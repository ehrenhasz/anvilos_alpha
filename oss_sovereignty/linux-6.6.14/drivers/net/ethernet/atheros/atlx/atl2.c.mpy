{
  "module_name": "atl2.c",
  "hash_id": "b1c683549725090a3f761a9416275bb08a6de663c44de08cf06bd1325d90815b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/atheros/atlx/atl2.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/crc32.h>\n#include <linux/dma-mapping.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/hardirq.h>\n#include <linux/if_vlan.h>\n#include <linux/in.h>\n#include <linux/interrupt.h>\n#include <linux/ip.h>\n#include <linux/irqflags.h>\n#include <linux/irqreturn.h>\n#include <linux/mii.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/pm.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/tcp.h>\n#include <linux/timer.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#include \"atl2.h\"\n\nstatic const char atl2_driver_name[] = \"atl2\";\nstatic const struct ethtool_ops atl2_ethtool_ops;\n\nMODULE_AUTHOR(\"Atheros Corporation <xiong.huang@atheros.com>, Chris Snook <csnook@redhat.com>\");\nMODULE_DESCRIPTION(\"Atheros Fast Ethernet Network Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic const struct pci_device_id atl2_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_ATTANSIC, PCI_DEVICE_ID_ATTANSIC_L2)},\n\t \n\t{0,}\n};\nMODULE_DEVICE_TABLE(pci, atl2_pci_tbl);\n\nstatic void atl2_check_options(struct atl2_adapter *adapter);\n\n \nstatic int atl2_sw_init(struct atl2_adapter *adapter)\n{\n\tstruct atl2_hw *hw = &adapter->hw;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\t \n\thw->vendor_id = pdev->vendor;\n\thw->device_id = pdev->device;\n\thw->subsystem_vendor_id = pdev->subsystem_vendor;\n\thw->subsystem_id = pdev->subsystem_device;\n\thw->revision_id  = pdev->revision;\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);\n\n\tadapter->wol = 0;\n\tadapter->ict = 50000;   \n\tadapter->link_speed = SPEED_0;    \n\tadapter->link_duplex = FULL_DUPLEX;\n\n\thw->phy_configured = false;\n\thw->preamble_len = 7;\n\thw->ipgt = 0x60;\n\thw->min_ifg = 0x50;\n\thw->ipgr1 = 0x40;\n\thw->ipgr2 = 0x60;\n\thw->retry_buf = 2;\n\thw->max_retry = 0xf;\n\thw->lcol = 0x37;\n\thw->jam_ipg = 7;\n\thw->fc_rxd_hi = 0;\n\thw->fc_rxd_lo = 0;\n\thw->max_frame_size = adapter->netdev->mtu;\n\n\tspin_lock_init(&adapter->stats_lock);\n\n\tset_bit(__ATL2_DOWN, &adapter->flags);\n\n\treturn 0;\n}\n\n \nstatic void atl2_set_multi(struct net_device *netdev)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tstruct atl2_hw *hw = &adapter->hw;\n\tstruct netdev_hw_addr *ha;\n\tu32 rctl;\n\tu32 hash_value;\n\n\t \n\trctl = ATL2_READ_REG(hw, REG_MAC_CTRL);\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\trctl |= MAC_CTRL_PROMIS_EN;\n\t} else if (netdev->flags & IFF_ALLMULTI) {\n\t\trctl |= MAC_CTRL_MC_ALL_EN;\n\t\trctl &= ~MAC_CTRL_PROMIS_EN;\n\t} else\n\t\trctl &= ~(MAC_CTRL_PROMIS_EN | MAC_CTRL_MC_ALL_EN);\n\n\tATL2_WRITE_REG(hw, REG_MAC_CTRL, rctl);\n\n\t \n\tATL2_WRITE_REG(hw, REG_RX_HASH_TABLE, 0);\n\tATL2_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, 1, 0);\n\n\t \n\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\thash_value = atl2_hash_mc_addr(hw, ha->addr);\n\t\tatl2_hash_set(hw, hash_value);\n\t}\n}\n\nstatic void init_ring_ptrs(struct atl2_adapter *adapter)\n{\n\t \n\tadapter->txd_write_ptr = 0;\n\tatomic_set(&adapter->txd_read_ptr, 0);\n\n\tadapter->rxd_read_ptr = 0;\n\tadapter->rxd_write_ptr = 0;\n\n\tatomic_set(&adapter->txs_write_ptr, 0);\n\tadapter->txs_next_clear = 0;\n}\n\n \nstatic int atl2_configure(struct atl2_adapter *adapter)\n{\n\tstruct atl2_hw *hw = &adapter->hw;\n\tu32 value;\n\n\t \n\tATL2_WRITE_REG(&adapter->hw, REG_ISR, 0xffffffff);\n\n\t \n\tvalue = (((u32)hw->mac_addr[2]) << 24) |\n\t\t(((u32)hw->mac_addr[3]) << 16) |\n\t\t(((u32)hw->mac_addr[4]) << 8) |\n\t\t(((u32)hw->mac_addr[5]));\n\tATL2_WRITE_REG(hw, REG_MAC_STA_ADDR, value);\n\tvalue = (((u32)hw->mac_addr[0]) << 8) |\n\t\t(((u32)hw->mac_addr[1]));\n\tATL2_WRITE_REG(hw, (REG_MAC_STA_ADDR+4), value);\n\n\t \n\tATL2_WRITE_REG(hw, REG_DESC_BASE_ADDR_HI,\n\t\t(u32)((adapter->ring_dma & 0xffffffff00000000ULL) >> 32));\n\n\t \n\tATL2_WRITE_REG(hw, REG_TXD_BASE_ADDR_LO,\n\t\t(u32)(adapter->txd_dma & 0x00000000ffffffffULL));\n\tATL2_WRITE_REG(hw, REG_TXS_BASE_ADDR_LO,\n\t\t(u32)(adapter->txs_dma & 0x00000000ffffffffULL));\n\tATL2_WRITE_REG(hw, REG_RXD_BASE_ADDR_LO,\n\t\t(u32)(adapter->rxd_dma & 0x00000000ffffffffULL));\n\n\t \n\tATL2_WRITE_REGW(hw, REG_TXD_MEM_SIZE, (u16)(adapter->txd_ring_size/4));\n\tATL2_WRITE_REGW(hw, REG_TXS_MEM_SIZE, (u16)adapter->txs_ring_size);\n\tATL2_WRITE_REGW(hw, REG_RXD_BUF_NUM,  (u16)adapter->rxd_ring_size);\n\n\t \n \n\n\t \n\tvalue = (((u32)hw->ipgt & MAC_IPG_IFG_IPGT_MASK) <<\n\t\tMAC_IPG_IFG_IPGT_SHIFT) |\n\t\t(((u32)hw->min_ifg & MAC_IPG_IFG_MIFG_MASK) <<\n\t\tMAC_IPG_IFG_MIFG_SHIFT) |\n\t\t(((u32)hw->ipgr1 & MAC_IPG_IFG_IPGR1_MASK) <<\n\t\tMAC_IPG_IFG_IPGR1_SHIFT)|\n\t\t(((u32)hw->ipgr2 & MAC_IPG_IFG_IPGR2_MASK) <<\n\t\tMAC_IPG_IFG_IPGR2_SHIFT);\n\tATL2_WRITE_REG(hw, REG_MAC_IPG_IFG, value);\n\n\t \n\tvalue = ((u32)hw->lcol & MAC_HALF_DUPLX_CTRL_LCOL_MASK) |\n\t\t(((u32)hw->max_retry & MAC_HALF_DUPLX_CTRL_RETRY_MASK) <<\n\t\tMAC_HALF_DUPLX_CTRL_RETRY_SHIFT) |\n\t\tMAC_HALF_DUPLX_CTRL_EXC_DEF_EN |\n\t\t(0xa << MAC_HALF_DUPLX_CTRL_ABEBT_SHIFT) |\n\t\t(((u32)hw->jam_ipg & MAC_HALF_DUPLX_CTRL_JAMIPG_MASK) <<\n\t\tMAC_HALF_DUPLX_CTRL_JAMIPG_SHIFT);\n\tATL2_WRITE_REG(hw, REG_MAC_HALF_DUPLX_CTRL, value);\n\n\t \n\tATL2_WRITE_REGW(hw, REG_IRQ_MODU_TIMER_INIT, adapter->imt);\n\tATL2_WRITE_REG(hw, REG_MASTER_CTRL, MASTER_CTRL_ITIMER_EN);\n\n\t \n\tATL2_WRITE_REGW(hw, REG_CMBDISDMA_TIMER, adapter->ict);\n\n\t \n\tATL2_WRITE_REG(hw, REG_MTU, adapter->netdev->mtu +\n\t\tETH_HLEN + VLAN_HLEN + ETH_FCS_LEN);\n\n\t \n\tATL2_WRITE_REG(hw, REG_TX_CUT_THRESH, 0x177);\n\n\t \n\tATL2_WRITE_REGW(hw, REG_PAUSE_ON_TH, hw->fc_rxd_hi);\n\tATL2_WRITE_REGW(hw, REG_PAUSE_OFF_TH, hw->fc_rxd_lo);\n\n\t \n\tATL2_WRITE_REGW(hw, REG_MB_TXD_WR_IDX, (u16)adapter->txd_write_ptr);\n\tATL2_WRITE_REGW(hw, REG_MB_RXD_RD_IDX, (u16)adapter->rxd_read_ptr);\n\n\t \n\tATL2_WRITE_REGB(hw, REG_DMAR, DMAR_EN);\n\tATL2_WRITE_REGB(hw, REG_DMAW, DMAW_EN);\n\n\tvalue = ATL2_READ_REG(&adapter->hw, REG_ISR);\n\tif ((value & ISR_PHY_LINKDOWN) != 0)\n\t\tvalue = 1;  \n\telse\n\t\tvalue = 0;\n\n\t \n\tATL2_WRITE_REG(&adapter->hw, REG_ISR, 0x3fffffff);\n\tATL2_WRITE_REG(&adapter->hw, REG_ISR, 0);\n\treturn value;\n}\n\n \nstatic s32 atl2_setup_ring_resources(struct atl2_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tint size;\n\tu8 offset = 0;\n\n\t \n\tadapter->ring_size = size =\n\t\tadapter->txd_ring_size * 1 + 7 +\t \n\t\tadapter->txs_ring_size * 4 + 7 +\t \n\t\tadapter->rxd_ring_size * 1536 + 127;\t \n\n\tadapter->ring_vir_addr = dma_alloc_coherent(&pdev->dev, size,\n\t\t\t\t\t\t    &adapter->ring_dma, GFP_KERNEL);\n\tif (!adapter->ring_vir_addr)\n\t\treturn -ENOMEM;\n\n\t \n\tadapter->txd_dma = adapter->ring_dma ;\n\toffset = (adapter->txd_dma & 0x7) ? (8 - (adapter->txd_dma & 0x7)) : 0;\n\tadapter->txd_dma += offset;\n\tadapter->txd_ring = adapter->ring_vir_addr + offset;\n\n\t \n\tadapter->txs_dma = adapter->txd_dma + adapter->txd_ring_size;\n\toffset = (adapter->txs_dma & 0x7) ? (8 - (adapter->txs_dma & 0x7)) : 0;\n\tadapter->txs_dma += offset;\n\tadapter->txs_ring = (struct tx_pkt_status *)\n\t\t(((u8 *)adapter->txd_ring) + (adapter->txd_ring_size + offset));\n\n\t \n\tadapter->rxd_dma = adapter->txs_dma + adapter->txs_ring_size * 4;\n\toffset = (adapter->rxd_dma & 127) ?\n\t\t(128 - (adapter->rxd_dma & 127)) : 0;\n\tif (offset > 7)\n\t\toffset -= 8;\n\telse\n\t\toffset += (128 - 8);\n\n\tadapter->rxd_dma += offset;\n\tadapter->rxd_ring = (struct rx_desc *) (((u8 *)adapter->txs_ring) +\n\t\t(adapter->txs_ring_size * 4 + offset));\n\n \n\treturn 0;\n}\n\n \nstatic inline void atl2_irq_enable(struct atl2_adapter *adapter)\n{\n\tATL2_WRITE_REG(&adapter->hw, REG_IMR, IMR_NORMAL_MASK);\n\tATL2_WRITE_FLUSH(&adapter->hw);\n}\n\n \nstatic inline void atl2_irq_disable(struct atl2_adapter *adapter)\n{\n    ATL2_WRITE_REG(&adapter->hw, REG_IMR, 0);\n    ATL2_WRITE_FLUSH(&adapter->hw);\n    synchronize_irq(adapter->pdev->irq);\n}\n\nstatic void __atl2_vlan_mode(netdev_features_t features, u32 *ctrl)\n{\n\tif (features & NETIF_F_HW_VLAN_CTAG_RX) {\n\t\t \n\t\t*ctrl |= MAC_CTRL_RMV_VLAN;\n\t} else {\n\t\t \n\t\t*ctrl &= ~MAC_CTRL_RMV_VLAN;\n\t}\n}\n\nstatic void atl2_vlan_mode(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tu32 ctrl;\n\n\tatl2_irq_disable(adapter);\n\n\tctrl = ATL2_READ_REG(&adapter->hw, REG_MAC_CTRL);\n\t__atl2_vlan_mode(features, &ctrl);\n\tATL2_WRITE_REG(&adapter->hw, REG_MAC_CTRL, ctrl);\n\n\tatl2_irq_enable(adapter);\n}\n\nstatic void atl2_restore_vlan(struct atl2_adapter *adapter)\n{\n\tatl2_vlan_mode(adapter->netdev, adapter->netdev->features);\n}\n\nstatic netdev_features_t atl2_fix_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\t \n\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\n\telse\n\t\tfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\n\n\treturn features;\n}\n\nstatic int atl2_set_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\tnetdev_features_t changed = netdev->features ^ features;\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tatl2_vlan_mode(netdev, features);\n\n\treturn 0;\n}\n\nstatic void atl2_intr_rx(struct atl2_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct rx_desc *rxd;\n\tstruct sk_buff *skb;\n\n\tdo {\n\t\trxd = adapter->rxd_ring+adapter->rxd_write_ptr;\n\t\tif (!rxd->status.update)\n\t\t\tbreak;  \n\n\t\t \n\t\trxd->status.update = 0;\n\n\t\tif (rxd->status.ok && rxd->status.pkt_size >= 60) {\n\t\t\tint rx_size = (int)(rxd->status.pkt_size - 4);\n\t\t\t \n\t\t\tskb = netdev_alloc_skb_ip_align(netdev, rx_size);\n\t\t\tif (NULL == skb) {\n\t\t\t\t \n\t\t\t\tnetdev->stats.rx_dropped++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(skb->data, rxd->packet, rx_size);\n\t\t\tskb_put(skb, rx_size);\n\t\t\tskb->protocol = eth_type_trans(skb, netdev);\n\t\t\tif (rxd->status.vlan) {\n\t\t\t\tu16 vlan_tag = (rxd->status.vtag>>4) |\n\t\t\t\t\t((rxd->status.vtag&7) << 13) |\n\t\t\t\t\t((rxd->status.vtag&8) << 9);\n\n\t\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlan_tag);\n\t\t\t}\n\t\t\tnetif_rx(skb);\n\t\t\tnetdev->stats.rx_bytes += rx_size;\n\t\t\tnetdev->stats.rx_packets++;\n\t\t} else {\n\t\t\tnetdev->stats.rx_errors++;\n\n\t\t\tif (rxd->status.ok && rxd->status.pkt_size <= 60)\n\t\t\t\tnetdev->stats.rx_length_errors++;\n\t\t\tif (rxd->status.mcast)\n\t\t\t\tnetdev->stats.multicast++;\n\t\t\tif (rxd->status.crc)\n\t\t\t\tnetdev->stats.rx_crc_errors++;\n\t\t\tif (rxd->status.align)\n\t\t\t\tnetdev->stats.rx_frame_errors++;\n\t\t}\n\n\t\t \n\t\tif (++adapter->rxd_write_ptr == adapter->rxd_ring_size)\n\t\t\tadapter->rxd_write_ptr = 0;\n\t} while (1);\n\n\t \n\tadapter->rxd_read_ptr = adapter->rxd_write_ptr;\n\tATL2_WRITE_REGW(&adapter->hw, REG_MB_RXD_RD_IDX, adapter->rxd_read_ptr);\n}\n\nstatic void atl2_intr_tx(struct atl2_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tu32 txd_read_ptr;\n\tu32 txs_write_ptr;\n\tstruct tx_pkt_status *txs;\n\tstruct tx_pkt_header *txph;\n\tint free_hole = 0;\n\n\tdo {\n\t\ttxs_write_ptr = (u32) atomic_read(&adapter->txs_write_ptr);\n\t\ttxs = adapter->txs_ring + txs_write_ptr;\n\t\tif (!txs->update)\n\t\t\tbreak;  \n\n\t\tfree_hole = 1;\n\t\ttxs->update = 0;\n\n\t\tif (++txs_write_ptr == adapter->txs_ring_size)\n\t\t\ttxs_write_ptr = 0;\n\t\tatomic_set(&adapter->txs_write_ptr, (int)txs_write_ptr);\n\n\t\ttxd_read_ptr = (u32) atomic_read(&adapter->txd_read_ptr);\n\t\ttxph = (struct tx_pkt_header *)\n\t\t\t(((u8 *)adapter->txd_ring) + txd_read_ptr);\n\n\t\tif (txph->pkt_size != txs->pkt_size) {\n\t\t\tstruct tx_pkt_status *old_txs = txs;\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"%s: txs packet size not consistent with txd\"\n\t\t\t\t\" txd_:0x%08x, txs_:0x%08x!\\n\",\n\t\t\t\tadapter->netdev->name,\n\t\t\t\t*(u32 *)txph, *(u32 *)txs);\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"txd read ptr: 0x%x\\n\",\n\t\t\t\ttxd_read_ptr);\n\t\t\ttxs = adapter->txs_ring + txs_write_ptr;\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"txs-behind:0x%08x\\n\",\n\t\t\t\t*(u32 *)txs);\n\t\t\tif (txs_write_ptr < 2) {\n\t\t\t\ttxs = adapter->txs_ring +\n\t\t\t\t\t(adapter->txs_ring_size +\n\t\t\t\t\ttxs_write_ptr - 2);\n\t\t\t} else {\n\t\t\t\ttxs = adapter->txs_ring + (txs_write_ptr - 2);\n\t\t\t}\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"txs-before:0x%08x\\n\",\n\t\t\t\t*(u32 *)txs);\n\t\t\ttxs = old_txs;\n\t\t}\n\n\t\t  \n\t\ttxd_read_ptr += (((u32)(txph->pkt_size) + 7) & ~3);\n\t\tif (txd_read_ptr >= adapter->txd_ring_size)\n\t\t\ttxd_read_ptr -= adapter->txd_ring_size;\n\n\t\tatomic_set(&adapter->txd_read_ptr, (int)txd_read_ptr);\n\n\t\t \n\t\tif (txs->ok) {\n\t\t\tnetdev->stats.tx_bytes += txs->pkt_size;\n\t\t\tnetdev->stats.tx_packets++;\n\t\t}\n\t\telse\n\t\t\tnetdev->stats.tx_errors++;\n\n\t\tif (txs->defer)\n\t\t\tnetdev->stats.collisions++;\n\t\tif (txs->abort_col)\n\t\t\tnetdev->stats.tx_aborted_errors++;\n\t\tif (txs->late_col)\n\t\t\tnetdev->stats.tx_window_errors++;\n\t\tif (txs->underrun)\n\t\t\tnetdev->stats.tx_fifo_errors++;\n\t} while (1);\n\n\tif (free_hole) {\n\t\tif (netif_queue_stopped(adapter->netdev) &&\n\t\t\tnetif_carrier_ok(adapter->netdev))\n\t\t\tnetif_wake_queue(adapter->netdev);\n\t}\n}\n\nstatic void atl2_check_for_link(struct atl2_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tu16 phy_data = 0;\n\n\tspin_lock(&adapter->stats_lock);\n\tatl2_read_phy_reg(&adapter->hw, MII_BMSR, &phy_data);\n\tatl2_read_phy_reg(&adapter->hw, MII_BMSR, &phy_data);\n\tspin_unlock(&adapter->stats_lock);\n\n\t \n\tif (!(phy_data & BMSR_LSTATUS)) {  \n\t\tif (netif_carrier_ok(netdev)) {  \n\t\tprintk(KERN_INFO \"%s: %s NIC Link is Down\\n\",\n\t\t\tatl2_driver_name, netdev->name);\n\t\tadapter->link_speed = SPEED_0;\n\t\tnetif_carrier_off(netdev);\n\t\tnetif_stop_queue(netdev);\n\t\t}\n\t}\n\tschedule_work(&adapter->link_chg_task);\n}\n\nstatic inline void atl2_clear_phy_int(struct atl2_adapter *adapter)\n{\n\tu16 phy_data;\n\tspin_lock(&adapter->stats_lock);\n\tatl2_read_phy_reg(&adapter->hw, 19, &phy_data);\n\tspin_unlock(&adapter->stats_lock);\n}\n\n \nstatic irqreturn_t atl2_intr(int irq, void *data)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(data);\n\tstruct atl2_hw *hw = &adapter->hw;\n\tu32 status;\n\n\tstatus = ATL2_READ_REG(hw, REG_ISR);\n\tif (0 == status)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (status & ISR_PHY)\n\t\tatl2_clear_phy_int(adapter);\n\n\t \n\tATL2_WRITE_REG(hw, REG_ISR, status | ISR_DIS_INT);\n\n\t \n\tif (status & ISR_PHY_LINKDOWN) {\n\t\tif (netif_running(adapter->netdev)) {  \n\t\t\tATL2_WRITE_REG(hw, REG_ISR, 0);\n\t\t\tATL2_WRITE_REG(hw, REG_IMR, 0);\n\t\t\tATL2_WRITE_FLUSH(hw);\n\t\t\tschedule_work(&adapter->reset_task);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\n\t \n\tif (status & (ISR_DMAR_TO_RST | ISR_DMAW_TO_RST)) {\n\t\tATL2_WRITE_REG(hw, REG_ISR, 0);\n\t\tATL2_WRITE_REG(hw, REG_IMR, 0);\n\t\tATL2_WRITE_FLUSH(hw);\n\t\tschedule_work(&adapter->reset_task);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (status & (ISR_PHY | ISR_MANUAL)) {\n\t\tadapter->netdev->stats.tx_carrier_errors++;\n\t\tatl2_check_for_link(adapter);\n\t}\n\n\t \n\tif (status & ISR_TX_EVENT)\n\t\tatl2_intr_tx(adapter);\n\n\t \n\tif (status & ISR_RX_EVENT)\n\t\tatl2_intr_rx(adapter);\n\n\t \n\tATL2_WRITE_REG(&adapter->hw, REG_ISR, 0);\n\treturn IRQ_HANDLED;\n}\n\nstatic int atl2_request_irq(struct atl2_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint flags, err = 0;\n\n\tflags = IRQF_SHARED;\n\tadapter->have_msi = true;\n\terr = pci_enable_msi(adapter->pdev);\n\tif (err)\n\t\tadapter->have_msi = false;\n\n\tif (adapter->have_msi)\n\t\tflags &= ~IRQF_SHARED;\n\n\treturn request_irq(adapter->pdev->irq, atl2_intr, flags, netdev->name,\n\t\tnetdev);\n}\n\n \nstatic void atl2_free_ring_resources(struct atl2_adapter *adapter)\n{\n\tstruct pci_dev *pdev = adapter->pdev;\n\tdma_free_coherent(&pdev->dev, adapter->ring_size,\n\t\t\t  adapter->ring_vir_addr, adapter->ring_dma);\n}\n\n \nstatic int atl2_open(struct net_device *netdev)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tint err;\n\tu32 val;\n\n\t \n\tif (test_bit(__ATL2_TESTING, &adapter->flags))\n\t\treturn -EBUSY;\n\n\t \n\terr = atl2_setup_ring_resources(adapter);\n\tif (err)\n\t\treturn err;\n\n\terr = atl2_init_hw(&adapter->hw);\n\tif (err) {\n\t\terr = -EIO;\n\t\tgoto err_init_hw;\n\t}\n\n\t \n\tatl2_set_multi(netdev);\n\tinit_ring_ptrs(adapter);\n\n\tatl2_restore_vlan(adapter);\n\n\tif (atl2_configure(adapter)) {\n\t\terr = -EIO;\n\t\tgoto err_config;\n\t}\n\n\terr = atl2_request_irq(adapter);\n\tif (err)\n\t\tgoto err_req_irq;\n\n\tclear_bit(__ATL2_DOWN, &adapter->flags);\n\n\tmod_timer(&adapter->watchdog_timer, round_jiffies(jiffies + 4*HZ));\n\n\tval = ATL2_READ_REG(&adapter->hw, REG_MASTER_CTRL);\n\tATL2_WRITE_REG(&adapter->hw, REG_MASTER_CTRL,\n\t\tval | MASTER_CTRL_MANUAL_INT);\n\n\tatl2_irq_enable(adapter);\n\n\treturn 0;\n\nerr_init_hw:\nerr_req_irq:\nerr_config:\n\tatl2_free_ring_resources(adapter);\n\tatl2_reset_hw(&adapter->hw);\n\n\treturn err;\n}\n\nstatic void atl2_down(struct atl2_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\t \n\tset_bit(__ATL2_DOWN, &adapter->flags);\n\n\tnetif_tx_disable(netdev);\n\n\t \n\tatl2_reset_hw(&adapter->hw);\n\tmsleep(1);\n\n\tatl2_irq_disable(adapter);\n\n\tdel_timer_sync(&adapter->watchdog_timer);\n\tdel_timer_sync(&adapter->phy_config_timer);\n\tclear_bit(0, &adapter->cfg_phy);\n\n\tnetif_carrier_off(netdev);\n\tadapter->link_speed = SPEED_0;\n\tadapter->link_duplex = -1;\n}\n\nstatic void atl2_free_irq(struct atl2_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tfree_irq(adapter->pdev->irq, netdev);\n\n#ifdef CONFIG_PCI_MSI\n\tif (adapter->have_msi)\n\t\tpci_disable_msi(adapter->pdev);\n#endif\n}\n\n \nstatic int atl2_close(struct net_device *netdev)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\n\tWARN_ON(test_bit(__ATL2_RESETTING, &adapter->flags));\n\n\tatl2_down(adapter);\n\tatl2_free_irq(adapter);\n\tatl2_free_ring_resources(adapter);\n\n\treturn 0;\n}\n\nstatic inline int TxsFreeUnit(struct atl2_adapter *adapter)\n{\n\tu32 txs_write_ptr = (u32) atomic_read(&adapter->txs_write_ptr);\n\n\treturn (adapter->txs_next_clear >= txs_write_ptr) ?\n\t\t(int) (adapter->txs_ring_size - adapter->txs_next_clear +\n\t\ttxs_write_ptr - 1) :\n\t\t(int) (txs_write_ptr - adapter->txs_next_clear - 1);\n}\n\nstatic inline int TxdFreeBytes(struct atl2_adapter *adapter)\n{\n\tu32 txd_read_ptr = (u32)atomic_read(&adapter->txd_read_ptr);\n\n\treturn (adapter->txd_write_ptr >= txd_read_ptr) ?\n\t\t(int) (adapter->txd_ring_size - adapter->txd_write_ptr +\n\t\ttxd_read_ptr - 1) :\n\t\t(int) (txd_read_ptr - adapter->txd_write_ptr - 1);\n}\n\nstatic netdev_tx_t atl2_xmit_frame(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *netdev)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tstruct tx_pkt_header *txph;\n\tu32 offset, copy_len;\n\tint txs_unused;\n\tint txbuf_unused;\n\n\tif (test_bit(__ATL2_DOWN, &adapter->flags)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (unlikely(skb->len <= 0)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\ttxs_unused = TxsFreeUnit(adapter);\n\ttxbuf_unused = TxdFreeBytes(adapter);\n\n\tif (skb->len + sizeof(struct tx_pkt_header) + 4  > txbuf_unused ||\n\t\ttxs_unused < 1) {\n\t\t \n\t\tnetif_stop_queue(netdev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\toffset = adapter->txd_write_ptr;\n\n\ttxph = (struct tx_pkt_header *) (((u8 *)adapter->txd_ring) + offset);\n\n\t*(u32 *)txph = 0;\n\ttxph->pkt_size = skb->len;\n\n\toffset += 4;\n\tif (offset >= adapter->txd_ring_size)\n\t\toffset -= adapter->txd_ring_size;\n\tcopy_len = adapter->txd_ring_size - offset;\n\tif (copy_len >= skb->len) {\n\t\tmemcpy(((u8 *)adapter->txd_ring) + offset, skb->data, skb->len);\n\t\toffset += ((u32)(skb->len + 3) & ~3);\n\t} else {\n\t\tmemcpy(((u8 *)adapter->txd_ring)+offset, skb->data, copy_len);\n\t\tmemcpy((u8 *)adapter->txd_ring, skb->data+copy_len,\n\t\t\tskb->len-copy_len);\n\t\toffset = ((u32)(skb->len-copy_len + 3) & ~3);\n\t}\n#ifdef NETIF_F_HW_VLAN_CTAG_TX\n\tif (skb_vlan_tag_present(skb)) {\n\t\tu16 vlan_tag = skb_vlan_tag_get(skb);\n\t\tvlan_tag = (vlan_tag << 4) |\n\t\t\t(vlan_tag >> 13) |\n\t\t\t((vlan_tag >> 9) & 0x8);\n\t\ttxph->ins_vlan = 1;\n\t\ttxph->vlan = vlan_tag;\n\t}\n#endif\n\tif (offset >= adapter->txd_ring_size)\n\t\toffset -= adapter->txd_ring_size;\n\tadapter->txd_write_ptr = offset;\n\n\t \n\tadapter->txs_ring[adapter->txs_next_clear].update = 0;\n\tif (++adapter->txs_next_clear == adapter->txs_ring_size)\n\t\tadapter->txs_next_clear = 0;\n\n\tATL2_WRITE_REGW(&adapter->hw, REG_MB_TXD_WR_IDX,\n\t\t(adapter->txd_write_ptr >> 2));\n\n\tdev_consume_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic int atl2_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tstruct atl2_hw *hw = &adapter->hw;\n\n\t \n\tnetdev->mtu = new_mtu;\n\thw->max_frame_size = new_mtu;\n\tATL2_WRITE_REG(hw, REG_MTU, new_mtu + ETH_HLEN +\n\t\t       VLAN_HLEN + ETH_FCS_LEN);\n\n\treturn 0;\n}\n\n \nstatic int atl2_set_mac(struct net_device *netdev, void *p)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (netif_running(netdev))\n\t\treturn -EBUSY;\n\n\teth_hw_addr_set(netdev, addr->sa_data);\n\tmemcpy(adapter->hw.mac_addr, addr->sa_data, netdev->addr_len);\n\n\tatl2_set_mac_addr(&adapter->hw);\n\n\treturn 0;\n}\n\nstatic int atl2_mii_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\tunsigned long flags;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tdata->phy_id = 0;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\t\tspin_lock_irqsave(&adapter->stats_lock, flags);\n\t\tif (atl2_read_phy_reg(&adapter->hw,\n\t\t\tdata->reg_num & 0x1F, &data->val_out)) {\n\t\t\tspin_unlock_irqrestore(&adapter->stats_lock, flags);\n\t\t\treturn -EIO;\n\t\t}\n\t\tspin_unlock_irqrestore(&adapter->stats_lock, flags);\n\t\tbreak;\n\tcase SIOCSMIIREG:\n\t\tif (data->reg_num & ~(0x1F))\n\t\t\treturn -EFAULT;\n\t\tspin_lock_irqsave(&adapter->stats_lock, flags);\n\t\tif (atl2_write_phy_reg(&adapter->hw, data->reg_num,\n\t\t\tdata->val_in)) {\n\t\t\tspin_unlock_irqrestore(&adapter->stats_lock, flags);\n\t\t\treturn -EIO;\n\t\t}\n\t\tspin_unlock_irqrestore(&adapter->stats_lock, flags);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int atl2_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn atl2_mii_ioctl(netdev, ifr, cmd);\n#ifdef ETHTOOL_OPS_COMPAT\n\tcase SIOCETHTOOL:\n\t\treturn ethtool_ioctl(ifr);\n#endif\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic void atl2_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tschedule_work(&adapter->reset_task);\n}\n\n \nstatic void atl2_watchdog(struct timer_list *t)\n{\n\tstruct atl2_adapter *adapter = from_timer(adapter, t, watchdog_timer);\n\n\tif (!test_bit(__ATL2_DOWN, &adapter->flags)) {\n\t\tu32 drop_rxd, drop_rxs;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&adapter->stats_lock, flags);\n\t\tdrop_rxd = ATL2_READ_REG(&adapter->hw, REG_STS_RXD_OV);\n\t\tdrop_rxs = ATL2_READ_REG(&adapter->hw, REG_STS_RXS_OV);\n\t\tspin_unlock_irqrestore(&adapter->stats_lock, flags);\n\n\t\tadapter->netdev->stats.rx_over_errors += drop_rxd + drop_rxs;\n\n\t\t \n\t\tmod_timer(&adapter->watchdog_timer,\n\t\t\t  round_jiffies(jiffies + 4 * HZ));\n\t}\n}\n\n \nstatic void atl2_phy_config(struct timer_list *t)\n{\n\tstruct atl2_adapter *adapter = from_timer(adapter, t,\n\t\t\t\t\t\t  phy_config_timer);\n\tstruct atl2_hw *hw = &adapter->hw;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->stats_lock, flags);\n\tatl2_write_phy_reg(hw, MII_ADVERTISE, hw->mii_autoneg_adv_reg);\n\tatl2_write_phy_reg(hw, MII_BMCR, MII_CR_RESET | MII_CR_AUTO_NEG_EN |\n\t\tMII_CR_RESTART_AUTO_NEG);\n\tspin_unlock_irqrestore(&adapter->stats_lock, flags);\n\tclear_bit(0, &adapter->cfg_phy);\n}\n\nstatic int atl2_up(struct atl2_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint err = 0;\n\tu32 val;\n\n\t \n\n\terr = atl2_init_hw(&adapter->hw);\n\tif (err) {\n\t\terr = -EIO;\n\t\treturn err;\n\t}\n\n\tatl2_set_multi(netdev);\n\tinit_ring_ptrs(adapter);\n\n\tatl2_restore_vlan(adapter);\n\n\tif (atl2_configure(adapter)) {\n\t\terr = -EIO;\n\t\tgoto err_up;\n\t}\n\n\tclear_bit(__ATL2_DOWN, &adapter->flags);\n\n\tval = ATL2_READ_REG(&adapter->hw, REG_MASTER_CTRL);\n\tATL2_WRITE_REG(&adapter->hw, REG_MASTER_CTRL, val |\n\t\tMASTER_CTRL_MANUAL_INT);\n\n\tatl2_irq_enable(adapter);\n\nerr_up:\n\treturn err;\n}\n\nstatic void atl2_reinit_locked(struct atl2_adapter *adapter)\n{\n\twhile (test_and_set_bit(__ATL2_RESETTING, &adapter->flags))\n\t\tmsleep(1);\n\tatl2_down(adapter);\n\tatl2_up(adapter);\n\tclear_bit(__ATL2_RESETTING, &adapter->flags);\n}\n\nstatic void atl2_reset_task(struct work_struct *work)\n{\n\tstruct atl2_adapter *adapter;\n\tadapter = container_of(work, struct atl2_adapter, reset_task);\n\n\tatl2_reinit_locked(adapter);\n}\n\nstatic void atl2_setup_mac_ctrl(struct atl2_adapter *adapter)\n{\n\tu32 value;\n\tstruct atl2_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\n\t \n\tvalue = MAC_CTRL_TX_EN | MAC_CTRL_RX_EN | MAC_CTRL_MACLP_CLK_PHY;\n\n\t \n\tif (FULL_DUPLEX == adapter->link_duplex)\n\t\tvalue |= MAC_CTRL_DUPLX;\n\n\t \n\tvalue |= (MAC_CTRL_TX_FLOW | MAC_CTRL_RX_FLOW);\n\n\t \n\tvalue |= (MAC_CTRL_ADD_CRC | MAC_CTRL_PAD);\n\n\t \n\tvalue |= (((u32)adapter->hw.preamble_len & MAC_CTRL_PRMLEN_MASK) <<\n\t\tMAC_CTRL_PRMLEN_SHIFT);\n\n\t \n\t__atl2_vlan_mode(netdev->features, &value);\n\n\t \n\tvalue |= MAC_CTRL_BC_EN;\n\tif (netdev->flags & IFF_PROMISC)\n\t\tvalue |= MAC_CTRL_PROMIS_EN;\n\telse if (netdev->flags & IFF_ALLMULTI)\n\t\tvalue |= MAC_CTRL_MC_ALL_EN;\n\n\t \n\tvalue |= (((u32)(adapter->hw.retry_buf &\n\t\tMAC_CTRL_HALF_LEFT_BUF_MASK)) << MAC_CTRL_HALF_LEFT_BUF_SHIFT);\n\n\tATL2_WRITE_REG(hw, REG_MAC_CTRL, value);\n}\n\nstatic int atl2_check_link(struct atl2_adapter *adapter)\n{\n\tstruct atl2_hw *hw = &adapter->hw;\n\tstruct net_device *netdev = adapter->netdev;\n\tint ret_val;\n\tu16 speed, duplex, phy_data;\n\tint reconfig = 0;\n\n\t \n\tatl2_read_phy_reg(hw, MII_BMSR, &phy_data);\n\tatl2_read_phy_reg(hw, MII_BMSR, &phy_data);\n\tif (!(phy_data&BMSR_LSTATUS)) {  \n\t\tif (netif_carrier_ok(netdev)) {  \n\t\t\tu32 value;\n\t\t\t \n\t\t\tvalue = ATL2_READ_REG(hw, REG_MAC_CTRL);\n\t\t\tvalue &= ~MAC_CTRL_RX_EN;\n\t\t\tATL2_WRITE_REG(hw, REG_MAC_CTRL, value);\n\t\t\tadapter->link_speed = SPEED_0;\n\t\t\tnetif_carrier_off(netdev);\n\t\t\tnetif_stop_queue(netdev);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tret_val = atl2_get_speed_and_duplex(hw, &speed, &duplex);\n\tif (ret_val)\n\t\treturn ret_val;\n\tswitch (hw->MediaType) {\n\tcase MEDIA_TYPE_100M_FULL:\n\t\tif (speed  != SPEED_100 || duplex != FULL_DUPLEX)\n\t\t\treconfig = 1;\n\t\tbreak;\n\tcase MEDIA_TYPE_100M_HALF:\n\t\tif (speed  != SPEED_100 || duplex != HALF_DUPLEX)\n\t\t\treconfig = 1;\n\t\tbreak;\n\tcase MEDIA_TYPE_10M_FULL:\n\t\tif (speed != SPEED_10 || duplex != FULL_DUPLEX)\n\t\t\treconfig = 1;\n\t\tbreak;\n\tcase MEDIA_TYPE_10M_HALF:\n\t\tif (speed  != SPEED_10 || duplex != HALF_DUPLEX)\n\t\t\treconfig = 1;\n\t\tbreak;\n\t}\n\t \n\tif (reconfig == 0) {\n\t\tif (adapter->link_speed != speed ||\n\t\t\tadapter->link_duplex != duplex) {\n\t\t\tadapter->link_speed = speed;\n\t\t\tadapter->link_duplex = duplex;\n\t\t\tatl2_setup_mac_ctrl(adapter);\n\t\t\tprintk(KERN_INFO \"%s: %s NIC Link is Up<%d Mbps %s>\\n\",\n\t\t\t\tatl2_driver_name, netdev->name,\n\t\t\t\tadapter->link_speed,\n\t\t\t\tadapter->link_duplex == FULL_DUPLEX ?\n\t\t\t\t\t\"Full Duplex\" : \"Half Duplex\");\n\t\t}\n\n\t\tif (!netif_carrier_ok(netdev)) {  \n\t\t\tnetif_carrier_on(netdev);\n\t\t\tnetif_wake_queue(netdev);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tif (netif_carrier_ok(netdev)) {\n\t\tu32 value;\n\t\t \n\t\tvalue = ATL2_READ_REG(hw, REG_MAC_CTRL);\n\t\tvalue &= ~MAC_CTRL_RX_EN;\n\t\tATL2_WRITE_REG(hw, REG_MAC_CTRL, value);\n\n\t\tadapter->link_speed = SPEED_0;\n\t\tnetif_carrier_off(netdev);\n\t\tnetif_stop_queue(netdev);\n\t}\n\n\t \n\tif (!test_bit(__ATL2_DOWN, &adapter->flags)) {\n\t\tif (!test_and_set_bit(0, &adapter->cfg_phy))\n\t\t\tmod_timer(&adapter->phy_config_timer,\n\t\t\t\t  round_jiffies(jiffies + 5 * HZ));\n\t}\n\n\treturn 0;\n}\n\n \nstatic void atl2_link_chg_task(struct work_struct *work)\n{\n\tstruct atl2_adapter *adapter;\n\tunsigned long flags;\n\n\tadapter = container_of(work, struct atl2_adapter, link_chg_task);\n\n\tspin_lock_irqsave(&adapter->stats_lock, flags);\n\tatl2_check_link(adapter);\n\tspin_unlock_irqrestore(&adapter->stats_lock, flags);\n}\n\nstatic void atl2_setup_pcicmd(struct pci_dev *pdev)\n{\n\tu16 cmd;\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &cmd);\n\n\tif (cmd & PCI_COMMAND_INTX_DISABLE)\n\t\tcmd &= ~PCI_COMMAND_INTX_DISABLE;\n\tif (cmd & PCI_COMMAND_IO)\n\t\tcmd &= ~PCI_COMMAND_IO;\n\tif (0 == (cmd & PCI_COMMAND_MEMORY))\n\t\tcmd |= PCI_COMMAND_MEMORY;\n\tif (0 == (cmd & PCI_COMMAND_MASTER))\n\t\tcmd |= PCI_COMMAND_MASTER;\n\tpci_write_config_word(pdev, PCI_COMMAND, cmd);\n\n\t \n\tpci_write_config_dword(pdev, REG_PM_CTRLSTAT, 0);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void atl2_poll_controller(struct net_device *netdev)\n{\n\tdisable_irq(netdev->irq);\n\tatl2_intr(netdev->irq, netdev);\n\tenable_irq(netdev->irq);\n}\n#endif\n\n\nstatic const struct net_device_ops atl2_netdev_ops = {\n\t.ndo_open\t\t= atl2_open,\n\t.ndo_stop\t\t= atl2_close,\n\t.ndo_start_xmit\t\t= atl2_xmit_frame,\n\t.ndo_set_rx_mode\t= atl2_set_multi,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= atl2_set_mac,\n\t.ndo_change_mtu\t\t= atl2_change_mtu,\n\t.ndo_fix_features\t= atl2_fix_features,\n\t.ndo_set_features\t= atl2_set_features,\n\t.ndo_eth_ioctl\t\t= atl2_ioctl,\n\t.ndo_tx_timeout\t\t= atl2_tx_timeout,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= atl2_poll_controller,\n#endif\n};\n\n \nstatic int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev;\n\tstruct atl2_adapter *adapter;\n\tstatic int cards_found = 0;\n\tunsigned long mmio_start;\n\tint mmio_len;\n\tint err;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32)) &&\n\t    dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tprintk(KERN_ERR \"atl2: No usable DMA configuration, aborting\\n\");\n\t\terr = -EIO;\n\t\tgoto err_dma;\n\t}\n\n\t \n\terr = pci_request_regions(pdev, atl2_driver_name);\n\tif (err)\n\t\tgoto err_pci_reg;\n\n\t \n\tpci_set_master(pdev);\n\n\tnetdev = alloc_etherdev(sizeof(struct atl2_adapter));\n\tif (!netdev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_etherdev;\n\t}\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\tpci_set_drvdata(pdev, netdev);\n\tadapter = netdev_priv(netdev);\n\tadapter->netdev = netdev;\n\tadapter->pdev = pdev;\n\tadapter->hw.back = adapter;\n\n\tmmio_start = pci_resource_start(pdev, 0x0);\n\tmmio_len = pci_resource_len(pdev, 0x0);\n\n\tadapter->hw.mem_rang = (u32)mmio_len;\n\tadapter->hw.hw_addr = ioremap(mmio_start, mmio_len);\n\tif (!adapter->hw.hw_addr) {\n\t\terr = -EIO;\n\t\tgoto err_ioremap;\n\t}\n\n\tatl2_setup_pcicmd(pdev);\n\n\tnetdev->netdev_ops = &atl2_netdev_ops;\n\tnetdev->ethtool_ops = &atl2_ethtool_ops;\n\tnetdev->watchdog_timeo = 5 * HZ;\n\tnetdev->min_mtu = 40;\n\tnetdev->max_mtu = ETH_DATA_LEN + VLAN_HLEN;\n\tstrncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);\n\n\tnetdev->mem_start = mmio_start;\n\tnetdev->mem_end = mmio_start + mmio_len;\n\tadapter->bd_number = cards_found;\n\tadapter->pci_using_64 = false;\n\n\t \n\terr = atl2_sw_init(adapter);\n\tif (err)\n\t\tgoto err_sw_init;\n\n\tnetdev->hw_features = NETIF_F_HW_VLAN_CTAG_RX;\n\tnetdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);\n\n\t \n\tatl2_phy_init(&adapter->hw);\n\n\t \n\n\tif (atl2_reset_hw(&adapter->hw)) {\n\t\terr = -EIO;\n\t\tgoto err_reset;\n\t}\n\n\t \n\tatl2_read_mac_addr(&adapter->hw);\n\teth_hw_addr_set(netdev, adapter->hw.mac_addr);\n\tif (!is_valid_ether_addr(netdev->dev_addr)) {\n\t\terr = -EIO;\n\t\tgoto err_eeprom;\n\t}\n\n\tatl2_check_options(adapter);\n\n\ttimer_setup(&adapter->watchdog_timer, atl2_watchdog, 0);\n\n\ttimer_setup(&adapter->phy_config_timer, atl2_phy_config, 0);\n\n\tINIT_WORK(&adapter->reset_task, atl2_reset_task);\n\tINIT_WORK(&adapter->link_chg_task, atl2_link_chg_task);\n\n\tstrcpy(netdev->name, \"eth%d\");  \n\terr = register_netdev(netdev);\n\tif (err)\n\t\tgoto err_register;\n\n\t \n\tnetif_carrier_off(netdev);\n\tnetif_stop_queue(netdev);\n\n\tcards_found++;\n\n\treturn 0;\n\nerr_reset:\nerr_register:\nerr_sw_init:\nerr_eeprom:\n\tiounmap(adapter->hw.hw_addr);\nerr_ioremap:\n\tfree_netdev(netdev);\nerr_alloc_etherdev:\n\tpci_release_regions(pdev);\nerr_pci_reg:\nerr_dma:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\n \n \nstatic void atl2_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\n\t \n\tset_bit(__ATL2_DOWN, &adapter->flags);\n\n\tdel_timer_sync(&adapter->watchdog_timer);\n\tdel_timer_sync(&adapter->phy_config_timer);\n\tcancel_work_sync(&adapter->reset_task);\n\tcancel_work_sync(&adapter->link_chg_task);\n\n\tunregister_netdev(netdev);\n\n\tatl2_force_ps(&adapter->hw);\n\n\tiounmap(adapter->hw.hw_addr);\n\tpci_release_regions(pdev);\n\n\tfree_netdev(netdev);\n\n\tpci_disable_device(pdev);\n}\n\nstatic int atl2_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tstruct atl2_hw *hw = &adapter->hw;\n\tu16 speed, duplex;\n\tu32 ctrl = 0;\n\tu32 wufc = adapter->wol;\n\n#ifdef CONFIG_PM\n\tint retval = 0;\n#endif\n\n\tnetif_device_detach(netdev);\n\n\tif (netif_running(netdev)) {\n\t\tWARN_ON(test_bit(__ATL2_RESETTING, &adapter->flags));\n\t\tatl2_down(adapter);\n\t}\n\n#ifdef CONFIG_PM\n\tretval = pci_save_state(pdev);\n\tif (retval)\n\t\treturn retval;\n#endif\n\n\tatl2_read_phy_reg(hw, MII_BMSR, (u16 *)&ctrl);\n\tatl2_read_phy_reg(hw, MII_BMSR, (u16 *)&ctrl);\n\tif (ctrl & BMSR_LSTATUS)\n\t\twufc &= ~ATLX_WUFC_LNKC;\n\n\tif (0 != (ctrl & BMSR_LSTATUS) && 0 != wufc) {\n\t\tu32 ret_val;\n\t\t \n\t\tret_val = atl2_get_speed_and_duplex(hw, &speed, &duplex);\n\t\tif (ret_val) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"%s: get speed&duplex error while suspend\\n\",\n\t\t\t\tatl2_driver_name);\n\t\t\tgoto wol_dis;\n\t\t}\n\n\t\tctrl = 0;\n\n\t\t \n\t\tif (wufc & ATLX_WUFC_MAG)\n\t\t\tctrl |= (WOL_MAGIC_EN | WOL_MAGIC_PME_EN);\n\n\t\t \n\t\tATL2_WRITE_REG(hw, REG_WOL_CTRL, ctrl);\n\n\t\t \n\t\tctrl = MAC_CTRL_RX_EN | MAC_CTRL_MACLP_CLK_PHY;\n\t\tif (FULL_DUPLEX == adapter->link_duplex)\n\t\t\tctrl |= MAC_CTRL_DUPLX;\n\t\tctrl |= (MAC_CTRL_ADD_CRC | MAC_CTRL_PAD);\n\t\tctrl |= (((u32)adapter->hw.preamble_len &\n\t\t\tMAC_CTRL_PRMLEN_MASK) << MAC_CTRL_PRMLEN_SHIFT);\n\t\tctrl |= (((u32)(adapter->hw.retry_buf &\n\t\t\tMAC_CTRL_HALF_LEFT_BUF_MASK)) <<\n\t\t\tMAC_CTRL_HALF_LEFT_BUF_SHIFT);\n\t\tif (wufc & ATLX_WUFC_MAG) {\n\t\t\t \n\t\t\tctrl |= MAC_CTRL_BC_EN;\n\t\t}\n\n\t\tATL2_WRITE_REG(hw, REG_MAC_CTRL, ctrl);\n\n\t\t \n\t\tctrl = ATL2_READ_REG(hw, REG_PCIE_PHYMISC);\n\t\tctrl |= PCIE_PHYMISC_FORCE_RCV_DET;\n\t\tATL2_WRITE_REG(hw, REG_PCIE_PHYMISC, ctrl);\n\t\tctrl = ATL2_READ_REG(hw, REG_PCIE_DLL_TX_CTRL1);\n\t\tctrl |= PCIE_DLL_TX_CTRL1_SEL_NOR_CLK;\n\t\tATL2_WRITE_REG(hw, REG_PCIE_DLL_TX_CTRL1, ctrl);\n\n\t\tpci_enable_wake(pdev, pci_choose_state(pdev, state), 1);\n\t\tgoto suspend_exit;\n\t}\n\n\tif (0 == (ctrl&BMSR_LSTATUS) && 0 != (wufc&ATLX_WUFC_LNKC)) {\n\t\t \n\t\tctrl |= (WOL_LINK_CHG_EN | WOL_LINK_CHG_PME_EN);\n\t\tATL2_WRITE_REG(hw, REG_WOL_CTRL, ctrl);\n\t\tATL2_WRITE_REG(hw, REG_MAC_CTRL, 0);\n\n\t\t \n\t\tctrl = ATL2_READ_REG(hw, REG_PCIE_PHYMISC);\n\t\tctrl |= PCIE_PHYMISC_FORCE_RCV_DET;\n\t\tATL2_WRITE_REG(hw, REG_PCIE_PHYMISC, ctrl);\n\t\tctrl = ATL2_READ_REG(hw, REG_PCIE_DLL_TX_CTRL1);\n\t\tctrl |= PCIE_DLL_TX_CTRL1_SEL_NOR_CLK;\n\t\tATL2_WRITE_REG(hw, REG_PCIE_DLL_TX_CTRL1, ctrl);\n\n\t\thw->phy_configured = false;  \n\n\t\tpci_enable_wake(pdev, pci_choose_state(pdev, state), 1);\n\n\t\tgoto suspend_exit;\n\t}\n\nwol_dis:\n\t \n\tATL2_WRITE_REG(hw, REG_WOL_CTRL, 0);\n\n\t \n\tctrl = ATL2_READ_REG(hw, REG_PCIE_PHYMISC);\n\tctrl |= PCIE_PHYMISC_FORCE_RCV_DET;\n\tATL2_WRITE_REG(hw, REG_PCIE_PHYMISC, ctrl);\n\tctrl = ATL2_READ_REG(hw, REG_PCIE_DLL_TX_CTRL1);\n\tctrl |= PCIE_DLL_TX_CTRL1_SEL_NOR_CLK;\n\tATL2_WRITE_REG(hw, REG_PCIE_DLL_TX_CTRL1, ctrl);\n\n\tatl2_force_ps(hw);\n\thw->phy_configured = false;  \n\n\tpci_enable_wake(pdev, pci_choose_state(pdev, state), 0);\n\nsuspend_exit:\n\tif (netif_running(netdev))\n\t\tatl2_free_irq(adapter);\n\n\tpci_disable_device(pdev);\n\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int atl2_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tu32 err;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tprintk(KERN_ERR\n\t\t\t\"atl2: Cannot enable PCI device from suspend\\n\");\n\t\treturn err;\n\t}\n\n\tpci_set_master(pdev);\n\n\tATL2_READ_REG(&adapter->hw, REG_WOL_CTRL);  \n\n\tpci_enable_wake(pdev, PCI_D3hot, 0);\n\tpci_enable_wake(pdev, PCI_D3cold, 0);\n\n\tATL2_WRITE_REG(&adapter->hw, REG_WOL_CTRL, 0);\n\n\tif (netif_running(netdev)) {\n\t\terr = atl2_request_irq(adapter);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tatl2_reset_hw(&adapter->hw);\n\n\tif (netif_running(netdev))\n\t\tatl2_up(adapter);\n\n\tnetif_device_attach(netdev);\n\n\treturn 0;\n}\n#endif\n\nstatic void atl2_shutdown(struct pci_dev *pdev)\n{\n\tatl2_suspend(pdev, PMSG_SUSPEND);\n}\n\nstatic struct pci_driver atl2_driver = {\n\t.name     = atl2_driver_name,\n\t.id_table = atl2_pci_tbl,\n\t.probe    = atl2_probe,\n\t.remove   = atl2_remove,\n\t \n\t.suspend  = atl2_suspend,\n#ifdef CONFIG_PM\n\t.resume   = atl2_resume,\n#endif\n\t.shutdown = atl2_shutdown,\n};\n\nmodule_pci_driver(atl2_driver);\n\nstatic void atl2_read_pci_cfg(struct atl2_hw *hw, u32 reg, u16 *value)\n{\n\tstruct atl2_adapter *adapter = hw->back;\n\tpci_read_config_word(adapter->pdev, reg, value);\n}\n\nstatic void atl2_write_pci_cfg(struct atl2_hw *hw, u32 reg, u16 *value)\n{\n\tstruct atl2_adapter *adapter = hw->back;\n\tpci_write_config_word(adapter->pdev, reg, *value);\n}\n\nstatic int atl2_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tstruct atl2_hw *hw = &adapter->hw;\n\tu32 supported, advertising;\n\n\tsupported = (SUPPORTED_10baseT_Half |\n\t\tSUPPORTED_10baseT_Full |\n\t\tSUPPORTED_100baseT_Half |\n\t\tSUPPORTED_100baseT_Full |\n\t\tSUPPORTED_Autoneg |\n\t\tSUPPORTED_TP);\n\tadvertising = ADVERTISED_TP;\n\n\tadvertising |= ADVERTISED_Autoneg;\n\tadvertising |= hw->autoneg_advertised;\n\n\tcmd->base.port = PORT_TP;\n\tcmd->base.phy_address = 0;\n\n\tif (adapter->link_speed != SPEED_0) {\n\t\tcmd->base.speed = adapter->link_speed;\n\t\tif (adapter->link_duplex == FULL_DUPLEX)\n\t\t\tcmd->base.duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tcmd->base.duplex = DUPLEX_HALF;\n\t} else {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tcmd->base.autoneg = AUTONEG_ENABLE;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int atl2_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tstruct atl2_hw *hw = &adapter->hw;\n\tu32 advertising;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\twhile (test_and_set_bit(__ATL2_RESETTING, &adapter->flags))\n\t\tmsleep(1);\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n#define MY_ADV_MASK\t(ADVERTISE_10_HALF | \\\n\t\t\t ADVERTISE_10_FULL | \\\n\t\t\t ADVERTISE_100_HALF| \\\n\t\t\t ADVERTISE_100_FULL)\n\n\t\tif ((advertising & MY_ADV_MASK) == MY_ADV_MASK) {\n\t\t\thw->MediaType = MEDIA_TYPE_AUTO_SENSOR;\n\t\t\thw->autoneg_advertised =  MY_ADV_MASK;\n\t\t} else if ((advertising & MY_ADV_MASK) == ADVERTISE_100_FULL) {\n\t\t\thw->MediaType = MEDIA_TYPE_100M_FULL;\n\t\t\thw->autoneg_advertised = ADVERTISE_100_FULL;\n\t\t} else if ((advertising & MY_ADV_MASK) == ADVERTISE_100_HALF) {\n\t\t\thw->MediaType = MEDIA_TYPE_100M_HALF;\n\t\t\thw->autoneg_advertised = ADVERTISE_100_HALF;\n\t\t} else if ((advertising & MY_ADV_MASK) == ADVERTISE_10_FULL) {\n\t\t\thw->MediaType = MEDIA_TYPE_10M_FULL;\n\t\t\thw->autoneg_advertised = ADVERTISE_10_FULL;\n\t\t}  else if ((advertising & MY_ADV_MASK) == ADVERTISE_10_HALF) {\n\t\t\thw->MediaType = MEDIA_TYPE_10M_HALF;\n\t\t\thw->autoneg_advertised = ADVERTISE_10_HALF;\n\t\t} else {\n\t\t\tclear_bit(__ATL2_RESETTING, &adapter->flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tadvertising = hw->autoneg_advertised |\n\t\t\tADVERTISED_TP | ADVERTISED_Autoneg;\n\t} else {\n\t\tclear_bit(__ATL2_RESETTING, &adapter->flags);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (netif_running(adapter->netdev)) {\n\t\tatl2_down(adapter);\n\t\tatl2_up(adapter);\n\t} else\n\t\tatl2_reset_hw(&adapter->hw);\n\n\tclear_bit(__ATL2_RESETTING, &adapter->flags);\n\treturn 0;\n}\n\nstatic u32 atl2_get_msglevel(struct net_device *netdev)\n{\n\treturn 0;\n}\n\n \nstatic void atl2_set_msglevel(struct net_device *netdev, u32 data)\n{\n}\n\nstatic int atl2_get_regs_len(struct net_device *netdev)\n{\n#define ATL2_REGS_LEN 42\n\treturn sizeof(u32) * ATL2_REGS_LEN;\n}\n\nstatic void atl2_get_regs(struct net_device *netdev,\n\tstruct ethtool_regs *regs, void *p)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tstruct atl2_hw *hw = &adapter->hw;\n\tu32 *regs_buff = p;\n\tu16 phy_data;\n\n\tmemset(p, 0, sizeof(u32) * ATL2_REGS_LEN);\n\n\tregs->version = (1 << 24) | (hw->revision_id << 16) | hw->device_id;\n\n\tregs_buff[0]  = ATL2_READ_REG(hw, REG_VPD_CAP);\n\tregs_buff[1]  = ATL2_READ_REG(hw, REG_SPI_FLASH_CTRL);\n\tregs_buff[2]  = ATL2_READ_REG(hw, REG_SPI_FLASH_CONFIG);\n\tregs_buff[3]  = ATL2_READ_REG(hw, REG_TWSI_CTRL);\n\tregs_buff[4]  = ATL2_READ_REG(hw, REG_PCIE_DEV_MISC_CTRL);\n\tregs_buff[5]  = ATL2_READ_REG(hw, REG_MASTER_CTRL);\n\tregs_buff[6]  = ATL2_READ_REG(hw, REG_MANUAL_TIMER_INIT);\n\tregs_buff[7]  = ATL2_READ_REG(hw, REG_IRQ_MODU_TIMER_INIT);\n\tregs_buff[8]  = ATL2_READ_REG(hw, REG_PHY_ENABLE);\n\tregs_buff[9]  = ATL2_READ_REG(hw, REG_CMBDISDMA_TIMER);\n\tregs_buff[10] = ATL2_READ_REG(hw, REG_IDLE_STATUS);\n\tregs_buff[11] = ATL2_READ_REG(hw, REG_MDIO_CTRL);\n\tregs_buff[12] = ATL2_READ_REG(hw, REG_SERDES_LOCK);\n\tregs_buff[13] = ATL2_READ_REG(hw, REG_MAC_CTRL);\n\tregs_buff[14] = ATL2_READ_REG(hw, REG_MAC_IPG_IFG);\n\tregs_buff[15] = ATL2_READ_REG(hw, REG_MAC_STA_ADDR);\n\tregs_buff[16] = ATL2_READ_REG(hw, REG_MAC_STA_ADDR+4);\n\tregs_buff[17] = ATL2_READ_REG(hw, REG_RX_HASH_TABLE);\n\tregs_buff[18] = ATL2_READ_REG(hw, REG_RX_HASH_TABLE+4);\n\tregs_buff[19] = ATL2_READ_REG(hw, REG_MAC_HALF_DUPLX_CTRL);\n\tregs_buff[20] = ATL2_READ_REG(hw, REG_MTU);\n\tregs_buff[21] = ATL2_READ_REG(hw, REG_WOL_CTRL);\n\tregs_buff[22] = ATL2_READ_REG(hw, REG_SRAM_TXRAM_END);\n\tregs_buff[23] = ATL2_READ_REG(hw, REG_DESC_BASE_ADDR_HI);\n\tregs_buff[24] = ATL2_READ_REG(hw, REG_TXD_BASE_ADDR_LO);\n\tregs_buff[25] = ATL2_READ_REG(hw, REG_TXD_MEM_SIZE);\n\tregs_buff[26] = ATL2_READ_REG(hw, REG_TXS_BASE_ADDR_LO);\n\tregs_buff[27] = ATL2_READ_REG(hw, REG_TXS_MEM_SIZE);\n\tregs_buff[28] = ATL2_READ_REG(hw, REG_RXD_BASE_ADDR_LO);\n\tregs_buff[29] = ATL2_READ_REG(hw, REG_RXD_BUF_NUM);\n\tregs_buff[30] = ATL2_READ_REG(hw, REG_DMAR);\n\tregs_buff[31] = ATL2_READ_REG(hw, REG_TX_CUT_THRESH);\n\tregs_buff[32] = ATL2_READ_REG(hw, REG_DMAW);\n\tregs_buff[33] = ATL2_READ_REG(hw, REG_PAUSE_ON_TH);\n\tregs_buff[34] = ATL2_READ_REG(hw, REG_PAUSE_OFF_TH);\n\tregs_buff[35] = ATL2_READ_REG(hw, REG_MB_TXD_WR_IDX);\n\tregs_buff[36] = ATL2_READ_REG(hw, REG_MB_RXD_RD_IDX);\n\tregs_buff[38] = ATL2_READ_REG(hw, REG_ISR);\n\tregs_buff[39] = ATL2_READ_REG(hw, REG_IMR);\n\n\tatl2_read_phy_reg(hw, MII_BMCR, &phy_data);\n\tregs_buff[40] = (u32)phy_data;\n\tatl2_read_phy_reg(hw, MII_BMSR, &phy_data);\n\tregs_buff[41] = (u32)phy_data;\n}\n\nstatic int atl2_get_eeprom_len(struct net_device *netdev)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\n\tif (!atl2_check_eeprom_exist(&adapter->hw))\n\t\treturn 512;\n\telse\n\t\treturn 0;\n}\n\nstatic int atl2_get_eeprom(struct net_device *netdev,\n\tstruct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tstruct atl2_hw *hw = &adapter->hw;\n\tu32 *eeprom_buff;\n\tint first_dword, last_dword;\n\tint ret_val = 0;\n\tint i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\tif (atl2_check_eeprom_exist(hw))\n\t\treturn -EINVAL;\n\n\teeprom->magic = hw->vendor_id | (hw->device_id << 16);\n\n\tfirst_dword = eeprom->offset >> 2;\n\tlast_dword = (eeprom->offset + eeprom->len - 1) >> 2;\n\n\teeprom_buff = kmalloc_array(last_dword - first_dword + 1, sizeof(u32),\n\t\t\t\t    GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\tfor (i = first_dword; i < last_dword; i++) {\n\t\tif (!atl2_read_eeprom(hw, i*4, &(eeprom_buff[i-first_dword]))) {\n\t\t\tret_val = -EIO;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tmemcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 3),\n\t\teeprom->len);\nfree:\n\tkfree(eeprom_buff);\n\n\treturn ret_val;\n}\n\nstatic int atl2_set_eeprom(struct net_device *netdev,\n\tstruct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tstruct atl2_hw *hw = &adapter->hw;\n\tu32 *eeprom_buff;\n\tu32 *ptr;\n\tint max_len, first_dword, last_dword, ret_val = 0;\n\tint i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))\n\t\treturn -EFAULT;\n\n\tmax_len = 512;\n\n\tfirst_dword = eeprom->offset >> 2;\n\tlast_dword = (eeprom->offset + eeprom->len - 1) >> 2;\n\teeprom_buff = kmalloc(max_len, GFP_KERNEL);\n\tif (!eeprom_buff)\n\t\treturn -ENOMEM;\n\n\tptr = eeprom_buff;\n\n\tif (eeprom->offset & 3) {\n\t\t \n\t\t \n\t\tif (!atl2_read_eeprom(hw, first_dword*4, &(eeprom_buff[0]))) {\n\t\t\tret_val = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tptr++;\n\t}\n\tif (((eeprom->offset + eeprom->len) & 3)) {\n\t\t \n\t\tif (!atl2_read_eeprom(hw, last_dword * 4,\n\t\t\t\t\t&(eeprom_buff[last_dword - first_dword]))) {\n\t\t\tret_val = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tmemcpy(ptr, bytes, eeprom->len);\n\n\tfor (i = 0; i < last_dword - first_dword + 1; i++) {\n\t\tif (!atl2_write_eeprom(hw, ((first_dword+i)*4), eeprom_buff[i])) {\n\t\t\tret_val = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tkfree(eeprom_buff);\n\treturn ret_val;\n}\n\nstatic void atl2_get_drvinfo(struct net_device *netdev,\n\tstruct ethtool_drvinfo *drvinfo)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\n\tstrscpy(drvinfo->driver,  atl2_driver_name, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->fw_version, \"L2\", sizeof(drvinfo->fw_version));\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic void atl2_get_wol(struct net_device *netdev,\n\tstruct ethtool_wolinfo *wol)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\n\twol->supported = WAKE_MAGIC;\n\twol->wolopts = 0;\n\n\tif (adapter->wol & ATLX_WUFC_EX)\n\t\twol->wolopts |= WAKE_UCAST;\n\tif (adapter->wol & ATLX_WUFC_MC)\n\t\twol->wolopts |= WAKE_MCAST;\n\tif (adapter->wol & ATLX_WUFC_BC)\n\t\twol->wolopts |= WAKE_BCAST;\n\tif (adapter->wol & ATLX_WUFC_MAG)\n\t\twol->wolopts |= WAKE_MAGIC;\n\tif (adapter->wol & ATLX_WUFC_LNKC)\n\t\twol->wolopts |= WAKE_PHY;\n}\n\nstatic int atl2_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\n\tif (wol->wolopts & (WAKE_ARP | WAKE_MAGICSECURE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (wol->wolopts & (WAKE_UCAST | WAKE_BCAST | WAKE_MCAST))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tadapter->wol = 0;\n\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\tadapter->wol |= ATLX_WUFC_MAG;\n\tif (wol->wolopts & WAKE_PHY)\n\t\tadapter->wol |= ATLX_WUFC_LNKC;\n\n\treturn 0;\n}\n\nstatic int atl2_nway_reset(struct net_device *netdev)\n{\n\tstruct atl2_adapter *adapter = netdev_priv(netdev);\n\tif (netif_running(netdev))\n\t\tatl2_reinit_locked(adapter);\n\treturn 0;\n}\n\nstatic const struct ethtool_ops atl2_ethtool_ops = {\n\t.get_drvinfo\t\t= atl2_get_drvinfo,\n\t.get_regs_len\t\t= atl2_get_regs_len,\n\t.get_regs\t\t= atl2_get_regs,\n\t.get_wol\t\t= atl2_get_wol,\n\t.set_wol\t\t= atl2_set_wol,\n\t.get_msglevel\t\t= atl2_get_msglevel,\n\t.set_msglevel\t\t= atl2_set_msglevel,\n\t.nway_reset\t\t= atl2_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_eeprom_len\t\t= atl2_get_eeprom_len,\n\t.get_eeprom\t\t= atl2_get_eeprom,\n\t.set_eeprom\t\t= atl2_set_eeprom,\n\t.get_link_ksettings\t= atl2_get_link_ksettings,\n\t.set_link_ksettings\t= atl2_set_link_ksettings,\n};\n\n#define LBYTESWAP(a)  ((((a) & 0x00ff00ff) << 8) | \\\n\t(((a) & 0xff00ff00) >> 8))\n#define LONGSWAP(a)   ((LBYTESWAP(a) << 16) | (LBYTESWAP(a) >> 16))\n#define SHORTSWAP(a)  (((a) << 8) | ((a) >> 8))\n\n \nstatic s32 atl2_reset_hw(struct atl2_hw *hw)\n{\n\tu32 icr;\n\tu16 pci_cfg_cmd_word;\n\tint i;\n\n\t \n\tatl2_read_pci_cfg(hw, PCI_REG_COMMAND, &pci_cfg_cmd_word);\n\tif ((pci_cfg_cmd_word &\n\t\t(CMD_IO_SPACE|CMD_MEMORY_SPACE|CMD_BUS_MASTER)) !=\n\t\t(CMD_IO_SPACE|CMD_MEMORY_SPACE|CMD_BUS_MASTER)) {\n\t\tpci_cfg_cmd_word |=\n\t\t\t(CMD_IO_SPACE|CMD_MEMORY_SPACE|CMD_BUS_MASTER);\n\t\tatl2_write_pci_cfg(hw, PCI_REG_COMMAND, &pci_cfg_cmd_word);\n\t}\n\n\t \n\t \n\t \n\t \n\n\t \n\tATL2_WRITE_REG(hw, REG_MASTER_CTRL, MASTER_CTRL_SOFT_RST);\n\twmb();\n\tmsleep(1);  \n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\ticr = ATL2_READ_REG(hw, REG_IDLE_STATUS);\n\t\tif (!icr)\n\t\t\tbreak;\n\t\tmsleep(1);  \n\t\tcpu_relax();\n\t}\n\n\tif (icr)\n\t\treturn icr;\n\n\treturn 0;\n}\n\n#define CUSTOM_SPI_CS_SETUP        2\n#define CUSTOM_SPI_CLK_HI          2\n#define CUSTOM_SPI_CLK_LO          2\n#define CUSTOM_SPI_CS_HOLD         2\n#define CUSTOM_SPI_CS_HI           3\n\nstatic struct atl2_spi_flash_dev flash_table[] =\n{\n \n{\"Atmel\", 0x0,  0x03, 0x02,   0x06, 0x04, 0x05, 0x15, 0x52,        0x62 },\n{\"SST\",   0x01, 0x03, 0x02,   0x06, 0x04, 0x05, 0x90, 0x20,        0x60 },\n{\"ST\",    0x01, 0x03, 0x02,   0x06, 0x04, 0x05, 0xAB, 0xD8,        0xC7 },\n};\n\nstatic bool atl2_spi_read(struct atl2_hw *hw, u32 addr, u32 *buf)\n{\n\tint i;\n\tu32 value;\n\n\tATL2_WRITE_REG(hw, REG_SPI_DATA, 0);\n\tATL2_WRITE_REG(hw, REG_SPI_ADDR, addr);\n\n\tvalue = SPI_FLASH_CTRL_WAIT_READY |\n\t\t(CUSTOM_SPI_CS_SETUP & SPI_FLASH_CTRL_CS_SETUP_MASK) <<\n\t\t\tSPI_FLASH_CTRL_CS_SETUP_SHIFT |\n\t\t(CUSTOM_SPI_CLK_HI & SPI_FLASH_CTRL_CLK_HI_MASK) <<\n\t\t\tSPI_FLASH_CTRL_CLK_HI_SHIFT |\n\t\t(CUSTOM_SPI_CLK_LO & SPI_FLASH_CTRL_CLK_LO_MASK) <<\n\t\t\tSPI_FLASH_CTRL_CLK_LO_SHIFT |\n\t\t(CUSTOM_SPI_CS_HOLD & SPI_FLASH_CTRL_CS_HOLD_MASK) <<\n\t\t\tSPI_FLASH_CTRL_CS_HOLD_SHIFT |\n\t\t(CUSTOM_SPI_CS_HI & SPI_FLASH_CTRL_CS_HI_MASK) <<\n\t\t\tSPI_FLASH_CTRL_CS_HI_SHIFT |\n\t\t(0x1 & SPI_FLASH_CTRL_INS_MASK) << SPI_FLASH_CTRL_INS_SHIFT;\n\n\tATL2_WRITE_REG(hw, REG_SPI_FLASH_CTRL, value);\n\n\tvalue |= SPI_FLASH_CTRL_START;\n\n\tATL2_WRITE_REG(hw, REG_SPI_FLASH_CTRL, value);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tmsleep(1);\n\t\tvalue = ATL2_READ_REG(hw, REG_SPI_FLASH_CTRL);\n\t\tif (!(value & SPI_FLASH_CTRL_START))\n\t\t\tbreak;\n\t}\n\n\tif (value & SPI_FLASH_CTRL_START)\n\t\treturn false;\n\n\t*buf = ATL2_READ_REG(hw, REG_SPI_DATA);\n\n\treturn true;\n}\n\n \nstatic int get_permanent_address(struct atl2_hw *hw)\n{\n\tu32 Addr[2];\n\tu32 i, Control;\n\tu16 Register;\n\tu8  EthAddr[ETH_ALEN];\n\tbool KeyValid;\n\n\tif (is_valid_ether_addr(hw->perm_mac_addr))\n\t\treturn 0;\n\n\tAddr[0] = 0;\n\tAddr[1] = 0;\n\n\tif (!atl2_check_eeprom_exist(hw)) {  \n\t\tRegister = 0;\n\t\tKeyValid = false;\n\n\t\t \n\t\ti = 0;\n\t\twhile (1) {\n\t\t\tif (atl2_read_eeprom(hw, i + 0x100, &Control)) {\n\t\t\t\tif (KeyValid) {\n\t\t\t\t\tif (Register == REG_MAC_STA_ADDR)\n\t\t\t\t\t\tAddr[0] = Control;\n\t\t\t\t\telse if (Register ==\n\t\t\t\t\t\t(REG_MAC_STA_ADDR + 4))\n\t\t\t\t\t\tAddr[1] = Control;\n\t\t\t\t\tKeyValid = false;\n\t\t\t\t} else if ((Control & 0xff) == 0x5A) {\n\t\t\t\t\tKeyValid = true;\n\t\t\t\t\tRegister = (u16) (Control >> 16);\n\t\t\t\t} else {\n\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;  \n\t\t\t}\n\t\t\ti += 4;\n\t\t}\n\n\t\t*(u32 *) &EthAddr[2] = LONGSWAP(Addr[0]);\n\t\t*(u16 *) &EthAddr[0] = SHORTSWAP(*(u16 *) &Addr[1]);\n\n\t\tif (is_valid_ether_addr(EthAddr)) {\n\t\t\tmemcpy(hw->perm_mac_addr, EthAddr, ETH_ALEN);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t \n\tAddr[0] = 0;\n\tAddr[1] = 0;\n\tRegister = 0;\n\tKeyValid = false;\n\ti = 0;\n\twhile (1) {\n\t\tif (atl2_spi_read(hw, i + 0x1f000, &Control)) {\n\t\t\tif (KeyValid) {\n\t\t\t\tif (Register == REG_MAC_STA_ADDR)\n\t\t\t\t\tAddr[0] = Control;\n\t\t\t\telse if (Register == (REG_MAC_STA_ADDR + 4))\n\t\t\t\t\tAddr[1] = Control;\n\t\t\t\tKeyValid = false;\n\t\t\t} else if ((Control & 0xff) == 0x5A) {\n\t\t\t\tKeyValid = true;\n\t\t\t\tRegister = (u16) (Control >> 16);\n\t\t\t} else {\n\t\t\t\tbreak;  \n\t\t\t}\n\t\t} else {\n\t\t\tbreak;  \n\t\t}\n\t\ti += 4;\n\t}\n\n\t*(u32 *) &EthAddr[2] = LONGSWAP(Addr[0]);\n\t*(u16 *) &EthAddr[0] = SHORTSWAP(*(u16 *)&Addr[1]);\n\tif (is_valid_ether_addr(EthAddr)) {\n\t\tmemcpy(hw->perm_mac_addr, EthAddr, ETH_ALEN);\n\t\treturn 0;\n\t}\n\t \n\tAddr[0] = ATL2_READ_REG(hw, REG_MAC_STA_ADDR);\n\tAddr[1] = ATL2_READ_REG(hw, REG_MAC_STA_ADDR + 4);\n\t*(u32 *) &EthAddr[2] = LONGSWAP(Addr[0]);\n\t*(u16 *) &EthAddr[0] = SHORTSWAP(*(u16 *) &Addr[1]);\n\n\tif (is_valid_ether_addr(EthAddr)) {\n\t\tmemcpy(hw->perm_mac_addr, EthAddr, ETH_ALEN);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic s32 atl2_read_mac_addr(struct atl2_hw *hw)\n{\n\tif (get_permanent_address(hw)) {\n\t\t \n\t\t \n\t\thw->perm_mac_addr[0] = 0x00;\n\t\thw->perm_mac_addr[1] = 0x13;\n\t\thw->perm_mac_addr[2] = 0x74;\n\t\thw->perm_mac_addr[3] = 0x00;\n\t\thw->perm_mac_addr[4] = 0x5c;\n\t\thw->perm_mac_addr[5] = 0x38;\n\t}\n\n\tmemcpy(hw->mac_addr, hw->perm_mac_addr, ETH_ALEN);\n\n\treturn 0;\n}\n\n \nstatic u32 atl2_hash_mc_addr(struct atl2_hw *hw, u8 *mc_addr)\n{\n\tu32 crc32, value;\n\tint i;\n\n\tvalue = 0;\n\tcrc32 = ether_crc_le(6, mc_addr);\n\n\tfor (i = 0; i < 32; i++)\n\t\tvalue |= (((crc32 >> i) & 1) << (31 - i));\n\n\treturn value;\n}\n\n \nstatic void atl2_hash_set(struct atl2_hw *hw, u32 hash_value)\n{\n\tu32 hash_bit, hash_reg;\n\tu32 mta;\n\n\t \n\thash_reg = (hash_value >> 31) & 0x1;\n\thash_bit = (hash_value >> 26) & 0x1F;\n\n\tmta = ATL2_READ_REG_ARRAY(hw, REG_RX_HASH_TABLE, hash_reg);\n\n\tmta |= (1 << hash_bit);\n\n\tATL2_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, hash_reg, mta);\n}\n\n \nstatic void atl2_init_pcie(struct atl2_hw *hw)\n{\n    u32 value;\n    value = LTSSM_TEST_MODE_DEF;\n    ATL2_WRITE_REG(hw, REG_LTSSM_TEST_MODE, value);\n\n    value = PCIE_DLL_TX_CTRL1_DEF;\n    ATL2_WRITE_REG(hw, REG_PCIE_DLL_TX_CTRL1, value);\n}\n\nstatic void atl2_init_flash_opcode(struct atl2_hw *hw)\n{\n\tif (hw->flash_vendor >= ARRAY_SIZE(flash_table))\n\t\thw->flash_vendor = 0;  \n\n\t \n\tATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_PROGRAM,\n\t\tflash_table[hw->flash_vendor].cmdPROGRAM);\n\tATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_SC_ERASE,\n\t\tflash_table[hw->flash_vendor].cmdSECTOR_ERASE);\n\tATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_CHIP_ERASE,\n\t\tflash_table[hw->flash_vendor].cmdCHIP_ERASE);\n\tATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_RDID,\n\t\tflash_table[hw->flash_vendor].cmdRDID);\n\tATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_WREN,\n\t\tflash_table[hw->flash_vendor].cmdWREN);\n\tATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_RDSR,\n\t\tflash_table[hw->flash_vendor].cmdRDSR);\n\tATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_WRSR,\n\t\tflash_table[hw->flash_vendor].cmdWRSR);\n\tATL2_WRITE_REGB(hw, REG_SPI_FLASH_OP_READ,\n\t\tflash_table[hw->flash_vendor].cmdREAD);\n}\n\n \nstatic s32 atl2_init_hw(struct atl2_hw *hw)\n{\n\tu32 ret_val = 0;\n\n\tatl2_init_pcie(hw);\n\n\t \n\t \n\tATL2_WRITE_REG(hw, REG_RX_HASH_TABLE, 0);\n\tATL2_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, 1, 0);\n\n\tatl2_init_flash_opcode(hw);\n\n\tret_val = atl2_phy_init(hw);\n\n\treturn ret_val;\n}\n\n \nstatic s32 atl2_get_speed_and_duplex(struct atl2_hw *hw, u16 *speed,\n\tu16 *duplex)\n{\n\ts32 ret_val;\n\tu16 phy_data;\n\n\t \n\tret_val = atl2_read_phy_reg(hw, MII_ATLX_PSSR, &phy_data);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (!(phy_data & MII_ATLX_PSSR_SPD_DPLX_RESOLVED))\n\t\treturn ATLX_ERR_PHY_RES;\n\n\tswitch (phy_data & MII_ATLX_PSSR_SPEED) {\n\tcase MII_ATLX_PSSR_100MBS:\n\t\t*speed = SPEED_100;\n\t\tbreak;\n\tcase MII_ATLX_PSSR_10MBS:\n\t\t*speed = SPEED_10;\n\t\tbreak;\n\tdefault:\n\t\treturn ATLX_ERR_PHY_SPEED;\n\t}\n\n\tif (phy_data & MII_ATLX_PSSR_DPLX)\n\t\t*duplex = FULL_DUPLEX;\n\telse\n\t\t*duplex = HALF_DUPLEX;\n\n\treturn 0;\n}\n\n \nstatic s32 atl2_read_phy_reg(struct atl2_hw *hw, u16 reg_addr, u16 *phy_data)\n{\n\tu32 val;\n\tint i;\n\n\tval = ((u32)(reg_addr & MDIO_REG_ADDR_MASK)) << MDIO_REG_ADDR_SHIFT |\n\t\tMDIO_START |\n\t\tMDIO_SUP_PREAMBLE |\n\t\tMDIO_RW |\n\t\tMDIO_CLK_25_4 << MDIO_CLK_SEL_SHIFT;\n\tATL2_WRITE_REG(hw, REG_MDIO_CTRL, val);\n\n\twmb();\n\n\tfor (i = 0; i < MDIO_WAIT_TIMES; i++) {\n\t\tudelay(2);\n\t\tval = ATL2_READ_REG(hw, REG_MDIO_CTRL);\n\t\tif (!(val & (MDIO_START | MDIO_BUSY)))\n\t\t\tbreak;\n\t\twmb();\n\t}\n\tif (!(val & (MDIO_START | MDIO_BUSY))) {\n\t\t*phy_data = (u16)val;\n\t\treturn 0;\n\t}\n\n\treturn ATLX_ERR_PHY;\n}\n\n \nstatic s32 atl2_write_phy_reg(struct atl2_hw *hw, u32 reg_addr, u16 phy_data)\n{\n\tint i;\n\tu32 val;\n\n\tval = ((u32)(phy_data & MDIO_DATA_MASK)) << MDIO_DATA_SHIFT |\n\t\t(reg_addr & MDIO_REG_ADDR_MASK) << MDIO_REG_ADDR_SHIFT |\n\t\tMDIO_SUP_PREAMBLE |\n\t\tMDIO_START |\n\t\tMDIO_CLK_25_4 << MDIO_CLK_SEL_SHIFT;\n\tATL2_WRITE_REG(hw, REG_MDIO_CTRL, val);\n\n\twmb();\n\n\tfor (i = 0; i < MDIO_WAIT_TIMES; i++) {\n\t\tudelay(2);\n\t\tval = ATL2_READ_REG(hw, REG_MDIO_CTRL);\n\t\tif (!(val & (MDIO_START | MDIO_BUSY)))\n\t\t\tbreak;\n\n\t\twmb();\n\t}\n\n\tif (!(val & (MDIO_START | MDIO_BUSY)))\n\t\treturn 0;\n\n\treturn ATLX_ERR_PHY;\n}\n\n \nstatic s32 atl2_phy_setup_autoneg_adv(struct atl2_hw *hw)\n{\n\ts16 mii_autoneg_adv_reg;\n\n\t \n\tmii_autoneg_adv_reg = MII_AR_DEFAULT_CAP_MASK;\n\n\t \n\n\t \n\tmii_autoneg_adv_reg &= ~MII_AR_SPEED_MASK;\n\n\t \n\tswitch (hw->MediaType) {\n\tcase MEDIA_TYPE_AUTO_SENSOR:\n\t\tmii_autoneg_adv_reg |=\n\t\t\t(MII_AR_10T_HD_CAPS |\n\t\t\tMII_AR_10T_FD_CAPS  |\n\t\t\tMII_AR_100TX_HD_CAPS|\n\t\t\tMII_AR_100TX_FD_CAPS);\n\t\thw->autoneg_advertised =\n\t\t\tADVERTISE_10_HALF |\n\t\t\tADVERTISE_10_FULL |\n\t\t\tADVERTISE_100_HALF|\n\t\t\tADVERTISE_100_FULL;\n\t\tbreak;\n\tcase MEDIA_TYPE_100M_FULL:\n\t\tmii_autoneg_adv_reg |= MII_AR_100TX_FD_CAPS;\n\t\thw->autoneg_advertised = ADVERTISE_100_FULL;\n\t\tbreak;\n\tcase MEDIA_TYPE_100M_HALF:\n\t\tmii_autoneg_adv_reg |= MII_AR_100TX_HD_CAPS;\n\t\thw->autoneg_advertised = ADVERTISE_100_HALF;\n\t\tbreak;\n\tcase MEDIA_TYPE_10M_FULL:\n\t\tmii_autoneg_adv_reg |= MII_AR_10T_FD_CAPS;\n\t\thw->autoneg_advertised = ADVERTISE_10_FULL;\n\t\tbreak;\n\tdefault:\n\t\tmii_autoneg_adv_reg |= MII_AR_10T_HD_CAPS;\n\t\thw->autoneg_advertised = ADVERTISE_10_HALF;\n\t\tbreak;\n\t}\n\n\t \n\tmii_autoneg_adv_reg |= (MII_AR_ASM_DIR | MII_AR_PAUSE);\n\n\thw->mii_autoneg_adv_reg = mii_autoneg_adv_reg;\n\n\treturn atl2_write_phy_reg(hw, MII_ADVERTISE, mii_autoneg_adv_reg);\n}\n\n \nstatic s32 atl2_phy_commit(struct atl2_hw *hw)\n{\n\ts32 ret_val;\n\tu16 phy_data;\n\n\tphy_data = MII_CR_RESET | MII_CR_AUTO_NEG_EN | MII_CR_RESTART_AUTO_NEG;\n\tret_val = atl2_write_phy_reg(hw, MII_BMCR, phy_data);\n\tif (ret_val) {\n\t\tu32 val;\n\t\tint i;\n\t\t \n\t\tfor (i = 0; i < 25; i++) {\n\t\t\tmsleep(1);\n\t\t\tval = ATL2_READ_REG(hw, REG_MDIO_CTRL);\n\t\t\tif (!(val & (MDIO_START | MDIO_BUSY)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (0 != (val & (MDIO_START | MDIO_BUSY))) {\n\t\t\tprintk(KERN_ERR \"atl2: PCIe link down for at least 25ms !\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic s32 atl2_phy_init(struct atl2_hw *hw)\n{\n\ts32 ret_val;\n\tu16 phy_val;\n\n\tif (hw->phy_configured)\n\t\treturn 0;\n\n\t \n\tATL2_WRITE_REGW(hw, REG_PHY_ENABLE, 1);\n\tATL2_WRITE_FLUSH(hw);\n\tmsleep(1);\n\n\t \n\tatl2_write_phy_reg(hw, MII_DBG_ADDR, 0);\n\tatl2_read_phy_reg(hw, MII_DBG_DATA, &phy_val);\n\n\t \n\tif (phy_val & 0x1000) {\n\t\tphy_val &= ~0x1000;\n\t\tatl2_write_phy_reg(hw, MII_DBG_DATA, phy_val);\n\t}\n\n\tmsleep(1);\n\n\t \n\tret_val = atl2_write_phy_reg(hw, 18, 0xC00);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = atl2_phy_setup_autoneg_adv(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\t \n\tret_val = atl2_phy_commit(hw);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\thw->phy_configured = true;\n\n\treturn ret_val;\n}\n\nstatic void atl2_set_mac_addr(struct atl2_hw *hw)\n{\n\tu32 value;\n\t \n\tvalue = (((u32)hw->mac_addr[2]) << 24) |\n\t\t(((u32)hw->mac_addr[3]) << 16) |\n\t\t(((u32)hw->mac_addr[4]) << 8)  |\n\t\t(((u32)hw->mac_addr[5]));\n\tATL2_WRITE_REG_ARRAY(hw, REG_MAC_STA_ADDR, 0, value);\n\t \n\tvalue = (((u32)hw->mac_addr[0]) << 8) |\n\t\t(((u32)hw->mac_addr[1]));\n\tATL2_WRITE_REG_ARRAY(hw, REG_MAC_STA_ADDR, 1, value);\n}\n\n \nstatic int atl2_check_eeprom_exist(struct atl2_hw *hw)\n{\n\tu32 value;\n\n\tvalue = ATL2_READ_REG(hw, REG_SPI_FLASH_CTRL);\n\tif (value & SPI_FLASH_CTRL_EN_VPD) {\n\t\tvalue &= ~SPI_FLASH_CTRL_EN_VPD;\n\t\tATL2_WRITE_REG(hw, REG_SPI_FLASH_CTRL, value);\n\t}\n\tvalue = ATL2_READ_REGW(hw, REG_PCIE_CAP_LIST);\n\treturn ((value & 0xFF00) == 0x6C00) ? 0 : 1;\n}\n\n \nstatic bool atl2_write_eeprom(struct atl2_hw *hw, u32 offset, u32 value)\n{\n\treturn true;\n}\n\nstatic bool atl2_read_eeprom(struct atl2_hw *hw, u32 Offset, u32 *pValue)\n{\n\tint i;\n\tu32    Control;\n\n\tif (Offset & 0x3)\n\t\treturn false;  \n\n\tATL2_WRITE_REG(hw, REG_VPD_DATA, 0);\n\tControl = (Offset & VPD_CAP_VPD_ADDR_MASK) << VPD_CAP_VPD_ADDR_SHIFT;\n\tATL2_WRITE_REG(hw, REG_VPD_CAP, Control);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tmsleep(2);\n\t\tControl = ATL2_READ_REG(hw, REG_VPD_CAP);\n\t\tif (Control & VPD_CAP_VPD_FLAG)\n\t\t\tbreak;\n\t}\n\n\tif (Control & VPD_CAP_VPD_FLAG) {\n\t\t*pValue = ATL2_READ_REG(hw, REG_VPD_DATA);\n\t\treturn true;\n\t}\n\treturn false;  \n}\n\nstatic void atl2_force_ps(struct atl2_hw *hw)\n{\n\tu16 phy_val;\n\n\tatl2_write_phy_reg(hw, MII_DBG_ADDR, 0);\n\tatl2_read_phy_reg(hw, MII_DBG_DATA, &phy_val);\n\tatl2_write_phy_reg(hw, MII_DBG_DATA, phy_val | 0x1000);\n\n\tatl2_write_phy_reg(hw, MII_DBG_ADDR, 2);\n\tatl2_write_phy_reg(hw, MII_DBG_DATA, 0x3000);\n\tatl2_write_phy_reg(hw, MII_DBG_ADDR, 3);\n\tatl2_write_phy_reg(hw, MII_DBG_DATA, 0);\n}\n\n \n#define ATL2_MAX_NIC 4\n\n#define OPTION_UNSET    -1\n#define OPTION_DISABLED 0\n#define OPTION_ENABLED  1\n\n \n#define ATL2_PARAM_INIT {[0 ... ATL2_MAX_NIC] = OPTION_UNSET}\n#ifndef module_param_array\n \n\n#define ATL2_PARAM(X, desc) \\\n    static const int X[ATL2_MAX_NIC + 1] = ATL2_PARAM_INIT; \\\n    MODULE_PARM(X, \"1-\" __MODULE_STRING(ATL2_MAX_NIC) \"i\"); \\\n    MODULE_PARM_DESC(X, desc);\n#else\n#define ATL2_PARAM(X, desc) \\\n    static int X[ATL2_MAX_NIC+1] = ATL2_PARAM_INIT; \\\n    static unsigned int num_##X; \\\n    module_param_array_named(X, X, int, &num_##X, 0); \\\n    MODULE_PARM_DESC(X, desc);\n#endif\n\n \n#define ATL2_MIN_TX_MEMSIZE\t\t4\t \n#define ATL2_MAX_TX_MEMSIZE\t\t64\t \n#define ATL2_DEFAULT_TX_MEMSIZE\t\t8\t \nATL2_PARAM(TxMemSize, \"Bytes of Transmit Memory\");\n\n \n#define ATL2_MIN_RXD_COUNT\t\t16\n#define ATL2_MAX_RXD_COUNT\t\t512\n#define ATL2_DEFAULT_RXD_COUNT\t\t64\nATL2_PARAM(RxMemBlock, \"Number of receive memory block\");\n\n \nATL2_PARAM(MediaType, \"MediaType Select\");\n\n \n#define INT_MOD_DEFAULT_CNT\t100  \n#define INT_MOD_MAX_CNT\t\t65000\n#define INT_MOD_MIN_CNT\t\t50\nATL2_PARAM(IntModTimer, \"Interrupt Moderator Timer\");\n\n \nATL2_PARAM(FlashVendor, \"SPI Flash Vendor\");\n\n#define AUTONEG_ADV_DEFAULT\t0x2F\n#define AUTONEG_ADV_MASK\t0x2F\n#define FLOW_CONTROL_DEFAULT\tFLOW_CONTROL_FULL\n\n#define FLASH_VENDOR_DEFAULT\t0\n#define FLASH_VENDOR_MIN\t0\n#define FLASH_VENDOR_MAX\t2\n\nstruct atl2_option {\n\tenum { enable_option, range_option, list_option } type;\n\tchar *name;\n\tchar *err;\n\tint  def;\n\tunion {\n\t\tstruct {  \n\t\t\tint min;\n\t\t\tint max;\n\t\t} r;\n\t\tstruct {  \n\t\t\tint nr;\n\t\t\tstruct atl2_opt_list { int i; char *str; } *p;\n\t\t} l;\n\t} arg;\n};\n\nstatic int atl2_validate_option(int *value, struct atl2_option *opt)\n{\n\tint i;\n\tstruct atl2_opt_list *ent;\n\n\tif (*value == OPTION_UNSET) {\n\t\t*value = opt->def;\n\t\treturn 0;\n\t}\n\n\tswitch (opt->type) {\n\tcase enable_option:\n\t\tswitch (*value) {\n\t\tcase OPTION_ENABLED:\n\t\t\tprintk(KERN_INFO \"%s Enabled\\n\", opt->name);\n\t\t\treturn 0;\n\t\tcase OPTION_DISABLED:\n\t\t\tprintk(KERN_INFO \"%s Disabled\\n\", opt->name);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase range_option:\n\t\tif (*value >= opt->arg.r.min && *value <= opt->arg.r.max) {\n\t\t\tprintk(KERN_INFO \"%s set to %i\\n\", opt->name, *value);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase list_option:\n\t\tfor (i = 0; i < opt->arg.l.nr; i++) {\n\t\t\tent = &opt->arg.l.p[i];\n\t\t\tif (*value == ent->i) {\n\t\t\t\tif (ent->str[0] != '\\0')\n\t\t\t\t\tprintk(KERN_INFO \"%s\\n\", ent->str);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tprintk(KERN_INFO \"Invalid %s specified (%i) %s\\n\",\n\t\topt->name, *value, opt->err);\n\t*value = opt->def;\n\treturn -1;\n}\n\n \nstatic void atl2_check_options(struct atl2_adapter *adapter)\n{\n\tint val;\n\tstruct atl2_option opt;\n\tint bd = adapter->bd_number;\n\tif (bd >= ATL2_MAX_NIC) {\n\t\tprintk(KERN_NOTICE \"Warning: no configuration for board #%i\\n\",\n\t\t\tbd);\n\t\tprintk(KERN_NOTICE \"Using defaults for all values\\n\");\n#ifndef module_param_array\n\t\tbd = ATL2_MAX_NIC;\n#endif\n\t}\n\n\t \n\topt.type = range_option;\n\topt.name = \"Bytes of Transmit Memory\";\n\topt.err = \"using default of \" __MODULE_STRING(ATL2_DEFAULT_TX_MEMSIZE);\n\topt.def = ATL2_DEFAULT_TX_MEMSIZE;\n\topt.arg.r.min = ATL2_MIN_TX_MEMSIZE;\n\topt.arg.r.max = ATL2_MAX_TX_MEMSIZE;\n#ifdef module_param_array\n\tif (num_TxMemSize > bd) {\n#endif\n\t\tval = TxMemSize[bd];\n\t\tatl2_validate_option(&val, &opt);\n\t\tadapter->txd_ring_size = ((u32) val) * 1024;\n#ifdef module_param_array\n\t} else\n\t\tadapter->txd_ring_size = ((u32)opt.def) * 1024;\n#endif\n\t \n\tadapter->txs_ring_size = adapter->txd_ring_size / 128;\n\tif (adapter->txs_ring_size > 160)\n\t\tadapter->txs_ring_size = 160;\n\n\t \n\topt.type = range_option;\n\topt.name = \"Number of receive memory block\";\n\topt.err = \"using default of \" __MODULE_STRING(ATL2_DEFAULT_RXD_COUNT);\n\topt.def = ATL2_DEFAULT_RXD_COUNT;\n\topt.arg.r.min = ATL2_MIN_RXD_COUNT;\n\topt.arg.r.max = ATL2_MAX_RXD_COUNT;\n#ifdef module_param_array\n\tif (num_RxMemBlock > bd) {\n#endif\n\t\tval = RxMemBlock[bd];\n\t\tatl2_validate_option(&val, &opt);\n\t\tadapter->rxd_ring_size = (u32)val;\n\t\t \n\t\t \t \n#ifdef module_param_array\n\t} else\n\t\tadapter->rxd_ring_size = (u32)opt.def;\n#endif\n\t \n\tadapter->hw.fc_rxd_hi = (adapter->rxd_ring_size / 8) * 7;\n\tadapter->hw.fc_rxd_lo = (ATL2_MIN_RXD_COUNT / 8) >\n\t\t(adapter->rxd_ring_size / 12) ? (ATL2_MIN_RXD_COUNT / 8) :\n\t\t(adapter->rxd_ring_size / 12);\n\n\t \n\topt.type = range_option;\n\topt.name = \"Interrupt Moderate Timer\";\n\topt.err = \"using default of \" __MODULE_STRING(INT_MOD_DEFAULT_CNT);\n\topt.def = INT_MOD_DEFAULT_CNT;\n\topt.arg.r.min = INT_MOD_MIN_CNT;\n\topt.arg.r.max = INT_MOD_MAX_CNT;\n#ifdef module_param_array\n\tif (num_IntModTimer > bd) {\n#endif\n\t\tval = IntModTimer[bd];\n\t\tatl2_validate_option(&val, &opt);\n\t\tadapter->imt = (u16) val;\n#ifdef module_param_array\n\t} else\n\t\tadapter->imt = (u16)(opt.def);\n#endif\n\t \n\topt.type = range_option;\n\topt.name = \"SPI Flash Vendor\";\n\topt.err = \"using default of \" __MODULE_STRING(FLASH_VENDOR_DEFAULT);\n\topt.def = FLASH_VENDOR_DEFAULT;\n\topt.arg.r.min = FLASH_VENDOR_MIN;\n\topt.arg.r.max = FLASH_VENDOR_MAX;\n#ifdef module_param_array\n\tif (num_FlashVendor > bd) {\n#endif\n\t\tval = FlashVendor[bd];\n\t\tatl2_validate_option(&val, &opt);\n\t\tadapter->hw.flash_vendor = (u8) val;\n#ifdef module_param_array\n\t} else\n\t\tadapter->hw.flash_vendor = (u8)(opt.def);\n#endif\n\t \n\topt.type = range_option;\n\topt.name = \"Speed/Duplex Selection\";\n\topt.err = \"using default of \" __MODULE_STRING(MEDIA_TYPE_AUTO_SENSOR);\n\topt.def = MEDIA_TYPE_AUTO_SENSOR;\n\topt.arg.r.min = MEDIA_TYPE_AUTO_SENSOR;\n\topt.arg.r.max = MEDIA_TYPE_10M_HALF;\n#ifdef module_param_array\n\tif (num_MediaType > bd) {\n#endif\n\t\tval = MediaType[bd];\n\t\tatl2_validate_option(&val, &opt);\n\t\tadapter->hw.MediaType = (u16) val;\n#ifdef module_param_array\n\t} else\n\t\tadapter->hw.MediaType = (u16)(opt.def);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}