{
  "module_name": "atlx.c",
  "hash_id": "6a4bbe467ef6163684cc11b13133b594a4b5aa9357c2cec8515a51243d141d95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/atheros/atlx/atlx.c",
  "human_readable_source": "\n \n\n \n#ifndef ATLX_C\n#define ATLX_C\n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/if.h>\n#include <linux/netdevice.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#include \"atlx.h\"\n\nstatic s32 atlx_read_phy_reg(struct atl1_hw *hw, u16 reg_addr, u16 *phy_data);\nstatic u32 atlx_hash_mc_addr(struct atl1_hw *hw, u8 *mc_addr);\nstatic void atlx_set_mac_addr(struct atl1_hw *hw);\n\nstatic struct atlx_spi_flash_dev flash_table[] = {\n \n\t{\"Atmel\", 0x00, 0x03, 0x02, 0x06, 0x04, 0x05, 0x15, 0x52,   0x62},\n\t{\"SST\",   0x01, 0x03, 0x02, 0x06, 0x04, 0x05, 0x90, 0x20,   0x60},\n\t{\"ST\",    0x01, 0x03, 0x02, 0x06, 0x04, 0x05, 0xAB, 0xD8,   0xC7},\n};\n\nstatic int atlx_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn atlx_mii_ioctl(netdev, ifr, cmd);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic int atlx_set_mac(struct net_device *netdev, void *p)\n{\n\tstruct atlx_adapter *adapter = netdev_priv(netdev);\n\tstruct sockaddr *addr = p;\n\n\tif (netif_running(netdev))\n\t\treturn -EBUSY;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(netdev, addr->sa_data);\n\tmemcpy(adapter->hw.mac_addr, addr->sa_data, netdev->addr_len);\n\n\tatlx_set_mac_addr(&adapter->hw);\n\treturn 0;\n}\n\nstatic void atlx_check_for_link(struct atlx_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tu16 phy_data = 0;\n\n\tspin_lock(&adapter->lock);\n\tadapter->phy_timer_pending = false;\n\tatlx_read_phy_reg(&adapter->hw, MII_BMSR, &phy_data);\n\tatlx_read_phy_reg(&adapter->hw, MII_BMSR, &phy_data);\n\tspin_unlock(&adapter->lock);\n\n\t \n\tif (!(phy_data & BMSR_LSTATUS)) {\n\t\t \n\t\tif (netif_carrier_ok(netdev)) {\n\t\t\t \n\t\t\tdev_info(&adapter->pdev->dev, \"%s link is down\\n\",\n\t\t\t\tnetdev->name);\n\t\t\tadapter->link_speed = SPEED_0;\n\t\t\tnetif_carrier_off(netdev);\n\t\t}\n\t}\n\tschedule_work(&adapter->link_chg_task);\n}\n\n \nstatic void atlx_set_multi(struct net_device *netdev)\n{\n\tstruct atlx_adapter *adapter = netdev_priv(netdev);\n\tstruct atlx_hw *hw = &adapter->hw;\n\tstruct netdev_hw_addr *ha;\n\tu32 rctl;\n\tu32 hash_value;\n\n\t \n\trctl = ioread32(hw->hw_addr + REG_MAC_CTRL);\n\tif (netdev->flags & IFF_PROMISC)\n\t\trctl |= MAC_CTRL_PROMIS_EN;\n\telse if (netdev->flags & IFF_ALLMULTI) {\n\t\trctl |= MAC_CTRL_MC_ALL_EN;\n\t\trctl &= ~MAC_CTRL_PROMIS_EN;\n\t} else\n\t\trctl &= ~(MAC_CTRL_PROMIS_EN | MAC_CTRL_MC_ALL_EN);\n\n\tiowrite32(rctl, hw->hw_addr + REG_MAC_CTRL);\n\n\t \n\tiowrite32(0, hw->hw_addr + REG_RX_HASH_TABLE);\n\tiowrite32(0, (hw->hw_addr + REG_RX_HASH_TABLE) + (1 << 2));\n\n\t \n\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\thash_value = atlx_hash_mc_addr(hw, ha->addr);\n\t\tatlx_hash_set(hw, hash_value);\n\t}\n}\n\nstatic inline void atlx_imr_set(struct atlx_adapter *adapter,\n\t\t\t\tunsigned int imr)\n{\n\tiowrite32(imr, adapter->hw.hw_addr + REG_IMR);\n\tioread32(adapter->hw.hw_addr + REG_IMR);\n}\n\n \nstatic void atlx_irq_enable(struct atlx_adapter *adapter)\n{\n\tatlx_imr_set(adapter, IMR_NORMAL_MASK);\n\tadapter->int_enabled = true;\n}\n\n \nstatic void atlx_irq_disable(struct atlx_adapter *adapter)\n{\n\tadapter->int_enabled = false;\n\tatlx_imr_set(adapter, 0);\n\tsynchronize_irq(adapter->pdev->irq);\n}\n\nstatic void atlx_clear_phy_int(struct atlx_adapter *adapter)\n{\n\tu16 phy_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->lock, flags);\n\tatlx_read_phy_reg(&adapter->hw, 19, &phy_data);\n\tspin_unlock_irqrestore(&adapter->lock, flags);\n}\n\n \nstatic void atlx_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct atlx_adapter *adapter = netdev_priv(netdev);\n\t \n\tschedule_work(&adapter->reset_dev_task);\n}\n\n \nstatic void atlx_link_chg_task(struct work_struct *work)\n{\n\tstruct atlx_adapter *adapter;\n\tunsigned long flags;\n\n\tadapter = container_of(work, struct atlx_adapter, link_chg_task);\n\n\tspin_lock_irqsave(&adapter->lock, flags);\n\tatlx_check_link(adapter);\n\tspin_unlock_irqrestore(&adapter->lock, flags);\n}\n\nstatic void __atlx_vlan_mode(netdev_features_t features, u32 *ctrl)\n{\n\tif (features & NETIF_F_HW_VLAN_CTAG_RX) {\n\t\t \n\t\t*ctrl |= MAC_CTRL_RMV_VLAN;\n\t} else {\n\t\t \n\t\t*ctrl &= ~MAC_CTRL_RMV_VLAN;\n\t}\n}\n\nstatic void atlx_vlan_mode(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\tstruct atlx_adapter *adapter = netdev_priv(netdev);\n\tunsigned long flags;\n\tu32 ctrl;\n\n\tspin_lock_irqsave(&adapter->lock, flags);\n\t \n\tctrl = ioread32(adapter->hw.hw_addr + REG_MAC_CTRL);\n\t__atlx_vlan_mode(features, &ctrl);\n\tiowrite32(ctrl, adapter->hw.hw_addr + REG_MAC_CTRL);\n\t \n\tspin_unlock_irqrestore(&adapter->lock, flags);\n}\n\nstatic void atlx_restore_vlan(struct atlx_adapter *adapter)\n{\n\tatlx_vlan_mode(adapter->netdev, adapter->netdev->features);\n}\n\nstatic netdev_features_t atlx_fix_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\t \n\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\n\telse\n\t\tfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\n\n\treturn features;\n}\n\nstatic int atlx_set_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\tnetdev_features_t changed = netdev->features ^ features;\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tatlx_vlan_mode(netdev, features);\n\n\treturn 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}