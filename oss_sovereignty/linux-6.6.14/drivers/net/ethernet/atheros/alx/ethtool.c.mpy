{
  "module_name": "ethtool.c",
  "hash_id": "d678df9f5785b59116d757e07f41f463b1cd82317be3ba382e11addb3848845a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/atheros/alx/ethtool.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/mdio.h>\n#include <linux/interrupt.h>\n#include <asm/byteorder.h>\n\n#include \"alx.h\"\n#include \"reg.h\"\n#include \"hw.h\"\n\n \nstatic const char alx_gstrings_stats[][ETH_GSTRING_LEN] = {\n\t\"rx_packets\",\n\t\"rx_bcast_packets\",\n\t\"rx_mcast_packets\",\n\t\"rx_pause_packets\",\n\t\"rx_ctrl_packets\",\n\t\"rx_fcs_errors\",\n\t\"rx_length_errors\",\n\t\"rx_bytes\",\n\t\"rx_runt_packets\",\n\t\"rx_fragments\",\n\t\"rx_64B_or_less_packets\",\n\t\"rx_65B_to_127B_packets\",\n\t\"rx_128B_to_255B_packets\",\n\t\"rx_256B_to_511B_packets\",\n\t\"rx_512B_to_1023B_packets\",\n\t\"rx_1024B_to_1518B_packets\",\n\t\"rx_1519B_to_mtu_packets\",\n\t\"rx_oversize_packets\",\n\t\"rx_rxf_ov_drop_packets\",\n\t\"rx_rrd_ov_drop_packets\",\n\t\"rx_align_errors\",\n\t\"rx_bcast_bytes\",\n\t\"rx_mcast_bytes\",\n\t\"rx_address_errors\",\n\t\"tx_packets\",\n\t\"tx_bcast_packets\",\n\t\"tx_mcast_packets\",\n\t\"tx_pause_packets\",\n\t\"tx_exc_defer_packets\",\n\t\"tx_ctrl_packets\",\n\t\"tx_defer_packets\",\n\t\"tx_bytes\",\n\t\"tx_64B_or_less_packets\",\n\t\"tx_65B_to_127B_packets\",\n\t\"tx_128B_to_255B_packets\",\n\t\"tx_256B_to_511B_packets\",\n\t\"tx_512B_to_1023B_packets\",\n\t\"tx_1024B_to_1518B_packets\",\n\t\"tx_1519B_to_mtu_packets\",\n\t\"tx_single_collision\",\n\t\"tx_multiple_collisions\",\n\t\"tx_late_collision\",\n\t\"tx_abort_collision\",\n\t\"tx_underrun\",\n\t\"tx_trd_eop\",\n\t\"tx_length_errors\",\n\t\"tx_trunc_packets\",\n\t\"tx_bcast_bytes\",\n\t\"tx_mcast_bytes\",\n\t\"tx_update\",\n};\n\n#define ALX_NUM_STATS ARRAY_SIZE(alx_gstrings_stats)\n\n\nstatic u32 alx_get_supported_speeds(struct alx_hw *hw)\n{\n\tu32 supported = SUPPORTED_10baseT_Half |\n\t\t\tSUPPORTED_10baseT_Full |\n\t\t\tSUPPORTED_100baseT_Half |\n\t\t\tSUPPORTED_100baseT_Full;\n\n\tif (alx_hw_giga(hw))\n\t\tsupported |= SUPPORTED_1000baseT_Full;\n\n\tBUILD_BUG_ON(SUPPORTED_10baseT_Half != ADVERTISED_10baseT_Half);\n\tBUILD_BUG_ON(SUPPORTED_10baseT_Full != ADVERTISED_10baseT_Full);\n\tBUILD_BUG_ON(SUPPORTED_100baseT_Half != ADVERTISED_100baseT_Half);\n\tBUILD_BUG_ON(SUPPORTED_100baseT_Full != ADVERTISED_100baseT_Full);\n\tBUILD_BUG_ON(SUPPORTED_1000baseT_Full != ADVERTISED_1000baseT_Full);\n\n\treturn supported;\n}\n\nstatic int alx_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tstruct alx_priv *alx = netdev_priv(netdev);\n\tstruct alx_hw *hw = &alx->hw;\n\tu32 supported, advertising;\n\n\tsupported = SUPPORTED_Autoneg |\n\t\t\t  SUPPORTED_TP |\n\t\t\t  SUPPORTED_Pause |\n\t\t\t  SUPPORTED_Asym_Pause;\n\tif (alx_hw_giga(hw))\n\t\tsupported |= SUPPORTED_1000baseT_Full;\n\tsupported |= alx_get_supported_speeds(hw);\n\n\tadvertising = ADVERTISED_TP;\n\tif (hw->adv_cfg & ADVERTISED_Autoneg)\n\t\tadvertising |= hw->adv_cfg;\n\n\tcmd->base.port = PORT_TP;\n\tcmd->base.phy_address = 0;\n\n\tif (hw->adv_cfg & ADVERTISED_Autoneg)\n\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\telse\n\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\n\tif (hw->flowctrl & ALX_FC_ANEG && hw->adv_cfg & ADVERTISED_Autoneg) {\n\t\tif (hw->flowctrl & ALX_FC_RX) {\n\t\t\tadvertising |= ADVERTISED_Pause;\n\n\t\t\tif (!(hw->flowctrl & ALX_FC_TX))\n\t\t\t\tadvertising |= ADVERTISED_Asym_Pause;\n\t\t} else if (hw->flowctrl & ALX_FC_TX) {\n\t\t\tadvertising |= ADVERTISED_Asym_Pause;\n\t\t}\n\t}\n\n\tmutex_lock(&alx->mtx);\n\tcmd->base.speed = hw->link_speed;\n\tcmd->base.duplex = hw->duplex;\n\tmutex_unlock(&alx->mtx);\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int alx_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t  const struct ethtool_link_ksettings *cmd)\n{\n\tstruct alx_priv *alx = netdev_priv(netdev);\n\tstruct alx_hw *hw = &alx->hw;\n\tu32 adv_cfg;\n\tu32 advertising;\n\tint ret;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tif (advertising & ~alx_get_supported_speeds(hw))\n\t\t\treturn -EINVAL;\n\t\tadv_cfg = advertising | ADVERTISED_Autoneg;\n\t} else {\n\t\tadv_cfg = alx_speed_to_ethadv(cmd->base.speed,\n\t\t\t\t\t      cmd->base.duplex);\n\n\t\tif (!adv_cfg || adv_cfg == ADVERTISED_1000baseT_Full)\n\t\t\treturn -EINVAL;\n\t}\n\n\thw->adv_cfg = adv_cfg;\n\n\tmutex_lock(&alx->mtx);\n\tret = alx_setup_speed_duplex(hw, adv_cfg, hw->flowctrl);\n\tmutex_unlock(&alx->mtx);\n\n\treturn ret;\n}\n\nstatic void alx_get_pauseparam(struct net_device *netdev,\n\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tstruct alx_priv *alx = netdev_priv(netdev);\n\tstruct alx_hw *hw = &alx->hw;\n\n\tmutex_lock(&alx->mtx);\n\tpause->autoneg = !!(hw->flowctrl & ALX_FC_ANEG &&\n\t\t\t    hw->adv_cfg & ADVERTISED_Autoneg);\n\tpause->tx_pause = !!(hw->flowctrl & ALX_FC_TX);\n\tpause->rx_pause = !!(hw->flowctrl & ALX_FC_RX);\n\tmutex_unlock(&alx->mtx);\n}\n\n\nstatic int alx_set_pauseparam(struct net_device *netdev,\n\t\t\t      struct ethtool_pauseparam *pause)\n{\n\tstruct alx_priv *alx = netdev_priv(netdev);\n\tstruct alx_hw *hw = &alx->hw;\n\tint err = 0;\n\tbool reconfig_phy = false;\n\tu8 fc = 0;\n\n\tif (pause->tx_pause)\n\t\tfc |= ALX_FC_TX;\n\tif (pause->rx_pause)\n\t\tfc |= ALX_FC_RX;\n\tif (pause->autoneg)\n\t\tfc |= ALX_FC_ANEG;\n\n\tmutex_lock(&alx->mtx);\n\n\t \n\tif (hw->adv_cfg & ADVERTISED_Autoneg) {\n\t\tif (!((fc ^ hw->flowctrl) & ALX_FC_ANEG))\n\t\t\treconfig_phy = true;\n\t\tif (fc & hw->flowctrl & ALX_FC_ANEG &&\n\t\t    (fc ^ hw->flowctrl) & (ALX_FC_RX | ALX_FC_TX))\n\t\t\treconfig_phy = true;\n\t}\n\n\tif (reconfig_phy) {\n\t\terr = alx_setup_speed_duplex(hw, hw->adv_cfg, fc);\n\t\tif (err) {\n\t\t\tmutex_unlock(&alx->mtx);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif ((fc ^ hw->flowctrl) & (ALX_FC_RX | ALX_FC_TX))\n\t\talx_cfg_mac_flowcontrol(hw, fc);\n\n\thw->flowctrl = fc;\n\tmutex_unlock(&alx->mtx);\n\n\treturn 0;\n}\n\nstatic u32 alx_get_msglevel(struct net_device *netdev)\n{\n\tstruct alx_priv *alx = netdev_priv(netdev);\n\n\treturn alx->msg_enable;\n}\n\nstatic void alx_set_msglevel(struct net_device *netdev, u32 data)\n{\n\tstruct alx_priv *alx = netdev_priv(netdev);\n\n\talx->msg_enable = data;\n}\n\nstatic void alx_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t  struct ethtool_stats *estats, u64 *data)\n{\n\tstruct alx_priv *alx = netdev_priv(netdev);\n\tstruct alx_hw *hw = &alx->hw;\n\n\tspin_lock(&alx->stats_lock);\n\n\talx_update_hw_stats(hw);\n\tBUILD_BUG_ON(sizeof(hw->stats) != ALX_NUM_STATS * sizeof(u64));\n\tmemcpy(data, &hw->stats, sizeof(hw->stats));\n\n\tspin_unlock(&alx->stats_lock);\n}\n\nstatic void alx_get_strings(struct net_device *netdev, u32 stringset, u8 *buf)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(buf, &alx_gstrings_stats, sizeof(alx_gstrings_stats));\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nstatic int alx_get_sset_count(struct net_device *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ALX_NUM_STATS;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nconst struct ethtool_ops alx_ethtool_ops = {\n\t.get_pauseparam\t= alx_get_pauseparam,\n\t.set_pauseparam\t= alx_set_pauseparam,\n\t.get_msglevel\t= alx_get_msglevel,\n\t.set_msglevel\t= alx_set_msglevel,\n\t.get_link\t= ethtool_op_get_link,\n\t.get_strings\t= alx_get_strings,\n\t.get_sset_count\t= alx_get_sset_count,\n\t.get_ethtool_stats\t= alx_get_ethtool_stats,\n\t.get_link_ksettings\t= alx_get_link_ksettings,\n\t.set_link_ksettings\t= alx_set_link_ksettings,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}