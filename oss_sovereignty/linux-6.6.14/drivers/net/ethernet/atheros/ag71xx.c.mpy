{
  "module_name": "ag71xx.c",
  "hash_id": "818d51d1ae4dad87a1f2f8e4eb8485a044146028859ddc616464ee9bdabc7c2f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/atheros/ag71xx.c",
  "human_readable_source": "\n \n\n#include <linux/if_vlan.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/platform_device.h>\n#include <linux/phylink.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <net/selftests.h>\n\n \n#define AG71XX_NAPI_WEIGHT\t32\n#define AG71XX_OOM_REFILL\t(1 + HZ / 10)\n\n#define AG71XX_INT_ERR\t(AG71XX_INT_RX_BE | AG71XX_INT_TX_BE)\n#define AG71XX_INT_TX\t(AG71XX_INT_TX_PS)\n#define AG71XX_INT_RX\t(AG71XX_INT_RX_PR | AG71XX_INT_RX_OF)\n\n#define AG71XX_INT_POLL\t(AG71XX_INT_RX | AG71XX_INT_TX)\n#define AG71XX_INT_INIT\t(AG71XX_INT_ERR | AG71XX_INT_POLL)\n\n#define AG71XX_TX_MTU_LEN\t1540\n\n#define AG71XX_TX_RING_SPLIT\t\t512\n#define AG71XX_TX_RING_DS_PER_PKT\tDIV_ROUND_UP(AG71XX_TX_MTU_LEN, \\\n\t\t\t\t\t\t     AG71XX_TX_RING_SPLIT)\n#define AG71XX_TX_RING_SIZE_DEFAULT\t128\n#define AG71XX_RX_RING_SIZE_DEFAULT\t256\n\n#define AG71XX_MDIO_RETRY\t1000\n#define AG71XX_MDIO_DELAY\t5\n#define AG71XX_MDIO_MAX_CLK\t5000000\n\n \n#define AG71XX_REG_MAC_CFG1\t0x0000\n#define MAC_CFG1_TXE\t\tBIT(0)\t \n#define MAC_CFG1_STX\t\tBIT(1)\t \n#define MAC_CFG1_RXE\t\tBIT(2)\t \n#define MAC_CFG1_SRX\t\tBIT(3)\t \n#define MAC_CFG1_TFC\t\tBIT(4)\t \n#define MAC_CFG1_RFC\t\tBIT(5)\t \n#define MAC_CFG1_SR\t\tBIT(31)\t \n#define MAC_CFG1_INIT\t(MAC_CFG1_RXE | MAC_CFG1_TXE | \\\n\t\t\t MAC_CFG1_SRX | MAC_CFG1_STX)\n\n#define AG71XX_REG_MAC_CFG2\t0x0004\n#define MAC_CFG2_FDX\t\tBIT(0)\n#define MAC_CFG2_PAD_CRC_EN\tBIT(2)\n#define MAC_CFG2_LEN_CHECK\tBIT(4)\n#define MAC_CFG2_IF_1000\tBIT(9)\n#define MAC_CFG2_IF_10_100\tBIT(8)\n\n#define AG71XX_REG_MAC_MFL\t0x0010\n\n#define AG71XX_REG_MII_CFG\t0x0020\n#define MII_CFG_CLK_DIV_4\t0\n#define MII_CFG_CLK_DIV_6\t2\n#define MII_CFG_CLK_DIV_8\t3\n#define MII_CFG_CLK_DIV_10\t4\n#define MII_CFG_CLK_DIV_14\t5\n#define MII_CFG_CLK_DIV_20\t6\n#define MII_CFG_CLK_DIV_28\t7\n#define MII_CFG_CLK_DIV_34\t8\n#define MII_CFG_CLK_DIV_42\t9\n#define MII_CFG_CLK_DIV_50\t10\n#define MII_CFG_CLK_DIV_58\t11\n#define MII_CFG_CLK_DIV_66\t12\n#define MII_CFG_CLK_DIV_74\t13\n#define MII_CFG_CLK_DIV_82\t14\n#define MII_CFG_CLK_DIV_98\t15\n#define MII_CFG_RESET\t\tBIT(31)\n\n#define AG71XX_REG_MII_CMD\t0x0024\n#define MII_CMD_READ\t\tBIT(0)\n\n#define AG71XX_REG_MII_ADDR\t0x0028\n#define MII_ADDR_SHIFT\t\t8\n\n#define AG71XX_REG_MII_CTRL\t0x002c\n#define AG71XX_REG_MII_STATUS\t0x0030\n#define AG71XX_REG_MII_IND\t0x0034\n#define MII_IND_BUSY\t\tBIT(0)\n#define MII_IND_INVALID\t\tBIT(2)\n\n#define AG71XX_REG_MAC_IFCTL\t0x0038\n#define MAC_IFCTL_SPEED\t\tBIT(16)\n\n#define AG71XX_REG_MAC_ADDR1\t0x0040\n#define AG71XX_REG_MAC_ADDR2\t0x0044\n#define AG71XX_REG_FIFO_CFG0\t0x0048\n#define FIFO_CFG0_WTM\t\tBIT(0)\t \n#define FIFO_CFG0_RXS\t\tBIT(1)\t \n#define FIFO_CFG0_RXF\t\tBIT(2)\t \n#define FIFO_CFG0_TXS\t\tBIT(3)\t \n#define FIFO_CFG0_TXF\t\tBIT(4)\t \n#define FIFO_CFG0_ALL\t(FIFO_CFG0_WTM | FIFO_CFG0_RXS | FIFO_CFG0_RXF \\\n\t\t\t| FIFO_CFG0_TXS | FIFO_CFG0_TXF)\n#define FIFO_CFG0_INIT\t(FIFO_CFG0_ALL << FIFO_CFG0_ENABLE_SHIFT)\n\n#define FIFO_CFG0_ENABLE_SHIFT\t8\n\n#define AG71XX_REG_FIFO_CFG1\t0x004c\n#define AG71XX_REG_FIFO_CFG2\t0x0050\n#define AG71XX_REG_FIFO_CFG3\t0x0054\n#define AG71XX_REG_FIFO_CFG4\t0x0058\n#define FIFO_CFG4_DE\t\tBIT(0)\t \n#define FIFO_CFG4_DV\t\tBIT(1)\t \n#define FIFO_CFG4_FC\t\tBIT(2)\t \n#define FIFO_CFG4_CE\t\tBIT(3)\t \n#define FIFO_CFG4_CR\t\tBIT(4)\t \n#define FIFO_CFG4_LM\t\tBIT(5)\t \n#define FIFO_CFG4_LO\t\tBIT(6)\t \n#define FIFO_CFG4_OK\t\tBIT(7)\t \n#define FIFO_CFG4_MC\t\tBIT(8)\t \n#define FIFO_CFG4_BC\t\tBIT(9)\t \n#define FIFO_CFG4_DR\t\tBIT(10)\t \n#define FIFO_CFG4_LE\t\tBIT(11)\t \n#define FIFO_CFG4_CF\t\tBIT(12)\t \n#define FIFO_CFG4_PF\t\tBIT(13)\t \n#define FIFO_CFG4_UO\t\tBIT(14)\t \n#define FIFO_CFG4_VT\t\tBIT(15)\t \n#define FIFO_CFG4_FT\t\tBIT(16)\t \n#define FIFO_CFG4_UC\t\tBIT(17)\t \n#define FIFO_CFG4_INIT\t(FIFO_CFG4_DE | FIFO_CFG4_DV | FIFO_CFG4_FC | \\\n\t\t\t FIFO_CFG4_CE | FIFO_CFG4_CR | FIFO_CFG4_LM | \\\n\t\t\t FIFO_CFG4_LO | FIFO_CFG4_OK | FIFO_CFG4_MC | \\\n\t\t\t FIFO_CFG4_BC | FIFO_CFG4_DR | FIFO_CFG4_LE | \\\n\t\t\t FIFO_CFG4_CF | FIFO_CFG4_PF | FIFO_CFG4_UO | \\\n\t\t\t FIFO_CFG4_VT)\n\n#define AG71XX_REG_FIFO_CFG5\t0x005c\n#define FIFO_CFG5_DE\t\tBIT(0)\t \n#define FIFO_CFG5_DV\t\tBIT(1)\t \n#define FIFO_CFG5_FC\t\tBIT(2)\t \n#define FIFO_CFG5_CE\t\tBIT(3)\t \n#define FIFO_CFG5_LM\t\tBIT(4)\t \n#define FIFO_CFG5_LO\t\tBIT(5)\t \n#define FIFO_CFG5_OK\t\tBIT(6)\t \n#define FIFO_CFG5_MC\t\tBIT(7)\t \n#define FIFO_CFG5_BC\t\tBIT(8)\t \n#define FIFO_CFG5_DR\t\tBIT(9)\t \n#define FIFO_CFG5_CF\t\tBIT(10)\t \n#define FIFO_CFG5_PF\t\tBIT(11)\t \n#define FIFO_CFG5_UO\t\tBIT(12)\t \n#define FIFO_CFG5_VT\t\tBIT(13)\t \n#define FIFO_CFG5_LE\t\tBIT(14)\t \n#define FIFO_CFG5_FT\t\tBIT(15)\t \n#define FIFO_CFG5_16\t\tBIT(16)\t \n#define FIFO_CFG5_17\t\tBIT(17)\t \n#define FIFO_CFG5_SF\t\tBIT(18)\t \n#define FIFO_CFG5_BM\t\tBIT(19)\t \n#define FIFO_CFG5_INIT\t(FIFO_CFG5_DE | FIFO_CFG5_DV | FIFO_CFG5_FC | \\\n\t\t\t FIFO_CFG5_CE | FIFO_CFG5_LO | FIFO_CFG5_OK | \\\n\t\t\t FIFO_CFG5_MC | FIFO_CFG5_BC | FIFO_CFG5_DR | \\\n\t\t\t FIFO_CFG5_CF | FIFO_CFG5_PF | FIFO_CFG5_VT | \\\n\t\t\t FIFO_CFG5_LE | FIFO_CFG5_FT | FIFO_CFG5_16 | \\\n\t\t\t FIFO_CFG5_17 | FIFO_CFG5_SF)\n\n#define AG71XX_REG_TX_CTRL\t0x0180\n#define TX_CTRL_TXE\t\tBIT(0)\t \n\n#define AG71XX_REG_TX_DESC\t0x0184\n#define AG71XX_REG_TX_STATUS\t0x0188\n#define TX_STATUS_PS\t\tBIT(0)\t \n#define TX_STATUS_UR\t\tBIT(1)\t \n#define TX_STATUS_BE\t\tBIT(3)\t \n\n#define AG71XX_REG_RX_CTRL\t0x018c\n#define RX_CTRL_RXE\t\tBIT(0)\t \n\n#define AG71XX_DMA_RETRY\t10\n#define AG71XX_DMA_DELAY\t1\n\n#define AG71XX_REG_RX_DESC\t0x0190\n#define AG71XX_REG_RX_STATUS\t0x0194\n#define RX_STATUS_PR\t\tBIT(0)\t \n#define RX_STATUS_OF\t\tBIT(2)\t \n#define RX_STATUS_BE\t\tBIT(3)\t \n\n#define AG71XX_REG_INT_ENABLE\t0x0198\n#define AG71XX_REG_INT_STATUS\t0x019c\n#define AG71XX_INT_TX_PS\tBIT(0)\n#define AG71XX_INT_TX_UR\tBIT(1)\n#define AG71XX_INT_TX_BE\tBIT(3)\n#define AG71XX_INT_RX_PR\tBIT(4)\n#define AG71XX_INT_RX_OF\tBIT(6)\n#define AG71XX_INT_RX_BE\tBIT(7)\n\n#define AG71XX_REG_FIFO_DEPTH\t0x01a8\n#define AG71XX_REG_RX_SM\t0x01b0\n#define AG71XX_REG_TX_SM\t0x01b4\n\n#define AG71XX_DEFAULT_MSG_ENABLE\t\\\n\t(NETIF_MSG_DRV\t\t\t\\\n\t| NETIF_MSG_PROBE\t\t\\\n\t| NETIF_MSG_LINK\t\t\\\n\t| NETIF_MSG_TIMER\t\t\\\n\t| NETIF_MSG_IFDOWN\t\t\\\n\t| NETIF_MSG_IFUP\t\t\\\n\t| NETIF_MSG_RX_ERR\t\t\\\n\t| NETIF_MSG_TX_ERR)\n\nstruct ag71xx_statistic {\n\tunsigned short offset;\n\tu32 mask;\n\tconst char name[ETH_GSTRING_LEN];\n};\n\nstatic const struct ag71xx_statistic ag71xx_statistics[] = {\n\t{ 0x0080, GENMASK(17, 0), \"Tx/Rx 64 Byte\", },\n\t{ 0x0084, GENMASK(17, 0), \"Tx/Rx 65-127 Byte\", },\n\t{ 0x0088, GENMASK(17, 0), \"Tx/Rx 128-255 Byte\", },\n\t{ 0x008C, GENMASK(17, 0), \"Tx/Rx 256-511 Byte\", },\n\t{ 0x0090, GENMASK(17, 0), \"Tx/Rx 512-1023 Byte\", },\n\t{ 0x0094, GENMASK(17, 0), \"Tx/Rx 1024-1518 Byte\", },\n\t{ 0x0098, GENMASK(17, 0), \"Tx/Rx 1519-1522 Byte VLAN\", },\n\t{ 0x009C, GENMASK(23, 0), \"Rx Byte\", },\n\t{ 0x00A0, GENMASK(17, 0), \"Rx Packet\", },\n\t{ 0x00A4, GENMASK(11, 0), \"Rx FCS Error\", },\n\t{ 0x00A8, GENMASK(17, 0), \"Rx Multicast Packet\", },\n\t{ 0x00AC, GENMASK(21, 0), \"Rx Broadcast Packet\", },\n\t{ 0x00B0, GENMASK(17, 0), \"Rx Control Frame Packet\", },\n\t{ 0x00B4, GENMASK(11, 0), \"Rx Pause Frame Packet\", },\n\t{ 0x00B8, GENMASK(11, 0), \"Rx Unknown OPCode Packet\", },\n\t{ 0x00BC, GENMASK(11, 0), \"Rx Alignment Error\", },\n\t{ 0x00C0, GENMASK(15, 0), \"Rx Frame Length Error\", },\n\t{ 0x00C4, GENMASK(11, 0), \"Rx Code Error\", },\n\t{ 0x00C8, GENMASK(11, 0), \"Rx Carrier Sense Error\", },\n\t{ 0x00CC, GENMASK(11, 0), \"Rx Undersize Packet\", },\n\t{ 0x00D0, GENMASK(11, 0), \"Rx Oversize Packet\", },\n\t{ 0x00D4, GENMASK(11, 0), \"Rx Fragments\", },\n\t{ 0x00D8, GENMASK(11, 0), \"Rx Jabber\", },\n\t{ 0x00DC, GENMASK(11, 0), \"Rx Dropped Packet\", },\n\t{ 0x00E0, GENMASK(23, 0), \"Tx Byte\", },\n\t{ 0x00E4, GENMASK(17, 0), \"Tx Packet\", },\n\t{ 0x00E8, GENMASK(17, 0), \"Tx Multicast Packet\", },\n\t{ 0x00EC, GENMASK(17, 0), \"Tx Broadcast Packet\", },\n\t{ 0x00F0, GENMASK(11, 0), \"Tx Pause Control Frame\", },\n\t{ 0x00F4, GENMASK(11, 0), \"Tx Deferral Packet\", },\n\t{ 0x00F8, GENMASK(11, 0), \"Tx Excessive Deferral Packet\", },\n\t{ 0x00FC, GENMASK(11, 0), \"Tx Single Collision Packet\", },\n\t{ 0x0100, GENMASK(11, 0), \"Tx Multiple Collision\", },\n\t{ 0x0104, GENMASK(11, 0), \"Tx Late Collision Packet\", },\n\t{ 0x0108, GENMASK(11, 0), \"Tx Excessive Collision Packet\", },\n\t{ 0x010C, GENMASK(12, 0), \"Tx Total Collision\", },\n\t{ 0x0110, GENMASK(11, 0), \"Tx Pause Frames Honored\", },\n\t{ 0x0114, GENMASK(11, 0), \"Tx Drop Frame\", },\n\t{ 0x0118, GENMASK(11, 0), \"Tx Jabber Frame\", },\n\t{ 0x011C, GENMASK(11, 0), \"Tx FCS Error\", },\n\t{ 0x0120, GENMASK(11, 0), \"Tx Control Frame\", },\n\t{ 0x0124, GENMASK(11, 0), \"Tx Oversize Frame\", },\n\t{ 0x0128, GENMASK(11, 0), \"Tx Undersize Frame\", },\n\t{ 0x012C, GENMASK(11, 0), \"Tx Fragment\", },\n};\n\n#define DESC_EMPTY\t\tBIT(31)\n#define DESC_MORE\t\tBIT(24)\n#define DESC_PKTLEN_M\t\t0xfff\nstruct ag71xx_desc {\n\tu32 data;\n\tu32 ctrl;\n\tu32 next;\n\tu32 pad;\n} __aligned(4);\n\n#define AG71XX_DESC_SIZE\troundup(sizeof(struct ag71xx_desc), \\\n\t\t\t\t\tL1_CACHE_BYTES)\n\nstruct ag71xx_buf {\n\tunion {\n\t\tstruct {\n\t\t\tstruct sk_buff *skb;\n\t\t\tunsigned int len;\n\t\t} tx;\n\t\tstruct {\n\t\t\tdma_addr_t dma_addr;\n\t\t\tvoid *rx_buf;\n\t\t} rx;\n\t};\n};\n\nstruct ag71xx_ring {\n\t \n\tunsigned int curr;\n\tunsigned int dirty;\n\n\t \n\tstruct ag71xx_buf *buf;\n\tu16 order;\n\tu16 desc_split;\n\tdma_addr_t descs_dma;\n\tu8 *descs_cpu;\n};\n\nenum ag71xx_type {\n\tAR7100,\n\tAR7240,\n\tAR9130,\n\tAR9330,\n\tAR9340,\n\tQCA9530,\n\tQCA9550,\n};\n\nstruct ag71xx_dcfg {\n\tu32 max_frame_len;\n\tconst u32 *fifodata;\n\tu16 desc_pktlen_mask;\n\tbool tx_hang_workaround;\n\tenum ag71xx_type type;\n};\n\nstruct ag71xx {\n\t \n\tstruct ag71xx_ring rx_ring ____cacheline_aligned;\n\tstruct ag71xx_ring tx_ring ____cacheline_aligned;\n\n\tu16 rx_buf_size;\n\tu8 rx_buf_offset;\n\n\tstruct net_device *ndev;\n\tstruct platform_device *pdev;\n\tstruct napi_struct napi;\n\tu32 msg_enable;\n\tconst struct ag71xx_dcfg *dcfg;\n\n\t \n\tvoid __iomem *mac_base;\n\n\tstruct ag71xx_desc *stop_desc;\n\tdma_addr_t stop_desc_dma;\n\n\tphy_interface_t phy_if_mode;\n\tstruct phylink *phylink;\n\tstruct phylink_config phylink_config;\n\n\tstruct delayed_work restart_work;\n\tstruct timer_list oom_timer;\n\n\tstruct reset_control *mac_reset;\n\n\tu32 fifodata[3];\n\tint mac_idx;\n\n\tstruct reset_control *mdio_reset;\n\tstruct mii_bus *mii_bus;\n\tstruct clk *clk_mdio;\n\tstruct clk *clk_eth;\n};\n\nstatic int ag71xx_desc_empty(struct ag71xx_desc *desc)\n{\n\treturn (desc->ctrl & DESC_EMPTY) != 0;\n}\n\nstatic struct ag71xx_desc *ag71xx_ring_desc(struct ag71xx_ring *ring, int idx)\n{\n\treturn (struct ag71xx_desc *)&ring->descs_cpu[idx * AG71XX_DESC_SIZE];\n}\n\nstatic int ag71xx_ring_size_order(int size)\n{\n\treturn fls(size - 1);\n}\n\nstatic bool ag71xx_is(struct ag71xx *ag, enum ag71xx_type type)\n{\n\treturn ag->dcfg->type == type;\n}\n\nstatic void ag71xx_wr(struct ag71xx *ag, unsigned int reg, u32 value)\n{\n\tiowrite32(value, ag->mac_base + reg);\n\t \n\t(void)ioread32(ag->mac_base + reg);\n}\n\nstatic u32 ag71xx_rr(struct ag71xx *ag, unsigned int reg)\n{\n\treturn ioread32(ag->mac_base + reg);\n}\n\nstatic void ag71xx_sb(struct ag71xx *ag, unsigned int reg, u32 mask)\n{\n\tvoid __iomem *r;\n\n\tr = ag->mac_base + reg;\n\tiowrite32(ioread32(r) | mask, r);\n\t \n\t(void)ioread32(r);\n}\n\nstatic void ag71xx_cb(struct ag71xx *ag, unsigned int reg, u32 mask)\n{\n\tvoid __iomem *r;\n\n\tr = ag->mac_base + reg;\n\tiowrite32(ioread32(r) & ~mask, r);\n\t \n\t(void)ioread32(r);\n}\n\nstatic void ag71xx_int_enable(struct ag71xx *ag, u32 ints)\n{\n\tag71xx_sb(ag, AG71XX_REG_INT_ENABLE, ints);\n}\n\nstatic void ag71xx_int_disable(struct ag71xx *ag, u32 ints)\n{\n\tag71xx_cb(ag, AG71XX_REG_INT_ENABLE, ints);\n}\n\nstatic void ag71xx_get_drvinfo(struct net_device *ndev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstruct ag71xx *ag = netdev_priv(ndev);\n\n\tstrscpy(info->driver, \"ag71xx\", sizeof(info->driver));\n\tstrscpy(info->bus_info, of_node_full_name(ag->pdev->dev.of_node),\n\t\tsizeof(info->bus_info));\n}\n\nstatic int ag71xx_get_link_ksettings(struct net_device *ndev,\n\t\t\t\t   struct ethtool_link_ksettings *kset)\n{\n\tstruct ag71xx *ag = netdev_priv(ndev);\n\n\treturn phylink_ethtool_ksettings_get(ag->phylink, kset);\n}\n\nstatic int ag71xx_set_link_ksettings(struct net_device *ndev,\n\t\t\t\t   const struct ethtool_link_ksettings *kset)\n{\n\tstruct ag71xx *ag = netdev_priv(ndev);\n\n\treturn phylink_ethtool_ksettings_set(ag->phylink, kset);\n}\n\nstatic int ag71xx_ethtool_nway_reset(struct net_device *ndev)\n{\n\tstruct ag71xx *ag = netdev_priv(ndev);\n\n\treturn phylink_ethtool_nway_reset(ag->phylink);\n}\n\nstatic void ag71xx_ethtool_get_pauseparam(struct net_device *ndev,\n\t\t\t\t\t  struct ethtool_pauseparam *pause)\n{\n\tstruct ag71xx *ag = netdev_priv(ndev);\n\n\tphylink_ethtool_get_pauseparam(ag->phylink, pause);\n}\n\nstatic int ag71xx_ethtool_set_pauseparam(struct net_device *ndev,\n\t\t\t\t\t struct ethtool_pauseparam *pause)\n{\n\tstruct ag71xx *ag = netdev_priv(ndev);\n\n\treturn phylink_ethtool_set_pauseparam(ag->phylink, pause);\n}\n\nstatic void ag71xx_ethtool_get_strings(struct net_device *netdev, u32 sset,\n\t\t\t\t       u8 *data)\n{\n\tint i;\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < ARRAY_SIZE(ag71xx_statistics); i++)\n\t\t\tmemcpy(data + i * ETH_GSTRING_LEN,\n\t\t\t       ag71xx_statistics[i].name, ETH_GSTRING_LEN);\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tnet_selftest_get_strings(data);\n\t\tbreak;\n\t}\n}\n\nstatic void ag71xx_ethtool_get_stats(struct net_device *ndev,\n\t\t\t\t     struct ethtool_stats *stats, u64 *data)\n{\n\tstruct ag71xx *ag = netdev_priv(ndev);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ag71xx_statistics); i++)\n\t\t*data++ = ag71xx_rr(ag, ag71xx_statistics[i].offset)\n\t\t\t\t& ag71xx_statistics[i].mask;\n}\n\nstatic int ag71xx_ethtool_get_sset_count(struct net_device *ndev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(ag71xx_statistics);\n\tcase ETH_SS_TEST:\n\t\treturn net_selftest_get_count();\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct ethtool_ops ag71xx_ethtool_ops = {\n\t.get_drvinfo\t\t\t= ag71xx_get_drvinfo,\n\t.get_link\t\t\t= ethtool_op_get_link,\n\t.get_ts_info\t\t\t= ethtool_op_get_ts_info,\n\t.get_link_ksettings\t\t= ag71xx_get_link_ksettings,\n\t.set_link_ksettings\t\t= ag71xx_set_link_ksettings,\n\t.nway_reset\t\t\t= ag71xx_ethtool_nway_reset,\n\t.get_pauseparam\t\t\t= ag71xx_ethtool_get_pauseparam,\n\t.set_pauseparam\t\t\t= ag71xx_ethtool_set_pauseparam,\n\t.get_strings\t\t\t= ag71xx_ethtool_get_strings,\n\t.get_ethtool_stats\t\t= ag71xx_ethtool_get_stats,\n\t.get_sset_count\t\t\t= ag71xx_ethtool_get_sset_count,\n\t.self_test\t\t\t= net_selftest,\n};\n\nstatic int ag71xx_mdio_wait_busy(struct ag71xx *ag)\n{\n\tstruct net_device *ndev = ag->ndev;\n\tint i;\n\n\tfor (i = 0; i < AG71XX_MDIO_RETRY; i++) {\n\t\tu32 busy;\n\n\t\tudelay(AG71XX_MDIO_DELAY);\n\n\t\tbusy = ag71xx_rr(ag, AG71XX_REG_MII_IND);\n\t\tif (!busy)\n\t\t\treturn 0;\n\n\t\tudelay(AG71XX_MDIO_DELAY);\n\t}\n\n\tnetif_err(ag, link, ndev, \"MDIO operation timed out\\n\");\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int ag71xx_mdio_mii_read(struct mii_bus *bus, int addr, int reg)\n{\n\tstruct ag71xx *ag = bus->priv;\n\tint err, val;\n\n\terr = ag71xx_mdio_wait_busy(ag);\n\tif (err)\n\t\treturn err;\n\n\tag71xx_wr(ag, AG71XX_REG_MII_ADDR,\n\t\t  ((addr & 0x1f) << MII_ADDR_SHIFT) | (reg & 0xff));\n\t \n\tag71xx_wr(ag, AG71XX_REG_MII_CMD, MII_CMD_READ);\n\n\terr = ag71xx_mdio_wait_busy(ag);\n\tif (err)\n\t\treturn err;\n\n\tval = ag71xx_rr(ag, AG71XX_REG_MII_STATUS);\n\t \n\tag71xx_wr(ag, AG71XX_REG_MII_CMD, 0);\n\n\tnetif_dbg(ag, link, ag->ndev, \"mii_read: addr=%04x, reg=%04x, value=%04x\\n\",\n\t\t  addr, reg, val);\n\n\treturn val;\n}\n\nstatic int ag71xx_mdio_mii_write(struct mii_bus *bus, int addr, int reg,\n\t\t\t\t u16 val)\n{\n\tstruct ag71xx *ag = bus->priv;\n\n\tnetif_dbg(ag, link, ag->ndev, \"mii_write: addr=%04x, reg=%04x, value=%04x\\n\",\n\t\t  addr, reg, val);\n\n\tag71xx_wr(ag, AG71XX_REG_MII_ADDR,\n\t\t  ((addr & 0x1f) << MII_ADDR_SHIFT) | (reg & 0xff));\n\tag71xx_wr(ag, AG71XX_REG_MII_CTRL, val);\n\n\treturn ag71xx_mdio_wait_busy(ag);\n}\n\nstatic const u32 ar71xx_mdio_div_table[] = {\n\t4, 4, 6, 8, 10, 14, 20, 28,\n};\n\nstatic const u32 ar7240_mdio_div_table[] = {\n\t2, 2, 4, 6, 8, 12, 18, 26, 32, 40, 48, 56, 62, 70, 78, 96,\n};\n\nstatic const u32 ar933x_mdio_div_table[] = {\n\t4, 4, 6, 8, 10, 14, 20, 28, 34, 42, 50, 58, 66, 74, 82, 98,\n};\n\nstatic int ag71xx_mdio_get_divider(struct ag71xx *ag, u32 *div)\n{\n\tunsigned long ref_clock;\n\tconst u32 *table;\n\tint ndivs, i;\n\n\tref_clock = clk_get_rate(ag->clk_mdio);\n\tif (!ref_clock)\n\t\treturn -EINVAL;\n\n\tif (ag71xx_is(ag, AR9330) || ag71xx_is(ag, AR9340)) {\n\t\ttable = ar933x_mdio_div_table;\n\t\tndivs = ARRAY_SIZE(ar933x_mdio_div_table);\n\t} else if (ag71xx_is(ag, AR7240)) {\n\t\ttable = ar7240_mdio_div_table;\n\t\tndivs = ARRAY_SIZE(ar7240_mdio_div_table);\n\t} else {\n\t\ttable = ar71xx_mdio_div_table;\n\t\tndivs = ARRAY_SIZE(ar71xx_mdio_div_table);\n\t}\n\n\tfor (i = 0; i < ndivs; i++) {\n\t\tunsigned long t;\n\n\t\tt = ref_clock / table[i];\n\t\tif (t <= AG71XX_MDIO_MAX_CLK) {\n\t\t\t*div = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int ag71xx_mdio_reset(struct mii_bus *bus)\n{\n\tstruct ag71xx *ag = bus->priv;\n\tint err;\n\tu32 t;\n\n\terr = ag71xx_mdio_get_divider(ag, &t);\n\tif (err)\n\t\treturn err;\n\n\tag71xx_wr(ag, AG71XX_REG_MII_CFG, t | MII_CFG_RESET);\n\tusleep_range(100, 200);\n\n\tag71xx_wr(ag, AG71XX_REG_MII_CFG, t);\n\tusleep_range(100, 200);\n\n\treturn 0;\n}\n\nstatic int ag71xx_mdio_probe(struct ag71xx *ag)\n{\n\tstruct device *dev = &ag->pdev->dev;\n\tstruct net_device *ndev = ag->ndev;\n\tstatic struct mii_bus *mii_bus;\n\tstruct device_node *np, *mnp;\n\tint err;\n\n\tnp = dev->of_node;\n\tag->mii_bus = NULL;\n\n\tag->clk_mdio = devm_clk_get(dev, \"mdio\");\n\tif (IS_ERR(ag->clk_mdio)) {\n\t\tnetif_err(ag, probe, ndev, \"Failed to get mdio clk.\\n\");\n\t\treturn PTR_ERR(ag->clk_mdio);\n\t}\n\n\terr = clk_prepare_enable(ag->clk_mdio);\n\tif (err) {\n\t\tnetif_err(ag, probe, ndev, \"Failed to enable mdio clk.\\n\");\n\t\treturn err;\n\t}\n\n\tmii_bus = devm_mdiobus_alloc(dev);\n\tif (!mii_bus) {\n\t\terr = -ENOMEM;\n\t\tgoto mdio_err_put_clk;\n\t}\n\n\tag->mdio_reset = of_reset_control_get_exclusive(np, \"mdio\");\n\tif (IS_ERR(ag->mdio_reset)) {\n\t\tnetif_err(ag, probe, ndev, \"Failed to get reset mdio.\\n\");\n\t\terr = PTR_ERR(ag->mdio_reset);\n\t\tgoto mdio_err_put_clk;\n\t}\n\n\tmii_bus->name = \"ag71xx_mdio\";\n\tmii_bus->read = ag71xx_mdio_mii_read;\n\tmii_bus->write = ag71xx_mdio_mii_write;\n\tmii_bus->reset = ag71xx_mdio_reset;\n\tmii_bus->priv = ag;\n\tmii_bus->parent = dev;\n\tsnprintf(mii_bus->id, MII_BUS_ID_SIZE, \"%s.%d\", np->name, ag->mac_idx);\n\n\tif (!IS_ERR(ag->mdio_reset)) {\n\t\treset_control_assert(ag->mdio_reset);\n\t\tmsleep(100);\n\t\treset_control_deassert(ag->mdio_reset);\n\t\tmsleep(200);\n\t}\n\n\tmnp = of_get_child_by_name(np, \"mdio\");\n\terr = of_mdiobus_register(mii_bus, mnp);\n\tof_node_put(mnp);\n\tif (err)\n\t\tgoto mdio_err_put_clk;\n\n\tag->mii_bus = mii_bus;\n\n\treturn 0;\n\nmdio_err_put_clk:\n\tclk_disable_unprepare(ag->clk_mdio);\n\treturn err;\n}\n\nstatic void ag71xx_mdio_remove(struct ag71xx *ag)\n{\n\tif (ag->mii_bus)\n\t\tmdiobus_unregister(ag->mii_bus);\n\tclk_disable_unprepare(ag->clk_mdio);\n}\n\nstatic void ag71xx_hw_stop(struct ag71xx *ag)\n{\n\t \n\tag71xx_wr(ag, AG71XX_REG_INT_ENABLE, 0);\n\tag71xx_wr(ag, AG71XX_REG_RX_CTRL, 0);\n\tag71xx_wr(ag, AG71XX_REG_TX_CTRL, 0);\n}\n\nstatic bool ag71xx_check_dma_stuck(struct ag71xx *ag)\n{\n\tunsigned long timestamp;\n\tu32 rx_sm, tx_sm, rx_fd;\n\n\ttimestamp = READ_ONCE(netdev_get_tx_queue(ag->ndev, 0)->trans_start);\n\tif (likely(time_before(jiffies, timestamp + HZ / 10)))\n\t\treturn false;\n\n\tif (!netif_carrier_ok(ag->ndev))\n\t\treturn false;\n\n\trx_sm = ag71xx_rr(ag, AG71XX_REG_RX_SM);\n\tif ((rx_sm & 0x7) == 0x3 && ((rx_sm >> 4) & 0x7) == 0x6)\n\t\treturn true;\n\n\ttx_sm = ag71xx_rr(ag, AG71XX_REG_TX_SM);\n\trx_fd = ag71xx_rr(ag, AG71XX_REG_FIFO_DEPTH);\n\tif (((tx_sm >> 4) & 0x7) == 0 && ((rx_sm & 0x7) == 0) &&\n\t    ((rx_sm >> 4) & 0x7) == 0 && rx_fd == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int ag71xx_tx_packets(struct ag71xx *ag, bool flush, int budget)\n{\n\tstruct ag71xx_ring *ring = &ag->tx_ring;\n\tint sent = 0, bytes_compl = 0, n = 0;\n\tstruct net_device *ndev = ag->ndev;\n\tint ring_mask, ring_size;\n\tbool dma_stuck = false;\n\n\tring_mask = BIT(ring->order) - 1;\n\tring_size = BIT(ring->order);\n\n\tnetif_dbg(ag, tx_queued, ndev, \"processing TX ring\\n\");\n\n\twhile (ring->dirty + n != ring->curr) {\n\t\tstruct ag71xx_desc *desc;\n\t\tstruct sk_buff *skb;\n\t\tunsigned int i;\n\n\t\ti = (ring->dirty + n) & ring_mask;\n\t\tdesc = ag71xx_ring_desc(ring, i);\n\t\tskb = ring->buf[i].tx.skb;\n\n\t\tif (!flush && !ag71xx_desc_empty(desc)) {\n\t\t\tif (ag->dcfg->tx_hang_workaround &&\n\t\t\t    ag71xx_check_dma_stuck(ag)) {\n\t\t\t\tschedule_delayed_work(&ag->restart_work,\n\t\t\t\t\t\t      HZ / 2);\n\t\t\t\tdma_stuck = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (flush)\n\t\t\tdesc->ctrl |= DESC_EMPTY;\n\n\t\tn++;\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tnapi_consume_skb(skb, budget);\n\t\tring->buf[i].tx.skb = NULL;\n\n\t\tbytes_compl += ring->buf[i].tx.len;\n\n\t\tsent++;\n\t\tring->dirty += n;\n\n\t\twhile (n > 0) {\n\t\t\tag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_PS);\n\t\t\tn--;\n\t\t}\n\t}\n\n\tnetif_dbg(ag, tx_done, ndev, \"%d packets sent out\\n\", sent);\n\n\tif (!sent)\n\t\treturn 0;\n\n\tag->ndev->stats.tx_bytes += bytes_compl;\n\tag->ndev->stats.tx_packets += sent;\n\n\tnetdev_completed_queue(ag->ndev, sent, bytes_compl);\n\tif ((ring->curr - ring->dirty) < (ring_size * 3) / 4)\n\t\tnetif_wake_queue(ag->ndev);\n\n\tif (!dma_stuck)\n\t\tcancel_delayed_work(&ag->restart_work);\n\n\treturn sent;\n}\n\nstatic void ag71xx_dma_wait_stop(struct ag71xx *ag)\n{\n\tstruct net_device *ndev = ag->ndev;\n\tint i;\n\n\tfor (i = 0; i < AG71XX_DMA_RETRY; i++) {\n\t\tu32 rx, tx;\n\n\t\tmdelay(AG71XX_DMA_DELAY);\n\n\t\trx = ag71xx_rr(ag, AG71XX_REG_RX_CTRL) & RX_CTRL_RXE;\n\t\ttx = ag71xx_rr(ag, AG71XX_REG_TX_CTRL) & TX_CTRL_TXE;\n\t\tif (!rx && !tx)\n\t\t\treturn;\n\t}\n\n\tnetif_err(ag, hw, ndev, \"DMA stop operation timed out\\n\");\n}\n\nstatic void ag71xx_dma_reset(struct ag71xx *ag)\n{\n\tstruct net_device *ndev = ag->ndev;\n\tu32 val;\n\tint i;\n\n\t \n\tag71xx_wr(ag, AG71XX_REG_RX_CTRL, 0);\n\tag71xx_wr(ag, AG71XX_REG_TX_CTRL, 0);\n\n\t \n\tag71xx_dma_wait_stop(ag);\n\n\t \n\tag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->stop_desc_dma);\n\tag71xx_wr(ag, AG71XX_REG_RX_DESC, ag->stop_desc_dma);\n\n\t \n\tfor (i = 0; i < 256; i++) {\n\t\tag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_PR);\n\t\tag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_PS);\n\t}\n\n\t \n\tag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_BE | RX_STATUS_OF);\n\tag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_BE | TX_STATUS_UR);\n\n\tval = ag71xx_rr(ag, AG71XX_REG_RX_STATUS);\n\tif (val)\n\t\tnetif_err(ag, hw, ndev, \"unable to clear DMA Rx status: %08x\\n\",\n\t\t\t  val);\n\n\tval = ag71xx_rr(ag, AG71XX_REG_TX_STATUS);\n\n\t \n\tval &= ~0xff000000;\n\n\tif (val)\n\t\tnetif_err(ag, hw, ndev, \"unable to clear DMA Tx status: %08x\\n\",\n\t\t\t  val);\n}\n\nstatic void ag71xx_hw_setup(struct ag71xx *ag)\n{\n\tu32 init = MAC_CFG1_INIT;\n\n\t \n\tag71xx_wr(ag, AG71XX_REG_MAC_CFG1, init);\n\n\tag71xx_sb(ag, AG71XX_REG_MAC_CFG2,\n\t\t  MAC_CFG2_PAD_CRC_EN | MAC_CFG2_LEN_CHECK);\n\n\t \n\tag71xx_wr(ag, AG71XX_REG_MAC_MFL, 0);\n\n\t \n\tag71xx_wr(ag, AG71XX_REG_FIFO_CFG0, FIFO_CFG0_INIT);\n\tag71xx_wr(ag, AG71XX_REG_FIFO_CFG1, ag->fifodata[0]);\n\tag71xx_wr(ag, AG71XX_REG_FIFO_CFG2, ag->fifodata[1]);\n\tag71xx_wr(ag, AG71XX_REG_FIFO_CFG4, FIFO_CFG4_INIT);\n\tag71xx_wr(ag, AG71XX_REG_FIFO_CFG5, FIFO_CFG5_INIT);\n}\n\nstatic unsigned int ag71xx_max_frame_len(unsigned int mtu)\n{\n\treturn ETH_HLEN + VLAN_HLEN + mtu + ETH_FCS_LEN;\n}\n\nstatic void ag71xx_hw_set_macaddr(struct ag71xx *ag, const unsigned char *mac)\n{\n\tu32 t;\n\n\tt = (((u32)mac[5]) << 24) | (((u32)mac[4]) << 16)\n\t  | (((u32)mac[3]) << 8) | ((u32)mac[2]);\n\n\tag71xx_wr(ag, AG71XX_REG_MAC_ADDR1, t);\n\n\tt = (((u32)mac[1]) << 24) | (((u32)mac[0]) << 16);\n\tag71xx_wr(ag, AG71XX_REG_MAC_ADDR2, t);\n}\n\nstatic void ag71xx_fast_reset(struct ag71xx *ag)\n{\n\tstruct net_device *dev = ag->ndev;\n\tu32 rx_ds;\n\tu32 mii_reg;\n\n\tag71xx_hw_stop(ag);\n\n\tmii_reg = ag71xx_rr(ag, AG71XX_REG_MII_CFG);\n\trx_ds = ag71xx_rr(ag, AG71XX_REG_RX_DESC);\n\n\tag71xx_tx_packets(ag, true, 0);\n\n\treset_control_assert(ag->mac_reset);\n\tusleep_range(10, 20);\n\treset_control_deassert(ag->mac_reset);\n\tusleep_range(10, 20);\n\n\tag71xx_dma_reset(ag);\n\tag71xx_hw_setup(ag);\n\tag->tx_ring.curr = 0;\n\tag->tx_ring.dirty = 0;\n\tnetdev_reset_queue(ag->ndev);\n\n\t \n\tag71xx_wr(ag, AG71XX_REG_MAC_MFL,\n\t\t  ag71xx_max_frame_len(ag->ndev->mtu));\n\n\tag71xx_wr(ag, AG71XX_REG_RX_DESC, rx_ds);\n\tag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->tx_ring.descs_dma);\n\tag71xx_wr(ag, AG71XX_REG_MII_CFG, mii_reg);\n\n\tag71xx_hw_set_macaddr(ag, dev->dev_addr);\n}\n\nstatic void ag71xx_hw_start(struct ag71xx *ag)\n{\n\t \n\tag71xx_wr(ag, AG71XX_REG_RX_CTRL, RX_CTRL_RXE);\n\n\t \n\tag71xx_wr(ag, AG71XX_REG_INT_ENABLE, AG71XX_INT_INIT);\n\n\tnetif_wake_queue(ag->ndev);\n}\n\nstatic void ag71xx_mac_config(struct phylink_config *config, unsigned int mode,\n\t\t\t      const struct phylink_link_state *state)\n{\n\tstruct ag71xx *ag = netdev_priv(to_net_dev(config->dev));\n\n\tif (phylink_autoneg_inband(mode))\n\t\treturn;\n\n\tif (!ag71xx_is(ag, AR7100) && !ag71xx_is(ag, AR9130))\n\t\tag71xx_fast_reset(ag);\n\n\tif (ag->tx_ring.desc_split) {\n\t\tag->fifodata[2] &= 0xffff;\n\t\tag->fifodata[2] |= ((2048 - ag->tx_ring.desc_split) / 4) << 16;\n\t}\n\n\tag71xx_wr(ag, AG71XX_REG_FIFO_CFG3, ag->fifodata[2]);\n}\n\nstatic void ag71xx_mac_link_down(struct phylink_config *config,\n\t\t\t\t unsigned int mode, phy_interface_t interface)\n{\n\tstruct ag71xx *ag = netdev_priv(to_net_dev(config->dev));\n\n\tag71xx_hw_stop(ag);\n}\n\nstatic void ag71xx_mac_link_up(struct phylink_config *config,\n\t\t\t       struct phy_device *phy,\n\t\t\t       unsigned int mode, phy_interface_t interface,\n\t\t\t       int speed, int duplex,\n\t\t\t       bool tx_pause, bool rx_pause)\n{\n\tstruct ag71xx *ag = netdev_priv(to_net_dev(config->dev));\n\tu32 cfg1, cfg2;\n\tu32 ifctl;\n\tu32 fifo5;\n\n\tcfg2 = ag71xx_rr(ag, AG71XX_REG_MAC_CFG2);\n\tcfg2 &= ~(MAC_CFG2_IF_1000 | MAC_CFG2_IF_10_100 | MAC_CFG2_FDX);\n\tcfg2 |= duplex ? MAC_CFG2_FDX : 0;\n\n\tifctl = ag71xx_rr(ag, AG71XX_REG_MAC_IFCTL);\n\tifctl &= ~(MAC_IFCTL_SPEED);\n\n\tfifo5 = ag71xx_rr(ag, AG71XX_REG_FIFO_CFG5);\n\tfifo5 &= ~FIFO_CFG5_BM;\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\tcfg2 |= MAC_CFG2_IF_1000;\n\t\tfifo5 |= FIFO_CFG5_BM;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tcfg2 |= MAC_CFG2_IF_10_100;\n\t\tifctl |= MAC_IFCTL_SPEED;\n\t\tbreak;\n\tcase SPEED_10:\n\t\tcfg2 |= MAC_CFG2_IF_10_100;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tag71xx_wr(ag, AG71XX_REG_MAC_CFG2, cfg2);\n\tag71xx_wr(ag, AG71XX_REG_FIFO_CFG5, fifo5);\n\tag71xx_wr(ag, AG71XX_REG_MAC_IFCTL, ifctl);\n\n\tcfg1 = ag71xx_rr(ag, AG71XX_REG_MAC_CFG1);\n\tcfg1 &= ~(MAC_CFG1_TFC | MAC_CFG1_RFC);\n\tif (tx_pause)\n\t\tcfg1 |= MAC_CFG1_TFC;\n\n\tif (rx_pause)\n\t\tcfg1 |= MAC_CFG1_RFC;\n\tag71xx_wr(ag, AG71XX_REG_MAC_CFG1, cfg1);\n\n\tag71xx_hw_start(ag);\n}\n\nstatic const struct phylink_mac_ops ag71xx_phylink_mac_ops = {\n\t.mac_config = ag71xx_mac_config,\n\t.mac_link_down = ag71xx_mac_link_down,\n\t.mac_link_up = ag71xx_mac_link_up,\n};\n\nstatic int ag71xx_phylink_setup(struct ag71xx *ag)\n{\n\tstruct phylink *phylink;\n\n\tag->phylink_config.dev = &ag->ndev->dev;\n\tag->phylink_config.type = PHYLINK_NETDEV;\n\tag->phylink_config.mac_capabilities = MAC_SYM_PAUSE | MAC_ASYM_PAUSE |\n\t\tMAC_10 | MAC_100 | MAC_1000FD;\n\n\tif ((ag71xx_is(ag, AR9330) && ag->mac_idx == 0) ||\n\t    ag71xx_is(ag, AR9340) ||\n\t    ag71xx_is(ag, QCA9530) ||\n\t    (ag71xx_is(ag, QCA9550) && ag->mac_idx == 1))\n\t\t__set_bit(PHY_INTERFACE_MODE_MII,\n\t\t\t  ag->phylink_config.supported_interfaces);\n\n\tif ((ag71xx_is(ag, AR9330) && ag->mac_idx == 1) ||\n\t    (ag71xx_is(ag, AR9340) && ag->mac_idx == 1) ||\n\t    (ag71xx_is(ag, QCA9530) && ag->mac_idx == 1))\n\t\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t\t  ag->phylink_config.supported_interfaces);\n\n\tif (ag71xx_is(ag, QCA9550) && ag->mac_idx == 0)\n\t\t__set_bit(PHY_INTERFACE_MODE_SGMII,\n\t\t\t  ag->phylink_config.supported_interfaces);\n\n\tif (ag71xx_is(ag, AR9340) && ag->mac_idx == 0)\n\t\t__set_bit(PHY_INTERFACE_MODE_RMII,\n\t\t\t  ag->phylink_config.supported_interfaces);\n\n\tif ((ag71xx_is(ag, AR9340) && ag->mac_idx == 0) ||\n\t    (ag71xx_is(ag, QCA9550) && ag->mac_idx == 1))\n\t\t__set_bit(PHY_INTERFACE_MODE_RGMII,\n\t\t\t  ag->phylink_config.supported_interfaces);\n\n\tphylink = phylink_create(&ag->phylink_config, ag->pdev->dev.fwnode,\n\t\t\t\t ag->phy_if_mode, &ag71xx_phylink_mac_ops);\n\tif (IS_ERR(phylink))\n\t\treturn PTR_ERR(phylink);\n\n\tag->phylink = phylink;\n\treturn 0;\n}\n\nstatic void ag71xx_ring_tx_clean(struct ag71xx *ag)\n{\n\tstruct ag71xx_ring *ring = &ag->tx_ring;\n\tint ring_mask = BIT(ring->order) - 1;\n\tu32 bytes_compl = 0, pkts_compl = 0;\n\tstruct net_device *ndev = ag->ndev;\n\n\twhile (ring->curr != ring->dirty) {\n\t\tstruct ag71xx_desc *desc;\n\t\tu32 i = ring->dirty & ring_mask;\n\n\t\tdesc = ag71xx_ring_desc(ring, i);\n\t\tif (!ag71xx_desc_empty(desc)) {\n\t\t\tdesc->ctrl = 0;\n\t\t\tndev->stats.tx_errors++;\n\t\t}\n\n\t\tif (ring->buf[i].tx.skb) {\n\t\t\tbytes_compl += ring->buf[i].tx.len;\n\t\t\tpkts_compl++;\n\t\t\tdev_kfree_skb_any(ring->buf[i].tx.skb);\n\t\t}\n\t\tring->buf[i].tx.skb = NULL;\n\t\tring->dirty++;\n\t}\n\n\t \n\twmb();\n\n\tnetdev_completed_queue(ndev, pkts_compl, bytes_compl);\n}\n\nstatic void ag71xx_ring_tx_init(struct ag71xx *ag)\n{\n\tstruct ag71xx_ring *ring = &ag->tx_ring;\n\tint ring_size = BIT(ring->order);\n\tint ring_mask = ring_size - 1;\n\tint i;\n\n\tfor (i = 0; i < ring_size; i++) {\n\t\tstruct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);\n\n\t\tdesc->next = (u32)(ring->descs_dma +\n\t\t\tAG71XX_DESC_SIZE * ((i + 1) & ring_mask));\n\n\t\tdesc->ctrl = DESC_EMPTY;\n\t\tring->buf[i].tx.skb = NULL;\n\t}\n\n\t \n\twmb();\n\n\tring->curr = 0;\n\tring->dirty = 0;\n\tnetdev_reset_queue(ag->ndev);\n}\n\nstatic void ag71xx_ring_rx_clean(struct ag71xx *ag)\n{\n\tstruct ag71xx_ring *ring = &ag->rx_ring;\n\tint ring_size = BIT(ring->order);\n\tint i;\n\n\tif (!ring->buf)\n\t\treturn;\n\n\tfor (i = 0; i < ring_size; i++)\n\t\tif (ring->buf[i].rx.rx_buf) {\n\t\t\tdma_unmap_single(&ag->pdev->dev,\n\t\t\t\t\t ring->buf[i].rx.dma_addr,\n\t\t\t\t\t ag->rx_buf_size, DMA_FROM_DEVICE);\n\t\t\tskb_free_frag(ring->buf[i].rx.rx_buf);\n\t\t}\n}\n\nstatic int ag71xx_buffer_size(struct ag71xx *ag)\n{\n\treturn ag->rx_buf_size +\n\t       SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n}\n\nstatic bool ag71xx_fill_rx_buf(struct ag71xx *ag, struct ag71xx_buf *buf,\n\t\t\t       int offset,\n\t\t\t       void *(*alloc)(unsigned int size))\n{\n\tstruct ag71xx_ring *ring = &ag->rx_ring;\n\tstruct ag71xx_desc *desc;\n\tvoid *data;\n\n\tdesc = ag71xx_ring_desc(ring, buf - &ring->buf[0]);\n\n\tdata = alloc(ag71xx_buffer_size(ag));\n\tif (!data)\n\t\treturn false;\n\n\tbuf->rx.rx_buf = data;\n\tbuf->rx.dma_addr = dma_map_single(&ag->pdev->dev, data, ag->rx_buf_size,\n\t\t\t\t\t  DMA_FROM_DEVICE);\n\tdesc->data = (u32)buf->rx.dma_addr + offset;\n\treturn true;\n}\n\nstatic int ag71xx_ring_rx_init(struct ag71xx *ag)\n{\n\tstruct ag71xx_ring *ring = &ag->rx_ring;\n\tstruct net_device *ndev = ag->ndev;\n\tint ring_mask = BIT(ring->order) - 1;\n\tint ring_size = BIT(ring->order);\n\tunsigned int i;\n\tint ret;\n\n\tret = 0;\n\tfor (i = 0; i < ring_size; i++) {\n\t\tstruct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);\n\n\t\tdesc->next = (u32)(ring->descs_dma +\n\t\t\tAG71XX_DESC_SIZE * ((i + 1) & ring_mask));\n\n\t\tnetif_dbg(ag, rx_status, ndev, \"RX desc at %p, next is %08x\\n\",\n\t\t\t  desc, desc->next);\n\t}\n\n\tfor (i = 0; i < ring_size; i++) {\n\t\tstruct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);\n\n\t\tif (!ag71xx_fill_rx_buf(ag, &ring->buf[i], ag->rx_buf_offset,\n\t\t\t\t\tnetdev_alloc_frag)) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tdesc->ctrl = DESC_EMPTY;\n\t}\n\n\t \n\twmb();\n\n\tring->curr = 0;\n\tring->dirty = 0;\n\n\treturn ret;\n}\n\nstatic int ag71xx_ring_rx_refill(struct ag71xx *ag)\n{\n\tstruct ag71xx_ring *ring = &ag->rx_ring;\n\tint ring_mask = BIT(ring->order) - 1;\n\tint offset = ag->rx_buf_offset;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor (; ring->curr - ring->dirty > 0; ring->dirty++) {\n\t\tstruct ag71xx_desc *desc;\n\t\tunsigned int i;\n\n\t\ti = ring->dirty & ring_mask;\n\t\tdesc = ag71xx_ring_desc(ring, i);\n\n\t\tif (!ring->buf[i].rx.rx_buf &&\n\t\t    !ag71xx_fill_rx_buf(ag, &ring->buf[i], offset,\n\t\t\t\t\tnapi_alloc_frag))\n\t\t\tbreak;\n\n\t\tdesc->ctrl = DESC_EMPTY;\n\t\tcount++;\n\t}\n\n\t \n\twmb();\n\n\tnetif_dbg(ag, rx_status, ag->ndev, \"%u rx descriptors refilled\\n\",\n\t\t  count);\n\n\treturn count;\n}\n\nstatic int ag71xx_rings_init(struct ag71xx *ag)\n{\n\tstruct ag71xx_ring *tx = &ag->tx_ring;\n\tstruct ag71xx_ring *rx = &ag->rx_ring;\n\tint ring_size, tx_size;\n\n\tring_size = BIT(tx->order) + BIT(rx->order);\n\ttx_size = BIT(tx->order);\n\n\ttx->buf = kcalloc(ring_size, sizeof(*tx->buf), GFP_KERNEL);\n\tif (!tx->buf)\n\t\treturn -ENOMEM;\n\n\ttx->descs_cpu = dma_alloc_coherent(&ag->pdev->dev,\n\t\t\t\t\t   ring_size * AG71XX_DESC_SIZE,\n\t\t\t\t\t   &tx->descs_dma, GFP_KERNEL);\n\tif (!tx->descs_cpu) {\n\t\tkfree(tx->buf);\n\t\ttx->buf = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\trx->buf = &tx->buf[tx_size];\n\trx->descs_cpu = ((void *)tx->descs_cpu) + tx_size * AG71XX_DESC_SIZE;\n\trx->descs_dma = tx->descs_dma + tx_size * AG71XX_DESC_SIZE;\n\n\tag71xx_ring_tx_init(ag);\n\treturn ag71xx_ring_rx_init(ag);\n}\n\nstatic void ag71xx_rings_free(struct ag71xx *ag)\n{\n\tstruct ag71xx_ring *tx = &ag->tx_ring;\n\tstruct ag71xx_ring *rx = &ag->rx_ring;\n\tint ring_size;\n\n\tring_size = BIT(tx->order) + BIT(rx->order);\n\n\tif (tx->descs_cpu)\n\t\tdma_free_coherent(&ag->pdev->dev, ring_size * AG71XX_DESC_SIZE,\n\t\t\t\t  tx->descs_cpu, tx->descs_dma);\n\n\tkfree(tx->buf);\n\n\ttx->descs_cpu = NULL;\n\trx->descs_cpu = NULL;\n\ttx->buf = NULL;\n\trx->buf = NULL;\n}\n\nstatic void ag71xx_rings_cleanup(struct ag71xx *ag)\n{\n\tag71xx_ring_rx_clean(ag);\n\tag71xx_ring_tx_clean(ag);\n\tag71xx_rings_free(ag);\n\n\tnetdev_reset_queue(ag->ndev);\n}\n\nstatic void ag71xx_hw_init(struct ag71xx *ag)\n{\n\tag71xx_hw_stop(ag);\n\n\tag71xx_sb(ag, AG71XX_REG_MAC_CFG1, MAC_CFG1_SR);\n\tusleep_range(20, 30);\n\n\treset_control_assert(ag->mac_reset);\n\tmsleep(100);\n\treset_control_deassert(ag->mac_reset);\n\tmsleep(200);\n\n\tag71xx_hw_setup(ag);\n\n\tag71xx_dma_reset(ag);\n}\n\nstatic int ag71xx_hw_enable(struct ag71xx *ag)\n{\n\tint ret;\n\n\tret = ag71xx_rings_init(ag);\n\tif (ret)\n\t\treturn ret;\n\n\tnapi_enable(&ag->napi);\n\tag71xx_wr(ag, AG71XX_REG_TX_DESC, ag->tx_ring.descs_dma);\n\tag71xx_wr(ag, AG71XX_REG_RX_DESC, ag->rx_ring.descs_dma);\n\tnetif_start_queue(ag->ndev);\n\n\treturn 0;\n}\n\nstatic void ag71xx_hw_disable(struct ag71xx *ag)\n{\n\tnetif_stop_queue(ag->ndev);\n\n\tag71xx_hw_stop(ag);\n\tag71xx_dma_reset(ag);\n\n\tnapi_disable(&ag->napi);\n\tdel_timer_sync(&ag->oom_timer);\n\n\tag71xx_rings_cleanup(ag);\n}\n\nstatic int ag71xx_open(struct net_device *ndev)\n{\n\tstruct ag71xx *ag = netdev_priv(ndev);\n\tunsigned int max_frame_len;\n\tint ret;\n\n\tret = phylink_of_phy_connect(ag->phylink, ag->pdev->dev.of_node, 0);\n\tif (ret) {\n\t\tnetif_err(ag, link, ndev, \"phylink_of_phy_connect filed with err: %i\\n\",\n\t\t\t  ret);\n\t\treturn ret;\n\t}\n\n\tmax_frame_len = ag71xx_max_frame_len(ndev->mtu);\n\tag->rx_buf_size =\n\t\tSKB_DATA_ALIGN(max_frame_len + NET_SKB_PAD + NET_IP_ALIGN);\n\n\t \n\tag71xx_wr(ag, AG71XX_REG_MAC_MFL, max_frame_len);\n\tag71xx_hw_set_macaddr(ag, ndev->dev_addr);\n\n\tret = ag71xx_hw_enable(ag);\n\tif (ret)\n\t\tgoto err;\n\n\tphylink_start(ag->phylink);\n\n\treturn 0;\n\nerr:\n\tag71xx_rings_cleanup(ag);\n\tphylink_disconnect_phy(ag->phylink);\n\treturn ret;\n}\n\nstatic int ag71xx_stop(struct net_device *ndev)\n{\n\tstruct ag71xx *ag = netdev_priv(ndev);\n\n\tphylink_stop(ag->phylink);\n\tphylink_disconnect_phy(ag->phylink);\n\tag71xx_hw_disable(ag);\n\n\treturn 0;\n}\n\nstatic int ag71xx_fill_dma_desc(struct ag71xx_ring *ring, u32 addr, int len)\n{\n\tint i, ring_mask, ndesc, split;\n\tstruct ag71xx_desc *desc;\n\n\tring_mask = BIT(ring->order) - 1;\n\tndesc = 0;\n\tsplit = ring->desc_split;\n\n\tif (!split)\n\t\tsplit = len;\n\n\twhile (len > 0) {\n\t\tunsigned int cur_len = len;\n\n\t\ti = (ring->curr + ndesc) & ring_mask;\n\t\tdesc = ag71xx_ring_desc(ring, i);\n\n\t\tif (!ag71xx_desc_empty(desc))\n\t\t\treturn -1;\n\n\t\tif (cur_len > split) {\n\t\t\tcur_len = split;\n\n\t\t\t \n\t\t\tif (len <= split + 4)\n\t\t\t\tcur_len -= 4;\n\t\t}\n\n\t\tdesc->data = addr;\n\t\taddr += cur_len;\n\t\tlen -= cur_len;\n\n\t\tif (len > 0)\n\t\t\tcur_len |= DESC_MORE;\n\n\t\t \n\t\tif (!ndesc)\n\t\t\tcur_len |= DESC_EMPTY;\n\n\t\tdesc->ctrl = cur_len;\n\t\tndesc++;\n\t}\n\n\treturn ndesc;\n}\n\nstatic netdev_tx_t ag71xx_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *ndev)\n{\n\tint i, n, ring_min, ring_mask, ring_size;\n\tstruct ag71xx *ag = netdev_priv(ndev);\n\tstruct ag71xx_ring *ring;\n\tstruct ag71xx_desc *desc;\n\tdma_addr_t dma_addr;\n\n\tring = &ag->tx_ring;\n\tring_mask = BIT(ring->order) - 1;\n\tring_size = BIT(ring->order);\n\n\tif (skb->len <= 4) {\n\t\tnetif_dbg(ag, tx_err, ndev, \"packet len is too small\\n\");\n\t\tgoto err_drop;\n\t}\n\n\tdma_addr = dma_map_single(&ag->pdev->dev, skb->data, skb->len,\n\t\t\t\t  DMA_TO_DEVICE);\n\n\ti = ring->curr & ring_mask;\n\tdesc = ag71xx_ring_desc(ring, i);\n\n\t \n\tn = ag71xx_fill_dma_desc(ring, (u32)dma_addr,\n\t\t\t\t skb->len & ag->dcfg->desc_pktlen_mask);\n\tif (n < 0)\n\t\tgoto err_drop_unmap;\n\n\ti = (ring->curr + n - 1) & ring_mask;\n\tring->buf[i].tx.len = skb->len;\n\tring->buf[i].tx.skb = skb;\n\n\tnetdev_sent_queue(ndev, skb->len);\n\n\tskb_tx_timestamp(skb);\n\n\tdesc->ctrl &= ~DESC_EMPTY;\n\tring->curr += n;\n\n\t \n\twmb();\n\n\tring_min = 2;\n\tif (ring->desc_split)\n\t\tring_min *= AG71XX_TX_RING_DS_PER_PKT;\n\n\tif (ring->curr - ring->dirty >= ring_size - ring_min) {\n\t\tnetif_dbg(ag, tx_err, ndev, \"tx queue full\\n\");\n\t\tnetif_stop_queue(ndev);\n\t}\n\n\tnetif_dbg(ag, tx_queued, ndev, \"packet injected into TX queue\\n\");\n\n\t \n\tag71xx_wr(ag, AG71XX_REG_TX_CTRL, TX_CTRL_TXE);\n\n\treturn NETDEV_TX_OK;\n\nerr_drop_unmap:\n\tdma_unmap_single(&ag->pdev->dev, dma_addr, skb->len, DMA_TO_DEVICE);\n\nerr_drop:\n\tndev->stats.tx_dropped++;\n\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ag71xx_oom_timer_handler(struct timer_list *t)\n{\n\tstruct ag71xx *ag = from_timer(ag, t, oom_timer);\n\n\tnapi_schedule(&ag->napi);\n}\n\nstatic void ag71xx_tx_timeout(struct net_device *ndev, unsigned int txqueue)\n{\n\tstruct ag71xx *ag = netdev_priv(ndev);\n\n\tnetif_err(ag, tx_err, ndev, \"tx timeout\\n\");\n\n\tschedule_delayed_work(&ag->restart_work, 1);\n}\n\nstatic void ag71xx_restart_work_func(struct work_struct *work)\n{\n\tstruct ag71xx *ag = container_of(work, struct ag71xx,\n\t\t\t\t\t restart_work.work);\n\n\trtnl_lock();\n\tag71xx_hw_disable(ag);\n\tag71xx_hw_enable(ag);\n\n\tphylink_stop(ag->phylink);\n\tphylink_start(ag->phylink);\n\n\trtnl_unlock();\n}\n\nstatic int ag71xx_rx_packets(struct ag71xx *ag, int limit)\n{\n\tstruct net_device *ndev = ag->ndev;\n\tint ring_mask, ring_size, done = 0;\n\tunsigned int pktlen_mask, offset;\n\tstruct ag71xx_ring *ring;\n\tstruct list_head rx_list;\n\tstruct sk_buff *skb;\n\n\tring = &ag->rx_ring;\n\tpktlen_mask = ag->dcfg->desc_pktlen_mask;\n\toffset = ag->rx_buf_offset;\n\tring_mask = BIT(ring->order) - 1;\n\tring_size = BIT(ring->order);\n\n\tnetif_dbg(ag, rx_status, ndev, \"rx packets, limit=%d, curr=%u, dirty=%u\\n\",\n\t\t  limit, ring->curr, ring->dirty);\n\n\tINIT_LIST_HEAD(&rx_list);\n\n\twhile (done < limit) {\n\t\tunsigned int i = ring->curr & ring_mask;\n\t\tstruct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);\n\t\tint pktlen;\n\t\tint err = 0;\n\n\t\tif (ag71xx_desc_empty(desc))\n\t\t\tbreak;\n\n\t\tif ((ring->dirty + ring_size) == ring->curr) {\n\t\t\tWARN_ONCE(1, \"RX out of ring\");\n\t\t\tbreak;\n\t\t}\n\n\t\tag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_PR);\n\n\t\tpktlen = desc->ctrl & pktlen_mask;\n\t\tpktlen -= ETH_FCS_LEN;\n\n\t\tdma_unmap_single(&ag->pdev->dev, ring->buf[i].rx.dma_addr,\n\t\t\t\t ag->rx_buf_size, DMA_FROM_DEVICE);\n\n\t\tndev->stats.rx_packets++;\n\t\tndev->stats.rx_bytes += pktlen;\n\n\t\tskb = napi_build_skb(ring->buf[i].rx.rx_buf, ag71xx_buffer_size(ag));\n\t\tif (!skb) {\n\t\t\tskb_free_frag(ring->buf[i].rx.rx_buf);\n\t\t\tgoto next;\n\t\t}\n\n\t\tskb_reserve(skb, offset);\n\t\tskb_put(skb, pktlen);\n\n\t\tif (err) {\n\t\t\tndev->stats.rx_dropped++;\n\t\t\tkfree_skb(skb);\n\t\t} else {\n\t\t\tskb->dev = ndev;\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tlist_add_tail(&skb->list, &rx_list);\n\t\t}\n\nnext:\n\t\tring->buf[i].rx.rx_buf = NULL;\n\t\tdone++;\n\n\t\tring->curr++;\n\t}\n\n\tag71xx_ring_rx_refill(ag);\n\n\tlist_for_each_entry(skb, &rx_list, list)\n\t\tskb->protocol = eth_type_trans(skb, ndev);\n\tnetif_receive_skb_list(&rx_list);\n\n\tnetif_dbg(ag, rx_status, ndev, \"rx finish, curr=%u, dirty=%u, done=%d\\n\",\n\t\t  ring->curr, ring->dirty, done);\n\n\treturn done;\n}\n\nstatic int ag71xx_poll(struct napi_struct *napi, int limit)\n{\n\tstruct ag71xx *ag = container_of(napi, struct ag71xx, napi);\n\tstruct ag71xx_ring *rx_ring = &ag->rx_ring;\n\tint rx_ring_size = BIT(rx_ring->order);\n\tstruct net_device *ndev = ag->ndev;\n\tint tx_done, rx_done;\n\tu32 status;\n\n\ttx_done = ag71xx_tx_packets(ag, false, limit);\n\n\tnetif_dbg(ag, rx_status, ndev, \"processing RX ring\\n\");\n\trx_done = ag71xx_rx_packets(ag, limit);\n\n\tif (!rx_ring->buf[rx_ring->dirty % rx_ring_size].rx.rx_buf)\n\t\tgoto oom;\n\n\tstatus = ag71xx_rr(ag, AG71XX_REG_RX_STATUS);\n\tif (unlikely(status & RX_STATUS_OF)) {\n\t\tag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_OF);\n\t\tndev->stats.rx_fifo_errors++;\n\n\t\t \n\t\tag71xx_wr(ag, AG71XX_REG_RX_CTRL, RX_CTRL_RXE);\n\t}\n\n\tif (rx_done < limit) {\n\t\tif (status & RX_STATUS_PR)\n\t\t\tgoto more;\n\n\t\tstatus = ag71xx_rr(ag, AG71XX_REG_TX_STATUS);\n\t\tif (status & TX_STATUS_PS)\n\t\t\tgoto more;\n\n\t\tnetif_dbg(ag, rx_status, ndev, \"disable polling mode, rx=%d, tx=%d,limit=%d\\n\",\n\t\t\t  rx_done, tx_done, limit);\n\n\t\tnapi_complete(napi);\n\n\t\t \n\t\tag71xx_int_enable(ag, AG71XX_INT_POLL);\n\t\treturn rx_done;\n\t}\n\nmore:\n\tnetif_dbg(ag, rx_status, ndev, \"stay in polling mode, rx=%d, tx=%d, limit=%d\\n\",\n\t\t  rx_done, tx_done, limit);\n\treturn limit;\n\noom:\n\tnetif_err(ag, rx_err, ndev, \"out of memory\\n\");\n\n\tmod_timer(&ag->oom_timer, jiffies + AG71XX_OOM_REFILL);\n\tnapi_complete(napi);\n\treturn 0;\n}\n\nstatic irqreturn_t ag71xx_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *ndev = dev_id;\n\tstruct ag71xx *ag;\n\tu32 status;\n\n\tag = netdev_priv(ndev);\n\tstatus = ag71xx_rr(ag, AG71XX_REG_INT_STATUS);\n\n\tif (unlikely(!status))\n\t\treturn IRQ_NONE;\n\n\tif (unlikely(status & AG71XX_INT_ERR)) {\n\t\tif (status & AG71XX_INT_TX_BE) {\n\t\t\tag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_BE);\n\t\t\tnetif_err(ag, intr, ndev, \"TX BUS error\\n\");\n\t\t}\n\t\tif (status & AG71XX_INT_RX_BE) {\n\t\t\tag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_BE);\n\t\t\tnetif_err(ag, intr, ndev, \"RX BUS error\\n\");\n\t\t}\n\t}\n\n\tif (likely(status & AG71XX_INT_POLL)) {\n\t\tag71xx_int_disable(ag, AG71XX_INT_POLL);\n\t\tnetif_dbg(ag, intr, ndev, \"enable polling mode\\n\");\n\t\tnapi_schedule(&ag->napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ag71xx_change_mtu(struct net_device *ndev, int new_mtu)\n{\n\tstruct ag71xx *ag = netdev_priv(ndev);\n\n\tndev->mtu = new_mtu;\n\tag71xx_wr(ag, AG71XX_REG_MAC_MFL,\n\t\t  ag71xx_max_frame_len(ndev->mtu));\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ag71xx_netdev_ops = {\n\t.ndo_open\t\t= ag71xx_open,\n\t.ndo_stop\t\t= ag71xx_stop,\n\t.ndo_start_xmit\t\t= ag71xx_hard_start_xmit,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl,\n\t.ndo_tx_timeout\t\t= ag71xx_tx_timeout,\n\t.ndo_change_mtu\t\t= ag71xx_change_mtu,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic const u32 ar71xx_addr_ar7100[] = {\n\t0x19000000, 0x1a000000,\n};\n\nstatic int ag71xx_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct ag71xx_dcfg *dcfg;\n\tstruct net_device *ndev;\n\tstruct resource *res;\n\tint tx_size, err, i;\n\tstruct ag71xx *ag;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tndev = devm_alloc_etherdev(&pdev->dev, sizeof(*ag));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tdcfg = of_device_get_match_data(&pdev->dev);\n\tif (!dcfg)\n\t\treturn -EINVAL;\n\n\tag = netdev_priv(ndev);\n\tag->mac_idx = -1;\n\tfor (i = 0; i < ARRAY_SIZE(ar71xx_addr_ar7100); i++) {\n\t\tif (ar71xx_addr_ar7100[i] == res->start)\n\t\t\tag->mac_idx = i;\n\t}\n\n\tif (ag->mac_idx < 0) {\n\t\tnetif_err(ag, probe, ndev, \"unknown mac idx\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tag->clk_eth = devm_clk_get(&pdev->dev, \"eth\");\n\tif (IS_ERR(ag->clk_eth)) {\n\t\tnetif_err(ag, probe, ndev, \"Failed to get eth clk.\\n\");\n\t\treturn PTR_ERR(ag->clk_eth);\n\t}\n\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\n\tag->pdev = pdev;\n\tag->ndev = ndev;\n\tag->dcfg = dcfg;\n\tag->msg_enable = netif_msg_init(-1, AG71XX_DEFAULT_MSG_ENABLE);\n\tmemcpy(ag->fifodata, dcfg->fifodata, sizeof(ag->fifodata));\n\n\tag->mac_reset = devm_reset_control_get(&pdev->dev, \"mac\");\n\tif (IS_ERR(ag->mac_reset)) {\n\t\tnetif_err(ag, probe, ndev, \"missing mac reset\\n\");\n\t\treturn PTR_ERR(ag->mac_reset);\n\t}\n\n\tag->mac_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!ag->mac_base)\n\t\treturn -ENOMEM;\n\n\tndev->irq = platform_get_irq(pdev, 0);\n\terr = devm_request_irq(&pdev->dev, ndev->irq, ag71xx_interrupt,\n\t\t\t       0x0, dev_name(&pdev->dev), ndev);\n\tif (err) {\n\t\tnetif_err(ag, probe, ndev, \"unable to request IRQ %d\\n\",\n\t\t\t  ndev->irq);\n\t\treturn err;\n\t}\n\n\tndev->netdev_ops = &ag71xx_netdev_ops;\n\tndev->ethtool_ops = &ag71xx_ethtool_ops;\n\n\tINIT_DELAYED_WORK(&ag->restart_work, ag71xx_restart_work_func);\n\ttimer_setup(&ag->oom_timer, ag71xx_oom_timer_handler, 0);\n\n\ttx_size = AG71XX_TX_RING_SIZE_DEFAULT;\n\tag->rx_ring.order = ag71xx_ring_size_order(AG71XX_RX_RING_SIZE_DEFAULT);\n\n\tndev->min_mtu = 68;\n\tndev->max_mtu = dcfg->max_frame_len - ag71xx_max_frame_len(0);\n\n\tag->rx_buf_offset = NET_SKB_PAD;\n\tif (!ag71xx_is(ag, AR7100) && !ag71xx_is(ag, AR9130))\n\t\tag->rx_buf_offset += NET_IP_ALIGN;\n\n\tif (ag71xx_is(ag, AR7100)) {\n\t\tag->tx_ring.desc_split = AG71XX_TX_RING_SPLIT;\n\t\ttx_size *= AG71XX_TX_RING_DS_PER_PKT;\n\t}\n\tag->tx_ring.order = ag71xx_ring_size_order(tx_size);\n\n\tag->stop_desc = dmam_alloc_coherent(&pdev->dev,\n\t\t\t\t\t    sizeof(struct ag71xx_desc),\n\t\t\t\t\t    &ag->stop_desc_dma, GFP_KERNEL);\n\tif (!ag->stop_desc)\n\t\treturn -ENOMEM;\n\n\tag->stop_desc->data = 0;\n\tag->stop_desc->ctrl = 0;\n\tag->stop_desc->next = (u32)ag->stop_desc_dma;\n\n\terr = of_get_ethdev_address(np, ndev);\n\tif (err) {\n\t\tnetif_err(ag, probe, ndev, \"invalid MAC address, using random address\\n\");\n\t\teth_hw_addr_random(ndev);\n\t}\n\n\terr = of_get_phy_mode(np, &ag->phy_if_mode);\n\tif (err) {\n\t\tnetif_err(ag, probe, ndev, \"missing phy-mode property in DT\\n\");\n\t\treturn err;\n\t}\n\n\tnetif_napi_add_weight(ndev, &ag->napi, ag71xx_poll,\n\t\t\t      AG71XX_NAPI_WEIGHT);\n\n\terr = clk_prepare_enable(ag->clk_eth);\n\tif (err) {\n\t\tnetif_err(ag, probe, ndev, \"Failed to enable eth clk.\\n\");\n\t\treturn err;\n\t}\n\n\tag71xx_wr(ag, AG71XX_REG_MAC_CFG1, 0);\n\n\tag71xx_hw_init(ag);\n\n\terr = ag71xx_mdio_probe(ag);\n\tif (err)\n\t\tgoto err_put_clk;\n\n\tplatform_set_drvdata(pdev, ndev);\n\n\terr = ag71xx_phylink_setup(ag);\n\tif (err) {\n\t\tnetif_err(ag, probe, ndev, \"failed to setup phylink (%d)\\n\", err);\n\t\tgoto err_mdio_remove;\n\t}\n\n\terr = register_netdev(ndev);\n\tif (err) {\n\t\tnetif_err(ag, probe, ndev, \"unable to register net device\\n\");\n\t\tplatform_set_drvdata(pdev, NULL);\n\t\tgoto err_mdio_remove;\n\t}\n\n\tnetif_info(ag, probe, ndev, \"Atheros AG71xx at 0x%08lx, irq %d, mode:%s\\n\",\n\t\t   (unsigned long)ag->mac_base, ndev->irq,\n\t\t   phy_modes(ag->phy_if_mode));\n\n\treturn 0;\n\nerr_mdio_remove:\n\tag71xx_mdio_remove(ag);\nerr_put_clk:\n\tclk_disable_unprepare(ag->clk_eth);\n\treturn err;\n}\n\nstatic int ag71xx_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct ag71xx *ag;\n\n\tif (!ndev)\n\t\treturn 0;\n\n\tag = netdev_priv(ndev);\n\tunregister_netdev(ndev);\n\tag71xx_mdio_remove(ag);\n\tclk_disable_unprepare(ag->clk_eth);\n\tplatform_set_drvdata(pdev, NULL);\n\n\treturn 0;\n}\n\nstatic const u32 ar71xx_fifo_ar7100[] = {\n\t0x0fff0000, 0x00001fff, 0x00780fff,\n};\n\nstatic const u32 ar71xx_fifo_ar9130[] = {\n\t0x0fff0000, 0x00001fff, 0x008001ff,\n};\n\nstatic const u32 ar71xx_fifo_ar9330[] = {\n\t0x0010ffff, 0x015500aa, 0x01f00140,\n};\n\nstatic const struct ag71xx_dcfg ag71xx_dcfg_ar7100 = {\n\t.type = AR7100,\n\t.fifodata = ar71xx_fifo_ar7100,\n\t.max_frame_len = 1540,\n\t.desc_pktlen_mask = SZ_4K - 1,\n\t.tx_hang_workaround = false,\n};\n\nstatic const struct ag71xx_dcfg ag71xx_dcfg_ar7240 = {\n\t.type = AR7240,\n\t.fifodata = ar71xx_fifo_ar7100,\n\t.max_frame_len = 1540,\n\t.desc_pktlen_mask = SZ_4K - 1,\n\t.tx_hang_workaround = true,\n};\n\nstatic const struct ag71xx_dcfg ag71xx_dcfg_ar9130 = {\n\t.type = AR9130,\n\t.fifodata = ar71xx_fifo_ar9130,\n\t.max_frame_len = 1540,\n\t.desc_pktlen_mask = SZ_4K - 1,\n\t.tx_hang_workaround = false,\n};\n\nstatic const struct ag71xx_dcfg ag71xx_dcfg_ar9330 = {\n\t.type = AR9330,\n\t.fifodata = ar71xx_fifo_ar9330,\n\t.max_frame_len = 1540,\n\t.desc_pktlen_mask = SZ_4K - 1,\n\t.tx_hang_workaround = true,\n};\n\nstatic const struct ag71xx_dcfg ag71xx_dcfg_ar9340 = {\n\t.type = AR9340,\n\t.fifodata = ar71xx_fifo_ar9330,\n\t.max_frame_len = SZ_16K - 1,\n\t.desc_pktlen_mask = SZ_16K - 1,\n\t.tx_hang_workaround = true,\n};\n\nstatic const struct ag71xx_dcfg ag71xx_dcfg_qca9530 = {\n\t.type = QCA9530,\n\t.fifodata = ar71xx_fifo_ar9330,\n\t.max_frame_len = SZ_16K - 1,\n\t.desc_pktlen_mask = SZ_16K - 1,\n\t.tx_hang_workaround = true,\n};\n\nstatic const struct ag71xx_dcfg ag71xx_dcfg_qca9550 = {\n\t.type = QCA9550,\n\t.fifodata = ar71xx_fifo_ar9330,\n\t.max_frame_len = 1540,\n\t.desc_pktlen_mask = SZ_16K - 1,\n\t.tx_hang_workaround = true,\n};\n\nstatic const struct of_device_id ag71xx_match[] = {\n\t{ .compatible = \"qca,ar7100-eth\", .data = &ag71xx_dcfg_ar7100 },\n\t{ .compatible = \"qca,ar7240-eth\", .data = &ag71xx_dcfg_ar7240 },\n\t{ .compatible = \"qca,ar7241-eth\", .data = &ag71xx_dcfg_ar7240 },\n\t{ .compatible = \"qca,ar7242-eth\", .data = &ag71xx_dcfg_ar7240 },\n\t{ .compatible = \"qca,ar9130-eth\", .data = &ag71xx_dcfg_ar9130 },\n\t{ .compatible = \"qca,ar9330-eth\", .data = &ag71xx_dcfg_ar9330 },\n\t{ .compatible = \"qca,ar9340-eth\", .data = &ag71xx_dcfg_ar9340 },\n\t{ .compatible = \"qca,qca9530-eth\", .data = &ag71xx_dcfg_qca9530 },\n\t{ .compatible = \"qca,qca9550-eth\", .data = &ag71xx_dcfg_qca9550 },\n\t{ .compatible = \"qca,qca9560-eth\", .data = &ag71xx_dcfg_qca9550 },\n\t{}\n};\n\nstatic struct platform_driver ag71xx_driver = {\n\t.probe\t\t= ag71xx_probe,\n\t.remove\t\t= ag71xx_remove,\n\t.driver = {\n\t\t.name\t= \"ag71xx\",\n\t\t.of_match_table = ag71xx_match,\n\t}\n};\n\nmodule_platform_driver(ag71xx_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}