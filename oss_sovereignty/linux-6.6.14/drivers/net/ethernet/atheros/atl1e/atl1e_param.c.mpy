{
  "module_name": "atl1e_param.c",
  "hash_id": "c94f3cc1139a9eb29bd9bded5b302a6408420a87ca43f72308eefc8c6886f12a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/atheros/atl1e/atl1e_param.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n\n#include \"atl1e.h\"\n\n \n\n#define ATL1E_MAX_NIC 32\n\n#define OPTION_UNSET    -1\n#define OPTION_DISABLED 0\n#define OPTION_ENABLED  1\n\n \n#define ATL1E_PARAM_INIT { [0 ... ATL1E_MAX_NIC] = OPTION_UNSET }\n\n#define ATL1E_PARAM(x, desc) \\\n\tstatic int x[ATL1E_MAX_NIC + 1] = ATL1E_PARAM_INIT; \\\n\tstatic unsigned int num_##x; \\\n\tmodule_param_array_named(x, x, int, &num_##x, 0); \\\n\tMODULE_PARM_DESC(x, desc);\n\n \n#define ATL1E_MIN_TX_DESC_CNT\t\t32\n#define ATL1E_MAX_TX_DESC_CNT\t\t1020\n#define ATL1E_DEFAULT_TX_DESC_CNT\t128\nATL1E_PARAM(tx_desc_cnt, \"Transmit description count\");\n\n \n#define ATL1E_MIN_RX_MEM_SIZE\t\t8     \n#define ATL1E_MAX_RX_MEM_SIZE\t\t1024  \n#define ATL1E_DEFAULT_RX_MEM_SIZE\t256   \nATL1E_PARAM(rx_mem_size, \"memory size of rx buffer(KB)\");\n\n \n\nATL1E_PARAM(media_type, \"MediaType Select\");\n\n \n#define INT_MOD_DEFAULT_CNT             100  \n#define INT_MOD_MAX_CNT                 65000\n#define INT_MOD_MIN_CNT                 50\nATL1E_PARAM(int_mod_timer, \"Interrupt Moderator Timer\");\n\n#define AUTONEG_ADV_DEFAULT  0x2F\n#define AUTONEG_ADV_MASK     0x2F\n#define FLOW_CONTROL_DEFAULT FLOW_CONTROL_FULL\n\n#define FLASH_VENDOR_DEFAULT    0\n#define FLASH_VENDOR_MIN        0\n#define FLASH_VENDOR_MAX        2\n\nstruct atl1e_option {\n\tenum { enable_option, range_option, list_option } type;\n\tchar *name;\n\tchar *err;\n\tint  def;\n\tunion {\n\t\tstruct {  \n\t\t\tint min;\n\t\t\tint max;\n\t\t} r;\n\t\tstruct {  \n\t\t\tint nr;\n\t\t\tstruct atl1e_opt_list { int i; char *str; } *p;\n\t\t} l;\n\t} arg;\n};\n\nstatic int atl1e_validate_option(int *value, struct atl1e_option *opt,\n\t\t\t\t struct atl1e_adapter *adapter)\n{\n\tif (*value == OPTION_UNSET) {\n\t\t*value = opt->def;\n\t\treturn 0;\n\t}\n\n\tswitch (opt->type) {\n\tcase enable_option:\n\t\tswitch (*value) {\n\t\tcase OPTION_ENABLED:\n\t\t\tnetdev_info(adapter->netdev,\n\t\t\t\t    \"%s Enabled\\n\", opt->name);\n\t\t\treturn 0;\n\t\tcase OPTION_DISABLED:\n\t\t\tnetdev_info(adapter->netdev,\n\t\t\t\t    \"%s Disabled\\n\", opt->name);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase range_option:\n\t\tif (*value >= opt->arg.r.min && *value <= opt->arg.r.max) {\n\t\t\tnetdev_info(adapter->netdev, \"%s set to %i\\n\",\n\t\t\t\t    opt->name, *value);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase list_option:{\n\t\t\tint i;\n\t\t\tstruct atl1e_opt_list *ent;\n\n\t\t\tfor (i = 0; i < opt->arg.l.nr; i++) {\n\t\t\t\tent = &opt->arg.l.p[i];\n\t\t\t\tif (*value == ent->i) {\n\t\t\t\t\tif (ent->str[0] != '\\0')\n\t\t\t\t\t\tnetdev_info(adapter->netdev,\n\t\t\t\t\t\t\t    \"%s\\n\", ent->str);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tBUG();\n\t}\n\n\tnetdev_info(adapter->netdev, \"Invalid %s specified (%i) %s\\n\",\n\t\t    opt->name, *value, opt->err);\n\t*value = opt->def;\n\treturn -1;\n}\n\n \nvoid atl1e_check_options(struct atl1e_adapter *adapter)\n{\n\tint bd = adapter->bd_number;\n\n\tif (bd >= ATL1E_MAX_NIC) {\n\t\tnetdev_notice(adapter->netdev,\n\t\t\t      \"no configuration for board #%i\\n\", bd);\n\t\tnetdev_notice(adapter->netdev,\n\t\t\t      \"Using defaults for all values\\n\");\n\t}\n\n\t{ \t\t \n\t\tstruct atl1e_option opt = {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Transmit Ddescription Count\",\n\t\t\t.err  = \"using default of \"\n\t\t\t\t__MODULE_STRING(ATL1E_DEFAULT_TX_DESC_CNT),\n\t\t\t.def  = ATL1E_DEFAULT_TX_DESC_CNT,\n\t\t\t.arg  = { .r = { .min = ATL1E_MIN_TX_DESC_CNT,\n\t\t\t\t\t .max = ATL1E_MAX_TX_DESC_CNT} }\n\t\t};\n\t\tint val;\n\t\tif (num_tx_desc_cnt > bd) {\n\t\t\tval = tx_desc_cnt[bd];\n\t\t\tatl1e_validate_option(&val, &opt, adapter);\n\t\t\tadapter->tx_ring.count = (u16) val & 0xFFFC;\n\t\t} else\n\t\t\tadapter->tx_ring.count = (u16)opt.def;\n\t}\n\n\t{ \t\t \n\t\tstruct atl1e_option opt = {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Memory size of rx buffer(KB)\",\n\t\t\t.err  = \"using default of \"\n\t\t\t\t__MODULE_STRING(ATL1E_DEFAULT_RX_MEM_SIZE),\n\t\t\t.def  = ATL1E_DEFAULT_RX_MEM_SIZE,\n\t\t\t.arg  = { .r = { .min = ATL1E_MIN_RX_MEM_SIZE,\n\t\t\t\t\t .max = ATL1E_MAX_RX_MEM_SIZE} }\n\t\t};\n\t\tint val;\n\t\tif (num_rx_mem_size > bd) {\n\t\t\tval = rx_mem_size[bd];\n\t\t\tatl1e_validate_option(&val, &opt, adapter);\n\t\t\tadapter->rx_ring.page_size = (u32)val * 1024;\n\t\t} else {\n\t\t\tadapter->rx_ring.page_size = (u32)opt.def * 1024;\n\t\t}\n\t}\n\n\t{ \t\t \n\t\tstruct atl1e_option opt = {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Interrupt Moderate Timer\",\n\t\t\t.err  = \"using default of \"\n\t\t\t\t__MODULE_STRING(INT_MOD_DEFAULT_CNT),\n\t\t\t.def  = INT_MOD_DEFAULT_CNT,\n\t\t\t.arg  = { .r = { .min = INT_MOD_MIN_CNT,\n\t\t\t\t\t .max = INT_MOD_MAX_CNT} }\n\t\t} ;\n\t\tint val;\n\t\tif (num_int_mod_timer > bd) {\n\t\t\tval = int_mod_timer[bd];\n\t\t\tatl1e_validate_option(&val, &opt, adapter);\n\t\t\tadapter->hw.imt = (u16) val;\n\t\t} else\n\t\t\tadapter->hw.imt = (u16)(opt.def);\n\t}\n\n\t{ \t\t \n\t\tstruct atl1e_option opt = {\n\t\t\t.type = range_option,\n\t\t\t.name = \"Speed/Duplex Selection\",\n\t\t\t.err  = \"using default of \"\n\t\t\t\t__MODULE_STRING(MEDIA_TYPE_AUTO_SENSOR),\n\t\t\t.def  = MEDIA_TYPE_AUTO_SENSOR,\n\t\t\t.arg  = { .r = { .min = MEDIA_TYPE_AUTO_SENSOR,\n\t\t\t\t\t .max = MEDIA_TYPE_10M_HALF} }\n\t\t} ;\n\t\tint val;\n\t\tif (num_media_type > bd) {\n\t\t\tval = media_type[bd];\n\t\t\tatl1e_validate_option(&val, &opt, adapter);\n\t\t\tadapter->hw.media_type = (u16) val;\n\t\t} else\n\t\t\tadapter->hw.media_type = (u16)(opt.def);\n\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}