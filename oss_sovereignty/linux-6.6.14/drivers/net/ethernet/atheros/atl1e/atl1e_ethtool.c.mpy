{
  "module_name": "atl1e_ethtool.c",
  "hash_id": "26af951a2acb15ee3766e6d3475731d9e4b509ef3d0d897649fc1fa9937805e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/atheros/atl1e/atl1e_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/slab.h>\n\n#include \"atl1e.h\"\n\nstatic int atl1e_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tstruct atl1e_adapter *adapter = netdev_priv(netdev);\n\tstruct atl1e_hw *hw = &adapter->hw;\n\tu32 supported, advertising;\n\n\tsupported = (SUPPORTED_10baseT_Half  |\n\t\t\t   SUPPORTED_10baseT_Full  |\n\t\t\t   SUPPORTED_100baseT_Half |\n\t\t\t   SUPPORTED_100baseT_Full |\n\t\t\t   SUPPORTED_Autoneg       |\n\t\t\t   SUPPORTED_TP);\n\tif (hw->nic_type == athr_l1e)\n\t\tsupported |= SUPPORTED_1000baseT_Full;\n\n\tadvertising = ADVERTISED_TP;\n\n\tadvertising |= ADVERTISED_Autoneg;\n\tadvertising |= hw->autoneg_advertised;\n\n\tcmd->base.port = PORT_TP;\n\tcmd->base.phy_address = 0;\n\n\tif (adapter->link_speed != SPEED_0) {\n\t\tcmd->base.speed = adapter->link_speed;\n\t\tif (adapter->link_duplex == FULL_DUPLEX)\n\t\t\tcmd->base.duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tcmd->base.duplex = DUPLEX_HALF;\n\t} else {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tcmd->base.autoneg = AUTONEG_ENABLE;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int atl1e_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t    const struct ethtool_link_ksettings *cmd)\n{\n\tstruct atl1e_adapter *adapter = netdev_priv(netdev);\n\tstruct atl1e_hw *hw = &adapter->hw;\n\tu32 advertising;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\twhile (test_and_set_bit(__AT_RESETTING, &adapter->flags))\n\t\tmsleep(1);\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tu16 adv4, adv9;\n\n\t\tif (advertising & ADVERTISE_1000_FULL) {\n\t\t\tif (hw->nic_type == athr_l1e) {\n\t\t\t\thw->autoneg_advertised =\n\t\t\t\t\tadvertising & AT_ADV_MASK;\n\t\t\t} else {\n\t\t\t\tclear_bit(__AT_RESETTING, &adapter->flags);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (advertising & ADVERTISE_1000_HALF) {\n\t\t\tclear_bit(__AT_RESETTING, &adapter->flags);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\thw->autoneg_advertised =\n\t\t\t\tadvertising & AT_ADV_MASK;\n\t\t}\n\t\tadvertising = hw->autoneg_advertised |\n\t\t\t\t    ADVERTISED_TP | ADVERTISED_Autoneg;\n\n\t\tadv4 = hw->mii_autoneg_adv_reg & ~ADVERTISE_ALL;\n\t\tadv9 = hw->mii_1000t_ctrl_reg & ~MII_AT001_CR_1000T_SPEED_MASK;\n\t\tif (hw->autoneg_advertised & ADVERTISE_10_HALF)\n\t\t\tadv4 |= ADVERTISE_10HALF;\n\t\tif (hw->autoneg_advertised & ADVERTISE_10_FULL)\n\t\t\tadv4 |= ADVERTISE_10FULL;\n\t\tif (hw->autoneg_advertised & ADVERTISE_100_HALF)\n\t\t\tadv4 |= ADVERTISE_100HALF;\n\t\tif (hw->autoneg_advertised & ADVERTISE_100_FULL)\n\t\t\tadv4 |= ADVERTISE_100FULL;\n\t\tif (hw->autoneg_advertised & ADVERTISE_1000_FULL)\n\t\t\tadv9 |= ADVERTISE_1000FULL;\n\n\t\tif (adv4 != hw->mii_autoneg_adv_reg ||\n\t\t\t\tadv9 != hw->mii_1000t_ctrl_reg) {\n\t\t\thw->mii_autoneg_adv_reg = adv4;\n\t\t\thw->mii_1000t_ctrl_reg = adv9;\n\t\t\thw->re_autoneg = true;\n\t\t}\n\n\t} else {\n\t\tclear_bit(__AT_RESETTING, &adapter->flags);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tif (netif_running(adapter->netdev)) {\n\t\tatl1e_down(adapter);\n\t\tatl1e_up(adapter);\n\t} else\n\t\tatl1e_reset_hw(&adapter->hw);\n\n\tclear_bit(__AT_RESETTING, &adapter->flags);\n\treturn 0;\n}\n\nstatic u32 atl1e_get_msglevel(struct net_device *netdev)\n{\n#ifdef DBG\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\nstatic int atl1e_get_regs_len(struct net_device *netdev)\n{\n\treturn AT_REGS_LEN * sizeof(u32);\n}\n\nstatic void atl1e_get_regs(struct net_device *netdev,\n\t\t\t   struct ethtool_regs *regs, void *p)\n{\n\tstruct atl1e_adapter *adapter = netdev_priv(netdev);\n\tstruct atl1e_hw *hw = &adapter->hw;\n\tu32 *regs_buff = p;\n\tu16 phy_data;\n\n\tmemset(p, 0, AT_REGS_LEN * sizeof(u32));\n\n\tregs->version = (1 << 24) | (hw->revision_id << 16) | hw->device_id;\n\n\tregs_buff[0]  = AT_READ_REG(hw, REG_VPD_CAP);\n\tregs_buff[1]  = AT_READ_REG(hw, REG_SPI_FLASH_CTRL);\n\tregs_buff[2]  = AT_READ_REG(hw, REG_SPI_FLASH_CONFIG);\n\tregs_buff[3]  = AT_READ_REG(hw, REG_TWSI_CTRL);\n\tregs_buff[4]  = AT_READ_REG(hw, REG_PCIE_DEV_MISC_CTRL);\n\tregs_buff[5]  = AT_READ_REG(hw, REG_MASTER_CTRL);\n\tregs_buff[6]  = AT_READ_REG(hw, REG_MANUAL_TIMER_INIT);\n\tregs_buff[7]  = AT_READ_REG(hw, REG_IRQ_MODU_TIMER_INIT);\n\tregs_buff[8]  = AT_READ_REG(hw, REG_GPHY_CTRL);\n\tregs_buff[9]  = AT_READ_REG(hw, REG_CMBDISDMA_TIMER);\n\tregs_buff[10] = AT_READ_REG(hw, REG_IDLE_STATUS);\n\tregs_buff[11] = AT_READ_REG(hw, REG_MDIO_CTRL);\n\tregs_buff[12] = AT_READ_REG(hw, REG_SERDES_LOCK);\n\tregs_buff[13] = AT_READ_REG(hw, REG_MAC_CTRL);\n\tregs_buff[14] = AT_READ_REG(hw, REG_MAC_IPG_IFG);\n\tregs_buff[15] = AT_READ_REG(hw, REG_MAC_STA_ADDR);\n\tregs_buff[16] = AT_READ_REG(hw, REG_MAC_STA_ADDR+4);\n\tregs_buff[17] = AT_READ_REG(hw, REG_RX_HASH_TABLE);\n\tregs_buff[18] = AT_READ_REG(hw, REG_RX_HASH_TABLE+4);\n\tregs_buff[19] = AT_READ_REG(hw, REG_MAC_HALF_DUPLX_CTRL);\n\tregs_buff[20] = AT_READ_REG(hw, REG_MTU);\n\tregs_buff[21] = AT_READ_REG(hw, REG_WOL_CTRL);\n\tregs_buff[22] = AT_READ_REG(hw, REG_SRAM_TRD_ADDR);\n\tregs_buff[23] = AT_READ_REG(hw, REG_SRAM_TRD_LEN);\n\tregs_buff[24] = AT_READ_REG(hw, REG_SRAM_RXF_ADDR);\n\tregs_buff[25] = AT_READ_REG(hw, REG_SRAM_RXF_LEN);\n\tregs_buff[26] = AT_READ_REG(hw, REG_SRAM_TXF_ADDR);\n\tregs_buff[27] = AT_READ_REG(hw, REG_SRAM_TXF_LEN);\n\tregs_buff[28] = AT_READ_REG(hw, REG_SRAM_TCPH_ADDR);\n\tregs_buff[29] = AT_READ_REG(hw, REG_SRAM_PKTH_ADDR);\n\n\tatl1e_read_phy_reg(hw, MII_BMCR, &phy_data);\n\tregs_buff[73] = (u32)phy_data;\n\tatl1e_read_phy_reg(hw, MII_BMSR, &phy_data);\n\tregs_buff[74] = (u32)phy_data;\n}\n\nstatic int atl1e_get_eeprom_len(struct net_device *netdev)\n{\n\tstruct atl1e_adapter *adapter = netdev_priv(netdev);\n\n\tif (!atl1e_check_eeprom_exist(&adapter->hw))\n\t\treturn AT_EEPROM_LEN;\n\telse\n\t\treturn 0;\n}\n\nstatic int atl1e_get_eeprom(struct net_device *netdev,\n\t\tstruct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct atl1e_adapter *adapter = netdev_priv(netdev);\n\tstruct atl1e_hw *hw = &adapter->hw;\n\tu32 *eeprom_buff;\n\tint first_dword, last_dword;\n\tint ret_val = 0;\n\tint i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EINVAL;\n\n\tif (atl1e_check_eeprom_exist(hw))  \n\t\treturn -EINVAL;\n\n\teeprom->magic = hw->vendor_id | (hw->device_id << 16);\n\n\tfirst_dword = eeprom->offset >> 2;\n\tlast_dword = (eeprom->offset + eeprom->len - 1) >> 2;\n\n\teeprom_buff = kmalloc_array(last_dword - first_dword + 1, sizeof(u32),\n\t\t\t\t    GFP_KERNEL);\n\tif (eeprom_buff == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = first_dword; i < last_dword; i++) {\n\t\tif (!atl1e_read_eeprom(hw, i * 4, &(eeprom_buff[i-first_dword]))) {\n\t\t\tkfree(eeprom_buff);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tmemcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 3),\n\t\t\teeprom->len);\n\tkfree(eeprom_buff);\n\n\treturn ret_val;\n}\n\nstatic int atl1e_set_eeprom(struct net_device *netdev,\n\t\t\t    struct ethtool_eeprom *eeprom, u8 *bytes)\n{\n\tstruct atl1e_adapter *adapter = netdev_priv(netdev);\n\tstruct atl1e_hw *hw = &adapter->hw;\n\tu32 *eeprom_buff;\n\tu32 *ptr;\n\tint first_dword, last_dword;\n\tint ret_val = 0;\n\tint i;\n\n\tif (eeprom->len == 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))\n\t\treturn -EINVAL;\n\n\tfirst_dword = eeprom->offset >> 2;\n\tlast_dword = (eeprom->offset + eeprom->len - 1) >> 2;\n\teeprom_buff = kmalloc(AT_EEPROM_LEN, GFP_KERNEL);\n\tif (eeprom_buff == NULL)\n\t\treturn -ENOMEM;\n\n\tptr = eeprom_buff;\n\n\tif (eeprom->offset & 3) {\n\t\t \n\t\t \n\t\tif (!atl1e_read_eeprom(hw, first_dword * 4, &(eeprom_buff[0]))) {\n\t\t\tret_val = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tptr++;\n\t}\n\tif (((eeprom->offset + eeprom->len) & 3)) {\n\t\t \n\t\t \n\n\t\tif (!atl1e_read_eeprom(hw, last_dword * 4,\n\t\t\t\t&(eeprom_buff[last_dword - first_dword]))) {\n\t\t\tret_val = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tmemcpy(ptr, bytes, eeprom->len);\n\n\tfor (i = 0; i < last_dword - first_dword + 1; i++) {\n\t\tif (!atl1e_write_eeprom(hw, ((first_dword + i) * 4),\n\t\t\t\t  eeprom_buff[i])) {\n\t\t\tret_val = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tkfree(eeprom_buff);\n\treturn ret_val;\n}\n\nstatic void atl1e_get_drvinfo(struct net_device *netdev,\n\t\tstruct ethtool_drvinfo *drvinfo)\n{\n\tstruct atl1e_adapter *adapter = netdev_priv(netdev);\n\n\tstrscpy(drvinfo->driver,  atl1e_driver_name, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->fw_version, \"L1e\", sizeof(drvinfo->fw_version));\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic void atl1e_get_wol(struct net_device *netdev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\tstruct atl1e_adapter *adapter = netdev_priv(netdev);\n\n\twol->supported = WAKE_MAGIC | WAKE_PHY;\n\twol->wolopts = 0;\n\n\tif (adapter->wol & AT_WUFC_EX)\n\t\twol->wolopts |= WAKE_UCAST;\n\tif (adapter->wol & AT_WUFC_MC)\n\t\twol->wolopts |= WAKE_MCAST;\n\tif (adapter->wol & AT_WUFC_BC)\n\t\twol->wolopts |= WAKE_BCAST;\n\tif (adapter->wol & AT_WUFC_MAG)\n\t\twol->wolopts |= WAKE_MAGIC;\n\tif (adapter->wol & AT_WUFC_LNKC)\n\t\twol->wolopts |= WAKE_PHY;\n}\n\nstatic int atl1e_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct atl1e_adapter *adapter = netdev_priv(netdev);\n\n\tif (wol->wolopts & (WAKE_ARP | WAKE_MAGICSECURE |\n\t\t\t    WAKE_UCAST | WAKE_MCAST | WAKE_BCAST))\n\t\treturn -EOPNOTSUPP;\n\t \n\tadapter->wol = 0;\n\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\tadapter->wol |= AT_WUFC_MAG;\n\tif (wol->wolopts & WAKE_PHY)\n\t\tadapter->wol |= AT_WUFC_LNKC;\n\n\tdevice_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);\n\n\treturn 0;\n}\n\nstatic int atl1e_nway_reset(struct net_device *netdev)\n{\n\tstruct atl1e_adapter *adapter = netdev_priv(netdev);\n\tif (netif_running(netdev))\n\t\tatl1e_reinit_locked(adapter);\n\treturn 0;\n}\n\nstatic const struct ethtool_ops atl1e_ethtool_ops = {\n\t.get_drvinfo            = atl1e_get_drvinfo,\n\t.get_regs_len           = atl1e_get_regs_len,\n\t.get_regs               = atl1e_get_regs,\n\t.get_wol                = atl1e_get_wol,\n\t.set_wol                = atl1e_set_wol,\n\t.get_msglevel           = atl1e_get_msglevel,\n\t.nway_reset             = atl1e_nway_reset,\n\t.get_link               = ethtool_op_get_link,\n\t.get_eeprom_len         = atl1e_get_eeprom_len,\n\t.get_eeprom             = atl1e_get_eeprom,\n\t.set_eeprom             = atl1e_set_eeprom,\n\t.get_link_ksettings     = atl1e_get_link_ksettings,\n\t.set_link_ksettings     = atl1e_set_link_ksettings,\n};\n\nvoid atl1e_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &atl1e_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}