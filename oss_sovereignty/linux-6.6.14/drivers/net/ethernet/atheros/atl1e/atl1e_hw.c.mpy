{
  "module_name": "atl1e_hw.c",
  "hash_id": "21588e084ea1c7d5db6fc99cb44d61a1422e5e158bd769fb85a4216698d35514",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/atheros/atl1e/atl1e_hw.c",
  "human_readable_source": "\n \n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/mii.h>\n#include <linux/crc32.h>\n\n#include \"atl1e.h\"\n\n \nint atl1e_check_eeprom_exist(struct atl1e_hw *hw)\n{\n\tu32 value;\n\n\tvalue = AT_READ_REG(hw, REG_SPI_FLASH_CTRL);\n\tif (value & SPI_FLASH_CTRL_EN_VPD) {\n\t\tvalue &= ~SPI_FLASH_CTRL_EN_VPD;\n\t\tAT_WRITE_REG(hw, REG_SPI_FLASH_CTRL, value);\n\t}\n\tvalue = AT_READ_REGW(hw, REG_PCIE_CAP_LIST);\n\treturn ((value & 0xFF00) == 0x6C00) ? 0 : 1;\n}\n\nvoid atl1e_hw_set_mac_addr(struct atl1e_hw *hw)\n{\n\tu32 value;\n\t \n\tvalue = (((u32)hw->mac_addr[2]) << 24) |\n\t\t(((u32)hw->mac_addr[3]) << 16) |\n\t\t(((u32)hw->mac_addr[4]) << 8)  |\n\t\t(((u32)hw->mac_addr[5])) ;\n\tAT_WRITE_REG_ARRAY(hw, REG_MAC_STA_ADDR, 0, value);\n\t \n\tvalue = (((u32)hw->mac_addr[0]) << 8) |\n\t\t(((u32)hw->mac_addr[1])) ;\n\tAT_WRITE_REG_ARRAY(hw, REG_MAC_STA_ADDR, 1, value);\n}\n\n \nstatic int atl1e_get_permanent_address(struct atl1e_hw *hw)\n{\n\tu32 addr[2];\n\tu32 i;\n\tu32 twsi_ctrl_data;\n\tu8  eth_addr[ETH_ALEN];\n\n\tif (is_valid_ether_addr(hw->perm_mac_addr))\n\t\treturn 0;\n\n\t \n\taddr[0] = addr[1] = 0;\n\n\tif (!atl1e_check_eeprom_exist(hw)) {\n\t\t \n\t\ttwsi_ctrl_data = AT_READ_REG(hw, REG_TWSI_CTRL);\n\t\ttwsi_ctrl_data |= TWSI_CTRL_SW_LDSTART;\n\t\tAT_WRITE_REG(hw, REG_TWSI_CTRL, twsi_ctrl_data);\n\t\tfor (i = 0; i < AT_TWSI_EEPROM_TIMEOUT; i++) {\n\t\t\tmsleep(10);\n\t\t\ttwsi_ctrl_data = AT_READ_REG(hw, REG_TWSI_CTRL);\n\t\t\tif ((twsi_ctrl_data & TWSI_CTRL_SW_LDSTART) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= AT_TWSI_EEPROM_TIMEOUT)\n\t\t\treturn AT_ERR_TIMEOUT;\n\t}\n\n\t \n\taddr[0] = AT_READ_REG(hw, REG_MAC_STA_ADDR);\n\taddr[1] = AT_READ_REG(hw, REG_MAC_STA_ADDR + 4);\n\t*(u32 *) &eth_addr[2] = swab32(addr[0]);\n\t*(u16 *) &eth_addr[0] = swab16(*(u16 *)&addr[1]);\n\n\tif (is_valid_ether_addr(eth_addr)) {\n\t\tmemcpy(hw->perm_mac_addr, eth_addr, ETH_ALEN);\n\t\treturn 0;\n\t}\n\n\treturn AT_ERR_EEPROM;\n}\n\nbool atl1e_write_eeprom(struct atl1e_hw *hw, u32 offset, u32 value)\n{\n\treturn true;\n}\n\nbool atl1e_read_eeprom(struct atl1e_hw *hw, u32 offset, u32 *p_value)\n{\n\tint i;\n\tu32 control;\n\n\tif (offset & 3)\n\t\treturn false;  \n\n\tAT_WRITE_REG(hw, REG_VPD_DATA, 0);\n\tcontrol = (offset & VPD_CAP_VPD_ADDR_MASK) << VPD_CAP_VPD_ADDR_SHIFT;\n\tAT_WRITE_REG(hw, REG_VPD_CAP, control);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tmsleep(2);\n\t\tcontrol = AT_READ_REG(hw, REG_VPD_CAP);\n\t\tif (control & VPD_CAP_VPD_FLAG)\n\t\t\tbreak;\n\t}\n\tif (control & VPD_CAP_VPD_FLAG) {\n\t\t*p_value = AT_READ_REG(hw, REG_VPD_DATA);\n\t\treturn true;\n\t}\n\treturn false;  \n}\n\nvoid atl1e_force_ps(struct atl1e_hw *hw)\n{\n\tAT_WRITE_REGW(hw, REG_GPHY_CTRL,\n\t\t\tGPHY_CTRL_PW_WOL_DIS | GPHY_CTRL_EXT_RESET);\n}\n\n \nint atl1e_read_mac_addr(struct atl1e_hw *hw)\n{\n\tint err = 0;\n\n\terr = atl1e_get_permanent_address(hw);\n\tif (err)\n\t\treturn AT_ERR_EEPROM;\n\tmemcpy(hw->mac_addr, hw->perm_mac_addr, sizeof(hw->perm_mac_addr));\n\treturn 0;\n}\n\n \nu32 atl1e_hash_mc_addr(struct atl1e_hw *hw, u8 *mc_addr)\n{\n\tu32 crc32;\n\tu32 value = 0;\n\tint i;\n\n\tcrc32 = ether_crc_le(6, mc_addr);\n\tfor (i = 0; i < 32; i++)\n\t\tvalue |= (((crc32 >> i) & 1) << (31 - i));\n\n\treturn value;\n}\n\n \nvoid atl1e_hash_set(struct atl1e_hw *hw, u32 hash_value)\n{\n\tu32 hash_bit, hash_reg;\n\tu32 mta;\n\n\t \n\thash_reg = (hash_value >> 31) & 0x1;\n\thash_bit = (hash_value >> 26) & 0x1F;\n\n\tmta = AT_READ_REG_ARRAY(hw, REG_RX_HASH_TABLE, hash_reg);\n\n\tmta |= (1 << hash_bit);\n\n\tAT_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, hash_reg, mta);\n}\n \nint atl1e_read_phy_reg(struct atl1e_hw *hw, u16 reg_addr, u16 *phy_data)\n{\n\tu32 val;\n\tint i;\n\n\tval = ((u32)(reg_addr & MDIO_REG_ADDR_MASK)) << MDIO_REG_ADDR_SHIFT |\n\t\tMDIO_START | MDIO_SUP_PREAMBLE | MDIO_RW |\n\t\tMDIO_CLK_25_4 << MDIO_CLK_SEL_SHIFT;\n\n\tAT_WRITE_REG(hw, REG_MDIO_CTRL, val);\n\n\twmb();\n\n\tfor (i = 0; i < MDIO_WAIT_TIMES; i++) {\n\t\tudelay(2);\n\t\tval = AT_READ_REG(hw, REG_MDIO_CTRL);\n\t\tif (!(val & (MDIO_START | MDIO_BUSY)))\n\t\t\tbreak;\n\t\twmb();\n\t}\n\tif (!(val & (MDIO_START | MDIO_BUSY))) {\n\t\t*phy_data = (u16)val;\n\t\treturn 0;\n\t}\n\n\treturn AT_ERR_PHY;\n}\n\n \nint atl1e_write_phy_reg(struct atl1e_hw *hw, u32 reg_addr, u16 phy_data)\n{\n\tint i;\n\tu32 val;\n\n\tval = ((u32)(phy_data & MDIO_DATA_MASK)) << MDIO_DATA_SHIFT |\n\t       (reg_addr&MDIO_REG_ADDR_MASK) << MDIO_REG_ADDR_SHIFT |\n\t       MDIO_SUP_PREAMBLE |\n\t       MDIO_START |\n\t       MDIO_CLK_25_4 << MDIO_CLK_SEL_SHIFT;\n\n\tAT_WRITE_REG(hw, REG_MDIO_CTRL, val);\n\twmb();\n\n\tfor (i = 0; i < MDIO_WAIT_TIMES; i++) {\n\t\tudelay(2);\n\t\tval = AT_READ_REG(hw, REG_MDIO_CTRL);\n\t\tif (!(val & (MDIO_START | MDIO_BUSY)))\n\t\t\tbreak;\n\t\twmb();\n\t}\n\n\tif (!(val & (MDIO_START | MDIO_BUSY)))\n\t\treturn 0;\n\n\treturn AT_ERR_PHY;\n}\n\n \nstatic void atl1e_init_pcie(struct atl1e_hw *hw)\n{\n\tu32 value;\n\t \n\n\t \n\tvalue = AT_READ_REG(hw, 0x1008);\n\tvalue |= 0x8000;\n\tAT_WRITE_REG(hw, 0x1008, value);\n}\n \nstatic int atl1e_phy_setup_autoneg_adv(struct atl1e_hw *hw)\n{\n\ts32 ret_val;\n\tu16 mii_autoneg_adv_reg;\n\tu16 mii_1000t_ctrl_reg;\n\n\tif (0 != hw->mii_autoneg_adv_reg)\n\t\treturn 0;\n\t \n\tmii_autoneg_adv_reg = MII_AR_DEFAULT_CAP_MASK;\n\tmii_1000t_ctrl_reg  = MII_AT001_CR_1000T_DEFAULT_CAP_MASK;\n\n\t \n\n\t \n\tmii_autoneg_adv_reg &= ~ADVERTISE_ALL;\n\tmii_1000t_ctrl_reg  &= ~MII_AT001_CR_1000T_SPEED_MASK;\n\n\t \n\tswitch (hw->media_type) {\n\tcase MEDIA_TYPE_AUTO_SENSOR:\n\t\tmii_autoneg_adv_reg |= ADVERTISE_ALL;\n\t\thw->autoneg_advertised = ADVERTISE_ALL;\n\t\tif (hw->nic_type == athr_l1e) {\n\t\t\tmii_1000t_ctrl_reg |= ADVERTISE_1000FULL;\n\t\t\thw->autoneg_advertised |= ADVERTISE_1000_FULL;\n\t\t}\n\t\tbreak;\n\n\tcase MEDIA_TYPE_100M_FULL:\n\t\tmii_autoneg_adv_reg   |= ADVERTISE_100FULL;\n\t\thw->autoneg_advertised = ADVERTISE_100_FULL;\n\t\tbreak;\n\n\tcase MEDIA_TYPE_100M_HALF:\n\t\tmii_autoneg_adv_reg   |= ADVERTISE_100_HALF;\n\t\thw->autoneg_advertised = ADVERTISE_100_HALF;\n\t\tbreak;\n\n\tcase MEDIA_TYPE_10M_FULL:\n\t\tmii_autoneg_adv_reg   |= ADVERTISE_10_FULL;\n\t\thw->autoneg_advertised = ADVERTISE_10_FULL;\n\t\tbreak;\n\n\tdefault:\n\t\tmii_autoneg_adv_reg   |= ADVERTISE_10_HALF;\n\t\thw->autoneg_advertised = ADVERTISE_10_HALF;\n\t\tbreak;\n\t}\n\n\t \n\tmii_autoneg_adv_reg |= (ADVERTISE_PAUSE_ASYM | ADVERTISE_PAUSE_CAP);\n\n\thw->mii_autoneg_adv_reg = mii_autoneg_adv_reg;\n\thw->mii_1000t_ctrl_reg  = mii_1000t_ctrl_reg;\n\n\tret_val = atl1e_write_phy_reg(hw, MII_ADVERTISE, mii_autoneg_adv_reg);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (hw->nic_type == athr_l1e || hw->nic_type == athr_l2e_revA) {\n\t\tret_val = atl1e_write_phy_reg(hw, MII_CTRL1000,\n\t\t\t\t\t   mii_1000t_ctrl_reg);\n\t\tif (ret_val)\n\t\t\treturn ret_val;\n\t}\n\n\treturn 0;\n}\n\n\n \nint atl1e_phy_commit(struct atl1e_hw *hw)\n{\n\tstruct atl1e_adapter *adapter = hw->adapter;\n\tint ret_val;\n\tu16 phy_data;\n\n\tphy_data = BMCR_RESET | BMCR_ANENABLE | BMCR_ANRESTART;\n\n\tret_val = atl1e_write_phy_reg(hw, MII_BMCR, phy_data);\n\tif (ret_val) {\n\t\tu32 val;\n\t\tint i;\n\t\t \n\t\tfor (i = 0; i < 25; i++) {\n\t\t\tmsleep(1);\n\t\t\tval = AT_READ_REG(hw, REG_MDIO_CTRL);\n\t\t\tif (!(val & (MDIO_START | MDIO_BUSY)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (0 != (val & (MDIO_START | MDIO_BUSY))) {\n\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t   \"pcie linkdown at least for 25ms\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\n\t\tnetdev_err(adapter->netdev, \"pcie linkup after %d ms\\n\", i);\n\t}\n\treturn 0;\n}\n\nint atl1e_phy_init(struct atl1e_hw *hw)\n{\n\tstruct atl1e_adapter *adapter = hw->adapter;\n\ts32 ret_val;\n\tu16 phy_val;\n\n\tif (hw->phy_configured) {\n\t\tif (hw->re_autoneg) {\n\t\t\thw->re_autoneg = false;\n\t\t\treturn atl1e_restart_autoneg(hw);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tAT_WRITE_REGW(hw, REG_GPHY_CTRL, GPHY_CTRL_DEFAULT);\n\tmsleep(2);\n\tAT_WRITE_REGW(hw, REG_GPHY_CTRL, GPHY_CTRL_DEFAULT |\n\t\t      GPHY_CTRL_EXT_RESET);\n\tmsleep(2);\n\n\t \n\t \n\tret_val = atl1e_write_phy_reg(hw, MII_DBG_ADDR, 0xB);\n\tif (ret_val)\n\t\treturn ret_val;\n\tret_val = atl1e_write_phy_reg(hw, MII_DBG_DATA, 0xBC00);\n\tif (ret_val)\n\t\treturn ret_val;\n\t \n\tret_val = atl1e_write_phy_reg(hw, MII_DBG_ADDR, 0);\n\tif (ret_val)\n\t\treturn ret_val;\n\tphy_val = 0x02ef;\n\t \n\t \n\tret_val = atl1e_write_phy_reg(hw, MII_DBG_DATA, phy_val);\n\tif (ret_val)\n\t\treturn ret_val;\n\t \n\tret_val = atl1e_write_phy_reg(hw, MII_DBG_ADDR, 0x12);\n\tif (ret_val)\n\t\treturn ret_val;\n\tret_val = atl1e_write_phy_reg(hw, MII_DBG_DATA, 0x4C04);\n\tif (ret_val)\n\t\treturn ret_val;\n\t \n\tret_val = atl1e_write_phy_reg(hw, MII_DBG_ADDR, 0x4);\n\tif (ret_val)\n\t\treturn ret_val;\n\tret_val = atl1e_write_phy_reg(hw, MII_DBG_DATA, 0x8BBB);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tret_val = atl1e_write_phy_reg(hw, MII_DBG_ADDR, 0x5);\n\tif (ret_val)\n\t\treturn ret_val;\n\tret_val = atl1e_write_phy_reg(hw, MII_DBG_DATA, 0x2C46);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tmsleep(1);\n\n\t \n\tret_val = atl1e_write_phy_reg(hw, MII_INT_CTRL, 0xC00);\n\tif (ret_val) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Error enable PHY linkChange Interrupt\\n\");\n\t\treturn ret_val;\n\t}\n\t \n\tret_val = atl1e_phy_setup_autoneg_adv(hw);\n\tif (ret_val) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Error Setting up Auto-Negotiation\\n\");\n\t\treturn ret_val;\n\t}\n\t \n\tnetdev_dbg(adapter->netdev, \"Restarting Auto-Negotiation\\n\");\n\tret_val = atl1e_phy_commit(hw);\n\tif (ret_val) {\n\t\tnetdev_err(adapter->netdev, \"Error resetting the phy\\n\");\n\t\treturn ret_val;\n\t}\n\n\thw->phy_configured = true;\n\n\treturn 0;\n}\n\n \nint atl1e_reset_hw(struct atl1e_hw *hw)\n{\n\tstruct atl1e_adapter *adapter = hw->adapter;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tu32 idle_status_data = 0;\n\tu16 pci_cfg_cmd_word = 0;\n\tint timeout = 0;\n\n\t \n\tpci_read_config_word(pdev, PCI_REG_COMMAND, &pci_cfg_cmd_word);\n\tif ((pci_cfg_cmd_word & (CMD_IO_SPACE |\n\t\t\t\tCMD_MEMORY_SPACE | CMD_BUS_MASTER))\n\t\t\t!= (CMD_IO_SPACE | CMD_MEMORY_SPACE | CMD_BUS_MASTER)) {\n\t\tpci_cfg_cmd_word |= (CMD_IO_SPACE |\n\t\t\t\t     CMD_MEMORY_SPACE | CMD_BUS_MASTER);\n\t\tpci_write_config_word(pdev, PCI_REG_COMMAND, pci_cfg_cmd_word);\n\t}\n\n\t \n\tAT_WRITE_REG(hw, REG_MASTER_CTRL,\n\t\t\tMASTER_CTRL_LED_MODE | MASTER_CTRL_SOFT_RST);\n\twmb();\n\tmsleep(1);\n\n\t \n\tfor (timeout = 0; timeout < AT_HW_MAX_IDLE_DELAY; timeout++) {\n\t\tidle_status_data = AT_READ_REG(hw, REG_IDLE_STATUS);\n\t\tif (idle_status_data == 0)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t\tcpu_relax();\n\t}\n\n\tif (timeout >= AT_HW_MAX_IDLE_DELAY) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"MAC state machine can't be idle since disabled for 10ms second\\n\");\n\t\treturn AT_ERR_TIMEOUT;\n\t}\n\n\treturn 0;\n}\n\n\n \nint atl1e_init_hw(struct atl1e_hw *hw)\n{\n\ts32 ret_val = 0;\n\n\tatl1e_init_pcie(hw);\n\n\t \n\t \n\tAT_WRITE_REG(hw, REG_RX_HASH_TABLE, 0);\n\tAT_WRITE_REG_ARRAY(hw, REG_RX_HASH_TABLE, 1, 0);\n\n\tret_val = atl1e_phy_init(hw);\n\n\treturn ret_val;\n}\n\n \nint atl1e_get_speed_and_duplex(struct atl1e_hw *hw, u16 *speed, u16 *duplex)\n{\n\tint err;\n\tu16 phy_data;\n\n\t \n\terr = atl1e_read_phy_reg(hw, MII_AT001_PSSR, &phy_data);\n\tif (err)\n\t\treturn err;\n\n\tif (!(phy_data & MII_AT001_PSSR_SPD_DPLX_RESOLVED))\n\t\treturn AT_ERR_PHY_RES;\n\n\tswitch (phy_data & MII_AT001_PSSR_SPEED) {\n\tcase MII_AT001_PSSR_1000MBS:\n\t\t*speed = SPEED_1000;\n\t\tbreak;\n\tcase MII_AT001_PSSR_100MBS:\n\t\t*speed = SPEED_100;\n\t\tbreak;\n\tcase MII_AT001_PSSR_10MBS:\n\t\t*speed = SPEED_10;\n\t\tbreak;\n\tdefault:\n\t\treturn AT_ERR_PHY_SPEED;\n\t}\n\n\tif (phy_data & MII_AT001_PSSR_DPLX)\n\t\t*duplex = FULL_DUPLEX;\n\telse\n\t\t*duplex = HALF_DUPLEX;\n\n\treturn 0;\n}\n\nint atl1e_restart_autoneg(struct atl1e_hw *hw)\n{\n\tint err = 0;\n\n\terr = atl1e_write_phy_reg(hw, MII_ADVERTISE, hw->mii_autoneg_adv_reg);\n\tif (err)\n\t\treturn err;\n\n\tif (hw->nic_type == athr_l1e || hw->nic_type == athr_l2e_revA) {\n\t\terr = atl1e_write_phy_reg(hw, MII_CTRL1000,\n\t\t\t\t       hw->mii_1000t_ctrl_reg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = atl1e_write_phy_reg(hw, MII_BMCR,\n\t\t\tBMCR_RESET | BMCR_ANENABLE | BMCR_ANRESTART);\n\treturn err;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}