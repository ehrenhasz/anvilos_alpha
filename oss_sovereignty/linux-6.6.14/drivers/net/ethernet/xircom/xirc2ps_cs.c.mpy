{
  "module_name": "xirc2ps_cs.c",
  "hash_id": "18c10df603e0faed832a1ae3d5d72c2f600d8c7473cc0bec91594d5aec2f8573",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/xircom/xirc2ps_cs.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/ioport.h>\n#include <linux/bitops.h>\n#include <linux/mii.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/ciscode.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#ifndef MANFID_COMPAQ\n  #define MANFID_COMPAQ \t   0x0138\n  #define MANFID_COMPAQ2\t   0x0183   \n#endif\n\n#include <pcmcia/ds.h>\n\n \n#define TX_TIMEOUT\t((400*HZ)/1000)\n\n \n\n \n#define XIRCREG_CR  0\t \nenum xirc_cr {\n    TransmitPacket = 0x01,\n    SoftReset = 0x02,\n    EnableIntr = 0x04,\n    ForceIntr  = 0x08,\n    ClearTxFIFO = 0x10,\n    ClearRxOvrun = 0x20,\n    RestartTx\t = 0x40\n};\n#define XIRCREG_ESR 0\t \nenum xirc_esr {\n    FullPktRcvd = 0x01,  \n    PktRejected = 0x04,  \n    TxPktPend = 0x08,\t \n    IncorPolarity = 0x10,\n    MediaSelect = 0x20\t \n};\n#define XIRCREG_PR  1\t \n#define XIRCREG_EDP 4\t \n#define XIRCREG_ISR 6\t \nenum xirc_isr {\n    TxBufOvr = 0x01,\t \n    PktTxed  = 0x02,\t \n    MACIntr  = 0x04,\t \n    TxResGrant = 0x08,\t \n    RxFullPkt = 0x20,\t \n    RxPktRej  = 0x40,\t \n    ForcedIntr= 0x80\t \n};\n#define XIRCREG1_IMR0 12  \n#define XIRCREG1_IMR1 13\n#define XIRCREG0_TSO  8   \n#define XIRCREG0_TRS  10  \n#define XIRCREG0_DO   12  \n#define XIRCREG0_RSR  12  \nenum xirc_rsr {\n    PhyPkt = 0x01,\t \n    BrdcstPkt = 0x02,\t \n    PktTooLong = 0x04,\t \n    AlignErr = 0x10,\t \n    CRCErr = 0x20,\t \n    PktRxOk = 0x80\t \n};\n#define XIRCREG0_PTR 13  \n#define XIRCREG0_RBC 14  \n#define XIRCREG1_ECR 14  \nenum xirc_ecr {\n    FullDuplex = 0x04,\t \n    LongTPMode = 0x08,\t \n    DisablePolCor = 0x10, \n    DisableLinkPulse = 0x20,  \n    DisableAutoTx = 0x40,  \n};\n#define XIRCREG2_RBS 8\t \n#define XIRCREG2_LED 10  \n \n#define XIRCREG2_MSR 12  \n\n#define XIRCREG4_GPR0 8  \n#define XIRCREG4_GPR1 9  \n#define XIRCREG2_GPR2 13  \n#define XIRCREG4_BOV 10  \n#define XIRCREG4_LMA 12  \n#define XIRCREG4_LMD 14  \n \n#define XIRCREG40_CMD0 8     \nenum xirc_cmd { \t     \n    Transmit = 0x01,\n    EnableRecv = 0x04,\n    DisableRecv = 0x08,\n    Abort = 0x10,\n    Online = 0x20,\n    IntrAck = 0x40,\n    Offline = 0x80\n};\n#define XIRCREG5_RHSA0\t10   \n#define XIRCREG40_RXST0 9    \n#define XIRCREG40_TXST0 11   \n#define XIRCREG40_TXST1 12   \n#define XIRCREG40_RMASK0 13   \n#define XIRCREG40_TMASK0 14   \n#define XIRCREG40_TMASK1 15   \n#define XIRCREG42_SWC0\t8    \n#define XIRCREG42_SWC1\t9    \n#define XIRCREG42_BOC\t10   \n#define XIRCREG44_TDR0\t8    \n#define XIRCREG44_TDR1\t9    \n#define XIRCREG44_RXBC_LO 10  \n#define XIRCREG44_RXBC_HI 11  \n#define XIRCREG45_REV\t 15  \n#define XIRCREG50_IA\t8    \n\nstatic const char *if_names[] = { \"Auto\", \"10BaseT\", \"10Base2\", \"AUI\", \"100BaseT\" };\n\n \n#define XIR_UNKNOWN  0\t \n#define XIR_CE\t     1\t \n#define XIR_CE2      2\t \n#define XIR_CE3      3\t \n#define XIR_CEM      4\t \n#define XIR_CEM2     5\t \n#define XIR_CEM3     6\t \n#define XIR_CEM33    7\t \n#define XIR_CEM56M   8\t \n#define XIR_CEM56    9\t \n#define XIR_CM28    10\t \n#define XIR_CM33    11\t \n#define XIR_CM56    12\t \n#define XIR_CG\t    13\t \n#define XIR_CBE     14\t \n \n\n \n\nMODULE_DESCRIPTION(\"Xircom PCMCIA ethernet driver\");\nMODULE_LICENSE(\"Dual MPL/GPL\");\n\n#define INT_MODULE_PARM(n, v) static int n = v; module_param(n, int, 0)\n\nINT_MODULE_PARM(if_port,\t0);\nINT_MODULE_PARM(full_duplex,\t0);\nINT_MODULE_PARM(do_sound, \t1);\nINT_MODULE_PARM(lockup_hack,\t0);   \n\n \n\n \nstatic unsigned maxrx_bytes = 22000;\n\n \nstatic void mii_idle(unsigned int ioaddr);\nstatic void mii_putbit(unsigned int ioaddr, unsigned data);\nstatic int  mii_getbit(unsigned int ioaddr);\nstatic void mii_wbits(unsigned int ioaddr, unsigned data, int len);\nstatic unsigned mii_rd(unsigned int ioaddr, u_char phyaddr, u_char phyreg);\nstatic void mii_wr(unsigned int ioaddr, u_char phyaddr, u_char phyreg,\n\t\t   unsigned data, int len);\n\nstatic int has_ce2_string(struct pcmcia_device * link);\nstatic int xirc2ps_config(struct pcmcia_device * link);\nstatic void xirc2ps_release(struct pcmcia_device * link);\nstatic void xirc2ps_detach(struct pcmcia_device *p_dev);\n\nstatic irqreturn_t xirc2ps_interrupt(int irq, void *dev_id);\n\nstruct local_info {\n\tstruct net_device\t*dev;\n\tstruct pcmcia_device\t*p_dev;\n\n    int card_type;\n    int probe_port;\n    int silicon;  \n    int mohawk;   \n    int dingo;\t  \n    int new_mii;  \n    int modem;\t  \n    void __iomem *dingo_ccr;  \n    unsigned last_ptr_value;  \n    const char *manf_str;\n    struct work_struct tx_timeout_task;\n};\n\n \nstatic netdev_tx_t do_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev);\nstatic void xirc_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic void xirc2ps_tx_timeout_task(struct work_struct *work);\nstatic void set_addresses(struct net_device *dev);\nstatic void set_multicast_list(struct net_device *dev);\nstatic int set_card_type(struct pcmcia_device *link);\nstatic int do_config(struct net_device *dev, struct ifmap *map);\nstatic int do_open(struct net_device *dev);\nstatic int do_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic const struct ethtool_ops netdev_ethtool_ops;\nstatic void hardreset(struct net_device *dev);\nstatic void do_reset(struct net_device *dev, int full);\nstatic int init_mii(struct net_device *dev);\nstatic void do_powerdown(struct net_device *dev);\nstatic int do_stop(struct net_device *dev);\n\n \n#define SelectPage(pgnr)   outb((pgnr), ioaddr + XIRCREG_PR)\n#define GetByte(reg)\t   ((unsigned)inb(ioaddr + (reg)))\n#define GetWord(reg)\t   ((unsigned)inw(ioaddr + (reg)))\n#define PutByte(reg,value) outb((value), ioaddr+(reg))\n#define PutWord(reg,value) outw((value), ioaddr+(reg))\n\n \n#if 0  \nstatic void\nPrintRegisters(struct net_device *dev)\n{\n    unsigned int ioaddr = dev->base_addr;\n\n    if (pc_debug > 1) {\n\tint i, page;\n\n\tprintk(KERN_DEBUG pr_fmt(\"Register  common: \"));\n\tfor (i = 0; i < 8; i++)\n\t    pr_cont(\" %2.2x\", GetByte(i));\n\tpr_cont(\"\\n\");\n\tfor (page = 0; page <= 8; page++) {\n\t    printk(KERN_DEBUG pr_fmt(\"Register page %2x: \"), page);\n\t    SelectPage(page);\n\t    for (i = 8; i < 16; i++)\n\t\tpr_cont(\" %2.2x\", GetByte(i));\n\t    pr_cont(\"\\n\");\n\t}\n\tfor (page=0x40 ; page <= 0x5f; page++) {\n\t\tif (page == 0x43 || (page >= 0x46 && page <= 0x4f) ||\n\t\t    (page >= 0x51 && page <=0x5e))\n\t\t\tcontinue;\n\t    printk(KERN_DEBUG pr_fmt(\"Register page %2x: \"), page);\n\t    SelectPage(page);\n\t    for (i = 8; i < 16; i++)\n\t\tpr_cont(\" %2.2x\", GetByte(i));\n\t    pr_cont(\"\\n\");\n\t}\n    }\n}\n#endif  \n\n \n\n \nstatic void\nmii_idle(unsigned int ioaddr)\n{\n    PutByte(XIRCREG2_GPR2, 0x04|0);  \n    udelay(1);\n    PutByte(XIRCREG2_GPR2, 0x04|1);  \n    udelay(1);\n}\n\n \nstatic void\nmii_putbit(unsigned int ioaddr, unsigned data)\n{\n  #if 1\n    if (data) {\n\tPutByte(XIRCREG2_GPR2, 0x0c|2|0);  \n\tudelay(1);\n\tPutByte(XIRCREG2_GPR2, 0x0c|2|1);  \n\tudelay(1);\n    } else {\n\tPutByte(XIRCREG2_GPR2, 0x0c|0|0);  \n\tudelay(1);\n\tPutByte(XIRCREG2_GPR2, 0x0c|0|1);  \n\tudelay(1);\n    }\n  #else\n    if (data) {\n\tPutWord(XIRCREG2_GPR2-1, 0x0e0e);\n\tudelay(1);\n\tPutWord(XIRCREG2_GPR2-1, 0x0f0f);\n\tudelay(1);\n    } else {\n\tPutWord(XIRCREG2_GPR2-1, 0x0c0c);\n\tudelay(1);\n\tPutWord(XIRCREG2_GPR2-1, 0x0d0d);\n\tudelay(1);\n    }\n  #endif\n}\n\n \nstatic int\nmii_getbit(unsigned int ioaddr)\n{\n    unsigned d;\n\n    PutByte(XIRCREG2_GPR2, 4|0);  \n    udelay(1);\n    d = GetByte(XIRCREG2_GPR2);  \n    PutByte(XIRCREG2_GPR2, 4|1);  \n    udelay(1);\n    return d & 0x20;  \n}\n\nstatic void\nmii_wbits(unsigned int ioaddr, unsigned data, int len)\n{\n    unsigned m = 1 << (len-1);\n    for (; m; m >>= 1)\n\tmii_putbit(ioaddr, data & m);\n}\n\nstatic unsigned\nmii_rd(unsigned int ioaddr,\tu_char phyaddr, u_char phyreg)\n{\n    int i;\n    unsigned data=0, m;\n\n    SelectPage(2);\n    for (i=0; i < 32; i++)\t\t \n\tmii_putbit(ioaddr, 1);\n    mii_wbits(ioaddr, 0x06, 4); \t \n    mii_wbits(ioaddr, phyaddr, 5);\t \n    mii_wbits(ioaddr, phyreg, 5);\t \n    mii_idle(ioaddr);\t\t\t \n    mii_getbit(ioaddr);\n\n    for (m = 1<<15; m; m >>= 1)\n\tif (mii_getbit(ioaddr))\n\t    data |= m;\n    mii_idle(ioaddr);\n    return data;\n}\n\nstatic void\nmii_wr(unsigned int ioaddr, u_char phyaddr, u_char phyreg, unsigned data,\n       int len)\n{\n    int i;\n\n    SelectPage(2);\n    for (i=0; i < 32; i++)\t\t \n\tmii_putbit(ioaddr, 1);\n    mii_wbits(ioaddr, 0x05, 4); \t \n    mii_wbits(ioaddr, phyaddr, 5);\t \n    mii_wbits(ioaddr, phyreg, 5);\t \n    mii_putbit(ioaddr, 1);\t\t \n    mii_putbit(ioaddr, 0);\n    mii_wbits(ioaddr, data, len);\t \n    mii_idle(ioaddr);\n}\n\n \n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open\t\t= do_open,\n\t.ndo_stop\t\t= do_stop,\n\t.ndo_start_xmit\t\t= do_start_xmit,\n\t.ndo_tx_timeout \t= xirc_tx_timeout,\n\t.ndo_set_config\t\t= do_config,\n\t.ndo_eth_ioctl\t\t= do_ioctl,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int\nxirc2ps_probe(struct pcmcia_device *link)\n{\n    struct net_device *dev;\n    struct local_info *local;\n\n    dev_dbg(&link->dev, \"attach()\\n\");\n\n     \n    dev = alloc_etherdev(sizeof(struct local_info));\n    if (!dev)\n\t    return -ENOMEM;\n    local = netdev_priv(dev);\n    local->dev = dev;\n    local->p_dev = link;\n    link->priv = dev;\n\n     \n    link->config_index = 1;\n\n     \n    dev->netdev_ops = &netdev_ops;\n    dev->ethtool_ops = &netdev_ethtool_ops;\n    dev->watchdog_timeo = TX_TIMEOUT;\n    INIT_WORK(&local->tx_timeout_task, xirc2ps_tx_timeout_task);\n\n    return xirc2ps_config(link);\n}  \n\nstatic void\nxirc2ps_detach(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    struct local_info *local = netdev_priv(dev);\n\n    netif_carrier_off(dev);\n    netif_tx_disable(dev);\n    cancel_work_sync(&local->tx_timeout_task);\n\n    dev_dbg(&link->dev, \"detach\\n\");\n\n    unregister_netdev(dev);\n\n    xirc2ps_release(link);\n\n    free_netdev(dev);\n}  \n\n \nstatic int\nset_card_type(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    struct local_info *local = netdev_priv(dev);\n    u8 *buf;\n    unsigned int cisrev, mediaid, prodid;\n    size_t len;\n\n    len = pcmcia_get_tuple(link, CISTPL_MANFID, &buf);\n    if (len < 5) {\n\t    dev_err(&link->dev, \"invalid CIS -- sorry\\n\");\n\t    return 0;\n    }\n\n    cisrev = buf[2];\n    mediaid = buf[3];\n    prodid = buf[4];\n\n    dev_dbg(&link->dev, \"cisrev=%02x mediaid=%02x prodid=%02x\\n\",\n\t  cisrev, mediaid, prodid);\n\n    local->mohawk = 0;\n    local->dingo = 0;\n    local->modem = 0;\n    local->card_type = XIR_UNKNOWN;\n    if (!(prodid & 0x40)) {\n\tpr_notice(\"Oops: Not a creditcard\\n\");\n\treturn 0;\n    }\n    if (!(mediaid & 0x01)) {\n\tpr_notice(\"Not an Ethernet card\\n\");\n\treturn 0;\n    }\n    if (mediaid & 0x10) {\n\tlocal->modem = 1;\n\tswitch(prodid & 15) {\n\t  case 1: local->card_type = XIR_CEM   ; break;\n\t  case 2: local->card_type = XIR_CEM2  ; break;\n\t  case 3: local->card_type = XIR_CEM3  ; break;\n\t  case 4: local->card_type = XIR_CEM33 ; break;\n\t  case 5: local->card_type = XIR_CEM56M;\n\t\t  local->mohawk = 1;\n\t\t  break;\n\t  case 6:\n\t  case 7:  \n\t\t  local->card_type = XIR_CEM56 ;\n\t\t  local->mohawk = 1;\n\t\t  local->dingo = 1;\n\t\t  break;\n\t}\n    } else {\n\tswitch(prodid & 15) {\n\t  case 1: local->card_type = has_ce2_string(link)? XIR_CE2 : XIR_CE ;\n\t\t  break;\n\t  case 2: local->card_type = XIR_CE2; break;\n\t  case 3: local->card_type = XIR_CE3;\n\t\t  local->mohawk = 1;\n\t\t  break;\n\t}\n    }\n    if (local->card_type == XIR_CE || local->card_type == XIR_CEM) {\n\tpr_notice(\"Sorry, this is an old CE card\\n\");\n\treturn 0;\n    }\n    if (local->card_type == XIR_UNKNOWN)\n\tpr_notice(\"unknown card (mediaid=%02x prodid=%02x)\\n\", mediaid, prodid);\n\n    return 1;\n}\n\n \nstatic int\nhas_ce2_string(struct pcmcia_device * p_dev)\n{\n\tif (p_dev->prod_id[2] && strstr(p_dev->prod_id[2], \"CE2\"))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int\nxirc2ps_config_modem(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tunsigned int ioaddr;\n\n\tif ((p_dev->resource[0]->start & 0xf) == 8)\n\t\treturn -ENODEV;\n\n\tp_dev->resource[0]->end = 16;\n\tp_dev->resource[1]->end = 8;\n\tp_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_16;\n\tp_dev->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\n\tp_dev->io_lines = 10;\n\n\tp_dev->resource[1]->start = p_dev->resource[0]->start;\n\tfor (ioaddr = 0x300; ioaddr < 0x400; ioaddr += 0x10) {\n\t\tp_dev->resource[0]->start = ioaddr;\n\t\tif (!pcmcia_request_io(p_dev))\n\t\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic int\nxirc2ps_config_check(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tint *pass = priv_data;\n\tresource_size_t tmp = p_dev->resource[1]->start;\n\n\ttmp += (*pass ? (p_dev->config_index & 0x20 ? -24 : 8)\n\t\t: (p_dev->config_index & 0x20 ?   8 : -24));\n\n\tif ((p_dev->resource[0]->start & 0xf) == 8)\n\t\treturn -ENODEV;\n\n\tp_dev->resource[0]->end = 18;\n\tp_dev->resource[1]->end = 8;\n\tp_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_16;\n\tp_dev->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\n\tp_dev->io_lines = 10;\n\n\tp_dev->resource[1]->start = p_dev->resource[0]->start;\n\tp_dev->resource[0]->start = tmp;\n\treturn pcmcia_request_io(p_dev);\n}\n\n\nstatic int pcmcia_get_mac_ce(struct pcmcia_device *p_dev,\n\t\t\t     tuple_t *tuple,\n\t\t\t     void *priv)\n{\n\tstruct net_device *dev = priv;\n\n\tif (tuple->TupleDataLen != 13)\n\t\treturn -EINVAL;\n\tif ((tuple->TupleData[0] != 2) || (tuple->TupleData[1] != 1) ||\n\t\t(tuple->TupleData[2] != 6))\n\t\treturn -EINVAL;\n\t \n\tdev_addr_mod(dev, 2, &tuple->TupleData[2], 4);\n\treturn 0;\n};\n\n\nstatic int\nxirc2ps_config(struct pcmcia_device * link)\n{\n    struct net_device *dev = link->priv;\n    struct local_info *local = netdev_priv(dev);\n    unsigned int ioaddr;\n    int err;\n    u8 *buf;\n    size_t len;\n\n    local->dingo_ccr = NULL;\n\n    dev_dbg(&link->dev, \"config\\n\");\n\n     \n    if (link->has_manf_id == 0) {\n\tpr_notice(\"manfid not found in CIS\\n\");\n\tgoto failure;\n    }\n\n    switch (link->manf_id) {\n      case MANFID_XIRCOM:\n\tlocal->manf_str = \"Xircom\";\n\tbreak;\n      case MANFID_ACCTON:\n\tlocal->manf_str = \"Accton\";\n\tbreak;\n      case MANFID_COMPAQ:\n      case MANFID_COMPAQ2:\n\tlocal->manf_str = \"Compaq\";\n\tbreak;\n      case MANFID_INTEL:\n\tlocal->manf_str = \"Intel\";\n\tbreak;\n      case MANFID_TOSHIBA:\n\tlocal->manf_str = \"Toshiba\";\n\tbreak;\n      default:\n\tpr_notice(\"Unknown Card Manufacturer ID: 0x%04x\\n\",\n\t\t  (unsigned)link->manf_id);\n\tgoto failure;\n    }\n    dev_dbg(&link->dev, \"found %s card\\n\", local->manf_str);\n\n    if (!set_card_type(link)) {\n\tpr_notice(\"this card is not supported\\n\");\n\tgoto failure;\n    }\n\n     \n    err = pcmcia_get_mac_from_cis(link, dev);\n\n     \n    if (err) {\n\t    len = pcmcia_get_tuple(link, 0x89, &buf);\n\t     \n\t    if (buf && len == 8) {\n\t\t    if (*buf == CISTPL_FUNCE_LAN_NODE_ID)\n\t\t\t    dev_addr_mod(dev, 2, &buf[2], 4);\n\t\t    else\n\t\t\t    err = -1;\n\t    }\n\t    kfree(buf);\n    }\n\n    if (err)\n\terr = pcmcia_loop_tuple(link, CISTPL_FUNCE, pcmcia_get_mac_ce, dev);\n\n    if (err) {\n\tpr_notice(\"node-id not found in CIS\\n\");\n\tgoto failure;\n    }\n\n    if (local->modem) {\n\tint pass;\n\tlink->config_flags |= CONF_AUTO_SET_IO;\n\n\tif (local->dingo) {\n\t     \n\t    if (!pcmcia_loop_config(link, xirc2ps_config_modem, NULL))\n\t\t    goto port_found;\n\t} else {\n\t     \n\t    for (pass=0; pass < 2; pass++)\n\t\t    if (!pcmcia_loop_config(link, xirc2ps_config_check,\n\t\t\t\t\t\t    &pass))\n\t\t\t    goto port_found;\n\t     \n\t}\n\tpr_notice(\"no ports available\\n\");\n    } else {\n\tlink->io_lines = 10;\n\tlink->resource[0]->end = 16;\n\tlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_16;\n\tfor (ioaddr = 0x300; ioaddr < 0x400; ioaddr += 0x10) {\n\t    link->resource[0]->start = ioaddr;\n\t    if (!(err = pcmcia_request_io(link)))\n\t\tgoto port_found;\n\t}\n\tlink->resource[0]->start = 0;  \n\tif ((err = pcmcia_request_io(link)))\n\t    goto config_error;\n    }\n  port_found:\n\n     \n    if ((err=pcmcia_request_irq(link, xirc2ps_interrupt)))\n\tgoto config_error;\n\n    link->config_flags |= CONF_ENABLE_IRQ;\n    if (do_sound)\n\t    link->config_flags |= CONF_ENABLE_SPKR;\n\n    if ((err = pcmcia_enable_device(link)))\n\tgoto config_error;\n\n    if (local->dingo) {\n\t \n\terr = pcmcia_write_config_byte(link, CISREG_IOBASE_0, (u8)\n\t\t\t\tlink->resource[1]->start & 0xff);\n\tif (err)\n\t    goto config_error;\n\n\terr = pcmcia_write_config_byte(link, CISREG_IOBASE_1,\n\t\t\t\t(link->resource[1]->start >> 8) & 0xff);\n\tif (err)\n\t    goto config_error;\n\n\t \n\tlink->resource[2]->flags = WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_AM |\n\t\t\t\t\tWIN_ENABLE;\n\tlink->resource[2]->start = link->resource[2]->end = 0;\n\tif ((err = pcmcia_request_window(link, link->resource[2], 0)))\n\t    goto config_error;\n\n\tlocal->dingo_ccr = ioremap(link->resource[2]->start, 0x1000) + 0x0800;\n\tif ((err = pcmcia_map_mem_page(link, link->resource[2], 0)))\n\t    goto config_error;\n\n\t \n\twriteb(0x47, local->dingo_ccr + CISREG_COR);\n\tioaddr = link->resource[0]->start;\n\twriteb(ioaddr & 0xff\t  , local->dingo_ccr + CISREG_IOBASE_0);\n\twriteb((ioaddr >> 8)&0xff , local->dingo_ccr + CISREG_IOBASE_1);\n\n      #if 0\n\t{\n\t    u_char tmp;\n\t    pr_info(\"ECOR:\");\n\t    for (i=0; i < 7; i++) {\n\t\ttmp = readb(local->dingo_ccr + i*2);\n\t\tpr_cont(\" %02x\", tmp);\n\t    }\n\t    pr_cont(\"\\n\");\n\t    pr_info(\"DCOR:\");\n\t    for (i=0; i < 4; i++) {\n\t\ttmp = readb(local->dingo_ccr + 0x20 + i*2);\n\t\tpr_cont(\" %02x\", tmp);\n\t    }\n\t    pr_cont(\"\\n\");\n\t    pr_info(\"SCOR:\");\n\t    for (i=0; i < 10; i++) {\n\t\ttmp = readb(local->dingo_ccr + 0x40 + i*2);\n\t\tpr_cont(\" %02x\", tmp);\n\t    }\n\t    pr_cont(\"\\n\");\n\t}\n      #endif\n\n\twriteb(0x01, local->dingo_ccr + 0x20);\n\twriteb(0x0c, local->dingo_ccr + 0x22);\n\twriteb(0x00, local->dingo_ccr + 0x24);\n\twriteb(0x00, local->dingo_ccr + 0x26);\n\twriteb(0x00, local->dingo_ccr + 0x28);\n    }\n\n     \n    local->probe_port=0;\n    if (!if_port) {\n\tlocal->probe_port = dev->if_port = 1;\n    } else if ((if_port >= 1 && if_port <= 2) ||\n\t       (local->mohawk && if_port==4))\n\tdev->if_port = if_port;\n    else\n\tpr_notice(\"invalid if_port requested\\n\");\n\n     \n    dev->irq = link->irq;\n    dev->base_addr = link->resource[0]->start;\n\n    if (local->dingo)\n\tdo_reset(dev, 1);  \n\n    SET_NETDEV_DEV(dev, &link->dev);\n\n    if ((err=register_netdev(dev))) {\n\tpr_notice(\"register_netdev() failed\\n\");\n\tgoto config_error;\n    }\n\n     \n    netdev_info(dev, \"%s: port %#3lx, irq %d, hwaddr %pM\\n\",\n\t\tlocal->manf_str, (u_long)dev->base_addr, (int)dev->irq,\n\t\tdev->dev_addr);\n\n    return 0;\n\n  config_error:\n    xirc2ps_release(link);\n    return -ENODEV;\n\n  failure:\n    return -ENODEV;\n}  \n\nstatic void\nxirc2ps_release(struct pcmcia_device *link)\n{\n\tdev_dbg(&link->dev, \"release\\n\");\n\n\tif (link->resource[2]->end) {\n\t\tstruct net_device *dev = link->priv;\n\t\tstruct local_info *local = netdev_priv(dev);\n\t\tif (local->dingo)\n\t\t\tiounmap(local->dingo_ccr - 0x0800);\n\t}\n\tpcmcia_disable_device(link);\n}  \n\n \n\n\nstatic int xirc2ps_suspend(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open) {\n\t\tnetif_device_detach(dev);\n\t\tdo_powerdown(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int xirc2ps_resume(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open) {\n\t\tdo_reset(dev,1);\n\t\tnetif_device_attach(dev);\n\t}\n\n\treturn 0;\n}\n\n\n \n\n \nstatic irqreturn_t\nxirc2ps_interrupt(int irq, void *dev_id)\n{\n    struct net_device *dev = (struct net_device *)dev_id;\n    struct local_info *lp = netdev_priv(dev);\n    unsigned int ioaddr;\n    u_char saved_page;\n    unsigned bytes_rcvd;\n    unsigned int_status, eth_status, rx_status, tx_status;\n    unsigned rsr, pktlen;\n    ulong start_ticks = jiffies;  \n\n    if (!netif_device_present(dev))\n\treturn IRQ_HANDLED;\n\n    ioaddr = dev->base_addr;\n    if (lp->mohawk) {  \n\tPutByte(XIRCREG_CR, 0);\n    }\n\n    pr_debug(\"%s: interrupt %d at %#x.\\n\", dev->name, irq, ioaddr);\n\n    saved_page = GetByte(XIRCREG_PR);\n     \n    int_status = GetByte(XIRCREG_ISR);\n    bytes_rcvd = 0;\n  loop_entry:\n    if (int_status == 0xff) {  \n\tpr_debug(\"%s: interrupt %d for dead card\\n\", dev->name, irq);\n\tgoto leave;\n    }\n    eth_status = GetByte(XIRCREG_ESR);\n\n    SelectPage(0x40);\n    rx_status  = GetByte(XIRCREG40_RXST0);\n    PutByte(XIRCREG40_RXST0, (~rx_status & 0xff));\n    tx_status = GetByte(XIRCREG40_TXST0);\n    tx_status |= GetByte(XIRCREG40_TXST1) << 8;\n    PutByte(XIRCREG40_TXST0, 0);\n    PutByte(XIRCREG40_TXST1, 0);\n\n    pr_debug(\"%s: ISR=%#2.2x ESR=%#2.2x RSR=%#2.2x TSR=%#4.4x\\n\",\n\t  dev->name, int_status, eth_status, rx_status, tx_status);\n\n     \n    SelectPage(0);\n    while (eth_status & FullPktRcvd) {\n\trsr = GetByte(XIRCREG0_RSR);\n\tif (bytes_rcvd > maxrx_bytes && (rsr & PktRxOk)) {\n\t     \n\t    dev->stats.rx_dropped++;\n\t    pr_debug(\"%s: RX drop, too much done\\n\", dev->name);\n\t} else if (rsr & PktRxOk) {\n\t    struct sk_buff *skb;\n\n\t    pktlen = GetWord(XIRCREG0_RBC);\n\t    bytes_rcvd += pktlen;\n\n\t    pr_debug(\"rsr=%#02x packet_length=%u\\n\", rsr, pktlen);\n\n\t     \n\t    skb = netdev_alloc_skb(dev, pktlen + 3);\n\t    if (!skb) {\n\t\tdev->stats.rx_dropped++;\n\t    } else {  \n\t\tskb_reserve(skb, 2);\n\t\tif (lp->silicon == 0 ) {  \n\t\t    unsigned rhsa;  \n\n\t\t    SelectPage(5);\n\t\t    rhsa = GetWord(XIRCREG5_RHSA0);\n\t\t    SelectPage(0);\n\t\t    rhsa += 3;  \n\t\t    if (rhsa >= 0x8000)\n\t\t\trhsa = 0;\n\t\t    if (rhsa + pktlen > 0x8000) {\n\t\t\tunsigned i;\n\t\t\tu_char *buf = skb_put(skb, pktlen);\n\t\t\tfor (i=0; i < pktlen ; i++, rhsa++) {\n\t\t\t    buf[i] = GetByte(XIRCREG_EDP);\n\t\t\t    if (rhsa == 0x8000) {\n\t\t\t\trhsa = 0;\n\t\t\t\ti--;\n\t\t\t    }\n\t\t\t}\n\t\t    } else {\n\t\t\tinsw(ioaddr+XIRCREG_EDP,\n\t\t\t\tskb_put(skb, pktlen), (pktlen+1)>>1);\n\t\t    }\n\t\t}\n\t      #if 0\n\t\telse if (lp->mohawk) {\n\t\t     \n\t\t    unsigned i;\n\t\t    u_long *p = skb_put(skb, pktlen);\n\t\t    register u_long a;\n\t\t    unsigned int edpreg = ioaddr+XIRCREG_EDP-2;\n\t\t    for (i=0; i < len ; i += 4, p++) {\n\t\t\ta = inl(edpreg);\n\t\t\t__asm__(\"rorl $16,%0\\n\\t\"\n\t\t\t\t:\"=q\" (a)\n\t\t\t\t: \"0\" (a));\n\t\t\t*p = a;\n\t\t    }\n\t\t}\n\t      #endif\n\t\telse {\n\t\t    insw(ioaddr+XIRCREG_EDP, skb_put(skb, pktlen),\n\t\t\t    (pktlen+1)>>1);\n\t\t}\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tnetif_rx(skb);\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += pktlen;\n\t\tif (!(rsr & PhyPkt))\n\t\t    dev->stats.multicast++;\n\t    }\n\t} else {  \n\t    pr_debug(\"rsr=%#02x\\n\", rsr);\n\t}\n\tif (rsr & PktTooLong) {\n\t    dev->stats.rx_frame_errors++;\n\t    pr_debug(\"%s: Packet too long\\n\", dev->name);\n\t}\n\tif (rsr & CRCErr) {\n\t    dev->stats.rx_crc_errors++;\n\t    pr_debug(\"%s: CRC error\\n\", dev->name);\n\t}\n\tif (rsr & AlignErr) {\n\t    dev->stats.rx_fifo_errors++;  \n\t    pr_debug(\"%s: Alignment error\\n\", dev->name);\n\t}\n\n\t \n\tPutWord(XIRCREG0_DO, 0x8000);  \n\n\t \n\teth_status = GetByte(XIRCREG_ESR);\n    }\n    if (rx_status & 0x10) {  \n\tdev->stats.rx_over_errors++;\n\tPutByte(XIRCREG_CR, ClearRxOvrun);\n\tpr_debug(\"receive overrun cleared\\n\");\n    }\n\n     \n    if (int_status & PktTxed) {\n\tunsigned n, nn;\n\n\tn = lp->last_ptr_value;\n\tnn = GetByte(XIRCREG0_PTR);\n\tlp->last_ptr_value = nn;\n\tif (nn < n)  \n\t    dev->stats.tx_packets += 256 - n;\n\telse if (n == nn) {  \n\t    pr_debug(\"PTR not changed?\\n\");\n\t} else\n\t    dev->stats.tx_packets += lp->last_ptr_value - n;\n\tnetif_wake_queue(dev);\n    }\n    if (tx_status & 0x0002) {\t \n\tpr_debug(\"tx restarted due to excessive collisions\\n\");\n\tPutByte(XIRCREG_CR, RestartTx);   \n    }\n    if (tx_status & 0x0040)\n\tdev->stats.tx_aborted_errors++;\n\n     \n    if (bytes_rcvd > 1000) {\n\tu_long duration = jiffies - start_ticks;\n\n\tif (duration >= HZ/10) {  \n\t    maxrx_bytes = (bytes_rcvd * (HZ/10)) / duration;\n\t    if (maxrx_bytes < 2000)\n\t\tmaxrx_bytes = 2000;\n\t    else if (maxrx_bytes > 22000)\n\t\tmaxrx_bytes = 22000;\n\t    pr_debug(\"set maxrx=%u (rcvd=%u ticks=%lu)\\n\",\n\t\t  maxrx_bytes, bytes_rcvd, duration);\n\t} else if (!duration && maxrx_bytes < 22000) {\n\t     \n\t    maxrx_bytes += 2000;\n\t    if (maxrx_bytes > 22000)\n\t\tmaxrx_bytes = 22000;\n\t    pr_debug(\"set maxrx=%u\\n\", maxrx_bytes);\n\t}\n    }\n\n  leave:\n    if (lockup_hack) {\n\tif (int_status != 0xff && (int_status = GetByte(XIRCREG_ISR)) != 0)\n\t    goto loop_entry;\n    }\n    SelectPage(saved_page);\n    PutByte(XIRCREG_CR, EnableIntr);   \n     \n    return IRQ_HANDLED;\n}  \n\n \n\nstatic void\nxirc2ps_tx_timeout_task(struct work_struct *work)\n{\n\tstruct local_info *local =\n\t\tcontainer_of(work, struct local_info, tx_timeout_task);\n\tstruct net_device *dev = local->dev;\n     \n    do_reset(dev,1);\n    netif_trans_update(dev);  \n    netif_wake_queue(dev);\n}\n\nstatic void\nxirc_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n    struct local_info *lp = netdev_priv(dev);\n    dev->stats.tx_errors++;\n    netdev_notice(dev, \"transmit timed out\\n\");\n    schedule_work(&lp->tx_timeout_task);\n}\n\nstatic netdev_tx_t\ndo_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n    struct local_info *lp = netdev_priv(dev);\n    unsigned int ioaddr = dev->base_addr;\n    int okay;\n    unsigned freespace;\n    unsigned pktlen = skb->len;\n\n    pr_debug(\"do_start_xmit(skb=%p, dev=%p) len=%u\\n\",\n\t  skb, dev, pktlen);\n\n\n     \n    if (pktlen < ETH_ZLEN)\n    {\n        if (skb_padto(skb, ETH_ZLEN))\n\t\treturn NETDEV_TX_OK;\n\tpktlen = ETH_ZLEN;\n    }\n\n    netif_stop_queue(dev);\n    SelectPage(0);\n    PutWord(XIRCREG0_TRS, (u_short)pktlen+2);\n    freespace = GetWord(XIRCREG0_TSO);\n    okay = freespace & 0x8000;\n    freespace &= 0x7fff;\n     \n    okay = pktlen +2 < freespace;\n    pr_debug(\"%s: avail. tx space=%u%s\\n\",\n\t  dev->name, freespace, okay ? \" (okay)\":\" (not enough)\");\n    if (!okay) {  \n\treturn NETDEV_TX_BUSY;   \n    }\n     \n    PutWord(XIRCREG_EDP, (u_short)pktlen);\n    outsw(ioaddr+XIRCREG_EDP, skb->data, pktlen>>1);\n    if (pktlen & 1)\n\tPutByte(XIRCREG_EDP, skb->data[pktlen-1]);\n\n    if (lp->mohawk)\n\tPutByte(XIRCREG_CR, TransmitPacket|EnableIntr);\n\n    dev_kfree_skb (skb);\n    dev->stats.tx_bytes += pktlen;\n    netif_start_queue(dev);\n    return NETDEV_TX_OK;\n}\n\nstruct set_address_info {\n\tint reg_nr;\n\tint page_nr;\n\tint mohawk;\n\tunsigned int ioaddr;\n};\n\nstatic void set_address(struct set_address_info *sa_info, const char *addr)\n{\n\tunsigned int ioaddr = sa_info->ioaddr;\n\tint i;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (sa_info->reg_nr > 15) {\n\t\t\tsa_info->reg_nr = 8;\n\t\t\tsa_info->page_nr++;\n\t\t\tSelectPage(sa_info->page_nr);\n\t\t}\n\t\tif (sa_info->mohawk)\n\t\t\tPutByte(sa_info->reg_nr++, addr[5 - i]);\n\t\telse\n\t\t\tPutByte(sa_info->reg_nr++, addr[i]);\n\t}\n}\n\n \nstatic void set_addresses(struct net_device *dev)\n{\n\tunsigned int ioaddr = dev->base_addr;\n\tstruct local_info *lp = netdev_priv(dev);\n\tstruct netdev_hw_addr *ha;\n\tstruct set_address_info sa_info;\n\tint i;\n\n\t \n\tsa_info.reg_nr = 15 + 1;\n\tsa_info.page_nr = 0x50 - 1;\n\tsa_info.mohawk = lp->mohawk;\n\tsa_info.ioaddr = ioaddr;\n\n\tset_address(&sa_info, dev->dev_addr);\n\ti = 0;\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tif (i++ == 9)\n\t\t\tbreak;\n\t\tset_address(&sa_info, ha->addr);\n\t}\n\twhile (i++ < 9)\n\t\tset_address(&sa_info, dev->dev_addr);\n\tSelectPage(0);\n}\n\n \n\nstatic void\nset_multicast_list(struct net_device *dev)\n{\n    unsigned int ioaddr = dev->base_addr;\n    unsigned value;\n\n    SelectPage(0x42);\n    value = GetByte(XIRCREG42_SWC1) & 0xC0;\n\n    if (dev->flags & IFF_PROMISC) {  \n\tPutByte(XIRCREG42_SWC1, value | 0x06);  \n    } else if (netdev_mc_count(dev) > 9 || (dev->flags & IFF_ALLMULTI)) {\n\tPutByte(XIRCREG42_SWC1, value | 0x02);  \n    } else if (!netdev_mc_empty(dev)) {\n\t \n\tPutByte(XIRCREG42_SWC1, value | 0x01);\n\tSelectPage(0x40);\n\tPutByte(XIRCREG40_CMD0, Offline);\n\tset_addresses(dev);\n\tSelectPage(0x40);\n\tPutByte(XIRCREG40_CMD0, EnableRecv | Online);\n    } else {  \n\tPutByte(XIRCREG42_SWC1, value | 0x00);\n    }\n    SelectPage(0);\n}\n\nstatic int\ndo_config(struct net_device *dev, struct ifmap *map)\n{\n    struct local_info *local = netdev_priv(dev);\n\n    pr_debug(\"do_config(%p)\\n\", dev);\n    if (map->port != 255 && map->port != dev->if_port) {\n\tif (map->port > 4)\n\t    return -EINVAL;\n\tif (!map->port) {\n\t    local->probe_port = 1;\n\t    dev->if_port = 1;\n\t} else {\n\t    local->probe_port = 0;\n\t    dev->if_port = map->port;\n\t}\n\tnetdev_info(dev, \"switching to %s port\\n\", if_names[dev->if_port]);\n\tdo_reset(dev,1);   \n    }\n    return 0;\n}\n\n \nstatic int\ndo_open(struct net_device *dev)\n{\n    struct local_info *lp = netdev_priv(dev);\n    struct pcmcia_device *link = lp->p_dev;\n\n    dev_dbg(&link->dev, \"do_open(%p)\\n\", dev);\n\n     \n     \n    if (!pcmcia_dev_present(link))\n\treturn -ENODEV;\n\n     \n    link->open++;\n\n    netif_start_queue(dev);\n    do_reset(dev,1);\n\n    return 0;\n}\n\nstatic void netdev_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, \"xirc2ps_cs\", sizeof(info->driver));\n\tsnprintf(info->bus_info, sizeof(info->bus_info), \"PCMCIA 0x%lx\",\n\t\t dev->base_addr);\n}\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.get_drvinfo\t\t= netdev_get_drvinfo,\n};\n\nstatic int\ndo_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n    struct local_info *local = netdev_priv(dev);\n    unsigned int ioaddr = dev->base_addr;\n    struct mii_ioctl_data *data = if_mii(rq);\n\n    pr_debug(\"%s: ioctl(%-.6s, %#04x) %04x %04x %04x %04x\\n\",\n\t  dev->name, rq->ifr_ifrn.ifrn_name, cmd,\n\t  data->phy_id, data->reg_num, data->val_in, data->val_out);\n\n    if (!local->mohawk)\n\treturn -EOPNOTSUPP;\n\n    switch(cmd) {\n      case SIOCGMIIPHY:\t\t \n\tdata->phy_id = 0;\t \n\tfallthrough;\n      case SIOCGMIIREG:\t\t \n\tdata->val_out = mii_rd(ioaddr, data->phy_id & 0x1f,\n\t\t\t       data->reg_num & 0x1f);\n\tbreak;\n      case SIOCSMIIREG:\t\t \n\tmii_wr(ioaddr, data->phy_id & 0x1f, data->reg_num & 0x1f, data->val_in,\n\t       16);\n\tbreak;\n      default:\n\treturn -EOPNOTSUPP;\n    }\n    return 0;\n}\n\nstatic void\nhardreset(struct net_device *dev)\n{\n    struct local_info *local = netdev_priv(dev);\n    unsigned int ioaddr = dev->base_addr;\n\n    SelectPage(4);\n    udelay(1);\n    PutByte(XIRCREG4_GPR1, 0);\t      \n    msleep(40);\t\t\t\t      \n    if (local->mohawk)\n\tPutByte(XIRCREG4_GPR1, 1);\t  \n    else\n\tPutByte(XIRCREG4_GPR1, 1 | 4);\t  \n    msleep(20);\t\t\t      \n}\n\nstatic void\ndo_reset(struct net_device *dev, int full)\n{\n    struct local_info *local = netdev_priv(dev);\n    unsigned int ioaddr = dev->base_addr;\n    unsigned value;\n\n    pr_debug(\"%s: do_reset(%p,%d)\\n\", dev->name, dev, full);\n\n    hardreset(dev);\n    PutByte(XIRCREG_CR, SoftReset);  \n    msleep(20);\t\t\t      \n    PutByte(XIRCREG_CR, 0);\t      \n    msleep(40);\t\t\t      \n    if (local->mohawk) {\n\tSelectPage(4);\n\t \n\tPutByte(XIRCREG4_GPR0, 0x0e);\n    }\n\n     \n    msleep(500);\t\t\t \n\n    local->last_ptr_value = 0;\n    local->silicon = local->mohawk ? (GetByte(XIRCREG4_BOV) & 0x70) >> 4\n\t\t\t\t   : (GetByte(XIRCREG4_BOV) & 0x30) >> 4;\n\n    if (local->probe_port) {\n\tif (!local->mohawk) {\n\t    SelectPage(4);\n\t    PutByte(XIRCREG4_GPR0, 4);\n\t    local->probe_port = 0;\n\t}\n    } else if (dev->if_port == 2) {  \n\tSelectPage(0x42);\n\tPutByte(XIRCREG42_SWC1, 0xC0);\n    } else {  \n\tSelectPage(0x42);\n\tPutByte(XIRCREG42_SWC1, 0x80);\n    }\n    msleep(40);\t\t\t      \n\n  #if 0\n    {\n\tSelectPage(0);\n\tvalue = GetByte(XIRCREG_ESR);\t  \n\tpr_debug(\"%s: ESR is: %#02x\\n\", dev->name, value);\n    }\n  #endif\n\n     \n    SelectPage(1);\n    PutByte(XIRCREG1_IMR0, 0xff);  \n    PutByte(XIRCREG1_IMR1, 1\t);  \n    value = GetByte(XIRCREG1_ECR);\n  #if 0\n    if (local->mohawk)\n\tvalue |= DisableLinkPulse;\n    PutByte(XIRCREG1_ECR, value);\n  #endif\n    pr_debug(\"%s: ECR is: %#02x\\n\", dev->name, value);\n\n    SelectPage(0x42);\n    PutByte(XIRCREG42_SWC0, 0x20);  \n\n    if (local->silicon != 1) {\n\t \n\tSelectPage(2);\n\tPutWord(XIRCREG2_RBS, 0x2000);\n    }\n\n    if (full)\n\tset_addresses(dev);\n\n     \n    SelectPage(0);\n    PutWord(XIRCREG0_DO, 0x2000);  \n\n     \n    SelectPage(0x40);\t\t      \n    PutByte(XIRCREG40_RMASK0, 0xff);  \n    PutByte(XIRCREG40_TMASK0, 0xff);  \n    PutByte(XIRCREG40_TMASK1, 0xb0);  \n    PutByte(XIRCREG40_RXST0,  0x00);  \n    PutByte(XIRCREG40_TXST0,  0x00);  \n    PutByte(XIRCREG40_TXST1,  0x00);  \n\n    if (full && local->mohawk && init_mii(dev)) {\n\tif (dev->if_port == 4 || local->dingo || local->new_mii) {\n\t    netdev_info(dev, \"MII selected\\n\");\n\t    SelectPage(2);\n\t    PutByte(XIRCREG2_MSR, GetByte(XIRCREG2_MSR) | 0x08);\n\t    msleep(20);\n\t} else {\n\t    netdev_info(dev, \"MII detected; using 10mbs\\n\");\n\t    SelectPage(0x42);\n\t    if (dev->if_port == 2)  \n\t\tPutByte(XIRCREG42_SWC1, 0xC0);\n\t    else   \n\t\tPutByte(XIRCREG42_SWC1, 0x80);\n\t    msleep(40);\t\t\t \n\t}\n\tif (full_duplex)\n\t    PutByte(XIRCREG1_ECR, GetByte(XIRCREG1_ECR | FullDuplex));\n    } else {   \n\tSelectPage(0);\n\tvalue = GetByte(XIRCREG_ESR);\t  \n\tdev->if_port = (value & MediaSelect) ? 1 : 2;\n    }\n\n     \n    SelectPage(2);\n    if (dev->if_port == 1 || dev->if_port == 4)  \n\tPutByte(XIRCREG2_LED, 0x3b);\n    else\t\t\t       \n\tPutByte(XIRCREG2_LED, 0x3a);\n\n    if (local->dingo)\n\tPutByte(0x0b, 0x04);  \n\n     \n    if (full) {\n\tset_multicast_list(dev);\n\tSelectPage(0x40);\n\tPutByte(XIRCREG40_CMD0, EnableRecv | Online);\n    }\n\n     \n    SelectPage(1);\n    PutByte(XIRCREG1_IMR0, 0xff);\n    udelay(1);\n    SelectPage(0);\n    PutByte(XIRCREG_CR, EnableIntr);\n    if (local->modem && !local->dingo) {  \n\tif (!(GetByte(0x10) & 0x01))\n\t    PutByte(0x10, 0x11);  \n    }\n\n    if (full)\n\tnetdev_info(dev, \"media %s, silicon revision %d\\n\",\n\t\t    if_names[dev->if_port], local->silicon);\n     \n    SelectPage(0);\n}\n\n \nstatic int\ninit_mii(struct net_device *dev)\n{\n    struct local_info *local = netdev_priv(dev);\n    unsigned int ioaddr = dev->base_addr;\n    unsigned control, status, linkpartner;\n    int i;\n\n    if (if_port == 4 || if_port == 1) {  \n\tdev->if_port = if_port;\n\tlocal->probe_port = 0;\n\treturn 1;\n    }\n\n    status = mii_rd(ioaddr,  0, 1);\n    if ((status & 0xff00) != 0x7800)\n\treturn 0;  \n\n    local->new_mii = (mii_rd(ioaddr, 0, 2) != 0xffff);\n    \n    if (local->probe_port)\n\tcontrol = 0x1000;  \n    else if (dev->if_port == 4)\n\tcontrol = 0x2000;  \n    else\n\tcontrol = 0x0000;  \n    mii_wr(ioaddr,  0, 0, control, 16);\n    udelay(100);\n    control = mii_rd(ioaddr, 0, 0);\n\n    if (control & 0x0400) {\n\tnetdev_notice(dev, \"can't take PHY out of isolation mode\\n\");\n\tlocal->probe_port = 0;\n\treturn 0;\n    }\n\n    if (local->probe_port) {\n\t \n\tfor (i=0; i < 35; i++) {\n\t    msleep(100);\t  \n\t    status = mii_rd(ioaddr,  0, 1);\n\t    if ((status & 0x0020) && (status & 0x0004))\n\t\tbreak;\n\t}\n\n\tif (!(status & 0x0020)) {\n\t    netdev_info(dev, \"autonegotiation failed; using 10mbs\\n\");\n\t    if (!local->new_mii) {\n\t\tcontrol = 0x0000;\n\t\tmii_wr(ioaddr,  0, 0, control, 16);\n\t\tudelay(100);\n\t\tSelectPage(0);\n\t\tdev->if_port = (GetByte(XIRCREG_ESR) & MediaSelect) ? 1 : 2;\n\t    }\n\t} else {\n\t    linkpartner = mii_rd(ioaddr, 0, 5);\n\t    netdev_info(dev, \"MII link partner: %04x\\n\", linkpartner);\n\t    if (linkpartner & 0x0080) {\n\t\tdev->if_port = 4;\n\t    } else\n\t\tdev->if_port = 1;\n\t}\n    }\n\n    return 1;\n}\n\nstatic void\ndo_powerdown(struct net_device *dev)\n{\n\n    unsigned int ioaddr = dev->base_addr;\n\n    pr_debug(\"do_powerdown(%p)\\n\", dev);\n\n    SelectPage(4);\n    PutByte(XIRCREG4_GPR1, 0);\t      \n    SelectPage(0);\n}\n\nstatic int\ndo_stop(struct net_device *dev)\n{\n    unsigned int ioaddr = dev->base_addr;\n    struct local_info *lp = netdev_priv(dev);\n    struct pcmcia_device *link = lp->p_dev;\n\n    dev_dbg(&link->dev, \"do_stop(%p)\\n\", dev);\n\n    if (!link)\n\treturn -ENODEV;\n\n    netif_stop_queue(dev);\n\n    SelectPage(0);\n    PutByte(XIRCREG_CR, 0);   \n    SelectPage(0x01);\n    PutByte(XIRCREG1_IMR0, 0x00);  \n    SelectPage(4);\n    PutByte(XIRCREG4_GPR1, 0);\t \n    SelectPage(0);\n\n    link->open--;\n    return 0;\n}\n\nstatic const struct pcmcia_device_id xirc2ps_ids[] = {\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0089, 0x110a),\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0138, 0x110a),\n\tPCMCIA_PFC_DEVICE_PROD_ID13(0, \"Xircom\", \"CEM28\", 0x2e3ee845, 0x0ea978ea),\n\tPCMCIA_PFC_DEVICE_PROD_ID13(0, \"Xircom\", \"CEM33\", 0x2e3ee845, 0x80609023),\n\tPCMCIA_PFC_DEVICE_PROD_ID13(0, \"Xircom\", \"CEM56\", 0x2e3ee845, 0xa650c32a),\n\tPCMCIA_PFC_DEVICE_PROD_ID13(0, \"Xircom\", \"REM10\", 0x2e3ee845, 0x76df1d29),\n\tPCMCIA_PFC_DEVICE_PROD_ID13(0, \"Xircom\", \"XEM5600\", 0x2e3ee845, 0xf1403719),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"Xircom\", \"CreditCard Ethernet+Modem II\", 0x2e3ee845, 0xeca401bf),\n\tPCMCIA_DEVICE_MANF_CARD(0x01bf, 0x010a),\n\tPCMCIA_DEVICE_PROD_ID13(\"Toshiba Information Systems\", \"TPCENET\", 0x1b3b94fe, 0xf381c1a2),\n\tPCMCIA_DEVICE_PROD_ID13(\"Xircom\", \"CE3-10/100\", 0x2e3ee845, 0x0ec0ac37),\n\tPCMCIA_DEVICE_PROD_ID13(\"Xircom\", \"PS-CE2-10\", 0x2e3ee845, 0x947d9073),\n\tPCMCIA_DEVICE_PROD_ID13(\"Xircom\", \"R2E-100BTX\", 0x2e3ee845, 0x2464a6e3),\n\tPCMCIA_DEVICE_PROD_ID13(\"Xircom\", \"RE-10\", 0x2e3ee845, 0x3e08d609),\n\tPCMCIA_DEVICE_PROD_ID13(\"Xircom\", \"XE2000\", 0x2e3ee845, 0xf7188e46),\n\tPCMCIA_DEVICE_PROD_ID12(\"Compaq\", \"Ethernet LAN Card\", 0x54f7c49c, 0x9fd2f0a2),\n\tPCMCIA_DEVICE_PROD_ID12(\"Compaq\", \"Netelligent 10/100 PC Card\", 0x54f7c49c, 0xefe96769),\n\tPCMCIA_DEVICE_PROD_ID12(\"Intel\", \"EtherExpress(TM) PRO/100 PC Card Mobile Adapter16\", 0x816cc815, 0x174397db),\n\tPCMCIA_DEVICE_PROD_ID12(\"Toshiba\", \"10/100 Ethernet PC Card\", 0x44a09d9c, 0xb44deecf),\n\t \n\t \n\tPCMCIA_DEVICE_NULL,\n};\nMODULE_DEVICE_TABLE(pcmcia, xirc2ps_ids);\n\n\nstatic struct pcmcia_driver xirc2ps_cs_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"xirc2ps_cs\",\n\t.probe\t\t= xirc2ps_probe,\n\t.remove\t\t= xirc2ps_detach,\n\t.id_table       = xirc2ps_ids,\n\t.suspend\t= xirc2ps_suspend,\n\t.resume\t\t= xirc2ps_resume,\n};\nmodule_pcmcia_driver(xirc2ps_cs_driver);\n\n#ifndef MODULE\nstatic int __init setup_xirc2ps_cs(char *str)\n{\n\t \n\tint ints[10] = { -1 };\n\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\n#define MAYBE_SET(X,Y) if (ints[0] >= Y && ints[Y] != -1) { X = ints[Y]; }\n\tMAYBE_SET(if_port, 3);\n\tMAYBE_SET(full_duplex, 4);\n\tMAYBE_SET(do_sound, 5);\n\tMAYBE_SET(lockup_hack, 6);\n#undef  MAYBE_SET\n\n\treturn 1;\n}\n\n__setup(\"xirc2ps_cs=\", setup_xirc2ps_cs);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}