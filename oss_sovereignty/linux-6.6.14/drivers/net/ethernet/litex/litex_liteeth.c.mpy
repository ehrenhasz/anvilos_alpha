{
  "module_name": "litex_liteeth.c",
  "hash_id": "4fb90e4e5ae70679c51cc10a299868c0eebb046cb072e9fb0af82ca1478101ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/litex/litex_liteeth.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/litex.h>\n#include <linux/module.h>\n#include <linux/of_net.h>\n#include <linux/platform_device.h>\n\n#define LITEETH_WRITER_SLOT       0x00\n#define LITEETH_WRITER_LENGTH     0x04\n#define LITEETH_WRITER_ERRORS     0x08\n#define LITEETH_WRITER_EV_STATUS  0x0C\n#define LITEETH_WRITER_EV_PENDING 0x10\n#define LITEETH_WRITER_EV_ENABLE  0x14\n#define LITEETH_READER_START      0x18\n#define LITEETH_READER_READY      0x1C\n#define LITEETH_READER_LEVEL      0x20\n#define LITEETH_READER_SLOT       0x24\n#define LITEETH_READER_LENGTH     0x28\n#define LITEETH_READER_EV_STATUS  0x2C\n#define LITEETH_READER_EV_PENDING 0x30\n#define LITEETH_READER_EV_ENABLE  0x34\n#define LITEETH_PREAMBLE_CRC      0x38\n#define LITEETH_PREAMBLE_ERRORS   0x3C\n#define LITEETH_CRC_ERRORS        0x40\n\n#define LITEETH_PHY_CRG_RESET     0x00\n#define LITEETH_MDIO_W            0x04\n#define LITEETH_MDIO_R            0x0C\n\n#define DRV_NAME\t\"liteeth\"\n\nstruct liteeth {\n\tvoid __iomem *base;\n\tstruct net_device *netdev;\n\tstruct device *dev;\n\tu32 slot_size;\n\n\t \n\tu32 tx_slot;\n\tu32 num_tx_slots;\n\tvoid __iomem *tx_base;\n\n\t \n\tu32 rx_slot;\n\tu32 num_rx_slots;\n\tvoid __iomem *rx_base;\n};\n\nstatic int liteeth_rx(struct net_device *netdev)\n{\n\tstruct liteeth *priv = netdev_priv(netdev);\n\tstruct sk_buff *skb;\n\tunsigned char *data;\n\tu8 rx_slot;\n\tint len;\n\n\trx_slot = litex_read8(priv->base + LITEETH_WRITER_SLOT);\n\tlen = litex_read32(priv->base + LITEETH_WRITER_LENGTH);\n\n\tif (len == 0 || len > 2048)\n\t\tgoto rx_drop;\n\n\tskb = netdev_alloc_skb_ip_align(netdev, len);\n\tif (!skb) {\n\t\tnetdev_err(netdev, \"couldn't get memory\\n\");\n\t\tgoto rx_drop;\n\t}\n\n\tdata = skb_put(skb, len);\n\tmemcpy_fromio(data, priv->rx_base + rx_slot * priv->slot_size, len);\n\tskb->protocol = eth_type_trans(skb, netdev);\n\n\tdev_sw_netstats_rx_add(netdev, len);\n\n\treturn netif_rx(skb);\n\nrx_drop:\n\tnetdev->stats.rx_dropped++;\n\tnetdev->stats.rx_errors++;\n\n\treturn NET_RX_DROP;\n}\n\nstatic irqreturn_t liteeth_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *netdev = dev_id;\n\tstruct liteeth *priv = netdev_priv(netdev);\n\tu8 reg;\n\n\treg = litex_read8(priv->base + LITEETH_READER_EV_PENDING);\n\tif (reg) {\n\t\tif (netif_queue_stopped(netdev))\n\t\t\tnetif_wake_queue(netdev);\n\t\tlitex_write8(priv->base + LITEETH_READER_EV_PENDING, reg);\n\t}\n\n\treg = litex_read8(priv->base + LITEETH_WRITER_EV_PENDING);\n\tif (reg) {\n\t\tliteeth_rx(netdev);\n\t\tlitex_write8(priv->base + LITEETH_WRITER_EV_PENDING, reg);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int liteeth_open(struct net_device *netdev)\n{\n\tstruct liteeth *priv = netdev_priv(netdev);\n\tint err;\n\n\t \n\tlitex_write8(priv->base + LITEETH_WRITER_EV_PENDING, 1);\n\tlitex_write8(priv->base + LITEETH_READER_EV_PENDING, 1);\n\n\terr = request_irq(netdev->irq, liteeth_interrupt, 0, netdev->name, netdev);\n\tif (err) {\n\t\tnetdev_err(netdev, \"failed to request irq %d\\n\", netdev->irq);\n\t\treturn err;\n\t}\n\n\t \n\tlitex_write8(priv->base + LITEETH_WRITER_EV_ENABLE, 1);\n\tlitex_write8(priv->base + LITEETH_READER_EV_ENABLE, 1);\n\n\tnetif_carrier_on(netdev);\n\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\nstatic int liteeth_stop(struct net_device *netdev)\n{\n\tstruct liteeth *priv = netdev_priv(netdev);\n\n\tnetif_stop_queue(netdev);\n\tnetif_carrier_off(netdev);\n\n\tlitex_write8(priv->base + LITEETH_WRITER_EV_ENABLE, 0);\n\tlitex_write8(priv->base + LITEETH_READER_EV_ENABLE, 0);\n\n\tfree_irq(netdev->irq, netdev);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t liteeth_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *netdev)\n{\n\tstruct liteeth *priv = netdev_priv(netdev);\n\tvoid __iomem *txbuffer;\n\n\tif (!litex_read8(priv->base + LITEETH_READER_READY)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev, \"LITEETH_READER_READY not ready\\n\");\n\n\t\tnetif_stop_queue(netdev);\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tif (unlikely(skb->len > priv->slot_size)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev, \"tx packet too big\\n\");\n\n\t\tdev_kfree_skb_any(skb);\n\t\tnetdev->stats.tx_dropped++;\n\t\tnetdev->stats.tx_errors++;\n\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\ttxbuffer = priv->tx_base + priv->tx_slot * priv->slot_size;\n\tmemcpy_toio(txbuffer, skb->data, skb->len);\n\tlitex_write8(priv->base + LITEETH_READER_SLOT, priv->tx_slot);\n\tlitex_write16(priv->base + LITEETH_READER_LENGTH, skb->len);\n\tlitex_write8(priv->base + LITEETH_READER_START, 1);\n\n\tdev_sw_netstats_tx_add(netdev, 1, skb->len);\n\n\tpriv->tx_slot = (priv->tx_slot + 1) % priv->num_tx_slots;\n\tdev_kfree_skb_any(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void\nliteeth_get_stats64(struct net_device *netdev, struct rtnl_link_stats64 *stats)\n{\n\tnetdev_stats_to_stats64(stats, &netdev->stats);\n\tdev_fetch_sw_netstats(stats, netdev->tstats);\n}\n\nstatic const struct net_device_ops liteeth_netdev_ops = {\n\t.ndo_open\t\t= liteeth_open,\n\t.ndo_stop\t\t= liteeth_stop,\n\t.ndo_get_stats64\t= liteeth_get_stats64,\n\t.ndo_start_xmit         = liteeth_start_xmit,\n};\n\nstatic void liteeth_setup_slots(struct liteeth *priv)\n{\n\tstruct device_node *np = priv->dev->of_node;\n\tint err;\n\n\terr = of_property_read_u32(np, \"litex,rx-slots\", &priv->num_rx_slots);\n\tif (err) {\n\t\tdev_dbg(priv->dev, \"unable to get litex,rx-slots, using 2\\n\");\n\t\tpriv->num_rx_slots = 2;\n\t}\n\n\terr = of_property_read_u32(np, \"litex,tx-slots\", &priv->num_tx_slots);\n\tif (err) {\n\t\tdev_dbg(priv->dev, \"unable to get litex,tx-slots, using 2\\n\");\n\t\tpriv->num_tx_slots = 2;\n\t}\n\n\terr = of_property_read_u32(np, \"litex,slot-size\", &priv->slot_size);\n\tif (err) {\n\t\tdev_dbg(priv->dev, \"unable to get litex,slot-size, using 0x800\\n\");\n\t\tpriv->slot_size = 0x800;\n\t}\n}\n\nstatic int liteeth_probe(struct platform_device *pdev)\n{\n\tstruct net_device *netdev;\n\tvoid __iomem *buf_base;\n\tstruct liteeth *priv;\n\tint irq, err;\n\n\tnetdev = devm_alloc_etherdev(&pdev->dev, sizeof(*priv));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\tplatform_set_drvdata(pdev, netdev);\n\n\tpriv = netdev_priv(netdev);\n\tpriv->netdev = netdev;\n\tpriv->dev = &pdev->dev;\n\n\tnetdev->tstats = devm_netdev_alloc_pcpu_stats(&pdev->dev,\n\t\t\t\t\t\t      struct pcpu_sw_netstats);\n\tif (!netdev->tstats)\n\t\treturn -ENOMEM;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tnetdev->irq = irq;\n\n\tpriv->base = devm_platform_ioremap_resource_byname(pdev, \"mac\");\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tbuf_base = devm_platform_ioremap_resource_byname(pdev, \"buffer\");\n\tif (IS_ERR(buf_base))\n\t\treturn PTR_ERR(buf_base);\n\n\tliteeth_setup_slots(priv);\n\n\t \n\tpriv->rx_base = buf_base;\n\tpriv->rx_slot = 0;\n\n\t \n\tpriv->tx_base = buf_base + priv->num_rx_slots * priv->slot_size;\n\tpriv->tx_slot = 0;\n\n\terr = of_get_ethdev_address(pdev->dev.of_node, netdev);\n\tif (err)\n\t\teth_hw_addr_random(netdev);\n\n\tnetdev->netdev_ops = &liteeth_netdev_ops;\n\n\terr = register_netdev(netdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to register netdev %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tnetdev_info(netdev, \"irq %d slots: tx %d rx %d size %d\\n\",\n\t\t    netdev->irq, priv->num_tx_slots, priv->num_rx_slots, priv->slot_size);\n\n\treturn 0;\n}\n\nstatic int liteeth_remove(struct platform_device *pdev)\n{\n\tstruct net_device *netdev = platform_get_drvdata(pdev);\n\n\tunregister_netdev(netdev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id liteeth_of_match[] = {\n\t{ .compatible = \"litex,liteeth\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, liteeth_of_match);\n\nstatic struct platform_driver liteeth_driver = {\n\t.probe = liteeth_probe,\n\t.remove = liteeth_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = liteeth_of_match,\n\t},\n};\nmodule_platform_driver(liteeth_driver);\n\nMODULE_AUTHOR(\"Joel Stanley <joel@jms.id.au>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}