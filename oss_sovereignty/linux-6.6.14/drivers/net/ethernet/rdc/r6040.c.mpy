{
  "module_name": "r6040.c",
  "hash_id": "014749af8dccc5d1a49945b7dceabfbf2a40a2983aab5f138ffa38256eaf33e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/rdc/r6040.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/crc32.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/uaccess.h>\n#include <linux/phy.h>\n\n#include <asm/processor.h>\n\n#define DRV_NAME\t\"r6040\"\n#define DRV_VERSION\t\"0.29\"\n#define DRV_RELDATE\t\"04Jul2016\"\n\n \n#define TX_TIMEOUT\t(6000 * HZ / 1000)\n\n \n#define R6040_IO_SIZE\t256\n\n \n#define MAX_MAC\t\t2\n\n \n#define MCR0\t\t0x00\t \n#define  MCR0_RCVEN\t0x0002\t \n#define  MCR0_PROMISC\t0x0020\t \n#define  MCR0_HASH_EN\t0x0100\t \n#define  MCR0_XMTEN\t0x1000\t \n#define  MCR0_FD\t0x8000\t \n#define MCR1\t\t0x04\t \n#define  MAC_RST\t0x0001\t \n#define MBCR\t\t0x08\t \n#define MT_ICR\t\t0x0C\t \n#define MR_ICR\t\t0x10\t \n#define MTPR\t\t0x14\t \n#define  TM2TX\t\t0x0001\t \n#define MR_BSR\t\t0x18\t \n#define MR_DCR\t\t0x1A\t \n#define MLSR\t\t0x1C\t \n#define  TX_FIFO_UNDR\t0x0200\t \n#define\t TX_EXCEEDC\t0x2000\t \n#define  TX_LATEC\t0x4000\t \n#define MMDIO\t\t0x20\t \n#define  MDIO_WRITE\t0x4000\t \n#define  MDIO_READ\t0x2000\t \n#define MMRD\t\t0x24\t \n#define MMWD\t\t0x28\t \n#define MTD_SA0\t\t0x2C\t \n#define MTD_SA1\t\t0x30\t \n#define MRD_SA0\t\t0x34\t \n#define MRD_SA1\t\t0x38\t \n#define MISR\t\t0x3C\t \n#define MIER\t\t0x40\t \n#define  MSK_INT\t0x0000\t \n#define  RX_FINISH\t0x0001   \n#define  RX_NO_DESC\t0x0002   \n#define  RX_FIFO_FULL\t0x0004   \n#define  RX_EARLY\t0x0008   \n#define  TX_FINISH\t0x0010   \n#define  TX_EARLY\t0x0080   \n#define  EVENT_OVRFL\t0x0100   \n#define  LINK_CHANGED\t0x0200   \n#define ME_CISR\t\t0x44\t \n#define ME_CIER\t\t0x48\t \n#define MR_CNT\t\t0x50\t \n#define ME_CNT0\t\t0x52\t \n#define ME_CNT1\t\t0x54\t \n#define ME_CNT2\t\t0x56\t \n#define ME_CNT3\t\t0x58\t \n#define MT_CNT\t\t0x5A\t \n#define ME_CNT4\t\t0x5C\t \n#define MP_CNT\t\t0x5E\t \n#define MAR0\t\t0x60\t \n#define MAR1\t\t0x62\t \n#define MAR2\t\t0x64\t \n#define MAR3\t\t0x66\t \n#define MID_0L\t\t0x68\t \n#define MID_0M\t\t0x6A\t \n#define MID_0H\t\t0x6C\t \n#define MID_1L\t\t0x70\t \n#define MID_1M\t\t0x72\t \n#define MID_1H\t\t0x74\t \n#define MID_2L\t\t0x78\t \n#define MID_2M\t\t0x7A\t \n#define MID_2H\t\t0x7C\t \n#define MID_3L\t\t0x80\t \n#define MID_3M\t\t0x82\t \n#define MID_3H\t\t0x84\t \n#define PHY_CC\t\t0x88\t \n#define  SCEN\t\t0x8000\t \n#define  PHYAD_SHIFT\t8\t \n#define  TMRDIV_SHIFT\t0\t \n#define PHY_ST\t\t0x8A\t \n#define MAC_SM\t\t0xAC\t \n#define  MAC_SM_RST\t0x0002\t \n#define MD_CSC\t\t0xb6\t \n#define  MD_CSC_DEFAULT\t0x0030\n#define MAC_ID\t\t0xBE\t \n\n#define TX_DCNT\t\t0x80\t \n#define RX_DCNT\t\t0x80\t \n#define MAX_BUF_SIZE\t0x600\n#define RX_DESC_SIZE\t(RX_DCNT * sizeof(struct r6040_descriptor))\n#define TX_DESC_SIZE\t(TX_DCNT * sizeof(struct r6040_descriptor))\n#define MBCR_DEFAULT\t0x012A\t \n#define MCAST_MAX\t3\t \n\n#define MAC_DEF_TIMEOUT\t2048\t \n\n \n#define DSC_OWNER_MAC\t0x8000\t \n#define DSC_RX_OK\t0x4000\t \n#define DSC_RX_ERR\t0x0800\t \n#define DSC_RX_ERR_DRI\t0x0400\t \n#define DSC_RX_ERR_BUF\t0x0200\t \n#define DSC_RX_ERR_LONG\t0x0100\t \n#define DSC_RX_ERR_RUNT\t0x0080\t \n#define DSC_RX_ERR_CRC\t0x0040\t \n#define DSC_RX_BCAST\t0x0020\t \n#define DSC_RX_MCAST\t0x0010\t \n#define DSC_RX_MCH_HIT\t0x0008\t \n#define DSC_RX_MIDH_HIT\t0x0004\t \n#define DSC_RX_IDX_MID_MASK 3\t \n\nMODULE_AUTHOR(\"Sten Wang <sten.wang@rdc.com.tw>,\"\n\t\"Daniel Gimpelevich <daniel@gimpelevich.san-francisco.ca.us>,\"\n\t\"Florian Fainelli <f.fainelli@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"RDC R6040 NAPI PCI FastEthernet driver\");\nMODULE_VERSION(DRV_VERSION \" \" DRV_RELDATE);\n\n \n#define RX_INTS\t\t\t(RX_FIFO_FULL | RX_NO_DESC | RX_FINISH)\n#define TX_INTS\t\t\t(TX_FINISH)\n#define INT_MASK\t\t(RX_INTS | TX_INTS)\n\nstruct r6040_descriptor {\n\tu16\tstatus, len;\t\t \n\t__le32\tbuf;\t\t\t \n\t__le32\tndesc;\t\t\t \n\tu32\trev1;\t\t\t \n\tchar\t*vbufp;\t\t\t \n\tstruct r6040_descriptor *vndescp;\t \n\tstruct sk_buff *skb_ptr;\t \n\tu32\trev2;\t\t\t \n} __aligned(32);\n\nstruct r6040_private {\n\tspinlock_t lock;\t\t \n\tstruct pci_dev *pdev;\n\tstruct r6040_descriptor *rx_insert_ptr;\n\tstruct r6040_descriptor *rx_remove_ptr;\n\tstruct r6040_descriptor *tx_insert_ptr;\n\tstruct r6040_descriptor *tx_remove_ptr;\n\tstruct r6040_descriptor *rx_ring;\n\tstruct r6040_descriptor *tx_ring;\n\tdma_addr_t rx_ring_dma;\n\tdma_addr_t tx_ring_dma;\n\tu16\ttx_free_desc;\n\tu16\tmcr0;\n\tstruct net_device *dev;\n\tstruct mii_bus *mii_bus;\n\tstruct napi_struct napi;\n\tvoid __iomem *base;\n\tint old_link;\n\tint old_duplex;\n};\n\nstatic char version[] = DRV_NAME\n\t\": RDC R6040 NAPI net driver,\"\n\t\"version \"DRV_VERSION \" (\" DRV_RELDATE \")\";\n\n \nstatic int r6040_phy_read(void __iomem *ioaddr, int phy_addr, int reg)\n{\n\tint limit = MAC_DEF_TIMEOUT;\n\tu16 cmd;\n\n\tiowrite16(MDIO_READ | reg | (phy_addr << 8), ioaddr + MMDIO);\n\t \n\twhile (limit--) {\n\t\tcmd = ioread16(ioaddr + MMDIO);\n\t\tif (!(cmd & MDIO_READ))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (limit < 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn ioread16(ioaddr + MMRD);\n}\n\n \nstatic int r6040_phy_write(void __iomem *ioaddr,\n\t\t\t\t\tint phy_addr, int reg, u16 val)\n{\n\tint limit = MAC_DEF_TIMEOUT;\n\tu16 cmd;\n\n\tiowrite16(val, ioaddr + MMWD);\n\t \n\tiowrite16(MDIO_WRITE | reg | (phy_addr << 8), ioaddr + MMDIO);\n\t \n\twhile (limit--) {\n\t\tcmd = ioread16(ioaddr + MMDIO);\n\t\tif (!(cmd & MDIO_WRITE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\treturn (limit < 0) ? -ETIMEDOUT : 0;\n}\n\nstatic int r6040_mdiobus_read(struct mii_bus *bus, int phy_addr, int reg)\n{\n\tstruct net_device *dev = bus->priv;\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\n\treturn r6040_phy_read(ioaddr, phy_addr, reg);\n}\n\nstatic int r6040_mdiobus_write(struct mii_bus *bus, int phy_addr,\n\t\t\t\t\t\tint reg, u16 value)\n{\n\tstruct net_device *dev = bus->priv;\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\n\treturn r6040_phy_write(ioaddr, phy_addr, reg, value);\n}\n\nstatic void r6040_free_txbufs(struct net_device *dev)\n{\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tint i;\n\n\tfor (i = 0; i < TX_DCNT; i++) {\n\t\tif (lp->tx_insert_ptr->skb_ptr) {\n\t\t\tdma_unmap_single(&lp->pdev->dev,\n\t\t\t\t\t le32_to_cpu(lp->tx_insert_ptr->buf),\n\t\t\t\t\t MAX_BUF_SIZE, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(lp->tx_insert_ptr->skb_ptr);\n\t\t\tlp->tx_insert_ptr->skb_ptr = NULL;\n\t\t}\n\t\tlp->tx_insert_ptr = lp->tx_insert_ptr->vndescp;\n\t}\n}\n\nstatic void r6040_free_rxbufs(struct net_device *dev)\n{\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tint i;\n\n\tfor (i = 0; i < RX_DCNT; i++) {\n\t\tif (lp->rx_insert_ptr->skb_ptr) {\n\t\t\tdma_unmap_single(&lp->pdev->dev,\n\t\t\t\t\t le32_to_cpu(lp->rx_insert_ptr->buf),\n\t\t\t\t\t MAX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(lp->rx_insert_ptr->skb_ptr);\n\t\t\tlp->rx_insert_ptr->skb_ptr = NULL;\n\t\t}\n\t\tlp->rx_insert_ptr = lp->rx_insert_ptr->vndescp;\n\t}\n}\n\nstatic void r6040_init_ring_desc(struct r6040_descriptor *desc_ring,\n\t\t\t\t dma_addr_t desc_dma, int size)\n{\n\tstruct r6040_descriptor *desc = desc_ring;\n\tdma_addr_t mapping = desc_dma;\n\n\twhile (size-- > 0) {\n\t\tmapping += sizeof(*desc);\n\t\tdesc->ndesc = cpu_to_le32(mapping);\n\t\tdesc->vndescp = desc + 1;\n\t\tdesc++;\n\t}\n\tdesc--;\n\tdesc->ndesc = cpu_to_le32(desc_dma);\n\tdesc->vndescp = desc_ring;\n}\n\nstatic void r6040_init_txbufs(struct net_device *dev)\n{\n\tstruct r6040_private *lp = netdev_priv(dev);\n\n\tlp->tx_free_desc = TX_DCNT;\n\n\tlp->tx_remove_ptr = lp->tx_insert_ptr = lp->tx_ring;\n\tr6040_init_ring_desc(lp->tx_ring, lp->tx_ring_dma, TX_DCNT);\n}\n\nstatic int r6040_alloc_rxbufs(struct net_device *dev)\n{\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tstruct r6040_descriptor *desc;\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tlp->rx_remove_ptr = lp->rx_insert_ptr = lp->rx_ring;\n\tr6040_init_ring_desc(lp->rx_ring, lp->rx_ring_dma, RX_DCNT);\n\n\t \n\tdesc = lp->rx_ring;\n\tdo {\n\t\tskb = netdev_alloc_skb(dev, MAX_BUF_SIZE);\n\t\tif (!skb) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_exit;\n\t\t}\n\t\tdesc->skb_ptr = skb;\n\t\tdesc->buf = cpu_to_le32(dma_map_single(&lp->pdev->dev,\n\t\t\t\t\t\t       desc->skb_ptr->data,\n\t\t\t\t\t\t       MAX_BUF_SIZE,\n\t\t\t\t\t\t       DMA_FROM_DEVICE));\n\t\tdesc->status = DSC_OWNER_MAC;\n\t\tdesc = desc->vndescp;\n\t} while (desc != lp->rx_ring);\n\n\treturn 0;\n\nerr_exit:\n\t \n\tr6040_free_rxbufs(dev);\n\treturn rc;\n}\n\nstatic void r6040_reset_mac(struct r6040_private *lp)\n{\n\tvoid __iomem *ioaddr = lp->base;\n\tint limit = MAC_DEF_TIMEOUT;\n\tu16 cmd, md_csc;\n\n\tmd_csc = ioread16(ioaddr + MD_CSC);\n\tiowrite16(MAC_RST, ioaddr + MCR1);\n\twhile (limit--) {\n\t\tcmd = ioread16(ioaddr + MCR1);\n\t\tif (cmd & MAC_RST)\n\t\t\tbreak;\n\t}\n\n\t \n\tiowrite16(MAC_SM_RST, ioaddr + MAC_SM);\n\tiowrite16(0, ioaddr + MAC_SM);\n\tmdelay(5);\n\n\t \n\tif (md_csc != MD_CSC_DEFAULT)\n\t\tiowrite16(md_csc, ioaddr + MD_CSC);\n}\n\nstatic void r6040_init_mac_regs(struct net_device *dev)\n{\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\n\t \n\tiowrite16(MSK_INT, ioaddr + MIER);\n\n\t \n\tr6040_reset_mac(lp);\n\n\t \n\tiowrite16(MBCR_DEFAULT, ioaddr + MBCR);\n\n\t \n\tiowrite16(MAX_BUF_SIZE, ioaddr + MR_BSR);\n\n\t \n\tiowrite16(lp->tx_ring_dma, ioaddr + MTD_SA0);\n\tiowrite16(lp->tx_ring_dma >> 16, ioaddr + MTD_SA1);\n\n\t \n\tiowrite16(lp->rx_ring_dma, ioaddr + MRD_SA0);\n\tiowrite16(lp->rx_ring_dma >> 16, ioaddr + MRD_SA1);\n\n\t \n\tiowrite16(0, ioaddr + MT_ICR);\n\tiowrite16(0, ioaddr + MR_ICR);\n\n\t \n\tiowrite16(INT_MASK, ioaddr + MIER);\n\n\t \n\tiowrite16(lp->mcr0 | MCR0_RCVEN, ioaddr);\n\n\t \n\tiowrite16(TM2TX, ioaddr + MTPR);\n}\n\nstatic void r6040_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct r6040_private *priv = netdev_priv(dev);\n\tvoid __iomem *ioaddr = priv->base;\n\n\tnetdev_warn(dev, \"transmit timed out, int enable %4.4x \"\n\t\t\"status %4.4x\\n\",\n\t\tioread16(ioaddr + MIER),\n\t\tioread16(ioaddr + MISR));\n\n\tdev->stats.tx_errors++;\n\n\t \n\tr6040_init_mac_regs(dev);\n}\n\nstatic struct net_device_stats *r6040_get_stats(struct net_device *dev)\n{\n\tstruct r6040_private *priv = netdev_priv(dev);\n\tvoid __iomem *ioaddr = priv->base;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tdev->stats.rx_crc_errors += ioread8(ioaddr + ME_CNT1);\n\tdev->stats.multicast += ioread8(ioaddr + ME_CNT0);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn &dev->stats;\n}\n\n \nstatic void r6040_down(struct net_device *dev)\n{\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tconst u16 *adrp;\n\n\t \n\tiowrite16(MSK_INT, ioaddr + MIER);\t \n\n\t \n\tr6040_reset_mac(lp);\n\n\t \n\tadrp = (const u16 *) dev->dev_addr;\n\tiowrite16(adrp[0], ioaddr + MID_0L);\n\tiowrite16(adrp[1], ioaddr + MID_0M);\n\tiowrite16(adrp[2], ioaddr + MID_0H);\n}\n\nstatic int r6040_close(struct net_device *dev)\n{\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tstruct pci_dev *pdev = lp->pdev;\n\n\tphy_stop(dev->phydev);\n\tnapi_disable(&lp->napi);\n\tnetif_stop_queue(dev);\n\n\tspin_lock_irq(&lp->lock);\n\tr6040_down(dev);\n\n\t \n\tr6040_free_rxbufs(dev);\n\n\t \n\tr6040_free_txbufs(dev);\n\n\tspin_unlock_irq(&lp->lock);\n\n\tfree_irq(dev->irq, dev);\n\n\t \n\tif (lp->rx_ring) {\n\t\tdma_free_coherent(&pdev->dev, RX_DESC_SIZE, lp->rx_ring,\n\t\t\t\t  lp->rx_ring_dma);\n\t\tlp->rx_ring = NULL;\n\t}\n\n\tif (lp->tx_ring) {\n\t\tdma_free_coherent(&pdev->dev, TX_DESC_SIZE, lp->tx_ring,\n\t\t\t\t  lp->tx_ring_dma);\n\t\tlp->tx_ring = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int r6040_rx(struct net_device *dev, int limit)\n{\n\tstruct r6040_private *priv = netdev_priv(dev);\n\tstruct r6040_descriptor *descptr = priv->rx_remove_ptr;\n\tstruct sk_buff *skb_ptr, *new_skb;\n\tint count = 0;\n\tu16 err;\n\n\t \n\twhile (count < limit && !(descptr->status & DSC_OWNER_MAC)) {\n\t\t \n\t\terr = descptr->status;\n\t\t \n\t\tif (err & DSC_RX_ERR) {\n\t\t\t \n\t\t\tif (err & DSC_RX_ERR_DRI)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\t \n\t\t\tif (err & DSC_RX_ERR_BUF)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t \n\t\t\tif (err & DSC_RX_ERR_LONG)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t \n\t\t\tif (err & DSC_RX_ERR_RUNT)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t \n\t\t\tif (err & DSC_RX_ERR_CRC) {\n\t\t\t\tspin_lock(&priv->lock);\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t\tspin_unlock(&priv->lock);\n\t\t\t}\n\t\t\tgoto next_descr;\n\t\t}\n\n\t\t \n\t\tnew_skb = netdev_alloc_skb(dev, MAX_BUF_SIZE);\n\t\tif (!new_skb) {\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tgoto next_descr;\n\t\t}\n\t\tskb_ptr = descptr->skb_ptr;\n\t\tskb_ptr->dev = priv->dev;\n\n\t\t \n\t\tskb_put(skb_ptr, descptr->len - ETH_FCS_LEN);\n\t\tdma_unmap_single(&priv->pdev->dev, le32_to_cpu(descptr->buf),\n\t\t\t\t MAX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tskb_ptr->protocol = eth_type_trans(skb_ptr, priv->dev);\n\n\t\t \n\t\tnetif_receive_skb(skb_ptr);\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += descptr->len - ETH_FCS_LEN;\n\n\t\t \n\t\tdescptr->skb_ptr = new_skb;\n\t\tdescptr->buf = cpu_to_le32(dma_map_single(&priv->pdev->dev,\n\t\t\t\t\t\t\t  descptr->skb_ptr->data,\n\t\t\t\t\t\t\t  MAX_BUF_SIZE,\n\t\t\t\t\t\t\t  DMA_FROM_DEVICE));\n\nnext_descr:\n\t\t \n\t\tdescptr->status = DSC_OWNER_MAC;\n\t\tdescptr = descptr->vndescp;\n\t\tcount++;\n\t}\n\tpriv->rx_remove_ptr = descptr;\n\n\treturn count;\n}\n\nstatic void r6040_tx(struct net_device *dev)\n{\n\tstruct r6040_private *priv = netdev_priv(dev);\n\tstruct r6040_descriptor *descptr;\n\tvoid __iomem *ioaddr = priv->base;\n\tstruct sk_buff *skb_ptr;\n\tu16 err;\n\n\tspin_lock(&priv->lock);\n\tdescptr = priv->tx_remove_ptr;\n\twhile (priv->tx_free_desc < TX_DCNT) {\n\t\t \n\t\terr = ioread16(ioaddr + MLSR);\n\n\t\tif (err & TX_FIFO_UNDR)\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\tif (err & (TX_EXCEEDC | TX_LATEC))\n\t\t\tdev->stats.tx_carrier_errors++;\n\n\t\tif (descptr->status & DSC_OWNER_MAC)\n\t\t\tbreak;  \n\t\tskb_ptr = descptr->skb_ptr;\n\n\t\t \n\t\tdev->stats.tx_packets++;\n\t\tdev->stats.tx_bytes += skb_ptr->len;\n\n\t\tdma_unmap_single(&priv->pdev->dev, le32_to_cpu(descptr->buf),\n\t\t\t\t skb_ptr->len, DMA_TO_DEVICE);\n\t\t \n\t\tdev_kfree_skb(skb_ptr);\n\t\tdescptr->skb_ptr = NULL;\n\t\t \n\t\tdescptr = descptr->vndescp;\n\t\tpriv->tx_free_desc++;\n\t}\n\tpriv->tx_remove_ptr = descptr;\n\n\tif (priv->tx_free_desc)\n\t\tnetif_wake_queue(dev);\n\tspin_unlock(&priv->lock);\n}\n\nstatic int r6040_poll(struct napi_struct *napi, int budget)\n{\n\tstruct r6040_private *priv =\n\t\tcontainer_of(napi, struct r6040_private, napi);\n\tstruct net_device *dev = priv->dev;\n\tvoid __iomem *ioaddr = priv->base;\n\tint work_done;\n\n\tr6040_tx(dev);\n\n\twork_done = r6040_rx(dev, budget);\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\t \n\t\tiowrite16(ioread16(ioaddr + MIER) | RX_INTS | TX_INTS,\n\t\t\t  ioaddr + MIER);\n\t}\n\treturn work_done;\n}\n\n \nstatic irqreturn_t r6040_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tu16 misr, status;\n\n\t \n\tmisr = ioread16(ioaddr + MIER);\n\t \n\tiowrite16(MSK_INT, ioaddr + MIER);\n\t \n\tstatus = ioread16(ioaddr + MISR);\n\n\tif (status == 0x0000 || status == 0xffff) {\n\t\t \n\t\tiowrite16(misr, ioaddr + MIER);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (status & (RX_INTS | TX_INTS)) {\n\t\tif (status & RX_NO_DESC) {\n\t\t\t \n\t\t\tdev->stats.rx_dropped++;\n\t\t\tdev->stats.rx_missed_errors++;\n\t\t}\n\t\tif (status & RX_FIFO_FULL)\n\t\t\tdev->stats.rx_fifo_errors++;\n\n\t\tif (likely(napi_schedule_prep(&lp->napi))) {\n\t\t\t \n\t\t\tmisr &= ~(RX_INTS | TX_INTS);\n\t\t\t__napi_schedule_irqoff(&lp->napi);\n\t\t}\n\t}\n\n\t \n\tiowrite16(misr, ioaddr + MIER);\n\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void r6040_poll_controller(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\tr6040_interrupt(dev->irq, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n\n \nstatic int r6040_up(struct net_device *dev)\n{\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tint ret;\n\n\t \n\tr6040_init_txbufs(dev);\n\tret = r6040_alloc_rxbufs(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tr6040_phy_write(ioaddr, 30, 17,\n\t\t\t(r6040_phy_read(ioaddr, 30, 17) | 0x4000));\n\tr6040_phy_write(ioaddr, 30, 17,\n\t\t\t~((~r6040_phy_read(ioaddr, 30, 17)) | 0x2000));\n\tr6040_phy_write(ioaddr, 0, 19, 0x0000);\n\tr6040_phy_write(ioaddr, 0, 30, 0x01F0);\n\n\t \n\tr6040_init_mac_regs(dev);\n\n\tphy_start(dev->phydev);\n\n\treturn 0;\n}\n\n\n \nstatic void r6040_mac_address(struct net_device *dev)\n{\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tconst u16 *adrp;\n\n\t \n\tr6040_reset_mac(lp);\n\n\t \n\tadrp = (const u16 *) dev->dev_addr;\n\tiowrite16(adrp[0], ioaddr + MID_0L);\n\tiowrite16(adrp[1], ioaddr + MID_0M);\n\tiowrite16(adrp[2], ioaddr + MID_0H);\n}\n\nstatic int r6040_open(struct net_device *dev)\n{\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tint ret;\n\n\t \n\tret = request_irq(dev->irq, r6040_interrupt,\n\t\tIRQF_SHARED, dev->name, dev);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tr6040_mac_address(dev);\n\n\t \n\tlp->rx_ring =\n\t\tdma_alloc_coherent(&lp->pdev->dev, RX_DESC_SIZE,\n\t\t\t\t   &lp->rx_ring_dma, GFP_KERNEL);\n\tif (!lp->rx_ring) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_irq;\n\t}\n\n\tlp->tx_ring =\n\t\tdma_alloc_coherent(&lp->pdev->dev, TX_DESC_SIZE,\n\t\t\t\t   &lp->tx_ring_dma, GFP_KERNEL);\n\tif (!lp->tx_ring) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_rx_ring;\n\t}\n\n\tret = r6040_up(dev);\n\tif (ret)\n\t\tgoto err_free_tx_ring;\n\n\tnapi_enable(&lp->napi);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n\nerr_free_tx_ring:\n\tdma_free_coherent(&lp->pdev->dev, TX_DESC_SIZE, lp->tx_ring,\n\t\t\t  lp->tx_ring_dma);\nerr_free_rx_ring:\n\tdma_free_coherent(&lp->pdev->dev, RX_DESC_SIZE, lp->rx_ring,\n\t\t\t  lp->rx_ring_dma);\nerr_free_irq:\n\tfree_irq(dev->irq, dev);\nout:\n\treturn ret;\n}\n\nstatic netdev_tx_t r6040_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tstruct r6040_descriptor *descptr;\n\tvoid __iomem *ioaddr = lp->base;\n\tunsigned long flags;\n\n\tif (skb_put_padto(skb, ETH_ZLEN) < 0)\n\t\treturn NETDEV_TX_OK;\n\n\t \n\tspin_lock_irqsave(&lp->lock, flags);\n\n\t \n\tif (!lp->tx_free_desc) {\n\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\t\tnetif_stop_queue(dev);\n\t\tnetdev_err(dev, \": no tx descriptor\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tlp->tx_free_desc--;\n\tdescptr = lp->tx_insert_ptr;\n\tdescptr->len = skb->len;\n\tdescptr->skb_ptr = skb;\n\tdescptr->buf = cpu_to_le32(dma_map_single(&lp->pdev->dev, skb->data,\n\t\t\t\t\t\t  skb->len, DMA_TO_DEVICE));\n\tdescptr->status = DSC_OWNER_MAC;\n\n\tskb_tx_timestamp(skb);\n\n\t \n\tif (!netdev_xmit_more() || netif_queue_stopped(dev))\n\t\tiowrite16(TM2TX, ioaddr + MTPR);\n\tlp->tx_insert_ptr = descptr->vndescp;\n\n\t \n\tif (!lp->tx_free_desc)\n\t\tnetif_stop_queue(dev);\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void r6040_multicast_list(struct net_device *dev)\n{\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = lp->base;\n\tunsigned long flags;\n\tstruct netdev_hw_addr *ha;\n\tint i;\n\tconst u16 *adrp;\n\tu16 hash_table[4] = { 0 };\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\t \n\tadrp = (const u16 *)dev->dev_addr;\n\tiowrite16(adrp[0], ioaddr + MID_0L);\n\tiowrite16(adrp[1], ioaddr + MID_0M);\n\tiowrite16(adrp[2], ioaddr + MID_0H);\n\n\t \n\tlp->mcr0 = ioread16(ioaddr + MCR0) & ~(MCR0_PROMISC | MCR0_HASH_EN);\n\n\t \n\tif (dev->flags & IFF_PROMISC)\n\t\tlp->mcr0 |= MCR0_PROMISC;\n\n\t \n\telse if (dev->flags & IFF_ALLMULTI) {\n\t\tlp->mcr0 |= MCR0_HASH_EN;\n\n\t\tfor (i = 0; i < MCAST_MAX ; i++) {\n\t\t\tiowrite16(0, ioaddr + MID_1L + 8 * i);\n\t\t\tiowrite16(0, ioaddr + MID_1M + 8 * i);\n\t\t\tiowrite16(0, ioaddr + MID_1H + 8 * i);\n\t\t}\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\thash_table[i] = 0xffff;\n\t}\n\t \n\telse if (netdev_mc_count(dev) <= MCAST_MAX) {\n\t\ti = 0;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tu16 *adrp = (u16 *) ha->addr;\n\t\t\tiowrite16(adrp[0], ioaddr + MID_1L + 8 * i);\n\t\t\tiowrite16(adrp[1], ioaddr + MID_1M + 8 * i);\n\t\t\tiowrite16(adrp[2], ioaddr + MID_1H + 8 * i);\n\t\t\ti++;\n\t\t}\n\t\twhile (i < MCAST_MAX) {\n\t\t\tiowrite16(0, ioaddr + MID_1L + 8 * i);\n\t\t\tiowrite16(0, ioaddr + MID_1M + 8 * i);\n\t\t\tiowrite16(0, ioaddr + MID_1H + 8 * i);\n\t\t\ti++;\n\t\t}\n\t}\n\t \n\telse {\n\t\tu32 crc;\n\n\t\tlp->mcr0 |= MCR0_HASH_EN;\n\n\t\tfor (i = 0; i < MCAST_MAX ; i++) {\n\t\t\tiowrite16(0, ioaddr + MID_1L + 8 * i);\n\t\t\tiowrite16(0, ioaddr + MID_1M + 8 * i);\n\t\t\tiowrite16(0, ioaddr + MID_1H + 8 * i);\n\t\t}\n\n\t\t \n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tu8 *addrs = ha->addr;\n\n\t\t\tcrc = ether_crc(ETH_ALEN, addrs);\n\t\t\tcrc >>= 26;\n\t\t\thash_table[crc >> 4] |= 1 << (crc & 0xf);\n\t\t}\n\t}\n\n\tiowrite16(lp->mcr0, ioaddr + MCR0);\n\n\t \n\tif (lp->mcr0 & MCR0_HASH_EN) {\n\t\tiowrite16(hash_table[0], ioaddr + MAR0);\n\t\tiowrite16(hash_table[1], ioaddr + MAR1);\n\t\tiowrite16(hash_table[2], ioaddr + MAR2);\n\t\tiowrite16(hash_table[3], ioaddr + MAR3);\n\t}\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\n}\n\nstatic void netdev_get_drvinfo(struct net_device *dev,\n\t\t\tstruct ethtool_drvinfo *info)\n{\n\tstruct r6040_private *rp = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(rp->pdev), sizeof(info->bus_info));\n}\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.get_drvinfo\t\t= netdev_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_link_ksettings     = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings     = phy_ethtool_set_link_ksettings,\n\t.nway_reset\t\t= phy_ethtool_nway_reset,\n};\n\nstatic const struct net_device_ops r6040_netdev_ops = {\n\t.ndo_open\t\t= r6040_open,\n\t.ndo_stop\t\t= r6040_close,\n\t.ndo_start_xmit\t\t= r6040_start_xmit,\n\t.ndo_get_stats\t\t= r6040_get_stats,\n\t.ndo_set_rx_mode\t= r6040_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl,\n\t.ndo_tx_timeout\t\t= r6040_tx_timeout,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= r6040_poll_controller,\n#endif\n};\n\nstatic void r6040_adjust_link(struct net_device *dev)\n{\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tint status_changed = 0;\n\tvoid __iomem *ioaddr = lp->base;\n\n\tBUG_ON(!phydev);\n\n\tif (lp->old_link != phydev->link) {\n\t\tstatus_changed = 1;\n\t\tlp->old_link = phydev->link;\n\t}\n\n\t \n\tif (phydev->link && (lp->old_duplex != phydev->duplex)) {\n\t\tlp->mcr0 |= (phydev->duplex == DUPLEX_FULL ? MCR0_FD : 0);\n\t\tiowrite16(lp->mcr0, ioaddr);\n\n\t\tstatus_changed = 1;\n\t\tlp->old_duplex = phydev->duplex;\n\t}\n\n\tif (status_changed)\n\t\tphy_print_status(phydev);\n}\n\nstatic int r6040_mii_probe(struct net_device *dev)\n{\n\tstruct r6040_private *lp = netdev_priv(dev);\n\tstruct phy_device *phydev = NULL;\n\n\tphydev = phy_find_first(lp->mii_bus);\n\tif (!phydev) {\n\t\tdev_err(&lp->pdev->dev, \"no PHY found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tphydev = phy_connect(dev, phydev_name(phydev), &r6040_adjust_link,\n\t\t\t     PHY_INTERFACE_MODE_MII);\n\n\tif (IS_ERR(phydev)) {\n\t\tdev_err(&lp->pdev->dev, \"could not attach to PHY\\n\");\n\t\treturn PTR_ERR(phydev);\n\t}\n\n\tphy_set_max_speed(phydev, SPEED_100);\n\n\tlp->old_link = 0;\n\tlp->old_duplex = -1;\n\n\tphy_attached_info(phydev);\n\n\treturn 0;\n}\n\nstatic int r6040_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct r6040_private *lp;\n\tvoid __iomem *ioaddr;\n\tint err, io_size = R6040_IO_SIZE;\n\tstatic int card_idx = -1;\n\tu16 addr[ETH_ALEN / 2];\n\tint bar = 0;\n\n\tpr_info(\"%s\\n\", version);\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\tgoto err_out;\n\n\t \n\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"32-bit PCI DMA addresses not supported by the card\\n\");\n\t\tgoto err_out_disable_dev;\n\t}\n\terr = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"32-bit PCI DMA addresses not supported by the card\\n\");\n\t\tgoto err_out_disable_dev;\n\t}\n\n\t \n\tif (pci_resource_len(pdev, bar) < io_size) {\n\t\tdev_err(&pdev->dev, \"Insufficient PCI resources, aborting\\n\");\n\t\terr = -EIO;\n\t\tgoto err_out_disable_dev;\n\t}\n\n\tpci_set_master(pdev);\n\n\tdev = alloc_etherdev(sizeof(struct r6040_private));\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_disable_dev;\n\t}\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tlp = netdev_priv(dev);\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to request PCI regions\\n\");\n\t\tgoto err_out_free_dev;\n\t}\n\n\tioaddr = pci_iomap(pdev, bar, io_size);\n\tif (!ioaddr) {\n\t\tdev_err(&pdev->dev, \"ioremap failed for device\\n\");\n\t\terr = -EIO;\n\t\tgoto err_out_free_res;\n\t}\n\n\t \n\tif (ioread16(ioaddr + PHY_CC) == 0)\n\t\tiowrite16(SCEN | PHY_MAX_ADDR << PHYAD_SHIFT |\n\t\t\t\t7 << TMRDIV_SHIFT, ioaddr + PHY_CC);\n\n\t \n\tlp->base = ioaddr;\n\tdev->irq = pdev->irq;\n\n\tspin_lock_init(&lp->lock);\n\tpci_set_drvdata(pdev, dev);\n\n\t \n\tcard_idx++;\n\n\taddr[0] = ioread16(ioaddr + MID_0L);\n\taddr[1] = ioread16(ioaddr + MID_0M);\n\taddr[2] = ioread16(ioaddr + MID_0H);\n\teth_hw_addr_set(dev, (u8 *)addr);\n\n\t \n\tif (!(addr[0] || addr[1] || addr[2])) {\n\t\tnetdev_warn(dev, \"MAC address not initialized, \"\n\t\t\t\t\t\"generating random\\n\");\n\t\teth_hw_addr_random(dev);\n\t}\n\n\t \n\tlp->pdev = pdev;\n\tlp->dev = dev;\n\n\t \n\tlp->mcr0 = MCR0_XMTEN | MCR0_RCVEN;\n\n\t \n\tdev->netdev_ops = &r6040_netdev_ops;\n\tdev->ethtool_ops = &netdev_ethtool_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\tnetif_napi_add(dev, &lp->napi, r6040_poll);\n\n\tlp->mii_bus = mdiobus_alloc();\n\tif (!lp->mii_bus) {\n\t\tdev_err(&pdev->dev, \"mdiobus_alloc() failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_unmap;\n\t}\n\n\tlp->mii_bus->priv = dev;\n\tlp->mii_bus->read = r6040_mdiobus_read;\n\tlp->mii_bus->write = r6040_mdiobus_write;\n\tlp->mii_bus->name = \"r6040_eth_mii\";\n\tsnprintf(lp->mii_bus->id, MII_BUS_ID_SIZE, \"%s-%x\",\n\t\tdev_name(&pdev->dev), card_idx);\n\n\terr = mdiobus_register(lp->mii_bus);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to register MII bus\\n\");\n\t\tgoto err_out_mdio;\n\t}\n\n\terr = r6040_mii_probe(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to probe MII bus\\n\");\n\t\tgoto err_out_mdio_unregister;\n\t}\n\n\t \n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to register net device\\n\");\n\t\tgoto err_out_phy_disconnect;\n\t}\n\treturn 0;\n\nerr_out_phy_disconnect:\n\tphy_disconnect(dev->phydev);\nerr_out_mdio_unregister:\n\tmdiobus_unregister(lp->mii_bus);\nerr_out_mdio:\n\tmdiobus_free(lp->mii_bus);\nerr_out_unmap:\n\tnetif_napi_del(&lp->napi);\n\tpci_iounmap(pdev, ioaddr);\nerr_out_free_res:\n\tpci_release_regions(pdev);\nerr_out_free_dev:\n\tfree_netdev(dev);\nerr_out_disable_dev:\n\tpci_disable_device(pdev);\nerr_out:\n\treturn err;\n}\n\nstatic void r6040_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct r6040_private *lp = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\tphy_disconnect(dev->phydev);\n\tmdiobus_unregister(lp->mii_bus);\n\tmdiobus_free(lp->mii_bus);\n\tnetif_napi_del(&lp->napi);\n\tpci_iounmap(pdev, lp->base);\n\tpci_release_regions(pdev);\n\tfree_netdev(dev);\n\tpci_disable_device(pdev);\n}\n\n\nstatic const struct pci_device_id r6040_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_RDC, 0x6040) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, r6040_pci_tbl);\n\nstatic struct pci_driver r6040_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= r6040_pci_tbl,\n\t.probe\t\t= r6040_init_one,\n\t.remove\t\t= r6040_remove_one,\n};\n\nmodule_pci_driver(r6040_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}