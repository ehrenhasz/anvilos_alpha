{
  "module_name": "cs89x0.c",
  "hash_id": "e22289b2cde250bb848f9f838a7601081de3bffd954fd761ef625d34c6ed2c92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cirrus/cs89x0.c",
  "human_readable_source": " \n\n\n \n#ifndef CONFIG_ISA_DMA_API\n#define ALLOW_DMA\t0\n#else\n#define ALLOW_DMA\t1\n#endif\n\n \n#define DEBUGGING\t1\n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/jiffies.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <linux/io.h>\n\n#include <net/Space.h>\n\n#include <asm/irq.h>\n#include <linux/atomic.h>\n#if ALLOW_DMA\n#include <asm/dma.h>\n#endif\n\n#include \"cs89x0.h\"\n\n#define cs89_dbg(val, level, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (val <= net_debug)\t\t\t\t\t\\\n\t\tpr_##level(fmt, ##__VA_ARGS__);\t\t\t\\\n} while (0)\n\nstatic char version[] __initdata =\n\t\"v2.4.3-pre1 Russell Nelson <nelson@crynwr.com>, Andrew Morton\";\n\n#define DRV_NAME \"cs89x0\"\n\n \n \n#if IS_ENABLED(CONFIG_CS89x0_ISA)\nstatic unsigned int netcard_portlist[] __used __initdata = {\n\t0x300, 0x320, 0x340, 0x360, 0x200, 0x220, 0x240,\n\t0x260, 0x280, 0x2a0, 0x2c0, 0x2e0, 0\n};\nstatic unsigned int cs8900_irq_map[] = {\n\t10, 11, 12, 5\n};\n#endif\n\n#if DEBUGGING\nstatic unsigned int net_debug = DEBUGGING;\n#else\n#define net_debug 0\t \n#endif\n\n \n#define NETCARD_IO_EXTENT\t16\n\n \n#define FORCE_RJ45\t0x0001     \n#define FORCE_AUI\t0x0002\n#define FORCE_BNC\t0x0004\n\n#define FORCE_AUTO\t0x0010     \n#define FORCE_HALF\t0x0020\n#define FORCE_FULL\t0x0030\n\n \nstruct net_local {\n\tint chip_type;\t\t \n\tchar chip_revision;\t \n\tint send_cmd;\t\t \n\tint auto_neg_cnf;\t \n\tint adapter_cnf;\t \n\tint isa_config;\t\t \n\tint irq_map;\t\t \n\tint rx_mode;\t\t \n\tint curr_rx_cfg;\t \n\tint linectl;\t\t \n\tint send_underrun;\t \n\tint force;\t\t \n\tspinlock_t lock;\n\tvoid __iomem *virt_addr; \n#if ALLOW_DMA\n\tint use_dma;\t\t \n\tint dma;\t\t \n\tint dmasize;\t\t \n\tunsigned char *dma_buff;\t \n\tunsigned char *end_dma_buff;\t \n\tunsigned char *rx_dma_ptr;\t \n#endif\n};\n\n \n#define tx_done(dev) 1\n\n \n#if !defined(MODULE)\n#if ALLOW_DMA\nstatic int g_cs89x0_dma;\n\nstatic int __init dma_fn(char *str)\n{\n\tg_cs89x0_dma = simple_strtol(str, NULL, 0);\n\treturn 1;\n}\n\n__setup(\"cs89x0_dma=\", dma_fn);\n#endif\t \n\nstatic int g_cs89x0_media__force;\n\nstatic int __init media_fn(char *str)\n{\n\tif (!strcmp(str, \"rj45\"))\n\t\tg_cs89x0_media__force = FORCE_RJ45;\n\telse if (!strcmp(str, \"aui\"))\n\t\tg_cs89x0_media__force = FORCE_AUI;\n\telse if (!strcmp(str, \"bnc\"))\n\t\tg_cs89x0_media__force = FORCE_BNC;\n\n\treturn 1;\n}\n\n__setup(\"cs89x0_media=\", media_fn);\n#endif\n\nstatic void readwords(struct net_local *lp, int portno, void *buf, int length)\n{\n\tu8 *buf8 = (u8 *)buf;\n\n\tdo {\n\t\tu16 tmp16;\n\n\t\ttmp16 = ioread16(lp->virt_addr + portno);\n\t\t*buf8++ = (u8)tmp16;\n\t\t*buf8++ = (u8)(tmp16 >> 8);\n\t} while (--length);\n}\n\nstatic void writewords(struct net_local *lp, int portno, void *buf, int length)\n{\n\tu8 *buf8 = (u8 *)buf;\n\n\tdo {\n\t\tu16 tmp16;\n\n\t\ttmp16 = *buf8++;\n\t\ttmp16 |= (*buf8++) << 8;\n\t\tiowrite16(tmp16, lp->virt_addr + portno);\n\t} while (--length);\n}\n\nstatic u16\nreadreg(struct net_device *dev, u16 regno)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\n\tiowrite16(regno, lp->virt_addr + ADD_PORT);\n\treturn ioread16(lp->virt_addr + DATA_PORT);\n}\n\nstatic void\nwritereg(struct net_device *dev, u16 regno, u16 value)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\n\tiowrite16(regno, lp->virt_addr + ADD_PORT);\n\tiowrite16(value, lp->virt_addr + DATA_PORT);\n}\n\nstatic int __init\nwait_eeprom_ready(struct net_device *dev)\n{\n\tunsigned long timeout = jiffies;\n\t \n\twhile (readreg(dev, PP_SelfST) & SI_BUSY)\n\t\tif (time_after_eq(jiffies, timeout + 40))\n\t\t\treturn -1;\n\treturn 0;\n}\n\nstatic int __init\nget_eeprom_data(struct net_device *dev, int off, int len, int *buffer)\n{\n\tint i;\n\n\tcs89_dbg(3, info, \"EEPROM data from %x for %x:\", off, len);\n\tfor (i = 0; i < len; i++) {\n\t\tif (wait_eeprom_ready(dev) < 0)\n\t\t\treturn -1;\n\t\t \n\t\twritereg(dev, PP_EECMD, (off + i) | EEPROM_READ_CMD);\n\t\tif (wait_eeprom_ready(dev) < 0)\n\t\t\treturn -1;\n\t\tbuffer[i] = readreg(dev, PP_EEData);\n\t\tcs89_dbg(3, cont, \" %04x\", buffer[i]);\n\t}\n\tcs89_dbg(3, cont, \"\\n\");\n\treturn 0;\n}\n\nstatic int  __init\nget_eeprom_cksum(int off, int len, int *buffer)\n{\n\tint i, cksum;\n\n\tcksum = 0;\n\tfor (i = 0; i < len; i++)\n\t\tcksum += buffer[i];\n\tcksum &= 0xffff;\n\tif (cksum == 0)\n\t\treturn 0;\n\treturn -1;\n}\n\nstatic void\nwrite_irq(struct net_device *dev, int chip_type, int irq)\n{\n\tint i;\n\n\tif (chip_type == CS8900) {\n#if IS_ENABLED(CONFIG_CS89x0_ISA)\n\t\t \n\t\tfor (i = 0; i != ARRAY_SIZE(cs8900_irq_map); i++)\n\t\t\tif (cs8900_irq_map[i] == irq)\n\t\t\t\tbreak;\n\t\t \n\t\tif (i == ARRAY_SIZE(cs8900_irq_map))\n\t\t\ti = 3;\n#else\n\t\t \n\t\ti = 0;\n#endif\n\t\twritereg(dev, PP_CS8900_ISAINT, i);\n\t} else {\n\t\twritereg(dev, PP_CS8920_ISAINT, irq);\n\t}\n}\n\nstatic void\ncount_rx_errors(int status, struct net_device *dev)\n{\n\tdev->stats.rx_errors++;\n\tif (status & RX_RUNT)\n\t\tdev->stats.rx_length_errors++;\n\tif (status & RX_EXTRA_DATA)\n\t\tdev->stats.rx_length_errors++;\n\tif ((status & RX_CRC_ERROR) && !(status & (RX_EXTRA_DATA | RX_RUNT)))\n\t\t \n\t\tdev->stats.rx_crc_errors++;\n\tif (status & RX_DRIBBLE)\n\t\tdev->stats.rx_frame_errors++;\n}\n\n \n\n#if ALLOW_DMA\n\n#define dma_page_eq(ptr1, ptr2) ((long)(ptr1) >> 17 == (long)(ptr2) >> 17)\n\nstatic void\nget_dma_channel(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\n\tif (lp->dma) {\n\t\tdev->dma = lp->dma;\n\t\tlp->isa_config |= ISA_RxDMA;\n\t} else {\n\t\tif ((lp->isa_config & ANY_ISA_DMA) == 0)\n\t\t\treturn;\n\t\tdev->dma = lp->isa_config & DMA_NO_MASK;\n\t\tif (lp->chip_type == CS8900)\n\t\t\tdev->dma += 5;\n\t\tif (dev->dma < 5 || dev->dma > 7) {\n\t\t\tlp->isa_config &= ~ANY_ISA_DMA;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void\nwrite_dma(struct net_device *dev, int chip_type, int dma)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tif ((lp->isa_config & ANY_ISA_DMA) == 0)\n\t\treturn;\n\tif (chip_type == CS8900)\n\t\twritereg(dev, PP_CS8900_ISADMA, dma - 5);\n\telse\n\t\twritereg(dev, PP_CS8920_ISADMA, dma);\n}\n\nstatic void\nset_dma_cfg(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\n\tif (lp->use_dma) {\n\t\tif ((lp->isa_config & ANY_ISA_DMA) == 0) {\n\t\t\tcs89_dbg(3, err, \"set_dma_cfg(): no DMA\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (lp->isa_config & ISA_RxDMA) {\n\t\t\tlp->curr_rx_cfg |= RX_DMA_ONLY;\n\t\t\tcs89_dbg(3, info, \"set_dma_cfg(): RX_DMA_ONLY\\n\");\n\t\t} else {\n\t\t\tlp->curr_rx_cfg |= AUTO_RX_DMA;\t \n\t\t\tcs89_dbg(3, info, \"set_dma_cfg(): AUTO_RX_DMA\\n\");\n\t\t}\n\t}\n}\n\nstatic int\ndma_bufcfg(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tif (lp->use_dma)\n\t\treturn (lp->isa_config & ANY_ISA_DMA) ? RX_DMA_ENBL : 0;\n\telse\n\t\treturn 0;\n}\n\nstatic int\ndma_busctl(struct net_device *dev)\n{\n\tint retval = 0;\n\tstruct net_local *lp = netdev_priv(dev);\n\tif (lp->use_dma) {\n\t\tif (lp->isa_config & ANY_ISA_DMA)\n\t\t\tretval |= RESET_RX_DMA;  \n\t\tif (lp->isa_config & DMA_BURST)\n\t\t\tretval |= DMA_BURST_MODE;  \n\t\tif (lp->dmasize == 64)\n\t\t\tretval |= RX_DMA_SIZE_64K;  \n\t\tretval |= MEMORY_ON;\t \n\t}\n\treturn retval;\n}\n\nstatic void\ndma_rx(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tint status, length;\n\tunsigned char *bp = lp->rx_dma_ptr;\n\n\tstatus = bp[0] + (bp[1] << 8);\n\tlength = bp[2] + (bp[3] << 8);\n\tbp += 4;\n\n\tcs89_dbg(5, debug, \"%s: receiving DMA packet at %lx, status %x, length %x\\n\",\n\t\t dev->name, (unsigned long)bp, status, length);\n\n\tif ((status & RX_OK) == 0) {\n\t\tcount_rx_errors(status, dev);\n\t\tgoto skip_this_frame;\n\t}\n\n\t \n\tskb = netdev_alloc_skb(dev, length + 2);\n\tif (skb == NULL) {\n\t\tdev->stats.rx_dropped++;\n\n\t\t \nskip_this_frame:\n\t\tbp += (length + 3) & ~3;\n\t\tif (bp >= lp->end_dma_buff)\n\t\t\tbp -= lp->dmasize * 1024;\n\t\tlp->rx_dma_ptr = bp;\n\t\treturn;\n\t}\n\tskb_reserve(skb, 2);\t \n\n\tif (bp + length > lp->end_dma_buff) {\n\t\tint semi_cnt = lp->end_dma_buff - bp;\n\t\tskb_put_data(skb, bp, semi_cnt);\n\t\tskb_put_data(skb, lp->dma_buff, length - semi_cnt);\n\t} else {\n\t\tskb_put_data(skb, bp, length);\n\t}\n\tbp += (length + 3) & ~3;\n\tif (bp >= lp->end_dma_buff)\n\t\tbp -= lp->dmasize*1024;\n\tlp->rx_dma_ptr = bp;\n\n\tcs89_dbg(3, info, \"%s: received %d byte DMA packet of type %x\\n\",\n\t\t dev->name, length,\n\t\t ((skb->data[ETH_ALEN + ETH_ALEN] << 8) |\n\t\t  skb->data[ETH_ALEN + ETH_ALEN + 1]));\n\n\tskb->protocol = eth_type_trans(skb, dev);\n\tnetif_rx(skb);\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += length;\n}\n\nstatic void release_dma_buff(struct net_local *lp)\n{\n\tif (lp->dma_buff) {\n\t\tfree_pages((unsigned long)(lp->dma_buff),\n\t\t\t   get_order(lp->dmasize * 1024));\n\t\tlp->dma_buff = NULL;\n\t}\n}\n\n#endif\t \n\nstatic void\ncontrol_dc_dc(struct net_device *dev, int on_not_off)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tunsigned int selfcontrol;\n\tunsigned long timenow = jiffies;\n\t \n\n\tselfcontrol = HCB1_ENBL;  \n\tif (((lp->adapter_cnf & A_CNF_DC_DC_POLARITY) != 0) ^ on_not_off)\n\t\tselfcontrol |= HCB1;\n\telse\n\t\tselfcontrol &= ~HCB1;\n\twritereg(dev, PP_SelfCTL, selfcontrol);\n\n\t \n\twhile (time_before(jiffies, timenow + HZ))\n\t\t;\n}\n\n \nstatic int\nsend_test_pkt(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tchar test_packet[] = {\n\t\t0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0,\n\t\t0, 46,\t\t \n\t\t0, 0,\t\t \n\t\t0xf3, 0\t\t \n\t};\n\tunsigned long timenow = jiffies;\n\n\twritereg(dev, PP_LineCTL, readreg(dev, PP_LineCTL) | SERIAL_TX_ON);\n\n\tmemcpy(test_packet,            dev->dev_addr, ETH_ALEN);\n\tmemcpy(test_packet + ETH_ALEN, dev->dev_addr, ETH_ALEN);\n\n\tiowrite16(TX_AFTER_ALL, lp->virt_addr + TX_CMD_PORT);\n\tiowrite16(ETH_ZLEN, lp->virt_addr + TX_LEN_PORT);\n\n\t \n\twhile (time_before(jiffies, timenow + 5))\n\t\tif (readreg(dev, PP_BusST) & READY_FOR_TX_NOW)\n\t\t\tbreak;\n\tif (time_after_eq(jiffies, timenow + 5))\n\t\treturn 0;\t \n\n\t \n\twritewords(lp, TX_FRAME_PORT, test_packet, (ETH_ZLEN + 1) >> 1);\n\n\tcs89_dbg(1, debug, \"Sending test packet \");\n\t \n\tfor (timenow = jiffies; time_before(jiffies, timenow + 3);)\n\t\t;\n\tif ((readreg(dev, PP_TxEvent) & TX_SEND_OK_BITS) == TX_OK) {\n\t\tcs89_dbg(1, cont, \"succeeded\\n\");\n\t\treturn 1;\n\t}\n\tcs89_dbg(1, cont, \"failed\\n\");\n\treturn 0;\n}\n\n#define DETECTED_NONE  0\n#define DETECTED_RJ45H 1\n#define DETECTED_RJ45F 2\n#define DETECTED_AUI   3\n#define DETECTED_BNC   4\n\nstatic int\ndetect_tp(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tunsigned long timenow = jiffies;\n\tint fdx;\n\n\tcs89_dbg(1, debug, \"%s: Attempting TP\\n\", dev->name);\n\n\t \n\twritereg(dev, PP_LineCTL, lp->linectl & ~AUI_ONLY);\n\tcontrol_dc_dc(dev, 0);\n\n\t \n\tfor (timenow = jiffies; time_before(jiffies, timenow + 15);)\n\t\t;\n\tif ((readreg(dev, PP_LineST) & LINK_OK) == 0)\n\t\treturn DETECTED_NONE;\n\n\tif (lp->chip_type == CS8900) {\n\t\tswitch (lp->force & 0xf0) {\n#if 0\n\t\tcase FORCE_AUTO:\n\t\t\tpr_info(\"%s: cs8900 doesn't autonegotiate\\n\",\n\t\t\t\tdev->name);\n\t\t\treturn DETECTED_NONE;\n#endif\n\t\t\t \n\t\tcase FORCE_AUTO:\n\t\t\tlp->force &= ~FORCE_AUTO;\n\t\t\tlp->force |= FORCE_HALF;\n\t\t\tbreak;\n\t\tcase FORCE_HALF:\n\t\t\tbreak;\n\t\tcase FORCE_FULL:\n\t\t\twritereg(dev, PP_TestCTL,\n\t\t\t\t readreg(dev, PP_TestCTL) | FDX_8900);\n\t\t\tbreak;\n\t\t}\n\t\tfdx = readreg(dev, PP_TestCTL) & FDX_8900;\n\t} else {\n\t\tswitch (lp->force & 0xf0) {\n\t\tcase FORCE_AUTO:\n\t\t\tlp->auto_neg_cnf = AUTO_NEG_ENABLE;\n\t\t\tbreak;\n\t\tcase FORCE_HALF:\n\t\t\tlp->auto_neg_cnf = 0;\n\t\t\tbreak;\n\t\tcase FORCE_FULL:\n\t\t\tlp->auto_neg_cnf = RE_NEG_NOW | ALLOW_FDX;\n\t\t\tbreak;\n\t\t}\n\n\t\twritereg(dev, PP_AutoNegCTL, lp->auto_neg_cnf & AUTO_NEG_MASK);\n\n\t\tif ((lp->auto_neg_cnf & AUTO_NEG_BITS) == AUTO_NEG_ENABLE) {\n\t\t\tpr_info(\"%s: negotiating duplex...\\n\", dev->name);\n\t\t\twhile (readreg(dev, PP_AutoNegST) & AUTO_NEG_BUSY) {\n\t\t\t\tif (time_after(jiffies, timenow + 4000)) {\n\t\t\t\t\tpr_err(\"**** Full / half duplex auto-negotiation timed out ****\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfdx = readreg(dev, PP_AutoNegST) & FDX_ACTIVE;\n\t}\n\tif (fdx)\n\t\treturn DETECTED_RJ45F;\n\telse\n\t\treturn DETECTED_RJ45H;\n}\n\nstatic int\ndetect_bnc(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\n\tcs89_dbg(1, debug, \"%s: Attempting BNC\\n\", dev->name);\n\tcontrol_dc_dc(dev, 1);\n\n\twritereg(dev, PP_LineCTL, (lp->linectl & ~AUTO_AUI_10BASET) | AUI_ONLY);\n\n\tif (send_test_pkt(dev))\n\t\treturn DETECTED_BNC;\n\telse\n\t\treturn DETECTED_NONE;\n}\n\nstatic int\ndetect_aui(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\n\tcs89_dbg(1, debug, \"%s: Attempting AUI\\n\", dev->name);\n\tcontrol_dc_dc(dev, 0);\n\n\twritereg(dev, PP_LineCTL, (lp->linectl & ~AUTO_AUI_10BASET) | AUI_ONLY);\n\n\tif (send_test_pkt(dev))\n\t\treturn DETECTED_AUI;\n\telse\n\t\treturn DETECTED_NONE;\n}\n\n \nstatic void\nnet_rx(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tint status, length;\n\n\tstatus = ioread16(lp->virt_addr + RX_FRAME_PORT);\n\tlength = ioread16(lp->virt_addr + RX_FRAME_PORT);\n\n\tif ((status & RX_OK) == 0) {\n\t\tcount_rx_errors(status, dev);\n\t\treturn;\n\t}\n\n\t \n\tskb = netdev_alloc_skb(dev, length + 2);\n\tif (skb == NULL) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\tskb_reserve(skb, 2);\t \n\n\treadwords(lp, RX_FRAME_PORT, skb_put(skb, length), length >> 1);\n\tif (length & 1)\n\t\tskb->data[length-1] = ioread16(lp->virt_addr + RX_FRAME_PORT);\n\n\tcs89_dbg(3, debug, \"%s: received %d byte packet of type %x\\n\",\n\t\t dev->name, length,\n\t\t (skb->data[ETH_ALEN + ETH_ALEN] << 8) |\n\t\t skb->data[ETH_ALEN + ETH_ALEN + 1]);\n\n\tskb->protocol = eth_type_trans(skb, dev);\n\tnetif_rx(skb);\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += length;\n}\n\n \n\nstatic irqreturn_t net_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct net_local *lp;\n\tint status;\n\tint handled = 0;\n\n\tlp = netdev_priv(dev);\n\n\t \n\twhile ((status = ioread16(lp->virt_addr + ISQ_PORT))) {\n\t\tcs89_dbg(4, debug, \"%s: event=%04x\\n\", dev->name, status);\n\t\thandled = 1;\n\t\tswitch (status & ISQ_EVENT_MASK) {\n\t\tcase ISQ_RECEIVER_EVENT:\n\t\t\t \n\t\t\tnet_rx(dev);\n\t\t\tbreak;\n\t\tcase ISQ_TRANSMITTER_EVENT:\n\t\t\tdev->stats.tx_packets++;\n\t\t\tnetif_wake_queue(dev);\t \n\t\t\tif ((status & (TX_OK |\n\t\t\t\t       TX_LOST_CRS |\n\t\t\t\t       TX_SQE_ERROR |\n\t\t\t\t       TX_LATE_COL |\n\t\t\t\t       TX_16_COL)) != TX_OK) {\n\t\t\t\tif ((status & TX_OK) == 0)\n\t\t\t\t\tdev->stats.tx_errors++;\n\t\t\t\tif (status & TX_LOST_CRS)\n\t\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\t\tif (status & TX_SQE_ERROR)\n\t\t\t\t\tdev->stats.tx_heartbeat_errors++;\n\t\t\t\tif (status & TX_LATE_COL)\n\t\t\t\t\tdev->stats.tx_window_errors++;\n\t\t\t\tif (status & TX_16_COL)\n\t\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ISQ_BUFFER_EVENT:\n\t\t\tif (status & READY_FOR_TX) {\n\t\t\t\t \n\t\t\t\tnetif_wake_queue(dev);\t \n\t\t\t}\n\t\t\tif (status & TX_UNDERRUN) {\n\t\t\t\tcs89_dbg(0, err, \"%s: transmit underrun\\n\",\n\t\t\t\t\t dev->name);\n\t\t\t\tlp->send_underrun++;\n\t\t\t\tif (lp->send_underrun == 3)\n\t\t\t\t\tlp->send_cmd = TX_AFTER_381;\n\t\t\t\telse if (lp->send_underrun == 6)\n\t\t\t\t\tlp->send_cmd = TX_AFTER_ALL;\n\t\t\t\t \n\t\t\t\tnetif_wake_queue(dev);\t \n\t\t\t}\n#if ALLOW_DMA\n\t\t\tif (lp->use_dma && (status & RX_DMA)) {\n\t\t\t\tint count = readreg(dev, PP_DmaFrameCnt);\n\t\t\t\twhile (count) {\n\t\t\t\t\tcs89_dbg(5, debug,\n\t\t\t\t\t\t \"%s: receiving %d DMA frames\\n\",\n\t\t\t\t\t\t dev->name, count);\n\t\t\t\t\tif (count > 1)\n\t\t\t\t\t\tcs89_dbg(2, debug,\n\t\t\t\t\t\t\t \"%s: receiving %d DMA frames\\n\",\n\t\t\t\t\t\t\t dev->name, count);\n\t\t\t\t\tdma_rx(dev);\n\t\t\t\t\tif (--count == 0)\n\t\t\t\t\t\tcount = readreg(dev, PP_DmaFrameCnt);\n\t\t\t\t\tif (count > 0)\n\t\t\t\t\t\tcs89_dbg(2, debug,\n\t\t\t\t\t\t\t \"%s: continuing with %d DMA frames\\n\",\n\t\t\t\t\t\t\t dev->name, count);\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ISQ_RX_MISS_EVENT:\n\t\t\tdev->stats.rx_missed_errors += (status >> 6);\n\t\t\tbreak;\n\t\tcase ISQ_TX_COL_EVENT:\n\t\t\tdev->stats.collisions += (status >> 6);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn IRQ_RETVAL(handled);\n}\n\n \n\n \n\nstatic int\nnet_open(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tint result = 0;\n\tint i;\n\tint ret;\n\n\tif (dev->irq < 2) {\n\t\t \n \n#if 0\n\t\twritereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL) | ENABLE_IRQ);\n#endif\n \n\t\twritereg(dev, PP_BusCTL, ENABLE_IRQ | MEMORY_ON);\n\n\t\tfor (i = 2; i < CS8920_NO_INTS; i++) {\n\t\t\tif ((1 << i) & lp->irq_map) {\n\t\t\t\tif (request_irq(i, net_interrupt, 0, dev->name,\n\t\t\t\t\t\tdev) == 0) {\n\t\t\t\t\tdev->irq = i;\n\t\t\t\t\twrite_irq(dev, lp->chip_type, i);\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (i >= CS8920_NO_INTS) {\n\t\t\twritereg(dev, PP_BusCTL, 0);\t \n\t\t\tpr_err(\"can't get an interrupt\\n\");\n\t\t\tret = -EAGAIN;\n\t\t\tgoto bad_out;\n\t\t}\n\t} else {\n#if IS_ENABLED(CONFIG_CS89x0_ISA)\n\t\tif (((1 << dev->irq) & lp->irq_map) == 0) {\n\t\t\tpr_err(\"%s: IRQ %d is not in our map of allowable IRQs, which is %x\\n\",\n\t\t\t       dev->name, dev->irq, lp->irq_map);\n\t\t\tret = -EAGAIN;\n\t\t\tgoto bad_out;\n\t\t}\n#endif\n \n\t\twritereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ);\n \n#if 0\n\t\twritereg(dev, PP_BusCTL, ENABLE_IRQ | MEMORY_ON);\n#endif\n\t\twrite_irq(dev, lp->chip_type, dev->irq);\n\t\tret = request_irq(dev->irq, net_interrupt, 0, dev->name, dev);\n\t\tif (ret) {\n\t\t\tpr_err(\"request_irq(%d) failed\\n\", dev->irq);\n\t\t\tgoto bad_out;\n\t\t}\n\t}\n\n#if ALLOW_DMA\n\tif (lp->use_dma && (lp->isa_config & ANY_ISA_DMA)) {\n\t\tunsigned long flags;\n\t\tlp->dma_buff = (unsigned char *)__get_dma_pages(GFP_KERNEL,\n\t\t\t\t\t\t\t\tget_order(lp->dmasize * 1024));\n\t\tif (!lp->dma_buff) {\n\t\t\tpr_err(\"%s: cannot get %dK memory for DMA\\n\",\n\t\t\t       dev->name, lp->dmasize);\n\t\t\tgoto release_irq;\n\t\t}\n\t\tcs89_dbg(1, debug, \"%s: dma %lx %lx\\n\",\n\t\t\t dev->name,\n\t\t\t (unsigned long)lp->dma_buff,\n\t\t\t (unsigned long)isa_virt_to_bus(lp->dma_buff));\n\t\tif ((unsigned long)lp->dma_buff >= MAX_DMA_ADDRESS ||\n\t\t    !dma_page_eq(lp->dma_buff,\n\t\t\t\t lp->dma_buff + lp->dmasize * 1024 - 1)) {\n\t\t\tpr_err(\"%s: not usable as DMA buffer\\n\", dev->name);\n\t\t\tgoto release_irq;\n\t\t}\n\t\tmemset(lp->dma_buff, 0, lp->dmasize * 1024);\t \n\t\tif (request_dma(dev->dma, dev->name)) {\n\t\t\tpr_err(\"%s: cannot get dma channel %d\\n\",\n\t\t\t       dev->name, dev->dma);\n\t\t\tgoto release_irq;\n\t\t}\n\t\twrite_dma(dev, lp->chip_type, dev->dma);\n\t\tlp->rx_dma_ptr = lp->dma_buff;\n\t\tlp->end_dma_buff = lp->dma_buff + lp->dmasize * 1024;\n\t\tspin_lock_irqsave(&lp->lock, flags);\n\t\tdisable_dma(dev->dma);\n\t\tclear_dma_ff(dev->dma);\n\t\tset_dma_mode(dev->dma, DMA_RX_MODE);  \n\t\tset_dma_addr(dev->dma, isa_virt_to_bus(lp->dma_buff));\n\t\tset_dma_count(dev->dma, lp->dmasize * 1024);\n\t\tenable_dma(dev->dma);\n\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\t}\n#endif\t \n\n\t \n\tfor (i = 0; i < ETH_ALEN / 2; i++)\n\t\twritereg(dev, PP_IA + i * 2,\n\t\t\t (dev->dev_addr[i * 2] |\n\t\t\t  (dev->dev_addr[i * 2 + 1] << 8)));\n\n\t \n\twritereg(dev, PP_BusCTL, MEMORY_ON);\n\n\t \n\tif ((lp->adapter_cnf & A_CNF_EXTND_10B_2) &&\n\t    (lp->adapter_cnf & A_CNF_LOW_RX_SQUELCH))\n\t\tlp->linectl = LOW_RX_SQUELCH;\n\telse\n\t\tlp->linectl = 0;\n\n\t \n\tswitch (lp->adapter_cnf & A_CNF_MEDIA_TYPE) {\n\tcase A_CNF_MEDIA_10B_T:\n\t\tresult = lp->adapter_cnf & A_CNF_10B_T;\n\t\tbreak;\n\tcase A_CNF_MEDIA_AUI:\n\t\tresult = lp->adapter_cnf & A_CNF_AUI;\n\t\tbreak;\n\tcase A_CNF_MEDIA_10B_2:\n\t\tresult = lp->adapter_cnf & A_CNF_10B_2;\n\t\tbreak;\n\tdefault:\n\t\tresult = lp->adapter_cnf & (A_CNF_10B_T |\n\t\t\t\t\t    A_CNF_AUI |\n\t\t\t\t\t    A_CNF_10B_2);\n\t}\n\tif (!result) {\n\t\tpr_err(\"%s: EEPROM is configured for unavailable media\\n\",\n\t\t       dev->name);\nrelease_dma:\n#if ALLOW_DMA\n\t\tfree_dma(dev->dma);\nrelease_irq:\n\t\trelease_dma_buff(lp);\n#endif\n\t\twritereg(dev, PP_LineCTL,\n\t\t\t readreg(dev, PP_LineCTL) & ~(SERIAL_TX_ON | SERIAL_RX_ON));\n\t\tfree_irq(dev->irq, dev);\n\t\tret = -EAGAIN;\n\t\tgoto bad_out;\n\t}\n\n\t \n\tswitch (lp->adapter_cnf & A_CNF_MEDIA_TYPE) {\n\tcase A_CNF_MEDIA_10B_T:\n\t\tresult = detect_tp(dev);\n\t\tif (result == DETECTED_NONE) {\n\t\t\tpr_warn(\"%s: 10Base-T (RJ-45) has no cable\\n\",\n\t\t\t\tdev->name);\n\t\t\tif (lp->auto_neg_cnf & IMM_BIT)  \n\t\t\t\tresult = DETECTED_RJ45H;  \n\t\t}\n\t\tbreak;\n\tcase A_CNF_MEDIA_AUI:\n\t\tresult = detect_aui(dev);\n\t\tif (result == DETECTED_NONE) {\n\t\t\tpr_warn(\"%s: 10Base-5 (AUI) has no cable\\n\", dev->name);\n\t\t\tif (lp->auto_neg_cnf & IMM_BIT)  \n\t\t\t\tresult = DETECTED_AUI;  \n\t\t}\n\t\tbreak;\n\tcase A_CNF_MEDIA_10B_2:\n\t\tresult = detect_bnc(dev);\n\t\tif (result == DETECTED_NONE) {\n\t\t\tpr_warn(\"%s: 10Base-2 (BNC) has no cable\\n\", dev->name);\n\t\t\tif (lp->auto_neg_cnf & IMM_BIT)  \n\t\t\t\tresult = DETECTED_BNC;  \n\t\t}\n\t\tbreak;\n\tcase A_CNF_MEDIA_AUTO:\n\t\twritereg(dev, PP_LineCTL, lp->linectl | AUTO_AUI_10BASET);\n\t\tif (lp->adapter_cnf & A_CNF_10B_T) {\n\t\t\tresult = detect_tp(dev);\n\t\t\tif (result != DETECTED_NONE)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (lp->adapter_cnf & A_CNF_AUI) {\n\t\t\tresult = detect_aui(dev);\n\t\t\tif (result != DETECTED_NONE)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (lp->adapter_cnf & A_CNF_10B_2) {\n\t\t\tresult = detect_bnc(dev);\n\t\t\tif (result != DETECTED_NONE)\n\t\t\t\tbreak;\n\t\t}\n\t\tpr_err(\"%s: no media detected\\n\", dev->name);\n\t\tgoto release_dma;\n\t}\n\tswitch (result) {\n\tcase DETECTED_NONE:\n\t\tpr_err(\"%s: no network cable attached to configured media\\n\",\n\t\t       dev->name);\n\t\tgoto release_dma;\n\tcase DETECTED_RJ45H:\n\t\tpr_info(\"%s: using half-duplex 10Base-T (RJ-45)\\n\", dev->name);\n\t\tbreak;\n\tcase DETECTED_RJ45F:\n\t\tpr_info(\"%s: using full-duplex 10Base-T (RJ-45)\\n\", dev->name);\n\t\tbreak;\n\tcase DETECTED_AUI:\n\t\tpr_info(\"%s: using 10Base-5 (AUI)\\n\", dev->name);\n\t\tbreak;\n\tcase DETECTED_BNC:\n\t\tpr_info(\"%s: using 10Base-2 (BNC)\\n\", dev->name);\n\t\tbreak;\n\t}\n\n\t \n\twritereg(dev, PP_LineCTL,\n\t\t readreg(dev, PP_LineCTL) | SERIAL_RX_ON | SERIAL_TX_ON);\n\n\t \n\tlp->rx_mode = 0;\n\twritereg(dev, PP_RxCTL, DEF_RX_ACCEPT);\n\n\tlp->curr_rx_cfg = RX_OK_ENBL | RX_CRC_ERROR_ENBL;\n\n\tif (lp->isa_config & STREAM_TRANSFER)\n\t\tlp->curr_rx_cfg |= RX_STREAM_ENBL;\n#if ALLOW_DMA\n\tset_dma_cfg(dev);\n#endif\n\twritereg(dev, PP_RxCFG, lp->curr_rx_cfg);\n\n\twritereg(dev, PP_TxCFG, (TX_LOST_CRS_ENBL |\n\t\t\t\t TX_SQE_ERROR_ENBL |\n\t\t\t\t TX_OK_ENBL |\n\t\t\t\t TX_LATE_COL_ENBL |\n\t\t\t\t TX_JBR_ENBL |\n\t\t\t\t TX_ANY_COL_ENBL |\n\t\t\t\t TX_16_COL_ENBL));\n\n\twritereg(dev, PP_BufCFG, (READY_FOR_TX_ENBL |\n\t\t\t\t  RX_MISS_COUNT_OVRFLOW_ENBL |\n#if ALLOW_DMA\n\t\t\t\t  dma_bufcfg(dev) |\n#endif\n\t\t\t\t  TX_COL_COUNT_OVRFLOW_ENBL |\n\t\t\t\t  TX_UNDERRUN_ENBL));\n\n\t \n\twritereg(dev, PP_BusCTL, (ENABLE_IRQ\n\t\t\t\t  | (dev->mem_start ? MEMORY_ON : 0)  \n#if ALLOW_DMA\n\t\t\t\t  | dma_busctl(dev)\n#endif\n\t\t\t ));\n\tnetif_start_queue(dev);\n\tcs89_dbg(1, debug, \"net_open() succeeded\\n\");\n\treturn 0;\nbad_out:\n\treturn ret;\n}\n\n \nstatic int\nnet_close(struct net_device *dev)\n{\n#if ALLOW_DMA\n\tstruct net_local *lp = netdev_priv(dev);\n#endif\n\n\tnetif_stop_queue(dev);\n\n\twritereg(dev, PP_RxCFG, 0);\n\twritereg(dev, PP_TxCFG, 0);\n\twritereg(dev, PP_BufCFG, 0);\n\twritereg(dev, PP_BusCTL, 0);\n\n\tfree_irq(dev->irq, dev);\n\n#if ALLOW_DMA\n\tif (lp->use_dma && lp->dma) {\n\t\tfree_dma(dev->dma);\n\t\trelease_dma_buff(lp);\n\t}\n#endif\n\n\t \n\treturn 0;\n}\n\n \nstatic struct net_device_stats *\nnet_get_stats(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\t \n\tdev->stats.rx_missed_errors += (readreg(dev, PP_RxMiss) >> 6);\n\tdev->stats.collisions += (readreg(dev, PP_TxCol) >> 6);\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\treturn &dev->stats;\n}\n\nstatic void net_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\t \n\tcs89_dbg(0, err, \"%s: transmit timed out, %s?\\n\",\n\t\t dev->name,\n\t\t tx_done(dev) ? \"IRQ conflict\" : \"network cable problem\");\n\t \n\tnetif_wake_queue(dev);\n}\n\nstatic netdev_tx_t net_send_packet(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tunsigned long flags;\n\n\tcs89_dbg(3, debug, \"%s: sent %d byte packet of type %x\\n\",\n\t\t dev->name, skb->len,\n\t\t ((skb->data[ETH_ALEN + ETH_ALEN] << 8) |\n\t\t  skb->data[ETH_ALEN + ETH_ALEN + 1]));\n\n\t \n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tnetif_stop_queue(dev);\n\n\t \n\tiowrite16(lp->send_cmd, lp->virt_addr + TX_CMD_PORT);\n\tiowrite16(skb->len, lp->virt_addr + TX_LEN_PORT);\n\n\t \n\tif ((readreg(dev, PP_BusST) & READY_FOR_TX_NOW) == 0) {\n\t\t \n\n\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\t\tcs89_dbg(0, err, \"Tx buffer not free!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\t \n\twritewords(lp, TX_FRAME_PORT, skb->data, (skb->len + 1) >> 1);\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\tdev->stats.tx_bytes += skb->len;\n\tdev_consume_skb_any(skb);\n\n\t \n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void set_multicast_list(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tunsigned long flags;\n\tu16 cfg;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tif (dev->flags & IFF_PROMISC)\n\t\tlp->rx_mode = RX_ALL_ACCEPT;\n\telse if ((dev->flags & IFF_ALLMULTI) || !netdev_mc_empty(dev))\n\t\t \n\t\tlp->rx_mode = RX_MULTCAST_ACCEPT;\n\telse\n\t\tlp->rx_mode = 0;\n\n\twritereg(dev, PP_RxCTL, DEF_RX_ACCEPT | lp->rx_mode);\n\n\t \n\tcfg = lp->curr_rx_cfg;\n\tif (lp->rx_mode == RX_ALL_ACCEPT)\n\t\tcfg |= RX_CRC_ERROR_ENBL | RX_RUNT_ENBL | RX_EXTRA_DATA_ENBL;\n\twritereg(dev, PP_RxCFG, cfg);\n\tspin_unlock_irqrestore(&lp->lock, flags);\n}\n\nstatic int set_mac_address(struct net_device *dev, void *p)\n{\n\tint i;\n\tstruct sockaddr *addr = p;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\tcs89_dbg(0, debug, \"%s: Setting MAC address to %pM\\n\",\n\t\t dev->name, dev->dev_addr);\n\n\t \n\tfor (i = 0; i < ETH_ALEN / 2; i++)\n\t\twritereg(dev, PP_IA + i * 2,\n\t\t\t (dev->dev_addr[i * 2] |\n\t\t\t  (dev->dev_addr[i * 2 + 1] << 8)));\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void net_poll_controller(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\tnet_interrupt(dev->irq, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n\nstatic const struct net_device_ops net_ops = {\n\t.ndo_open\t\t= net_open,\n\t.ndo_stop\t\t= net_close,\n\t.ndo_tx_timeout\t\t= net_timeout,\n\t.ndo_start_xmit\t\t= net_send_packet,\n\t.ndo_get_stats\t\t= net_get_stats,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_set_mac_address\t= set_mac_address,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= net_poll_controller,\n#endif\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic void __init reset_chip(struct net_device *dev)\n{\n#if !defined(CONFIG_MACH_MX31ADS)\n\tstruct net_local *lp = netdev_priv(dev);\n\tunsigned long reset_start_time;\n\n\twritereg(dev, PP_SelfCTL, readreg(dev, PP_SelfCTL) | POWER_ON_RESET);\n\n\t \n\tmsleep(30);\n\n\tif (lp->chip_type != CS8900) {\n\t\t \n\t\tiowrite16(PP_CS8920_ISAINT, lp->virt_addr + ADD_PORT);\n\t\tiowrite8(dev->irq, lp->virt_addr + DATA_PORT);\n\t\tiowrite8(0, lp->virt_addr + DATA_PORT + 1);\n\n\t\tiowrite16(PP_CS8920_ISAMemB, lp->virt_addr + ADD_PORT);\n\t\tiowrite8((dev->mem_start >> 16) & 0xff,\n\t\t\t lp->virt_addr + DATA_PORT);\n\t\tiowrite8((dev->mem_start >> 8) & 0xff,\n\t\t\t lp->virt_addr + DATA_PORT + 1);\n\t}\n\n\t \n\treset_start_time = jiffies;\n\twhile ((readreg(dev, PP_SelfST) & INIT_DONE) == 0 &&\n\t       time_before(jiffies, reset_start_time + 2))\n\t\t;\n#endif  \n}\n\n \nstatic int __init\ncs89x0_probe1(struct net_device *dev, void __iomem *ioaddr, int modular)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tint i;\n\tint tmp;\n\tunsigned rev_type = 0;\n\tint eeprom_buff[CHKSUM_LEN];\n\tu8 addr[ETH_ALEN];\n\tint retval;\n\n\t \n\tif (!modular) {\n\t\tmemset(lp, 0, sizeof(*lp));\n\t\tspin_lock_init(&lp->lock);\n#ifndef MODULE\n#if ALLOW_DMA\n\t\tif (g_cs89x0_dma) {\n\t\t\tlp->use_dma = 1;\n\t\t\tlp->dma = g_cs89x0_dma;\n\t\t\tlp->dmasize = 16;\t \n\t\t}\n#endif\n\t\tlp->force = g_cs89x0_media__force;\n#endif\n\t}\n\n\tpr_debug(\"PP_addr at %p[%x]: 0x%x\\n\",\n\t\t ioaddr, ADD_PORT, ioread16(ioaddr + ADD_PORT));\n\tiowrite16(PP_ChipID, ioaddr + ADD_PORT);\n\n\ttmp = ioread16(ioaddr + DATA_PORT);\n\tif (tmp != CHIP_EISA_ID_SIG) {\n\t\tpr_debug(\"%s: incorrect signature at %p[%x]: 0x%x!=\"\n\t\t\t CHIP_EISA_ID_SIG_STR \"\\n\",\n\t\t\t dev->name, ioaddr, DATA_PORT, tmp);\n\t\tretval = -ENODEV;\n\t\tgoto out1;\n\t}\n\n\tlp->virt_addr = ioaddr;\n\n\t \n\trev_type = readreg(dev, PRODUCT_ID_ADD);\n\tlp->chip_type = rev_type & ~REVISON_BITS;\n\tlp->chip_revision = ((rev_type & REVISON_BITS) >> 8) + 'A';\n\n\t \n\tlp->send_cmd = TX_AFTER_381;\n\tif (lp->chip_type == CS8900 && lp->chip_revision >= 'F')\n\t\tlp->send_cmd = TX_NOW;\n\tif (lp->chip_type != CS8900 && lp->chip_revision >= 'C')\n\t\tlp->send_cmd = TX_NOW;\n\n\tpr_info_once(\"%s\\n\", version);\n\n\tpr_info(\"%s: cs89%c0%s rev %c found at %p \",\n\t\tdev->name,\n\t\tlp->chip_type == CS8900  ? '0' : '2',\n\t\tlp->chip_type == CS8920M ? \"M\" : \"\",\n\t\tlp->chip_revision,\n\t\tlp->virt_addr);\n\n\treset_chip(dev);\n\n\t \n\n\tif ((readreg(dev, PP_SelfST) & (EEPROM_OK | EEPROM_PRESENT)) ==\n\t    (EEPROM_OK | EEPROM_PRESENT)) {\n\t\t \n\t\tfor (i = 0; i < ETH_ALEN / 2; i++) {\n\t\t\tunsigned int Addr;\n\t\t\tAddr = readreg(dev, PP_IA + i * 2);\n\t\t\taddr[i * 2] = Addr & 0xFF;\n\t\t\taddr[i * 2 + 1] = Addr >> 8;\n\t\t}\n\t\teth_hw_addr_set(dev, addr);\n\n\t\t \n\n\t\tlp->adapter_cnf = 0;\n\t\ti = readreg(dev, PP_LineCTL);\n\t\t \n\t\tif ((i & (HCB1 | HCB1_ENBL)) == (HCB1 | HCB1_ENBL))\n\t\t\tlp->adapter_cnf |= A_CNF_DC_DC_POLARITY;\n\t\t \n\t\tif ((i & LOW_RX_SQUELCH) == LOW_RX_SQUELCH)\n\t\t\tlp->adapter_cnf |= A_CNF_EXTND_10B_2 | A_CNF_LOW_RX_SQUELCH;\n\t\t \n\t\tif ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == 0)\n\t\t\tlp->adapter_cnf |=  A_CNF_10B_T | A_CNF_MEDIA_10B_T;\n\t\t \n\t\tif ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == AUI_ONLY)\n\t\t\tlp->adapter_cnf |=  A_CNF_AUI | A_CNF_MEDIA_AUI;\n\t\t \n\t\tif ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == AUTO_AUI_10BASET)\n\t\t\tlp->adapter_cnf |=  A_CNF_AUI | A_CNF_10B_T |\n\t\t\t\tA_CNF_MEDIA_AUI | A_CNF_MEDIA_10B_T | A_CNF_MEDIA_AUTO;\n\n\t\tcs89_dbg(1, info, \"%s: PP_LineCTL=0x%x, adapter_cnf=0x%x\\n\",\n\t\t\t dev->name, i, lp->adapter_cnf);\n\n\t\t \n\t\tif (lp->chip_type == CS8900)\n\t\t\tlp->isa_config = readreg(dev, PP_CS8900_ISAINT) & INT_NO_MASK;\n\n\t\tpr_cont(\"[Cirrus EEPROM] \");\n\t}\n\n\tpr_cont(\"\\n\");\n\n\t \n\n\tif ((readreg(dev, PP_SelfST) & EEPROM_PRESENT) == 0)\n\t\tpr_warn(\"No EEPROM, relying on command line....\\n\");\n\telse if (get_eeprom_data(dev, START_EEPROM_DATA, CHKSUM_LEN, eeprom_buff) < 0) {\n\t\tpr_warn(\"EEPROM read failed, relying on command line\\n\");\n\t} else if (get_eeprom_cksum(START_EEPROM_DATA, CHKSUM_LEN, eeprom_buff) < 0) {\n\t\t \n\t\tif ((readreg(dev, PP_SelfST) & (EEPROM_OK | EEPROM_PRESENT)) !=\n\t\t    (EEPROM_OK | EEPROM_PRESENT))\n\t\t\tpr_warn(\"Extended EEPROM checksum bad and no Cirrus EEPROM, relying on command line\\n\");\n\n\t} else {\n\t\t \n\n\t\t \n\t\tif (!lp->auto_neg_cnf)\n\t\t\tlp->auto_neg_cnf = eeprom_buff[AUTO_NEG_CNF_OFFSET / 2];\n\t\t \n\t\tif (!lp->adapter_cnf)\n\t\t\tlp->adapter_cnf = eeprom_buff[ADAPTER_CNF_OFFSET / 2];\n\t\t \n\t\tlp->isa_config = eeprom_buff[ISA_CNF_OFFSET / 2];\n\t\tdev->mem_start = eeprom_buff[PACKET_PAGE_OFFSET / 2] << 8;\n\n\t\t \n\t\t \n\t\tfor (i = 0; i < ETH_ALEN / 2; i++) {\n\t\t\taddr[i * 2] = eeprom_buff[i];\n\t\t\taddr[i * 2 + 1] = eeprom_buff[i] >> 8;\n\t\t}\n\t\teth_hw_addr_set(dev, addr);\n\t\tcs89_dbg(1, debug, \"%s: new adapter_cnf: 0x%x\\n\",\n\t\t\t dev->name, lp->adapter_cnf);\n\t}\n\n\t \n\t{\n\t\tint count = 0;\n\t\tif (lp->force & FORCE_RJ45) {\n\t\t\tlp->adapter_cnf |= A_CNF_10B_T;\n\t\t\tcount++;\n\t\t}\n\t\tif (lp->force & FORCE_AUI) {\n\t\t\tlp->adapter_cnf |= A_CNF_AUI;\n\t\t\tcount++;\n\t\t}\n\t\tif (lp->force & FORCE_BNC) {\n\t\t\tlp->adapter_cnf |= A_CNF_10B_2;\n\t\t\tcount++;\n\t\t}\n\t\tif (count > 1)\n\t\t\tlp->adapter_cnf |= A_CNF_MEDIA_AUTO;\n\t\telse if (lp->force & FORCE_RJ45)\n\t\t\tlp->adapter_cnf |= A_CNF_MEDIA_10B_T;\n\t\telse if (lp->force & FORCE_AUI)\n\t\t\tlp->adapter_cnf |= A_CNF_MEDIA_AUI;\n\t\telse if (lp->force & FORCE_BNC)\n\t\t\tlp->adapter_cnf |= A_CNF_MEDIA_10B_2;\n\t}\n\n\tcs89_dbg(1, debug, \"%s: after force 0x%x, adapter_cnf=0x%x\\n\",\n\t\t dev->name, lp->force, lp->adapter_cnf);\n\n\t \n\n\t \n\n\t \n\n\tpr_info(\"media %s%s%s\",\n\t\t(lp->adapter_cnf & A_CNF_10B_T) ? \"RJ-45,\" : \"\",\n\t\t(lp->adapter_cnf & A_CNF_AUI) ? \"AUI,\" : \"\",\n\t\t(lp->adapter_cnf & A_CNF_10B_2) ? \"BNC,\" : \"\");\n\n\tlp->irq_map = 0xffff;\n\n\t \n\tif (lp->chip_type != CS8900 &&\n\t     \n\t    (i = readreg(dev, PP_CS8920_ISAINT) & 0xff,\n\t     (i != 0 && i < CS8920_NO_INTS))) {\n\t\tif (!dev->irq)\n\t\t\tdev->irq = i;\n\t} else {\n\t\ti = lp->isa_config & INT_NO_MASK;\n#if IS_ENABLED(CONFIG_CS89x0_ISA)\n\t\tif (lp->chip_type == CS8900) {\n\t\t\t \n\t\t\tif (i >= ARRAY_SIZE(cs8900_irq_map))\n\t\t\t\tpr_err(\"invalid ISA interrupt number %d\\n\", i);\n\t\t\telse\n\t\t\t\ti = cs8900_irq_map[i];\n\n\t\t\tlp->irq_map = CS8900_IRQ_MAP;  \n\t\t} else {\n\t\t\tint irq_map_buff[IRQ_MAP_LEN/2];\n\n\t\t\tif (get_eeprom_data(dev, IRQ_MAP_EEPROM_DATA,\n\t\t\t\t\t    IRQ_MAP_LEN / 2,\n\t\t\t\t\t    irq_map_buff) >= 0) {\n\t\t\t\tif ((irq_map_buff[0] & 0xff) == PNP_IRQ_FRMT)\n\t\t\t\t\tlp->irq_map = ((irq_map_buff[0] >> 8) |\n\t\t\t\t\t\t       (irq_map_buff[1] << 8));\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!dev->irq)\n\t\t\tdev->irq = i;\n\t}\n\n\tpr_cont(\" IRQ %d\", dev->irq);\n\n#if ALLOW_DMA\n\tif (lp->use_dma) {\n\t\tget_dma_channel(dev);\n\t\tpr_cont(\", DMA %d\", dev->dma);\n\t} else\n#endif\n\t\tpr_cont(\", programmed I/O\");\n\n\t \n\tpr_cont(\", MAC %pM\\n\", dev->dev_addr);\n\n\tdev->netdev_ops\t= &net_ops;\n\tdev->watchdog_timeo = HZ;\n\n\tcs89_dbg(0, info, \"cs89x0_probe1() successful\\n\");\n\n\tretval = register_netdev(dev);\n\tif (retval)\n\t\tgoto out2;\n\treturn 0;\nout2:\n\tiowrite16(PP_ChipID, lp->virt_addr + ADD_PORT);\nout1:\n\treturn retval;\n}\n\n#if IS_ENABLED(CONFIG_CS89x0_ISA)\n \nstatic int __init\ncs89x0_ioport_probe(struct net_device *dev, unsigned long ioport, int modular)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tint ret;\n\tvoid __iomem *io_mem;\n\n\tif (!lp)\n\t\treturn -ENOMEM;\n\n\tdev->base_addr = ioport;\n\n\tif (!request_region(ioport, NETCARD_IO_EXTENT, DRV_NAME)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tio_mem = ioport_map(ioport & ~3, NETCARD_IO_EXTENT);\n\tif (!io_mem) {\n\t\tret = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\t \n\tif (ioport & 1) {\n\t\tcs89_dbg(1, info, \"%s: odd ioaddr 0x%lx\\n\", dev->name, ioport);\n\t\tif ((ioport & 2) != 2) {\n\t\t\tif ((ioread16(io_mem + ADD_PORT) & ADD_MASK) !=\n\t\t\t    ADD_SIG) {\n\t\t\t\tpr_err(\"%s: bad signature 0x%x\\n\",\n\t\t\t\t       dev->name, ioread16(io_mem + ADD_PORT));\n\t\t\t\tret = -ENODEV;\n\t\t\t\tgoto unmap;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = cs89x0_probe1(dev, io_mem, modular);\n\tif (!ret)\n\t\tgoto out;\nunmap:\n\tioport_unmap(io_mem);\nrelease:\n\trelease_region(ioport, NETCARD_IO_EXTENT);\nout:\n\treturn ret;\n}\n\n#ifndef MODULE\n \n\nstruct net_device * __init cs89x0_probe(int unit)\n{\n\tstruct net_device *dev = alloc_etherdev(sizeof(struct net_local));\n\tunsigned *port;\n\tint err = 0;\n\tint irq;\n\tint io;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsprintf(dev->name, \"eth%d\", unit);\n\tnetdev_boot_setup_check(dev);\n\tio = dev->base_addr;\n\tirq = dev->irq;\n\n\tcs89_dbg(0, info, \"cs89x0_probe(0x%x)\\n\", io);\n\n\tif (io > 0x1ff)\t{\t \n\t\terr = cs89x0_ioport_probe(dev, io, 0);\n\t} else if (io != 0) {\t \n\t\terr = -ENXIO;\n\t} else {\n\t\tfor (port = netcard_portlist; *port; port++) {\n\t\t\tif (cs89x0_ioport_probe(dev, *port, 0) == 0)\n\t\t\t\tbreak;\n\t\t\tdev->irq = irq;\n\t\t}\n\t\tif (!*port)\n\t\t\terr = -ENODEV;\n\t}\n\tif (err)\n\t\tgoto out;\n\treturn dev;\nout:\n\tfree_netdev(dev);\n\tpr_warn(\"no cs8900 or cs8920 detected.  Be sure to disable PnP with SETUP\\n\");\n\treturn ERR_PTR(err);\n}\n#else\nstatic struct net_device *dev_cs89x0;\n\n \n\nstatic int io;\nstatic int irq;\nstatic int debug;\nstatic char media[8];\nstatic int duplex = -1;\n\nstatic int use_dma;\t\t\t \nstatic int dma;\nstatic int dmasize = 16;\t\t \n\nmodule_param_hw(io, int, ioport, 0);\nmodule_param_hw(irq, int, irq, 0);\nmodule_param(debug, int, 0);\nmodule_param_string(media, media, sizeof(media), 0);\nmodule_param(duplex, int, 0);\nmodule_param_hw(dma , int, dma, 0);\nmodule_param(dmasize , int, 0);\nmodule_param(use_dma , int, 0);\nMODULE_PARM_DESC(io, \"cs89x0 I/O base address\");\nMODULE_PARM_DESC(irq, \"cs89x0 IRQ number\");\n#if DEBUGGING\nMODULE_PARM_DESC(debug, \"cs89x0 debug level (0-6)\");\n#else\nMODULE_PARM_DESC(debug, \"(ignored)\");\n#endif\nMODULE_PARM_DESC(media, \"Set cs89x0 adapter(s) media type(s) (rj45,bnc,aui)\");\n \nMODULE_PARM_DESC(duplex, \"(ignored)\");\n#if ALLOW_DMA\nMODULE_PARM_DESC(dma , \"cs89x0 ISA DMA channel; ignored if use_dma=0\");\nMODULE_PARM_DESC(dmasize , \"cs89x0 DMA size in kB (16,64); ignored if use_dma=0\");\nMODULE_PARM_DESC(use_dma , \"cs89x0 using DMA (0-1)\");\n#else\nMODULE_PARM_DESC(dma , \"(ignored)\");\nMODULE_PARM_DESC(dmasize , \"(ignored)\");\nMODULE_PARM_DESC(use_dma , \"(ignored)\");\n#endif\n\nMODULE_AUTHOR(\"Mike Cruse, Russwll Nelson <nelson@crynwr.com>, Andrew Morton\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic int __init cs89x0_isa_init_module(void)\n{\n\tstruct net_device *dev;\n\tstruct net_local *lp;\n\tint ret = 0;\n\n#if DEBUGGING\n\tnet_debug = debug;\n#else\n\tdebug = 0;\n#endif\n\tdev = alloc_etherdev(sizeof(struct net_local));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->irq = irq;\n\tdev->base_addr = io;\n\tlp = netdev_priv(dev);\n\n#if ALLOW_DMA\n\tif (use_dma) {\n\t\tlp->use_dma = use_dma;\n\t\tlp->dma = dma;\n\t\tlp->dmasize = dmasize;\n\t}\n#endif\n\n\tspin_lock_init(&lp->lock);\n\n\t \n\tif (!strcmp(media, \"rj45\"))\n\t\tlp->adapter_cnf = A_CNF_MEDIA_10B_T | A_CNF_10B_T;\n\telse if (!strcmp(media, \"aui\"))\n\t\tlp->adapter_cnf = A_CNF_MEDIA_AUI   | A_CNF_AUI;\n\telse if (!strcmp(media, \"bnc\"))\n\t\tlp->adapter_cnf = A_CNF_MEDIA_10B_2 | A_CNF_10B_2;\n\telse\n\t\tlp->adapter_cnf = A_CNF_MEDIA_10B_T | A_CNF_10B_T;\n\n\tif (duplex == -1)\n\t\tlp->auto_neg_cnf = AUTO_NEG_ENABLE;\n\n\tif (io == 0) {\n\t\tpr_err(\"Module autoprobing not allowed\\n\");\n\t\tpr_err(\"Append io=0xNNN\\n\");\n\t\tret = -EPERM;\n\t\tgoto out;\n\t} else if (io <= 0x1ff) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n#if ALLOW_DMA\n\tif (use_dma && dmasize != 16 && dmasize != 64) {\n\t\tpr_err(\"dma size must be either 16K or 64K, not %dK\\n\",\n\t\t       dmasize);\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n#endif\n\tret = cs89x0_ioport_probe(dev, io, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tdev_cs89x0 = dev;\n\treturn 0;\nout:\n\tfree_netdev(dev);\n\treturn ret;\n}\nmodule_init(cs89x0_isa_init_module);\n\nstatic void __exit cs89x0_isa_cleanup_module(void)\n{\n\tstruct net_local *lp = netdev_priv(dev_cs89x0);\n\n\tunregister_netdev(dev_cs89x0);\n\tiowrite16(PP_ChipID, lp->virt_addr + ADD_PORT);\n\tioport_unmap(lp->virt_addr);\n\trelease_region(dev_cs89x0->base_addr, NETCARD_IO_EXTENT);\n\tfree_netdev(dev_cs89x0);\n}\nmodule_exit(cs89x0_isa_cleanup_module);\n#endif  \n#endif  \n\n#if IS_ENABLED(CONFIG_CS89x0_PLATFORM)\nstatic int __init cs89x0_platform_probe(struct platform_device *pdev)\n{\n\tstruct net_device *dev = alloc_etherdev(sizeof(struct net_local));\n\tvoid __iomem *virt_addr;\n\tint err;\n\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->irq = platform_get_irq(pdev, 0);\n\tif (dev->irq < 0) {\n\t\terr = dev->irq;\n\t\tgoto free;\n\t}\n\n\tvirt_addr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(virt_addr)) {\n\t\terr = PTR_ERR(virt_addr);\n\t\tgoto free;\n\t}\n\n\terr = cs89x0_probe1(dev, virt_addr, 0);\n\tif (err) {\n\t\tdev_warn(&dev->dev, \"no cs8900 or cs8920 detected\\n\");\n\t\tgoto free;\n\t}\n\n\tplatform_set_drvdata(pdev, dev);\n\treturn 0;\n\nfree:\n\tfree_netdev(dev);\n\treturn err;\n}\n\nstatic int cs89x0_platform_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\n\t \n\tunregister_netdev(dev);\n\tfree_netdev(dev);\n\treturn 0;\n}\n\nstatic const struct of_device_id __maybe_unused cs89x0_match[] = {\n\t{ .compatible = \"cirrus,cs8900\", },\n\t{ .compatible = \"cirrus,cs8920\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, cs89x0_match);\n\nstatic struct platform_driver cs89x0_driver = {\n\t.driver\t= {\n\t\t.name\t\t= DRV_NAME,\n\t\t.of_match_table\t= of_match_ptr(cs89x0_match),\n\t},\n\t.remove\t= cs89x0_platform_remove,\n};\n\nmodule_platform_driver_probe(cs89x0_driver, cs89x0_platform_probe);\n\n#endif  \n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Crystal Semiconductor (Now Cirrus Logic) CS89[02]0 network driver\");\nMODULE_AUTHOR(\"Russell Nelson <nelson@crynwr.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}