{
  "module_name": "mac89x0.c",
  "hash_id": "986f8b017ce994eef1e2e0862d3eaae9a6d0e6b6459b2656b6bd5dcf9b944574",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cirrus/mac89x0.c",
  "human_readable_source": " \n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\nstatic const char version[] =\n\"cs89x0.c:v1.02 11/26/96 Russell Nelson <nelson@crynwr.com>\\n\";\n\n#include <linux/module.h>\n\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/nubus.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/platform_device.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n#include <linux/gfp.h>\n\n#include <asm/io.h>\n#include <asm/hwtest.h>\n#include <asm/macints.h>\n\n#include \"cs89x0.h\"\n\nstatic int debug = -1;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"debug message level\");\n\n \nstruct net_local {\n\tint msg_enable;\n\tint chip_type;\t\t \n\tchar chip_revision;\t \n\tint send_cmd;\t\t \n\tint rx_mode;\n\tint curr_rx_cfg;\n        int send_underrun;       \n};\n\n \nstatic int net_open(struct net_device *dev);\nstatic netdev_tx_t net_send_packet(struct sk_buff *skb, struct net_device *dev);\nstatic irqreturn_t net_interrupt(int irq, void *dev_id);\nstatic void set_multicast_list(struct net_device *dev);\nstatic void net_rx(struct net_device *dev);\nstatic int net_close(struct net_device *dev);\nstatic struct net_device_stats *net_get_stats(struct net_device *dev);\nstatic int set_mac_address(struct net_device *dev, void *addr);\n\n \nstatic inline int\nreadreg_io(struct net_device *dev, int portno)\n{\n\tnubus_writew(swab16(portno), dev->base_addr + ADD_PORT);\n\treturn swab16(nubus_readw(dev->base_addr + DATA_PORT));\n}\n\nstatic inline void\nwritereg_io(struct net_device *dev, int portno, int value)\n{\n\tnubus_writew(swab16(portno), dev->base_addr + ADD_PORT);\n\tnubus_writew(swab16(value), dev->base_addr + DATA_PORT);\n}\n\n \nstatic inline int\nreadreg(struct net_device *dev, int portno)\n{\n\treturn swab16(nubus_readw(dev->mem_start + portno));\n}\n\nstatic inline void\nwritereg(struct net_device *dev, int portno, int value)\n{\n\tnubus_writew(swab16(value), dev->mem_start + portno);\n}\n\nstatic const struct net_device_ops mac89x0_netdev_ops = {\n\t.ndo_open\t\t= net_open,\n\t.ndo_stop\t\t= net_close,\n\t.ndo_start_xmit\t\t= net_send_packet,\n\t.ndo_get_stats\t\t= net_get_stats,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_set_mac_address\t= set_mac_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n \nstatic int mac89x0_device_probe(struct platform_device *pdev)\n{\n\tstruct net_device *dev;\n\tstruct net_local *lp;\n\tint i, slot;\n\tunsigned rev_type = 0;\n\tunsigned long ioaddr;\n\tunsigned short sig;\n\tint err = -ENODEV;\n\tstruct nubus_rsrc *fres;\n\n\tdev = alloc_etherdev(sizeof(struct net_local));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tslot = 0xE;\n\t \n\tfor_each_func_rsrc(fres)\n\t\tif (fres->board->slot == slot)\n\t\t\tgoto out;\n\n\t \n\tioaddr = (unsigned long)\n\t\tnubus_slot_addr(slot) | (((slot&0xf) << 20) + DEFAULTIOBASE);\n\t{\n\t\tint card_present;\n\n\t\tcard_present = (hwreg_present((void *)ioaddr + 4) &&\n\t\t\t\thwreg_present((void *)ioaddr + DATA_PORT));\n\t\tif (!card_present)\n\t\t\tgoto out;\n\t}\n\n\tnubus_writew(0, ioaddr + ADD_PORT);\n\tsig = nubus_readw(ioaddr + DATA_PORT);\n\tif (sig != swab16(CHIP_EISA_ID_SIG))\n\t\tgoto out;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\t \n\tlp = netdev_priv(dev);\n\n\tlp->msg_enable = netif_msg_init(debug, 0);\n\n\t \n\tdev->base_addr = ioaddr;\n\tdev->mem_start = (unsigned long)\n\t\tnubus_slot_addr(slot) | (((slot&0xf) << 20) + MMIOBASE);\n\tdev->mem_end = dev->mem_start + 0x1000;\n\n\t \n\twritereg_io(dev, PP_BusCTL, MEMORY_ON);\n\n\t \n\trev_type = readreg(dev, PRODUCT_ID_ADD);\n\tlp->chip_type = rev_type &~ REVISON_BITS;\n\tlp->chip_revision = ((rev_type & REVISON_BITS) >> 8) + 'A';\n\n\t \n\tlp->send_cmd = TX_AFTER_381;\n\tif (lp->chip_type == CS8900 && lp->chip_revision >= 'F')\n\t\tlp->send_cmd = TX_NOW;\n\tif (lp->chip_type != CS8900 && lp->chip_revision >= 'C')\n\t\tlp->send_cmd = TX_NOW;\n\n\tnetif_dbg(lp, drv, dev, \"%s\", version);\n\n\tpr_info(\"cs89%c0%s rev %c found at %#8lx\\n\",\n\t\tlp->chip_type == CS8900 ? '0' : '2',\n\t\tlp->chip_type == CS8920M ? \"M\" : \"\",\n\t\tlp->chip_revision, dev->base_addr);\n\n\t \n\tif ((readreg(dev, PP_SelfST) & (EEPROM_PRESENT | EEPROM_OK)) == 0) {\n\t\tpr_info(\"No EEPROM, giving up now.\\n\");\n\t\tgoto out1;\n        } else {\n\t\tu8 addr[ETH_ALEN];\n\n                for (i = 0; i < ETH_ALEN; i += 2) {\n\t\t\t \n\t\t\tunsigned short s = readreg(dev, PP_IA + i);\n\t\t\taddr[i] = s >> 8;\n\t\t\taddr[i+1] = s & 0xff;\n                }\n\t\teth_hw_addr_set(dev, addr);\n        }\n\n\tdev->irq = SLOT2IRQ(slot);\n\n\t \n\n\tpr_info(\"MAC %pM, IRQ %d\\n\", dev->dev_addr, dev->irq);\n\n\tdev->netdev_ops\t\t= &mac89x0_netdev_ops;\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto out1;\n\n\tplatform_set_drvdata(pdev, dev);\n\treturn 0;\nout1:\n\tnubus_writew(0, dev->base_addr + ADD_PORT);\nout:\n\tfree_netdev(dev);\n\treturn err;\n}\n\n \nstatic int\nnet_open(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tint i;\n\n\t \n\twritereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL) & ~ENABLE_IRQ);\n\n\t \n\tif (request_irq(dev->irq, net_interrupt, 0, \"cs89x0\", dev))\n\t\treturn -EAGAIN;\n\n\t \n\tif (lp->chip_type == CS8900)\n\t\twritereg(dev, PP_CS8900_ISAINT, 0);\n\telse\n\t\twritereg(dev, PP_CS8920_ISAINT, 0);\n\n\t \n\tfor (i=0; i < ETH_ALEN/2; i++)\n\t\twritereg(dev, PP_IA+i*2, dev->dev_addr[i*2] | (dev->dev_addr[i*2+1] << 8));\n\n\t \n\twritereg(dev, PP_LineCTL, readreg(dev, PP_LineCTL) | SERIAL_RX_ON | SERIAL_TX_ON);\n\n\t \n\tlp->rx_mode = 0;\n\twritereg(dev, PP_RxCTL, DEF_RX_ACCEPT);\n\n\tlp->curr_rx_cfg = RX_OK_ENBL | RX_CRC_ERROR_ENBL;\n\n\twritereg(dev, PP_RxCFG, lp->curr_rx_cfg);\n\n\twritereg(dev, PP_TxCFG, TX_LOST_CRS_ENBL | TX_SQE_ERROR_ENBL | TX_OK_ENBL |\n\t       TX_LATE_COL_ENBL | TX_JBR_ENBL | TX_ANY_COL_ENBL | TX_16_COL_ENBL);\n\n\twritereg(dev, PP_BufCFG, READY_FOR_TX_ENBL | RX_MISS_COUNT_OVRFLOW_ENBL |\n\t\t TX_COL_COUNT_OVRFLOW_ENBL | TX_UNDERRUN_ENBL);\n\n\t \n\twritereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL) | ENABLE_IRQ);\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\nstatic netdev_tx_t\nnet_send_packet(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tunsigned long flags;\n\n\tnetif_dbg(lp, tx_queued, dev, \"sent %d byte packet of type %x\\n\",\n\t\t  skb->len, skb->data[ETH_ALEN + ETH_ALEN] << 8 |\n\t\t  skb->data[ETH_ALEN + ETH_ALEN + 1]);\n\n\t \n\tlocal_irq_save(flags);\n\tnetif_stop_queue(dev);\n\n\t \n\twritereg(dev, PP_TxCMD, lp->send_cmd);\n\twritereg(dev, PP_TxLength, skb->len);\n\n\t \n\tif ((readreg(dev, PP_BusST) & READY_FOR_TX_NOW) == 0) {\n\t\t \n\t\tlocal_irq_restore(flags);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tskb_copy_from_linear_data(skb, (void *)(dev->mem_start + PP_TxFrame),\n\t\t\t\t  skb->len+1);\n\n\tlocal_irq_restore(flags);\n\tdev_kfree_skb (skb);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic irqreturn_t net_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct net_local *lp;\n\tint ioaddr, status;\n\n\tioaddr = dev->base_addr;\n\tlp = netdev_priv(dev);\n\n\t \n\twhile ((status = swab16(nubus_readw(dev->base_addr + ISQ_PORT)))) {\n\t\tnetif_dbg(lp, intr, dev, \"status=%04x\\n\", status);\n\t\tswitch(status & ISQ_EVENT_MASK) {\n\t\tcase ISQ_RECEIVER_EVENT:\n\t\t\t \n\t\t\tnet_rx(dev);\n\t\t\tbreak;\n\t\tcase ISQ_TRANSMITTER_EVENT:\n\t\t\tdev->stats.tx_packets++;\n\t\t\tnetif_wake_queue(dev);\n\t\t\tif ((status & TX_OK) == 0)\n\t\t\t\tdev->stats.tx_errors++;\n\t\t\tif (status & TX_LOST_CRS)\n\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\tif (status & TX_SQE_ERROR)\n\t\t\t\tdev->stats.tx_heartbeat_errors++;\n\t\t\tif (status & TX_LATE_COL)\n\t\t\t\tdev->stats.tx_window_errors++;\n\t\t\tif (status & TX_16_COL)\n\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\tbreak;\n\t\tcase ISQ_BUFFER_EVENT:\n\t\t\tif (status & READY_FOR_TX) {\n\t\t\t\t \n\t\t\t\tnetif_wake_queue(dev);\n\t\t\t}\n\t\t\tif (status & TX_UNDERRUN) {\n\t\t\t\tnetif_dbg(lp, tx_err, dev, \"transmit underrun\\n\");\n                                lp->send_underrun++;\n                                if (lp->send_underrun == 3) lp->send_cmd = TX_AFTER_381;\n                                else if (lp->send_underrun == 6) lp->send_cmd = TX_AFTER_ALL;\n                        }\n\t\t\tbreak;\n\t\tcase ISQ_RX_MISS_EVENT:\n\t\t\tdev->stats.rx_missed_errors += (status >> 6);\n\t\t\tbreak;\n\t\tcase ISQ_TX_COL_EVENT:\n\t\t\tdev->stats.collisions += (status >> 6);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void\nnet_rx(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tint status, length;\n\n\tstatus = readreg(dev, PP_RxStatus);\n\tif ((status & RX_OK) == 0) {\n\t\tdev->stats.rx_errors++;\n\t\tif (status & RX_RUNT)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\tif (status & RX_EXTRA_DATA)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\tif ((status & RX_CRC_ERROR) &&\n\t\t    !(status & (RX_EXTRA_DATA|RX_RUNT)))\n\t\t\t \n\t\t\tdev->stats.rx_crc_errors++;\n\t\tif (status & RX_DRIBBLE)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\treturn;\n\t}\n\n\tlength = readreg(dev, PP_RxLength);\n\t \n\tskb = alloc_skb(length, GFP_ATOMIC);\n\tif (skb == NULL) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\tskb_put(skb, length);\n\n\tskb_copy_to_linear_data(skb, (void *)(dev->mem_start + PP_RxFrame),\n\t\t\t\tlength);\n\n\tnetif_dbg(lp, rx_status, dev, \"received %d byte packet of type %x\\n\",\n\t\t  length, skb->data[ETH_ALEN + ETH_ALEN] << 8 |\n\t\t  skb->data[ETH_ALEN + ETH_ALEN + 1]);\n\n        skb->protocol=eth_type_trans(skb,dev);\n\tnetif_rx(skb);\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += length;\n}\n\n \nstatic int\nnet_close(struct net_device *dev)\n{\n\n\twritereg(dev, PP_RxCFG, 0);\n\twritereg(dev, PP_TxCFG, 0);\n\twritereg(dev, PP_BufCFG, 0);\n\twritereg(dev, PP_BusCTL, 0);\n\n\tnetif_stop_queue(dev);\n\n\tfree_irq(dev->irq, dev);\n\n\t \n\n\treturn 0;\n\n}\n\n \nstatic struct net_device_stats *\nnet_get_stats(struct net_device *dev)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t \n\tdev->stats.rx_missed_errors += (readreg(dev, PP_RxMiss) >> 6);\n\tdev->stats.collisions += (readreg(dev, PP_TxCol) >> 6);\n\tlocal_irq_restore(flags);\n\n\treturn &dev->stats;\n}\n\nstatic void set_multicast_list(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\n\tif(dev->flags&IFF_PROMISC)\n\t{\n\t\tlp->rx_mode = RX_ALL_ACCEPT;\n\t} else if ((dev->flags & IFF_ALLMULTI) || !netdev_mc_empty(dev)) {\n\t\t \n\t\tlp->rx_mode = RX_MULTCAST_ACCEPT;\n\t}\n\telse\n\t\tlp->rx_mode = 0;\n\n\twritereg(dev, PP_RxCTL, DEF_RX_ACCEPT | lp->rx_mode);\n\n\t \n\twritereg(dev, PP_RxCFG, lp->curr_rx_cfg |\n\t     (lp->rx_mode == RX_ALL_ACCEPT? (RX_CRC_ERROR_ENBL|RX_RUNT_ENBL|RX_EXTRA_DATA_ENBL) : 0));\n}\n\n\nstatic int set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *saddr = addr;\n\tint i;\n\n\tif (!is_valid_ether_addr(saddr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, saddr->sa_data);\n\tnetdev_info(dev, \"Setting MAC address to %pM\\n\", dev->dev_addr);\n\n\t \n\tfor (i=0; i < ETH_ALEN/2; i++)\n\t\twritereg(dev, PP_IA+i*2, dev->dev_addr[i*2] | (dev->dev_addr[i*2+1] << 8));\n\n\treturn 0;\n}\n\nMODULE_LICENSE(\"GPL\");\n\nstatic int mac89x0_device_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\n\tunregister_netdev(dev);\n\tnubus_writew(0, dev->base_addr + ADD_PORT);\n\tfree_netdev(dev);\n\treturn 0;\n}\n\nstatic struct platform_driver mac89x0_platform_driver = {\n\t.probe = mac89x0_device_probe,\n\t.remove = mac89x0_device_remove,\n\t.driver = {\n\t\t.name = \"mac89x0\",\n\t},\n};\n\nmodule_platform_driver(mac89x0_platform_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}