{
  "module_name": "r8169_firmware.c",
  "hash_id": "d7b8520ac0398b482442e19f6271075b6858e99200057f7c5ab28c6747c0bd1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/realtek/r8169_firmware.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/firmware.h>\n\n#include \"r8169_firmware.h\"\n\nenum rtl_fw_opcode {\n\tPHY_READ\t\t= 0x0,\n\tPHY_DATA_OR\t\t= 0x1,\n\tPHY_DATA_AND\t\t= 0x2,\n\tPHY_BJMPN\t\t= 0x3,\n\tPHY_MDIO_CHG\t\t= 0x4,\n\tPHY_CLEAR_READCOUNT\t= 0x7,\n\tPHY_WRITE\t\t= 0x8,\n\tPHY_READCOUNT_EQ_SKIP\t= 0x9,\n\tPHY_COMP_EQ_SKIPN\t= 0xa,\n\tPHY_COMP_NEQ_SKIPN\t= 0xb,\n\tPHY_WRITE_PREVIOUS\t= 0xc,\n\tPHY_SKIPN\t\t= 0xd,\n\tPHY_DELAY_MS\t\t= 0xe,\n};\n\nstruct fw_info {\n\tu32\tmagic;\n\tchar\tversion[RTL_VER_SIZE];\n\t__le32\tfw_start;\n\t__le32\tfw_len;\n\tu8\tchksum;\n} __packed;\n\n#define FW_OPCODE_SIZE sizeof_field(struct rtl_fw_phy_action, code[0])\n\nstatic bool rtl_fw_format_ok(struct rtl_fw *rtl_fw)\n{\n\tconst struct firmware *fw = rtl_fw->fw;\n\tstruct fw_info *fw_info = (struct fw_info *)fw->data;\n\tstruct rtl_fw_phy_action *pa = &rtl_fw->phy_action;\n\n\tif (fw->size < FW_OPCODE_SIZE)\n\t\treturn false;\n\n\tif (!fw_info->magic) {\n\t\tsize_t i, size, start;\n\t\tu8 checksum = 0;\n\n\t\tif (fw->size < sizeof(*fw_info))\n\t\t\treturn false;\n\n\t\tfor (i = 0; i < fw->size; i++)\n\t\t\tchecksum += fw->data[i];\n\t\tif (checksum != 0)\n\t\t\treturn false;\n\n\t\tstart = le32_to_cpu(fw_info->fw_start);\n\t\tif (start > fw->size)\n\t\t\treturn false;\n\n\t\tsize = le32_to_cpu(fw_info->fw_len);\n\t\tif (size > (fw->size - start) / FW_OPCODE_SIZE)\n\t\t\treturn false;\n\n\t\tstrscpy(rtl_fw->version, fw_info->version, RTL_VER_SIZE);\n\n\t\tpa->code = (__le32 *)(fw->data + start);\n\t\tpa->size = size;\n\t} else {\n\t\tif (fw->size % FW_OPCODE_SIZE)\n\t\t\treturn false;\n\n\t\tstrscpy(rtl_fw->version, rtl_fw->fw_name, RTL_VER_SIZE);\n\n\t\tpa->code = (__le32 *)fw->data;\n\t\tpa->size = fw->size / FW_OPCODE_SIZE;\n\t}\n\n\treturn true;\n}\n\nstatic bool rtl_fw_data_ok(struct rtl_fw *rtl_fw)\n{\n\tstruct rtl_fw_phy_action *pa = &rtl_fw->phy_action;\n\tsize_t index;\n\n\tfor (index = 0; index < pa->size; index++) {\n\t\tu32 action = le32_to_cpu(pa->code[index]);\n\t\tu32 val = action & 0x0000ffff;\n\t\tu32 regno = (action & 0x0fff0000) >> 16;\n\n\t\tswitch (action >> 28) {\n\t\tcase PHY_READ:\n\t\tcase PHY_DATA_OR:\n\t\tcase PHY_DATA_AND:\n\t\tcase PHY_CLEAR_READCOUNT:\n\t\tcase PHY_WRITE:\n\t\tcase PHY_WRITE_PREVIOUS:\n\t\tcase PHY_DELAY_MS:\n\t\t\tbreak;\n\n\t\tcase PHY_MDIO_CHG:\n\t\t\tif (val > 1)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tcase PHY_BJMPN:\n\t\t\tif (regno > index)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase PHY_READCOUNT_EQ_SKIP:\n\t\t\tif (index + 2 >= pa->size)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase PHY_COMP_EQ_SKIPN:\n\t\tcase PHY_COMP_NEQ_SKIPN:\n\t\tcase PHY_SKIPN:\n\t\t\tif (index + 1 + regno >= pa->size)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(rtl_fw->dev, \"Invalid action 0x%08x\\n\", action);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\nout:\n\tdev_err(rtl_fw->dev, \"Out of range of firmware\\n\");\n\treturn false;\n}\n\nvoid rtl_fw_write_firmware(struct rtl8169_private *tp, struct rtl_fw *rtl_fw)\n{\n\tstruct rtl_fw_phy_action *pa = &rtl_fw->phy_action;\n\trtl_fw_write_t fw_write = rtl_fw->phy_write;\n\trtl_fw_read_t fw_read = rtl_fw->phy_read;\n\tint predata = 0, count = 0;\n\tsize_t index;\n\n\tfor (index = 0; index < pa->size; index++) {\n\t\tu32 action = le32_to_cpu(pa->code[index]);\n\t\tu32 data = action & 0x0000ffff;\n\t\tu32 regno = (action & 0x0fff0000) >> 16;\n\t\tenum rtl_fw_opcode opcode = action >> 28;\n\n\t\tif (!action)\n\t\t\tbreak;\n\n\t\tswitch (opcode) {\n\t\tcase PHY_READ:\n\t\t\tpredata = fw_read(tp, regno);\n\t\t\tcount++;\n\t\t\tbreak;\n\t\tcase PHY_DATA_OR:\n\t\t\tpredata |= data;\n\t\t\tbreak;\n\t\tcase PHY_DATA_AND:\n\t\t\tpredata &= data;\n\t\t\tbreak;\n\t\tcase PHY_BJMPN:\n\t\t\tindex -= (regno + 1);\n\t\t\tbreak;\n\t\tcase PHY_MDIO_CHG:\n\t\t\tif (data) {\n\t\t\t\tfw_write = rtl_fw->mac_mcu_write;\n\t\t\t\tfw_read = rtl_fw->mac_mcu_read;\n\t\t\t} else {\n\t\t\t\tfw_write = rtl_fw->phy_write;\n\t\t\t\tfw_read = rtl_fw->phy_read;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase PHY_CLEAR_READCOUNT:\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\tcase PHY_WRITE:\n\t\t\tfw_write(tp, regno, data);\n\t\t\tbreak;\n\t\tcase PHY_READCOUNT_EQ_SKIP:\n\t\t\tif (count == data)\n\t\t\t\tindex++;\n\t\t\tbreak;\n\t\tcase PHY_COMP_EQ_SKIPN:\n\t\t\tif (predata == data)\n\t\t\t\tindex += regno;\n\t\t\tbreak;\n\t\tcase PHY_COMP_NEQ_SKIPN:\n\t\t\tif (predata != data)\n\t\t\t\tindex += regno;\n\t\t\tbreak;\n\t\tcase PHY_WRITE_PREVIOUS:\n\t\t\tfw_write(tp, regno, predata);\n\t\t\tbreak;\n\t\tcase PHY_SKIPN:\n\t\t\tindex += regno;\n\t\t\tbreak;\n\t\tcase PHY_DELAY_MS:\n\t\t\tmsleep(data);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid rtl_fw_release_firmware(struct rtl_fw *rtl_fw)\n{\n\trelease_firmware(rtl_fw->fw);\n}\n\nint rtl_fw_request_firmware(struct rtl_fw *rtl_fw)\n{\n\tint rc;\n\n\trc = request_firmware(&rtl_fw->fw, rtl_fw->fw_name, rtl_fw->dev);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tif (!rtl_fw_format_ok(rtl_fw) || !rtl_fw_data_ok(rtl_fw)) {\n\t\trelease_firmware(rtl_fw->fw);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\treturn 0;\nout:\n\tdev_err(rtl_fw->dev, \"Unable to load firmware %s (%d)\\n\",\n\t\trtl_fw->fw_name, rc);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}