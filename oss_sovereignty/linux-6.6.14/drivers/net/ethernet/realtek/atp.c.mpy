{
  "module_name": "atp.c",
  "hash_id": "6ebfa832eb749c3c01b85b5c54d54172fbee4a519f6dceb7bf91638b880bcbda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/realtek/atp.c",
  "human_readable_source": " \n \n\nstatic const char version[] =\n\"atp.c:v1.09=ac 2002/10/01 Donald Becker <becker@scyld.com>\\n\";\n\n \n\nstatic int debug = 1; \t\t\t \n#define net_debug debug\n\n \nstatic int max_interrupt_work = 15;\n\n#define NUM_UNITS 2\n \nstatic int io[NUM_UNITS];\nstatic int irq[NUM_UNITS];\nstatic int xcvr[NUM_UNITS]; \t\t\t \n\n \n\n \n#define TX_TIMEOUT  (400*HZ/1000)\n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/crc32.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n\n#include \"atp.h\"\n\nMODULE_AUTHOR(\"Donald Becker <becker@scyld.com>\");\nMODULE_DESCRIPTION(\"RealTek RTL8002/8012 parallel port Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(max_interrupt_work, int, 0);\nmodule_param(debug, int, 0);\nmodule_param_hw_array(io, int, ioport, NULL, 0);\nmodule_param_hw_array(irq, int, irq, NULL, 0);\nmodule_param_array(xcvr, int, NULL, 0);\nMODULE_PARM_DESC(max_interrupt_work, \"ATP maximum events handled per interrupt\");\nMODULE_PARM_DESC(debug, \"ATP debug level (0-7)\");\nMODULE_PARM_DESC(io, \"ATP I/O base address(es)\");\nMODULE_PARM_DESC(irq, \"ATP IRQ number(s)\");\nMODULE_PARM_DESC(xcvr, \"ATP transceiver(s) (0=internal, 1=external)\");\n\n \n#define ETHERCARD_TOTAL_SIZE\t3\n\n \nstatic char mux_8012[] = { 0xff, 0xf7, 0xff, 0xfb, 0xf3, 0xfb, 0xff, 0xf7,};\n\nstruct net_local {\n    spinlock_t lock;\n    struct net_device *next_module;\n    struct timer_list timer;\t \n    struct net_device *dev;\t \n    unsigned long last_rx_time;\t \n    int saved_tx_size;\n    unsigned int tx_unit_busy:1;\n    unsigned char re_tx,\t \n\t\taddr_mode,\t\t \n\t\tpac_cnt_in_tx_buf;\n};\n\n \n#define TIMED_CHECKER (HZ/4)\n#ifdef TIMED_CHECKER\n#include <linux/timer.h>\nstatic void atp_timed_checker(struct timer_list *t);\n#endif\n\n \n\nstatic int atp_probe1(long ioaddr);\nstatic void get_node_ID(struct net_device *dev);\nstatic unsigned short eeprom_op(long ioaddr, unsigned int cmd);\nstatic int net_open(struct net_device *dev);\nstatic void hardware_init(struct net_device *dev);\nstatic void write_packet(long ioaddr, int length, unsigned char *packet, int pad, int mode);\nstatic void trigger_send(long ioaddr, int length);\nstatic netdev_tx_t atp_send_packet(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev);\nstatic irqreturn_t atp_interrupt(int irq, void *dev_id);\nstatic void net_rx(struct net_device *dev);\nstatic void read_block(long ioaddr, int length, unsigned char *buffer, int data_mode);\nstatic int net_close(struct net_device *dev);\nstatic void set_rx_mode(struct net_device *dev);\nstatic void tx_timeout(struct net_device *dev, unsigned int txqueue);\n\n\n \nstatic struct net_device *root_atp_dev;\n\n \nstatic int __init atp_init(void)\n{\n\tint *port, ports[] = {0x378, 0x278, 0x3bc, 0};\n\tint base_addr = io[0];\n\n\tif (base_addr > 0x1ff)\t\t \n\t\treturn atp_probe1(base_addr);\n\telse if (base_addr == 1)\t \n\t\treturn -ENXIO;\n\n\tfor (port = ports; *port; port++) {\n\t\tlong ioaddr = *port;\n\t\toutb(0x57, ioaddr + PAR_DATA);\n\t\tif (inb(ioaddr + PAR_DATA) != 0x57)\n\t\t\tcontinue;\n\t\tif (atp_probe1(ioaddr) == 0)\n\t\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic const struct net_device_ops atp_netdev_ops = {\n\t.ndo_open\t\t= net_open,\n\t.ndo_stop\t\t= net_close,\n\t.ndo_start_xmit\t\t= atp_send_packet,\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_tx_timeout\t\t= tx_timeout,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int __init atp_probe1(long ioaddr)\n{\n\tstruct net_device *dev = NULL;\n\tstruct net_local *lp;\n\tint saved_ctrl_reg, status, i;\n\tint res;\n\n\toutb(0xff, ioaddr + PAR_DATA);\n\t \n\tsaved_ctrl_reg = inb(ioaddr + PAR_CONTROL);\n\tif (net_debug > 3)\n\t\tprintk(\"atp: Control register was %#2.2x.\\n\", saved_ctrl_reg);\n\t \n\toutb(0x04, ioaddr + PAR_CONTROL);\n#ifndef final_version\n\tif (net_debug > 3) {\n\t\t \n\t\tfor (i = 0; i < 8; i++)\n\t\t\toutb(mux_8012[i], ioaddr + PAR_DATA);\n\t\twrite_reg(ioaddr, MODSEL, 0x00);\n\t\tprintk(\"atp: Registers are \");\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tprintk(\" %2.2x\", read_nibble(ioaddr, i));\n\t\tprintk(\".\\n\");\n\t}\n#endif\n\t \n\tfor (i = 0; i < 8; i++)\n\t\toutb(mux_8012[i], ioaddr + PAR_DATA);\n\twrite_reg_high(ioaddr, CMR1, CMR1h_RESET);\n\t \n\tstatus = read_nibble(ioaddr, CMR1);\n\n\tif (net_debug > 3) {\n\t\tprintk(KERN_DEBUG \"atp: Status nibble was %#2.2x..\", status);\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tprintk(\" %2.2x\", read_nibble(ioaddr, i));\n\t\tprintk(\"\\n\");\n\t}\n\n\tif ((status & 0x78) != 0x08) {\n\t\t \n\t\toutb(saved_ctrl_reg, ioaddr + PAR_CONTROL);\n\t\treturn -ENODEV;\n\t}\n\tstatus = read_nibble(ioaddr, CMR2_h);\n\tif ((status & 0x78) != 0x10) {\n\t\toutb(saved_ctrl_reg, ioaddr + PAR_CONTROL);\n\t\treturn -ENODEV;\n\t}\n\n\tdev = alloc_etherdev(sizeof(struct net_local));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\twrite_reg_byte(ioaddr, CMR2, 0x01);\t\t\t \n\twrite_reg_high(ioaddr, CMR1, CMR1h_RxENABLE | CMR1h_TxENABLE);\t \n\n\t \n\tif (irq[0])\n\t\tdev->irq = irq[0];\n\telse if (ioaddr == 0x378)\n\t\tdev->irq = 7;\n\telse\n\t\tdev->irq = 5;\n\twrite_reg_high(ioaddr, CMR1, CMR1h_TxRxOFF);  \n\twrite_reg(ioaddr, CMR2, CMR2_NULL);\n\n\tdev->base_addr = ioaddr;\n\n\t \n\tget_node_ID(dev);\n\n#ifndef MODULE\n\tif (net_debug)\n\t\tprintk(KERN_INFO \"%s\", version);\n#endif\n\n\tprintk(KERN_NOTICE \"%s: Pocket adapter found at %#3lx, IRQ %d, \"\n\t       \"SAPROM %pM.\\n\",\n\t       dev->name, dev->base_addr, dev->irq, dev->dev_addr);\n\n\t \n\twrite_reg_high(ioaddr, CMR1, CMR1h_RESET | CMR1h_MUX);\n\n\tlp = netdev_priv(dev);\n\tlp->addr_mode = CMR2h_Normal;\n\tspin_lock_init(&lp->lock);\n\n\t \n\tif (xcvr[0])\n\t\tdev->if_port = xcvr[0];\n\telse\n\t\tdev->if_port = (dev->mem_start & 0xf) ? (dev->mem_start & 0x7) : 4;\n\tif (dev->mem_end & 0xf)\n\t\tnet_debug = dev->mem_end & 7;\n\n\tdev->netdev_ops \t= &atp_netdev_ops;\n\tdev->watchdog_timeo\t= TX_TIMEOUT;\n\n\tres = register_netdev(dev);\n\tif (res) {\n\t\tfree_netdev(dev);\n\t\treturn res;\n\t}\n\n\tlp->next_module = root_atp_dev;\n\troot_atp_dev = dev;\n\n\treturn 0;\n}\n\n \nstatic void __init get_node_ID(struct net_device *dev)\n{\n\tlong ioaddr = dev->base_addr;\n\t__be16 addr[ETH_ALEN / 2];\n\tint sa_offset = 0;\n\tint i;\n\n\twrite_reg(ioaddr, CMR2, CMR2_EEPROM);\t   \n\n\t \n\tif (eeprom_op(ioaddr, EE_READ(0)) == 0xffff)\n\t\tsa_offset = 15;\n\n\tfor (i = 0; i < 3; i++)\n\t\taddr[i] =\n\t\t\tcpu_to_be16(eeprom_op(ioaddr, EE_READ(sa_offset + i)));\n\teth_hw_addr_set(dev, (u8 *)addr);\n\n\twrite_reg(ioaddr, CMR2, CMR2_NULL);\n}\n\n \n\nstatic unsigned short __init eeprom_op(long ioaddr, u32 cmd)\n{\n\tunsigned eedata_out = 0;\n\tint num_bits = EE_CMD_SIZE;\n\n\twhile (--num_bits >= 0) {\n\t\tchar outval = (cmd & (1<<num_bits)) ? EE_DATA_WRITE : 0;\n\t\twrite_reg_high(ioaddr, PROM_CMD, outval | EE_CLK_LOW);\n\t\twrite_reg_high(ioaddr, PROM_CMD, outval | EE_CLK_HIGH);\n\t\teedata_out <<= 1;\n\t\tif (read_nibble(ioaddr, PROM_DATA) & EE_DATA_READ)\n\t\t\teedata_out++;\n\t}\n\twrite_reg_high(ioaddr, PROM_CMD, EE_CLK_LOW & ~EE_CS);\n\treturn eedata_out;\n}\n\n\n \nstatic int net_open(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tint ret;\n\n\t \n\tret = request_irq(dev->irq, atp_interrupt, 0, dev->name, dev);\n\tif (ret)\n\t\treturn ret;\n\n\thardware_init(dev);\n\n\tlp->dev = dev;\n\ttimer_setup(&lp->timer, atp_timed_checker, 0);\n\tlp->timer.expires = jiffies + TIMED_CHECKER;\n\tadd_timer(&lp->timer);\n\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\n \nstatic void hardware_init(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tlong ioaddr = dev->base_addr;\n\tint i;\n\n\t \n\tfor (i = 0; i < 8; i++)\n\t\toutb(mux_8012[i], ioaddr + PAR_DATA);\n\twrite_reg_high(ioaddr, CMR1, CMR1h_RESET);\n\n\tfor (i = 0; i < 6; i++)\n\t\twrite_reg_byte(ioaddr, PAR0 + i, dev->dev_addr[i]);\n\n\twrite_reg_high(ioaddr, CMR2, lp->addr_mode);\n\n\tif (net_debug > 2) {\n\t\tprintk(KERN_DEBUG \"%s: Reset: current Rx mode %d.\\n\", dev->name,\n\t\t\t   (read_nibble(ioaddr, CMR2_h) >> 3) & 0x0f);\n\t}\n\n\twrite_reg(ioaddr, CMR2, CMR2_IRQOUT);\n\twrite_reg_high(ioaddr, CMR1, CMR1h_RxENABLE | CMR1h_TxENABLE);\n\n\t \n\toutb(Ctrl_SelData + Ctrl_IRQEN, ioaddr + PAR_CONTROL);\n\n\t \n\twrite_reg(ioaddr, IMR, ISR_RxOK | ISR_TxErr | ISR_TxOK);\n\twrite_reg_high(ioaddr, IMR, ISRh_RxErr);\n\n\tlp->tx_unit_busy = 0;\n\tlp->pac_cnt_in_tx_buf = 0;\n\tlp->saved_tx_size = 0;\n}\n\nstatic void trigger_send(long ioaddr, int length)\n{\n\twrite_reg_byte(ioaddr, TxCNT0, length & 0xff);\n\twrite_reg(ioaddr, TxCNT1, length >> 8);\n\twrite_reg(ioaddr, CMR1, CMR1_Xmit);\n}\n\nstatic void write_packet(long ioaddr, int length, unsigned char *packet, int pad_len, int data_mode)\n{\n    if (length & 1)\n    {\n\tlength++;\n\tpad_len++;\n    }\n\n    outb(EOC+MAR, ioaddr + PAR_DATA);\n    if ((data_mode & 1) == 0) {\n\t\t \n\t\toutb(WrAddr+MAR, ioaddr + PAR_DATA);\n\t\tdo {\n\t\t\twrite_byte_mode0(ioaddr, *packet++);\n\t\t} while (--length > pad_len) ;\n\t\tdo {\n\t\t\twrite_byte_mode0(ioaddr, 0);\n\t\t} while (--length > 0) ;\n    } else {\n\t\t \n\t\tunsigned char outbyte = *packet++;\n\n\t\toutb(Ctrl_LNibWrite + Ctrl_IRQEN, ioaddr + PAR_CONTROL);\n\t\toutb(WrAddr+MAR, ioaddr + PAR_DATA);\n\n\t\toutb((outbyte & 0x0f)|0x40, ioaddr + PAR_DATA);\n\t\toutb(outbyte & 0x0f, ioaddr + PAR_DATA);\n\t\toutbyte >>= 4;\n\t\toutb(outbyte & 0x0f, ioaddr + PAR_DATA);\n\t\toutb(Ctrl_HNibWrite + Ctrl_IRQEN, ioaddr + PAR_CONTROL);\n\t\twhile (--length > pad_len)\n\t\t\twrite_byte_mode1(ioaddr, *packet++);\n\t\twhile (--length > 0)\n\t\t\twrite_byte_mode1(ioaddr, 0);\n    }\n     \n    outb(0xff, ioaddr + PAR_DATA);\n    outb(Ctrl_HNibWrite | Ctrl_SelData | Ctrl_IRQEN, ioaddr + PAR_CONTROL);\n}\n\nstatic void tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tlong ioaddr = dev->base_addr;\n\n\tprintk(KERN_WARNING \"%s: Transmit timed out, %s?\\n\", dev->name,\n\t\t   inb(ioaddr + PAR_CONTROL) & 0x10 ? \"network cable problem\"\n\t\t   :  \"IRQ conflict\");\n\tdev->stats.tx_errors++;\n\t \n\thardware_init(dev);\n\tnetif_trans_update(dev);  \n\tnetif_wake_queue(dev);\n\tdev->stats.tx_errors++;\n}\n\nstatic netdev_tx_t atp_send_packet(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tlong ioaddr = dev->base_addr;\n\tint length;\n\tunsigned long flags;\n\n\tlength = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\n\n\tnetif_stop_queue(dev);\n\n\t \n\n\tspin_lock_irqsave(&lp->lock, flags);\n\twrite_reg(ioaddr, IMR, 0);\n\twrite_reg_high(ioaddr, IMR, 0);\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\twrite_packet(ioaddr, length, skb->data, length-skb->len, dev->if_port);\n\n\tlp->pac_cnt_in_tx_buf++;\n\tif (lp->tx_unit_busy == 0) {\n\t\ttrigger_send(ioaddr, length);\n\t\tlp->saved_tx_size = 0; \t\t\t\t \n\t\tlp->re_tx = 0;\n\t\tlp->tx_unit_busy = 1;\n\t} else\n\t\tlp->saved_tx_size = length;\n\t \n\twrite_reg(ioaddr, IMR, ISR_RxOK | ISR_TxErr | ISR_TxOK);\n\twrite_reg_high(ioaddr, IMR, ISRh_RxErr);\n\n\tdev_kfree_skb (skb);\n\treturn NETDEV_TX_OK;\n}\n\n\n \nstatic irqreturn_t atp_interrupt(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct net_local *lp;\n\tlong ioaddr;\n\tstatic int num_tx_since_rx;\n\tint boguscount = max_interrupt_work;\n\tint handled = 0;\n\n\tioaddr = dev->base_addr;\n\tlp = netdev_priv(dev);\n\n\tspin_lock(&lp->lock);\n\n\t \n\toutb(Ctrl_SelData, ioaddr + PAR_CONTROL);\n\n\t \n\twrite_reg(ioaddr, CMR2, CMR2_NULL);\n\twrite_reg(ioaddr, IMR, 0);\n\n\tif (net_debug > 5)\n\t\tprintk(KERN_DEBUG \"%s: In interrupt \", dev->name);\n\twhile (--boguscount > 0) {\n\t\tint status = read_nibble(ioaddr, ISR);\n\t\tif (net_debug > 5)\n\t\t\tprintk(\"loop status %02x..\", status);\n\n\t\tif (status & (ISR_RxOK<<3)) {\n\t\t\thandled = 1;\n\t\t\twrite_reg(ioaddr, ISR, ISR_RxOK);  \n\t\t\tdo {\n\t\t\t\tint read_status = read_nibble(ioaddr, CMR1);\n\t\t\t\tif (net_debug > 6)\n\t\t\t\t\tprintk(\"handling Rx packet %02x..\", read_status);\n\t\t\t\t \n\t\t\t\tif (read_status & (CMR1_IRQ << 3)) {  \n\t\t\t\t\tdev->stats.rx_over_errors++;\n\t\t\t\t\t \n\t\t\t\t\twrite_reg_high(ioaddr, CMR2, CMR2h_OFF);\n\t\t\t\t\tnet_rx(dev);\n\t\t\t\t\t \n\t\t\t\t\twrite_reg_high(ioaddr, ISR, ISRh_RxErr);\n\t\t\t\t\twrite_reg_high(ioaddr, CMR2, lp->addr_mode);\n\t\t\t\t} else if ((read_status & (CMR1_BufEnb << 3)) == 0) {\n\t\t\t\t\tnet_rx(dev);\n\t\t\t\t\tnum_tx_since_rx = 0;\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\t\t\t} while (--boguscount > 0);\n\t\t} else if (status & ((ISR_TxErr + ISR_TxOK)<<3)) {\n\t\t\thandled = 1;\n\t\t\tif (net_debug > 6)\n\t\t\t\tprintk(\"handling Tx done..\");\n\t\t\t \n\t\t\twrite_reg(ioaddr, ISR, ISR_TxErr + ISR_TxOK);\n\t\t\tif (status & (ISR_TxErr<<3)) {\n\t\t\t\tdev->stats.collisions++;\n\t\t\t\tif (++lp->re_tx > 15) {\n\t\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\t\t\thardware_init(dev);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (net_debug > 6)  printk(\"attempting to ReTx\");\n\t\t\t\twrite_reg(ioaddr, CMR1, CMR1_ReXmit + CMR1_Xmit);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\tlp->pac_cnt_in_tx_buf--;\n\t\t\t\tif ( lp->saved_tx_size) {\n\t\t\t\t\ttrigger_send(ioaddr, lp->saved_tx_size);\n\t\t\t\t\tlp->saved_tx_size = 0;\n\t\t\t\t\tlp->re_tx = 0;\n\t\t\t\t} else\n\t\t\t\t\tlp->tx_unit_busy = 0;\n\t\t\t\tnetif_wake_queue(dev);\t \n\t\t\t}\n\t\t\tnum_tx_since_rx++;\n\t\t} else if (num_tx_since_rx > 8 &&\n\t\t\t   time_after(jiffies, lp->last_rx_time + HZ)) {\n\t\t\tif (net_debug > 2)\n\t\t\t\tprintk(KERN_DEBUG \"%s: Missed packet? No Rx after %d Tx and \"\n\t\t\t\t\t   \"%ld jiffies status %02x  CMR1 %02x.\\n\", dev->name,\n\t\t\t\t\t   num_tx_since_rx, jiffies - lp->last_rx_time, status,\n\t\t\t\t\t   (read_nibble(ioaddr, CMR1) >> 3) & 15);\n\t\t\tdev->stats.rx_missed_errors++;\n\t\t\thardware_init(dev);\n\t\t\tnum_tx_since_rx = 0;\n\t\t\tbreak;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\t \n\t{\n\t\tint i;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\twrite_reg_byte(ioaddr, PAR0 + i, dev->dev_addr[i]);\n#if 0 && defined(TIMED_CHECKER)\n\t\tmod_timer(&lp->timer, jiffies + TIMED_CHECKER);\n#endif\n\t}\n\n\t \n\twrite_reg(ioaddr, CMR2, CMR2_IRQOUT);\n\t \n\toutb(Ctrl_SelData + Ctrl_IRQEN, ioaddr + PAR_CONTROL);\n\t \n\twrite_reg(ioaddr, IMR, ISR_RxOK | ISR_TxErr | ISR_TxOK);\n\twrite_reg_high(ioaddr, IMR, ISRh_RxErr); \t\t\t \n\n\tspin_unlock(&lp->lock);\n\n\tif (net_debug > 5) printk(\"exiting interrupt.\\n\");\n\treturn IRQ_RETVAL(handled);\n}\n\n#ifdef TIMED_CHECKER\n \nstatic void atp_timed_checker(struct timer_list *t)\n{\n\tstruct net_local *lp = from_timer(lp, t, timer);\n\tstruct net_device *dev = lp->dev;\n\tlong ioaddr = dev->base_addr;\n\tint tickssofar = jiffies - lp->last_rx_time;\n\tint i;\n\n\tspin_lock(&lp->lock);\n\tif (tickssofar > 2*HZ) {\n#if 1\n\t\tfor (i = 0; i < 6; i++)\n\t\t\twrite_reg_byte(ioaddr, PAR0 + i, dev->dev_addr[i]);\n\t\tlp->last_rx_time = jiffies;\n#else\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tif (read_cmd_byte(ioaddr, PAR0 + i) != atp_timed_dev->dev_addr[i])\n\t\t\t\t{\n\t\t\tstruct net_local *lp = netdev_priv(atp_timed_dev);\n\t\t\twrite_reg_byte(ioaddr, PAR0 + i, atp_timed_dev->dev_addr[i]);\n\t\t\tif (i == 2)\n\t\t\t  dev->stats.tx_errors++;\n\t\t\telse if (i == 3)\n\t\t\t  dev->stats.tx_dropped++;\n\t\t\telse if (i == 4)\n\t\t\t  dev->stats.collisions++;\n\t\t\telse\n\t\t\t  dev->stats.rx_errors++;\n\t\t  }\n#endif\n\t}\n\tspin_unlock(&lp->lock);\n\tlp->timer.expires = jiffies + TIMED_CHECKER;\n\tadd_timer(&lp->timer);\n}\n#endif\n\n \nstatic void net_rx(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tlong ioaddr = dev->base_addr;\n\tstruct rx_header rx_head;\n\n\t \n\toutb(EOC+MAR, ioaddr + PAR_DATA);\n\tread_block(ioaddr, 8, (unsigned char*)&rx_head, dev->if_port);\n\tif (net_debug > 5)\n\t\tprintk(KERN_DEBUG \" rx_count %04x %04x %04x %04x..\", rx_head.pad,\n\t\t\t   rx_head.rx_count, rx_head.rx_status, rx_head.cur_addr);\n\tif ((rx_head.rx_status & 0x77) != 0x01) {\n\t\tdev->stats.rx_errors++;\n\t\tif (rx_head.rx_status & 0x0004) dev->stats.rx_frame_errors++;\n\t\telse if (rx_head.rx_status & 0x0002) dev->stats.rx_crc_errors++;\n\t\tif (net_debug > 3)\n\t\t\tprintk(KERN_DEBUG \"%s: Unknown ATP Rx error %04x.\\n\",\n\t\t\t\t   dev->name, rx_head.rx_status);\n\t\tif  (rx_head.rx_status & 0x0020) {\n\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\twrite_reg_high(ioaddr, CMR1, CMR1h_TxENABLE);\n\t\t\twrite_reg_high(ioaddr, CMR1, CMR1h_RxENABLE | CMR1h_TxENABLE);\n\t\t} else if (rx_head.rx_status & 0x0050)\n\t\t\thardware_init(dev);\n\t\treturn;\n\t} else {\n\t\t \n\t\tint pkt_len = (rx_head.rx_count & 0x7ff) - 4;\n\t\tstruct sk_buff *skb;\n\n\t\tskb = netdev_alloc_skb(dev, pkt_len + 2);\n\t\tif (skb == NULL) {\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tgoto done;\n\t\t}\n\n\t\tskb_reserve(skb, 2);\t \n\t\tread_block(ioaddr, pkt_len, skb_put(skb,pkt_len), dev->if_port);\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tnetif_rx(skb);\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += pkt_len;\n\t}\n done:\n\twrite_reg(ioaddr, CMR1, CMR1_NextPkt);\n\tlp->last_rx_time = jiffies;\n}\n\nstatic void read_block(long ioaddr, int length, unsigned char *p, int data_mode)\n{\n\tif (data_mode <= 3) {  \n\t\toutb(Ctrl_LNibRead, ioaddr + PAR_CONTROL);\n\t\toutb(length == 8  ?  RdAddr | HNib | MAR  :  RdAddr | MAR,\n\t\t\t ioaddr + PAR_DATA);\n\t\tif (data_mode <= 1) {  \n\t\t\tdo { *p++ = read_byte_mode0(ioaddr); } while (--length > 0);\n\t\t} else {  \n\t\t\tdo { *p++ = read_byte_mode2(ioaddr); } while (--length > 0);\n\t\t}\n\t} else if (data_mode <= 5) {\n\t\tdo { *p++ = read_byte_mode4(ioaddr); } while (--length > 0);\n\t} else {\n\t\tdo { *p++ = read_byte_mode6(ioaddr); } while (--length > 0);\n\t}\n\n\toutb(EOC+HNib+MAR, ioaddr + PAR_DATA);\n\toutb(Ctrl_SelData, ioaddr + PAR_CONTROL);\n}\n\n \nstatic int\nnet_close(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tlong ioaddr = dev->base_addr;\n\n\tnetif_stop_queue(dev);\n\n\tdel_timer_sync(&lp->timer);\n\n\t \n\tlp->addr_mode = CMR2h_OFF;\n\twrite_reg_high(ioaddr, CMR2, CMR2h_OFF);\n\n\t \n\toutb(0x00, ioaddr + PAR_CONTROL);\n\tfree_irq(dev->irq, dev);\n\n\t \n\twrite_reg_high(ioaddr, CMR1, CMR1h_RESET | CMR1h_MUX);\n\treturn 0;\n}\n\n \n\nstatic void set_rx_mode(struct net_device *dev)\n{\n\tstruct net_local *lp = netdev_priv(dev);\n\tlong ioaddr = dev->base_addr;\n\n\tif (!netdev_mc_empty(dev) || (dev->flags & (IFF_ALLMULTI|IFF_PROMISC)))\n\t\tlp->addr_mode = CMR2h_PROMISC;\n\telse\n\t\tlp->addr_mode = CMR2h_Normal;\n\twrite_reg_high(ioaddr, CMR2, lp->addr_mode);\n}\n\nstatic int __init atp_init_module(void) {\n\tif (debug)\t\t\t\t\t \n\t\tprintk(KERN_INFO \"%s\", version);\n\treturn atp_init();\n}\n\nstatic void __exit atp_cleanup_module(void) {\n\tstruct net_device *next_dev;\n\n\twhile (root_atp_dev) {\n\t\tstruct net_local *atp_local = netdev_priv(root_atp_dev);\n\t\tnext_dev = atp_local->next_module;\n\t\tunregister_netdev(root_atp_dev);\n\t\t \n\t\tfree_netdev(root_atp_dev);\n\t\troot_atp_dev = next_dev;\n\t}\n}\n\nmodule_init(atp_init_module);\nmodule_exit(atp_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}