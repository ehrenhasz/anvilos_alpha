{
  "module_name": "atp.h",
  "hash_id": "3e1e080b1c66859b3eb86861ebb07420864f4f094a1d904c57a38ab43cf19459",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/realtek/atp.h",
  "human_readable_source": " \n \n \n\n#include <linux/if_ether.h>\n#include <linux/types.h>\n\n \nstruct rx_header {\n\tushort pad;\t\t \n\tushort rx_count;\n\tushort rx_status;\t \n\tushort cur_addr;\t \n};\n\n#define PAR_DATA\t0\n#define PAR_STATUS\t1\n#define PAR_CONTROL 2\n\n#define Ctrl_LNibRead\t0x08\t \n#define Ctrl_HNibRead\t0\n#define Ctrl_LNibWrite\t0x08\t \n#define Ctrl_HNibWrite\t0\n#define Ctrl_SelData\t0x04\t \n#define Ctrl_IRQEN\t0x10\t \n\n#define EOW\t0xE0\n#define EOC\t0xE0\n#define WrAddr\t0x40\t \n#define RdAddr\t0xC0\n#define HNib\t0x10\n\nenum page0_regs {\n\t \n\tPAR0 = 0, PAR1 = 1, PAR2 = 2, PAR3 = 3, PAR4 = 4, PAR5 = 5,\n\tTxCNT0 = 6, TxCNT1 = 7,\t\t \n\tTxSTAT = 8, RxSTAT = 9,\t\t \n\tISR = 10, IMR = 11,\t\t \n\tCMR1 = 12,\t\t\t \n\tCMR2 = 13,\t\t\t \n\tMODSEL = 14,\t\t \n\tMAR = 14,\t\t\t \n\tCMR2_h = 0x1d,\n};\n\nenum eepage_regs {\n\tPROM_CMD = 6,\n\tPROM_DATA = 7\t \n};\n\n#define ISR_TxOK\t0x01\n#define ISR_RxOK\t0x04\n#define ISR_TxErr\t0x02\n#define ISRh_RxErr\t0x11\t \n\n#define CMR1h_MUX\t0x08\t \n#define CMR1h_RESET\t0x04\t \n#define CMR1h_RxENABLE\t0x02\t \n#define CMR1h_TxENABLE\t0x01\t \n#define CMR1h_TxRxOFF\t0x00\n#define CMR1_ReXmit\t0x08\t \n#define CMR1_Xmit\t0x04\t \n#define\tCMR1_IRQ\t0x02\t \n#define\tCMR1_BufEnb\t0x01\t \n#define\tCMR1_NextPkt\t0x01\t \n\n#define CMR2_NULL\t8\n#define CMR2_IRQOUT\t9\n#define CMR2_RAMTEST\t10\n#define CMR2_EEPROM\t12\t \n\n#define CMR2h_OFF\t0\t \n#define CMR2h_Physical\t1\t \n#define CMR2h_Normal\t2\t \n#define CMR2h_PROMISC\t3\t \n\n \nstatic inline unsigned char inbyte(unsigned short port)\n{\n\tunsigned char _v;\n\n\t__asm__ __volatile__ (\"inb %w1,%b0\" : \"=a\" (_v) : \"d\" (port));\n\treturn _v;\n}\n\n \nstatic inline unsigned char read_nibble(short port, unsigned char offset)\n{\n\tunsigned char retval;\n\n\toutb(EOC+offset, port + PAR_DATA);\n\toutb(RdAddr+offset, port + PAR_DATA);\n\tinbyte(port + PAR_STATUS);\t \n\tretval = inbyte(port + PAR_STATUS);\n\toutb(EOC+offset, port + PAR_DATA);\n\n\treturn retval;\n}\n\n \n \nstatic inline unsigned char read_byte_mode0(short ioaddr)\n{\n\tunsigned char low_nib;\n\n\toutb(Ctrl_LNibRead, ioaddr + PAR_CONTROL);\n\tinbyte(ioaddr + PAR_STATUS);\n\tlow_nib = (inbyte(ioaddr + PAR_STATUS) >> 3) & 0x0f;\n\toutb(Ctrl_HNibRead, ioaddr + PAR_CONTROL);\n\tinbyte(ioaddr + PAR_STATUS);\t \n\tinbyte(ioaddr + PAR_STATUS);\t \n\treturn low_nib | ((inbyte(ioaddr + PAR_STATUS) << 1) & 0xf0);\n}\n\n \nstatic inline unsigned char read_byte_mode2(short ioaddr)\n{\n\tunsigned char low_nib;\n\n\toutb(Ctrl_LNibRead, ioaddr + PAR_CONTROL);\n\tinbyte(ioaddr + PAR_STATUS);\n\tlow_nib = (inbyte(ioaddr + PAR_STATUS) >> 3) & 0x0f;\n\toutb(Ctrl_HNibRead, ioaddr + PAR_CONTROL);\n\tinbyte(ioaddr + PAR_STATUS);\t \n\treturn low_nib | ((inbyte(ioaddr + PAR_STATUS) << 1) & 0xf0);\n}\n\n \nstatic inline unsigned char read_byte_mode4(short ioaddr)\n{\n\tunsigned char low_nib;\n\n\toutb(RdAddr | MAR, ioaddr + PAR_DATA);\n\tlow_nib = (inbyte(ioaddr + PAR_STATUS) >> 3) & 0x0f;\n\toutb(RdAddr | HNib | MAR, ioaddr + PAR_DATA);\n\treturn low_nib | ((inbyte(ioaddr + PAR_STATUS) << 1) & 0xf0);\n}\n\n \nstatic inline unsigned char read_byte_mode6(short ioaddr)\n{\n\tunsigned char low_nib;\n\n\toutb(RdAddr | MAR, ioaddr + PAR_DATA);\n\tinbyte(ioaddr + PAR_STATUS);\n\tlow_nib = (inbyte(ioaddr + PAR_STATUS) >> 3) & 0x0f;\n\toutb(RdAddr | HNib | MAR, ioaddr + PAR_DATA);\n\tinbyte(ioaddr + PAR_STATUS);\n\treturn low_nib | ((inbyte(ioaddr + PAR_STATUS) << 1) & 0xf0);\n}\n\nstatic inline void\nwrite_reg(short port, unsigned char reg, unsigned char value)\n{\n\tunsigned char outval;\n\n\toutb(EOC | reg, port + PAR_DATA);\n\toutval = WrAddr | reg;\n\toutb(outval, port + PAR_DATA);\n\toutb(outval, port + PAR_DATA);\t \n\n\toutval &= 0xf0;\n\toutval |= value;\n\toutb(outval, port + PAR_DATA);\n\toutval &= 0x1f;\n\toutb(outval, port + PAR_DATA);\n\toutb(outval, port + PAR_DATA);\n\n\toutb(EOC | outval, port + PAR_DATA);\n}\n\nstatic inline void\nwrite_reg_high(short port, unsigned char reg, unsigned char value)\n{\n\tunsigned char outval = EOC | HNib | reg;\n\n\toutb(outval, port + PAR_DATA);\n\toutval &= WrAddr | HNib | 0x0f;\n\toutb(outval, port + PAR_DATA);\n\toutb(outval, port + PAR_DATA);\t \n\n\toutval = WrAddr | HNib | value;\n\toutb(outval, port + PAR_DATA);\n\toutval &= HNib | 0x0f;\t\t \n\toutb(outval, port + PAR_DATA);\n\toutb(outval, port + PAR_DATA);\n\n\toutb(EOC | HNib | outval, port + PAR_DATA);\n}\n\n \nstatic inline void\nwrite_reg_byte(short port, unsigned char reg, unsigned char value)\n{\n\tunsigned char outval;\n\n\toutb(EOC | reg, port + PAR_DATA);  \n\toutval = WrAddr | reg;\n\toutb(outval, port + PAR_DATA);\n\toutb(outval, port + PAR_DATA);\t \n\n\toutb((outval & 0xf0) | (value & 0x0f), port + PAR_DATA);\n\toutb(value & 0x0f, port + PAR_DATA);\n\tvalue >>= 4;\n\toutb(value, port + PAR_DATA);\n\toutb(0x10 | value, port + PAR_DATA);\n\toutb(0x10 | value, port + PAR_DATA);\n\n\toutb(EOC  | value, port + PAR_DATA);  \n}\n\n \nstatic inline void write_byte_mode0(short ioaddr, unsigned char value)\n{\n\toutb(value & 0x0f, ioaddr + PAR_DATA);\n\toutb((value>>4) | 0x10, ioaddr + PAR_DATA);\n}\n\nstatic inline void write_byte_mode1(short ioaddr, unsigned char value)\n{\n\toutb(value & 0x0f, ioaddr + PAR_DATA);\n\toutb(Ctrl_IRQEN | Ctrl_LNibWrite, ioaddr + PAR_CONTROL);\n\toutb((value>>4) | 0x10, ioaddr + PAR_DATA);\n\toutb(Ctrl_IRQEN | Ctrl_HNibWrite, ioaddr + PAR_CONTROL);\n}\n\n \nstatic inline void write_word_mode0(short ioaddr, unsigned short value)\n{\n\toutb(value & 0x0f, ioaddr + PAR_DATA);\n\tvalue >>= 4;\n\toutb((value & 0x0f) | 0x10, ioaddr + PAR_DATA);\n\tvalue >>= 4;\n\toutb(value & 0x0f, ioaddr + PAR_DATA);\n\tvalue >>= 4;\n\toutb((value & 0x0f) | 0x10, ioaddr + PAR_DATA);\n}\n\n \n#define EE_SHIFT_CLK\t0x04\t \n#define EE_CS\t\t0x02\t \n#define EE_CLK_HIGH\t0x12\n#define EE_CLK_LOW\t0x16\n#define EE_DATA_WRITE\t0x01\t \n#define EE_DATA_READ\t0x08\t \n\n \n#define EE_WRITE_CMD(offset)\t(((5 << 6) + (offset)) << 17)\n#define EE_READ(offset)\t\t(((6 << 6) + (offset)) << 17)\n#define EE_ERASE(offset)\t(((7 << 6) + (offset)) << 17)\n#define EE_CMD_SIZE\t27\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}