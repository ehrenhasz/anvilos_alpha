{
  "module_name": "8139too.c",
  "hash_id": "7fb506c87476aca997172ac69cd053eb577c168f6c9d88c51b61350d1a1f6d3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/realtek/8139too.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DRV_NAME\t\"8139too\"\n#define DRV_VERSION\t\"0.9.28\"\n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/completion.h>\n#include <linux/crc32.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/if_vlan.h>\n#include <asm/irq.h>\n\n#define RTL8139_DRIVER_NAME   DRV_NAME \" Fast Ethernet driver \" DRV_VERSION\n\n \n#define RTL8139_DEF_MSG_ENABLE   (NETIF_MSG_DRV   | \\\n                                 NETIF_MSG_PROBE  | \\\n                                 NETIF_MSG_LINK)\n\n\n \n#define RTL8139_DEBUG 0\n\n \n#undef RTL8139_NDEBUG\n\n\n#ifdef RTL8139_NDEBUG\n#  define assert(expr) do {} while (0)\n#else\n#  define assert(expr) \\\n        if (unlikely(!(expr))) {\t\t\t\t\\\n\t\tpr_err(\"Assertion failed! %s,%s,%s,line=%d\\n\",\t\\\n\t\t       #expr, __FILE__, __func__, __LINE__);\t\\\n        }\n#endif\n\n\n \n \n#define MAX_UNITS 8\nstatic int media[MAX_UNITS] = {-1, -1, -1, -1, -1, -1, -1, -1};\nstatic int full_duplex[MAX_UNITS] = {-1, -1, -1, -1, -1, -1, -1, -1};\n\n \n#ifdef CONFIG_8139TOO_PIO\nstatic bool use_io = true;\n#else\nstatic bool use_io = false;\n#endif\n\n \nstatic int multicast_filter_limit = 32;\n\n \nstatic int debug = -1;\n\n \n#if defined(CONFIG_SH_DREAMCAST)\n#define RX_BUF_IDX 0\t \n#else\n#define RX_BUF_IDX\t2\t \n#endif\n#define RX_BUF_LEN\t(8192 << RX_BUF_IDX)\n#define RX_BUF_PAD\t16\n#define RX_BUF_WRAP_PAD 2048  \n\n#if RX_BUF_LEN == 65536\n#define RX_BUF_TOT_LEN\tRX_BUF_LEN\n#else\n#define RX_BUF_TOT_LEN\t(RX_BUF_LEN + RX_BUF_PAD + RX_BUF_WRAP_PAD)\n#endif\n\n \n#define NUM_TX_DESC\t4\n\n \n#define MAX_ETH_FRAME_SIZE\t1792\n\n \n#define MAX_ETH_DATA_SIZE (MAX_ETH_FRAME_SIZE - VLAN_ETH_HLEN - ETH_FCS_LEN)\n\n \n#define TX_BUF_SIZE\tMAX_ETH_FRAME_SIZE\n#define TX_BUF_TOT_LEN\t(TX_BUF_SIZE * NUM_TX_DESC)\n\n \n#define TX_FIFO_THRESH 256\t \n\n \n#define RX_FIFO_THRESH\t7\t \n#define RX_DMA_BURST\t7\t \n#define TX_DMA_BURST\t6\t \n#define TX_RETRY\t8\t \n\n \n \n#define TX_TIMEOUT  (6*HZ)\n\n\nenum {\n\tHAS_MII_XCVR = 0x010000,\n\tHAS_CHIP_XCVR = 0x020000,\n\tHAS_LNK_CHNG = 0x040000,\n};\n\n#define RTL_NUM_STATS 4\t\t \n#define RTL_REGS_VER 1\t\t \n#define RTL_MIN_IO_SIZE 0x80\n#define RTL8139B_IO_SIZE 256\n\n#define RTL8129_CAPS\tHAS_MII_XCVR\n#define RTL8139_CAPS\t(HAS_CHIP_XCVR|HAS_LNK_CHNG)\n\ntypedef enum {\n\tRTL8139 = 0,\n\tRTL8129,\n} board_t;\n\n\n \nstatic const struct {\n\tconst char *name;\n\tu32 hw_flags;\n} board_info[] = {\n\t{ \"RealTek RTL8139\", RTL8139_CAPS },\n\t{ \"RealTek RTL8129\", RTL8129_CAPS },\n};\n\n\nstatic const struct pci_device_id rtl8139_pci_tbl[] = {\n\t{0x10ec, 0x8139, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x10ec, 0x8138, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x1113, 0x1211, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x1500, 0x1360, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x4033, 0x1360, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x1186, 0x1300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x1186, 0x1340, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x13d1, 0xab06, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x1259, 0xa117, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x1259, 0xa11e, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x14ea, 0xab06, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x14ea, 0xab07, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x11db, 0x1234, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x1432, 0x9130, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x02ac, 0x1012, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x018a, 0x0106, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x126c, 0x1211, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x1743, 0x8139, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x021b, 0x8139, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\t{0x16ec, 0xab06, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n\n#ifdef CONFIG_SH_SECUREEDGE5410\n\t \n\t{0x10ec, 0x8129, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8139 },\n#endif\n#ifdef CONFIG_8139TOO_8129\n\t{0x10ec, 0x8129, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RTL8129 },\n#endif\n\n\t \n\t{PCI_ANY_ID, 0x8139, 0x10ec, 0x8139, 0, 0, RTL8139 },\n\t{PCI_ANY_ID, 0x8139, 0x1186, 0x1300, 0, 0, RTL8139 },\n\t{PCI_ANY_ID, 0x8139, 0x13d1, 0xab06, 0, 0, RTL8139 },\n\n\t{0,}\n};\nMODULE_DEVICE_TABLE (pci, rtl8139_pci_tbl);\n\nstatic struct {\n\tconst char str[ETH_GSTRING_LEN];\n} ethtool_stats_keys[] = {\n\t{ \"early_rx\" },\n\t{ \"tx_buf_mapped\" },\n\t{ \"tx_timeouts\" },\n\t{ \"rx_lost_in_ring\" },\n};\n\n \n\n \nenum RTL8139_registers {\n\tMAC0\t\t= 0,\t  \n\tMAR0\t\t= 8,\t  \n\tTxStatus0\t= 0x10,\t  \n\tTxAddr0\t\t= 0x20,\t  \n\tRxBuf\t\t= 0x30,\n\tChipCmd\t\t= 0x37,\n\tRxBufPtr\t= 0x38,\n\tRxBufAddr\t= 0x3A,\n\tIntrMask\t= 0x3C,\n\tIntrStatus\t= 0x3E,\n\tTxConfig\t= 0x40,\n\tRxConfig\t= 0x44,\n\tTimer\t\t= 0x48,\t  \n\tRxMissed\t= 0x4C,   \n\tCfg9346\t\t= 0x50,\n\tConfig0\t\t= 0x51,\n\tConfig1\t\t= 0x52,\n\tTimerInt\t= 0x54,\n\tMediaStatus\t= 0x58,\n\tConfig3\t\t= 0x59,\n\tConfig4\t\t= 0x5A,\t  \n\tHltClk\t\t= 0x5B,\n\tMultiIntr\t= 0x5C,\n\tTxSummary\t= 0x60,\n\tBasicModeCtrl\t= 0x62,\n\tBasicModeStatus\t= 0x64,\n\tNWayAdvert\t= 0x66,\n\tNWayLPAR\t= 0x68,\n\tNWayExpansion\t= 0x6A,\n\t \n\tFIFOTMS\t\t= 0x70,\t  \n\tCSCR\t\t= 0x74,\t  \n\tPARA78\t\t= 0x78,\n\tFlashReg\t= 0xD4,\t \n\tPARA7c\t\t= 0x7c,\t  \n\tConfig5\t\t= 0xD8,\t  \n};\n\nenum ClearBitMasks {\n\tMultiIntrClear\t= 0xF000,\n\tChipCmdClear\t= 0xE2,\n\tConfig1Clear\t= (1<<7)|(1<<6)|(1<<3)|(1<<2)|(1<<1),\n};\n\nenum ChipCmdBits {\n\tCmdReset\t= 0x10,\n\tCmdRxEnb\t= 0x08,\n\tCmdTxEnb\t= 0x04,\n\tRxBufEmpty\t= 0x01,\n};\n\n \nenum IntrStatusBits {\n\tPCIErr\t\t= 0x8000,\n\tPCSTimeout\t= 0x4000,\n\tRxFIFOOver\t= 0x40,\n\tRxUnderrun\t= 0x20,\n\tRxOverflow\t= 0x10,\n\tTxErr\t\t= 0x08,\n\tTxOK\t\t= 0x04,\n\tRxErr\t\t= 0x02,\n\tRxOK\t\t= 0x01,\n\n\tRxAckBits\t= RxFIFOOver | RxOverflow | RxOK,\n};\n\nenum TxStatusBits {\n\tTxHostOwns\t= 0x2000,\n\tTxUnderrun\t= 0x4000,\n\tTxStatOK\t= 0x8000,\n\tTxOutOfWindow\t= 0x20000000,\n\tTxAborted\t= 0x40000000,\n\tTxCarrierLost\t= 0x80000000,\n};\nenum RxStatusBits {\n\tRxMulticast\t= 0x8000,\n\tRxPhysical\t= 0x4000,\n\tRxBroadcast\t= 0x2000,\n\tRxBadSymbol\t= 0x0020,\n\tRxRunt\t\t= 0x0010,\n\tRxTooLong\t= 0x0008,\n\tRxCRCErr\t= 0x0004,\n\tRxBadAlign\t= 0x0002,\n\tRxStatusOK\t= 0x0001,\n};\n\n \nenum rx_mode_bits {\n\tAcceptErr\t= 0x20,\n\tAcceptRunt\t= 0x10,\n\tAcceptBroadcast\t= 0x08,\n\tAcceptMulticast\t= 0x04,\n\tAcceptMyPhys\t= 0x02,\n\tAcceptAllPhys\t= 0x01,\n};\n\n \nenum tx_config_bits {\n         \n        TxIFGShift\t= 24,\n        TxIFG84\t\t= (0 << TxIFGShift),  \n        TxIFG88\t\t= (1 << TxIFGShift),  \n        TxIFG92\t\t= (2 << TxIFGShift),  \n        TxIFG96\t\t= (3 << TxIFGShift),  \n\n\tTxLoopBack\t= (1 << 18) | (1 << 17),  \n\tTxCRC\t\t= (1 << 16),\t \n\tTxClearAbt\t= (1 << 0),\t \n\tTxDMAShift\t= 8,  \n\tTxRetryShift\t= 4,  \n\n\tTxVersionMask\t= 0x7C800000,  \n};\n\n \nenum Config1Bits {\n\tCfg1_PM_Enable\t= 0x01,\n\tCfg1_VPD_Enable\t= 0x02,\n\tCfg1_PIO\t= 0x04,\n\tCfg1_MMIO\t= 0x08,\n\tLWAKE\t\t= 0x10,\t\t \n\tCfg1_Driver_Load = 0x20,\n\tCfg1_LED0\t= 0x40,\n\tCfg1_LED1\t= 0x80,\n\tSLEEP\t\t= (1 << 1),\t \n\tPWRDN\t\t= (1 << 0),\t \n};\n\n \nenum Config3Bits {\n\tCfg3_FBtBEn   \t= (1 << 0),  \n\tCfg3_FuncRegEn\t= (1 << 1),  \n\tCfg3_CLKRUN_En\t= (1 << 2),  \n\tCfg3_CardB_En \t= (1 << 3),  \n\tCfg3_LinkUp   \t= (1 << 4),  \n\tCfg3_Magic    \t= (1 << 5),  \n\tCfg3_PARM_En  \t= (1 << 6),  \n\tCfg3_GNTSel   \t= (1 << 7),  \n};\n\n \nenum Config4Bits {\n\tLWPTN\t= (1 << 2),\t \n};\n\n \nenum Config5Bits {\n\tCfg5_PME_STS   \t= (1 << 0),  \n\tCfg5_LANWake   \t= (1 << 1),  \n\tCfg5_LDPS      \t= (1 << 2),  \n\tCfg5_FIFOAddrPtr= (1 << 3),  \n\tCfg5_UWF        = (1 << 4),  \n\tCfg5_MWF        = (1 << 5),  \n\tCfg5_BWF        = (1 << 6),  \n};\n\nenum RxConfigBits {\n\t \n\tRxCfgFIFOShift\t= 13,\n\tRxCfgFIFONone\t= (7 << RxCfgFIFOShift),\n\n\t \n\tRxCfgDMAShift\t= 8,\n\tRxCfgDMAUnlimited = (7 << RxCfgDMAShift),\n\n\t \n\tRxCfgRcv8K\t= 0,\n\tRxCfgRcv16K\t= (1 << 11),\n\tRxCfgRcv32K\t= (1 << 12),\n\tRxCfgRcv64K\t= (1 << 11) | (1 << 12),\n\n\t \n\tRxNoWrap\t= (1 << 7),\n};\n\n \nenum CSCRBits {\n\tCSCR_LinkOKBit\t\t= 0x0400,\n\tCSCR_LinkChangeBit\t= 0x0800,\n\tCSCR_LinkStatusBits\t= 0x0f000,\n\tCSCR_LinkDownOffCmd\t= 0x003c0,\n\tCSCR_LinkDownCmd\t= 0x0f3c0,\n};\n\nenum Cfg9346Bits {\n\tCfg9346_Lock\t= 0x00,\n\tCfg9346_Unlock\t= 0xC0,\n};\n\ntypedef enum {\n\tCH_8139\t= 0,\n\tCH_8139_K,\n\tCH_8139A,\n\tCH_8139A_G,\n\tCH_8139B,\n\tCH_8130,\n\tCH_8139C,\n\tCH_8100,\n\tCH_8100B_8139D,\n\tCH_8101,\n} chip_t;\n\nenum chip_flags {\n\tHasHltClk\t= (1 << 0),\n\tHasLWake\t= (1 << 1),\n};\n\n#define HW_REVID(b30, b29, b28, b27, b26, b23, b22) \\\n\t(b30<<30 | b29<<29 | b28<<28 | b27<<27 | b26<<26 | b23<<23 | b22<<22)\n#define HW_REVID_MASK\tHW_REVID(1, 1, 1, 1, 1, 1, 1)\n\n \nstatic const struct {\n\tconst char *name;\n\tu32 version;  \n\tu32 flags;\n} rtl_chip_info[] = {\n\t{ \"RTL-8139\",\n\t  HW_REVID(1, 0, 0, 0, 0, 0, 0),\n\t  HasHltClk,\n\t},\n\n\t{ \"RTL-8139 rev K\",\n\t  HW_REVID(1, 1, 0, 0, 0, 0, 0),\n\t  HasHltClk,\n\t},\n\n\t{ \"RTL-8139A\",\n\t  HW_REVID(1, 1, 1, 0, 0, 0, 0),\n\t  HasHltClk,  \n\t},\n\n\t{ \"RTL-8139A rev G\",\n\t  HW_REVID(1, 1, 1, 0, 0, 1, 0),\n\t  HasHltClk,  \n\t},\n\n\t{ \"RTL-8139B\",\n\t  HW_REVID(1, 1, 1, 1, 0, 0, 0),\n\t  HasLWake,\n\t},\n\n\t{ \"RTL-8130\",\n\t  HW_REVID(1, 1, 1, 1, 1, 0, 0),\n\t  HasLWake,\n\t},\n\n\t{ \"RTL-8139C\",\n\t  HW_REVID(1, 1, 1, 0, 1, 0, 0),\n\t  HasLWake,\n\t},\n\n\t{ \"RTL-8100\",\n\t  HW_REVID(1, 1, 1, 1, 0, 1, 0),\n\t  HasLWake,\n\t},\n\n\t{ \"RTL-8100B/8139D\",\n\t  HW_REVID(1, 1, 1, 0, 1, 0, 1),\n\t  HasHltClk  \n\t| HasLWake,\n\t},\n\n\t{ \"RTL-8101\",\n\t  HW_REVID(1, 1, 1, 0, 1, 1, 1),\n\t  HasLWake,\n\t},\n};\n\nstruct rtl_extra_stats {\n\tunsigned long early_rx;\n\tunsigned long tx_buf_mapped;\n\tunsigned long tx_timeouts;\n\tunsigned long rx_lost_in_ring;\n};\n\nstruct rtl8139_stats {\n\tu64\tpackets;\n\tu64\tbytes;\n\tstruct u64_stats_sync\tsyncp;\n};\n\nstruct rtl8139_private {\n\tvoid __iomem\t\t*mmio_addr;\n\tint\t\t\tdrv_flags;\n\tstruct pci_dev\t\t*pci_dev;\n\tu32\t\t\tmsg_enable;\n\tstruct napi_struct\tnapi;\n\tstruct net_device\t*dev;\n\n\tunsigned char\t\t*rx_ring;\n\tunsigned int\t\tcur_rx;\t \n\tstruct rtl8139_stats\trx_stats;\n\tdma_addr_t\t\trx_ring_dma;\n\n\tunsigned int\t\ttx_flag;\n\tunsigned long\t\tcur_tx;\n\tunsigned long\t\tdirty_tx;\n\tstruct rtl8139_stats\ttx_stats;\n\tunsigned char\t\t*tx_buf[NUM_TX_DESC];\t \n\tunsigned char\t\t*tx_bufs;\t \n\tdma_addr_t\t\ttx_bufs_dma;\n\n\tsigned char\t\tphys[4];\t \n\n\t\t\t\t \n\tchar\t\t\ttwistie, twist_row, twist_col;\n\n\tunsigned int\t\twatchdog_fired : 1;\n\tunsigned int\t\tdefault_port : 4;  \n\tunsigned int\t\thave_thread : 1;\n\n\tspinlock_t\t\tlock;\n\tspinlock_t\t\trx_lock;\n\n\tchip_t\t\t\tchipset;\n\tu32\t\t\trx_config;\n\tstruct rtl_extra_stats\txstats;\n\n\tstruct delayed_work\tthread;\n\n\tstruct mii_if_info\tmii;\n\tunsigned int\t\tregs_len;\n\tunsigned long\t\tfifo_copy_timeout;\n};\n\nMODULE_AUTHOR (\"Jeff Garzik <jgarzik@pobox.com>\");\nMODULE_DESCRIPTION (\"RealTek RTL-8139 Fast Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n\nmodule_param(use_io, bool, 0);\nMODULE_PARM_DESC(use_io, \"Force use of I/O access mode. 0=MMIO 1=PIO\");\nmodule_param(multicast_filter_limit, int, 0);\nmodule_param_array(media, int, NULL, 0);\nmodule_param_array(full_duplex, int, NULL, 0);\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC (debug, \"8139too bitmapped message enable number\");\nMODULE_PARM_DESC (multicast_filter_limit, \"8139too maximum number of filtered multicast addresses\");\nMODULE_PARM_DESC (media, \"8139too: Bits 4+9: force full duplex, bit 5: 100Mbps\");\nMODULE_PARM_DESC (full_duplex, \"8139too: Force full duplex for board(s) (1)\");\n\nstatic int read_eeprom (void __iomem *ioaddr, int location, int addr_len);\nstatic int rtl8139_open (struct net_device *dev);\nstatic int mdio_read (struct net_device *dev, int phy_id, int location);\nstatic void mdio_write (struct net_device *dev, int phy_id, int location,\n\t\t\tint val);\nstatic void rtl8139_start_thread(struct rtl8139_private *tp);\nstatic void rtl8139_tx_timeout (struct net_device *dev, unsigned int txqueue);\nstatic void rtl8139_init_ring (struct net_device *dev);\nstatic netdev_tx_t rtl8139_start_xmit (struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev);\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void rtl8139_poll_controller(struct net_device *dev);\n#endif\nstatic int rtl8139_set_mac_address(struct net_device *dev, void *p);\nstatic int rtl8139_poll(struct napi_struct *napi, int budget);\nstatic irqreturn_t rtl8139_interrupt (int irq, void *dev_instance);\nstatic int rtl8139_close (struct net_device *dev);\nstatic int netdev_ioctl (struct net_device *dev, struct ifreq *rq, int cmd);\nstatic void rtl8139_get_stats64(struct net_device *dev,\n\t\t\t\tstruct rtnl_link_stats64 *stats);\nstatic void rtl8139_set_rx_mode (struct net_device *dev);\nstatic void __set_rx_mode (struct net_device *dev);\nstatic void rtl8139_hw_start (struct net_device *dev);\nstatic void rtl8139_thread (struct work_struct *work);\nstatic void rtl8139_tx_timeout_task(struct work_struct *work);\nstatic const struct ethtool_ops rtl8139_ethtool_ops;\n\n \n \n#define RTL_W8_F(reg, val8)\tdo { iowrite8 ((val8), ioaddr + (reg)); ioread8 (ioaddr + (reg)); } while (0)\n#define RTL_W16_F(reg, val16)\tdo { iowrite16 ((val16), ioaddr + (reg)); ioread16 (ioaddr + (reg)); } while (0)\n#define RTL_W32_F(reg, val32)\tdo { iowrite32 ((val32), ioaddr + (reg)); ioread32 (ioaddr + (reg)); } while (0)\n\n \n#define RTL_W8(reg, val8)\tiowrite8 ((val8), ioaddr + (reg))\n#define RTL_W16(reg, val16)\tiowrite16 ((val16), ioaddr + (reg))\n#define RTL_W32(reg, val32)\tiowrite32 ((val32), ioaddr + (reg))\n\n \n#define RTL_R8(reg)\t\tioread8 (ioaddr + (reg))\n#define RTL_R16(reg)\t\tioread16 (ioaddr + (reg))\n#define RTL_R32(reg)\t\tioread32 (ioaddr + (reg))\n\n\nstatic const u16 rtl8139_intr_mask =\n\tPCIErr | PCSTimeout | RxUnderrun | RxOverflow | RxFIFOOver |\n\tTxErr | TxOK | RxErr | RxOK;\n\nstatic const u16 rtl8139_norx_intr_mask =\n\tPCIErr | PCSTimeout | RxUnderrun |\n\tTxErr | TxOK | RxErr ;\n\n#if RX_BUF_IDX == 0\nstatic const unsigned int rtl8139_rx_config =\n\tRxCfgRcv8K | RxNoWrap |\n\t(RX_FIFO_THRESH << RxCfgFIFOShift) |\n\t(RX_DMA_BURST << RxCfgDMAShift);\n#elif RX_BUF_IDX == 1\nstatic const unsigned int rtl8139_rx_config =\n\tRxCfgRcv16K | RxNoWrap |\n\t(RX_FIFO_THRESH << RxCfgFIFOShift) |\n\t(RX_DMA_BURST << RxCfgDMAShift);\n#elif RX_BUF_IDX == 2\nstatic const unsigned int rtl8139_rx_config =\n\tRxCfgRcv32K | RxNoWrap |\n\t(RX_FIFO_THRESH << RxCfgFIFOShift) |\n\t(RX_DMA_BURST << RxCfgDMAShift);\n#elif RX_BUF_IDX == 3\nstatic const unsigned int rtl8139_rx_config =\n\tRxCfgRcv64K |\n\t(RX_FIFO_THRESH << RxCfgFIFOShift) |\n\t(RX_DMA_BURST << RxCfgDMAShift);\n#else\n#error \"Invalid configuration for 8139_RXBUF_IDX\"\n#endif\n\nstatic const unsigned int rtl8139_tx_config =\n\tTxIFG96 | (TX_DMA_BURST << TxDMAShift) | (TX_RETRY << TxRetryShift);\n\nstatic void __rtl8139_cleanup_dev (struct net_device *dev)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tstruct pci_dev *pdev;\n\n\tassert (dev != NULL);\n\tassert (tp->pci_dev != NULL);\n\tpdev = tp->pci_dev;\n\n\tif (tp->mmio_addr)\n\t\tpci_iounmap (pdev, tp->mmio_addr);\n\n\t \n\tpci_release_regions (pdev);\n\n\tfree_netdev(dev);\n}\n\n\nstatic void rtl8139_chip_reset (void __iomem *ioaddr)\n{\n\tint i;\n\n\t \n\tRTL_W8 (ChipCmd, CmdReset);\n\n\t \n\tfor (i = 1000; i > 0; i--) {\n\t\tbarrier();\n\t\tif ((RTL_R8 (ChipCmd) & CmdReset) == 0)\n\t\t\tbreak;\n\t\tudelay (10);\n\t}\n}\n\n\nstatic struct net_device *rtl8139_init_board(struct pci_dev *pdev)\n{\n\tstruct device *d = &pdev->dev;\n\tvoid __iomem *ioaddr;\n\tstruct net_device *dev;\n\tstruct rtl8139_private *tp;\n\tu8 tmp8;\n\tint rc, disable_dev_on_err = 0;\n\tunsigned int i, bar;\n\tunsigned long io_len;\n\tu32 version;\n\tstatic const struct {\n\t\tunsigned long mask;\n\t\tchar *type;\n\t} res[] = {\n\t\t{ IORESOURCE_IO,  \"PIO\" },\n\t\t{ IORESOURCE_MEM, \"MMIO\" }\n\t};\n\n\tassert (pdev != NULL);\n\n\t \n\tdev = alloc_etherdev (sizeof (*tp));\n\tif (dev == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\ttp = netdev_priv(dev);\n\ttp->pci_dev = pdev;\n\n\t \n\trc = pci_enable_device (pdev);\n\tif (rc)\n\t\tgoto err_out;\n\n\tdisable_dev_on_err = 1;\n\trc = pci_request_regions (pdev, DRV_NAME);\n\tif (rc)\n\t\tgoto err_out;\n\n\tpci_set_master (pdev);\n\n\tu64_stats_init(&tp->rx_stats.syncp);\n\tu64_stats_init(&tp->tx_stats.syncp);\n\nretry:\n\t \n\tbar = !use_io;\n\n\tio_len = pci_resource_len(pdev, bar);\n\n\tdev_dbg(d, \"%s region size = 0x%02lX\\n\", res[bar].type, io_len);\n\n\tif (!(pci_resource_flags(pdev, bar) & res[bar].mask)) {\n\t\tdev_err(d, \"region #%d not a %s resource, aborting\\n\", bar,\n\t\t\tres[bar].type);\n\t\trc = -ENODEV;\n\t\tgoto err_out;\n\t}\n\tif (io_len < RTL_MIN_IO_SIZE) {\n\t\tdev_err(d, \"Invalid PCI %s region size(s), aborting\\n\",\n\t\t\tres[bar].type);\n\t\trc = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\tioaddr = pci_iomap(pdev, bar, 0);\n\tif (!ioaddr) {\n\t\tdev_err(d, \"cannot map %s\\n\", res[bar].type);\n\t\tif (!use_io) {\n\t\t\tuse_io = true;\n\t\t\tgoto retry;\n\t\t}\n\t\trc = -ENODEV;\n\t\tgoto err_out;\n\t}\n\ttp->regs_len = io_len;\n\ttp->mmio_addr = ioaddr;\n\n\t \n\tRTL_W8 (HltClk, 'R');\n\n\t \n\tif (RTL_R32 (TxConfig) == 0xFFFFFFFF) {\n\t\tdev_err(&pdev->dev, \"Chip not responding, ignoring board\\n\");\n\t\trc = -EIO;\n\t\tgoto err_out;\n\t}\n\n\t \n\tversion = RTL_R32 (TxConfig) & HW_REVID_MASK;\n\tfor (i = 0; i < ARRAY_SIZE (rtl_chip_info); i++)\n\t\tif (version == rtl_chip_info[i].version) {\n\t\t\ttp->chipset = i;\n\t\t\tgoto match;\n\t\t}\n\n\t \n\ti = 0;\n\tdev_dbg(&pdev->dev, \"unknown chip version, assuming RTL-8139\\n\");\n\tdev_dbg(&pdev->dev, \"TxConfig = 0x%x\\n\", RTL_R32 (TxConfig));\n\ttp->chipset = 0;\n\nmatch:\n\tpr_debug(\"chipset id (%d) == index %d, '%s'\\n\",\n\t\t version, i, rtl_chip_info[i].name);\n\n\tif (tp->chipset >= CH_8139B) {\n\t\tu8 new_tmp8 = tmp8 = RTL_R8 (Config1);\n\t\tpr_debug(\"PCI PM wakeup\\n\");\n\t\tif ((rtl_chip_info[tp->chipset].flags & HasLWake) &&\n\t\t    (tmp8 & LWAKE))\n\t\t\tnew_tmp8 &= ~LWAKE;\n\t\tnew_tmp8 |= Cfg1_PM_Enable;\n\t\tif (new_tmp8 != tmp8) {\n\t\t\tRTL_W8 (Cfg9346, Cfg9346_Unlock);\n\t\t\tRTL_W8 (Config1, tmp8);\n\t\t\tRTL_W8 (Cfg9346, Cfg9346_Lock);\n\t\t}\n\t\tif (rtl_chip_info[tp->chipset].flags & HasLWake) {\n\t\t\ttmp8 = RTL_R8 (Config4);\n\t\t\tif (tmp8 & LWPTN) {\n\t\t\t\tRTL_W8 (Cfg9346, Cfg9346_Unlock);\n\t\t\t\tRTL_W8 (Config4, tmp8 & ~LWPTN);\n\t\t\t\tRTL_W8 (Cfg9346, Cfg9346_Lock);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpr_debug(\"Old chip wakeup\\n\");\n\t\ttmp8 = RTL_R8 (Config1);\n\t\ttmp8 &= ~(SLEEP | PWRDN);\n\t\tRTL_W8 (Config1, tmp8);\n\t}\n\n\trtl8139_chip_reset (ioaddr);\n\n\treturn dev;\n\nerr_out:\n\t__rtl8139_cleanup_dev (dev);\n\tif (disable_dev_on_err)\n\t\tpci_disable_device (pdev);\n\treturn ERR_PTR(rc);\n}\n\nstatic int rtl8139_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tunsigned long flags;\n\tnetdev_features_t changed = features ^ dev->features;\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\n\tif (!(changed & (NETIF_F_RXALL)))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&tp->lock, flags);\n\n\tif (changed & NETIF_F_RXALL) {\n\t\tint rx_mode = tp->rx_config;\n\t\tif (features & NETIF_F_RXALL)\n\t\t\trx_mode |= (AcceptErr | AcceptRunt);\n\t\telse\n\t\t\trx_mode &= ~(AcceptErr | AcceptRunt);\n\t\ttp->rx_config = rtl8139_rx_config | rx_mode;\n\t\tRTL_W32_F(RxConfig, tp->rx_config);\n\t}\n\n\tspin_unlock_irqrestore(&tp->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops rtl8139_netdev_ops = {\n\t.ndo_open\t\t= rtl8139_open,\n\t.ndo_stop\t\t= rtl8139_close,\n\t.ndo_get_stats64\t= rtl8139_get_stats64,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address \t= rtl8139_set_mac_address,\n\t.ndo_start_xmit\t\t= rtl8139_start_xmit,\n\t.ndo_set_rx_mode\t= rtl8139_set_rx_mode,\n\t.ndo_eth_ioctl\t\t= netdev_ioctl,\n\t.ndo_tx_timeout\t\t= rtl8139_tx_timeout,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= rtl8139_poll_controller,\n#endif\n\t.ndo_set_features\t= rtl8139_set_features,\n};\n\nstatic int rtl8139_init_one(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct net_device *dev = NULL;\n\tstruct rtl8139_private *tp;\n\t__le16 addr[ETH_ALEN / 2];\n\tint i, addr_len, option;\n\tvoid __iomem *ioaddr;\n\tstatic int board_idx = -1;\n\n\tassert (pdev != NULL);\n\tassert (ent != NULL);\n\n\tboard_idx++;\n\n\t \n#ifndef MODULE\n\t{\n\t\tstatic int printed_version;\n\t\tif (!printed_version++)\n\t\t\tpr_info(RTL8139_DRIVER_NAME \"\\n\");\n\t}\n#endif\n\n\tif (pdev->vendor == PCI_VENDOR_ID_REALTEK &&\n\t    pdev->device == PCI_DEVICE_ID_REALTEK_8139 && pdev->revision >= 0x20) {\n\t\tdev_info(&pdev->dev,\n\t\t\t   \"This (id %04x:%04x rev %02x) is an enhanced 8139C+ chip, use 8139cp\\n\",\n\t\t       \t   pdev->vendor, pdev->device, pdev->revision);\n\t\treturn -ENODEV;\n\t}\n\n\tif (pdev->vendor == PCI_VENDOR_ID_REALTEK &&\n\t    pdev->device == PCI_DEVICE_ID_REALTEK_8139 &&\n\t    pdev->subsystem_vendor == PCI_VENDOR_ID_ATHEROS &&\n\t    pdev->subsystem_device == PCI_DEVICE_ID_REALTEK_8139) {\n\t\tpr_info(\"OQO Model 2 detected. Forcing PIO\\n\");\n\t\tuse_io = true;\n\t}\n\n\tdev = rtl8139_init_board (pdev);\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\n\tassert (dev != NULL);\n\ttp = netdev_priv(dev);\n\ttp->dev = dev;\n\n\tioaddr = tp->mmio_addr;\n\tassert (ioaddr != NULL);\n\n\taddr_len = read_eeprom (ioaddr, 0, 8) == 0x8129 ? 8 : 6;\n\tfor (i = 0; i < 3; i++)\n\t\taddr[i] = cpu_to_le16(read_eeprom (ioaddr, i + 7, addr_len));\n\teth_hw_addr_set(dev, (u8 *)addr);\n\n\t \n\tdev->netdev_ops = &rtl8139_netdev_ops;\n\tdev->ethtool_ops = &rtl8139_ethtool_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tnetif_napi_add(dev, &tp->napi, rtl8139_poll);\n\n\t \n\tdev->features |= NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_HIGHDMA;\n\tdev->vlan_features = dev->features;\n\n\tdev->hw_features |= NETIF_F_RXALL;\n\tdev->hw_features |= NETIF_F_RXFCS;\n\n\t \n\tdev->min_mtu = ETH_MIN_MTU;\n\tdev->max_mtu = MAX_ETH_DATA_SIZE;\n\n\t \n\ttp = netdev_priv(dev);\n\n\t \n\ttp->drv_flags = board_info[ent->driver_data].hw_flags;\n\ttp->mmio_addr = ioaddr;\n\ttp->msg_enable =\n\t\t(debug < 0 ? RTL8139_DEF_MSG_ENABLE : ((1 << debug) - 1));\n\tspin_lock_init (&tp->lock);\n\tspin_lock_init (&tp->rx_lock);\n\tINIT_DELAYED_WORK(&tp->thread, rtl8139_thread);\n\ttp->mii.dev = dev;\n\ttp->mii.mdio_read = mdio_read;\n\ttp->mii.mdio_write = mdio_write;\n\ttp->mii.phy_id_mask = 0x3f;\n\ttp->mii.reg_num_mask = 0x1f;\n\n\t \n\tpr_debug(\"about to register device named %s (%p)...\\n\",\n\t\t dev->name, dev);\n\ti = register_netdev (dev);\n\tif (i) goto err_out;\n\n\tpci_set_drvdata (pdev, dev);\n\n\tnetdev_info(dev, \"%s at 0x%p, %pM, IRQ %d\\n\",\n\t\t    board_info[ent->driver_data].name,\n\t\t    ioaddr, dev->dev_addr, pdev->irq);\n\n\tnetdev_dbg(dev, \"Identified 8139 chip type '%s'\\n\",\n\t\t   rtl_chip_info[tp->chipset].name);\n\n\t \n#ifdef CONFIG_8139TOO_8129\n\tif (tp->drv_flags & HAS_MII_XCVR) {\n\t\tint phy, phy_idx = 0;\n\t\tfor (phy = 0; phy < 32 && phy_idx < sizeof(tp->phys); phy++) {\n\t\t\tint mii_status = mdio_read(dev, phy, 1);\n\t\t\tif (mii_status != 0xffff  &&  mii_status != 0x0000) {\n\t\t\t\tu16 advertising = mdio_read(dev, phy, 4);\n\t\t\t\ttp->phys[phy_idx++] = phy;\n\t\t\t\tnetdev_info(dev, \"MII transceiver %d status 0x%04x advertising %04x\\n\",\n\t\t\t\t\t    phy, mii_status, advertising);\n\t\t\t}\n\t\t}\n\t\tif (phy_idx == 0) {\n\t\t\tnetdev_info(dev, \"No MII transceivers found! Assuming SYM transceiver\\n\");\n\t\t\ttp->phys[0] = 32;\n\t\t}\n\t} else\n#endif\n\t\ttp->phys[0] = 32;\n\ttp->mii.phy_id = tp->phys[0];\n\n\t \n\toption = (board_idx >= MAX_UNITS) ? 0 : media[board_idx];\n\tif (option > 0) {\n\t\ttp->mii.full_duplex = (option & 0x210) ? 1 : 0;\n\t\ttp->default_port = option & 0xFF;\n\t\tif (tp->default_port)\n\t\t\ttp->mii.force_media = 1;\n\t}\n\tif (board_idx < MAX_UNITS  &&  full_duplex[board_idx] > 0)\n\t\ttp->mii.full_duplex = full_duplex[board_idx];\n\tif (tp->mii.full_duplex) {\n\t\tnetdev_info(dev, \"Media type forced to Full Duplex\\n\");\n\t\t \n\t\ttp->mii.force_media = 1;\n\t}\n\tif (tp->default_port) {\n\t\tnetdev_info(dev, \"  Forcing %dMbps %s-duplex operation\\n\",\n\t\t\t    (option & 0x20 ? 100 : 10),\n\t\t\t    (option & 0x10 ? \"full\" : \"half\"));\n\t\tmdio_write(dev, tp->phys[0], 0,\n\t\t\t\t   ((option & 0x20) ? 0x2000 : 0) | \t \n\t\t\t\t   ((option & 0x10) ? 0x0100 : 0));  \n\t}\n\n\t \n\tif (rtl_chip_info[tp->chipset].flags & HasHltClk)\n\t\tRTL_W8 (HltClk, 'H');\t \n\n\treturn 0;\n\nerr_out:\n\t__rtl8139_cleanup_dev (dev);\n\tpci_disable_device (pdev);\n\treturn i;\n}\n\n\nstatic void rtl8139_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata (pdev);\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\n\tassert (dev != NULL);\n\n\tcancel_delayed_work_sync(&tp->thread);\n\n\tunregister_netdev (dev);\n\n\t__rtl8139_cleanup_dev (dev);\n\tpci_disable_device (pdev);\n}\n\n\n \n\n \n#define EE_SHIFT_CLK\t0x04\t \n#define EE_CS\t\t\t0x08\t \n#define EE_DATA_WRITE\t0x02\t \n#define EE_WRITE_0\t\t0x00\n#define EE_WRITE_1\t\t0x02\n#define EE_DATA_READ\t0x01\t \n#define EE_ENB\t\t\t(0x80 | EE_CS)\n\n \n\n#define eeprom_delay()\t(void)RTL_R8(Cfg9346)\n\n \n#define EE_WRITE_CMD\t(5)\n#define EE_READ_CMD\t\t(6)\n#define EE_ERASE_CMD\t(7)\n\nstatic int read_eeprom(void __iomem *ioaddr, int location, int addr_len)\n{\n\tint i;\n\tunsigned retval = 0;\n\tint read_cmd = location | (EE_READ_CMD << addr_len);\n\n\tRTL_W8 (Cfg9346, EE_ENB & ~EE_CS);\n\tRTL_W8 (Cfg9346, EE_ENB);\n\teeprom_delay ();\n\n\t \n\tfor (i = 4 + addr_len; i >= 0; i--) {\n\t\tint dataval = (read_cmd & (1 << i)) ? EE_DATA_WRITE : 0;\n\t\tRTL_W8 (Cfg9346, EE_ENB | dataval);\n\t\teeprom_delay ();\n\t\tRTL_W8 (Cfg9346, EE_ENB | dataval | EE_SHIFT_CLK);\n\t\teeprom_delay ();\n\t}\n\tRTL_W8 (Cfg9346, EE_ENB);\n\teeprom_delay ();\n\n\tfor (i = 16; i > 0; i--) {\n\t\tRTL_W8 (Cfg9346, EE_ENB | EE_SHIFT_CLK);\n\t\teeprom_delay ();\n\t\tretval =\n\t\t    (retval << 1) | ((RTL_R8 (Cfg9346) & EE_DATA_READ) ? 1 :\n\t\t\t\t     0);\n\t\tRTL_W8 (Cfg9346, EE_ENB);\n\t\teeprom_delay ();\n\t}\n\n\t \n\tRTL_W8(Cfg9346, 0);\n\teeprom_delay ();\n\n\treturn retval;\n}\n\n \n \n#define MDIO_DIR\t\t0x80\n#define MDIO_DATA_OUT\t0x04\n#define MDIO_DATA_IN\t0x02\n#define MDIO_CLK\t\t0x01\n#define MDIO_WRITE0 (MDIO_DIR)\n#define MDIO_WRITE1 (MDIO_DIR | MDIO_DATA_OUT)\n\n#define mdio_delay()\tRTL_R8(Config4)\n\n\nstatic const char mii_2_8139_map[8] = {\n\tBasicModeCtrl,\n\tBasicModeStatus,\n\t0,\n\t0,\n\tNWayAdvert,\n\tNWayLPAR,\n\tNWayExpansion,\n\t0\n};\n\n\n#ifdef CONFIG_8139TOO_8129\n \nstatic void mdio_sync (void __iomem *ioaddr)\n{\n\tint i;\n\n\tfor (i = 32; i >= 0; i--) {\n\t\tRTL_W8 (Config4, MDIO_WRITE1);\n\t\tmdio_delay ();\n\t\tRTL_W8 (Config4, MDIO_WRITE1 | MDIO_CLK);\n\t\tmdio_delay ();\n\t}\n}\n#endif\n\nstatic int mdio_read (struct net_device *dev, int phy_id, int location)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tint retval = 0;\n#ifdef CONFIG_8139TOO_8129\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tint mii_cmd = (0xf6 << 10) | (phy_id << 5) | location;\n\tint i;\n#endif\n\n\tif (phy_id > 31) {\t \n\t\tvoid __iomem *ioaddr = tp->mmio_addr;\n\t\treturn location < 8 && mii_2_8139_map[location] ?\n\t\t    RTL_R16 (mii_2_8139_map[location]) : 0;\n\t}\n\n#ifdef CONFIG_8139TOO_8129\n\tmdio_sync (ioaddr);\n\t \n\tfor (i = 15; i >= 0; i--) {\n\t\tint dataval = (mii_cmd & (1 << i)) ? MDIO_DATA_OUT : 0;\n\n\t\tRTL_W8 (Config4, MDIO_DIR | dataval);\n\t\tmdio_delay ();\n\t\tRTL_W8 (Config4, MDIO_DIR | dataval | MDIO_CLK);\n\t\tmdio_delay ();\n\t}\n\n\t \n\tfor (i = 19; i > 0; i--) {\n\t\tRTL_W8 (Config4, 0);\n\t\tmdio_delay ();\n\t\tretval = (retval << 1) | ((RTL_R8 (Config4) & MDIO_DATA_IN) ? 1 : 0);\n\t\tRTL_W8 (Config4, MDIO_CLK);\n\t\tmdio_delay ();\n\t}\n#endif\n\n\treturn (retval >> 1) & 0xffff;\n}\n\n\nstatic void mdio_write (struct net_device *dev, int phy_id, int location,\n\t\t\tint value)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n#ifdef CONFIG_8139TOO_8129\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tint mii_cmd = (0x5002 << 16) | (phy_id << 23) | (location << 18) | value;\n\tint i;\n#endif\n\n\tif (phy_id > 31) {\t \n\t\tvoid __iomem *ioaddr = tp->mmio_addr;\n\t\tif (location == 0) {\n\t\t\tRTL_W8 (Cfg9346, Cfg9346_Unlock);\n\t\t\tRTL_W16 (BasicModeCtrl, value);\n\t\t\tRTL_W8 (Cfg9346, Cfg9346_Lock);\n\t\t} else if (location < 8 && mii_2_8139_map[location])\n\t\t\tRTL_W16 (mii_2_8139_map[location], value);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_8139TOO_8129\n\tmdio_sync (ioaddr);\n\n\t \n\tfor (i = 31; i >= 0; i--) {\n\t\tint dataval =\n\t\t    (mii_cmd & (1 << i)) ? MDIO_WRITE1 : MDIO_WRITE0;\n\t\tRTL_W8 (Config4, dataval);\n\t\tmdio_delay ();\n\t\tRTL_W8 (Config4, dataval | MDIO_CLK);\n\t\tmdio_delay ();\n\t}\n\t \n\tfor (i = 2; i > 0; i--) {\n\t\tRTL_W8 (Config4, 0);\n\t\tmdio_delay ();\n\t\tRTL_W8 (Config4, MDIO_CLK);\n\t\tmdio_delay ();\n\t}\n#endif\n}\n\n\nstatic int rtl8139_open (struct net_device *dev)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tconst int irq = tp->pci_dev->irq;\n\tint retval;\n\n\tretval = request_irq(irq, rtl8139_interrupt, IRQF_SHARED, dev->name, dev);\n\tif (retval)\n\t\treturn retval;\n\n\ttp->tx_bufs = dma_alloc_coherent(&tp->pci_dev->dev, TX_BUF_TOT_LEN,\n\t\t\t\t\t   &tp->tx_bufs_dma, GFP_KERNEL);\n\ttp->rx_ring = dma_alloc_coherent(&tp->pci_dev->dev, RX_BUF_TOT_LEN,\n\t\t\t\t\t   &tp->rx_ring_dma, GFP_KERNEL);\n\tif (tp->tx_bufs == NULL || tp->rx_ring == NULL) {\n\t\tfree_irq(irq, dev);\n\n\t\tif (tp->tx_bufs)\n\t\t\tdma_free_coherent(&tp->pci_dev->dev, TX_BUF_TOT_LEN,\n\t\t\t\t\t    tp->tx_bufs, tp->tx_bufs_dma);\n\t\tif (tp->rx_ring)\n\t\t\tdma_free_coherent(&tp->pci_dev->dev, RX_BUF_TOT_LEN,\n\t\t\t\t\t    tp->rx_ring, tp->rx_ring_dma);\n\n\t\treturn -ENOMEM;\n\n\t}\n\n\tnapi_enable(&tp->napi);\n\n\ttp->mii.full_duplex = tp->mii.force_media;\n\ttp->tx_flag = (TX_FIFO_THRESH << 11) & 0x003f0000;\n\n\trtl8139_init_ring (dev);\n\trtl8139_hw_start (dev);\n\tnetif_start_queue (dev);\n\n\tnetif_dbg(tp, ifup, dev,\n\t\t  \"%s() ioaddr %#llx IRQ %d GP Pins %02x %s-duplex\\n\",\n\t\t  __func__,\n\t\t  (unsigned long long)pci_resource_start (tp->pci_dev, 1),\n\t\t  irq, RTL_R8 (MediaStatus),\n\t\t  tp->mii.full_duplex ? \"full\" : \"half\");\n\n\trtl8139_start_thread(tp);\n\n\treturn 0;\n}\n\n\nstatic void rtl_check_media (struct net_device *dev, unsigned int init_media)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\n\tif (tp->phys[0] >= 0) {\n\t\tmii_check_media(&tp->mii, netif_msg_link(tp), init_media);\n\t}\n}\n\n \nstatic void rtl8139_hw_start (struct net_device *dev)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tu32 i;\n\tu8 tmp;\n\n\t \n\tif (rtl_chip_info[tp->chipset].flags & HasHltClk)\n\t\tRTL_W8 (HltClk, 'R');\n\n\trtl8139_chip_reset (ioaddr);\n\n\t \n\tRTL_W8_F (Cfg9346, Cfg9346_Unlock);\n\t \n\tRTL_W32_F (MAC0 + 0, le32_to_cpu (*(__le32 *) (dev->dev_addr + 0)));\n\tRTL_W32_F (MAC0 + 4, le16_to_cpu (*(__le16 *) (dev->dev_addr + 4)));\n\n\ttp->cur_rx = 0;\n\n\t \n\tRTL_W32_F (RxBuf, tp->rx_ring_dma);\n\n\t \n\tRTL_W8 (ChipCmd, CmdRxEnb | CmdTxEnb);\n\n\ttp->rx_config = rtl8139_rx_config | AcceptBroadcast | AcceptMyPhys;\n\tRTL_W32 (RxConfig, tp->rx_config);\n\tRTL_W32 (TxConfig, rtl8139_tx_config);\n\n\trtl_check_media (dev, 1);\n\n\tif (tp->chipset >= CH_8139B) {\n\t\t \n\t\tRTL_W8 (Config3, RTL_R8 (Config3) & ~Cfg3_Magic);\n\t}\n\n\tnetdev_dbg(dev, \"init buffer addresses\\n\");\n\n\t \n\tRTL_W8 (Cfg9346, Cfg9346_Lock);\n\n\t \n\tfor (i = 0; i < NUM_TX_DESC; i++)\n\t\tRTL_W32_F (TxAddr0 + (i * 4), tp->tx_bufs_dma + (tp->tx_buf[i] - tp->tx_bufs));\n\n\tRTL_W32 (RxMissed, 0);\n\n\trtl8139_set_rx_mode (dev);\n\n\t \n\tRTL_W16 (MultiIntr, RTL_R16 (MultiIntr) & MultiIntrClear);\n\n\t \n\ttmp = RTL_R8 (ChipCmd);\n\tif ((!(tmp & CmdRxEnb)) || (!(tmp & CmdTxEnb)))\n\t\tRTL_W8 (ChipCmd, CmdRxEnb | CmdTxEnb);\n\n\t \n\tRTL_W16 (IntrMask, rtl8139_intr_mask);\n}\n\n\n \nstatic void rtl8139_init_ring (struct net_device *dev)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tint i;\n\n\ttp->cur_rx = 0;\n\ttp->cur_tx = 0;\n\ttp->dirty_tx = 0;\n\n\tfor (i = 0; i < NUM_TX_DESC; i++)\n\t\ttp->tx_buf[i] = &tp->tx_bufs[i * TX_BUF_SIZE];\n}\n\n\n \nstatic int next_tick = 3 * HZ;\n\n#ifndef CONFIG_8139TOO_TUNE_TWISTER\nstatic inline void rtl8139_tune_twister (struct net_device *dev,\n\t\t\t\t  struct rtl8139_private *tp) {}\n#else\nenum TwisterParamVals {\n\tPARA78_default\t= 0x78fa8388,\n\tPARA7c_default\t= 0xcb38de43,\t \n\tPARA7c_xxx\t= 0xcb38de43,\n};\n\nstatic const unsigned long param[4][4] = {\n\t{0xcb39de43, 0xcb39ce43, 0xfb38de03, 0xcb38de43},\n\t{0xcb39de43, 0xcb39ce43, 0xcb39ce83, 0xcb39ce83},\n\t{0xcb39de43, 0xcb39ce43, 0xcb39ce83, 0xcb39ce83},\n\t{0xbb39de43, 0xbb39ce43, 0xbb39ce83, 0xbb39ce83}\n};\n\nstatic void rtl8139_tune_twister (struct net_device *dev,\n\t\t\t\t  struct rtl8139_private *tp)\n{\n\tint linkcase;\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\n\t \n\tswitch (tp->twistie) {\n\tcase 1:\n\t\tif (RTL_R16 (CSCR) & CSCR_LinkOKBit) {\n\t\t\t \n\t\t\tRTL_W16 (CSCR, CSCR_LinkDownOffCmd);\n\t\t\ttp->twistie = 2;\t \n\t\t\tnext_tick = HZ / 10;\n\t\t} else {\n\t\t\t \n\t\t\tRTL_W16 (CSCR, CSCR_LinkDownCmd);\n\t\t\tRTL_W32 (FIFOTMS, 0x20);\t \n\t\t\tRTL_W32 (PARA78, PARA78_default);\n\t\t\tRTL_W32 (PARA7c, PARA7c_default);\n\t\t\ttp->twistie = 0;\t \n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tlinkcase = RTL_R16 (CSCR) & CSCR_LinkStatusBits;\n\t\tif (linkcase == 0x7000)\n\t\t\ttp->twist_row = 3;\n\t\telse if (linkcase == 0x3000)\n\t\t\ttp->twist_row = 2;\n\t\telse if (linkcase == 0x1000)\n\t\t\ttp->twist_row = 1;\n\t\telse\n\t\t\ttp->twist_row = 0;\n\t\ttp->twist_col = 0;\n\t\ttp->twistie = 3;\t \n\t\tnext_tick = HZ / 10;\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tif (tp->twist_col == 0)\n\t\t\tRTL_W16 (FIFOTMS, 0);\n\t\tRTL_W32 (PARA7c, param[(int) tp->twist_row]\n\t\t\t [(int) tp->twist_col]);\n\t\tnext_tick = HZ / 10;\n\t\tif (++tp->twist_col >= 4) {\n\t\t\t \n\t\t\ttp->twistie =\n\t\t\t    (tp->twist_row == 3) ? 4 : 0;\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\t \n\t\tif ((RTL_R16 (CSCR) &\n\t\t     CSCR_LinkStatusBits) == 0x7000) {\n\t\t\ttp->twistie = 0;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tRTL_W32 (PARA7c, 0xfb38de03);\n\t\t\ttp->twistie = 5;\n\t\t\tnext_tick = HZ / 10;\n\t\t}\n\t\tbreak;\n\tcase 5:\n\t\t \n\t\tRTL_W32 (FIFOTMS, 0x20);\n\t\tRTL_W32 (PARA78, PARA78_default);\n\t\tRTL_W32 (PARA7c, PARA7c_default);\n\t\tRTL_W32 (FIFOTMS, 0x00);\n\t\ttp->twist_row = 2;\n\t\ttp->twist_col = 0;\n\t\ttp->twistie = 3;\n\t\tnext_tick = HZ / 10;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n#endif  \n\nstatic inline void rtl8139_thread_iter (struct net_device *dev,\n\t\t\t\t struct rtl8139_private *tp,\n\t\t\t\t void __iomem *ioaddr)\n{\n\tint mii_lpa;\n\n\tmii_lpa = mdio_read (dev, tp->phys[0], MII_LPA);\n\n\tif (!tp->mii.force_media && mii_lpa != 0xffff) {\n\t\tint duplex = ((mii_lpa & LPA_100FULL) ||\n\t\t\t      (mii_lpa & 0x01C0) == 0x0040);\n\t\tif (tp->mii.full_duplex != duplex) {\n\t\t\ttp->mii.full_duplex = duplex;\n\n\t\t\tif (mii_lpa) {\n\t\t\t\tnetdev_info(dev, \"Setting %s-duplex based on MII #%d link partner ability of %04x\\n\",\n\t\t\t\t\t    tp->mii.full_duplex ? \"full\" : \"half\",\n\t\t\t\t\t    tp->phys[0], mii_lpa);\n\t\t\t} else {\n\t\t\t\tnetdev_info(dev, \"media is unconnected, link down, or incompatible connection\\n\");\n\t\t\t}\n#if 0\n\t\t\tRTL_W8 (Cfg9346, Cfg9346_Unlock);\n\t\t\tRTL_W8 (Config1, tp->mii.full_duplex ? 0x60 : 0x20);\n\t\t\tRTL_W8 (Cfg9346, Cfg9346_Lock);\n#endif\n\t\t}\n\t}\n\n\tnext_tick = HZ * 60;\n\n\trtl8139_tune_twister (dev, tp);\n\n\tnetdev_dbg(dev, \"Media selection tick, Link partner %04x\\n\",\n\t\t   RTL_R16(NWayLPAR));\n\tnetdev_dbg(dev, \"Other registers are IntMask %04x IntStatus %04x\\n\",\n\t\t   RTL_R16(IntrMask), RTL_R16(IntrStatus));\n\tnetdev_dbg(dev, \"Chip config %02x %02x\\n\",\n\t\t   RTL_R8(Config0), RTL_R8(Config1));\n}\n\nstatic void rtl8139_thread (struct work_struct *work)\n{\n\tstruct rtl8139_private *tp =\n\t\tcontainer_of(work, struct rtl8139_private, thread.work);\n\tstruct net_device *dev = tp->mii.dev;\n\tunsigned long thr_delay = next_tick;\n\n\trtnl_lock();\n\n\tif (!netif_running(dev))\n\t\tgoto out_unlock;\n\n\tif (tp->watchdog_fired) {\n\t\ttp->watchdog_fired = 0;\n\t\trtl8139_tx_timeout_task(work);\n\t} else\n\t\trtl8139_thread_iter(dev, tp, tp->mmio_addr);\n\n\tif (tp->have_thread)\n\t\tschedule_delayed_work(&tp->thread, thr_delay);\nout_unlock:\n\trtnl_unlock ();\n}\n\nstatic void rtl8139_start_thread(struct rtl8139_private *tp)\n{\n\ttp->twistie = 0;\n\tif (tp->chipset == CH_8139_K)\n\t\ttp->twistie = 1;\n\telse if (tp->drv_flags & HAS_LNK_CHNG)\n\t\treturn;\n\n\ttp->have_thread = 1;\n\ttp->watchdog_fired = 0;\n\n\tschedule_delayed_work(&tp->thread, next_tick);\n}\n\nstatic inline void rtl8139_tx_clear (struct rtl8139_private *tp)\n{\n\ttp->cur_tx = 0;\n\ttp->dirty_tx = 0;\n\n\t \n}\n\nstatic void rtl8139_tx_timeout_task (struct work_struct *work)\n{\n\tstruct rtl8139_private *tp =\n\t\tcontainer_of(work, struct rtl8139_private, thread.work);\n\tstruct net_device *dev = tp->mii.dev;\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tint i;\n\tu8 tmp8;\n\n\tnapi_disable(&tp->napi);\n\tnetif_stop_queue(dev);\n\tsynchronize_rcu();\n\n\tnetdev_dbg(dev, \"Transmit timeout, status %02x %04x %04x media %02x\\n\",\n\t\t   RTL_R8(ChipCmd), RTL_R16(IntrStatus),\n\t\t   RTL_R16(IntrMask), RTL_R8(MediaStatus));\n\t \n\tnetdev_dbg(dev, \"Tx queue start entry %ld  dirty entry %ld\\n\",\n\t\t   tp->cur_tx, tp->dirty_tx);\n\tfor (i = 0; i < NUM_TX_DESC; i++)\n\t\tnetdev_dbg(dev, \"Tx descriptor %d is %08x%s\\n\",\n\t\t\t   i, RTL_R32(TxStatus0 + (i * 4)),\n\t\t\t   i == tp->dirty_tx % NUM_TX_DESC ?\n\t\t\t   \" (queue head)\" : \"\");\n\n\ttp->xstats.tx_timeouts++;\n\n\t \n\ttmp8 = RTL_R8 (ChipCmd);\n\tif (tmp8 & CmdTxEnb)\n\t\tRTL_W8 (ChipCmd, CmdRxEnb);\n\n\tspin_lock_bh(&tp->rx_lock);\n\t \n\tRTL_W16 (IntrMask, 0x0000);\n\n\t \n\tspin_lock_irq(&tp->lock);\n\trtl8139_tx_clear (tp);\n\tspin_unlock_irq(&tp->lock);\n\n\t \n\tnapi_enable(&tp->napi);\n\trtl8139_hw_start(dev);\n\tnetif_wake_queue(dev);\n\n\tspin_unlock_bh(&tp->rx_lock);\n}\n\nstatic void rtl8139_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\n\ttp->watchdog_fired = 1;\n\tif (!tp->have_thread) {\n\t\tINIT_DELAYED_WORK(&tp->thread, rtl8139_thread);\n\t\tschedule_delayed_work(&tp->thread, next_tick);\n\t}\n}\n\nstatic netdev_tx_t rtl8139_start_xmit (struct sk_buff *skb,\n\t\t\t\t\t     struct net_device *dev)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tunsigned int entry;\n\tunsigned int len = skb->len;\n\tunsigned long flags;\n\n\t \n\tentry = tp->cur_tx % NUM_TX_DESC;\n\n\t \n\tif (likely(len < TX_BUF_SIZE)) {\n\t\tif (len < ETH_ZLEN)\n\t\t\tmemset(tp->tx_buf[entry], 0, ETH_ZLEN);\n\t\tskb_copy_and_csum_dev(skb, tp->tx_buf[entry]);\n\t\tdev_kfree_skb_any(skb);\n\t} else {\n\t\tdev_kfree_skb_any(skb);\n\t\tdev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tspin_lock_irqsave(&tp->lock, flags);\n\t \n\twmb();\n\tRTL_W32_F (TxStatus0 + (entry * sizeof (u32)),\n\t\t   tp->tx_flag | max(len, (unsigned int)ETH_ZLEN));\n\n\ttp->cur_tx++;\n\n\tif ((tp->cur_tx - NUM_TX_DESC) == tp->dirty_tx)\n\t\tnetif_stop_queue (dev);\n\tspin_unlock_irqrestore(&tp->lock, flags);\n\n\tnetif_dbg(tp, tx_queued, dev, \"Queued Tx packet size %u to slot %d\\n\",\n\t\t  len, entry);\n\n\treturn NETDEV_TX_OK;\n}\n\n\nstatic void rtl8139_tx_interrupt (struct net_device *dev,\n\t\t\t\t  struct rtl8139_private *tp,\n\t\t\t\t  void __iomem *ioaddr)\n{\n\tunsigned long dirty_tx, tx_left;\n\n\tassert (dev != NULL);\n\tassert (ioaddr != NULL);\n\n\tdirty_tx = tp->dirty_tx;\n\ttx_left = tp->cur_tx - dirty_tx;\n\twhile (tx_left > 0) {\n\t\tint entry = dirty_tx % NUM_TX_DESC;\n\t\tint txstatus;\n\n\t\ttxstatus = RTL_R32 (TxStatus0 + (entry * sizeof (u32)));\n\n\t\tif (!(txstatus & (TxStatOK | TxUnderrun | TxAborted)))\n\t\t\tbreak;\t \n\n\t\t \n\t\tif (txstatus & (TxOutOfWindow | TxAborted)) {\n\t\t\t \n\t\t\tnetif_dbg(tp, tx_err, dev, \"Transmit error, Tx status %08x\\n\",\n\t\t\t\t  txstatus);\n\t\t\tdev->stats.tx_errors++;\n\t\t\tif (txstatus & TxAborted) {\n\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\t\tRTL_W32 (TxConfig, TxClearAbt);\n\t\t\t\tRTL_W16 (IntrStatus, TxErr);\n\t\t\t\twmb();\n\t\t\t}\n\t\t\tif (txstatus & TxCarrierLost)\n\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\tif (txstatus & TxOutOfWindow)\n\t\t\t\tdev->stats.tx_window_errors++;\n\t\t} else {\n\t\t\tif (txstatus & TxUnderrun) {\n\t\t\t\t \n\t\t\t\tif (tp->tx_flag < 0x00300000)\n\t\t\t\t\ttp->tx_flag += 0x00020000;\n\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\t}\n\t\t\tdev->stats.collisions += (txstatus >> 24) & 15;\n\t\t\tu64_stats_update_begin(&tp->tx_stats.syncp);\n\t\t\ttp->tx_stats.packets++;\n\t\t\ttp->tx_stats.bytes += txstatus & 0x7ff;\n\t\t\tu64_stats_update_end(&tp->tx_stats.syncp);\n\t\t}\n\n\t\tdirty_tx++;\n\t\ttx_left--;\n\t}\n\n#ifndef RTL8139_NDEBUG\n\tif (tp->cur_tx - dirty_tx > NUM_TX_DESC) {\n\t\tnetdev_err(dev, \"Out-of-sync dirty pointer, %ld vs. %ld\\n\",\n\t\t\t   dirty_tx, tp->cur_tx);\n\t\tdirty_tx += NUM_TX_DESC;\n\t}\n#endif  \n\n\t \n\tif (tp->dirty_tx != dirty_tx) {\n\t\ttp->dirty_tx = dirty_tx;\n\t\tmb();\n\t\tnetif_wake_queue (dev);\n\t}\n}\n\n\n \nstatic void rtl8139_rx_err (u32 rx_status, struct net_device *dev,\n\t\t\t    struct rtl8139_private *tp, void __iomem *ioaddr)\n{\n\tu8 tmp8;\n#ifdef CONFIG_8139_OLD_RX_RESET\n\tint tmp_work;\n#endif\n\n\tnetif_dbg(tp, rx_err, dev, \"Ethernet frame had errors, status %08x\\n\",\n\t\t  rx_status);\n\tdev->stats.rx_errors++;\n\tif (!(rx_status & RxStatusOK)) {\n\t\tif (rx_status & RxTooLong) {\n\t\t\tnetdev_dbg(dev, \"Oversized Ethernet frame, status %04x!\\n\",\n\t\t\t\t   rx_status);\n\t\t\t \n\t\t}\n\t\tif (rx_status & (RxBadSymbol | RxBadAlign))\n\t\t\tdev->stats.rx_frame_errors++;\n\t\tif (rx_status & (RxRunt | RxTooLong))\n\t\t\tdev->stats.rx_length_errors++;\n\t\tif (rx_status & RxCRCErr)\n\t\t\tdev->stats.rx_crc_errors++;\n\t} else {\n\t\ttp->xstats.rx_lost_in_ring++;\n\t}\n\n#ifndef CONFIG_8139_OLD_RX_RESET\n\ttmp8 = RTL_R8 (ChipCmd);\n\tRTL_W8 (ChipCmd, tmp8 & ~CmdRxEnb);\n\tRTL_W8 (ChipCmd, tmp8);\n\tRTL_W32 (RxConfig, tp->rx_config);\n\ttp->cur_rx = 0;\n#else\n\t \n\n\t \n\tRTL_W8_F (ChipCmd, CmdTxEnb);\n\ttmp_work = 200;\n\twhile (--tmp_work > 0) {\n\t\tudelay(1);\n\t\ttmp8 = RTL_R8 (ChipCmd);\n\t\tif (!(tmp8 & CmdRxEnb))\n\t\t\tbreak;\n\t}\n\tif (tmp_work <= 0)\n\t\tnetdev_warn(dev, \"rx stop wait too long\\n\");\n\t \n\ttmp_work = 200;\n\twhile (--tmp_work > 0) {\n\t\tRTL_W8_F (ChipCmd, CmdRxEnb | CmdTxEnb);\n\t\tudelay(1);\n\t\ttmp8 = RTL_R8 (ChipCmd);\n\t\tif ((tmp8 & CmdRxEnb) && (tmp8 & CmdTxEnb))\n\t\t\tbreak;\n\t}\n\tif (tmp_work <= 0)\n\t\tnetdev_warn(dev, \"tx/rx enable wait too long\\n\");\n\n\t \n\tRTL_W8_F (Cfg9346, Cfg9346_Unlock);\n\t \n\tRTL_W8 (ChipCmd, CmdRxEnb | CmdTxEnb);\n\n\ttp->rx_config = rtl8139_rx_config | AcceptBroadcast | AcceptMyPhys;\n\tRTL_W32 (RxConfig, tp->rx_config);\n\ttp->cur_rx = 0;\n\n\tnetdev_dbg(dev, \"init buffer addresses\\n\");\n\n\t \n\tRTL_W8 (Cfg9346, Cfg9346_Lock);\n\n\t \n\tRTL_W32_F (RxBuf, tp->rx_ring_dma);\n\n\t \n\t__set_rx_mode (dev);\n#endif\n}\n\n#if RX_BUF_IDX == 3\nstatic inline void wrap_copy(struct sk_buff *skb, const unsigned char *ring,\n\t\t\t\t u32 offset, unsigned int size)\n{\n\tu32 left = RX_BUF_LEN - offset;\n\n\tif (size > left) {\n\t\tskb_copy_to_linear_data(skb, ring + offset, left);\n\t\tskb_copy_to_linear_data_offset(skb, left, ring, size - left);\n\t} else\n\t\tskb_copy_to_linear_data(skb, ring + offset, size);\n}\n#endif\n\nstatic void rtl8139_isr_ack(struct rtl8139_private *tp)\n{\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tu16 status;\n\n\tstatus = RTL_R16 (IntrStatus) & RxAckBits;\n\n\t \n\tif (likely(status != 0)) {\n\t\tif (unlikely(status & (RxFIFOOver | RxOverflow))) {\n\t\t\ttp->dev->stats.rx_errors++;\n\t\t\tif (status & RxFIFOOver)\n\t\t\t\ttp->dev->stats.rx_fifo_errors++;\n\t\t}\n\t\tRTL_W16_F (IntrStatus, RxAckBits);\n\t}\n}\n\nstatic int rtl8139_rx(struct net_device *dev, struct rtl8139_private *tp,\n\t\t      int budget)\n{\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tint received = 0;\n\tunsigned char *rx_ring = tp->rx_ring;\n\tunsigned int cur_rx = tp->cur_rx;\n\tunsigned int rx_size = 0;\n\n\tnetdev_dbg(dev, \"In %s(), current %04x BufAddr %04x, free to %04x, Cmd %02x\\n\",\n\t\t   __func__, (u16)cur_rx,\n\t\t   RTL_R16(RxBufAddr), RTL_R16(RxBufPtr), RTL_R8(ChipCmd));\n\n\twhile (netif_running(dev) && received < budget &&\n\t       (RTL_R8 (ChipCmd) & RxBufEmpty) == 0) {\n\t\tu32 ring_offset = cur_rx % RX_BUF_LEN;\n\t\tu32 rx_status;\n\t\tunsigned int pkt_size;\n\t\tstruct sk_buff *skb;\n\n\t\trmb();\n\n\t\t \n\t\trx_status = le32_to_cpu (*(__le32 *) (rx_ring + ring_offset));\n\t\trx_size = rx_status >> 16;\n\t\tif (likely(!(dev->features & NETIF_F_RXFCS)))\n\t\t\tpkt_size = rx_size - 4;\n\t\telse\n\t\t\tpkt_size = rx_size;\n\n\t\tnetif_dbg(tp, rx_status, dev, \"%s() status %04x, size %04x, cur %04x\\n\",\n\t\t\t  __func__, rx_status, rx_size, cur_rx);\n#if RTL8139_DEBUG > 2\n\t\tprint_hex_dump(KERN_DEBUG, \"Frame contents: \",\n\t\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       &rx_ring[ring_offset], 70, true);\n#endif\n\n\t\t \n\t\tif (unlikely(rx_size == 0xfff0)) {\n\t\t\tif (!tp->fifo_copy_timeout)\n\t\t\t\ttp->fifo_copy_timeout = jiffies + 2;\n\t\t\telse if (time_after(jiffies, tp->fifo_copy_timeout)) {\n\t\t\t\tnetdev_dbg(dev, \"hung FIFO. Reset\\n\");\n\t\t\t\trx_size = 0;\n\t\t\t\tgoto no_early_rx;\n\t\t\t}\n\t\t\tnetif_dbg(tp, intr, dev, \"fifo copy in progress\\n\");\n\t\t\ttp->xstats.early_rx++;\n\t\t\tbreak;\n\t\t}\n\nno_early_rx:\n\t\ttp->fifo_copy_timeout = 0;\n\n\t\t \n\t\tif (unlikely((rx_size > (MAX_ETH_FRAME_SIZE+4)) ||\n\t\t\t     (rx_size < 8) ||\n\t\t\t     (!(rx_status & RxStatusOK)))) {\n\t\t\tif ((dev->features & NETIF_F_RXALL) &&\n\t\t\t    (rx_size <= (MAX_ETH_FRAME_SIZE + 4)) &&\n\t\t\t    (rx_size >= 8) &&\n\t\t\t    (!(rx_status & RxStatusOK))) {\n\t\t\t\t \n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t\tif (rx_status & RxCRCErr) {\n\t\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t\t\tgoto keep_pkt;\n\t\t\t\t}\n\t\t\t\tif (rx_status & RxRunt) {\n\t\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\t\tgoto keep_pkt;\n\t\t\t\t}\n\t\t\t}\n\t\t\trtl8139_rx_err (rx_status, dev, tp, ioaddr);\n\t\t\treceived = -1;\n\t\t\tgoto out;\n\t\t}\n\nkeep_pkt:\n\t\t \n\t\t \n\n\t\tskb = napi_alloc_skb(&tp->napi, pkt_size);\n\t\tif (likely(skb)) {\n#if RX_BUF_IDX == 3\n\t\t\twrap_copy(skb, rx_ring, ring_offset+4, pkt_size);\n#else\n\t\t\tskb_copy_to_linear_data (skb, &rx_ring[ring_offset + 4], pkt_size);\n#endif\n\t\t\tskb_put (skb, pkt_size);\n\n\t\t\tskb->protocol = eth_type_trans (skb, dev);\n\n\t\t\tu64_stats_update_begin(&tp->rx_stats.syncp);\n\t\t\ttp->rx_stats.packets++;\n\t\t\ttp->rx_stats.bytes += pkt_size;\n\t\t\tu64_stats_update_end(&tp->rx_stats.syncp);\n\n\t\t\tnetif_receive_skb (skb);\n\t\t} else {\n\t\t\tdev->stats.rx_dropped++;\n\t\t}\n\t\treceived++;\n\n\t\tcur_rx = (cur_rx + rx_size + 4 + 3) & ~3;\n\t\tRTL_W16 (RxBufPtr, (u16) (cur_rx - 16));\n\n\t\trtl8139_isr_ack(tp);\n\t}\n\n\tif (unlikely(!received || rx_size == 0xfff0))\n\t\trtl8139_isr_ack(tp);\n\n\tnetdev_dbg(dev, \"Done %s(), current %04x BufAddr %04x, free to %04x, Cmd %02x\\n\",\n\t\t   __func__, cur_rx,\n\t\t   RTL_R16(RxBufAddr), RTL_R16(RxBufPtr), RTL_R8(ChipCmd));\n\n\ttp->cur_rx = cur_rx;\n\n\t \n\tif (tp->fifo_copy_timeout)\n\t\treceived = budget;\n\nout:\n\treturn received;\n}\n\n\nstatic void rtl8139_weird_interrupt (struct net_device *dev,\n\t\t\t\t     struct rtl8139_private *tp,\n\t\t\t\t     void __iomem *ioaddr,\n\t\t\t\t     int status, int link_changed)\n{\n\tnetdev_dbg(dev, \"Abnormal interrupt, status %08x\\n\", status);\n\n\tassert (dev != NULL);\n\tassert (tp != NULL);\n\tassert (ioaddr != NULL);\n\n\t \n\tdev->stats.rx_missed_errors += RTL_R32 (RxMissed);\n\tRTL_W32 (RxMissed, 0);\n\n\tif ((status & RxUnderrun) && link_changed &&\n\t    (tp->drv_flags & HAS_LNK_CHNG)) {\n\t\trtl_check_media(dev, 0);\n\t\tstatus &= ~RxUnderrun;\n\t}\n\n\tif (status & (RxUnderrun | RxErr))\n\t\tdev->stats.rx_errors++;\n\n\tif (status & PCSTimeout)\n\t\tdev->stats.rx_length_errors++;\n\tif (status & RxUnderrun)\n\t\tdev->stats.rx_fifo_errors++;\n\tif (status & PCIErr) {\n\t\tu16 pci_cmd_status;\n\t\tpci_read_config_word (tp->pci_dev, PCI_STATUS, &pci_cmd_status);\n\t\tpci_write_config_word (tp->pci_dev, PCI_STATUS, pci_cmd_status);\n\n\t\tnetdev_err(dev, \"PCI Bus error %04x\\n\", pci_cmd_status);\n\t}\n}\n\nstatic int rtl8139_poll(struct napi_struct *napi, int budget)\n{\n\tstruct rtl8139_private *tp = container_of(napi, struct rtl8139_private, napi);\n\tstruct net_device *dev = tp->dev;\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tint work_done;\n\n\tspin_lock(&tp->rx_lock);\n\twork_done = 0;\n\tif (likely(RTL_R16(IntrStatus) & RxAckBits))\n\t\twork_done += rtl8139_rx(dev, tp, budget);\n\n\tif (work_done < budget) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&tp->lock, flags);\n\t\tif (napi_complete_done(napi, work_done))\n\t\t\tRTL_W16_F(IntrMask, rtl8139_intr_mask);\n\t\tspin_unlock_irqrestore(&tp->lock, flags);\n\t}\n\tspin_unlock(&tp->rx_lock);\n\n\treturn work_done;\n}\n\n \nstatic irqreturn_t rtl8139_interrupt (int irq, void *dev_instance)\n{\n\tstruct net_device *dev = (struct net_device *) dev_instance;\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tu16 status, ackstat;\n\tint link_changed = 0;  \n\tint handled = 0;\n\n\tspin_lock (&tp->lock);\n\tstatus = RTL_R16 (IntrStatus);\n\n\t \n\tif (unlikely((status & rtl8139_intr_mask) == 0))\n\t\tgoto out;\n\n\thandled = 1;\n\n\t \n\tif (unlikely(status == 0xFFFF))\n\t\tgoto out;\n\n\t \n\tif (unlikely(!netif_running(dev))) {\n\t\tRTL_W16 (IntrMask, 0);\n\t\tgoto out;\n\t}\n\n\t \n\tif (unlikely(status & RxUnderrun))\n\t\tlink_changed = RTL_R16 (CSCR) & CSCR_LinkChangeBit;\n\n\tackstat = status & ~(RxAckBits | TxErr);\n\tif (ackstat)\n\t\tRTL_W16 (IntrStatus, ackstat);\n\n\t \n\tif (status & RxAckBits){\n\t\tif (napi_schedule_prep(&tp->napi)) {\n\t\t\tRTL_W16_F (IntrMask, rtl8139_norx_intr_mask);\n\t\t\t__napi_schedule(&tp->napi);\n\t\t}\n\t}\n\n\t \n\tif (unlikely(status & (PCIErr | PCSTimeout | RxUnderrun | RxErr)))\n\t\trtl8139_weird_interrupt (dev, tp, ioaddr,\n\t\t\t\t\t status, link_changed);\n\n\tif (status & (TxOK | TxErr)) {\n\t\trtl8139_tx_interrupt (dev, tp, ioaddr);\n\t\tif (status & TxErr)\n\t\t\tRTL_W16 (IntrStatus, TxErr);\n\t}\n out:\n\tspin_unlock (&tp->lock);\n\n\tnetdev_dbg(dev, \"exiting interrupt, intr_status=%#4.4x\\n\",\n\t\t   RTL_R16(IntrStatus));\n\treturn IRQ_RETVAL(handled);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void rtl8139_poll_controller(struct net_device *dev)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tconst int irq = tp->pci_dev->irq;\n\n\tdisable_irq_nosync(irq);\n\trtl8139_interrupt(irq, dev);\n\tenable_irq(irq);\n}\n#endif\n\nstatic int rtl8139_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\tspin_lock_irq(&tp->lock);\n\n\tRTL_W8_F(Cfg9346, Cfg9346_Unlock);\n\tRTL_W32_F(MAC0 + 0, cpu_to_le32 (*(u32 *) (dev->dev_addr + 0)));\n\tRTL_W32_F(MAC0 + 4, cpu_to_le32 (*(u32 *) (dev->dev_addr + 4)));\n\tRTL_W8_F(Cfg9346, Cfg9346_Lock);\n\n\tspin_unlock_irq(&tp->lock);\n\n\treturn 0;\n}\n\nstatic int rtl8139_close (struct net_device *dev)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tunsigned long flags;\n\n\tnetif_stop_queue(dev);\n\tnapi_disable(&tp->napi);\n\n\tnetif_dbg(tp, ifdown, dev, \"Shutting down ethercard, status was 0x%04x\\n\",\n\t\t  RTL_R16(IntrStatus));\n\n\tspin_lock_irqsave (&tp->lock, flags);\n\n\t \n\tRTL_W8 (ChipCmd, 0);\n\n\t \n\tRTL_W16 (IntrMask, 0);\n\n\t \n\tdev->stats.rx_missed_errors += RTL_R32 (RxMissed);\n\tRTL_W32 (RxMissed, 0);\n\n\tspin_unlock_irqrestore (&tp->lock, flags);\n\n\tfree_irq(tp->pci_dev->irq, dev);\n\n\trtl8139_tx_clear (tp);\n\n\tdma_free_coherent(&tp->pci_dev->dev, RX_BUF_TOT_LEN,\n\t\t\t  tp->rx_ring, tp->rx_ring_dma);\n\tdma_free_coherent(&tp->pci_dev->dev, TX_BUF_TOT_LEN,\n\t\t\t  tp->tx_bufs, tp->tx_bufs_dma);\n\ttp->rx_ring = NULL;\n\ttp->tx_bufs = NULL;\n\n\t \n\tRTL_W8 (Cfg9346, Cfg9346_Unlock);\n\n\tif (rtl_chip_info[tp->chipset].flags & HasHltClk)\n\t\tRTL_W8 (HltClk, 'H');\t \n\n\treturn 0;\n}\n\n\n \nstatic void rtl8139_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\n\tspin_lock_irq(&tp->lock);\n\tif (rtl_chip_info[tp->chipset].flags & HasLWake) {\n\t\tu8 cfg3 = RTL_R8 (Config3);\n\t\tu8 cfg5 = RTL_R8 (Config5);\n\n\t\twol->supported = WAKE_PHY | WAKE_MAGIC\n\t\t\t| WAKE_UCAST | WAKE_MCAST | WAKE_BCAST;\n\n\t\twol->wolopts = 0;\n\t\tif (cfg3 & Cfg3_LinkUp)\n\t\t\twol->wolopts |= WAKE_PHY;\n\t\tif (cfg3 & Cfg3_Magic)\n\t\t\twol->wolopts |= WAKE_MAGIC;\n\t\t \n\t\tif (cfg5 & Cfg5_UWF)\n\t\t\twol->wolopts |= WAKE_UCAST;\n\t\tif (cfg5 & Cfg5_MWF)\n\t\t\twol->wolopts |= WAKE_MCAST;\n\t\tif (cfg5 & Cfg5_BWF)\n\t\t\twol->wolopts |= WAKE_BCAST;\n\t}\n\tspin_unlock_irq(&tp->lock);\n}\n\n\n \nstatic int rtl8139_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tu32 support;\n\tu8 cfg3, cfg5;\n\n\tsupport = ((rtl_chip_info[tp->chipset].flags & HasLWake)\n\t\t   ? (WAKE_PHY | WAKE_MAGIC\n\t\t      | WAKE_UCAST | WAKE_MCAST | WAKE_BCAST)\n\t\t   : 0);\n\tif (wol->wolopts & ~support)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&tp->lock);\n\tcfg3 = RTL_R8 (Config3) & ~(Cfg3_LinkUp | Cfg3_Magic);\n\tif (wol->wolopts & WAKE_PHY)\n\t\tcfg3 |= Cfg3_LinkUp;\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\tcfg3 |= Cfg3_Magic;\n\tRTL_W8 (Cfg9346, Cfg9346_Unlock);\n\tRTL_W8 (Config3, cfg3);\n\tRTL_W8 (Cfg9346, Cfg9346_Lock);\n\n\tcfg5 = RTL_R8 (Config5) & ~(Cfg5_UWF | Cfg5_MWF | Cfg5_BWF);\n\t \n\tif (wol->wolopts & WAKE_UCAST)\n\t\tcfg5 |= Cfg5_UWF;\n\tif (wol->wolopts & WAKE_MCAST)\n\t\tcfg5 |= Cfg5_MWF;\n\tif (wol->wolopts & WAKE_BCAST)\n\t\tcfg5 |= Cfg5_BWF;\n\tRTL_W8 (Config5, cfg5);\t \n\tspin_unlock_irq(&tp->lock);\n\n\treturn 0;\n}\n\nstatic void rtl8139_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(tp->pci_dev), sizeof(info->bus_info));\n}\n\nstatic int rtl8139_get_link_ksettings(struct net_device *dev,\n\t\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tspin_lock_irq(&tp->lock);\n\tmii_ethtool_get_link_ksettings(&tp->mii, cmd);\n\tspin_unlock_irq(&tp->lock);\n\treturn 0;\n}\n\nstatic int rtl8139_set_link_ksettings(struct net_device *dev,\n\t\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tint rc;\n\tspin_lock_irq(&tp->lock);\n\trc = mii_ethtool_set_link_ksettings(&tp->mii, cmd);\n\tspin_unlock_irq(&tp->lock);\n\treturn rc;\n}\n\nstatic int rtl8139_nway_reset(struct net_device *dev)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\treturn mii_nway_restart(&tp->mii);\n}\n\nstatic u32 rtl8139_get_link(struct net_device *dev)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\treturn mii_link_ok(&tp->mii);\n}\n\nstatic u32 rtl8139_get_msglevel(struct net_device *dev)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\treturn tp->msg_enable;\n}\n\nstatic void rtl8139_set_msglevel(struct net_device *dev, u32 datum)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\ttp->msg_enable = datum;\n}\n\nstatic int rtl8139_get_regs_len(struct net_device *dev)\n{\n\tstruct rtl8139_private *tp;\n\t \n\tif (use_io)\n\t\treturn 0;\n\ttp = netdev_priv(dev);\n\treturn tp->regs_len;\n}\n\nstatic void rtl8139_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *regbuf)\n{\n\tstruct rtl8139_private *tp;\n\n\t \n\tif (use_io)\n\t\treturn;\n\ttp = netdev_priv(dev);\n\n\tregs->version = RTL_REGS_VER;\n\n\tspin_lock_irq(&tp->lock);\n\tmemcpy_fromio(regbuf, tp->mmio_addr, regs->len);\n\tspin_unlock_irq(&tp->lock);\n}\n\nstatic int rtl8139_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn RTL_NUM_STATS;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void rtl8139_get_ethtool_stats(struct net_device *dev, struct ethtool_stats *stats, u64 *data)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\n\tdata[0] = tp->xstats.early_rx;\n\tdata[1] = tp->xstats.tx_buf_mapped;\n\tdata[2] = tp->xstats.tx_timeouts;\n\tdata[3] = tp->xstats.rx_lost_in_ring;\n}\n\nstatic void rtl8139_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tmemcpy(data, ethtool_stats_keys, sizeof(ethtool_stats_keys));\n}\n\nstatic const struct ethtool_ops rtl8139_ethtool_ops = {\n\t.get_drvinfo\t\t= rtl8139_get_drvinfo,\n\t.get_regs_len\t\t= rtl8139_get_regs_len,\n\t.get_regs\t\t= rtl8139_get_regs,\n\t.nway_reset\t\t= rtl8139_nway_reset,\n\t.get_link\t\t= rtl8139_get_link,\n\t.get_msglevel\t\t= rtl8139_get_msglevel,\n\t.set_msglevel\t\t= rtl8139_set_msglevel,\n\t.get_wol\t\t= rtl8139_get_wol,\n\t.set_wol\t\t= rtl8139_set_wol,\n\t.get_strings\t\t= rtl8139_get_strings,\n\t.get_sset_count\t\t= rtl8139_get_sset_count,\n\t.get_ethtool_stats\t= rtl8139_get_ethtool_stats,\n\t.get_link_ksettings\t= rtl8139_get_link_ksettings,\n\t.set_link_ksettings\t= rtl8139_set_link_ksettings,\n};\n\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tint rc;\n\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&tp->lock);\n\trc = generic_mii_ioctl(&tp->mii, if_mii(rq), cmd, NULL);\n\tspin_unlock_irq(&tp->lock);\n\n\treturn rc;\n}\n\n\nstatic void\nrtl8139_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tunsigned long flags;\n\tunsigned int start;\n\n\tif (netif_running(dev)) {\n\t\tspin_lock_irqsave (&tp->lock, flags);\n\t\tdev->stats.rx_missed_errors += RTL_R32 (RxMissed);\n\t\tRTL_W32 (RxMissed, 0);\n\t\tspin_unlock_irqrestore (&tp->lock, flags);\n\t}\n\n\tnetdev_stats_to_stats64(stats, &dev->stats);\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&tp->rx_stats.syncp);\n\t\tstats->rx_packets = tp->rx_stats.packets;\n\t\tstats->rx_bytes = tp->rx_stats.bytes;\n\t} while (u64_stats_fetch_retry(&tp->rx_stats.syncp, start));\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&tp->tx_stats.syncp);\n\t\tstats->tx_packets = tp->tx_stats.packets;\n\t\tstats->tx_bytes = tp->tx_stats.bytes;\n\t} while (u64_stats_fetch_retry(&tp->tx_stats.syncp, start));\n}\n\n \n\nstatic void __set_rx_mode (struct net_device *dev)\n{\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tu32 mc_filter[2];\t \n\tint rx_mode;\n\tu32 tmp;\n\n\tnetdev_dbg(dev, \"rtl8139_set_rx_mode(%04x) done -- Rx config %08x\\n\",\n\t\t   dev->flags, RTL_R32(RxConfig));\n\n\t \n\tif (dev->flags & IFF_PROMISC) {\n\t\trx_mode =\n\t\t    AcceptBroadcast | AcceptMulticast | AcceptMyPhys |\n\t\t    AcceptAllPhys;\n\t\tmc_filter[1] = mc_filter[0] = 0xffffffff;\n\t} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\n\t\t   (dev->flags & IFF_ALLMULTI)) {\n\t\t \n\t\trx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;\n\t\tmc_filter[1] = mc_filter[0] = 0xffffffff;\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\t\trx_mode = AcceptBroadcast | AcceptMyPhys;\n\t\tmc_filter[1] = mc_filter[0] = 0;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tint bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\n\n\t\t\tmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\n\t\t\trx_mode |= AcceptMulticast;\n\t\t}\n\t}\n\n\tif (dev->features & NETIF_F_RXALL)\n\t\trx_mode |= (AcceptErr | AcceptRunt);\n\n\t \n\ttmp = rtl8139_rx_config | rx_mode;\n\tif (tp->rx_config != tmp) {\n\t\tRTL_W32_F (RxConfig, tmp);\n\t\ttp->rx_config = tmp;\n\t}\n\tRTL_W32_F (MAR0 + 0, mc_filter[0]);\n\tRTL_W32_F (MAR0 + 4, mc_filter[1]);\n}\n\nstatic void rtl8139_set_rx_mode (struct net_device *dev)\n{\n\tunsigned long flags;\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\n\tspin_lock_irqsave (&tp->lock, flags);\n\t__set_rx_mode(dev);\n\tspin_unlock_irqrestore (&tp->lock, flags);\n}\n\nstatic int __maybe_unused rtl8139_suspend(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct rtl8139_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tunsigned long flags;\n\n\tif (!netif_running (dev))\n\t\treturn 0;\n\n\tnetif_device_detach (dev);\n\n\tspin_lock_irqsave (&tp->lock, flags);\n\n\t \n\tRTL_W16 (IntrMask, 0);\n\tRTL_W8 (ChipCmd, 0);\n\n\t \n\tdev->stats.rx_missed_errors += RTL_R32 (RxMissed);\n\tRTL_W32 (RxMissed, 0);\n\n\tspin_unlock_irqrestore (&tp->lock, flags);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rtl8139_resume(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\n\tif (!netif_running (dev))\n\t\treturn 0;\n\n\trtl8139_init_ring (dev);\n\trtl8139_hw_start (dev);\n\tnetif_device_attach (dev);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(rtl8139_pm_ops, rtl8139_suspend, rtl8139_resume);\n\nstatic struct pci_driver rtl8139_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= rtl8139_pci_tbl,\n\t.probe\t\t= rtl8139_init_one,\n\t.remove\t\t= rtl8139_remove_one,\n\t.driver.pm\t= &rtl8139_pm_ops,\n};\n\n\nstatic int __init rtl8139_init_module (void)\n{\n\t \n#ifdef MODULE\n\tpr_info(RTL8139_DRIVER_NAME \"\\n\");\n#endif\n\n\treturn pci_register_driver(&rtl8139_pci_driver);\n}\n\n\nstatic void __exit rtl8139_cleanup_module (void)\n{\n\tpci_unregister_driver (&rtl8139_pci_driver);\n}\n\n\nmodule_init(rtl8139_init_module);\nmodule_exit(rtl8139_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}