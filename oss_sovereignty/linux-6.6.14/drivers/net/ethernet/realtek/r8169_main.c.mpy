{
  "module_name": "r8169_main.c",
  "hash_id": "d501fbba447ce5751fbb0501eb725dc598d22e5b4a81469680ba6b006fa6e8ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/realtek/r8169_main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/phy.h>\n#include <linux/if_vlan.h>\n#include <linux/in.h>\n#include <linux/io.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/pm_runtime.h>\n#include <linux/bitfield.h>\n#include <linux/prefetch.h>\n#include <linux/ipv6.h>\n#include <asm/unaligned.h>\n#include <net/ip6_checksum.h>\n#include <net/netdev_queues.h>\n\n#include \"r8169.h\"\n#include \"r8169_firmware.h\"\n\n#define FIRMWARE_8168D_1\t\"rtl_nic/rtl8168d-1.fw\"\n#define FIRMWARE_8168D_2\t\"rtl_nic/rtl8168d-2.fw\"\n#define FIRMWARE_8168E_1\t\"rtl_nic/rtl8168e-1.fw\"\n#define FIRMWARE_8168E_2\t\"rtl_nic/rtl8168e-2.fw\"\n#define FIRMWARE_8168E_3\t\"rtl_nic/rtl8168e-3.fw\"\n#define FIRMWARE_8168F_1\t\"rtl_nic/rtl8168f-1.fw\"\n#define FIRMWARE_8168F_2\t\"rtl_nic/rtl8168f-2.fw\"\n#define FIRMWARE_8105E_1\t\"rtl_nic/rtl8105e-1.fw\"\n#define FIRMWARE_8402_1\t\t\"rtl_nic/rtl8402-1.fw\"\n#define FIRMWARE_8411_1\t\t\"rtl_nic/rtl8411-1.fw\"\n#define FIRMWARE_8411_2\t\t\"rtl_nic/rtl8411-2.fw\"\n#define FIRMWARE_8106E_1\t\"rtl_nic/rtl8106e-1.fw\"\n#define FIRMWARE_8106E_2\t\"rtl_nic/rtl8106e-2.fw\"\n#define FIRMWARE_8168G_2\t\"rtl_nic/rtl8168g-2.fw\"\n#define FIRMWARE_8168G_3\t\"rtl_nic/rtl8168g-3.fw\"\n#define FIRMWARE_8168H_2\t\"rtl_nic/rtl8168h-2.fw\"\n#define FIRMWARE_8168FP_3\t\"rtl_nic/rtl8168fp-3.fw\"\n#define FIRMWARE_8107E_2\t\"rtl_nic/rtl8107e-2.fw\"\n#define FIRMWARE_8125A_3\t\"rtl_nic/rtl8125a-3.fw\"\n#define FIRMWARE_8125B_2\t\"rtl_nic/rtl8125b-2.fw\"\n\n \n#define\tMC_FILTER_LIMIT\t32\n\n#define TX_DMA_BURST\t7\t \n#define InterFrameGap\t0x03\t \n\n#define R8169_REGS_SIZE\t\t256\n#define R8169_RX_BUF_SIZE\t(SZ_16K - 1)\n#define NUM_TX_DESC\t256\t \n#define NUM_RX_DESC\t256\t \n#define R8169_TX_RING_BYTES\t(NUM_TX_DESC * sizeof(struct TxDesc))\n#define R8169_RX_RING_BYTES\t(NUM_RX_DESC * sizeof(struct RxDesc))\n#define R8169_TX_STOP_THRS\t(MAX_SKB_FRAGS + 1)\n#define R8169_TX_START_THRS\t(2 * R8169_TX_STOP_THRS)\n\n#define OCP_STD_PHY_BASE\t0xa400\n\n#define RTL_CFG_NO_GBIT\t1\n\n \n#define RTL_W8(tp, reg, val8)\twriteb((val8), tp->mmio_addr + (reg))\n#define RTL_W16(tp, reg, val16)\twritew((val16), tp->mmio_addr + (reg))\n#define RTL_W32(tp, reg, val32)\twritel((val32), tp->mmio_addr + (reg))\n#define RTL_R8(tp, reg)\t\treadb(tp->mmio_addr + (reg))\n#define RTL_R16(tp, reg)\t\treadw(tp->mmio_addr + (reg))\n#define RTL_R32(tp, reg)\t\treadl(tp->mmio_addr + (reg))\n\n#define JUMBO_4K\t(4 * SZ_1K - VLAN_ETH_HLEN - ETH_FCS_LEN)\n#define JUMBO_6K\t(6 * SZ_1K - VLAN_ETH_HLEN - ETH_FCS_LEN)\n#define JUMBO_7K\t(7 * SZ_1K - VLAN_ETH_HLEN - ETH_FCS_LEN)\n#define JUMBO_9K\t(9 * SZ_1K - VLAN_ETH_HLEN - ETH_FCS_LEN)\n\nstatic const struct {\n\tconst char *name;\n\tconst char *fw_name;\n} rtl_chip_infos[] = {\n\t \n\t[RTL_GIGA_MAC_VER_02] = {\"RTL8169s\"\t\t\t\t},\n\t[RTL_GIGA_MAC_VER_03] = {\"RTL8110s\"\t\t\t\t},\n\t[RTL_GIGA_MAC_VER_04] = {\"RTL8169sb/8110sb\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_05] = {\"RTL8169sc/8110sc\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_06] = {\"RTL8169sc/8110sc\"\t\t\t},\n\t \n\t[RTL_GIGA_MAC_VER_07] = {\"RTL8102e\"\t\t\t\t},\n\t[RTL_GIGA_MAC_VER_08] = {\"RTL8102e\"\t\t\t\t},\n\t[RTL_GIGA_MAC_VER_09] = {\"RTL8102e/RTL8103e\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_10] = {\"RTL8101e/RTL8100e\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_11] = {\"RTL8168b/8111b\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_14] = {\"RTL8401\"\t\t\t\t},\n\t[RTL_GIGA_MAC_VER_17] = {\"RTL8168b/8111b\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_18] = {\"RTL8168cp/8111cp\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_19] = {\"RTL8168c/8111c\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_20] = {\"RTL8168c/8111c\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_21] = {\"RTL8168c/8111c\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_22] = {\"RTL8168c/8111c\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_23] = {\"RTL8168cp/8111cp\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_24] = {\"RTL8168cp/8111cp\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_25] = {\"RTL8168d/8111d\",\tFIRMWARE_8168D_1},\n\t[RTL_GIGA_MAC_VER_26] = {\"RTL8168d/8111d\",\tFIRMWARE_8168D_2},\n\t[RTL_GIGA_MAC_VER_28] = {\"RTL8168dp/8111dp\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_29] = {\"RTL8105e\",\t\tFIRMWARE_8105E_1},\n\t[RTL_GIGA_MAC_VER_30] = {\"RTL8105e\",\t\tFIRMWARE_8105E_1},\n\t[RTL_GIGA_MAC_VER_31] = {\"RTL8168dp/8111dp\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_32] = {\"RTL8168e/8111e\",\tFIRMWARE_8168E_1},\n\t[RTL_GIGA_MAC_VER_33] = {\"RTL8168e/8111e\",\tFIRMWARE_8168E_2},\n\t[RTL_GIGA_MAC_VER_34] = {\"RTL8168evl/8111evl\",\tFIRMWARE_8168E_3},\n\t[RTL_GIGA_MAC_VER_35] = {\"RTL8168f/8111f\",\tFIRMWARE_8168F_1},\n\t[RTL_GIGA_MAC_VER_36] = {\"RTL8168f/8111f\",\tFIRMWARE_8168F_2},\n\t[RTL_GIGA_MAC_VER_37] = {\"RTL8402\",\t\tFIRMWARE_8402_1 },\n\t[RTL_GIGA_MAC_VER_38] = {\"RTL8411\",\t\tFIRMWARE_8411_1 },\n\t[RTL_GIGA_MAC_VER_39] = {\"RTL8106e\",\t\tFIRMWARE_8106E_1},\n\t[RTL_GIGA_MAC_VER_40] = {\"RTL8168g/8111g\",\tFIRMWARE_8168G_2},\n\t[RTL_GIGA_MAC_VER_42] = {\"RTL8168gu/8111gu\",\tFIRMWARE_8168G_3},\n\t[RTL_GIGA_MAC_VER_43] = {\"RTL8106eus\",\t\tFIRMWARE_8106E_2},\n\t[RTL_GIGA_MAC_VER_44] = {\"RTL8411b\",\t\tFIRMWARE_8411_2 },\n\t[RTL_GIGA_MAC_VER_46] = {\"RTL8168h/8111h\",\tFIRMWARE_8168H_2},\n\t[RTL_GIGA_MAC_VER_48] = {\"RTL8107e\",\t\tFIRMWARE_8107E_2},\n\t[RTL_GIGA_MAC_VER_51] = {\"RTL8168ep/8111ep\"\t\t\t},\n\t[RTL_GIGA_MAC_VER_52] = {\"RTL8168fp/RTL8117\",  FIRMWARE_8168FP_3},\n\t[RTL_GIGA_MAC_VER_53] = {\"RTL8168fp/RTL8117\",\t\t\t},\n\t[RTL_GIGA_MAC_VER_61] = {\"RTL8125A\",\t\tFIRMWARE_8125A_3},\n\t \n\t[RTL_GIGA_MAC_VER_63] = {\"RTL8125B\",\t\tFIRMWARE_8125B_2},\n};\n\nstatic const struct pci_device_id rtl8169_pci_tbl[] = {\n\t{ PCI_VDEVICE(REALTEK,\t0x2502) },\n\t{ PCI_VDEVICE(REALTEK,\t0x2600) },\n\t{ PCI_VDEVICE(REALTEK,\t0x8129) },\n\t{ PCI_VDEVICE(REALTEK,\t0x8136), RTL_CFG_NO_GBIT },\n\t{ PCI_VDEVICE(REALTEK,\t0x8161) },\n\t{ PCI_VDEVICE(REALTEK,\t0x8162) },\n\t{ PCI_VDEVICE(REALTEK,\t0x8167) },\n\t{ PCI_VDEVICE(REALTEK,\t0x8168) },\n\t{ PCI_VDEVICE(NCUBE,\t0x8168) },\n\t{ PCI_VDEVICE(REALTEK,\t0x8169) },\n\t{ PCI_VENDOR_ID_DLINK,\t0x4300,\n\t\tPCI_VENDOR_ID_DLINK, 0x4b10, 0, 0 },\n\t{ PCI_VDEVICE(DLINK,\t0x4300) },\n\t{ PCI_VDEVICE(DLINK,\t0x4302) },\n\t{ PCI_VDEVICE(AT,\t0xc107) },\n\t{ PCI_VDEVICE(USR,\t0x0116) },\n\t{ PCI_VENDOR_ID_LINKSYS, 0x1032, PCI_ANY_ID, 0x0024 },\n\t{ 0x0001, 0x8168, PCI_ANY_ID, 0x2410 },\n\t{ PCI_VDEVICE(REALTEK,\t0x8125) },\n\t{ PCI_VDEVICE(REALTEK,\t0x3000) },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, rtl8169_pci_tbl);\n\nenum rtl_registers {\n\tMAC0\t\t= 0,\t \n\tMAC4\t\t= 4,\n\tMAR0\t\t= 8,\t \n\tCounterAddrLow\t\t= 0x10,\n\tCounterAddrHigh\t\t= 0x14,\n\tTxDescStartAddrLow\t= 0x20,\n\tTxDescStartAddrHigh\t= 0x24,\n\tTxHDescStartAddrLow\t= 0x28,\n\tTxHDescStartAddrHigh\t= 0x2c,\n\tFLASH\t\t= 0x30,\n\tERSR\t\t= 0x36,\n\tChipCmd\t\t= 0x37,\n\tTxPoll\t\t= 0x38,\n\tIntrMask\t= 0x3c,\n\tIntrStatus\t= 0x3e,\n\n\tTxConfig\t= 0x40,\n#define\tTXCFG_AUTO_FIFO\t\t\t(1 << 7)\t \n#define\tTXCFG_EMPTY\t\t\t(1 << 11)\t \n\n\tRxConfig\t= 0x44,\n#define\tRX128_INT_EN\t\t\t(1 << 15)\t \n#define\tRX_MULTI_EN\t\t\t(1 << 14)\t \n#define\tRXCFG_FIFO_SHIFT\t\t13\n\t\t\t\t\t \n#define\tRX_FIFO_THRESH\t\t\t(7 << RXCFG_FIFO_SHIFT)\n#define\tRX_EARLY_OFF\t\t\t(1 << 11)\n#define\tRX_PAUSE_SLOT_ON\t\t(1 << 11)\t \n#define\tRXCFG_DMA_SHIFT\t\t\t8\n\t\t\t\t\t \n#define\tRX_DMA_BURST\t\t\t(7 << RXCFG_DMA_SHIFT)\n\n\tCfg9346\t\t= 0x50,\n\tConfig0\t\t= 0x51,\n\tConfig1\t\t= 0x52,\n\tConfig2\t\t= 0x53,\n#define PME_SIGNAL\t\t\t(1 << 5)\t \n\n\tConfig3\t\t= 0x54,\n\tConfig4\t\t= 0x55,\n\tConfig5\t\t= 0x56,\n\tPHYAR\t\t= 0x60,\n\tPHYstatus\t= 0x6c,\n\tRxMaxSize\t= 0xda,\n\tCPlusCmd\t= 0xe0,\n\tIntrMitigate\t= 0xe2,\n\n#define RTL_COALESCE_TX_USECS\tGENMASK(15, 12)\n#define RTL_COALESCE_TX_FRAMES\tGENMASK(11, 8)\n#define RTL_COALESCE_RX_USECS\tGENMASK(7, 4)\n#define RTL_COALESCE_RX_FRAMES\tGENMASK(3, 0)\n\n#define RTL_COALESCE_T_MAX\t0x0fU\n#define RTL_COALESCE_FRAME_MAX\t(RTL_COALESCE_T_MAX * 4)\n\n\tRxDescAddrLow\t= 0xe4,\n\tRxDescAddrHigh\t= 0xe8,\n\tEarlyTxThres\t= 0xec,\t \n\n#define NoEarlyTx\t0x3f\t \n\n\tMaxTxPacketSize\t= 0xec,\t \n\n#define TxPacketMax\t(8064 >> 7)\n#define EarlySize\t0x27\n\n\tFuncEvent\t= 0xf0,\n\tFuncEventMask\t= 0xf4,\n\tFuncPresetState\t= 0xf8,\n\tIBCR0           = 0xf8,\n\tIBCR2           = 0xf9,\n\tIBIMR0          = 0xfa,\n\tIBISR0          = 0xfb,\n\tFuncForceEvent\t= 0xfc,\n};\n\nenum rtl8168_8101_registers {\n\tCSIDR\t\t\t= 0x64,\n\tCSIAR\t\t\t= 0x68,\n#define\tCSIAR_FLAG\t\t\t0x80000000\n#define\tCSIAR_WRITE_CMD\t\t\t0x80000000\n#define\tCSIAR_BYTE_ENABLE\t\t0x0000f000\n#define\tCSIAR_ADDR_MASK\t\t\t0x00000fff\n\tPMCH\t\t\t= 0x6f,\n#define D3COLD_NO_PLL_DOWN\t\tBIT(7)\n#define D3HOT_NO_PLL_DOWN\t\tBIT(6)\n#define D3_NO_PLL_DOWN\t\t\t(BIT(7) | BIT(6))\n\tEPHYAR\t\t\t= 0x80,\n#define\tEPHYAR_FLAG\t\t\t0x80000000\n#define\tEPHYAR_WRITE_CMD\t\t0x80000000\n#define\tEPHYAR_REG_MASK\t\t\t0x1f\n#define\tEPHYAR_REG_SHIFT\t\t16\n#define\tEPHYAR_DATA_MASK\t\t0xffff\n\tDLLPR\t\t\t= 0xd0,\n#define\tPFM_EN\t\t\t\t(1 << 6)\n#define\tTX_10M_PS_EN\t\t\t(1 << 7)\n\tDBG_REG\t\t\t= 0xd1,\n#define\tFIX_NAK_1\t\t\t(1 << 4)\n#define\tFIX_NAK_2\t\t\t(1 << 3)\n\tTWSI\t\t\t= 0xd2,\n\tMCU\t\t\t= 0xd3,\n#define\tNOW_IS_OOB\t\t\t(1 << 7)\n#define\tTX_EMPTY\t\t\t(1 << 5)\n#define\tRX_EMPTY\t\t\t(1 << 4)\n#define\tRXTX_EMPTY\t\t\t(TX_EMPTY | RX_EMPTY)\n#define\tEN_NDP\t\t\t\t(1 << 3)\n#define\tEN_OOB_RESET\t\t\t(1 << 2)\n#define\tLINK_LIST_RDY\t\t\t(1 << 1)\n\tEFUSEAR\t\t\t= 0xdc,\n#define\tEFUSEAR_FLAG\t\t\t0x80000000\n#define\tEFUSEAR_WRITE_CMD\t\t0x80000000\n#define\tEFUSEAR_READ_CMD\t\t0x00000000\n#define\tEFUSEAR_REG_MASK\t\t0x03ff\n#define\tEFUSEAR_REG_SHIFT\t\t8\n#define\tEFUSEAR_DATA_MASK\t\t0xff\n\tMISC_1\t\t\t= 0xf2,\n#define\tPFM_D3COLD_EN\t\t\t(1 << 6)\n};\n\nenum rtl8168_registers {\n\tLED_FREQ\t\t= 0x1a,\n\tEEE_LED\t\t\t= 0x1b,\n\tERIDR\t\t\t= 0x70,\n\tERIAR\t\t\t= 0x74,\n#define ERIAR_FLAG\t\t\t0x80000000\n#define ERIAR_WRITE_CMD\t\t\t0x80000000\n#define ERIAR_READ_CMD\t\t\t0x00000000\n#define ERIAR_ADDR_BYTE_ALIGN\t\t4\n#define ERIAR_TYPE_SHIFT\t\t16\n#define ERIAR_EXGMAC\t\t\t(0x00 << ERIAR_TYPE_SHIFT)\n#define ERIAR_MSIX\t\t\t(0x01 << ERIAR_TYPE_SHIFT)\n#define ERIAR_ASF\t\t\t(0x02 << ERIAR_TYPE_SHIFT)\n#define ERIAR_OOB\t\t\t(0x02 << ERIAR_TYPE_SHIFT)\n#define ERIAR_MASK_SHIFT\t\t12\n#define ERIAR_MASK_0001\t\t\t(0x1 << ERIAR_MASK_SHIFT)\n#define ERIAR_MASK_0011\t\t\t(0x3 << ERIAR_MASK_SHIFT)\n#define ERIAR_MASK_0100\t\t\t(0x4 << ERIAR_MASK_SHIFT)\n#define ERIAR_MASK_0101\t\t\t(0x5 << ERIAR_MASK_SHIFT)\n#define ERIAR_MASK_1111\t\t\t(0xf << ERIAR_MASK_SHIFT)\n\tEPHY_RXER_NUM\t\t= 0x7c,\n\tOCPDR\t\t\t= 0xb0,\t \n#define OCPDR_WRITE_CMD\t\t\t0x80000000\n#define OCPDR_READ_CMD\t\t\t0x00000000\n#define OCPDR_REG_MASK\t\t\t0x7f\n#define OCPDR_GPHY_REG_SHIFT\t\t16\n#define OCPDR_DATA_MASK\t\t\t0xffff\n\tOCPAR\t\t\t= 0xb4,\n#define OCPAR_FLAG\t\t\t0x80000000\n#define OCPAR_GPHY_WRITE_CMD\t\t0x8000f060\n#define OCPAR_GPHY_READ_CMD\t\t0x0000f060\n\tGPHY_OCP\t\t= 0xb8,\n\tRDSAR1\t\t\t= 0xd0,\t \n\tMISC\t\t\t= 0xf0,\t \n#define TXPLA_RST\t\t\t(1 << 29)\n#define DISABLE_LAN_EN\t\t\t(1 << 23)  \n#define PWM_EN\t\t\t\t(1 << 22)\n#define RXDV_GATED_EN\t\t\t(1 << 19)\n#define EARLY_TALLY_EN\t\t\t(1 << 16)\n};\n\nenum rtl8125_registers {\n\tIntrMask_8125\t\t= 0x38,\n\tIntrStatus_8125\t\t= 0x3c,\n\tTxPoll_8125\t\t= 0x90,\n\tMAC0_BKP\t\t= 0x19e0,\n\tEEE_TXIDLE_TIMER_8125\t= 0x6048,\n};\n\n#define RX_VLAN_INNER_8125\tBIT(22)\n#define RX_VLAN_OUTER_8125\tBIT(23)\n#define RX_VLAN_8125\t\t(RX_VLAN_INNER_8125 | RX_VLAN_OUTER_8125)\n\n#define RX_FETCH_DFLT_8125\t(8 << 27)\n\nenum rtl_register_content {\n\t \n\tSYSErr\t\t= 0x8000,\n\tPCSTimeout\t= 0x4000,\n\tSWInt\t\t= 0x0100,\n\tTxDescUnavail\t= 0x0080,\n\tRxFIFOOver\t= 0x0040,\n\tLinkChg\t\t= 0x0020,\n\tRxOverflow\t= 0x0010,\n\tTxErr\t\t= 0x0008,\n\tTxOK\t\t= 0x0004,\n\tRxErr\t\t= 0x0002,\n\tRxOK\t\t= 0x0001,\n\n\t \n\tRxRWT\t= (1 << 22),\n\tRxRES\t= (1 << 21),\n\tRxRUNT\t= (1 << 20),\n\tRxCRC\t= (1 << 19),\n\n\t \n\tStopReq\t\t= 0x80,\n\tCmdReset\t= 0x10,\n\tCmdRxEnb\t= 0x08,\n\tCmdTxEnb\t= 0x04,\n\tRxBufEmpty\t= 0x01,\n\n\t \n\tHPQ\t\t= 0x80,\t\t \n\tNPQ\t\t= 0x40,\t\t \n\tFSWInt\t\t= 0x01,\t\t \n\n\t \n\tCfg9346_Lock\t= 0x00,\n\tCfg9346_Unlock\t= 0xc0,\n\n\t \n\tAcceptErr\t= 0x20,\n\tAcceptRunt\t= 0x10,\n#define RX_CONFIG_ACCEPT_ERR_MASK\t0x30\n\tAcceptBroadcast\t= 0x08,\n\tAcceptMulticast\t= 0x04,\n\tAcceptMyPhys\t= 0x02,\n\tAcceptAllPhys\t= 0x01,\n#define RX_CONFIG_ACCEPT_OK_MASK\t0x0f\n#define RX_CONFIG_ACCEPT_MASK\t\t0x3f\n\n\t \n\tTxInterFrameGapShift = 24,\n\tTxDMAShift = 8,\t \n\n\t \n\tLEDS1\t\t= (1 << 7),\n\tLEDS0\t\t= (1 << 6),\n\tSpeed_down\t= (1 << 4),\n\tMEMMAP\t\t= (1 << 3),\n\tIOMAP\t\t= (1 << 2),\n\tVPD\t\t= (1 << 1),\n\tPMEnable\t= (1 << 0),\t \n\n\t \n\tClkReqEn\t= (1 << 7),\t \n\tMSIEnable\t= (1 << 5),\t \n\tPCI_Clock_66MHz = 0x01,\n\tPCI_Clock_33MHz = 0x00,\n\n\t \n\tMagicPacket\t= (1 << 5),\t \n\tLinkUp\t\t= (1 << 4),\t \n\tJumbo_En0\t= (1 << 2),\t \n\tRdy_to_L23\t= (1 << 1),\t \n\tBeacon_en\t= (1 << 0),\t \n\n\t \n\tJumbo_En1\t= (1 << 1),\t \n\n\t \n\tBWF\t\t= (1 << 6),\t \n\tMWF\t\t= (1 << 5),\t \n\tUWF\t\t= (1 << 4),\t \n\tSpi_en\t\t= (1 << 3),\n\tLanWake\t\t= (1 << 1),\t \n\tPMEStatus\t= (1 << 0),\t \n\tASPM_en\t\t= (1 << 0),\t \n\n\t \n\tEnableBist\t= (1 << 15),\t\n\tMac_dbgo_oe\t= (1 << 14),\t\n\tEnAnaPLL\t= (1 << 14),\t\n\tNormal_mode\t= (1 << 13),\t\n\tForce_half_dup\t= (1 << 12),\t\n\tForce_rxflow_en\t= (1 << 11),\t\n\tForce_txflow_en\t= (1 << 10),\t\n\tCxpl_dbg_sel\t= (1 << 9),\t\n\tASF\t\t= (1 << 8),\t\n\tPktCntrDisable\t= (1 << 7),\t\n\tMac_dbgo_sel\t= 0x001c,\t\n\tRxVlan\t\t= (1 << 6),\n\tRxChkSum\t= (1 << 5),\n\tPCIDAC\t\t= (1 << 4),\n\tPCIMulRW\t= (1 << 3),\n#define INTT_MASK\tGENMASK(1, 0)\n#define CPCMD_MASK\t(Normal_mode | RxVlan | RxChkSum | INTT_MASK)\n\n\t \n\tTBI_Enable\t= 0x80,\n\tTxFlowCtrl\t= 0x40,\n\tRxFlowCtrl\t= 0x20,\n\t_1000bpsF\t= 0x10,\n\t_100bps\t\t= 0x08,\n\t_10bps\t\t= 0x04,\n\tLinkStatus\t= 0x02,\n\tFullDup\t\t= 0x01,\n\n\t \n\tCounterReset\t= 0x1,\n\n\t \n\tCounterDump\t= 0x8,\n\n\t \n\tMagicPacket_v2\t= (1 << 16),\t \n};\n\nenum rtl_desc_bit {\n\t \n\tDescOwn\t\t= (1 << 31),  \n\tRingEnd\t\t= (1 << 30),  \n\tFirstFrag\t= (1 << 29),  \n\tLastFrag\t= (1 << 28),  \n};\n\n \nenum rtl_tx_desc_bit {\n\t \n\tTD_LSO\t\t= (1 << 27),\t\t \n#define TD_MSS_MAX\t\t\t0x07ffu\t \n\n\t \n\tTxVlanTag\t= (1 << 17),\t\t \n};\n\n \nenum rtl_tx_desc_bit_0 {\n\t \n#define TD0_MSS_SHIFT\t\t\t16\t \n\tTD0_TCP_CS\t= (1 << 16),\t\t \n\tTD0_UDP_CS\t= (1 << 17),\t\t \n\tTD0_IP_CS\t= (1 << 18),\t\t \n};\n\n \nenum rtl_tx_desc_bit_1 {\n\t \n\tTD1_GTSENV4\t= (1 << 26),\t\t \n\tTD1_GTSENV6\t= (1 << 25),\t\t \n#define GTTCPHO_SHIFT\t\t\t18\n#define GTTCPHO_MAX\t\t\t0x7f\n\n\t \n#define TCPHO_SHIFT\t\t\t18\n#define TCPHO_MAX\t\t\t0x3ff\n#define TD1_MSS_SHIFT\t\t\t18\t \n\tTD1_IPv6_CS\t= (1 << 28),\t\t \n\tTD1_IPv4_CS\t= (1 << 29),\t\t \n\tTD1_TCP_CS\t= (1 << 30),\t\t \n\tTD1_UDP_CS\t= (1 << 31),\t\t \n};\n\nenum rtl_rx_desc_bit {\n\t \n\tPID1\t\t= (1 << 18),  \n\tPID0\t\t= (1 << 17),  \n\n#define RxProtoUDP\t(PID1)\n#define RxProtoTCP\t(PID0)\n#define RxProtoIP\t(PID1 | PID0)\n#define RxProtoMask\tRxProtoIP\n\n\tIPFail\t\t= (1 << 16),  \n\tUDPFail\t\t= (1 << 15),  \n\tTCPFail\t\t= (1 << 14),  \n\n#define RxCSFailMask\t(IPFail | UDPFail | TCPFail)\n\n\tRxVlanTag\t= (1 << 16),  \n};\n\n#define RTL_GSO_MAX_SIZE_V1\t32000\n#define RTL_GSO_MAX_SEGS_V1\t24\n#define RTL_GSO_MAX_SIZE_V2\t64000\n#define RTL_GSO_MAX_SEGS_V2\t64\n\nstruct TxDesc {\n\t__le32 opts1;\n\t__le32 opts2;\n\t__le64 addr;\n};\n\nstruct RxDesc {\n\t__le32 opts1;\n\t__le32 opts2;\n\t__le64 addr;\n};\n\nstruct ring_info {\n\tstruct sk_buff\t*skb;\n\tu32\t\tlen;\n};\n\nstruct rtl8169_counters {\n\t__le64\ttx_packets;\n\t__le64\trx_packets;\n\t__le64\ttx_errors;\n\t__le32\trx_errors;\n\t__le16\trx_missed;\n\t__le16\talign_errors;\n\t__le32\ttx_one_collision;\n\t__le32\ttx_multi_collision;\n\t__le64\trx_unicast;\n\t__le64\trx_broadcast;\n\t__le32\trx_multicast;\n\t__le16\ttx_aborted;\n\t__le16\ttx_underun;\n};\n\nstruct rtl8169_tc_offsets {\n\tbool\tinited;\n\t__le64\ttx_errors;\n\t__le32\ttx_multi_collision;\n\t__le16\ttx_aborted;\n\t__le16\trx_missed;\n};\n\nenum rtl_flag {\n\tRTL_FLAG_TASK_ENABLED = 0,\n\tRTL_FLAG_TASK_RESET_PENDING,\n\tRTL_FLAG_TASK_RESET_NO_QUEUE_WAKE,\n\tRTL_FLAG_TASK_TX_TIMEOUT,\n\tRTL_FLAG_MAX\n};\n\nenum rtl_dash_type {\n\tRTL_DASH_NONE,\n\tRTL_DASH_DP,\n\tRTL_DASH_EP,\n};\n\nstruct rtl8169_private {\n\tvoid __iomem *mmio_addr;\t \n\tstruct pci_dev *pci_dev;\n\tstruct net_device *dev;\n\tstruct phy_device *phydev;\n\tstruct napi_struct napi;\n\tenum mac_version mac_version;\n\tenum rtl_dash_type dash_type;\n\tu32 cur_rx;  \n\tu32 cur_tx;  \n\tu32 dirty_tx;\n\tstruct TxDesc *TxDescArray;\t \n\tstruct RxDesc *RxDescArray;\t \n\tdma_addr_t TxPhyAddr;\n\tdma_addr_t RxPhyAddr;\n\tstruct page *Rx_databuff[NUM_RX_DESC];\t \n\tstruct ring_info tx_skb[NUM_TX_DESC];\t \n\tu16 cp_cmd;\n\tu32 irq_mask;\n\tint irq;\n\tstruct clk *clk;\n\n\tstruct {\n\t\tDECLARE_BITMAP(flags, RTL_FLAG_MAX);\n\t\tstruct work_struct work;\n\t} wk;\n\n\traw_spinlock_t config25_lock;\n\traw_spinlock_t mac_ocp_lock;\n\n\traw_spinlock_t cfg9346_usage_lock;\n\tint cfg9346_usage_count;\n\n\tunsigned supports_gmii:1;\n\tunsigned aspm_manageable:1;\n\tunsigned dash_enabled:1;\n\tdma_addr_t counters_phys_addr;\n\tstruct rtl8169_counters *counters;\n\tstruct rtl8169_tc_offsets tc_offset;\n\tu32 saved_wolopts;\n\tint eee_adv;\n\n\tconst char *fw_name;\n\tstruct rtl_fw *rtl_fw;\n\n\tu32 ocp_base;\n};\n\ntypedef void (*rtl_generic_fct)(struct rtl8169_private *tp);\n\nMODULE_AUTHOR(\"Realtek and the Linux r8169 crew <netdev@vger.kernel.org>\");\nMODULE_DESCRIPTION(\"RealTek RTL-8169 Gigabit Ethernet driver\");\nMODULE_SOFTDEP(\"pre: realtek\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FIRMWARE_8168D_1);\nMODULE_FIRMWARE(FIRMWARE_8168D_2);\nMODULE_FIRMWARE(FIRMWARE_8168E_1);\nMODULE_FIRMWARE(FIRMWARE_8168E_2);\nMODULE_FIRMWARE(FIRMWARE_8168E_3);\nMODULE_FIRMWARE(FIRMWARE_8105E_1);\nMODULE_FIRMWARE(FIRMWARE_8168F_1);\nMODULE_FIRMWARE(FIRMWARE_8168F_2);\nMODULE_FIRMWARE(FIRMWARE_8402_1);\nMODULE_FIRMWARE(FIRMWARE_8411_1);\nMODULE_FIRMWARE(FIRMWARE_8411_2);\nMODULE_FIRMWARE(FIRMWARE_8106E_1);\nMODULE_FIRMWARE(FIRMWARE_8106E_2);\nMODULE_FIRMWARE(FIRMWARE_8168G_2);\nMODULE_FIRMWARE(FIRMWARE_8168G_3);\nMODULE_FIRMWARE(FIRMWARE_8168H_2);\nMODULE_FIRMWARE(FIRMWARE_8168FP_3);\nMODULE_FIRMWARE(FIRMWARE_8107E_2);\nMODULE_FIRMWARE(FIRMWARE_8125A_3);\nMODULE_FIRMWARE(FIRMWARE_8125B_2);\n\nstatic inline struct device *tp_to_dev(struct rtl8169_private *tp)\n{\n\treturn &tp->pci_dev->dev;\n}\n\nstatic void rtl_lock_config_regs(struct rtl8169_private *tp)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tp->cfg9346_usage_lock, flags);\n\tif (!--tp->cfg9346_usage_count)\n\t\tRTL_W8(tp, Cfg9346, Cfg9346_Lock);\n\traw_spin_unlock_irqrestore(&tp->cfg9346_usage_lock, flags);\n}\n\nstatic void rtl_unlock_config_regs(struct rtl8169_private *tp)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tp->cfg9346_usage_lock, flags);\n\tif (!tp->cfg9346_usage_count++)\n\t\tRTL_W8(tp, Cfg9346, Cfg9346_Unlock);\n\traw_spin_unlock_irqrestore(&tp->cfg9346_usage_lock, flags);\n}\n\nstatic void rtl_pci_commit(struct rtl8169_private *tp)\n{\n\t \n\tRTL_R8(tp, ChipCmd);\n}\n\nstatic void rtl_mod_config2(struct rtl8169_private *tp, u8 clear, u8 set)\n{\n\tunsigned long flags;\n\tu8 val;\n\n\traw_spin_lock_irqsave(&tp->config25_lock, flags);\n\tval = RTL_R8(tp, Config2);\n\tRTL_W8(tp, Config2, (val & ~clear) | set);\n\traw_spin_unlock_irqrestore(&tp->config25_lock, flags);\n}\n\nstatic void rtl_mod_config5(struct rtl8169_private *tp, u8 clear, u8 set)\n{\n\tunsigned long flags;\n\tu8 val;\n\n\traw_spin_lock_irqsave(&tp->config25_lock, flags);\n\tval = RTL_R8(tp, Config5);\n\tRTL_W8(tp, Config5, (val & ~clear) | set);\n\traw_spin_unlock_irqrestore(&tp->config25_lock, flags);\n}\n\nstatic bool rtl_is_8125(struct rtl8169_private *tp)\n{\n\treturn tp->mac_version >= RTL_GIGA_MAC_VER_61;\n}\n\nstatic bool rtl_is_8168evl_up(struct rtl8169_private *tp)\n{\n\treturn tp->mac_version >= RTL_GIGA_MAC_VER_34 &&\n\t       tp->mac_version != RTL_GIGA_MAC_VER_39 &&\n\t       tp->mac_version <= RTL_GIGA_MAC_VER_53;\n}\n\nstatic bool rtl_supports_eee(struct rtl8169_private *tp)\n{\n\treturn tp->mac_version >= RTL_GIGA_MAC_VER_34 &&\n\t       tp->mac_version != RTL_GIGA_MAC_VER_37 &&\n\t       tp->mac_version != RTL_GIGA_MAC_VER_39;\n}\n\nstatic void rtl_read_mac_from_reg(struct rtl8169_private *tp, u8 *mac, int reg)\n{\n\tint i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tmac[i] = RTL_R8(tp, reg + i);\n}\n\nstruct rtl_cond {\n\tbool (*check)(struct rtl8169_private *);\n\tconst char *msg;\n};\n\nstatic bool rtl_loop_wait(struct rtl8169_private *tp, const struct rtl_cond *c,\n\t\t\t  unsigned long usecs, int n, bool high)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (c->check(tp) == high)\n\t\t\treturn true;\n\t\tfsleep(usecs);\n\t}\n\n\tif (net_ratelimit())\n\t\tnetdev_err(tp->dev, \"%s == %d (loop: %d, delay: %lu).\\n\",\n\t\t\t   c->msg, !high, n, usecs);\n\treturn false;\n}\n\nstatic bool rtl_loop_wait_high(struct rtl8169_private *tp,\n\t\t\t       const struct rtl_cond *c,\n\t\t\t       unsigned long d, int n)\n{\n\treturn rtl_loop_wait(tp, c, d, n, true);\n}\n\nstatic bool rtl_loop_wait_low(struct rtl8169_private *tp,\n\t\t\t      const struct rtl_cond *c,\n\t\t\t      unsigned long d, int n)\n{\n\treturn rtl_loop_wait(tp, c, d, n, false);\n}\n\n#define DECLARE_RTL_COND(name)\t\t\t\t\\\nstatic bool name ## _check(struct rtl8169_private *);\t\\\n\t\t\t\t\t\t\t\\\nstatic const struct rtl_cond name = {\t\t\t\\\n\t.check\t= name ## _check,\t\t\t\\\n\t.msg\t= #name\t\t\t\t\t\\\n};\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\\\nstatic bool name ## _check(struct rtl8169_private *tp)\n\nstatic void r8168fp_adjust_ocp_cmd(struct rtl8169_private *tp, u32 *cmd, int type)\n{\n\t \n\tif (type == ERIAR_OOB &&\n\t    (tp->mac_version == RTL_GIGA_MAC_VER_52 ||\n\t     tp->mac_version == RTL_GIGA_MAC_VER_53))\n\t\t*cmd |= 0xf70 << 18;\n}\n\nDECLARE_RTL_COND(rtl_eriar_cond)\n{\n\treturn RTL_R32(tp, ERIAR) & ERIAR_FLAG;\n}\n\nstatic void _rtl_eri_write(struct rtl8169_private *tp, int addr, u32 mask,\n\t\t\t   u32 val, int type)\n{\n\tu32 cmd = ERIAR_WRITE_CMD | type | mask | addr;\n\n\tif (WARN(addr & 3 || !mask, \"addr: 0x%x, mask: 0x%08x\\n\", addr, mask))\n\t\treturn;\n\n\tRTL_W32(tp, ERIDR, val);\n\tr8168fp_adjust_ocp_cmd(tp, &cmd, type);\n\tRTL_W32(tp, ERIAR, cmd);\n\n\trtl_loop_wait_low(tp, &rtl_eriar_cond, 100, 100);\n}\n\nstatic void rtl_eri_write(struct rtl8169_private *tp, int addr, u32 mask,\n\t\t\t  u32 val)\n{\n\t_rtl_eri_write(tp, addr, mask, val, ERIAR_EXGMAC);\n}\n\nstatic u32 _rtl_eri_read(struct rtl8169_private *tp, int addr, int type)\n{\n\tu32 cmd = ERIAR_READ_CMD | type | ERIAR_MASK_1111 | addr;\n\n\tr8168fp_adjust_ocp_cmd(tp, &cmd, type);\n\tRTL_W32(tp, ERIAR, cmd);\n\n\treturn rtl_loop_wait_high(tp, &rtl_eriar_cond, 100, 100) ?\n\t\tRTL_R32(tp, ERIDR) : ~0;\n}\n\nstatic u32 rtl_eri_read(struct rtl8169_private *tp, int addr)\n{\n\treturn _rtl_eri_read(tp, addr, ERIAR_EXGMAC);\n}\n\nstatic void rtl_w0w1_eri(struct rtl8169_private *tp, int addr, u32 p, u32 m)\n{\n\tu32 val = rtl_eri_read(tp, addr);\n\n\trtl_eri_write(tp, addr, ERIAR_MASK_1111, (val & ~m) | p);\n}\n\nstatic void rtl_eri_set_bits(struct rtl8169_private *tp, int addr, u32 p)\n{\n\trtl_w0w1_eri(tp, addr, p, 0);\n}\n\nstatic void rtl_eri_clear_bits(struct rtl8169_private *tp, int addr, u32 m)\n{\n\trtl_w0w1_eri(tp, addr, 0, m);\n}\n\nstatic bool rtl_ocp_reg_failure(u32 reg)\n{\n\treturn WARN_ONCE(reg & 0xffff0001, \"Invalid ocp reg %x!\\n\", reg);\n}\n\nDECLARE_RTL_COND(rtl_ocp_gphy_cond)\n{\n\treturn RTL_R32(tp, GPHY_OCP) & OCPAR_FLAG;\n}\n\nstatic void r8168_phy_ocp_write(struct rtl8169_private *tp, u32 reg, u32 data)\n{\n\tif (rtl_ocp_reg_failure(reg))\n\t\treturn;\n\n\tRTL_W32(tp, GPHY_OCP, OCPAR_FLAG | (reg << 15) | data);\n\n\trtl_loop_wait_low(tp, &rtl_ocp_gphy_cond, 25, 10);\n}\n\nstatic int r8168_phy_ocp_read(struct rtl8169_private *tp, u32 reg)\n{\n\tif (rtl_ocp_reg_failure(reg))\n\t\treturn 0;\n\n\tRTL_W32(tp, GPHY_OCP, reg << 15);\n\n\treturn rtl_loop_wait_high(tp, &rtl_ocp_gphy_cond, 25, 10) ?\n\t\t(RTL_R32(tp, GPHY_OCP) & 0xffff) : -ETIMEDOUT;\n}\n\nstatic void __r8168_mac_ocp_write(struct rtl8169_private *tp, u32 reg, u32 data)\n{\n\tif (rtl_ocp_reg_failure(reg))\n\t\treturn;\n\n\tRTL_W32(tp, OCPDR, OCPAR_FLAG | (reg << 15) | data);\n}\n\nstatic void r8168_mac_ocp_write(struct rtl8169_private *tp, u32 reg, u32 data)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tp->mac_ocp_lock, flags);\n\t__r8168_mac_ocp_write(tp, reg, data);\n\traw_spin_unlock_irqrestore(&tp->mac_ocp_lock, flags);\n}\n\nstatic u16 __r8168_mac_ocp_read(struct rtl8169_private *tp, u32 reg)\n{\n\tif (rtl_ocp_reg_failure(reg))\n\t\treturn 0;\n\n\tRTL_W32(tp, OCPDR, reg << 15);\n\n\treturn RTL_R32(tp, OCPDR);\n}\n\nstatic u16 r8168_mac_ocp_read(struct rtl8169_private *tp, u32 reg)\n{\n\tunsigned long flags;\n\tu16 val;\n\n\traw_spin_lock_irqsave(&tp->mac_ocp_lock, flags);\n\tval = __r8168_mac_ocp_read(tp, reg);\n\traw_spin_unlock_irqrestore(&tp->mac_ocp_lock, flags);\n\n\treturn val;\n}\n\nstatic void r8168_mac_ocp_modify(struct rtl8169_private *tp, u32 reg, u16 mask,\n\t\t\t\t u16 set)\n{\n\tunsigned long flags;\n\tu16 data;\n\n\traw_spin_lock_irqsave(&tp->mac_ocp_lock, flags);\n\tdata = __r8168_mac_ocp_read(tp, reg);\n\t__r8168_mac_ocp_write(tp, reg, (data & ~mask) | set);\n\traw_spin_unlock_irqrestore(&tp->mac_ocp_lock, flags);\n}\n\n \nstatic void rtl8168g_phy_suspend_quirk(struct rtl8169_private *tp, int value)\n{\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_40:\n\t\tif (value & BMCR_RESET || !(value & BMCR_PDOWN))\n\t\t\trtl_eri_set_bits(tp, 0x1a8, 0xfc000000);\n\t\telse\n\t\t\trtl_eri_clear_bits(tp, 0x1a8, 0xfc000000);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n};\n\nstatic void r8168g_mdio_write(struct rtl8169_private *tp, int reg, int value)\n{\n\tif (reg == 0x1f) {\n\t\ttp->ocp_base = value ? value << 4 : OCP_STD_PHY_BASE;\n\t\treturn;\n\t}\n\n\tif (tp->ocp_base != OCP_STD_PHY_BASE)\n\t\treg -= 0x10;\n\n\tif (tp->ocp_base == OCP_STD_PHY_BASE && reg == MII_BMCR)\n\t\trtl8168g_phy_suspend_quirk(tp, value);\n\n\tr8168_phy_ocp_write(tp, tp->ocp_base + reg * 2, value);\n}\n\nstatic int r8168g_mdio_read(struct rtl8169_private *tp, int reg)\n{\n\tif (reg == 0x1f)\n\t\treturn tp->ocp_base == OCP_STD_PHY_BASE ? 0 : tp->ocp_base >> 4;\n\n\tif (tp->ocp_base != OCP_STD_PHY_BASE)\n\t\treg -= 0x10;\n\n\treturn r8168_phy_ocp_read(tp, tp->ocp_base + reg * 2);\n}\n\nstatic void mac_mcu_write(struct rtl8169_private *tp, int reg, int value)\n{\n\tif (reg == 0x1f) {\n\t\ttp->ocp_base = value << 4;\n\t\treturn;\n\t}\n\n\tr8168_mac_ocp_write(tp, tp->ocp_base + reg, value);\n}\n\nstatic int mac_mcu_read(struct rtl8169_private *tp, int reg)\n{\n\treturn r8168_mac_ocp_read(tp, tp->ocp_base + reg);\n}\n\nDECLARE_RTL_COND(rtl_phyar_cond)\n{\n\treturn RTL_R32(tp, PHYAR) & 0x80000000;\n}\n\nstatic void r8169_mdio_write(struct rtl8169_private *tp, int reg, int value)\n{\n\tRTL_W32(tp, PHYAR, 0x80000000 | (reg & 0x1f) << 16 | (value & 0xffff));\n\n\trtl_loop_wait_low(tp, &rtl_phyar_cond, 25, 20);\n\t \n\tudelay(20);\n}\n\nstatic int r8169_mdio_read(struct rtl8169_private *tp, int reg)\n{\n\tint value;\n\n\tRTL_W32(tp, PHYAR, 0x0 | (reg & 0x1f) << 16);\n\n\tvalue = rtl_loop_wait_high(tp, &rtl_phyar_cond, 25, 20) ?\n\t\tRTL_R32(tp, PHYAR) & 0xffff : -ETIMEDOUT;\n\n\t \n\tudelay(20);\n\n\treturn value;\n}\n\nDECLARE_RTL_COND(rtl_ocpar_cond)\n{\n\treturn RTL_R32(tp, OCPAR) & OCPAR_FLAG;\n}\n\n#define R8168DP_1_MDIO_ACCESS_BIT\t0x00020000\n\nstatic void r8168dp_2_mdio_start(struct rtl8169_private *tp)\n{\n\tRTL_W32(tp, 0xd0, RTL_R32(tp, 0xd0) & ~R8168DP_1_MDIO_ACCESS_BIT);\n}\n\nstatic void r8168dp_2_mdio_stop(struct rtl8169_private *tp)\n{\n\tRTL_W32(tp, 0xd0, RTL_R32(tp, 0xd0) | R8168DP_1_MDIO_ACCESS_BIT);\n}\n\nstatic void r8168dp_2_mdio_write(struct rtl8169_private *tp, int reg, int value)\n{\n\tr8168dp_2_mdio_start(tp);\n\n\tr8169_mdio_write(tp, reg, value);\n\n\tr8168dp_2_mdio_stop(tp);\n}\n\nstatic int r8168dp_2_mdio_read(struct rtl8169_private *tp, int reg)\n{\n\tint value;\n\n\t \n\tif (reg == MII_PHYSID2)\n\t\treturn 0xc912;\n\n\tr8168dp_2_mdio_start(tp);\n\n\tvalue = r8169_mdio_read(tp, reg);\n\n\tr8168dp_2_mdio_stop(tp);\n\n\treturn value;\n}\n\nstatic void rtl_writephy(struct rtl8169_private *tp, int location, int val)\n{\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_28:\n\tcase RTL_GIGA_MAC_VER_31:\n\t\tr8168dp_2_mdio_write(tp, location, val);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_63:\n\t\tr8168g_mdio_write(tp, location, val);\n\t\tbreak;\n\tdefault:\n\t\tr8169_mdio_write(tp, location, val);\n\t\tbreak;\n\t}\n}\n\nstatic int rtl_readphy(struct rtl8169_private *tp, int location)\n{\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_28:\n\tcase RTL_GIGA_MAC_VER_31:\n\t\treturn r8168dp_2_mdio_read(tp, location);\n\tcase RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_63:\n\t\treturn r8168g_mdio_read(tp, location);\n\tdefault:\n\t\treturn r8169_mdio_read(tp, location);\n\t}\n}\n\nDECLARE_RTL_COND(rtl_ephyar_cond)\n{\n\treturn RTL_R32(tp, EPHYAR) & EPHYAR_FLAG;\n}\n\nstatic void rtl_ephy_write(struct rtl8169_private *tp, int reg_addr, int value)\n{\n\tRTL_W32(tp, EPHYAR, EPHYAR_WRITE_CMD | (value & EPHYAR_DATA_MASK) |\n\t\t(reg_addr & EPHYAR_REG_MASK) << EPHYAR_REG_SHIFT);\n\n\trtl_loop_wait_low(tp, &rtl_ephyar_cond, 10, 100);\n\n\tudelay(10);\n}\n\nstatic u16 rtl_ephy_read(struct rtl8169_private *tp, int reg_addr)\n{\n\tRTL_W32(tp, EPHYAR, (reg_addr & EPHYAR_REG_MASK) << EPHYAR_REG_SHIFT);\n\n\treturn rtl_loop_wait_high(tp, &rtl_ephyar_cond, 10, 100) ?\n\t\tRTL_R32(tp, EPHYAR) & EPHYAR_DATA_MASK : ~0;\n}\n\nstatic u32 r8168dp_ocp_read(struct rtl8169_private *tp, u16 reg)\n{\n\tRTL_W32(tp, OCPAR, 0x0fu << 12 | (reg & 0x0fff));\n\treturn rtl_loop_wait_high(tp, &rtl_ocpar_cond, 100, 20) ?\n\t\tRTL_R32(tp, OCPDR) : ~0;\n}\n\nstatic u32 r8168ep_ocp_read(struct rtl8169_private *tp, u16 reg)\n{\n\treturn _rtl_eri_read(tp, reg, ERIAR_OOB);\n}\n\nstatic void r8168dp_ocp_write(struct rtl8169_private *tp, u8 mask, u16 reg,\n\t\t\t      u32 data)\n{\n\tRTL_W32(tp, OCPDR, data);\n\tRTL_W32(tp, OCPAR, OCPAR_FLAG | ((u32)mask & 0x0f) << 12 | (reg & 0x0fff));\n\trtl_loop_wait_low(tp, &rtl_ocpar_cond, 100, 20);\n}\n\nstatic void r8168ep_ocp_write(struct rtl8169_private *tp, u8 mask, u16 reg,\n\t\t\t      u32 data)\n{\n\t_rtl_eri_write(tp, reg, ((u32)mask & 0x0f) << ERIAR_MASK_SHIFT,\n\t\t       data, ERIAR_OOB);\n}\n\nstatic void r8168dp_oob_notify(struct rtl8169_private *tp, u8 cmd)\n{\n\trtl_eri_write(tp, 0xe8, ERIAR_MASK_0001, cmd);\n\n\tr8168dp_ocp_write(tp, 0x1, 0x30, 0x00000001);\n}\n\n#define OOB_CMD_RESET\t\t0x00\n#define OOB_CMD_DRIVER_START\t0x05\n#define OOB_CMD_DRIVER_STOP\t0x06\n\nstatic u16 rtl8168_get_ocp_reg(struct rtl8169_private *tp)\n{\n\treturn (tp->mac_version == RTL_GIGA_MAC_VER_31) ? 0xb8 : 0x10;\n}\n\nDECLARE_RTL_COND(rtl_dp_ocp_read_cond)\n{\n\tu16 reg;\n\n\treg = rtl8168_get_ocp_reg(tp);\n\n\treturn r8168dp_ocp_read(tp, reg) & 0x00000800;\n}\n\nDECLARE_RTL_COND(rtl_ep_ocp_read_cond)\n{\n\treturn r8168ep_ocp_read(tp, 0x124) & 0x00000001;\n}\n\nDECLARE_RTL_COND(rtl_ocp_tx_cond)\n{\n\treturn RTL_R8(tp, IBISR0) & 0x20;\n}\n\nstatic void rtl8168ep_stop_cmac(struct rtl8169_private *tp)\n{\n\tRTL_W8(tp, IBCR2, RTL_R8(tp, IBCR2) & ~0x01);\n\trtl_loop_wait_high(tp, &rtl_ocp_tx_cond, 50000, 2000);\n\tRTL_W8(tp, IBISR0, RTL_R8(tp, IBISR0) | 0x20);\n\tRTL_W8(tp, IBCR0, RTL_R8(tp, IBCR0) & ~0x01);\n}\n\nstatic void rtl8168dp_driver_start(struct rtl8169_private *tp)\n{\n\tr8168dp_oob_notify(tp, OOB_CMD_DRIVER_START);\n\trtl_loop_wait_high(tp, &rtl_dp_ocp_read_cond, 10000, 10);\n}\n\nstatic void rtl8168ep_driver_start(struct rtl8169_private *tp)\n{\n\tr8168ep_ocp_write(tp, 0x01, 0x180, OOB_CMD_DRIVER_START);\n\tr8168ep_ocp_write(tp, 0x01, 0x30, r8168ep_ocp_read(tp, 0x30) | 0x01);\n\trtl_loop_wait_high(tp, &rtl_ep_ocp_read_cond, 10000, 30);\n}\n\nstatic void rtl8168_driver_start(struct rtl8169_private *tp)\n{\n\tif (tp->dash_type == RTL_DASH_DP)\n\t\trtl8168dp_driver_start(tp);\n\telse\n\t\trtl8168ep_driver_start(tp);\n}\n\nstatic void rtl8168dp_driver_stop(struct rtl8169_private *tp)\n{\n\tr8168dp_oob_notify(tp, OOB_CMD_DRIVER_STOP);\n\trtl_loop_wait_low(tp, &rtl_dp_ocp_read_cond, 10000, 10);\n}\n\nstatic void rtl8168ep_driver_stop(struct rtl8169_private *tp)\n{\n\trtl8168ep_stop_cmac(tp);\n\tr8168ep_ocp_write(tp, 0x01, 0x180, OOB_CMD_DRIVER_STOP);\n\tr8168ep_ocp_write(tp, 0x01, 0x30, r8168ep_ocp_read(tp, 0x30) | 0x01);\n\trtl_loop_wait_low(tp, &rtl_ep_ocp_read_cond, 10000, 10);\n}\n\nstatic void rtl8168_driver_stop(struct rtl8169_private *tp)\n{\n\tif (tp->dash_type == RTL_DASH_DP)\n\t\trtl8168dp_driver_stop(tp);\n\telse\n\t\trtl8168ep_driver_stop(tp);\n}\n\nstatic bool r8168dp_check_dash(struct rtl8169_private *tp)\n{\n\tu16 reg = rtl8168_get_ocp_reg(tp);\n\n\treturn r8168dp_ocp_read(tp, reg) & BIT(15);\n}\n\nstatic bool r8168ep_check_dash(struct rtl8169_private *tp)\n{\n\treturn r8168ep_ocp_read(tp, 0x128) & BIT(0);\n}\n\nstatic bool rtl_dash_is_enabled(struct rtl8169_private *tp)\n{\n\tswitch (tp->dash_type) {\n\tcase RTL_DASH_DP:\n\t\treturn r8168dp_check_dash(tp);\n\tcase RTL_DASH_EP:\n\t\treturn r8168ep_check_dash(tp);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic enum rtl_dash_type rtl_get_dash_type(struct rtl8169_private *tp)\n{\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_28:\n\tcase RTL_GIGA_MAC_VER_31:\n\t\treturn RTL_DASH_DP;\n\tcase RTL_GIGA_MAC_VER_51 ... RTL_GIGA_MAC_VER_53:\n\t\treturn RTL_DASH_EP;\n\tdefault:\n\t\treturn RTL_DASH_NONE;\n\t}\n}\n\nstatic void rtl_set_d3_pll_down(struct rtl8169_private *tp, bool enable)\n{\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_25 ... RTL_GIGA_MAC_VER_26:\n\tcase RTL_GIGA_MAC_VER_29 ... RTL_GIGA_MAC_VER_30:\n\tcase RTL_GIGA_MAC_VER_32 ... RTL_GIGA_MAC_VER_37:\n\tcase RTL_GIGA_MAC_VER_39 ... RTL_GIGA_MAC_VER_63:\n\t\tif (enable)\n\t\t\tRTL_W8(tp, PMCH, RTL_R8(tp, PMCH) & ~D3_NO_PLL_DOWN);\n\t\telse\n\t\t\tRTL_W8(tp, PMCH, RTL_R8(tp, PMCH) | D3_NO_PLL_DOWN);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rtl_reset_packet_filter(struct rtl8169_private *tp)\n{\n\trtl_eri_clear_bits(tp, 0xdc, BIT(0));\n\trtl_eri_set_bits(tp, 0xdc, BIT(0));\n}\n\nDECLARE_RTL_COND(rtl_efusear_cond)\n{\n\treturn RTL_R32(tp, EFUSEAR) & EFUSEAR_FLAG;\n}\n\nu8 rtl8168d_efuse_read(struct rtl8169_private *tp, int reg_addr)\n{\n\tRTL_W32(tp, EFUSEAR, (reg_addr & EFUSEAR_REG_MASK) << EFUSEAR_REG_SHIFT);\n\n\treturn rtl_loop_wait_high(tp, &rtl_efusear_cond, 100, 300) ?\n\t\tRTL_R32(tp, EFUSEAR) & EFUSEAR_DATA_MASK : ~0;\n}\n\nstatic u32 rtl_get_events(struct rtl8169_private *tp)\n{\n\tif (rtl_is_8125(tp))\n\t\treturn RTL_R32(tp, IntrStatus_8125);\n\telse\n\t\treturn RTL_R16(tp, IntrStatus);\n}\n\nstatic void rtl_ack_events(struct rtl8169_private *tp, u32 bits)\n{\n\tif (rtl_is_8125(tp))\n\t\tRTL_W32(tp, IntrStatus_8125, bits);\n\telse\n\t\tRTL_W16(tp, IntrStatus, bits);\n}\n\nstatic void rtl_irq_disable(struct rtl8169_private *tp)\n{\n\tif (rtl_is_8125(tp))\n\t\tRTL_W32(tp, IntrMask_8125, 0);\n\telse\n\t\tRTL_W16(tp, IntrMask, 0);\n}\n\nstatic void rtl_irq_enable(struct rtl8169_private *tp)\n{\n\tif (rtl_is_8125(tp))\n\t\tRTL_W32(tp, IntrMask_8125, tp->irq_mask);\n\telse\n\t\tRTL_W16(tp, IntrMask, tp->irq_mask);\n}\n\nstatic void rtl8169_irq_mask_and_ack(struct rtl8169_private *tp)\n{\n\trtl_irq_disable(tp);\n\trtl_ack_events(tp, 0xffffffff);\n\trtl_pci_commit(tp);\n}\n\nstatic void rtl_link_chg_patch(struct rtl8169_private *tp)\n{\n\tstruct phy_device *phydev = tp->phydev;\n\n\tif (tp->mac_version == RTL_GIGA_MAC_VER_34 ||\n\t    tp->mac_version == RTL_GIGA_MAC_VER_38) {\n\t\tif (phydev->speed == SPEED_1000) {\n\t\t\trtl_eri_write(tp, 0x1bc, ERIAR_MASK_1111, 0x00000011);\n\t\t\trtl_eri_write(tp, 0x1dc, ERIAR_MASK_1111, 0x00000005);\n\t\t} else if (phydev->speed == SPEED_100) {\n\t\t\trtl_eri_write(tp, 0x1bc, ERIAR_MASK_1111, 0x0000001f);\n\t\t\trtl_eri_write(tp, 0x1dc, ERIAR_MASK_1111, 0x00000005);\n\t\t} else {\n\t\t\trtl_eri_write(tp, 0x1bc, ERIAR_MASK_1111, 0x0000001f);\n\t\t\trtl_eri_write(tp, 0x1dc, ERIAR_MASK_1111, 0x0000003f);\n\t\t}\n\t\trtl_reset_packet_filter(tp);\n\t} else if (tp->mac_version == RTL_GIGA_MAC_VER_35 ||\n\t\t   tp->mac_version == RTL_GIGA_MAC_VER_36) {\n\t\tif (phydev->speed == SPEED_1000) {\n\t\t\trtl_eri_write(tp, 0x1bc, ERIAR_MASK_1111, 0x00000011);\n\t\t\trtl_eri_write(tp, 0x1dc, ERIAR_MASK_1111, 0x00000005);\n\t\t} else {\n\t\t\trtl_eri_write(tp, 0x1bc, ERIAR_MASK_1111, 0x0000001f);\n\t\t\trtl_eri_write(tp, 0x1dc, ERIAR_MASK_1111, 0x0000003f);\n\t\t}\n\t} else if (tp->mac_version == RTL_GIGA_MAC_VER_37) {\n\t\tif (phydev->speed == SPEED_10) {\n\t\t\trtl_eri_write(tp, 0x1d0, ERIAR_MASK_0011, 0x4d02);\n\t\t\trtl_eri_write(tp, 0x1dc, ERIAR_MASK_0011, 0x0060a);\n\t\t} else {\n\t\t\trtl_eri_write(tp, 0x1d0, ERIAR_MASK_0011, 0x0000);\n\t\t}\n\t}\n}\n\n#define WAKE_ANY (WAKE_PHY | WAKE_MAGIC | WAKE_UCAST | WAKE_BCAST | WAKE_MCAST)\n\nstatic void rtl8169_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\n\twol->supported = WAKE_ANY;\n\twol->wolopts = tp->saved_wolopts;\n}\n\nstatic void __rtl8169_set_wol(struct rtl8169_private *tp, u32 wolopts)\n{\n\tstatic const struct {\n\t\tu32 opt;\n\t\tu16 reg;\n\t\tu8  mask;\n\t} cfg[] = {\n\t\t{ WAKE_PHY,   Config3, LinkUp },\n\t\t{ WAKE_UCAST, Config5, UWF },\n\t\t{ WAKE_BCAST, Config5, BWF },\n\t\t{ WAKE_MCAST, Config5, MWF },\n\t\t{ WAKE_ANY,   Config5, LanWake },\n\t\t{ WAKE_MAGIC, Config3, MagicPacket }\n\t};\n\tunsigned int i, tmp = ARRAY_SIZE(cfg);\n\tunsigned long flags;\n\tu8 options;\n\n\trtl_unlock_config_regs(tp);\n\n\tif (rtl_is_8168evl_up(tp)) {\n\t\ttmp--;\n\t\tif (wolopts & WAKE_MAGIC)\n\t\t\trtl_eri_set_bits(tp, 0x0dc, MagicPacket_v2);\n\t\telse\n\t\t\trtl_eri_clear_bits(tp, 0x0dc, MagicPacket_v2);\n\t} else if (rtl_is_8125(tp)) {\n\t\ttmp--;\n\t\tif (wolopts & WAKE_MAGIC)\n\t\t\tr8168_mac_ocp_modify(tp, 0xc0b6, 0, BIT(0));\n\t\telse\n\t\t\tr8168_mac_ocp_modify(tp, 0xc0b6, BIT(0), 0);\n\t}\n\n\traw_spin_lock_irqsave(&tp->config25_lock, flags);\n\tfor (i = 0; i < tmp; i++) {\n\t\toptions = RTL_R8(tp, cfg[i].reg) & ~cfg[i].mask;\n\t\tif (wolopts & cfg[i].opt)\n\t\t\toptions |= cfg[i].mask;\n\t\tRTL_W8(tp, cfg[i].reg, options);\n\t}\n\traw_spin_unlock_irqrestore(&tp->config25_lock, flags);\n\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_02 ... RTL_GIGA_MAC_VER_06:\n\t\toptions = RTL_R8(tp, Config1) & ~PMEnable;\n\t\tif (wolopts)\n\t\t\toptions |= PMEnable;\n\t\tRTL_W8(tp, Config1, options);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_34:\n\tcase RTL_GIGA_MAC_VER_37:\n\tcase RTL_GIGA_MAC_VER_39 ... RTL_GIGA_MAC_VER_63:\n\t\tif (wolopts)\n\t\t\trtl_mod_config2(tp, 0, PME_SIGNAL);\n\t\telse\n\t\t\trtl_mod_config2(tp, PME_SIGNAL, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trtl_lock_config_regs(tp);\n\n\tdevice_set_wakeup_enable(tp_to_dev(tp), wolopts);\n\n\tif (!tp->dash_enabled) {\n\t\trtl_set_d3_pll_down(tp, !wolopts);\n\t\ttp->dev->wol_enabled = wolopts ? 1 : 0;\n\t}\n}\n\nstatic int rtl8169_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\n\tif (wol->wolopts & ~WAKE_ANY)\n\t\treturn -EINVAL;\n\n\ttp->saved_wolopts = wol->wolopts;\n\t__rtl8169_set_wol(tp, tp->saved_wolopts);\n\n\treturn 0;\n}\n\nstatic void rtl8169_get_drvinfo(struct net_device *dev,\n\t\t\t\tstruct ethtool_drvinfo *info)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\tstruct rtl_fw *rtl_fw = tp->rtl_fw;\n\n\tstrscpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(tp->pci_dev), sizeof(info->bus_info));\n\tBUILD_BUG_ON(sizeof(info->fw_version) < sizeof(rtl_fw->version));\n\tif (rtl_fw)\n\t\tstrscpy(info->fw_version, rtl_fw->version,\n\t\t\tsizeof(info->fw_version));\n}\n\nstatic int rtl8169_get_regs_len(struct net_device *dev)\n{\n\treturn R8169_REGS_SIZE;\n}\n\nstatic netdev_features_t rtl8169_fix_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\n\tif (dev->mtu > TD_MSS_MAX)\n\t\tfeatures &= ~NETIF_F_ALL_TSO;\n\n\tif (dev->mtu > ETH_DATA_LEN &&\n\t    tp->mac_version > RTL_GIGA_MAC_VER_06)\n\t\tfeatures &= ~(NETIF_F_CSUM_MASK | NETIF_F_ALL_TSO);\n\n\treturn features;\n}\n\nstatic void rtl_set_rx_config_features(struct rtl8169_private *tp,\n\t\t\t\t       netdev_features_t features)\n{\n\tu32 rx_config = RTL_R32(tp, RxConfig);\n\n\tif (features & NETIF_F_RXALL)\n\t\trx_config |= RX_CONFIG_ACCEPT_ERR_MASK;\n\telse\n\t\trx_config &= ~RX_CONFIG_ACCEPT_ERR_MASK;\n\n\tif (rtl_is_8125(tp)) {\n\t\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\t\trx_config |= RX_VLAN_8125;\n\t\telse\n\t\t\trx_config &= ~RX_VLAN_8125;\n\t}\n\n\tRTL_W32(tp, RxConfig, rx_config);\n}\n\nstatic int rtl8169_set_features(struct net_device *dev,\n\t\t\t\tnetdev_features_t features)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\n\trtl_set_rx_config_features(tp, features);\n\n\tif (features & NETIF_F_RXCSUM)\n\t\ttp->cp_cmd |= RxChkSum;\n\telse\n\t\ttp->cp_cmd &= ~RxChkSum;\n\n\tif (!rtl_is_8125(tp)) {\n\t\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\t\ttp->cp_cmd |= RxVlan;\n\t\telse\n\t\t\ttp->cp_cmd &= ~RxVlan;\n\t}\n\n\tRTL_W16(tp, CPlusCmd, tp->cp_cmd);\n\trtl_pci_commit(tp);\n\n\treturn 0;\n}\n\nstatic inline u32 rtl8169_tx_vlan_tag(struct sk_buff *skb)\n{\n\treturn (skb_vlan_tag_present(skb)) ?\n\t\tTxVlanTag | swab16(skb_vlan_tag_get(skb)) : 0x00;\n}\n\nstatic void rtl8169_rx_vlan_tag(struct RxDesc *desc, struct sk_buff *skb)\n{\n\tu32 opts2 = le32_to_cpu(desc->opts2);\n\n\tif (opts2 & RxVlanTag)\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), swab16(opts2 & 0xffff));\n}\n\nstatic void rtl8169_get_regs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t\t     void *p)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\tu32 __iomem *data = tp->mmio_addr;\n\tu32 *dw = p;\n\tint i;\n\n\tfor (i = 0; i < R8169_REGS_SIZE; i += 4)\n\t\tmemcpy_fromio(dw++, data++, 4);\n}\n\nstatic const char rtl8169_gstrings[][ETH_GSTRING_LEN] = {\n\t\"tx_packets\",\n\t\"rx_packets\",\n\t\"tx_errors\",\n\t\"rx_errors\",\n\t\"rx_missed\",\n\t\"align_errors\",\n\t\"tx_single_collisions\",\n\t\"tx_multi_collisions\",\n\t\"unicast\",\n\t\"broadcast\",\n\t\"multicast\",\n\t\"tx_aborted\",\n\t\"tx_underrun\",\n};\n\nstatic int rtl8169_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(rtl8169_gstrings);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nDECLARE_RTL_COND(rtl_counters_cond)\n{\n\treturn RTL_R32(tp, CounterAddrLow) & (CounterReset | CounterDump);\n}\n\nstatic void rtl8169_do_counters(struct rtl8169_private *tp, u32 counter_cmd)\n{\n\tu32 cmd = lower_32_bits(tp->counters_phys_addr);\n\n\tRTL_W32(tp, CounterAddrHigh, upper_32_bits(tp->counters_phys_addr));\n\trtl_pci_commit(tp);\n\tRTL_W32(tp, CounterAddrLow, cmd);\n\tRTL_W32(tp, CounterAddrLow, cmd | counter_cmd);\n\n\trtl_loop_wait_low(tp, &rtl_counters_cond, 10, 1000);\n}\n\nstatic void rtl8169_update_counters(struct rtl8169_private *tp)\n{\n\tu8 val = RTL_R8(tp, ChipCmd);\n\n\t \n\tif (val & CmdRxEnb && val != 0xff)\n\t\trtl8169_do_counters(tp, CounterDump);\n}\n\nstatic void rtl8169_init_counter_offsets(struct rtl8169_private *tp)\n{\n\tstruct rtl8169_counters *counters = tp->counters;\n\n\t \n\n\tif (tp->tc_offset.inited)\n\t\treturn;\n\n\tif (tp->mac_version >= RTL_GIGA_MAC_VER_19) {\n\t\trtl8169_do_counters(tp, CounterReset);\n\t} else {\n\t\trtl8169_update_counters(tp);\n\t\ttp->tc_offset.tx_errors = counters->tx_errors;\n\t\ttp->tc_offset.tx_multi_collision = counters->tx_multi_collision;\n\t\ttp->tc_offset.tx_aborted = counters->tx_aborted;\n\t\ttp->tc_offset.rx_missed = counters->rx_missed;\n\t}\n\n\ttp->tc_offset.inited = true;\n}\n\nstatic void rtl8169_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t      struct ethtool_stats *stats, u64 *data)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\tstruct rtl8169_counters *counters;\n\n\tcounters = tp->counters;\n\trtl8169_update_counters(tp);\n\n\tdata[0] = le64_to_cpu(counters->tx_packets);\n\tdata[1] = le64_to_cpu(counters->rx_packets);\n\tdata[2] = le64_to_cpu(counters->tx_errors);\n\tdata[3] = le32_to_cpu(counters->rx_errors);\n\tdata[4] = le16_to_cpu(counters->rx_missed);\n\tdata[5] = le16_to_cpu(counters->align_errors);\n\tdata[6] = le32_to_cpu(counters->tx_one_collision);\n\tdata[7] = le32_to_cpu(counters->tx_multi_collision);\n\tdata[8] = le64_to_cpu(counters->rx_unicast);\n\tdata[9] = le64_to_cpu(counters->rx_broadcast);\n\tdata[10] = le32_to_cpu(counters->rx_multicast);\n\tdata[11] = le16_to_cpu(counters->tx_aborted);\n\tdata[12] = le16_to_cpu(counters->tx_underun);\n}\n\nstatic void rtl8169_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tswitch(stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(data, rtl8169_gstrings, sizeof(rtl8169_gstrings));\n\t\tbreak;\n\t}\n}\n\n \n\n \nstruct rtl_coalesce_info {\n\tu32 speed;\n\tu32 scale_nsecs[4];\n};\n\n \n#define COALESCE_DELAY(d) { (d), 8 * (d), 16 * (d), 32 * (d) }\n\nstatic const struct rtl_coalesce_info rtl_coalesce_info_8169[] = {\n\t{ SPEED_1000,\tCOALESCE_DELAY(320) },\n\t{ SPEED_100,\tCOALESCE_DELAY(2560) },\n\t{ SPEED_10,\tCOALESCE_DELAY(40960) },\n\t{ 0 },\n};\n\nstatic const struct rtl_coalesce_info rtl_coalesce_info_8168_8136[] = {\n\t{ SPEED_1000,\tCOALESCE_DELAY(5000) },\n\t{ SPEED_100,\tCOALESCE_DELAY(2560) },\n\t{ SPEED_10,\tCOALESCE_DELAY(40960) },\n\t{ 0 },\n};\n#undef COALESCE_DELAY\n\n \nstatic const struct rtl_coalesce_info *\nrtl_coalesce_info(struct rtl8169_private *tp)\n{\n\tconst struct rtl_coalesce_info *ci;\n\n\tif (tp->mac_version <= RTL_GIGA_MAC_VER_06)\n\t\tci = rtl_coalesce_info_8169;\n\telse\n\t\tci = rtl_coalesce_info_8168_8136;\n\n\t \n\tif (tp->phydev->speed == SPEED_UNKNOWN)\n\t\treturn ci;\n\n\tfor (; ci->speed; ci++) {\n\t\tif (tp->phydev->speed == ci->speed)\n\t\t\treturn ci;\n\t}\n\n\treturn ERR_PTR(-ELNRNG);\n}\n\nstatic int rtl_get_coalesce(struct net_device *dev,\n\t\t\t    struct ethtool_coalesce *ec,\n\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\tconst struct rtl_coalesce_info *ci;\n\tu32 scale, c_us, c_fr;\n\tu16 intrmit;\n\n\tif (rtl_is_8125(tp))\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(ec, 0, sizeof(*ec));\n\n\t \n\tci = rtl_coalesce_info(tp);\n\tif (IS_ERR(ci))\n\t\treturn PTR_ERR(ci);\n\n\tscale = ci->scale_nsecs[tp->cp_cmd & INTT_MASK];\n\n\tintrmit = RTL_R16(tp, IntrMitigate);\n\n\tc_us = FIELD_GET(RTL_COALESCE_TX_USECS, intrmit);\n\tec->tx_coalesce_usecs = DIV_ROUND_UP(c_us * scale, 1000);\n\n\tc_fr = FIELD_GET(RTL_COALESCE_TX_FRAMES, intrmit);\n\t \n\tec->tx_max_coalesced_frames = (c_us || c_fr) ? c_fr * 4 : 1;\n\n\tc_us = FIELD_GET(RTL_COALESCE_RX_USECS, intrmit);\n\tec->rx_coalesce_usecs = DIV_ROUND_UP(c_us * scale, 1000);\n\n\tc_fr = FIELD_GET(RTL_COALESCE_RX_FRAMES, intrmit);\n\tec->rx_max_coalesced_frames = (c_us || c_fr) ? c_fr * 4 : 1;\n\n\treturn 0;\n}\n\n \nstatic int rtl_coalesce_choose_scale(struct rtl8169_private *tp, u32 usec,\n\t\t\t\t     u16 *cp01)\n{\n\tconst struct rtl_coalesce_info *ci;\n\tu16 i;\n\n\tci = rtl_coalesce_info(tp);\n\tif (IS_ERR(ci))\n\t\treturn PTR_ERR(ci);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (usec <= ci->scale_nsecs[i] * RTL_COALESCE_T_MAX / 1000U) {\n\t\t\t*cp01 = i;\n\t\t\treturn ci->scale_nsecs[i];\n\t\t}\n\t}\n\n\treturn -ERANGE;\n}\n\nstatic int rtl_set_coalesce(struct net_device *dev,\n\t\t\t    struct ethtool_coalesce *ec,\n\t\t\t    struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\tu32 tx_fr = ec->tx_max_coalesced_frames;\n\tu32 rx_fr = ec->rx_max_coalesced_frames;\n\tu32 coal_usec_max, units;\n\tu16 w = 0, cp01 = 0;\n\tint scale;\n\n\tif (rtl_is_8125(tp))\n\t\treturn -EOPNOTSUPP;\n\n\tif (rx_fr > RTL_COALESCE_FRAME_MAX || tx_fr > RTL_COALESCE_FRAME_MAX)\n\t\treturn -ERANGE;\n\n\tcoal_usec_max = max(ec->rx_coalesce_usecs, ec->tx_coalesce_usecs);\n\tscale = rtl_coalesce_choose_scale(tp, coal_usec_max, &cp01);\n\tif (scale < 0)\n\t\treturn scale;\n\n\t \n\tif (rx_fr == 1)\n\t\trx_fr = 0;\n\tif (tx_fr == 1)\n\t\ttx_fr = 0;\n\n\t \n\tif ((tx_fr && !ec->tx_coalesce_usecs) ||\n\t    (rx_fr && !ec->rx_coalesce_usecs))\n\t\treturn -EINVAL;\n\n\tw |= FIELD_PREP(RTL_COALESCE_TX_FRAMES, DIV_ROUND_UP(tx_fr, 4));\n\tw |= FIELD_PREP(RTL_COALESCE_RX_FRAMES, DIV_ROUND_UP(rx_fr, 4));\n\n\tunits = DIV_ROUND_UP(ec->tx_coalesce_usecs * 1000U, scale);\n\tw |= FIELD_PREP(RTL_COALESCE_TX_USECS, units);\n\tunits = DIV_ROUND_UP(ec->rx_coalesce_usecs * 1000U, scale);\n\tw |= FIELD_PREP(RTL_COALESCE_RX_USECS, units);\n\n\tRTL_W16(tp, IntrMitigate, w);\n\n\t \n\tif (rtl_is_8168evl_up(tp)) {\n\t\tif (!rx_fr && !tx_fr)\n\t\t\t \n\t\t\ttp->cp_cmd |= PktCntrDisable;\n\t\telse\n\t\t\ttp->cp_cmd &= ~PktCntrDisable;\n\t}\n\n\ttp->cp_cmd = (tp->cp_cmd & ~INTT_MASK) | cp01;\n\tRTL_W16(tp, CPlusCmd, tp->cp_cmd);\n\trtl_pci_commit(tp);\n\n\treturn 0;\n}\n\nstatic int rtl8169_get_eee(struct net_device *dev, struct ethtool_eee *data)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\n\tif (!rtl_supports_eee(tp))\n\t\treturn -EOPNOTSUPP;\n\n\treturn phy_ethtool_get_eee(tp->phydev, data);\n}\n\nstatic int rtl8169_set_eee(struct net_device *dev, struct ethtool_eee *data)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\tint ret;\n\n\tif (!rtl_supports_eee(tp))\n\t\treturn -EOPNOTSUPP;\n\n\tret = phy_ethtool_set_eee(tp->phydev, data);\n\n\tif (!ret)\n\t\ttp->eee_adv = phy_read_mmd(dev->phydev, MDIO_MMD_AN,\n\t\t\t\t\t   MDIO_AN_EEE_ADV);\n\treturn ret;\n}\n\nstatic void rtl8169_get_ringparam(struct net_device *dev,\n\t\t\t\t  struct ethtool_ringparam *data,\n\t\t\t\t  struct kernel_ethtool_ringparam *kernel_data,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tdata->rx_max_pending = NUM_RX_DESC;\n\tdata->rx_pending = NUM_RX_DESC;\n\tdata->tx_max_pending = NUM_TX_DESC;\n\tdata->tx_pending = NUM_TX_DESC;\n}\n\nstatic void rtl8169_get_pauseparam(struct net_device *dev,\n\t\t\t\t   struct ethtool_pauseparam *data)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\tbool tx_pause, rx_pause;\n\n\tphy_get_pause(tp->phydev, &tx_pause, &rx_pause);\n\n\tdata->autoneg = tp->phydev->autoneg;\n\tdata->tx_pause = tx_pause ? 1 : 0;\n\tdata->rx_pause = rx_pause ? 1 : 0;\n}\n\nstatic int rtl8169_set_pauseparam(struct net_device *dev,\n\t\t\t\t  struct ethtool_pauseparam *data)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\n\tif (dev->mtu > ETH_DATA_LEN)\n\t\treturn -EOPNOTSUPP;\n\n\tphy_set_asym_pause(tp->phydev, data->rx_pause, data->tx_pause);\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops rtl8169_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES,\n\t.get_drvinfo\t\t= rtl8169_get_drvinfo,\n\t.get_regs_len\t\t= rtl8169_get_regs_len,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_coalesce\t\t= rtl_get_coalesce,\n\t.set_coalesce\t\t= rtl_set_coalesce,\n\t.get_regs\t\t= rtl8169_get_regs,\n\t.get_wol\t\t= rtl8169_get_wol,\n\t.set_wol\t\t= rtl8169_set_wol,\n\t.get_strings\t\t= rtl8169_get_strings,\n\t.get_sset_count\t\t= rtl8169_get_sset_count,\n\t.get_ethtool_stats\t= rtl8169_get_ethtool_stats,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.nway_reset\t\t= phy_ethtool_nway_reset,\n\t.get_eee\t\t= rtl8169_get_eee,\n\t.set_eee\t\t= rtl8169_set_eee,\n\t.get_link_ksettings\t= phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= phy_ethtool_set_link_ksettings,\n\t.get_ringparam\t\t= rtl8169_get_ringparam,\n\t.get_pauseparam\t\t= rtl8169_get_pauseparam,\n\t.set_pauseparam\t\t= rtl8169_set_pauseparam,\n};\n\nstatic void rtl_enable_eee(struct rtl8169_private *tp)\n{\n\tstruct phy_device *phydev = tp->phydev;\n\tint adv;\n\n\t \n\tif (tp->eee_adv >= 0)\n\t\tadv = tp->eee_adv;\n\telse\n\t\tadv = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);\n\n\tif (adv >= 0)\n\t\tphy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, adv);\n}\n\nstatic enum mac_version rtl8169_get_mac_version(u16 xid, bool gmii)\n{\n\t \n\tstatic const struct rtl_mac_info {\n\t\tu16 mask;\n\t\tu16 val;\n\t\tenum mac_version ver;\n\t} mac_info[] = {\n\t\t \n\t\t{ 0x7cf, 0x641,\tRTL_GIGA_MAC_VER_63 },\n\n\t\t \n\t\t{ 0x7cf, 0x609,\tRTL_GIGA_MAC_VER_61 },\n\t\t \n\n\t\t \n\t\t{ 0x7cf, 0x54b,\tRTL_GIGA_MAC_VER_53 },\n\t\t{ 0x7cf, 0x54a,\tRTL_GIGA_MAC_VER_52 },\n\n\t\t \n\t\t{ 0x7cf, 0x502,\tRTL_GIGA_MAC_VER_51 },\n\t\t \n\n\t\t \n\t\t{ 0x7cf, 0x541,\tRTL_GIGA_MAC_VER_46 },\n\t\t \n\n\t\t \n\t\t{ 0x7cf, 0x5c8,\tRTL_GIGA_MAC_VER_44 },\n\t\t{ 0x7cf, 0x509,\tRTL_GIGA_MAC_VER_42 },\n\t\t \n\t\t{ 0x7cf, 0x4c0,\tRTL_GIGA_MAC_VER_40 },\n\n\t\t \n\t\t{ 0x7c8, 0x488,\tRTL_GIGA_MAC_VER_38 },\n\t\t{ 0x7cf, 0x481,\tRTL_GIGA_MAC_VER_36 },\n\t\t{ 0x7cf, 0x480,\tRTL_GIGA_MAC_VER_35 },\n\n\t\t \n\t\t{ 0x7c8, 0x2c8,\tRTL_GIGA_MAC_VER_34 },\n\t\t{ 0x7cf, 0x2c1,\tRTL_GIGA_MAC_VER_32 },\n\t\t{ 0x7c8, 0x2c0,\tRTL_GIGA_MAC_VER_33 },\n\n\t\t \n\t\t{ 0x7cf, 0x281,\tRTL_GIGA_MAC_VER_25 },\n\t\t{ 0x7c8, 0x280,\tRTL_GIGA_MAC_VER_26 },\n\n\t\t \n\t\t \n\t\t{ 0x7cf, 0x28a,\tRTL_GIGA_MAC_VER_28 },\n\t\t{ 0x7cf, 0x28b,\tRTL_GIGA_MAC_VER_31 },\n\n\t\t \n\t\t{ 0x7cf, 0x3c9,\tRTL_GIGA_MAC_VER_23 },\n\t\t{ 0x7cf, 0x3c8,\tRTL_GIGA_MAC_VER_18 },\n\t\t{ 0x7c8, 0x3c8,\tRTL_GIGA_MAC_VER_24 },\n\t\t{ 0x7cf, 0x3c0,\tRTL_GIGA_MAC_VER_19 },\n\t\t{ 0x7cf, 0x3c2,\tRTL_GIGA_MAC_VER_20 },\n\t\t{ 0x7cf, 0x3c3,\tRTL_GIGA_MAC_VER_21 },\n\t\t{ 0x7c8, 0x3c0,\tRTL_GIGA_MAC_VER_22 },\n\n\t\t \n\t\t{ 0x7c8, 0x380,\tRTL_GIGA_MAC_VER_17 },\n\t\t{ 0x7c8, 0x300,\tRTL_GIGA_MAC_VER_11 },\n\n\t\t \n\t\t{ 0x7c8, 0x448,\tRTL_GIGA_MAC_VER_39 },\n\t\t{ 0x7c8, 0x440,\tRTL_GIGA_MAC_VER_37 },\n\t\t{ 0x7cf, 0x409,\tRTL_GIGA_MAC_VER_29 },\n\t\t{ 0x7c8, 0x408,\tRTL_GIGA_MAC_VER_30 },\n\t\t{ 0x7cf, 0x349,\tRTL_GIGA_MAC_VER_08 },\n\t\t{ 0x7cf, 0x249,\tRTL_GIGA_MAC_VER_08 },\n\t\t{ 0x7cf, 0x348,\tRTL_GIGA_MAC_VER_07 },\n\t\t{ 0x7cf, 0x248,\tRTL_GIGA_MAC_VER_07 },\n\t\t{ 0x7cf, 0x240,\tRTL_GIGA_MAC_VER_14 },\n\t\t{ 0x7c8, 0x348,\tRTL_GIGA_MAC_VER_09 },\n\t\t{ 0x7c8, 0x248,\tRTL_GIGA_MAC_VER_09 },\n\t\t{ 0x7c8, 0x340,\tRTL_GIGA_MAC_VER_10 },\n\n\t\t \n\t\t{ 0xfc8, 0x980,\tRTL_GIGA_MAC_VER_06 },\n\t\t{ 0xfc8, 0x180,\tRTL_GIGA_MAC_VER_05 },\n\t\t{ 0xfc8, 0x100,\tRTL_GIGA_MAC_VER_04 },\n\t\t{ 0xfc8, 0x040,\tRTL_GIGA_MAC_VER_03 },\n\t\t{ 0xfc8, 0x008,\tRTL_GIGA_MAC_VER_02 },\n\n\t\t \n\t\t{ 0x000, 0x000,\tRTL_GIGA_MAC_NONE   }\n\t};\n\tconst struct rtl_mac_info *p = mac_info;\n\tenum mac_version ver;\n\n\twhile ((xid & p->mask) != p->val)\n\t\tp++;\n\tver = p->ver;\n\n\tif (ver != RTL_GIGA_MAC_NONE && !gmii) {\n\t\tif (ver == RTL_GIGA_MAC_VER_42)\n\t\t\tver = RTL_GIGA_MAC_VER_43;\n\t\telse if (ver == RTL_GIGA_MAC_VER_46)\n\t\t\tver = RTL_GIGA_MAC_VER_48;\n\t}\n\n\treturn ver;\n}\n\nstatic void rtl_release_firmware(struct rtl8169_private *tp)\n{\n\tif (tp->rtl_fw) {\n\t\trtl_fw_release_firmware(tp->rtl_fw);\n\t\tkfree(tp->rtl_fw);\n\t\ttp->rtl_fw = NULL;\n\t}\n}\n\nvoid r8169_apply_firmware(struct rtl8169_private *tp)\n{\n\tint val;\n\n\t \n\tif (tp->rtl_fw) {\n\t\trtl_fw_write_firmware(tp, tp->rtl_fw);\n\t\t \n\t\ttp->ocp_base = OCP_STD_PHY_BASE;\n\n\t\t \n\t\tphy_read_poll_timeout(tp->phydev, MII_BMCR, val,\n\t\t\t\t      !(val & BMCR_RESET),\n\t\t\t\t      50000, 600000, true);\n\t}\n}\n\nstatic void rtl8168_config_eee_mac(struct rtl8169_private *tp)\n{\n\t \n\tif (tp->mac_version != RTL_GIGA_MAC_VER_38)\n\t\tRTL_W8(tp, EEE_LED, RTL_R8(tp, EEE_LED) & ~0x07);\n\n\trtl_eri_set_bits(tp, 0x1b0, 0x0003);\n}\n\nstatic void rtl8125a_config_eee_mac(struct rtl8169_private *tp)\n{\n\tr8168_mac_ocp_modify(tp, 0xe040, 0, BIT(1) | BIT(0));\n\tr8168_mac_ocp_modify(tp, 0xeb62, 0, BIT(2) | BIT(1));\n}\n\nstatic void rtl8125_set_eee_txidle_timer(struct rtl8169_private *tp)\n{\n\tRTL_W16(tp, EEE_TXIDLE_TIMER_8125, tp->dev->mtu + ETH_HLEN + 0x20);\n}\n\nstatic void rtl8125b_config_eee_mac(struct rtl8169_private *tp)\n{\n\trtl8125_set_eee_txidle_timer(tp);\n\tr8168_mac_ocp_modify(tp, 0xe040, 0, BIT(1) | BIT(0));\n}\n\nstatic void rtl_rar_exgmac_set(struct rtl8169_private *tp, const u8 *addr)\n{\n\trtl_eri_write(tp, 0xe0, ERIAR_MASK_1111, get_unaligned_le32(addr));\n\trtl_eri_write(tp, 0xe4, ERIAR_MASK_1111, get_unaligned_le16(addr + 4));\n\trtl_eri_write(tp, 0xf0, ERIAR_MASK_1111, get_unaligned_le16(addr) << 16);\n\trtl_eri_write(tp, 0xf4, ERIAR_MASK_1111, get_unaligned_le32(addr + 2));\n}\n\nu16 rtl8168h_2_get_adc_bias_ioffset(struct rtl8169_private *tp)\n{\n\tu16 data1, data2, ioffset;\n\n\tr8168_mac_ocp_write(tp, 0xdd02, 0x807d);\n\tdata1 = r8168_mac_ocp_read(tp, 0xdd02);\n\tdata2 = r8168_mac_ocp_read(tp, 0xdd00);\n\n\tioffset = (data2 >> 1) & 0x7ff8;\n\tioffset |= data2 & 0x0007;\n\tif (data1 & BIT(7))\n\t\tioffset |= BIT(15);\n\n\treturn ioffset;\n}\n\nstatic void rtl_schedule_task(struct rtl8169_private *tp, enum rtl_flag flag)\n{\n\tset_bit(flag, tp->wk.flags);\n\tschedule_work(&tp->wk.work);\n}\n\nstatic void rtl8169_init_phy(struct rtl8169_private *tp)\n{\n\tr8169_hw_phy_config(tp, tp->phydev, tp->mac_version);\n\n\tif (tp->mac_version <= RTL_GIGA_MAC_VER_06) {\n\t\tpci_write_config_byte(tp->pci_dev, PCI_LATENCY_TIMER, 0x40);\n\t\tpci_write_config_byte(tp->pci_dev, PCI_CACHE_LINE_SIZE, 0x08);\n\t\t \n\t\tRTL_W8(tp, 0x82, 0x01);\n\t}\n\n\tif (tp->mac_version == RTL_GIGA_MAC_VER_05 &&\n\t    tp->pci_dev->subsystem_vendor == PCI_VENDOR_ID_GIGABYTE &&\n\t    tp->pci_dev->subsystem_device == 0xe000)\n\t\tphy_write_paged(tp->phydev, 0x0001, 0x10, 0xf01b);\n\n\t \n\tphy_speed_up(tp->phydev);\n\n\tif (rtl_supports_eee(tp))\n\t\trtl_enable_eee(tp);\n\n\tgenphy_soft_reset(tp->phydev);\n}\n\nstatic void rtl_rar_set(struct rtl8169_private *tp, const u8 *addr)\n{\n\trtl_unlock_config_regs(tp);\n\n\tRTL_W32(tp, MAC4, get_unaligned_le16(addr + 4));\n\trtl_pci_commit(tp);\n\n\tRTL_W32(tp, MAC0, get_unaligned_le32(addr));\n\trtl_pci_commit(tp);\n\n\tif (tp->mac_version == RTL_GIGA_MAC_VER_34)\n\t\trtl_rar_exgmac_set(tp, addr);\n\n\trtl_lock_config_regs(tp);\n}\n\nstatic int rtl_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\tint ret;\n\n\tret = eth_mac_addr(dev, p);\n\tif (ret)\n\t\treturn ret;\n\n\trtl_rar_set(tp, dev->dev_addr);\n\n\treturn 0;\n}\n\nstatic void rtl_init_rxcfg(struct rtl8169_private *tp)\n{\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_02 ... RTL_GIGA_MAC_VER_06:\n\tcase RTL_GIGA_MAC_VER_10 ... RTL_GIGA_MAC_VER_17:\n\t\tRTL_W32(tp, RxConfig, RX_FIFO_THRESH | RX_DMA_BURST);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_18 ... RTL_GIGA_MAC_VER_24:\n\tcase RTL_GIGA_MAC_VER_34 ... RTL_GIGA_MAC_VER_36:\n\tcase RTL_GIGA_MAC_VER_38:\n\t\tRTL_W32(tp, RxConfig, RX128_INT_EN | RX_MULTI_EN | RX_DMA_BURST);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_53:\n\t\tRTL_W32(tp, RxConfig, RX128_INT_EN | RX_MULTI_EN | RX_DMA_BURST | RX_EARLY_OFF);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_61:\n\t\tRTL_W32(tp, RxConfig, RX_FETCH_DFLT_8125 | RX_DMA_BURST);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_63:\n\t\tRTL_W32(tp, RxConfig, RX_FETCH_DFLT_8125 | RX_DMA_BURST |\n\t\t\tRX_PAUSE_SLOT_ON);\n\t\tbreak;\n\tdefault:\n\t\tRTL_W32(tp, RxConfig, RX128_INT_EN | RX_DMA_BURST);\n\t\tbreak;\n\t}\n}\n\nstatic void rtl8169_init_ring_indexes(struct rtl8169_private *tp)\n{\n\ttp->dirty_tx = tp->cur_tx = tp->cur_rx = 0;\n}\n\nstatic void r8168c_hw_jumbo_enable(struct rtl8169_private *tp)\n{\n\tRTL_W8(tp, Config3, RTL_R8(tp, Config3) | Jumbo_En0);\n\tRTL_W8(tp, Config4, RTL_R8(tp, Config4) | Jumbo_En1);\n}\n\nstatic void r8168c_hw_jumbo_disable(struct rtl8169_private *tp)\n{\n\tRTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~Jumbo_En0);\n\tRTL_W8(tp, Config4, RTL_R8(tp, Config4) & ~Jumbo_En1);\n}\n\nstatic void r8168dp_hw_jumbo_enable(struct rtl8169_private *tp)\n{\n\tRTL_W8(tp, Config3, RTL_R8(tp, Config3) | Jumbo_En0);\n}\n\nstatic void r8168dp_hw_jumbo_disable(struct rtl8169_private *tp)\n{\n\tRTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~Jumbo_En0);\n}\n\nstatic void r8168e_hw_jumbo_enable(struct rtl8169_private *tp)\n{\n\tRTL_W8(tp, MaxTxPacketSize, 0x24);\n\tRTL_W8(tp, Config3, RTL_R8(tp, Config3) | Jumbo_En0);\n\tRTL_W8(tp, Config4, RTL_R8(tp, Config4) | 0x01);\n}\n\nstatic void r8168e_hw_jumbo_disable(struct rtl8169_private *tp)\n{\n\tRTL_W8(tp, MaxTxPacketSize, 0x3f);\n\tRTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~Jumbo_En0);\n\tRTL_W8(tp, Config4, RTL_R8(tp, Config4) & ~0x01);\n}\n\nstatic void r8168b_1_hw_jumbo_enable(struct rtl8169_private *tp)\n{\n\tRTL_W8(tp, Config4, RTL_R8(tp, Config4) | (1 << 0));\n}\n\nstatic void r8168b_1_hw_jumbo_disable(struct rtl8169_private *tp)\n{\n\tRTL_W8(tp, Config4, RTL_R8(tp, Config4) & ~(1 << 0));\n}\n\nstatic void rtl_jumbo_config(struct rtl8169_private *tp)\n{\n\tbool jumbo = tp->dev->mtu > ETH_DATA_LEN;\n\tint readrq = 4096;\n\n\trtl_unlock_config_regs(tp);\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_17:\n\t\tif (jumbo) {\n\t\t\treadrq = 512;\n\t\t\tr8168b_1_hw_jumbo_enable(tp);\n\t\t} else {\n\t\t\tr8168b_1_hw_jumbo_disable(tp);\n\t\t}\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_18 ... RTL_GIGA_MAC_VER_26:\n\t\tif (jumbo) {\n\t\t\treadrq = 512;\n\t\t\tr8168c_hw_jumbo_enable(tp);\n\t\t} else {\n\t\t\tr8168c_hw_jumbo_disable(tp);\n\t\t}\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_28:\n\t\tif (jumbo)\n\t\t\tr8168dp_hw_jumbo_enable(tp);\n\t\telse\n\t\t\tr8168dp_hw_jumbo_disable(tp);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_31 ... RTL_GIGA_MAC_VER_33:\n\t\tif (jumbo)\n\t\t\tr8168e_hw_jumbo_enable(tp);\n\t\telse\n\t\t\tr8168e_hw_jumbo_disable(tp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\trtl_lock_config_regs(tp);\n\n\tif (pci_is_pcie(tp->pci_dev) && tp->supports_gmii)\n\t\tpcie_set_readrq(tp->pci_dev, readrq);\n\n\t \n\tif (jumbo) {\n\t\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t\t   tp->phydev->advertising);\n\t\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\t\t\t\t   tp->phydev->advertising);\n\t\tphy_start_aneg(tp->phydev);\n\t}\n}\n\nDECLARE_RTL_COND(rtl_chipcmd_cond)\n{\n\treturn RTL_R8(tp, ChipCmd) & CmdReset;\n}\n\nstatic void rtl_hw_reset(struct rtl8169_private *tp)\n{\n\tRTL_W8(tp, ChipCmd, CmdReset);\n\n\trtl_loop_wait_low(tp, &rtl_chipcmd_cond, 100, 100);\n}\n\nstatic void rtl_request_firmware(struct rtl8169_private *tp)\n{\n\tstruct rtl_fw *rtl_fw;\n\n\t \n\tif (tp->rtl_fw || !tp->fw_name)\n\t\treturn;\n\n\trtl_fw = kzalloc(sizeof(*rtl_fw), GFP_KERNEL);\n\tif (!rtl_fw)\n\t\treturn;\n\n\trtl_fw->phy_write = rtl_writephy;\n\trtl_fw->phy_read = rtl_readphy;\n\trtl_fw->mac_mcu_write = mac_mcu_write;\n\trtl_fw->mac_mcu_read = mac_mcu_read;\n\trtl_fw->fw_name = tp->fw_name;\n\trtl_fw->dev = tp_to_dev(tp);\n\n\tif (rtl_fw_request_firmware(rtl_fw))\n\t\tkfree(rtl_fw);\n\telse\n\t\ttp->rtl_fw = rtl_fw;\n}\n\nstatic void rtl_rx_close(struct rtl8169_private *tp)\n{\n\tRTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) & ~RX_CONFIG_ACCEPT_MASK);\n}\n\nDECLARE_RTL_COND(rtl_npq_cond)\n{\n\treturn RTL_R8(tp, TxPoll) & NPQ;\n}\n\nDECLARE_RTL_COND(rtl_txcfg_empty_cond)\n{\n\treturn RTL_R32(tp, TxConfig) & TXCFG_EMPTY;\n}\n\nDECLARE_RTL_COND(rtl_rxtx_empty_cond)\n{\n\treturn (RTL_R8(tp, MCU) & RXTX_EMPTY) == RXTX_EMPTY;\n}\n\nDECLARE_RTL_COND(rtl_rxtx_empty_cond_2)\n{\n\t \n\treturn (RTL_R16(tp, IntrMitigate) & 0x0103) == 0x0103;\n}\n\nstatic void rtl_wait_txrx_fifo_empty(struct rtl8169_private *tp)\n{\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_53:\n\t\trtl_loop_wait_high(tp, &rtl_txcfg_empty_cond, 100, 42);\n\t\trtl_loop_wait_high(tp, &rtl_rxtx_empty_cond, 100, 42);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_61:\n\t\trtl_loop_wait_high(tp, &rtl_rxtx_empty_cond, 100, 42);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_63:\n\t\tRTL_W8(tp, ChipCmd, RTL_R8(tp, ChipCmd) | StopReq);\n\t\trtl_loop_wait_high(tp, &rtl_rxtx_empty_cond, 100, 42);\n\t\trtl_loop_wait_high(tp, &rtl_rxtx_empty_cond_2, 100, 42);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rtl_disable_rxdvgate(struct rtl8169_private *tp)\n{\n\tRTL_W32(tp, MISC, RTL_R32(tp, MISC) & ~RXDV_GATED_EN);\n}\n\nstatic void rtl_enable_rxdvgate(struct rtl8169_private *tp)\n{\n\tRTL_W32(tp, MISC, RTL_R32(tp, MISC) | RXDV_GATED_EN);\n\tfsleep(2000);\n\trtl_wait_txrx_fifo_empty(tp);\n}\n\nstatic void rtl_wol_enable_rx(struct rtl8169_private *tp)\n{\n\tif (tp->mac_version >= RTL_GIGA_MAC_VER_25)\n\t\tRTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) |\n\t\t\tAcceptBroadcast | AcceptMulticast | AcceptMyPhys);\n\n\tif (tp->mac_version >= RTL_GIGA_MAC_VER_40)\n\t\trtl_disable_rxdvgate(tp);\n}\n\nstatic void rtl_prepare_power_down(struct rtl8169_private *tp)\n{\n\tif (tp->dash_enabled)\n\t\treturn;\n\n\tif (tp->mac_version == RTL_GIGA_MAC_VER_32 ||\n\t    tp->mac_version == RTL_GIGA_MAC_VER_33)\n\t\trtl_ephy_write(tp, 0x19, 0xff64);\n\n\tif (device_may_wakeup(tp_to_dev(tp))) {\n\t\tphy_speed_down(tp->phydev, false);\n\t\trtl_wol_enable_rx(tp);\n\t}\n}\n\nstatic void rtl_set_tx_config_registers(struct rtl8169_private *tp)\n{\n\tu32 val = TX_DMA_BURST << TxDMAShift |\n\t\t  InterFrameGap << TxInterFrameGapShift;\n\n\tif (rtl_is_8168evl_up(tp))\n\t\tval |= TXCFG_AUTO_FIFO;\n\n\tRTL_W32(tp, TxConfig, val);\n}\n\nstatic void rtl_set_rx_max_size(struct rtl8169_private *tp)\n{\n\t \n\tRTL_W16(tp, RxMaxSize, R8169_RX_BUF_SIZE + 1);\n}\n\nstatic void rtl_set_rx_tx_desc_registers(struct rtl8169_private *tp)\n{\n\t \n\tRTL_W32(tp, TxDescStartAddrHigh, ((u64) tp->TxPhyAddr) >> 32);\n\tRTL_W32(tp, TxDescStartAddrLow, ((u64) tp->TxPhyAddr) & DMA_BIT_MASK(32));\n\tRTL_W32(tp, RxDescAddrHigh, ((u64) tp->RxPhyAddr) >> 32);\n\tRTL_W32(tp, RxDescAddrLow, ((u64) tp->RxPhyAddr) & DMA_BIT_MASK(32));\n}\n\nstatic void rtl8169_set_magic_reg(struct rtl8169_private *tp)\n{\n\tu32 val;\n\n\tif (tp->mac_version == RTL_GIGA_MAC_VER_05)\n\t\tval = 0x000fff00;\n\telse if (tp->mac_version == RTL_GIGA_MAC_VER_06)\n\t\tval = 0x00ffff00;\n\telse\n\t\treturn;\n\n\tif (RTL_R8(tp, Config2) & PCI_Clock_66MHz)\n\t\tval |= 0xff;\n\n\tRTL_W32(tp, 0x7c, val);\n}\n\nstatic void rtl_set_rx_mode(struct net_device *dev)\n{\n\tu32 rx_mode = AcceptBroadcast | AcceptMyPhys | AcceptMulticast;\n\t \n\tu32 mc_filter[2] = { 0xffffffff, 0xffffffff };\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\tu32 tmp;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\trx_mode |= AcceptAllPhys;\n\t} else if (!(dev->flags & IFF_MULTICAST)) {\n\t\trx_mode &= ~AcceptMulticast;\n\t} else if (netdev_mc_count(dev) > MC_FILTER_LIMIT ||\n\t\t   dev->flags & IFF_ALLMULTI ||\n\t\t   tp->mac_version == RTL_GIGA_MAC_VER_35) {\n\t\t \n\t} else if (netdev_mc_empty(dev)) {\n\t\trx_mode &= ~AcceptMulticast;\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tmc_filter[1] = mc_filter[0] = 0;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tu32 bit_nr = eth_hw_addr_crc(ha) >> 26;\n\t\t\tmc_filter[bit_nr >> 5] |= BIT(bit_nr & 31);\n\t\t}\n\n\t\tif (tp->mac_version > RTL_GIGA_MAC_VER_06) {\n\t\t\ttmp = mc_filter[0];\n\t\t\tmc_filter[0] = swab32(mc_filter[1]);\n\t\t\tmc_filter[1] = swab32(tmp);\n\t\t}\n\t}\n\n\tRTL_W32(tp, MAR0 + 4, mc_filter[1]);\n\tRTL_W32(tp, MAR0 + 0, mc_filter[0]);\n\n\ttmp = RTL_R32(tp, RxConfig);\n\tRTL_W32(tp, RxConfig, (tmp & ~RX_CONFIG_ACCEPT_OK_MASK) | rx_mode);\n}\n\nDECLARE_RTL_COND(rtl_csiar_cond)\n{\n\treturn RTL_R32(tp, CSIAR) & CSIAR_FLAG;\n}\n\nstatic void rtl_csi_write(struct rtl8169_private *tp, int addr, int value)\n{\n\tu32 func = PCI_FUNC(tp->pci_dev->devfn);\n\n\tRTL_W32(tp, CSIDR, value);\n\tRTL_W32(tp, CSIAR, CSIAR_WRITE_CMD | (addr & CSIAR_ADDR_MASK) |\n\t\tCSIAR_BYTE_ENABLE | func << 16);\n\n\trtl_loop_wait_low(tp, &rtl_csiar_cond, 10, 100);\n}\n\nstatic u32 rtl_csi_read(struct rtl8169_private *tp, int addr)\n{\n\tu32 func = PCI_FUNC(tp->pci_dev->devfn);\n\n\tRTL_W32(tp, CSIAR, (addr & CSIAR_ADDR_MASK) | func << 16 |\n\t\tCSIAR_BYTE_ENABLE);\n\n\treturn rtl_loop_wait_high(tp, &rtl_csiar_cond, 10, 100) ?\n\t\tRTL_R32(tp, CSIDR) : ~0;\n}\n\nstatic void rtl_set_aspm_entry_latency(struct rtl8169_private *tp, u8 val)\n{\n\tstruct pci_dev *pdev = tp->pci_dev;\n\tu32 csi;\n\n\t \n\tif (pdev->cfg_size > 0x070f &&\n\t    pci_write_config_byte(pdev, 0x070f, val) == PCIBIOS_SUCCESSFUL)\n\t\treturn;\n\n\tnetdev_notice_once(tp->dev,\n\t\t\"No native access to PCI extended config space, falling back to CSI\\n\");\n\tcsi = rtl_csi_read(tp, 0x070c) & 0x00ffffff;\n\trtl_csi_write(tp, 0x070c, csi | val << 24);\n}\n\nstatic void rtl_set_def_aspm_entry_latency(struct rtl8169_private *tp)\n{\n\t \n\trtl_set_aspm_entry_latency(tp, 0x27);\n}\n\nstruct ephy_info {\n\tunsigned int offset;\n\tu16 mask;\n\tu16 bits;\n};\n\nstatic void __rtl_ephy_init(struct rtl8169_private *tp,\n\t\t\t    const struct ephy_info *e, int len)\n{\n\tu16 w;\n\n\twhile (len-- > 0) {\n\t\tw = (rtl_ephy_read(tp, e->offset) & ~e->mask) | e->bits;\n\t\trtl_ephy_write(tp, e->offset, w);\n\t\te++;\n\t}\n}\n\n#define rtl_ephy_init(tp, a) __rtl_ephy_init(tp, a, ARRAY_SIZE(a))\n\nstatic void rtl_disable_clock_request(struct rtl8169_private *tp)\n{\n\tpcie_capability_clear_word(tp->pci_dev, PCI_EXP_LNKCTL,\n\t\t\t\t   PCI_EXP_LNKCTL_CLKREQ_EN);\n}\n\nstatic void rtl_enable_clock_request(struct rtl8169_private *tp)\n{\n\tpcie_capability_set_word(tp->pci_dev, PCI_EXP_LNKCTL,\n\t\t\t\t PCI_EXP_LNKCTL_CLKREQ_EN);\n}\n\nstatic void rtl_pcie_state_l2l3_disable(struct rtl8169_private *tp)\n{\n\t \n\tRTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~Rdy_to_L23);\n}\n\nstatic void rtl_enable_exit_l1(struct rtl8169_private *tp)\n{\n\t \n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_34 ... RTL_GIGA_MAC_VER_36:\n\t\trtl_eri_set_bits(tp, 0xd4, 0x1f00);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_37 ... RTL_GIGA_MAC_VER_38:\n\t\trtl_eri_set_bits(tp, 0xd4, 0x0c00);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_63:\n\t\tr8168_mac_ocp_modify(tp, 0xc0ac, 0, 0x1f80);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rtl_disable_exit_l1(struct rtl8169_private *tp)\n{\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_34 ... RTL_GIGA_MAC_VER_38:\n\t\trtl_eri_clear_bits(tp, 0xd4, 0x1f00);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_63:\n\t\tr8168_mac_ocp_modify(tp, 0xc0ac, 0x1f80, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rtl_hw_aspm_clkreq_enable(struct rtl8169_private *tp, bool enable)\n{\n\tif (tp->mac_version < RTL_GIGA_MAC_VER_32)\n\t\treturn;\n\n\t \n\tif (enable && tp->aspm_manageable) {\n\t\t \n\t\tif (tp->mac_version == RTL_GIGA_MAC_VER_42 ||\n\t\t    tp->mac_version == RTL_GIGA_MAC_VER_43)\n\t\t\treturn;\n\n\t\trtl_mod_config5(tp, 0, ASPM_en);\n\t\trtl_mod_config2(tp, 0, ClkReqEn);\n\n\t\tswitch (tp->mac_version) {\n\t\tcase RTL_GIGA_MAC_VER_46 ... RTL_GIGA_MAC_VER_48:\n\t\tcase RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_63:\n\t\t\t \n\t\t\tr8168_mac_ocp_modify(tp, 0xe094, 0xff00, 0);\n\t\t\t \n\t\t\tr8168_mac_ocp_modify(tp, 0xe092, 0x00ff, BIT(2));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (tp->mac_version) {\n\t\tcase RTL_GIGA_MAC_VER_46 ... RTL_GIGA_MAC_VER_48:\n\t\tcase RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_63:\n\t\t\tr8168_mac_ocp_modify(tp, 0xe092, 0x00ff, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\trtl_mod_config2(tp, ClkReqEn, 0);\n\t\trtl_mod_config5(tp, ASPM_en, 0);\n\t}\n}\n\nstatic void rtl_set_fifo_size(struct rtl8169_private *tp, u16 rx_stat,\n\t\t\t      u16 tx_stat, u16 rx_dyn, u16 tx_dyn)\n{\n\t \n\trtl_eri_write(tp, 0xc8, ERIAR_MASK_1111, (rx_stat << 16) | rx_dyn);\n\trtl_eri_write(tp, 0xe8, ERIAR_MASK_1111, (tx_stat << 16) | tx_dyn);\n}\n\nstatic void rtl8168g_set_pause_thresholds(struct rtl8169_private *tp,\n\t\t\t\t\t  u8 low, u8 high)\n{\n\t \n\trtl_eri_write(tp, 0xcc, ERIAR_MASK_0001, low);\n\trtl_eri_write(tp, 0xd0, ERIAR_MASK_0001, high);\n}\n\nstatic void rtl_hw_start_8168b(struct rtl8169_private *tp)\n{\n\tRTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~Beacon_en);\n}\n\nstatic void __rtl_hw_start_8168cp(struct rtl8169_private *tp)\n{\n\tRTL_W8(tp, Config1, RTL_R8(tp, Config1) | Speed_down);\n\n\tRTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~Beacon_en);\n\n\trtl_disable_clock_request(tp);\n}\n\nstatic void rtl_hw_start_8168cp_1(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8168cp[] = {\n\t\t{ 0x01, 0,\t0x0001 },\n\t\t{ 0x02, 0x0800,\t0x1000 },\n\t\t{ 0x03, 0,\t0x0042 },\n\t\t{ 0x06, 0x0080,\t0x0000 },\n\t\t{ 0x07, 0,\t0x2000 }\n\t};\n\n\trtl_set_def_aspm_entry_latency(tp);\n\n\trtl_ephy_init(tp, e_info_8168cp);\n\n\t__rtl_hw_start_8168cp(tp);\n}\n\nstatic void rtl_hw_start_8168cp_2(struct rtl8169_private *tp)\n{\n\trtl_set_def_aspm_entry_latency(tp);\n\n\tRTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~Beacon_en);\n}\n\nstatic void rtl_hw_start_8168cp_3(struct rtl8169_private *tp)\n{\n\trtl_set_def_aspm_entry_latency(tp);\n\n\tRTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~Beacon_en);\n\n\t \n\tRTL_W8(tp, DBG_REG, 0x20);\n}\n\nstatic void rtl_hw_start_8168c_1(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8168c_1[] = {\n\t\t{ 0x02, 0x0800,\t0x1000 },\n\t\t{ 0x03, 0,\t0x0002 },\n\t\t{ 0x06, 0x0080,\t0x0000 }\n\t};\n\n\trtl_set_def_aspm_entry_latency(tp);\n\n\tRTL_W8(tp, DBG_REG, 0x06 | FIX_NAK_1 | FIX_NAK_2);\n\n\trtl_ephy_init(tp, e_info_8168c_1);\n\n\t__rtl_hw_start_8168cp(tp);\n}\n\nstatic void rtl_hw_start_8168c_2(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8168c_2[] = {\n\t\t{ 0x01, 0,\t0x0001 },\n\t\t{ 0x03, 0x0400,\t0x0020 }\n\t};\n\n\trtl_set_def_aspm_entry_latency(tp);\n\n\trtl_ephy_init(tp, e_info_8168c_2);\n\n\t__rtl_hw_start_8168cp(tp);\n}\n\nstatic void rtl_hw_start_8168c_4(struct rtl8169_private *tp)\n{\n\trtl_set_def_aspm_entry_latency(tp);\n\n\t__rtl_hw_start_8168cp(tp);\n}\n\nstatic void rtl_hw_start_8168d(struct rtl8169_private *tp)\n{\n\trtl_set_def_aspm_entry_latency(tp);\n\n\trtl_disable_clock_request(tp);\n}\n\nstatic void rtl_hw_start_8168d_4(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8168d_4[] = {\n\t\t{ 0x0b, 0x0000,\t0x0048 },\n\t\t{ 0x19, 0x0020,\t0x0050 },\n\t\t{ 0x0c, 0x0100,\t0x0020 },\n\t\t{ 0x10, 0x0004,\t0x0000 },\n\t};\n\n\trtl_set_def_aspm_entry_latency(tp);\n\n\trtl_ephy_init(tp, e_info_8168d_4);\n\n\trtl_enable_clock_request(tp);\n}\n\nstatic void rtl_hw_start_8168e_1(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8168e_1[] = {\n\t\t{ 0x00, 0x0200,\t0x0100 },\n\t\t{ 0x00, 0x0000,\t0x0004 },\n\t\t{ 0x06, 0x0002,\t0x0001 },\n\t\t{ 0x06, 0x0000,\t0x0030 },\n\t\t{ 0x07, 0x0000,\t0x2000 },\n\t\t{ 0x00, 0x0000,\t0x0020 },\n\t\t{ 0x03, 0x5800,\t0x2000 },\n\t\t{ 0x03, 0x0000,\t0x0001 },\n\t\t{ 0x01, 0x0800,\t0x1000 },\n\t\t{ 0x07, 0x0000,\t0x4000 },\n\t\t{ 0x1e, 0x0000,\t0x2000 },\n\t\t{ 0x19, 0xffff,\t0xfe6c },\n\t\t{ 0x0a, 0x0000,\t0x0040 }\n\t};\n\n\trtl_set_def_aspm_entry_latency(tp);\n\n\trtl_ephy_init(tp, e_info_8168e_1);\n\n\trtl_disable_clock_request(tp);\n\n\t \n\tRTL_W32(tp, MISC, RTL_R32(tp, MISC) | TXPLA_RST);\n\tRTL_W32(tp, MISC, RTL_R32(tp, MISC) & ~TXPLA_RST);\n\n\trtl_mod_config5(tp, Spi_en, 0);\n}\n\nstatic void rtl_hw_start_8168e_2(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8168e_2[] = {\n\t\t{ 0x09, 0x0000,\t0x0080 },\n\t\t{ 0x19, 0x0000,\t0x0224 },\n\t\t{ 0x00, 0x0000,\t0x0004 },\n\t\t{ 0x0c, 0x3df0,\t0x0200 },\n\t};\n\n\trtl_set_def_aspm_entry_latency(tp);\n\n\trtl_ephy_init(tp, e_info_8168e_2);\n\n\trtl_eri_write(tp, 0xc0, ERIAR_MASK_0011, 0x0000);\n\trtl_eri_write(tp, 0xb8, ERIAR_MASK_1111, 0x0000);\n\trtl_set_fifo_size(tp, 0x10, 0x10, 0x02, 0x06);\n\trtl_eri_set_bits(tp, 0x1d0, BIT(1));\n\trtl_reset_packet_filter(tp);\n\trtl_eri_set_bits(tp, 0x1b0, BIT(4));\n\trtl_eri_write(tp, 0xcc, ERIAR_MASK_1111, 0x00000050);\n\trtl_eri_write(tp, 0xd0, ERIAR_MASK_1111, 0x07ff0060);\n\n\trtl_disable_clock_request(tp);\n\n\tRTL_W8(tp, MCU, RTL_R8(tp, MCU) & ~NOW_IS_OOB);\n\n\trtl8168_config_eee_mac(tp);\n\n\tRTL_W8(tp, DLLPR, RTL_R8(tp, DLLPR) | PFM_EN);\n\tRTL_W32(tp, MISC, RTL_R32(tp, MISC) | PWM_EN);\n\trtl_mod_config5(tp, Spi_en, 0);\n}\n\nstatic void rtl_hw_start_8168f(struct rtl8169_private *tp)\n{\n\trtl_set_def_aspm_entry_latency(tp);\n\n\trtl_eri_write(tp, 0xc0, ERIAR_MASK_0011, 0x0000);\n\trtl_eri_write(tp, 0xb8, ERIAR_MASK_1111, 0x0000);\n\trtl_set_fifo_size(tp, 0x10, 0x10, 0x02, 0x06);\n\trtl_reset_packet_filter(tp);\n\trtl_eri_set_bits(tp, 0x1b0, BIT(4));\n\trtl_eri_set_bits(tp, 0x1d0, BIT(4) | BIT(1));\n\trtl_eri_write(tp, 0xcc, ERIAR_MASK_1111, 0x00000050);\n\trtl_eri_write(tp, 0xd0, ERIAR_MASK_1111, 0x00000060);\n\n\trtl_disable_clock_request(tp);\n\n\tRTL_W8(tp, MCU, RTL_R8(tp, MCU) & ~NOW_IS_OOB);\n\tRTL_W8(tp, DLLPR, RTL_R8(tp, DLLPR) | PFM_EN);\n\tRTL_W32(tp, MISC, RTL_R32(tp, MISC) | PWM_EN);\n\trtl_mod_config5(tp, Spi_en, 0);\n\n\trtl8168_config_eee_mac(tp);\n}\n\nstatic void rtl_hw_start_8168f_1(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8168f_1[] = {\n\t\t{ 0x06, 0x00c0,\t0x0020 },\n\t\t{ 0x08, 0x0001,\t0x0002 },\n\t\t{ 0x09, 0x0000,\t0x0080 },\n\t\t{ 0x19, 0x0000,\t0x0224 },\n\t\t{ 0x00, 0x0000,\t0x0008 },\n\t\t{ 0x0c, 0x3df0,\t0x0200 },\n\t};\n\n\trtl_hw_start_8168f(tp);\n\n\trtl_ephy_init(tp, e_info_8168f_1);\n}\n\nstatic void rtl_hw_start_8411(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8168f_1[] = {\n\t\t{ 0x06, 0x00c0,\t0x0020 },\n\t\t{ 0x0f, 0xffff,\t0x5200 },\n\t\t{ 0x19, 0x0000,\t0x0224 },\n\t\t{ 0x00, 0x0000,\t0x0008 },\n\t\t{ 0x0c, 0x3df0,\t0x0200 },\n\t};\n\n\trtl_hw_start_8168f(tp);\n\trtl_pcie_state_l2l3_disable(tp);\n\n\trtl_ephy_init(tp, e_info_8168f_1);\n}\n\nstatic void rtl_hw_start_8168g(struct rtl8169_private *tp)\n{\n\trtl_set_fifo_size(tp, 0x08, 0x10, 0x02, 0x06);\n\trtl8168g_set_pause_thresholds(tp, 0x38, 0x48);\n\n\trtl_set_def_aspm_entry_latency(tp);\n\n\trtl_reset_packet_filter(tp);\n\trtl_eri_write(tp, 0x2f8, ERIAR_MASK_0011, 0x1d8f);\n\n\trtl_disable_rxdvgate(tp);\n\n\trtl_eri_write(tp, 0xc0, ERIAR_MASK_0011, 0x0000);\n\trtl_eri_write(tp, 0xb8, ERIAR_MASK_0011, 0x0000);\n\n\trtl8168_config_eee_mac(tp);\n\n\trtl_w0w1_eri(tp, 0x2fc, 0x01, 0x06);\n\trtl_eri_clear_bits(tp, 0x1b0, BIT(12));\n\n\trtl_pcie_state_l2l3_disable(tp);\n}\n\nstatic void rtl_hw_start_8168g_1(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8168g_1[] = {\n\t\t{ 0x00, 0x0008,\t0x0000 },\n\t\t{ 0x0c, 0x3ff0,\t0x0820 },\n\t\t{ 0x1e, 0x0000,\t0x0001 },\n\t\t{ 0x19, 0x8000,\t0x0000 }\n\t};\n\n\trtl_hw_start_8168g(tp);\n\trtl_ephy_init(tp, e_info_8168g_1);\n}\n\nstatic void rtl_hw_start_8168g_2(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8168g_2[] = {\n\t\t{ 0x00, 0x0008,\t0x0000 },\n\t\t{ 0x0c, 0x3ff0,\t0x0820 },\n\t\t{ 0x19, 0xffff,\t0x7c00 },\n\t\t{ 0x1e, 0xffff,\t0x20eb },\n\t\t{ 0x0d, 0xffff,\t0x1666 },\n\t\t{ 0x00, 0xffff,\t0x10a3 },\n\t\t{ 0x06, 0xffff,\t0xf050 },\n\t\t{ 0x04, 0x0000,\t0x0010 },\n\t\t{ 0x1d, 0x4000,\t0x0000 },\n\t};\n\n\trtl_hw_start_8168g(tp);\n\trtl_ephy_init(tp, e_info_8168g_2);\n}\n\nstatic void rtl_hw_start_8411_2(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8411_2[] = {\n\t\t{ 0x00, 0x0008,\t0x0000 },\n\t\t{ 0x0c, 0x37d0,\t0x0820 },\n\t\t{ 0x1e, 0x0000,\t0x0001 },\n\t\t{ 0x19, 0x8021,\t0x0000 },\n\t\t{ 0x1e, 0x0000,\t0x2000 },\n\t\t{ 0x0d, 0x0100,\t0x0200 },\n\t\t{ 0x00, 0x0000,\t0x0080 },\n\t\t{ 0x06, 0x0000,\t0x0010 },\n\t\t{ 0x04, 0x0000,\t0x0010 },\n\t\t{ 0x1d, 0x0000,\t0x4000 },\n\t};\n\n\trtl_hw_start_8168g(tp);\n\n\trtl_ephy_init(tp, e_info_8411_2);\n\n\t \n\tr8168_mac_ocp_write(tp, 0xFC28, 0x0000);\n\tr8168_mac_ocp_write(tp, 0xFC2A, 0x0000);\n\tr8168_mac_ocp_write(tp, 0xFC2C, 0x0000);\n\tr8168_mac_ocp_write(tp, 0xFC2E, 0x0000);\n\tr8168_mac_ocp_write(tp, 0xFC30, 0x0000);\n\tr8168_mac_ocp_write(tp, 0xFC32, 0x0000);\n\tr8168_mac_ocp_write(tp, 0xFC34, 0x0000);\n\tr8168_mac_ocp_write(tp, 0xFC36, 0x0000);\n\tmdelay(3);\n\tr8168_mac_ocp_write(tp, 0xFC26, 0x0000);\n\n\tr8168_mac_ocp_write(tp, 0xF800, 0xE008);\n\tr8168_mac_ocp_write(tp, 0xF802, 0xE00A);\n\tr8168_mac_ocp_write(tp, 0xF804, 0xE00C);\n\tr8168_mac_ocp_write(tp, 0xF806, 0xE00E);\n\tr8168_mac_ocp_write(tp, 0xF808, 0xE027);\n\tr8168_mac_ocp_write(tp, 0xF80A, 0xE04F);\n\tr8168_mac_ocp_write(tp, 0xF80C, 0xE05E);\n\tr8168_mac_ocp_write(tp, 0xF80E, 0xE065);\n\tr8168_mac_ocp_write(tp, 0xF810, 0xC602);\n\tr8168_mac_ocp_write(tp, 0xF812, 0xBE00);\n\tr8168_mac_ocp_write(tp, 0xF814, 0x0000);\n\tr8168_mac_ocp_write(tp, 0xF816, 0xC502);\n\tr8168_mac_ocp_write(tp, 0xF818, 0xBD00);\n\tr8168_mac_ocp_write(tp, 0xF81A, 0x074C);\n\tr8168_mac_ocp_write(tp, 0xF81C, 0xC302);\n\tr8168_mac_ocp_write(tp, 0xF81E, 0xBB00);\n\tr8168_mac_ocp_write(tp, 0xF820, 0x080A);\n\tr8168_mac_ocp_write(tp, 0xF822, 0x6420);\n\tr8168_mac_ocp_write(tp, 0xF824, 0x48C2);\n\tr8168_mac_ocp_write(tp, 0xF826, 0x8C20);\n\tr8168_mac_ocp_write(tp, 0xF828, 0xC516);\n\tr8168_mac_ocp_write(tp, 0xF82A, 0x64A4);\n\tr8168_mac_ocp_write(tp, 0xF82C, 0x49C0);\n\tr8168_mac_ocp_write(tp, 0xF82E, 0xF009);\n\tr8168_mac_ocp_write(tp, 0xF830, 0x74A2);\n\tr8168_mac_ocp_write(tp, 0xF832, 0x8CA5);\n\tr8168_mac_ocp_write(tp, 0xF834, 0x74A0);\n\tr8168_mac_ocp_write(tp, 0xF836, 0xC50E);\n\tr8168_mac_ocp_write(tp, 0xF838, 0x9CA2);\n\tr8168_mac_ocp_write(tp, 0xF83A, 0x1C11);\n\tr8168_mac_ocp_write(tp, 0xF83C, 0x9CA0);\n\tr8168_mac_ocp_write(tp, 0xF83E, 0xE006);\n\tr8168_mac_ocp_write(tp, 0xF840, 0x74F8);\n\tr8168_mac_ocp_write(tp, 0xF842, 0x48C4);\n\tr8168_mac_ocp_write(tp, 0xF844, 0x8CF8);\n\tr8168_mac_ocp_write(tp, 0xF846, 0xC404);\n\tr8168_mac_ocp_write(tp, 0xF848, 0xBC00);\n\tr8168_mac_ocp_write(tp, 0xF84A, 0xC403);\n\tr8168_mac_ocp_write(tp, 0xF84C, 0xBC00);\n\tr8168_mac_ocp_write(tp, 0xF84E, 0x0BF2);\n\tr8168_mac_ocp_write(tp, 0xF850, 0x0C0A);\n\tr8168_mac_ocp_write(tp, 0xF852, 0xE434);\n\tr8168_mac_ocp_write(tp, 0xF854, 0xD3C0);\n\tr8168_mac_ocp_write(tp, 0xF856, 0x49D9);\n\tr8168_mac_ocp_write(tp, 0xF858, 0xF01F);\n\tr8168_mac_ocp_write(tp, 0xF85A, 0xC526);\n\tr8168_mac_ocp_write(tp, 0xF85C, 0x64A5);\n\tr8168_mac_ocp_write(tp, 0xF85E, 0x1400);\n\tr8168_mac_ocp_write(tp, 0xF860, 0xF007);\n\tr8168_mac_ocp_write(tp, 0xF862, 0x0C01);\n\tr8168_mac_ocp_write(tp, 0xF864, 0x8CA5);\n\tr8168_mac_ocp_write(tp, 0xF866, 0x1C15);\n\tr8168_mac_ocp_write(tp, 0xF868, 0xC51B);\n\tr8168_mac_ocp_write(tp, 0xF86A, 0x9CA0);\n\tr8168_mac_ocp_write(tp, 0xF86C, 0xE013);\n\tr8168_mac_ocp_write(tp, 0xF86E, 0xC519);\n\tr8168_mac_ocp_write(tp, 0xF870, 0x74A0);\n\tr8168_mac_ocp_write(tp, 0xF872, 0x48C4);\n\tr8168_mac_ocp_write(tp, 0xF874, 0x8CA0);\n\tr8168_mac_ocp_write(tp, 0xF876, 0xC516);\n\tr8168_mac_ocp_write(tp, 0xF878, 0x74A4);\n\tr8168_mac_ocp_write(tp, 0xF87A, 0x48C8);\n\tr8168_mac_ocp_write(tp, 0xF87C, 0x48CA);\n\tr8168_mac_ocp_write(tp, 0xF87E, 0x9CA4);\n\tr8168_mac_ocp_write(tp, 0xF880, 0xC512);\n\tr8168_mac_ocp_write(tp, 0xF882, 0x1B00);\n\tr8168_mac_ocp_write(tp, 0xF884, 0x9BA0);\n\tr8168_mac_ocp_write(tp, 0xF886, 0x1B1C);\n\tr8168_mac_ocp_write(tp, 0xF888, 0x483F);\n\tr8168_mac_ocp_write(tp, 0xF88A, 0x9BA2);\n\tr8168_mac_ocp_write(tp, 0xF88C, 0x1B04);\n\tr8168_mac_ocp_write(tp, 0xF88E, 0xC508);\n\tr8168_mac_ocp_write(tp, 0xF890, 0x9BA0);\n\tr8168_mac_ocp_write(tp, 0xF892, 0xC505);\n\tr8168_mac_ocp_write(tp, 0xF894, 0xBD00);\n\tr8168_mac_ocp_write(tp, 0xF896, 0xC502);\n\tr8168_mac_ocp_write(tp, 0xF898, 0xBD00);\n\tr8168_mac_ocp_write(tp, 0xF89A, 0x0300);\n\tr8168_mac_ocp_write(tp, 0xF89C, 0x051E);\n\tr8168_mac_ocp_write(tp, 0xF89E, 0xE434);\n\tr8168_mac_ocp_write(tp, 0xF8A0, 0xE018);\n\tr8168_mac_ocp_write(tp, 0xF8A2, 0xE092);\n\tr8168_mac_ocp_write(tp, 0xF8A4, 0xDE20);\n\tr8168_mac_ocp_write(tp, 0xF8A6, 0xD3C0);\n\tr8168_mac_ocp_write(tp, 0xF8A8, 0xC50F);\n\tr8168_mac_ocp_write(tp, 0xF8AA, 0x76A4);\n\tr8168_mac_ocp_write(tp, 0xF8AC, 0x49E3);\n\tr8168_mac_ocp_write(tp, 0xF8AE, 0xF007);\n\tr8168_mac_ocp_write(tp, 0xF8B0, 0x49C0);\n\tr8168_mac_ocp_write(tp, 0xF8B2, 0xF103);\n\tr8168_mac_ocp_write(tp, 0xF8B4, 0xC607);\n\tr8168_mac_ocp_write(tp, 0xF8B6, 0xBE00);\n\tr8168_mac_ocp_write(tp, 0xF8B8, 0xC606);\n\tr8168_mac_ocp_write(tp, 0xF8BA, 0xBE00);\n\tr8168_mac_ocp_write(tp, 0xF8BC, 0xC602);\n\tr8168_mac_ocp_write(tp, 0xF8BE, 0xBE00);\n\tr8168_mac_ocp_write(tp, 0xF8C0, 0x0C4C);\n\tr8168_mac_ocp_write(tp, 0xF8C2, 0x0C28);\n\tr8168_mac_ocp_write(tp, 0xF8C4, 0x0C2C);\n\tr8168_mac_ocp_write(tp, 0xF8C6, 0xDC00);\n\tr8168_mac_ocp_write(tp, 0xF8C8, 0xC707);\n\tr8168_mac_ocp_write(tp, 0xF8CA, 0x1D00);\n\tr8168_mac_ocp_write(tp, 0xF8CC, 0x8DE2);\n\tr8168_mac_ocp_write(tp, 0xF8CE, 0x48C1);\n\tr8168_mac_ocp_write(tp, 0xF8D0, 0xC502);\n\tr8168_mac_ocp_write(tp, 0xF8D2, 0xBD00);\n\tr8168_mac_ocp_write(tp, 0xF8D4, 0x00AA);\n\tr8168_mac_ocp_write(tp, 0xF8D6, 0xE0C0);\n\tr8168_mac_ocp_write(tp, 0xF8D8, 0xC502);\n\tr8168_mac_ocp_write(tp, 0xF8DA, 0xBD00);\n\tr8168_mac_ocp_write(tp, 0xF8DC, 0x0132);\n\n\tr8168_mac_ocp_write(tp, 0xFC26, 0x8000);\n\n\tr8168_mac_ocp_write(tp, 0xFC2A, 0x0743);\n\tr8168_mac_ocp_write(tp, 0xFC2C, 0x0801);\n\tr8168_mac_ocp_write(tp, 0xFC2E, 0x0BE9);\n\tr8168_mac_ocp_write(tp, 0xFC30, 0x02FD);\n\tr8168_mac_ocp_write(tp, 0xFC32, 0x0C25);\n\tr8168_mac_ocp_write(tp, 0xFC34, 0x00A9);\n\tr8168_mac_ocp_write(tp, 0xFC36, 0x012D);\n}\n\nstatic void rtl_hw_start_8168h_1(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8168h_1[] = {\n\t\t{ 0x1e, 0x0800,\t0x0001 },\n\t\t{ 0x1d, 0x0000,\t0x0800 },\n\t\t{ 0x05, 0xffff,\t0x2089 },\n\t\t{ 0x06, 0xffff,\t0x5881 },\n\t\t{ 0x04, 0xffff,\t0x854a },\n\t\t{ 0x01, 0xffff,\t0x068b }\n\t};\n\tint rg_saw_cnt;\n\n\trtl_ephy_init(tp, e_info_8168h_1);\n\n\trtl_set_fifo_size(tp, 0x08, 0x10, 0x02, 0x06);\n\trtl8168g_set_pause_thresholds(tp, 0x38, 0x48);\n\n\trtl_set_def_aspm_entry_latency(tp);\n\n\trtl_reset_packet_filter(tp);\n\n\trtl_eri_set_bits(tp, 0xdc, 0x001c);\n\n\trtl_eri_write(tp, 0x5f0, ERIAR_MASK_0011, 0x4f87);\n\n\trtl_disable_rxdvgate(tp);\n\n\trtl_eri_write(tp, 0xc0, ERIAR_MASK_0011, 0x0000);\n\trtl_eri_write(tp, 0xb8, ERIAR_MASK_0011, 0x0000);\n\n\trtl8168_config_eee_mac(tp);\n\n\tRTL_W8(tp, DLLPR, RTL_R8(tp, DLLPR) & ~PFM_EN);\n\tRTL_W8(tp, MISC_1, RTL_R8(tp, MISC_1) & ~PFM_D3COLD_EN);\n\n\tRTL_W8(tp, DLLPR, RTL_R8(tp, DLLPR) & ~TX_10M_PS_EN);\n\n\trtl_eri_clear_bits(tp, 0x1b0, BIT(12));\n\n\trtl_pcie_state_l2l3_disable(tp);\n\n\trg_saw_cnt = phy_read_paged(tp->phydev, 0x0c42, 0x13) & 0x3fff;\n\tif (rg_saw_cnt > 0) {\n\t\tu16 sw_cnt_1ms_ini;\n\n\t\tsw_cnt_1ms_ini = 16000000/rg_saw_cnt;\n\t\tsw_cnt_1ms_ini &= 0x0fff;\n\t\tr8168_mac_ocp_modify(tp, 0xd412, 0x0fff, sw_cnt_1ms_ini);\n\t}\n\n\tr8168_mac_ocp_modify(tp, 0xe056, 0x00f0, 0x0070);\n\tr8168_mac_ocp_modify(tp, 0xe052, 0x6000, 0x8008);\n\tr8168_mac_ocp_modify(tp, 0xe0d6, 0x01ff, 0x017f);\n\tr8168_mac_ocp_modify(tp, 0xd420, 0x0fff, 0x047f);\n\n\tr8168_mac_ocp_write(tp, 0xe63e, 0x0001);\n\tr8168_mac_ocp_write(tp, 0xe63e, 0x0000);\n\tr8168_mac_ocp_write(tp, 0xc094, 0x0000);\n\tr8168_mac_ocp_write(tp, 0xc09e, 0x0000);\n}\n\nstatic void rtl_hw_start_8168ep(struct rtl8169_private *tp)\n{\n\trtl8168ep_stop_cmac(tp);\n\n\trtl_set_fifo_size(tp, 0x08, 0x10, 0x02, 0x06);\n\trtl8168g_set_pause_thresholds(tp, 0x2f, 0x5f);\n\n\trtl_set_def_aspm_entry_latency(tp);\n\n\trtl_reset_packet_filter(tp);\n\n\trtl_eri_write(tp, 0x5f0, ERIAR_MASK_0011, 0x4f87);\n\n\trtl_disable_rxdvgate(tp);\n\n\trtl_eri_write(tp, 0xc0, ERIAR_MASK_0011, 0x0000);\n\trtl_eri_write(tp, 0xb8, ERIAR_MASK_0011, 0x0000);\n\n\trtl8168_config_eee_mac(tp);\n\n\trtl_w0w1_eri(tp, 0x2fc, 0x01, 0x06);\n\n\tRTL_W8(tp, DLLPR, RTL_R8(tp, DLLPR) & ~TX_10M_PS_EN);\n\n\trtl_pcie_state_l2l3_disable(tp);\n}\n\nstatic void rtl_hw_start_8168ep_3(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8168ep_3[] = {\n\t\t{ 0x00, 0x0000,\t0x0080 },\n\t\t{ 0x0d, 0x0100,\t0x0200 },\n\t\t{ 0x19, 0x8021,\t0x0000 },\n\t\t{ 0x1e, 0x0000,\t0x2000 },\n\t};\n\n\trtl_ephy_init(tp, e_info_8168ep_3);\n\n\trtl_hw_start_8168ep(tp);\n\n\tRTL_W8(tp, DLLPR, RTL_R8(tp, DLLPR) & ~PFM_EN);\n\tRTL_W8(tp, MISC_1, RTL_R8(tp, MISC_1) & ~PFM_D3COLD_EN);\n\n\tr8168_mac_ocp_modify(tp, 0xd3e2, 0x0fff, 0x0271);\n\tr8168_mac_ocp_modify(tp, 0xd3e4, 0x00ff, 0x0000);\n\tr8168_mac_ocp_modify(tp, 0xe860, 0x0000, 0x0080);\n}\n\nstatic void rtl_hw_start_8117(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8117[] = {\n\t\t{ 0x19, 0x0040,\t0x1100 },\n\t\t{ 0x59, 0x0040,\t0x1100 },\n\t};\n\tint rg_saw_cnt;\n\n\trtl8168ep_stop_cmac(tp);\n\trtl_ephy_init(tp, e_info_8117);\n\n\trtl_set_fifo_size(tp, 0x08, 0x10, 0x02, 0x06);\n\trtl8168g_set_pause_thresholds(tp, 0x2f, 0x5f);\n\n\trtl_set_def_aspm_entry_latency(tp);\n\n\trtl_reset_packet_filter(tp);\n\n\trtl_eri_set_bits(tp, 0xd4, 0x0010);\n\n\trtl_eri_write(tp, 0x5f0, ERIAR_MASK_0011, 0x4f87);\n\n\trtl_disable_rxdvgate(tp);\n\n\trtl_eri_write(tp, 0xc0, ERIAR_MASK_0011, 0x0000);\n\trtl_eri_write(tp, 0xb8, ERIAR_MASK_0011, 0x0000);\n\n\trtl8168_config_eee_mac(tp);\n\n\tRTL_W8(tp, DLLPR, RTL_R8(tp, DLLPR) & ~PFM_EN);\n\tRTL_W8(tp, MISC_1, RTL_R8(tp, MISC_1) & ~PFM_D3COLD_EN);\n\n\tRTL_W8(tp, DLLPR, RTL_R8(tp, DLLPR) & ~TX_10M_PS_EN);\n\n\trtl_eri_clear_bits(tp, 0x1b0, BIT(12));\n\n\trtl_pcie_state_l2l3_disable(tp);\n\n\trg_saw_cnt = phy_read_paged(tp->phydev, 0x0c42, 0x13) & 0x3fff;\n\tif (rg_saw_cnt > 0) {\n\t\tu16 sw_cnt_1ms_ini;\n\n\t\tsw_cnt_1ms_ini = (16000000 / rg_saw_cnt) & 0x0fff;\n\t\tr8168_mac_ocp_modify(tp, 0xd412, 0x0fff, sw_cnt_1ms_ini);\n\t}\n\n\tr8168_mac_ocp_modify(tp, 0xe056, 0x00f0, 0x0070);\n\tr8168_mac_ocp_write(tp, 0xea80, 0x0003);\n\tr8168_mac_ocp_modify(tp, 0xe052, 0x0000, 0x0009);\n\tr8168_mac_ocp_modify(tp, 0xd420, 0x0fff, 0x047f);\n\n\tr8168_mac_ocp_write(tp, 0xe63e, 0x0001);\n\tr8168_mac_ocp_write(tp, 0xe63e, 0x0000);\n\tr8168_mac_ocp_write(tp, 0xc094, 0x0000);\n\tr8168_mac_ocp_write(tp, 0xc09e, 0x0000);\n\n\t \n\tr8169_apply_firmware(tp);\n}\n\nstatic void rtl_hw_start_8102e_1(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8102e_1[] = {\n\t\t{ 0x01,\t0, 0x6e65 },\n\t\t{ 0x02,\t0, 0x091f },\n\t\t{ 0x03,\t0, 0xc2f9 },\n\t\t{ 0x06,\t0, 0xafb5 },\n\t\t{ 0x07,\t0, 0x0e00 },\n\t\t{ 0x19,\t0, 0xec80 },\n\t\t{ 0x01,\t0, 0x2e65 },\n\t\t{ 0x01,\t0, 0x6e65 }\n\t};\n\tu8 cfg1;\n\n\trtl_set_def_aspm_entry_latency(tp);\n\n\tRTL_W8(tp, DBG_REG, FIX_NAK_1);\n\n\tRTL_W8(tp, Config1,\n\t       LEDS1 | LEDS0 | Speed_down | MEMMAP | IOMAP | VPD | PMEnable);\n\tRTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~Beacon_en);\n\n\tcfg1 = RTL_R8(tp, Config1);\n\tif ((cfg1 & LEDS0) && (cfg1 & LEDS1))\n\t\tRTL_W8(tp, Config1, cfg1 & ~LEDS0);\n\n\trtl_ephy_init(tp, e_info_8102e_1);\n}\n\nstatic void rtl_hw_start_8102e_2(struct rtl8169_private *tp)\n{\n\trtl_set_def_aspm_entry_latency(tp);\n\n\tRTL_W8(tp, Config1, MEMMAP | IOMAP | VPD | PMEnable);\n\tRTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~Beacon_en);\n}\n\nstatic void rtl_hw_start_8102e_3(struct rtl8169_private *tp)\n{\n\trtl_hw_start_8102e_2(tp);\n\n\trtl_ephy_write(tp, 0x03, 0xc2f9);\n}\n\nstatic void rtl_hw_start_8401(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8401[] = {\n\t\t{ 0x01,\t0xffff, 0x6fe5 },\n\t\t{ 0x03,\t0xffff, 0x0599 },\n\t\t{ 0x06,\t0xffff, 0xaf25 },\n\t\t{ 0x07,\t0xffff, 0x8e68 },\n\t};\n\n\trtl_ephy_init(tp, e_info_8401);\n\tRTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~Beacon_en);\n}\n\nstatic void rtl_hw_start_8105e_1(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8105e_1[] = {\n\t\t{ 0x07,\t0, 0x4000 },\n\t\t{ 0x19,\t0, 0x0200 },\n\t\t{ 0x19,\t0, 0x0020 },\n\t\t{ 0x1e,\t0, 0x2000 },\n\t\t{ 0x03,\t0, 0x0001 },\n\t\t{ 0x19,\t0, 0x0100 },\n\t\t{ 0x19,\t0, 0x0004 },\n\t\t{ 0x0a,\t0, 0x0020 }\n\t};\n\n\t \n\tRTL_W32(tp, FuncEvent, RTL_R32(tp, FuncEvent) | 0x002800);\n\n\t \n\tRTL_W32(tp, FuncEvent, RTL_R32(tp, FuncEvent) & ~0x010000);\n\n\tRTL_W8(tp, MCU, RTL_R8(tp, MCU) | EN_NDP | EN_OOB_RESET);\n\tRTL_W8(tp, DLLPR, RTL_R8(tp, DLLPR) | PFM_EN);\n\n\trtl_ephy_init(tp, e_info_8105e_1);\n\n\trtl_pcie_state_l2l3_disable(tp);\n}\n\nstatic void rtl_hw_start_8105e_2(struct rtl8169_private *tp)\n{\n\trtl_hw_start_8105e_1(tp);\n\trtl_ephy_write(tp, 0x1e, rtl_ephy_read(tp, 0x1e) | 0x8000);\n}\n\nstatic void rtl_hw_start_8402(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8402[] = {\n\t\t{ 0x19,\t0xffff, 0xff64 },\n\t\t{ 0x1e,\t0, 0x4000 }\n\t};\n\n\trtl_set_def_aspm_entry_latency(tp);\n\n\t \n\tRTL_W32(tp, FuncEvent, RTL_R32(tp, FuncEvent) | 0x002800);\n\n\tRTL_W8(tp, MCU, RTL_R8(tp, MCU) & ~NOW_IS_OOB);\n\n\trtl_ephy_init(tp, e_info_8402);\n\n\trtl_set_fifo_size(tp, 0x00, 0x00, 0x02, 0x06);\n\trtl_reset_packet_filter(tp);\n\trtl_eri_write(tp, 0xc0, ERIAR_MASK_0011, 0x0000);\n\trtl_eri_write(tp, 0xb8, ERIAR_MASK_0011, 0x0000);\n\trtl_w0w1_eri(tp, 0x0d4, 0x0e00, 0xff00);\n\n\t \n\trtl_eri_write(tp, 0x1b0, ERIAR_MASK_0011, 0x0000);\n\n\trtl_pcie_state_l2l3_disable(tp);\n}\n\nstatic void rtl_hw_start_8106(struct rtl8169_private *tp)\n{\n\t \n\tRTL_W32(tp, FuncEvent, RTL_R32(tp, FuncEvent) | 0x002800);\n\n\tRTL_W32(tp, MISC, (RTL_R32(tp, MISC) | DISABLE_LAN_EN) & ~EARLY_TALLY_EN);\n\tRTL_W8(tp, MCU, RTL_R8(tp, MCU) | EN_NDP | EN_OOB_RESET);\n\tRTL_W8(tp, DLLPR, RTL_R8(tp, DLLPR) & ~PFM_EN);\n\n\t \n\trtl_set_aspm_entry_latency(tp, 0x2f);\n\n\trtl_eri_write(tp, 0x1d0, ERIAR_MASK_0011, 0x0000);\n\n\t \n\trtl_eri_write(tp, 0x1b0, ERIAR_MASK_0011, 0x0000);\n\n\trtl_pcie_state_l2l3_disable(tp);\n}\n\nDECLARE_RTL_COND(rtl_mac_ocp_e00e_cond)\n{\n\treturn r8168_mac_ocp_read(tp, 0xe00e) & BIT(13);\n}\n\nstatic void rtl_hw_start_8125_common(struct rtl8169_private *tp)\n{\n\trtl_pcie_state_l2l3_disable(tp);\n\n\tRTL_W16(tp, 0x382, 0x221b);\n\tRTL_W8(tp, 0x4500, 0);\n\tRTL_W16(tp, 0x4800, 0);\n\n\t \n\tr8168_mac_ocp_modify(tp, 0xd40a, 0x0010, 0x0000);\n\n\tRTL_W8(tp, Config1, RTL_R8(tp, Config1) & ~0x10);\n\n\tr8168_mac_ocp_write(tp, 0xc140, 0xffff);\n\tr8168_mac_ocp_write(tp, 0xc142, 0xffff);\n\n\tr8168_mac_ocp_modify(tp, 0xd3e2, 0x0fff, 0x03a9);\n\tr8168_mac_ocp_modify(tp, 0xd3e4, 0x00ff, 0x0000);\n\tr8168_mac_ocp_modify(tp, 0xe860, 0x0000, 0x0080);\n\n\t \n\tr8168_mac_ocp_modify(tp, 0xeb58, 0x0001, 0x0000);\n\n\tif (tp->mac_version == RTL_GIGA_MAC_VER_63)\n\t\tr8168_mac_ocp_modify(tp, 0xe614, 0x0700, 0x0200);\n\telse\n\t\tr8168_mac_ocp_modify(tp, 0xe614, 0x0700, 0x0400);\n\n\tif (tp->mac_version == RTL_GIGA_MAC_VER_63)\n\t\tr8168_mac_ocp_modify(tp, 0xe63e, 0x0c30, 0x0000);\n\telse\n\t\tr8168_mac_ocp_modify(tp, 0xe63e, 0x0c30, 0x0020);\n\n\tr8168_mac_ocp_modify(tp, 0xc0b4, 0x0000, 0x000c);\n\tr8168_mac_ocp_modify(tp, 0xeb6a, 0x00ff, 0x0033);\n\tr8168_mac_ocp_modify(tp, 0xeb50, 0x03e0, 0x0040);\n\tr8168_mac_ocp_modify(tp, 0xe056, 0x00f0, 0x0030);\n\tr8168_mac_ocp_modify(tp, 0xe040, 0x1000, 0x0000);\n\tr8168_mac_ocp_modify(tp, 0xea1c, 0x0003, 0x0001);\n\tr8168_mac_ocp_modify(tp, 0xe0c0, 0x4f0f, 0x4403);\n\tr8168_mac_ocp_modify(tp, 0xe052, 0x0080, 0x0068);\n\tr8168_mac_ocp_modify(tp, 0xd430, 0x0fff, 0x047f);\n\n\tr8168_mac_ocp_modify(tp, 0xea1c, 0x0004, 0x0000);\n\tr8168_mac_ocp_modify(tp, 0xeb54, 0x0000, 0x0001);\n\tudelay(1);\n\tr8168_mac_ocp_modify(tp, 0xeb54, 0x0001, 0x0000);\n\tRTL_W16(tp, 0x1880, RTL_R16(tp, 0x1880) & ~0x0030);\n\n\tr8168_mac_ocp_write(tp, 0xe098, 0xc302);\n\n\trtl_loop_wait_low(tp, &rtl_mac_ocp_e00e_cond, 1000, 10);\n\n\tif (tp->mac_version == RTL_GIGA_MAC_VER_63)\n\t\trtl8125b_config_eee_mac(tp);\n\telse\n\t\trtl8125a_config_eee_mac(tp);\n\n\trtl_disable_rxdvgate(tp);\n}\n\nstatic void rtl_hw_start_8125a_2(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8125a_2[] = {\n\t\t{ 0x04, 0xffff, 0xd000 },\n\t\t{ 0x0a, 0xffff, 0x8653 },\n\t\t{ 0x23, 0xffff, 0xab66 },\n\t\t{ 0x20, 0xffff, 0x9455 },\n\t\t{ 0x21, 0xffff, 0x99ff },\n\t\t{ 0x29, 0xffff, 0xfe04 },\n\n\t\t{ 0x44, 0xffff, 0xd000 },\n\t\t{ 0x4a, 0xffff, 0x8653 },\n\t\t{ 0x63, 0xffff, 0xab66 },\n\t\t{ 0x60, 0xffff, 0x9455 },\n\t\t{ 0x61, 0xffff, 0x99ff },\n\t\t{ 0x69, 0xffff, 0xfe04 },\n\t};\n\n\trtl_set_def_aspm_entry_latency(tp);\n\trtl_ephy_init(tp, e_info_8125a_2);\n\trtl_hw_start_8125_common(tp);\n}\n\nstatic void rtl_hw_start_8125b(struct rtl8169_private *tp)\n{\n\tstatic const struct ephy_info e_info_8125b[] = {\n\t\t{ 0x0b, 0xffff, 0xa908 },\n\t\t{ 0x1e, 0xffff, 0x20eb },\n\t\t{ 0x4b, 0xffff, 0xa908 },\n\t\t{ 0x5e, 0xffff, 0x20eb },\n\t\t{ 0x22, 0x0030, 0x0020 },\n\t\t{ 0x62, 0x0030, 0x0020 },\n\t};\n\n\trtl_set_def_aspm_entry_latency(tp);\n\trtl_ephy_init(tp, e_info_8125b);\n\trtl_hw_start_8125_common(tp);\n}\n\nstatic void rtl_hw_config(struct rtl8169_private *tp)\n{\n\tstatic const rtl_generic_fct hw_configs[] = {\n\t\t[RTL_GIGA_MAC_VER_07] = rtl_hw_start_8102e_1,\n\t\t[RTL_GIGA_MAC_VER_08] = rtl_hw_start_8102e_3,\n\t\t[RTL_GIGA_MAC_VER_09] = rtl_hw_start_8102e_2,\n\t\t[RTL_GIGA_MAC_VER_10] = NULL,\n\t\t[RTL_GIGA_MAC_VER_11] = rtl_hw_start_8168b,\n\t\t[RTL_GIGA_MAC_VER_14] = rtl_hw_start_8401,\n\t\t[RTL_GIGA_MAC_VER_17] = rtl_hw_start_8168b,\n\t\t[RTL_GIGA_MAC_VER_18] = rtl_hw_start_8168cp_1,\n\t\t[RTL_GIGA_MAC_VER_19] = rtl_hw_start_8168c_1,\n\t\t[RTL_GIGA_MAC_VER_20] = rtl_hw_start_8168c_2,\n\t\t[RTL_GIGA_MAC_VER_21] = rtl_hw_start_8168c_2,\n\t\t[RTL_GIGA_MAC_VER_22] = rtl_hw_start_8168c_4,\n\t\t[RTL_GIGA_MAC_VER_23] = rtl_hw_start_8168cp_2,\n\t\t[RTL_GIGA_MAC_VER_24] = rtl_hw_start_8168cp_3,\n\t\t[RTL_GIGA_MAC_VER_25] = rtl_hw_start_8168d,\n\t\t[RTL_GIGA_MAC_VER_26] = rtl_hw_start_8168d,\n\t\t[RTL_GIGA_MAC_VER_28] = rtl_hw_start_8168d_4,\n\t\t[RTL_GIGA_MAC_VER_29] = rtl_hw_start_8105e_1,\n\t\t[RTL_GIGA_MAC_VER_30] = rtl_hw_start_8105e_2,\n\t\t[RTL_GIGA_MAC_VER_31] = rtl_hw_start_8168d,\n\t\t[RTL_GIGA_MAC_VER_32] = rtl_hw_start_8168e_1,\n\t\t[RTL_GIGA_MAC_VER_33] = rtl_hw_start_8168e_1,\n\t\t[RTL_GIGA_MAC_VER_34] = rtl_hw_start_8168e_2,\n\t\t[RTL_GIGA_MAC_VER_35] = rtl_hw_start_8168f_1,\n\t\t[RTL_GIGA_MAC_VER_36] = rtl_hw_start_8168f_1,\n\t\t[RTL_GIGA_MAC_VER_37] = rtl_hw_start_8402,\n\t\t[RTL_GIGA_MAC_VER_38] = rtl_hw_start_8411,\n\t\t[RTL_GIGA_MAC_VER_39] = rtl_hw_start_8106,\n\t\t[RTL_GIGA_MAC_VER_40] = rtl_hw_start_8168g_1,\n\t\t[RTL_GIGA_MAC_VER_42] = rtl_hw_start_8168g_2,\n\t\t[RTL_GIGA_MAC_VER_43] = rtl_hw_start_8168g_2,\n\t\t[RTL_GIGA_MAC_VER_44] = rtl_hw_start_8411_2,\n\t\t[RTL_GIGA_MAC_VER_46] = rtl_hw_start_8168h_1,\n\t\t[RTL_GIGA_MAC_VER_48] = rtl_hw_start_8168h_1,\n\t\t[RTL_GIGA_MAC_VER_51] = rtl_hw_start_8168ep_3,\n\t\t[RTL_GIGA_MAC_VER_52] = rtl_hw_start_8117,\n\t\t[RTL_GIGA_MAC_VER_53] = rtl_hw_start_8117,\n\t\t[RTL_GIGA_MAC_VER_61] = rtl_hw_start_8125a_2,\n\t\t[RTL_GIGA_MAC_VER_63] = rtl_hw_start_8125b,\n\t};\n\n\tif (hw_configs[tp->mac_version])\n\t\thw_configs[tp->mac_version](tp);\n}\n\nstatic void rtl_hw_start_8125(struct rtl8169_private *tp)\n{\n\tint i;\n\n\t \n\tfor (i = 0xa00; i < 0xb00; i += 4)\n\t\tRTL_W32(tp, i, 0);\n\n\trtl_hw_config(tp);\n}\n\nstatic void rtl_hw_start_8168(struct rtl8169_private *tp)\n{\n\tif (rtl_is_8168evl_up(tp))\n\t\tRTL_W8(tp, MaxTxPacketSize, EarlySize);\n\telse\n\t\tRTL_W8(tp, MaxTxPacketSize, TxPacketMax);\n\n\trtl_hw_config(tp);\n\n\t \n\tRTL_W16(tp, IntrMitigate, 0x0000);\n}\n\nstatic void rtl_hw_start_8169(struct rtl8169_private *tp)\n{\n\tRTL_W8(tp, EarlyTxThres, NoEarlyTx);\n\n\ttp->cp_cmd |= PCIMulRW;\n\n\tif (tp->mac_version == RTL_GIGA_MAC_VER_02 ||\n\t    tp->mac_version == RTL_GIGA_MAC_VER_03)\n\t\ttp->cp_cmd |= EnAnaPLL;\n\n\tRTL_W16(tp, CPlusCmd, tp->cp_cmd);\n\n\trtl8169_set_magic_reg(tp);\n\n\t \n\tRTL_W16(tp, IntrMitigate, 0x0000);\n}\n\nstatic void rtl_hw_start(struct  rtl8169_private *tp)\n{\n\trtl_unlock_config_regs(tp);\n\t \n\trtl_hw_aspm_clkreq_enable(tp, false);\n\tRTL_W16(tp, CPlusCmd, tp->cp_cmd);\n\n\tif (tp->mac_version <= RTL_GIGA_MAC_VER_06)\n\t\trtl_hw_start_8169(tp);\n\telse if (rtl_is_8125(tp))\n\t\trtl_hw_start_8125(tp);\n\telse\n\t\trtl_hw_start_8168(tp);\n\n\trtl_enable_exit_l1(tp);\n\trtl_hw_aspm_clkreq_enable(tp, true);\n\trtl_set_rx_max_size(tp);\n\trtl_set_rx_tx_desc_registers(tp);\n\trtl_lock_config_regs(tp);\n\n\trtl_jumbo_config(tp);\n\n\t \n\trtl_pci_commit(tp);\n\n\tRTL_W8(tp, ChipCmd, CmdTxEnb | CmdRxEnb);\n\trtl_init_rxcfg(tp);\n\trtl_set_tx_config_registers(tp);\n\trtl_set_rx_config_features(tp, tp->dev->features);\n\trtl_set_rx_mode(tp->dev);\n\trtl_irq_enable(tp);\n}\n\nstatic int rtl8169_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\n\tdev->mtu = new_mtu;\n\tnetdev_update_features(dev);\n\trtl_jumbo_config(tp);\n\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_61:\n\tcase RTL_GIGA_MAC_VER_63:\n\t\trtl8125_set_eee_txidle_timer(tp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtl8169_mark_to_asic(struct RxDesc *desc)\n{\n\tu32 eor = le32_to_cpu(desc->opts1) & RingEnd;\n\n\tdesc->opts2 = 0;\n\t \n\tdma_wmb();\n\tWRITE_ONCE(desc->opts1, cpu_to_le32(DescOwn | eor | R8169_RX_BUF_SIZE));\n}\n\nstatic struct page *rtl8169_alloc_rx_data(struct rtl8169_private *tp,\n\t\t\t\t\t  struct RxDesc *desc)\n{\n\tstruct device *d = tp_to_dev(tp);\n\tint node = dev_to_node(d);\n\tdma_addr_t mapping;\n\tstruct page *data;\n\n\tdata = alloc_pages_node(node, GFP_KERNEL, get_order(R8169_RX_BUF_SIZE));\n\tif (!data)\n\t\treturn NULL;\n\n\tmapping = dma_map_page(d, data, 0, R8169_RX_BUF_SIZE, DMA_FROM_DEVICE);\n\tif (unlikely(dma_mapping_error(d, mapping))) {\n\t\tnetdev_err(tp->dev, \"Failed to map RX DMA!\\n\");\n\t\t__free_pages(data, get_order(R8169_RX_BUF_SIZE));\n\t\treturn NULL;\n\t}\n\n\tdesc->addr = cpu_to_le64(mapping);\n\trtl8169_mark_to_asic(desc);\n\n\treturn data;\n}\n\nstatic void rtl8169_rx_clear(struct rtl8169_private *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_RX_DESC && tp->Rx_databuff[i]; i++) {\n\t\tdma_unmap_page(tp_to_dev(tp),\n\t\t\t       le64_to_cpu(tp->RxDescArray[i].addr),\n\t\t\t       R8169_RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\t__free_pages(tp->Rx_databuff[i], get_order(R8169_RX_BUF_SIZE));\n\t\ttp->Rx_databuff[i] = NULL;\n\t\ttp->RxDescArray[i].addr = 0;\n\t\ttp->RxDescArray[i].opts1 = 0;\n\t}\n}\n\nstatic int rtl8169_rx_fill(struct rtl8169_private *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_RX_DESC; i++) {\n\t\tstruct page *data;\n\n\t\tdata = rtl8169_alloc_rx_data(tp, tp->RxDescArray + i);\n\t\tif (!data) {\n\t\t\trtl8169_rx_clear(tp);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\ttp->Rx_databuff[i] = data;\n\t}\n\n\t \n\ttp->RxDescArray[NUM_RX_DESC - 1].opts1 |= cpu_to_le32(RingEnd);\n\n\treturn 0;\n}\n\nstatic int rtl8169_init_ring(struct rtl8169_private *tp)\n{\n\trtl8169_init_ring_indexes(tp);\n\n\tmemset(tp->tx_skb, 0, sizeof(tp->tx_skb));\n\tmemset(tp->Rx_databuff, 0, sizeof(tp->Rx_databuff));\n\n\treturn rtl8169_rx_fill(tp);\n}\n\nstatic void rtl8169_unmap_tx_skb(struct rtl8169_private *tp, unsigned int entry)\n{\n\tstruct ring_info *tx_skb = tp->tx_skb + entry;\n\tstruct TxDesc *desc = tp->TxDescArray + entry;\n\n\tdma_unmap_single(tp_to_dev(tp), le64_to_cpu(desc->addr), tx_skb->len,\n\t\t\t DMA_TO_DEVICE);\n\tmemset(desc, 0, sizeof(*desc));\n\tmemset(tx_skb, 0, sizeof(*tx_skb));\n}\n\nstatic void rtl8169_tx_clear_range(struct rtl8169_private *tp, u32 start,\n\t\t\t\t   unsigned int n)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned int entry = (start + i) % NUM_TX_DESC;\n\t\tstruct ring_info *tx_skb = tp->tx_skb + entry;\n\t\tunsigned int len = tx_skb->len;\n\n\t\tif (len) {\n\t\t\tstruct sk_buff *skb = tx_skb->skb;\n\n\t\t\trtl8169_unmap_tx_skb(tp, entry);\n\t\t\tif (skb)\n\t\t\t\tdev_consume_skb_any(skb);\n\t\t}\n\t}\n}\n\nstatic void rtl8169_tx_clear(struct rtl8169_private *tp)\n{\n\trtl8169_tx_clear_range(tp, tp->dirty_tx, NUM_TX_DESC);\n\tnetdev_reset_queue(tp->dev);\n}\n\nstatic void rtl8169_cleanup(struct rtl8169_private *tp)\n{\n\tnapi_disable(&tp->napi);\n\n\t \n\tsynchronize_net();\n\n\t \n\trtl8169_irq_mask_and_ack(tp);\n\n\trtl_rx_close(tp);\n\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_28:\n\tcase RTL_GIGA_MAC_VER_31:\n\t\trtl_loop_wait_low(tp, &rtl_npq_cond, 20, 2000);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_34 ... RTL_GIGA_MAC_VER_38:\n\t\tRTL_W8(tp, ChipCmd, RTL_R8(tp, ChipCmd) | StopReq);\n\t\trtl_loop_wait_high(tp, &rtl_txcfg_empty_cond, 100, 666);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_63:\n\t\trtl_enable_rxdvgate(tp);\n\t\tfsleep(2000);\n\t\tbreak;\n\tdefault:\n\t\tRTL_W8(tp, ChipCmd, RTL_R8(tp, ChipCmd) | StopReq);\n\t\tfsleep(100);\n\t\tbreak;\n\t}\n\n\trtl_hw_reset(tp);\n\n\trtl8169_tx_clear(tp);\n\trtl8169_init_ring_indexes(tp);\n}\n\nstatic void rtl_reset_work(struct rtl8169_private *tp)\n{\n\tint i;\n\n\tnetif_stop_queue(tp->dev);\n\n\trtl8169_cleanup(tp);\n\n\tfor (i = 0; i < NUM_RX_DESC; i++)\n\t\trtl8169_mark_to_asic(tp->RxDescArray + i);\n\n\tnapi_enable(&tp->napi);\n\trtl_hw_start(tp);\n}\n\nstatic void rtl8169_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\n\trtl_schedule_task(tp, RTL_FLAG_TASK_TX_TIMEOUT);\n}\n\nstatic int rtl8169_tx_map(struct rtl8169_private *tp, const u32 *opts, u32 len,\n\t\t\t  void *addr, unsigned int entry, bool desc_own)\n{\n\tstruct TxDesc *txd = tp->TxDescArray + entry;\n\tstruct device *d = tp_to_dev(tp);\n\tdma_addr_t mapping;\n\tu32 opts1;\n\tint ret;\n\n\tmapping = dma_map_single(d, addr, len, DMA_TO_DEVICE);\n\tret = dma_mapping_error(d, mapping);\n\tif (unlikely(ret)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(tp->dev, \"Failed to map TX data!\\n\");\n\t\treturn ret;\n\t}\n\n\ttxd->addr = cpu_to_le64(mapping);\n\ttxd->opts2 = cpu_to_le32(opts[1]);\n\n\topts1 = opts[0] | len;\n\tif (entry == NUM_TX_DESC - 1)\n\t\topts1 |= RingEnd;\n\tif (desc_own)\n\t\topts1 |= DescOwn;\n\ttxd->opts1 = cpu_to_le32(opts1);\n\n\ttp->tx_skb[entry].len = len;\n\n\treturn 0;\n}\n\nstatic int rtl8169_xmit_frags(struct rtl8169_private *tp, struct sk_buff *skb,\n\t\t\t      const u32 *opts, unsigned int entry)\n{\n\tstruct skb_shared_info *info = skb_shinfo(skb);\n\tunsigned int cur_frag;\n\n\tfor (cur_frag = 0; cur_frag < info->nr_frags; cur_frag++) {\n\t\tconst skb_frag_t *frag = info->frags + cur_frag;\n\t\tvoid *addr = skb_frag_address(frag);\n\t\tu32 len = skb_frag_size(frag);\n\n\t\tentry = (entry + 1) % NUM_TX_DESC;\n\n\t\tif (unlikely(rtl8169_tx_map(tp, opts, len, addr, entry, true)))\n\t\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\trtl8169_tx_clear_range(tp, tp->cur_tx + 1, cur_frag);\n\treturn -EIO;\n}\n\nstatic bool rtl_skb_is_udp(struct sk_buff *skb)\n{\n\tint no = skb_network_offset(skb);\n\tstruct ipv6hdr *i6h, _i6h;\n\tstruct iphdr *ih, _ih;\n\n\tswitch (vlan_get_protocol(skb)) {\n\tcase htons(ETH_P_IP):\n\t\tih = skb_header_pointer(skb, no, sizeof(_ih), &_ih);\n\t\treturn ih && ih->protocol == IPPROTO_UDP;\n\tcase htons(ETH_P_IPV6):\n\t\ti6h = skb_header_pointer(skb, no, sizeof(_i6h), &_i6h);\n\t\treturn i6h && i6h->nexthdr == IPPROTO_UDP;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n#define RTL_MIN_PATCH_LEN\t47\n\n \nstatic unsigned int rtl8125_quirk_udp_padto(struct rtl8169_private *tp,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tunsigned int padto = 0, len = skb->len;\n\n\tif (rtl_is_8125(tp) && len < 128 + RTL_MIN_PATCH_LEN &&\n\t    rtl_skb_is_udp(skb) && skb_transport_header_was_set(skb)) {\n\t\tunsigned int trans_data_len = skb_tail_pointer(skb) -\n\t\t\t\t\t      skb_transport_header(skb);\n\n\t\tif (trans_data_len >= offsetof(struct udphdr, len) &&\n\t\t    trans_data_len < RTL_MIN_PATCH_LEN) {\n\t\t\tu16 dest = ntohs(udp_hdr(skb)->dest);\n\n\t\t\t \n\t\t\tif (dest == 319 || dest == 320)\n\t\t\t\tpadto = len + RTL_MIN_PATCH_LEN - trans_data_len;\n\t\t}\n\n\t\tif (trans_data_len < sizeof(struct udphdr))\n\t\t\tpadto = max_t(unsigned int, padto,\n\t\t\t\t      len + sizeof(struct udphdr) - trans_data_len);\n\t}\n\n\treturn padto;\n}\n\nstatic unsigned int rtl_quirk_packet_padto(struct rtl8169_private *tp,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tunsigned int padto;\n\n\tpadto = rtl8125_quirk_udp_padto(tp, skb);\n\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_34:\n\tcase RTL_GIGA_MAC_VER_61:\n\tcase RTL_GIGA_MAC_VER_63:\n\t\tpadto = max_t(unsigned int, padto, ETH_ZLEN);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn padto;\n}\n\nstatic void rtl8169_tso_csum_v1(struct sk_buff *skb, u32 *opts)\n{\n\tu32 mss = skb_shinfo(skb)->gso_size;\n\n\tif (mss) {\n\t\topts[0] |= TD_LSO;\n\t\topts[0] |= mss << TD0_MSS_SHIFT;\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tconst struct iphdr *ip = ip_hdr(skb);\n\n\t\tif (ip->protocol == IPPROTO_TCP)\n\t\t\topts[0] |= TD0_IP_CS | TD0_TCP_CS;\n\t\telse if (ip->protocol == IPPROTO_UDP)\n\t\t\topts[0] |= TD0_IP_CS | TD0_UDP_CS;\n\t\telse\n\t\t\tWARN_ON_ONCE(1);\n\t}\n}\n\nstatic bool rtl8169_tso_csum_v2(struct rtl8169_private *tp,\n\t\t\t\tstruct sk_buff *skb, u32 *opts)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tu32 mss = shinfo->gso_size;\n\n\tif (mss) {\n\t\tif (shinfo->gso_type & SKB_GSO_TCPV4) {\n\t\t\topts[0] |= TD1_GTSENV4;\n\t\t} else if (shinfo->gso_type & SKB_GSO_TCPV6) {\n\t\t\tif (skb_cow_head(skb, 0))\n\t\t\t\treturn false;\n\n\t\t\ttcp_v6_gso_csum_prep(skb);\n\t\t\topts[0] |= TD1_GTSENV6;\n\t\t} else {\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\n\t\topts[0] |= skb_transport_offset(skb) << GTTCPHO_SHIFT;\n\t\topts[1] |= mss << TD1_MSS_SHIFT;\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tu8 ip_protocol;\n\n\t\tswitch (vlan_get_protocol(skb)) {\n\t\tcase htons(ETH_P_IP):\n\t\t\topts[1] |= TD1_IPv4_CS;\n\t\t\tip_protocol = ip_hdr(skb)->protocol;\n\t\t\tbreak;\n\n\t\tcase htons(ETH_P_IPV6):\n\t\t\topts[1] |= TD1_IPv6_CS;\n\t\t\tip_protocol = ipv6_hdr(skb)->nexthdr;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tip_protocol = IPPROTO_RAW;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ip_protocol == IPPROTO_TCP)\n\t\t\topts[1] |= TD1_TCP_CS;\n\t\telse if (ip_protocol == IPPROTO_UDP)\n\t\t\topts[1] |= TD1_UDP_CS;\n\t\telse\n\t\t\tWARN_ON_ONCE(1);\n\n\t\topts[1] |= skb_transport_offset(skb) << TCPHO_SHIFT;\n\t} else {\n\t\tunsigned int padto = rtl_quirk_packet_padto(tp, skb);\n\n\t\t \n\t\treturn !__skb_put_padto(skb, padto, false);\n\t}\n\n\treturn true;\n}\n\nstatic unsigned int rtl_tx_slots_avail(struct rtl8169_private *tp)\n{\n\treturn READ_ONCE(tp->dirty_tx) + NUM_TX_DESC - READ_ONCE(tp->cur_tx);\n}\n\n \nstatic bool rtl_chip_supports_csum_v2(struct rtl8169_private *tp)\n{\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_02 ... RTL_GIGA_MAC_VER_06:\n\tcase RTL_GIGA_MAC_VER_10 ... RTL_GIGA_MAC_VER_17:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic void rtl8169_doorbell(struct rtl8169_private *tp)\n{\n\tif (rtl_is_8125(tp))\n\t\tRTL_W16(tp, TxPoll_8125, BIT(0));\n\telse\n\t\tRTL_W8(tp, TxPoll, NPQ);\n}\n\nstatic netdev_tx_t rtl8169_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tunsigned int frags = skb_shinfo(skb)->nr_frags;\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\tunsigned int entry = tp->cur_tx % NUM_TX_DESC;\n\tstruct TxDesc *txd_first, *txd_last;\n\tbool stop_queue, door_bell;\n\tu32 opts[2];\n\n\tif (unlikely(!rtl_tx_slots_avail(tp))) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(dev, \"BUG! Tx Ring full when queue awake!\\n\");\n\t\tgoto err_stop_0;\n\t}\n\n\topts[1] = rtl8169_tx_vlan_tag(skb);\n\topts[0] = 0;\n\n\tif (!rtl_chip_supports_csum_v2(tp))\n\t\trtl8169_tso_csum_v1(skb, opts);\n\telse if (!rtl8169_tso_csum_v2(tp, skb, opts))\n\t\tgoto err_dma_0;\n\n\tif (unlikely(rtl8169_tx_map(tp, opts, skb_headlen(skb), skb->data,\n\t\t\t\t    entry, false)))\n\t\tgoto err_dma_0;\n\n\ttxd_first = tp->TxDescArray + entry;\n\n\tif (frags) {\n\t\tif (rtl8169_xmit_frags(tp, skb, opts, entry))\n\t\t\tgoto err_dma_1;\n\t\tentry = (entry + frags) % NUM_TX_DESC;\n\t}\n\n\ttxd_last = tp->TxDescArray + entry;\n\ttxd_last->opts1 |= cpu_to_le32(LastFrag);\n\ttp->tx_skb[entry].skb = skb;\n\n\tskb_tx_timestamp(skb);\n\n\t \n\tdma_wmb();\n\n\tdoor_bell = __netdev_sent_queue(dev, skb->len, netdev_xmit_more());\n\n\ttxd_first->opts1 |= cpu_to_le32(DescOwn | FirstFrag);\n\n\t \n\tsmp_wmb();\n\n\tWRITE_ONCE(tp->cur_tx, tp->cur_tx + frags + 1);\n\n\tstop_queue = !netif_subqueue_maybe_stop(dev, 0, rtl_tx_slots_avail(tp),\n\t\t\t\t\t\tR8169_TX_STOP_THRS,\n\t\t\t\t\t\tR8169_TX_START_THRS);\n\tif (door_bell || stop_queue)\n\t\trtl8169_doorbell(tp);\n\n\treturn NETDEV_TX_OK;\n\nerr_dma_1:\n\trtl8169_unmap_tx_skb(tp, entry);\nerr_dma_0:\n\tdev_kfree_skb_any(skb);\n\tdev->stats.tx_dropped++;\n\treturn NETDEV_TX_OK;\n\nerr_stop_0:\n\tnetif_stop_queue(dev);\n\tdev->stats.tx_dropped++;\n\treturn NETDEV_TX_BUSY;\n}\n\nstatic unsigned int rtl_last_frag_len(struct sk_buff *skb)\n{\n\tstruct skb_shared_info *info = skb_shinfo(skb);\n\tunsigned int nr_frags = info->nr_frags;\n\n\tif (!nr_frags)\n\t\treturn UINT_MAX;\n\n\treturn skb_frag_size(info->frags + nr_frags - 1);\n}\n\n \nstatic netdev_features_t rtl8168evl_fix_tso(struct sk_buff *skb,\n\t\t\t\t\t    netdev_features_t features)\n{\n\t \n\tif (vlan_get_protocol(skb) == htons(ETH_P_IP) &&\n\t    ip_hdrlen(skb) > sizeof(struct iphdr))\n\t\tfeatures &= ~NETIF_F_ALL_TSO;\n\n\t \n\telse if (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV4 &&\n\t\t tcp_hdrlen(skb) > sizeof(struct tcphdr))\n\t\tfeatures &= ~NETIF_F_ALL_TSO;\n\n\telse if (rtl_last_frag_len(skb) <= 6)\n\t\tfeatures &= ~NETIF_F_ALL_TSO;\n\n\treturn features;\n}\n\nstatic netdev_features_t rtl8169_features_check(struct sk_buff *skb,\n\t\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\t\tnetdev_features_t features)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\n\tif (skb_is_gso(skb)) {\n\t\tif (tp->mac_version == RTL_GIGA_MAC_VER_34)\n\t\t\tfeatures = rtl8168evl_fix_tso(skb, features);\n\n\t\tif (skb_transport_offset(skb) > GTTCPHO_MAX &&\n\t\t    rtl_chip_supports_csum_v2(tp))\n\t\t\tfeatures &= ~NETIF_F_ALL_TSO;\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t \n\t\tif (skb->len < ETH_ZLEN)\n\t\t\tfeatures &= ~NETIF_F_CSUM_MASK;\n\n\t\tif (rtl_quirk_packet_padto(tp, skb))\n\t\t\tfeatures &= ~NETIF_F_CSUM_MASK;\n\n\t\tif (skb_transport_offset(skb) > TCPHO_MAX &&\n\t\t    rtl_chip_supports_csum_v2(tp))\n\t\t\tfeatures &= ~NETIF_F_CSUM_MASK;\n\t}\n\n\treturn vlan_features_check(skb, features);\n}\n\nstatic void rtl8169_pcierr_interrupt(struct net_device *dev)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\tstruct pci_dev *pdev = tp->pci_dev;\n\tint pci_status_errs;\n\tu16 pci_cmd;\n\n\tpci_read_config_word(pdev, PCI_COMMAND, &pci_cmd);\n\n\tpci_status_errs = pci_status_get_and_clear_errors(pdev);\n\n\tif (net_ratelimit())\n\t\tnetdev_err(dev, \"PCI error (cmd = 0x%04x, status_errs = 0x%04x)\\n\",\n\t\t\t   pci_cmd, pci_status_errs);\n\n\trtl_schedule_task(tp, RTL_FLAG_TASK_RESET_PENDING);\n}\n\nstatic void rtl_tx(struct net_device *dev, struct rtl8169_private *tp,\n\t\t   int budget)\n{\n\tunsigned int dirty_tx, bytes_compl = 0, pkts_compl = 0;\n\tstruct sk_buff *skb;\n\n\tdirty_tx = tp->dirty_tx;\n\n\twhile (READ_ONCE(tp->cur_tx) != dirty_tx) {\n\t\tunsigned int entry = dirty_tx % NUM_TX_DESC;\n\t\tu32 status;\n\n\t\tstatus = le32_to_cpu(READ_ONCE(tp->TxDescArray[entry].opts1));\n\t\tif (status & DescOwn)\n\t\t\tbreak;\n\n\t\tskb = tp->tx_skb[entry].skb;\n\t\trtl8169_unmap_tx_skb(tp, entry);\n\n\t\tif (skb) {\n\t\t\tpkts_compl++;\n\t\t\tbytes_compl += skb->len;\n\t\t\tnapi_consume_skb(skb, budget);\n\t\t}\n\t\tdirty_tx++;\n\t}\n\n\tif (tp->dirty_tx != dirty_tx) {\n\t\tdev_sw_netstats_tx_add(dev, pkts_compl, bytes_compl);\n\t\tWRITE_ONCE(tp->dirty_tx, dirty_tx);\n\n\t\tnetif_subqueue_completed_wake(dev, 0, pkts_compl, bytes_compl,\n\t\t\t\t\t      rtl_tx_slots_avail(tp),\n\t\t\t\t\t      R8169_TX_START_THRS);\n\t\t \n\t\tif (READ_ONCE(tp->cur_tx) != dirty_tx && skb)\n\t\t\trtl8169_doorbell(tp);\n\t}\n}\n\nstatic inline int rtl8169_fragmented_frame(u32 status)\n{\n\treturn (status & (FirstFrag | LastFrag)) != (FirstFrag | LastFrag);\n}\n\nstatic inline void rtl8169_rx_csum(struct sk_buff *skb, u32 opts1)\n{\n\tu32 status = opts1 & (RxProtoMask | RxCSFailMask);\n\n\tif (status == RxProtoTCP || status == RxProtoUDP)\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\telse\n\t\tskb_checksum_none_assert(skb);\n}\n\nstatic int rtl_rx(struct net_device *dev, struct rtl8169_private *tp, int budget)\n{\n\tstruct device *d = tp_to_dev(tp);\n\tint count;\n\n\tfor (count = 0; count < budget; count++, tp->cur_rx++) {\n\t\tunsigned int pkt_size, entry = tp->cur_rx % NUM_RX_DESC;\n\t\tstruct RxDesc *desc = tp->RxDescArray + entry;\n\t\tstruct sk_buff *skb;\n\t\tconst void *rx_buf;\n\t\tdma_addr_t addr;\n\t\tu32 status;\n\n\t\tstatus = le32_to_cpu(READ_ONCE(desc->opts1));\n\t\tif (status & DescOwn)\n\t\t\tbreak;\n\n\t\t \n\t\tdma_rmb();\n\n\t\tif (unlikely(status & RxRES)) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_warn(dev, \"Rx ERROR. status = %08x\\n\",\n\t\t\t\t\t    status);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (status & (RxRWT | RxRUNT))\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\tif (status & RxCRC)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\n\t\t\tif (!(dev->features & NETIF_F_RXALL))\n\t\t\t\tgoto release_descriptor;\n\t\t\telse if (status & RxRWT || !(status & (RxRUNT | RxCRC)))\n\t\t\t\tgoto release_descriptor;\n\t\t}\n\n\t\tpkt_size = status & GENMASK(13, 0);\n\t\tif (likely(!(dev->features & NETIF_F_RXFCS)))\n\t\t\tpkt_size -= ETH_FCS_LEN;\n\n\t\t \n\t\tif (unlikely(rtl8169_fragmented_frame(status))) {\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tdev->stats.rx_length_errors++;\n\t\t\tgoto release_descriptor;\n\t\t}\n\n\t\tskb = napi_alloc_skb(&tp->napi, pkt_size);\n\t\tif (unlikely(!skb)) {\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tgoto release_descriptor;\n\t\t}\n\n\t\taddr = le64_to_cpu(desc->addr);\n\t\trx_buf = page_address(tp->Rx_databuff[entry]);\n\n\t\tdma_sync_single_for_cpu(d, addr, pkt_size, DMA_FROM_DEVICE);\n\t\tprefetch(rx_buf);\n\t\tskb_copy_to_linear_data(skb, rx_buf, pkt_size);\n\t\tskb->tail += pkt_size;\n\t\tskb->len = pkt_size;\n\t\tdma_sync_single_for_device(d, addr, pkt_size, DMA_FROM_DEVICE);\n\n\t\trtl8169_rx_csum(skb, status);\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\n\t\trtl8169_rx_vlan_tag(desc, skb);\n\n\t\tif (skb->pkt_type == PACKET_MULTICAST)\n\t\t\tdev->stats.multicast++;\n\n\t\tnapi_gro_receive(&tp->napi, skb);\n\n\t\tdev_sw_netstats_rx_add(dev, pkt_size);\nrelease_descriptor:\n\t\trtl8169_mark_to_asic(desc);\n\t}\n\n\treturn count;\n}\n\nstatic irqreturn_t rtl8169_interrupt(int irq, void *dev_instance)\n{\n\tstruct rtl8169_private *tp = dev_instance;\n\tu32 status = rtl_get_events(tp);\n\n\tif ((status & 0xffff) == 0xffff || !(status & tp->irq_mask))\n\t\treturn IRQ_NONE;\n\n\tif (unlikely(status & SYSErr)) {\n\t\trtl8169_pcierr_interrupt(tp->dev);\n\t\tgoto out;\n\t}\n\n\tif (status & LinkChg)\n\t\tphy_mac_interrupt(tp->phydev);\n\n\tif (unlikely(status & RxFIFOOver &&\n\t    tp->mac_version == RTL_GIGA_MAC_VER_11)) {\n\t\tnetif_stop_queue(tp->dev);\n\t\trtl_schedule_task(tp, RTL_FLAG_TASK_RESET_PENDING);\n\t}\n\n\tif (napi_schedule_prep(&tp->napi)) {\n\t\trtl_irq_disable(tp);\n\t\t__napi_schedule(&tp->napi);\n\t}\nout:\n\trtl_ack_events(tp, status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rtl_task(struct work_struct *work)\n{\n\tstruct rtl8169_private *tp =\n\t\tcontainer_of(work, struct rtl8169_private, wk.work);\n\tint ret;\n\n\trtnl_lock();\n\n\tif (!netif_running(tp->dev) ||\n\t    !test_bit(RTL_FLAG_TASK_ENABLED, tp->wk.flags))\n\t\tgoto out_unlock;\n\n\tif (test_and_clear_bit(RTL_FLAG_TASK_TX_TIMEOUT, tp->wk.flags)) {\n\t\t \n\t\tif (RTL_R32(tp, TxConfig) == ~0) {\n\t\t\tret = pci_reset_bus(tp->pci_dev);\n\t\t\tif (ret < 0) {\n\t\t\t\tnetdev_err(tp->dev, \"Can't reset secondary PCI bus, detach NIC\\n\");\n\t\t\t\tnetif_device_detach(tp->dev);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = pci_disable_link_state(tp->pci_dev, PCIE_LINK_STATE_L1 |\n\t\t\t\t\t\t\t  PCIE_LINK_STATE_L0S);\n\t\tif (!ret)\n\t\t\tnetdev_warn_once(tp->dev, \"ASPM disabled on Tx timeout\\n\");\n\t\tgoto reset;\n\t}\n\n\tif (test_and_clear_bit(RTL_FLAG_TASK_RESET_PENDING, tp->wk.flags)) {\nreset:\n\t\trtl_reset_work(tp);\n\t\tnetif_wake_queue(tp->dev);\n\t} else if (test_and_clear_bit(RTL_FLAG_TASK_RESET_NO_QUEUE_WAKE, tp->wk.flags)) {\n\t\trtl_reset_work(tp);\n\t}\nout_unlock:\n\trtnl_unlock();\n}\n\nstatic int rtl8169_poll(struct napi_struct *napi, int budget)\n{\n\tstruct rtl8169_private *tp = container_of(napi, struct rtl8169_private, napi);\n\tstruct net_device *dev = tp->dev;\n\tint work_done;\n\n\trtl_tx(dev, tp, budget);\n\n\twork_done = rtl_rx(dev, tp, budget);\n\n\tif (work_done < budget && napi_complete_done(napi, work_done))\n\t\trtl_irq_enable(tp);\n\n\treturn work_done;\n}\n\nstatic void r8169_phylink_handler(struct net_device *ndev)\n{\n\tstruct rtl8169_private *tp = netdev_priv(ndev);\n\tstruct device *d = tp_to_dev(tp);\n\n\tif (netif_carrier_ok(ndev)) {\n\t\trtl_link_chg_patch(tp);\n\t\tpm_request_resume(d);\n\t\tnetif_wake_queue(tp->dev);\n\t} else {\n\t\t \n\t\tif (rtl_is_8125(tp))\n\t\t\trtl_schedule_task(tp, RTL_FLAG_TASK_RESET_NO_QUEUE_WAKE);\n\t\tpm_runtime_idle(d);\n\t}\n\n\tphy_print_status(tp->phydev);\n}\n\nstatic int r8169_phy_connect(struct rtl8169_private *tp)\n{\n\tstruct phy_device *phydev = tp->phydev;\n\tphy_interface_t phy_mode;\n\tint ret;\n\n\tphy_mode = tp->supports_gmii ? PHY_INTERFACE_MODE_GMII :\n\t\t   PHY_INTERFACE_MODE_MII;\n\n\tret = phy_connect_direct(tp->dev, phydev, r8169_phylink_handler,\n\t\t\t\t phy_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!tp->supports_gmii)\n\t\tphy_set_max_speed(phydev, SPEED_100);\n\n\tphy_attached_info(phydev);\n\n\treturn 0;\n}\n\nstatic void rtl8169_down(struct rtl8169_private *tp)\n{\n\t \n\tbitmap_zero(tp->wk.flags, RTL_FLAG_MAX);\n\n\tphy_stop(tp->phydev);\n\n\trtl8169_update_counters(tp);\n\n\tpci_clear_master(tp->pci_dev);\n\trtl_pci_commit(tp);\n\n\trtl8169_cleanup(tp);\n\trtl_disable_exit_l1(tp);\n\trtl_prepare_power_down(tp);\n\n\tif (tp->dash_type != RTL_DASH_NONE)\n\t\trtl8168_driver_stop(tp);\n}\n\nstatic void rtl8169_up(struct rtl8169_private *tp)\n{\n\tif (tp->dash_type != RTL_DASH_NONE)\n\t\trtl8168_driver_start(tp);\n\n\tpci_set_master(tp->pci_dev);\n\tphy_init_hw(tp->phydev);\n\tphy_resume(tp->phydev);\n\trtl8169_init_phy(tp);\n\tnapi_enable(&tp->napi);\n\tset_bit(RTL_FLAG_TASK_ENABLED, tp->wk.flags);\n\trtl_reset_work(tp);\n\n\tphy_start(tp->phydev);\n}\n\nstatic int rtl8169_close(struct net_device *dev)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\tstruct pci_dev *pdev = tp->pci_dev;\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tnetif_stop_queue(dev);\n\trtl8169_down(tp);\n\trtl8169_rx_clear(tp);\n\n\tcancel_work(&tp->wk.work);\n\n\tfree_irq(tp->irq, tp);\n\n\tphy_disconnect(tp->phydev);\n\n\tdma_free_coherent(&pdev->dev, R8169_RX_RING_BYTES, tp->RxDescArray,\n\t\t\t  tp->RxPhyAddr);\n\tdma_free_coherent(&pdev->dev, R8169_TX_RING_BYTES, tp->TxDescArray,\n\t\t\t  tp->TxPhyAddr);\n\ttp->TxDescArray = NULL;\n\ttp->RxDescArray = NULL;\n\n\tpm_runtime_put_sync(&pdev->dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void rtl8169_netpoll(struct net_device *dev)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\n\trtl8169_interrupt(tp->irq, tp);\n}\n#endif\n\nstatic int rtl_open(struct net_device *dev)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\tstruct pci_dev *pdev = tp->pci_dev;\n\tunsigned long irqflags;\n\tint retval = -ENOMEM;\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\t \n\ttp->TxDescArray = dma_alloc_coherent(&pdev->dev, R8169_TX_RING_BYTES,\n\t\t\t\t\t     &tp->TxPhyAddr, GFP_KERNEL);\n\tif (!tp->TxDescArray)\n\t\tgoto out;\n\n\ttp->RxDescArray = dma_alloc_coherent(&pdev->dev, R8169_RX_RING_BYTES,\n\t\t\t\t\t     &tp->RxPhyAddr, GFP_KERNEL);\n\tif (!tp->RxDescArray)\n\t\tgoto err_free_tx_0;\n\n\tretval = rtl8169_init_ring(tp);\n\tif (retval < 0)\n\t\tgoto err_free_rx_1;\n\n\trtl_request_firmware(tp);\n\n\tirqflags = pci_dev_msi_enabled(pdev) ? IRQF_NO_THREAD : IRQF_SHARED;\n\tretval = request_irq(tp->irq, rtl8169_interrupt, irqflags, dev->name, tp);\n\tif (retval < 0)\n\t\tgoto err_release_fw_2;\n\n\tretval = r8169_phy_connect(tp);\n\tif (retval)\n\t\tgoto err_free_irq;\n\n\trtl8169_up(tp);\n\trtl8169_init_counter_offsets(tp);\n\tnetif_start_queue(dev);\nout:\n\tpm_runtime_put_sync(&pdev->dev);\n\n\treturn retval;\n\nerr_free_irq:\n\tfree_irq(tp->irq, tp);\nerr_release_fw_2:\n\trtl_release_firmware(tp);\n\trtl8169_rx_clear(tp);\nerr_free_rx_1:\n\tdma_free_coherent(&pdev->dev, R8169_RX_RING_BYTES, tp->RxDescArray,\n\t\t\t  tp->RxPhyAddr);\n\ttp->RxDescArray = NULL;\nerr_free_tx_0:\n\tdma_free_coherent(&pdev->dev, R8169_TX_RING_BYTES, tp->TxDescArray,\n\t\t\t  tp->TxPhyAddr);\n\ttp->TxDescArray = NULL;\n\tgoto out;\n}\n\nstatic void\nrtl8169_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tstruct rtl8169_private *tp = netdev_priv(dev);\n\tstruct pci_dev *pdev = tp->pci_dev;\n\tstruct rtl8169_counters *counters = tp->counters;\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\n\tnetdev_stats_to_stats64(stats, &dev->stats);\n\tdev_fetch_sw_netstats(stats, dev->tstats);\n\n\t \n\tif (pm_runtime_active(&pdev->dev))\n\t\trtl8169_update_counters(tp);\n\n\t \n\tstats->tx_errors = le64_to_cpu(counters->tx_errors) -\n\t\tle64_to_cpu(tp->tc_offset.tx_errors);\n\tstats->collisions = le32_to_cpu(counters->tx_multi_collision) -\n\t\tle32_to_cpu(tp->tc_offset.tx_multi_collision);\n\tstats->tx_aborted_errors = le16_to_cpu(counters->tx_aborted) -\n\t\tle16_to_cpu(tp->tc_offset.tx_aborted);\n\tstats->rx_missed_errors = le16_to_cpu(counters->rx_missed) -\n\t\tle16_to_cpu(tp->tc_offset.rx_missed);\n\n\tpm_runtime_put_noidle(&pdev->dev);\n}\n\nstatic void rtl8169_net_suspend(struct rtl8169_private *tp)\n{\n\tnetif_device_detach(tp->dev);\n\n\tif (netif_running(tp->dev))\n\t\trtl8169_down(tp);\n}\n\nstatic int rtl8169_runtime_resume(struct device *dev)\n{\n\tstruct rtl8169_private *tp = dev_get_drvdata(dev);\n\n\trtl_rar_set(tp, tp->dev->dev_addr);\n\t__rtl8169_set_wol(tp, tp->saved_wolopts);\n\n\tif (tp->TxDescArray)\n\t\trtl8169_up(tp);\n\n\tnetif_device_attach(tp->dev);\n\n\treturn 0;\n}\n\nstatic int rtl8169_suspend(struct device *device)\n{\n\tstruct rtl8169_private *tp = dev_get_drvdata(device);\n\n\trtnl_lock();\n\trtl8169_net_suspend(tp);\n\tif (!device_may_wakeup(tp_to_dev(tp)))\n\t\tclk_disable_unprepare(tp->clk);\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic int rtl8169_resume(struct device *device)\n{\n\tstruct rtl8169_private *tp = dev_get_drvdata(device);\n\n\tif (!device_may_wakeup(tp_to_dev(tp)))\n\t\tclk_prepare_enable(tp->clk);\n\n\t \n\tif (tp->mac_version == RTL_GIGA_MAC_VER_37)\n\t\trtl_init_rxcfg(tp);\n\n\treturn rtl8169_runtime_resume(device);\n}\n\nstatic int rtl8169_runtime_suspend(struct device *device)\n{\n\tstruct rtl8169_private *tp = dev_get_drvdata(device);\n\n\tif (!tp->TxDescArray) {\n\t\tnetif_device_detach(tp->dev);\n\t\treturn 0;\n\t}\n\n\trtnl_lock();\n\t__rtl8169_set_wol(tp, WAKE_PHY);\n\trtl8169_net_suspend(tp);\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic int rtl8169_runtime_idle(struct device *device)\n{\n\tstruct rtl8169_private *tp = dev_get_drvdata(device);\n\n\tif (tp->dash_enabled)\n\t\treturn -EBUSY;\n\n\tif (!netif_running(tp->dev) || !netif_carrier_ok(tp->dev))\n\t\tpm_schedule_suspend(device, 10000);\n\n\treturn -EBUSY;\n}\n\nstatic const struct dev_pm_ops rtl8169_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(rtl8169_suspend, rtl8169_resume)\n\tRUNTIME_PM_OPS(rtl8169_runtime_suspend, rtl8169_runtime_resume,\n\t\t       rtl8169_runtime_idle)\n};\n\nstatic void rtl_shutdown(struct pci_dev *pdev)\n{\n\tstruct rtl8169_private *tp = pci_get_drvdata(pdev);\n\n\trtnl_lock();\n\trtl8169_net_suspend(tp);\n\trtnl_unlock();\n\n\t \n\trtl_rar_set(tp, tp->dev->perm_addr);\n\n\tif (system_state == SYSTEM_POWER_OFF && !tp->dash_enabled) {\n\t\tpci_wake_from_d3(pdev, tp->saved_wolopts);\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n\t}\n}\n\nstatic void rtl_remove_one(struct pci_dev *pdev)\n{\n\tstruct rtl8169_private *tp = pci_get_drvdata(pdev);\n\n\tif (pci_dev_run_wake(pdev))\n\t\tpm_runtime_get_noresume(&pdev->dev);\n\n\tcancel_work_sync(&tp->wk.work);\n\n\tunregister_netdev(tp->dev);\n\n\tif (tp->dash_type != RTL_DASH_NONE)\n\t\trtl8168_driver_stop(tp);\n\n\trtl_release_firmware(tp);\n\n\t \n\trtl_rar_set(tp, tp->dev->perm_addr);\n}\n\nstatic const struct net_device_ops rtl_netdev_ops = {\n\t.ndo_open\t\t= rtl_open,\n\t.ndo_stop\t\t= rtl8169_close,\n\t.ndo_get_stats64\t= rtl8169_get_stats64,\n\t.ndo_start_xmit\t\t= rtl8169_start_xmit,\n\t.ndo_features_check\t= rtl8169_features_check,\n\t.ndo_tx_timeout\t\t= rtl8169_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_change_mtu\t\t= rtl8169_change_mtu,\n\t.ndo_fix_features\t= rtl8169_fix_features,\n\t.ndo_set_features\t= rtl8169_set_features,\n\t.ndo_set_mac_address\t= rtl_set_mac_address,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl_running,\n\t.ndo_set_rx_mode\t= rtl_set_rx_mode,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= rtl8169_netpoll,\n#endif\n\n};\n\nstatic void rtl_set_irq_mask(struct rtl8169_private *tp)\n{\n\ttp->irq_mask = RxOK | RxErr | TxOK | TxErr | LinkChg;\n\n\tif (tp->mac_version <= RTL_GIGA_MAC_VER_06)\n\t\ttp->irq_mask |= SYSErr | RxOverflow | RxFIFOOver;\n\telse if (tp->mac_version == RTL_GIGA_MAC_VER_11)\n\t\t \n\t\ttp->irq_mask |= RxFIFOOver;\n\telse\n\t\ttp->irq_mask |= RxOverflow;\n}\n\nstatic int rtl_alloc_irq(struct rtl8169_private *tp)\n{\n\tunsigned int flags;\n\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_02 ... RTL_GIGA_MAC_VER_06:\n\t\trtl_unlock_config_regs(tp);\n\t\tRTL_W8(tp, Config2, RTL_R8(tp, Config2) & ~MSIEnable);\n\t\trtl_lock_config_regs(tp);\n\t\tfallthrough;\n\tcase RTL_GIGA_MAC_VER_07 ... RTL_GIGA_MAC_VER_17:\n\t\tflags = PCI_IRQ_LEGACY;\n\t\tbreak;\n\tdefault:\n\t\tflags = PCI_IRQ_ALL_TYPES;\n\t\tbreak;\n\t}\n\n\treturn pci_alloc_irq_vectors(tp->pci_dev, 1, 1, flags);\n}\n\nstatic void rtl_read_mac_address(struct rtl8169_private *tp,\n\t\t\t\t u8 mac_addr[ETH_ALEN])\n{\n\t \n\tif (rtl_is_8168evl_up(tp) && tp->mac_version != RTL_GIGA_MAC_VER_34) {\n\t\tu32 value;\n\n\t\tvalue = rtl_eri_read(tp, 0xe0);\n\t\tput_unaligned_le32(value, mac_addr);\n\t\tvalue = rtl_eri_read(tp, 0xe4);\n\t\tput_unaligned_le16(value, mac_addr + 4);\n\t} else if (rtl_is_8125(tp)) {\n\t\trtl_read_mac_from_reg(tp, mac_addr, MAC0_BKP);\n\t}\n}\n\nDECLARE_RTL_COND(rtl_link_list_ready_cond)\n{\n\treturn RTL_R8(tp, MCU) & LINK_LIST_RDY;\n}\n\nstatic void r8168g_wait_ll_share_fifo_ready(struct rtl8169_private *tp)\n{\n\trtl_loop_wait_high(tp, &rtl_link_list_ready_cond, 100, 42);\n}\n\nstatic int r8169_mdio_read_reg(struct mii_bus *mii_bus, int phyaddr, int phyreg)\n{\n\tstruct rtl8169_private *tp = mii_bus->priv;\n\n\tif (phyaddr > 0)\n\t\treturn -ENODEV;\n\n\treturn rtl_readphy(tp, phyreg);\n}\n\nstatic int r8169_mdio_write_reg(struct mii_bus *mii_bus, int phyaddr,\n\t\t\t\tint phyreg, u16 val)\n{\n\tstruct rtl8169_private *tp = mii_bus->priv;\n\n\tif (phyaddr > 0)\n\t\treturn -ENODEV;\n\n\trtl_writephy(tp, phyreg, val);\n\n\treturn 0;\n}\n\nstatic int r8169_mdio_register(struct rtl8169_private *tp)\n{\n\tstruct pci_dev *pdev = tp->pci_dev;\n\tstruct mii_bus *new_bus;\n\tint ret;\n\n\tnew_bus = devm_mdiobus_alloc(&pdev->dev);\n\tif (!new_bus)\n\t\treturn -ENOMEM;\n\n\tnew_bus->name = \"r8169\";\n\tnew_bus->priv = tp;\n\tnew_bus->parent = &pdev->dev;\n\tnew_bus->irq[0] = PHY_MAC_INTERRUPT;\n\tsnprintf(new_bus->id, MII_BUS_ID_SIZE, \"r8169-%x-%x\",\n\t\t pci_domain_nr(pdev->bus), pci_dev_id(pdev));\n\n\tnew_bus->read = r8169_mdio_read_reg;\n\tnew_bus->write = r8169_mdio_write_reg;\n\n\tret = devm_mdiobus_register(&pdev->dev, new_bus);\n\tif (ret)\n\t\treturn ret;\n\n\ttp->phydev = mdiobus_get_phy(new_bus, 0);\n\tif (!tp->phydev) {\n\t\treturn -ENODEV;\n\t} else if (!tp->phydev->drv) {\n\t\t \n\t\tdev_err(&pdev->dev, \"no dedicated PHY driver found for PHY ID 0x%08x, maybe realtek.ko needs to be added to initramfs?\\n\",\n\t\t\ttp->phydev->phy_id);\n\t\treturn -EUNATCH;\n\t}\n\n\ttp->phydev->mac_managed_pm = true;\n\n\tphy_support_asym_pause(tp->phydev);\n\n\t \n\tphy_suspend(tp->phydev);\n\n\treturn 0;\n}\n\nstatic void rtl_hw_init_8168g(struct rtl8169_private *tp)\n{\n\trtl_enable_rxdvgate(tp);\n\n\tRTL_W8(tp, ChipCmd, RTL_R8(tp, ChipCmd) & ~(CmdTxEnb | CmdRxEnb));\n\tmsleep(1);\n\tRTL_W8(tp, MCU, RTL_R8(tp, MCU) & ~NOW_IS_OOB);\n\n\tr8168_mac_ocp_modify(tp, 0xe8de, BIT(14), 0);\n\tr8168g_wait_ll_share_fifo_ready(tp);\n\n\tr8168_mac_ocp_modify(tp, 0xe8de, 0, BIT(15));\n\tr8168g_wait_ll_share_fifo_ready(tp);\n}\n\nstatic void rtl_hw_init_8125(struct rtl8169_private *tp)\n{\n\trtl_enable_rxdvgate(tp);\n\n\tRTL_W8(tp, ChipCmd, RTL_R8(tp, ChipCmd) & ~(CmdTxEnb | CmdRxEnb));\n\tmsleep(1);\n\tRTL_W8(tp, MCU, RTL_R8(tp, MCU) & ~NOW_IS_OOB);\n\n\tr8168_mac_ocp_modify(tp, 0xe8de, BIT(14), 0);\n\tr8168g_wait_ll_share_fifo_ready(tp);\n\n\tr8168_mac_ocp_write(tp, 0xc0aa, 0x07d0);\n\tr8168_mac_ocp_write(tp, 0xc0a6, 0x0150);\n\tr8168_mac_ocp_write(tp, 0xc01e, 0x5555);\n\tr8168g_wait_ll_share_fifo_ready(tp);\n}\n\nstatic void rtl_hw_initialize(struct rtl8169_private *tp)\n{\n\tswitch (tp->mac_version) {\n\tcase RTL_GIGA_MAC_VER_51 ... RTL_GIGA_MAC_VER_53:\n\t\trtl8168ep_stop_cmac(tp);\n\t\tfallthrough;\n\tcase RTL_GIGA_MAC_VER_40 ... RTL_GIGA_MAC_VER_48:\n\t\trtl_hw_init_8168g(tp);\n\t\tbreak;\n\tcase RTL_GIGA_MAC_VER_61 ... RTL_GIGA_MAC_VER_63:\n\t\trtl_hw_init_8125(tp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int rtl_jumbo_max(struct rtl8169_private *tp)\n{\n\t \n\tif (!tp->supports_gmii)\n\t\treturn 0;\n\n\tswitch (tp->mac_version) {\n\t \n\tcase RTL_GIGA_MAC_VER_02 ... RTL_GIGA_MAC_VER_06:\n\t\treturn JUMBO_7K;\n\t \n\tcase RTL_GIGA_MAC_VER_11:\n\tcase RTL_GIGA_MAC_VER_17:\n\t\treturn JUMBO_4K;\n\t \n\tcase RTL_GIGA_MAC_VER_18 ... RTL_GIGA_MAC_VER_24:\n\t\treturn JUMBO_6K;\n\tdefault:\n\t\treturn JUMBO_9K;\n\t}\n}\n\nstatic void rtl_init_mac_address(struct rtl8169_private *tp)\n{\n\tu8 mac_addr[ETH_ALEN] __aligned(2) = {};\n\tstruct net_device *dev = tp->dev;\n\tint rc;\n\n\trc = eth_platform_get_mac_address(tp_to_dev(tp), mac_addr);\n\tif (!rc)\n\t\tgoto done;\n\n\trtl_read_mac_address(tp, mac_addr);\n\tif (is_valid_ether_addr(mac_addr))\n\t\tgoto done;\n\n\trtl_read_mac_from_reg(tp, mac_addr, MAC0);\n\tif (is_valid_ether_addr(mac_addr))\n\t\tgoto done;\n\n\teth_random_addr(mac_addr);\n\tdev->addr_assign_type = NET_ADDR_RANDOM;\n\tdev_warn(tp_to_dev(tp), \"can't read MAC address, setting random one\\n\");\ndone:\n\teth_hw_addr_set(dev, mac_addr);\n\trtl_rar_set(tp, mac_addr);\n}\n\n \nstatic bool rtl_aspm_is_safe(struct rtl8169_private *tp)\n{\n\tif (tp->mac_version >= RTL_GIGA_MAC_VER_61 &&\n\t    r8168_mac_ocp_read(tp, 0xc0b2) & 0xf)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int rtl_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct rtl8169_private *tp;\n\tint jumbo_max, region, rc;\n\tenum mac_version chipset;\n\tstruct net_device *dev;\n\tu32 txconfig;\n\tu16 xid;\n\n\tdev = devm_alloc_etherdev(&pdev->dev, sizeof (*tp));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tdev->netdev_ops = &rtl_netdev_ops;\n\ttp = netdev_priv(dev);\n\ttp->dev = dev;\n\ttp->pci_dev = pdev;\n\ttp->supports_gmii = ent->driver_data == RTL_CFG_NO_GBIT ? 0 : 1;\n\ttp->eee_adv = -1;\n\ttp->ocp_base = OCP_STD_PHY_BASE;\n\n\traw_spin_lock_init(&tp->cfg9346_usage_lock);\n\traw_spin_lock_init(&tp->config25_lock);\n\traw_spin_lock_init(&tp->mac_ocp_lock);\n\n\tdev->tstats = devm_netdev_alloc_pcpu_stats(&pdev->dev,\n\t\t\t\t\t\t   struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\treturn -ENOMEM;\n\n\t \n\ttp->clk = devm_clk_get_optional_enabled(&pdev->dev, \"ether_clk\");\n\tif (IS_ERR(tp->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(tp->clk), \"failed to get ether_clk\\n\");\n\n\t \n\trc = pcim_enable_device(pdev);\n\tif (rc < 0)\n\t\treturn dev_err_probe(&pdev->dev, rc, \"enable failure\\n\");\n\n\tif (pcim_set_mwi(pdev) < 0)\n\t\tdev_info(&pdev->dev, \"Mem-Wr-Inval unavailable\\n\");\n\n\t \n\tregion = ffs(pci_select_bars(pdev, IORESOURCE_MEM)) - 1;\n\tif (region < 0)\n\t\treturn dev_err_probe(&pdev->dev, -ENODEV, \"no MMIO resource found\\n\");\n\n\trc = pcim_iomap_regions(pdev, BIT(region), KBUILD_MODNAME);\n\tif (rc < 0)\n\t\treturn dev_err_probe(&pdev->dev, rc, \"cannot remap MMIO, aborting\\n\");\n\n\ttp->mmio_addr = pcim_iomap_table(pdev)[region];\n\n\ttxconfig = RTL_R32(tp, TxConfig);\n\tif (txconfig == ~0U)\n\t\treturn dev_err_probe(&pdev->dev, -EIO, \"PCI read failed\\n\");\n\n\txid = (txconfig >> 20) & 0xfcf;\n\n\t \n\tchipset = rtl8169_get_mac_version(xid, tp->supports_gmii);\n\tif (chipset == RTL_GIGA_MAC_NONE)\n\t\treturn dev_err_probe(&pdev->dev, -ENODEV,\n\t\t\t\t     \"unknown chip XID %03x, contact r8169 maintainers (see MAINTAINERS file)\\n\",\n\t\t\t\t     xid);\n\ttp->mac_version = chipset;\n\n\t \n\tif (rtl_aspm_is_safe(tp))\n\t\trc = 0;\n\telse\n\t\trc = pci_disable_link_state(pdev, PCIE_LINK_STATE_L1);\n\ttp->aspm_manageable = !rc;\n\n\ttp->dash_type = rtl_get_dash_type(tp);\n\ttp->dash_enabled = rtl_dash_is_enabled(tp);\n\n\ttp->cp_cmd = RTL_R16(tp, CPlusCmd) & CPCMD_MASK;\n\n\tif (sizeof(dma_addr_t) > 4 && tp->mac_version >= RTL_GIGA_MAC_VER_18 &&\n\t    !dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64)))\n\t\tdev->features |= NETIF_F_HIGHDMA;\n\n\trtl_init_rxcfg(tp);\n\n\trtl8169_irq_mask_and_ack(tp);\n\n\trtl_hw_initialize(tp);\n\n\trtl_hw_reset(tp);\n\n\trc = rtl_alloc_irq(tp);\n\tif (rc < 0)\n\t\treturn dev_err_probe(&pdev->dev, rc, \"Can't allocate interrupt\\n\");\n\n\ttp->irq = pci_irq_vector(pdev, 0);\n\n\tINIT_WORK(&tp->wk.work, rtl_task);\n\n\trtl_init_mac_address(tp);\n\n\tdev->ethtool_ops = &rtl8169_ethtool_ops;\n\n\tnetif_napi_add(dev, &tp->napi, rtl8169_poll);\n\n\tdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM |\n\t\t\t   NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX;\n\tdev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO;\n\tdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\n\t \n\tif (tp->mac_version == RTL_GIGA_MAC_VER_05)\n\t\t \n\t\tdev->hw_features &= ~NETIF_F_HW_VLAN_CTAG_RX;\n\n\tif (rtl_chip_supports_csum_v2(tp))\n\t\tdev->hw_features |= NETIF_F_IPV6_CSUM;\n\n\tdev->features |= dev->hw_features;\n\n\t \n\tif (rtl_chip_supports_csum_v2(tp)) {\n\t\tdev->hw_features |= NETIF_F_SG | NETIF_F_TSO | NETIF_F_TSO6;\n\t\tnetif_set_tso_max_size(dev, RTL_GSO_MAX_SIZE_V2);\n\t\tnetif_set_tso_max_segs(dev, RTL_GSO_MAX_SEGS_V2);\n\t} else {\n\t\tdev->hw_features |= NETIF_F_SG | NETIF_F_TSO;\n\t\tnetif_set_tso_max_size(dev, RTL_GSO_MAX_SIZE_V1);\n\t\tnetif_set_tso_max_segs(dev, RTL_GSO_MAX_SEGS_V1);\n\t}\n\n\tdev->hw_features |= NETIF_F_RXALL;\n\tdev->hw_features |= NETIF_F_RXFCS;\n\n\tnetdev_sw_irq_coalesce_default_on(dev);\n\n\t \n\trtl8169_set_features(dev, dev->features);\n\n\tif (!tp->dash_enabled) {\n\t\trtl_set_d3_pll_down(tp, true);\n\t} else {\n\t\trtl_set_d3_pll_down(tp, false);\n\t\tdev->wol_enabled = 1;\n\t}\n\n\tjumbo_max = rtl_jumbo_max(tp);\n\tif (jumbo_max)\n\t\tdev->max_mtu = jumbo_max;\n\n\trtl_set_irq_mask(tp);\n\n\ttp->fw_name = rtl_chip_infos[chipset].fw_name;\n\n\ttp->counters = dmam_alloc_coherent (&pdev->dev, sizeof(*tp->counters),\n\t\t\t\t\t    &tp->counters_phys_addr,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!tp->counters)\n\t\treturn -ENOMEM;\n\n\tpci_set_drvdata(pdev, tp);\n\n\trc = r8169_mdio_register(tp);\n\tif (rc)\n\t\treturn rc;\n\n\trc = register_netdev(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tnetdev_info(dev, \"%s, %pM, XID %03x, IRQ %d\\n\",\n\t\t    rtl_chip_infos[chipset].name, dev->dev_addr, xid, tp->irq);\n\n\tif (jumbo_max)\n\t\tnetdev_info(dev, \"jumbo features [frames: %d bytes, tx checksumming: %s]\\n\",\n\t\t\t    jumbo_max, tp->mac_version <= RTL_GIGA_MAC_VER_06 ?\n\t\t\t    \"ok\" : \"ko\");\n\n\tif (tp->dash_type != RTL_DASH_NONE) {\n\t\tnetdev_info(dev, \"DASH %s\\n\",\n\t\t\t    tp->dash_enabled ? \"enabled\" : \"disabled\");\n\t\trtl8168_driver_start(tp);\n\t}\n\n\tif (pci_dev_run_wake(pdev))\n\t\tpm_runtime_put_sync(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic struct pci_driver rtl8169_pci_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= rtl8169_pci_tbl,\n\t.probe\t\t= rtl_init_one,\n\t.remove\t\t= rtl_remove_one,\n\t.shutdown\t= rtl_shutdown,\n\t.driver.pm\t= pm_ptr(&rtl8169_pm_ops),\n};\n\nmodule_pci_driver(rtl8169_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}