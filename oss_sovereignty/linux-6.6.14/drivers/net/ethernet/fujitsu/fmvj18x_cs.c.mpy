{
  "module_name": "fmvj18x_cs.c",
  "hash_id": "c4b66a081ca3423097c164ea872bf878f2fcdf24e543b4752f6bfb927a577500",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/fujitsu/fmvj18x_cs.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DRV_NAME\t\"fmvj18x_cs\"\n#define DRV_VERSION\t\"2.9\"\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/ioport.h>\n#include <linux/crc32.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ciscode.h>\n#include <pcmcia/ds.h>\n\n#include <linux/uaccess.h>\n#include <asm/io.h>\n\n \n\n \n\nMODULE_DESCRIPTION(\"fmvj18x and compatible PCMCIA ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define INT_MODULE_PARM(n, v) static int n = v; module_param(n, int, 0)\n\n \n \nINT_MODULE_PARM(sram_config, 0);\n\n\n \n \nstatic int fmvj18x_config(struct pcmcia_device *link);\nstatic int fmvj18x_get_hwinfo(struct pcmcia_device *link, u_char *node_id);\nstatic int fmvj18x_setup_mfc(struct pcmcia_device *link);\nstatic void fmvj18x_release(struct pcmcia_device *link);\nstatic void fmvj18x_detach(struct pcmcia_device *p_dev);\n\n \nstatic int fjn_config(struct net_device *dev, struct ifmap *map);\nstatic int fjn_open(struct net_device *dev);\nstatic int fjn_close(struct net_device *dev);\nstatic netdev_tx_t fjn_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev);\nstatic irqreturn_t fjn_interrupt(int irq, void *dev_id);\nstatic void fjn_rx(struct net_device *dev);\nstatic void fjn_reset(struct net_device *dev);\nstatic void set_rx_mode(struct net_device *dev);\nstatic void fjn_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic const struct ethtool_ops netdev_ethtool_ops;\n\n \nenum cardtype { MBH10302, MBH10304, TDK, CONTEC, LA501, UNGERMANN,\n\t       XXX10304, NEC, KME\n};\n\n \nstruct local_info {\n\tstruct pcmcia_device\t*p_dev;\n    long open_time;\n    uint tx_started:1;\n    uint tx_queue;\n    u_short tx_queue_len;\n    enum cardtype cardtype;\n    u_short sent;\n    u_char __iomem *base;\n};\n\n#define MC_FILTERBREAK 64\n\n \n \n#define TX_STATUS               0  \n#define RX_STATUS               1  \n#define TX_INTR                 2  \n#define RX_INTR                 3  \n#define TX_MODE                 4  \n#define RX_MODE                 5  \n#define CONFIG_0                6  \n#define CONFIG_1                7  \n\n#define NODE_ID                 8  \n#define MAR_ADR                 8  \n\n#define DATAPORT                8  \n#define TX_START               10  \n#define COL_CTRL               11  \n#define BMPR12                 12  \n#define BMPR13                 13  \n#define RX_SKIP                14  \n\n#define LAN_CTRL               16  \n\n#define MAC_ID               0x1a  \n#define UNGERMANN_MAC_ID     0x18  \n\n \n#define ENA_TMT_OK           0x80\n#define ENA_TMT_REC          0x20\n#define ENA_COL              0x04\n#define ENA_16_COL           0x02\n#define ENA_TBUS_ERR         0x01\n\n#define ENA_PKT_RDY          0x80\n#define ENA_BUS_ERR          0x40\n#define ENA_LEN_ERR          0x08\n#define ENA_ALG_ERR          0x04\n#define ENA_CRC_ERR          0x02\n#define ENA_OVR_FLO          0x01\n\n \n#define F_TMT_RDY            0x80  \n#define F_NET_BSY            0x40  \n#define F_TMT_OK             0x20  \n#define F_SRT_PKT            0x10  \n#define F_COL_ERR            0x04  \n#define F_16_COL             0x02  \n#define F_TBUS_ERR           0x01  \n\n#define F_PKT_RDY            0x80  \n#define F_BUS_ERR            0x40  \n#define F_LEN_ERR            0x08  \n#define F_ALG_ERR            0x04  \n#define F_CRC_ERR            0x02  \n#define F_OVR_FLO            0x01  \n\n#define F_BUF_EMP            0x40  \n\n#define F_SKP_PKT            0x05  \n\n \n#define D_TX_INTR  ( ENA_TMT_OK )\n#define D_RX_INTR  ( ENA_PKT_RDY | ENA_LEN_ERR \\\n\t\t   | ENA_ALG_ERR | ENA_CRC_ERR | ENA_OVR_FLO )\n#define TX_STAT_M  ( F_TMT_RDY )\n#define RX_STAT_M  ( F_PKT_RDY | F_LEN_ERR \\\n                   | F_ALG_ERR | F_CRC_ERR | F_OVR_FLO )\n\n \n#define D_TX_MODE            0x06  \n#define ID_MATCHED           0x02  \n#define RECV_ALL             0x03  \n#define CONFIG0_DFL          0x5a  \n#define CONFIG0_DFL_1        0x5e  \n#define CONFIG0_RST          0xda  \n#define CONFIG0_RST_1        0xde  \n#define BANK_0               0xa0  \n#define BANK_1               0xa4  \n#define BANK_2               0xa8  \n#define CHIP_OFF             0x80  \n#define DO_TX                0x80  \n#define SEND_PKT             0x81  \n#define AUTO_MODE            0x07  \n#define MANU_MODE            0x03  \n#define TDK_AUTO_MODE        0x47  \n#define TDK_MANU_MODE        0x43  \n#define INTR_OFF             0x0d  \n#define INTR_ON              0x1d  \n\n#define TX_TIMEOUT\t\t((400*HZ)/1000)\n\n#define BANK_0U              0x20  \n#define BANK_1U              0x24  \n#define BANK_2U              0x28  \n\nstatic const struct net_device_ops fjn_netdev_ops = {\n\t.ndo_open \t\t= fjn_open,\n\t.ndo_stop\t\t= fjn_close,\n\t.ndo_start_xmit \t= fjn_start_xmit,\n\t.ndo_tx_timeout \t= fjn_tx_timeout,\n\t.ndo_set_config \t= fjn_config,\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int fmvj18x_probe(struct pcmcia_device *link)\n{\n    struct local_info *lp;\n    struct net_device *dev;\n\n    dev_dbg(&link->dev, \"fmvj18x_attach()\\n\");\n\n     \n    dev = alloc_etherdev(sizeof(struct local_info));\n    if (!dev)\n\treturn -ENOMEM;\n    lp = netdev_priv(dev);\n    link->priv = dev;\n    lp->p_dev = link;\n    lp->base = NULL;\n\n     \n    link->resource[0]->end = 32;\n    link->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\n\n     \n    link->config_flags |= CONF_ENABLE_IRQ;\n\n    dev->netdev_ops = &fjn_netdev_ops;\n    dev->watchdog_timeo = TX_TIMEOUT;\n\n    dev->ethtool_ops = &netdev_ethtool_ops;\n\n    return fmvj18x_config(link);\n}  \n\n \n\nstatic void fmvj18x_detach(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n\n    dev_dbg(&link->dev, \"fmvj18x_detach\\n\");\n\n    unregister_netdev(dev);\n\n    fmvj18x_release(link);\n\n    free_netdev(dev);\n}  \n\n \n\nstatic int mfc_try_io_port(struct pcmcia_device *link)\n{\n    int i, ret;\n    static const unsigned int serial_base[5] =\n\t{ 0x3f8, 0x2f8, 0x3e8, 0x2e8, 0x0 };\n\n    for (i = 0; i < 5; i++) {\n\tlink->resource[1]->start = serial_base[i];\n\tlink->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\n\tif (link->resource[1]->start == 0) {\n\t    link->resource[1]->end = 0;\n\t    pr_notice(\"out of resource for serial\\n\");\n\t}\n\tret = pcmcia_request_io(link);\n\tif (ret == 0)\n\t\treturn ret;\n    }\n    return ret;\n}\n\nstatic int ungermann_try_io_port(struct pcmcia_device *link)\n{\n    int ret;\n    unsigned int ioaddr;\n     \n    for (ioaddr = 0x300; ioaddr < 0x3e0; ioaddr += 0x20) {\n\tlink->resource[0]->start = ioaddr;\n\tret = pcmcia_request_io(link);\n\tif (ret == 0) {\n\t     \n\t    link->config_index =\n\t\t((link->resource[0]->start & 0x0f0) >> 3) | 0x22;\n\t    return ret;\n\t}\n    }\n    return ret;\t \n}\n\nstatic int fmvj18x_ioprobe(struct pcmcia_device *p_dev, void *priv_data)\n{\n\treturn 0;  \n}\n\nstatic int fmvj18x_config(struct pcmcia_device *link)\n{\n    struct net_device *dev = link->priv;\n    struct local_info *lp = netdev_priv(dev);\n    int i, ret;\n    unsigned int ioaddr;\n    enum cardtype cardtype;\n    char *card_name = \"unknown\";\n    u8 *buf;\n    size_t len;\n    u_char buggybuf[32];\n    u8 addr[ETH_ALEN];\n\n    dev_dbg(&link->dev, \"fmvj18x_config\\n\");\n\n    link->io_lines = 5;\n\n    len = pcmcia_get_tuple(link, CISTPL_FUNCE, &buf);\n    kfree(buf);\n\n    if (len) {\n\t \n\tret = pcmcia_loop_config(link, fmvj18x_ioprobe, NULL);\n\tif (ret != 0)\n\t\tgoto failed;\n\n\tswitch (link->manf_id) {\n\tcase MANFID_TDK:\n\t    cardtype = TDK;\n\t    if (link->card_id == PRODID_TDK_GN3410 ||\n\t\tlink->card_id == PRODID_TDK_NP9610 ||\n\t\tlink->card_id == PRODID_TDK_MN3200) {\n\t\t \n\t\tlink->config_base = 0x800;\n\t\tlink->config_index = 0x47;\n\t\tlink->resource[1]->end = 8;\n\t    }\n\t    break;\n\tcase MANFID_NEC:\n\t    cardtype = NEC;  \n\t    link->config_base = 0x800;\n\t    link->config_index = 0x47;\n\t    link->resource[1]->end = 8;\n\t    break;\n\tcase MANFID_KME:\n\t    cardtype = KME;  \n\t    link->config_base = 0x800;\n\t    link->config_index = 0x47;\n\t    link->resource[1]->end = 8;\n\t    break;\n\tcase MANFID_CONTEC:\n\t    cardtype = CONTEC;\n\t    break;\n\tcase MANFID_FUJITSU:\n\t    if (link->config_base == 0x0fe0)\n\t\tcardtype = MBH10302;\n\t    else if (link->card_id == PRODID_FUJITSU_MBH10302) \n                  \n\t\tcardtype = MBH10304;\n\t    else if (link->card_id == PRODID_FUJITSU_MBH10304)\n\t\tcardtype = MBH10304;\n\t    else\n\t\tcardtype = LA501;\n\t    break;\n\tdefault:\n\t    cardtype = MBH10304;\n\t}\n    } else {\n\t \n\tswitch (link->manf_id) {\n\tcase MANFID_FUJITSU:\n\t    if (link->card_id == PRODID_FUJITSU_MBH10304) {\n\t\tcardtype = XXX10304;     \n\t\tlink->config_index = 0x20;\n\t    } else {\n\t\tcardtype = MBH10302;     \n\t\tlink->config_index = 1;\n\t    }\n\t    break;\n\tcase MANFID_UNGERMANN:\n\t    cardtype = UNGERMANN;\n\t    break;\n\tdefault:\n\t    cardtype = MBH10302;\n\t    link->config_index = 1;\n\t}\n    }\n\n    if (link->resource[1]->end != 0) {\n\tret = mfc_try_io_port(link);\n\tif (ret != 0) goto failed;\n    } else if (cardtype == UNGERMANN) {\n\tret = ungermann_try_io_port(link);\n\tif (ret != 0) goto failed;\n    } else { \n\t    ret = pcmcia_request_io(link);\n\t    if (ret)\n\t\t    goto failed;\n    }\n    ret = pcmcia_request_irq(link, fjn_interrupt);\n    if (ret)\n\t    goto failed;\n    ret = pcmcia_enable_device(link);\n    if (ret)\n\t    goto failed;\n\n    dev->irq = link->irq;\n    dev->base_addr = link->resource[0]->start;\n\n    if (resource_size(link->resource[1]) != 0) {\n\tret = fmvj18x_setup_mfc(link);\n\tif (ret != 0) goto failed;\n    }\n\n    ioaddr = dev->base_addr;\n\n     \n    if (sram_config == 0) \n\toutb(CONFIG0_RST, ioaddr + CONFIG_0);\n    else\n\toutb(CONFIG0_RST_1, ioaddr + CONFIG_0);\n\n     \n    if (cardtype == MBH10302)\n\toutb(BANK_0, ioaddr + CONFIG_1);\n    else\n\toutb(BANK_0U, ioaddr + CONFIG_1);\n    \n     \n    switch (cardtype) {\n    case MBH10304:\n    case TDK:\n    case LA501:\n    case CONTEC:\n    case NEC:\n    case KME:\n\tif (cardtype == MBH10304) {\n\t    card_name = \"FMV-J182\";\n\n\t    len = pcmcia_get_tuple(link, CISTPL_FUNCE, &buf);\n\t    if (len < 11) {\n\t\t    kfree(buf);\n\t\t    goto failed;\n\t    }\n\t     \n\t    eth_hw_addr_set(dev, &buf[5]);\n\t    kfree(buf);\n\t} else {\n\t    if (pcmcia_get_mac_from_cis(link, dev))\n\t\tgoto failed;\n\t    if( cardtype == TDK ) {\n\t\tcard_name = \"TDK LAK-CD021\";\n\t    } else if( cardtype == LA501 ) {\n\t\tcard_name = \"LA501\";\n\t    } else if( cardtype == NEC ) {\n\t\tcard_name = \"PK-UG-J001\";\n\t    } else if( cardtype == KME ) {\n\t\tcard_name = \"Panasonic\";\n\t    } else {\n\t\tcard_name = \"C-NET(PC)C\";\n\t    }\n\t}\n\tbreak;\n    case UNGERMANN:\n\t \n\tfor (i = 0; i < 6; i++) \n\t    addr[i] = inb(ioaddr + UNGERMANN_MAC_ID + i);\n\teth_hw_addr_set(dev, addr);\n\tcard_name = \"Access/CARD\";\n\tbreak;\n    case XXX10304:\n\t \n\tif (fmvj18x_get_hwinfo(link, buggybuf) == -1) {\n\t    pr_notice(\"unable to read hardware net address\\n\");\n\t    goto failed;\n\t}\n\teth_hw_addr_set(dev, buggybuf);\n\tcard_name = \"FMV-J182\";\n\tbreak;\n    case MBH10302:\n    default:\n\t \n\tfor (i = 0; i < 6; i++) \n\t    addr[i] = inb(ioaddr + MAC_ID + i);\n\teth_hw_addr_set(dev, addr);\n\tcard_name = \"FMV-J181\";\n\tbreak;\n    }\n\n    lp->cardtype = cardtype;\n    SET_NETDEV_DEV(dev, &link->dev);\n\n    if (register_netdev(dev) != 0) {\n\tpr_notice(\"register_netdev() failed\\n\");\n\tgoto failed;\n    }\n\n     \n    netdev_info(dev, \"%s, sram %s, port %#3lx, irq %d, hw_addr %pM\\n\",\n\t\tcard_name, sram_config == 0 ? \"4K TX*2\" : \"8K TX*2\",\n\t\tdev->base_addr, dev->irq, dev->dev_addr);\n\n    return 0;\n    \nfailed:\n    fmvj18x_release(link);\n    return -ENODEV;\n}  \n \n\nstatic int fmvj18x_get_hwinfo(struct pcmcia_device *link, u_char *node_id)\n{\n    u_char __iomem *base;\n    int i, j;\n\n     \n    link->resource[2]->flags |= WIN_DATA_WIDTH_8|WIN_MEMORY_TYPE_AM|WIN_ENABLE;\n    link->resource[2]->start = 0; link->resource[2]->end = 0;\n    i = pcmcia_request_window(link, link->resource[2], 0);\n    if (i != 0)\n\treturn -1;\n\n    base = ioremap(link->resource[2]->start, resource_size(link->resource[2]));\n    if (!base) {\n\tpcmcia_release_window(link, link->resource[2]);\n\treturn -1;\n    }\n\n    pcmcia_map_mem_page(link, link->resource[2], 0);\n\n      \n    for (i = 0; i < 0x200; i++) {\n\tif (readb(base+i*2) == 0x22) {\t\n\t\tif (readb(base+(i-1)*2) == 0xff &&\n\t\t    readb(base+(i+5)*2) == 0x04 &&\n\t\t    readb(base+(i+6)*2) == 0x06 &&\n\t\t    readb(base+(i+13)*2) == 0xff)\n\t\t\tbreak;\n\t}\n    }\n\n    if (i != 0x200) {\n\tfor (j = 0 ; j < 6; j++,i++) {\n\t    node_id[j] = readb(base+(i+7)*2);\n\t}\n    }\n\n    iounmap(base);\n    j = pcmcia_release_window(link, link->resource[2]);\n    return (i != 0x200) ? 0 : -1;\n\n}  \n \n\nstatic int fmvj18x_setup_mfc(struct pcmcia_device *link)\n{\n    int i;\n    struct net_device *dev = link->priv;\n    unsigned int ioaddr;\n    struct local_info *lp = netdev_priv(dev);\n\n     \n    link->resource[3]->flags = WIN_DATA_WIDTH_8|WIN_MEMORY_TYPE_AM|WIN_ENABLE;\n    link->resource[3]->start = link->resource[3]->end = 0;\n    i = pcmcia_request_window(link, link->resource[3], 0);\n    if (i != 0)\n\treturn -1;\n\n    lp->base = ioremap(link->resource[3]->start,\n\t\t       resource_size(link->resource[3]));\n    if (lp->base == NULL) {\n\tnetdev_notice(dev, \"ioremap failed\\n\");\n\treturn -1;\n    }\n\n    i = pcmcia_map_mem_page(link, link->resource[3], 0);\n    if (i != 0) {\n\tiounmap(lp->base);\n\tlp->base = NULL;\n\treturn -1;\n    }\n    \n    ioaddr = dev->base_addr;\n    writeb(0x47, lp->base+0x800);\t \n    writeb(0x0,  lp->base+0x802);\t \n\n    writeb(ioaddr & 0xff, lp->base+0x80a);\t   \n    writeb((ioaddr >> 8) & 0xff, lp->base+0x80c);  \n   \n    writeb(0x45, lp->base+0x820);\t \n    writeb(0x8,  lp->base+0x822);\t \n\n    return 0;\n\n}\n \n\nstatic void fmvj18x_release(struct pcmcia_device *link)\n{\n\n    struct net_device *dev = link->priv;\n    struct local_info *lp = netdev_priv(dev);\n    u_char __iomem *tmp;\n\n    dev_dbg(&link->dev, \"fmvj18x_release\\n\");\n\n    if (lp->base != NULL) {\n\ttmp = lp->base;\n\tlp->base = NULL;     \n\tiounmap(tmp);\n    }\n\n    pcmcia_disable_device(link);\n\n}\n\nstatic int fmvj18x_suspend(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open)\n\t\tnetif_device_detach(dev);\n\n\treturn 0;\n}\n\nstatic int fmvj18x_resume(struct pcmcia_device *link)\n{\n\tstruct net_device *dev = link->priv;\n\n\tif (link->open) {\n\t\tfjn_reset(dev);\n\t\tnetif_device_attach(dev);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const struct pcmcia_device_id fmvj18x_ids[] = {\n\tPCMCIA_DEVICE_MANF_CARD(0x0004, 0x0004),\n\tPCMCIA_DEVICE_PROD_ID12(\"EAGLE Technology\", \"NE200 ETHERNET LAN MBH10302 04\", 0x528c88c4, 0x74f91e59),\n\tPCMCIA_DEVICE_PROD_ID12(\"Eiger Labs,Inc\", \"EPX-10BT PC Card Ethernet 10BT\", 0x53af556e, 0x877f9922),\n\tPCMCIA_DEVICE_PROD_ID12(\"Eiger labs,Inc.\", \"EPX-10BT PC Card Ethernet 10BT\", 0xf47e6c66, 0x877f9922),\n\tPCMCIA_DEVICE_PROD_ID12(\"FUJITSU\", \"LAN Card(FMV-J182)\", 0x6ee5a3d8, 0x5baf31db),\n\tPCMCIA_DEVICE_PROD_ID12(\"FUJITSU\", \"MBH10308\", 0x6ee5a3d8, 0x3f04875e),\n\tPCMCIA_DEVICE_PROD_ID12(\"FUJITSU TOWA\", \"LA501\", 0xb8451188, 0x12939ba2),\n\tPCMCIA_DEVICE_PROD_ID12(\"HITACHI\", \"HT-4840-11\", 0xf4f43949, 0x773910f4),\n\tPCMCIA_DEVICE_PROD_ID12(\"NextComK.K.\", \"NC5310B Ver1.0       \", 0x8cef4d3a, 0x075fc7b6),\n\tPCMCIA_DEVICE_PROD_ID12(\"NextComK.K.\", \"NC5310 Ver1.0        \", 0x8cef4d3a, 0xbccf43e6),\n\tPCMCIA_DEVICE_PROD_ID12(\"RATOC System Inc.\", \"10BASE_T CARD R280\", 0x85c10e17, 0xd9413666),\n\tPCMCIA_DEVICE_PROD_ID12(\"TDK\", \"LAC-CD02x\", 0x1eae9475, 0x8fa0ee70),\n\tPCMCIA_DEVICE_PROD_ID12(\"TDK\", \"LAC-CF010\", 0x1eae9475, 0x7683bc9a),\n\tPCMCIA_DEVICE_PROD_ID1(\"CONTEC Co.,Ltd.\", 0x58d8fee2),\n\tPCMCIA_DEVICE_PROD_ID1(\"PCMCIA LAN MBH10304  ES\", 0x2599f454),\n\tPCMCIA_DEVICE_PROD_ID1(\"PCMCIA MBH10302\", 0x8f4005da),\n\tPCMCIA_DEVICE_PROD_ID1(\"UBKK,V2.0\", 0x90888080),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"TDK\", \"GlobalNetworker 3410/3412\", 0x1eae9475, 0xd9a93bed),\n\tPCMCIA_PFC_DEVICE_PROD_ID12(0, \"NEC\", \"PK-UG-J001\" ,0x18df0ba0 ,0x831b1064),\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0105, 0x0d0a),\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0105, 0x0e0a),\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0032, 0x0e01),\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0032, 0x0a05),\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0032, 0x0b05),\n\tPCMCIA_PFC_DEVICE_MANF_CARD(0, 0x0032, 0x1101),\n\tPCMCIA_DEVICE_NULL,\n};\nMODULE_DEVICE_TABLE(pcmcia, fmvj18x_ids);\n\nstatic struct pcmcia_driver fmvj18x_cs_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fmvj18x_cs\",\n\t.probe\t\t= fmvj18x_probe,\n\t.remove\t\t= fmvj18x_detach,\n\t.id_table       = fmvj18x_ids,\n\t.suspend\t= fmvj18x_suspend,\n\t.resume\t\t= fmvj18x_resume,\n};\nmodule_pcmcia_driver(fmvj18x_cs_driver);\n\n \n\nstatic irqreturn_t fjn_interrupt(int dummy, void *dev_id)\n{\n    struct net_device *dev = dev_id;\n    struct local_info *lp = netdev_priv(dev);\n    unsigned int ioaddr;\n    unsigned short tx_stat, rx_stat;\n\n    ioaddr = dev->base_addr;\n\n     \n    outw(0x0000, ioaddr + TX_INTR);\n\n     \n    udelay(1);\n\n     \n    tx_stat = inb(ioaddr + TX_STATUS);\n    rx_stat = inb(ioaddr + RX_STATUS);\n\n     \n    outb(tx_stat, ioaddr + TX_STATUS);\n    outb(rx_stat, ioaddr + RX_STATUS);\n    \n    pr_debug(\"%s: interrupt, rx_status %02x.\\n\", dev->name, rx_stat);\n    pr_debug(\"               tx_status %02x.\\n\", tx_stat);\n    \n    if (rx_stat || (inb(ioaddr + RX_MODE) & F_BUF_EMP) == 0) {\n\t \n\tfjn_rx(dev);\n    }\n    if (tx_stat & F_TMT_RDY) {\n\tdev->stats.tx_packets += lp->sent ;\n        lp->sent = 0 ;\n\tif (lp->tx_queue) {\n\t    outb(DO_TX | lp->tx_queue, ioaddr + TX_START);\n\t    lp->sent = lp->tx_queue ;\n\t    lp->tx_queue = 0;\n\t    lp->tx_queue_len = 0;\n\t    netif_trans_update(dev);\n\t} else {\n\t    lp->tx_started = 0;\n\t}\n\tnetif_wake_queue(dev);\n    }\n    pr_debug(\"%s: exiting interrupt,\\n\", dev->name);\n    pr_debug(\"    tx_status %02x, rx_status %02x.\\n\", tx_stat, rx_stat);\n\n    outb(D_TX_INTR, ioaddr + TX_INTR);\n    outb(D_RX_INTR, ioaddr + RX_INTR);\n\n    if (lp->base != NULL) {\n\t \n\twriteb(0x01, lp->base+0x802);\n\twriteb(0x09, lp->base+0x822);\n    }\n\n    return IRQ_HANDLED;\n\n}  \n\n \n\nstatic void fjn_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n    struct local_info *lp = netdev_priv(dev);\n    unsigned int ioaddr = dev->base_addr;\n\n    netdev_notice(dev, \"transmit timed out with status %04x, %s?\\n\",\n\t\t  htons(inw(ioaddr + TX_STATUS)),\n\t\t  inb(ioaddr + TX_STATUS) & F_TMT_RDY\n\t\t  ? \"IRQ conflict\" : \"network cable problem\");\n    netdev_notice(dev, \"timeout registers: %04x %04x %04x \"\n\t\t  \"%04x %04x %04x %04x %04x.\\n\",\n\t\t  htons(inw(ioaddr + 0)), htons(inw(ioaddr + 2)),\n\t\t  htons(inw(ioaddr + 4)), htons(inw(ioaddr + 6)),\n\t\t  htons(inw(ioaddr + 8)), htons(inw(ioaddr + 10)),\n\t\t  htons(inw(ioaddr + 12)), htons(inw(ioaddr + 14)));\n    dev->stats.tx_errors++;\n     \n    local_irq_disable();\n    fjn_reset(dev);\n\n    lp->tx_started = 0;\n    lp->tx_queue = 0;\n    lp->tx_queue_len = 0;\n    lp->sent = 0;\n    lp->open_time = jiffies;\n    local_irq_enable();\n    netif_wake_queue(dev);\n}\n\nstatic netdev_tx_t fjn_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n    struct local_info *lp = netdev_priv(dev);\n    unsigned int ioaddr = dev->base_addr;\n    short length = skb->len;\n    \n    if (length < ETH_ZLEN)\n    {\n\tif (skb_padto(skb, ETH_ZLEN))\n\t\treturn NETDEV_TX_OK;\n\tlength = ETH_ZLEN;\n    }\n\n    netif_stop_queue(dev);\n\n    {\n\tunsigned char *buf = skb->data;\n\n\tif (length > ETH_FRAME_LEN) {\n\t    netdev_notice(dev, \"Attempting to send a large packet (%d bytes)\\n\",\n\t\t\t  length);\n\t    return NETDEV_TX_BUSY;\n\t}\n\n\tnetdev_dbg(dev, \"Transmitting a packet of length %lu\\n\",\n\t\t   (unsigned long)skb->len);\n\tdev->stats.tx_bytes += skb->len;\n\n\t \n\toutw(0x0000, ioaddr + TX_INTR);\n\n\t \n\tudelay(1);\n\n\toutw(length, ioaddr + DATAPORT);\n\toutsw(ioaddr + DATAPORT, buf, (length + 1) >> 1);\n\n\tlp->tx_queue++;\n\tlp->tx_queue_len += ((length+3) & ~1);\n\n\tif (lp->tx_started == 0) {\n\t     \n\t    outb(DO_TX | lp->tx_queue, ioaddr + TX_START);\n\t    lp->sent = lp->tx_queue ;\n\t    lp->tx_queue = 0;\n\t    lp->tx_queue_len = 0;\n\t    lp->tx_started = 1;\n\t    netif_start_queue(dev);\n\t} else {\n\t    if( sram_config == 0 ) {\n\t\tif (lp->tx_queue_len < (4096 - (ETH_FRAME_LEN +2)) )\n\t\t     \n\t\t    netif_start_queue(dev);\n\t    } else {\n\t\tif (lp->tx_queue_len < (8192 - (ETH_FRAME_LEN +2)) && \n\t\t\t\t\t\tlp->tx_queue < 127 )\n\t\t     \n\t\t    netif_start_queue(dev);\n\t    }\n\t}\n\n\t \n\toutb(D_TX_INTR, ioaddr + TX_INTR);\n\toutb(D_RX_INTR, ioaddr + RX_INTR);\n    }\n    dev_kfree_skb (skb);\n\n    return NETDEV_TX_OK;\n}  \n\n \n\nstatic void fjn_reset(struct net_device *dev)\n{\n    struct local_info *lp = netdev_priv(dev);\n    unsigned int ioaddr = dev->base_addr;\n    int i;\n\n    netdev_dbg(dev, \"fjn_reset() called\\n\");\n\n     \n    if( sram_config == 0 ) \n\toutb(CONFIG0_RST, ioaddr + CONFIG_0);\n    else\n\toutb(CONFIG0_RST_1, ioaddr + CONFIG_0);\n\n     \n    if (lp->cardtype == MBH10302)\n\toutb(BANK_0, ioaddr + CONFIG_1);\n    else\n\toutb(BANK_0U, ioaddr + CONFIG_1);\n\n     \n    outb(D_TX_MODE, ioaddr + TX_MODE);\n     \n    outb(ID_MATCHED, ioaddr + RX_MODE);\n\n     \n    for (i = 0; i < 6; i++) \n        outb(dev->dev_addr[i], ioaddr + NODE_ID + i);\n\n     \n    set_rx_mode(dev);\n\n     \n    if (lp->cardtype == MBH10302)\n\toutb(BANK_2, ioaddr + CONFIG_1);\n    else\n\toutb(BANK_2U, ioaddr + CONFIG_1);\n\n     \n    if( lp->cardtype == TDK || lp->cardtype == CONTEC) \n        outb(TDK_AUTO_MODE, ioaddr + COL_CTRL);\n    else\n        outb(AUTO_MODE, ioaddr + COL_CTRL);\n\n     \n    outb(0x00, ioaddr + BMPR12);\n    outb(0x00, ioaddr + BMPR13);\n\n     \n    outb(0x01, ioaddr + RX_SKIP);\n\n     \n    if( sram_config == 0 )\n\toutb(CONFIG0_DFL, ioaddr + CONFIG_0);\n    else\n\toutb(CONFIG0_DFL_1, ioaddr + CONFIG_0);\n\n     \n    inw(ioaddr + DATAPORT);\n    inw(ioaddr + DATAPORT);\n\n     \n    outb(0xff, ioaddr + TX_STATUS);\n    outb(0xff, ioaddr + RX_STATUS);\n\n    if (lp->cardtype == MBH10302)\n\toutb(INTR_OFF, ioaddr + LAN_CTRL);\n\n     \n    outb(D_TX_INTR, ioaddr + TX_INTR);\n    outb(D_RX_INTR, ioaddr + RX_INTR);\n\n     \n    if (lp->cardtype == MBH10302)\n\toutb(INTR_ON, ioaddr + LAN_CTRL);\n}  \n\n \n\nstatic void fjn_rx(struct net_device *dev)\n{\n    unsigned int ioaddr = dev->base_addr;\n    int boguscount = 10;\t \n\n    pr_debug(\"%s: in rx_packet(), rx_status %02x.\\n\",\n\t  dev->name, inb(ioaddr + RX_STATUS));\n\n    while ((inb(ioaddr + RX_MODE) & F_BUF_EMP) == 0) {\n\tu_short status = inw(ioaddr + DATAPORT);\n\n\tnetdev_dbg(dev, \"Rxing packet mode %02x status %04x.\\n\",\n\t\t   inb(ioaddr + RX_MODE), status);\n#ifndef final_version\n\tif (status == 0) {\n\t    outb(F_SKP_PKT, ioaddr + RX_SKIP);\n\t    break;\n\t}\n#endif\n\tif ((status & 0xF0) != 0x20) {\t \n\t    dev->stats.rx_errors++;\n\t    if (status & F_LEN_ERR) dev->stats.rx_length_errors++;\n\t    if (status & F_ALG_ERR) dev->stats.rx_frame_errors++;\n\t    if (status & F_CRC_ERR) dev->stats.rx_crc_errors++;\n\t    if (status & F_OVR_FLO) dev->stats.rx_over_errors++;\n\t} else {\n\t    u_short pkt_len = inw(ioaddr + DATAPORT);\n\t     \n\t    struct sk_buff *skb;\n\n\t    if (pkt_len > 1550) {\n\t\tnetdev_notice(dev, \"The FMV-18x claimed a very large packet, size %d\\n\",\n\t\t\t      pkt_len);\n\t\toutb(F_SKP_PKT, ioaddr + RX_SKIP);\n\t\tdev->stats.rx_errors++;\n\t\tbreak;\n\t    }\n\t    skb = netdev_alloc_skb(dev, pkt_len + 2);\n\t    if (skb == NULL) {\n\t\toutb(F_SKP_PKT, ioaddr + RX_SKIP);\n\t\tdev->stats.rx_dropped++;\n\t\tbreak;\n\t    }\n\n\t    skb_reserve(skb, 2);\n\t    insw(ioaddr + DATAPORT, skb_put(skb, pkt_len),\n\t\t (pkt_len + 1) >> 1);\n\t    skb->protocol = eth_type_trans(skb, dev);\n\n\t    {\n\t\tint i;\n\t\tpr_debug(\"%s: Rxed packet of length %d: \",\n\t\t\tdev->name, pkt_len);\n\t\tfor (i = 0; i < 14; i++)\n\t\t\tpr_debug(\" %02x\", skb->data[i]);\n\t\tpr_debug(\".\\n\");\n\t    }\n\n\t    netif_rx(skb);\n\t    dev->stats.rx_packets++;\n\t    dev->stats.rx_bytes += pkt_len;\n\t}\n\tif (--boguscount <= 0)\n\t    break;\n    }\n\n     \n \n}  \n\n \n\nstatic void netdev_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tsnprintf(info->bus_info, sizeof(info->bus_info),\n\t\t\"PCMCIA 0x%lx\", dev->base_addr);\n}\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.get_drvinfo\t\t= netdev_get_drvinfo,\n};\n\nstatic int fjn_config(struct net_device *dev, struct ifmap *map){\n    return 0;\n}\n\nstatic int fjn_open(struct net_device *dev)\n{\n    struct local_info *lp = netdev_priv(dev);\n    struct pcmcia_device *link = lp->p_dev;\n\n    pr_debug(\"fjn_open('%s').\\n\", dev->name);\n\n    if (!pcmcia_dev_present(link))\n\treturn -ENODEV;\n    \n    link->open++;\n    \n    fjn_reset(dev);\n    \n    lp->tx_started = 0;\n    lp->tx_queue = 0;\n    lp->tx_queue_len = 0;\n    lp->open_time = jiffies;\n    netif_start_queue(dev);\n    \n    return 0;\n}  \n\n \n\nstatic int fjn_close(struct net_device *dev)\n{\n    struct local_info *lp = netdev_priv(dev);\n    struct pcmcia_device *link = lp->p_dev;\n    unsigned int ioaddr = dev->base_addr;\n\n    pr_debug(\"fjn_close('%s').\\n\", dev->name);\n\n    lp->open_time = 0;\n    netif_stop_queue(dev);\n\n     \n    if( sram_config == 0 ) \n\toutb(CONFIG0_RST ,ioaddr + CONFIG_0);\n    else\n\toutb(CONFIG0_RST_1 ,ioaddr + CONFIG_0);\n\n     \n\n     \n    outb(CHIP_OFF ,ioaddr + CONFIG_1);\n\n     \n    if (lp->cardtype == MBH10302)\n\toutb(INTR_OFF, ioaddr + LAN_CTRL);\n\n    link->open--;\n\n    return 0;\n}  \n\n \n\n \n\nstatic void set_rx_mode(struct net_device *dev)\n{\n    unsigned int ioaddr = dev->base_addr;\n    u_char mc_filter[8];\t\t  \n    u_long flags;\n    int i;\n    \n    int saved_bank;\n    int saved_config_0 = inb(ioaddr + CONFIG_0);\n     \n    local_irq_save(flags); \n\n     \n    if (sram_config == 0) \n\toutb(CONFIG0_RST, ioaddr + CONFIG_0);\n    else\n\toutb(CONFIG0_RST_1, ioaddr + CONFIG_0);\n\n    if (dev->flags & IFF_PROMISC) {\n\tmemset(mc_filter, 0xff, sizeof(mc_filter));\n\toutb(3, ioaddr + RX_MODE);\t \n    } else if (netdev_mc_count(dev) > MC_FILTERBREAK ||\n\t       (dev->flags & IFF_ALLMULTI)) {\n\t \n\tmemset(mc_filter, 0xff, sizeof(mc_filter));\n\toutb(2, ioaddr + RX_MODE);\t \n    } else if (netdev_mc_empty(dev)) {\n\tmemset(mc_filter, 0x00, sizeof(mc_filter));\n\toutb(1, ioaddr + RX_MODE);\t \n    } else {\n\tstruct netdev_hw_addr *ha;\n\n\tmemset(mc_filter, 0, sizeof(mc_filter));\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t    unsigned int bit = ether_crc_le(ETH_ALEN, ha->addr) >> 26;\n\t    mc_filter[bit >> 3] |= (1 << (bit & 7));\n\t}\n\toutb(2, ioaddr + RX_MODE);\t \n    }\n\n     \n    saved_bank = inb(ioaddr + CONFIG_1);\n    outb(0xe4, ioaddr + CONFIG_1);\n\n    for (i = 0; i < 8; i++)\n\toutb(mc_filter[i], ioaddr + MAR_ADR + i);\n    outb(saved_bank, ioaddr + CONFIG_1);\n\n    outb(saved_config_0, ioaddr + CONFIG_0);\n\n    local_irq_restore(flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}