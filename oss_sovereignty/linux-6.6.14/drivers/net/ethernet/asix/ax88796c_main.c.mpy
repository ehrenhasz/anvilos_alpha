{
  "module_name": "ax88796c_main.c",
  "hash_id": "7202042d0652be607ce1887c8142ba680eb0bd6dd045314c60b7f1fecbe90a59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/asix/ax88796c_main.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"ax88796c: \" fmt\n\n#include \"ax88796c_main.h\"\n#include \"ax88796c_ioctl.h\"\n\n#include <linux/bitmap.h>\n#include <linux/etherdevice.h>\n#include <linux/iopoll.h>\n#include <linux/lockdep.h>\n#include <linux/mdio.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/phy.h>\n#include <linux/skbuff.h>\n#include <linux/spi/spi.h>\n\nstatic int comp = IS_ENABLED(CONFIG_SPI_AX88796C_COMPRESSION);\nstatic int msg_enable = NETIF_MSG_PROBE |\n\t\t\tNETIF_MSG_LINK |\n\t\t\tNETIF_MSG_RX_ERR |\n\t\t\tNETIF_MSG_TX_ERR;\n\nstatic const char *no_regs_list = \"80018001,e1918001,8001a001,fc0d0000\";\nunsigned long ax88796c_no_regs_mask[AX88796C_REGDUMP_LEN / (sizeof(unsigned long) * 8)];\n\nmodule_param(msg_enable, int, 0444);\nMODULE_PARM_DESC(msg_enable, \"Message mask (see linux/netdevice.h for bitmap)\");\n\nstatic int ax88796c_soft_reset(struct ax88796c_device *ax_local)\n{\n\tu16 temp;\n\tint ret;\n\n\tlockdep_assert_held(&ax_local->spi_lock);\n\n\tAX_WRITE(&ax_local->ax_spi, PSR_RESET, P0_PSR);\n\tAX_WRITE(&ax_local->ax_spi, PSR_RESET_CLR, P0_PSR);\n\n\tret = read_poll_timeout(AX_READ, ret,\n\t\t\t\t(ret & PSR_DEV_READY),\n\t\t\t\t0, jiffies_to_usecs(160 * HZ / 1000), false,\n\t\t\t\t&ax_local->ax_spi, P0_PSR);\n\tif (ret)\n\t\treturn ret;\n\n\ttemp = AX_READ(&ax_local->ax_spi, P4_SPICR);\n\tif (ax_local->priv_flags & AX_CAP_COMP) {\n\t\tAX_WRITE(&ax_local->ax_spi,\n\t\t\t (temp | SPICR_RCEN | SPICR_QCEN), P4_SPICR);\n\t\tax_local->ax_spi.comp = 1;\n\t} else {\n\t\tAX_WRITE(&ax_local->ax_spi,\n\t\t\t (temp & ~(SPICR_RCEN | SPICR_QCEN)), P4_SPICR);\n\t\tax_local->ax_spi.comp = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int ax88796c_reload_eeprom(struct ax88796c_device *ax_local)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ax_local->spi_lock);\n\n\tAX_WRITE(&ax_local->ax_spi, EECR_RELOAD, P3_EECR);\n\n\tret = read_poll_timeout(AX_READ, ret,\n\t\t\t\t(ret & PSR_DEV_READY),\n\t\t\t\t0, jiffies_to_usecs(2 * HZ / 1000), false,\n\t\t\t\t&ax_local->ax_spi, P0_PSR);\n\tif (ret) {\n\t\tdev_err(&ax_local->spi->dev,\n\t\t\t\"timeout waiting for reload eeprom\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ax88796c_set_hw_multicast(struct net_device *ndev)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\tint mc_count = netdev_mc_count(ndev);\n\tu16 rx_ctl = RXCR_AB;\n\n\tlockdep_assert_held(&ax_local->spi_lock);\n\n\tmemset(ax_local->multi_filter, 0, AX_MCAST_FILTER_SIZE);\n\n\tif (ndev->flags & IFF_PROMISC) {\n\t\trx_ctl |= RXCR_PRO;\n\n\t} else if (ndev->flags & IFF_ALLMULTI || mc_count > AX_MAX_MCAST) {\n\t\trx_ctl |= RXCR_AMALL;\n\n\t} else if (mc_count == 0) {\n\t\t \n\t} else {\n\t\tu32 crc_bits;\n\t\tint i;\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tnetdev_for_each_mc_addr(ha, ndev) {\n\t\t\tcrc_bits = ether_crc(ETH_ALEN, ha->addr);\n\t\t\tax_local->multi_filter[crc_bits >> 29] |=\n\t\t\t\t\t\t(1 << ((crc_bits >> 26) & 7));\n\t\t}\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tAX_WRITE(&ax_local->ax_spi,\n\t\t\t\t ((ax_local->multi_filter[i * 2 + 1] << 8) |\n\t\t\t\t  ax_local->multi_filter[i * 2]), P3_MFAR(i));\n\t\t}\n\t}\n\n\tAX_WRITE(&ax_local->ax_spi, rx_ctl, P2_RXCR);\n}\n\nstatic void ax88796c_set_mac_addr(struct net_device *ndev)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\n\tlockdep_assert_held(&ax_local->spi_lock);\n\n\tAX_WRITE(&ax_local->ax_spi, ((u16)(ndev->dev_addr[4] << 8) |\n\t\t\t(u16)ndev->dev_addr[5]), P3_MACASR0);\n\tAX_WRITE(&ax_local->ax_spi, ((u16)(ndev->dev_addr[2] << 8) |\n\t\t\t(u16)ndev->dev_addr[3]), P3_MACASR1);\n\tAX_WRITE(&ax_local->ax_spi, ((u16)(ndev->dev_addr[0] << 8) |\n\t\t\t(u16)ndev->dev_addr[1]), P3_MACASR2);\n}\n\nstatic void ax88796c_load_mac_addr(struct net_device *ndev)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\tu8 addr[ETH_ALEN];\n\tu16 temp;\n\n\tlockdep_assert_held(&ax_local->spi_lock);\n\n\t \n\tif (!platform_get_ethdev_address(&ax_local->spi->dev, ndev) &&\n\t    is_valid_ether_addr(ndev->dev_addr)) {\n\t\tif (netif_msg_probe(ax_local))\n\t\t\tdev_info(&ax_local->spi->dev,\n\t\t\t\t \"MAC address read from device tree\\n\");\n\t\treturn;\n\t}\n\n\t \n\ttemp = AX_READ(&ax_local->ax_spi, P3_MACASR0);\n\taddr[5] = (u8)temp;\n\taddr[4] = (u8)(temp >> 8);\n\n\ttemp = AX_READ(&ax_local->ax_spi, P3_MACASR1);\n\taddr[3] = (u8)temp;\n\taddr[2] = (u8)(temp >> 8);\n\n\ttemp = AX_READ(&ax_local->ax_spi, P3_MACASR2);\n\taddr[1] = (u8)temp;\n\taddr[0] = (u8)(temp >> 8);\n\n\tif (is_valid_ether_addr(addr)) {\n\t\teth_hw_addr_set(ndev, addr);\n\t\tif (netif_msg_probe(ax_local))\n\t\t\tdev_info(&ax_local->spi->dev,\n\t\t\t\t \"MAC address read from ASIX chip\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (netif_msg_probe(ax_local))\n\t\tdev_info(&ax_local->spi->dev, \"Use random MAC address\\n\");\n\teth_hw_addr_random(ndev);\n}\n\nstatic void ax88796c_proc_tx_hdr(struct tx_pkt_info *info, u8 ip_summed)\n{\n\tu16 pkt_len_bar = (~info->pkt_len & TX_HDR_SOP_PKTLENBAR);\n\n\t \n\tinfo->sop.flags_len = info->pkt_len |\n\t\t((ip_summed == CHECKSUM_NONE) ||\n\t\t (ip_summed == CHECKSUM_UNNECESSARY) ? TX_HDR_SOP_DICF : 0);\n\n\tinfo->sop.seq_lenbar = ((info->seq_num << 11) & TX_HDR_SOP_SEQNUM)\n\t\t\t\t| pkt_len_bar;\n\tcpu_to_be16s(&info->sop.flags_len);\n\tcpu_to_be16s(&info->sop.seq_lenbar);\n\n\t \n\tinfo->seg.flags_seqnum_seglen = TX_HDR_SEG_FS | TX_HDR_SEG_LS\n\t\t\t\t\t\t| info->pkt_len;\n\n\tinfo->seg.eo_so_seglenbar = pkt_len_bar;\n\n\tcpu_to_be16s(&info->seg.flags_seqnum_seglen);\n\tcpu_to_be16s(&info->seg.eo_so_seglenbar);\n\n\t \n\tinfo->eop.seq_len = ((info->seq_num << 11) &\n\t\t\t     TX_HDR_EOP_SEQNUM) | info->pkt_len;\n\tinfo->eop.seqbar_lenbar = ((~info->seq_num << 11) &\n\t\t\t\t   TX_HDR_EOP_SEQNUMBAR) | pkt_len_bar;\n\n\tcpu_to_be16s(&info->eop.seq_len);\n\tcpu_to_be16s(&info->eop.seqbar_lenbar);\n}\n\nstatic int\nax88796c_check_free_pages(struct ax88796c_device *ax_local, u8 need_pages)\n{\n\tu8 free_pages;\n\tu16 tmp;\n\n\tlockdep_assert_held(&ax_local->spi_lock);\n\n\tfree_pages = AX_READ(&ax_local->ax_spi, P0_TFBFCR) & TX_FREEBUF_MASK;\n\tif (free_pages < need_pages) {\n\t\t \n\t\ttmp = AX_READ(&ax_local->ax_spi, P0_TFBFCR)\n\t\t\t\t& TFBFCR_SCHE_FREE_PAGE;\n\t\tAX_WRITE(&ax_local->ax_spi, tmp | TFBFCR_TX_PAGE_SET |\n\t\t\t\tTFBFCR_SET_FREE_PAGE(need_pages),\n\t\t\t\tP0_TFBFCR);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic struct sk_buff *\nax88796c_tx_fixup(struct net_device *ndev, struct sk_buff_head *q)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\tu8 spi_len = ax_local->ax_spi.comp ? 1 : 4;\n\tstruct sk_buff *skb;\n\tstruct tx_pkt_info info;\n\tstruct skb_data *entry;\n\tu16 pkt_len;\n\tu8 padlen, seq_num;\n\tu8 need_pages;\n\tint headroom;\n\tint tailroom;\n\n\tif (skb_queue_empty(q))\n\t\treturn NULL;\n\n\tskb = skb_peek(q);\n\tpkt_len = skb->len;\n\tneed_pages = (pkt_len + TX_OVERHEAD + 127) >> 7;\n\tif (ax88796c_check_free_pages(ax_local, need_pages) != 0)\n\t\treturn NULL;\n\n\theadroom = skb_headroom(skb);\n\ttailroom = skb_tailroom(skb);\n\tpadlen = round_up(pkt_len, 4) - pkt_len;\n\tseq_num = ++ax_local->seq_num & 0x1F;\n\n\tinfo.pkt_len = pkt_len;\n\n\tif (skb_cloned(skb) ||\n\t    (headroom < (TX_OVERHEAD + spi_len)) ||\n\t    (tailroom < (padlen + TX_EOP_SIZE))) {\n\t\tsize_t h = max((TX_OVERHEAD + spi_len) - headroom, 0);\n\t\tsize_t t = max((padlen + TX_EOP_SIZE) - tailroom, 0);\n\n\t\tif (pskb_expand_head(skb, h, t, GFP_KERNEL))\n\t\t\treturn NULL;\n\t}\n\n\tinfo.seq_num = seq_num;\n\tax88796c_proc_tx_hdr(&info, skb->ip_summed);\n\n\t \n\tmemcpy(skb_push(skb, TX_OVERHEAD), &info.sop, TX_OVERHEAD);\n\n\t \n\tmemcpy(skb_push(skb, spi_len), ax88796c_tx_cmd_buf, spi_len);\n\n\t \n\tskb_put(skb, padlen);\n\n\t \n\tskb_put_data(skb, &info.eop, TX_EOP_SIZE);\n\n\tskb_unlink(skb, q);\n\n\tentry = (struct skb_data *)skb->cb;\n\tmemset(entry, 0, sizeof(*entry));\n\tentry->len = pkt_len;\n\n\tif (netif_msg_pktdata(ax_local)) {\n\t\tchar pfx[IFNAMSIZ + 7];\n\n\t\tsnprintf(pfx, sizeof(pfx), \"%s:     \", ndev->name);\n\n\t\tnetdev_info(ndev, \"TX packet len %d, total len %d, seq %d\\n\",\n\t\t\t    pkt_len, skb->len, seq_num);\n\n\t\tnetdev_info(ndev, \"  SPI Header:\\n\");\n\t\tprint_hex_dump(KERN_INFO, pfx, DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       skb->data, 4, 0);\n\n\t\tnetdev_info(ndev, \"  TX SOP:\\n\");\n\t\tprint_hex_dump(KERN_INFO, pfx, DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       skb->data + 4, TX_OVERHEAD, 0);\n\n\t\tnetdev_info(ndev, \"  TX packet:\\n\");\n\t\tprint_hex_dump(KERN_INFO, pfx, DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       skb->data + 4 + TX_OVERHEAD,\n\t\t\t       skb->len - TX_EOP_SIZE - 4 - TX_OVERHEAD, 0);\n\n\t\tnetdev_info(ndev, \"  TX EOP:\\n\");\n\t\tprint_hex_dump(KERN_INFO, pfx, DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       skb->data + skb->len - 4, 4, 0);\n\t}\n\n\treturn skb;\n}\n\nstatic int ax88796c_hard_xmit(struct ax88796c_device *ax_local)\n{\n\tstruct ax88796c_pcpu_stats *stats;\n\tstruct sk_buff *tx_skb;\n\tstruct skb_data *entry;\n\tunsigned long flags;\n\n\tlockdep_assert_held(&ax_local->spi_lock);\n\n\tstats = this_cpu_ptr(ax_local->stats);\n\ttx_skb = ax88796c_tx_fixup(ax_local->ndev, &ax_local->tx_wait_q);\n\n\tif (!tx_skb) {\n\t\tthis_cpu_inc(ax_local->stats->tx_dropped);\n\t\treturn 0;\n\t}\n\tentry = (struct skb_data *)tx_skb->cb;\n\n\tAX_WRITE(&ax_local->ax_spi,\n\t\t (TSNR_TXB_START | TSNR_PKT_CNT(1)), P0_TSNR);\n\n\taxspi_write_txq(&ax_local->ax_spi, tx_skb->data, tx_skb->len);\n\n\tif (((AX_READ(&ax_local->ax_spi, P0_TSNR) & TXNR_TXB_IDLE) == 0) ||\n\t    ((ISR_TXERR & AX_READ(&ax_local->ax_spi, P0_ISR)) != 0)) {\n\t\t \n\t\tAX_WRITE(&ax_local->ax_spi, ISR_TXERR, P0_ISR);\n\n\t\tthis_cpu_inc(ax_local->stats->tx_dropped);\n\n\t\tif (net_ratelimit())\n\t\t\tnetif_err(ax_local, tx_err, ax_local->ndev,\n\t\t\t\t  \"TX FIFO error, re-initialize the TX bridge\\n\");\n\n\t\t \n\t\tAX_WRITE(&ax_local->ax_spi, TXNR_TXB_REINIT |\n\t\t\tAX_READ(&ax_local->ax_spi, P0_TSNR), P0_TSNR);\n\t\tax_local->seq_num = 0;\n\t} else {\n\t\tflags = u64_stats_update_begin_irqsave(&stats->syncp);\n\t\tu64_stats_inc(&stats->tx_packets);\n\t\tu64_stats_add(&stats->tx_bytes, entry->len);\n\t\tu64_stats_update_end_irqrestore(&stats->syncp, flags);\n\t}\n\n\tentry->state = tx_done;\n\tdev_kfree_skb(tx_skb);\n\n\treturn 1;\n}\n\nstatic netdev_tx_t\nax88796c_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\n\tskb_queue_tail(&ax_local->tx_wait_q, skb);\n\tif (skb_queue_len(&ax_local->tx_wait_q) > TX_QUEUE_HIGH_WATER)\n\t\tnetif_stop_queue(ndev);\n\n\tset_bit(EVENT_TX, &ax_local->flags);\n\tschedule_work(&ax_local->ax_work);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void\nax88796c_skb_return(struct ax88796c_device *ax_local,\n\t\t    struct sk_buff *skb, struct rx_header *rxhdr)\n{\n\tstruct net_device *ndev = ax_local->ndev;\n\tstruct ax88796c_pcpu_stats *stats;\n\tunsigned long flags;\n\tint status;\n\n\tstats = this_cpu_ptr(ax_local->stats);\n\n\tdo {\n\t\tif (!(ndev->features & NETIF_F_RXCSUM))\n\t\t\tbreak;\n\n\t\t \n\t\tif ((rxhdr->flags & RX_HDR3_L3_ERR) ||\n\t\t    (rxhdr->flags & RX_HDR3_L4_ERR))\n\t\t\tbreak;\n\n\t\t \n\t\tif ((rxhdr->flags & RX_HDR3_L4_TYPE_TCP) ||\n\t\t    (rxhdr->flags & RX_HDR3_L4_TYPE_UDP))\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t} while (0);\n\n\tflags = u64_stats_update_begin_irqsave(&stats->syncp);\n\tu64_stats_inc(&stats->rx_packets);\n\tu64_stats_add(&stats->rx_bytes, skb->len);\n\tu64_stats_update_end_irqrestore(&stats->syncp, flags);\n\n\tskb->dev = ndev;\n\tskb->protocol = eth_type_trans(skb, ax_local->ndev);\n\n\tnetif_info(ax_local, rx_status, ndev, \"< rx, len %zu, type 0x%x\\n\",\n\t\t   skb->len + sizeof(struct ethhdr), skb->protocol);\n\n\tstatus = netif_rx(skb);\n\tif (status != NET_RX_SUCCESS && net_ratelimit())\n\t\tnetif_info(ax_local, rx_err, ndev,\n\t\t\t   \"netif_rx status %d\\n\", status);\n}\n\nstatic void\nax88796c_rx_fixup(struct ax88796c_device *ax_local, struct sk_buff *rx_skb)\n{\n\tstruct rx_header *rxhdr = (struct rx_header *)rx_skb->data;\n\tstruct net_device *ndev = ax_local->ndev;\n\tu16 len;\n\n\tbe16_to_cpus(&rxhdr->flags_len);\n\tbe16_to_cpus(&rxhdr->seq_lenbar);\n\tbe16_to_cpus(&rxhdr->flags);\n\n\tif ((rxhdr->flags_len & RX_HDR1_PKT_LEN) !=\n\t\t\t (~rxhdr->seq_lenbar & 0x7FF)) {\n\t\tnetif_err(ax_local, rx_err, ndev, \"Header error\\n\");\n\n\t\tthis_cpu_inc(ax_local->stats->rx_frame_errors);\n\t\tkfree_skb(rx_skb);\n\t\treturn;\n\t}\n\n\tif ((rxhdr->flags_len & RX_HDR1_MII_ERR) ||\n\t    (rxhdr->flags_len & RX_HDR1_CRC_ERR)) {\n\t\tnetif_err(ax_local, rx_err, ndev, \"CRC or MII error\\n\");\n\n\t\tthis_cpu_inc(ax_local->stats->rx_crc_errors);\n\t\tkfree_skb(rx_skb);\n\t\treturn;\n\t}\n\n\tlen = rxhdr->flags_len & RX_HDR1_PKT_LEN;\n\tif (netif_msg_pktdata(ax_local)) {\n\t\tchar pfx[IFNAMSIZ + 7];\n\n\t\tsnprintf(pfx, sizeof(pfx), \"%s:     \", ndev->name);\n\t\tnetdev_info(ndev, \"RX data, total len %d, packet len %d\\n\",\n\t\t\t    rx_skb->len, len);\n\n\t\tnetdev_info(ndev, \"  Dump RX packet header:\");\n\t\tprint_hex_dump(KERN_INFO, pfx, DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       rx_skb->data, sizeof(*rxhdr), 0);\n\n\t\tnetdev_info(ndev, \"  Dump RX packet:\");\n\t\tprint_hex_dump(KERN_INFO, pfx, DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       rx_skb->data + sizeof(*rxhdr), len, 0);\n\t}\n\n\tskb_pull(rx_skb, sizeof(*rxhdr));\n\tpskb_trim(rx_skb, len);\n\n\tax88796c_skb_return(ax_local, rx_skb, rxhdr);\n}\n\nstatic int ax88796c_receive(struct net_device *ndev)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\tstruct skb_data *entry;\n\tu16 w_count, pkt_len;\n\tstruct sk_buff *skb;\n\tu8 pkt_cnt;\n\n\tlockdep_assert_held(&ax_local->spi_lock);\n\n\t \n\tAX_WRITE(&ax_local->ax_spi, AX_READ(&ax_local->ax_spi, P0_RTWCR)\n\t\t  | RTWCR_RX_LATCH, P0_RTWCR);\n\n\tpkt_cnt = AX_READ(&ax_local->ax_spi, P0_RXBCR2) & RXBCR2_PKT_MASK;\n\tif (!pkt_cnt)\n\t\treturn 0;\n\n\tpkt_len = AX_READ(&ax_local->ax_spi, P0_RCPHR) & 0x7FF;\n\n\tw_count = round_up(pkt_len + 6, 4) >> 1;\n\n\tskb = netdev_alloc_skb(ndev, w_count * 2);\n\tif (!skb) {\n\t\tAX_WRITE(&ax_local->ax_spi, RXBCR1_RXB_DISCARD, P0_RXBCR1);\n\t\tthis_cpu_inc(ax_local->stats->rx_dropped);\n\t\treturn 0;\n\t}\n\tentry = (struct skb_data *)skb->cb;\n\n\tAX_WRITE(&ax_local->ax_spi, RXBCR1_RXB_START | w_count, P0_RXBCR1);\n\n\taxspi_read_rxq(&ax_local->ax_spi,\n\t\t       skb_put(skb, w_count * 2), skb->len);\n\n\t \n\tif ((AX_READ(&ax_local->ax_spi, P0_RXBCR2) & RXBCR2_RXB_IDLE) == 0) {\n\t\tif (net_ratelimit())\n\t\t\tnetif_err(ax_local, rx_err, ndev,\n\t\t\t\t  \"Rx Bridge is not idle\\n\");\n\t\tAX_WRITE(&ax_local->ax_spi, RXBCR2_RXB_REINIT, P0_RXBCR2);\n\n\t\tentry->state = rx_err;\n\t} else {\n\t\tentry->state = rx_done;\n\t}\n\n\tAX_WRITE(&ax_local->ax_spi, ISR_RXPKT, P0_ISR);\n\n\tax88796c_rx_fixup(ax_local, skb);\n\n\treturn 1;\n}\n\nstatic int ax88796c_process_isr(struct ax88796c_device *ax_local)\n{\n\tstruct net_device *ndev = ax_local->ndev;\n\tint todo = 0;\n\tu16 isr;\n\n\tlockdep_assert_held(&ax_local->spi_lock);\n\n\tisr = AX_READ(&ax_local->ax_spi, P0_ISR);\n\tAX_WRITE(&ax_local->ax_spi, isr, P0_ISR);\n\n\tnetif_dbg(ax_local, intr, ndev, \"  ISR 0x%04x\\n\", isr);\n\n\tif (isr & ISR_TXERR) {\n\t\tnetif_dbg(ax_local, intr, ndev, \"  TXERR interrupt\\n\");\n\t\tAX_WRITE(&ax_local->ax_spi, TXNR_TXB_REINIT, P0_TSNR);\n\t\tax_local->seq_num = 0x1f;\n\t}\n\n\tif (isr & ISR_TXPAGES) {\n\t\tnetif_dbg(ax_local, intr, ndev, \"  TXPAGES interrupt\\n\");\n\t\tset_bit(EVENT_TX, &ax_local->flags);\n\t}\n\n\tif (isr & ISR_LINK) {\n\t\tnetif_dbg(ax_local, intr, ndev, \"  Link change interrupt\\n\");\n\t\tphy_mac_interrupt(ax_local->ndev->phydev);\n\t}\n\n\tif (isr & ISR_RXPKT) {\n\t\tnetif_dbg(ax_local, intr, ndev, \"  RX interrupt\\n\");\n\t\ttodo = ax88796c_receive(ax_local->ndev);\n\t}\n\n\treturn todo;\n}\n\nstatic irqreturn_t ax88796c_interrupt(int irq, void *dev_instance)\n{\n\tstruct ax88796c_device *ax_local;\n\tstruct net_device *ndev;\n\n\tndev = dev_instance;\n\tif (!ndev) {\n\t\tpr_err(\"irq %d for unknown device.\\n\", irq);\n\t\treturn IRQ_RETVAL(0);\n\t}\n\tax_local = to_ax88796c_device(ndev);\n\n\tdisable_irq_nosync(irq);\n\n\tnetif_dbg(ax_local, intr, ndev, \"Interrupt occurred\\n\");\n\n\tset_bit(EVENT_INTR, &ax_local->flags);\n\tschedule_work(&ax_local->ax_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ax88796c_work(struct work_struct *work)\n{\n\tstruct ax88796c_device *ax_local =\n\t\t\tcontainer_of(work, struct ax88796c_device, ax_work);\n\n\tmutex_lock(&ax_local->spi_lock);\n\n\tif (test_bit(EVENT_SET_MULTI, &ax_local->flags)) {\n\t\tax88796c_set_hw_multicast(ax_local->ndev);\n\t\tclear_bit(EVENT_SET_MULTI, &ax_local->flags);\n\t}\n\n\tif (test_bit(EVENT_INTR, &ax_local->flags)) {\n\t\tAX_WRITE(&ax_local->ax_spi, IMR_MASKALL, P0_IMR);\n\n\t\twhile (ax88796c_process_isr(ax_local))\n\t\t\t ;\n\n\t\tclear_bit(EVENT_INTR, &ax_local->flags);\n\n\t\tAX_WRITE(&ax_local->ax_spi, IMR_DEFAULT, P0_IMR);\n\n\t\tenable_irq(ax_local->ndev->irq);\n\t}\n\n\tif (test_bit(EVENT_TX, &ax_local->flags)) {\n\t\twhile (skb_queue_len(&ax_local->tx_wait_q)) {\n\t\t\tif (!ax88796c_hard_xmit(ax_local))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tclear_bit(EVENT_TX, &ax_local->flags);\n\n\t\tif (netif_queue_stopped(ax_local->ndev) &&\n\t\t    (skb_queue_len(&ax_local->tx_wait_q) < TX_QUEUE_LOW_WATER))\n\t\t\tnetif_wake_queue(ax_local->ndev);\n\t}\n\n\tmutex_unlock(&ax_local->spi_lock);\n}\n\nstatic void ax88796c_get_stats64(struct net_device *ndev,\n\t\t\t\t struct rtnl_link_stats64 *stats)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\tu32 rx_frame_errors = 0, rx_crc_errors = 0;\n\tu32 rx_dropped = 0, tx_dropped = 0;\n\tunsigned int start;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct ax88796c_pcpu_stats *s;\n\t\tu64 rx_packets, rx_bytes;\n\t\tu64 tx_packets, tx_bytes;\n\n\t\ts = per_cpu_ptr(ax_local->stats, cpu);\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&s->syncp);\n\t\t\trx_packets = u64_stats_read(&s->rx_packets);\n\t\t\trx_bytes   = u64_stats_read(&s->rx_bytes);\n\t\t\ttx_packets = u64_stats_read(&s->tx_packets);\n\t\t\ttx_bytes   = u64_stats_read(&s->tx_bytes);\n\t\t} while (u64_stats_fetch_retry(&s->syncp, start));\n\n\t\tstats->rx_packets += rx_packets;\n\t\tstats->rx_bytes   += rx_bytes;\n\t\tstats->tx_packets += tx_packets;\n\t\tstats->tx_bytes   += tx_bytes;\n\n\t\trx_dropped      += s->rx_dropped;\n\t\ttx_dropped      += s->tx_dropped;\n\t\trx_frame_errors += s->rx_frame_errors;\n\t\trx_crc_errors   += s->rx_crc_errors;\n\t}\n\n\tstats->rx_dropped = rx_dropped;\n\tstats->tx_dropped = tx_dropped;\n\tstats->rx_frame_errors = rx_frame_errors;\n\tstats->rx_crc_errors = rx_crc_errors;\n}\n\nstatic void ax88796c_set_mac(struct  ax88796c_device *ax_local)\n{\n\tu16 maccr;\n\n\tmaccr = (ax_local->link) ? MACCR_RXEN : 0;\n\n\tswitch (ax_local->speed) {\n\tcase SPEED_100:\n\t\tmaccr |= MACCR_SPEED_100;\n\t\tbreak;\n\tcase SPEED_10:\n\tcase SPEED_UNKNOWN:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tswitch (ax_local->duplex) {\n\tcase DUPLEX_FULL:\n\t\tmaccr |= MACCR_SPEED_100;\n\t\tbreak;\n\tcase DUPLEX_HALF:\n\tcase DUPLEX_UNKNOWN:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (ax_local->flowctrl & AX_FC_ANEG &&\n\t    ax_local->phydev->autoneg) {\n\t\tmaccr |= ax_local->pause ? MACCR_RXFC_ENABLE : 0;\n\t\tmaccr |= !ax_local->pause != !ax_local->asym_pause ?\n\t\t\tMACCR_TXFC_ENABLE : 0;\n\t} else {\n\t\tmaccr |= (ax_local->flowctrl & AX_FC_RX) ? MACCR_RXFC_ENABLE : 0;\n\t\tmaccr |= (ax_local->flowctrl & AX_FC_TX) ? MACCR_TXFC_ENABLE : 0;\n\t}\n\n\tmutex_lock(&ax_local->spi_lock);\n\n\tmaccr |= AX_READ(&ax_local->ax_spi, P0_MACCR) &\n\t\t~(MACCR_DUPLEX_FULL | MACCR_SPEED_100 |\n\t\t  MACCR_TXFC_ENABLE | MACCR_RXFC_ENABLE);\n\tAX_WRITE(&ax_local->ax_spi, maccr, P0_MACCR);\n\n\tmutex_unlock(&ax_local->spi_lock);\n}\n\nstatic void ax88796c_handle_link_change(struct net_device *ndev)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\tstruct phy_device *phydev = ndev->phydev;\n\tbool update = false;\n\n\tif (phydev->link && (ax_local->speed != phydev->speed ||\n\t\t\t     ax_local->duplex != phydev->duplex ||\n\t\t\t     ax_local->pause != phydev->pause ||\n\t\t\t     ax_local->asym_pause != phydev->asym_pause)) {\n\t\tax_local->speed = phydev->speed;\n\t\tax_local->duplex = phydev->duplex;\n\t\tax_local->pause = phydev->pause;\n\t\tax_local->asym_pause = phydev->asym_pause;\n\t\tupdate = true;\n\t}\n\n\tif (phydev->link != ax_local->link) {\n\t\tif (!phydev->link) {\n\t\t\tax_local->speed = SPEED_UNKNOWN;\n\t\t\tax_local->duplex = DUPLEX_UNKNOWN;\n\t\t}\n\n\t\tax_local->link = phydev->link;\n\t\tupdate = true;\n\t}\n\n\tif (update)\n\t\tax88796c_set_mac(ax_local);\n\n\tif (net_ratelimit())\n\t\tphy_print_status(ndev->phydev);\n}\n\nstatic void ax88796c_set_csums(struct ax88796c_device *ax_local)\n{\n\tstruct net_device *ndev = ax_local->ndev;\n\n\tlockdep_assert_held(&ax_local->spi_lock);\n\n\tif (ndev->features & NETIF_F_RXCSUM) {\n\t\tAX_WRITE(&ax_local->ax_spi, COERCR0_DEFAULT, P4_COERCR0);\n\t\tAX_WRITE(&ax_local->ax_spi, COERCR1_DEFAULT, P4_COERCR1);\n\t} else {\n\t\tAX_WRITE(&ax_local->ax_spi, 0, P4_COERCR0);\n\t\tAX_WRITE(&ax_local->ax_spi, 0, P4_COERCR1);\n\t}\n\n\tif (ndev->features & NETIF_F_HW_CSUM) {\n\t\tAX_WRITE(&ax_local->ax_spi, COETCR0_DEFAULT, P4_COETCR0);\n\t\tAX_WRITE(&ax_local->ax_spi, COETCR1_TXPPPE, P4_COETCR1);\n\t} else {\n\t\tAX_WRITE(&ax_local->ax_spi, 0, P4_COETCR0);\n\t\tAX_WRITE(&ax_local->ax_spi, 0, P4_COETCR1);\n\t}\n}\n\nstatic int\nax88796c_open(struct net_device *ndev)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\tunsigned long irq_flag = 0;\n\tint fc = AX_FC_NONE;\n\tint ret;\n\tu16 t;\n\n\tret = request_irq(ndev->irq, ax88796c_interrupt,\n\t\t\t  irq_flag, ndev->name, ndev);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"unable to get IRQ %d (errno=%d).\\n\",\n\t\t\t   ndev->irq, ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&ax_local->spi_lock);\n\n\tret = ax88796c_soft_reset(ax_local);\n\tif (ret < 0) {\n\t\tfree_irq(ndev->irq, ndev);\n\t\tmutex_unlock(&ax_local->spi_lock);\n\t\treturn ret;\n\t}\n\tax_local->seq_num = 0x1f;\n\n\tax88796c_set_mac_addr(ndev);\n\tax88796c_set_csums(ax_local);\n\n\t \n\tt = AX_READ(&ax_local->ax_spi, P1_RXBSPCR);\n\tt &= ~RXBSPCR_STUF_ENABLE;\n\tAX_WRITE(&ax_local->ax_spi, t, P1_RXBSPCR);\n\n\t \n\tAX_WRITE(&ax_local->ax_spi, RPPER_RXEN, P1_RPPER);\n\n\tt = AX_READ(&ax_local->ax_spi, P0_FER);\n\tt |= FER_RXEN | FER_TXEN | FER_BSWAP | FER_IRQ_PULL;\n\tAX_WRITE(&ax_local->ax_spi, t, P0_FER);\n\n\t \n\tAX_WRITE(&ax_local->ax_spi,\n\t\t (LCR_LED0_EN | LCR_LED0_DUPLEX | LCR_LED1_EN |\n\t\t LCR_LED1_100MODE), P2_LCR0);\n\tAX_WRITE(&ax_local->ax_spi,\n\t\t (AX_READ(&ax_local->ax_spi, P2_LCR1) & LCR_LED2_MASK) |\n\t\t LCR_LED2_EN | LCR_LED2_LINK, P2_LCR1);\n\n\t \n\tAX_WRITE(&ax_local->ax_spi, PCR_PHYID(AX88796C_PHY_ID), P2_PCR);\n\n\t \n\tAX_WRITE(&ax_local->ax_spi, IMR_DEFAULT, P0_IMR);\n\n\tmutex_unlock(&ax_local->spi_lock);\n\n\t \n\tphy_support_asym_pause(ax_local->phydev);\n\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t      ax_local->phydev->advertising) ||\n\t    linkmode_test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\t\t\t      ax_local->phydev->advertising))\n\t\tfc |= AX_FC_ANEG;\n\n\tfc |= linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t\tax_local->phydev->advertising) ? AX_FC_RX : 0;\n\tfc |= (linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t\t ax_local->phydev->advertising) !=\n\t       linkmode_test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\t\t\t\t ax_local->phydev->advertising)) ? AX_FC_TX : 0;\n\tax_local->flowctrl = fc;\n\n\tphy_start(ax_local->ndev->phydev);\n\n\tnetif_start_queue(ndev);\n\n\tspi_message_init(&ax_local->ax_spi.rx_msg);\n\n\treturn 0;\n}\n\nstatic int\nax88796c_close(struct net_device *ndev)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\n\tphy_stop(ndev->phydev);\n\n\t \n\tmutex_lock(&ax_local->spi_lock);\n\n\tnetif_stop_queue(ndev);\n\n\t \n\tnetif_dbg(ax_local, ifdown, ndev, \"clearing bits\\n\");\n\tclear_bit(EVENT_SET_MULTI, &ax_local->flags);\n\tclear_bit(EVENT_INTR, &ax_local->flags);\n\tclear_bit(EVENT_TX, &ax_local->flags);\n\n\t \n\tAX_WRITE(&ax_local->ax_spi, IMR_MASKALL, P0_IMR);\n\t__skb_queue_purge(&ax_local->tx_wait_q);\n\tax88796c_soft_reset(ax_local);\n\n\tmutex_unlock(&ax_local->spi_lock);\n\n\tcancel_work_sync(&ax_local->ax_work);\n\n\tfree_irq(ndev->irq, ndev);\n\n\treturn 0;\n}\n\nstatic int\nax88796c_set_features(struct net_device *ndev, netdev_features_t features)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\tnetdev_features_t changed = features ^ ndev->features;\n\n\tif (!(changed & (NETIF_F_RXCSUM | NETIF_F_HW_CSUM)))\n\t\treturn 0;\n\n\tndev->features = features;\n\n\tif (changed & (NETIF_F_RXCSUM | NETIF_F_HW_CSUM))\n\t\tax88796c_set_csums(ax_local);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ax88796c_netdev_ops = {\n\t.ndo_open\t\t= ax88796c_open,\n\t.ndo_stop\t\t= ax88796c_close,\n\t.ndo_start_xmit\t\t= ax88796c_start_xmit,\n\t.ndo_get_stats64\t= ax88796c_get_stats64,\n\t.ndo_eth_ioctl\t\t= ax88796c_ioctl,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_set_features\t= ax88796c_set_features,\n};\n\nstatic int ax88796c_hard_reset(struct ax88796c_device *ax_local)\n{\n\tstruct device *dev = (struct device *)&ax_local->spi->dev;\n\tstruct gpio_desc *reset_gpio;\n\n\t \n\treset_gpio = gpiod_get(dev, \"reset\", 0);\n\tif (IS_ERR(reset_gpio)) {\n\t\tdev_err(dev, \"Could not get 'reset' GPIO: %ld\", PTR_ERR(reset_gpio));\n\t\treturn PTR_ERR(reset_gpio);\n\t}\n\n\t \n\tgpiod_direction_output(reset_gpio, 1);\n\tmsleep(100);\n\tgpiod_direction_output(reset_gpio, 0);\n\tgpiod_put(reset_gpio);\n\tmsleep(20);\n\n\treturn 0;\n}\n\nstatic int ax88796c_probe(struct spi_device *spi)\n{\n\tchar phy_id[MII_BUS_ID_SIZE + 3];\n\tstruct ax88796c_device *ax_local;\n\tstruct net_device *ndev;\n\tu16 temp;\n\tint ret;\n\n\tndev = devm_alloc_etherdev(&spi->dev, sizeof(*ax_local));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(ndev, &spi->dev);\n\n\tax_local = to_ax88796c_device(ndev);\n\n\tdev_set_drvdata(&spi->dev, ax_local);\n\tax_local->spi = spi;\n\tax_local->ax_spi.spi = spi;\n\n\tax_local->stats =\n\t\tdevm_netdev_alloc_pcpu_stats(&spi->dev,\n\t\t\t\t\t     struct ax88796c_pcpu_stats);\n\tif (!ax_local->stats)\n\t\treturn -ENOMEM;\n\n\tax_local->ndev = ndev;\n\tax_local->priv_flags |= comp ? AX_CAP_COMP : 0;\n\tax_local->msg_enable = msg_enable;\n\tmutex_init(&ax_local->spi_lock);\n\n\tax_local->mdiobus = devm_mdiobus_alloc(&spi->dev);\n\tif (!ax_local->mdiobus)\n\t\treturn -ENOMEM;\n\n\tax_local->mdiobus->priv = ax_local;\n\tax_local->mdiobus->read = ax88796c_mdio_read;\n\tax_local->mdiobus->write = ax88796c_mdio_write;\n\tax_local->mdiobus->name = \"ax88976c-mdiobus\";\n\tax_local->mdiobus->phy_mask = (u32)~BIT(AX88796C_PHY_ID);\n\tax_local->mdiobus->parent = &spi->dev;\n\n\tsnprintf(ax_local->mdiobus->id, MII_BUS_ID_SIZE,\n\t\t \"ax88796c-%s.%u\", dev_name(&spi->dev), spi_get_chipselect(spi, 0));\n\n\tret = devm_mdiobus_register(&spi->dev, ax_local->mdiobus);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"Could not register MDIO bus\\n\");\n\t\treturn ret;\n\t}\n\n\tif (netif_msg_probe(ax_local)) {\n\t\tdev_info(&spi->dev, \"AX88796C-SPI Configuration:\\n\");\n\t\tdev_info(&spi->dev, \"    Compression : %s\\n\",\n\t\t\t ax_local->priv_flags & AX_CAP_COMP ? \"ON\" : \"OFF\");\n\t}\n\n\tndev->irq = spi->irq;\n\tndev->netdev_ops = &ax88796c_netdev_ops;\n\tndev->ethtool_ops = &ax88796c_ethtool_ops;\n\tndev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_RXCSUM;\n\tndev->features |= NETIF_F_HW_CSUM | NETIF_F_RXCSUM;\n\tndev->needed_headroom = TX_OVERHEAD;\n\tndev->needed_tailroom = TX_EOP_SIZE;\n\n\tmutex_lock(&ax_local->spi_lock);\n\n\t \n\tax88796c_hard_reset(ax_local);\n\n\t \n\tret = ax88796c_soft_reset(ax_local);\n\tif (ret < 0) {\n\t\tret = -ENODEV;\n\t\tmutex_unlock(&ax_local->spi_lock);\n\t\tgoto err;\n\t}\n\t \n\ttemp = AX_READ(&ax_local->ax_spi, P2_CRIR);\n\tif ((temp & 0xF) != 0x0) {\n\t\tdev_err(&spi->dev, \"spi read failed: %d\\n\", temp);\n\t\tret = -ENODEV;\n\t\tmutex_unlock(&ax_local->spi_lock);\n\t\tgoto err;\n\t}\n\n\t \n\tax88796c_reload_eeprom(ax_local);\n\n\tax88796c_load_mac_addr(ndev);\n\n\tif (netif_msg_probe(ax_local))\n\t\tdev_info(&spi->dev,\n\t\t\t \"irq %d, MAC addr %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n\t\t\t ndev->irq,\n\t\t\t ndev->dev_addr[0], ndev->dev_addr[1],\n\t\t\t ndev->dev_addr[2], ndev->dev_addr[3],\n\t\t\t ndev->dev_addr[4], ndev->dev_addr[5]);\n\n\t \n\tAX_WRITE(&ax_local->ax_spi, (AX_READ(&ax_local->ax_spi, P0_PSCR)\n\t\t\t\t     & PSCR_PS_MASK) | PSCR_PS_D0, P0_PSCR);\n\n\tmutex_unlock(&ax_local->spi_lock);\n\n\tINIT_WORK(&ax_local->ax_work, ax88796c_work);\n\n\tskb_queue_head_init(&ax_local->tx_wait_q);\n\n\tsnprintf(phy_id, MII_BUS_ID_SIZE + 3, PHY_ID_FMT,\n\t\t ax_local->mdiobus->id, AX88796C_PHY_ID);\n\tax_local->phydev = phy_connect(ax_local->ndev, phy_id,\n\t\t\t\t       ax88796c_handle_link_change,\n\t\t\t\t       PHY_INTERFACE_MODE_MII);\n\tif (IS_ERR(ax_local->phydev)) {\n\t\tret = PTR_ERR(ax_local->phydev);\n\t\tgoto err;\n\t}\n\tax_local->phydev->irq = PHY_POLL;\n\n\tret = devm_register_netdev(&spi->dev, ndev);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to register a network device\\n\");\n\t\tgoto err_phy_dis;\n\t}\n\n\tnetif_info(ax_local, probe, ndev, \"%s %s registered\\n\",\n\t\t   dev_driver_string(&spi->dev),\n\t\t   dev_name(&spi->dev));\n\tphy_attached_info(ax_local->phydev);\n\n\treturn 0;\n\nerr_phy_dis:\n\tphy_disconnect(ax_local->phydev);\nerr:\n\treturn ret;\n}\n\nstatic void ax88796c_remove(struct spi_device *spi)\n{\n\tstruct ax88796c_device *ax_local = dev_get_drvdata(&spi->dev);\n\tstruct net_device *ndev = ax_local->ndev;\n\n\tphy_disconnect(ndev->phydev);\n\n\tnetif_info(ax_local, probe, ndev, \"removing network device %s %s\\n\",\n\t\t   dev_driver_string(&spi->dev),\n\t\t   dev_name(&spi->dev));\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ax88796c_dt_ids[] = {\n\t{ .compatible = \"asix,ax88796c\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ax88796c_dt_ids);\n#endif\n\nstatic const struct spi_device_id asix_id[] = {\n\t{ \"ax88796c\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, asix_id);\n\nstatic struct spi_driver ax88796c_spi_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = of_match_ptr(ax88796c_dt_ids),\n\t},\n\t.probe = ax88796c_probe,\n\t.remove = ax88796c_remove,\n\t.id_table = asix_id,\n};\n\nstatic __init int ax88796c_spi_init(void)\n{\n\tint ret;\n\n\tbitmap_zero(ax88796c_no_regs_mask, AX88796C_REGDUMP_LEN);\n\tret = bitmap_parse(no_regs_list, 35,\n\t\t\t   ax88796c_no_regs_mask, AX88796C_REGDUMP_LEN);\n\tif (ret) {\n\t\tbitmap_fill(ax88796c_no_regs_mask, AX88796C_REGDUMP_LEN);\n\t\tpr_err(\"Invalid bitmap description, masking all registers\\n\");\n\t}\n\n\treturn spi_register_driver(&ax88796c_spi_driver);\n}\n\nstatic __exit void ax88796c_spi_exit(void)\n{\n\tspi_unregister_driver(&ax88796c_spi_driver);\n}\n\nmodule_init(ax88796c_spi_init);\nmodule_exit(ax88796c_spi_exit);\n\nMODULE_AUTHOR(\"\u0141ukasz Stelmach <l.stelmach@samsung.com>\");\nMODULE_DESCRIPTION(\"ASIX AX88796C SPI Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}