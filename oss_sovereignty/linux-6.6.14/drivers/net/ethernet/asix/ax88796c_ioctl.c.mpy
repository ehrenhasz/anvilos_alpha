{
  "module_name": "ax88796c_ioctl.c",
  "hash_id": "164af235c371b060a8ebb92822743295d43d51327f823d0b90ca381bfe797a6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/asix/ax88796c_ioctl.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"ax88796c: \" fmt\n\n#include <linux/bitmap.h>\n#include <linux/iopoll.h>\n#include <linux/phy.h>\n#include <linux/netdevice.h>\n\n#include \"ax88796c_main.h\"\n#include \"ax88796c_ioctl.h\"\n\nstatic const char ax88796c_priv_flag_names[][ETH_GSTRING_LEN] = {\n\t\"SPICompression\",\n};\n\nstatic void\nax88796c_get_drvinfo(struct net_device *ndev, struct ethtool_drvinfo *info)\n{\n\t \n\tstrncpy(info->driver, DRV_NAME, sizeof(info->driver));\n}\n\nstatic u32 ax88796c_get_msglevel(struct net_device *ndev)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\n\treturn ax_local->msg_enable;\n}\n\nstatic void ax88796c_set_msglevel(struct net_device *ndev, u32 level)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\n\tax_local->msg_enable = level;\n}\n\nstatic void\nax88796c_get_pauseparam(struct net_device *ndev, struct ethtool_pauseparam *pause)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\n\tpause->tx_pause = !!(ax_local->flowctrl & AX_FC_TX);\n\tpause->rx_pause = !!(ax_local->flowctrl & AX_FC_RX);\n\tpause->autoneg = (ax_local->flowctrl & AX_FC_ANEG) ?\n\t\tAUTONEG_ENABLE :\n\t\tAUTONEG_DISABLE;\n}\n\nstatic int\nax88796c_set_pauseparam(struct net_device *ndev, struct ethtool_pauseparam *pause)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\tint fc;\n\n\t \n\tfc = pause->tx_pause ? AX_FC_TX : 0;\n\tfc |= pause->rx_pause ? AX_FC_RX : 0;\n\tfc |= pause->autoneg ? AX_FC_ANEG : 0;\n\n\tax_local->flowctrl = fc;\n\n\tif (pause->autoneg) {\n\t\tphy_set_asym_pause(ax_local->phydev, pause->tx_pause,\n\t\t\t\t   pause->rx_pause);\n\t} else {\n\t\tint maccr = 0;\n\n\t\tphy_set_asym_pause(ax_local->phydev, 0, 0);\n\t\tmaccr |= (ax_local->flowctrl & AX_FC_RX) ? MACCR_RXFC_ENABLE : 0;\n\t\tmaccr |= (ax_local->flowctrl & AX_FC_TX) ? MACCR_TXFC_ENABLE : 0;\n\n\t\tmutex_lock(&ax_local->spi_lock);\n\n\t\tmaccr |= AX_READ(&ax_local->ax_spi, P0_MACCR) &\n\t\t\t~(MACCR_TXFC_ENABLE | MACCR_RXFC_ENABLE);\n\t\tAX_WRITE(&ax_local->ax_spi, maccr, P0_MACCR);\n\n\t\tmutex_unlock(&ax_local->spi_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int ax88796c_get_regs_len(struct net_device *ndev)\n{\n\treturn AX88796C_REGDUMP_LEN + AX88796C_PHY_REGDUMP_LEN;\n}\n\nstatic void\nax88796c_get_regs(struct net_device *ndev, struct ethtool_regs *regs, void *_p)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\tint offset, i;\n\tu16 *p = _p;\n\n\tmemset(p, 0, ax88796c_get_regs_len(ndev));\n\n\tmutex_lock(&ax_local->spi_lock);\n\n\tfor (offset = 0; offset < AX88796C_REGDUMP_LEN; offset += 2) {\n\t\tif (!test_bit(offset / 2, ax88796c_no_regs_mask))\n\t\t\t*p = AX_READ(&ax_local->ax_spi, offset);\n\t\tp++;\n\t}\n\n\tmutex_unlock(&ax_local->spi_lock);\n\n\tfor (i = 0; i < AX88796C_PHY_REGDUMP_LEN / 2; i++) {\n\t\t*p = phy_read(ax_local->phydev, i);\n\t\tp++;\n\t}\n}\n\nstatic void\nax88796c_get_strings(struct net_device *ndev, u32 stringset, u8 *data)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tmemcpy(data, ax88796c_priv_flag_names,\n\t\t       sizeof(ax88796c_priv_flag_names));\n\t\tbreak;\n\t}\n}\n\nstatic int\nax88796c_get_sset_count(struct net_device *ndev, int stringset)\n{\n\tint ret = 0;\n\n\tswitch (stringset) {\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tret = ARRAY_SIZE(ax88796c_priv_flag_names);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int ax88796c_set_priv_flags(struct net_device *ndev, u32 flags)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\n\tif (flags & ~AX_PRIV_FLAGS_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((ax_local->priv_flags ^ flags) & AX_CAP_COMP)\n\t\tif (netif_running(ndev))\n\t\t\treturn -EBUSY;\n\n\tax_local->priv_flags = flags;\n\n\treturn 0;\n}\n\nstatic u32 ax88796c_get_priv_flags(struct net_device *ndev)\n{\n\tstruct ax88796c_device *ax_local = to_ax88796c_device(ndev);\n\n\treturn ax_local->priv_flags;\n}\n\nint ax88796c_mdio_read(struct mii_bus *mdiobus, int phy_id, int loc)\n{\n\tstruct ax88796c_device *ax_local = mdiobus->priv;\n\tint ret;\n\n\tmutex_lock(&ax_local->spi_lock);\n\tAX_WRITE(&ax_local->ax_spi, MDIOCR_RADDR(loc)\n\t\t\t| MDIOCR_FADDR(phy_id) | MDIOCR_READ, P2_MDIOCR);\n\n\tret = read_poll_timeout(AX_READ, ret,\n\t\t\t\t(ret != 0),\n\t\t\t\t0, jiffies_to_usecs(HZ / 100), false,\n\t\t\t\t&ax_local->ax_spi, P2_MDIOCR);\n\tif (!ret)\n\t\tret = AX_READ(&ax_local->ax_spi, P2_MDIODR);\n\n\tmutex_unlock(&ax_local->spi_lock);\n\n\treturn ret;\n}\n\nint\nax88796c_mdio_write(struct mii_bus *mdiobus, int phy_id, int loc, u16 val)\n{\n\tstruct ax88796c_device *ax_local = mdiobus->priv;\n\tint ret;\n\n\tmutex_lock(&ax_local->spi_lock);\n\tAX_WRITE(&ax_local->ax_spi, val, P2_MDIODR);\n\n\tAX_WRITE(&ax_local->ax_spi,\n\t\t MDIOCR_RADDR(loc) | MDIOCR_FADDR(phy_id)\n\t\t | MDIOCR_WRITE, P2_MDIOCR);\n\n\tret = read_poll_timeout(AX_READ, ret,\n\t\t\t\t((ret & MDIOCR_VALID) != 0), 0,\n\t\t\t\tjiffies_to_usecs(HZ / 100), false,\n\t\t\t\t&ax_local->ax_spi, P2_MDIOCR);\n\tmutex_unlock(&ax_local->spi_lock);\n\n\treturn ret;\n}\n\nconst struct ethtool_ops ax88796c_ethtool_ops = {\n\t.get_drvinfo\t\t= ax88796c_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_msglevel\t\t= ax88796c_get_msglevel,\n\t.set_msglevel\t\t= ax88796c_set_msglevel,\n\t.get_link_ksettings\t= phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= phy_ethtool_set_link_ksettings,\n\t.nway_reset\t\t= phy_ethtool_nway_reset,\n\t.get_pauseparam\t\t= ax88796c_get_pauseparam,\n\t.set_pauseparam\t\t= ax88796c_set_pauseparam,\n\t.get_regs_len\t\t= ax88796c_get_regs_len,\n\t.get_regs\t\t= ax88796c_get_regs,\n\t.get_strings\t\t= ax88796c_get_strings,\n\t.get_sset_count\t\t= ax88796c_get_sset_count,\n\t.get_priv_flags\t\t= ax88796c_get_priv_flags,\n\t.set_priv_flags\t\t= ax88796c_set_priv_flags,\n};\n\nint ax88796c_ioctl(struct net_device *ndev, struct ifreq *ifr, int cmd)\n{\n\tint ret;\n\n\tret = phy_mii_ioctl(ndev->phydev, ifr, cmd);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}