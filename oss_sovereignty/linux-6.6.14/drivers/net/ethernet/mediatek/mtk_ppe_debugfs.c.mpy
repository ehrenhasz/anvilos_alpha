{
  "module_name": "mtk_ppe_debugfs.c",
  "hash_id": "d54cfa7e0190b80782dc632ea8ef8375f405f5188a820f30df9df40478bf20a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mediatek/mtk_ppe_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n#include \"mtk_eth_soc.h\"\n\nstruct mtk_flow_addr_info\n{\n\tvoid *src, *dest;\n\tu16 *src_port, *dest_port;\n\tbool ipv6;\n};\n\nstatic const char *mtk_foe_entry_state_str(int state)\n{\n\tstatic const char * const state_str[] = {\n\t\t[MTK_FOE_STATE_INVALID] = \"INV\",\n\t\t[MTK_FOE_STATE_UNBIND] = \"UNB\",\n\t\t[MTK_FOE_STATE_BIND] = \"BND\",\n\t\t[MTK_FOE_STATE_FIN] = \"FIN\",\n\t};\n\n\tif (state >= ARRAY_SIZE(state_str) || !state_str[state])\n\t\treturn \"UNK\";\n\n\treturn state_str[state];\n}\n\nstatic const char *mtk_foe_pkt_type_str(int type)\n{\n\tstatic const char * const type_str[] = {\n\t\t[MTK_PPE_PKT_TYPE_IPV4_HNAPT] = \"IPv4 5T\",\n\t\t[MTK_PPE_PKT_TYPE_IPV4_ROUTE] = \"IPv4 3T\",\n\t\t[MTK_PPE_PKT_TYPE_IPV4_DSLITE] = \"DS-LITE\",\n\t\t[MTK_PPE_PKT_TYPE_IPV6_ROUTE_3T] = \"IPv6 3T\",\n\t\t[MTK_PPE_PKT_TYPE_IPV6_ROUTE_5T] = \"IPv6 5T\",\n\t\t[MTK_PPE_PKT_TYPE_IPV6_6RD] = \"6RD\",\n\t};\n\n\tif (type >= ARRAY_SIZE(type_str) || !type_str[type])\n\t\treturn \"UNKNOWN\";\n\n\treturn type_str[type];\n}\n\nstatic void\nmtk_print_addr(struct seq_file *m, u32 *addr, bool ipv6)\n{\n\t__be32 n_addr[4];\n\tint i;\n\n\tif (!ipv6) {\n\t\tseq_printf(m, \"%pI4h\", addr);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(n_addr); i++)\n\t\tn_addr[i] = htonl(addr[i]);\n\tseq_printf(m, \"%pI6\", n_addr);\n}\n\nstatic void\nmtk_print_addr_info(struct seq_file *m, struct mtk_flow_addr_info *ai)\n{\n\tmtk_print_addr(m, ai->src, ai->ipv6);\n\tif (ai->src_port)\n\t\tseq_printf(m, \":%d\", *ai->src_port);\n\tseq_printf(m, \"->\");\n\tmtk_print_addr(m, ai->dest, ai->ipv6);\n\tif (ai->dest_port)\n\t\tseq_printf(m, \":%d\", *ai->dest_port);\n}\n\nstatic int\nmtk_ppe_debugfs_foe_show(struct seq_file *m, void *private, bool bind)\n{\n\tstruct mtk_ppe *ppe = m->private;\n\tint i;\n\n\tfor (i = 0; i < MTK_PPE_ENTRIES; i++) {\n\t\tstruct mtk_foe_entry *entry = mtk_foe_get_entry(ppe, i);\n\t\tstruct mtk_foe_mac_info *l2;\n\t\tstruct mtk_flow_addr_info ai = {};\n\t\tstruct mtk_foe_accounting *acct;\n\t\tunsigned char h_source[ETH_ALEN];\n\t\tunsigned char h_dest[ETH_ALEN];\n\t\tint type, state;\n\t\tu32 ib2;\n\n\n\t\tstate = FIELD_GET(MTK_FOE_IB1_STATE, entry->ib1);\n\t\tif (!state)\n\t\t\tcontinue;\n\n\t\tif (bind && state != MTK_FOE_STATE_BIND)\n\t\t\tcontinue;\n\n\t\tacct = mtk_foe_entry_get_mib(ppe, i, NULL);\n\n\t\ttype = mtk_get_ib1_pkt_type(ppe->eth, entry->ib1);\n\t\tseq_printf(m, \"%05x %s %7s\", i,\n\t\t\t   mtk_foe_entry_state_str(state),\n\t\t\t   mtk_foe_pkt_type_str(type));\n\n\t\tswitch (type) {\n\t\tcase MTK_PPE_PKT_TYPE_IPV4_HNAPT:\n\t\tcase MTK_PPE_PKT_TYPE_IPV4_DSLITE:\n\t\t\tai.src_port = &entry->ipv4.orig.src_port;\n\t\t\tai.dest_port = &entry->ipv4.orig.dest_port;\n\t\t\tfallthrough;\n\t\tcase MTK_PPE_PKT_TYPE_IPV4_ROUTE:\n\t\t\tai.src = &entry->ipv4.orig.src_ip;\n\t\t\tai.dest = &entry->ipv4.orig.dest_ip;\n\t\t\tbreak;\n\t\tcase MTK_PPE_PKT_TYPE_IPV6_ROUTE_5T:\n\t\t\tai.src_port = &entry->ipv6.src_port;\n\t\t\tai.dest_port = &entry->ipv6.dest_port;\n\t\t\tfallthrough;\n\t\tcase MTK_PPE_PKT_TYPE_IPV6_ROUTE_3T:\n\t\tcase MTK_PPE_PKT_TYPE_IPV6_6RD:\n\t\t\tai.src = &entry->ipv6.src_ip;\n\t\t\tai.dest = &entry->ipv6.dest_ip;\n\t\t\tai.ipv6 = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tseq_printf(m, \" orig=\");\n\t\tmtk_print_addr_info(m, &ai);\n\n\t\tswitch (type) {\n\t\tcase MTK_PPE_PKT_TYPE_IPV4_HNAPT:\n\t\tcase MTK_PPE_PKT_TYPE_IPV4_DSLITE:\n\t\t\tai.src_port = &entry->ipv4.new.src_port;\n\t\t\tai.dest_port = &entry->ipv4.new.dest_port;\n\t\t\tfallthrough;\n\t\tcase MTK_PPE_PKT_TYPE_IPV4_ROUTE:\n\t\t\tai.src = &entry->ipv4.new.src_ip;\n\t\t\tai.dest = &entry->ipv4.new.dest_ip;\n\t\t\tseq_printf(m, \" new=\");\n\t\t\tmtk_print_addr_info(m, &ai);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (type >= MTK_PPE_PKT_TYPE_IPV4_DSLITE) {\n\t\t\tl2 = &entry->ipv6.l2;\n\t\t\tib2 = entry->ipv6.ib2;\n\t\t} else {\n\t\t\tl2 = &entry->ipv4.l2;\n\t\t\tib2 = entry->ipv4.ib2;\n\t\t}\n\n\t\t*((__be32 *)h_source) = htonl(l2->src_mac_hi);\n\t\t*((__be16 *)&h_source[4]) = htons(l2->src_mac_lo);\n\t\t*((__be32 *)h_dest) = htonl(l2->dest_mac_hi);\n\t\t*((__be16 *)&h_dest[4]) = htons(l2->dest_mac_lo);\n\n\t\tseq_printf(m, \" eth=%pM->%pM etype=%04x\"\n\t\t\t      \" vlan=%d,%d ib1=%08x ib2=%08x\"\n\t\t\t      \" packets=%llu bytes=%llu\\n\",\n\t\t\t   h_source, h_dest, ntohs(l2->etype),\n\t\t\t   l2->vlan1, l2->vlan2, entry->ib1, ib2,\n\t\t\t   acct ? acct->packets : 0, acct ? acct->bytes : 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmtk_ppe_debugfs_foe_all_show(struct seq_file *m, void *private)\n{\n\treturn mtk_ppe_debugfs_foe_show(m, private, false);\n}\nDEFINE_SHOW_ATTRIBUTE(mtk_ppe_debugfs_foe_all);\n\nstatic int\nmtk_ppe_debugfs_foe_bind_show(struct seq_file *m, void *private)\n{\n\treturn mtk_ppe_debugfs_foe_show(m, private, true);\n}\nDEFINE_SHOW_ATTRIBUTE(mtk_ppe_debugfs_foe_bind);\n\nint mtk_ppe_debugfs_init(struct mtk_ppe *ppe, int index)\n{\n\tstruct dentry *root;\n\n\tsnprintf(ppe->dirname, sizeof(ppe->dirname), \"ppe%d\", index);\n\n\troot = debugfs_create_dir(ppe->dirname, NULL);\n\tdebugfs_create_file(\"entries\", S_IRUGO, root, ppe, &mtk_ppe_debugfs_foe_all_fops);\n\tdebugfs_create_file(\"bind\", S_IRUGO, root, ppe, &mtk_ppe_debugfs_foe_bind_fops);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}