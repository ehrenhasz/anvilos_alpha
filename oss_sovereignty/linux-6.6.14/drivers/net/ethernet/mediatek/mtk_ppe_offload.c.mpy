{
  "module_name": "mtk_ppe_offload.c",
  "hash_id": "444bd5d077581a8e86a2f25f93d7eb8ebfa3e20f5795f271ef36fe7cabdc8a5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mediatek/mtk_ppe_offload.c",
  "human_readable_source": "\n \n\n#include <linux/if_ether.h>\n#include <linux/rhashtable.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <net/flow_offload.h>\n#include <net/pkt_cls.h>\n#include <net/dsa.h>\n#include \"mtk_eth_soc.h\"\n#include \"mtk_wed.h\"\n\nstruct mtk_flow_data {\n\tstruct ethhdr eth;\n\n\tunion {\n\t\tstruct {\n\t\t\t__be32 src_addr;\n\t\t\t__be32 dst_addr;\n\t\t} v4;\n\n\t\tstruct {\n\t\t\tstruct in6_addr src_addr;\n\t\t\tstruct in6_addr dst_addr;\n\t\t} v6;\n\t};\n\n\t__be16 src_port;\n\t__be16 dst_port;\n\n\tu16 vlan_in;\n\n\tstruct {\n\t\tu16 id;\n\t\t__be16 proto;\n\t\tu8 num;\n\t} vlan;\n\tstruct {\n\t\tu16 sid;\n\t\tu8 num;\n\t} pppoe;\n};\n\nstatic const struct rhashtable_params mtk_flow_ht_params = {\n\t.head_offset = offsetof(struct mtk_flow_entry, node),\n\t.key_offset = offsetof(struct mtk_flow_entry, cookie),\n\t.key_len = sizeof(unsigned long),\n\t.automatic_shrinking = true,\n};\n\nstatic int\nmtk_flow_set_ipv4_addr(struct mtk_eth *eth, struct mtk_foe_entry *foe,\n\t\t       struct mtk_flow_data *data, bool egress)\n{\n\treturn mtk_foe_entry_set_ipv4_tuple(eth, foe, egress,\n\t\t\t\t\t    data->v4.src_addr, data->src_port,\n\t\t\t\t\t    data->v4.dst_addr, data->dst_port);\n}\n\nstatic int\nmtk_flow_set_ipv6_addr(struct mtk_eth *eth, struct mtk_foe_entry *foe,\n\t\t       struct mtk_flow_data *data)\n{\n\treturn mtk_foe_entry_set_ipv6_tuple(eth, foe,\n\t\t\t\t\t    data->v6.src_addr.s6_addr32, data->src_port,\n\t\t\t\t\t    data->v6.dst_addr.s6_addr32, data->dst_port);\n}\n\nstatic void\nmtk_flow_offload_mangle_eth(const struct flow_action_entry *act, void *eth)\n{\n\tvoid *dest = eth + act->mangle.offset;\n\tconst void *src = &act->mangle.val;\n\n\tif (act->mangle.offset > 8)\n\t\treturn;\n\n\tif (act->mangle.mask == 0xffff) {\n\t\tsrc += 2;\n\t\tdest += 2;\n\t}\n\n\tmemcpy(dest, src, act->mangle.mask ? 2 : 4);\n}\n\nstatic int\nmtk_flow_get_wdma_info(struct net_device *dev, const u8 *addr, struct mtk_wdma_info *info)\n{\n\tstruct net_device_path_stack stack;\n\tstruct net_device_path *path;\n\tint err;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!IS_ENABLED(CONFIG_NET_MEDIATEK_SOC_WED))\n\t\treturn -1;\n\n\terr = dev_fill_forward_path(dev, addr, &stack);\n\tif (err)\n\t\treturn err;\n\n\tpath = &stack.path[stack.num_paths - 1];\n\tif (path->type != DEV_PATH_MTK_WDMA)\n\t\treturn -1;\n\n\tinfo->wdma_idx = path->mtk_wdma.wdma_idx;\n\tinfo->queue = path->mtk_wdma.queue;\n\tinfo->bss = path->mtk_wdma.bss;\n\tinfo->wcid = path->mtk_wdma.wcid;\n\n\treturn 0;\n}\n\n\nstatic int\nmtk_flow_mangle_ports(const struct flow_action_entry *act,\n\t\t      struct mtk_flow_data *data)\n{\n\tu32 val = ntohl(act->mangle.val);\n\n\tswitch (act->mangle.offset) {\n\tcase 0:\n\t\tif (act->mangle.mask == ~htonl(0xffff))\n\t\t\tdata->dst_port = cpu_to_be16(val);\n\t\telse\n\t\t\tdata->src_port = cpu_to_be16(val >> 16);\n\t\tbreak;\n\tcase 2:\n\t\tdata->dst_port = cpu_to_be16(val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmtk_flow_mangle_ipv4(const struct flow_action_entry *act,\n\t\t     struct mtk_flow_data *data)\n{\n\t__be32 *dest;\n\n\tswitch (act->mangle.offset) {\n\tcase offsetof(struct iphdr, saddr):\n\t\tdest = &data->v4.src_addr;\n\t\tbreak;\n\tcase offsetof(struct iphdr, daddr):\n\t\tdest = &data->v4.dst_addr;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(dest, &act->mangle.val, sizeof(u32));\n\n\treturn 0;\n}\n\nstatic int\nmtk_flow_get_dsa_port(struct net_device **dev)\n{\n#if IS_ENABLED(CONFIG_NET_DSA)\n\tstruct dsa_port *dp;\n\n\tdp = dsa_port_from_netdev(*dev);\n\tif (IS_ERR(dp))\n\t\treturn -ENODEV;\n\n\tif (dp->cpu_dp->tag_ops->proto != DSA_TAG_PROTO_MTK)\n\t\treturn -ENODEV;\n\n\t*dev = dsa_port_to_master(dp);\n\n\treturn dp->index;\n#else\n\treturn -ENODEV;\n#endif\n}\n\nstatic int\nmtk_flow_set_output_device(struct mtk_eth *eth, struct mtk_foe_entry *foe,\n\t\t\t   struct net_device *dev, const u8 *dest_mac,\n\t\t\t   int *wed_index)\n{\n\tstruct mtk_wdma_info info = {};\n\tint pse_port, dsa_port, queue;\n\n\tif (mtk_flow_get_wdma_info(dev, dest_mac, &info) == 0) {\n\t\tmtk_foe_entry_set_wdma(eth, foe, info.wdma_idx, info.queue,\n\t\t\t\t       info.bss, info.wcid);\n\t\tif (mtk_is_netsys_v2_or_greater(eth)) {\n\t\t\tswitch (info.wdma_idx) {\n\t\t\tcase 0:\n\t\t\t\tpse_port = 8;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tpse_port = 9;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tpse_port = 3;\n\t\t}\n\t\t*wed_index = info.wdma_idx;\n\t\tgoto out;\n\t}\n\n\tdsa_port = mtk_flow_get_dsa_port(&dev);\n\n\tif (dev == eth->netdev[0])\n\t\tpse_port = PSE_GDM1_PORT;\n\telse if (dev == eth->netdev[1])\n\t\tpse_port = PSE_GDM2_PORT;\n\telse if (dev == eth->netdev[2])\n\t\tpse_port = PSE_GDM3_PORT;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\tif (dsa_port >= 0) {\n\t\tmtk_foe_entry_set_dsa(eth, foe, dsa_port);\n\t\tqueue = 3 + dsa_port;\n\t} else {\n\t\tqueue = pse_port - 1;\n\t}\n\tmtk_foe_entry_set_queue(eth, foe, queue);\n\nout:\n\tmtk_foe_entry_set_pse_port(eth, foe, pse_port);\n\n\treturn 0;\n}\n\nstatic int\nmtk_flow_offload_replace(struct mtk_eth *eth, struct flow_cls_offload *f,\n\t\t\t int ppe_index)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct flow_action_entry *act;\n\tstruct mtk_flow_data data = {};\n\tstruct mtk_foe_entry foe;\n\tstruct net_device *odev = NULL;\n\tstruct mtk_flow_entry *entry;\n\tint offload_type = 0;\n\tint wed_index = -1;\n\tu16 addr_type = 0;\n\tu8 l4proto = 0;\n\tint err = 0;\n\tint i;\n\n\tif (rhashtable_lookup(&eth->flow_table, &f->cookie, mtk_flow_ht_params))\n\t\treturn -EEXIST;\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_META)) {\n\t\tstruct flow_match_meta match;\n\n\t\tflow_rule_match_meta(rule, &match);\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CONTROL)) {\n\t\tstruct flow_match_control match;\n\n\t\tflow_rule_match_control(rule, &match);\n\t\taddr_type = match.key->addr_type;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC)) {\n\t\tstruct flow_match_basic match;\n\n\t\tflow_rule_match_basic(rule, &match);\n\t\tl4proto = match.key->ip_proto;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (addr_type) {\n\tcase 0:\n\t\toffload_type = MTK_PPE_PKT_TYPE_BRIDGE;\n\t\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\t\tstruct flow_match_eth_addrs match;\n\n\t\t\tflow_rule_match_eth_addrs(rule, &match);\n\t\t\tmemcpy(data.eth.h_dest, match.key->dst, ETH_ALEN);\n\t\t\tmemcpy(data.eth.h_source, match.key->src, ETH_ALEN);\n\t\t} else {\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\t\tstruct flow_match_vlan match;\n\n\t\t\tflow_rule_match_vlan(rule, &match);\n\n\t\t\tif (match.key->vlan_tpid != cpu_to_be16(ETH_P_8021Q))\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tdata.vlan_in = match.key->vlan_id;\n\t\t}\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\toffload_type = MTK_PPE_PKT_TYPE_IPV4_HNAPT;\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\toffload_type = MTK_PPE_PKT_TYPE_IPV6_ROUTE_5T;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tflow_action_for_each(i, act, &rule->action) {\n\t\tswitch (act->id) {\n\t\tcase FLOW_ACTION_MANGLE:\n\t\t\tif (offload_type == MTK_PPE_PKT_TYPE_BRIDGE)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tif (act->mangle.htype == FLOW_ACT_MANGLE_HDR_TYPE_ETH)\n\t\t\t\tmtk_flow_offload_mangle_eth(act, &data.eth);\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_REDIRECT:\n\t\t\todev = act->dev;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_CSUM:\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_VLAN_PUSH:\n\t\t\tif (data.vlan.num == 1 ||\n\t\t\t    act->vlan.proto != htons(ETH_P_8021Q))\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tdata.vlan.id = act->vlan.vid;\n\t\t\tdata.vlan.proto = act->vlan.proto;\n\t\t\tdata.vlan.num++;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_VLAN_POP:\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_PPPOE_PUSH:\n\t\t\tif (data.pppoe.num == 1)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tdata.pppoe.sid = act->pppoe.sid;\n\t\t\tdata.pppoe.num++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (!is_valid_ether_addr(data.eth.h_source) ||\n\t    !is_valid_ether_addr(data.eth.h_dest))\n\t\treturn -EINVAL;\n\n\terr = mtk_foe_entry_prepare(eth, &foe, offload_type, l4proto, 0,\n\t\t\t\t    data.eth.h_source, data.eth.h_dest);\n\tif (err)\n\t\treturn err;\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_PORTS)) {\n\t\tstruct flow_match_ports ports;\n\n\t\tif (offload_type == MTK_PPE_PKT_TYPE_BRIDGE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tflow_rule_match_ports(rule, &ports);\n\t\tdata.src_port = ports.key->src;\n\t\tdata.dst_port = ports.key->dst;\n\t} else if (offload_type != MTK_PPE_PKT_TYPE_BRIDGE) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {\n\t\tstruct flow_match_ipv4_addrs addrs;\n\n\t\tflow_rule_match_ipv4_addrs(rule, &addrs);\n\n\t\tdata.v4.src_addr = addrs.key->src;\n\t\tdata.v4.dst_addr = addrs.key->dst;\n\n\t\tmtk_flow_set_ipv4_addr(eth, &foe, &data, false);\n\t}\n\n\tif (addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {\n\t\tstruct flow_match_ipv6_addrs addrs;\n\n\t\tflow_rule_match_ipv6_addrs(rule, &addrs);\n\n\t\tdata.v6.src_addr = addrs.key->src;\n\t\tdata.v6.dst_addr = addrs.key->dst;\n\n\t\tmtk_flow_set_ipv6_addr(eth, &foe, &data);\n\t}\n\n\tflow_action_for_each(i, act, &rule->action) {\n\t\tif (act->id != FLOW_ACTION_MANGLE)\n\t\t\tcontinue;\n\n\t\tif (offload_type == MTK_PPE_PKT_TYPE_BRIDGE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tswitch (act->mangle.htype) {\n\t\tcase FLOW_ACT_MANGLE_HDR_TYPE_TCP:\n\t\tcase FLOW_ACT_MANGLE_HDR_TYPE_UDP:\n\t\t\terr = mtk_flow_mangle_ports(act, &data);\n\t\t\tbreak;\n\t\tcase FLOW_ACT_MANGLE_HDR_TYPE_IP4:\n\t\t\terr = mtk_flow_mangle_ipv4(act, &data);\n\t\t\tbreak;\n\t\tcase FLOW_ACT_MANGLE_HDR_TYPE_ETH:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {\n\t\terr = mtk_flow_set_ipv4_addr(eth, &foe, &data, true);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (offload_type == MTK_PPE_PKT_TYPE_BRIDGE)\n\t\tfoe.bridge.vlan = data.vlan_in;\n\n\tif (data.vlan.num == 1) {\n\t\tif (data.vlan.proto != htons(ETH_P_8021Q))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tmtk_foe_entry_set_vlan(eth, &foe, data.vlan.id);\n\t}\n\tif (data.pppoe.num == 1)\n\t\tmtk_foe_entry_set_pppoe(eth, &foe, data.pppoe.sid);\n\n\terr = mtk_flow_set_output_device(eth, &foe, odev, data.eth.h_dest,\n\t\t\t\t\t &wed_index);\n\tif (err)\n\t\treturn err;\n\n\tif (wed_index >= 0 && (err = mtk_wed_flow_add(wed_index)) < 0)\n\t\treturn err;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->cookie = f->cookie;\n\tmemcpy(&entry->data, &foe, sizeof(entry->data));\n\tentry->wed_index = wed_index;\n\tentry->ppe_index = ppe_index;\n\n\terr = mtk_foe_entry_commit(eth->ppe[entry->ppe_index], entry);\n\tif (err < 0)\n\t\tgoto free;\n\n\terr = rhashtable_insert_fast(&eth->flow_table, &entry->node,\n\t\t\t\t     mtk_flow_ht_params);\n\tif (err < 0)\n\t\tgoto clear;\n\n\treturn 0;\n\nclear:\n\tmtk_foe_entry_clear(eth->ppe[entry->ppe_index], entry);\nfree:\n\tkfree(entry);\n\tif (wed_index >= 0)\n\t    mtk_wed_flow_remove(wed_index);\n\treturn err;\n}\n\nstatic int\nmtk_flow_offload_destroy(struct mtk_eth *eth, struct flow_cls_offload *f)\n{\n\tstruct mtk_flow_entry *entry;\n\n\tentry = rhashtable_lookup(&eth->flow_table, &f->cookie,\n\t\t\t\t  mtk_flow_ht_params);\n\tif (!entry)\n\t\treturn -ENOENT;\n\n\tmtk_foe_entry_clear(eth->ppe[entry->ppe_index], entry);\n\trhashtable_remove_fast(&eth->flow_table, &entry->node,\n\t\t\t       mtk_flow_ht_params);\n\tif (entry->wed_index >= 0)\n\t\tmtk_wed_flow_remove(entry->wed_index);\n\tkfree(entry);\n\n\treturn 0;\n}\n\nstatic int\nmtk_flow_offload_stats(struct mtk_eth *eth, struct flow_cls_offload *f)\n{\n\tstruct mtk_flow_entry *entry;\n\tstruct mtk_foe_accounting diff;\n\tu32 idle;\n\n\tentry = rhashtable_lookup(&eth->flow_table, &f->cookie,\n\t\t\t\t  mtk_flow_ht_params);\n\tif (!entry)\n\t\treturn -ENOENT;\n\n\tidle = mtk_foe_entry_idle_time(eth->ppe[entry->ppe_index], entry);\n\tf->stats.lastused = jiffies - idle * HZ;\n\n\tif (entry->hash != 0xFFFF &&\n\t    mtk_foe_entry_get_mib(eth->ppe[entry->ppe_index], entry->hash,\n\t\t\t\t  &diff)) {\n\t\tf->stats.pkts += diff.packets;\n\t\tf->stats.bytes += diff.bytes;\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_MUTEX(mtk_flow_offload_mutex);\n\nint mtk_flow_offload_cmd(struct mtk_eth *eth, struct flow_cls_offload *cls,\n\t\t\t int ppe_index)\n{\n\tint err;\n\n\tmutex_lock(&mtk_flow_offload_mutex);\n\tswitch (cls->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\terr = mtk_flow_offload_replace(eth, cls, ppe_index);\n\t\tbreak;\n\tcase FLOW_CLS_DESTROY:\n\t\terr = mtk_flow_offload_destroy(eth, cls);\n\t\tbreak;\n\tcase FLOW_CLS_STATS:\n\t\terr = mtk_flow_offload_stats(eth, cls);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mtk_flow_offload_mutex);\n\n\treturn err;\n}\n\nstatic int\nmtk_eth_setup_tc_block_cb(enum tc_setup_type type, void *type_data, void *cb_priv)\n{\n\tstruct flow_cls_offload *cls = type_data;\n\tstruct net_device *dev = cb_priv;\n\tstruct mtk_mac *mac;\n\tstruct mtk_eth *eth;\n\n\tmac = netdev_priv(dev);\n\teth = mac->hw;\n\n\tif (!tc_can_offload(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (type != TC_SETUP_CLSFLOWER)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mtk_flow_offload_cmd(eth, cls, 0);\n}\n\nstatic int\nmtk_eth_setup_tc_block(struct net_device *dev, struct flow_block_offload *f)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\tstatic LIST_HEAD(block_cb_list);\n\tstruct flow_block_cb *block_cb;\n\tflow_setup_cb_t *cb;\n\n\tif (!eth->soc->offload_version)\n\t\treturn -EOPNOTSUPP;\n\n\tif (f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS)\n\t\treturn -EOPNOTSUPP;\n\n\tcb = mtk_eth_setup_tc_block_cb;\n\tf->driver_block_list = &block_cb_list;\n\n\tswitch (f->command) {\n\tcase FLOW_BLOCK_BIND:\n\t\tblock_cb = flow_block_cb_lookup(f->block, cb, dev);\n\t\tif (block_cb) {\n\t\t\tflow_block_cb_incref(block_cb);\n\t\t\treturn 0;\n\t\t}\n\t\tblock_cb = flow_block_cb_alloc(cb, dev, dev, NULL);\n\t\tif (IS_ERR(block_cb))\n\t\t\treturn PTR_ERR(block_cb);\n\n\t\tflow_block_cb_incref(block_cb);\n\t\tflow_block_cb_add(block_cb, f);\n\t\tlist_add_tail(&block_cb->driver_list, &block_cb_list);\n\t\treturn 0;\n\tcase FLOW_BLOCK_UNBIND:\n\t\tblock_cb = flow_block_cb_lookup(f->block, cb, dev);\n\t\tif (!block_cb)\n\t\t\treturn -ENOENT;\n\n\t\tif (!flow_block_cb_decref(block_cb)) {\n\t\t\tflow_block_cb_remove(block_cb, f);\n\t\t\tlist_del(&block_cb->driver_list);\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint mtk_eth_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t     void *type_data)\n{\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK:\n\tcase TC_SETUP_FT:\n\t\treturn mtk_eth_setup_tc_block(dev, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint mtk_eth_offload_init(struct mtk_eth *eth)\n{\n\treturn rhashtable_init(&eth->flow_table, &mtk_flow_ht_params);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}