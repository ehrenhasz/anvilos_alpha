{
  "module_name": "mtk_star_emac.c",
  "hash_id": "99d99cc964a6bf507d5bf78245ed1ea494e656c1a7410e492932a21c1a8a0385",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mediatek/mtk_star_emac.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/compiler.h>\n#include <linux/dma-mapping.h>\n#include <linux/etherdevice.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n\n#define MTK_STAR_DRVNAME\t\t\t\"mtk_star_emac\"\n\n#define MTK_STAR_WAIT_TIMEOUT\t\t\t300\n#define MTK_STAR_MAX_FRAME_SIZE\t\t\t1514\n#define MTK_STAR_SKB_ALIGNMENT\t\t\t16\n#define MTK_STAR_HASHTABLE_MC_LIMIT\t\t256\n#define MTK_STAR_HASHTABLE_SIZE_MAX\t\t512\n#define MTK_STAR_DESC_NEEDED\t\t\t(MAX_SKB_FRAGS + 4)\n\n \n#define MTK_STAR_IP_ALIGN\t\t\t2\n\nstatic const char *const mtk_star_clk_names[] = { \"core\", \"reg\", \"trans\" };\n#define MTK_STAR_NCLKS ARRAY_SIZE(mtk_star_clk_names)\n\n \n#define MTK_STAR_REG_PHY_CTRL0\t\t\t0x0000\n#define MTK_STAR_BIT_PHY_CTRL0_WTCMD\t\tBIT(13)\n#define MTK_STAR_BIT_PHY_CTRL0_RDCMD\t\tBIT(14)\n#define MTK_STAR_BIT_PHY_CTRL0_RWOK\t\tBIT(15)\n#define MTK_STAR_MSK_PHY_CTRL0_PREG\t\tGENMASK(12, 8)\n#define MTK_STAR_OFF_PHY_CTRL0_PREG\t\t8\n#define MTK_STAR_MSK_PHY_CTRL0_RWDATA\t\tGENMASK(31, 16)\n#define MTK_STAR_OFF_PHY_CTRL0_RWDATA\t\t16\n\n \n#define MTK_STAR_REG_PHY_CTRL1\t\t\t0x0004\n#define MTK_STAR_BIT_PHY_CTRL1_LINK_ST\t\tBIT(0)\n#define MTK_STAR_BIT_PHY_CTRL1_AN_EN\t\tBIT(8)\n#define MTK_STAR_OFF_PHY_CTRL1_FORCE_SPD\t9\n#define MTK_STAR_VAL_PHY_CTRL1_FORCE_SPD_10M\t0x00\n#define MTK_STAR_VAL_PHY_CTRL1_FORCE_SPD_100M\t0x01\n#define MTK_STAR_VAL_PHY_CTRL1_FORCE_SPD_1000M\t0x02\n#define MTK_STAR_BIT_PHY_CTRL1_FORCE_DPX\tBIT(11)\n#define MTK_STAR_BIT_PHY_CTRL1_FORCE_FC_RX\tBIT(12)\n#define MTK_STAR_BIT_PHY_CTRL1_FORCE_FC_TX\tBIT(13)\n\n \n#define MTK_STAR_REG_MAC_CFG\t\t\t0x0008\n#define MTK_STAR_OFF_MAC_CFG_IPG\t\t10\n#define MTK_STAR_VAL_MAC_CFG_IPG_96BIT\t\tGENMASK(4, 0)\n#define MTK_STAR_BIT_MAC_CFG_MAXLEN_1522\tBIT(16)\n#define MTK_STAR_BIT_MAC_CFG_AUTO_PAD\t\tBIT(19)\n#define MTK_STAR_BIT_MAC_CFG_CRC_STRIP\t\tBIT(20)\n#define MTK_STAR_BIT_MAC_CFG_VLAN_STRIP\t\tBIT(22)\n#define MTK_STAR_BIT_MAC_CFG_NIC_PD\t\tBIT(31)\n\n \n#define MTK_STAR_REG_FC_CFG\t\t\t0x000c\n#define MTK_STAR_BIT_FC_CFG_BP_EN\t\tBIT(7)\n#define MTK_STAR_BIT_FC_CFG_UC_PAUSE_DIR\tBIT(8)\n#define MTK_STAR_OFF_FC_CFG_SEND_PAUSE_TH\t16\n#define MTK_STAR_MSK_FC_CFG_SEND_PAUSE_TH\tGENMASK(27, 16)\n#define MTK_STAR_VAL_FC_CFG_SEND_PAUSE_TH_2K\t0x800\n\n \n#define MTK_STAR_REG_ARL_CFG\t\t\t0x0010\n#define MTK_STAR_BIT_ARL_CFG_HASH_ALG\t\tBIT(0)\n#define MTK_STAR_BIT_ARL_CFG_MISC_MODE\t\tBIT(4)\n\n \n#define MTK_STAR_REG_MY_MAC_H\t\t\t0x0014\n#define MTK_STAR_REG_MY_MAC_L\t\t\t0x0018\n\n \n#define MTK_STAR_REG_HASH_CTRL\t\t\t0x001c\n#define MTK_STAR_MSK_HASH_CTRL_HASH_BIT_ADDR\tGENMASK(8, 0)\n#define MTK_STAR_BIT_HASH_CTRL_HASH_BIT_DATA\tBIT(12)\n#define MTK_STAR_BIT_HASH_CTRL_ACC_CMD\t\tBIT(13)\n#define MTK_STAR_BIT_HASH_CTRL_CMD_START\tBIT(14)\n#define MTK_STAR_BIT_HASH_CTRL_BIST_OK\t\tBIT(16)\n#define MTK_STAR_BIT_HASH_CTRL_BIST_DONE\tBIT(17)\n#define MTK_STAR_BIT_HASH_CTRL_BIST_EN\t\tBIT(31)\n\n \n#define MTK_STAR_REG_TX_DMA_CTRL\t\t0x0034\n#define MTK_STAR_BIT_TX_DMA_CTRL_START\t\tBIT(0)\n#define MTK_STAR_BIT_TX_DMA_CTRL_STOP\t\tBIT(1)\n#define MTK_STAR_BIT_TX_DMA_CTRL_RESUME\t\tBIT(2)\n\n \n#define MTK_STAR_REG_RX_DMA_CTRL\t\t0x0038\n#define MTK_STAR_BIT_RX_DMA_CTRL_START\t\tBIT(0)\n#define MTK_STAR_BIT_RX_DMA_CTRL_STOP\t\tBIT(1)\n#define MTK_STAR_BIT_RX_DMA_CTRL_RESUME\t\tBIT(2)\n\n \n#define MTK_STAR_REG_TX_DPTR\t\t\t0x003c\n#define MTK_STAR_REG_RX_DPTR\t\t\t0x0040\n#define MTK_STAR_REG_TX_BASE_ADDR\t\t0x0044\n#define MTK_STAR_REG_RX_BASE_ADDR\t\t0x0048\n\n \n#define MTK_STAR_REG_INT_STS\t\t\t0x0050\n#define MTK_STAR_REG_INT_STS_PORT_STS_CHG\tBIT(2)\n#define MTK_STAR_REG_INT_STS_MIB_CNT_TH\t\tBIT(3)\n#define MTK_STAR_BIT_INT_STS_FNRC\t\tBIT(6)\n#define MTK_STAR_BIT_INT_STS_TNTC\t\tBIT(8)\n\n \n#define MTK_STAR_REG_INT_MASK\t\t\t0x0054\n#define MTK_STAR_BIT_INT_MASK_FNRC\t\tBIT(6)\n\n \n#define MTK_STAR_REG_TEST0\t\t\t0x0058\n#define MTK_STAR_BIT_INV_RX_CLK\t\t\tBIT(30)\n#define MTK_STAR_BIT_INV_TX_CLK\t\t\tBIT(31)\n\n \n#define MTK_STAR_REG_TEST1\t\t\t0x005c\n#define MTK_STAR_BIT_TEST1_RST_HASH_MBIST\tBIT(31)\n\n \n#define MTK_STAR_REG_EXT_CFG\t\t\t0x0060\n#define MTK_STAR_OFF_EXT_CFG_SND_PAUSE_RLS\t16\n#define MTK_STAR_MSK_EXT_CFG_SND_PAUSE_RLS\tGENMASK(26, 16)\n#define MTK_STAR_VAL_EXT_CFG_SND_PAUSE_RLS_1K\t0x400\n\n \n#define MTK_STAR_REG_SYS_CONF\t\t\t0x0094\n#define MTK_STAR_BIT_MII_PAD_OUT_ENABLE\t\tBIT(0)\n#define MTK_STAR_BIT_EXT_MDC_MODE\t\tBIT(1)\n#define MTK_STAR_BIT_SWC_MII_MODE\t\tBIT(2)\n\n \n#define MTK_STAR_REG_MAC_CLK_CONF\t\t0x00ac\n#define MTK_STAR_MSK_MAC_CLK_CONF\t\tGENMASK(7, 0)\n#define MTK_STAR_BIT_CLK_DIV_10\t\t\t0x0a\n#define MTK_STAR_BIT_CLK_DIV_50\t\t\t0x32\n\n \n#define MTK_STAR_REG_C_RXOKPKT\t\t\t0x0100\n#define MTK_STAR_REG_C_RXOKBYTE\t\t\t0x0104\n#define MTK_STAR_REG_C_RXRUNT\t\t\t0x0108\n#define MTK_STAR_REG_C_RXLONG\t\t\t0x010c\n#define MTK_STAR_REG_C_RXDROP\t\t\t0x0110\n#define MTK_STAR_REG_C_RXCRC\t\t\t0x0114\n#define MTK_STAR_REG_C_RXARLDROP\t\t0x0118\n#define MTK_STAR_REG_C_RXVLANDROP\t\t0x011c\n#define MTK_STAR_REG_C_RXCSERR\t\t\t0x0120\n#define MTK_STAR_REG_C_RXPAUSE\t\t\t0x0124\n#define MTK_STAR_REG_C_TXOKPKT\t\t\t0x0128\n#define MTK_STAR_REG_C_TXOKBYTE\t\t\t0x012c\n#define MTK_STAR_REG_C_TXPAUSECOL\t\t0x0130\n#define MTK_STAR_REG_C_TXRTY\t\t\t0x0134\n#define MTK_STAR_REG_C_TXSKIP\t\t\t0x0138\n#define MTK_STAR_REG_C_TX_ARP\t\t\t0x013c\n#define MTK_STAR_REG_C_RX_RERR\t\t\t0x01d8\n#define MTK_STAR_REG_C_RX_UNI\t\t\t0x01dc\n#define MTK_STAR_REG_C_RX_MULTI\t\t\t0x01e0\n#define MTK_STAR_REG_C_RX_BROAD\t\t\t0x01e4\n#define MTK_STAR_REG_C_RX_ALIGNERR\t\t0x01e8\n#define MTK_STAR_REG_C_TX_UNI\t\t\t0x01ec\n#define MTK_STAR_REG_C_TX_MULTI\t\t\t0x01f0\n#define MTK_STAR_REG_C_TX_BROAD\t\t\t0x01f4\n#define MTK_STAR_REG_C_TX_TIMEOUT\t\t0x01f8\n#define MTK_STAR_REG_C_TX_LATECOL\t\t0x01fc\n#define MTK_STAR_REG_C_RX_LENGTHERR\t\t0x0214\n#define MTK_STAR_REG_C_RX_TWIST\t\t\t0x0218\n\n \n#define MTK_PERICFG_REG_NIC_CFG0_CON\t\t0x03c4\n#define MTK_PERICFG_REG_NIC_CFG1_CON\t\t0x03c8\n#define MTK_PERICFG_REG_NIC_CFG_CON_V2\t\t0x0c10\n#define MTK_PERICFG_REG_NIC_CFG_CON_CFG_INTF\tGENMASK(3, 0)\n#define MTK_PERICFG_BIT_NIC_CFG_CON_MII\t\t0\n#define MTK_PERICFG_BIT_NIC_CFG_CON_RMII\t1\n#define MTK_PERICFG_BIT_NIC_CFG_CON_CLK\t\tBIT(0)\n#define MTK_PERICFG_BIT_NIC_CFG_CON_CLK_V2\tBIT(8)\n\n \nstruct mtk_star_ring_desc {\n\t \n\tu32 status;\n\tu32 data_ptr;\n\tu32 vtag;\n\tu32 reserved;\n};\n\n#define MTK_STAR_DESC_MSK_LEN\t\t\tGENMASK(15, 0)\n#define MTK_STAR_DESC_BIT_RX_CRCE\t\tBIT(24)\n#define MTK_STAR_DESC_BIT_RX_OSIZE\t\tBIT(25)\n#define MTK_STAR_DESC_BIT_INT\t\t\tBIT(27)\n#define MTK_STAR_DESC_BIT_LS\t\t\tBIT(28)\n#define MTK_STAR_DESC_BIT_FS\t\t\tBIT(29)\n#define MTK_STAR_DESC_BIT_EOR\t\t\tBIT(30)\n#define MTK_STAR_DESC_BIT_COWN\t\t\tBIT(31)\n\n \nstruct mtk_star_ring_desc_data {\n\tunsigned int len;\n\tunsigned int flags;\n\tdma_addr_t dma_addr;\n\tstruct sk_buff *skb;\n};\n\n#define MTK_STAR_RING_NUM_DESCS\t\t\t512\n#define MTK_STAR_TX_THRESH\t\t\t(MTK_STAR_RING_NUM_DESCS / 4)\n#define MTK_STAR_NUM_TX_DESCS\t\t\tMTK_STAR_RING_NUM_DESCS\n#define MTK_STAR_NUM_RX_DESCS\t\t\tMTK_STAR_RING_NUM_DESCS\n#define MTK_STAR_NUM_DESCS_TOTAL\t\t(MTK_STAR_RING_NUM_DESCS * 2)\n#define MTK_STAR_DMA_SIZE \\\n\t\t(MTK_STAR_NUM_DESCS_TOTAL * sizeof(struct mtk_star_ring_desc))\n\nstruct mtk_star_ring {\n\tstruct mtk_star_ring_desc *descs;\n\tstruct sk_buff *skbs[MTK_STAR_RING_NUM_DESCS];\n\tdma_addr_t dma_addrs[MTK_STAR_RING_NUM_DESCS];\n\tunsigned int head;\n\tunsigned int tail;\n};\n\nstruct mtk_star_compat {\n\tint (*set_interface_mode)(struct net_device *ndev);\n\tunsigned char bit_clk_div;\n};\n\nstruct mtk_star_priv {\n\tstruct net_device *ndev;\n\n\tstruct regmap *regs;\n\tstruct regmap *pericfg;\n\n\tstruct clk_bulk_data clks[MTK_STAR_NCLKS];\n\n\tvoid *ring_base;\n\tstruct mtk_star_ring_desc *descs_base;\n\tdma_addr_t dma_addr;\n\tstruct mtk_star_ring tx_ring;\n\tstruct mtk_star_ring rx_ring;\n\n\tstruct mii_bus *mii;\n\tstruct napi_struct tx_napi;\n\tstruct napi_struct rx_napi;\n\n\tstruct device_node *phy_node;\n\tphy_interface_t phy_intf;\n\tstruct phy_device *phydev;\n\tunsigned int link;\n\tint speed;\n\tint duplex;\n\tint pause;\n\tbool rmii_rxc;\n\tbool rx_inv;\n\tbool tx_inv;\n\n\tconst struct mtk_star_compat *compat_data;\n\n\t \n\tspinlock_t lock;\n\n\tstruct rtnl_link_stats64 stats;\n};\n\nstatic struct device *mtk_star_get_dev(struct mtk_star_priv *priv)\n{\n\treturn priv->ndev->dev.parent;\n}\n\nstatic const struct regmap_config mtk_star_regmap_config = {\n\t.reg_bits\t\t= 32,\n\t.val_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.disable_locking\t= true,\n};\n\nstatic void mtk_star_ring_init(struct mtk_star_ring *ring,\n\t\t\t       struct mtk_star_ring_desc *descs)\n{\n\tmemset(ring, 0, sizeof(*ring));\n\tring->descs = descs;\n\tring->head = 0;\n\tring->tail = 0;\n}\n\nstatic int mtk_star_ring_pop_tail(struct mtk_star_ring *ring,\n\t\t\t\t  struct mtk_star_ring_desc_data *desc_data)\n{\n\tstruct mtk_star_ring_desc *desc = &ring->descs[ring->tail];\n\tunsigned int status;\n\n\tstatus = READ_ONCE(desc->status);\n\tdma_rmb();  \n\n\tif (!(status & MTK_STAR_DESC_BIT_COWN))\n\t\treturn -1;\n\n\tdesc_data->len = status & MTK_STAR_DESC_MSK_LEN;\n\tdesc_data->flags = status & ~MTK_STAR_DESC_MSK_LEN;\n\tdesc_data->dma_addr = ring->dma_addrs[ring->tail];\n\tdesc_data->skb = ring->skbs[ring->tail];\n\n\tring->dma_addrs[ring->tail] = 0;\n\tring->skbs[ring->tail] = NULL;\n\n\tstatus &= MTK_STAR_DESC_BIT_COWN | MTK_STAR_DESC_BIT_EOR;\n\n\tWRITE_ONCE(desc->data_ptr, 0);\n\tWRITE_ONCE(desc->status, status);\n\n\tring->tail = (ring->tail + 1) % MTK_STAR_RING_NUM_DESCS;\n\n\treturn 0;\n}\n\nstatic void mtk_star_ring_push_head(struct mtk_star_ring *ring,\n\t\t\t\t    struct mtk_star_ring_desc_data *desc_data,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct mtk_star_ring_desc *desc = &ring->descs[ring->head];\n\tunsigned int status;\n\n\tstatus = READ_ONCE(desc->status);\n\n\tring->skbs[ring->head] = desc_data->skb;\n\tring->dma_addrs[ring->head] = desc_data->dma_addr;\n\n\tstatus |= desc_data->len;\n\tif (flags)\n\t\tstatus |= flags;\n\n\tWRITE_ONCE(desc->data_ptr, desc_data->dma_addr);\n\tWRITE_ONCE(desc->status, status);\n\tstatus &= ~MTK_STAR_DESC_BIT_COWN;\n\t \n\tdma_wmb();\n\tWRITE_ONCE(desc->status, status);\n\n\tring->head = (ring->head + 1) % MTK_STAR_RING_NUM_DESCS;\n}\n\nstatic void\nmtk_star_ring_push_head_rx(struct mtk_star_ring *ring,\n\t\t\t   struct mtk_star_ring_desc_data *desc_data)\n{\n\tmtk_star_ring_push_head(ring, desc_data, 0);\n}\n\nstatic void\nmtk_star_ring_push_head_tx(struct mtk_star_ring *ring,\n\t\t\t   struct mtk_star_ring_desc_data *desc_data)\n{\n\tstatic const unsigned int flags = MTK_STAR_DESC_BIT_FS |\n\t\t\t\t\t  MTK_STAR_DESC_BIT_LS |\n\t\t\t\t\t  MTK_STAR_DESC_BIT_INT;\n\n\tmtk_star_ring_push_head(ring, desc_data, flags);\n}\n\nstatic unsigned int mtk_star_tx_ring_avail(struct mtk_star_ring *ring)\n{\n\tu32 avail;\n\n\tif (ring->tail > ring->head)\n\t\tavail = ring->tail - ring->head - 1;\n\telse\n\t\tavail = MTK_STAR_RING_NUM_DESCS - ring->head + ring->tail - 1;\n\n\treturn avail;\n}\n\nstatic dma_addr_t mtk_star_dma_map_rx(struct mtk_star_priv *priv,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct device *dev = mtk_star_get_dev(priv);\n\n\t \n\treturn dma_map_single(dev, skb_tail_pointer(skb) - 2,\n\t\t\t      skb_tailroom(skb), DMA_FROM_DEVICE);\n}\n\nstatic void mtk_star_dma_unmap_rx(struct mtk_star_priv *priv,\n\t\t\t\t  struct mtk_star_ring_desc_data *desc_data)\n{\n\tstruct device *dev = mtk_star_get_dev(priv);\n\n\tdma_unmap_single(dev, desc_data->dma_addr,\n\t\t\t skb_tailroom(desc_data->skb), DMA_FROM_DEVICE);\n}\n\nstatic dma_addr_t mtk_star_dma_map_tx(struct mtk_star_priv *priv,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct device *dev = mtk_star_get_dev(priv);\n\n\treturn dma_map_single(dev, skb->data, skb_headlen(skb), DMA_TO_DEVICE);\n}\n\nstatic void mtk_star_dma_unmap_tx(struct mtk_star_priv *priv,\n\t\t\t\t  struct mtk_star_ring_desc_data *desc_data)\n{\n\tstruct device *dev = mtk_star_get_dev(priv);\n\n\treturn dma_unmap_single(dev, desc_data->dma_addr,\n\t\t\t\tskb_headlen(desc_data->skb), DMA_TO_DEVICE);\n}\n\nstatic void mtk_star_nic_disable_pd(struct mtk_star_priv *priv)\n{\n\tregmap_clear_bits(priv->regs, MTK_STAR_REG_MAC_CFG,\n\t\t\t  MTK_STAR_BIT_MAC_CFG_NIC_PD);\n}\n\nstatic void mtk_star_enable_dma_irq(struct mtk_star_priv *priv,\n\t\t\t\t    bool rx, bool tx)\n{\n\tu32 value;\n\n\tregmap_read(priv->regs, MTK_STAR_REG_INT_MASK, &value);\n\n\tif (tx)\n\t\tvalue &= ~MTK_STAR_BIT_INT_STS_TNTC;\n\tif (rx)\n\t\tvalue &= ~MTK_STAR_BIT_INT_STS_FNRC;\n\n\tregmap_write(priv->regs, MTK_STAR_REG_INT_MASK, value);\n}\n\nstatic void mtk_star_disable_dma_irq(struct mtk_star_priv *priv,\n\t\t\t\t     bool rx, bool tx)\n{\n\tu32 value;\n\n\tregmap_read(priv->regs, MTK_STAR_REG_INT_MASK, &value);\n\n\tif (tx)\n\t\tvalue |= MTK_STAR_BIT_INT_STS_TNTC;\n\tif (rx)\n\t\tvalue |= MTK_STAR_BIT_INT_STS_FNRC;\n\n\tregmap_write(priv->regs, MTK_STAR_REG_INT_MASK, value);\n}\n\n \nstatic void mtk_star_intr_enable(struct mtk_star_priv *priv)\n{\n\tunsigned int val = MTK_STAR_BIT_INT_STS_TNTC |\n\t\t\t   MTK_STAR_BIT_INT_STS_FNRC |\n\t\t\t   MTK_STAR_REG_INT_STS_MIB_CNT_TH;\n\n\tregmap_write(priv->regs, MTK_STAR_REG_INT_MASK, ~val);\n}\n\nstatic void mtk_star_intr_disable(struct mtk_star_priv *priv)\n{\n\tregmap_write(priv->regs, MTK_STAR_REG_INT_MASK, ~0);\n}\n\nstatic unsigned int mtk_star_intr_ack_all(struct mtk_star_priv *priv)\n{\n\tunsigned int val;\n\n\tregmap_read(priv->regs, MTK_STAR_REG_INT_STS, &val);\n\tregmap_write(priv->regs, MTK_STAR_REG_INT_STS, val);\n\n\treturn val;\n}\n\nstatic void mtk_star_dma_init(struct mtk_star_priv *priv)\n{\n\tstruct mtk_star_ring_desc *desc;\n\tunsigned int val;\n\tint i;\n\n\tpriv->descs_base = (struct mtk_star_ring_desc *)priv->ring_base;\n\n\tfor (i = 0; i < MTK_STAR_NUM_DESCS_TOTAL; i++) {\n\t\tdesc = &priv->descs_base[i];\n\n\t\tmemset(desc, 0, sizeof(*desc));\n\t\tdesc->status = MTK_STAR_DESC_BIT_COWN;\n\t\tif ((i == MTK_STAR_NUM_TX_DESCS - 1) ||\n\t\t    (i == MTK_STAR_NUM_DESCS_TOTAL - 1))\n\t\t\tdesc->status |= MTK_STAR_DESC_BIT_EOR;\n\t}\n\n\tmtk_star_ring_init(&priv->tx_ring, priv->descs_base);\n\tmtk_star_ring_init(&priv->rx_ring,\n\t\t\t   priv->descs_base + MTK_STAR_NUM_TX_DESCS);\n\n\t \n\tval = (unsigned int)priv->dma_addr;\n\tregmap_write(priv->regs, MTK_STAR_REG_TX_BASE_ADDR, val);\n\tregmap_write(priv->regs, MTK_STAR_REG_TX_DPTR, val);\n\n\tval += sizeof(struct mtk_star_ring_desc) * MTK_STAR_NUM_TX_DESCS;\n\tregmap_write(priv->regs, MTK_STAR_REG_RX_BASE_ADDR, val);\n\tregmap_write(priv->regs, MTK_STAR_REG_RX_DPTR, val);\n}\n\nstatic void mtk_star_dma_start(struct mtk_star_priv *priv)\n{\n\tregmap_set_bits(priv->regs, MTK_STAR_REG_TX_DMA_CTRL,\n\t\t\tMTK_STAR_BIT_TX_DMA_CTRL_START);\n\tregmap_set_bits(priv->regs, MTK_STAR_REG_RX_DMA_CTRL,\n\t\t\tMTK_STAR_BIT_RX_DMA_CTRL_START);\n}\n\nstatic void mtk_star_dma_stop(struct mtk_star_priv *priv)\n{\n\tregmap_write(priv->regs, MTK_STAR_REG_TX_DMA_CTRL,\n\t\t     MTK_STAR_BIT_TX_DMA_CTRL_STOP);\n\tregmap_write(priv->regs, MTK_STAR_REG_RX_DMA_CTRL,\n\t\t     MTK_STAR_BIT_RX_DMA_CTRL_STOP);\n}\n\nstatic void mtk_star_dma_disable(struct mtk_star_priv *priv)\n{\n\tint i;\n\n\tmtk_star_dma_stop(priv);\n\n\t \n\tfor (i = 0; i < MTK_STAR_NUM_DESCS_TOTAL; i++)\n\t\tpriv->descs_base[i].status |= MTK_STAR_DESC_BIT_COWN;\n}\n\nstatic void mtk_star_dma_resume_rx(struct mtk_star_priv *priv)\n{\n\tregmap_set_bits(priv->regs, MTK_STAR_REG_RX_DMA_CTRL,\n\t\t\tMTK_STAR_BIT_RX_DMA_CTRL_RESUME);\n}\n\nstatic void mtk_star_dma_resume_tx(struct mtk_star_priv *priv)\n{\n\tregmap_set_bits(priv->regs, MTK_STAR_REG_TX_DMA_CTRL,\n\t\t\tMTK_STAR_BIT_TX_DMA_CTRL_RESUME);\n}\n\nstatic void mtk_star_set_mac_addr(struct net_device *ndev)\n{\n\tstruct mtk_star_priv *priv = netdev_priv(ndev);\n\tconst u8 *mac_addr = ndev->dev_addr;\n\tunsigned int high, low;\n\n\thigh = mac_addr[0] << 8 | mac_addr[1] << 0;\n\tlow = mac_addr[2] << 24 | mac_addr[3] << 16 |\n\t      mac_addr[4] << 8 | mac_addr[5];\n\n\tregmap_write(priv->regs, MTK_STAR_REG_MY_MAC_H, high);\n\tregmap_write(priv->regs, MTK_STAR_REG_MY_MAC_L, low);\n}\n\nstatic void mtk_star_reset_counters(struct mtk_star_priv *priv)\n{\n\tstatic const unsigned int counter_regs[] = {\n\t\tMTK_STAR_REG_C_RXOKPKT,\n\t\tMTK_STAR_REG_C_RXOKBYTE,\n\t\tMTK_STAR_REG_C_RXRUNT,\n\t\tMTK_STAR_REG_C_RXLONG,\n\t\tMTK_STAR_REG_C_RXDROP,\n\t\tMTK_STAR_REG_C_RXCRC,\n\t\tMTK_STAR_REG_C_RXARLDROP,\n\t\tMTK_STAR_REG_C_RXVLANDROP,\n\t\tMTK_STAR_REG_C_RXCSERR,\n\t\tMTK_STAR_REG_C_RXPAUSE,\n\t\tMTK_STAR_REG_C_TXOKPKT,\n\t\tMTK_STAR_REG_C_TXOKBYTE,\n\t\tMTK_STAR_REG_C_TXPAUSECOL,\n\t\tMTK_STAR_REG_C_TXRTY,\n\t\tMTK_STAR_REG_C_TXSKIP,\n\t\tMTK_STAR_REG_C_TX_ARP,\n\t\tMTK_STAR_REG_C_RX_RERR,\n\t\tMTK_STAR_REG_C_RX_UNI,\n\t\tMTK_STAR_REG_C_RX_MULTI,\n\t\tMTK_STAR_REG_C_RX_BROAD,\n\t\tMTK_STAR_REG_C_RX_ALIGNERR,\n\t\tMTK_STAR_REG_C_TX_UNI,\n\t\tMTK_STAR_REG_C_TX_MULTI,\n\t\tMTK_STAR_REG_C_TX_BROAD,\n\t\tMTK_STAR_REG_C_TX_TIMEOUT,\n\t\tMTK_STAR_REG_C_TX_LATECOL,\n\t\tMTK_STAR_REG_C_RX_LENGTHERR,\n\t\tMTK_STAR_REG_C_RX_TWIST,\n\t};\n\n\tunsigned int i, val;\n\n\tfor (i = 0; i < ARRAY_SIZE(counter_regs); i++)\n\t\tregmap_read(priv->regs, counter_regs[i], &val);\n}\n\nstatic void mtk_star_update_stat(struct mtk_star_priv *priv,\n\t\t\t\t unsigned int reg, u64 *stat)\n{\n\tunsigned int val;\n\n\tregmap_read(priv->regs, reg, &val);\n\t*stat += val;\n}\n\n \nstatic void mtk_star_update_stats(struct mtk_star_priv *priv)\n{\n\tstruct rtnl_link_stats64 *stats = &priv->stats;\n\n\t \n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_RXOKPKT, &stats->rx_packets);\n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_TXOKPKT, &stats->tx_packets);\n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_RXOKBYTE, &stats->rx_bytes);\n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_TXOKBYTE, &stats->tx_bytes);\n\n\t \n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_RX_MULTI, &stats->multicast);\n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_TX_MULTI, &stats->multicast);\n\n\t \n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_TXPAUSECOL,\n\t\t\t     &stats->collisions);\n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_TX_LATECOL,\n\t\t\t     &stats->collisions);\n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_RXRUNT, &stats->collisions);\n\n\t \n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_RX_LENGTHERR,\n\t\t\t     &stats->rx_length_errors);\n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_RXLONG,\n\t\t\t     &stats->rx_over_errors);\n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_RXCRC, &stats->rx_crc_errors);\n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_RX_ALIGNERR,\n\t\t\t     &stats->rx_frame_errors);\n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_RXDROP,\n\t\t\t     &stats->rx_fifo_errors);\n\t \n\tmtk_star_update_stat(priv, MTK_STAR_REG_C_RX_RERR, &stats->rx_errors);\n\tstats->rx_errors += stats->rx_length_errors;\n\tstats->rx_errors += stats->rx_over_errors;\n\tstats->rx_errors += stats->rx_crc_errors;\n\tstats->rx_errors += stats->rx_frame_errors;\n\tstats->rx_errors += stats->rx_fifo_errors;\n}\n\nstatic struct sk_buff *mtk_star_alloc_skb(struct net_device *ndev)\n{\n\tuintptr_t tail, offset;\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(MTK_STAR_MAX_FRAME_SIZE);\n\tif (!skb)\n\t\treturn NULL;\n\n\t \n\ttail = (uintptr_t)skb_tail_pointer(skb);\n\tif (tail & (MTK_STAR_SKB_ALIGNMENT - 1)) {\n\t\toffset = tail & (MTK_STAR_SKB_ALIGNMENT - 1);\n\t\tskb_reserve(skb, MTK_STAR_SKB_ALIGNMENT - offset);\n\t}\n\n\t \n\tskb_reserve(skb, MTK_STAR_IP_ALIGN);\n\n\treturn skb;\n}\n\nstatic int mtk_star_prepare_rx_skbs(struct net_device *ndev)\n{\n\tstruct mtk_star_priv *priv = netdev_priv(ndev);\n\tstruct mtk_star_ring *ring = &priv->rx_ring;\n\tstruct device *dev = mtk_star_get_dev(priv);\n\tstruct mtk_star_ring_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t dma_addr;\n\tint i;\n\n\tfor (i = 0; i < MTK_STAR_NUM_RX_DESCS; i++) {\n\t\tskb = mtk_star_alloc_skb(ndev);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tdma_addr = mtk_star_dma_map_rx(priv, skb);\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdesc = &ring->descs[i];\n\t\tdesc->data_ptr = dma_addr;\n\t\tdesc->status |= skb_tailroom(skb) & MTK_STAR_DESC_MSK_LEN;\n\t\tdesc->status &= ~MTK_STAR_DESC_BIT_COWN;\n\t\tring->skbs[i] = skb;\n\t\tring->dma_addrs[i] = dma_addr;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nmtk_star_ring_free_skbs(struct mtk_star_priv *priv, struct mtk_star_ring *ring,\n\t\t\tvoid (*unmap_func)(struct mtk_star_priv *,\n\t\t\t\t\t   struct mtk_star_ring_desc_data *))\n{\n\tstruct mtk_star_ring_desc_data desc_data;\n\tint i;\n\n\tfor (i = 0; i < MTK_STAR_RING_NUM_DESCS; i++) {\n\t\tif (!ring->dma_addrs[i])\n\t\t\tcontinue;\n\n\t\tdesc_data.dma_addr = ring->dma_addrs[i];\n\t\tdesc_data.skb = ring->skbs[i];\n\n\t\tunmap_func(priv, &desc_data);\n\t\tdev_kfree_skb(desc_data.skb);\n\t}\n}\n\nstatic void mtk_star_free_rx_skbs(struct mtk_star_priv *priv)\n{\n\tstruct mtk_star_ring *ring = &priv->rx_ring;\n\n\tmtk_star_ring_free_skbs(priv, ring, mtk_star_dma_unmap_rx);\n}\n\nstatic void mtk_star_free_tx_skbs(struct mtk_star_priv *priv)\n{\n\tstruct mtk_star_ring *ring = &priv->tx_ring;\n\n\tmtk_star_ring_free_skbs(priv, ring, mtk_star_dma_unmap_tx);\n}\n\n \nstatic irqreturn_t mtk_star_handle_irq(int irq, void *data)\n{\n\tstruct net_device *ndev = data;\n\tstruct mtk_star_priv *priv = netdev_priv(ndev);\n\tunsigned int intr_status = mtk_star_intr_ack_all(priv);\n\tbool rx, tx;\n\n\trx = (intr_status & MTK_STAR_BIT_INT_STS_FNRC) &&\n\t     napi_schedule_prep(&priv->rx_napi);\n\ttx = (intr_status & MTK_STAR_BIT_INT_STS_TNTC) &&\n\t     napi_schedule_prep(&priv->tx_napi);\n\n\tif (rx || tx) {\n\t\tspin_lock(&priv->lock);\n\t\t \n\t\tmtk_star_disable_dma_irq(priv, rx, tx);\n\t\tspin_unlock(&priv->lock);\n\n\t\tif (rx)\n\t\t\t__napi_schedule(&priv->rx_napi);\n\t\tif (tx)\n\t\t\t__napi_schedule(&priv->tx_napi);\n\t}\n\n\t \n\tif (intr_status & MTK_STAR_REG_INT_STS_MIB_CNT_TH) {\n\t\tmtk_star_update_stats(priv);\n\t\tmtk_star_reset_counters(priv);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int mtk_star_hash_wait_cmd_start(struct mtk_star_priv *priv)\n{\n\tunsigned int val;\n\n\treturn regmap_read_poll_timeout_atomic(priv->regs,\n\t\t\t\tMTK_STAR_REG_HASH_CTRL, val,\n\t\t\t\t!(val & MTK_STAR_BIT_HASH_CTRL_CMD_START),\n\t\t\t\t10, MTK_STAR_WAIT_TIMEOUT);\n}\n\nstatic int mtk_star_hash_wait_ok(struct mtk_star_priv *priv)\n{\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_read_poll_timeout_atomic(priv->regs,\n\t\t\t\t\tMTK_STAR_REG_HASH_CTRL, val,\n\t\t\t\t\tval & MTK_STAR_BIT_HASH_CTRL_BIST_DONE,\n\t\t\t\t\t10, MTK_STAR_WAIT_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!regmap_test_bits(priv->regs, MTK_STAR_REG_HASH_CTRL,\n\t\t\t      MTK_STAR_BIT_HASH_CTRL_BIST_OK))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int mtk_star_set_hashbit(struct mtk_star_priv *priv,\n\t\t\t\tunsigned int hash_addr)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = mtk_star_hash_wait_cmd_start(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tval = hash_addr & MTK_STAR_MSK_HASH_CTRL_HASH_BIT_ADDR;\n\tval |= MTK_STAR_BIT_HASH_CTRL_ACC_CMD;\n\tval |= MTK_STAR_BIT_HASH_CTRL_CMD_START;\n\tval |= MTK_STAR_BIT_HASH_CTRL_BIST_EN;\n\tval |= MTK_STAR_BIT_HASH_CTRL_HASH_BIT_DATA;\n\tregmap_write(priv->regs, MTK_STAR_REG_HASH_CTRL, val);\n\n\treturn mtk_star_hash_wait_ok(priv);\n}\n\nstatic int mtk_star_reset_hash_table(struct mtk_star_priv *priv)\n{\n\tint ret;\n\n\tret = mtk_star_hash_wait_cmd_start(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_set_bits(priv->regs, MTK_STAR_REG_HASH_CTRL,\n\t\t\tMTK_STAR_BIT_HASH_CTRL_BIST_EN);\n\tregmap_set_bits(priv->regs, MTK_STAR_REG_TEST1,\n\t\t\tMTK_STAR_BIT_TEST1_RST_HASH_MBIST);\n\n\treturn mtk_star_hash_wait_ok(priv);\n}\n\nstatic void mtk_star_phy_config(struct mtk_star_priv *priv)\n{\n\tunsigned int val;\n\n\tif (priv->speed == SPEED_1000)\n\t\tval = MTK_STAR_VAL_PHY_CTRL1_FORCE_SPD_1000M;\n\telse if (priv->speed == SPEED_100)\n\t\tval = MTK_STAR_VAL_PHY_CTRL1_FORCE_SPD_100M;\n\telse\n\t\tval = MTK_STAR_VAL_PHY_CTRL1_FORCE_SPD_10M;\n\tval <<= MTK_STAR_OFF_PHY_CTRL1_FORCE_SPD;\n\n\tval |= MTK_STAR_BIT_PHY_CTRL1_AN_EN;\n\tif (priv->pause) {\n\t\tval |= MTK_STAR_BIT_PHY_CTRL1_FORCE_FC_RX;\n\t\tval |= MTK_STAR_BIT_PHY_CTRL1_FORCE_FC_TX;\n\t\tval |= MTK_STAR_BIT_PHY_CTRL1_FORCE_DPX;\n\t} else {\n\t\tval &= ~MTK_STAR_BIT_PHY_CTRL1_FORCE_FC_RX;\n\t\tval &= ~MTK_STAR_BIT_PHY_CTRL1_FORCE_FC_TX;\n\t\tval &= ~MTK_STAR_BIT_PHY_CTRL1_FORCE_DPX;\n\t}\n\tregmap_write(priv->regs, MTK_STAR_REG_PHY_CTRL1, val);\n\n\tval = MTK_STAR_VAL_FC_CFG_SEND_PAUSE_TH_2K;\n\tval <<= MTK_STAR_OFF_FC_CFG_SEND_PAUSE_TH;\n\tval |= MTK_STAR_BIT_FC_CFG_UC_PAUSE_DIR;\n\tregmap_update_bits(priv->regs, MTK_STAR_REG_FC_CFG,\n\t\t\t   MTK_STAR_MSK_FC_CFG_SEND_PAUSE_TH |\n\t\t\t   MTK_STAR_BIT_FC_CFG_UC_PAUSE_DIR, val);\n\n\tval = MTK_STAR_VAL_EXT_CFG_SND_PAUSE_RLS_1K;\n\tval <<= MTK_STAR_OFF_EXT_CFG_SND_PAUSE_RLS;\n\tregmap_update_bits(priv->regs, MTK_STAR_REG_EXT_CFG,\n\t\t\t   MTK_STAR_MSK_EXT_CFG_SND_PAUSE_RLS, val);\n}\n\nstatic void mtk_star_adjust_link(struct net_device *ndev)\n{\n\tstruct mtk_star_priv *priv = netdev_priv(ndev);\n\tstruct phy_device *phydev = priv->phydev;\n\tbool new_state = false;\n\n\tif (phydev->link) {\n\t\tif (!priv->link) {\n\t\t\tpriv->link = phydev->link;\n\t\t\tnew_state = true;\n\t\t}\n\n\t\tif (priv->speed != phydev->speed) {\n\t\t\tpriv->speed = phydev->speed;\n\t\t\tnew_state = true;\n\t\t}\n\n\t\tif (priv->pause != phydev->pause) {\n\t\t\tpriv->pause = phydev->pause;\n\t\t\tnew_state = true;\n\t\t}\n\t} else {\n\t\tif (priv->link) {\n\t\t\tpriv->link = phydev->link;\n\t\t\tnew_state = true;\n\t\t}\n\t}\n\n\tif (new_state) {\n\t\tif (phydev->link)\n\t\t\tmtk_star_phy_config(priv);\n\n\t\tphy_print_status(ndev->phydev);\n\t}\n}\n\nstatic void mtk_star_init_config(struct mtk_star_priv *priv)\n{\n\tunsigned int val;\n\n\tval = (MTK_STAR_BIT_MII_PAD_OUT_ENABLE |\n\t       MTK_STAR_BIT_EXT_MDC_MODE |\n\t       MTK_STAR_BIT_SWC_MII_MODE);\n\n\tregmap_write(priv->regs, MTK_STAR_REG_SYS_CONF, val);\n\tregmap_update_bits(priv->regs, MTK_STAR_REG_MAC_CLK_CONF,\n\t\t\t   MTK_STAR_MSK_MAC_CLK_CONF,\n\t\t\t   priv->compat_data->bit_clk_div);\n}\n\nstatic int mtk_star_enable(struct net_device *ndev)\n{\n\tstruct mtk_star_priv *priv = netdev_priv(ndev);\n\tunsigned int val;\n\tint ret;\n\n\tmtk_star_nic_disable_pd(priv);\n\tmtk_star_intr_disable(priv);\n\tmtk_star_dma_stop(priv);\n\n\tmtk_star_set_mac_addr(ndev);\n\n\t \n\tval = MTK_STAR_VAL_MAC_CFG_IPG_96BIT;\n\tval <<= MTK_STAR_OFF_MAC_CFG_IPG;\n\tval |= MTK_STAR_BIT_MAC_CFG_MAXLEN_1522;\n\tval |= MTK_STAR_BIT_MAC_CFG_AUTO_PAD;\n\tval |= MTK_STAR_BIT_MAC_CFG_CRC_STRIP;\n\tregmap_write(priv->regs, MTK_STAR_REG_MAC_CFG, val);\n\n\t \n\tret = mtk_star_reset_hash_table(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_clear_bits(priv->regs, MTK_STAR_REG_ARL_CFG,\n\t\t\t  MTK_STAR_BIT_ARL_CFG_HASH_ALG |\n\t\t\t  MTK_STAR_BIT_ARL_CFG_MISC_MODE);\n\n\t \n\tregmap_clear_bits(priv->regs, MTK_STAR_REG_MAC_CFG,\n\t\t\t  MTK_STAR_BIT_MAC_CFG_VLAN_STRIP);\n\n\t \n\tmtk_star_dma_init(priv);\n\n\tret = mtk_star_prepare_rx_skbs(ndev);\n\tif (ret)\n\t\tgoto err_out;\n\n\t \n\tret = request_irq(ndev->irq, mtk_star_handle_irq,\n\t\t\t  IRQF_TRIGGER_NONE, ndev->name, ndev);\n\tif (ret)\n\t\tgoto err_free_skbs;\n\n\tnapi_enable(&priv->tx_napi);\n\tnapi_enable(&priv->rx_napi);\n\n\tmtk_star_intr_ack_all(priv);\n\tmtk_star_intr_enable(priv);\n\n\t \n\tpriv->phydev = of_phy_connect(ndev, priv->phy_node,\n\t\t\t\t      mtk_star_adjust_link, 0, priv->phy_intf);\n\tif (!priv->phydev) {\n\t\tnetdev_err(ndev, \"failed to connect to PHY\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_free_irq;\n\t}\n\n\tmtk_star_dma_start(priv);\n\tphy_start(priv->phydev);\n\tnetif_start_queue(ndev);\n\n\treturn 0;\n\nerr_free_irq:\n\tnapi_disable(&priv->rx_napi);\n\tnapi_disable(&priv->tx_napi);\n\tfree_irq(ndev->irq, ndev);\nerr_free_skbs:\n\tmtk_star_free_rx_skbs(priv);\nerr_out:\n\treturn ret;\n}\n\nstatic void mtk_star_disable(struct net_device *ndev)\n{\n\tstruct mtk_star_priv *priv = netdev_priv(ndev);\n\n\tnetif_stop_queue(ndev);\n\tnapi_disable(&priv->tx_napi);\n\tnapi_disable(&priv->rx_napi);\n\tmtk_star_intr_disable(priv);\n\tmtk_star_dma_disable(priv);\n\tmtk_star_intr_ack_all(priv);\n\tphy_stop(priv->phydev);\n\tphy_disconnect(priv->phydev);\n\tfree_irq(ndev->irq, ndev);\n\tmtk_star_free_rx_skbs(priv);\n\tmtk_star_free_tx_skbs(priv);\n}\n\nstatic int mtk_star_netdev_open(struct net_device *ndev)\n{\n\treturn mtk_star_enable(ndev);\n}\n\nstatic int mtk_star_netdev_stop(struct net_device *ndev)\n{\n\tmtk_star_disable(ndev);\n\n\treturn 0;\n}\n\nstatic int mtk_star_netdev_ioctl(struct net_device *ndev,\n\t\t\t\t struct ifreq *req, int cmd)\n{\n\tif (!netif_running(ndev))\n\t\treturn -EINVAL;\n\n\treturn phy_mii_ioctl(ndev->phydev, req, cmd);\n}\n\nstatic int __mtk_star_maybe_stop_tx(struct mtk_star_priv *priv, u16 size)\n{\n\tnetif_stop_queue(priv->ndev);\n\n\t \n\tsmp_mb();\n\tif (likely(mtk_star_tx_ring_avail(&priv->tx_ring) < size))\n\t\treturn -EBUSY;\n\n\tnetif_start_queue(priv->ndev);\n\n\treturn 0;\n}\n\nstatic inline int mtk_star_maybe_stop_tx(struct mtk_star_priv *priv, u16 size)\n{\n\tif (likely(mtk_star_tx_ring_avail(&priv->tx_ring) >= size))\n\t\treturn 0;\n\n\treturn __mtk_star_maybe_stop_tx(priv, size);\n}\n\nstatic netdev_tx_t mtk_star_netdev_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t      struct net_device *ndev)\n{\n\tstruct mtk_star_priv *priv = netdev_priv(ndev);\n\tstruct mtk_star_ring *ring = &priv->tx_ring;\n\tstruct device *dev = mtk_star_get_dev(priv);\n\tstruct mtk_star_ring_desc_data desc_data;\n\tint nfrags = skb_shinfo(skb)->nr_frags;\n\n\tif (unlikely(mtk_star_tx_ring_avail(ring) < nfrags + 1)) {\n\t\tif (!netif_queue_stopped(ndev)) {\n\t\t\tnetif_stop_queue(ndev);\n\t\t\t \n\t\t\tpr_err_ratelimited(\"Tx ring full when queue awake\\n\");\n\t\t}\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tdesc_data.dma_addr = mtk_star_dma_map_tx(priv, skb);\n\tif (dma_mapping_error(dev, desc_data.dma_addr))\n\t\tgoto err_drop_packet;\n\n\tdesc_data.skb = skb;\n\tdesc_data.len = skb->len;\n\tmtk_star_ring_push_head_tx(ring, &desc_data);\n\n\tnetdev_sent_queue(ndev, skb->len);\n\n\tmtk_star_maybe_stop_tx(priv, MTK_STAR_DESC_NEEDED);\n\n\tmtk_star_dma_resume_tx(priv);\n\n\treturn NETDEV_TX_OK;\n\nerr_drop_packet:\n\tdev_kfree_skb(skb);\n\tndev->stats.tx_dropped++;\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic int mtk_star_tx_complete_one(struct mtk_star_priv *priv)\n{\n\tstruct mtk_star_ring *ring = &priv->tx_ring;\n\tstruct mtk_star_ring_desc_data desc_data;\n\tint ret;\n\n\tret = mtk_star_ring_pop_tail(ring, &desc_data);\n\tif (ret)\n\t\treturn ret;\n\n\tmtk_star_dma_unmap_tx(priv, &desc_data);\n\tret = desc_data.skb->len;\n\tdev_kfree_skb_irq(desc_data.skb);\n\n\treturn ret;\n}\n\nstatic int mtk_star_tx_poll(struct napi_struct *napi, int budget)\n{\n\tstruct mtk_star_priv *priv = container_of(napi, struct mtk_star_priv,\n\t\t\t\t\t\t  tx_napi);\n\tint ret = 0, pkts_compl = 0, bytes_compl = 0, count = 0;\n\tstruct mtk_star_ring *ring = &priv->tx_ring;\n\tstruct net_device *ndev = priv->ndev;\n\tunsigned int head = ring->head;\n\tunsigned int entry = ring->tail;\n\n\twhile (entry != head && count < (MTK_STAR_RING_NUM_DESCS - 1)) {\n\t\tret = mtk_star_tx_complete_one(priv);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tcount++;\n\t\tpkts_compl++;\n\t\tbytes_compl += ret;\n\t\tentry = ring->tail;\n\t}\n\n\tnetdev_completed_queue(ndev, pkts_compl, bytes_compl);\n\n\tif (unlikely(netif_queue_stopped(ndev)) &&\n\t    (mtk_star_tx_ring_avail(ring) > MTK_STAR_TX_THRESH))\n\t\tnetif_wake_queue(ndev);\n\n\tif (napi_complete(napi)) {\n\t\tspin_lock(&priv->lock);\n\t\tmtk_star_enable_dma_irq(priv, false, true);\n\t\tspin_unlock(&priv->lock);\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_star_netdev_get_stats64(struct net_device *ndev,\n\t\t\t\t\tstruct rtnl_link_stats64 *stats)\n{\n\tstruct mtk_star_priv *priv = netdev_priv(ndev);\n\n\tmtk_star_update_stats(priv);\n\n\tmemcpy(stats, &priv->stats, sizeof(*stats));\n}\n\nstatic void mtk_star_set_rx_mode(struct net_device *ndev)\n{\n\tstruct mtk_star_priv *priv = netdev_priv(ndev);\n\tstruct netdev_hw_addr *hw_addr;\n\tunsigned int hash_addr, i;\n\tint ret;\n\n\tif (ndev->flags & IFF_PROMISC) {\n\t\tregmap_set_bits(priv->regs, MTK_STAR_REG_ARL_CFG,\n\t\t\t\tMTK_STAR_BIT_ARL_CFG_MISC_MODE);\n\t} else if (netdev_mc_count(ndev) > MTK_STAR_HASHTABLE_MC_LIMIT ||\n\t\t   ndev->flags & IFF_ALLMULTI) {\n\t\tfor (i = 0; i < MTK_STAR_HASHTABLE_SIZE_MAX; i++) {\n\t\t\tret = mtk_star_set_hashbit(priv, i);\n\t\t\tif (ret)\n\t\t\t\tgoto hash_fail;\n\t\t}\n\t} else {\n\t\t \n\t\tret = mtk_star_reset_hash_table(priv);\n\t\tif (ret)\n\t\t\tgoto hash_fail;\n\n\t\tnetdev_for_each_mc_addr(hw_addr, ndev) {\n\t\t\thash_addr = (hw_addr->addr[0] & 0x01) << 8;\n\t\t\thash_addr += hw_addr->addr[5];\n\t\t\tret = mtk_star_set_hashbit(priv, hash_addr);\n\t\t\tif (ret)\n\t\t\t\tgoto hash_fail;\n\t\t}\n\t}\n\n\treturn;\n\nhash_fail:\n\tif (ret == -ETIMEDOUT)\n\t\tnetdev_err(ndev, \"setting hash bit timed out\\n\");\n\telse\n\t\t \n\t\tnetdev_err(ndev, \"unable to set hash bit\");\n}\n\nstatic const struct net_device_ops mtk_star_netdev_ops = {\n\t.ndo_open\t\t= mtk_star_netdev_open,\n\t.ndo_stop\t\t= mtk_star_netdev_stop,\n\t.ndo_start_xmit\t\t= mtk_star_netdev_start_xmit,\n\t.ndo_get_stats64\t= mtk_star_netdev_get_stats64,\n\t.ndo_set_rx_mode\t= mtk_star_set_rx_mode,\n\t.ndo_eth_ioctl\t\t= mtk_star_netdev_ioctl,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic void mtk_star_get_drvinfo(struct net_device *dev,\n\t\t\t\t struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, MTK_STAR_DRVNAME, sizeof(info->driver));\n}\n\n \nstatic const struct ethtool_ops mtk_star_ethtool_ops = {\n\t.get_drvinfo\t\t= mtk_star_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_link_ksettings\t= phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= phy_ethtool_set_link_ksettings,\n};\n\nstatic int mtk_star_rx(struct mtk_star_priv *priv, int budget)\n{\n\tstruct mtk_star_ring *ring = &priv->rx_ring;\n\tstruct device *dev = mtk_star_get_dev(priv);\n\tstruct mtk_star_ring_desc_data desc_data;\n\tstruct net_device *ndev = priv->ndev;\n\tstruct sk_buff *curr_skb, *new_skb;\n\tdma_addr_t new_dma_addr;\n\tint ret, count = 0;\n\n\twhile (count < budget) {\n\t\tret = mtk_star_ring_pop_tail(ring, &desc_data);\n\t\tif (ret)\n\t\t\treturn -1;\n\n\t\tcurr_skb = desc_data.skb;\n\n\t\tif ((desc_data.flags & MTK_STAR_DESC_BIT_RX_CRCE) ||\n\t\t    (desc_data.flags & MTK_STAR_DESC_BIT_RX_OSIZE)) {\n\t\t\t \n\t\t\tnew_skb = curr_skb;\n\t\t\tgoto push_new_skb;\n\t\t}\n\n\t\t \n\t\tnew_skb = mtk_star_alloc_skb(ndev);\n\t\tif (!new_skb) {\n\t\t\tndev->stats.rx_dropped++;\n\t\t\tnew_skb = curr_skb;\n\t\t\tgoto push_new_skb;\n\t\t}\n\n\t\tnew_dma_addr = mtk_star_dma_map_rx(priv, new_skb);\n\t\tif (dma_mapping_error(dev, new_dma_addr)) {\n\t\t\tndev->stats.rx_dropped++;\n\t\t\tdev_kfree_skb(new_skb);\n\t\t\tnew_skb = curr_skb;\n\t\t\tnetdev_err(ndev, \"DMA mapping error of RX descriptor\\n\");\n\t\t\tgoto push_new_skb;\n\t\t}\n\n\t\t \n\t\tmtk_star_dma_unmap_rx(priv, &desc_data);\n\n\t\tskb_put(desc_data.skb, desc_data.len);\n\t\tdesc_data.skb->ip_summed = CHECKSUM_NONE;\n\t\tdesc_data.skb->protocol = eth_type_trans(desc_data.skb, ndev);\n\t\tdesc_data.skb->dev = ndev;\n\t\tnetif_receive_skb(desc_data.skb);\n\n\t\t \n\t\tdesc_data.dma_addr = new_dma_addr;\n\npush_new_skb:\n\n\t\tcount++;\n\n\t\tdesc_data.len = skb_tailroom(new_skb);\n\t\tdesc_data.skb = new_skb;\n\t\tmtk_star_ring_push_head_rx(ring, &desc_data);\n\t}\n\n\tmtk_star_dma_resume_rx(priv);\n\n\treturn count;\n}\n\nstatic int mtk_star_rx_poll(struct napi_struct *napi, int budget)\n{\n\tstruct mtk_star_priv *priv;\n\tint work_done = 0;\n\n\tpriv = container_of(napi, struct mtk_star_priv, rx_napi);\n\n\twork_done = mtk_star_rx(priv, budget);\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tspin_lock(&priv->lock);\n\t\tmtk_star_enable_dma_irq(priv, true, false);\n\t\tspin_unlock(&priv->lock);\n\t}\n\n\treturn work_done;\n}\n\nstatic void mtk_star_mdio_rwok_clear(struct mtk_star_priv *priv)\n{\n\tregmap_write(priv->regs, MTK_STAR_REG_PHY_CTRL0,\n\t\t     MTK_STAR_BIT_PHY_CTRL0_RWOK);\n}\n\nstatic int mtk_star_mdio_rwok_wait(struct mtk_star_priv *priv)\n{\n\tunsigned int val;\n\n\treturn regmap_read_poll_timeout(priv->regs, MTK_STAR_REG_PHY_CTRL0,\n\t\t\t\t\tval, val & MTK_STAR_BIT_PHY_CTRL0_RWOK,\n\t\t\t\t\t10, MTK_STAR_WAIT_TIMEOUT);\n}\n\nstatic int mtk_star_mdio_read(struct mii_bus *mii, int phy_id, int regnum)\n{\n\tstruct mtk_star_priv *priv = mii->priv;\n\tunsigned int val, data;\n\tint ret;\n\n\tmtk_star_mdio_rwok_clear(priv);\n\n\tval = (regnum << MTK_STAR_OFF_PHY_CTRL0_PREG);\n\tval &= MTK_STAR_MSK_PHY_CTRL0_PREG;\n\tval |= MTK_STAR_BIT_PHY_CTRL0_RDCMD;\n\n\tregmap_write(priv->regs, MTK_STAR_REG_PHY_CTRL0, val);\n\n\tret = mtk_star_mdio_rwok_wait(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_read(priv->regs, MTK_STAR_REG_PHY_CTRL0, &data);\n\n\tdata &= MTK_STAR_MSK_PHY_CTRL0_RWDATA;\n\tdata >>= MTK_STAR_OFF_PHY_CTRL0_RWDATA;\n\n\treturn data;\n}\n\nstatic int mtk_star_mdio_write(struct mii_bus *mii, int phy_id,\n\t\t\t       int regnum, u16 data)\n{\n\tstruct mtk_star_priv *priv = mii->priv;\n\tunsigned int val;\n\n\tmtk_star_mdio_rwok_clear(priv);\n\n\tval = data;\n\tval <<= MTK_STAR_OFF_PHY_CTRL0_RWDATA;\n\tval &= MTK_STAR_MSK_PHY_CTRL0_RWDATA;\n\tregnum <<= MTK_STAR_OFF_PHY_CTRL0_PREG;\n\tregnum &= MTK_STAR_MSK_PHY_CTRL0_PREG;\n\tval |= regnum;\n\tval |= MTK_STAR_BIT_PHY_CTRL0_WTCMD;\n\n\tregmap_write(priv->regs, MTK_STAR_REG_PHY_CTRL0, val);\n\n\treturn mtk_star_mdio_rwok_wait(priv);\n}\n\nstatic int mtk_star_mdio_init(struct net_device *ndev)\n{\n\tstruct mtk_star_priv *priv = netdev_priv(ndev);\n\tstruct device *dev = mtk_star_get_dev(priv);\n\tstruct device_node *of_node, *mdio_node;\n\tint ret;\n\n\tof_node = dev->of_node;\n\n\tmdio_node = of_get_child_by_name(of_node, \"mdio\");\n\tif (!mdio_node)\n\t\treturn -ENODEV;\n\n\tif (!of_device_is_available(mdio_node)) {\n\t\tret = -ENODEV;\n\t\tgoto out_put_node;\n\t}\n\n\tpriv->mii = devm_mdiobus_alloc(dev);\n\tif (!priv->mii) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put_node;\n\t}\n\n\tsnprintf(priv->mii->id, MII_BUS_ID_SIZE, \"%s\", dev_name(dev));\n\tpriv->mii->name = \"mtk-mac-mdio\";\n\tpriv->mii->parent = dev;\n\tpriv->mii->read = mtk_star_mdio_read;\n\tpriv->mii->write = mtk_star_mdio_write;\n\tpriv->mii->priv = priv;\n\n\tret = devm_of_mdiobus_register(dev, priv->mii, mdio_node);\n\nout_put_node:\n\tof_node_put(mdio_node);\n\treturn ret;\n}\n\nstatic __maybe_unused int mtk_star_suspend(struct device *dev)\n{\n\tstruct mtk_star_priv *priv;\n\tstruct net_device *ndev;\n\n\tndev = dev_get_drvdata(dev);\n\tpriv = netdev_priv(ndev);\n\n\tif (netif_running(ndev))\n\t\tmtk_star_disable(ndev);\n\n\tclk_bulk_disable_unprepare(MTK_STAR_NCLKS, priv->clks);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int mtk_star_resume(struct device *dev)\n{\n\tstruct mtk_star_priv *priv;\n\tstruct net_device *ndev;\n\tint ret;\n\n\tndev = dev_get_drvdata(dev);\n\tpriv = netdev_priv(ndev);\n\n\tret = clk_bulk_prepare_enable(MTK_STAR_NCLKS, priv->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tif (netif_running(ndev)) {\n\t\tret = mtk_star_enable(ndev);\n\t\tif (ret)\n\t\t\tclk_bulk_disable_unprepare(MTK_STAR_NCLKS, priv->clks);\n\t}\n\n\treturn ret;\n}\n\nstatic void mtk_star_clk_disable_unprepare(void *data)\n{\n\tstruct mtk_star_priv *priv = data;\n\n\tclk_bulk_disable_unprepare(MTK_STAR_NCLKS, priv->clks);\n}\n\nstatic int mtk_star_set_timing(struct mtk_star_priv *priv)\n{\n\tstruct device *dev = mtk_star_get_dev(priv);\n\tunsigned int delay_val = 0;\n\n\tswitch (priv->phy_intf) {\n\tcase PHY_INTERFACE_MODE_MII:\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tdelay_val |= FIELD_PREP(MTK_STAR_BIT_INV_RX_CLK, priv->rx_inv);\n\t\tdelay_val |= FIELD_PREP(MTK_STAR_BIT_INV_TX_CLK, priv->tx_inv);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"This interface not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_write(priv->regs, MTK_STAR_REG_TEST0, delay_val);\n}\n\nstatic int mtk_star_probe(struct platform_device *pdev)\n{\n\tstruct device_node *of_node;\n\tstruct mtk_star_priv *priv;\n\tstruct net_device *ndev;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tint ret, i;\n\n\tdev = &pdev->dev;\n\tof_node = dev->of_node;\n\n\tndev = devm_alloc_etherdev(dev, sizeof(*priv));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tpriv = netdev_priv(ndev);\n\tpriv->ndev = ndev;\n\tpriv->compat_data = of_device_get_match_data(&pdev->dev);\n\tSET_NETDEV_DEV(ndev, dev);\n\tplatform_set_drvdata(pdev, ndev);\n\n\tndev->min_mtu = ETH_ZLEN;\n\tndev->max_mtu = MTK_STAR_MAX_FRAME_SIZE;\n\n\tspin_lock_init(&priv->lock);\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\t \n\tpriv->regs = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t   &mtk_star_regmap_config);\n\tif (IS_ERR(priv->regs))\n\t\treturn PTR_ERR(priv->regs);\n\n\tpriv->pericfg = syscon_regmap_lookup_by_phandle(of_node,\n\t\t\t\t\t\t\t\"mediatek,pericfg\");\n\tif (IS_ERR(priv->pericfg)) {\n\t\tdev_err(dev, \"Failed to lookup the PERICFG syscon\\n\");\n\t\treturn PTR_ERR(priv->pericfg);\n\t}\n\n\tndev->irq = platform_get_irq(pdev, 0);\n\tif (ndev->irq < 0)\n\t\treturn ndev->irq;\n\n\tfor (i = 0; i < MTK_STAR_NCLKS; i++)\n\t\tpriv->clks[i].id = mtk_star_clk_names[i];\n\tret = devm_clk_bulk_get(dev, MTK_STAR_NCLKS, priv->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_bulk_prepare_enable(MTK_STAR_NCLKS, priv->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev,\n\t\t\t\t       mtk_star_clk_disable_unprepare, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_get_phy_mode(of_node, &priv->phy_intf);\n\tif (ret) {\n\t\treturn ret;\n\t} else if (priv->phy_intf != PHY_INTERFACE_MODE_RMII &&\n\t\t   priv->phy_intf != PHY_INTERFACE_MODE_MII) {\n\t\tdev_err(dev, \"unsupported phy mode: %s\\n\",\n\t\t\tphy_modes(priv->phy_intf));\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->phy_node = of_parse_phandle(of_node, \"phy-handle\", 0);\n\tif (!priv->phy_node) {\n\t\tdev_err(dev, \"failed to retrieve the phy handle from device tree\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->rmii_rxc = of_property_read_bool(of_node, \"mediatek,rmii-rxc\");\n\tpriv->rx_inv = of_property_read_bool(of_node, \"mediatek,rxc-inverse\");\n\tpriv->tx_inv = of_property_read_bool(of_node, \"mediatek,txc-inverse\");\n\n\tif (priv->compat_data->set_interface_mode) {\n\t\tret = priv->compat_data->set_interface_mode(ndev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to set phy interface, err = %d\\n\", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = mtk_star_set_timing(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set timing, err = %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(dev, \"unsupported DMA mask\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->ring_base = dmam_alloc_coherent(dev, MTK_STAR_DMA_SIZE,\n\t\t\t\t\t      &priv->dma_addr,\n\t\t\t\t\t      GFP_KERNEL | GFP_DMA);\n\tif (!priv->ring_base)\n\t\treturn -ENOMEM;\n\n\tmtk_star_nic_disable_pd(priv);\n\tmtk_star_init_config(priv);\n\n\tret = mtk_star_mdio_init(ndev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_get_ethdev_address(dev, ndev);\n\tif (ret || !is_valid_ether_addr(ndev->dev_addr))\n\t\teth_hw_addr_random(ndev);\n\n\tndev->netdev_ops = &mtk_star_netdev_ops;\n\tndev->ethtool_ops = &mtk_star_ethtool_ops;\n\n\tnetif_napi_add(ndev, &priv->rx_napi, mtk_star_rx_poll);\n\tnetif_napi_add_tx(ndev, &priv->tx_napi, mtk_star_tx_poll);\n\n\treturn devm_register_netdev(dev, ndev);\n}\n\n#ifdef CONFIG_OF\nstatic int mt8516_set_interface_mode(struct net_device *ndev)\n{\n\tstruct mtk_star_priv *priv = netdev_priv(ndev);\n\tstruct device *dev = mtk_star_get_dev(priv);\n\tunsigned int intf_val, ret, rmii_rxc;\n\n\tswitch (priv->phy_intf) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tintf_val = MTK_PERICFG_BIT_NIC_CFG_CON_MII;\n\t\trmii_rxc = 0;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tintf_val = MTK_PERICFG_BIT_NIC_CFG_CON_RMII;\n\t\trmii_rxc = priv->rmii_rxc ? 0 : MTK_PERICFG_BIT_NIC_CFG_CON_CLK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"This interface not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(priv->pericfg,\n\t\t\t\t MTK_PERICFG_REG_NIC_CFG1_CON,\n\t\t\t\t MTK_PERICFG_BIT_NIC_CFG_CON_CLK,\n\t\t\t\t rmii_rxc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(priv->pericfg,\n\t\t\t\t  MTK_PERICFG_REG_NIC_CFG0_CON,\n\t\t\t\t  MTK_PERICFG_REG_NIC_CFG_CON_CFG_INTF,\n\t\t\t\t  intf_val);\n}\n\nstatic int mt8365_set_interface_mode(struct net_device *ndev)\n{\n\tstruct mtk_star_priv *priv = netdev_priv(ndev);\n\tstruct device *dev = mtk_star_get_dev(priv);\n\tunsigned int intf_val;\n\n\tswitch (priv->phy_intf) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tintf_val = MTK_PERICFG_BIT_NIC_CFG_CON_MII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tintf_val = MTK_PERICFG_BIT_NIC_CFG_CON_RMII;\n\t\tintf_val |= priv->rmii_rxc ? 0 : MTK_PERICFG_BIT_NIC_CFG_CON_CLK_V2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"This interface not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(priv->pericfg,\n\t\t\t\t  MTK_PERICFG_REG_NIC_CFG_CON_V2,\n\t\t\t\t  MTK_PERICFG_REG_NIC_CFG_CON_CFG_INTF |\n\t\t\t\t  MTK_PERICFG_BIT_NIC_CFG_CON_CLK_V2,\n\t\t\t\t  intf_val);\n}\n\nstatic const struct mtk_star_compat mtk_star_mt8516_compat = {\n\t.set_interface_mode = mt8516_set_interface_mode,\n\t.bit_clk_div = MTK_STAR_BIT_CLK_DIV_10,\n};\n\nstatic const struct mtk_star_compat mtk_star_mt8365_compat = {\n\t.set_interface_mode = mt8365_set_interface_mode,\n\t.bit_clk_div = MTK_STAR_BIT_CLK_DIV_50,\n};\n\nstatic const struct of_device_id mtk_star_of_match[] = {\n\t{ .compatible = \"mediatek,mt8516-eth\",\n\t  .data = &mtk_star_mt8516_compat },\n\t{ .compatible = \"mediatek,mt8518-eth\",\n\t  .data = &mtk_star_mt8516_compat },\n\t{ .compatible = \"mediatek,mt8175-eth\",\n\t  .data = &mtk_star_mt8516_compat },\n\t{ .compatible = \"mediatek,mt8365-eth\",\n\t  .data = &mtk_star_mt8365_compat },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mtk_star_of_match);\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(mtk_star_pm_ops,\n\t\t\t mtk_star_suspend, mtk_star_resume);\n\nstatic struct platform_driver mtk_star_driver = {\n\t.driver = {\n\t\t.name = MTK_STAR_DRVNAME,\n\t\t.pm = &mtk_star_pm_ops,\n\t\t.of_match_table = of_match_ptr(mtk_star_of_match),\n\t},\n\t.probe = mtk_star_probe,\n};\nmodule_platform_driver(mtk_star_driver);\n\nMODULE_AUTHOR(\"Bartosz Golaszewski <bgolaszewski@baylibre.com>\");\nMODULE_DESCRIPTION(\"Mediatek STAR Ethernet MAC Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}