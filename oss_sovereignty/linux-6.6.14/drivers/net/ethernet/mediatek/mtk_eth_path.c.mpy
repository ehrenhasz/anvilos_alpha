{
  "module_name": "mtk_eth_path.c",
  "hash_id": "f11e27efb0160c1d95e2b80499510ef717100bbe17f4325288292df810d2e8d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mediatek/mtk_eth_path.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/phy.h>\n#include <linux/regmap.h>\n\n#include \"mtk_eth_soc.h\"\n\nstruct mtk_eth_muxc {\n\tconst char\t*name;\n\tint\t\tcap_bit;\n\tint\t\t(*set_path)(struct mtk_eth *eth, u64 path);\n};\n\nstatic const char *mtk_eth_path_name(u64 path)\n{\n\tswitch (path) {\n\tcase MTK_ETH_PATH_GMAC1_RGMII:\n\t\treturn \"gmac1_rgmii\";\n\tcase MTK_ETH_PATH_GMAC1_TRGMII:\n\t\treturn \"gmac1_trgmii\";\n\tcase MTK_ETH_PATH_GMAC1_SGMII:\n\t\treturn \"gmac1_sgmii\";\n\tcase MTK_ETH_PATH_GMAC2_RGMII:\n\t\treturn \"gmac2_rgmii\";\n\tcase MTK_ETH_PATH_GMAC2_SGMII:\n\t\treturn \"gmac2_sgmii\";\n\tcase MTK_ETH_PATH_GMAC2_GEPHY:\n\t\treturn \"gmac2_gephy\";\n\tcase MTK_ETH_PATH_GDM1_ESW:\n\t\treturn \"gdm1_esw\";\n\tdefault:\n\t\treturn \"unknown path\";\n\t}\n}\n\nstatic int set_mux_gdm1_to_gmac1_esw(struct mtk_eth *eth, u64 path)\n{\n\tbool updated = true;\n\tu32 mask, set, reg;\n\n\tswitch (path) {\n\tcase MTK_ETH_PATH_GMAC1_SGMII:\n\t\tmask = ~(u32)MTK_MUX_TO_ESW;\n\t\tset = 0;\n\t\tbreak;\n\tcase MTK_ETH_PATH_GDM1_ESW:\n\t\tmask = ~(u32)MTK_MUX_TO_ESW;\n\t\tset = MTK_MUX_TO_ESW;\n\t\tbreak;\n\tdefault:\n\t\tupdated = false;\n\t\tbreak;\n\t}\n\n\tif (mtk_is_netsys_v3_or_greater(eth))\n\t\treg = MTK_MAC_MISC_V3;\n\telse\n\t\treg = MTK_MAC_MISC;\n\n\tif (updated)\n\t\tmtk_m32(eth, mask, set, reg);\n\n\tdev_dbg(eth->dev, \"path %s in %s updated = %d\\n\",\n\t\tmtk_eth_path_name(path), __func__, updated);\n\n\treturn 0;\n}\n\nstatic int set_mux_gmac2_gmac0_to_gephy(struct mtk_eth *eth, u64 path)\n{\n\tunsigned int val = 0;\n\tbool updated = true;\n\n\tswitch (path) {\n\tcase MTK_ETH_PATH_GMAC2_GEPHY:\n\t\tval = ~(u32)GEPHY_MAC_SEL;\n\t\tbreak;\n\tdefault:\n\t\tupdated = false;\n\t\tbreak;\n\t}\n\n\tif (updated)\n\t\tregmap_update_bits(eth->infra, INFRA_MISC2, GEPHY_MAC_SEL, val);\n\n\tdev_dbg(eth->dev, \"path %s in %s updated = %d\\n\",\n\t\tmtk_eth_path_name(path), __func__, updated);\n\n\treturn 0;\n}\n\nstatic int set_mux_u3_gmac2_to_qphy(struct mtk_eth *eth, u64 path)\n{\n\tunsigned int val = 0, mask = 0, reg = 0;\n\tbool updated = true;\n\n\tswitch (path) {\n\tcase MTK_ETH_PATH_GMAC2_SGMII:\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_U3_COPHY_V2)) {\n\t\t\treg = USB_PHY_SWITCH_REG;\n\t\t\tval = SGMII_QPHY_SEL;\n\t\t\tmask = QPHY_SEL_MASK;\n\t\t} else {\n\t\t\treg = INFRA_MISC2;\n\t\t\tval = CO_QPHY_SEL;\n\t\t\tmask = val;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tupdated = false;\n\t\tbreak;\n\t}\n\n\tif (updated)\n\t\tregmap_update_bits(eth->infra, reg, mask, val);\n\n\tdev_dbg(eth->dev, \"path %s in %s updated = %d\\n\",\n\t\tmtk_eth_path_name(path), __func__, updated);\n\n\treturn 0;\n}\n\nstatic int set_mux_gmac1_gmac2_to_sgmii_rgmii(struct mtk_eth *eth, u64 path)\n{\n\tunsigned int val = 0;\n\tbool updated = true;\n\n\tswitch (path) {\n\tcase MTK_ETH_PATH_GMAC1_SGMII:\n\t\tval = SYSCFG0_SGMII_GMAC1;\n\t\tbreak;\n\tcase MTK_ETH_PATH_GMAC2_SGMII:\n\t\tval = SYSCFG0_SGMII_GMAC2;\n\t\tbreak;\n\tcase MTK_ETH_PATH_GMAC1_RGMII:\n\tcase MTK_ETH_PATH_GMAC2_RGMII:\n\t\tregmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);\n\t\tval &= SYSCFG0_SGMII_MASK;\n\n\t\tif ((path == MTK_GMAC1_RGMII && val == SYSCFG0_SGMII_GMAC1) ||\n\t\t    (path == MTK_GMAC2_RGMII && val == SYSCFG0_SGMII_GMAC2))\n\t\t\tval = 0;\n\t\telse\n\t\t\tupdated = false;\n\t\tbreak;\n\tdefault:\n\t\tupdated = false;\n\t\tbreak;\n\t}\n\n\tif (updated)\n\t\tregmap_update_bits(eth->ethsys, ETHSYS_SYSCFG0,\n\t\t\t\t   SYSCFG0_SGMII_MASK, val);\n\n\tdev_dbg(eth->dev, \"path %s in %s updated = %d\\n\",\n\t\tmtk_eth_path_name(path), __func__, updated);\n\n\treturn 0;\n}\n\nstatic int set_mux_gmac12_to_gephy_sgmii(struct mtk_eth *eth, u64 path)\n{\n\tunsigned int val = 0;\n\tbool updated = true;\n\n\tregmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);\n\n\tswitch (path) {\n\tcase MTK_ETH_PATH_GMAC1_SGMII:\n\t\tval |= SYSCFG0_SGMII_GMAC1_V2;\n\t\tbreak;\n\tcase MTK_ETH_PATH_GMAC2_GEPHY:\n\t\tval &= ~(u32)SYSCFG0_SGMII_GMAC2_V2;\n\t\tbreak;\n\tcase MTK_ETH_PATH_GMAC2_SGMII:\n\t\tval |= SYSCFG0_SGMII_GMAC2_V2;\n\t\tbreak;\n\tdefault:\n\t\tupdated = false;\n\t}\n\n\tif (updated)\n\t\tregmap_update_bits(eth->ethsys, ETHSYS_SYSCFG0,\n\t\t\t\t   SYSCFG0_SGMII_MASK, val);\n\n\tdev_dbg(eth->dev, \"path %s in %s updated = %d\\n\",\n\t\tmtk_eth_path_name(path), __func__, updated);\n\n\treturn 0;\n}\n\nstatic const struct mtk_eth_muxc mtk_eth_muxc[] = {\n\t{\n\t\t.name = \"mux_gdm1_to_gmac1_esw\",\n\t\t.cap_bit = MTK_ETH_MUX_GDM1_TO_GMAC1_ESW,\n\t\t.set_path = set_mux_gdm1_to_gmac1_esw,\n\t}, {\n\t\t.name = \"mux_gmac2_gmac0_to_gephy\",\n\t\t.cap_bit = MTK_ETH_MUX_GMAC2_GMAC0_TO_GEPHY,\n\t\t.set_path = set_mux_gmac2_gmac0_to_gephy,\n\t}, {\n\t\t.name = \"mux_u3_gmac2_to_qphy\",\n\t\t.cap_bit = MTK_ETH_MUX_U3_GMAC2_TO_QPHY,\n\t\t.set_path = set_mux_u3_gmac2_to_qphy,\n\t}, {\n\t\t.name = \"mux_gmac1_gmac2_to_sgmii_rgmii\",\n\t\t.cap_bit = MTK_ETH_MUX_GMAC1_GMAC2_TO_SGMII_RGMII,\n\t\t.set_path = set_mux_gmac1_gmac2_to_sgmii_rgmii,\n\t}, {\n\t\t.name = \"mux_gmac12_to_gephy_sgmii\",\n\t\t.cap_bit = MTK_ETH_MUX_GMAC12_TO_GEPHY_SGMII,\n\t\t.set_path = set_mux_gmac12_to_gephy_sgmii,\n\t},\n};\n\nstatic int mtk_eth_mux_setup(struct mtk_eth *eth, u64 path)\n{\n\tint i, err = 0;\n\n\tif (!MTK_HAS_CAPS(eth->soc->caps, path)) {\n\t\tdev_err(eth->dev, \"path %s isn't support on the SoC\\n\",\n\t\t\tmtk_eth_path_name(path));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!MTK_HAS_CAPS(eth->soc->caps, MTK_MUX))\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mtk_eth_muxc); i++) {\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, mtk_eth_muxc[i].cap_bit)) {\n\t\t\terr = mtk_eth_muxc[i].set_path(eth, path);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tdev_dbg(eth->dev, \"mux %s isn't present on the SoC\\n\",\n\t\t\t\tmtk_eth_muxc[i].name);\n\t\t}\n\t}\n\nout:\n\treturn err;\n}\n\nint mtk_gmac_sgmii_path_setup(struct mtk_eth *eth, int mac_id)\n{\n\tu64 path;\n\n\tpath = (mac_id == 0) ?  MTK_ETH_PATH_GMAC1_SGMII :\n\t\t\t\tMTK_ETH_PATH_GMAC2_SGMII;\n\n\t \n\treturn mtk_eth_mux_setup(eth, path);\n}\n\nint mtk_gmac_gephy_path_setup(struct mtk_eth *eth, int mac_id)\n{\n\tu64 path = 0;\n\n\tif (mac_id == 1)\n\t\tpath = MTK_ETH_PATH_GMAC2_GEPHY;\n\n\tif (!path)\n\t\treturn -EINVAL;\n\n\t \n\treturn mtk_eth_mux_setup(eth, path);\n}\n\nint mtk_gmac_rgmii_path_setup(struct mtk_eth *eth, int mac_id)\n{\n\tu64 path;\n\n\tpath = (mac_id == 0) ?  MTK_ETH_PATH_GMAC1_RGMII :\n\t\t\t\tMTK_ETH_PATH_GMAC2_RGMII;\n\n\t \n\treturn mtk_eth_mux_setup(eth, path);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}