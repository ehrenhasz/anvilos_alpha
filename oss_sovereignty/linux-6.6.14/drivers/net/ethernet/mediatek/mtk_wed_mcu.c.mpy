{
  "module_name": "mtk_wed_mcu.c",
  "hash_id": "69160e63a5ef6abc3871e2f2af44eb54d665649445f3035f60f33db4a15a902b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mediatek/mtk_wed_mcu.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/of_address.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/mfd/syscon.h>\n#include <linux/soc/mediatek/mtk_wed.h>\n#include <asm/unaligned.h>\n\n#include \"mtk_wed_regs.h\"\n#include \"mtk_wed_wo.h\"\n#include \"mtk_wed.h\"\n\nstatic u32 wo_r32(struct mtk_wed_wo *wo, u32 reg)\n{\n\treturn readl(wo->boot.addr + reg);\n}\n\nstatic void wo_w32(struct mtk_wed_wo *wo, u32 reg, u32 val)\n{\n\twritel(val, wo->boot.addr + reg);\n}\n\nstatic struct sk_buff *\nmtk_wed_mcu_msg_alloc(const void *data, int data_len)\n{\n\tint length = sizeof(struct mtk_wed_mcu_hdr) + data_len;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(length, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tmemset(skb->head, 0, length);\n\tskb_reserve(skb, sizeof(struct mtk_wed_mcu_hdr));\n\tif (data && data_len)\n\t\tskb_put_data(skb, data, data_len);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *\nmtk_wed_mcu_get_response(struct mtk_wed_wo *wo, unsigned long expires)\n{\n\tif (!time_is_after_jiffies(expires))\n\t\treturn NULL;\n\n\twait_event_timeout(wo->mcu.wait, !skb_queue_empty(&wo->mcu.res_q),\n\t\t\t   expires - jiffies);\n\treturn skb_dequeue(&wo->mcu.res_q);\n}\n\nvoid mtk_wed_mcu_rx_event(struct mtk_wed_wo *wo, struct sk_buff *skb)\n{\n\tskb_queue_tail(&wo->mcu.res_q, skb);\n\twake_up(&wo->mcu.wait);\n}\n\nstatic void\nmtk_wed_update_rx_stats(struct mtk_wed_device *wed, struct sk_buff *skb)\n{\n\tu32 count = get_unaligned_le32(skb->data);\n\tstruct mtk_wed_wo_rx_stats *stats;\n\tint i;\n\n\tif (count * sizeof(*stats) > skb->len - sizeof(u32))\n\t\treturn;\n\n\tstats = (struct mtk_wed_wo_rx_stats *)(skb->data + sizeof(u32));\n\tfor (i = 0 ; i < count ; i++)\n\t\twed->wlan.update_wo_rx_stats(wed, &stats[i]);\n}\n\nvoid mtk_wed_mcu_rx_unsolicited_event(struct mtk_wed_wo *wo,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct mtk_wed_mcu_hdr *hdr = (struct mtk_wed_mcu_hdr *)skb->data;\n\n\tskb_pull(skb, sizeof(*hdr));\n\n\tswitch (hdr->cmd) {\n\tcase MTK_WED_WO_EVT_LOG_DUMP:\n\t\tdev_notice(wo->hw->dev, \"%s\\n\", skb->data);\n\t\tbreak;\n\tcase MTK_WED_WO_EVT_PROFILING: {\n\t\tstruct mtk_wed_wo_log_info *info = (void *)skb->data;\n\t\tu32 count = skb->len / sizeof(*info);\n\t\tint i;\n\n\t\tfor (i = 0 ; i < count ; i++)\n\t\t\tdev_notice(wo->hw->dev,\n\t\t\t\t   \"SN:%u latency: total=%u, rro:%u, mod:%u\\n\",\n\t\t\t\t   le32_to_cpu(info[i].sn),\n\t\t\t\t   le32_to_cpu(info[i].total),\n\t\t\t\t   le32_to_cpu(info[i].rro),\n\t\t\t\t   le32_to_cpu(info[i].mod));\n\t\tbreak;\n\t}\n\tcase MTK_WED_WO_EVT_RXCNT_INFO:\n\t\tmtk_wed_update_rx_stats(wo->hw->wed_dev, skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_kfree_skb(skb);\n}\n\nstatic int\nmtk_wed_mcu_skb_send_msg(struct mtk_wed_wo *wo, struct sk_buff *skb,\n\t\t\t int id, int cmd, u16 *wait_seq, bool wait_resp)\n{\n\tstruct mtk_wed_mcu_hdr *hdr;\n\n\t \n\two->mcu.timeout = 20 * HZ;\n\n\thdr = (struct mtk_wed_mcu_hdr *)skb_push(skb, sizeof(*hdr));\n\thdr->cmd = cmd;\n\thdr->length = cpu_to_le16(skb->len);\n\n\tif (wait_resp && wait_seq) {\n\t\tu16 seq = ++wo->mcu.seq;\n\n\t\tif (!seq)\n\t\t\tseq = ++wo->mcu.seq;\n\t\t*wait_seq = seq;\n\n\t\thdr->flag |= cpu_to_le16(MTK_WED_WARP_CMD_FLAG_NEED_RSP);\n\t\thdr->seq = cpu_to_le16(seq);\n\t}\n\tif (id == MTK_WED_MODULE_ID_WO)\n\t\thdr->flag |= cpu_to_le16(MTK_WED_WARP_CMD_FLAG_FROM_TO_WO);\n\n\treturn mtk_wed_wo_queue_tx_skb(wo, &wo->q_tx, skb);\n}\n\nstatic int\nmtk_wed_mcu_parse_response(struct mtk_wed_wo *wo, struct sk_buff *skb,\n\t\t\t   int cmd, int seq)\n{\n\tstruct mtk_wed_mcu_hdr *hdr;\n\n\tif (!skb) {\n\t\tdev_err(wo->hw->dev, \"Message %08x (seq %d) timeout\\n\",\n\t\t\tcmd, seq);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\thdr = (struct mtk_wed_mcu_hdr *)skb->data;\n\tif (le16_to_cpu(hdr->seq) != seq)\n\t\treturn -EAGAIN;\n\n\tskb_pull(skb, sizeof(*hdr));\n\tswitch (cmd) {\n\tcase MTK_WED_WO_CMD_RXCNT_INFO:\n\t\tmtk_wed_update_rx_stats(wo->hw->wed_dev, skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint mtk_wed_mcu_send_msg(struct mtk_wed_wo *wo, int id, int cmd,\n\t\t\t const void *data, int len, bool wait_resp)\n{\n\tunsigned long expires;\n\tstruct sk_buff *skb;\n\tu16 seq;\n\tint ret;\n\n\tskb = mtk_wed_mcu_msg_alloc(data, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&wo->mcu.mutex);\n\n\tret = mtk_wed_mcu_skb_send_msg(wo, skb, id, cmd, &seq, wait_resp);\n\tif (ret || !wait_resp)\n\t\tgoto unlock;\n\n\texpires = jiffies + wo->mcu.timeout;\n\tdo {\n\t\tskb = mtk_wed_mcu_get_response(wo, expires);\n\t\tret = mtk_wed_mcu_parse_response(wo, skb, cmd, seq);\n\t\tdev_kfree_skb(skb);\n\t} while (ret == -EAGAIN);\n\nunlock:\n\tmutex_unlock(&wo->mcu.mutex);\n\n\treturn ret;\n}\n\nint mtk_wed_mcu_msg_update(struct mtk_wed_device *dev, int id, void *data,\n\t\t\t   int len)\n{\n\tstruct mtk_wed_wo *wo = dev->hw->wed_wo;\n\n\tif (dev->hw->version == 1)\n\t\treturn 0;\n\n\tif (WARN_ON(!wo))\n\t\treturn -ENODEV;\n\n\treturn mtk_wed_mcu_send_msg(wo, MTK_WED_MODULE_ID_WO, id, data, len,\n\t\t\t\t    true);\n}\n\nstatic int\nmtk_wed_get_memory_region(struct mtk_wed_wo *wo,\n\t\t\t  struct mtk_wed_wo_memory_region *region)\n{\n\tstruct reserved_mem *rmem;\n\tstruct device_node *np;\n\tint index;\n\n\tindex = of_property_match_string(wo->hw->node, \"memory-region-names\",\n\t\t\t\t\t region->name);\n\tif (index < 0)\n\t\treturn index;\n\n\tnp = of_parse_phandle(wo->hw->node, \"memory-region\", index);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\trmem = of_reserved_mem_lookup(np);\n\tof_node_put(np);\n\n\tif (!rmem)\n\t\treturn -ENODEV;\n\n\tregion->phy_addr = rmem->base;\n\tregion->size = rmem->size;\n\tregion->addr = devm_ioremap(wo->hw->dev, region->phy_addr, region->size);\n\n\treturn !region->addr ? -EINVAL : 0;\n}\n\nstatic int\nmtk_wed_mcu_run_firmware(struct mtk_wed_wo *wo, const struct firmware *fw,\n\t\t\t struct mtk_wed_wo_memory_region *region)\n{\n\tconst u8 *first_region_ptr, *region_ptr, *trailer_ptr, *ptr = fw->data;\n\tconst struct mtk_wed_fw_trailer *trailer;\n\tconst struct mtk_wed_fw_region *fw_region;\n\n\ttrailer_ptr = fw->data + fw->size - sizeof(*trailer);\n\ttrailer = (const struct mtk_wed_fw_trailer *)trailer_ptr;\n\tregion_ptr = trailer_ptr - trailer->num_region * sizeof(*fw_region);\n\tfirst_region_ptr = region_ptr;\n\n\twhile (region_ptr < trailer_ptr) {\n\t\tu32 length;\n\n\t\tfw_region = (const struct mtk_wed_fw_region *)region_ptr;\n\t\tlength = le32_to_cpu(fw_region->len);\n\n\t\tif (region->phy_addr != le32_to_cpu(fw_region->addr))\n\t\t\tgoto next;\n\n\t\tif (region->size < length)\n\t\t\tgoto next;\n\n\t\tif (first_region_ptr < ptr + length)\n\t\t\tgoto next;\n\n\t\tif (region->shared && region->consumed)\n\t\t\treturn 0;\n\n\t\tif (!region->shared || !region->consumed) {\n\t\t\tmemcpy_toio(region->addr, ptr, length);\n\t\t\tregion->consumed = true;\n\t\t\treturn 0;\n\t\t}\nnext:\n\t\tregion_ptr += sizeof(*fw_region);\n\t\tptr += length;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nmtk_wed_mcu_load_firmware(struct mtk_wed_wo *wo)\n{\n\tstatic struct mtk_wed_wo_memory_region mem_region[] = {\n\t\t[MTK_WED_WO_REGION_EMI] = {\n\t\t\t.name = \"wo-emi\",\n\t\t},\n\t\t[MTK_WED_WO_REGION_ILM] = {\n\t\t\t.name = \"wo-ilm\",\n\t\t},\n\t\t[MTK_WED_WO_REGION_DATA] = {\n\t\t\t.name = \"wo-data\",\n\t\t\t.shared = true,\n\t\t},\n\t};\n\tconst struct mtk_wed_fw_trailer *trailer;\n\tconst struct firmware *fw;\n\tconst char *fw_name;\n\tu32 val, boot_cr;\n\tint ret, i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mem_region); i++) {\n\t\tret = mtk_wed_get_memory_region(wo, &mem_region[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\two->boot.name = \"wo-boot\";\n\tret = mtk_wed_get_memory_region(wo, &wo->boot);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twed_w32(wo->hw->wed_dev, MTK_WED_SCR0 + 4 * MTK_WED_DUMMY_CR_FWDL,\n\t\two->hw->index + 1);\n\n\t \n\tif (of_device_is_compatible(wo->hw->node, \"mediatek,mt7981-wed\"))\n\t\tfw_name = MT7981_FIRMWARE_WO;\n\telse\n\t\tfw_name = wo->hw->index ? MT7986_FIRMWARE_WO1 : MT7986_FIRMWARE_WO0;\n\n\tret = request_firmware(&fw, fw_name, wo->hw->dev);\n\tif (ret)\n\t\treturn ret;\n\n\ttrailer = (void *)(fw->data + fw->size -\n\t\t\t   sizeof(struct mtk_wed_fw_trailer));\n\tdev_info(wo->hw->dev,\n\t\t \"MTK WED WO Firmware Version: %.10s, Build Time: %.15s\\n\",\n\t\t trailer->fw_ver, trailer->build_date);\n\tdev_info(wo->hw->dev, \"MTK WED WO Chip ID %02x Region %d\\n\",\n\t\t trailer->chip_id, trailer->num_region);\n\n\tfor (i = 0; i < ARRAY_SIZE(mem_region); i++) {\n\t\tret = mtk_wed_mcu_run_firmware(wo, fw, &mem_region[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tboot_cr = wo->hw->index ? MTK_WO_MCU_CFG_LS_WA_BOOT_ADDR_ADDR\n\t\t\t\t: MTK_WO_MCU_CFG_LS_WM_BOOT_ADDR_ADDR;\n\two_w32(wo, boot_cr, mem_region[MTK_WED_WO_REGION_EMI].phy_addr >> 16);\n\t \n\two_w32(wo, MTK_WO_MCU_CFG_LS_WF_MCCR_CLR_ADDR, 0xc00);\n\n\tval = wo_r32(wo, MTK_WO_MCU_CFG_LS_WF_MCU_CFG_WM_WA_ADDR);\n\tval |= wo->hw->index ? MTK_WO_MCU_CFG_LS_WF_WM_WA_WA_CPU_RSTB_MASK\n\t\t\t     : MTK_WO_MCU_CFG_LS_WF_WM_WA_WM_CPU_RSTB_MASK;\n\two_w32(wo, MTK_WO_MCU_CFG_LS_WF_MCU_CFG_WM_WA_ADDR, val);\nout:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic u32\nmtk_wed_mcu_read_fw_dl(struct mtk_wed_wo *wo)\n{\n\treturn wed_r32(wo->hw->wed_dev,\n\t\t       MTK_WED_SCR0 + 4 * MTK_WED_DUMMY_CR_FWDL);\n}\n\nint mtk_wed_mcu_init(struct mtk_wed_wo *wo)\n{\n\tu32 val;\n\tint ret;\n\n\tskb_queue_head_init(&wo->mcu.res_q);\n\tinit_waitqueue_head(&wo->mcu.wait);\n\tmutex_init(&wo->mcu.mutex);\n\n\tret = mtk_wed_mcu_load_firmware(wo);\n\tif (ret)\n\t\treturn ret;\n\n\treturn readx_poll_timeout(mtk_wed_mcu_read_fw_dl, wo, val, !val,\n\t\t\t\t  100, MTK_FW_DL_TIMEOUT);\n}\n\nMODULE_FIRMWARE(MT7981_FIRMWARE_WO);\nMODULE_FIRMWARE(MT7986_FIRMWARE_WO0);\nMODULE_FIRMWARE(MT7986_FIRMWARE_WO1);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}