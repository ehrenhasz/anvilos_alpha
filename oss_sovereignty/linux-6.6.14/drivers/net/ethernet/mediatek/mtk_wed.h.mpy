{
  "module_name": "mtk_wed.h",
  "hash_id": "92bcc808a5f3b1a048a7214eb96511239993ce29cd1e6487a3bd510c2f4ac113",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mediatek/mtk_wed.h",
  "human_readable_source": "\n \n\n#ifndef __MTK_WED_PRIV_H\n#define __MTK_WED_PRIV_H\n\n#include <linux/soc/mediatek/mtk_wed.h>\n#include <linux/debugfs.h>\n#include <linux/regmap.h>\n#include <linux/netdevice.h>\n\nstruct mtk_eth;\nstruct mtk_wed_wo;\n\nstruct mtk_wed_hw {\n\tstruct device_node *node;\n\tstruct mtk_eth *eth;\n\tstruct regmap *regs;\n\tstruct regmap *hifsys;\n\tstruct device *dev;\n\tvoid __iomem *wdma;\n\tphys_addr_t wdma_phy;\n\tstruct regmap *mirror;\n\tstruct dentry *debugfs_dir;\n\tstruct mtk_wed_device *wed_dev;\n\tstruct mtk_wed_wo *wed_wo;\n\tu32 debugfs_reg;\n\tu32 num_flows;\n\tu8 version;\n\tchar dirname[5];\n\tint irq;\n\tint index;\n};\n\nstruct mtk_wdma_info {\n\tu8 wdma_idx;\n\tu8 queue;\n\tu16 wcid;\n\tu8 bss;\n};\n\n#ifdef CONFIG_NET_MEDIATEK_SOC_WED\nstatic inline void\nwed_w32(struct mtk_wed_device *dev, u32 reg, u32 val)\n{\n\tregmap_write(dev->hw->regs, reg, val);\n}\n\nstatic inline u32\nwed_r32(struct mtk_wed_device *dev, u32 reg)\n{\n\tunsigned int val;\n\n\tregmap_read(dev->hw->regs, reg, &val);\n\n\treturn val;\n}\n\nstatic inline void\nwdma_w32(struct mtk_wed_device *dev, u32 reg, u32 val)\n{\n\twritel(val, dev->hw->wdma + reg);\n}\n\nstatic inline u32\nwdma_r32(struct mtk_wed_device *dev, u32 reg)\n{\n\treturn readl(dev->hw->wdma + reg);\n}\n\nstatic inline u32\nwpdma_tx_r32(struct mtk_wed_device *dev, int ring, u32 reg)\n{\n\tif (!dev->tx_ring[ring].wpdma)\n\t\treturn 0;\n\n\treturn readl(dev->tx_ring[ring].wpdma + reg);\n}\n\nstatic inline void\nwpdma_tx_w32(struct mtk_wed_device *dev, int ring, u32 reg, u32 val)\n{\n\tif (!dev->tx_ring[ring].wpdma)\n\t\treturn;\n\n\twritel(val, dev->tx_ring[ring].wpdma + reg);\n}\n\nstatic inline u32\nwpdma_rx_r32(struct mtk_wed_device *dev, int ring, u32 reg)\n{\n\tif (!dev->rx_ring[ring].wpdma)\n\t\treturn 0;\n\n\treturn readl(dev->rx_ring[ring].wpdma + reg);\n}\n\nstatic inline void\nwpdma_rx_w32(struct mtk_wed_device *dev, int ring, u32 reg, u32 val)\n{\n\tif (!dev->rx_ring[ring].wpdma)\n\t\treturn;\n\n\twritel(val, dev->rx_ring[ring].wpdma + reg);\n}\n\nstatic inline u32\nwpdma_txfree_r32(struct mtk_wed_device *dev, u32 reg)\n{\n\tif (!dev->txfree_ring.wpdma)\n\t\treturn 0;\n\n\treturn readl(dev->txfree_ring.wpdma + reg);\n}\n\nstatic inline void\nwpdma_txfree_w32(struct mtk_wed_device *dev, u32 reg, u32 val)\n{\n\tif (!dev->txfree_ring.wpdma)\n\t\treturn;\n\n\twritel(val, dev->txfree_ring.wpdma + reg);\n}\n\nvoid mtk_wed_add_hw(struct device_node *np, struct mtk_eth *eth,\n\t\t    void __iomem *wdma, phys_addr_t wdma_phy,\n\t\t    int index);\nvoid mtk_wed_exit(void);\nint mtk_wed_flow_add(int index);\nvoid mtk_wed_flow_remove(int index);\nvoid mtk_wed_fe_reset(void);\nvoid mtk_wed_fe_reset_complete(void);\n#else\nstatic inline void\nmtk_wed_add_hw(struct device_node *np, struct mtk_eth *eth,\n\t       void __iomem *wdma, phys_addr_t wdma_phy,\n\t       int index)\n{\n}\nstatic inline void\nmtk_wed_exit(void)\n{\n}\nstatic inline int mtk_wed_flow_add(int index)\n{\n\treturn -EINVAL;\n}\nstatic inline void mtk_wed_flow_remove(int index)\n{\n}\n\nstatic inline void mtk_wed_fe_reset(void)\n{\n}\n\nstatic inline void mtk_wed_fe_reset_complete(void)\n{\n}\n#endif\n\n#ifdef CONFIG_DEBUG_FS\nvoid mtk_wed_hw_add_debugfs(struct mtk_wed_hw *hw);\n#else\nstatic inline void mtk_wed_hw_add_debugfs(struct mtk_wed_hw *hw)\n{\n}\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}