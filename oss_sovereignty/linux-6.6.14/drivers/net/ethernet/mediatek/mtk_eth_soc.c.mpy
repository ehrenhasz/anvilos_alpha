{
  "module_name": "mtk_eth_soc.c",
  "hash_id": "549a65f9e7331324791ae89e8b346f724a6fd0c53aa716f50dfc7c7a98b46537",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mediatek/mtk_eth_soc.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_address.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/clk.h>\n#include <linux/pm_runtime.h>\n#include <linux/if_vlan.h>\n#include <linux/reset.h>\n#include <linux/tcp.h>\n#include <linux/interrupt.h>\n#include <linux/pinctrl/devinfo.h>\n#include <linux/phylink.h>\n#include <linux/pcs/pcs-mtk-lynxi.h>\n#include <linux/jhash.h>\n#include <linux/bitfield.h>\n#include <net/dsa.h>\n#include <net/dst_metadata.h>\n#include <net/page_pool/helpers.h>\n\n#include \"mtk_eth_soc.h\"\n#include \"mtk_wed.h\"\n\nstatic int mtk_msg_level = -1;\nmodule_param_named(msg_level, mtk_msg_level, int, 0);\nMODULE_PARM_DESC(msg_level, \"Message level (-1=defaults,0=none,...,16=all)\");\n\n#define MTK_ETHTOOL_STAT(x) { #x, \\\n\t\t\t      offsetof(struct mtk_hw_stats, x) / sizeof(u64) }\n\n#define MTK_ETHTOOL_XDP_STAT(x) { #x, \\\n\t\t\t\t  offsetof(struct mtk_hw_stats, xdp_stats.x) / \\\n\t\t\t\t  sizeof(u64) }\n\nstatic const struct mtk_reg_map mtk_reg_map = {\n\t.tx_irq_mask\t\t= 0x1a1c,\n\t.tx_irq_status\t\t= 0x1a18,\n\t.pdma = {\n\t\t.rx_ptr\t\t= 0x0900,\n\t\t.rx_cnt_cfg\t= 0x0904,\n\t\t.pcrx_ptr\t= 0x0908,\n\t\t.glo_cfg\t= 0x0a04,\n\t\t.rst_idx\t= 0x0a08,\n\t\t.delay_irq\t= 0x0a0c,\n\t\t.irq_status\t= 0x0a20,\n\t\t.irq_mask\t= 0x0a28,\n\t\t.adma_rx_dbg0\t= 0x0a38,\n\t\t.int_grp\t= 0x0a50,\n\t},\n\t.qdma = {\n\t\t.qtx_cfg\t= 0x1800,\n\t\t.qtx_sch\t= 0x1804,\n\t\t.rx_ptr\t\t= 0x1900,\n\t\t.rx_cnt_cfg\t= 0x1904,\n\t\t.qcrx_ptr\t= 0x1908,\n\t\t.glo_cfg\t= 0x1a04,\n\t\t.rst_idx\t= 0x1a08,\n\t\t.delay_irq\t= 0x1a0c,\n\t\t.fc_th\t\t= 0x1a10,\n\t\t.tx_sch_rate\t= 0x1a14,\n\t\t.int_grp\t= 0x1a20,\n\t\t.hred\t\t= 0x1a44,\n\t\t.ctx_ptr\t= 0x1b00,\n\t\t.dtx_ptr\t= 0x1b04,\n\t\t.crx_ptr\t= 0x1b10,\n\t\t.drx_ptr\t= 0x1b14,\n\t\t.fq_head\t= 0x1b20,\n\t\t.fq_tail\t= 0x1b24,\n\t\t.fq_count\t= 0x1b28,\n\t\t.fq_blen\t= 0x1b2c,\n\t},\n\t.gdm1_cnt\t\t= 0x2400,\n\t.gdma_to_ppe\t\t= 0x4444,\n\t.ppe_base\t\t= 0x0c00,\n\t.wdma_base = {\n\t\t[0]\t\t= 0x2800,\n\t\t[1]\t\t= 0x2c00,\n\t},\n\t.pse_iq_sta\t\t= 0x0110,\n\t.pse_oq_sta\t\t= 0x0118,\n};\n\nstatic const struct mtk_reg_map mt7628_reg_map = {\n\t.tx_irq_mask\t\t= 0x0a28,\n\t.tx_irq_status\t\t= 0x0a20,\n\t.pdma = {\n\t\t.rx_ptr\t\t= 0x0900,\n\t\t.rx_cnt_cfg\t= 0x0904,\n\t\t.pcrx_ptr\t= 0x0908,\n\t\t.glo_cfg\t= 0x0a04,\n\t\t.rst_idx\t= 0x0a08,\n\t\t.delay_irq\t= 0x0a0c,\n\t\t.irq_status\t= 0x0a20,\n\t\t.irq_mask\t= 0x0a28,\n\t\t.int_grp\t= 0x0a50,\n\t},\n};\n\nstatic const struct mtk_reg_map mt7986_reg_map = {\n\t.tx_irq_mask\t\t= 0x461c,\n\t.tx_irq_status\t\t= 0x4618,\n\t.pdma = {\n\t\t.rx_ptr\t\t= 0x6100,\n\t\t.rx_cnt_cfg\t= 0x6104,\n\t\t.pcrx_ptr\t= 0x6108,\n\t\t.glo_cfg\t= 0x6204,\n\t\t.rst_idx\t= 0x6208,\n\t\t.delay_irq\t= 0x620c,\n\t\t.irq_status\t= 0x6220,\n\t\t.irq_mask\t= 0x6228,\n\t\t.adma_rx_dbg0\t= 0x6238,\n\t\t.int_grp\t= 0x6250,\n\t},\n\t.qdma = {\n\t\t.qtx_cfg\t= 0x4400,\n\t\t.qtx_sch\t= 0x4404,\n\t\t.rx_ptr\t\t= 0x4500,\n\t\t.rx_cnt_cfg\t= 0x4504,\n\t\t.qcrx_ptr\t= 0x4508,\n\t\t.glo_cfg\t= 0x4604,\n\t\t.rst_idx\t= 0x4608,\n\t\t.delay_irq\t= 0x460c,\n\t\t.fc_th\t\t= 0x4610,\n\t\t.int_grp\t= 0x4620,\n\t\t.hred\t\t= 0x4644,\n\t\t.ctx_ptr\t= 0x4700,\n\t\t.dtx_ptr\t= 0x4704,\n\t\t.crx_ptr\t= 0x4710,\n\t\t.drx_ptr\t= 0x4714,\n\t\t.fq_head\t= 0x4720,\n\t\t.fq_tail\t= 0x4724,\n\t\t.fq_count\t= 0x4728,\n\t\t.fq_blen\t= 0x472c,\n\t\t.tx_sch_rate\t= 0x4798,\n\t},\n\t.gdm1_cnt\t\t= 0x1c00,\n\t.gdma_to_ppe\t\t= 0x3333,\n\t.ppe_base\t\t= 0x2000,\n\t.wdma_base = {\n\t\t[0]\t\t= 0x4800,\n\t\t[1]\t\t= 0x4c00,\n\t},\n\t.pse_iq_sta\t\t= 0x0180,\n\t.pse_oq_sta\t\t= 0x01a0,\n};\n\nstatic const struct mtk_reg_map mt7988_reg_map = {\n\t.tx_irq_mask\t\t= 0x461c,\n\t.tx_irq_status\t\t= 0x4618,\n\t.pdma = {\n\t\t.rx_ptr\t\t= 0x6900,\n\t\t.rx_cnt_cfg\t= 0x6904,\n\t\t.pcrx_ptr\t= 0x6908,\n\t\t.glo_cfg\t= 0x6a04,\n\t\t.rst_idx\t= 0x6a08,\n\t\t.delay_irq\t= 0x6a0c,\n\t\t.irq_status\t= 0x6a20,\n\t\t.irq_mask\t= 0x6a28,\n\t\t.adma_rx_dbg0\t= 0x6a38,\n\t\t.int_grp\t= 0x6a50,\n\t},\n\t.qdma = {\n\t\t.qtx_cfg\t= 0x4400,\n\t\t.qtx_sch\t= 0x4404,\n\t\t.rx_ptr\t\t= 0x4500,\n\t\t.rx_cnt_cfg\t= 0x4504,\n\t\t.qcrx_ptr\t= 0x4508,\n\t\t.glo_cfg\t= 0x4604,\n\t\t.rst_idx\t= 0x4608,\n\t\t.delay_irq\t= 0x460c,\n\t\t.fc_th\t\t= 0x4610,\n\t\t.int_grp\t= 0x4620,\n\t\t.hred\t\t= 0x4644,\n\t\t.ctx_ptr\t= 0x4700,\n\t\t.dtx_ptr\t= 0x4704,\n\t\t.crx_ptr\t= 0x4710,\n\t\t.drx_ptr\t= 0x4714,\n\t\t.fq_head\t= 0x4720,\n\t\t.fq_tail\t= 0x4724,\n\t\t.fq_count\t= 0x4728,\n\t\t.fq_blen\t= 0x472c,\n\t\t.tx_sch_rate\t= 0x4798,\n\t},\n\t.gdm1_cnt\t\t= 0x1c00,\n\t.gdma_to_ppe\t\t= 0x3333,\n\t.ppe_base\t\t= 0x2000,\n\t.wdma_base = {\n\t\t[0]\t\t= 0x4800,\n\t\t[1]\t\t= 0x4c00,\n\t},\n\t.pse_iq_sta\t\t= 0x0180,\n\t.pse_oq_sta\t\t= 0x01a0,\n};\n\n \nstatic const struct mtk_ethtool_stats {\n\tchar str[ETH_GSTRING_LEN];\n\tu32 offset;\n} mtk_ethtool_stats[] = {\n\tMTK_ETHTOOL_STAT(tx_bytes),\n\tMTK_ETHTOOL_STAT(tx_packets),\n\tMTK_ETHTOOL_STAT(tx_skip),\n\tMTK_ETHTOOL_STAT(tx_collisions),\n\tMTK_ETHTOOL_STAT(rx_bytes),\n\tMTK_ETHTOOL_STAT(rx_packets),\n\tMTK_ETHTOOL_STAT(rx_overflow),\n\tMTK_ETHTOOL_STAT(rx_fcs_errors),\n\tMTK_ETHTOOL_STAT(rx_short_errors),\n\tMTK_ETHTOOL_STAT(rx_long_errors),\n\tMTK_ETHTOOL_STAT(rx_checksum_errors),\n\tMTK_ETHTOOL_STAT(rx_flow_control_packets),\n\tMTK_ETHTOOL_XDP_STAT(rx_xdp_redirect),\n\tMTK_ETHTOOL_XDP_STAT(rx_xdp_pass),\n\tMTK_ETHTOOL_XDP_STAT(rx_xdp_drop),\n\tMTK_ETHTOOL_XDP_STAT(rx_xdp_tx),\n\tMTK_ETHTOOL_XDP_STAT(rx_xdp_tx_errors),\n\tMTK_ETHTOOL_XDP_STAT(tx_xdp_xmit),\n\tMTK_ETHTOOL_XDP_STAT(tx_xdp_xmit_errors),\n};\n\nstatic const char * const mtk_clks_source_name[] = {\n\t\"ethif\",\n\t\"sgmiitop\",\n\t\"esw\",\n\t\"gp0\",\n\t\"gp1\",\n\t\"gp2\",\n\t\"gp3\",\n\t\"xgp1\",\n\t\"xgp2\",\n\t\"xgp3\",\n\t\"crypto\",\n\t\"fe\",\n\t\"trgpll\",\n\t\"sgmii_tx250m\",\n\t\"sgmii_rx250m\",\n\t\"sgmii_cdr_ref\",\n\t\"sgmii_cdr_fb\",\n\t\"sgmii2_tx250m\",\n\t\"sgmii2_rx250m\",\n\t\"sgmii2_cdr_ref\",\n\t\"sgmii2_cdr_fb\",\n\t\"sgmii_ck\",\n\t\"eth2pll\",\n\t\"wocpu0\",\n\t\"wocpu1\",\n\t\"netsys0\",\n\t\"netsys1\",\n\t\"ethwarp_wocpu2\",\n\t\"ethwarp_wocpu1\",\n\t\"ethwarp_wocpu0\",\n\t\"top_usxgmii0_sel\",\n\t\"top_usxgmii1_sel\",\n\t\"top_sgm0_sel\",\n\t\"top_sgm1_sel\",\n\t\"top_xfi_phy0_xtal_sel\",\n\t\"top_xfi_phy1_xtal_sel\",\n\t\"top_eth_gmii_sel\",\n\t\"top_eth_refck_50m_sel\",\n\t\"top_eth_sys_200m_sel\",\n\t\"top_eth_sys_sel\",\n\t\"top_eth_xgmii_sel\",\n\t\"top_eth_mii_sel\",\n\t\"top_netsys_sel\",\n\t\"top_netsys_500m_sel\",\n\t\"top_netsys_pao_2x_sel\",\n\t\"top_netsys_sync_250m_sel\",\n\t\"top_netsys_ppefb_250m_sel\",\n\t\"top_netsys_warp_sel\",\n};\n\nvoid mtk_w32(struct mtk_eth *eth, u32 val, unsigned reg)\n{\n\t__raw_writel(val, eth->base + reg);\n}\n\nu32 mtk_r32(struct mtk_eth *eth, unsigned reg)\n{\n\treturn __raw_readl(eth->base + reg);\n}\n\nu32 mtk_m32(struct mtk_eth *eth, u32 mask, u32 set, unsigned int reg)\n{\n\tu32 val;\n\n\tval = mtk_r32(eth, reg);\n\tval &= ~mask;\n\tval |= set;\n\tmtk_w32(eth, val, reg);\n\treturn reg;\n}\n\nstatic int mtk_mdio_busy_wait(struct mtk_eth *eth)\n{\n\tunsigned long t_start = jiffies;\n\n\twhile (1) {\n\t\tif (!(mtk_r32(eth, MTK_PHY_IAC) & PHY_IAC_ACCESS))\n\t\t\treturn 0;\n\t\tif (time_after(jiffies, t_start + PHY_IAC_TIMEOUT))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\n\tdev_err(eth->dev, \"mdio: MDIO timeout\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic int _mtk_mdio_write_c22(struct mtk_eth *eth, u32 phy_addr, u32 phy_reg,\n\t\t\t       u32 write_data)\n{\n\tint ret;\n\n\tret = mtk_mdio_busy_wait(eth);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmtk_w32(eth, PHY_IAC_ACCESS |\n\t\tPHY_IAC_START_C22 |\n\t\tPHY_IAC_CMD_WRITE |\n\t\tPHY_IAC_REG(phy_reg) |\n\t\tPHY_IAC_ADDR(phy_addr) |\n\t\tPHY_IAC_DATA(write_data),\n\t\tMTK_PHY_IAC);\n\n\tret = mtk_mdio_busy_wait(eth);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int _mtk_mdio_write_c45(struct mtk_eth *eth, u32 phy_addr,\n\t\t\t       u32 devad, u32 phy_reg, u32 write_data)\n{\n\tint ret;\n\n\tret = mtk_mdio_busy_wait(eth);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmtk_w32(eth, PHY_IAC_ACCESS |\n\t\tPHY_IAC_START_C45 |\n\t\tPHY_IAC_CMD_C45_ADDR |\n\t\tPHY_IAC_REG(devad) |\n\t\tPHY_IAC_ADDR(phy_addr) |\n\t\tPHY_IAC_DATA(phy_reg),\n\t\tMTK_PHY_IAC);\n\n\tret = mtk_mdio_busy_wait(eth);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmtk_w32(eth, PHY_IAC_ACCESS |\n\t\tPHY_IAC_START_C45 |\n\t\tPHY_IAC_CMD_WRITE |\n\t\tPHY_IAC_REG(devad) |\n\t\tPHY_IAC_ADDR(phy_addr) |\n\t\tPHY_IAC_DATA(write_data),\n\t\tMTK_PHY_IAC);\n\n\tret = mtk_mdio_busy_wait(eth);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int _mtk_mdio_read_c22(struct mtk_eth *eth, u32 phy_addr, u32 phy_reg)\n{\n\tint ret;\n\n\tret = mtk_mdio_busy_wait(eth);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmtk_w32(eth, PHY_IAC_ACCESS |\n\t\tPHY_IAC_START_C22 |\n\t\tPHY_IAC_CMD_C22_READ |\n\t\tPHY_IAC_REG(phy_reg) |\n\t\tPHY_IAC_ADDR(phy_addr),\n\t\tMTK_PHY_IAC);\n\n\tret = mtk_mdio_busy_wait(eth);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mtk_r32(eth, MTK_PHY_IAC) & PHY_IAC_DATA_MASK;\n}\n\nstatic int _mtk_mdio_read_c45(struct mtk_eth *eth, u32 phy_addr,\n\t\t\t      u32 devad, u32 phy_reg)\n{\n\tint ret;\n\n\tret = mtk_mdio_busy_wait(eth);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmtk_w32(eth, PHY_IAC_ACCESS |\n\t\tPHY_IAC_START_C45 |\n\t\tPHY_IAC_CMD_C45_ADDR |\n\t\tPHY_IAC_REG(devad) |\n\t\tPHY_IAC_ADDR(phy_addr) |\n\t\tPHY_IAC_DATA(phy_reg),\n\t\tMTK_PHY_IAC);\n\n\tret = mtk_mdio_busy_wait(eth);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmtk_w32(eth, PHY_IAC_ACCESS |\n\t\tPHY_IAC_START_C45 |\n\t\tPHY_IAC_CMD_C45_READ |\n\t\tPHY_IAC_REG(devad) |\n\t\tPHY_IAC_ADDR(phy_addr),\n\t\tMTK_PHY_IAC);\n\n\tret = mtk_mdio_busy_wait(eth);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mtk_r32(eth, MTK_PHY_IAC) & PHY_IAC_DATA_MASK;\n}\n\nstatic int mtk_mdio_write_c22(struct mii_bus *bus, int phy_addr,\n\t\t\t      int phy_reg, u16 val)\n{\n\tstruct mtk_eth *eth = bus->priv;\n\n\treturn _mtk_mdio_write_c22(eth, phy_addr, phy_reg, val);\n}\n\nstatic int mtk_mdio_write_c45(struct mii_bus *bus, int phy_addr,\n\t\t\t      int devad, int phy_reg, u16 val)\n{\n\tstruct mtk_eth *eth = bus->priv;\n\n\treturn _mtk_mdio_write_c45(eth, phy_addr, devad, phy_reg, val);\n}\n\nstatic int mtk_mdio_read_c22(struct mii_bus *bus, int phy_addr, int phy_reg)\n{\n\tstruct mtk_eth *eth = bus->priv;\n\n\treturn _mtk_mdio_read_c22(eth, phy_addr, phy_reg);\n}\n\nstatic int mtk_mdio_read_c45(struct mii_bus *bus, int phy_addr, int devad,\n\t\t\t     int phy_reg)\n{\n\tstruct mtk_eth *eth = bus->priv;\n\n\treturn _mtk_mdio_read_c45(eth, phy_addr, devad, phy_reg);\n}\n\nstatic int mt7621_gmac0_rgmii_adjust(struct mtk_eth *eth,\n\t\t\t\t     phy_interface_t interface)\n{\n\tu32 val;\n\n\tval = (interface == PHY_INTERFACE_MODE_TRGMII) ?\n\t\tETHSYS_TRGMII_MT7621_DDR_PLL : 0;\n\n\tregmap_update_bits(eth->ethsys, ETHSYS_CLKCFG0,\n\t\t\t   ETHSYS_TRGMII_MT7621_MASK, val);\n\n\treturn 0;\n}\n\nstatic void mtk_gmac0_rgmii_adjust(struct mtk_eth *eth,\n\t\t\t\t   phy_interface_t interface)\n{\n\tint ret;\n\n\tif (interface == PHY_INTERFACE_MODE_TRGMII) {\n\t\tmtk_w32(eth, TRGMII_MODE, INTF_MODE);\n\t\tret = clk_set_rate(eth->clks[MTK_CLK_TRGPLL], 500000000);\n\t\tif (ret)\n\t\t\tdev_err(eth->dev, \"Failed to set trgmii pll: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tdev_err(eth->dev, \"Missing PLL configuration, ethernet may not work\\n\");\n}\n\nstatic void mtk_setup_bridge_switch(struct mtk_eth *eth)\n{\n\t \n\tmtk_m32(eth, 0, MTK_XGMAC_FORCE_LINK(MTK_GMAC1_ID),\n\t\tMTK_XGMAC_STS(MTK_GMAC1_ID));\n\n\t \n\tmtk_m32(eth, GSWTX_IPG_MASK | GSWRX_IPG_MASK,\n\t\t(GSW_IPG_11 << GSWTX_IPG_SHIFT) |\n\t\t(GSW_IPG_11 << GSWRX_IPG_SHIFT),\n\t\tMTK_GSW_CFG);\n}\n\nstatic struct phylink_pcs *mtk_mac_select_pcs(struct phylink_config *config,\n\t\t\t\t\t      phy_interface_t interface)\n{\n\tstruct mtk_mac *mac = container_of(config, struct mtk_mac,\n\t\t\t\t\t   phylink_config);\n\tstruct mtk_eth *eth = mac->hw;\n\tunsigned int sid;\n\n\tif (interface == PHY_INTERFACE_MODE_SGMII ||\n\t    phy_interface_mode_is_8023z(interface)) {\n\t\tsid = (MTK_HAS_CAPS(eth->soc->caps, MTK_SHARED_SGMII)) ?\n\t\t       0 : mac->id;\n\n\t\treturn eth->sgmii_pcs[sid];\n\t}\n\n\treturn NULL;\n}\n\nstatic void mtk_mac_config(struct phylink_config *config, unsigned int mode,\n\t\t\t   const struct phylink_link_state *state)\n{\n\tstruct mtk_mac *mac = container_of(config, struct mtk_mac,\n\t\t\t\t\t   phylink_config);\n\tstruct mtk_eth *eth = mac->hw;\n\tint val, ge_mode, err = 0;\n\tu32 i;\n\n\t \n\tif (!MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628) &&\n\t    mac->interface != state->interface) {\n\t\t \n\t\tswitch (state->interface) {\n\t\tcase PHY_INTERFACE_MODE_TRGMII:\n\t\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tcase PHY_INTERFACE_MODE_MII:\n\t\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_RGMII)) {\n\t\t\t\terr = mtk_gmac_rgmii_path_setup(eth, mac->id);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto init_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\tcase PHY_INTERFACE_MODE_SGMII:\n\t\t\terr = mtk_gmac_sgmii_path_setup(eth, mac->id);\n\t\t\tif (err)\n\t\t\t\tgoto init_err;\n\t\t\tbreak;\n\t\tcase PHY_INTERFACE_MODE_GMII:\n\t\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_GEPHY)) {\n\t\t\t\terr = mtk_gmac_gephy_path_setup(eth, mac->id);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto init_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHY_INTERFACE_MODE_INTERNAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_phy;\n\t\t}\n\n\t\t \n\t\tif (!mac->id && state->interface != PHY_INTERFACE_MODE_SGMII &&\n\t\t    !phy_interface_mode_is_8023z(state->interface) &&\n\t\t    MTK_HAS_CAPS(mac->hw->soc->caps, MTK_GMAC1_TRGMII)) {\n\t\t\tif (MTK_HAS_CAPS(mac->hw->soc->caps,\n\t\t\t\t\t MTK_TRGMII_MT7621_CLK)) {\n\t\t\t\tif (mt7621_gmac0_rgmii_adjust(mac->hw,\n\t\t\t\t\t\t\t      state->interface))\n\t\t\t\t\tgoto err_phy;\n\t\t\t} else {\n\t\t\t\tmtk_gmac0_rgmii_adjust(mac->hw,\n\t\t\t\t\t\t       state->interface);\n\n\t\t\t\t \n\t\t\t\tfor (i = 0 ; i < NUM_TRGMII_CTRL; i++)\n\t\t\t\t\tmtk_w32(mac->hw,\n\t\t\t\t\t\tTD_DM_DRVP(8) | TD_DM_DRVN(8),\n\t\t\t\t\t\tTRGMII_TD_ODT(i));\n\n\t\t\t\t \n\t\t\t\tmtk_m32(mac->hw, 0, RXC_RST | RXC_DQSISEL,\n\t\t\t\t\tTRGMII_RCK_CTRL);\n\t\t\t\tmtk_m32(mac->hw, RXC_RST, 0, TRGMII_RCK_CTRL);\n\t\t\t}\n\t\t}\n\n\t\tswitch (state->interface) {\n\t\tcase PHY_INTERFACE_MODE_MII:\n\t\tcase PHY_INTERFACE_MODE_GMII:\n\t\t\tge_mode = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tge_mode = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tregmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);\n\t\tval &= ~SYSCFG0_GE_MODE(SYSCFG0_GE_MASK, mac->id);\n\t\tval |= SYSCFG0_GE_MODE(ge_mode, mac->id);\n\t\tregmap_write(eth->ethsys, ETHSYS_SYSCFG0, val);\n\n\t\tmac->interface = state->interface;\n\t}\n\n\t \n\tif (state->interface == PHY_INTERFACE_MODE_SGMII ||\n\t    phy_interface_mode_is_8023z(state->interface)) {\n\t\t \n\t\tregmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);\n\n\t\tregmap_update_bits(eth->ethsys, ETHSYS_SYSCFG0,\n\t\t\t\t   SYSCFG0_SGMII_MASK,\n\t\t\t\t   ~(u32)SYSCFG0_SGMII_MASK);\n\n\t\t \n\t\tmac->syscfg0 = val;\n\t} else if (phylink_autoneg_inband(mode)) {\n\t\tdev_err(eth->dev,\n\t\t\t\"In-band mode not supported in non SGMII mode!\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (mtk_is_netsys_v3_or_greater(eth) &&\n\t    mac->interface == PHY_INTERFACE_MODE_INTERNAL) {\n\t\tmtk_w32(mac->hw, MTK_GDMA_XGDM_SEL, MTK_GDMA_EG_CTRL(mac->id));\n\t\tmtk_w32(mac->hw, MAC_MCR_FORCE_LINK_DOWN, MTK_MAC_MCR(mac->id));\n\n\t\tmtk_setup_bridge_switch(eth);\n\t}\n\n\treturn;\n\nerr_phy:\n\tdev_err(eth->dev, \"%s: GMAC%d mode %s not supported!\\n\", __func__,\n\t\tmac->id, phy_modes(state->interface));\n\treturn;\n\ninit_err:\n\tdev_err(eth->dev, \"%s: GMAC%d mode %s err: %d!\\n\", __func__,\n\t\tmac->id, phy_modes(state->interface), err);\n}\n\nstatic int mtk_mac_finish(struct phylink_config *config, unsigned int mode,\n\t\t\t  phy_interface_t interface)\n{\n\tstruct mtk_mac *mac = container_of(config, struct mtk_mac,\n\t\t\t\t\t   phylink_config);\n\tstruct mtk_eth *eth = mac->hw;\n\tu32 mcr_cur, mcr_new;\n\n\t \n\tif (interface == PHY_INTERFACE_MODE_SGMII ||\n\t    phy_interface_mode_is_8023z(interface))\n\t\tregmap_update_bits(eth->ethsys, ETHSYS_SYSCFG0,\n\t\t\t\t   SYSCFG0_SGMII_MASK, mac->syscfg0);\n\n\t \n\tmcr_cur = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));\n\tmcr_new = mcr_cur;\n\tmcr_new |= MAC_MCR_IPG_CFG | MAC_MCR_FORCE_MODE |\n\t\t   MAC_MCR_BACKOFF_EN | MAC_MCR_BACKPR_EN | MAC_MCR_FORCE_LINK |\n\t\t   MAC_MCR_RX_FIFO_CLR_DIS;\n\n\t \n\tif (mcr_new != mcr_cur)\n\t\tmtk_w32(mac->hw, mcr_new, MTK_MAC_MCR(mac->id));\n\n\treturn 0;\n}\n\nstatic void mtk_mac_link_down(struct phylink_config *config, unsigned int mode,\n\t\t\t      phy_interface_t interface)\n{\n\tstruct mtk_mac *mac = container_of(config, struct mtk_mac,\n\t\t\t\t\t   phylink_config);\n\tu32 mcr = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));\n\n\tmcr &= ~(MAC_MCR_TX_EN | MAC_MCR_RX_EN);\n\tmtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));\n}\n\nstatic void mtk_set_queue_speed(struct mtk_eth *eth, unsigned int idx,\n\t\t\t\tint speed)\n{\n\tconst struct mtk_soc_data *soc = eth->soc;\n\tu32 ofs, val;\n\n\tif (!MTK_HAS_CAPS(soc->caps, MTK_QDMA))\n\t\treturn;\n\n\tval = MTK_QTX_SCH_MIN_RATE_EN |\n\t       \n\t      FIELD_PREP(MTK_QTX_SCH_MIN_RATE_MAN, 1) |\n\t      FIELD_PREP(MTK_QTX_SCH_MIN_RATE_EXP, 4) |\n\t      MTK_QTX_SCH_LEAKY_BUCKET_SIZE;\n\tif (mtk_is_netsys_v1(eth))\n\t\tval |= MTK_QTX_SCH_LEAKY_BUCKET_EN;\n\n\tif (IS_ENABLED(CONFIG_SOC_MT7621)) {\n\t\tswitch (speed) {\n\t\tcase SPEED_10:\n\t\t\tval |= MTK_QTX_SCH_MAX_RATE_EN |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_MAN, 103) |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_EXP, 2) |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_WEIGHT, 1);\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tval |= MTK_QTX_SCH_MAX_RATE_EN |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_MAN, 103) |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_EXP, 3);\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_WEIGHT, 1);\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tval |= MTK_QTX_SCH_MAX_RATE_EN |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_MAN, 105) |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_EXP, 4) |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_WEIGHT, 10);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (speed) {\n\t\tcase SPEED_10:\n\t\t\tval |= MTK_QTX_SCH_MAX_RATE_EN |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_MAN, 1) |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_EXP, 4) |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_WEIGHT, 1);\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tval |= MTK_QTX_SCH_MAX_RATE_EN |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_MAN, 1) |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_EXP, 5);\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_WEIGHT, 1);\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tval |= MTK_QTX_SCH_MAX_RATE_EN |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_MAN, 10) |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_EXP, 5) |\n\t\t\t       FIELD_PREP(MTK_QTX_SCH_MAX_RATE_WEIGHT, 10);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tofs = MTK_QTX_OFFSET * idx;\n\tmtk_w32(eth, val, soc->reg_map->qdma.qtx_sch + ofs);\n}\n\nstatic void mtk_mac_link_up(struct phylink_config *config,\n\t\t\t    struct phy_device *phy,\n\t\t\t    unsigned int mode, phy_interface_t interface,\n\t\t\t    int speed, int duplex, bool tx_pause, bool rx_pause)\n{\n\tstruct mtk_mac *mac = container_of(config, struct mtk_mac,\n\t\t\t\t\t   phylink_config);\n\tu32 mcr;\n\n\tmcr = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));\n\tmcr &= ~(MAC_MCR_SPEED_100 | MAC_MCR_SPEED_1000 |\n\t\t MAC_MCR_FORCE_DPX | MAC_MCR_FORCE_TX_FC |\n\t\t MAC_MCR_FORCE_RX_FC);\n\n\t \n\tmac->speed = speed;\n\tswitch (speed) {\n\tcase SPEED_2500:\n\tcase SPEED_1000:\n\t\tmcr |= MAC_MCR_SPEED_1000;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tmcr |= MAC_MCR_SPEED_100;\n\t\tbreak;\n\t}\n\n\t \n\tif (duplex == DUPLEX_FULL)\n\t\tmcr |= MAC_MCR_FORCE_DPX;\n\n\t \n\tif (tx_pause)\n\t\tmcr |= MAC_MCR_FORCE_TX_FC;\n\tif (rx_pause)\n\t\tmcr |= MAC_MCR_FORCE_RX_FC;\n\n\tmcr |= MAC_MCR_TX_EN | MAC_MCR_RX_EN;\n\tmtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));\n}\n\nstatic const struct phylink_mac_ops mtk_phylink_ops = {\n\t.mac_select_pcs = mtk_mac_select_pcs,\n\t.mac_config = mtk_mac_config,\n\t.mac_finish = mtk_mac_finish,\n\t.mac_link_down = mtk_mac_link_down,\n\t.mac_link_up = mtk_mac_link_up,\n};\n\nstatic int mtk_mdio_init(struct mtk_eth *eth)\n{\n\tunsigned int max_clk = 2500000, divider;\n\tstruct device_node *mii_np;\n\tint ret;\n\tu32 val;\n\n\tmii_np = of_get_child_by_name(eth->dev->of_node, \"mdio-bus\");\n\tif (!mii_np) {\n\t\tdev_err(eth->dev, \"no %s child node found\", \"mdio-bus\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!of_device_is_available(mii_np)) {\n\t\tret = -ENODEV;\n\t\tgoto err_put_node;\n\t}\n\n\teth->mii_bus = devm_mdiobus_alloc(eth->dev);\n\tif (!eth->mii_bus) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_node;\n\t}\n\n\teth->mii_bus->name = \"mdio\";\n\teth->mii_bus->read = mtk_mdio_read_c22;\n\teth->mii_bus->write = mtk_mdio_write_c22;\n\teth->mii_bus->read_c45 = mtk_mdio_read_c45;\n\teth->mii_bus->write_c45 = mtk_mdio_write_c45;\n\teth->mii_bus->priv = eth;\n\teth->mii_bus->parent = eth->dev;\n\n\tsnprintf(eth->mii_bus->id, MII_BUS_ID_SIZE, \"%pOFn\", mii_np);\n\n\tif (!of_property_read_u32(mii_np, \"clock-frequency\", &val)) {\n\t\tif (val > MDC_MAX_FREQ || val < MDC_MAX_FREQ / MDC_MAX_DIVIDER) {\n\t\t\tdev_err(eth->dev, \"MDIO clock frequency out of range\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_put_node;\n\t\t}\n\t\tmax_clk = val;\n\t}\n\tdivider = min_t(unsigned int, DIV_ROUND_UP(MDC_MAX_FREQ, max_clk), 63);\n\n\t \n\tif (mtk_is_netsys_v3_or_greater(eth))\n\t\tmtk_m32(eth, 0, MISC_MDC_TURBO, MTK_MAC_MISC_V3);\n\n\t \n\tval = FIELD_PREP(PPSC_MDC_CFG, divider);\n\tif (!mtk_is_netsys_v3_or_greater(eth))\n\t\tval |= PPSC_MDC_TURBO;\n\tmtk_m32(eth, PPSC_MDC_CFG, val, MTK_PPSC);\n\n\tdev_dbg(eth->dev, \"MDC is running on %d Hz\\n\", MDC_MAX_FREQ / divider);\n\n\tret = of_mdiobus_register(eth->mii_bus, mii_np);\n\nerr_put_node:\n\tof_node_put(mii_np);\n\treturn ret;\n}\n\nstatic void mtk_mdio_cleanup(struct mtk_eth *eth)\n{\n\tif (!eth->mii_bus)\n\t\treturn;\n\n\tmdiobus_unregister(eth->mii_bus);\n}\n\nstatic inline void mtk_tx_irq_disable(struct mtk_eth *eth, u32 mask)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&eth->tx_irq_lock, flags);\n\tval = mtk_r32(eth, eth->soc->reg_map->tx_irq_mask);\n\tmtk_w32(eth, val & ~mask, eth->soc->reg_map->tx_irq_mask);\n\tspin_unlock_irqrestore(&eth->tx_irq_lock, flags);\n}\n\nstatic inline void mtk_tx_irq_enable(struct mtk_eth *eth, u32 mask)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&eth->tx_irq_lock, flags);\n\tval = mtk_r32(eth, eth->soc->reg_map->tx_irq_mask);\n\tmtk_w32(eth, val | mask, eth->soc->reg_map->tx_irq_mask);\n\tspin_unlock_irqrestore(&eth->tx_irq_lock, flags);\n}\n\nstatic inline void mtk_rx_irq_disable(struct mtk_eth *eth, u32 mask)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&eth->rx_irq_lock, flags);\n\tval = mtk_r32(eth, eth->soc->reg_map->pdma.irq_mask);\n\tmtk_w32(eth, val & ~mask, eth->soc->reg_map->pdma.irq_mask);\n\tspin_unlock_irqrestore(&eth->rx_irq_lock, flags);\n}\n\nstatic inline void mtk_rx_irq_enable(struct mtk_eth *eth, u32 mask)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&eth->rx_irq_lock, flags);\n\tval = mtk_r32(eth, eth->soc->reg_map->pdma.irq_mask);\n\tmtk_w32(eth, val | mask, eth->soc->reg_map->pdma.irq_mask);\n\tspin_unlock_irqrestore(&eth->rx_irq_lock, flags);\n}\n\nstatic int mtk_set_mac_address(struct net_device *dev, void *p)\n{\n\tint ret = eth_mac_addr(dev, p);\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\tconst char *macaddr = dev->dev_addr;\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))\n\t\treturn -EBUSY;\n\n\tspin_lock_bh(&mac->hw->page_lock);\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628)) {\n\t\tmtk_w32(mac->hw, (macaddr[0] << 8) | macaddr[1],\n\t\t\tMT7628_SDM_MAC_ADRH);\n\t\tmtk_w32(mac->hw, (macaddr[2] << 24) | (macaddr[3] << 16) |\n\t\t\t(macaddr[4] << 8) | macaddr[5],\n\t\t\tMT7628_SDM_MAC_ADRL);\n\t} else {\n\t\tmtk_w32(mac->hw, (macaddr[0] << 8) | macaddr[1],\n\t\t\tMTK_GDMA_MAC_ADRH(mac->id));\n\t\tmtk_w32(mac->hw, (macaddr[2] << 24) | (macaddr[3] << 16) |\n\t\t\t(macaddr[4] << 8) | macaddr[5],\n\t\t\tMTK_GDMA_MAC_ADRL(mac->id));\n\t}\n\tspin_unlock_bh(&mac->hw->page_lock);\n\n\treturn 0;\n}\n\nvoid mtk_stats_update_mac(struct mtk_mac *mac)\n{\n\tstruct mtk_hw_stats *hw_stats = mac->hw_stats;\n\tstruct mtk_eth *eth = mac->hw;\n\n\tu64_stats_update_begin(&hw_stats->syncp);\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628)) {\n\t\thw_stats->tx_packets += mtk_r32(mac->hw, MT7628_SDM_TPCNT);\n\t\thw_stats->tx_bytes += mtk_r32(mac->hw, MT7628_SDM_TBCNT);\n\t\thw_stats->rx_packets += mtk_r32(mac->hw, MT7628_SDM_RPCNT);\n\t\thw_stats->rx_bytes += mtk_r32(mac->hw, MT7628_SDM_RBCNT);\n\t\thw_stats->rx_checksum_errors +=\n\t\t\tmtk_r32(mac->hw, MT7628_SDM_CS_ERR);\n\t} else {\n\t\tconst struct mtk_reg_map *reg_map = eth->soc->reg_map;\n\t\tunsigned int offs = hw_stats->reg_offset;\n\t\tu64 stats;\n\n\t\thw_stats->rx_bytes += mtk_r32(mac->hw, reg_map->gdm1_cnt + offs);\n\t\tstats = mtk_r32(mac->hw, reg_map->gdm1_cnt + 0x4 + offs);\n\t\tif (stats)\n\t\t\thw_stats->rx_bytes += (stats << 32);\n\t\thw_stats->rx_packets +=\n\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x8 + offs);\n\t\thw_stats->rx_overflow +=\n\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x10 + offs);\n\t\thw_stats->rx_fcs_errors +=\n\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x14 + offs);\n\t\thw_stats->rx_short_errors +=\n\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x18 + offs);\n\t\thw_stats->rx_long_errors +=\n\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x1c + offs);\n\t\thw_stats->rx_checksum_errors +=\n\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x20 + offs);\n\t\thw_stats->rx_flow_control_packets +=\n\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x24 + offs);\n\n\t\tif (mtk_is_netsys_v3_or_greater(eth)) {\n\t\t\thw_stats->tx_skip +=\n\t\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x50 + offs);\n\t\t\thw_stats->tx_collisions +=\n\t\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x54 + offs);\n\t\t\thw_stats->tx_bytes +=\n\t\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x40 + offs);\n\t\t\tstats =  mtk_r32(mac->hw, reg_map->gdm1_cnt + 0x44 + offs);\n\t\t\tif (stats)\n\t\t\t\thw_stats->tx_bytes += (stats << 32);\n\t\t\thw_stats->tx_packets +=\n\t\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x48 + offs);\n\t\t} else {\n\t\t\thw_stats->tx_skip +=\n\t\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x28 + offs);\n\t\t\thw_stats->tx_collisions +=\n\t\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x2c + offs);\n\t\t\thw_stats->tx_bytes +=\n\t\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x30 + offs);\n\t\t\tstats =  mtk_r32(mac->hw, reg_map->gdm1_cnt + 0x34 + offs);\n\t\t\tif (stats)\n\t\t\t\thw_stats->tx_bytes += (stats << 32);\n\t\t\thw_stats->tx_packets +=\n\t\t\t\tmtk_r32(mac->hw, reg_map->gdm1_cnt + 0x38 + offs);\n\t\t}\n\t}\n\n\tu64_stats_update_end(&hw_stats->syncp);\n}\n\nstatic void mtk_stats_update(struct mtk_eth *eth)\n{\n\tint i;\n\n\tfor (i = 0; i < MTK_MAX_DEVS; i++) {\n\t\tif (!eth->mac[i] || !eth->mac[i]->hw_stats)\n\t\t\tcontinue;\n\t\tif (spin_trylock(&eth->mac[i]->hw_stats->stats_lock)) {\n\t\t\tmtk_stats_update_mac(eth->mac[i]);\n\t\t\tspin_unlock(&eth->mac[i]->hw_stats->stats_lock);\n\t\t}\n\t}\n}\n\nstatic void mtk_get_stats64(struct net_device *dev,\n\t\t\t    struct rtnl_link_stats64 *storage)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_hw_stats *hw_stats = mac->hw_stats;\n\tunsigned int start;\n\n\tif (netif_running(dev) && netif_device_present(dev)) {\n\t\tif (spin_trylock_bh(&hw_stats->stats_lock)) {\n\t\t\tmtk_stats_update_mac(mac);\n\t\t\tspin_unlock_bh(&hw_stats->stats_lock);\n\t\t}\n\t}\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&hw_stats->syncp);\n\t\tstorage->rx_packets = hw_stats->rx_packets;\n\t\tstorage->tx_packets = hw_stats->tx_packets;\n\t\tstorage->rx_bytes = hw_stats->rx_bytes;\n\t\tstorage->tx_bytes = hw_stats->tx_bytes;\n\t\tstorage->collisions = hw_stats->tx_collisions;\n\t\tstorage->rx_length_errors = hw_stats->rx_short_errors +\n\t\t\thw_stats->rx_long_errors;\n\t\tstorage->rx_over_errors = hw_stats->rx_overflow;\n\t\tstorage->rx_crc_errors = hw_stats->rx_fcs_errors;\n\t\tstorage->rx_errors = hw_stats->rx_checksum_errors;\n\t\tstorage->tx_aborted_errors = hw_stats->tx_skip;\n\t} while (u64_stats_fetch_retry(&hw_stats->syncp, start));\n\n\tstorage->tx_errors = dev->stats.tx_errors;\n\tstorage->rx_dropped = dev->stats.rx_dropped;\n\tstorage->tx_dropped = dev->stats.tx_dropped;\n}\n\nstatic inline int mtk_max_frag_size(int mtu)\n{\n\t \n\tif (mtu + MTK_RX_ETH_HLEN < MTK_MAX_RX_LENGTH_2K)\n\t\tmtu = MTK_MAX_RX_LENGTH_2K - MTK_RX_ETH_HLEN;\n\n\treturn SKB_DATA_ALIGN(MTK_RX_HLEN + mtu) +\n\t\tSKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n}\n\nstatic inline int mtk_max_buf_size(int frag_size)\n{\n\tint buf_size = frag_size - NET_SKB_PAD - NET_IP_ALIGN -\n\t\t       SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\n\tWARN_ON(buf_size < MTK_MAX_RX_LENGTH_2K);\n\n\treturn buf_size;\n}\n\nstatic bool mtk_rx_get_desc(struct mtk_eth *eth, struct mtk_rx_dma_v2 *rxd,\n\t\t\t    struct mtk_rx_dma_v2 *dma_rxd)\n{\n\trxd->rxd2 = READ_ONCE(dma_rxd->rxd2);\n\tif (!(rxd->rxd2 & RX_DMA_DONE))\n\t\treturn false;\n\n\trxd->rxd1 = READ_ONCE(dma_rxd->rxd1);\n\trxd->rxd3 = READ_ONCE(dma_rxd->rxd3);\n\trxd->rxd4 = READ_ONCE(dma_rxd->rxd4);\n\tif (mtk_is_netsys_v2_or_greater(eth)) {\n\t\trxd->rxd5 = READ_ONCE(dma_rxd->rxd5);\n\t\trxd->rxd6 = READ_ONCE(dma_rxd->rxd6);\n\t}\n\n\treturn true;\n}\n\nstatic void *mtk_max_lro_buf_alloc(gfp_t gfp_mask)\n{\n\tunsigned int size = mtk_max_frag_size(MTK_MAX_LRO_RX_LENGTH);\n\tunsigned long data;\n\n\tdata = __get_free_pages(gfp_mask | __GFP_COMP | __GFP_NOWARN,\n\t\t\t\tget_order(size));\n\n\treturn (void *)data;\n}\n\n \nstatic int mtk_init_fq_dma(struct mtk_eth *eth)\n{\n\tconst struct mtk_soc_data *soc = eth->soc;\n\tdma_addr_t phy_ring_tail;\n\tint cnt = MTK_QDMA_RING_SIZE;\n\tdma_addr_t dma_addr;\n\tint i;\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SRAM))\n\t\teth->scratch_ring = eth->sram_base;\n\telse\n\t\teth->scratch_ring = dma_alloc_coherent(eth->dma_dev,\n\t\t\t\t\t\t       cnt * soc->txrx.txd_size,\n\t\t\t\t\t\t       &eth->phy_scratch_ring,\n\t\t\t\t\t\t       GFP_KERNEL);\n\tif (unlikely(!eth->scratch_ring))\n\t\treturn -ENOMEM;\n\n\teth->scratch_head = kcalloc(cnt, MTK_QDMA_PAGE_SIZE, GFP_KERNEL);\n\tif (unlikely(!eth->scratch_head))\n\t\treturn -ENOMEM;\n\n\tdma_addr = dma_map_single(eth->dma_dev,\n\t\t\t\t  eth->scratch_head, cnt * MTK_QDMA_PAGE_SIZE,\n\t\t\t\t  DMA_FROM_DEVICE);\n\tif (unlikely(dma_mapping_error(eth->dma_dev, dma_addr)))\n\t\treturn -ENOMEM;\n\n\tphy_ring_tail = eth->phy_scratch_ring + soc->txrx.txd_size * (cnt - 1);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tstruct mtk_tx_dma_v2 *txd;\n\n\t\ttxd = eth->scratch_ring + i * soc->txrx.txd_size;\n\t\ttxd->txd1 = dma_addr + i * MTK_QDMA_PAGE_SIZE;\n\t\tif (i < cnt - 1)\n\t\t\ttxd->txd2 = eth->phy_scratch_ring +\n\t\t\t\t    (i + 1) * soc->txrx.txd_size;\n\n\t\ttxd->txd3 = TX_DMA_PLEN0(MTK_QDMA_PAGE_SIZE);\n\t\ttxd->txd4 = 0;\n\t\tif (mtk_is_netsys_v2_or_greater(eth)) {\n\t\t\ttxd->txd5 = 0;\n\t\t\ttxd->txd6 = 0;\n\t\t\ttxd->txd7 = 0;\n\t\t\ttxd->txd8 = 0;\n\t\t}\n\t}\n\n\tmtk_w32(eth, eth->phy_scratch_ring, soc->reg_map->qdma.fq_head);\n\tmtk_w32(eth, phy_ring_tail, soc->reg_map->qdma.fq_tail);\n\tmtk_w32(eth, (cnt << 16) | cnt, soc->reg_map->qdma.fq_count);\n\tmtk_w32(eth, MTK_QDMA_PAGE_SIZE << 16, soc->reg_map->qdma.fq_blen);\n\n\treturn 0;\n}\n\nstatic void *mtk_qdma_phys_to_virt(struct mtk_tx_ring *ring, u32 desc)\n{\n\treturn ring->dma + (desc - ring->phys);\n}\n\nstatic struct mtk_tx_buf *mtk_desc_to_tx_buf(struct mtk_tx_ring *ring,\n\t\t\t\t\t     void *txd, u32 txd_size)\n{\n\tint idx = (txd - ring->dma) / txd_size;\n\n\treturn &ring->buf[idx];\n}\n\nstatic struct mtk_tx_dma *qdma_to_pdma(struct mtk_tx_ring *ring,\n\t\t\t\t       struct mtk_tx_dma *dma)\n{\n\treturn ring->dma_pdma - (struct mtk_tx_dma *)ring->dma + dma;\n}\n\nstatic int txd_to_idx(struct mtk_tx_ring *ring, void *dma, u32 txd_size)\n{\n\treturn (dma - ring->dma) / txd_size;\n}\n\nstatic void mtk_tx_unmap(struct mtk_eth *eth, struct mtk_tx_buf *tx_buf,\n\t\t\t struct xdp_frame_bulk *bq, bool napi)\n{\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA)) {\n\t\tif (tx_buf->flags & MTK_TX_FLAGS_SINGLE0) {\n\t\t\tdma_unmap_single(eth->dma_dev,\n\t\t\t\t\t dma_unmap_addr(tx_buf, dma_addr0),\n\t\t\t\t\t dma_unmap_len(tx_buf, dma_len0),\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t} else if (tx_buf->flags & MTK_TX_FLAGS_PAGE0) {\n\t\t\tdma_unmap_page(eth->dma_dev,\n\t\t\t\t       dma_unmap_addr(tx_buf, dma_addr0),\n\t\t\t\t       dma_unmap_len(tx_buf, dma_len0),\n\t\t\t\t       DMA_TO_DEVICE);\n\t\t}\n\t} else {\n\t\tif (dma_unmap_len(tx_buf, dma_len0)) {\n\t\t\tdma_unmap_page(eth->dma_dev,\n\t\t\t\t       dma_unmap_addr(tx_buf, dma_addr0),\n\t\t\t\t       dma_unmap_len(tx_buf, dma_len0),\n\t\t\t\t       DMA_TO_DEVICE);\n\t\t}\n\n\t\tif (dma_unmap_len(tx_buf, dma_len1)) {\n\t\t\tdma_unmap_page(eth->dma_dev,\n\t\t\t\t       dma_unmap_addr(tx_buf, dma_addr1),\n\t\t\t\t       dma_unmap_len(tx_buf, dma_len1),\n\t\t\t\t       DMA_TO_DEVICE);\n\t\t}\n\t}\n\n\tif (tx_buf->data && tx_buf->data != (void *)MTK_DMA_DUMMY_DESC) {\n\t\tif (tx_buf->type == MTK_TYPE_SKB) {\n\t\t\tstruct sk_buff *skb = tx_buf->data;\n\n\t\t\tif (napi)\n\t\t\t\tnapi_consume_skb(skb, napi);\n\t\t\telse\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t} else {\n\t\t\tstruct xdp_frame *xdpf = tx_buf->data;\n\n\t\t\tif (napi && tx_buf->type == MTK_TYPE_XDP_TX)\n\t\t\t\txdp_return_frame_rx_napi(xdpf);\n\t\t\telse if (bq)\n\t\t\t\txdp_return_frame_bulk(xdpf, bq);\n\t\t\telse\n\t\t\t\txdp_return_frame(xdpf);\n\t\t}\n\t}\n\ttx_buf->flags = 0;\n\ttx_buf->data = NULL;\n}\n\nstatic void setup_tx_buf(struct mtk_eth *eth, struct mtk_tx_buf *tx_buf,\n\t\t\t struct mtk_tx_dma *txd, dma_addr_t mapped_addr,\n\t\t\t size_t size, int idx)\n{\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA)) {\n\t\tdma_unmap_addr_set(tx_buf, dma_addr0, mapped_addr);\n\t\tdma_unmap_len_set(tx_buf, dma_len0, size);\n\t} else {\n\t\tif (idx & 1) {\n\t\t\ttxd->txd3 = mapped_addr;\n\t\t\ttxd->txd2 |= TX_DMA_PLEN1(size);\n\t\t\tdma_unmap_addr_set(tx_buf, dma_addr1, mapped_addr);\n\t\t\tdma_unmap_len_set(tx_buf, dma_len1, size);\n\t\t} else {\n\t\t\ttx_buf->data = (void *)MTK_DMA_DUMMY_DESC;\n\t\t\ttxd->txd1 = mapped_addr;\n\t\t\ttxd->txd2 = TX_DMA_PLEN0(size);\n\t\t\tdma_unmap_addr_set(tx_buf, dma_addr0, mapped_addr);\n\t\t\tdma_unmap_len_set(tx_buf, dma_len0, size);\n\t\t}\n\t}\n}\n\nstatic void mtk_tx_set_dma_desc_v1(struct net_device *dev, void *txd,\n\t\t\t\t   struct mtk_tx_dma_desc_info *info)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\tstruct mtk_tx_dma *desc = txd;\n\tu32 data;\n\n\tWRITE_ONCE(desc->txd1, info->addr);\n\n\tdata = TX_DMA_SWC | TX_DMA_PLEN0(info->size) |\n\t       FIELD_PREP(TX_DMA_PQID, info->qid);\n\tif (info->last)\n\t\tdata |= TX_DMA_LS0;\n\tWRITE_ONCE(desc->txd3, data);\n\n\tdata = (mac->id + 1) << TX_DMA_FPORT_SHIFT;  \n\tif (info->first) {\n\t\tif (info->gso)\n\t\t\tdata |= TX_DMA_TSO;\n\t\t \n\t\tif (info->csum)\n\t\t\tdata |= TX_DMA_CHKSUM;\n\t\t \n\t\tif (info->vlan)\n\t\t\tdata |= TX_DMA_INS_VLAN | info->vlan_tci;\n\t}\n\tWRITE_ONCE(desc->txd4, data);\n}\n\nstatic void mtk_tx_set_dma_desc_v2(struct net_device *dev, void *txd,\n\t\t\t\t   struct mtk_tx_dma_desc_info *info)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_tx_dma_v2 *desc = txd;\n\tstruct mtk_eth *eth = mac->hw;\n\tu32 data;\n\n\tWRITE_ONCE(desc->txd1, info->addr);\n\n\tdata = TX_DMA_PLEN0(info->size);\n\tif (info->last)\n\t\tdata |= TX_DMA_LS0;\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_36BIT_DMA))\n\t\tdata |= TX_DMA_PREP_ADDR64(info->addr);\n\n\tWRITE_ONCE(desc->txd3, data);\n\n\t  \n\tswitch (mac->id) {\n\tcase MTK_GMAC1_ID:\n\t\tdata = PSE_GDM1_PORT << TX_DMA_FPORT_SHIFT_V2;\n\t\tbreak;\n\tcase MTK_GMAC2_ID:\n\t\tdata = PSE_GDM2_PORT << TX_DMA_FPORT_SHIFT_V2;\n\t\tbreak;\n\tcase MTK_GMAC3_ID:\n\t\tdata = PSE_GDM3_PORT << TX_DMA_FPORT_SHIFT_V2;\n\t\tbreak;\n\t}\n\n\tdata |= TX_DMA_SWC_V2 | QID_BITS_V2(info->qid);\n\tWRITE_ONCE(desc->txd4, data);\n\n\tdata = 0;\n\tif (info->first) {\n\t\tif (info->gso)\n\t\t\tdata |= TX_DMA_TSO_V2;\n\t\t \n\t\tif (info->csum)\n\t\t\tdata |= TX_DMA_CHKSUM_V2;\n\t\tif (mtk_is_netsys_v3_or_greater(eth) && netdev_uses_dsa(dev))\n\t\t\tdata |= TX_DMA_SPTAG_V3;\n\t}\n\tWRITE_ONCE(desc->txd5, data);\n\n\tdata = 0;\n\tif (info->first && info->vlan)\n\t\tdata |= TX_DMA_INS_VLAN_V2 | info->vlan_tci;\n\tWRITE_ONCE(desc->txd6, data);\n\n\tWRITE_ONCE(desc->txd7, 0);\n\tWRITE_ONCE(desc->txd8, 0);\n}\n\nstatic void mtk_tx_set_dma_desc(struct net_device *dev, void *txd,\n\t\t\t\tstruct mtk_tx_dma_desc_info *info)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\n\tif (mtk_is_netsys_v2_or_greater(eth))\n\t\tmtk_tx_set_dma_desc_v2(dev, txd, info);\n\telse\n\t\tmtk_tx_set_dma_desc_v1(dev, txd, info);\n}\n\nstatic int mtk_tx_map(struct sk_buff *skb, struct net_device *dev,\n\t\t      int tx_num, struct mtk_tx_ring *ring, bool gso)\n{\n\tstruct mtk_tx_dma_desc_info txd_info = {\n\t\t.size = skb_headlen(skb),\n\t\t.gso = gso,\n\t\t.csum = skb->ip_summed == CHECKSUM_PARTIAL,\n\t\t.vlan = skb_vlan_tag_present(skb),\n\t\t.qid = skb_get_queue_mapping(skb),\n\t\t.vlan_tci = skb_vlan_tag_get(skb),\n\t\t.first = true,\n\t\t.last = !skb_is_nonlinear(skb),\n\t};\n\tstruct netdev_queue *txq;\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\tconst struct mtk_soc_data *soc = eth->soc;\n\tstruct mtk_tx_dma *itxd, *txd;\n\tstruct mtk_tx_dma *itxd_pdma, *txd_pdma;\n\tstruct mtk_tx_buf *itx_buf, *tx_buf;\n\tint i, n_desc = 1;\n\tint queue = skb_get_queue_mapping(skb);\n\tint k = 0;\n\n\ttxq = netdev_get_tx_queue(dev, queue);\n\titxd = ring->next_free;\n\titxd_pdma = qdma_to_pdma(ring, itxd);\n\tif (itxd == ring->last_free)\n\t\treturn -ENOMEM;\n\n\titx_buf = mtk_desc_to_tx_buf(ring, itxd, soc->txrx.txd_size);\n\tmemset(itx_buf, 0, sizeof(*itx_buf));\n\n\ttxd_info.addr = dma_map_single(eth->dma_dev, skb->data, txd_info.size,\n\t\t\t\t       DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(eth->dma_dev, txd_info.addr)))\n\t\treturn -ENOMEM;\n\n\tmtk_tx_set_dma_desc(dev, itxd, &txd_info);\n\n\titx_buf->flags |= MTK_TX_FLAGS_SINGLE0;\n\titx_buf->mac_id = mac->id;\n\tsetup_tx_buf(eth, itx_buf, itxd_pdma, txd_info.addr, txd_info.size,\n\t\t     k++);\n\n\t \n\ttxd = itxd;\n\ttxd_pdma = qdma_to_pdma(ring, txd);\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tunsigned int offset = 0;\n\t\tint frag_size = skb_frag_size(frag);\n\n\t\twhile (frag_size) {\n\t\t\tbool new_desc = true;\n\n\t\t\tif (MTK_HAS_CAPS(soc->caps, MTK_QDMA) ||\n\t\t\t    (i & 0x1)) {\n\t\t\t\ttxd = mtk_qdma_phys_to_virt(ring, txd->txd2);\n\t\t\t\ttxd_pdma = qdma_to_pdma(ring, txd);\n\t\t\t\tif (txd == ring->last_free)\n\t\t\t\t\tgoto err_dma;\n\n\t\t\t\tn_desc++;\n\t\t\t} else {\n\t\t\t\tnew_desc = false;\n\t\t\t}\n\n\t\t\tmemset(&txd_info, 0, sizeof(struct mtk_tx_dma_desc_info));\n\t\t\ttxd_info.size = min_t(unsigned int, frag_size,\n\t\t\t\t\t      soc->txrx.dma_max_len);\n\t\t\ttxd_info.qid = queue;\n\t\t\ttxd_info.last = i == skb_shinfo(skb)->nr_frags - 1 &&\n\t\t\t\t\t!(frag_size - txd_info.size);\n\t\t\ttxd_info.addr = skb_frag_dma_map(eth->dma_dev, frag,\n\t\t\t\t\t\t\t offset, txd_info.size,\n\t\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tif (unlikely(dma_mapping_error(eth->dma_dev, txd_info.addr)))\n\t\t\t\tgoto err_dma;\n\n\t\t\tmtk_tx_set_dma_desc(dev, txd, &txd_info);\n\n\t\t\ttx_buf = mtk_desc_to_tx_buf(ring, txd,\n\t\t\t\t\t\t    soc->txrx.txd_size);\n\t\t\tif (new_desc)\n\t\t\t\tmemset(tx_buf, 0, sizeof(*tx_buf));\n\t\t\ttx_buf->data = (void *)MTK_DMA_DUMMY_DESC;\n\t\t\ttx_buf->flags |= MTK_TX_FLAGS_PAGE0;\n\t\t\ttx_buf->mac_id = mac->id;\n\n\t\t\tsetup_tx_buf(eth, tx_buf, txd_pdma, txd_info.addr,\n\t\t\t\t     txd_info.size, k++);\n\n\t\t\tfrag_size -= txd_info.size;\n\t\t\toffset += txd_info.size;\n\t\t}\n\t}\n\n\t \n\titx_buf->type = MTK_TYPE_SKB;\n\titx_buf->data = skb;\n\n\tif (!MTK_HAS_CAPS(soc->caps, MTK_QDMA)) {\n\t\tif (k & 0x1)\n\t\t\ttxd_pdma->txd2 |= TX_DMA_LS0;\n\t\telse\n\t\t\ttxd_pdma->txd2 |= TX_DMA_LS1;\n\t}\n\n\tnetdev_tx_sent_queue(txq, skb->len);\n\tskb_tx_timestamp(skb);\n\n\tring->next_free = mtk_qdma_phys_to_virt(ring, txd->txd2);\n\tatomic_sub(n_desc, &ring->free_count);\n\n\t \n\twmb();\n\n\tif (MTK_HAS_CAPS(soc->caps, MTK_QDMA)) {\n\t\tif (netif_xmit_stopped(txq) || !netdev_xmit_more())\n\t\t\tmtk_w32(eth, txd->txd2, soc->reg_map->qdma.ctx_ptr);\n\t} else {\n\t\tint next_idx;\n\n\t\tnext_idx = NEXT_DESP_IDX(txd_to_idx(ring, txd, soc->txrx.txd_size),\n\t\t\t\t\t ring->dma_size);\n\t\tmtk_w32(eth, next_idx, MT7628_TX_CTX_IDX0);\n\t}\n\n\treturn 0;\n\nerr_dma:\n\tdo {\n\t\ttx_buf = mtk_desc_to_tx_buf(ring, itxd, soc->txrx.txd_size);\n\n\t\t \n\t\tmtk_tx_unmap(eth, tx_buf, NULL, false);\n\n\t\titxd->txd3 = TX_DMA_LS0 | TX_DMA_OWNER_CPU;\n\t\tif (!MTK_HAS_CAPS(soc->caps, MTK_QDMA))\n\t\t\titxd_pdma->txd2 = TX_DMA_DESP2_DEF;\n\n\t\titxd = mtk_qdma_phys_to_virt(ring, itxd->txd2);\n\t\titxd_pdma = qdma_to_pdma(ring, itxd);\n\t} while (itxd != txd);\n\n\treturn -ENOMEM;\n}\n\nstatic int mtk_cal_txd_req(struct mtk_eth *eth, struct sk_buff *skb)\n{\n\tint i, nfrags = 1;\n\tskb_frag_t *frag;\n\n\tif (skb_is_gso(skb)) {\n\t\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\t\tfrag = &skb_shinfo(skb)->frags[i];\n\t\t\tnfrags += DIV_ROUND_UP(skb_frag_size(frag),\n\t\t\t\t\t       eth->soc->txrx.dma_max_len);\n\t\t}\n\t} else {\n\t\tnfrags += skb_shinfo(skb)->nr_frags;\n\t}\n\n\treturn nfrags;\n}\n\nstatic int mtk_queue_stopped(struct mtk_eth *eth)\n{\n\tint i;\n\n\tfor (i = 0; i < MTK_MAX_DEVS; i++) {\n\t\tif (!eth->netdev[i])\n\t\t\tcontinue;\n\t\tif (netif_queue_stopped(eth->netdev[i]))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_wake_queue(struct mtk_eth *eth)\n{\n\tint i;\n\n\tfor (i = 0; i < MTK_MAX_DEVS; i++) {\n\t\tif (!eth->netdev[i])\n\t\t\tcontinue;\n\t\tnetif_tx_wake_all_queues(eth->netdev[i]);\n\t}\n}\n\nstatic netdev_tx_t mtk_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\tstruct mtk_tx_ring *ring = &eth->tx_ring;\n\tstruct net_device_stats *stats = &dev->stats;\n\tbool gso = false;\n\tint tx_num;\n\n\t \n\tspin_lock(&eth->page_lock);\n\n\tif (unlikely(test_bit(MTK_RESETTING, &eth->state)))\n\t\tgoto drop;\n\n\ttx_num = mtk_cal_txd_req(eth, skb);\n\tif (unlikely(atomic_read(&ring->free_count) <= tx_num)) {\n\t\tnetif_tx_stop_all_queues(dev);\n\t\tnetif_err(eth, tx_queued, dev,\n\t\t\t  \"Tx Ring full when queue awake!\\n\");\n\t\tspin_unlock(&eth->page_lock);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tif (skb_is_gso(skb)) {\n\t\tif (skb_cow_head(skb, 0)) {\n\t\t\tnetif_warn(eth, tx_err, dev,\n\t\t\t\t   \"GSO expand head fail.\\n\");\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (skb_shinfo(skb)->gso_type &\n\t\t\t\t(SKB_GSO_TCPV4 | SKB_GSO_TCPV6)) {\n\t\t\tgso = true;\n\t\t\ttcp_hdr(skb)->check = htons(skb_shinfo(skb)->gso_size);\n\t\t}\n\t}\n\n\tif (mtk_tx_map(skb, dev, tx_num, ring, gso) < 0)\n\t\tgoto drop;\n\n\tif (unlikely(atomic_read(&ring->free_count) <= ring->thresh))\n\t\tnetif_tx_stop_all_queues(dev);\n\n\tspin_unlock(&eth->page_lock);\n\n\treturn NETDEV_TX_OK;\n\ndrop:\n\tspin_unlock(&eth->page_lock);\n\tstats->tx_dropped++;\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic struct mtk_rx_ring *mtk_get_rx_ring(struct mtk_eth *eth)\n{\n\tint i;\n\tstruct mtk_rx_ring *ring;\n\tint idx;\n\n\tif (!eth->hwlro)\n\t\treturn &eth->rx_ring[0];\n\n\tfor (i = 0; i < MTK_MAX_RX_RING_NUM; i++) {\n\t\tstruct mtk_rx_dma *rxd;\n\n\t\tring = &eth->rx_ring[i];\n\t\tidx = NEXT_DESP_IDX(ring->calc_idx, ring->dma_size);\n\t\trxd = ring->dma + idx * eth->soc->txrx.rxd_size;\n\t\tif (rxd->rxd2 & RX_DMA_DONE) {\n\t\t\tring->calc_idx_update = true;\n\t\t\treturn ring;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void mtk_update_rx_cpu_idx(struct mtk_eth *eth)\n{\n\tstruct mtk_rx_ring *ring;\n\tint i;\n\n\tif (!eth->hwlro) {\n\t\tring = &eth->rx_ring[0];\n\t\tmtk_w32(eth, ring->calc_idx, ring->crx_idx_reg);\n\t} else {\n\t\tfor (i = 0; i < MTK_MAX_RX_RING_NUM; i++) {\n\t\t\tring = &eth->rx_ring[i];\n\t\t\tif (ring->calc_idx_update) {\n\t\t\t\tring->calc_idx_update = false;\n\t\t\t\tmtk_w32(eth, ring->calc_idx, ring->crx_idx_reg);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool mtk_page_pool_enabled(struct mtk_eth *eth)\n{\n\treturn mtk_is_netsys_v2_or_greater(eth);\n}\n\nstatic struct page_pool *mtk_create_page_pool(struct mtk_eth *eth,\n\t\t\t\t\t      struct xdp_rxq_info *xdp_q,\n\t\t\t\t\t      int id, int size)\n{\n\tstruct page_pool_params pp_params = {\n\t\t.order = 0,\n\t\t.flags = PP_FLAG_DMA_MAP | PP_FLAG_DMA_SYNC_DEV,\n\t\t.pool_size = size,\n\t\t.nid = NUMA_NO_NODE,\n\t\t.dev = eth->dma_dev,\n\t\t.offset = MTK_PP_HEADROOM,\n\t\t.max_len = MTK_PP_MAX_BUF_SIZE,\n\t};\n\tstruct page_pool *pp;\n\tint err;\n\n\tpp_params.dma_dir = rcu_access_pointer(eth->prog) ? DMA_BIDIRECTIONAL\n\t\t\t\t\t\t\t  : DMA_FROM_DEVICE;\n\tpp = page_pool_create(&pp_params);\n\tif (IS_ERR(pp))\n\t\treturn pp;\n\n\terr = __xdp_rxq_info_reg(xdp_q, &eth->dummy_dev, id,\n\t\t\t\t eth->rx_napi.napi_id, PAGE_SIZE);\n\tif (err < 0)\n\t\tgoto err_free_pp;\n\n\terr = xdp_rxq_info_reg_mem_model(xdp_q, MEM_TYPE_PAGE_POOL, pp);\n\tif (err)\n\t\tgoto err_unregister_rxq;\n\n\treturn pp;\n\nerr_unregister_rxq:\n\txdp_rxq_info_unreg(xdp_q);\nerr_free_pp:\n\tpage_pool_destroy(pp);\n\n\treturn ERR_PTR(err);\n}\n\nstatic void *mtk_page_pool_get_buff(struct page_pool *pp, dma_addr_t *dma_addr,\n\t\t\t\t    gfp_t gfp_mask)\n{\n\tstruct page *page;\n\n\tpage = page_pool_alloc_pages(pp, gfp_mask | __GFP_NOWARN);\n\tif (!page)\n\t\treturn NULL;\n\n\t*dma_addr = page_pool_get_dma_addr(page) + MTK_PP_HEADROOM;\n\treturn page_address(page);\n}\n\nstatic void mtk_rx_put_buff(struct mtk_rx_ring *ring, void *data, bool napi)\n{\n\tif (ring->page_pool)\n\t\tpage_pool_put_full_page(ring->page_pool,\n\t\t\t\t\tvirt_to_head_page(data), napi);\n\telse\n\t\tskb_free_frag(data);\n}\n\nstatic int mtk_xdp_frame_map(struct mtk_eth *eth, struct net_device *dev,\n\t\t\t     struct mtk_tx_dma_desc_info *txd_info,\n\t\t\t     struct mtk_tx_dma *txd, struct mtk_tx_buf *tx_buf,\n\t\t\t     void *data, u16 headroom, int index, bool dma_map)\n{\n\tstruct mtk_tx_ring *ring = &eth->tx_ring;\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_tx_dma *txd_pdma;\n\n\tif (dma_map) {   \n\t\ttxd_info->addr = dma_map_single(eth->dma_dev, data,\n\t\t\t\t\t\ttxd_info->size, DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(eth->dma_dev, txd_info->addr)))\n\t\t\treturn -ENOMEM;\n\n\t\ttx_buf->flags |= MTK_TX_FLAGS_SINGLE0;\n\t} else {\n\t\tstruct page *page = virt_to_head_page(data);\n\n\t\ttxd_info->addr = page_pool_get_dma_addr(page) +\n\t\t\t\t sizeof(struct xdp_frame) + headroom;\n\t\tdma_sync_single_for_device(eth->dma_dev, txd_info->addr,\n\t\t\t\t\t   txd_info->size, DMA_BIDIRECTIONAL);\n\t}\n\tmtk_tx_set_dma_desc(dev, txd, txd_info);\n\n\ttx_buf->mac_id = mac->id;\n\ttx_buf->type = dma_map ? MTK_TYPE_XDP_NDO : MTK_TYPE_XDP_TX;\n\ttx_buf->data = (void *)MTK_DMA_DUMMY_DESC;\n\n\ttxd_pdma = qdma_to_pdma(ring, txd);\n\tsetup_tx_buf(eth, tx_buf, txd_pdma, txd_info->addr, txd_info->size,\n\t\t     index);\n\n\treturn 0;\n}\n\nstatic int mtk_xdp_submit_frame(struct mtk_eth *eth, struct xdp_frame *xdpf,\n\t\t\t\tstruct net_device *dev, bool dma_map)\n{\n\tstruct skb_shared_info *sinfo = xdp_get_shared_info_from_frame(xdpf);\n\tconst struct mtk_soc_data *soc = eth->soc;\n\tstruct mtk_tx_ring *ring = &eth->tx_ring;\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_tx_dma_desc_info txd_info = {\n\t\t.size\t= xdpf->len,\n\t\t.first\t= true,\n\t\t.last\t= !xdp_frame_has_frags(xdpf),\n\t\t.qid\t= mac->id,\n\t};\n\tint err, index = 0, n_desc = 1, nr_frags;\n\tstruct mtk_tx_buf *htx_buf, *tx_buf;\n\tstruct mtk_tx_dma *htxd, *txd;\n\tvoid *data = xdpf->data;\n\n\tif (unlikely(test_bit(MTK_RESETTING, &eth->state)))\n\t\treturn -EBUSY;\n\n\tnr_frags = unlikely(xdp_frame_has_frags(xdpf)) ? sinfo->nr_frags : 0;\n\tif (unlikely(atomic_read(&ring->free_count) <= 1 + nr_frags))\n\t\treturn -EBUSY;\n\n\tspin_lock(&eth->page_lock);\n\n\ttxd = ring->next_free;\n\tif (txd == ring->last_free) {\n\t\tspin_unlock(&eth->page_lock);\n\t\treturn -ENOMEM;\n\t}\n\thtxd = txd;\n\n\ttx_buf = mtk_desc_to_tx_buf(ring, txd, soc->txrx.txd_size);\n\tmemset(tx_buf, 0, sizeof(*tx_buf));\n\thtx_buf = tx_buf;\n\n\tfor (;;) {\n\t\terr = mtk_xdp_frame_map(eth, dev, &txd_info, txd, tx_buf,\n\t\t\t\t\tdata, xdpf->headroom, index, dma_map);\n\t\tif (err < 0)\n\t\t\tgoto unmap;\n\n\t\tif (txd_info.last)\n\t\t\tbreak;\n\n\t\tif (MTK_HAS_CAPS(soc->caps, MTK_QDMA) || (index & 0x1)) {\n\t\t\ttxd = mtk_qdma_phys_to_virt(ring, txd->txd2);\n\t\t\tif (txd == ring->last_free)\n\t\t\t\tgoto unmap;\n\n\t\t\ttx_buf = mtk_desc_to_tx_buf(ring, txd,\n\t\t\t\t\t\t    soc->txrx.txd_size);\n\t\t\tmemset(tx_buf, 0, sizeof(*tx_buf));\n\t\t\tn_desc++;\n\t\t}\n\n\t\tmemset(&txd_info, 0, sizeof(struct mtk_tx_dma_desc_info));\n\t\ttxd_info.size = skb_frag_size(&sinfo->frags[index]);\n\t\ttxd_info.last = index + 1 == nr_frags;\n\t\ttxd_info.qid = mac->id;\n\t\tdata = skb_frag_address(&sinfo->frags[index]);\n\n\t\tindex++;\n\t}\n\t \n\thtx_buf->data = xdpf;\n\n\tif (!MTK_HAS_CAPS(soc->caps, MTK_QDMA)) {\n\t\tstruct mtk_tx_dma *txd_pdma = qdma_to_pdma(ring, txd);\n\n\t\tif (index & 1)\n\t\t\ttxd_pdma->txd2 |= TX_DMA_LS0;\n\t\telse\n\t\t\ttxd_pdma->txd2 |= TX_DMA_LS1;\n\t}\n\n\tring->next_free = mtk_qdma_phys_to_virt(ring, txd->txd2);\n\tatomic_sub(n_desc, &ring->free_count);\n\n\t \n\twmb();\n\n\tif (MTK_HAS_CAPS(soc->caps, MTK_QDMA)) {\n\t\tmtk_w32(eth, txd->txd2, soc->reg_map->qdma.ctx_ptr);\n\t} else {\n\t\tint idx;\n\n\t\tidx = txd_to_idx(ring, txd, soc->txrx.txd_size);\n\t\tmtk_w32(eth, NEXT_DESP_IDX(idx, ring->dma_size),\n\t\t\tMT7628_TX_CTX_IDX0);\n\t}\n\n\tspin_unlock(&eth->page_lock);\n\n\treturn 0;\n\nunmap:\n\twhile (htxd != txd) {\n\t\ttx_buf = mtk_desc_to_tx_buf(ring, htxd, soc->txrx.txd_size);\n\t\tmtk_tx_unmap(eth, tx_buf, NULL, false);\n\n\t\thtxd->txd3 = TX_DMA_LS0 | TX_DMA_OWNER_CPU;\n\t\tif (!MTK_HAS_CAPS(soc->caps, MTK_QDMA)) {\n\t\t\tstruct mtk_tx_dma *txd_pdma = qdma_to_pdma(ring, htxd);\n\n\t\t\ttxd_pdma->txd2 = TX_DMA_DESP2_DEF;\n\t\t}\n\n\t\thtxd = mtk_qdma_phys_to_virt(ring, htxd->txd2);\n\t}\n\n\tspin_unlock(&eth->page_lock);\n\n\treturn err;\n}\n\nstatic int mtk_xdp_xmit(struct net_device *dev, int num_frame,\n\t\t\tstruct xdp_frame **frames, u32 flags)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_hw_stats *hw_stats = mac->hw_stats;\n\tstruct mtk_eth *eth = mac->hw;\n\tint i, nxmit = 0;\n\n\tif (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_frame; i++) {\n\t\tif (mtk_xdp_submit_frame(eth, frames[i], dev, true))\n\t\t\tbreak;\n\t\tnxmit++;\n\t}\n\n\tu64_stats_update_begin(&hw_stats->syncp);\n\thw_stats->xdp_stats.tx_xdp_xmit += nxmit;\n\thw_stats->xdp_stats.tx_xdp_xmit_errors += num_frame - nxmit;\n\tu64_stats_update_end(&hw_stats->syncp);\n\n\treturn nxmit;\n}\n\nstatic u32 mtk_xdp_run(struct mtk_eth *eth, struct mtk_rx_ring *ring,\n\t\t       struct xdp_buff *xdp, struct net_device *dev)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_hw_stats *hw_stats = mac->hw_stats;\n\tu64 *count = &hw_stats->xdp_stats.rx_xdp_drop;\n\tstruct bpf_prog *prog;\n\tu32 act = XDP_PASS;\n\n\trcu_read_lock();\n\n\tprog = rcu_dereference(eth->prog);\n\tif (!prog)\n\t\tgoto out;\n\n\tact = bpf_prog_run_xdp(prog, xdp);\n\tswitch (act) {\n\tcase XDP_PASS:\n\t\tcount = &hw_stats->xdp_stats.rx_xdp_pass;\n\t\tgoto update_stats;\n\tcase XDP_REDIRECT:\n\t\tif (unlikely(xdp_do_redirect(dev, xdp, prog))) {\n\t\t\tact = XDP_DROP;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = &hw_stats->xdp_stats.rx_xdp_redirect;\n\t\tgoto update_stats;\n\tcase XDP_TX: {\n\t\tstruct xdp_frame *xdpf = xdp_convert_buff_to_frame(xdp);\n\n\t\tif (!xdpf || mtk_xdp_submit_frame(eth, xdpf, dev, false)) {\n\t\t\tcount = &hw_stats->xdp_stats.rx_xdp_tx_errors;\n\t\t\tact = XDP_DROP;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = &hw_stats->xdp_stats.rx_xdp_tx;\n\t\tgoto update_stats;\n\t}\n\tdefault:\n\t\tbpf_warn_invalid_xdp_action(dev, prog, act);\n\t\tfallthrough;\n\tcase XDP_ABORTED:\n\t\ttrace_xdp_exception(dev, prog, act);\n\t\tfallthrough;\n\tcase XDP_DROP:\n\t\tbreak;\n\t}\n\n\tpage_pool_put_full_page(ring->page_pool,\n\t\t\t\tvirt_to_head_page(xdp->data), true);\n\nupdate_stats:\n\tu64_stats_update_begin(&hw_stats->syncp);\n\t*count = *count + 1;\n\tu64_stats_update_end(&hw_stats->syncp);\nout:\n\trcu_read_unlock();\n\n\treturn act;\n}\n\nstatic int mtk_poll_rx(struct napi_struct *napi, int budget,\n\t\t       struct mtk_eth *eth)\n{\n\tstruct dim_sample dim_sample = {};\n\tstruct mtk_rx_ring *ring;\n\tbool xdp_flush = false;\n\tint idx;\n\tstruct sk_buff *skb;\n\tu64 addr64 = 0;\n\tu8 *data, *new_data;\n\tstruct mtk_rx_dma_v2 *rxd, trxd;\n\tint done = 0, bytes = 0;\n\tdma_addr_t dma_addr = DMA_MAPPING_ERROR;\n\n\twhile (done < budget) {\n\t\tunsigned int pktlen, *rxdcsum;\n\t\tstruct net_device *netdev;\n\t\tu32 hash, reason;\n\t\tint mac = 0;\n\n\t\tring = mtk_get_rx_ring(eth);\n\t\tif (unlikely(!ring))\n\t\t\tgoto rx_done;\n\n\t\tidx = NEXT_DESP_IDX(ring->calc_idx, ring->dma_size);\n\t\trxd = ring->dma + idx * eth->soc->txrx.rxd_size;\n\t\tdata = ring->data[idx];\n\n\t\tif (!mtk_rx_get_desc(eth, &trxd, rxd))\n\t\t\tbreak;\n\n\t\t \n\t\tif (mtk_is_netsys_v2_or_greater(eth)) {\n\t\t\tu32 val = RX_DMA_GET_SPORT_V2(trxd.rxd5);\n\n\t\t\tswitch (val) {\n\t\t\tcase PSE_GDM1_PORT:\n\t\t\tcase PSE_GDM2_PORT:\n\t\t\t\tmac = val - 1;\n\t\t\t\tbreak;\n\t\t\tcase PSE_GDM3_PORT:\n\t\t\t\tmac = MTK_GMAC3_ID;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628) &&\n\t\t\t   !(trxd.rxd4 & RX_DMA_SPECIAL_TAG)) {\n\t\t\tmac = RX_DMA_GET_SPORT(trxd.rxd4) - 1;\n\t\t}\n\n\t\tif (unlikely(mac < 0 || mac >= MTK_MAX_DEVS ||\n\t\t\t     !eth->netdev[mac]))\n\t\t\tgoto release_desc;\n\n\t\tnetdev = eth->netdev[mac];\n\n\t\tif (unlikely(test_bit(MTK_RESETTING, &eth->state)))\n\t\t\tgoto release_desc;\n\n\t\tpktlen = RX_DMA_GET_PLEN0(trxd.rxd2);\n\n\t\t \n\t\tif (ring->page_pool) {\n\t\t\tstruct page *page = virt_to_head_page(data);\n\t\t\tstruct xdp_buff xdp;\n\t\t\tu32 ret;\n\n\t\t\tnew_data = mtk_page_pool_get_buff(ring->page_pool,\n\t\t\t\t\t\t\t  &dma_addr,\n\t\t\t\t\t\t\t  GFP_ATOMIC);\n\t\t\tif (unlikely(!new_data)) {\n\t\t\t\tnetdev->stats.rx_dropped++;\n\t\t\t\tgoto release_desc;\n\t\t\t}\n\n\t\t\tdma_sync_single_for_cpu(eth->dma_dev,\n\t\t\t\tpage_pool_get_dma_addr(page) + MTK_PP_HEADROOM,\n\t\t\t\tpktlen, page_pool_get_dma_dir(ring->page_pool));\n\n\t\t\txdp_init_buff(&xdp, PAGE_SIZE, &ring->xdp_q);\n\t\t\txdp_prepare_buff(&xdp, data, MTK_PP_HEADROOM, pktlen,\n\t\t\t\t\t false);\n\t\t\txdp_buff_clear_frags_flag(&xdp);\n\n\t\t\tret = mtk_xdp_run(eth, ring, &xdp, netdev);\n\t\t\tif (ret == XDP_REDIRECT)\n\t\t\t\txdp_flush = true;\n\n\t\t\tif (ret != XDP_PASS)\n\t\t\t\tgoto skip_rx;\n\n\t\t\tskb = build_skb(data, PAGE_SIZE);\n\t\t\tif (unlikely(!skb)) {\n\t\t\t\tpage_pool_put_full_page(ring->page_pool,\n\t\t\t\t\t\t\tpage, true);\n\t\t\t\tnetdev->stats.rx_dropped++;\n\t\t\t\tgoto skip_rx;\n\t\t\t}\n\n\t\t\tskb_reserve(skb, xdp.data - xdp.data_hard_start);\n\t\t\tskb_put(skb, xdp.data_end - xdp.data);\n\t\t\tskb_mark_for_recycle(skb);\n\t\t} else {\n\t\t\tif (ring->frag_size <= PAGE_SIZE)\n\t\t\t\tnew_data = napi_alloc_frag(ring->frag_size);\n\t\t\telse\n\t\t\t\tnew_data = mtk_max_lro_buf_alloc(GFP_ATOMIC);\n\n\t\t\tif (unlikely(!new_data)) {\n\t\t\t\tnetdev->stats.rx_dropped++;\n\t\t\t\tgoto release_desc;\n\t\t\t}\n\n\t\t\tdma_addr = dma_map_single(eth->dma_dev,\n\t\t\t\tnew_data + NET_SKB_PAD + eth->ip_align,\n\t\t\t\tring->buf_size, DMA_FROM_DEVICE);\n\t\t\tif (unlikely(dma_mapping_error(eth->dma_dev,\n\t\t\t\t\t\t       dma_addr))) {\n\t\t\t\tskb_free_frag(new_data);\n\t\t\t\tnetdev->stats.rx_dropped++;\n\t\t\t\tgoto release_desc;\n\t\t\t}\n\n\t\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_36BIT_DMA))\n\t\t\t\taddr64 = RX_DMA_GET_ADDR64(trxd.rxd2);\n\n\t\t\tdma_unmap_single(eth->dma_dev, ((u64)trxd.rxd1 | addr64),\n\t\t\t\t\t ring->buf_size, DMA_FROM_DEVICE);\n\n\t\t\tskb = build_skb(data, ring->frag_size);\n\t\t\tif (unlikely(!skb)) {\n\t\t\t\tnetdev->stats.rx_dropped++;\n\t\t\t\tskb_free_frag(data);\n\t\t\t\tgoto skip_rx;\n\t\t\t}\n\n\t\t\tskb_reserve(skb, NET_SKB_PAD + NET_IP_ALIGN);\n\t\t\tskb_put(skb, pktlen);\n\t\t}\n\n\t\tskb->dev = netdev;\n\t\tbytes += skb->len;\n\n\t\tif (mtk_is_netsys_v2_or_greater(eth)) {\n\t\t\treason = FIELD_GET(MTK_RXD5_PPE_CPU_REASON, trxd.rxd5);\n\t\t\thash = trxd.rxd5 & MTK_RXD5_FOE_ENTRY;\n\t\t\tif (hash != MTK_RXD5_FOE_ENTRY)\n\t\t\t\tskb_set_hash(skb, jhash_1word(hash, 0),\n\t\t\t\t\t     PKT_HASH_TYPE_L4);\n\t\t\trxdcsum = &trxd.rxd3;\n\t\t} else {\n\t\t\treason = FIELD_GET(MTK_RXD4_PPE_CPU_REASON, trxd.rxd4);\n\t\t\thash = trxd.rxd4 & MTK_RXD4_FOE_ENTRY;\n\t\t\tif (hash != MTK_RXD4_FOE_ENTRY)\n\t\t\t\tskb_set_hash(skb, jhash_1word(hash, 0),\n\t\t\t\t\t     PKT_HASH_TYPE_L4);\n\t\t\trxdcsum = &trxd.rxd4;\n\t\t}\n\n\t\tif (*rxdcsum & eth->soc->txrx.rx_dma_l4_valid)\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\telse\n\t\t\tskb_checksum_none_assert(skb);\n\t\tskb->protocol = eth_type_trans(skb, netdev);\n\n\t\t \n\t\tif (mtk_is_netsys_v1(eth) && (trxd.rxd2 & RX_DMA_VTAG) &&\n\t\t    netdev_uses_dsa(netdev)) {\n\t\t\tunsigned int port = RX_DMA_VPID(trxd.rxd3) & GENMASK(2, 0);\n\n\t\t\tif (port < ARRAY_SIZE(eth->dsa_meta) &&\n\t\t\t    eth->dsa_meta[port])\n\t\t\t\tskb_dst_set_noref(skb, &eth->dsa_meta[port]->dst);\n\t\t}\n\n\t\tif (reason == MTK_PPE_CPU_REASON_HIT_UNBIND_RATE_REACHED)\n\t\t\tmtk_ppe_check_skb(eth->ppe[0], skb, hash);\n\n\t\tskb_record_rx_queue(skb, 0);\n\t\tnapi_gro_receive(napi, skb);\n\nskip_rx:\n\t\tring->data[idx] = new_data;\n\t\trxd->rxd1 = (unsigned int)dma_addr;\nrelease_desc:\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628))\n\t\t\trxd->rxd2 = RX_DMA_LSO;\n\t\telse\n\t\t\trxd->rxd2 = RX_DMA_PREP_PLEN0(ring->buf_size);\n\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_36BIT_DMA) &&\n\t\t    likely(dma_addr != DMA_MAPPING_ERROR))\n\t\t\trxd->rxd2 |= RX_DMA_PREP_ADDR64(dma_addr);\n\n\t\tring->calc_idx = idx;\n\t\tdone++;\n\t}\n\nrx_done:\n\tif (done) {\n\t\t \n\t\twmb();\n\t\tmtk_update_rx_cpu_idx(eth);\n\t}\n\n\teth->rx_packets += done;\n\teth->rx_bytes += bytes;\n\tdim_update_sample(eth->rx_events, eth->rx_packets, eth->rx_bytes,\n\t\t\t  &dim_sample);\n\tnet_dim(&eth->rx_dim, dim_sample);\n\n\tif (xdp_flush)\n\t\txdp_do_flush_map();\n\n\treturn done;\n}\n\nstruct mtk_poll_state {\n    struct netdev_queue *txq;\n    unsigned int total;\n    unsigned int done;\n    unsigned int bytes;\n};\n\nstatic void\nmtk_poll_tx_done(struct mtk_eth *eth, struct mtk_poll_state *state, u8 mac,\n\t\t struct sk_buff *skb)\n{\n\tstruct netdev_queue *txq;\n\tstruct net_device *dev;\n\tunsigned int bytes = skb->len;\n\n\tstate->total++;\n\teth->tx_packets++;\n\teth->tx_bytes += bytes;\n\n\tdev = eth->netdev[mac];\n\tif (!dev)\n\t\treturn;\n\n\ttxq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));\n\tif (state->txq == txq) {\n\t\tstate->done++;\n\t\tstate->bytes += bytes;\n\t\treturn;\n\t}\n\n\tif (state->txq)\n\t\tnetdev_tx_completed_queue(state->txq, state->done, state->bytes);\n\n\tstate->txq = txq;\n\tstate->done = 1;\n\tstate->bytes = bytes;\n}\n\nstatic int mtk_poll_tx_qdma(struct mtk_eth *eth, int budget,\n\t\t\t    struct mtk_poll_state *state)\n{\n\tconst struct mtk_reg_map *reg_map = eth->soc->reg_map;\n\tstruct mtk_tx_ring *ring = &eth->tx_ring;\n\tstruct mtk_tx_buf *tx_buf;\n\tstruct xdp_frame_bulk bq;\n\tstruct mtk_tx_dma *desc;\n\tu32 cpu, dma;\n\n\tcpu = ring->last_free_ptr;\n\tdma = mtk_r32(eth, reg_map->qdma.drx_ptr);\n\n\tdesc = mtk_qdma_phys_to_virt(ring, cpu);\n\txdp_frame_bulk_init(&bq);\n\n\twhile ((cpu != dma) && budget) {\n\t\tu32 next_cpu = desc->txd2;\n\n\t\tdesc = mtk_qdma_phys_to_virt(ring, desc->txd2);\n\t\tif ((desc->txd3 & TX_DMA_OWNER_CPU) == 0)\n\t\t\tbreak;\n\n\t\ttx_buf = mtk_desc_to_tx_buf(ring, desc,\n\t\t\t\t\t    eth->soc->txrx.txd_size);\n\t\tif (!tx_buf->data)\n\t\t\tbreak;\n\n\t\tif (tx_buf->data != (void *)MTK_DMA_DUMMY_DESC) {\n\t\t\tif (tx_buf->type == MTK_TYPE_SKB)\n\t\t\t\tmtk_poll_tx_done(eth, state, tx_buf->mac_id,\n\t\t\t\t\t\t tx_buf->data);\n\n\t\t\tbudget--;\n\t\t}\n\t\tmtk_tx_unmap(eth, tx_buf, &bq, true);\n\n\t\tring->last_free = desc;\n\t\tatomic_inc(&ring->free_count);\n\n\t\tcpu = next_cpu;\n\t}\n\txdp_flush_frame_bulk(&bq);\n\n\tring->last_free_ptr = cpu;\n\tmtk_w32(eth, cpu, reg_map->qdma.crx_ptr);\n\n\treturn budget;\n}\n\nstatic int mtk_poll_tx_pdma(struct mtk_eth *eth, int budget,\n\t\t\t    struct mtk_poll_state *state)\n{\n\tstruct mtk_tx_ring *ring = &eth->tx_ring;\n\tstruct mtk_tx_buf *tx_buf;\n\tstruct xdp_frame_bulk bq;\n\tstruct mtk_tx_dma *desc;\n\tu32 cpu, dma;\n\n\tcpu = ring->cpu_idx;\n\tdma = mtk_r32(eth, MT7628_TX_DTX_IDX0);\n\txdp_frame_bulk_init(&bq);\n\n\twhile ((cpu != dma) && budget) {\n\t\ttx_buf = &ring->buf[cpu];\n\t\tif (!tx_buf->data)\n\t\t\tbreak;\n\n\t\tif (tx_buf->data != (void *)MTK_DMA_DUMMY_DESC) {\n\t\t\tif (tx_buf->type == MTK_TYPE_SKB)\n\t\t\t\tmtk_poll_tx_done(eth, state, 0, tx_buf->data);\n\t\t\tbudget--;\n\t\t}\n\t\tmtk_tx_unmap(eth, tx_buf, &bq, true);\n\n\t\tdesc = ring->dma + cpu * eth->soc->txrx.txd_size;\n\t\tring->last_free = desc;\n\t\tatomic_inc(&ring->free_count);\n\n\t\tcpu = NEXT_DESP_IDX(cpu, ring->dma_size);\n\t}\n\txdp_flush_frame_bulk(&bq);\n\n\tring->cpu_idx = cpu;\n\n\treturn budget;\n}\n\nstatic int mtk_poll_tx(struct mtk_eth *eth, int budget)\n{\n\tstruct mtk_tx_ring *ring = &eth->tx_ring;\n\tstruct dim_sample dim_sample = {};\n\tstruct mtk_poll_state state = {};\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA))\n\t\tbudget = mtk_poll_tx_qdma(eth, budget, &state);\n\telse\n\t\tbudget = mtk_poll_tx_pdma(eth, budget, &state);\n\n\tif (state.txq)\n\t\tnetdev_tx_completed_queue(state.txq, state.done, state.bytes);\n\n\tdim_update_sample(eth->tx_events, eth->tx_packets, eth->tx_bytes,\n\t\t\t  &dim_sample);\n\tnet_dim(&eth->tx_dim, dim_sample);\n\n\tif (mtk_queue_stopped(eth) &&\n\t    (atomic_read(&ring->free_count) > ring->thresh))\n\t\tmtk_wake_queue(eth);\n\n\treturn state.total;\n}\n\nstatic void mtk_handle_status_irq(struct mtk_eth *eth)\n{\n\tu32 status2 = mtk_r32(eth, MTK_INT_STATUS2);\n\n\tif (unlikely(status2 & (MTK_GDM1_AF | MTK_GDM2_AF))) {\n\t\tmtk_stats_update(eth);\n\t\tmtk_w32(eth, (MTK_GDM1_AF | MTK_GDM2_AF),\n\t\t\tMTK_INT_STATUS2);\n\t}\n}\n\nstatic int mtk_napi_tx(struct napi_struct *napi, int budget)\n{\n\tstruct mtk_eth *eth = container_of(napi, struct mtk_eth, tx_napi);\n\tconst struct mtk_reg_map *reg_map = eth->soc->reg_map;\n\tint tx_done = 0;\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA))\n\t\tmtk_handle_status_irq(eth);\n\tmtk_w32(eth, MTK_TX_DONE_INT, reg_map->tx_irq_status);\n\ttx_done = mtk_poll_tx(eth, budget);\n\n\tif (unlikely(netif_msg_intr(eth))) {\n\t\tdev_info(eth->dev,\n\t\t\t \"done tx %d, intr 0x%08x/0x%x\\n\", tx_done,\n\t\t\t mtk_r32(eth, reg_map->tx_irq_status),\n\t\t\t mtk_r32(eth, reg_map->tx_irq_mask));\n\t}\n\n\tif (tx_done == budget)\n\t\treturn budget;\n\n\tif (mtk_r32(eth, reg_map->tx_irq_status) & MTK_TX_DONE_INT)\n\t\treturn budget;\n\n\tif (napi_complete_done(napi, tx_done))\n\t\tmtk_tx_irq_enable(eth, MTK_TX_DONE_INT);\n\n\treturn tx_done;\n}\n\nstatic int mtk_napi_rx(struct napi_struct *napi, int budget)\n{\n\tstruct mtk_eth *eth = container_of(napi, struct mtk_eth, rx_napi);\n\tconst struct mtk_reg_map *reg_map = eth->soc->reg_map;\n\tint rx_done_total = 0;\n\n\tmtk_handle_status_irq(eth);\n\n\tdo {\n\t\tint rx_done;\n\n\t\tmtk_w32(eth, eth->soc->txrx.rx_irq_done_mask,\n\t\t\treg_map->pdma.irq_status);\n\t\trx_done = mtk_poll_rx(napi, budget - rx_done_total, eth);\n\t\trx_done_total += rx_done;\n\n\t\tif (unlikely(netif_msg_intr(eth))) {\n\t\t\tdev_info(eth->dev,\n\t\t\t\t \"done rx %d, intr 0x%08x/0x%x\\n\", rx_done,\n\t\t\t\t mtk_r32(eth, reg_map->pdma.irq_status),\n\t\t\t\t mtk_r32(eth, reg_map->pdma.irq_mask));\n\t\t}\n\n\t\tif (rx_done_total == budget)\n\t\t\treturn budget;\n\n\t} while (mtk_r32(eth, reg_map->pdma.irq_status) &\n\t\t eth->soc->txrx.rx_irq_done_mask);\n\n\tif (napi_complete_done(napi, rx_done_total))\n\t\tmtk_rx_irq_enable(eth, eth->soc->txrx.rx_irq_done_mask);\n\n\treturn rx_done_total;\n}\n\nstatic int mtk_tx_alloc(struct mtk_eth *eth)\n{\n\tconst struct mtk_soc_data *soc = eth->soc;\n\tstruct mtk_tx_ring *ring = &eth->tx_ring;\n\tint i, sz = soc->txrx.txd_size;\n\tstruct mtk_tx_dma_v2 *txd;\n\tint ring_size;\n\tu32 ofs, val;\n\n\tif (MTK_HAS_CAPS(soc->caps, MTK_QDMA))\n\t\tring_size = MTK_QDMA_RING_SIZE;\n\telse\n\t\tring_size = MTK_DMA_SIZE;\n\n\tring->buf = kcalloc(ring_size, sizeof(*ring->buf),\n\t\t\t       GFP_KERNEL);\n\tif (!ring->buf)\n\t\tgoto no_tx_mem;\n\n\tif (MTK_HAS_CAPS(soc->caps, MTK_SRAM)) {\n\t\tring->dma = eth->sram_base + ring_size * sz;\n\t\tring->phys = eth->phy_scratch_ring + ring_size * (dma_addr_t)sz;\n\t} else {\n\t\tring->dma = dma_alloc_coherent(eth->dma_dev, ring_size * sz,\n\t\t\t\t\t       &ring->phys, GFP_KERNEL);\n\t}\n\n\tif (!ring->dma)\n\t\tgoto no_tx_mem;\n\n\tfor (i = 0; i < ring_size; i++) {\n\t\tint next = (i + 1) % ring_size;\n\t\tu32 next_ptr = ring->phys + next * sz;\n\n\t\ttxd = ring->dma + i * sz;\n\t\ttxd->txd2 = next_ptr;\n\t\ttxd->txd3 = TX_DMA_LS0 | TX_DMA_OWNER_CPU;\n\t\ttxd->txd4 = 0;\n\t\tif (mtk_is_netsys_v2_or_greater(eth)) {\n\t\t\ttxd->txd5 = 0;\n\t\t\ttxd->txd6 = 0;\n\t\t\ttxd->txd7 = 0;\n\t\t\ttxd->txd8 = 0;\n\t\t}\n\t}\n\n\t \n\tif (!MTK_HAS_CAPS(soc->caps, MTK_QDMA)) {\n\t\tring->dma_pdma = dma_alloc_coherent(eth->dma_dev, ring_size * sz,\n\t\t\t\t\t\t    &ring->phys_pdma, GFP_KERNEL);\n\t\tif (!ring->dma_pdma)\n\t\t\tgoto no_tx_mem;\n\n\t\tfor (i = 0; i < ring_size; i++) {\n\t\t\tring->dma_pdma[i].txd2 = TX_DMA_DESP2_DEF;\n\t\t\tring->dma_pdma[i].txd4 = 0;\n\t\t}\n\t}\n\n\tring->dma_size = ring_size;\n\tatomic_set(&ring->free_count, ring_size - 2);\n\tring->next_free = ring->dma;\n\tring->last_free = (void *)txd;\n\tring->last_free_ptr = (u32)(ring->phys + ((ring_size - 1) * sz));\n\tring->thresh = MAX_SKB_FRAGS;\n\n\t \n\twmb();\n\n\tif (MTK_HAS_CAPS(soc->caps, MTK_QDMA)) {\n\t\tmtk_w32(eth, ring->phys, soc->reg_map->qdma.ctx_ptr);\n\t\tmtk_w32(eth, ring->phys, soc->reg_map->qdma.dtx_ptr);\n\t\tmtk_w32(eth,\n\t\t\tring->phys + ((ring_size - 1) * sz),\n\t\t\tsoc->reg_map->qdma.crx_ptr);\n\t\tmtk_w32(eth, ring->last_free_ptr, soc->reg_map->qdma.drx_ptr);\n\n\t\tfor (i = 0, ofs = 0; i < MTK_QDMA_NUM_QUEUES; i++) {\n\t\t\tval = (QDMA_RES_THRES << 8) | QDMA_RES_THRES;\n\t\t\tmtk_w32(eth, val, soc->reg_map->qdma.qtx_cfg + ofs);\n\n\t\t\tval = MTK_QTX_SCH_MIN_RATE_EN |\n\t\t\t       \n\t\t\t      FIELD_PREP(MTK_QTX_SCH_MIN_RATE_MAN, 1) |\n\t\t\t      FIELD_PREP(MTK_QTX_SCH_MIN_RATE_EXP, 4) |\n\t\t\t      MTK_QTX_SCH_LEAKY_BUCKET_SIZE;\n\t\t\tif (mtk_is_netsys_v1(eth))\n\t\t\t\tval |= MTK_QTX_SCH_LEAKY_BUCKET_EN;\n\t\t\tmtk_w32(eth, val, soc->reg_map->qdma.qtx_sch + ofs);\n\t\t\tofs += MTK_QTX_OFFSET;\n\t\t}\n\t\tval = MTK_QDMA_TX_SCH_MAX_WFQ | (MTK_QDMA_TX_SCH_MAX_WFQ << 16);\n\t\tmtk_w32(eth, val, soc->reg_map->qdma.tx_sch_rate);\n\t\tif (mtk_is_netsys_v2_or_greater(eth))\n\t\t\tmtk_w32(eth, val, soc->reg_map->qdma.tx_sch_rate + 4);\n\t} else {\n\t\tmtk_w32(eth, ring->phys_pdma, MT7628_TX_BASE_PTR0);\n\t\tmtk_w32(eth, ring_size, MT7628_TX_MAX_CNT0);\n\t\tmtk_w32(eth, 0, MT7628_TX_CTX_IDX0);\n\t\tmtk_w32(eth, MT7628_PST_DTX_IDX0, soc->reg_map->pdma.rst_idx);\n\t}\n\n\treturn 0;\n\nno_tx_mem:\n\treturn -ENOMEM;\n}\n\nstatic void mtk_tx_clean(struct mtk_eth *eth)\n{\n\tconst struct mtk_soc_data *soc = eth->soc;\n\tstruct mtk_tx_ring *ring = &eth->tx_ring;\n\tint i;\n\n\tif (ring->buf) {\n\t\tfor (i = 0; i < ring->dma_size; i++)\n\t\t\tmtk_tx_unmap(eth, &ring->buf[i], NULL, false);\n\t\tkfree(ring->buf);\n\t\tring->buf = NULL;\n\t}\n\tif (!MTK_HAS_CAPS(soc->caps, MTK_SRAM) && ring->dma) {\n\t\tdma_free_coherent(eth->dma_dev,\n\t\t\t\t  ring->dma_size * soc->txrx.txd_size,\n\t\t\t\t  ring->dma, ring->phys);\n\t\tring->dma = NULL;\n\t}\n\n\tif (ring->dma_pdma) {\n\t\tdma_free_coherent(eth->dma_dev,\n\t\t\t\t  ring->dma_size * soc->txrx.txd_size,\n\t\t\t\t  ring->dma_pdma, ring->phys_pdma);\n\t\tring->dma_pdma = NULL;\n\t}\n}\n\nstatic int mtk_rx_alloc(struct mtk_eth *eth, int ring_no, int rx_flag)\n{\n\tconst struct mtk_reg_map *reg_map = eth->soc->reg_map;\n\tstruct mtk_rx_ring *ring;\n\tint rx_data_len, rx_dma_size, tx_ring_size;\n\tint i;\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA))\n\t\ttx_ring_size = MTK_QDMA_RING_SIZE;\n\telse\n\t\ttx_ring_size = MTK_DMA_SIZE;\n\n\tif (rx_flag == MTK_RX_FLAGS_QDMA) {\n\t\tif (ring_no)\n\t\t\treturn -EINVAL;\n\t\tring = &eth->rx_ring_qdma;\n\t} else {\n\t\tring = &eth->rx_ring[ring_no];\n\t}\n\n\tif (rx_flag == MTK_RX_FLAGS_HWLRO) {\n\t\trx_data_len = MTK_MAX_LRO_RX_LENGTH;\n\t\trx_dma_size = MTK_HW_LRO_DMA_SIZE;\n\t} else {\n\t\trx_data_len = ETH_DATA_LEN;\n\t\trx_dma_size = MTK_DMA_SIZE;\n\t}\n\n\tring->frag_size = mtk_max_frag_size(rx_data_len);\n\tring->buf_size = mtk_max_buf_size(ring->frag_size);\n\tring->data = kcalloc(rx_dma_size, sizeof(*ring->data),\n\t\t\t     GFP_KERNEL);\n\tif (!ring->data)\n\t\treturn -ENOMEM;\n\n\tif (mtk_page_pool_enabled(eth)) {\n\t\tstruct page_pool *pp;\n\n\t\tpp = mtk_create_page_pool(eth, &ring->xdp_q, ring_no,\n\t\t\t\t\t  rx_dma_size);\n\t\tif (IS_ERR(pp))\n\t\t\treturn PTR_ERR(pp);\n\n\t\tring->page_pool = pp;\n\t}\n\n\tif (!MTK_HAS_CAPS(eth->soc->caps, MTK_SRAM) ||\n\t    rx_flag != MTK_RX_FLAGS_NORMAL) {\n\t\tring->dma = dma_alloc_coherent(eth->dma_dev,\n\t\t\t\t\t       rx_dma_size * eth->soc->txrx.rxd_size,\n\t\t\t\t\t       &ring->phys, GFP_KERNEL);\n\t} else {\n\t\tstruct mtk_tx_ring *tx_ring = &eth->tx_ring;\n\n\t\tring->dma = tx_ring->dma + tx_ring_size *\n\t\t\t    eth->soc->txrx.txd_size * (ring_no + 1);\n\t\tring->phys = tx_ring->phys + tx_ring_size *\n\t\t\t     eth->soc->txrx.txd_size * (ring_no + 1);\n\t}\n\n\tif (!ring->dma)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < rx_dma_size; i++) {\n\t\tstruct mtk_rx_dma_v2 *rxd;\n\t\tdma_addr_t dma_addr;\n\t\tvoid *data;\n\n\t\trxd = ring->dma + i * eth->soc->txrx.rxd_size;\n\t\tif (ring->page_pool) {\n\t\t\tdata = mtk_page_pool_get_buff(ring->page_pool,\n\t\t\t\t\t\t      &dma_addr, GFP_KERNEL);\n\t\t\tif (!data)\n\t\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tif (ring->frag_size <= PAGE_SIZE)\n\t\t\t\tdata = netdev_alloc_frag(ring->frag_size);\n\t\t\telse\n\t\t\t\tdata = mtk_max_lro_buf_alloc(GFP_KERNEL);\n\n\t\t\tif (!data)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdma_addr = dma_map_single(eth->dma_dev,\n\t\t\t\tdata + NET_SKB_PAD + eth->ip_align,\n\t\t\t\tring->buf_size, DMA_FROM_DEVICE);\n\t\t\tif (unlikely(dma_mapping_error(eth->dma_dev,\n\t\t\t\t\t\t       dma_addr))) {\n\t\t\t\tskb_free_frag(data);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t\trxd->rxd1 = (unsigned int)dma_addr;\n\t\tring->data[i] = data;\n\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628))\n\t\t\trxd->rxd2 = RX_DMA_LSO;\n\t\telse\n\t\t\trxd->rxd2 = RX_DMA_PREP_PLEN0(ring->buf_size);\n\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_36BIT_DMA))\n\t\t\trxd->rxd2 |= RX_DMA_PREP_ADDR64(dma_addr);\n\n\t\trxd->rxd3 = 0;\n\t\trxd->rxd4 = 0;\n\t\tif (mtk_is_netsys_v2_or_greater(eth)) {\n\t\t\trxd->rxd5 = 0;\n\t\t\trxd->rxd6 = 0;\n\t\t\trxd->rxd7 = 0;\n\t\t\trxd->rxd8 = 0;\n\t\t}\n\t}\n\n\tring->dma_size = rx_dma_size;\n\tring->calc_idx_update = false;\n\tring->calc_idx = rx_dma_size - 1;\n\tif (rx_flag == MTK_RX_FLAGS_QDMA)\n\t\tring->crx_idx_reg = reg_map->qdma.qcrx_ptr +\n\t\t\t\t    ring_no * MTK_QRX_OFFSET;\n\telse\n\t\tring->crx_idx_reg = reg_map->pdma.pcrx_ptr +\n\t\t\t\t    ring_no * MTK_QRX_OFFSET;\n\t \n\twmb();\n\n\tif (rx_flag == MTK_RX_FLAGS_QDMA) {\n\t\tmtk_w32(eth, ring->phys,\n\t\t\treg_map->qdma.rx_ptr + ring_no * MTK_QRX_OFFSET);\n\t\tmtk_w32(eth, rx_dma_size,\n\t\t\treg_map->qdma.rx_cnt_cfg + ring_no * MTK_QRX_OFFSET);\n\t\tmtk_w32(eth, MTK_PST_DRX_IDX_CFG(ring_no),\n\t\t\treg_map->qdma.rst_idx);\n\t} else {\n\t\tmtk_w32(eth, ring->phys,\n\t\t\treg_map->pdma.rx_ptr + ring_no * MTK_QRX_OFFSET);\n\t\tmtk_w32(eth, rx_dma_size,\n\t\t\treg_map->pdma.rx_cnt_cfg + ring_no * MTK_QRX_OFFSET);\n\t\tmtk_w32(eth, MTK_PST_DRX_IDX_CFG(ring_no),\n\t\t\treg_map->pdma.rst_idx);\n\t}\n\tmtk_w32(eth, ring->calc_idx, ring->crx_idx_reg);\n\n\treturn 0;\n}\n\nstatic void mtk_rx_clean(struct mtk_eth *eth, struct mtk_rx_ring *ring, bool in_sram)\n{\n\tu64 addr64 = 0;\n\tint i;\n\n\tif (ring->data && ring->dma) {\n\t\tfor (i = 0; i < ring->dma_size; i++) {\n\t\t\tstruct mtk_rx_dma *rxd;\n\n\t\t\tif (!ring->data[i])\n\t\t\t\tcontinue;\n\n\t\t\trxd = ring->dma + i * eth->soc->txrx.rxd_size;\n\t\t\tif (!rxd->rxd1)\n\t\t\t\tcontinue;\n\n\t\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_36BIT_DMA))\n\t\t\t\taddr64 = RX_DMA_GET_ADDR64(rxd->rxd2);\n\n\t\t\tdma_unmap_single(eth->dma_dev, ((u64)rxd->rxd1 | addr64),\n\t\t\t\t\t ring->buf_size, DMA_FROM_DEVICE);\n\t\t\tmtk_rx_put_buff(ring, ring->data[i], false);\n\t\t}\n\t\tkfree(ring->data);\n\t\tring->data = NULL;\n\t}\n\n\tif (!in_sram && ring->dma) {\n\t\tdma_free_coherent(eth->dma_dev,\n\t\t\t\t  ring->dma_size * eth->soc->txrx.rxd_size,\n\t\t\t\t  ring->dma, ring->phys);\n\t\tring->dma = NULL;\n\t}\n\n\tif (ring->page_pool) {\n\t\tif (xdp_rxq_info_is_reg(&ring->xdp_q))\n\t\t\txdp_rxq_info_unreg(&ring->xdp_q);\n\t\tpage_pool_destroy(ring->page_pool);\n\t\tring->page_pool = NULL;\n\t}\n}\n\nstatic int mtk_hwlro_rx_init(struct mtk_eth *eth)\n{\n\tint i;\n\tu32 ring_ctrl_dw1 = 0, ring_ctrl_dw2 = 0, ring_ctrl_dw3 = 0;\n\tu32 lro_ctrl_dw0 = 0, lro_ctrl_dw3 = 0;\n\n\t \n\tring_ctrl_dw2 |= MTK_RING_AUTO_LERAN_MODE;\n\n\t \n\tring_ctrl_dw2 |= MTK_RING_VLD;\n\n\t \n\tring_ctrl_dw2 |= MTK_RING_AGE_TIME_H;\n\tring_ctrl_dw1 |= MTK_RING_AGE_TIME_L;\n\n\t \n\tring_ctrl_dw2 |= MTK_RING_MAX_AGG_TIME;\n\n\t \n\tring_ctrl_dw2 |= MTK_RING_MAX_AGG_CNT_L;\n\tring_ctrl_dw3 |= MTK_RING_MAX_AGG_CNT_H;\n\n\tfor (i = 1; i < MTK_MAX_RX_RING_NUM; i++) {\n\t\tmtk_w32(eth, ring_ctrl_dw1, MTK_LRO_CTRL_DW1_CFG(i));\n\t\tmtk_w32(eth, ring_ctrl_dw2, MTK_LRO_CTRL_DW2_CFG(i));\n\t\tmtk_w32(eth, ring_ctrl_dw3, MTK_LRO_CTRL_DW3_CFG(i));\n\t}\n\n\t \n\tlro_ctrl_dw0 |= MTK_L3_CKS_UPD_EN;\n\n\t \n\tlro_ctrl_dw0 |= MTK_LRO_ALT_PKT_CNT_MODE;\n\n\t \n\tmtk_w32(eth, MTK_HW_LRO_BW_THRE, MTK_PDMA_LRO_CTRL_DW2);\n\n\t \n\tmtk_w32(eth, MTK_HW_LRO_REPLACE_DELTA, MTK_PDMA_LRO_ALT_SCORE_DELTA);\n\n\t \n\tmtk_w32(eth, (MTK_HW_LRO_TIMER_UNIT << 16) | MTK_HW_LRO_REFRESH_TIME,\n\t\tMTK_PDMA_LRO_ALT_REFRESH_TIMER);\n\n\t \n\tlro_ctrl_dw3 |= MTK_ADMA_MODE | (MTK_HW_LRO_MAX_AGG_CNT & 0xff);\n\n\t \n\tlro_ctrl_dw3 |= MTK_LRO_MIN_RXD_SDL;\n\n\t \n\tlro_ctrl_dw0 |= MTK_LRO_EN;\n\n\tmtk_w32(eth, lro_ctrl_dw3, MTK_PDMA_LRO_CTRL_DW3);\n\tmtk_w32(eth, lro_ctrl_dw0, MTK_PDMA_LRO_CTRL_DW0);\n\n\treturn 0;\n}\n\nstatic void mtk_hwlro_rx_uninit(struct mtk_eth *eth)\n{\n\tint i;\n\tu32 val;\n\n\t \n\tmtk_w32(eth, MTK_LRO_RING_RELINQUISH_REQ, MTK_PDMA_LRO_CTRL_DW0);\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tval = mtk_r32(eth, MTK_PDMA_LRO_CTRL_DW0);\n\t\tif (val & MTK_LRO_RING_RELINQUISH_DONE) {\n\t\t\tmsleep(20);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 1; i < MTK_MAX_RX_RING_NUM; i++)\n\t\tmtk_w32(eth, 0, MTK_LRO_CTRL_DW2_CFG(i));\n\n\t \n\tmtk_w32(eth, 0, MTK_PDMA_LRO_CTRL_DW0);\n}\n\nstatic void mtk_hwlro_val_ipaddr(struct mtk_eth *eth, int idx, __be32 ip)\n{\n\tu32 reg_val;\n\n\treg_val = mtk_r32(eth, MTK_LRO_CTRL_DW2_CFG(idx));\n\n\t \n\tmtk_w32(eth, (reg_val & ~MTK_RING_MYIP_VLD), MTK_LRO_CTRL_DW2_CFG(idx));\n\n\tmtk_w32(eth, ip, MTK_LRO_DIP_DW0_CFG(idx));\n\n\t \n\tmtk_w32(eth, (reg_val | MTK_RING_MYIP_VLD), MTK_LRO_CTRL_DW2_CFG(idx));\n}\n\nstatic void mtk_hwlro_inval_ipaddr(struct mtk_eth *eth, int idx)\n{\n\tu32 reg_val;\n\n\treg_val = mtk_r32(eth, MTK_LRO_CTRL_DW2_CFG(idx));\n\n\t \n\tmtk_w32(eth, (reg_val & ~MTK_RING_MYIP_VLD), MTK_LRO_CTRL_DW2_CFG(idx));\n\n\tmtk_w32(eth, 0, MTK_LRO_DIP_DW0_CFG(idx));\n}\n\nstatic int mtk_hwlro_get_ip_cnt(struct mtk_mac *mac)\n{\n\tint cnt = 0;\n\tint i;\n\n\tfor (i = 0; i < MTK_MAX_LRO_IP_CNT; i++) {\n\t\tif (mac->hwlro_ip[i])\n\t\t\tcnt++;\n\t}\n\n\treturn cnt;\n}\n\nstatic int mtk_hwlro_add_ipaddr(struct net_device *dev,\n\t\t\t\tstruct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\tint hwlro_idx;\n\n\tif ((fsp->flow_type != TCP_V4_FLOW) ||\n\t    (!fsp->h_u.tcp_ip4_spec.ip4dst) ||\n\t    (fsp->location > 1))\n\t\treturn -EINVAL;\n\n\tmac->hwlro_ip[fsp->location] = htonl(fsp->h_u.tcp_ip4_spec.ip4dst);\n\thwlro_idx = (mac->id * MTK_MAX_LRO_IP_CNT) + fsp->location;\n\n\tmac->hwlro_ip_cnt = mtk_hwlro_get_ip_cnt(mac);\n\n\tmtk_hwlro_val_ipaddr(eth, hwlro_idx, mac->hwlro_ip[fsp->location]);\n\n\treturn 0;\n}\n\nstatic int mtk_hwlro_del_ipaddr(struct net_device *dev,\n\t\t\t\tstruct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\tint hwlro_idx;\n\n\tif (fsp->location > 1)\n\t\treturn -EINVAL;\n\n\tmac->hwlro_ip[fsp->location] = 0;\n\thwlro_idx = (mac->id * MTK_MAX_LRO_IP_CNT) + fsp->location;\n\n\tmac->hwlro_ip_cnt = mtk_hwlro_get_ip_cnt(mac);\n\n\tmtk_hwlro_inval_ipaddr(eth, hwlro_idx);\n\n\treturn 0;\n}\n\nstatic void mtk_hwlro_netdev_disable(struct net_device *dev)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\tint i, hwlro_idx;\n\n\tfor (i = 0; i < MTK_MAX_LRO_IP_CNT; i++) {\n\t\tmac->hwlro_ip[i] = 0;\n\t\thwlro_idx = (mac->id * MTK_MAX_LRO_IP_CNT) + i;\n\n\t\tmtk_hwlro_inval_ipaddr(eth, hwlro_idx);\n\t}\n\n\tmac->hwlro_ip_cnt = 0;\n}\n\nstatic int mtk_hwlro_get_fdir_entry(struct net_device *dev,\n\t\t\t\t    struct ethtool_rxnfc *cmd)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\n\tif (fsp->location >= ARRAY_SIZE(mac->hwlro_ip))\n\t\treturn -EINVAL;\n\n\t \n\tfsp->flow_type = TCP_V4_FLOW;\n\tfsp->h_u.tcp_ip4_spec.ip4dst = ntohl(mac->hwlro_ip[fsp->location]);\n\tfsp->m_u.tcp_ip4_spec.ip4dst = 0;\n\n\tfsp->h_u.tcp_ip4_spec.ip4src = 0;\n\tfsp->m_u.tcp_ip4_spec.ip4src = 0xffffffff;\n\tfsp->h_u.tcp_ip4_spec.psrc = 0;\n\tfsp->m_u.tcp_ip4_spec.psrc = 0xffff;\n\tfsp->h_u.tcp_ip4_spec.pdst = 0;\n\tfsp->m_u.tcp_ip4_spec.pdst = 0xffff;\n\tfsp->h_u.tcp_ip4_spec.tos = 0;\n\tfsp->m_u.tcp_ip4_spec.tos = 0xff;\n\n\treturn 0;\n}\n\nstatic int mtk_hwlro_get_fdir_all(struct net_device *dev,\n\t\t\t\t  struct ethtool_rxnfc *cmd,\n\t\t\t\t  u32 *rule_locs)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tint cnt = 0;\n\tint i;\n\n\tfor (i = 0; i < MTK_MAX_LRO_IP_CNT; i++) {\n\t\tif (cnt == cmd->rule_cnt)\n\t\t\treturn -EMSGSIZE;\n\n\t\tif (mac->hwlro_ip[i]) {\n\t\t\trule_locs[cnt] = i;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tcmd->rule_cnt = cnt;\n\n\treturn 0;\n}\n\nstatic netdev_features_t mtk_fix_features(struct net_device *dev,\n\t\t\t\t\t  netdev_features_t features)\n{\n\tif (!(features & NETIF_F_LRO)) {\n\t\tstruct mtk_mac *mac = netdev_priv(dev);\n\t\tint ip_cnt = mtk_hwlro_get_ip_cnt(mac);\n\n\t\tif (ip_cnt) {\n\t\t\tnetdev_info(dev, \"RX flow is programmed, LRO should keep on\\n\");\n\n\t\t\tfeatures |= NETIF_F_LRO;\n\t\t}\n\t}\n\n\treturn features;\n}\n\nstatic int mtk_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tnetdev_features_t diff = dev->features ^ features;\n\n\tif ((diff & NETIF_F_LRO) && !(features & NETIF_F_LRO))\n\t\tmtk_hwlro_netdev_disable(dev);\n\n\treturn 0;\n}\n\n \nstatic int mtk_dma_busy_wait(struct mtk_eth *eth)\n{\n\tunsigned int reg;\n\tint ret;\n\tu32 val;\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA))\n\t\treg = eth->soc->reg_map->qdma.glo_cfg;\n\telse\n\t\treg = eth->soc->reg_map->pdma.glo_cfg;\n\n\tret = readx_poll_timeout_atomic(__raw_readl, eth->base + reg, val,\n\t\t\t\t\t!(val & (MTK_RX_DMA_BUSY | MTK_TX_DMA_BUSY)),\n\t\t\t\t\t5, MTK_DMA_BUSY_TIMEOUT_US);\n\tif (ret)\n\t\tdev_err(eth->dev, \"DMA init timeout\\n\");\n\n\treturn ret;\n}\n\nstatic int mtk_dma_init(struct mtk_eth *eth)\n{\n\tint err;\n\tu32 i;\n\n\tif (mtk_dma_busy_wait(eth))\n\t\treturn -EBUSY;\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA)) {\n\t\t \n\t\terr = mtk_init_fq_dma(eth);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = mtk_tx_alloc(eth);\n\tif (err)\n\t\treturn err;\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA)) {\n\t\terr = mtk_rx_alloc(eth, 0, MTK_RX_FLAGS_QDMA);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = mtk_rx_alloc(eth, 0, MTK_RX_FLAGS_NORMAL);\n\tif (err)\n\t\treturn err;\n\n\tif (eth->hwlro) {\n\t\tfor (i = 1; i < MTK_MAX_RX_RING_NUM; i++) {\n\t\t\terr = mtk_rx_alloc(eth, i, MTK_RX_FLAGS_HWLRO);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = mtk_hwlro_rx_init(eth);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA)) {\n\t\t \n\t\tmtk_w32(eth, FC_THRES_DROP_MODE | FC_THRES_DROP_EN |\n\t\t\tFC_THRES_MIN, eth->soc->reg_map->qdma.fc_th);\n\t\tmtk_w32(eth, 0x0, eth->soc->reg_map->qdma.hred);\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_dma_free(struct mtk_eth *eth)\n{\n\tconst struct mtk_soc_data *soc = eth->soc;\n\tint i;\n\n\tfor (i = 0; i < MTK_MAX_DEVS; i++)\n\t\tif (eth->netdev[i])\n\t\t\tnetdev_reset_queue(eth->netdev[i]);\n\tif (!MTK_HAS_CAPS(soc->caps, MTK_SRAM) && eth->scratch_ring) {\n\t\tdma_free_coherent(eth->dma_dev,\n\t\t\t\t  MTK_QDMA_RING_SIZE * soc->txrx.txd_size,\n\t\t\t\t  eth->scratch_ring, eth->phy_scratch_ring);\n\t\teth->scratch_ring = NULL;\n\t\teth->phy_scratch_ring = 0;\n\t}\n\tmtk_tx_clean(eth);\n\tmtk_rx_clean(eth, &eth->rx_ring[0], MTK_HAS_CAPS(soc->caps, MTK_SRAM));\n\tmtk_rx_clean(eth, &eth->rx_ring_qdma, false);\n\n\tif (eth->hwlro) {\n\t\tmtk_hwlro_rx_uninit(eth);\n\t\tfor (i = 1; i < MTK_MAX_RX_RING_NUM; i++)\n\t\t\tmtk_rx_clean(eth, &eth->rx_ring[i], false);\n\t}\n\n\tkfree(eth->scratch_head);\n}\n\nstatic bool mtk_hw_reset_check(struct mtk_eth *eth)\n{\n\tu32 val = mtk_r32(eth, MTK_INT_STATUS2);\n\n\treturn (val & MTK_FE_INT_FQ_EMPTY) || (val & MTK_FE_INT_RFIFO_UF) ||\n\t       (val & MTK_FE_INT_RFIFO_OV) || (val & MTK_FE_INT_TSO_FAIL) ||\n\t       (val & MTK_FE_INT_TSO_ALIGN) || (val & MTK_FE_INT_TSO_ILLEGAL);\n}\n\nstatic void mtk_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\n\tif (test_bit(MTK_RESETTING, &eth->state))\n\t\treturn;\n\n\tif (!mtk_hw_reset_check(eth))\n\t\treturn;\n\n\teth->netdev[mac->id]->stats.tx_errors++;\n\tnetif_err(eth, tx_err, dev, \"transmit timed out\\n\");\n\n\tschedule_work(&eth->pending_work);\n}\n\nstatic irqreturn_t mtk_handle_irq_rx(int irq, void *_eth)\n{\n\tstruct mtk_eth *eth = _eth;\n\n\teth->rx_events++;\n\tif (likely(napi_schedule_prep(&eth->rx_napi))) {\n\t\tmtk_rx_irq_disable(eth, eth->soc->txrx.rx_irq_done_mask);\n\t\t__napi_schedule(&eth->rx_napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mtk_handle_irq_tx(int irq, void *_eth)\n{\n\tstruct mtk_eth *eth = _eth;\n\n\teth->tx_events++;\n\tif (likely(napi_schedule_prep(&eth->tx_napi))) {\n\t\tmtk_tx_irq_disable(eth, MTK_TX_DONE_INT);\n\t\t__napi_schedule(&eth->tx_napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mtk_handle_irq(int irq, void *_eth)\n{\n\tstruct mtk_eth *eth = _eth;\n\tconst struct mtk_reg_map *reg_map = eth->soc->reg_map;\n\n\tif (mtk_r32(eth, reg_map->pdma.irq_mask) &\n\t    eth->soc->txrx.rx_irq_done_mask) {\n\t\tif (mtk_r32(eth, reg_map->pdma.irq_status) &\n\t\t    eth->soc->txrx.rx_irq_done_mask)\n\t\t\tmtk_handle_irq_rx(irq, _eth);\n\t}\n\tif (mtk_r32(eth, reg_map->tx_irq_mask) & MTK_TX_DONE_INT) {\n\t\tif (mtk_r32(eth, reg_map->tx_irq_status) & MTK_TX_DONE_INT)\n\t\t\tmtk_handle_irq_tx(irq, _eth);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void mtk_poll_controller(struct net_device *dev)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\n\tmtk_tx_irq_disable(eth, MTK_TX_DONE_INT);\n\tmtk_rx_irq_disable(eth, eth->soc->txrx.rx_irq_done_mask);\n\tmtk_handle_irq_rx(eth->irq[2], dev);\n\tmtk_tx_irq_enable(eth, MTK_TX_DONE_INT);\n\tmtk_rx_irq_enable(eth, eth->soc->txrx.rx_irq_done_mask);\n}\n#endif\n\nstatic int mtk_start_dma(struct mtk_eth *eth)\n{\n\tu32 val, rx_2b_offset = (NET_IP_ALIGN == 2) ? MTK_RX_2B_OFFSET : 0;\n\tconst struct mtk_reg_map *reg_map = eth->soc->reg_map;\n\tint err;\n\n\terr = mtk_dma_init(eth);\n\tif (err) {\n\t\tmtk_dma_free(eth);\n\t\treturn err;\n\t}\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA)) {\n\t\tval = mtk_r32(eth, reg_map->qdma.glo_cfg);\n\t\tval |= MTK_TX_DMA_EN | MTK_RX_DMA_EN |\n\t\t       MTK_TX_BT_32DWORDS | MTK_NDP_CO_PRO |\n\t\t       MTK_RX_2B_OFFSET | MTK_TX_WB_DDONE;\n\n\t\tif (mtk_is_netsys_v2_or_greater(eth))\n\t\t\tval |= MTK_MUTLI_CNT | MTK_RESV_BUF |\n\t\t\t       MTK_WCOMP_EN | MTK_DMAD_WR_WDONE |\n\t\t\t       MTK_CHK_DDONE_EN | MTK_LEAKY_BUCKET_EN;\n\t\telse\n\t\t\tval |= MTK_RX_BT_32DWORDS;\n\t\tmtk_w32(eth, val, reg_map->qdma.glo_cfg);\n\n\t\tmtk_w32(eth,\n\t\t\tMTK_RX_DMA_EN | rx_2b_offset |\n\t\t\tMTK_RX_BT_32DWORDS | MTK_MULTI_EN,\n\t\t\treg_map->pdma.glo_cfg);\n\t} else {\n\t\tmtk_w32(eth, MTK_TX_WB_DDONE | MTK_TX_DMA_EN | MTK_RX_DMA_EN |\n\t\t\tMTK_MULTI_EN | MTK_PDMA_SIZE_8DWORDS,\n\t\t\treg_map->pdma.glo_cfg);\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_gdm_config(struct mtk_eth *eth, u32 config)\n{\n\tint i;\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628))\n\t\treturn;\n\n\tfor (i = 0; i < MTK_MAX_DEVS; i++) {\n\t\tu32 val;\n\n\t\tif (!eth->netdev[i])\n\t\t\tcontinue;\n\n\t\tval = mtk_r32(eth, MTK_GDMA_FWD_CFG(i));\n\n\t\t \n\t\tval &= ~0xffff;\n\n\t\t \n\t\tval |= MTK_GDMA_ICS_EN | MTK_GDMA_TCS_EN | MTK_GDMA_UCS_EN;\n\n\t\tval |= config;\n\n\t\tif (netdev_uses_dsa(eth->netdev[i]))\n\t\t\tval |= MTK_GDMA_SPECIAL_TAG;\n\n\t\tmtk_w32(eth, val, MTK_GDMA_FWD_CFG(i));\n\t}\n\t \n\tmtk_w32(eth, RST_GL_PSE, MTK_RST_GL);\n\tmtk_w32(eth, 0, MTK_RST_GL);\n}\n\n\nstatic bool mtk_uses_dsa(struct net_device *dev)\n{\n#if IS_ENABLED(CONFIG_NET_DSA)\n\treturn netdev_uses_dsa(dev) &&\n\t       dev->dsa_ptr->tag_ops->proto == DSA_TAG_PROTO_MTK;\n#else\n\treturn false;\n#endif\n}\n\nstatic int mtk_device_event(struct notifier_block *n, unsigned long event, void *ptr)\n{\n\tstruct mtk_mac *mac = container_of(n, struct mtk_mac, device_notifier);\n\tstruct mtk_eth *eth = mac->hw;\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct ethtool_link_ksettings s;\n\tstruct net_device *ldev;\n\tstruct list_head *iter;\n\tstruct dsa_port *dp;\n\n\tif (event != NETDEV_CHANGE)\n\t\treturn NOTIFY_DONE;\n\n\tnetdev_for_each_lower_dev(dev, ldev, iter) {\n\t\tif (netdev_priv(ldev) == mac)\n\t\t\tgoto found;\n\t}\n\n\treturn NOTIFY_DONE;\n\nfound:\n\tif (!dsa_slave_dev_check(dev))\n\t\treturn NOTIFY_DONE;\n\n\tif (__ethtool_get_link_ksettings(dev, &s))\n\t\treturn NOTIFY_DONE;\n\n\tif (s.base.speed == 0 || s.base.speed == ((__u32)-1))\n\t\treturn NOTIFY_DONE;\n\n\tdp = dsa_port_from_netdev(dev);\n\tif (dp->index >= MTK_QDMA_NUM_QUEUES)\n\t\treturn NOTIFY_DONE;\n\n\tif (mac->speed > 0 && mac->speed <= s.base.speed)\n\t\ts.base.speed = 0;\n\n\tmtk_set_queue_speed(eth, dp->index + 3, s.base.speed);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int mtk_open(struct net_device *dev)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\tint i, err;\n\n\terr = phylink_of_phy_connect(mac->phylink, mac->of_node, 0);\n\tif (err) {\n\t\tnetdev_err(dev, \"%s: could not attach PHY: %d\\n\", __func__,\n\t\t\t   err);\n\t\treturn err;\n\t}\n\n\t \n\tif (!refcount_read(&eth->dma_refcnt)) {\n\t\tconst struct mtk_soc_data *soc = eth->soc;\n\t\tu32 gdm_config;\n\t\tint i;\n\n\t\terr = mtk_start_dma(eth);\n\t\tif (err) {\n\t\t\tphylink_disconnect_phy(mac->phylink);\n\t\t\treturn err;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(eth->ppe); i++)\n\t\t\tmtk_ppe_start(eth->ppe[i]);\n\n\t\tgdm_config = soc->offload_version ? soc->reg_map->gdma_to_ppe\n\t\t\t\t\t\t  : MTK_GDMA_TO_PDMA;\n\t\tmtk_gdm_config(eth, gdm_config);\n\n\t\tnapi_enable(&eth->tx_napi);\n\t\tnapi_enable(&eth->rx_napi);\n\t\tmtk_tx_irq_enable(eth, MTK_TX_DONE_INT);\n\t\tmtk_rx_irq_enable(eth, soc->txrx.rx_irq_done_mask);\n\t\trefcount_set(&eth->dma_refcnt, 1);\n\t}\n\telse\n\t\trefcount_inc(&eth->dma_refcnt);\n\n\tphylink_start(mac->phylink);\n\tnetif_tx_start_all_queues(dev);\n\n\tif (mtk_is_netsys_v2_or_greater(eth))\n\t\treturn 0;\n\n\tif (mtk_uses_dsa(dev) && !eth->prog) {\n\t\tfor (i = 0; i < ARRAY_SIZE(eth->dsa_meta); i++) {\n\t\t\tstruct metadata_dst *md_dst = eth->dsa_meta[i];\n\n\t\t\tif (md_dst)\n\t\t\t\tcontinue;\n\n\t\t\tmd_dst = metadata_dst_alloc(0, METADATA_HW_PORT_MUX,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\t\tif (!md_dst)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmd_dst->u.port_info.port_id = i;\n\t\t\teth->dsa_meta[i] = md_dst;\n\t\t}\n\t} else {\n\t\t \n\t\tu32 val = mtk_r32(eth, MTK_CDMP_IG_CTRL);\n\n\t\tval &= ~MTK_CDMP_STAG_EN;\n\t\tmtk_w32(eth, val, MTK_CDMP_IG_CTRL);\n\n\t\tmtk_w32(eth, 0, MTK_CDMP_EG_CTRL);\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_stop_dma(struct mtk_eth *eth, u32 glo_cfg)\n{\n\tu32 val;\n\tint i;\n\n\t \n\tspin_lock_bh(&eth->page_lock);\n\tval = mtk_r32(eth, glo_cfg);\n\tmtk_w32(eth, val & ~(MTK_TX_WB_DDONE | MTK_RX_DMA_EN | MTK_TX_DMA_EN),\n\t\tglo_cfg);\n\tspin_unlock_bh(&eth->page_lock);\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tval = mtk_r32(eth, glo_cfg);\n\t\tif (val & (MTK_TX_DMA_BUSY | MTK_RX_DMA_BUSY)) {\n\t\t\tmsleep(20);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int mtk_stop(struct net_device *dev)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\tint i;\n\n\tphylink_stop(mac->phylink);\n\n\tnetif_tx_disable(dev);\n\n\tphylink_disconnect_phy(mac->phylink);\n\n\t \n\tif (!refcount_dec_and_test(&eth->dma_refcnt))\n\t\treturn 0;\n\n\tmtk_gdm_config(eth, MTK_GDMA_DROP_ALL);\n\n\tmtk_tx_irq_disable(eth, MTK_TX_DONE_INT);\n\tmtk_rx_irq_disable(eth, eth->soc->txrx.rx_irq_done_mask);\n\tnapi_disable(&eth->tx_napi);\n\tnapi_disable(&eth->rx_napi);\n\n\tcancel_work_sync(&eth->rx_dim.work);\n\tcancel_work_sync(&eth->tx_dim.work);\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA))\n\t\tmtk_stop_dma(eth, eth->soc->reg_map->qdma.glo_cfg);\n\tmtk_stop_dma(eth, eth->soc->reg_map->pdma.glo_cfg);\n\n\tmtk_dma_free(eth);\n\n\tfor (i = 0; i < ARRAY_SIZE(eth->ppe); i++)\n\t\tmtk_ppe_stop(eth->ppe[i]);\n\n\treturn 0;\n}\n\nstatic int mtk_xdp_setup(struct net_device *dev, struct bpf_prog *prog,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\tstruct bpf_prog *old_prog;\n\tbool need_update;\n\n\tif (eth->hwlro) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"XDP not supported with HWLRO\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (dev->mtu > MTK_PP_MAX_BUF_SIZE) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"MTU too large for XDP\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tneed_update = !!eth->prog != !!prog;\n\tif (netif_running(dev) && need_update)\n\t\tmtk_stop(dev);\n\n\told_prog = rcu_replace_pointer(eth->prog, prog, lockdep_rtnl_is_held());\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\n\tif (netif_running(dev) && need_update)\n\t\treturn mtk_open(dev);\n\n\treturn 0;\n}\n\nstatic int mtk_xdp(struct net_device *dev, struct netdev_bpf *xdp)\n{\n\tswitch (xdp->command) {\n\tcase XDP_SETUP_PROG:\n\t\treturn mtk_xdp_setup(dev, xdp->prog, xdp->extack);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void ethsys_reset(struct mtk_eth *eth, u32 reset_bits)\n{\n\tregmap_update_bits(eth->ethsys, ETHSYS_RSTCTRL,\n\t\t\t   reset_bits,\n\t\t\t   reset_bits);\n\n\tusleep_range(1000, 1100);\n\tregmap_update_bits(eth->ethsys, ETHSYS_RSTCTRL,\n\t\t\t   reset_bits,\n\t\t\t   ~reset_bits);\n\tmdelay(10);\n}\n\nstatic void mtk_clk_disable(struct mtk_eth *eth)\n{\n\tint clk;\n\n\tfor (clk = MTK_CLK_MAX - 1; clk >= 0; clk--)\n\t\tclk_disable_unprepare(eth->clks[clk]);\n}\n\nstatic int mtk_clk_enable(struct mtk_eth *eth)\n{\n\tint clk, ret;\n\n\tfor (clk = 0; clk < MTK_CLK_MAX ; clk++) {\n\t\tret = clk_prepare_enable(eth->clks[clk]);\n\t\tif (ret)\n\t\t\tgoto err_disable_clks;\n\t}\n\n\treturn 0;\n\nerr_disable_clks:\n\twhile (--clk >= 0)\n\t\tclk_disable_unprepare(eth->clks[clk]);\n\n\treturn ret;\n}\n\nstatic void mtk_dim_rx(struct work_struct *work)\n{\n\tstruct dim *dim = container_of(work, struct dim, work);\n\tstruct mtk_eth *eth = container_of(dim, struct mtk_eth, rx_dim);\n\tconst struct mtk_reg_map *reg_map = eth->soc->reg_map;\n\tstruct dim_cq_moder cur_profile;\n\tu32 val, cur;\n\n\tcur_profile = net_dim_get_rx_moderation(eth->rx_dim.mode,\n\t\t\t\t\t\tdim->profile_ix);\n\tspin_lock_bh(&eth->dim_lock);\n\n\tval = mtk_r32(eth, reg_map->pdma.delay_irq);\n\tval &= MTK_PDMA_DELAY_TX_MASK;\n\tval |= MTK_PDMA_DELAY_RX_EN;\n\n\tcur = min_t(u32, DIV_ROUND_UP(cur_profile.usec, 20), MTK_PDMA_DELAY_PTIME_MASK);\n\tval |= cur << MTK_PDMA_DELAY_RX_PTIME_SHIFT;\n\n\tcur = min_t(u32, cur_profile.pkts, MTK_PDMA_DELAY_PINT_MASK);\n\tval |= cur << MTK_PDMA_DELAY_RX_PINT_SHIFT;\n\n\tmtk_w32(eth, val, reg_map->pdma.delay_irq);\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA))\n\t\tmtk_w32(eth, val, reg_map->qdma.delay_irq);\n\n\tspin_unlock_bh(&eth->dim_lock);\n\n\tdim->state = DIM_START_MEASURE;\n}\n\nstatic void mtk_dim_tx(struct work_struct *work)\n{\n\tstruct dim *dim = container_of(work, struct dim, work);\n\tstruct mtk_eth *eth = container_of(dim, struct mtk_eth, tx_dim);\n\tconst struct mtk_reg_map *reg_map = eth->soc->reg_map;\n\tstruct dim_cq_moder cur_profile;\n\tu32 val, cur;\n\n\tcur_profile = net_dim_get_tx_moderation(eth->tx_dim.mode,\n\t\t\t\t\t\tdim->profile_ix);\n\tspin_lock_bh(&eth->dim_lock);\n\n\tval = mtk_r32(eth, reg_map->pdma.delay_irq);\n\tval &= MTK_PDMA_DELAY_RX_MASK;\n\tval |= MTK_PDMA_DELAY_TX_EN;\n\n\tcur = min_t(u32, DIV_ROUND_UP(cur_profile.usec, 20), MTK_PDMA_DELAY_PTIME_MASK);\n\tval |= cur << MTK_PDMA_DELAY_TX_PTIME_SHIFT;\n\n\tcur = min_t(u32, cur_profile.pkts, MTK_PDMA_DELAY_PINT_MASK);\n\tval |= cur << MTK_PDMA_DELAY_TX_PINT_SHIFT;\n\n\tmtk_w32(eth, val, reg_map->pdma.delay_irq);\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA))\n\t\tmtk_w32(eth, val, reg_map->qdma.delay_irq);\n\n\tspin_unlock_bh(&eth->dim_lock);\n\n\tdim->state = DIM_START_MEASURE;\n}\n\nstatic void mtk_set_mcr_max_rx(struct mtk_mac *mac, u32 val)\n{\n\tstruct mtk_eth *eth = mac->hw;\n\tu32 mcr_cur, mcr_new;\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628))\n\t\treturn;\n\n\tmcr_cur = mtk_r32(mac->hw, MTK_MAC_MCR(mac->id));\n\tmcr_new = mcr_cur & ~MAC_MCR_MAX_RX_MASK;\n\n\tif (val <= 1518)\n\t\tmcr_new |= MAC_MCR_MAX_RX(MAC_MCR_MAX_RX_1518);\n\telse if (val <= 1536)\n\t\tmcr_new |= MAC_MCR_MAX_RX(MAC_MCR_MAX_RX_1536);\n\telse if (val <= 1552)\n\t\tmcr_new |= MAC_MCR_MAX_RX(MAC_MCR_MAX_RX_1552);\n\telse\n\t\tmcr_new |= MAC_MCR_MAX_RX(MAC_MCR_MAX_RX_2048);\n\n\tif (mcr_new != mcr_cur)\n\t\tmtk_w32(mac->hw, mcr_new, MTK_MAC_MCR(mac->id));\n}\n\nstatic void mtk_hw_reset(struct mtk_eth *eth)\n{\n\tu32 val;\n\n\tif (mtk_is_netsys_v2_or_greater(eth))\n\t\tregmap_write(eth->ethsys, ETHSYS_FE_RST_CHK_IDLE_EN, 0);\n\n\tif (mtk_is_netsys_v3_or_greater(eth)) {\n\t\tval = RSTCTRL_PPE0_V3;\n\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_RSTCTRL_PPE1))\n\t\t\tval |= RSTCTRL_PPE1_V3;\n\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_RSTCTRL_PPE2))\n\t\t\tval |= RSTCTRL_PPE2;\n\n\t\tval |= RSTCTRL_WDMA0 | RSTCTRL_WDMA1 | RSTCTRL_WDMA2;\n\t} else if (mtk_is_netsys_v2_or_greater(eth)) {\n\t\tval = RSTCTRL_PPE0_V2;\n\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_RSTCTRL_PPE1))\n\t\t\tval |= RSTCTRL_PPE1;\n\t} else {\n\t\tval = RSTCTRL_PPE0;\n\t}\n\n\tethsys_reset(eth, RSTCTRL_ETH | RSTCTRL_FE | val);\n\n\tif (mtk_is_netsys_v3_or_greater(eth))\n\t\tregmap_write(eth->ethsys, ETHSYS_FE_RST_CHK_IDLE_EN,\n\t\t\t     0x6f8ff);\n\telse if (mtk_is_netsys_v2_or_greater(eth))\n\t\tregmap_write(eth->ethsys, ETHSYS_FE_RST_CHK_IDLE_EN,\n\t\t\t     0x3ffffff);\n}\n\nstatic u32 mtk_hw_reset_read(struct mtk_eth *eth)\n{\n\tu32 val;\n\n\tregmap_read(eth->ethsys, ETHSYS_RSTCTRL, &val);\n\treturn val;\n}\n\nstatic void mtk_hw_warm_reset(struct mtk_eth *eth)\n{\n\tu32 rst_mask, val;\n\n\tregmap_update_bits(eth->ethsys, ETHSYS_RSTCTRL, RSTCTRL_FE,\n\t\t\t   RSTCTRL_FE);\n\tif (readx_poll_timeout_atomic(mtk_hw_reset_read, eth, val,\n\t\t\t\t      val & RSTCTRL_FE, 1, 1000)) {\n\t\tdev_err(eth->dev, \"warm reset failed\\n\");\n\t\tmtk_hw_reset(eth);\n\t\treturn;\n\t}\n\n\tif (mtk_is_netsys_v3_or_greater(eth)) {\n\t\trst_mask = RSTCTRL_ETH | RSTCTRL_PPE0_V3;\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_RSTCTRL_PPE1))\n\t\t\trst_mask |= RSTCTRL_PPE1_V3;\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_RSTCTRL_PPE2))\n\t\t\trst_mask |= RSTCTRL_PPE2;\n\n\t\trst_mask |= RSTCTRL_WDMA0 | RSTCTRL_WDMA1 | RSTCTRL_WDMA2;\n\t} else if (mtk_is_netsys_v2_or_greater(eth)) {\n\t\trst_mask = RSTCTRL_ETH | RSTCTRL_PPE0_V2;\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_RSTCTRL_PPE1))\n\t\t\trst_mask |= RSTCTRL_PPE1;\n\t} else {\n\t\trst_mask = RSTCTRL_ETH | RSTCTRL_PPE0;\n\t}\n\n\tregmap_update_bits(eth->ethsys, ETHSYS_RSTCTRL, rst_mask, rst_mask);\n\n\tudelay(1);\n\tval = mtk_hw_reset_read(eth);\n\tif (!(val & rst_mask))\n\t\tdev_err(eth->dev, \"warm reset stage0 failed %08x (%08x)\\n\",\n\t\t\tval, rst_mask);\n\n\trst_mask |= RSTCTRL_FE;\n\tregmap_update_bits(eth->ethsys, ETHSYS_RSTCTRL, rst_mask, ~rst_mask);\n\n\tudelay(1);\n\tval = mtk_hw_reset_read(eth);\n\tif (val & rst_mask)\n\t\tdev_err(eth->dev, \"warm reset stage1 failed %08x (%08x)\\n\",\n\t\t\tval, rst_mask);\n}\n\nstatic bool mtk_hw_check_dma_hang(struct mtk_eth *eth)\n{\n\tconst struct mtk_reg_map *reg_map = eth->soc->reg_map;\n\tbool gmac1_tx, gmac2_tx, gdm1_tx, gdm2_tx;\n\tbool oq_hang, cdm1_busy, adma_busy;\n\tbool wtx_busy, cdm_full, oq_free;\n\tu32 wdidx, val, gdm1_fc, gdm2_fc;\n\tbool qfsm_hang, qfwd_hang;\n\tbool ret = false;\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628))\n\t\treturn false;\n\n\t \n\twdidx = mtk_r32(eth, reg_map->wdma_base[0] + 0xc);\n\n\tval = mtk_r32(eth, reg_map->wdma_base[0] + 0x204);\n\twtx_busy = FIELD_GET(MTK_TX_DMA_BUSY, val);\n\n\tval = mtk_r32(eth, reg_map->wdma_base[0] + 0x230);\n\tcdm_full = !FIELD_GET(MTK_CDM_TXFIFO_RDY, val);\n\n\toq_free  = (!(mtk_r32(eth, reg_map->pse_oq_sta) & GENMASK(24, 16)) &&\n\t\t    !(mtk_r32(eth, reg_map->pse_oq_sta + 0x4) & GENMASK(8, 0)) &&\n\t\t    !(mtk_r32(eth, reg_map->pse_oq_sta + 0x10) & GENMASK(24, 16)));\n\n\tif (wdidx == eth->reset.wdidx && wtx_busy && cdm_full && oq_free) {\n\t\tif (++eth->reset.wdma_hang_count > 2) {\n\t\t\teth->reset.wdma_hang_count = 0;\n\t\t\tret = true;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tqfsm_hang = !!mtk_r32(eth, reg_map->qdma.qtx_cfg + 0x234);\n\tqfwd_hang = !mtk_r32(eth, reg_map->qdma.qtx_cfg + 0x308);\n\n\tgdm1_tx = FIELD_GET(GENMASK(31, 16), mtk_r32(eth, MTK_FE_GDM1_FSM)) > 0;\n\tgdm2_tx = FIELD_GET(GENMASK(31, 16), mtk_r32(eth, MTK_FE_GDM2_FSM)) > 0;\n\tgmac1_tx = FIELD_GET(GENMASK(31, 24), mtk_r32(eth, MTK_MAC_FSM(0))) != 1;\n\tgmac2_tx = FIELD_GET(GENMASK(31, 24), mtk_r32(eth, MTK_MAC_FSM(1))) != 1;\n\tgdm1_fc = mtk_r32(eth, reg_map->gdm1_cnt + 0x24);\n\tgdm2_fc = mtk_r32(eth, reg_map->gdm1_cnt + 0x64);\n\n\tif (qfsm_hang && qfwd_hang &&\n\t    ((gdm1_tx && gmac1_tx && gdm1_fc < 1) ||\n\t     (gdm2_tx && gmac2_tx && gdm2_fc < 1))) {\n\t\tif (++eth->reset.qdma_hang_count > 2) {\n\t\t\teth->reset.qdma_hang_count = 0;\n\t\t\tret = true;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\toq_hang = !!(mtk_r32(eth, reg_map->pse_oq_sta) & GENMASK(8, 0));\n\tcdm1_busy = !!(mtk_r32(eth, MTK_FE_CDM1_FSM) & GENMASK(31, 16));\n\tadma_busy = !(mtk_r32(eth, reg_map->pdma.adma_rx_dbg0) & GENMASK(4, 0)) &&\n\t\t    !(mtk_r32(eth, reg_map->pdma.adma_rx_dbg0) & BIT(6));\n\n\tif (oq_hang && cdm1_busy && adma_busy) {\n\t\tif (++eth->reset.adma_hang_count > 2) {\n\t\t\teth->reset.adma_hang_count = 0;\n\t\t\tret = true;\n\t\t}\n\t\tgoto out;\n\t}\n\n\teth->reset.wdma_hang_count = 0;\n\teth->reset.qdma_hang_count = 0;\n\teth->reset.adma_hang_count = 0;\nout:\n\teth->reset.wdidx = wdidx;\n\n\treturn ret;\n}\n\nstatic void mtk_hw_reset_monitor_work(struct work_struct *work)\n{\n\tstruct delayed_work *del_work = to_delayed_work(work);\n\tstruct mtk_eth *eth = container_of(del_work, struct mtk_eth,\n\t\t\t\t\t   reset.monitor_work);\n\n\tif (test_bit(MTK_RESETTING, &eth->state))\n\t\tgoto out;\n\n\t \n\tif (mtk_hw_check_dma_hang(eth))\n\t\tschedule_work(&eth->pending_work);\n\nout:\n\tschedule_delayed_work(&eth->reset.monitor_work,\n\t\t\t      MTK_DMA_MONITOR_TIMEOUT);\n}\n\nstatic int mtk_hw_init(struct mtk_eth *eth, bool reset)\n{\n\tu32 dma_mask = ETHSYS_DMA_AG_MAP_PDMA | ETHSYS_DMA_AG_MAP_QDMA |\n\t\t       ETHSYS_DMA_AG_MAP_PPE;\n\tconst struct mtk_reg_map *reg_map = eth->soc->reg_map;\n\tint i, val, ret;\n\n\tif (!reset && test_and_set_bit(MTK_HW_INIT, &eth->state))\n\t\treturn 0;\n\n\tif (!reset) {\n\t\tpm_runtime_enable(eth->dev);\n\t\tpm_runtime_get_sync(eth->dev);\n\n\t\tret = mtk_clk_enable(eth);\n\t\tif (ret)\n\t\t\tgoto err_disable_pm;\n\t}\n\n\tif (eth->ethsys)\n\t\tregmap_update_bits(eth->ethsys, ETHSYS_DMA_AG_MAP, dma_mask,\n\t\t\t\t   of_dma_is_coherent(eth->dma_dev->of_node) * dma_mask);\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628)) {\n\t\tret = device_reset(eth->dev);\n\t\tif (ret) {\n\t\t\tdev_err(eth->dev, \"MAC reset failed!\\n\");\n\t\t\tgoto err_disable_pm;\n\t\t}\n\n\t\t \n\t\tmtk_dim_rx(&eth->rx_dim.work);\n\t\tmtk_dim_tx(&eth->tx_dim.work);\n\n\t\t \n\t\tmtk_tx_irq_disable(eth, ~0);\n\t\tmtk_rx_irq_disable(eth, ~0);\n\n\t\treturn 0;\n\t}\n\n\tmsleep(100);\n\n\tif (reset)\n\t\tmtk_hw_warm_reset(eth);\n\telse\n\t\tmtk_hw_reset(eth);\n\n\tif (mtk_is_netsys_v2_or_greater(eth)) {\n\t\t \n\t\tval = mtk_r32(eth, MTK_FE_GLO_MISC);\n\t\tmtk_w32(eth,  val | BIT(4), MTK_FE_GLO_MISC);\n\t}\n\n\tif (eth->pctl) {\n\t\t \n\t\tregmap_write(eth->pctl, GPIO_DRV_SEL10, 0xa00);\n\n\t\t \n\t\tregmap_write(eth->pctl, GPIO_OD33_CTRL8, 0x5);\n\n\t\t \n\t\tregmap_write(eth->pctl, GPIO_BIAS_CTRL, 0x0);\n\t}\n\n\t \n\tfor (i = 0; i < MTK_MAX_DEVS; i++) {\n\t\tstruct net_device *dev = eth->netdev[i];\n\n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\tmtk_w32(eth, MAC_MCR_FORCE_LINK_DOWN, MTK_MAC_MCR(i));\n\t\tmtk_set_mcr_max_rx(netdev_priv(dev),\n\t\t\t\t   dev->mtu + MTK_RX_ETH_HLEN);\n\t}\n\n\t \n\tval = mtk_r32(eth, MTK_CDMQ_IG_CTRL);\n\tmtk_w32(eth, val | MTK_CDMQ_STAG_EN, MTK_CDMQ_IG_CTRL);\n\tif (mtk_is_netsys_v1(eth)) {\n\t\tval = mtk_r32(eth, MTK_CDMP_IG_CTRL);\n\t\tmtk_w32(eth, val | MTK_CDMP_STAG_EN, MTK_CDMP_IG_CTRL);\n\n\t\tmtk_w32(eth, 1, MTK_CDMP_EG_CTRL);\n\t}\n\n\t \n\tmtk_dim_rx(&eth->rx_dim.work);\n\tmtk_dim_tx(&eth->tx_dim.work);\n\n\t \n\tmtk_tx_irq_disable(eth, ~0);\n\tmtk_rx_irq_disable(eth, ~0);\n\n\t \n\tmtk_w32(eth, MTK_TX_DONE_INT, reg_map->pdma.int_grp);\n\tmtk_w32(eth, eth->soc->txrx.rx_irq_done_mask, reg_map->pdma.int_grp + 4);\n\tmtk_w32(eth, MTK_TX_DONE_INT, reg_map->qdma.int_grp);\n\tmtk_w32(eth, eth->soc->txrx.rx_irq_done_mask, reg_map->qdma.int_grp + 4);\n\tmtk_w32(eth, 0x21021000, MTK_FE_INT_GRP);\n\n\tif (mtk_is_netsys_v3_or_greater(eth)) {\n\t\t \n\t\tmtk_w32(eth, 0x00000302, PSE_DROP_CFG);\n\n\t\t \n\t\tmtk_w32(eth, 0x00000707, MTK_CDMW0_THRES);\n\t\tmtk_w32(eth, 0x00000077, MTK_CDMW1_THRES);\n\n\t\t \n\t\tmtk_m32(eth, MTK_GDMA_STRP_CRC, 0, MTK_GDMA_FWD_CFG(0));\n\n\t\t \n\t\tfor (i = 0; i < 0x80; i += 0x4)\n\t\t\tmtk_r32(eth, reg_map->gdm1_cnt + 0x100 + i);\n\t} else if (!mtk_is_netsys_v1(eth)) {\n\t\t \n\t\tmtk_w32(eth, 0x00000300, PSE_DROP_CFG);\n\n\t\t \n\t\tmtk_w32(eth, 0x00000300, PSE_PPE0_DROP);\n\n\t\t \n\t\tmtk_w32(eth, 0x01fa01f4, PSE_FQFC_CFG2);\n\n\t\t \n\t\tmtk_w32(eth, 0x001a000e, PSE_IQ_REV(1));\n\t\tmtk_w32(eth, 0x01ff001a, PSE_IQ_REV(2));\n\t\tmtk_w32(eth, 0x000e01ff, PSE_IQ_REV(3));\n\t\tmtk_w32(eth, 0x000e000e, PSE_IQ_REV(4));\n\t\tmtk_w32(eth, 0x000e000e, PSE_IQ_REV(5));\n\t\tmtk_w32(eth, 0x000e000e, PSE_IQ_REV(6));\n\t\tmtk_w32(eth, 0x000e000e, PSE_IQ_REV(7));\n\t\tmtk_w32(eth, 0x000e000e, PSE_IQ_REV(8));\n\n\t\t \n\t\tmtk_w32(eth, 0x000f000a, PSE_OQ_TH(1));\n\t\tmtk_w32(eth, 0x001a000f, PSE_OQ_TH(2));\n\t\tmtk_w32(eth, 0x000f001a, PSE_OQ_TH(3));\n\t\tmtk_w32(eth, 0x01ff000f, PSE_OQ_TH(4));\n\t\tmtk_w32(eth, 0x000f000f, PSE_OQ_TH(5));\n\t\tmtk_w32(eth, 0x0006000f, PSE_OQ_TH(6));\n\t\tmtk_w32(eth, 0x00060006, PSE_OQ_TH(7));\n\t\tmtk_w32(eth, 0x00060006, PSE_OQ_TH(8));\n\n\t\t \n\t\tmtk_w32(eth, 0x00000004, MTK_GDM2_THRES);\n\t\tmtk_w32(eth, 0x00000004, MTK_CDMW0_THRES);\n\t\tmtk_w32(eth, 0x00000004, MTK_CDMW1_THRES);\n\t\tmtk_w32(eth, 0x00000004, MTK_CDME0_THRES);\n\t\tmtk_w32(eth, 0x00000004, MTK_CDME1_THRES);\n\t\tmtk_w32(eth, 0x00000004, MTK_CDMM_THRES);\n\t}\n\n\treturn 0;\n\nerr_disable_pm:\n\tif (!reset) {\n\t\tpm_runtime_put_sync(eth->dev);\n\t\tpm_runtime_disable(eth->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int mtk_hw_deinit(struct mtk_eth *eth)\n{\n\tif (!test_and_clear_bit(MTK_HW_INIT, &eth->state))\n\t\treturn 0;\n\n\tmtk_clk_disable(eth);\n\n\tpm_runtime_put_sync(eth->dev);\n\tpm_runtime_disable(eth->dev);\n\n\treturn 0;\n}\n\nstatic void mtk_uninit(struct net_device *dev)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\n\tphylink_disconnect_phy(mac->phylink);\n\tmtk_tx_irq_disable(eth, ~0);\n\tmtk_rx_irq_disable(eth, ~0);\n}\n\nstatic int mtk_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tint length = new_mtu + MTK_RX_ETH_HLEN;\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_eth *eth = mac->hw;\n\n\tif (rcu_access_pointer(eth->prog) &&\n\t    length > MTK_PP_MAX_BUF_SIZE) {\n\t\tnetdev_err(dev, \"Invalid MTU for XDP mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmtk_set_mcr_max_rx(mac, length);\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\nstatic int mtk_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn phylink_mii_ioctl(mac->phylink, ifr, cmd);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void mtk_prepare_for_reset(struct mtk_eth *eth)\n{\n\tu32 val;\n\tint i;\n\n\t \n\tfor (i = MTK_GMAC1_ID;\n\t     i <= (mtk_is_netsys_v3_or_greater(eth) ? MTK_GMAC3_ID : MTK_GMAC2_ID);\n\t     i += 2) {\n\t\tval = mtk_r32(eth, MTK_FE_GLO_CFG(i)) | MTK_FE_LINK_DOWN_P(PSE_PPE0_PORT);\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_RSTCTRL_PPE1))\n\t\t\tval |= MTK_FE_LINK_DOWN_P(PSE_PPE1_PORT);\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_RSTCTRL_PPE2))\n\t\t\tval |= MTK_FE_LINK_DOWN_P(PSE_PPE2_PORT);\n\t\tmtk_w32(eth, val, MTK_FE_GLO_CFG(i));\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(eth->ppe); i++)\n\t\tmtk_ppe_prepare_reset(eth->ppe[i]);\n\n\t \n\tmtk_w32(eth, 0, MTK_FE_INT_ENABLE);\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tval = mtk_r32(eth, MTK_MAC_MCR(i)) & ~MAC_MCR_FORCE_LINK;\n\t\tmtk_w32(eth, val, MTK_MAC_MCR(i));\n\t}\n}\n\nstatic void mtk_pending_work(struct work_struct *work)\n{\n\tstruct mtk_eth *eth = container_of(work, struct mtk_eth, pending_work);\n\tunsigned long restart = 0;\n\tu32 val;\n\tint i;\n\n\trtnl_lock();\n\tset_bit(MTK_RESETTING, &eth->state);\n\n\tmtk_prepare_for_reset(eth);\n\tmtk_wed_fe_reset();\n\t \n\tmtk_prepare_for_reset(eth);\n\n\t \n\tfor (i = 0; i < MTK_MAX_DEVS; i++) {\n\t\tif (!eth->netdev[i] || !netif_running(eth->netdev[i]))\n\t\t\tcontinue;\n\n\t\tmtk_stop(eth->netdev[i]);\n\t\t__set_bit(i, &restart);\n\t}\n\n\tusleep_range(15000, 16000);\n\n\tif (eth->dev->pins)\n\t\tpinctrl_select_state(eth->dev->pins->p,\n\t\t\t\t     eth->dev->pins->default_state);\n\tmtk_hw_init(eth, true);\n\n\t \n\tfor (i = 0; i < MTK_MAX_DEVS; i++) {\n\t\tif (!eth->netdev[i] || !test_bit(i, &restart))\n\t\t\tcontinue;\n\n\t\tif (mtk_open(eth->netdev[i])) {\n\t\t\tnetif_alert(eth, ifup, eth->netdev[i],\n\t\t\t\t    \"Driver up/down cycle failed\\n\");\n\t\t\tdev_close(eth->netdev[i]);\n\t\t}\n\t}\n\n\t \n\tfor (i = MTK_GMAC1_ID;\n\t     i <= (mtk_is_netsys_v3_or_greater(eth) ? MTK_GMAC3_ID : MTK_GMAC2_ID);\n\t     i += 2) {\n\t\tval = mtk_r32(eth, MTK_FE_GLO_CFG(i)) & ~MTK_FE_LINK_DOWN_P(PSE_PPE0_PORT);\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_RSTCTRL_PPE1))\n\t\t\tval &= ~MTK_FE_LINK_DOWN_P(PSE_PPE1_PORT);\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_RSTCTRL_PPE2))\n\t\t\tval &= ~MTK_FE_LINK_DOWN_P(PSE_PPE2_PORT);\n\n\t\tmtk_w32(eth, val, MTK_FE_GLO_CFG(i));\n\t}\n\n\tclear_bit(MTK_RESETTING, &eth->state);\n\n\tmtk_wed_fe_reset_complete();\n\n\trtnl_unlock();\n}\n\nstatic int mtk_free_dev(struct mtk_eth *eth)\n{\n\tint i;\n\n\tfor (i = 0; i < MTK_MAX_DEVS; i++) {\n\t\tif (!eth->netdev[i])\n\t\t\tcontinue;\n\t\tfree_netdev(eth->netdev[i]);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(eth->dsa_meta); i++) {\n\t\tif (!eth->dsa_meta[i])\n\t\t\tbreak;\n\t\tmetadata_dst_free(eth->dsa_meta[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_unreg_dev(struct mtk_eth *eth)\n{\n\tint i;\n\n\tfor (i = 0; i < MTK_MAX_DEVS; i++) {\n\t\tstruct mtk_mac *mac;\n\t\tif (!eth->netdev[i])\n\t\t\tcontinue;\n\t\tmac = netdev_priv(eth->netdev[i]);\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA))\n\t\t\tunregister_netdevice_notifier(&mac->device_notifier);\n\t\tunregister_netdev(eth->netdev[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_sgmii_destroy(struct mtk_eth *eth)\n{\n\tint i;\n\n\tfor (i = 0; i < MTK_MAX_DEVS; i++)\n\t\tmtk_pcs_lynxi_destroy(eth->sgmii_pcs[i]);\n}\n\nstatic int mtk_cleanup(struct mtk_eth *eth)\n{\n\tmtk_sgmii_destroy(eth);\n\tmtk_unreg_dev(eth);\n\tmtk_free_dev(eth);\n\tcancel_work_sync(&eth->pending_work);\n\tcancel_delayed_work_sync(&eth->reset.monitor_work);\n\n\treturn 0;\n}\n\nstatic int mtk_get_link_ksettings(struct net_device *ndev,\n\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tstruct mtk_mac *mac = netdev_priv(ndev);\n\n\tif (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))\n\t\treturn -EBUSY;\n\n\treturn phylink_ethtool_ksettings_get(mac->phylink, cmd);\n}\n\nstatic int mtk_set_link_ksettings(struct net_device *ndev,\n\t\t\t\t  const struct ethtool_link_ksettings *cmd)\n{\n\tstruct mtk_mac *mac = netdev_priv(ndev);\n\n\tif (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))\n\t\treturn -EBUSY;\n\n\treturn phylink_ethtool_ksettings_set(mac->phylink, cmd);\n}\n\nstatic void mtk_get_drvinfo(struct net_device *dev,\n\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\n\tstrscpy(info->driver, mac->hw->dev->driver->name, sizeof(info->driver));\n\tstrscpy(info->bus_info, dev_name(mac->hw->dev), sizeof(info->bus_info));\n\tinfo->n_stats = ARRAY_SIZE(mtk_ethtool_stats);\n}\n\nstatic u32 mtk_get_msglevel(struct net_device *dev)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\n\treturn mac->hw->msg_enable;\n}\n\nstatic void mtk_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\n\tmac->hw->msg_enable = value;\n}\n\nstatic int mtk_nway_reset(struct net_device *dev)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\n\tif (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))\n\t\treturn -EBUSY;\n\n\tif (!mac->phylink)\n\t\treturn -ENOTSUPP;\n\n\treturn phylink_ethtool_nway_reset(mac->phylink);\n}\n\nstatic void mtk_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS: {\n\t\tstruct mtk_mac *mac = netdev_priv(dev);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mtk_ethtool_stats); i++) {\n\t\t\tmemcpy(data, mtk_ethtool_stats[i].str, ETH_GSTRING_LEN);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t\tif (mtk_page_pool_enabled(mac->hw))\n\t\t\tpage_pool_ethtool_stats_get_strings(data);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int mtk_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS: {\n\t\tint count = ARRAY_SIZE(mtk_ethtool_stats);\n\t\tstruct mtk_mac *mac = netdev_priv(dev);\n\n\t\tif (mtk_page_pool_enabled(mac->hw))\n\t\t\tcount += page_pool_ethtool_stats_get_count();\n\t\treturn count;\n\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void mtk_ethtool_pp_stats(struct mtk_eth *eth, u64 *data)\n{\n\tstruct page_pool_stats stats = {};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(eth->rx_ring); i++) {\n\t\tstruct mtk_rx_ring *ring = &eth->rx_ring[i];\n\n\t\tif (!ring->page_pool)\n\t\t\tcontinue;\n\n\t\tpage_pool_get_stats(ring->page_pool, &stats);\n\t}\n\tpage_pool_ethtool_stats_get(data, &stats);\n}\n\nstatic void mtk_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t  struct ethtool_stats *stats, u64 *data)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tstruct mtk_hw_stats *hwstats = mac->hw_stats;\n\tu64 *data_src, *data_dst;\n\tunsigned int start;\n\tint i;\n\n\tif (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))\n\t\treturn;\n\n\tif (netif_running(dev) && netif_device_present(dev)) {\n\t\tif (spin_trylock_bh(&hwstats->stats_lock)) {\n\t\t\tmtk_stats_update_mac(mac);\n\t\t\tspin_unlock_bh(&hwstats->stats_lock);\n\t\t}\n\t}\n\n\tdata_src = (u64 *)hwstats;\n\n\tdo {\n\t\tdata_dst = data;\n\t\tstart = u64_stats_fetch_begin(&hwstats->syncp);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mtk_ethtool_stats); i++)\n\t\t\t*data_dst++ = *(data_src + mtk_ethtool_stats[i].offset);\n\t\tif (mtk_page_pool_enabled(mac->hw))\n\t\t\tmtk_ethtool_pp_stats(mac->hw, data_dst);\n\t} while (u64_stats_fetch_retry(&hwstats->syncp, start));\n}\n\nstatic int mtk_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\n\t\t\t u32 *rule_locs)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tif (dev->hw_features & NETIF_F_LRO) {\n\t\t\tcmd->data = MTK_MAX_RX_RING_NUM;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tif (dev->hw_features & NETIF_F_LRO) {\n\t\t\tstruct mtk_mac *mac = netdev_priv(dev);\n\n\t\t\tcmd->rule_cnt = mac->hwlro_ip_cnt;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tif (dev->hw_features & NETIF_F_LRO)\n\t\t\tret = mtk_hwlro_get_fdir_entry(dev, cmd);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tif (dev->hw_features & NETIF_F_LRO)\n\t\t\tret = mtk_hwlro_get_fdir_all(dev, cmd,\n\t\t\t\t\t\t     rule_locs);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int mtk_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tif (dev->hw_features & NETIF_F_LRO)\n\t\t\tret = mtk_hwlro_add_ipaddr(dev, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tif (dev->hw_features & NETIF_F_LRO)\n\t\t\tret = mtk_hwlro_del_ipaddr(dev, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic u16 mtk_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t    struct net_device *sb_dev)\n{\n\tstruct mtk_mac *mac = netdev_priv(dev);\n\tunsigned int queue = 0;\n\n\tif (netdev_uses_dsa(dev))\n\t\tqueue = skb_get_queue_mapping(skb) + 3;\n\telse\n\t\tqueue = mac->id;\n\n\tif (queue >= dev->num_tx_queues)\n\t\tqueue = 0;\n\n\treturn queue;\n}\n\nstatic const struct ethtool_ops mtk_ethtool_ops = {\n\t.get_link_ksettings\t= mtk_get_link_ksettings,\n\t.set_link_ksettings\t= mtk_set_link_ksettings,\n\t.get_drvinfo\t\t= mtk_get_drvinfo,\n\t.get_msglevel\t\t= mtk_get_msglevel,\n\t.set_msglevel\t\t= mtk_set_msglevel,\n\t.nway_reset\t\t= mtk_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= mtk_get_strings,\n\t.get_sset_count\t\t= mtk_get_sset_count,\n\t.get_ethtool_stats\t= mtk_get_ethtool_stats,\n\t.get_rxnfc\t\t= mtk_get_rxnfc,\n\t.set_rxnfc              = mtk_set_rxnfc,\n};\n\nstatic const struct net_device_ops mtk_netdev_ops = {\n\t.ndo_uninit\t\t= mtk_uninit,\n\t.ndo_open\t\t= mtk_open,\n\t.ndo_stop\t\t= mtk_stop,\n\t.ndo_start_xmit\t\t= mtk_start_xmit,\n\t.ndo_set_mac_address\t= mtk_set_mac_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= mtk_do_ioctl,\n\t.ndo_change_mtu\t\t= mtk_change_mtu,\n\t.ndo_tx_timeout\t\t= mtk_tx_timeout,\n\t.ndo_get_stats64        = mtk_get_stats64,\n\t.ndo_fix_features\t= mtk_fix_features,\n\t.ndo_set_features\t= mtk_set_features,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= mtk_poll_controller,\n#endif\n\t.ndo_setup_tc\t\t= mtk_eth_setup_tc,\n\t.ndo_bpf\t\t= mtk_xdp,\n\t.ndo_xdp_xmit\t\t= mtk_xdp_xmit,\n\t.ndo_select_queue\t= mtk_select_queue,\n};\n\nstatic int mtk_add_mac(struct mtk_eth *eth, struct device_node *np)\n{\n\tconst __be32 *_id = of_get_property(np, \"reg\", NULL);\n\tphy_interface_t phy_mode;\n\tstruct phylink *phylink;\n\tstruct mtk_mac *mac;\n\tint id, err;\n\tint txqs = 1;\n\tu32 val;\n\n\tif (!_id) {\n\t\tdev_err(eth->dev, \"missing mac id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tid = be32_to_cpup(_id);\n\tif (id >= MTK_MAX_DEVS) {\n\t\tdev_err(eth->dev, \"%d is not a valid mac id\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (eth->netdev[id]) {\n\t\tdev_err(eth->dev, \"duplicate mac id found: %d\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA))\n\t\ttxqs = MTK_QDMA_NUM_QUEUES;\n\n\teth->netdev[id] = alloc_etherdev_mqs(sizeof(*mac), txqs, 1);\n\tif (!eth->netdev[id]) {\n\t\tdev_err(eth->dev, \"alloc_etherdev failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmac = netdev_priv(eth->netdev[id]);\n\teth->mac[id] = mac;\n\tmac->id = id;\n\tmac->hw = eth;\n\tmac->of_node = np;\n\n\terr = of_get_ethdev_address(mac->of_node, eth->netdev[id]);\n\tif (err == -EPROBE_DEFER)\n\t\treturn err;\n\n\tif (err) {\n\t\t \n\t\teth_hw_addr_random(eth->netdev[id]);\n\t\tdev_err(eth->dev, \"generated random MAC address %pM\\n\",\n\t\t\teth->netdev[id]->dev_addr);\n\t}\n\n\tmemset(mac->hwlro_ip, 0, sizeof(mac->hwlro_ip));\n\tmac->hwlro_ip_cnt = 0;\n\n\tmac->hw_stats = devm_kzalloc(eth->dev,\n\t\t\t\t     sizeof(*mac->hw_stats),\n\t\t\t\t     GFP_KERNEL);\n\tif (!mac->hw_stats) {\n\t\tdev_err(eth->dev, \"failed to allocate counter memory\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto free_netdev;\n\t}\n\tspin_lock_init(&mac->hw_stats->stats_lock);\n\tu64_stats_init(&mac->hw_stats->syncp);\n\n\tif (mtk_is_netsys_v3_or_greater(eth))\n\t\tmac->hw_stats->reg_offset = id * 0x80;\n\telse\n\t\tmac->hw_stats->reg_offset = id * 0x40;\n\n\t \n\terr = of_get_phy_mode(np, &phy_mode);\n\tif (err) {\n\t\tdev_err(eth->dev, \"incorrect phy-mode\\n\");\n\t\tgoto free_netdev;\n\t}\n\n\t \n\tmac->interface = PHY_INTERFACE_MODE_NA;\n\tmac->speed = SPEED_UNKNOWN;\n\n\tmac->phylink_config.dev = &eth->netdev[id]->dev;\n\tmac->phylink_config.type = PHYLINK_NETDEV;\n\tmac->phylink_config.mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |\n\t\tMAC_10 | MAC_100 | MAC_1000 | MAC_2500FD;\n\n\t \n\tif (!mac->hw->soc->disable_pll_modes || mac->id != 0) {\n\t\t__set_bit(PHY_INTERFACE_MODE_MII,\n\t\t\t  mac->phylink_config.supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t\t  mac->phylink_config.supported_interfaces);\n\n\t\tif (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_RGMII))\n\t\t\tphy_interface_set_rgmii(mac->phylink_config.supported_interfaces);\n\t}\n\n\tif (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_TRGMII) && !mac->id)\n\t\t__set_bit(PHY_INTERFACE_MODE_TRGMII,\n\t\t\t  mac->phylink_config.supported_interfaces);\n\n\t \n\tif (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_GMAC1_TRGMII) &&\n\t    MTK_HAS_CAPS(mac->hw->soc->caps, MTK_TRGMII_MT7621_CLK)) {\n\t\tregmap_read(eth->ethsys, ETHSYS_SYSCFG, &val);\n\t\tif (val & SYSCFG_DRAM_TYPE_DDR2)\n\t\t\t__clear_bit(PHY_INTERFACE_MODE_TRGMII,\n\t\t\t\t    mac->phylink_config.supported_interfaces);\n\t}\n\n\tif (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_SGMII)) {\n\t\t__set_bit(PHY_INTERFACE_MODE_SGMII,\n\t\t\t  mac->phylink_config.supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX,\n\t\t\t  mac->phylink_config.supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_2500BASEX,\n\t\t\t  mac->phylink_config.supported_interfaces);\n\t}\n\n\tif (mtk_is_netsys_v3_or_greater(mac->hw) &&\n\t    MTK_HAS_CAPS(mac->hw->soc->caps, MTK_ESW_BIT) &&\n\t    id == MTK_GMAC1_ID) {\n\t\tmac->phylink_config.mac_capabilities = MAC_ASYM_PAUSE |\n\t\t\t\t\t\t       MAC_SYM_PAUSE |\n\t\t\t\t\t\t       MAC_10000FD;\n\t\tphy_interface_zero(mac->phylink_config.supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t  mac->phylink_config.supported_interfaces);\n\t}\n\n\tphylink = phylink_create(&mac->phylink_config,\n\t\t\t\t of_fwnode_handle(mac->of_node),\n\t\t\t\t phy_mode, &mtk_phylink_ops);\n\tif (IS_ERR(phylink)) {\n\t\terr = PTR_ERR(phylink);\n\t\tgoto free_netdev;\n\t}\n\n\tmac->phylink = phylink;\n\n\tSET_NETDEV_DEV(eth->netdev[id], eth->dev);\n\teth->netdev[id]->watchdog_timeo = 5 * HZ;\n\teth->netdev[id]->netdev_ops = &mtk_netdev_ops;\n\teth->netdev[id]->base_addr = (unsigned long)eth->base;\n\n\teth->netdev[id]->hw_features = eth->soc->hw_features;\n\tif (eth->hwlro)\n\t\teth->netdev[id]->hw_features |= NETIF_F_LRO;\n\n\teth->netdev[id]->vlan_features = eth->soc->hw_features &\n\t\t~NETIF_F_HW_VLAN_CTAG_TX;\n\teth->netdev[id]->features |= eth->soc->hw_features;\n\teth->netdev[id]->ethtool_ops = &mtk_ethtool_ops;\n\n\teth->netdev[id]->irq = eth->irq[0];\n\teth->netdev[id]->dev.of_node = np;\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628))\n\t\teth->netdev[id]->max_mtu = MTK_MAX_RX_LENGTH - MTK_RX_ETH_HLEN;\n\telse\n\t\teth->netdev[id]->max_mtu = MTK_MAX_RX_LENGTH_2K - MTK_RX_ETH_HLEN;\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA)) {\n\t\tmac->device_notifier.notifier_call = mtk_device_event;\n\t\tregister_netdevice_notifier(&mac->device_notifier);\n\t}\n\n\tif (mtk_page_pool_enabled(eth))\n\t\teth->netdev[id]->xdp_features = NETDEV_XDP_ACT_BASIC |\n\t\t\t\t\t\tNETDEV_XDP_ACT_REDIRECT |\n\t\t\t\t\t\tNETDEV_XDP_ACT_NDO_XMIT |\n\t\t\t\t\t\tNETDEV_XDP_ACT_NDO_XMIT_SG;\n\n\treturn 0;\n\nfree_netdev:\n\tfree_netdev(eth->netdev[id]);\n\treturn err;\n}\n\nvoid mtk_eth_set_dma_device(struct mtk_eth *eth, struct device *dma_dev)\n{\n\tstruct net_device *dev, *tmp;\n\tLIST_HEAD(dev_list);\n\tint i;\n\n\trtnl_lock();\n\n\tfor (i = 0; i < MTK_MAX_DEVS; i++) {\n\t\tdev = eth->netdev[i];\n\n\t\tif (!dev || !(dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tlist_add_tail(&dev->close_list, &dev_list);\n\t}\n\n\tdev_close_many(&dev_list, false);\n\n\teth->dma_dev = dma_dev;\n\n\tlist_for_each_entry_safe(dev, tmp, &dev_list, close_list) {\n\t\tlist_del_init(&dev->close_list);\n\t\tdev_open(dev, NULL);\n\t}\n\n\trtnl_unlock();\n}\n\nstatic int mtk_sgmii_init(struct mtk_eth *eth)\n{\n\tstruct device_node *np;\n\tstruct regmap *regmap;\n\tu32 flags;\n\tint i;\n\n\tfor (i = 0; i < MTK_MAX_DEVS; i++) {\n\t\tnp = of_parse_phandle(eth->dev->of_node, \"mediatek,sgmiisys\", i);\n\t\tif (!np)\n\t\t\tbreak;\n\n\t\tregmap = syscon_node_to_regmap(np);\n\t\tflags = 0;\n\t\tif (of_property_read_bool(np, \"mediatek,pnswap\"))\n\t\t\tflags |= MTK_SGMII_FLAG_PN_SWAP;\n\n\t\tof_node_put(np);\n\n\t\tif (IS_ERR(regmap))\n\t\t\treturn PTR_ERR(regmap);\n\n\t\teth->sgmii_pcs[i] = mtk_pcs_lynxi_create(eth->dev, regmap,\n\t\t\t\t\t\t\t eth->soc->ana_rgc3,\n\t\t\t\t\t\t\t flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_probe(struct platform_device *pdev)\n{\n\tstruct resource *res = NULL, *res_sram;\n\tstruct device_node *mac_np;\n\tstruct mtk_eth *eth;\n\tint err, i;\n\n\teth = devm_kzalloc(&pdev->dev, sizeof(*eth), GFP_KERNEL);\n\tif (!eth)\n\t\treturn -ENOMEM;\n\n\teth->soc = of_device_get_match_data(&pdev->dev);\n\n\teth->dev = &pdev->dev;\n\teth->dma_dev = &pdev->dev;\n\teth->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(eth->base))\n\t\treturn PTR_ERR(eth->base);\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628))\n\t\teth->ip_align = NET_IP_ALIGN;\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SRAM)) {\n\t\t \n\t\tif (mtk_is_netsys_v3_or_greater(eth)) {\n\t\t\teth->sram_base = (void __force *)devm_platform_ioremap_resource(pdev, 1);\n\t\t\tif (IS_ERR(eth->sram_base))\n\t\t\t\treturn PTR_ERR(eth->sram_base);\n\t\t} else {\n\t\t\teth->sram_base = (void __force *)eth->base + MTK_ETH_SRAM_OFFSET;\n\t\t}\n\t}\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_36BIT_DMA)) {\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(36));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Wrong DMA config\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tspin_lock_init(&eth->page_lock);\n\tspin_lock_init(&eth->tx_irq_lock);\n\tspin_lock_init(&eth->rx_irq_lock);\n\tspin_lock_init(&eth->dim_lock);\n\n\teth->rx_dim.mode = DIM_CQ_PERIOD_MODE_START_FROM_EQE;\n\tINIT_WORK(&eth->rx_dim.work, mtk_dim_rx);\n\tINIT_DELAYED_WORK(&eth->reset.monitor_work, mtk_hw_reset_monitor_work);\n\n\teth->tx_dim.mode = DIM_CQ_PERIOD_MODE_START_FROM_EQE;\n\tINIT_WORK(&eth->tx_dim.work, mtk_dim_tx);\n\n\tif (!MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628)) {\n\t\teth->ethsys = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t      \"mediatek,ethsys\");\n\t\tif (IS_ERR(eth->ethsys)) {\n\t\t\tdev_err(&pdev->dev, \"no ethsys regmap found\\n\");\n\t\t\treturn PTR_ERR(eth->ethsys);\n\t\t}\n\t}\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_INFRA)) {\n\t\teth->infra = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t     \"mediatek,infracfg\");\n\t\tif (IS_ERR(eth->infra)) {\n\t\t\tdev_err(&pdev->dev, \"no infracfg regmap found\\n\");\n\t\t\treturn PTR_ERR(eth->infra);\n\t\t}\n\t}\n\n\tif (of_dma_is_coherent(pdev->dev.of_node)) {\n\t\tstruct regmap *cci;\n\n\t\tcci = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t      \"cci-control-port\");\n\t\t \n\t\tif (!IS_ERR(cci))\n\t\t\tregmap_write(cci, 0, 3);\n\t}\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SGMII)) {\n\t\terr = mtk_sgmii_init(eth);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (eth->soc->required_pctl) {\n\t\teth->pctl = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t    \"mediatek,pctl\");\n\t\tif (IS_ERR(eth->pctl)) {\n\t\t\tdev_err(&pdev->dev, \"no pctl regmap found\\n\");\n\t\t\terr = PTR_ERR(eth->pctl);\n\t\t\tgoto err_destroy_sgmii;\n\t\t}\n\t}\n\n\tif (mtk_is_netsys_v2_or_greater(eth)) {\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t\tif (!res) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_destroy_sgmii;\n\t\t}\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SRAM)) {\n\t\t\tif (mtk_is_netsys_v3_or_greater(eth)) {\n\t\t\t\tres_sram = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\t\t\t\tif (!res_sram) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto err_destroy_sgmii;\n\t\t\t\t}\n\t\t\t\teth->phy_scratch_ring = res_sram->start;\n\t\t\t} else {\n\t\t\t\teth->phy_scratch_ring = res->start + MTK_ETH_SRAM_OFFSET;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (eth->soc->offload_version) {\n\t\tfor (i = 0;; i++) {\n\t\t\tstruct device_node *np;\n\t\t\tphys_addr_t wdma_phy;\n\t\t\tu32 wdma_base;\n\n\t\t\tif (i >= ARRAY_SIZE(eth->soc->reg_map->wdma_base))\n\t\t\t\tbreak;\n\n\t\t\tnp = of_parse_phandle(pdev->dev.of_node,\n\t\t\t\t\t      \"mediatek,wed\", i);\n\t\t\tif (!np)\n\t\t\t\tbreak;\n\n\t\t\twdma_base = eth->soc->reg_map->wdma_base[i];\n\t\t\twdma_phy = res ? res->start + wdma_base : 0;\n\t\t\tmtk_wed_add_hw(np, eth, eth->base + wdma_base,\n\t\t\t\t       wdma_phy, i);\n\t\t}\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SHARED_INT) && i > 0)\n\t\t\teth->irq[i] = eth->irq[0];\n\t\telse\n\t\t\teth->irq[i] = platform_get_irq(pdev, i);\n\t\tif (eth->irq[i] < 0) {\n\t\t\tdev_err(&pdev->dev, \"no IRQ%d resource found\\n\", i);\n\t\t\terr = -ENXIO;\n\t\t\tgoto err_wed_exit;\n\t\t}\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(eth->clks); i++) {\n\t\teth->clks[i] = devm_clk_get(eth->dev,\n\t\t\t\t\t    mtk_clks_source_name[i]);\n\t\tif (IS_ERR(eth->clks[i])) {\n\t\t\tif (PTR_ERR(eth->clks[i]) == -EPROBE_DEFER) {\n\t\t\t\terr = -EPROBE_DEFER;\n\t\t\t\tgoto err_wed_exit;\n\t\t\t}\n\t\t\tif (eth->soc->required_clks & BIT(i)) {\n\t\t\t\tdev_err(&pdev->dev, \"clock %s not found\\n\",\n\t\t\t\t\tmtk_clks_source_name[i]);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_wed_exit;\n\t\t\t}\n\t\t\teth->clks[i] = NULL;\n\t\t}\n\t}\n\n\teth->msg_enable = netif_msg_init(mtk_msg_level, MTK_DEFAULT_MSG_ENABLE);\n\tINIT_WORK(&eth->pending_work, mtk_pending_work);\n\n\terr = mtk_hw_init(eth, false);\n\tif (err)\n\t\tgoto err_wed_exit;\n\n\teth->hwlro = MTK_HAS_CAPS(eth->soc->caps, MTK_HWLRO);\n\n\tfor_each_child_of_node(pdev->dev.of_node, mac_np) {\n\t\tif (!of_device_is_compatible(mac_np,\n\t\t\t\t\t     \"mediatek,eth-mac\"))\n\t\t\tcontinue;\n\n\t\tif (!of_device_is_available(mac_np))\n\t\t\tcontinue;\n\n\t\terr = mtk_add_mac(eth, mac_np);\n\t\tif (err) {\n\t\t\tof_node_put(mac_np);\n\t\t\tgoto err_deinit_hw;\n\t\t}\n\t}\n\n\tif (MTK_HAS_CAPS(eth->soc->caps, MTK_SHARED_INT)) {\n\t\terr = devm_request_irq(eth->dev, eth->irq[0],\n\t\t\t\t       mtk_handle_irq, 0,\n\t\t\t\t       dev_name(eth->dev), eth);\n\t} else {\n\t\terr = devm_request_irq(eth->dev, eth->irq[1],\n\t\t\t\t       mtk_handle_irq_tx, 0,\n\t\t\t\t       dev_name(eth->dev), eth);\n\t\tif (err)\n\t\t\tgoto err_free_dev;\n\n\t\terr = devm_request_irq(eth->dev, eth->irq[2],\n\t\t\t\t       mtk_handle_irq_rx, 0,\n\t\t\t\t       dev_name(eth->dev), eth);\n\t}\n\tif (err)\n\t\tgoto err_free_dev;\n\n\t \n\tif (!MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628)) {\n\t\terr = mtk_mdio_init(eth);\n\t\tif (err)\n\t\t\tgoto err_free_dev;\n\t}\n\n\tif (eth->soc->offload_version) {\n\t\tu32 num_ppe = mtk_is_netsys_v2_or_greater(eth) ? 2 : 1;\n\n\t\tnum_ppe = min_t(u32, ARRAY_SIZE(eth->ppe), num_ppe);\n\t\tfor (i = 0; i < num_ppe; i++) {\n\t\t\tu32 ppe_addr = eth->soc->reg_map->ppe_base + i * 0x400;\n\n\t\t\teth->ppe[i] = mtk_ppe_init(eth, eth->base + ppe_addr, i);\n\n\t\t\tif (!eth->ppe[i]) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_deinit_ppe;\n\t\t\t}\n\t\t}\n\n\t\terr = mtk_eth_offload_init(eth);\n\t\tif (err)\n\t\t\tgoto err_deinit_ppe;\n\t}\n\n\tfor (i = 0; i < MTK_MAX_DEVS; i++) {\n\t\tif (!eth->netdev[i])\n\t\t\tcontinue;\n\n\t\terr = register_netdev(eth->netdev[i]);\n\t\tif (err) {\n\t\t\tdev_err(eth->dev, \"error bringing up device\\n\");\n\t\t\tgoto err_deinit_ppe;\n\t\t} else\n\t\t\tnetif_info(eth, probe, eth->netdev[i],\n\t\t\t\t   \"mediatek frame engine at 0x%08lx, irq %d\\n\",\n\t\t\t\t   eth->netdev[i]->base_addr, eth->irq[0]);\n\t}\n\n\t \n\tinit_dummy_netdev(&eth->dummy_dev);\n\tnetif_napi_add(&eth->dummy_dev, &eth->tx_napi, mtk_napi_tx);\n\tnetif_napi_add(&eth->dummy_dev, &eth->rx_napi, mtk_napi_rx);\n\n\tplatform_set_drvdata(pdev, eth);\n\tschedule_delayed_work(&eth->reset.monitor_work,\n\t\t\t      MTK_DMA_MONITOR_TIMEOUT);\n\n\treturn 0;\n\nerr_deinit_ppe:\n\tmtk_ppe_deinit(eth);\n\tmtk_mdio_cleanup(eth);\nerr_free_dev:\n\tmtk_free_dev(eth);\nerr_deinit_hw:\n\tmtk_hw_deinit(eth);\nerr_wed_exit:\n\tmtk_wed_exit();\nerr_destroy_sgmii:\n\tmtk_sgmii_destroy(eth);\n\n\treturn err;\n}\n\nstatic int mtk_remove(struct platform_device *pdev)\n{\n\tstruct mtk_eth *eth = platform_get_drvdata(pdev);\n\tstruct mtk_mac *mac;\n\tint i;\n\n\t \n\tfor (i = 0; i < MTK_MAX_DEVS; i++) {\n\t\tif (!eth->netdev[i])\n\t\t\tcontinue;\n\t\tmtk_stop(eth->netdev[i]);\n\t\tmac = netdev_priv(eth->netdev[i]);\n\t\tphylink_disconnect_phy(mac->phylink);\n\t}\n\n\tmtk_wed_exit();\n\tmtk_hw_deinit(eth);\n\n\tnetif_napi_del(&eth->tx_napi);\n\tnetif_napi_del(&eth->rx_napi);\n\tmtk_cleanup(eth);\n\tmtk_mdio_cleanup(eth);\n\n\treturn 0;\n}\n\nstatic const struct mtk_soc_data mt2701_data = {\n\t.reg_map = &mtk_reg_map,\n\t.caps = MT7623_CAPS | MTK_HWLRO,\n\t.hw_features = MTK_HW_FEATURES,\n\t.required_clks = MT7623_CLKS_BITMAP,\n\t.required_pctl = true,\n\t.version = 1,\n\t.txrx = {\n\t\t.txd_size = sizeof(struct mtk_tx_dma),\n\t\t.rxd_size = sizeof(struct mtk_rx_dma),\n\t\t.rx_irq_done_mask = MTK_RX_DONE_INT,\n\t\t.rx_dma_l4_valid = RX_DMA_L4_VALID,\n\t\t.dma_max_len = MTK_TX_DMA_BUF_LEN,\n\t\t.dma_len_offset = 16,\n\t},\n};\n\nstatic const struct mtk_soc_data mt7621_data = {\n\t.reg_map = &mtk_reg_map,\n\t.caps = MT7621_CAPS,\n\t.hw_features = MTK_HW_FEATURES,\n\t.required_clks = MT7621_CLKS_BITMAP,\n\t.required_pctl = false,\n\t.version = 1,\n\t.offload_version = 1,\n\t.hash_offset = 2,\n\t.foe_entry_size = MTK_FOE_ENTRY_V1_SIZE,\n\t.txrx = {\n\t\t.txd_size = sizeof(struct mtk_tx_dma),\n\t\t.rxd_size = sizeof(struct mtk_rx_dma),\n\t\t.rx_irq_done_mask = MTK_RX_DONE_INT,\n\t\t.rx_dma_l4_valid = RX_DMA_L4_VALID,\n\t\t.dma_max_len = MTK_TX_DMA_BUF_LEN,\n\t\t.dma_len_offset = 16,\n\t},\n};\n\nstatic const struct mtk_soc_data mt7622_data = {\n\t.reg_map = &mtk_reg_map,\n\t.ana_rgc3 = 0x2028,\n\t.caps = MT7622_CAPS | MTK_HWLRO,\n\t.hw_features = MTK_HW_FEATURES,\n\t.required_clks = MT7622_CLKS_BITMAP,\n\t.required_pctl = false,\n\t.version = 1,\n\t.offload_version = 2,\n\t.hash_offset = 2,\n\t.has_accounting = true,\n\t.foe_entry_size = MTK_FOE_ENTRY_V1_SIZE,\n\t.txrx = {\n\t\t.txd_size = sizeof(struct mtk_tx_dma),\n\t\t.rxd_size = sizeof(struct mtk_rx_dma),\n\t\t.rx_irq_done_mask = MTK_RX_DONE_INT,\n\t\t.rx_dma_l4_valid = RX_DMA_L4_VALID,\n\t\t.dma_max_len = MTK_TX_DMA_BUF_LEN,\n\t\t.dma_len_offset = 16,\n\t},\n};\n\nstatic const struct mtk_soc_data mt7623_data = {\n\t.reg_map = &mtk_reg_map,\n\t.caps = MT7623_CAPS | MTK_HWLRO,\n\t.hw_features = MTK_HW_FEATURES,\n\t.required_clks = MT7623_CLKS_BITMAP,\n\t.required_pctl = true,\n\t.version = 1,\n\t.offload_version = 1,\n\t.hash_offset = 2,\n\t.foe_entry_size = MTK_FOE_ENTRY_V1_SIZE,\n\t.disable_pll_modes = true,\n\t.txrx = {\n\t\t.txd_size = sizeof(struct mtk_tx_dma),\n\t\t.rxd_size = sizeof(struct mtk_rx_dma),\n\t\t.rx_irq_done_mask = MTK_RX_DONE_INT,\n\t\t.rx_dma_l4_valid = RX_DMA_L4_VALID,\n\t\t.dma_max_len = MTK_TX_DMA_BUF_LEN,\n\t\t.dma_len_offset = 16,\n\t},\n};\n\nstatic const struct mtk_soc_data mt7629_data = {\n\t.reg_map = &mtk_reg_map,\n\t.ana_rgc3 = 0x128,\n\t.caps = MT7629_CAPS | MTK_HWLRO,\n\t.hw_features = MTK_HW_FEATURES,\n\t.required_clks = MT7629_CLKS_BITMAP,\n\t.required_pctl = false,\n\t.has_accounting = true,\n\t.version = 1,\n\t.txrx = {\n\t\t.txd_size = sizeof(struct mtk_tx_dma),\n\t\t.rxd_size = sizeof(struct mtk_rx_dma),\n\t\t.rx_irq_done_mask = MTK_RX_DONE_INT,\n\t\t.rx_dma_l4_valid = RX_DMA_L4_VALID,\n\t\t.dma_max_len = MTK_TX_DMA_BUF_LEN,\n\t\t.dma_len_offset = 16,\n\t},\n};\n\nstatic const struct mtk_soc_data mt7981_data = {\n\t.reg_map = &mt7986_reg_map,\n\t.ana_rgc3 = 0x128,\n\t.caps = MT7981_CAPS,\n\t.hw_features = MTK_HW_FEATURES,\n\t.required_clks = MT7981_CLKS_BITMAP,\n\t.required_pctl = false,\n\t.version = 2,\n\t.offload_version = 2,\n\t.hash_offset = 4,\n\t.has_accounting = true,\n\t.foe_entry_size = MTK_FOE_ENTRY_V2_SIZE,\n\t.txrx = {\n\t\t.txd_size = sizeof(struct mtk_tx_dma_v2),\n\t\t.rxd_size = sizeof(struct mtk_rx_dma_v2),\n\t\t.rx_irq_done_mask = MTK_RX_DONE_INT_V2,\n\t\t.rx_dma_l4_valid = RX_DMA_L4_VALID_V2,\n\t\t.dma_max_len = MTK_TX_DMA_BUF_LEN_V2,\n\t\t.dma_len_offset = 8,\n\t},\n};\n\nstatic const struct mtk_soc_data mt7986_data = {\n\t.reg_map = &mt7986_reg_map,\n\t.ana_rgc3 = 0x128,\n\t.caps = MT7986_CAPS,\n\t.hw_features = MTK_HW_FEATURES,\n\t.required_clks = MT7986_CLKS_BITMAP,\n\t.required_pctl = false,\n\t.version = 2,\n\t.offload_version = 2,\n\t.hash_offset = 4,\n\t.has_accounting = true,\n\t.foe_entry_size = MTK_FOE_ENTRY_V2_SIZE,\n\t.txrx = {\n\t\t.txd_size = sizeof(struct mtk_tx_dma_v2),\n\t\t.rxd_size = sizeof(struct mtk_rx_dma_v2),\n\t\t.rx_irq_done_mask = MTK_RX_DONE_INT_V2,\n\t\t.rx_dma_l4_valid = RX_DMA_L4_VALID_V2,\n\t\t.dma_max_len = MTK_TX_DMA_BUF_LEN_V2,\n\t\t.dma_len_offset = 8,\n\t},\n};\n\nstatic const struct mtk_soc_data mt7988_data = {\n\t.reg_map = &mt7988_reg_map,\n\t.ana_rgc3 = 0x128,\n\t.caps = MT7988_CAPS,\n\t.hw_features = MTK_HW_FEATURES,\n\t.required_clks = MT7988_CLKS_BITMAP,\n\t.required_pctl = false,\n\t.version = 3,\n\t.offload_version = 2,\n\t.hash_offset = 4,\n\t.has_accounting = true,\n\t.foe_entry_size = MTK_FOE_ENTRY_V3_SIZE,\n\t.txrx = {\n\t\t.txd_size = sizeof(struct mtk_tx_dma_v2),\n\t\t.rxd_size = sizeof(struct mtk_rx_dma_v2),\n\t\t.rx_irq_done_mask = MTK_RX_DONE_INT_V2,\n\t\t.rx_dma_l4_valid = RX_DMA_L4_VALID_V2,\n\t\t.dma_max_len = MTK_TX_DMA_BUF_LEN_V2,\n\t\t.dma_len_offset = 8,\n\t},\n};\n\nstatic const struct mtk_soc_data rt5350_data = {\n\t.reg_map = &mt7628_reg_map,\n\t.caps = MT7628_CAPS,\n\t.hw_features = MTK_HW_FEATURES_MT7628,\n\t.required_clks = MT7628_CLKS_BITMAP,\n\t.required_pctl = false,\n\t.version = 1,\n\t.txrx = {\n\t\t.txd_size = sizeof(struct mtk_tx_dma),\n\t\t.rxd_size = sizeof(struct mtk_rx_dma),\n\t\t.rx_irq_done_mask = MTK_RX_DONE_INT,\n\t\t.rx_dma_l4_valid = RX_DMA_L4_VALID_PDMA,\n\t\t.dma_max_len = MTK_TX_DMA_BUF_LEN,\n\t\t.dma_len_offset = 16,\n\t},\n};\n\nconst struct of_device_id of_mtk_match[] = {\n\t{ .compatible = \"mediatek,mt2701-eth\", .data = &mt2701_data },\n\t{ .compatible = \"mediatek,mt7621-eth\", .data = &mt7621_data },\n\t{ .compatible = \"mediatek,mt7622-eth\", .data = &mt7622_data },\n\t{ .compatible = \"mediatek,mt7623-eth\", .data = &mt7623_data },\n\t{ .compatible = \"mediatek,mt7629-eth\", .data = &mt7629_data },\n\t{ .compatible = \"mediatek,mt7981-eth\", .data = &mt7981_data },\n\t{ .compatible = \"mediatek,mt7986-eth\", .data = &mt7986_data },\n\t{ .compatible = \"mediatek,mt7988-eth\", .data = &mt7988_data },\n\t{ .compatible = \"ralink,rt5350-eth\", .data = &rt5350_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_mtk_match);\n\nstatic struct platform_driver mtk_driver = {\n\t.probe = mtk_probe,\n\t.remove = mtk_remove,\n\t.driver = {\n\t\t.name = \"mtk_soc_eth\",\n\t\t.of_match_table = of_mtk_match,\n\t},\n};\n\nmodule_platform_driver(mtk_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"John Crispin <blogic@openwrt.org>\");\nMODULE_DESCRIPTION(\"Ethernet driver for MediaTek SoC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}