{
  "module_name": "nps_enet.c",
  "hash_id": "b6abbfed57234179c7f0f12d82730459cec6ba5f0dd11706619858dd059cb67b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ezchip/nps_enet.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of_net.h>\n#include <linux/platform_device.h>\n#include \"nps_enet.h\"\n\n#define DRV_NAME\t\t\t\"nps_mgt_enet\"\n\nstatic inline bool nps_enet_is_tx_pending(struct nps_enet_priv *priv)\n{\n\tu32 tx_ctrl_value = nps_enet_reg_get(priv, NPS_ENET_REG_TX_CTL);\n\tu32 tx_ctrl_ct = (tx_ctrl_value & TX_CTL_CT_MASK) >> TX_CTL_CT_SHIFT;\n\n\treturn (!tx_ctrl_ct && priv->tx_skb);\n}\n\nstatic void nps_enet_clean_rx_fifo(struct net_device *ndev, u32 frame_len)\n{\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\tu32 i, len = DIV_ROUND_UP(frame_len, sizeof(u32));\n\n\t \n\tfor (i = 0; i < len; i++)\n\t\tnps_enet_reg_get(priv, NPS_ENET_REG_RX_BUF);\n}\n\nstatic void nps_enet_read_rx_fifo(struct net_device *ndev,\n\t\t\t\t  unsigned char *dst, u32 length)\n{\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\ts32 i, last = length & (sizeof(u32) - 1);\n\tu32 *reg = (u32 *)dst, len = length / sizeof(u32);\n\tbool dst_is_aligned = IS_ALIGNED((unsigned long)dst, sizeof(u32));\n\n\t \n\tif (dst_is_aligned) {\n\t\tioread32_rep(priv->regs_base + NPS_ENET_REG_RX_BUF, reg, len);\n\t\treg += len;\n\t} else {  \n\t\tfor (i = 0; i < len; i++, reg++) {\n\t\t\tu32 buf = nps_enet_reg_get(priv, NPS_ENET_REG_RX_BUF);\n\n\t\t\tput_unaligned_be32(buf, reg);\n\t\t}\n\t}\n\t \n\tif (last) {\n\t\tu32 buf;\n\n\t\tioread32_rep(priv->regs_base + NPS_ENET_REG_RX_BUF, &buf, 1);\n\t\tmemcpy((u8 *)reg, &buf, last);\n\t}\n}\n\nstatic u32 nps_enet_rx_handler(struct net_device *ndev)\n{\n\tu32 frame_len, err = 0;\n\tu32 work_done = 0;\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\tstruct sk_buff *skb;\n\tu32 rx_ctrl_value = nps_enet_reg_get(priv, NPS_ENET_REG_RX_CTL);\n\tu32 rx_ctrl_cr = (rx_ctrl_value & RX_CTL_CR_MASK) >> RX_CTL_CR_SHIFT;\n\tu32 rx_ctrl_er = (rx_ctrl_value & RX_CTL_ER_MASK) >> RX_CTL_ER_SHIFT;\n\tu32 rx_ctrl_crc = (rx_ctrl_value & RX_CTL_CRC_MASK) >> RX_CTL_CRC_SHIFT;\n\n\tframe_len = (rx_ctrl_value & RX_CTL_NR_MASK) >> RX_CTL_NR_SHIFT;\n\n\t \n\tif (!rx_ctrl_cr)\n\t\treturn work_done;\n\n\t \n\twork_done++;\n\n\t \n\tif (rx_ctrl_er) {\n\t\tndev->stats.rx_errors++;\n\t\terr = 1;\n\t}\n\n\t \n\tif (rx_ctrl_crc) {\n\t\tndev->stats.rx_crc_errors++;\n\t\tndev->stats.rx_dropped++;\n\t\terr = 1;\n\t}\n\n\t \n\tif (unlikely(frame_len < ETH_ZLEN)) {\n\t\tndev->stats.rx_length_errors++;\n\t\tndev->stats.rx_dropped++;\n\t\terr = 1;\n\t}\n\n\tif (err)\n\t\tgoto rx_irq_clean;\n\n\t \n\tskb = netdev_alloc_skb_ip_align(ndev, frame_len);\n\tif (unlikely(!skb)) {\n\t\tndev->stats.rx_errors++;\n\t\tndev->stats.rx_dropped++;\n\t\tgoto rx_irq_clean;\n\t}\n\n\t \n\tnps_enet_read_rx_fifo(ndev, skb->data, frame_len);\n\n\tskb_put(skb, frame_len);\n\tskb->protocol = eth_type_trans(skb, ndev);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tndev->stats.rx_packets++;\n\tndev->stats.rx_bytes += frame_len;\n\tnetif_receive_skb(skb);\n\n\tgoto rx_irq_frame_done;\n\nrx_irq_clean:\n\t \n\tnps_enet_clean_rx_fifo(ndev, frame_len);\n\nrx_irq_frame_done:\n\t \n\tnps_enet_reg_set(priv, NPS_ENET_REG_RX_CTL, 0);\n\n\treturn work_done;\n}\n\nstatic void nps_enet_tx_handler(struct net_device *ndev)\n{\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\tu32 tx_ctrl_value = nps_enet_reg_get(priv, NPS_ENET_REG_TX_CTL);\n\tu32 tx_ctrl_et = (tx_ctrl_value & TX_CTL_ET_MASK) >> TX_CTL_ET_SHIFT;\n\tu32 tx_ctrl_nt = (tx_ctrl_value & TX_CTL_NT_MASK) >> TX_CTL_NT_SHIFT;\n\n\t \n\tif (!nps_enet_is_tx_pending(priv))\n\t\treturn;\n\n\t \n\tnps_enet_reg_set(priv, NPS_ENET_REG_TX_CTL, 0);\n\n\t \n\tif (unlikely(tx_ctrl_et)) {\n\t\tndev->stats.tx_errors++;\n\t} else {\n\t\tndev->stats.tx_packets++;\n\t\tndev->stats.tx_bytes += tx_ctrl_nt;\n\t}\n\n\tdev_kfree_skb(priv->tx_skb);\n\tpriv->tx_skb = NULL;\n\n\tif (netif_queue_stopped(ndev))\n\t\tnetif_wake_queue(ndev);\n}\n\n \nstatic int nps_enet_poll(struct napi_struct *napi, int budget)\n{\n\tstruct net_device *ndev = napi->dev;\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\tu32 work_done;\n\n\tnps_enet_tx_handler(ndev);\n\twork_done = nps_enet_rx_handler(ndev);\n\tif ((work_done < budget) && napi_complete_done(napi, work_done)) {\n\t\tu32 buf_int_enable_value = 0;\n\n\t\t \n\t\tbuf_int_enable_value |= NPS_ENET_ENABLE << RX_RDY_SHIFT;\n\t\tbuf_int_enable_value |= NPS_ENET_ENABLE << TX_DONE_SHIFT;\n\n\t\tnps_enet_reg_set(priv, NPS_ENET_REG_BUF_INT_ENABLE,\n\t\t\t\t buf_int_enable_value);\n\n\t\t \n\t\tif (nps_enet_is_tx_pending(priv)) {\n\t\t\tnps_enet_reg_set(priv, NPS_ENET_REG_BUF_INT_ENABLE, 0);\n\t\t\tnapi_reschedule(napi);\n\t\t}\n\t}\n\n\treturn work_done;\n}\n\n \nstatic irqreturn_t nps_enet_irq_handler(s32 irq, void *dev_instance)\n{\n\tstruct net_device *ndev = dev_instance;\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\tu32 rx_ctrl_value = nps_enet_reg_get(priv, NPS_ENET_REG_RX_CTL);\n\tu32 rx_ctrl_cr = (rx_ctrl_value & RX_CTL_CR_MASK) >> RX_CTL_CR_SHIFT;\n\n\tif (nps_enet_is_tx_pending(priv) || rx_ctrl_cr)\n\t\tif (likely(napi_schedule_prep(&priv->napi))) {\n\t\t\tnps_enet_reg_set(priv, NPS_ENET_REG_BUF_INT_ENABLE, 0);\n\t\t\t__napi_schedule(&priv->napi);\n\t\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void nps_enet_set_hw_mac_address(struct net_device *ndev)\n{\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\tu32 ge_mac_cfg_1_value = 0;\n\tu32 *ge_mac_cfg_2_value = &priv->ge_mac_cfg_2_value;\n\n\t \n\tge_mac_cfg_1_value |= ndev->dev_addr[0] << CFG_1_OCTET_0_SHIFT;\n\tge_mac_cfg_1_value |= ndev->dev_addr[1] << CFG_1_OCTET_1_SHIFT;\n\tge_mac_cfg_1_value |= ndev->dev_addr[2] << CFG_1_OCTET_2_SHIFT;\n\tge_mac_cfg_1_value |= ndev->dev_addr[3] << CFG_1_OCTET_3_SHIFT;\n\t*ge_mac_cfg_2_value = (*ge_mac_cfg_2_value & ~CFG_2_OCTET_4_MASK)\n\t\t | ndev->dev_addr[4] << CFG_2_OCTET_4_SHIFT;\n\t*ge_mac_cfg_2_value = (*ge_mac_cfg_2_value & ~CFG_2_OCTET_5_MASK)\n\t\t | ndev->dev_addr[5] << CFG_2_OCTET_5_SHIFT;\n\n\tnps_enet_reg_set(priv, NPS_ENET_REG_GE_MAC_CFG_1,\n\t\t\t ge_mac_cfg_1_value);\n\n\tnps_enet_reg_set(priv, NPS_ENET_REG_GE_MAC_CFG_2,\n\t\t\t *ge_mac_cfg_2_value);\n}\n\n \nstatic void nps_enet_hw_reset(struct net_device *ndev)\n{\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\tu32 ge_rst_value = 0, phase_fifo_ctl_value = 0;\n\n\t \n\tge_rst_value |= NPS_ENET_ENABLE << RST_GMAC_0_SHIFT;\n\tnps_enet_reg_set(priv, NPS_ENET_REG_GE_RST, ge_rst_value);\n\tusleep_range(10, 20);\n\tge_rst_value = 0;\n\tnps_enet_reg_set(priv, NPS_ENET_REG_GE_RST, ge_rst_value);\n\n\t \n\tphase_fifo_ctl_value |= NPS_ENET_ENABLE << PHASE_FIFO_CTL_RST_SHIFT;\n\tphase_fifo_ctl_value |= NPS_ENET_ENABLE << PHASE_FIFO_CTL_INIT_SHIFT;\n\tnps_enet_reg_set(priv, NPS_ENET_REG_PHASE_FIFO_CTL,\n\t\t\t phase_fifo_ctl_value);\n\tusleep_range(10, 20);\n\tphase_fifo_ctl_value = 0;\n\tnps_enet_reg_set(priv, NPS_ENET_REG_PHASE_FIFO_CTL,\n\t\t\t phase_fifo_ctl_value);\n}\n\nstatic void nps_enet_hw_enable_control(struct net_device *ndev)\n{\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\tu32 ge_mac_cfg_0_value = 0, buf_int_enable_value = 0;\n\tu32 *ge_mac_cfg_2_value = &priv->ge_mac_cfg_2_value;\n\tu32 *ge_mac_cfg_3_value = &priv->ge_mac_cfg_3_value;\n\ts32 max_frame_length;\n\n\t \n\t*ge_mac_cfg_2_value = (*ge_mac_cfg_2_value & ~CFG_2_STAT_EN_MASK)\n\t\t | NPS_ENET_GE_MAC_CFG_2_STAT_EN << CFG_2_STAT_EN_SHIFT;\n\n\t \n\t*ge_mac_cfg_2_value = (*ge_mac_cfg_2_value & ~CFG_2_DISK_DA_MASK)\n\t\t | NPS_ENET_ENABLE << CFG_2_DISK_DA_SHIFT;\n\n\t \n\t*ge_mac_cfg_2_value = (*ge_mac_cfg_2_value & ~CFG_2_DISK_MC_MASK)\n\t\t | NPS_ENET_ENABLE << CFG_2_DISK_MC_SHIFT;\n\n\tnps_enet_reg_set(priv, NPS_ENET_REG_GE_MAC_CFG_2,\n\t\t\t *ge_mac_cfg_2_value);\n\n\t \n\tmax_frame_length = ETH_HLEN + ndev->mtu + ETH_FCS_LEN;\n\tif (max_frame_length <= NPS_ENET_MAX_FRAME_LENGTH) {\n\t\t*ge_mac_cfg_3_value =\n\t\t\t (*ge_mac_cfg_3_value & ~CFG_3_MAX_LEN_MASK)\n\t\t\t | max_frame_length << CFG_3_MAX_LEN_SHIFT;\n\t}\n\n\t \n\tbuf_int_enable_value |= NPS_ENET_ENABLE << RX_RDY_SHIFT;\n\tbuf_int_enable_value |= NPS_ENET_ENABLE << TX_DONE_SHIFT;\n\tnps_enet_reg_set(priv, NPS_ENET_REG_BUF_INT_ENABLE,\n\t\t\t buf_int_enable_value);\n\n\t \n\tnps_enet_set_hw_mac_address(ndev);\n\n\t \n\tge_mac_cfg_0_value |= NPS_ENET_ENABLE << CFG_0_TX_PAD_EN_SHIFT;\n\tge_mac_cfg_0_value |= NPS_ENET_ENABLE << CFG_0_TX_CRC_EN_SHIFT;\n\tge_mac_cfg_0_value |= NPS_ENET_ENABLE << CFG_0_RX_CRC_STRIP_SHIFT;\n\n\t \n\tge_mac_cfg_0_value |=\n\t\t NPS_ENET_GE_MAC_CFG_0_RX_IFG << CFG_0_RX_IFG_SHIFT;\n\tge_mac_cfg_0_value |=\n\t\t NPS_ENET_GE_MAC_CFG_0_TX_IFG << CFG_0_TX_IFG_SHIFT;\n\n\t \n\tge_mac_cfg_0_value |= NPS_ENET_ENABLE << CFG_0_RX_PR_CHECK_EN_SHIFT;\n\tge_mac_cfg_0_value |=\n\t\t NPS_ENET_GE_MAC_CFG_0_TX_PR_LEN << CFG_0_TX_PR_LEN_SHIFT;\n\n\t \n\tge_mac_cfg_0_value |= NPS_ENET_ENABLE << CFG_0_TX_FC_EN_SHIFT;\n\tge_mac_cfg_0_value |= NPS_ENET_ENABLE << CFG_0_RX_FC_EN_SHIFT;\n\tge_mac_cfg_0_value |=\n\t\t NPS_ENET_GE_MAC_CFG_0_TX_FC_RETR << CFG_0_TX_FC_RETR_SHIFT;\n\t*ge_mac_cfg_3_value = (*ge_mac_cfg_3_value & ~CFG_3_CF_DROP_MASK)\n\t\t | NPS_ENET_ENABLE << CFG_3_CF_DROP_SHIFT;\n\n\t \n\tge_mac_cfg_0_value |= NPS_ENET_ENABLE << CFG_0_RX_EN_SHIFT;\n\tge_mac_cfg_0_value |= NPS_ENET_ENABLE << CFG_0_TX_EN_SHIFT;\n\n\tnps_enet_reg_set(priv, NPS_ENET_REG_GE_MAC_CFG_3,\n\t\t\t *ge_mac_cfg_3_value);\n\tnps_enet_reg_set(priv, NPS_ENET_REG_GE_MAC_CFG_0,\n\t\t\t ge_mac_cfg_0_value);\n}\n\nstatic void nps_enet_hw_disable_control(struct net_device *ndev)\n{\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\n\t \n\tnps_enet_reg_set(priv, NPS_ENET_REG_BUF_INT_ENABLE, 0);\n\n\t \n\tnps_enet_reg_set(priv, NPS_ENET_REG_GE_MAC_CFG_0, 0);\n}\n\nstatic void nps_enet_send_frame(struct net_device *ndev,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\tu32 tx_ctrl_value = 0;\n\tshort length = skb->len;\n\tu32 i, len = DIV_ROUND_UP(length, sizeof(u32));\n\tu32 *src = (void *)skb->data;\n\tbool src_is_aligned = IS_ALIGNED((unsigned long)src, sizeof(u32));\n\n\t \n\tif (src_is_aligned)\n\t\tiowrite32_rep(priv->regs_base + NPS_ENET_REG_TX_BUF, src, len);\n\telse  \n\t\tfor (i = 0; i < len; i++, src++)\n\t\t\tnps_enet_reg_set(priv, NPS_ENET_REG_TX_BUF,\n\t\t\t\t\t get_unaligned_be32(src));\n\n\t \n\ttx_ctrl_value |= length << TX_CTL_NT_SHIFT;\n\n\ttx_ctrl_value |= NPS_ENET_ENABLE << TX_CTL_CT_SHIFT;\n\t \n\tnps_enet_reg_set(priv, NPS_ENET_REG_TX_CTL, tx_ctrl_value);\n}\n\n \nstatic s32 nps_enet_set_mac_address(struct net_device *ndev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\ts32 res;\n\n\tif (netif_running(ndev))\n\t\treturn -EBUSY;\n\n\tres = eth_mac_addr(ndev, p);\n\tif (!res) {\n\t\teth_hw_addr_set(ndev, addr->sa_data);\n\t\tnps_enet_set_hw_mac_address(ndev);\n\t}\n\n\treturn res;\n}\n\n \nstatic void nps_enet_set_rx_mode(struct net_device *ndev)\n{\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\tu32 ge_mac_cfg_2_value = priv->ge_mac_cfg_2_value;\n\n\tif (ndev->flags & IFF_PROMISC) {\n\t\tge_mac_cfg_2_value = (ge_mac_cfg_2_value & ~CFG_2_DISK_DA_MASK)\n\t\t\t | NPS_ENET_DISABLE << CFG_2_DISK_DA_SHIFT;\n\t\tge_mac_cfg_2_value = (ge_mac_cfg_2_value & ~CFG_2_DISK_MC_MASK)\n\t\t\t | NPS_ENET_DISABLE << CFG_2_DISK_MC_SHIFT;\n\n\t} else {\n\t\tge_mac_cfg_2_value = (ge_mac_cfg_2_value & ~CFG_2_DISK_DA_MASK)\n\t\t\t | NPS_ENET_ENABLE << CFG_2_DISK_DA_SHIFT;\n\t\tge_mac_cfg_2_value = (ge_mac_cfg_2_value & ~CFG_2_DISK_MC_MASK)\n\t\t\t | NPS_ENET_ENABLE << CFG_2_DISK_MC_SHIFT;\n\t}\n\n\tnps_enet_reg_set(priv, NPS_ENET_REG_GE_MAC_CFG_2, ge_mac_cfg_2_value);\n}\n\n \nstatic s32 nps_enet_open(struct net_device *ndev)\n{\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\ts32 err;\n\n\t \n\tpriv->tx_skb = NULL;\n\tpriv->ge_mac_cfg_2_value = 0;\n\tpriv->ge_mac_cfg_3_value = 0;\n\n\t \n\tpriv->ge_mac_cfg_3_value |=\n\t\t NPS_ENET_GE_MAC_CFG_3_RX_IFG_TH << CFG_3_RX_IFG_TH_SHIFT;\n\n\tpriv->ge_mac_cfg_3_value |=\n\t\t NPS_ENET_GE_MAC_CFG_3_MAX_LEN << CFG_3_MAX_LEN_SHIFT;\n\n\t \n\tnps_enet_hw_disable_control(ndev);\n\n\t \n\terr = request_irq(priv->irq, nps_enet_irq_handler,\n\t\t\t  0, \"enet-rx-tx\", ndev);\n\tif (err)\n\t\treturn err;\n\n\tnapi_enable(&priv->napi);\n\n\t \n\tnps_enet_hw_reset(ndev);\n\tnps_enet_hw_enable_control(ndev);\n\n\tnetif_start_queue(ndev);\n\n\treturn 0;\n}\n\n \nstatic s32 nps_enet_stop(struct net_device *ndev)\n{\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\n\tnapi_disable(&priv->napi);\n\tnetif_stop_queue(ndev);\n\tnps_enet_hw_disable_control(ndev);\n\tfree_irq(priv->irq, ndev);\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t nps_enet_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *ndev)\n{\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\n\t \n\tnetif_stop_queue(ndev);\n\n\tpriv->tx_skb = skb;\n\n\t \n\twmb();\n\n\tnps_enet_send_frame(ndev, skb);\n\n\treturn NETDEV_TX_OK;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void nps_enet_poll_controller(struct net_device *ndev)\n{\n\tdisable_irq(ndev->irq);\n\tnps_enet_irq_handler(ndev->irq, ndev);\n\tenable_irq(ndev->irq);\n}\n#endif\n\nstatic const struct net_device_ops nps_netdev_ops = {\n\t.ndo_open\t\t= nps_enet_open,\n\t.ndo_stop\t\t= nps_enet_stop,\n\t.ndo_start_xmit\t\t= nps_enet_start_xmit,\n\t.ndo_set_mac_address\t= nps_enet_set_mac_address,\n\t.ndo_set_rx_mode        = nps_enet_set_rx_mode,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= nps_enet_poll_controller,\n#endif\n};\n\nstatic s32 nps_enet_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct net_device *ndev;\n\tstruct nps_enet_priv *priv;\n\ts32 err = 0;\n\n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tndev = alloc_etherdev(sizeof(struct nps_enet_priv));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ndev);\n\tSET_NETDEV_DEV(ndev, dev);\n\tpriv = netdev_priv(ndev);\n\n\t \n\tndev->netdev_ops = &nps_netdev_ops;\n\tndev->watchdog_timeo = (400 * HZ / 1000);\n\t \n\tndev->flags &= ~IFF_MULTICAST;\n\n\tpriv->regs_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->regs_base)) {\n\t\terr = PTR_ERR(priv->regs_base);\n\t\tgoto out_netdev;\n\t}\n\tdev_dbg(dev, \"Registers base address is 0x%p\\n\", priv->regs_base);\n\n\t \n\terr = of_get_ethdev_address(dev->of_node, ndev);\n\tif (err)\n\t\teth_hw_addr_random(ndev);\n\n\t \n\tpriv->irq = platform_get_irq(pdev, 0);\n\tif (priv->irq < 0) {\n\t\terr = -ENODEV;\n\t\tgoto out_netdev;\n\t}\n\n\tnetif_napi_add_weight(ndev, &priv->napi, nps_enet_poll,\n\t\t\t      NPS_ENET_NAPI_POLL_WEIGHT);\n\n\t \n\terr = register_netdev(ndev);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to register ndev for %s, err = 0x%08x\\n\",\n\t\t\tndev->name, (s32)err);\n\t\tgoto out_netif_api;\n\t}\n\n\tdev_info(dev, \"(rx/tx=%d)\\n\", priv->irq);\n\treturn 0;\n\nout_netif_api:\n\tnetif_napi_del(&priv->napi);\nout_netdev:\n\tfree_netdev(ndev);\n\n\treturn err;\n}\n\nstatic s32 nps_enet_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct nps_enet_priv *priv = netdev_priv(ndev);\n\n\tunregister_netdev(ndev);\n\tnetif_napi_del(&priv->napi);\n\tfree_netdev(ndev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id nps_enet_dt_ids[] = {\n\t{ .compatible = \"ezchip,nps-mgt-enet\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, nps_enet_dt_ids);\n\nstatic struct platform_driver nps_enet_driver = {\n\t.probe = nps_enet_probe,\n\t.remove = nps_enet_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table  = nps_enet_dt_ids,\n\t},\n};\n\nmodule_platform_driver(nps_enet_driver);\n\nMODULE_AUTHOR(\"EZchip Semiconductor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}