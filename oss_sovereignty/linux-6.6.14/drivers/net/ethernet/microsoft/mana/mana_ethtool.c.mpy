{
  "module_name": "mana_ethtool.c",
  "hash_id": "f18322aa13b3d70f53c72098a0f9b078081807e8114e1c0a78b0f2ef9acaee55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microsoft/mana/mana_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/inetdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n\n#include <net/mana/mana.h>\n\nstatic const struct {\n\tchar name[ETH_GSTRING_LEN];\n\tu16 offset;\n} mana_eth_stats[] = {\n\t{\"stop_queue\", offsetof(struct mana_ethtool_stats, stop_queue)},\n\t{\"wake_queue\", offsetof(struct mana_ethtool_stats, wake_queue)},\n\t{\"hc_tx_bytes\", offsetof(struct mana_ethtool_stats, hc_tx_bytes)},\n\t{\"hc_tx_ucast_pkts\", offsetof(struct mana_ethtool_stats,\n\t\t\t\t\thc_tx_ucast_pkts)},\n\t{\"hc_tx_ucast_bytes\", offsetof(struct mana_ethtool_stats,\n\t\t\t\t\thc_tx_ucast_bytes)},\n\t{\"hc_tx_bcast_pkts\", offsetof(struct mana_ethtool_stats,\n\t\t\t\t\thc_tx_bcast_pkts)},\n\t{\"hc_tx_bcast_bytes\", offsetof(struct mana_ethtool_stats,\n\t\t\t\t\thc_tx_bcast_bytes)},\n\t{\"hc_tx_mcast_pkts\", offsetof(struct mana_ethtool_stats,\n\t\t\t\t\thc_tx_mcast_pkts)},\n\t{\"hc_tx_mcast_bytes\", offsetof(struct mana_ethtool_stats,\n\t\t\t\t\thc_tx_mcast_bytes)},\n\t{\"tx_cq_err\", offsetof(struct mana_ethtool_stats, tx_cqe_err)},\n\t{\"tx_cqe_unknown_type\", offsetof(struct mana_ethtool_stats,\n\t\t\t\t\ttx_cqe_unknown_type)},\n\t{\"rx_coalesced_err\", offsetof(struct mana_ethtool_stats,\n\t\t\t\t\trx_coalesced_err)},\n\t{\"rx_cqe_unknown_type\", offsetof(struct mana_ethtool_stats,\n\t\t\t\t\trx_cqe_unknown_type)},\n};\n\nstatic int mana_get_sset_count(struct net_device *ndev, int stringset)\n{\n\tstruct mana_port_context *apc = netdev_priv(ndev);\n\tunsigned int num_queues = apc->num_queues;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn -EINVAL;\n\n\treturn ARRAY_SIZE(mana_eth_stats) + num_queues *\n\t\t\t\t(MANA_STATS_RX_COUNT + MANA_STATS_TX_COUNT);\n}\n\nstatic void mana_get_strings(struct net_device *ndev, u32 stringset, u8 *data)\n{\n\tstruct mana_port_context *apc = netdev_priv(ndev);\n\tunsigned int num_queues = apc->num_queues;\n\tu8 *p = data;\n\tint i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(mana_eth_stats); i++) {\n\t\tmemcpy(p, mana_eth_stats[i].name, ETH_GSTRING_LEN);\n\t\tp += ETH_GSTRING_LEN;\n\t}\n\n\tfor (i = 0; i < num_queues; i++) {\n\t\tsprintf(p, \"rx_%d_packets\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tsprintf(p, \"rx_%d_bytes\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tsprintf(p, \"rx_%d_xdp_drop\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tsprintf(p, \"rx_%d_xdp_tx\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tsprintf(p, \"rx_%d_xdp_redirect\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t}\n\n\tfor (i = 0; i < num_queues; i++) {\n\t\tsprintf(p, \"tx_%d_packets\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tsprintf(p, \"tx_%d_bytes\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tsprintf(p, \"tx_%d_xdp_xmit\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tsprintf(p, \"tx_%d_tso_packets\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tsprintf(p, \"tx_%d_tso_bytes\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tsprintf(p, \"tx_%d_tso_inner_packets\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tsprintf(p, \"tx_%d_tso_inner_bytes\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tsprintf(p, \"tx_%d_long_pkt_fmt\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tsprintf(p, \"tx_%d_short_pkt_fmt\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tsprintf(p, \"tx_%d_csum_partial\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tsprintf(p, \"tx_%d_mana_map_err\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t}\n}\n\nstatic void mana_get_ethtool_stats(struct net_device *ndev,\n\t\t\t\t   struct ethtool_stats *e_stats, u64 *data)\n{\n\tstruct mana_port_context *apc = netdev_priv(ndev);\n\tunsigned int num_queues = apc->num_queues;\n\tvoid *eth_stats = &apc->eth_stats;\n\tstruct mana_stats_rx *rx_stats;\n\tstruct mana_stats_tx *tx_stats;\n\tunsigned int start;\n\tu64 packets, bytes;\n\tu64 xdp_redirect;\n\tu64 xdp_xmit;\n\tu64 xdp_drop;\n\tu64 xdp_tx;\n\tu64 tso_packets;\n\tu64 tso_bytes;\n\tu64 tso_inner_packets;\n\tu64 tso_inner_bytes;\n\tu64 long_pkt_fmt;\n\tu64 short_pkt_fmt;\n\tu64 csum_partial;\n\tu64 mana_map_err;\n\tint q, i = 0;\n\n\tif (!apc->port_is_up)\n\t\treturn;\n\t \n\tmana_query_gf_stats(apc);\n\n\tfor (q = 0; q < ARRAY_SIZE(mana_eth_stats); q++)\n\t\tdata[i++] = *(u64 *)(eth_stats + mana_eth_stats[q].offset);\n\n\tfor (q = 0; q < num_queues; q++) {\n\t\trx_stats = &apc->rxqs[q]->stats;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&rx_stats->syncp);\n\t\t\tpackets = rx_stats->packets;\n\t\t\tbytes = rx_stats->bytes;\n\t\t\txdp_drop = rx_stats->xdp_drop;\n\t\t\txdp_tx = rx_stats->xdp_tx;\n\t\t\txdp_redirect = rx_stats->xdp_redirect;\n\t\t} while (u64_stats_fetch_retry(&rx_stats->syncp, start));\n\n\t\tdata[i++] = packets;\n\t\tdata[i++] = bytes;\n\t\tdata[i++] = xdp_drop;\n\t\tdata[i++] = xdp_tx;\n\t\tdata[i++] = xdp_redirect;\n\t}\n\n\tfor (q = 0; q < num_queues; q++) {\n\t\ttx_stats = &apc->tx_qp[q].txq.stats;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&tx_stats->syncp);\n\t\t\tpackets = tx_stats->packets;\n\t\t\tbytes = tx_stats->bytes;\n\t\t\txdp_xmit = tx_stats->xdp_xmit;\n\t\t\ttso_packets = tx_stats->tso_packets;\n\t\t\ttso_bytes = tx_stats->tso_bytes;\n\t\t\ttso_inner_packets = tx_stats->tso_inner_packets;\n\t\t\ttso_inner_bytes = tx_stats->tso_inner_bytes;\n\t\t\tlong_pkt_fmt = tx_stats->long_pkt_fmt;\n\t\t\tshort_pkt_fmt = tx_stats->short_pkt_fmt;\n\t\t\tcsum_partial = tx_stats->csum_partial;\n\t\t\tmana_map_err = tx_stats->mana_map_err;\n\t\t} while (u64_stats_fetch_retry(&tx_stats->syncp, start));\n\n\t\tdata[i++] = packets;\n\t\tdata[i++] = bytes;\n\t\tdata[i++] = xdp_xmit;\n\t\tdata[i++] = tso_packets;\n\t\tdata[i++] = tso_bytes;\n\t\tdata[i++] = tso_inner_packets;\n\t\tdata[i++] = tso_inner_bytes;\n\t\tdata[i++] = long_pkt_fmt;\n\t\tdata[i++] = short_pkt_fmt;\n\t\tdata[i++] = csum_partial;\n\t\tdata[i++] = mana_map_err;\n\t}\n}\n\nstatic int mana_get_rxnfc(struct net_device *ndev, struct ethtool_rxnfc *cmd,\n\t\t\t  u32 *rules)\n{\n\tstruct mana_port_context *apc = netdev_priv(ndev);\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = apc->num_queues;\n\t\treturn 0;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic u32 mana_get_rxfh_key_size(struct net_device *ndev)\n{\n\treturn MANA_HASH_KEY_SIZE;\n}\n\nstatic u32 mana_rss_indir_size(struct net_device *ndev)\n{\n\treturn MANA_INDIRECT_TABLE_SIZE;\n}\n\nstatic int mana_get_rxfh(struct net_device *ndev, u32 *indir, u8 *key,\n\t\t\t u8 *hfunc)\n{\n\tstruct mana_port_context *apc = netdev_priv(ndev);\n\tint i;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;  \n\n\tif (indir) {\n\t\tfor (i = 0; i < MANA_INDIRECT_TABLE_SIZE; i++)\n\t\t\tindir[i] = apc->indir_table[i];\n\t}\n\n\tif (key)\n\t\tmemcpy(key, apc->hashkey, MANA_HASH_KEY_SIZE);\n\n\treturn 0;\n}\n\nstatic int mana_set_rxfh(struct net_device *ndev, const u32 *indir,\n\t\t\t const u8 *key, const u8 hfunc)\n{\n\tstruct mana_port_context *apc = netdev_priv(ndev);\n\tbool update_hash = false, update_table = false;\n\tu32 save_table[MANA_INDIRECT_TABLE_SIZE];\n\tu8 save_key[MANA_HASH_KEY_SIZE];\n\tint i, err;\n\n\tif (!apc->port_is_up)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (indir) {\n\t\tfor (i = 0; i < MANA_INDIRECT_TABLE_SIZE; i++)\n\t\t\tif (indir[i] >= apc->num_queues)\n\t\t\t\treturn -EINVAL;\n\n\t\tupdate_table = true;\n\t\tfor (i = 0; i < MANA_INDIRECT_TABLE_SIZE; i++) {\n\t\t\tsave_table[i] = apc->indir_table[i];\n\t\t\tapc->indir_table[i] = indir[i];\n\t\t}\n\t}\n\n\tif (key) {\n\t\tupdate_hash = true;\n\t\tmemcpy(save_key, apc->hashkey, MANA_HASH_KEY_SIZE);\n\t\tmemcpy(apc->hashkey, key, MANA_HASH_KEY_SIZE);\n\t}\n\n\terr = mana_config_rss(apc, TRI_STATE_TRUE, update_hash, update_table);\n\n\tif (err) {  \n\t\tif (update_table) {\n\t\t\tfor (i = 0; i < MANA_INDIRECT_TABLE_SIZE; i++)\n\t\t\t\tapc->indir_table[i] = save_table[i];\n\t\t}\n\n\t\tif (update_hash)\n\t\t\tmemcpy(apc->hashkey, save_key, MANA_HASH_KEY_SIZE);\n\n\t\tmana_config_rss(apc, TRI_STATE_TRUE, update_hash, update_table);\n\t}\n\n\treturn err;\n}\n\nstatic void mana_get_channels(struct net_device *ndev,\n\t\t\t      struct ethtool_channels *channel)\n{\n\tstruct mana_port_context *apc = netdev_priv(ndev);\n\n\tchannel->max_combined = apc->max_queues;\n\tchannel->combined_count = apc->num_queues;\n}\n\nstatic int mana_set_channels(struct net_device *ndev,\n\t\t\t     struct ethtool_channels *channels)\n{\n\tstruct mana_port_context *apc = netdev_priv(ndev);\n\tunsigned int new_count = channels->combined_count;\n\tunsigned int old_count = apc->num_queues;\n\tint err, err2;\n\n\terr = mana_detach(ndev, false);\n\tif (err) {\n\t\tnetdev_err(ndev, \"mana_detach failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tapc->num_queues = new_count;\n\terr = mana_attach(ndev);\n\tif (!err)\n\t\treturn 0;\n\n\tnetdev_err(ndev, \"mana_attach failed: %d\\n\", err);\n\n\t \n\tapc->num_queues = old_count;\n\terr2 = mana_attach(ndev);\n\tif (err2)\n\t\tnetdev_err(ndev, \"mana re-attach failed: %d\\n\", err2);\n\n\treturn err;\n}\n\nconst struct ethtool_ops mana_ethtool_ops = {\n\t.get_ethtool_stats\t= mana_get_ethtool_stats,\n\t.get_sset_count\t\t= mana_get_sset_count,\n\t.get_strings\t\t= mana_get_strings,\n\t.get_rxnfc\t\t= mana_get_rxnfc,\n\t.get_rxfh_key_size\t= mana_get_rxfh_key_size,\n\t.get_rxfh_indir_size\t= mana_rss_indir_size,\n\t.get_rxfh\t\t= mana_get_rxfh,\n\t.set_rxfh\t\t= mana_set_rxfh,\n\t.get_channels\t\t= mana_get_channels,\n\t.set_channels\t\t= mana_set_channels,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}