{
  "module_name": "gdma_main.c",
  "hash_id": "ef6470ef7b289758cd529c07c390ecabe4194953941d47b72f6e386033455c04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microsoft/mana/gdma_main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/utsname.h>\n#include <linux/version.h>\n\n#include <net/mana/mana.h>\n\nstatic u32 mana_gd_r32(struct gdma_context *g, u64 offset)\n{\n\treturn readl(g->bar0_va + offset);\n}\n\nstatic u64 mana_gd_r64(struct gdma_context *g, u64 offset)\n{\n\treturn readq(g->bar0_va + offset);\n}\n\nstatic void mana_gd_init_pf_regs(struct pci_dev *pdev)\n{\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\tvoid __iomem *sriov_base_va;\n\tu64 sriov_base_off;\n\n\tgc->db_page_size = mana_gd_r32(gc, GDMA_PF_REG_DB_PAGE_SIZE) & 0xFFFF;\n\tgc->db_page_base = gc->bar0_va +\n\t\t\t\tmana_gd_r64(gc, GDMA_PF_REG_DB_PAGE_OFF);\n\n\tsriov_base_off = mana_gd_r64(gc, GDMA_SRIOV_REG_CFG_BASE_OFF);\n\n\tsriov_base_va = gc->bar0_va + sriov_base_off;\n\tgc->shm_base = sriov_base_va +\n\t\t\tmana_gd_r64(gc, sriov_base_off + GDMA_PF_REG_SHM_OFF);\n}\n\nstatic void mana_gd_init_vf_regs(struct pci_dev *pdev)\n{\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\n\tgc->db_page_size = mana_gd_r32(gc, GDMA_REG_DB_PAGE_SIZE) & 0xFFFF;\n\n\tgc->db_page_base = gc->bar0_va +\n\t\t\t\tmana_gd_r64(gc, GDMA_REG_DB_PAGE_OFFSET);\n\n\tgc->phys_db_page_base = gc->bar0_pa +\n\t\t\t\tmana_gd_r64(gc, GDMA_REG_DB_PAGE_OFFSET);\n\n\tgc->shm_base = gc->bar0_va + mana_gd_r64(gc, GDMA_REG_SHM_OFFSET);\n}\n\nstatic void mana_gd_init_registers(struct pci_dev *pdev)\n{\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\n\tif (gc->is_pf)\n\t\tmana_gd_init_pf_regs(pdev);\n\telse\n\t\tmana_gd_init_vf_regs(pdev);\n}\n\nstatic int mana_gd_query_max_resources(struct pci_dev *pdev)\n{\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\tstruct gdma_query_max_resources_resp resp = {};\n\tstruct gdma_general_req req = {};\n\tint err;\n\n\tmana_gd_init_req_hdr(&req.hdr, GDMA_QUERY_MAX_RESOURCES,\n\t\t\t     sizeof(req), sizeof(resp));\n\n\terr = mana_gd_send_request(gc, sizeof(req), &req, sizeof(resp), &resp);\n\tif (err || resp.hdr.status) {\n\t\tdev_err(gc->dev, \"Failed to query resource info: %d, 0x%x\\n\",\n\t\t\terr, resp.hdr.status);\n\t\treturn err ? err : -EPROTO;\n\t}\n\n\tif (gc->num_msix_usable > resp.max_msix)\n\t\tgc->num_msix_usable = resp.max_msix;\n\n\tif (gc->num_msix_usable <= 1)\n\t\treturn -ENOSPC;\n\n\tgc->max_num_queues = num_online_cpus();\n\tif (gc->max_num_queues > MANA_MAX_NUM_QUEUES)\n\t\tgc->max_num_queues = MANA_MAX_NUM_QUEUES;\n\n\tif (gc->max_num_queues > resp.max_eq)\n\t\tgc->max_num_queues = resp.max_eq;\n\n\tif (gc->max_num_queues > resp.max_cq)\n\t\tgc->max_num_queues = resp.max_cq;\n\n\tif (gc->max_num_queues > resp.max_sq)\n\t\tgc->max_num_queues = resp.max_sq;\n\n\tif (gc->max_num_queues > resp.max_rq)\n\t\tgc->max_num_queues = resp.max_rq;\n\n\t \n\tif (gc->max_num_queues > gc->num_msix_usable - 1)\n\t\tgc->max_num_queues = gc->num_msix_usable - 1;\n\n\treturn 0;\n}\n\nstatic int mana_gd_query_hwc_timeout(struct pci_dev *pdev, u32 *timeout_val)\n{\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\tstruct gdma_query_hwc_timeout_resp resp = {};\n\tstruct gdma_query_hwc_timeout_req req = {};\n\tint err;\n\n\tmana_gd_init_req_hdr(&req.hdr, GDMA_QUERY_HWC_TIMEOUT,\n\t\t\t     sizeof(req), sizeof(resp));\n\treq.timeout_ms = *timeout_val;\n\terr = mana_gd_send_request(gc, sizeof(req), &req, sizeof(resp), &resp);\n\tif (err || resp.hdr.status)\n\t\treturn err ? err : -EPROTO;\n\n\t*timeout_val = resp.timeout_ms;\n\n\treturn 0;\n}\n\nstatic int mana_gd_detect_devices(struct pci_dev *pdev)\n{\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\tstruct gdma_list_devices_resp resp = {};\n\tstruct gdma_general_req req = {};\n\tstruct gdma_dev_id dev;\n\tu32 i, max_num_devs;\n\tu16 dev_type;\n\tint err;\n\n\tmana_gd_init_req_hdr(&req.hdr, GDMA_LIST_DEVICES, sizeof(req),\n\t\t\t     sizeof(resp));\n\n\terr = mana_gd_send_request(gc, sizeof(req), &req, sizeof(resp), &resp);\n\tif (err || resp.hdr.status) {\n\t\tdev_err(gc->dev, \"Failed to detect devices: %d, 0x%x\\n\", err,\n\t\t\tresp.hdr.status);\n\t\treturn err ? err : -EPROTO;\n\t}\n\n\tmax_num_devs = min_t(u32, MAX_NUM_GDMA_DEVICES, resp.num_of_devs);\n\n\tfor (i = 0; i < max_num_devs; i++) {\n\t\tdev = resp.devs[i];\n\t\tdev_type = dev.type;\n\n\t\t \n\t\tif (dev_type == GDMA_DEVICE_HWC)\n\t\t\tcontinue;\n\n\t\tif (dev_type == GDMA_DEVICE_MANA) {\n\t\t\tgc->mana.gdma_context = gc;\n\t\t\tgc->mana.dev_id = dev;\n\t\t}\n\t}\n\n\treturn gc->mana.dev_id.type == 0 ? -ENODEV : 0;\n}\n\nint mana_gd_send_request(struct gdma_context *gc, u32 req_len, const void *req,\n\t\t\t u32 resp_len, void *resp)\n{\n\tstruct hw_channel_context *hwc = gc->hwc.driver_data;\n\n\treturn mana_hwc_send_request(hwc, req_len, req, resp_len, resp);\n}\nEXPORT_SYMBOL_NS(mana_gd_send_request, NET_MANA);\n\nint mana_gd_alloc_memory(struct gdma_context *gc, unsigned int length,\n\t\t\t struct gdma_mem_info *gmi)\n{\n\tdma_addr_t dma_handle;\n\tvoid *buf;\n\n\tif (length < PAGE_SIZE || !is_power_of_2(length))\n\t\treturn -EINVAL;\n\n\tgmi->dev = gc->dev;\n\tbuf = dma_alloc_coherent(gmi->dev, length, &dma_handle, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tgmi->dma_handle = dma_handle;\n\tgmi->virt_addr = buf;\n\tgmi->length = length;\n\n\treturn 0;\n}\n\nvoid mana_gd_free_memory(struct gdma_mem_info *gmi)\n{\n\tdma_free_coherent(gmi->dev, gmi->length, gmi->virt_addr,\n\t\t\t  gmi->dma_handle);\n}\n\nstatic int mana_gd_create_hw_eq(struct gdma_context *gc,\n\t\t\t\tstruct gdma_queue *queue)\n{\n\tstruct gdma_create_queue_resp resp = {};\n\tstruct gdma_create_queue_req req = {};\n\tint err;\n\n\tif (queue->type != GDMA_EQ)\n\t\treturn -EINVAL;\n\n\tmana_gd_init_req_hdr(&req.hdr, GDMA_CREATE_QUEUE,\n\t\t\t     sizeof(req), sizeof(resp));\n\n\treq.hdr.dev_id = queue->gdma_dev->dev_id;\n\treq.type = queue->type;\n\treq.pdid = queue->gdma_dev->pdid;\n\treq.doolbell_id = queue->gdma_dev->doorbell;\n\treq.gdma_region = queue->mem_info.dma_region_handle;\n\treq.queue_size = queue->queue_size;\n\treq.log2_throttle_limit = queue->eq.log2_throttle_limit;\n\treq.eq_pci_msix_index = queue->eq.msix_index;\n\n\terr = mana_gd_send_request(gc, sizeof(req), &req, sizeof(resp), &resp);\n\tif (err || resp.hdr.status) {\n\t\tdev_err(gc->dev, \"Failed to create queue: %d, 0x%x\\n\", err,\n\t\t\tresp.hdr.status);\n\t\treturn err ? err : -EPROTO;\n\t}\n\n\tqueue->id = resp.queue_index;\n\tqueue->eq.disable_needed = true;\n\tqueue->mem_info.dma_region_handle = GDMA_INVALID_DMA_REGION;\n\treturn 0;\n}\n\nstatic int mana_gd_disable_queue(struct gdma_queue *queue)\n{\n\tstruct gdma_context *gc = queue->gdma_dev->gdma_context;\n\tstruct gdma_disable_queue_req req = {};\n\tstruct gdma_general_resp resp = {};\n\tint err;\n\n\tWARN_ON(queue->type != GDMA_EQ);\n\n\tmana_gd_init_req_hdr(&req.hdr, GDMA_DISABLE_QUEUE,\n\t\t\t     sizeof(req), sizeof(resp));\n\n\treq.hdr.dev_id = queue->gdma_dev->dev_id;\n\treq.type = queue->type;\n\treq.queue_index =  queue->id;\n\treq.alloc_res_id_on_creation = 1;\n\n\terr = mana_gd_send_request(gc, sizeof(req), &req, sizeof(resp), &resp);\n\tif (err || resp.hdr.status) {\n\t\tdev_err(gc->dev, \"Failed to disable queue: %d, 0x%x\\n\", err,\n\t\t\tresp.hdr.status);\n\t\treturn err ? err : -EPROTO;\n\t}\n\n\treturn 0;\n}\n\n#define DOORBELL_OFFSET_SQ\t0x0\n#define DOORBELL_OFFSET_RQ\t0x400\n#define DOORBELL_OFFSET_CQ\t0x800\n#define DOORBELL_OFFSET_EQ\t0xFF8\n\nstatic void mana_gd_ring_doorbell(struct gdma_context *gc, u32 db_index,\n\t\t\t\t  enum gdma_queue_type q_type, u32 qid,\n\t\t\t\t  u32 tail_ptr, u8 num_req)\n{\n\tvoid __iomem *addr = gc->db_page_base + gc->db_page_size * db_index;\n\tunion gdma_doorbell_entry e = {};\n\n\tswitch (q_type) {\n\tcase GDMA_EQ:\n\t\te.eq.id = qid;\n\t\te.eq.tail_ptr = tail_ptr;\n\t\te.eq.arm = num_req;\n\n\t\taddr += DOORBELL_OFFSET_EQ;\n\t\tbreak;\n\n\tcase GDMA_CQ:\n\t\te.cq.id = qid;\n\t\te.cq.tail_ptr = tail_ptr;\n\t\te.cq.arm = num_req;\n\n\t\taddr += DOORBELL_OFFSET_CQ;\n\t\tbreak;\n\n\tcase GDMA_RQ:\n\t\te.rq.id = qid;\n\t\te.rq.tail_ptr = tail_ptr;\n\t\te.rq.wqe_cnt = num_req;\n\n\t\taddr += DOORBELL_OFFSET_RQ;\n\t\tbreak;\n\n\tcase GDMA_SQ:\n\t\te.sq.id = qid;\n\t\te.sq.tail_ptr = tail_ptr;\n\n\t\taddr += DOORBELL_OFFSET_SQ;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t \n\twmb();\n\n\twriteq(e.as_uint64, addr);\n}\n\nvoid mana_gd_wq_ring_doorbell(struct gdma_context *gc, struct gdma_queue *queue)\n{\n\t \n\tmana_gd_ring_doorbell(gc, queue->gdma_dev->doorbell, queue->type,\n\t\t\t      queue->id, queue->head * GDMA_WQE_BU_SIZE, 0);\n}\n\nvoid mana_gd_ring_cq(struct gdma_queue *cq, u8 arm_bit)\n{\n\tstruct gdma_context *gc = cq->gdma_dev->gdma_context;\n\n\tu32 num_cqe = cq->queue_size / GDMA_CQE_SIZE;\n\n\tu32 head = cq->head % (num_cqe << GDMA_CQE_OWNER_BITS);\n\n\tmana_gd_ring_doorbell(gc, cq->gdma_dev->doorbell, cq->type, cq->id,\n\t\t\t      head, arm_bit);\n}\n\nstatic void mana_gd_process_eqe(struct gdma_queue *eq)\n{\n\tu32 head = eq->head % (eq->queue_size / GDMA_EQE_SIZE);\n\tstruct gdma_context *gc = eq->gdma_dev->gdma_context;\n\tstruct gdma_eqe *eq_eqe_ptr = eq->queue_mem_ptr;\n\tunion gdma_eqe_info eqe_info;\n\tenum gdma_eqe_type type;\n\tstruct gdma_event event;\n\tstruct gdma_queue *cq;\n\tstruct gdma_eqe *eqe;\n\tu32 cq_id;\n\n\teqe = &eq_eqe_ptr[head];\n\teqe_info.as_uint32 = eqe->eqe_info;\n\ttype = eqe_info.type;\n\n\tswitch (type) {\n\tcase GDMA_EQE_COMPLETION:\n\t\tcq_id = eqe->details[0] & 0xFFFFFF;\n\t\tif (WARN_ON_ONCE(cq_id >= gc->max_num_cqs))\n\t\t\tbreak;\n\n\t\tcq = gc->cq_table[cq_id];\n\t\tif (WARN_ON_ONCE(!cq || cq->type != GDMA_CQ || cq->id != cq_id))\n\t\t\tbreak;\n\n\t\tif (cq->cq.callback)\n\t\t\tcq->cq.callback(cq->cq.context, cq);\n\n\t\tbreak;\n\n\tcase GDMA_EQE_TEST_EVENT:\n\t\tgc->test_event_eq_id = eq->id;\n\t\tcomplete(&gc->eq_test_event);\n\t\tbreak;\n\n\tcase GDMA_EQE_HWC_INIT_EQ_ID_DB:\n\tcase GDMA_EQE_HWC_INIT_DATA:\n\tcase GDMA_EQE_HWC_INIT_DONE:\n\t\tif (!eq->eq.callback)\n\t\t\tbreak;\n\n\t\tevent.type = type;\n\t\tmemcpy(&event.details, &eqe->details, GDMA_EVENT_DATA_SIZE);\n\t\teq->eq.callback(eq->eq.context, eq, &event);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void mana_gd_process_eq_events(void *arg)\n{\n\tu32 owner_bits, new_bits, old_bits;\n\tunion gdma_eqe_info eqe_info;\n\tstruct gdma_eqe *eq_eqe_ptr;\n\tstruct gdma_queue *eq = arg;\n\tstruct gdma_context *gc;\n\tstruct gdma_eqe *eqe;\n\tu32 head, num_eqe;\n\tint i;\n\n\tgc = eq->gdma_dev->gdma_context;\n\n\tnum_eqe = eq->queue_size / GDMA_EQE_SIZE;\n\teq_eqe_ptr = eq->queue_mem_ptr;\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\teqe = &eq_eqe_ptr[eq->head % num_eqe];\n\t\teqe_info.as_uint32 = eqe->eqe_info;\n\t\towner_bits = eqe_info.owner_bits;\n\n\t\told_bits = (eq->head / num_eqe - 1) & GDMA_EQE_OWNER_MASK;\n\t\t \n\t\tif (owner_bits == old_bits)\n\t\t\tbreak;\n\n\t\tnew_bits = (eq->head / num_eqe) & GDMA_EQE_OWNER_MASK;\n\t\tif (owner_bits != new_bits) {\n\t\t\tdev_err(gc->dev, \"EQ %d: overflow detected\\n\", eq->id);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trmb();\n\n\t\tmana_gd_process_eqe(eq);\n\n\t\teq->head++;\n\t}\n\n\thead = eq->head % (num_eqe << GDMA_EQE_OWNER_BITS);\n\n\tmana_gd_ring_doorbell(gc, eq->gdma_dev->doorbell, eq->type, eq->id,\n\t\t\t      head, SET_ARM_BIT);\n}\n\nstatic int mana_gd_register_irq(struct gdma_queue *queue,\n\t\t\t\tconst struct gdma_queue_spec *spec)\n{\n\tstruct gdma_dev *gd = queue->gdma_dev;\n\tstruct gdma_irq_context *gic;\n\tstruct gdma_context *gc;\n\tstruct gdma_resource *r;\n\tunsigned int msi_index;\n\tunsigned long flags;\n\tstruct device *dev;\n\tint err = 0;\n\n\tgc = gd->gdma_context;\n\tr = &gc->msix_resource;\n\tdev = gc->dev;\n\n\tspin_lock_irqsave(&r->lock, flags);\n\n\tmsi_index = find_first_zero_bit(r->map, r->size);\n\tif (msi_index >= r->size || msi_index >= gc->num_msix_usable) {\n\t\terr = -ENOSPC;\n\t} else {\n\t\tbitmap_set(r->map, msi_index, 1);\n\t\tqueue->eq.msix_index = msi_index;\n\t}\n\n\tspin_unlock_irqrestore(&r->lock, flags);\n\n\tif (err) {\n\t\tdev_err(dev, \"Register IRQ err:%d, msi:%u rsize:%u, nMSI:%u\",\n\t\t\terr, msi_index, r->size, gc->num_msix_usable);\n\n\t\treturn err;\n\t}\n\n\tgic = &gc->irq_contexts[msi_index];\n\n\tWARN_ON(gic->handler || gic->arg);\n\n\tgic->arg = queue;\n\n\tgic->handler = mana_gd_process_eq_events;\n\n\treturn 0;\n}\n\nstatic void mana_gd_deregiser_irq(struct gdma_queue *queue)\n{\n\tstruct gdma_dev *gd = queue->gdma_dev;\n\tstruct gdma_irq_context *gic;\n\tstruct gdma_context *gc;\n\tstruct gdma_resource *r;\n\tunsigned int msix_index;\n\tunsigned long flags;\n\n\tgc = gd->gdma_context;\n\tr = &gc->msix_resource;\n\n\t \n\tmsix_index = queue->eq.msix_index;\n\tif (WARN_ON(msix_index >= gc->num_msix_usable))\n\t\treturn;\n\n\tgic = &gc->irq_contexts[msix_index];\n\tgic->handler = NULL;\n\tgic->arg = NULL;\n\n\tspin_lock_irqsave(&r->lock, flags);\n\tbitmap_clear(r->map, msix_index, 1);\n\tspin_unlock_irqrestore(&r->lock, flags);\n\n\tqueue->eq.msix_index = INVALID_PCI_MSIX_INDEX;\n}\n\nint mana_gd_test_eq(struct gdma_context *gc, struct gdma_queue *eq)\n{\n\tstruct gdma_generate_test_event_req req = {};\n\tstruct gdma_general_resp resp = {};\n\tstruct device *dev = gc->dev;\n\tint err;\n\n\tmutex_lock(&gc->eq_test_event_mutex);\n\n\tinit_completion(&gc->eq_test_event);\n\tgc->test_event_eq_id = INVALID_QUEUE_ID;\n\n\tmana_gd_init_req_hdr(&req.hdr, GDMA_GENERATE_TEST_EQE,\n\t\t\t     sizeof(req), sizeof(resp));\n\n\treq.hdr.dev_id = eq->gdma_dev->dev_id;\n\treq.queue_index = eq->id;\n\n\terr = mana_gd_send_request(gc, sizeof(req), &req, sizeof(resp), &resp);\n\tif (err) {\n\t\tdev_err(dev, \"test_eq failed: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\terr = -EPROTO;\n\n\tif (resp.hdr.status) {\n\t\tdev_err(dev, \"test_eq failed: 0x%x\\n\", resp.hdr.status);\n\t\tgoto out;\n\t}\n\n\tif (!wait_for_completion_timeout(&gc->eq_test_event, 30 * HZ)) {\n\t\tdev_err(dev, \"test_eq timed out on queue %d\\n\", eq->id);\n\t\tgoto out;\n\t}\n\n\tif (eq->id != gc->test_event_eq_id) {\n\t\tdev_err(dev, \"test_eq got an event on wrong queue %d (%d)\\n\",\n\t\t\tgc->test_event_eq_id, eq->id);\n\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\tmutex_unlock(&gc->eq_test_event_mutex);\n\treturn err;\n}\n\nstatic void mana_gd_destroy_eq(struct gdma_context *gc, bool flush_evenets,\n\t\t\t       struct gdma_queue *queue)\n{\n\tint err;\n\n\tif (flush_evenets) {\n\t\terr = mana_gd_test_eq(gc, queue);\n\t\tif (err)\n\t\t\tdev_warn(gc->dev, \"Failed to flush EQ: %d\\n\", err);\n\t}\n\n\tmana_gd_deregiser_irq(queue);\n\n\tif (queue->eq.disable_needed)\n\t\tmana_gd_disable_queue(queue);\n}\n\nstatic int mana_gd_create_eq(struct gdma_dev *gd,\n\t\t\t     const struct gdma_queue_spec *spec,\n\t\t\t     bool create_hwq, struct gdma_queue *queue)\n{\n\tstruct gdma_context *gc = gd->gdma_context;\n\tstruct device *dev = gc->dev;\n\tu32 log2_num_entries;\n\tint err;\n\n\tqueue->eq.msix_index = INVALID_PCI_MSIX_INDEX;\n\n\tlog2_num_entries = ilog2(queue->queue_size / GDMA_EQE_SIZE);\n\n\tif (spec->eq.log2_throttle_limit > log2_num_entries) {\n\t\tdev_err(dev, \"EQ throttling limit (%lu) > maximum EQE (%u)\\n\",\n\t\t\tspec->eq.log2_throttle_limit, log2_num_entries);\n\t\treturn -EINVAL;\n\t}\n\n\terr = mana_gd_register_irq(queue, spec);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to register irq: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tqueue->eq.callback = spec->eq.callback;\n\tqueue->eq.context = spec->eq.context;\n\tqueue->head |= INITIALIZED_OWNER_BIT(log2_num_entries);\n\tqueue->eq.log2_throttle_limit = spec->eq.log2_throttle_limit ?: 1;\n\n\tif (create_hwq) {\n\t\terr = mana_gd_create_hw_eq(gc, queue);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = mana_gd_test_eq(gc, queue);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treturn 0;\nout:\n\tdev_err(dev, \"Failed to create EQ: %d\\n\", err);\n\tmana_gd_destroy_eq(gc, false, queue);\n\treturn err;\n}\n\nstatic void mana_gd_create_cq(const struct gdma_queue_spec *spec,\n\t\t\t      struct gdma_queue *queue)\n{\n\tu32 log2_num_entries = ilog2(spec->queue_size / GDMA_CQE_SIZE);\n\n\tqueue->head |= INITIALIZED_OWNER_BIT(log2_num_entries);\n\tqueue->cq.parent = spec->cq.parent_eq;\n\tqueue->cq.context = spec->cq.context;\n\tqueue->cq.callback = spec->cq.callback;\n}\n\nstatic void mana_gd_destroy_cq(struct gdma_context *gc,\n\t\t\t       struct gdma_queue *queue)\n{\n\tu32 id = queue->id;\n\n\tif (id >= gc->max_num_cqs)\n\t\treturn;\n\n\tif (!gc->cq_table[id])\n\t\treturn;\n\n\tgc->cq_table[id] = NULL;\n}\n\nint mana_gd_create_hwc_queue(struct gdma_dev *gd,\n\t\t\t     const struct gdma_queue_spec *spec,\n\t\t\t     struct gdma_queue **queue_ptr)\n{\n\tstruct gdma_context *gc = gd->gdma_context;\n\tstruct gdma_mem_info *gmi;\n\tstruct gdma_queue *queue;\n\tint err;\n\n\tqueue = kzalloc(sizeof(*queue), GFP_KERNEL);\n\tif (!queue)\n\t\treturn -ENOMEM;\n\n\tgmi = &queue->mem_info;\n\terr = mana_gd_alloc_memory(gc, spec->queue_size, gmi);\n\tif (err)\n\t\tgoto free_q;\n\n\tqueue->head = 0;\n\tqueue->tail = 0;\n\tqueue->queue_mem_ptr = gmi->virt_addr;\n\tqueue->queue_size = spec->queue_size;\n\tqueue->monitor_avl_buf = spec->monitor_avl_buf;\n\tqueue->type = spec->type;\n\tqueue->gdma_dev = gd;\n\n\tif (spec->type == GDMA_EQ)\n\t\terr = mana_gd_create_eq(gd, spec, false, queue);\n\telse if (spec->type == GDMA_CQ)\n\t\tmana_gd_create_cq(spec, queue);\n\n\tif (err)\n\t\tgoto out;\n\n\t*queue_ptr = queue;\n\treturn 0;\nout:\n\tmana_gd_free_memory(gmi);\nfree_q:\n\tkfree(queue);\n\treturn err;\n}\n\nint mana_gd_destroy_dma_region(struct gdma_context *gc, u64 dma_region_handle)\n{\n\tstruct gdma_destroy_dma_region_req req = {};\n\tstruct gdma_general_resp resp = {};\n\tint err;\n\n\tif (dma_region_handle == GDMA_INVALID_DMA_REGION)\n\t\treturn 0;\n\n\tmana_gd_init_req_hdr(&req.hdr, GDMA_DESTROY_DMA_REGION, sizeof(req),\n\t\t\t     sizeof(resp));\n\treq.dma_region_handle = dma_region_handle;\n\n\terr = mana_gd_send_request(gc, sizeof(req), &req, sizeof(resp), &resp);\n\tif (err || resp.hdr.status) {\n\t\tdev_err(gc->dev, \"Failed to destroy DMA region: %d, 0x%x\\n\",\n\t\t\terr, resp.hdr.status);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(mana_gd_destroy_dma_region, NET_MANA);\n\nstatic int mana_gd_create_dma_region(struct gdma_dev *gd,\n\t\t\t\t     struct gdma_mem_info *gmi)\n{\n\tunsigned int num_page = gmi->length / PAGE_SIZE;\n\tstruct gdma_create_dma_region_req *req = NULL;\n\tstruct gdma_create_dma_region_resp resp = {};\n\tstruct gdma_context *gc = gd->gdma_context;\n\tstruct hw_channel_context *hwc;\n\tu32 length = gmi->length;\n\tsize_t req_msg_size;\n\tint err;\n\tint i;\n\n\tif (length < PAGE_SIZE || !is_power_of_2(length))\n\t\treturn -EINVAL;\n\n\tif (offset_in_page(gmi->virt_addr) != 0)\n\t\treturn -EINVAL;\n\n\thwc = gc->hwc.driver_data;\n\treq_msg_size = struct_size(req, page_addr_list, num_page);\n\tif (req_msg_size > hwc->max_req_msg_size)\n\t\treturn -EINVAL;\n\n\treq = kzalloc(req_msg_size, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tmana_gd_init_req_hdr(&req->hdr, GDMA_CREATE_DMA_REGION,\n\t\t\t     req_msg_size, sizeof(resp));\n\treq->length = length;\n\treq->offset_in_page = 0;\n\treq->gdma_page_type = GDMA_PAGE_TYPE_4K;\n\treq->page_count = num_page;\n\treq->page_addr_list_len = num_page;\n\n\tfor (i = 0; i < num_page; i++)\n\t\treq->page_addr_list[i] = gmi->dma_handle +  i * PAGE_SIZE;\n\n\terr = mana_gd_send_request(gc, req_msg_size, req, sizeof(resp), &resp);\n\tif (err)\n\t\tgoto out;\n\n\tif (resp.hdr.status ||\n\t    resp.dma_region_handle == GDMA_INVALID_DMA_REGION) {\n\t\tdev_err(gc->dev, \"Failed to create DMA region: 0x%x\\n\",\n\t\t\tresp.hdr.status);\n\t\terr = -EPROTO;\n\t\tgoto out;\n\t}\n\n\tgmi->dma_region_handle = resp.dma_region_handle;\nout:\n\tkfree(req);\n\treturn err;\n}\n\nint mana_gd_create_mana_eq(struct gdma_dev *gd,\n\t\t\t   const struct gdma_queue_spec *spec,\n\t\t\t   struct gdma_queue **queue_ptr)\n{\n\tstruct gdma_context *gc = gd->gdma_context;\n\tstruct gdma_mem_info *gmi;\n\tstruct gdma_queue *queue;\n\tint err;\n\n\tif (spec->type != GDMA_EQ)\n\t\treturn -EINVAL;\n\n\tqueue = kzalloc(sizeof(*queue), GFP_KERNEL);\n\tif (!queue)\n\t\treturn -ENOMEM;\n\n\tgmi = &queue->mem_info;\n\terr = mana_gd_alloc_memory(gc, spec->queue_size, gmi);\n\tif (err)\n\t\tgoto free_q;\n\n\terr = mana_gd_create_dma_region(gd, gmi);\n\tif (err)\n\t\tgoto out;\n\n\tqueue->head = 0;\n\tqueue->tail = 0;\n\tqueue->queue_mem_ptr = gmi->virt_addr;\n\tqueue->queue_size = spec->queue_size;\n\tqueue->monitor_avl_buf = spec->monitor_avl_buf;\n\tqueue->type = spec->type;\n\tqueue->gdma_dev = gd;\n\n\terr = mana_gd_create_eq(gd, spec, true, queue);\n\tif (err)\n\t\tgoto out;\n\n\t*queue_ptr = queue;\n\treturn 0;\nout:\n\tmana_gd_free_memory(gmi);\nfree_q:\n\tkfree(queue);\n\treturn err;\n}\n\nint mana_gd_create_mana_wq_cq(struct gdma_dev *gd,\n\t\t\t      const struct gdma_queue_spec *spec,\n\t\t\t      struct gdma_queue **queue_ptr)\n{\n\tstruct gdma_context *gc = gd->gdma_context;\n\tstruct gdma_mem_info *gmi;\n\tstruct gdma_queue *queue;\n\tint err;\n\n\tif (spec->type != GDMA_CQ && spec->type != GDMA_SQ &&\n\t    spec->type != GDMA_RQ)\n\t\treturn -EINVAL;\n\n\tqueue = kzalloc(sizeof(*queue), GFP_KERNEL);\n\tif (!queue)\n\t\treturn -ENOMEM;\n\n\tgmi = &queue->mem_info;\n\terr = mana_gd_alloc_memory(gc, spec->queue_size, gmi);\n\tif (err)\n\t\tgoto free_q;\n\n\terr = mana_gd_create_dma_region(gd, gmi);\n\tif (err)\n\t\tgoto out;\n\n\tqueue->head = 0;\n\tqueue->tail = 0;\n\tqueue->queue_mem_ptr = gmi->virt_addr;\n\tqueue->queue_size = spec->queue_size;\n\tqueue->monitor_avl_buf = spec->monitor_avl_buf;\n\tqueue->type = spec->type;\n\tqueue->gdma_dev = gd;\n\n\tif (spec->type == GDMA_CQ)\n\t\tmana_gd_create_cq(spec, queue);\n\n\t*queue_ptr = queue;\n\treturn 0;\nout:\n\tmana_gd_free_memory(gmi);\nfree_q:\n\tkfree(queue);\n\treturn err;\n}\n\nvoid mana_gd_destroy_queue(struct gdma_context *gc, struct gdma_queue *queue)\n{\n\tstruct gdma_mem_info *gmi = &queue->mem_info;\n\n\tswitch (queue->type) {\n\tcase GDMA_EQ:\n\t\tmana_gd_destroy_eq(gc, queue->eq.disable_needed, queue);\n\t\tbreak;\n\n\tcase GDMA_CQ:\n\t\tmana_gd_destroy_cq(gc, queue);\n\t\tbreak;\n\n\tcase GDMA_RQ:\n\t\tbreak;\n\n\tcase GDMA_SQ:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(gc->dev, \"Can't destroy unknown queue: type=%d\\n\",\n\t\t\tqueue->type);\n\t\treturn;\n\t}\n\n\tmana_gd_destroy_dma_region(gc, gmi->dma_region_handle);\n\tmana_gd_free_memory(gmi);\n\tkfree(queue);\n}\n\nint mana_gd_verify_vf_version(struct pci_dev *pdev)\n{\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\tstruct gdma_verify_ver_resp resp = {};\n\tstruct gdma_verify_ver_req req = {};\n\tstruct hw_channel_context *hwc;\n\tint err;\n\n\thwc = gc->hwc.driver_data;\n\tmana_gd_init_req_hdr(&req.hdr, GDMA_VERIFY_VF_DRIVER_VERSION,\n\t\t\t     sizeof(req), sizeof(resp));\n\n\treq.protocol_ver_min = GDMA_PROTOCOL_FIRST;\n\treq.protocol_ver_max = GDMA_PROTOCOL_LAST;\n\n\treq.gd_drv_cap_flags1 = GDMA_DRV_CAP_FLAGS1;\n\treq.gd_drv_cap_flags2 = GDMA_DRV_CAP_FLAGS2;\n\treq.gd_drv_cap_flags3 = GDMA_DRV_CAP_FLAGS3;\n\treq.gd_drv_cap_flags4 = GDMA_DRV_CAP_FLAGS4;\n\n\treq.drv_ver = 0;\t \n\treq.os_type = 0x10;\t \n\treq.os_ver_major = LINUX_VERSION_MAJOR;\n\treq.os_ver_minor = LINUX_VERSION_PATCHLEVEL;\n\treq.os_ver_build = LINUX_VERSION_SUBLEVEL;\n\tstrscpy(req.os_ver_str1, utsname()->sysname, sizeof(req.os_ver_str1));\n\tstrscpy(req.os_ver_str2, utsname()->release, sizeof(req.os_ver_str2));\n\tstrscpy(req.os_ver_str3, utsname()->version, sizeof(req.os_ver_str3));\n\n\terr = mana_gd_send_request(gc, sizeof(req), &req, sizeof(resp), &resp);\n\tif (err || resp.hdr.status) {\n\t\tdev_err(gc->dev, \"VfVerifyVersionOutput: %d, status=0x%x\\n\",\n\t\t\terr, resp.hdr.status);\n\t\treturn err ? err : -EPROTO;\n\t}\n\tif (resp.pf_cap_flags1 & GDMA_DRV_CAP_FLAG_1_HWC_TIMEOUT_RECONFIG) {\n\t\terr = mana_gd_query_hwc_timeout(pdev, &hwc->hwc_timeout);\n\t\tif (err) {\n\t\t\tdev_err(gc->dev, \"Failed to set the hwc timeout %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tdev_dbg(gc->dev, \"set the hwc timeout to %u\\n\", hwc->hwc_timeout);\n\t}\n\treturn 0;\n}\n\nint mana_gd_register_device(struct gdma_dev *gd)\n{\n\tstruct gdma_context *gc = gd->gdma_context;\n\tstruct gdma_register_device_resp resp = {};\n\tstruct gdma_general_req req = {};\n\tint err;\n\n\tgd->pdid = INVALID_PDID;\n\tgd->doorbell = INVALID_DOORBELL;\n\tgd->gpa_mkey = INVALID_MEM_KEY;\n\n\tmana_gd_init_req_hdr(&req.hdr, GDMA_REGISTER_DEVICE, sizeof(req),\n\t\t\t     sizeof(resp));\n\n\treq.hdr.dev_id = gd->dev_id;\n\n\terr = mana_gd_send_request(gc, sizeof(req), &req, sizeof(resp), &resp);\n\tif (err || resp.hdr.status) {\n\t\tdev_err(gc->dev, \"gdma_register_device_resp failed: %d, 0x%x\\n\",\n\t\t\terr, resp.hdr.status);\n\t\treturn err ? err : -EPROTO;\n\t}\n\n\tgd->pdid = resp.pdid;\n\tgd->gpa_mkey = resp.gpa_mkey;\n\tgd->doorbell = resp.db_id;\n\n\treturn 0;\n}\n\nint mana_gd_deregister_device(struct gdma_dev *gd)\n{\n\tstruct gdma_context *gc = gd->gdma_context;\n\tstruct gdma_general_resp resp = {};\n\tstruct gdma_general_req req = {};\n\tint err;\n\n\tif (gd->pdid == INVALID_PDID)\n\t\treturn -EINVAL;\n\n\tmana_gd_init_req_hdr(&req.hdr, GDMA_DEREGISTER_DEVICE, sizeof(req),\n\t\t\t     sizeof(resp));\n\n\treq.hdr.dev_id = gd->dev_id;\n\n\terr = mana_gd_send_request(gc, sizeof(req), &req, sizeof(resp), &resp);\n\tif (err || resp.hdr.status) {\n\t\tdev_err(gc->dev, \"Failed to deregister device: %d, 0x%x\\n\",\n\t\t\terr, resp.hdr.status);\n\t\tif (!err)\n\t\t\terr = -EPROTO;\n\t}\n\n\tgd->pdid = INVALID_PDID;\n\tgd->doorbell = INVALID_DOORBELL;\n\tgd->gpa_mkey = INVALID_MEM_KEY;\n\n\treturn err;\n}\n\nu32 mana_gd_wq_avail_space(struct gdma_queue *wq)\n{\n\tu32 used_space = (wq->head - wq->tail) * GDMA_WQE_BU_SIZE;\n\tu32 wq_size = wq->queue_size;\n\n\tWARN_ON_ONCE(used_space > wq_size);\n\n\treturn wq_size - used_space;\n}\n\nu8 *mana_gd_get_wqe_ptr(const struct gdma_queue *wq, u32 wqe_offset)\n{\n\tu32 offset = (wqe_offset * GDMA_WQE_BU_SIZE) & (wq->queue_size - 1);\n\n\tWARN_ON_ONCE((offset + GDMA_WQE_BU_SIZE) > wq->queue_size);\n\n\treturn wq->queue_mem_ptr + offset;\n}\n\nstatic u32 mana_gd_write_client_oob(const struct gdma_wqe_request *wqe_req,\n\t\t\t\t    enum gdma_queue_type q_type,\n\t\t\t\t    u32 client_oob_size, u32 sgl_data_size,\n\t\t\t\t    u8 *wqe_ptr)\n{\n\tbool oob_in_sgl = !!(wqe_req->flags & GDMA_WR_OOB_IN_SGL);\n\tbool pad_data = !!(wqe_req->flags & GDMA_WR_PAD_BY_SGE0);\n\tstruct gdma_wqe *header = (struct gdma_wqe *)wqe_ptr;\n\tu8 *ptr;\n\n\tmemset(header, 0, sizeof(struct gdma_wqe));\n\theader->num_sge = wqe_req->num_sge;\n\theader->inline_oob_size_div4 = client_oob_size / sizeof(u32);\n\n\tif (oob_in_sgl) {\n\t\tWARN_ON_ONCE(!pad_data || wqe_req->num_sge < 2);\n\n\t\theader->client_oob_in_sgl = 1;\n\n\t\tif (pad_data)\n\t\t\theader->last_vbytes = wqe_req->sgl[0].size;\n\t}\n\n\tif (q_type == GDMA_SQ)\n\t\theader->client_data_unit = wqe_req->client_data_unit;\n\n\t \n\tptr = wqe_ptr + sizeof(header);\n\n\tif (wqe_req->inline_oob_data && wqe_req->inline_oob_size > 0) {\n\t\tmemcpy(ptr, wqe_req->inline_oob_data, wqe_req->inline_oob_size);\n\n\t\tif (client_oob_size > wqe_req->inline_oob_size)\n\t\t\tmemset(ptr + wqe_req->inline_oob_size, 0,\n\t\t\t       client_oob_size - wqe_req->inline_oob_size);\n\t}\n\n\treturn sizeof(header) + client_oob_size;\n}\n\nstatic void mana_gd_write_sgl(struct gdma_queue *wq, u8 *wqe_ptr,\n\t\t\t      const struct gdma_wqe_request *wqe_req)\n{\n\tu32 sgl_size = sizeof(struct gdma_sge) * wqe_req->num_sge;\n\tconst u8 *address = (u8 *)wqe_req->sgl;\n\tu8 *base_ptr, *end_ptr;\n\tu32 size_to_end;\n\n\tbase_ptr = wq->queue_mem_ptr;\n\tend_ptr = base_ptr + wq->queue_size;\n\tsize_to_end = (u32)(end_ptr - wqe_ptr);\n\n\tif (size_to_end < sgl_size) {\n\t\tmemcpy(wqe_ptr, address, size_to_end);\n\n\t\twqe_ptr = base_ptr;\n\t\taddress += size_to_end;\n\t\tsgl_size -= size_to_end;\n\t}\n\n\tmemcpy(wqe_ptr, address, sgl_size);\n}\n\nint mana_gd_post_work_request(struct gdma_queue *wq,\n\t\t\t      const struct gdma_wqe_request *wqe_req,\n\t\t\t      struct gdma_posted_wqe_info *wqe_info)\n{\n\tu32 client_oob_size = wqe_req->inline_oob_size;\n\tstruct gdma_context *gc;\n\tu32 sgl_data_size;\n\tu32 max_wqe_size;\n\tu32 wqe_size;\n\tu8 *wqe_ptr;\n\n\tif (wqe_req->num_sge == 0)\n\t\treturn -EINVAL;\n\n\tif (wq->type == GDMA_RQ) {\n\t\tif (client_oob_size != 0)\n\t\t\treturn -EINVAL;\n\n\t\tclient_oob_size = INLINE_OOB_SMALL_SIZE;\n\n\t\tmax_wqe_size = GDMA_MAX_RQE_SIZE;\n\t} else {\n\t\tif (client_oob_size != INLINE_OOB_SMALL_SIZE &&\n\t\t    client_oob_size != INLINE_OOB_LARGE_SIZE)\n\t\t\treturn -EINVAL;\n\n\t\tmax_wqe_size = GDMA_MAX_SQE_SIZE;\n\t}\n\n\tsgl_data_size = sizeof(struct gdma_sge) * wqe_req->num_sge;\n\twqe_size = ALIGN(sizeof(struct gdma_wqe) + client_oob_size +\n\t\t\t sgl_data_size, GDMA_WQE_BU_SIZE);\n\tif (wqe_size > max_wqe_size)\n\t\treturn -EINVAL;\n\n\tif (wq->monitor_avl_buf && wqe_size > mana_gd_wq_avail_space(wq)) {\n\t\tgc = wq->gdma_dev->gdma_context;\n\t\tdev_err(gc->dev, \"unsuccessful flow control!\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (wqe_info)\n\t\twqe_info->wqe_size_in_bu = wqe_size / GDMA_WQE_BU_SIZE;\n\n\twqe_ptr = mana_gd_get_wqe_ptr(wq, wq->head);\n\twqe_ptr += mana_gd_write_client_oob(wqe_req, wq->type, client_oob_size,\n\t\t\t\t\t    sgl_data_size, wqe_ptr);\n\tif (wqe_ptr >= (u8 *)wq->queue_mem_ptr + wq->queue_size)\n\t\twqe_ptr -= wq->queue_size;\n\n\tmana_gd_write_sgl(wq, wqe_ptr, wqe_req);\n\n\twq->head += wqe_size / GDMA_WQE_BU_SIZE;\n\n\treturn 0;\n}\n\nint mana_gd_post_and_ring(struct gdma_queue *queue,\n\t\t\t  const struct gdma_wqe_request *wqe_req,\n\t\t\t  struct gdma_posted_wqe_info *wqe_info)\n{\n\tstruct gdma_context *gc = queue->gdma_dev->gdma_context;\n\tint err;\n\n\terr = mana_gd_post_work_request(queue, wqe_req, wqe_info);\n\tif (err)\n\t\treturn err;\n\n\tmana_gd_wq_ring_doorbell(gc, queue);\n\n\treturn 0;\n}\n\nstatic int mana_gd_read_cqe(struct gdma_queue *cq, struct gdma_comp *comp)\n{\n\tunsigned int num_cqe = cq->queue_size / sizeof(struct gdma_cqe);\n\tstruct gdma_cqe *cq_cqe = cq->queue_mem_ptr;\n\tu32 owner_bits, new_bits, old_bits;\n\tstruct gdma_cqe *cqe;\n\n\tcqe = &cq_cqe[cq->head % num_cqe];\n\towner_bits = cqe->cqe_info.owner_bits;\n\n\told_bits = (cq->head / num_cqe - 1) & GDMA_CQE_OWNER_MASK;\n\t \n\tif (owner_bits == old_bits)\n\t\treturn 0;\n\n\tnew_bits = (cq->head / num_cqe) & GDMA_CQE_OWNER_MASK;\n\t \n\tif (WARN_ON_ONCE(owner_bits != new_bits))\n\t\treturn -1;\n\n\t \n\trmb();\n\n\tcomp->wq_num = cqe->cqe_info.wq_num;\n\tcomp->is_sq = cqe->cqe_info.is_sq;\n\tmemcpy(comp->cqe_data, cqe->cqe_data, GDMA_COMP_DATA_SIZE);\n\n\treturn 1;\n}\n\nint mana_gd_poll_cq(struct gdma_queue *cq, struct gdma_comp *comp, int num_cqe)\n{\n\tint cqe_idx;\n\tint ret;\n\n\tfor (cqe_idx = 0; cqe_idx < num_cqe; cqe_idx++) {\n\t\tret = mana_gd_read_cqe(cq, &comp[cqe_idx]);\n\n\t\tif (ret < 0) {\n\t\t\tcq->head -= cqe_idx;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (ret == 0)\n\t\t\tbreak;\n\n\t\tcq->head++;\n\t}\n\n\treturn cqe_idx;\n}\n\nstatic irqreturn_t mana_gd_intr(int irq, void *arg)\n{\n\tstruct gdma_irq_context *gic = arg;\n\n\tif (gic->handler)\n\t\tgic->handler(gic->arg);\n\n\treturn IRQ_HANDLED;\n}\n\nint mana_gd_alloc_res_map(u32 res_avail, struct gdma_resource *r)\n{\n\tr->map = bitmap_zalloc(res_avail, GFP_KERNEL);\n\tif (!r->map)\n\t\treturn -ENOMEM;\n\n\tr->size = res_avail;\n\tspin_lock_init(&r->lock);\n\n\treturn 0;\n}\n\nvoid mana_gd_free_res_map(struct gdma_resource *r)\n{\n\tbitmap_free(r->map);\n\tr->map = NULL;\n\tr->size = 0;\n}\n\nstatic int mana_gd_setup_irqs(struct pci_dev *pdev)\n{\n\tunsigned int max_queues_per_port = num_online_cpus();\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\tstruct gdma_irq_context *gic;\n\tunsigned int max_irqs, cpu;\n\tint nvec, irq;\n\tint err, i = 0, j;\n\n\tif (max_queues_per_port > MANA_MAX_NUM_QUEUES)\n\t\tmax_queues_per_port = MANA_MAX_NUM_QUEUES;\n\n\t \n\tmax_irqs = max_queues_per_port + 1;\n\n\tnvec = pci_alloc_irq_vectors(pdev, 2, max_irqs, PCI_IRQ_MSIX);\n\tif (nvec < 0)\n\t\treturn nvec;\n\n\tgc->irq_contexts = kcalloc(nvec, sizeof(struct gdma_irq_context),\n\t\t\t\t   GFP_KERNEL);\n\tif (!gc->irq_contexts) {\n\t\terr = -ENOMEM;\n\t\tgoto free_irq_vector;\n\t}\n\n\tfor (i = 0; i < nvec; i++) {\n\t\tgic = &gc->irq_contexts[i];\n\t\tgic->handler = NULL;\n\t\tgic->arg = NULL;\n\n\t\tif (!i)\n\t\t\tsnprintf(gic->name, MANA_IRQ_NAME_SZ, \"mana_hwc@pci:%s\",\n\t\t\t\t pci_name(pdev));\n\t\telse\n\t\t\tsnprintf(gic->name, MANA_IRQ_NAME_SZ, \"mana_q%d@pci:%s\",\n\t\t\t\t i - 1, pci_name(pdev));\n\n\t\tirq = pci_irq_vector(pdev, i);\n\t\tif (irq < 0) {\n\t\t\terr = irq;\n\t\t\tgoto free_irq;\n\t\t}\n\n\t\terr = request_irq(irq, mana_gd_intr, 0, gic->name, gic);\n\t\tif (err)\n\t\t\tgoto free_irq;\n\n\t\tcpu = cpumask_local_spread(i, gc->numa_node);\n\t\tirq_set_affinity_and_hint(irq, cpumask_of(cpu));\n\t}\n\n\terr = mana_gd_alloc_res_map(nvec, &gc->msix_resource);\n\tif (err)\n\t\tgoto free_irq;\n\n\tgc->max_num_msix = nvec;\n\tgc->num_msix_usable = nvec;\n\n\treturn 0;\n\nfree_irq:\n\tfor (j = i - 1; j >= 0; j--) {\n\t\tirq = pci_irq_vector(pdev, j);\n\t\tgic = &gc->irq_contexts[j];\n\n\t\tirq_update_affinity_hint(irq, NULL);\n\t\tfree_irq(irq, gic);\n\t}\n\n\tkfree(gc->irq_contexts);\n\tgc->irq_contexts = NULL;\nfree_irq_vector:\n\tpci_free_irq_vectors(pdev);\n\treturn err;\n}\n\nstatic void mana_gd_remove_irqs(struct pci_dev *pdev)\n{\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\tstruct gdma_irq_context *gic;\n\tint irq, i;\n\n\tif (gc->max_num_msix < 1)\n\t\treturn;\n\n\tmana_gd_free_res_map(&gc->msix_resource);\n\n\tfor (i = 0; i < gc->max_num_msix; i++) {\n\t\tirq = pci_irq_vector(pdev, i);\n\t\tif (irq < 0)\n\t\t\tcontinue;\n\n\t\tgic = &gc->irq_contexts[i];\n\n\t\t \n\t\tirq_update_affinity_hint(irq, NULL);\n\t\tfree_irq(irq, gic);\n\t}\n\n\tpci_free_irq_vectors(pdev);\n\n\tgc->max_num_msix = 0;\n\tgc->num_msix_usable = 0;\n\tkfree(gc->irq_contexts);\n\tgc->irq_contexts = NULL;\n}\n\nstatic int mana_gd_setup(struct pci_dev *pdev)\n{\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\tint err;\n\n\tmana_gd_init_registers(pdev);\n\tmana_smc_init(&gc->shm_channel, gc->dev, gc->shm_base);\n\n\terr = mana_gd_setup_irqs(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = mana_hwc_create_channel(gc);\n\tif (err)\n\t\tgoto remove_irq;\n\n\terr = mana_gd_verify_vf_version(pdev);\n\tif (err)\n\t\tgoto destroy_hwc;\n\n\terr = mana_gd_query_max_resources(pdev);\n\tif (err)\n\t\tgoto destroy_hwc;\n\n\terr = mana_gd_detect_devices(pdev);\n\tif (err)\n\t\tgoto destroy_hwc;\n\n\treturn 0;\n\ndestroy_hwc:\n\tmana_hwc_destroy_channel(gc);\nremove_irq:\n\tmana_gd_remove_irqs(pdev);\n\treturn err;\n}\n\nstatic void mana_gd_cleanup(struct pci_dev *pdev)\n{\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\n\tmana_hwc_destroy_channel(gc);\n\n\tmana_gd_remove_irqs(pdev);\n}\n\nstatic bool mana_is_pf(unsigned short dev_id)\n{\n\treturn dev_id == MANA_PF_DEVICE_ID;\n}\n\nstatic int mana_gd_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct gdma_context *gc;\n\tvoid __iomem *bar0_va;\n\tint bar = 0;\n\tint err;\n\n\t \n\tBUILD_BUG_ON(2 * MAX_PORTS_IN_MANA_DEV * GDMA_EQE_SIZE > EQ_SIZE);\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn -ENXIO;\n\n\tpci_set_master(pdev);\n\n\terr = pci_request_regions(pdev, \"mana\");\n\tif (err)\n\t\tgoto disable_dev;\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err)\n\t\tgoto release_region;\n\n\terr = dma_set_max_seg_size(&pdev->dev, UINT_MAX);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to set dma device segment size\\n\");\n\t\tgoto release_region;\n\t}\n\n\terr = -ENOMEM;\n\tgc = vzalloc(sizeof(*gc));\n\tif (!gc)\n\t\tgoto release_region;\n\n\tmutex_init(&gc->eq_test_event_mutex);\n\tpci_set_drvdata(pdev, gc);\n\tgc->bar0_pa = pci_resource_start(pdev, 0);\n\n\tbar0_va = pci_iomap(pdev, bar, 0);\n\tif (!bar0_va)\n\t\tgoto free_gc;\n\n\tgc->numa_node = dev_to_node(&pdev->dev);\n\tgc->is_pf = mana_is_pf(pdev->device);\n\tgc->bar0_va = bar0_va;\n\tgc->dev = &pdev->dev;\n\n\terr = mana_gd_setup(pdev);\n\tif (err)\n\t\tgoto unmap_bar;\n\n\terr = mana_probe(&gc->mana, false);\n\tif (err)\n\t\tgoto cleanup_gd;\n\n\treturn 0;\n\ncleanup_gd:\n\tmana_gd_cleanup(pdev);\nunmap_bar:\n\tpci_iounmap(pdev, bar0_va);\nfree_gc:\n\tpci_set_drvdata(pdev, NULL);\n\tvfree(gc);\nrelease_region:\n\tpci_release_regions(pdev);\ndisable_dev:\n\tpci_disable_device(pdev);\n\tdev_err(&pdev->dev, \"gdma probe failed: err = %d\\n\", err);\n\treturn err;\n}\n\nstatic void mana_gd_remove(struct pci_dev *pdev)\n{\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\n\tmana_remove(&gc->mana, false);\n\n\tmana_gd_cleanup(pdev);\n\n\tpci_iounmap(pdev, gc->bar0_va);\n\n\tvfree(gc);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\n \nstatic int mana_gd_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\n\tmana_remove(&gc->mana, true);\n\n\tmana_gd_cleanup(pdev);\n\n\treturn 0;\n}\n\n \nstatic int mana_gd_resume(struct pci_dev *pdev)\n{\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\tint err;\n\n\terr = mana_gd_setup(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = mana_probe(&gc->mana, true);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic void mana_gd_shutdown(struct pci_dev *pdev)\n{\n\tstruct gdma_context *gc = pci_get_drvdata(pdev);\n\n\tdev_info(&pdev->dev, \"Shutdown was called\\n\");\n\n\tmana_remove(&gc->mana, true);\n\n\tmana_gd_cleanup(pdev);\n\n\tpci_disable_device(pdev);\n}\n\nstatic const struct pci_device_id mana_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MICROSOFT, MANA_PF_DEVICE_ID) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MICROSOFT, MANA_VF_DEVICE_ID) },\n\t{ }\n};\n\nstatic struct pci_driver mana_driver = {\n\t.name\t\t= \"mana\",\n\t.id_table\t= mana_id_table,\n\t.probe\t\t= mana_gd_probe,\n\t.remove\t\t= mana_gd_remove,\n\t.suspend\t= mana_gd_suspend,\n\t.resume\t\t= mana_gd_resume,\n\t.shutdown\t= mana_gd_shutdown,\n};\n\nmodule_pci_driver(mana_driver);\n\nMODULE_DEVICE_TABLE(pci, mana_id_table);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"Microsoft Azure Network Adapter driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}