{
  "module_name": "shm_channel.c",
  "hash_id": "91238c38d64f0b752e7deae87b2c7249e900b048bdb0b617c64cc2972dcd004f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microsoft/mana/shm_channel.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n\n#include <net/mana/shm_channel.h>\n\n#define PAGE_FRAME_L48_WIDTH_BYTES 6\n#define PAGE_FRAME_L48_WIDTH_BITS (PAGE_FRAME_L48_WIDTH_BYTES * 8)\n#define PAGE_FRAME_L48_MASK 0x0000FFFFFFFFFFFF\n#define PAGE_FRAME_H4_WIDTH_BITS 4\n#define VECTOR_MASK 0xFFFF\n#define SHMEM_VF_RESET_STATE ((u32)-1)\n\n#define SMC_MSG_TYPE_ESTABLISH_HWC 1\n#define SMC_MSG_TYPE_ESTABLISH_HWC_VERSION 0\n\n#define SMC_MSG_TYPE_DESTROY_HWC 2\n#define SMC_MSG_TYPE_DESTROY_HWC_VERSION 0\n\n#define SMC_MSG_DIRECTION_REQUEST 0\n#define SMC_MSG_DIRECTION_RESPONSE 1\n\n \n\n \nunion smc_proto_hdr {\n\tu32 as_uint32;\n\n\tstruct {\n\t\tu8 msg_type\t: 3;\n\t\tu8 msg_version\t: 3;\n\t\tu8 reserved_1\t: 1;\n\t\tu8 direction\t: 1;\n\n\t\tu8 status;\n\n\t\tu8 reserved_2;\n\n\t\tu8 reset_vf\t: 1;\n\t\tu8 reserved_3\t: 6;\n\t\tu8 owner_is_pf\t: 1;\n\t};\n};  \n\n#define SMC_APERTURE_BITS 256\n#define SMC_BASIC_UNIT (sizeof(u32))\n#define SMC_APERTURE_DWORDS (SMC_APERTURE_BITS / (SMC_BASIC_UNIT * 8))\n#define SMC_LAST_DWORD (SMC_APERTURE_DWORDS - 1)\n\nstatic int mana_smc_poll_register(void __iomem *base, bool reset)\n{\n\tvoid __iomem *ptr = base + SMC_LAST_DWORD * SMC_BASIC_UNIT;\n\tu32 last_dword;\n\tint i;\n\n\t \n\tfor (i = 0; i < 20 * 1000; i++)  {\n\t\tlast_dword = readl(ptr);\n\n\t\t \n\t\tif (reset && last_dword == SHMEM_VF_RESET_STATE)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (!(last_dword & BIT(31)))\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int mana_smc_read_response(struct shm_channel *sc, u32 msg_type,\n\t\t\t\t  u32 msg_version, bool reset_vf)\n{\n\tvoid __iomem *base = sc->base;\n\tunion smc_proto_hdr hdr;\n\tint err;\n\n\t \n\terr = mana_smc_poll_register(base, reset_vf);\n\tif (err)\n\t\treturn err;\n\n\thdr.as_uint32 = readl(base + SMC_LAST_DWORD * SMC_BASIC_UNIT);\n\n\tif (reset_vf && hdr.as_uint32 == SHMEM_VF_RESET_STATE)\n\t\treturn 0;\n\n\t \n\tif (hdr.msg_type != msg_type || hdr.msg_version > msg_version ||\n\t    hdr.direction != SMC_MSG_DIRECTION_RESPONSE) {\n\t\tdev_err(sc->dev, \"Wrong SMC response 0x%x, type=%d, ver=%d\\n\",\n\t\t\thdr.as_uint32, msg_type, msg_version);\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tif (hdr.status != 0) {\n\t\tdev_err(sc->dev, \"SMC operation failed: 0x%x\\n\", hdr.status);\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\nvoid mana_smc_init(struct shm_channel *sc, struct device *dev,\n\t\t   void __iomem *base)\n{\n\tsc->dev = dev;\n\tsc->base = base;\n}\n\nint mana_smc_setup_hwc(struct shm_channel *sc, bool reset_vf, u64 eq_addr,\n\t\t       u64 cq_addr, u64 rq_addr, u64 sq_addr,\n\t\t       u32 eq_msix_index)\n{\n\tunion smc_proto_hdr *hdr;\n\tu16 all_addr_h4bits = 0;\n\tu16 frame_addr_seq = 0;\n\tu64 frame_addr = 0;\n\tu8 shm_buf[32];\n\tu64 *shmem;\n\tu32 *dword;\n\tu8 *ptr;\n\tint err;\n\tint i;\n\n\t \n\terr = mana_smc_poll_register(sc->base, false);\n\tif (err) {\n\t\tdev_err(sc->dev, \"Timeout when setting up HWC: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (!PAGE_ALIGNED(eq_addr) || !PAGE_ALIGNED(cq_addr) ||\n\t    !PAGE_ALIGNED(rq_addr) || !PAGE_ALIGNED(sq_addr))\n\t\treturn -EINVAL;\n\n\tif ((eq_msix_index & VECTOR_MASK) != eq_msix_index)\n\t\treturn -EINVAL;\n\n\t \n\n\tmemset(shm_buf, 0, sizeof(shm_buf));\n\tptr = shm_buf;\n\n\t \n\tshmem = (u64 *)ptr;\n\tframe_addr = PHYS_PFN(eq_addr);\n\t*shmem = frame_addr & PAGE_FRAME_L48_MASK;\n\tall_addr_h4bits |= (frame_addr >> PAGE_FRAME_L48_WIDTH_BITS) <<\n\t\t(frame_addr_seq++ * PAGE_FRAME_H4_WIDTH_BITS);\n\tptr += PAGE_FRAME_L48_WIDTH_BYTES;\n\n\t \n\tshmem = (u64 *)ptr;\n\tframe_addr = PHYS_PFN(cq_addr);\n\t*shmem = frame_addr & PAGE_FRAME_L48_MASK;\n\tall_addr_h4bits |= (frame_addr >> PAGE_FRAME_L48_WIDTH_BITS) <<\n\t\t(frame_addr_seq++ * PAGE_FRAME_H4_WIDTH_BITS);\n\tptr += PAGE_FRAME_L48_WIDTH_BYTES;\n\n\t \n\tshmem = (u64 *)ptr;\n\tframe_addr = PHYS_PFN(rq_addr);\n\t*shmem = frame_addr & PAGE_FRAME_L48_MASK;\n\tall_addr_h4bits |= (frame_addr >> PAGE_FRAME_L48_WIDTH_BITS) <<\n\t\t(frame_addr_seq++ * PAGE_FRAME_H4_WIDTH_BITS);\n\tptr += PAGE_FRAME_L48_WIDTH_BYTES;\n\n\t \n\tshmem = (u64 *)ptr;\n\tframe_addr = PHYS_PFN(sq_addr);\n\t*shmem = frame_addr & PAGE_FRAME_L48_MASK;\n\tall_addr_h4bits |= (frame_addr >> PAGE_FRAME_L48_WIDTH_BITS) <<\n\t\t(frame_addr_seq++ * PAGE_FRAME_H4_WIDTH_BITS);\n\tptr += PAGE_FRAME_L48_WIDTH_BYTES;\n\n\t \n\t*((u16 *)ptr) = all_addr_h4bits;\n\tptr += sizeof(u16);\n\n\t \n\t*((u16 *)ptr) = (u16)eq_msix_index;\n\tptr += sizeof(u16);\n\n\t \n\t*((u32 *)ptr) = 0;\n\n\thdr = (union smc_proto_hdr *)ptr;\n\thdr->msg_type = SMC_MSG_TYPE_ESTABLISH_HWC;\n\thdr->msg_version = SMC_MSG_TYPE_ESTABLISH_HWC_VERSION;\n\thdr->direction = SMC_MSG_DIRECTION_REQUEST;\n\thdr->reset_vf = reset_vf;\n\n\t \n\tdword = (u32 *)shm_buf;\n\tfor (i = 0; i < SMC_APERTURE_DWORDS; i++)\n\t\twritel(*dword++, sc->base + i * SMC_BASIC_UNIT);\n\n\t \n\terr = mana_smc_read_response(sc, SMC_MSG_TYPE_ESTABLISH_HWC,\n\t\t\t\t     SMC_MSG_TYPE_ESTABLISH_HWC_VERSION,\n\t\t\t\t     reset_vf);\n\tif (err) {\n\t\tdev_err(sc->dev, \"Error when setting up HWC: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint mana_smc_teardown_hwc(struct shm_channel *sc, bool reset_vf)\n{\n\tunion smc_proto_hdr hdr = {};\n\tint err;\n\n\t \n\terr = mana_smc_poll_register(sc->base, false);\n\tif (err) {\n\t\tdev_err(sc->dev, \"Timeout when tearing down HWC\\n\");\n\t\treturn err;\n\t}\n\n\t \n\thdr.msg_type = SMC_MSG_TYPE_DESTROY_HWC;\n\thdr.msg_version = SMC_MSG_TYPE_DESTROY_HWC_VERSION;\n\thdr.direction = SMC_MSG_DIRECTION_REQUEST;\n\thdr.reset_vf = reset_vf;\n\n\t \n\twritel(hdr.as_uint32, sc->base + SMC_LAST_DWORD * SMC_BASIC_UNIT);\n\n\t \n\terr = mana_smc_read_response(sc, SMC_MSG_TYPE_DESTROY_HWC,\n\t\t\t\t     SMC_MSG_TYPE_DESTROY_HWC_VERSION,\n\t\t\t\t     reset_vf);\n\tif (err) {\n\t\tdev_err(sc->dev, \"Error when tearing down HWC: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}