{
  "module_name": "mana_bpf.c",
  "hash_id": "0c077fe3b222ec6d133dec7145ce1d3b8dd74de9bb0f463ffc5385529edbaee4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/microsoft/mana/mana_bpf.c",
  "human_readable_source": "\n \n\n#include <linux/inetdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/mm.h>\n#include <linux/bpf.h>\n#include <linux/bpf_trace.h>\n#include <net/xdp.h>\n\n#include <net/mana/mana.h>\n\nvoid mana_xdp_tx(struct sk_buff *skb, struct net_device *ndev)\n{\n\tu16 txq_idx = skb_get_queue_mapping(skb);\n\tstruct netdev_queue *ndevtxq;\n\tint rc;\n\n\t__skb_push(skb, ETH_HLEN);\n\n\tndevtxq = netdev_get_tx_queue(ndev, txq_idx);\n\t__netif_tx_lock(ndevtxq, smp_processor_id());\n\n\trc = mana_start_xmit(skb, ndev);\n\n\t__netif_tx_unlock(ndevtxq);\n\n\tif (dev_xmit_complete(rc))\n\t\treturn;\n\n\tdev_kfree_skb_any(skb);\n\tndev->stats.tx_dropped++;\n}\n\nstatic int mana_xdp_xmit_fm(struct net_device *ndev, struct xdp_frame *frame,\n\t\t\t    u16 q_idx)\n{\n\tstruct sk_buff *skb;\n\n\tskb = xdp_build_skb_from_frame(frame, ndev);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tskb_set_queue_mapping(skb, q_idx);\n\n\tmana_xdp_tx(skb, ndev);\n\n\treturn 0;\n}\n\nint mana_xdp_xmit(struct net_device *ndev, int n, struct xdp_frame **frames,\n\t\t  u32 flags)\n{\n\tstruct mana_port_context *apc = netdev_priv(ndev);\n\tstruct mana_stats_tx *tx_stats;\n\tint i, count = 0;\n\tu16 q_idx;\n\n\tif (unlikely(!apc->port_is_up))\n\t\treturn 0;\n\n\tq_idx = smp_processor_id() % ndev->real_num_tx_queues;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (mana_xdp_xmit_fm(ndev, frames[i], q_idx))\n\t\t\tbreak;\n\n\t\tcount++;\n\t}\n\n\ttx_stats = &apc->tx_qp[q_idx].txq.stats;\n\n\tu64_stats_update_begin(&tx_stats->syncp);\n\ttx_stats->xdp_xmit += count;\n\tu64_stats_update_end(&tx_stats->syncp);\n\n\treturn count;\n}\n\nu32 mana_run_xdp(struct net_device *ndev, struct mana_rxq *rxq,\n\t\t struct xdp_buff *xdp, void *buf_va, uint pkt_len)\n{\n\tstruct mana_stats_rx *rx_stats;\n\tstruct bpf_prog *prog;\n\tu32 act = XDP_PASS;\n\n\trcu_read_lock();\n\tprog = rcu_dereference(rxq->bpf_prog);\n\n\tif (!prog)\n\t\tgoto out;\n\n\txdp_init_buff(xdp, PAGE_SIZE, &rxq->xdp_rxq);\n\txdp_prepare_buff(xdp, buf_va, XDP_PACKET_HEADROOM, pkt_len, false);\n\n\tact = bpf_prog_run_xdp(prog, xdp);\n\n\trx_stats = &rxq->stats;\n\n\tswitch (act) {\n\tcase XDP_PASS:\n\tcase XDP_TX:\n\tcase XDP_DROP:\n\t\tbreak;\n\n\tcase XDP_REDIRECT:\n\t\trxq->xdp_rc = xdp_do_redirect(ndev, xdp, prog);\n\t\tif (!rxq->xdp_rc) {\n\t\t\trxq->xdp_flush = true;\n\n\t\t\tu64_stats_update_begin(&rx_stats->syncp);\n\t\t\trx_stats->packets++;\n\t\t\trx_stats->bytes += pkt_len;\n\t\t\trx_stats->xdp_redirect++;\n\t\t\tu64_stats_update_end(&rx_stats->syncp);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tfallthrough;\n\n\tcase XDP_ABORTED:\n\t\ttrace_xdp_exception(ndev, prog, act);\n\t\tbreak;\n\n\tdefault:\n\t\tbpf_warn_invalid_xdp_action(ndev, prog, act);\n\t}\n\nout:\n\trcu_read_unlock();\n\n\treturn act;\n}\n\nstruct bpf_prog *mana_xdp_get(struct mana_port_context *apc)\n{\n\tASSERT_RTNL();\n\n\treturn apc->bpf_prog;\n}\n\nstatic struct bpf_prog *mana_chn_xdp_get(struct mana_port_context *apc)\n{\n\treturn rtnl_dereference(apc->rxqs[0]->bpf_prog);\n}\n\n \nvoid mana_chn_setxdp(struct mana_port_context *apc, struct bpf_prog *prog)\n{\n\tstruct bpf_prog *old_prog = mana_chn_xdp_get(apc);\n\tunsigned int num_queues = apc->num_queues;\n\tint i;\n\n\tASSERT_RTNL();\n\n\tif (old_prog == prog)\n\t\treturn;\n\n\tif (prog)\n\t\tbpf_prog_add(prog, num_queues);\n\n\tfor (i = 0; i < num_queues; i++)\n\t\trcu_assign_pointer(apc->rxqs[i]->bpf_prog, prog);\n\n\tif (old_prog)\n\t\tfor (i = 0; i < num_queues; i++)\n\t\t\tbpf_prog_put(old_prog);\n}\n\nstatic int mana_xdp_set(struct net_device *ndev, struct bpf_prog *prog,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mana_port_context *apc = netdev_priv(ndev);\n\tstruct bpf_prog *old_prog;\n\tstruct gdma_context *gc;\n\n\tgc = apc->ac->gdma_dev->gdma_context;\n\n\told_prog = mana_xdp_get(apc);\n\n\tif (!old_prog && !prog)\n\t\treturn 0;\n\n\tif (prog && ndev->mtu > MANA_XDP_MTU_MAX) {\n\t\tnetdev_err(ndev, \"XDP: mtu:%u too large, mtu_max:%lu\\n\",\n\t\t\t   ndev->mtu, MANA_XDP_MTU_MAX);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"XDP: mtu too large\");\n\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tapc->bpf_prog = prog;\n\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\n\tif (apc->port_is_up)\n\t\tmana_chn_setxdp(apc, prog);\n\n\tif (prog)\n\t\tndev->max_mtu = MANA_XDP_MTU_MAX;\n\telse\n\t\tndev->max_mtu = gc->adapter_mtu - ETH_HLEN;\n\n\treturn 0;\n}\n\nint mana_bpf(struct net_device *ndev, struct netdev_bpf *bpf)\n{\n\tstruct netlink_ext_ack *extack = bpf->extack;\n\tint ret;\n\n\tswitch (bpf->command) {\n\tcase XDP_SETUP_PROG:\n\t\treturn mana_xdp_set(ndev, bpf->prog, extack);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}