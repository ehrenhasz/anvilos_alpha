{
  "module_name": "sxgbe_platform.c",
  "hash_id": "a23a02ad31ff68bb12890207a2084fd0c250257e246ad404c17be874730c37fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/samsung/sxgbe/sxgbe_platform.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/etherdevice.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_net.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/sxgbe_platform.h>\n\n#include \"sxgbe_common.h\"\n#include \"sxgbe_reg.h\"\n\n#ifdef CONFIG_OF\nstatic int sxgbe_probe_config_dt(struct platform_device *pdev,\n\t\t\t\t struct sxgbe_plat_data *plat)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct sxgbe_dma_cfg *dma_cfg;\n\tint err;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\terr = of_get_phy_mode(np, &plat->interface);\n\tif (err && err != -ENODEV)\n\t\treturn err;\n\n\tplat->bus_id = of_alias_get_id(np, \"ethernet\");\n\tif (plat->bus_id < 0)\n\t\tplat->bus_id = 0;\n\n\tplat->mdio_bus_data = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t   sizeof(*plat->mdio_bus_data),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!plat->mdio_bus_data)\n\t\treturn -ENOMEM;\n\n\tdma_cfg = devm_kzalloc(&pdev->dev, sizeof(*dma_cfg), GFP_KERNEL);\n\tif (!dma_cfg)\n\t\treturn -ENOMEM;\n\n\tplat->dma_cfg = dma_cfg;\n\tof_property_read_u32(np, \"samsung,pbl\", &dma_cfg->pbl);\n\tif (of_property_read_u32(np, \"samsung,burst-map\", &dma_cfg->burst_map) == 0)\n\t\tdma_cfg->fixed_burst = true;\n\n\treturn 0;\n}\n#else\nstatic int sxgbe_probe_config_dt(struct platform_device *pdev,\n\t\t\t\t struct sxgbe_plat_data *plat)\n{\n\treturn -ENOSYS;\n}\n#endif  \n\n \nstatic int sxgbe_platform_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tint i, chan;\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *addr;\n\tstruct sxgbe_priv_data *priv = NULL;\n\tstruct sxgbe_plat_data *plat_dat = NULL;\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct device_node *node = dev->of_node;\n\n\t \n\taddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(addr))\n\t\treturn PTR_ERR(addr);\n\n\tif (pdev->dev.of_node) {\n\t\tplat_dat = devm_kzalloc(&pdev->dev,\n\t\t\t\t\tsizeof(struct sxgbe_plat_data),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!plat_dat)\n\t\t\treturn  -ENOMEM;\n\n\t\tret = sxgbe_probe_config_dt(pdev, plat_dat);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: main dt probe failed\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpriv = sxgbe_drv_probe(&(pdev->dev), plat_dat, addr);\n\tif (!priv) {\n\t\tpr_err(\"%s: main driver probe failed\\n\", __func__);\n\t\tgoto err_out;\n\t}\n\n\t \n\tpriv->irq  = irq_of_parse_and_map(node, 0);\n\tif (priv->irq <= 0) {\n\t\tdev_err(dev, \"sxgbe common irq parsing failed\\n\");\n\t\tgoto err_drv_remove;\n\t}\n\n\t \n\tof_get_ethdev_address(node, priv->dev);\n\n\t \n\tfor (i = 0, chan = 1; i < SXGBE_TX_QUEUES; i++) {\n\t\tpriv->txq[i]->irq_no = irq_of_parse_and_map(node, chan++);\n\t\tif (priv->txq[i]->irq_no <= 0) {\n\t\t\tdev_err(dev, \"sxgbe tx irq parsing failed\\n\");\n\t\t\tgoto err_tx_irq_unmap;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SXGBE_RX_QUEUES; i++) {\n\t\tpriv->rxq[i]->irq_no = irq_of_parse_and_map(node, chan++);\n\t\tif (priv->rxq[i]->irq_no <= 0) {\n\t\t\tdev_err(dev, \"sxgbe rx irq parsing failed\\n\");\n\t\t\tgoto err_rx_irq_unmap;\n\t\t}\n\t}\n\n\tpriv->lpi_irq = irq_of_parse_and_map(node, chan);\n\tif (priv->lpi_irq <= 0) {\n\t\tdev_err(dev, \"sxgbe lpi irq parsing failed\\n\");\n\t\tgoto err_rx_irq_unmap;\n\t}\n\n\tplatform_set_drvdata(pdev, priv->dev);\n\n\tpr_debug(\"platform driver registration completed\\n\");\n\n\treturn 0;\n\nerr_rx_irq_unmap:\n\twhile (i--)\n\t\tirq_dispose_mapping(priv->rxq[i]->irq_no);\n\ti = SXGBE_TX_QUEUES;\nerr_tx_irq_unmap:\n\twhile (i--)\n\t\tirq_dispose_mapping(priv->txq[i]->irq_no);\n\tirq_dispose_mapping(priv->irq);\nerr_drv_remove:\n\tsxgbe_drv_remove(ndev);\nerr_out:\n\treturn -ENODEV;\n}\n\n \nstatic int sxgbe_platform_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\n\tsxgbe_drv_remove(ndev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int sxgbe_platform_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\n\treturn sxgbe_suspend(ndev);\n}\n\nstatic int sxgbe_platform_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\n\treturn sxgbe_resume(ndev);\n}\n\nstatic int sxgbe_platform_freeze(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\n\treturn sxgbe_freeze(ndev);\n}\n\nstatic int sxgbe_platform_restore(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\n\treturn sxgbe_restore(ndev);\n}\n\nstatic const struct dev_pm_ops sxgbe_platform_pm_ops = {\n\t.suspend\t= sxgbe_platform_suspend,\n\t.resume\t\t= sxgbe_platform_resume,\n\t.freeze\t\t= sxgbe_platform_freeze,\n\t.thaw\t\t= sxgbe_platform_restore,\n\t.restore\t= sxgbe_platform_restore,\n};\n#else\nstatic const struct dev_pm_ops sxgbe_platform_pm_ops;\n#endif  \n\nstatic const struct of_device_id sxgbe_dt_ids[] = {\n\t{ .compatible = \"samsung,sxgbe-v2.0a\"},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sxgbe_dt_ids);\n\nstatic struct platform_driver sxgbe_platform_driver = {\n\t.probe\t= sxgbe_platform_probe,\n\t.remove\t= sxgbe_platform_remove,\n\t.driver\t= {\n\t\t.name\t\t= SXGBE_RESOURCE_NAME,\n\t\t.pm\t\t= &sxgbe_platform_pm_ops,\n\t\t.of_match_table\t= sxgbe_dt_ids,\n\t},\n};\n\nint sxgbe_register_platform(void)\n{\n\tint err;\n\n\terr = platform_driver_register(&sxgbe_platform_driver);\n\tif (err)\n\t\tpr_err(\"failed to register the platform driver\\n\");\n\n\treturn err;\n}\n\nvoid sxgbe_unregister_platform(void)\n{\n\tplatform_driver_unregister(&sxgbe_platform_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}