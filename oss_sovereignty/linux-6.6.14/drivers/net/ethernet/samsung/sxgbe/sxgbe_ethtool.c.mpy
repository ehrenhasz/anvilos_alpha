{
  "module_name": "sxgbe_ethtool.c",
  "hash_id": "e83fb06048d58592c8b2a8e4067d72260be6482f8b1a5f3aa14fad242a89400f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/samsung/sxgbe/sxgbe_ethtool.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/net_tstamp.h>\n#include <linux/phy.h>\n#include <linux/ptp_clock_kernel.h>\n\n#include \"sxgbe_common.h\"\n#include \"sxgbe_reg.h\"\n#include \"sxgbe_dma.h\"\n\nstruct sxgbe_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\n#define SXGBE_STAT(m)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t#m,\t\t\t\t\t\t\t\\\n\tsizeof_field(struct sxgbe_extra_stats, m),\t\t\\\n\toffsetof(struct sxgbe_priv_data, xstats.m)\t\t\\\n}\n\nstatic const struct sxgbe_stats sxgbe_gstrings_stats[] = {\n\t \n\tSXGBE_STAT(tx_process_stopped_irq),\n\tSXGBE_STAT(tx_ctxt_desc_err),\n\tSXGBE_STAT(tx_threshold),\n\tSXGBE_STAT(rx_threshold),\n\tSXGBE_STAT(tx_pkt_n),\n\tSXGBE_STAT(rx_pkt_n),\n\tSXGBE_STAT(normal_irq_n),\n\tSXGBE_STAT(tx_normal_irq_n),\n\tSXGBE_STAT(rx_normal_irq_n),\n\tSXGBE_STAT(napi_poll),\n\tSXGBE_STAT(tx_clean),\n\tSXGBE_STAT(tx_reset_ic_bit),\n\tSXGBE_STAT(rx_process_stopped_irq),\n\tSXGBE_STAT(rx_underflow_irq),\n\n\t \n\tSXGBE_STAT(fatal_bus_error_irq),\n\tSXGBE_STAT(tx_read_transfer_err),\n\tSXGBE_STAT(tx_write_transfer_err),\n\tSXGBE_STAT(tx_desc_access_err),\n\tSXGBE_STAT(tx_buffer_access_err),\n\tSXGBE_STAT(tx_data_transfer_err),\n\tSXGBE_STAT(rx_read_transfer_err),\n\tSXGBE_STAT(rx_write_transfer_err),\n\tSXGBE_STAT(rx_desc_access_err),\n\tSXGBE_STAT(rx_buffer_access_err),\n\tSXGBE_STAT(rx_data_transfer_err),\n\n\t \n\tSXGBE_STAT(tx_lpi_entry_n),\n\tSXGBE_STAT(tx_lpi_exit_n),\n\tSXGBE_STAT(rx_lpi_entry_n),\n\tSXGBE_STAT(rx_lpi_exit_n),\n\tSXGBE_STAT(eee_wakeup_error_n),\n\n\t \n\t \n\tSXGBE_STAT(rx_code_gmii_err),\n\tSXGBE_STAT(rx_watchdog_err),\n\tSXGBE_STAT(rx_crc_err),\n\tSXGBE_STAT(rx_gaint_pkt_err),\n\tSXGBE_STAT(ip_hdr_err),\n\tSXGBE_STAT(ip_payload_err),\n\tSXGBE_STAT(overflow_error),\n\n\t \n\tSXGBE_STAT(len_pkt),\n\tSXGBE_STAT(mac_ctl_pkt),\n\tSXGBE_STAT(dcb_ctl_pkt),\n\tSXGBE_STAT(arp_pkt),\n\tSXGBE_STAT(oam_pkt),\n\tSXGBE_STAT(untag_okt),\n\tSXGBE_STAT(other_pkt),\n\tSXGBE_STAT(svlan_tag_pkt),\n\tSXGBE_STAT(cvlan_tag_pkt),\n\tSXGBE_STAT(dvlan_ocvlan_icvlan_pkt),\n\tSXGBE_STAT(dvlan_osvlan_isvlan_pkt),\n\tSXGBE_STAT(dvlan_osvlan_icvlan_pkt),\n\tSXGBE_STAT(dvan_ocvlan_icvlan_pkt),\n\n\t \n\tSXGBE_STAT(not_ip_pkt),\n\tSXGBE_STAT(ip4_tcp_pkt),\n\tSXGBE_STAT(ip4_udp_pkt),\n\tSXGBE_STAT(ip4_icmp_pkt),\n\tSXGBE_STAT(ip4_unknown_pkt),\n\tSXGBE_STAT(ip6_tcp_pkt),\n\tSXGBE_STAT(ip6_udp_pkt),\n\tSXGBE_STAT(ip6_icmp_pkt),\n\tSXGBE_STAT(ip6_unknown_pkt),\n\n\t \n\tSXGBE_STAT(vlan_filter_match),\n\tSXGBE_STAT(sa_filter_fail),\n\tSXGBE_STAT(da_filter_fail),\n\tSXGBE_STAT(hash_filter_pass),\n\tSXGBE_STAT(l3_filter_match),\n\tSXGBE_STAT(l4_filter_match),\n\n\t \n\tSXGBE_STAT(timestamp_dropped),\n\tSXGBE_STAT(rx_msg_type_no_ptp),\n\tSXGBE_STAT(rx_ptp_type_sync),\n\tSXGBE_STAT(rx_ptp_type_follow_up),\n\tSXGBE_STAT(rx_ptp_type_delay_req),\n\tSXGBE_STAT(rx_ptp_type_delay_resp),\n\tSXGBE_STAT(rx_ptp_type_pdelay_req),\n\tSXGBE_STAT(rx_ptp_type_pdelay_resp),\n\tSXGBE_STAT(rx_ptp_type_pdelay_follow_up),\n\tSXGBE_STAT(rx_ptp_announce),\n\tSXGBE_STAT(rx_ptp_mgmt),\n\tSXGBE_STAT(rx_ptp_signal),\n\tSXGBE_STAT(rx_ptp_resv_msg_type),\n};\n#define SXGBE_STATS_LEN ARRAY_SIZE(sxgbe_gstrings_stats)\n\nstatic int sxgbe_get_eee(struct net_device *dev,\n\t\t\t struct ethtool_eee *edata)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\n\tif (!priv->hw_cap.eee)\n\t\treturn -EOPNOTSUPP;\n\n\tedata->eee_enabled = priv->eee_enabled;\n\tedata->eee_active = priv->eee_active;\n\tedata->tx_lpi_timer = priv->tx_lpi_timer;\n\n\treturn phy_ethtool_get_eee(dev->phydev, edata);\n}\n\nstatic int sxgbe_set_eee(struct net_device *dev,\n\t\t\t struct ethtool_eee *edata)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\n\tpriv->eee_enabled = edata->eee_enabled;\n\n\tif (!priv->eee_enabled) {\n\t\tsxgbe_disable_eee_mode(priv);\n\t} else {\n\t\t \n\t\tpriv->eee_enabled = sxgbe_eee_init(priv);\n\t\tif (!priv->eee_enabled)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tpriv->tx_lpi_timer = edata->tx_lpi_timer;\n\t}\n\n\treturn phy_ethtool_set_eee(dev->phydev, edata);\n}\n\nstatic void sxgbe_getdrvinfo(struct net_device *dev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n}\n\nstatic u32 sxgbe_getmsglevel(struct net_device *dev)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\treturn priv->msg_enable;\n}\n\nstatic void sxgbe_setmsglevel(struct net_device *dev, u32 level)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\tpriv->msg_enable = level;\n}\n\nstatic void sxgbe_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tint i;\n\tu8 *p = data;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < SXGBE_STATS_LEN; i++) {\n\t\t\tmemcpy(p, sxgbe_gstrings_stats[i].stat_string,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nstatic int sxgbe_get_sset_count(struct net_device *netdev, int sset)\n{\n\tint len;\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\tlen = SXGBE_STATS_LEN;\n\t\treturn len;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void sxgbe_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t    struct ethtool_stats *dummy, u64 *data)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\tint i;\n\tchar *p;\n\n\tif (priv->eee_enabled) {\n\t\tint val = phy_get_eee_err(dev->phydev);\n\n\t\tif (val)\n\t\t\tpriv->xstats.eee_wakeup_error_n = val;\n\t}\n\n\tfor (i = 0; i < SXGBE_STATS_LEN; i++) {\n\t\tp = (char *)priv + sxgbe_gstrings_stats[i].stat_offset;\n\t\tdata[i] = (sxgbe_gstrings_stats[i].sizeof_stat == sizeof(u64))\n\t\t\t? (*(u64 *)p) : (*(u32 *)p);\n\t}\n}\n\nstatic void sxgbe_get_channels(struct net_device *dev,\n\t\t\t       struct ethtool_channels *channel)\n{\n\tchannel->max_rx = SXGBE_MAX_RX_CHANNELS;\n\tchannel->max_tx = SXGBE_MAX_TX_CHANNELS;\n\tchannel->rx_count = SXGBE_RX_QUEUES;\n\tchannel->tx_count = SXGBE_TX_QUEUES;\n}\n\nstatic u32 sxgbe_riwt2usec(u32 riwt, struct sxgbe_priv_data *priv)\n{\n\tunsigned long clk = clk_get_rate(priv->sxgbe_clk);\n\n\tif (!clk)\n\t\treturn 0;\n\n\treturn (riwt * 256) / (clk / 1000000);\n}\n\nstatic u32 sxgbe_usec2riwt(u32 usec, struct sxgbe_priv_data *priv)\n{\n\tunsigned long clk = clk_get_rate(priv->sxgbe_clk);\n\n\tif (!clk)\n\t\treturn 0;\n\n\treturn (usec * (clk / 1000000)) / 256;\n}\n\nstatic int sxgbe_get_coalesce(struct net_device *dev,\n\t\t\t      struct ethtool_coalesce *ec,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\n\tif (priv->use_riwt)\n\t\tec->rx_coalesce_usecs = sxgbe_riwt2usec(priv->rx_riwt, priv);\n\n\treturn 0;\n}\n\nstatic int sxgbe_set_coalesce(struct net_device *dev,\n\t\t\t      struct ethtool_coalesce *ec,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\tunsigned int rx_riwt;\n\n\tif (!ec->rx_coalesce_usecs)\n\t\treturn -EINVAL;\n\n\trx_riwt = sxgbe_usec2riwt(ec->rx_coalesce_usecs, priv);\n\n\tif ((rx_riwt > SXGBE_MAX_DMA_RIWT) || (rx_riwt < SXGBE_MIN_DMA_RIWT))\n\t\treturn -EINVAL;\n\telse if (!priv->use_riwt)\n\t\treturn -EOPNOTSUPP;\n\n\tpriv->rx_riwt = rx_riwt;\n\tpriv->hw->dma->rx_watchdog(priv->ioaddr, priv->rx_riwt);\n\n\treturn 0;\n}\n\nstatic int sxgbe_get_rss_hash_opts(struct sxgbe_priv_data *priv,\n\t\t\t\t   struct ethtool_rxnfc *cmd)\n{\n\tcmd->data = 0;\n\n\t \n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase IPV4_FLOW:\n\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase SCTP_V6_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase IPV6_FLOW:\n\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sxgbe_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\n\t\t\t   u32 *rule_locs)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXFH:\n\t\tret = sxgbe_get_rss_hash_opts(priv, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int sxgbe_set_rss_hash_opt(struct sxgbe_priv_data *priv,\n\t\t\t\t  struct ethtool_rxnfc *cmd)\n{\n\tu32 reg_val = 0;\n\n\t \n\tif (cmd->data & ~(RXH_IP_SRC | RXH_IP_DST |\n\t\t\t  RXH_L4_B_0_1 | RXH_L4_B_2_3))\n\t\treturn -EINVAL;\n\n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\tif (!(cmd->data & RXH_IP_SRC) ||\n\t\t    !(cmd->data & RXH_IP_DST) ||\n\t\t    !(cmd->data & RXH_L4_B_0_1) ||\n\t\t    !(cmd->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\treg_val = SXGBE_CORE_RSS_CTL_TCP4TE;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\tcase UDP_V6_FLOW:\n\t\tif (!(cmd->data & RXH_IP_SRC) ||\n\t\t    !(cmd->data & RXH_IP_DST) ||\n\t\t    !(cmd->data & RXH_L4_B_0_1) ||\n\t\t    !(cmd->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\treg_val = SXGBE_CORE_RSS_CTL_UDP4TE;\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase IPV4_FLOW:\n\tcase IPV6_FLOW:\n\t\tif (!(cmd->data & RXH_IP_SRC) ||\n\t\t    !(cmd->data & RXH_IP_DST) ||\n\t\t    (cmd->data & RXH_L4_B_0_1) ||\n\t\t    (cmd->data & RXH_L4_B_2_3))\n\t\t\treturn -EINVAL;\n\t\treg_val = SXGBE_CORE_RSS_CTL_IP2TE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treg_val |= readl(priv->ioaddr + SXGBE_CORE_RSS_CTL_REG);\n\twritel(reg_val, priv->ioaddr + SXGBE_CORE_RSS_CTL_REG);\n\treadl(priv->ioaddr + SXGBE_CORE_RSS_CTL_REG);\n\n\treturn 0;\n}\n\nstatic int sxgbe_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\tret = sxgbe_set_rss_hash_opt(priv, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void sxgbe_get_regs(struct net_device *dev,\n\t\t\t   struct ethtool_regs *regs, void *space)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\tu32 *reg_space = (u32 *)space;\n\tint reg_offset;\n\tint reg_ix = 0;\n\tvoid __iomem *ioaddr = priv->ioaddr;\n\n\tmemset(reg_space, 0x0, REG_SPACE_SIZE);\n\n\t \n\tfor (reg_offset = START_MAC_REG_OFFSET;\n\t     reg_offset <= MAX_MAC_REG_OFFSET; reg_offset += 4) {\n\t\treg_space[reg_ix] = readl(ioaddr + reg_offset);\n\t\treg_ix++;\n\t}\n\n\t \n\tfor (reg_offset = START_MTL_REG_OFFSET;\n\t     reg_offset <= MAX_MTL_REG_OFFSET; reg_offset += 4) {\n\t\treg_space[reg_ix] = readl(ioaddr + reg_offset);\n\t\treg_ix++;\n\t}\n\n\t \n\tfor (reg_offset = START_DMA_REG_OFFSET;\n\t     reg_offset <= MAX_DMA_REG_OFFSET; reg_offset += 4) {\n\t\treg_space[reg_ix] = readl(ioaddr + reg_offset);\n\t\treg_ix++;\n\t}\n\n\tBUG_ON(reg_ix * 4 > REG_SPACE_SIZE);\n}\n\nstatic int sxgbe_get_regs_len(struct net_device *dev)\n{\n\treturn REG_SPACE_SIZE;\n}\n\nstatic const struct ethtool_ops sxgbe_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS,\n\t.get_drvinfo = sxgbe_getdrvinfo,\n\t.get_msglevel = sxgbe_getmsglevel,\n\t.set_msglevel = sxgbe_setmsglevel,\n\t.get_link = ethtool_op_get_link,\n\t.get_strings = sxgbe_get_strings,\n\t.get_ethtool_stats = sxgbe_get_ethtool_stats,\n\t.get_sset_count = sxgbe_get_sset_count,\n\t.get_channels = sxgbe_get_channels,\n\t.get_coalesce = sxgbe_get_coalesce,\n\t.set_coalesce = sxgbe_set_coalesce,\n\t.get_rxnfc = sxgbe_get_rxnfc,\n\t.set_rxnfc = sxgbe_set_rxnfc,\n\t.get_regs = sxgbe_get_regs,\n\t.get_regs_len = sxgbe_get_regs_len,\n\t.get_eee = sxgbe_get_eee,\n\t.set_eee = sxgbe_set_eee,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\nvoid sxgbe_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &sxgbe_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}