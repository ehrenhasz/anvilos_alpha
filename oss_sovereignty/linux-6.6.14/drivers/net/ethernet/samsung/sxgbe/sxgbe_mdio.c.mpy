{
  "module_name": "sxgbe_mdio.c",
  "hash_id": "946af0b93d0190e2417c191d22a357acd66c87f067153673b7142b24dbee3261",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/samsung/sxgbe/sxgbe_mdio.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/io.h>\n#include <linux/mii.h>\n#include <linux/netdevice.h>\n#include <linux/platform_device.h>\n#include <linux/phy.h>\n#include <linux/slab.h>\n#include <linux/sxgbe_platform.h>\n\n#include \"sxgbe_common.h\"\n#include \"sxgbe_reg.h\"\n\n#define SXGBE_SMA_WRITE_CMD\t0x01  \n#define SXGBE_SMA_PREAD_CMD\t0x02  \n#define SXGBE_SMA_READ_CMD\t0x03  \n#define SXGBE_SMA_SKIP_ADDRFRM\t0x00040000  \n#define SXGBE_MII_BUSY\t\t0x00400000  \n\nstatic int sxgbe_mdio_busy_wait(void __iomem *ioaddr, unsigned int mii_data)\n{\n\tunsigned long fin_time = jiffies + 3 * HZ;  \n\n\twhile (!time_after(jiffies, fin_time)) {\n\t\tif (!(readl(ioaddr + mii_data) & SXGBE_MII_BUSY))\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic void sxgbe_mdio_ctrl_data(struct sxgbe_priv_data *sp, u32 cmd,\n\t\t\t\t u16 phydata)\n{\n\tu32 reg = phydata;\n\n\treg |= (cmd << 16) | SXGBE_SMA_SKIP_ADDRFRM |\n\t       ((sp->clk_csr & 0x7) << 19) | SXGBE_MII_BUSY;\n\twritel(reg, sp->ioaddr + sp->hw->mii.data);\n}\n\nstatic void sxgbe_mdio_c45(struct sxgbe_priv_data *sp, u32 cmd, int phyaddr,\n\t\t\t   int devad, int phyreg, u16 phydata)\n{\n\tu32 reg;\n\n\t \n\treg = (devad & 0x1f) << 21;\n\treg |= (phyaddr << 16) | (phyreg & 0xffff);\n\twritel(reg, sp->ioaddr + sp->hw->mii.addr);\n\n\tsxgbe_mdio_ctrl_data(sp, cmd, phydata);\n}\n\nstatic void sxgbe_mdio_c22(struct sxgbe_priv_data *sp, u32 cmd, int phyaddr,\n\t\t\t   int phyreg, u16 phydata)\n{\n\tu32 reg;\n\n\twritel(1 << phyaddr, sp->ioaddr + SXGBE_MDIO_CLAUSE22_PORT_REG);\n\n\t \n\treg = (phyaddr << 16) | (phyreg & 0x1f);\n\twritel(reg, sp->ioaddr + sp->hw->mii.addr);\n\n\tsxgbe_mdio_ctrl_data(sp, cmd, phydata);\n}\n\nstatic int sxgbe_mdio_access_c22(struct sxgbe_priv_data *sp, u32 cmd,\n\t\t\t\t int phyaddr, int phyreg, u16 phydata)\n{\n\tconst struct mii_regs *mii = &sp->hw->mii;\n\tint rc;\n\n\trc = sxgbe_mdio_busy_wait(sp->ioaddr, mii->data);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (phyaddr >= 4)\n\t\treturn -ENODEV;\n\n\tsxgbe_mdio_c22(sp, cmd, phyaddr, phyreg, phydata);\n\n\treturn sxgbe_mdio_busy_wait(sp->ioaddr, mii->data);\n}\n\nstatic int sxgbe_mdio_access_c45(struct sxgbe_priv_data *sp, u32 cmd,\n\t\t\t\t int phyaddr, int devad, int phyreg,\n\t\t\t\t u16 phydata)\n{\n\tconst struct mii_regs *mii = &sp->hw->mii;\n\tint rc;\n\n\trc = sxgbe_mdio_busy_wait(sp->ioaddr, mii->data);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tsxgbe_mdio_c45(sp, cmd, phyaddr, devad, phyreg, phydata);\n\n\treturn sxgbe_mdio_busy_wait(sp->ioaddr, mii->data);\n}\n\n \nstatic int sxgbe_mdio_read_c22(struct mii_bus *bus, int phyaddr, int phyreg)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct sxgbe_priv_data *priv = netdev_priv(ndev);\n\tint rc;\n\n\trc = sxgbe_mdio_access_c22(priv, SXGBE_SMA_READ_CMD, phyaddr,\n\t\t\t\t   phyreg, 0);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn readl(priv->ioaddr + priv->hw->mii.data) & 0xffff;\n}\n\n \nstatic int sxgbe_mdio_read_c45(struct mii_bus *bus, int phyaddr, int devad,\n\t\t\t       int phyreg)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct sxgbe_priv_data *priv = netdev_priv(ndev);\n\tint rc;\n\n\trc = sxgbe_mdio_access_c45(priv, SXGBE_SMA_READ_CMD, phyaddr,\n\t\t\t\t   devad, phyreg, 0);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn readl(priv->ioaddr + priv->hw->mii.data) & 0xffff;\n}\n\n \nstatic int sxgbe_mdio_write_c22(struct mii_bus *bus, int phyaddr, int phyreg,\n\t\t\t\tu16 phydata)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct sxgbe_priv_data *priv = netdev_priv(ndev);\n\n\treturn sxgbe_mdio_access_c22(priv, SXGBE_SMA_WRITE_CMD, phyaddr, phyreg,\n\t\t\t\t     phydata);\n}\n\n \nstatic int sxgbe_mdio_write_c45(struct mii_bus *bus, int phyaddr, int devad,\n\t\t\t\tint phyreg, u16 phydata)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct sxgbe_priv_data *priv = netdev_priv(ndev);\n\n\treturn sxgbe_mdio_access_c45(priv, SXGBE_SMA_WRITE_CMD, phyaddr,\n\t\t\t\t     devad, phyreg, phydata);\n}\n\nint sxgbe_mdio_register(struct net_device *ndev)\n{\n\tstruct mii_bus *mdio_bus;\n\tstruct sxgbe_priv_data *priv = netdev_priv(ndev);\n\tstruct sxgbe_mdio_bus_data *mdio_data = priv->plat->mdio_bus_data;\n\tint err, phy_addr;\n\tint *irqlist;\n\tbool phy_found = false;\n\tbool act;\n\n\t \n\tmdio_bus = mdiobus_alloc();\n\tif (!mdio_bus) {\n\t\tnetdev_err(ndev, \"%s: mii bus allocation failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (mdio_data->irqs)\n\t\tirqlist = mdio_data->irqs;\n\telse\n\t\tirqlist = priv->mii_irq;\n\n\t \n\tmdio_bus->name = \"sxgbe\";\n\tmdio_bus->read = sxgbe_mdio_read_c22;\n\tmdio_bus->write = sxgbe_mdio_write_c22;\n\tmdio_bus->read_c45 = sxgbe_mdio_read_c45;\n\tmdio_bus->write_c45 = sxgbe_mdio_write_c45;\n\tsnprintf(mdio_bus->id, MII_BUS_ID_SIZE, \"%s-%x\",\n\t\t mdio_bus->name, priv->plat->bus_id);\n\tmdio_bus->priv = ndev;\n\tmdio_bus->phy_mask = mdio_data->phy_mask;\n\tmdio_bus->parent = priv->device;\n\n\t \n\terr = mdiobus_register(mdio_bus);\n\tif (err != 0) {\n\t\tnetdev_err(ndev, \"mdiobus register failed\\n\");\n\t\tgoto mdiobus_err;\n\t}\n\n\tfor (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {\n\t\tstruct phy_device *phy = mdiobus_get_phy(mdio_bus, phy_addr);\n\n\t\tif (phy) {\n\t\t\tchar irq_num[4];\n\t\t\tchar *irq_str;\n\t\t\t \n\t\t\tif ((mdio_data->irqs == NULL) &&\n\t\t\t    (mdio_data->probed_phy_irq > 0)) {\n\t\t\t\tirqlist[phy_addr] = mdio_data->probed_phy_irq;\n\t\t\t\tphy->irq = mdio_data->probed_phy_irq;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (priv->plat->phy_addr == -1)\n\t\t\t\tpriv->plat->phy_addr = phy_addr;\n\n\t\t\tact = (priv->plat->phy_addr == phy_addr);\n\t\t\tswitch (phy->irq) {\n\t\t\tcase PHY_POLL:\n\t\t\t\tirq_str = \"POLL\";\n\t\t\t\tbreak;\n\t\t\tcase PHY_MAC_INTERRUPT:\n\t\t\t\tirq_str = \"MAC\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf(irq_num, \"%d\", phy->irq);\n\t\t\t\tirq_str = irq_num;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnetdev_info(ndev, \"PHY ID %08x at %d IRQ %s (%s)%s\\n\",\n\t\t\t\t    phy->phy_id, phy_addr, irq_str,\n\t\t\t\t    phydev_name(phy), act ? \" active\" : \"\");\n\t\t\tphy_found = true;\n\t\t}\n\t}\n\n\tif (!phy_found) {\n\t\tnetdev_err(ndev, \"PHY not found\\n\");\n\t\tgoto phyfound_err;\n\t}\n\n\tpriv->mii = mdio_bus;\n\n\treturn 0;\n\nphyfound_err:\n\terr = -ENODEV;\n\tmdiobus_unregister(mdio_bus);\nmdiobus_err:\n\tmdiobus_free(mdio_bus);\n\treturn err;\n}\n\nint sxgbe_mdio_unregister(struct net_device *ndev)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(ndev);\n\n\tif (!priv->mii)\n\t\treturn 0;\n\n\tmdiobus_unregister(priv->mii);\n\tpriv->mii->priv = NULL;\n\tmdiobus_free(priv->mii);\n\tpriv->mii = NULL;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}