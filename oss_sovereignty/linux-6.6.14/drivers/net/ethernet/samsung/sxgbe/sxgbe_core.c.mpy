{
  "module_name": "sxgbe_core.c",
  "hash_id": "b61f6721c955863a4e1a909bef7532d56ee02efeda531978bdfd3e8255e454e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/samsung/sxgbe/sxgbe_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/netdevice.h>\n#include <linux/phy.h>\n\n#include \"sxgbe_common.h\"\n#include \"sxgbe_reg.h\"\n\n \nstatic void sxgbe_core_init(void __iomem *ioaddr)\n{\n\tu32 regval;\n\n\t \n\tregval = readl(ioaddr + SXGBE_CORE_TX_CONFIG_REG);\n\t \n\tregval |= SXGBE_TX_JABBER_DISABLE;\n\twritel(regval, ioaddr + SXGBE_CORE_TX_CONFIG_REG);\n\n\t \n\tregval = readl(ioaddr + SXGBE_CORE_RX_CONFIG_REG);\n\t \n\tregval |= SXGBE_RX_JUMBPKT_ENABLE | SXGBE_RX_ACS_ENABLE;\n\twritel(regval, ioaddr + SXGBE_CORE_RX_CONFIG_REG);\n}\n\n \nstatic void sxgbe_core_dump_regs(void __iomem *ioaddr)\n{\n}\n\nstatic int sxgbe_get_lpi_status(void __iomem *ioaddr, const u32 irq_status)\n{\n\tint status = 0;\n\tint lpi_status;\n\n\t \n\tlpi_status = readl(ioaddr + SXGBE_CORE_LPI_CTRL_STATUS);\n\n\tif (lpi_status & LPI_CTRL_STATUS_TLPIEN)\n\t\tstatus |= TX_ENTRY_LPI_MODE;\n\tif (lpi_status & LPI_CTRL_STATUS_TLPIEX)\n\t\tstatus |= TX_EXIT_LPI_MODE;\n\tif (lpi_status & LPI_CTRL_STATUS_RLPIEN)\n\t\tstatus |= RX_ENTRY_LPI_MODE;\n\tif (lpi_status & LPI_CTRL_STATUS_RLPIEX)\n\t\tstatus |= RX_EXIT_LPI_MODE;\n\n\treturn status;\n}\n\n \nstatic int sxgbe_core_host_irq_status(void __iomem *ioaddr,\n\t\t\t\t      struct sxgbe_extra_stats *x)\n{\n\tint irq_status, status = 0;\n\n\tirq_status = readl(ioaddr + SXGBE_CORE_INT_STATUS_REG);\n\n\tif (unlikely(irq_status & LPI_INT_STATUS))\n\t\tstatus |= sxgbe_get_lpi_status(ioaddr, irq_status);\n\n\treturn status;\n}\n\n \nstatic void sxgbe_core_pmt(void __iomem *ioaddr, unsigned long mode)\n{\n}\n\n \nstatic void sxgbe_core_set_umac_addr(void __iomem *ioaddr,\n\t\t\t\t     const unsigned char *addr,\n\t\t\t\t     unsigned int reg_n)\n{\n\tu32 high_word, low_word;\n\n\thigh_word = (addr[5] << 8) | (addr[4]);\n\tlow_word = (addr[3] << 24) | (addr[2] << 16) |\n\t\t   (addr[1] << 8) | (addr[0]);\n\twritel(high_word, ioaddr + SXGBE_CORE_ADD_HIGHOFFSET(reg_n));\n\twritel(low_word, ioaddr + SXGBE_CORE_ADD_LOWOFFSET(reg_n));\n}\n\nstatic void sxgbe_core_get_umac_addr(void __iomem *ioaddr, unsigned char *addr,\n\t\t\t\t     unsigned int reg_n)\n{\n\tu32 high_word, low_word;\n\n\thigh_word = readl(ioaddr + SXGBE_CORE_ADD_HIGHOFFSET(reg_n));\n\tlow_word = readl(ioaddr + SXGBE_CORE_ADD_LOWOFFSET(reg_n));\n\n\t \n\taddr[5] = (high_word & 0x0000FF00) >> 8;\n\taddr[4] = (high_word & 0x000000FF);\n\taddr[3] = (low_word & 0xFF000000) >> 24;\n\taddr[2] = (low_word & 0x00FF0000) >> 16;\n\taddr[1] = (low_word & 0x0000FF00) >> 8;\n\taddr[0] = (low_word & 0x000000FF);\n}\n\nstatic void sxgbe_enable_tx(void __iomem *ioaddr, bool enable)\n{\n\tu32 tx_config;\n\n\ttx_config = readl(ioaddr + SXGBE_CORE_TX_CONFIG_REG);\n\ttx_config &= ~SXGBE_TX_ENABLE;\n\n\tif (enable)\n\t\ttx_config |= SXGBE_TX_ENABLE;\n\twritel(tx_config, ioaddr + SXGBE_CORE_TX_CONFIG_REG);\n}\n\nstatic void sxgbe_enable_rx(void __iomem *ioaddr, bool enable)\n{\n\tu32 rx_config;\n\n\trx_config = readl(ioaddr + SXGBE_CORE_RX_CONFIG_REG);\n\trx_config &= ~SXGBE_RX_ENABLE;\n\n\tif (enable)\n\t\trx_config |= SXGBE_RX_ENABLE;\n\twritel(rx_config, ioaddr + SXGBE_CORE_RX_CONFIG_REG);\n}\n\nstatic int sxgbe_get_controller_version(void __iomem *ioaddr)\n{\n\treturn readl(ioaddr + SXGBE_CORE_VERSION_REG);\n}\n\n \nstatic unsigned int sxgbe_get_hw_feature(void __iomem *ioaddr,\n\t\t\t\t\t unsigned char feature_index)\n{\n\treturn readl(ioaddr + (SXGBE_CORE_HW_FEA_REG(feature_index)));\n}\n\nstatic void sxgbe_core_set_speed(void __iomem *ioaddr, unsigned char speed)\n{\n\tu32 tx_cfg = readl(ioaddr + SXGBE_CORE_TX_CONFIG_REG);\n\n\t \n\ttx_cfg &= ~0x60000000;\n\ttx_cfg |= (speed << SXGBE_SPEED_LSHIFT);\n\n\t \n\twritel(tx_cfg, ioaddr + SXGBE_CORE_TX_CONFIG_REG);\n}\n\nstatic void sxgbe_core_enable_rxqueue(void __iomem *ioaddr, int queue_num)\n{\n\tu32 reg_val;\n\n\treg_val = readl(ioaddr + SXGBE_CORE_RX_CTL0_REG);\n\treg_val &= ~(SXGBE_CORE_RXQ_ENABLE_MASK << queue_num);\n\treg_val |= SXGBE_CORE_RXQ_ENABLE;\n\twritel(reg_val, ioaddr + SXGBE_CORE_RX_CTL0_REG);\n}\n\nstatic void sxgbe_core_disable_rxqueue(void __iomem *ioaddr, int queue_num)\n{\n\tu32 reg_val;\n\n\treg_val = readl(ioaddr + SXGBE_CORE_RX_CTL0_REG);\n\treg_val &= ~(SXGBE_CORE_RXQ_ENABLE_MASK << queue_num);\n\treg_val |= SXGBE_CORE_RXQ_DISABLE;\n\twritel(reg_val, ioaddr + SXGBE_CORE_RX_CTL0_REG);\n}\n\nstatic void  sxgbe_set_eee_mode(void __iomem *ioaddr)\n{\n\tu32 ctrl;\n\n\t \n\tctrl = readl(ioaddr + SXGBE_CORE_LPI_CTRL_STATUS);\n\tctrl |= LPI_CTRL_STATUS_LPIEN | LPI_CTRL_STATUS_TXA;\n\twritel(ctrl, ioaddr + SXGBE_CORE_LPI_CTRL_STATUS);\n}\n\nstatic void  sxgbe_reset_eee_mode(void __iomem *ioaddr)\n{\n\tu32 ctrl;\n\n\tctrl = readl(ioaddr + SXGBE_CORE_LPI_CTRL_STATUS);\n\tctrl &= ~(LPI_CTRL_STATUS_LPIEN | LPI_CTRL_STATUS_TXA);\n\twritel(ctrl, ioaddr + SXGBE_CORE_LPI_CTRL_STATUS);\n}\n\nstatic void  sxgbe_set_eee_pls(void __iomem *ioaddr, const int link)\n{\n\tu32 ctrl;\n\n\tctrl = readl(ioaddr + SXGBE_CORE_LPI_CTRL_STATUS);\n\n\t \n\tif (link)\n\t\tctrl |= LPI_CTRL_STATUS_PLS;\n\telse\n\t\tctrl &= ~LPI_CTRL_STATUS_PLS;\n\n\twritel(ctrl, ioaddr + SXGBE_CORE_LPI_CTRL_STATUS);\n}\n\nstatic void  sxgbe_set_eee_timer(void __iomem *ioaddr,\n\t\t\t\t const int ls, const int tw)\n{\n\tint value = ((tw & 0xffff)) | ((ls & 0x7ff) << 16);\n\n\t \n\twritel(value, ioaddr + SXGBE_CORE_LPI_TIMER_CTRL);\n}\n\nstatic void sxgbe_enable_rx_csum(void __iomem *ioaddr)\n{\n\tu32 ctrl;\n\n\tctrl = readl(ioaddr + SXGBE_CORE_RX_CONFIG_REG);\n\tctrl |= SXGBE_RX_CSUMOFFLOAD_ENABLE;\n\twritel(ctrl, ioaddr + SXGBE_CORE_RX_CONFIG_REG);\n}\n\nstatic void sxgbe_disable_rx_csum(void __iomem *ioaddr)\n{\n\tu32 ctrl;\n\n\tctrl = readl(ioaddr + SXGBE_CORE_RX_CONFIG_REG);\n\tctrl &= ~SXGBE_RX_CSUMOFFLOAD_ENABLE;\n\twritel(ctrl, ioaddr + SXGBE_CORE_RX_CONFIG_REG);\n}\n\nstatic const struct sxgbe_core_ops core_ops = {\n\t.core_init\t\t= sxgbe_core_init,\n\t.dump_regs\t\t= sxgbe_core_dump_regs,\n\t.host_irq_status\t= sxgbe_core_host_irq_status,\n\t.pmt\t\t\t= sxgbe_core_pmt,\n\t.set_umac_addr\t\t= sxgbe_core_set_umac_addr,\n\t.get_umac_addr\t\t= sxgbe_core_get_umac_addr,\n\t.enable_rx\t\t= sxgbe_enable_rx,\n\t.enable_tx\t\t= sxgbe_enable_tx,\n\t.get_controller_version\t= sxgbe_get_controller_version,\n\t.get_hw_feature\t\t= sxgbe_get_hw_feature,\n\t.set_speed\t\t= sxgbe_core_set_speed,\n\t.set_eee_mode\t\t= sxgbe_set_eee_mode,\n\t.reset_eee_mode\t\t= sxgbe_reset_eee_mode,\n\t.set_eee_timer\t\t= sxgbe_set_eee_timer,\n\t.set_eee_pls\t\t= sxgbe_set_eee_pls,\n\t.enable_rx_csum\t\t= sxgbe_enable_rx_csum,\n\t.disable_rx_csum\t= sxgbe_disable_rx_csum,\n\t.enable_rxqueue\t\t= sxgbe_core_enable_rxqueue,\n\t.disable_rxqueue\t= sxgbe_core_disable_rxqueue,\n};\n\nconst struct sxgbe_core_ops *sxgbe_get_core_ops(void)\n{\n\treturn &core_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}