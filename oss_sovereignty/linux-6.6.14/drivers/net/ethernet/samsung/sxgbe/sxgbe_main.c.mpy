{
  "module_name": "sxgbe_main.c",
  "hash_id": "4393c2251b950fd1ccadb936c12757dd5073d543418cd486df32c0492ab39036",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/crc32.h>\n#include <linux/dma-mapping.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/net_tstamp.h>\n#include <linux/netdevice.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/prefetch.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/tcp.h>\n#include <linux/sxgbe_platform.h>\n\n#include \"sxgbe_common.h\"\n#include \"sxgbe_desc.h\"\n#include \"sxgbe_dma.h\"\n#include \"sxgbe_mtl.h\"\n#include \"sxgbe_reg.h\"\n\n#define SXGBE_ALIGN(x)\tL1_CACHE_ALIGN(x)\n#define JUMBO_LEN\t9000\n\n \n#define TX_TIMEO\t5000\n#define DMA_TX_SIZE\t512\n#define DMA_RX_SIZE\t1024\n#define TC_DEFAULT\t64\n#define DMA_BUFFER_SIZE\tBUF_SIZE_2KiB\n \n#define SXGBE_DEFAULT_LPI_TIMER\t1000\n\nstatic int debug = -1;\nstatic int eee_timer = SXGBE_DEFAULT_LPI_TIMER;\n\nmodule_param(eee_timer, int, 0644);\n\nmodule_param(debug, int, 0644);\nstatic const u32 default_msg_level = (NETIF_MSG_DRV | NETIF_MSG_PROBE |\n\t\t\t\t      NETIF_MSG_LINK | NETIF_MSG_IFUP |\n\t\t\t\t      NETIF_MSG_IFDOWN | NETIF_MSG_TIMER);\n\nstatic irqreturn_t sxgbe_common_interrupt(int irq, void *dev_id);\nstatic irqreturn_t sxgbe_tx_interrupt(int irq, void *dev_id);\nstatic irqreturn_t sxgbe_rx_interrupt(int irq, void *dev_id);\n\n#define SXGBE_COAL_TIMER(x) (jiffies + usecs_to_jiffies(x))\n\n#define SXGBE_LPI_TIMER(x) (jiffies + msecs_to_jiffies(x))\n\n \nstatic void sxgbe_verify_args(void)\n{\n\tif (unlikely(eee_timer < 0))\n\t\teee_timer = SXGBE_DEFAULT_LPI_TIMER;\n}\n\nstatic void sxgbe_enable_eee_mode(const struct sxgbe_priv_data *priv)\n{\n\t \n\tif (!priv->tx_path_in_lpi_mode)\n\t\tpriv->hw->mac->set_eee_mode(priv->ioaddr);\n}\n\nvoid sxgbe_disable_eee_mode(struct sxgbe_priv_data * const priv)\n{\n\t \n\tpriv->hw->mac->reset_eee_mode(priv->ioaddr);\n\tdel_timer_sync(&priv->eee_ctrl_timer);\n\tpriv->tx_path_in_lpi_mode = false;\n}\n\n \nstatic void sxgbe_eee_ctrl_timer(struct timer_list *t)\n{\n\tstruct sxgbe_priv_data *priv = from_timer(priv, t, eee_ctrl_timer);\n\n\tsxgbe_enable_eee_mode(priv);\n\tmod_timer(&priv->eee_ctrl_timer, SXGBE_LPI_TIMER(eee_timer));\n}\n\n \nbool sxgbe_eee_init(struct sxgbe_priv_data * const priv)\n{\n\tstruct net_device *ndev = priv->dev;\n\tbool ret = false;\n\n\t \n\tif (priv->hw_cap.eee) {\n\t\t \n\t\tif (phy_init_eee(ndev->phydev, true))\n\t\t\treturn false;\n\n\t\tpriv->eee_active = 1;\n\t\ttimer_setup(&priv->eee_ctrl_timer, sxgbe_eee_ctrl_timer, 0);\n\t\tpriv->eee_ctrl_timer.expires = SXGBE_LPI_TIMER(eee_timer);\n\t\tadd_timer(&priv->eee_ctrl_timer);\n\n\t\tpriv->hw->mac->set_eee_timer(priv->ioaddr,\n\t\t\t\t\t     SXGBE_DEFAULT_LPI_TIMER,\n\t\t\t\t\t     priv->tx_lpi_timer);\n\n\t\tpr_info(\"Energy-Efficient Ethernet initialized\\n\");\n\n\t\tret = true;\n\t}\n\n\treturn ret;\n}\n\nstatic void sxgbe_eee_adjust(const struct sxgbe_priv_data *priv)\n{\n\tstruct net_device *ndev = priv->dev;\n\n\t \n\tif (priv->eee_enabled)\n\t\tpriv->hw->mac->set_eee_pls(priv->ioaddr, ndev->phydev->link);\n}\n\n \nstatic void sxgbe_clk_csr_set(struct sxgbe_priv_data *priv)\n{\n\tu32 clk_rate = clk_get_rate(priv->sxgbe_clk);\n\n\t \n\tif (clk_rate < SXGBE_CSR_F_150M)\n\t\tpriv->clk_csr = SXGBE_CSR_100_150M;\n\telse if (clk_rate <= SXGBE_CSR_F_250M)\n\t\tpriv->clk_csr = SXGBE_CSR_150_250M;\n\telse if (clk_rate <= SXGBE_CSR_F_300M)\n\t\tpriv->clk_csr = SXGBE_CSR_250_300M;\n\telse if (clk_rate <= SXGBE_CSR_F_350M)\n\t\tpriv->clk_csr = SXGBE_CSR_300_350M;\n\telse if (clk_rate <= SXGBE_CSR_F_400M)\n\t\tpriv->clk_csr = SXGBE_CSR_350_400M;\n\telse if (clk_rate <= SXGBE_CSR_F_500M)\n\t\tpriv->clk_csr = SXGBE_CSR_400_500M;\n}\n\n \n#define SXGBE_TX_THRESH(x)\t(x->dma_tx_size/4)\n\nstatic inline u32 sxgbe_tx_avail(struct sxgbe_tx_queue *queue, int tx_qsize)\n{\n\treturn queue->dirty_tx + tx_qsize - queue->cur_tx - 1;\n}\n\n \nstatic void sxgbe_adjust_link(struct net_device *dev)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tu8 new_state = 0;\n\tu8 speed = 0xff;\n\n\tif (!phydev)\n\t\treturn;\n\n\t \n\tif (phydev->link) {\n\t\tif (phydev->speed != priv->speed) {\n\t\t\tnew_state = 1;\n\t\t\tswitch (phydev->speed) {\n\t\t\tcase SPEED_10000:\n\t\t\t\tspeed = SXGBE_SPEED_10G;\n\t\t\t\tbreak;\n\t\t\tcase SPEED_2500:\n\t\t\t\tspeed = SXGBE_SPEED_2_5G;\n\t\t\t\tbreak;\n\t\t\tcase SPEED_1000:\n\t\t\t\tspeed = SXGBE_SPEED_1G;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnetif_err(priv, link, dev,\n\t\t\t\t\t  \"Speed (%d) not supported\\n\",\n\t\t\t\t\t  phydev->speed);\n\t\t\t}\n\n\t\t\tpriv->speed = phydev->speed;\n\t\t\tpriv->hw->mac->set_speed(priv->ioaddr, speed);\n\t\t}\n\n\t\tif (!priv->oldlink) {\n\t\t\tnew_state = 1;\n\t\t\tpriv->oldlink = 1;\n\t\t}\n\t} else if (priv->oldlink) {\n\t\tnew_state = 1;\n\t\tpriv->oldlink = 0;\n\t\tpriv->speed = SPEED_UNKNOWN;\n\t}\n\n\tif (new_state & netif_msg_link(priv))\n\t\tphy_print_status(phydev);\n\n\t \n\tsxgbe_eee_adjust(priv);\n}\n\n \nstatic int sxgbe_init_phy(struct net_device *ndev)\n{\n\tchar phy_id_fmt[MII_BUS_ID_SIZE + 3];\n\tchar bus_id[MII_BUS_ID_SIZE];\n\tstruct phy_device *phydev;\n\tstruct sxgbe_priv_data *priv = netdev_priv(ndev);\n\tint phy_iface = priv->plat->interface;\n\n\t \n\tpriv->oldlink = 0;\n\tpriv->speed = SPEED_UNKNOWN;\n\tpriv->oldduplex = DUPLEX_UNKNOWN;\n\n\tif (priv->plat->phy_bus_name)\n\t\tsnprintf(bus_id, MII_BUS_ID_SIZE, \"%s-%x\",\n\t\t\t priv->plat->phy_bus_name, priv->plat->bus_id);\n\telse\n\t\tsnprintf(bus_id, MII_BUS_ID_SIZE, \"sxgbe-%x\",\n\t\t\t priv->plat->bus_id);\n\n\tsnprintf(phy_id_fmt, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id,\n\t\t priv->plat->phy_addr);\n\tnetdev_dbg(ndev, \"%s: trying to attach to %s\\n\", __func__, phy_id_fmt);\n\n\tphydev = phy_connect(ndev, phy_id_fmt, &sxgbe_adjust_link, phy_iface);\n\n\tif (IS_ERR(phydev)) {\n\t\tnetdev_err(ndev, \"Could not attach to PHY\\n\");\n\t\treturn PTR_ERR(phydev);\n\t}\n\n\t \n\tif ((phy_iface == PHY_INTERFACE_MODE_MII) ||\n\t    (phy_iface == PHY_INTERFACE_MODE_RMII))\n\t\tphy_set_max_speed(phydev, SPEED_1000);\n\n\tif (phydev->phy_id == 0) {\n\t\tphy_disconnect(phydev);\n\t\treturn -ENODEV;\n\t}\n\n\tnetdev_dbg(ndev, \"%s: attached to PHY (UID 0x%x) Link = %d\\n\",\n\t\t   __func__, phydev->phy_id, phydev->link);\n\n\treturn 0;\n}\n\n \nstatic void sxgbe_clear_descriptors(struct sxgbe_priv_data *priv)\n{\n\tint i, j;\n\tunsigned int txsize = priv->dma_tx_size;\n\tunsigned int rxsize = priv->dma_rx_size;\n\n\t \n\tfor (j = 0; j < SXGBE_RX_QUEUES; j++) {\n\t\tfor (i = 0; i < rxsize; i++)\n\t\t\tpriv->hw->desc->init_rx_desc(&priv->rxq[j]->dma_rx[i],\n\t\t\t\t\t\t     priv->use_riwt, priv->mode,\n\t\t\t\t\t\t     (i == rxsize - 1));\n\t}\n\n\tfor (j = 0; j < SXGBE_TX_QUEUES; j++) {\n\t\tfor (i = 0; i < txsize; i++)\n\t\t\tpriv->hw->desc->init_tx_desc(&priv->txq[j]->dma_tx[i]);\n\t}\n}\n\nstatic int sxgbe_init_rx_buffers(struct net_device *dev,\n\t\t\t\t struct sxgbe_rx_norm_desc *p, int i,\n\t\t\t\t unsigned int dma_buf_sz,\n\t\t\t\t struct sxgbe_rx_queue *rx_ring)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\n\tskb = __netdev_alloc_skb_ip_align(dev, dma_buf_sz, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\trx_ring->rx_skbuff[i] = skb;\n\trx_ring->rx_skbuff_dma[i] = dma_map_single(priv->device, skb->data,\n\t\t\t\t\t\t   dma_buf_sz, DMA_FROM_DEVICE);\n\n\tif (dma_mapping_error(priv->device, rx_ring->rx_skbuff_dma[i])) {\n\t\tnetdev_err(dev, \"%s: DMA mapping error\\n\", __func__);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tp->rdes23.rx_rd_des23.buf2_addr = rx_ring->rx_skbuff_dma[i];\n\n\treturn 0;\n}\n\n \nstatic void sxgbe_free_rx_buffers(struct net_device *dev,\n\t\t\t\t  struct sxgbe_rx_norm_desc *p, int i,\n\t\t\t\t  unsigned int dma_buf_sz,\n\t\t\t\t  struct sxgbe_rx_queue *rx_ring)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\n\tkfree_skb(rx_ring->rx_skbuff[i]);\n\tdma_unmap_single(priv->device, rx_ring->rx_skbuff_dma[i],\n\t\t\t dma_buf_sz, DMA_FROM_DEVICE);\n}\n\n \nstatic int init_tx_ring(struct device *dev, u8 queue_no,\n\t\t\tstruct sxgbe_tx_queue *tx_ring,\tint tx_rsize)\n{\n\t \n\tif (!tx_ring) {\n\t\tdev_err(dev, \"No memory for TX queue of SXGBE\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\ttx_ring->dma_tx = dma_alloc_coherent(dev,\n\t\t\t\t\t     tx_rsize * sizeof(struct sxgbe_tx_norm_desc),\n\t\t\t\t\t     &tx_ring->dma_tx_phy, GFP_KERNEL);\n\tif (!tx_ring->dma_tx)\n\t\treturn -ENOMEM;\n\n\t \n\ttx_ring->tx_skbuff_dma = devm_kcalloc(dev, tx_rsize,\n\t\t\t\t\t      sizeof(dma_addr_t), GFP_KERNEL);\n\tif (!tx_ring->tx_skbuff_dma)\n\t\tgoto dmamem_err;\n\n\ttx_ring->tx_skbuff = devm_kcalloc(dev, tx_rsize,\n\t\t\t\t\t  sizeof(struct sk_buff *), GFP_KERNEL);\n\n\tif (!tx_ring->tx_skbuff)\n\t\tgoto dmamem_err;\n\n\t \n\ttx_ring->queue_no = queue_no;\n\n\t \n\ttx_ring->dirty_tx = 0;\n\ttx_ring->cur_tx = 0;\n\n\treturn 0;\n\ndmamem_err:\n\tdma_free_coherent(dev, tx_rsize * sizeof(struct sxgbe_tx_norm_desc),\n\t\t\t  tx_ring->dma_tx, tx_ring->dma_tx_phy);\n\treturn -ENOMEM;\n}\n\n \nstatic void free_rx_ring(struct device *dev, struct sxgbe_rx_queue *rx_ring,\n\t\t\t int rx_rsize)\n{\n\tdma_free_coherent(dev, rx_rsize * sizeof(struct sxgbe_rx_norm_desc),\n\t\t\t  rx_ring->dma_rx, rx_ring->dma_rx_phy);\n\tkfree(rx_ring->rx_skbuff_dma);\n\tkfree(rx_ring->rx_skbuff);\n}\n\n \nstatic int init_rx_ring(struct net_device *dev, u8 queue_no,\n\t\t\tstruct sxgbe_rx_queue *rx_ring,\tint rx_rsize)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\tint desc_index;\n\tunsigned int bfsize = 0;\n\tunsigned int ret = 0;\n\n\t \n\tbfsize = ALIGN(dev->mtu + ETH_HLEN + ETH_FCS_LEN + NET_IP_ALIGN, 8);\n\n\tnetif_dbg(priv, probe, dev, \"%s: bfsize %d\\n\", __func__, bfsize);\n\n\t \n\tif (rx_ring == NULL) {\n\t\tnetdev_err(dev, \"No memory for RX queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\trx_ring->queue_no = queue_no;\n\n\t \n\trx_ring->dma_rx = dma_alloc_coherent(priv->device,\n\t\t\t\t\t     rx_rsize * sizeof(struct sxgbe_rx_norm_desc),\n\t\t\t\t\t     &rx_ring->dma_rx_phy, GFP_KERNEL);\n\n\tif (rx_ring->dma_rx == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\trx_ring->rx_skbuff_dma = kmalloc_array(rx_rsize,\n\t\t\t\t\t       sizeof(dma_addr_t), GFP_KERNEL);\n\tif (!rx_ring->rx_skbuff_dma) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_dma_rx;\n\t}\n\n\trx_ring->rx_skbuff = kmalloc_array(rx_rsize,\n\t\t\t\t\t   sizeof(struct sk_buff *), GFP_KERNEL);\n\tif (!rx_ring->rx_skbuff) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_skbuff_dma;\n\t}\n\n\t \n\tfor (desc_index = 0; desc_index < rx_rsize; desc_index++) {\n\t\tstruct sxgbe_rx_norm_desc *p;\n\t\tp = rx_ring->dma_rx + desc_index;\n\t\tret = sxgbe_init_rx_buffers(dev, p, desc_index,\n\t\t\t\t\t    bfsize, rx_ring);\n\t\tif (ret)\n\t\t\tgoto err_free_rx_buffers;\n\t}\n\n\t \n\trx_ring->cur_rx = 0;\n\trx_ring->dirty_rx = (unsigned int)(desc_index - rx_rsize);\n\tpriv->dma_buf_sz = bfsize;\n\n\treturn 0;\n\nerr_free_rx_buffers:\n\twhile (--desc_index >= 0) {\n\t\tstruct sxgbe_rx_norm_desc *p;\n\n\t\tp = rx_ring->dma_rx + desc_index;\n\t\tsxgbe_free_rx_buffers(dev, p, desc_index, bfsize, rx_ring);\n\t}\n\tkfree(rx_ring->rx_skbuff);\nerr_free_skbuff_dma:\n\tkfree(rx_ring->rx_skbuff_dma);\nerr_free_dma_rx:\n\tdma_free_coherent(priv->device,\n\t\t\t  rx_rsize * sizeof(struct sxgbe_rx_norm_desc),\n\t\t\t  rx_ring->dma_rx, rx_ring->dma_rx_phy);\n\n\treturn ret;\n}\n \nstatic void free_tx_ring(struct device *dev, struct sxgbe_tx_queue *tx_ring,\n\t\t\t int tx_rsize)\n{\n\tdma_free_coherent(dev, tx_rsize * sizeof(struct sxgbe_tx_norm_desc),\n\t\t\t  tx_ring->dma_tx, tx_ring->dma_tx_phy);\n}\n\n \nstatic int init_dma_desc_rings(struct net_device *netd)\n{\n\tint queue_num, ret;\n\tstruct sxgbe_priv_data *priv = netdev_priv(netd);\n\tint tx_rsize = priv->dma_tx_size;\n\tint rx_rsize = priv->dma_rx_size;\n\n\t \n\tSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\n\t\tret = init_tx_ring(priv->device, queue_num,\n\t\t\t\t   priv->txq[queue_num], tx_rsize);\n\t\tif (ret) {\n\t\t\tdev_err(&netd->dev, \"TX DMA ring allocation failed!\\n\");\n\t\t\tgoto txalloc_err;\n\t\t}\n\n\t\t \n\t\tpriv->txq[queue_num]->priv_ptr = priv;\n\t}\n\n\t \n\tSXGBE_FOR_EACH_QUEUE(SXGBE_RX_QUEUES, queue_num) {\n\t\tret = init_rx_ring(netd, queue_num,\n\t\t\t\t   priv->rxq[queue_num], rx_rsize);\n\t\tif (ret) {\n\t\t\tnetdev_err(netd, \"RX DMA ring allocation failed!!\\n\");\n\t\t\tgoto rxalloc_err;\n\t\t}\n\n\t\t \n\t\tpriv->rxq[queue_num]->priv_ptr = priv;\n\t}\n\n\tsxgbe_clear_descriptors(priv);\n\n\treturn 0;\n\ntxalloc_err:\n\twhile (queue_num--)\n\t\tfree_tx_ring(priv->device, priv->txq[queue_num], tx_rsize);\n\treturn ret;\n\nrxalloc_err:\n\twhile (queue_num--)\n\t\tfree_rx_ring(priv->device, priv->rxq[queue_num], rx_rsize);\n\treturn ret;\n}\n\nstatic void tx_free_ring_skbufs(struct sxgbe_tx_queue *txqueue)\n{\n\tint dma_desc;\n\tstruct sxgbe_priv_data *priv = txqueue->priv_ptr;\n\tint tx_rsize = priv->dma_tx_size;\n\n\tfor (dma_desc = 0; dma_desc < tx_rsize; dma_desc++) {\n\t\tstruct sxgbe_tx_norm_desc *tdesc = txqueue->dma_tx + dma_desc;\n\n\t\tif (txqueue->tx_skbuff_dma[dma_desc])\n\t\t\tdma_unmap_single(priv->device,\n\t\t\t\t\t txqueue->tx_skbuff_dma[dma_desc],\n\t\t\t\t\t priv->hw->desc->get_tx_len(tdesc),\n\t\t\t\t\t DMA_TO_DEVICE);\n\n\t\tdev_kfree_skb_any(txqueue->tx_skbuff[dma_desc]);\n\t\ttxqueue->tx_skbuff[dma_desc] = NULL;\n\t\ttxqueue->tx_skbuff_dma[dma_desc] = 0;\n\t}\n}\n\n\nstatic void dma_free_tx_skbufs(struct sxgbe_priv_data *priv)\n{\n\tint queue_num;\n\n\tSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\n\t\tstruct sxgbe_tx_queue *tqueue = priv->txq[queue_num];\n\t\ttx_free_ring_skbufs(tqueue);\n\t}\n}\n\nstatic void free_dma_desc_resources(struct sxgbe_priv_data *priv)\n{\n\tint queue_num;\n\tint tx_rsize = priv->dma_tx_size;\n\tint rx_rsize = priv->dma_rx_size;\n\n\t \n\tdma_free_tx_skbufs(priv);\n\n\t \n\tSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\n\t\tfree_tx_ring(priv->device, priv->txq[queue_num], tx_rsize);\n\t}\n\n\t \n\tSXGBE_FOR_EACH_QUEUE(SXGBE_RX_QUEUES, queue_num) {\n\t\tfree_rx_ring(priv->device, priv->rxq[queue_num], rx_rsize);\n\t}\n}\n\nstatic int txring_mem_alloc(struct sxgbe_priv_data *priv)\n{\n\tint queue_num;\n\n\tSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\n\t\tpriv->txq[queue_num] = devm_kmalloc(priv->device,\n\t\t\t\t\t\t    sizeof(struct sxgbe_tx_queue), GFP_KERNEL);\n\t\tif (!priv->txq[queue_num])\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int rxring_mem_alloc(struct sxgbe_priv_data *priv)\n{\n\tint queue_num;\n\n\tSXGBE_FOR_EACH_QUEUE(SXGBE_RX_QUEUES, queue_num) {\n\t\tpriv->rxq[queue_num] = devm_kmalloc(priv->device,\n\t\t\t\t\t\t    sizeof(struct sxgbe_rx_queue), GFP_KERNEL);\n\t\tif (!priv->rxq[queue_num])\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void sxgbe_mtl_operation_mode(struct sxgbe_priv_data *priv)\n{\n\tint queue_num;\n\n\t \n\tif (likely(priv->plat->force_sf_dma_mode)) {\n\t\t \n\t\tSXGBE_FOR_EACH_QUEUE(priv->hw_cap.tx_mtl_queues, queue_num)\n\t\t\tpriv->hw->mtl->set_tx_mtl_mode(priv->ioaddr, queue_num,\n\t\t\t\t\t\t       SXGBE_MTL_SFMODE);\n\t\tpriv->tx_tc = SXGBE_MTL_SFMODE;\n\n\t\t \n\t\tSXGBE_FOR_EACH_QUEUE(priv->hw_cap.rx_mtl_queues, queue_num)\n\t\t\tpriv->hw->mtl->set_rx_mtl_mode(priv->ioaddr, queue_num,\n\t\t\t\t\t\t       SXGBE_MTL_SFMODE);\n\t\tpriv->rx_tc = SXGBE_MTL_SFMODE;\n\t} else if (unlikely(priv->plat->force_thresh_dma_mode)) {\n\t\t \n\t\tSXGBE_FOR_EACH_QUEUE(priv->hw_cap.tx_mtl_queues, queue_num)\n\t\t\tpriv->hw->mtl->set_tx_mtl_mode(priv->ioaddr, queue_num,\n\t\t\t\t\t\t       priv->tx_tc);\n\t\t \n\t\tSXGBE_FOR_EACH_QUEUE(priv->hw_cap.rx_mtl_queues, queue_num)\n\t\t\tpriv->hw->mtl->set_rx_mtl_mode(priv->ioaddr, queue_num,\n\t\t\t\t\t\t       priv->rx_tc);\n\t} else {\n\t\tpr_err(\"ERROR: %s: Invalid TX threshold mode\\n\", __func__);\n\t}\n}\n\n \nstatic void sxgbe_tx_queue_clean(struct sxgbe_tx_queue *tqueue)\n{\n\tstruct sxgbe_priv_data *priv = tqueue->priv_ptr;\n\tunsigned int tx_rsize = priv->dma_tx_size;\n\tstruct netdev_queue *dev_txq;\n\tu8 queue_no = tqueue->queue_no;\n\n\tdev_txq = netdev_get_tx_queue(priv->dev, queue_no);\n\n\t__netif_tx_lock(dev_txq, smp_processor_id());\n\n\tpriv->xstats.tx_clean++;\n\twhile (tqueue->dirty_tx != tqueue->cur_tx) {\n\t\tunsigned int entry = tqueue->dirty_tx % tx_rsize;\n\t\tstruct sk_buff *skb = tqueue->tx_skbuff[entry];\n\t\tstruct sxgbe_tx_norm_desc *p;\n\n\t\tp = tqueue->dma_tx + entry;\n\n\t\t \n\t\tif (priv->hw->desc->get_tx_owner(p))\n\t\t\tbreak;\n\n\t\tif (netif_msg_tx_done(priv))\n\t\t\tpr_debug(\"%s: curr %d, dirty %d\\n\",\n\t\t\t\t __func__, tqueue->cur_tx, tqueue->dirty_tx);\n\n\t\tif (likely(tqueue->tx_skbuff_dma[entry])) {\n\t\t\tdma_unmap_single(priv->device,\n\t\t\t\t\t tqueue->tx_skbuff_dma[entry],\n\t\t\t\t\t priv->hw->desc->get_tx_len(p),\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\ttqueue->tx_skbuff_dma[entry] = 0;\n\t\t}\n\n\t\tif (likely(skb)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\ttqueue->tx_skbuff[entry] = NULL;\n\t\t}\n\n\t\tpriv->hw->desc->release_tx_desc(p);\n\n\t\ttqueue->dirty_tx++;\n\t}\n\n\t \n\tif (unlikely(netif_tx_queue_stopped(dev_txq) &&\n\t    sxgbe_tx_avail(tqueue, tx_rsize) > SXGBE_TX_THRESH(priv))) {\n\t\tif (netif_msg_tx_done(priv))\n\t\t\tpr_debug(\"%s: restart transmit\\n\", __func__);\n\t\tnetif_tx_wake_queue(dev_txq);\n\t}\n\n\t__netif_tx_unlock(dev_txq);\n}\n\n \nstatic void sxgbe_tx_all_clean(struct sxgbe_priv_data * const priv)\n{\n\tu8 queue_num;\n\n\tSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\n\t\tstruct sxgbe_tx_queue *tqueue = priv->txq[queue_num];\n\n\t\tsxgbe_tx_queue_clean(tqueue);\n\t}\n\n\tif ((priv->eee_enabled) && (!priv->tx_path_in_lpi_mode)) {\n\t\tsxgbe_enable_eee_mode(priv);\n\t\tmod_timer(&priv->eee_ctrl_timer, SXGBE_LPI_TIMER(eee_timer));\n\t}\n}\n\n \nstatic void sxgbe_restart_tx_queue(struct sxgbe_priv_data *priv, int queue_num)\n{\n\tstruct sxgbe_tx_queue *tx_ring = priv->txq[queue_num];\n\tstruct netdev_queue *dev_txq = netdev_get_tx_queue(priv->dev,\n\t\t\t\t\t\t\t   queue_num);\n\n\t \n\tnetif_tx_stop_queue(dev_txq);\n\n\t \n\tpriv->hw->dma->stop_tx_queue(priv->ioaddr, queue_num);\n\n\t \n\ttx_free_ring_skbufs(tx_ring);\n\n\t \n\ttx_ring->cur_tx = 0;\n\ttx_ring->dirty_tx = 0;\n\n\t \n\tpriv->hw->dma->start_tx_queue(priv->ioaddr, queue_num);\n\n\tpriv->dev->stats.tx_errors++;\n\n\t \n\tnetif_tx_wake_queue(dev_txq);\n}\n\n \nstatic void sxgbe_reset_all_tx_queues(struct sxgbe_priv_data *priv)\n{\n\tint queue_num;\n\n\t \n\tSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num)\n\t\tsxgbe_restart_tx_queue(priv, queue_num);\n}\n\n \nstatic int sxgbe_get_hw_features(struct sxgbe_priv_data * const priv)\n{\n\tint rval = 0;\n\tstruct sxgbe_hw_features *features = &priv->hw_cap;\n\n\t \n\trval = priv->hw->mac->get_hw_feature(priv->ioaddr, 0);\n\tif (rval) {\n\t\tfeatures->pmt_remote_wake_up =\n\t\t\tSXGBE_HW_FEAT_PMT_TEMOTE_WOP(rval);\n\t\tfeatures->pmt_magic_frame = SXGBE_HW_FEAT_PMT_MAGIC_PKT(rval);\n\t\tfeatures->atime_stamp = SXGBE_HW_FEAT_IEEE1500_2008(rval);\n\t\tfeatures->tx_csum_offload =\n\t\t\tSXGBE_HW_FEAT_TX_CSUM_OFFLOAD(rval);\n\t\tfeatures->rx_csum_offload =\n\t\t\tSXGBE_HW_FEAT_RX_CSUM_OFFLOAD(rval);\n\t\tfeatures->multi_macaddr = SXGBE_HW_FEAT_MACADDR_COUNT(rval);\n\t\tfeatures->tstamp_srcselect = SXGBE_HW_FEAT_TSTMAP_SRC(rval);\n\t\tfeatures->sa_vlan_insert = SXGBE_HW_FEAT_SRCADDR_VLAN(rval);\n\t\tfeatures->eee = SXGBE_HW_FEAT_EEE(rval);\n\t}\n\n\t \n\trval = priv->hw->mac->get_hw_feature(priv->ioaddr, 1);\n\tif (rval) {\n\t\tfeatures->rxfifo_size = SXGBE_HW_FEAT_RX_FIFO_SIZE(rval);\n\t\tfeatures->txfifo_size = SXGBE_HW_FEAT_TX_FIFO_SIZE(rval);\n\t\tfeatures->atstmap_hword = SXGBE_HW_FEAT_TX_FIFO_SIZE(rval);\n\t\tfeatures->dcb_enable = SXGBE_HW_FEAT_DCB(rval);\n\t\tfeatures->splithead_enable = SXGBE_HW_FEAT_SPLIT_HDR(rval);\n\t\tfeatures->tcpseg_offload = SXGBE_HW_FEAT_TSO(rval);\n\t\tfeatures->debug_mem = SXGBE_HW_FEAT_DEBUG_MEM_IFACE(rval);\n\t\tfeatures->rss_enable = SXGBE_HW_FEAT_RSS(rval);\n\t\tfeatures->hash_tsize = SXGBE_HW_FEAT_HASH_TABLE_SIZE(rval);\n\t\tfeatures->l3l4_filer_size = SXGBE_HW_FEAT_L3L4_FILTER_NUM(rval);\n\t}\n\n\t \n\trval = priv->hw->mac->get_hw_feature(priv->ioaddr, 2);\n\tif (rval) {\n\t\tfeatures->rx_mtl_queues = SXGBE_HW_FEAT_RX_MTL_QUEUES(rval);\n\t\tfeatures->tx_mtl_queues = SXGBE_HW_FEAT_TX_MTL_QUEUES(rval);\n\t\tfeatures->rx_dma_channels = SXGBE_HW_FEAT_RX_DMA_CHANNELS(rval);\n\t\tfeatures->tx_dma_channels = SXGBE_HW_FEAT_TX_DMA_CHANNELS(rval);\n\t\tfeatures->pps_output_count = SXGBE_HW_FEAT_PPS_OUTPUTS(rval);\n\t\tfeatures->aux_input_count = SXGBE_HW_FEAT_AUX_SNAPSHOTS(rval);\n\t}\n\n\treturn rval;\n}\n\n \nstatic void sxgbe_check_ether_addr(struct sxgbe_priv_data *priv)\n{\n\tif (!is_valid_ether_addr(priv->dev->dev_addr)) {\n\t\tu8 addr[ETH_ALEN];\n\n\t\tpriv->hw->mac->get_umac_addr((void __iomem *)\n\t\t\t\t\t     priv->ioaddr, addr, 0);\n\t\tif (is_valid_ether_addr(addr))\n\t\t\teth_hw_addr_set(priv->dev, addr);\n\t\telse\n\t\t\teth_hw_addr_random(priv->dev);\n\t}\n\tdev_info(priv->device, \"device MAC address %pM\\n\",\n\t\t priv->dev->dev_addr);\n}\n\n \nstatic int sxgbe_init_dma_engine(struct sxgbe_priv_data *priv)\n{\n\tint pbl = DEFAULT_DMA_PBL, fixed_burst = 0, burst_map = 0;\n\tint queue_num;\n\n\tif (priv->plat->dma_cfg) {\n\t\tpbl = priv->plat->dma_cfg->pbl;\n\t\tfixed_burst = priv->plat->dma_cfg->fixed_burst;\n\t\tburst_map = priv->plat->dma_cfg->burst_map;\n\t}\n\n\tSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num)\n\t\tpriv->hw->dma->cha_init(priv->ioaddr, queue_num,\n\t\t\t\t\tfixed_burst, pbl,\n\t\t\t\t\t(priv->txq[queue_num])->dma_tx_phy,\n\t\t\t\t\t(priv->rxq[queue_num])->dma_rx_phy,\n\t\t\t\t\tpriv->dma_tx_size, priv->dma_rx_size);\n\n\treturn priv->hw->dma->init(priv->ioaddr, fixed_burst, burst_map);\n}\n\n \nstatic void sxgbe_init_mtl_engine(struct sxgbe_priv_data *priv)\n{\n\tint queue_num;\n\n\tSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\n\t\tpriv->hw->mtl->mtl_set_txfifosize(priv->ioaddr, queue_num,\n\t\t\t\t\t\t  priv->hw_cap.tx_mtl_qsize);\n\t\tpriv->hw->mtl->mtl_enable_txqueue(priv->ioaddr, queue_num);\n\t}\n}\n\n \nstatic void sxgbe_disable_mtl_engine(struct sxgbe_priv_data *priv)\n{\n\tint queue_num;\n\n\tSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num)\n\t\tpriv->hw->mtl->mtl_disable_txqueue(priv->ioaddr, queue_num);\n}\n\n\n \nstatic void sxgbe_tx_timer(struct timer_list *t)\n{\n\tstruct sxgbe_tx_queue *p = from_timer(p, t, txtimer);\n\tsxgbe_tx_queue_clean(p);\n}\n\n \nstatic void sxgbe_tx_init_coalesce(struct sxgbe_priv_data *priv)\n{\n\tu8 queue_num;\n\n\tSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\n\t\tstruct sxgbe_tx_queue *p = priv->txq[queue_num];\n\t\tp->tx_coal_frames =  SXGBE_TX_FRAMES;\n\t\tp->tx_coal_timer = SXGBE_COAL_TX_TIMER;\n\t\ttimer_setup(&p->txtimer, sxgbe_tx_timer, 0);\n\t\tp->txtimer.expires = SXGBE_COAL_TIMER(p->tx_coal_timer);\n\t\tadd_timer(&p->txtimer);\n\t}\n}\n\nstatic void sxgbe_tx_del_timer(struct sxgbe_priv_data *priv)\n{\n\tu8 queue_num;\n\n\tSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\n\t\tstruct sxgbe_tx_queue *p = priv->txq[queue_num];\n\t\tdel_timer_sync(&p->txtimer);\n\t}\n}\n\n \nstatic int sxgbe_open(struct net_device *dev)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\tint ret, queue_num;\n\n\tclk_prepare_enable(priv->sxgbe_clk);\n\n\tsxgbe_check_ether_addr(priv);\n\n\t \n\tret = sxgbe_init_phy(dev);\n\tif (ret) {\n\t\tnetdev_err(dev, \"%s: Cannot attach to PHY (error: %d)\\n\",\n\t\t\t   __func__, ret);\n\t\tgoto phy_error;\n\t}\n\n\t \n\tpriv->dma_tx_size = SXGBE_ALIGN(DMA_TX_SIZE);\n\tpriv->dma_rx_size = SXGBE_ALIGN(DMA_RX_SIZE);\n\tpriv->dma_buf_sz = SXGBE_ALIGN(DMA_BUFFER_SIZE);\n\tpriv->tx_tc = TC_DEFAULT;\n\tpriv->rx_tc = TC_DEFAULT;\n\tinit_dma_desc_rings(dev);\n\n\t \n\tret = sxgbe_init_dma_engine(priv);\n\tif (ret < 0) {\n\t\tnetdev_err(dev, \"%s: DMA initialization failed\\n\", __func__);\n\t\tgoto init_error;\n\t}\n\n\t \n\tsxgbe_init_mtl_engine(priv);\n\n\t \n\tpriv->hw->mac->set_umac_addr(priv->ioaddr, dev->dev_addr, 0);\n\n\t \n\tpriv->hw->mac->core_init(priv->ioaddr);\n\tSXGBE_FOR_EACH_QUEUE(SXGBE_RX_QUEUES, queue_num) {\n\t\tpriv->hw->mac->enable_rxqueue(priv->ioaddr, queue_num);\n\t}\n\n\t \n\tret = devm_request_irq(priv->device, priv->irq, sxgbe_common_interrupt,\n\t\t\t       IRQF_SHARED, dev->name, dev);\n\tif (unlikely(ret < 0)) {\n\t\tnetdev_err(dev, \"%s: ERROR: allocating the IRQ %d (error: %d)\\n\",\n\t\t\t   __func__, priv->irq, ret);\n\t\tgoto init_error;\n\t}\n\n\t \n\tif (priv->lpi_irq != dev->irq) {\n\t\tret = devm_request_irq(priv->device, priv->lpi_irq,\n\t\t\t\t       sxgbe_common_interrupt,\n\t\t\t\t       IRQF_SHARED, dev->name, dev);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tnetdev_err(dev, \"%s: ERROR: allocating the LPI IRQ %d (%d)\\n\",\n\t\t\t\t   __func__, priv->lpi_irq, ret);\n\t\t\tgoto init_error;\n\t\t}\n\t}\n\n\t \n\tSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\n\t\tret = devm_request_irq(priv->device,\n\t\t\t\t       (priv->txq[queue_num])->irq_no,\n\t\t\t\t       sxgbe_tx_interrupt, 0,\n\t\t\t\t       dev->name, priv->txq[queue_num]);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tnetdev_err(dev, \"%s: ERROR: allocating TX IRQ %d (error: %d)\\n\",\n\t\t\t\t   __func__, priv->irq, ret);\n\t\t\tgoto init_error;\n\t\t}\n\t}\n\n\t \n\tSXGBE_FOR_EACH_QUEUE(SXGBE_RX_QUEUES, queue_num) {\n\t\tret = devm_request_irq(priv->device,\n\t\t\t\t       (priv->rxq[queue_num])->irq_no,\n\t\t\t\t       sxgbe_rx_interrupt, 0,\n\t\t\t\t       dev->name, priv->rxq[queue_num]);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tnetdev_err(dev, \"%s: ERROR: allocating TX IRQ %d (error: %d)\\n\",\n\t\t\t\t   __func__, priv->irq, ret);\n\t\t\tgoto init_error;\n\t\t}\n\t}\n\n\t \n\tpriv->hw->mac->enable_tx(priv->ioaddr, true);\n\tpriv->hw->mac->enable_rx(priv->ioaddr, true);\n\n\t \n\tsxgbe_mtl_operation_mode(priv);\n\n\t \n\tmemset(&priv->xstats, 0, sizeof(struct sxgbe_extra_stats));\n\n\tpriv->xstats.tx_threshold = priv->tx_tc;\n\tpriv->xstats.rx_threshold = priv->rx_tc;\n\n\t \n\tnetdev_dbg(dev, \"DMA RX/TX processes started...\\n\");\n\tpriv->hw->dma->start_tx(priv->ioaddr, SXGBE_TX_QUEUES);\n\tpriv->hw->dma->start_rx(priv->ioaddr, SXGBE_RX_QUEUES);\n\n\tif (dev->phydev)\n\t\tphy_start(dev->phydev);\n\n\t \n\tsxgbe_tx_init_coalesce(priv);\n\n\tif ((priv->use_riwt) && (priv->hw->dma->rx_watchdog)) {\n\t\tpriv->rx_riwt = SXGBE_MAX_DMA_RIWT;\n\t\tpriv->hw->dma->rx_watchdog(priv->ioaddr, SXGBE_MAX_DMA_RIWT);\n\t}\n\n\tpriv->tx_lpi_timer = SXGBE_DEFAULT_LPI_TIMER;\n\tpriv->eee_enabled = sxgbe_eee_init(priv);\n\n\tnapi_enable(&priv->napi);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n\ninit_error:\n\tfree_dma_desc_resources(priv);\n\tif (dev->phydev)\n\t\tphy_disconnect(dev->phydev);\nphy_error:\n\tclk_disable_unprepare(priv->sxgbe_clk);\n\n\treturn ret;\n}\n\n \nstatic int sxgbe_release(struct net_device *dev)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\n\tif (priv->eee_enabled)\n\t\tdel_timer_sync(&priv->eee_ctrl_timer);\n\n\t \n\tif (dev->phydev) {\n\t\tphy_stop(dev->phydev);\n\t\tphy_disconnect(dev->phydev);\n\t}\n\n\tnetif_tx_stop_all_queues(dev);\n\n\tnapi_disable(&priv->napi);\n\n\t \n\tsxgbe_tx_del_timer(priv);\n\n\t \n\tpriv->hw->dma->stop_tx(priv->ioaddr, SXGBE_TX_QUEUES);\n\tpriv->hw->dma->stop_rx(priv->ioaddr, SXGBE_RX_QUEUES);\n\n\t \n\tsxgbe_disable_mtl_engine(priv);\n\n\t \n\tfree_dma_desc_resources(priv);\n\n\t \n\tpriv->hw->mac->enable_tx(priv->ioaddr, false);\n\tpriv->hw->mac->enable_rx(priv->ioaddr, false);\n\n\tclk_disable_unprepare(priv->sxgbe_clk);\n\n\treturn 0;\n}\n \nstatic void sxgbe_tso_prepare(struct sxgbe_priv_data *priv,\n\t\t\t      struct sxgbe_tx_norm_desc *first_desc,\n\t\t\t      struct sk_buff *skb)\n{\n\tunsigned int total_hdr_len, tcp_hdr_len;\n\n\t \n\ttcp_hdr_len = tcp_hdrlen(skb);\n\ttotal_hdr_len = skb_transport_offset(skb) + tcp_hdr_len;\n\n\tfirst_desc->tdes01 = dma_map_single(priv->device, skb->data,\n\t\t\t\t\t    total_hdr_len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(priv->device, first_desc->tdes01))\n\t\tpr_err(\"%s: TX dma mapping failed!!\\n\", __func__);\n\n\tfirst_desc->tdes23.tx_rd_des23.first_desc = 1;\n\tpriv->hw->desc->tx_desc_enable_tse(first_desc, 1, total_hdr_len,\n\t\t\t\t\t   tcp_hdr_len,\n\t\t\t\t\t   skb->len - total_hdr_len);\n}\n\n \nstatic netdev_tx_t sxgbe_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tunsigned int entry, frag_num;\n\tint cksum_flag = 0;\n\tstruct netdev_queue *dev_txq;\n\tunsigned txq_index = skb_get_queue_mapping(skb);\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\tunsigned int tx_rsize = priv->dma_tx_size;\n\tstruct sxgbe_tx_queue *tqueue = priv->txq[txq_index];\n\tstruct sxgbe_tx_norm_desc *tx_desc, *first_desc;\n\tstruct sxgbe_tx_ctxt_desc *ctxt_desc = NULL;\n\tint nr_frags = skb_shinfo(skb)->nr_frags;\n\tint no_pagedlen = skb_headlen(skb);\n\tint is_jumbo = 0;\n\tu16 cur_mss = skb_shinfo(skb)->gso_size;\n\tu32 ctxt_desc_req = 0;\n\n\t \n\tdev_txq = netdev_get_tx_queue(dev, txq_index);\n\n\tif (unlikely(skb_is_gso(skb) && tqueue->prev_mss != cur_mss))\n\t\tctxt_desc_req = 1;\n\n\tif (unlikely(skb_vlan_tag_present(skb) ||\n\t\t     ((skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&\n\t\t      tqueue->hwts_tx_en)))\n\t\tctxt_desc_req = 1;\n\n\tif (priv->tx_path_in_lpi_mode)\n\t\tsxgbe_disable_eee_mode(priv);\n\n\tif (unlikely(sxgbe_tx_avail(tqueue, tx_rsize) < nr_frags + 1)) {\n\t\tif (!netif_tx_queue_stopped(dev_txq)) {\n\t\t\tnetif_tx_stop_queue(dev_txq);\n\t\t\tnetdev_err(dev, \"%s: Tx Ring is full when %d queue is awake\\n\",\n\t\t\t\t   __func__, txq_index);\n\t\t}\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tentry = tqueue->cur_tx % tx_rsize;\n\ttx_desc = tqueue->dma_tx + entry;\n\n\tfirst_desc = tx_desc;\n\tif (ctxt_desc_req)\n\t\tctxt_desc = (struct sxgbe_tx_ctxt_desc *)first_desc;\n\n\t \n\ttqueue->tx_skbuff[entry] = skb;\n\n\tif (!is_jumbo) {\n\t\tif (likely(skb_is_gso(skb))) {\n\t\t\t \n\t\t\tif (unlikely(tqueue->prev_mss != cur_mss)) {\n\t\t\t\tpriv->hw->desc->tx_ctxt_desc_set_mss(\n\t\t\t\t\t\tctxt_desc, cur_mss);\n\t\t\t\tpriv->hw->desc->tx_ctxt_desc_set_tcmssv(\n\t\t\t\t\t\tctxt_desc);\n\t\t\t\tpriv->hw->desc->tx_ctxt_desc_reset_ostc(\n\t\t\t\t\t\tctxt_desc);\n\t\t\t\tpriv->hw->desc->tx_ctxt_desc_set_ctxt(\n\t\t\t\t\t\tctxt_desc);\n\t\t\t\tpriv->hw->desc->tx_ctxt_desc_set_owner(\n\t\t\t\t\t\tctxt_desc);\n\n\t\t\t\tentry = (++tqueue->cur_tx) % tx_rsize;\n\t\t\t\tfirst_desc = tqueue->dma_tx + entry;\n\n\t\t\t\ttqueue->prev_mss = cur_mss;\n\t\t\t}\n\t\t\tsxgbe_tso_prepare(priv, first_desc, skb);\n\t\t} else {\n\t\t\ttx_desc->tdes01 = dma_map_single(priv->device,\n\t\t\t\t\t\t\t skb->data, no_pagedlen, DMA_TO_DEVICE);\n\t\t\tif (dma_mapping_error(priv->device, tx_desc->tdes01))\n\t\t\t\tnetdev_err(dev, \"%s: TX dma mapping failed!!\\n\",\n\t\t\t\t\t   __func__);\n\n\t\t\tpriv->hw->desc->prepare_tx_desc(tx_desc, 1, no_pagedlen,\n\t\t\t\t\t\t\tno_pagedlen, cksum_flag);\n\t\t}\n\t}\n\n\tfor (frag_num = 0; frag_num < nr_frags; frag_num++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[frag_num];\n\t\tint len = skb_frag_size(frag);\n\n\t\tentry = (++tqueue->cur_tx) % tx_rsize;\n\t\ttx_desc = tqueue->dma_tx + entry;\n\t\ttx_desc->tdes01 = skb_frag_dma_map(priv->device, frag, 0, len,\n\t\t\t\t\t\t   DMA_TO_DEVICE);\n\n\t\ttqueue->tx_skbuff_dma[entry] = tx_desc->tdes01;\n\t\ttqueue->tx_skbuff[entry] = NULL;\n\n\t\t \n\t\tpriv->hw->desc->prepare_tx_desc(tx_desc, 0, len,\n\t\t\t\t\t\tlen, cksum_flag);\n\t\t \n\t\twmb();\n\n\t\t \n\t\tpriv->hw->desc->set_tx_owner(tx_desc);\n\t}\n\n\t \n\tpriv->hw->desc->close_tx_desc(tx_desc);\n\n\t \n\twmb();\n\n\ttqueue->tx_count_frames += nr_frags + 1;\n\tif (tqueue->tx_count_frames > tqueue->tx_coal_frames) {\n\t\tpriv->hw->desc->clear_tx_ic(tx_desc);\n\t\tpriv->xstats.tx_reset_ic_bit++;\n\t\tmod_timer(&tqueue->txtimer,\n\t\t\t  SXGBE_COAL_TIMER(tqueue->tx_coal_timer));\n\t} else {\n\t\ttqueue->tx_count_frames = 0;\n\t}\n\n\t \n\tpriv->hw->desc->set_tx_owner(first_desc);\n\n\t \n\twmb();\n\n\ttqueue->cur_tx++;\n\n\t \n\tnetif_dbg(priv, pktdata, dev, \"%s: curr %d dirty=%d entry=%d, first=%p, nfrags=%d\\n\",\n\t\t  __func__, tqueue->cur_tx % tx_rsize,\n\t\t  tqueue->dirty_tx % tx_rsize, entry,\n\t\t  first_desc, nr_frags);\n\n\tif (unlikely(sxgbe_tx_avail(tqueue, tx_rsize) <= (MAX_SKB_FRAGS + 1))) {\n\t\tnetif_dbg(priv, hw, dev, \"%s: stop transmitted packets\\n\",\n\t\t\t  __func__);\n\t\tnetif_tx_stop_queue(dev_txq);\n\t}\n\n\tdev->stats.tx_bytes += skb->len;\n\n\tif (unlikely((skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&\n\t\t     tqueue->hwts_tx_en)) {\n\t\t \n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\tpriv->hw->desc->tx_enable_tstamp(first_desc);\n\t}\n\n\tskb_tx_timestamp(skb);\n\n\tpriv->hw->dma->enable_dma_transmission(priv->ioaddr, txq_index);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void sxgbe_rx_refill(struct sxgbe_priv_data *priv)\n{\n\tunsigned int rxsize = priv->dma_rx_size;\n\tint bfsize = priv->dma_buf_sz;\n\tu8 qnum = priv->cur_rx_qnum;\n\n\tfor (; priv->rxq[qnum]->cur_rx - priv->rxq[qnum]->dirty_rx > 0;\n\t     priv->rxq[qnum]->dirty_rx++) {\n\t\tunsigned int entry = priv->rxq[qnum]->dirty_rx % rxsize;\n\t\tstruct sxgbe_rx_norm_desc *p;\n\n\t\tp = priv->rxq[qnum]->dma_rx + entry;\n\n\t\tif (likely(priv->rxq[qnum]->rx_skbuff[entry] == NULL)) {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tskb = netdev_alloc_skb_ip_align(priv->dev, bfsize);\n\n\t\t\tif (unlikely(skb == NULL))\n\t\t\t\tbreak;\n\n\t\t\tpriv->rxq[qnum]->rx_skbuff[entry] = skb;\n\t\t\tpriv->rxq[qnum]->rx_skbuff_dma[entry] =\n\t\t\t\tdma_map_single(priv->device, skb->data, bfsize,\n\t\t\t\t\t       DMA_FROM_DEVICE);\n\n\t\t\tp->rdes23.rx_rd_des23.buf2_addr =\n\t\t\t\tpriv->rxq[qnum]->rx_skbuff_dma[entry];\n\t\t}\n\n\t\t \n\t\twmb();\n\t\tpriv->hw->desc->set_rx_owner(p);\n\t\tpriv->hw->desc->set_rx_int_on_com(p);\n\t\t \n\t\twmb();\n\t}\n}\n\n \nstatic int sxgbe_rx(struct sxgbe_priv_data *priv, int limit)\n{\n\tu8 qnum = priv->cur_rx_qnum;\n\tunsigned int rxsize = priv->dma_rx_size;\n\tunsigned int entry = priv->rxq[qnum]->cur_rx;\n\tunsigned int next_entry = 0;\n\tunsigned int count = 0;\n\tint checksum;\n\tint status;\n\n\twhile (count < limit) {\n\t\tstruct sxgbe_rx_norm_desc *p;\n\t\tstruct sk_buff *skb;\n\t\tint frame_len;\n\n\t\tp = priv->rxq[qnum]->dma_rx + entry;\n\n\t\tif (priv->hw->desc->get_rx_owner(p))\n\t\t\tbreak;\n\n\t\tcount++;\n\n\t\tnext_entry = (++priv->rxq[qnum]->cur_rx) % rxsize;\n\t\tprefetch(priv->rxq[qnum]->dma_rx + next_entry);\n\n\t\t \n\t\tstatus = priv->hw->desc->rx_wbstatus(p, &priv->xstats,\n\t\t\t\t\t\t     &checksum);\n\t\tif (unlikely(status < 0)) {\n\t\t\tentry = next_entry;\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(!priv->rxcsum_insertion))\n\t\t\tchecksum = CHECKSUM_NONE;\n\n\t\tskb = priv->rxq[qnum]->rx_skbuff[entry];\n\n\t\tif (unlikely(!skb))\n\t\t\tnetdev_err(priv->dev, \"rx descriptor is not consistent\\n\");\n\n\t\tprefetch(skb->data - NET_IP_ALIGN);\n\t\tpriv->rxq[qnum]->rx_skbuff[entry] = NULL;\n\n\t\tframe_len = priv->hw->desc->get_rx_frame_len(p);\n\n\t\tskb_put(skb, frame_len);\n\n\t\tskb->ip_summed = checksum;\n\t\tif (checksum == CHECKSUM_NONE)\n\t\t\tnetif_receive_skb(skb);\n\t\telse\n\t\t\tnapi_gro_receive(&priv->napi, skb);\n\n\t\tentry = next_entry;\n\t}\n\n\tsxgbe_rx_refill(priv);\n\n\treturn count;\n}\n\n \nstatic int sxgbe_poll(struct napi_struct *napi, int budget)\n{\n\tstruct sxgbe_priv_data *priv = container_of(napi,\n\t\t\t\t\t\t    struct sxgbe_priv_data, napi);\n\tint work_done = 0;\n\tu8 qnum = priv->cur_rx_qnum;\n\n\tpriv->xstats.napi_poll++;\n\t \n\tsxgbe_tx_all_clean(priv);\n\n\twork_done = sxgbe_rx(priv, budget);\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tpriv->hw->dma->enable_dma_irq(priv->ioaddr, qnum);\n\t}\n\n\treturn work_done;\n}\n\n \nstatic void sxgbe_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\n\tsxgbe_reset_all_tx_queues(priv);\n}\n\n \nstatic irqreturn_t sxgbe_common_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *netdev = (struct net_device *)dev_id;\n\tstruct sxgbe_priv_data *priv = netdev_priv(netdev);\n\tint status;\n\n\tstatus = priv->hw->mac->host_irq_status(priv->ioaddr, &priv->xstats);\n\t \n\tif (status & TX_ENTRY_LPI_MODE) {\n\t\tpriv->xstats.tx_lpi_entry_n++;\n\t\tpriv->tx_path_in_lpi_mode = true;\n\t}\n\tif (status & TX_EXIT_LPI_MODE) {\n\t\tpriv->xstats.tx_lpi_exit_n++;\n\t\tpriv->tx_path_in_lpi_mode = false;\n\t}\n\tif (status & RX_ENTRY_LPI_MODE)\n\t\tpriv->xstats.rx_lpi_entry_n++;\n\tif (status & RX_EXIT_LPI_MODE)\n\t\tpriv->xstats.rx_lpi_exit_n++;\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t sxgbe_tx_interrupt(int irq, void *dev_id)\n{\n\tint status;\n\tstruct sxgbe_tx_queue *txq = (struct sxgbe_tx_queue *)dev_id;\n\tstruct sxgbe_priv_data *priv = txq->priv_ptr;\n\n\t \n\tstatus = priv->hw->dma->tx_dma_int_status(priv->ioaddr, txq->queue_no,\n\t\t\t\t\t\t  &priv->xstats);\n\t \n\tif (likely((status & handle_tx)))\n\t\tnapi_schedule(&priv->napi);\n\n\t \n\tif (unlikely((status & tx_hard_error)))\n\t\tsxgbe_restart_tx_queue(priv, txq->queue_no);\n\n\t \n\tif (unlikely((status & tx_bump_tc) &&\n\t\t     (priv->tx_tc != SXGBE_MTL_SFMODE) &&\n\t\t     (priv->tx_tc < 512))) {\n\t\t \n\t\tpriv->tx_tc += (priv->tx_tc < 128) ? 32 : 64;\n\t\tpriv->hw->mtl->set_tx_mtl_mode(priv->ioaddr,\n\t\t\t\t\t       txq->queue_no, priv->tx_tc);\n\t\tpriv->xstats.tx_threshold = priv->tx_tc;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t sxgbe_rx_interrupt(int irq, void *dev_id)\n{\n\tint status;\n\tstruct sxgbe_rx_queue *rxq = (struct sxgbe_rx_queue *)dev_id;\n\tstruct sxgbe_priv_data *priv = rxq->priv_ptr;\n\n\t \n\tstatus = priv->hw->dma->rx_dma_int_status(priv->ioaddr, rxq->queue_no,\n\t\t\t\t\t\t  &priv->xstats);\n\n\tif (likely((status & handle_rx) && (napi_schedule_prep(&priv->napi)))) {\n\t\tpriv->hw->dma->disable_dma_irq(priv->ioaddr, rxq->queue_no);\n\t\t__napi_schedule(&priv->napi);\n\t}\n\n\t \n\tif (unlikely((status & rx_bump_tc) &&\n\t\t     (priv->rx_tc != SXGBE_MTL_SFMODE) &&\n\t\t     (priv->rx_tc < 128))) {\n\t\t \n\t\tpriv->rx_tc += 32;\n\t\tpriv->hw->mtl->set_rx_mtl_mode(priv->ioaddr,\n\t\t\t\t\t       rxq->queue_no, priv->rx_tc);\n\t\tpriv->xstats.rx_threshold = priv->rx_tc;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline u64 sxgbe_get_stat64(void __iomem *ioaddr, int reg_lo, int reg_hi)\n{\n\tu64 val = readl(ioaddr + reg_lo);\n\n\tval |= ((u64)readl(ioaddr + reg_hi)) << 32;\n\n\treturn val;\n}\n\n\n \nstatic void sxgbe_get_stats64(struct net_device *dev,\n\t\t\t      struct rtnl_link_stats64 *stats)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\tvoid __iomem *ioaddr = priv->ioaddr;\n\tu64 count;\n\n\tspin_lock(&priv->stats_lock);\n\t \n\twritel(SXGBE_MMC_CTRL_CNT_FRZ, ioaddr + SXGBE_MMC_CTL_REG);\n\n\tstats->rx_bytes = sxgbe_get_stat64(ioaddr,\n\t\t\t\t\t   SXGBE_MMC_RXOCTETLO_GCNT_REG,\n\t\t\t\t\t   SXGBE_MMC_RXOCTETHI_GCNT_REG);\n\n\tstats->rx_packets = sxgbe_get_stat64(ioaddr,\n\t\t\t\t\t     SXGBE_MMC_RXFRAMELO_GBCNT_REG,\n\t\t\t\t\t     SXGBE_MMC_RXFRAMEHI_GBCNT_REG);\n\n\tstats->multicast = sxgbe_get_stat64(ioaddr,\n\t\t\t\t\t    SXGBE_MMC_RXMULTILO_GCNT_REG,\n\t\t\t\t\t    SXGBE_MMC_RXMULTIHI_GCNT_REG);\n\n\tstats->rx_crc_errors = sxgbe_get_stat64(ioaddr,\n\t\t\t\t\t\tSXGBE_MMC_RXCRCERRLO_REG,\n\t\t\t\t\t\tSXGBE_MMC_RXCRCERRHI_REG);\n\n\tstats->rx_length_errors = sxgbe_get_stat64(ioaddr,\n\t\t\t\t\t\t  SXGBE_MMC_RXLENERRLO_REG,\n\t\t\t\t\t\t  SXGBE_MMC_RXLENERRHI_REG);\n\n\tstats->rx_missed_errors = sxgbe_get_stat64(ioaddr,\n\t\t\t\t\t\t   SXGBE_MMC_RXFIFOOVERFLOWLO_GBCNT_REG,\n\t\t\t\t\t\t   SXGBE_MMC_RXFIFOOVERFLOWHI_GBCNT_REG);\n\n\tstats->tx_bytes = sxgbe_get_stat64(ioaddr,\n\t\t\t\t\t   SXGBE_MMC_TXOCTETLO_GCNT_REG,\n\t\t\t\t\t   SXGBE_MMC_TXOCTETHI_GCNT_REG);\n\n\tcount = sxgbe_get_stat64(ioaddr, SXGBE_MMC_TXFRAMELO_GBCNT_REG,\n\t\t\t\t SXGBE_MMC_TXFRAMEHI_GBCNT_REG);\n\n\tstats->tx_errors = sxgbe_get_stat64(ioaddr, SXGBE_MMC_TXFRAMELO_GCNT_REG,\n\t\t\t\t\t    SXGBE_MMC_TXFRAMEHI_GCNT_REG);\n\tstats->tx_errors = count - stats->tx_errors;\n\tstats->tx_packets = count;\n\tstats->tx_fifo_errors = sxgbe_get_stat64(ioaddr, SXGBE_MMC_TXUFLWLO_GBCNT_REG,\n\t\t\t\t\t\t SXGBE_MMC_TXUFLWHI_GBCNT_REG);\n\twritel(0, ioaddr + SXGBE_MMC_CTL_REG);\n\tspin_unlock(&priv->stats_lock);\n}\n\n \nstatic int sxgbe_set_features(struct net_device *dev,\n\t\t\t      netdev_features_t features)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\tnetdev_features_t changed = dev->features ^ features;\n\n\tif (changed & NETIF_F_RXCSUM) {\n\t\tif (features & NETIF_F_RXCSUM) {\n\t\t\tpriv->hw->mac->enable_rx_csum(priv->ioaddr);\n\t\t\tpriv->rxcsum_insertion = true;\n\t\t} else {\n\t\t\tpriv->hw->mac->disable_rx_csum(priv->ioaddr);\n\t\t\tpriv->rxcsum_insertion = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sxgbe_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tdev->mtu = new_mtu;\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\t \n\tsxgbe_release(dev);\n\treturn sxgbe_open(dev);\n}\n\nstatic void sxgbe_set_umac_addr(void __iomem *ioaddr, unsigned char *addr,\n\t\t\t\tunsigned int reg_n)\n{\n\tunsigned long data;\n\n\tdata = (addr[5] << 8) | addr[4];\n\t \n\twritel(data | SXGBE_HI_REG_AE, ioaddr + SXGBE_ADDR_HIGH(reg_n));\n\tdata = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) | addr[0];\n\twritel(data, ioaddr + SXGBE_ADDR_LOW(reg_n));\n}\n\n \nstatic void sxgbe_set_rx_mode(struct net_device *dev)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\tvoid __iomem *ioaddr = (void __iomem *)priv->ioaddr;\n\tunsigned int value = 0;\n\tu32 mc_filter[2];\n\tstruct netdev_hw_addr *ha;\n\tint reg = 1;\n\n\tnetdev_dbg(dev, \"%s: # mcasts %d, # unicast %d\\n\",\n\t\t   __func__, netdev_mc_count(dev), netdev_uc_count(dev));\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tvalue = SXGBE_FRAME_FILTER_PR;\n\n\t} else if ((netdev_mc_count(dev) > SXGBE_HASH_TABLE_SIZE) ||\n\t\t   (dev->flags & IFF_ALLMULTI)) {\n\t\tvalue = SXGBE_FRAME_FILTER_PM;\t \n\t\twritel(0xffffffff, ioaddr + SXGBE_HASH_HIGH);\n\t\twritel(0xffffffff, ioaddr + SXGBE_HASH_LOW);\n\n\t} else if (!netdev_mc_empty(dev)) {\n\t\t \n\t\tvalue = SXGBE_FRAME_FILTER_HMC;\n\n\t\tmemset(mc_filter, 0, sizeof(mc_filter));\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t \n\t\t\tint bit_nr = bitrev32(~crc32_le(~0, ha->addr, 6)) >> 26;\n\n\t\t\t \n\t\t\tmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\n\t\t}\n\t\twritel(mc_filter[0], ioaddr + SXGBE_HASH_LOW);\n\t\twritel(mc_filter[1], ioaddr + SXGBE_HASH_HIGH);\n\t}\n\n\t \n\tif (netdev_uc_count(dev) > SXGBE_MAX_PERFECT_ADDRESSES)\n\t\t \n\t\tvalue |= SXGBE_FRAME_FILTER_PR;\n\telse {\n\t\tnetdev_for_each_uc_addr(ha, dev) {\n\t\t\tsxgbe_set_umac_addr(ioaddr, ha->addr, reg);\n\t\t\treg++;\n\t\t}\n\t}\n#ifdef FRAME_FILTER_DEBUG\n\t \n\tvalue |= SXGBE_FRAME_FILTER_RA;\n#endif\n\twritel(value, ioaddr + SXGBE_FRAME_FILTER);\n\n\tnetdev_dbg(dev, \"Filter: 0x%08x\\n\\tHash: HI 0x%08x, LO 0x%08x\\n\",\n\t\t   readl(ioaddr + SXGBE_FRAME_FILTER),\n\t\t   readl(ioaddr + SXGBE_HASH_HIGH),\n\t\t   readl(ioaddr + SXGBE_HASH_LOW));\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void sxgbe_poll_controller(struct net_device *dev)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(dev);\n\n\tdisable_irq(priv->irq);\n\tsxgbe_rx_interrupt(priv->irq, dev);\n\tenable_irq(priv->irq);\n}\n#endif\n\n \nstatic int sxgbe_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\tret = phy_do_ioctl(dev, rq, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct net_device_ops sxgbe_netdev_ops = {\n\t.ndo_open\t\t= sxgbe_open,\n\t.ndo_start_xmit\t\t= sxgbe_xmit,\n\t.ndo_stop\t\t= sxgbe_release,\n\t.ndo_get_stats64\t= sxgbe_get_stats64,\n\t.ndo_change_mtu\t\t= sxgbe_change_mtu,\n\t.ndo_set_features\t= sxgbe_set_features,\n\t.ndo_set_rx_mode\t= sxgbe_set_rx_mode,\n\t.ndo_tx_timeout\t\t= sxgbe_tx_timeout,\n\t.ndo_eth_ioctl\t\t= sxgbe_ioctl,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= sxgbe_poll_controller,\n#endif\n\t.ndo_set_mac_address\t= eth_mac_addr,\n};\n\n \nstatic void sxgbe_get_ops(struct sxgbe_ops * const ops_ptr)\n{\n\tops_ptr->mac\t\t= sxgbe_get_core_ops();\n\tops_ptr->desc\t\t= sxgbe_get_desc_ops();\n\tops_ptr->dma\t\t= sxgbe_get_dma_ops();\n\tops_ptr->mtl\t\t= sxgbe_get_mtl_ops();\n\n\t \n\tops_ptr->mii.addr\t= SXGBE_MDIO_SCMD_ADD_REG;\n\tops_ptr->mii.data\t= SXGBE_MDIO_SCMD_DATA_REG;\n\n\t \n\tops_ptr->link.port\t= 0;\n\tops_ptr->link.duplex\t= 0;\n\tops_ptr->link.speed\t= SXGBE_SPEED_10G;\n}\n\n \nstatic int sxgbe_hw_init(struct sxgbe_priv_data * const priv)\n{\n\tu32 ctrl_ids;\n\n\tpriv->hw = kmalloc(sizeof(*priv->hw), GFP_KERNEL);\n\tif(!priv->hw)\n\t\treturn -ENOMEM;\n\n\t \n\tsxgbe_get_ops(priv->hw);\n\n\t \n\tctrl_ids = priv->hw->mac->get_controller_version(priv->ioaddr);\n\tpriv->hw->ctrl_uid = (ctrl_ids & 0x00ff0000) >> 16;\n\tpriv->hw->ctrl_id = (ctrl_ids & 0x000000ff);\n\tpr_info(\"user ID: 0x%x, Controller ID: 0x%x\\n\",\n\t\tpriv->hw->ctrl_uid, priv->hw->ctrl_id);\n\n\t \n\tif (!sxgbe_get_hw_features(priv))\n\t\tpr_info(\"Hardware features not found\\n\");\n\n\tif (priv->hw_cap.tx_csum_offload)\n\t\tpr_info(\"TX Checksum offload supported\\n\");\n\n\tif (priv->hw_cap.rx_csum_offload)\n\t\tpr_info(\"RX Checksum offload supported\\n\");\n\n\treturn 0;\n}\n\nstatic int sxgbe_sw_reset(void __iomem *addr)\n{\n\tint retry_count = 10;\n\n\twritel(SXGBE_DMA_SOFT_RESET, addr + SXGBE_DMA_MODE_REG);\n\twhile (retry_count--) {\n\t\tif (!(readl(addr + SXGBE_DMA_MODE_REG) &\n\t\t      SXGBE_DMA_SOFT_RESET))\n\t\t\tbreak;\n\t\tmdelay(10);\n\t}\n\n\tif (retry_count < 0)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n \nstruct sxgbe_priv_data *sxgbe_drv_probe(struct device *device,\n\t\t\t\t\tstruct sxgbe_plat_data *plat_dat,\n\t\t\t\t\tvoid __iomem *addr)\n{\n\tstruct sxgbe_priv_data *priv;\n\tstruct net_device *ndev;\n\tint ret;\n\tu8 queue_num;\n\n\tndev = alloc_etherdev_mqs(sizeof(struct sxgbe_priv_data),\n\t\t\t\t  SXGBE_TX_QUEUES, SXGBE_RX_QUEUES);\n\tif (!ndev)\n\t\treturn NULL;\n\n\tSET_NETDEV_DEV(ndev, device);\n\n\tpriv = netdev_priv(ndev);\n\tpriv->device = device;\n\tpriv->dev = ndev;\n\n\tsxgbe_set_ethtool_ops(ndev);\n\tpriv->plat = plat_dat;\n\tpriv->ioaddr = addr;\n\n\tret = sxgbe_sw_reset(priv->ioaddr);\n\tif (ret)\n\t\tgoto error_free_netdev;\n\n\t \n\tsxgbe_verify_args();\n\n\t \n\tret = sxgbe_hw_init(priv);\n\tif (ret)\n\t\tgoto error_free_netdev;\n\n\t \n\tret = txring_mem_alloc(priv);\n\tif (ret)\n\t\tgoto error_free_hw;\n\n\tret = rxring_mem_alloc(priv);\n\tif (ret)\n\t\tgoto error_free_hw;\n\n\tndev->netdev_ops = &sxgbe_netdev_ops;\n\n\tndev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\n\t\tNETIF_F_RXCSUM | NETIF_F_TSO | NETIF_F_TSO6 |\n\t\tNETIF_F_GRO;\n\tndev->features |= ndev->hw_features | NETIF_F_HIGHDMA;\n\tndev->watchdog_timeo = msecs_to_jiffies(TX_TIMEO);\n\n\t \n\tndev->priv_flags |= IFF_UNICAST_FLT;\n\n\t \n\tndev->min_mtu = MIN_MTU;\n\tndev->max_mtu = MAX_MTU;\n\n\tpriv->msg_enable = netif_msg_init(debug, default_msg_level);\n\n\t \n\tif (priv->hw_cap.tcpseg_offload) {\n\t\tSXGBE_FOR_EACH_QUEUE(SXGBE_TX_QUEUES, queue_num) {\n\t\t\tpriv->hw->dma->enable_tso(priv->ioaddr, queue_num);\n\t\t}\n\t}\n\n\t \n\tif (priv->hw_cap.rx_csum_offload) {\n\t\tpriv->hw->mac->enable_rx_csum(priv->ioaddr);\n\t\tpriv->rxcsum_insertion = true;\n\t}\n\n\t \n\tpriv->rx_pause = 1;\n\tpriv->tx_pause = 1;\n\n\t \n\tif (!priv->plat->riwt_off) {\n\t\tpriv->use_riwt = 1;\n\t\tpr_info(\"Enable RX Mitigation via HW Watchdog Timer\\n\");\n\t}\n\n\tnetif_napi_add(ndev, &priv->napi, sxgbe_poll);\n\n\tspin_lock_init(&priv->stats_lock);\n\n\tpriv->sxgbe_clk = clk_get(priv->device, SXGBE_RESOURCE_NAME);\n\tif (IS_ERR(priv->sxgbe_clk)) {\n\t\tnetdev_warn(ndev, \"%s: warning: cannot get CSR clock\\n\",\n\t\t\t    __func__);\n\t\tgoto error_napi_del;\n\t}\n\n\t \n\tif (!priv->plat->clk_csr)\n\t\tsxgbe_clk_csr_set(priv);\n\telse\n\t\tpriv->clk_csr = priv->plat->clk_csr;\n\n\t \n\tret = sxgbe_mdio_register(ndev);\n\tif (ret < 0) {\n\t\tnetdev_dbg(ndev, \"%s: MDIO bus (id: %d) registration failed\\n\",\n\t\t\t   __func__, priv->plat->bus_id);\n\t\tgoto error_clk_put;\n\t}\n\n\tret = register_netdev(ndev);\n\tif (ret) {\n\t\tpr_err(\"%s: ERROR %i registering the device\\n\", __func__, ret);\n\t\tgoto error_mdio_unregister;\n\t}\n\n\tsxgbe_check_ether_addr(priv);\n\n\treturn priv;\n\nerror_mdio_unregister:\n\tsxgbe_mdio_unregister(ndev);\nerror_clk_put:\n\tclk_put(priv->sxgbe_clk);\nerror_napi_del:\n\tnetif_napi_del(&priv->napi);\nerror_free_hw:\n\tkfree(priv->hw);\nerror_free_netdev:\n\tfree_netdev(ndev);\n\n\treturn NULL;\n}\n\n \nvoid sxgbe_drv_remove(struct net_device *ndev)\n{\n\tstruct sxgbe_priv_data *priv = netdev_priv(ndev);\n\tu8 queue_num;\n\n\tnetdev_info(ndev, \"%s: removing driver\\n\", __func__);\n\n\tSXGBE_FOR_EACH_QUEUE(SXGBE_RX_QUEUES, queue_num) {\n\t\tpriv->hw->mac->disable_rxqueue(priv->ioaddr, queue_num);\n\t}\n\n\tpriv->hw->dma->stop_rx(priv->ioaddr, SXGBE_RX_QUEUES);\n\tpriv->hw->dma->stop_tx(priv->ioaddr, SXGBE_TX_QUEUES);\n\n\tpriv->hw->mac->enable_tx(priv->ioaddr, false);\n\tpriv->hw->mac->enable_rx(priv->ioaddr, false);\n\n\tunregister_netdev(ndev);\n\n\tsxgbe_mdio_unregister(ndev);\n\n\tclk_put(priv->sxgbe_clk);\n\n\tnetif_napi_del(&priv->napi);\n\n\tkfree(priv->hw);\n\n\tfree_netdev(ndev);\n}\n\n#ifdef CONFIG_PM\nint sxgbe_suspend(struct net_device *ndev)\n{\n\treturn 0;\n}\n\nint sxgbe_resume(struct net_device *ndev)\n{\n\treturn 0;\n}\n\nint sxgbe_freeze(struct net_device *ndev)\n{\n\treturn -ENOSYS;\n}\n\nint sxgbe_restore(struct net_device *ndev)\n{\n\treturn -ENOSYS;\n}\n#endif  \n\n \nstatic int __init sxgbe_init(void)\n{\n\tint ret;\n\n\tret = sxgbe_register_platform();\n\tif (ret)\n\t\tgoto err;\n\treturn 0;\nerr:\n\tpr_err(\"driver registration failed\\n\");\n\treturn ret;\n}\n\nstatic void __exit sxgbe_exit(void)\n{\n\tsxgbe_unregister_platform();\n}\n\nmodule_init(sxgbe_init);\nmodule_exit(sxgbe_exit);\n\n#ifndef MODULE\nstatic int __init sxgbe_cmdline_opt(char *str)\n{\n\tchar *opt;\n\n\tif (!str || !*str)\n\t\treturn 1;\n\twhile ((opt = strsep(&str, \",\")) != NULL) {\n\t\tif (!strncmp(opt, \"eee_timer:\", 10)) {\n\t\t\tif (kstrtoint(opt + 10, 0, &eee_timer))\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn 1;\n\nerr:\n\tpr_err(\"%s: ERROR broken module parameter conversion\\n\", __func__);\n\treturn 1;\n}\n\n__setup(\"sxgbeeth=\", sxgbe_cmdline_opt);\n#endif  \n\n\n\nMODULE_DESCRIPTION(\"Samsung 10G/2.5G/1G Ethernet PLATFORM driver\");\n\nMODULE_PARM_DESC(debug, \"Message Level (-1: default, 0: no output, 16: all)\");\nMODULE_PARM_DESC(eee_timer, \"EEE-LPI Default LS timer value\");\n\nMODULE_AUTHOR(\"Siva Reddy Kallam <siva.kallam@samsung.com>\");\nMODULE_AUTHOR(\"ByungHo An <bh74.an@samsung.com>\");\nMODULE_AUTHOR(\"Girish K S <ks.giri@samsung.com>\");\nMODULE_AUTHOR(\"Vipul Pandya <vipul.pandya@samsung.com>\");\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}