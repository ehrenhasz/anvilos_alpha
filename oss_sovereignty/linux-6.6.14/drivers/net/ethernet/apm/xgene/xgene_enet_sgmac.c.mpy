{
  "module_name": "xgene_enet_sgmac.c",
  "hash_id": "3ed7a9fb0a064fbf98aee5639ebd7ec8c176bba63231376dbfb5e39c4aa0feab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/apm/xgene/xgene_enet_sgmac.c",
  "human_readable_source": "\n \n\n#include \"xgene_enet_main.h\"\n#include \"xgene_enet_hw.h\"\n#include \"xgene_enet_sgmac.h\"\n#include \"xgene_enet_xgmac.h\"\n\nstatic void xgene_enet_wr_csr(struct xgene_enet_pdata *p, u32 offset, u32 val)\n{\n\tiowrite32(val, p->eth_csr_addr + offset);\n}\n\nstatic void xgene_enet_wr_clkrst_csr(struct xgene_enet_pdata *p, u32 offset,\n\t\t\t\t     u32 val)\n{\n\tiowrite32(val, p->base_addr + offset);\n}\n\nstatic void xgene_enet_wr_ring_if(struct xgene_enet_pdata *p,\n\t\t\t\t  u32 offset, u32 val)\n{\n\tiowrite32(val, p->eth_ring_if_addr + offset);\n}\n\nstatic void xgene_enet_wr_diag_csr(struct xgene_enet_pdata *p,\n\t\t\t\t   u32 offset, u32 val)\n{\n\tiowrite32(val, p->eth_diag_csr_addr + offset);\n}\n\nstatic void xgene_enet_wr_mcx_csr(struct xgene_enet_pdata *pdata,\n\t\t\t\t  u32 offset, u32 val)\n{\n\tvoid __iomem *addr = pdata->mcx_mac_csr_addr + offset;\n\n\tiowrite32(val, addr);\n}\n\nstatic u32 xgene_enet_rd_csr(struct xgene_enet_pdata *p, u32 offset)\n{\n\treturn ioread32(p->eth_csr_addr + offset);\n}\n\nstatic u32 xgene_enet_rd_diag_csr(struct xgene_enet_pdata *p, u32 offset)\n{\n\treturn ioread32(p->eth_diag_csr_addr + offset);\n}\n\nstatic u32 xgene_enet_rd_mcx_csr(struct xgene_enet_pdata *p, u32 offset)\n{\n\treturn ioread32(p->mcx_mac_csr_addr + offset);\n}\n\nstatic int xgene_enet_ecc_init(struct xgene_enet_pdata *p)\n{\n\tstruct net_device *ndev = p->ndev;\n\tu32 data, shutdown;\n\tint i = 0;\n\n\tshutdown = xgene_enet_rd_diag_csr(p, ENET_CFG_MEM_RAM_SHUTDOWN_ADDR);\n\tdata = xgene_enet_rd_diag_csr(p, ENET_BLOCK_MEM_RDY_ADDR);\n\n\tif (!shutdown && data == ~0U) {\n\t\tnetdev_dbg(ndev, \"+ ecc_init done, skipping\\n\");\n\t\treturn 0;\n\t}\n\n\txgene_enet_wr_diag_csr(p, ENET_CFG_MEM_RAM_SHUTDOWN_ADDR, 0);\n\tdo {\n\t\tusleep_range(100, 110);\n\t\tdata = xgene_enet_rd_diag_csr(p, ENET_BLOCK_MEM_RDY_ADDR);\n\t\tif (data == ~0U)\n\t\t\treturn 0;\n\t} while (++i < 10);\n\n\tnetdev_err(ndev, \"Failed to release memory from shutdown\\n\");\n\treturn -ENODEV;\n}\n\nstatic void xgene_sgmac_get_drop_cnt(struct xgene_enet_pdata *pdata,\n\t\t\t\t     u32 *rx, u32 *tx)\n{\n\tu32 addr, count;\n\n\taddr = (pdata->enet_id != XGENE_ENET1) ?\n\t\tXG_MCX_ICM_ECM_DROP_COUNT_REG0_ADDR :\n\t\tICM_ECM_DROP_COUNT_REG0_ADDR + pdata->port_id * OFFSET_4;\n\tcount = xgene_enet_rd_mcx_csr(pdata, addr);\n\t*rx = ICM_DROP_COUNT(count);\n\t*tx = ECM_DROP_COUNT(count);\n\t \n\taddr = (pdata->enet_id != XGENE_ENET1) ?\n\t\tXG_MCX_ECM_CONFIG0_REG_0_ADDR :\n\t\tECM_CONFIG0_REG_0_ADDR + pdata->port_id * OFFSET_4;\n\txgene_enet_rd_mcx_csr(pdata, addr);\n}\n\nstatic void xgene_enet_config_ring_if_assoc(struct xgene_enet_pdata *p)\n{\n\tu32 val;\n\n\tval = (p->enet_id == XGENE_ENET1) ? 0xffffffff : 0;\n\txgene_enet_wr_ring_if(p, ENET_CFGSSQMIWQASSOC_ADDR, val);\n\txgene_enet_wr_ring_if(p, ENET_CFGSSQMIFPQASSOC_ADDR, val);\n}\n\nstatic void xgene_mii_phy_write(struct xgene_enet_pdata *p, u8 phy_id,\n\t\t\t\tu32 reg, u16 data)\n{\n\tu32 addr, wr_data, done;\n\tint i;\n\n\taddr = PHY_ADDR(phy_id) | REG_ADDR(reg);\n\txgene_enet_wr_mac(p, MII_MGMT_ADDRESS_ADDR, addr);\n\n\twr_data = PHY_CONTROL(data);\n\txgene_enet_wr_mac(p, MII_MGMT_CONTROL_ADDR, wr_data);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tdone = xgene_enet_rd_mac(p, MII_MGMT_INDICATORS_ADDR);\n\t\tif (!(done & BUSY_MASK))\n\t\t\treturn;\n\t\tusleep_range(10, 20);\n\t}\n\n\tnetdev_err(p->ndev, \"MII_MGMT write failed\\n\");\n}\n\nstatic u32 xgene_mii_phy_read(struct xgene_enet_pdata *p, u8 phy_id, u32 reg)\n{\n\tu32 addr, data, done;\n\tint i;\n\n\taddr = PHY_ADDR(phy_id) | REG_ADDR(reg);\n\txgene_enet_wr_mac(p, MII_MGMT_ADDRESS_ADDR, addr);\n\txgene_enet_wr_mac(p, MII_MGMT_COMMAND_ADDR, READ_CYCLE_MASK);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tdone = xgene_enet_rd_mac(p, MII_MGMT_INDICATORS_ADDR);\n\t\tif (!(done & BUSY_MASK)) {\n\t\t\tdata = xgene_enet_rd_mac(p, MII_MGMT_STATUS_ADDR);\n\t\t\txgene_enet_wr_mac(p, MII_MGMT_COMMAND_ADDR, 0);\n\n\t\t\treturn data;\n\t\t}\n\t\tusleep_range(10, 20);\n\t}\n\n\tnetdev_err(p->ndev, \"MII_MGMT read failed\\n\");\n\n\treturn 0;\n}\n\nstatic void xgene_sgmac_reset(struct xgene_enet_pdata *p)\n{\n\txgene_enet_wr_mac(p, MAC_CONFIG_1_ADDR, SOFT_RESET1);\n\txgene_enet_wr_mac(p, MAC_CONFIG_1_ADDR, 0);\n}\n\nstatic void xgene_sgmac_set_mac_addr(struct xgene_enet_pdata *p)\n{\n\tconst u8 *dev_addr = p->ndev->dev_addr;\n\tu32 addr0, addr1;\n\n\taddr0 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |\n\t\t(dev_addr[1] << 8) | dev_addr[0];\n\txgene_enet_wr_mac(p, STATION_ADDR0_ADDR, addr0);\n\n\taddr1 = xgene_enet_rd_mac(p, STATION_ADDR1_ADDR);\n\taddr1 |= (dev_addr[5] << 24) | (dev_addr[4] << 16);\n\txgene_enet_wr_mac(p, STATION_ADDR1_ADDR, addr1);\n}\n\nstatic u32 xgene_enet_link_status(struct xgene_enet_pdata *p)\n{\n\tu32 data;\n\n\tdata = xgene_mii_phy_read(p, INT_PHY_ADDR,\n\t\t\t\t  SGMII_BASE_PAGE_ABILITY_ADDR >> 2);\n\n\tif (LINK_SPEED(data) == PHY_SPEED_1000)\n\t\tp->phy_speed = SPEED_1000;\n\telse if (LINK_SPEED(data) == PHY_SPEED_100)\n\t\tp->phy_speed = SPEED_100;\n\telse\n\t\tp->phy_speed = SPEED_10;\n\n\treturn data & LINK_UP;\n}\n\nstatic void xgene_sgmii_configure(struct xgene_enet_pdata *p)\n{\n\txgene_mii_phy_write(p, INT_PHY_ADDR, SGMII_TBI_CONTROL_ADDR >> 2,\n\t\t\t    0x8000);\n\txgene_mii_phy_write(p, INT_PHY_ADDR, SGMII_CONTROL_ADDR >> 2, 0x9000);\n\txgene_mii_phy_write(p, INT_PHY_ADDR, SGMII_TBI_CONTROL_ADDR >> 2, 0);\n}\n\nstatic void xgene_sgmii_tbi_control_reset(struct xgene_enet_pdata *p)\n{\n\txgene_mii_phy_write(p, INT_PHY_ADDR, SGMII_TBI_CONTROL_ADDR >> 2,\n\t\t\t    0x8000);\n\txgene_mii_phy_write(p, INT_PHY_ADDR, SGMII_TBI_CONTROL_ADDR >> 2, 0);\n}\n\nstatic void xgene_sgmii_reset(struct xgene_enet_pdata *p)\n{\n\tu32 value;\n\n\tif (p->phy_speed == SPEED_UNKNOWN)\n\t\treturn;\n\n\tvalue = xgene_mii_phy_read(p, INT_PHY_ADDR,\n\t\t\t\t   SGMII_BASE_PAGE_ABILITY_ADDR >> 2);\n\tif (!(value & LINK_UP))\n\t\txgene_sgmii_tbi_control_reset(p);\n}\n\nstatic void xgene_sgmac_set_speed(struct xgene_enet_pdata *p)\n{\n\tu32 icm0_addr, icm2_addr, debug_addr;\n\tu32 icm0, icm2, intf_ctl;\n\tu32 mc2, value;\n\n\txgene_sgmii_reset(p);\n\n\tif (p->enet_id == XGENE_ENET1) {\n\t\ticm0_addr = ICM_CONFIG0_REG_0_ADDR + p->port_id * OFFSET_8;\n\t\ticm2_addr = ICM_CONFIG2_REG_0_ADDR + p->port_id * OFFSET_4;\n\t\tdebug_addr = DEBUG_REG_ADDR;\n\t} else {\n\t\ticm0_addr = XG_MCX_ICM_CONFIG0_REG_0_ADDR;\n\t\ticm2_addr = XG_MCX_ICM_CONFIG2_REG_0_ADDR;\n\t\tdebug_addr = XG_DEBUG_REG_ADDR;\n\t}\n\n\ticm0 = xgene_enet_rd_mcx_csr(p, icm0_addr);\n\ticm2 = xgene_enet_rd_mcx_csr(p, icm2_addr);\n\tmc2 = xgene_enet_rd_mac(p, MAC_CONFIG_2_ADDR);\n\tintf_ctl = xgene_enet_rd_mac(p, INTERFACE_CONTROL_ADDR);\n\n\tswitch (p->phy_speed) {\n\tcase SPEED_10:\n\t\tENET_INTERFACE_MODE2_SET(&mc2, 1);\n\t\tintf_ctl &= ~(ENET_LHD_MODE | ENET_GHD_MODE);\n\t\tCFG_MACMODE_SET(&icm0, 0);\n\t\tCFG_WAITASYNCRD_SET(&icm2, 500);\n\t\tbreak;\n\tcase SPEED_100:\n\t\tENET_INTERFACE_MODE2_SET(&mc2, 1);\n\t\tintf_ctl &= ~ENET_GHD_MODE;\n\t\tintf_ctl |= ENET_LHD_MODE;\n\t\tCFG_MACMODE_SET(&icm0, 1);\n\t\tCFG_WAITASYNCRD_SET(&icm2, 80);\n\t\tbreak;\n\tdefault:\n\t\tENET_INTERFACE_MODE2_SET(&mc2, 2);\n\t\tintf_ctl &= ~ENET_LHD_MODE;\n\t\tintf_ctl |= ENET_GHD_MODE;\n\t\tCFG_MACMODE_SET(&icm0, 2);\n\t\tCFG_WAITASYNCRD_SET(&icm2, 16);\n\t\tvalue = xgene_enet_rd_csr(p, debug_addr);\n\t\tvalue |= CFG_BYPASS_UNISEC_TX | CFG_BYPASS_UNISEC_RX;\n\t\txgene_enet_wr_csr(p, debug_addr, value);\n\t\tbreak;\n\t}\n\n\tmc2 |= FULL_DUPLEX2 | PAD_CRC;\n\txgene_enet_wr_mac(p, MAC_CONFIG_2_ADDR, mc2);\n\txgene_enet_wr_mac(p, INTERFACE_CONTROL_ADDR, intf_ctl);\n\txgene_enet_wr_mcx_csr(p, icm0_addr, icm0);\n\txgene_enet_wr_mcx_csr(p, icm2_addr, icm2);\n}\n\nstatic void xgene_sgmac_set_frame_size(struct xgene_enet_pdata *pdata, int size)\n{\n\txgene_enet_wr_mac(pdata, MAX_FRAME_LEN_ADDR, size);\n}\n\nstatic void xgene_sgmii_enable_autoneg(struct xgene_enet_pdata *p)\n{\n\tu32 data, loop = 10;\n\n\txgene_sgmii_configure(p);\n\n\twhile (loop--) {\n\t\tdata = xgene_mii_phy_read(p, INT_PHY_ADDR,\n\t\t\t\t\t  SGMII_STATUS_ADDR >> 2);\n\t\tif ((data & AUTO_NEG_COMPLETE) && (data & LINK_STATUS))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\tif (!(data & AUTO_NEG_COMPLETE) || !(data & LINK_STATUS))\n\t\tnetdev_err(p->ndev, \"Auto-negotiation failed\\n\");\n}\n\nstatic void xgene_sgmac_rxtx(struct xgene_enet_pdata *p, u32 bits, bool set)\n{\n\tu32 data;\n\n\tdata = xgene_enet_rd_mac(p, MAC_CONFIG_1_ADDR);\n\n\tif (set)\n\t\tdata |= bits;\n\telse\n\t\tdata &= ~bits;\n\n\txgene_enet_wr_mac(p, MAC_CONFIG_1_ADDR, data);\n}\n\nstatic void xgene_sgmac_flowctl_tx(struct xgene_enet_pdata *p, bool enable)\n{\n\txgene_sgmac_rxtx(p, TX_FLOW_EN, enable);\n\n\tp->mac_ops->enable_tx_pause(p, enable);\n}\n\nstatic void xgene_sgmac_flowctl_rx(struct xgene_enet_pdata *pdata, bool enable)\n{\n\txgene_sgmac_rxtx(pdata, RX_FLOW_EN, enable);\n}\n\nstatic void xgene_sgmac_init(struct xgene_enet_pdata *p)\n{\n\tu32 pause_thres_reg, pause_off_thres_reg;\n\tu32 enet_spare_cfg_reg, rsif_config_reg;\n\tu32 cfg_bypass_reg, rx_dv_gate_reg;\n\tu32 data, data1, data2, offset;\n\tu32 multi_dpf_reg;\n\n\tif (!(p->enet_id == XGENE_ENET2 && p->mdio_driver))\n\t\txgene_sgmac_reset(p);\n\n\txgene_sgmii_enable_autoneg(p);\n\txgene_sgmac_set_speed(p);\n\txgene_sgmac_set_mac_addr(p);\n\n\tif (p->enet_id == XGENE_ENET1) {\n\t\tenet_spare_cfg_reg = ENET_SPARE_CFG_REG_ADDR;\n\t\trsif_config_reg = RSIF_CONFIG_REG_ADDR;\n\t\tcfg_bypass_reg = CFG_BYPASS_ADDR;\n\t\toffset = p->port_id * OFFSET_4;\n\t\trx_dv_gate_reg = SG_RX_DV_GATE_REG_0_ADDR + offset;\n\t} else {\n\t\tenet_spare_cfg_reg = XG_ENET_SPARE_CFG_REG_ADDR;\n\t\trsif_config_reg = XG_RSIF_CONFIG_REG_ADDR;\n\t\tcfg_bypass_reg = XG_CFG_BYPASS_ADDR;\n\t\trx_dv_gate_reg = XG_MCX_RX_DV_GATE_REG_0_ADDR;\n\t}\n\n\tdata = xgene_enet_rd_csr(p, enet_spare_cfg_reg);\n\tdata |= MPA_IDLE_WITH_QMI_EMPTY;\n\txgene_enet_wr_csr(p, enet_spare_cfg_reg, data);\n\n\t \n\tdata = xgene_enet_rd_mac(p, MII_MGMT_CONFIG_ADDR);\n\tMGMT_CLOCK_SEL_SET(&data, 7);\n\txgene_enet_wr_mac(p, MII_MGMT_CONFIG_ADDR, data);\n\n\t \n\tdata = xgene_enet_rd_csr(p, rsif_config_reg);\n\tdata |= CFG_RSIF_FPBUFF_TIMEOUT_EN;\n\txgene_enet_wr_csr(p, rsif_config_reg, data);\n\n\t \n\tmulti_dpf_reg = (p->enet_id == XGENE_ENET1) ? CSR_MULTI_DPF0_ADDR :\n\t\t\t XG_MCX_MULTI_DPF0_ADDR;\n\tdata = xgene_enet_rd_mcx_csr(p, multi_dpf_reg);\n\tdata = (DEF_QUANTA << 16) | (data & 0xffff);\n\txgene_enet_wr_mcx_csr(p, multi_dpf_reg, data);\n\n\tif (p->enet_id != XGENE_ENET1) {\n\t\tdata = xgene_enet_rd_mcx_csr(p, XG_MCX_MULTI_DPF1_ADDR);\n\t\tdata =  (NORM_PAUSE_OPCODE << 16) | (data & 0xFFFF);\n\t\txgene_enet_wr_mcx_csr(p, XG_MCX_MULTI_DPF1_ADDR, data);\n\t}\n\n\tpause_thres_reg = (p->enet_id == XGENE_ENET1) ? RXBUF_PAUSE_THRESH :\n\t\t\t   XG_RXBUF_PAUSE_THRESH;\n\tpause_off_thres_reg = (p->enet_id == XGENE_ENET1) ?\n\t\t\t       RXBUF_PAUSE_OFF_THRESH : 0;\n\n\tif (p->enet_id == XGENE_ENET1) {\n\t\tdata1 = xgene_enet_rd_csr(p, pause_thres_reg);\n\t\tdata2 = xgene_enet_rd_csr(p, pause_off_thres_reg);\n\n\t\tif (!(p->port_id % 2)) {\n\t\t\tdata1 = (data1 & 0xffff0000) | DEF_PAUSE_THRES;\n\t\t\tdata2 = (data2 & 0xffff0000) | DEF_PAUSE_OFF_THRES;\n\t\t} else {\n\t\t\tdata1 = (data1 & 0xffff) | (DEF_PAUSE_THRES << 16);\n\t\t\tdata2 = (data2 & 0xffff) | (DEF_PAUSE_OFF_THRES << 16);\n\t\t}\n\n\t\txgene_enet_wr_csr(p, pause_thres_reg, data1);\n\t\txgene_enet_wr_csr(p, pause_off_thres_reg, data2);\n\t} else {\n\t\tdata = (DEF_PAUSE_OFF_THRES << 16) | DEF_PAUSE_THRES;\n\t\txgene_enet_wr_csr(p, pause_thres_reg, data);\n\t}\n\n\txgene_sgmac_flowctl_tx(p, p->tx_pause);\n\txgene_sgmac_flowctl_rx(p, p->rx_pause);\n\n\t \n\txgene_enet_wr_csr(p, XG_ENET_SPARE_CFG_REG_1_ADDR, 0x84);\n\txgene_enet_wr_csr(p, cfg_bypass_reg, RESUME_TX);\n\txgene_enet_wr_mcx_csr(p, rx_dv_gate_reg, RESUME_RX0);\n}\n\nstatic void xgene_sgmac_rx_enable(struct xgene_enet_pdata *p)\n{\n\txgene_sgmac_rxtx(p, RX_EN, true);\n}\n\nstatic void xgene_sgmac_tx_enable(struct xgene_enet_pdata *p)\n{\n\txgene_sgmac_rxtx(p, TX_EN, true);\n}\n\nstatic void xgene_sgmac_rx_disable(struct xgene_enet_pdata *p)\n{\n\txgene_sgmac_rxtx(p, RX_EN, false);\n}\n\nstatic void xgene_sgmac_tx_disable(struct xgene_enet_pdata *p)\n{\n\txgene_sgmac_rxtx(p, TX_EN, false);\n}\n\nstatic int xgene_enet_reset(struct xgene_enet_pdata *p)\n{\n\tstruct device *dev = &p->pdev->dev;\n\n\tif (!xgene_ring_mgr_init(p))\n\t\treturn -ENODEV;\n\n\tif (p->mdio_driver && p->enet_id == XGENE_ENET2) {\n\t\txgene_enet_config_ring_if_assoc(p);\n\t\treturn 0;\n\t}\n\n\tif (p->enet_id == XGENE_ENET2)\n\t\txgene_enet_wr_clkrst_csr(p, XGENET_CONFIG_REG_ADDR, SGMII_EN);\n\n\tif (dev->of_node) {\n\t\tif (!IS_ERR(p->clk)) {\n\t\t\tclk_prepare_enable(p->clk);\n\t\t\tudelay(5);\n\t\t\tclk_disable_unprepare(p->clk);\n\t\t\tudelay(5);\n\t\t\tclk_prepare_enable(p->clk);\n\t\t\tudelay(5);\n\t\t}\n\t} else {\n#ifdef CONFIG_ACPI\n\t\tacpi_status status;\n\n\t\tstatus = acpi_evaluate_object(ACPI_HANDLE(&p->pdev->dev),\n\t\t\t\t\t      \"_RST\", NULL, NULL);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_evaluate_object(ACPI_HANDLE(&p->pdev->dev),\n\t\t\t\t\t     \"_INI\", NULL, NULL);\n\t\t}\n#endif\n\t}\n\n\tif (!p->port_id) {\n\t\txgene_enet_ecc_init(p);\n\t\txgene_enet_config_ring_if_assoc(p);\n\t}\n\n\treturn 0;\n}\n\nstatic void xgene_enet_cle_bypass(struct xgene_enet_pdata *p,\n\t\t\t\t  u32 dst_ring_num, u16 bufpool_id,\n\t\t\t\t  u16 nxtbufpool_id)\n{\n\tu32 cle_bypass_reg0, cle_bypass_reg1;\n\tu32 offset = p->port_id * MAC_OFFSET;\n\tu32 data, fpsel, nxtfpsel;\n\n\tif (p->enet_id == XGENE_ENET1) {\n\t\tcle_bypass_reg0 = CLE_BYPASS_REG0_0_ADDR;\n\t\tcle_bypass_reg1 = CLE_BYPASS_REG1_0_ADDR;\n\t} else {\n\t\tcle_bypass_reg0 = XCLE_BYPASS_REG0_ADDR;\n\t\tcle_bypass_reg1 = XCLE_BYPASS_REG1_ADDR;\n\t}\n\n\tdata = CFG_CLE_BYPASS_EN0;\n\txgene_enet_wr_csr(p, cle_bypass_reg0 + offset, data);\n\n\tfpsel = xgene_enet_get_fpsel(bufpool_id);\n\tnxtfpsel = xgene_enet_get_fpsel(nxtbufpool_id);\n\tdata = CFG_CLE_DSTQID0(dst_ring_num) | CFG_CLE_FPSEL0(fpsel) |\n\t       CFG_CLE_NXTFPSEL0(nxtfpsel);\n\txgene_enet_wr_csr(p, cle_bypass_reg1 + offset, data);\n}\n\nstatic void xgene_enet_clear(struct xgene_enet_pdata *pdata,\n\t\t\t     struct xgene_enet_desc_ring *ring)\n{\n\tu32 addr, data;\n\n\tif (xgene_enet_is_bufpool(ring->id)) {\n\t\taddr = ENET_CFGSSQMIFPRESET_ADDR;\n\t\tdata = BIT(xgene_enet_get_fpsel(ring->id));\n\t} else {\n\t\taddr = ENET_CFGSSQMIWQRESET_ADDR;\n\t\tdata = BIT(xgene_enet_ring_bufnum(ring->id));\n\t}\n\n\txgene_enet_wr_ring_if(pdata, addr, data);\n}\n\nstatic void xgene_enet_shutdown(struct xgene_enet_pdata *p)\n{\n\tstruct device *dev = &p->pdev->dev;\n\n\tif (dev->of_node) {\n\t\tif (!IS_ERR(p->clk))\n\t\t\tclk_disable_unprepare(p->clk);\n\t}\n}\n\nstatic void xgene_enet_link_state(struct work_struct *work)\n{\n\tstruct xgene_enet_pdata *p = container_of(to_delayed_work(work),\n\t\t\t\t     struct xgene_enet_pdata, link_work);\n\tstruct net_device *ndev = p->ndev;\n\tu32 link, poll_interval;\n\n\tlink = xgene_enet_link_status(p);\n\tif (link) {\n\t\tif (!netif_carrier_ok(ndev)) {\n\t\t\tnetif_carrier_on(ndev);\n\t\t\txgene_sgmac_set_speed(p);\n\t\t\txgene_sgmac_rx_enable(p);\n\t\t\txgene_sgmac_tx_enable(p);\n\t\t\tnetdev_info(ndev, \"Link is Up - %dMbps\\n\",\n\t\t\t\t    p->phy_speed);\n\t\t}\n\t\tpoll_interval = PHY_POLL_LINK_ON;\n\t} else {\n\t\tif (netif_carrier_ok(ndev)) {\n\t\t\txgene_sgmac_rx_disable(p);\n\t\t\txgene_sgmac_tx_disable(p);\n\t\t\tnetif_carrier_off(ndev);\n\t\t\tnetdev_info(ndev, \"Link is Down\\n\");\n\t\t}\n\t\tpoll_interval = PHY_POLL_LINK_OFF;\n\t}\n\n\tschedule_delayed_work(&p->link_work, poll_interval);\n}\n\nstatic void xgene_sgmac_enable_tx_pause(struct xgene_enet_pdata *p, bool enable)\n{\n\tu32 data, ecm_cfg_addr;\n\n\tif (p->enet_id == XGENE_ENET1) {\n\t\tecm_cfg_addr = (!(p->port_id % 2)) ? CSR_ECM_CFG_0_ADDR :\n\t\t\t\tCSR_ECM_CFG_1_ADDR;\n\t} else {\n\t\tecm_cfg_addr = XG_MCX_ECM_CFG_0_ADDR;\n\t}\n\n\tdata = xgene_enet_rd_mcx_csr(p, ecm_cfg_addr);\n\tif (enable)\n\t\tdata |= MULTI_DPF_AUTOCTRL | PAUSE_XON_EN;\n\telse\n\t\tdata &= ~(MULTI_DPF_AUTOCTRL | PAUSE_XON_EN);\n\txgene_enet_wr_mcx_csr(p, ecm_cfg_addr, data);\n}\n\nconst struct xgene_mac_ops xgene_sgmac_ops = {\n\t.init\t\t= xgene_sgmac_init,\n\t.reset\t\t= xgene_sgmac_reset,\n\t.rx_enable\t= xgene_sgmac_rx_enable,\n\t.tx_enable\t= xgene_sgmac_tx_enable,\n\t.rx_disable\t= xgene_sgmac_rx_disable,\n\t.tx_disable\t= xgene_sgmac_tx_disable,\n\t.get_drop_cnt   = xgene_sgmac_get_drop_cnt,\n\t.set_speed\t= xgene_sgmac_set_speed,\n\t.set_mac_addr\t= xgene_sgmac_set_mac_addr,\n\t.set_framesize  = xgene_sgmac_set_frame_size,\n\t.link_state\t= xgene_enet_link_state,\n\t.enable_tx_pause = xgene_sgmac_enable_tx_pause,\n\t.flowctl_tx     = xgene_sgmac_flowctl_tx,\n\t.flowctl_rx     = xgene_sgmac_flowctl_rx\n};\n\nconst struct xgene_port_ops xgene_sgport_ops = {\n\t.reset\t\t= xgene_enet_reset,\n\t.clear\t\t= xgene_enet_clear,\n\t.cle_bypass\t= xgene_enet_cle_bypass,\n\t.shutdown\t= xgene_enet_shutdown\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}