{
  "module_name": "xgene_enet_xgmac.c",
  "hash_id": "76f5f5a089f3576be8ea5e829841655852e796f94bea371b056c7733aa1e4f05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/apm/xgene/xgene_enet_xgmac.c",
  "human_readable_source": "\n \n\n#include <linux/of_gpio.h>\n#include <linux/gpio.h>\n#include \"xgene_enet_main.h\"\n#include \"xgene_enet_hw.h\"\n#include \"xgene_enet_xgmac.h\"\n\nstatic void xgene_enet_wr_csr(struct xgene_enet_pdata *pdata,\n\t\t\t      u32 offset, u32 val)\n{\n\tvoid __iomem *addr = pdata->eth_csr_addr + offset;\n\n\tiowrite32(val, addr);\n}\n\nstatic void xgene_enet_wr_ring_if(struct xgene_enet_pdata *pdata,\n\t\t\t\t  u32 offset, u32 val)\n{\n\tvoid __iomem *addr = pdata->eth_ring_if_addr + offset;\n\n\tiowrite32(val, addr);\n}\n\nstatic void xgene_enet_wr_diag_csr(struct xgene_enet_pdata *pdata,\n\t\t\t\t   u32 offset, u32 val)\n{\n\tvoid __iomem *addr = pdata->eth_diag_csr_addr + offset;\n\n\tiowrite32(val, addr);\n}\n\nstatic bool xgene_enet_wr_indirect(void __iomem *addr, void __iomem *wr,\n\t\t\t\t   void __iomem *cmd, void __iomem *cmd_done,\n\t\t\t\t   u32 wr_addr, u32 wr_data)\n{\n\tu32 done;\n\tu8 wait = 10;\n\n\tiowrite32(wr_addr, addr);\n\tiowrite32(wr_data, wr);\n\tiowrite32(XGENE_ENET_WR_CMD, cmd);\n\n\t \n\twhile (!(done = ioread32(cmd_done)) && wait--)\n\t\tudelay(1);\n\n\tif (!done)\n\t\treturn false;\n\n\tiowrite32(0, cmd);\n\n\treturn true;\n}\n\nstatic void xgene_enet_wr_pcs(struct xgene_enet_pdata *pdata,\n\t\t\t      u32 wr_addr, u32 wr_data)\n{\n\tvoid __iomem *addr, *wr, *cmd, *cmd_done;\n\n\taddr = pdata->pcs_addr + PCS_ADDR_REG_OFFSET;\n\twr = pdata->pcs_addr + PCS_WRITE_REG_OFFSET;\n\tcmd = pdata->pcs_addr + PCS_COMMAND_REG_OFFSET;\n\tcmd_done = pdata->pcs_addr + PCS_COMMAND_DONE_REG_OFFSET;\n\n\tif (!xgene_enet_wr_indirect(addr, wr, cmd, cmd_done, wr_addr, wr_data))\n\t\tnetdev_err(pdata->ndev, \"PCS write failed, addr: %04x\\n\",\n\t\t\t   wr_addr);\n}\n\nstatic void xgene_enet_wr_axg_csr(struct xgene_enet_pdata *pdata,\n\t\t\t\t  u32 offset, u32 val)\n{\n\tvoid __iomem *addr = pdata->mcx_mac_csr_addr + offset;\n\n\tiowrite32(val, addr);\n}\n\nstatic void xgene_enet_rd_csr(struct xgene_enet_pdata *pdata,\n\t\t\t      u32 offset, u32 *val)\n{\n\tvoid __iomem *addr = pdata->eth_csr_addr + offset;\n\n\t*val = ioread32(addr);\n}\n\nstatic void xgene_enet_rd_diag_csr(struct xgene_enet_pdata *pdata,\n\t\t\t\t   u32 offset, u32 *val)\n{\n\tvoid __iomem *addr = pdata->eth_diag_csr_addr + offset;\n\n\t*val = ioread32(addr);\n}\n\nstatic bool xgene_enet_rd_indirect(void __iomem *addr, void __iomem *rd,\n\t\t\t\t   void __iomem *cmd, void __iomem *cmd_done,\n\t\t\t\t   u32 rd_addr, u32 *rd_data)\n{\n\tu32 done;\n\tu8 wait = 10;\n\n\tiowrite32(rd_addr, addr);\n\tiowrite32(XGENE_ENET_RD_CMD, cmd);\n\n\t \n\twhile (!(done = ioread32(cmd_done)) && wait--)\n\t\tudelay(1);\n\n\tif (!done)\n\t\treturn false;\n\n\t*rd_data = ioread32(rd);\n\tiowrite32(0, cmd);\n\n\treturn true;\n}\n\nstatic bool xgene_enet_rd_pcs(struct xgene_enet_pdata *pdata,\n\t\t\t      u32 rd_addr, u32 *rd_data)\n{\n\tvoid __iomem *addr, *rd, *cmd, *cmd_done;\n\tbool success;\n\n\taddr = pdata->pcs_addr + PCS_ADDR_REG_OFFSET;\n\trd = pdata->pcs_addr + PCS_READ_REG_OFFSET;\n\tcmd = pdata->pcs_addr + PCS_COMMAND_REG_OFFSET;\n\tcmd_done = pdata->pcs_addr + PCS_COMMAND_DONE_REG_OFFSET;\n\n\tsuccess = xgene_enet_rd_indirect(addr, rd, cmd, cmd_done, rd_addr, rd_data);\n\tif (!success)\n\t\tnetdev_err(pdata->ndev, \"PCS read failed, addr: %04x\\n\",\n\t\t\t   rd_addr);\n\n\treturn success;\n}\n\nstatic void xgene_enet_rd_axg_csr(struct xgene_enet_pdata *pdata,\n\t\t\t\t  u32 offset, u32 *val)\n{\n\tvoid __iomem *addr = pdata->mcx_mac_csr_addr + offset;\n\n\t*val = ioread32(addr);\n}\n\nstatic int xgene_enet_ecc_init(struct xgene_enet_pdata *pdata)\n{\n\tstruct net_device *ndev = pdata->ndev;\n\tu32 data;\n\tu8 wait = 10;\n\n\txgene_enet_wr_diag_csr(pdata, ENET_CFG_MEM_RAM_SHUTDOWN_ADDR, 0x0);\n\tdo {\n\t\tusleep_range(100, 110);\n\t\txgene_enet_rd_diag_csr(pdata, ENET_BLOCK_MEM_RDY_ADDR, &data);\n\t} while ((data != 0xffffffff) && wait--);\n\n\tif (data != 0xffffffff) {\n\t\tnetdev_err(ndev, \"Failed to release memory from shutdown\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void xgene_xgmac_get_drop_cnt(struct xgene_enet_pdata *pdata,\n\t\t\t\t     u32 *rx, u32 *tx)\n{\n\tu32 count;\n\n\txgene_enet_rd_axg_csr(pdata, XGENET_ICM_ECM_DROP_COUNT_REG0, &count);\n\t*rx = ICM_DROP_COUNT(count);\n\t*tx = ECM_DROP_COUNT(count);\n\t \n\txgene_enet_rd_axg_csr(pdata, XGENET_ECM_CONFIG0_REG_0, &count);\n}\n\nstatic void xgene_enet_config_ring_if_assoc(struct xgene_enet_pdata *pdata)\n{\n\txgene_enet_wr_ring_if(pdata, ENET_CFGSSQMIWQASSOC_ADDR, 0);\n\txgene_enet_wr_ring_if(pdata, ENET_CFGSSQMIFPQASSOC_ADDR, 0);\n\txgene_enet_wr_ring_if(pdata, ENET_CFGSSQMIQMLITEWQASSOC_ADDR, 0);\n\txgene_enet_wr_ring_if(pdata, ENET_CFGSSQMIQMLITEFPQASSOC_ADDR, 0);\n}\n\nstatic void xgene_xgmac_reset(struct xgene_enet_pdata *pdata)\n{\n\txgene_enet_wr_mac(pdata, AXGMAC_CONFIG_0, HSTMACRST);\n\txgene_enet_wr_mac(pdata, AXGMAC_CONFIG_0, 0);\n}\n\nstatic void xgene_pcs_reset(struct xgene_enet_pdata *pdata)\n{\n\tu32 data;\n\n\tif (!xgene_enet_rd_pcs(pdata, PCS_CONTROL_1, &data))\n\t\treturn;\n\n\txgene_enet_wr_pcs(pdata, PCS_CONTROL_1, data | PCS_CTRL_PCS_RST);\n\txgene_enet_wr_pcs(pdata, PCS_CONTROL_1, data & ~PCS_CTRL_PCS_RST);\n}\n\nstatic void xgene_xgmac_set_mac_addr(struct xgene_enet_pdata *pdata)\n{\n\tconst u8 *dev_addr = pdata->ndev->dev_addr;\n\tu32 addr0, addr1;\n\n\taddr0 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |\n\t\t(dev_addr[1] << 8) | dev_addr[0];\n\taddr1 = (dev_addr[5] << 24) | (dev_addr[4] << 16);\n\n\txgene_enet_wr_mac(pdata, HSTMACADR_LSW_ADDR, addr0);\n\txgene_enet_wr_mac(pdata, HSTMACADR_MSW_ADDR, addr1);\n}\n\nstatic void xgene_xgmac_set_mss(struct xgene_enet_pdata *pdata,\n\t\t\t\tu16 mss, u8 index)\n{\n\tu8 offset;\n\tu32 data;\n\n\toffset = (index < 2) ? 0 : 4;\n\txgene_enet_rd_csr(pdata, XG_TSIF_MSS_REG0_ADDR + offset, &data);\n\n\tif (!(index & 0x1))\n\t\tdata = SET_VAL(TSO_MSS1, data >> TSO_MSS1_POS) |\n\t\t\tSET_VAL(TSO_MSS0, mss);\n\telse\n\t\tdata = SET_VAL(TSO_MSS1, mss) | SET_VAL(TSO_MSS0, data);\n\n\txgene_enet_wr_csr(pdata, XG_TSIF_MSS_REG0_ADDR + offset, data);\n}\n\nstatic void xgene_xgmac_set_frame_size(struct xgene_enet_pdata *pdata, int size)\n{\n\txgene_enet_wr_mac(pdata, HSTMAXFRAME_LENGTH_ADDR,\n\t\t\t  ((((size + 2) >> 2) << 16) | size));\n}\n\nstatic u32 xgene_enet_link_status(struct xgene_enet_pdata *pdata)\n{\n\tu32 data;\n\n\txgene_enet_rd_csr(pdata, XG_LINK_STATUS_ADDR, &data);\n\n\treturn data;\n}\n\nstatic void xgene_xgmac_enable_tx_pause(struct xgene_enet_pdata *pdata,\n\t\t\t\t\tbool enable)\n{\n\tu32 data;\n\n\txgene_enet_rd_axg_csr(pdata, XGENET_CSR_ECM_CFG_0_ADDR, &data);\n\n\tif (enable)\n\t\tdata |= MULTI_DPF_AUTOCTRL | PAUSE_XON_EN;\n\telse\n\t\tdata &= ~(MULTI_DPF_AUTOCTRL | PAUSE_XON_EN);\n\n\txgene_enet_wr_axg_csr(pdata, XGENET_CSR_ECM_CFG_0_ADDR, data);\n}\n\nstatic void xgene_xgmac_flowctl_tx(struct xgene_enet_pdata *pdata, bool enable)\n{\n\tu32 data;\n\n\tdata = xgene_enet_rd_mac(pdata, AXGMAC_CONFIG_1);\n\n\tif (enable)\n\t\tdata |= HSTTCTLEN;\n\telse\n\t\tdata &= ~HSTTCTLEN;\n\n\txgene_enet_wr_mac(pdata, AXGMAC_CONFIG_1, data);\n\n\tpdata->mac_ops->enable_tx_pause(pdata, enable);\n}\n\nstatic void xgene_xgmac_flowctl_rx(struct xgene_enet_pdata *pdata, bool enable)\n{\n\tu32 data;\n\n\tdata = xgene_enet_rd_mac(pdata, AXGMAC_CONFIG_1);\n\n\tif (enable)\n\t\tdata |= HSTRCTLEN;\n\telse\n\t\tdata &= ~HSTRCTLEN;\n\n\txgene_enet_wr_mac(pdata, AXGMAC_CONFIG_1, data);\n}\n\nstatic void xgene_xgmac_init(struct xgene_enet_pdata *pdata)\n{\n\tu32 data;\n\n\txgene_xgmac_reset(pdata);\n\n\tdata = xgene_enet_rd_mac(pdata, AXGMAC_CONFIG_1);\n\tdata |= HSTPPEN;\n\tdata &= ~HSTLENCHK;\n\txgene_enet_wr_mac(pdata, AXGMAC_CONFIG_1, data);\n\n\txgene_xgmac_set_mac_addr(pdata);\n\n\txgene_enet_rd_csr(pdata, XG_RSIF_CONFIG_REG_ADDR, &data);\n\tdata |= CFG_RSIF_FPBUFF_TIMEOUT_EN;\n\t \n\tRSIF_CLE_BUFF_THRESH_SET(&data, XG_RSIF_CLE_BUFF_THRESH);\n\txgene_enet_wr_csr(pdata, XG_RSIF_CONFIG_REG_ADDR, data);\n\n\t \n\txgene_enet_rd_csr(pdata, XG_RSIF_CONFIG1_REG_ADDR, &data);\n\tRSIF_PLC_CLE_BUFF_THRESH_SET(&data, XG_RSIF_PLC_CLE_BUFF_THRESH);\n\txgene_enet_wr_csr(pdata, XG_RSIF_CONFIG1_REG_ADDR, data);\n\n\txgene_enet_rd_csr(pdata, XG_ENET_SPARE_CFG_REG_ADDR, &data);\n\tdata |= BIT(12);\n\txgene_enet_wr_csr(pdata, XG_ENET_SPARE_CFG_REG_ADDR, data);\n\txgene_enet_wr_csr(pdata, XG_ENET_SPARE_CFG_REG_1_ADDR, 0x82);\n\txgene_enet_wr_csr(pdata, XGENET_RX_DV_GATE_REG_0_ADDR, 0);\n\txgene_enet_wr_csr(pdata, XG_CFG_BYPASS_ADDR, RESUME_TX);\n\n\t \n\txgene_enet_rd_axg_csr(pdata, XGENET_CSR_MULTI_DPF0_ADDR, &data);\n\tdata = (DEF_QUANTA << 16) | (data & 0xFFFF);\n\txgene_enet_wr_axg_csr(pdata, XGENET_CSR_MULTI_DPF0_ADDR, data);\n\n\tif (pdata->enet_id != XGENE_ENET1) {\n\t\txgene_enet_rd_axg_csr(pdata, XGENET_CSR_MULTI_DPF1_ADDR, &data);\n\t\tdata = (NORM_PAUSE_OPCODE << 16) | (data & 0xFFFF);\n\t\txgene_enet_wr_axg_csr(pdata, XGENET_CSR_MULTI_DPF1_ADDR, data);\n\t}\n\n\tdata = (XG_DEF_PAUSE_OFF_THRES << 16) | XG_DEF_PAUSE_THRES;\n\txgene_enet_wr_csr(pdata, XG_RXBUF_PAUSE_THRESH, data);\n\n\txgene_xgmac_flowctl_tx(pdata, pdata->tx_pause);\n\txgene_xgmac_flowctl_rx(pdata, pdata->rx_pause);\n}\n\nstatic void xgene_xgmac_rx_enable(struct xgene_enet_pdata *pdata)\n{\n\tu32 data;\n\n\tdata = xgene_enet_rd_mac(pdata, AXGMAC_CONFIG_1);\n\txgene_enet_wr_mac(pdata, AXGMAC_CONFIG_1, data | HSTRFEN);\n}\n\nstatic void xgene_xgmac_tx_enable(struct xgene_enet_pdata *pdata)\n{\n\tu32 data;\n\n\tdata = xgene_enet_rd_mac(pdata, AXGMAC_CONFIG_1);\n\txgene_enet_wr_mac(pdata, AXGMAC_CONFIG_1, data | HSTTFEN);\n}\n\nstatic void xgene_xgmac_rx_disable(struct xgene_enet_pdata *pdata)\n{\n\tu32 data;\n\n\tdata = xgene_enet_rd_mac(pdata, AXGMAC_CONFIG_1);\n\txgene_enet_wr_mac(pdata, AXGMAC_CONFIG_1, data & ~HSTRFEN);\n}\n\nstatic void xgene_xgmac_tx_disable(struct xgene_enet_pdata *pdata)\n{\n\tu32 data;\n\n\tdata = xgene_enet_rd_mac(pdata, AXGMAC_CONFIG_1);\n\txgene_enet_wr_mac(pdata, AXGMAC_CONFIG_1, data & ~HSTTFEN);\n}\n\nstatic int xgene_enet_reset(struct xgene_enet_pdata *pdata)\n{\n\tstruct device *dev = &pdata->pdev->dev;\n\n\tif (!xgene_ring_mgr_init(pdata))\n\t\treturn -ENODEV;\n\n\tif (dev->of_node) {\n\t\tclk_prepare_enable(pdata->clk);\n\t\tudelay(5);\n\t\tclk_disable_unprepare(pdata->clk);\n\t\tudelay(5);\n\t\tclk_prepare_enable(pdata->clk);\n\t\tudelay(5);\n\t} else {\n#ifdef CONFIG_ACPI\n\t\tacpi_status status;\n\n\t\tstatus = acpi_evaluate_object(ACPI_HANDLE(&pdata->pdev->dev),\n\t\t\t\t\t      \"_RST\", NULL, NULL);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_evaluate_object(ACPI_HANDLE(&pdata->pdev->dev),\n\t\t\t\t\t     \"_INI\", NULL, NULL);\n\t\t}\n#endif\n\t}\n\n\txgene_enet_ecc_init(pdata);\n\txgene_enet_config_ring_if_assoc(pdata);\n\n\treturn 0;\n}\n\nstatic void xgene_enet_xgcle_bypass(struct xgene_enet_pdata *pdata,\n\t\t\t\t    u32 dst_ring_num, u16 bufpool_id,\n\t\t\t\t    u16 nxtbufpool_id)\n{\n\tu32 cb, fpsel, nxtfpsel;\n\n\txgene_enet_rd_csr(pdata, XCLE_BYPASS_REG0_ADDR, &cb);\n\tcb |= CFG_CLE_BYPASS_EN0;\n\tCFG_CLE_IP_PROTOCOL0_SET(&cb, 3);\n\txgene_enet_wr_csr(pdata, XCLE_BYPASS_REG0_ADDR, cb);\n\n\tfpsel = xgene_enet_get_fpsel(bufpool_id);\n\tnxtfpsel = xgene_enet_get_fpsel(nxtbufpool_id);\n\txgene_enet_rd_csr(pdata, XCLE_BYPASS_REG1_ADDR, &cb);\n\tCFG_CLE_DSTQID0_SET(&cb, dst_ring_num);\n\tCFG_CLE_FPSEL0_SET(&cb, fpsel);\n\tCFG_CLE_NXTFPSEL0_SET(&cb, nxtfpsel);\n\txgene_enet_wr_csr(pdata, XCLE_BYPASS_REG1_ADDR, cb);\n\tpr_info(\"+ cle_bypass: fpsel: %d nxtfpsel: %d\\n\", fpsel, nxtfpsel);\n}\n\nstatic void xgene_enet_shutdown(struct xgene_enet_pdata *pdata)\n{\n\tstruct device *dev = &pdata->pdev->dev;\n\n\tif (dev->of_node) {\n\t\tif (!IS_ERR(pdata->clk))\n\t\t\tclk_disable_unprepare(pdata->clk);\n\t}\n}\n\nstatic void xgene_enet_clear(struct xgene_enet_pdata *pdata,\n\t\t\t     struct xgene_enet_desc_ring *ring)\n{\n\tu32 addr, data;\n\n\tif (xgene_enet_is_bufpool(ring->id)) {\n\t\taddr = ENET_CFGSSQMIFPRESET_ADDR;\n\t\tdata = BIT(xgene_enet_get_fpsel(ring->id));\n\t} else {\n\t\taddr = ENET_CFGSSQMIWQRESET_ADDR;\n\t\tdata = BIT(xgene_enet_ring_bufnum(ring->id));\n\t}\n\n\txgene_enet_wr_ring_if(pdata, addr, data);\n}\n\nstatic int xgene_enet_gpio_lookup(struct xgene_enet_pdata *pdata)\n{\n\tstruct device *dev = &pdata->pdev->dev;\n\n\tpdata->sfp_rdy = gpiod_get(dev, \"rxlos\", GPIOD_IN);\n\tif (IS_ERR(pdata->sfp_rdy))\n\t\tpdata->sfp_rdy = gpiod_get(dev, \"sfp\", GPIOD_IN);\n\n\tif (IS_ERR(pdata->sfp_rdy))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void xgene_enet_link_state(struct work_struct *work)\n{\n\tstruct xgene_enet_pdata *pdata = container_of(to_delayed_work(work),\n\t\t\t\t\t struct xgene_enet_pdata, link_work);\n\tstruct net_device *ndev = pdata->ndev;\n\tu32 link_status, poll_interval;\n\n\tlink_status = xgene_enet_link_status(pdata);\n\tif (pdata->sfp_gpio_en && link_status &&\n\t    (!IS_ERR(pdata->sfp_rdy) || !xgene_enet_gpio_lookup(pdata)) &&\n\t    !gpiod_get_value(pdata->sfp_rdy))\n\t\tlink_status = 0;\n\n\tif (link_status) {\n\t\tif (!netif_carrier_ok(ndev)) {\n\t\t\tnetif_carrier_on(ndev);\n\t\t\txgene_xgmac_rx_enable(pdata);\n\t\t\txgene_xgmac_tx_enable(pdata);\n\t\t\tnetdev_info(ndev, \"Link is Up - 10Gbps\\n\");\n\t\t}\n\t\tpoll_interval = PHY_POLL_LINK_ON;\n\t} else {\n\t\tif (netif_carrier_ok(ndev)) {\n\t\t\txgene_xgmac_rx_disable(pdata);\n\t\t\txgene_xgmac_tx_disable(pdata);\n\t\t\tnetif_carrier_off(ndev);\n\t\t\tnetdev_info(ndev, \"Link is Down\\n\");\n\t\t}\n\t\tpoll_interval = PHY_POLL_LINK_OFF;\n\n\t\txgene_pcs_reset(pdata);\n\t}\n\n\tschedule_delayed_work(&pdata->link_work, poll_interval);\n}\n\nconst struct xgene_mac_ops xgene_xgmac_ops = {\n\t.init = xgene_xgmac_init,\n\t.reset = xgene_xgmac_reset,\n\t.rx_enable = xgene_xgmac_rx_enable,\n\t.tx_enable = xgene_xgmac_tx_enable,\n\t.rx_disable = xgene_xgmac_rx_disable,\n\t.tx_disable = xgene_xgmac_tx_disable,\n\t.set_mac_addr = xgene_xgmac_set_mac_addr,\n\t.set_framesize = xgene_xgmac_set_frame_size,\n\t.set_mss = xgene_xgmac_set_mss,\n\t.get_drop_cnt = xgene_xgmac_get_drop_cnt,\n\t.link_state = xgene_enet_link_state,\n\t.enable_tx_pause = xgene_xgmac_enable_tx_pause,\n\t.flowctl_rx = xgene_xgmac_flowctl_rx,\n\t.flowctl_tx = xgene_xgmac_flowctl_tx\n};\n\nconst struct xgene_port_ops xgene_xgport_ops = {\n\t.reset = xgene_enet_reset,\n\t.clear = xgene_enet_clear,\n\t.cle_bypass = xgene_enet_xgcle_bypass,\n\t.shutdown = xgene_enet_shutdown,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}