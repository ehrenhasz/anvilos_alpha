{
  "module_name": "xgene_enet_ring2.c",
  "hash_id": "451cec45bc92ca737542bdaf4fccfeed6a415896d58ab7a1403f4d15529093fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/apm/xgene/xgene_enet_ring2.c",
  "human_readable_source": "\n \n\n#include \"xgene_enet_main.h\"\n#include \"xgene_enet_hw.h\"\n#include \"xgene_enet_ring2.h\"\n\nstatic void xgene_enet_ring_init(struct xgene_enet_desc_ring *ring)\n{\n\tu32 *ring_cfg = ring->state;\n\tu64 addr = ring->dma;\n\n\tif (xgene_enet_ring_owner(ring->id) == RING_OWNER_CPU) {\n\t\tring_cfg[0] |= SET_VAL(X2_INTLINE, ring->id & RING_BUFNUM_MASK);\n\t\tring_cfg[3] |= SET_BIT(X2_DEQINTEN);\n\t}\n\tring_cfg[0] |= SET_VAL(X2_CFGCRID, 2);\n\n\taddr >>= 8;\n\tring_cfg[2] |= QCOHERENT | SET_VAL(RINGADDRL, addr);\n\n\taddr >>= 27;\n\tring_cfg[3] |= SET_VAL(RINGSIZE, ring->cfgsize)\n\t\t    | ACCEPTLERR\n\t\t    | SET_VAL(RINGADDRH, addr);\n\tring_cfg[4] |= SET_VAL(X2_SELTHRSH, 1);\n\tring_cfg[5] |= SET_BIT(X2_QBASE_AM) | SET_BIT(X2_MSG_AM);\n}\n\nstatic void xgene_enet_ring_set_type(struct xgene_enet_desc_ring *ring)\n{\n\tu32 *ring_cfg = ring->state;\n\tbool is_bufpool;\n\tu32 val;\n\n\tis_bufpool = xgene_enet_is_bufpool(ring->id);\n\tval = (is_bufpool) ? RING_BUFPOOL : RING_REGULAR;\n\tring_cfg[4] |= SET_VAL(X2_RINGTYPE, val);\n\tif (is_bufpool)\n\t\tring_cfg[3] |= SET_VAL(RINGMODE, BUFPOOL_MODE);\n}\n\nstatic void xgene_enet_ring_set_recombbuf(struct xgene_enet_desc_ring *ring)\n{\n\tu32 *ring_cfg = ring->state;\n\n\tring_cfg[3] |= RECOMBBUF;\n\tring_cfg[4] |= SET_VAL(X2_RECOMTIMEOUT, 0x7);\n}\n\nstatic void xgene_enet_ring_wr32(struct xgene_enet_desc_ring *ring,\n\t\t\t\t u32 offset, u32 data)\n{\n\tstruct xgene_enet_pdata *pdata = netdev_priv(ring->ndev);\n\n\tiowrite32(data, pdata->ring_csr_addr + offset);\n}\n\nstatic void xgene_enet_write_ring_state(struct xgene_enet_desc_ring *ring)\n{\n\tstruct xgene_enet_pdata *pdata = netdev_priv(ring->ndev);\n\tint i;\n\n\txgene_enet_ring_wr32(ring, CSR_RING_CONFIG, ring->num);\n\tfor (i = 0; i < pdata->ring_ops->num_ring_config; i++) {\n\t\txgene_enet_ring_wr32(ring, CSR_RING_WR_BASE + (i * 4),\n\t\t\t\t     ring->state[i]);\n\t}\n}\n\nstatic void xgene_enet_clr_ring_state(struct xgene_enet_desc_ring *ring)\n{\n\tmemset(ring->state, 0, sizeof(ring->state));\n\txgene_enet_write_ring_state(ring);\n}\n\nstatic void xgene_enet_set_ring_state(struct xgene_enet_desc_ring *ring)\n{\n\tenum xgene_ring_owner owner;\n\n\txgene_enet_ring_set_type(ring);\n\n\towner = xgene_enet_ring_owner(ring->id);\n\tif (owner == RING_OWNER_ETH0 || owner == RING_OWNER_ETH1)\n\t\txgene_enet_ring_set_recombbuf(ring);\n\n\txgene_enet_ring_init(ring);\n\txgene_enet_write_ring_state(ring);\n}\n\nstatic void xgene_enet_set_ring_id(struct xgene_enet_desc_ring *ring)\n{\n\tu32 ring_id_val, ring_id_buf;\n\tbool is_bufpool;\n\n\tif (xgene_enet_ring_owner(ring->id) == RING_OWNER_CPU)\n\t\treturn;\n\n\tis_bufpool = xgene_enet_is_bufpool(ring->id);\n\n\tring_id_val = ring->id & GENMASK(9, 0);\n\tring_id_val |= OVERWRITE;\n\n\tring_id_buf = (ring->num << 9) & GENMASK(18, 9);\n\tring_id_buf |= PREFETCH_BUF_EN;\n\n\tif (is_bufpool)\n\t\tring_id_buf |= IS_BUFFER_POOL;\n\n\txgene_enet_ring_wr32(ring, CSR_RING_ID, ring_id_val);\n\txgene_enet_ring_wr32(ring, CSR_RING_ID_BUF, ring_id_buf);\n}\n\nstatic void xgene_enet_clr_desc_ring_id(struct xgene_enet_desc_ring *ring)\n{\n\tu32 ring_id;\n\n\tring_id = ring->id | OVERWRITE;\n\txgene_enet_ring_wr32(ring, CSR_RING_ID, ring_id);\n\txgene_enet_ring_wr32(ring, CSR_RING_ID_BUF, 0);\n}\n\nstatic struct xgene_enet_desc_ring *xgene_enet_setup_ring(\n\t\t\t\t    struct xgene_enet_desc_ring *ring)\n{\n\tbool is_bufpool;\n\tu32 addr, i;\n\n\txgene_enet_clr_ring_state(ring);\n\txgene_enet_set_ring_state(ring);\n\txgene_enet_set_ring_id(ring);\n\n\tring->slots = xgene_enet_get_numslots(ring->id, ring->size);\n\n\tis_bufpool = xgene_enet_is_bufpool(ring->id);\n\tif (is_bufpool || xgene_enet_ring_owner(ring->id) != RING_OWNER_CPU)\n\t\treturn ring;\n\n\taddr = CSR_VMID0_INTR_MBOX + (4 * (ring->id & RING_BUFNUM_MASK));\n\txgene_enet_ring_wr32(ring, addr, ring->irq_mbox_dma >> 10);\n\n\tfor (i = 0; i < ring->slots; i++)\n\t\txgene_enet_mark_desc_slot_empty(&ring->raw_desc[i]);\n\n\treturn ring;\n}\n\nstatic void xgene_enet_clear_ring(struct xgene_enet_desc_ring *ring)\n{\n\txgene_enet_clr_desc_ring_id(ring);\n\txgene_enet_clr_ring_state(ring);\n}\n\nstatic void xgene_enet_wr_cmd(struct xgene_enet_desc_ring *ring, int count)\n{\n\tu32 data = 0;\n\n\tif (xgene_enet_ring_owner(ring->id) == RING_OWNER_CPU) {\n\t\tdata = SET_VAL(X2_INTLINE, ring->id & RING_BUFNUM_MASK) |\n\t\t       INTR_CLEAR;\n\t}\n\tdata |= (count & GENMASK(16, 0));\n\n\tiowrite32(data, ring->cmd);\n}\n\nstatic u32 xgene_enet_ring_len(struct xgene_enet_desc_ring *ring)\n{\n\tu32 __iomem *cmd_base = ring->cmd_base;\n\tu32 ring_state, num_msgs;\n\n\tring_state = ioread32(&cmd_base[1]);\n\tnum_msgs = GET_VAL(X2_NUMMSGSINQ, ring_state);\n\n\treturn num_msgs;\n}\n\nstatic void xgene_enet_setup_coalescing(struct xgene_enet_desc_ring *ring)\n{\n\tu32 data = 0x77777777;\n\n\txgene_enet_ring_wr32(ring, CSR_PBM_COAL, 0x8e);\n\txgene_enet_ring_wr32(ring, CSR_PBM_CTICK0, data);\n\txgene_enet_ring_wr32(ring, CSR_PBM_CTICK1, data);\n\txgene_enet_ring_wr32(ring, CSR_PBM_CTICK2, data);\n\txgene_enet_ring_wr32(ring, CSR_PBM_CTICK3, data);\n\txgene_enet_ring_wr32(ring, CSR_THRESHOLD0_SET1, 0x08);\n\txgene_enet_ring_wr32(ring, CSR_THRESHOLD1_SET1, 0x10);\n}\n\nstruct xgene_ring_ops xgene_ring2_ops = {\n\t.num_ring_config = X2_NUM_RING_CONFIG,\n\t.num_ring_id_shift = 13,\n\t.setup = xgene_enet_setup_ring,\n\t.clear = xgene_enet_clear_ring,\n\t.wr_cmd = xgene_enet_wr_cmd,\n\t.len = xgene_enet_ring_len,\n\t.coalesce = xgene_enet_setup_coalescing,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}