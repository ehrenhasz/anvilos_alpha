{
  "module_name": "xgene_enet_cle.c",
  "hash_id": "1b6978f474d283289598957de423836ba7c02efae75f92a52ea4092e1d911c09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/apm/xgene/xgene_enet_cle.c",
  "human_readable_source": "\n \n\n#include \"xgene_enet_main.h\"\n\n \nstatic void xgene_cle_sband_to_hw(u8 frag, enum xgene_cle_prot_version ver,\n\t\t\t\t  enum xgene_cle_prot_type type, u32 len,\n\t\t\t\t  u32 *reg)\n{\n\t*reg =  SET_VAL(SB_IPFRAG, frag) |\n\t\tSET_VAL(SB_IPPROT, type) |\n\t\tSET_VAL(SB_IPVER, ver) |\n\t\tSET_VAL(SB_HDRLEN, len);\n}\n\nstatic void xgene_cle_idt_to_hw(struct xgene_enet_pdata *pdata,\n\t\t\t\tu32 dstqid, u32 fpsel,\n\t\t\t\tu32 nfpsel, u32 *idt_reg)\n{\n\tif (pdata->enet_id == XGENE_ENET1) {\n\t\t*idt_reg = SET_VAL(IDT_DSTQID, dstqid) |\n\t\t\t   SET_VAL(IDT_FPSEL1, fpsel)  |\n\t\t\t   SET_VAL(IDT_NFPSEL1, nfpsel);\n\t} else {\n\t\t*idt_reg = SET_VAL(IDT_DSTQID, dstqid) |\n\t\t\t   SET_VAL(IDT_FPSEL, fpsel)   |\n\t\t\t   SET_VAL(IDT_NFPSEL, nfpsel);\n\t}\n}\n\nstatic void xgene_cle_dbptr_to_hw(struct xgene_enet_pdata *pdata,\n\t\t\t\t  struct xgene_cle_dbptr *dbptr, u32 *buf)\n{\n\tbuf[0] = SET_VAL(CLE_DROP, dbptr->drop);\n\tbuf[4] = SET_VAL(CLE_FPSEL, dbptr->fpsel) |\n\t\t SET_VAL(CLE_NFPSEL, dbptr->nxtfpsel) |\n\t\t SET_VAL(CLE_DSTQIDL, dbptr->dstqid);\n\n\tbuf[5] = SET_VAL(CLE_DSTQIDH, (u32)dbptr->dstqid >> CLE_DSTQIDL_LEN) |\n\t\t SET_VAL(CLE_PRIORITY, dbptr->cle_priority);\n}\n\nstatic void xgene_cle_kn_to_hw(struct xgene_cle_ptree_kn *kn, u32 *buf)\n{\n\tu32 i, j = 0;\n\tu32 data;\n\n\tbuf[j++] = SET_VAL(CLE_TYPE, kn->node_type);\n\tfor (i = 0; i < kn->num_keys; i++) {\n\t\tstruct xgene_cle_ptree_key *key = &kn->key[i];\n\n\t\tif (!(i % 2)) {\n\t\t\tbuf[j] = SET_VAL(CLE_KN_PRIO, key->priority) |\n\t\t\t\t SET_VAL(CLE_KN_RPTR, key->result_pointer);\n\t\t} else {\n\t\t\tdata = SET_VAL(CLE_KN_PRIO, key->priority) |\n\t\t\t       SET_VAL(CLE_KN_RPTR, key->result_pointer);\n\t\t\tbuf[j++] |= (data << 16);\n\t\t}\n\t}\n}\n\nstatic void xgene_cle_dn_to_hw(const struct xgene_cle_ptree_ewdn *dn,\n\t\t\t       u32 *buf, u32 jb)\n{\n\tconst struct xgene_cle_ptree_branch *br;\n\tu32 i, j = 0;\n\tu32 npp;\n\n\tbuf[j++] = SET_VAL(CLE_DN_TYPE, dn->node_type) |\n\t\t   SET_VAL(CLE_DN_LASTN, dn->last_node) |\n\t\t   SET_VAL(CLE_DN_HLS, dn->hdr_len_store) |\n\t\t   SET_VAL(CLE_DN_EXT, dn->hdr_extn) |\n\t\t   SET_VAL(CLE_DN_BSTOR, dn->byte_store) |\n\t\t   SET_VAL(CLE_DN_SBSTOR, dn->search_byte_store) |\n\t\t   SET_VAL(CLE_DN_RPTR, dn->result_pointer);\n\n\tfor (i = 0; i < dn->num_branches; i++) {\n\t\tbr = &dn->branch[i];\n\t\tnpp = br->next_packet_pointer;\n\n\t\tif ((br->jump_rel == JMP_ABS) && (npp < CLE_PKTRAM_SIZE))\n\t\t\tnpp += jb;\n\n\t\tbuf[j++] = SET_VAL(CLE_BR_VALID, br->valid) |\n\t\t\t   SET_VAL(CLE_BR_NPPTR, npp) |\n\t\t\t   SET_VAL(CLE_BR_JB, br->jump_bw) |\n\t\t\t   SET_VAL(CLE_BR_JR, br->jump_rel) |\n\t\t\t   SET_VAL(CLE_BR_OP, br->operation) |\n\t\t\t   SET_VAL(CLE_BR_NNODE, br->next_node) |\n\t\t\t   SET_VAL(CLE_BR_NBR, br->next_branch);\n\n\t\tbuf[j++] = SET_VAL(CLE_BR_DATA, br->data) |\n\t\t\t   SET_VAL(CLE_BR_MASK, br->mask);\n\t}\n}\n\nstatic int xgene_cle_poll_cmd_done(void __iomem *base,\n\t\t\t\t   enum xgene_cle_cmd_type cmd)\n{\n\tu32 status, loop = 10;\n\tint ret = -EBUSY;\n\n\twhile (loop--) {\n\t\tstatus = ioread32(base + INDCMD_STATUS);\n\t\tif (status & cmd) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn ret;\n}\n\nstatic int xgene_cle_dram_wr(struct xgene_enet_cle *cle, u32 *data, u8 nregs,\n\t\t\t     u32 index, enum xgene_cle_dram_type type,\n\t\t\t     enum xgene_cle_cmd_type cmd)\n{\n\tenum xgene_cle_parser parser = cle->active_parser;\n\tvoid __iomem *base = cle->base;\n\tu32 i, j, ind_addr;\n\tu8 port, nparsers;\n\tint ret = 0;\n\n\t \n\tnparsers = (type >= PTREE_RAM) ? 1 : cle->parsers;\n\n\tfor (i = 0; i < nparsers; i++) {\n\t\tport = i;\n\t\tif ((type < PTREE_RAM) && (parser != PARSER_ALL))\n\t\t\tport = parser;\n\n\t\tind_addr = XGENE_CLE_DRAM(type + (port * 4)) | index;\n\t\tiowrite32(ind_addr, base + INDADDR);\n\t\tfor (j = 0; j < nregs; j++)\n\t\t\tiowrite32(data[j], base + DATA_RAM0 + (j * 4));\n\t\tiowrite32(cmd, base + INDCMD);\n\n\t\tret = xgene_cle_poll_cmd_done(base, cmd);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void xgene_cle_enable_ptree(struct xgene_enet_pdata *pdata,\n\t\t\t\t   struct xgene_enet_cle *cle)\n{\n\tstruct xgene_cle_ptree *ptree = &cle->ptree;\n\tvoid __iomem *addr, *base = cle->base;\n\tu32 offset = CLE_PORT_OFFSET;\n\tu32 i;\n\n\t \n\tptree->start_pkt += cle->jump_bytes;\n\tfor (i = 0; i < cle->parsers; i++) {\n\t\tif (cle->active_parser != PARSER_ALL)\n\t\t\taddr = base + cle->active_parser * offset;\n\t\telse\n\t\t\taddr = base + (i * offset);\n\n\t\tiowrite32(ptree->start_node & 0x3fff, addr + SNPTR0);\n\t\tiowrite32(ptree->start_pkt & 0x1ff, addr + SPPTR0);\n\t}\n}\n\nstatic int xgene_cle_setup_dbptr(struct xgene_enet_pdata *pdata,\n\t\t\t\t struct xgene_enet_cle *cle)\n{\n\tstruct xgene_cle_ptree *ptree = &cle->ptree;\n\tu32 buf[CLE_DRAM_REGS];\n\tu32 i;\n\tint ret;\n\n\tmemset(buf, 0, sizeof(buf));\n\tfor (i = 0; i < ptree->num_dbptr; i++) {\n\t\txgene_cle_dbptr_to_hw(pdata, &ptree->dbptr[i], buf);\n\t\tret = xgene_cle_dram_wr(cle, buf, 6, i + ptree->start_dbptr,\n\t\t\t\t\tDB_RAM,\tCLE_CMD_WR);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct xgene_cle_ptree_ewdn xgene_init_ptree_dn[] = {\n\t{\n\t\t \n\t\t.node_type = EWDN,\n\t\t.last_node = 0,\n\t\t.hdr_len_store = 1,\n\t\t.hdr_extn = NO_BYTE,\n\t\t.byte_store = NO_BYTE,\n\t\t.search_byte_store = NO_BYTE,\n\t\t.result_pointer = DB_RES_DROP,\n\t\t.num_branches = 2,\n\t\t.branch = {\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 1,\n\t\t\t\t.next_packet_pointer = 22,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = PKT_PROT_NODE,\n\t\t\t\t.next_branch = 0,\n\t\t\t\t.data = 0x8,\n\t\t\t\t.mask = 0x0\n\t\t\t},\n\t\t\t{\n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 262,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = LAST_NODE,\n\t\t\t\t.next_branch = 0,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t}\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.node_type = EWDN,\n\t\t.last_node = 0,\n\t\t.hdr_len_store = 1,\n\t\t.hdr_extn = NO_BYTE,\n\t\t.byte_store = NO_BYTE,\n\t\t.search_byte_store = NO_BYTE,\n\t\t.result_pointer = DB_RES_DROP,\n\t\t.num_branches = 3,\n\t\t.branch = {\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 1,\n\t\t\t\t.next_packet_pointer = 26,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_TCP_NODE,\n\t\t\t\t.next_branch = 0,\n\t\t\t\t.data = 0x0600,\n\t\t\t\t.mask = 0x00ff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 1,\n\t\t\t\t.next_packet_pointer = 26,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_UDP_NODE,\n\t\t\t\t.next_branch = 0,\n\t\t\t\t.data = 0x1100,\n\t\t\t\t.mask = 0x00ff\n\t\t\t},\n\t\t\t{\n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 26,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_OTHERS_NODE,\n\t\t\t\t.next_branch = 0,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t}\n\t\t}\n\t},\n\t{\n\t\t \n\t\t.node_type = EWDN,\n\t\t.last_node = 0,\n\t\t.hdr_len_store = 1,\n\t\t.hdr_extn = NO_BYTE,\n\t\t.byte_store = NO_BYTE,\n\t\t.search_byte_store = BOTH_BYTES,\n\t\t.result_pointer = DB_RES_DROP,\n\t\t.num_branches = 6,\n\t\t.branch = {\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 28,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_TCP_NODE,\n\t\t\t\t.next_branch = 1,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 30,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_TCP_NODE,\n\t\t\t\t.next_branch = 2,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 32,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_TCP_NODE,\n\t\t\t\t.next_branch = 3,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 34,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_TCP_NODE,\n\t\t\t\t.next_branch = 4,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 36,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_TCP_NODE,\n\t\t\t\t.next_branch = 5,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 256,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = LAST_NODE,\n\t\t\t\t.next_branch = 0,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t}\n\t\t}\n\t},\n\t{\n\t\t \n\t\t.node_type = EWDN,\n\t\t.last_node = 0,\n\t\t.hdr_len_store = 1,\n\t\t.hdr_extn = NO_BYTE,\n\t\t.byte_store = NO_BYTE,\n\t\t.search_byte_store = BOTH_BYTES,\n\t\t.result_pointer = DB_RES_DROP,\n\t\t.num_branches = 6,\n\t\t.branch = {\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 28,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_UDP_NODE,\n\t\t\t\t.next_branch = 1,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 30,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_UDP_NODE,\n\t\t\t\t.next_branch = 2,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 32,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_UDP_NODE,\n\t\t\t\t.next_branch = 3,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 34,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_UDP_NODE,\n\t\t\t\t.next_branch = 4,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 36,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_UDP_NODE,\n\t\t\t\t.next_branch = 5,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 258,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = LAST_NODE,\n\t\t\t\t.next_branch = 0,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t}\n\t\t}\n\t},\n\t{\n\t\t \n\t\t.node_type = EWDN,\n\t\t.last_node = 0,\n\t\t.hdr_len_store = 1,\n\t\t.hdr_extn = NO_BYTE,\n\t\t.byte_store = NO_BYTE,\n\t\t.search_byte_store = BOTH_BYTES,\n\t\t.result_pointer = DB_RES_DROP,\n\t\t.num_branches = 6,\n\t\t.branch = {\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 28,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_OTHERS_NODE,\n\t\t\t\t.next_branch = 1,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 30,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_OTHERS_NODE,\n\t\t\t\t.next_branch = 2,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 32,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_OTHERS_NODE,\n\t\t\t\t.next_branch = 3,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 34,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_OTHERS_NODE,\n\t\t\t\t.next_branch = 4,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 36,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = RSS_IPV4_OTHERS_NODE,\n\t\t\t\t.next_branch = 5,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t},\n\t\t\t{\n\t\t\t\t \n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 260,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = LAST_NODE,\n\t\t\t\t.next_branch = 0,\n\t\t\t\t.data = 0x0,\n\t\t\t\t.mask = 0xffff\n\t\t\t}\n\t\t}\n\t},\n\n\t{\n\t\t \n\t\t.node_type = EWDN,\n\t\t.last_node = 1,\n\t\t.hdr_len_store = 1,\n\t\t.hdr_extn = NO_BYTE,\n\t\t.byte_store = NO_BYTE,\n\t\t.search_byte_store = NO_BYTE,\n\t\t.result_pointer = DB_RES_DROP,\n\t\t.num_branches = 1,\n\t\t.branch = {\n\t\t\t{\n\t\t\t\t.valid = 0,\n\t\t\t\t.next_packet_pointer = 0,\n\t\t\t\t.jump_bw = JMP_FW,\n\t\t\t\t.jump_rel = JMP_ABS,\n\t\t\t\t.operation = EQT,\n\t\t\t\t.next_node = MAX_NODES,\n\t\t\t\t.next_branch = 0,\n\t\t\t\t.data = 0,\n\t\t\t\t.mask = 0xffff\n\t\t\t}\n\t\t}\n\t}\n};\n\nstatic int xgene_cle_setup_node(struct xgene_enet_pdata *pdata,\n\t\t\t\tstruct xgene_enet_cle *cle)\n{\n\tstruct xgene_cle_ptree *ptree = &cle->ptree;\n\tconst struct xgene_cle_ptree_ewdn *dn = xgene_init_ptree_dn;\n\tint num_dn = ARRAY_SIZE(xgene_init_ptree_dn);\n\tstruct xgene_cle_ptree_kn *kn = ptree->kn;\n\tu32 buf[CLE_DRAM_REGS];\n\tint i, j, ret;\n\n\tmemset(buf, 0, sizeof(buf));\n\tfor (i = 0; i < num_dn; i++) {\n\t\txgene_cle_dn_to_hw(&dn[i], buf, cle->jump_bytes);\n\t\tret = xgene_cle_dram_wr(cle, buf, 17, i + ptree->start_node,\n\t\t\t\t\tPTREE_RAM, CLE_CMD_WR);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tmemset(buf, 0, sizeof(buf));\n\tfor (j = i; j < (ptree->num_kn + num_dn); j++) {\n\t\txgene_cle_kn_to_hw(&kn[j - num_dn], buf);\n\t\tret = xgene_cle_dram_wr(cle, buf, 17, j + ptree->start_node,\n\t\t\t\t\tPTREE_RAM, CLE_CMD_WR);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int xgene_cle_setup_ptree(struct xgene_enet_pdata *pdata,\n\t\t\t\t struct xgene_enet_cle *cle)\n{\n\tint ret;\n\n\tret = xgene_cle_setup_node(pdata, cle);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xgene_cle_setup_dbptr(pdata, cle);\n\tif (ret)\n\t\treturn ret;\n\n\txgene_cle_enable_ptree(pdata, cle);\n\n\treturn 0;\n}\n\nstatic void xgene_cle_setup_def_dbptr(struct xgene_enet_pdata *pdata,\n\t\t\t\t      struct xgene_enet_cle *enet_cle,\n\t\t\t\t      struct xgene_cle_dbptr *dbptr,\n\t\t\t\t      u32 index, u8 priority)\n{\n\tvoid __iomem *base = enet_cle->base;\n\tvoid __iomem *base_addr;\n\tu32 buf[CLE_DRAM_REGS];\n\tu32 def_cls, offset;\n\tu32 i, j;\n\n\tmemset(buf, 0, sizeof(buf));\n\txgene_cle_dbptr_to_hw(pdata, dbptr, buf);\n\n\tfor (i = 0; i < enet_cle->parsers; i++) {\n\t\tif (enet_cle->active_parser != PARSER_ALL) {\n\t\t\toffset = enet_cle->active_parser *\n\t\t\t\tCLE_PORT_OFFSET;\n\t\t} else {\n\t\t\toffset = i * CLE_PORT_OFFSET;\n\t\t}\n\n\t\tbase_addr = base + DFCLSRESDB00 + offset;\n\t\tfor (j = 0; j < 6; j++)\n\t\t\tiowrite32(buf[j], base_addr + (j * 4));\n\n\t\tdef_cls = ((priority & 0x7) << 10) | (index & 0x3ff);\n\t\tiowrite32(def_cls, base + DFCLSRESDBPTR0 + offset);\n\t}\n}\n\nstatic int xgene_cle_set_rss_sband(struct xgene_enet_cle *cle)\n{\n\tu32 idx = CLE_PKTRAM_SIZE / sizeof(u32);\n\tu32 mac_hdr_len = ETH_HLEN;\n\tu32 sband, reg = 0;\n\tu32 ipv4_ihl = 5;\n\tu32 hdr_len;\n\tint ret;\n\n\t \n\thdr_len = (mac_hdr_len << 5) | ipv4_ihl;\n\txgene_cle_sband_to_hw(0, XGENE_CLE_IPV4, XGENE_CLE_TCP, hdr_len, &reg);\n\tsband = reg;\n\n\t \n\thdr_len = (mac_hdr_len << 5) | ipv4_ihl;\n\txgene_cle_sband_to_hw(1, XGENE_CLE_IPV4, XGENE_CLE_UDP, hdr_len, &reg);\n\tsband |= (reg << 16);\n\n\tret = xgene_cle_dram_wr(cle, &sband, 1, idx, PKT_RAM, CLE_CMD_WR);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\thdr_len = (mac_hdr_len << 5) | ipv4_ihl;\n\txgene_cle_sband_to_hw(0, XGENE_CLE_IPV4, XGENE_CLE_OTHER,\n\t\t\t      hdr_len, &reg);\n\tsband = reg;\n\n\t \n\thdr_len = (mac_hdr_len << 5);\n\txgene_cle_sband_to_hw(0, XGENE_CLE_IPV4, XGENE_CLE_OTHER,\n\t\t\t      hdr_len, &reg);\n\tsband |= (reg << 16);\n\n\tret = xgene_cle_dram_wr(cle, &sband, 1, idx + 1, PKT_RAM, CLE_CMD_WR);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int xgene_cle_set_rss_skeys(struct xgene_enet_cle *cle)\n{\n\tu32 secret_key_ipv4[4];   \n\tint ret = 0;\n\n\tget_random_bytes(secret_key_ipv4, 16);\n\tret = xgene_cle_dram_wr(cle, secret_key_ipv4, 4, 0,\n\t\t\t\tRSS_IPV4_HASH_SKEY, CLE_CMD_WR);\n\treturn ret;\n}\n\nstatic int xgene_cle_set_rss_idt(struct xgene_enet_pdata *pdata)\n{\n\tu32 fpsel, dstqid, nfpsel, idt_reg, idx;\n\tint i, ret = 0;\n\tu16 pool_id;\n\n\tfor (i = 0; i < XGENE_CLE_IDT_ENTRIES; i++) {\n\t\tidx = i % pdata->rxq_cnt;\n\t\tpool_id = pdata->rx_ring[idx]->buf_pool->id;\n\t\tfpsel = xgene_enet_get_fpsel(pool_id);\n\t\tdstqid = xgene_enet_dst_ring_num(pdata->rx_ring[idx]);\n\t\tnfpsel = 0;\n\t\tif (pdata->rx_ring[idx]->page_pool) {\n\t\t\tpool_id = pdata->rx_ring[idx]->page_pool->id;\n\t\t\tnfpsel = xgene_enet_get_fpsel(pool_id);\n\t\t}\n\n\t\tidt_reg = 0;\n\t\txgene_cle_idt_to_hw(pdata, dstqid, fpsel, nfpsel, &idt_reg);\n\t\tret = xgene_cle_dram_wr(&pdata->cle, &idt_reg, 1, i,\n\t\t\t\t\tRSS_IDT, CLE_CMD_WR);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = xgene_cle_set_rss_skeys(&pdata->cle);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int xgene_cle_setup_rss(struct xgene_enet_pdata *pdata)\n{\n\tstruct xgene_enet_cle *cle = &pdata->cle;\n\tvoid __iomem *base = cle->base;\n\tu32 offset, val = 0;\n\tint i, ret = 0;\n\n\toffset = CLE_PORT_OFFSET;\n\tfor (i = 0; i < cle->parsers; i++) {\n\t\tif (cle->active_parser != PARSER_ALL)\n\t\t\toffset = cle->active_parser * CLE_PORT_OFFSET;\n\t\telse\n\t\t\toffset = i * CLE_PORT_OFFSET;\n\n\t\t \n\t\tval = (RSS_IPV4_12B << 1) | 0x1;\n\t\twritel(val, base + RSS_CTRL0 + offset);\n\t}\n\n\t \n\tret = xgene_cle_set_rss_sband(cle);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = xgene_cle_set_rss_idt(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int xgene_enet_cle_init(struct xgene_enet_pdata *pdata)\n{\n\tstruct xgene_enet_cle *enet_cle = &pdata->cle;\n\tu32 def_qid, def_fpsel, def_nxtfpsel, pool_id;\n\tstruct xgene_cle_dbptr dbptr[DB_MAX_PTRS];\n\tstruct xgene_cle_ptree *ptree;\n\tstruct xgene_cle_ptree_kn kn;\n\tint ret;\n\n\tif (pdata->phy_mode != PHY_INTERFACE_MODE_XGMII)\n\t\treturn -EINVAL;\n\n\tptree = &enet_cle->ptree;\n\tptree->start_pkt = 12;  \n\n\tret = xgene_cle_setup_rss(pdata);\n\tif (ret) {\n\t\tnetdev_err(pdata->ndev, \"RSS initialization failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdef_qid = xgene_enet_dst_ring_num(pdata->rx_ring[0]);\n\tpool_id = pdata->rx_ring[0]->buf_pool->id;\n\tdef_fpsel = xgene_enet_get_fpsel(pool_id);\n\tdef_nxtfpsel = 0;\n\tif (pdata->rx_ring[0]->page_pool) {\n\t\tpool_id = pdata->rx_ring[0]->page_pool->id;\n\t\tdef_nxtfpsel = xgene_enet_get_fpsel(pool_id);\n\t}\n\n\tmemset(dbptr, 0, sizeof(struct xgene_cle_dbptr) * DB_MAX_PTRS);\n\tdbptr[DB_RES_ACCEPT].fpsel =  def_fpsel;\n\tdbptr[DB_RES_ACCEPT].nxtfpsel = def_nxtfpsel;\n\tdbptr[DB_RES_ACCEPT].dstqid = def_qid;\n\tdbptr[DB_RES_ACCEPT].cle_priority = 1;\n\n\tdbptr[DB_RES_DEF].fpsel = def_fpsel;\n\tdbptr[DB_RES_DEF].nxtfpsel = def_nxtfpsel;\n\tdbptr[DB_RES_DEF].dstqid = def_qid;\n\tdbptr[DB_RES_DEF].cle_priority = 7;\n\txgene_cle_setup_def_dbptr(pdata, enet_cle, &dbptr[DB_RES_DEF],\n\t\t\t\t  DB_RES_ACCEPT, 7);\n\n\tdbptr[DB_RES_DROP].drop = 1;\n\n\tmemset(&kn, 0, sizeof(kn));\n\tkn.node_type = KN;\n\tkn.num_keys = 1;\n\tkn.key[0].priority = 0;\n\tkn.key[0].result_pointer = DB_RES_ACCEPT;\n\n\tptree->kn = &kn;\n\tptree->dbptr = dbptr;\n\tptree->num_kn = 1;\n\tptree->num_dbptr = DB_MAX_PTRS;\n\n\treturn xgene_cle_setup_ptree(pdata, enet_cle);\n}\n\nconst struct xgene_cle_ops xgene_cle3in_ops = {\n\t.cle_init = xgene_enet_cle_init,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}