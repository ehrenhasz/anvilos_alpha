{
  "module_name": "xgene_enet_hw.c",
  "hash_id": "d2a53837d240db3ab664dc55169e0278760d69e97b463a185a14e8164866c909",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/apm/xgene/xgene_enet_hw.c",
  "human_readable_source": "\n \n\n#include \"xgene_enet_main.h\"\n#include \"xgene_enet_hw.h\"\n\nstatic void xgene_enet_ring_init(struct xgene_enet_desc_ring *ring)\n{\n\tu32 *ring_cfg = ring->state;\n\tu64 addr = ring->dma;\n\tenum xgene_enet_ring_cfgsize cfgsize = ring->cfgsize;\n\n\tring_cfg[4] |= (1 << SELTHRSH_POS) &\n\t\t\tCREATE_MASK(SELTHRSH_POS, SELTHRSH_LEN);\n\tring_cfg[3] |= ACCEPTLERR;\n\tring_cfg[2] |= QCOHERENT;\n\n\taddr >>= 8;\n\tring_cfg[2] |= (addr << RINGADDRL_POS) &\n\t\t\tCREATE_MASK_ULL(RINGADDRL_POS, RINGADDRL_LEN);\n\taddr >>= RINGADDRL_LEN;\n\tring_cfg[3] |= addr & CREATE_MASK_ULL(RINGADDRH_POS, RINGADDRH_LEN);\n\tring_cfg[3] |= ((u32)cfgsize << RINGSIZE_POS) &\n\t\t\tCREATE_MASK(RINGSIZE_POS, RINGSIZE_LEN);\n}\n\nstatic void xgene_enet_ring_set_type(struct xgene_enet_desc_ring *ring)\n{\n\tu32 *ring_cfg = ring->state;\n\tbool is_bufpool;\n\tu32 val;\n\n\tis_bufpool = xgene_enet_is_bufpool(ring->id);\n\tval = (is_bufpool) ? RING_BUFPOOL : RING_REGULAR;\n\tring_cfg[4] |= (val << RINGTYPE_POS) &\n\t\t\tCREATE_MASK(RINGTYPE_POS, RINGTYPE_LEN);\n\n\tif (is_bufpool) {\n\t\tring_cfg[3] |= (BUFPOOL_MODE << RINGMODE_POS) &\n\t\t\t\tCREATE_MASK(RINGMODE_POS, RINGMODE_LEN);\n\t}\n}\n\nstatic void xgene_enet_ring_set_recombbuf(struct xgene_enet_desc_ring *ring)\n{\n\tu32 *ring_cfg = ring->state;\n\n\tring_cfg[3] |= RECOMBBUF;\n\tring_cfg[3] |= (0xf << RECOMTIMEOUTL_POS) &\n\t\t\tCREATE_MASK(RECOMTIMEOUTL_POS, RECOMTIMEOUTL_LEN);\n\tring_cfg[4] |= 0x7 & CREATE_MASK(RECOMTIMEOUTH_POS, RECOMTIMEOUTH_LEN);\n}\n\nstatic void xgene_enet_ring_wr32(struct xgene_enet_desc_ring *ring,\n\t\t\t\t u32 offset, u32 data)\n{\n\tstruct xgene_enet_pdata *pdata = netdev_priv(ring->ndev);\n\n\tiowrite32(data, pdata->ring_csr_addr + offset);\n}\n\nstatic void xgene_enet_ring_rd32(struct xgene_enet_desc_ring *ring,\n\t\t\t\t u32 offset, u32 *data)\n{\n\tstruct xgene_enet_pdata *pdata = netdev_priv(ring->ndev);\n\n\t*data = ioread32(pdata->ring_csr_addr + offset);\n}\n\nstatic void xgene_enet_write_ring_state(struct xgene_enet_desc_ring *ring)\n{\n\tstruct xgene_enet_pdata *pdata = netdev_priv(ring->ndev);\n\tint i;\n\n\txgene_enet_ring_wr32(ring, CSR_RING_CONFIG, ring->num);\n\tfor (i = 0; i < pdata->ring_ops->num_ring_config; i++) {\n\t\txgene_enet_ring_wr32(ring, CSR_RING_WR_BASE + (i * 4),\n\t\t\t\t     ring->state[i]);\n\t}\n}\n\nstatic void xgene_enet_clr_ring_state(struct xgene_enet_desc_ring *ring)\n{\n\tmemset(ring->state, 0, sizeof(ring->state));\n\txgene_enet_write_ring_state(ring);\n}\n\nstatic void xgene_enet_set_ring_state(struct xgene_enet_desc_ring *ring)\n{\n\txgene_enet_ring_set_type(ring);\n\n\tif (xgene_enet_ring_owner(ring->id) == RING_OWNER_ETH0 ||\n\t    xgene_enet_ring_owner(ring->id) == RING_OWNER_ETH1)\n\t\txgene_enet_ring_set_recombbuf(ring);\n\n\txgene_enet_ring_init(ring);\n\txgene_enet_write_ring_state(ring);\n}\n\nstatic void xgene_enet_set_ring_id(struct xgene_enet_desc_ring *ring)\n{\n\tu32 ring_id_val, ring_id_buf;\n\tbool is_bufpool;\n\n\tis_bufpool = xgene_enet_is_bufpool(ring->id);\n\n\tring_id_val = ring->id & GENMASK(9, 0);\n\tring_id_val |= OVERWRITE;\n\n\tring_id_buf = (ring->num << 9) & GENMASK(18, 9);\n\tring_id_buf |= PREFETCH_BUF_EN;\n\tif (is_bufpool)\n\t\tring_id_buf |= IS_BUFFER_POOL;\n\n\txgene_enet_ring_wr32(ring, CSR_RING_ID, ring_id_val);\n\txgene_enet_ring_wr32(ring, CSR_RING_ID_BUF, ring_id_buf);\n}\n\nstatic void xgene_enet_clr_desc_ring_id(struct xgene_enet_desc_ring *ring)\n{\n\tu32 ring_id;\n\n\tring_id = ring->id | OVERWRITE;\n\txgene_enet_ring_wr32(ring, CSR_RING_ID, ring_id);\n\txgene_enet_ring_wr32(ring, CSR_RING_ID_BUF, 0);\n}\n\nstatic struct xgene_enet_desc_ring *xgene_enet_setup_ring(\n\t\t\t\t    struct xgene_enet_desc_ring *ring)\n{\n\tu32 size = ring->size;\n\tu32 i, data;\n\tbool is_bufpool;\n\n\txgene_enet_clr_ring_state(ring);\n\txgene_enet_set_ring_state(ring);\n\txgene_enet_set_ring_id(ring);\n\n\tring->slots = xgene_enet_get_numslots(ring->id, size);\n\n\tis_bufpool = xgene_enet_is_bufpool(ring->id);\n\tif (is_bufpool || xgene_enet_ring_owner(ring->id) != RING_OWNER_CPU)\n\t\treturn ring;\n\n\tfor (i = 0; i < ring->slots; i++)\n\t\txgene_enet_mark_desc_slot_empty(&ring->raw_desc[i]);\n\n\txgene_enet_ring_rd32(ring, CSR_RING_NE_INT_MODE, &data);\n\tdata |= BIT(31 - xgene_enet_ring_bufnum(ring->id));\n\txgene_enet_ring_wr32(ring, CSR_RING_NE_INT_MODE, data);\n\n\treturn ring;\n}\n\nstatic void xgene_enet_clear_ring(struct xgene_enet_desc_ring *ring)\n{\n\tu32 data;\n\tbool is_bufpool;\n\n\tis_bufpool = xgene_enet_is_bufpool(ring->id);\n\tif (is_bufpool || xgene_enet_ring_owner(ring->id) != RING_OWNER_CPU)\n\t\tgoto out;\n\n\txgene_enet_ring_rd32(ring, CSR_RING_NE_INT_MODE, &data);\n\tdata &= ~BIT(31 - xgene_enet_ring_bufnum(ring->id));\n\txgene_enet_ring_wr32(ring, CSR_RING_NE_INT_MODE, data);\n\nout:\n\txgene_enet_clr_desc_ring_id(ring);\n\txgene_enet_clr_ring_state(ring);\n}\n\nstatic void xgene_enet_wr_cmd(struct xgene_enet_desc_ring *ring, int count)\n{\n\tiowrite32(count, ring->cmd);\n}\n\nstatic u32 xgene_enet_ring_len(struct xgene_enet_desc_ring *ring)\n{\n\tu32 __iomem *cmd_base = ring->cmd_base;\n\tu32 ring_state, num_msgs;\n\n\tring_state = ioread32(&cmd_base[1]);\n\tnum_msgs = GET_VAL(NUMMSGSINQ, ring_state);\n\n\treturn num_msgs;\n}\n\nvoid xgene_enet_parse_error(struct xgene_enet_desc_ring *ring,\n\t\t\t    enum xgene_enet_err_code status)\n{\n\tswitch (status) {\n\tcase INGRESS_CRC:\n\t\tring->rx_crc_errors++;\n\t\tbreak;\n\tcase INGRESS_CHECKSUM:\n\tcase INGRESS_CHECKSUM_COMPUTE:\n\t\tring->rx_errors++;\n\t\tbreak;\n\tcase INGRESS_TRUNC_FRAME:\n\t\tring->rx_frame_errors++;\n\t\tbreak;\n\tcase INGRESS_PKT_LEN:\n\t\tring->rx_length_errors++;\n\t\tbreak;\n\tcase INGRESS_PKT_UNDER:\n\t\tring->rx_frame_errors++;\n\t\tbreak;\n\tcase INGRESS_FIFO_OVERRUN:\n\t\tring->rx_fifo_errors++;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void xgene_enet_wr_csr(struct xgene_enet_pdata *pdata,\n\t\t\t      u32 offset, u32 val)\n{\n\tvoid __iomem *addr = pdata->eth_csr_addr + offset;\n\n\tiowrite32(val, addr);\n}\n\nstatic void xgene_enet_wr_ring_if(struct xgene_enet_pdata *pdata,\n\t\t\t\t  u32 offset, u32 val)\n{\n\tvoid __iomem *addr = pdata->eth_ring_if_addr + offset;\n\n\tiowrite32(val, addr);\n}\n\nstatic void xgene_enet_wr_diag_csr(struct xgene_enet_pdata *pdata,\n\t\t\t\t   u32 offset, u32 val)\n{\n\tvoid __iomem *addr = pdata->eth_diag_csr_addr + offset;\n\n\tiowrite32(val, addr);\n}\n\nstatic void xgene_enet_wr_mcx_csr(struct xgene_enet_pdata *pdata,\n\t\t\t\t  u32 offset, u32 val)\n{\n\tvoid __iomem *addr = pdata->mcx_mac_csr_addr + offset;\n\n\tiowrite32(val, addr);\n}\n\nvoid xgene_enet_wr_mac(struct xgene_enet_pdata *pdata, u32 wr_addr, u32 wr_data)\n{\n\tvoid __iomem *addr, *wr, *cmd, *cmd_done;\n\tstruct net_device *ndev = pdata->ndev;\n\tu8 wait = 10;\n\tu32 done;\n\n\tif (pdata->mdio_driver && ndev->phydev &&\n\t    phy_interface_mode_is_rgmii(pdata->phy_mode)) {\n\t\tstruct mii_bus *bus = ndev->phydev->mdio.bus;\n\n\t\treturn xgene_mdio_wr_mac(bus->priv, wr_addr, wr_data);\n\t}\n\n\taddr = pdata->mcx_mac_addr + MAC_ADDR_REG_OFFSET;\n\twr = pdata->mcx_mac_addr + MAC_WRITE_REG_OFFSET;\n\tcmd = pdata->mcx_mac_addr + MAC_COMMAND_REG_OFFSET;\n\tcmd_done = pdata->mcx_mac_addr + MAC_COMMAND_DONE_REG_OFFSET;\n\n\tspin_lock(&pdata->mac_lock);\n\tiowrite32(wr_addr, addr);\n\tiowrite32(wr_data, wr);\n\tiowrite32(XGENE_ENET_WR_CMD, cmd);\n\n\twhile (!(done = ioread32(cmd_done)) && wait--)\n\t\tudelay(1);\n\n\tif (!done)\n\t\tnetdev_err(ndev, \"mac write failed, addr: %04x data: %08x\\n\",\n\t\t\t   wr_addr, wr_data);\n\n\tiowrite32(0, cmd);\n\tspin_unlock(&pdata->mac_lock);\n}\n\nstatic void xgene_enet_rd_csr(struct xgene_enet_pdata *pdata,\n\t\t\t      u32 offset, u32 *val)\n{\n\tvoid __iomem *addr = pdata->eth_csr_addr + offset;\n\n\t*val = ioread32(addr);\n}\n\nstatic void xgene_enet_rd_diag_csr(struct xgene_enet_pdata *pdata,\n\t\t\t\t   u32 offset, u32 *val)\n{\n\tvoid __iomem *addr = pdata->eth_diag_csr_addr + offset;\n\n\t*val = ioread32(addr);\n}\n\nstatic void xgene_enet_rd_mcx_csr(struct xgene_enet_pdata *pdata,\n\t\t\t\t  u32 offset, u32 *val)\n{\n\tvoid __iomem *addr = pdata->mcx_mac_csr_addr + offset;\n\n\t*val = ioread32(addr);\n}\n\nu32 xgene_enet_rd_mac(struct xgene_enet_pdata *pdata, u32 rd_addr)\n{\n\tvoid __iomem *addr, *rd, *cmd, *cmd_done;\n\tstruct net_device *ndev = pdata->ndev;\n\tu32 done, rd_data;\n\tu8 wait = 10;\n\n\tif (pdata->mdio_driver && ndev->phydev &&\n\t    phy_interface_mode_is_rgmii(pdata->phy_mode)) {\n\t\tstruct mii_bus *bus = ndev->phydev->mdio.bus;\n\n\t\treturn xgene_mdio_rd_mac(bus->priv, rd_addr);\n\t}\n\n\taddr = pdata->mcx_mac_addr + MAC_ADDR_REG_OFFSET;\n\trd = pdata->mcx_mac_addr + MAC_READ_REG_OFFSET;\n\tcmd = pdata->mcx_mac_addr + MAC_COMMAND_REG_OFFSET;\n\tcmd_done = pdata->mcx_mac_addr + MAC_COMMAND_DONE_REG_OFFSET;\n\n\tspin_lock(&pdata->mac_lock);\n\tiowrite32(rd_addr, addr);\n\tiowrite32(XGENE_ENET_RD_CMD, cmd);\n\n\twhile (!(done = ioread32(cmd_done)) && wait--)\n\t\tudelay(1);\n\n\tif (!done)\n\t\tnetdev_err(ndev, \"mac read failed, addr: %04x\\n\", rd_addr);\n\n\trd_data = ioread32(rd);\n\tiowrite32(0, cmd);\n\tspin_unlock(&pdata->mac_lock);\n\n\treturn rd_data;\n}\n\nu32 xgene_enet_rd_stat(struct xgene_enet_pdata *pdata, u32 rd_addr)\n{\n\tvoid __iomem *addr, *rd, *cmd, *cmd_done;\n\tu32 done, rd_data;\n\tu8 wait = 10;\n\n\taddr = pdata->mcx_stats_addr + STAT_ADDR_REG_OFFSET;\n\trd = pdata->mcx_stats_addr + STAT_READ_REG_OFFSET;\n\tcmd = pdata->mcx_stats_addr + STAT_COMMAND_REG_OFFSET;\n\tcmd_done = pdata->mcx_stats_addr + STAT_COMMAND_DONE_REG_OFFSET;\n\n\tspin_lock(&pdata->stats_lock);\n\tiowrite32(rd_addr, addr);\n\tiowrite32(XGENE_ENET_RD_CMD, cmd);\n\n\twhile (!(done = ioread32(cmd_done)) && wait--)\n\t\tudelay(1);\n\n\tif (!done)\n\t\tnetdev_err(pdata->ndev, \"mac stats read failed, addr: %04x\\n\",\n\t\t\t   rd_addr);\n\n\trd_data = ioread32(rd);\n\tiowrite32(0, cmd);\n\tspin_unlock(&pdata->stats_lock);\n\n\treturn rd_data;\n}\n\nstatic void xgene_gmac_set_mac_addr(struct xgene_enet_pdata *pdata)\n{\n\tconst u8 *dev_addr = pdata->ndev->dev_addr;\n\tu32 addr0, addr1;\n\n\taddr0 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |\n\t\t(dev_addr[1] << 8) | dev_addr[0];\n\taddr1 = (dev_addr[5] << 24) | (dev_addr[4] << 16);\n\n\txgene_enet_wr_mac(pdata, STATION_ADDR0_ADDR, addr0);\n\txgene_enet_wr_mac(pdata, STATION_ADDR1_ADDR, addr1);\n}\n\nstatic int xgene_enet_ecc_init(struct xgene_enet_pdata *pdata)\n{\n\tstruct net_device *ndev = pdata->ndev;\n\tu32 data;\n\tu8 wait = 10;\n\n\txgene_enet_wr_diag_csr(pdata, ENET_CFG_MEM_RAM_SHUTDOWN_ADDR, 0x0);\n\tdo {\n\t\tusleep_range(100, 110);\n\t\txgene_enet_rd_diag_csr(pdata, ENET_BLOCK_MEM_RDY_ADDR, &data);\n\t} while ((data != 0xffffffff) && wait--);\n\n\tif (data != 0xffffffff) {\n\t\tnetdev_err(ndev, \"Failed to release memory from shutdown\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void xgene_gmac_reset(struct xgene_enet_pdata *pdata)\n{\n\txgene_enet_wr_mac(pdata, MAC_CONFIG_1_ADDR, SOFT_RESET1);\n\txgene_enet_wr_mac(pdata, MAC_CONFIG_1_ADDR, 0);\n}\n\nstatic void xgene_enet_configure_clock(struct xgene_enet_pdata *pdata)\n{\n\tstruct device *dev = &pdata->pdev->dev;\n\n\tif (dev->of_node) {\n\t\tstruct clk *parent = clk_get_parent(pdata->clk);\n\n\t\tswitch (pdata->phy_speed) {\n\t\tcase SPEED_10:\n\t\t\tclk_set_rate(parent, 2500000);\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tclk_set_rate(parent, 25000000);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclk_set_rate(parent, 125000000);\n\t\t\tbreak;\n\t\t}\n\t}\n#ifdef CONFIG_ACPI\n\telse {\n\t\tswitch (pdata->phy_speed) {\n\t\tcase SPEED_10:\n\t\t\tacpi_evaluate_object(ACPI_HANDLE(dev),\n\t\t\t\t\t     \"S10\", NULL, NULL);\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tacpi_evaluate_object(ACPI_HANDLE(dev),\n\t\t\t\t\t     \"S100\", NULL, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tacpi_evaluate_object(ACPI_HANDLE(dev),\n\t\t\t\t\t     \"S1G\", NULL, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n}\n\nstatic void xgene_gmac_set_speed(struct xgene_enet_pdata *pdata)\n{\n\tu32 icm0, icm2, mc2;\n\tu32 intf_ctl, rgmii, value;\n\n\txgene_enet_rd_mcx_csr(pdata, ICM_CONFIG0_REG_0_ADDR, &icm0);\n\txgene_enet_rd_mcx_csr(pdata, ICM_CONFIG2_REG_0_ADDR, &icm2);\n\tmc2 = xgene_enet_rd_mac(pdata, MAC_CONFIG_2_ADDR);\n\tintf_ctl = xgene_enet_rd_mac(pdata, INTERFACE_CONTROL_ADDR);\n\txgene_enet_rd_csr(pdata, RGMII_REG_0_ADDR, &rgmii);\n\n\tswitch (pdata->phy_speed) {\n\tcase SPEED_10:\n\t\tENET_INTERFACE_MODE2_SET(&mc2, 1);\n\t\tintf_ctl &= ~(ENET_LHD_MODE | ENET_GHD_MODE);\n\t\tCFG_MACMODE_SET(&icm0, 0);\n\t\tCFG_WAITASYNCRD_SET(&icm2, 500);\n\t\trgmii &= ~CFG_SPEED_1250;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tENET_INTERFACE_MODE2_SET(&mc2, 1);\n\t\tintf_ctl &= ~ENET_GHD_MODE;\n\t\tintf_ctl |= ENET_LHD_MODE;\n\t\tCFG_MACMODE_SET(&icm0, 1);\n\t\tCFG_WAITASYNCRD_SET(&icm2, 80);\n\t\trgmii &= ~CFG_SPEED_1250;\n\t\tbreak;\n\tdefault:\n\t\tENET_INTERFACE_MODE2_SET(&mc2, 2);\n\t\tintf_ctl &= ~ENET_LHD_MODE;\n\t\tintf_ctl |= ENET_GHD_MODE;\n\t\tCFG_MACMODE_SET(&icm0, 2);\n\t\tCFG_WAITASYNCRD_SET(&icm2, 0);\n\t\tCFG_TXCLK_MUXSEL0_SET(&rgmii, pdata->tx_delay);\n\t\tCFG_RXCLK_MUXSEL0_SET(&rgmii, pdata->rx_delay);\n\t\trgmii |= CFG_SPEED_1250;\n\n\t\txgene_enet_rd_csr(pdata, DEBUG_REG_ADDR, &value);\n\t\tvalue |= CFG_BYPASS_UNISEC_TX | CFG_BYPASS_UNISEC_RX;\n\t\txgene_enet_wr_csr(pdata, DEBUG_REG_ADDR, value);\n\t\tbreak;\n\t}\n\n\tmc2 |= FULL_DUPLEX2 | PAD_CRC | LENGTH_CHK;\n\txgene_enet_wr_mac(pdata, MAC_CONFIG_2_ADDR, mc2);\n\txgene_enet_wr_mac(pdata, INTERFACE_CONTROL_ADDR, intf_ctl);\n\txgene_enet_wr_csr(pdata, RGMII_REG_0_ADDR, rgmii);\n\txgene_enet_configure_clock(pdata);\n\n\txgene_enet_wr_mcx_csr(pdata, ICM_CONFIG0_REG_0_ADDR, icm0);\n\txgene_enet_wr_mcx_csr(pdata, ICM_CONFIG2_REG_0_ADDR, icm2);\n}\n\nstatic void xgene_enet_set_frame_size(struct xgene_enet_pdata *pdata, int size)\n{\n\txgene_enet_wr_mac(pdata, MAX_FRAME_LEN_ADDR, size);\n}\n\nstatic void xgene_gmac_enable_tx_pause(struct xgene_enet_pdata *pdata,\n\t\t\t\t       bool enable)\n{\n\tu32 data;\n\n\txgene_enet_rd_mcx_csr(pdata, CSR_ECM_CFG_0_ADDR, &data);\n\n\tif (enable)\n\t\tdata |= MULTI_DPF_AUTOCTRL | PAUSE_XON_EN;\n\telse\n\t\tdata &= ~(MULTI_DPF_AUTOCTRL | PAUSE_XON_EN);\n\n\txgene_enet_wr_mcx_csr(pdata, CSR_ECM_CFG_0_ADDR, data);\n}\n\nstatic void xgene_gmac_flowctl_tx(struct xgene_enet_pdata *pdata, bool enable)\n{\n\tu32 data;\n\n\tdata = xgene_enet_rd_mac(pdata, MAC_CONFIG_1_ADDR);\n\n\tif (enable)\n\t\tdata |= TX_FLOW_EN;\n\telse\n\t\tdata &= ~TX_FLOW_EN;\n\n\txgene_enet_wr_mac(pdata, MAC_CONFIG_1_ADDR, data);\n\n\tpdata->mac_ops->enable_tx_pause(pdata, enable);\n}\n\nstatic void xgene_gmac_flowctl_rx(struct xgene_enet_pdata *pdata, bool enable)\n{\n\tu32 data;\n\n\tdata = xgene_enet_rd_mac(pdata, MAC_CONFIG_1_ADDR);\n\n\tif (enable)\n\t\tdata |= RX_FLOW_EN;\n\telse\n\t\tdata &= ~RX_FLOW_EN;\n\n\txgene_enet_wr_mac(pdata, MAC_CONFIG_1_ADDR, data);\n}\n\nstatic void xgene_gmac_init(struct xgene_enet_pdata *pdata)\n{\n\tu32 value;\n\n\tif (!pdata->mdio_driver)\n\t\txgene_gmac_reset(pdata);\n\n\txgene_gmac_set_speed(pdata);\n\txgene_gmac_set_mac_addr(pdata);\n\n\t \n\tvalue = xgene_enet_rd_mac(pdata, MII_MGMT_CONFIG_ADDR);\n\tMGMT_CLOCK_SEL_SET(&value, 7);\n\txgene_enet_wr_mac(pdata, MII_MGMT_CONFIG_ADDR, value);\n\n\t \n\txgene_enet_rd_csr(pdata, RSIF_CONFIG_REG_ADDR, &value);\n\tvalue |= CFG_RSIF_FPBUFF_TIMEOUT_EN;\n\txgene_enet_wr_csr(pdata, RSIF_CONFIG_REG_ADDR, value);\n\n\t \n\txgene_enet_wr_csr(pdata, RSIF_RAM_DBG_REG0_ADDR, 0);\n\n\t \n\txgene_enet_rd_mcx_csr(pdata, CSR_MULTI_DPF0_ADDR, &value);\n\tvalue = (DEF_QUANTA << 16) | (value & 0xFFFF);\n\txgene_enet_wr_mcx_csr(pdata, CSR_MULTI_DPF0_ADDR, value);\n\n\txgene_enet_wr_csr(pdata, RXBUF_PAUSE_THRESH, DEF_PAUSE_THRES);\n\txgene_enet_wr_csr(pdata, RXBUF_PAUSE_OFF_THRESH, DEF_PAUSE_OFF_THRES);\n\n\txgene_gmac_flowctl_tx(pdata, pdata->tx_pause);\n\txgene_gmac_flowctl_rx(pdata, pdata->rx_pause);\n\n\t \n\txgene_enet_wr_csr(pdata, CFG_LINK_AGGR_RESUME_0_ADDR, TX_PORT0);\n\n\txgene_enet_rd_mcx_csr(pdata, RX_DV_GATE_REG_0_ADDR, &value);\n\tvalue &= ~TX_DV_GATE_EN0;\n\tvalue &= ~RX_DV_GATE_EN0;\n\tvalue |= RESUME_RX0;\n\txgene_enet_wr_mcx_csr(pdata, RX_DV_GATE_REG_0_ADDR, value);\n\n\txgene_enet_wr_csr(pdata, CFG_BYPASS_ADDR, RESUME_TX);\n}\n\nstatic void xgene_gmac_get_drop_cnt(struct xgene_enet_pdata *pdata,\n\t\t\t\t    u32 *rx, u32 *tx)\n{\n\tu32 count;\n\n\txgene_enet_rd_mcx_csr(pdata, ICM_ECM_DROP_COUNT_REG0_ADDR, &count);\n\t*rx = ICM_DROP_COUNT(count);\n\t*tx = ECM_DROP_COUNT(count);\n\t \n\txgene_enet_rd_mcx_csr(pdata, ECM_CONFIG0_REG_0_ADDR, &count);\n}\n\nstatic void xgene_enet_config_ring_if_assoc(struct xgene_enet_pdata *pdata)\n{\n\tu32 val = 0xffffffff;\n\n\txgene_enet_wr_ring_if(pdata, ENET_CFGSSQMIWQASSOC_ADDR, val);\n\txgene_enet_wr_ring_if(pdata, ENET_CFGSSQMIFPQASSOC_ADDR, val);\n\txgene_enet_wr_ring_if(pdata, ENET_CFGSSQMIQMLITEWQASSOC_ADDR, val);\n\txgene_enet_wr_ring_if(pdata, ENET_CFGSSQMIQMLITEFPQASSOC_ADDR, val);\n}\n\nstatic void xgene_enet_cle_bypass(struct xgene_enet_pdata *pdata,\n\t\t\t\t  u32 dst_ring_num, u16 bufpool_id,\n\t\t\t\t  u16 nxtbufpool_id)\n{\n\tu32 cb;\n\tu32 fpsel, nxtfpsel;\n\n\tfpsel = xgene_enet_get_fpsel(bufpool_id);\n\tnxtfpsel = xgene_enet_get_fpsel(nxtbufpool_id);\n\n\txgene_enet_rd_csr(pdata, CLE_BYPASS_REG0_0_ADDR, &cb);\n\tcb |= CFG_CLE_BYPASS_EN0;\n\tCFG_CLE_IP_PROTOCOL0_SET(&cb, 3);\n\tCFG_CLE_IP_HDR_LEN_SET(&cb, 0);\n\txgene_enet_wr_csr(pdata, CLE_BYPASS_REG0_0_ADDR, cb);\n\n\txgene_enet_rd_csr(pdata, CLE_BYPASS_REG1_0_ADDR, &cb);\n\tCFG_CLE_DSTQID0_SET(&cb, dst_ring_num);\n\tCFG_CLE_FPSEL0_SET(&cb, fpsel);\n\tCFG_CLE_NXTFPSEL0_SET(&cb, nxtfpsel);\n\txgene_enet_wr_csr(pdata, CLE_BYPASS_REG1_0_ADDR, cb);\n}\n\nstatic void xgene_gmac_rx_enable(struct xgene_enet_pdata *pdata)\n{\n\tu32 data;\n\n\tdata = xgene_enet_rd_mac(pdata, MAC_CONFIG_1_ADDR);\n\txgene_enet_wr_mac(pdata, MAC_CONFIG_1_ADDR, data | RX_EN);\n}\n\nstatic void xgene_gmac_tx_enable(struct xgene_enet_pdata *pdata)\n{\n\tu32 data;\n\n\tdata = xgene_enet_rd_mac(pdata, MAC_CONFIG_1_ADDR);\n\txgene_enet_wr_mac(pdata, MAC_CONFIG_1_ADDR, data | TX_EN);\n}\n\nstatic void xgene_gmac_rx_disable(struct xgene_enet_pdata *pdata)\n{\n\tu32 data;\n\n\tdata = xgene_enet_rd_mac(pdata, MAC_CONFIG_1_ADDR);\n\txgene_enet_wr_mac(pdata, MAC_CONFIG_1_ADDR, data & ~RX_EN);\n}\n\nstatic void xgene_gmac_tx_disable(struct xgene_enet_pdata *pdata)\n{\n\tu32 data;\n\n\tdata = xgene_enet_rd_mac(pdata, MAC_CONFIG_1_ADDR);\n\txgene_enet_wr_mac(pdata, MAC_CONFIG_1_ADDR, data & ~TX_EN);\n}\n\nbool xgene_ring_mgr_init(struct xgene_enet_pdata *p)\n{\n\tif (!ioread32(p->ring_csr_addr + CLKEN_ADDR))\n\t\treturn false;\n\n\tif (ioread32(p->ring_csr_addr + SRST_ADDR))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int xgene_enet_reset(struct xgene_enet_pdata *pdata)\n{\n\tstruct device *dev = &pdata->pdev->dev;\n\n\tif (!xgene_ring_mgr_init(pdata))\n\t\treturn -ENODEV;\n\n\tif (pdata->mdio_driver) {\n\t\txgene_enet_config_ring_if_assoc(pdata);\n\t\treturn 0;\n\t}\n\n\tif (dev->of_node) {\n\t\tclk_prepare_enable(pdata->clk);\n\t\tudelay(5);\n\t\tclk_disable_unprepare(pdata->clk);\n\t\tudelay(5);\n\t\tclk_prepare_enable(pdata->clk);\n\t\tudelay(5);\n\t} else {\n#ifdef CONFIG_ACPI\n\t\tacpi_status status;\n\n\t\tstatus = acpi_evaluate_object(ACPI_HANDLE(&pdata->pdev->dev),\n\t\t\t\t\t      \"_RST\", NULL, NULL);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_evaluate_object(ACPI_HANDLE(&pdata->pdev->dev),\n\t\t\t\t\t     \"_INI\", NULL, NULL);\n\t\t}\n#endif\n\t}\n\n\txgene_enet_ecc_init(pdata);\n\txgene_enet_config_ring_if_assoc(pdata);\n\n\treturn 0;\n}\n\nstatic void xgene_enet_clear(struct xgene_enet_pdata *pdata,\n\t\t\t     struct xgene_enet_desc_ring *ring)\n{\n\tu32 addr, data;\n\n\tif (xgene_enet_is_bufpool(ring->id)) {\n\t\taddr = ENET_CFGSSQMIFPRESET_ADDR;\n\t\tdata = BIT(xgene_enet_get_fpsel(ring->id));\n\t} else {\n\t\taddr = ENET_CFGSSQMIWQRESET_ADDR;\n\t\tdata = BIT(xgene_enet_ring_bufnum(ring->id));\n\t}\n\n\txgene_enet_wr_ring_if(pdata, addr, data);\n}\n\nstatic void xgene_gport_shutdown(struct xgene_enet_pdata *pdata)\n{\n\tstruct device *dev = &pdata->pdev->dev;\n\n\tif (dev->of_node) {\n\t\tif (!IS_ERR(pdata->clk))\n\t\t\tclk_disable_unprepare(pdata->clk);\n\t}\n}\n\nstatic u32 xgene_enet_flowctrl_cfg(struct net_device *ndev)\n{\n\tstruct xgene_enet_pdata *pdata = netdev_priv(ndev);\n\tstruct phy_device *phydev = ndev->phydev;\n\tu16 lcladv, rmtadv = 0;\n\tu32 rx_pause, tx_pause;\n\tu8 flowctl = 0;\n\n\tif (!phydev->duplex || !pdata->pause_autoneg)\n\t\treturn 0;\n\n\tif (pdata->tx_pause)\n\t\tflowctl |= FLOW_CTRL_TX;\n\n\tif (pdata->rx_pause)\n\t\tflowctl |= FLOW_CTRL_RX;\n\n\tlcladv = mii_advertise_flowctrl(flowctl);\n\n\tif (phydev->pause)\n\t\trmtadv = LPA_PAUSE_CAP;\n\n\tif (phydev->asym_pause)\n\t\trmtadv |= LPA_PAUSE_ASYM;\n\n\tflowctl = mii_resolve_flowctrl_fdx(lcladv, rmtadv);\n\ttx_pause = !!(flowctl & FLOW_CTRL_TX);\n\trx_pause = !!(flowctl & FLOW_CTRL_RX);\n\n\tif (tx_pause != pdata->tx_pause) {\n\t\tpdata->tx_pause = tx_pause;\n\t\tpdata->mac_ops->flowctl_tx(pdata, pdata->tx_pause);\n\t}\n\n\tif (rx_pause != pdata->rx_pause) {\n\t\tpdata->rx_pause = rx_pause;\n\t\tpdata->mac_ops->flowctl_rx(pdata, pdata->rx_pause);\n\t}\n\n\treturn 0;\n}\n\nstatic void xgene_enet_adjust_link(struct net_device *ndev)\n{\n\tstruct xgene_enet_pdata *pdata = netdev_priv(ndev);\n\tconst struct xgene_mac_ops *mac_ops = pdata->mac_ops;\n\tstruct phy_device *phydev = ndev->phydev;\n\n\tif (phydev->link) {\n\t\tif (pdata->phy_speed != phydev->speed) {\n\t\t\tpdata->phy_speed = phydev->speed;\n\t\t\tmac_ops->set_speed(pdata);\n\t\t\tmac_ops->rx_enable(pdata);\n\t\t\tmac_ops->tx_enable(pdata);\n\t\t\tphy_print_status(phydev);\n\t\t}\n\n\t\txgene_enet_flowctrl_cfg(ndev);\n\t} else {\n\t\tmac_ops->rx_disable(pdata);\n\t\tmac_ops->tx_disable(pdata);\n\t\tpdata->phy_speed = SPEED_UNKNOWN;\n\t\tphy_print_status(phydev);\n\t}\n}\n\n#ifdef CONFIG_ACPI\nstatic struct acpi_device *acpi_phy_find_device(struct device *dev)\n{\n\tstruct fwnode_reference_args args;\n\tstruct fwnode_handle *fw_node;\n\tint status;\n\n\tfw_node = acpi_fwnode_handle(ACPI_COMPANION(dev));\n\tstatus = acpi_node_get_property_reference(fw_node, \"phy-handle\", 0,\n\t\t\t\t\t\t  &args);\n\tif (ACPI_FAILURE(status) || !is_acpi_device_node(args.fwnode)) {\n\t\tdev_dbg(dev, \"No matching phy in ACPI table\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn to_acpi_device_node(args.fwnode);\n}\n#endif\n\nint xgene_enet_phy_connect(struct net_device *ndev)\n{\n\tstruct xgene_enet_pdata *pdata = netdev_priv(ndev);\n\tstruct device_node *np;\n\tstruct phy_device *phy_dev;\n\tstruct device *dev = &pdata->pdev->dev;\n\tint i;\n\n\tif (dev->of_node) {\n\t\tfor (i = 0 ; i < 2; i++) {\n\t\t\tnp = of_parse_phandle(dev->of_node, \"phy-handle\", i);\n\t\t\tphy_dev = of_phy_connect(ndev, np,\n\t\t\t\t\t\t &xgene_enet_adjust_link,\n\t\t\t\t\t\t 0, pdata->phy_mode);\n\t\t\tof_node_put(np);\n\t\t\tif (phy_dev)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!phy_dev) {\n\t\t\tnetdev_err(ndev, \"Could not connect to PHY\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n#ifdef CONFIG_ACPI\n\t\tstruct acpi_device *adev = acpi_phy_find_device(dev);\n\t\tif (adev)\n\t\t\tphy_dev = adev->driver_data;\n\t\telse\n\t\t\tphy_dev = NULL;\n\n\t\tif (!phy_dev ||\n\t\t    phy_connect_direct(ndev, phy_dev, &xgene_enet_adjust_link,\n\t\t\t\t       pdata->phy_mode)) {\n\t\t\tnetdev_err(ndev, \"Could not connect to PHY\\n\");\n\t\t\treturn  -ENODEV;\n\t\t}\n#else\n\t\treturn -ENODEV;\n#endif\n\t}\n\n\tpdata->phy_speed = SPEED_UNKNOWN;\n\tphy_remove_link_mode(phy_dev, ETHTOOL_LINK_MODE_10baseT_Half_BIT);\n\tphy_remove_link_mode(phy_dev, ETHTOOL_LINK_MODE_100baseT_Half_BIT);\n\tphy_remove_link_mode(phy_dev, ETHTOOL_LINK_MODE_1000baseT_Half_BIT);\n\tphy_support_asym_pause(phy_dev);\n\n\treturn 0;\n}\n\nstatic int xgene_mdiobus_register(struct xgene_enet_pdata *pdata,\n\t\t\t\t  struct mii_bus *mdio)\n{\n\tstruct device *dev = &pdata->pdev->dev;\n\tstruct net_device *ndev = pdata->ndev;\n\tstruct phy_device *phy;\n\tstruct device_node *child_np;\n\tstruct device_node *mdio_np = NULL;\n\tu32 phy_addr;\n\tint ret;\n\n\tif (dev->of_node) {\n\t\tfor_each_child_of_node(dev->of_node, child_np) {\n\t\t\tif (of_device_is_compatible(child_np,\n\t\t\t\t\t\t    \"apm,xgene-mdio\")) {\n\t\t\t\tmdio_np = child_np;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!mdio_np) {\n\t\t\tnetdev_dbg(ndev, \"No mdio node in the dts\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\treturn of_mdiobus_register(mdio, mdio_np);\n\t}\n\n\t \n\tmdio->phy_mask = ~0;\n\n\t \n\tret = mdiobus_register(mdio);\n\tif (ret)\n\t\treturn ret;\n\n\tret = device_property_read_u32(dev, \"phy-channel\", &phy_addr);\n\tif (ret)\n\t\tret = device_property_read_u32(dev, \"phy-addr\", &phy_addr);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tphy = xgene_enet_phy_register(mdio, phy_addr);\n\tif (!phy)\n\t\treturn -EIO;\n\n\treturn ret;\n}\n\nint xgene_enet_mdio_config(struct xgene_enet_pdata *pdata)\n{\n\tstruct net_device *ndev = pdata->ndev;\n\tstruct mii_bus *mdio_bus;\n\tint ret;\n\n\tmdio_bus = mdiobus_alloc();\n\tif (!mdio_bus)\n\t\treturn -ENOMEM;\n\n\tmdio_bus->name = \"APM X-Gene MDIO bus\";\n\tmdio_bus->read = xgene_mdio_rgmii_read;\n\tmdio_bus->write = xgene_mdio_rgmii_write;\n\tsnprintf(mdio_bus->id, MII_BUS_ID_SIZE, \"%s-%s\", \"xgene-mii\",\n\t\t ndev->name);\n\n\tmdio_bus->priv = (void __force *)pdata->mcx_mac_addr;\n\tmdio_bus->parent = &pdata->pdev->dev;\n\n\tret = xgene_mdiobus_register(pdata, mdio_bus);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"Failed to register MDIO bus\\n\");\n\t\tmdiobus_free(mdio_bus);\n\t\treturn ret;\n\t}\n\tpdata->mdio_bus = mdio_bus;\n\n\tret = xgene_enet_phy_connect(ndev);\n\tif (ret)\n\t\txgene_enet_mdio_remove(pdata);\n\n\treturn ret;\n}\n\nvoid xgene_enet_phy_disconnect(struct xgene_enet_pdata *pdata)\n{\n\tstruct net_device *ndev = pdata->ndev;\n\n\tif (ndev->phydev)\n\t\tphy_disconnect(ndev->phydev);\n}\n\nvoid xgene_enet_mdio_remove(struct xgene_enet_pdata *pdata)\n{\n\tstruct net_device *ndev = pdata->ndev;\n\n\tif (ndev->phydev)\n\t\tphy_disconnect(ndev->phydev);\n\n\tmdiobus_unregister(pdata->mdio_bus);\n\tmdiobus_free(pdata->mdio_bus);\n\tpdata->mdio_bus = NULL;\n}\n\nconst struct xgene_mac_ops xgene_gmac_ops = {\n\t.init = xgene_gmac_init,\n\t.reset = xgene_gmac_reset,\n\t.rx_enable = xgene_gmac_rx_enable,\n\t.tx_enable = xgene_gmac_tx_enable,\n\t.rx_disable = xgene_gmac_rx_disable,\n\t.tx_disable = xgene_gmac_tx_disable,\n\t.get_drop_cnt = xgene_gmac_get_drop_cnt,\n\t.set_speed = xgene_gmac_set_speed,\n\t.set_mac_addr = xgene_gmac_set_mac_addr,\n\t.set_framesize = xgene_enet_set_frame_size,\n\t.enable_tx_pause = xgene_gmac_enable_tx_pause,\n\t.flowctl_tx     = xgene_gmac_flowctl_tx,\n\t.flowctl_rx     = xgene_gmac_flowctl_rx,\n};\n\nconst struct xgene_port_ops xgene_gport_ops = {\n\t.reset = xgene_enet_reset,\n\t.clear = xgene_enet_clear,\n\t.cle_bypass = xgene_enet_cle_bypass,\n\t.shutdown = xgene_gport_shutdown,\n};\n\nstruct xgene_ring_ops xgene_ring1_ops = {\n\t.num_ring_config = NUM_RING_CONFIG,\n\t.num_ring_id_shift = 6,\n\t.setup = xgene_enet_setup_ring,\n\t.clear = xgene_enet_clear_ring,\n\t.wr_cmd = xgene_enet_wr_cmd,\n\t.len = xgene_enet_ring_len,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}