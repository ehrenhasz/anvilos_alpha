{
  "module_name": "main.c",
  "hash_id": "8dd2a76a638ac7eb1f4aa78e64a8899c6641489a5c6a10a181a4cb2ebecae0e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/apm/xgene-v2/main.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n\nstatic const struct acpi_device_id xge_acpi_match[];\n\nstatic int xge_get_resources(struct xge_pdata *pdata)\n{\n\tstruct platform_device *pdev;\n\tstruct net_device *ndev;\n\tint phy_mode, ret = 0;\n\tstruct resource *res;\n\tstruct device *dev;\n\n\tpdev = pdata->pdev;\n\tdev = &pdev->dev;\n\tndev = pdata->ndev;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"Resource enet_csr not defined\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpdata->resources.base_addr = devm_ioremap(dev, res->start,\n\t\t\t\t\t\t  resource_size(res));\n\tif (!pdata->resources.base_addr) {\n\t\tdev_err(dev, \"Unable to retrieve ENET Port CSR region\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (device_get_ethdev_address(dev, ndev))\n\t\teth_hw_addr_random(ndev);\n\n\tmemcpy(ndev->perm_addr, ndev->dev_addr, ndev->addr_len);\n\n\tphy_mode = device_get_phy_mode(dev);\n\tif (phy_mode < 0) {\n\t\tdev_err(dev, \"Unable to get phy-connection-type\\n\");\n\t\treturn phy_mode;\n\t}\n\tpdata->resources.phy_mode = phy_mode;\n\n\tif (pdata->resources.phy_mode != PHY_INTERFACE_MODE_RGMII) {\n\t\tdev_err(dev, \"Incorrect phy-connection-type specified\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tpdata->resources.irq = ret;\n\n\treturn 0;\n}\n\nstatic int xge_refill_buffers(struct net_device *ndev, u32 nbuf)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\tstruct xge_desc_ring *ring = pdata->rx_ring;\n\tconst u8 slots = XGENE_ENET_NUM_DESC - 1;\n\tstruct device *dev = &pdata->pdev->dev;\n\tstruct xge_raw_desc *raw_desc;\n\tu64 addr_lo, addr_hi;\n\tu8 tail = ring->tail;\n\tstruct sk_buff *skb;\n\tdma_addr_t dma_addr;\n\tu16 len;\n\tint i;\n\n\tfor (i = 0; i < nbuf; i++) {\n\t\traw_desc = &ring->raw_desc[tail];\n\n\t\tlen = XGENE_ENET_STD_MTU;\n\t\tskb = netdev_alloc_skb(ndev, len);\n\t\tif (unlikely(!skb))\n\t\t\treturn -ENOMEM;\n\n\t\tdma_addr = dma_map_single(dev, skb->data, len, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tnetdev_err(ndev, \"DMA mapping error\\n\");\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tring->pkt_info[tail].skb = skb;\n\t\tring->pkt_info[tail].dma_addr = dma_addr;\n\n\t\taddr_hi = GET_BITS(NEXT_DESC_ADDRH, le64_to_cpu(raw_desc->m1));\n\t\taddr_lo = GET_BITS(NEXT_DESC_ADDRL, le64_to_cpu(raw_desc->m1));\n\t\traw_desc->m1 = cpu_to_le64(SET_BITS(NEXT_DESC_ADDRL, addr_lo) |\n\t\t\t\t\t   SET_BITS(NEXT_DESC_ADDRH, addr_hi) |\n\t\t\t\t\t   SET_BITS(PKT_ADDRH,\n\t\t\t\t\t\t    upper_32_bits(dma_addr)));\n\n\t\tdma_wmb();\n\t\traw_desc->m0 = cpu_to_le64(SET_BITS(PKT_ADDRL, dma_addr) |\n\t\t\t\t\t   SET_BITS(E, 1));\n\t\ttail = (tail + 1) & slots;\n\t}\n\n\tring->tail = tail;\n\n\treturn 0;\n}\n\nstatic int xge_init_hw(struct net_device *ndev)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\tint ret;\n\n\tret = xge_port_reset(ndev);\n\tif (ret)\n\t\treturn ret;\n\n\txge_port_init(ndev);\n\tpdata->nbufs = NUM_BUFS;\n\n\treturn 0;\n}\n\nstatic irqreturn_t xge_irq(const int irq, void *data)\n{\n\tstruct xge_pdata *pdata = data;\n\n\tif (napi_schedule_prep(&pdata->napi)) {\n\t\txge_intr_disable(pdata);\n\t\t__napi_schedule(&pdata->napi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int xge_request_irq(struct net_device *ndev)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\tint ret;\n\n\tsnprintf(pdata->irq_name, IRQ_ID_SIZE, \"%s\", ndev->name);\n\n\tret = request_irq(pdata->resources.irq, xge_irq, 0, pdata->irq_name,\n\t\t\t  pdata);\n\tif (ret)\n\t\tnetdev_err(ndev, \"Failed to request irq %s\\n\", pdata->irq_name);\n\n\treturn ret;\n}\n\nstatic void xge_free_irq(struct net_device *ndev)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\n\tfree_irq(pdata->resources.irq, pdata);\n}\n\nstatic bool is_tx_slot_available(struct xge_raw_desc *raw_desc)\n{\n\tif (GET_BITS(E, le64_to_cpu(raw_desc->m0)) &&\n\t    (GET_BITS(PKT_SIZE, le64_to_cpu(raw_desc->m0)) == SLOT_EMPTY))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic netdev_tx_t xge_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\tstruct device *dev = &pdata->pdev->dev;\n\tstruct xge_desc_ring *tx_ring;\n\tstruct xge_raw_desc *raw_desc;\n\tstatic dma_addr_t dma_addr;\n\tu64 addr_lo, addr_hi;\n\tvoid *pkt_buf;\n\tu8 tail;\n\tu16 len;\n\n\ttx_ring = pdata->tx_ring;\n\ttail = tx_ring->tail;\n\tlen = skb_headlen(skb);\n\traw_desc = &tx_ring->raw_desc[tail];\n\n\tif (!is_tx_slot_available(raw_desc)) {\n\t\tnetif_stop_queue(ndev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tpkt_buf = dma_alloc_coherent(dev, XGENE_ENET_STD_MTU, &dma_addr,\n\t\t\t\t     GFP_ATOMIC);\n\tif (unlikely(!pkt_buf)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tmemcpy(pkt_buf, skb->data, len);\n\n\taddr_hi = GET_BITS(NEXT_DESC_ADDRH, le64_to_cpu(raw_desc->m1));\n\taddr_lo = GET_BITS(NEXT_DESC_ADDRL, le64_to_cpu(raw_desc->m1));\n\traw_desc->m1 = cpu_to_le64(SET_BITS(NEXT_DESC_ADDRL, addr_lo) |\n\t\t\t\t   SET_BITS(NEXT_DESC_ADDRH, addr_hi) |\n\t\t\t\t   SET_BITS(PKT_ADDRH,\n\t\t\t\t\t    upper_32_bits(dma_addr)));\n\n\ttx_ring->pkt_info[tail].skb = skb;\n\ttx_ring->pkt_info[tail].dma_addr = dma_addr;\n\ttx_ring->pkt_info[tail].pkt_buf = pkt_buf;\n\n\tdma_wmb();\n\n\traw_desc->m0 = cpu_to_le64(SET_BITS(PKT_ADDRL, dma_addr) |\n\t\t\t\t   SET_BITS(PKT_SIZE, len) |\n\t\t\t\t   SET_BITS(E, 0));\n\tskb_tx_timestamp(skb);\n\txge_wr_csr(pdata, DMATXCTRL, 1);\n\n\ttx_ring->tail = (tail + 1) & (XGENE_ENET_NUM_DESC - 1);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic bool is_tx_hw_done(struct xge_raw_desc *raw_desc)\n{\n\tif (GET_BITS(E, le64_to_cpu(raw_desc->m0)) &&\n\t    !GET_BITS(PKT_SIZE, le64_to_cpu(raw_desc->m0)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void xge_txc_poll(struct net_device *ndev)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\tstruct device *dev = &pdata->pdev->dev;\n\tstruct xge_desc_ring *tx_ring;\n\tstruct xge_raw_desc *raw_desc;\n\tdma_addr_t dma_addr;\n\tstruct sk_buff *skb;\n\tvoid *pkt_buf;\n\tu32 data;\n\tu8 head;\n\n\ttx_ring = pdata->tx_ring;\n\thead = tx_ring->head;\n\n\tdata = xge_rd_csr(pdata, DMATXSTATUS);\n\tif (!GET_BITS(TXPKTCOUNT, data))\n\t\treturn;\n\n\twhile (1) {\n\t\traw_desc = &tx_ring->raw_desc[head];\n\n\t\tif (!is_tx_hw_done(raw_desc))\n\t\t\tbreak;\n\n\t\tdma_rmb();\n\n\t\tskb = tx_ring->pkt_info[head].skb;\n\t\tdma_addr = tx_ring->pkt_info[head].dma_addr;\n\t\tpkt_buf = tx_ring->pkt_info[head].pkt_buf;\n\t\tpdata->stats.tx_packets++;\n\t\tpdata->stats.tx_bytes += skb->len;\n\t\tdma_free_coherent(dev, XGENE_ENET_STD_MTU, pkt_buf, dma_addr);\n\t\tdev_kfree_skb_any(skb);\n\n\t\t \n\t\traw_desc->m0 = cpu_to_le64(SET_BITS(E, 1) |\n\t\t\t\t\t   SET_BITS(PKT_SIZE, SLOT_EMPTY));\n\t\txge_wr_csr(pdata, DMATXSTATUS, 1);\n\n\t\thead = (head + 1) & (XGENE_ENET_NUM_DESC - 1);\n\t}\n\n\tif (netif_queue_stopped(ndev))\n\t\tnetif_wake_queue(ndev);\n\n\ttx_ring->head = head;\n}\n\nstatic int xge_rx_poll(struct net_device *ndev, unsigned int budget)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\tstruct device *dev = &pdata->pdev->dev;\n\tstruct xge_desc_ring *rx_ring;\n\tstruct xge_raw_desc *raw_desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t dma_addr;\n\tint processed = 0;\n\tu8 head, rx_error;\n\tint i, ret;\n\tu32 data;\n\tu16 len;\n\n\trx_ring = pdata->rx_ring;\n\thead = rx_ring->head;\n\n\tdata = xge_rd_csr(pdata, DMARXSTATUS);\n\tif (!GET_BITS(RXPKTCOUNT, data))\n\t\treturn 0;\n\n\tfor (i = 0; i < budget; i++) {\n\t\traw_desc = &rx_ring->raw_desc[head];\n\n\t\tif (GET_BITS(E, le64_to_cpu(raw_desc->m0)))\n\t\t\tbreak;\n\n\t\tdma_rmb();\n\n\t\tskb = rx_ring->pkt_info[head].skb;\n\t\trx_ring->pkt_info[head].skb = NULL;\n\t\tdma_addr = rx_ring->pkt_info[head].dma_addr;\n\t\tlen = GET_BITS(PKT_SIZE, le64_to_cpu(raw_desc->m0));\n\t\tdma_unmap_single(dev, dma_addr, XGENE_ENET_STD_MTU,\n\t\t\t\t DMA_FROM_DEVICE);\n\n\t\trx_error = GET_BITS(D, le64_to_cpu(raw_desc->m2));\n\t\tif (unlikely(rx_error)) {\n\t\t\tpdata->stats.rx_errors++;\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tgoto out;\n\t\t}\n\n\t\tskb_put(skb, len);\n\t\tskb->protocol = eth_type_trans(skb, ndev);\n\n\t\tpdata->stats.rx_packets++;\n\t\tpdata->stats.rx_bytes += len;\n\t\tnapi_gro_receive(&pdata->napi, skb);\nout:\n\t\tret = xge_refill_buffers(ndev, 1);\n\t\txge_wr_csr(pdata, DMARXSTATUS, 1);\n\t\txge_wr_csr(pdata, DMARXCTRL, 1);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\thead = (head + 1) & (XGENE_ENET_NUM_DESC - 1);\n\t\tprocessed++;\n\t}\n\n\trx_ring->head = head;\n\n\treturn processed;\n}\n\nstatic void xge_delete_desc_ring(struct net_device *ndev,\n\t\t\t\t struct xge_desc_ring *ring)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\tstruct device *dev = &pdata->pdev->dev;\n\tu16 size;\n\n\tif (!ring)\n\t\treturn;\n\n\tsize = XGENE_ENET_DESC_SIZE * XGENE_ENET_NUM_DESC;\n\tif (ring->desc_addr)\n\t\tdma_free_coherent(dev, size, ring->desc_addr, ring->dma_addr);\n\n\tkfree(ring->pkt_info);\n\tkfree(ring);\n}\n\nstatic void xge_free_buffers(struct net_device *ndev)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\tstruct xge_desc_ring *ring = pdata->rx_ring;\n\tstruct device *dev = &pdata->pdev->dev;\n\tstruct sk_buff *skb;\n\tdma_addr_t dma_addr;\n\tint i;\n\n\tfor (i = 0; i < XGENE_ENET_NUM_DESC; i++) {\n\t\tskb = ring->pkt_info[i].skb;\n\t\tdma_addr = ring->pkt_info[i].dma_addr;\n\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tdma_unmap_single(dev, dma_addr, XGENE_ENET_STD_MTU,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void xge_delete_desc_rings(struct net_device *ndev)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\n\txge_txc_poll(ndev);\n\txge_delete_desc_ring(ndev, pdata->tx_ring);\n\n\txge_rx_poll(ndev, 64);\n\txge_free_buffers(ndev);\n\txge_delete_desc_ring(ndev, pdata->rx_ring);\n}\n\nstatic struct xge_desc_ring *xge_create_desc_ring(struct net_device *ndev)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\tstruct device *dev = &pdata->pdev->dev;\n\tstruct xge_desc_ring *ring;\n\tu16 size;\n\n\tring = kzalloc(sizeof(*ring), GFP_KERNEL);\n\tif (!ring)\n\t\treturn NULL;\n\n\tring->ndev = ndev;\n\n\tsize = XGENE_ENET_DESC_SIZE * XGENE_ENET_NUM_DESC;\n\tring->desc_addr = dma_alloc_coherent(dev, size, &ring->dma_addr,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!ring->desc_addr)\n\t\tgoto err;\n\n\tring->pkt_info = kcalloc(XGENE_ENET_NUM_DESC, sizeof(*ring->pkt_info),\n\t\t\t\t GFP_KERNEL);\n\tif (!ring->pkt_info)\n\t\tgoto err;\n\n\txge_setup_desc(ring);\n\n\treturn ring;\n\nerr:\n\txge_delete_desc_ring(ndev, ring);\n\n\treturn NULL;\n}\n\nstatic int xge_create_desc_rings(struct net_device *ndev)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\tstruct xge_desc_ring *ring;\n\tint ret;\n\n\t \n\tring = xge_create_desc_ring(ndev);\n\tif (!ring)\n\t\tgoto err;\n\n\tpdata->tx_ring = ring;\n\txge_update_tx_desc_addr(pdata);\n\n\t \n\tring = xge_create_desc_ring(ndev);\n\tif (!ring)\n\t\tgoto err;\n\n\tpdata->rx_ring = ring;\n\txge_update_rx_desc_addr(pdata);\n\n\tret = xge_refill_buffers(ndev, XGENE_ENET_NUM_DESC);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\txge_delete_desc_rings(ndev);\n\n\treturn -ENOMEM;\n}\n\nstatic int xge_open(struct net_device *ndev)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\tint ret;\n\n\tret = xge_create_desc_rings(ndev);\n\tif (ret)\n\t\treturn ret;\n\n\tnapi_enable(&pdata->napi);\n\tret = xge_request_irq(ndev);\n\tif (ret)\n\t\treturn ret;\n\n\txge_intr_enable(pdata);\n\txge_wr_csr(pdata, DMARXCTRL, 1);\n\n\tphy_start(ndev->phydev);\n\txge_mac_enable(pdata);\n\tnetif_start_queue(ndev);\n\n\treturn 0;\n}\n\nstatic int xge_close(struct net_device *ndev)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\n\tnetif_stop_queue(ndev);\n\txge_mac_disable(pdata);\n\tphy_stop(ndev->phydev);\n\n\txge_intr_disable(pdata);\n\txge_free_irq(ndev);\n\tnapi_disable(&pdata->napi);\n\txge_delete_desc_rings(ndev);\n\n\treturn 0;\n}\n\nstatic int xge_napi(struct napi_struct *napi, const int budget)\n{\n\tstruct net_device *ndev = napi->dev;\n\tstruct xge_pdata *pdata;\n\tint processed;\n\n\tpdata = netdev_priv(ndev);\n\n\txge_txc_poll(ndev);\n\tprocessed = xge_rx_poll(ndev, budget);\n\n\tif (processed < budget) {\n\t\tnapi_complete_done(napi, processed);\n\t\txge_intr_enable(pdata);\n\t}\n\n\treturn processed;\n}\n\nstatic int xge_set_mac_addr(struct net_device *ndev, void *addr)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\tint ret;\n\n\tret = eth_mac_addr(ndev, addr);\n\tif (ret)\n\t\treturn ret;\n\n\txge_mac_set_station_addr(pdata);\n\n\treturn 0;\n}\n\nstatic bool is_tx_pending(struct xge_raw_desc *raw_desc)\n{\n\tif (!GET_BITS(E, le64_to_cpu(raw_desc->m0)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void xge_free_pending_skb(struct net_device *ndev)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\tstruct device *dev = &pdata->pdev->dev;\n\tstruct xge_desc_ring *tx_ring;\n\tstruct xge_raw_desc *raw_desc;\n\tdma_addr_t dma_addr;\n\tstruct sk_buff *skb;\n\tvoid *pkt_buf;\n\tint i;\n\n\ttx_ring = pdata->tx_ring;\n\n\tfor (i = 0; i < XGENE_ENET_NUM_DESC; i++) {\n\t\traw_desc = &tx_ring->raw_desc[i];\n\n\t\tif (!is_tx_pending(raw_desc))\n\t\t\tcontinue;\n\n\t\tskb = tx_ring->pkt_info[i].skb;\n\t\tdma_addr = tx_ring->pkt_info[i].dma_addr;\n\t\tpkt_buf = tx_ring->pkt_info[i].pkt_buf;\n\t\tdma_free_coherent(dev, XGENE_ENET_STD_MTU, pkt_buf, dma_addr);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void xge_timeout(struct net_device *ndev, unsigned int txqueue)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\n\trtnl_lock();\n\n\tif (!netif_running(ndev))\n\t\tgoto out;\n\n\tnetif_stop_queue(ndev);\n\txge_intr_disable(pdata);\n\tnapi_disable(&pdata->napi);\n\n\txge_wr_csr(pdata, DMATXCTRL, 0);\n\txge_txc_poll(ndev);\n\txge_free_pending_skb(ndev);\n\txge_wr_csr(pdata, DMATXSTATUS, ~0U);\n\n\txge_setup_desc(pdata->tx_ring);\n\txge_update_tx_desc_addr(pdata);\n\txge_mac_init(pdata);\n\n\tnapi_enable(&pdata->napi);\n\txge_intr_enable(pdata);\n\txge_mac_enable(pdata);\n\tnetif_start_queue(ndev);\n\nout:\n\trtnl_unlock();\n}\n\nstatic void xge_get_stats64(struct net_device *ndev,\n\t\t\t    struct rtnl_link_stats64 *storage)\n{\n\tstruct xge_pdata *pdata = netdev_priv(ndev);\n\tstruct xge_stats *stats = &pdata->stats;\n\n\tstorage->tx_packets += stats->tx_packets;\n\tstorage->tx_bytes += stats->tx_bytes;\n\n\tstorage->rx_packets += stats->rx_packets;\n\tstorage->rx_bytes += stats->rx_bytes;\n\tstorage->rx_errors += stats->rx_errors;\n}\n\nstatic const struct net_device_ops xgene_ndev_ops = {\n\t.ndo_open = xge_open,\n\t.ndo_stop = xge_close,\n\t.ndo_start_xmit = xge_start_xmit,\n\t.ndo_set_mac_address = xge_set_mac_addr,\n\t.ndo_tx_timeout = xge_timeout,\n\t.ndo_get_stats64 = xge_get_stats64,\n};\n\nstatic int xge_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct net_device *ndev;\n\tstruct xge_pdata *pdata;\n\tint ret;\n\n\tndev = alloc_etherdev(sizeof(*pdata));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tpdata = netdev_priv(ndev);\n\n\tpdata->pdev = pdev;\n\tpdata->ndev = ndev;\n\tSET_NETDEV_DEV(ndev, dev);\n\tplatform_set_drvdata(pdev, pdata);\n\tndev->netdev_ops = &xgene_ndev_ops;\n\n\tndev->features |= NETIF_F_GSO |\n\t\t\t  NETIF_F_GRO;\n\n\tret = xge_get_resources(pdata);\n\tif (ret)\n\t\tgoto err;\n\n\tndev->hw_features = ndev->features;\n\txge_set_ethtool_ops(ndev);\n\n\tret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(64));\n\tif (ret) {\n\t\tnetdev_err(ndev, \"No usable DMA configuration\\n\");\n\t\tgoto err;\n\t}\n\n\tret = xge_init_hw(ndev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = xge_mdio_config(ndev);\n\tif (ret)\n\t\tgoto err;\n\n\tnetif_napi_add(ndev, &pdata->napi, xge_napi);\n\n\tret = register_netdev(ndev);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"Failed to register netdev\\n\");\n\t\tgoto err_mdio_remove;\n\t}\n\n\treturn 0;\n\nerr_mdio_remove:\n\txge_mdio_remove(ndev);\nerr:\n\tfree_netdev(ndev);\n\n\treturn ret;\n}\n\nstatic int xge_remove(struct platform_device *pdev)\n{\n\tstruct xge_pdata *pdata;\n\tstruct net_device *ndev;\n\n\tpdata = platform_get_drvdata(pdev);\n\tndev = pdata->ndev;\n\n\trtnl_lock();\n\tif (netif_running(ndev))\n\t\tdev_close(ndev);\n\trtnl_unlock();\n\n\txge_mdio_remove(ndev);\n\tunregister_netdev(ndev);\n\tfree_netdev(ndev);\n\n\treturn 0;\n}\n\nstatic void xge_shutdown(struct platform_device *pdev)\n{\n\tstruct xge_pdata *pdata;\n\n\tpdata = platform_get_drvdata(pdev);\n\tif (!pdata)\n\t\treturn;\n\n\tif (!pdata->ndev)\n\t\treturn;\n\n\txge_remove(pdev);\n}\n\nstatic const struct acpi_device_id xge_acpi_match[] = {\n\t{ \"APMC0D80\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, xge_acpi_match);\n\nstatic struct platform_driver xge_driver = {\n\t.driver = {\n\t\t   .name = \"xgene-enet-v2\",\n\t\t   .acpi_match_table = ACPI_PTR(xge_acpi_match),\n\t},\n\t.probe = xge_probe,\n\t.remove = xge_remove,\n\t.shutdown = xge_shutdown,\n};\nmodule_platform_driver(xge_driver);\n\nMODULE_DESCRIPTION(\"APM X-Gene SoC Ethernet v2 driver\");\nMODULE_AUTHOR(\"Iyappan Subramanian <isubramanian@apm.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}