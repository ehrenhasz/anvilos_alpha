{
  "module_name": "macmace.c",
  "hash_id": "6fe29402ffb596f6574fc9fafe9800b314a765663683b0f2206fdfafd74825ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/apple/macmace.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/crc32.h>\n#include <linux/bitrev.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <asm/io.h>\n#include <asm/macints.h>\n#include <asm/mac_psc.h>\n#include <asm/page.h>\n#include \"mace.h\"\n\nstatic char mac_mace_string[] = \"macmace\";\n\n#define N_TX_BUFF_ORDER\t0\n#define N_TX_RING\t(1 << N_TX_BUFF_ORDER)\n#define N_RX_BUFF_ORDER\t3\n#define N_RX_RING\t(1 << N_RX_BUFF_ORDER)\n\n#define TX_TIMEOUT\tHZ\n\n#define MACE_BUFF_SIZE\t0x800\n\n \n#define BROKEN_ADDRCHG_REV\t0x0941\n\n \n\n#define MACE_BASE\t(void *)(0x50F1C000)\n#define MACE_PROM\t(void *)(0x50F08001)\n\nstruct mace_data {\n\tvolatile struct mace *mace;\n\tunsigned char *tx_ring;\n\tdma_addr_t tx_ring_phys;\n\tunsigned char *rx_ring;\n\tdma_addr_t rx_ring_phys;\n\tint dma_intr;\n\tint rx_slot, rx_tail;\n\tint tx_slot, tx_sloti, tx_count;\n\tint chipid;\n\tstruct device *device;\n};\n\nstruct mace_frame {\n\tu8\trcvcnt;\n\tu8\tpad1;\n\tu8\trcvsts;\n\tu8\tpad2;\n\tu8\trntpc;\n\tu8\tpad3;\n\tu8\trcvcc;\n\tu8\tpad4;\n\tu32\tpad5;\n\tu32\tpad6;\n\tDECLARE_FLEX_ARRAY(u8, data);\n\t \n};\n\n#define PRIV_BYTES\tsizeof(struct mace_data)\n\nstatic int mace_open(struct net_device *dev);\nstatic int mace_close(struct net_device *dev);\nstatic netdev_tx_t mace_xmit_start(struct sk_buff *skb, struct net_device *dev);\nstatic void mace_set_multicast(struct net_device *dev);\nstatic int mace_set_address(struct net_device *dev, void *addr);\nstatic void mace_reset(struct net_device *dev);\nstatic irqreturn_t mace_interrupt(int irq, void *dev_id);\nstatic irqreturn_t mace_dma_intr(int irq, void *dev_id);\nstatic void mace_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic void __mace_set_address(struct net_device *dev, const void *addr);\n\n \n\nstatic void mace_load_rxdma_base(struct net_device *dev, int set)\n{\n\tstruct mace_data *mp = netdev_priv(dev);\n\n\tpsc_write_word(PSC_ENETRD_CMD + set, 0x0100);\n\tpsc_write_long(PSC_ENETRD_ADDR + set, (u32) mp->rx_ring_phys);\n\tpsc_write_long(PSC_ENETRD_LEN + set, N_RX_RING);\n\tpsc_write_word(PSC_ENETRD_CMD + set, 0x9800);\n\tmp->rx_tail = 0;\n}\n\n \n\nstatic void mace_rxdma_reset(struct net_device *dev)\n{\n\tstruct mace_data *mp = netdev_priv(dev);\n\tvolatile struct mace *mace = mp->mace;\n\tu8 maccc = mace->maccc;\n\n\tmace->maccc = maccc & ~ENRCV;\n\n\tpsc_write_word(PSC_ENETRD_CTL, 0x8800);\n\tmace_load_rxdma_base(dev, 0x00);\n\tpsc_write_word(PSC_ENETRD_CTL, 0x0400);\n\n\tpsc_write_word(PSC_ENETRD_CTL, 0x8800);\n\tmace_load_rxdma_base(dev, 0x10);\n\tpsc_write_word(PSC_ENETRD_CTL, 0x0400);\n\n\tmace->maccc = maccc;\n\tmp->rx_slot = 0;\n\n\tpsc_write_word(PSC_ENETRD_CMD + PSC_SET0, 0x9800);\n\tpsc_write_word(PSC_ENETRD_CMD + PSC_SET1, 0x9800);\n}\n\n \n\nstatic void mace_txdma_reset(struct net_device *dev)\n{\n\tstruct mace_data *mp = netdev_priv(dev);\n\tvolatile struct mace *mace = mp->mace;\n\tu8 maccc;\n\n\tpsc_write_word(PSC_ENETWR_CTL, 0x8800);\n\n\tmaccc = mace->maccc;\n\tmace->maccc = maccc & ~ENXMT;\n\n\tmp->tx_slot = mp->tx_sloti = 0;\n\tmp->tx_count = N_TX_RING;\n\n\tpsc_write_word(PSC_ENETWR_CTL, 0x0400);\n\tmace->maccc = maccc;\n}\n\n \n\nstatic void mace_dma_off(struct net_device *dev)\n{\n\tpsc_write_word(PSC_ENETRD_CTL, 0x8800);\n\tpsc_write_word(PSC_ENETRD_CTL, 0x1000);\n\tpsc_write_word(PSC_ENETRD_CMD + PSC_SET0, 0x1100);\n\tpsc_write_word(PSC_ENETRD_CMD + PSC_SET1, 0x1100);\n\n\tpsc_write_word(PSC_ENETWR_CTL, 0x8800);\n\tpsc_write_word(PSC_ENETWR_CTL, 0x1000);\n\tpsc_write_word(PSC_ENETWR_CMD + PSC_SET0, 0x1100);\n\tpsc_write_word(PSC_ENETWR_CMD + PSC_SET1, 0x1100);\n}\n\nstatic const struct net_device_ops mace_netdev_ops = {\n\t.ndo_open\t\t= mace_open,\n\t.ndo_stop\t\t= mace_close,\n\t.ndo_start_xmit\t\t= mace_xmit_start,\n\t.ndo_tx_timeout\t\t= mace_tx_timeout,\n\t.ndo_set_rx_mode\t= mace_set_multicast,\n\t.ndo_set_mac_address\t= mace_set_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n \n\nstatic int mace_probe(struct platform_device *pdev)\n{\n\tint j;\n\tstruct mace_data *mp;\n\tunsigned char *addr;\n\tstruct net_device *dev;\n\tunsigned char checksum = 0;\n\tu8 macaddr[ETH_ALEN];\n\tint err;\n\n\tdev = alloc_etherdev(PRIV_BYTES);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tmp = netdev_priv(dev);\n\n\tmp->device = &pdev->dev;\n\tplatform_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tdev->base_addr = (u32)MACE_BASE;\n\tmp->mace = MACE_BASE;\n\n\tdev->irq = IRQ_MAC_MACE;\n\tmp->dma_intr = IRQ_MAC_MACE_DMA;\n\n\tmp->chipid = mp->mace->chipid_hi << 8 | mp->mace->chipid_lo;\n\n\t \n\n\taddr = MACE_PROM;\n\n\tfor (j = 0; j < 6; ++j) {\n\t\tu8 v = bitrev8(addr[j<<4]);\n\t\tchecksum ^= v;\n\t\tmacaddr[j] = v;\n\t}\n\teth_hw_addr_set(dev, macaddr);\n\tfor (; j < 8; ++j) {\n\t\tchecksum ^= bitrev8(addr[j<<4]);\n\t}\n\n\tif (checksum != 0xFF) {\n\t\tfree_netdev(dev);\n\t\treturn -ENODEV;\n\t}\n\n\tdev->netdev_ops\t\t= &mace_netdev_ops;\n\tdev->watchdog_timeo\t= TX_TIMEOUT;\n\n\tpr_info(\"Onboard MACE, hardware address %pM, chip revision 0x%04X\\n\",\n\t\tdev->dev_addr, mp->chipid);\n\n\terr = register_netdev(dev);\n\tif (!err)\n\t\treturn 0;\n\n\tfree_netdev(dev);\n\treturn err;\n}\n\n \n\nstatic void mace_reset(struct net_device *dev)\n{\n\tstruct mace_data *mp = netdev_priv(dev);\n\tvolatile struct mace *mb = mp->mace;\n\tint i;\n\n\t \n\ti = 200;\n\twhile (--i) {\n\t\tmb->biucc = SWRST;\n\t\tif (mb->biucc & SWRST) {\n\t\t\tudelay(10);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!i) {\n\t\tprintk(KERN_ERR \"macmace: cannot reset chip!\\n\");\n\t\treturn;\n\t}\n\n\tmb->maccc = 0;\t \n\tmb->imr = 0xFF;\t \n\ti = mb->ir;\n\n\tmb->biucc = XMTSP_64;\n\tmb->utr = RTRD;\n\tmb->fifocc = XMTFW_8 | RCVFW_64 | XMTFWU | RCVFWU;\n\n\tmb->xmtfc = AUTO_PAD_XMIT;  \n\tmb->rcvfc = 0;\n\n\t \n\t__mace_set_address(dev, dev->dev_addr);\n\n\t \n\tif (mp->chipid == BROKEN_ADDRCHG_REV)\n\t\tmb->iac = LOGADDR;\n\telse {\n\t\tmb->iac = ADDRCHG | LOGADDR;\n\t\twhile ((mb->iac & ADDRCHG) != 0)\n\t\t\t;\n\t}\n\tfor (i = 0; i < 8; ++i)\n\t\tmb->ladrf = 0;\n\n\t \n\tif (mp->chipid != BROKEN_ADDRCHG_REV)\n\t\tmb->iac = 0;\n\n\tmb->plscc = PORTSEL_AUI;\n}\n\n \n\nstatic void __mace_set_address(struct net_device *dev, const void *addr)\n{\n\tstruct mace_data *mp = netdev_priv(dev);\n\tvolatile struct mace *mb = mp->mace;\n\tconst unsigned char *p = addr;\n\tu8 macaddr[ETH_ALEN];\n\tint i;\n\n\t \n\tif (mp->chipid == BROKEN_ADDRCHG_REV)\n\t\tmb->iac = PHYADDR;\n\telse {\n\t\tmb->iac = ADDRCHG | PHYADDR;\n\t\twhile ((mb->iac & ADDRCHG) != 0)\n\t\t\t;\n\t}\n\tfor (i = 0; i < 6; ++i)\n\t\tmb->padr = macaddr[i] = p[i];\n\teth_hw_addr_set(dev, macaddr);\n\tif (mp->chipid != BROKEN_ADDRCHG_REV)\n\t\tmb->iac = 0;\n}\n\nstatic int mace_set_address(struct net_device *dev, void *addr)\n{\n\tstruct mace_data *mp = netdev_priv(dev);\n\tvolatile struct mace *mb = mp->mace;\n\tunsigned long flags;\n\tu8 maccc;\n\n\tlocal_irq_save(flags);\n\n\tmaccc = mb->maccc;\n\n\t__mace_set_address(dev, addr);\n\n\tmb->maccc = maccc;\n\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\n \n\nstatic int mace_open(struct net_device *dev)\n{\n\tstruct mace_data *mp = netdev_priv(dev);\n\tvolatile struct mace *mb = mp->mace;\n\n\t \n\tmace_reset(dev);\n\n\tif (request_irq(dev->irq, mace_interrupt, 0, dev->name, dev)) {\n\t\tprintk(KERN_ERR \"%s: can't get irq %d\\n\", dev->name, dev->irq);\n\t\treturn -EAGAIN;\n\t}\n\tif (request_irq(mp->dma_intr, mace_dma_intr, 0, dev->name, dev)) {\n\t\tprintk(KERN_ERR \"%s: can't get irq %d\\n\", dev->name, mp->dma_intr);\n\t\tfree_irq(dev->irq, dev);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\n\tmp->tx_ring = dma_alloc_coherent(mp->device,\n\t\t\t\t\t N_TX_RING * MACE_BUFF_SIZE,\n\t\t\t\t\t &mp->tx_ring_phys, GFP_KERNEL);\n\tif (mp->tx_ring == NULL)\n\t\tgoto out1;\n\n\tmp->rx_ring = dma_alloc_coherent(mp->device,\n\t\t\t\t\t N_RX_RING * MACE_BUFF_SIZE,\n\t\t\t\t\t &mp->rx_ring_phys, GFP_KERNEL);\n\tif (mp->rx_ring == NULL)\n\t\tgoto out2;\n\n\tmace_dma_off(dev);\n\n\t \n\n\tpsc_write_word(PSC_ENETWR_CTL, 0x9000);\n\tpsc_write_word(PSC_ENETRD_CTL, 0x9000);\n\tpsc_write_word(PSC_ENETWR_CTL, 0x0400);\n\tpsc_write_word(PSC_ENETRD_CTL, 0x0400);\n\n\tmace_rxdma_reset(dev);\n\tmace_txdma_reset(dev);\n\n\t \n\tmb->maccc = ENXMT | ENRCV;\n\t \n\tmb->imr = RCVINT;\n\treturn 0;\n\nout2:\n\tdma_free_coherent(mp->device, N_TX_RING * MACE_BUFF_SIZE,\n\t                  mp->tx_ring, mp->tx_ring_phys);\nout1:\n\tfree_irq(dev->irq, dev);\n\tfree_irq(mp->dma_intr, dev);\n\treturn -ENOMEM;\n}\n\n \n\nstatic int mace_close(struct net_device *dev)\n{\n\tstruct mace_data *mp = netdev_priv(dev);\n\tvolatile struct mace *mb = mp->mace;\n\n\tmb->maccc = 0;\t\t \n\tmb->imr = 0xFF;\t\t \n\tmace_dma_off(dev);\t \n\n\treturn 0;\n}\n\n \n\nstatic netdev_tx_t mace_xmit_start(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct mace_data *mp = netdev_priv(dev);\n\tunsigned long flags;\n\n\t \n\n\tlocal_irq_save(flags);\n\tnetif_stop_queue(dev);\n\tif (!mp->tx_count) {\n\t\tprintk(KERN_ERR \"macmace: tx queue running but no free buffers.\\n\");\n\t\tlocal_irq_restore(flags);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\tmp->tx_count--;\n\tlocal_irq_restore(flags);\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\t \n\tskb_copy_from_linear_data(skb, mp->tx_ring, skb->len);\n\n\t \n\n\tpsc_write_long(PSC_ENETWR_ADDR + mp->tx_slot, (u32)  mp->tx_ring_phys);\n\tpsc_write_long(PSC_ENETWR_LEN + mp->tx_slot, skb->len);\n\tpsc_write_word(PSC_ENETWR_CMD + mp->tx_slot, 0x9800);\n\n\tmp->tx_slot ^= 0x10;\n\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void mace_set_multicast(struct net_device *dev)\n{\n\tstruct mace_data *mp = netdev_priv(dev);\n\tvolatile struct mace *mb = mp->mace;\n\tint i;\n\tu32 crc;\n\tu8 maccc;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tmaccc = mb->maccc;\n\tmb->maccc &= ~PROM;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tmb->maccc |= PROM;\n\t} else {\n\t\tunsigned char multicast_filter[8];\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tif (dev->flags & IFF_ALLMULTI) {\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tmulticast_filter[i] = 0xFF;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\tmulticast_filter[i] = 0;\n\t\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t\tcrc = ether_crc_le(6, ha->addr);\n\t\t\t\t \n\t\t\t\ti = crc >> 26;\n\t\t\t\tmulticast_filter[i >> 3] |= 1 << (i & 7);\n\t\t\t}\n\t\t}\n\n\t\tif (mp->chipid == BROKEN_ADDRCHG_REV)\n\t\t\tmb->iac = LOGADDR;\n\t\telse {\n\t\t\tmb->iac = ADDRCHG | LOGADDR;\n\t\t\twhile ((mb->iac & ADDRCHG) != 0)\n\t\t\t\t;\n\t\t}\n\t\tfor (i = 0; i < 8; ++i)\n\t\t\tmb->ladrf = multicast_filter[i];\n\t\tif (mp->chipid != BROKEN_ADDRCHG_REV)\n\t\t\tmb->iac = 0;\n\t}\n\n\tmb->maccc = maccc;\n\tlocal_irq_restore(flags);\n}\n\nstatic void mace_handle_misc_intrs(struct net_device *dev, int intr)\n{\n\tstruct mace_data *mp = netdev_priv(dev);\n\tvolatile struct mace *mb = mp->mace;\n\tstatic int mace_babbles, mace_jabbers;\n\n\tif (intr & MPCO)\n\t\tdev->stats.rx_missed_errors += 256;\n\tdev->stats.rx_missed_errors += mb->mpc;    \n\tif (intr & RNTPCO)\n\t\tdev->stats.rx_length_errors += 256;\n\tdev->stats.rx_length_errors += mb->rntpc;  \n\tif (intr & CERR)\n\t\t++dev->stats.tx_heartbeat_errors;\n\tif (intr & BABBLE)\n\t\tif (mace_babbles++ < 4)\n\t\t\tprintk(KERN_DEBUG \"macmace: babbling transmitter\\n\");\n\tif (intr & JABBER)\n\t\tif (mace_jabbers++ < 4)\n\t\t\tprintk(KERN_DEBUG \"macmace: jabbering transceiver\\n\");\n}\n\nstatic irqreturn_t mace_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *) dev_id;\n\tstruct mace_data *mp = netdev_priv(dev);\n\tvolatile struct mace *mb = mp->mace;\n\tint intr, fs;\n\tunsigned long flags;\n\n\t \n\tlocal_irq_save(flags);\n\n\tintr = mb->ir;  \n\tmace_handle_misc_intrs(dev, intr);\n\n\tif (intr & XMTINT) {\n\t\tfs = mb->xmtfs;\n\t\tif ((fs & XMTSV) == 0) {\n\t\t\tprintk(KERN_ERR \"macmace: xmtfs not valid! (fs=%x)\\n\", fs);\n\t\t\tmace_reset(dev);\n\t\t\t \n\t\t}\n\t\t \n\t\tif (!mp->tx_count) {\n\t\t\tprintk(KERN_DEBUG \"macmace: tx ring ran out? (fs=%x)\\n\", fs);\n\t\t}\n\t\t \n\t\tif (fs & (UFLO|LCOL|LCAR|RTRY)) {\n\t\t\t++dev->stats.tx_errors;\n\t\t\tif (fs & LCAR)\n\t\t\t\t++dev->stats.tx_carrier_errors;\n\t\t\telse if (fs & (UFLO|LCOL|RTRY)) {\n\t\t\t\t++dev->stats.tx_aborted_errors;\n\t\t\t\tif (mb->xmtfs & UFLO) {\n\t\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\t\t\tmace_txdma_reset(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (mp->tx_count)\n\t\tnetif_wake_queue(dev);\n\n\tlocal_irq_restore(flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mace_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct mace_data *mp = netdev_priv(dev);\n\tvolatile struct mace *mb = mp->mace;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\t \n\tmb->maccc = 0;\n\tprintk(KERN_ERR \"macmace: transmit timeout - resetting\\n\");\n\tmace_txdma_reset(dev);\n\tmace_reset(dev);\n\n\t \n\tmace_rxdma_reset(dev);\n\n\tmp->tx_count = N_TX_RING;\n\tnetif_wake_queue(dev);\n\n\t \n\tmb->maccc = ENXMT | ENRCV;\n\t \n\tmb->imr = RCVINT;\n\n\tlocal_irq_restore(flags);\n}\n\n \n\nstatic void mace_dma_rx_frame(struct net_device *dev, struct mace_frame *mf)\n{\n\tstruct sk_buff *skb;\n\tunsigned int frame_status = mf->rcvsts;\n\n\tif (frame_status & (RS_OFLO | RS_CLSN | RS_FRAMERR | RS_FCSERR)) {\n\t\tdev->stats.rx_errors++;\n\t\tif (frame_status & RS_OFLO)\n\t\t\tdev->stats.rx_fifo_errors++;\n\t\tif (frame_status & RS_CLSN)\n\t\t\tdev->stats.collisions++;\n\t\tif (frame_status & RS_FRAMERR)\n\t\t\tdev->stats.rx_frame_errors++;\n\t\tif (frame_status & RS_FCSERR)\n\t\t\tdev->stats.rx_crc_errors++;\n\t} else {\n\t\tunsigned int frame_length = mf->rcvcnt + ((frame_status & 0x0F) << 8 );\n\n\t\tskb = netdev_alloc_skb(dev, frame_length + 2);\n\t\tif (!skb) {\n\t\t\tdev->stats.rx_dropped++;\n\t\t\treturn;\n\t\t}\n\t\tskb_reserve(skb, 2);\n\t\tskb_put_data(skb, mf->data, frame_length);\n\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tnetif_rx(skb);\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += frame_length;\n\t}\n}\n\n \n\nstatic irqreturn_t mace_dma_intr(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *) dev_id;\n\tstruct mace_data *mp = netdev_priv(dev);\n\tint left, head;\n\tu16 status;\n\tu32 baka;\n\n\t \n\n\twhile ((baka = psc_read_long(PSC_MYSTERY)) != psc_read_long(PSC_MYSTERY));\n\tif (!(baka & 0x60000000)) return IRQ_NONE;\n\n\t \n\n\tstatus = psc_read_word(PSC_ENETRD_CTL);\n\n\tif (status & 0x2000) {\n\t\tmace_rxdma_reset(dev);\n\t} else if (status & 0x0100) {\n\t\tpsc_write_word(PSC_ENETRD_CMD + mp->rx_slot, 0x1100);\n\n\t\tleft = psc_read_long(PSC_ENETRD_LEN + mp->rx_slot);\n\t\thead = N_RX_RING - left;\n\n\t\t \n\n\t\twhile (mp->rx_tail < head) {\n\t\t\tmace_dma_rx_frame(dev, (struct mace_frame*) (mp->rx_ring\n\t\t\t\t+ (mp->rx_tail * MACE_BUFF_SIZE)));\n\t\t\tmp->rx_tail++;\n\t\t}\n\n\t\t \n\t\t \n\n\t\tif (!left) {\n\t\t\tmace_load_rxdma_base(dev, mp->rx_slot);\n\t\t\tmp->rx_slot ^= 0x10;\n\t\t} else {\n\t\t\tpsc_write_word(PSC_ENETRD_CMD + mp->rx_slot, 0x9800);\n\t\t}\n\t}\n\n\t \n\n\tstatus = psc_read_word(PSC_ENETWR_CTL);\n\n\tif (status & 0x2000) {\n\t\tmace_txdma_reset(dev);\n\t} else if (status & 0x0100) {\n\t\tpsc_write_word(PSC_ENETWR_CMD + mp->tx_sloti, 0x0100);\n\t\tmp->tx_sloti ^= 0x10;\n\t\tmp->tx_count++;\n\t}\n\treturn IRQ_HANDLED;\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Macintosh MACE ethernet driver\");\nMODULE_ALIAS(\"platform:macmace\");\n\nstatic int mac_mace_device_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct mace_data *mp = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\n\tfree_irq(dev->irq, dev);\n\tfree_irq(IRQ_MAC_MACE_DMA, dev);\n\n\tdma_free_coherent(mp->device, N_RX_RING * MACE_BUFF_SIZE,\n\t                  mp->rx_ring, mp->rx_ring_phys);\n\tdma_free_coherent(mp->device, N_TX_RING * MACE_BUFF_SIZE,\n\t                  mp->tx_ring, mp->tx_ring_phys);\n\n\tfree_netdev(dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mac_mace_driver = {\n\t.probe  = mace_probe,\n\t.remove = mac_mace_device_remove,\n\t.driver\t= {\n\t\t.name\t= mac_mace_string,\n\t},\n};\n\nmodule_platform_driver(mac_mace_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}