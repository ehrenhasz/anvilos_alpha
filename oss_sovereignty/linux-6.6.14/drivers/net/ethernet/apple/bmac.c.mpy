{
  "module_name": "bmac.c",
  "hash_id": "609014ae62cb8fd847cce6e0c7f4bfd618a37aba0517f4c5b9b81ee2179df3b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/apple/bmac.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/crc32.h>\n#include <linux/crc32poly.h>\n#include <linux/bitrev.h>\n#include <linux/ethtool.h>\n#include <linux/slab.h>\n#include <linux/pgtable.h>\n#include <asm/dbdma.h>\n#include <asm/io.h>\n#include <asm/page.h>\n#include <asm/machdep.h>\n#include <asm/pmac_feature.h>\n#include <asm/macio.h>\n#include <asm/irq.h>\n\n#include \"bmac.h\"\n\n#define trunc_page(x)\t((void *)(((unsigned long)(x)) & ~((unsigned long)(PAGE_SIZE - 1))))\n#define round_page(x)\ttrunc_page(((unsigned long)(x)) + ((unsigned long)(PAGE_SIZE - 1)))\n\n \n#define SUNHME_MULTICAST\n\n#define N_RX_RING\t64\n#define N_TX_RING\t32\n#define MAX_TX_ACTIVE\t1\n#define ETHERCRC\t4\n#define ETHERMINPACKET\t64\n#define ETHERMTU\t1500\n#define RX_BUFLEN\t(ETHERMTU + 14 + ETHERCRC + 2)\n#define TX_TIMEOUT\tHZ\t \n\n \n#define TX_DMA_ERR\t0x80\n\n#define XXDEBUG(args)\n\nstruct bmac_data {\n\t \n\tstruct sk_buff_head *queue;\n\tvolatile struct dbdma_regs __iomem *tx_dma;\n\tint tx_dma_intr;\n\tvolatile struct dbdma_regs __iomem *rx_dma;\n\tint rx_dma_intr;\n\tvolatile struct dbdma_cmd *tx_cmds;\t \n\tvolatile struct dbdma_cmd *rx_cmds;\t \n\tstruct macio_dev *mdev;\n\tint is_bmac_plus;\n\tstruct sk_buff *rx_bufs[N_RX_RING];\n\tint rx_fill;\n\tint rx_empty;\n\tstruct sk_buff *tx_bufs[N_TX_RING];\n\tint tx_fill;\n\tint tx_empty;\n\tunsigned char tx_fullup;\n\tstruct timer_list tx_timeout;\n\tint timeout_active;\n\tint sleeping;\n\tint opened;\n\tunsigned short hash_use_count[64];\n\tunsigned short hash_table_mask[4];\n\tspinlock_t lock;\n};\n\n#if 0  \n\ntypedef struct bmac_reg_entry {\n\tchar *name;\n\tunsigned short reg_offset;\n} bmac_reg_entry_t;\n\n#define N_REG_ENTRIES 31\n\nstatic bmac_reg_entry_t reg_entries[N_REG_ENTRIES] = {\n\t{\"MEMADD\", MEMADD},\n\t{\"MEMDATAHI\", MEMDATAHI},\n\t{\"MEMDATALO\", MEMDATALO},\n\t{\"TXPNTR\", TXPNTR},\n\t{\"RXPNTR\", RXPNTR},\n\t{\"IPG1\", IPG1},\n\t{\"IPG2\", IPG2},\n\t{\"ALIMIT\", ALIMIT},\n\t{\"SLOT\", SLOT},\n\t{\"PALEN\", PALEN},\n\t{\"PAPAT\", PAPAT},\n\t{\"TXSFD\", TXSFD},\n\t{\"JAM\", JAM},\n\t{\"TXCFG\", TXCFG},\n\t{\"TXMAX\", TXMAX},\n\t{\"TXMIN\", TXMIN},\n\t{\"PAREG\", PAREG},\n\t{\"DCNT\", DCNT},\n\t{\"NCCNT\", NCCNT},\n\t{\"NTCNT\", NTCNT},\n\t{\"EXCNT\", EXCNT},\n\t{\"LTCNT\", LTCNT},\n\t{\"TXSM\", TXSM},\n\t{\"RXCFG\", RXCFG},\n\t{\"RXMAX\", RXMAX},\n\t{\"RXMIN\", RXMIN},\n\t{\"FRCNT\", FRCNT},\n\t{\"AECNT\", AECNT},\n\t{\"FECNT\", FECNT},\n\t{\"RXSM\", RXSM},\n\t{\"RXCV\", RXCV}\n};\n\n#endif\n\nstatic unsigned char *bmac_emergency_rxbuf;\n\n \n#define PRIV_BYTES\t(sizeof(struct bmac_data) \\\n\t+ (N_RX_RING + N_TX_RING + 4) * sizeof(struct dbdma_cmd) \\\n\t+ sizeof(struct sk_buff_head))\n\nstatic int bmac_open(struct net_device *dev);\nstatic int bmac_close(struct net_device *dev);\nstatic int bmac_transmit_packet(struct sk_buff *skb, struct net_device *dev);\nstatic void bmac_set_multicast(struct net_device *dev);\nstatic void bmac_reset_and_enable(struct net_device *dev);\nstatic void bmac_start_chip(struct net_device *dev);\nstatic void bmac_init_chip(struct net_device *dev);\nstatic void bmac_init_registers(struct net_device *dev);\nstatic void bmac_enable_and_reset_chip(struct net_device *dev);\nstatic int bmac_set_address(struct net_device *dev, void *addr);\nstatic irqreturn_t bmac_misc_intr(int irq, void *dev_id);\nstatic irqreturn_t bmac_txdma_intr(int irq, void *dev_id);\nstatic irqreturn_t bmac_rxdma_intr(int irq, void *dev_id);\nstatic void bmac_set_timeout(struct net_device *dev);\nstatic void bmac_tx_timeout(struct timer_list *t);\nstatic netdev_tx_t bmac_output(struct sk_buff *skb, struct net_device *dev);\nstatic void bmac_start(struct net_device *dev);\n\n#define\tDBDMA_SET(x)\t( ((x) | (x) << 16) )\n#define\tDBDMA_CLEAR(x)\t( (x) << 16)\n\nstatic inline void\ndbdma_st32(volatile __u32 __iomem *a, unsigned long x)\n{\n\t__asm__ volatile( \"stwbrx %0,0,%1\" : : \"r\" (x), \"r\" (a) : \"memory\");\n}\n\nstatic inline unsigned long\ndbdma_ld32(volatile __u32 __iomem *a)\n{\n\t__u32 swap;\n\t__asm__ volatile (\"lwbrx %0,0,%1\" :  \"=r\" (swap) : \"r\" (a));\n\treturn swap;\n}\n\nstatic void\ndbdma_continue(volatile struct dbdma_regs __iomem *dmap)\n{\n\tdbdma_st32(&dmap->control,\n\t\t   DBDMA_SET(RUN|WAKE) | DBDMA_CLEAR(PAUSE|DEAD));\n\teieio();\n}\n\nstatic void\ndbdma_reset(volatile struct dbdma_regs __iomem *dmap)\n{\n\tdbdma_st32(&dmap->control,\n\t\t   DBDMA_CLEAR(ACTIVE|DEAD|WAKE|FLUSH|PAUSE|RUN));\n\teieio();\n\twhile (dbdma_ld32(&dmap->status) & RUN)\n\t\teieio();\n}\n\nstatic void\ndbdma_setcmd(volatile struct dbdma_cmd *cp,\n\t     unsigned short cmd, unsigned count, unsigned long addr,\n\t     unsigned long cmd_dep)\n{\n\tout_le16(&cp->command, cmd);\n\tout_le16(&cp->req_count, count);\n\tout_le32(&cp->phy_addr, addr);\n\tout_le32(&cp->cmd_dep, cmd_dep);\n\tout_le16(&cp->xfer_status, 0);\n\tout_le16(&cp->res_count, 0);\n}\n\nstatic inline\nvoid bmwrite(struct net_device *dev, unsigned long reg_offset, unsigned data )\n{\n\tout_le16((void __iomem *)dev->base_addr + reg_offset, data);\n}\n\n\nstatic inline\nunsigned short bmread(struct net_device *dev, unsigned long reg_offset )\n{\n\treturn in_le16((void __iomem *)dev->base_addr + reg_offset);\n}\n\nstatic void\nbmac_enable_and_reset_chip(struct net_device *dev)\n{\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tvolatile struct dbdma_regs __iomem *rd = bp->rx_dma;\n\tvolatile struct dbdma_regs __iomem *td = bp->tx_dma;\n\n\tif (rd)\n\t\tdbdma_reset(rd);\n\tif (td)\n\t\tdbdma_reset(td);\n\n\tpmac_call_feature(PMAC_FTR_BMAC_ENABLE, macio_get_of_node(bp->mdev), 0, 1);\n}\n\n#define MIFDELAY\tudelay(10)\n\nstatic unsigned int\nbmac_mif_readbits(struct net_device *dev, int nb)\n{\n\tunsigned int val = 0;\n\n\twhile (--nb >= 0) {\n\t\tbmwrite(dev, MIFCSR, 0);\n\t\tMIFDELAY;\n\t\tif (bmread(dev, MIFCSR) & 8)\n\t\t\tval |= 1 << nb;\n\t\tbmwrite(dev, MIFCSR, 1);\n\t\tMIFDELAY;\n\t}\n\tbmwrite(dev, MIFCSR, 0);\n\tMIFDELAY;\n\tbmwrite(dev, MIFCSR, 1);\n\tMIFDELAY;\n\treturn val;\n}\n\nstatic void\nbmac_mif_writebits(struct net_device *dev, unsigned int val, int nb)\n{\n\tint b;\n\n\twhile (--nb >= 0) {\n\t\tb = (val & (1 << nb))? 6: 4;\n\t\tbmwrite(dev, MIFCSR, b);\n\t\tMIFDELAY;\n\t\tbmwrite(dev, MIFCSR, b|1);\n\t\tMIFDELAY;\n\t}\n}\n\nstatic unsigned int\nbmac_mif_read(struct net_device *dev, unsigned int addr)\n{\n\tunsigned int val;\n\n\tbmwrite(dev, MIFCSR, 4);\n\tMIFDELAY;\n\tbmac_mif_writebits(dev, ~0U, 32);\n\tbmac_mif_writebits(dev, 6, 4);\n\tbmac_mif_writebits(dev, addr, 10);\n\tbmwrite(dev, MIFCSR, 2);\n\tMIFDELAY;\n\tbmwrite(dev, MIFCSR, 1);\n\tMIFDELAY;\n\tval = bmac_mif_readbits(dev, 17);\n\tbmwrite(dev, MIFCSR, 4);\n\tMIFDELAY;\n\treturn val;\n}\n\nstatic void\nbmac_mif_write(struct net_device *dev, unsigned int addr, unsigned int val)\n{\n\tbmwrite(dev, MIFCSR, 4);\n\tMIFDELAY;\n\tbmac_mif_writebits(dev, ~0U, 32);\n\tbmac_mif_writebits(dev, 5, 4);\n\tbmac_mif_writebits(dev, addr, 10);\n\tbmac_mif_writebits(dev, 2, 2);\n\tbmac_mif_writebits(dev, val, 16);\n\tbmac_mif_writebits(dev, 3, 2);\n}\n\nstatic void\nbmac_init_registers(struct net_device *dev)\n{\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tvolatile unsigned short regValue;\n\tconst unsigned short *pWord16;\n\tint i;\n\n\t \n\n\tbmwrite(dev, RXRST, RxResetValue);\n\tbmwrite(dev, TXRST, TxResetBit);\n\n\ti = 100;\n\tdo {\n\t\t--i;\n\t\tudelay(10000);\n\t\tregValue = bmread(dev, TXRST);  \n\t} while ((regValue & TxResetBit) && i > 0);\n\n\tif (!bp->is_bmac_plus) {\n\t\tregValue = bmread(dev, XCVRIF);\n\t\tregValue |= ClkBit | SerialMode | COLActiveLow;\n\t\tbmwrite(dev, XCVRIF, regValue);\n\t\tudelay(10000);\n\t}\n\n\tbmwrite(dev, RSEED, (unsigned short)0x1968);\n\n\tregValue = bmread(dev, XIFC);\n\tregValue |= TxOutputEnable;\n\tbmwrite(dev, XIFC, regValue);\n\n\tbmread(dev, PAREG);\n\n\t \n\tbmwrite(dev, NCCNT, 0);\n\tbmwrite(dev, NTCNT, 0);\n\tbmwrite(dev, EXCNT, 0);\n\tbmwrite(dev, LTCNT, 0);\n\n\t \n\tbmwrite(dev, FRCNT, 0);\n\tbmwrite(dev, LECNT, 0);\n\tbmwrite(dev, AECNT, 0);\n\tbmwrite(dev, FECNT, 0);\n\tbmwrite(dev, RXCV, 0);\n\n\t \n\tbmwrite(dev, TXTH, 4);\t \n\n\tbmwrite(dev, TXFIFOCSR, 0);\t \n\tbmwrite(dev, TXFIFOCSR, TxFIFOEnable );\n\n\t \n\tbmwrite(dev, RXFIFOCSR, 0);\t \n\tbmwrite(dev, RXFIFOCSR, RxFIFOEnable );\n\n\t\n\tbmread(dev, STATUS);\t\t \n\n\t \n\tfor (i=0; i<4; i++) bp->hash_table_mask[i] = 0;\n\tbmwrite(dev, BHASH3, bp->hash_table_mask[0]); \t \n\tbmwrite(dev, BHASH2, bp->hash_table_mask[1]); \t \n\tbmwrite(dev, BHASH1, bp->hash_table_mask[2]); \t \n\tbmwrite(dev, BHASH0, bp->hash_table_mask[3]); \t \n\n\tpWord16 = (const unsigned short *)dev->dev_addr;\n\tbmwrite(dev, MADD0, *pWord16++);\n\tbmwrite(dev, MADD1, *pWord16++);\n\tbmwrite(dev, MADD2, *pWord16);\n\n\tbmwrite(dev, RXCFG, RxCRCNoStrip | RxHashFilterEnable | RxRejectOwnPackets);\n\n\tbmwrite(dev, INTDISABLE, EnableNormal);\n}\n\n#if 0\nstatic void\nbmac_disable_interrupts(struct net_device *dev)\n{\n\tbmwrite(dev, INTDISABLE, DisableAll);\n}\n\nstatic void\nbmac_enable_interrupts(struct net_device *dev)\n{\n\tbmwrite(dev, INTDISABLE, EnableNormal);\n}\n#endif\n\n\nstatic void\nbmac_start_chip(struct net_device *dev)\n{\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tvolatile struct dbdma_regs __iomem *rd = bp->rx_dma;\n\tunsigned short\toldConfig;\n\n\t \n\tdbdma_continue(rd);\n\n\toldConfig = bmread(dev, TXCFG);\n\tbmwrite(dev, TXCFG, oldConfig | TxMACEnable );\n\n\t \n\toldConfig = bmread(dev, RXCFG);\n\tbmwrite(dev, RXCFG, oldConfig | RxMACEnable );\n\tudelay(20000);\n}\n\nstatic void\nbmac_init_phy(struct net_device *dev)\n{\n\tunsigned int addr;\n\tstruct bmac_data *bp = netdev_priv(dev);\n\n\tprintk(KERN_DEBUG \"phy registers:\");\n\tfor (addr = 0; addr < 32; ++addr) {\n\t\tif ((addr & 7) == 0)\n\t\t\tprintk(KERN_DEBUG);\n\t\tprintk(KERN_CONT \" %.4x\", bmac_mif_read(dev, addr));\n\t}\n\tprintk(KERN_CONT \"\\n\");\n\n\tif (bp->is_bmac_plus) {\n\t\tunsigned int capable, ctrl;\n\n\t\tctrl = bmac_mif_read(dev, 0);\n\t\tcapable = ((bmac_mif_read(dev, 1) & 0xf800) >> 6) | 1;\n\t\tif (bmac_mif_read(dev, 4) != capable ||\n\t\t    (ctrl & 0x1000) == 0) {\n\t\t\tbmac_mif_write(dev, 4, capable);\n\t\t\tbmac_mif_write(dev, 0, 0x1200);\n\t\t} else\n\t\t\tbmac_mif_write(dev, 0, 0x1000);\n\t}\n}\n\nstatic void bmac_init_chip(struct net_device *dev)\n{\n\tbmac_init_phy(dev);\n\tbmac_init_registers(dev);\n}\n\n#ifdef CONFIG_PM\nstatic int bmac_suspend(struct macio_dev *mdev, pm_message_t state)\n{\n\tstruct net_device* dev = macio_get_drvdata(mdev);\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tunsigned long flags;\n\tunsigned short config;\n\tint i;\n\n\tnetif_device_detach(dev);\n\t \n\tspin_lock_irqsave(&bp->lock, flags);\n\tif (bp->timeout_active) {\n\t\tdel_timer(&bp->tx_timeout);\n\t\tbp->timeout_active = 0;\n\t}\n\tdisable_irq(dev->irq);\n\tdisable_irq(bp->tx_dma_intr);\n\tdisable_irq(bp->rx_dma_intr);\n\tbp->sleeping = 1;\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\tif (bp->opened) {\n\t\tvolatile struct dbdma_regs __iomem *rd = bp->rx_dma;\n\t\tvolatile struct dbdma_regs __iomem *td = bp->tx_dma;\n\n\t\tconfig = bmread(dev, RXCFG);\n\t\tbmwrite(dev, RXCFG, (config & ~RxMACEnable));\n\t\tconfig = bmread(dev, TXCFG);\n\t\tbmwrite(dev, TXCFG, (config & ~TxMACEnable));\n\t\tbmwrite(dev, INTDISABLE, DisableAll);  \n\t\t \n\t\trd->control = cpu_to_le32(DBDMA_CLEAR(RUN|PAUSE|FLUSH|WAKE));\t \n\t\ttd->control = cpu_to_le32(DBDMA_CLEAR(RUN|PAUSE|FLUSH|WAKE));\t \n\t\t \n\t\tfor (i=0; i<N_RX_RING; i++) {\n\t\t\tif (bp->rx_bufs[i] != NULL) {\n\t\t\t\tdev_kfree_skb(bp->rx_bufs[i]);\n\t\t\t\tbp->rx_bufs[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i<N_TX_RING; i++) {\n\t\t\tif (bp->tx_bufs[i] != NULL) {\n\t\t       \t\tdev_kfree_skb(bp->tx_bufs[i]);\n\t       \t\t\tbp->tx_bufs[i] = NULL;\n\t\t       \t}\n\t\t}\n\t}\n\tpmac_call_feature(PMAC_FTR_BMAC_ENABLE, macio_get_of_node(bp->mdev), 0, 0);\n\treturn 0;\n}\n\nstatic int bmac_resume(struct macio_dev *mdev)\n{\n\tstruct net_device* dev = macio_get_drvdata(mdev);\n\tstruct bmac_data *bp = netdev_priv(dev);\n\n\t \n\tif (bp->opened)\n\t\tbmac_reset_and_enable(dev);\n\n\tenable_irq(dev->irq);\n\tenable_irq(bp->tx_dma_intr);\n\tenable_irq(bp->rx_dma_intr);\n\tnetif_device_attach(dev);\n\n\treturn 0;\n}\n#endif  \n\nstatic int bmac_set_address(struct net_device *dev, void *addr)\n{\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tconst unsigned short *pWord16;\n\tunsigned long flags;\n\n\tXXDEBUG((\"bmac: enter set_address\\n\"));\n\tspin_lock_irqsave(&bp->lock, flags);\n\n\teth_hw_addr_set(dev, addr);\n\n\t \n\tpWord16  = (const unsigned short *)dev->dev_addr;\n\tbmwrite(dev, MADD0, *pWord16++);\n\tbmwrite(dev, MADD1, *pWord16++);\n\tbmwrite(dev, MADD2, *pWord16);\n\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\tXXDEBUG((\"bmac: exit set_address\\n\"));\n\treturn 0;\n}\n\nstatic inline void bmac_set_timeout(struct net_device *dev)\n{\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\tif (bp->timeout_active)\n\t\tdel_timer(&bp->tx_timeout);\n\tbp->tx_timeout.expires = jiffies + TX_TIMEOUT;\n\tadd_timer(&bp->tx_timeout);\n\tbp->timeout_active = 1;\n\tspin_unlock_irqrestore(&bp->lock, flags);\n}\n\nstatic void\nbmac_construct_xmt(struct sk_buff *skb, volatile struct dbdma_cmd *cp)\n{\n\tvoid *vaddr;\n\tunsigned long baddr;\n\tunsigned long len;\n\n\tlen = skb->len;\n\tvaddr = skb->data;\n\tbaddr = virt_to_bus(vaddr);\n\n\tdbdma_setcmd(cp, (OUTPUT_LAST | INTR_ALWAYS | WAIT_IFCLR), len, baddr, 0);\n}\n\nstatic void\nbmac_construct_rxbuff(struct sk_buff *skb, volatile struct dbdma_cmd *cp)\n{\n\tunsigned char *addr = skb? skb->data: bmac_emergency_rxbuf;\n\n\tdbdma_setcmd(cp, (INPUT_LAST | INTR_ALWAYS), RX_BUFLEN,\n\t\t     virt_to_bus(addr), 0);\n}\n\nstatic void\nbmac_init_tx_ring(struct bmac_data *bp)\n{\n\tvolatile struct dbdma_regs __iomem *td = bp->tx_dma;\n\n\tmemset((char *)bp->tx_cmds, 0, (N_TX_RING+1) * sizeof(struct dbdma_cmd));\n\n\tbp->tx_empty = 0;\n\tbp->tx_fill = 0;\n\tbp->tx_fullup = 0;\n\n\t \n\tdbdma_setcmd(&bp->tx_cmds[N_TX_RING],\n\t\t     (DBDMA_NOP | BR_ALWAYS), 0, 0, virt_to_bus(bp->tx_cmds));\n\n\t \n\tdbdma_reset(td);\n\tout_le32(&td->wait_sel, 0x00200020);\n\tout_le32(&td->cmdptr, virt_to_bus(bp->tx_cmds));\n}\n\nstatic int\nbmac_init_rx_ring(struct net_device *dev)\n{\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tvolatile struct dbdma_regs __iomem *rd = bp->rx_dma;\n\tint i;\n\tstruct sk_buff *skb;\n\n\t \n\tmemset((char *)bp->rx_cmds, 0,\n\t       (N_RX_RING + 1) * sizeof(struct dbdma_cmd));\n\tfor (i = 0; i < N_RX_RING; i++) {\n\t\tif ((skb = bp->rx_bufs[i]) == NULL) {\n\t\t\tbp->rx_bufs[i] = skb = netdev_alloc_skb(dev, RX_BUFLEN + 2);\n\t\t\tif (skb != NULL)\n\t\t\t\tskb_reserve(skb, 2);\n\t\t}\n\t\tbmac_construct_rxbuff(skb, &bp->rx_cmds[i]);\n\t}\n\n\tbp->rx_empty = 0;\n\tbp->rx_fill = i;\n\n\t \n\tdbdma_setcmd(&bp->rx_cmds[N_RX_RING],\n\t\t     (DBDMA_NOP | BR_ALWAYS), 0, 0, virt_to_bus(bp->rx_cmds));\n\n\t \n\tdbdma_reset(rd);\n\tout_le32(&rd->cmdptr, virt_to_bus(bp->rx_cmds));\n\n\treturn 1;\n}\n\n\nstatic int bmac_transmit_packet(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tvolatile struct dbdma_regs __iomem *td = bp->tx_dma;\n\tint i;\n\n\t \n\t \n\t \n\ti = bp->tx_fill + 1;\n\tif (i >= N_TX_RING)\n\t\ti = 0;\n\tif (i == bp->tx_empty) {\n\t\tnetif_stop_queue(dev);\n\t\tbp->tx_fullup = 1;\n\t\tXXDEBUG((\"bmac_transmit_packet: tx ring full\\n\"));\n\t\treturn -1;\t\t \n\t}\n\n\tdbdma_setcmd(&bp->tx_cmds[i], DBDMA_STOP, 0, 0, 0);\n\n\tbmac_construct_xmt(skb, &bp->tx_cmds[bp->tx_fill]);\n\n\tbp->tx_bufs[bp->tx_fill] = skb;\n\tbp->tx_fill = i;\n\n\tdev->stats.tx_bytes += skb->len;\n\n\tdbdma_continue(td);\n\n\treturn 0;\n}\n\nstatic int rxintcount;\n\nstatic irqreturn_t bmac_rxdma_intr(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *) dev_id;\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tvolatile struct dbdma_regs __iomem *rd = bp->rx_dma;\n\tvolatile struct dbdma_cmd *cp;\n\tint i, nb, stat;\n\tstruct sk_buff *skb;\n\tunsigned int residual;\n\tint last;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\n\tif (++rxintcount < 10) {\n\t\tXXDEBUG((\"bmac_rxdma_intr\\n\"));\n\t}\n\n\tlast = -1;\n\ti = bp->rx_empty;\n\n\twhile (1) {\n\t\tcp = &bp->rx_cmds[i];\n\t\tstat = le16_to_cpu(cp->xfer_status);\n\t\tresidual = le16_to_cpu(cp->res_count);\n\t\tif ((stat & ACTIVE) == 0)\n\t\t\tbreak;\n\t\tnb = RX_BUFLEN - residual - 2;\n\t\tif (nb < (ETHERMINPACKET - ETHERCRC)) {\n\t\t\tskb = NULL;\n\t\t\tdev->stats.rx_length_errors++;\n\t\t\tdev->stats.rx_errors++;\n\t\t} else {\n\t\t\tskb = bp->rx_bufs[i];\n\t\t\tbp->rx_bufs[i] = NULL;\n\t\t}\n\t\tif (skb != NULL) {\n\t\t\tnb -= ETHERCRC;\n\t\t\tskb_put(skb, nb);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_rx(skb);\n\t\t\t++dev->stats.rx_packets;\n\t\t\tdev->stats.rx_bytes += nb;\n\t\t} else {\n\t\t\t++dev->stats.rx_dropped;\n\t\t}\n\t\tif ((skb = bp->rx_bufs[i]) == NULL) {\n\t\t\tbp->rx_bufs[i] = skb = netdev_alloc_skb(dev, RX_BUFLEN + 2);\n\t\t\tif (skb != NULL)\n\t\t\t\tskb_reserve(bp->rx_bufs[i], 2);\n\t\t}\n\t\tbmac_construct_rxbuff(skb, &bp->rx_cmds[i]);\n\t\tcp->res_count = cpu_to_le16(0);\n\t\tcp->xfer_status = cpu_to_le16(0);\n\t\tlast = i;\n\t\tif (++i >= N_RX_RING) i = 0;\n\t}\n\n\tif (last != -1) {\n\t\tbp->rx_fill = last;\n\t\tbp->rx_empty = i;\n\t}\n\n\tdbdma_continue(rd);\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\tif (rxintcount < 10) {\n\t\tXXDEBUG((\"bmac_rxdma_intr done\\n\"));\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int txintcount;\n\nstatic irqreturn_t bmac_txdma_intr(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *) dev_id;\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tvolatile struct dbdma_cmd *cp;\n\tint stat;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\n\tif (txintcount++ < 10) {\n\t\tXXDEBUG((\"bmac_txdma_intr\\n\"));\n\t}\n\n\t \n\t \n\n\twhile (1) {\n\t\tcp = &bp->tx_cmds[bp->tx_empty];\n\t\tstat = le16_to_cpu(cp->xfer_status);\n\t\tif (txintcount < 10) {\n\t\t\tXXDEBUG((\"bmac_txdma_xfer_stat=%#0x\\n\", stat));\n\t\t}\n\t\tif (!(stat & ACTIVE)) {\n\t\t\t \n\t\t\tif (cp == bus_to_virt(in_le32(&bp->tx_dma->cmdptr)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (bp->tx_bufs[bp->tx_empty]) {\n\t\t\t++dev->stats.tx_packets;\n\t\t\tdev_consume_skb_irq(bp->tx_bufs[bp->tx_empty]);\n\t\t}\n\t\tbp->tx_bufs[bp->tx_empty] = NULL;\n\t\tbp->tx_fullup = 0;\n\t\tnetif_wake_queue(dev);\n\t\tif (++bp->tx_empty >= N_TX_RING)\n\t\t\tbp->tx_empty = 0;\n\t\tif (bp->tx_empty == bp->tx_fill)\n\t\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\tif (txintcount < 10) {\n\t\tXXDEBUG((\"bmac_txdma_intr done->bmac_start\\n\"));\n\t}\n\n\tbmac_start(dev);\n\treturn IRQ_HANDLED;\n}\n\n#ifndef SUNHME_MULTICAST\n \nstatic int reverse6[64] = {\n\t0x0,0x20,0x10,0x30,0x8,0x28,0x18,0x38,\n\t0x4,0x24,0x14,0x34,0xc,0x2c,0x1c,0x3c,\n\t0x2,0x22,0x12,0x32,0xa,0x2a,0x1a,0x3a,\n\t0x6,0x26,0x16,0x36,0xe,0x2e,0x1e,0x3e,\n\t0x1,0x21,0x11,0x31,0x9,0x29,0x19,0x39,\n\t0x5,0x25,0x15,0x35,0xd,0x2d,0x1d,0x3d,\n\t0x3,0x23,0x13,0x33,0xb,0x2b,0x1b,0x3b,\n\t0x7,0x27,0x17,0x37,0xf,0x2f,0x1f,0x3f\n};\n\nstatic unsigned int\ncrc416(unsigned int curval, unsigned short nxtval)\n{\n\tunsigned int counter, cur = curval, next = nxtval;\n\tint high_crc_set, low_data_set;\n\n\t \n\tnext = ((next & 0x00FF) << 8) | (next >> 8);\n\n\t \n\tfor (counter = 0; counter < 16; ++counter) {\n\t\t \n\t\tif ((cur & 0x80000000) == 0) high_crc_set = 0;\n\t\telse high_crc_set = 1;\n\n\t\tcur = cur << 1;\n\n\t\tif ((next & 0x0001) == 0) low_data_set = 0;\n\t\telse low_data_set = 1;\n\n\t\tnext = next >> 1;\n\n\t\t \n\t\tif (high_crc_set ^ low_data_set) cur = cur ^ CRC32_POLY_BE;\n\t}\n\treturn cur;\n}\n\nstatic unsigned int\nbmac_crc(unsigned short *address)\n{\n\tunsigned int newcrc;\n\n\tXXDEBUG((\"bmac_crc: addr=%#04x, %#04x, %#04x\\n\", *address, address[1], address[2]));\n\tnewcrc = crc416(0xffffffff, *address);\t \n\tnewcrc = crc416(newcrc, address[1]);\t \n\tnewcrc = crc416(newcrc, address[2]);\t \n\n\treturn(newcrc);\n}\n\n \n\nstatic void\nbmac_addhash(struct bmac_data *bp, unsigned char *addr)\n{\n\tunsigned int\t crc;\n\tunsigned short\t mask;\n\n\tif (!(*addr)) return;\n\tcrc = bmac_crc((unsigned short *)addr) & 0x3f;  \n\tcrc = reverse6[crc];\t \n\tif (bp->hash_use_count[crc]++) return;  \n\tmask = crc % 16;\n\tmask = (unsigned char)1 << mask;\n\tbp->hash_use_count[crc/16] |= mask;\n}\n\nstatic void\nbmac_removehash(struct bmac_data *bp, unsigned char *addr)\n{\n\tunsigned int crc;\n\tunsigned char mask;\n\n\t \n\tcrc = bmac_crc((unsigned short *)addr) & 0x3f;  \n\tcrc = reverse6[crc];\t \n\tif (bp->hash_use_count[crc] == 0) return;  \n\tif (--bp->hash_use_count[crc]) return;  \n\tmask = crc % 16;\n\tmask = ((unsigned char)1 << mask) ^ 0xffff;  \n\tbp->hash_table_mask[crc/16] &= mask;\n}\n\n \n\nstatic void\nbmac_rx_off(struct net_device *dev)\n{\n\tunsigned short rx_cfg;\n\n\trx_cfg = bmread(dev, RXCFG);\n\trx_cfg &= ~RxMACEnable;\n\tbmwrite(dev, RXCFG, rx_cfg);\n\tdo {\n\t\trx_cfg = bmread(dev, RXCFG);\n\t}  while (rx_cfg & RxMACEnable);\n}\n\nunsigned short\nbmac_rx_on(struct net_device *dev, int hash_enable, int promisc_enable)\n{\n\tunsigned short rx_cfg;\n\n\trx_cfg = bmread(dev, RXCFG);\n\trx_cfg |= RxMACEnable;\n\tif (hash_enable) rx_cfg |= RxHashFilterEnable;\n\telse rx_cfg &= ~RxHashFilterEnable;\n\tif (promisc_enable) rx_cfg |= RxPromiscEnable;\n\telse rx_cfg &= ~RxPromiscEnable;\n\tbmwrite(dev, RXRST, RxResetValue);\n\tbmwrite(dev, RXFIFOCSR, 0);\t \n\tbmwrite(dev, RXFIFOCSR, RxFIFOEnable );\n\tbmwrite(dev, RXCFG, rx_cfg );\n\treturn rx_cfg;\n}\n\nstatic void\nbmac_update_hash_table_mask(struct net_device *dev, struct bmac_data *bp)\n{\n\tbmwrite(dev, BHASH3, bp->hash_table_mask[0]);  \n\tbmwrite(dev, BHASH2, bp->hash_table_mask[1]);  \n\tbmwrite(dev, BHASH1, bp->hash_table_mask[2]);  \n\tbmwrite(dev, BHASH0, bp->hash_table_mask[3]);  \n}\n\n#if 0\nstatic void\nbmac_add_multi(struct net_device *dev,\n\t       struct bmac_data *bp, unsigned char *addr)\n{\n\t \n\tbmac_addhash(bp, addr);\n\tbmac_rx_off(dev);\n\tbmac_update_hash_table_mask(dev, bp);\n\tbmac_rx_on(dev, 1, (dev->flags & IFF_PROMISC)? 1 : 0);\n\t \n}\n\nstatic void\nbmac_remove_multi(struct net_device *dev,\n\t\t  struct bmac_data *bp, unsigned char *addr)\n{\n\tbmac_removehash(bp, addr);\n\tbmac_rx_off(dev);\n\tbmac_update_hash_table_mask(dev, bp);\n\tbmac_rx_on(dev, 1, (dev->flags & IFF_PROMISC)? 1 : 0);\n}\n#endif\n\n \nstatic void bmac_set_multicast(struct net_device *dev)\n{\n\tstruct netdev_hw_addr *ha;\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tint num_addrs = netdev_mc_count(dev);\n\tunsigned short rx_cfg;\n\tint i;\n\n\tif (bp->sleeping)\n\t\treturn;\n\n\tXXDEBUG((\"bmac: enter bmac_set_multicast, n_addrs=%d\\n\", num_addrs));\n\n\tif((dev->flags & IFF_ALLMULTI) || (netdev_mc_count(dev) > 64)) {\n\t\tfor (i=0; i<4; i++) bp->hash_table_mask[i] = 0xffff;\n\t\tbmac_update_hash_table_mask(dev, bp);\n\t\trx_cfg = bmac_rx_on(dev, 1, 0);\n\t\tXXDEBUG((\"bmac: all multi, rx_cfg=%#08x\\n\"));\n\t} else if ((dev->flags & IFF_PROMISC) || (num_addrs < 0)) {\n\t\trx_cfg = bmread(dev, RXCFG);\n\t\trx_cfg |= RxPromiscEnable;\n\t\tbmwrite(dev, RXCFG, rx_cfg);\n\t\trx_cfg = bmac_rx_on(dev, 0, 1);\n\t\tXXDEBUG((\"bmac: promisc mode enabled, rx_cfg=%#08x\\n\", rx_cfg));\n\t} else {\n\t\tfor (i=0; i<4; i++) bp->hash_table_mask[i] = 0;\n\t\tfor (i=0; i<64; i++) bp->hash_use_count[i] = 0;\n\t\tif (num_addrs == 0) {\n\t\t\trx_cfg = bmac_rx_on(dev, 0, 0);\n\t\t\tXXDEBUG((\"bmac: multi disabled, rx_cfg=%#08x\\n\", rx_cfg));\n\t\t} else {\n\t\t\tnetdev_for_each_mc_addr(ha, dev)\n\t\t\t\tbmac_addhash(bp, ha->addr);\n\t\t\tbmac_update_hash_table_mask(dev, bp);\n\t\t\trx_cfg = bmac_rx_on(dev, 1, 0);\n\t\t\tXXDEBUG((\"bmac: multi enabled, rx_cfg=%#08x\\n\", rx_cfg));\n\t\t}\n\t}\n\t \n}\n#else  \n\n \n\nstatic void bmac_set_multicast(struct net_device *dev)\n{\n\tstruct netdev_hw_addr *ha;\n\tunsigned short rx_cfg;\n\tu32 crc;\n\n\tif((dev->flags & IFF_ALLMULTI) || (netdev_mc_count(dev) > 64)) {\n\t\tbmwrite(dev, BHASH0, 0xffff);\n\t\tbmwrite(dev, BHASH1, 0xffff);\n\t\tbmwrite(dev, BHASH2, 0xffff);\n\t\tbmwrite(dev, BHASH3, 0xffff);\n\t} else if(dev->flags & IFF_PROMISC) {\n\t\trx_cfg = bmread(dev, RXCFG);\n\t\trx_cfg |= RxPromiscEnable;\n\t\tbmwrite(dev, RXCFG, rx_cfg);\n\t} else {\n\t\tu16 hash_table[4] = { 0 };\n\n\t\trx_cfg = bmread(dev, RXCFG);\n\t\trx_cfg &= ~RxPromiscEnable;\n\t\tbmwrite(dev, RXCFG, rx_cfg);\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tcrc = ether_crc_le(6, ha->addr);\n\t\t\tcrc >>= 26;\n\t\t\thash_table[crc >> 4] |= 1 << (crc & 0xf);\n\t\t}\n\t\tbmwrite(dev, BHASH0, hash_table[0]);\n\t\tbmwrite(dev, BHASH1, hash_table[1]);\n\t\tbmwrite(dev, BHASH2, hash_table[2]);\n\t\tbmwrite(dev, BHASH3, hash_table[3]);\n\t}\n}\n#endif  \n\nstatic int miscintcount;\n\nstatic irqreturn_t bmac_misc_intr(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *) dev_id;\n\tunsigned int status = bmread(dev, STATUS);\n\tif (miscintcount++ < 10) {\n\t\tXXDEBUG((\"bmac_misc_intr\\n\"));\n\t}\n\t \n\t \n\t \n\tif (status & RxErrorMask) dev->stats.rx_errors++;\n\tif (status & RxCRCCntExp) dev->stats.rx_crc_errors++;\n\tif (status & RxLenCntExp) dev->stats.rx_length_errors++;\n\tif (status & RxOverFlow) dev->stats.rx_over_errors++;\n\tif (status & RxAlignCntExp) dev->stats.rx_frame_errors++;\n\n\t \n\tif (status & TxErrorMask) dev->stats.tx_errors++;\n\tif (status & TxUnderrun) dev->stats.tx_fifo_errors++;\n\tif (status & TxNormalCollExp) dev->stats.collisions++;\n\treturn IRQ_HANDLED;\n}\n\n \n#define SROMAddressLength\t5\n#define DataInOn\t\t0x0008\n#define DataInOff\t\t0x0000\n#define Clk\t\t\t0x0002\n#define ChipSelect\t\t0x0001\n#define SDIShiftCount\t\t3\n#define SD0ShiftCount\t\t2\n#define\tDelayValue\t\t1000\t \n#define SROMStartOffset\t\t10\t \n#define SROMReadCount\t\t3\t \n#define SROMAddressBits\t\t6\n#define EnetAddressOffset\t20\n\nstatic unsigned char\nbmac_clock_out_bit(struct net_device *dev)\n{\n\tunsigned short         data;\n\tunsigned short         val;\n\n\tbmwrite(dev, SROMCSR, ChipSelect | Clk);\n\tudelay(DelayValue);\n\n\tdata = bmread(dev, SROMCSR);\n\tudelay(DelayValue);\n\tval = (data >> SD0ShiftCount) & 1;\n\n\tbmwrite(dev, SROMCSR, ChipSelect);\n\tudelay(DelayValue);\n\n\treturn val;\n}\n\nstatic void\nbmac_clock_in_bit(struct net_device *dev, unsigned int val)\n{\n\tunsigned short data;\n\n\tif (val != 0 && val != 1) return;\n\n\tdata = (val << SDIShiftCount);\n\tbmwrite(dev, SROMCSR, data | ChipSelect  );\n\tudelay(DelayValue);\n\n\tbmwrite(dev, SROMCSR, data | ChipSelect | Clk );\n\tudelay(DelayValue);\n\n\tbmwrite(dev, SROMCSR, data | ChipSelect);\n\tudelay(DelayValue);\n}\n\nstatic void\nreset_and_select_srom(struct net_device *dev)\n{\n\t \n\tbmwrite(dev, SROMCSR, 0);\n\tudelay(DelayValue);\n\n\t \n\tbmac_clock_in_bit(dev, 1);\n\tbmac_clock_in_bit(dev, 1);\n\tbmac_clock_in_bit(dev, 0);\n}\n\nstatic unsigned short\nread_srom(struct net_device *dev, unsigned int addr, unsigned int addr_len)\n{\n\tunsigned short data, val;\n\tint i;\n\n\t \n\tfor (i = 0; i < addr_len; i++)\t{\n\t\tval = addr >> (addr_len-i-1);\n\t\tbmac_clock_in_bit(dev, val & 1);\n\t}\n\n\t \n\tdata = 0;\n\tfor (i = 0; i < 16; i++)\t{\n\t\tval = bmac_clock_out_bit(dev);\n\t\tdata <<= 1;\n\t\tdata |= val;\n\t}\n\tbmwrite(dev, SROMCSR, 0);\n\n\treturn data;\n}\n\n \n\nstatic int\nbmac_verify_checksum(struct net_device *dev)\n{\n\tunsigned short data, storedCS;\n\n\treset_and_select_srom(dev);\n\tdata = read_srom(dev, 3, SROMAddressBits);\n\tstoredCS = ((data >> 8) & 0x0ff) | ((data << 8) & 0xff00);\n\n\treturn 0;\n}\n\n\nstatic void\nbmac_get_station_address(struct net_device *dev, unsigned char *ea)\n{\n\tint i;\n\tunsigned short data;\n\n\tfor (i = 0; i < 3; i++)\n\t\t{\n\t\t\treset_and_select_srom(dev);\n\t\t\tdata = read_srom(dev, i + EnetAddressOffset/2, SROMAddressBits);\n\t\t\tea[2*i]   = bitrev8(data & 0x0ff);\n\t\t\tea[2*i+1] = bitrev8((data >> 8) & 0x0ff);\n\t\t}\n}\n\nstatic void bmac_reset_and_enable(struct net_device *dev)\n{\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tunsigned char *data;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\tbmac_enable_and_reset_chip(dev);\n\tbmac_init_tx_ring(bp);\n\tbmac_init_rx_ring(dev);\n\tbmac_init_chip(dev);\n\tbmac_start_chip(dev);\n\tbmwrite(dev, INTDISABLE, EnableNormal);\n\tbp->sleeping = 0;\n\n\t \n\tskb = netdev_alloc_skb(dev, ETHERMINPACKET);\n\tif (skb != NULL) {\n\t\tdata = skb_put_zero(skb, ETHERMINPACKET);\n\t\tmemcpy(data, dev->dev_addr, ETH_ALEN);\n\t\tmemcpy(data + ETH_ALEN, dev->dev_addr, ETH_ALEN);\n\t\tbmac_transmit_packet(skb, dev);\n\t}\n\tspin_unlock_irqrestore(&bp->lock, flags);\n}\n\nstatic const struct ethtool_ops bmac_ethtool_ops = {\n\t.get_link\t\t= ethtool_op_get_link,\n};\n\nstatic const struct net_device_ops bmac_netdev_ops = {\n\t.ndo_open\t\t= bmac_open,\n\t.ndo_stop\t\t= bmac_close,\n\t.ndo_start_xmit\t\t= bmac_output,\n\t.ndo_set_rx_mode\t= bmac_set_multicast,\n\t.ndo_set_mac_address\t= bmac_set_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int bmac_probe(struct macio_dev *mdev, const struct of_device_id *match)\n{\n\tint j, rev, ret;\n\tstruct bmac_data *bp;\n\tconst unsigned char *prop_addr;\n\tunsigned char addr[6];\n\tu8 macaddr[6];\n\tstruct net_device *dev;\n\tint is_bmac_plus = ((int)match->data) != 0;\n\n\tif (macio_resource_count(mdev) != 3 || macio_irq_count(mdev) != 3) {\n\t\tprintk(KERN_ERR \"BMAC: can't use, need 3 addrs and 3 intrs\\n\");\n\t\treturn -ENODEV;\n\t}\n\tprop_addr = of_get_property(macio_get_of_node(mdev),\n\t\t\t\"mac-address\", NULL);\n\tif (prop_addr == NULL) {\n\t\tprop_addr = of_get_property(macio_get_of_node(mdev),\n\t\t\t\t\"local-mac-address\", NULL);\n\t\tif (prop_addr == NULL) {\n\t\t\tprintk(KERN_ERR \"BMAC: Can't get mac-address\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tmemcpy(addr, prop_addr, sizeof(addr));\n\n\tdev = alloc_etherdev(PRIV_BYTES);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tbp = netdev_priv(dev);\n\tSET_NETDEV_DEV(dev, &mdev->ofdev.dev);\n\tmacio_set_drvdata(mdev, dev);\n\n\tbp->mdev = mdev;\n\tspin_lock_init(&bp->lock);\n\n\tif (macio_request_resources(mdev, \"bmac\")) {\n\t\tprintk(KERN_ERR \"BMAC: can't request IO resource !\\n\");\n\t\tgoto out_free;\n\t}\n\n\tdev->base_addr = (unsigned long)\n\t\tioremap(macio_resource_start(mdev, 0), macio_resource_len(mdev, 0));\n\tif (dev->base_addr == 0)\n\t\tgoto out_release;\n\n\tdev->irq = macio_irq(mdev, 0);\n\n\tbmac_enable_and_reset_chip(dev);\n\tbmwrite(dev, INTDISABLE, DisableAll);\n\n\trev = addr[0] == 0 && addr[1] == 0xA0;\n\tfor (j = 0; j < 6; ++j)\n\t\tmacaddr[j] = rev ? bitrev8(addr[j]): addr[j];\n\n\teth_hw_addr_set(dev, macaddr);\n\n\t \n\tbmac_enable_and_reset_chip(dev);\n\tbmwrite(dev, INTDISABLE, DisableAll);\n\n\tdev->netdev_ops = &bmac_netdev_ops;\n\tdev->ethtool_ops = &bmac_ethtool_ops;\n\n\tbmac_get_station_address(dev, addr);\n\tif (bmac_verify_checksum(dev) != 0)\n\t\tgoto err_out_iounmap;\n\n\tbp->is_bmac_plus = is_bmac_plus;\n\tbp->tx_dma = ioremap(macio_resource_start(mdev, 1), macio_resource_len(mdev, 1));\n\tif (!bp->tx_dma)\n\t\tgoto err_out_iounmap;\n\tbp->tx_dma_intr = macio_irq(mdev, 1);\n\tbp->rx_dma = ioremap(macio_resource_start(mdev, 2), macio_resource_len(mdev, 2));\n\tif (!bp->rx_dma)\n\t\tgoto err_out_iounmap_tx;\n\tbp->rx_dma_intr = macio_irq(mdev, 2);\n\n\tbp->tx_cmds = (volatile struct dbdma_cmd *) DBDMA_ALIGN(bp + 1);\n\tbp->rx_cmds = bp->tx_cmds + N_TX_RING + 1;\n\n\tbp->queue = (struct sk_buff_head *)(bp->rx_cmds + N_RX_RING + 1);\n\tskb_queue_head_init(bp->queue);\n\n\ttimer_setup(&bp->tx_timeout, bmac_tx_timeout, 0);\n\n\tret = request_irq(dev->irq, bmac_misc_intr, 0, \"BMAC-misc\", dev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BMAC: can't get irq %d\\n\", dev->irq);\n\t\tgoto err_out_iounmap_rx;\n\t}\n\tret = request_irq(bp->tx_dma_intr, bmac_txdma_intr, 0, \"BMAC-txdma\", dev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BMAC: can't get irq %d\\n\", bp->tx_dma_intr);\n\t\tgoto err_out_irq0;\n\t}\n\tret = request_irq(bp->rx_dma_intr, bmac_rxdma_intr, 0, \"BMAC-rxdma\", dev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BMAC: can't get irq %d\\n\", bp->rx_dma_intr);\n\t\tgoto err_out_irq1;\n\t}\n\n\t \n\tdisable_irq(dev->irq);\n\tpmac_call_feature(PMAC_FTR_BMAC_ENABLE, macio_get_of_node(bp->mdev), 0, 0);\n\n\tif (register_netdev(dev) != 0) {\n\t\tprintk(KERN_ERR \"BMAC: Ethernet registration failed\\n\");\n\t\tgoto err_out_irq2;\n\t}\n\n\tprintk(KERN_INFO \"%s: BMAC%s at %pM\",\n\t       dev->name, (is_bmac_plus ? \"+\" : \"\"), dev->dev_addr);\n\tXXDEBUG((\", base_addr=%#0lx\", dev->base_addr));\n\tprintk(\"\\n\");\n\n\treturn 0;\n\nerr_out_irq2:\n\tfree_irq(bp->rx_dma_intr, dev);\nerr_out_irq1:\n\tfree_irq(bp->tx_dma_intr, dev);\nerr_out_irq0:\n\tfree_irq(dev->irq, dev);\nerr_out_iounmap_rx:\n\tiounmap(bp->rx_dma);\nerr_out_iounmap_tx:\n\tiounmap(bp->tx_dma);\nerr_out_iounmap:\n\tiounmap((void __iomem *)dev->base_addr);\nout_release:\n\tmacio_release_resources(mdev);\nout_free:\n\tpmac_call_feature(PMAC_FTR_BMAC_ENABLE, macio_get_of_node(bp->mdev), 0, 0);\n\tfree_netdev(dev);\n\n\treturn -ENODEV;\n}\n\nstatic int bmac_open(struct net_device *dev)\n{\n\tstruct bmac_data *bp = netdev_priv(dev);\n\t \n\t \n\tbp->opened = 1;\n\tbmac_reset_and_enable(dev);\n\tenable_irq(dev->irq);\n\treturn 0;\n}\n\nstatic int bmac_close(struct net_device *dev)\n{\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tvolatile struct dbdma_regs __iomem *rd = bp->rx_dma;\n\tvolatile struct dbdma_regs __iomem *td = bp->tx_dma;\n\tunsigned short config;\n\tint i;\n\n\tbp->sleeping = 1;\n\n\t \n\tconfig = bmread(dev, RXCFG);\n\tbmwrite(dev, RXCFG, (config & ~RxMACEnable));\n\n\tconfig = bmread(dev, TXCFG);\n\tbmwrite(dev, TXCFG, (config & ~TxMACEnable));\n\n\tbmwrite(dev, INTDISABLE, DisableAll);  \n\n\t \n\trd->control = cpu_to_le32(DBDMA_CLEAR(RUN|PAUSE|FLUSH|WAKE));\t \n\ttd->control = cpu_to_le32(DBDMA_CLEAR(RUN|PAUSE|FLUSH|WAKE));\t \n\n\t \n\tXXDEBUG((\"bmac: free rx bufs\\n\"));\n\tfor (i=0; i<N_RX_RING; i++) {\n\t\tif (bp->rx_bufs[i] != NULL) {\n\t\t\tdev_kfree_skb(bp->rx_bufs[i]);\n\t\t\tbp->rx_bufs[i] = NULL;\n\t\t}\n\t}\n\tXXDEBUG((\"bmac: free tx bufs\\n\"));\n\tfor (i = 0; i<N_TX_RING; i++) {\n\t\tif (bp->tx_bufs[i] != NULL) {\n\t\t\tdev_kfree_skb(bp->tx_bufs[i]);\n\t\t\tbp->tx_bufs[i] = NULL;\n\t\t}\n\t}\n\tXXDEBUG((\"bmac: all bufs freed\\n\"));\n\n\tbp->opened = 0;\n\tdisable_irq(dev->irq);\n\tpmac_call_feature(PMAC_FTR_BMAC_ENABLE, macio_get_of_node(bp->mdev), 0, 0);\n\n\treturn 0;\n}\n\nstatic void\nbmac_start(struct net_device *dev)\n{\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tint i;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\n\tif (bp->sleeping)\n\t\treturn;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\twhile (1) {\n\t\ti = bp->tx_fill + 1;\n\t\tif (i >= N_TX_RING)\n\t\t\ti = 0;\n\t\tif (i == bp->tx_empty)\n\t\t\tbreak;\n\t\tskb = skb_dequeue(bp->queue);\n\t\tif (skb == NULL)\n\t\t\tbreak;\n\t\tbmac_transmit_packet(skb, dev);\n\t}\n\tspin_unlock_irqrestore(&bp->lock, flags);\n}\n\nstatic netdev_tx_t\nbmac_output(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct bmac_data *bp = netdev_priv(dev);\n\tskb_queue_tail(bp->queue, skb);\n\tbmac_start(dev);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void bmac_tx_timeout(struct timer_list *t)\n{\n\tstruct bmac_data *bp = from_timer(bp, t, tx_timeout);\n\tstruct net_device *dev = macio_get_drvdata(bp->mdev);\n\tvolatile struct dbdma_regs __iomem *td = bp->tx_dma;\n\tvolatile struct dbdma_regs __iomem *rd = bp->rx_dma;\n\tvolatile struct dbdma_cmd *cp;\n\tunsigned long flags;\n\tunsigned short config, oldConfig;\n\tint i;\n\n\tXXDEBUG((\"bmac: tx_timeout called\\n\"));\n\tspin_lock_irqsave(&bp->lock, flags);\n\tbp->timeout_active = 0;\n\n\t \n \n\n\tcp = &bp->tx_cmds[bp->tx_empty];\n \n \n \n\n\t \n\tconfig = bmread(dev, RXCFG);\n\tbmwrite(dev, RXCFG, (config & ~RxMACEnable));\n\tconfig = bmread(dev, TXCFG);\n\tbmwrite(dev, TXCFG, (config & ~TxMACEnable));\n\tout_le32(&td->control, DBDMA_CLEAR(RUN|PAUSE|FLUSH|WAKE|ACTIVE|DEAD));\n\tprintk(KERN_ERR \"bmac: transmit timeout - resetting\\n\");\n\tbmac_enable_and_reset_chip(dev);\n\n\t \n\tcp = bus_to_virt(le32_to_cpu(rd->cmdptr));\n\tout_le32(&rd->control, DBDMA_CLEAR(RUN|PAUSE|FLUSH|WAKE|ACTIVE|DEAD));\n\tout_le16(&cp->xfer_status, 0);\n\tout_le32(&rd->cmdptr, virt_to_bus(cp));\n\tout_le32(&rd->control, DBDMA_SET(RUN|WAKE));\n\n\t \n\tXXDEBUG((KERN_DEBUG \"bmac: tx empty=%d fill=%d fullup=%d\\n\",\n\t\t bp->tx_empty, bp->tx_fill, bp->tx_fullup));\n\ti = bp->tx_empty;\n\t++dev->stats.tx_errors;\n\tif (i != bp->tx_fill) {\n\t\tdev_kfree_skb_irq(bp->tx_bufs[i]);\n\t\tbp->tx_bufs[i] = NULL;\n\t\tif (++i >= N_TX_RING) i = 0;\n\t\tbp->tx_empty = i;\n\t}\n\tbp->tx_fullup = 0;\n\tnetif_wake_queue(dev);\n\tif (i != bp->tx_fill) {\n\t\tcp = &bp->tx_cmds[i];\n\t\tout_le16(&cp->xfer_status, 0);\n\t\tout_le16(&cp->command, OUTPUT_LAST);\n\t\tout_le32(&td->cmdptr, virt_to_bus(cp));\n\t\tout_le32(&td->control, DBDMA_SET(RUN));\n\t\t \n\t\tXXDEBUG((KERN_DEBUG \"bmac: starting %d\\n\", i));\n\t}\n\n\t \n\toldConfig = bmread(dev, RXCFG);\n\tbmwrite(dev, RXCFG, oldConfig | RxMACEnable );\n\toldConfig = bmread(dev, TXCFG);\n\tbmwrite(dev, TXCFG, oldConfig | TxMACEnable );\n\n\tspin_unlock_irqrestore(&bp->lock, flags);\n}\n\n#if 0\nstatic void dump_dbdma(volatile struct dbdma_cmd *cp,int count)\n{\n\tint i,*ip;\n\n\tfor (i=0;i< count;i++) {\n\t\tip = (int*)(cp+i);\n\n\t\tprintk(\"dbdma req 0x%x addr 0x%x baddr 0x%x xfer/res 0x%x\\n\",\n\t\t       le32_to_cpup(ip+0),\n\t\t       le32_to_cpup(ip+1),\n\t\t       le32_to_cpup(ip+2),\n\t\t       le32_to_cpup(ip+3));\n\t}\n\n}\n#endif\n\n#if 0\nstatic int\nbmac_proc_info(char *buffer, char **start, off_t offset, int length)\n{\n\tint len = 0;\n\toff_t pos   = 0;\n\toff_t begin = 0;\n\tint i;\n\n\tif (bmac_devs == NULL)\n\t\treturn -ENOSYS;\n\n\tlen += sprintf(buffer, \"BMAC counters & registers\\n\");\n\n\tfor (i = 0; i<N_REG_ENTRIES; i++) {\n\t\tlen += sprintf(buffer + len, \"%s: %#08x\\n\",\n\t\t\t       reg_entries[i].name,\n\t\t\t       bmread(bmac_devs, reg_entries[i].reg_offset));\n\t\tpos = begin + len;\n\n\t\tif (pos < offset) {\n\t\t\tlen = 0;\n\t\t\tbegin = pos;\n\t\t}\n\n\t\tif (pos > offset+length) break;\n\t}\n\n\t*start = buffer + (offset - begin);\n\tlen -= (offset - begin);\n\n\tif (len > length) len = length;\n\n\treturn len;\n}\n#endif\n\nstatic int bmac_remove(struct macio_dev *mdev)\n{\n\tstruct net_device *dev = macio_get_drvdata(mdev);\n\tstruct bmac_data *bp = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\n\tfree_irq(dev->irq, dev);\n\tfree_irq(bp->tx_dma_intr, dev);\n\tfree_irq(bp->rx_dma_intr, dev);\n\n\tiounmap((void __iomem *)dev->base_addr);\n\tiounmap(bp->tx_dma);\n\tiounmap(bp->rx_dma);\n\n\tmacio_release_resources(mdev);\n\n\tfree_netdev(dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bmac_match[] =\n{\n\t{\n\t.name \t\t= \"bmac\",\n\t.data\t\t= (void *)0,\n\t},\n\t{\n\t.type\t\t= \"network\",\n\t.compatible\t= \"bmac+\",\n\t.data\t\t= (void *)1,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE (of, bmac_match);\n\nstatic struct macio_driver bmac_driver =\n{\n\t.driver = {\n\t\t.name \t\t= \"bmac\",\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.of_match_table\t= bmac_match,\n\t},\n\t.probe\t\t= bmac_probe,\n\t.remove\t\t= bmac_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= bmac_suspend,\n\t.resume\t\t= bmac_resume,\n#endif\n};\n\n\nstatic int __init bmac_init(void)\n{\n\tif (bmac_emergency_rxbuf == NULL) {\n\t\tbmac_emergency_rxbuf = kmalloc(RX_BUFLEN, GFP_KERNEL);\n\t\tif (bmac_emergency_rxbuf == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn macio_register_driver(&bmac_driver);\n}\n\nstatic void __exit bmac_exit(void)\n{\n\tmacio_unregister_driver(&bmac_driver);\n\n\tkfree(bmac_emergency_rxbuf);\n\tbmac_emergency_rxbuf = NULL;\n}\n\nMODULE_AUTHOR(\"Randy Gobbel/Paul Mackerras\");\nMODULE_DESCRIPTION(\"PowerMac BMAC ethernet driver.\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(bmac_init);\nmodule_exit(bmac_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}