{
  "module_name": "ocelot_fdma.c",
  "hash_id": "4e0aa279b48bdb600500c29052628df0e43a205f82c0d48b936fc9b962824cd2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mscc/ocelot_fdma.c",
  "human_readable_source": "\n \n\n#include <linux/align.h>\n#include <linux/bitops.h>\n#include <linux/dmapool.h>\n#include <linux/dsa/ocelot.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n\n#include \"ocelot_fdma.h\"\n#include \"ocelot_qs.h\"\n\nDEFINE_STATIC_KEY_FALSE(ocelot_fdma_enabled);\n\nstatic void ocelot_fdma_writel(struct ocelot *ocelot, u32 reg, u32 data)\n{\n\tregmap_write(ocelot->targets[FDMA], reg, data);\n}\n\nstatic u32 ocelot_fdma_readl(struct ocelot *ocelot, u32 reg)\n{\n\tu32 retval;\n\n\tregmap_read(ocelot->targets[FDMA], reg, &retval);\n\n\treturn retval;\n}\n\nstatic dma_addr_t ocelot_fdma_idx_dma(dma_addr_t base, u16 idx)\n{\n\treturn base + idx * sizeof(struct ocelot_fdma_dcb);\n}\n\nstatic u16 ocelot_fdma_dma_idx(dma_addr_t base, dma_addr_t dma)\n{\n\treturn (dma - base) / sizeof(struct ocelot_fdma_dcb);\n}\n\nstatic u16 ocelot_fdma_idx_next(u16 idx, u16 ring_sz)\n{\n\treturn unlikely(idx == ring_sz - 1) ? 0 : idx + 1;\n}\n\nstatic u16 ocelot_fdma_idx_prev(u16 idx, u16 ring_sz)\n{\n\treturn unlikely(idx == 0) ? ring_sz - 1 : idx - 1;\n}\n\nstatic int ocelot_fdma_rx_ring_free(struct ocelot_fdma *fdma)\n{\n\tstruct ocelot_fdma_rx_ring *rx_ring = &fdma->rx_ring;\n\n\tif (rx_ring->next_to_use >= rx_ring->next_to_clean)\n\t\treturn OCELOT_FDMA_RX_RING_SIZE -\n\t\t       (rx_ring->next_to_use - rx_ring->next_to_clean) - 1;\n\telse\n\t\treturn rx_ring->next_to_clean - rx_ring->next_to_use - 1;\n}\n\nstatic int ocelot_fdma_tx_ring_free(struct ocelot_fdma *fdma)\n{\n\tstruct ocelot_fdma_tx_ring *tx_ring = &fdma->tx_ring;\n\n\tif (tx_ring->next_to_use >= tx_ring->next_to_clean)\n\t\treturn OCELOT_FDMA_TX_RING_SIZE -\n\t\t       (tx_ring->next_to_use - tx_ring->next_to_clean) - 1;\n\telse\n\t\treturn tx_ring->next_to_clean - tx_ring->next_to_use - 1;\n}\n\nstatic bool ocelot_fdma_tx_ring_empty(struct ocelot_fdma *fdma)\n{\n\tstruct ocelot_fdma_tx_ring *tx_ring = &fdma->tx_ring;\n\n\treturn tx_ring->next_to_clean == tx_ring->next_to_use;\n}\n\nstatic void ocelot_fdma_activate_chan(struct ocelot *ocelot, dma_addr_t dma,\n\t\t\t\t      int chan)\n{\n\tocelot_fdma_writel(ocelot, MSCC_FDMA_DCB_LLP(chan), dma);\n\t \n\twmb();\n\tocelot_fdma_writel(ocelot, MSCC_FDMA_CH_ACTIVATE, BIT(chan));\n}\n\nstatic u32 ocelot_fdma_read_ch_safe(struct ocelot *ocelot)\n{\n\treturn ocelot_fdma_readl(ocelot, MSCC_FDMA_CH_SAFE);\n}\n\nstatic int ocelot_fdma_wait_chan_safe(struct ocelot *ocelot, int chan)\n{\n\tu32 safe;\n\n\treturn readx_poll_timeout_atomic(ocelot_fdma_read_ch_safe, ocelot, safe,\n\t\t\t\t\t safe & BIT(chan), 0,\n\t\t\t\t\t OCELOT_FDMA_CH_SAFE_TIMEOUT_US);\n}\n\nstatic void ocelot_fdma_dcb_set_data(struct ocelot_fdma_dcb *dcb,\n\t\t\t\t     dma_addr_t dma_addr,\n\t\t\t\t     size_t size)\n{\n\tu32 offset = dma_addr & 0x3;\n\n\tdcb->llp = 0;\n\tdcb->datap = ALIGN_DOWN(dma_addr, 4);\n\tdcb->datal = ALIGN_DOWN(size, 4);\n\tdcb->stat = MSCC_FDMA_DCB_STAT_BLOCKO(offset);\n}\n\nstatic bool ocelot_fdma_rx_alloc_page(struct ocelot *ocelot,\n\t\t\t\t      struct ocelot_fdma_rx_buf *rxb)\n{\n\tdma_addr_t mapping;\n\tstruct page *page;\n\n\tpage = dev_alloc_page();\n\tif (unlikely(!page))\n\t\treturn false;\n\n\tmapping = dma_map_page(ocelot->dev, page, 0, PAGE_SIZE,\n\t\t\t       DMA_FROM_DEVICE);\n\tif (unlikely(dma_mapping_error(ocelot->dev, mapping))) {\n\t\t__free_page(page);\n\t\treturn false;\n\t}\n\n\trxb->page = page;\n\trxb->page_offset = 0;\n\trxb->dma_addr = mapping;\n\n\treturn true;\n}\n\nstatic int ocelot_fdma_alloc_rx_buffs(struct ocelot *ocelot, u16 alloc_cnt)\n{\n\tstruct ocelot_fdma *fdma = ocelot->fdma;\n\tstruct ocelot_fdma_rx_ring *rx_ring;\n\tstruct ocelot_fdma_rx_buf *rxb;\n\tstruct ocelot_fdma_dcb *dcb;\n\tdma_addr_t dma_addr;\n\tint ret = 0;\n\tu16 idx;\n\n\trx_ring = &fdma->rx_ring;\n\tidx = rx_ring->next_to_use;\n\n\twhile (alloc_cnt--) {\n\t\trxb = &rx_ring->bufs[idx];\n\t\t \n\t\tif (unlikely(!rxb->page)) {\n\t\t\tif (unlikely(!ocelot_fdma_rx_alloc_page(ocelot, rxb))) {\n\t\t\t\tdev_err_ratelimited(ocelot->dev,\n\t\t\t\t\t\t    \"Failed to allocate rx\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdcb = &rx_ring->dcbs[idx];\n\t\tdma_addr = rxb->dma_addr + rxb->page_offset;\n\t\tocelot_fdma_dcb_set_data(dcb, dma_addr, OCELOT_FDMA_RXB_SIZE);\n\n\t\tidx = ocelot_fdma_idx_next(idx, OCELOT_FDMA_RX_RING_SIZE);\n\t\t \n\t\tdcb->llp = ocelot_fdma_idx_dma(rx_ring->dcbs_dma, idx);\n\t}\n\n\trx_ring->next_to_use = idx;\n\trx_ring->next_to_alloc = idx;\n\n\treturn ret;\n}\n\nstatic bool ocelot_fdma_tx_dcb_set_skb(struct ocelot *ocelot,\n\t\t\t\t       struct ocelot_fdma_tx_buf *tx_buf,\n\t\t\t\t       struct ocelot_fdma_dcb *dcb,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tdma_addr_t mapping;\n\n\tmapping = dma_map_single(ocelot->dev, skb->data, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(ocelot->dev, mapping)))\n\t\treturn false;\n\n\tdma_unmap_addr_set(tx_buf, dma_addr, mapping);\n\n\tocelot_fdma_dcb_set_data(dcb, mapping, OCELOT_FDMA_RX_SIZE);\n\ttx_buf->skb = skb;\n\tdcb->stat |= MSCC_FDMA_DCB_STAT_BLOCKL(skb->len);\n\tdcb->stat |= MSCC_FDMA_DCB_STAT_SOF | MSCC_FDMA_DCB_STAT_EOF;\n\n\treturn true;\n}\n\nstatic bool ocelot_fdma_check_stop_rx(struct ocelot *ocelot)\n{\n\tu32 llp;\n\n\t \n\tllp = ocelot_fdma_readl(ocelot, MSCC_FDMA_DCB_LLP(MSCC_FDMA_XTR_CHAN));\n\tif (unlikely(llp))\n\t\treturn false;\n\n\tocelot_fdma_writel(ocelot, MSCC_FDMA_CH_DISABLE,\n\t\t\t   BIT(MSCC_FDMA_XTR_CHAN));\n\n\treturn true;\n}\n\nstatic void ocelot_fdma_rx_set_llp(struct ocelot_fdma_rx_ring *rx_ring)\n{\n\tstruct ocelot_fdma_dcb *dcb;\n\tunsigned int idx;\n\n\tidx = ocelot_fdma_idx_prev(rx_ring->next_to_use,\n\t\t\t\t   OCELOT_FDMA_RX_RING_SIZE);\n\tdcb = &rx_ring->dcbs[idx];\n\tdcb->llp = 0;\n}\n\nstatic void ocelot_fdma_rx_restart(struct ocelot *ocelot)\n{\n\tstruct ocelot_fdma *fdma = ocelot->fdma;\n\tstruct ocelot_fdma_rx_ring *rx_ring;\n\tconst u8 chan = MSCC_FDMA_XTR_CHAN;\n\tdma_addr_t new_llp, dma_base;\n\tunsigned int idx;\n\tu32 llp_prev;\n\tint ret;\n\n\trx_ring = &fdma->rx_ring;\n\tret = ocelot_fdma_wait_chan_safe(ocelot, chan);\n\tif (ret) {\n\t\tdev_err_ratelimited(ocelot->dev,\n\t\t\t\t    \"Unable to stop RX channel\\n\");\n\t\treturn;\n\t}\n\n\tocelot_fdma_rx_set_llp(rx_ring);\n\n\t \n\tllp_prev = ocelot_fdma_readl(ocelot, MSCC_FDMA_DCB_LLP_PREV(chan));\n\tdma_base = rx_ring->dcbs_dma;\n\n\t \n\tidx = ocelot_fdma_dma_idx(dma_base, llp_prev);\n\tidx = ocelot_fdma_idx_next(idx, OCELOT_FDMA_RX_RING_SIZE);\n\tnew_llp = ocelot_fdma_idx_dma(dma_base, idx);\n\n\t \n\tocelot_fdma_activate_chan(ocelot, new_llp, chan);\n}\n\nstatic bool ocelot_fdma_add_rx_frag(struct ocelot_fdma_rx_buf *rxb, u32 stat,\n\t\t\t\t    struct sk_buff *skb, bool first)\n{\n\tint size = MSCC_FDMA_DCB_STAT_BLOCKL(stat);\n\tstruct page *page = rxb->page;\n\n\tif (likely(first)) {\n\t\tskb_put(skb, size);\n\t} else {\n\t\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,\n\t\t\t\trxb->page_offset, size, OCELOT_FDMA_RX_SIZE);\n\t}\n\n\t \n\tif (unlikely(page_ref_count(page) != 1 || page_is_pfmemalloc(page)))\n\t\treturn false;\n\n\t \n\trxb->page_offset ^= OCELOT_FDMA_RX_SIZE;\n\n\tpage_ref_inc(page);\n\n\treturn true;\n}\n\nstatic void ocelot_fdma_reuse_rx_page(struct ocelot *ocelot,\n\t\t\t\t      struct ocelot_fdma_rx_buf *old_rxb)\n{\n\tstruct ocelot_fdma_rx_ring *rx_ring = &ocelot->fdma->rx_ring;\n\tstruct ocelot_fdma_rx_buf *new_rxb;\n\n\tnew_rxb = &rx_ring->bufs[rx_ring->next_to_alloc];\n\trx_ring->next_to_alloc = ocelot_fdma_idx_next(rx_ring->next_to_alloc,\n\t\t\t\t\t\t      OCELOT_FDMA_RX_RING_SIZE);\n\n\t \n\t*new_rxb = *old_rxb;\n\n\t \n\tdma_sync_single_range_for_device(ocelot->dev, old_rxb->dma_addr,\n\t\t\t\t\t old_rxb->page_offset,\n\t\t\t\t\t OCELOT_FDMA_RX_SIZE, DMA_FROM_DEVICE);\n}\n\nstatic struct sk_buff *ocelot_fdma_get_skb(struct ocelot *ocelot, u32 stat,\n\t\t\t\t\t   struct ocelot_fdma_rx_buf *rxb,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tbool first = false;\n\n\t \n\tif (likely(!skb)) {\n\t\tvoid *buff_addr = page_address(rxb->page) +\n\t\t\t\t  rxb->page_offset;\n\n\t\tskb = build_skb(buff_addr, OCELOT_FDMA_SKBFRAG_SIZE);\n\t\tif (unlikely(!skb)) {\n\t\t\tdev_err_ratelimited(ocelot->dev,\n\t\t\t\t\t    \"build_skb failed !\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tfirst = true;\n\t}\n\n\tdma_sync_single_range_for_cpu(ocelot->dev, rxb->dma_addr,\n\t\t\t\t      rxb->page_offset, OCELOT_FDMA_RX_SIZE,\n\t\t\t\t      DMA_FROM_DEVICE);\n\n\tif (ocelot_fdma_add_rx_frag(rxb, stat, skb, first)) {\n\t\t \n\t\tocelot_fdma_reuse_rx_page(ocelot, rxb);\n\t} else {\n\t\t \n\t\tdma_unmap_page(ocelot->dev, rxb->dma_addr, PAGE_SIZE,\n\t\t\t       DMA_FROM_DEVICE);\n\t}\n\n\t \n\trxb->page = NULL;\n\n\treturn skb;\n}\n\nstatic bool ocelot_fdma_receive_skb(struct ocelot *ocelot, struct sk_buff *skb)\n{\n\tstruct net_device *ndev;\n\tvoid *xfh = skb->data;\n\tu64 timestamp;\n\tu64 src_port;\n\n\tskb_pull(skb, OCELOT_TAG_LEN);\n\n\tocelot_xfh_get_src_port(xfh, &src_port);\n\tif (unlikely(src_port >= ocelot->num_phys_ports))\n\t\treturn false;\n\n\tndev = ocelot_port_to_netdev(ocelot, src_port);\n\tif (unlikely(!ndev))\n\t\treturn false;\n\n\tif (pskb_trim(skb, skb->len - ETH_FCS_LEN))\n\t\treturn false;\n\n\tskb->dev = ndev;\n\tskb->protocol = eth_type_trans(skb, skb->dev);\n\tskb->dev->stats.rx_bytes += skb->len;\n\tskb->dev->stats.rx_packets++;\n\n\tif (ocelot->ptp) {\n\t\tocelot_xfh_get_rew_val(xfh, &timestamp);\n\t\tocelot_ptp_rx_timestamp(ocelot, skb, timestamp);\n\t}\n\n\tif (likely(!skb_defer_rx_timestamp(skb)))\n\t\tnetif_receive_skb(skb);\n\n\treturn true;\n}\n\nstatic int ocelot_fdma_rx_get(struct ocelot *ocelot, int budget)\n{\n\tstruct ocelot_fdma *fdma = ocelot->fdma;\n\tstruct ocelot_fdma_rx_ring *rx_ring;\n\tstruct ocelot_fdma_rx_buf *rxb;\n\tstruct ocelot_fdma_dcb *dcb;\n\tstruct sk_buff *skb;\n\tint work_done = 0;\n\tint cleaned_cnt;\n\tu32 stat;\n\tu16 idx;\n\n\tcleaned_cnt = ocelot_fdma_rx_ring_free(fdma);\n\trx_ring = &fdma->rx_ring;\n\tskb = rx_ring->skb;\n\n\twhile (budget--) {\n\t\tidx = rx_ring->next_to_clean;\n\t\tdcb = &rx_ring->dcbs[idx];\n\t\tstat = dcb->stat;\n\t\tif (MSCC_FDMA_DCB_STAT_BLOCKL(stat) == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (unlikely(skb && (stat & MSCC_FDMA_DCB_STAT_SOF))) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tskb = NULL;\n\t\t}\n\n\t\trxb = &rx_ring->bufs[idx];\n\t\t \n\t\tskb = ocelot_fdma_get_skb(ocelot, stat, rxb, skb);\n\t\tif (unlikely(!skb))\n\t\t\tbreak;\n\n\t\twork_done++;\n\t\tcleaned_cnt++;\n\n\t\tidx = ocelot_fdma_idx_next(idx, OCELOT_FDMA_RX_RING_SIZE);\n\t\trx_ring->next_to_clean = idx;\n\n\t\tif (unlikely(stat & MSCC_FDMA_DCB_STAT_ABORT ||\n\t\t\t     stat & MSCC_FDMA_DCB_STAT_PD)) {\n\t\t\tdev_err_ratelimited(ocelot->dev,\n\t\t\t\t\t    \"DCB aborted or pruned\\n\");\n\t\t\tdev_kfree_skb(skb);\n\t\t\tskb = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!(stat & MSCC_FDMA_DCB_STAT_EOF))\n\t\t\tcontinue;\n\n\t\tif (unlikely(!ocelot_fdma_receive_skb(ocelot, skb)))\n\t\t\tdev_kfree_skb(skb);\n\n\t\tskb = NULL;\n\t}\n\n\trx_ring->skb = skb;\n\n\tif (cleaned_cnt)\n\t\tocelot_fdma_alloc_rx_buffs(ocelot, cleaned_cnt);\n\n\treturn work_done;\n}\n\nstatic void ocelot_fdma_wakeup_netdev(struct ocelot *ocelot)\n{\n\tstruct ocelot_port_private *priv;\n\tstruct ocelot_port *ocelot_port;\n\tstruct net_device *dev;\n\tint port;\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tocelot_port = ocelot->ports[port];\n\t\tif (!ocelot_port)\n\t\t\tcontinue;\n\t\tpriv = container_of(ocelot_port, struct ocelot_port_private,\n\t\t\t\t    port);\n\t\tdev = priv->dev;\n\n\t\tif (unlikely(netif_queue_stopped(dev)))\n\t\t\tnetif_wake_queue(dev);\n\t}\n}\n\nstatic void ocelot_fdma_tx_cleanup(struct ocelot *ocelot, int budget)\n{\n\tstruct ocelot_fdma *fdma = ocelot->fdma;\n\tstruct ocelot_fdma_tx_ring *tx_ring;\n\tstruct ocelot_fdma_tx_buf *buf;\n\tunsigned int new_null_llp_idx;\n\tstruct ocelot_fdma_dcb *dcb;\n\tbool end_of_list = false;\n\tstruct sk_buff *skb;\n\tdma_addr_t dma;\n\tu32 dcb_llp;\n\tu16 ntc;\n\tint ret;\n\n\ttx_ring = &fdma->tx_ring;\n\n\t \n\twhile (!ocelot_fdma_tx_ring_empty(fdma)) {\n\t\tntc = tx_ring->next_to_clean;\n\t\tdcb = &tx_ring->dcbs[ntc];\n\t\tif (!(dcb->stat & MSCC_FDMA_DCB_STAT_PD))\n\t\t\tbreak;\n\n\t\tbuf = &tx_ring->bufs[ntc];\n\t\tskb = buf->skb;\n\t\tdma_unmap_single(ocelot->dev, dma_unmap_addr(buf, dma_addr),\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\tnapi_consume_skb(skb, budget);\n\t\tdcb_llp = dcb->llp;\n\n\t\t \n\t\ttx_ring->next_to_clean = ocelot_fdma_idx_next(ntc,\n\t\t\t\t\t\t\t      OCELOT_FDMA_TX_RING_SIZE);\n\n\t\t \n\t\tif (dcb_llp == 0) {\n\t\t\tend_of_list = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (ocelot_fdma_tx_ring_free(fdma))\n\t\tocelot_fdma_wakeup_netdev(ocelot);\n\n\t \n\tif (!end_of_list || ocelot_fdma_tx_ring_empty(fdma))\n\t\treturn;\n\n\tret = ocelot_fdma_wait_chan_safe(ocelot, MSCC_FDMA_INJ_CHAN);\n\tif (ret) {\n\t\tdev_warn(ocelot->dev,\n\t\t\t \"Failed to wait for TX channel to stop\\n\");\n\t\treturn;\n\t}\n\n\t \n\tnew_null_llp_idx = ocelot_fdma_idx_prev(tx_ring->next_to_use,\n\t\t\t\t\t\tOCELOT_FDMA_TX_RING_SIZE);\n\tdcb = &tx_ring->dcbs[new_null_llp_idx];\n\tdcb->llp = 0;\n\n\tdma = ocelot_fdma_idx_dma(tx_ring->dcbs_dma, tx_ring->next_to_clean);\n\tocelot_fdma_activate_chan(ocelot, dma, MSCC_FDMA_INJ_CHAN);\n}\n\nstatic int ocelot_fdma_napi_poll(struct napi_struct *napi, int budget)\n{\n\tstruct ocelot_fdma *fdma = container_of(napi, struct ocelot_fdma, napi);\n\tstruct ocelot *ocelot = fdma->ocelot;\n\tint work_done = 0;\n\tbool rx_stopped;\n\n\tocelot_fdma_tx_cleanup(ocelot, budget);\n\n\trx_stopped = ocelot_fdma_check_stop_rx(ocelot);\n\n\twork_done = ocelot_fdma_rx_get(ocelot, budget);\n\n\tif (rx_stopped)\n\t\tocelot_fdma_rx_restart(ocelot);\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(&fdma->napi, work_done);\n\t\tocelot_fdma_writel(ocelot, MSCC_FDMA_INTR_ENA,\n\t\t\t\t   BIT(MSCC_FDMA_INJ_CHAN) |\n\t\t\t\t   BIT(MSCC_FDMA_XTR_CHAN));\n\t}\n\n\treturn work_done;\n}\n\nstatic irqreturn_t ocelot_fdma_interrupt(int irq, void *dev_id)\n{\n\tu32 ident, llp, frm, err, err_code;\n\tstruct ocelot *ocelot = dev_id;\n\n\tident = ocelot_fdma_readl(ocelot, MSCC_FDMA_INTR_IDENT);\n\tfrm = ocelot_fdma_readl(ocelot, MSCC_FDMA_INTR_FRM);\n\tllp = ocelot_fdma_readl(ocelot, MSCC_FDMA_INTR_LLP);\n\n\tocelot_fdma_writel(ocelot, MSCC_FDMA_INTR_LLP, llp & ident);\n\tocelot_fdma_writel(ocelot, MSCC_FDMA_INTR_FRM, frm & ident);\n\tif (frm || llp) {\n\t\tocelot_fdma_writel(ocelot, MSCC_FDMA_INTR_ENA, 0);\n\t\tnapi_schedule(&ocelot->fdma->napi);\n\t}\n\n\terr = ocelot_fdma_readl(ocelot, MSCC_FDMA_EVT_ERR);\n\tif (unlikely(err)) {\n\t\terr_code = ocelot_fdma_readl(ocelot, MSCC_FDMA_EVT_ERR_CODE);\n\t\tdev_err_ratelimited(ocelot->dev,\n\t\t\t\t    \"Error ! chans mask: %#x, code: %#x\\n\",\n\t\t\t\t    err, err_code);\n\n\t\tocelot_fdma_writel(ocelot, MSCC_FDMA_EVT_ERR, err);\n\t\tocelot_fdma_writel(ocelot, MSCC_FDMA_EVT_ERR_CODE, err_code);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ocelot_fdma_send_skb(struct ocelot *ocelot,\n\t\t\t\t struct ocelot_fdma *fdma, struct sk_buff *skb)\n{\n\tstruct ocelot_fdma_tx_ring *tx_ring = &fdma->tx_ring;\n\tstruct ocelot_fdma_tx_buf *tx_buf;\n\tstruct ocelot_fdma_dcb *dcb;\n\tdma_addr_t dma;\n\tu16 next_idx;\n\n\tdcb = &tx_ring->dcbs[tx_ring->next_to_use];\n\ttx_buf = &tx_ring->bufs[tx_ring->next_to_use];\n\tif (!ocelot_fdma_tx_dcb_set_skb(ocelot, tx_buf, dcb, skb)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\tnext_idx = ocelot_fdma_idx_next(tx_ring->next_to_use,\n\t\t\t\t\tOCELOT_FDMA_TX_RING_SIZE);\n\tskb_tx_timestamp(skb);\n\n\t \n\tif (ocelot_fdma_tx_ring_empty(fdma)) {\n\t\tdma = ocelot_fdma_idx_dma(tx_ring->dcbs_dma,\n\t\t\t\t\t  tx_ring->next_to_use);\n\t\tocelot_fdma_activate_chan(ocelot, dma, MSCC_FDMA_INJ_CHAN);\n\t} else {\n\t\t \n\t\tdcb->llp = ocelot_fdma_idx_dma(tx_ring->dcbs_dma, next_idx);\n\t}\n\n\ttx_ring->next_to_use = next_idx;\n}\n\nstatic int ocelot_fdma_prepare_skb(struct ocelot *ocelot, int port, u32 rew_op,\n\t\t\t\t   struct sk_buff *skb, struct net_device *dev)\n{\n\tint needed_headroom = max_t(int, OCELOT_TAG_LEN - skb_headroom(skb), 0);\n\tint needed_tailroom = max_t(int, ETH_FCS_LEN - skb_tailroom(skb), 0);\n\tvoid *ifh;\n\tint err;\n\n\tif (unlikely(needed_headroom || needed_tailroom ||\n\t\t     skb_header_cloned(skb))) {\n\t\terr = pskb_expand_head(skb, needed_headroom, needed_tailroom,\n\t\t\t\t       GFP_ATOMIC);\n\t\tif (unlikely(err)) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\terr = skb_linearize(skb);\n\tif (err) {\n\t\tnet_err_ratelimited(\"%s: skb_linearize error (%d)!\\n\",\n\t\t\t\t    dev->name, err);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn 1;\n\t}\n\n\tifh = skb_push(skb, OCELOT_TAG_LEN);\n\tskb_put(skb, ETH_FCS_LEN);\n\tmemset(ifh, 0, OCELOT_TAG_LEN);\n\tocelot_ifh_port_set(ifh, port, rew_op, skb_vlan_tag_get(skb));\n\n\treturn 0;\n}\n\nint ocelot_fdma_inject_frame(struct ocelot *ocelot, int port, u32 rew_op,\n\t\t\t     struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ocelot_fdma *fdma = ocelot->fdma;\n\tint ret = NETDEV_TX_OK;\n\n\tspin_lock(&fdma->tx_ring.xmit_lock);\n\n\tif (ocelot_fdma_tx_ring_free(fdma) == 0) {\n\t\tnetif_stop_queue(dev);\n\t\tret = NETDEV_TX_BUSY;\n\t\tgoto out;\n\t}\n\n\tif (ocelot_fdma_prepare_skb(ocelot, port, rew_op, skb, dev))\n\t\tgoto out;\n\n\tocelot_fdma_send_skb(ocelot, fdma, skb);\n\nout:\n\tspin_unlock(&fdma->tx_ring.xmit_lock);\n\n\treturn ret;\n}\n\nstatic void ocelot_fdma_free_rx_ring(struct ocelot *ocelot)\n{\n\tstruct ocelot_fdma *fdma = ocelot->fdma;\n\tstruct ocelot_fdma_rx_ring *rx_ring;\n\tstruct ocelot_fdma_rx_buf *rxb;\n\tu16 idx;\n\n\trx_ring = &fdma->rx_ring;\n\tidx = rx_ring->next_to_clean;\n\n\t \n\twhile (idx != rx_ring->next_to_use) {\n\t\trxb = &rx_ring->bufs[idx];\n\t\tdma_unmap_page(ocelot->dev, rxb->dma_addr, PAGE_SIZE,\n\t\t\t       DMA_FROM_DEVICE);\n\t\t__free_page(rxb->page);\n\t\tidx = ocelot_fdma_idx_next(idx, OCELOT_FDMA_RX_RING_SIZE);\n\t}\n\n\tif (fdma->rx_ring.skb)\n\t\tdev_kfree_skb_any(fdma->rx_ring.skb);\n}\n\nstatic void ocelot_fdma_free_tx_ring(struct ocelot *ocelot)\n{\n\tstruct ocelot_fdma *fdma = ocelot->fdma;\n\tstruct ocelot_fdma_tx_ring *tx_ring;\n\tstruct ocelot_fdma_tx_buf *txb;\n\tstruct sk_buff *skb;\n\tu16 idx;\n\n\ttx_ring = &fdma->tx_ring;\n\tidx = tx_ring->next_to_clean;\n\n\twhile (idx != tx_ring->next_to_use) {\n\t\ttxb = &tx_ring->bufs[idx];\n\t\tskb = txb->skb;\n\t\tdma_unmap_single(ocelot->dev, dma_unmap_addr(txb, dma_addr),\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t\tidx = ocelot_fdma_idx_next(idx, OCELOT_FDMA_TX_RING_SIZE);\n\t}\n}\n\nstatic int ocelot_fdma_rings_alloc(struct ocelot *ocelot)\n{\n\tstruct ocelot_fdma *fdma = ocelot->fdma;\n\tstruct ocelot_fdma_dcb *dcbs;\n\tunsigned int adjust;\n\tdma_addr_t dcbs_dma;\n\tint ret;\n\n\t \n\tfdma->dcbs_base = dmam_alloc_coherent(ocelot->dev,\n\t\t\t\t\t      OCELOT_DCBS_HW_ALLOC_SIZE,\n\t\t\t\t\t      &fdma->dcbs_dma_base, GFP_KERNEL);\n\tif (!fdma->dcbs_base)\n\t\treturn -ENOMEM;\n\n\t \n\tdcbs = fdma->dcbs_base;\n\tdcbs_dma = fdma->dcbs_dma_base;\n\tif (!IS_ALIGNED(dcbs_dma, 4)) {\n\t\tadjust = dcbs_dma & 0x3;\n\t\tdcbs_dma = ALIGN(dcbs_dma, 4);\n\t\tdcbs = (void *)dcbs + adjust;\n\t}\n\n\t \n\tfdma->tx_ring.dcbs = dcbs;\n\tfdma->tx_ring.dcbs_dma = dcbs_dma;\n\tspin_lock_init(&fdma->tx_ring.xmit_lock);\n\n\t \n\tfdma->rx_ring.dcbs = dcbs + OCELOT_FDMA_TX_RING_SIZE;\n\tfdma->rx_ring.dcbs_dma = dcbs_dma + OCELOT_FDMA_TX_DCB_SIZE;\n\tret = ocelot_fdma_alloc_rx_buffs(ocelot,\n\t\t\t\t\t ocelot_fdma_tx_ring_free(fdma));\n\tif (ret) {\n\t\tocelot_fdma_free_rx_ring(ocelot);\n\t\treturn ret;\n\t}\n\n\t \n\tocelot_fdma_rx_set_llp(&fdma->rx_ring);\n\n\treturn 0;\n}\n\nvoid ocelot_fdma_netdev_init(struct ocelot *ocelot, struct net_device *dev)\n{\n\tstruct ocelot_fdma *fdma = ocelot->fdma;\n\n\tdev->needed_headroom = OCELOT_TAG_LEN;\n\tdev->needed_tailroom = ETH_FCS_LEN;\n\n\tif (fdma->ndev)\n\t\treturn;\n\n\tfdma->ndev = dev;\n\tnetif_napi_add_weight(dev, &fdma->napi, ocelot_fdma_napi_poll,\n\t\t\t      OCELOT_FDMA_WEIGHT);\n}\n\nvoid ocelot_fdma_netdev_deinit(struct ocelot *ocelot, struct net_device *dev)\n{\n\tstruct ocelot_fdma *fdma = ocelot->fdma;\n\n\tif (fdma->ndev == dev) {\n\t\tnetif_napi_del(&fdma->napi);\n\t\tfdma->ndev = NULL;\n\t}\n}\n\nvoid ocelot_fdma_init(struct platform_device *pdev, struct ocelot *ocelot)\n{\n\tstruct device *dev = ocelot->dev;\n\tstruct ocelot_fdma *fdma;\n\tint ret;\n\n\tfdma = devm_kzalloc(dev, sizeof(*fdma), GFP_KERNEL);\n\tif (!fdma)\n\t\treturn;\n\n\tocelot->fdma = fdma;\n\tocelot->dev->coherent_dma_mask = DMA_BIT_MASK(32);\n\n\tocelot_fdma_writel(ocelot, MSCC_FDMA_INTR_ENA, 0);\n\n\tfdma->ocelot = ocelot;\n\tfdma->irq = platform_get_irq_byname(pdev, \"fdma\");\n\tret = devm_request_irq(dev, fdma->irq, ocelot_fdma_interrupt, 0,\n\t\t\t       dev_name(dev), ocelot);\n\tif (ret)\n\t\tgoto err_free_fdma;\n\n\tret = ocelot_fdma_rings_alloc(ocelot);\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\tstatic_branch_enable(&ocelot_fdma_enabled);\n\n\treturn;\n\nerr_free_irq:\n\tdevm_free_irq(dev, fdma->irq, fdma);\nerr_free_fdma:\n\tdevm_kfree(dev, fdma);\n\n\tocelot->fdma = NULL;\n}\n\nvoid ocelot_fdma_start(struct ocelot *ocelot)\n{\n\tstruct ocelot_fdma *fdma = ocelot->fdma;\n\n\t \n\tocelot_write_rix(ocelot, QS_INJ_GRP_CFG_MODE(2), QS_INJ_GRP_CFG, 0);\n\tocelot_write_rix(ocelot, QS_INJ_CTRL_GAP_SIZE(0), QS_INJ_CTRL, 0);\n\n\tocelot_write_rix(ocelot, QS_XTR_GRP_CFG_MODE(2), QS_XTR_GRP_CFG, 0);\n\n\tocelot_fdma_writel(ocelot, MSCC_FDMA_INTR_LLP, 0xffffffff);\n\tocelot_fdma_writel(ocelot, MSCC_FDMA_INTR_FRM, 0xffffffff);\n\n\tocelot_fdma_writel(ocelot, MSCC_FDMA_INTR_LLP_ENA,\n\t\t\t   BIT(MSCC_FDMA_INJ_CHAN) | BIT(MSCC_FDMA_XTR_CHAN));\n\tocelot_fdma_writel(ocelot, MSCC_FDMA_INTR_FRM_ENA,\n\t\t\t   BIT(MSCC_FDMA_XTR_CHAN));\n\tocelot_fdma_writel(ocelot, MSCC_FDMA_INTR_ENA,\n\t\t\t   BIT(MSCC_FDMA_INJ_CHAN) | BIT(MSCC_FDMA_XTR_CHAN));\n\n\tnapi_enable(&fdma->napi);\n\n\tocelot_fdma_activate_chan(ocelot, ocelot->fdma->rx_ring.dcbs_dma,\n\t\t\t\t  MSCC_FDMA_XTR_CHAN);\n}\n\nvoid ocelot_fdma_deinit(struct ocelot *ocelot)\n{\n\tstruct ocelot_fdma *fdma = ocelot->fdma;\n\n\tocelot_fdma_writel(ocelot, MSCC_FDMA_INTR_ENA, 0);\n\tocelot_fdma_writel(ocelot, MSCC_FDMA_CH_FORCEDIS,\n\t\t\t   BIT(MSCC_FDMA_XTR_CHAN));\n\tocelot_fdma_writel(ocelot, MSCC_FDMA_CH_FORCEDIS,\n\t\t\t   BIT(MSCC_FDMA_INJ_CHAN));\n\tnapi_synchronize(&fdma->napi);\n\tnapi_disable(&fdma->napi);\n\n\tocelot_fdma_free_rx_ring(ocelot);\n\tocelot_fdma_free_tx_ring(ocelot);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}