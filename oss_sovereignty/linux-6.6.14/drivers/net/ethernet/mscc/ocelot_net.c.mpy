{
  "module_name": "ocelot_net.c",
  "hash_id": "467dd4b7115cce27fb0acb068add341dfbc811148f79936f3855e99d329cbe9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mscc/ocelot_net.c",
  "human_readable_source": "\n \n\n#include <linux/dsa/ocelot.h>\n#include <linux/if_bridge.h>\n#include <linux/of_net.h>\n#include <linux/phy/phy.h>\n#include <net/pkt_cls.h>\n#include \"ocelot.h\"\n#include \"ocelot_police.h\"\n#include \"ocelot_vcap.h\"\n#include \"ocelot_fdma.h\"\n\n#define OCELOT_MAC_QUIRKS\tOCELOT_QUIRK_QSGMII_PORTS_MUST_BE_UP\n\nstruct ocelot_dump_ctx {\n\tstruct net_device *dev;\n\tstruct sk_buff *skb;\n\tstruct netlink_callback *cb;\n\tint idx;\n};\n\nstatic bool ocelot_netdevice_dev_check(const struct net_device *dev);\n\nstatic struct ocelot *devlink_port_to_ocelot(struct devlink_port *dlp)\n{\n\treturn devlink_priv(dlp->devlink);\n}\n\nstatic int devlink_port_to_port(struct devlink_port *dlp)\n{\n\tstruct ocelot *ocelot = devlink_port_to_ocelot(dlp);\n\n\treturn dlp - ocelot->devlink_ports;\n}\n\nstatic int ocelot_devlink_sb_pool_get(struct devlink *dl,\n\t\t\t\t      unsigned int sb_index, u16 pool_index,\n\t\t\t\t      struct devlink_sb_pool_info *pool_info)\n{\n\tstruct ocelot *ocelot = devlink_priv(dl);\n\n\treturn ocelot_sb_pool_get(ocelot, sb_index, pool_index, pool_info);\n}\n\nstatic int ocelot_devlink_sb_pool_set(struct devlink *dl, unsigned int sb_index,\n\t\t\t\t      u16 pool_index, u32 size,\n\t\t\t\t      enum devlink_sb_threshold_type threshold_type,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = devlink_priv(dl);\n\n\treturn ocelot_sb_pool_set(ocelot, sb_index, pool_index, size,\n\t\t\t\t  threshold_type, extack);\n}\n\nstatic int ocelot_devlink_sb_port_pool_get(struct devlink_port *dlp,\n\t\t\t\t\t   unsigned int sb_index, u16 pool_index,\n\t\t\t\t\t   u32 *p_threshold)\n{\n\tstruct ocelot *ocelot = devlink_port_to_ocelot(dlp);\n\tint port = devlink_port_to_port(dlp);\n\n\treturn ocelot_sb_port_pool_get(ocelot, port, sb_index, pool_index,\n\t\t\t\t       p_threshold);\n}\n\nstatic int ocelot_devlink_sb_port_pool_set(struct devlink_port *dlp,\n\t\t\t\t\t   unsigned int sb_index, u16 pool_index,\n\t\t\t\t\t   u32 threshold,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = devlink_port_to_ocelot(dlp);\n\tint port = devlink_port_to_port(dlp);\n\n\treturn ocelot_sb_port_pool_set(ocelot, port, sb_index, pool_index,\n\t\t\t\t       threshold, extack);\n}\n\nstatic int\nocelot_devlink_sb_tc_pool_bind_get(struct devlink_port *dlp,\n\t\t\t\t   unsigned int sb_index, u16 tc_index,\n\t\t\t\t   enum devlink_sb_pool_type pool_type,\n\t\t\t\t   u16 *p_pool_index, u32 *p_threshold)\n{\n\tstruct ocelot *ocelot = devlink_port_to_ocelot(dlp);\n\tint port = devlink_port_to_port(dlp);\n\n\treturn ocelot_sb_tc_pool_bind_get(ocelot, port, sb_index, tc_index,\n\t\t\t\t\t  pool_type, p_pool_index,\n\t\t\t\t\t  p_threshold);\n}\n\nstatic int\nocelot_devlink_sb_tc_pool_bind_set(struct devlink_port *dlp,\n\t\t\t\t   unsigned int sb_index, u16 tc_index,\n\t\t\t\t   enum devlink_sb_pool_type pool_type,\n\t\t\t\t   u16 pool_index, u32 threshold,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = devlink_port_to_ocelot(dlp);\n\tint port = devlink_port_to_port(dlp);\n\n\treturn ocelot_sb_tc_pool_bind_set(ocelot, port, sb_index, tc_index,\n\t\t\t\t\t  pool_type, pool_index, threshold,\n\t\t\t\t\t  extack);\n}\n\nstatic int ocelot_devlink_sb_occ_snapshot(struct devlink *dl,\n\t\t\t\t\t  unsigned int sb_index)\n{\n\tstruct ocelot *ocelot = devlink_priv(dl);\n\n\treturn ocelot_sb_occ_snapshot(ocelot, sb_index);\n}\n\nstatic int ocelot_devlink_sb_occ_max_clear(struct devlink *dl,\n\t\t\t\t\t   unsigned int sb_index)\n{\n\tstruct ocelot *ocelot = devlink_priv(dl);\n\n\treturn ocelot_sb_occ_max_clear(ocelot, sb_index);\n}\n\nstatic int ocelot_devlink_sb_occ_port_pool_get(struct devlink_port *dlp,\n\t\t\t\t\t       unsigned int sb_index,\n\t\t\t\t\t       u16 pool_index, u32 *p_cur,\n\t\t\t\t\t       u32 *p_max)\n{\n\tstruct ocelot *ocelot = devlink_port_to_ocelot(dlp);\n\tint port = devlink_port_to_port(dlp);\n\n\treturn ocelot_sb_occ_port_pool_get(ocelot, port, sb_index, pool_index,\n\t\t\t\t\t   p_cur, p_max);\n}\n\nstatic int\nocelot_devlink_sb_occ_tc_port_bind_get(struct devlink_port *dlp,\n\t\t\t\t       unsigned int sb_index, u16 tc_index,\n\t\t\t\t       enum devlink_sb_pool_type pool_type,\n\t\t\t\t       u32 *p_cur, u32 *p_max)\n{\n\tstruct ocelot *ocelot = devlink_port_to_ocelot(dlp);\n\tint port = devlink_port_to_port(dlp);\n\n\treturn ocelot_sb_occ_tc_port_bind_get(ocelot, port, sb_index,\n\t\t\t\t\t      tc_index, pool_type,\n\t\t\t\t\t      p_cur, p_max);\n}\n\nconst struct devlink_ops ocelot_devlink_ops = {\n\t.sb_pool_get\t\t\t= ocelot_devlink_sb_pool_get,\n\t.sb_pool_set\t\t\t= ocelot_devlink_sb_pool_set,\n\t.sb_port_pool_get\t\t= ocelot_devlink_sb_port_pool_get,\n\t.sb_port_pool_set\t\t= ocelot_devlink_sb_port_pool_set,\n\t.sb_tc_pool_bind_get\t\t= ocelot_devlink_sb_tc_pool_bind_get,\n\t.sb_tc_pool_bind_set\t\t= ocelot_devlink_sb_tc_pool_bind_set,\n\t.sb_occ_snapshot\t\t= ocelot_devlink_sb_occ_snapshot,\n\t.sb_occ_max_clear\t\t= ocelot_devlink_sb_occ_max_clear,\n\t.sb_occ_port_pool_get\t\t= ocelot_devlink_sb_occ_port_pool_get,\n\t.sb_occ_tc_port_bind_get\t= ocelot_devlink_sb_occ_tc_port_bind_get,\n};\n\nint ocelot_port_devlink_init(struct ocelot *ocelot, int port,\n\t\t\t     enum devlink_port_flavour flavour)\n{\n\tstruct devlink_port *dlp = &ocelot->devlink_ports[port];\n\tint id_len = sizeof(ocelot->base_mac);\n\tstruct devlink *dl = ocelot->devlink;\n\tstruct devlink_port_attrs attrs = {};\n\n\tmemset(dlp, 0, sizeof(*dlp));\n\tmemcpy(attrs.switch_id.id, &ocelot->base_mac, id_len);\n\tattrs.switch_id.id_len = id_len;\n\tattrs.phys.port_number = port;\n\tattrs.flavour = flavour;\n\n\tdevlink_port_attrs_set(dlp, &attrs);\n\n\treturn devlink_port_register(dl, dlp, port);\n}\n\nvoid ocelot_port_devlink_teardown(struct ocelot *ocelot, int port)\n{\n\tstruct devlink_port *dlp = &ocelot->devlink_ports[port];\n\n\tdevlink_port_unregister(dlp);\n}\n\nint ocelot_setup_tc_cls_flower(struct ocelot_port_private *priv,\n\t\t\t       struct flow_cls_offload *f,\n\t\t\t       bool ingress)\n{\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\n\tif (!ingress)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (f->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn ocelot_cls_flower_replace(ocelot, port, f, ingress);\n\tcase FLOW_CLS_DESTROY:\n\t\treturn ocelot_cls_flower_destroy(ocelot, port, f, ingress);\n\tcase FLOW_CLS_STATS:\n\t\treturn ocelot_cls_flower_stats(ocelot, port, f, ingress);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ocelot_setup_tc_cls_matchall_police(struct ocelot_port_private *priv,\n\t\t\t\t\t       struct tc_cls_matchall_offload *f,\n\t\t\t\t\t       bool ingress,\n\t\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct flow_action_entry *action = &f->rule->action.entries[0];\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tstruct ocelot_policer pol = { 0 };\n\tint port = priv->port.index;\n\tint err;\n\n\tif (!ingress) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Only ingress is supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (priv->tc.police_id && priv->tc.police_id != f->cookie) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Only one policer per port is supported\");\n\t\treturn -EEXIST;\n\t}\n\n\terr = ocelot_policer_validate(&f->rule->action, action, extack);\n\tif (err)\n\t\treturn err;\n\n\tpol.rate = (u32)div_u64(action->police.rate_bytes_ps, 1000) * 8;\n\tpol.burst = action->police.burst;\n\n\terr = ocelot_port_policer_add(ocelot, port, &pol);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Could not add policer\");\n\t\treturn err;\n\t}\n\n\tpriv->tc.police_id = f->cookie;\n\tpriv->tc.offload_cnt++;\n\n\treturn 0;\n}\n\nstatic int ocelot_setup_tc_cls_matchall_mirred(struct ocelot_port_private *priv,\n\t\t\t\t\t       struct tc_cls_matchall_offload *f,\n\t\t\t\t\t       bool ingress,\n\t\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct flow_action *action = &f->rule->action;\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tstruct ocelot_port_private *other_priv;\n\tconst struct flow_action_entry *a;\n\tint err;\n\n\tif (f->common.protocol != htons(ETH_P_ALL))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!flow_action_basic_hw_stats_check(action, extack))\n\t\treturn -EOPNOTSUPP;\n\n\ta = &action->entries[0];\n\tif (!a->dev)\n\t\treturn -EINVAL;\n\n\tif (!ocelot_netdevice_dev_check(a->dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Destination not an ocelot port\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tother_priv = netdev_priv(a->dev);\n\n\terr = ocelot_port_mirror_add(ocelot, priv->port.index,\n\t\t\t\t     other_priv->port.index, ingress, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (ingress)\n\t\tpriv->tc.ingress_mirred_id = f->cookie;\n\telse\n\t\tpriv->tc.egress_mirred_id = f->cookie;\n\tpriv->tc.offload_cnt++;\n\n\treturn 0;\n}\n\nstatic int ocelot_del_tc_cls_matchall_police(struct ocelot_port_private *priv,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\tint err;\n\n\terr = ocelot_port_policer_del(ocelot, port);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Could not delete policer\");\n\t\treturn err;\n\t}\n\n\tpriv->tc.police_id = 0;\n\tpriv->tc.offload_cnt--;\n\n\treturn 0;\n}\n\nstatic int ocelot_del_tc_cls_matchall_mirred(struct ocelot_port_private *priv,\n\t\t\t\t\t     bool ingress,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\n\tocelot_port_mirror_del(ocelot, port, ingress);\n\n\tif (ingress)\n\t\tpriv->tc.ingress_mirred_id = 0;\n\telse\n\t\tpriv->tc.egress_mirred_id = 0;\n\tpriv->tc.offload_cnt--;\n\n\treturn 0;\n}\n\nstatic int ocelot_setup_tc_cls_matchall(struct ocelot_port_private *priv,\n\t\t\t\t\tstruct tc_cls_matchall_offload *f,\n\t\t\t\t\tbool ingress)\n{\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct flow_action_entry *action;\n\n\tswitch (f->command) {\n\tcase TC_CLSMATCHALL_REPLACE:\n\t\tif (!flow_offload_has_one_action(&f->rule->action)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Only one action is supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (priv->tc.block_shared) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Matchall offloads not supported on shared blocks\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\taction = &f->rule->action.entries[0];\n\n\t\tswitch (action->id) {\n\t\tcase FLOW_ACTION_POLICE:\n\t\t\treturn ocelot_setup_tc_cls_matchall_police(priv, f,\n\t\t\t\t\t\t\t\t   ingress,\n\t\t\t\t\t\t\t\t   extack);\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_MIRRED:\n\t\t\treturn ocelot_setup_tc_cls_matchall_mirred(priv, f,\n\t\t\t\t\t\t\t\t   ingress,\n\t\t\t\t\t\t\t\t   extack);\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported action\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tbreak;\n\tcase TC_CLSMATCHALL_DESTROY:\n\t\taction = &f->rule->action.entries[0];\n\n\t\tif (f->cookie == priv->tc.police_id)\n\t\t\treturn ocelot_del_tc_cls_matchall_police(priv, extack);\n\t\telse if (f->cookie == priv->tc.ingress_mirred_id ||\n\t\t\t f->cookie == priv->tc.egress_mirred_id)\n\t\t\treturn ocelot_del_tc_cls_matchall_mirred(priv, ingress,\n\t\t\t\t\t\t\t\t extack);\n\t\telse\n\t\t\treturn -ENOENT;\n\n\t\tbreak;\n\tcase TC_CLSMATCHALL_STATS:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ocelot_setup_tc_block_cb(enum tc_setup_type type,\n\t\t\t\t    void *type_data,\n\t\t\t\t    void *cb_priv, bool ingress)\n{\n\tstruct ocelot_port_private *priv = cb_priv;\n\n\tif (!tc_cls_can_offload_and_chain0(priv->dev, type_data))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSMATCHALL:\n\t\treturn ocelot_setup_tc_cls_matchall(priv, type_data, ingress);\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn ocelot_setup_tc_cls_flower(priv, type_data, ingress);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ocelot_setup_tc_block_cb_ig(enum tc_setup_type type,\n\t\t\t\t       void *type_data,\n\t\t\t\t       void *cb_priv)\n{\n\treturn ocelot_setup_tc_block_cb(type, type_data,\n\t\t\t\t\tcb_priv, true);\n}\n\nstatic int ocelot_setup_tc_block_cb_eg(enum tc_setup_type type,\n\t\t\t\t       void *type_data,\n\t\t\t\t       void *cb_priv)\n{\n\treturn ocelot_setup_tc_block_cb(type, type_data,\n\t\t\t\t\tcb_priv, false);\n}\n\nstatic LIST_HEAD(ocelot_block_cb_list);\n\nstatic int ocelot_setup_tc_block(struct ocelot_port_private *priv,\n\t\t\t\t struct flow_block_offload *f)\n{\n\tstruct flow_block_cb *block_cb;\n\tflow_setup_cb_t *cb;\n\n\tif (f->binder_type == FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS) {\n\t\tcb = ocelot_setup_tc_block_cb_ig;\n\t\tpriv->tc.block_shared = f->block_shared;\n\t} else if (f->binder_type == FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS) {\n\t\tcb = ocelot_setup_tc_block_cb_eg;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tf->driver_block_list = &ocelot_block_cb_list;\n\n\tswitch (f->command) {\n\tcase FLOW_BLOCK_BIND:\n\t\tif (flow_block_cb_is_busy(cb, priv, &ocelot_block_cb_list))\n\t\t\treturn -EBUSY;\n\n\t\tblock_cb = flow_block_cb_alloc(cb, priv, priv, NULL);\n\t\tif (IS_ERR(block_cb))\n\t\t\treturn PTR_ERR(block_cb);\n\n\t\tflow_block_cb_add(block_cb, f);\n\t\tlist_add_tail(&block_cb->driver_list, f->driver_block_list);\n\t\treturn 0;\n\tcase FLOW_BLOCK_UNBIND:\n\t\tblock_cb = flow_block_cb_lookup(f->block, cb, priv);\n\t\tif (!block_cb)\n\t\t\treturn -ENOENT;\n\n\t\tflow_block_cb_remove(block_cb, f);\n\t\tlist_del(&block_cb->driver_list);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int ocelot_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t\t   void *type_data)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK:\n\t\treturn ocelot_setup_tc_block(priv, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int ocelot_vlan_vid_add(struct net_device *dev, u16 vid, bool pvid,\n\t\t\t       bool untagged)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tint port = priv->port.index;\n\tint ret;\n\n\tret = ocelot_vlan_add(ocelot, port, vid, pvid, untagged);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tocelot_mact_learn(ocelot, PGID_CPU, dev->dev_addr, vid,\n\t\t\t  ENTRYTYPE_LOCKED);\n\n\treturn 0;\n}\n\nstatic int ocelot_vlan_vid_del(struct net_device *dev, u16 vid)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\tint ret;\n\n\t \n\tif (vid == OCELOT_STANDALONE_PVID)\n\t\treturn 0;\n\n\tret = ocelot_vlan_del(ocelot, port, vid);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tocelot_mact_forget(ocelot, dev->dev_addr, vid);\n\n\treturn 0;\n}\n\nstatic int ocelot_port_open(struct net_device *dev)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\n\tphylink_start(priv->phylink);\n\n\treturn 0;\n}\n\nstatic int ocelot_port_stop(struct net_device *dev)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\n\tphylink_stop(priv->phylink);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t ocelot_port_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tint port = priv->port.index;\n\tu32 rew_op = 0;\n\n\tif (!static_branch_unlikely(&ocelot_fdma_enabled) &&\n\t    !ocelot_can_inject(ocelot, 0))\n\t\treturn NETDEV_TX_BUSY;\n\n\t \n\tif (ocelot->ptp && (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {\n\t\tstruct sk_buff *clone = NULL;\n\n\t\tif (ocelot_port_txtstamp_request(ocelot, port, skb, &clone)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\n\t\tif (clone)\n\t\t\tOCELOT_SKB_CB(skb)->clone = clone;\n\n\t\trew_op = ocelot_ptp_rew_op(skb);\n\t}\n\n\tif (static_branch_unlikely(&ocelot_fdma_enabled)) {\n\t\tocelot_fdma_inject_frame(ocelot, port, rew_op, skb, dev);\n\t} else {\n\t\tocelot_port_inject_frame(ocelot, port, 0, rew_op, skb);\n\n\t\tconsume_skb(skb);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nenum ocelot_action_type {\n\tOCELOT_MACT_LEARN,\n\tOCELOT_MACT_FORGET,\n};\n\nstruct ocelot_mact_work_ctx {\n\tstruct work_struct work;\n\tstruct ocelot *ocelot;\n\tenum ocelot_action_type type;\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\tunsigned char addr[ETH_ALEN];\n\t\t\tu16 vid;\n\t\t\tenum macaccess_entry_type entry_type;\n\t\t\tint pgid;\n\t\t} learn;\n\t\t \n\t\tstruct {\n\t\t\tunsigned char addr[ETH_ALEN];\n\t\t\tu16 vid;\n\t\t} forget;\n\t};\n};\n\n#define ocelot_work_to_ctx(x) \\\n\tcontainer_of((x), struct ocelot_mact_work_ctx, work)\n\nstatic void ocelot_mact_work(struct work_struct *work)\n{\n\tstruct ocelot_mact_work_ctx *w = ocelot_work_to_ctx(work);\n\tstruct ocelot *ocelot = w->ocelot;\n\n\tswitch (w->type) {\n\tcase OCELOT_MACT_LEARN:\n\t\tocelot_mact_learn(ocelot, w->learn.pgid, w->learn.addr,\n\t\t\t\t  w->learn.vid, w->learn.entry_type);\n\t\tbreak;\n\tcase OCELOT_MACT_FORGET:\n\t\tocelot_mact_forget(ocelot, w->forget.addr, w->forget.vid);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkfree(w);\n}\n\nstatic int ocelot_enqueue_mact_action(struct ocelot *ocelot,\n\t\t\t\t      const struct ocelot_mact_work_ctx *ctx)\n{\n\tstruct ocelot_mact_work_ctx *w = kmemdup(ctx, sizeof(*w), GFP_ATOMIC);\n\n\tif (!w)\n\t\treturn -ENOMEM;\n\n\tw->ocelot = ocelot;\n\tINIT_WORK(&w->work, ocelot_mact_work);\n\tqueue_work(ocelot->owq, &w->work);\n\n\treturn 0;\n}\n\nstatic int ocelot_mc_unsync(struct net_device *dev, const unsigned char *addr)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tstruct ocelot_mact_work_ctx w;\n\n\tether_addr_copy(w.forget.addr, addr);\n\tw.forget.vid = OCELOT_STANDALONE_PVID;\n\tw.type = OCELOT_MACT_FORGET;\n\n\treturn ocelot_enqueue_mact_action(ocelot, &w);\n}\n\nstatic int ocelot_mc_sync(struct net_device *dev, const unsigned char *addr)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tstruct ocelot_mact_work_ctx w;\n\n\tether_addr_copy(w.learn.addr, addr);\n\tw.learn.vid = OCELOT_STANDALONE_PVID;\n\tw.learn.pgid = PGID_CPU;\n\tw.learn.entry_type = ENTRYTYPE_LOCKED;\n\tw.type = OCELOT_MACT_LEARN;\n\n\treturn ocelot_enqueue_mact_action(ocelot, &w);\n}\n\nstatic void ocelot_set_rx_mode(struct net_device *dev)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tu32 val;\n\tint i;\n\n\t \n\tval = GENMASK(ocelot->num_phys_ports - 1, 0);\n\tfor_each_nonreserved_multicast_dest_pgid(ocelot, i)\n\t\tocelot_write_rix(ocelot, val, ANA_PGID_PGID, i);\n\n\t__dev_mc_sync(dev, ocelot_mc_sync, ocelot_mc_unsync);\n}\n\nstatic int ocelot_port_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tconst struct sockaddr *addr = p;\n\n\t \n\tocelot_mact_learn(ocelot, PGID_CPU, addr->sa_data,\n\t\t\t  OCELOT_STANDALONE_PVID, ENTRYTYPE_LOCKED);\n\t \n\tocelot_mact_forget(ocelot, dev->dev_addr, OCELOT_STANDALONE_PVID);\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\treturn 0;\n}\n\nstatic void ocelot_get_stats64(struct net_device *dev,\n\t\t\t       struct rtnl_link_stats64 *stats)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\n\treturn ocelot_port_get_stats64(ocelot, port, stats);\n}\n\nstatic int ocelot_port_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],\n\t\t\t       struct net_device *dev,\n\t\t\t       const unsigned char *addr,\n\t\t\t       u16 vid, u16 flags,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tint port = priv->port.index;\n\n\treturn ocelot_fdb_add(ocelot, port, addr, vid, ocelot_port->bridge);\n}\n\nstatic int ocelot_port_fdb_del(struct ndmsg *ndm, struct nlattr *tb[],\n\t\t\t       struct net_device *dev,\n\t\t\t       const unsigned char *addr, u16 vid,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tint port = priv->port.index;\n\n\treturn ocelot_fdb_del(ocelot, port, addr, vid, ocelot_port->bridge);\n}\n\nstatic int ocelot_port_fdb_do_dump(const unsigned char *addr, u16 vid,\n\t\t\t\t   bool is_static, void *data)\n{\n\tstruct ocelot_dump_ctx *dump = data;\n\tu32 portid = NETLINK_CB(dump->cb->skb).portid;\n\tu32 seq = dump->cb->nlh->nlmsg_seq;\n\tstruct nlmsghdr *nlh;\n\tstruct ndmsg *ndm;\n\n\tif (dump->idx < dump->cb->args[2])\n\t\tgoto skip;\n\n\tnlh = nlmsg_put(dump->skb, portid, seq, RTM_NEWNEIGH,\n\t\t\tsizeof(*ndm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tndm = nlmsg_data(nlh);\n\tndm->ndm_family  = AF_BRIDGE;\n\tndm->ndm_pad1    = 0;\n\tndm->ndm_pad2    = 0;\n\tndm->ndm_flags   = NTF_SELF;\n\tndm->ndm_type    = 0;\n\tndm->ndm_ifindex = dump->dev->ifindex;\n\tndm->ndm_state   = is_static ? NUD_NOARP : NUD_REACHABLE;\n\n\tif (nla_put(dump->skb, NDA_LLADDR, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\tif (vid && nla_put_u16(dump->skb, NDA_VLAN, vid))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(dump->skb, nlh);\n\nskip:\n\tdump->idx++;\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(dump->skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int ocelot_port_fdb_dump(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tstruct net_device *filter_dev, int *idx)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tstruct ocelot_dump_ctx dump = {\n\t\t.dev = dev,\n\t\t.skb = skb,\n\t\t.cb = cb,\n\t\t.idx = *idx,\n\t};\n\tint port = priv->port.index;\n\tint ret;\n\n\tret = ocelot_fdb_dump(ocelot, port, ocelot_port_fdb_do_dump, &dump);\n\n\t*idx = dump.idx;\n\n\treturn ret;\n}\n\nstatic int ocelot_vlan_rx_add_vid(struct net_device *dev, __be16 proto,\n\t\t\t\t  u16 vid)\n{\n\treturn ocelot_vlan_vid_add(dev, vid, false, false);\n}\n\nstatic int ocelot_vlan_rx_kill_vid(struct net_device *dev, __be16 proto,\n\t\t\t\t   u16 vid)\n{\n\treturn ocelot_vlan_vid_del(dev, vid);\n}\n\nstatic void ocelot_vlan_mode(struct ocelot *ocelot, int port,\n\t\t\t     netdev_features_t features)\n{\n\tu32 val;\n\n\t \n\tval = ocelot_read(ocelot, ANA_VLANMASK);\n\tif (features & NETIF_F_HW_VLAN_CTAG_FILTER)\n\t\tval |= BIT(port);\n\telse\n\t\tval &= ~BIT(port);\n\tocelot_write(ocelot, val, ANA_VLANMASK);\n}\n\nstatic int ocelot_set_features(struct net_device *dev,\n\t\t\t       netdev_features_t features)\n{\n\tnetdev_features_t changed = dev->features ^ features;\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\n\tif ((dev->features & NETIF_F_HW_TC) > (features & NETIF_F_HW_TC) &&\n\t    priv->tc.offload_cnt) {\n\t\tnetdev_err(dev,\n\t\t\t   \"Cannot disable HW TC offload while offloads active\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_FILTER)\n\t\tocelot_vlan_mode(ocelot, port, features);\n\n\treturn 0;\n}\n\nstatic int ocelot_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\n\t \n\tif (!phy_has_hwtstamp(dev->phydev) && ocelot->ptp) {\n\t\tswitch (cmd) {\n\t\tcase SIOCSHWTSTAMP:\n\t\t\treturn ocelot_hwstamp_set(ocelot, port, ifr);\n\t\tcase SIOCGHWTSTAMP:\n\t\t\treturn ocelot_hwstamp_get(ocelot, port, ifr);\n\t\t}\n\t}\n\n\treturn phy_mii_ioctl(dev->phydev, ifr, cmd);\n}\n\nstatic int ocelot_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\n\tocelot_port_set_maxlen(ocelot, priv->port.index, new_mtu);\n\tWRITE_ONCE(dev->mtu, new_mtu);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ocelot_port_netdev_ops = {\n\t.ndo_open\t\t\t= ocelot_port_open,\n\t.ndo_stop\t\t\t= ocelot_port_stop,\n\t.ndo_start_xmit\t\t\t= ocelot_port_xmit,\n\t.ndo_change_mtu\t\t\t= ocelot_change_mtu,\n\t.ndo_set_rx_mode\t\t= ocelot_set_rx_mode,\n\t.ndo_set_mac_address\t\t= ocelot_port_set_mac_address,\n\t.ndo_get_stats64\t\t= ocelot_get_stats64,\n\t.ndo_fdb_add\t\t\t= ocelot_port_fdb_add,\n\t.ndo_fdb_del\t\t\t= ocelot_port_fdb_del,\n\t.ndo_fdb_dump\t\t\t= ocelot_port_fdb_dump,\n\t.ndo_vlan_rx_add_vid\t\t= ocelot_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t\t= ocelot_vlan_rx_kill_vid,\n\t.ndo_set_features\t\t= ocelot_set_features,\n\t.ndo_setup_tc\t\t\t= ocelot_setup_tc,\n\t.ndo_eth_ioctl\t\t\t= ocelot_ioctl,\n};\n\nstruct net_device *ocelot_port_to_netdev(struct ocelot *ocelot, int port)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tstruct ocelot_port_private *priv;\n\n\tif (!ocelot_port)\n\t\treturn NULL;\n\n\tpriv = container_of(ocelot_port, struct ocelot_port_private, port);\n\n\treturn priv->dev;\n}\n\n \nstatic bool ocelot_netdevice_dev_check(const struct net_device *dev)\n{\n\treturn dev->netdev_ops == &ocelot_port_netdev_ops;\n}\n\nint ocelot_netdev_to_port(struct net_device *dev)\n{\n\tstruct ocelot_port_private *priv;\n\n\tif (!dev || !ocelot_netdevice_dev_check(dev))\n\t\treturn -EINVAL;\n\n\tpriv = netdev_priv(dev);\n\n\treturn priv->port.index;\n}\n\nstatic void ocelot_port_get_strings(struct net_device *netdev, u32 sset,\n\t\t\t\t    u8 *data)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(netdev);\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\n\tocelot_get_strings(ocelot, port, sset, data);\n}\n\nstatic void ocelot_port_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t\t  struct ethtool_stats *stats,\n\t\t\t\t\t  u64 *data)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\n\tocelot_get_ethtool_stats(ocelot, port, data);\n}\n\nstatic int ocelot_port_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\n\treturn ocelot_get_sset_count(ocelot, port, sset);\n}\n\nstatic int ocelot_port_get_ts_info(struct net_device *dev,\n\t\t\t\t   struct ethtool_ts_info *info)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\n\tif (!ocelot->ptp)\n\t\treturn ethtool_op_get_ts_info(dev, info);\n\n\treturn ocelot_get_ts_info(ocelot, port, info);\n}\n\nstatic const struct ethtool_ops ocelot_ethtool_ops = {\n\t.get_strings\t\t= ocelot_port_get_strings,\n\t.get_ethtool_stats\t= ocelot_port_get_ethtool_stats,\n\t.get_sset_count\t\t= ocelot_port_get_sset_count,\n\t.get_link_ksettings\t= phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= phy_ethtool_set_link_ksettings,\n\t.get_ts_info\t\t= ocelot_port_get_ts_info,\n};\n\nstatic void ocelot_port_attr_stp_state_set(struct ocelot *ocelot, int port,\n\t\t\t\t\t   u8 state)\n{\n\tocelot_bridge_stp_state_set(ocelot, port, state);\n}\n\nstatic void ocelot_port_attr_ageing_set(struct ocelot *ocelot, int port,\n\t\t\t\t\tunsigned long ageing_clock_t)\n{\n\tunsigned long ageing_jiffies = clock_t_to_jiffies(ageing_clock_t);\n\tu32 ageing_time = jiffies_to_msecs(ageing_jiffies);\n\n\tocelot_set_ageing_time(ocelot, ageing_time);\n}\n\nstatic void ocelot_port_attr_mc_set(struct ocelot *ocelot, int port, bool mc)\n{\n\tu32 cpu_fwd_mcast = ANA_PORT_CPU_FWD_CFG_CPU_IGMP_REDIR_ENA |\n\t\t\t    ANA_PORT_CPU_FWD_CFG_CPU_MLD_REDIR_ENA |\n\t\t\t    ANA_PORT_CPU_FWD_CFG_CPU_IPMC_CTRL_COPY_ENA;\n\tu32 val = 0;\n\n\tif (mc)\n\t\tval = cpu_fwd_mcast;\n\n\tocelot_rmw_gix(ocelot, val, cpu_fwd_mcast,\n\t\t       ANA_PORT_CPU_FWD_CFG, port);\n}\n\nstatic int ocelot_port_attr_set(struct net_device *dev, const void *ctx,\n\t\t\t\tconst struct switchdev_attr *attr,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\tint err = 0;\n\n\tif (ctx && ctx != priv)\n\t\treturn 0;\n\n\tswitch (attr->id) {\n\tcase SWITCHDEV_ATTR_ID_PORT_STP_STATE:\n\t\tocelot_port_attr_stp_state_set(ocelot, port, attr->u.stp_state);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME:\n\t\tocelot_port_attr_ageing_set(ocelot, port, attr->u.ageing_time);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING:\n\t\tocelot_port_vlan_filtering(ocelot, port, attr->u.vlan_filtering,\n\t\t\t\t\t   extack);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED:\n\t\tocelot_port_attr_mc_set(ocelot, port, !attr->u.mc_disabled);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS:\n\t\terr = ocelot_port_pre_bridge_flags(ocelot, port,\n\t\t\t\t\t\t   attr->u.brport_flags);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:\n\t\tocelot_port_bridge_flags(ocelot, port, attr->u.brport_flags);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int ocelot_vlan_vid_prepare(struct net_device *dev, u16 vid, bool pvid,\n\t\t\t\t   bool untagged, struct netlink_ext_ack *extack)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tint port = priv->port.index;\n\n\treturn ocelot_vlan_prepare(ocelot, port, vid, pvid, untagged, extack);\n}\n\nstatic int ocelot_port_obj_add_vlan(struct net_device *dev,\n\t\t\t\t    const struct switchdev_obj_port_vlan *vlan,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tbool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\tint ret;\n\n\tret = ocelot_vlan_vid_prepare(dev, vlan->vid, pvid, untagged, extack);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ocelot_vlan_vid_add(dev, vlan->vid, pvid, untagged);\n}\n\nstatic int ocelot_port_obj_add_mdb(struct net_device *dev,\n\t\t\t\t   const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tint port = priv->port.index;\n\n\treturn ocelot_port_mdb_add(ocelot, port, mdb, ocelot_port->bridge);\n}\n\nstatic int ocelot_port_obj_del_mdb(struct net_device *dev,\n\t\t\t\t   const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tint port = priv->port.index;\n\n\treturn ocelot_port_mdb_del(ocelot, port, mdb, ocelot_port->bridge);\n}\n\nstatic int ocelot_port_obj_mrp_add(struct net_device *dev,\n\t\t\t\t   const struct switchdev_obj_mrp *mrp)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tint port = priv->port.index;\n\n\treturn ocelot_mrp_add(ocelot, port, mrp);\n}\n\nstatic int ocelot_port_obj_mrp_del(struct net_device *dev,\n\t\t\t\t   const struct switchdev_obj_mrp *mrp)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tint port = priv->port.index;\n\n\treturn ocelot_mrp_del(ocelot, port, mrp);\n}\n\nstatic int\nocelot_port_obj_mrp_add_ring_role(struct net_device *dev,\n\t\t\t\t  const struct switchdev_obj_ring_role_mrp *mrp)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tint port = priv->port.index;\n\n\treturn ocelot_mrp_add_ring_role(ocelot, port, mrp);\n}\n\nstatic int\nocelot_port_obj_mrp_del_ring_role(struct net_device *dev,\n\t\t\t\t  const struct switchdev_obj_ring_role_mrp *mrp)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tint port = priv->port.index;\n\n\treturn ocelot_mrp_del_ring_role(ocelot, port, mrp);\n}\n\nstatic int ocelot_port_obj_add(struct net_device *dev, const void *ctx,\n\t\t\t       const struct switchdev_obj *obj,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tint ret = 0;\n\n\tif (ctx && ctx != priv)\n\t\treturn 0;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\tret = ocelot_port_obj_add_vlan(dev,\n\t\t\t\t\t       SWITCHDEV_OBJ_PORT_VLAN(obj),\n\t\t\t\t\t       extack);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\t\tret = ocelot_port_obj_add_mdb(dev, SWITCHDEV_OBJ_PORT_MDB(obj));\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_MRP:\n\t\tret = ocelot_port_obj_mrp_add(dev, SWITCHDEV_OBJ_MRP(obj));\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_RING_ROLE_MRP:\n\t\tret = ocelot_port_obj_mrp_add_ring_role(dev,\n\t\t\t\t\t\t\tSWITCHDEV_OBJ_RING_ROLE_MRP(obj));\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int ocelot_port_obj_del(struct net_device *dev, const void *ctx,\n\t\t\t       const struct switchdev_obj *obj)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tint ret = 0;\n\n\tif (ctx && ctx != priv)\n\t\treturn 0;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\tret = ocelot_vlan_vid_del(dev,\n\t\t\t\t\t  SWITCHDEV_OBJ_PORT_VLAN(obj)->vid);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\t\tret = ocelot_port_obj_del_mdb(dev, SWITCHDEV_OBJ_PORT_MDB(obj));\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_MRP:\n\t\tret = ocelot_port_obj_mrp_del(dev, SWITCHDEV_OBJ_MRP(obj));\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_RING_ROLE_MRP:\n\t\tret = ocelot_port_obj_mrp_del_ring_role(dev,\n\t\t\t\t\t\t\tSWITCHDEV_OBJ_RING_ROLE_MRP(obj));\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic void ocelot_inherit_brport_flags(struct ocelot *ocelot, int port,\n\t\t\t\t\tstruct net_device *brport_dev)\n{\n\tstruct switchdev_brport_flags flags = {0};\n\tint flag;\n\n\tflags.mask = BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD;\n\n\tfor_each_set_bit(flag, &flags.mask, 32)\n\t\tif (br_port_flag_is_set(brport_dev, BIT(flag)))\n\t\t\tflags.val |= BIT(flag);\n\n\tocelot_port_bridge_flags(ocelot, port, flags);\n}\n\nstatic void ocelot_clear_brport_flags(struct ocelot *ocelot, int port)\n{\n\tstruct switchdev_brport_flags flags;\n\n\tflags.mask = BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD;\n\tflags.val = flags.mask & ~BR_LEARNING;\n\n\tocelot_port_bridge_flags(ocelot, port, flags);\n}\n\nstatic int ocelot_switchdev_sync(struct ocelot *ocelot, int port,\n\t\t\t\t struct net_device *brport_dev,\n\t\t\t\t struct net_device *bridge_dev,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tclock_t ageing_time;\n\tu8 stp_state;\n\n\tocelot_inherit_brport_flags(ocelot, port, brport_dev);\n\n\tstp_state = br_port_get_stp_state(brport_dev);\n\tocelot_bridge_stp_state_set(ocelot, port, stp_state);\n\n\tageing_time = br_get_ageing_time(bridge_dev);\n\tocelot_port_attr_ageing_set(ocelot, port, ageing_time);\n\n\treturn ocelot_port_vlan_filtering(ocelot, port,\n\t\t\t\t\t  br_vlan_enabled(bridge_dev),\n\t\t\t\t\t  extack);\n}\n\nstatic int ocelot_switchdev_unsync(struct ocelot *ocelot, int port)\n{\n\tint err;\n\n\terr = ocelot_port_vlan_filtering(ocelot, port, false, NULL);\n\tif (err)\n\t\treturn err;\n\n\tocelot_clear_brport_flags(ocelot, port);\n\n\tocelot_bridge_stp_state_set(ocelot, port, BR_STATE_FORWARDING);\n\n\treturn 0;\n}\n\nstatic int ocelot_bridge_num_get(struct ocelot *ocelot,\n\t\t\t\t const struct net_device *bridge_dev)\n{\n\tint bridge_num = ocelot_bridge_num_find(ocelot, bridge_dev);\n\n\tif (bridge_num < 0) {\n\t\t \n\t\tbridge_num = find_first_zero_bit(&ocelot->bridges,\n\t\t\t\t\t\t ocelot->num_phys_ports);\n\n\t\tset_bit(bridge_num, &ocelot->bridges);\n\t}\n\n\treturn bridge_num;\n}\n\nstatic void ocelot_bridge_num_put(struct ocelot *ocelot,\n\t\t\t\t  const struct net_device *bridge_dev,\n\t\t\t\t  int bridge_num)\n{\n\t \n\tif (!ocelot_bridge_num_find(ocelot, bridge_dev))\n\t\tclear_bit(bridge_num, &ocelot->bridges);\n}\n\nstatic int ocelot_netdevice_bridge_join(struct net_device *dev,\n\t\t\t\t\tstruct net_device *brport_dev,\n\t\t\t\t\tstruct net_device *bridge,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tint port = priv->port.index;\n\tint bridge_num, err;\n\n\tbridge_num = ocelot_bridge_num_get(ocelot, bridge);\n\n\terr = ocelot_port_bridge_join(ocelot, port, bridge, bridge_num,\n\t\t\t\t      extack);\n\tif (err)\n\t\tgoto err_join;\n\n\terr = switchdev_bridge_port_offload(brport_dev, dev, priv,\n\t\t\t\t\t    &ocelot_switchdev_nb,\n\t\t\t\t\t    &ocelot_switchdev_blocking_nb,\n\t\t\t\t\t    false, extack);\n\tif (err)\n\t\tgoto err_switchdev_offload;\n\n\terr = ocelot_switchdev_sync(ocelot, port, brport_dev, bridge, extack);\n\tif (err)\n\t\tgoto err_switchdev_sync;\n\n\treturn 0;\n\nerr_switchdev_sync:\n\tswitchdev_bridge_port_unoffload(brport_dev, priv,\n\t\t\t\t\t&ocelot_switchdev_nb,\n\t\t\t\t\t&ocelot_switchdev_blocking_nb);\nerr_switchdev_offload:\n\tocelot_port_bridge_leave(ocelot, port, bridge);\nerr_join:\n\tocelot_bridge_num_put(ocelot, bridge, bridge_num);\n\treturn err;\n}\n\nstatic void ocelot_netdevice_pre_bridge_leave(struct net_device *dev,\n\t\t\t\t\t      struct net_device *brport_dev)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\n\tswitchdev_bridge_port_unoffload(brport_dev, priv,\n\t\t\t\t\t&ocelot_switchdev_nb,\n\t\t\t\t\t&ocelot_switchdev_blocking_nb);\n}\n\nstatic int ocelot_netdevice_bridge_leave(struct net_device *dev,\n\t\t\t\t\t struct net_device *brport_dev,\n\t\t\t\t\t struct net_device *bridge)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tint bridge_num = ocelot_port->bridge_num;\n\tint port = priv->port.index;\n\tint err;\n\n\terr = ocelot_switchdev_unsync(ocelot, port);\n\tif (err)\n\t\treturn err;\n\n\tocelot_port_bridge_leave(ocelot, port, bridge);\n\tocelot_bridge_num_put(ocelot, bridge, bridge_num);\n\n\treturn 0;\n}\n\nstatic int ocelot_netdevice_lag_join(struct net_device *dev,\n\t\t\t\t     struct net_device *bond,\n\t\t\t\t     struct netdev_lag_upper_info *info,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tstruct net_device *bridge_dev;\n\tint port = priv->port.index;\n\tint err;\n\n\terr = ocelot_port_lag_join(ocelot, port, bond, info, extack);\n\tif (err == -EOPNOTSUPP)\n\t\t \n\t\treturn 0;\n\n\tbridge_dev = netdev_master_upper_dev_get(bond);\n\tif (!bridge_dev || !netif_is_bridge_master(bridge_dev))\n\t\treturn 0;\n\n\terr = ocelot_netdevice_bridge_join(dev, bond, bridge_dev, extack);\n\tif (err)\n\t\tgoto err_bridge_join;\n\n\treturn 0;\n\nerr_bridge_join:\n\tocelot_port_lag_leave(ocelot, port, bond);\n\treturn err;\n}\n\nstatic void ocelot_netdevice_pre_lag_leave(struct net_device *dev,\n\t\t\t\t\t   struct net_device *bond)\n{\n\tstruct net_device *bridge_dev;\n\n\tbridge_dev = netdev_master_upper_dev_get(bond);\n\tif (!bridge_dev || !netif_is_bridge_master(bridge_dev))\n\t\treturn;\n\n\tocelot_netdevice_pre_bridge_leave(dev, bond);\n}\n\nstatic int ocelot_netdevice_lag_leave(struct net_device *dev,\n\t\t\t\t      struct net_device *bond)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tstruct net_device *bridge_dev;\n\tint port = priv->port.index;\n\n\tocelot_port_lag_leave(ocelot, port, bond);\n\n\tbridge_dev = netdev_master_upper_dev_get(bond);\n\tif (!bridge_dev || !netif_is_bridge_master(bridge_dev))\n\t\treturn 0;\n\n\treturn ocelot_netdevice_bridge_leave(dev, bond, bridge_dev);\n}\n\nstatic int ocelot_netdevice_changeupper(struct net_device *dev,\n\t\t\t\t\tstruct net_device *brport_dev,\n\t\t\t\t\tstruct netdev_notifier_changeupper_info *info)\n{\n\tstruct netlink_ext_ack *extack;\n\tint err = 0;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\n\tif (netif_is_bridge_master(info->upper_dev)) {\n\t\tif (info->linking)\n\t\t\terr = ocelot_netdevice_bridge_join(dev, brport_dev,\n\t\t\t\t\t\t\t   info->upper_dev,\n\t\t\t\t\t\t\t   extack);\n\t\telse\n\t\t\terr = ocelot_netdevice_bridge_leave(dev, brport_dev,\n\t\t\t\t\t\t\t    info->upper_dev);\n\t}\n\tif (netif_is_lag_master(info->upper_dev)) {\n\t\tif (info->linking)\n\t\t\terr = ocelot_netdevice_lag_join(dev, info->upper_dev,\n\t\t\t\t\t\t\tinfo->upper_info, extack);\n\t\telse\n\t\t\tocelot_netdevice_lag_leave(dev, info->upper_dev);\n\t}\n\n\treturn notifier_from_errno(err);\n}\n\n \nstatic int\nocelot_netdevice_lag_changeupper(struct net_device *dev,\n\t\t\t\t struct netdev_notifier_changeupper_info *info)\n{\n\tstruct net_device *lower;\n\tstruct list_head *iter;\n\tint err = NOTIFY_DONE;\n\n\tnetdev_for_each_lower_dev(dev, lower, iter) {\n\t\tstruct ocelot_port_private *priv = netdev_priv(lower);\n\t\tstruct ocelot_port *ocelot_port = &priv->port;\n\n\t\tif (ocelot_port->bond != dev)\n\t\t\treturn NOTIFY_OK;\n\n\t\terr = ocelot_netdevice_changeupper(lower, dev, info);\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int\nocelot_netdevice_prechangeupper(struct net_device *dev,\n\t\t\t\tstruct net_device *brport_dev,\n\t\t\t\tstruct netdev_notifier_changeupper_info *info)\n{\n\tif (netif_is_bridge_master(info->upper_dev) && !info->linking)\n\t\tocelot_netdevice_pre_bridge_leave(dev, brport_dev);\n\n\tif (netif_is_lag_master(info->upper_dev) && !info->linking)\n\t\tocelot_netdevice_pre_lag_leave(dev, info->upper_dev);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int\nocelot_netdevice_lag_prechangeupper(struct net_device *dev,\n\t\t\t\t    struct netdev_notifier_changeupper_info *info)\n{\n\tstruct net_device *lower;\n\tstruct list_head *iter;\n\tint err = NOTIFY_DONE;\n\n\tnetdev_for_each_lower_dev(dev, lower, iter) {\n\t\tstruct ocelot_port_private *priv = netdev_priv(lower);\n\t\tstruct ocelot_port *ocelot_port = &priv->port;\n\n\t\tif (ocelot_port->bond != dev)\n\t\t\treturn NOTIFY_OK;\n\n\t\terr = ocelot_netdevice_prechangeupper(dev, lower, info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int\nocelot_netdevice_changelowerstate(struct net_device *dev,\n\t\t\t\t  struct netdev_lag_lower_state_info *info)\n{\n\tstruct ocelot_port_private *priv = netdev_priv(dev);\n\tbool is_active = info->link_up && info->tx_enabled;\n\tstruct ocelot_port *ocelot_port = &priv->port;\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tint port = priv->port.index;\n\n\tif (!ocelot_port->bond)\n\t\treturn NOTIFY_DONE;\n\n\tif (ocelot_port->lag_tx_active == is_active)\n\t\treturn NOTIFY_DONE;\n\n\tocelot_port_lag_change(ocelot, port, is_active);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int ocelot_netdevice_event(struct notifier_block *unused,\n\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tswitch (event) {\n\tcase NETDEV_PRECHANGEUPPER: {\n\t\tstruct netdev_notifier_changeupper_info *info = ptr;\n\n\t\tif (ocelot_netdevice_dev_check(dev))\n\t\t\treturn ocelot_netdevice_prechangeupper(dev, dev, info);\n\n\t\tif (netif_is_lag_master(dev))\n\t\t\treturn ocelot_netdevice_lag_prechangeupper(dev, info);\n\n\t\tbreak;\n\t}\n\tcase NETDEV_CHANGEUPPER: {\n\t\tstruct netdev_notifier_changeupper_info *info = ptr;\n\n\t\tif (ocelot_netdevice_dev_check(dev))\n\t\t\treturn ocelot_netdevice_changeupper(dev, dev, info);\n\n\t\tif (netif_is_lag_master(dev))\n\t\t\treturn ocelot_netdevice_lag_changeupper(dev, info);\n\n\t\tbreak;\n\t}\n\tcase NETDEV_CHANGELOWERSTATE: {\n\t\tstruct netdev_notifier_changelowerstate_info *info = ptr;\n\n\t\tif (!ocelot_netdevice_dev_check(dev))\n\t\t\tbreak;\n\n\t\treturn ocelot_netdevice_changelowerstate(dev,\n\t\t\t\t\t\t\t info->lower_state_info);\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstruct notifier_block ocelot_netdevice_nb __read_mostly = {\n\t.notifier_call = ocelot_netdevice_event,\n};\n\nstatic int ocelot_switchdev_event(struct notifier_block *unused,\n\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tint err;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     ocelot_netdevice_dev_check,\n\t\t\t\t\t\t     ocelot_port_attr_set);\n\t\treturn notifier_from_errno(err);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstruct notifier_block ocelot_switchdev_nb __read_mostly = {\n\t.notifier_call = ocelot_switchdev_event,\n};\n\nstatic int ocelot_switchdev_blocking_event(struct notifier_block *unused,\n\t\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tint err;\n\n\tswitch (event) {\n\t\t \n\tcase SWITCHDEV_PORT_OBJ_ADD:\n\t\terr = switchdev_handle_port_obj_add(dev, ptr,\n\t\t\t\t\t\t    ocelot_netdevice_dev_check,\n\t\t\t\t\t\t    ocelot_port_obj_add);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_PORT_OBJ_DEL:\n\t\terr = switchdev_handle_port_obj_del(dev, ptr,\n\t\t\t\t\t\t    ocelot_netdevice_dev_check,\n\t\t\t\t\t\t    ocelot_port_obj_del);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     ocelot_netdevice_dev_check,\n\t\t\t\t\t\t     ocelot_port_attr_set);\n\t\treturn notifier_from_errno(err);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstruct notifier_block ocelot_switchdev_blocking_nb __read_mostly = {\n\t.notifier_call = ocelot_switchdev_blocking_event,\n};\n\nstatic void vsc7514_phylink_mac_config(struct phylink_config *config,\n\t\t\t\t       unsigned int link_an_mode,\n\t\t\t\t       const struct phylink_link_state *state)\n{\n\tstruct net_device *ndev = to_net_dev(config->dev);\n\tstruct ocelot_port_private *priv = netdev_priv(ndev);\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\n\tocelot_phylink_mac_config(ocelot, port, link_an_mode, state);\n}\n\nstatic void vsc7514_phylink_mac_link_down(struct phylink_config *config,\n\t\t\t\t\t  unsigned int link_an_mode,\n\t\t\t\t\t  phy_interface_t interface)\n{\n\tstruct net_device *ndev = to_net_dev(config->dev);\n\tstruct ocelot_port_private *priv = netdev_priv(ndev);\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\n\tocelot_phylink_mac_link_down(ocelot, port, link_an_mode, interface,\n\t\t\t\t     OCELOT_MAC_QUIRKS);\n}\n\nstatic void vsc7514_phylink_mac_link_up(struct phylink_config *config,\n\t\t\t\t\tstruct phy_device *phydev,\n\t\t\t\t\tunsigned int link_an_mode,\n\t\t\t\t\tphy_interface_t interface,\n\t\t\t\t\tint speed, int duplex,\n\t\t\t\t\tbool tx_pause, bool rx_pause)\n{\n\tstruct net_device *ndev = to_net_dev(config->dev);\n\tstruct ocelot_port_private *priv = netdev_priv(ndev);\n\tstruct ocelot *ocelot = priv->port.ocelot;\n\tint port = priv->port.index;\n\n\tocelot_phylink_mac_link_up(ocelot, port, phydev, link_an_mode,\n\t\t\t\t   interface, speed, duplex,\n\t\t\t\t   tx_pause, rx_pause, OCELOT_MAC_QUIRKS);\n}\n\nstatic const struct phylink_mac_ops ocelot_phylink_ops = {\n\t.mac_config\t\t= vsc7514_phylink_mac_config,\n\t.mac_link_down\t\t= vsc7514_phylink_mac_link_down,\n\t.mac_link_up\t\t= vsc7514_phylink_mac_link_up,\n};\n\nstatic int ocelot_port_phylink_create(struct ocelot *ocelot, int port,\n\t\t\t\t      struct device_node *portnp)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tstruct ocelot_port_private *priv;\n\tstruct device *dev = ocelot->dev;\n\tphy_interface_t phy_mode;\n\tstruct phylink *phylink;\n\tint err;\n\n\tof_get_phy_mode(portnp, &phy_mode);\n\t \n\tif (phy_mode == PHY_INTERFACE_MODE_NA)\n\t\tphy_mode = PHY_INTERFACE_MODE_INTERNAL;\n\n\tif (phy_mode != PHY_INTERFACE_MODE_SGMII &&\n\t    phy_mode != PHY_INTERFACE_MODE_QSGMII &&\n\t    phy_mode != PHY_INTERFACE_MODE_INTERNAL) {\n\t\tdev_err(dev, \"unsupported phy mode %s for port %d\\n\",\n\t\t\tphy_modes(phy_mode), port);\n\t\treturn -EINVAL;\n\t}\n\n\tocelot_port->phy_mode = phy_mode;\n\n\terr = ocelot_port_configure_serdes(ocelot, port, portnp);\n\tif (err)\n\t\treturn err;\n\n\tpriv = container_of(ocelot_port, struct ocelot_port_private, port);\n\n\tpriv->phylink_config.dev = &priv->dev->dev;\n\tpriv->phylink_config.type = PHYLINK_NETDEV;\n\tpriv->phylink_config.mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |\n\t\tMAC_10 | MAC_100 | MAC_1000FD | MAC_2500FD;\n\n\t__set_bit(ocelot_port->phy_mode,\n\t\t  priv->phylink_config.supported_interfaces);\n\n\tphylink = phylink_create(&priv->phylink_config,\n\t\t\t\t of_fwnode_handle(portnp),\n\t\t\t\t phy_mode, &ocelot_phylink_ops);\n\tif (IS_ERR(phylink)) {\n\t\terr = PTR_ERR(phylink);\n\t\tdev_err(dev, \"Could not create phylink (%pe)\\n\", phylink);\n\t\treturn err;\n\t}\n\n\tpriv->phylink = phylink;\n\n\terr = phylink_of_phy_connect(phylink, portnp, 0);\n\tif (err) {\n\t\tdev_err(dev, \"Could not connect to PHY: %pe\\n\", ERR_PTR(err));\n\t\tphylink_destroy(phylink);\n\t\tpriv->phylink = NULL;\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint ocelot_probe_port(struct ocelot *ocelot, int port, struct regmap *target,\n\t\t      struct device_node *portnp)\n{\n\tstruct ocelot_port_private *priv;\n\tstruct ocelot_port *ocelot_port;\n\tstruct net_device *dev;\n\tint err;\n\n\tdev = alloc_etherdev(sizeof(struct ocelot_port_private));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tSET_NETDEV_DEV(dev, ocelot->dev);\n\tpriv = netdev_priv(dev);\n\tpriv->dev = dev;\n\tocelot_port = &priv->port;\n\tocelot_port->ocelot = ocelot;\n\tocelot_port->index = port;\n\tocelot_port->target = target;\n\tocelot->ports[port] = ocelot_port;\n\n\tdev->netdev_ops = &ocelot_port_netdev_ops;\n\tdev->ethtool_ops = &ocelot_ethtool_ops;\n\tdev->max_mtu = OCELOT_JUMBO_MTU;\n\n\tdev->hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_RXFCS |\n\t\tNETIF_F_HW_TC;\n\tdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_HW_TC;\n\n\terr = of_get_ethdev_address(portnp, dev);\n\tif (err)\n\t\teth_hw_addr_gen(dev, ocelot->base_mac, port);\n\n\tocelot_mact_learn(ocelot, PGID_CPU, dev->dev_addr,\n\t\t\t  OCELOT_STANDALONE_PVID, ENTRYTYPE_LOCKED);\n\n\tocelot_init_port(ocelot, port);\n\n\terr = ocelot_port_phylink_create(ocelot, port, portnp);\n\tif (err)\n\t\tgoto out;\n\n\tif (ocelot->fdma)\n\t\tocelot_fdma_netdev_init(ocelot, dev);\n\n\tSET_NETDEV_DEVLINK_PORT(dev, &ocelot->devlink_ports[port]);\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(ocelot->dev, \"register_netdev failed\\n\");\n\t\tgoto out_fdma_deinit;\n\t}\n\n\treturn 0;\n\nout_fdma_deinit:\n\tif (ocelot->fdma)\n\t\tocelot_fdma_netdev_deinit(ocelot, dev);\nout:\n\tocelot->ports[port] = NULL;\n\tfree_netdev(dev);\n\n\treturn err;\n}\n\nvoid ocelot_release_port(struct ocelot_port *ocelot_port)\n{\n\tstruct ocelot_port_private *priv = container_of(ocelot_port,\n\t\t\t\t\t\tstruct ocelot_port_private,\n\t\t\t\t\t\tport);\n\tstruct ocelot *ocelot = ocelot_port->ocelot;\n\tstruct ocelot_fdma *fdma = ocelot->fdma;\n\n\tunregister_netdev(priv->dev);\n\n\tif (fdma)\n\t\tocelot_fdma_netdev_deinit(ocelot, priv->dev);\n\n\tif (priv->phylink) {\n\t\trtnl_lock();\n\t\tphylink_disconnect_phy(priv->phylink);\n\t\trtnl_unlock();\n\n\t\tphylink_destroy(priv->phylink);\n\t}\n\n\tfree_netdev(priv->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}