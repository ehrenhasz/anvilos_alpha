{
  "module_name": "ocelot.c",
  "hash_id": "e7573239fc8af6fe3f4aced234a1bde1110083653b4f56b6ed991dd970144806",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mscc/ocelot.c",
  "human_readable_source": "\n \n#include <linux/dsa/ocelot.h>\n#include <linux/if_bridge.h>\n#include <linux/iopoll.h>\n#include <linux/phy/phy.h>\n#include <net/pkt_sched.h>\n#include <soc/mscc/ocelot_hsio.h>\n#include <soc/mscc/ocelot_vcap.h>\n#include \"ocelot.h\"\n#include \"ocelot_vcap.h\"\n\n#define TABLE_UPDATE_SLEEP_US\t10\n#define TABLE_UPDATE_TIMEOUT_US\t100000\n#define MEM_INIT_SLEEP_US\t1000\n#define MEM_INIT_TIMEOUT_US\t100000\n\n#define OCELOT_RSV_VLAN_RANGE_START 4000\n\nstruct ocelot_mact_entry {\n\tu8 mac[ETH_ALEN];\n\tu16 vid;\n\tenum macaccess_entry_type type;\n};\n\n \nstatic inline u32 ocelot_mact_read_macaccess(struct ocelot *ocelot)\n{\n\treturn ocelot_read(ocelot, ANA_TABLES_MACACCESS);\n}\n\n \nstatic inline int ocelot_mact_wait_for_completion(struct ocelot *ocelot)\n{\n\tu32 val;\n\n\treturn readx_poll_timeout(ocelot_mact_read_macaccess,\n\t\tocelot, val,\n\t\t(val & ANA_TABLES_MACACCESS_MAC_TABLE_CMD_M) ==\n\t\tMACACCESS_CMD_IDLE,\n\t\tTABLE_UPDATE_SLEEP_US, TABLE_UPDATE_TIMEOUT_US);\n}\n\n \nstatic void ocelot_mact_select(struct ocelot *ocelot,\n\t\t\t       const unsigned char mac[ETH_ALEN],\n\t\t\t       unsigned int vid)\n{\n\tu32 macl = 0, mach = 0;\n\n\t \n\tmach |= vid    << 16;\n\tmach |= mac[0] << 8;\n\tmach |= mac[1] << 0;\n\tmacl |= mac[2] << 24;\n\tmacl |= mac[3] << 16;\n\tmacl |= mac[4] << 8;\n\tmacl |= mac[5] << 0;\n\n\tocelot_write(ocelot, macl, ANA_TABLES_MACLDATA);\n\tocelot_write(ocelot, mach, ANA_TABLES_MACHDATA);\n\n}\n\nstatic int __ocelot_mact_learn(struct ocelot *ocelot, int port,\n\t\t\t       const unsigned char mac[ETH_ALEN],\n\t\t\t       unsigned int vid, enum macaccess_entry_type type)\n{\n\tu32 cmd = ANA_TABLES_MACACCESS_VALID |\n\t\tANA_TABLES_MACACCESS_DEST_IDX(port) |\n\t\tANA_TABLES_MACACCESS_ENTRYTYPE(type) |\n\t\tANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_LEARN);\n\tunsigned int mc_ports;\n\tint err;\n\n\t \n\tif (type == ENTRYTYPE_MACv4)\n\t\tmc_ports = (mac[1] << 8) | mac[2];\n\telse if (type == ENTRYTYPE_MACv6)\n\t\tmc_ports = (mac[0] << 8) | mac[1];\n\telse\n\t\tmc_ports = 0;\n\n\tif (mc_ports & BIT(ocelot->num_phys_ports))\n\t\tcmd |= ANA_TABLES_MACACCESS_MAC_CPU_COPY;\n\n\tocelot_mact_select(ocelot, mac, vid);\n\n\t \n\tocelot_write(ocelot, cmd, ANA_TABLES_MACACCESS);\n\n\terr = ocelot_mact_wait_for_completion(ocelot);\n\n\treturn err;\n}\n\nint ocelot_mact_learn(struct ocelot *ocelot, int port,\n\t\t      const unsigned char mac[ETH_ALEN],\n\t\t      unsigned int vid, enum macaccess_entry_type type)\n{\n\tint ret;\n\n\tmutex_lock(&ocelot->mact_lock);\n\tret = __ocelot_mact_learn(ocelot, port, mac, vid, type);\n\tmutex_unlock(&ocelot->mact_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ocelot_mact_learn);\n\nint ocelot_mact_forget(struct ocelot *ocelot,\n\t\t       const unsigned char mac[ETH_ALEN], unsigned int vid)\n{\n\tint err;\n\n\tmutex_lock(&ocelot->mact_lock);\n\n\tocelot_mact_select(ocelot, mac, vid);\n\n\t \n\tocelot_write(ocelot,\n\t\t     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_FORGET),\n\t\t     ANA_TABLES_MACACCESS);\n\n\terr = ocelot_mact_wait_for_completion(ocelot);\n\n\tmutex_unlock(&ocelot->mact_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(ocelot_mact_forget);\n\nint ocelot_mact_lookup(struct ocelot *ocelot, int *dst_idx,\n\t\t       const unsigned char mac[ETH_ALEN],\n\t\t       unsigned int vid, enum macaccess_entry_type *type)\n{\n\tint val;\n\n\tmutex_lock(&ocelot->mact_lock);\n\n\tocelot_mact_select(ocelot, mac, vid);\n\n\t \n\tocelot_write(ocelot, ANA_TABLES_MACACCESS_VALID |\n\t\t     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_READ),\n\t\t     ANA_TABLES_MACACCESS);\n\n\tif (ocelot_mact_wait_for_completion(ocelot)) {\n\t\tmutex_unlock(&ocelot->mact_lock);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tval = ocelot_read(ocelot, ANA_TABLES_MACACCESS);\n\n\tmutex_unlock(&ocelot->mact_lock);\n\n\tif (!(val & ANA_TABLES_MACACCESS_VALID))\n\t\treturn -ENOENT;\n\n\t*dst_idx = ANA_TABLES_MACACCESS_DEST_IDX_X(val);\n\t*type = ANA_TABLES_MACACCESS_ENTRYTYPE_X(val);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_mact_lookup);\n\nint ocelot_mact_learn_streamdata(struct ocelot *ocelot, int dst_idx,\n\t\t\t\t const unsigned char mac[ETH_ALEN],\n\t\t\t\t unsigned int vid,\n\t\t\t\t enum macaccess_entry_type type,\n\t\t\t\t int sfid, int ssid)\n{\n\tint ret;\n\n\tmutex_lock(&ocelot->mact_lock);\n\n\tocelot_write(ocelot,\n\t\t     (sfid < 0 ? 0 : ANA_TABLES_STREAMDATA_SFID_VALID) |\n\t\t     ANA_TABLES_STREAMDATA_SFID(sfid) |\n\t\t     (ssid < 0 ? 0 : ANA_TABLES_STREAMDATA_SSID_VALID) |\n\t\t     ANA_TABLES_STREAMDATA_SSID(ssid),\n\t\t     ANA_TABLES_STREAMDATA);\n\n\tret = __ocelot_mact_learn(ocelot, dst_idx, mac, vid, type);\n\n\tmutex_unlock(&ocelot->mact_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ocelot_mact_learn_streamdata);\n\nstatic void ocelot_mact_init(struct ocelot *ocelot)\n{\n\t \n\tocelot_rmw(ocelot, 0,\n\t\t   ANA_AGENCTRL_LEARN_CPU_COPY | ANA_AGENCTRL_IGNORE_DMAC_FLAGS\n\t\t   | ANA_AGENCTRL_LEARN_FWD_KILL\n\t\t   | ANA_AGENCTRL_LEARN_IGNORE_VLAN,\n\t\t   ANA_AGENCTRL);\n\n\t \n\tocelot_write(ocelot, MACACCESS_CMD_INIT, ANA_TABLES_MACACCESS);\n}\n\nvoid ocelot_pll5_init(struct ocelot *ocelot)\n{\n\t \n\tregmap_write(ocelot->targets[HSIO], HSIO_PLL5G_CFG4,\n\t\t     HSIO_PLL5G_CFG4_IB_CTRL(0x7600) |\n\t\t     HSIO_PLL5G_CFG4_IB_BIAS_CTRL(0x8));\n\tregmap_write(ocelot->targets[HSIO], HSIO_PLL5G_CFG0,\n\t\t     HSIO_PLL5G_CFG0_CORE_CLK_DIV(0x11) |\n\t\t     HSIO_PLL5G_CFG0_CPU_CLK_DIV(2) |\n\t\t     HSIO_PLL5G_CFG0_ENA_BIAS |\n\t\t     HSIO_PLL5G_CFG0_ENA_VCO_BUF |\n\t\t     HSIO_PLL5G_CFG0_ENA_CP1 |\n\t\t     HSIO_PLL5G_CFG0_SELCPI(2) |\n\t\t     HSIO_PLL5G_CFG0_LOOP_BW_RES(0xe) |\n\t\t     HSIO_PLL5G_CFG0_SELBGV820(4) |\n\t\t     HSIO_PLL5G_CFG0_DIV4 |\n\t\t     HSIO_PLL5G_CFG0_ENA_CLKTREE |\n\t\t     HSIO_PLL5G_CFG0_ENA_LANE);\n\tregmap_write(ocelot->targets[HSIO], HSIO_PLL5G_CFG2,\n\t\t     HSIO_PLL5G_CFG2_EN_RESET_FRQ_DET |\n\t\t     HSIO_PLL5G_CFG2_EN_RESET_OVERRUN |\n\t\t     HSIO_PLL5G_CFG2_GAIN_TEST(0x8) |\n\t\t     HSIO_PLL5G_CFG2_ENA_AMPCTRL |\n\t\t     HSIO_PLL5G_CFG2_PWD_AMPCTRL_N |\n\t\t     HSIO_PLL5G_CFG2_AMPC_SEL(0x10));\n}\nEXPORT_SYMBOL(ocelot_pll5_init);\n\nstatic void ocelot_vcap_enable(struct ocelot *ocelot, int port)\n{\n\tocelot_write_gix(ocelot, ANA_PORT_VCAP_S2_CFG_S2_ENA |\n\t\t\t ANA_PORT_VCAP_S2_CFG_S2_IP6_CFG(0xa),\n\t\t\t ANA_PORT_VCAP_S2_CFG, port);\n\n\tocelot_write_gix(ocelot, ANA_PORT_VCAP_CFG_S1_ENA,\n\t\t\t ANA_PORT_VCAP_CFG, port);\n\n\tocelot_rmw_gix(ocelot, REW_PORT_CFG_ES0_EN,\n\t\t       REW_PORT_CFG_ES0_EN,\n\t\t       REW_PORT_CFG, port);\n}\n\nstatic int ocelot_single_vlan_aware_bridge(struct ocelot *ocelot,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net_device *bridge = NULL;\n\tint port;\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\t\tif (!ocelot_port || !ocelot_port->bridge ||\n\t\t    !br_vlan_enabled(ocelot_port->bridge))\n\t\t\tcontinue;\n\n\t\tif (!bridge) {\n\t\t\tbridge = ocelot_port->bridge;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (bridge == ocelot_port->bridge)\n\t\t\tcontinue;\n\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Only one VLAN-aware bridge is supported\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic inline u32 ocelot_vlant_read_vlanaccess(struct ocelot *ocelot)\n{\n\treturn ocelot_read(ocelot, ANA_TABLES_VLANACCESS);\n}\n\nstatic inline int ocelot_vlant_wait_for_completion(struct ocelot *ocelot)\n{\n\tu32 val;\n\n\treturn readx_poll_timeout(ocelot_vlant_read_vlanaccess,\n\t\tocelot,\n\t\tval,\n\t\t(val & ANA_TABLES_VLANACCESS_VLAN_TBL_CMD_M) ==\n\t\tANA_TABLES_VLANACCESS_CMD_IDLE,\n\t\tTABLE_UPDATE_SLEEP_US, TABLE_UPDATE_TIMEOUT_US);\n}\n\nstatic int ocelot_vlant_set_mask(struct ocelot *ocelot, u16 vid, u32 mask)\n{\n\t \n\tocelot_write(ocelot, ANA_TABLES_VLANTIDX_V_INDEX(vid),\n\t\t     ANA_TABLES_VLANTIDX);\n\t \n\tocelot_write(ocelot, ANA_TABLES_VLANACCESS_VLAN_PORT_MASK(mask) |\n\t\t\t     ANA_TABLES_VLANACCESS_CMD_WRITE,\n\t\t     ANA_TABLES_VLANACCESS);\n\n\treturn ocelot_vlant_wait_for_completion(ocelot);\n}\n\nstatic int ocelot_port_num_untagged_vlans(struct ocelot *ocelot, int port)\n{\n\tstruct ocelot_bridge_vlan *vlan;\n\tint num_untagged = 0;\n\n\tlist_for_each_entry(vlan, &ocelot->vlans, list) {\n\t\tif (!(vlan->portmask & BIT(port)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (vlan->vid >= OCELOT_RSV_VLAN_RANGE_START)\n\t\t\tcontinue;\n\n\t\tif (vlan->untagged & BIT(port))\n\t\t\tnum_untagged++;\n\t}\n\n\treturn num_untagged;\n}\n\nstatic int ocelot_port_num_tagged_vlans(struct ocelot *ocelot, int port)\n{\n\tstruct ocelot_bridge_vlan *vlan;\n\tint num_tagged = 0;\n\n\tlist_for_each_entry(vlan, &ocelot->vlans, list) {\n\t\tif (!(vlan->portmask & BIT(port)))\n\t\t\tcontinue;\n\n\t\tif (!(vlan->untagged & BIT(port)))\n\t\t\tnum_tagged++;\n\t}\n\n\treturn num_tagged;\n}\n\n \nstatic bool ocelot_port_uses_native_vlan(struct ocelot *ocelot, int port)\n{\n\treturn ocelot_port_num_tagged_vlans(ocelot, port) &&\n\t       ocelot_port_num_untagged_vlans(ocelot, port) == 1;\n}\n\nstatic struct ocelot_bridge_vlan *\nocelot_port_find_native_vlan(struct ocelot *ocelot, int port)\n{\n\tstruct ocelot_bridge_vlan *vlan;\n\n\tlist_for_each_entry(vlan, &ocelot->vlans, list)\n\t\tif (vlan->portmask & BIT(port) && vlan->untagged & BIT(port))\n\t\t\treturn vlan;\n\n\treturn NULL;\n}\n\n \nstatic void ocelot_port_manage_port_tag(struct ocelot *ocelot, int port)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tenum ocelot_port_tag_config tag_cfg;\n\tbool uses_native_vlan = false;\n\n\tif (ocelot_port->vlan_aware) {\n\t\tuses_native_vlan = ocelot_port_uses_native_vlan(ocelot, port);\n\n\t\tif (uses_native_vlan)\n\t\t\ttag_cfg = OCELOT_PORT_TAG_NATIVE;\n\t\telse if (ocelot_port_num_untagged_vlans(ocelot, port))\n\t\t\ttag_cfg = OCELOT_PORT_TAG_DISABLED;\n\t\telse\n\t\t\ttag_cfg = OCELOT_PORT_TAG_TRUNK;\n\t} else {\n\t\ttag_cfg = OCELOT_PORT_TAG_DISABLED;\n\t}\n\n\tocelot_rmw_gix(ocelot, REW_TAG_CFG_TAG_CFG(tag_cfg),\n\t\t       REW_TAG_CFG_TAG_CFG_M,\n\t\t       REW_TAG_CFG, port);\n\n\tif (uses_native_vlan) {\n\t\tstruct ocelot_bridge_vlan *native_vlan;\n\n\t\t \n\t\tnative_vlan = ocelot_port_find_native_vlan(ocelot, port);\n\n\t\tocelot_rmw_gix(ocelot,\n\t\t\t       REW_PORT_VLAN_CFG_PORT_VID(native_vlan->vid),\n\t\t\t       REW_PORT_VLAN_CFG_PORT_VID_M,\n\t\t\t       REW_PORT_VLAN_CFG, port);\n\t}\n}\n\nint ocelot_bridge_num_find(struct ocelot *ocelot,\n\t\t\t   const struct net_device *bridge)\n{\n\tint port;\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\t\tif (ocelot_port && ocelot_port->bridge == bridge)\n\t\t\treturn ocelot_port->bridge_num;\n\t}\n\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(ocelot_bridge_num_find);\n\nstatic u16 ocelot_vlan_unaware_pvid(struct ocelot *ocelot,\n\t\t\t\t    const struct net_device *bridge)\n{\n\tint bridge_num;\n\n\t \n\tif (!bridge)\n\t\treturn 0;\n\n\tbridge_num = ocelot_bridge_num_find(ocelot, bridge);\n\tif (WARN_ON(bridge_num < 0))\n\t\treturn 0;\n\n\t \n\treturn VLAN_N_VID - bridge_num - 1;\n}\n\n \nstatic void ocelot_port_set_pvid(struct ocelot *ocelot, int port,\n\t\t\t\t const struct ocelot_bridge_vlan *pvid_vlan)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tu16 pvid = ocelot_vlan_unaware_pvid(ocelot, ocelot_port->bridge);\n\tu32 val = 0;\n\n\tocelot_port->pvid_vlan = pvid_vlan;\n\n\tif (ocelot_port->vlan_aware && pvid_vlan)\n\t\tpvid = pvid_vlan->vid;\n\n\tocelot_rmw_gix(ocelot,\n\t\t       ANA_PORT_VLAN_CFG_VLAN_VID(pvid),\n\t\t       ANA_PORT_VLAN_CFG_VLAN_VID_M,\n\t\t       ANA_PORT_VLAN_CFG, port);\n\n\t \n\tif (!pvid_vlan && ocelot_port->vlan_aware)\n\t\tval = ANA_PORT_DROP_CFG_DROP_PRIO_S_TAGGED_ENA |\n\t\t      ANA_PORT_DROP_CFG_DROP_PRIO_C_TAGGED_ENA;\n\n\tocelot_rmw_gix(ocelot, val,\n\t\t       ANA_PORT_DROP_CFG_DROP_PRIO_S_TAGGED_ENA |\n\t\t       ANA_PORT_DROP_CFG_DROP_PRIO_C_TAGGED_ENA,\n\t\t       ANA_PORT_DROP_CFG, port);\n}\n\nstatic struct ocelot_bridge_vlan *ocelot_bridge_vlan_find(struct ocelot *ocelot,\n\t\t\t\t\t\t\t  u16 vid)\n{\n\tstruct ocelot_bridge_vlan *vlan;\n\n\tlist_for_each_entry(vlan, &ocelot->vlans, list)\n\t\tif (vlan->vid == vid)\n\t\t\treturn vlan;\n\n\treturn NULL;\n}\n\nstatic int ocelot_vlan_member_add(struct ocelot *ocelot, int port, u16 vid,\n\t\t\t\t  bool untagged)\n{\n\tstruct ocelot_bridge_vlan *vlan = ocelot_bridge_vlan_find(ocelot, vid);\n\tunsigned long portmask;\n\tint err;\n\n\tif (vlan) {\n\t\tportmask = vlan->portmask | BIT(port);\n\n\t\terr = ocelot_vlant_set_mask(ocelot, vid, portmask);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tvlan->portmask = portmask;\n\t\t \n\t\tif (untagged)\n\t\t\tvlan->untagged |= BIT(port);\n\t\telse\n\t\t\tvlan->untagged &= ~BIT(port);\n\n\t\treturn 0;\n\t}\n\n\tvlan = kzalloc(sizeof(*vlan), GFP_KERNEL);\n\tif (!vlan)\n\t\treturn -ENOMEM;\n\n\tportmask = BIT(port);\n\n\terr = ocelot_vlant_set_mask(ocelot, vid, portmask);\n\tif (err) {\n\t\tkfree(vlan);\n\t\treturn err;\n\t}\n\n\tvlan->vid = vid;\n\tvlan->portmask = portmask;\n\tif (untagged)\n\t\tvlan->untagged = BIT(port);\n\tINIT_LIST_HEAD(&vlan->list);\n\tlist_add_tail(&vlan->list, &ocelot->vlans);\n\n\treturn 0;\n}\n\nstatic int ocelot_vlan_member_del(struct ocelot *ocelot, int port, u16 vid)\n{\n\tstruct ocelot_bridge_vlan *vlan = ocelot_bridge_vlan_find(ocelot, vid);\n\tunsigned long portmask;\n\tint err;\n\n\tif (!vlan)\n\t\treturn 0;\n\n\tportmask = vlan->portmask & ~BIT(port);\n\n\terr = ocelot_vlant_set_mask(ocelot, vid, portmask);\n\tif (err)\n\t\treturn err;\n\n\tvlan->portmask = portmask;\n\tif (vlan->portmask)\n\t\treturn 0;\n\n\tlist_del(&vlan->list);\n\tkfree(vlan);\n\n\treturn 0;\n}\n\nstatic int ocelot_add_vlan_unaware_pvid(struct ocelot *ocelot, int port,\n\t\t\t\t\tconst struct net_device *bridge)\n{\n\tu16 vid = ocelot_vlan_unaware_pvid(ocelot, bridge);\n\n\treturn ocelot_vlan_member_add(ocelot, port, vid, true);\n}\n\nstatic int ocelot_del_vlan_unaware_pvid(struct ocelot *ocelot, int port,\n\t\t\t\t\tconst struct net_device *bridge)\n{\n\tu16 vid = ocelot_vlan_unaware_pvid(ocelot, bridge);\n\n\treturn ocelot_vlan_member_del(ocelot, port, vid);\n}\n\nint ocelot_port_vlan_filtering(struct ocelot *ocelot, int port,\n\t\t\t       bool vlan_aware, struct netlink_ext_ack *extack)\n{\n\tstruct ocelot_vcap_block *block = &ocelot->block[VCAP_IS1];\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tstruct ocelot_vcap_filter *filter;\n\tint err = 0;\n\tu32 val;\n\n\tlist_for_each_entry(filter, &block->rules, list) {\n\t\tif (filter->ingress_port_mask & BIT(port) &&\n\t\t    filter->action.vid_replace_ena) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Cannot change VLAN state with vlan modify rules active\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\terr = ocelot_single_vlan_aware_bridge(ocelot, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (vlan_aware)\n\t\terr = ocelot_del_vlan_unaware_pvid(ocelot, port,\n\t\t\t\t\t\t   ocelot_port->bridge);\n\telse if (ocelot_port->bridge)\n\t\terr = ocelot_add_vlan_unaware_pvid(ocelot, port,\n\t\t\t\t\t\t   ocelot_port->bridge);\n\tif (err)\n\t\treturn err;\n\n\tocelot_port->vlan_aware = vlan_aware;\n\n\tif (vlan_aware)\n\t\tval = ANA_PORT_VLAN_CFG_VLAN_AWARE_ENA |\n\t\t      ANA_PORT_VLAN_CFG_VLAN_POP_CNT(1);\n\telse\n\t\tval = 0;\n\tocelot_rmw_gix(ocelot, val,\n\t\t       ANA_PORT_VLAN_CFG_VLAN_AWARE_ENA |\n\t\t       ANA_PORT_VLAN_CFG_VLAN_POP_CNT_M,\n\t\t       ANA_PORT_VLAN_CFG, port);\n\n\tocelot_port_set_pvid(ocelot, port, ocelot_port->pvid_vlan);\n\tocelot_port_manage_port_tag(ocelot, port);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_port_vlan_filtering);\n\nint ocelot_vlan_prepare(struct ocelot *ocelot, int port, u16 vid, bool pvid,\n\t\t\tbool untagged, struct netlink_ext_ack *extack)\n{\n\tif (untagged) {\n\t\t \n\t\tif (ocelot_port_uses_native_vlan(ocelot, port)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Port with egress-tagged VLANs cannot have more than one egress-untagged (native) VLAN\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t} else {\n\t\t \n\t\tif (ocelot_port_num_untagged_vlans(ocelot, port) > 1) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Port with more than one egress-untagged VLAN cannot have egress-tagged VLANs\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (vid > OCELOT_RSV_VLAN_RANGE_START) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"VLAN range 4000-4095 reserved for VLAN-unaware bridging\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_vlan_prepare);\n\nint ocelot_vlan_add(struct ocelot *ocelot, int port, u16 vid, bool pvid,\n\t\t    bool untagged)\n{\n\tint err;\n\n\t \n\tif (!vid)\n\t\treturn 0;\n\n\terr = ocelot_vlan_member_add(ocelot, port, vid, untagged);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (pvid)\n\t\tocelot_port_set_pvid(ocelot, port,\n\t\t\t\t     ocelot_bridge_vlan_find(ocelot, vid));\n\n\t \n\tocelot_port_manage_port_tag(ocelot, port);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_vlan_add);\n\nint ocelot_vlan_del(struct ocelot *ocelot, int port, u16 vid)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tbool del_pvid = false;\n\tint err;\n\n\tif (!vid)\n\t\treturn 0;\n\n\tif (ocelot_port->pvid_vlan && ocelot_port->pvid_vlan->vid == vid)\n\t\tdel_pvid = true;\n\n\terr = ocelot_vlan_member_del(ocelot, port, vid);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (del_pvid)\n\t\tocelot_port_set_pvid(ocelot, port, NULL);\n\n\t \n\tocelot_port_manage_port_tag(ocelot, port);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_vlan_del);\n\nstatic void ocelot_vlan_init(struct ocelot *ocelot)\n{\n\tunsigned long all_ports = GENMASK(ocelot->num_phys_ports - 1, 0);\n\tu16 port, vid;\n\n\t \n\tocelot_write(ocelot, ANA_TABLES_VLANACCESS_CMD_INIT,\n\t\t     ANA_TABLES_VLANACCESS);\n\tocelot_vlant_wait_for_completion(ocelot);\n\n\t \n\tfor (vid = 1; vid < VLAN_N_VID; vid++)\n\t\tocelot_vlant_set_mask(ocelot, vid, 0);\n\n\t \n\tocelot_vlant_set_mask(ocelot, OCELOT_STANDALONE_PVID, all_ports);\n\n\t \n\tocelot_write(ocelot, all_ports, ANA_VLANMASK);\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tocelot_write_gix(ocelot, 0, REW_PORT_VLAN_CFG, port);\n\t\tocelot_write_gix(ocelot, 0, REW_TAG_CFG, port);\n\t}\n}\n\nstatic u32 ocelot_read_eq_avail(struct ocelot *ocelot, int port)\n{\n\treturn ocelot_read_rix(ocelot, QSYS_SW_STATUS, port);\n}\n\nstatic int ocelot_port_flush(struct ocelot *ocelot, int port)\n{\n\tunsigned int pause_ena;\n\tint err, val;\n\n\t \n\tocelot_rmw_rix(ocelot, QSYS_PORT_MODE_DEQUEUE_DIS,\n\t\t       QSYS_PORT_MODE_DEQUEUE_DIS,\n\t\t       QSYS_PORT_MODE, port);\n\n\t \n\tocelot_fields_read(ocelot, port, SYS_PAUSE_CFG_PAUSE_ENA, &pause_ena);\n\tocelot_fields_write(ocelot, port, SYS_PAUSE_CFG_PAUSE_ENA, 0);\n\n\t \n\tocelot_fields_write(ocelot, port,\n\t\t\t    QSYS_SWITCH_PORT_MODE_TX_PFC_ENA, 0);\n\n\t \n\tusleep_range(8000, 10000);\n\n\t \n\tocelot_rmw_rix(ocelot, 0, SYS_FRONT_PORT_MODE_HDX_MODE,\n\t\t       SYS_FRONT_PORT_MODE, port);\n\n\t \n\tocelot_rmw_gix(ocelot, REW_PORT_CFG_FLUSH_ENA, REW_PORT_CFG_FLUSH_ENA,\n\t\t       REW_PORT_CFG, port);\n\n\t \n\tocelot_rmw_rix(ocelot, 0, QSYS_PORT_MODE_DEQUEUE_DIS, QSYS_PORT_MODE,\n\t\t       port);\n\n\t \n\terr = read_poll_timeout(ocelot_read_eq_avail, val, !val,\n\t\t\t\t100, 2000000, false, ocelot, port);\n\n\t \n\tocelot_rmw_gix(ocelot, 0, REW_PORT_CFG_FLUSH_ENA, REW_PORT_CFG, port);\n\n\t \n\tocelot_fields_write(ocelot, port, SYS_PAUSE_CFG_PAUSE_ENA, pause_ena);\n\n\treturn err;\n}\n\nint ocelot_port_configure_serdes(struct ocelot *ocelot, int port,\n\t\t\t\t struct device_node *portnp)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tstruct device *dev = ocelot->dev;\n\tint err;\n\n\t \n\tif (ocelot_port->phy_mode == PHY_INTERFACE_MODE_QSGMII)\n\t\tocelot_port_rmwl(ocelot_port, 0,\n\t\t\t\t DEV_CLOCK_CFG_MAC_TX_RST |\n\t\t\t\t DEV_CLOCK_CFG_MAC_RX_RST,\n\t\t\t\t DEV_CLOCK_CFG);\n\n\tif (ocelot_port->phy_mode != PHY_INTERFACE_MODE_INTERNAL) {\n\t\tstruct phy *serdes = of_phy_get(portnp, NULL);\n\n\t\tif (IS_ERR(serdes)) {\n\t\t\terr = PTR_ERR(serdes);\n\t\t\tdev_err_probe(dev, err,\n\t\t\t\t      \"missing SerDes phys for port %d\\n\",\n\t\t\t\t      port);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = phy_set_mode_ext(serdes, PHY_MODE_ETHERNET,\n\t\t\t\t       ocelot_port->phy_mode);\n\t\tof_phy_put(serdes);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Could not SerDes mode on port %d: %pe\\n\",\n\t\t\t\tport, ERR_PTR(err));\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocelot_port_configure_serdes);\n\nvoid ocelot_phylink_mac_config(struct ocelot *ocelot, int port,\n\t\t\t       unsigned int link_an_mode,\n\t\t\t       const struct phylink_link_state *state)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\t \n\tocelot_port_writel(ocelot_port, DEV_PORT_MISC_HDX_FAST_DIS,\n\t\t\t   DEV_PORT_MISC);\n\n\t \n\tocelot_port_writel(ocelot_port, PCS1G_MODE_CFG_SGMII_MODE_ENA,\n\t\t\t   PCS1G_MODE_CFG);\n\tocelot_port_writel(ocelot_port, PCS1G_SD_CFG_SD_SEL, PCS1G_SD_CFG);\n\n\t \n\tocelot_port_writel(ocelot_port, PCS1G_CFG_PCS_ENA, PCS1G_CFG);\n\n\t \n\tocelot_port_writel(ocelot_port, 0, PCS1G_ANEG_CFG);\n\n\t \n\tocelot_port_writel(ocelot_port, 0, PCS1G_LB_CFG);\n}\nEXPORT_SYMBOL_GPL(ocelot_phylink_mac_config);\n\nvoid ocelot_phylink_mac_link_down(struct ocelot *ocelot, int port,\n\t\t\t\t  unsigned int link_an_mode,\n\t\t\t\t  phy_interface_t interface,\n\t\t\t\t  unsigned long quirks)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tint err;\n\n\tocelot_port->speed = SPEED_UNKNOWN;\n\n\tocelot_port_rmwl(ocelot_port, 0, DEV_MAC_ENA_CFG_RX_ENA,\n\t\t\t DEV_MAC_ENA_CFG);\n\n\tif (ocelot->ops->cut_through_fwd) {\n\t\tmutex_lock(&ocelot->fwd_domain_lock);\n\t\tocelot->ops->cut_through_fwd(ocelot);\n\t\tmutex_unlock(&ocelot->fwd_domain_lock);\n\t}\n\n\tocelot_fields_write(ocelot, port, QSYS_SWITCH_PORT_MODE_PORT_ENA, 0);\n\n\terr = ocelot_port_flush(ocelot, port);\n\tif (err)\n\t\tdev_err(ocelot->dev, \"failed to flush port %d: %d\\n\",\n\t\t\tport, err);\n\n\t \n\tif (interface != PHY_INTERFACE_MODE_QSGMII ||\n\t    !(quirks & OCELOT_QUIRK_QSGMII_PORTS_MUST_BE_UP))\n\t\tocelot_port_rmwl(ocelot_port,\n\t\t\t\t DEV_CLOCK_CFG_MAC_TX_RST |\n\t\t\t\t DEV_CLOCK_CFG_MAC_RX_RST,\n\t\t\t\t DEV_CLOCK_CFG_MAC_TX_RST |\n\t\t\t\t DEV_CLOCK_CFG_MAC_RX_RST,\n\t\t\t\t DEV_CLOCK_CFG);\n}\nEXPORT_SYMBOL_GPL(ocelot_phylink_mac_link_down);\n\nvoid ocelot_phylink_mac_link_up(struct ocelot *ocelot, int port,\n\t\t\t\tstruct phy_device *phydev,\n\t\t\t\tunsigned int link_an_mode,\n\t\t\t\tphy_interface_t interface,\n\t\t\t\tint speed, int duplex,\n\t\t\t\tbool tx_pause, bool rx_pause,\n\t\t\t\tunsigned long quirks)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tint mac_speed, mode = 0;\n\tu32 mac_fc_cfg;\n\n\tocelot_port->speed = speed;\n\n\t \n\tif ((quirks & OCELOT_QUIRK_PCS_PERFORMS_RATE_ADAPTATION) ||\n\t    speed == SPEED_1000) {\n\t\tmac_speed = OCELOT_SPEED_1000;\n\t\tmode = DEV_MAC_MODE_CFG_GIGA_MODE_ENA;\n\t} else if (speed == SPEED_2500) {\n\t\tmac_speed = OCELOT_SPEED_2500;\n\t\tmode = DEV_MAC_MODE_CFG_GIGA_MODE_ENA;\n\t} else if (speed == SPEED_100) {\n\t\tmac_speed = OCELOT_SPEED_100;\n\t} else {\n\t\tmac_speed = OCELOT_SPEED_10;\n\t}\n\n\tif (duplex == DUPLEX_FULL)\n\t\tmode |= DEV_MAC_MODE_CFG_FDX_ENA;\n\n\tocelot_port_writel(ocelot_port, mode, DEV_MAC_MODE_CFG);\n\n\t \n\tocelot_port_writel(ocelot_port, DEV_CLOCK_CFG_LINK_SPEED(mac_speed),\n\t\t\t   DEV_CLOCK_CFG);\n\n\tswitch (speed) {\n\tcase SPEED_10:\n\t\tmac_fc_cfg = SYS_MAC_FC_CFG_FC_LINK_SPEED(OCELOT_SPEED_10);\n\t\tbreak;\n\tcase SPEED_100:\n\t\tmac_fc_cfg = SYS_MAC_FC_CFG_FC_LINK_SPEED(OCELOT_SPEED_100);\n\t\tbreak;\n\tcase SPEED_1000:\n\tcase SPEED_2500:\n\t\tmac_fc_cfg = SYS_MAC_FC_CFG_FC_LINK_SPEED(OCELOT_SPEED_1000);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ocelot->dev, \"Unsupported speed on port %d: %d\\n\",\n\t\t\tport, speed);\n\t\treturn;\n\t}\n\n\tif (rx_pause)\n\t\tmac_fc_cfg |= SYS_MAC_FC_CFG_RX_FC_ENA;\n\n\tif (tx_pause)\n\t\tmac_fc_cfg |= SYS_MAC_FC_CFG_TX_FC_ENA |\n\t\t\t      SYS_MAC_FC_CFG_PAUSE_VAL_CFG(0xffff) |\n\t\t\t      SYS_MAC_FC_CFG_FC_LATENCY_CFG(0x7) |\n\t\t\t      SYS_MAC_FC_CFG_ZERO_PAUSE_ENA;\n\n\t \n\tocelot_write_rix(ocelot, mac_fc_cfg, SYS_MAC_FC_CFG, port);\n\n\tocelot_write_rix(ocelot, 0, ANA_POL_FLOWC, port);\n\n\t \n\tif (port != ocelot->npi)\n\t\tocelot_fields_write(ocelot, port, SYS_PAUSE_CFG_PAUSE_ENA,\n\t\t\t\t    tx_pause);\n\n\t \n\tocelot_port_writel(ocelot_port, DEV_MAC_ENA_CFG_RX_ENA |\n\t\t\t   DEV_MAC_ENA_CFG_TX_ENA, DEV_MAC_ENA_CFG);\n\n\t \n\tif (ocelot->ops->cut_through_fwd) {\n\t\tmutex_lock(&ocelot->fwd_domain_lock);\n\t\t \n\t\tocelot_port_update_active_preemptible_tcs(ocelot, port);\n\t\tmutex_unlock(&ocelot->fwd_domain_lock);\n\t}\n\n\t \n\tocelot_fields_write(ocelot, port,\n\t\t\t    QSYS_SWITCH_PORT_MODE_PORT_ENA, 1);\n}\nEXPORT_SYMBOL_GPL(ocelot_phylink_mac_link_up);\n\nstatic int ocelot_rx_frame_word(struct ocelot *ocelot, u8 grp, bool ifh,\n\t\t\t\tu32 *rval)\n{\n\tu32 bytes_valid, val;\n\n\tval = ocelot_read_rix(ocelot, QS_XTR_RD, grp);\n\tif (val == XTR_NOT_READY) {\n\t\tif (ifh)\n\t\t\treturn -EIO;\n\n\t\tdo {\n\t\t\tval = ocelot_read_rix(ocelot, QS_XTR_RD, grp);\n\t\t} while (val == XTR_NOT_READY);\n\t}\n\n\tswitch (val) {\n\tcase XTR_ABORT:\n\t\treturn -EIO;\n\tcase XTR_EOF_0:\n\tcase XTR_EOF_1:\n\tcase XTR_EOF_2:\n\tcase XTR_EOF_3:\n\tcase XTR_PRUNED:\n\t\tbytes_valid = XTR_VALID_BYTES(val);\n\t\tval = ocelot_read_rix(ocelot, QS_XTR_RD, grp);\n\t\tif (val == XTR_ESCAPE)\n\t\t\t*rval = ocelot_read_rix(ocelot, QS_XTR_RD, grp);\n\t\telse\n\t\t\t*rval = val;\n\n\t\treturn bytes_valid;\n\tcase XTR_ESCAPE:\n\t\t*rval = ocelot_read_rix(ocelot, QS_XTR_RD, grp);\n\n\t\treturn 4;\n\tdefault:\n\t\t*rval = val;\n\n\t\treturn 4;\n\t}\n}\n\nstatic int ocelot_xtr_poll_xfh(struct ocelot *ocelot, int grp, u32 *xfh)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < OCELOT_TAG_LEN / 4; i++) {\n\t\terr = ocelot_rx_frame_word(ocelot, grp, true, &xfh[i]);\n\t\tif (err != 4)\n\t\t\treturn (err < 0) ? err : -EIO;\n\t}\n\n\treturn 0;\n}\n\nvoid ocelot_ptp_rx_timestamp(struct ocelot *ocelot, struct sk_buff *skb,\n\t\t\t     u64 timestamp)\n{\n\tstruct skb_shared_hwtstamps *shhwtstamps;\n\tu64 tod_in_ns, full_ts_in_ns;\n\tstruct timespec64 ts;\n\n\tocelot_ptp_gettime64(&ocelot->ptp_info, &ts);\n\n\ttod_in_ns = ktime_set(ts.tv_sec, ts.tv_nsec);\n\tif ((tod_in_ns & 0xffffffff) < timestamp)\n\t\tfull_ts_in_ns = (((tod_in_ns >> 32) - 1) << 32) |\n\t\t\t\ttimestamp;\n\telse\n\t\tfull_ts_in_ns = (tod_in_ns & GENMASK_ULL(63, 32)) |\n\t\t\t\ttimestamp;\n\n\tshhwtstamps = skb_hwtstamps(skb);\n\tmemset(shhwtstamps, 0, sizeof(struct skb_shared_hwtstamps));\n\tshhwtstamps->hwtstamp = full_ts_in_ns;\n}\nEXPORT_SYMBOL(ocelot_ptp_rx_timestamp);\n\nint ocelot_xtr_poll_frame(struct ocelot *ocelot, int grp, struct sk_buff **nskb)\n{\n\tu64 timestamp, src_port, len;\n\tu32 xfh[OCELOT_TAG_LEN / 4];\n\tstruct net_device *dev;\n\tstruct sk_buff *skb;\n\tint sz, buf_len;\n\tu32 val, *buf;\n\tint err;\n\n\terr = ocelot_xtr_poll_xfh(ocelot, grp, xfh);\n\tif (err)\n\t\treturn err;\n\n\tocelot_xfh_get_src_port(xfh, &src_port);\n\tocelot_xfh_get_len(xfh, &len);\n\tocelot_xfh_get_rew_val(xfh, &timestamp);\n\n\tif (WARN_ON(src_port >= ocelot->num_phys_ports))\n\t\treturn -EINVAL;\n\n\tdev = ocelot->ops->port_to_netdev(ocelot, src_port);\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tskb = netdev_alloc_skb(dev, len);\n\tif (unlikely(!skb)) {\n\t\tnetdev_err(dev, \"Unable to allocate sk_buff\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbuf_len = len - ETH_FCS_LEN;\n\tbuf = (u32 *)skb_put(skb, buf_len);\n\n\tlen = 0;\n\tdo {\n\t\tsz = ocelot_rx_frame_word(ocelot, grp, false, &val);\n\t\tif (sz < 0) {\n\t\t\terr = sz;\n\t\t\tgoto out_free_skb;\n\t\t}\n\t\t*buf++ = val;\n\t\tlen += sz;\n\t} while (len < buf_len);\n\n\t \n\tsz = ocelot_rx_frame_word(ocelot, grp, false, &val);\n\tif (sz < 0) {\n\t\terr = sz;\n\t\tgoto out_free_skb;\n\t}\n\n\t \n\tlen -= ETH_FCS_LEN - sz;\n\n\tif (unlikely(dev->features & NETIF_F_RXFCS)) {\n\t\tbuf = (u32 *)skb_put(skb, ETH_FCS_LEN);\n\t\t*buf = val;\n\t}\n\n\tif (ocelot->ptp)\n\t\tocelot_ptp_rx_timestamp(ocelot, skb, timestamp);\n\n\t \n\tif (ocelot->ports[src_port]->bridge)\n\t\tskb->offload_fwd_mark = 1;\n\n\tskb->protocol = eth_type_trans(skb, dev);\n\n\t*nskb = skb;\n\n\treturn 0;\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\nEXPORT_SYMBOL(ocelot_xtr_poll_frame);\n\nbool ocelot_can_inject(struct ocelot *ocelot, int grp)\n{\n\tu32 val = ocelot_read(ocelot, QS_INJ_STATUS);\n\n\tif (!(val & QS_INJ_STATUS_FIFO_RDY(BIT(grp))))\n\t\treturn false;\n\tif (val & QS_INJ_STATUS_WMARK_REACHED(BIT(grp)))\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL(ocelot_can_inject);\n\nvoid ocelot_ifh_port_set(void *ifh, int port, u32 rew_op, u32 vlan_tag)\n{\n\tocelot_ifh_set_bypass(ifh, 1);\n\tocelot_ifh_set_dest(ifh, BIT_ULL(port));\n\tocelot_ifh_set_tag_type(ifh, IFH_TAG_TYPE_C);\n\tif (vlan_tag)\n\t\tocelot_ifh_set_vlan_tci(ifh, vlan_tag);\n\tif (rew_op)\n\t\tocelot_ifh_set_rew_op(ifh, rew_op);\n}\nEXPORT_SYMBOL(ocelot_ifh_port_set);\n\nvoid ocelot_port_inject_frame(struct ocelot *ocelot, int port, int grp,\n\t\t\t      u32 rew_op, struct sk_buff *skb)\n{\n\tu32 ifh[OCELOT_TAG_LEN / 4] = {0};\n\tunsigned int i, count, last;\n\n\tocelot_write_rix(ocelot, QS_INJ_CTRL_GAP_SIZE(1) |\n\t\t\t QS_INJ_CTRL_SOF, QS_INJ_CTRL, grp);\n\n\tocelot_ifh_port_set(ifh, port, rew_op, skb_vlan_tag_get(skb));\n\n\tfor (i = 0; i < OCELOT_TAG_LEN / 4; i++)\n\t\tocelot_write_rix(ocelot, ifh[i], QS_INJ_WR, grp);\n\n\tcount = DIV_ROUND_UP(skb->len, 4);\n\tlast = skb->len % 4;\n\tfor (i = 0; i < count; i++)\n\t\tocelot_write_rix(ocelot, ((u32 *)skb->data)[i], QS_INJ_WR, grp);\n\n\t \n\twhile (i < (OCELOT_BUFFER_CELL_SZ / 4)) {\n\t\tocelot_write_rix(ocelot, 0, QS_INJ_WR, grp);\n\t\ti++;\n\t}\n\n\t \n\tocelot_write_rix(ocelot, QS_INJ_CTRL_GAP_SIZE(1) |\n\t\t\t QS_INJ_CTRL_VLD_BYTES(skb->len < OCELOT_BUFFER_CELL_SZ ? 0 : last) |\n\t\t\t QS_INJ_CTRL_EOF,\n\t\t\t QS_INJ_CTRL, grp);\n\n\t \n\tocelot_write_rix(ocelot, 0, QS_INJ_WR, grp);\n\tskb_tx_timestamp(skb);\n\n\tskb->dev->stats.tx_packets++;\n\tskb->dev->stats.tx_bytes += skb->len;\n}\nEXPORT_SYMBOL(ocelot_port_inject_frame);\n\nvoid ocelot_drain_cpu_queue(struct ocelot *ocelot, int grp)\n{\n\twhile (ocelot_read(ocelot, QS_XTR_DATA_PRESENT) & BIT(grp))\n\t\tocelot_read_rix(ocelot, QS_XTR_RD, grp);\n}\nEXPORT_SYMBOL(ocelot_drain_cpu_queue);\n\nint ocelot_fdb_add(struct ocelot *ocelot, int port, const unsigned char *addr,\n\t\t   u16 vid, const struct net_device *bridge)\n{\n\tif (!vid)\n\t\tvid = ocelot_vlan_unaware_pvid(ocelot, bridge);\n\n\treturn ocelot_mact_learn(ocelot, port, addr, vid, ENTRYTYPE_LOCKED);\n}\nEXPORT_SYMBOL(ocelot_fdb_add);\n\nint ocelot_fdb_del(struct ocelot *ocelot, int port, const unsigned char *addr,\n\t\t   u16 vid, const struct net_device *bridge)\n{\n\tif (!vid)\n\t\tvid = ocelot_vlan_unaware_pvid(ocelot, bridge);\n\n\treturn ocelot_mact_forget(ocelot, addr, vid);\n}\nEXPORT_SYMBOL(ocelot_fdb_del);\n\n \nstatic int ocelot_mact_read(struct ocelot *ocelot, int port, int row, int col,\n\t\t\t    struct ocelot_mact_entry *entry)\n{\n\tu32 val, dst, macl, mach;\n\tchar mac[ETH_ALEN];\n\n\t \n\tocelot_field_write(ocelot, ANA_TABLES_MACTINDX_M_INDEX, row);\n\tocelot_field_write(ocelot, ANA_TABLES_MACTINDX_BUCKET, col);\n\n\t \n\tocelot_write(ocelot,\n\t\t     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_READ),\n\t\t     ANA_TABLES_MACACCESS);\n\n\tif (ocelot_mact_wait_for_completion(ocelot))\n\t\treturn -ETIMEDOUT;\n\n\t \n\tval = ocelot_read(ocelot, ANA_TABLES_MACACCESS);\n\tif (!(val & ANA_TABLES_MACACCESS_VALID))\n\t\treturn -EINVAL;\n\n\t \n\tdst = (val & ANA_TABLES_MACACCESS_DEST_IDX_M) >> 3;\n\tif (dst != port)\n\t\treturn -EINVAL;\n\n\t \n\tmacl = ocelot_read(ocelot, ANA_TABLES_MACLDATA);\n\tmach = ocelot_read(ocelot, ANA_TABLES_MACHDATA);\n\n\tmac[0] = (mach >> 8)  & 0xff;\n\tmac[1] = (mach >> 0)  & 0xff;\n\tmac[2] = (macl >> 24) & 0xff;\n\tmac[3] = (macl >> 16) & 0xff;\n\tmac[4] = (macl >> 8)  & 0xff;\n\tmac[5] = (macl >> 0)  & 0xff;\n\n\tentry->vid = (mach >> 16) & 0xfff;\n\tether_addr_copy(entry->mac, mac);\n\n\treturn 0;\n}\n\nint ocelot_mact_flush(struct ocelot *ocelot, int port)\n{\n\tint err;\n\n\tmutex_lock(&ocelot->mact_lock);\n\n\t \n\tocelot_write(ocelot, ANA_ANAGEFIL_PID_EN | ANA_ANAGEFIL_PID_VAL(port),\n\t\t     ANA_ANAGEFIL);\n\n\t \n\tocelot_write(ocelot,\n\t\t     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_AGE),\n\t\t     ANA_TABLES_MACACCESS);\n\n\terr = ocelot_mact_wait_for_completion(ocelot);\n\tif (err) {\n\t\tmutex_unlock(&ocelot->mact_lock);\n\t\treturn err;\n\t}\n\n\t \n\tocelot_write(ocelot,\n\t\t     ANA_TABLES_MACACCESS_MAC_TABLE_CMD(MACACCESS_CMD_AGE),\n\t\t     ANA_TABLES_MACACCESS);\n\n\terr = ocelot_mact_wait_for_completion(ocelot);\n\n\t \n\tocelot_write(ocelot, 0, ANA_ANAGEFIL);\n\n\tmutex_unlock(&ocelot->mact_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ocelot_mact_flush);\n\nint ocelot_fdb_dump(struct ocelot *ocelot, int port,\n\t\t    dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tint err = 0;\n\tint i, j;\n\n\t \n\tmutex_lock(&ocelot->mact_lock);\n\n\t \n\tfor (i = 0; i < ocelot->num_mact_rows; i++) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tstruct ocelot_mact_entry entry;\n\t\t\tbool is_static;\n\n\t\t\terr = ocelot_mact_read(ocelot, port, i, j, &entry);\n\t\t\t \n\t\t\tif (err == -EINVAL)\n\t\t\t\tcontinue;\n\t\t\telse if (err)\n\t\t\t\tbreak;\n\n\t\t\tis_static = (entry.type == ENTRYTYPE_LOCKED);\n\n\t\t\t \n\t\t\tif (entry.vid > OCELOT_RSV_VLAN_RANGE_START)\n\t\t\t\tentry.vid = 0;\n\n\t\t\terr = cb(entry.mac, entry.vid, is_static, data);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&ocelot->mact_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(ocelot_fdb_dump);\n\nint ocelot_trap_add(struct ocelot *ocelot, int port,\n\t\t    unsigned long cookie, bool take_ts,\n\t\t    void (*populate)(struct ocelot_vcap_filter *f))\n{\n\tstruct ocelot_vcap_block *block_vcap_is2;\n\tstruct ocelot_vcap_filter *trap;\n\tbool new = false;\n\tint err;\n\n\tblock_vcap_is2 = &ocelot->block[VCAP_IS2];\n\n\ttrap = ocelot_vcap_block_find_filter_by_id(block_vcap_is2, cookie,\n\t\t\t\t\t\t   false);\n\tif (!trap) {\n\t\ttrap = kzalloc(sizeof(*trap), GFP_KERNEL);\n\t\tif (!trap)\n\t\t\treturn -ENOMEM;\n\n\t\tpopulate(trap);\n\t\ttrap->prio = 1;\n\t\ttrap->id.cookie = cookie;\n\t\ttrap->id.tc_offload = false;\n\t\ttrap->block_id = VCAP_IS2;\n\t\ttrap->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\t\ttrap->lookup = 0;\n\t\ttrap->action.cpu_copy_ena = true;\n\t\ttrap->action.mask_mode = OCELOT_MASK_MODE_PERMIT_DENY;\n\t\ttrap->action.port_mask = 0;\n\t\ttrap->take_ts = take_ts;\n\t\ttrap->is_trap = true;\n\t\tnew = true;\n\t}\n\n\ttrap->ingress_port_mask |= BIT(port);\n\n\tif (new)\n\t\terr = ocelot_vcap_filter_add(ocelot, trap, NULL);\n\telse\n\t\terr = ocelot_vcap_filter_replace(ocelot, trap);\n\tif (err) {\n\t\ttrap->ingress_port_mask &= ~BIT(port);\n\t\tif (!trap->ingress_port_mask)\n\t\t\tkfree(trap);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint ocelot_trap_del(struct ocelot *ocelot, int port, unsigned long cookie)\n{\n\tstruct ocelot_vcap_block *block_vcap_is2;\n\tstruct ocelot_vcap_filter *trap;\n\n\tblock_vcap_is2 = &ocelot->block[VCAP_IS2];\n\n\ttrap = ocelot_vcap_block_find_filter_by_id(block_vcap_is2, cookie,\n\t\t\t\t\t\t   false);\n\tif (!trap)\n\t\treturn 0;\n\n\ttrap->ingress_port_mask &= ~BIT(port);\n\tif (!trap->ingress_port_mask)\n\t\treturn ocelot_vcap_filter_del(ocelot, trap);\n\n\treturn ocelot_vcap_filter_replace(ocelot, trap);\n}\n\nstatic u32 ocelot_get_bond_mask(struct ocelot *ocelot, struct net_device *bond)\n{\n\tu32 mask = 0;\n\tint port;\n\n\tlockdep_assert_held(&ocelot->fwd_domain_lock);\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\t\tif (!ocelot_port)\n\t\t\tcontinue;\n\n\t\tif (ocelot_port->bond == bond)\n\t\t\tmask |= BIT(port);\n\t}\n\n\treturn mask;\n}\n\n \nint ocelot_bond_get_id(struct ocelot *ocelot, struct net_device *bond)\n{\n\tint bond_mask = ocelot_get_bond_mask(ocelot, bond);\n\n\tif (!bond_mask)\n\t\treturn -ENOENT;\n\n\treturn __ffs(bond_mask);\n}\nEXPORT_SYMBOL_GPL(ocelot_bond_get_id);\n\n \nstatic u32 ocelot_dsa_8021q_cpu_assigned_ports(struct ocelot *ocelot,\n\t\t\t\t\t       struct ocelot_port *cpu)\n{\n\tu32 mask = 0;\n\tint port;\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\t\tif (!ocelot_port)\n\t\t\tcontinue;\n\n\t\tif (ocelot_port->dsa_8021q_cpu == cpu)\n\t\t\tmask |= BIT(port);\n\t}\n\n\tif (cpu->bond)\n\t\tmask &= ~ocelot_get_bond_mask(ocelot, cpu->bond);\n\n\treturn mask;\n}\n\n \nu32 ocelot_port_assigned_dsa_8021q_cpu_mask(struct ocelot *ocelot, int port)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tstruct ocelot_port *cpu_port = ocelot_port->dsa_8021q_cpu;\n\n\tif (!cpu_port)\n\t\treturn 0;\n\n\tif (cpu_port->bond)\n\t\treturn ocelot_get_bond_mask(ocelot, cpu_port->bond);\n\n\treturn BIT(cpu_port->index);\n}\nEXPORT_SYMBOL_GPL(ocelot_port_assigned_dsa_8021q_cpu_mask);\n\nu32 ocelot_get_bridge_fwd_mask(struct ocelot *ocelot, int src_port)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[src_port];\n\tconst struct net_device *bridge;\n\tu32 mask = 0;\n\tint port;\n\n\tif (!ocelot_port || ocelot_port->stp_state != BR_STATE_FORWARDING)\n\t\treturn 0;\n\n\tbridge = ocelot_port->bridge;\n\tif (!bridge)\n\t\treturn 0;\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tocelot_port = ocelot->ports[port];\n\n\t\tif (!ocelot_port)\n\t\t\tcontinue;\n\n\t\tif (ocelot_port->stp_state == BR_STATE_FORWARDING &&\n\t\t    ocelot_port->bridge == bridge)\n\t\t\tmask |= BIT(port);\n\t}\n\n\treturn mask;\n}\nEXPORT_SYMBOL_GPL(ocelot_get_bridge_fwd_mask);\n\nstatic void ocelot_apply_bridge_fwd_mask(struct ocelot *ocelot, bool joining)\n{\n\tint port;\n\n\tlockdep_assert_held(&ocelot->fwd_domain_lock);\n\n\t \n\tif (joining && ocelot->ops->cut_through_fwd)\n\t\tocelot->ops->cut_through_fwd(ocelot);\n\n\t \n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\t\tunsigned long mask;\n\n\t\tif (!ocelot_port) {\n\t\t\t \n\t\t\tmask = 0;\n\t\t} else if (ocelot_port->is_dsa_8021q_cpu) {\n\t\t\t \n\t\t\tmask = ocelot_dsa_8021q_cpu_assigned_ports(ocelot,\n\t\t\t\t\t\t\t\t   ocelot_port);\n\t\t} else if (ocelot_port->bridge) {\n\t\t\tstruct net_device *bond = ocelot_port->bond;\n\n\t\t\tmask = ocelot_get_bridge_fwd_mask(ocelot, port);\n\t\t\tmask &= ~BIT(port);\n\n\t\t\tmask |= ocelot_port_assigned_dsa_8021q_cpu_mask(ocelot,\n\t\t\t\t\t\t\t\t\tport);\n\n\t\t\tif (bond)\n\t\t\t\tmask &= ~ocelot_get_bond_mask(ocelot, bond);\n\t\t} else {\n\t\t\t \n\t\t\tmask = ocelot_port_assigned_dsa_8021q_cpu_mask(ocelot,\n\t\t\t\t\t\t\t\t       port);\n\t\t}\n\n\t\tocelot_write_rix(ocelot, mask, ANA_PGID_PGID, PGID_SRC + port);\n\t}\n\n\t \n\tif (!joining && ocelot->ops->cut_through_fwd)\n\t\tocelot->ops->cut_through_fwd(ocelot);\n}\n\n \nstatic void ocelot_update_pgid_cpu(struct ocelot *ocelot)\n{\n\tint pgid_cpu = 0;\n\tint port;\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\t\tif (!ocelot_port || !ocelot_port->is_dsa_8021q_cpu)\n\t\t\tcontinue;\n\n\t\tpgid_cpu |= BIT(port);\n\t}\n\n\tif (!pgid_cpu)\n\t\tpgid_cpu = BIT(ocelot->num_phys_ports);\n\n\tocelot_write_rix(ocelot, pgid_cpu, ANA_PGID_PGID, PGID_CPU);\n}\n\nvoid ocelot_port_setup_dsa_8021q_cpu(struct ocelot *ocelot, int cpu)\n{\n\tstruct ocelot_port *cpu_port = ocelot->ports[cpu];\n\tu16 vid;\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tcpu_port->is_dsa_8021q_cpu = true;\n\n\tfor (vid = OCELOT_RSV_VLAN_RANGE_START; vid < VLAN_N_VID; vid++)\n\t\tocelot_vlan_member_add(ocelot, cpu, vid, true);\n\n\tocelot_update_pgid_cpu(ocelot);\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n}\nEXPORT_SYMBOL_GPL(ocelot_port_setup_dsa_8021q_cpu);\n\nvoid ocelot_port_teardown_dsa_8021q_cpu(struct ocelot *ocelot, int cpu)\n{\n\tstruct ocelot_port *cpu_port = ocelot->ports[cpu];\n\tu16 vid;\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tcpu_port->is_dsa_8021q_cpu = false;\n\n\tfor (vid = OCELOT_RSV_VLAN_RANGE_START; vid < VLAN_N_VID; vid++)\n\t\tocelot_vlan_member_del(ocelot, cpu_port->index, vid);\n\n\tocelot_update_pgid_cpu(ocelot);\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n}\nEXPORT_SYMBOL_GPL(ocelot_port_teardown_dsa_8021q_cpu);\n\nvoid ocelot_port_assign_dsa_8021q_cpu(struct ocelot *ocelot, int port,\n\t\t\t\t      int cpu)\n{\n\tstruct ocelot_port *cpu_port = ocelot->ports[cpu];\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tocelot->ports[port]->dsa_8021q_cpu = cpu_port;\n\tocelot_apply_bridge_fwd_mask(ocelot, true);\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n}\nEXPORT_SYMBOL_GPL(ocelot_port_assign_dsa_8021q_cpu);\n\nvoid ocelot_port_unassign_dsa_8021q_cpu(struct ocelot *ocelot, int port)\n{\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tocelot->ports[port]->dsa_8021q_cpu = NULL;\n\tocelot_apply_bridge_fwd_mask(ocelot, true);\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n}\nEXPORT_SYMBOL_GPL(ocelot_port_unassign_dsa_8021q_cpu);\n\nvoid ocelot_bridge_stp_state_set(struct ocelot *ocelot, int port, u8 state)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tu32 learn_ena = 0;\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tocelot_port->stp_state = state;\n\n\tif ((state == BR_STATE_LEARNING || state == BR_STATE_FORWARDING) &&\n\t    ocelot_port->learn_ena)\n\t\tlearn_ena = ANA_PORT_PORT_CFG_LEARN_ENA;\n\n\tocelot_rmw_gix(ocelot, learn_ena, ANA_PORT_PORT_CFG_LEARN_ENA,\n\t\t       ANA_PORT_PORT_CFG, port);\n\n\tocelot_apply_bridge_fwd_mask(ocelot, state == BR_STATE_FORWARDING);\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n}\nEXPORT_SYMBOL(ocelot_bridge_stp_state_set);\n\nvoid ocelot_set_ageing_time(struct ocelot *ocelot, unsigned int msecs)\n{\n\tunsigned int age_period = ANA_AUTOAGE_AGE_PERIOD(msecs / 2000);\n\n\t \n\tif (!age_period)\n\t\tage_period = 1;\n\n\tocelot_rmw(ocelot, age_period, ANA_AUTOAGE_AGE_PERIOD_M, ANA_AUTOAGE);\n}\nEXPORT_SYMBOL(ocelot_set_ageing_time);\n\nstatic struct ocelot_multicast *ocelot_multicast_get(struct ocelot *ocelot,\n\t\t\t\t\t\t     const unsigned char *addr,\n\t\t\t\t\t\t     u16 vid)\n{\n\tstruct ocelot_multicast *mc;\n\n\tlist_for_each_entry(mc, &ocelot->multicast, list) {\n\t\tif (ether_addr_equal(mc->addr, addr) && mc->vid == vid)\n\t\t\treturn mc;\n\t}\n\n\treturn NULL;\n}\n\nstatic enum macaccess_entry_type ocelot_classify_mdb(const unsigned char *addr)\n{\n\tif (addr[0] == 0x01 && addr[1] == 0x00 && addr[2] == 0x5e)\n\t\treturn ENTRYTYPE_MACv4;\n\tif (addr[0] == 0x33 && addr[1] == 0x33)\n\t\treturn ENTRYTYPE_MACv6;\n\treturn ENTRYTYPE_LOCKED;\n}\n\nstatic struct ocelot_pgid *ocelot_pgid_alloc(struct ocelot *ocelot, int index,\n\t\t\t\t\t     unsigned long ports)\n{\n\tstruct ocelot_pgid *pgid;\n\n\tpgid = kzalloc(sizeof(*pgid), GFP_KERNEL);\n\tif (!pgid)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpgid->ports = ports;\n\tpgid->index = index;\n\trefcount_set(&pgid->refcount, 1);\n\tlist_add_tail(&pgid->list, &ocelot->pgids);\n\n\treturn pgid;\n}\n\nstatic void ocelot_pgid_free(struct ocelot *ocelot, struct ocelot_pgid *pgid)\n{\n\tif (!refcount_dec_and_test(&pgid->refcount))\n\t\treturn;\n\n\tlist_del(&pgid->list);\n\tkfree(pgid);\n}\n\nstatic struct ocelot_pgid *ocelot_mdb_get_pgid(struct ocelot *ocelot,\n\t\t\t\t\t       const struct ocelot_multicast *mc)\n{\n\tstruct ocelot_pgid *pgid;\n\tint index;\n\n\t \n\tif (mc->entry_type == ENTRYTYPE_MACv4 ||\n\t    mc->entry_type == ENTRYTYPE_MACv6)\n\t\treturn ocelot_pgid_alloc(ocelot, 0, mc->ports);\n\n\tlist_for_each_entry(pgid, &ocelot->pgids, list) {\n\t\t \n\t\tif (pgid->index && pgid->ports == mc->ports) {\n\t\t\trefcount_inc(&pgid->refcount);\n\t\t\treturn pgid;\n\t\t}\n\t}\n\n\t \n\tfor_each_nonreserved_multicast_dest_pgid(ocelot, index) {\n\t\tbool used = false;\n\n\t\tlist_for_each_entry(pgid, &ocelot->pgids, list) {\n\t\t\tif (pgid->index == index) {\n\t\t\t\tused = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!used)\n\t\t\treturn ocelot_pgid_alloc(ocelot, index, mc->ports);\n\t}\n\n\treturn ERR_PTR(-ENOSPC);\n}\n\nstatic void ocelot_encode_ports_to_mdb(unsigned char *addr,\n\t\t\t\t       struct ocelot_multicast *mc)\n{\n\tether_addr_copy(addr, mc->addr);\n\n\tif (mc->entry_type == ENTRYTYPE_MACv4) {\n\t\taddr[0] = 0;\n\t\taddr[1] = mc->ports >> 8;\n\t\taddr[2] = mc->ports & 0xff;\n\t} else if (mc->entry_type == ENTRYTYPE_MACv6) {\n\t\taddr[0] = mc->ports >> 8;\n\t\taddr[1] = mc->ports & 0xff;\n\t}\n}\n\nint ocelot_port_mdb_add(struct ocelot *ocelot, int port,\n\t\t\tconst struct switchdev_obj_port_mdb *mdb,\n\t\t\tconst struct net_device *bridge)\n{\n\tunsigned char addr[ETH_ALEN];\n\tstruct ocelot_multicast *mc;\n\tstruct ocelot_pgid *pgid;\n\tu16 vid = mdb->vid;\n\n\tif (!vid)\n\t\tvid = ocelot_vlan_unaware_pvid(ocelot, bridge);\n\n\tmc = ocelot_multicast_get(ocelot, mdb->addr, vid);\n\tif (!mc) {\n\t\t \n\t\tmc = devm_kzalloc(ocelot->dev, sizeof(*mc), GFP_KERNEL);\n\t\tif (!mc)\n\t\t\treturn -ENOMEM;\n\n\t\tmc->entry_type = ocelot_classify_mdb(mdb->addr);\n\t\tether_addr_copy(mc->addr, mdb->addr);\n\t\tmc->vid = vid;\n\n\t\tlist_add_tail(&mc->list, &ocelot->multicast);\n\t} else {\n\t\t \n\t\tocelot_pgid_free(ocelot, mc->pgid);\n\t\tocelot_encode_ports_to_mdb(addr, mc);\n\t\tocelot_mact_forget(ocelot, addr, vid);\n\t}\n\n\tmc->ports |= BIT(port);\n\n\tpgid = ocelot_mdb_get_pgid(ocelot, mc);\n\tif (IS_ERR(pgid)) {\n\t\tdev_err(ocelot->dev,\n\t\t\t\"Cannot allocate PGID for mdb %pM vid %d\\n\",\n\t\t\tmc->addr, mc->vid);\n\t\tdevm_kfree(ocelot->dev, mc);\n\t\treturn PTR_ERR(pgid);\n\t}\n\tmc->pgid = pgid;\n\n\tocelot_encode_ports_to_mdb(addr, mc);\n\n\tif (mc->entry_type != ENTRYTYPE_MACv4 &&\n\t    mc->entry_type != ENTRYTYPE_MACv6)\n\t\tocelot_write_rix(ocelot, pgid->ports, ANA_PGID_PGID,\n\t\t\t\t pgid->index);\n\n\treturn ocelot_mact_learn(ocelot, pgid->index, addr, vid,\n\t\t\t\t mc->entry_type);\n}\nEXPORT_SYMBOL(ocelot_port_mdb_add);\n\nint ocelot_port_mdb_del(struct ocelot *ocelot, int port,\n\t\t\tconst struct switchdev_obj_port_mdb *mdb,\n\t\t\tconst struct net_device *bridge)\n{\n\tunsigned char addr[ETH_ALEN];\n\tstruct ocelot_multicast *mc;\n\tstruct ocelot_pgid *pgid;\n\tu16 vid = mdb->vid;\n\n\tif (!vid)\n\t\tvid = ocelot_vlan_unaware_pvid(ocelot, bridge);\n\n\tmc = ocelot_multicast_get(ocelot, mdb->addr, vid);\n\tif (!mc)\n\t\treturn -ENOENT;\n\n\tocelot_encode_ports_to_mdb(addr, mc);\n\tocelot_mact_forget(ocelot, addr, vid);\n\n\tocelot_pgid_free(ocelot, mc->pgid);\n\tmc->ports &= ~BIT(port);\n\tif (!mc->ports) {\n\t\tlist_del(&mc->list);\n\t\tdevm_kfree(ocelot->dev, mc);\n\t\treturn 0;\n\t}\n\n\t \n\tpgid = ocelot_mdb_get_pgid(ocelot, mc);\n\tif (IS_ERR(pgid))\n\t\treturn PTR_ERR(pgid);\n\tmc->pgid = pgid;\n\n\tocelot_encode_ports_to_mdb(addr, mc);\n\n\tif (mc->entry_type != ENTRYTYPE_MACv4 &&\n\t    mc->entry_type != ENTRYTYPE_MACv6)\n\t\tocelot_write_rix(ocelot, pgid->ports, ANA_PGID_PGID,\n\t\t\t\t pgid->index);\n\n\treturn ocelot_mact_learn(ocelot, pgid->index, addr, vid,\n\t\t\t\t mc->entry_type);\n}\nEXPORT_SYMBOL(ocelot_port_mdb_del);\n\nint ocelot_port_bridge_join(struct ocelot *ocelot, int port,\n\t\t\t    struct net_device *bridge, int bridge_num,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tint err;\n\n\terr = ocelot_single_vlan_aware_bridge(ocelot, extack);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tocelot_port->bridge = bridge;\n\tocelot_port->bridge_num = bridge_num;\n\n\tocelot_apply_bridge_fwd_mask(ocelot, true);\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n\n\tif (br_vlan_enabled(bridge))\n\t\treturn 0;\n\n\treturn ocelot_add_vlan_unaware_pvid(ocelot, port, bridge);\n}\nEXPORT_SYMBOL(ocelot_port_bridge_join);\n\nvoid ocelot_port_bridge_leave(struct ocelot *ocelot, int port,\n\t\t\t      struct net_device *bridge)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tif (!br_vlan_enabled(bridge))\n\t\tocelot_del_vlan_unaware_pvid(ocelot, port, bridge);\n\n\tocelot_port->bridge = NULL;\n\tocelot_port->bridge_num = -1;\n\n\tocelot_port_set_pvid(ocelot, port, NULL);\n\tocelot_port_manage_port_tag(ocelot, port);\n\tocelot_apply_bridge_fwd_mask(ocelot, false);\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n}\nEXPORT_SYMBOL(ocelot_port_bridge_leave);\n\nstatic void ocelot_set_aggr_pgids(struct ocelot *ocelot)\n{\n\tunsigned long visited = GENMASK(ocelot->num_phys_ports - 1, 0);\n\tint i, port, lag;\n\n\t \n\tfor_each_unicast_dest_pgid(ocelot, port)\n\t\tocelot_write_rix(ocelot, BIT(port), ANA_PGID_PGID, port);\n\n\tfor_each_aggr_pgid(ocelot, i)\n\t\tocelot_write_rix(ocelot, GENMASK(ocelot->num_phys_ports - 1, 0),\n\t\t\t\t ANA_PGID_PGID, i);\n\n\t \n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\t\tif (!ocelot_port || !ocelot_port->bond)\n\t\t\tcontinue;\n\n\t\tvisited &= ~BIT(port);\n\t}\n\n\t \n\tfor (lag = 0; lag < ocelot->num_phys_ports; lag++) {\n\t\tstruct net_device *bond = ocelot->ports[lag]->bond;\n\t\tint num_active_ports = 0;\n\t\tunsigned long bond_mask;\n\t\tu8 aggr_idx[16];\n\n\t\tif (!bond || (visited & BIT(lag)))\n\t\t\tcontinue;\n\n\t\tbond_mask = ocelot_get_bond_mask(ocelot, bond);\n\n\t\tfor_each_set_bit(port, &bond_mask, ocelot->num_phys_ports) {\n\t\t\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\t\t\t\n\t\t\tocelot_write_rix(ocelot, bond_mask,\n\t\t\t\t\t ANA_PGID_PGID, port);\n\n\t\t\tif (ocelot_port->lag_tx_active)\n\t\t\t\taggr_idx[num_active_ports++] = port;\n\t\t}\n\n\t\tfor_each_aggr_pgid(ocelot, i) {\n\t\t\tu32 ac;\n\n\t\t\tac = ocelot_read_rix(ocelot, ANA_PGID_PGID, i);\n\t\t\tac &= ~bond_mask;\n\t\t\t \n\t\t\tif (num_active_ports)\n\t\t\t\tac |= BIT(aggr_idx[i % num_active_ports]);\n\t\t\tocelot_write_rix(ocelot, ac, ANA_PGID_PGID, i);\n\t\t}\n\n\t\t \n\t\tfor (port = lag; port < ocelot->num_phys_ports; port++) {\n\t\t\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\t\t\tif (!ocelot_port)\n\t\t\t\tcontinue;\n\n\t\t\tif (ocelot_port->bond == bond)\n\t\t\t\tvisited |= BIT(port);\n\t\t}\n\t}\n}\n\n \nstatic void ocelot_setup_logical_port_ids(struct ocelot *ocelot)\n{\n\tint port;\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\t\tstruct net_device *bond;\n\n\t\tif (!ocelot_port)\n\t\t\tcontinue;\n\n\t\tbond = ocelot_port->bond;\n\t\tif (bond) {\n\t\t\tint lag = ocelot_bond_get_id(ocelot, bond);\n\n\t\t\tocelot_rmw_gix(ocelot,\n\t\t\t\t       ANA_PORT_PORT_CFG_PORTID_VAL(lag),\n\t\t\t\t       ANA_PORT_PORT_CFG_PORTID_VAL_M,\n\t\t\t\t       ANA_PORT_PORT_CFG, port);\n\t\t} else {\n\t\t\tocelot_rmw_gix(ocelot,\n\t\t\t\t       ANA_PORT_PORT_CFG_PORTID_VAL(port),\n\t\t\t\t       ANA_PORT_PORT_CFG_PORTID_VAL_M,\n\t\t\t\t       ANA_PORT_PORT_CFG, port);\n\t\t}\n\t}\n}\n\nstatic int ocelot_migrate_mc(struct ocelot *ocelot, struct ocelot_multicast *mc,\n\t\t\t     unsigned long from_mask, unsigned long to_mask)\n{\n\tunsigned char addr[ETH_ALEN];\n\tstruct ocelot_pgid *pgid;\n\tu16 vid = mc->vid;\n\n\tdev_dbg(ocelot->dev,\n\t\t\"Migrating multicast %pM vid %d from port mask 0x%lx to 0x%lx\\n\",\n\t\tmc->addr, mc->vid, from_mask, to_mask);\n\n\t \n\tocelot_pgid_free(ocelot, mc->pgid);\n\tocelot_encode_ports_to_mdb(addr, mc);\n\tocelot_mact_forget(ocelot, addr, vid);\n\n\tmc->ports &= ~from_mask;\n\tmc->ports |= to_mask;\n\n\tpgid = ocelot_mdb_get_pgid(ocelot, mc);\n\tif (IS_ERR(pgid)) {\n\t\tdev_err(ocelot->dev,\n\t\t\t\"Cannot allocate PGID for mdb %pM vid %d\\n\",\n\t\t\tmc->addr, mc->vid);\n\t\tdevm_kfree(ocelot->dev, mc);\n\t\treturn PTR_ERR(pgid);\n\t}\n\tmc->pgid = pgid;\n\n\tocelot_encode_ports_to_mdb(addr, mc);\n\n\tif (mc->entry_type != ENTRYTYPE_MACv4 &&\n\t    mc->entry_type != ENTRYTYPE_MACv6)\n\t\tocelot_write_rix(ocelot, pgid->ports, ANA_PGID_PGID,\n\t\t\t\t pgid->index);\n\n\treturn ocelot_mact_learn(ocelot, pgid->index, addr, vid,\n\t\t\t\t mc->entry_type);\n}\n\nint ocelot_migrate_mdbs(struct ocelot *ocelot, unsigned long from_mask,\n\t\t\tunsigned long to_mask)\n{\n\tstruct ocelot_multicast *mc;\n\tint err;\n\n\tlist_for_each_entry(mc, &ocelot->multicast, list) {\n\t\tif (!(mc->ports & from_mask))\n\t\t\tcontinue;\n\n\t\terr = ocelot_migrate_mc(ocelot, mc, from_mask, to_mask);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocelot_migrate_mdbs);\n\n \nstatic void ocelot_migrate_lag_fdbs(struct ocelot *ocelot,\n\t\t\t\t    struct net_device *bond,\n\t\t\t\t    int lag)\n{\n\tstruct ocelot_lag_fdb *fdb;\n\tint err;\n\n\tlockdep_assert_held(&ocelot->fwd_domain_lock);\n\n\tlist_for_each_entry(fdb, &ocelot->lag_fdbs, list) {\n\t\tif (fdb->bond != bond)\n\t\t\tcontinue;\n\n\t\terr = ocelot_mact_forget(ocelot, fdb->addr, fdb->vid);\n\t\tif (err) {\n\t\t\tdev_err(ocelot->dev,\n\t\t\t\t\"failed to delete LAG %s FDB %pM vid %d: %pe\\n\",\n\t\t\t\tbond->name, fdb->addr, fdb->vid, ERR_PTR(err));\n\t\t}\n\n\t\terr = ocelot_mact_learn(ocelot, lag, fdb->addr, fdb->vid,\n\t\t\t\t\tENTRYTYPE_LOCKED);\n\t\tif (err) {\n\t\t\tdev_err(ocelot->dev,\n\t\t\t\t\"failed to migrate LAG %s FDB %pM vid %d: %pe\\n\",\n\t\t\t\tbond->name, fdb->addr, fdb->vid, ERR_PTR(err));\n\t\t}\n\t}\n}\n\nint ocelot_port_lag_join(struct ocelot *ocelot, int port,\n\t\t\t struct net_device *bond,\n\t\t\t struct netdev_lag_upper_info *info,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tif (info->tx_type != NETDEV_LAG_TX_TYPE_HASH) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Can only offload LAG using hash TX type\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tocelot->ports[port]->bond = bond;\n\n\tocelot_setup_logical_port_ids(ocelot);\n\tocelot_apply_bridge_fwd_mask(ocelot, true);\n\tocelot_set_aggr_pgids(ocelot);\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_port_lag_join);\n\nvoid ocelot_port_lag_leave(struct ocelot *ocelot, int port,\n\t\t\t   struct net_device *bond)\n{\n\tint old_lag_id, new_lag_id;\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\told_lag_id = ocelot_bond_get_id(ocelot, bond);\n\n\tocelot->ports[port]->bond = NULL;\n\n\tocelot_setup_logical_port_ids(ocelot);\n\tocelot_apply_bridge_fwd_mask(ocelot, false);\n\tocelot_set_aggr_pgids(ocelot);\n\n\tnew_lag_id = ocelot_bond_get_id(ocelot, bond);\n\n\tif (new_lag_id >= 0 && old_lag_id != new_lag_id)\n\t\tocelot_migrate_lag_fdbs(ocelot, bond, new_lag_id);\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n}\nEXPORT_SYMBOL(ocelot_port_lag_leave);\n\nvoid ocelot_port_lag_change(struct ocelot *ocelot, int port, bool lag_tx_active)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tocelot_port->lag_tx_active = lag_tx_active;\n\n\t \n\tocelot_set_aggr_pgids(ocelot);\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n}\nEXPORT_SYMBOL(ocelot_port_lag_change);\n\nint ocelot_lag_fdb_add(struct ocelot *ocelot, struct net_device *bond,\n\t\t       const unsigned char *addr, u16 vid,\n\t\t       const struct net_device *bridge)\n{\n\tstruct ocelot_lag_fdb *fdb;\n\tint lag, err;\n\n\tfdb = kzalloc(sizeof(*fdb), GFP_KERNEL);\n\tif (!fdb)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tif (!vid)\n\t\tvid = ocelot_vlan_unaware_pvid(ocelot, bridge);\n\n\tether_addr_copy(fdb->addr, addr);\n\tfdb->vid = vid;\n\tfdb->bond = bond;\n\n\tlag = ocelot_bond_get_id(ocelot, bond);\n\n\terr = ocelot_mact_learn(ocelot, lag, addr, vid, ENTRYTYPE_LOCKED);\n\tif (err) {\n\t\tmutex_unlock(&ocelot->fwd_domain_lock);\n\t\tkfree(fdb);\n\t\treturn err;\n\t}\n\n\tlist_add_tail(&fdb->list, &ocelot->lag_fdbs);\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocelot_lag_fdb_add);\n\nint ocelot_lag_fdb_del(struct ocelot *ocelot, struct net_device *bond,\n\t\t       const unsigned char *addr, u16 vid,\n\t\t       const struct net_device *bridge)\n{\n\tstruct ocelot_lag_fdb *fdb, *tmp;\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tif (!vid)\n\t\tvid = ocelot_vlan_unaware_pvid(ocelot, bridge);\n\n\tlist_for_each_entry_safe(fdb, tmp, &ocelot->lag_fdbs, list) {\n\t\tif (!ether_addr_equal(fdb->addr, addr) || fdb->vid != vid ||\n\t\t    fdb->bond != bond)\n\t\t\tcontinue;\n\n\t\tocelot_mact_forget(ocelot, addr, vid);\n\t\tlist_del(&fdb->list);\n\t\tmutex_unlock(&ocelot->fwd_domain_lock);\n\t\tkfree(fdb);\n\n\t\treturn 0;\n\t}\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(ocelot_lag_fdb_del);\n\n \nvoid ocelot_port_set_maxlen(struct ocelot *ocelot, int port, size_t sdu)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tint maxlen = sdu + ETH_HLEN + ETH_FCS_LEN;\n\tint pause_start, pause_stop;\n\tint atop, atop_tot;\n\n\tif (port == ocelot->npi) {\n\t\tmaxlen += OCELOT_TAG_LEN;\n\n\t\tif (ocelot->npi_inj_prefix == OCELOT_TAG_PREFIX_SHORT)\n\t\t\tmaxlen += OCELOT_SHORT_PREFIX_LEN;\n\t\telse if (ocelot->npi_inj_prefix == OCELOT_TAG_PREFIX_LONG)\n\t\t\tmaxlen += OCELOT_LONG_PREFIX_LEN;\n\t}\n\n\tocelot_port_writel(ocelot_port, maxlen, DEV_MAC_MAXLEN_CFG);\n\n\t \n\tpause_start = 6 * maxlen / OCELOT_BUFFER_CELL_SZ;\n\tpause_stop = 4 * maxlen / OCELOT_BUFFER_CELL_SZ;\n\tocelot_fields_write(ocelot, port, SYS_PAUSE_CFG_PAUSE_START,\n\t\t\t    pause_start);\n\tocelot_fields_write(ocelot, port, SYS_PAUSE_CFG_PAUSE_STOP,\n\t\t\t    pause_stop);\n\n\t \n\tatop_tot = (ocelot->packet_buffer_size - 9 * maxlen) /\n\t\t   OCELOT_BUFFER_CELL_SZ;\n\tatop = (9 * maxlen) / OCELOT_BUFFER_CELL_SZ;\n\tocelot_write_rix(ocelot, ocelot->ops->wm_enc(atop), SYS_ATOP, port);\n\tocelot_write(ocelot, ocelot->ops->wm_enc(atop_tot), SYS_ATOP_TOT_CFG);\n}\nEXPORT_SYMBOL(ocelot_port_set_maxlen);\n\nint ocelot_get_max_mtu(struct ocelot *ocelot, int port)\n{\n\tint max_mtu = 65535 - ETH_HLEN - ETH_FCS_LEN;\n\n\tif (port == ocelot->npi) {\n\t\tmax_mtu -= OCELOT_TAG_LEN;\n\n\t\tif (ocelot->npi_inj_prefix == OCELOT_TAG_PREFIX_SHORT)\n\t\t\tmax_mtu -= OCELOT_SHORT_PREFIX_LEN;\n\t\telse if (ocelot->npi_inj_prefix == OCELOT_TAG_PREFIX_LONG)\n\t\t\tmax_mtu -= OCELOT_LONG_PREFIX_LEN;\n\t}\n\n\treturn max_mtu;\n}\nEXPORT_SYMBOL(ocelot_get_max_mtu);\n\nstatic void ocelot_port_set_learning(struct ocelot *ocelot, int port,\n\t\t\t\t     bool enabled)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tu32 val = 0;\n\n\tif (enabled)\n\t\tval = ANA_PORT_PORT_CFG_LEARN_ENA;\n\n\tocelot_rmw_gix(ocelot, val, ANA_PORT_PORT_CFG_LEARN_ENA,\n\t\t       ANA_PORT_PORT_CFG, port);\n\n\tocelot_port->learn_ena = enabled;\n}\n\nstatic void ocelot_port_set_ucast_flood(struct ocelot *ocelot, int port,\n\t\t\t\t\tbool enabled)\n{\n\tu32 val = 0;\n\n\tif (enabled)\n\t\tval = BIT(port);\n\n\tocelot_rmw_rix(ocelot, val, BIT(port), ANA_PGID_PGID, PGID_UC);\n}\n\nstatic void ocelot_port_set_mcast_flood(struct ocelot *ocelot, int port,\n\t\t\t\t\tbool enabled)\n{\n\tu32 val = 0;\n\n\tif (enabled)\n\t\tval = BIT(port);\n\n\tocelot_rmw_rix(ocelot, val, BIT(port), ANA_PGID_PGID, PGID_MC);\n\tocelot_rmw_rix(ocelot, val, BIT(port), ANA_PGID_PGID, PGID_MCIPV4);\n\tocelot_rmw_rix(ocelot, val, BIT(port), ANA_PGID_PGID, PGID_MCIPV6);\n}\n\nstatic void ocelot_port_set_bcast_flood(struct ocelot *ocelot, int port,\n\t\t\t\t\tbool enabled)\n{\n\tu32 val = 0;\n\n\tif (enabled)\n\t\tval = BIT(port);\n\n\tocelot_rmw_rix(ocelot, val, BIT(port), ANA_PGID_PGID, PGID_BC);\n}\n\nint ocelot_port_pre_bridge_flags(struct ocelot *ocelot, int port,\n\t\t\t\t struct switchdev_brport_flags flags)\n{\n\tif (flags.mask & ~(BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD |\n\t\t\t   BR_BCAST_FLOOD))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_port_pre_bridge_flags);\n\nvoid ocelot_port_bridge_flags(struct ocelot *ocelot, int port,\n\t\t\t      struct switchdev_brport_flags flags)\n{\n\tif (flags.mask & BR_LEARNING)\n\t\tocelot_port_set_learning(ocelot, port,\n\t\t\t\t\t !!(flags.val & BR_LEARNING));\n\n\tif (flags.mask & BR_FLOOD)\n\t\tocelot_port_set_ucast_flood(ocelot, port,\n\t\t\t\t\t    !!(flags.val & BR_FLOOD));\n\n\tif (flags.mask & BR_MCAST_FLOOD)\n\t\tocelot_port_set_mcast_flood(ocelot, port,\n\t\t\t\t\t    !!(flags.val & BR_MCAST_FLOOD));\n\n\tif (flags.mask & BR_BCAST_FLOOD)\n\t\tocelot_port_set_bcast_flood(ocelot, port,\n\t\t\t\t\t    !!(flags.val & BR_BCAST_FLOOD));\n}\nEXPORT_SYMBOL(ocelot_port_bridge_flags);\n\nint ocelot_port_get_default_prio(struct ocelot *ocelot, int port)\n{\n\tint val = ocelot_read_gix(ocelot, ANA_PORT_QOS_CFG, port);\n\n\treturn ANA_PORT_QOS_CFG_QOS_DEFAULT_VAL_X(val);\n}\nEXPORT_SYMBOL_GPL(ocelot_port_get_default_prio);\n\nint ocelot_port_set_default_prio(struct ocelot *ocelot, int port, u8 prio)\n{\n\tif (prio >= OCELOT_NUM_TC)\n\t\treturn -ERANGE;\n\n\tocelot_rmw_gix(ocelot,\n\t\t       ANA_PORT_QOS_CFG_QOS_DEFAULT_VAL(prio),\n\t\t       ANA_PORT_QOS_CFG_QOS_DEFAULT_VAL_M,\n\t\t       ANA_PORT_QOS_CFG,\n\t\t       port);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocelot_port_set_default_prio);\n\nint ocelot_port_get_dscp_prio(struct ocelot *ocelot, int port, u8 dscp)\n{\n\tint qos_cfg = ocelot_read_gix(ocelot, ANA_PORT_QOS_CFG, port);\n\tint dscp_cfg = ocelot_read_rix(ocelot, ANA_DSCP_CFG, dscp);\n\n\t \n\tif (!(qos_cfg & ANA_PORT_QOS_CFG_QOS_DSCP_ENA))\n\t\treturn -EOPNOTSUPP;\n\n\tif (qos_cfg & ANA_PORT_QOS_CFG_DSCP_TRANSLATE_ENA) {\n\t\tdscp = ANA_DSCP_CFG_DSCP_TRANSLATE_VAL_X(dscp_cfg);\n\t\t \n\t\tdscp_cfg = ocelot_read_rix(ocelot, ANA_DSCP_CFG, dscp);\n\t}\n\n\t \n\tif (!(dscp_cfg & ANA_DSCP_CFG_DSCP_TRUST_ENA))\n\t\treturn -EOPNOTSUPP;\n\n\treturn ANA_DSCP_CFG_QOS_DSCP_VAL_X(dscp_cfg);\n}\nEXPORT_SYMBOL_GPL(ocelot_port_get_dscp_prio);\n\nint ocelot_port_add_dscp_prio(struct ocelot *ocelot, int port, u8 dscp, u8 prio)\n{\n\tint mask, val;\n\n\tif (prio >= OCELOT_NUM_TC)\n\t\treturn -ERANGE;\n\n\t \n\tmask = ANA_PORT_QOS_CFG_QOS_DSCP_ENA |\n\t       ANA_PORT_QOS_CFG_DSCP_TRANSLATE_ENA;\n\n\tocelot_rmw_gix(ocelot, ANA_PORT_QOS_CFG_QOS_DSCP_ENA, mask,\n\t\t       ANA_PORT_QOS_CFG, port);\n\n\t \n\tval = ANA_DSCP_CFG_DSCP_TRUST_ENA | ANA_DSCP_CFG_QOS_DSCP_VAL(prio);\n\n\tocelot_write_rix(ocelot, val, ANA_DSCP_CFG, dscp);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocelot_port_add_dscp_prio);\n\nint ocelot_port_del_dscp_prio(struct ocelot *ocelot, int port, u8 dscp, u8 prio)\n{\n\tint dscp_cfg = ocelot_read_rix(ocelot, ANA_DSCP_CFG, dscp);\n\tint mask, i;\n\n\t \n\tif (ANA_DSCP_CFG_QOS_DSCP_VAL_X(dscp_cfg) != prio)\n\t\treturn 0;\n\n\t \n\tocelot_write_rix(ocelot, 0, ANA_DSCP_CFG, dscp);\n\n\tfor (i = 0; i < 64; i++) {\n\t\tint dscp_cfg = ocelot_read_rix(ocelot, ANA_DSCP_CFG, i);\n\n\t\t \n\t\tif (dscp_cfg & ANA_DSCP_CFG_DSCP_TRUST_ENA)\n\t\t\treturn 0;\n\t}\n\n\t \n\tmask = ANA_PORT_QOS_CFG_QOS_DSCP_ENA |\n\t       ANA_PORT_QOS_CFG_DSCP_TRANSLATE_ENA;\n\n\tocelot_rmw_gix(ocelot, 0, mask, ANA_PORT_QOS_CFG, port);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocelot_port_del_dscp_prio);\n\nstruct ocelot_mirror *ocelot_mirror_get(struct ocelot *ocelot, int to,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ocelot_mirror *m = ocelot->mirror;\n\n\tif (m) {\n\t\tif (m->to != to) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Mirroring already configured towards different egress port\");\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\t}\n\n\t\trefcount_inc(&m->refcount);\n\t\treturn m;\n\t}\n\n\tm = kzalloc(sizeof(*m), GFP_KERNEL);\n\tif (!m)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tm->to = to;\n\trefcount_set(&m->refcount, 1);\n\tocelot->mirror = m;\n\n\t \n\tocelot_write(ocelot, BIT(to), ANA_MIRRORPORTS);\n\n\treturn m;\n}\n\nvoid ocelot_mirror_put(struct ocelot *ocelot)\n{\n\tstruct ocelot_mirror *m = ocelot->mirror;\n\n\tif (!refcount_dec_and_test(&m->refcount))\n\t\treturn;\n\n\tocelot_write(ocelot, 0, ANA_MIRRORPORTS);\n\tocelot->mirror = NULL;\n\tkfree(m);\n}\n\nint ocelot_port_mirror_add(struct ocelot *ocelot, int from, int to,\n\t\t\t   bool ingress, struct netlink_ext_ack *extack)\n{\n\tstruct ocelot_mirror *m = ocelot_mirror_get(ocelot, to, extack);\n\n\tif (IS_ERR(m))\n\t\treturn PTR_ERR(m);\n\n\tif (ingress) {\n\t\tocelot_rmw_gix(ocelot, ANA_PORT_PORT_CFG_SRC_MIRROR_ENA,\n\t\t\t       ANA_PORT_PORT_CFG_SRC_MIRROR_ENA,\n\t\t\t       ANA_PORT_PORT_CFG, from);\n\t} else {\n\t\tocelot_rmw(ocelot, BIT(from), BIT(from),\n\t\t\t   ANA_EMIRRORPORTS);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocelot_port_mirror_add);\n\nvoid ocelot_port_mirror_del(struct ocelot *ocelot, int from, bool ingress)\n{\n\tif (ingress) {\n\t\tocelot_rmw_gix(ocelot, 0, ANA_PORT_PORT_CFG_SRC_MIRROR_ENA,\n\t\t\t       ANA_PORT_PORT_CFG, from);\n\t} else {\n\t\tocelot_rmw(ocelot, 0, BIT(from), ANA_EMIRRORPORTS);\n\t}\n\n\tocelot_mirror_put(ocelot);\n}\nEXPORT_SYMBOL_GPL(ocelot_port_mirror_del);\n\nstatic void ocelot_port_reset_mqprio(struct ocelot *ocelot, int port)\n{\n\tstruct net_device *dev = ocelot->ops->port_to_netdev(ocelot, port);\n\n\tnetdev_reset_tc(dev);\n\tocelot_port_change_fp(ocelot, port, 0);\n}\n\nint ocelot_port_mqprio(struct ocelot *ocelot, int port,\n\t\t       struct tc_mqprio_qopt_offload *mqprio)\n{\n\tstruct net_device *dev = ocelot->ops->port_to_netdev(ocelot, port);\n\tstruct netlink_ext_ack *extack = mqprio->extack;\n\tstruct tc_mqprio_qopt *qopt = &mqprio->qopt;\n\tint num_tc = qopt->num_tc;\n\tint tc, err;\n\n\tif (!num_tc) {\n\t\tocelot_port_reset_mqprio(ocelot, port);\n\t\treturn 0;\n\t}\n\n\terr = netdev_set_num_tc(dev, num_tc);\n\tif (err)\n\t\treturn err;\n\n\tfor (tc = 0; tc < num_tc; tc++) {\n\t\tif (qopt->count[tc] != 1) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Only one TXQ per TC supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = netdev_set_tc_queue(dev, tc, 1, qopt->offset[tc]);\n\t\tif (err)\n\t\t\tgoto err_reset_tc;\n\t}\n\n\terr = netif_set_real_num_tx_queues(dev, num_tc);\n\tif (err)\n\t\tgoto err_reset_tc;\n\n\tocelot_port_change_fp(ocelot, port, mqprio->preemptible_tcs);\n\n\treturn 0;\n\nerr_reset_tc:\n\tocelot_port_reset_mqprio(ocelot, port);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ocelot_port_mqprio);\n\nvoid ocelot_init_port(struct ocelot *ocelot, int port)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\tskb_queue_head_init(&ocelot_port->tx_skbs);\n\n\t \n\n\t \n\tocelot_port_writel(ocelot_port, DEV_MAC_IFG_CFG_TX_IFG(5),\n\t\t\t   DEV_MAC_IFG_CFG);\n\n\t \n\tocelot_port_writel(ocelot_port, DEV_MAC_HDX_CFG_LATE_COL_POS(67) |\n\t\t\t   DEV_MAC_HDX_CFG_SEED_LOAD,\n\t\t\t   DEV_MAC_HDX_CFG);\n\tmdelay(1);\n\tocelot_port_writel(ocelot_port, DEV_MAC_HDX_CFG_LATE_COL_POS(67),\n\t\t\t   DEV_MAC_HDX_CFG);\n\n\t \n\tocelot_port_set_maxlen(ocelot, port, ETH_DATA_LEN);\n\tocelot_port_writel(ocelot_port, DEV_MAC_TAGS_CFG_TAG_ID(ETH_P_8021AD) |\n\t\t\t   DEV_MAC_TAGS_CFG_VLAN_AWR_ENA |\n\t\t\t   DEV_MAC_TAGS_CFG_VLAN_DBL_AWR_ENA |\n\t\t\t   DEV_MAC_TAGS_CFG_VLAN_LEN_AWR_ENA,\n\t\t\t   DEV_MAC_TAGS_CFG);\n\n\t \n\tocelot_port_writel(ocelot_port, 0, DEV_MAC_FC_MAC_HIGH_CFG);\n\tocelot_port_writel(ocelot_port, 0, DEV_MAC_FC_MAC_LOW_CFG);\n\n\t \n\tocelot_fields_write(ocelot, port, SYS_PAUSE_CFG_PAUSE_ENA, 1);\n\n\t \n\tocelot_rmw_gix(ocelot, ANA_PORT_DROP_CFG_DROP_MC_SMAC_ENA,\n\t\t       ANA_PORT_DROP_CFG_DROP_MC_SMAC_ENA,\n\t\t       ANA_PORT_DROP_CFG, port);\n\n\t \n\tocelot_rmw_gix(ocelot, REW_PORT_VLAN_CFG_PORT_TPID(ETH_P_8021Q),\n\t\t       REW_PORT_VLAN_CFG_PORT_TPID_M,\n\t\t       REW_PORT_VLAN_CFG, port);\n\n\t \n\tocelot_port_set_learning(ocelot, port, false);\n\n\t \n\tocelot_write_gix(ocelot, ANA_PORT_PORT_CFG_LEARNAUTO |\n\t\t\t ANA_PORT_PORT_CFG_RECV_ENA |\n\t\t\t ANA_PORT_PORT_CFG_PORTID_VAL(port),\n\t\t\t ANA_PORT_PORT_CFG, port);\n\n\t \n\tocelot_vcap_enable(ocelot, port);\n}\nEXPORT_SYMBOL(ocelot_init_port);\n\n \nstatic void ocelot_cpu_port_init(struct ocelot *ocelot)\n{\n\tint cpu = ocelot->num_phys_ports;\n\n\t \n\tocelot_write_rix(ocelot, 0, ANA_PGID_PGID, cpu);\n\t \n\tocelot_write_rix(ocelot, BIT(cpu), ANA_PGID_PGID, PGID_CPU);\n\tocelot_write_gix(ocelot, ANA_PORT_PORT_CFG_RECV_ENA |\n\t\t\t ANA_PORT_PORT_CFG_PORTID_VAL(cpu),\n\t\t\t ANA_PORT_PORT_CFG, cpu);\n\n\t \n\tocelot_fields_write(ocelot, cpu, QSYS_SWITCH_PORT_MODE_PORT_ENA, 1);\n\t \n\tocelot_fields_write(ocelot, cpu, SYS_PORT_MODE_INCL_XTR_HDR,\n\t\t\t    OCELOT_TAG_PREFIX_NONE);\n\tocelot_fields_write(ocelot, cpu, SYS_PORT_MODE_INCL_INJ_HDR,\n\t\t\t    OCELOT_TAG_PREFIX_NONE);\n\n\t \n\tocelot_write_gix(ocelot,\n\t\t\t ANA_PORT_VLAN_CFG_VLAN_VID(OCELOT_STANDALONE_PVID) |\n\t\t\t ANA_PORT_VLAN_CFG_VLAN_AWARE_ENA |\n\t\t\t ANA_PORT_VLAN_CFG_VLAN_POP_CNT(1),\n\t\t\t ANA_PORT_VLAN_CFG, cpu);\n}\n\nstatic void ocelot_detect_features(struct ocelot *ocelot)\n{\n\tint mmgt, eq_ctrl;\n\n\t \n\tmmgt = ocelot_read(ocelot, SYS_MMGT);\n\tocelot->packet_buffer_size = 240 * SYS_MMGT_FREECNT(mmgt);\n\n\teq_ctrl = ocelot_read(ocelot, QSYS_EQ_CTRL);\n\tocelot->num_frame_refs = QSYS_MMGT_EQ_CTRL_FP_FREE_CNT(eq_ctrl);\n}\n\nstatic int ocelot_mem_init_status(struct ocelot *ocelot)\n{\n\tunsigned int val;\n\tint err;\n\n\terr = regmap_field_read(ocelot->regfields[SYS_RESET_CFG_MEM_INIT],\n\t\t\t\t&val);\n\n\treturn err ?: val;\n}\n\nint ocelot_reset(struct ocelot *ocelot)\n{\n\tint err;\n\tu32 val;\n\n\terr = regmap_field_write(ocelot->regfields[SYS_RESET_CFG_MEM_INIT], 1);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_field_write(ocelot->regfields[SYS_RESET_CFG_MEM_ENA], 1);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = readx_poll_timeout(ocelot_mem_init_status, ocelot, val, !val,\n\t\t\t\t MEM_INIT_SLEEP_US, MEM_INIT_TIMEOUT_US);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_field_write(ocelot->regfields[SYS_RESET_CFG_MEM_ENA], 1);\n\tif (err)\n\t\treturn err;\n\n\treturn regmap_field_write(ocelot->regfields[SYS_RESET_CFG_CORE_ENA], 1);\n}\nEXPORT_SYMBOL(ocelot_reset);\n\nint ocelot_init(struct ocelot *ocelot)\n{\n\tint i, ret;\n\tu32 port;\n\n\tif (ocelot->ops->reset) {\n\t\tret = ocelot->ops->reset(ocelot);\n\t\tif (ret) {\n\t\t\tdev_err(ocelot->dev, \"Switch reset failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmutex_init(&ocelot->mact_lock);\n\tmutex_init(&ocelot->fwd_domain_lock);\n\tspin_lock_init(&ocelot->ptp_clock_lock);\n\tspin_lock_init(&ocelot->ts_id_lock);\n\n\tocelot->owq = alloc_ordered_workqueue(\"ocelot-owq\", 0);\n\tif (!ocelot->owq)\n\t\treturn -ENOMEM;\n\n\tret = ocelot_stats_init(ocelot);\n\tif (ret)\n\t\tgoto err_stats_init;\n\n\tINIT_LIST_HEAD(&ocelot->multicast);\n\tINIT_LIST_HEAD(&ocelot->pgids);\n\tINIT_LIST_HEAD(&ocelot->vlans);\n\tINIT_LIST_HEAD(&ocelot->lag_fdbs);\n\tocelot_detect_features(ocelot);\n\tocelot_mact_init(ocelot);\n\tocelot_vlan_init(ocelot);\n\tocelot_vcap_init(ocelot);\n\tocelot_cpu_port_init(ocelot);\n\n\tif (ocelot->ops->psfp_init)\n\t\tocelot->ops->psfp_init(ocelot);\n\n\tif (ocelot->mm_supported) {\n\t\tret = ocelot_mm_init(ocelot);\n\t\tif (ret)\n\t\t\tgoto err_mm_init;\n\t}\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\t \n\t\tocelot_write(ocelot, SYS_STAT_CFG_STAT_VIEW(port) |\n\t\t\t\t     SYS_STAT_CFG_STAT_CLEAR_SHOT(0x7f),\n\t\t\t     SYS_STAT_CFG);\n\t}\n\n\t \n\tocelot_write(ocelot, ETH_P_8021AD, SYS_VLAN_ETYPE_CFG);\n\n\t \n\tocelot_write(ocelot, ANA_AGGR_CFG_AC_SMAC_ENA |\n\t\t\t     ANA_AGGR_CFG_AC_DMAC_ENA |\n\t\t\t     ANA_AGGR_CFG_AC_IP4_SIPDIP_ENA |\n\t\t\t     ANA_AGGR_CFG_AC_IP4_TCPUDP_ENA |\n\t\t\t     ANA_AGGR_CFG_AC_IP6_FLOW_LBL_ENA |\n\t\t\t     ANA_AGGR_CFG_AC_IP6_TCPUDP_ENA,\n\t\t\t     ANA_AGGR_CFG);\n\n\t \n\tocelot_write(ocelot,\n\t\t     ANA_AUTOAGE_AGE_PERIOD(BR_DEFAULT_AGEING_TIME / 2 / HZ),\n\t\t     ANA_AUTOAGE);\n\n\t \n\tregmap_field_write(ocelot->regfields[ANA_ADVLEARN_VLAN_CHK], 1);\n\n\t \n\tocelot_write(ocelot, SYS_FRM_AGING_AGE_TX_ENA |\n\t\t     SYS_FRM_AGING_MAX_AGE(307692), SYS_FRM_AGING);\n\n\t \n\tfor (i = 0; i < ocelot->num_flooding_pgids; i++)\n\t\tocelot_write_rix(ocelot, ANA_FLOODING_FLD_MULTICAST(PGID_MC) |\n\t\t\t\t ANA_FLOODING_FLD_BROADCAST(PGID_BC) |\n\t\t\t\t ANA_FLOODING_FLD_UNICAST(PGID_UC),\n\t\t\t\t ANA_FLOODING, i);\n\tocelot_write(ocelot, ANA_FLOODING_IPMC_FLD_MC6_DATA(PGID_MCIPV6) |\n\t\t     ANA_FLOODING_IPMC_FLD_MC6_CTRL(PGID_MC) |\n\t\t     ANA_FLOODING_IPMC_FLD_MC4_DATA(PGID_MCIPV4) |\n\t\t     ANA_FLOODING_IPMC_FLD_MC4_CTRL(PGID_MC),\n\t\t     ANA_FLOODING_IPMC);\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\t \n\t\tocelot_write_rix(ocelot, BIT(port), ANA_PGID_PGID, port);\n\t\t \n\t\tocelot_write_gix(ocelot,\n\t\t\t\t ANA_PORT_CPU_FWD_BPDU_CFG_BPDU_REDIR_ENA(0xffff),\n\t\t\t\t ANA_PORT_CPU_FWD_BPDU_CFG,\n\t\t\t\t port);\n\t\t \n\t\tocelot_write_rix(ocelot, 0, ANA_PGID_PGID, PGID_SRC + port);\n\t}\n\n\tfor_each_nonreserved_multicast_dest_pgid(ocelot, i) {\n\t\tu32 val = ANA_PGID_PGID_PGID(GENMASK(ocelot->num_phys_ports - 1, 0));\n\n\t\tocelot_write_rix(ocelot, val, ANA_PGID_PGID, i);\n\t}\n\n\tocelot_write_rix(ocelot, 0, ANA_PGID_PGID, PGID_BLACKHOLE);\n\n\t \n\tocelot_rmw_rix(ocelot, ANA_PGID_PGID_PGID(BIT(ocelot->num_phys_ports)),\n\t\t       ANA_PGID_PGID_PGID(BIT(ocelot->num_phys_ports)),\n\t\t       ANA_PGID_PGID, PGID_MC);\n\tocelot_rmw_rix(ocelot, ANA_PGID_PGID_PGID(BIT(ocelot->num_phys_ports)),\n\t\t       ANA_PGID_PGID_PGID(BIT(ocelot->num_phys_ports)),\n\t\t       ANA_PGID_PGID, PGID_BC);\n\tocelot_write_rix(ocelot, 0, ANA_PGID_PGID, PGID_MCIPV4);\n\tocelot_write_rix(ocelot, 0, ANA_PGID_PGID, PGID_MCIPV6);\n\n\t \n\tocelot_write_rix(ocelot, QS_INJ_GRP_CFG_BYTE_SWAP |\n\t\t\t QS_INJ_GRP_CFG_MODE(1), QS_INJ_GRP_CFG, 0);\n\tocelot_write_rix(ocelot, QS_XTR_GRP_CFG_BYTE_SWAP |\n\t\t\t QS_XTR_GRP_CFG_MODE(1), QS_XTR_GRP_CFG, 0);\n\tocelot_write(ocelot, ANA_CPUQ_CFG_CPUQ_MIRROR(2) |\n\t\t     ANA_CPUQ_CFG_CPUQ_LRN(2) |\n\t\t     ANA_CPUQ_CFG_CPUQ_MAC_COPY(2) |\n\t\t     ANA_CPUQ_CFG_CPUQ_SRC_COPY(2) |\n\t\t     ANA_CPUQ_CFG_CPUQ_LOCKED_PORTMOVE(2) |\n\t\t     ANA_CPUQ_CFG_CPUQ_ALLBRIDGE(6) |\n\t\t     ANA_CPUQ_CFG_CPUQ_IPMC_CTRL(6) |\n\t\t     ANA_CPUQ_CFG_CPUQ_IGMP(6) |\n\t\t     ANA_CPUQ_CFG_CPUQ_MLD(6), ANA_CPUQ_CFG);\n\tfor (i = 0; i < 16; i++)\n\t\tocelot_write_rix(ocelot, ANA_CPUQ_8021_CFG_CPUQ_GARP_VAL(6) |\n\t\t\t\t ANA_CPUQ_8021_CFG_CPUQ_BPDU_VAL(6),\n\t\t\t\t ANA_CPUQ_8021_CFG, i);\n\n\treturn 0;\n\nerr_mm_init:\n\tocelot_stats_deinit(ocelot);\nerr_stats_init:\n\tdestroy_workqueue(ocelot->owq);\n\treturn ret;\n}\nEXPORT_SYMBOL(ocelot_init);\n\nvoid ocelot_deinit(struct ocelot *ocelot)\n{\n\tocelot_stats_deinit(ocelot);\n\tdestroy_workqueue(ocelot->owq);\n}\nEXPORT_SYMBOL(ocelot_deinit);\n\nvoid ocelot_deinit_port(struct ocelot *ocelot, int port)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\tskb_queue_purge(&ocelot_port->tx_skbs);\n}\nEXPORT_SYMBOL(ocelot_deinit_port);\n\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}