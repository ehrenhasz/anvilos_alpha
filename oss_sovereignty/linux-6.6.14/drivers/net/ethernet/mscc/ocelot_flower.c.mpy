{
  "module_name": "ocelot_flower.c",
  "hash_id": "6d013a9fd54cbfc59490ce005587f5327955364f0ebaf70be2f0264413579e3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mscc/ocelot_flower.c",
  "human_readable_source": "\n \n\n#include <net/pkt_cls.h>\n#include <net/tc_act/tc_gact.h>\n#include <soc/mscc/ocelot_vcap.h>\n#include \"ocelot_police.h\"\n#include \"ocelot_vcap.h\"\n\n \n#define VCAP_BLOCK\t\t\t10000\n#define VCAP_LOOKUP\t\t\t1000\n#define VCAP_IS1_NUM_LOOKUPS\t\t3\n#define VCAP_IS2_NUM_LOOKUPS\t\t2\n#define VCAP_IS2_NUM_PAG\t\t256\n#define VCAP_IS1_CHAIN(lookup)\t\t\\\n\t(1 * VCAP_BLOCK + (lookup) * VCAP_LOOKUP)\n#define VCAP_IS2_CHAIN(lookup, pag)\t\\\n\t(2 * VCAP_BLOCK + (lookup) * VCAP_LOOKUP + (pag))\n \n#define PSFP_BLOCK_ID\t\t\tOCELOT_NUM_VCAP_BLOCKS\n#define OCELOT_PSFP_CHAIN\t\t(3 * VCAP_BLOCK)\n\nstatic int ocelot_chain_to_block(int chain, bool ingress)\n{\n\tint lookup, pag;\n\n\tif (!ingress) {\n\t\tif (chain == 0)\n\t\t\treturn VCAP_ES0;\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (chain == 0)\n\t\treturn VCAP_IS2;\n\n\tfor (lookup = 0; lookup < VCAP_IS1_NUM_LOOKUPS; lookup++)\n\t\tif (chain == VCAP_IS1_CHAIN(lookup))\n\t\t\treturn VCAP_IS1;\n\n\tfor (lookup = 0; lookup < VCAP_IS2_NUM_LOOKUPS; lookup++)\n\t\tfor (pag = 0; pag < VCAP_IS2_NUM_PAG; pag++)\n\t\t\tif (chain == VCAP_IS2_CHAIN(lookup, pag))\n\t\t\t\treturn VCAP_IS2;\n\n\tif (chain == OCELOT_PSFP_CHAIN)\n\t\treturn PSFP_BLOCK_ID;\n\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic int ocelot_chain_to_lookup(int chain)\n{\n\t \n\tif (chain == 0)\n\t\treturn 0;\n\n\treturn (chain / VCAP_LOOKUP) % 10;\n}\n\n \nstatic int ocelot_chain_to_pag(int chain)\n{\n\tint lookup;\n\n\t \n\tif (chain == 0)\n\t\treturn 0;\n\n\tlookup = ocelot_chain_to_lookup(chain);\n\n\t \n\treturn chain - VCAP_IS2_CHAIN(lookup, 0);\n}\n\nstatic bool ocelot_is_goto_target_valid(int goto_target, int chain,\n\t\t\t\t\tbool ingress)\n{\n\tint pag;\n\n\t \n\tif (!ingress)\n\t\treturn (goto_target < 0);\n\n\t \n\tif (chain == 0)\n\t\t \n\t\treturn (goto_target == VCAP_IS1_CHAIN(0) ||\n\t\t\tgoto_target == VCAP_IS1_CHAIN(1) ||\n\t\t\tgoto_target == VCAP_IS1_CHAIN(2) ||\n\t\t\tgoto_target == VCAP_IS2_CHAIN(0, 0) ||\n\t\t\tgoto_target == VCAP_IS2_CHAIN(1, 0) ||\n\t\t\tgoto_target == OCELOT_PSFP_CHAIN);\n\n\tif (chain == VCAP_IS1_CHAIN(0))\n\t\treturn (goto_target == VCAP_IS1_CHAIN(1));\n\n\tif (chain == VCAP_IS1_CHAIN(1))\n\t\treturn (goto_target == VCAP_IS1_CHAIN(2));\n\n\t \n\tif (chain == VCAP_IS1_CHAIN(2)) {\n\t\tfor (pag = 0; pag < VCAP_IS2_NUM_PAG; pag++)\n\t\t\tif (goto_target == VCAP_IS2_CHAIN(0, pag))\n\t\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t \n\tfor (pag = 0; pag < VCAP_IS2_NUM_PAG; pag++)\n\t\tif (chain == VCAP_IS2_CHAIN(0, pag))\n\t\t\treturn (goto_target == VCAP_IS2_CHAIN(1, pag));\n\n\t \n\tfor (pag = 0; pag < VCAP_IS2_NUM_PAG; pag++)\n\t\tif (chain == VCAP_IS2_CHAIN(1, pag))\n\t\t\treturn (goto_target == OCELOT_PSFP_CHAIN);\n\n\treturn false;\n}\n\nstatic struct ocelot_vcap_filter *\nocelot_find_vcap_filter_that_points_at(struct ocelot *ocelot, int chain)\n{\n\tstruct ocelot_vcap_filter *filter;\n\tstruct ocelot_vcap_block *block;\n\tint block_id;\n\n\tblock_id = ocelot_chain_to_block(chain, true);\n\tif (block_id < 0)\n\t\treturn NULL;\n\n\tif (block_id == VCAP_IS2) {\n\t\tblock = &ocelot->block[VCAP_IS1];\n\n\t\tlist_for_each_entry(filter, &block->rules, list)\n\t\t\tif (filter->type == OCELOT_VCAP_FILTER_PAG &&\n\t\t\t    filter->goto_target == chain)\n\t\t\t\treturn filter;\n\t}\n\n\tlist_for_each_entry(filter, &ocelot->dummy_rules, list)\n\t\tif (filter->goto_target == chain)\n\t\t\treturn filter;\n\n\treturn NULL;\n}\n\nstatic int\nocelot_flower_parse_ingress_vlan_modify(struct ocelot *ocelot, int port,\n\t\t\t\t\tstruct ocelot_vcap_filter *filter,\n\t\t\t\t\tconst struct flow_action_entry *a,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\tif (filter->goto_target != -1) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Last action must be GOTO\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!ocelot_port->vlan_aware) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Can only modify VLAN under VLAN aware bridge\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfilter->action.vid_replace_ena = true;\n\tfilter->action.pcp_dei_ena = true;\n\tfilter->action.vid = a->vlan.vid;\n\tfilter->action.pcp = a->vlan.prio;\n\tfilter->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\n\treturn 0;\n}\n\nstatic int\nocelot_flower_parse_egress_vlan_modify(struct ocelot_vcap_filter *filter,\n\t\t\t\t       const struct flow_action_entry *a,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tenum ocelot_tag_tpid_sel tpid;\n\n\tswitch (ntohs(a->vlan.proto)) {\n\tcase ETH_P_8021Q:\n\t\ttpid = OCELOT_TAG_TPID_SEL_8021Q;\n\t\tbreak;\n\tcase ETH_P_8021AD:\n\t\ttpid = OCELOT_TAG_TPID_SEL_8021AD;\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Cannot modify custom TPID\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfilter->action.tag_a_tpid_sel = tpid;\n\tfilter->action.push_outer_tag = OCELOT_ES0_TAG;\n\tfilter->action.tag_a_vid_sel = OCELOT_ES0_VID_PLUS_CLASSIFIED_VID;\n\tfilter->action.vid_a_val = a->vlan.vid;\n\tfilter->action.pcp_a_val = a->vlan.prio;\n\tfilter->action.tag_a_pcp_sel = OCELOT_ES0_PCP;\n\tfilter->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\n\treturn 0;\n}\n\nstatic int ocelot_flower_parse_action(struct ocelot *ocelot, int port,\n\t\t\t\t      bool ingress, struct flow_cls_offload *f,\n\t\t\t\t      struct ocelot_vcap_filter *filter)\n{\n\tconst struct flow_action *action = &f->rule->action;\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tbool allow_missing_goto_target = false;\n\tconst struct flow_action_entry *a;\n\tenum ocelot_tag_tpid_sel tpid;\n\tint i, chain, egress_port;\n\tu32 pol_ix, pol_max;\n\tu64 rate;\n\tint err;\n\n\tif (!flow_action_basic_hw_stats_check(&f->rule->action,\n\t\t\t\t\t      f->common.extack))\n\t\treturn -EOPNOTSUPP;\n\n\tchain = f->common.chain_index;\n\tfilter->block_id = ocelot_chain_to_block(chain, ingress);\n\tif (filter->block_id < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot offload to this chain\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (filter->block_id == VCAP_IS1 || filter->block_id == VCAP_IS2)\n\t\tfilter->lookup = ocelot_chain_to_lookup(chain);\n\tif (filter->block_id == VCAP_IS2)\n\t\tfilter->pag = ocelot_chain_to_pag(chain);\n\n\tfilter->goto_target = -1;\n\tfilter->type = OCELOT_VCAP_FILTER_DUMMY;\n\n\tflow_action_for_each(i, a, action) {\n\t\tswitch (a->id) {\n\t\tcase FLOW_ACTION_DROP:\n\t\t\tif (filter->block_id != VCAP_IS2) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Drop action can only be offloaded to VCAP IS2\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (filter->goto_target != -1) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Last action must be GOTO\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tfilter->action.mask_mode = OCELOT_MASK_MODE_PERMIT_DENY;\n\t\t\tfilter->action.port_mask = 0;\n\t\t\tfilter->action.police_ena = true;\n\t\t\tfilter->action.pol_ix = OCELOT_POLICER_DISCARD;\n\t\t\tfilter->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_ACCEPT:\n\t\t\tif (filter->block_id != VCAP_ES0 &&\n\t\t\t    filter->block_id != VCAP_IS1 &&\n\t\t\t    filter->block_id != VCAP_IS2) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Accept action can only be offloaded to VCAP chains\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (filter->block_id != VCAP_ES0 &&\n\t\t\t    filter->goto_target != -1) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Last action must be GOTO\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tfilter->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_TRAP:\n\t\t\tif (filter->block_id != VCAP_IS2 ||\n\t\t\t    filter->lookup != 0) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Trap action can only be offloaded to VCAP IS2 lookup 0\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (filter->goto_target != -1) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Last action must be GOTO\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tfilter->action.mask_mode = OCELOT_MASK_MODE_PERMIT_DENY;\n\t\t\tfilter->action.port_mask = 0;\n\t\t\tfilter->action.cpu_copy_ena = true;\n\t\t\tfilter->action.cpu_qu_num = 0;\n\t\t\tfilter->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\t\t\tfilter->is_trap = true;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_POLICE:\n\t\t\tif (filter->block_id == PSFP_BLOCK_ID) {\n\t\t\t\tfilter->type = OCELOT_PSFP_FILTER_OFFLOAD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (filter->block_id != VCAP_IS2 ||\n\t\t\t    filter->lookup != 0) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Police action can only be offloaded to VCAP IS2 lookup 0 or PSFP\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (filter->goto_target != -1) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Last action must be GOTO\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\terr = ocelot_policer_validate(action, a, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tfilter->action.police_ena = true;\n\n\t\t\tpol_ix = a->hw_index + ocelot->vcap_pol.base;\n\t\t\tpol_max = ocelot->vcap_pol.max;\n\n\t\t\tif (ocelot->vcap_pol.max2 && pol_ix > pol_max) {\n\t\t\t\tpol_ix += ocelot->vcap_pol.base2 - pol_max - 1;\n\t\t\t\tpol_max = ocelot->vcap_pol.max2;\n\t\t\t}\n\n\t\t\tif (pol_ix >= pol_max)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tfilter->action.pol_ix = pol_ix;\n\n\t\t\trate = a->police.rate_bytes_ps;\n\t\t\tfilter->action.pol.rate = div_u64(rate, 1000) * 8;\n\t\t\tfilter->action.pol.burst = a->police.burst;\n\t\t\tfilter->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_REDIRECT:\n\t\t\tif (filter->block_id != VCAP_IS2) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Redirect action can only be offloaded to VCAP IS2\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (filter->goto_target != -1) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Last action must be GOTO\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tegress_port = ocelot->ops->netdev_to_port(a->dev);\n\t\t\tif (egress_port < 0) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Destination not an ocelot port\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tfilter->action.mask_mode = OCELOT_MASK_MODE_REDIRECT;\n\t\t\tfilter->action.port_mask = BIT(egress_port);\n\t\t\tfilter->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_MIRRED:\n\t\t\tif (filter->block_id != VCAP_IS2) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Mirror action can only be offloaded to VCAP IS2\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (filter->goto_target != -1) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Last action must be GOTO\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tegress_port = ocelot->ops->netdev_to_port(a->dev);\n\t\t\tif (egress_port < 0) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Destination not an ocelot port\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tfilter->egress_port.value = egress_port;\n\t\t\tfilter->action.mirror_ena = true;\n\t\t\tfilter->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_VLAN_POP:\n\t\t\tif (filter->block_id != VCAP_IS1) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"VLAN pop action can only be offloaded to VCAP IS1\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (filter->goto_target != -1) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Last action must be GOTO\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tfilter->action.vlan_pop_cnt_ena = true;\n\t\t\tfilter->action.vlan_pop_cnt++;\n\t\t\tif (filter->action.vlan_pop_cnt > 2) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Cannot pop more than 2 VLAN headers\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tfilter->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_VLAN_MANGLE:\n\t\t\tif (filter->block_id == VCAP_IS1) {\n\t\t\t\terr = ocelot_flower_parse_ingress_vlan_modify(ocelot, port,\n\t\t\t\t\t\t\t\t\t      filter, a,\n\t\t\t\t\t\t\t\t\t      extack);\n\t\t\t} else if (filter->block_id == VCAP_ES0) {\n\t\t\t\terr = ocelot_flower_parse_egress_vlan_modify(filter, a,\n\t\t\t\t\t\t\t\t\t     extack);\n\t\t\t} else {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"VLAN modify action can only be offloaded to VCAP IS1 or ES0\");\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_PRIORITY:\n\t\t\tif (filter->block_id != VCAP_IS1) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Priority action can only be offloaded to VCAP IS1\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (filter->goto_target != -1) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Last action must be GOTO\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tfilter->action.qos_ena = true;\n\t\t\tfilter->action.qos_val = a->priority;\n\t\t\tfilter->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_GOTO:\n\t\t\tfilter->goto_target = a->chain_index;\n\n\t\t\tif (filter->block_id == VCAP_IS1 && filter->lookup == 2) {\n\t\t\t\tint pag = ocelot_chain_to_pag(filter->goto_target);\n\n\t\t\t\tfilter->action.pag_override_mask = 0xff;\n\t\t\t\tfilter->action.pag_val = pag;\n\t\t\t\tfilter->type = OCELOT_VCAP_FILTER_PAG;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_VLAN_PUSH:\n\t\t\tif (filter->block_id != VCAP_ES0) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"VLAN push action can only be offloaded to VCAP ES0\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tswitch (ntohs(a->vlan.proto)) {\n\t\t\tcase ETH_P_8021Q:\n\t\t\t\ttpid = OCELOT_TAG_TPID_SEL_8021Q;\n\t\t\t\tbreak;\n\t\t\tcase ETH_P_8021AD:\n\t\t\t\ttpid = OCELOT_TAG_TPID_SEL_8021AD;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Cannot push custom TPID\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tfilter->action.tag_a_tpid_sel = tpid;\n\t\t\tfilter->action.push_outer_tag = OCELOT_ES0_TAG;\n\t\t\tfilter->action.tag_a_vid_sel = OCELOT_ES0_VID;\n\t\t\tfilter->action.vid_a_val = a->vlan.vid;\n\t\t\tfilter->action.pcp_a_val = a->vlan.prio;\n\t\t\tfilter->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_GATE:\n\t\t\tif (filter->block_id != PSFP_BLOCK_ID) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Gate action can only be offloaded to PSFP chain\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tfilter->type = OCELOT_PSFP_FILTER_OFFLOAD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot offload action\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (filter->goto_target == -1) {\n\t\tif ((filter->block_id == VCAP_IS2 && filter->lookup == 1) ||\n\t\t    chain == 0 || filter->block_id == PSFP_BLOCK_ID) {\n\t\t\tallow_missing_goto_target = true;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Missing GOTO action\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (!ocelot_is_goto_target_valid(filter->goto_target, chain, ingress) &&\n\t    !allow_missing_goto_target) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot offload this GOTO target\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int ocelot_flower_parse_indev(struct ocelot *ocelot, int port,\n\t\t\t\t     struct flow_cls_offload *f,\n\t\t\t\t     struct ocelot_vcap_filter *filter)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tconst struct vcap_props *vcap = &ocelot->vcap[VCAP_ES0];\n\tint key_length = vcap->keys[VCAP_ES0_IGR_PORT].length;\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct net_device *dev, *indev;\n\tstruct flow_match_meta match;\n\tint ingress_port;\n\n\tflow_rule_match_meta(rule, &match);\n\n\tif (!match.mask->ingress_ifindex)\n\t\treturn 0;\n\n\tif (match.mask->ingress_ifindex != 0xFFFFFFFF) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported ingress ifindex mask\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdev = ocelot->ops->port_to_netdev(ocelot, port);\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tindev = __dev_get_by_index(dev_net(dev), match.key->ingress_ifindex);\n\tif (!indev) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Can't find the ingress port to match on\");\n\t\treturn -ENOENT;\n\t}\n\n\tingress_port = ocelot->ops->netdev_to_port(indev);\n\tif (ingress_port < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Can only offload an ocelot ingress port\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (ingress_port == port) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Ingress port is equal to the egress port\");\n\t\treturn -EINVAL;\n\t}\n\n\tfilter->ingress_port.value = ingress_port;\n\tfilter->ingress_port.mask = GENMASK(key_length - 1, 0);\n\n\treturn 0;\n}\n\nstatic int\nocelot_flower_parse_key(struct ocelot *ocelot, int port, bool ingress,\n\t\t\tstruct flow_cls_offload *f,\n\t\t\tstruct ocelot_vcap_filter *filter)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tu16 proto = ntohs(f->common.protocol);\n\tbool match_protocol = true;\n\tint ret;\n\n\tif (dissector->used_keys &\n\t    ~(BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_META) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_PORTS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_VLAN) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV4_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV6_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS))) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_META)) {\n\t\tstruct flow_match_meta match;\n\n\t\tflow_rule_match_meta(rule, &match);\n\t\tif (match.mask->l2_miss) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't match on \\\"l2_miss\\\"\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\t \n\tif (!ingress) {\n\t\tret = ocelot_flower_parse_indev(ocelot, port, f, filter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CONTROL)) {\n\t\tstruct flow_match_control match;\n\n\t\tflow_rule_match_control(rule, &match);\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tstruct flow_match_vlan match;\n\n\t\tflow_rule_match_vlan(rule, &match);\n\t\tfilter->key_type = OCELOT_VCAP_KEY_ANY;\n\t\tfilter->vlan.vid.value = match.key->vlan_id;\n\t\tfilter->vlan.vid.mask = match.mask->vlan_id;\n\t\tfilter->vlan.pcp.value[0] = match.key->vlan_priority;\n\t\tfilter->vlan.pcp.mask[0] = match.mask->vlan_priority;\n\t\tmatch_protocol = false;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct flow_match_eth_addrs match;\n\n\t\tif (filter->block_id == VCAP_ES0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"VCAP ES0 cannot match on MAC address\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\t \n\t\tif ((dissector->used_keys &\n\t\t    (BIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS) |\n\t\t     BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) |\n\t\t     BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL))) !=\n\t\t    (BIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS) |\n\t\t     BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) |\n\t\t     BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL)))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tflow_rule_match_eth_addrs(rule, &match);\n\n\t\tif (filter->block_id == VCAP_IS1 &&\n\t\t    !is_zero_ether_addr(match.mask->dst)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Key type S1_NORMAL cannot match on destination MAC\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tfilter->key_type = OCELOT_VCAP_KEY_ETYPE;\n\t\tether_addr_copy(filter->key.etype.dmac.value,\n\t\t\t\tmatch.key->dst);\n\t\tether_addr_copy(filter->key.etype.smac.value,\n\t\t\t\tmatch.key->src);\n\t\tether_addr_copy(filter->key.etype.dmac.mask,\n\t\t\t\tmatch.mask->dst);\n\t\tether_addr_copy(filter->key.etype.smac.mask,\n\t\t\t\tmatch.mask->src);\n\t\tgoto finished_key_parsing;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC)) {\n\t\tstruct flow_match_basic match;\n\n\t\tflow_rule_match_basic(rule, &match);\n\t\tif (ntohs(match.key->n_proto) == ETH_P_IP) {\n\t\t\tif (filter->block_id == VCAP_ES0) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"VCAP ES0 cannot match on IP protocol\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\tfilter->key_type = OCELOT_VCAP_KEY_IPV4;\n\t\t\tfilter->key.ipv4.proto.value[0] =\n\t\t\t\tmatch.key->ip_proto;\n\t\t\tfilter->key.ipv4.proto.mask[0] =\n\t\t\t\tmatch.mask->ip_proto;\n\t\t\tmatch_protocol = false;\n\t\t}\n\t\tif (ntohs(match.key->n_proto) == ETH_P_IPV6) {\n\t\t\tif (filter->block_id == VCAP_ES0) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"VCAP ES0 cannot match on IP protocol\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\tfilter->key_type = OCELOT_VCAP_KEY_IPV6;\n\t\t\tfilter->key.ipv6.proto.value[0] =\n\t\t\t\tmatch.key->ip_proto;\n\t\t\tfilter->key.ipv6.proto.mask[0] =\n\t\t\t\tmatch.mask->ip_proto;\n\t\t\tmatch_protocol = false;\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IPV4_ADDRS) &&\n\t    proto == ETH_P_IP) {\n\t\tstruct flow_match_ipv4_addrs match;\n\t\tu8 *tmp;\n\n\t\tif (filter->block_id == VCAP_ES0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"VCAP ES0 cannot match on IP address\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tflow_rule_match_ipv4_addrs(rule, &match);\n\n\t\tif (filter->block_id == VCAP_IS1 && *(u32 *)&match.mask->dst) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Key type S1_NORMAL cannot match on destination IP\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\ttmp = &filter->key.ipv4.sip.value.addr[0];\n\t\tmemcpy(tmp, &match.key->src, 4);\n\n\t\ttmp = &filter->key.ipv4.sip.mask.addr[0];\n\t\tmemcpy(tmp, &match.mask->src, 4);\n\n\t\ttmp = &filter->key.ipv4.dip.value.addr[0];\n\t\tmemcpy(tmp, &match.key->dst, 4);\n\n\t\ttmp = &filter->key.ipv4.dip.mask.addr[0];\n\t\tmemcpy(tmp, &match.mask->dst, 4);\n\t\tmatch_protocol = false;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IPV6_ADDRS) &&\n\t    proto == ETH_P_IPV6) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_PORTS)) {\n\t\tstruct flow_match_ports match;\n\n\t\tif (filter->block_id == VCAP_ES0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"VCAP ES0 cannot match on L4 ports\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tflow_rule_match_ports(rule, &match);\n\t\tfilter->key.ipv4.sport.value = ntohs(match.key->src);\n\t\tfilter->key.ipv4.sport.mask = ntohs(match.mask->src);\n\t\tfilter->key.ipv4.dport.value = ntohs(match.key->dst);\n\t\tfilter->key.ipv4.dport.mask = ntohs(match.mask->dst);\n\t\tmatch_protocol = false;\n\t}\n\nfinished_key_parsing:\n\tif (match_protocol && proto != ETH_P_ALL) {\n\t\tif (filter->block_id == VCAP_ES0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"VCAP ES0 cannot match on L2 proto\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\t \n\t\tif (proto < ETH_P_802_3_MIN)\n\t\t\treturn -EOPNOTSUPP;\n\t\tfilter->key_type = OCELOT_VCAP_KEY_ETYPE;\n\t\t*(__be16 *)filter->key.etype.etype.value = htons(proto);\n\t\t*(__be16 *)filter->key.etype.etype.mask = htons(0xffff);\n\t}\n\t \n\n\treturn 0;\n}\n\nstatic int ocelot_flower_parse(struct ocelot *ocelot, int port, bool ingress,\n\t\t\t       struct flow_cls_offload *f,\n\t\t\t       struct ocelot_vcap_filter *filter)\n{\n\tint ret;\n\n\tfilter->prio = f->common.prio;\n\tfilter->id.cookie = f->cookie;\n\tfilter->id.tc_offload = true;\n\n\tret = ocelot_flower_parse_action(ocelot, port, ingress, f, filter);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (filter->type == OCELOT_PSFP_FILTER_OFFLOAD)\n\t\treturn 0;\n\n\treturn ocelot_flower_parse_key(ocelot, port, ingress, f, filter);\n}\n\nstatic struct ocelot_vcap_filter\n*ocelot_vcap_filter_create(struct ocelot *ocelot, int port, bool ingress,\n\t\t\t   struct flow_cls_offload *f)\n{\n\tstruct ocelot_vcap_filter *filter;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (!filter)\n\t\treturn NULL;\n\n\tif (ingress) {\n\t\tfilter->ingress_port_mask = BIT(port);\n\t} else {\n\t\tconst struct vcap_props *vcap = &ocelot->vcap[VCAP_ES0];\n\t\tint key_length = vcap->keys[VCAP_ES0_EGR_PORT].length;\n\n\t\tfilter->egress_port.value = port;\n\t\tfilter->egress_port.mask = GENMASK(key_length - 1, 0);\n\t}\n\n\treturn filter;\n}\n\nstatic int ocelot_vcap_dummy_filter_add(struct ocelot *ocelot,\n\t\t\t\t\tstruct ocelot_vcap_filter *filter)\n{\n\tlist_add(&filter->list, &ocelot->dummy_rules);\n\n\treturn 0;\n}\n\nstatic int ocelot_vcap_dummy_filter_del(struct ocelot *ocelot,\n\t\t\t\t\tstruct ocelot_vcap_filter *filter)\n{\n\tlist_del(&filter->list);\n\tkfree(filter);\n\n\treturn 0;\n}\n\n \nstatic int\nocelot_flower_patch_es0_vlan_modify(struct ocelot_vcap_filter *filter,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (filter->block_id != VCAP_ES0 ||\n\t    filter->action.tag_a_vid_sel != OCELOT_ES0_VID_PLUS_CLASSIFIED_VID)\n\t\treturn 0;\n\n\tif (filter->vlan.vid.mask != VLAN_VID_MASK) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"VCAP ES0 VLAN rewriting needs a full VLAN in the key\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfilter->action.vid_a_val -= filter->vlan.vid.value;\n\tfilter->action.vid_a_val &= VLAN_VID_MASK;\n\n\treturn 0;\n}\n\nint ocelot_cls_flower_replace(struct ocelot *ocelot, int port,\n\t\t\t      struct flow_cls_offload *f, bool ingress)\n{\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct ocelot_vcap_filter *filter;\n\tint chain = f->common.chain_index;\n\tint block_id, ret;\n\n\tif (chain && !ocelot_find_vcap_filter_that_points_at(ocelot, chain)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"No default GOTO action points to this chain\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tblock_id = ocelot_chain_to_block(chain, ingress);\n\tif (block_id < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot offload to this chain\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfilter = ocelot_vcap_block_find_filter_by_id(&ocelot->block[block_id],\n\t\t\t\t\t\t     f->cookie, true);\n\tif (filter) {\n\t\t \n\t\tif (!ingress) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"VCAP ES0 does not support shared filters\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tfilter->ingress_port_mask |= BIT(port);\n\n\t\treturn ocelot_vcap_filter_replace(ocelot, filter);\n\t}\n\n\t \n\tfilter = ocelot_vcap_filter_create(ocelot, port, ingress, f);\n\tif (!filter)\n\t\treturn -ENOMEM;\n\n\tret = ocelot_flower_parse(ocelot, port, ingress, f, filter);\n\tif (ret) {\n\t\tkfree(filter);\n\t\treturn ret;\n\t}\n\n\tret = ocelot_flower_patch_es0_vlan_modify(filter, extack);\n\tif (ret) {\n\t\tkfree(filter);\n\t\treturn ret;\n\t}\n\n\t \n\tif (filter->type == OCELOT_VCAP_FILTER_DUMMY)\n\t\treturn ocelot_vcap_dummy_filter_add(ocelot, filter);\n\n\tif (filter->type == OCELOT_PSFP_FILTER_OFFLOAD) {\n\t\tkfree(filter);\n\t\tif (ocelot->ops->psfp_filter_add)\n\t\t\treturn ocelot->ops->psfp_filter_add(ocelot, port, f);\n\n\t\tNL_SET_ERR_MSG_MOD(extack, \"PSFP chain is not supported in HW\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ocelot_vcap_filter_add(ocelot, filter, f->common.extack);\n}\nEXPORT_SYMBOL_GPL(ocelot_cls_flower_replace);\n\nint ocelot_cls_flower_destroy(struct ocelot *ocelot, int port,\n\t\t\t      struct flow_cls_offload *f, bool ingress)\n{\n\tstruct ocelot_vcap_filter *filter;\n\tstruct ocelot_vcap_block *block;\n\tint block_id;\n\n\tblock_id = ocelot_chain_to_block(f->common.chain_index, ingress);\n\tif (block_id < 0)\n\t\treturn 0;\n\n\tif (block_id == PSFP_BLOCK_ID) {\n\t\tif (ocelot->ops->psfp_filter_del)\n\t\t\treturn ocelot->ops->psfp_filter_del(ocelot, f);\n\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tblock = &ocelot->block[block_id];\n\n\tfilter = ocelot_vcap_block_find_filter_by_id(block, f->cookie, true);\n\tif (!filter)\n\t\treturn 0;\n\n\tif (filter->type == OCELOT_VCAP_FILTER_DUMMY)\n\t\treturn ocelot_vcap_dummy_filter_del(ocelot, filter);\n\n\tif (ingress) {\n\t\tfilter->ingress_port_mask &= ~BIT(port);\n\t\tif (filter->ingress_port_mask)\n\t\t\treturn ocelot_vcap_filter_replace(ocelot, filter);\n\t}\n\n\treturn ocelot_vcap_filter_del(ocelot, filter);\n}\nEXPORT_SYMBOL_GPL(ocelot_cls_flower_destroy);\n\nint ocelot_cls_flower_stats(struct ocelot *ocelot, int port,\n\t\t\t    struct flow_cls_offload *f, bool ingress)\n{\n\tstruct ocelot_vcap_filter *filter;\n\tstruct ocelot_vcap_block *block;\n\tstruct flow_stats stats = {0};\n\tint block_id, ret;\n\n\tblock_id = ocelot_chain_to_block(f->common.chain_index, ingress);\n\tif (block_id < 0)\n\t\treturn 0;\n\n\tif (block_id == PSFP_BLOCK_ID) {\n\t\tif (ocelot->ops->psfp_stats_get) {\n\t\t\tret = ocelot->ops->psfp_stats_get(ocelot, f, &stats);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tgoto stats_update;\n\t\t}\n\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tblock = &ocelot->block[block_id];\n\n\tfilter = ocelot_vcap_block_find_filter_by_id(block, f->cookie, true);\n\tif (!filter || filter->type == OCELOT_VCAP_FILTER_DUMMY)\n\t\treturn 0;\n\n\tret = ocelot_vcap_filter_stats_update(ocelot, filter);\n\tif (ret)\n\t\treturn ret;\n\n\tstats.pkts = filter->stats.pkts;\n\nstats_update:\n\tflow_stats_update(&f->stats, 0x0, stats.pkts, stats.drops, 0x0,\n\t\t\t  FLOW_ACTION_HW_STATS_IMMEDIATE);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocelot_cls_flower_stats);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}