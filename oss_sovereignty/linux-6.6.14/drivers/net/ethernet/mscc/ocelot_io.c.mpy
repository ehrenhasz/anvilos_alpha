{
  "module_name": "ocelot_io.c",
  "hash_id": "2f306a884ba8a573f54d169181058bc77a6f7fd6efb6ac6414dd99bd13aadbe4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mscc/ocelot_io.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n\n#include \"ocelot.h\"\n\nint __ocelot_bulk_read_ix(struct ocelot *ocelot, enum ocelot_reg reg,\n\t\t\t  u32 offset, void *buf, int count)\n{\n\tenum ocelot_target target;\n\tu32 addr;\n\n\tocelot_reg_to_target_addr(ocelot, reg, &target, &addr);\n\tWARN_ON(!target);\n\n\treturn regmap_bulk_read(ocelot->targets[target], addr + offset,\n\t\t\t\tbuf, count);\n}\nEXPORT_SYMBOL_GPL(__ocelot_bulk_read_ix);\n\nu32 __ocelot_read_ix(struct ocelot *ocelot, enum ocelot_reg reg, u32 offset)\n{\n\tenum ocelot_target target;\n\tu32 addr, val;\n\n\tocelot_reg_to_target_addr(ocelot, reg, &target, &addr);\n\tWARN_ON(!target);\n\n\tregmap_read(ocelot->targets[target], addr + offset, &val);\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(__ocelot_read_ix);\n\nvoid __ocelot_write_ix(struct ocelot *ocelot, u32 val, enum ocelot_reg reg,\n\t\t       u32 offset)\n{\n\tenum ocelot_target target;\n\tu32 addr;\n\n\tocelot_reg_to_target_addr(ocelot, reg, &target, &addr);\n\tWARN_ON(!target);\n\n\tregmap_write(ocelot->targets[target], addr + offset, val);\n}\nEXPORT_SYMBOL_GPL(__ocelot_write_ix);\n\nvoid __ocelot_rmw_ix(struct ocelot *ocelot, u32 val, u32 mask,\n\t\t     enum ocelot_reg reg, u32 offset)\n{\n\tenum ocelot_target target;\n\tu32 addr;\n\n\tocelot_reg_to_target_addr(ocelot, reg, &target, &addr);\n\tWARN_ON(!target);\n\n\tregmap_update_bits(ocelot->targets[target], addr + offset, mask, val);\n}\nEXPORT_SYMBOL_GPL(__ocelot_rmw_ix);\n\nu32 ocelot_port_readl(struct ocelot_port *port, enum ocelot_reg reg)\n{\n\tstruct ocelot *ocelot = port->ocelot;\n\tu16 target = reg >> TARGET_OFFSET;\n\tu32 val;\n\n\tWARN_ON(!target);\n\n\tregmap_read(port->target, ocelot->map[target][reg & REG_MASK], &val);\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(ocelot_port_readl);\n\nvoid ocelot_port_writel(struct ocelot_port *port, u32 val, enum ocelot_reg reg)\n{\n\tstruct ocelot *ocelot = port->ocelot;\n\tu16 target = reg >> TARGET_OFFSET;\n\n\tWARN_ON(!target);\n\n\tregmap_write(port->target, ocelot->map[target][reg & REG_MASK], val);\n}\nEXPORT_SYMBOL_GPL(ocelot_port_writel);\n\nvoid ocelot_port_rmwl(struct ocelot_port *port, u32 val, u32 mask,\n\t\t      enum ocelot_reg reg)\n{\n\tu32 cur = ocelot_port_readl(port, reg);\n\n\tocelot_port_writel(port, (cur & (~mask)) | val, reg);\n}\nEXPORT_SYMBOL_GPL(ocelot_port_rmwl);\n\nu32 __ocelot_target_read_ix(struct ocelot *ocelot, enum ocelot_target target,\n\t\t\t    u32 reg, u32 offset)\n{\n\tu32 val;\n\n\tregmap_read(ocelot->targets[target],\n\t\t    ocelot->map[target][reg] + offset, &val);\n\treturn val;\n}\n\nvoid __ocelot_target_write_ix(struct ocelot *ocelot, enum ocelot_target target,\n\t\t\t      u32 val, u32 reg, u32 offset)\n{\n\tregmap_write(ocelot->targets[target],\n\t\t     ocelot->map[target][reg] + offset, val);\n}\n\nint ocelot_regfields_init(struct ocelot *ocelot,\n\t\t\t  const struct reg_field *const regfields)\n{\n\tunsigned int i;\n\tu16 target;\n\n\tfor (i = 0; i < REGFIELD_MAX; i++) {\n\t\tstruct reg_field regfield = {};\n\t\tu32 reg = regfields[i].reg;\n\n\t\tif (!reg)\n\t\t\tcontinue;\n\n\t\ttarget = regfields[i].reg >> TARGET_OFFSET;\n\n\t\tregfield.reg = ocelot->map[target][reg & REG_MASK];\n\t\tregfield.lsb = regfields[i].lsb;\n\t\tregfield.msb = regfields[i].msb;\n\t\tregfield.id_size = regfields[i].id_size;\n\t\tregfield.id_offset = regfields[i].id_offset;\n\n\t\tocelot->regfields[i] =\n\t\tdevm_regmap_field_alloc(ocelot->dev,\n\t\t\t\t\tocelot->targets[target],\n\t\t\t\t\tregfield);\n\n\t\tif (IS_ERR(ocelot->regfields[i]))\n\t\t\treturn PTR_ERR(ocelot->regfields[i]);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocelot_regfields_init);\n\nstatic struct regmap_config ocelot_regmap_config = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n};\n\nstruct regmap *ocelot_regmap_init(struct ocelot *ocelot, struct resource *res)\n{\n\tvoid __iomem *regs;\n\n\tregs = devm_ioremap_resource(ocelot->dev, res);\n\tif (IS_ERR(regs))\n\t\treturn ERR_CAST(regs);\n\n\tocelot_regmap_config.name = res->name;\n\n\treturn devm_regmap_init_mmio(ocelot->dev, regs, &ocelot_regmap_config);\n}\nEXPORT_SYMBOL_GPL(ocelot_regmap_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}