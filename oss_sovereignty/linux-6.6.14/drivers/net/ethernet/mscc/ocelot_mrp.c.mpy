{
  "module_name": "ocelot_mrp.c",
  "hash_id": "a4b0b48d42f454da90701f4466e96492e6de82230ab64d139e5a3e14b5440d18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mscc/ocelot_mrp.c",
  "human_readable_source": "\n \n\n#include <linux/if_bridge.h>\n#include <linux/mrp_bridge.h>\n#include <soc/mscc/ocelot_vcap.h>\n#include <uapi/linux/mrp_bridge.h>\n#include \"ocelot.h\"\n#include \"ocelot_vcap.h\"\n\nstatic const u8 mrp_test_dmac[] = { 0x01, 0x15, 0x4e, 0x00, 0x00, 0x01 };\nstatic const u8 mrp_control_dmac[] = { 0x01, 0x15, 0x4e, 0x00, 0x00, 0x02 };\n\nstatic int ocelot_mrp_find_partner_port(struct ocelot *ocelot,\n\t\t\t\t\tstruct ocelot_port *p)\n{\n\tint i;\n\n\tfor (i = 0; i < ocelot->num_phys_ports; ++i) {\n\t\tstruct ocelot_port *ocelot_port = ocelot->ports[i];\n\n\t\tif (!ocelot_port || p == ocelot_port)\n\t\t\tcontinue;\n\n\t\tif (ocelot_port->mrp_ring_id == p->mrp_ring_id)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nstatic int ocelot_mrp_del_vcap(struct ocelot *ocelot, int id)\n{\n\tstruct ocelot_vcap_block *block_vcap_is2;\n\tstruct ocelot_vcap_filter *filter;\n\n\tblock_vcap_is2 = &ocelot->block[VCAP_IS2];\n\tfilter = ocelot_vcap_block_find_filter_by_id(block_vcap_is2, id,\n\t\t\t\t\t\t     false);\n\tif (!filter)\n\t\treturn 0;\n\n\treturn ocelot_vcap_filter_del(ocelot, filter);\n}\n\nstatic int ocelot_mrp_redirect_add_vcap(struct ocelot *ocelot, int src_port,\n\t\t\t\t\tint dst_port)\n{\n\tconst u8 mrp_test_mask[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\tstruct ocelot_vcap_filter *filter;\n\tint err;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (!filter)\n\t\treturn -ENOMEM;\n\n\tfilter->key_type = OCELOT_VCAP_KEY_ETYPE;\n\tfilter->prio = 1;\n\tfilter->id.cookie = OCELOT_VCAP_IS2_MRP_REDIRECT(ocelot, src_port);\n\tfilter->id.tc_offload = false;\n\tfilter->block_id = VCAP_IS2;\n\tfilter->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\tfilter->ingress_port_mask = BIT(src_port);\n\tether_addr_copy(filter->key.etype.dmac.value, mrp_test_dmac);\n\tether_addr_copy(filter->key.etype.dmac.mask, mrp_test_mask);\n\tfilter->action.mask_mode = OCELOT_MASK_MODE_REDIRECT;\n\tfilter->action.port_mask = BIT(dst_port);\n\n\terr = ocelot_vcap_filter_add(ocelot, filter, NULL);\n\tif (err)\n\t\tkfree(filter);\n\n\treturn err;\n}\n\nstatic void ocelot_populate_mrp_trap_key(struct ocelot_vcap_filter *filter)\n{\n\tconst u8 mrp_mask[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0x00 };\n\n\t \n\tether_addr_copy(filter->key.etype.dmac.value, mrp_test_dmac);\n\tether_addr_copy(filter->key.etype.dmac.mask, mrp_mask);\n}\n\nstatic int ocelot_mrp_trap_add(struct ocelot *ocelot, int port)\n{\n\tunsigned long cookie = OCELOT_VCAP_IS2_MRP_TRAP(ocelot);\n\n\treturn ocelot_trap_add(ocelot, port, cookie, false,\n\t\t\t       ocelot_populate_mrp_trap_key);\n}\n\nstatic int ocelot_mrp_trap_del(struct ocelot *ocelot, int port)\n{\n\tunsigned long cookie = OCELOT_VCAP_IS2_MRP_TRAP(ocelot);\n\n\treturn ocelot_trap_del(ocelot, port, cookie);\n}\n\nstatic void ocelot_mrp_save_mac(struct ocelot *ocelot,\n\t\t\t\tstruct ocelot_port *port)\n{\n\tocelot_mact_learn(ocelot, PGID_BLACKHOLE, mrp_test_dmac,\n\t\t\t  OCELOT_STANDALONE_PVID, ENTRYTYPE_LOCKED);\n\tocelot_mact_learn(ocelot, PGID_BLACKHOLE, mrp_control_dmac,\n\t\t\t  OCELOT_STANDALONE_PVID, ENTRYTYPE_LOCKED);\n}\n\nstatic void ocelot_mrp_del_mac(struct ocelot *ocelot,\n\t\t\t       struct ocelot_port *port)\n{\n\tocelot_mact_forget(ocelot, mrp_test_dmac, OCELOT_STANDALONE_PVID);\n\tocelot_mact_forget(ocelot, mrp_control_dmac, OCELOT_STANDALONE_PVID);\n}\n\nint ocelot_mrp_add(struct ocelot *ocelot, int port,\n\t\t   const struct switchdev_obj_mrp *mrp)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tstruct ocelot_port_private *priv;\n\tstruct net_device *dev;\n\n\tif (!ocelot_port)\n\t\treturn -EOPNOTSUPP;\n\n\tpriv = container_of(ocelot_port, struct ocelot_port_private, port);\n\tdev = priv->dev;\n\n\tif (mrp->p_port != dev && mrp->s_port != dev)\n\t\treturn 0;\n\n\tocelot_port->mrp_ring_id = mrp->ring_id;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_mrp_add);\n\nint ocelot_mrp_del(struct ocelot *ocelot, int port,\n\t\t   const struct switchdev_obj_mrp *mrp)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\tif (!ocelot_port)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ocelot_port->mrp_ring_id != mrp->ring_id)\n\t\treturn 0;\n\n\tocelot_port->mrp_ring_id = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_mrp_del);\n\nint ocelot_mrp_add_ring_role(struct ocelot *ocelot, int port,\n\t\t\t     const struct switchdev_obj_ring_role_mrp *mrp)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tint dst_port;\n\tint err;\n\n\tif (!ocelot_port)\n\t\treturn -EOPNOTSUPP;\n\n\tif (mrp->ring_role != BR_MRP_RING_ROLE_MRC && !mrp->sw_backup)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ocelot_port->mrp_ring_id != mrp->ring_id)\n\t\treturn 0;\n\n\tocelot_mrp_save_mac(ocelot, ocelot_port);\n\n\tif (mrp->ring_role != BR_MRP_RING_ROLE_MRC)\n\t\treturn ocelot_mrp_trap_add(ocelot, port);\n\n\tdst_port = ocelot_mrp_find_partner_port(ocelot, ocelot_port);\n\tif (dst_port == -1)\n\t\treturn -EINVAL;\n\n\terr = ocelot_mrp_redirect_add_vcap(ocelot, port, dst_port);\n\tif (err)\n\t\treturn err;\n\n\terr = ocelot_mrp_trap_add(ocelot, port);\n\tif (err) {\n\t\tocelot_mrp_del_vcap(ocelot,\n\t\t\t\t    OCELOT_VCAP_IS2_MRP_REDIRECT(ocelot, port));\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_mrp_add_ring_role);\n\nint ocelot_mrp_del_ring_role(struct ocelot *ocelot, int port,\n\t\t\t     const struct switchdev_obj_ring_role_mrp *mrp)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tint err, i;\n\n\tif (!ocelot_port)\n\t\treturn -EOPNOTSUPP;\n\n\tif (mrp->ring_role != BR_MRP_RING_ROLE_MRC && !mrp->sw_backup)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ocelot_port->mrp_ring_id != mrp->ring_id)\n\t\treturn 0;\n\n\terr = ocelot_mrp_trap_del(ocelot, port);\n\tif (err)\n\t\treturn err;\n\n\tocelot_mrp_del_vcap(ocelot, OCELOT_VCAP_IS2_MRP_REDIRECT(ocelot, port));\n\n\tfor (i = 0; i < ocelot->num_phys_ports; ++i) {\n\t\tocelot_port = ocelot->ports[i];\n\n\t\tif (!ocelot_port)\n\t\t\tcontinue;\n\n\t\tif (ocelot_port->mrp_ring_id != 0)\n\t\t\tgoto out;\n\t}\n\n\tocelot_mrp_del_mac(ocelot, ocelot->ports[port]);\nout:\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_mrp_del_ring_role);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}