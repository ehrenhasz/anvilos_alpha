{
  "module_name": "ocelot_vcap.c",
  "hash_id": "643fab2bd706ccfdbdabd58759dbcb8daa7cb1c8340c013c4856dd1e689052fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mscc/ocelot_vcap.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n#include <linux/proc_fs.h>\n\n#include <soc/mscc/ocelot_vcap.h>\n#include \"ocelot_police.h\"\n#include \"ocelot_vcap.h\"\n\n#define ENTRY_WIDTH 32\n\nenum vcap_sel {\n\tVCAP_SEL_ENTRY = 0x1,\n\tVCAP_SEL_ACTION = 0x2,\n\tVCAP_SEL_COUNTER = 0x4,\n\tVCAP_SEL_ALL = 0x7,\n};\n\nenum vcap_cmd {\n\tVCAP_CMD_WRITE = 0,  \n\tVCAP_CMD_READ = 1,  \n\tVCAP_CMD_MOVE_UP = 2,  \n\tVCAP_CMD_MOVE_DOWN = 3,  \n\tVCAP_CMD_INITIALIZE = 4,  \n};\n\n#define VCAP_ENTRY_WIDTH 12  \n#define VCAP_COUNTER_WIDTH 4  \n\nstruct vcap_data {\n\tu32 entry[VCAP_ENTRY_WIDTH];  \n\tu32 mask[VCAP_ENTRY_WIDTH];  \n\tu32 action[VCAP_ENTRY_WIDTH];  \n\tu32 counter[VCAP_COUNTER_WIDTH];  \n\tu32 tg;  \n\tu32 type;  \n\tu32 tg_sw;  \n\tu32 cnt;  \n\tu32 key_offset;  \n\tu32 action_offset;  \n\tu32 counter_offset;  \n\tu32 tg_value;  \n\tu32 tg_mask;  \n};\n\nstatic u32 vcap_read_update_ctrl(struct ocelot *ocelot,\n\t\t\t\t const struct vcap_props *vcap)\n{\n\treturn ocelot_target_read(ocelot, vcap->target, VCAP_CORE_UPDATE_CTRL);\n}\n\nstatic void vcap_cmd(struct ocelot *ocelot, const struct vcap_props *vcap,\n\t\t     u16 ix, int cmd, int sel)\n{\n\tu32 value = (VCAP_CORE_UPDATE_CTRL_UPDATE_CMD(cmd) |\n\t\t     VCAP_CORE_UPDATE_CTRL_UPDATE_ADDR(ix) |\n\t\t     VCAP_CORE_UPDATE_CTRL_UPDATE_SHOT);\n\n\tif ((sel & VCAP_SEL_ENTRY) && ix >= vcap->entry_count)\n\t\treturn;\n\n\tif (!(sel & VCAP_SEL_ENTRY))\n\t\tvalue |= VCAP_CORE_UPDATE_CTRL_UPDATE_ENTRY_DIS;\n\n\tif (!(sel & VCAP_SEL_ACTION))\n\t\tvalue |= VCAP_CORE_UPDATE_CTRL_UPDATE_ACTION_DIS;\n\n\tif (!(sel & VCAP_SEL_COUNTER))\n\t\tvalue |= VCAP_CORE_UPDATE_CTRL_UPDATE_CNT_DIS;\n\n\tocelot_target_write(ocelot, vcap->target, value, VCAP_CORE_UPDATE_CTRL);\n\n\tread_poll_timeout(vcap_read_update_ctrl, value,\n\t\t\t  (value & VCAP_CORE_UPDATE_CTRL_UPDATE_SHOT) == 0,\n\t\t\t  10, 100000, false, ocelot, vcap);\n}\n\n \nstatic void vcap_row_cmd(struct ocelot *ocelot, const struct vcap_props *vcap,\n\t\t\t u32 row, int cmd, int sel)\n{\n\tvcap_cmd(ocelot, vcap, vcap->entry_count - row - 1, cmd, sel);\n}\n\nstatic void vcap_entry2cache(struct ocelot *ocelot,\n\t\t\t     const struct vcap_props *vcap,\n\t\t\t     struct vcap_data *data)\n{\n\tu32 entry_words, i;\n\n\tentry_words = DIV_ROUND_UP(vcap->entry_width, ENTRY_WIDTH);\n\n\tfor (i = 0; i < entry_words; i++) {\n\t\tocelot_target_write_rix(ocelot, vcap->target, data->entry[i],\n\t\t\t\t\tVCAP_CACHE_ENTRY_DAT, i);\n\t\tocelot_target_write_rix(ocelot, vcap->target, ~data->mask[i],\n\t\t\t\t\tVCAP_CACHE_MASK_DAT, i);\n\t}\n\tocelot_target_write(ocelot, vcap->target, data->tg, VCAP_CACHE_TG_DAT);\n}\n\nstatic void vcap_cache2entry(struct ocelot *ocelot,\n\t\t\t     const struct vcap_props *vcap,\n\t\t\t     struct vcap_data *data)\n{\n\tu32 entry_words, i;\n\n\tentry_words = DIV_ROUND_UP(vcap->entry_width, ENTRY_WIDTH);\n\n\tfor (i = 0; i < entry_words; i++) {\n\t\tdata->entry[i] = ocelot_target_read_rix(ocelot, vcap->target,\n\t\t\t\t\t\t\tVCAP_CACHE_ENTRY_DAT, i);\n\t\t\n\t\tdata->mask[i] = ~ocelot_target_read_rix(ocelot, vcap->target,\n\t\t\t\t\t\t\tVCAP_CACHE_MASK_DAT, i);\n\t}\n\tdata->tg = ocelot_target_read(ocelot, vcap->target, VCAP_CACHE_TG_DAT);\n}\n\nstatic void vcap_action2cache(struct ocelot *ocelot,\n\t\t\t      const struct vcap_props *vcap,\n\t\t\t      struct vcap_data *data)\n{\n\tu32 action_words, mask;\n\tint i, width;\n\n\t \n\twidth = vcap->action_type_width;\n\tif (width) {\n\t\tmask = GENMASK(width, 0);\n\t\tdata->action[0] = ((data->action[0] & ~mask) | data->type);\n\t}\n\n\taction_words = DIV_ROUND_UP(vcap->action_width, ENTRY_WIDTH);\n\n\tfor (i = 0; i < action_words; i++)\n\t\tocelot_target_write_rix(ocelot, vcap->target, data->action[i],\n\t\t\t\t\tVCAP_CACHE_ACTION_DAT, i);\n\n\tfor (i = 0; i < vcap->counter_words; i++)\n\t\tocelot_target_write_rix(ocelot, vcap->target, data->counter[i],\n\t\t\t\t\tVCAP_CACHE_CNT_DAT, i);\n}\n\nstatic void vcap_cache2action(struct ocelot *ocelot,\n\t\t\t      const struct vcap_props *vcap,\n\t\t\t      struct vcap_data *data)\n{\n\tu32 action_words;\n\tint i, width;\n\n\taction_words = DIV_ROUND_UP(vcap->action_width, ENTRY_WIDTH);\n\n\tfor (i = 0; i < action_words; i++)\n\t\tdata->action[i] = ocelot_target_read_rix(ocelot, vcap->target,\n\t\t\t\t\t\t\t VCAP_CACHE_ACTION_DAT,\n\t\t\t\t\t\t\t i);\n\n\tfor (i = 0; i < vcap->counter_words; i++)\n\t\tdata->counter[i] = ocelot_target_read_rix(ocelot, vcap->target,\n\t\t\t\t\t\t\t  VCAP_CACHE_CNT_DAT,\n\t\t\t\t\t\t\t  i);\n\n\t \n\twidth = vcap->action_type_width;\n\tdata->type = (width ? (data->action[0] & GENMASK(width, 0)) : 0);\n}\n\n \nstatic void vcap_data_offset_get(const struct vcap_props *vcap,\n\t\t\t\t struct vcap_data *data, int ix)\n{\n\tint num_subwords_per_entry, num_subwords_per_action;\n\tint i, col, offset, num_entries_per_row, base;\n\tu32 width = vcap->tg_width;\n\n\tswitch (data->tg_sw) {\n\tcase VCAP_TG_FULL:\n\t\tnum_entries_per_row = 1;\n\t\tbreak;\n\tcase VCAP_TG_HALF:\n\t\tnum_entries_per_row = 2;\n\t\tbreak;\n\tcase VCAP_TG_QUARTER:\n\t\tnum_entries_per_row = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tcol = (ix % num_entries_per_row);\n\tnum_subwords_per_entry = (vcap->sw_count / num_entries_per_row);\n\tbase = (vcap->sw_count - col * num_subwords_per_entry -\n\t\tnum_subwords_per_entry);\n\tdata->tg_value = 0;\n\tdata->tg_mask = 0;\n\tfor (i = 0; i < num_subwords_per_entry; i++) {\n\t\toffset = ((base + i) * width);\n\t\tdata->tg_value |= (data->tg_sw << offset);\n\t\tdata->tg_mask |= GENMASK(offset + width - 1, offset);\n\t}\n\n\t \n\tcol = (num_entries_per_row - col - 1);\n\tdata->key_offset = (base * vcap->entry_width) / vcap->sw_count;\n\tdata->counter_offset = (num_subwords_per_entry * col *\n\t\t\t\tvcap->counter_width);\n\ti = data->type;\n\twidth = vcap->action_table[i].width;\n\tnum_subwords_per_action = vcap->action_table[i].count;\n\tdata->action_offset = ((num_subwords_per_action * col * width) /\n\t\t\t\tnum_entries_per_row);\n\tdata->action_offset += vcap->action_type_width;\n}\n\nstatic void vcap_data_set(u32 *data, u32 offset, u32 len, u32 value)\n{\n\tu32 i, v, m;\n\n\tfor (i = 0; i < len; i++, offset++) {\n\t\tv = data[offset / ENTRY_WIDTH];\n\t\tm = (1 << (offset % ENTRY_WIDTH));\n\t\tif (value & (1 << i))\n\t\t\tv |= m;\n\t\telse\n\t\t\tv &= ~m;\n\t\tdata[offset / ENTRY_WIDTH] = v;\n\t}\n}\n\nstatic u32 vcap_data_get(u32 *data, u32 offset, u32 len)\n{\n\tu32 i, v, m, value = 0;\n\n\tfor (i = 0; i < len; i++, offset++) {\n\t\tv = data[offset / ENTRY_WIDTH];\n\t\tm = (1 << (offset % ENTRY_WIDTH));\n\t\tif (v & m)\n\t\t\tvalue |= (1 << i);\n\t}\n\treturn value;\n}\n\nstatic void vcap_key_field_set(struct vcap_data *data, u32 offset, u32 width,\n\t\t\t       u32 value, u32 mask)\n{\n\tvcap_data_set(data->entry, offset + data->key_offset, width, value);\n\tvcap_data_set(data->mask, offset + data->key_offset, width, mask);\n}\n\nstatic void vcap_key_set(const struct vcap_props *vcap, struct vcap_data *data,\n\t\t\t int field, u32 value, u32 mask)\n{\n\tu32 offset = vcap->keys[field].offset;\n\tu32 length = vcap->keys[field].length;\n\n\tvcap_key_field_set(data, offset, length, value, mask);\n}\n\nstatic void vcap_key_bytes_set(const struct vcap_props *vcap,\n\t\t\t       struct vcap_data *data, int field,\n\t\t\t       u8 *val, u8 *msk)\n{\n\tu32 offset = vcap->keys[field].offset;\n\tu32 count  = vcap->keys[field].length;\n\tu32 i, j, n = 0, value = 0, mask = 0;\n\n\tWARN_ON(count % 8);\n\n\t \n\toffset += count;\n\tcount /= 8;\n\n\tfor (i = 0; i < count; i++) {\n\t\tj = (count - i - 1);\n\t\tvalue += (val[j] << n);\n\t\tmask += (msk[j] << n);\n\t\tn += 8;\n\t\tif (n == ENTRY_WIDTH || (i + 1) == count) {\n\t\t\toffset -= n;\n\t\t\tvcap_key_field_set(data, offset, n, value, mask);\n\t\t\tn = 0;\n\t\t\tvalue = 0;\n\t\t\tmask = 0;\n\t\t}\n\t}\n}\n\nstatic void vcap_key_l4_port_set(const struct vcap_props *vcap,\n\t\t\t\t struct vcap_data *data, int field,\n\t\t\t\t struct ocelot_vcap_udp_tcp *port)\n{\n\tu32 offset = vcap->keys[field].offset;\n\tu32 length = vcap->keys[field].length;\n\n\tWARN_ON(length != 16);\n\n\tvcap_key_field_set(data, offset, length, port->value, port->mask);\n}\n\nstatic void vcap_key_bit_set(const struct vcap_props *vcap,\n\t\t\t     struct vcap_data *data, int field,\n\t\t\t     enum ocelot_vcap_bit val)\n{\n\tu32 value = (val == OCELOT_VCAP_BIT_1 ? 1 : 0);\n\tu32 msk = (val == OCELOT_VCAP_BIT_ANY ? 0 : 1);\n\tu32 offset = vcap->keys[field].offset;\n\tu32 length = vcap->keys[field].length;\n\n\tWARN_ON(length != 1);\n\n\tvcap_key_field_set(data, offset, length, value, msk);\n}\n\nstatic void vcap_action_set(const struct vcap_props *vcap,\n\t\t\t    struct vcap_data *data, int field, u32 value)\n{\n\tint offset = vcap->actions[field].offset;\n\tint length = vcap->actions[field].length;\n\n\tvcap_data_set(data->action, offset + data->action_offset, length,\n\t\t      value);\n}\n\nstatic void is2_action_set(struct ocelot *ocelot, struct vcap_data *data,\n\t\t\t   struct ocelot_vcap_filter *filter)\n{\n\tconst struct vcap_props *vcap = &ocelot->vcap[VCAP_IS2];\n\tstruct ocelot_vcap_action *a = &filter->action;\n\n\tvcap_action_set(vcap, data, VCAP_IS2_ACT_MASK_MODE, a->mask_mode);\n\tvcap_action_set(vcap, data, VCAP_IS2_ACT_PORT_MASK, a->port_mask);\n\tvcap_action_set(vcap, data, VCAP_IS2_ACT_MIRROR_ENA, a->mirror_ena);\n\tvcap_action_set(vcap, data, VCAP_IS2_ACT_POLICE_ENA, a->police_ena);\n\tvcap_action_set(vcap, data, VCAP_IS2_ACT_POLICE_IDX, a->pol_ix);\n\tvcap_action_set(vcap, data, VCAP_IS2_ACT_CPU_QU_NUM, a->cpu_qu_num);\n\tvcap_action_set(vcap, data, VCAP_IS2_ACT_CPU_COPY_ENA, a->cpu_copy_ena);\n}\n\nstatic void is2_entry_set(struct ocelot *ocelot, int ix,\n\t\t\t  struct ocelot_vcap_filter *filter)\n{\n\tconst struct vcap_props *vcap = &ocelot->vcap[VCAP_IS2];\n\tstruct ocelot_vcap_key_vlan *tag = &filter->vlan;\n\tu32 val, msk, type, type_mask = 0xf, i, count;\n\tstruct ocelot_vcap_u64 payload;\n\tstruct vcap_data data;\n\tint row = (ix / 2);\n\n\tmemset(&payload, 0, sizeof(payload));\n\tmemset(&data, 0, sizeof(data));\n\n\t \n\tvcap_row_cmd(ocelot, vcap, row, VCAP_CMD_READ, VCAP_SEL_ALL);\n\tvcap_cache2entry(ocelot, vcap, &data);\n\tvcap_cache2action(ocelot, vcap, &data);\n\n\tdata.tg_sw = VCAP_TG_HALF;\n\tvcap_data_offset_get(vcap, &data, ix);\n\tdata.tg = (data.tg & ~data.tg_mask);\n\tif (filter->prio != 0)\n\t\tdata.tg |= data.tg_value;\n\n\tdata.type = IS2_ACTION_TYPE_NORMAL;\n\n\tvcap_key_set(vcap, &data, VCAP_IS2_HK_PAG, filter->pag, 0xff);\n\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_FIRST,\n\t\t\t (filter->lookup == 0) ? OCELOT_VCAP_BIT_1 :\n\t\t\t OCELOT_VCAP_BIT_0);\n\tvcap_key_set(vcap, &data, VCAP_IS2_HK_IGR_PORT_MASK, 0,\n\t\t     ~filter->ingress_port_mask);\n\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_HOST_MATCH,\n\t\t\t OCELOT_VCAP_BIT_ANY);\n\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_L2_MC, filter->dmac_mc);\n\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_L2_BC, filter->dmac_bc);\n\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_VLAN_TAGGED, tag->tagged);\n\tvcap_key_set(vcap, &data, VCAP_IS2_HK_VID,\n\t\t     tag->vid.value, tag->vid.mask);\n\tvcap_key_set(vcap, &data, VCAP_IS2_HK_PCP,\n\t\t     tag->pcp.value[0], tag->pcp.mask[0]);\n\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_DEI, tag->dei);\n\n\tswitch (filter->key_type) {\n\tcase OCELOT_VCAP_KEY_ETYPE: {\n\t\tstruct ocelot_vcap_key_etype *etype = &filter->key.etype;\n\n\t\ttype = IS2_TYPE_ETYPE;\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS2_HK_L2_DMAC,\n\t\t\t\t   etype->dmac.value, etype->dmac.mask);\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS2_HK_L2_SMAC,\n\t\t\t\t   etype->smac.value, etype->smac.mask);\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS2_HK_MAC_ETYPE_ETYPE,\n\t\t\t\t   etype->etype.value, etype->etype.mask);\n\t\t \n\t\tvcap_key_set(vcap, &data, VCAP_IS2_HK_MAC_ETYPE_L2_PAYLOAD0,\n\t\t\t     0, 0);\n\t\tvcap_key_set(vcap, &data, VCAP_IS2_HK_MAC_ETYPE_L2_PAYLOAD1,\n\t\t\t     0, 0);\n\t\tvcap_key_set(vcap, &data, VCAP_IS2_HK_MAC_ETYPE_L2_PAYLOAD2,\n\t\t\t     0, 0);\n\t\tvcap_key_bytes_set(vcap, &data,\n\t\t\t\t   VCAP_IS2_HK_MAC_ETYPE_L2_PAYLOAD0,\n\t\t\t\t   etype->data.value, etype->data.mask);\n\t\tbreak;\n\t}\n\tcase OCELOT_VCAP_KEY_LLC: {\n\t\tstruct ocelot_vcap_key_llc *llc = &filter->key.llc;\n\n\t\ttype = IS2_TYPE_LLC;\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS2_HK_L2_DMAC,\n\t\t\t\t   llc->dmac.value, llc->dmac.mask);\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS2_HK_L2_SMAC,\n\t\t\t\t   llc->smac.value, llc->smac.mask);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tpayload.value[i] = llc->llc.value[i];\n\t\t\tpayload.mask[i] = llc->llc.mask[i];\n\t\t}\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS2_HK_MAC_LLC_L2_LLC,\n\t\t\t\t   payload.value, payload.mask);\n\t\tbreak;\n\t}\n\tcase OCELOT_VCAP_KEY_SNAP: {\n\t\tstruct ocelot_vcap_key_snap *snap = &filter->key.snap;\n\n\t\ttype = IS2_TYPE_SNAP;\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS2_HK_L2_DMAC,\n\t\t\t\t   snap->dmac.value, snap->dmac.mask);\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS2_HK_L2_SMAC,\n\t\t\t\t   snap->smac.value, snap->smac.mask);\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS2_HK_MAC_SNAP_L2_SNAP,\n\t\t\t\t   filter->key.snap.snap.value,\n\t\t\t\t   filter->key.snap.snap.mask);\n\t\tbreak;\n\t}\n\tcase OCELOT_VCAP_KEY_ARP: {\n\t\tstruct ocelot_vcap_key_arp *arp = &filter->key.arp;\n\n\t\ttype = IS2_TYPE_ARP;\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS2_HK_MAC_ARP_SMAC,\n\t\t\t\t   arp->smac.value, arp->smac.mask);\n\t\tvcap_key_bit_set(vcap, &data,\n\t\t\t\t VCAP_IS2_HK_MAC_ARP_ADDR_SPACE_OK,\n\t\t\t\t arp->ethernet);\n\t\tvcap_key_bit_set(vcap, &data,\n\t\t\t\t VCAP_IS2_HK_MAC_ARP_PROTO_SPACE_OK,\n\t\t\t\t arp->ip);\n\t\tvcap_key_bit_set(vcap, &data,\n\t\t\t\t VCAP_IS2_HK_MAC_ARP_LEN_OK,\n\t\t\t\t arp->length);\n\t\tvcap_key_bit_set(vcap, &data,\n\t\t\t\t VCAP_IS2_HK_MAC_ARP_TARGET_MATCH,\n\t\t\t\t arp->dmac_match);\n\t\tvcap_key_bit_set(vcap, &data,\n\t\t\t\t VCAP_IS2_HK_MAC_ARP_SENDER_MATCH,\n\t\t\t\t arp->smac_match);\n\t\tvcap_key_bit_set(vcap, &data,\n\t\t\t\t VCAP_IS2_HK_MAC_ARP_OPCODE_UNKNOWN,\n\t\t\t\t arp->unknown);\n\n\t\t \n\t\tval = ((arp->req == OCELOT_VCAP_BIT_0 ? 1 : 0) |\n\t\t       (arp->arp == OCELOT_VCAP_BIT_0 ? 2 : 0));\n\t\tmsk = ((arp->req == OCELOT_VCAP_BIT_ANY ? 0 : 1) |\n\t\t       (arp->arp == OCELOT_VCAP_BIT_ANY ? 0 : 2));\n\t\tvcap_key_set(vcap, &data, VCAP_IS2_HK_MAC_ARP_OPCODE,\n\t\t\t     val, msk);\n\t\tvcap_key_bytes_set(vcap, &data,\n\t\t\t\t   VCAP_IS2_HK_MAC_ARP_L3_IP4_DIP,\n\t\t\t\t   arp->dip.value.addr, arp->dip.mask.addr);\n\t\tvcap_key_bytes_set(vcap, &data,\n\t\t\t\t   VCAP_IS2_HK_MAC_ARP_L3_IP4_SIP,\n\t\t\t\t   arp->sip.value.addr, arp->sip.mask.addr);\n\t\tvcap_key_set(vcap, &data, VCAP_IS2_HK_MAC_ARP_DIP_EQ_SIP,\n\t\t\t     0, 0);\n\t\tbreak;\n\t}\n\tcase OCELOT_VCAP_KEY_IPV4:\n\tcase OCELOT_VCAP_KEY_IPV6: {\n\t\tenum ocelot_vcap_bit sip_eq_dip, sport_eq_dport, seq_zero, tcp;\n\t\tenum ocelot_vcap_bit ttl, fragment, options, tcp_ack, tcp_urg;\n\t\tenum ocelot_vcap_bit tcp_fin, tcp_syn, tcp_rst, tcp_psh;\n\t\tstruct ocelot_vcap_key_ipv4 *ipv4 = NULL;\n\t\tstruct ocelot_vcap_key_ipv6 *ipv6 = NULL;\n\t\tstruct ocelot_vcap_udp_tcp *sport, *dport;\n\t\tstruct ocelot_vcap_ipv4 sip, dip;\n\t\tstruct ocelot_vcap_u8 proto, ds;\n\t\tstruct ocelot_vcap_u48 *ip_data;\n\n\t\tif (filter->key_type == OCELOT_VCAP_KEY_IPV4) {\n\t\t\tipv4 = &filter->key.ipv4;\n\t\t\tttl = ipv4->ttl;\n\t\t\tfragment = ipv4->fragment;\n\t\t\toptions = ipv4->options;\n\t\t\tproto = ipv4->proto;\n\t\t\tds = ipv4->ds;\n\t\t\tip_data = &ipv4->data;\n\t\t\tsip = ipv4->sip;\n\t\t\tdip = ipv4->dip;\n\t\t\tsport = &ipv4->sport;\n\t\t\tdport = &ipv4->dport;\n\t\t\ttcp_fin = ipv4->tcp_fin;\n\t\t\ttcp_syn = ipv4->tcp_syn;\n\t\t\ttcp_rst = ipv4->tcp_rst;\n\t\t\ttcp_psh = ipv4->tcp_psh;\n\t\t\ttcp_ack = ipv4->tcp_ack;\n\t\t\ttcp_urg = ipv4->tcp_urg;\n\t\t\tsip_eq_dip = ipv4->sip_eq_dip;\n\t\t\tsport_eq_dport = ipv4->sport_eq_dport;\n\t\t\tseq_zero = ipv4->seq_zero;\n\t\t} else {\n\t\t\tipv6 = &filter->key.ipv6;\n\t\t\tttl = ipv6->ttl;\n\t\t\tfragment = OCELOT_VCAP_BIT_ANY;\n\t\t\toptions = OCELOT_VCAP_BIT_ANY;\n\t\t\tproto = ipv6->proto;\n\t\t\tds = ipv6->ds;\n\t\t\tip_data = &ipv6->data;\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tval = ipv6->sip.value[i + 8];\n\t\t\t\tmsk = ipv6->sip.mask[i + 8];\n\t\t\t\tif (i < 4) {\n\t\t\t\t\tdip.value.addr[i] = val;\n\t\t\t\t\tdip.mask.addr[i] = msk;\n\t\t\t\t} else {\n\t\t\t\t\tsip.value.addr[i - 4] = val;\n\t\t\t\t\tsip.mask.addr[i - 4] = msk;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsport = &ipv6->sport;\n\t\t\tdport = &ipv6->dport;\n\t\t\ttcp_fin = ipv6->tcp_fin;\n\t\t\ttcp_syn = ipv6->tcp_syn;\n\t\t\ttcp_rst = ipv6->tcp_rst;\n\t\t\ttcp_psh = ipv6->tcp_psh;\n\t\t\ttcp_ack = ipv6->tcp_ack;\n\t\t\ttcp_urg = ipv6->tcp_urg;\n\t\t\tsip_eq_dip = ipv6->sip_eq_dip;\n\t\t\tsport_eq_dport = ipv6->sport_eq_dport;\n\t\t\tseq_zero = ipv6->seq_zero;\n\t\t}\n\n\t\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_IP4,\n\t\t\t\t ipv4 ? OCELOT_VCAP_BIT_1 : OCELOT_VCAP_BIT_0);\n\t\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_L3_FRAGMENT,\n\t\t\t\t fragment);\n\t\tvcap_key_set(vcap, &data, VCAP_IS2_HK_L3_FRAG_OFS_GT0, 0, 0);\n\t\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_L3_OPTIONS,\n\t\t\t\t options);\n\t\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_IP4_L3_TTL_GT0,\n\t\t\t\t ttl);\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS2_HK_L3_TOS,\n\t\t\t\t   ds.value, ds.mask);\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS2_HK_L3_IP4_DIP,\n\t\t\t\t   dip.value.addr, dip.mask.addr);\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS2_HK_L3_IP4_SIP,\n\t\t\t\t   sip.value.addr, sip.mask.addr);\n\t\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_DIP_EQ_SIP,\n\t\t\t\t sip_eq_dip);\n\t\tval = proto.value[0];\n\t\tmsk = proto.mask[0];\n\t\ttype = IS2_TYPE_IP_UDP_TCP;\n\t\tif (msk == 0xff && (val == IPPROTO_TCP || val == IPPROTO_UDP)) {\n\t\t\t \n\t\t\ttcp = (val == IPPROTO_TCP ?\n\t\t\t       OCELOT_VCAP_BIT_1 : OCELOT_VCAP_BIT_0);\n\t\t\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_TCP, tcp);\n\t\t\tvcap_key_l4_port_set(vcap, &data,\n\t\t\t\t\t     VCAP_IS2_HK_L4_DPORT, dport);\n\t\t\tvcap_key_l4_port_set(vcap, &data,\n\t\t\t\t\t     VCAP_IS2_HK_L4_SPORT, sport);\n\t\t\tvcap_key_set(vcap, &data, VCAP_IS2_HK_L4_RNG, 0, 0);\n\t\t\tvcap_key_bit_set(vcap, &data,\n\t\t\t\t\t VCAP_IS2_HK_L4_SPORT_EQ_DPORT,\n\t\t\t\t\t sport_eq_dport);\n\t\t\tvcap_key_bit_set(vcap, &data,\n\t\t\t\t\t VCAP_IS2_HK_L4_SEQUENCE_EQ0,\n\t\t\t\t\t seq_zero);\n\t\t\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_L4_FIN,\n\t\t\t\t\t tcp_fin);\n\t\t\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_L4_SYN,\n\t\t\t\t\t tcp_syn);\n\t\t\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_L4_RST,\n\t\t\t\t\t tcp_rst);\n\t\t\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_L4_PSH,\n\t\t\t\t\t tcp_psh);\n\t\t\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_L4_ACK,\n\t\t\t\t\t tcp_ack);\n\t\t\tvcap_key_bit_set(vcap, &data, VCAP_IS2_HK_L4_URG,\n\t\t\t\t\t tcp_urg);\n\t\t\tvcap_key_set(vcap, &data, VCAP_IS2_HK_L4_1588_DOM,\n\t\t\t\t     0, 0);\n\t\t\tvcap_key_set(vcap, &data, VCAP_IS2_HK_L4_1588_VER,\n\t\t\t\t     0, 0);\n\t\t} else {\n\t\t\tif (msk == 0) {\n\t\t\t\t \n\t\t\t\ttype_mask = IS2_TYPE_MASK_IP_ANY;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttype = IS2_TYPE_IP_OTHER;\n\t\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\t\tpayload.value[i] = ip_data->value[i];\n\t\t\t\t\tpayload.mask[i] = ip_data->mask[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvcap_key_bytes_set(vcap, &data,\n\t\t\t\t\t   VCAP_IS2_HK_IP4_L3_PROTO,\n\t\t\t\t\t   proto.value, proto.mask);\n\t\t\tvcap_key_bytes_set(vcap, &data,\n\t\t\t\t\t   VCAP_IS2_HK_L3_PAYLOAD,\n\t\t\t\t\t   payload.value, payload.mask);\n\t\t}\n\t\tbreak;\n\t}\n\tcase OCELOT_VCAP_KEY_ANY:\n\tdefault:\n\t\ttype = 0;\n\t\ttype_mask = 0;\n\t\tcount = vcap->entry_width / 2;\n\t\t \n\t\tfor (i = vcap->keys[VCAP_IS2_HK_L2_DMAC].offset;\n\t\t     i < count; i += ENTRY_WIDTH) {\n\t\t\tvcap_key_field_set(&data, i, min(32u, count - i), 0, 0);\n\t\t}\n\t\tbreak;\n\t}\n\n\tvcap_key_set(vcap, &data, VCAP_IS2_TYPE, type, type_mask);\n\tis2_action_set(ocelot, &data, filter);\n\tvcap_data_set(data.counter, data.counter_offset,\n\t\t      vcap->counter_width, filter->stats.pkts);\n\n\t \n\tvcap_entry2cache(ocelot, vcap, &data);\n\tvcap_action2cache(ocelot, vcap, &data);\n\tvcap_row_cmd(ocelot, vcap, row, VCAP_CMD_WRITE, VCAP_SEL_ALL);\n}\n\nstatic void is1_action_set(struct ocelot *ocelot, struct vcap_data *data,\n\t\t\t   const struct ocelot_vcap_filter *filter)\n{\n\tconst struct vcap_props *vcap = &ocelot->vcap[VCAP_IS1];\n\tconst struct ocelot_vcap_action *a = &filter->action;\n\n\tvcap_action_set(vcap, data, VCAP_IS1_ACT_VID_REPLACE_ENA,\n\t\t\ta->vid_replace_ena);\n\tvcap_action_set(vcap, data, VCAP_IS1_ACT_VID_ADD_VAL, a->vid);\n\tvcap_action_set(vcap, data, VCAP_IS1_ACT_VLAN_POP_CNT_ENA,\n\t\t\ta->vlan_pop_cnt_ena);\n\tvcap_action_set(vcap, data, VCAP_IS1_ACT_VLAN_POP_CNT,\n\t\t\ta->vlan_pop_cnt);\n\tvcap_action_set(vcap, data, VCAP_IS1_ACT_PCP_DEI_ENA, a->pcp_dei_ena);\n\tvcap_action_set(vcap, data, VCAP_IS1_ACT_PCP_VAL, a->pcp);\n\tvcap_action_set(vcap, data, VCAP_IS1_ACT_DEI_VAL, a->dei);\n\tvcap_action_set(vcap, data, VCAP_IS1_ACT_QOS_ENA, a->qos_ena);\n\tvcap_action_set(vcap, data, VCAP_IS1_ACT_QOS_VAL, a->qos_val);\n\tvcap_action_set(vcap, data, VCAP_IS1_ACT_PAG_OVERRIDE_MASK,\n\t\t\ta->pag_override_mask);\n\tvcap_action_set(vcap, data, VCAP_IS1_ACT_PAG_VAL, a->pag_val);\n}\n\nstatic void is1_entry_set(struct ocelot *ocelot, int ix,\n\t\t\t  struct ocelot_vcap_filter *filter)\n{\n\tconst struct vcap_props *vcap = &ocelot->vcap[VCAP_IS1];\n\tstruct ocelot_vcap_key_vlan *tag = &filter->vlan;\n\tstruct vcap_data data;\n\tint row = ix / 2;\n\tu32 type;\n\n\tmemset(&data, 0, sizeof(data));\n\n\t \n\tvcap_row_cmd(ocelot, vcap, row, VCAP_CMD_READ, VCAP_SEL_ALL);\n\tvcap_cache2entry(ocelot, vcap, &data);\n\tvcap_cache2action(ocelot, vcap, &data);\n\n\tdata.tg_sw = VCAP_TG_HALF;\n\tdata.type = IS1_ACTION_TYPE_NORMAL;\n\tvcap_data_offset_get(vcap, &data, ix);\n\tdata.tg = (data.tg & ~data.tg_mask);\n\tif (filter->prio != 0)\n\t\tdata.tg |= data.tg_value;\n\n\tvcap_key_set(vcap, &data, VCAP_IS1_HK_LOOKUP, filter->lookup, 0x3);\n\tvcap_key_set(vcap, &data, VCAP_IS1_HK_IGR_PORT_MASK, 0,\n\t\t     ~filter->ingress_port_mask);\n\tvcap_key_bit_set(vcap, &data, VCAP_IS1_HK_L2_MC, filter->dmac_mc);\n\tvcap_key_bit_set(vcap, &data, VCAP_IS1_HK_L2_BC, filter->dmac_bc);\n\tvcap_key_bit_set(vcap, &data, VCAP_IS1_HK_VLAN_TAGGED, tag->tagged);\n\tvcap_key_set(vcap, &data, VCAP_IS1_HK_VID,\n\t\t     tag->vid.value, tag->vid.mask);\n\tvcap_key_set(vcap, &data, VCAP_IS1_HK_PCP,\n\t\t     tag->pcp.value[0], tag->pcp.mask[0]);\n\ttype = IS1_TYPE_S1_NORMAL;\n\n\tswitch (filter->key_type) {\n\tcase OCELOT_VCAP_KEY_ETYPE: {\n\t\tstruct ocelot_vcap_key_etype *etype = &filter->key.etype;\n\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS1_HK_L2_SMAC,\n\t\t\t\t   etype->smac.value, etype->smac.mask);\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS1_HK_ETYPE,\n\t\t\t\t   etype->etype.value, etype->etype.mask);\n\t\tbreak;\n\t}\n\tcase OCELOT_VCAP_KEY_IPV4: {\n\t\tstruct ocelot_vcap_key_ipv4 *ipv4 = &filter->key.ipv4;\n\t\tstruct ocelot_vcap_udp_tcp *sport = &ipv4->sport;\n\t\tstruct ocelot_vcap_udp_tcp *dport = &ipv4->dport;\n\t\tenum ocelot_vcap_bit tcp_udp = OCELOT_VCAP_BIT_0;\n\t\tstruct ocelot_vcap_u8 proto = ipv4->proto;\n\t\tstruct ocelot_vcap_ipv4 sip = ipv4->sip;\n\t\tu32 val, msk;\n\n\t\tvcap_key_bit_set(vcap, &data, VCAP_IS1_HK_IP_SNAP,\n\t\t\t\t OCELOT_VCAP_BIT_1);\n\t\tvcap_key_bit_set(vcap, &data, VCAP_IS1_HK_IP4,\n\t\t\t\t OCELOT_VCAP_BIT_1);\n\t\tvcap_key_bit_set(vcap, &data, VCAP_IS1_HK_ETYPE_LEN,\n\t\t\t\t OCELOT_VCAP_BIT_1);\n\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS1_HK_L3_IP4_SIP,\n\t\t\t\t   sip.value.addr, sip.mask.addr);\n\n\t\tval = proto.value[0];\n\t\tmsk = proto.mask[0];\n\n\t\tif ((val == NEXTHDR_TCP || val == NEXTHDR_UDP) && msk == 0xff)\n\t\t\ttcp_udp = OCELOT_VCAP_BIT_1;\n\t\tvcap_key_bit_set(vcap, &data, VCAP_IS1_HK_TCP_UDP, tcp_udp);\n\n\t\tif (tcp_udp) {\n\t\t\tenum ocelot_vcap_bit tcp = OCELOT_VCAP_BIT_0;\n\n\t\t\tif (val == NEXTHDR_TCP)\n\t\t\t\ttcp = OCELOT_VCAP_BIT_1;\n\n\t\t\tvcap_key_bit_set(vcap, &data, VCAP_IS1_HK_TCP, tcp);\n\t\t\tvcap_key_l4_port_set(vcap, &data, VCAP_IS1_HK_L4_SPORT,\n\t\t\t\t\t     sport);\n\t\t\t \n\t\t\tvcap_key_l4_port_set(vcap, &data, VCAP_IS1_HK_ETYPE,\n\t\t\t\t\t     dport);\n\t\t} else {\n\t\t\t \n\t\t\tstruct ocelot_vcap_u16 etype = {0};\n\n\t\t\t \n\t\t\tetype.value[0] = proto.value[0];\n\t\t\tetype.mask[0] = proto.mask[0];\n\n\t\t\tvcap_key_bytes_set(vcap, &data, VCAP_IS1_HK_ETYPE,\n\t\t\t\t\t   etype.value, etype.mask);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tvcap_key_bit_set(vcap, &data, VCAP_IS1_HK_TYPE,\n\t\t\t type ? OCELOT_VCAP_BIT_1 : OCELOT_VCAP_BIT_0);\n\n\tis1_action_set(ocelot, &data, filter);\n\tvcap_data_set(data.counter, data.counter_offset,\n\t\t      vcap->counter_width, filter->stats.pkts);\n\n\t \n\tvcap_entry2cache(ocelot, vcap, &data);\n\tvcap_action2cache(ocelot, vcap, &data);\n\tvcap_row_cmd(ocelot, vcap, row, VCAP_CMD_WRITE, VCAP_SEL_ALL);\n}\n\nstatic void es0_action_set(struct ocelot *ocelot, struct vcap_data *data,\n\t\t\t   const struct ocelot_vcap_filter *filter)\n{\n\tconst struct vcap_props *vcap = &ocelot->vcap[VCAP_ES0];\n\tconst struct ocelot_vcap_action *a = &filter->action;\n\n\tvcap_action_set(vcap, data, VCAP_ES0_ACT_PUSH_OUTER_TAG,\n\t\t\ta->push_outer_tag);\n\tvcap_action_set(vcap, data, VCAP_ES0_ACT_PUSH_INNER_TAG,\n\t\t\ta->push_inner_tag);\n\tvcap_action_set(vcap, data, VCAP_ES0_ACT_TAG_A_TPID_SEL,\n\t\t\ta->tag_a_tpid_sel);\n\tvcap_action_set(vcap, data, VCAP_ES0_ACT_TAG_A_VID_SEL,\n\t\t\ta->tag_a_vid_sel);\n\tvcap_action_set(vcap, data, VCAP_ES0_ACT_TAG_A_PCP_SEL,\n\t\t\ta->tag_a_pcp_sel);\n\tvcap_action_set(vcap, data, VCAP_ES0_ACT_VID_A_VAL, a->vid_a_val);\n\tvcap_action_set(vcap, data, VCAP_ES0_ACT_PCP_A_VAL, a->pcp_a_val);\n\tvcap_action_set(vcap, data, VCAP_ES0_ACT_TAG_B_TPID_SEL,\n\t\t\ta->tag_b_tpid_sel);\n\tvcap_action_set(vcap, data, VCAP_ES0_ACT_TAG_B_VID_SEL,\n\t\t\ta->tag_b_vid_sel);\n\tvcap_action_set(vcap, data, VCAP_ES0_ACT_TAG_B_PCP_SEL,\n\t\t\ta->tag_b_pcp_sel);\n\tvcap_action_set(vcap, data, VCAP_ES0_ACT_VID_B_VAL, a->vid_b_val);\n\tvcap_action_set(vcap, data, VCAP_ES0_ACT_PCP_B_VAL, a->pcp_b_val);\n}\n\nstatic void es0_entry_set(struct ocelot *ocelot, int ix,\n\t\t\t  struct ocelot_vcap_filter *filter)\n{\n\tconst struct vcap_props *vcap = &ocelot->vcap[VCAP_ES0];\n\tstruct ocelot_vcap_key_vlan *tag = &filter->vlan;\n\tstruct vcap_data data;\n\tint row = ix;\n\n\tmemset(&data, 0, sizeof(data));\n\n\t \n\tvcap_row_cmd(ocelot, vcap, row, VCAP_CMD_READ, VCAP_SEL_ALL);\n\tvcap_cache2entry(ocelot, vcap, &data);\n\tvcap_cache2action(ocelot, vcap, &data);\n\n\tdata.tg_sw = VCAP_TG_FULL;\n\tdata.type = ES0_ACTION_TYPE_NORMAL;\n\tvcap_data_offset_get(vcap, &data, ix);\n\tdata.tg = (data.tg & ~data.tg_mask);\n\tif (filter->prio != 0)\n\t\tdata.tg |= data.tg_value;\n\n\tvcap_key_set(vcap, &data, VCAP_ES0_IGR_PORT, filter->ingress_port.value,\n\t\t     filter->ingress_port.mask);\n\tvcap_key_set(vcap, &data, VCAP_ES0_EGR_PORT, filter->egress_port.value,\n\t\t     filter->egress_port.mask);\n\tvcap_key_bit_set(vcap, &data, VCAP_ES0_L2_MC, filter->dmac_mc);\n\tvcap_key_bit_set(vcap, &data, VCAP_ES0_L2_BC, filter->dmac_bc);\n\tvcap_key_set(vcap, &data, VCAP_ES0_VID,\n\t\t     tag->vid.value, tag->vid.mask);\n\tvcap_key_set(vcap, &data, VCAP_ES0_PCP,\n\t\t     tag->pcp.value[0], tag->pcp.mask[0]);\n\n\tes0_action_set(ocelot, &data, filter);\n\tvcap_data_set(data.counter, data.counter_offset,\n\t\t      vcap->counter_width, filter->stats.pkts);\n\n\t \n\tvcap_entry2cache(ocelot, vcap, &data);\n\tvcap_action2cache(ocelot, vcap, &data);\n\tvcap_row_cmd(ocelot, vcap, row, VCAP_CMD_WRITE, VCAP_SEL_ALL);\n}\n\nstatic void vcap_entry_get(struct ocelot *ocelot, int ix,\n\t\t\t   struct ocelot_vcap_filter *filter)\n{\n\tconst struct vcap_props *vcap = &ocelot->vcap[filter->block_id];\n\tstruct vcap_data data;\n\tint row, count;\n\tu32 cnt;\n\n\tif (filter->block_id == VCAP_ES0)\n\t\tdata.tg_sw = VCAP_TG_FULL;\n\telse\n\t\tdata.tg_sw = VCAP_TG_HALF;\n\n\tcount = (1 << (data.tg_sw - 1));\n\trow = (ix / count);\n\tvcap_row_cmd(ocelot, vcap, row, VCAP_CMD_READ, VCAP_SEL_COUNTER);\n\tvcap_cache2action(ocelot, vcap, &data);\n\tvcap_data_offset_get(vcap, &data, ix);\n\tcnt = vcap_data_get(data.counter, data.counter_offset,\n\t\t\t    vcap->counter_width);\n\n\tfilter->stats.pkts = cnt;\n}\n\nstatic void vcap_entry_set(struct ocelot *ocelot, int ix,\n\t\t\t   struct ocelot_vcap_filter *filter)\n{\n\tif (filter->block_id == VCAP_IS1)\n\t\treturn is1_entry_set(ocelot, ix, filter);\n\tif (filter->block_id == VCAP_IS2)\n\t\treturn is2_entry_set(ocelot, ix, filter);\n\tif (filter->block_id == VCAP_ES0)\n\t\treturn es0_entry_set(ocelot, ix, filter);\n}\n\nstruct vcap_policer_entry {\n\tstruct list_head list;\n\trefcount_t refcount;\n\tu32 pol_ix;\n};\n\nint ocelot_vcap_policer_add(struct ocelot *ocelot, u32 pol_ix,\n\t\t\t    struct ocelot_policer *pol)\n{\n\tstruct qos_policer_conf pp = { 0 };\n\tstruct vcap_policer_entry *tmp;\n\tint ret;\n\n\tif (!pol)\n\t\treturn -EINVAL;\n\n\tpp.mode = MSCC_QOS_RATE_MODE_DATA;\n\tpp.pir = pol->rate;\n\tpp.pbs = pol->burst;\n\n\tlist_for_each_entry(tmp, &ocelot->vcap_pol.pol_list, list)\n\t\tif (tmp->pol_ix == pol_ix) {\n\t\t\trefcount_inc(&tmp->refcount);\n\t\t\treturn 0;\n\t\t}\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tret = qos_policer_conf_set(ocelot, pol_ix, &pp);\n\tif (ret) {\n\t\tkfree(tmp);\n\t\treturn ret;\n\t}\n\n\ttmp->pol_ix = pol_ix;\n\trefcount_set(&tmp->refcount, 1);\n\tlist_add_tail(&tmp->list, &ocelot->vcap_pol.pol_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_vcap_policer_add);\n\nint ocelot_vcap_policer_del(struct ocelot *ocelot, u32 pol_ix)\n{\n\tstruct qos_policer_conf pp = {0};\n\tstruct vcap_policer_entry *tmp, *n;\n\tu8 z = 0;\n\n\tlist_for_each_entry_safe(tmp, n, &ocelot->vcap_pol.pol_list, list)\n\t\tif (tmp->pol_ix == pol_ix) {\n\t\t\tz = refcount_dec_and_test(&tmp->refcount);\n\t\t\tif (z) {\n\t\t\t\tlist_del(&tmp->list);\n\t\t\t\tkfree(tmp);\n\t\t\t}\n\t\t}\n\n\tif (z) {\n\t\tpp.mode = MSCC_QOS_RATE_MODE_DISABLED;\n\t\treturn qos_policer_conf_set(ocelot, pol_ix, &pp);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_vcap_policer_del);\n\nstatic int\nocelot_vcap_filter_add_aux_resources(struct ocelot *ocelot,\n\t\t\t\t     struct ocelot_vcap_filter *filter,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ocelot_mirror *m;\n\tint ret;\n\n\tif (filter->block_id == VCAP_IS2 && filter->action.mirror_ena) {\n\t\tm = ocelot_mirror_get(ocelot, filter->egress_port.value,\n\t\t\t\t      extack);\n\t\tif (IS_ERR(m))\n\t\t\treturn PTR_ERR(m);\n\t}\n\n\tif (filter->block_id == VCAP_IS2 && filter->action.police_ena) {\n\t\tret = ocelot_vcap_policer_add(ocelot, filter->action.pol_ix,\n\t\t\t\t\t      &filter->action.pol);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nocelot_vcap_filter_del_aux_resources(struct ocelot *ocelot,\n\t\t\t\t     struct ocelot_vcap_filter *filter)\n{\n\tif (filter->block_id == VCAP_IS2 && filter->action.police_ena)\n\t\tocelot_vcap_policer_del(ocelot, filter->action.pol_ix);\n\n\tif (filter->block_id == VCAP_IS2 && filter->action.mirror_ena)\n\t\tocelot_mirror_put(ocelot);\n}\n\nstatic int ocelot_vcap_filter_add_to_block(struct ocelot *ocelot,\n\t\t\t\t\t   struct ocelot_vcap_block *block,\n\t\t\t\t\t   struct ocelot_vcap_filter *filter,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct list_head *pos = &block->rules;\n\tstruct ocelot_vcap_filter *tmp;\n\tint ret;\n\n\tret = ocelot_vcap_filter_add_aux_resources(ocelot, filter, extack);\n\tif (ret)\n\t\treturn ret;\n\n\tblock->count++;\n\n\tlist_for_each_entry(tmp, &block->rules, list) {\n\t\tif (filter->prio < tmp->prio) {\n\t\t\tpos = &tmp->list;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlist_add_tail(&filter->list, pos);\n\n\treturn 0;\n}\n\nstatic bool ocelot_vcap_filter_equal(const struct ocelot_vcap_filter *a,\n\t\t\t\t     const struct ocelot_vcap_filter *b)\n{\n\treturn !memcmp(&a->id, &b->id, sizeof(struct ocelot_vcap_id));\n}\n\nstatic int ocelot_vcap_block_get_filter_index(struct ocelot_vcap_block *block,\n\t\t\t\t\t      struct ocelot_vcap_filter *filter)\n{\n\tstruct ocelot_vcap_filter *tmp;\n\tint index = 0;\n\n\tlist_for_each_entry(tmp, &block->rules, list) {\n\t\tif (ocelot_vcap_filter_equal(filter, tmp))\n\t\t\treturn index;\n\t\tindex++;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic struct ocelot_vcap_filter*\nocelot_vcap_block_find_filter_by_index(struct ocelot_vcap_block *block,\n\t\t\t\t       int index)\n{\n\tstruct ocelot_vcap_filter *tmp;\n\tint i = 0;\n\n\tlist_for_each_entry(tmp, &block->rules, list) {\n\t\tif (i == index)\n\t\t\treturn tmp;\n\t\t++i;\n\t}\n\n\treturn NULL;\n}\n\nstruct ocelot_vcap_filter *\nocelot_vcap_block_find_filter_by_id(struct ocelot_vcap_block *block,\n\t\t\t\t    unsigned long cookie, bool tc_offload)\n{\n\tstruct ocelot_vcap_filter *filter;\n\n\tlist_for_each_entry(filter, &block->rules, list)\n\t\tif (filter->id.tc_offload == tc_offload &&\n\t\t    filter->id.cookie == cookie)\n\t\t\treturn filter;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(ocelot_vcap_block_find_filter_by_id);\n\n \nstatic void ocelot_match_all_as_mac_etype(struct ocelot *ocelot, int port,\n\t\t\t\t\t  int lookup, bool on)\n{\n\tu32 val = 0;\n\n\tif (on)\n\t\tval = ANA_PORT_VCAP_S2_CFG_S2_SNAP_DIS(BIT(lookup)) |\n\t\t      ANA_PORT_VCAP_S2_CFG_S2_ARP_DIS(BIT(lookup)) |\n\t\t      ANA_PORT_VCAP_S2_CFG_S2_IP_TCPUDP_DIS(BIT(lookup)) |\n\t\t      ANA_PORT_VCAP_S2_CFG_S2_IP_OTHER_DIS(BIT(lookup)) |\n\t\t      ANA_PORT_VCAP_S2_CFG_S2_OAM_DIS(BIT(lookup));\n\n\tocelot_rmw_gix(ocelot, val,\n\t\t       ANA_PORT_VCAP_S2_CFG_S2_SNAP_DIS(BIT(lookup)) |\n\t\t       ANA_PORT_VCAP_S2_CFG_S2_ARP_DIS(BIT(lookup)) |\n\t\t       ANA_PORT_VCAP_S2_CFG_S2_IP_TCPUDP_DIS(BIT(lookup)) |\n\t\t       ANA_PORT_VCAP_S2_CFG_S2_IP_OTHER_DIS(BIT(lookup)) |\n\t\t       ANA_PORT_VCAP_S2_CFG_S2_OAM_DIS(BIT(lookup)),\n\t\t       ANA_PORT_VCAP_S2_CFG, port);\n}\n\nstatic bool\nocelot_vcap_is_problematic_mac_etype(struct ocelot_vcap_filter *filter)\n{\n\tu16 proto, mask;\n\n\tif (filter->key_type != OCELOT_VCAP_KEY_ETYPE)\n\t\treturn false;\n\n\tproto = ntohs(*(__be16 *)filter->key.etype.etype.value);\n\tmask = ntohs(*(__be16 *)filter->key.etype.etype.mask);\n\n\t \n\tif (mask == 0)\n\t\treturn true;\n\tif (proto == ETH_P_ARP)\n\t\treturn true;\n\tif (proto == ETH_P_IP)\n\t\treturn true;\n\tif (proto == ETH_P_IPV6)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool\nocelot_vcap_is_problematic_non_mac_etype(struct ocelot_vcap_filter *filter)\n{\n\tif (filter->key_type == OCELOT_VCAP_KEY_SNAP)\n\t\treturn true;\n\tif (filter->key_type == OCELOT_VCAP_KEY_ARP)\n\t\treturn true;\n\tif (filter->key_type == OCELOT_VCAP_KEY_IPV4)\n\t\treturn true;\n\tif (filter->key_type == OCELOT_VCAP_KEY_IPV6)\n\t\treturn true;\n\treturn false;\n}\n\nstatic bool\nocelot_exclusive_mac_etype_filter_rules(struct ocelot *ocelot,\n\t\t\t\t\tstruct ocelot_vcap_filter *filter)\n{\n\tstruct ocelot_vcap_block *block = &ocelot->block[filter->block_id];\n\tstruct ocelot_vcap_filter *tmp;\n\tunsigned long port;\n\tint i;\n\n\t \n\tif (filter->block_id != VCAP_IS2)\n\t\treturn true;\n\n\tif (ocelot_vcap_is_problematic_mac_etype(filter)) {\n\t\t \n\t\tfor (i = 0; i < block->count; i++) {\n\t\t\ttmp = ocelot_vcap_block_find_filter_by_index(block, i);\n\t\t\tif (tmp->ingress_port_mask & filter->ingress_port_mask &&\n\t\t\t    tmp->lookup == filter->lookup &&\n\t\t\t    ocelot_vcap_is_problematic_non_mac_etype(tmp))\n\t\t\t\treturn false;\n\t\t}\n\n\t\tfor_each_set_bit(port, &filter->ingress_port_mask,\n\t\t\t\t ocelot->num_phys_ports)\n\t\t\tocelot_match_all_as_mac_etype(ocelot, port,\n\t\t\t\t\t\t      filter->lookup, true);\n\t} else if (ocelot_vcap_is_problematic_non_mac_etype(filter)) {\n\t\t \n\t\tfor (i = 0; i < block->count; i++) {\n\t\t\ttmp = ocelot_vcap_block_find_filter_by_index(block, i);\n\t\t\tif (tmp->ingress_port_mask & filter->ingress_port_mask &&\n\t\t\t    tmp->lookup == filter->lookup &&\n\t\t\t    ocelot_vcap_is_problematic_mac_etype(tmp))\n\t\t\t\treturn false;\n\t\t}\n\n\t\tfor_each_set_bit(port, &filter->ingress_port_mask,\n\t\t\t\t ocelot->num_phys_ports)\n\t\t\tocelot_match_all_as_mac_etype(ocelot, port,\n\t\t\t\t\t\t      filter->lookup, false);\n\t}\n\n\treturn true;\n}\n\nint ocelot_vcap_filter_add(struct ocelot *ocelot,\n\t\t\t   struct ocelot_vcap_filter *filter,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct ocelot_vcap_block *block = &ocelot->block[filter->block_id];\n\tint i, index, ret;\n\n\tif (!ocelot_exclusive_mac_etype_filter_rules(ocelot, filter)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Cannot mix MAC_ETYPE with non-MAC_ETYPE rules, use the other IS2 lookup\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tret = ocelot_vcap_filter_add_to_block(ocelot, block, filter, extack);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tindex = ocelot_vcap_block_get_filter_index(block, filter);\n\tif (index < 0)\n\t\treturn index;\n\n\t \n\tfor (i = block->count - 1; i > index; i--) {\n\t\tstruct ocelot_vcap_filter *tmp;\n\n\t\ttmp = ocelot_vcap_block_find_filter_by_index(block, i);\n\t\t \n\t\tvcap_entry_get(ocelot, i - 1, tmp);\n\t\tvcap_entry_set(ocelot, i, tmp);\n\t}\n\n\t \n\tvcap_entry_set(ocelot, index, filter);\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_vcap_filter_add);\n\nstatic void ocelot_vcap_block_remove_filter(struct ocelot *ocelot,\n\t\t\t\t\t    struct ocelot_vcap_block *block,\n\t\t\t\t\t    struct ocelot_vcap_filter *filter)\n{\n\tstruct ocelot_vcap_filter *tmp, *n;\n\n\tlist_for_each_entry_safe(tmp, n, &block->rules, list) {\n\t\tif (ocelot_vcap_filter_equal(filter, tmp)) {\n\t\t\tocelot_vcap_filter_del_aux_resources(ocelot, tmp);\n\t\t\tlist_del(&tmp->list);\n\t\t\tkfree(tmp);\n\t\t}\n\t}\n\n\tblock->count--;\n}\n\nint ocelot_vcap_filter_del(struct ocelot *ocelot,\n\t\t\t   struct ocelot_vcap_filter *filter)\n{\n\tstruct ocelot_vcap_block *block = &ocelot->block[filter->block_id];\n\tstruct ocelot_vcap_filter del_filter;\n\tint i, index;\n\n\t \n\tmemset(&del_filter, 0, sizeof(del_filter));\n\tdel_filter.block_id = filter->block_id;\n\n\t \n\tindex = ocelot_vcap_block_get_filter_index(block, filter);\n\tif (index < 0)\n\t\treturn index;\n\n\t \n\tocelot_vcap_block_remove_filter(ocelot, block, filter);\n\n\t \n\tfor (i = index; i < block->count; i++) {\n\t\tstruct ocelot_vcap_filter *tmp;\n\n\t\ttmp = ocelot_vcap_block_find_filter_by_index(block, i);\n\t\t \n\t\tvcap_entry_get(ocelot, i + 1, tmp);\n\t\tvcap_entry_set(ocelot, i, tmp);\n\t}\n\n\t \n\tvcap_entry_set(ocelot, block->count, &del_filter);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_vcap_filter_del);\n\nint ocelot_vcap_filter_replace(struct ocelot *ocelot,\n\t\t\t       struct ocelot_vcap_filter *filter)\n{\n\tstruct ocelot_vcap_block *block = &ocelot->block[filter->block_id];\n\tint index;\n\n\tindex = ocelot_vcap_block_get_filter_index(block, filter);\n\tif (index < 0)\n\t\treturn index;\n\n\tvcap_entry_set(ocelot, index, filter);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_vcap_filter_replace);\n\nint ocelot_vcap_filter_stats_update(struct ocelot *ocelot,\n\t\t\t\t    struct ocelot_vcap_filter *filter)\n{\n\tstruct ocelot_vcap_block *block = &ocelot->block[filter->block_id];\n\tstruct ocelot_vcap_filter tmp;\n\tint index;\n\n\tindex = ocelot_vcap_block_get_filter_index(block, filter);\n\tif (index < 0)\n\t\treturn index;\n\n\tvcap_entry_get(ocelot, index, filter);\n\n\t \n\ttmp = *filter;\n\ttmp.stats.pkts = 0;\n\tvcap_entry_set(ocelot, index, &tmp);\n\n\treturn 0;\n}\n\nstatic void ocelot_vcap_init_one(struct ocelot *ocelot,\n\t\t\t\t const struct vcap_props *vcap)\n{\n\tstruct vcap_data data;\n\n\tmemset(&data, 0, sizeof(data));\n\n\tvcap_entry2cache(ocelot, vcap, &data);\n\tocelot_target_write(ocelot, vcap->target, vcap->entry_count,\n\t\t\t    VCAP_CORE_MV_CFG);\n\tvcap_cmd(ocelot, vcap, 0, VCAP_CMD_INITIALIZE, VCAP_SEL_ENTRY);\n\n\tvcap_action2cache(ocelot, vcap, &data);\n\tocelot_target_write(ocelot, vcap->target, vcap->action_count,\n\t\t\t    VCAP_CORE_MV_CFG);\n\tvcap_cmd(ocelot, vcap, 0, VCAP_CMD_INITIALIZE,\n\t\t VCAP_SEL_ACTION | VCAP_SEL_COUNTER);\n}\n\nstatic void ocelot_vcap_detect_constants(struct ocelot *ocelot,\n\t\t\t\t\t struct vcap_props *vcap)\n{\n\tint counter_memory_width;\n\tint num_default_actions;\n\tint version;\n\n\tversion = ocelot_target_read(ocelot, vcap->target,\n\t\t\t\t     VCAP_CONST_VCAP_VER);\n\t \n\tif (WARN_ON(version != 0))\n\t\treturn;\n\n\t \n\tvcap->tg_width = ocelot_target_read(ocelot, vcap->target,\n\t\t\t\t\t    VCAP_CONST_ENTRY_TG_WIDTH);\n\t \n\tvcap->sw_count = ocelot_target_read(ocelot, vcap->target,\n\t\t\t\t\t    VCAP_CONST_ENTRY_SWCNT);\n\t \n\tvcap->entry_count = ocelot_target_read(ocelot, vcap->target,\n\t\t\t\t\t       VCAP_CONST_ENTRY_CNT);\n\t \n\tvcap->entry_width = ocelot_target_read(ocelot, vcap->target,\n\t\t\t\t\t       VCAP_CONST_ENTRY_WIDTH);\n\tvcap->entry_width -= vcap->tg_width * vcap->sw_count;\n\tnum_default_actions = ocelot_target_read(ocelot, vcap->target,\n\t\t\t\t\t\t VCAP_CONST_ACTION_DEF_CNT);\n\tvcap->action_count = vcap->entry_count + num_default_actions;\n\tvcap->action_width = ocelot_target_read(ocelot, vcap->target,\n\t\t\t\t\t\tVCAP_CONST_ACTION_WIDTH);\n\t \n\tvcap->counter_words = vcap->sw_count;\n\tcounter_memory_width = ocelot_target_read(ocelot, vcap->target,\n\t\t\t\t\t\t  VCAP_CONST_CNT_WIDTH);\n\tvcap->counter_width = counter_memory_width / vcap->counter_words;\n}\n\nint ocelot_vcap_init(struct ocelot *ocelot)\n{\n\tstruct qos_policer_conf cpu_drop = {\n\t\t.mode = MSCC_QOS_RATE_MODE_DATA,\n\t};\n\tint ret, i;\n\n\t \n\tret = qos_policer_conf_set(ocelot, OCELOT_POLICER_DISCARD, &cpu_drop);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < OCELOT_NUM_VCAP_BLOCKS; i++) {\n\t\tstruct ocelot_vcap_block *block = &ocelot->block[i];\n\t\tstruct vcap_props *vcap = &ocelot->vcap[i];\n\n\t\tINIT_LIST_HEAD(&block->rules);\n\n\t\tocelot_vcap_detect_constants(ocelot, vcap);\n\t\tocelot_vcap_init_one(ocelot, vcap);\n\t}\n\n\tINIT_LIST_HEAD(&ocelot->dummy_rules);\n\tINIT_LIST_HEAD(&ocelot->traps);\n\tINIT_LIST_HEAD(&ocelot->vcap_pol.pol_list);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}