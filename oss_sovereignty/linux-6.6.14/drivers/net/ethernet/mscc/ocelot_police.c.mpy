{
  "module_name": "ocelot_police.c",
  "hash_id": "242ba08345250bdf5714fae7dc81af6f4678925feac50f677a6611aa4d990889",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mscc/ocelot_police.c",
  "human_readable_source": "\n \n\n#include <soc/mscc/ocelot.h>\n#include \"ocelot_police.h\"\n\n \n#define POL_MODE_LINERATE   0  \n#define POL_MODE_DATARATE   1  \n#define POL_MODE_FRMRATE_HI 2  \n#define POL_MODE_FRMRATE_LO 3  \n\n \n#define POL_IX_PORT    0     \n#define POL_IX_QUEUE   32    \n\n \n#define POL_ORDER 0x1d3  \n\nint qos_policer_conf_set(struct ocelot *ocelot, u32 pol_ix,\n\t\t\t struct qos_policer_conf *conf)\n{\n\tu32 cf = 0, cir_ena = 0, frm_mode = POL_MODE_LINERATE;\n\tu32 cir = 0, cbs = 0, pir = 0, pbs = 0;\n\tbool cir_discard = 0, pir_discard = 0;\n\tu32 pbs_max = 0, cbs_max = 0;\n\tu8 ipg = 20;\n\tu32 value;\n\n\tpir = conf->pir;\n\tpbs = conf->pbs;\n\n\tswitch (conf->mode) {\n\tcase MSCC_QOS_RATE_MODE_LINE:\n\tcase MSCC_QOS_RATE_MODE_DATA:\n\t\tif (conf->mode == MSCC_QOS_RATE_MODE_LINE) {\n\t\t\tfrm_mode = POL_MODE_LINERATE;\n\t\t\tipg = min_t(u8, GENMASK(4, 0), conf->ipg);\n\t\t} else {\n\t\t\tfrm_mode = POL_MODE_DATARATE;\n\t\t}\n\t\tif (conf->dlb) {\n\t\t\tcir_ena = 1;\n\t\t\tcir = conf->cir;\n\t\t\tcbs = conf->cbs;\n\t\t\tif (cir == 0 && cbs == 0) {\n\t\t\t\t \n\t\t\t\tcir_discard = 1;\n\t\t\t} else {\n\t\t\t\tcir = DIV_ROUND_UP(cir, 100);\n\t\t\t\tcir *= 3;  \n\t\t\t\tcbs = DIV_ROUND_UP(cbs, 4096);\n\t\t\t\tcbs = (cbs ? cbs : 1);  \n\t\t\t\tcbs_max = 60;  \n\t\t\t\tcf = conf->cf;\n\t\t\t\tif (cf)\n\t\t\t\t\tpir += conf->cir;\n\t\t\t}\n\t\t}\n\t\tif (pir == 0 && pbs == 0) {\n\t\t\t \n\t\t\tpir_discard = 1;\n\t\t} else {\n\t\t\tpir = DIV_ROUND_UP(pir, 100);\n\t\t\tpir *= 3;   \n\t\t\tpbs = DIV_ROUND_UP(pbs, 4096);\n\t\t\tpbs = (pbs ? pbs : 1);  \n\t\t\tpbs_max = 60;  \n\t\t}\n\t\tbreak;\n\tcase MSCC_QOS_RATE_MODE_FRAME:\n\t\tif (pir >= 100) {\n\t\t\tfrm_mode = POL_MODE_FRMRATE_HI;\n\t\t\tpir = DIV_ROUND_UP(pir, 100);\n\t\t\tpir *= 3;   \n\t\t\tpbs = (pbs * 10) / 328;  \n\t\t\tpbs = (pbs ? pbs : 1);  \n\t\t\tpbs_max = GENMASK(6, 0);  \n\t\t} else {\n\t\t\tfrm_mode = POL_MODE_FRMRATE_LO;\n\t\t\tif (pir == 0 && pbs == 0) {\n\t\t\t\t \n\t\t\t\tpir_discard = 1;\n\t\t\t\tcir_discard = 1;\n\t\t\t} else {\n\t\t\t\tpir *= 3;  \n\t\t\t\tpbs = (pbs * 10) / 3;  \n\t\t\t\tpbs = (pbs ? pbs : 1);  \n\t\t\t\tpbs_max = 61;  \n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:  \n\t\t \n\t\tpir = GENMASK(15, 0);\n\t\tpbs = 0;\n\t\tbreak;\n\t}\n\n\t \n\tif (pir > GENMASK(15, 0)) {\n\t\tdev_err(ocelot->dev,\n\t\t\t\"Invalid pir for policer %u: %u (max %lu)\\n\",\n\t\t\tpol_ix, pir, GENMASK(15, 0));\n\t\treturn -EINVAL;\n\t}\n\n\tif (cir > GENMASK(15, 0)) {\n\t\tdev_err(ocelot->dev,\n\t\t\t\"Invalid cir for policer %u: %u (max %lu)\\n\",\n\t\t\tpol_ix, cir, GENMASK(15, 0));\n\t\treturn -EINVAL;\n\t}\n\n\tif (pbs > pbs_max) {\n\t\tdev_err(ocelot->dev,\n\t\t\t\"Invalid pbs for policer %u: %u (max %u)\\n\",\n\t\t\tpol_ix, pbs, pbs_max);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cbs > cbs_max) {\n\t\tdev_err(ocelot->dev,\n\t\t\t\"Invalid cbs for policer %u: %u (max %u)\\n\",\n\t\t\tpol_ix, cbs, cbs_max);\n\t\treturn -EINVAL;\n\t}\n\n\tvalue = (ANA_POL_MODE_CFG_IPG_SIZE(ipg) |\n\t\t ANA_POL_MODE_CFG_FRM_MODE(frm_mode) |\n\t\t (cf ? ANA_POL_MODE_CFG_DLB_COUPLED : 0) |\n\t\t (cir_ena ? ANA_POL_MODE_CFG_CIR_ENA : 0) |\n\t\t ANA_POL_MODE_CFG_OVERSHOOT_ENA);\n\n\tocelot_write_gix(ocelot, value, ANA_POL_MODE_CFG, pol_ix);\n\n\tocelot_write_gix(ocelot,\n\t\t\t ANA_POL_PIR_CFG_PIR_RATE(pir) |\n\t\t\t ANA_POL_PIR_CFG_PIR_BURST(pbs),\n\t\t\t ANA_POL_PIR_CFG, pol_ix);\n\n\tocelot_write_gix(ocelot,\n\t\t\t (pir_discard ? GENMASK(22, 0) : 0),\n\t\t\t ANA_POL_PIR_STATE, pol_ix);\n\n\tocelot_write_gix(ocelot,\n\t\t\t ANA_POL_CIR_CFG_CIR_RATE(cir) |\n\t\t\t ANA_POL_CIR_CFG_CIR_BURST(cbs),\n\t\t\t ANA_POL_CIR_CFG, pol_ix);\n\n\tocelot_write_gix(ocelot,\n\t\t\t (cir_discard ? GENMASK(22, 0) : 0),\n\t\t\t ANA_POL_CIR_STATE, pol_ix);\n\n\treturn 0;\n}\n\nint ocelot_policer_validate(const struct flow_action *action,\n\t\t\t    const struct flow_action_entry *a,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (a->police.exceed.act_id != FLOW_ACTION_DROP) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when exceed action is not drop\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (a->police.notexceed.act_id != FLOW_ACTION_PIPE &&\n\t    a->police.notexceed.act_id != FLOW_ACTION_ACCEPT) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when conform action is not pipe or ok\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (a->police.notexceed.act_id == FLOW_ACTION_ACCEPT &&\n\t    !flow_action_is_last_entry(action, a)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when conform action is ok, but police action is not last\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (a->police.peakrate_bytes_ps ||\n\t    a->police.avrate || a->police.overhead) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when peakrate/avrate/overhead is configured\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (a->police.rate_pkt_ps) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload does not support packets per second\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_policer_validate);\n\nint ocelot_port_policer_add(struct ocelot *ocelot, int port,\n\t\t\t    struct ocelot_policer *pol)\n{\n\tstruct qos_policer_conf pp = { 0 };\n\tint err;\n\n\tif (!pol)\n\t\treturn -EINVAL;\n\n\tpp.mode = MSCC_QOS_RATE_MODE_DATA;\n\tpp.pir = pol->rate;\n\tpp.pbs = pol->burst;\n\n\tdev_dbg(ocelot->dev, \"%s: port %u pir %u kbps, pbs %u bytes\\n\",\n\t\t__func__, port, pp.pir, pp.pbs);\n\n\terr = qos_policer_conf_set(ocelot, POL_IX_PORT + port, &pp);\n\tif (err)\n\t\treturn err;\n\n\tocelot_rmw_gix(ocelot,\n\t\t       ANA_PORT_POL_CFG_PORT_POL_ENA |\n\t\t       ANA_PORT_POL_CFG_POL_ORDER(POL_ORDER),\n\t\t       ANA_PORT_POL_CFG_PORT_POL_ENA |\n\t\t       ANA_PORT_POL_CFG_POL_ORDER_M,\n\t\t       ANA_PORT_POL_CFG, port);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_port_policer_add);\n\nint ocelot_port_policer_del(struct ocelot *ocelot, int port)\n{\n\tstruct qos_policer_conf pp = { 0 };\n\tint err;\n\n\tdev_dbg(ocelot->dev, \"%s: port %u\\n\", __func__, port);\n\n\tpp.mode = MSCC_QOS_RATE_MODE_DISABLED;\n\n\terr = qos_policer_conf_set(ocelot, POL_IX_PORT + port, &pp);\n\tif (err)\n\t\treturn err;\n\n\tocelot_rmw_gix(ocelot,\n\t\t       ANA_PORT_POL_CFG_POL_ORDER(POL_ORDER),\n\t\t       ANA_PORT_POL_CFG_PORT_POL_ENA |\n\t\t       ANA_PORT_POL_CFG_POL_ORDER_M,\n\t\t       ANA_PORT_POL_CFG, port);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_port_policer_del);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}