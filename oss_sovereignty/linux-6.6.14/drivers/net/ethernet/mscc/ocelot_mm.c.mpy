{
  "module_name": "ocelot_mm.c",
  "hash_id": "af81ba7e48822c5e7fba098ef61c901c5a7f9a038b5562fd10159950b44bf208",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mscc/ocelot_mm.c",
  "human_readable_source": "\n \n#include <linux/ethtool.h>\n#include <soc/mscc/ocelot.h>\n#include <soc/mscc/ocelot_dev.h>\n#include <soc/mscc/ocelot_qsys.h>\n\n#include \"ocelot.h\"\n\nstatic const char *\nmm_verify_state_to_string(enum ethtool_mm_verify_status state)\n{\n\tswitch (state) {\n\tcase ETHTOOL_MM_VERIFY_STATUS_INITIAL:\n\t\treturn \"INITIAL\";\n\tcase ETHTOOL_MM_VERIFY_STATUS_VERIFYING:\n\t\treturn \"VERIFYING\";\n\tcase ETHTOOL_MM_VERIFY_STATUS_SUCCEEDED:\n\t\treturn \"SUCCEEDED\";\n\tcase ETHTOOL_MM_VERIFY_STATUS_FAILED:\n\t\treturn \"FAILED\";\n\tcase ETHTOOL_MM_VERIFY_STATUS_DISABLED:\n\t\treturn \"DISABLED\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic enum ethtool_mm_verify_status ocelot_mm_verify_status(u32 val)\n{\n\tswitch (DEV_MM_STAT_MM_STATUS_PRMPT_VERIFY_STATE_X(val)) {\n\tcase 0:\n\t\treturn ETHTOOL_MM_VERIFY_STATUS_INITIAL;\n\tcase 1:\n\t\treturn ETHTOOL_MM_VERIFY_STATUS_VERIFYING;\n\tcase 2:\n\t\treturn ETHTOOL_MM_VERIFY_STATUS_SUCCEEDED;\n\tcase 3:\n\t\treturn ETHTOOL_MM_VERIFY_STATUS_FAILED;\n\tcase 4:\n\t\treturn ETHTOOL_MM_VERIFY_STATUS_DISABLED;\n\tdefault:\n\t\treturn ETHTOOL_MM_VERIFY_STATUS_UNKNOWN;\n\t}\n}\n\nvoid ocelot_port_update_active_preemptible_tcs(struct ocelot *ocelot, int port)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tstruct ocelot_mm_state *mm = &ocelot->mm[port];\n\tu32 val = 0;\n\n\tlockdep_assert_held(&ocelot->fwd_domain_lock);\n\n\t \n\tif ((ocelot_port->phy_mode != PHY_INTERFACE_MODE_QSGMII ||\n\t     ocelot_port->speed == SPEED_1000) && mm->tx_active)\n\t\tval = mm->preemptible_tcs;\n\n\t \n\tmm->active_preemptible_tcs = val;\n\tocelot->ops->tas_guard_bands_update(ocelot, port);\n\n\tdev_dbg(ocelot->dev,\n\t\t\"port %d %s/%s, MM TX %s, preemptible TCs 0x%x, active 0x%x\\n\",\n\t\tport, phy_modes(ocelot_port->phy_mode),\n\t\tphy_speed_to_str(ocelot_port->speed),\n\t\tmm->tx_active ? \"active\" : \"inactive\", mm->preemptible_tcs,\n\t\tmm->active_preemptible_tcs);\n\n\tocelot_rmw_rix(ocelot, QSYS_PREEMPTION_CFG_P_QUEUES(val),\n\t\t       QSYS_PREEMPTION_CFG_P_QUEUES_M,\n\t\t       QSYS_PREEMPTION_CFG, port);\n}\n\nvoid ocelot_port_change_fp(struct ocelot *ocelot, int port,\n\t\t\t   unsigned long preemptible_tcs)\n{\n\tstruct ocelot_mm_state *mm = &ocelot->mm[port];\n\n\tlockdep_assert_held(&ocelot->fwd_domain_lock);\n\n\tif (mm->preemptible_tcs == preemptible_tcs)\n\t\treturn;\n\n\tmm->preemptible_tcs = preemptible_tcs;\n\n\tocelot_port_update_active_preemptible_tcs(ocelot, port);\n}\n\nstatic void ocelot_mm_update_port_status(struct ocelot *ocelot, int port)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tstruct ocelot_mm_state *mm = &ocelot->mm[port];\n\tenum ethtool_mm_verify_status verify_status;\n\tu32 val, ack = 0;\n\n\tif (!mm->tx_enabled)\n\t\treturn;\n\n\tval = ocelot_port_readl(ocelot_port, DEV_MM_STATUS);\n\n\tverify_status = ocelot_mm_verify_status(val);\n\tif (mm->verify_status != verify_status) {\n\t\tdev_dbg(ocelot->dev,\n\t\t\t\"Port %d MAC Merge verification state %s\\n\",\n\t\t\tport, mm_verify_state_to_string(verify_status));\n\t\tmm->verify_status = verify_status;\n\t}\n\n\tif (val & DEV_MM_STAT_MM_STATUS_PRMPT_ACTIVE_STICKY) {\n\t\tmm->tx_active = !!(val & DEV_MM_STAT_MM_STATUS_PRMPT_ACTIVE_STATUS);\n\n\t\tdev_dbg(ocelot->dev, \"Port %d TX preemption %s\\n\",\n\t\t\tport, mm->tx_active ? \"active\" : \"inactive\");\n\t\tocelot_port_update_active_preemptible_tcs(ocelot, port);\n\n\t\tack |= DEV_MM_STAT_MM_STATUS_PRMPT_ACTIVE_STICKY;\n\t}\n\n\tif (val & DEV_MM_STAT_MM_STATUS_UNEXP_RX_PFRM_STICKY) {\n\t\tdev_err(ocelot->dev,\n\t\t\t\"Unexpected P-frame received on port %d while verification was unsuccessful or not yet verified\\n\",\n\t\t\tport);\n\n\t\tack |= DEV_MM_STAT_MM_STATUS_UNEXP_RX_PFRM_STICKY;\n\t}\n\n\tif (val & DEV_MM_STAT_MM_STATUS_UNEXP_TX_PFRM_STICKY) {\n\t\tdev_err(ocelot->dev,\n\t\t\t\"Unexpected P-frame requested to be transmitted on port %d while verification was unsuccessful or not yet verified, or MM_TX_ENA=0\\n\",\n\t\t\tport);\n\n\t\tack |= DEV_MM_STAT_MM_STATUS_UNEXP_TX_PFRM_STICKY;\n\t}\n\n\tif (ack)\n\t\tocelot_port_writel(ocelot_port, ack, DEV_MM_STATUS);\n}\n\nvoid ocelot_mm_irq(struct ocelot *ocelot)\n{\n\tint port;\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++)\n\t\tocelot_mm_update_port_status(ocelot, port);\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n}\nEXPORT_SYMBOL_GPL(ocelot_mm_irq);\n\nint ocelot_port_set_mm(struct ocelot *ocelot, int port,\n\t\t       struct ethtool_mm_cfg *cfg,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tu32 mm_enable = 0, verify_disable = 0, add_frag_size;\n\tstruct ocelot_mm_state *mm;\n\tint err;\n\n\tif (!ocelot->mm_supported)\n\t\treturn -EOPNOTSUPP;\n\n\tmm = &ocelot->mm[port];\n\n\terr = ethtool_mm_frag_size_min_to_add(cfg->tx_min_frag_size,\n\t\t\t\t\t      &add_frag_size, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (cfg->pmac_enabled)\n\t\tmm_enable |= DEV_MM_CONFIG_ENABLE_CONFIG_MM_RX_ENA;\n\n\tif (cfg->tx_enabled)\n\t\tmm_enable |= DEV_MM_CONFIG_ENABLE_CONFIG_MM_TX_ENA;\n\n\tif (!cfg->verify_enabled)\n\t\tverify_disable = DEV_MM_CONFIG_VERIF_CONFIG_PRM_VERIFY_DIS;\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tocelot_port_rmwl(ocelot_port, mm_enable,\n\t\t\t DEV_MM_CONFIG_ENABLE_CONFIG_MM_TX_ENA |\n\t\t\t DEV_MM_CONFIG_ENABLE_CONFIG_MM_RX_ENA,\n\t\t\t DEV_MM_ENABLE_CONFIG);\n\n\tocelot_port_rmwl(ocelot_port, verify_disable |\n\t\t\t DEV_MM_CONFIG_VERIF_CONFIG_PRM_VERIFY_TIME(cfg->verify_time),\n\t\t\t DEV_MM_CONFIG_VERIF_CONFIG_PRM_VERIFY_DIS |\n\t\t\t DEV_MM_CONFIG_VERIF_CONFIG_PRM_VERIFY_TIME_M,\n\t\t\t DEV_MM_VERIF_CONFIG);\n\n\tocelot_rmw_rix(ocelot,\n\t\t       QSYS_PREEMPTION_CFG_MM_ADD_FRAG_SIZE(add_frag_size),\n\t\t       QSYS_PREEMPTION_CFG_MM_ADD_FRAG_SIZE_M,\n\t\t       QSYS_PREEMPTION_CFG,\n\t\t       port);\n\n\t \n\tif (mm->tx_enabled && !cfg->tx_enabled) {\n\t\tocelot_mm_update_port_status(ocelot, port);\n\t\tWARN_ON(mm->tx_active);\n\t}\n\n\tmm->tx_enabled = cfg->tx_enabled;\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocelot_port_set_mm);\n\nint ocelot_port_get_mm(struct ocelot *ocelot, int port,\n\t\t       struct ethtool_mm_state *state)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tstruct ocelot_mm_state *mm;\n\tu32 val, add_frag_size;\n\n\tif (!ocelot->mm_supported)\n\t\treturn -EOPNOTSUPP;\n\n\tmm = &ocelot->mm[port];\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tval = ocelot_port_readl(ocelot_port, DEV_MM_ENABLE_CONFIG);\n\tstate->pmac_enabled = !!(val & DEV_MM_CONFIG_ENABLE_CONFIG_MM_RX_ENA);\n\tstate->tx_enabled = !!(val & DEV_MM_CONFIG_ENABLE_CONFIG_MM_TX_ENA);\n\n\tval = ocelot_port_readl(ocelot_port, DEV_MM_VERIF_CONFIG);\n\tstate->verify_enabled = !(val & DEV_MM_CONFIG_VERIF_CONFIG_PRM_VERIFY_DIS);\n\tstate->verify_time = DEV_MM_CONFIG_VERIF_CONFIG_PRM_VERIFY_TIME_X(val);\n\tstate->max_verify_time = 128;\n\n\tval = ocelot_read_rix(ocelot, QSYS_PREEMPTION_CFG, port);\n\tadd_frag_size = QSYS_PREEMPTION_CFG_MM_ADD_FRAG_SIZE_X(val);\n\tstate->tx_min_frag_size = ethtool_mm_frag_size_add_to_min(add_frag_size);\n\tstate->rx_min_frag_size = ETH_ZLEN;\n\n\tocelot_mm_update_port_status(ocelot, port);\n\tstate->verify_status = mm->verify_status;\n\tstate->tx_active = mm->tx_active;\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ocelot_port_get_mm);\n\nint ocelot_mm_init(struct ocelot *ocelot)\n{\n\tstruct ocelot_port *ocelot_port;\n\tstruct ocelot_mm_state *mm;\n\tint port;\n\n\tif (!ocelot->mm_supported)\n\t\treturn 0;\n\n\tocelot->mm = devm_kcalloc(ocelot->dev, ocelot->num_phys_ports,\n\t\t\t\t  sizeof(*ocelot->mm), GFP_KERNEL);\n\tif (!ocelot->mm)\n\t\treturn -ENOMEM;\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tu32 val;\n\n\t\tmm = &ocelot->mm[port];\n\t\tocelot_port = ocelot->ports[port];\n\n\t\t \n\t\tval = ocelot_port_readl(ocelot_port, DEV_MM_STATUS);\n\t\tmm->verify_status = ocelot_mm_verify_status(val);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}