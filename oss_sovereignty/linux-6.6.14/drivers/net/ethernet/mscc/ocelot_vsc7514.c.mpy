{
  "module_name": "ocelot_vsc7514.c",
  "hash_id": "b4b1ec99ef47f3bf0db1fb4466269d7d6872a74fcc71466e98c28b093d9bb8ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mscc/ocelot_vsc7514.c",
  "human_readable_source": "\n \n#include <linux/dsa/ocelot.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of_net.h>\n#include <linux/netdevice.h>\n#include <linux/phylink.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/syscon.h>\n#include <linux/skbuff.h>\n#include <net/switchdev.h>\n\n#include <soc/mscc/ocelot.h>\n#include <soc/mscc/ocelot_vcap.h>\n#include <soc/mscc/vsc7514_regs.h>\n#include \"ocelot_fdma.h\"\n#include \"ocelot.h\"\n\n#define VSC7514_VCAP_POLICER_BASE\t\t\t128\n#define VSC7514_VCAP_POLICER_MAX\t\t\t191\n\nstatic int ocelot_chip_init(struct ocelot *ocelot, const struct ocelot_ops *ops)\n{\n\tint ret;\n\n\tocelot->map = vsc7514_regmap;\n\tocelot->num_mact_rows = 1024;\n\tocelot->ops = ops;\n\n\tret = ocelot_regfields_init(ocelot, vsc7514_regfields);\n\tif (ret)\n\t\treturn ret;\n\n\tocelot_pll5_init(ocelot);\n\n\teth_random_addr(ocelot->base_mac);\n\tocelot->base_mac[5] &= 0xf0;\n\n\treturn 0;\n}\n\nstatic irqreturn_t ocelot_xtr_irq_handler(int irq, void *arg)\n{\n\tstruct ocelot *ocelot = arg;\n\tint grp = 0, err;\n\n\twhile (ocelot_read(ocelot, QS_XTR_DATA_PRESENT) & BIT(grp)) {\n\t\tstruct sk_buff *skb;\n\n\t\terr = ocelot_xtr_poll_frame(ocelot, grp, &skb);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tskb->dev->stats.rx_bytes += skb->len;\n\t\tskb->dev->stats.rx_packets++;\n\n\t\tif (!skb_defer_rx_timestamp(skb))\n\t\t\tnetif_rx(skb);\n\t}\n\nout:\n\tif (err < 0)\n\t\tocelot_drain_cpu_queue(ocelot, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ocelot_ptp_rdy_irq_handler(int irq, void *arg)\n{\n\tstruct ocelot *ocelot = arg;\n\n\tocelot_get_txtstamp(ocelot);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct of_device_id mscc_ocelot_match[] = {\n\t{ .compatible = \"mscc,vsc7514-switch\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mscc_ocelot_match);\n\nstatic const struct ocelot_ops ocelot_ops = {\n\t.reset\t\t\t= ocelot_reset,\n\t.wm_enc\t\t\t= ocelot_wm_enc,\n\t.wm_dec\t\t\t= ocelot_wm_dec,\n\t.wm_stat\t\t= ocelot_wm_stat,\n\t.port_to_netdev\t\t= ocelot_port_to_netdev,\n\t.netdev_to_port\t\t= ocelot_netdev_to_port,\n};\n\nstatic struct ptp_clock_info ocelot_ptp_clock_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ocelot ptp\",\n\t.max_adj\t= 0x7fffffff,\n\t.n_alarm\t= 0,\n\t.n_ext_ts\t= 0,\n\t.n_per_out\t= OCELOT_PTP_PINS_NUM,\n\t.n_pins\t\t= OCELOT_PTP_PINS_NUM,\n\t.pps\t\t= 0,\n\t.gettime64\t= ocelot_ptp_gettime64,\n\t.settime64\t= ocelot_ptp_settime64,\n\t.adjtime\t= ocelot_ptp_adjtime,\n\t.adjfine\t= ocelot_ptp_adjfine,\n\t.verify\t\t= ocelot_ptp_verify,\n\t.enable\t\t= ocelot_ptp_enable,\n};\n\nstatic void mscc_ocelot_teardown_devlink_ports(struct ocelot *ocelot)\n{\n\tint port;\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++)\n\t\tocelot_port_devlink_teardown(ocelot, port);\n}\n\nstatic void mscc_ocelot_release_ports(struct ocelot *ocelot)\n{\n\tint port;\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tstruct ocelot_port *ocelot_port;\n\n\t\tocelot_port = ocelot->ports[port];\n\t\tif (!ocelot_port)\n\t\t\tcontinue;\n\n\t\tocelot_deinit_port(ocelot, port);\n\t\tocelot_release_port(ocelot_port);\n\t}\n}\n\nstatic int mscc_ocelot_init_ports(struct platform_device *pdev,\n\t\t\t\t  struct device_node *ports)\n{\n\tstruct ocelot *ocelot = platform_get_drvdata(pdev);\n\tu32 devlink_ports_registered = 0;\n\tstruct device_node *portnp;\n\tint port, err;\n\tu32 reg;\n\n\tocelot->ports = devm_kcalloc(ocelot->dev, ocelot->num_phys_ports,\n\t\t\t\t     sizeof(struct ocelot_port *), GFP_KERNEL);\n\tif (!ocelot->ports)\n\t\treturn -ENOMEM;\n\n\tocelot->devlink_ports = devm_kcalloc(ocelot->dev,\n\t\t\t\t\t     ocelot->num_phys_ports,\n\t\t\t\t\t     sizeof(*ocelot->devlink_ports),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!ocelot->devlink_ports)\n\t\treturn -ENOMEM;\n\n\tfor_each_available_child_of_node(ports, portnp) {\n\t\tstruct regmap *target;\n\t\tstruct resource *res;\n\t\tchar res_name[8];\n\n\t\tif (of_property_read_u32(portnp, \"reg\", &reg))\n\t\t\tcontinue;\n\n\t\tport = reg;\n\t\tif (port < 0 || port >= ocelot->num_phys_ports) {\n\t\t\tdev_err(ocelot->dev,\n\t\t\t\t\"invalid port number: %d >= %d\\n\", port,\n\t\t\t\tocelot->num_phys_ports);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsnprintf(res_name, sizeof(res_name), \"port%d\", port);\n\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   res_name);\n\t\ttarget = ocelot_regmap_init(ocelot, res);\n\t\tif (IS_ERR(target)) {\n\t\t\terr = PTR_ERR(target);\n\t\t\tof_node_put(portnp);\n\t\t\tgoto out_teardown;\n\t\t}\n\n\t\terr = ocelot_port_devlink_init(ocelot, port,\n\t\t\t\t\t       DEVLINK_PORT_FLAVOUR_PHYSICAL);\n\t\tif (err) {\n\t\t\tof_node_put(portnp);\n\t\t\tgoto out_teardown;\n\t\t}\n\n\t\terr = ocelot_probe_port(ocelot, port, target, portnp);\n\t\tif (err) {\n\t\t\tocelot_port_devlink_teardown(ocelot, port);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdevlink_ports_registered |= BIT(port);\n\t}\n\n\t \n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tif (devlink_ports_registered & BIT(port))\n\t\t\tcontinue;\n\n\t\terr = ocelot_port_devlink_init(ocelot, port,\n\t\t\t\t\t       DEVLINK_PORT_FLAVOUR_UNUSED);\n\t\tif (err)\n\t\t\tgoto out_teardown;\n\n\t\tdevlink_ports_registered |= BIT(port);\n\t}\n\n\treturn 0;\n\nout_teardown:\n\t \n\tmscc_ocelot_release_ports(ocelot);\n\t \n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tif (devlink_ports_registered & BIT(port))\n\t\t\tocelot_port_devlink_teardown(ocelot, port);\n\t}\n\treturn err;\n}\n\nstatic int mscc_ocelot_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint err, irq_xtr, irq_ptp_rdy;\n\tstruct device_node *ports;\n\tstruct devlink *devlink;\n\tstruct ocelot *ocelot;\n\tstruct regmap *hsio;\n\tunsigned int i;\n\n\tstruct {\n\t\tenum ocelot_target id;\n\t\tchar *name;\n\t\tu8 optional:1;\n\t} io_target[] = {\n\t\t{ SYS, \"sys\" },\n\t\t{ REW, \"rew\" },\n\t\t{ QSYS, \"qsys\" },\n\t\t{ ANA, \"ana\" },\n\t\t{ QS, \"qs\" },\n\t\t{ S0, \"s0\" },\n\t\t{ S1, \"s1\" },\n\t\t{ S2, \"s2\" },\n\t\t{ PTP, \"ptp\", 1 },\n\t\t{ FDMA, \"fdma\", 1 },\n\t};\n\n\tif (!np && !pdev->dev.platform_data)\n\t\treturn -ENODEV;\n\n\tdevlink =\n\t\tdevlink_alloc(&ocelot_devlink_ops, sizeof(*ocelot), &pdev->dev);\n\tif (!devlink)\n\t\treturn -ENOMEM;\n\n\tocelot = devlink_priv(devlink);\n\tocelot->devlink = priv_to_devlink(ocelot);\n\tplatform_set_drvdata(pdev, ocelot);\n\tocelot->dev = &pdev->dev;\n\n\tfor (i = 0; i < ARRAY_SIZE(io_target); i++) {\n\t\tstruct regmap *target;\n\t\tstruct resource *res;\n\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   io_target[i].name);\n\n\t\ttarget = ocelot_regmap_init(ocelot, res);\n\t\tif (IS_ERR(target)) {\n\t\t\tif (io_target[i].optional) {\n\t\t\t\tocelot->targets[io_target[i].id] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = PTR_ERR(target);\n\t\t\tgoto out_free_devlink;\n\t\t}\n\n\t\tocelot->targets[io_target[i].id] = target;\n\t}\n\n\tif (ocelot->targets[FDMA])\n\t\tocelot_fdma_init(pdev, ocelot);\n\n\thsio = syscon_regmap_lookup_by_compatible(\"mscc,ocelot-hsio\");\n\tif (IS_ERR(hsio)) {\n\t\tdev_err(&pdev->dev, \"missing hsio syscon\\n\");\n\t\terr = PTR_ERR(hsio);\n\t\tgoto out_free_devlink;\n\t}\n\n\tocelot->targets[HSIO] = hsio;\n\n\terr = ocelot_chip_init(ocelot, &ocelot_ops);\n\tif (err)\n\t\tgoto out_free_devlink;\n\n\tirq_xtr = platform_get_irq_byname(pdev, \"xtr\");\n\tif (irq_xtr < 0) {\n\t\terr = irq_xtr;\n\t\tgoto out_free_devlink;\n\t}\n\n\terr = devm_request_threaded_irq(&pdev->dev, irq_xtr, NULL,\n\t\t\t\t\tocelot_xtr_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\t\"frame extraction\", ocelot);\n\tif (err)\n\t\tgoto out_free_devlink;\n\n\tirq_ptp_rdy = platform_get_irq_byname(pdev, \"ptp_rdy\");\n\tif (irq_ptp_rdy > 0 && ocelot->targets[PTP]) {\n\t\terr = devm_request_threaded_irq(&pdev->dev, irq_ptp_rdy, NULL,\n\t\t\t\t\t\tocelot_ptp_rdy_irq_handler,\n\t\t\t\t\t\tIRQF_ONESHOT, \"ptp ready\",\n\t\t\t\t\t\tocelot);\n\t\tif (err)\n\t\t\tgoto out_free_devlink;\n\n\t\t \n\t\tocelot->ptp = 1;\n\t}\n\n\tports = of_get_child_by_name(np, \"ethernet-ports\");\n\tif (!ports) {\n\t\tdev_err(ocelot->dev, \"no ethernet-ports child node found\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out_free_devlink;\n\t}\n\n\tocelot->num_phys_ports = of_get_child_count(ports);\n\tocelot->num_flooding_pgids = 1;\n\n\tocelot->vcap = vsc7514_vcap_props;\n\n\tocelot->vcap_pol.base = VSC7514_VCAP_POLICER_BASE;\n\tocelot->vcap_pol.max = VSC7514_VCAP_POLICER_MAX;\n\n\tocelot->npi = -1;\n\n\terr = ocelot_init(ocelot);\n\tif (err)\n\t\tgoto out_put_ports;\n\n\terr = mscc_ocelot_init_ports(pdev, ports);\n\tif (err)\n\t\tgoto out_ocelot_devlink_unregister;\n\n\tif (ocelot->fdma)\n\t\tocelot_fdma_start(ocelot);\n\n\terr = ocelot_devlink_sb_register(ocelot);\n\tif (err)\n\t\tgoto out_ocelot_release_ports;\n\n\tif (ocelot->ptp) {\n\t\terr = ocelot_init_timestamp(ocelot, &ocelot_ptp_clock_info);\n\t\tif (err) {\n\t\t\tdev_err(ocelot->dev,\n\t\t\t\t\"Timestamp initialization failed\\n\");\n\t\t\tocelot->ptp = 0;\n\t\t}\n\t}\n\n\tregister_netdevice_notifier(&ocelot_netdevice_nb);\n\tregister_switchdev_notifier(&ocelot_switchdev_nb);\n\tregister_switchdev_blocking_notifier(&ocelot_switchdev_blocking_nb);\n\n\tof_node_put(ports);\n\tdevlink_register(devlink);\n\n\tdev_info(&pdev->dev, \"Ocelot switch probed\\n\");\n\n\treturn 0;\n\nout_ocelot_release_ports:\n\tmscc_ocelot_release_ports(ocelot);\n\tmscc_ocelot_teardown_devlink_ports(ocelot);\nout_ocelot_devlink_unregister:\n\tocelot_deinit(ocelot);\nout_put_ports:\n\tof_node_put(ports);\nout_free_devlink:\n\tdevlink_free(devlink);\n\treturn err;\n}\n\nstatic int mscc_ocelot_remove(struct platform_device *pdev)\n{\n\tstruct ocelot *ocelot = platform_get_drvdata(pdev);\n\n\tif (ocelot->fdma)\n\t\tocelot_fdma_deinit(ocelot);\n\tdevlink_unregister(ocelot->devlink);\n\tocelot_deinit_timestamp(ocelot);\n\tocelot_devlink_sb_unregister(ocelot);\n\tmscc_ocelot_release_ports(ocelot);\n\tmscc_ocelot_teardown_devlink_ports(ocelot);\n\tocelot_deinit(ocelot);\n\tunregister_switchdev_blocking_notifier(&ocelot_switchdev_blocking_nb);\n\tunregister_switchdev_notifier(&ocelot_switchdev_nb);\n\tunregister_netdevice_notifier(&ocelot_netdevice_nb);\n\tdevlink_free(ocelot->devlink);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mscc_ocelot_driver = {\n\t.probe = mscc_ocelot_probe,\n\t.remove = mscc_ocelot_remove,\n\t.driver = {\n\t\t.name = \"ocelot-switch\",\n\t\t.of_match_table = mscc_ocelot_match,\n\t},\n};\n\nmodule_platform_driver(mscc_ocelot_driver);\n\nMODULE_DESCRIPTION(\"Microsemi Ocelot switch driver\");\nMODULE_AUTHOR(\"Alexandre Belloni <alexandre.belloni@bootlin.com>\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}