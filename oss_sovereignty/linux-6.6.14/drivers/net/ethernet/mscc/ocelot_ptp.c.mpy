{
  "module_name": "ocelot_ptp.c",
  "hash_id": "fe309a78b32c5b9cb207531ac93ed447f08eee89a7afb9d386f3cab035f92763",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mscc/ocelot_ptp.c",
  "human_readable_source": "\n \n#include <linux/time64.h>\n\n#include <linux/dsa/ocelot.h>\n#include <linux/ptp_classify.h>\n#include <soc/mscc/ocelot_ptp.h>\n#include <soc/mscc/ocelot_sys.h>\n#include <soc/mscc/ocelot_vcap.h>\n#include <soc/mscc/ocelot.h>\n#include \"ocelot.h\"\n\nint ocelot_ptp_gettime64(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tstruct ocelot *ocelot = container_of(ptp, struct ocelot, ptp_info);\n\tunsigned long flags;\n\ttime64_t s;\n\tu32 val;\n\ts64 ns;\n\n\tspin_lock_irqsave(&ocelot->ptp_clock_lock, flags);\n\n\tval = ocelot_read_rix(ocelot, PTP_PIN_CFG, TOD_ACC_PIN);\n\tval &= ~(PTP_PIN_CFG_SYNC | PTP_PIN_CFG_ACTION_MASK | PTP_PIN_CFG_DOM);\n\tval |= PTP_PIN_CFG_ACTION(PTP_PIN_ACTION_SAVE);\n\tocelot_write_rix(ocelot, val, PTP_PIN_CFG, TOD_ACC_PIN);\n\n\ts = ocelot_read_rix(ocelot, PTP_PIN_TOD_SEC_MSB, TOD_ACC_PIN) & 0xffff;\n\ts <<= 32;\n\ts += ocelot_read_rix(ocelot, PTP_PIN_TOD_SEC_LSB, TOD_ACC_PIN);\n\tns = ocelot_read_rix(ocelot, PTP_PIN_TOD_NSEC, TOD_ACC_PIN);\n\n\tspin_unlock_irqrestore(&ocelot->ptp_clock_lock, flags);\n\n\t \n\tif (ns >= 0x3ffffff0 && ns <= 0x3fffffff) {\n\t\ts--;\n\t\tns &= 0xf;\n\t\tns += 999999984;\n\t}\n\n\tset_normalized_timespec64(ts, s, ns);\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_ptp_gettime64);\n\nint ocelot_ptp_settime64(struct ptp_clock_info *ptp,\n\t\t\t const struct timespec64 *ts)\n{\n\tstruct ocelot *ocelot = container_of(ptp, struct ocelot, ptp_info);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&ocelot->ptp_clock_lock, flags);\n\n\tval = ocelot_read_rix(ocelot, PTP_PIN_CFG, TOD_ACC_PIN);\n\tval &= ~(PTP_PIN_CFG_SYNC | PTP_PIN_CFG_ACTION_MASK | PTP_PIN_CFG_DOM);\n\tval |= PTP_PIN_CFG_ACTION(PTP_PIN_ACTION_IDLE);\n\n\tocelot_write_rix(ocelot, val, PTP_PIN_CFG, TOD_ACC_PIN);\n\n\tocelot_write_rix(ocelot, lower_32_bits(ts->tv_sec), PTP_PIN_TOD_SEC_LSB,\n\t\t\t TOD_ACC_PIN);\n\tocelot_write_rix(ocelot, upper_32_bits(ts->tv_sec), PTP_PIN_TOD_SEC_MSB,\n\t\t\t TOD_ACC_PIN);\n\tocelot_write_rix(ocelot, ts->tv_nsec, PTP_PIN_TOD_NSEC, TOD_ACC_PIN);\n\n\tval = ocelot_read_rix(ocelot, PTP_PIN_CFG, TOD_ACC_PIN);\n\tval &= ~(PTP_PIN_CFG_SYNC | PTP_PIN_CFG_ACTION_MASK | PTP_PIN_CFG_DOM);\n\tval |= PTP_PIN_CFG_ACTION(PTP_PIN_ACTION_LOAD);\n\n\tocelot_write_rix(ocelot, val, PTP_PIN_CFG, TOD_ACC_PIN);\n\n\tspin_unlock_irqrestore(&ocelot->ptp_clock_lock, flags);\n\n\tif (ocelot->ops->tas_clock_adjust)\n\t\tocelot->ops->tas_clock_adjust(ocelot);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_ptp_settime64);\n\nint ocelot_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tif (delta > -(NSEC_PER_SEC / 2) && delta < (NSEC_PER_SEC / 2)) {\n\t\tstruct ocelot *ocelot = container_of(ptp, struct ocelot,\n\t\t\t\t\t\t     ptp_info);\n\t\tunsigned long flags;\n\t\tu32 val;\n\n\t\tspin_lock_irqsave(&ocelot->ptp_clock_lock, flags);\n\n\t\tval = ocelot_read_rix(ocelot, PTP_PIN_CFG, TOD_ACC_PIN);\n\t\tval &= ~(PTP_PIN_CFG_SYNC | PTP_PIN_CFG_ACTION_MASK |\n\t\t\t PTP_PIN_CFG_DOM);\n\t\tval |= PTP_PIN_CFG_ACTION(PTP_PIN_ACTION_IDLE);\n\n\t\tocelot_write_rix(ocelot, val, PTP_PIN_CFG, TOD_ACC_PIN);\n\n\t\tocelot_write_rix(ocelot, 0, PTP_PIN_TOD_SEC_LSB, TOD_ACC_PIN);\n\t\tocelot_write_rix(ocelot, 0, PTP_PIN_TOD_SEC_MSB, TOD_ACC_PIN);\n\t\tocelot_write_rix(ocelot, delta, PTP_PIN_TOD_NSEC, TOD_ACC_PIN);\n\n\t\tval = ocelot_read_rix(ocelot, PTP_PIN_CFG, TOD_ACC_PIN);\n\t\tval &= ~(PTP_PIN_CFG_SYNC | PTP_PIN_CFG_ACTION_MASK |\n\t\t\t PTP_PIN_CFG_DOM);\n\t\tval |= PTP_PIN_CFG_ACTION(PTP_PIN_ACTION_DELTA);\n\n\t\tocelot_write_rix(ocelot, val, PTP_PIN_CFG, TOD_ACC_PIN);\n\n\t\tspin_unlock_irqrestore(&ocelot->ptp_clock_lock, flags);\n\n\t\tif (ocelot->ops->tas_clock_adjust)\n\t\t\tocelot->ops->tas_clock_adjust(ocelot);\n\t} else {\n\t\t \n\t\tstruct timespec64 ts;\n\t\tu64 now;\n\n\t\tocelot_ptp_gettime64(ptp, &ts);\n\n\t\tnow = ktime_to_ns(timespec64_to_ktime(ts));\n\t\tts = ns_to_timespec64(now + delta);\n\n\t\tocelot_ptp_settime64(ptp, &ts);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_ptp_adjtime);\n\nint ocelot_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct ocelot *ocelot = container_of(ptp, struct ocelot, ptp_info);\n\tu32 unit = 0, direction = 0;\n\tunsigned long flags;\n\tu64 adj = 0;\n\n\tspin_lock_irqsave(&ocelot->ptp_clock_lock, flags);\n\n\tif (!scaled_ppm)\n\t\tgoto disable_adj;\n\n\tif (scaled_ppm < 0) {\n\t\tdirection = PTP_CFG_CLK_ADJ_CFG_DIR;\n\t\tscaled_ppm = -scaled_ppm;\n\t}\n\n\tadj = PSEC_PER_SEC << 16;\n\tdo_div(adj, scaled_ppm);\n\tdo_div(adj, 1000);\n\n\t \n\tif (adj >= (1L << 30)) {\n\t\tunit = PTP_CFG_CLK_ADJ_FREQ_NS;\n\t\tdo_div(adj, 1000);\n\t}\n\n\t \n\tif (adj >= (1L << 30))\n\t\tgoto disable_adj;\n\n\tocelot_write(ocelot, unit | adj, PTP_CLK_CFG_ADJ_FREQ);\n\tocelot_write(ocelot, PTP_CFG_CLK_ADJ_CFG_ENA | direction,\n\t\t     PTP_CLK_CFG_ADJ_CFG);\n\n\tspin_unlock_irqrestore(&ocelot->ptp_clock_lock, flags);\n\treturn 0;\n\ndisable_adj:\n\tocelot_write(ocelot, 0, PTP_CLK_CFG_ADJ_CFG);\n\n\tspin_unlock_irqrestore(&ocelot->ptp_clock_lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_ptp_adjfine);\n\nint ocelot_ptp_verify(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t      enum ptp_pin_function func, unsigned int chan)\n{\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_PEROUT:\n\t\tbreak;\n\tcase PTP_PF_EXTTS:\n\tcase PTP_PF_PHYSYNC:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_ptp_verify);\n\nint ocelot_ptp_enable(struct ptp_clock_info *ptp,\n\t\t      struct ptp_clock_request *rq, int on)\n{\n\tstruct ocelot *ocelot = container_of(ptp, struct ocelot, ptp_info);\n\tstruct timespec64 ts_phase, ts_period;\n\tenum ocelot_ptp_pins ptp_pin;\n\tunsigned long flags;\n\tbool pps = false;\n\tint pin = -1;\n\ts64 wf_high;\n\ts64 wf_low;\n\tu32 val;\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_PEROUT:\n\t\t \n\t\tif (rq->perout.flags & ~(PTP_PEROUT_DUTY_CYCLE |\n\t\t\t\t\t PTP_PEROUT_PHASE))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tpin = ptp_find_pin(ocelot->ptp_clock, PTP_PF_PEROUT,\n\t\t\t\t   rq->perout.index);\n\t\tif (pin == 0)\n\t\t\tptp_pin = PTP_PIN_0;\n\t\telse if (pin == 1)\n\t\t\tptp_pin = PTP_PIN_1;\n\t\telse if (pin == 2)\n\t\t\tptp_pin = PTP_PIN_2;\n\t\telse if (pin == 3)\n\t\t\tptp_pin = PTP_PIN_3;\n\t\telse\n\t\t\treturn -EBUSY;\n\n\t\tts_period.tv_sec = rq->perout.period.sec;\n\t\tts_period.tv_nsec = rq->perout.period.nsec;\n\n\t\tif (ts_period.tv_sec == 1 && ts_period.tv_nsec == 0)\n\t\t\tpps = true;\n\n\t\t \n\t\tif (!on) {\n\t\t\tspin_lock_irqsave(&ocelot->ptp_clock_lock, flags);\n\t\t\tval = PTP_PIN_CFG_ACTION(PTP_PIN_ACTION_IDLE);\n\t\t\tocelot_write_rix(ocelot, val, PTP_PIN_CFG, ptp_pin);\n\t\t\tspin_unlock_irqrestore(&ocelot->ptp_clock_lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rq->perout.flags & PTP_PEROUT_PHASE) {\n\t\t\tts_phase.tv_sec = rq->perout.phase.sec;\n\t\t\tts_phase.tv_nsec = rq->perout.phase.nsec;\n\t\t} else {\n\t\t\t \n\t\t\tts_phase.tv_sec = rq->perout.start.sec;\n\t\t\tts_phase.tv_nsec = rq->perout.start.nsec;\n\t\t}\n\t\tif (ts_phase.tv_sec || (ts_phase.tv_nsec && !pps)) {\n\t\t\tdev_warn(ocelot->dev,\n\t\t\t\t \"Absolute start time not supported!\\n\");\n\t\t\tdev_warn(ocelot->dev,\n\t\t\t\t \"Accept nsec for PPS phase adjustment, otherwise start time should be 0 0.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (rq->perout.flags & PTP_PEROUT_DUTY_CYCLE) {\n\t\t\tstruct timespec64 ts_on;\n\n\t\t\tts_on.tv_sec = rq->perout.on.sec;\n\t\t\tts_on.tv_nsec = rq->perout.on.nsec;\n\n\t\t\twf_high = timespec64_to_ns(&ts_on);\n\t\t} else {\n\t\t\tif (pps) {\n\t\t\t\twf_high = 1000;\n\t\t\t} else {\n\t\t\t\twf_high = timespec64_to_ns(&ts_period);\n\t\t\t\twf_high = div_s64(wf_high, 2);\n\t\t\t}\n\t\t}\n\n\t\twf_low = timespec64_to_ns(&ts_period);\n\t\twf_low -= wf_high;\n\n\t\t \n\t\tif (pps) {\n\t\t\tspin_lock_irqsave(&ocelot->ptp_clock_lock, flags);\n\t\t\tocelot_write_rix(ocelot, ts_phase.tv_nsec,\n\t\t\t\t\t PTP_PIN_WF_LOW_PERIOD, ptp_pin);\n\t\t\tocelot_write_rix(ocelot, wf_high,\n\t\t\t\t\t PTP_PIN_WF_HIGH_PERIOD, ptp_pin);\n\t\t\tval = PTP_PIN_CFG_ACTION(PTP_PIN_ACTION_CLOCK);\n\t\t\tval |= PTP_PIN_CFG_SYNC;\n\t\t\tocelot_write_rix(ocelot, val, PTP_PIN_CFG, ptp_pin);\n\t\t\tspin_unlock_irqrestore(&ocelot->ptp_clock_lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (wf_high > 0x3fffffff || wf_high <= 0x6)\n\t\t\treturn -EINVAL;\n\t\tif (wf_low > 0x3fffffff || wf_low <= 0x6)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irqsave(&ocelot->ptp_clock_lock, flags);\n\t\tocelot_write_rix(ocelot, wf_low, PTP_PIN_WF_LOW_PERIOD,\n\t\t\t\t ptp_pin);\n\t\tocelot_write_rix(ocelot, wf_high, PTP_PIN_WF_HIGH_PERIOD,\n\t\t\t\t ptp_pin);\n\t\tval = PTP_PIN_CFG_ACTION(PTP_PIN_ACTION_CLOCK);\n\t\tocelot_write_rix(ocelot, val, PTP_PIN_CFG, ptp_pin);\n\t\tspin_unlock_irqrestore(&ocelot->ptp_clock_lock, flags);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_ptp_enable);\n\nstatic void ocelot_populate_l2_ptp_trap_key(struct ocelot_vcap_filter *trap)\n{\n\ttrap->key_type = OCELOT_VCAP_KEY_ETYPE;\n\t*(__be16 *)trap->key.etype.etype.value = htons(ETH_P_1588);\n\t*(__be16 *)trap->key.etype.etype.mask = htons(0xffff);\n}\n\nstatic void\nocelot_populate_ipv4_ptp_event_trap_key(struct ocelot_vcap_filter *trap)\n{\n\ttrap->key_type = OCELOT_VCAP_KEY_IPV4;\n\ttrap->key.ipv4.proto.value[0] = IPPROTO_UDP;\n\ttrap->key.ipv4.proto.mask[0] = 0xff;\n\ttrap->key.ipv4.dport.value = PTP_EV_PORT;\n\ttrap->key.ipv4.dport.mask = 0xffff;\n}\n\nstatic void\nocelot_populate_ipv6_ptp_event_trap_key(struct ocelot_vcap_filter *trap)\n{\n\ttrap->key_type = OCELOT_VCAP_KEY_IPV6;\n\ttrap->key.ipv6.proto.value[0] = IPPROTO_UDP;\n\ttrap->key.ipv6.proto.mask[0] = 0xff;\n\ttrap->key.ipv6.dport.value = PTP_EV_PORT;\n\ttrap->key.ipv6.dport.mask = 0xffff;\n}\n\nstatic void\nocelot_populate_ipv4_ptp_general_trap_key(struct ocelot_vcap_filter *trap)\n{\n\ttrap->key_type = OCELOT_VCAP_KEY_IPV4;\n\ttrap->key.ipv4.proto.value[0] = IPPROTO_UDP;\n\ttrap->key.ipv4.proto.mask[0] = 0xff;\n\ttrap->key.ipv4.dport.value = PTP_GEN_PORT;\n\ttrap->key.ipv4.dport.mask = 0xffff;\n}\n\nstatic void\nocelot_populate_ipv6_ptp_general_trap_key(struct ocelot_vcap_filter *trap)\n{\n\ttrap->key_type = OCELOT_VCAP_KEY_IPV6;\n\ttrap->key.ipv6.proto.value[0] = IPPROTO_UDP;\n\ttrap->key.ipv6.proto.mask[0] = 0xff;\n\ttrap->key.ipv6.dport.value = PTP_GEN_PORT;\n\ttrap->key.ipv6.dport.mask = 0xffff;\n}\n\nstatic int ocelot_l2_ptp_trap_add(struct ocelot *ocelot, int port)\n{\n\tunsigned long l2_cookie = OCELOT_VCAP_IS2_L2_PTP_TRAP(ocelot);\n\n\treturn ocelot_trap_add(ocelot, port, l2_cookie, true,\n\t\t\t       ocelot_populate_l2_ptp_trap_key);\n}\n\nstatic int ocelot_l2_ptp_trap_del(struct ocelot *ocelot, int port)\n{\n\tunsigned long l2_cookie = OCELOT_VCAP_IS2_L2_PTP_TRAP(ocelot);\n\n\treturn ocelot_trap_del(ocelot, port, l2_cookie);\n}\n\nstatic int ocelot_ipv4_ptp_trap_add(struct ocelot *ocelot, int port)\n{\n\tunsigned long ipv4_gen_cookie = OCELOT_VCAP_IS2_IPV4_GEN_PTP_TRAP(ocelot);\n\tunsigned long ipv4_ev_cookie = OCELOT_VCAP_IS2_IPV4_EV_PTP_TRAP(ocelot);\n\tint err;\n\n\terr = ocelot_trap_add(ocelot, port, ipv4_ev_cookie, true,\n\t\t\t      ocelot_populate_ipv4_ptp_event_trap_key);\n\tif (err)\n\t\treturn err;\n\n\terr = ocelot_trap_add(ocelot, port, ipv4_gen_cookie, false,\n\t\t\t      ocelot_populate_ipv4_ptp_general_trap_key);\n\tif (err)\n\t\tocelot_trap_del(ocelot, port, ipv4_ev_cookie);\n\n\treturn err;\n}\n\nstatic int ocelot_ipv4_ptp_trap_del(struct ocelot *ocelot, int port)\n{\n\tunsigned long ipv4_gen_cookie = OCELOT_VCAP_IS2_IPV4_GEN_PTP_TRAP(ocelot);\n\tunsigned long ipv4_ev_cookie = OCELOT_VCAP_IS2_IPV4_EV_PTP_TRAP(ocelot);\n\tint err;\n\n\terr = ocelot_trap_del(ocelot, port, ipv4_ev_cookie);\n\terr |= ocelot_trap_del(ocelot, port, ipv4_gen_cookie);\n\treturn err;\n}\n\nstatic int ocelot_ipv6_ptp_trap_add(struct ocelot *ocelot, int port)\n{\n\tunsigned long ipv6_gen_cookie = OCELOT_VCAP_IS2_IPV6_GEN_PTP_TRAP(ocelot);\n\tunsigned long ipv6_ev_cookie = OCELOT_VCAP_IS2_IPV6_EV_PTP_TRAP(ocelot);\n\tint err;\n\n\terr = ocelot_trap_add(ocelot, port, ipv6_ev_cookie, true,\n\t\t\t      ocelot_populate_ipv6_ptp_event_trap_key);\n\tif (err)\n\t\treturn err;\n\n\terr = ocelot_trap_add(ocelot, port, ipv6_gen_cookie, false,\n\t\t\t      ocelot_populate_ipv6_ptp_general_trap_key);\n\tif (err)\n\t\tocelot_trap_del(ocelot, port, ipv6_ev_cookie);\n\n\treturn err;\n}\n\nstatic int ocelot_ipv6_ptp_trap_del(struct ocelot *ocelot, int port)\n{\n\tunsigned long ipv6_gen_cookie = OCELOT_VCAP_IS2_IPV6_GEN_PTP_TRAP(ocelot);\n\tunsigned long ipv6_ev_cookie = OCELOT_VCAP_IS2_IPV6_EV_PTP_TRAP(ocelot);\n\tint err;\n\n\terr = ocelot_trap_del(ocelot, port, ipv6_ev_cookie);\n\terr |= ocelot_trap_del(ocelot, port, ipv6_gen_cookie);\n\treturn err;\n}\n\nstatic int ocelot_setup_ptp_traps(struct ocelot *ocelot, int port,\n\t\t\t\t  bool l2, bool l4)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tint err;\n\n\tocelot_port->trap_proto &= ~(OCELOT_PROTO_PTP_L2 |\n\t\t\t\t     OCELOT_PROTO_PTP_L4);\n\n\tif (l2)\n\t\terr = ocelot_l2_ptp_trap_add(ocelot, port);\n\telse\n\t\terr = ocelot_l2_ptp_trap_del(ocelot, port);\n\tif (err)\n\t\treturn err;\n\n\tif (l4) {\n\t\terr = ocelot_ipv4_ptp_trap_add(ocelot, port);\n\t\tif (err)\n\t\t\tgoto err_ipv4;\n\n\t\terr = ocelot_ipv6_ptp_trap_add(ocelot, port);\n\t\tif (err)\n\t\t\tgoto err_ipv6;\n\t} else {\n\t\terr = ocelot_ipv4_ptp_trap_del(ocelot, port);\n\n\t\terr |= ocelot_ipv6_ptp_trap_del(ocelot, port);\n\t}\n\tif (err)\n\t\treturn err;\n\n\tif (l2)\n\t\tocelot_port->trap_proto |= OCELOT_PROTO_PTP_L2;\n\tif (l4)\n\t\tocelot_port->trap_proto |= OCELOT_PROTO_PTP_L4;\n\n\treturn 0;\n\nerr_ipv6:\n\tocelot_ipv4_ptp_trap_del(ocelot, port);\nerr_ipv4:\n\tif (l2)\n\t\tocelot_l2_ptp_trap_del(ocelot, port);\n\treturn err;\n}\n\nstatic int ocelot_traps_to_ptp_rx_filter(unsigned int proto)\n{\n\tif ((proto & OCELOT_PROTO_PTP_L2) && (proto & OCELOT_PROTO_PTP_L4))\n\t\treturn HWTSTAMP_FILTER_PTP_V2_EVENT;\n\telse if (proto & OCELOT_PROTO_PTP_L2)\n\t\treturn HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\n\telse if (proto & OCELOT_PROTO_PTP_L4)\n\t\treturn HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\n\n\treturn HWTSTAMP_FILTER_NONE;\n}\n\nint ocelot_hwstamp_get(struct ocelot *ocelot, int port, struct ifreq *ifr)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tstruct hwtstamp_config cfg = {};\n\n\tswitch (ocelot_port->ptp_cmd) {\n\tcase IFH_REW_OP_TWO_STEP_PTP:\n\t\tcfg.tx_type = HWTSTAMP_TX_ON;\n\t\tbreak;\n\tcase IFH_REW_OP_ORIGIN_PTP:\n\t\tcfg.tx_type = HWTSTAMP_TX_ONESTEP_SYNC;\n\t\tbreak;\n\tdefault:\n\t\tcfg.tx_type = HWTSTAMP_TX_OFF;\n\t\tbreak;\n\t}\n\n\tcfg.rx_filter = ocelot_traps_to_ptp_rx_filter(ocelot_port->trap_proto);\n\n\treturn copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\n}\nEXPORT_SYMBOL(ocelot_hwstamp_get);\n\nint ocelot_hwstamp_set(struct ocelot *ocelot, int port, struct ifreq *ifr)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tbool l2 = false, l4 = false;\n\tstruct hwtstamp_config cfg;\n\tint err;\n\n\tif (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))\n\t\treturn -EFAULT;\n\n\t \n\tswitch (cfg.tx_type) {\n\tcase HWTSTAMP_TX_ON:\n\t\tocelot_port->ptp_cmd = IFH_REW_OP_TWO_STEP_PTP;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\t\t \n\t\tocelot_port->ptp_cmd = IFH_REW_OP_ORIGIN_PTP;\n\t\tbreak;\n\tcase HWTSTAMP_TX_OFF:\n\t\tocelot_port->ptp_cmd = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (cfg.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\tl4 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\t\tl2 = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\tl2 = true;\n\t\tl4 = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\terr = ocelot_setup_ptp_traps(ocelot, port, l2, l4);\n\tif (err)\n\t\treturn err;\n\n\tcfg.rx_filter = ocelot_traps_to_ptp_rx_filter(ocelot_port->trap_proto);\n\n\treturn copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\n}\nEXPORT_SYMBOL(ocelot_hwstamp_set);\n\nint ocelot_get_ts_info(struct ocelot *ocelot, int port,\n\t\t       struct ethtool_ts_info *info)\n{\n\tinfo->phc_index = ocelot->ptp_clock ?\n\t\t\t  ptp_clock_index(ocelot->ptp_clock) : -1;\n\tif (info->phc_index == -1) {\n\t\tinfo->so_timestamping |= SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\t\t SOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\t\t SOF_TIMESTAMPING_SOFTWARE;\n\t\treturn 0;\n\t}\n\tinfo->so_timestamping |= SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\t SOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\t SOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\t SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\t SOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\t SOF_TIMESTAMPING_RAW_HARDWARE;\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF) | BIT(HWTSTAMP_TX_ON) |\n\t\t\t BIT(HWTSTAMP_TX_ONESTEP_SYNC);\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_EVENT) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_L4_EVENT);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_get_ts_info);\n\nstatic int ocelot_port_add_txtstamp_skb(struct ocelot *ocelot, int port,\n\t\t\t\t\tstruct sk_buff *clone)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ocelot->ts_id_lock, flags);\n\n\tif (ocelot_port->ptp_skbs_in_flight == OCELOT_MAX_PTP_ID ||\n\t    ocelot->ptp_skbs_in_flight == OCELOT_PTP_FIFO_SIZE) {\n\t\tspin_unlock_irqrestore(&ocelot->ts_id_lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tskb_shinfo(clone)->tx_flags |= SKBTX_IN_PROGRESS;\n\t \n\tOCELOT_SKB_CB(clone)->ts_id = ocelot_port->ts_id;\n\n\tocelot_port->ts_id++;\n\tif (ocelot_port->ts_id == OCELOT_MAX_PTP_ID)\n\t\tocelot_port->ts_id = 0;\n\n\tocelot_port->ptp_skbs_in_flight++;\n\tocelot->ptp_skbs_in_flight++;\n\n\tskb_queue_tail(&ocelot_port->tx_skbs, clone);\n\n\tspin_unlock_irqrestore(&ocelot->ts_id_lock, flags);\n\n\treturn 0;\n}\n\nstatic bool ocelot_ptp_is_onestep_sync(struct sk_buff *skb,\n\t\t\t\t       unsigned int ptp_class)\n{\n\tstruct ptp_header *hdr;\n\tu8 msgtype, twostep;\n\n\thdr = ptp_parse_header(skb, ptp_class);\n\tif (!hdr)\n\t\treturn false;\n\n\tmsgtype = ptp_get_msgtype(hdr, ptp_class);\n\ttwostep = hdr->flag_field[0] & 0x2;\n\n\tif (msgtype == PTP_MSGTYPE_SYNC && twostep == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nint ocelot_port_txtstamp_request(struct ocelot *ocelot, int port,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t struct sk_buff **clone)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tu8 ptp_cmd = ocelot_port->ptp_cmd;\n\tunsigned int ptp_class;\n\tint err;\n\n\t \n\tif (!ptp_cmd)\n\t\treturn 0;\n\n\tptp_class = ptp_classify_raw(skb);\n\tif (ptp_class == PTP_CLASS_NONE)\n\t\treturn -EINVAL;\n\n\t \n\tif (ptp_cmd == IFH_REW_OP_ORIGIN_PTP) {\n\t\tif (ocelot_ptp_is_onestep_sync(skb, ptp_class)) {\n\t\t\tOCELOT_SKB_CB(skb)->ptp_cmd = ptp_cmd;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tptp_cmd = IFH_REW_OP_TWO_STEP_PTP;\n\t}\n\n\tif (ptp_cmd == IFH_REW_OP_TWO_STEP_PTP) {\n\t\t*clone = skb_clone_sk(skb);\n\t\tif (!(*clone))\n\t\t\treturn -ENOMEM;\n\n\t\terr = ocelot_port_add_txtstamp_skb(ocelot, port, *clone);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tOCELOT_SKB_CB(skb)->ptp_cmd = ptp_cmd;\n\t\tOCELOT_SKB_CB(*clone)->ptp_class = ptp_class;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_port_txtstamp_request);\n\nstatic void ocelot_get_hwtimestamp(struct ocelot *ocelot,\n\t\t\t\t   struct timespec64 *ts)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&ocelot->ptp_clock_lock, flags);\n\n\t \n\tval = ocelot_read_rix(ocelot, PTP_PIN_CFG, TOD_ACC_PIN);\n\n\tval &= ~(PTP_PIN_CFG_SYNC | PTP_PIN_CFG_ACTION_MASK | PTP_PIN_CFG_DOM);\n\tval |= PTP_PIN_CFG_ACTION(PTP_PIN_ACTION_SAVE);\n\tocelot_write_rix(ocelot, val, PTP_PIN_CFG, TOD_ACC_PIN);\n\tts->tv_sec = ocelot_read_rix(ocelot, PTP_PIN_TOD_SEC_LSB, TOD_ACC_PIN);\n\n\t \n\tval = ocelot_read(ocelot, SYS_PTP_TXSTAMP);\n\tts->tv_nsec = SYS_PTP_TXSTAMP_PTP_TXSTAMP(val);\n\n\t \n\tif ((ts->tv_sec & 0x1) != !!(val & SYS_PTP_TXSTAMP_PTP_TXSTAMP_SEC))\n\t\tts->tv_sec--;\n\n\tspin_unlock_irqrestore(&ocelot->ptp_clock_lock, flags);\n}\n\nstatic bool ocelot_validate_ptp_skb(struct sk_buff *clone, u16 seqid)\n{\n\tstruct ptp_header *hdr;\n\n\thdr = ptp_parse_header(clone, OCELOT_SKB_CB(clone)->ptp_class);\n\tif (WARN_ON(!hdr))\n\t\treturn false;\n\n\treturn seqid == ntohs(hdr->sequence_id);\n}\n\nvoid ocelot_get_txtstamp(struct ocelot *ocelot)\n{\n\tint budget = OCELOT_PTP_QUEUE_SZ;\n\n\twhile (budget--) {\n\t\tstruct sk_buff *skb, *skb_tmp, *skb_match = NULL;\n\t\tstruct skb_shared_hwtstamps shhwtstamps;\n\t\tu32 val, id, seqid, txport;\n\t\tstruct ocelot_port *port;\n\t\tstruct timespec64 ts;\n\t\tunsigned long flags;\n\n\t\tval = ocelot_read(ocelot, SYS_PTP_STATUS);\n\n\t\t \n\t\tif (!(val & SYS_PTP_STATUS_PTP_MESS_VLD))\n\t\t\tbreak;\n\n\t\tWARN_ON(val & SYS_PTP_STATUS_PTP_OVFL);\n\n\t\t \n\t\tid = SYS_PTP_STATUS_PTP_MESS_ID_X(val);\n\t\ttxport = SYS_PTP_STATUS_PTP_MESS_TXPORT_X(val);\n\t\tseqid = SYS_PTP_STATUS_PTP_MESS_SEQ_ID(val);\n\n\t\tport = ocelot->ports[txport];\n\n\t\tspin_lock(&ocelot->ts_id_lock);\n\t\tport->ptp_skbs_in_flight--;\n\t\tocelot->ptp_skbs_in_flight--;\n\t\tspin_unlock(&ocelot->ts_id_lock);\n\n\t\t \ntry_again:\n\t\tspin_lock_irqsave(&port->tx_skbs.lock, flags);\n\n\t\tskb_queue_walk_safe(&port->tx_skbs, skb, skb_tmp) {\n\t\t\tif (OCELOT_SKB_CB(skb)->ts_id != id)\n\t\t\t\tcontinue;\n\t\t\t__skb_unlink(skb, &port->tx_skbs);\n\t\t\tskb_match = skb;\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&port->tx_skbs.lock, flags);\n\n\t\tif (WARN_ON(!skb_match))\n\t\t\tcontinue;\n\n\t\tif (!ocelot_validate_ptp_skb(skb_match, seqid)) {\n\t\t\tdev_err_ratelimited(ocelot->dev,\n\t\t\t\t\t    \"port %d received stale TX timestamp for seqid %d, discarding\\n\",\n\t\t\t\t\t    txport, seqid);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tgoto try_again;\n\t\t}\n\n\t\t \n\t\tocelot_get_hwtimestamp(ocelot, &ts);\n\n\t\t \n\t\tmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\n\t\tshhwtstamps.hwtstamp = ktime_set(ts.tv_sec, ts.tv_nsec);\n\t\tskb_complete_tx_timestamp(skb_match, &shhwtstamps);\n\n\t\t \n\t\tocelot_write(ocelot, SYS_PTP_NXT_PTP_NXT, SYS_PTP_NXT);\n\t}\n}\nEXPORT_SYMBOL(ocelot_get_txtstamp);\n\nint ocelot_init_timestamp(struct ocelot *ocelot,\n\t\t\t  const struct ptp_clock_info *info)\n{\n\tstruct ptp_clock *ptp_clock;\n\tint i;\n\n\tocelot->ptp_info = *info;\n\n\tfor (i = 0; i < OCELOT_PTP_PINS_NUM; i++) {\n\t\tstruct ptp_pin_desc *p = &ocelot->ptp_pins[i];\n\n\t\tsnprintf(p->name, sizeof(p->name), \"switch_1588_dat%d\", i);\n\t\tp->index = i;\n\t\tp->func = PTP_PF_NONE;\n\t}\n\n\tocelot->ptp_info.pin_config = &ocelot->ptp_pins[0];\n\n\tptp_clock = ptp_clock_register(&ocelot->ptp_info, ocelot->dev);\n\tif (IS_ERR(ptp_clock))\n\t\treturn PTR_ERR(ptp_clock);\n\t \n\tif (!ptp_clock)\n\t\treturn 0;\n\n\tocelot->ptp_clock = ptp_clock;\n\n\tocelot_write(ocelot, SYS_PTP_CFG_PTP_STAMP_WID(30), SYS_PTP_CFG);\n\tocelot_write(ocelot, 0xffffffff, ANA_TABLES_PTP_ID_LOW);\n\tocelot_write(ocelot, 0xffffffff, ANA_TABLES_PTP_ID_HIGH);\n\n\tocelot_write(ocelot, PTP_CFG_MISC_PTP_EN, PTP_CFG_MISC);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_init_timestamp);\n\nint ocelot_deinit_timestamp(struct ocelot *ocelot)\n{\n\tif (ocelot->ptp_clock)\n\t\tptp_clock_unregister(ocelot->ptp_clock);\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_deinit_timestamp);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}