{
  "module_name": "ocelot_devlink.c",
  "hash_id": "4020206c739314b5197537a128bd1acf292e0c0152c082fa9a4ce2891148952d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mscc/ocelot_devlink.c",
  "human_readable_source": "\n \n#include <net/devlink.h>\n#include \"ocelot.h\"\n\n \n#define OCELOT_RESOURCE_SZ\t\t256\n#define OCELOT_NUM_RESOURCES\t\t4\n\n#define BUF_xxxx_I\t\t\t(0 * OCELOT_RESOURCE_SZ)\n#define REF_xxxx_I\t\t\t(1 * OCELOT_RESOURCE_SZ)\n#define BUF_xxxx_E\t\t\t(2 * OCELOT_RESOURCE_SZ)\n#define REF_xxxx_E\t\t\t(3 * OCELOT_RESOURCE_SZ)\n\n \n#define xxx_Q_RSRV_x\t\t\t0\n#define xxx_PRIO_SHR_x\t\t\t216\n#define xxx_P_RSRV_x\t\t\t224\n#define xxx_COL_SHR_x\t\t\t254\n\n \n\n \n#define BUF_Q_RSRV_E(port, prio) \\\n\t(BUF_xxxx_E + xxx_Q_RSRV_x + OCELOT_NUM_TC * (port) + (prio))\n\n \n#define BUF_P_RSRV_E(port) \\\n\t(BUF_xxxx_E + xxx_P_RSRV_x + (port))\n\n \n#define BUF_Q_RSRV_I(port, prio) \\\n\t(BUF_xxxx_I + xxx_Q_RSRV_x + OCELOT_NUM_TC * (port) + (prio))\n\n \n#define BUF_P_RSRV_I(port) \\\n\t(BUF_xxxx_I + xxx_P_RSRV_x + (port))\n\n \n#define REF_Q_RSRV_E(port, prio) \\\n\t(REF_xxxx_E + xxx_Q_RSRV_x + OCELOT_NUM_TC * (port) + (prio))\n\n \n#define REF_P_RSRV_E(port) \\\n\t(REF_xxxx_E + xxx_P_RSRV_x + (port))\n\n \n#define REF_Q_RSRV_I(port, prio) \\\n\t(REF_xxxx_I + xxx_Q_RSRV_x + OCELOT_NUM_TC * (port) + (prio))\n\n \n#define REF_P_RSRV_I(port) \\\n\t(REF_xxxx_I + xxx_P_RSRV_x + (port))\n\n \n\n \n#define BUF_PRIO_SHR_E(prio) \\\n\t(BUF_xxxx_E + xxx_PRIO_SHR_x + (prio))\n\n \n#define BUF_COL_SHR_E(dp) \\\n\t(BUF_xxxx_E + xxx_COL_SHR_x + (1 - (dp)))\n\n \n#define BUF_PRIO_SHR_I(prio) \\\n\t(BUF_xxxx_I + xxx_PRIO_SHR_x + (prio))\n\n \n#define BUF_COL_SHR_I(dp) \\\n\t(BUF_xxxx_I + xxx_COL_SHR_x + (1 - (dp)))\n\n \n#define REF_PRIO_SHR_E(prio) \\\n\t(REF_xxxx_E + xxx_PRIO_SHR_x + (prio))\n\n \n#define REF_COL_SHR_E(dp) \\\n\t(REF_xxxx_E + xxx_COL_SHR_x + (1 - (dp)))\n\n \n#define REF_PRIO_SHR_I(prio) \\\n\t(REF_xxxx_I + xxx_PRIO_SHR_x + (prio))\n\n \n#define REF_COL_SHR_I(dp) \\\n\t(REF_xxxx_I + xxx_COL_SHR_x + (1 - (dp)))\n\nstatic u32 ocelot_wm_read(struct ocelot *ocelot, int index)\n{\n\tint wm = ocelot_read_gix(ocelot, QSYS_RES_CFG, index);\n\n\treturn ocelot->ops->wm_dec(wm);\n}\n\nstatic void ocelot_wm_write(struct ocelot *ocelot, int index, u32 val)\n{\n\tu32 wm = ocelot->ops->wm_enc(val);\n\n\tocelot_write_gix(ocelot, wm, QSYS_RES_CFG, index);\n}\n\nstatic void ocelot_wm_status(struct ocelot *ocelot, int index, u32 *inuse,\n\t\t\t     u32 *maxuse)\n{\n\tint res_stat = ocelot_read_gix(ocelot, QSYS_RES_STAT, index);\n\n\treturn ocelot->ops->wm_stat(res_stat, inuse, maxuse);\n}\n\n \nstatic void ocelot_disable_reservation_watermarks(struct ocelot *ocelot,\n\t\t\t\t\t\t  int port)\n{\n\tint prio;\n\n\tfor (prio = 0; prio < OCELOT_NUM_TC; prio++) {\n\t\tocelot_wm_write(ocelot, BUF_Q_RSRV_I(port, prio), 0);\n\t\tocelot_wm_write(ocelot, BUF_Q_RSRV_E(port, prio), 0);\n\t\tocelot_wm_write(ocelot, REF_Q_RSRV_I(port, prio), 0);\n\t\tocelot_wm_write(ocelot, REF_Q_RSRV_E(port, prio), 0);\n\t}\n\n\tocelot_wm_write(ocelot, BUF_P_RSRV_I(port), 0);\n\tocelot_wm_write(ocelot, BUF_P_RSRV_E(port), 0);\n\tocelot_wm_write(ocelot, REF_P_RSRV_I(port), 0);\n\tocelot_wm_write(ocelot, REF_P_RSRV_E(port), 0);\n}\n\n \nstatic void ocelot_disable_tc_sharing_watermarks(struct ocelot *ocelot)\n{\n\tint prio;\n\n\tfor (prio = 0; prio < OCELOT_NUM_TC; prio++) {\n\t\tocelot_wm_write(ocelot, BUF_PRIO_SHR_I(prio), 0);\n\t\tocelot_wm_write(ocelot, BUF_PRIO_SHR_E(prio), 0);\n\t\tocelot_wm_write(ocelot, REF_PRIO_SHR_I(prio), 0);\n\t\tocelot_wm_write(ocelot, REF_PRIO_SHR_E(prio), 0);\n\t}\n}\n\nstatic void ocelot_get_buf_rsrv(struct ocelot *ocelot, u32 *buf_rsrv_i,\n\t\t\t\tu32 *buf_rsrv_e)\n{\n\tint port, prio;\n\n\t*buf_rsrv_i = 0;\n\t*buf_rsrv_e = 0;\n\n\tfor (port = 0; port <= ocelot->num_phys_ports; port++) {\n\t\tfor (prio = 0; prio < OCELOT_NUM_TC; prio++) {\n\t\t\t*buf_rsrv_i += ocelot_wm_read(ocelot,\n\t\t\t\t\t\t      BUF_Q_RSRV_I(port, prio));\n\t\t\t*buf_rsrv_e += ocelot_wm_read(ocelot,\n\t\t\t\t\t\t      BUF_Q_RSRV_E(port, prio));\n\t\t}\n\n\t\t*buf_rsrv_i += ocelot_wm_read(ocelot, BUF_P_RSRV_I(port));\n\t\t*buf_rsrv_e += ocelot_wm_read(ocelot, BUF_P_RSRV_E(port));\n\t}\n\n\t*buf_rsrv_i *= OCELOT_BUFFER_CELL_SZ;\n\t*buf_rsrv_e *= OCELOT_BUFFER_CELL_SZ;\n}\n\nstatic void ocelot_get_ref_rsrv(struct ocelot *ocelot, u32 *ref_rsrv_i,\n\t\t\t\tu32 *ref_rsrv_e)\n{\n\tint port, prio;\n\n\t*ref_rsrv_i = 0;\n\t*ref_rsrv_e = 0;\n\n\tfor (port = 0; port <= ocelot->num_phys_ports; port++) {\n\t\tfor (prio = 0; prio < OCELOT_NUM_TC; prio++) {\n\t\t\t*ref_rsrv_i += ocelot_wm_read(ocelot,\n\t\t\t\t\t\t      REF_Q_RSRV_I(port, prio));\n\t\t\t*ref_rsrv_e += ocelot_wm_read(ocelot,\n\t\t\t\t\t\t      REF_Q_RSRV_E(port, prio));\n\t\t}\n\n\t\t*ref_rsrv_i += ocelot_wm_read(ocelot, REF_P_RSRV_I(port));\n\t\t*ref_rsrv_e += ocelot_wm_read(ocelot, REF_P_RSRV_E(port));\n\t}\n}\n\n \nstatic void ocelot_setup_sharing_watermarks(struct ocelot *ocelot)\n{\n\tu32 buf_rsrv_i, buf_rsrv_e;\n\tu32 ref_rsrv_i, ref_rsrv_e;\n\tu32 buf_shr_i, buf_shr_e;\n\tu32 ref_shr_i, ref_shr_e;\n\n\tocelot_get_buf_rsrv(ocelot, &buf_rsrv_i, &buf_rsrv_e);\n\tocelot_get_ref_rsrv(ocelot, &ref_rsrv_i, &ref_rsrv_e);\n\n\tbuf_shr_i = ocelot->pool_size[OCELOT_SB_BUF][OCELOT_SB_POOL_ING] -\n\t\t    buf_rsrv_i;\n\tbuf_shr_e = ocelot->pool_size[OCELOT_SB_BUF][OCELOT_SB_POOL_EGR] -\n\t\t    buf_rsrv_e;\n\tref_shr_i = ocelot->pool_size[OCELOT_SB_REF][OCELOT_SB_POOL_ING] -\n\t\t    ref_rsrv_i;\n\tref_shr_e = ocelot->pool_size[OCELOT_SB_REF][OCELOT_SB_POOL_EGR] -\n\t\t    ref_rsrv_e;\n\n\tbuf_shr_i /= OCELOT_BUFFER_CELL_SZ;\n\tbuf_shr_e /= OCELOT_BUFFER_CELL_SZ;\n\n\tocelot_wm_write(ocelot, BUF_COL_SHR_I(0), buf_shr_i);\n\tocelot_wm_write(ocelot, BUF_COL_SHR_E(0), buf_shr_e);\n\tocelot_wm_write(ocelot, REF_COL_SHR_E(0), ref_shr_e);\n\tocelot_wm_write(ocelot, REF_COL_SHR_I(0), ref_shr_i);\n\tocelot_wm_write(ocelot, BUF_COL_SHR_I(1), 0);\n\tocelot_wm_write(ocelot, BUF_COL_SHR_E(1), 0);\n\tocelot_wm_write(ocelot, REF_COL_SHR_E(1), 0);\n\tocelot_wm_write(ocelot, REF_COL_SHR_I(1), 0);\n}\n\n \nstatic int ocelot_watermark_validate(struct ocelot *ocelot,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tu32 buf_rsrv_i, buf_rsrv_e;\n\tu32 ref_rsrv_i, ref_rsrv_e;\n\n\tocelot_get_buf_rsrv(ocelot, &buf_rsrv_i, &buf_rsrv_e);\n\tocelot_get_ref_rsrv(ocelot, &ref_rsrv_i, &ref_rsrv_e);\n\n\tif (buf_rsrv_i > ocelot->pool_size[OCELOT_SB_BUF][OCELOT_SB_POOL_ING]) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Ingress frame reservations exceed pool size\");\n\t\treturn -ERANGE;\n\t}\n\tif (buf_rsrv_e > ocelot->pool_size[OCELOT_SB_BUF][OCELOT_SB_POOL_EGR]) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Egress frame reservations exceed pool size\");\n\t\treturn -ERANGE;\n\t}\n\tif (ref_rsrv_i > ocelot->pool_size[OCELOT_SB_REF][OCELOT_SB_POOL_ING]) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Ingress reference reservations exceed pool size\");\n\t\treturn -ERANGE;\n\t}\n\tif (ref_rsrv_e > ocelot->pool_size[OCELOT_SB_REF][OCELOT_SB_POOL_EGR]) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Egress reference reservations exceed pool size\");\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ocelot_watermark_init(struct ocelot *ocelot)\n{\n\tint all_tcs = GENMASK(OCELOT_NUM_TC - 1, 0);\n\tint port;\n\n\tocelot_write(ocelot, all_tcs, QSYS_RES_QOS_MODE);\n\n\tfor (port = 0; port <= ocelot->num_phys_ports; port++)\n\t\tocelot_disable_reservation_watermarks(ocelot, port);\n\n\tocelot_disable_tc_sharing_watermarks(ocelot);\n\tocelot_setup_sharing_watermarks(ocelot);\n}\n\n \nu16 ocelot_wm_enc(u16 value)\n{\n\tWARN_ON(value >= 16 * BIT(8));\n\n\tif (value >= BIT(8))\n\t\treturn BIT(8) | (value / 16);\n\n\treturn value;\n}\nEXPORT_SYMBOL(ocelot_wm_enc);\n\nu16 ocelot_wm_dec(u16 wm)\n{\n\tif (wm & BIT(8))\n\t\treturn (wm & GENMASK(7, 0)) * 16;\n\n\treturn wm;\n}\nEXPORT_SYMBOL(ocelot_wm_dec);\n\nvoid ocelot_wm_stat(u32 val, u32 *inuse, u32 *maxuse)\n{\n\t*inuse = (val & GENMASK(23, 12)) >> 12;\n\t*maxuse = val & GENMASK(11, 0);\n}\nEXPORT_SYMBOL(ocelot_wm_stat);\n\n \nstatic const struct devlink_sb_pool_info ocelot_sb_pool[] = {\n\t[OCELOT_SB_BUF] = {\n\t\t.cell_size = OCELOT_BUFFER_CELL_SZ,\n\t\t.threshold_type = DEVLINK_SB_THRESHOLD_TYPE_STATIC,\n\t},\n\t[OCELOT_SB_REF] = {\n\t\t.cell_size = 1,\n\t\t.threshold_type = DEVLINK_SB_THRESHOLD_TYPE_STATIC,\n\t},\n};\n\n \nint ocelot_sb_pool_get(struct ocelot *ocelot, unsigned int sb_index,\n\t\t       u16 pool_index,\n\t\t       struct devlink_sb_pool_info *pool_info)\n{\n\tif (sb_index >= OCELOT_SB_NUM)\n\t\treturn -ENODEV;\n\tif (pool_index >= OCELOT_SB_POOL_NUM)\n\t\treturn -ENODEV;\n\n\t*pool_info = ocelot_sb_pool[sb_index];\n\tpool_info->size = ocelot->pool_size[sb_index][pool_index];\n\tif (pool_index)\n\t\tpool_info->pool_type = DEVLINK_SB_POOL_TYPE_INGRESS;\n\telse\n\t\tpool_info->pool_type = DEVLINK_SB_POOL_TYPE_EGRESS;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_sb_pool_get);\n\n \nint ocelot_sb_pool_set(struct ocelot *ocelot, unsigned int sb_index,\n\t\t       u16 pool_index, u32 size,\n\t\t       enum devlink_sb_threshold_type threshold_type,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tu32 old_pool_size;\n\tint err;\n\n\tif (sb_index >= OCELOT_SB_NUM) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid sb, use 0 for buffers and 1 for frame references\");\n\t\treturn -ENODEV;\n\t}\n\tif (pool_index >= OCELOT_SB_POOL_NUM) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid pool, use 0 for ingress and 1 for egress\");\n\t\treturn -ENODEV;\n\t}\n\tif (threshold_type != DEVLINK_SB_THRESHOLD_TYPE_STATIC) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Only static threshold supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\told_pool_size = ocelot->pool_size[sb_index][pool_index];\n\tocelot->pool_size[sb_index][pool_index] = size;\n\n\terr = ocelot_watermark_validate(ocelot, extack);\n\tif (err) {\n\t\tocelot->pool_size[sb_index][pool_index] = old_pool_size;\n\t\treturn err;\n\t}\n\n\tocelot_setup_sharing_watermarks(ocelot);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_sb_pool_set);\n\n \nint ocelot_sb_port_pool_get(struct ocelot *ocelot, int port,\n\t\t\t    unsigned int sb_index, u16 pool_index,\n\t\t\t    u32 *p_threshold)\n{\n\tint wm_index;\n\n\tswitch (sb_index) {\n\tcase OCELOT_SB_BUF:\n\t\tif (pool_index == OCELOT_SB_POOL_ING)\n\t\t\twm_index = BUF_P_RSRV_I(port);\n\t\telse\n\t\t\twm_index = BUF_P_RSRV_E(port);\n\t\tbreak;\n\tcase OCELOT_SB_REF:\n\t\tif (pool_index == OCELOT_SB_POOL_ING)\n\t\t\twm_index = REF_P_RSRV_I(port);\n\t\telse\n\t\t\twm_index = REF_P_RSRV_E(port);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\t*p_threshold = ocelot_wm_read(ocelot, wm_index);\n\t*p_threshold *= ocelot_sb_pool[sb_index].cell_size;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_sb_port_pool_get);\n\n \nint ocelot_sb_port_pool_set(struct ocelot *ocelot, int port,\n\t\t\t    unsigned int sb_index, u16 pool_index,\n\t\t\t    u32 threshold, struct netlink_ext_ack *extack)\n{\n\tint wm_index, err;\n\tu32 old_thr;\n\n\tswitch (sb_index) {\n\tcase OCELOT_SB_BUF:\n\t\tif (pool_index == OCELOT_SB_POOL_ING)\n\t\t\twm_index = BUF_P_RSRV_I(port);\n\t\telse\n\t\t\twm_index = BUF_P_RSRV_E(port);\n\t\tbreak;\n\tcase OCELOT_SB_REF:\n\t\tif (pool_index == OCELOT_SB_POOL_ING)\n\t\t\twm_index = REF_P_RSRV_I(port);\n\t\telse\n\t\t\twm_index = REF_P_RSRV_E(port);\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid shared buffer\");\n\t\treturn -ENODEV;\n\t}\n\n\tthreshold /= ocelot_sb_pool[sb_index].cell_size;\n\n\told_thr = ocelot_wm_read(ocelot, wm_index);\n\tocelot_wm_write(ocelot, wm_index, threshold);\n\n\terr = ocelot_watermark_validate(ocelot, extack);\n\tif (err) {\n\t\tocelot_wm_write(ocelot, wm_index, old_thr);\n\t\treturn err;\n\t}\n\n\tocelot_setup_sharing_watermarks(ocelot);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_sb_port_pool_set);\n\n \nint ocelot_sb_tc_pool_bind_get(struct ocelot *ocelot, int port,\n\t\t\t       unsigned int sb_index, u16 tc_index,\n\t\t\t       enum devlink_sb_pool_type pool_type,\n\t\t\t       u16 *p_pool_index, u32 *p_threshold)\n{\n\tint wm_index;\n\n\tswitch (sb_index) {\n\tcase OCELOT_SB_BUF:\n\t\tif (pool_type == DEVLINK_SB_POOL_TYPE_INGRESS)\n\t\t\twm_index = BUF_Q_RSRV_I(port, tc_index);\n\t\telse\n\t\t\twm_index = BUF_Q_RSRV_E(port, tc_index);\n\t\tbreak;\n\tcase OCELOT_SB_REF:\n\t\tif (pool_type == DEVLINK_SB_POOL_TYPE_INGRESS)\n\t\t\twm_index = REF_Q_RSRV_I(port, tc_index);\n\t\telse\n\t\t\twm_index = REF_Q_RSRV_E(port, tc_index);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\t*p_threshold = ocelot_wm_read(ocelot, wm_index);\n\t*p_threshold *= ocelot_sb_pool[sb_index].cell_size;\n\n\tif (pool_type == DEVLINK_SB_POOL_TYPE_INGRESS)\n\t\t*p_pool_index = 0;\n\telse\n\t\t*p_pool_index = 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_sb_tc_pool_bind_get);\n\n \nint ocelot_sb_tc_pool_bind_set(struct ocelot *ocelot, int port,\n\t\t\t       unsigned int sb_index, u16 tc_index,\n\t\t\t       enum devlink_sb_pool_type pool_type,\n\t\t\t       u16 pool_index, u32 threshold,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tint wm_index, err;\n\tu32 old_thr;\n\n\t \n\tif (pool_index == OCELOT_SB_POOL_ING &&\n\t    pool_type != DEVLINK_SB_POOL_TYPE_INGRESS)\n\t\treturn -EINVAL;\n\tif (pool_index == OCELOT_SB_POOL_EGR &&\n\t    pool_type != DEVLINK_SB_POOL_TYPE_EGRESS)\n\t\treturn -EINVAL;\n\n\tswitch (sb_index) {\n\tcase OCELOT_SB_BUF:\n\t\tif (pool_type == DEVLINK_SB_POOL_TYPE_INGRESS)\n\t\t\twm_index = BUF_Q_RSRV_I(port, tc_index);\n\t\telse\n\t\t\twm_index = BUF_Q_RSRV_E(port, tc_index);\n\t\tbreak;\n\tcase OCELOT_SB_REF:\n\t\tif (pool_type == DEVLINK_SB_POOL_TYPE_INGRESS)\n\t\t\twm_index = REF_Q_RSRV_I(port, tc_index);\n\t\telse\n\t\t\twm_index = REF_Q_RSRV_E(port, tc_index);\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid shared buffer\");\n\t\treturn -ENODEV;\n\t}\n\n\tthreshold /= ocelot_sb_pool[sb_index].cell_size;\n\n\told_thr = ocelot_wm_read(ocelot, wm_index);\n\tocelot_wm_write(ocelot, wm_index, threshold);\n\terr = ocelot_watermark_validate(ocelot, extack);\n\tif (err) {\n\t\tocelot_wm_write(ocelot, wm_index, old_thr);\n\t\treturn err;\n\t}\n\n\tocelot_setup_sharing_watermarks(ocelot);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_sb_tc_pool_bind_set);\n\n \nint ocelot_sb_occ_snapshot(struct ocelot *ocelot, unsigned int sb_index)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_sb_occ_snapshot);\n\n \nint ocelot_sb_occ_max_clear(struct ocelot *ocelot, unsigned int sb_index)\n{\n\tu32 inuse, maxuse;\n\tint port, prio;\n\n\tswitch (sb_index) {\n\tcase OCELOT_SB_BUF:\n\t\tfor (port = 0; port <= ocelot->num_phys_ports; port++) {\n\t\t\tfor (prio = 0; prio < OCELOT_NUM_TC; prio++) {\n\t\t\t\tocelot_wm_status(ocelot, BUF_Q_RSRV_I(port, prio),\n\t\t\t\t\t\t &inuse, &maxuse);\n\t\t\t\tocelot_wm_status(ocelot, BUF_Q_RSRV_E(port, prio),\n\t\t\t\t\t\t &inuse, &maxuse);\n\t\t\t}\n\t\t\tocelot_wm_status(ocelot, BUF_P_RSRV_I(port),\n\t\t\t\t\t &inuse, &maxuse);\n\t\t\tocelot_wm_status(ocelot, BUF_P_RSRV_E(port),\n\t\t\t\t\t &inuse, &maxuse);\n\t\t}\n\t\tbreak;\n\tcase OCELOT_SB_REF:\n\t\tfor (port = 0; port <= ocelot->num_phys_ports; port++) {\n\t\t\tfor (prio = 0; prio < OCELOT_NUM_TC; prio++) {\n\t\t\t\tocelot_wm_status(ocelot, REF_Q_RSRV_I(port, prio),\n\t\t\t\t\t\t &inuse, &maxuse);\n\t\t\t\tocelot_wm_status(ocelot, REF_Q_RSRV_E(port, prio),\n\t\t\t\t\t\t &inuse, &maxuse);\n\t\t\t}\n\t\t\tocelot_wm_status(ocelot, REF_P_RSRV_I(port),\n\t\t\t\t\t &inuse, &maxuse);\n\t\t\tocelot_wm_status(ocelot, REF_P_RSRV_E(port),\n\t\t\t\t\t &inuse, &maxuse);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_sb_occ_max_clear);\n\n \nint ocelot_sb_occ_port_pool_get(struct ocelot *ocelot, int port,\n\t\t\t\tunsigned int sb_index, u16 pool_index,\n\t\t\t\tu32 *p_cur, u32 *p_max)\n{\n\tint wm_index;\n\n\tswitch (sb_index) {\n\tcase OCELOT_SB_BUF:\n\t\tif (pool_index == OCELOT_SB_POOL_ING)\n\t\t\twm_index = BUF_P_RSRV_I(port);\n\t\telse\n\t\t\twm_index = BUF_P_RSRV_E(port);\n\t\tbreak;\n\tcase OCELOT_SB_REF:\n\t\tif (pool_index == OCELOT_SB_POOL_ING)\n\t\t\twm_index = REF_P_RSRV_I(port);\n\t\telse\n\t\t\twm_index = REF_P_RSRV_E(port);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tocelot_wm_status(ocelot, wm_index, p_cur, p_max);\n\t*p_cur *= ocelot_sb_pool[sb_index].cell_size;\n\t*p_max *= ocelot_sb_pool[sb_index].cell_size;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_sb_occ_port_pool_get);\n\n \nint ocelot_sb_occ_tc_port_bind_get(struct ocelot *ocelot, int port,\n\t\t\t\t   unsigned int sb_index, u16 tc_index,\n\t\t\t\t   enum devlink_sb_pool_type pool_type,\n\t\t\t\t   u32 *p_cur, u32 *p_max)\n{\n\tint wm_index;\n\n\tswitch (sb_index) {\n\tcase OCELOT_SB_BUF:\n\t\tif (pool_type == DEVLINK_SB_POOL_TYPE_INGRESS)\n\t\t\twm_index = BUF_Q_RSRV_I(port, tc_index);\n\t\telse\n\t\t\twm_index = BUF_Q_RSRV_E(port, tc_index);\n\t\tbreak;\n\tcase OCELOT_SB_REF:\n\t\tif (pool_type == DEVLINK_SB_POOL_TYPE_INGRESS)\n\t\t\twm_index = REF_Q_RSRV_I(port, tc_index);\n\t\telse\n\t\t\twm_index = REF_Q_RSRV_E(port, tc_index);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tocelot_wm_status(ocelot, wm_index, p_cur, p_max);\n\t*p_cur *= ocelot_sb_pool[sb_index].cell_size;\n\t*p_max *= ocelot_sb_pool[sb_index].cell_size;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_sb_occ_tc_port_bind_get);\n\nint ocelot_devlink_sb_register(struct ocelot *ocelot)\n{\n\tint err;\n\n\terr = devlink_sb_register(ocelot->devlink, OCELOT_SB_BUF,\n\t\t\t\t  ocelot->packet_buffer_size, 1, 1,\n\t\t\t\t  OCELOT_NUM_TC, OCELOT_NUM_TC);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_sb_register(ocelot->devlink, OCELOT_SB_REF,\n\t\t\t\t  ocelot->num_frame_refs, 1, 1,\n\t\t\t\t  OCELOT_NUM_TC, OCELOT_NUM_TC);\n\tif (err) {\n\t\tdevlink_sb_unregister(ocelot->devlink, OCELOT_SB_BUF);\n\t\treturn err;\n\t}\n\n\tocelot->pool_size[OCELOT_SB_BUF][OCELOT_SB_POOL_ING] = ocelot->packet_buffer_size;\n\tocelot->pool_size[OCELOT_SB_BUF][OCELOT_SB_POOL_EGR] = ocelot->packet_buffer_size;\n\tocelot->pool_size[OCELOT_SB_REF][OCELOT_SB_POOL_ING] = ocelot->num_frame_refs;\n\tocelot->pool_size[OCELOT_SB_REF][OCELOT_SB_POOL_EGR] = ocelot->num_frame_refs;\n\n\tocelot_watermark_init(ocelot);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ocelot_devlink_sb_register);\n\nvoid ocelot_devlink_sb_unregister(struct ocelot *ocelot)\n{\n\tdevlink_sb_unregister(ocelot->devlink, OCELOT_SB_BUF);\n\tdevlink_sb_unregister(ocelot->devlink, OCELOT_SB_REF);\n}\nEXPORT_SYMBOL(ocelot_devlink_sb_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}