{
  "module_name": "libcxgb_cm.c",
  "hash_id": "720cd6e969b1eccb31ab7346b4681cebc92cef5577e9504831d90b1c9f0cac1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/libcxgb/libcxgb_cm.c",
  "human_readable_source": " \n\n#include <linux/tcp.h>\n#include <linux/ipv6.h>\n#include <net/inet_ecn.h>\n#include <net/route.h>\n#include <net/ip6_route.h>\n\n#include \"libcxgb_cm.h\"\n\nvoid\ncxgb_get_4tuple(struct cpl_pass_accept_req *req, enum chip_type type,\n\t\tint *iptype, __u8 *local_ip, __u8 *peer_ip,\n\t\t__be16 *local_port, __be16 *peer_port)\n{\n\tint eth_len = (CHELSIO_CHIP_VERSION(type) <= CHELSIO_T5) ?\n\t\t      ETH_HDR_LEN_G(be32_to_cpu(req->hdr_len)) :\n\t\t      T6_ETH_HDR_LEN_G(be32_to_cpu(req->hdr_len));\n\tint ip_len = (CHELSIO_CHIP_VERSION(type) <= CHELSIO_T5) ?\n\t\t     IP_HDR_LEN_G(be32_to_cpu(req->hdr_len)) :\n\t\t     T6_IP_HDR_LEN_G(be32_to_cpu(req->hdr_len));\n\tstruct iphdr *ip = (struct iphdr *)((u8 *)(req + 1) + eth_len);\n\tstruct ipv6hdr *ip6 = (struct ipv6hdr *)((u8 *)(req + 1) + eth_len);\n\tstruct tcphdr *tcp = (struct tcphdr *)\n\t\t\t     ((u8 *)(req + 1) + eth_len + ip_len);\n\n\tif (ip->version == 4) {\n\t\tpr_debug(\"%s saddr 0x%x daddr 0x%x sport %u dport %u\\n\",\n\t\t\t __func__, ntohl(ip->saddr), ntohl(ip->daddr),\n\t\t\t ntohs(tcp->source), ntohs(tcp->dest));\n\t\t*iptype = 4;\n\t\tmemcpy(peer_ip, &ip->saddr, 4);\n\t\tmemcpy(local_ip, &ip->daddr, 4);\n\t} else {\n\t\tpr_debug(\"%s saddr %pI6 daddr %pI6 sport %u dport %u\\n\",\n\t\t\t __func__, ip6->saddr.s6_addr, ip6->daddr.s6_addr,\n\t\t\t ntohs(tcp->source), ntohs(tcp->dest));\n\t\t*iptype = 6;\n\t\tmemcpy(peer_ip, ip6->saddr.s6_addr, 16);\n\t\tmemcpy(local_ip, ip6->daddr.s6_addr, 16);\n\t}\n\t*peer_port = tcp->source;\n\t*local_port = tcp->dest;\n}\nEXPORT_SYMBOL(cxgb_get_4tuple);\n\nstatic bool\ncxgb_our_interface(struct cxgb4_lld_info *lldi,\n\t\t   struct net_device *(*get_real_dev)(struct net_device *),\n\t\t   struct net_device *egress_dev)\n{\n\tint i;\n\n\tegress_dev = get_real_dev(egress_dev);\n\tfor (i = 0; i < lldi->nports; i++)\n\t\tif (lldi->ports[i] == egress_dev)\n\t\t\treturn true;\n\treturn false;\n}\n\nstruct dst_entry *\ncxgb_find_route(struct cxgb4_lld_info *lldi,\n\t\tstruct net_device *(*get_real_dev)(struct net_device *),\n\t\t__be32 local_ip, __be32 peer_ip, __be16 local_port,\n\t\t__be16 peer_port, u8 tos)\n{\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\tstruct neighbour *n;\n\n\trt = ip_route_output_ports(&init_net, &fl4, NULL, peer_ip, local_ip,\n\t\t\t\t   peer_port, local_port, IPPROTO_TCP,\n\t\t\t\t   tos & ~INET_ECN_MASK, 0);\n\tif (IS_ERR(rt))\n\t\treturn NULL;\n\tn = dst_neigh_lookup(&rt->dst, &peer_ip);\n\tif (!n)\n\t\treturn NULL;\n\tif (!cxgb_our_interface(lldi, get_real_dev, n->dev) &&\n\t    !(n->dev->flags & IFF_LOOPBACK)) {\n\t\tneigh_release(n);\n\t\tdst_release(&rt->dst);\n\t\treturn NULL;\n\t}\n\tneigh_release(n);\n\treturn &rt->dst;\n}\nEXPORT_SYMBOL(cxgb_find_route);\n\nstruct dst_entry *\ncxgb_find_route6(struct cxgb4_lld_info *lldi,\n\t\t struct net_device *(*get_real_dev)(struct net_device *),\n\t\t __u8 *local_ip, __u8 *peer_ip, __be16 local_port,\n\t\t __be16 peer_port, u8 tos, __u32 sin6_scope_id)\n{\n\tstruct dst_entry *dst = NULL;\n\n\tif (IS_ENABLED(CONFIG_IPV6)) {\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tmemcpy(&fl6.daddr, peer_ip, 16);\n\t\tmemcpy(&fl6.saddr, local_ip, 16);\n\t\tif (ipv6_addr_type(&fl6.daddr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tfl6.flowi6_oif = sin6_scope_id;\n\t\tdst = ip6_route_output(&init_net, NULL, &fl6);\n\t\tif (dst->error ||\n\t\t    (!cxgb_our_interface(lldi, get_real_dev,\n\t\t\t\t\t ip6_dst_idev(dst)->dev) &&\n\t\t     !(ip6_dst_idev(dst)->dev->flags & IFF_LOOPBACK))) {\n\t\t\tdst_release(dst);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn dst;\n}\nEXPORT_SYMBOL(cxgb_find_route6);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}