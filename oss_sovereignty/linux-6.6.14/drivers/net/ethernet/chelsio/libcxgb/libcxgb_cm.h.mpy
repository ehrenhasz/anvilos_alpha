{
  "module_name": "libcxgb_cm.h",
  "hash_id": "143d763e9a5fc3a3d76fe9643e38a298d18d91b0bae25b747c8d4e68c967c7bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/libcxgb/libcxgb_cm.h",
  "human_readable_source": " \n\n#ifndef __LIBCXGB_CM_H__\n#define __LIBCXGB_CM_H__\n\n\n#include <net/tcp.h>\n\n#include <cxgb4.h>\n#include <t4_msg.h>\n#include <l2t.h>\n\nvoid\ncxgb_get_4tuple(struct cpl_pass_accept_req *, enum chip_type,\n\t\tint *, __u8 *, __u8 *, __be16 *, __be16 *);\nstruct dst_entry *\ncxgb_find_route(struct cxgb4_lld_info *,\n\t\tstruct net_device *(*)(struct net_device *),\n\t\t__be32, __be32, __be16,\t__be16, u8);\nstruct dst_entry *\ncxgb_find_route6(struct cxgb4_lld_info *,\n\t\t struct net_device *(*)(struct net_device *),\n\t\t __u8 *, __u8 *, __be16, __be16, u8, __u32);\n\n \nstatic inline bool cxgb_is_neg_adv(unsigned int status)\n{\n\treturn status == CPL_ERR_RTX_NEG_ADVICE ||\n\t       status == CPL_ERR_PERSIST_NEG_ADVICE ||\n\t       status == CPL_ERR_KEEPALV_NEG_ADVICE;\n}\n\nstatic inline void\ncxgb_best_mtu(const unsigned short *mtus, unsigned short mtu,\n\t      unsigned int *idx, int use_ts, int ipv6)\n{\n\tunsigned short hdr_size = (ipv6 ?\n\t\t\t\t   sizeof(struct ipv6hdr) :\n\t\t\t\t   sizeof(struct iphdr)) +\n\t\t\t\t  sizeof(struct tcphdr) +\n\t\t\t\t  (use_ts ?\n\t\t\t\t   round_up(TCPOLEN_TIMESTAMP, 4) : 0);\n\tunsigned short data_size = mtu - hdr_size;\n\n\tcxgb4_best_aligned_mtu(mtus, hdr_size, data_size, 8, idx);\n}\n\nstatic inline u32 cxgb_compute_wscale(u32 win)\n{\n\tu32 wscale = 0;\n\n\twhile (wscale < 14 && (65535 << wscale) < win)\n\t\twscale++;\n\treturn wscale;\n}\n\nstatic inline void\ncxgb_mk_tid_release(struct sk_buff *skb, u32 len, u32 tid, u16 chan)\n{\n\tstruct cpl_tid_release *req;\n\n\treq = __skb_put_zero(skb, len);\n\n\tINIT_TP_WR(req, tid);\n\tOPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_TID_RELEASE, tid));\n\tset_wr_txq(skb, CPL_PRIORITY_SETUP, chan);\n}\n\nstatic inline void\ncxgb_mk_close_con_req(struct sk_buff *skb, u32 len, u32 tid, u16 chan,\n\t\t      void *handle, arp_err_handler_t handler)\n{\n\tstruct cpl_close_con_req *req;\n\n\treq = __skb_put_zero(skb, len);\n\n\tINIT_TP_WR(req, tid);\n\tOPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_CLOSE_CON_REQ, tid));\n\tset_wr_txq(skb, CPL_PRIORITY_DATA, chan);\n\tt4_set_arp_err_handler(skb, handle, handler);\n}\n\nstatic inline void\ncxgb_mk_abort_req(struct sk_buff *skb, u32 len, u32 tid, u16 chan,\n\t\t  void *handle, arp_err_handler_t handler)\n{\n\tstruct cpl_abort_req *req;\n\n\treq = __skb_put_zero(skb, len);\n\n\tINIT_TP_WR(req, tid);\n\tOPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_ABORT_REQ, tid));\n\treq->cmd = CPL_ABORT_SEND_RST;\n\tset_wr_txq(skb, CPL_PRIORITY_DATA, chan);\n\tt4_set_arp_err_handler(skb, handle, handler);\n}\n\nstatic inline void\ncxgb_mk_abort_rpl(struct sk_buff *skb, u32 len, u32 tid, u16 chan)\n{\n\tstruct cpl_abort_rpl *rpl;\n\n\trpl = __skb_put_zero(skb, len);\n\n\tINIT_TP_WR(rpl, tid);\n\tOPCODE_TID(rpl) = cpu_to_be32(MK_OPCODE_TID(CPL_ABORT_RPL, tid));\n\trpl->cmd = CPL_ABORT_NO_RST;\n\tset_wr_txq(skb, CPL_PRIORITY_DATA, chan);\n}\n\nstatic inline void\ncxgb_mk_rx_data_ack(struct sk_buff *skb, u32 len, u32 tid, u16 chan,\n\t\t    u32 credit_dack)\n{\n\tstruct cpl_rx_data_ack *req;\n\n\treq = __skb_put_zero(skb, len);\n\n\tINIT_TP_WR(req, tid);\n\tOPCODE_TID(req) = cpu_to_be32(MK_OPCODE_TID(CPL_RX_DATA_ACK, tid));\n\treq->credit_dack = cpu_to_be32(credit_dack);\n\tset_wr_txq(skb, CPL_PRIORITY_ACK, chan);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}