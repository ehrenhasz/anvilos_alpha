{
  "module_name": "libcxgb_ppm.c",
  "hash_id": "f409fde85926d5876a36a3c948b70999bc5d8e710df21d962f80569b925bad22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/libcxgb/libcxgb_ppm.c",
  "human_readable_source": " \n\n#define DRV_NAME \"libcxgb\"\n#define pr_fmt(fmt) DRV_NAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/debugfs.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/skbuff.h>\n#include <linux/pci.h>\n#include <linux/scatterlist.h>\n\n#include \"libcxgb_ppm.h\"\n\n \n\n \nint cxgbi_ppm_find_page_index(struct cxgbi_ppm *ppm, unsigned long pgsz)\n{\n\tstruct cxgbi_tag_format *tformat = &ppm->tformat;\n\tint i;\n\n\tfor (i = 0; i < DDP_PGIDX_MAX; i++) {\n\t\tif (pgsz == 1UL << (DDP_PGSZ_BASE_SHIFT +\n\t\t\t\t\t tformat->pgsz_order[i])) {\n\t\t\tpr_debug(\"%s: %s ppm, pgsz %lu -> idx %d.\\n\",\n\t\t\t\t __func__, ppm->ndev->name, pgsz, i);\n\t\t\treturn i;\n\t\t}\n\t}\n\tpr_info(\"ippm: ddp page size %lu not supported.\\n\", pgsz);\n\treturn DDP_PGIDX_MAX;\n}\n\n \nstatic int ppm_find_unused_entries(unsigned long *bmap,\n\t\t\t\t   unsigned int max_ppods,\n\t\t\t\t   unsigned int start,\n\t\t\t\t   unsigned int nr,\n\t\t\t\t   unsigned int align_mask)\n{\n\tunsigned long i;\n\n\ti = bitmap_find_next_zero_area(bmap, max_ppods, start, nr, align_mask);\n\n\tif (unlikely(i >= max_ppods) && (start > nr))\n\t\ti = bitmap_find_next_zero_area(bmap, max_ppods, 0, start - 1,\n\t\t\t\t\t       align_mask);\n\tif (unlikely(i >= max_ppods))\n\t\treturn -ENOSPC;\n\n\tbitmap_set(bmap, i, nr);\n\treturn (int)i;\n}\n\nstatic void ppm_mark_entries(struct cxgbi_ppm *ppm, int i, int count,\n\t\t\t     unsigned long caller_data)\n{\n\tstruct cxgbi_ppod_data *pdata = ppm->ppod_data + i;\n\n\tpdata->caller_data = caller_data;\n\tpdata->npods = count;\n\n\tif (pdata->color == ((1 << PPOD_IDX_SHIFT) - 1))\n\t\tpdata->color = 0;\n\telse\n\t\tpdata->color++;\n}\n\nstatic int ppm_get_cpu_entries(struct cxgbi_ppm *ppm, unsigned int count,\n\t\t\t       unsigned long caller_data)\n{\n\tstruct cxgbi_ppm_pool *pool;\n\tunsigned int cpu;\n\tint i;\n\n\tif (!ppm->pool)\n\t\treturn -EINVAL;\n\n\tcpu = get_cpu();\n\tpool = per_cpu_ptr(ppm->pool, cpu);\n\tspin_lock_bh(&pool->lock);\n\tput_cpu();\n\n\ti = ppm_find_unused_entries(pool->bmap, ppm->pool_index_max,\n\t\t\t\t    pool->next, count, 0);\n\tif (i < 0) {\n\t\tpool->next = 0;\n\t\tspin_unlock_bh(&pool->lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tpool->next = i + count;\n\tif (pool->next >= ppm->pool_index_max)\n\t\tpool->next = 0;\n\n\tspin_unlock_bh(&pool->lock);\n\n\tpr_debug(\"%s: cpu %u, idx %d + %d (%d), next %u.\\n\",\n\t\t __func__, cpu, i, count, i + cpu * ppm->pool_index_max,\n\t\tpool->next);\n\n\ti += cpu * ppm->pool_index_max;\n\tppm_mark_entries(ppm, i, count, caller_data);\n\n\treturn i;\n}\n\nstatic int ppm_get_entries(struct cxgbi_ppm *ppm, unsigned int count,\n\t\t\t   unsigned long caller_data)\n{\n\tint i;\n\n\tspin_lock_bh(&ppm->map_lock);\n\ti = ppm_find_unused_entries(ppm->ppod_bmap, ppm->bmap_index_max,\n\t\t\t\t    ppm->next, count, 0);\n\tif (i < 0) {\n\t\tppm->next = 0;\n\t\tspin_unlock_bh(&ppm->map_lock);\n\t\tpr_debug(\"ippm: NO suitable entries %u available.\\n\",\n\t\t\t count);\n\t\treturn -ENOSPC;\n\t}\n\n\tppm->next = i + count;\n\tif (ppm->max_index_in_edram && (ppm->next >= ppm->max_index_in_edram))\n\t\tppm->next = 0;\n\telse if (ppm->next >= ppm->bmap_index_max)\n\t\tppm->next = 0;\n\n\tspin_unlock_bh(&ppm->map_lock);\n\n\tpr_debug(\"%s: idx %d + %d (%d), next %u, caller_data 0x%lx.\\n\",\n\t\t __func__, i, count, i + ppm->pool_rsvd, ppm->next,\n\t\t caller_data);\n\n\ti += ppm->pool_rsvd;\n\tppm_mark_entries(ppm, i, count, caller_data);\n\n\treturn i;\n}\n\nstatic void ppm_unmark_entries(struct cxgbi_ppm *ppm, int i, int count)\n{\n\tpr_debug(\"%s: idx %d + %d.\\n\", __func__, i, count);\n\n\tif (i < ppm->pool_rsvd) {\n\t\tunsigned int cpu;\n\t\tstruct cxgbi_ppm_pool *pool;\n\n\t\tcpu = i / ppm->pool_index_max;\n\t\ti %= ppm->pool_index_max;\n\n\t\tpool = per_cpu_ptr(ppm->pool, cpu);\n\t\tspin_lock_bh(&pool->lock);\n\t\tbitmap_clear(pool->bmap, i, count);\n\n\t\tif (i < pool->next)\n\t\t\tpool->next = i;\n\t\tspin_unlock_bh(&pool->lock);\n\n\t\tpr_debug(\"%s: cpu %u, idx %d, next %u.\\n\",\n\t\t\t __func__, cpu, i, pool->next);\n\t} else {\n\t\tspin_lock_bh(&ppm->map_lock);\n\n\t\ti -= ppm->pool_rsvd;\n\t\tbitmap_clear(ppm->ppod_bmap, i, count);\n\n\t\tif (i < ppm->next)\n\t\t\tppm->next = i;\n\t\tspin_unlock_bh(&ppm->map_lock);\n\n\t\tpr_debug(\"%s: idx %d, next %u.\\n\", __func__, i, ppm->next);\n\t}\n}\n\nvoid cxgbi_ppm_ppod_release(struct cxgbi_ppm *ppm, u32 idx)\n{\n\tstruct cxgbi_ppod_data *pdata;\n\n\tif (idx >= ppm->ppmax) {\n\t\tpr_warn(\"ippm: idx too big %u > %u.\\n\", idx, ppm->ppmax);\n\t\treturn;\n\t}\n\n\tpdata = ppm->ppod_data + idx;\n\tif (!pdata->npods) {\n\t\tpr_warn(\"ippm: idx %u, npods 0.\\n\", idx);\n\t\treturn;\n\t}\n\n\tpr_debug(\"release idx %u, npods %u.\\n\", idx, pdata->npods);\n\tppm_unmark_entries(ppm, idx, pdata->npods);\n}\nEXPORT_SYMBOL(cxgbi_ppm_ppod_release);\n\nint cxgbi_ppm_ppods_reserve(struct cxgbi_ppm *ppm, unsigned short nr_pages,\n\t\t\t    u32 per_tag_pg_idx, u32 *ppod_idx,\n\t\t\t    u32 *ddp_tag, unsigned long caller_data)\n{\n\tstruct cxgbi_ppod_data *pdata;\n\tunsigned int npods;\n\tint idx = -1;\n\tunsigned int hwidx;\n\tu32 tag;\n\n\tnpods = (nr_pages + PPOD_PAGES_MAX - 1) >> PPOD_PAGES_SHIFT;\n\tif (!npods) {\n\t\tpr_warn(\"%s: pages %u -> npods %u, full.\\n\",\n\t\t\t__func__, nr_pages, npods);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tidx = ppm_get_cpu_entries(ppm, npods, caller_data);\n\t \n\tif (idx < 0)\n\t\tidx = ppm_get_entries(ppm, npods, caller_data);\n\tif (idx < 0) {\n\t\tpr_debug(\"ippm: pages %u, nospc %u, nxt %u, 0x%lx.\\n\",\n\t\t\t nr_pages, npods, ppm->next, caller_data);\n\t\treturn idx;\n\t}\n\n\tpdata = ppm->ppod_data + idx;\n\thwidx = ppm->base_idx + idx;\n\n\ttag = cxgbi_ppm_make_ddp_tag(hwidx, pdata->color);\n\n\tif (per_tag_pg_idx)\n\t\ttag |= (per_tag_pg_idx << 30) & 0xC0000000;\n\n\t*ppod_idx = idx;\n\t*ddp_tag = tag;\n\n\tpr_debug(\"ippm: sg %u, tag 0x%x(%u,%u), data 0x%lx.\\n\",\n\t\t nr_pages, tag, idx, npods, caller_data);\n\n\treturn npods;\n}\nEXPORT_SYMBOL(cxgbi_ppm_ppods_reserve);\n\nvoid cxgbi_ppm_make_ppod_hdr(struct cxgbi_ppm *ppm, u32 tag,\n\t\t\t     unsigned int tid, unsigned int offset,\n\t\t\t     unsigned int length,\n\t\t\t     struct cxgbi_pagepod_hdr *hdr)\n{\n\t \n\ttag &= 0x3FFFFFFF;\n\n\thdr->vld_tid = htonl(PPOD_VALID_FLAG | PPOD_TID(tid));\n\n\thdr->rsvd = 0;\n\thdr->pgsz_tag_clr = htonl(tag & ppm->tformat.idx_clr_mask);\n\thdr->max_offset = htonl(length);\n\thdr->page_offset = htonl(offset);\n\n\tpr_debug(\"ippm: tag 0x%x, tid 0x%x, xfer %u, off %u.\\n\",\n\t\t tag, tid, length, offset);\n}\nEXPORT_SYMBOL(cxgbi_ppm_make_ppod_hdr);\n\nstatic void ppm_free(struct cxgbi_ppm *ppm)\n{\n\tvfree(ppm);\n}\n\nstatic void ppm_destroy(struct kref *kref)\n{\n\tstruct cxgbi_ppm *ppm = container_of(kref,\n\t\t\t\t\t     struct cxgbi_ppm,\n\t\t\t\t\t     refcnt);\n\tpr_info(\"ippm: kref 0, destroy %s ppm 0x%p.\\n\",\n\t\tppm->ndev->name, ppm);\n\n\t*ppm->ppm_pp = NULL;\n\n\tfree_percpu(ppm->pool);\n\tppm_free(ppm);\n}\n\nint cxgbi_ppm_release(struct cxgbi_ppm *ppm)\n{\n\tif (ppm) {\n\t\tint rv;\n\n\t\trv = kref_put(&ppm->refcnt, ppm_destroy);\n\t\treturn rv;\n\t}\n\treturn 1;\n}\nEXPORT_SYMBOL(cxgbi_ppm_release);\n\nstatic struct cxgbi_ppm_pool *ppm_alloc_cpu_pool(unsigned int *total,\n\t\t\t\t\t\t unsigned int *pcpu_ppmax)\n{\n\tstruct cxgbi_ppm_pool *pools;\n\tunsigned int ppmax = (*total) / num_possible_cpus();\n\tunsigned int max = (PCPU_MIN_UNIT_SIZE - sizeof(*pools)) << 3;\n\tunsigned int bmap;\n\tunsigned int alloc_sz;\n\tunsigned int count = 0;\n\tunsigned int cpu;\n\n\t \n\tif (ppmax > max)\n\t\tppmax = max;\n\n\t \n\tbmap = ppmax / BITS_PER_TYPE(unsigned long);\n\tif (!bmap)\n\t\treturn NULL;\n\n\tppmax = (bmap * sizeof(unsigned long)) << 3;\n\n\talloc_sz = sizeof(*pools) + sizeof(unsigned long) * bmap;\n\tpools = __alloc_percpu(alloc_sz, __alignof__(struct cxgbi_ppm_pool));\n\n\tif (!pools)\n\t\treturn NULL;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct cxgbi_ppm_pool *ppool = per_cpu_ptr(pools, cpu);\n\n\t\tmemset(ppool, 0, alloc_sz);\n\t\tspin_lock_init(&ppool->lock);\n\t\tcount += ppmax;\n\t}\n\n\t*total = count;\n\t*pcpu_ppmax = ppmax;\n\n\treturn pools;\n}\n\nint cxgbi_ppm_init(void **ppm_pp, struct net_device *ndev,\n\t\t   struct pci_dev *pdev, void *lldev,\n\t\t   struct cxgbi_tag_format *tformat, unsigned int iscsi_size,\n\t\t   unsigned int llimit, unsigned int start,\n\t\t   unsigned int reserve_factor, unsigned int iscsi_edram_start,\n\t\t   unsigned int iscsi_edram_size)\n{\n\tstruct cxgbi_ppm *ppm = (struct cxgbi_ppm *)(*ppm_pp);\n\tstruct cxgbi_ppm_pool *pool = NULL;\n\tunsigned int pool_index_max = 0;\n\tunsigned int ppmax_pool = 0;\n\tunsigned int ppod_bmap_size;\n\tunsigned int alloc_sz;\n\tunsigned int ppmax;\n\n\tif (!iscsi_edram_start)\n\t\tiscsi_edram_size = 0;\n\n\tif (iscsi_edram_size &&\n\t    ((iscsi_edram_start + iscsi_edram_size) != start)) {\n\t\tpr_err(\"iscsi ppod region not contiguous: EDRAM start 0x%x \"\n\t\t\t\"size 0x%x DDR start 0x%x\\n\",\n\t\t\tiscsi_edram_start, iscsi_edram_size, start);\n\t\treturn -EINVAL;\n\t}\n\n\tif (iscsi_edram_size) {\n\t\treserve_factor = 0;\n\t\tstart = iscsi_edram_start;\n\t}\n\n\tppmax = (iscsi_edram_size + iscsi_size) >> PPOD_SIZE_SHIFT;\n\n\tif (ppm) {\n\t\tpr_info(\"ippm: %s, ppm 0x%p,0x%p already initialized, %u/%u.\\n\",\n\t\t\tndev->name, ppm_pp, ppm, ppm->ppmax, ppmax);\n\t\tkref_get(&ppm->refcnt);\n\t\treturn 1;\n\t}\n\n\tif (reserve_factor) {\n\t\tppmax_pool = ppmax / reserve_factor;\n\t\tpool = ppm_alloc_cpu_pool(&ppmax_pool, &pool_index_max);\n\t\tif (!pool) {\n\t\t\tppmax_pool = 0;\n\t\t\treserve_factor = 0;\n\t\t}\n\n\t\tpr_debug(\"%s: ppmax %u, cpu total %u, per cpu %u.\\n\",\n\t\t\t ndev->name, ppmax, ppmax_pool, pool_index_max);\n\t}\n\n\tppod_bmap_size = BITS_TO_LONGS(ppmax - ppmax_pool);\n\talloc_sz = sizeof(struct cxgbi_ppm) +\n\t\t\tppmax * (sizeof(struct cxgbi_ppod_data)) +\n\t\t\tppod_bmap_size * sizeof(unsigned long);\n\n\tppm = vzalloc(alloc_sz);\n\tif (!ppm)\n\t\tgoto release_ppm_pool;\n\n\tppm->ppod_bmap = (unsigned long *)(&ppm->ppod_data[ppmax]);\n\n\tif ((ppod_bmap_size >> 3) > (ppmax - ppmax_pool)) {\n\t\tunsigned int start = ppmax - ppmax_pool;\n\t\tunsigned int end = ppod_bmap_size >> 3;\n\n\t\tbitmap_set(ppm->ppod_bmap, ppmax, end - start);\n\t\tpr_info(\"%s: %u - %u < %u * 8, mask extra bits %u, %u.\\n\",\n\t\t\t__func__, ppmax, ppmax_pool, ppod_bmap_size, start,\n\t\t\tend);\n\t}\n\tif (iscsi_edram_size) {\n\t\tunsigned int first_ddr_idx =\n\t\t\t\tiscsi_edram_size >> PPOD_SIZE_SHIFT;\n\n\t\tppm->max_index_in_edram = first_ddr_idx - 1;\n\t\tbitmap_set(ppm->ppod_bmap, first_ddr_idx, 1);\n\t\tpr_debug(\"reserved %u ppod in bitmap\\n\", first_ddr_idx);\n\t}\n\n\tspin_lock_init(&ppm->map_lock);\n\tkref_init(&ppm->refcnt);\n\n\tmemcpy(&ppm->tformat, tformat, sizeof(struct cxgbi_tag_format));\n\n\tppm->ppm_pp = ppm_pp;\n\tppm->ndev = ndev;\n\tppm->pdev = pdev;\n\tppm->lldev = lldev;\n\tppm->ppmax = ppmax;\n\tppm->next = 0;\n\tppm->llimit = llimit;\n\tppm->base_idx = start > llimit ?\n\t\t\t(start - llimit + 1) >> PPOD_SIZE_SHIFT : 0;\n\tppm->bmap_index_max = ppmax - ppmax_pool;\n\n\tppm->pool = pool;\n\tppm->pool_rsvd = ppmax_pool;\n\tppm->pool_index_max = pool_index_max;\n\n\t \n\tif (*ppm_pp) {\n\t\tppm_free(ppm);\n\t\tppm = (struct cxgbi_ppm *)(*ppm_pp);\n\n\t\tpr_info(\"ippm: %s, ppm 0x%p,0x%p already initialized, %u/%u.\\n\",\n\t\t\tndev->name, ppm_pp, *ppm_pp, ppm->ppmax, ppmax);\n\n\t\tkref_get(&ppm->refcnt);\n\t\treturn 1;\n\t}\n\t*ppm_pp = ppm;\n\n\tppm->tformat.pgsz_idx_dflt = cxgbi_ppm_find_page_index(ppm, PAGE_SIZE);\n\n\tpr_info(\"ippm %s: ppm 0x%p, 0x%p, base %u/%u, pg %lu,%u, rsvd %u,%u.\\n\",\n\t\tndev->name, ppm_pp, ppm, ppm->base_idx, ppm->ppmax, PAGE_SIZE,\n\t\tppm->tformat.pgsz_idx_dflt, ppm->pool_rsvd,\n\t\tppm->pool_index_max);\n\n\treturn 0;\n\nrelease_ppm_pool:\n\tfree_percpu(pool);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(cxgbi_ppm_init);\n\nunsigned int cxgbi_tagmask_set(unsigned int ppmax)\n{\n\tunsigned int bits = fls(ppmax);\n\n\tif (bits > PPOD_IDX_MAX_SIZE)\n\t\tbits = PPOD_IDX_MAX_SIZE;\n\n\tpr_info(\"ippm: ppmax %u/0x%x -> bits %u, tagmask 0x%x.\\n\",\n\t\tppmax, ppmax, bits, 1 << (bits + PPOD_IDX_SHIFT));\n\n\treturn 1 << (bits + PPOD_IDX_SHIFT);\n}\nEXPORT_SYMBOL(cxgbi_tagmask_set);\n\nMODULE_AUTHOR(\"Chelsio Communications\");\nMODULE_DESCRIPTION(\"Chelsio common library\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}