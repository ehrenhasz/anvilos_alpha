{
  "module_name": "cxgb4_tc_matchall.c",
  "hash_id": "022e1b4dc06b2baf724f78804485461ea26d3f4b37b458a202fd85f0c36e8422",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_matchall.c",
  "human_readable_source": "\n \n\n#include \"cxgb4.h\"\n#include \"cxgb4_tc_matchall.h\"\n#include \"sched.h\"\n#include \"cxgb4_uld.h\"\n#include \"cxgb4_filter.h\"\n#include \"cxgb4_tc_flower.h\"\n\nstatic int cxgb4_policer_validate(const struct flow_action *action,\n\t\t\t\t  const struct flow_action_entry *act,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tif (act->police.exceed.act_id != FLOW_ACTION_DROP) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when exceed action is not drop\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.notexceed.act_id != FLOW_ACTION_PIPE &&\n\t    act->police.notexceed.act_id != FLOW_ACTION_ACCEPT) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when conform action is not pipe or ok\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.notexceed.act_id == FLOW_ACTION_ACCEPT &&\n\t    !flow_action_is_last_entry(action, act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when conform action is ok, but action is not last\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.peakrate_bytes_ps ||\n\t    act->police.avrate || act->police.overhead) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when peakrate/avrate/overhead is configured\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.rate_pkt_ps) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"QoS offload not support packets per second\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxgb4_matchall_egress_validate(struct net_device *dev,\n\t\t\t\t\t  struct tc_cls_matchall_offload *cls)\n{\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct flow_action *actions = &cls->rule->action;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct flow_action_entry *entry;\n\tstruct ch_sched_queue qe;\n\tstruct sched_class *e;\n\tu64 max_link_rate;\n\tu32 i, speed;\n\tint ret;\n\n\tif (!flow_action_has_entries(actions)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Egress MATCHALL offload needs at least 1 policing action\");\n\t\treturn -EINVAL;\n\t} else if (!flow_offload_has_one_action(actions)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Egress MATCHALL offload only supports 1 policing action\");\n\t\treturn -EINVAL;\n\t} else if (pi->tc_block_shared) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Egress MATCHALL offload not supported with shared blocks\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = t4_get_link_params(pi, NULL, &speed, NULL);\n\tif (ret) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Failed to get max speed supported by the link\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmax_link_rate = (u64)speed * 1000 * 1000;\n\n\tflow_action_for_each(i, entry, actions) {\n\t\tswitch (entry->id) {\n\t\tcase FLOW_ACTION_POLICE:\n\t\t\tret = cxgb4_policer_validate(actions, entry, extack);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tif (entry->police.rate_bytes_ps * 8 > max_link_rate) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Specified policing max rate is larger than underlying link speed\");\n\t\t\t\treturn -ERANGE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Only policing action supported with Egress MATCHALL offload\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tfor (i = 0; i < pi->nqsets; i++) {\n\t\tmemset(&qe, 0, sizeof(qe));\n\t\tqe.queue = i;\n\n\t\te = cxgb4_sched_queue_lookup(dev, &qe);\n\t\tif (e && e->info.u.params.level != SCHED_CLASS_LEVEL_CH_RL) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Some queues are already bound to different class\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cxgb4_matchall_tc_bind_queues(struct net_device *dev, u32 tc)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct ch_sched_queue qe;\n\tint ret;\n\tu32 i;\n\n\tfor (i = 0; i < pi->nqsets; i++) {\n\t\tqe.queue = i;\n\t\tqe.class = tc;\n\t\tret = cxgb4_sched_class_bind(dev, &qe, SCHED_QUEUE);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\treturn 0;\n\nout_free:\n\twhile (i--) {\n\t\tqe.queue = i;\n\t\tqe.class = SCHED_CLS_NONE;\n\t\tcxgb4_sched_class_unbind(dev, &qe, SCHED_QUEUE);\n\t}\n\n\treturn ret;\n}\n\nstatic void cxgb4_matchall_tc_unbind_queues(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct ch_sched_queue qe;\n\tu32 i;\n\n\tfor (i = 0; i < pi->nqsets; i++) {\n\t\tqe.queue = i;\n\t\tqe.class = SCHED_CLS_NONE;\n\t\tcxgb4_sched_class_unbind(dev, &qe, SCHED_QUEUE);\n\t}\n}\n\nstatic int cxgb4_matchall_alloc_tc(struct net_device *dev,\n\t\t\t\t   struct tc_cls_matchall_offload *cls)\n{\n\tstruct ch_sched_params p = {\n\t\t.type = SCHED_CLASS_TYPE_PACKET,\n\t\t.u.params.level = SCHED_CLASS_LEVEL_CH_RL,\n\t\t.u.params.mode = SCHED_CLASS_MODE_CLASS,\n\t\t.u.params.rateunit = SCHED_CLASS_RATEUNIT_BITS,\n\t\t.u.params.ratemode = SCHED_CLASS_RATEMODE_ABS,\n\t\t.u.params.class = SCHED_CLS_NONE,\n\t\t.u.params.minrate = 0,\n\t\t.u.params.weight = 0,\n\t\t.u.params.pktsize = dev->mtu,\n\t};\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct cxgb4_tc_port_matchall *tc_port_matchall;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct flow_action_entry *entry;\n\tstruct sched_class *e;\n\tint ret;\n\tu32 i;\n\n\ttc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];\n\n\tflow_action_for_each(i, entry, &cls->rule->action)\n\t\tif (entry->id == FLOW_ACTION_POLICE)\n\t\t\tbreak;\n\n\tret = cxgb4_policer_validate(&cls->rule->action, entry, extack);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tp.u.params.maxrate = div_u64(entry->police.rate_bytes_ps * 8, 1000);\n\tp.u.params.channel = pi->tx_chan;\n\te = cxgb4_sched_class_alloc(dev, &p);\n\tif (!e) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"No free traffic class available for policing action\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = cxgb4_matchall_tc_bind_queues(dev, e->idx);\n\tif (ret) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Could not bind queues to traffic class\");\n\t\tgoto out_free;\n\t}\n\n\ttc_port_matchall->egress.hwtc = e->idx;\n\ttc_port_matchall->egress.cookie = cls->cookie;\n\ttc_port_matchall->egress.state = CXGB4_MATCHALL_STATE_ENABLED;\n\treturn 0;\n\nout_free:\n\tcxgb4_sched_class_free(dev, e->idx);\n\treturn ret;\n}\n\nstatic void cxgb4_matchall_free_tc(struct net_device *dev)\n{\n\tstruct cxgb4_tc_port_matchall *tc_port_matchall;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\n\ttc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];\n\tcxgb4_matchall_tc_unbind_queues(dev);\n\tcxgb4_sched_class_free(dev, tc_port_matchall->egress.hwtc);\n\n\ttc_port_matchall->egress.hwtc = SCHED_CLS_NONE;\n\ttc_port_matchall->egress.cookie = 0;\n\ttc_port_matchall->egress.state = CXGB4_MATCHALL_STATE_DISABLED;\n}\n\nstatic int cxgb4_matchall_mirror_alloc(struct net_device *dev,\n\t\t\t\t       struct tc_cls_matchall_offload *cls)\n{\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct cxgb4_tc_port_matchall *tc_port_matchall;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct flow_action_entry *act;\n\tint ret;\n\tu32 i;\n\n\ttc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];\n\tflow_action_for_each(i, act, &cls->rule->action) {\n\t\tif (act->id == FLOW_ACTION_MIRRED) {\n\t\t\tret = cxgb4_port_mirror_alloc(dev);\n\t\t\tif (ret) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Couldn't allocate mirror\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\ttc_port_matchall->ingress.viid_mirror = pi->viid_mirror;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void cxgb4_matchall_mirror_free(struct net_device *dev)\n{\n\tstruct cxgb4_tc_port_matchall *tc_port_matchall;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\n\ttc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];\n\tif (!tc_port_matchall->ingress.viid_mirror)\n\t\treturn;\n\n\tcxgb4_port_mirror_free(dev);\n\ttc_port_matchall->ingress.viid_mirror = 0;\n}\n\nstatic int cxgb4_matchall_del_filter(struct net_device *dev, u8 filter_type)\n{\n\tstruct cxgb4_tc_port_matchall *tc_port_matchall;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tint ret;\n\n\ttc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];\n\tret = cxgb4_del_filter(dev, tc_port_matchall->ingress.tid[filter_type],\n\t\t\t       &tc_port_matchall->ingress.fs[filter_type]);\n\tif (ret)\n\t\treturn ret;\n\n\ttc_port_matchall->ingress.tid[filter_type] = 0;\n\treturn 0;\n}\n\nstatic int cxgb4_matchall_add_filter(struct net_device *dev,\n\t\t\t\t     struct tc_cls_matchall_offload *cls,\n\t\t\t\t     u8 filter_type)\n{\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct cxgb4_tc_port_matchall *tc_port_matchall;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct ch_filter_specification *fs;\n\tint ret, fidx;\n\n\t \n\tfidx = cxgb4_get_free_ftid(dev, filter_type ? PF_INET6 : PF_INET,\n\t\t\t\t   false, cls->common.prio);\n\tif (fidx < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"No free LETCAM index available\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];\n\tfs = &tc_port_matchall->ingress.fs[filter_type];\n\tmemset(fs, 0, sizeof(*fs));\n\n\tif (fidx < adap->tids.nhpftids)\n\t\tfs->prio = 1;\n\tfs->tc_prio = cls->common.prio;\n\tfs->tc_cookie = cls->cookie;\n\tfs->type = filter_type;\n\tfs->hitcnts = 1;\n\n\tfs->val.pfvf_vld = 1;\n\tfs->val.pf = adap->pf;\n\tfs->val.vf = pi->vin;\n\n\tcxgb4_process_flow_actions(dev, &cls->rule->action, fs);\n\n\tret = cxgb4_set_filter(dev, fidx, fs);\n\tif (ret)\n\t\treturn ret;\n\n\ttc_port_matchall->ingress.tid[filter_type] = fidx;\n\treturn 0;\n}\n\nstatic int cxgb4_matchall_alloc_filter(struct net_device *dev,\n\t\t\t\t       struct tc_cls_matchall_offload *cls)\n{\n\tstruct cxgb4_tc_port_matchall *tc_port_matchall;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tint ret, i;\n\n\ttc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];\n\n\tret = cxgb4_matchall_mirror_alloc(dev, cls);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < CXGB4_FILTER_TYPE_MAX; i++) {\n\t\tret = cxgb4_matchall_add_filter(dev, cls, i);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\ttc_port_matchall->ingress.state = CXGB4_MATCHALL_STATE_ENABLED;\n\treturn 0;\n\nout_free:\n\twhile (i-- > 0)\n\t\tcxgb4_matchall_del_filter(dev, i);\n\n\tcxgb4_matchall_mirror_free(dev);\n\treturn ret;\n}\n\nstatic int cxgb4_matchall_free_filter(struct net_device *dev)\n{\n\tstruct cxgb4_tc_port_matchall *tc_port_matchall;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tint ret;\n\tu8 i;\n\n\ttc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];\n\n\tfor (i = 0; i < CXGB4_FILTER_TYPE_MAX; i++) {\n\t\tret = cxgb4_matchall_del_filter(dev, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcxgb4_matchall_mirror_free(dev);\n\n\ttc_port_matchall->ingress.packets = 0;\n\ttc_port_matchall->ingress.bytes = 0;\n\ttc_port_matchall->ingress.last_used = 0;\n\ttc_port_matchall->ingress.state = CXGB4_MATCHALL_STATE_DISABLED;\n\treturn 0;\n}\n\nint cxgb4_tc_matchall_replace(struct net_device *dev,\n\t\t\t      struct tc_cls_matchall_offload *cls_matchall,\n\t\t\t      bool ingress)\n{\n\tstruct netlink_ext_ack *extack = cls_matchall->common.extack;\n\tstruct cxgb4_tc_port_matchall *tc_port_matchall;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tint ret;\n\n\ttc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];\n\tif (ingress) {\n\t\tif (tc_port_matchall->ingress.state ==\n\t\t    CXGB4_MATCHALL_STATE_ENABLED) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Only 1 Ingress MATCHALL can be offloaded\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tret = cxgb4_validate_flow_actions(dev,\n\t\t\t\t\t\t  &cls_matchall->rule->action,\n\t\t\t\t\t\t  extack, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn cxgb4_matchall_alloc_filter(dev, cls_matchall);\n\t}\n\n\tif (tc_port_matchall->egress.state == CXGB4_MATCHALL_STATE_ENABLED) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Only 1 Egress MATCHALL can be offloaded\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = cxgb4_matchall_egress_validate(dev, cls_matchall);\n\tif (ret)\n\t\treturn ret;\n\n\treturn cxgb4_matchall_alloc_tc(dev, cls_matchall);\n}\n\nint cxgb4_tc_matchall_destroy(struct net_device *dev,\n\t\t\t      struct tc_cls_matchall_offload *cls_matchall,\n\t\t\t      bool ingress)\n{\n\tstruct cxgb4_tc_port_matchall *tc_port_matchall;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\n\ttc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];\n\tif (ingress) {\n\t\t \n\t\tif (cls_matchall->cookie !=\n\t\t    tc_port_matchall->ingress.fs[0].tc_cookie)\n\t\t\treturn -ENOENT;\n\n\t\treturn cxgb4_matchall_free_filter(dev);\n\t}\n\n\tif (cls_matchall->cookie != tc_port_matchall->egress.cookie)\n\t\treturn -ENOENT;\n\n\tcxgb4_matchall_free_tc(dev);\n\treturn 0;\n}\n\nint cxgb4_tc_matchall_stats(struct net_device *dev,\n\t\t\t    struct tc_cls_matchall_offload *cls_matchall)\n{\n\tu64 tmp_packets, tmp_bytes, packets = 0, bytes = 0;\n\tstruct cxgb4_tc_port_matchall *tc_port_matchall;\n\tstruct cxgb4_matchall_ingress_entry *ingress;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tint ret;\n\tu8 i;\n\n\ttc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];\n\tif (tc_port_matchall->ingress.state == CXGB4_MATCHALL_STATE_DISABLED)\n\t\treturn -ENOENT;\n\n\tingress = &tc_port_matchall->ingress;\n\tfor (i = 0; i < CXGB4_FILTER_TYPE_MAX; i++) {\n\t\tret = cxgb4_get_filter_counters(dev, ingress->tid[i],\n\t\t\t\t\t\t&tmp_packets, &tmp_bytes,\n\t\t\t\t\t\tingress->fs[i].hash);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpackets += tmp_packets;\n\t\tbytes += tmp_bytes;\n\t}\n\n\tif (tc_port_matchall->ingress.packets != packets) {\n\t\tflow_stats_update(&cls_matchall->stats,\n\t\t\t\t  bytes - tc_port_matchall->ingress.bytes,\n\t\t\t\t  packets - tc_port_matchall->ingress.packets,\n\t\t\t\t  0, tc_port_matchall->ingress.last_used,\n\t\t\t\t  FLOW_ACTION_HW_STATS_IMMEDIATE);\n\n\t\ttc_port_matchall->ingress.packets = packets;\n\t\ttc_port_matchall->ingress.bytes = bytes;\n\t\ttc_port_matchall->ingress.last_used = jiffies;\n\t}\n\n\treturn 0;\n}\n\nstatic void cxgb4_matchall_disable_offload(struct net_device *dev)\n{\n\tstruct cxgb4_tc_port_matchall *tc_port_matchall;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\n\ttc_port_matchall = &adap->tc_matchall->port_matchall[pi->port_id];\n\tif (tc_port_matchall->egress.state == CXGB4_MATCHALL_STATE_ENABLED)\n\t\tcxgb4_matchall_free_tc(dev);\n\n\tif (tc_port_matchall->ingress.state == CXGB4_MATCHALL_STATE_ENABLED)\n\t\tcxgb4_matchall_free_filter(dev);\n}\n\nint cxgb4_init_tc_matchall(struct adapter *adap)\n{\n\tstruct cxgb4_tc_port_matchall *tc_port_matchall;\n\tstruct cxgb4_tc_matchall *tc_matchall;\n\tint ret;\n\n\ttc_matchall = kzalloc(sizeof(*tc_matchall), GFP_KERNEL);\n\tif (!tc_matchall)\n\t\treturn -ENOMEM;\n\n\ttc_port_matchall = kcalloc(adap->params.nports,\n\t\t\t\t   sizeof(*tc_port_matchall),\n\t\t\t\t   GFP_KERNEL);\n\tif (!tc_port_matchall) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_matchall;\n\t}\n\n\ttc_matchall->port_matchall = tc_port_matchall;\n\tadap->tc_matchall = tc_matchall;\n\treturn 0;\n\nout_free_matchall:\n\tkfree(tc_matchall);\n\treturn ret;\n}\n\nvoid cxgb4_cleanup_tc_matchall(struct adapter *adap)\n{\n\tu8 i;\n\n\tif (adap->tc_matchall) {\n\t\tif (adap->tc_matchall->port_matchall) {\n\t\t\tfor (i = 0; i < adap->params.nports; i++) {\n\t\t\t\tstruct net_device *dev = adap->port[i];\n\n\t\t\t\tif (dev)\n\t\t\t\t\tcxgb4_matchall_disable_offload(dev);\n\t\t\t}\n\t\t\tkfree(adap->tc_matchall->port_matchall);\n\t\t}\n\t\tkfree(adap->tc_matchall);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}