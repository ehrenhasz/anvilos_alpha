{
  "module_name": "cxgb4_ptp.c",
  "hash_id": "debf74e1fe6846fecf35ddbb02f4d5c723a3775b39241fd55dcf9a4ca6c71644",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/cxgb4_ptp.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/net_tstamp.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/pps_kernel.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/ptp_classify.h>\n#include <linux/udp.h>\n\n#include \"cxgb4.h\"\n#include \"t4_hw.h\"\n#include \"t4_regs.h\"\n#include \"t4_msg.h\"\n#include \"t4fw_api.h\"\n#include \"cxgb4_ptp.h\"\n\n \nbool cxgb4_ptp_is_ptp_tx(struct sk_buff *skb)\n{\n\tstruct udphdr *uh;\n\n\tuh = udp_hdr(skb);\n\treturn skb->len >= PTP_MIN_LENGTH &&\n\t\tskb->len <= PTP_IN_TRANSMIT_PACKET_MAXNUM &&\n\t\tlikely(skb->protocol == htons(ETH_P_IP)) &&\n\t\tip_hdr(skb)->protocol == IPPROTO_UDP &&\n\t\tuh->dest == htons(PTP_EVENT_PORT);\n}\n\nbool is_ptp_enabled(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct port_info *pi;\n\n\tpi = netdev_priv(dev);\n\treturn (pi->ptp_enable && cxgb4_xmit_with_hwtstamp(skb) &&\n\t\tcxgb4_ptp_is_ptp_tx(skb));\n}\n\n \nbool cxgb4_ptp_is_ptp_rx(struct sk_buff *skb)\n{\n\tstruct udphdr *uh = (struct udphdr *)(skb->data + ETH_HLEN +\n\t\t\t\t\t      IPV4_HLEN(skb->data));\n\n\treturn  uh->dest == htons(PTP_EVENT_PORT) &&\n\t\tuh->source == htons(PTP_EVENT_PORT);\n}\n\n \nvoid cxgb4_ptp_read_hwstamp(struct adapter *adapter, struct port_info *pi)\n{\n\tstruct skb_shared_hwtstamps *skb_ts = NULL;\n\tu64 tx_ts;\n\n\tskb_ts = skb_hwtstamps(adapter->ptp_tx_skb);\n\n\ttx_ts = t4_read_reg(adapter,\n\t\t\t    T5_PORT_REG(pi->port_id, MAC_PORT_TX_TS_VAL_LO));\n\n\ttx_ts |= (u64)t4_read_reg(adapter,\n\t\t\t\t  T5_PORT_REG(pi->port_id,\n\t\t\t\t\t      MAC_PORT_TX_TS_VAL_HI)) << 32;\n\tskb_ts->hwtstamp = ns_to_ktime(tx_ts);\n\tskb_tstamp_tx(adapter->ptp_tx_skb, skb_ts);\n\tdev_kfree_skb_any(adapter->ptp_tx_skb);\n\tspin_lock(&adapter->ptp_lock);\n\tadapter->ptp_tx_skb = NULL;\n\tspin_unlock(&adapter->ptp_lock);\n}\n\n \nint cxgb4_ptprx_timestamping(struct port_info *pi, u8 port, u16 mode)\n{\n\tstruct adapter *adapter = pi->adapter;\n\tstruct fw_ptp_cmd c;\n\tint err;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t     FW_PTP_CMD_PORTID_V(port));\n\tc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\n\tc.u.init.sc = FW_PTP_SC_RXTIME_STAMP;\n\tc.u.init.mode = cpu_to_be16(mode);\n\n\terr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\n\tif (err < 0)\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"PTP: %s error %d\\n\", __func__, -err);\n\treturn err;\n}\n\nint cxgb4_ptp_txtype(struct adapter *adapter, u8 port)\n{\n\tstruct fw_ptp_cmd c;\n\tint err;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t     FW_PTP_CMD_PORTID_V(port));\n\tc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\n\tc.u.init.sc = FW_PTP_SC_TX_TYPE;\n\tc.u.init.mode = cpu_to_be16(PTP_TS_NONE);\n\n\terr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\n\tif (err < 0)\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"PTP: %s error %d\\n\", __func__, -err);\n\n\treturn err;\n}\n\nint cxgb4_ptp_redirect_rx_packet(struct adapter *adapter, struct port_info *pi)\n{\n\tstruct sge *s = &adapter->sge;\n\tstruct sge_eth_rxq *receive_q =  &s->ethrxq[pi->first_qset];\n\tstruct fw_ptp_cmd c;\n\tint err;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t     FW_PTP_CMD_PORTID_V(pi->port_id));\n\n\tc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\n\tc.u.init.sc = FW_PTP_SC_RDRX_TYPE;\n\tc.u.init.txchan = pi->tx_chan;\n\tc.u.init.absid = cpu_to_be16(receive_q->rspq.abs_id);\n\n\terr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\n\tif (err < 0)\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"PTP: %s error %d\\n\", __func__, -err);\n\treturn err;\n}\n\n \nstatic int cxgb4_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct adapter *adapter = (struct adapter *)container_of(ptp,\n\t\t\t\t   struct adapter, ptp_clock_info);\n\ts32 ppb = scaled_ppm_to_ppb(scaled_ppm);\n\tstruct fw_ptp_cmd c;\n\tint err;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t     FW_PTP_CMD_PORTID_V(0));\n\tc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\n\tc.u.ts.sc = FW_PTP_SC_ADJ_FREQ;\n\tc.u.ts.sign = (ppb < 0) ? 1 : 0;\n\tif (ppb < 0)\n\t\tppb = -ppb;\n\tc.u.ts.ppb = cpu_to_be32(ppb);\n\n\terr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\n\tif (err < 0)\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"PTP: %s error %d\\n\", __func__, -err);\n\n\treturn err;\n}\n\n \nstatic int  cxgb4_ptp_fineadjtime(struct adapter *adapter, s64 delta)\n{\n\tstruct fw_ptp_cmd c;\n\tint err;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\n\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t     FW_CMD_WRITE_F |\n\t\t\t     FW_PTP_CMD_PORTID_V(0));\n\tc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\n\tc.u.ts.sc = FW_PTP_SC_ADJ_FTIME;\n\tc.u.ts.sign = (delta < 0) ? 1 : 0;\n\tif (delta < 0)\n\t\tdelta = -delta;\n\tc.u.ts.tm = cpu_to_be64(delta);\n\n\terr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\n\tif (err < 0)\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"PTP: %s error %d\\n\", __func__, -err);\n\treturn err;\n}\n\n \nstatic int cxgb4_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct adapter *adapter =\n\t\t(struct adapter *)container_of(ptp, struct adapter,\n\t\t\t\t\t       ptp_clock_info);\n\tstruct fw_ptp_cmd c;\n\ts64 sign = 1;\n\tint err;\n\n\tif (delta < 0)\n\t\tsign = -1;\n\n\tif (delta * sign > PTP_CLOCK_MAX_ADJTIME) {\n\t\tmemset(&c, 0, sizeof(c));\n\t\tc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\n\t\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t\t     FW_PTP_CMD_PORTID_V(0));\n\t\tc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\n\t\tc.u.ts.sc = FW_PTP_SC_ADJ_TIME;\n\t\tc.u.ts.sign = (delta < 0) ? 1 : 0;\n\t\tif (delta < 0)\n\t\t\tdelta = -delta;\n\t\tc.u.ts.tm = cpu_to_be64(delta);\n\n\t\terr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\n\t\tif (err < 0)\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"PTP: %s error %d\\n\", __func__, -err);\n\t} else {\n\t\terr = cxgb4_ptp_fineadjtime(adapter, delta);\n\t}\n\n\treturn err;\n}\n\n \nstatic int cxgb4_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tstruct adapter *adapter = container_of(ptp, struct adapter,\n\t\t\t\t\t       ptp_clock_info);\n\tu64 ns;\n\n\tns = t4_read_reg(adapter, T5_PORT_REG(0, MAC_PORT_PTP_SUM_LO_A));\n\tns |= (u64)t4_read_reg(adapter,\n\t\t\t       T5_PORT_REG(0, MAC_PORT_PTP_SUM_HI_A)) << 32;\n\n\t \n\t*ts = ns_to_timespec64(ns);\n\treturn 0;\n}\n\n \nstatic int cxgb4_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t     const struct timespec64 *ts)\n{\n\tstruct adapter *adapter = (struct adapter *)container_of(ptp,\n\t\t\t\t   struct adapter, ptp_clock_info);\n\tstruct fw_ptp_cmd c;\n\tu64 ns;\n\tint err;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t     FW_PTP_CMD_PORTID_V(0));\n\tc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\n\tc.u.ts.sc = FW_PTP_SC_SET_TIME;\n\n\tns = timespec64_to_ns(ts);\n\tc.u.ts.tm = cpu_to_be64(ns);\n\n\terr =  t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\n\tif (err < 0)\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"PTP: %s error %d\\n\", __func__, -err);\n\n\treturn err;\n}\n\nstatic void cxgb4_init_ptp_timer(struct adapter *adapter)\n{\n\tstruct fw_ptp_cmd c;\n\tint err;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PTP_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t     FW_PTP_CMD_PORTID_V(0));\n\tc.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(sizeof(c) / 16));\n\tc.u.scmd.sc = FW_PTP_SC_INIT_TIMER;\n\n\terr = t4_wr_mbox(adapter, adapter->mbox, &c, sizeof(c), NULL);\n\tif (err < 0)\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"PTP: %s error %d\\n\", __func__, -err);\n}\n\n \nstatic int cxgb4_ptp_enable(struct ptp_clock_info __always_unused *ptp,\n\t\t\t    struct ptp_clock_request __always_unused *request,\n\t\t\t    int __always_unused on)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic const struct ptp_clock_info cxgb4_ptp_clock_info = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"cxgb4_clock\",\n\t.max_adj        = MAX_PTP_FREQ_ADJ,\n\t.n_alarm        = 0,\n\t.n_ext_ts       = 0,\n\t.n_per_out      = 0,\n\t.pps            = 0,\n\t.adjfine        = cxgb4_ptp_adjfine,\n\t.adjtime        = cxgb4_ptp_adjtime,\n\t.gettime64      = cxgb4_ptp_gettime,\n\t.settime64      = cxgb4_ptp_settime,\n\t.enable         = cxgb4_ptp_enable,\n};\n\n \nvoid cxgb4_ptp_init(struct adapter *adapter)\n{\n\tstruct timespec64 now;\n\t  \n\tif (!IS_ERR_OR_NULL(adapter->ptp_clock))\n\t\treturn;\n\n\tadapter->ptp_tx_skb = NULL;\n\tadapter->ptp_clock_info = cxgb4_ptp_clock_info;\n\tspin_lock_init(&adapter->ptp_lock);\n\n\tadapter->ptp_clock = ptp_clock_register(&adapter->ptp_clock_info,\n\t\t\t\t\t\t&adapter->pdev->dev);\n\tif (IS_ERR_OR_NULL(adapter->ptp_clock)) {\n\t\tadapter->ptp_clock = NULL;\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"PTP %s Clock registration has failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\tnow = ktime_to_timespec64(ktime_get_real());\n\tcxgb4_init_ptp_timer(adapter);\n\tif (cxgb4_ptp_settime(&adapter->ptp_clock_info, &now) < 0) {\n\t\tptp_clock_unregister(adapter->ptp_clock);\n\t\tadapter->ptp_clock = NULL;\n\t}\n}\n\n \nvoid cxgb4_ptp_stop(struct adapter *adapter)\n{\n\tif (adapter->ptp_tx_skb) {\n\t\tdev_kfree_skb_any(adapter->ptp_tx_skb);\n\t\tadapter->ptp_tx_skb = NULL;\n\t}\n\n\tif (adapter->ptp_clock) {\n\t\tptp_clock_unregister(adapter->ptp_clock);\n\t\tadapter->ptp_clock = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}