{
  "module_name": "cxgb4_main.c",
  "hash_id": "e2e28081fd69206dd4881a53ac40e54230e9449cc68ae4eaf5c68ded568669d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitmap.h>\n#include <linux/crc32.h>\n#include <linux/ctype.h>\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/etherdevice.h>\n#include <linux/firmware.h>\n#include <linux/if.h>\n#include <linux/if_vlan.h>\n#include <linux/init.h>\n#include <linux/log2.h>\n#include <linux/mdio.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/rtnetlink.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/sockios.h>\n#include <linux/vmalloc.h>\n#include <linux/workqueue.h>\n#include <net/neighbour.h>\n#include <net/netevent.h>\n#include <net/addrconf.h>\n#include <net/bonding.h>\n#include <linux/uaccess.h>\n#include <linux/crash_dump.h>\n#include <net/udp_tunnel.h>\n#include <net/xfrm.h>\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n#include <net/tls.h>\n#endif\n\n#include \"cxgb4.h\"\n#include \"cxgb4_filter.h\"\n#include \"t4_regs.h\"\n#include \"t4_values.h\"\n#include \"t4_msg.h\"\n#include \"t4fw_api.h\"\n#include \"t4fw_version.h\"\n#include \"cxgb4_dcb.h\"\n#include \"srq.h\"\n#include \"cxgb4_debugfs.h\"\n#include \"clip_tbl.h\"\n#include \"l2t.h\"\n#include \"smt.h\"\n#include \"sched.h\"\n#include \"cxgb4_tc_u32.h\"\n#include \"cxgb4_tc_flower.h\"\n#include \"cxgb4_tc_mqprio.h\"\n#include \"cxgb4_tc_matchall.h\"\n#include \"cxgb4_ptp.h\"\n#include \"cxgb4_cudbg.h\"\n\nchar cxgb4_driver_name[] = KBUILD_MODNAME;\n\n#define DRV_DESC \"Chelsio T4/T5/T6 Network Driver\"\n\n#define DFLT_MSG_ENABLE (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK | \\\n\t\t\t NETIF_MSG_TIMER | NETIF_MSG_IFDOWN | NETIF_MSG_IFUP |\\\n\t\t\t NETIF_MSG_RX_ERR | NETIF_MSG_TX_ERR)\n\n \n#define CH_PCI_DEVICE_ID_TABLE_DEFINE_BEGIN \\\n\tstatic const struct pci_device_id cxgb4_pci_tbl[] = {\n#define CXGB4_UNIFIED_PF 0x4\n\n#define CH_PCI_DEVICE_ID_FUNCTION CXGB4_UNIFIED_PF\n\n \n#define CH_PCI_DEVICE_ID_FUNCTION2 0x0\n\n#define CH_PCI_ID_TABLE_ENTRY(devid) \\\n\t\t{PCI_VDEVICE(CHELSIO, (devid)), CXGB4_UNIFIED_PF}\n\n#define CH_PCI_DEVICE_ID_TABLE_DEFINE_END \\\n\t\t{ 0, } \\\n\t}\n\n#include \"t4_pci_id_tbl.h\"\n\n#define FW4_FNAME \"cxgb4/t4fw.bin\"\n#define FW5_FNAME \"cxgb4/t5fw.bin\"\n#define FW6_FNAME \"cxgb4/t6fw.bin\"\n#define FW4_CFNAME \"cxgb4/t4-config.txt\"\n#define FW5_CFNAME \"cxgb4/t5-config.txt\"\n#define FW6_CFNAME \"cxgb4/t6-config.txt\"\n#define PHY_AQ1202_FIRMWARE \"cxgb4/aq1202_fw.cld\"\n#define PHY_BCM84834_FIRMWARE \"cxgb4/bcm8483.bin\"\n#define PHY_AQ1202_DEVICEID 0x4409\n#define PHY_BCM84834_DEVICEID 0x4486\n\nMODULE_DESCRIPTION(DRV_DESC);\nMODULE_AUTHOR(\"Chelsio Communications\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DEVICE_TABLE(pci, cxgb4_pci_tbl);\nMODULE_FIRMWARE(FW4_FNAME);\nMODULE_FIRMWARE(FW5_FNAME);\nMODULE_FIRMWARE(FW6_FNAME);\n\n \nstatic int msi = 2;\n\nmodule_param(msi, int, 0644);\nMODULE_PARM_DESC(msi, \"whether to use INTx (0), MSI (1) or MSI-X (2)\");\n\n \nstatic int rx_dma_offset = 2;\n\n \nstatic int select_queue;\nmodule_param(select_queue, int, 0644);\nMODULE_PARM_DESC(select_queue,\n\t\t \"Select between kernel provided method of selecting or driver method of selecting TX queue. Default is kernel method.\");\n\nstatic struct dentry *cxgb4_debugfs_root;\n\nLIST_HEAD(adapter_list);\nDEFINE_MUTEX(uld_mutex);\nLIST_HEAD(uld_list);\n\nstatic int cfg_queues(struct adapter *adap);\n\nstatic void link_report(struct net_device *dev)\n{\n\tif (!netif_carrier_ok(dev))\n\t\tnetdev_info(dev, \"link down\\n\");\n\telse {\n\t\tstatic const char *fc[] = { \"no\", \"Rx\", \"Tx\", \"Tx/Rx\" };\n\n\t\tconst char *s;\n\t\tconst struct port_info *p = netdev_priv(dev);\n\n\t\tswitch (p->link_cfg.speed) {\n\t\tcase 100:\n\t\t\ts = \"100Mbps\";\n\t\t\tbreak;\n\t\tcase 1000:\n\t\t\ts = \"1Gbps\";\n\t\t\tbreak;\n\t\tcase 10000:\n\t\t\ts = \"10Gbps\";\n\t\t\tbreak;\n\t\tcase 25000:\n\t\t\ts = \"25Gbps\";\n\t\t\tbreak;\n\t\tcase 40000:\n\t\t\ts = \"40Gbps\";\n\t\t\tbreak;\n\t\tcase 50000:\n\t\t\ts = \"50Gbps\";\n\t\t\tbreak;\n\t\tcase 100000:\n\t\t\ts = \"100Gbps\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"%s: unsupported speed: %d\\n\",\n\t\t\t\tdev->name, p->link_cfg.speed);\n\t\t\treturn;\n\t\t}\n\n\t\tnetdev_info(dev, \"link up, %s, full-duplex, %s PAUSE\\n\", s,\n\t\t\t    fc[p->link_cfg.fc]);\n\t}\n}\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n \nstatic void dcb_tx_queue_prio_enable(struct net_device *dev, int enable)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tstruct sge_eth_txq *txq = &adap->sge.ethtxq[pi->first_qset];\n\tint i;\n\n\t \n\tfor (i = 0; i < pi->nqsets; i++, txq++) {\n\t\tu32 name, value;\n\t\tint err;\n\n\t\tname = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DMAQ) |\n\t\t\tFW_PARAMS_PARAM_X_V(\n\t\t\t\tFW_PARAMS_PARAM_DMAQ_EQ_DCBPRIO_ETH) |\n\t\t\tFW_PARAMS_PARAM_YZ_V(txq->q.cntxt_id));\n\t\tvalue = enable ? i : 0xffffffff;\n\n\t\t \n\t\terr = t4_set_params_timeout(adap, adap->mbox, adap->pf, 0, 1,\n\t\t\t\t\t    &name, &value,\n\t\t\t\t\t    -FW_CMD_MAX_TIMEOUT);\n\n\t\tif (err)\n\t\t\tdev_err(adap->pdev_dev,\n\t\t\t\t\"Can't %s DCB Priority on port %d, TX Queue %d: err=%d\\n\",\n\t\t\t\tenable ? \"set\" : \"unset\", pi->port_id, i, -err);\n\t\telse\n\t\t\ttxq->dcb_prio = enable ? value : 0;\n\t}\n}\n\nint cxgb4_dcb_enabled(const struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\n\tif (!pi->dcb.enabled)\n\t\treturn 0;\n\n\treturn ((pi->dcb.state == CXGB4_DCB_STATE_FW_ALLSYNCED) ||\n\t\t(pi->dcb.state == CXGB4_DCB_STATE_HOST));\n}\n#endif  \n\nvoid t4_os_link_changed(struct adapter *adapter, int port_id, int link_stat)\n{\n\tstruct net_device *dev = adapter->port[port_id];\n\n\t \n\tif (netif_running(dev) && link_stat != netif_carrier_ok(dev)) {\n\t\tif (link_stat)\n\t\t\tnetif_carrier_on(dev);\n\t\telse {\n#ifdef CONFIG_CHELSIO_T4_DCB\n\t\t\tif (cxgb4_dcb_enabled(dev)) {\n\t\t\t\tcxgb4_dcb_reset(dev);\n\t\t\t\tdcb_tx_queue_prio_enable(dev, false);\n\t\t\t}\n#endif  \n\t\t\tnetif_carrier_off(dev);\n\t\t}\n\n\t\tlink_report(dev);\n\t}\n}\n\nvoid t4_os_portmod_changed(struct adapter *adap, int port_id)\n{\n\tstatic const char *mod_str[] = {\n\t\tNULL, \"LR\", \"SR\", \"ER\", \"passive DA\", \"active DA\", \"LRM\"\n\t};\n\n\tstruct net_device *dev = adap->port[port_id];\n\tstruct port_info *pi = netdev_priv(dev);\n\n\tif (pi->mod_type == FW_PORT_MOD_TYPE_NONE)\n\t\tnetdev_info(dev, \"port module unplugged\\n\");\n\telse if (pi->mod_type < ARRAY_SIZE(mod_str))\n\t\tnetdev_info(dev, \"%s module inserted\\n\", mod_str[pi->mod_type]);\n\telse if (pi->mod_type == FW_PORT_MOD_TYPE_NOTSUPPORTED)\n\t\tnetdev_info(dev, \"%s: unsupported port module inserted\\n\",\n\t\t\t    dev->name);\n\telse if (pi->mod_type == FW_PORT_MOD_TYPE_UNKNOWN)\n\t\tnetdev_info(dev, \"%s: unknown port module inserted\\n\",\n\t\t\t    dev->name);\n\telse if (pi->mod_type == FW_PORT_MOD_TYPE_ERROR)\n\t\tnetdev_info(dev, \"%s: transceiver module error\\n\", dev->name);\n\telse\n\t\tnetdev_info(dev, \"%s: unknown module type %d inserted\\n\",\n\t\t\t    dev->name, pi->mod_type);\n\n\t \n\tpi->link_cfg.redo_l1cfg = netif_running(dev);\n}\n\nint dbfifo_int_thresh = 10;  \nmodule_param(dbfifo_int_thresh, int, 0644);\nMODULE_PARM_DESC(dbfifo_int_thresh, \"doorbell fifo interrupt threshold\");\n\n \nstatic int dbfifo_drain_delay = 1000;\nmodule_param(dbfifo_drain_delay, int, 0644);\nMODULE_PARM_DESC(dbfifo_drain_delay,\n\t\t \"usecs to sleep while draining the dbfifo\");\n\nstatic inline int cxgb4_set_addr_hash(struct port_info *pi)\n{\n\tstruct adapter *adap = pi->adapter;\n\tu64 vec = 0;\n\tbool ucast = false;\n\tstruct hash_mac_addr *entry;\n\n\t \n\tlist_for_each_entry(entry, &adap->mac_hlist, list) {\n\t\tucast |= is_unicast_ether_addr(entry->addr);\n\t\tvec |= (1ULL << hash_mac_addr(entry->addr));\n\t}\n\treturn t4_set_addr_hash(adap, adap->mbox, pi->viid, ucast,\n\t\t\t\tvec, false);\n}\n\nstatic int cxgb4_mac_sync(struct net_device *netdev, const u8 *mac_addr)\n{\n\tstruct port_info *pi = netdev_priv(netdev);\n\tstruct adapter *adap = pi->adapter;\n\tint ret;\n\tu64 mhash = 0;\n\tu64 uhash = 0;\n\t \n\n\tu16 idx[1] = {};\n\tbool free = false;\n\tbool ucast = is_unicast_ether_addr(mac_addr);\n\tconst u8 *maclist[1] = {mac_addr};\n\tstruct hash_mac_addr *new_entry;\n\n\tret = cxgb4_alloc_mac_filt(adap, pi->viid, free, 1, maclist,\n\t\t\t\t   idx, ucast ? &uhash : &mhash, false);\n\tif (ret < 0)\n\t\tgoto out;\n\t \n\tif (uhash || mhash) {\n\t\tnew_entry = kzalloc(sizeof(*new_entry), GFP_ATOMIC);\n\t\tif (!new_entry)\n\t\t\treturn -ENOMEM;\n\t\tether_addr_copy(new_entry->addr, mac_addr);\n\t\tlist_add_tail(&new_entry->list, &adap->mac_hlist);\n\t\tret = cxgb4_set_addr_hash(pi);\n\t}\nout:\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int cxgb4_mac_unsync(struct net_device *netdev, const u8 *mac_addr)\n{\n\tstruct port_info *pi = netdev_priv(netdev);\n\tstruct adapter *adap = pi->adapter;\n\tint ret;\n\tconst u8 *maclist[1] = {mac_addr};\n\tstruct hash_mac_addr *entry, *tmp;\n\n\t \n\tlist_for_each_entry_safe(entry, tmp, &adap->mac_hlist, list) {\n\t\tif (ether_addr_equal(entry->addr, mac_addr)) {\n\t\t\tlist_del(&entry->list);\n\t\t\tkfree(entry);\n\t\t\treturn cxgb4_set_addr_hash(pi);\n\t\t}\n\t}\n\n\tret = cxgb4_free_mac_filt(adap, pi->viid, 1, maclist, false);\n\treturn ret < 0 ? -EINVAL : 0;\n}\n\n \nstatic int set_rxmode(struct net_device *dev, int mtu, bool sleep_ok)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\t__dev_uc_sync(dev, cxgb4_mac_sync, cxgb4_mac_unsync);\n\t__dev_mc_sync(dev, cxgb4_mac_sync, cxgb4_mac_unsync);\n\n\treturn t4_set_rxmode(adapter, adapter->mbox, pi->viid, pi->viid_mirror,\n\t\t\t     mtu, (dev->flags & IFF_PROMISC) ? 1 : 0,\n\t\t\t     (dev->flags & IFF_ALLMULTI) ? 1 : 0, 1, -1,\n\t\t\t     sleep_ok);\n}\n\n \nint cxgb4_change_mac(struct port_info *pi, unsigned int viid,\n\t\t     int *tcam_idx, const u8 *addr, bool persist,\n\t\t     u8 *smt_idx)\n{\n\tstruct adapter *adapter = pi->adapter;\n\tstruct hash_mac_addr *entry, *new_entry;\n\tint ret;\n\n\tret = t4_change_mac(adapter, adapter->mbox, viid,\n\t\t\t    *tcam_idx, addr, persist, smt_idx);\n\t \n\tif (ret == -ENOMEM) {\n\t\t \n\t\tlist_for_each_entry(entry, &adapter->mac_hlist, list) {\n\t\t\tif (entry->iface_mac) {\n\t\t\t\tether_addr_copy(entry->addr, addr);\n\t\t\t\tgoto set_hash;\n\t\t\t}\n\t\t}\n\t\tnew_entry = kzalloc(sizeof(*new_entry), GFP_KERNEL);\n\t\tif (!new_entry)\n\t\t\treturn -ENOMEM;\n\t\tether_addr_copy(new_entry->addr, addr);\n\t\tnew_entry->iface_mac = true;\n\t\tlist_add_tail(&new_entry->list, &adapter->mac_hlist);\nset_hash:\n\t\tret = cxgb4_set_addr_hash(pi);\n\t} else if (ret >= 0) {\n\t\t*tcam_idx = ret;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int link_start(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tunsigned int mb = pi->adapter->mbox;\n\tint ret;\n\n\t \n\tret = t4_set_rxmode(pi->adapter, mb, pi->viid, pi->viid_mirror,\n\t\t\t    dev->mtu, -1, -1, -1,\n\t\t\t    !!(dev->features & NETIF_F_HW_VLAN_CTAG_RX), true);\n\tif (ret == 0)\n\t\tret = cxgb4_update_mac_filt(pi, pi->viid, &pi->xact_addr_filt,\n\t\t\t\t\t    dev->dev_addr, true, &pi->smt_idx);\n\tif (ret == 0)\n\t\tret = t4_link_l1cfg(pi->adapter, mb, pi->tx_chan,\n\t\t\t\t    &pi->link_cfg);\n\tif (ret == 0) {\n\t\tlocal_bh_disable();\n\t\tret = t4_enable_pi_params(pi->adapter, mb, pi, true,\n\t\t\t\t\t  true, CXGB4_DCB_ENABLED);\n\t\tlocal_bh_enable();\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n \nstatic void dcb_rpl(struct adapter *adap, const struct fw_port_cmd *pcmd)\n{\n\tint port = FW_PORT_CMD_PORTID_G(ntohl(pcmd->op_to_portid));\n\tstruct net_device *dev = adap->port[adap->chan_map[port]];\n\tint old_dcb_enabled = cxgb4_dcb_enabled(dev);\n\tint new_dcb_enabled;\n\n\tcxgb4_dcb_handle_fw_update(adap, pcmd);\n\tnew_dcb_enabled = cxgb4_dcb_enabled(dev);\n\n\t \n\tif (new_dcb_enabled != old_dcb_enabled)\n\t\tdcb_tx_queue_prio_enable(dev, new_dcb_enabled);\n}\n#endif  \n\n \nstatic int fwevtq_handler(struct sge_rspq *q, const __be64 *rsp,\n\t\t\t  const struct pkt_gl *gl)\n{\n\tu8 opcode = ((const struct rss_header *)rsp)->opcode;\n\n\trsp++;                                           \n\n\t \n\tif (unlikely(opcode == CPL_FW4_MSG &&\n\t   ((const struct cpl_fw4_msg *)rsp)->type == FW_TYPE_RSSCPL)) {\n\t\trsp++;\n\t\topcode = ((const struct rss_header *)rsp)->opcode;\n\t\trsp++;\n\t\tif (opcode != CPL_SGE_EGR_UPDATE) {\n\t\t\tdev_err(q->adap->pdev_dev, \"unexpected FW4/CPL %#x on FW event queue\\n\"\n\t\t\t\t, opcode);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (likely(opcode == CPL_SGE_EGR_UPDATE)) {\n\t\tconst struct cpl_sge_egr_update *p = (void *)rsp;\n\t\tunsigned int qid = EGR_QID_G(ntohl(p->opcode_qid));\n\t\tstruct sge_txq *txq;\n\n\t\ttxq = q->adap->sge.egr_map[qid - q->adap->sge.egr_start];\n\t\ttxq->restarts++;\n\t\tif (txq->q_type == CXGB4_TXQ_ETH) {\n\t\t\tstruct sge_eth_txq *eq;\n\n\t\t\teq = container_of(txq, struct sge_eth_txq, q);\n\t\t\tt4_sge_eth_txq_egress_update(q->adap, eq, -1);\n\t\t} else {\n\t\t\tstruct sge_uld_txq *oq;\n\n\t\t\toq = container_of(txq, struct sge_uld_txq, q);\n\t\t\ttasklet_schedule(&oq->qresume_tsk);\n\t\t}\n\t} else if (opcode == CPL_FW6_MSG || opcode == CPL_FW4_MSG) {\n\t\tconst struct cpl_fw6_msg *p = (void *)rsp;\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n\t\tconst struct fw_port_cmd *pcmd = (const void *)p->data;\n\t\tunsigned int cmd = FW_CMD_OP_G(ntohl(pcmd->op_to_portid));\n\t\tunsigned int action =\n\t\t\tFW_PORT_CMD_ACTION_G(ntohl(pcmd->action_to_len16));\n\n\t\tif (cmd == FW_PORT_CMD &&\n\t\t    (action == FW_PORT_ACTION_GET_PORT_INFO ||\n\t\t     action == FW_PORT_ACTION_GET_PORT_INFO32)) {\n\t\t\tint port = FW_PORT_CMD_PORTID_G(\n\t\t\t\t\tbe32_to_cpu(pcmd->op_to_portid));\n\t\t\tstruct net_device *dev;\n\t\t\tint dcbxdis, state_input;\n\n\t\t\tdev = q->adap->port[q->adap->chan_map[port]];\n\t\t\tdcbxdis = (action == FW_PORT_ACTION_GET_PORT_INFO\n\t\t\t  ? !!(pcmd->u.info.dcbxdis_pkd & FW_PORT_CMD_DCBXDIS_F)\n\t\t\t  : !!(be32_to_cpu(pcmd->u.info32.lstatus32_to_cbllen32)\n\t\t\t       & FW_PORT_CMD_DCBXDIS32_F));\n\t\t\tstate_input = (dcbxdis\n\t\t\t\t       ? CXGB4_DCB_INPUT_FW_DISABLED\n\t\t\t\t       : CXGB4_DCB_INPUT_FW_ENABLED);\n\n\t\t\tcxgb4_dcb_state_fsm(dev, state_input);\n\t\t}\n\n\t\tif (cmd == FW_PORT_CMD &&\n\t\t    action == FW_PORT_ACTION_L2_DCB_CFG)\n\t\t\tdcb_rpl(q->adap, pcmd);\n\t\telse\n#endif\n\t\t\tif (p->type == 0)\n\t\t\t\tt4_handle_fw_rpl(q->adap, p->data);\n\t} else if (opcode == CPL_L2T_WRITE_RPL) {\n\t\tconst struct cpl_l2t_write_rpl *p = (void *)rsp;\n\n\t\tdo_l2t_write_rpl(q->adap, p);\n\t} else if (opcode == CPL_SMT_WRITE_RPL) {\n\t\tconst struct cpl_smt_write_rpl *p = (void *)rsp;\n\n\t\tdo_smt_write_rpl(q->adap, p);\n\t} else if (opcode == CPL_SET_TCB_RPL) {\n\t\tconst struct cpl_set_tcb_rpl *p = (void *)rsp;\n\n\t\tfilter_rpl(q->adap, p);\n\t} else if (opcode == CPL_ACT_OPEN_RPL) {\n\t\tconst struct cpl_act_open_rpl *p = (void *)rsp;\n\n\t\thash_filter_rpl(q->adap, p);\n\t} else if (opcode == CPL_ABORT_RPL_RSS) {\n\t\tconst struct cpl_abort_rpl_rss *p = (void *)rsp;\n\n\t\thash_del_filter_rpl(q->adap, p);\n\t} else if (opcode == CPL_SRQ_TABLE_RPL) {\n\t\tconst struct cpl_srq_table_rpl *p = (void *)rsp;\n\n\t\tdo_srq_table_rpl(q->adap, p);\n\t} else\n\t\tdev_err(q->adap->pdev_dev,\n\t\t\t\"unexpected CPL %#x on FW event queue\\n\", opcode);\nout:\n\treturn 0;\n}\n\nstatic void disable_msi(struct adapter *adapter)\n{\n\tif (adapter->flags & CXGB4_USING_MSIX) {\n\t\tpci_disable_msix(adapter->pdev);\n\t\tadapter->flags &= ~CXGB4_USING_MSIX;\n\t} else if (adapter->flags & CXGB4_USING_MSI) {\n\t\tpci_disable_msi(adapter->pdev);\n\t\tadapter->flags &= ~CXGB4_USING_MSI;\n\t}\n}\n\n \nstatic irqreturn_t t4_nondata_intr(int irq, void *cookie)\n{\n\tstruct adapter *adap = cookie;\n\tu32 v = t4_read_reg(adap, MYPF_REG(PL_PF_INT_CAUSE_A));\n\n\tif (v & PFSW_F) {\n\t\tadap->swintr = 1;\n\t\tt4_write_reg(adap, MYPF_REG(PL_PF_INT_CAUSE_A), v);\n\t}\n\tif (adap->flags & CXGB4_MASTER_PF)\n\t\tt4_slow_intr_handler(adap);\n\treturn IRQ_HANDLED;\n}\n\nint cxgb4_set_msix_aff(struct adapter *adap, unsigned short vec,\n\t\t       cpumask_var_t *aff_mask, int idx)\n{\n\tint rv;\n\n\tif (!zalloc_cpumask_var(aff_mask, GFP_KERNEL)) {\n\t\tdev_err(adap->pdev_dev, \"alloc_cpumask_var failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcpumask_set_cpu(cpumask_local_spread(idx, dev_to_node(adap->pdev_dev)),\n\t\t\t*aff_mask);\n\n\trv = irq_set_affinity_hint(vec, *aff_mask);\n\tif (rv)\n\t\tdev_warn(adap->pdev_dev,\n\t\t\t \"irq_set_affinity_hint %u failed %d\\n\",\n\t\t\t vec, rv);\n\n\treturn 0;\n}\n\nvoid cxgb4_clear_msix_aff(unsigned short vec, cpumask_var_t aff_mask)\n{\n\tirq_set_affinity_hint(vec, NULL);\n\tfree_cpumask_var(aff_mask);\n}\n\nstatic int request_msix_queue_irqs(struct adapter *adap)\n{\n\tstruct sge *s = &adap->sge;\n\tstruct msix_info *minfo;\n\tint err, ethqidx;\n\n\tif (s->fwevtq_msix_idx < 0)\n\t\treturn -ENOMEM;\n\n\terr = request_irq(adap->msix_info[s->fwevtq_msix_idx].vec,\n\t\t\t  t4_sge_intr_msix, 0,\n\t\t\t  adap->msix_info[s->fwevtq_msix_idx].desc,\n\t\t\t  &s->fw_evtq);\n\tif (err)\n\t\treturn err;\n\n\tfor_each_ethrxq(s, ethqidx) {\n\t\tminfo = s->ethrxq[ethqidx].msix;\n\t\terr = request_irq(minfo->vec,\n\t\t\t\t  t4_sge_intr_msix, 0,\n\t\t\t\t  minfo->desc,\n\t\t\t\t  &s->ethrxq[ethqidx].rspq);\n\t\tif (err)\n\t\t\tgoto unwind;\n\n\t\tcxgb4_set_msix_aff(adap, minfo->vec,\n\t\t\t\t   &minfo->aff_mask, ethqidx);\n\t}\n\treturn 0;\n\nunwind:\n\twhile (--ethqidx >= 0) {\n\t\tminfo = s->ethrxq[ethqidx].msix;\n\t\tcxgb4_clear_msix_aff(minfo->vec, minfo->aff_mask);\n\t\tfree_irq(minfo->vec, &s->ethrxq[ethqidx].rspq);\n\t}\n\tfree_irq(adap->msix_info[s->fwevtq_msix_idx].vec, &s->fw_evtq);\n\treturn err;\n}\n\nstatic void free_msix_queue_irqs(struct adapter *adap)\n{\n\tstruct sge *s = &adap->sge;\n\tstruct msix_info *minfo;\n\tint i;\n\n\tfree_irq(adap->msix_info[s->fwevtq_msix_idx].vec, &s->fw_evtq);\n\tfor_each_ethrxq(s, i) {\n\t\tminfo = s->ethrxq[i].msix;\n\t\tcxgb4_clear_msix_aff(minfo->vec, minfo->aff_mask);\n\t\tfree_irq(minfo->vec, &s->ethrxq[i].rspq);\n\t}\n}\n\nstatic int setup_ppod_edram(struct adapter *adap)\n{\n\tunsigned int param, val;\n\tint ret;\n\n\t \n\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\tFW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_PPOD_EDRAM));\n\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1, &param, &val);\n\tif (ret < 0) {\n\t\tdev_warn(adap->pdev_dev,\n\t\t\t \"querying PPOD_EDRAM support failed: %d\\n\",\n\t\t\t ret);\n\t\treturn -1;\n\t}\n\n\tif (val != 1)\n\t\treturn -1;\n\n\tret = t4_set_params(adap, adap->mbox, adap->pf, 0, 1, &param, &val);\n\tif (ret < 0) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"setting PPOD_EDRAM failed: %d\\n\", ret);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void adap_config_hpfilter(struct adapter *adapter)\n{\n\tu32 param, val = 0;\n\tint ret;\n\n\t \n\tparam = FW_PARAM_DEV(HPFILTER_REGION_SUPPORT);\n\tret = t4_set_params(adapter, adapter->mbox, adapter->pf, 0,\n\t\t\t    1, &param, &val);\n\n\t \n\tif (ret < 0)\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"HP filter region isn't supported by FW\\n\");\n}\n\nstatic int cxgb4_config_rss(const struct port_info *pi, u16 *rss,\n\t\t\t    u16 rss_size, u16 viid)\n{\n\tstruct adapter *adap = pi->adapter;\n\tint ret;\n\n\tret = t4_config_rss_range(adap, adap->mbox, viid, 0, rss_size, rss,\n\t\t\t\t  rss_size);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn t4_config_vi_rss(adap, adap->mbox, viid,\n\t\t\t\tFW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN_F |\n\t\t\t\tFW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F |\n\t\t\t\tFW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN_F |\n\t\t\t\tFW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F |\n\t\t\t\tFW_RSS_VI_CONFIG_CMD_UDPEN_F,\n\t\t\t\trss[0]);\n}\n\n \nint cxgb4_write_rss(const struct port_info *pi, const u16 *queues)\n{\n\tstruct adapter *adapter = pi->adapter;\n\tconst struct sge_eth_rxq *rxq;\n\tint i, err;\n\tu16 *rss;\n\n\trxq = &adapter->sge.ethrxq[pi->first_qset];\n\trss = kmalloc_array(pi->rss_size, sizeof(u16), GFP_KERNEL);\n\tif (!rss)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < pi->rss_size; i++, queues++)\n\t\trss[i] = rxq[*queues].rspq.abs_id;\n\n\terr = cxgb4_config_rss(pi, rss, pi->rss_size, pi->viid);\n\tkfree(rss);\n\treturn err;\n}\n\n \nstatic int setup_rss(struct adapter *adap)\n{\n\tint i, j, err;\n\n\tfor_each_port(adap, i) {\n\t\tconst struct port_info *pi = adap2pinfo(adap, i);\n\n\t\t \n\t\tfor (j = 0; j < pi->rss_size; j++)\n\t\t\tpi->rss[j] = j % pi->nqsets;\n\n\t\terr = cxgb4_write_rss(pi, pi->rss);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic unsigned int rxq_to_chan(const struct sge *p, unsigned int qid)\n{\n\tqid -= p->ingr_start;\n\treturn netdev2pinfo(p->ingr_map[qid]->netdev)->tx_chan;\n}\n\nvoid cxgb4_quiesce_rx(struct sge_rspq *q)\n{\n\tif (q->handler)\n\t\tnapi_disable(&q->napi);\n}\n\n \nstatic void quiesce_rx(struct adapter *adap)\n{\n\tint i;\n\n\tfor (i = 0; i < adap->sge.ingr_sz; i++) {\n\t\tstruct sge_rspq *q = adap->sge.ingr_map[i];\n\n\t\tif (!q)\n\t\t\tcontinue;\n\n\t\tcxgb4_quiesce_rx(q);\n\t}\n}\n\n \nstatic void disable_interrupts(struct adapter *adap)\n{\n\tstruct sge *s = &adap->sge;\n\n\tif (adap->flags & CXGB4_FULL_INIT_DONE) {\n\t\tt4_intr_disable(adap);\n\t\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\t\tfree_msix_queue_irqs(adap);\n\t\t\tfree_irq(adap->msix_info[s->nd_msix_idx].vec,\n\t\t\t\t adap);\n\t\t} else {\n\t\t\tfree_irq(adap->pdev->irq, adap);\n\t\t}\n\t\tquiesce_rx(adap);\n\t}\n}\n\nvoid cxgb4_enable_rx(struct adapter *adap, struct sge_rspq *q)\n{\n\tif (q->handler)\n\t\tnapi_enable(&q->napi);\n\n\t \n\tt4_write_reg(adap, MYPF_REG(SGE_PF_GTS_A),\n\t\t     SEINTARM_V(q->intr_params) |\n\t\t     INGRESSQID_V(q->cntxt_id));\n}\n\n \nstatic void enable_rx(struct adapter *adap)\n{\n\tint i;\n\n\tfor (i = 0; i < adap->sge.ingr_sz; i++) {\n\t\tstruct sge_rspq *q = adap->sge.ingr_map[i];\n\n\t\tif (!q)\n\t\t\tcontinue;\n\n\t\tcxgb4_enable_rx(adap, q);\n\t}\n}\n\nstatic int setup_non_data_intr(struct adapter *adap)\n{\n\tint msix;\n\n\tadap->sge.nd_msix_idx = -1;\n\tif (!(adap->flags & CXGB4_USING_MSIX))\n\t\treturn 0;\n\n\t \n\tmsix = cxgb4_get_msix_idx_from_bmap(adap);\n\tif (msix < 0)\n\t\treturn -ENOMEM;\n\n\tsnprintf(adap->msix_info[msix].desc,\n\t\t sizeof(adap->msix_info[msix].desc),\n\t\t \"%s\", adap->port[0]->name);\n\n\tadap->sge.nd_msix_idx = msix;\n\treturn 0;\n}\n\nstatic int setup_fw_sge_queues(struct adapter *adap)\n{\n\tstruct sge *s = &adap->sge;\n\tint msix, err = 0;\n\n\tbitmap_zero(s->starving_fl, s->egr_sz);\n\tbitmap_zero(s->txq_maperr, s->egr_sz);\n\n\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\ts->fwevtq_msix_idx = -1;\n\t\tmsix = cxgb4_get_msix_idx_from_bmap(adap);\n\t\tif (msix < 0)\n\t\t\treturn -ENOMEM;\n\n\t\tsnprintf(adap->msix_info[msix].desc,\n\t\t\t sizeof(adap->msix_info[msix].desc),\n\t\t\t \"%s-FWeventq\", adap->port[0]->name);\n\t} else {\n\t\terr = t4_sge_alloc_rxq(adap, &s->intrq, false, adap->port[0], 0,\n\t\t\t\t       NULL, NULL, NULL, -1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmsix = -((int)s->intrq.abs_id + 1);\n\t}\n\n\terr = t4_sge_alloc_rxq(adap, &s->fw_evtq, true, adap->port[0],\n\t\t\t       msix, NULL, fwevtq_handler, NULL, -1);\n\tif (err && msix >= 0)\n\t\tcxgb4_free_msix_idx_in_bmap(adap, msix);\n\n\ts->fwevtq_msix_idx = msix;\n\treturn err;\n}\n\n \nstatic int setup_sge_queues(struct adapter *adap)\n{\n\tstruct sge_uld_rxq_info *rxq_info = NULL;\n\tstruct sge *s = &adap->sge;\n\tunsigned int cmplqid = 0;\n\tint err, i, j, msix = 0;\n\n\tif (is_uld(adap))\n\t\trxq_info = s->uld_rxq_info[CXGB4_ULD_RDMA];\n\n\tif (!(adap->flags & CXGB4_USING_MSIX))\n\t\tmsix = -((int)s->intrq.abs_id + 1);\n\n\tfor_each_port(adap, i) {\n\t\tstruct net_device *dev = adap->port[i];\n\t\tstruct port_info *pi = netdev_priv(dev);\n\t\tstruct sge_eth_rxq *q = &s->ethrxq[pi->first_qset];\n\t\tstruct sge_eth_txq *t = &s->ethtxq[pi->first_qset];\n\n\t\tfor (j = 0; j < pi->nqsets; j++, q++) {\n\t\t\tif (msix >= 0) {\n\t\t\t\tmsix = cxgb4_get_msix_idx_from_bmap(adap);\n\t\t\t\tif (msix < 0) {\n\t\t\t\t\terr = msix;\n\t\t\t\t\tgoto freeout;\n\t\t\t\t}\n\n\t\t\t\tsnprintf(adap->msix_info[msix].desc,\n\t\t\t\t\t sizeof(adap->msix_info[msix].desc),\n\t\t\t\t\t \"%s-Rx%d\", dev->name, j);\n\t\t\t\tq->msix = &adap->msix_info[msix];\n\t\t\t}\n\n\t\t\terr = t4_sge_alloc_rxq(adap, &q->rspq, false, dev,\n\t\t\t\t\t       msix, &q->fl,\n\t\t\t\t\t       t4_ethrx_handler,\n\t\t\t\t\t       NULL,\n\t\t\t\t\t       t4_get_tp_ch_map(adap,\n\t\t\t\t\t\t\t\tpi->tx_chan));\n\t\t\tif (err)\n\t\t\t\tgoto freeout;\n\t\t\tq->rspq.idx = j;\n\t\t\tmemset(&q->stats, 0, sizeof(q->stats));\n\t\t}\n\n\t\tq = &s->ethrxq[pi->first_qset];\n\t\tfor (j = 0; j < pi->nqsets; j++, t++, q++) {\n\t\t\terr = t4_sge_alloc_eth_txq(adap, t, dev,\n\t\t\t\t\tnetdev_get_tx_queue(dev, j),\n\t\t\t\t\tq->rspq.cntxt_id,\n\t\t\t\t\t!!(adap->flags & CXGB4_SGE_DBQ_TIMER));\n\t\t\tif (err)\n\t\t\t\tgoto freeout;\n\t\t}\n\t}\n\n\tfor_each_port(adap, i) {\n\t\t \n\t\tif (rxq_info)\n\t\t\tcmplqid\t= rxq_info->uldrxq[i].rspq.cntxt_id;\n\n\t\terr = t4_sge_alloc_ctrl_txq(adap, &s->ctrlq[i], adap->port[i],\n\t\t\t\t\t    s->fw_evtq.cntxt_id, cmplqid);\n\t\tif (err)\n\t\t\tgoto freeout;\n\t}\n\n\tif (!is_t4(adap->params.chip)) {\n\t\terr = t4_sge_alloc_eth_txq(adap, &s->ptptxq, adap->port[0],\n\t\t\t\t\t   netdev_get_tx_queue(adap->port[0], 0)\n\t\t\t\t\t   , s->fw_evtq.cntxt_id, false);\n\t\tif (err)\n\t\t\tgoto freeout;\n\t}\n\n\tt4_write_reg(adap, is_t4(adap->params.chip) ?\n\t\t\t\tMPS_TRC_RSS_CONTROL_A :\n\t\t\t\tMPS_T5_TRC_RSS_CONTROL_A,\n\t\t     RSSCONTROL_V(netdev2pinfo(adap->port[0])->tx_chan) |\n\t\t     QUEUENUMBER_V(s->ethrxq[0].rspq.abs_id));\n\treturn 0;\nfreeout:\n\tdev_err(adap->pdev_dev, \"Can't allocate queues, err=%d\\n\", -err);\n\tt4_free_sge_resources(adap);\n\treturn err;\n}\n\nstatic u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb,\n\t\t\t     struct net_device *sb_dev)\n{\n\tint txq;\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n\t \n\tif (cxgb4_dcb_enabled(dev) && !is_kdump_kernel()) {\n\t\tu16 vlan_tci;\n\t\tint err;\n\n\t\terr = vlan_get_tag(skb, &vlan_tci);\n\t\tif (unlikely(err)) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_warn(dev,\n\t\t\t\t\t    \"TX Packet without VLAN Tag on DCB Link\\n\");\n\t\t\ttxq = 0;\n\t\t} else {\n\t\t\ttxq = (vlan_tci & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;\n#ifdef CONFIG_CHELSIO_T4_FCOE\n\t\t\tif (skb->protocol == htons(ETH_P_FCOE))\n\t\t\t\ttxq = skb->priority & 0x7;\n#endif  \n\t\t}\n\t\treturn txq;\n\t}\n#endif  \n\n\tif (dev->num_tc) {\n\t\tstruct port_info *pi = netdev2pinfo(dev);\n\t\tu8 ver, proto;\n\n\t\tver = ip_hdr(skb)->version;\n\t\tproto = (ver == 6) ? ipv6_hdr(skb)->nexthdr :\n\t\t\t\t     ip_hdr(skb)->protocol;\n\n\t\t \n\t\ttxq = netdev_pick_tx(dev, skb, sb_dev);\n\t\tif (xfrm_offload(skb) || is_ptp_enabled(skb, dev) ||\n\t\t    skb->encapsulation ||\n\t\t    tls_is_skb_tx_device_offloaded(skb) ||\n\t\t    (proto != IPPROTO_TCP && proto != IPPROTO_UDP))\n\t\t\ttxq = txq % pi->nqsets;\n\n\t\treturn txq;\n\t}\n\n\tif (select_queue) {\n\t\ttxq = (skb_rx_queue_recorded(skb)\n\t\t\t? skb_get_rx_queue(skb)\n\t\t\t: smp_processor_id());\n\n\t\twhile (unlikely(txq >= dev->real_num_tx_queues))\n\t\t\ttxq -= dev->real_num_tx_queues;\n\n\t\treturn txq;\n\t}\n\n\treturn netdev_pick_tx(dev, skb, NULL) % dev->real_num_tx_queues;\n}\n\nstatic int closest_timer(const struct sge *s, int time)\n{\n\tint i, delta, match = 0, min_delta = INT_MAX;\n\n\tfor (i = 0; i < ARRAY_SIZE(s->timer_val); i++) {\n\t\tdelta = time - s->timer_val[i];\n\t\tif (delta < 0)\n\t\t\tdelta = -delta;\n\t\tif (delta < min_delta) {\n\t\t\tmin_delta = delta;\n\t\t\tmatch = i;\n\t\t}\n\t}\n\treturn match;\n}\n\nstatic int closest_thres(const struct sge *s, int thres)\n{\n\tint i, delta, match = 0, min_delta = INT_MAX;\n\n\tfor (i = 0; i < ARRAY_SIZE(s->counter_val); i++) {\n\t\tdelta = thres - s->counter_val[i];\n\t\tif (delta < 0)\n\t\t\tdelta = -delta;\n\t\tif (delta < min_delta) {\n\t\t\tmin_delta = delta;\n\t\t\tmatch = i;\n\t\t}\n\t}\n\treturn match;\n}\n\n \nint cxgb4_set_rspq_intr_params(struct sge_rspq *q,\n\t\t\t       unsigned int us, unsigned int cnt)\n{\n\tstruct adapter *adap = q->adap;\n\n\tif ((us | cnt) == 0)\n\t\tcnt = 1;\n\n\tif (cnt) {\n\t\tint err;\n\t\tu32 v, new_idx;\n\n\t\tnew_idx = closest_thres(&adap->sge, cnt);\n\t\tif (q->desc && q->pktcnt_idx != new_idx) {\n\t\t\t \n\t\t\tv = FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DMAQ) |\n\t\t\t    FW_PARAMS_PARAM_X_V(\n\t\t\t\t\tFW_PARAMS_PARAM_DMAQ_IQ_INTCNTTHRESH) |\n\t\t\t    FW_PARAMS_PARAM_YZ_V(q->cntxt_id);\n\t\t\terr = t4_set_params(adap, adap->mbox, adap->pf, 0, 1,\n\t\t\t\t\t    &v, &new_idx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tq->pktcnt_idx = new_idx;\n\t}\n\n\tus = us == 0 ? 6 : closest_timer(&adap->sge, us);\n\tq->intr_params = QINTR_TIMER_IDX_V(us) | QINTR_CNT_EN_V(cnt > 0);\n\treturn 0;\n}\n\nstatic int cxgb_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tnetdev_features_t changed = dev->features ^ features;\n\tconst struct port_info *pi = netdev_priv(dev);\n\tint err;\n\n\tif (!(changed & NETIF_F_HW_VLAN_CTAG_RX))\n\t\treturn 0;\n\n\terr = t4_set_rxmode(pi->adapter, pi->adapter->mbox, pi->viid,\n\t\t\t    pi->viid_mirror, -1, -1, -1, -1,\n\t\t\t    !!(features & NETIF_F_HW_VLAN_CTAG_RX), true);\n\tif (unlikely(err))\n\t\tdev->features = features ^ NETIF_F_HW_VLAN_CTAG_RX;\n\treturn err;\n}\n\nstatic int setup_debugfs(struct adapter *adap)\n{\n\tif (IS_ERR_OR_NULL(adap->debugfs_root))\n\t\treturn -1;\n\n#ifdef CONFIG_DEBUG_FS\n\tt4_setup_debugfs(adap);\n#endif\n\treturn 0;\n}\n\nstatic void cxgb4_port_mirror_free_rxq(struct adapter *adap,\n\t\t\t\t       struct sge_eth_rxq *mirror_rxq)\n{\n\tif ((adap->flags & CXGB4_FULL_INIT_DONE) &&\n\t    !(adap->flags & CXGB4_SHUTTING_DOWN))\n\t\tcxgb4_quiesce_rx(&mirror_rxq->rspq);\n\n\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\tcxgb4_clear_msix_aff(mirror_rxq->msix->vec,\n\t\t\t\t     mirror_rxq->msix->aff_mask);\n\t\tfree_irq(mirror_rxq->msix->vec, &mirror_rxq->rspq);\n\t\tcxgb4_free_msix_idx_in_bmap(adap, mirror_rxq->msix->idx);\n\t}\n\n\tfree_rspq_fl(adap, &mirror_rxq->rspq, &mirror_rxq->fl);\n}\n\nstatic int cxgb4_port_mirror_alloc_queues(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct sge_eth_rxq *mirror_rxq;\n\tstruct sge *s = &adap->sge;\n\tint ret = 0, msix = 0;\n\tu16 i, rxqid;\n\tu16 *rss;\n\n\tif (!pi->vi_mirror_count)\n\t\treturn 0;\n\n\tif (s->mirror_rxq[pi->port_id])\n\t\treturn 0;\n\n\tmirror_rxq = kcalloc(pi->nmirrorqsets, sizeof(*mirror_rxq), GFP_KERNEL);\n\tif (!mirror_rxq)\n\t\treturn -ENOMEM;\n\n\ts->mirror_rxq[pi->port_id] = mirror_rxq;\n\n\tif (!(adap->flags & CXGB4_USING_MSIX))\n\t\tmsix = -((int)adap->sge.intrq.abs_id + 1);\n\n\tfor (i = 0, rxqid = 0; i < pi->nmirrorqsets; i++, rxqid++) {\n\t\tmirror_rxq = &s->mirror_rxq[pi->port_id][i];\n\n\t\t \n\t\tif (msix >= 0) {\n\t\t\tmsix = cxgb4_get_msix_idx_from_bmap(adap);\n\t\t\tif (msix < 0) {\n\t\t\t\tret = msix;\n\t\t\t\tgoto out_free_queues;\n\t\t\t}\n\n\t\t\tmirror_rxq->msix = &adap->msix_info[msix];\n\t\t\tsnprintf(mirror_rxq->msix->desc,\n\t\t\t\t sizeof(mirror_rxq->msix->desc),\n\t\t\t\t \"%s-mirrorrxq%d\", dev->name, i);\n\t\t}\n\n\t\tinit_rspq(adap, &mirror_rxq->rspq,\n\t\t\t  CXGB4_MIRROR_RXQ_DEFAULT_INTR_USEC,\n\t\t\t  CXGB4_MIRROR_RXQ_DEFAULT_PKT_CNT,\n\t\t\t  CXGB4_MIRROR_RXQ_DEFAULT_DESC_NUM,\n\t\t\t  CXGB4_MIRROR_RXQ_DEFAULT_DESC_SIZE);\n\n\t\tmirror_rxq->fl.size = CXGB4_MIRROR_FLQ_DEFAULT_DESC_NUM;\n\n\t\tret = t4_sge_alloc_rxq(adap, &mirror_rxq->rspq, false,\n\t\t\t\t       dev, msix, &mirror_rxq->fl,\n\t\t\t\t       t4_ethrx_handler, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto out_free_msix_idx;\n\n\t\t \n\t\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\t\tret = request_irq(mirror_rxq->msix->vec,\n\t\t\t\t\t  t4_sge_intr_msix, 0,\n\t\t\t\t\t  mirror_rxq->msix->desc,\n\t\t\t\t\t  &mirror_rxq->rspq);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_rxq;\n\n\t\t\tcxgb4_set_msix_aff(adap, mirror_rxq->msix->vec,\n\t\t\t\t\t   &mirror_rxq->msix->aff_mask, i);\n\t\t}\n\n\t\t \n\t\tcxgb4_enable_rx(adap, &mirror_rxq->rspq);\n\t}\n\n\t \n\trss = kcalloc(pi->rss_size, sizeof(u16), GFP_KERNEL);\n\tif (!rss) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_queues;\n\t}\n\n\tmirror_rxq = &s->mirror_rxq[pi->port_id][0];\n\tfor (i = 0; i < pi->rss_size; i++)\n\t\trss[i] = mirror_rxq[i % pi->nmirrorqsets].rspq.abs_id;\n\n\tret = cxgb4_config_rss(pi, rss, pi->rss_size, pi->viid_mirror);\n\tkfree(rss);\n\tif (ret)\n\t\tgoto out_free_queues;\n\n\treturn 0;\n\nout_free_rxq:\n\tfree_rspq_fl(adap, &mirror_rxq->rspq, &mirror_rxq->fl);\n\nout_free_msix_idx:\n\tcxgb4_free_msix_idx_in_bmap(adap, mirror_rxq->msix->idx);\n\nout_free_queues:\n\twhile (rxqid-- > 0)\n\t\tcxgb4_port_mirror_free_rxq(adap,\n\t\t\t\t\t   &s->mirror_rxq[pi->port_id][rxqid]);\n\n\tkfree(s->mirror_rxq[pi->port_id]);\n\ts->mirror_rxq[pi->port_id] = NULL;\n\treturn ret;\n}\n\nstatic void cxgb4_port_mirror_free_queues(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct sge *s = &adap->sge;\n\tu16 i;\n\n\tif (!pi->vi_mirror_count)\n\t\treturn;\n\n\tif (!s->mirror_rxq[pi->port_id])\n\t\treturn;\n\n\tfor (i = 0; i < pi->nmirrorqsets; i++)\n\t\tcxgb4_port_mirror_free_rxq(adap,\n\t\t\t\t\t   &s->mirror_rxq[pi->port_id][i]);\n\n\tkfree(s->mirror_rxq[pi->port_id]);\n\ts->mirror_rxq[pi->port_id] = NULL;\n}\n\nstatic int cxgb4_port_mirror_start(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tint ret, idx = -1;\n\n\tif (!pi->vi_mirror_count)\n\t\treturn 0;\n\n\t \n\tret = t4_set_rxmode(adap, adap->mbox, pi->viid, pi->viid_mirror,\n\t\t\t    dev->mtu, (dev->flags & IFF_PROMISC) ? 1 : 0,\n\t\t\t    (dev->flags & IFF_ALLMULTI) ? 1 : 0, 1,\n\t\t\t    !!(dev->features & NETIF_F_HW_VLAN_CTAG_RX), true);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed start up Rx mode for Mirror VI 0x%x, ret: %d\\n\",\n\t\t\tpi->viid_mirror, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = cxgb4_update_mac_filt(pi, pi->viid_mirror, &idx,\n\t\t\t\t    dev->dev_addr, true, NULL);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed updating MAC filter for Mirror VI 0x%x, ret: %d\\n\",\n\t\t\tpi->viid_mirror, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tlocal_bh_disable();\n\tret = t4_enable_vi_params(adap, adap->mbox, pi->viid_mirror, true, true,\n\t\t\t\t  false);\n\tlocal_bh_enable();\n\tif (ret)\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed starting Mirror VI 0x%x, ret: %d\\n\",\n\t\t\tpi->viid_mirror, ret);\n\n\treturn ret;\n}\n\nstatic void cxgb4_port_mirror_stop(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tif (!pi->vi_mirror_count)\n\t\treturn;\n\n\tt4_enable_vi_params(adap, adap->mbox, pi->viid_mirror, false, false,\n\t\t\t    false);\n}\n\nint cxgb4_port_mirror_alloc(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tint ret = 0;\n\n\tif (!pi->nmirrorqsets)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&pi->vi_mirror_mutex);\n\tif (pi->viid_mirror) {\n\t\tpi->vi_mirror_count++;\n\t\tgoto out_unlock;\n\t}\n\n\tret = t4_init_port_mirror(pi, adap->mbox, pi->port_id, adap->pf, 0,\n\t\t\t\t  &pi->viid_mirror);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tpi->vi_mirror_count = 1;\n\n\tif (adap->flags & CXGB4_FULL_INIT_DONE) {\n\t\tret = cxgb4_port_mirror_alloc_queues(dev);\n\t\tif (ret)\n\t\t\tgoto out_free_vi;\n\n\t\tret = cxgb4_port_mirror_start(dev);\n\t\tif (ret)\n\t\t\tgoto out_free_queues;\n\t}\n\n\tmutex_unlock(&pi->vi_mirror_mutex);\n\treturn 0;\n\nout_free_queues:\n\tcxgb4_port_mirror_free_queues(dev);\n\nout_free_vi:\n\tpi->vi_mirror_count = 0;\n\tt4_free_vi(adap, adap->mbox, adap->pf, 0, pi->viid_mirror);\n\tpi->viid_mirror = 0;\n\nout_unlock:\n\tmutex_unlock(&pi->vi_mirror_mutex);\n\treturn ret;\n}\n\nvoid cxgb4_port_mirror_free(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tmutex_lock(&pi->vi_mirror_mutex);\n\tif (!pi->viid_mirror)\n\t\tgoto out_unlock;\n\n\tif (pi->vi_mirror_count > 1) {\n\t\tpi->vi_mirror_count--;\n\t\tgoto out_unlock;\n\t}\n\n\tcxgb4_port_mirror_stop(dev);\n\tcxgb4_port_mirror_free_queues(dev);\n\n\tpi->vi_mirror_count = 0;\n\tt4_free_vi(adap, adap->mbox, adap->pf, 0, pi->viid_mirror);\n\tpi->viid_mirror = 0;\n\nout_unlock:\n\tmutex_unlock(&pi->vi_mirror_mutex);\n}\n\n \n\n \nint cxgb4_alloc_atid(struct tid_info *t, void *data)\n{\n\tint atid = -1;\n\n\tspin_lock_bh(&t->atid_lock);\n\tif (t->afree) {\n\t\tunion aopen_entry *p = t->afree;\n\n\t\tatid = (p - t->atid_tab) + t->atid_base;\n\t\tt->afree = p->next;\n\t\tp->data = data;\n\t\tt->atids_in_use++;\n\t}\n\tspin_unlock_bh(&t->atid_lock);\n\treturn atid;\n}\nEXPORT_SYMBOL(cxgb4_alloc_atid);\n\n \nvoid cxgb4_free_atid(struct tid_info *t, unsigned int atid)\n{\n\tunion aopen_entry *p = &t->atid_tab[atid - t->atid_base];\n\n\tspin_lock_bh(&t->atid_lock);\n\tp->next = t->afree;\n\tt->afree = p;\n\tt->atids_in_use--;\n\tspin_unlock_bh(&t->atid_lock);\n}\nEXPORT_SYMBOL(cxgb4_free_atid);\n\n \nint cxgb4_alloc_stid(struct tid_info *t, int family, void *data)\n{\n\tint stid;\n\n\tspin_lock_bh(&t->stid_lock);\n\tif (family == PF_INET) {\n\t\tstid = find_first_zero_bit(t->stid_bmap, t->nstids);\n\t\tif (stid < t->nstids)\n\t\t\t__set_bit(stid, t->stid_bmap);\n\t\telse\n\t\t\tstid = -1;\n\t} else {\n\t\tstid = bitmap_find_free_region(t->stid_bmap, t->nstids, 1);\n\t\tif (stid < 0)\n\t\t\tstid = -1;\n\t}\n\tif (stid >= 0) {\n\t\tt->stid_tab[stid].data = data;\n\t\tstid += t->stid_base;\n\t\t \n\t\tif (family == PF_INET6) {\n\t\t\tt->stids_in_use += 2;\n\t\t\tt->v6_stids_in_use += 2;\n\t\t} else {\n\t\t\tt->stids_in_use++;\n\t\t}\n\t}\n\tspin_unlock_bh(&t->stid_lock);\n\treturn stid;\n}\nEXPORT_SYMBOL(cxgb4_alloc_stid);\n\n \nint cxgb4_alloc_sftid(struct tid_info *t, int family, void *data)\n{\n\tint stid;\n\n\tspin_lock_bh(&t->stid_lock);\n\tif (family == PF_INET) {\n\t\tstid = find_next_zero_bit(t->stid_bmap,\n\t\t\t\tt->nstids + t->nsftids, t->nstids);\n\t\tif (stid < (t->nstids + t->nsftids))\n\t\t\t__set_bit(stid, t->stid_bmap);\n\t\telse\n\t\t\tstid = -1;\n\t} else {\n\t\tstid = -1;\n\t}\n\tif (stid >= 0) {\n\t\tt->stid_tab[stid].data = data;\n\t\tstid -= t->nstids;\n\t\tstid += t->sftid_base;\n\t\tt->sftids_in_use++;\n\t}\n\tspin_unlock_bh(&t->stid_lock);\n\treturn stid;\n}\nEXPORT_SYMBOL(cxgb4_alloc_sftid);\n\n \nvoid cxgb4_free_stid(struct tid_info *t, unsigned int stid, int family)\n{\n\t \n\tif (t->nsftids && (stid >= t->sftid_base)) {\n\t\tstid -= t->sftid_base;\n\t\tstid += t->nstids;\n\t} else {\n\t\tstid -= t->stid_base;\n\t}\n\n\tspin_lock_bh(&t->stid_lock);\n\tif (family == PF_INET)\n\t\t__clear_bit(stid, t->stid_bmap);\n\telse\n\t\tbitmap_release_region(t->stid_bmap, stid, 1);\n\tt->stid_tab[stid].data = NULL;\n\tif (stid < t->nstids) {\n\t\tif (family == PF_INET6) {\n\t\t\tt->stids_in_use -= 2;\n\t\t\tt->v6_stids_in_use -= 2;\n\t\t} else {\n\t\t\tt->stids_in_use--;\n\t\t}\n\t} else {\n\t\tt->sftids_in_use--;\n\t}\n\n\tspin_unlock_bh(&t->stid_lock);\n}\nEXPORT_SYMBOL(cxgb4_free_stid);\n\n \nstatic void mk_tid_release(struct sk_buff *skb, unsigned int chan,\n\t\t\t   unsigned int tid)\n{\n\tstruct cpl_tid_release *req;\n\n\tset_wr_txq(skb, CPL_PRIORITY_SETUP, chan);\n\treq = __skb_put(skb, sizeof(*req));\n\tINIT_TP_WR(req, tid);\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_TID_RELEASE, tid));\n}\n\n \nstatic void cxgb4_queue_tid_release(struct tid_info *t, unsigned int chan,\n\t\t\t\t    unsigned int tid)\n{\n\tstruct adapter *adap = container_of(t, struct adapter, tids);\n\tvoid **p = &t->tid_tab[tid - t->tid_base];\n\n\tspin_lock_bh(&adap->tid_release_lock);\n\t*p = adap->tid_release_head;\n\t \n\tadap->tid_release_head = (void **)((uintptr_t)p | chan);\n\tif (!adap->tid_release_task_busy) {\n\t\tadap->tid_release_task_busy = true;\n\t\tqueue_work(adap->workq, &adap->tid_release_task);\n\t}\n\tspin_unlock_bh(&adap->tid_release_lock);\n}\n\n \nstatic void process_tid_release_list(struct work_struct *work)\n{\n\tstruct sk_buff *skb;\n\tstruct adapter *adap;\n\n\tadap = container_of(work, struct adapter, tid_release_task);\n\n\tspin_lock_bh(&adap->tid_release_lock);\n\twhile (adap->tid_release_head) {\n\t\tvoid **p = adap->tid_release_head;\n\t\tunsigned int chan = (uintptr_t)p & 3;\n\t\tp = (void *)p - chan;\n\n\t\tadap->tid_release_head = *p;\n\t\t*p = NULL;\n\t\tspin_unlock_bh(&adap->tid_release_lock);\n\n\t\twhile (!(skb = alloc_skb(sizeof(struct cpl_tid_release),\n\t\t\t\t\t GFP_KERNEL)))\n\t\t\tschedule_timeout_uninterruptible(1);\n\n\t\tmk_tid_release(skb, chan, p - adap->tids.tid_tab);\n\t\tt4_ofld_send(adap, skb);\n\t\tspin_lock_bh(&adap->tid_release_lock);\n\t}\n\tadap->tid_release_task_busy = false;\n\tspin_unlock_bh(&adap->tid_release_lock);\n}\n\n \nvoid cxgb4_remove_tid(struct tid_info *t, unsigned int chan, unsigned int tid,\n\t\t      unsigned short family)\n{\n\tstruct adapter *adap = container_of(t, struct adapter, tids);\n\tstruct sk_buff *skb;\n\n\tWARN_ON(tid_out_of_range(&adap->tids, tid));\n\n\tif (t->tid_tab[tid - adap->tids.tid_base]) {\n\t\tt->tid_tab[tid - adap->tids.tid_base] = NULL;\n\t\tatomic_dec(&t->conns_in_use);\n\t\tif (t->hash_base && (tid >= t->hash_base)) {\n\t\t\tif (family == AF_INET6)\n\t\t\t\tatomic_sub(2, &t->hash_tids_in_use);\n\t\t\telse\n\t\t\t\tatomic_dec(&t->hash_tids_in_use);\n\t\t} else {\n\t\t\tif (family == AF_INET6)\n\t\t\t\tatomic_sub(2, &t->tids_in_use);\n\t\t\telse\n\t\t\t\tatomic_dec(&t->tids_in_use);\n\t\t}\n\t}\n\n\tskb = alloc_skb(sizeof(struct cpl_tid_release), GFP_ATOMIC);\n\tif (likely(skb)) {\n\t\tmk_tid_release(skb, chan, tid);\n\t\tt4_ofld_send(adap, skb);\n\t} else\n\t\tcxgb4_queue_tid_release(t, chan, tid);\n}\nEXPORT_SYMBOL(cxgb4_remove_tid);\n\n \nstatic int tid_init(struct tid_info *t)\n{\n\tstruct adapter *adap = container_of(t, struct adapter, tids);\n\tunsigned int max_ftids = t->nftids + t->nsftids;\n\tunsigned int natids = t->natids;\n\tunsigned int hpftid_bmap_size;\n\tunsigned int eotid_bmap_size;\n\tunsigned int stid_bmap_size;\n\tunsigned int ftid_bmap_size;\n\tsize_t size;\n\n\tstid_bmap_size = BITS_TO_LONGS(t->nstids + t->nsftids);\n\tftid_bmap_size = BITS_TO_LONGS(t->nftids);\n\thpftid_bmap_size = BITS_TO_LONGS(t->nhpftids);\n\teotid_bmap_size = BITS_TO_LONGS(t->neotids);\n\tsize = t->ntids * sizeof(*t->tid_tab) +\n\t       natids * sizeof(*t->atid_tab) +\n\t       t->nstids * sizeof(*t->stid_tab) +\n\t       t->nsftids * sizeof(*t->stid_tab) +\n\t       stid_bmap_size * sizeof(long) +\n\t       t->nhpftids * sizeof(*t->hpftid_tab) +\n\t       hpftid_bmap_size * sizeof(long) +\n\t       max_ftids * sizeof(*t->ftid_tab) +\n\t       ftid_bmap_size * sizeof(long) +\n\t       t->neotids * sizeof(*t->eotid_tab) +\n\t       eotid_bmap_size * sizeof(long);\n\n\tt->tid_tab = kvzalloc(size, GFP_KERNEL);\n\tif (!t->tid_tab)\n\t\treturn -ENOMEM;\n\n\tt->atid_tab = (union aopen_entry *)&t->tid_tab[t->ntids];\n\tt->stid_tab = (struct serv_entry *)&t->atid_tab[natids];\n\tt->stid_bmap = (unsigned long *)&t->stid_tab[t->nstids + t->nsftids];\n\tt->hpftid_tab = (struct filter_entry *)&t->stid_bmap[stid_bmap_size];\n\tt->hpftid_bmap = (unsigned long *)&t->hpftid_tab[t->nhpftids];\n\tt->ftid_tab = (struct filter_entry *)&t->hpftid_bmap[hpftid_bmap_size];\n\tt->ftid_bmap = (unsigned long *)&t->ftid_tab[max_ftids];\n\tt->eotid_tab = (struct eotid_entry *)&t->ftid_bmap[ftid_bmap_size];\n\tt->eotid_bmap = (unsigned long *)&t->eotid_tab[t->neotids];\n\tspin_lock_init(&t->stid_lock);\n\tspin_lock_init(&t->atid_lock);\n\tspin_lock_init(&t->ftid_lock);\n\n\tt->stids_in_use = 0;\n\tt->v6_stids_in_use = 0;\n\tt->sftids_in_use = 0;\n\tt->afree = NULL;\n\tt->atids_in_use = 0;\n\tatomic_set(&t->tids_in_use, 0);\n\tatomic_set(&t->conns_in_use, 0);\n\tatomic_set(&t->hash_tids_in_use, 0);\n\tatomic_set(&t->eotids_in_use, 0);\n\n\t \n\tif (natids) {\n\t\twhile (--natids)\n\t\t\tt->atid_tab[natids - 1].next = &t->atid_tab[natids];\n\t\tt->afree = t->atid_tab;\n\t}\n\n\tif (is_offload(adap)) {\n\t\tbitmap_zero(t->stid_bmap, t->nstids + t->nsftids);\n\t\t \n\t\tif (!t->stid_base &&\n\t\t    CHELSIO_CHIP_VERSION(adap->params.chip) <= CHELSIO_T5)\n\t\t\t__set_bit(0, t->stid_bmap);\n\n\t\tif (t->neotids)\n\t\t\tbitmap_zero(t->eotid_bmap, t->neotids);\n\t}\n\n\tif (t->nhpftids)\n\t\tbitmap_zero(t->hpftid_bmap, t->nhpftids);\n\tbitmap_zero(t->ftid_bmap, t->nftids);\n\treturn 0;\n}\n\n \nint cxgb4_create_server(const struct net_device *dev, unsigned int stid,\n\t\t\t__be32 sip, __be16 sport, __be16 vlan,\n\t\t\tunsigned int queue)\n{\n\tunsigned int chan;\n\tstruct sk_buff *skb;\n\tstruct adapter *adap;\n\tstruct cpl_pass_open_req *req;\n\tint ret;\n\n\tskb = alloc_skb(sizeof(*req), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tadap = netdev2adap(dev);\n\treq = __skb_put(skb, sizeof(*req));\n\tINIT_TP_WR(req, 0);\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_PASS_OPEN_REQ, stid));\n\treq->local_port = sport;\n\treq->peer_port = htons(0);\n\treq->local_ip = sip;\n\treq->peer_ip = htonl(0);\n\tchan = rxq_to_chan(&adap->sge, queue);\n\treq->opt0 = cpu_to_be64(TX_CHAN_V(chan));\n\treq->opt1 = cpu_to_be64(CONN_POLICY_V(CPL_CONN_POLICY_ASK) |\n\t\t\t\tSYN_RSS_ENABLE_F | SYN_RSS_QUEUE_V(queue));\n\tret = t4_mgmt_tx(adap, skb);\n\treturn net_xmit_eval(ret);\n}\nEXPORT_SYMBOL(cxgb4_create_server);\n\n \nint cxgb4_create_server6(const struct net_device *dev, unsigned int stid,\n\t\t\t const struct in6_addr *sip, __be16 sport,\n\t\t\t unsigned int queue)\n{\n\tunsigned int chan;\n\tstruct sk_buff *skb;\n\tstruct adapter *adap;\n\tstruct cpl_pass_open_req6 *req;\n\tint ret;\n\n\tskb = alloc_skb(sizeof(*req), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tadap = netdev2adap(dev);\n\treq = __skb_put(skb, sizeof(*req));\n\tINIT_TP_WR(req, 0);\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_PASS_OPEN_REQ6, stid));\n\treq->local_port = sport;\n\treq->peer_port = htons(0);\n\treq->local_ip_hi = *(__be64 *)(sip->s6_addr);\n\treq->local_ip_lo = *(__be64 *)(sip->s6_addr + 8);\n\treq->peer_ip_hi = cpu_to_be64(0);\n\treq->peer_ip_lo = cpu_to_be64(0);\n\tchan = rxq_to_chan(&adap->sge, queue);\n\treq->opt0 = cpu_to_be64(TX_CHAN_V(chan));\n\treq->opt1 = cpu_to_be64(CONN_POLICY_V(CPL_CONN_POLICY_ASK) |\n\t\t\t\tSYN_RSS_ENABLE_F | SYN_RSS_QUEUE_V(queue));\n\tret = t4_mgmt_tx(adap, skb);\n\treturn net_xmit_eval(ret);\n}\nEXPORT_SYMBOL(cxgb4_create_server6);\n\nint cxgb4_remove_server(const struct net_device *dev, unsigned int stid,\n\t\t\tunsigned int queue, bool ipv6)\n{\n\tstruct sk_buff *skb;\n\tstruct adapter *adap;\n\tstruct cpl_close_listsvr_req *req;\n\tint ret;\n\n\tadap = netdev2adap(dev);\n\n\tskb = alloc_skb(sizeof(*req), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treq = __skb_put(skb, sizeof(*req));\n\tINIT_TP_WR(req, 0);\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_CLOSE_LISTSRV_REQ, stid));\n\treq->reply_ctrl = htons(NO_REPLY_V(0) | (ipv6 ? LISTSVR_IPV6_V(1) :\n\t\t\t\tLISTSVR_IPV6_V(0)) | QUEUENO_V(queue));\n\tret = t4_mgmt_tx(adap, skb);\n\treturn net_xmit_eval(ret);\n}\nEXPORT_SYMBOL(cxgb4_remove_server);\n\n \nunsigned int cxgb4_best_mtu(const unsigned short *mtus, unsigned short mtu,\n\t\t\t    unsigned int *idx)\n{\n\tunsigned int i = 0;\n\n\twhile (i < NMTUS - 1 && mtus[i + 1] <= mtu)\n\t\t++i;\n\tif (idx)\n\t\t*idx = i;\n\treturn mtus[i];\n}\nEXPORT_SYMBOL(cxgb4_best_mtu);\n\n \nunsigned int cxgb4_best_aligned_mtu(const unsigned short *mtus,\n\t\t\t\t    unsigned short header_size,\n\t\t\t\t    unsigned short data_size_max,\n\t\t\t\t    unsigned short data_size_align,\n\t\t\t\t    unsigned int *mtu_idxp)\n{\n\tunsigned short max_mtu = header_size + data_size_max;\n\tunsigned short data_size_align_mask = data_size_align - 1;\n\tint mtu_idx, aligned_mtu_idx;\n\n\t \n\tfor (mtu_idx = 0, aligned_mtu_idx = -1; mtu_idx < NMTUS; mtu_idx++) {\n\t\tunsigned short data_size = mtus[mtu_idx] - header_size;\n\n\t\t \n\t\tif ((data_size & data_size_align_mask) == 0)\n\t\t\taligned_mtu_idx = mtu_idx;\n\n\t\t \n\t\tif (mtu_idx+1 < NMTUS && mtus[mtu_idx+1] > max_mtu)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (mtu_idx == NMTUS)\n\t\tmtu_idx--;\n\n\t \n\tif (aligned_mtu_idx >= 0 &&\n\t    mtu_idx - aligned_mtu_idx <= 1)\n\t\tmtu_idx = aligned_mtu_idx;\n\n\t \n\tif (mtu_idxp)\n\t\t*mtu_idxp = mtu_idx;\n\treturn mtus[mtu_idx];\n}\nEXPORT_SYMBOL(cxgb4_best_aligned_mtu);\n\n \nunsigned int cxgb4_port_chan(const struct net_device *dev)\n{\n\treturn netdev2pinfo(dev)->tx_chan;\n}\nEXPORT_SYMBOL(cxgb4_port_chan);\n\n \nunsigned int cxgb4_port_e2cchan(const struct net_device *dev)\n{\n\treturn netdev2pinfo(dev)->rx_cchan;\n}\nEXPORT_SYMBOL(cxgb4_port_e2cchan);\n\nunsigned int cxgb4_dbfifo_count(const struct net_device *dev, int lpfifo)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\tu32 v1, v2, lp_count, hp_count;\n\n\tv1 = t4_read_reg(adap, SGE_DBFIFO_STATUS_A);\n\tv2 = t4_read_reg(adap, SGE_DBFIFO_STATUS2_A);\n\tif (is_t4(adap->params.chip)) {\n\t\tlp_count = LP_COUNT_G(v1);\n\t\thp_count = HP_COUNT_G(v1);\n\t} else {\n\t\tlp_count = LP_COUNT_T5_G(v1);\n\t\thp_count = HP_COUNT_T5_G(v2);\n\t}\n\treturn lpfifo ? lp_count : hp_count;\n}\nEXPORT_SYMBOL(cxgb4_dbfifo_count);\n\n \nunsigned int cxgb4_port_viid(const struct net_device *dev)\n{\n\treturn netdev2pinfo(dev)->viid;\n}\nEXPORT_SYMBOL(cxgb4_port_viid);\n\n \nunsigned int cxgb4_port_idx(const struct net_device *dev)\n{\n\treturn netdev2pinfo(dev)->port_id;\n}\nEXPORT_SYMBOL(cxgb4_port_idx);\n\nvoid cxgb4_get_tcp_stats(struct pci_dev *pdev, struct tp_tcp_stats *v4,\n\t\t\t struct tp_tcp_stats *v6)\n{\n\tstruct adapter *adap = pci_get_drvdata(pdev);\n\n\tspin_lock(&adap->stats_lock);\n\tt4_tp_get_tcp_stats(adap, v4, v6, false);\n\tspin_unlock(&adap->stats_lock);\n}\nEXPORT_SYMBOL(cxgb4_get_tcp_stats);\n\nvoid cxgb4_iscsi_init(struct net_device *dev, unsigned int tag_mask,\n\t\t      const unsigned int *pgsz_order)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tt4_write_reg(adap, ULP_RX_ISCSI_TAGMASK_A, tag_mask);\n\tt4_write_reg(adap, ULP_RX_ISCSI_PSZ_A, HPZ0_V(pgsz_order[0]) |\n\t\t     HPZ1_V(pgsz_order[1]) | HPZ2_V(pgsz_order[2]) |\n\t\t     HPZ3_V(pgsz_order[3]));\n}\nEXPORT_SYMBOL(cxgb4_iscsi_init);\n\nint cxgb4_flush_eq_cache(struct net_device *dev)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\n\treturn t4_sge_ctxt_flush(adap, adap->mbox, CTXT_EGRESS);\n}\nEXPORT_SYMBOL(cxgb4_flush_eq_cache);\n\nstatic int read_eq_indices(struct adapter *adap, u16 qid, u16 *pidx, u16 *cidx)\n{\n\tu32 addr = t4_read_reg(adap, SGE_DBQ_CTXT_BADDR_A) + 24 * qid + 8;\n\t__be64 indices;\n\tint ret;\n\n\tspin_lock(&adap->win0_lock);\n\tret = t4_memory_rw(adap, 0, MEM_EDC0, addr,\n\t\t\t   sizeof(indices), (__be32 *)&indices,\n\t\t\t   T4_MEMORY_READ);\n\tspin_unlock(&adap->win0_lock);\n\tif (!ret) {\n\t\t*cidx = (be64_to_cpu(indices) >> 25) & 0xffff;\n\t\t*pidx = (be64_to_cpu(indices) >> 9) & 0xffff;\n\t}\n\treturn ret;\n}\n\nint cxgb4_sync_txq_pidx(struct net_device *dev, u16 qid, u16 pidx,\n\t\t\tu16 size)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\tu16 hw_pidx, hw_cidx;\n\tint ret;\n\n\tret = read_eq_indices(adap, qid, &hw_pidx, &hw_cidx);\n\tif (ret)\n\t\tgoto out;\n\n\tif (pidx != hw_pidx) {\n\t\tu16 delta;\n\t\tu32 val;\n\n\t\tif (pidx >= hw_pidx)\n\t\t\tdelta = pidx - hw_pidx;\n\t\telse\n\t\t\tdelta = size - hw_pidx + pidx;\n\n\t\tif (is_t4(adap->params.chip))\n\t\t\tval = PIDX_V(delta);\n\t\telse\n\t\t\tval = PIDX_T5_V(delta);\n\t\twmb();\n\t\tt4_write_reg(adap, MYPF_REG(SGE_PF_KDOORBELL_A),\n\t\t\t     QID_V(qid) | val);\n\t}\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(cxgb4_sync_txq_pidx);\n\nint cxgb4_read_tpte(struct net_device *dev, u32 stag, __be32 *tpte)\n{\n\tu32 edc0_size, edc1_size, mc0_size, mc1_size, size;\n\tu32 edc0_end, edc1_end, mc0_end, mc1_end;\n\tu32 offset, memtype, memaddr;\n\tstruct adapter *adap;\n\tu32 hma_size = 0;\n\tint ret;\n\n\tadap = netdev2adap(dev);\n\n\toffset = ((stag >> 8) * 32) + adap->vres.stag.start;\n\n\t \n\tsize = t4_read_reg(adap, MA_EDRAM0_BAR_A);\n\tedc0_size = EDRAM0_SIZE_G(size) << 20;\n\tsize = t4_read_reg(adap, MA_EDRAM1_BAR_A);\n\tedc1_size = EDRAM1_SIZE_G(size) << 20;\n\tsize = t4_read_reg(adap, MA_EXT_MEMORY0_BAR_A);\n\tmc0_size = EXT_MEM0_SIZE_G(size) << 20;\n\n\tif (t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A) & HMA_MUX_F) {\n\t\tsize = t4_read_reg(adap, MA_EXT_MEMORY1_BAR_A);\n\t\thma_size = EXT_MEM1_SIZE_G(size) << 20;\n\t}\n\tedc0_end = edc0_size;\n\tedc1_end = edc0_end + edc1_size;\n\tmc0_end = edc1_end + mc0_size;\n\n\tif (offset < edc0_end) {\n\t\tmemtype = MEM_EDC0;\n\t\tmemaddr = offset;\n\t} else if (offset < edc1_end) {\n\t\tmemtype = MEM_EDC1;\n\t\tmemaddr = offset - edc0_end;\n\t} else {\n\t\tif (hma_size && (offset < (edc1_end + hma_size))) {\n\t\t\tmemtype = MEM_HMA;\n\t\t\tmemaddr = offset - edc1_end;\n\t\t} else if (offset < mc0_end) {\n\t\t\tmemtype = MEM_MC0;\n\t\t\tmemaddr = offset - edc1_end;\n\t\t} else if (is_t5(adap->params.chip)) {\n\t\t\tsize = t4_read_reg(adap, MA_EXT_MEMORY1_BAR_A);\n\t\t\tmc1_size = EXT_MEM1_SIZE_G(size) << 20;\n\t\t\tmc1_end = mc0_end + mc1_size;\n\t\t\tif (offset < mc1_end) {\n\t\t\t\tmemtype = MEM_MC1;\n\t\t\t\tmemaddr = offset - mc0_end;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tspin_lock(&adap->win0_lock);\n\tret = t4_memory_rw(adap, 0, memtype, memaddr, 32, tpte, T4_MEMORY_READ);\n\tspin_unlock(&adap->win0_lock);\n\treturn ret;\n\nerr:\n\tdev_err(adap->pdev_dev, \"stag %#x, offset %#x out of range\\n\",\n\t\tstag, offset);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(cxgb4_read_tpte);\n\nu64 cxgb4_read_sge_timestamp(struct net_device *dev)\n{\n\tu32 hi, lo;\n\tstruct adapter *adap;\n\n\tadap = netdev2adap(dev);\n\tlo = t4_read_reg(adap, SGE_TIMESTAMP_LO_A);\n\thi = TSVAL_G(t4_read_reg(adap, SGE_TIMESTAMP_HI_A));\n\n\treturn ((u64)hi << 32) | (u64)lo;\n}\nEXPORT_SYMBOL(cxgb4_read_sge_timestamp);\n\nint cxgb4_bar2_sge_qregs(struct net_device *dev,\n\t\t\t unsigned int qid,\n\t\t\t enum cxgb4_bar2_qtype qtype,\n\t\t\t int user,\n\t\t\t u64 *pbar2_qoffset,\n\t\t\t unsigned int *pbar2_qid)\n{\n\treturn t4_bar2_sge_qregs(netdev2adap(dev),\n\t\t\t\t qid,\n\t\t\t\t (qtype == CXGB4_BAR2_QTYPE_EGRESS\n\t\t\t\t  ? T4_BAR2_QTYPE_EGRESS\n\t\t\t\t  : T4_BAR2_QTYPE_INGRESS),\n\t\t\t\t user,\n\t\t\t\t pbar2_qoffset,\n\t\t\t\t pbar2_qid);\n}\nEXPORT_SYMBOL(cxgb4_bar2_sge_qregs);\n\nstatic struct pci_driver cxgb4_driver;\n\nstatic void check_neigh_update(struct neighbour *neigh)\n{\n\tconst struct device *parent;\n\tconst struct net_device *netdev = neigh->dev;\n\n\tif (is_vlan_dev(netdev))\n\t\tnetdev = vlan_dev_real_dev(netdev);\n\tparent = netdev->dev.parent;\n\tif (parent && parent->driver == &cxgb4_driver.driver)\n\t\tt4_l2t_update(dev_get_drvdata(parent), neigh);\n}\n\nstatic int netevent_cb(struct notifier_block *nb, unsigned long event,\n\t\t       void *data)\n{\n\tswitch (event) {\n\tcase NETEVENT_NEIGH_UPDATE:\n\t\tcheck_neigh_update(data);\n\t\tbreak;\n\tcase NETEVENT_REDIRECT:\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic bool netevent_registered;\nstatic struct notifier_block cxgb4_netevent_nb = {\n\t.notifier_call = netevent_cb\n};\n\nstatic void drain_db_fifo(struct adapter *adap, int usecs)\n{\n\tu32 v1, v2, lp_count, hp_count;\n\n\tdo {\n\t\tv1 = t4_read_reg(adap, SGE_DBFIFO_STATUS_A);\n\t\tv2 = t4_read_reg(adap, SGE_DBFIFO_STATUS2_A);\n\t\tif (is_t4(adap->params.chip)) {\n\t\t\tlp_count = LP_COUNT_G(v1);\n\t\t\thp_count = HP_COUNT_G(v1);\n\t\t} else {\n\t\t\tlp_count = LP_COUNT_T5_G(v1);\n\t\t\thp_count = HP_COUNT_T5_G(v2);\n\t\t}\n\n\t\tif (lp_count == 0 && hp_count == 0)\n\t\t\tbreak;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(usecs_to_jiffies(usecs));\n\t} while (1);\n}\n\nstatic void disable_txq_db(struct sge_txq *q)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&q->db_lock, flags);\n\tq->db_disabled = 1;\n\tspin_unlock_irqrestore(&q->db_lock, flags);\n}\n\nstatic void enable_txq_db(struct adapter *adap, struct sge_txq *q)\n{\n\tspin_lock_irq(&q->db_lock);\n\tif (q->db_pidx_inc) {\n\t\t \n\t\twmb();\n\t\tt4_write_reg(adap, MYPF_REG(SGE_PF_KDOORBELL_A),\n\t\t\t     QID_V(q->cntxt_id) | PIDX_V(q->db_pidx_inc));\n\t\tq->db_pidx_inc = 0;\n\t}\n\tq->db_disabled = 0;\n\tspin_unlock_irq(&q->db_lock);\n}\n\nstatic void disable_dbs(struct adapter *adap)\n{\n\tint i;\n\n\tfor_each_ethrxq(&adap->sge, i)\n\t\tdisable_txq_db(&adap->sge.ethtxq[i].q);\n\tif (is_offload(adap)) {\n\t\tstruct sge_uld_txq_info *txq_info =\n\t\t\tadap->sge.uld_txq_info[CXGB4_TX_OFLD];\n\n\t\tif (txq_info) {\n\t\t\tfor_each_ofldtxq(&adap->sge, i) {\n\t\t\t\tstruct sge_uld_txq *txq = &txq_info->uldtxq[i];\n\n\t\t\t\tdisable_txq_db(&txq->q);\n\t\t\t}\n\t\t}\n\t}\n\tfor_each_port(adap, i)\n\t\tdisable_txq_db(&adap->sge.ctrlq[i].q);\n}\n\nstatic void enable_dbs(struct adapter *adap)\n{\n\tint i;\n\n\tfor_each_ethrxq(&adap->sge, i)\n\t\tenable_txq_db(adap, &adap->sge.ethtxq[i].q);\n\tif (is_offload(adap)) {\n\t\tstruct sge_uld_txq_info *txq_info =\n\t\t\tadap->sge.uld_txq_info[CXGB4_TX_OFLD];\n\n\t\tif (txq_info) {\n\t\t\tfor_each_ofldtxq(&adap->sge, i) {\n\t\t\t\tstruct sge_uld_txq *txq = &txq_info->uldtxq[i];\n\n\t\t\t\tenable_txq_db(adap, &txq->q);\n\t\t\t}\n\t\t}\n\t}\n\tfor_each_port(adap, i)\n\t\tenable_txq_db(adap, &adap->sge.ctrlq[i].q);\n}\n\nstatic void notify_rdma_uld(struct adapter *adap, enum cxgb4_control cmd)\n{\n\tenum cxgb4_uld type = CXGB4_ULD_RDMA;\n\n\tif (adap->uld && adap->uld[type].handle)\n\t\tadap->uld[type].control(adap->uld[type].handle, cmd);\n}\n\nstatic void process_db_full(struct work_struct *work)\n{\n\tstruct adapter *adap;\n\n\tadap = container_of(work, struct adapter, db_full_task);\n\n\tdrain_db_fifo(adap, dbfifo_drain_delay);\n\tenable_dbs(adap);\n\tnotify_rdma_uld(adap, CXGB4_CONTROL_DB_EMPTY);\n\tif (CHELSIO_CHIP_VERSION(adap->params.chip) <= CHELSIO_T5)\n\t\tt4_set_reg_field(adap, SGE_INT_ENABLE3_A,\n\t\t\t\t DBFIFO_HP_INT_F | DBFIFO_LP_INT_F,\n\t\t\t\t DBFIFO_HP_INT_F | DBFIFO_LP_INT_F);\n\telse\n\t\tt4_set_reg_field(adap, SGE_INT_ENABLE3_A,\n\t\t\t\t DBFIFO_LP_INT_F, DBFIFO_LP_INT_F);\n}\n\nstatic void sync_txq_pidx(struct adapter *adap, struct sge_txq *q)\n{\n\tu16 hw_pidx, hw_cidx;\n\tint ret;\n\n\tspin_lock_irq(&q->db_lock);\n\tret = read_eq_indices(adap, (u16)q->cntxt_id, &hw_pidx, &hw_cidx);\n\tif (ret)\n\t\tgoto out;\n\tif (q->db_pidx != hw_pidx) {\n\t\tu16 delta;\n\t\tu32 val;\n\n\t\tif (q->db_pidx >= hw_pidx)\n\t\t\tdelta = q->db_pidx - hw_pidx;\n\t\telse\n\t\t\tdelta = q->size - hw_pidx + q->db_pidx;\n\n\t\tif (is_t4(adap->params.chip))\n\t\t\tval = PIDX_V(delta);\n\t\telse\n\t\t\tval = PIDX_T5_V(delta);\n\t\twmb();\n\t\tt4_write_reg(adap, MYPF_REG(SGE_PF_KDOORBELL_A),\n\t\t\t     QID_V(q->cntxt_id) | val);\n\t}\nout:\n\tq->db_disabled = 0;\n\tq->db_pidx_inc = 0;\n\tspin_unlock_irq(&q->db_lock);\n\tif (ret)\n\t\tCH_WARN(adap, \"DB drop recovery failed.\\n\");\n}\n\nstatic void recover_all_queues(struct adapter *adap)\n{\n\tint i;\n\n\tfor_each_ethrxq(&adap->sge, i)\n\t\tsync_txq_pidx(adap, &adap->sge.ethtxq[i].q);\n\tif (is_offload(adap)) {\n\t\tstruct sge_uld_txq_info *txq_info =\n\t\t\tadap->sge.uld_txq_info[CXGB4_TX_OFLD];\n\t\tif (txq_info) {\n\t\t\tfor_each_ofldtxq(&adap->sge, i) {\n\t\t\t\tstruct sge_uld_txq *txq = &txq_info->uldtxq[i];\n\n\t\t\t\tsync_txq_pidx(adap, &txq->q);\n\t\t\t}\n\t\t}\n\t}\n\tfor_each_port(adap, i)\n\t\tsync_txq_pidx(adap, &adap->sge.ctrlq[i].q);\n}\n\nstatic void process_db_drop(struct work_struct *work)\n{\n\tstruct adapter *adap;\n\n\tadap = container_of(work, struct adapter, db_drop_task);\n\n\tif (is_t4(adap->params.chip)) {\n\t\tdrain_db_fifo(adap, dbfifo_drain_delay);\n\t\tnotify_rdma_uld(adap, CXGB4_CONTROL_DB_DROP);\n\t\tdrain_db_fifo(adap, dbfifo_drain_delay);\n\t\trecover_all_queues(adap);\n\t\tdrain_db_fifo(adap, dbfifo_drain_delay);\n\t\tenable_dbs(adap);\n\t\tnotify_rdma_uld(adap, CXGB4_CONTROL_DB_EMPTY);\n\t} else if (is_t5(adap->params.chip)) {\n\t\tu32 dropped_db = t4_read_reg(adap, 0x010ac);\n\t\tu16 qid = (dropped_db >> 15) & 0x1ffff;\n\t\tu16 pidx_inc = dropped_db & 0x1fff;\n\t\tu64 bar2_qoffset;\n\t\tunsigned int bar2_qid;\n\t\tint ret;\n\n\t\tret = t4_bar2_sge_qregs(adap, qid, T4_BAR2_QTYPE_EGRESS,\n\t\t\t\t\t0, &bar2_qoffset, &bar2_qid);\n\t\tif (ret)\n\t\t\tdev_err(adap->pdev_dev, \"doorbell drop recovery: \"\n\t\t\t\t\"qid=%d, pidx_inc=%d\\n\", qid, pidx_inc);\n\t\telse\n\t\t\twritel(PIDX_T5_V(pidx_inc) | QID_V(bar2_qid),\n\t\t\t       adap->bar2 + bar2_qoffset + SGE_UDB_KDOORBELL);\n\n\t\t \n\t\tt4_set_reg_field(adap, 0x10b0, 1<<15, 1<<15);\n\t}\n\n\tif (CHELSIO_CHIP_VERSION(adap->params.chip) <= CHELSIO_T5)\n\t\tt4_set_reg_field(adap, SGE_DOORBELL_CONTROL_A, DROPPED_DB_F, 0);\n}\n\nvoid t4_db_full(struct adapter *adap)\n{\n\tif (is_t4(adap->params.chip)) {\n\t\tdisable_dbs(adap);\n\t\tnotify_rdma_uld(adap, CXGB4_CONTROL_DB_FULL);\n\t\tt4_set_reg_field(adap, SGE_INT_ENABLE3_A,\n\t\t\t\t DBFIFO_HP_INT_F | DBFIFO_LP_INT_F, 0);\n\t\tqueue_work(adap->workq, &adap->db_full_task);\n\t}\n}\n\nvoid t4_db_dropped(struct adapter *adap)\n{\n\tif (is_t4(adap->params.chip)) {\n\t\tdisable_dbs(adap);\n\t\tnotify_rdma_uld(adap, CXGB4_CONTROL_DB_FULL);\n\t}\n\tqueue_work(adap->workq, &adap->db_drop_task);\n}\n\nvoid t4_register_netevent_notifier(void)\n{\n\tif (!netevent_registered) {\n\t\tregister_netevent_notifier(&cxgb4_netevent_nb);\n\t\tnetevent_registered = true;\n\t}\n}\n\nstatic void detach_ulds(struct adapter *adap)\n{\n\tunsigned int i;\n\n\tif (!is_uld(adap))\n\t\treturn;\n\n\tmutex_lock(&uld_mutex);\n\tlist_del(&adap->list_node);\n\n\tfor (i = 0; i < CXGB4_ULD_MAX; i++)\n\t\tif (adap->uld && adap->uld[i].handle)\n\t\t\tadap->uld[i].state_change(adap->uld[i].handle,\n\t\t\t\t\t     CXGB4_STATE_DETACH);\n\n\tif (netevent_registered && list_empty(&adapter_list)) {\n\t\tunregister_netevent_notifier(&cxgb4_netevent_nb);\n\t\tnetevent_registered = false;\n\t}\n\tmutex_unlock(&uld_mutex);\n}\n\nstatic void notify_ulds(struct adapter *adap, enum cxgb4_state new_state)\n{\n\tunsigned int i;\n\n\tmutex_lock(&uld_mutex);\n\tfor (i = 0; i < CXGB4_ULD_MAX; i++)\n\t\tif (adap->uld && adap->uld[i].handle)\n\t\t\tadap->uld[i].state_change(adap->uld[i].handle,\n\t\t\t\t\t\t  new_state);\n\tmutex_unlock(&uld_mutex);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int cxgb4_inet6addr_handler(struct notifier_block *this,\n\t\t\t\t   unsigned long event, void *data)\n{\n\tstruct inet6_ifaddr *ifa = data;\n\tstruct net_device *event_dev = ifa->idev->dev;\n\tconst struct device *parent = NULL;\n#if IS_ENABLED(CONFIG_BONDING)\n\tstruct adapter *adap;\n#endif\n\tif (is_vlan_dev(event_dev))\n\t\tevent_dev = vlan_dev_real_dev(event_dev);\n#if IS_ENABLED(CONFIG_BONDING)\n\tif (event_dev->flags & IFF_MASTER) {\n\t\tlist_for_each_entry(adap, &adapter_list, list_node) {\n\t\t\tswitch (event) {\n\t\t\tcase NETDEV_UP:\n\t\t\t\tcxgb4_clip_get(adap->port[0],\n\t\t\t\t\t       (const u32 *)ifa, 1);\n\t\t\t\tbreak;\n\t\t\tcase NETDEV_DOWN:\n\t\t\t\tcxgb4_clip_release(adap->port[0],\n\t\t\t\t\t\t   (const u32 *)ifa, 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn NOTIFY_OK;\n\t}\n#endif\n\n\tif (event_dev)\n\t\tparent = event_dev->dev.parent;\n\n\tif (parent && parent->driver == &cxgb4_driver.driver) {\n\t\tswitch (event) {\n\t\tcase NETDEV_UP:\n\t\t\tcxgb4_clip_get(event_dev, (const u32 *)ifa, 1);\n\t\t\tbreak;\n\t\tcase NETDEV_DOWN:\n\t\t\tcxgb4_clip_release(event_dev, (const u32 *)ifa, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic bool inet6addr_registered;\nstatic struct notifier_block cxgb4_inet6addr_notifier = {\n\t.notifier_call = cxgb4_inet6addr_handler\n};\n\nstatic void update_clip(const struct adapter *adap)\n{\n\tint i;\n\tstruct net_device *dev;\n\tint ret;\n\n\trcu_read_lock();\n\n\tfor (i = 0; i < MAX_NPORTS; i++) {\n\t\tdev = adap->port[i];\n\t\tret = 0;\n\n\t\tif (dev)\n\t\t\tret = cxgb4_update_root_dev_clip(dev);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}\n#endif  \n\n \nstatic int cxgb_up(struct adapter *adap)\n{\n\tstruct sge *s = &adap->sge;\n\tint err;\n\n\tmutex_lock(&uld_mutex);\n\terr = setup_sge_queues(adap);\n\tif (err)\n\t\tgoto rel_lock;\n\terr = setup_rss(adap);\n\tif (err)\n\t\tgoto freeq;\n\n\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\tif (s->nd_msix_idx < 0) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto irq_err;\n\t\t}\n\n\t\terr = request_irq(adap->msix_info[s->nd_msix_idx].vec,\n\t\t\t\t  t4_nondata_intr, 0,\n\t\t\t\t  adap->msix_info[s->nd_msix_idx].desc, adap);\n\t\tif (err)\n\t\t\tgoto irq_err;\n\n\t\terr = request_msix_queue_irqs(adap);\n\t\tif (err)\n\t\t\tgoto irq_err_free_nd_msix;\n\t} else {\n\t\terr = request_irq(adap->pdev->irq, t4_intr_handler(adap),\n\t\t\t\t  (adap->flags & CXGB4_USING_MSI) ? 0\n\t\t\t\t\t\t\t\t  : IRQF_SHARED,\n\t\t\t\t  adap->port[0]->name, adap);\n\t\tif (err)\n\t\t\tgoto irq_err;\n\t}\n\n\tenable_rx(adap);\n\tt4_sge_start(adap);\n\tt4_intr_enable(adap);\n\tadap->flags |= CXGB4_FULL_INIT_DONE;\n\tmutex_unlock(&uld_mutex);\n\n\tnotify_ulds(adap, CXGB4_STATE_UP);\n#if IS_ENABLED(CONFIG_IPV6)\n\tupdate_clip(adap);\n#endif\n\treturn err;\n\nirq_err_free_nd_msix:\n\tfree_irq(adap->msix_info[s->nd_msix_idx].vec, adap);\nirq_err:\n\tdev_err(adap->pdev_dev, \"request_irq failed, err %d\\n\", err);\nfreeq:\n\tt4_free_sge_resources(adap);\nrel_lock:\n\tmutex_unlock(&uld_mutex);\n\treturn err;\n}\n\nstatic void cxgb_down(struct adapter *adapter)\n{\n\tcancel_work_sync(&adapter->tid_release_task);\n\tcancel_work_sync(&adapter->db_full_task);\n\tcancel_work_sync(&adapter->db_drop_task);\n\tadapter->tid_release_task_busy = false;\n\tadapter->tid_release_head = NULL;\n\n\tt4_sge_stop(adapter);\n\tt4_free_sge_resources(adapter);\n\n\tadapter->flags &= ~CXGB4_FULL_INIT_DONE;\n}\n\n \nstatic int cxgb_open(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tint err;\n\n\tnetif_carrier_off(dev);\n\n\tif (!(adapter->flags & CXGB4_FULL_INIT_DONE)) {\n\t\terr = cxgb_up(adapter);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = t4_update_port_info(pi);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = link_start(dev);\n\tif (err)\n\t\treturn err;\n\n\tif (pi->nmirrorqsets) {\n\t\tmutex_lock(&pi->vi_mirror_mutex);\n\t\terr = cxgb4_port_mirror_alloc_queues(dev);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\terr = cxgb4_port_mirror_start(dev);\n\t\tif (err)\n\t\t\tgoto out_free_queues;\n\t\tmutex_unlock(&pi->vi_mirror_mutex);\n\t}\n\n\tnetif_tx_start_all_queues(dev);\n\treturn 0;\n\nout_free_queues:\n\tcxgb4_port_mirror_free_queues(dev);\n\nout_unlock:\n\tmutex_unlock(&pi->vi_mirror_mutex);\n\treturn err;\n}\n\nstatic int cxgb_close(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tint ret;\n\n\tnetif_tx_stop_all_queues(dev);\n\tnetif_carrier_off(dev);\n\tret = t4_enable_pi_params(adapter, adapter->pf, pi,\n\t\t\t\t  false, false, false);\n#ifdef CONFIG_CHELSIO_T4_DCB\n\tcxgb4_dcb_reset(dev);\n\tdcb_tx_queue_prio_enable(dev, false);\n#endif\n\tif (ret)\n\t\treturn ret;\n\n\tif (pi->nmirrorqsets) {\n\t\tmutex_lock(&pi->vi_mirror_mutex);\n\t\tcxgb4_port_mirror_stop(dev);\n\t\tcxgb4_port_mirror_free_queues(dev);\n\t\tmutex_unlock(&pi->vi_mirror_mutex);\n\t}\n\n\treturn 0;\n}\n\nint cxgb4_create_server_filter(const struct net_device *dev, unsigned int stid,\n\t\t__be32 sip, __be16 sport, __be16 vlan,\n\t\tunsigned int queue, unsigned char port, unsigned char mask)\n{\n\tint ret;\n\tstruct filter_entry *f;\n\tstruct adapter *adap;\n\tint i;\n\tu8 *val;\n\n\tadap = netdev2adap(dev);\n\n\t \n\tstid -= adap->tids.sftid_base;\n\tstid += adap->tids.nftids;\n\n\t \n\tf = &adap->tids.ftid_tab[stid];\n\tret = writable_filter(f);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (f->valid)\n\t\tclear_filter(adap, f);\n\n\t \n\tmemset(&f->fs, 0, sizeof(struct ch_filter_specification));\n\tf->fs.val.lport = be16_to_cpu(sport);\n\tf->fs.mask.lport  = ~0;\n\tval = (u8 *)&sip;\n\tif ((val[0] | val[1] | val[2] | val[3]) != 0) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tf->fs.val.lip[i] = val[i];\n\t\t\tf->fs.mask.lip[i] = ~0;\n\t\t}\n\t\tif (adap->params.tp.vlan_pri_map & PORT_F) {\n\t\t\tf->fs.val.iport = port;\n\t\t\tf->fs.mask.iport = mask;\n\t\t}\n\t}\n\n\tif (adap->params.tp.vlan_pri_map & PROTOCOL_F) {\n\t\tf->fs.val.proto = IPPROTO_TCP;\n\t\tf->fs.mask.proto = ~0;\n\t}\n\n\tf->fs.dirsteer = 1;\n\tf->fs.iq = queue;\n\t \n\tf->locked = 1;\n\tf->fs.rpttid = 1;\n\n\t \n\tf->tid = stid + adap->tids.ftid_base;\n\tret = set_filter_wr(adap, stid);\n\tif (ret) {\n\t\tclear_filter(adap, f);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cxgb4_create_server_filter);\n\nint cxgb4_remove_server_filter(const struct net_device *dev, unsigned int stid,\n\t\tunsigned int queue, bool ipv6)\n{\n\tstruct filter_entry *f;\n\tstruct adapter *adap;\n\n\tadap = netdev2adap(dev);\n\n\t \n\tstid -= adap->tids.sftid_base;\n\tstid += adap->tids.nftids;\n\n\tf = &adap->tids.ftid_tab[stid];\n\t \n\tf->locked = 0;\n\n\treturn delete_filter(adap, stid);\n}\nEXPORT_SYMBOL(cxgb4_remove_server_filter);\n\nstatic void cxgb_get_stats(struct net_device *dev,\n\t\t\t   struct rtnl_link_stats64 *ns)\n{\n\tstruct port_stats stats;\n\tstruct port_info *p = netdev_priv(dev);\n\tstruct adapter *adapter = p->adapter;\n\n\t \n\tspin_lock(&adapter->stats_lock);\n\tif (!netif_device_present(dev)) {\n\t\tspin_unlock(&adapter->stats_lock);\n\t\treturn;\n\t}\n\tt4_get_port_stats_offset(adapter, p->tx_chan, &stats,\n\t\t\t\t &p->stats_base);\n\tspin_unlock(&adapter->stats_lock);\n\n\tns->tx_bytes   = stats.tx_octets;\n\tns->tx_packets = stats.tx_frames;\n\tns->rx_bytes   = stats.rx_octets;\n\tns->rx_packets = stats.rx_frames;\n\tns->multicast  = stats.rx_mcast_frames;\n\n\t \n\tns->rx_length_errors = stats.rx_jabber + stats.rx_too_long +\n\t\t\t       stats.rx_runt;\n\tns->rx_over_errors   = 0;\n\tns->rx_crc_errors    = stats.rx_fcs_err;\n\tns->rx_frame_errors  = stats.rx_symbol_err;\n\tns->rx_dropped\t     = stats.rx_ovflow0 + stats.rx_ovflow1 +\n\t\t\t       stats.rx_ovflow2 + stats.rx_ovflow3 +\n\t\t\t       stats.rx_trunc0 + stats.rx_trunc1 +\n\t\t\t       stats.rx_trunc2 + stats.rx_trunc3;\n\tns->rx_missed_errors = 0;\n\n\t \n\tns->tx_aborted_errors   = 0;\n\tns->tx_carrier_errors   = 0;\n\tns->tx_fifo_errors      = 0;\n\tns->tx_heartbeat_errors = 0;\n\tns->tx_window_errors    = 0;\n\n\tns->tx_errors = stats.tx_error_frames;\n\tns->rx_errors = stats.rx_symbol_err + stats.rx_fcs_err +\n\t\tns->rx_length_errors + stats.rx_len_err + ns->rx_fifo_errors;\n}\n\nstatic int cxgb_ioctl(struct net_device *dev, struct ifreq *req, int cmd)\n{\n\tunsigned int mbox;\n\tint ret = 0, prtad, devad;\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tstruct mii_ioctl_data *data = (struct mii_ioctl_data *)&req->ifr_data;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tif (pi->mdio_addr < 0)\n\t\t\treturn -EOPNOTSUPP;\n\t\tdata->phy_id = pi->mdio_addr;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\tif (mdio_phy_id_is_c45(data->phy_id)) {\n\t\t\tprtad = mdio_phy_id_prtad(data->phy_id);\n\t\t\tdevad = mdio_phy_id_devad(data->phy_id);\n\t\t} else if (data->phy_id < 32) {\n\t\t\tprtad = data->phy_id;\n\t\t\tdevad = 0;\n\t\t\tdata->reg_num &= 0x1f;\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tmbox = pi->adapter->pf;\n\t\tif (cmd == SIOCGMIIREG)\n\t\t\tret = t4_mdio_rd(pi->adapter, mbox, prtad, devad,\n\t\t\t\t\t data->reg_num, &data->val_out);\n\t\telse\n\t\t\tret = t4_mdio_wr(pi->adapter, mbox, prtad, devad,\n\t\t\t\t\t data->reg_num, data->val_in);\n\t\tbreak;\n\tcase SIOCGHWTSTAMP:\n\t\treturn copy_to_user(req->ifr_data, &pi->tstamp_config,\n\t\t\t\t    sizeof(pi->tstamp_config)) ?\n\t\t\t-EFAULT : 0;\n\tcase SIOCSHWTSTAMP:\n\t\tif (copy_from_user(&pi->tstamp_config, req->ifr_data,\n\t\t\t\t   sizeof(pi->tstamp_config)))\n\t\t\treturn -EFAULT;\n\n\t\tif (!is_t4(adapter->params.chip)) {\n\t\t\tswitch (pi->tstamp_config.tx_type) {\n\t\t\tcase HWTSTAMP_TX_OFF:\n\t\t\tcase HWTSTAMP_TX_ON:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -ERANGE;\n\t\t\t}\n\n\t\t\tswitch (pi->tstamp_config.rx_filter) {\n\t\t\tcase HWTSTAMP_FILTER_NONE:\n\t\t\t\tpi->rxtstamp = false;\n\t\t\t\tbreak;\n\t\t\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\t\t\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\t\t\t\tcxgb4_ptprx_timestamping(pi, pi->port_id,\n\t\t\t\t\t\t\t PTP_TS_L4);\n\t\t\t\tbreak;\n\t\t\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\t\t\t\tcxgb4_ptprx_timestamping(pi, pi->port_id,\n\t\t\t\t\t\t\t PTP_TS_L2_L4);\n\t\t\t\tbreak;\n\t\t\tcase HWTSTAMP_FILTER_ALL:\n\t\t\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\t\t\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\t\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\t\t\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\t\t\tpi->rxtstamp = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpi->tstamp_config.rx_filter =\n\t\t\t\t\tHWTSTAMP_FILTER_NONE;\n\t\t\t\treturn -ERANGE;\n\t\t\t}\n\n\t\t\tif ((pi->tstamp_config.tx_type == HWTSTAMP_TX_OFF) &&\n\t\t\t    (pi->tstamp_config.rx_filter ==\n\t\t\t\tHWTSTAMP_FILTER_NONE)) {\n\t\t\t\tif (cxgb4_ptp_txtype(adapter, pi->port_id) >= 0)\n\t\t\t\t\tpi->ptp_enable = false;\n\t\t\t}\n\n\t\t\tif (pi->tstamp_config.rx_filter !=\n\t\t\t\tHWTSTAMP_FILTER_NONE) {\n\t\t\t\tif (cxgb4_ptp_redirect_rx_packet(adapter,\n\t\t\t\t\t\t\t\t pi) >= 0)\n\t\t\t\t\tpi->ptp_enable = true;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tswitch (pi->tstamp_config.rx_filter) {\n\t\t\tcase HWTSTAMP_FILTER_NONE:\n\t\t\tpi->rxtstamp = false;\n\t\t\tbreak;\n\t\t\tcase HWTSTAMP_FILTER_ALL:\n\t\t\tpi->rxtstamp = true;\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tpi->tstamp_config.rx_filter =\n\t\t\tHWTSTAMP_FILTER_NONE;\n\t\t\treturn -ERANGE;\n\t\t\t}\n\t\t}\n\t\treturn copy_to_user(req->ifr_data, &pi->tstamp_config,\n\t\t\t\t    sizeof(pi->tstamp_config)) ?\n\t\t\t-EFAULT : 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn ret;\n}\n\nstatic void cxgb_set_rxmode(struct net_device *dev)\n{\n\t \n\tset_rxmode(dev, -1, false);\n}\n\nstatic int cxgb_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tint ret;\n\n\tret = t4_set_rxmode(pi->adapter, pi->adapter->mbox, pi->viid,\n\t\t\t    pi->viid_mirror, new_mtu, -1, -1, -1, -1, true);\n\tif (!ret)\n\t\tdev->mtu = new_mtu;\n\treturn ret;\n}\n\n#ifdef CONFIG_PCI_IOV\nstatic int cxgb4_mgmt_open(struct net_device *dev)\n{\n\t \n\tnetif_carrier_off(dev);\n\treturn 0;\n}\n\n \nstatic void cxgb4_mgmt_fill_vf_station_mac_addr(struct adapter *adap)\n{\n\tu8 hw_addr[ETH_ALEN], macaddr[ETH_ALEN];\n\tunsigned int i, vf, nvfs;\n\tu16 a, b;\n\tint err;\n\tu8 *na;\n\n\terr = t4_get_raw_vpd_params(adap, &adap->params.vpd);\n\tif (err)\n\t\treturn;\n\n\tna = adap->params.vpd.na;\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\thw_addr[i] = (hex2val(na[2 * i + 0]) * 16 +\n\t\t\t      hex2val(na[2 * i + 1]));\n\n\ta = (hw_addr[0] << 8) | hw_addr[1];\n\tb = (hw_addr[1] << 8) | hw_addr[2];\n\ta ^= b;\n\ta |= 0x0200;     \n\ta &= ~0x0100;    \n\tmacaddr[0] = a >> 8;\n\tmacaddr[1] = a & 0xff;\n\n\tfor (i = 2; i < 5; i++)\n\t\tmacaddr[i] = hw_addr[i + 1];\n\n\tfor (vf = 0, nvfs = pci_sriov_get_totalvfs(adap->pdev);\n\t\tvf < nvfs; vf++) {\n\t\tmacaddr[5] = adap->pf * nvfs + vf;\n\t\tether_addr_copy(adap->vfinfo[vf].vf_mac_addr, macaddr);\n\t}\n}\n\nstatic int cxgb4_mgmt_set_vf_mac(struct net_device *dev, int vf, u8 *mac)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint ret;\n\n\t \n\tif (!is_valid_ether_addr(mac)) {\n\t\tdev_err(pi->adapter->pdev_dev,\n\t\t\t\"Invalid Ethernet address %pM for VF %d\\n\",\n\t\t\tmac, vf);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(pi->adapter->pdev_dev,\n\t\t \"Setting MAC %pM on VF %d\\n\", mac, vf);\n\tret = t4_set_vf_mac_acl(adap, vf + 1, 1, mac);\n\tif (!ret)\n\t\tether_addr_copy(adap->vfinfo[vf].vf_mac_addr, mac);\n\treturn ret;\n}\n\nstatic int cxgb4_mgmt_get_vf_config(struct net_device *dev,\n\t\t\t\t    int vf, struct ifla_vf_info *ivi)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tstruct vf_info *vfinfo;\n\n\tif (vf >= adap->num_vfs)\n\t\treturn -EINVAL;\n\tvfinfo = &adap->vfinfo[vf];\n\n\tivi->vf = vf;\n\tivi->max_tx_rate = vfinfo->tx_rate;\n\tivi->min_tx_rate = 0;\n\tether_addr_copy(ivi->mac, vfinfo->vf_mac_addr);\n\tivi->vlan = vfinfo->vlan;\n\tivi->linkstate = vfinfo->link_state;\n\treturn 0;\n}\n\nstatic int cxgb4_mgmt_get_phys_port_id(struct net_device *dev,\n\t\t\t\t       struct netdev_phys_item_id *ppid)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tunsigned int phy_port_id;\n\n\tphy_port_id = pi->adapter->adap_idx * 10 + pi->port_id;\n\tppid->id_len = sizeof(phy_port_id);\n\tmemcpy(ppid->id, &phy_port_id, ppid->id_len);\n\treturn 0;\n}\n\nstatic int cxgb4_mgmt_set_vf_rate(struct net_device *dev, int vf,\n\t\t\t\t  int min_tx_rate, int max_tx_rate)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tunsigned int link_ok, speed, mtu;\n\tu32 fw_pfvf, fw_class;\n\tint class_id = vf;\n\tint ret;\n\tu16 pktsize;\n\n\tif (vf >= adap->num_vfs)\n\t\treturn -EINVAL;\n\n\tif (min_tx_rate) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Min tx rate (%d) (> 0) for VF %d is Invalid.\\n\",\n\t\t\tmin_tx_rate, vf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (max_tx_rate == 0) {\n\t\t \n\t\tfw_pfvf =\n\t\t    (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_PFVF) |\n\t\t     FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_PFVF_SCHEDCLASS_ETH));\n\t\tfw_class = 0xffffffff;\n\t\tret = t4_set_params(adap, adap->mbox, adap->pf, vf + 1, 1,\n\t\t\t\t    &fw_pfvf, &fw_class);\n\t\tif (ret) {\n\t\t\tdev_err(adap->pdev_dev,\n\t\t\t\t\"Err %d in unbinding PF %d VF %d from TX Rate Limiting\\n\",\n\t\t\t\tret, adap->pf, vf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdev_info(adap->pdev_dev,\n\t\t\t \"PF %d VF %d is unbound from TX Rate Limiting\\n\",\n\t\t\t adap->pf, vf);\n\t\tadap->vfinfo[vf].tx_rate = 0;\n\t\treturn 0;\n\t}\n\n\tret = t4_get_link_params(pi, &link_ok, &speed, &mtu);\n\tif (ret != FW_SUCCESS) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed to get link information for VF %d\\n\", vf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!link_ok) {\n\t\tdev_err(adap->pdev_dev, \"Link down for VF %d\\n\", vf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (max_tx_rate > speed) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Max tx rate %d for VF %d can't be > link-speed %u\",\n\t\t\tmax_tx_rate, vf, speed);\n\t\treturn -EINVAL;\n\t}\n\n\tpktsize = mtu;\n\t \n\tpktsize = pktsize - sizeof(struct ethhdr) - 4;\n\t \n\tpktsize = pktsize - sizeof(struct iphdr) - sizeof(struct tcphdr);\n\t \n\tret = t4_sched_params(adap, SCHED_CLASS_TYPE_PACKET,\n\t\t\t      SCHED_CLASS_LEVEL_CL_RL,\n\t\t\t      SCHED_CLASS_MODE_CLASS,\n\t\t\t      SCHED_CLASS_RATEUNIT_BITS,\n\t\t\t      SCHED_CLASS_RATEMODE_ABS,\n\t\t\t      pi->tx_chan, class_id, 0,\n\t\t\t      max_tx_rate * 1000, 0, pktsize, 0);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev, \"Err %d for Traffic Class config\\n\",\n\t\t\tret);\n\t\treturn -EINVAL;\n\t}\n\tdev_info(adap->pdev_dev,\n\t\t \"Class %d with MSS %u configured with rate %u\\n\",\n\t\t class_id, pktsize, max_tx_rate);\n\n\t \n\tfw_pfvf = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_PFVF) |\n\t\t   FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_PFVF_SCHEDCLASS_ETH));\n\tfw_class = class_id;\n\tret = t4_set_params(adap, adap->mbox, adap->pf, vf + 1, 1, &fw_pfvf,\n\t\t\t    &fw_class);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Err %d in binding PF %d VF %d to Traffic Class %d\\n\",\n\t\t\tret, adap->pf, vf, class_id);\n\t\treturn -EINVAL;\n\t}\n\tdev_info(adap->pdev_dev, \"PF %d VF %d is bound to Class %d\\n\",\n\t\t adap->pf, vf, class_id);\n\tadap->vfinfo[vf].tx_rate = max_tx_rate;\n\treturn 0;\n}\n\nstatic int cxgb4_mgmt_set_vf_vlan(struct net_device *dev, int vf,\n\t\t\t\t  u16 vlan, u8 qos, __be16 vlan_proto)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint ret;\n\n\tif (vf >= adap->num_vfs || vlan > 4095 || qos > 7)\n\t\treturn -EINVAL;\n\n\tif (vlan_proto != htons(ETH_P_8021Q) || qos != 0)\n\t\treturn -EPROTONOSUPPORT;\n\n\tret = t4_set_vlan_acl(adap, adap->mbox, vf + 1, vlan);\n\tif (!ret) {\n\t\tadap->vfinfo[vf].vlan = vlan;\n\t\treturn 0;\n\t}\n\n\tdev_err(adap->pdev_dev, \"Err %d %s VLAN ACL for PF/VF %d/%d\\n\",\n\t\tret, (vlan ? \"setting\" : \"clearing\"), adap->pf, vf);\n\treturn ret;\n}\n\nstatic int cxgb4_mgmt_set_vf_link_state(struct net_device *dev, int vf,\n\t\t\t\t\tint link)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tu32 param, val;\n\tint ret = 0;\n\n\tif (vf >= adap->num_vfs)\n\t\treturn -EINVAL;\n\n\tswitch (link) {\n\tcase IFLA_VF_LINK_STATE_AUTO:\n\t\tval = FW_VF_LINK_STATE_AUTO;\n\t\tbreak;\n\n\tcase IFLA_VF_LINK_STATE_ENABLE:\n\t\tval = FW_VF_LINK_STATE_ENABLE;\n\t\tbreak;\n\n\tcase IFLA_VF_LINK_STATE_DISABLE:\n\t\tval = FW_VF_LINK_STATE_DISABLE;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_PFVF) |\n\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_PFVF_LINK_STATE));\n\tret = t4_set_params(adap, adap->mbox, adap->pf, vf + 1, 1,\n\t\t\t    &param, &val);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Error %d in setting PF %d VF %d link state\\n\",\n\t\t\tret, adap->pf, vf);\n\t\treturn -EINVAL;\n\t}\n\n\tadap->vfinfo[vf].link_state = link;\n\treturn ret;\n}\n#endif  \n\nstatic int cxgb_set_mac_addr(struct net_device *dev, void *p)\n{\n\tint ret;\n\tstruct sockaddr *addr = p;\n\tstruct port_info *pi = netdev_priv(dev);\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tret = cxgb4_update_mac_filt(pi, pi->viid, &pi->xact_addr_filt,\n\t\t\t\t    addr->sa_data, true, &pi->smt_idx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void cxgb_netpoll(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\n\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\tint i;\n\t\tstruct sge_eth_rxq *rx = &adap->sge.ethrxq[pi->first_qset];\n\n\t\tfor (i = pi->nqsets; i; i--, rx++)\n\t\t\tt4_sge_intr_msix(0, &rx->rspq);\n\t} else\n\t\tt4_intr_handler(adap)(0, adap);\n}\n#endif\n\nstatic int cxgb_set_tx_maxrate(struct net_device *dev, int index, u32 rate)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tstruct ch_sched_queue qe = { 0 };\n\tstruct ch_sched_params p = { 0 };\n\tstruct sched_class *e;\n\tu32 req_rate;\n\tint err = 0;\n\n\tif (!can_sched(dev))\n\t\treturn -ENOTSUPP;\n\n\tif (index < 0 || index > pi->nqsets - 1)\n\t\treturn -EINVAL;\n\n\tif (!(adap->flags & CXGB4_FULL_INIT_DONE)) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed to rate limit on queue %d. Link Down?\\n\",\n\t\t\tindex);\n\t\treturn -EINVAL;\n\t}\n\n\tqe.queue = index;\n\te = cxgb4_sched_queue_lookup(dev, &qe);\n\tif (e && e->info.u.params.level != SCHED_CLASS_LEVEL_CL_RL) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Queue %u already bound to class %u of type: %u\\n\",\n\t\t\tindex, e->idx, e->info.u.params.level);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\treq_rate = rate * 1000;\n\n\t \n\tif (req_rate > SCHED_MAX_RATE_KBPS) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Invalid rate %u Mbps, Max rate is %u Mbps\\n\",\n\t\t\trate, SCHED_MAX_RATE_KBPS / 1000);\n\t\treturn -ERANGE;\n\t}\n\n\t \n\tmemset(&qe, 0, sizeof(qe));\n\tqe.queue = index;\n\tqe.class = SCHED_CLS_NONE;\n\n\terr = cxgb4_sched_class_unbind(dev, (void *)(&qe), SCHED_QUEUE);\n\tif (err) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Unbinding Queue %d on port %d fail. Err: %d\\n\",\n\t\t\tindex, pi->port_id, err);\n\t\treturn err;\n\t}\n\n\t \n\tif (!req_rate)\n\t\treturn 0;\n\n\t \n\tp.type = SCHED_CLASS_TYPE_PACKET;\n\tp.u.params.level    = SCHED_CLASS_LEVEL_CL_RL;\n\tp.u.params.mode     = SCHED_CLASS_MODE_CLASS;\n\tp.u.params.rateunit = SCHED_CLASS_RATEUNIT_BITS;\n\tp.u.params.ratemode = SCHED_CLASS_RATEMODE_ABS;\n\tp.u.params.channel  = pi->tx_chan;\n\tp.u.params.class    = SCHED_CLS_NONE;\n\tp.u.params.minrate  = 0;\n\tp.u.params.maxrate  = req_rate;\n\tp.u.params.weight   = 0;\n\tp.u.params.pktsize  = dev->mtu;\n\n\te = cxgb4_sched_class_alloc(dev, &p);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\t \n\tmemset(&qe, 0, sizeof(qe));\n\tqe.queue = index;\n\tqe.class = e->idx;\n\n\terr = cxgb4_sched_class_bind(dev, (void *)(&qe), SCHED_QUEUE);\n\tif (err)\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Queue rate limiting failed. Err: %d\\n\", err);\n\treturn err;\n}\n\nstatic int cxgb_setup_tc_flower(struct net_device *dev,\n\t\t\t\tstruct flow_cls_offload *cls_flower)\n{\n\tswitch (cls_flower->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn cxgb4_tc_flower_replace(dev, cls_flower);\n\tcase FLOW_CLS_DESTROY:\n\t\treturn cxgb4_tc_flower_destroy(dev, cls_flower);\n\tcase FLOW_CLS_STATS:\n\t\treturn cxgb4_tc_flower_stats(dev, cls_flower);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int cxgb_setup_tc_cls_u32(struct net_device *dev,\n\t\t\t\t struct tc_cls_u32_offload *cls_u32)\n{\n\tswitch (cls_u32->command) {\n\tcase TC_CLSU32_NEW_KNODE:\n\tcase TC_CLSU32_REPLACE_KNODE:\n\t\treturn cxgb4_config_knode(dev, cls_u32);\n\tcase TC_CLSU32_DELETE_KNODE:\n\t\treturn cxgb4_delete_knode(dev, cls_u32);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int cxgb_setup_tc_matchall(struct net_device *dev,\n\t\t\t\t  struct tc_cls_matchall_offload *cls_matchall,\n\t\t\t\t  bool ingress)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tif (!adap->tc_matchall)\n\t\treturn -ENOMEM;\n\n\tswitch (cls_matchall->command) {\n\tcase TC_CLSMATCHALL_REPLACE:\n\t\treturn cxgb4_tc_matchall_replace(dev, cls_matchall, ingress);\n\tcase TC_CLSMATCHALL_DESTROY:\n\t\treturn cxgb4_tc_matchall_destroy(dev, cls_matchall, ingress);\n\tcase TC_CLSMATCHALL_STATS:\n\t\tif (ingress)\n\t\t\treturn cxgb4_tc_matchall_stats(dev, cls_matchall);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int cxgb_setup_tc_block_ingress_cb(enum tc_setup_type type,\n\t\t\t\t\t  void *type_data, void *cb_priv)\n{\n\tstruct net_device *dev = cb_priv;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tif (!(adap->flags & CXGB4_FULL_INIT_DONE)) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed to setup tc on port %d. Link Down?\\n\",\n\t\t\tpi->port_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!tc_cls_can_offload_and_chain0(dev, type_data))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSU32:\n\t\treturn cxgb_setup_tc_cls_u32(dev, type_data);\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn cxgb_setup_tc_flower(dev, type_data);\n\tcase TC_SETUP_CLSMATCHALL:\n\t\treturn cxgb_setup_tc_matchall(dev, type_data, true);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int cxgb_setup_tc_block_egress_cb(enum tc_setup_type type,\n\t\t\t\t\t void *type_data, void *cb_priv)\n{\n\tstruct net_device *dev = cb_priv;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tif (!(adap->flags & CXGB4_FULL_INIT_DONE)) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed to setup tc on port %d. Link Down?\\n\",\n\t\t\tpi->port_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!tc_cls_can_offload_and_chain0(dev, type_data))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSMATCHALL:\n\t\treturn cxgb_setup_tc_matchall(dev, type_data, false);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int cxgb_setup_tc_mqprio(struct net_device *dev,\n\t\t\t\tstruct tc_mqprio_qopt_offload *mqprio)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tif (!is_ethofld(adap) || !adap->tc_mqprio)\n\t\treturn -ENOMEM;\n\n\treturn cxgb4_setup_tc_mqprio(dev, mqprio);\n}\n\nstatic LIST_HEAD(cxgb_block_cb_list);\n\nstatic int cxgb_setup_tc_block(struct net_device *dev,\n\t\t\t       struct flow_block_offload *f)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tflow_setup_cb_t *cb;\n\tbool ingress_only;\n\n\tpi->tc_block_shared = f->block_shared;\n\tif (f->binder_type == FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS) {\n\t\tcb = cxgb_setup_tc_block_egress_cb;\n\t\tingress_only = false;\n\t} else {\n\t\tcb = cxgb_setup_tc_block_ingress_cb;\n\t\tingress_only = true;\n\t}\n\n\treturn flow_block_cb_setup_simple(f, &cxgb_block_cb_list,\n\t\t\t\t\t  cb, pi, dev, ingress_only);\n}\n\nstatic int cxgb_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t\t void *type_data)\n{\n\tswitch (type) {\n\tcase TC_SETUP_QDISC_MQPRIO:\n\t\treturn cxgb_setup_tc_mqprio(dev, type_data);\n\tcase TC_SETUP_BLOCK:\n\t\treturn cxgb_setup_tc_block(dev, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int cxgb_udp_tunnel_unset_port(struct net_device *netdev,\n\t\t\t\t      unsigned int table, unsigned int entry,\n\t\t\t\t      struct udp_tunnel_info *ti)\n{\n\tstruct port_info *pi = netdev_priv(netdev);\n\tstruct adapter *adapter = pi->adapter;\n\tu8 match_all_mac[] = { 0, 0, 0, 0, 0, 0 };\n\tint ret = 0, i;\n\n\tswitch (ti->type) {\n\tcase UDP_TUNNEL_TYPE_VXLAN:\n\t\tadapter->vxlan_port = 0;\n\t\tt4_write_reg(adapter, MPS_RX_VXLAN_TYPE_A, 0);\n\t\tbreak;\n\tcase UDP_TUNNEL_TYPE_GENEVE:\n\t\tadapter->geneve_port = 0;\n\t\tt4_write_reg(adapter, MPS_RX_GENEVE_TYPE_A, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!adapter->rawf_cnt)\n\t\treturn 0;\n\tfor_each_port(adapter, i) {\n\t\tpi = adap2pinfo(adapter, i);\n\t\tret = t4_free_raw_mac_filt(adapter, pi->viid,\n\t\t\t\t\t   match_all_mac, match_all_mac,\n\t\t\t\t\t   adapter->rawf_start + pi->port_id,\n\t\t\t\t\t   1, pi->port_id, false);\n\t\tif (ret < 0) {\n\t\t\tnetdev_info(netdev, \"Failed to free mac filter entry, for port %d\\n\",\n\t\t\t\t    i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cxgb_udp_tunnel_set_port(struct net_device *netdev,\n\t\t\t\t    unsigned int table, unsigned int entry,\n\t\t\t\t    struct udp_tunnel_info *ti)\n{\n\tstruct port_info *pi = netdev_priv(netdev);\n\tstruct adapter *adapter = pi->adapter;\n\tu8 match_all_mac[] = { 0, 0, 0, 0, 0, 0 };\n\tint i, ret;\n\n\tswitch (ti->type) {\n\tcase UDP_TUNNEL_TYPE_VXLAN:\n\t\tadapter->vxlan_port = ti->port;\n\t\tt4_write_reg(adapter, MPS_RX_VXLAN_TYPE_A,\n\t\t\t     VXLAN_V(be16_to_cpu(ti->port)) | VXLAN_EN_F);\n\t\tbreak;\n\tcase UDP_TUNNEL_TYPE_GENEVE:\n\t\tadapter->geneve_port = ti->port;\n\t\tt4_write_reg(adapter, MPS_RX_GENEVE_TYPE_A,\n\t\t\t     GENEVE_V(be16_to_cpu(ti->port)) | GENEVE_EN_F);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor_each_port(adapter, i) {\n\t\tpi = adap2pinfo(adapter, i);\n\n\t\tret = t4_alloc_raw_mac_filt(adapter, pi->viid,\n\t\t\t\t\t    match_all_mac,\n\t\t\t\t\t    match_all_mac,\n\t\t\t\t\t    adapter->rawf_start + pi->port_id,\n\t\t\t\t\t    1, pi->port_id, false);\n\t\tif (ret < 0) {\n\t\t\tnetdev_info(netdev, \"Failed to allocate a mac filter entry, not adding port %d\\n\",\n\t\t\t\t    be16_to_cpu(ti->port));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct udp_tunnel_nic_info cxgb_udp_tunnels = {\n\t.set_port\t= cxgb_udp_tunnel_set_port,\n\t.unset_port\t= cxgb_udp_tunnel_unset_port,\n\t.tables\t\t= {\n\t\t{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_VXLAN,  },\n\t\t{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_GENEVE, },\n\t},\n};\n\nstatic netdev_features_t cxgb_features_check(struct sk_buff *skb,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     netdev_features_t features)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\tif (CHELSIO_CHIP_VERSION(adapter->params.chip) < CHELSIO_T6)\n\t\treturn features;\n\n\t \n\tif (!skb->encapsulation || cxgb_encap_offload_supported(skb))\n\t\treturn features;\n\n\t \n\treturn features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n}\n\nstatic netdev_features_t cxgb_fix_features(struct net_device *dev,\n\t\t\t\t\t   netdev_features_t features)\n{\n\t \n\tif (!(features & NETIF_F_RXCSUM))\n\t\tfeatures &= ~NETIF_F_GRO;\n\n\treturn features;\n}\n\nstatic const struct net_device_ops cxgb4_netdev_ops = {\n\t.ndo_open             = cxgb_open,\n\t.ndo_stop             = cxgb_close,\n\t.ndo_start_xmit       = t4_start_xmit,\n\t.ndo_select_queue     =\tcxgb_select_queue,\n\t.ndo_get_stats64      = cxgb_get_stats,\n\t.ndo_set_rx_mode      = cxgb_set_rxmode,\n\t.ndo_set_mac_address  = cxgb_set_mac_addr,\n\t.ndo_set_features     = cxgb_set_features,\n\t.ndo_validate_addr    = eth_validate_addr,\n\t.ndo_eth_ioctl         = cxgb_ioctl,\n\t.ndo_change_mtu       = cxgb_change_mtu,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller  = cxgb_netpoll,\n#endif\n#ifdef CONFIG_CHELSIO_T4_FCOE\n\t.ndo_fcoe_enable      = cxgb_fcoe_enable,\n\t.ndo_fcoe_disable     = cxgb_fcoe_disable,\n#endif  \n\t.ndo_set_tx_maxrate   = cxgb_set_tx_maxrate,\n\t.ndo_setup_tc         = cxgb_setup_tc,\n\t.ndo_features_check   = cxgb_features_check,\n\t.ndo_fix_features     = cxgb_fix_features,\n};\n\n#ifdef CONFIG_PCI_IOV\nstatic const struct net_device_ops cxgb4_mgmt_netdev_ops = {\n\t.ndo_open               = cxgb4_mgmt_open,\n\t.ndo_set_vf_mac         = cxgb4_mgmt_set_vf_mac,\n\t.ndo_get_vf_config      = cxgb4_mgmt_get_vf_config,\n\t.ndo_set_vf_rate        = cxgb4_mgmt_set_vf_rate,\n\t.ndo_get_phys_port_id   = cxgb4_mgmt_get_phys_port_id,\n\t.ndo_set_vf_vlan        = cxgb4_mgmt_set_vf_vlan,\n\t.ndo_set_vf_link_state\t= cxgb4_mgmt_set_vf_link_state,\n};\n\nstatic void cxgb4_mgmt_get_drvinfo(struct net_device *dev,\n\t\t\t\t   struct ethtool_drvinfo *info)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\n\tstrscpy(info->driver, cxgb4_driver_name, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(info->bus_info));\n}\n\nstatic const struct ethtool_ops cxgb4_mgmt_ethtool_ops = {\n\t.get_drvinfo       = cxgb4_mgmt_get_drvinfo,\n};\n#endif\n\nstatic void notify_fatal_err(struct work_struct *work)\n{\n\tstruct adapter *adap;\n\n\tadap = container_of(work, struct adapter, fatal_err_notify_task);\n\tnotify_ulds(adap, CXGB4_STATE_FATAL_ERROR);\n}\n\nvoid t4_fatal_err(struct adapter *adap)\n{\n\tint port;\n\n\tif (pci_channel_offline(adap->pdev))\n\t\treturn;\n\n\t \n\tt4_shutdown_adapter(adap);\n\tfor_each_port(adap, port) {\n\t\tstruct net_device *dev = adap->port[port];\n\n\t\t \n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\tnetif_tx_stop_all_queues(dev);\n\t\tnetif_carrier_off(dev);\n\t}\n\tdev_alert(adap->pdev_dev, \"encountered fatal error, adapter stopped\\n\");\n\tqueue_work(adap->workq, &adap->fatal_err_notify_task);\n}\n\nstatic void setup_memwin(struct adapter *adap)\n{\n\tu32 nic_win_base = t4_get_util_window(adap);\n\n\tt4_setup_memwin(adap, nic_win_base, MEMWIN_NIC);\n}\n\nstatic void setup_memwin_rdma(struct adapter *adap)\n{\n\tif (adap->vres.ocq.size) {\n\t\tu32 start;\n\t\tunsigned int sz_kb;\n\n\t\tstart = t4_read_pcie_cfg4(adap, PCI_BASE_ADDRESS_2);\n\t\tstart &= PCI_BASE_ADDRESS_MEM_MASK;\n\t\tstart += OCQ_WIN_OFFSET(adap->pdev, &adap->vres);\n\t\tsz_kb = roundup_pow_of_two(adap->vres.ocq.size) >> 10;\n\t\tt4_write_reg(adap,\n\t\t\t     PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_BASE_WIN_A, 3),\n\t\t\t     start | BIR_V(1) | WINDOW_V(ilog2(sz_kb)));\n\t\tt4_write_reg(adap,\n\t\t\t     PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_OFFSET_A, 3),\n\t\t\t     adap->vres.ocq.start);\n\t\tt4_read_reg(adap,\n\t\t\t    PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_OFFSET_A, 3));\n\t}\n}\n\n \n\n \n#define HMA_MAX_ADDR_IN_CMD\t5\n\n#define HMA_PAGE_SIZE\t\tPAGE_SIZE\n\n#define HMA_MAX_NO_FW_ADDRESS\t(16 << 10)   \n\n#define HMA_PAGE_ORDER\t\t\t\t\t\\\n\t((HMA_PAGE_SIZE < HMA_MAX_NO_FW_ADDRESS) ?\t\\\n\tilog2(HMA_MAX_NO_FW_ADDRESS / HMA_PAGE_SIZE) : 0)\n\n \n#define HMA_MIN_TOTAL_SIZE\t1\n#define HMA_MAX_TOTAL_SIZE\t\t\t\t\\\n\t(((HMA_PAGE_SIZE << HMA_PAGE_ORDER) *\t\t\\\n\t  HMA_MAX_NO_FW_ADDRESS) >> 20)\n\nstatic void adap_free_hma_mem(struct adapter *adapter)\n{\n\tstruct scatterlist *iter;\n\tstruct page *page;\n\tint i;\n\n\tif (!adapter->hma.sgt)\n\t\treturn;\n\n\tif (adapter->hma.flags & HMA_DMA_MAPPED_FLAG) {\n\t\tdma_unmap_sg(adapter->pdev_dev, adapter->hma.sgt->sgl,\n\t\t\t     adapter->hma.sgt->nents, DMA_BIDIRECTIONAL);\n\t\tadapter->hma.flags &= ~HMA_DMA_MAPPED_FLAG;\n\t}\n\n\tfor_each_sg(adapter->hma.sgt->sgl, iter,\n\t\t    adapter->hma.sgt->orig_nents, i) {\n\t\tpage = sg_page(iter);\n\t\tif (page)\n\t\t\t__free_pages(page, HMA_PAGE_ORDER);\n\t}\n\n\tkfree(adapter->hma.phy_addr);\n\tsg_free_table(adapter->hma.sgt);\n\tkfree(adapter->hma.sgt);\n\tadapter->hma.sgt = NULL;\n}\n\nstatic int adap_config_hma(struct adapter *adapter)\n{\n\tstruct scatterlist *sgl, *iter;\n\tstruct sg_table *sgt;\n\tstruct page *newpage;\n\tunsigned int i, j, k;\n\tu32 param, hma_size;\n\tunsigned int ncmds;\n\tsize_t page_size;\n\tu32 page_order;\n\tint node, ret;\n\n\t \n\tif (is_kdump_kernel() ||\n\t    CHELSIO_CHIP_VERSION(adapter->params.chip) < CHELSIO_T6)\n\t\treturn 0;\n\n\t \n\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_HMA_SIZE));\n\tret = t4_query_params(adapter, adapter->mbox, adapter->pf, 0,\n\t\t\t      1, &param, &hma_size);\n\t \n\tif (ret || !hma_size)\n\t\treturn 0;\n\n\tif (hma_size < HMA_MIN_TOTAL_SIZE ||\n\t    hma_size > HMA_MAX_TOTAL_SIZE) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"HMA size %uMB beyond bounds(%u-%lu)MB\\n\",\n\t\t\thma_size, HMA_MIN_TOTAL_SIZE, HMA_MAX_TOTAL_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tpage_size = HMA_PAGE_SIZE;\n\tpage_order = HMA_PAGE_ORDER;\n\tadapter->hma.sgt = kzalloc(sizeof(*adapter->hma.sgt), GFP_KERNEL);\n\tif (unlikely(!adapter->hma.sgt)) {\n\t\tdev_err(adapter->pdev_dev, \"HMA SG table allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsgt = adapter->hma.sgt;\n\t \n\tsgt->orig_nents = (hma_size << 20) / (page_size << page_order);\n\tif (sg_alloc_table(sgt, sgt->orig_nents, GFP_KERNEL)) {\n\t\tdev_err(adapter->pdev_dev, \"HMA SGL allocation failed\\n\");\n\t\tkfree(adapter->hma.sgt);\n\t\tadapter->hma.sgt = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tsgl = adapter->hma.sgt->sgl;\n\tnode = dev_to_node(adapter->pdev_dev);\n\tfor_each_sg(sgl, iter, sgt->orig_nents, i) {\n\t\tnewpage = alloc_pages_node(node, __GFP_NOWARN | GFP_KERNEL |\n\t\t\t\t\t   __GFP_ZERO, page_order);\n\t\tif (!newpage) {\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"Not enough memory for HMA page allocation\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_hma;\n\t\t}\n\t\tsg_set_page(iter, newpage, page_size << page_order, 0);\n\t}\n\n\tsgt->nents = dma_map_sg(adapter->pdev_dev, sgl, sgt->orig_nents,\n\t\t\t\tDMA_BIDIRECTIONAL);\n\tif (!sgt->nents) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"Not enough memory for HMA DMA mapping\");\n\t\tret = -ENOMEM;\n\t\tgoto free_hma;\n\t}\n\tadapter->hma.flags |= HMA_DMA_MAPPED_FLAG;\n\n\tadapter->hma.phy_addr = kcalloc(sgt->nents, sizeof(dma_addr_t),\n\t\t\t\t\tGFP_KERNEL);\n\tif (unlikely(!adapter->hma.phy_addr))\n\t\tgoto free_hma;\n\n\tfor_each_sg(sgl, iter, sgt->nents, i) {\n\t\tnewpage = sg_page(iter);\n\t\tadapter->hma.phy_addr[i] = sg_dma_address(iter);\n\t}\n\n\tncmds = DIV_ROUND_UP(sgt->nents, HMA_MAX_ADDR_IN_CMD);\n\t \n\tfor (i = 0, k = 0; i < ncmds; i++, k += HMA_MAX_ADDR_IN_CMD) {\n\t\tstruct fw_hma_cmd hma_cmd;\n\t\tu8 naddr = HMA_MAX_ADDR_IN_CMD;\n\t\tu8 soc = 0, eoc = 0;\n\t\tu8 hma_mode = 1;  \n\n\t\tsoc = (i == 0) ? 1 : 0;\n\t\teoc = (i == ncmds - 1) ? 1 : 0;\n\n\t\t \n\t\tif (i == ncmds - 1) {\n\t\t\tnaddr = sgt->nents % HMA_MAX_ADDR_IN_CMD;\n\t\t\tnaddr = naddr ? naddr : HMA_MAX_ADDR_IN_CMD;\n\t\t}\n\t\tmemset(&hma_cmd, 0, sizeof(hma_cmd));\n\t\thma_cmd.op_pkd = htonl(FW_CMD_OP_V(FW_HMA_CMD) |\n\t\t\t\t       FW_CMD_REQUEST_F | FW_CMD_WRITE_F);\n\t\thma_cmd.retval_len16 = htonl(FW_LEN16(hma_cmd));\n\n\t\thma_cmd.mode_to_pcie_params =\n\t\t\thtonl(FW_HMA_CMD_MODE_V(hma_mode) |\n\t\t\t      FW_HMA_CMD_SOC_V(soc) | FW_HMA_CMD_EOC_V(eoc));\n\n\t\t \n\t\thma_cmd.naddr_size =\n\t\t\thtonl(FW_HMA_CMD_SIZE_V(hma_size) |\n\t\t\t      FW_HMA_CMD_NADDR_V(naddr));\n\n\t\t \n\t\thma_cmd.addr_size_pkd =\n\t\t\thtonl(FW_HMA_CMD_ADDR_SIZE_V\n\t\t\t\t((page_size << page_order) >> 12));\n\n\t\t \n\t\tfor (j = 0; j < naddr; j++) {\n\t\t\thma_cmd.phy_address[j] =\n\t\t\t\tcpu_to_be64(adapter->hma.phy_addr[j + k]);\n\t\t}\n\t\tret = t4_wr_mbox(adapter, adapter->mbox, &hma_cmd,\n\t\t\t\t sizeof(hma_cmd), &hma_cmd);\n\t\tif (ret) {\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"HMA FW command failed with err %d\\n\", ret);\n\t\t\tgoto free_hma;\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tdev_info(adapter->pdev_dev,\n\t\t\t \"Reserved %uMB host memory for HMA\\n\", hma_size);\n\treturn ret;\n\nfree_hma:\n\tadap_free_hma_mem(adapter);\n\treturn ret;\n}\n\nstatic int adap_init1(struct adapter *adap, struct fw_caps_config_cmd *c)\n{\n\tu32 v;\n\tint ret;\n\n\t \n\tret = t4_get_pfres(adap);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Unable to retrieve resource provisioning information\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tmemset(c, 0, sizeof(*c));\n\tc->op_to_write = htonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t\t       FW_CMD_REQUEST_F | FW_CMD_READ_F);\n\tc->cfvalid_to_len16 = htonl(FW_LEN16(*c));\n\tret = t4_wr_mbox(adap, adap->mbox, c, sizeof(*c), c);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tc->op_to_write = htonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t\t       FW_CMD_REQUEST_F | FW_CMD_WRITE_F);\n\tret = t4_wr_mbox(adap, adap->mbox, c, sizeof(*c), NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = t4_config_glbl_rss(adap, adap->pf,\n\t\t\t\t FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL,\n\t\t\t\t FW_RSS_GLB_CONFIG_CMD_TNLMAPEN_F |\n\t\t\t\t FW_RSS_GLB_CONFIG_CMD_TNLALLLKP_F);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = t4_cfg_pfvf(adap, adap->mbox, adap->pf, 0, adap->sge.egr_sz, 64,\n\t\t\t  MAX_INGQ, 0, 0, 4, 0xf, 0xf, 16, FW_CMD_CAP_PF,\n\t\t\t  FW_CMD_CAP_PF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tt4_sge_init(adap);\n\n\t \n\tt4_write_reg(adap, TP_SHIFT_CNT_A, 0x64f8849);\n\tt4_write_reg(adap, ULP_RX_TDDP_PSZ_A, HPZ0_V(PAGE_SHIFT - 12));\n\tt4_write_reg(adap, TP_PIO_ADDR_A, TP_INGRESS_CONFIG_A);\n\tv = t4_read_reg(adap, TP_PIO_DATA_A);\n\tt4_write_reg(adap, TP_PIO_DATA_A, v & ~CSUM_HAS_PSEUDO_HDR_F);\n\n\t \n\tadap->params.tp.tx_modq_map = 0xE4;\n\tt4_write_reg(adap, TP_TX_MOD_QUEUE_REQ_MAP_A,\n\t\t     TX_MOD_QUEUE_REQ_MAP_V(adap->params.tp.tx_modq_map));\n\n\t \n\tv = 0x84218421;\n\tt4_write_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A,\n\t\t\t  &v, 1, TP_TX_SCHED_HDR_A);\n\tt4_write_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A,\n\t\t\t  &v, 1, TP_TX_SCHED_FIFO_A);\n\tt4_write_indirect(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A,\n\t\t\t  &v, 1, TP_TX_SCHED_PCMD_A);\n\n#define T4_TX_MODQ_10G_WEIGHT_DEFAULT 16  \n\tif (is_offload(adap)) {\n\t\tt4_write_reg(adap, TP_TX_MOD_QUEUE_WEIGHT0_A,\n\t\t\t     TX_MODQ_WEIGHT0_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT) |\n\t\t\t     TX_MODQ_WEIGHT1_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT) |\n\t\t\t     TX_MODQ_WEIGHT2_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT) |\n\t\t\t     TX_MODQ_WEIGHT3_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT));\n\t\tt4_write_reg(adap, TP_TX_MOD_CHANNEL_WEIGHT_A,\n\t\t\t     TX_MODQ_WEIGHT0_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT) |\n\t\t\t     TX_MODQ_WEIGHT1_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT) |\n\t\t\t     TX_MODQ_WEIGHT2_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT) |\n\t\t\t     TX_MODQ_WEIGHT3_V(T4_TX_MODQ_10G_WEIGHT_DEFAULT));\n\t}\n\n\t \n\treturn t4_early_init(adap, adap->pf);\n}\n\n \n#define MAX_ATIDS 8192U\n\n \n\n \nstatic int adap_init0_tweaks(struct adapter *adapter)\n{\n\t \n\tt4_fixup_host_params(adapter, PAGE_SIZE, L1_CACHE_BYTES);\n\n\t \n\tif (rx_dma_offset != 2 && rx_dma_offset != 0) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Ignoring illegal rx_dma_offset=%d, using 2\\n\",\n\t\t\trx_dma_offset);\n\t\trx_dma_offset = 2;\n\t}\n\tt4_set_reg_field(adapter, SGE_CONTROL_A,\n\t\t\t PKTSHIFT_V(PKTSHIFT_M),\n\t\t\t PKTSHIFT_V(rx_dma_offset));\n\n\t \n\tt4_tp_wr_bits_indirect(adapter, TP_INGRESS_CONFIG_A,\n\t\t\t       CSUM_HAS_PSEUDO_HDR_F, 0);\n\n\treturn 0;\n}\n\n \nstatic int phy_aq1202_version(const u8 *phy_fw_data,\n\t\t\t      size_t phy_fw_size)\n{\n\tint offset;\n\n\t \n\t#define be16(__p) (((__p)[0] << 8) | (__p)[1])\n\t#define le16(__p) ((__p)[0] | ((__p)[1] << 8))\n\t#define le24(__p) (le16(__p) | ((__p)[2] << 16))\n\n\toffset = le24(phy_fw_data + 0x8) << 12;\n\toffset = le24(phy_fw_data + offset + 0xa);\n\treturn be16(phy_fw_data + offset + 0x27e);\n\n\t#undef be16\n\t#undef le16\n\t#undef le24\n}\n\nstatic struct info_10gbt_phy_fw {\n\tunsigned int phy_fw_id;\t\t \n\tchar *phy_fw_file;\t\t \n\tint (*phy_fw_version)(const u8 *phy_fw_data, size_t phy_fw_size);\n\tint phy_flash;\t\t\t \n} phy_info_array[] = {\n\t{\n\t\tPHY_AQ1202_DEVICEID,\n\t\tPHY_AQ1202_FIRMWARE,\n\t\tphy_aq1202_version,\n\t\t1,\n\t},\n\t{\n\t\tPHY_BCM84834_DEVICEID,\n\t\tPHY_BCM84834_FIRMWARE,\n\t\tNULL,\n\t\t0,\n\t},\n\t{ 0, NULL, NULL },\n};\n\nstatic struct info_10gbt_phy_fw *find_phy_info(int devid)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(phy_info_array); i++) {\n\t\tif (phy_info_array[i].phy_fw_id == devid)\n\t\t\treturn &phy_info_array[i];\n\t}\n\treturn NULL;\n}\n\n \nstatic int adap_init0_phy(struct adapter *adap)\n{\n\tconst struct firmware *phyf;\n\tint ret;\n\tstruct info_10gbt_phy_fw *phy_info;\n\n\t \n\tphy_info = find_phy_info(adap->pdev->device);\n\tif (!phy_info) {\n\t\tdev_warn(adap->pdev_dev,\n\t\t\t \"No PHY Firmware file found for this PHY\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tret = request_firmware_direct(&phyf, phy_info->phy_fw_file,\n\t\t\t\t      adap->pdev_dev);\n\tif (ret < 0) {\n\t\t \n\t\tdev_err(adap->pdev_dev, \"unable to find PHY Firmware image \"\n\t\t\t\"/lib/firmware/%s, error %d\\n\",\n\t\t\tphy_info->phy_fw_file, -ret);\n\t\tif (phy_info->phy_flash) {\n\t\t\tint cur_phy_fw_ver = 0;\n\n\t\t\tt4_phy_fw_ver(adap, &cur_phy_fw_ver);\n\t\t\tdev_warn(adap->pdev_dev, \"continuing with, on-adapter \"\n\t\t\t\t \"FLASH copy, version %#x\\n\", cur_phy_fw_ver);\n\t\t\tret = 0;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t \n\tret = t4_load_phy_fw(adap, MEMWIN_NIC, phy_info->phy_fw_version,\n\t\t\t     (u8 *)phyf->data, phyf->size);\n\tif (ret < 0)\n\t\tdev_err(adap->pdev_dev, \"PHY Firmware transfer error %d\\n\",\n\t\t\t-ret);\n\telse if (ret > 0) {\n\t\tint new_phy_fw_ver = 0;\n\n\t\tif (phy_info->phy_fw_version)\n\t\t\tnew_phy_fw_ver = phy_info->phy_fw_version(phyf->data,\n\t\t\t\t\t\t\t\t  phyf->size);\n\t\tdev_info(adap->pdev_dev, \"Successfully transferred PHY \"\n\t\t\t \"Firmware /lib/firmware/%s, version %#x\\n\",\n\t\t\t phy_info->phy_fw_file, new_phy_fw_ver);\n\t}\n\n\trelease_firmware(phyf);\n\n\treturn ret;\n}\n\n \nstatic int adap_init0_config(struct adapter *adapter, int reset)\n{\n\tchar *fw_config_file, fw_config_file_path[256];\n\tu32 finiver, finicsum, cfcsum, param, val;\n\tstruct fw_caps_config_cmd caps_cmd;\n\tunsigned long mtype = 0, maddr = 0;\n\tconst struct firmware *cf;\n\tchar *config_name = NULL;\n\tint config_issued = 0;\n\tint ret;\n\n\t \n\tif (reset) {\n\t\tret = t4_fw_reset(adapter, adapter->mbox,\n\t\t\t\t  PIORSTMODE_F | PIORST_F);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t}\n\n\t \n\tif (is_10gbt_device(adapter->pdev->device)) {\n\t\tret = adap_init0_phy(adapter);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t}\n\t \n\tswitch (CHELSIO_CHIP_VERSION(adapter->params.chip)) {\n\tcase CHELSIO_T4:\n\t\tfw_config_file = FW4_CFNAME;\n\t\tbreak;\n\tcase CHELSIO_T5:\n\t\tfw_config_file = FW5_CFNAME;\n\t\tbreak;\n\tcase CHELSIO_T6:\n\t\tfw_config_file = FW6_CFNAME;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adapter->pdev_dev, \"Device %d is not supported\\n\",\n\t\t       adapter->pdev->device);\n\t\tret = -EINVAL;\n\t\tgoto bye;\n\t}\n\n\tret = request_firmware(&cf, fw_config_file, adapter->pdev_dev);\n\tif (ret < 0) {\n\t\tconfig_name = \"On FLASH\";\n\t\tmtype = FW_MEMTYPE_CF_FLASH;\n\t\tmaddr = t4_flash_cfg_addr(adapter);\n\t} else {\n\t\tu32 params[7], val[7];\n\n\t\tsprintf(fw_config_file_path,\n\t\t\t\"/lib/firmware/%s\", fw_config_file);\n\t\tconfig_name = fw_config_file_path;\n\n\t\tif (cf->size >= FLASH_CFG_MAX_SIZE)\n\t\t\tret = -ENOMEM;\n\t\telse {\n\t\t\tparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t\t     FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_CF));\n\t\t\tret = t4_query_params(adapter, adapter->mbox,\n\t\t\t\t\t      adapter->pf, 0, 1, params, val);\n\t\t\tif (ret == 0) {\n\t\t\t\t \n\t\t\t\tsize_t resid = cf->size & 0x3;\n\t\t\t\tsize_t size = cf->size & ~0x3;\n\t\t\t\t__be32 *data = (__be32 *)cf->data;\n\n\t\t\t\tmtype = FW_PARAMS_PARAM_Y_G(val[0]);\n\t\t\t\tmaddr = FW_PARAMS_PARAM_Z_G(val[0]) << 16;\n\n\t\t\t\tspin_lock(&adapter->win0_lock);\n\t\t\t\tret = t4_memory_rw(adapter, 0, mtype, maddr,\n\t\t\t\t\t\t   size, data, T4_MEMORY_WRITE);\n\t\t\t\tif (ret == 0 && resid != 0) {\n\t\t\t\t\tunion {\n\t\t\t\t\t\t__be32 word;\n\t\t\t\t\t\tchar buf[4];\n\t\t\t\t\t} last;\n\t\t\t\t\tint i;\n\n\t\t\t\t\tlast.word = data[size >> 2];\n\t\t\t\t\tfor (i = resid; i < 4; i++)\n\t\t\t\t\t\tlast.buf[i] = 0;\n\t\t\t\t\tret = t4_memory_rw(adapter, 0, mtype,\n\t\t\t\t\t\t\t   maddr + size,\n\t\t\t\t\t\t\t   4, &last.word,\n\t\t\t\t\t\t\t   T4_MEMORY_WRITE);\n\t\t\t\t}\n\t\t\t\tspin_unlock(&adapter->win0_lock);\n\t\t\t}\n\t\t}\n\n\t\trelease_firmware(cf);\n\t\tif (ret)\n\t\t\tgoto bye;\n\t}\n\n\tval = 0;\n\n\t \n\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_HASHFILTER_WITH_OFLD));\n\tret = t4_set_params(adapter, adapter->mbox, adapter->pf, 0,\n\t\t\t    1, &param, &val);\n\n\t \n\tif (ret < 0) {\n\t\tdev_warn(adapter->pdev_dev,\n\t\t\t \"Hash filter with ofld is not supported by FW\\n\");\n\t}\n\n\t \n\tmemset(&caps_cmd, 0, sizeof(caps_cmd));\n\tcaps_cmd.op_to_write =\n\t\thtonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t      FW_CMD_REQUEST_F |\n\t\t      FW_CMD_READ_F);\n\tcaps_cmd.cfvalid_to_len16 =\n\t\thtonl(FW_CAPS_CONFIG_CMD_CFVALID_F |\n\t\t      FW_CAPS_CONFIG_CMD_MEMTYPE_CF_V(mtype) |\n\t\t      FW_CAPS_CONFIG_CMD_MEMADDR64K_CF_V(maddr >> 16) |\n\t\t      FW_LEN16(caps_cmd));\n\tret = t4_wr_mbox(adapter, adapter->mbox, &caps_cmd, sizeof(caps_cmd),\n\t\t\t &caps_cmd);\n\n\t \n\tif (ret == -ENOENT) {\n\t\tmemset(&caps_cmd, 0, sizeof(caps_cmd));\n\t\tcaps_cmd.op_to_write =\n\t\t\thtonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t\t\t\tFW_CMD_REQUEST_F |\n\t\t\t\t\tFW_CMD_READ_F);\n\t\tcaps_cmd.cfvalid_to_len16 = htonl(FW_LEN16(caps_cmd));\n\t\tret = t4_wr_mbox(adapter, adapter->mbox, &caps_cmd,\n\t\t\t\tsizeof(caps_cmd), &caps_cmd);\n\t\tconfig_name = \"Firmware Default\";\n\t}\n\n\tconfig_issued = 1;\n\tif (ret < 0)\n\t\tgoto bye;\n\n\tfiniver = ntohl(caps_cmd.finiver);\n\tfinicsum = ntohl(caps_cmd.finicsum);\n\tcfcsum = ntohl(caps_cmd.cfcsum);\n\tif (finicsum != cfcsum)\n\t\tdev_warn(adapter->pdev_dev, \"Configuration File checksum \"\\\n\t\t\t \"mismatch: [fini] csum=%#x, computed csum=%#x\\n\",\n\t\t\t finicsum, cfcsum);\n\n\t \n\tcaps_cmd.op_to_write =\n\t\thtonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t      FW_CMD_REQUEST_F |\n\t\t      FW_CMD_WRITE_F);\n\tcaps_cmd.cfvalid_to_len16 = htonl(FW_LEN16(caps_cmd));\n\tret = t4_wr_mbox(adapter, adapter->mbox, &caps_cmd, sizeof(caps_cmd),\n\t\t\t NULL);\n\tif (ret < 0)\n\t\tgoto bye;\n\n\t \n\tret = adap_init0_tweaks(adapter);\n\tif (ret < 0)\n\t\tgoto bye;\n\n\t \n\tret = adap_config_hma(adapter);\n\tif (ret)\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"HMA configuration failed with error %d\\n\", ret);\n\n\tif (is_t6(adapter->params.chip)) {\n\t\tadap_config_hpfilter(adapter);\n\t\tret = setup_ppod_edram(adapter);\n\t\tif (!ret)\n\t\t\tdev_info(adapter->pdev_dev, \"Successfully enabled \"\n\t\t\t\t \"ppod edram feature\\n\");\n\t}\n\n\t \n\tret = t4_fw_initialize(adapter, adapter->mbox);\n\tif (ret < 0)\n\t\tgoto bye;\n\n\t \n\tdev_info(adapter->pdev_dev, \"Successfully configured using Firmware \"\\\n\t\t \"Configuration File \\\"%s\\\", version %#x, computed checksum %#x\\n\",\n\t\t config_name, finiver, cfcsum);\n\treturn 0;\n\n\t \nbye:\n\tif (config_issued && ret != -ENOENT)\n\t\tdev_warn(adapter->pdev_dev, \"\\\"%s\\\" configuration file error %d\\n\",\n\t\t\t config_name, -ret);\n\treturn ret;\n}\n\nstatic struct fw_info fw_info_array[] = {\n\t{\n\t\t.chip = CHELSIO_T4,\n\t\t.fs_name = FW4_CFNAME,\n\t\t.fw_mod_name = FW4_FNAME,\n\t\t.fw_hdr = {\n\t\t\t.chip = FW_HDR_CHIP_T4,\n\t\t\t.fw_ver = __cpu_to_be32(FW_VERSION(T4)),\n\t\t\t.intfver_nic = FW_INTFVER(T4, NIC),\n\t\t\t.intfver_vnic = FW_INTFVER(T4, VNIC),\n\t\t\t.intfver_ri = FW_INTFVER(T4, RI),\n\t\t\t.intfver_iscsi = FW_INTFVER(T4, ISCSI),\n\t\t\t.intfver_fcoe = FW_INTFVER(T4, FCOE),\n\t\t},\n\t}, {\n\t\t.chip = CHELSIO_T5,\n\t\t.fs_name = FW5_CFNAME,\n\t\t.fw_mod_name = FW5_FNAME,\n\t\t.fw_hdr = {\n\t\t\t.chip = FW_HDR_CHIP_T5,\n\t\t\t.fw_ver = __cpu_to_be32(FW_VERSION(T5)),\n\t\t\t.intfver_nic = FW_INTFVER(T5, NIC),\n\t\t\t.intfver_vnic = FW_INTFVER(T5, VNIC),\n\t\t\t.intfver_ri = FW_INTFVER(T5, RI),\n\t\t\t.intfver_iscsi = FW_INTFVER(T5, ISCSI),\n\t\t\t.intfver_fcoe = FW_INTFVER(T5, FCOE),\n\t\t},\n\t}, {\n\t\t.chip = CHELSIO_T6,\n\t\t.fs_name = FW6_CFNAME,\n\t\t.fw_mod_name = FW6_FNAME,\n\t\t.fw_hdr = {\n\t\t\t.chip = FW_HDR_CHIP_T6,\n\t\t\t.fw_ver = __cpu_to_be32(FW_VERSION(T6)),\n\t\t\t.intfver_nic = FW_INTFVER(T6, NIC),\n\t\t\t.intfver_vnic = FW_INTFVER(T6, VNIC),\n\t\t\t.intfver_ofld = FW_INTFVER(T6, OFLD),\n\t\t\t.intfver_ri = FW_INTFVER(T6, RI),\n\t\t\t.intfver_iscsipdu = FW_INTFVER(T6, ISCSIPDU),\n\t\t\t.intfver_iscsi = FW_INTFVER(T6, ISCSI),\n\t\t\t.intfver_fcoepdu = FW_INTFVER(T6, FCOEPDU),\n\t\t\t.intfver_fcoe = FW_INTFVER(T6, FCOE),\n\t\t},\n\t}\n\n};\n\nstatic struct fw_info *find_fw_info(int chip)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fw_info_array); i++) {\n\t\tif (fw_info_array[i].chip == chip)\n\t\t\treturn &fw_info_array[i];\n\t}\n\treturn NULL;\n}\n\n \nstatic int adap_init0(struct adapter *adap, int vpd_skip)\n{\n\tstruct fw_caps_config_cmd caps_cmd;\n\tu32 params[7], val[7];\n\tenum dev_state state;\n\tu32 v, port_vec;\n\tint reset = 1;\n\tint ret;\n\n\t \n\tret = t4_init_devlog_params(adap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = t4_fw_hello(adap, adap->mbox, adap->mbox,\n\t\t\t  is_kdump_kernel() ? MASTER_MUST : MASTER_MAY, &state);\n\tif (ret < 0) {\n\t\tdev_err(adap->pdev_dev, \"could not connect to FW, error %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tif (ret == adap->mbox)\n\t\tadap->flags |= CXGB4_MASTER_PF;\n\n\t \n\n\tt4_get_version_info(adap);\n\tret = t4_check_fw_version(adap);\n\t \n\tif (ret)\n\t\tstate = DEV_STATE_UNINIT;\n\tif ((adap->flags & CXGB4_MASTER_PF) && state != DEV_STATE_INIT) {\n\t\tstruct fw_info *fw_info;\n\t\tstruct fw_hdr *card_fw;\n\t\tconst struct firmware *fw;\n\t\tconst u8 *fw_data = NULL;\n\t\tunsigned int fw_size = 0;\n\n\t\t \n\t\tfw_info = find_fw_info(CHELSIO_CHIP_VERSION(adap->params.chip));\n\t\tif (fw_info == NULL) {\n\t\t\tdev_err(adap->pdev_dev,\n\t\t\t\t\"unable to get firmware info for chip %d.\\n\",\n\t\t\t\tCHELSIO_CHIP_VERSION(adap->params.chip));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tcard_fw = kvzalloc(sizeof(*card_fw), GFP_KERNEL);\n\t\tif (!card_fw) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto bye;\n\t\t}\n\n\t\t \n\t\tret = request_firmware(&fw, fw_info->fw_mod_name,\n\t\t\t\t       adap->pdev_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(adap->pdev_dev,\n\t\t\t\t\"unable to load firmware image %s, error %d\\n\",\n\t\t\t\tfw_info->fw_mod_name, ret);\n\t\t} else {\n\t\t\tfw_data = fw->data;\n\t\t\tfw_size = fw->size;\n\t\t}\n\n\t\t \n\t\tret = t4_prep_fw(adap, fw_info, fw_data, fw_size, card_fw,\n\t\t\t\t state, &reset);\n\n\t\t \n\t\trelease_firmware(fw);\n\t\tkvfree(card_fw);\n\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t}\n\n\t \n\tif (state == DEV_STATE_INIT) {\n\t\tret = adap_config_hma(adap);\n\t\tif (ret)\n\t\t\tdev_err(adap->pdev_dev,\n\t\t\t\t\"HMA configuration failed with error %d\\n\",\n\t\t\t\tret);\n\t\tdev_info(adap->pdev_dev, \"Coming up as %s: \"\\\n\t\t\t \"Adapter already initialized\\n\",\n\t\t\t adap->flags & CXGB4_MASTER_PF ? \"MASTER\" : \"SLAVE\");\n\t} else {\n\t\tdev_info(adap->pdev_dev, \"Coming up as MASTER: \"\\\n\t\t\t \"Initializing adapter\\n\");\n\n\t\t \n\t\tparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t\t     FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_CF));\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1,\n\t\t\t\t      params, val);\n\n\t\t \n\t\tif (ret < 0) {\n\t\t\tdev_err(adap->pdev_dev, \"firmware doesn't support \"\n\t\t\t\t\"Firmware Configuration Files\\n\");\n\t\t\tgoto bye;\n\t\t}\n\n\t\t \n\t\tret = adap_init0_config(adap, reset);\n\t\tif (ret == -ENOENT) {\n\t\t\tdev_err(adap->pdev_dev, \"no Configuration File \"\n\t\t\t\t\"present on adapter.\\n\");\n\t\t\tgoto bye;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(adap->pdev_dev, \"could not initialize \"\n\t\t\t\t\"adapter, error %d\\n\", -ret);\n\t\t\tgoto bye;\n\t\t}\n\t}\n\n\t \n\tret = t4_get_pfres(adap);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Unable to retrieve resource provisioning information\\n\");\n\t\tgoto bye;\n\t}\n\n\t \n\tif (!vpd_skip) {\n\t\tret = t4_get_vpd_params(adap, &adap->params.vpd);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t}\n\n\t \n\tv =\n\t    FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t    FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_PORTVEC);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1, &v, &port_vec);\n\tif (ret < 0)\n\t\tgoto bye;\n\n\tadap->params.nports = hweight32(port_vec);\n\tadap->params.portvec = port_vec;\n\n\t \n\tret = t4_sge_init(adap);\n\tif (ret < 0)\n\t\tgoto bye;\n\n\t \n\tparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t    FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_DBQ_TIMERTICK));\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t      1, params, val);\n\n\tif (!ret) {\n\t\tadap->sge.dbqtimer_tick = val[0];\n\t\tret = t4_read_sge_dbqtimers(adap,\n\t\t\t\t\t    ARRAY_SIZE(adap->sge.dbqtimer_val),\n\t\t\t\t\t    adap->sge.dbqtimer_val);\n\t}\n\n\tif (!ret)\n\t\tadap->flags |= CXGB4_SGE_DBQ_TIMER;\n\n\tif (is_bypass_device(adap->pdev->device))\n\t\tadap->params.bypass = 1;\n\n\t \n\tparams[0] = FW_PARAM_PFVF(EQ_START);\n\tparams[1] = FW_PARAM_PFVF(L2T_START);\n\tparams[2] = FW_PARAM_PFVF(L2T_END);\n\tparams[3] = FW_PARAM_PFVF(FILTER_START);\n\tparams[4] = FW_PARAM_PFVF(FILTER_END);\n\tparams[5] = FW_PARAM_PFVF(IQFLINT_START);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 6, params, val);\n\tif (ret < 0)\n\t\tgoto bye;\n\tadap->sge.egr_start = val[0];\n\tadap->l2t_start = val[1];\n\tadap->l2t_end = val[2];\n\tadap->tids.ftid_base = val[3];\n\tadap->tids.nftids = val[4] - val[3] + 1;\n\tadap->sge.ingr_start = val[5];\n\n\tif (CHELSIO_CHIP_VERSION(adap->params.chip) > CHELSIO_T5) {\n\t\tparams[0] = FW_PARAM_PFVF(HPFILTER_START);\n\t\tparams[1] = FW_PARAM_PFVF(HPFILTER_END);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2,\n\t\t\t\t      params, val);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\n\t\tadap->tids.hpftid_base = val[0];\n\t\tadap->tids.nhpftids = val[1] - val[0] + 1;\n\n\t\t \n\t\tparams[0] = FW_PARAM_PFVF(RAWF_START);\n\t\tparams[1] = FW_PARAM_PFVF(RAWF_END);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2,\n\t\t\t\t      params, val);\n\t\tif (ret == 0) {\n\t\t\tadap->rawf_start = val[0];\n\t\t\tadap->rawf_cnt = val[1] - val[0] + 1;\n\t\t}\n\n\t\tadap->tids.tid_base =\n\t\t\tt4_read_reg(adap, LE_DB_ACTIVE_TABLE_START_INDEX_A);\n\t}\n\n\t \n\tparams[0] = FW_PARAM_PFVF(EQ_END);\n\tparams[1] = FW_PARAM_PFVF(IQFLINT_END);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2, params, val);\n\tif (ret < 0)\n\t\tgoto bye;\n\tadap->sge.egr_sz = val[0] - adap->sge.egr_start + 1;\n\tadap->sge.ingr_sz = val[1] - adap->sge.ingr_start + 1;\n\n\tadap->sge.egr_map = kcalloc(adap->sge.egr_sz,\n\t\t\t\t    sizeof(*adap->sge.egr_map), GFP_KERNEL);\n\tif (!adap->sge.egr_map) {\n\t\tret = -ENOMEM;\n\t\tgoto bye;\n\t}\n\n\tadap->sge.ingr_map = kcalloc(adap->sge.ingr_sz,\n\t\t\t\t     sizeof(*adap->sge.ingr_map), GFP_KERNEL);\n\tif (!adap->sge.ingr_map) {\n\t\tret = -ENOMEM;\n\t\tgoto bye;\n\t}\n\n\t \n\tadap->sge.starving_fl = bitmap_zalloc(adap->sge.egr_sz, GFP_KERNEL);\n\tif (!adap->sge.starving_fl) {\n\t\tret = -ENOMEM;\n\t\tgoto bye;\n\t}\n\n\tadap->sge.txq_maperr = bitmap_zalloc(adap->sge.egr_sz, GFP_KERNEL);\n\tif (!adap->sge.txq_maperr) {\n\t\tret = -ENOMEM;\n\t\tgoto bye;\n\t}\n\n#ifdef CONFIG_DEBUG_FS\n\tadap->sge.blocked_fl = bitmap_zalloc(adap->sge.egr_sz, GFP_KERNEL);\n\tif (!adap->sge.blocked_fl) {\n\t\tret = -ENOMEM;\n\t\tgoto bye;\n\t}\n#endif\n\n\tparams[0] = FW_PARAM_PFVF(CLIP_START);\n\tparams[1] = FW_PARAM_PFVF(CLIP_END);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2, params, val);\n\tif (ret < 0)\n\t\tgoto bye;\n\tadap->clipt_start = val[0];\n\tadap->clipt_end = val[1];\n\n\t \n\tparams[0] = FW_PARAM_DEV(NUM_TM_CLASS);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1, params, val);\n\tif (ret < 0) {\n\t\t \n\t\tadap->params.nsched_cls = is_t4(adap->params.chip) ? 15 : 16;\n\t} else {\n\t\tadap->params.nsched_cls = val[0];\n\t}\n\n\t \n\tparams[0] = FW_PARAM_PFVF(ACTIVE_FILTER_START);\n\tparams[1] = FW_PARAM_PFVF(ACTIVE_FILTER_END);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2, params, val);\n\t \n\tif ((val[0] != val[1]) && (ret >= 0)) {\n\t\tadap->flags |= CXGB4_FW_OFLD_CONN;\n\t\tadap->tids.aftid_base = val[0];\n\t\tadap->tids.aftid_end = val[1];\n\t}\n\n\t \n\tparams[0] = FW_PARAM_PFVF(CPLFW4MSG_ENCAP);\n\tval[0] = 1;\n\t(void)t4_set_params(adap, adap->mbox, adap->pf, 0, 1, params, val);\n\n\t \n\tif (is_t4(adap->params.chip)) {\n\t\tadap->params.ulptx_memwrite_dsgl = false;\n\t} else {\n\t\tparams[0] = FW_PARAM_DEV(ULPTX_MEMWRITE_DSGL);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t\t      1, params, val);\n\t\tadap->params.ulptx_memwrite_dsgl = (ret == 0 && val[0] != 0);\n\t}\n\n\t \n\tparams[0] = FW_PARAM_DEV(RI_FR_NSMR_TPTE_WR);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t      1, params, val);\n\tadap->params.fr_nsmr_tpte_wr_support = (ret == 0 && val[0] != 0);\n\n\t \n\tif (is_t4(adap->params.chip)) {\n\t\tadap->params.filter2_wr_support = false;\n\t} else {\n\t\tparams[0] = FW_PARAM_DEV(FILTER2_WR);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t\t      1, params, val);\n\t\tadap->params.filter2_wr_support = (ret == 0 && val[0] != 0);\n\t}\n\n\t \n\tparams[0] = FW_PARAM_DEV(OPAQUE_VIID_SMT_EXTN);\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t      1, params, val);\n\tadap->params.viid_smt_extn_support = (ret == 0 && val[0] != 0);\n\n\t \n\tmemset(&caps_cmd, 0, sizeof(caps_cmd));\n\tcaps_cmd.op_to_write = htonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F | FW_CMD_READ_F);\n\tcaps_cmd.cfvalid_to_len16 = htonl(FW_LEN16(caps_cmd));\n\tret = t4_wr_mbox(adap, adap->mbox, &caps_cmd, sizeof(caps_cmd),\n\t\t\t &caps_cmd);\n\tif (ret < 0)\n\t\tgoto bye;\n\n\t \n\tif (caps_cmd.ofldcaps)\n\t\tadap->params.offload = 1;\n\n\tif (caps_cmd.ofldcaps ||\n\t    (caps_cmd.niccaps & htons(FW_CAPS_CONFIG_NIC_HASHFILTER)) ||\n\t    (caps_cmd.niccaps & htons(FW_CAPS_CONFIG_NIC_ETHOFLD))) {\n\t\t \n\t\tparams[0] = FW_PARAM_DEV(NTID);\n\t\tparams[1] = FW_PARAM_PFVF(SERVER_START);\n\t\tparams[2] = FW_PARAM_PFVF(SERVER_END);\n\t\tparams[3] = FW_PARAM_PFVF(TDDP_START);\n\t\tparams[4] = FW_PARAM_PFVF(TDDP_END);\n\t\tparams[5] = FW_PARAM_DEV(FLOWC_BUFFIFO_SZ);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 6,\n\t\t\t\t      params, val);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t\tadap->tids.ntids = val[0];\n\t\tadap->tids.natids = min(adap->tids.ntids / 2, MAX_ATIDS);\n\t\tadap->tids.stid_base = val[1];\n\t\tadap->tids.nstids = val[2] - val[1] + 1;\n\t\t \n\t\tif (adap->flags & CXGB4_FW_OFLD_CONN && !is_bypass(adap)) {\n\t\t\tadap->tids.sftid_base = adap->tids.ftid_base +\n\t\t\t\t\tDIV_ROUND_UP(adap->tids.nftids, 3);\n\t\t\tadap->tids.nsftids = adap->tids.nftids -\n\t\t\t\t\t DIV_ROUND_UP(adap->tids.nftids, 3);\n\t\t\tadap->tids.nftids = adap->tids.sftid_base -\n\t\t\t\t\t\tadap->tids.ftid_base;\n\t\t}\n\t\tadap->vres.ddp.start = val[3];\n\t\tadap->vres.ddp.size = val[4] - val[3] + 1;\n\t\tadap->params.ofldq_wr_cred = val[5];\n\n\t\tif (caps_cmd.niccaps & htons(FW_CAPS_CONFIG_NIC_HASHFILTER)) {\n\t\t\tinit_hash_filter(adap);\n\t\t} else {\n\t\t\tadap->num_ofld_uld += 1;\n\t\t}\n\n\t\tif (caps_cmd.niccaps & htons(FW_CAPS_CONFIG_NIC_ETHOFLD)) {\n\t\t\tparams[0] = FW_PARAM_PFVF(ETHOFLD_START);\n\t\t\tparams[1] = FW_PARAM_PFVF(ETHOFLD_END);\n\t\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2,\n\t\t\t\t\t      params, val);\n\t\t\tif (!ret) {\n\t\t\t\tadap->tids.eotid_base = val[0];\n\t\t\t\tadap->tids.neotids = min_t(u32, MAX_ATIDS,\n\t\t\t\t\t\t\t   val[1] - val[0] + 1);\n\t\t\t\tadap->params.ethofld = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (caps_cmd.rdmacaps) {\n\t\tparams[0] = FW_PARAM_PFVF(STAG_START);\n\t\tparams[1] = FW_PARAM_PFVF(STAG_END);\n\t\tparams[2] = FW_PARAM_PFVF(RQ_START);\n\t\tparams[3] = FW_PARAM_PFVF(RQ_END);\n\t\tparams[4] = FW_PARAM_PFVF(PBL_START);\n\t\tparams[5] = FW_PARAM_PFVF(PBL_END);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 6,\n\t\t\t\t      params, val);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t\tadap->vres.stag.start = val[0];\n\t\tadap->vres.stag.size = val[1] - val[0] + 1;\n\t\tadap->vres.rq.start = val[2];\n\t\tadap->vres.rq.size = val[3] - val[2] + 1;\n\t\tadap->vres.pbl.start = val[4];\n\t\tadap->vres.pbl.size = val[5] - val[4] + 1;\n\n\t\tparams[0] = FW_PARAM_PFVF(SRQ_START);\n\t\tparams[1] = FW_PARAM_PFVF(SRQ_END);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2,\n\t\t\t\t      params, val);\n\t\tif (!ret) {\n\t\t\tadap->vres.srq.start = val[0];\n\t\t\tadap->vres.srq.size = val[1] - val[0] + 1;\n\t\t}\n\t\tif (adap->vres.srq.size) {\n\t\t\tadap->srq = t4_init_srq(adap->vres.srq.size);\n\t\t\tif (!adap->srq)\n\t\t\t\tdev_warn(&adap->pdev->dev, \"could not allocate SRQ, continuing\\n\");\n\t\t}\n\n\t\tparams[0] = FW_PARAM_PFVF(SQRQ_START);\n\t\tparams[1] = FW_PARAM_PFVF(SQRQ_END);\n\t\tparams[2] = FW_PARAM_PFVF(CQ_START);\n\t\tparams[3] = FW_PARAM_PFVF(CQ_END);\n\t\tparams[4] = FW_PARAM_PFVF(OCQ_START);\n\t\tparams[5] = FW_PARAM_PFVF(OCQ_END);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 6, params,\n\t\t\t\t      val);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t\tadap->vres.qp.start = val[0];\n\t\tadap->vres.qp.size = val[1] - val[0] + 1;\n\t\tadap->vres.cq.start = val[2];\n\t\tadap->vres.cq.size = val[3] - val[2] + 1;\n\t\tadap->vres.ocq.start = val[4];\n\t\tadap->vres.ocq.size = val[5] - val[4] + 1;\n\n\t\tparams[0] = FW_PARAM_DEV(MAXORDIRD_QP);\n\t\tparams[1] = FW_PARAM_DEV(MAXIRD_ADAPTER);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2, params,\n\t\t\t\t      val);\n\t\tif (ret < 0) {\n\t\t\tadap->params.max_ordird_qp = 8;\n\t\t\tadap->params.max_ird_adapter = 32 * adap->tids.ntids;\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tadap->params.max_ordird_qp = val[0];\n\t\t\tadap->params.max_ird_adapter = val[1];\n\t\t}\n\t\tdev_info(adap->pdev_dev,\n\t\t\t \"max_ordird_qp %d max_ird_adapter %d\\n\",\n\t\t\t adap->params.max_ordird_qp,\n\t\t\t adap->params.max_ird_adapter);\n\n\t\t \n\t\tparams[0] = FW_PARAM_DEV(RDMA_WRITE_WITH_IMM);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1, params,\n\t\t\t\t      val);\n\t\tadap->params.write_w_imm_support = (ret == 0 && val[0] != 0);\n\n\t\t \n\t\tparams[0] = FW_PARAM_DEV(RI_WRITE_CMPL_WR);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1, params,\n\t\t\t\t      val);\n\t\tadap->params.write_cmpl_support = (ret == 0 && val[0] != 0);\n\t\tadap->num_ofld_uld += 2;\n\t}\n\tif (caps_cmd.iscsicaps) {\n\t\tparams[0] = FW_PARAM_PFVF(ISCSI_START);\n\t\tparams[1] = FW_PARAM_PFVF(ISCSI_END);\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2,\n\t\t\t\t      params, val);\n\t\tif (ret < 0)\n\t\t\tgoto bye;\n\t\tadap->vres.iscsi.start = val[0];\n\t\tadap->vres.iscsi.size = val[1] - val[0] + 1;\n\t\tif (is_t6(adap->params.chip)) {\n\t\t\tparams[0] = FW_PARAM_PFVF(PPOD_EDRAM_START);\n\t\t\tparams[1] = FW_PARAM_PFVF(PPOD_EDRAM_END);\n\t\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2,\n\t\t\t\t\t      params, val);\n\t\t\tif (!ret) {\n\t\t\t\tadap->vres.ppod_edram.start = val[0];\n\t\t\t\tadap->vres.ppod_edram.size =\n\t\t\t\t\tval[1] - val[0] + 1;\n\n\t\t\t\tdev_info(adap->pdev_dev,\n\t\t\t\t\t \"ppod edram start 0x%x end 0x%x size 0x%x\\n\",\n\t\t\t\t\t val[0], val[1],\n\t\t\t\t\t adap->vres.ppod_edram.size);\n\t\t\t}\n\t\t}\n\t\t \n\t\tadap->num_ofld_uld += 2;\n\t}\n\tif (caps_cmd.cryptocaps) {\n\t\tif (ntohs(caps_cmd.cryptocaps) &\n\t\t    FW_CAPS_CONFIG_CRYPTO_LOOKASIDE) {\n\t\t\tparams[0] = FW_PARAM_PFVF(NCRYPTO_LOOKASIDE);\n\t\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t\t\t      2, params, val);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (ret != -EINVAL)\n\t\t\t\t\tgoto bye;\n\t\t\t} else {\n\t\t\t\tadap->vres.ncrypto_fc = val[0];\n\t\t\t}\n\t\t\tadap->num_ofld_uld += 1;\n\t\t}\n\t\tif (ntohs(caps_cmd.cryptocaps) &\n\t\t    FW_CAPS_CONFIG_TLS_INLINE) {\n\t\t\tparams[0] = FW_PARAM_PFVF(TLS_START);\n\t\t\tparams[1] = FW_PARAM_PFVF(TLS_END);\n\t\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t\t\t      2, params, val);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto bye;\n\t\t\tadap->vres.key.start = val[0];\n\t\t\tadap->vres.key.size = val[1] - val[0] + 1;\n\t\t\tadap->num_uld += 1;\n\t\t}\n\t\tadap->params.crypto = ntohs(caps_cmd.cryptocaps);\n\t}\n\n\t \n\tt4_read_mtu_tbl(adap, adap->params.mtus, NULL);\n\tif (state != DEV_STATE_INIT) {\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < NMTUS; i++)\n\t\t\tif (adap->params.mtus[i] == 1492) {\n\t\t\t\tadap->params.mtus[i] = 1488;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tt4_load_mtus(adap, adap->params.mtus, adap->params.a_wnd,\n\t\t\t     adap->params.b_wnd);\n\t}\n\tt4_init_sge_params(adap);\n\tadap->flags |= CXGB4_FW_OK;\n\tt4_init_tp_params(adap, true);\n\treturn 0;\n\n\t \nbye:\n\tadap_free_hma_mem(adap);\n\tkfree(adap->sge.egr_map);\n\tkfree(adap->sge.ingr_map);\n\tbitmap_free(adap->sge.starving_fl);\n\tbitmap_free(adap->sge.txq_maperr);\n#ifdef CONFIG_DEBUG_FS\n\tbitmap_free(adap->sge.blocked_fl);\n#endif\n\tif (ret != -ETIMEDOUT && ret != -EIO)\n\t\tt4_fw_bye(adap, adap->mbox);\n\treturn ret;\n}\n\n \n\nstatic pci_ers_result_t eeh_err_detected(struct pci_dev *pdev,\n\t\t\t\t\t pci_channel_state_t state)\n{\n\tint i;\n\tstruct adapter *adap = pci_get_drvdata(pdev);\n\n\tif (!adap)\n\t\tgoto out;\n\n\trtnl_lock();\n\tadap->flags &= ~CXGB4_FW_OK;\n\tnotify_ulds(adap, CXGB4_STATE_START_RECOVERY);\n\tspin_lock(&adap->stats_lock);\n\tfor_each_port(adap, i) {\n\t\tstruct net_device *dev = adap->port[i];\n\t\tif (dev) {\n\t\t\tnetif_device_detach(dev);\n\t\t\tnetif_carrier_off(dev);\n\t\t}\n\t}\n\tspin_unlock(&adap->stats_lock);\n\tdisable_interrupts(adap);\n\tif (adap->flags & CXGB4_FULL_INIT_DONE)\n\t\tcxgb_down(adap);\n\trtnl_unlock();\n\tif ((adap->flags & CXGB4_DEV_ENABLED)) {\n\t\tpci_disable_device(pdev);\n\t\tadap->flags &= ~CXGB4_DEV_ENABLED;\n\t}\nout:\treturn state == pci_channel_io_perm_failure ?\n\t\tPCI_ERS_RESULT_DISCONNECT : PCI_ERS_RESULT_NEED_RESET;\n}\n\nstatic pci_ers_result_t eeh_slot_reset(struct pci_dev *pdev)\n{\n\tint i, ret;\n\tstruct fw_caps_config_cmd c;\n\tstruct adapter *adap = pci_get_drvdata(pdev);\n\n\tif (!adap) {\n\t\tpci_restore_state(pdev);\n\t\tpci_save_state(pdev);\n\t\treturn PCI_ERS_RESULT_RECOVERED;\n\t}\n\n\tif (!(adap->flags & CXGB4_DEV_ENABLED)) {\n\t\tif (pci_enable_device(pdev)) {\n\t\t\tdev_err(&pdev->dev, \"Cannot reenable PCI \"\n\t\t\t\t\t    \"device after reset\\n\");\n\t\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t\t}\n\t\tadap->flags |= CXGB4_DEV_ENABLED;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_restore_state(pdev);\n\tpci_save_state(pdev);\n\n\tif (t4_wait_dev_ready(adap->regs) < 0)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\tif (t4_fw_hello(adap, adap->mbox, adap->pf, MASTER_MUST, NULL) < 0)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\tadap->flags |= CXGB4_FW_OK;\n\tif (adap_init1(adap, &c))\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tfor_each_port(adap, i) {\n\t\tstruct port_info *pi = adap2pinfo(adap, i);\n\t\tu8 vivld = 0, vin = 0;\n\n\t\tret = t4_alloc_vi(adap, adap->mbox, pi->tx_chan, adap->pf, 0, 1,\n\t\t\t\t  NULL, NULL, &vivld, &vin);\n\t\tif (ret < 0)\n\t\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t\tpi->viid = ret;\n\t\tpi->xact_addr_filt = -1;\n\t\t \n\t\tif (adap->params.viid_smt_extn_support) {\n\t\t\tpi->vivld = vivld;\n\t\t\tpi->vin = vin;\n\t\t} else {\n\t\t\t \n\t\t\tpi->vivld = FW_VIID_VIVLD_G(pi->viid);\n\t\t\tpi->vin = FW_VIID_VIN_G(pi->viid);\n\t\t}\n\t}\n\n\tt4_load_mtus(adap, adap->params.mtus, adap->params.a_wnd,\n\t\t     adap->params.b_wnd);\n\tsetup_memwin(adap);\n\tif (cxgb_up(adap))\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic void eeh_resume(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct adapter *adap = pci_get_drvdata(pdev);\n\n\tif (!adap)\n\t\treturn;\n\n\trtnl_lock();\n\tfor_each_port(adap, i) {\n\t\tstruct net_device *dev = adap->port[i];\n\t\tif (dev) {\n\t\t\tif (netif_running(dev)) {\n\t\t\t\tlink_start(dev);\n\t\t\t\tcxgb_set_rxmode(dev);\n\t\t\t}\n\t\t\tnetif_device_attach(dev);\n\t\t}\n\t}\n\trtnl_unlock();\n}\n\nstatic void eeh_reset_prepare(struct pci_dev *pdev)\n{\n\tstruct adapter *adapter = pci_get_drvdata(pdev);\n\tint i;\n\n\tif (adapter->pf != 4)\n\t\treturn;\n\n\tadapter->flags &= ~CXGB4_FW_OK;\n\n\tnotify_ulds(adapter, CXGB4_STATE_DOWN);\n\n\tfor_each_port(adapter, i)\n\t\tif (adapter->port[i]->reg_state == NETREG_REGISTERED)\n\t\t\tcxgb_close(adapter->port[i]);\n\n\tdisable_interrupts(adapter);\n\tcxgb4_free_mps_ref_entries(adapter);\n\n\tadap_free_hma_mem(adapter);\n\n\tif (adapter->flags & CXGB4_FULL_INIT_DONE)\n\t\tcxgb_down(adapter);\n}\n\nstatic void eeh_reset_done(struct pci_dev *pdev)\n{\n\tstruct adapter *adapter = pci_get_drvdata(pdev);\n\tint err, i;\n\n\tif (adapter->pf != 4)\n\t\treturn;\n\n\terr = t4_wait_dev_ready(adapter->regs);\n\tif (err < 0) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"Device not ready, err %d\", err);\n\t\treturn;\n\t}\n\n\tsetup_memwin(adapter);\n\n\terr = adap_init0(adapter, 1);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"Adapter init failed, err %d\", err);\n\t\treturn;\n\t}\n\n\tsetup_memwin_rdma(adapter);\n\n\tif (adapter->flags & CXGB4_FW_OK) {\n\t\terr = t4_port_init(adapter, adapter->pf, adapter->pf, 0);\n\t\tif (err) {\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"Port init failed, err %d\", err);\n\t\t\treturn;\n\t\t}\n\t}\n\n\terr = cfg_queues(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"Config queues failed, err %d\", err);\n\t\treturn;\n\t}\n\n\tcxgb4_init_mps_ref_entries(adapter);\n\n\terr = setup_fw_sge_queues(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"FW sge queue allocation failed, err %d\", err);\n\t\treturn;\n\t}\n\n\tfor_each_port(adapter, i)\n\t\tif (adapter->port[i]->reg_state == NETREG_REGISTERED)\n\t\t\tcxgb_open(adapter->port[i]);\n}\n\nstatic const struct pci_error_handlers cxgb4_eeh = {\n\t.error_detected = eeh_err_detected,\n\t.slot_reset     = eeh_slot_reset,\n\t.resume         = eeh_resume,\n\t.reset_prepare  = eeh_reset_prepare,\n\t.reset_done     = eeh_reset_done,\n};\n\n \nstatic inline bool is_x_10g_port(const struct link_config *lc)\n{\n\tunsigned int speeds, high_speeds;\n\n\tspeeds = FW_PORT_CAP32_SPEED_V(FW_PORT_CAP32_SPEED_G(lc->pcaps));\n\thigh_speeds = speeds &\n\t\t\t~(FW_PORT_CAP32_SPEED_100M | FW_PORT_CAP32_SPEED_1G);\n\n\treturn high_speeds != 0;\n}\n\n \nstatic int cfg_queues(struct adapter *adap)\n{\n\tu32 avail_qsets, avail_eth_qsets, avail_uld_qsets;\n\tu32 ncpus = num_online_cpus();\n\tu32 niqflint, neq, num_ulds;\n\tstruct sge *s = &adap->sge;\n\tu32 i, n10g = 0, qidx = 0;\n\tu32 q10g = 0, q1g;\n\n\t \n\tif (is_kdump_kernel() || (is_uld(adap) && t4_uld_mem_alloc(adap))) {\n\t\tadap->params.offload = 0;\n\t\tadap->params.crypto = 0;\n\t\tadap->params.ethofld = 0;\n\t}\n\n\t \n\tniqflint = adap->params.pfres.niqflint - 1;\n\tif (!(adap->flags & CXGB4_USING_MSIX))\n\t\tniqflint--;\n\tneq = adap->params.pfres.neq / 2;\n\tavail_qsets = min(niqflint, neq);\n\n\tif (avail_qsets < adap->params.nports) {\n\t\tdev_err(adap->pdev_dev, \"avail_eth_qsets=%d < nports=%d\\n\",\n\t\t\tavail_qsets, adap->params.nports);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor_each_port(adap, i)\n\t\tn10g += is_x_10g_port(&adap2pinfo(adap, i)->link_cfg);\n\n\tavail_eth_qsets = min_t(u32, avail_qsets, MAX_ETH_QSETS);\n\n\t \n\tif (n10g)\n\t\tq10g = (avail_eth_qsets - (adap->params.nports - n10g)) / n10g;\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n\t \n\tq1g = 8;\n\tif (adap->params.nports * 8 > avail_eth_qsets) {\n\t\tdev_err(adap->pdev_dev, \"DCB avail_eth_qsets=%d < %d!\\n\",\n\t\t\tavail_eth_qsets, adap->params.nports * 8);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (adap->params.nports * ncpus < avail_eth_qsets)\n\t\tq10g = max(8U, ncpus);\n\telse\n\t\tq10g = max(8U, q10g);\n\n\twhile ((q10g * n10g) >\n\t       (avail_eth_qsets - (adap->params.nports - n10g) * q1g))\n\t\tq10g--;\n\n#else  \n\tq1g = 1;\n\tq10g = min(q10g, ncpus);\n#endif  \n\tif (is_kdump_kernel()) {\n\t\tq10g = 1;\n\t\tq1g = 1;\n\t}\n\n\tfor_each_port(adap, i) {\n\t\tstruct port_info *pi = adap2pinfo(adap, i);\n\n\t\tpi->first_qset = qidx;\n\t\tpi->nqsets = is_x_10g_port(&pi->link_cfg) ? q10g : q1g;\n\t\tqidx += pi->nqsets;\n\t}\n\n\ts->ethqsets = qidx;\n\ts->max_ethqsets = qidx;    \n\tavail_qsets -= qidx;\n\n\tif (is_uld(adap)) {\n\t\t \n\t\tnum_ulds = adap->num_uld + adap->num_ofld_uld;\n\t\ti = min_t(u32, MAX_OFLD_QSETS, ncpus);\n\t\tavail_uld_qsets = roundup(i, adap->params.nports);\n\t\tif (avail_qsets < num_ulds * adap->params.nports) {\n\t\t\tadap->params.offload = 0;\n\t\t\tadap->params.crypto = 0;\n\t\t\ts->ofldqsets = 0;\n\t\t} else if (avail_qsets < num_ulds * avail_uld_qsets || !n10g) {\n\t\t\ts->ofldqsets = adap->params.nports;\n\t\t} else {\n\t\t\ts->ofldqsets = avail_uld_qsets;\n\t\t}\n\n\t\tavail_qsets -= num_ulds * s->ofldqsets;\n\t}\n\n\t \n\tif (is_ethofld(adap)) {\n\t\tif (avail_qsets < s->max_ethqsets) {\n\t\t\tadap->params.ethofld = 0;\n\t\t\ts->eoqsets = 0;\n\t\t} else {\n\t\t\ts->eoqsets = s->max_ethqsets;\n\t\t}\n\t\tavail_qsets -= s->eoqsets;\n\t}\n\n\t \n\tif (avail_qsets >= s->max_ethqsets)\n\t\ts->mirrorqsets = s->max_ethqsets;\n\telse if (avail_qsets >= adap->params.nports)\n\t\ts->mirrorqsets = adap->params.nports;\n\telse\n\t\ts->mirrorqsets = 0;\n\tavail_qsets -= s->mirrorqsets;\n\n\tfor (i = 0; i < ARRAY_SIZE(s->ethrxq); i++) {\n\t\tstruct sge_eth_rxq *r = &s->ethrxq[i];\n\n\t\tinit_rspq(adap, &r->rspq, 5, 10, 1024, 64);\n\t\tr->fl.size = 72;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(s->ethtxq); i++)\n\t\ts->ethtxq[i].q.size = 1024;\n\n\tfor (i = 0; i < ARRAY_SIZE(s->ctrlq); i++)\n\t\ts->ctrlq[i].q.size = 512;\n\n\tif (!is_t4(adap->params.chip))\n\t\ts->ptptxq.q.size = 8;\n\n\tinit_rspq(adap, &s->fw_evtq, 0, 1, 1024, 64);\n\tinit_rspq(adap, &s->intrq, 0, 1, 512, 64);\n\n\treturn 0;\n}\n\n \nstatic void reduce_ethqs(struct adapter *adap, int n)\n{\n\tint i;\n\tstruct port_info *pi;\n\n\twhile (n < adap->sge.ethqsets)\n\t\tfor_each_port(adap, i) {\n\t\t\tpi = adap2pinfo(adap, i);\n\t\t\tif (pi->nqsets > 1) {\n\t\t\t\tpi->nqsets--;\n\t\t\t\tadap->sge.ethqsets--;\n\t\t\t\tif (adap->sge.ethqsets <= n)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tn = 0;\n\tfor_each_port(adap, i) {\n\t\tpi = adap2pinfo(adap, i);\n\t\tpi->first_qset = n;\n\t\tn += pi->nqsets;\n\t}\n}\n\nstatic int alloc_msix_info(struct adapter *adap, u32 num_vec)\n{\n\tstruct msix_info *msix_info;\n\n\tmsix_info = kcalloc(num_vec, sizeof(*msix_info), GFP_KERNEL);\n\tif (!msix_info)\n\t\treturn -ENOMEM;\n\n\tadap->msix_bmap.msix_bmap = bitmap_zalloc(num_vec, GFP_KERNEL);\n\tif (!adap->msix_bmap.msix_bmap) {\n\t\tkfree(msix_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&adap->msix_bmap.lock);\n\tadap->msix_bmap.mapsize = num_vec;\n\n\tadap->msix_info = msix_info;\n\treturn 0;\n}\n\nstatic void free_msix_info(struct adapter *adap)\n{\n\tbitmap_free(adap->msix_bmap.msix_bmap);\n\tkfree(adap->msix_info);\n}\n\nint cxgb4_get_msix_idx_from_bmap(struct adapter *adap)\n{\n\tstruct msix_bmap *bmap = &adap->msix_bmap;\n\tunsigned int msix_idx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bmap->lock, flags);\n\tmsix_idx = find_first_zero_bit(bmap->msix_bmap, bmap->mapsize);\n\tif (msix_idx < bmap->mapsize) {\n\t\t__set_bit(msix_idx, bmap->msix_bmap);\n\t} else {\n\t\tspin_unlock_irqrestore(&bmap->lock, flags);\n\t\treturn -ENOSPC;\n\t}\n\n\tspin_unlock_irqrestore(&bmap->lock, flags);\n\treturn msix_idx;\n}\n\nvoid cxgb4_free_msix_idx_in_bmap(struct adapter *adap,\n\t\t\t\t unsigned int msix_idx)\n{\n\tstruct msix_bmap *bmap = &adap->msix_bmap;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bmap->lock, flags);\n\t__clear_bit(msix_idx, bmap->msix_bmap);\n\tspin_unlock_irqrestore(&bmap->lock, flags);\n}\n\n \n#define EXTRA_VECS 2\n\nstatic int enable_msix(struct adapter *adap)\n{\n\tu32 eth_need, uld_need = 0, ethofld_need = 0, mirror_need = 0;\n\tu32 ethqsets = 0, ofldqsets = 0, eoqsets = 0, mirrorqsets = 0;\n\tu8 num_uld = 0, nchan = adap->params.nports;\n\tu32 i, want, need, num_vec;\n\tstruct sge *s = &adap->sge;\n\tstruct msix_entry *entries;\n\tstruct port_info *pi;\n\tint allocated, ret;\n\n\twant = s->max_ethqsets;\n#ifdef CONFIG_CHELSIO_T4_DCB\n\t \n\tneed = 8 * nchan;\n#else\n\tneed = nchan;\n#endif\n\teth_need = need;\n\tif (is_uld(adap)) {\n\t\tnum_uld = adap->num_ofld_uld + adap->num_uld;\n\t\twant += num_uld * s->ofldqsets;\n\t\tuld_need = num_uld * nchan;\n\t\tneed += uld_need;\n\t}\n\n\tif (is_ethofld(adap)) {\n\t\twant += s->eoqsets;\n\t\tethofld_need = eth_need;\n\t\tneed += ethofld_need;\n\t}\n\n\tif (s->mirrorqsets) {\n\t\twant += s->mirrorqsets;\n\t\tmirror_need = nchan;\n\t\tneed += mirror_need;\n\t}\n\n\twant += EXTRA_VECS;\n\tneed += EXTRA_VECS;\n\n\tentries = kmalloc_array(want, sizeof(*entries), GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < want; i++)\n\t\tentries[i].entry = i;\n\n\tallocated = pci_enable_msix_range(adap->pdev, entries, need, want);\n\tif (allocated < 0) {\n\t\t \n\t\twant = s->max_ethqsets + EXTRA_VECS;\n\t\tneed = eth_need + EXTRA_VECS;\n\t\tallocated = pci_enable_msix_range(adap->pdev, entries,\n\t\t\t\t\t\t  need, want);\n\t\tif (allocated < 0) {\n\t\t\tdev_info(adap->pdev_dev,\n\t\t\t\t \"Disabling MSI-X due to insufficient MSI-X vectors\\n\");\n\t\t\tret = allocated;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tdev_info(adap->pdev_dev,\n\t\t\t \"Disabling offload due to insufficient MSI-X vectors\\n\");\n\t\tadap->params.offload = 0;\n\t\tadap->params.crypto = 0;\n\t\tadap->params.ethofld = 0;\n\t\ts->ofldqsets = 0;\n\t\ts->eoqsets = 0;\n\t\ts->mirrorqsets = 0;\n\t\tuld_need = 0;\n\t\tethofld_need = 0;\n\t\tmirror_need = 0;\n\t}\n\n\tnum_vec = allocated;\n\tif (num_vec < want) {\n\t\t \n\t\tethqsets = eth_need;\n\t\tif (is_uld(adap))\n\t\t\tofldqsets = nchan;\n\t\tif (is_ethofld(adap))\n\t\t\teoqsets = ethofld_need;\n\t\tif (s->mirrorqsets)\n\t\t\tmirrorqsets = mirror_need;\n\n\t\tnum_vec -= need;\n\t\twhile (num_vec) {\n\t\t\tif (num_vec < eth_need + ethofld_need ||\n\t\t\t    ethqsets > s->max_ethqsets)\n\t\t\t\tbreak;\n\n\t\t\tfor_each_port(adap, i) {\n\t\t\t\tpi = adap2pinfo(adap, i);\n\t\t\t\tif (pi->nqsets < 2)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tethqsets++;\n\t\t\t\tnum_vec--;\n\t\t\t\tif (ethofld_need) {\n\t\t\t\t\teoqsets++;\n\t\t\t\t\tnum_vec--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (is_uld(adap)) {\n\t\t\twhile (num_vec) {\n\t\t\t\tif (num_vec < uld_need ||\n\t\t\t\t    ofldqsets > s->ofldqsets)\n\t\t\t\t\tbreak;\n\n\t\t\t\tofldqsets++;\n\t\t\t\tnum_vec -= uld_need;\n\t\t\t}\n\t\t}\n\n\t\tif (s->mirrorqsets) {\n\t\t\twhile (num_vec) {\n\t\t\t\tif (num_vec < mirror_need ||\n\t\t\t\t    mirrorqsets > s->mirrorqsets)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmirrorqsets++;\n\t\t\t\tnum_vec -= mirror_need;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tethqsets = s->max_ethqsets;\n\t\tif (is_uld(adap))\n\t\t\tofldqsets = s->ofldqsets;\n\t\tif (is_ethofld(adap))\n\t\t\teoqsets = s->eoqsets;\n\t\tif (s->mirrorqsets)\n\t\t\tmirrorqsets = s->mirrorqsets;\n\t}\n\n\tif (ethqsets < s->max_ethqsets) {\n\t\ts->max_ethqsets = ethqsets;\n\t\treduce_ethqs(adap, ethqsets);\n\t}\n\n\tif (is_uld(adap)) {\n\t\ts->ofldqsets = ofldqsets;\n\t\ts->nqs_per_uld = s->ofldqsets;\n\t}\n\n\tif (is_ethofld(adap))\n\t\ts->eoqsets = eoqsets;\n\n\tif (s->mirrorqsets) {\n\t\ts->mirrorqsets = mirrorqsets;\n\t\tfor_each_port(adap, i) {\n\t\t\tpi = adap2pinfo(adap, i);\n\t\t\tpi->nmirrorqsets = s->mirrorqsets / nchan;\n\t\t\tmutex_init(&pi->vi_mirror_mutex);\n\t\t}\n\t}\n\n\t \n\tret = alloc_msix_info(adap, allocated);\n\tif (ret)\n\t\tgoto out_disable_msix;\n\n\tfor (i = 0; i < allocated; i++) {\n\t\tadap->msix_info[i].vec = entries[i].vector;\n\t\tadap->msix_info[i].idx = i;\n\t}\n\n\tdev_info(adap->pdev_dev,\n\t\t \"%d MSI-X vectors allocated, nic %d eoqsets %d per uld %d mirrorqsets %d\\n\",\n\t\t allocated, s->max_ethqsets, s->eoqsets, s->nqs_per_uld,\n\t\t s->mirrorqsets);\n\n\tkfree(entries);\n\treturn 0;\n\nout_disable_msix:\n\tpci_disable_msix(adap->pdev);\n\nout_free:\n\tkfree(entries);\n\treturn ret;\n}\n\n#undef EXTRA_VECS\n\nstatic int init_rss(struct adapter *adap)\n{\n\tunsigned int i;\n\tint err;\n\n\terr = t4_init_rss_mode(adap, adap->mbox);\n\tif (err)\n\t\treturn err;\n\n\tfor_each_port(adap, i) {\n\t\tstruct port_info *pi = adap2pinfo(adap, i);\n\n\t\tpi->rss = kcalloc(pi->rss_size, sizeof(u16), GFP_KERNEL);\n\t\tif (!pi->rss)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nstatic void print_adapter_info(struct adapter *adapter)\n{\n\t \n\tt4_dump_version_info(adapter);\n\n\t \n\tdev_info(adapter->pdev_dev, \"Configuration: %sNIC %s, %s capable\\n\",\n\t\t is_offload(adapter) ? \"R\" : \"\",\n\t\t ((adapter->flags & CXGB4_USING_MSIX) ? \"MSI-X\" :\n\t\t  (adapter->flags & CXGB4_USING_MSI) ? \"MSI\" : \"\"),\n\t\t is_offload(adapter) ? \"Offload\" : \"non-Offload\");\n}\n\nstatic void print_port_info(const struct net_device *dev)\n{\n\tchar buf[80];\n\tchar *bufp = buf;\n\tconst struct port_info *pi = netdev_priv(dev);\n\tconst struct adapter *adap = pi->adapter;\n\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_100M)\n\t\tbufp += sprintf(bufp, \"100M/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_1G)\n\t\tbufp += sprintf(bufp, \"1G/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_10G)\n\t\tbufp += sprintf(bufp, \"10G/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_25G)\n\t\tbufp += sprintf(bufp, \"25G/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_40G)\n\t\tbufp += sprintf(bufp, \"40G/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_50G)\n\t\tbufp += sprintf(bufp, \"50G/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_100G)\n\t\tbufp += sprintf(bufp, \"100G/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_200G)\n\t\tbufp += sprintf(bufp, \"200G/\");\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_SPEED_400G)\n\t\tbufp += sprintf(bufp, \"400G/\");\n\tif (bufp != buf)\n\t\t--bufp;\n\tsprintf(bufp, \"BASE-%s\", t4_get_port_type_description(pi->port_type));\n\n\tnetdev_info(dev, \"Chelsio %s %s\\n\", adap->params.vpd.id, buf);\n}\n\n \nstatic void free_some_resources(struct adapter *adapter)\n{\n\tunsigned int i;\n\n\tkvfree(adapter->smt);\n\tkvfree(adapter->l2t);\n\tkvfree(adapter->srq);\n\tt4_cleanup_sched(adapter);\n\tkvfree(adapter->tids.tid_tab);\n\tcxgb4_cleanup_tc_matchall(adapter);\n\tcxgb4_cleanup_tc_mqprio(adapter);\n\tcxgb4_cleanup_tc_flower(adapter);\n\tcxgb4_cleanup_tc_u32(adapter);\n\tcxgb4_cleanup_ethtool_filters(adapter);\n\tkfree(adapter->sge.egr_map);\n\tkfree(adapter->sge.ingr_map);\n\tbitmap_free(adapter->sge.starving_fl);\n\tbitmap_free(adapter->sge.txq_maperr);\n#ifdef CONFIG_DEBUG_FS\n\tbitmap_free(adapter->sge.blocked_fl);\n#endif\n\tdisable_msi(adapter);\n\n\tfor_each_port(adapter, i)\n\t\tif (adapter->port[i]) {\n\t\t\tstruct port_info *pi = adap2pinfo(adapter, i);\n\n\t\t\tif (pi->viid != 0)\n\t\t\t\tt4_free_vi(adapter, adapter->mbox, adapter->pf,\n\t\t\t\t\t   0, pi->viid);\n\t\t\tkfree(adap2pinfo(adapter, i)->rss);\n\t\t\tfree_netdev(adapter->port[i]);\n\t\t}\n\tif (adapter->flags & CXGB4_FW_OK)\n\t\tt4_fw_bye(adapter, adapter->pf);\n}\n\n#define TSO_FLAGS (NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_TSO_ECN | \\\n\t\t   NETIF_F_GSO_UDP_L4)\n#define VLAN_FEAT (NETIF_F_SG | NETIF_F_IP_CSUM | TSO_FLAGS | \\\n\t\t   NETIF_F_GRO | NETIF_F_IPV6_CSUM | NETIF_F_HIGHDMA)\n#define SEGMENT_SIZE 128\n\nstatic int t4_get_chip_type(struct adapter *adap, int ver)\n{\n\tu32 pl_rev = REV_G(t4_read_reg(adap, PL_REV_A));\n\n\tswitch (ver) {\n\tcase CHELSIO_T4:\n\t\treturn CHELSIO_CHIP_CODE(CHELSIO_T4, pl_rev);\n\tcase CHELSIO_T5:\n\t\treturn CHELSIO_CHIP_CODE(CHELSIO_T5, pl_rev);\n\tcase CHELSIO_T6:\n\t\treturn CHELSIO_CHIP_CODE(CHELSIO_T6, pl_rev);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_PCI_IOV\nstatic void cxgb4_mgmt_setup(struct net_device *dev)\n{\n\tdev->type = ARPHRD_NONE;\n\tdev->mtu = 0;\n\tdev->hard_header_len = 0;\n\tdev->addr_len = 0;\n\tdev->tx_queue_len = 0;\n\tdev->flags |= IFF_NOARP;\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\n\t \n\tdev->netdev_ops = &cxgb4_mgmt_netdev_ops;\n\tdev->ethtool_ops = &cxgb4_mgmt_ethtool_ops;\n}\n\nstatic int cxgb4_iov_configure(struct pci_dev *pdev, int num_vfs)\n{\n\tstruct adapter *adap = pci_get_drvdata(pdev);\n\tint err = 0;\n\tint current_vfs = pci_num_vf(pdev);\n\tu32 pcie_fw;\n\n\tpcie_fw = readl(adap->regs + PCIE_FW_A);\n\t \n\tif (!(pcie_fw & PCIE_FW_INIT_F)) {\n\t\tdev_warn(&pdev->dev, \"Device not initialized\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (current_vfs && pci_vfs_assigned(pdev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot modify SR-IOV while VFs are assigned\\n\");\n\t\treturn current_vfs;\n\t}\n\t \n\tif (num_vfs != 0 && current_vfs != 0)\n\t\treturn -EBUSY;\n\n\t \n\tif (num_vfs == current_vfs)\n\t\treturn num_vfs;\n\n\t \n\tif (!num_vfs) {\n\t\tpci_disable_sriov(pdev);\n\t\t \n\t\tunregister_netdev(adap->port[0]);\n\t\tfree_netdev(adap->port[0]);\n\t\tadap->port[0] = NULL;\n\n\t\t \n\t\tadap->num_vfs = 0;\n\t\tkfree(adap->vfinfo);\n\t\tadap->vfinfo = NULL;\n\t\treturn 0;\n\t}\n\n\tif (!current_vfs) {\n\t\tstruct fw_pfvf_cmd port_cmd, port_rpl;\n\t\tstruct net_device *netdev;\n\t\tunsigned int pmask, port;\n\t\tstruct pci_dev *pbridge;\n\t\tstruct port_info *pi;\n\t\tchar name[IFNAMSIZ];\n\t\tu32 devcap2;\n\t\tu16 flags;\n\n\t\t \n\t\tpbridge = pdev->bus->self;\n\t\tpcie_capability_read_word(pbridge, PCI_EXP_FLAGS, &flags);\n\t\tpcie_capability_read_dword(pbridge, PCI_EXP_DEVCAP2, &devcap2);\n\n\t\tif ((flags & PCI_EXP_FLAGS_VERS) < 2 ||\n\t\t    !(devcap2 & PCI_EXP_DEVCAP2_ARI)) {\n\t\t\t \n\t\t\tdev_warn(&pdev->dev, \"Parent bridge %02x:%02x.%x doesn't support ARI; can't instantiate Virtual Functions\\n\",\n\t\t\t\t pbridge->bus->number, PCI_SLOT(pbridge->devfn),\n\t\t\t\t PCI_FUNC(pbridge->devfn));\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tmemset(&port_cmd, 0, sizeof(port_cmd));\n\t\tport_cmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PFVF_CMD) |\n\t\t\t\t\t\t FW_CMD_REQUEST_F |\n\t\t\t\t\t\t FW_CMD_READ_F |\n\t\t\t\t\t\t FW_PFVF_CMD_PFN_V(adap->pf) |\n\t\t\t\t\t\t FW_PFVF_CMD_VFN_V(0));\n\t\tport_cmd.retval_len16 = cpu_to_be32(FW_LEN16(port_cmd));\n\t\terr = t4_wr_mbox(adap, adap->mbox, &port_cmd, sizeof(port_cmd),\n\t\t\t\t &port_rpl);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpmask = FW_PFVF_CMD_PMASK_G(be32_to_cpu(port_rpl.type_to_neq));\n\t\tport = ffs(pmask) - 1;\n\t\t \n\t\tsnprintf(name, IFNAMSIZ, \"mgmtpf%d,%d\", adap->adap_idx,\n\t\t\t adap->pf);\n\t\tnetdev = alloc_netdev(sizeof(struct port_info),\n\t\t\t\t      name, NET_NAME_UNKNOWN, cxgb4_mgmt_setup);\n\t\tif (!netdev)\n\t\t\treturn -ENOMEM;\n\n\t\tpi = netdev_priv(netdev);\n\t\tpi->adapter = adap;\n\t\tpi->lport = port;\n\t\tpi->tx_chan = port;\n\t\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\t\tadap->port[0] = netdev;\n\t\tpi->port_id = 0;\n\n\t\terr = register_netdev(adap->port[0]);\n\t\tif (err) {\n\t\t\tpr_info(\"Unable to register VF mgmt netdev %s\\n\", name);\n\t\t\tfree_netdev(adap->port[0]);\n\t\t\tadap->port[0] = NULL;\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\tadap->vfinfo = kcalloc(pci_sriov_get_totalvfs(pdev),\n\t\t\t\t       sizeof(struct vf_info), GFP_KERNEL);\n\t\tif (!adap->vfinfo) {\n\t\t\tunregister_netdev(adap->port[0]);\n\t\t\tfree_netdev(adap->port[0]);\n\t\t\tadap->port[0] = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcxgb4_mgmt_fill_vf_station_mac_addr(adap);\n\t}\n\t \n\terr = pci_enable_sriov(pdev, num_vfs);\n\tif (err) {\n\t\tpr_info(\"Unable to instantiate %d VFs\\n\", num_vfs);\n\t\tif (!current_vfs) {\n\t\t\tunregister_netdev(adap->port[0]);\n\t\t\tfree_netdev(adap->port[0]);\n\t\t\tadap->port[0] = NULL;\n\t\t\tkfree(adap->vfinfo);\n\t\t\tadap->vfinfo = NULL;\n\t\t}\n\t\treturn err;\n\t}\n\n\tadap->num_vfs = num_vfs;\n\treturn num_vfs;\n}\n#endif  \n\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE) || IS_ENABLED(CONFIG_CHELSIO_IPSEC_INLINE)\n\nstatic int chcr_offload_state(struct adapter *adap,\n\t\t\t      enum cxgb4_netdev_tls_ops op_val)\n{\n\tswitch (op_val) {\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n\tcase CXGB4_TLSDEV_OPS:\n\t\tif (!adap->uld[CXGB4_ULD_KTLS].handle) {\n\t\t\tdev_dbg(adap->pdev_dev, \"ch_ktls driver is not loaded\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!adap->uld[CXGB4_ULD_KTLS].tlsdev_ops) {\n\t\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\t\"ch_ktls driver has no registered tlsdev_ops\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n#endif  \n#if IS_ENABLED(CONFIG_CHELSIO_IPSEC_INLINE)\n\tcase CXGB4_XFRMDEV_OPS:\n\t\tif (!adap->uld[CXGB4_ULD_IPSEC].handle) {\n\t\t\tdev_dbg(adap->pdev_dev, \"chipsec driver is not loaded\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!adap->uld[CXGB4_ULD_IPSEC].xfrmdev_ops) {\n\t\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\t\"chipsec driver has no registered xfrmdev_ops\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n#endif  \n\tdefault:\n\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\"driver has no support for offload %d\\n\", op_val);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n#endif  \n\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n\nstatic int cxgb4_ktls_dev_add(struct net_device *netdev, struct sock *sk,\n\t\t\t      enum tls_offload_ctx_dir direction,\n\t\t\t      struct tls_crypto_info *crypto_info,\n\t\t\t      u32 tcp_sn)\n{\n\tstruct adapter *adap = netdev2adap(netdev);\n\tint ret;\n\n\tmutex_lock(&uld_mutex);\n\tret = chcr_offload_state(adap, CXGB4_TLSDEV_OPS);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = cxgb4_set_ktls_feature(adap, FW_PARAMS_PARAM_DEV_KTLS_HW_ENABLE);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = adap->uld[CXGB4_ULD_KTLS].tlsdev_ops->tls_dev_add(netdev, sk,\n\t\t\t\t\t\t\t\tdirection,\n\t\t\t\t\t\t\t\tcrypto_info,\n\t\t\t\t\t\t\t\ttcp_sn);\n\t \n\tif (ret)\n\t\tcxgb4_set_ktls_feature(adap,\n\t\t\t\t       FW_PARAMS_PARAM_DEV_KTLS_HW_DISABLE);\nout_unlock:\n\tmutex_unlock(&uld_mutex);\n\treturn ret;\n}\n\nstatic void cxgb4_ktls_dev_del(struct net_device *netdev,\n\t\t\t       struct tls_context *tls_ctx,\n\t\t\t       enum tls_offload_ctx_dir direction)\n{\n\tstruct adapter *adap = netdev2adap(netdev);\n\n\tmutex_lock(&uld_mutex);\n\tif (chcr_offload_state(adap, CXGB4_TLSDEV_OPS))\n\t\tgoto out_unlock;\n\n\tadap->uld[CXGB4_ULD_KTLS].tlsdev_ops->tls_dev_del(netdev, tls_ctx,\n\t\t\t\t\t\t\t  direction);\n\nout_unlock:\n\tcxgb4_set_ktls_feature(adap, FW_PARAMS_PARAM_DEV_KTLS_HW_DISABLE);\n\tmutex_unlock(&uld_mutex);\n}\n\nstatic const struct tlsdev_ops cxgb4_ktls_ops = {\n\t.tls_dev_add = cxgb4_ktls_dev_add,\n\t.tls_dev_del = cxgb4_ktls_dev_del,\n};\n#endif  \n\n#if IS_ENABLED(CONFIG_CHELSIO_IPSEC_INLINE)\n\nstatic int cxgb4_xfrm_add_state(struct xfrm_state *x,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct adapter *adap = netdev2adap(x->xso.dev);\n\tint ret;\n\n\tif (!mutex_trylock(&uld_mutex)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"crypto uld critical resource is under use\");\n\t\treturn -EBUSY;\n\t}\n\tret = chcr_offload_state(adap, CXGB4_XFRMDEV_OPS);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = adap->uld[CXGB4_ULD_IPSEC].xfrmdev_ops->xdo_dev_state_add(x, extack);\n\nout_unlock:\n\tmutex_unlock(&uld_mutex);\n\n\treturn ret;\n}\n\nstatic void cxgb4_xfrm_del_state(struct xfrm_state *x)\n{\n\tstruct adapter *adap = netdev2adap(x->xso.dev);\n\n\tif (!mutex_trylock(&uld_mutex)) {\n\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\"crypto uld critical resource is under use\\n\");\n\t\treturn;\n\t}\n\tif (chcr_offload_state(adap, CXGB4_XFRMDEV_OPS))\n\t\tgoto out_unlock;\n\n\tadap->uld[CXGB4_ULD_IPSEC].xfrmdev_ops->xdo_dev_state_delete(x);\n\nout_unlock:\n\tmutex_unlock(&uld_mutex);\n}\n\nstatic void cxgb4_xfrm_free_state(struct xfrm_state *x)\n{\n\tstruct adapter *adap = netdev2adap(x->xso.dev);\n\n\tif (!mutex_trylock(&uld_mutex)) {\n\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\"crypto uld critical resource is under use\\n\");\n\t\treturn;\n\t}\n\tif (chcr_offload_state(adap, CXGB4_XFRMDEV_OPS))\n\t\tgoto out_unlock;\n\n\tadap->uld[CXGB4_ULD_IPSEC].xfrmdev_ops->xdo_dev_state_free(x);\n\nout_unlock:\n\tmutex_unlock(&uld_mutex);\n}\n\nstatic bool cxgb4_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *x)\n{\n\tstruct adapter *adap = netdev2adap(x->xso.dev);\n\tbool ret = false;\n\n\tif (!mutex_trylock(&uld_mutex)) {\n\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\"crypto uld critical resource is under use\\n\");\n\t\treturn ret;\n\t}\n\tif (chcr_offload_state(adap, CXGB4_XFRMDEV_OPS))\n\t\tgoto out_unlock;\n\n\tret = adap->uld[CXGB4_ULD_IPSEC].xfrmdev_ops->xdo_dev_offload_ok(skb, x);\n\nout_unlock:\n\tmutex_unlock(&uld_mutex);\n\treturn ret;\n}\n\nstatic void cxgb4_advance_esn_state(struct xfrm_state *x)\n{\n\tstruct adapter *adap = netdev2adap(x->xso.dev);\n\n\tif (!mutex_trylock(&uld_mutex)) {\n\t\tdev_dbg(adap->pdev_dev,\n\t\t\t\"crypto uld critical resource is under use\\n\");\n\t\treturn;\n\t}\n\tif (chcr_offload_state(adap, CXGB4_XFRMDEV_OPS))\n\t\tgoto out_unlock;\n\n\tadap->uld[CXGB4_ULD_IPSEC].xfrmdev_ops->xdo_dev_state_advance_esn(x);\n\nout_unlock:\n\tmutex_unlock(&uld_mutex);\n}\n\nstatic const struct xfrmdev_ops cxgb4_xfrmdev_ops = {\n\t.xdo_dev_state_add      = cxgb4_xfrm_add_state,\n\t.xdo_dev_state_delete   = cxgb4_xfrm_del_state,\n\t.xdo_dev_state_free     = cxgb4_xfrm_free_state,\n\t.xdo_dev_offload_ok     = cxgb4_ipsec_offload_ok,\n\t.xdo_dev_state_advance_esn = cxgb4_advance_esn_state,\n};\n\n#endif  \n\nstatic int init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *netdev;\n\tstruct adapter *adapter;\n\tstatic int adap_idx = 1;\n\tint s_qpp, qpp, num_seg;\n\tstruct port_info *pi;\n\tenum chip_type chip;\n\tvoid __iomem *regs;\n\tint func, chip_ver;\n\tu16 device_id;\n\tint i, err;\n\tu32 whoami;\n\n\terr = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (err) {\n\t\t \n\t\tdev_info(&pdev->dev, \"cannot obtain PCI resources\\n\");\n\t\treturn err;\n\t}\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot enable PCI device\\n\");\n\t\tgoto out_release_regions;\n\t}\n\n\tregs = pci_ioremap_bar(pdev, 0);\n\tif (!regs) {\n\t\tdev_err(&pdev->dev, \"cannot map device registers\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_disable_device;\n\t}\n\n\tadapter = kzalloc(sizeof(*adapter), GFP_KERNEL);\n\tif (!adapter) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unmap_bar0;\n\t}\n\n\tadapter->regs = regs;\n\terr = t4_wait_dev_ready(regs);\n\tif (err < 0)\n\t\tgoto out_free_adapter;\n\n\t \n\twhoami = t4_read_reg(adapter, PL_WHOAMI_A);\n\tpci_read_config_word(pdev, PCI_DEVICE_ID, &device_id);\n\tchip = t4_get_chip_type(adapter, CHELSIO_PCI_ID_VER(device_id));\n\tif ((int)chip < 0) {\n\t\tdev_err(&pdev->dev, \"Device %d is not supported\\n\", device_id);\n\t\terr = chip;\n\t\tgoto out_free_adapter;\n\t}\n\tchip_ver = CHELSIO_CHIP_VERSION(chip);\n\tfunc = chip_ver <= CHELSIO_T5 ?\n\t       SOURCEPF_G(whoami) : T6_SOURCEPF_G(whoami);\n\n\tadapter->pdev = pdev;\n\tadapter->pdev_dev = &pdev->dev;\n\tadapter->name = pci_name(pdev);\n\tadapter->mbox = func;\n\tadapter->pf = func;\n\tadapter->params.chip = chip;\n\tadapter->adap_idx = adap_idx;\n\tadapter->msg_enable = DFLT_MSG_ENABLE;\n\tadapter->mbox_log = kzalloc(sizeof(*adapter->mbox_log) +\n\t\t\t\t    (sizeof(struct mbox_cmd) *\n\t\t\t\t     T4_OS_LOG_MBOX_CMDS),\n\t\t\t\t    GFP_KERNEL);\n\tif (!adapter->mbox_log) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_adapter;\n\t}\n\tspin_lock_init(&adapter->mbox_lock);\n\tINIT_LIST_HEAD(&adapter->mlist.list);\n\tadapter->mbox_log->size = T4_OS_LOG_MBOX_CMDS;\n\tpci_set_drvdata(pdev, adapter);\n\n\tif (func != ent->driver_data) {\n\t\tpci_disable_device(pdev);\n\t\tpci_save_state(pdev);         \n\t\treturn 0;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"no usable DMA configuration\\n\");\n\t\tgoto out_free_adapter;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_save_state(pdev);\n\tadap_idx++;\n\tadapter->workq = create_singlethread_workqueue(\"cxgb4\");\n\tif (!adapter->workq) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_adapter;\n\t}\n\n\t \n\tadapter->flags |= CXGB4_DEV_ENABLED;\n\tmemset(adapter->chan_map, 0xff, sizeof(adapter->chan_map));\n\n\t \n\tif (!pcie_relaxed_ordering_enabled(pdev))\n\t\tadapter->flags |= CXGB4_ROOT_NO_RELAXED_ORDERING;\n\n\tspin_lock_init(&adapter->stats_lock);\n\tspin_lock_init(&adapter->tid_release_lock);\n\tspin_lock_init(&adapter->win0_lock);\n\n\tINIT_WORK(&adapter->tid_release_task, process_tid_release_list);\n\tINIT_WORK(&adapter->db_full_task, process_db_full);\n\tINIT_WORK(&adapter->db_drop_task, process_db_drop);\n\tINIT_WORK(&adapter->fatal_err_notify_task, notify_fatal_err);\n\n\terr = t4_prep_adapter(adapter);\n\tif (err)\n\t\tgoto out_free_adapter;\n\n\tif (is_kdump_kernel()) {\n\t\t \n\t\terr = cxgb4_cudbg_vmcore_add_dump(adapter);\n\t\tif (err) {\n\t\t\tdev_warn(adapter->pdev_dev,\n\t\t\t\t \"Fail collecting vmcore device dump, err: %d. Continuing\\n\",\n\t\t\t\t err);\n\t\t\terr = 0;\n\t\t}\n\t}\n\n\tif (!is_t4(adapter->params.chip)) {\n\t\ts_qpp = (QUEUESPERPAGEPF0_S +\n\t\t\t(QUEUESPERPAGEPF1_S - QUEUESPERPAGEPF0_S) *\n\t\t\tadapter->pf);\n\t\tqpp = 1 << QUEUESPERPAGEPF0_G(t4_read_reg(adapter,\n\t\t      SGE_EGRESS_QUEUES_PER_PAGE_PF_A) >> s_qpp);\n\t\tnum_seg = PAGE_SIZE / SEGMENT_SIZE;\n\n\t\t \n\t\tif (qpp > num_seg) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Incorrect number of egress queues per page\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free_adapter;\n\t\t}\n\t\tadapter->bar2 = ioremap_wc(pci_resource_start(pdev, 2),\n\t\tpci_resource_len(pdev, 2));\n\t\tif (!adapter->bar2) {\n\t\t\tdev_err(&pdev->dev, \"cannot map device bar2 region\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_adapter;\n\t\t}\n\t}\n\n\tsetup_memwin(adapter);\n\terr = adap_init0(adapter, 0);\n\tif (err)\n\t\tgoto out_unmap_bar;\n\n\tsetup_memwin_rdma(adapter);\n\n\t \n\tif (!is_t4(adapter->params.chip))\n\t\tt4_write_reg(adapter, SGE_STAT_CFG_A, STATSOURCE_T5_V(7) |\n\t\t\t     (is_t5(adapter->params.chip) ? STATMODE_V(0) :\n\t\t\t      T6_STATMODE_V(0)));\n\n\t \n\tINIT_LIST_HEAD(&adapter->mac_hlist);\n\n\tfor_each_port(adapter, i) {\n\t\t \n\t\tnetdev = alloc_etherdev_mq(sizeof(struct port_info),\n\t\t\t\t\t   MAX_ETH_QSETS + MAX_ATIDS);\n\t\tif (!netdev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_dev;\n\t\t}\n\n\t\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\t\tadapter->port[i] = netdev;\n\t\tpi = netdev_priv(netdev);\n\t\tpi->adapter = adapter;\n\t\tpi->xact_addr_filt = -1;\n\t\tpi->port_id = i;\n\t\tnetdev->irq = pdev->irq;\n\n\t\tnetdev->hw_features = NETIF_F_SG | TSO_FLAGS |\n\t\t\tNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\n\t\t\tNETIF_F_RXCSUM | NETIF_F_RXHASH | NETIF_F_GRO |\n\t\t\tNETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\tNETIF_F_HW_TC | NETIF_F_NTUPLE | NETIF_F_HIGHDMA;\n\n\t\tif (chip_ver > CHELSIO_T5) {\n\t\t\tnetdev->hw_enc_features |= NETIF_F_IP_CSUM |\n\t\t\t\t\t\t   NETIF_F_IPV6_CSUM |\n\t\t\t\t\t\t   NETIF_F_RXCSUM |\n\t\t\t\t\t\t   NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t\t\t   NETIF_F_GSO_UDP_TUNNEL_CSUM |\n\t\t\t\t\t\t   NETIF_F_TSO | NETIF_F_TSO6;\n\n\t\t\tnetdev->hw_features |= NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t\t       NETIF_F_GSO_UDP_TUNNEL_CSUM |\n\t\t\t\t\t       NETIF_F_HW_TLS_RECORD;\n\n\t\t\tif (adapter->rawf_cnt)\n\t\t\t\tnetdev->udp_tunnel_nic_info = &cxgb_udp_tunnels;\n\t\t}\n\n\t\tnetdev->features |= netdev->hw_features;\n\t\tnetdev->vlan_features = netdev->features & VLAN_FEAT;\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n\t\tif (pi->adapter->params.crypto & FW_CAPS_CONFIG_TLS_HW) {\n\t\t\tnetdev->hw_features |= NETIF_F_HW_TLS_TX;\n\t\t\tnetdev->tlsdev_ops = &cxgb4_ktls_ops;\n\t\t\t \n\t\t\trefcount_set(&pi->adapter->chcr_ktls.ktls_refcount, 0);\n\t\t}\n#endif  \n#if IS_ENABLED(CONFIG_CHELSIO_IPSEC_INLINE)\n\t\tif (pi->adapter->params.crypto & FW_CAPS_CONFIG_IPSEC_INLINE) {\n\t\t\tnetdev->hw_enc_features |= NETIF_F_HW_ESP;\n\t\t\tnetdev->features |= NETIF_F_HW_ESP;\n\t\t\tnetdev->xfrmdev_ops = &cxgb4_xfrmdev_ops;\n\t\t}\n#endif  \n\n\t\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\n\t\t \n\t\tnetdev->min_mtu = 81;               \n\t\tnetdev->max_mtu = MAX_MTU;\n\n\t\tnetdev->netdev_ops = &cxgb4_netdev_ops;\n#ifdef CONFIG_CHELSIO_T4_DCB\n\t\tnetdev->dcbnl_ops = &cxgb4_dcb_ops;\n\t\tcxgb4_dcb_state_init(netdev);\n\t\tcxgb4_dcb_version_init(netdev);\n#endif\n\t\tcxgb4_set_ethtool_ops(netdev);\n\t}\n\n\tcxgb4_init_ethtool_dump(adapter);\n\n\tpci_set_drvdata(pdev, adapter);\n\n\tif (adapter->flags & CXGB4_FW_OK) {\n\t\terr = t4_port_init(adapter, func, func, 0);\n\t\tif (err)\n\t\t\tgoto out_free_dev;\n\t} else if (adapter->params.nports == 1) {\n\t\t \n\t\tu8 hw_addr[ETH_ALEN];\n\t\tu8 *na = adapter->params.vpd.na;\n\n\t\terr = t4_get_raw_vpd_params(adapter, &adapter->params.vpd);\n\t\tif (!err) {\n\t\t\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t\t\thw_addr[i] = (hex2val(na[2 * i + 0]) * 16 +\n\t\t\t\t\t      hex2val(na[2 * i + 1]));\n\t\t\tt4_set_hw_addr(adapter, 0, hw_addr);\n\t\t}\n\t}\n\n\tif (!(adapter->flags & CXGB4_FW_OK))\n\t\tgoto fw_attach_fail;\n\n\t \n\terr = cfg_queues(adapter);\n\tif (err)\n\t\tgoto out_free_dev;\n\n\tadapter->smt = t4_init_smt();\n\tif (!adapter->smt) {\n\t\t \n\t\tdev_warn(&pdev->dev, \"could not allocate SMT, continuing\\n\");\n\t}\n\n\tadapter->l2t = t4_init_l2t(adapter->l2t_start, adapter->l2t_end);\n\tif (!adapter->l2t) {\n\t\t \n\t\tdev_warn(&pdev->dev, \"could not allocate L2T, continuing\\n\");\n\t\tadapter->params.offload = 0;\n\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (chip_ver <= CHELSIO_T5 &&\n\t    (!(t4_read_reg(adapter, LE_DB_CONFIG_A) & ASLIPCOMPEN_F))) {\n\t\t \n\t\tdev_warn(&pdev->dev,\n\t\t\t \"CLIP not enabled in hardware, continuing\\n\");\n\t\tadapter->params.offload = 0;\n\t} else {\n\t\tadapter->clipt = t4_init_clip_tbl(adapter->clipt_start,\n\t\t\t\t\t\t  adapter->clipt_end);\n\t\tif (!adapter->clipt) {\n\t\t\t \n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"could not allocate Clip table, continuing\\n\");\n\t\t\tadapter->params.offload = 0;\n\t\t}\n\t}\n#endif\n\n\tfor_each_port(adapter, i) {\n\t\tpi = adap2pinfo(adapter, i);\n\t\tpi->sched_tbl = t4_init_sched(adapter->params.nsched_cls);\n\t\tif (!pi->sched_tbl)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"could not activate scheduling on port %d\\n\",\n\t\t\t\t i);\n\t}\n\n\tif (is_offload(adapter) || is_hashfilter(adapter)) {\n\t\tif (t4_read_reg(adapter, LE_DB_CONFIG_A) & HASHEN_F) {\n\t\t\tu32 v;\n\n\t\t\tv = t4_read_reg(adapter, LE_DB_HASH_CONFIG_A);\n\t\t\tif (chip_ver <= CHELSIO_T5) {\n\t\t\t\tadapter->tids.nhash = 1 << HASHTIDSIZE_G(v);\n\t\t\t\tv = t4_read_reg(adapter, LE_DB_TID_HASHBASE_A);\n\t\t\t\tadapter->tids.hash_base = v / 4;\n\t\t\t} else {\n\t\t\t\tadapter->tids.nhash = HASHTBLSIZE_G(v) << 3;\n\t\t\t\tv = t4_read_reg(adapter,\n\t\t\t\t\t\tT6_LE_DB_HASH_TID_BASE_A);\n\t\t\t\tadapter->tids.hash_base = v;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tid_init(&adapter->tids) < 0) {\n\t\tdev_warn(&pdev->dev, \"could not allocate TID table, \"\n\t\t\t \"continuing\\n\");\n\t\tadapter->params.offload = 0;\n\t} else {\n\t\tadapter->tc_u32 = cxgb4_init_tc_u32(adapter);\n\t\tif (!adapter->tc_u32)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"could not offload tc u32, continuing\\n\");\n\n\t\tif (cxgb4_init_tc_flower(adapter))\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"could not offload tc flower, continuing\\n\");\n\n\t\tif (cxgb4_init_tc_mqprio(adapter))\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"could not offload tc mqprio, continuing\\n\");\n\n\t\tif (cxgb4_init_tc_matchall(adapter))\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"could not offload tc matchall, continuing\\n\");\n\t\tif (cxgb4_init_ethtool_filters(adapter))\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"could not initialize ethtool filters, continuing\\n\");\n\t}\n\n\t \n\tif (msi > 1 && enable_msix(adapter) == 0)\n\t\tadapter->flags |= CXGB4_USING_MSIX;\n\telse if (msi > 0 && pci_enable_msi(pdev) == 0) {\n\t\tadapter->flags |= CXGB4_USING_MSI;\n\t\tif (msi > 1)\n\t\t\tfree_msix_info(adapter);\n\t}\n\n\t \n\tpcie_print_link_status(pdev);\n\n\tcxgb4_init_mps_ref_entries(adapter);\n\n\terr = init_rss(adapter);\n\tif (err)\n\t\tgoto out_free_dev;\n\n\terr = setup_non_data_intr(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"Non Data interrupt allocation failed, err: %d\\n\", err);\n\t\tgoto out_free_dev;\n\t}\n\n\terr = setup_fw_sge_queues(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"FW sge queue allocation failed, err %d\", err);\n\t\tgoto out_free_dev;\n\t}\n\nfw_attach_fail:\n\t \n\tfor_each_port(adapter, i) {\n\t\tpi = adap2pinfo(adapter, i);\n\t\tadapter->port[i]->dev_port = pi->lport;\n\t\tnetif_set_real_num_tx_queues(adapter->port[i], pi->nqsets);\n\t\tnetif_set_real_num_rx_queues(adapter->port[i], pi->nqsets);\n\n\t\tnetif_carrier_off(adapter->port[i]);\n\n\t\terr = register_netdev(adapter->port[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t\tadapter->chan_map[pi->tx_chan] = i;\n\t\tprint_port_info(adapter->port[i]);\n\t}\n\tif (i == 0) {\n\t\tdev_err(&pdev->dev, \"could not register any net devices\\n\");\n\t\tgoto out_free_dev;\n\t}\n\tif (err) {\n\t\tdev_warn(&pdev->dev, \"only %d net devices registered\\n\", i);\n\t\terr = 0;\n\t}\n\n\tif (cxgb4_debugfs_root) {\n\t\tadapter->debugfs_root = debugfs_create_dir(pci_name(pdev),\n\t\t\t\t\t\t\t   cxgb4_debugfs_root);\n\t\tsetup_debugfs(adapter);\n\t}\n\n\t \n\tpdev->needs_freset = 1;\n\n\tif (is_uld(adapter))\n\t\tcxgb4_uld_enable(adapter);\n\n\tif (!is_t4(adapter->params.chip))\n\t\tcxgb4_ptp_init(adapter);\n\n\tif (IS_REACHABLE(CONFIG_THERMAL) &&\n\t    !is_t4(adapter->params.chip) && (adapter->flags & CXGB4_FW_OK))\n\t\tcxgb4_thermal_init(adapter);\n\n\tprint_adapter_info(adapter);\n\treturn 0;\n\n out_free_dev:\n\tt4_free_sge_resources(adapter);\n\tfree_some_resources(adapter);\n\tif (adapter->flags & CXGB4_USING_MSIX)\n\t\tfree_msix_info(adapter);\n\tif (adapter->num_uld || adapter->num_ofld_uld)\n\t\tt4_uld_mem_free(adapter);\n out_unmap_bar:\n\tif (!is_t4(adapter->params.chip))\n\t\tiounmap(adapter->bar2);\n out_free_adapter:\n\tif (adapter->workq)\n\t\tdestroy_workqueue(adapter->workq);\n\n\tkfree(adapter->mbox_log);\n\tkfree(adapter);\n out_unmap_bar0:\n\tiounmap(regs);\n out_disable_device:\n\tpci_disable_device(pdev);\n out_release_regions:\n\tpci_release_regions(pdev);\n\treturn err;\n}\n\nstatic void remove_one(struct pci_dev *pdev)\n{\n\tstruct adapter *adapter = pci_get_drvdata(pdev);\n\tstruct hash_mac_addr *entry, *tmp;\n\n\tif (!adapter) {\n\t\tpci_release_regions(pdev);\n\t\treturn;\n\t}\n\n\t \n\tclear_all_filters(adapter);\n\n\tadapter->flags |= CXGB4_SHUTTING_DOWN;\n\n\tif (adapter->pf == 4) {\n\t\tint i;\n\n\t\t \n\t\tdestroy_workqueue(adapter->workq);\n\n\t\tdetach_ulds(adapter);\n\n\t\tfor_each_port(adapter, i)\n\t\t\tif (adapter->port[i]->reg_state == NETREG_REGISTERED)\n\t\t\t\tunregister_netdev(adapter->port[i]);\n\n\t\tt4_uld_clean_up(adapter);\n\n\t\tadap_free_hma_mem(adapter);\n\n\t\tdisable_interrupts(adapter);\n\n\t\tcxgb4_free_mps_ref_entries(adapter);\n\n\t\tdebugfs_remove_recursive(adapter->debugfs_root);\n\n\t\tif (!is_t4(adapter->params.chip))\n\t\t\tcxgb4_ptp_stop(adapter);\n\t\tif (IS_REACHABLE(CONFIG_THERMAL))\n\t\t\tcxgb4_thermal_remove(adapter);\n\n\t\tif (adapter->flags & CXGB4_FULL_INIT_DONE)\n\t\t\tcxgb_down(adapter);\n\n\t\tif (adapter->flags & CXGB4_USING_MSIX)\n\t\t\tfree_msix_info(adapter);\n\t\tif (adapter->num_uld || adapter->num_ofld_uld)\n\t\t\tt4_uld_mem_free(adapter);\n\t\tfree_some_resources(adapter);\n\t\tlist_for_each_entry_safe(entry, tmp, &adapter->mac_hlist,\n\t\t\t\t\t list) {\n\t\t\tlist_del(&entry->list);\n\t\t\tkfree(entry);\n\t\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tt4_cleanup_clip_tbl(adapter);\n#endif\n\t\tif (!is_t4(adapter->params.chip))\n\t\t\tiounmap(adapter->bar2);\n\t}\n#ifdef CONFIG_PCI_IOV\n\telse {\n\t\tcxgb4_iov_configure(adapter->pdev, 0);\n\t}\n#endif\n\tiounmap(adapter->regs);\n\tif ((adapter->flags & CXGB4_DEV_ENABLED)) {\n\t\tpci_disable_device(pdev);\n\t\tadapter->flags &= ~CXGB4_DEV_ENABLED;\n\t}\n\tpci_release_regions(pdev);\n\tkfree(adapter->mbox_log);\n\tsynchronize_rcu();\n\tkfree(adapter);\n}\n\n \nstatic void shutdown_one(struct pci_dev *pdev)\n{\n\tstruct adapter *adapter = pci_get_drvdata(pdev);\n\n\t \n\tif (!adapter) {\n\t\tpci_release_regions(pdev);\n\t\treturn;\n\t}\n\n\tadapter->flags |= CXGB4_SHUTTING_DOWN;\n\n\tif (adapter->pf == 4) {\n\t\tint i;\n\n\t\tfor_each_port(adapter, i)\n\t\t\tif (adapter->port[i]->reg_state == NETREG_REGISTERED)\n\t\t\t\tcxgb_close(adapter->port[i]);\n\n\t\trtnl_lock();\n\t\tcxgb4_mqprio_stop_offload(adapter);\n\t\trtnl_unlock();\n\n\t\tif (is_uld(adapter)) {\n\t\t\tdetach_ulds(adapter);\n\t\t\tt4_uld_clean_up(adapter);\n\t\t}\n\n\t\tdisable_interrupts(adapter);\n\t\tdisable_msi(adapter);\n\n\t\tt4_sge_stop(adapter);\n\t\tif (adapter->flags & CXGB4_FW_OK)\n\t\t\tt4_fw_bye(adapter, adapter->mbox);\n\t}\n}\n\nstatic struct pci_driver cxgb4_driver = {\n\t.name     = KBUILD_MODNAME,\n\t.id_table = cxgb4_pci_tbl,\n\t.probe    = init_one,\n\t.remove   = remove_one,\n\t.shutdown = shutdown_one,\n#ifdef CONFIG_PCI_IOV\n\t.sriov_configure = cxgb4_iov_configure,\n#endif\n\t.err_handler = &cxgb4_eeh,\n};\n\nstatic int __init cxgb4_init_module(void)\n{\n\tint ret;\n\n\tcxgb4_debugfs_root = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\n\tret = pci_register_driver(&cxgb4_driver);\n\tif (ret < 0)\n\t\tgoto err_pci;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (!inet6addr_registered) {\n\t\tret = register_inet6addr_notifier(&cxgb4_inet6addr_notifier);\n\t\tif (ret)\n\t\t\tpci_unregister_driver(&cxgb4_driver);\n\t\telse\n\t\t\tinet6addr_registered = true;\n\t}\n#endif\n\n\tif (ret == 0)\n\t\treturn ret;\n\nerr_pci:\n\tdebugfs_remove(cxgb4_debugfs_root);\n\n\treturn ret;\n}\n\nstatic void __exit cxgb4_cleanup_module(void)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (inet6addr_registered) {\n\t\tunregister_inet6addr_notifier(&cxgb4_inet6addr_notifier);\n\t\tinet6addr_registered = false;\n\t}\n#endif\n\tpci_unregister_driver(&cxgb4_driver);\n\tdebugfs_remove(cxgb4_debugfs_root);   \n}\n\nmodule_init(cxgb4_init_module);\nmodule_exit(cxgb4_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}