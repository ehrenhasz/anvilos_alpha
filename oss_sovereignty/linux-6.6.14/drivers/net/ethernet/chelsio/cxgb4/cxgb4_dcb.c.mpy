{
  "module_name": "cxgb4_dcb.c",
  "hash_id": "e0d1e482da66523266af27f08c8d5ccccc760b3a2b5093e21ebd3dd65aaaca4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c",
  "human_readable_source": "\n \n\n#include \"cxgb4.h\"\n\n \nconst char * const dcb_ver_array[] = {\n\t\"Unknown\",\n\t\"DCBx-CIN\",\n\t\"DCBx-CEE 1.01\",\n\t\"DCBx-IEEE\",\n\t\"\", \"\", \"\",\n\t\"Auto Negotiated\"\n};\n\nstatic inline bool cxgb4_dcb_state_synced(enum cxgb4_dcb_state state)\n{\n\tif (state == CXGB4_DCB_STATE_FW_ALLSYNCED ||\n\t    state == CXGB4_DCB_STATE_HOST)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nvoid cxgb4_dcb_state_init(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct port_dcb_info *dcb = &pi->dcb;\n\tint version_temp = dcb->dcb_version;\n\n\tmemset(dcb, 0, sizeof(struct port_dcb_info));\n\tdcb->state = CXGB4_DCB_STATE_START;\n\tif (version_temp)\n\t\tdcb->dcb_version = version_temp;\n\n\tnetdev_dbg(dev, \"%s: Initializing DCB state for port[%d]\\n\",\n\t\t    __func__, pi->port_id);\n}\n\nvoid cxgb4_dcb_version_init(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct port_dcb_info *dcb = &pi->dcb;\n\n\t \n\tdcb->dcb_version = FW_PORT_DCB_VER_AUTO;\n}\n\nstatic void cxgb4_dcb_cleanup_apps(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = pi->adapter;\n\tstruct port_dcb_info *dcb = &pi->dcb;\n\tstruct dcb_app app;\n\tint i, err;\n\n\t \n\tapp.priority = 0;\n\n\tfor (i = 0; i < CXGB4_MAX_DCBX_APP_SUPPORTED; i++) {\n\t\t \n\t\tif (!dcb->app_priority[i].protocolid)\n\t\t\tbreak;\n\n\t\tapp.protocol = dcb->app_priority[i].protocolid;\n\n\t\tif (dcb->dcb_version == FW_PORT_DCB_VER_IEEE) {\n\t\t\tapp.priority = dcb->app_priority[i].user_prio_map;\n\t\t\tapp.selector = dcb->app_priority[i].sel_field + 1;\n\t\t\terr = dcb_ieee_delapp(dev, &app);\n\t\t} else {\n\t\t\tapp.selector = !!(dcb->app_priority[i].sel_field);\n\t\t\terr = dcb_setapp(dev, &app);\n\t\t}\n\n\t\tif (err) {\n\t\t\tdev_err(adap->pdev_dev,\n\t\t\t\t\"Failed DCB Clear %s Application Priority: sel=%d, prot=%d, err=%d\\n\",\n\t\t\t\tdcb_ver_array[dcb->dcb_version], app.selector,\n\t\t\t\tapp.protocol, -err);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nvoid cxgb4_dcb_reset(struct net_device *dev)\n{\n\tcxgb4_dcb_cleanup_apps(dev);\n\tcxgb4_dcb_state_init(dev);\n}\n\n \nstatic inline void cxgb4_dcb_update_support(struct port_dcb_info *dcb)\n{\n\tif (dcb->dcb_version == FW_PORT_DCB_VER_IEEE) {\n\t\tif (dcb->supported & DCB_CAP_DCBX_VER_CEE)\n\t\t\tdcb->supported &= ~DCB_CAP_DCBX_VER_CEE;\n\t\tdcb->supported |= DCB_CAP_DCBX_VER_IEEE;\n\t} else if (dcb->dcb_version == FW_PORT_DCB_VER_CEE1D01) {\n\t\tif (dcb->supported & DCB_CAP_DCBX_VER_IEEE)\n\t\t\tdcb->supported &= ~DCB_CAP_DCBX_VER_IEEE;\n\t\tdcb->supported |= DCB_CAP_DCBX_VER_CEE;\n\t}\n}\n\n \nvoid cxgb4_dcb_state_fsm(struct net_device *dev,\n\t\t\t enum cxgb4_dcb_state_input transition_to)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct port_dcb_info *dcb = &pi->dcb;\n\tstruct adapter *adap = pi->adapter;\n\tenum cxgb4_dcb_state current_state = dcb->state;\n\n\tnetdev_dbg(dev, \"%s: State change from %d to %d for %s\\n\",\n\t\t    __func__, dcb->state, transition_to, dev->name);\n\n\tswitch (current_state) {\n\tcase CXGB4_DCB_STATE_START: {\n\t\tswitch (transition_to) {\n\t\tcase CXGB4_DCB_INPUT_FW_DISABLED: {\n\t\t\t \n\t\t\tdcb->state = CXGB4_DCB_STATE_HOST;\n\t\t\tdcb->supported = CXGB4_DCBX_HOST_SUPPORT;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase CXGB4_DCB_INPUT_FW_ENABLED: {\n\t\t\t \n\t\t\tdcb->state = CXGB4_DCB_STATE_FW_INCOMPLETE;\n\t\t\tdcb->supported = DCB_CAP_DCBX_LLD_MANAGED;\n\t\t\tif (dcb->dcb_version == FW_PORT_DCB_VER_IEEE)\n\t\t\t\tdcb->supported |= DCB_CAP_DCBX_VER_IEEE;\n\t\t\telse\n\t\t\t\tdcb->supported |= DCB_CAP_DCBX_VER_CEE;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase CXGB4_DCB_INPUT_FW_INCOMPLETE: {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tcase CXGB4_DCB_INPUT_FW_ALLSYNCED: {\n\t\t\tdcb->state = CXGB4_DCB_STATE_FW_ALLSYNCED;\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tgoto bad_state_input;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase CXGB4_DCB_STATE_FW_INCOMPLETE: {\n\t\tif (transition_to != CXGB4_DCB_INPUT_FW_DISABLED) {\n\t\t\t \n\t\t\tcxgb4_dcb_update_support(dcb);\n\t\t}\n\t\tswitch (transition_to) {\n\t\tcase CXGB4_DCB_INPUT_FW_ENABLED: {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tcase CXGB4_DCB_INPUT_FW_INCOMPLETE: {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tcase CXGB4_DCB_INPUT_FW_ALLSYNCED: {\n\t\t\tdcb->state = CXGB4_DCB_STATE_FW_ALLSYNCED;\n\t\t\tdcb->enabled = 1;\n\t\t\tlinkwatch_fire_event(dev);\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tgoto bad_state_input;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase CXGB4_DCB_STATE_FW_ALLSYNCED: {\n\t\tswitch (transition_to) {\n\t\tcase CXGB4_DCB_INPUT_FW_ENABLED: {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tcase CXGB4_DCB_INPUT_FW_INCOMPLETE: {\n\t\t\t \n\t\t\tcxgb4_dcb_reset(dev);\n\t\t\tdcb->state = CXGB4_DCB_STATE_FW_INCOMPLETE;\n\t\t\tdcb->supported = CXGB4_DCBX_FW_SUPPORT;\n\t\t\tlinkwatch_fire_event(dev);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase CXGB4_DCB_INPUT_FW_ALLSYNCED: {\n\t\t\t \n\t\t\tdcb->enabled = 1;\n\t\t\tlinkwatch_fire_event(dev);\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tgoto bad_state_input;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase CXGB4_DCB_STATE_HOST: {\n\t\tswitch (transition_to) {\n\t\tcase CXGB4_DCB_INPUT_FW_DISABLED: {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tgoto bad_state_input;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tgoto bad_state_transition;\n\t}\n\treturn;\n\nbad_state_input:\n\tdev_err(adap->pdev_dev, \"cxgb4_dcb_state_fsm: illegal input symbol %d\\n\",\n\t\ttransition_to);\n\treturn;\n\nbad_state_transition:\n\tdev_err(adap->pdev_dev, \"cxgb4_dcb_state_fsm: bad state transition, state = %d, input = %d\\n\",\n\t\tcurrent_state, transition_to);\n}\n\n \nvoid cxgb4_dcb_handle_fw_update(struct adapter *adap,\n\t\t\t\tconst struct fw_port_cmd *pcmd)\n{\n\tconst union fw_port_dcb *fwdcb = &pcmd->u.dcb;\n\tint port = FW_PORT_CMD_PORTID_G(be32_to_cpu(pcmd->op_to_portid));\n\tstruct net_device *dev = adap->port[adap->chan_map[port]];\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct port_dcb_info *dcb = &pi->dcb;\n\tint dcb_type = pcmd->u.dcb.pgid.type;\n\tint dcb_running_version;\n\n\t \n\tif (dcb_type == FW_PORT_DCB_TYPE_CONTROL) {\n\t\tenum cxgb4_dcb_state_input input =\n\t\t\t((pcmd->u.dcb.control.all_syncd_pkd &\n\t\t\t  FW_PORT_CMD_ALL_SYNCD_F)\n\t\t\t ? CXGB4_DCB_INPUT_FW_ALLSYNCED\n\t\t\t : CXGB4_DCB_INPUT_FW_INCOMPLETE);\n\n\t\tif (dcb->dcb_version != FW_PORT_DCB_VER_UNKNOWN) {\n\t\t\tdcb_running_version = FW_PORT_CMD_DCB_VERSION_G(\n\t\t\t\tbe16_to_cpu(\n\t\t\t\tpcmd->u.dcb.control.dcb_version_to_app_state));\n\t\t\tif (dcb_running_version == FW_PORT_DCB_VER_CEE1D01 ||\n\t\t\t    dcb_running_version == FW_PORT_DCB_VER_IEEE) {\n\t\t\t\tdcb->dcb_version = dcb_running_version;\n\t\t\t\tdev_warn(adap->pdev_dev, \"Interface %s is running %s\\n\",\n\t\t\t\t\t dev->name,\n\t\t\t\t\t dcb_ver_array[dcb->dcb_version]);\n\t\t\t} else {\n\t\t\t\tdev_warn(adap->pdev_dev,\n\t\t\t\t\t \"Something screwed up, requested firmware for %s, but firmware returned %s instead\\n\",\n\t\t\t\t\t dcb_ver_array[dcb->dcb_version],\n\t\t\t\t\t dcb_ver_array[dcb_running_version]);\n\t\t\t\tdcb->dcb_version = FW_PORT_DCB_VER_UNKNOWN;\n\t\t\t}\n\t\t}\n\n\t\tcxgb4_dcb_state_fsm(dev, input);\n\t\treturn;\n\t}\n\n\t \n\tif (dcb->state == CXGB4_DCB_STATE_START ||\n\t    dcb->state == CXGB4_DCB_STATE_HOST) {\n\t\tdev_err(adap->pdev_dev, \"Receiving Firmware DCB messages in State %d\\n\",\n\t\t\tdcb->state);\n\t\treturn;\n\t}\n\n\t \n\tswitch (dcb_type) {\n\tcase FW_PORT_DCB_TYPE_PGID:\n\t\tdcb->pgid = be32_to_cpu(fwdcb->pgid.pgid);\n\t\tdcb->msgs |= CXGB4_DCB_FW_PGID;\n\t\tbreak;\n\n\tcase FW_PORT_DCB_TYPE_PGRATE:\n\t\tdcb->pg_num_tcs_supported = fwdcb->pgrate.num_tcs_supported;\n\t\tmemcpy(dcb->pgrate, &fwdcb->pgrate.pgrate,\n\t\t       sizeof(dcb->pgrate));\n\t\tmemcpy(dcb->tsa, &fwdcb->pgrate.tsa,\n\t\t       sizeof(dcb->tsa));\n\t\tdcb->msgs |= CXGB4_DCB_FW_PGRATE;\n\t\tif (dcb->msgs & CXGB4_DCB_FW_PGID)\n\t\t\tIEEE_FAUX_SYNC(dev, dcb);\n\t\tbreak;\n\n\tcase FW_PORT_DCB_TYPE_PRIORATE:\n\t\tmemcpy(dcb->priorate, &fwdcb->priorate.strict_priorate,\n\t\t       sizeof(dcb->priorate));\n\t\tdcb->msgs |= CXGB4_DCB_FW_PRIORATE;\n\t\tbreak;\n\n\tcase FW_PORT_DCB_TYPE_PFC:\n\t\tdcb->pfcen = fwdcb->pfc.pfcen;\n\t\tdcb->pfc_num_tcs_supported = fwdcb->pfc.max_pfc_tcs;\n\t\tdcb->msgs |= CXGB4_DCB_FW_PFC;\n\t\tIEEE_FAUX_SYNC(dev, dcb);\n\t\tbreak;\n\n\tcase FW_PORT_DCB_TYPE_APP_ID: {\n\t\tconst struct fw_port_app_priority *fwap = &fwdcb->app_priority;\n\t\tint idx = fwap->idx;\n\t\tstruct app_priority *ap = &dcb->app_priority[idx];\n\n\t\tstruct dcb_app app = {\n\t\t\t.protocol = be16_to_cpu(fwap->protocolid),\n\t\t};\n\t\tint err;\n\n\t\t \n\t\tif (dcb->dcb_version == FW_PORT_DCB_VER_IEEE) {\n\t\t\tapp.selector = (fwap->sel_field + 1);\n\t\t\tapp.priority = ffs(fwap->user_prio_map) - 1;\n\t\t\terr = dcb_ieee_setapp(dev, &app);\n\t\t\tIEEE_FAUX_SYNC(dev, dcb);\n\t\t} else {\n\t\t\t \n\t\t\tapp.selector = !!(fwap->sel_field);\n\t\t\tapp.priority = fwap->user_prio_map;\n\t\t\terr = dcb_setapp(dev, &app);\n\t\t}\n\n\t\tif (err)\n\t\t\tdev_err(adap->pdev_dev,\n\t\t\t\t\"Failed DCB Set Application Priority: sel=%d, prot=%d, prio=%d, err=%d\\n\",\n\t\t\t\tapp.selector, app.protocol, app.priority, -err);\n\n\t\tap->user_prio_map = fwap->user_prio_map;\n\t\tap->sel_field = fwap->sel_field;\n\t\tap->protocolid = be16_to_cpu(fwap->protocolid);\n\t\tdcb->msgs |= CXGB4_DCB_FW_APP_ID;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tdev_err(adap->pdev_dev, \"Unknown DCB update type received %x\\n\",\n\t\t\tdcb_type);\n\t\tbreak;\n\t}\n}\n\n \n\n\n \nstatic u8 cxgb4_getstate(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\n\treturn pi->dcb.enabled;\n}\n\n \nstatic u8 cxgb4_setstate(struct net_device *dev, u8 enabled)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\n\t \n\tif (pi->dcb.state == CXGB4_DCB_STATE_HOST) {\n\t\tpi->dcb.enabled = enabled;\n\t\treturn 0;\n\t}\n\n\t \n\tif (enabled != (pi->dcb.state == CXGB4_DCB_STATE_FW_ALLSYNCED))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void cxgb4_getpgtccfg(struct net_device *dev, int tc,\n\t\t\t     u8 *prio_type, u8 *pgid, u8 *bw_per,\n\t\t\t     u8 *up_tc_map, int local)\n{\n\tstruct fw_port_cmd pcmd;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint err;\n\n\t*prio_type = *pgid = *bw_per = *up_tc_map = 0;\n\n\tif (local)\n\t\tINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\n\telse\n\t\tINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\n\n\tpcmd.u.dcb.pgid.type = FW_PORT_DCB_TYPE_PGID;\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\tdev_err(adap->pdev_dev, \"DCB read PGID failed with %d\\n\", -err);\n\t\treturn;\n\t}\n\t*pgid = (be32_to_cpu(pcmd.u.dcb.pgid.pgid) >> (tc * 4)) & 0xf;\n\n\tif (local)\n\t\tINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\n\telse\n\t\tINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\n\tpcmd.u.dcb.pgrate.type = FW_PORT_DCB_TYPE_PGRATE;\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\tdev_err(adap->pdev_dev, \"DCB read PGRATE failed with %d\\n\",\n\t\t\t-err);\n\t\treturn;\n\t}\n\n\t*bw_per = pcmd.u.dcb.pgrate.pgrate[*pgid];\n\t*up_tc_map = (1 << tc);\n\n\t \n\tif (*pgid != 0xF)\n\t\t*prio_type = 0x2;\n}\n\nstatic void cxgb4_getpgtccfg_tx(struct net_device *dev, int tc,\n\t\t\t\tu8 *prio_type, u8 *pgid, u8 *bw_per,\n\t\t\t\tu8 *up_tc_map)\n{\n\t \n\treturn cxgb4_getpgtccfg(dev, (7 - tc), prio_type, pgid, bw_per,\n\t\t\t\tup_tc_map, 1);\n}\n\n\nstatic void cxgb4_getpgtccfg_rx(struct net_device *dev, int tc,\n\t\t\t\tu8 *prio_type, u8 *pgid, u8 *bw_per,\n\t\t\t\tu8 *up_tc_map)\n{\n\t \n\treturn cxgb4_getpgtccfg(dev, (7 - tc), prio_type, pgid, bw_per,\n\t\t\t\tup_tc_map, 0);\n}\n\nstatic void cxgb4_setpgtccfg_tx(struct net_device *dev, int tc,\n\t\t\t\tu8 prio_type, u8 pgid, u8 bw_per,\n\t\t\t\tu8 up_tc_map)\n{\n\tstruct fw_port_cmd pcmd;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint fw_tc = 7 - tc;\n\tu32 _pgid;\n\tint err;\n\n\tif (pgid == DCB_ATTR_VALUE_UNDEFINED)\n\t\treturn;\n\tif (bw_per == DCB_ATTR_VALUE_UNDEFINED)\n\t\treturn;\n\n\tINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\n\tpcmd.u.dcb.pgid.type = FW_PORT_DCB_TYPE_PGID;\n\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\tdev_err(adap->pdev_dev, \"DCB read PGID failed with %d\\n\", -err);\n\t\treturn;\n\t}\n\n\t_pgid = be32_to_cpu(pcmd.u.dcb.pgid.pgid);\n\t_pgid &= ~(0xF << (fw_tc * 4));\n\t_pgid |= pgid << (fw_tc * 4);\n\tpcmd.u.dcb.pgid.pgid = cpu_to_be32(_pgid);\n\n\tINIT_PORT_DCB_WRITE_CMD(pcmd, pi->port_id);\n\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\tdev_err(adap->pdev_dev, \"DCB write PGID failed with %d\\n\",\n\t\t\t-err);\n\t\treturn;\n\t}\n\n\tmemset(&pcmd, 0, sizeof(struct fw_port_cmd));\n\n\tINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\n\tpcmd.u.dcb.pgrate.type = FW_PORT_DCB_TYPE_PGRATE;\n\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\tdev_err(adap->pdev_dev, \"DCB read PGRATE failed with %d\\n\",\n\t\t\t-err);\n\t\treturn;\n\t}\n\n\tpcmd.u.dcb.pgrate.pgrate[pgid] = bw_per;\n\n\tINIT_PORT_DCB_WRITE_CMD(pcmd, pi->port_id);\n\tif (pi->dcb.state == CXGB4_DCB_STATE_HOST)\n\t\tpcmd.op_to_portid |= cpu_to_be32(FW_PORT_CMD_APPLY_F);\n\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\tif (err != FW_PORT_DCB_CFG_SUCCESS)\n\t\tdev_err(adap->pdev_dev, \"DCB write PGRATE failed with %d\\n\",\n\t\t\t-err);\n}\n\nstatic void cxgb4_getpgbwgcfg(struct net_device *dev, int pgid, u8 *bw_per,\n\t\t\t      int local)\n{\n\tstruct fw_port_cmd pcmd;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint err;\n\n\tif (local)\n\t\tINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\n\telse\n\t\tINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\n\n\tpcmd.u.dcb.pgrate.type = FW_PORT_DCB_TYPE_PGRATE;\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\tdev_err(adap->pdev_dev, \"DCB read PGRATE failed with %d\\n\",\n\t\t\t-err);\n\t\treturn;\n\t}\n\n\t*bw_per = pcmd.u.dcb.pgrate.pgrate[pgid];\n}\n\nstatic void cxgb4_getpgbwgcfg_tx(struct net_device *dev, int pgid, u8 *bw_per)\n{\n\treturn cxgb4_getpgbwgcfg(dev, pgid, bw_per, 1);\n}\n\nstatic void cxgb4_getpgbwgcfg_rx(struct net_device *dev, int pgid, u8 *bw_per)\n{\n\treturn cxgb4_getpgbwgcfg(dev, pgid, bw_per, 0);\n}\n\nstatic void cxgb4_setpgbwgcfg_tx(struct net_device *dev, int pgid,\n\t\t\t\t u8 bw_per)\n{\n\tstruct fw_port_cmd pcmd;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint err;\n\n\tINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\n\tpcmd.u.dcb.pgrate.type = FW_PORT_DCB_TYPE_PGRATE;\n\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\tdev_err(adap->pdev_dev, \"DCB read PGRATE failed with %d\\n\",\n\t\t\t-err);\n\t\treturn;\n\t}\n\n\tpcmd.u.dcb.pgrate.pgrate[pgid] = bw_per;\n\n\tINIT_PORT_DCB_WRITE_CMD(pcmd, pi->port_id);\n\tif (pi->dcb.state == CXGB4_DCB_STATE_HOST)\n\t\tpcmd.op_to_portid |= cpu_to_be32(FW_PORT_CMD_APPLY_F);\n\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\n\tif (err != FW_PORT_DCB_CFG_SUCCESS)\n\t\tdev_err(adap->pdev_dev, \"DCB write PGRATE failed with %d\\n\",\n\t\t\t-err);\n}\n\n \nstatic void cxgb4_getpfccfg(struct net_device *dev, int priority, u8 *pfccfg)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct port_dcb_info *dcb = &pi->dcb;\n\n\tif (!cxgb4_dcb_state_synced(dcb->state) ||\n\t    priority >= CXGB4_MAX_PRIORITY)\n\t\t*pfccfg = 0;\n\telse\n\t\t*pfccfg = (pi->dcb.pfcen >> (7 - priority)) & 1;\n}\n\n \nstatic void cxgb4_setpfccfg(struct net_device *dev, int priority, u8 pfccfg)\n{\n\tstruct fw_port_cmd pcmd;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint err;\n\n\tif (!cxgb4_dcb_state_synced(pi->dcb.state) ||\n\t    priority >= CXGB4_MAX_PRIORITY)\n\t\treturn;\n\n\tINIT_PORT_DCB_WRITE_CMD(pcmd, pi->port_id);\n\tif (pi->dcb.state == CXGB4_DCB_STATE_HOST)\n\t\tpcmd.op_to_portid |= cpu_to_be32(FW_PORT_CMD_APPLY_F);\n\n\tpcmd.u.dcb.pfc.type = FW_PORT_DCB_TYPE_PFC;\n\tpcmd.u.dcb.pfc.pfcen = pi->dcb.pfcen;\n\n\tif (pfccfg)\n\t\tpcmd.u.dcb.pfc.pfcen |= (1 << (7 - priority));\n\telse\n\t\tpcmd.u.dcb.pfc.pfcen &= (~(1 << (7 - priority)));\n\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\tdev_err(adap->pdev_dev, \"DCB PFC write failed with %d\\n\", -err);\n\t\treturn;\n\t}\n\n\tpi->dcb.pfcen = pcmd.u.dcb.pfc.pfcen;\n}\n\nstatic u8 cxgb4_setall(struct net_device *dev)\n{\n\treturn 0;\n}\n\n \nstatic u8 cxgb4_getcap(struct net_device *dev, int cap_id, u8 *caps)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\n\tswitch (cap_id) {\n\tcase DCB_CAP_ATTR_PG:\n\tcase DCB_CAP_ATTR_PFC:\n\t\t*caps = true;\n\t\tbreak;\n\n\tcase DCB_CAP_ATTR_PG_TCS:\n\t\t \n\t\t*caps = 0x80;\n\t\tbreak;\n\n\tcase DCB_CAP_ATTR_PFC_TCS:\n\t\t \n\t\t*caps = 0x80;\n\t\tbreak;\n\n\tcase DCB_CAP_ATTR_GSP:\n\t\t*caps = true;\n\t\tbreak;\n\n\tcase DCB_CAP_ATTR_UP2TC:\n\tcase DCB_CAP_ATTR_BCN:\n\t\t*caps = false;\n\t\tbreak;\n\n\tcase DCB_CAP_ATTR_DCBX:\n\t\t*caps = pi->dcb.supported;\n\t\tbreak;\n\n\tdefault:\n\t\t*caps = false;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cxgb4_getnumtcs(struct net_device *dev, int tcs_id, u8 *num)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\n\tswitch (tcs_id) {\n\tcase DCB_NUMTCS_ATTR_PG:\n\t\tif (pi->dcb.msgs & CXGB4_DCB_FW_PGRATE)\n\t\t\t*num = pi->dcb.pg_num_tcs_supported;\n\t\telse\n\t\t\t*num = 0x8;\n\t\tbreak;\n\n\tcase DCB_NUMTCS_ATTR_PFC:\n\t\t*num = 0x8;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cxgb4_setnumtcs(struct net_device *dev, int tcs_id, u8 num)\n{\n\t \n\treturn -ENOSYS;\n}\n\n \nstatic u8 cxgb4_getpfcstate(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\n\tif (!cxgb4_dcb_state_synced(pi->dcb.state))\n\t\treturn false;\n\n\treturn pi->dcb.pfcen != 0;\n}\n\n \nstatic void cxgb4_setpfcstate(struct net_device *dev, u8 state)\n{\n\t \n}\n\n \nstatic int __cxgb4_getapp(struct net_device *dev, u8 app_idtype, u16 app_id,\n\t\t\t  int peer)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint i;\n\n\tif (!cxgb4_dcb_state_synced(pi->dcb.state))\n\t\treturn 0;\n\n\tfor (i = 0; i < CXGB4_MAX_DCBX_APP_SUPPORTED; i++) {\n\t\tstruct fw_port_cmd pcmd;\n\t\tint err;\n\n\t\tif (peer)\n\t\t\tINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\n\t\telse\n\t\t\tINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\n\n\t\tpcmd.u.dcb.app_priority.type = FW_PORT_DCB_TYPE_APP_ID;\n\t\tpcmd.u.dcb.app_priority.idx = i;\n\n\t\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\t\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\t\tdev_err(adap->pdev_dev, \"DCB APP read failed with %d\\n\",\n\t\t\t\t-err);\n\t\t\treturn err;\n\t\t}\n\t\tif (be16_to_cpu(pcmd.u.dcb.app_priority.protocolid) == app_id)\n\t\t\tif (pcmd.u.dcb.app_priority.sel_field == app_idtype)\n\t\t\t\treturn pcmd.u.dcb.app_priority.user_prio_map;\n\n\t\t \n\t\tif (!pcmd.u.dcb.app_priority.protocolid)\n\t\t\tbreak;\n\t}\n\n\treturn -EEXIST;\n}\n\n \nstatic int cxgb4_getapp(struct net_device *dev, u8 app_idtype, u16 app_id)\n{\n\t \n\treturn __cxgb4_getapp(dev, app_idtype == DCB_APP_IDTYPE_ETHTYPE ?\n\t\t\t      app_idtype : 3, app_id, 0);\n}\n\n \nstatic int __cxgb4_setapp(struct net_device *dev, u8 app_idtype, u16 app_id,\n\t\t\t  u8 app_prio)\n{\n\tstruct fw_port_cmd pcmd;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint i, err;\n\n\n\tif (!cxgb4_dcb_state_synced(pi->dcb.state))\n\t\treturn -EINVAL;\n\n\t \n\tif (!netif_carrier_ok(dev))\n\t\treturn -ENOLINK;\n\n\tfor (i = 0; i < CXGB4_MAX_DCBX_APP_SUPPORTED; i++) {\n\t\tINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\n\t\tpcmd.u.dcb.app_priority.type = FW_PORT_DCB_TYPE_APP_ID;\n\t\tpcmd.u.dcb.app_priority.idx = i;\n\t\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\n\t\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\t\tdev_err(adap->pdev_dev, \"DCB app table read failed with %d\\n\",\n\t\t\t\t-err);\n\t\t\treturn err;\n\t\t}\n\t\tif (be16_to_cpu(pcmd.u.dcb.app_priority.protocolid) == app_id) {\n\t\t\t \n\t\t\tpcmd.u.dcb.app_priority.protocolid = 0;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (!pcmd.u.dcb.app_priority.protocolid)\n\t\t\tbreak;\n\t}\n\n\tif (i == CXGB4_MAX_DCBX_APP_SUPPORTED) {\n\t\t \n\t\tdev_err(adap->pdev_dev, \"DCB app table full\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tINIT_PORT_DCB_WRITE_CMD(pcmd, pi->port_id);\n\tif (pi->dcb.state == CXGB4_DCB_STATE_HOST)\n\t\tpcmd.op_to_portid |= cpu_to_be32(FW_PORT_CMD_APPLY_F);\n\n\tpcmd.u.dcb.app_priority.type = FW_PORT_DCB_TYPE_APP_ID;\n\tpcmd.u.dcb.app_priority.protocolid = cpu_to_be16(app_id);\n\tpcmd.u.dcb.app_priority.sel_field = app_idtype;\n\tpcmd.u.dcb.app_priority.user_prio_map = app_prio;\n\tpcmd.u.dcb.app_priority.idx = i;\n\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\tdev_err(adap->pdev_dev, \"DCB app table write failed with %d\\n\",\n\t\t\t-err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cxgb4_setapp(struct net_device *dev, u8 app_idtype, u16 app_id,\n\t\t\tu8 app_prio)\n{\n\tint ret;\n\tstruct dcb_app app = {\n\t\t.selector = app_idtype,\n\t\t.protocol = app_id,\n\t\t.priority = app_prio,\n\t};\n\n\tif (app_idtype != DCB_APP_IDTYPE_ETHTYPE &&\n\t    app_idtype != DCB_APP_IDTYPE_PORTNUM)\n\t\treturn -EINVAL;\n\n\t \n\tret = __cxgb4_setapp(dev, app_idtype == DCB_APP_IDTYPE_ETHTYPE ?\n\t\t\t      app_idtype : 3, app_id, app_prio);\n\tif (ret)\n\t\treturn ret;\n\n\treturn dcb_setapp(dev, &app);\n}\n\n \nstatic inline int\ncxgb4_ieee_negotiation_complete(struct net_device *dev,\n\t\t\t\tenum cxgb4_dcb_fw_msgs dcb_subtype)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct port_dcb_info *dcb = &pi->dcb;\n\n\tif (dcb->state == CXGB4_DCB_STATE_FW_ALLSYNCED)\n\t\tif (dcb_subtype && !(dcb->msgs & dcb_subtype))\n\t\t\treturn 0;\n\n\treturn (cxgb4_dcb_state_synced(dcb->state) &&\n\t\t(dcb->supported & DCB_CAP_DCBX_VER_IEEE));\n}\n\nstatic int cxgb4_ieee_read_ets(struct net_device *dev, struct ieee_ets *ets,\n\t\t\t       int local)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct port_dcb_info *dcb = &pi->dcb;\n\tstruct adapter *adap = pi->adapter;\n\tuint32_t tc_info;\n\tstruct fw_port_cmd pcmd;\n\tint i, bwg, err;\n\n\tif (!(dcb->msgs & (CXGB4_DCB_FW_PGID | CXGB4_DCB_FW_PGRATE)))\n\t\treturn 0;\n\n\tets->ets_cap =  dcb->pg_num_tcs_supported;\n\n\tif (local) {\n\t\tets->willing = 1;\n\t\tINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\n\t} else {\n\t\tINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\n\t}\n\n\tpcmd.u.dcb.pgid.type = FW_PORT_DCB_TYPE_PGID;\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\tdev_err(adap->pdev_dev, \"DCB read PGID failed with %d\\n\", -err);\n\t\treturn err;\n\t}\n\n\ttc_info = be32_to_cpu(pcmd.u.dcb.pgid.pgid);\n\n\tif (local)\n\t\tINIT_PORT_DCB_READ_LOCAL_CMD(pcmd, pi->port_id);\n\telse\n\t\tINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\n\n\tpcmd.u.dcb.pgrate.type = FW_PORT_DCB_TYPE_PGRATE;\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\tdev_err(adap->pdev_dev, \"DCB read PGRATE failed with %d\\n\",\n\t\t\t-err);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tbwg = (tc_info >> ((7 - i) * 4)) & 0xF;\n\t\tets->prio_tc[i] = bwg;\n\t\tets->tc_tx_bw[i] = pcmd.u.dcb.pgrate.pgrate[i];\n\t\tets->tc_rx_bw[i] = ets->tc_tx_bw[i];\n\t\tets->tc_tsa[i] = pcmd.u.dcb.pgrate.tsa[i];\n\t}\n\n\treturn 0;\n}\n\nstatic int cxgb4_ieee_get_ets(struct net_device *dev, struct ieee_ets *ets)\n{\n\treturn cxgb4_ieee_read_ets(dev, ets, 1);\n}\n\n \nstatic int cxgb4_ieee_get_pfc(struct net_device *dev, struct ieee_pfc *pfc)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct port_dcb_info *dcb = &pi->dcb;\n\n\tmemset(pfc, 0, sizeof(struct ieee_pfc));\n\n\tif (!(dcb->msgs & CXGB4_DCB_FW_PFC))\n\t\treturn 0;\n\n\tpfc->pfc_cap = dcb->pfc_num_tcs_supported;\n\tpfc->pfc_en = bitswap_1(dcb->pfcen);\n\n\treturn 0;\n}\n\nstatic int cxgb4_ieee_peer_ets(struct net_device *dev, struct ieee_ets *ets)\n{\n\treturn cxgb4_ieee_read_ets(dev, ets, 0);\n}\n\n \nstatic int cxgb4_ieee_getapp(struct net_device *dev, struct dcb_app *app)\n{\n\tint prio;\n\n\tif (!cxgb4_ieee_negotiation_complete(dev, CXGB4_DCB_FW_APP_ID))\n\t\treturn -EINVAL;\n\tif (!(app->selector && app->protocol))\n\t\treturn -EINVAL;\n\n\t \n\tprio = __cxgb4_getapp(dev, app->selector - 1, app->protocol, 0);\n\n\tif (prio < 0)\n\t\tprio = dcb_ieee_getapp_mask(dev, app);\n\n\tapp->priority = ffs(prio) - 1;\n\treturn 0;\n}\n\n \nstatic int cxgb4_ieee_setapp(struct net_device *dev, struct dcb_app *app)\n{\n\tint ret;\n\n\tif (!cxgb4_ieee_negotiation_complete(dev, CXGB4_DCB_FW_APP_ID))\n\t\treturn -EINVAL;\n\tif (!(app->selector && app->protocol))\n\t\treturn -EINVAL;\n\n\tif (!(app->selector > IEEE_8021QAZ_APP_SEL_ETHERTYPE  &&\n\t      app->selector < IEEE_8021QAZ_APP_SEL_ANY))\n\t\treturn -EINVAL;\n\n\t \n\tret = __cxgb4_setapp(dev, app->selector - 1, app->protocol,\n\t\t\t     (1 << app->priority));\n\tif (ret)\n\t\treturn ret;\n\n\treturn dcb_ieee_setapp(dev, app);\n}\n\n \nstatic u8 cxgb4_getdcbx(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\n\t \n\treturn pi->dcb.supported;\n}\n\n \nstatic u8 cxgb4_setdcbx(struct net_device *dev, u8 dcb_request)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\n\t \n\tif ((dcb_request & (CXGB4_DCBX_FW_SUPPORT | CXGB4_DCBX_HOST_SUPPORT))\n\t    != dcb_request)\n\t\treturn 1;\n\n\t \n\tif (!cxgb4_dcb_state_synced(pi->dcb.state))\n\t\treturn 1;\n\n\t \n\tif (dcb_request != pi->dcb.supported)\n\t\treturn 1;\n\n\tpi->dcb.supported = dcb_request;\n\treturn 0;\n}\n\nstatic int cxgb4_getpeer_app(struct net_device *dev,\n\t\t\t     struct dcb_peer_app_info *info, u16 *app_count)\n{\n\tstruct fw_port_cmd pcmd;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint i, err = 0;\n\n\tif (!cxgb4_dcb_state_synced(pi->dcb.state))\n\t\treturn 1;\n\n\tinfo->willing = 0;\n\tinfo->error = 0;\n\n\t*app_count = 0;\n\tfor (i = 0; i < CXGB4_MAX_DCBX_APP_SUPPORTED; i++) {\n\t\tINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\n\t\tpcmd.u.dcb.app_priority.type = FW_PORT_DCB_TYPE_APP_ID;\n\t\tpcmd.u.dcb.app_priority.idx = *app_count;\n\t\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\n\t\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\t\tdev_err(adap->pdev_dev, \"DCB app table read failed with %d\\n\",\n\t\t\t\t-err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tif (!pcmd.u.dcb.app_priority.protocolid)\n\t\t\tbreak;\n\t}\n\t*app_count = i;\n\treturn err;\n}\n\nstatic int cxgb4_getpeerapp_tbl(struct net_device *dev, struct dcb_app *table)\n{\n\tstruct fw_port_cmd pcmd;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint i, err = 0;\n\n\tif (!cxgb4_dcb_state_synced(pi->dcb.state))\n\t\treturn 1;\n\n\tfor (i = 0; i < CXGB4_MAX_DCBX_APP_SUPPORTED; i++) {\n\t\tINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\n\t\tpcmd.u.dcb.app_priority.type = FW_PORT_DCB_TYPE_APP_ID;\n\t\tpcmd.u.dcb.app_priority.idx = i;\n\t\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\n\t\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\t\tdev_err(adap->pdev_dev, \"DCB app table read failed with %d\\n\",\n\t\t\t\t-err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tif (!pcmd.u.dcb.app_priority.protocolid)\n\t\t\tbreak;\n\n\t\ttable[i].selector = (pcmd.u.dcb.app_priority.sel_field + 1);\n\t\ttable[i].protocol =\n\t\t\tbe16_to_cpu(pcmd.u.dcb.app_priority.protocolid);\n\t\ttable[i].priority =\n\t\t\tffs(pcmd.u.dcb.app_priority.user_prio_map) - 1;\n\t}\n\treturn err;\n}\n\n \nstatic int cxgb4_cee_peer_getpg(struct net_device *dev, struct cee_pg *pg)\n{\n\tstruct fw_port_cmd pcmd;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = pi->adapter;\n\tu32 pgid;\n\tint i, err;\n\n\t \n\tpg->willing = true;\n\n\tINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\n\tpcmd.u.dcb.pgid.type = FW_PORT_DCB_TYPE_PGID;\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\tdev_err(adap->pdev_dev, \"DCB read PGID failed with %d\\n\", -err);\n\t\treturn err;\n\t}\n\tpgid = be32_to_cpu(pcmd.u.dcb.pgid.pgid);\n\n\tfor (i = 0; i < CXGB4_MAX_PRIORITY; i++)\n\t\tpg->prio_pg[7 - i] = (pgid >> (i * 4)) & 0xF;\n\n\tINIT_PORT_DCB_READ_PEER_CMD(pcmd, pi->port_id);\n\tpcmd.u.dcb.pgrate.type = FW_PORT_DCB_TYPE_PGRATE;\n\terr = t4_wr_mbox(adap, adap->mbox, &pcmd, sizeof(pcmd), &pcmd);\n\tif (err != FW_PORT_DCB_CFG_SUCCESS) {\n\t\tdev_err(adap->pdev_dev, \"DCB read PGRATE failed with %d\\n\",\n\t\t\t-err);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < CXGB4_MAX_PRIORITY; i++)\n\t\tpg->pg_bw[i] = pcmd.u.dcb.pgrate.pgrate[i];\n\n\tpg->tcs_supported = pcmd.u.dcb.pgrate.num_tcs_supported;\n\n\treturn 0;\n}\n\n \nstatic int cxgb4_cee_peer_getpfc(struct net_device *dev, struct cee_pfc *pfc)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\n\tcxgb4_getnumtcs(dev, DCB_NUMTCS_ATTR_PFC, &(pfc->tcs_supported));\n\n\t \n\tpfc->pfc_en = bitswap_1(pi->dcb.pfcen);\n\n\tpfc->tcs_supported = pi->dcb.pfc_num_tcs_supported;\n\n\treturn 0;\n}\n\nconst struct dcbnl_rtnl_ops cxgb4_dcb_ops = {\n\t.ieee_getets\t\t= cxgb4_ieee_get_ets,\n\t.ieee_getpfc\t\t= cxgb4_ieee_get_pfc,\n\t.ieee_getapp\t\t= cxgb4_ieee_getapp,\n\t.ieee_setapp\t\t= cxgb4_ieee_setapp,\n\t.ieee_peer_getets\t= cxgb4_ieee_peer_ets,\n\t.ieee_peer_getpfc\t= cxgb4_ieee_get_pfc,\n\n\t \n\t.getstate\t\t= cxgb4_getstate,\n\t.setstate\t\t= cxgb4_setstate,\n\t.getpgtccfgtx\t\t= cxgb4_getpgtccfg_tx,\n\t.getpgbwgcfgtx\t\t= cxgb4_getpgbwgcfg_tx,\n\t.getpgtccfgrx\t\t= cxgb4_getpgtccfg_rx,\n\t.getpgbwgcfgrx\t\t= cxgb4_getpgbwgcfg_rx,\n\t.setpgtccfgtx\t\t= cxgb4_setpgtccfg_tx,\n\t.setpgbwgcfgtx\t\t= cxgb4_setpgbwgcfg_tx,\n\t.setpfccfg\t\t= cxgb4_setpfccfg,\n\t.getpfccfg\t\t= cxgb4_getpfccfg,\n\t.setall\t\t\t= cxgb4_setall,\n\t.getcap\t\t\t= cxgb4_getcap,\n\t.getnumtcs\t\t= cxgb4_getnumtcs,\n\t.setnumtcs\t\t= cxgb4_setnumtcs,\n\t.getpfcstate\t\t= cxgb4_getpfcstate,\n\t.setpfcstate\t\t= cxgb4_setpfcstate,\n\t.getapp\t\t\t= cxgb4_getapp,\n\t.setapp\t\t\t= cxgb4_setapp,\n\n\t \n\t.getdcbx\t\t= cxgb4_getdcbx,\n\t.setdcbx\t\t= cxgb4_setdcbx,\n\n\t \n\t.peer_getappinfo\t= cxgb4_getpeer_app,\n\t.peer_getapptable\t= cxgb4_getpeerapp_tbl,\n\n\t \n\t.cee_peer_getpg\t\t= cxgb4_cee_peer_getpg,\n\t.cee_peer_getpfc\t= cxgb4_cee_peer_getpfc,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}