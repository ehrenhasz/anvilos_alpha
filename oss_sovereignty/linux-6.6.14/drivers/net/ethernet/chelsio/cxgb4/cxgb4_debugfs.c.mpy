{
  "module_name": "cxgb4_debugfs.c",
  "hash_id": "c0b4f479735c34737c5f527936486b7bbf5fda2652654c44c6b15d2936a7b0fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c",
  "human_readable_source": " \n\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/string_helpers.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n\n#include \"cxgb4.h\"\n#include \"t4_regs.h\"\n#include \"t4_values.h\"\n#include \"t4fw_api.h\"\n#include \"cxgb4_debugfs.h\"\n#include \"clip_tbl.h\"\n#include \"l2t.h\"\n#include \"cudbg_if.h\"\n#include \"cudbg_lib_common.h\"\n#include \"cudbg_entity.h\"\n#include \"cudbg_lib.h\"\n#include \"cxgb4_tc_mqprio.h\"\n\n \nstatic void *seq_tab_get_idx(struct seq_tab *tb, loff_t pos)\n{\n\tpos -= tb->skip_first;\n\treturn pos >= tb->rows ? NULL : &tb->data[pos * tb->width];\n}\n\nstatic void *seq_tab_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct seq_tab *tb = seq->private;\n\n\tif (tb->skip_first && *pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn seq_tab_get_idx(tb, *pos);\n}\n\nstatic void *seq_tab_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tv = seq_tab_get_idx(seq->private, *pos + 1);\n\t++(*pos);\n\treturn v;\n}\n\nstatic void seq_tab_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic int seq_tab_show(struct seq_file *seq, void *v)\n{\n\tconst struct seq_tab *tb = seq->private;\n\n\treturn tb->show(seq, v, ((char *)v - tb->data) / tb->width);\n}\n\nstatic const struct seq_operations seq_tab_ops = {\n\t.start = seq_tab_start,\n\t.next  = seq_tab_next,\n\t.stop  = seq_tab_stop,\n\t.show  = seq_tab_show\n};\n\nstruct seq_tab *seq_open_tab(struct file *f, unsigned int rows,\n\t\t\t     unsigned int width, unsigned int have_header,\n\t\t\t     int (*show)(struct seq_file *seq, void *v, int i))\n{\n\tstruct seq_tab *p;\n\n\tp = __seq_open_private(f, &seq_tab_ops, sizeof(*p) + rows * width);\n\tif (p) {\n\t\tp->show = show;\n\t\tp->rows = rows;\n\t\tp->width = width;\n\t\tp->skip_first = have_header != 0;\n\t}\n\treturn p;\n}\n\n \nstatic int seq_tab_trim(struct seq_tab *p, unsigned int new_rows)\n{\n\tif (new_rows > p->rows)\n\t\treturn -EINVAL;\n\tp->rows = new_rows;\n\treturn 0;\n}\n\nstatic int cim_la_show(struct seq_file *seq, void *v, int idx)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"Status   Data      PC     LS0Stat  LS0Addr \"\n\t\t\t \"            LS0Data\\n\");\n\telse {\n\t\tconst u32 *p = v;\n\n\t\tseq_printf(seq,\n\t\t\t   \"  %02x  %x%07x %x%07x %08x %08x %08x%08x%08x%08x\\n\",\n\t\t\t   (p[0] >> 4) & 0xff, p[0] & 0xf, p[1] >> 4,\n\t\t\t   p[1] & 0xf, p[2] >> 4, p[2] & 0xf, p[3], p[4], p[5],\n\t\t\t   p[6], p[7]);\n\t}\n\treturn 0;\n}\n\nstatic int cim_la_show_3in1(struct seq_file *seq, void *v, int idx)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"Status   Data      PC\\n\");\n\t} else {\n\t\tconst u32 *p = v;\n\n\t\tseq_printf(seq, \"  %02x   %08x %08x\\n\", p[5] & 0xff, p[6],\n\t\t\t   p[7]);\n\t\tseq_printf(seq, \"  %02x   %02x%06x %02x%06x\\n\",\n\t\t\t   (p[3] >> 8) & 0xff, p[3] & 0xff, p[4] >> 8,\n\t\t\t   p[4] & 0xff, p[5] >> 8);\n\t\tseq_printf(seq, \"  %02x   %x%07x %x%07x\\n\", (p[0] >> 4) & 0xff,\n\t\t\t   p[0] & 0xf, p[1] >> 4, p[1] & 0xf, p[2] >> 4);\n\t}\n\treturn 0;\n}\n\nstatic int cim_la_show_t6(struct seq_file *seq, void *v, int idx)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"Status   Inst    Data      PC     LS0Stat  \"\n\t\t\t \"LS0Addr  LS0Data  LS1Stat  LS1Addr  LS1Data\\n\");\n\t} else {\n\t\tconst u32 *p = v;\n\n\t\tseq_printf(seq, \"  %02x   %04x%04x %04x%04x %04x%04x %08x %08x %08x %08x %08x %08x\\n\",\n\t\t\t   (p[9] >> 16) & 0xff,        \n\t\t\t   p[9] & 0xffff, p[8] >> 16,  \n\t\t\t   p[8] & 0xffff, p[7] >> 16,  \n\t\t\t   p[7] & 0xffff, p[6] >> 16,  \n\t\t\t   p[2], p[1], p[0],       \n\t\t\t   p[5], p[4], p[3]);      \n\t}\n\treturn 0;\n}\n\nstatic int cim_la_show_pc_t6(struct seq_file *seq, void *v, int idx)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"Status   Inst    Data      PC\\n\");\n\t} else {\n\t\tconst u32 *p = v;\n\n\t\tseq_printf(seq, \"  %02x   %08x %08x %08x\\n\",\n\t\t\t   p[3] & 0xff, p[2], p[1], p[0]);\n\t\tseq_printf(seq, \"  %02x   %02x%06x %02x%06x %02x%06x\\n\",\n\t\t\t   (p[6] >> 8) & 0xff, p[6] & 0xff, p[5] >> 8,\n\t\t\t   p[5] & 0xff, p[4] >> 8, p[4] & 0xff, p[3] >> 8);\n\t\tseq_printf(seq, \"  %02x   %04x%04x %04x%04x %04x%04x\\n\",\n\t\t\t   (p[9] >> 16) & 0xff, p[9] & 0xffff, p[8] >> 16,\n\t\t\t   p[8] & 0xffff, p[7] >> 16, p[7] & 0xffff,\n\t\t\t   p[6] >> 16);\n\t}\n\treturn 0;\n}\n\nstatic int cim_la_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\tunsigned int cfg;\n\tstruct seq_tab *p;\n\tstruct adapter *adap = inode->i_private;\n\n\tret = t4_cim_read(adap, UP_UP_DBG_LA_CFG_A, 1, &cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (is_t6(adap->params.chip)) {\n\t\t \n\t\tp = seq_open_tab(file, (adap->params.cim_la_size / 10) + 1,\n\t\t\t\t 10 * sizeof(u32), 1,\n\t\t\t\t cfg & UPDBGLACAPTPCONLY_F ?\n\t\t\t\t\tcim_la_show_pc_t6 : cim_la_show_t6);\n\t} else {\n\t\tp = seq_open_tab(file, adap->params.cim_la_size / 8,\n\t\t\t\t 8 * sizeof(u32), 1,\n\t\t\t\t cfg & UPDBGLACAPTPCONLY_F ? cim_la_show_3in1 :\n\t\t\t\t\t\t\t     cim_la_show);\n\t}\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = t4_cim_read_la(adap, (u32 *)p->data, NULL);\n\tif (ret)\n\t\tseq_release_private(inode, file);\n\treturn ret;\n}\n\nstatic const struct file_operations cim_la_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = cim_la_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private\n};\n\nstatic int cim_pif_la_show(struct seq_file *seq, void *v, int idx)\n{\n\tconst u32 *p = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"Cntl ID DataBE   Addr                 Data\\n\");\n\t} else if (idx < CIM_PIFLA_SIZE) {\n\t\tseq_printf(seq, \" %02x  %02x  %04x  %08x %08x%08x%08x%08x\\n\",\n\t\t\t   (p[5] >> 22) & 0xff, (p[5] >> 16) & 0x3f,\n\t\t\t   p[5] & 0xffff, p[4], p[3], p[2], p[1], p[0]);\n\t} else {\n\t\tif (idx == CIM_PIFLA_SIZE)\n\t\t\tseq_puts(seq, \"\\nCntl ID               Data\\n\");\n\t\tseq_printf(seq, \" %02x  %02x %08x%08x%08x%08x\\n\",\n\t\t\t   (p[4] >> 6) & 0xff, p[4] & 0x3f,\n\t\t\t   p[3], p[2], p[1], p[0]);\n\t}\n\treturn 0;\n}\n\nstatic int cim_pif_la_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_tab *p;\n\tstruct adapter *adap = inode->i_private;\n\n\tp = seq_open_tab(file, 2 * CIM_PIFLA_SIZE, 6 * sizeof(u32), 1,\n\t\t\t cim_pif_la_show);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tt4_cim_read_pif_la(adap, (u32 *)p->data,\n\t\t\t   (u32 *)p->data + 6 * CIM_PIFLA_SIZE, NULL, NULL);\n\treturn 0;\n}\n\nstatic const struct file_operations cim_pif_la_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = cim_pif_la_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private\n};\n\nstatic int cim_ma_la_show(struct seq_file *seq, void *v, int idx)\n{\n\tconst u32 *p = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"\\n\");\n\t} else if (idx < CIM_MALA_SIZE) {\n\t\tseq_printf(seq, \"%02x%08x%08x%08x%08x\\n\",\n\t\t\t   p[4], p[3], p[2], p[1], p[0]);\n\t} else {\n\t\tif (idx == CIM_MALA_SIZE)\n\t\t\tseq_puts(seq,\n\t\t\t\t \"\\nCnt ID Tag UE       Data       RDY VLD\\n\");\n\t\tseq_printf(seq, \"%3u %2u  %x   %u %08x%08x  %u   %u\\n\",\n\t\t\t   (p[2] >> 10) & 0xff, (p[2] >> 7) & 7,\n\t\t\t   (p[2] >> 3) & 0xf, (p[2] >> 2) & 1,\n\t\t\t   (p[1] >> 2) | ((p[2] & 3) << 30),\n\t\t\t   (p[0] >> 2) | ((p[1] & 3) << 30), (p[0] >> 1) & 1,\n\t\t\t   p[0] & 1);\n\t}\n\treturn 0;\n}\n\nstatic int cim_ma_la_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_tab *p;\n\tstruct adapter *adap = inode->i_private;\n\n\tp = seq_open_tab(file, 2 * CIM_MALA_SIZE, 5 * sizeof(u32), 1,\n\t\t\t cim_ma_la_show);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tt4_cim_read_ma_la(adap, (u32 *)p->data,\n\t\t\t  (u32 *)p->data + 5 * CIM_MALA_SIZE);\n\treturn 0;\n}\n\nstatic const struct file_operations cim_ma_la_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = cim_ma_la_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private\n};\n\nstatic int cim_qcfg_show(struct seq_file *seq, void *v)\n{\n\tstatic const char * const qname[] = {\n\t\t\"TP0\", \"TP1\", \"ULP\", \"SGE0\", \"SGE1\", \"NC-SI\",\n\t\t\"ULP0\", \"ULP1\", \"ULP2\", \"ULP3\", \"SGE\", \"NC-SI\",\n\t\t\"SGE0-RX\", \"SGE1-RX\"\n\t};\n\n\tint i;\n\tstruct adapter *adap = seq->private;\n\tu16 base[CIM_NUM_IBQ + CIM_NUM_OBQ_T5];\n\tu16 size[CIM_NUM_IBQ + CIM_NUM_OBQ_T5];\n\tu32 stat[(4 * (CIM_NUM_IBQ + CIM_NUM_OBQ_T5))];\n\tu16 thres[CIM_NUM_IBQ];\n\tu32 obq_wr_t4[2 * CIM_NUM_OBQ], *wr;\n\tu32 obq_wr_t5[2 * CIM_NUM_OBQ_T5];\n\tu32 *p = stat;\n\tint cim_num_obq = is_t4(adap->params.chip) ?\n\t\t\t\tCIM_NUM_OBQ : CIM_NUM_OBQ_T5;\n\n\ti = t4_cim_read(adap, is_t4(adap->params.chip) ? UP_IBQ_0_RDADDR_A :\n\t\t\tUP_IBQ_0_SHADOW_RDADDR_A,\n\t\t\tARRAY_SIZE(stat), stat);\n\tif (!i) {\n\t\tif (is_t4(adap->params.chip)) {\n\t\t\ti = t4_cim_read(adap, UP_OBQ_0_REALADDR_A,\n\t\t\t\t\tARRAY_SIZE(obq_wr_t4), obq_wr_t4);\n\t\t\twr = obq_wr_t4;\n\t\t} else {\n\t\t\ti = t4_cim_read(adap, UP_OBQ_0_SHADOW_REALADDR_A,\n\t\t\t\t\tARRAY_SIZE(obq_wr_t5), obq_wr_t5);\n\t\t\twr = obq_wr_t5;\n\t\t}\n\t}\n\tif (i)\n\t\treturn i;\n\n\tt4_read_cimq_cfg(adap, base, size, thres);\n\n\tseq_printf(seq,\n\t\t   \"  Queue  Base  Size Thres  RdPtr WrPtr  SOP  EOP Avail\\n\");\n\tfor (i = 0; i < CIM_NUM_IBQ; i++, p += 4)\n\t\tseq_printf(seq, \"%7s %5x %5u %5u %6x  %4x %4u %4u %5u\\n\",\n\t\t\t   qname[i], base[i], size[i], thres[i],\n\t\t\t   IBQRDADDR_G(p[0]), IBQWRADDR_G(p[1]),\n\t\t\t   QUESOPCNT_G(p[3]), QUEEOPCNT_G(p[3]),\n\t\t\t   QUEREMFLITS_G(p[2]) * 16);\n\tfor ( ; i < CIM_NUM_IBQ + cim_num_obq; i++, p += 4, wr += 2)\n\t\tseq_printf(seq, \"%7s %5x %5u %12x  %4x %4u %4u %5u\\n\",\n\t\t\t   qname[i], base[i], size[i],\n\t\t\t   QUERDADDR_G(p[0]) & 0x3fff, wr[0] - base[i],\n\t\t\t   QUESOPCNT_G(p[3]), QUEEOPCNT_G(p[3]),\n\t\t\t   QUEREMFLITS_G(p[2]) * 16);\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(cim_qcfg);\n\nstatic int cimq_show(struct seq_file *seq, void *v, int idx)\n{\n\tconst u32 *p = v;\n\n\tseq_printf(seq, \"%#06x: %08x %08x %08x %08x\\n\", idx * 16, p[0], p[1],\n\t\t   p[2], p[3]);\n\treturn 0;\n}\n\nstatic int cim_ibq_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\tstruct seq_tab *p;\n\tunsigned int qid = (uintptr_t)inode->i_private & 7;\n\tstruct adapter *adap = inode->i_private - qid;\n\n\tp = seq_open_tab(file, CIM_IBQ_SIZE, 4 * sizeof(u32), 0, cimq_show);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = t4_read_cim_ibq(adap, qid, (u32 *)p->data, CIM_IBQ_SIZE * 4);\n\tif (ret < 0)\n\t\tseq_release_private(inode, file);\n\telse\n\t\tret = 0;\n\treturn ret;\n}\n\nstatic const struct file_operations cim_ibq_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = cim_ibq_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private\n};\n\nstatic int cim_obq_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\tstruct seq_tab *p;\n\tunsigned int qid = (uintptr_t)inode->i_private & 7;\n\tstruct adapter *adap = inode->i_private - qid;\n\n\tp = seq_open_tab(file, 6 * CIM_OBQ_SIZE, 4 * sizeof(u32), 0, cimq_show);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = t4_read_cim_obq(adap, qid, (u32 *)p->data, 6 * CIM_OBQ_SIZE * 4);\n\tif (ret < 0) {\n\t\tseq_release_private(inode, file);\n\t} else {\n\t\tseq_tab_trim(p, ret / 4);\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations cim_obq_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = cim_obq_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private\n};\n\nstruct field_desc {\n\tconst char *name;\n\tunsigned int start;\n\tunsigned int width;\n};\n\nstatic void field_desc_show(struct seq_file *seq, u64 v,\n\t\t\t    const struct field_desc *p)\n{\n\tchar buf[32];\n\tint line_size = 0;\n\n\twhile (p->name) {\n\t\tu64 mask = (1ULL << p->width) - 1;\n\t\tint len = scnprintf(buf, sizeof(buf), \"%s: %llu\", p->name,\n\t\t\t\t    ((unsigned long long)v >> p->start) & mask);\n\n\t\tif (line_size + len >= 79) {\n\t\t\tline_size = 8;\n\t\t\tseq_puts(seq, \"\\n        \");\n\t\t}\n\t\tseq_printf(seq, \"%s \", buf);\n\t\tline_size += len + 1;\n\t\tp++;\n\t}\n\tseq_putc(seq, '\\n');\n}\n\nstatic struct field_desc tp_la0[] = {\n\t{ \"RcfOpCodeOut\", 60, 4 },\n\t{ \"State\", 56, 4 },\n\t{ \"WcfState\", 52, 4 },\n\t{ \"RcfOpcSrcOut\", 50, 2 },\n\t{ \"CRxError\", 49, 1 },\n\t{ \"ERxError\", 48, 1 },\n\t{ \"SanityFailed\", 47, 1 },\n\t{ \"SpuriousMsg\", 46, 1 },\n\t{ \"FlushInputMsg\", 45, 1 },\n\t{ \"FlushInputCpl\", 44, 1 },\n\t{ \"RssUpBit\", 43, 1 },\n\t{ \"RssFilterHit\", 42, 1 },\n\t{ \"Tid\", 32, 10 },\n\t{ \"InitTcb\", 31, 1 },\n\t{ \"LineNumber\", 24, 7 },\n\t{ \"Emsg\", 23, 1 },\n\t{ \"EdataOut\", 22, 1 },\n\t{ \"Cmsg\", 21, 1 },\n\t{ \"CdataOut\", 20, 1 },\n\t{ \"EreadPdu\", 19, 1 },\n\t{ \"CreadPdu\", 18, 1 },\n\t{ \"TunnelPkt\", 17, 1 },\n\t{ \"RcfPeerFin\", 16, 1 },\n\t{ \"RcfReasonOut\", 12, 4 },\n\t{ \"TxCchannel\", 10, 2 },\n\t{ \"RcfTxChannel\", 8, 2 },\n\t{ \"RxEchannel\", 6, 2 },\n\t{ \"RcfRxChannel\", 5, 1 },\n\t{ \"RcfDataOutSrdy\", 4, 1 },\n\t{ \"RxDvld\", 3, 1 },\n\t{ \"RxOoDvld\", 2, 1 },\n\t{ \"RxCongestion\", 1, 1 },\n\t{ \"TxCongestion\", 0, 1 },\n\t{ NULL }\n};\n\nstatic int tp_la_show(struct seq_file *seq, void *v, int idx)\n{\n\tconst u64 *p = v;\n\n\tfield_desc_show(seq, *p, tp_la0);\n\treturn 0;\n}\n\nstatic int tp_la_show2(struct seq_file *seq, void *v, int idx)\n{\n\tconst u64 *p = v;\n\n\tif (idx)\n\t\tseq_putc(seq, '\\n');\n\tfield_desc_show(seq, p[0], tp_la0);\n\tif (idx < (TPLA_SIZE / 2 - 1) || p[1] != ~0ULL)\n\t\tfield_desc_show(seq, p[1], tp_la0);\n\treturn 0;\n}\n\nstatic int tp_la_show3(struct seq_file *seq, void *v, int idx)\n{\n\tstatic struct field_desc tp_la1[] = {\n\t\t{ \"CplCmdIn\", 56, 8 },\n\t\t{ \"CplCmdOut\", 48, 8 },\n\t\t{ \"ESynOut\", 47, 1 },\n\t\t{ \"EAckOut\", 46, 1 },\n\t\t{ \"EFinOut\", 45, 1 },\n\t\t{ \"ERstOut\", 44, 1 },\n\t\t{ \"SynIn\", 43, 1 },\n\t\t{ \"AckIn\", 42, 1 },\n\t\t{ \"FinIn\", 41, 1 },\n\t\t{ \"RstIn\", 40, 1 },\n\t\t{ \"DataIn\", 39, 1 },\n\t\t{ \"DataInVld\", 38, 1 },\n\t\t{ \"PadIn\", 37, 1 },\n\t\t{ \"RxBufEmpty\", 36, 1 },\n\t\t{ \"RxDdp\", 35, 1 },\n\t\t{ \"RxFbCongestion\", 34, 1 },\n\t\t{ \"TxFbCongestion\", 33, 1 },\n\t\t{ \"TxPktSumSrdy\", 32, 1 },\n\t\t{ \"RcfUlpType\", 28, 4 },\n\t\t{ \"Eread\", 27, 1 },\n\t\t{ \"Ebypass\", 26, 1 },\n\t\t{ \"Esave\", 25, 1 },\n\t\t{ \"Static0\", 24, 1 },\n\t\t{ \"Cread\", 23, 1 },\n\t\t{ \"Cbypass\", 22, 1 },\n\t\t{ \"Csave\", 21, 1 },\n\t\t{ \"CPktOut\", 20, 1 },\n\t\t{ \"RxPagePoolFull\", 18, 2 },\n\t\t{ \"RxLpbkPkt\", 17, 1 },\n\t\t{ \"TxLpbkPkt\", 16, 1 },\n\t\t{ \"RxVfValid\", 15, 1 },\n\t\t{ \"SynLearned\", 14, 1 },\n\t\t{ \"SetDelEntry\", 13, 1 },\n\t\t{ \"SetInvEntry\", 12, 1 },\n\t\t{ \"CpcmdDvld\", 11, 1 },\n\t\t{ \"CpcmdSave\", 10, 1 },\n\t\t{ \"RxPstructsFull\", 8, 2 },\n\t\t{ \"EpcmdDvld\", 7, 1 },\n\t\t{ \"EpcmdFlush\", 6, 1 },\n\t\t{ \"EpcmdTrimPrefix\", 5, 1 },\n\t\t{ \"EpcmdTrimPostfix\", 4, 1 },\n\t\t{ \"ERssIp4Pkt\", 3, 1 },\n\t\t{ \"ERssIp6Pkt\", 2, 1 },\n\t\t{ \"ERssTcpUdpPkt\", 1, 1 },\n\t\t{ \"ERssFceFipPkt\", 0, 1 },\n\t\t{ NULL }\n\t};\n\tstatic struct field_desc tp_la2[] = {\n\t\t{ \"CplCmdIn\", 56, 8 },\n\t\t{ \"MpsVfVld\", 55, 1 },\n\t\t{ \"MpsPf\", 52, 3 },\n\t\t{ \"MpsVf\", 44, 8 },\n\t\t{ \"SynIn\", 43, 1 },\n\t\t{ \"AckIn\", 42, 1 },\n\t\t{ \"FinIn\", 41, 1 },\n\t\t{ \"RstIn\", 40, 1 },\n\t\t{ \"DataIn\", 39, 1 },\n\t\t{ \"DataInVld\", 38, 1 },\n\t\t{ \"PadIn\", 37, 1 },\n\t\t{ \"RxBufEmpty\", 36, 1 },\n\t\t{ \"RxDdp\", 35, 1 },\n\t\t{ \"RxFbCongestion\", 34, 1 },\n\t\t{ \"TxFbCongestion\", 33, 1 },\n\t\t{ \"TxPktSumSrdy\", 32, 1 },\n\t\t{ \"RcfUlpType\", 28, 4 },\n\t\t{ \"Eread\", 27, 1 },\n\t\t{ \"Ebypass\", 26, 1 },\n\t\t{ \"Esave\", 25, 1 },\n\t\t{ \"Static0\", 24, 1 },\n\t\t{ \"Cread\", 23, 1 },\n\t\t{ \"Cbypass\", 22, 1 },\n\t\t{ \"Csave\", 21, 1 },\n\t\t{ \"CPktOut\", 20, 1 },\n\t\t{ \"RxPagePoolFull\", 18, 2 },\n\t\t{ \"RxLpbkPkt\", 17, 1 },\n\t\t{ \"TxLpbkPkt\", 16, 1 },\n\t\t{ \"RxVfValid\", 15, 1 },\n\t\t{ \"SynLearned\", 14, 1 },\n\t\t{ \"SetDelEntry\", 13, 1 },\n\t\t{ \"SetInvEntry\", 12, 1 },\n\t\t{ \"CpcmdDvld\", 11, 1 },\n\t\t{ \"CpcmdSave\", 10, 1 },\n\t\t{ \"RxPstructsFull\", 8, 2 },\n\t\t{ \"EpcmdDvld\", 7, 1 },\n\t\t{ \"EpcmdFlush\", 6, 1 },\n\t\t{ \"EpcmdTrimPrefix\", 5, 1 },\n\t\t{ \"EpcmdTrimPostfix\", 4, 1 },\n\t\t{ \"ERssIp4Pkt\", 3, 1 },\n\t\t{ \"ERssIp6Pkt\", 2, 1 },\n\t\t{ \"ERssTcpUdpPkt\", 1, 1 },\n\t\t{ \"ERssFceFipPkt\", 0, 1 },\n\t\t{ NULL }\n\t};\n\tconst u64 *p = v;\n\n\tif (idx)\n\t\tseq_putc(seq, '\\n');\n\tfield_desc_show(seq, p[0], tp_la0);\n\tif (idx < (TPLA_SIZE / 2 - 1) || p[1] != ~0ULL)\n\t\tfield_desc_show(seq, p[1], (p[0] & BIT(17)) ? tp_la2 : tp_la1);\n\treturn 0;\n}\n\nstatic int tp_la_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_tab *p;\n\tstruct adapter *adap = inode->i_private;\n\n\tswitch (DBGLAMODE_G(t4_read_reg(adap, TP_DBG_LA_CONFIG_A))) {\n\tcase 2:\n\t\tp = seq_open_tab(file, TPLA_SIZE / 2, 2 * sizeof(u64), 0,\n\t\t\t\t tp_la_show2);\n\t\tbreak;\n\tcase 3:\n\t\tp = seq_open_tab(file, TPLA_SIZE / 2, 2 * sizeof(u64), 0,\n\t\t\t\t tp_la_show3);\n\t\tbreak;\n\tdefault:\n\t\tp = seq_open_tab(file, TPLA_SIZE, sizeof(u64), 0, tp_la_show);\n\t}\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tt4_tp_read_la(adap, (u64 *)p->data, NULL);\n\treturn 0;\n}\n\nstatic ssize_t tp_la_write(struct file *file, const char __user *buf,\n\t\t\t   size_t count, loff_t *pos)\n{\n\tint err;\n\tchar s[32];\n\tunsigned long val;\n\tsize_t size = min(sizeof(s) - 1, count);\n\tstruct adapter *adap = file_inode(file)->i_private;\n\n\tif (copy_from_user(s, buf, size))\n\t\treturn -EFAULT;\n\ts[size] = '\\0';\n\terr = kstrtoul(s, 0, &val);\n\tif (err)\n\t\treturn err;\n\tif (val > 0xffff)\n\t\treturn -EINVAL;\n\tadap->params.tp.la_mask = val << 16;\n\tt4_set_reg_field(adap, TP_DBG_LA_CONFIG_A, 0xffff0000U,\n\t\t\t adap->params.tp.la_mask);\n\treturn count;\n}\n\nstatic const struct file_operations tp_la_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = tp_la_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private,\n\t.write   = tp_la_write\n};\n\nstatic int ulprx_la_show(struct seq_file *seq, void *v, int idx)\n{\n\tconst u32 *p = v;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"      Pcmd        Type   Message\"\n\t\t\t \"                Data\\n\");\n\telse\n\t\tseq_printf(seq, \"%08x%08x  %4x  %08x  %08x%08x%08x%08x\\n\",\n\t\t\t   p[1], p[0], p[2], p[3], p[7], p[6], p[5], p[4]);\n\treturn 0;\n}\n\nstatic int ulprx_la_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_tab *p;\n\tstruct adapter *adap = inode->i_private;\n\n\tp = seq_open_tab(file, ULPRX_LA_SIZE, 8 * sizeof(u32), 1,\n\t\t\t ulprx_la_show);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tt4_ulprx_read_la(adap, (u32 *)p->data);\n\treturn 0;\n}\n\nstatic const struct file_operations ulprx_la_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = ulprx_la_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private\n};\n\n \nstatic int pm_stats_show(struct seq_file *seq, void *v)\n{\n\tstatic const char * const tx_pm_stats[] = {\n\t\t\"Read:\", \"Write bypass:\", \"Write mem:\", \"Bypass + mem:\"\n\t};\n\tstatic const char * const rx_pm_stats[] = {\n\t\t\"Read:\", \"Write bypass:\", \"Write mem:\", \"Flush:\"\n\t};\n\n\tint i;\n\tu32 tx_cnt[T6_PM_NSTATS], rx_cnt[T6_PM_NSTATS];\n\tu64 tx_cyc[T6_PM_NSTATS], rx_cyc[T6_PM_NSTATS];\n\tstruct adapter *adap = seq->private;\n\n\tt4_pmtx_get_stats(adap, tx_cnt, tx_cyc);\n\tt4_pmrx_get_stats(adap, rx_cnt, rx_cyc);\n\n\tseq_printf(seq, \"%13s %10s  %20s\\n\", \" \", \"Tx pcmds\", \"Tx bytes\");\n\tfor (i = 0; i < PM_NSTATS - 1; i++)\n\t\tseq_printf(seq, \"%-13s %10u  %20llu\\n\",\n\t\t\t   tx_pm_stats[i], tx_cnt[i], tx_cyc[i]);\n\n\tseq_printf(seq, \"%13s %10s  %20s\\n\", \" \", \"Rx pcmds\", \"Rx bytes\");\n\tfor (i = 0; i < PM_NSTATS - 1; i++)\n\t\tseq_printf(seq, \"%-13s %10u  %20llu\\n\",\n\t\t\t   rx_pm_stats[i], rx_cnt[i], rx_cyc[i]);\n\n\tif (CHELSIO_CHIP_VERSION(adap->params.chip) > CHELSIO_T5) {\n\t\t \n\t\tseq_printf(seq, \"%13s %10s  %20s\\n\",\n\t\t\t   \" \", \"Total wait\", \"Total Occupancy\");\n\t\tseq_printf(seq, \"Tx FIFO wait  %10u  %20llu\\n\",\n\t\t\t   tx_cnt[i], tx_cyc[i]);\n\t\tseq_printf(seq, \"Rx FIFO wait  %10u  %20llu\\n\",\n\t\t\t   rx_cnt[i], rx_cyc[i]);\n\n\t\t \n\t\ti += 2;\n\n\t\t \n\t\tseq_printf(seq, \"%13s %10s  %20s\\n\",\n\t\t\t   \" \", \"Reads\", \"Total wait\");\n\t\tseq_printf(seq, \"Tx latency    %10u  %20llu\\n\",\n\t\t\t   tx_cnt[i], tx_cyc[i]);\n\t\tseq_printf(seq, \"Rx latency    %10u  %20llu\\n\",\n\t\t\t   rx_cnt[i], rx_cyc[i]);\n\t}\n\treturn 0;\n}\n\nstatic int pm_stats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, pm_stats_show, inode->i_private);\n}\n\nstatic ssize_t pm_stats_clear(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *pos)\n{\n\tstruct adapter *adap = file_inode(file)->i_private;\n\n\tt4_write_reg(adap, PM_RX_STAT_CONFIG_A, 0);\n\tt4_write_reg(adap, PM_TX_STAT_CONFIG_A, 0);\n\treturn count;\n}\n\nstatic const struct file_operations pm_stats_debugfs_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = pm_stats_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = single_release,\n\t.write   = pm_stats_clear\n};\n\nstatic int tx_rate_show(struct seq_file *seq, void *v)\n{\n\tu64 nrate[NCHAN], orate[NCHAN];\n\tstruct adapter *adap = seq->private;\n\n\tt4_get_chan_txrate(adap, nrate, orate);\n\tif (adap->params.arch.nchan == NCHAN) {\n\t\tseq_puts(seq, \"              channel 0   channel 1   \"\n\t\t\t \"channel 2   channel 3\\n\");\n\t\tseq_printf(seq, \"NIC B/s:     %10llu  %10llu  %10llu  %10llu\\n\",\n\t\t\t   (unsigned long long)nrate[0],\n\t\t\t   (unsigned long long)nrate[1],\n\t\t\t   (unsigned long long)nrate[2],\n\t\t\t   (unsigned long long)nrate[3]);\n\t\tseq_printf(seq, \"Offload B/s: %10llu  %10llu  %10llu  %10llu\\n\",\n\t\t\t   (unsigned long long)orate[0],\n\t\t\t   (unsigned long long)orate[1],\n\t\t\t   (unsigned long long)orate[2],\n\t\t\t   (unsigned long long)orate[3]);\n\t} else {\n\t\tseq_puts(seq, \"              channel 0   channel 1\\n\");\n\t\tseq_printf(seq, \"NIC B/s:     %10llu  %10llu\\n\",\n\t\t\t   (unsigned long long)nrate[0],\n\t\t\t   (unsigned long long)nrate[1]);\n\t\tseq_printf(seq, \"Offload B/s: %10llu  %10llu\\n\",\n\t\t\t   (unsigned long long)orate[0],\n\t\t\t   (unsigned long long)orate[1]);\n\t}\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(tx_rate);\n\nstatic int cctrl_tbl_show(struct seq_file *seq, void *v)\n{\n\tstatic const char * const dec_fac[] = {\n\t\t\"0.5\", \"0.5625\", \"0.625\", \"0.6875\", \"0.75\", \"0.8125\", \"0.875\",\n\t\t\"0.9375\" };\n\n\tint i;\n\tu16 (*incr)[NCCTRL_WIN];\n\tstruct adapter *adap = seq->private;\n\n\tincr = kmalloc_array(NMTUS, sizeof(*incr), GFP_KERNEL);\n\tif (!incr)\n\t\treturn -ENOMEM;\n\n\tt4_read_cong_tbl(adap, incr);\n\n\tfor (i = 0; i < NCCTRL_WIN; ++i) {\n\t\tseq_printf(seq, \"%2d: %4u %4u %4u %4u %4u %4u %4u %4u\\n\", i,\n\t\t\t   incr[0][i], incr[1][i], incr[2][i], incr[3][i],\n\t\t\t   incr[4][i], incr[5][i], incr[6][i], incr[7][i]);\n\t\tseq_printf(seq, \"%8u %4u %4u %4u %4u %4u %4u %4u %5u %s\\n\",\n\t\t\t   incr[8][i], incr[9][i], incr[10][i], incr[11][i],\n\t\t\t   incr[12][i], incr[13][i], incr[14][i], incr[15][i],\n\t\t\t   adap->params.a_wnd[i],\n\t\t\t   dec_fac[adap->params.b_wnd[i]]);\n\t}\n\n\tkfree(incr);\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(cctrl_tbl);\n\n \nstatic char *unit_conv(char *buf, size_t len, unsigned int val,\n\t\t       unsigned int factor)\n{\n\tunsigned int rem = val % factor;\n\n\tif (rem == 0) {\n\t\tsnprintf(buf, len, \"%u\", val / factor);\n\t} else {\n\t\twhile (rem % 10 == 0)\n\t\t\trem /= 10;\n\t\tsnprintf(buf, len, \"%u.%u\", val / factor, rem);\n\t}\n\treturn buf;\n}\n\nstatic int clk_show(struct seq_file *seq, void *v)\n{\n\tchar buf[32];\n\tstruct adapter *adap = seq->private;\n\tunsigned int cclk_ps = 1000000000 / adap->params.vpd.cclk;   \n\tu32 res = t4_read_reg(adap, TP_TIMER_RESOLUTION_A);\n\tunsigned int tre = TIMERRESOLUTION_G(res);\n\tunsigned int dack_re = DELAYEDACKRESOLUTION_G(res);\n\tunsigned long long tp_tick_us = (cclk_ps << tre) / 1000000;  \n\n\tseq_printf(seq, \"Core clock period: %s ns\\n\",\n\t\t   unit_conv(buf, sizeof(buf), cclk_ps, 1000));\n\tseq_printf(seq, \"TP timer tick: %s us\\n\",\n\t\t   unit_conv(buf, sizeof(buf), (cclk_ps << tre), 1000000));\n\tseq_printf(seq, \"TCP timestamp tick: %s us\\n\",\n\t\t   unit_conv(buf, sizeof(buf),\n\t\t\t     (cclk_ps << TIMESTAMPRESOLUTION_G(res)), 1000000));\n\tseq_printf(seq, \"DACK tick: %s us\\n\",\n\t\t   unit_conv(buf, sizeof(buf), (cclk_ps << dack_re), 1000000));\n\tseq_printf(seq, \"DACK timer: %u us\\n\",\n\t\t   ((cclk_ps << dack_re) / 1000000) *\n\t\t   t4_read_reg(adap, TP_DACK_TIMER_A));\n\tseq_printf(seq, \"Retransmit min: %llu us\\n\",\n\t\t   tp_tick_us * t4_read_reg(adap, TP_RXT_MIN_A));\n\tseq_printf(seq, \"Retransmit max: %llu us\\n\",\n\t\t   tp_tick_us * t4_read_reg(adap, TP_RXT_MAX_A));\n\tseq_printf(seq, \"Persist timer min: %llu us\\n\",\n\t\t   tp_tick_us * t4_read_reg(adap, TP_PERS_MIN_A));\n\tseq_printf(seq, \"Persist timer max: %llu us\\n\",\n\t\t   tp_tick_us * t4_read_reg(adap, TP_PERS_MAX_A));\n\tseq_printf(seq, \"Keepalive idle timer: %llu us\\n\",\n\t\t   tp_tick_us * t4_read_reg(adap, TP_KEEP_IDLE_A));\n\tseq_printf(seq, \"Keepalive interval: %llu us\\n\",\n\t\t   tp_tick_us * t4_read_reg(adap, TP_KEEP_INTVL_A));\n\tseq_printf(seq, \"Initial SRTT: %llu us\\n\",\n\t\t   tp_tick_us * INITSRTT_G(t4_read_reg(adap, TP_INIT_SRTT_A)));\n\tseq_printf(seq, \"FINWAIT2 timer: %llu us\\n\",\n\t\t   tp_tick_us * t4_read_reg(adap, TP_FINWAIT2_TIMER_A));\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(clk);\n\n \nstatic const char * const devlog_level_strings[] = {\n\t[FW_DEVLOG_LEVEL_EMERG]\t\t= \"EMERG\",\n\t[FW_DEVLOG_LEVEL_CRIT]\t\t= \"CRIT\",\n\t[FW_DEVLOG_LEVEL_ERR]\t\t= \"ERR\",\n\t[FW_DEVLOG_LEVEL_NOTICE]\t= \"NOTICE\",\n\t[FW_DEVLOG_LEVEL_INFO]\t\t= \"INFO\",\n\t[FW_DEVLOG_LEVEL_DEBUG]\t\t= \"DEBUG\"\n};\n\nstatic const char * const devlog_facility_strings[] = {\n\t[FW_DEVLOG_FACILITY_CORE]\t= \"CORE\",\n\t[FW_DEVLOG_FACILITY_CF]         = \"CF\",\n\t[FW_DEVLOG_FACILITY_SCHED]\t= \"SCHED\",\n\t[FW_DEVLOG_FACILITY_TIMER]\t= \"TIMER\",\n\t[FW_DEVLOG_FACILITY_RES]\t= \"RES\",\n\t[FW_DEVLOG_FACILITY_HW]\t\t= \"HW\",\n\t[FW_DEVLOG_FACILITY_FLR]\t= \"FLR\",\n\t[FW_DEVLOG_FACILITY_DMAQ]\t= \"DMAQ\",\n\t[FW_DEVLOG_FACILITY_PHY]\t= \"PHY\",\n\t[FW_DEVLOG_FACILITY_MAC]\t= \"MAC\",\n\t[FW_DEVLOG_FACILITY_PORT]\t= \"PORT\",\n\t[FW_DEVLOG_FACILITY_VI]\t\t= \"VI\",\n\t[FW_DEVLOG_FACILITY_FILTER]\t= \"FILTER\",\n\t[FW_DEVLOG_FACILITY_ACL]\t= \"ACL\",\n\t[FW_DEVLOG_FACILITY_TM]\t\t= \"TM\",\n\t[FW_DEVLOG_FACILITY_QFC]\t= \"QFC\",\n\t[FW_DEVLOG_FACILITY_DCB]\t= \"DCB\",\n\t[FW_DEVLOG_FACILITY_ETH]\t= \"ETH\",\n\t[FW_DEVLOG_FACILITY_OFLD]\t= \"OFLD\",\n\t[FW_DEVLOG_FACILITY_RI]\t\t= \"RI\",\n\t[FW_DEVLOG_FACILITY_ISCSI]\t= \"ISCSI\",\n\t[FW_DEVLOG_FACILITY_FCOE]\t= \"FCOE\",\n\t[FW_DEVLOG_FACILITY_FOISCSI]\t= \"FOISCSI\",\n\t[FW_DEVLOG_FACILITY_FOFCOE]\t= \"FOFCOE\"\n};\n\n \nstruct devlog_info {\n\tunsigned int nentries;\t\t \n\tunsigned int first;\t\t \n\tstruct fw_devlog_e log[];\t \n};\n\n \nstatic int devlog_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(seq, \"%10s  %15s  %8s  %8s  %s\\n\",\n\t\t\t   \"Seq#\", \"Tstamp\", \"Level\", \"Facility\", \"Message\");\n\telse {\n\t\tstruct devlog_info *dinfo = seq->private;\n\t\tint fidx = (uintptr_t)v - 2;\n\t\tunsigned long index;\n\t\tstruct fw_devlog_e *e;\n\n\t\t \n\t\tindex = dinfo->first + fidx;\n\t\tif (index >= dinfo->nentries)\n\t\t\tindex -= dinfo->nentries;\n\t\te = &dinfo->log[index];\n\t\tif (e->timestamp == 0)\n\t\t\treturn 0;\n\n\t\t \n\t\tseq_printf(seq, \"%10d  %15llu  %8s  %8s  \",\n\t\t\t   be32_to_cpu(e->seqno),\n\t\t\t   be64_to_cpu(e->timestamp),\n\t\t\t   (e->level < ARRAY_SIZE(devlog_level_strings)\n\t\t\t    ? devlog_level_strings[e->level]\n\t\t\t    : \"UNKNOWN\"),\n\t\t\t   (e->facility < ARRAY_SIZE(devlog_facility_strings)\n\t\t\t    ? devlog_facility_strings[e->facility]\n\t\t\t    : \"UNKNOWN\"));\n\t\tseq_printf(seq, e->fmt,\n\t\t\t   be32_to_cpu(e->params[0]),\n\t\t\t   be32_to_cpu(e->params[1]),\n\t\t\t   be32_to_cpu(e->params[2]),\n\t\t\t   be32_to_cpu(e->params[3]),\n\t\t\t   be32_to_cpu(e->params[4]),\n\t\t\t   be32_to_cpu(e->params[5]),\n\t\t\t   be32_to_cpu(e->params[6]),\n\t\t\t   be32_to_cpu(e->params[7]));\n\t}\n\treturn 0;\n}\n\n \nstatic inline void *devlog_get_idx(struct devlog_info *dinfo, loff_t pos)\n{\n\tif (pos > dinfo->nentries)\n\t\treturn NULL;\n\n\treturn (void *)(uintptr_t)(pos + 1);\n}\n\nstatic void *devlog_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct devlog_info *dinfo = seq->private;\n\n\treturn (*pos\n\t\t? devlog_get_idx(dinfo, *pos)\n\t\t: SEQ_START_TOKEN);\n}\n\nstatic void *devlog_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct devlog_info *dinfo = seq->private;\n\n\t(*pos)++;\n\treturn devlog_get_idx(dinfo, *pos);\n}\n\nstatic void devlog_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic const struct seq_operations devlog_seq_ops = {\n\t.start = devlog_start,\n\t.next  = devlog_next,\n\t.stop  = devlog_stop,\n\t.show  = devlog_show\n};\n\n \nstatic int devlog_open(struct inode *inode, struct file *file)\n{\n\tstruct adapter *adap = inode->i_private;\n\tstruct devlog_params *dparams = &adap->params.devlog;\n\tstruct devlog_info *dinfo;\n\tunsigned int index;\n\tu32 fseqno;\n\tint ret;\n\n\t \n\tif (dparams->start == 0)\n\t\treturn -ENXIO;\n\n\t \n\tdinfo = __seq_open_private(file, &devlog_seq_ops,\n\t\t\t\t   sizeof(*dinfo) + dparams->size);\n\tif (!dinfo)\n\t\treturn -ENOMEM;\n\n\t \n\tdinfo->nentries = (dparams->size / sizeof(struct fw_devlog_e));\n\tdinfo->first = 0;\n\tspin_lock(&adap->win0_lock);\n\tret = t4_memory_rw(adap, adap->params.drv_memwin, dparams->memtype,\n\t\t\t   dparams->start, dparams->size, (__be32 *)dinfo->log,\n\t\t\t   T4_MEMORY_READ);\n\tspin_unlock(&adap->win0_lock);\n\tif (ret) {\n\t\tseq_release_private(inode, file);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (fseqno = ~((u32)0), index = 0; index < dinfo->nentries; index++) {\n\t\tstruct fw_devlog_e *e = &dinfo->log[index];\n\t\t__u32 seqno;\n\n\t\tif (e->timestamp == 0)\n\t\t\tcontinue;\n\n\t\tseqno = be32_to_cpu(e->seqno);\n\t\tif (seqno < fseqno) {\n\t\t\tfseqno = seqno;\n\t\t\tdinfo->first = index;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct file_operations devlog_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = devlog_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private\n};\n\n \nstatic int mboxlog_show(struct seq_file *seq, void *v)\n{\n\tstruct adapter *adapter = seq->private;\n\tstruct mbox_cmd_log *log = adapter->mbox_log;\n\tstruct mbox_cmd *entry;\n\tint entry_idx, i;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(seq,\n\t\t\t   \"%10s  %15s  %5s  %5s  %s\\n\",\n\t\t\t   \"Seq#\", \"Tstamp\", \"Atime\", \"Etime\",\n\t\t\t   \"Command/Reply\");\n\t\treturn 0;\n\t}\n\n\tentry_idx = log->cursor + ((uintptr_t)v - 2);\n\tif (entry_idx >= log->size)\n\t\tentry_idx -= log->size;\n\tentry = mbox_cmd_log_entry(log, entry_idx);\n\n\t \n\tif (entry->timestamp == 0)\n\t\treturn 0;\n\n\tseq_printf(seq, \"%10u  %15llu  %5d  %5d\",\n\t\t   entry->seqno, entry->timestamp,\n\t\t   entry->access, entry->execute);\n\tfor (i = 0; i < MBOX_LEN / 8; i++) {\n\t\tu64 flit = entry->cmd[i];\n\t\tu32 hi = (u32)(flit >> 32);\n\t\tu32 lo = (u32)flit;\n\n\t\tseq_printf(seq, \"  %08x %08x\", hi, lo);\n\t}\n\tseq_puts(seq, \"\\n\");\n\treturn 0;\n}\n\nstatic inline void *mboxlog_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct adapter *adapter = seq->private;\n\tstruct mbox_cmd_log *log = adapter->mbox_log;\n\n\treturn ((pos <= log->size) ? (void *)(uintptr_t)(pos + 1) : NULL);\n}\n\nstatic void *mboxlog_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn *pos ? mboxlog_get_idx(seq, *pos) : SEQ_START_TOKEN;\n}\n\nstatic void *mboxlog_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn mboxlog_get_idx(seq, *pos);\n}\n\nstatic void mboxlog_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic const struct seq_operations mboxlog_seq_ops = {\n\t.start = mboxlog_start,\n\t.next  = mboxlog_next,\n\t.stop  = mboxlog_stop,\n\t.show  = mboxlog_show\n};\n\nstatic int mboxlog_open(struct inode *inode, struct file *file)\n{\n\tint res = seq_open(file, &mboxlog_seq_ops);\n\n\tif (!res) {\n\t\tstruct seq_file *seq = file->private_data;\n\n\t\tseq->private = inode->i_private;\n\t}\n\treturn res;\n}\n\nstatic const struct file_operations mboxlog_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = mboxlog_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release,\n};\n\nstatic int mbox_show(struct seq_file *seq, void *v)\n{\n\tstatic const char * const owner[] = { \"none\", \"FW\", \"driver\",\n\t\t\t\t\t      \"unknown\", \"<unread>\" };\n\n\tint i;\n\tunsigned int mbox = (uintptr_t)seq->private & 7;\n\tstruct adapter *adap = seq->private - mbox;\n\tvoid __iomem *addr = adap->regs + PF_REG(mbox, CIM_PF_MAILBOX_DATA_A);\n\n\t \n\tif (is_t4(adap->params.chip)) {\n\t\ti = 4;  \n\t} else {\n\t\tunsigned int ctrl_reg = CIM_PF_MAILBOX_CTRL_SHADOW_COPY_A;\n\t\tvoid __iomem *ctrl = adap->regs + PF_REG(mbox, ctrl_reg);\n\n\t\ti = MBOWNER_G(readl(ctrl));\n\t}\n\n\tseq_printf(seq, \"mailbox owned by %s\\n\\n\", owner[i]);\n\n\tfor (i = 0; i < MBOX_LEN; i += 8)\n\t\tseq_printf(seq, \"%016llx\\n\",\n\t\t\t   (unsigned long long)readq(addr + i));\n\treturn 0;\n}\n\nstatic int mbox_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, mbox_show, inode->i_private);\n}\n\nstatic ssize_t mbox_write(struct file *file, const char __user *buf,\n\t\t\t  size_t count, loff_t *pos)\n{\n\tint i;\n\tchar c = '\\n', s[256];\n\tunsigned long long data[8];\n\tconst struct inode *ino;\n\tunsigned int mbox;\n\tstruct adapter *adap;\n\tvoid __iomem *addr;\n\tvoid __iomem *ctrl;\n\n\tif (count > sizeof(s) - 1 || !count)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buf, count))\n\t\treturn -EFAULT;\n\ts[count] = '\\0';\n\n\tif (sscanf(s, \"%llx %llx %llx %llx %llx %llx %llx %llx%c\", &data[0],\n\t\t   &data[1], &data[2], &data[3], &data[4], &data[5], &data[6],\n\t\t   &data[7], &c) < 8 || c != '\\n')\n\t\treturn -EINVAL;\n\n\tino = file_inode(file);\n\tmbox = (uintptr_t)ino->i_private & 7;\n\tadap = ino->i_private - mbox;\n\taddr = adap->regs + PF_REG(mbox, CIM_PF_MAILBOX_DATA_A);\n\tctrl = addr + MBOX_LEN;\n\n\tif (MBOWNER_G(readl(ctrl)) != X_MBOWNER_PL)\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < 8; i++)\n\t\twriteq(data[i], addr + 8 * i);\n\n\twritel(MBMSGVALID_F | MBOWNER_V(X_MBOWNER_FW), ctrl);\n\treturn count;\n}\n\nstatic const struct file_operations mbox_debugfs_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = mbox_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = single_release,\n\t.write   = mbox_write\n};\n\nstatic int mps_trc_show(struct seq_file *seq, void *v)\n{\n\tint enabled, i;\n\tstruct trace_params tp;\n\tunsigned int trcidx = (uintptr_t)seq->private & 3;\n\tstruct adapter *adap = seq->private - trcidx;\n\n\tt4_get_trace_filter(adap, &tp, trcidx, &enabled);\n\tif (!enabled) {\n\t\tseq_puts(seq, \"tracer is disabled\\n\");\n\t\treturn 0;\n\t}\n\n\tif (tp.skip_ofst * 8 >= TRACE_LEN) {\n\t\tdev_err(adap->pdev_dev, \"illegal trace pattern skip offset\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tp.port < 8) {\n\t\ti = adap->chan_map[tp.port & 3];\n\t\tif (i >= MAX_NPORTS) {\n\t\t\tdev_err(adap->pdev_dev, \"tracer %u is assigned \"\n\t\t\t\t\"to non-existing port\\n\", trcidx);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tseq_printf(seq, \"tracer is capturing %s %s, \",\n\t\t\t   adap->port[i]->name, tp.port < 4 ? \"Rx\" : \"Tx\");\n\t} else\n\t\tseq_printf(seq, \"tracer is capturing loopback %d, \",\n\t\t\t   tp.port - 8);\n\tseq_printf(seq, \"snap length: %u, min length: %u\\n\", tp.snap_len,\n\t\t   tp.min_len);\n\tseq_printf(seq, \"packets captured %smatch filter\\n\",\n\t\t   tp.invert ? \"do not \" : \"\");\n\n\tif (tp.skip_ofst) {\n\t\tseq_puts(seq, \"filter pattern: \");\n\t\tfor (i = 0; i < tp.skip_ofst * 2; i += 2)\n\t\t\tseq_printf(seq, \"%08x%08x\", tp.data[i], tp.data[i + 1]);\n\t\tseq_putc(seq, '/');\n\t\tfor (i = 0; i < tp.skip_ofst * 2; i += 2)\n\t\t\tseq_printf(seq, \"%08x%08x\", tp.mask[i], tp.mask[i + 1]);\n\t\tseq_puts(seq, \"@0\\n\");\n\t}\n\n\tseq_puts(seq, \"filter pattern: \");\n\tfor (i = tp.skip_ofst * 2; i < TRACE_LEN / 4; i += 2)\n\t\tseq_printf(seq, \"%08x%08x\", tp.data[i], tp.data[i + 1]);\n\tseq_putc(seq, '/');\n\tfor (i = tp.skip_ofst * 2; i < TRACE_LEN / 4; i += 2)\n\t\tseq_printf(seq, \"%08x%08x\", tp.mask[i], tp.mask[i + 1]);\n\tseq_printf(seq, \"@%u\\n\", (tp.skip_ofst + tp.skip_len) * 8);\n\treturn 0;\n}\n\nstatic int mps_trc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, mps_trc_show, inode->i_private);\n}\n\nstatic unsigned int xdigit2int(unsigned char c)\n{\n\treturn isdigit(c) ? c - '0' : tolower(c) - 'a' + 10;\n}\n\n#define TRC_PORT_NONE 0xff\n#define TRC_RSS_ENABLE 0x33\n#define TRC_RSS_DISABLE 0x13\n\n \nstatic ssize_t mps_trc_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *pos)\n{\n\tint i, enable, ret;\n\tu32 *data, *mask;\n\tstruct trace_params tp;\n\tconst struct inode *ino;\n\tunsigned int trcidx;\n\tchar *s, *p, *word, *end;\n\tstruct adapter *adap;\n\tu32 j;\n\n\tino = file_inode(file);\n\ttrcidx = (uintptr_t)ino->i_private & 3;\n\tadap = ino->i_private - trcidx;\n\n\t \n\tif (count > 1024)\n\t\treturn -EFBIG;\n\tp = s = kzalloc(count + 1, GFP_USER);\n\tif (!s)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(s, buf, count)) {\n\t\tcount = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (s[count - 1] == '\\n')\n\t\ts[count - 1] = '\\0';\n\n\tenable = strcmp(\"disable\", s) != 0;\n\tif (!enable)\n\t\tgoto apply;\n\n\t \n\tif (adap->trace_rss)\n\t\tt4_write_reg(adap, MPS_TRC_CFG_A, TRC_RSS_ENABLE);\n\telse\n\t\tt4_write_reg(adap, MPS_TRC_CFG_A, TRC_RSS_DISABLE);\n\n\tmemset(&tp, 0, sizeof(tp));\n\ttp.port = TRC_PORT_NONE;\n\ti = 0;\t \n\n\twhile (p) {\n\t\twhile (isspace(*p))\n\t\t\tp++;\n\t\tword = strsep(&p, \" \");\n\t\tif (!*word)\n\t\t\tbreak;\n\n\t\tif (!strncmp(word, \"qid=\", 4)) {\n\t\t\tend = (char *)word + 4;\n\t\t\tret = kstrtouint(end, 10, &j);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (!adap->trace_rss) {\n\t\t\t\tt4_write_reg(adap, MPS_T5_TRC_RSS_CONTROL_A, j);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (trcidx) {\n\t\t\tcase 0:\n\t\t\t\tt4_write_reg(adap, MPS_TRC_RSS_CONTROL_A, j);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tt4_write_reg(adap,\n\t\t\t\t\t     MPS_TRC_FILTER1_RSS_CONTROL_A, j);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tt4_write_reg(adap,\n\t\t\t\t\t     MPS_TRC_FILTER2_RSS_CONTROL_A, j);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tt4_write_reg(adap,\n\t\t\t\t\t     MPS_TRC_FILTER3_RSS_CONTROL_A, j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp(word, \"snaplen=\", 8)) {\n\t\t\tend = (char *)word + 8;\n\t\t\tret = kstrtouint(end, 10, &j);\n\t\t\tif (ret || j > 9600) {\ninval:\t\t\t\tcount = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttp.snap_len = j;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp(word, \"minlen=\", 7)) {\n\t\t\tend = (char *)word + 7;\n\t\t\tret = kstrtouint(end, 10, &j);\n\t\t\tif (ret || j > TFMINPKTSIZE_M)\n\t\t\t\tgoto inval;\n\t\t\ttp.min_len = j;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strcmp(word, \"not\")) {\n\t\t\ttp.invert = !tp.invert;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp(word, \"loopback\", 8) && tp.port == TRC_PORT_NONE) {\n\t\t\tif (word[8] < '0' || word[8] > '3' || word[9])\n\t\t\t\tgoto inval;\n\t\t\ttp.port = word[8] - '0' + 8;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp(word, \"tx\", 2) && tp.port == TRC_PORT_NONE) {\n\t\t\tif (word[2] < '0' || word[2] > '3' || word[3])\n\t\t\t\tgoto inval;\n\t\t\ttp.port = word[2] - '0' + 4;\n\t\t\tif (adap->chan_map[tp.port & 3] >= MAX_NPORTS)\n\t\t\t\tgoto inval;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp(word, \"rx\", 2) && tp.port == TRC_PORT_NONE) {\n\t\t\tif (word[2] < '0' || word[2] > '3' || word[3])\n\t\t\t\tgoto inval;\n\t\t\ttp.port = word[2] - '0';\n\t\t\tif (adap->chan_map[tp.port] >= MAX_NPORTS)\n\t\t\t\tgoto inval;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!isxdigit(*word))\n\t\t\tgoto inval;\n\n\t\t \n\t\tif (i) {                             \n\t\t\tif (tp.skip_len)             \n\t\t\t\tgoto inval;\n\t\t\ttp.skip_ofst = i / 16;\n\t\t}\n\n\t\tdata = &tp.data[i / 8];\n\t\tmask = &tp.mask[i / 8];\n\t\tj = i;\n\n\t\twhile (isxdigit(*word)) {\n\t\t\tif (i >= TRACE_LEN * 2) {\n\t\t\t\tcount = -EFBIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*data = (*data << 4) + xdigit2int(*word++);\n\t\t\tif (++i % 8 == 0)\n\t\t\t\tdata++;\n\t\t}\n\t\tif (*word == '/') {\n\t\t\tword++;\n\t\t\twhile (isxdigit(*word)) {\n\t\t\t\tif (j >= i)          \n\t\t\t\t\tgoto inval;\n\t\t\t\t*mask = (*mask << 4) + xdigit2int(*word++);\n\t\t\t\tif (++j % 8 == 0)\n\t\t\t\t\tmask++;\n\t\t\t}\n\t\t\tif (i != j)                  \n\t\t\t\tgoto inval;\n\t\t} else {                             \n\t\t\tfor ( ; i - j >= 8; j += 8)\n\t\t\t\t*mask++ = 0xffffffff;\n\t\t\tif (i % 8)\n\t\t\t\t*mask = (1 << (i % 8) * 4) - 1;\n\t\t}\n\t\tif (*word == '@') {\n\t\t\tend = (char *)word + 1;\n\t\t\tret = kstrtouint(end, 10, &j);\n\t\t\tif (*end && *end != '\\n')\n\t\t\t\tgoto inval;\n\t\t\tif (j & 7)           \n\t\t\t\tgoto inval;\n\t\t\tj /= 8;\n\t\t\tif (j < tp.skip_ofst)      \n\t\t\t\tgoto inval;\n\t\t\tif (j - tp.skip_ofst > 31)             \n\t\t\t\tgoto inval;\n\t\t\ttp.skip_len = j - tp.skip_ofst;\n\t\t}\n\t\tif (i % 8) {\n\t\t\t*data <<= (8 - i % 8) * 4;\n\t\t\t*mask <<= (8 - i % 8) * 4;\n\t\t\ti = (i + 15) & ~15;          \n\t\t}\n\t}\n\n\tif (tp.port == TRC_PORT_NONE)\n\t\tgoto inval;\n\napply:\n\ti = t4_set_trace_filter(adap, &tp, trcidx, enable);\n\tif (i)\n\t\tcount = i;\nout:\n\tkfree(s);\n\treturn count;\n}\n\nstatic const struct file_operations mps_trc_debugfs_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = mps_trc_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = single_release,\n\t.write   = mps_trc_write\n};\n\nstatic ssize_t flash_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tloff_t pos = *ppos;\n\tloff_t avail = file_inode(file)->i_size;\n\tstruct adapter *adap = file->private_data;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= avail)\n\t\treturn 0;\n\tif (count > avail - pos)\n\t\tcount = avail - pos;\n\n\twhile (count) {\n\t\tsize_t len;\n\t\tint ret, ofst;\n\t\tu8 data[256];\n\n\t\tofst = pos & 3;\n\t\tlen = min(count + ofst, sizeof(data));\n\t\tret = t4_read_flash(adap, pos - ofst, (len + 3) / 4,\n\t\t\t\t    (u32 *)data, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlen -= ofst;\n\t\tif (copy_to_user(buf, data + ofst, len))\n\t\t\treturn -EFAULT;\n\n\t\tbuf += len;\n\t\tpos += len;\n\t\tcount -= len;\n\t}\n\tcount = pos - *ppos;\n\t*ppos = pos;\n\treturn count;\n}\n\nstatic const struct file_operations flash_debugfs_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = mem_open,\n\t.read    = flash_read,\n\t.llseek  = default_llseek,\n};\n\nstatic inline void tcamxy2valmask(u64 x, u64 y, u8 *addr, u64 *mask)\n{\n\t*mask = x | y;\n\ty = (__force u64)cpu_to_be64(y);\n\tmemcpy(addr, (char *)&y + 2, ETH_ALEN);\n}\n\nstatic int mps_tcam_show(struct seq_file *seq, void *v)\n{\n\tstruct adapter *adap = seq->private;\n\tunsigned int chip_ver = CHELSIO_CHIP_VERSION(adap->params.chip);\n\tif (v == SEQ_START_TOKEN) {\n\t\tif (chip_ver > CHELSIO_T5) {\n\t\t\tseq_puts(seq, \"Idx  Ethernet address     Mask     \"\n\t\t\t\t \"  VNI   Mask   IVLAN Vld \"\n\t\t\t\t \"DIP_Hit   Lookup  Port \"\n\t\t\t\t \"Vld Ports PF  VF                           \"\n\t\t\t\t \"Replication                                \"\n\t\t\t\t \"    P0 P1 P2 P3  ML\\n\");\n\t\t} else {\n\t\t\tif (adap->params.arch.mps_rplc_size > 128)\n\t\t\t\tseq_puts(seq, \"Idx  Ethernet address     Mask     \"\n\t\t\t\t\t \"Vld Ports PF  VF                           \"\n\t\t\t\t\t \"Replication                                \"\n\t\t\t\t\t \"    P0 P1 P2 P3  ML\\n\");\n\t\t\telse\n\t\t\t\tseq_puts(seq, \"Idx  Ethernet address     Mask     \"\n\t\t\t\t\t \"Vld Ports PF  VF              Replication\"\n\t\t\t\t\t \"\t         P0 P1 P2 P3  ML\\n\");\n\t\t}\n\t} else {\n\t\tu64 mask;\n\t\tu8 addr[ETH_ALEN];\n\t\tbool replicate, dip_hit = false, vlan_vld = false;\n\t\tunsigned int idx = (uintptr_t)v - 2;\n\t\tu64 tcamy, tcamx, val;\n\t\tu32 cls_lo, cls_hi, ctl, data2, vnix = 0, vniy = 0;\n\t\tu32 rplc[8] = {0};\n\t\tu8 lookup_type = 0, port_num = 0;\n\t\tu16 ivlan = 0;\n\n\t\tif (chip_ver > CHELSIO_T5) {\n\t\t\t \n\n\t\t\t \n\t\t\tctl = CTLCMDTYPE_V(0) | CTLXYBITSEL_V(0);\n\t\t\tif (idx < 256)\n\t\t\t\tctl |= CTLTCAMINDEX_V(idx) | CTLTCAMSEL_V(0);\n\t\t\telse\n\t\t\t\tctl |= CTLTCAMINDEX_V(idx - 256) |\n\t\t\t\t       CTLTCAMSEL_V(1);\n\t\t\tt4_write_reg(adap, MPS_CLS_TCAM_DATA2_CTL_A, ctl);\n\t\t\tval = t4_read_reg(adap, MPS_CLS_TCAM_DATA1_A);\n\t\t\ttcamy = DMACH_G(val) << 32;\n\t\t\ttcamy |= t4_read_reg(adap, MPS_CLS_TCAM_DATA0_A);\n\t\t\tdata2 = t4_read_reg(adap, MPS_CLS_TCAM_DATA2_CTL_A);\n\t\t\tlookup_type = DATALKPTYPE_G(data2);\n\t\t\t \n\t\t\tif (lookup_type && (lookup_type != DATALKPTYPE_M)) {\n\t\t\t\t \n\t\t\t\tvniy = (data2 & DATAVIDH2_F) |\n\t\t\t\t       (DATAVIDH1_G(data2) << 16) | VIDL_G(val);\n\t\t\t\tdip_hit = data2 & DATADIPHIT_F;\n\t\t\t} else {\n\t\t\t\tvlan_vld = data2 & DATAVIDH2_F;\n\t\t\t\tivlan = VIDL_G(val);\n\t\t\t}\n\t\t\tport_num = DATAPORTNUM_G(data2);\n\n\t\t\t \n\t\t\tvnix = 0;\n\t\t\tctl |= CTLXYBITSEL_V(1);\n\t\t\tt4_write_reg(adap, MPS_CLS_TCAM_DATA2_CTL_A, ctl);\n\t\t\tval = t4_read_reg(adap, MPS_CLS_TCAM_DATA1_A);\n\t\t\ttcamx = DMACH_G(val) << 32;\n\t\t\ttcamx |= t4_read_reg(adap, MPS_CLS_TCAM_DATA0_A);\n\t\t\tdata2 = t4_read_reg(adap, MPS_CLS_TCAM_DATA2_CTL_A);\n\t\t\tif (lookup_type && (lookup_type != DATALKPTYPE_M)) {\n\t\t\t\t \n\t\t\t\tvnix = (data2 & DATAVIDH2_F) |\n\t\t\t\t       (DATAVIDH1_G(data2) << 16) | VIDL_G(val);\n\t\t\t}\n\t\t} else {\n\t\t\ttcamy = t4_read_reg64(adap, MPS_CLS_TCAM_Y_L(idx));\n\t\t\ttcamx = t4_read_reg64(adap, MPS_CLS_TCAM_X_L(idx));\n\t\t}\n\n\t\tcls_lo = t4_read_reg(adap, MPS_CLS_SRAM_L(idx));\n\t\tcls_hi = t4_read_reg(adap, MPS_CLS_SRAM_H(idx));\n\n\t\tif (tcamx & tcamy) {\n\t\t\tseq_printf(seq, \"%3u         -\\n\", idx);\n\t\t\tgoto out;\n\t\t}\n\n\t\trplc[0] = rplc[1] = rplc[2] = rplc[3] = 0;\n\t\tif (chip_ver > CHELSIO_T5)\n\t\t\treplicate = (cls_lo & T6_REPLICATE_F);\n\t\telse\n\t\t\treplicate = (cls_lo & REPLICATE_F);\n\n\t\tif (replicate) {\n\t\t\tstruct fw_ldst_cmd ldst_cmd;\n\t\t\tint ret;\n\t\t\tstruct fw_ldst_mps_rplc mps_rplc;\n\t\t\tu32 ldst_addrspc;\n\n\t\t\tmemset(&ldst_cmd, 0, sizeof(ldst_cmd));\n\t\t\tldst_addrspc =\n\t\t\t\tFW_LDST_CMD_ADDRSPACE_V(FW_LDST_ADDRSPC_MPS);\n\t\t\tldst_cmd.op_to_addrspace =\n\t\t\t\thtonl(FW_CMD_OP_V(FW_LDST_CMD) |\n\t\t\t\t      FW_CMD_REQUEST_F |\n\t\t\t\t      FW_CMD_READ_F |\n\t\t\t\t      ldst_addrspc);\n\t\t\tldst_cmd.cycles_to_len16 = htonl(FW_LEN16(ldst_cmd));\n\t\t\tldst_cmd.u.mps.rplc.fid_idx =\n\t\t\t\thtons(FW_LDST_CMD_FID_V(FW_LDST_MPS_RPLC) |\n\t\t\t\t      FW_LDST_CMD_IDX_V(idx));\n\t\t\tret = t4_wr_mbox(adap, adap->mbox, &ldst_cmd,\n\t\t\t\t\t sizeof(ldst_cmd), &ldst_cmd);\n\t\t\tif (ret)\n\t\t\t\tdev_warn(adap->pdev_dev, \"Can't read MPS \"\n\t\t\t\t\t \"replication map for idx %d: %d\\n\",\n\t\t\t\t\t idx, -ret);\n\t\t\telse {\n\t\t\t\tmps_rplc = ldst_cmd.u.mps.rplc;\n\t\t\t\trplc[0] = ntohl(mps_rplc.rplc31_0);\n\t\t\t\trplc[1] = ntohl(mps_rplc.rplc63_32);\n\t\t\t\trplc[2] = ntohl(mps_rplc.rplc95_64);\n\t\t\t\trplc[3] = ntohl(mps_rplc.rplc127_96);\n\t\t\t\tif (adap->params.arch.mps_rplc_size > 128) {\n\t\t\t\t\trplc[4] = ntohl(mps_rplc.rplc159_128);\n\t\t\t\t\trplc[5] = ntohl(mps_rplc.rplc191_160);\n\t\t\t\t\trplc[6] = ntohl(mps_rplc.rplc223_192);\n\t\t\t\t\trplc[7] = ntohl(mps_rplc.rplc255_224);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttcamxy2valmask(tcamx, tcamy, addr, &mask);\n\t\tif (chip_ver > CHELSIO_T5) {\n\t\t\t \n\t\t\tif (lookup_type && (lookup_type != DATALKPTYPE_M)) {\n\t\t\t\tseq_printf(seq,\n\t\t\t\t\t   \"%3u %pM %012llx %06x %06x    -    -   %3c      'I'  %4x   %3c   %#x%4u%4d\",\n\t\t\t\t\t   idx, addr,\n\t\t\t\t\t   (unsigned long long)mask,\n\t\t\t\t\t   vniy, (vnix | vniy),\n\t\t\t\t\t   dip_hit ? 'Y' : 'N',\n\t\t\t\t\t   port_num,\n\t\t\t\t\t   (cls_lo & T6_SRAM_VLD_F) ? 'Y' : 'N',\n\t\t\t\t\t   PORTMAP_G(cls_hi),\n\t\t\t\t\t   T6_PF_G(cls_lo),\n\t\t\t\t\t   (cls_lo & T6_VF_VALID_F) ?\n\t\t\t\t\t   T6_VF_G(cls_lo) : -1);\n\t\t\t} else {\n\t\t\t\tseq_printf(seq,\n\t\t\t\t\t   \"%3u %pM %012llx    -       -   \",\n\t\t\t\t\t   idx, addr,\n\t\t\t\t\t   (unsigned long long)mask);\n\n\t\t\t\tif (vlan_vld)\n\t\t\t\t\tseq_printf(seq, \"%4u   Y     \", ivlan);\n\t\t\t\telse\n\t\t\t\t\tseq_puts(seq, \"  -    N     \");\n\n\t\t\t\tseq_printf(seq,\n\t\t\t\t\t   \"-      %3c  %4x   %3c   %#x%4u%4d\",\n\t\t\t\t\t   lookup_type ? 'I' : 'O', port_num,\n\t\t\t\t\t   (cls_lo & T6_SRAM_VLD_F) ? 'Y' : 'N',\n\t\t\t\t\t   PORTMAP_G(cls_hi),\n\t\t\t\t\t   T6_PF_G(cls_lo),\n\t\t\t\t\t   (cls_lo & T6_VF_VALID_F) ?\n\t\t\t\t\t   T6_VF_G(cls_lo) : -1);\n\t\t\t}\n\t\t} else\n\t\t\tseq_printf(seq, \"%3u %pM %012llx%3c   %#x%4u%4d\",\n\t\t\t\t   idx, addr, (unsigned long long)mask,\n\t\t\t\t   (cls_lo & SRAM_VLD_F) ? 'Y' : 'N',\n\t\t\t\t   PORTMAP_G(cls_hi),\n\t\t\t\t   PF_G(cls_lo),\n\t\t\t\t   (cls_lo & VF_VALID_F) ? VF_G(cls_lo) : -1);\n\n\t\tif (replicate) {\n\t\t\tif (adap->params.arch.mps_rplc_size > 128)\n\t\t\t\tseq_printf(seq, \" %08x %08x %08x %08x \"\n\t\t\t\t\t   \"%08x %08x %08x %08x\",\n\t\t\t\t\t   rplc[7], rplc[6], rplc[5], rplc[4],\n\t\t\t\t\t   rplc[3], rplc[2], rplc[1], rplc[0]);\n\t\t\telse\n\t\t\t\tseq_printf(seq, \" %08x %08x %08x %08x\",\n\t\t\t\t\t   rplc[3], rplc[2], rplc[1], rplc[0]);\n\t\t} else {\n\t\t\tif (adap->params.arch.mps_rplc_size > 128)\n\t\t\t\tseq_printf(seq, \"%72c\", ' ');\n\t\t\telse\n\t\t\t\tseq_printf(seq, \"%36c\", ' ');\n\t\t}\n\n\t\tif (chip_ver > CHELSIO_T5)\n\t\t\tseq_printf(seq, \"%4u%3u%3u%3u %#x\\n\",\n\t\t\t\t   T6_SRAM_PRIO0_G(cls_lo),\n\t\t\t\t   T6_SRAM_PRIO1_G(cls_lo),\n\t\t\t\t   T6_SRAM_PRIO2_G(cls_lo),\n\t\t\t\t   T6_SRAM_PRIO3_G(cls_lo),\n\t\t\t\t   (cls_lo >> T6_MULTILISTEN0_S) & 0xf);\n\t\telse\n\t\t\tseq_printf(seq, \"%4u%3u%3u%3u %#x\\n\",\n\t\t\t\t   SRAM_PRIO0_G(cls_lo), SRAM_PRIO1_G(cls_lo),\n\t\t\t\t   SRAM_PRIO2_G(cls_lo), SRAM_PRIO3_G(cls_lo),\n\t\t\t\t   (cls_lo >> MULTILISTEN0_S) & 0xf);\n\t}\nout:\treturn 0;\n}\n\nstatic inline void *mps_tcam_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct adapter *adap = seq->private;\n\tint max_mac_addr = is_t4(adap->params.chip) ?\n\t\t\t\tNUM_MPS_CLS_SRAM_L_INSTANCES :\n\t\t\t\tNUM_MPS_T5_CLS_SRAM_L_INSTANCES;\n\treturn ((pos <= max_mac_addr) ? (void *)(uintptr_t)(pos + 1) : NULL);\n}\n\nstatic void *mps_tcam_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn *pos ? mps_tcam_get_idx(seq, *pos) : SEQ_START_TOKEN;\n}\n\nstatic void *mps_tcam_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn mps_tcam_get_idx(seq, *pos);\n}\n\nstatic void mps_tcam_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic const struct seq_operations mps_tcam_seq_ops = {\n\t.start = mps_tcam_start,\n\t.next  = mps_tcam_next,\n\t.stop  = mps_tcam_stop,\n\t.show  = mps_tcam_show\n};\n\nstatic int mps_tcam_open(struct inode *inode, struct file *file)\n{\n\tint res = seq_open(file, &mps_tcam_seq_ops);\n\n\tif (!res) {\n\t\tstruct seq_file *seq = file->private_data;\n\n\t\tseq->private = inode->i_private;\n\t}\n\treturn res;\n}\n\nstatic const struct file_operations mps_tcam_debugfs_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = mps_tcam_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release,\n};\n\n \nstatic int sensors_show(struct seq_file *seq, void *v)\n{\n\tstruct adapter *adap = seq->private;\n\tu32 param[7], val[7];\n\tint ret;\n\n\t \n\tparam[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t    FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_DIAG) |\n\t\t    FW_PARAMS_PARAM_Y_V(FW_PARAM_DEV_DIAG_TMP));\n\tparam[1] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t    FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_DIAG) |\n\t\t    FW_PARAMS_PARAM_Y_V(FW_PARAM_DEV_DIAG_VDD));\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 2,\n\t\t\t      param, val);\n\n\tif (ret < 0 || val[0] == 0)\n\t\tseq_puts(seq, \"Temperature: <unknown>\\n\");\n\telse\n\t\tseq_printf(seq, \"Temperature: %dC\\n\", val[0]);\n\n\tif (ret < 0 || val[1] == 0)\n\t\tseq_puts(seq, \"Core VDD:    <unknown>\\n\");\n\telse\n\t\tseq_printf(seq, \"Core VDD:    %dmV\\n\", val[1]);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(sensors);\n\n#if IS_ENABLED(CONFIG_IPV6)\nDEFINE_SHOW_ATTRIBUTE(clip_tbl);\n#endif\n\n \n\nstatic int rss_show(struct seq_file *seq, void *v, int idx)\n{\n\tu16 *entry = v;\n\n\tseq_printf(seq, \"%4d:  %4u  %4u  %4u  %4u  %4u  %4u  %4u  %4u\\n\",\n\t\t   idx * 8, entry[0], entry[1], entry[2], entry[3], entry[4],\n\t\t   entry[5], entry[6], entry[7]);\n\treturn 0;\n}\n\nstatic int rss_open(struct inode *inode, struct file *file)\n{\n\tstruct adapter *adap = inode->i_private;\n\tint ret, nentries;\n\tstruct seq_tab *p;\n\n\tnentries = t4_chip_rss_size(adap);\n\tp = seq_open_tab(file, nentries / 8, 8 * sizeof(u16), 0, rss_show);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = t4_read_rss(adap, (u16 *)p->data);\n\tif (ret)\n\t\tseq_release_private(inode, file);\n\n\treturn ret;\n}\n\nstatic const struct file_operations rss_debugfs_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = rss_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private\n};\n\n \n\n \nstatic const char *yesno(int x)\n{\n\tstatic const char *yes = \"yes\";\n\tstatic const char *no = \"no\";\n\n\treturn x ? yes : no;\n}\n\nstatic int rss_config_show(struct seq_file *seq, void *v)\n{\n\tstruct adapter *adapter = seq->private;\n\tstatic const char * const keymode[] = {\n\t\t\"global\",\n\t\t\"global and per-VF scramble\",\n\t\t\"per-PF and per-VF scramble\",\n\t\t\"per-VF and per-VF scramble\",\n\t};\n\tu32 rssconf;\n\n\trssconf = t4_read_reg(adapter, TP_RSS_CONFIG_A);\n\tseq_printf(seq, \"TP_RSS_CONFIG: %#x\\n\", rssconf);\n\tseq_printf(seq, \"  Tnl4TupEnIpv6: %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tTNL4TUPENIPV6_F));\n\tseq_printf(seq, \"  Tnl2TupEnIpv6: %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tTNL2TUPENIPV6_F));\n\tseq_printf(seq, \"  Tnl4TupEnIpv4: %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tTNL4TUPENIPV4_F));\n\tseq_printf(seq, \"  Tnl2TupEnIpv4: %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tTNL2TUPENIPV4_F));\n\tseq_printf(seq, \"  TnlTcpSel:     %3s\\n\", yesno(rssconf & TNLTCPSEL_F));\n\tseq_printf(seq, \"  TnlIp6Sel:     %3s\\n\", yesno(rssconf & TNLIP6SEL_F));\n\tseq_printf(seq, \"  TnlVrtSel:     %3s\\n\", yesno(rssconf & TNLVRTSEL_F));\n\tseq_printf(seq, \"  TnlMapEn:      %3s\\n\", yesno(rssconf & TNLMAPEN_F));\n\tseq_printf(seq, \"  OfdHashSave:   %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tOFDHASHSAVE_F));\n\tseq_printf(seq, \"  OfdVrtSel:     %3s\\n\", yesno(rssconf & OFDVRTSEL_F));\n\tseq_printf(seq, \"  OfdMapEn:      %3s\\n\", yesno(rssconf & OFDMAPEN_F));\n\tseq_printf(seq, \"  OfdLkpEn:      %3s\\n\", yesno(rssconf & OFDLKPEN_F));\n\tseq_printf(seq, \"  Syn4TupEnIpv6: %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tSYN4TUPENIPV6_F));\n\tseq_printf(seq, \"  Syn2TupEnIpv6: %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tSYN2TUPENIPV6_F));\n\tseq_printf(seq, \"  Syn4TupEnIpv4: %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tSYN4TUPENIPV4_F));\n\tseq_printf(seq, \"  Syn2TupEnIpv4: %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tSYN2TUPENIPV4_F));\n\tseq_printf(seq, \"  Syn4TupEnIpv6: %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tSYN4TUPENIPV6_F));\n\tseq_printf(seq, \"  SynIp6Sel:     %3s\\n\", yesno(rssconf & SYNIP6SEL_F));\n\tseq_printf(seq, \"  SynVrt6Sel:    %3s\\n\", yesno(rssconf & SYNVRTSEL_F));\n\tseq_printf(seq, \"  SynMapEn:      %3s\\n\", yesno(rssconf & SYNMAPEN_F));\n\tseq_printf(seq, \"  SynLkpEn:      %3s\\n\", yesno(rssconf & SYNLKPEN_F));\n\tseq_printf(seq, \"  ChnEn:         %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tCHANNELENABLE_F));\n\tseq_printf(seq, \"  PrtEn:         %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tPORTENABLE_F));\n\tseq_printf(seq, \"  TnlAllLkp:     %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tTNLALLLOOKUP_F));\n\tseq_printf(seq, \"  VrtEn:         %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tVIRTENABLE_F));\n\tseq_printf(seq, \"  CngEn:         %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tCONGESTIONENABLE_F));\n\tseq_printf(seq, \"  HashToeplitz:  %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tHASHTOEPLITZ_F));\n\tseq_printf(seq, \"  Udp4En:        %3s\\n\", yesno(rssconf & UDPENABLE_F));\n\tseq_printf(seq, \"  Disable:       %3s\\n\", yesno(rssconf & DISABLE_F));\n\n\tseq_puts(seq, \"\\n\");\n\n\trssconf = t4_read_reg(adapter, TP_RSS_CONFIG_TNL_A);\n\tseq_printf(seq, \"TP_RSS_CONFIG_TNL: %#x\\n\", rssconf);\n\tseq_printf(seq, \"  MaskSize:      %3d\\n\", MASKSIZE_G(rssconf));\n\tseq_printf(seq, \"  MaskFilter:    %3d\\n\", MASKFILTER_G(rssconf));\n\tif (CHELSIO_CHIP_VERSION(adapter->params.chip) > CHELSIO_T5) {\n\t\tseq_printf(seq, \"  HashAll:     %3s\\n\",\n\t\t\t   yesno(rssconf & HASHALL_F));\n\t\tseq_printf(seq, \"  HashEth:     %3s\\n\",\n\t\t\t   yesno(rssconf & HASHETH_F));\n\t}\n\tseq_printf(seq, \"  UseWireCh:     %3s\\n\", yesno(rssconf & USEWIRECH_F));\n\n\tseq_puts(seq, \"\\n\");\n\n\trssconf = t4_read_reg(adapter, TP_RSS_CONFIG_OFD_A);\n\tseq_printf(seq, \"TP_RSS_CONFIG_OFD: %#x\\n\", rssconf);\n\tseq_printf(seq, \"  MaskSize:      %3d\\n\", MASKSIZE_G(rssconf));\n\tseq_printf(seq, \"  RRCplMapEn:    %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tRRCPLMAPEN_F));\n\tseq_printf(seq, \"  RRCplQueWidth: %3d\\n\", RRCPLQUEWIDTH_G(rssconf));\n\n\tseq_puts(seq, \"\\n\");\n\n\trssconf = t4_read_reg(adapter, TP_RSS_CONFIG_SYN_A);\n\tseq_printf(seq, \"TP_RSS_CONFIG_SYN: %#x\\n\", rssconf);\n\tseq_printf(seq, \"  MaskSize:      %3d\\n\", MASKSIZE_G(rssconf));\n\tseq_printf(seq, \"  UseWireCh:     %3s\\n\", yesno(rssconf & USEWIRECH_F));\n\n\tseq_puts(seq, \"\\n\");\n\n\trssconf = t4_read_reg(adapter, TP_RSS_CONFIG_VRT_A);\n\tseq_printf(seq, \"TP_RSS_CONFIG_VRT: %#x\\n\", rssconf);\n\tif (CHELSIO_CHIP_VERSION(adapter->params.chip) > CHELSIO_T5) {\n\t\tseq_printf(seq, \"  KeyWrAddrX:     %3d\\n\",\n\t\t\t   KEYWRADDRX_G(rssconf));\n\t\tseq_printf(seq, \"  KeyExtend:      %3s\\n\",\n\t\t\t   yesno(rssconf & KEYEXTEND_F));\n\t}\n\tseq_printf(seq, \"  VfRdRg:        %3s\\n\", yesno(rssconf & VFRDRG_F));\n\tseq_printf(seq, \"  VfRdEn:        %3s\\n\", yesno(rssconf & VFRDEN_F));\n\tseq_printf(seq, \"  VfPerrEn:      %3s\\n\", yesno(rssconf & VFPERREN_F));\n\tseq_printf(seq, \"  KeyPerrEn:     %3s\\n\", yesno(rssconf & KEYPERREN_F));\n\tseq_printf(seq, \"  DisVfVlan:     %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tDISABLEVLAN_F));\n\tseq_printf(seq, \"  EnUpSwt:       %3s\\n\", yesno(rssconf & ENABLEUP0_F));\n\tseq_printf(seq, \"  HashDelay:     %3d\\n\", HASHDELAY_G(rssconf));\n\tif (CHELSIO_CHIP_VERSION(adapter->params.chip) <= CHELSIO_T5)\n\t\tseq_printf(seq, \"  VfWrAddr:      %3d\\n\", VFWRADDR_G(rssconf));\n\telse\n\t\tseq_printf(seq, \"  VfWrAddr:      %3d\\n\",\n\t\t\t   T6_VFWRADDR_G(rssconf));\n\tseq_printf(seq, \"  KeyMode:       %s\\n\", keymode[KEYMODE_G(rssconf)]);\n\tseq_printf(seq, \"  VfWrEn:        %3s\\n\", yesno(rssconf & VFWREN_F));\n\tseq_printf(seq, \"  KeyWrEn:       %3s\\n\", yesno(rssconf & KEYWREN_F));\n\tseq_printf(seq, \"  KeyWrAddr:     %3d\\n\", KEYWRADDR_G(rssconf));\n\n\tseq_puts(seq, \"\\n\");\n\n\trssconf = t4_read_reg(adapter, TP_RSS_CONFIG_CNG_A);\n\tseq_printf(seq, \"TP_RSS_CONFIG_CNG: %#x\\n\", rssconf);\n\tseq_printf(seq, \"  ChnCount3:     %3s\\n\", yesno(rssconf & CHNCOUNT3_F));\n\tseq_printf(seq, \"  ChnCount2:     %3s\\n\", yesno(rssconf & CHNCOUNT2_F));\n\tseq_printf(seq, \"  ChnCount1:     %3s\\n\", yesno(rssconf & CHNCOUNT1_F));\n\tseq_printf(seq, \"  ChnCount0:     %3s\\n\", yesno(rssconf & CHNCOUNT0_F));\n\tseq_printf(seq, \"  ChnUndFlow3:   %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tCHNUNDFLOW3_F));\n\tseq_printf(seq, \"  ChnUndFlow2:   %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tCHNUNDFLOW2_F));\n\tseq_printf(seq, \"  ChnUndFlow1:   %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tCHNUNDFLOW1_F));\n\tseq_printf(seq, \"  ChnUndFlow0:   %3s\\n\", yesno(rssconf &\n\t\t\t\t\t\t\tCHNUNDFLOW0_F));\n\tseq_printf(seq, \"  RstChn3:       %3s\\n\", yesno(rssconf & RSTCHN3_F));\n\tseq_printf(seq, \"  RstChn2:       %3s\\n\", yesno(rssconf & RSTCHN2_F));\n\tseq_printf(seq, \"  RstChn1:       %3s\\n\", yesno(rssconf & RSTCHN1_F));\n\tseq_printf(seq, \"  RstChn0:       %3s\\n\", yesno(rssconf & RSTCHN0_F));\n\tseq_printf(seq, \"  UpdVld:        %3s\\n\", yesno(rssconf & UPDVLD_F));\n\tseq_printf(seq, \"  Xoff:          %3s\\n\", yesno(rssconf & XOFF_F));\n\tseq_printf(seq, \"  UpdChn3:       %3s\\n\", yesno(rssconf & UPDCHN3_F));\n\tseq_printf(seq, \"  UpdChn2:       %3s\\n\", yesno(rssconf & UPDCHN2_F));\n\tseq_printf(seq, \"  UpdChn1:       %3s\\n\", yesno(rssconf & UPDCHN1_F));\n\tseq_printf(seq, \"  UpdChn0:       %3s\\n\", yesno(rssconf & UPDCHN0_F));\n\tseq_printf(seq, \"  Queue:         %3d\\n\", QUEUE_G(rssconf));\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(rss_config);\n\n \n\nstatic int rss_key_show(struct seq_file *seq, void *v)\n{\n\tu32 key[10];\n\n\tt4_read_rss_key(seq->private, key, true);\n\tseq_printf(seq, \"%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x\\n\",\n\t\t   key[9], key[8], key[7], key[6], key[5], key[4], key[3],\n\t\t   key[2], key[1], key[0]);\n\treturn 0;\n}\n\nstatic int rss_key_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, rss_key_show, inode->i_private);\n}\n\nstatic ssize_t rss_key_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *pos)\n{\n\tint i, j;\n\tu32 key[10];\n\tchar s[100], *p;\n\tstruct adapter *adap = file_inode(file)->i_private;\n\n\tif (count > sizeof(s) - 1)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buf, count))\n\t\treturn -EFAULT;\n\tfor (i = count; i > 0 && isspace(s[i - 1]); i--)\n\t\t;\n\ts[i] = '\\0';\n\n\tfor (p = s, i = 9; i >= 0; i--) {\n\t\tkey[i] = 0;\n\t\tfor (j = 0; j < 8; j++, p++) {\n\t\t\tif (!isxdigit(*p))\n\t\t\t\treturn -EINVAL;\n\t\t\tkey[i] = (key[i] << 4) | hex2val(*p);\n\t\t}\n\t}\n\n\tt4_write_rss_key(adap, key, -1, true);\n\treturn count;\n}\n\nstatic const struct file_operations rss_key_debugfs_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = rss_key_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = single_release,\n\t.write   = rss_key_write\n};\n\n \n\nstruct rss_pf_conf {\n\tu32 rss_pf_map;\n\tu32 rss_pf_mask;\n\tu32 rss_pf_config;\n};\n\nstatic int rss_pf_config_show(struct seq_file *seq, void *v, int idx)\n{\n\tstruct rss_pf_conf *pfconf;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\t \n\t\tpfconf = seq->private + offsetof(struct seq_tab, data);\n\t\tseq_printf(seq, \"PF Map Index Size = %d\\n\\n\",\n\t\t\t   LKPIDXSIZE_G(pfconf->rss_pf_map));\n\n\t\tseq_puts(seq, \"     RSS              PF   VF    Hash Tuple Enable         Default\\n\");\n\t\tseq_puts(seq, \"     Enable       IPF Mask Mask  IPv6      IPv4      UDP   Queue\\n\");\n\t\tseq_puts(seq, \" PF  Map Chn Prt  Map Size Size  Four Two  Four Two  Four  Ch1  Ch0\\n\");\n\t} else {\n\t\t#define G_PFnLKPIDX(map, n) \\\n\t\t\t(((map) >> PF1LKPIDX_S*(n)) & PF0LKPIDX_M)\n\t\t#define G_PFnMSKSIZE(mask, n) \\\n\t\t\t(((mask) >> PF1MSKSIZE_S*(n)) & PF1MSKSIZE_M)\n\n\t\tpfconf = v;\n\t\tseq_printf(seq, \"%3d  %3s %3s %3s  %3d  %3d  %3d   %3s %3s   %3s %3s   %3s  %3d  %3d\\n\",\n\t\t\t   idx,\n\t\t\t   yesno(pfconf->rss_pf_config & MAPENABLE_F),\n\t\t\t   yesno(pfconf->rss_pf_config & CHNENABLE_F),\n\t\t\t   yesno(pfconf->rss_pf_config & PRTENABLE_F),\n\t\t\t   G_PFnLKPIDX(pfconf->rss_pf_map, idx),\n\t\t\t   G_PFnMSKSIZE(pfconf->rss_pf_mask, idx),\n\t\t\t   IVFWIDTH_G(pfconf->rss_pf_config),\n\t\t\t   yesno(pfconf->rss_pf_config & IP6FOURTUPEN_F),\n\t\t\t   yesno(pfconf->rss_pf_config & IP6TWOTUPEN_F),\n\t\t\t   yesno(pfconf->rss_pf_config & IP4FOURTUPEN_F),\n\t\t\t   yesno(pfconf->rss_pf_config & IP4TWOTUPEN_F),\n\t\t\t   yesno(pfconf->rss_pf_config & UDPFOURTUPEN_F),\n\t\t\t   CH1DEFAULTQUEUE_G(pfconf->rss_pf_config),\n\t\t\t   CH0DEFAULTQUEUE_G(pfconf->rss_pf_config));\n\n\t\t#undef G_PFnLKPIDX\n\t\t#undef G_PFnMSKSIZE\n\t}\n\treturn 0;\n}\n\nstatic int rss_pf_config_open(struct inode *inode, struct file *file)\n{\n\tstruct adapter *adapter = inode->i_private;\n\tstruct seq_tab *p;\n\tu32 rss_pf_map, rss_pf_mask;\n\tstruct rss_pf_conf *pfconf;\n\tint pf;\n\n\tp = seq_open_tab(file, 8, sizeof(*pfconf), 1, rss_pf_config_show);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpfconf = (struct rss_pf_conf *)p->data;\n\trss_pf_map = t4_read_rss_pf_map(adapter, true);\n\trss_pf_mask = t4_read_rss_pf_mask(adapter, true);\n\tfor (pf = 0; pf < 8; pf++) {\n\t\tpfconf[pf].rss_pf_map = rss_pf_map;\n\t\tpfconf[pf].rss_pf_mask = rss_pf_mask;\n\t\tt4_read_rss_pf_config(adapter, pf, &pfconf[pf].rss_pf_config,\n\t\t\t\t      true);\n\t}\n\treturn 0;\n}\n\nstatic const struct file_operations rss_pf_config_debugfs_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = rss_pf_config_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private\n};\n\n \n\nstruct rss_vf_conf {\n\tu32 rss_vf_vfl;\n\tu32 rss_vf_vfh;\n};\n\nstatic int rss_vf_config_show(struct seq_file *seq, void *v, int idx)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"     RSS                     Hash Tuple Enable\\n\");\n\t\tseq_puts(seq, \"     Enable   IVF  Dis  Enb  IPv6      IPv4      UDP    Def  Secret Key\\n\");\n\t\tseq_puts(seq, \" VF  Chn Prt  Map  VLAN  uP  Four Two  Four Two  Four   Que  Idx       Hash\\n\");\n\t} else {\n\t\tstruct rss_vf_conf *vfconf = v;\n\n\t\tseq_printf(seq, \"%3d  %3s %3s  %3d   %3s %3s   %3s %3s   %3s  %3s   %3s  %4d  %3d %#10x\\n\",\n\t\t\t   idx,\n\t\t\t   yesno(vfconf->rss_vf_vfh & VFCHNEN_F),\n\t\t\t   yesno(vfconf->rss_vf_vfh & VFPRTEN_F),\n\t\t\t   VFLKPIDX_G(vfconf->rss_vf_vfh),\n\t\t\t   yesno(vfconf->rss_vf_vfh & VFVLNEX_F),\n\t\t\t   yesno(vfconf->rss_vf_vfh & VFUPEN_F),\n\t\t\t   yesno(vfconf->rss_vf_vfh & VFIP4FOURTUPEN_F),\n\t\t\t   yesno(vfconf->rss_vf_vfh & VFIP6TWOTUPEN_F),\n\t\t\t   yesno(vfconf->rss_vf_vfh & VFIP4FOURTUPEN_F),\n\t\t\t   yesno(vfconf->rss_vf_vfh & VFIP4TWOTUPEN_F),\n\t\t\t   yesno(vfconf->rss_vf_vfh & ENABLEUDPHASH_F),\n\t\t\t   DEFAULTQUEUE_G(vfconf->rss_vf_vfh),\n\t\t\t   KEYINDEX_G(vfconf->rss_vf_vfh),\n\t\t\t   vfconf->rss_vf_vfl);\n\t}\n\treturn 0;\n}\n\nstatic int rss_vf_config_open(struct inode *inode, struct file *file)\n{\n\tstruct adapter *adapter = inode->i_private;\n\tstruct seq_tab *p;\n\tstruct rss_vf_conf *vfconf;\n\tint vf, vfcount = adapter->params.arch.vfcount;\n\n\tp = seq_open_tab(file, vfcount, sizeof(*vfconf), 1, rss_vf_config_show);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tvfconf = (struct rss_vf_conf *)p->data;\n\tfor (vf = 0; vf < vfcount; vf++) {\n\t\tt4_read_rss_vf_config(adapter, vf, &vfconf[vf].rss_vf_vfl,\n\t\t\t\t      &vfconf[vf].rss_vf_vfh, true);\n\t}\n\treturn 0;\n}\n\nstatic const struct file_operations rss_vf_config_debugfs_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = rss_vf_config_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_private\n};\n\n#ifdef CONFIG_CHELSIO_T4_DCB\n\n \nstatic int dcb_info_show(struct seq_file *seq, void *v)\n{\n\tstruct adapter *adap = seq->private;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"Data Center Bridging Information\\n\");\n\t} else {\n\t\tint port = (uintptr_t)v - 2;\n\t\tstruct net_device *dev = adap->port[port];\n\t\tstruct port_info *pi = netdev2pinfo(dev);\n\t\tstruct port_dcb_info *dcb = &pi->dcb;\n\n\t\tseq_puts(seq, \"\\n\");\n\t\tseq_printf(seq, \"Port: %d (DCB negotiated: %s)\\n\",\n\t\t\t   port,\n\t\t\t   cxgb4_dcb_enabled(dev) ? \"yes\" : \"no\");\n\n\t\tif (cxgb4_dcb_enabled(dev))\n\t\t\tseq_printf(seq, \"[ DCBx Version %s ]\\n\",\n\t\t\t\t   dcb_ver_array[dcb->dcb_version]);\n\n\t\tif (dcb->msgs) {\n\t\t\tint i;\n\n\t\t\tseq_puts(seq, \"\\n  Index\\t\\t\\t  :\\t\");\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\tseq_printf(seq, \" %3d\", i);\n\t\t\tseq_puts(seq, \"\\n\\n\");\n\t\t}\n\n\t\tif (dcb->msgs & CXGB4_DCB_FW_PGID) {\n\t\t\tint prio, pgid;\n\n\t\t\tseq_puts(seq, \"  Priority Group IDs\\t  :\\t\");\n\t\t\tfor (prio = 0; prio < 8; prio++) {\n\t\t\t\tpgid = (dcb->pgid >> 4 * (7 - prio)) & 0xf;\n\t\t\t\tseq_printf(seq, \" %3d\", pgid);\n\t\t\t}\n\t\t\tseq_puts(seq, \"\\n\");\n\t\t}\n\n\t\tif (dcb->msgs & CXGB4_DCB_FW_PGRATE) {\n\t\t\tint pg;\n\n\t\t\tseq_puts(seq, \"  Priority Group BW(%)\\t  :\\t\");\n\t\t\tfor (pg = 0; pg < 8; pg++)\n\t\t\t\tseq_printf(seq, \" %3d\", dcb->pgrate[pg]);\n\t\t\tseq_puts(seq, \"\\n\");\n\n\t\t\tif (dcb->dcb_version == FW_PORT_DCB_VER_IEEE) {\n\t\t\t\tseq_puts(seq, \"  TSA Algorithm\\t\\t  :\\t\");\n\t\t\t\tfor (pg = 0; pg < 8; pg++)\n\t\t\t\t\tseq_printf(seq, \" %3d\", dcb->tsa[pg]);\n\t\t\t\tseq_puts(seq, \"\\n\");\n\t\t\t}\n\n\t\t\tseq_printf(seq, \"  Max PG Traffic Classes  [%3d  ]\\n\",\n\t\t\t\t   dcb->pg_num_tcs_supported);\n\n\t\t\tseq_puts(seq, \"\\n\");\n\t\t}\n\n\t\tif (dcb->msgs & CXGB4_DCB_FW_PRIORATE) {\n\t\t\tint prio;\n\n\t\t\tseq_puts(seq, \"  Priority Rate\\t:\\t\");\n\t\t\tfor (prio = 0; prio < 8; prio++)\n\t\t\t\tseq_printf(seq, \" %3d\", dcb->priorate[prio]);\n\t\t\tseq_puts(seq, \"\\n\");\n\t\t}\n\n\t\tif (dcb->msgs & CXGB4_DCB_FW_PFC) {\n\t\t\tint prio;\n\n\t\t\tseq_puts(seq, \"  Priority Flow Control   :\\t\");\n\t\t\tfor (prio = 0; prio < 8; prio++) {\n\t\t\t\tint pfcen = (dcb->pfcen >> 1 * (7 - prio))\n\t\t\t\t\t    & 0x1;\n\t\t\t\tseq_printf(seq, \" %3d\", pfcen);\n\t\t\t}\n\t\t\tseq_puts(seq, \"\\n\");\n\n\t\t\tseq_printf(seq, \"  Max PFC Traffic Classes [%3d  ]\\n\",\n\t\t\t\t   dcb->pfc_num_tcs_supported);\n\n\t\t\tseq_puts(seq, \"\\n\");\n\t\t}\n\n\t\tif (dcb->msgs & CXGB4_DCB_FW_APP_ID) {\n\t\t\tint app, napps;\n\n\t\t\tseq_puts(seq, \"  Application Information:\\n\");\n\t\t\tseq_puts(seq, \"  App    Priority    Selection         Protocol\\n\");\n\t\t\tseq_puts(seq, \"  Index  Map         Field             ID\\n\");\n\t\t\tfor (app = 0, napps = 0;\n\t\t\t     app < CXGB4_MAX_DCBX_APP_SUPPORTED; app++) {\n\t\t\t\tstruct app_priority *ap;\n\t\t\t\tstatic const char * const sel_names[] = {\n\t\t\t\t\t\"Ethertype\",\n\t\t\t\t\t\"Socket TCP\",\n\t\t\t\t\t\"Socket UDP\",\n\t\t\t\t\t\"Socket All\",\n\t\t\t\t};\n\t\t\t\tconst char *sel_name;\n\n\t\t\t\tap = &dcb->app_priority[app];\n\t\t\t\t \n\t\t\t\tif (ap->protocolid == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tnapps++;\n\n\t\t\t\tif (ap->sel_field < ARRAY_SIZE(sel_names))\n\t\t\t\t\tsel_name = sel_names[ap->sel_field];\n\t\t\t\telse\n\t\t\t\t\tsel_name = \"UNKNOWN\";\n\n\t\t\t\tseq_printf(seq, \"  %3d    %#04x        %-10s (%d)    %#06x (%d)\\n\",\n\t\t\t\t\t   app,\n\t\t\t\t\t   ap->user_prio_map,\n\t\t\t\t\t   sel_name, ap->sel_field,\n\t\t\t\t\t   ap->protocolid, ap->protocolid);\n\t\t\t}\n\t\t\tif (napps == 0)\n\t\t\t\tseq_puts(seq, \"    --- None ---\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic inline void *dcb_info_get_idx(struct adapter *adap, loff_t pos)\n{\n\treturn (pos <= adap->params.nports\n\t\t? (void *)((uintptr_t)pos + 1)\n\t\t: NULL);\n}\n\nstatic void *dcb_info_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct adapter *adap = seq->private;\n\n\treturn (*pos\n\t\t? dcb_info_get_idx(adap, *pos)\n\t\t: SEQ_START_TOKEN);\n}\n\nstatic void dcb_info_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic void *dcb_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct adapter *adap = seq->private;\n\n\t(*pos)++;\n\treturn dcb_info_get_idx(adap, *pos);\n}\n\nstatic const struct seq_operations dcb_info_seq_ops = {\n\t.start = dcb_info_start,\n\t.next  = dcb_info_next,\n\t.stop  = dcb_info_stop,\n\t.show  = dcb_info_show\n};\n\nstatic int dcb_info_open(struct inode *inode, struct file *file)\n{\n\tint res = seq_open(file, &dcb_info_seq_ops);\n\n\tif (!res) {\n\t\tstruct seq_file *seq = file->private_data;\n\n\t\tseq->private = inode->i_private;\n\t}\n\treturn res;\n}\n\nstatic const struct file_operations dcb_info_debugfs_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = dcb_info_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release,\n};\n#endif  \n\nstatic int resources_show(struct seq_file *seq, void *v)\n{\n\tstruct adapter *adapter = seq->private;\n\tstruct pf_resources *pfres = &adapter->params.pfres;\n\n\t#define S(desc, fmt, var) \\\n\t\tseq_printf(seq, \"%-60s \" fmt \"\\n\", \\\n\t\t\t   desc \" (\" #var \"):\", pfres->var)\n\n\tS(\"Virtual Interfaces\", \"%d\", nvi);\n\tS(\"Egress Queues\", \"%d\", neq);\n\tS(\"Ethernet Control\", \"%d\", nethctrl);\n\tS(\"Ingress Queues/w Free Lists/Interrupts\", \"%d\", niqflint);\n\tS(\"Ingress Queues\", \"%d\", niq);\n\tS(\"Traffic Class\", \"%d\", tc);\n\tS(\"Port Access Rights Mask\", \"%#x\", pmask);\n\tS(\"MAC Address Filters\", \"%d\", nexactf);\n\tS(\"Firmware Command Read Capabilities\", \"%#x\", r_caps);\n\tS(\"Firmware Command Write/Execute Capabilities\", \"%#x\", wx_caps);\n\n\t#undef S\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(resources);\n\n \nstatic inline struct port_info *ethqset2pinfo(struct adapter *adap, int qset)\n{\n\tint pidx;\n\n\tfor_each_port(adap, pidx) {\n\t\tstruct port_info *pi = adap2pinfo(adap, pidx);\n\n\t\tif (qset >= pi->first_qset &&\n\t\t    qset < pi->first_qset + pi->nqsets)\n\t\t\treturn pi;\n\t}\n\n\t \n\tBUG();\n\treturn NULL;\n}\n\nstatic int sge_qinfo_uld_txq_entries(const struct adapter *adap, int uld)\n{\n\tconst struct sge_uld_txq_info *utxq_info = adap->sge.uld_txq_info[uld];\n\n\tif (!utxq_info)\n\t\treturn 0;\n\n\treturn DIV_ROUND_UP(utxq_info->ntxq, 4);\n}\n\nstatic int sge_qinfo_uld_rspq_entries(const struct adapter *adap, int uld,\n\t\t\t\t      bool ciq)\n{\n\tconst struct sge_uld_rxq_info *urxq_info = adap->sge.uld_rxq_info[uld];\n\n\tif (!urxq_info)\n\t\treturn 0;\n\n\treturn ciq ? DIV_ROUND_UP(urxq_info->nciq, 4) :\n\t\t     DIV_ROUND_UP(urxq_info->nrxq, 4);\n}\n\nstatic int sge_qinfo_uld_rxq_entries(const struct adapter *adap, int uld)\n{\n\treturn sge_qinfo_uld_rspq_entries(adap, uld, false);\n}\n\nstatic int sge_qinfo_uld_ciq_entries(const struct adapter *adap, int uld)\n{\n\treturn sge_qinfo_uld_rspq_entries(adap, uld, true);\n}\n\nstatic int sge_qinfo_show(struct seq_file *seq, void *v)\n{\n\tint eth_entries, ctrl_entries, eohw_entries = 0, eosw_entries = 0;\n\tint uld_rxq_entries[CXGB4_ULD_MAX] = { 0 };\n\tint uld_ciq_entries[CXGB4_ULD_MAX] = { 0 };\n\tint uld_txq_entries[CXGB4_TX_MAX] = { 0 };\n\tconst struct sge_uld_txq_info *utxq_info;\n\tconst struct sge_uld_rxq_info *urxq_info;\n\tstruct cxgb4_tc_port_mqprio *port_mqprio;\n\tstruct adapter *adap = seq->private;\n\tint i, j, n, r = (uintptr_t)v - 1;\n\tstruct sge *s = &adap->sge;\n\n\teth_entries = DIV_ROUND_UP(adap->sge.ethqsets, 4);\n\tctrl_entries = DIV_ROUND_UP(MAX_CTRL_QUEUES, 4);\n\n\tif (r)\n\t\tseq_putc(seq, '\\n');\n\n#define S3(fmt_spec, s, v) \\\ndo { \\\n\tseq_printf(seq, \"%-12s\", s); \\\n\tfor (i = 0; i < n; ++i) \\\n\t\tseq_printf(seq, \" %16\" fmt_spec, v); \\\n\tseq_putc(seq, '\\n'); \\\n} while (0)\n#define S(s, v) S3(\"s\", s, v)\n#define T3(fmt_spec, s, v) S3(fmt_spec, s, tx[i].v)\n#define T(s, v) S3(\"u\", s, tx[i].v)\n#define TL(s, v) T3(\"lu\", s, v)\n#define R3(fmt_spec, s, v) S3(fmt_spec, s, rx[i].v)\n#define R(s, v) S3(\"u\", s, rx[i].v)\n#define RL(s, v) R3(\"lu\", s, v)\n\n\tif (r < eth_entries) {\n\t\tint base_qset = r * 4;\n\t\tconst struct sge_eth_rxq *rx = &s->ethrxq[base_qset];\n\t\tconst struct sge_eth_txq *tx = &s->ethtxq[base_qset];\n\n\t\tn = min(4, s->ethqsets - 4 * r);\n\n\t\tS(\"QType:\", \"Ethernet\");\n\t\tS(\"Interface:\",\n\t\t  rx[i].rspq.netdev ? rx[i].rspq.netdev->name : \"N/A\");\n\t\tT(\"TxQ ID:\", q.cntxt_id);\n\t\tT(\"TxQ size:\", q.size);\n\t\tT(\"TxQ inuse:\", q.in_use);\n\t\tT(\"TxQ CIDX:\", q.cidx);\n\t\tT(\"TxQ PIDX:\", q.pidx);\n#ifdef CONFIG_CHELSIO_T4_DCB\n\t\tT(\"DCB Prio:\", dcb_prio);\n\t\tS3(\"u\", \"DCB PGID:\",\n\t\t   (ethqset2pinfo(adap, base_qset + i)->dcb.pgid >>\n\t\t    4*(7-tx[i].dcb_prio)) & 0xf);\n\t\tS3(\"u\", \"DCB PFC:\",\n\t\t   (ethqset2pinfo(adap, base_qset + i)->dcb.pfcen >>\n\t\t    1*(7-tx[i].dcb_prio)) & 0x1);\n#endif\n\t\tR(\"RspQ ID:\", rspq.abs_id);\n\t\tR(\"RspQ size:\", rspq.size);\n\t\tR(\"RspQE size:\", rspq.iqe_len);\n\t\tR(\"RspQ CIDX:\", rspq.cidx);\n\t\tR(\"RspQ Gen:\", rspq.gen);\n\t\tS3(\"u\", \"Intr delay:\", qtimer_val(adap, &rx[i].rspq));\n\t\tS3(\"u\", \"Intr pktcnt:\", s->counter_val[rx[i].rspq.pktcnt_idx]);\n\t\tR(\"FL ID:\", fl.cntxt_id);\n\t\tR(\"FL size:\", fl.size - 8);\n\t\tR(\"FL pend:\", fl.pend_cred);\n\t\tR(\"FL avail:\", fl.avail);\n\t\tR(\"FL PIDX:\", fl.pidx);\n\t\tR(\"FL CIDX:\", fl.cidx);\n\t\tRL(\"RxPackets:\", stats.pkts);\n\t\tRL(\"RxCSO:\", stats.rx_cso);\n\t\tRL(\"VLANxtract:\", stats.vlan_ex);\n\t\tRL(\"LROmerged:\", stats.lro_merged);\n\t\tRL(\"LROpackets:\", stats.lro_pkts);\n\t\tRL(\"RxDrops:\", stats.rx_drops);\n\t\tRL(\"RxBadPkts:\", stats.bad_rx_pkts);\n\t\tTL(\"TSO:\", tso);\n\t\tTL(\"USO:\", uso);\n\t\tTL(\"TxCSO:\", tx_cso);\n\t\tTL(\"VLANins:\", vlan_ins);\n\t\tTL(\"TxQFull:\", q.stops);\n\t\tTL(\"TxQRestarts:\", q.restarts);\n\t\tTL(\"TxMapErr:\", mapping_err);\n\t\tRL(\"FLAllocErr:\", fl.alloc_failed);\n\t\tRL(\"FLLrgAlcErr:\", fl.large_alloc_failed);\n\t\tRL(\"FLMapErr:\", fl.mapping_err);\n\t\tRL(\"FLLow:\", fl.low);\n\t\tRL(\"FLStarving:\", fl.starving);\n\n\t\tgoto out;\n\t}\n\n\tr -= eth_entries;\n\tfor_each_port(adap, j) {\n\t\tstruct port_info *pi = adap2pinfo(adap, j);\n\t\tconst struct sge_eth_rxq *rx;\n\n\t\tmutex_lock(&pi->vi_mirror_mutex);\n\t\tif (!pi->vi_mirror_count) {\n\t\t\tmutex_unlock(&pi->vi_mirror_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (r >= DIV_ROUND_UP(pi->nmirrorqsets, 4)) {\n\t\t\tr -= DIV_ROUND_UP(pi->nmirrorqsets, 4);\n\t\t\tmutex_unlock(&pi->vi_mirror_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\trx = &s->mirror_rxq[j][r * 4];\n\t\tn = min(4, pi->nmirrorqsets - 4 * r);\n\n\t\tS(\"QType:\", \"Mirror-Rxq\");\n\t\tS(\"Interface:\",\n\t\t  rx[i].rspq.netdev ? rx[i].rspq.netdev->name : \"N/A\");\n\t\tR(\"RspQ ID:\", rspq.abs_id);\n\t\tR(\"RspQ size:\", rspq.size);\n\t\tR(\"RspQE size:\", rspq.iqe_len);\n\t\tR(\"RspQ CIDX:\", rspq.cidx);\n\t\tR(\"RspQ Gen:\", rspq.gen);\n\t\tS3(\"u\", \"Intr delay:\", qtimer_val(adap, &rx[i].rspq));\n\t\tS3(\"u\", \"Intr pktcnt:\", s->counter_val[rx[i].rspq.pktcnt_idx]);\n\t\tR(\"FL ID:\", fl.cntxt_id);\n\t\tR(\"FL size:\", fl.size - 8);\n\t\tR(\"FL pend:\", fl.pend_cred);\n\t\tR(\"FL avail:\", fl.avail);\n\t\tR(\"FL PIDX:\", fl.pidx);\n\t\tR(\"FL CIDX:\", fl.cidx);\n\t\tRL(\"RxPackets:\", stats.pkts);\n\t\tRL(\"RxCSO:\", stats.rx_cso);\n\t\tRL(\"VLANxtract:\", stats.vlan_ex);\n\t\tRL(\"LROmerged:\", stats.lro_merged);\n\t\tRL(\"LROpackets:\", stats.lro_pkts);\n\t\tRL(\"RxDrops:\", stats.rx_drops);\n\t\tRL(\"RxBadPkts:\", stats.bad_rx_pkts);\n\t\tRL(\"FLAllocErr:\", fl.alloc_failed);\n\t\tRL(\"FLLrgAlcErr:\", fl.large_alloc_failed);\n\t\tRL(\"FLMapErr:\", fl.mapping_err);\n\t\tRL(\"FLLow:\", fl.low);\n\t\tRL(\"FLStarving:\", fl.starving);\n\n\t\tmutex_unlock(&pi->vi_mirror_mutex);\n\t\tgoto out;\n\t}\n\n\tif (!adap->tc_mqprio)\n\t\tgoto skip_mqprio;\n\n\tmutex_lock(&adap->tc_mqprio->mqprio_mutex);\n\tif (!refcount_read(&adap->tc_mqprio->refcnt)) {\n\t\tmutex_unlock(&adap->tc_mqprio->mqprio_mutex);\n\t\tgoto skip_mqprio;\n\t}\n\n\teohw_entries = DIV_ROUND_UP(adap->sge.eoqsets, 4);\n\tif (r < eohw_entries) {\n\t\tint base_qset = r * 4;\n\t\tconst struct sge_ofld_rxq *rx = &s->eohw_rxq[base_qset];\n\t\tconst struct sge_eohw_txq *tx = &s->eohw_txq[base_qset];\n\n\t\tn = min(4, s->eoqsets - 4 * r);\n\n\t\tS(\"QType:\", \"ETHOFLD\");\n\t\tS(\"Interface:\",\n\t\t  rx[i].rspq.netdev ? rx[i].rspq.netdev->name : \"N/A\");\n\t\tT(\"TxQ ID:\", q.cntxt_id);\n\t\tT(\"TxQ size:\", q.size);\n\t\tT(\"TxQ inuse:\", q.in_use);\n\t\tT(\"TxQ CIDX:\", q.cidx);\n\t\tT(\"TxQ PIDX:\", q.pidx);\n\t\tR(\"RspQ ID:\", rspq.abs_id);\n\t\tR(\"RspQ size:\", rspq.size);\n\t\tR(\"RspQE size:\", rspq.iqe_len);\n\t\tR(\"RspQ CIDX:\", rspq.cidx);\n\t\tR(\"RspQ Gen:\", rspq.gen);\n\t\tS3(\"u\", \"Intr delay:\", qtimer_val(adap, &rx[i].rspq));\n\t\tS3(\"u\", \"Intr pktcnt:\", s->counter_val[rx[i].rspq.pktcnt_idx]);\n\t\tR(\"FL ID:\", fl.cntxt_id);\n\t\tS3(\"u\", \"FL size:\", rx->fl.size ? rx->fl.size - 8 : 0);\n\t\tR(\"FL pend:\", fl.pend_cred);\n\t\tR(\"FL avail:\", fl.avail);\n\t\tR(\"FL PIDX:\", fl.pidx);\n\t\tR(\"FL CIDX:\", fl.cidx);\n\t\tRL(\"RxPackets:\", stats.pkts);\n\t\tRL(\"RxImm:\", stats.imm);\n\t\tRL(\"RxAN\", stats.an);\n\t\tRL(\"RxNoMem\", stats.nomem);\n\t\tTL(\"TSO:\", tso);\n\t\tTL(\"USO:\", uso);\n\t\tTL(\"TxCSO:\", tx_cso);\n\t\tTL(\"VLANins:\", vlan_ins);\n\t\tTL(\"TxQFull:\", q.stops);\n\t\tTL(\"TxQRestarts:\", q.restarts);\n\t\tTL(\"TxMapErr:\", mapping_err);\n\t\tRL(\"FLAllocErr:\", fl.alloc_failed);\n\t\tRL(\"FLLrgAlcErr:\", fl.large_alloc_failed);\n\t\tRL(\"FLMapErr:\", fl.mapping_err);\n\t\tRL(\"FLLow:\", fl.low);\n\t\tRL(\"FLStarving:\", fl.starving);\n\n\t\tmutex_unlock(&adap->tc_mqprio->mqprio_mutex);\n\t\tgoto out;\n\t}\n\n\tr -= eohw_entries;\n\tfor (j = 0; j < adap->params.nports; j++) {\n\t\tint entries;\n\t\tu8 tc;\n\n\t\tport_mqprio = &adap->tc_mqprio->port_mqprio[j];\n\t\tentries = 0;\n\t\tfor (tc = 0; tc < port_mqprio->mqprio.qopt.num_tc; tc++)\n\t\t\tentries += port_mqprio->mqprio.qopt.count[tc];\n\n\t\tif (!entries)\n\t\t\tcontinue;\n\n\t\teosw_entries = DIV_ROUND_UP(entries, 4);\n\t\tif (r < eosw_entries) {\n\t\t\tconst struct sge_eosw_txq *tx;\n\n\t\t\tn = min(4, entries - 4 * r);\n\t\t\ttx = &port_mqprio->eosw_txq[4 * r];\n\n\t\t\tS(\"QType:\", \"EOSW-TXQ\");\n\t\t\tS(\"Interface:\",\n\t\t\t  adap->port[j] ? adap->port[j]->name : \"N/A\");\n\t\t\tT(\"EOTID:\", hwtid);\n\t\t\tT(\"HWQID:\", hwqid);\n\t\t\tT(\"State:\", state);\n\t\t\tT(\"Size:\", ndesc);\n\t\t\tT(\"In-Use:\", inuse);\n\t\t\tT(\"Credits:\", cred);\n\t\t\tT(\"Compl:\", ncompl);\n\t\t\tT(\"Last-Compl:\", last_compl);\n\t\t\tT(\"PIDX:\", pidx);\n\t\t\tT(\"Last-PIDX:\", last_pidx);\n\t\t\tT(\"CIDX:\", cidx);\n\t\t\tT(\"Last-CIDX:\", last_cidx);\n\t\t\tT(\"FLOWC-IDX:\", flowc_idx);\n\n\t\t\tmutex_unlock(&adap->tc_mqprio->mqprio_mutex);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr -= eosw_entries;\n\t}\n\tmutex_unlock(&adap->tc_mqprio->mqprio_mutex);\n\nskip_mqprio:\n\tif (!is_uld(adap))\n\t\tgoto skip_uld;\n\n\tmutex_lock(&uld_mutex);\n\tif (s->uld_txq_info)\n\t\tfor (i = 0; i < ARRAY_SIZE(uld_txq_entries); i++)\n\t\t\tuld_txq_entries[i] = sge_qinfo_uld_txq_entries(adap, i);\n\n\tif (s->uld_rxq_info) {\n\t\tfor (i = 0; i < ARRAY_SIZE(uld_rxq_entries); i++) {\n\t\t\tuld_rxq_entries[i] = sge_qinfo_uld_rxq_entries(adap, i);\n\t\t\tuld_ciq_entries[i] = sge_qinfo_uld_ciq_entries(adap, i);\n\t\t}\n\t}\n\n\tif (r < uld_txq_entries[CXGB4_TX_OFLD]) {\n\t\tconst struct sge_uld_txq *tx;\n\n\t\tutxq_info = s->uld_txq_info[CXGB4_TX_OFLD];\n\t\ttx = &utxq_info->uldtxq[r * 4];\n\t\tn = min(4, utxq_info->ntxq - 4 * r);\n\n\t\tS(\"QType:\", \"OFLD-TXQ\");\n\t\tT(\"TxQ ID:\", q.cntxt_id);\n\t\tT(\"TxQ size:\", q.size);\n\t\tT(\"TxQ inuse:\", q.in_use);\n\t\tT(\"TxQ CIDX:\", q.cidx);\n\t\tT(\"TxQ PIDX:\", q.pidx);\n\n\t\tgoto unlock;\n\t}\n\n\tr -= uld_txq_entries[CXGB4_TX_OFLD];\n\tif (r < uld_rxq_entries[CXGB4_ULD_RDMA]) {\n\t\tconst struct sge_ofld_rxq *rx;\n\n\t\turxq_info = s->uld_rxq_info[CXGB4_ULD_RDMA];\n\t\trx = &urxq_info->uldrxq[r * 4];\n\t\tn = min(4, urxq_info->nrxq - 4 * r);\n\n\t\tS(\"QType:\", \"RDMA-CPL\");\n\t\tS(\"Interface:\",\n\t\t  rx[i].rspq.netdev ? rx[i].rspq.netdev->name : \"N/A\");\n\t\tR(\"RspQ ID:\", rspq.abs_id);\n\t\tR(\"RspQ size:\", rspq.size);\n\t\tR(\"RspQE size:\", rspq.iqe_len);\n\t\tR(\"RspQ CIDX:\", rspq.cidx);\n\t\tR(\"RspQ Gen:\", rspq.gen);\n\t\tS3(\"u\", \"Intr delay:\", qtimer_val(adap, &rx[i].rspq));\n\t\tS3(\"u\", \"Intr pktcnt:\",\ts->counter_val[rx[i].rspq.pktcnt_idx]);\n\t\tR(\"FL ID:\", fl.cntxt_id);\n\t\tR(\"FL size:\", fl.size - 8);\n\t\tR(\"FL pend:\", fl.pend_cred);\n\t\tR(\"FL avail:\", fl.avail);\n\t\tR(\"FL PIDX:\", fl.pidx);\n\t\tR(\"FL CIDX:\", fl.cidx);\n\n\t\tgoto unlock;\n\t}\n\n\tr -= uld_rxq_entries[CXGB4_ULD_RDMA];\n\tif (r < uld_ciq_entries[CXGB4_ULD_RDMA]) {\n\t\tconst struct sge_ofld_rxq *rx;\n\t\tint ciq_idx = 0;\n\n\t\turxq_info = s->uld_rxq_info[CXGB4_ULD_RDMA];\n\t\tciq_idx = urxq_info->nrxq + (r * 4);\n\t\trx = &urxq_info->uldrxq[ciq_idx];\n\t\tn = min(4, urxq_info->nciq - 4 * r);\n\n\t\tS(\"QType:\", \"RDMA-CIQ\");\n\t\tS(\"Interface:\",\n\t\t  rx[i].rspq.netdev ? rx[i].rspq.netdev->name : \"N/A\");\n\t\tR(\"RspQ ID:\", rspq.abs_id);\n\t\tR(\"RspQ size:\", rspq.size);\n\t\tR(\"RspQE size:\", rspq.iqe_len);\n\t\tR(\"RspQ CIDX:\", rspq.cidx);\n\t\tR(\"RspQ Gen:\", rspq.gen);\n\t\tS3(\"u\", \"Intr delay:\", qtimer_val(adap, &rx[i].rspq));\n\t\tS3(\"u\", \"Intr pktcnt:\",\ts->counter_val[rx[i].rspq.pktcnt_idx]);\n\n\t\tgoto unlock;\n\t}\n\n\tr -= uld_ciq_entries[CXGB4_ULD_RDMA];\n\tif (r < uld_rxq_entries[CXGB4_ULD_ISCSI]) {\n\t\tconst struct sge_ofld_rxq *rx;\n\n\t\turxq_info = s->uld_rxq_info[CXGB4_ULD_ISCSI];\n\t\trx = &urxq_info->uldrxq[r * 4];\n\t\tn = min(4, urxq_info->nrxq - 4 * r);\n\n\t\tS(\"QType:\", \"iSCSI\");\n\t\tR(\"RspQ ID:\", rspq.abs_id);\n\t\tR(\"RspQ size:\", rspq.size);\n\t\tR(\"RspQE size:\", rspq.iqe_len);\n\t\tR(\"RspQ CIDX:\", rspq.cidx);\n\t\tR(\"RspQ Gen:\", rspq.gen);\n\t\tS3(\"u\", \"Intr delay:\", qtimer_val(adap, &rx[i].rspq));\n\t\tS3(\"u\", \"Intr pktcnt:\",\ts->counter_val[rx[i].rspq.pktcnt_idx]);\n\t\tR(\"FL ID:\", fl.cntxt_id);\n\t\tR(\"FL size:\", fl.size - 8);\n\t\tR(\"FL pend:\", fl.pend_cred);\n\t\tR(\"FL avail:\", fl.avail);\n\t\tR(\"FL PIDX:\", fl.pidx);\n\t\tR(\"FL CIDX:\", fl.cidx);\n\n\t\tgoto unlock;\n\t}\n\n\tr -= uld_rxq_entries[CXGB4_ULD_ISCSI];\n\tif (r < uld_rxq_entries[CXGB4_ULD_ISCSIT]) {\n\t\tconst struct sge_ofld_rxq *rx;\n\n\t\turxq_info = s->uld_rxq_info[CXGB4_ULD_ISCSIT];\n\t\trx = &urxq_info->uldrxq[r * 4];\n\t\tn = min(4, urxq_info->nrxq - 4 * r);\n\n\t\tS(\"QType:\", \"iSCSIT\");\n\t\tR(\"RspQ ID:\", rspq.abs_id);\n\t\tR(\"RspQ size:\", rspq.size);\n\t\tR(\"RspQE size:\", rspq.iqe_len);\n\t\tR(\"RspQ CIDX:\", rspq.cidx);\n\t\tR(\"RspQ Gen:\", rspq.gen);\n\t\tS3(\"u\", \"Intr delay:\", qtimer_val(adap, &rx[i].rspq));\n\t\tS3(\"u\", \"Intr pktcnt:\",\ts->counter_val[rx[i].rspq.pktcnt_idx]);\n\t\tR(\"FL ID:\", fl.cntxt_id);\n\t\tR(\"FL size:\", fl.size - 8);\n\t\tR(\"FL pend:\", fl.pend_cred);\n\t\tR(\"FL avail:\", fl.avail);\n\t\tR(\"FL PIDX:\", fl.pidx);\n\t\tR(\"FL CIDX:\", fl.cidx);\n\n\t\tgoto unlock;\n\t}\n\n\tr -= uld_rxq_entries[CXGB4_ULD_ISCSIT];\n\tif (r < uld_rxq_entries[CXGB4_ULD_TLS]) {\n\t\tconst struct sge_ofld_rxq *rx;\n\n\t\turxq_info = s->uld_rxq_info[CXGB4_ULD_TLS];\n\t\trx = &urxq_info->uldrxq[r * 4];\n\t\tn = min(4, urxq_info->nrxq - 4 * r);\n\n\t\tS(\"QType:\", \"TLS\");\n\t\tR(\"RspQ ID:\", rspq.abs_id);\n\t\tR(\"RspQ size:\", rspq.size);\n\t\tR(\"RspQE size:\", rspq.iqe_len);\n\t\tR(\"RspQ CIDX:\", rspq.cidx);\n\t\tR(\"RspQ Gen:\", rspq.gen);\n\t\tS3(\"u\", \"Intr delay:\", qtimer_val(adap, &rx[i].rspq));\n\t\tS3(\"u\", \"Intr pktcnt:\",\ts->counter_val[rx[i].rspq.pktcnt_idx]);\n\t\tR(\"FL ID:\", fl.cntxt_id);\n\t\tR(\"FL size:\", fl.size - 8);\n\t\tR(\"FL pend:\", fl.pend_cred);\n\t\tR(\"FL avail:\", fl.avail);\n\t\tR(\"FL PIDX:\", fl.pidx);\n\t\tR(\"FL CIDX:\", fl.cidx);\n\n\t\tgoto unlock;\n\t}\n\n\tr -= uld_rxq_entries[CXGB4_ULD_TLS];\n\tif (r < uld_txq_entries[CXGB4_TX_CRYPTO]) {\n\t\tconst struct sge_ofld_rxq *rx;\n\t\tconst struct sge_uld_txq *tx;\n\n\t\tutxq_info = s->uld_txq_info[CXGB4_TX_CRYPTO];\n\t\turxq_info = s->uld_rxq_info[CXGB4_ULD_CRYPTO];\n\t\ttx = &utxq_info->uldtxq[r * 4];\n\t\trx = &urxq_info->uldrxq[r * 4];\n\t\tn = min(4, utxq_info->ntxq - 4 * r);\n\n\t\tS(\"QType:\", \"Crypto\");\n\t\tT(\"TxQ ID:\", q.cntxt_id);\n\t\tT(\"TxQ size:\", q.size);\n\t\tT(\"TxQ inuse:\", q.in_use);\n\t\tT(\"TxQ CIDX:\", q.cidx);\n\t\tT(\"TxQ PIDX:\", q.pidx);\n\t\tR(\"RspQ ID:\", rspq.abs_id);\n\t\tR(\"RspQ size:\", rspq.size);\n\t\tR(\"RspQE size:\", rspq.iqe_len);\n\t\tR(\"RspQ CIDX:\", rspq.cidx);\n\t\tR(\"RspQ Gen:\", rspq.gen);\n\t\tS3(\"u\", \"Intr delay:\", qtimer_val(adap, &rx[i].rspq));\n\t\tS3(\"u\", \"Intr pktcnt:\",\ts->counter_val[rx[i].rspq.pktcnt_idx]);\n\t\tR(\"FL ID:\", fl.cntxt_id);\n\t\tR(\"FL size:\", fl.size - 8);\n\t\tR(\"FL pend:\", fl.pend_cred);\n\t\tR(\"FL avail:\", fl.avail);\n\t\tR(\"FL PIDX:\", fl.pidx);\n\t\tR(\"FL CIDX:\", fl.cidx);\n\n\t\tgoto unlock;\n\t}\n\n\tr -= uld_txq_entries[CXGB4_TX_CRYPTO];\n\tmutex_unlock(&uld_mutex);\n\nskip_uld:\n\tif (r < ctrl_entries) {\n\t\tconst struct sge_ctrl_txq *tx = &s->ctrlq[r * 4];\n\n\t\tn = min(4, adap->params.nports - 4 * r);\n\n\t\tS(\"QType:\", \"Control\");\n\t\tT(\"TxQ ID:\", q.cntxt_id);\n\t\tT(\"TxQ size:\", q.size);\n\t\tT(\"TxQ inuse:\", q.in_use);\n\t\tT(\"TxQ CIDX:\", q.cidx);\n\t\tT(\"TxQ PIDX:\", q.pidx);\n\t\tTL(\"TxQFull:\", q.stops);\n\t\tTL(\"TxQRestarts:\", q.restarts);\n\n\t\tgoto out;\n\t}\n\n\tr -= ctrl_entries;\n\tif (r < 1) {\n\t\tconst struct sge_rspq *evtq = &s->fw_evtq;\n\n\t\tseq_printf(seq, \"%-12s %16s\\n\", \"QType:\", \"FW event queue\");\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"RspQ ID:\", evtq->abs_id);\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"RspQ size:\", evtq->size);\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"RspQE size:\", evtq->iqe_len);\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"RspQ CIDX:\", evtq->cidx);\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"RspQ Gen:\", evtq->gen);\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"Intr delay:\",\n\t\t\t   qtimer_val(adap, evtq));\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"Intr pktcnt:\",\n\t\t\t   s->counter_val[evtq->pktcnt_idx]);\n\n\t\tgoto out;\n\t}\n\n#undef R\n#undef RL\n#undef T\n#undef TL\n#undef S\n#undef R3\n#undef T3\n#undef S3\nout:\n\treturn 0;\n\nunlock:\n\tmutex_unlock(&uld_mutex);\n\treturn 0;\n}\n\nstatic int sge_queue_entries(struct adapter *adap)\n{\n\tint i, tot_uld_entries = 0, eohw_entries = 0, eosw_entries = 0;\n\tint mirror_rxq_entries = 0;\n\n\tif (adap->tc_mqprio) {\n\t\tstruct cxgb4_tc_port_mqprio *port_mqprio;\n\t\tu8 tc;\n\n\t\tmutex_lock(&adap->tc_mqprio->mqprio_mutex);\n\t\tif (adap->sge.eohw_txq)\n\t\t\teohw_entries = DIV_ROUND_UP(adap->sge.eoqsets, 4);\n\n\t\tfor (i = 0; i < adap->params.nports; i++) {\n\t\t\tu32 entries = 0;\n\n\t\t\tport_mqprio = &adap->tc_mqprio->port_mqprio[i];\n\t\t\tfor (tc = 0; tc < port_mqprio->mqprio.qopt.num_tc; tc++)\n\t\t\t\tentries += port_mqprio->mqprio.qopt.count[tc];\n\n\t\t\tif (entries)\n\t\t\t\teosw_entries += DIV_ROUND_UP(entries, 4);\n\t\t}\n\t\tmutex_unlock(&adap->tc_mqprio->mqprio_mutex);\n\t}\n\n\tfor_each_port(adap, i) {\n\t\tstruct port_info *pi = adap2pinfo(adap, i);\n\n\t\tmutex_lock(&pi->vi_mirror_mutex);\n\t\tif (pi->vi_mirror_count)\n\t\t\tmirror_rxq_entries += DIV_ROUND_UP(pi->nmirrorqsets, 4);\n\t\tmutex_unlock(&pi->vi_mirror_mutex);\n\t}\n\n\tif (!is_uld(adap))\n\t\tgoto lld_only;\n\n\tmutex_lock(&uld_mutex);\n\tfor (i = 0; i < CXGB4_TX_MAX; i++)\n\t\ttot_uld_entries += sge_qinfo_uld_txq_entries(adap, i);\n\n\tfor (i = 0; i < CXGB4_ULD_MAX; i++) {\n\t\ttot_uld_entries += sge_qinfo_uld_rxq_entries(adap, i);\n\t\ttot_uld_entries += sge_qinfo_uld_ciq_entries(adap, i);\n\t}\n\tmutex_unlock(&uld_mutex);\n\nlld_only:\n\treturn DIV_ROUND_UP(adap->sge.ethqsets, 4) + mirror_rxq_entries +\n\t       eohw_entries + eosw_entries + tot_uld_entries +\n\t       DIV_ROUND_UP(MAX_CTRL_QUEUES, 4) + 1;\n}\n\nstatic void *sge_queue_start(struct seq_file *seq, loff_t *pos)\n{\n\tint entries = sge_queue_entries(seq->private);\n\n\treturn *pos < entries ? (void *)((uintptr_t)*pos + 1) : NULL;\n}\n\nstatic void sge_queue_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic void *sge_queue_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tint entries = sge_queue_entries(seq->private);\n\n\t++*pos;\n\treturn *pos < entries ? (void *)((uintptr_t)*pos + 1) : NULL;\n}\n\nstatic const struct seq_operations sge_qinfo_seq_ops = {\n\t.start = sge_queue_start,\n\t.next  = sge_queue_next,\n\t.stop  = sge_queue_stop,\n\t.show  = sge_qinfo_show\n};\n\nstatic int sge_qinfo_open(struct inode *inode, struct file *file)\n{\n\tint res = seq_open(file, &sge_qinfo_seq_ops);\n\n\tif (!res) {\n\t\tstruct seq_file *seq = file->private_data;\n\n\t\tseq->private = inode->i_private;\n\t}\n\treturn res;\n}\n\nstatic const struct file_operations sge_qinfo_debugfs_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = sge_qinfo_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release,\n};\n\nint mem_open(struct inode *inode, struct file *file)\n{\n\tunsigned int mem;\n\tstruct adapter *adap;\n\n\tfile->private_data = inode->i_private;\n\n\tmem = (uintptr_t)file->private_data & 0x7;\n\tadap = file->private_data - mem;\n\n\t(void)t4_fwcache(adap, FW_PARAM_DEV_FWCACHE_FLUSH);\n\n\treturn 0;\n}\n\nstatic ssize_t mem_read(struct file *file, char __user *buf, size_t count,\n\t\t\tloff_t *ppos)\n{\n\tloff_t pos = *ppos;\n\tloff_t avail = file_inode(file)->i_size;\n\tunsigned int mem = (uintptr_t)file->private_data & 0x7;\n\tstruct adapter *adap = file->private_data - mem;\n\t__be32 *data;\n\tint ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= avail)\n\t\treturn 0;\n\tif (count > avail - pos)\n\t\tcount = avail - pos;\n\n\tdata = kvzalloc(count, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&adap->win0_lock);\n\tret = t4_memory_rw(adap, 0, mem, pos, count, data, T4_MEMORY_READ);\n\tspin_unlock(&adap->win0_lock);\n\tif (ret) {\n\t\tkvfree(data);\n\t\treturn ret;\n\t}\n\tret = copy_to_user(buf, data, count);\n\n\tkvfree(data);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\t*ppos = pos + count;\n\treturn count;\n}\nstatic const struct file_operations mem_debugfs_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = simple_open,\n\t.read    = mem_read,\n\t.llseek  = default_llseek,\n};\n\nstatic int tid_info_show(struct seq_file *seq, void *v)\n{\n\tstruct adapter *adap = seq->private;\n\tconst struct tid_info *t;\n\tenum chip_type chip;\n\n\tt = &adap->tids;\n\tchip = CHELSIO_CHIP_VERSION(adap->params.chip);\n\tif (t4_read_reg(adap, LE_DB_CONFIG_A) & HASHEN_F) {\n\t\tunsigned int sb;\n\t\tseq_printf(seq, \"Connections in use: %u\\n\",\n\t\t\t   atomic_read(&t->conns_in_use));\n\n\t\tif (chip <= CHELSIO_T5)\n\t\t\tsb = t4_read_reg(adap, LE_DB_SERVER_INDEX_A) / 4;\n\t\telse\n\t\t\tsb = t4_read_reg(adap, LE_DB_SRVR_START_INDEX_A);\n\n\t\tif (sb) {\n\t\t\tseq_printf(seq, \"TID range: %u..%u/%u..%u\", t->tid_base,\n\t\t\t\t   sb - 1, adap->tids.hash_base,\n\t\t\t\t   t->tid_base + t->ntids - 1);\n\t\t\tseq_printf(seq, \", in use: %u/%u\\n\",\n\t\t\t\t   atomic_read(&t->tids_in_use),\n\t\t\t\t   atomic_read(&t->hash_tids_in_use));\n\t\t} else if (adap->flags & CXGB4_FW_OFLD_CONN) {\n\t\t\tseq_printf(seq, \"TID range: %u..%u/%u..%u\",\n\t\t\t\t   t->aftid_base,\n\t\t\t\t   t->aftid_end,\n\t\t\t\t   adap->tids.hash_base,\n\t\t\t\t   t->tid_base + t->ntids - 1);\n\t\t\tseq_printf(seq, \", in use: %u/%u\\n\",\n\t\t\t\t   atomic_read(&t->tids_in_use),\n\t\t\t\t   atomic_read(&t->hash_tids_in_use));\n\t\t} else {\n\t\t\tseq_printf(seq, \"TID range: %u..%u\",\n\t\t\t\t   adap->tids.hash_base,\n\t\t\t\t   t->tid_base + t->ntids - 1);\n\t\t\tseq_printf(seq, \", in use: %u\\n\",\n\t\t\t\t   atomic_read(&t->hash_tids_in_use));\n\t\t}\n\t} else if (t->ntids) {\n\t\tseq_printf(seq, \"Connections in use: %u\\n\",\n\t\t\t   atomic_read(&t->conns_in_use));\n\n\t\tseq_printf(seq, \"TID range: %u..%u\", t->tid_base,\n\t\t\t   t->tid_base + t->ntids - 1);\n\t\tseq_printf(seq, \", in use: %u\\n\",\n\t\t\t   atomic_read(&t->tids_in_use));\n\t}\n\n\tif (t->nstids)\n\t\tseq_printf(seq, \"STID range: %u..%u, in use-IPv4/IPv6: %u/%u\\n\",\n\t\t\t   (!t->stid_base &&\n\t\t\t   (chip <= CHELSIO_T5)) ?\n\t\t\t   t->stid_base + 1 : t->stid_base,\n\t\t\t   t->stid_base + t->nstids - 1,\n\t\t\t   t->stids_in_use - t->v6_stids_in_use,\n\t\t\t   t->v6_stids_in_use);\n\n\tif (t->natids)\n\t\tseq_printf(seq, \"ATID range: 0..%u, in use: %u\\n\",\n\t\t\t   t->natids - 1, t->atids_in_use);\n\tseq_printf(seq, \"FTID range: %u..%u\\n\", t->ftid_base,\n\t\t   t->ftid_base + t->nftids - 1);\n\tif (t->nsftids)\n\t\tseq_printf(seq, \"SFTID range: %u..%u in use: %u\\n\",\n\t\t\t   t->sftid_base, t->sftid_base + t->nsftids - 2,\n\t\t\t   t->sftids_in_use);\n\tif (t->nhpftids)\n\t\tseq_printf(seq, \"HPFTID range: %u..%u\\n\", t->hpftid_base,\n\t\t\t   t->hpftid_base + t->nhpftids - 1);\n\tif (t->neotids)\n\t\tseq_printf(seq, \"EOTID range: %u..%u, in use: %u\\n\",\n\t\t\t   t->eotid_base, t->eotid_base + t->neotids - 1,\n\t\t\t   atomic_read(&t->eotids_in_use));\n\tif (t->ntids)\n\t\tseq_printf(seq, \"HW TID usage: %u IP users, %u IPv6 users\\n\",\n\t\t\t   t4_read_reg(adap, LE_DB_ACT_CNT_IPV4_A),\n\t\t\t   t4_read_reg(adap, LE_DB_ACT_CNT_IPV6_A));\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(tid_info);\n\nstatic void add_debugfs_mem(struct adapter *adap, const char *name,\n\t\t\t    unsigned int idx, unsigned int size_mb)\n{\n\tdebugfs_create_file_size(name, 0400, adap->debugfs_root,\n\t\t\t\t (void *)adap + idx, &mem_debugfs_fops,\n\t\t\t\t size_mb << 20);\n}\n\nstatic ssize_t blocked_fl_read(struct file *filp, char __user *ubuf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tint len;\n\tconst struct adapter *adap = filp->private_data;\n\tchar *buf;\n\tssize_t size = (adap->sge.egr_sz + 3) / 4 +\n\t\t\tadap->sge.egr_sz / 32 + 2;  \n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlen = snprintf(buf, size - 1, \"%*pb\\n\",\n\t\t       adap->sge.egr_sz, adap->sge.blocked_fl);\n\tlen += sprintf(buf + len, \"\\n\");\n\tsize = simple_read_from_buffer(ubuf, count, ppos, buf, len);\n\tkfree(buf);\n\treturn size;\n}\n\nstatic ssize_t blocked_fl_write(struct file *filp, const char __user *ubuf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tint err;\n\tunsigned long *t;\n\tstruct adapter *adap = filp->private_data;\n\n\tt = bitmap_zalloc(adap->sge.egr_sz, GFP_KERNEL);\n\tif (!t)\n\t\treturn -ENOMEM;\n\n\terr = bitmap_parse_user(ubuf, count, t, adap->sge.egr_sz);\n\tif (err) {\n\t\tbitmap_free(t);\n\t\treturn err;\n\t}\n\n\tbitmap_copy(adap->sge.blocked_fl, t, adap->sge.egr_sz);\n\tbitmap_free(t);\n\treturn count;\n}\n\nstatic const struct file_operations blocked_fl_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = simple_open,\n\t.read    = blocked_fl_read,\n\t.write   = blocked_fl_write,\n\t.llseek  = generic_file_llseek,\n};\n\nstatic void mem_region_show(struct seq_file *seq, const char *name,\n\t\t\t    unsigned int from, unsigned int to)\n{\n\tchar buf[40];\n\n\tstring_get_size((u64)to - from + 1, 1, STRING_UNITS_2, buf,\n\t\t\tsizeof(buf));\n\tseq_printf(seq, \"%-15s %#x-%#x [%s]\\n\", name, from, to, buf);\n}\n\nstatic int meminfo_show(struct seq_file *seq, void *v)\n{\n\tstatic const char * const memory[] = { \"EDC0:\", \"EDC1:\", \"MC:\",\n\t\t\t\t\t       \"MC0:\", \"MC1:\", \"HMA:\"};\n\tstruct adapter *adap = seq->private;\n\tstruct cudbg_meminfo meminfo;\n\tint i, rc;\n\n\tmemset(&meminfo, 0, sizeof(struct cudbg_meminfo));\n\trc = cudbg_fill_meminfo(adap, &meminfo);\n\tif (rc)\n\t\treturn -ENXIO;\n\n\tfor (i = 0; i < meminfo.avail_c; i++)\n\t\tmem_region_show(seq, memory[meminfo.avail[i].idx],\n\t\t\t\tmeminfo.avail[i].base,\n\t\t\t\tmeminfo.avail[i].limit - 1);\n\n\tseq_putc(seq, '\\n');\n\tfor (i = 0; i < meminfo.mem_c; i++) {\n\t\tif (meminfo.mem[i].idx >= ARRAY_SIZE(cudbg_region))\n\t\t\tcontinue;                         \n\t\tif (!meminfo.mem[i].limit)\n\t\t\tmeminfo.mem[i].limit =\n\t\t\t\ti < meminfo.mem_c - 1 ?\n\t\t\t\tmeminfo.mem[i + 1].base - 1 : ~0;\n\t\tmem_region_show(seq, cudbg_region[meminfo.mem[i].idx],\n\t\t\t\tmeminfo.mem[i].base, meminfo.mem[i].limit);\n\t}\n\n\tseq_putc(seq, '\\n');\n\tmem_region_show(seq, \"uP RAM:\", meminfo.up_ram_lo, meminfo.up_ram_hi);\n\tmem_region_show(seq, \"uP Extmem2:\", meminfo.up_extmem2_lo,\n\t\t\tmeminfo.up_extmem2_hi);\n\n\tseq_printf(seq, \"\\n%u Rx pages (%u free) of size %uKiB for %u channels\\n\",\n\t\t   meminfo.rx_pages_data[0], meminfo.free_rx_cnt,\n\t\t   meminfo.rx_pages_data[1], meminfo.rx_pages_data[2]);\n\n\tseq_printf(seq, \"%u Tx pages (%u free) of size %u%ciB for %u channels\\n\",\n\t\t   meminfo.tx_pages_data[0], meminfo.free_tx_cnt,\n\t\t   meminfo.tx_pages_data[1], meminfo.tx_pages_data[2],\n\t\t   meminfo.tx_pages_data[3]);\n\n\tseq_printf(seq, \"%u p-structs (%u free)\\n\\n\",\n\t\t   meminfo.p_structs, meminfo.p_structs_free_cnt);\n\n\tfor (i = 0; i < 4; i++)\n\t\t \n\t\tseq_printf(seq, \"Port %d using %u pages out of %u allocated\\n\",\n\t\t\t   i, meminfo.port_used[i], meminfo.port_alloc[i]);\n\n\tfor (i = 0; i < adap->params.arch.nchan; i++)\n\t\t \n\t\tseq_printf(seq,\n\t\t\t   \"Loopback %d using %u pages out of %u allocated\\n\",\n\t\t\t   i, meminfo.loopback_used[i],\n\t\t\t   meminfo.loopback_alloc[i]);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(meminfo);\n\nstatic int chcr_stats_show(struct seq_file *seq, void *v)\n{\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n\tstruct ch_ktls_port_stats_debug *ktls_port;\n\tint i = 0;\n#endif\n\tstruct adapter *adap = seq->private;\n\n\tseq_puts(seq, \"Chelsio Crypto Accelerator Stats \\n\");\n\tseq_printf(seq, \"Cipher Ops: %10u \\n\",\n\t\t   atomic_read(&adap->chcr_stats.cipher_rqst));\n\tseq_printf(seq, \"Digest Ops: %10u \\n\",\n\t\t   atomic_read(&adap->chcr_stats.digest_rqst));\n\tseq_printf(seq, \"Aead Ops: %10u \\n\",\n\t\t   atomic_read(&adap->chcr_stats.aead_rqst));\n\tseq_printf(seq, \"Completion: %10u \\n\",\n\t\t   atomic_read(&adap->chcr_stats.complete));\n\tseq_printf(seq, \"Error: %10u \\n\",\n\t\t   atomic_read(&adap->chcr_stats.error));\n\tseq_printf(seq, \"Fallback: %10u \\n\",\n\t\t   atomic_read(&adap->chcr_stats.fallback));\n\tseq_printf(seq, \"TLS PDU Tx: %10u\\n\",\n\t\t   atomic_read(&adap->chcr_stats.tls_pdu_tx));\n\tseq_printf(seq, \"TLS PDU Rx: %10u\\n\",\n\t\t   atomic_read(&adap->chcr_stats.tls_pdu_rx));\n\tseq_printf(seq, \"TLS Keys (DDR) Count: %10u\\n\",\n\t\t   atomic_read(&adap->chcr_stats.tls_key));\n#if IS_ENABLED(CONFIG_CHELSIO_IPSEC_INLINE)\n\tseq_puts(seq, \"\\nChelsio Inline IPsec Crypto Accelerator Stats\\n\");\n\tseq_printf(seq, \"IPSec PDU: %10u\\n\",\n\t\t   atomic_read(&adap->ch_ipsec_stats.ipsec_cnt));\n#endif\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n\tseq_puts(seq, \"\\nChelsio KTLS Crypto Accelerator Stats\\n\");\n\tseq_printf(seq, \"Tx TLS offload refcount:          %20u\\n\",\n\t\t   refcount_read(&adap->chcr_ktls.ktls_refcount));\n\tseq_printf(seq, \"Tx records send:                  %20llu\\n\",\n\t\t   atomic64_read(&adap->ch_ktls_stats.ktls_tx_send_records));\n\tseq_printf(seq, \"Tx partial start of records:      %20llu\\n\",\n\t\t   atomic64_read(&adap->ch_ktls_stats.ktls_tx_start_pkts));\n\tseq_printf(seq, \"Tx partial middle of records:     %20llu\\n\",\n\t\t   atomic64_read(&adap->ch_ktls_stats.ktls_tx_middle_pkts));\n\tseq_printf(seq, \"Tx partial end of record:         %20llu\\n\",\n\t\t   atomic64_read(&adap->ch_ktls_stats.ktls_tx_end_pkts));\n\tseq_printf(seq, \"Tx complete records:              %20llu\\n\",\n\t\t   atomic64_read(&adap->ch_ktls_stats.ktls_tx_complete_pkts));\n\tseq_printf(seq, \"TX trim pkts :                    %20llu\\n\",\n\t\t   atomic64_read(&adap->ch_ktls_stats.ktls_tx_trimmed_pkts));\n\tseq_printf(seq, \"TX sw fallback :                  %20llu\\n\",\n\t\t   atomic64_read(&adap->ch_ktls_stats.ktls_tx_fallback));\n\twhile (i < MAX_NPORTS) {\n\t\tktls_port = &adap->ch_ktls_stats.ktls_port[i];\n\t\tseq_printf(seq, \"Port %d\\n\", i);\n\t\tseq_printf(seq, \"Tx connection created:            %20llu\\n\",\n\t\t\t   atomic64_read(&ktls_port->ktls_tx_connection_open));\n\t\tseq_printf(seq, \"Tx connection failed:             %20llu\\n\",\n\t\t\t   atomic64_read(&ktls_port->ktls_tx_connection_fail));\n\t\tseq_printf(seq, \"Tx connection closed:             %20llu\\n\",\n\t\t\t   atomic64_read(&ktls_port->ktls_tx_connection_close));\n\t\ti++;\n\t}\n#endif\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(chcr_stats);\n\n#define PRINT_ADAP_STATS(string, value) \\\n\tseq_printf(seq, \"%-25s %-20llu\\n\", (string), \\\n\t\t   (unsigned long long)(value))\n\n#define PRINT_CH_STATS(string, value) \\\ndo { \\\n\tseq_printf(seq, \"%-25s \", (string)); \\\n\tfor (i = 0; i < adap->params.arch.nchan; i++) \\\n\t\tseq_printf(seq, \"%-20llu \", \\\n\t\t\t   (unsigned long long)stats.value[i]); \\\n\tseq_printf(seq, \"\\n\"); \\\n} while (0)\n\n#define PRINT_CH_STATS2(string, value) \\\ndo { \\\n\tseq_printf(seq, \"%-25s \", (string)); \\\n\tfor (i = 0; i < adap->params.arch.nchan; i++) \\\n\t\tseq_printf(seq, \"%-20llu \", \\\n\t\t\t   (unsigned long long)stats[i].value); \\\n\tseq_printf(seq, \"\\n\"); \\\n} while (0)\n\nstatic void show_tcp_stats(struct seq_file *seq)\n{\n\tstruct adapter *adap = seq->private;\n\tstruct tp_tcp_stats v4, v6;\n\n\tspin_lock(&adap->stats_lock);\n\tt4_tp_get_tcp_stats(adap, &v4, &v6, false);\n\tspin_unlock(&adap->stats_lock);\n\n\tPRINT_ADAP_STATS(\"tcp_ipv4_out_rsts:\", v4.tcp_out_rsts);\n\tPRINT_ADAP_STATS(\"tcp_ipv4_in_segs:\", v4.tcp_in_segs);\n\tPRINT_ADAP_STATS(\"tcp_ipv4_out_segs:\", v4.tcp_out_segs);\n\tPRINT_ADAP_STATS(\"tcp_ipv4_retrans_segs:\", v4.tcp_retrans_segs);\n\tPRINT_ADAP_STATS(\"tcp_ipv6_out_rsts:\", v6.tcp_out_rsts);\n\tPRINT_ADAP_STATS(\"tcp_ipv6_in_segs:\", v6.tcp_in_segs);\n\tPRINT_ADAP_STATS(\"tcp_ipv6_out_segs:\", v6.tcp_out_segs);\n\tPRINT_ADAP_STATS(\"tcp_ipv6_retrans_segs:\", v6.tcp_retrans_segs);\n}\n\nstatic void show_ddp_stats(struct seq_file *seq)\n{\n\tstruct adapter *adap = seq->private;\n\tstruct tp_usm_stats stats;\n\n\tspin_lock(&adap->stats_lock);\n\tt4_get_usm_stats(adap, &stats, false);\n\tspin_unlock(&adap->stats_lock);\n\n\tPRINT_ADAP_STATS(\"usm_ddp_frames:\", stats.frames);\n\tPRINT_ADAP_STATS(\"usm_ddp_octets:\", stats.octets);\n\tPRINT_ADAP_STATS(\"usm_ddp_drops:\", stats.drops);\n}\n\nstatic void show_rdma_stats(struct seq_file *seq)\n{\n\tstruct adapter *adap = seq->private;\n\tstruct tp_rdma_stats stats;\n\n\tspin_lock(&adap->stats_lock);\n\tt4_tp_get_rdma_stats(adap, &stats, false);\n\tspin_unlock(&adap->stats_lock);\n\n\tPRINT_ADAP_STATS(\"rdma_no_rqe_mod_defer:\", stats.rqe_dfr_mod);\n\tPRINT_ADAP_STATS(\"rdma_no_rqe_pkt_defer:\", stats.rqe_dfr_pkt);\n}\n\nstatic void show_tp_err_adapter_stats(struct seq_file *seq)\n{\n\tstruct adapter *adap = seq->private;\n\tstruct tp_err_stats stats;\n\n\tspin_lock(&adap->stats_lock);\n\tt4_tp_get_err_stats(adap, &stats, false);\n\tspin_unlock(&adap->stats_lock);\n\n\tPRINT_ADAP_STATS(\"tp_err_ofld_no_neigh:\", stats.ofld_no_neigh);\n\tPRINT_ADAP_STATS(\"tp_err_ofld_cong_defer:\", stats.ofld_cong_defer);\n}\n\nstatic void show_cpl_stats(struct seq_file *seq)\n{\n\tstruct adapter *adap = seq->private;\n\tstruct tp_cpl_stats stats;\n\tu8 i;\n\n\tspin_lock(&adap->stats_lock);\n\tt4_tp_get_cpl_stats(adap, &stats, false);\n\tspin_unlock(&adap->stats_lock);\n\n\tPRINT_CH_STATS(\"tp_cpl_requests:\", req);\n\tPRINT_CH_STATS(\"tp_cpl_responses:\", rsp);\n}\n\nstatic void show_tp_err_channel_stats(struct seq_file *seq)\n{\n\tstruct adapter *adap = seq->private;\n\tstruct tp_err_stats stats;\n\tu8 i;\n\n\tspin_lock(&adap->stats_lock);\n\tt4_tp_get_err_stats(adap, &stats, false);\n\tspin_unlock(&adap->stats_lock);\n\n\tPRINT_CH_STATS(\"tp_mac_in_errs:\", mac_in_errs);\n\tPRINT_CH_STATS(\"tp_hdr_in_errs:\", hdr_in_errs);\n\tPRINT_CH_STATS(\"tp_tcp_in_errs:\", tcp_in_errs);\n\tPRINT_CH_STATS(\"tp_tcp6_in_errs:\", tcp6_in_errs);\n\tPRINT_CH_STATS(\"tp_tnl_cong_drops:\", tnl_cong_drops);\n\tPRINT_CH_STATS(\"tp_tnl_tx_drops:\", tnl_tx_drops);\n\tPRINT_CH_STATS(\"tp_ofld_vlan_drops:\", ofld_vlan_drops);\n\tPRINT_CH_STATS(\"tp_ofld_chan_drops:\", ofld_chan_drops);\n}\n\nstatic void show_fcoe_stats(struct seq_file *seq)\n{\n\tstruct adapter *adap = seq->private;\n\tstruct tp_fcoe_stats stats[NCHAN];\n\tu8 i;\n\n\tspin_lock(&adap->stats_lock);\n\tfor (i = 0; i < adap->params.arch.nchan; i++)\n\t\tt4_get_fcoe_stats(adap, i, &stats[i], false);\n\tspin_unlock(&adap->stats_lock);\n\n\tPRINT_CH_STATS2(\"fcoe_octets_ddp\", octets_ddp);\n\tPRINT_CH_STATS2(\"fcoe_frames_ddp\", frames_ddp);\n\tPRINT_CH_STATS2(\"fcoe_frames_drop\", frames_drop);\n}\n\n#undef PRINT_CH_STATS2\n#undef PRINT_CH_STATS\n#undef PRINT_ADAP_STATS\n\nstatic int tp_stats_show(struct seq_file *seq, void *v)\n{\n\tstruct adapter *adap = seq->private;\n\n\tseq_puts(seq, \"\\n--------Adapter Stats--------\\n\");\n\tshow_tcp_stats(seq);\n\tshow_ddp_stats(seq);\n\tshow_rdma_stats(seq);\n\tshow_tp_err_adapter_stats(seq);\n\n\tseq_puts(seq, \"\\n-------- Channel Stats --------\\n\");\n\tif (adap->params.arch.nchan == NCHAN)\n\t\tseq_printf(seq, \"%-25s %-20s %-20s %-20s %-20s\\n\",\n\t\t\t   \" \", \"channel 0\", \"channel 1\",\n\t\t\t   \"channel 2\", \"channel 3\");\n\telse\n\t\tseq_printf(seq, \"%-25s %-20s %-20s\\n\",\n\t\t\t   \" \", \"channel 0\", \"channel 1\");\n\tshow_cpl_stats(seq);\n\tshow_tp_err_channel_stats(seq);\n\tshow_fcoe_stats(seq);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(tp_stats);\n\n \nvoid add_debugfs_files(struct adapter *adap,\n\t\t       struct t4_debugfs_entry *files,\n\t\t       unsigned int nfiles)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < nfiles; i++)\n\t\tdebugfs_create_file(files[i].name, files[i].mode,\n\t\t\t\t    adap->debugfs_root,\n\t\t\t\t    (void *)adap + files[i].data,\n\t\t\t\t    files[i].ops);\n}\n\nint t4_setup_debugfs(struct adapter *adap)\n{\n\tint i;\n\tu32 size = 0;\n\n\tstatic struct t4_debugfs_entry t4_debugfs_files[] = {\n\t\t{ \"cim_la\", &cim_la_fops, 0400, 0 },\n\t\t{ \"cim_pif_la\", &cim_pif_la_fops, 0400, 0 },\n\t\t{ \"cim_ma_la\", &cim_ma_la_fops, 0400, 0 },\n\t\t{ \"cim_qcfg\", &cim_qcfg_fops, 0400, 0 },\n\t\t{ \"clk\", &clk_fops, 0400, 0 },\n\t\t{ \"devlog\", &devlog_fops, 0400, 0 },\n\t\t{ \"mboxlog\", &mboxlog_fops, 0400, 0 },\n\t\t{ \"mbox0\", &mbox_debugfs_fops, 0600, 0 },\n\t\t{ \"mbox1\", &mbox_debugfs_fops, 0600, 1 },\n\t\t{ \"mbox2\", &mbox_debugfs_fops, 0600, 2 },\n\t\t{ \"mbox3\", &mbox_debugfs_fops, 0600, 3 },\n\t\t{ \"mbox4\", &mbox_debugfs_fops, 0600, 4 },\n\t\t{ \"mbox5\", &mbox_debugfs_fops, 0600, 5 },\n\t\t{ \"mbox6\", &mbox_debugfs_fops, 0600, 6 },\n\t\t{ \"mbox7\", &mbox_debugfs_fops, 0600, 7 },\n\t\t{ \"trace0\", &mps_trc_debugfs_fops, 0600, 0 },\n\t\t{ \"trace1\", &mps_trc_debugfs_fops, 0600, 1 },\n\t\t{ \"trace2\", &mps_trc_debugfs_fops, 0600, 2 },\n\t\t{ \"trace3\", &mps_trc_debugfs_fops, 0600, 3 },\n\t\t{ \"l2t\", &t4_l2t_fops, 0400, 0},\n\t\t{ \"mps_tcam\", &mps_tcam_debugfs_fops, 0400, 0 },\n\t\t{ \"rss\", &rss_debugfs_fops, 0400, 0 },\n\t\t{ \"rss_config\", &rss_config_fops, 0400, 0 },\n\t\t{ \"rss_key\", &rss_key_debugfs_fops, 0400, 0 },\n\t\t{ \"rss_pf_config\", &rss_pf_config_debugfs_fops, 0400, 0 },\n\t\t{ \"rss_vf_config\", &rss_vf_config_debugfs_fops, 0400, 0 },\n\t\t{ \"resources\", &resources_fops, 0400, 0 },\n#ifdef CONFIG_CHELSIO_T4_DCB\n\t\t{ \"dcb_info\", &dcb_info_debugfs_fops, 0400, 0 },\n#endif\n\t\t{ \"sge_qinfo\", &sge_qinfo_debugfs_fops, 0400, 0 },\n\t\t{ \"ibq_tp0\",  &cim_ibq_fops, 0400, 0 },\n\t\t{ \"ibq_tp1\",  &cim_ibq_fops, 0400, 1 },\n\t\t{ \"ibq_ulp\",  &cim_ibq_fops, 0400, 2 },\n\t\t{ \"ibq_sge0\", &cim_ibq_fops, 0400, 3 },\n\t\t{ \"ibq_sge1\", &cim_ibq_fops, 0400, 4 },\n\t\t{ \"ibq_ncsi\", &cim_ibq_fops, 0400, 5 },\n\t\t{ \"obq_ulp0\", &cim_obq_fops, 0400, 0 },\n\t\t{ \"obq_ulp1\", &cim_obq_fops, 0400, 1 },\n\t\t{ \"obq_ulp2\", &cim_obq_fops, 0400, 2 },\n\t\t{ \"obq_ulp3\", &cim_obq_fops, 0400, 3 },\n\t\t{ \"obq_sge\",  &cim_obq_fops, 0400, 4 },\n\t\t{ \"obq_ncsi\", &cim_obq_fops, 0400, 5 },\n\t\t{ \"tp_la\", &tp_la_fops, 0400, 0 },\n\t\t{ \"ulprx_la\", &ulprx_la_fops, 0400, 0 },\n\t\t{ \"sensors\", &sensors_fops, 0400, 0 },\n\t\t{ \"pm_stats\", &pm_stats_debugfs_fops, 0400, 0 },\n\t\t{ \"tx_rate\", &tx_rate_fops, 0400, 0 },\n\t\t{ \"cctrl\", &cctrl_tbl_fops, 0400, 0 },\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t{ \"clip_tbl\", &clip_tbl_fops, 0400, 0 },\n#endif\n\t\t{ \"tids\", &tid_info_fops, 0400, 0},\n\t\t{ \"blocked_fl\", &blocked_fl_fops, 0600, 0 },\n\t\t{ \"meminfo\", &meminfo_fops, 0400, 0 },\n\t\t{ \"crypto\", &chcr_stats_fops, 0400, 0 },\n\t\t{ \"tp_stats\", &tp_stats_fops, 0400, 0 },\n\t};\n\n\t \n\tstatic struct t4_debugfs_entry t5_debugfs_files[] = {\n\t\t{ \"obq_sge_rx_q0\", &cim_obq_fops, 0400, 6 },\n\t\t{ \"obq_sge_rx_q1\", &cim_obq_fops, 0400, 7 },\n\t};\n\n\tadd_debugfs_files(adap,\n\t\t\t  t4_debugfs_files,\n\t\t\t  ARRAY_SIZE(t4_debugfs_files));\n\tif (!is_t4(adap->params.chip))\n\t\tadd_debugfs_files(adap,\n\t\t\t\t  t5_debugfs_files,\n\t\t\t\t  ARRAY_SIZE(t5_debugfs_files));\n\n\ti = t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A);\n\tif (i & EDRAM0_ENABLE_F) {\n\t\tsize = t4_read_reg(adap, MA_EDRAM0_BAR_A);\n\t\tadd_debugfs_mem(adap, \"edc0\", MEM_EDC0, EDRAM0_SIZE_G(size));\n\t}\n\tif (i & EDRAM1_ENABLE_F) {\n\t\tsize = t4_read_reg(adap, MA_EDRAM1_BAR_A);\n\t\tadd_debugfs_mem(adap, \"edc1\", MEM_EDC1, EDRAM1_SIZE_G(size));\n\t}\n\tif (is_t5(adap->params.chip)) {\n\t\tif (i & EXT_MEM0_ENABLE_F) {\n\t\t\tsize = t4_read_reg(adap, MA_EXT_MEMORY0_BAR_A);\n\t\t\tadd_debugfs_mem(adap, \"mc0\", MEM_MC0,\n\t\t\t\t\tEXT_MEM0_SIZE_G(size));\n\t\t}\n\t\tif (i & EXT_MEM1_ENABLE_F) {\n\t\t\tsize = t4_read_reg(adap, MA_EXT_MEMORY1_BAR_A);\n\t\t\tadd_debugfs_mem(adap, \"mc1\", MEM_MC1,\n\t\t\t\t\tEXT_MEM1_SIZE_G(size));\n\t\t}\n\t} else {\n\t\tif (i & EXT_MEM_ENABLE_F) {\n\t\t\tsize = t4_read_reg(adap, MA_EXT_MEMORY_BAR_A);\n\t\t\tadd_debugfs_mem(adap, \"mc\", MEM_MC,\n\t\t\t\t\tEXT_MEM_SIZE_G(size));\n\t\t}\n\n\t\tif (i & HMA_MUX_F) {\n\t\t\tsize = t4_read_reg(adap, MA_EXT_MEMORY1_BAR_A);\n\t\t\tadd_debugfs_mem(adap, \"hma\", MEM_HMA,\n\t\t\t\t\tEXT_MEM1_SIZE_G(size));\n\t\t}\n\t}\n\n\tdebugfs_create_file_size(\"flash\", 0400, adap->debugfs_root, adap,\n\t\t\t\t &flash_debugfs_fops, adap->params.sf_size);\n\tdebugfs_create_bool(\"use_backdoor\", 0600,\n\t\t\t    adap->debugfs_root, &adap->use_bd);\n\tdebugfs_create_bool(\"trace_rss\", 0600,\n\t\t\t    adap->debugfs_root, &adap->trace_rss);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}