{
  "module_name": "t4_hw.c",
  "hash_id": "38c85a5d11454ef9fe201f9615203c0d2876327630a8b2ef5a59f046f8b6d3d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include \"cxgb4.h\"\n#include \"t4_regs.h\"\n#include \"t4_values.h\"\n#include \"t4fw_api.h\"\n#include \"t4fw_version.h\"\n\n \nstatic int t4_wait_op_done_val(struct adapter *adapter, int reg, u32 mask,\n\t\t\t       int polarity, int attempts, int delay, u32 *valp)\n{\n\twhile (1) {\n\t\tu32 val = t4_read_reg(adapter, reg);\n\n\t\tif (!!(val & mask) == polarity) {\n\t\t\tif (valp)\n\t\t\t\t*valp = val;\n\t\t\treturn 0;\n\t\t}\n\t\tif (--attempts == 0)\n\t\t\treturn -EAGAIN;\n\t\tif (delay)\n\t\t\tudelay(delay);\n\t}\n}\n\nstatic inline int t4_wait_op_done(struct adapter *adapter, int reg, u32 mask,\n\t\t\t\t  int polarity, int attempts, int delay)\n{\n\treturn t4_wait_op_done_val(adapter, reg, mask, polarity, attempts,\n\t\t\t\t   delay, NULL);\n}\n\n \nvoid t4_set_reg_field(struct adapter *adapter, unsigned int addr, u32 mask,\n\t\t      u32 val)\n{\n\tu32 v = t4_read_reg(adapter, addr) & ~mask;\n\n\tt4_write_reg(adapter, addr, v | val);\n\t(void) t4_read_reg(adapter, addr);       \n}\n\n \nvoid t4_read_indirect(struct adapter *adap, unsigned int addr_reg,\n\t\t\t     unsigned int data_reg, u32 *vals,\n\t\t\t     unsigned int nregs, unsigned int start_idx)\n{\n\twhile (nregs--) {\n\t\tt4_write_reg(adap, addr_reg, start_idx);\n\t\t*vals++ = t4_read_reg(adap, data_reg);\n\t\tstart_idx++;\n\t}\n}\n\n \nvoid t4_write_indirect(struct adapter *adap, unsigned int addr_reg,\n\t\t       unsigned int data_reg, const u32 *vals,\n\t\t       unsigned int nregs, unsigned int start_idx)\n{\n\twhile (nregs--) {\n\t\tt4_write_reg(adap, addr_reg, start_idx++);\n\t\tt4_write_reg(adap, data_reg, *vals++);\n\t}\n}\n\n \nvoid t4_hw_pci_read_cfg4(struct adapter *adap, int reg, u32 *val)\n{\n\tu32 req = FUNCTION_V(adap->pf) | REGISTER_V(reg);\n\n\tif (CHELSIO_CHIP_VERSION(adap->params.chip) <= CHELSIO_T5)\n\t\treq |= ENABLE_F;\n\telse\n\t\treq |= T6_ENABLE_F;\n\n\tif (is_t4(adap->params.chip))\n\t\treq |= LOCALCFG_F;\n\n\tt4_write_reg(adap, PCIE_CFG_SPACE_REQ_A, req);\n\t*val = t4_read_reg(adap, PCIE_CFG_SPACE_DATA_A);\n\n\t \n\tt4_write_reg(adap, PCIE_CFG_SPACE_REQ_A, 0);\n}\n\n \nstatic void t4_report_fw_error(struct adapter *adap)\n{\n\tstatic const char *const reason[] = {\n\t\t\"Crash\",                         \n\t\t\"During Device Preparation\",     \n\t\t\"During Device Configuration\",   \n\t\t\"During Device Initialization\",  \n\t\t\"Unexpected Event\",              \n\t\t\"Insufficient Airflow\",          \n\t\t\"Device Shutdown\",               \n\t\t\"Reserved\",                      \n\t};\n\tu32 pcie_fw;\n\n\tpcie_fw = t4_read_reg(adap, PCIE_FW_A);\n\tif (pcie_fw & PCIE_FW_ERR_F) {\n\t\tdev_err(adap->pdev_dev, \"Firmware reports adapter error: %s\\n\",\n\t\t\treason[PCIE_FW_EVAL_G(pcie_fw)]);\n\t\tadap->flags &= ~CXGB4_FW_OK;\n\t}\n}\n\n \nstatic void get_mbox_rpl(struct adapter *adap, __be64 *rpl, int nflit,\n\t\t\t u32 mbox_addr)\n{\n\tfor ( ; nflit; nflit--, mbox_addr += 8)\n\t\t*rpl++ = cpu_to_be64(t4_read_reg64(adap, mbox_addr));\n}\n\n \nstatic void fw_asrt(struct adapter *adap, u32 mbox_addr)\n{\n\tstruct fw_debug_cmd asrt;\n\n\tget_mbox_rpl(adap, (__be64 *)&asrt, sizeof(asrt) / 8, mbox_addr);\n\tdev_alert(adap->pdev_dev,\n\t\t  \"FW assertion at %.16s:%u, val0 %#x, val1 %#x\\n\",\n\t\t  asrt.u.assert.filename_0_7, be32_to_cpu(asrt.u.assert.line),\n\t\t  be32_to_cpu(asrt.u.assert.x), be32_to_cpu(asrt.u.assert.y));\n}\n\n \nstatic void t4_record_mbox(struct adapter *adapter,\n\t\t\t   const __be64 *cmd, unsigned int size,\n\t\t\t   int access, int execute)\n{\n\tstruct mbox_cmd_log *log = adapter->mbox_log;\n\tstruct mbox_cmd *entry;\n\tint i;\n\n\tentry = mbox_cmd_log_entry(log, log->cursor++);\n\tif (log->cursor == log->size)\n\t\tlog->cursor = 0;\n\n\tfor (i = 0; i < size / 8; i++)\n\t\tentry->cmd[i] = be64_to_cpu(cmd[i]);\n\twhile (i < MBOX_LEN / 8)\n\t\tentry->cmd[i++] = 0;\n\tentry->timestamp = jiffies;\n\tentry->seqno = log->seqno++;\n\tentry->access = access;\n\tentry->execute = execute;\n}\n\n \nint t4_wr_mbox_meat_timeout(struct adapter *adap, int mbox, const void *cmd,\n\t\t\t    int size, void *rpl, bool sleep_ok, int timeout)\n{\n\tstatic const int delay[] = {\n\t\t1, 1, 3, 5, 10, 10, 20, 50, 100, 200\n\t};\n\n\tstruct mbox_list entry;\n\tu16 access = 0;\n\tu16 execute = 0;\n\tu32 v;\n\tu64 res;\n\tint i, ms, delay_idx, ret;\n\tconst __be64 *p = cmd;\n\tu32 data_reg = PF_REG(mbox, CIM_PF_MAILBOX_DATA_A);\n\tu32 ctl_reg = PF_REG(mbox, CIM_PF_MAILBOX_CTRL_A);\n\t__be64 cmd_rpl[MBOX_LEN / 8];\n\tu32 pcie_fw;\n\n\tif ((size & 15) || size > MBOX_LEN)\n\t\treturn -EINVAL;\n\n\t \n\tif (adap->pdev->error_state != pci_channel_io_normal)\n\t\treturn -EIO;\n\n\t \n\tif (timeout < 0) {\n\t\tsleep_ok = false;\n\t\ttimeout = -timeout;\n\t}\n\n\t \n\tspin_lock_bh(&adap->mbox_lock);\n\tlist_add_tail(&entry.list, &adap->mlist.list);\n\tspin_unlock_bh(&adap->mbox_lock);\n\n\tdelay_idx = 0;\n\tms = delay[0];\n\n\tfor (i = 0; ; i += ms) {\n\t\t \n\t\tpcie_fw = t4_read_reg(adap, PCIE_FW_A);\n\t\tif (i > FW_CMD_MAX_TIMEOUT || (pcie_fw & PCIE_FW_ERR_F)) {\n\t\t\tspin_lock_bh(&adap->mbox_lock);\n\t\t\tlist_del(&entry.list);\n\t\t\tspin_unlock_bh(&adap->mbox_lock);\n\t\t\tret = (pcie_fw & PCIE_FW_ERR_F) ? -ENXIO : -EBUSY;\n\t\t\tt4_record_mbox(adap, cmd, size, access, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (list_first_entry(&adap->mlist.list, struct mbox_list,\n\t\t\t\t     list) == &entry)\n\t\t\tbreak;\n\n\t\t \n\t\tif (sleep_ok) {\n\t\t\tms = delay[delay_idx];   \n\t\t\tif (delay_idx < ARRAY_SIZE(delay) - 1)\n\t\t\t\tdelay_idx++;\n\t\t\tmsleep(ms);\n\t\t} else {\n\t\t\tmdelay(ms);\n\t\t}\n\t}\n\n\t \n\tv = MBOWNER_G(t4_read_reg(adap, ctl_reg));\n\tfor (i = 0; v == MBOX_OWNER_NONE && i < 3; i++)\n\t\tv = MBOWNER_G(t4_read_reg(adap, ctl_reg));\n\tif (v != MBOX_OWNER_DRV) {\n\t\tspin_lock_bh(&adap->mbox_lock);\n\t\tlist_del(&entry.list);\n\t\tspin_unlock_bh(&adap->mbox_lock);\n\t\tret = (v == MBOX_OWNER_FW) ? -EBUSY : -ETIMEDOUT;\n\t\tt4_record_mbox(adap, cmd, size, access, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tt4_record_mbox(adap, cmd, size, access, 0);\n\tfor (i = 0; i < size; i += 8)\n\t\tt4_write_reg64(adap, data_reg + i, be64_to_cpu(*p++));\n\n\tt4_write_reg(adap, ctl_reg, MBMSGVALID_F | MBOWNER_V(MBOX_OWNER_FW));\n\tt4_read_reg(adap, ctl_reg);           \n\n\tdelay_idx = 0;\n\tms = delay[0];\n\n\tfor (i = 0;\n\t     !((pcie_fw = t4_read_reg(adap, PCIE_FW_A)) & PCIE_FW_ERR_F) &&\n\t     i < timeout;\n\t     i += ms) {\n\t\tif (sleep_ok) {\n\t\t\tms = delay[delay_idx];   \n\t\t\tif (delay_idx < ARRAY_SIZE(delay) - 1)\n\t\t\t\tdelay_idx++;\n\t\t\tmsleep(ms);\n\t\t} else\n\t\t\tmdelay(ms);\n\n\t\tv = t4_read_reg(adap, ctl_reg);\n\t\tif (MBOWNER_G(v) == MBOX_OWNER_DRV) {\n\t\t\tif (!(v & MBMSGVALID_F)) {\n\t\t\t\tt4_write_reg(adap, ctl_reg, 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tget_mbox_rpl(adap, cmd_rpl, MBOX_LEN / 8, data_reg);\n\t\t\tres = be64_to_cpu(cmd_rpl[0]);\n\n\t\t\tif (FW_CMD_OP_G(res >> 32) == FW_DEBUG_CMD) {\n\t\t\t\tfw_asrt(adap, data_reg);\n\t\t\t\tres = FW_CMD_RETVAL_V(EIO);\n\t\t\t} else if (rpl) {\n\t\t\t\tmemcpy(rpl, cmd_rpl, size);\n\t\t\t}\n\n\t\t\tt4_write_reg(adap, ctl_reg, 0);\n\n\t\t\texecute = i + ms;\n\t\t\tt4_record_mbox(adap, cmd_rpl,\n\t\t\t\t       MBOX_LEN, access, execute);\n\t\t\tspin_lock_bh(&adap->mbox_lock);\n\t\t\tlist_del(&entry.list);\n\t\t\tspin_unlock_bh(&adap->mbox_lock);\n\t\t\treturn -FW_CMD_RETVAL_G((int)res);\n\t\t}\n\t}\n\n\tret = (pcie_fw & PCIE_FW_ERR_F) ? -ENXIO : -ETIMEDOUT;\n\tt4_record_mbox(adap, cmd, size, access, ret);\n\tdev_err(adap->pdev_dev, \"command %#x in mailbox %d timed out\\n\",\n\t\t*(const u8 *)cmd, mbox);\n\tt4_report_fw_error(adap);\n\tspin_lock_bh(&adap->mbox_lock);\n\tlist_del(&entry.list);\n\tspin_unlock_bh(&adap->mbox_lock);\n\tt4_fatal_err(adap);\n\treturn ret;\n}\n\nint t4_wr_mbox_meat(struct adapter *adap, int mbox, const void *cmd, int size,\n\t\t    void *rpl, bool sleep_ok)\n{\n\treturn t4_wr_mbox_meat_timeout(adap, mbox, cmd, size, rpl, sleep_ok,\n\t\t\t\t       FW_CMD_MAX_TIMEOUT);\n}\n\nstatic int t4_edc_err_read(struct adapter *adap, int idx)\n{\n\tu32 edc_ecc_err_addr_reg;\n\tu32 rdata_reg;\n\n\tif (is_t4(adap->params.chip)) {\n\t\tCH_WARN(adap, \"%s: T4 NOT supported.\\n\", __func__);\n\t\treturn 0;\n\t}\n\tif (idx != 0 && idx != 1) {\n\t\tCH_WARN(adap, \"%s: idx %d NOT supported.\\n\", __func__, idx);\n\t\treturn 0;\n\t}\n\n\tedc_ecc_err_addr_reg = EDC_T5_REG(EDC_H_ECC_ERR_ADDR_A, idx);\n\trdata_reg = EDC_T5_REG(EDC_H_BIST_STATUS_RDATA_A, idx);\n\n\tCH_WARN(adap,\n\t\t\"edc%d err addr 0x%x: 0x%x.\\n\",\n\t\tidx, edc_ecc_err_addr_reg,\n\t\tt4_read_reg(adap, edc_ecc_err_addr_reg));\n\tCH_WARN(adap,\n\t\t\"bist: 0x%x, status %llx %llx %llx %llx %llx %llx %llx %llx %llx.\\n\",\n\t\trdata_reg,\n\t\t(unsigned long long)t4_read_reg64(adap, rdata_reg),\n\t\t(unsigned long long)t4_read_reg64(adap, rdata_reg + 8),\n\t\t(unsigned long long)t4_read_reg64(adap, rdata_reg + 16),\n\t\t(unsigned long long)t4_read_reg64(adap, rdata_reg + 24),\n\t\t(unsigned long long)t4_read_reg64(adap, rdata_reg + 32),\n\t\t(unsigned long long)t4_read_reg64(adap, rdata_reg + 40),\n\t\t(unsigned long long)t4_read_reg64(adap, rdata_reg + 48),\n\t\t(unsigned long long)t4_read_reg64(adap, rdata_reg + 56),\n\t\t(unsigned long long)t4_read_reg64(adap, rdata_reg + 64));\n\n\treturn 0;\n}\n\n \nint t4_memory_rw_init(struct adapter *adap, int win, int mtype, u32 *mem_off,\n\t\t      u32 *mem_base, u32 *mem_aperture)\n{\n\tu32 edc_size, mc_size, mem_reg;\n\n\t \n\tedc_size  = EDRAM0_SIZE_G(t4_read_reg(adap, MA_EDRAM0_BAR_A));\n\tif (mtype == MEM_HMA) {\n\t\t*mem_off = 2 * (edc_size * 1024 * 1024);\n\t} else if (mtype != MEM_MC1) {\n\t\t*mem_off = (mtype * (edc_size * 1024 * 1024));\n\t} else {\n\t\tmc_size = EXT_MEM0_SIZE_G(t4_read_reg(adap,\n\t\t\t\t\t\t      MA_EXT_MEMORY0_BAR_A));\n\t\t*mem_off = (MEM_MC0 * edc_size + mc_size) * 1024 * 1024;\n\t}\n\n\t \n\tmem_reg = t4_read_reg(adap,\n\t\t\t      PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_BASE_WIN_A,\n\t\t\t\t\t\t  win));\n\t \n\tif (mem_reg == 0xffffffff)\n\t\treturn -ENXIO;\n\n\t*mem_aperture = 1 << (WINDOW_G(mem_reg) + WINDOW_SHIFT_X);\n\t*mem_base = PCIEOFST_G(mem_reg) << PCIEOFST_SHIFT_X;\n\tif (is_t4(adap->params.chip))\n\t\t*mem_base -= adap->t4_bar0;\n\n\treturn 0;\n}\n\n \nvoid t4_memory_update_win(struct adapter *adap, int win, u32 addr)\n{\n\tt4_write_reg(adap,\n\t\t     PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_OFFSET_A, win),\n\t\t     addr);\n\t \n\tt4_read_reg(adap,\n\t\t    PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_OFFSET_A, win));\n}\n\n \nvoid t4_memory_rw_residual(struct adapter *adap, u32 off, u32 addr, u8 *buf,\n\t\t\t   int dir)\n{\n\tunion {\n\t\tu32 word;\n\t\tchar byte[4];\n\t} last;\n\tunsigned char *bp;\n\tint i;\n\n\tif (dir == T4_MEMORY_READ) {\n\t\tlast.word = le32_to_cpu((__force __le32)\n\t\t\t\t\tt4_read_reg(adap, addr));\n\t\tfor (bp = (unsigned char *)buf, i = off; i < 4; i++)\n\t\t\tbp[i] = last.byte[i];\n\t} else {\n\t\tlast.word = *buf;\n\t\tfor (i = off; i < 4; i++)\n\t\t\tlast.byte[i] = 0;\n\t\tt4_write_reg(adap, addr,\n\t\t\t     (__force u32)cpu_to_le32(last.word));\n\t}\n}\n\n \nint t4_memory_rw(struct adapter *adap, int win, int mtype, u32 addr,\n\t\t u32 len, void *hbuf, int dir)\n{\n\tu32 pos, offset, resid, memoffset;\n\tu32 win_pf, mem_aperture, mem_base;\n\tu32 *buf;\n\tint ret;\n\n\t \n\tif (addr & 0x3 || (uintptr_t)hbuf & 0x3)\n\t\treturn -EINVAL;\n\tbuf = (u32 *)hbuf;\n\n\t \n\tresid = len & 0x3;\n\tlen -= resid;\n\n\tret = t4_memory_rw_init(adap, win, mtype, &memoffset, &mem_base,\n\t\t\t\t&mem_aperture);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\taddr = addr + memoffset;\n\n\twin_pf = is_t4(adap->params.chip) ? 0 : PFNUM_V(adap->pf);\n\n\t \n\tpos = addr & ~(mem_aperture - 1);\n\toffset = addr - pos;\n\n\t \n\tt4_memory_update_win(adap, win, pos | win_pf);\n\n\t \n\twhile (len > 0) {\n\t\tif (dir == T4_MEMORY_READ)\n\t\t\t*buf++ = le32_to_cpu((__force __le32)t4_read_reg(adap,\n\t\t\t\t\t\tmem_base + offset));\n\t\telse\n\t\t\tt4_write_reg(adap, mem_base + offset,\n\t\t\t\t     (__force u32)cpu_to_le32(*buf++));\n\t\toffset += sizeof(__be32);\n\t\tlen -= sizeof(__be32);\n\n\t\t \n\t\tif (offset == mem_aperture) {\n\t\t\tpos += mem_aperture;\n\t\t\toffset = 0;\n\t\t\tt4_memory_update_win(adap, win, pos | win_pf);\n\t\t}\n\t}\n\n\t \n\tif (resid)\n\t\tt4_memory_rw_residual(adap, resid, mem_base + offset,\n\t\t\t\t      (u8 *)buf, dir);\n\n\treturn 0;\n}\n\n \nu32 t4_read_pcie_cfg4(struct adapter *adap, int reg)\n{\n\tu32 val, ldst_addrspace;\n\n\t \n\tstruct fw_ldst_cmd ldst_cmd;\n\tint ret;\n\n\tmemset(&ldst_cmd, 0, sizeof(ldst_cmd));\n\tldst_addrspace = FW_LDST_CMD_ADDRSPACE_V(FW_LDST_ADDRSPC_FUNC_PCIE);\n\tldst_cmd.op_to_addrspace = cpu_to_be32(FW_CMD_OP_V(FW_LDST_CMD) |\n\t\t\t\t\t       FW_CMD_REQUEST_F |\n\t\t\t\t\t       FW_CMD_READ_F |\n\t\t\t\t\t       ldst_addrspace);\n\tldst_cmd.cycles_to_len16 = cpu_to_be32(FW_LEN16(ldst_cmd));\n\tldst_cmd.u.pcie.select_naccess = FW_LDST_CMD_NACCESS_V(1);\n\tldst_cmd.u.pcie.ctrl_to_fn =\n\t\t(FW_LDST_CMD_LC_F | FW_LDST_CMD_FN_V(adap->pf));\n\tldst_cmd.u.pcie.r = reg;\n\n\t \n\tret = t4_wr_mbox(adap, adap->mbox, &ldst_cmd, sizeof(ldst_cmd),\n\t\t\t &ldst_cmd);\n\tif (ret == 0)\n\t\tval = be32_to_cpu(ldst_cmd.u.pcie.data[0]);\n\telse\n\t\t \n\t\tt4_hw_pci_read_cfg4(adap, reg, &val);\n\treturn val;\n}\n\n \nstatic u32 t4_get_window(struct adapter *adap, u32 pci_base, u64 pci_mask,\n\t\t\t u32 memwin_base)\n{\n\tu32 ret;\n\n\tif (is_t4(adap->params.chip)) {\n\t\tu32 bar0;\n\n\t\t \n\t\tbar0 = t4_read_pcie_cfg4(adap, pci_base);\n\t\tbar0 &= pci_mask;\n\t\tadap->t4_bar0 = bar0;\n\n\t\tret = bar0 + memwin_base;\n\t} else {\n\t\t \n\t\tret = memwin_base;\n\t}\n\treturn ret;\n}\n\n \nu32 t4_get_util_window(struct adapter *adap)\n{\n\treturn t4_get_window(adap, PCI_BASE_ADDRESS_0,\n\t\t\t     PCI_BASE_ADDRESS_MEM_MASK, MEMWIN0_BASE);\n}\n\n \nvoid t4_setup_memwin(struct adapter *adap, u32 memwin_base, u32 window)\n{\n\tt4_write_reg(adap,\n\t\t     PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_BASE_WIN_A, window),\n\t\t     memwin_base | BIR_V(0) |\n\t\t     WINDOW_V(ilog2(MEMWIN0_APERTURE) - WINDOW_SHIFT_X));\n\tt4_read_reg(adap,\n\t\t    PCIE_MEM_ACCESS_REG(PCIE_MEM_ACCESS_BASE_WIN_A, window));\n}\n\n \nunsigned int t4_get_regs_len(struct adapter *adapter)\n{\n\tunsigned int chip_version = CHELSIO_CHIP_VERSION(adapter->params.chip);\n\n\tswitch (chip_version) {\n\tcase CHELSIO_T4:\n\t\treturn T4_REGMAP_SIZE;\n\n\tcase CHELSIO_T5:\n\tcase CHELSIO_T6:\n\t\treturn T5_REGMAP_SIZE;\n\t}\n\n\tdev_err(adapter->pdev_dev,\n\t\t\"Unsupported chip version %d\\n\", chip_version);\n\treturn 0;\n}\n\n \nvoid t4_get_regs(struct adapter *adap, void *buf, size_t buf_size)\n{\n\tstatic const unsigned int t4_reg_ranges[] = {\n\t\t0x1008, 0x1108,\n\t\t0x1180, 0x1184,\n\t\t0x1190, 0x1194,\n\t\t0x11a0, 0x11a4,\n\t\t0x11b0, 0x11b4,\n\t\t0x11fc, 0x123c,\n\t\t0x1300, 0x173c,\n\t\t0x1800, 0x18fc,\n\t\t0x3000, 0x30d8,\n\t\t0x30e0, 0x30e4,\n\t\t0x30ec, 0x5910,\n\t\t0x5920, 0x5924,\n\t\t0x5960, 0x5960,\n\t\t0x5968, 0x5968,\n\t\t0x5970, 0x5970,\n\t\t0x5978, 0x5978,\n\t\t0x5980, 0x5980,\n\t\t0x5988, 0x5988,\n\t\t0x5990, 0x5990,\n\t\t0x5998, 0x5998,\n\t\t0x59a0, 0x59d4,\n\t\t0x5a00, 0x5ae0,\n\t\t0x5ae8, 0x5ae8,\n\t\t0x5af0, 0x5af0,\n\t\t0x5af8, 0x5af8,\n\t\t0x6000, 0x6098,\n\t\t0x6100, 0x6150,\n\t\t0x6200, 0x6208,\n\t\t0x6240, 0x6248,\n\t\t0x6280, 0x62b0,\n\t\t0x62c0, 0x6338,\n\t\t0x6370, 0x638c,\n\t\t0x6400, 0x643c,\n\t\t0x6500, 0x6524,\n\t\t0x6a00, 0x6a04,\n\t\t0x6a14, 0x6a38,\n\t\t0x6a60, 0x6a70,\n\t\t0x6a78, 0x6a78,\n\t\t0x6b00, 0x6b0c,\n\t\t0x6b1c, 0x6b84,\n\t\t0x6bf0, 0x6bf8,\n\t\t0x6c00, 0x6c0c,\n\t\t0x6c1c, 0x6c84,\n\t\t0x6cf0, 0x6cf8,\n\t\t0x6d00, 0x6d0c,\n\t\t0x6d1c, 0x6d84,\n\t\t0x6df0, 0x6df8,\n\t\t0x6e00, 0x6e0c,\n\t\t0x6e1c, 0x6e84,\n\t\t0x6ef0, 0x6ef8,\n\t\t0x6f00, 0x6f0c,\n\t\t0x6f1c, 0x6f84,\n\t\t0x6ff0, 0x6ff8,\n\t\t0x7000, 0x700c,\n\t\t0x701c, 0x7084,\n\t\t0x70f0, 0x70f8,\n\t\t0x7100, 0x710c,\n\t\t0x711c, 0x7184,\n\t\t0x71f0, 0x71f8,\n\t\t0x7200, 0x720c,\n\t\t0x721c, 0x7284,\n\t\t0x72f0, 0x72f8,\n\t\t0x7300, 0x730c,\n\t\t0x731c, 0x7384,\n\t\t0x73f0, 0x73f8,\n\t\t0x7400, 0x7450,\n\t\t0x7500, 0x7530,\n\t\t0x7600, 0x760c,\n\t\t0x7614, 0x761c,\n\t\t0x7680, 0x76cc,\n\t\t0x7700, 0x7798,\n\t\t0x77c0, 0x77fc,\n\t\t0x7900, 0x79fc,\n\t\t0x7b00, 0x7b58,\n\t\t0x7b60, 0x7b84,\n\t\t0x7b8c, 0x7c38,\n\t\t0x7d00, 0x7d38,\n\t\t0x7d40, 0x7d80,\n\t\t0x7d8c, 0x7ddc,\n\t\t0x7de4, 0x7e04,\n\t\t0x7e10, 0x7e1c,\n\t\t0x7e24, 0x7e38,\n\t\t0x7e40, 0x7e44,\n\t\t0x7e4c, 0x7e78,\n\t\t0x7e80, 0x7ea4,\n\t\t0x7eac, 0x7edc,\n\t\t0x7ee8, 0x7efc,\n\t\t0x8dc0, 0x8e04,\n\t\t0x8e10, 0x8e1c,\n\t\t0x8e30, 0x8e78,\n\t\t0x8ea0, 0x8eb8,\n\t\t0x8ec0, 0x8f6c,\n\t\t0x8fc0, 0x9008,\n\t\t0x9010, 0x9058,\n\t\t0x9060, 0x9060,\n\t\t0x9068, 0x9074,\n\t\t0x90fc, 0x90fc,\n\t\t0x9400, 0x9408,\n\t\t0x9410, 0x9458,\n\t\t0x9600, 0x9600,\n\t\t0x9608, 0x9638,\n\t\t0x9640, 0x96bc,\n\t\t0x9800, 0x9808,\n\t\t0x9820, 0x983c,\n\t\t0x9850, 0x9864,\n\t\t0x9c00, 0x9c6c,\n\t\t0x9c80, 0x9cec,\n\t\t0x9d00, 0x9d6c,\n\t\t0x9d80, 0x9dec,\n\t\t0x9e00, 0x9e6c,\n\t\t0x9e80, 0x9eec,\n\t\t0x9f00, 0x9f6c,\n\t\t0x9f80, 0x9fec,\n\t\t0xd004, 0xd004,\n\t\t0xd010, 0xd03c,\n\t\t0xdfc0, 0xdfe0,\n\t\t0xe000, 0xea7c,\n\t\t0xf000, 0x11110,\n\t\t0x11118, 0x11190,\n\t\t0x19040, 0x1906c,\n\t\t0x19078, 0x19080,\n\t\t0x1908c, 0x190e4,\n\t\t0x190f0, 0x190f8,\n\t\t0x19100, 0x19110,\n\t\t0x19120, 0x19124,\n\t\t0x19150, 0x19194,\n\t\t0x1919c, 0x191b0,\n\t\t0x191d0, 0x191e8,\n\t\t0x19238, 0x1924c,\n\t\t0x193f8, 0x1943c,\n\t\t0x1944c, 0x19474,\n\t\t0x19490, 0x194e0,\n\t\t0x194f0, 0x194f8,\n\t\t0x19800, 0x19c08,\n\t\t0x19c10, 0x19c90,\n\t\t0x19ca0, 0x19ce4,\n\t\t0x19cf0, 0x19d40,\n\t\t0x19d50, 0x19d94,\n\t\t0x19da0, 0x19de8,\n\t\t0x19df0, 0x19e40,\n\t\t0x19e50, 0x19e90,\n\t\t0x19ea0, 0x19f4c,\n\t\t0x1a000, 0x1a004,\n\t\t0x1a010, 0x1a06c,\n\t\t0x1a0b0, 0x1a0e4,\n\t\t0x1a0ec, 0x1a0f4,\n\t\t0x1a100, 0x1a108,\n\t\t0x1a114, 0x1a120,\n\t\t0x1a128, 0x1a130,\n\t\t0x1a138, 0x1a138,\n\t\t0x1a190, 0x1a1c4,\n\t\t0x1a1fc, 0x1a1fc,\n\t\t0x1e040, 0x1e04c,\n\t\t0x1e284, 0x1e28c,\n\t\t0x1e2c0, 0x1e2c0,\n\t\t0x1e2e0, 0x1e2e0,\n\t\t0x1e300, 0x1e384,\n\t\t0x1e3c0, 0x1e3c8,\n\t\t0x1e440, 0x1e44c,\n\t\t0x1e684, 0x1e68c,\n\t\t0x1e6c0, 0x1e6c0,\n\t\t0x1e6e0, 0x1e6e0,\n\t\t0x1e700, 0x1e784,\n\t\t0x1e7c0, 0x1e7c8,\n\t\t0x1e840, 0x1e84c,\n\t\t0x1ea84, 0x1ea8c,\n\t\t0x1eac0, 0x1eac0,\n\t\t0x1eae0, 0x1eae0,\n\t\t0x1eb00, 0x1eb84,\n\t\t0x1ebc0, 0x1ebc8,\n\t\t0x1ec40, 0x1ec4c,\n\t\t0x1ee84, 0x1ee8c,\n\t\t0x1eec0, 0x1eec0,\n\t\t0x1eee0, 0x1eee0,\n\t\t0x1ef00, 0x1ef84,\n\t\t0x1efc0, 0x1efc8,\n\t\t0x1f040, 0x1f04c,\n\t\t0x1f284, 0x1f28c,\n\t\t0x1f2c0, 0x1f2c0,\n\t\t0x1f2e0, 0x1f2e0,\n\t\t0x1f300, 0x1f384,\n\t\t0x1f3c0, 0x1f3c8,\n\t\t0x1f440, 0x1f44c,\n\t\t0x1f684, 0x1f68c,\n\t\t0x1f6c0, 0x1f6c0,\n\t\t0x1f6e0, 0x1f6e0,\n\t\t0x1f700, 0x1f784,\n\t\t0x1f7c0, 0x1f7c8,\n\t\t0x1f840, 0x1f84c,\n\t\t0x1fa84, 0x1fa8c,\n\t\t0x1fac0, 0x1fac0,\n\t\t0x1fae0, 0x1fae0,\n\t\t0x1fb00, 0x1fb84,\n\t\t0x1fbc0, 0x1fbc8,\n\t\t0x1fc40, 0x1fc4c,\n\t\t0x1fe84, 0x1fe8c,\n\t\t0x1fec0, 0x1fec0,\n\t\t0x1fee0, 0x1fee0,\n\t\t0x1ff00, 0x1ff84,\n\t\t0x1ffc0, 0x1ffc8,\n\t\t0x20000, 0x2002c,\n\t\t0x20100, 0x2013c,\n\t\t0x20190, 0x201a0,\n\t\t0x201a8, 0x201b8,\n\t\t0x201c4, 0x201c8,\n\t\t0x20200, 0x20318,\n\t\t0x20400, 0x204b4,\n\t\t0x204c0, 0x20528,\n\t\t0x20540, 0x20614,\n\t\t0x21000, 0x21040,\n\t\t0x2104c, 0x21060,\n\t\t0x210c0, 0x210ec,\n\t\t0x21200, 0x21268,\n\t\t0x21270, 0x21284,\n\t\t0x212fc, 0x21388,\n\t\t0x21400, 0x21404,\n\t\t0x21500, 0x21500,\n\t\t0x21510, 0x21518,\n\t\t0x2152c, 0x21530,\n\t\t0x2153c, 0x2153c,\n\t\t0x21550, 0x21554,\n\t\t0x21600, 0x21600,\n\t\t0x21608, 0x2161c,\n\t\t0x21624, 0x21628,\n\t\t0x21630, 0x21634,\n\t\t0x2163c, 0x2163c,\n\t\t0x21700, 0x2171c,\n\t\t0x21780, 0x2178c,\n\t\t0x21800, 0x21818,\n\t\t0x21820, 0x21828,\n\t\t0x21830, 0x21848,\n\t\t0x21850, 0x21854,\n\t\t0x21860, 0x21868,\n\t\t0x21870, 0x21870,\n\t\t0x21878, 0x21898,\n\t\t0x218a0, 0x218a8,\n\t\t0x218b0, 0x218c8,\n\t\t0x218d0, 0x218d4,\n\t\t0x218e0, 0x218e8,\n\t\t0x218f0, 0x218f0,\n\t\t0x218f8, 0x21a18,\n\t\t0x21a20, 0x21a28,\n\t\t0x21a30, 0x21a48,\n\t\t0x21a50, 0x21a54,\n\t\t0x21a60, 0x21a68,\n\t\t0x21a70, 0x21a70,\n\t\t0x21a78, 0x21a98,\n\t\t0x21aa0, 0x21aa8,\n\t\t0x21ab0, 0x21ac8,\n\t\t0x21ad0, 0x21ad4,\n\t\t0x21ae0, 0x21ae8,\n\t\t0x21af0, 0x21af0,\n\t\t0x21af8, 0x21c18,\n\t\t0x21c20, 0x21c20,\n\t\t0x21c28, 0x21c30,\n\t\t0x21c38, 0x21c38,\n\t\t0x21c80, 0x21c98,\n\t\t0x21ca0, 0x21ca8,\n\t\t0x21cb0, 0x21cc8,\n\t\t0x21cd0, 0x21cd4,\n\t\t0x21ce0, 0x21ce8,\n\t\t0x21cf0, 0x21cf0,\n\t\t0x21cf8, 0x21d7c,\n\t\t0x21e00, 0x21e04,\n\t\t0x22000, 0x2202c,\n\t\t0x22100, 0x2213c,\n\t\t0x22190, 0x221a0,\n\t\t0x221a8, 0x221b8,\n\t\t0x221c4, 0x221c8,\n\t\t0x22200, 0x22318,\n\t\t0x22400, 0x224b4,\n\t\t0x224c0, 0x22528,\n\t\t0x22540, 0x22614,\n\t\t0x23000, 0x23040,\n\t\t0x2304c, 0x23060,\n\t\t0x230c0, 0x230ec,\n\t\t0x23200, 0x23268,\n\t\t0x23270, 0x23284,\n\t\t0x232fc, 0x23388,\n\t\t0x23400, 0x23404,\n\t\t0x23500, 0x23500,\n\t\t0x23510, 0x23518,\n\t\t0x2352c, 0x23530,\n\t\t0x2353c, 0x2353c,\n\t\t0x23550, 0x23554,\n\t\t0x23600, 0x23600,\n\t\t0x23608, 0x2361c,\n\t\t0x23624, 0x23628,\n\t\t0x23630, 0x23634,\n\t\t0x2363c, 0x2363c,\n\t\t0x23700, 0x2371c,\n\t\t0x23780, 0x2378c,\n\t\t0x23800, 0x23818,\n\t\t0x23820, 0x23828,\n\t\t0x23830, 0x23848,\n\t\t0x23850, 0x23854,\n\t\t0x23860, 0x23868,\n\t\t0x23870, 0x23870,\n\t\t0x23878, 0x23898,\n\t\t0x238a0, 0x238a8,\n\t\t0x238b0, 0x238c8,\n\t\t0x238d0, 0x238d4,\n\t\t0x238e0, 0x238e8,\n\t\t0x238f0, 0x238f0,\n\t\t0x238f8, 0x23a18,\n\t\t0x23a20, 0x23a28,\n\t\t0x23a30, 0x23a48,\n\t\t0x23a50, 0x23a54,\n\t\t0x23a60, 0x23a68,\n\t\t0x23a70, 0x23a70,\n\t\t0x23a78, 0x23a98,\n\t\t0x23aa0, 0x23aa8,\n\t\t0x23ab0, 0x23ac8,\n\t\t0x23ad0, 0x23ad4,\n\t\t0x23ae0, 0x23ae8,\n\t\t0x23af0, 0x23af0,\n\t\t0x23af8, 0x23c18,\n\t\t0x23c20, 0x23c20,\n\t\t0x23c28, 0x23c30,\n\t\t0x23c38, 0x23c38,\n\t\t0x23c80, 0x23c98,\n\t\t0x23ca0, 0x23ca8,\n\t\t0x23cb0, 0x23cc8,\n\t\t0x23cd0, 0x23cd4,\n\t\t0x23ce0, 0x23ce8,\n\t\t0x23cf0, 0x23cf0,\n\t\t0x23cf8, 0x23d7c,\n\t\t0x23e00, 0x23e04,\n\t\t0x24000, 0x2402c,\n\t\t0x24100, 0x2413c,\n\t\t0x24190, 0x241a0,\n\t\t0x241a8, 0x241b8,\n\t\t0x241c4, 0x241c8,\n\t\t0x24200, 0x24318,\n\t\t0x24400, 0x244b4,\n\t\t0x244c0, 0x24528,\n\t\t0x24540, 0x24614,\n\t\t0x25000, 0x25040,\n\t\t0x2504c, 0x25060,\n\t\t0x250c0, 0x250ec,\n\t\t0x25200, 0x25268,\n\t\t0x25270, 0x25284,\n\t\t0x252fc, 0x25388,\n\t\t0x25400, 0x25404,\n\t\t0x25500, 0x25500,\n\t\t0x25510, 0x25518,\n\t\t0x2552c, 0x25530,\n\t\t0x2553c, 0x2553c,\n\t\t0x25550, 0x25554,\n\t\t0x25600, 0x25600,\n\t\t0x25608, 0x2561c,\n\t\t0x25624, 0x25628,\n\t\t0x25630, 0x25634,\n\t\t0x2563c, 0x2563c,\n\t\t0x25700, 0x2571c,\n\t\t0x25780, 0x2578c,\n\t\t0x25800, 0x25818,\n\t\t0x25820, 0x25828,\n\t\t0x25830, 0x25848,\n\t\t0x25850, 0x25854,\n\t\t0x25860, 0x25868,\n\t\t0x25870, 0x25870,\n\t\t0x25878, 0x25898,\n\t\t0x258a0, 0x258a8,\n\t\t0x258b0, 0x258c8,\n\t\t0x258d0, 0x258d4,\n\t\t0x258e0, 0x258e8,\n\t\t0x258f0, 0x258f0,\n\t\t0x258f8, 0x25a18,\n\t\t0x25a20, 0x25a28,\n\t\t0x25a30, 0x25a48,\n\t\t0x25a50, 0x25a54,\n\t\t0x25a60, 0x25a68,\n\t\t0x25a70, 0x25a70,\n\t\t0x25a78, 0x25a98,\n\t\t0x25aa0, 0x25aa8,\n\t\t0x25ab0, 0x25ac8,\n\t\t0x25ad0, 0x25ad4,\n\t\t0x25ae0, 0x25ae8,\n\t\t0x25af0, 0x25af0,\n\t\t0x25af8, 0x25c18,\n\t\t0x25c20, 0x25c20,\n\t\t0x25c28, 0x25c30,\n\t\t0x25c38, 0x25c38,\n\t\t0x25c80, 0x25c98,\n\t\t0x25ca0, 0x25ca8,\n\t\t0x25cb0, 0x25cc8,\n\t\t0x25cd0, 0x25cd4,\n\t\t0x25ce0, 0x25ce8,\n\t\t0x25cf0, 0x25cf0,\n\t\t0x25cf8, 0x25d7c,\n\t\t0x25e00, 0x25e04,\n\t\t0x26000, 0x2602c,\n\t\t0x26100, 0x2613c,\n\t\t0x26190, 0x261a0,\n\t\t0x261a8, 0x261b8,\n\t\t0x261c4, 0x261c8,\n\t\t0x26200, 0x26318,\n\t\t0x26400, 0x264b4,\n\t\t0x264c0, 0x26528,\n\t\t0x26540, 0x26614,\n\t\t0x27000, 0x27040,\n\t\t0x2704c, 0x27060,\n\t\t0x270c0, 0x270ec,\n\t\t0x27200, 0x27268,\n\t\t0x27270, 0x27284,\n\t\t0x272fc, 0x27388,\n\t\t0x27400, 0x27404,\n\t\t0x27500, 0x27500,\n\t\t0x27510, 0x27518,\n\t\t0x2752c, 0x27530,\n\t\t0x2753c, 0x2753c,\n\t\t0x27550, 0x27554,\n\t\t0x27600, 0x27600,\n\t\t0x27608, 0x2761c,\n\t\t0x27624, 0x27628,\n\t\t0x27630, 0x27634,\n\t\t0x2763c, 0x2763c,\n\t\t0x27700, 0x2771c,\n\t\t0x27780, 0x2778c,\n\t\t0x27800, 0x27818,\n\t\t0x27820, 0x27828,\n\t\t0x27830, 0x27848,\n\t\t0x27850, 0x27854,\n\t\t0x27860, 0x27868,\n\t\t0x27870, 0x27870,\n\t\t0x27878, 0x27898,\n\t\t0x278a0, 0x278a8,\n\t\t0x278b0, 0x278c8,\n\t\t0x278d0, 0x278d4,\n\t\t0x278e0, 0x278e8,\n\t\t0x278f0, 0x278f0,\n\t\t0x278f8, 0x27a18,\n\t\t0x27a20, 0x27a28,\n\t\t0x27a30, 0x27a48,\n\t\t0x27a50, 0x27a54,\n\t\t0x27a60, 0x27a68,\n\t\t0x27a70, 0x27a70,\n\t\t0x27a78, 0x27a98,\n\t\t0x27aa0, 0x27aa8,\n\t\t0x27ab0, 0x27ac8,\n\t\t0x27ad0, 0x27ad4,\n\t\t0x27ae0, 0x27ae8,\n\t\t0x27af0, 0x27af0,\n\t\t0x27af8, 0x27c18,\n\t\t0x27c20, 0x27c20,\n\t\t0x27c28, 0x27c30,\n\t\t0x27c38, 0x27c38,\n\t\t0x27c80, 0x27c98,\n\t\t0x27ca0, 0x27ca8,\n\t\t0x27cb0, 0x27cc8,\n\t\t0x27cd0, 0x27cd4,\n\t\t0x27ce0, 0x27ce8,\n\t\t0x27cf0, 0x27cf0,\n\t\t0x27cf8, 0x27d7c,\n\t\t0x27e00, 0x27e04,\n\t};\n\n\tstatic const unsigned int t5_reg_ranges[] = {\n\t\t0x1008, 0x10c0,\n\t\t0x10cc, 0x10f8,\n\t\t0x1100, 0x1100,\n\t\t0x110c, 0x1148,\n\t\t0x1180, 0x1184,\n\t\t0x1190, 0x1194,\n\t\t0x11a0, 0x11a4,\n\t\t0x11b0, 0x11b4,\n\t\t0x11fc, 0x123c,\n\t\t0x1280, 0x173c,\n\t\t0x1800, 0x18fc,\n\t\t0x3000, 0x3028,\n\t\t0x3060, 0x30b0,\n\t\t0x30b8, 0x30d8,\n\t\t0x30e0, 0x30fc,\n\t\t0x3140, 0x357c,\n\t\t0x35a8, 0x35cc,\n\t\t0x35ec, 0x35ec,\n\t\t0x3600, 0x5624,\n\t\t0x56cc, 0x56ec,\n\t\t0x56f4, 0x5720,\n\t\t0x5728, 0x575c,\n\t\t0x580c, 0x5814,\n\t\t0x5890, 0x589c,\n\t\t0x58a4, 0x58ac,\n\t\t0x58b8, 0x58bc,\n\t\t0x5940, 0x59c8,\n\t\t0x59d0, 0x59dc,\n\t\t0x59fc, 0x5a18,\n\t\t0x5a60, 0x5a70,\n\t\t0x5a80, 0x5a9c,\n\t\t0x5b94, 0x5bfc,\n\t\t0x6000, 0x6020,\n\t\t0x6028, 0x6040,\n\t\t0x6058, 0x609c,\n\t\t0x60a8, 0x614c,\n\t\t0x7700, 0x7798,\n\t\t0x77c0, 0x78fc,\n\t\t0x7b00, 0x7b58,\n\t\t0x7b60, 0x7b84,\n\t\t0x7b8c, 0x7c54,\n\t\t0x7d00, 0x7d38,\n\t\t0x7d40, 0x7d80,\n\t\t0x7d8c, 0x7ddc,\n\t\t0x7de4, 0x7e04,\n\t\t0x7e10, 0x7e1c,\n\t\t0x7e24, 0x7e38,\n\t\t0x7e40, 0x7e44,\n\t\t0x7e4c, 0x7e78,\n\t\t0x7e80, 0x7edc,\n\t\t0x7ee8, 0x7efc,\n\t\t0x8dc0, 0x8de0,\n\t\t0x8df8, 0x8e04,\n\t\t0x8e10, 0x8e84,\n\t\t0x8ea0, 0x8f84,\n\t\t0x8fc0, 0x9058,\n\t\t0x9060, 0x9060,\n\t\t0x9068, 0x90f8,\n\t\t0x9400, 0x9408,\n\t\t0x9410, 0x9470,\n\t\t0x9600, 0x9600,\n\t\t0x9608, 0x9638,\n\t\t0x9640, 0x96f4,\n\t\t0x9800, 0x9808,\n\t\t0x9810, 0x9864,\n\t\t0x9c00, 0x9c6c,\n\t\t0x9c80, 0x9cec,\n\t\t0x9d00, 0x9d6c,\n\t\t0x9d80, 0x9dec,\n\t\t0x9e00, 0x9e6c,\n\t\t0x9e80, 0x9eec,\n\t\t0x9f00, 0x9f6c,\n\t\t0x9f80, 0xa020,\n\t\t0xd000, 0xd004,\n\t\t0xd010, 0xd03c,\n\t\t0xdfc0, 0xdfe0,\n\t\t0xe000, 0x1106c,\n\t\t0x11074, 0x11088,\n\t\t0x1109c, 0x1117c,\n\t\t0x11190, 0x11204,\n\t\t0x19040, 0x1906c,\n\t\t0x19078, 0x19080,\n\t\t0x1908c, 0x190e8,\n\t\t0x190f0, 0x190f8,\n\t\t0x19100, 0x19110,\n\t\t0x19120, 0x19124,\n\t\t0x19150, 0x19194,\n\t\t0x1919c, 0x191b0,\n\t\t0x191d0, 0x191e8,\n\t\t0x19238, 0x19290,\n\t\t0x193f8, 0x19428,\n\t\t0x19430, 0x19444,\n\t\t0x1944c, 0x1946c,\n\t\t0x19474, 0x19474,\n\t\t0x19490, 0x194cc,\n\t\t0x194f0, 0x194f8,\n\t\t0x19c00, 0x19c08,\n\t\t0x19c10, 0x19c60,\n\t\t0x19c94, 0x19ce4,\n\t\t0x19cf0, 0x19d40,\n\t\t0x19d50, 0x19d94,\n\t\t0x19da0, 0x19de8,\n\t\t0x19df0, 0x19e10,\n\t\t0x19e50, 0x19e90,\n\t\t0x19ea0, 0x19f24,\n\t\t0x19f34, 0x19f34,\n\t\t0x19f40, 0x19f50,\n\t\t0x19f90, 0x19fb4,\n\t\t0x19fc4, 0x19fe4,\n\t\t0x1a000, 0x1a004,\n\t\t0x1a010, 0x1a06c,\n\t\t0x1a0b0, 0x1a0e4,\n\t\t0x1a0ec, 0x1a0f8,\n\t\t0x1a100, 0x1a108,\n\t\t0x1a114, 0x1a130,\n\t\t0x1a138, 0x1a1c4,\n\t\t0x1a1fc, 0x1a1fc,\n\t\t0x1e008, 0x1e00c,\n\t\t0x1e040, 0x1e044,\n\t\t0x1e04c, 0x1e04c,\n\t\t0x1e284, 0x1e290,\n\t\t0x1e2c0, 0x1e2c0,\n\t\t0x1e2e0, 0x1e2e0,\n\t\t0x1e300, 0x1e384,\n\t\t0x1e3c0, 0x1e3c8,\n\t\t0x1e408, 0x1e40c,\n\t\t0x1e440, 0x1e444,\n\t\t0x1e44c, 0x1e44c,\n\t\t0x1e684, 0x1e690,\n\t\t0x1e6c0, 0x1e6c0,\n\t\t0x1e6e0, 0x1e6e0,\n\t\t0x1e700, 0x1e784,\n\t\t0x1e7c0, 0x1e7c8,\n\t\t0x1e808, 0x1e80c,\n\t\t0x1e840, 0x1e844,\n\t\t0x1e84c, 0x1e84c,\n\t\t0x1ea84, 0x1ea90,\n\t\t0x1eac0, 0x1eac0,\n\t\t0x1eae0, 0x1eae0,\n\t\t0x1eb00, 0x1eb84,\n\t\t0x1ebc0, 0x1ebc8,\n\t\t0x1ec08, 0x1ec0c,\n\t\t0x1ec40, 0x1ec44,\n\t\t0x1ec4c, 0x1ec4c,\n\t\t0x1ee84, 0x1ee90,\n\t\t0x1eec0, 0x1eec0,\n\t\t0x1eee0, 0x1eee0,\n\t\t0x1ef00, 0x1ef84,\n\t\t0x1efc0, 0x1efc8,\n\t\t0x1f008, 0x1f00c,\n\t\t0x1f040, 0x1f044,\n\t\t0x1f04c, 0x1f04c,\n\t\t0x1f284, 0x1f290,\n\t\t0x1f2c0, 0x1f2c0,\n\t\t0x1f2e0, 0x1f2e0,\n\t\t0x1f300, 0x1f384,\n\t\t0x1f3c0, 0x1f3c8,\n\t\t0x1f408, 0x1f40c,\n\t\t0x1f440, 0x1f444,\n\t\t0x1f44c, 0x1f44c,\n\t\t0x1f684, 0x1f690,\n\t\t0x1f6c0, 0x1f6c0,\n\t\t0x1f6e0, 0x1f6e0,\n\t\t0x1f700, 0x1f784,\n\t\t0x1f7c0, 0x1f7c8,\n\t\t0x1f808, 0x1f80c,\n\t\t0x1f840, 0x1f844,\n\t\t0x1f84c, 0x1f84c,\n\t\t0x1fa84, 0x1fa90,\n\t\t0x1fac0, 0x1fac0,\n\t\t0x1fae0, 0x1fae0,\n\t\t0x1fb00, 0x1fb84,\n\t\t0x1fbc0, 0x1fbc8,\n\t\t0x1fc08, 0x1fc0c,\n\t\t0x1fc40, 0x1fc44,\n\t\t0x1fc4c, 0x1fc4c,\n\t\t0x1fe84, 0x1fe90,\n\t\t0x1fec0, 0x1fec0,\n\t\t0x1fee0, 0x1fee0,\n\t\t0x1ff00, 0x1ff84,\n\t\t0x1ffc0, 0x1ffc8,\n\t\t0x30000, 0x30030,\n\t\t0x30100, 0x30144,\n\t\t0x30190, 0x301a0,\n\t\t0x301a8, 0x301b8,\n\t\t0x301c4, 0x301c8,\n\t\t0x301d0, 0x301d0,\n\t\t0x30200, 0x30318,\n\t\t0x30400, 0x304b4,\n\t\t0x304c0, 0x3052c,\n\t\t0x30540, 0x3061c,\n\t\t0x30800, 0x30828,\n\t\t0x30834, 0x30834,\n\t\t0x308c0, 0x30908,\n\t\t0x30910, 0x309ac,\n\t\t0x30a00, 0x30a14,\n\t\t0x30a1c, 0x30a2c,\n\t\t0x30a44, 0x30a50,\n\t\t0x30a74, 0x30a74,\n\t\t0x30a7c, 0x30afc,\n\t\t0x30b08, 0x30c24,\n\t\t0x30d00, 0x30d00,\n\t\t0x30d08, 0x30d14,\n\t\t0x30d1c, 0x30d20,\n\t\t0x30d3c, 0x30d3c,\n\t\t0x30d48, 0x30d50,\n\t\t0x31200, 0x3120c,\n\t\t0x31220, 0x31220,\n\t\t0x31240, 0x31240,\n\t\t0x31600, 0x3160c,\n\t\t0x31a00, 0x31a1c,\n\t\t0x31e00, 0x31e20,\n\t\t0x31e38, 0x31e3c,\n\t\t0x31e80, 0x31e80,\n\t\t0x31e88, 0x31ea8,\n\t\t0x31eb0, 0x31eb4,\n\t\t0x31ec8, 0x31ed4,\n\t\t0x31fb8, 0x32004,\n\t\t0x32200, 0x32200,\n\t\t0x32208, 0x32240,\n\t\t0x32248, 0x32280,\n\t\t0x32288, 0x322c0,\n\t\t0x322c8, 0x322fc,\n\t\t0x32600, 0x32630,\n\t\t0x32a00, 0x32abc,\n\t\t0x32b00, 0x32b10,\n\t\t0x32b20, 0x32b30,\n\t\t0x32b40, 0x32b50,\n\t\t0x32b60, 0x32b70,\n\t\t0x33000, 0x33028,\n\t\t0x33030, 0x33048,\n\t\t0x33060, 0x33068,\n\t\t0x33070, 0x3309c,\n\t\t0x330f0, 0x33128,\n\t\t0x33130, 0x33148,\n\t\t0x33160, 0x33168,\n\t\t0x33170, 0x3319c,\n\t\t0x331f0, 0x33238,\n\t\t0x33240, 0x33240,\n\t\t0x33248, 0x33250,\n\t\t0x3325c, 0x33264,\n\t\t0x33270, 0x332b8,\n\t\t0x332c0, 0x332e4,\n\t\t0x332f8, 0x33338,\n\t\t0x33340, 0x33340,\n\t\t0x33348, 0x33350,\n\t\t0x3335c, 0x33364,\n\t\t0x33370, 0x333b8,\n\t\t0x333c0, 0x333e4,\n\t\t0x333f8, 0x33428,\n\t\t0x33430, 0x33448,\n\t\t0x33460, 0x33468,\n\t\t0x33470, 0x3349c,\n\t\t0x334f0, 0x33528,\n\t\t0x33530, 0x33548,\n\t\t0x33560, 0x33568,\n\t\t0x33570, 0x3359c,\n\t\t0x335f0, 0x33638,\n\t\t0x33640, 0x33640,\n\t\t0x33648, 0x33650,\n\t\t0x3365c, 0x33664,\n\t\t0x33670, 0x336b8,\n\t\t0x336c0, 0x336e4,\n\t\t0x336f8, 0x33738,\n\t\t0x33740, 0x33740,\n\t\t0x33748, 0x33750,\n\t\t0x3375c, 0x33764,\n\t\t0x33770, 0x337b8,\n\t\t0x337c0, 0x337e4,\n\t\t0x337f8, 0x337fc,\n\t\t0x33814, 0x33814,\n\t\t0x3382c, 0x3382c,\n\t\t0x33880, 0x3388c,\n\t\t0x338e8, 0x338ec,\n\t\t0x33900, 0x33928,\n\t\t0x33930, 0x33948,\n\t\t0x33960, 0x33968,\n\t\t0x33970, 0x3399c,\n\t\t0x339f0, 0x33a38,\n\t\t0x33a40, 0x33a40,\n\t\t0x33a48, 0x33a50,\n\t\t0x33a5c, 0x33a64,\n\t\t0x33a70, 0x33ab8,\n\t\t0x33ac0, 0x33ae4,\n\t\t0x33af8, 0x33b10,\n\t\t0x33b28, 0x33b28,\n\t\t0x33b3c, 0x33b50,\n\t\t0x33bf0, 0x33c10,\n\t\t0x33c28, 0x33c28,\n\t\t0x33c3c, 0x33c50,\n\t\t0x33cf0, 0x33cfc,\n\t\t0x34000, 0x34030,\n\t\t0x34100, 0x34144,\n\t\t0x34190, 0x341a0,\n\t\t0x341a8, 0x341b8,\n\t\t0x341c4, 0x341c8,\n\t\t0x341d0, 0x341d0,\n\t\t0x34200, 0x34318,\n\t\t0x34400, 0x344b4,\n\t\t0x344c0, 0x3452c,\n\t\t0x34540, 0x3461c,\n\t\t0x34800, 0x34828,\n\t\t0x34834, 0x34834,\n\t\t0x348c0, 0x34908,\n\t\t0x34910, 0x349ac,\n\t\t0x34a00, 0x34a14,\n\t\t0x34a1c, 0x34a2c,\n\t\t0x34a44, 0x34a50,\n\t\t0x34a74, 0x34a74,\n\t\t0x34a7c, 0x34afc,\n\t\t0x34b08, 0x34c24,\n\t\t0x34d00, 0x34d00,\n\t\t0x34d08, 0x34d14,\n\t\t0x34d1c, 0x34d20,\n\t\t0x34d3c, 0x34d3c,\n\t\t0x34d48, 0x34d50,\n\t\t0x35200, 0x3520c,\n\t\t0x35220, 0x35220,\n\t\t0x35240, 0x35240,\n\t\t0x35600, 0x3560c,\n\t\t0x35a00, 0x35a1c,\n\t\t0x35e00, 0x35e20,\n\t\t0x35e38, 0x35e3c,\n\t\t0x35e80, 0x35e80,\n\t\t0x35e88, 0x35ea8,\n\t\t0x35eb0, 0x35eb4,\n\t\t0x35ec8, 0x35ed4,\n\t\t0x35fb8, 0x36004,\n\t\t0x36200, 0x36200,\n\t\t0x36208, 0x36240,\n\t\t0x36248, 0x36280,\n\t\t0x36288, 0x362c0,\n\t\t0x362c8, 0x362fc,\n\t\t0x36600, 0x36630,\n\t\t0x36a00, 0x36abc,\n\t\t0x36b00, 0x36b10,\n\t\t0x36b20, 0x36b30,\n\t\t0x36b40, 0x36b50,\n\t\t0x36b60, 0x36b70,\n\t\t0x37000, 0x37028,\n\t\t0x37030, 0x37048,\n\t\t0x37060, 0x37068,\n\t\t0x37070, 0x3709c,\n\t\t0x370f0, 0x37128,\n\t\t0x37130, 0x37148,\n\t\t0x37160, 0x37168,\n\t\t0x37170, 0x3719c,\n\t\t0x371f0, 0x37238,\n\t\t0x37240, 0x37240,\n\t\t0x37248, 0x37250,\n\t\t0x3725c, 0x37264,\n\t\t0x37270, 0x372b8,\n\t\t0x372c0, 0x372e4,\n\t\t0x372f8, 0x37338,\n\t\t0x37340, 0x37340,\n\t\t0x37348, 0x37350,\n\t\t0x3735c, 0x37364,\n\t\t0x37370, 0x373b8,\n\t\t0x373c0, 0x373e4,\n\t\t0x373f8, 0x37428,\n\t\t0x37430, 0x37448,\n\t\t0x37460, 0x37468,\n\t\t0x37470, 0x3749c,\n\t\t0x374f0, 0x37528,\n\t\t0x37530, 0x37548,\n\t\t0x37560, 0x37568,\n\t\t0x37570, 0x3759c,\n\t\t0x375f0, 0x37638,\n\t\t0x37640, 0x37640,\n\t\t0x37648, 0x37650,\n\t\t0x3765c, 0x37664,\n\t\t0x37670, 0x376b8,\n\t\t0x376c0, 0x376e4,\n\t\t0x376f8, 0x37738,\n\t\t0x37740, 0x37740,\n\t\t0x37748, 0x37750,\n\t\t0x3775c, 0x37764,\n\t\t0x37770, 0x377b8,\n\t\t0x377c0, 0x377e4,\n\t\t0x377f8, 0x377fc,\n\t\t0x37814, 0x37814,\n\t\t0x3782c, 0x3782c,\n\t\t0x37880, 0x3788c,\n\t\t0x378e8, 0x378ec,\n\t\t0x37900, 0x37928,\n\t\t0x37930, 0x37948,\n\t\t0x37960, 0x37968,\n\t\t0x37970, 0x3799c,\n\t\t0x379f0, 0x37a38,\n\t\t0x37a40, 0x37a40,\n\t\t0x37a48, 0x37a50,\n\t\t0x37a5c, 0x37a64,\n\t\t0x37a70, 0x37ab8,\n\t\t0x37ac0, 0x37ae4,\n\t\t0x37af8, 0x37b10,\n\t\t0x37b28, 0x37b28,\n\t\t0x37b3c, 0x37b50,\n\t\t0x37bf0, 0x37c10,\n\t\t0x37c28, 0x37c28,\n\t\t0x37c3c, 0x37c50,\n\t\t0x37cf0, 0x37cfc,\n\t\t0x38000, 0x38030,\n\t\t0x38100, 0x38144,\n\t\t0x38190, 0x381a0,\n\t\t0x381a8, 0x381b8,\n\t\t0x381c4, 0x381c8,\n\t\t0x381d0, 0x381d0,\n\t\t0x38200, 0x38318,\n\t\t0x38400, 0x384b4,\n\t\t0x384c0, 0x3852c,\n\t\t0x38540, 0x3861c,\n\t\t0x38800, 0x38828,\n\t\t0x38834, 0x38834,\n\t\t0x388c0, 0x38908,\n\t\t0x38910, 0x389ac,\n\t\t0x38a00, 0x38a14,\n\t\t0x38a1c, 0x38a2c,\n\t\t0x38a44, 0x38a50,\n\t\t0x38a74, 0x38a74,\n\t\t0x38a7c, 0x38afc,\n\t\t0x38b08, 0x38c24,\n\t\t0x38d00, 0x38d00,\n\t\t0x38d08, 0x38d14,\n\t\t0x38d1c, 0x38d20,\n\t\t0x38d3c, 0x38d3c,\n\t\t0x38d48, 0x38d50,\n\t\t0x39200, 0x3920c,\n\t\t0x39220, 0x39220,\n\t\t0x39240, 0x39240,\n\t\t0x39600, 0x3960c,\n\t\t0x39a00, 0x39a1c,\n\t\t0x39e00, 0x39e20,\n\t\t0x39e38, 0x39e3c,\n\t\t0x39e80, 0x39e80,\n\t\t0x39e88, 0x39ea8,\n\t\t0x39eb0, 0x39eb4,\n\t\t0x39ec8, 0x39ed4,\n\t\t0x39fb8, 0x3a004,\n\t\t0x3a200, 0x3a200,\n\t\t0x3a208, 0x3a240,\n\t\t0x3a248, 0x3a280,\n\t\t0x3a288, 0x3a2c0,\n\t\t0x3a2c8, 0x3a2fc,\n\t\t0x3a600, 0x3a630,\n\t\t0x3aa00, 0x3aabc,\n\t\t0x3ab00, 0x3ab10,\n\t\t0x3ab20, 0x3ab30,\n\t\t0x3ab40, 0x3ab50,\n\t\t0x3ab60, 0x3ab70,\n\t\t0x3b000, 0x3b028,\n\t\t0x3b030, 0x3b048,\n\t\t0x3b060, 0x3b068,\n\t\t0x3b070, 0x3b09c,\n\t\t0x3b0f0, 0x3b128,\n\t\t0x3b130, 0x3b148,\n\t\t0x3b160, 0x3b168,\n\t\t0x3b170, 0x3b19c,\n\t\t0x3b1f0, 0x3b238,\n\t\t0x3b240, 0x3b240,\n\t\t0x3b248, 0x3b250,\n\t\t0x3b25c, 0x3b264,\n\t\t0x3b270, 0x3b2b8,\n\t\t0x3b2c0, 0x3b2e4,\n\t\t0x3b2f8, 0x3b338,\n\t\t0x3b340, 0x3b340,\n\t\t0x3b348, 0x3b350,\n\t\t0x3b35c, 0x3b364,\n\t\t0x3b370, 0x3b3b8,\n\t\t0x3b3c0, 0x3b3e4,\n\t\t0x3b3f8, 0x3b428,\n\t\t0x3b430, 0x3b448,\n\t\t0x3b460, 0x3b468,\n\t\t0x3b470, 0x3b49c,\n\t\t0x3b4f0, 0x3b528,\n\t\t0x3b530, 0x3b548,\n\t\t0x3b560, 0x3b568,\n\t\t0x3b570, 0x3b59c,\n\t\t0x3b5f0, 0x3b638,\n\t\t0x3b640, 0x3b640,\n\t\t0x3b648, 0x3b650,\n\t\t0x3b65c, 0x3b664,\n\t\t0x3b670, 0x3b6b8,\n\t\t0x3b6c0, 0x3b6e4,\n\t\t0x3b6f8, 0x3b738,\n\t\t0x3b740, 0x3b740,\n\t\t0x3b748, 0x3b750,\n\t\t0x3b75c, 0x3b764,\n\t\t0x3b770, 0x3b7b8,\n\t\t0x3b7c0, 0x3b7e4,\n\t\t0x3b7f8, 0x3b7fc,\n\t\t0x3b814, 0x3b814,\n\t\t0x3b82c, 0x3b82c,\n\t\t0x3b880, 0x3b88c,\n\t\t0x3b8e8, 0x3b8ec,\n\t\t0x3b900, 0x3b928,\n\t\t0x3b930, 0x3b948,\n\t\t0x3b960, 0x3b968,\n\t\t0x3b970, 0x3b99c,\n\t\t0x3b9f0, 0x3ba38,\n\t\t0x3ba40, 0x3ba40,\n\t\t0x3ba48, 0x3ba50,\n\t\t0x3ba5c, 0x3ba64,\n\t\t0x3ba70, 0x3bab8,\n\t\t0x3bac0, 0x3bae4,\n\t\t0x3baf8, 0x3bb10,\n\t\t0x3bb28, 0x3bb28,\n\t\t0x3bb3c, 0x3bb50,\n\t\t0x3bbf0, 0x3bc10,\n\t\t0x3bc28, 0x3bc28,\n\t\t0x3bc3c, 0x3bc50,\n\t\t0x3bcf0, 0x3bcfc,\n\t\t0x3c000, 0x3c030,\n\t\t0x3c100, 0x3c144,\n\t\t0x3c190, 0x3c1a0,\n\t\t0x3c1a8, 0x3c1b8,\n\t\t0x3c1c4, 0x3c1c8,\n\t\t0x3c1d0, 0x3c1d0,\n\t\t0x3c200, 0x3c318,\n\t\t0x3c400, 0x3c4b4,\n\t\t0x3c4c0, 0x3c52c,\n\t\t0x3c540, 0x3c61c,\n\t\t0x3c800, 0x3c828,\n\t\t0x3c834, 0x3c834,\n\t\t0x3c8c0, 0x3c908,\n\t\t0x3c910, 0x3c9ac,\n\t\t0x3ca00, 0x3ca14,\n\t\t0x3ca1c, 0x3ca2c,\n\t\t0x3ca44, 0x3ca50,\n\t\t0x3ca74, 0x3ca74,\n\t\t0x3ca7c, 0x3cafc,\n\t\t0x3cb08, 0x3cc24,\n\t\t0x3cd00, 0x3cd00,\n\t\t0x3cd08, 0x3cd14,\n\t\t0x3cd1c, 0x3cd20,\n\t\t0x3cd3c, 0x3cd3c,\n\t\t0x3cd48, 0x3cd50,\n\t\t0x3d200, 0x3d20c,\n\t\t0x3d220, 0x3d220,\n\t\t0x3d240, 0x3d240,\n\t\t0x3d600, 0x3d60c,\n\t\t0x3da00, 0x3da1c,\n\t\t0x3de00, 0x3de20,\n\t\t0x3de38, 0x3de3c,\n\t\t0x3de80, 0x3de80,\n\t\t0x3de88, 0x3dea8,\n\t\t0x3deb0, 0x3deb4,\n\t\t0x3dec8, 0x3ded4,\n\t\t0x3dfb8, 0x3e004,\n\t\t0x3e200, 0x3e200,\n\t\t0x3e208, 0x3e240,\n\t\t0x3e248, 0x3e280,\n\t\t0x3e288, 0x3e2c0,\n\t\t0x3e2c8, 0x3e2fc,\n\t\t0x3e600, 0x3e630,\n\t\t0x3ea00, 0x3eabc,\n\t\t0x3eb00, 0x3eb10,\n\t\t0x3eb20, 0x3eb30,\n\t\t0x3eb40, 0x3eb50,\n\t\t0x3eb60, 0x3eb70,\n\t\t0x3f000, 0x3f028,\n\t\t0x3f030, 0x3f048,\n\t\t0x3f060, 0x3f068,\n\t\t0x3f070, 0x3f09c,\n\t\t0x3f0f0, 0x3f128,\n\t\t0x3f130, 0x3f148,\n\t\t0x3f160, 0x3f168,\n\t\t0x3f170, 0x3f19c,\n\t\t0x3f1f0, 0x3f238,\n\t\t0x3f240, 0x3f240,\n\t\t0x3f248, 0x3f250,\n\t\t0x3f25c, 0x3f264,\n\t\t0x3f270, 0x3f2b8,\n\t\t0x3f2c0, 0x3f2e4,\n\t\t0x3f2f8, 0x3f338,\n\t\t0x3f340, 0x3f340,\n\t\t0x3f348, 0x3f350,\n\t\t0x3f35c, 0x3f364,\n\t\t0x3f370, 0x3f3b8,\n\t\t0x3f3c0, 0x3f3e4,\n\t\t0x3f3f8, 0x3f428,\n\t\t0x3f430, 0x3f448,\n\t\t0x3f460, 0x3f468,\n\t\t0x3f470, 0x3f49c,\n\t\t0x3f4f0, 0x3f528,\n\t\t0x3f530, 0x3f548,\n\t\t0x3f560, 0x3f568,\n\t\t0x3f570, 0x3f59c,\n\t\t0x3f5f0, 0x3f638,\n\t\t0x3f640, 0x3f640,\n\t\t0x3f648, 0x3f650,\n\t\t0x3f65c, 0x3f664,\n\t\t0x3f670, 0x3f6b8,\n\t\t0x3f6c0, 0x3f6e4,\n\t\t0x3f6f8, 0x3f738,\n\t\t0x3f740, 0x3f740,\n\t\t0x3f748, 0x3f750,\n\t\t0x3f75c, 0x3f764,\n\t\t0x3f770, 0x3f7b8,\n\t\t0x3f7c0, 0x3f7e4,\n\t\t0x3f7f8, 0x3f7fc,\n\t\t0x3f814, 0x3f814,\n\t\t0x3f82c, 0x3f82c,\n\t\t0x3f880, 0x3f88c,\n\t\t0x3f8e8, 0x3f8ec,\n\t\t0x3f900, 0x3f928,\n\t\t0x3f930, 0x3f948,\n\t\t0x3f960, 0x3f968,\n\t\t0x3f970, 0x3f99c,\n\t\t0x3f9f0, 0x3fa38,\n\t\t0x3fa40, 0x3fa40,\n\t\t0x3fa48, 0x3fa50,\n\t\t0x3fa5c, 0x3fa64,\n\t\t0x3fa70, 0x3fab8,\n\t\t0x3fac0, 0x3fae4,\n\t\t0x3faf8, 0x3fb10,\n\t\t0x3fb28, 0x3fb28,\n\t\t0x3fb3c, 0x3fb50,\n\t\t0x3fbf0, 0x3fc10,\n\t\t0x3fc28, 0x3fc28,\n\t\t0x3fc3c, 0x3fc50,\n\t\t0x3fcf0, 0x3fcfc,\n\t\t0x40000, 0x4000c,\n\t\t0x40040, 0x40050,\n\t\t0x40060, 0x40068,\n\t\t0x4007c, 0x4008c,\n\t\t0x40094, 0x400b0,\n\t\t0x400c0, 0x40144,\n\t\t0x40180, 0x4018c,\n\t\t0x40200, 0x40254,\n\t\t0x40260, 0x40264,\n\t\t0x40270, 0x40288,\n\t\t0x40290, 0x40298,\n\t\t0x402ac, 0x402c8,\n\t\t0x402d0, 0x402e0,\n\t\t0x402f0, 0x402f0,\n\t\t0x40300, 0x4033c,\n\t\t0x403f8, 0x403fc,\n\t\t0x41304, 0x413c4,\n\t\t0x41400, 0x4140c,\n\t\t0x41414, 0x4141c,\n\t\t0x41480, 0x414d0,\n\t\t0x44000, 0x44054,\n\t\t0x4405c, 0x44078,\n\t\t0x440c0, 0x44174,\n\t\t0x44180, 0x441ac,\n\t\t0x441b4, 0x441b8,\n\t\t0x441c0, 0x44254,\n\t\t0x4425c, 0x44278,\n\t\t0x442c0, 0x44374,\n\t\t0x44380, 0x443ac,\n\t\t0x443b4, 0x443b8,\n\t\t0x443c0, 0x44454,\n\t\t0x4445c, 0x44478,\n\t\t0x444c0, 0x44574,\n\t\t0x44580, 0x445ac,\n\t\t0x445b4, 0x445b8,\n\t\t0x445c0, 0x44654,\n\t\t0x4465c, 0x44678,\n\t\t0x446c0, 0x44774,\n\t\t0x44780, 0x447ac,\n\t\t0x447b4, 0x447b8,\n\t\t0x447c0, 0x44854,\n\t\t0x4485c, 0x44878,\n\t\t0x448c0, 0x44974,\n\t\t0x44980, 0x449ac,\n\t\t0x449b4, 0x449b8,\n\t\t0x449c0, 0x449fc,\n\t\t0x45000, 0x45004,\n\t\t0x45010, 0x45030,\n\t\t0x45040, 0x45060,\n\t\t0x45068, 0x45068,\n\t\t0x45080, 0x45084,\n\t\t0x450a0, 0x450b0,\n\t\t0x45200, 0x45204,\n\t\t0x45210, 0x45230,\n\t\t0x45240, 0x45260,\n\t\t0x45268, 0x45268,\n\t\t0x45280, 0x45284,\n\t\t0x452a0, 0x452b0,\n\t\t0x460c0, 0x460e4,\n\t\t0x47000, 0x4703c,\n\t\t0x47044, 0x4708c,\n\t\t0x47200, 0x47250,\n\t\t0x47400, 0x47408,\n\t\t0x47414, 0x47420,\n\t\t0x47600, 0x47618,\n\t\t0x47800, 0x47814,\n\t\t0x48000, 0x4800c,\n\t\t0x48040, 0x48050,\n\t\t0x48060, 0x48068,\n\t\t0x4807c, 0x4808c,\n\t\t0x48094, 0x480b0,\n\t\t0x480c0, 0x48144,\n\t\t0x48180, 0x4818c,\n\t\t0x48200, 0x48254,\n\t\t0x48260, 0x48264,\n\t\t0x48270, 0x48288,\n\t\t0x48290, 0x48298,\n\t\t0x482ac, 0x482c8,\n\t\t0x482d0, 0x482e0,\n\t\t0x482f0, 0x482f0,\n\t\t0x48300, 0x4833c,\n\t\t0x483f8, 0x483fc,\n\t\t0x49304, 0x493c4,\n\t\t0x49400, 0x4940c,\n\t\t0x49414, 0x4941c,\n\t\t0x49480, 0x494d0,\n\t\t0x4c000, 0x4c054,\n\t\t0x4c05c, 0x4c078,\n\t\t0x4c0c0, 0x4c174,\n\t\t0x4c180, 0x4c1ac,\n\t\t0x4c1b4, 0x4c1b8,\n\t\t0x4c1c0, 0x4c254,\n\t\t0x4c25c, 0x4c278,\n\t\t0x4c2c0, 0x4c374,\n\t\t0x4c380, 0x4c3ac,\n\t\t0x4c3b4, 0x4c3b8,\n\t\t0x4c3c0, 0x4c454,\n\t\t0x4c45c, 0x4c478,\n\t\t0x4c4c0, 0x4c574,\n\t\t0x4c580, 0x4c5ac,\n\t\t0x4c5b4, 0x4c5b8,\n\t\t0x4c5c0, 0x4c654,\n\t\t0x4c65c, 0x4c678,\n\t\t0x4c6c0, 0x4c774,\n\t\t0x4c780, 0x4c7ac,\n\t\t0x4c7b4, 0x4c7b8,\n\t\t0x4c7c0, 0x4c854,\n\t\t0x4c85c, 0x4c878,\n\t\t0x4c8c0, 0x4c974,\n\t\t0x4c980, 0x4c9ac,\n\t\t0x4c9b4, 0x4c9b8,\n\t\t0x4c9c0, 0x4c9fc,\n\t\t0x4d000, 0x4d004,\n\t\t0x4d010, 0x4d030,\n\t\t0x4d040, 0x4d060,\n\t\t0x4d068, 0x4d068,\n\t\t0x4d080, 0x4d084,\n\t\t0x4d0a0, 0x4d0b0,\n\t\t0x4d200, 0x4d204,\n\t\t0x4d210, 0x4d230,\n\t\t0x4d240, 0x4d260,\n\t\t0x4d268, 0x4d268,\n\t\t0x4d280, 0x4d284,\n\t\t0x4d2a0, 0x4d2b0,\n\t\t0x4e0c0, 0x4e0e4,\n\t\t0x4f000, 0x4f03c,\n\t\t0x4f044, 0x4f08c,\n\t\t0x4f200, 0x4f250,\n\t\t0x4f400, 0x4f408,\n\t\t0x4f414, 0x4f420,\n\t\t0x4f600, 0x4f618,\n\t\t0x4f800, 0x4f814,\n\t\t0x50000, 0x50084,\n\t\t0x50090, 0x500cc,\n\t\t0x50400, 0x50400,\n\t\t0x50800, 0x50884,\n\t\t0x50890, 0x508cc,\n\t\t0x50c00, 0x50c00,\n\t\t0x51000, 0x5101c,\n\t\t0x51300, 0x51308,\n\t};\n\n\tstatic const unsigned int t6_reg_ranges[] = {\n\t\t0x1008, 0x101c,\n\t\t0x1024, 0x10a8,\n\t\t0x10b4, 0x10f8,\n\t\t0x1100, 0x1114,\n\t\t0x111c, 0x112c,\n\t\t0x1138, 0x113c,\n\t\t0x1144, 0x114c,\n\t\t0x1180, 0x1184,\n\t\t0x1190, 0x1194,\n\t\t0x11a0, 0x11a4,\n\t\t0x11b0, 0x11b4,\n\t\t0x11fc, 0x123c,\n\t\t0x1254, 0x1274,\n\t\t0x1280, 0x133c,\n\t\t0x1800, 0x18fc,\n\t\t0x3000, 0x302c,\n\t\t0x3060, 0x30b0,\n\t\t0x30b8, 0x30d8,\n\t\t0x30e0, 0x30fc,\n\t\t0x3140, 0x357c,\n\t\t0x35a8, 0x35cc,\n\t\t0x35ec, 0x35ec,\n\t\t0x3600, 0x5624,\n\t\t0x56cc, 0x56ec,\n\t\t0x56f4, 0x5720,\n\t\t0x5728, 0x575c,\n\t\t0x580c, 0x5814,\n\t\t0x5890, 0x589c,\n\t\t0x58a4, 0x58ac,\n\t\t0x58b8, 0x58bc,\n\t\t0x5940, 0x595c,\n\t\t0x5980, 0x598c,\n\t\t0x59b0, 0x59c8,\n\t\t0x59d0, 0x59dc,\n\t\t0x59fc, 0x5a18,\n\t\t0x5a60, 0x5a6c,\n\t\t0x5a80, 0x5a8c,\n\t\t0x5a94, 0x5a9c,\n\t\t0x5b94, 0x5bfc,\n\t\t0x5c10, 0x5e48,\n\t\t0x5e50, 0x5e94,\n\t\t0x5ea0, 0x5eb0,\n\t\t0x5ec0, 0x5ec0,\n\t\t0x5ec8, 0x5ed0,\n\t\t0x5ee0, 0x5ee0,\n\t\t0x5ef0, 0x5ef0,\n\t\t0x5f00, 0x5f00,\n\t\t0x6000, 0x6020,\n\t\t0x6028, 0x6040,\n\t\t0x6058, 0x609c,\n\t\t0x60a8, 0x619c,\n\t\t0x7700, 0x7798,\n\t\t0x77c0, 0x7880,\n\t\t0x78cc, 0x78fc,\n\t\t0x7b00, 0x7b58,\n\t\t0x7b60, 0x7b84,\n\t\t0x7b8c, 0x7c54,\n\t\t0x7d00, 0x7d38,\n\t\t0x7d40, 0x7d84,\n\t\t0x7d8c, 0x7ddc,\n\t\t0x7de4, 0x7e04,\n\t\t0x7e10, 0x7e1c,\n\t\t0x7e24, 0x7e38,\n\t\t0x7e40, 0x7e44,\n\t\t0x7e4c, 0x7e78,\n\t\t0x7e80, 0x7edc,\n\t\t0x7ee8, 0x7efc,\n\t\t0x8dc0, 0x8de4,\n\t\t0x8df8, 0x8e04,\n\t\t0x8e10, 0x8e84,\n\t\t0x8ea0, 0x8f88,\n\t\t0x8fb8, 0x9058,\n\t\t0x9060, 0x9060,\n\t\t0x9068, 0x90f8,\n\t\t0x9100, 0x9124,\n\t\t0x9400, 0x9470,\n\t\t0x9600, 0x9600,\n\t\t0x9608, 0x9638,\n\t\t0x9640, 0x9704,\n\t\t0x9710, 0x971c,\n\t\t0x9800, 0x9808,\n\t\t0x9810, 0x9864,\n\t\t0x9c00, 0x9c6c,\n\t\t0x9c80, 0x9cec,\n\t\t0x9d00, 0x9d6c,\n\t\t0x9d80, 0x9dec,\n\t\t0x9e00, 0x9e6c,\n\t\t0x9e80, 0x9eec,\n\t\t0x9f00, 0x9f6c,\n\t\t0x9f80, 0xa020,\n\t\t0xd000, 0xd03c,\n\t\t0xd100, 0xd118,\n\t\t0xd200, 0xd214,\n\t\t0xd220, 0xd234,\n\t\t0xd240, 0xd254,\n\t\t0xd260, 0xd274,\n\t\t0xd280, 0xd294,\n\t\t0xd2a0, 0xd2b4,\n\t\t0xd2c0, 0xd2d4,\n\t\t0xd2e0, 0xd2f4,\n\t\t0xd300, 0xd31c,\n\t\t0xdfc0, 0xdfe0,\n\t\t0xe000, 0xf008,\n\t\t0xf010, 0xf018,\n\t\t0xf020, 0xf028,\n\t\t0x11000, 0x11014,\n\t\t0x11048, 0x1106c,\n\t\t0x11074, 0x11088,\n\t\t0x11098, 0x11120,\n\t\t0x1112c, 0x1117c,\n\t\t0x11190, 0x112e0,\n\t\t0x11300, 0x1130c,\n\t\t0x12000, 0x1206c,\n\t\t0x19040, 0x1906c,\n\t\t0x19078, 0x19080,\n\t\t0x1908c, 0x190e8,\n\t\t0x190f0, 0x190f8,\n\t\t0x19100, 0x19110,\n\t\t0x19120, 0x19124,\n\t\t0x19150, 0x19194,\n\t\t0x1919c, 0x191b0,\n\t\t0x191d0, 0x191e8,\n\t\t0x19238, 0x19290,\n\t\t0x192a4, 0x192b0,\n\t\t0x192bc, 0x192bc,\n\t\t0x19348, 0x1934c,\n\t\t0x193f8, 0x19418,\n\t\t0x19420, 0x19428,\n\t\t0x19430, 0x19444,\n\t\t0x1944c, 0x1946c,\n\t\t0x19474, 0x19474,\n\t\t0x19490, 0x194cc,\n\t\t0x194f0, 0x194f8,\n\t\t0x19c00, 0x19c48,\n\t\t0x19c50, 0x19c80,\n\t\t0x19c94, 0x19c98,\n\t\t0x19ca0, 0x19cbc,\n\t\t0x19ce4, 0x19ce4,\n\t\t0x19cf0, 0x19cf8,\n\t\t0x19d00, 0x19d28,\n\t\t0x19d50, 0x19d78,\n\t\t0x19d94, 0x19d98,\n\t\t0x19da0, 0x19dc8,\n\t\t0x19df0, 0x19e10,\n\t\t0x19e50, 0x19e6c,\n\t\t0x19ea0, 0x19ebc,\n\t\t0x19ec4, 0x19ef4,\n\t\t0x19f04, 0x19f2c,\n\t\t0x19f34, 0x19f34,\n\t\t0x19f40, 0x19f50,\n\t\t0x19f90, 0x19fac,\n\t\t0x19fc4, 0x19fc8,\n\t\t0x19fd0, 0x19fe4,\n\t\t0x1a000, 0x1a004,\n\t\t0x1a010, 0x1a06c,\n\t\t0x1a0b0, 0x1a0e4,\n\t\t0x1a0ec, 0x1a0f8,\n\t\t0x1a100, 0x1a108,\n\t\t0x1a114, 0x1a130,\n\t\t0x1a138, 0x1a1c4,\n\t\t0x1a1fc, 0x1a1fc,\n\t\t0x1e008, 0x1e00c,\n\t\t0x1e040, 0x1e044,\n\t\t0x1e04c, 0x1e04c,\n\t\t0x1e284, 0x1e290,\n\t\t0x1e2c0, 0x1e2c0,\n\t\t0x1e2e0, 0x1e2e0,\n\t\t0x1e300, 0x1e384,\n\t\t0x1e3c0, 0x1e3c8,\n\t\t0x1e408, 0x1e40c,\n\t\t0x1e440, 0x1e444,\n\t\t0x1e44c, 0x1e44c,\n\t\t0x1e684, 0x1e690,\n\t\t0x1e6c0, 0x1e6c0,\n\t\t0x1e6e0, 0x1e6e0,\n\t\t0x1e700, 0x1e784,\n\t\t0x1e7c0, 0x1e7c8,\n\t\t0x1e808, 0x1e80c,\n\t\t0x1e840, 0x1e844,\n\t\t0x1e84c, 0x1e84c,\n\t\t0x1ea84, 0x1ea90,\n\t\t0x1eac0, 0x1eac0,\n\t\t0x1eae0, 0x1eae0,\n\t\t0x1eb00, 0x1eb84,\n\t\t0x1ebc0, 0x1ebc8,\n\t\t0x1ec08, 0x1ec0c,\n\t\t0x1ec40, 0x1ec44,\n\t\t0x1ec4c, 0x1ec4c,\n\t\t0x1ee84, 0x1ee90,\n\t\t0x1eec0, 0x1eec0,\n\t\t0x1eee0, 0x1eee0,\n\t\t0x1ef00, 0x1ef84,\n\t\t0x1efc0, 0x1efc8,\n\t\t0x1f008, 0x1f00c,\n\t\t0x1f040, 0x1f044,\n\t\t0x1f04c, 0x1f04c,\n\t\t0x1f284, 0x1f290,\n\t\t0x1f2c0, 0x1f2c0,\n\t\t0x1f2e0, 0x1f2e0,\n\t\t0x1f300, 0x1f384,\n\t\t0x1f3c0, 0x1f3c8,\n\t\t0x1f408, 0x1f40c,\n\t\t0x1f440, 0x1f444,\n\t\t0x1f44c, 0x1f44c,\n\t\t0x1f684, 0x1f690,\n\t\t0x1f6c0, 0x1f6c0,\n\t\t0x1f6e0, 0x1f6e0,\n\t\t0x1f700, 0x1f784,\n\t\t0x1f7c0, 0x1f7c8,\n\t\t0x1f808, 0x1f80c,\n\t\t0x1f840, 0x1f844,\n\t\t0x1f84c, 0x1f84c,\n\t\t0x1fa84, 0x1fa90,\n\t\t0x1fac0, 0x1fac0,\n\t\t0x1fae0, 0x1fae0,\n\t\t0x1fb00, 0x1fb84,\n\t\t0x1fbc0, 0x1fbc8,\n\t\t0x1fc08, 0x1fc0c,\n\t\t0x1fc40, 0x1fc44,\n\t\t0x1fc4c, 0x1fc4c,\n\t\t0x1fe84, 0x1fe90,\n\t\t0x1fec0, 0x1fec0,\n\t\t0x1fee0, 0x1fee0,\n\t\t0x1ff00, 0x1ff84,\n\t\t0x1ffc0, 0x1ffc8,\n\t\t0x30000, 0x30030,\n\t\t0x30100, 0x30168,\n\t\t0x30190, 0x301a0,\n\t\t0x301a8, 0x301b8,\n\t\t0x301c4, 0x301c8,\n\t\t0x301d0, 0x301d0,\n\t\t0x30200, 0x30320,\n\t\t0x30400, 0x304b4,\n\t\t0x304c0, 0x3052c,\n\t\t0x30540, 0x3061c,\n\t\t0x30800, 0x308a0,\n\t\t0x308c0, 0x30908,\n\t\t0x30910, 0x309b8,\n\t\t0x30a00, 0x30a04,\n\t\t0x30a0c, 0x30a14,\n\t\t0x30a1c, 0x30a2c,\n\t\t0x30a44, 0x30a50,\n\t\t0x30a74, 0x30a74,\n\t\t0x30a7c, 0x30afc,\n\t\t0x30b08, 0x30c24,\n\t\t0x30d00, 0x30d14,\n\t\t0x30d1c, 0x30d3c,\n\t\t0x30d44, 0x30d4c,\n\t\t0x30d54, 0x30d74,\n\t\t0x30d7c, 0x30d7c,\n\t\t0x30de0, 0x30de0,\n\t\t0x30e00, 0x30ed4,\n\t\t0x30f00, 0x30fa4,\n\t\t0x30fc0, 0x30fc4,\n\t\t0x31000, 0x31004,\n\t\t0x31080, 0x310fc,\n\t\t0x31208, 0x31220,\n\t\t0x3123c, 0x31254,\n\t\t0x31300, 0x31300,\n\t\t0x31308, 0x3131c,\n\t\t0x31338, 0x3133c,\n\t\t0x31380, 0x31380,\n\t\t0x31388, 0x313a8,\n\t\t0x313b4, 0x313b4,\n\t\t0x31400, 0x31420,\n\t\t0x31438, 0x3143c,\n\t\t0x31480, 0x31480,\n\t\t0x314a8, 0x314a8,\n\t\t0x314b0, 0x314b4,\n\t\t0x314c8, 0x314d4,\n\t\t0x31a40, 0x31a4c,\n\t\t0x31af0, 0x31b20,\n\t\t0x31b38, 0x31b3c,\n\t\t0x31b80, 0x31b80,\n\t\t0x31ba8, 0x31ba8,\n\t\t0x31bb0, 0x31bb4,\n\t\t0x31bc8, 0x31bd4,\n\t\t0x32140, 0x3218c,\n\t\t0x321f0, 0x321f4,\n\t\t0x32200, 0x32200,\n\t\t0x32218, 0x32218,\n\t\t0x32400, 0x32400,\n\t\t0x32408, 0x3241c,\n\t\t0x32618, 0x32620,\n\t\t0x32664, 0x32664,\n\t\t0x326a8, 0x326a8,\n\t\t0x326ec, 0x326ec,\n\t\t0x32a00, 0x32abc,\n\t\t0x32b00, 0x32b18,\n\t\t0x32b20, 0x32b38,\n\t\t0x32b40, 0x32b58,\n\t\t0x32b60, 0x32b78,\n\t\t0x32c00, 0x32c00,\n\t\t0x32c08, 0x32c3c,\n\t\t0x33000, 0x3302c,\n\t\t0x33034, 0x33050,\n\t\t0x33058, 0x33058,\n\t\t0x33060, 0x3308c,\n\t\t0x3309c, 0x330ac,\n\t\t0x330c0, 0x330c0,\n\t\t0x330c8, 0x330d0,\n\t\t0x330d8, 0x330e0,\n\t\t0x330ec, 0x3312c,\n\t\t0x33134, 0x33150,\n\t\t0x33158, 0x33158,\n\t\t0x33160, 0x3318c,\n\t\t0x3319c, 0x331ac,\n\t\t0x331c0, 0x331c0,\n\t\t0x331c8, 0x331d0,\n\t\t0x331d8, 0x331e0,\n\t\t0x331ec, 0x33290,\n\t\t0x33298, 0x332c4,\n\t\t0x332e4, 0x33390,\n\t\t0x33398, 0x333c4,\n\t\t0x333e4, 0x3342c,\n\t\t0x33434, 0x33450,\n\t\t0x33458, 0x33458,\n\t\t0x33460, 0x3348c,\n\t\t0x3349c, 0x334ac,\n\t\t0x334c0, 0x334c0,\n\t\t0x334c8, 0x334d0,\n\t\t0x334d8, 0x334e0,\n\t\t0x334ec, 0x3352c,\n\t\t0x33534, 0x33550,\n\t\t0x33558, 0x33558,\n\t\t0x33560, 0x3358c,\n\t\t0x3359c, 0x335ac,\n\t\t0x335c0, 0x335c0,\n\t\t0x335c8, 0x335d0,\n\t\t0x335d8, 0x335e0,\n\t\t0x335ec, 0x33690,\n\t\t0x33698, 0x336c4,\n\t\t0x336e4, 0x33790,\n\t\t0x33798, 0x337c4,\n\t\t0x337e4, 0x337fc,\n\t\t0x33814, 0x33814,\n\t\t0x33854, 0x33868,\n\t\t0x33880, 0x3388c,\n\t\t0x338c0, 0x338d0,\n\t\t0x338e8, 0x338ec,\n\t\t0x33900, 0x3392c,\n\t\t0x33934, 0x33950,\n\t\t0x33958, 0x33958,\n\t\t0x33960, 0x3398c,\n\t\t0x3399c, 0x339ac,\n\t\t0x339c0, 0x339c0,\n\t\t0x339c8, 0x339d0,\n\t\t0x339d8, 0x339e0,\n\t\t0x339ec, 0x33a90,\n\t\t0x33a98, 0x33ac4,\n\t\t0x33ae4, 0x33b10,\n\t\t0x33b24, 0x33b28,\n\t\t0x33b38, 0x33b50,\n\t\t0x33bf0, 0x33c10,\n\t\t0x33c24, 0x33c28,\n\t\t0x33c38, 0x33c50,\n\t\t0x33cf0, 0x33cfc,\n\t\t0x34000, 0x34030,\n\t\t0x34100, 0x34168,\n\t\t0x34190, 0x341a0,\n\t\t0x341a8, 0x341b8,\n\t\t0x341c4, 0x341c8,\n\t\t0x341d0, 0x341d0,\n\t\t0x34200, 0x34320,\n\t\t0x34400, 0x344b4,\n\t\t0x344c0, 0x3452c,\n\t\t0x34540, 0x3461c,\n\t\t0x34800, 0x348a0,\n\t\t0x348c0, 0x34908,\n\t\t0x34910, 0x349b8,\n\t\t0x34a00, 0x34a04,\n\t\t0x34a0c, 0x34a14,\n\t\t0x34a1c, 0x34a2c,\n\t\t0x34a44, 0x34a50,\n\t\t0x34a74, 0x34a74,\n\t\t0x34a7c, 0x34afc,\n\t\t0x34b08, 0x34c24,\n\t\t0x34d00, 0x34d14,\n\t\t0x34d1c, 0x34d3c,\n\t\t0x34d44, 0x34d4c,\n\t\t0x34d54, 0x34d74,\n\t\t0x34d7c, 0x34d7c,\n\t\t0x34de0, 0x34de0,\n\t\t0x34e00, 0x34ed4,\n\t\t0x34f00, 0x34fa4,\n\t\t0x34fc0, 0x34fc4,\n\t\t0x35000, 0x35004,\n\t\t0x35080, 0x350fc,\n\t\t0x35208, 0x35220,\n\t\t0x3523c, 0x35254,\n\t\t0x35300, 0x35300,\n\t\t0x35308, 0x3531c,\n\t\t0x35338, 0x3533c,\n\t\t0x35380, 0x35380,\n\t\t0x35388, 0x353a8,\n\t\t0x353b4, 0x353b4,\n\t\t0x35400, 0x35420,\n\t\t0x35438, 0x3543c,\n\t\t0x35480, 0x35480,\n\t\t0x354a8, 0x354a8,\n\t\t0x354b0, 0x354b4,\n\t\t0x354c8, 0x354d4,\n\t\t0x35a40, 0x35a4c,\n\t\t0x35af0, 0x35b20,\n\t\t0x35b38, 0x35b3c,\n\t\t0x35b80, 0x35b80,\n\t\t0x35ba8, 0x35ba8,\n\t\t0x35bb0, 0x35bb4,\n\t\t0x35bc8, 0x35bd4,\n\t\t0x36140, 0x3618c,\n\t\t0x361f0, 0x361f4,\n\t\t0x36200, 0x36200,\n\t\t0x36218, 0x36218,\n\t\t0x36400, 0x36400,\n\t\t0x36408, 0x3641c,\n\t\t0x36618, 0x36620,\n\t\t0x36664, 0x36664,\n\t\t0x366a8, 0x366a8,\n\t\t0x366ec, 0x366ec,\n\t\t0x36a00, 0x36abc,\n\t\t0x36b00, 0x36b18,\n\t\t0x36b20, 0x36b38,\n\t\t0x36b40, 0x36b58,\n\t\t0x36b60, 0x36b78,\n\t\t0x36c00, 0x36c00,\n\t\t0x36c08, 0x36c3c,\n\t\t0x37000, 0x3702c,\n\t\t0x37034, 0x37050,\n\t\t0x37058, 0x37058,\n\t\t0x37060, 0x3708c,\n\t\t0x3709c, 0x370ac,\n\t\t0x370c0, 0x370c0,\n\t\t0x370c8, 0x370d0,\n\t\t0x370d8, 0x370e0,\n\t\t0x370ec, 0x3712c,\n\t\t0x37134, 0x37150,\n\t\t0x37158, 0x37158,\n\t\t0x37160, 0x3718c,\n\t\t0x3719c, 0x371ac,\n\t\t0x371c0, 0x371c0,\n\t\t0x371c8, 0x371d0,\n\t\t0x371d8, 0x371e0,\n\t\t0x371ec, 0x37290,\n\t\t0x37298, 0x372c4,\n\t\t0x372e4, 0x37390,\n\t\t0x37398, 0x373c4,\n\t\t0x373e4, 0x3742c,\n\t\t0x37434, 0x37450,\n\t\t0x37458, 0x37458,\n\t\t0x37460, 0x3748c,\n\t\t0x3749c, 0x374ac,\n\t\t0x374c0, 0x374c0,\n\t\t0x374c8, 0x374d0,\n\t\t0x374d8, 0x374e0,\n\t\t0x374ec, 0x3752c,\n\t\t0x37534, 0x37550,\n\t\t0x37558, 0x37558,\n\t\t0x37560, 0x3758c,\n\t\t0x3759c, 0x375ac,\n\t\t0x375c0, 0x375c0,\n\t\t0x375c8, 0x375d0,\n\t\t0x375d8, 0x375e0,\n\t\t0x375ec, 0x37690,\n\t\t0x37698, 0x376c4,\n\t\t0x376e4, 0x37790,\n\t\t0x37798, 0x377c4,\n\t\t0x377e4, 0x377fc,\n\t\t0x37814, 0x37814,\n\t\t0x37854, 0x37868,\n\t\t0x37880, 0x3788c,\n\t\t0x378c0, 0x378d0,\n\t\t0x378e8, 0x378ec,\n\t\t0x37900, 0x3792c,\n\t\t0x37934, 0x37950,\n\t\t0x37958, 0x37958,\n\t\t0x37960, 0x3798c,\n\t\t0x3799c, 0x379ac,\n\t\t0x379c0, 0x379c0,\n\t\t0x379c8, 0x379d0,\n\t\t0x379d8, 0x379e0,\n\t\t0x379ec, 0x37a90,\n\t\t0x37a98, 0x37ac4,\n\t\t0x37ae4, 0x37b10,\n\t\t0x37b24, 0x37b28,\n\t\t0x37b38, 0x37b50,\n\t\t0x37bf0, 0x37c10,\n\t\t0x37c24, 0x37c28,\n\t\t0x37c38, 0x37c50,\n\t\t0x37cf0, 0x37cfc,\n\t\t0x40040, 0x40040,\n\t\t0x40080, 0x40084,\n\t\t0x40100, 0x40100,\n\t\t0x40140, 0x401bc,\n\t\t0x40200, 0x40214,\n\t\t0x40228, 0x40228,\n\t\t0x40240, 0x40258,\n\t\t0x40280, 0x40280,\n\t\t0x40304, 0x40304,\n\t\t0x40330, 0x4033c,\n\t\t0x41304, 0x413c8,\n\t\t0x413d0, 0x413dc,\n\t\t0x413f0, 0x413f0,\n\t\t0x41400, 0x4140c,\n\t\t0x41414, 0x4141c,\n\t\t0x41480, 0x414d0,\n\t\t0x44000, 0x4407c,\n\t\t0x440c0, 0x441ac,\n\t\t0x441b4, 0x4427c,\n\t\t0x442c0, 0x443ac,\n\t\t0x443b4, 0x4447c,\n\t\t0x444c0, 0x445ac,\n\t\t0x445b4, 0x4467c,\n\t\t0x446c0, 0x447ac,\n\t\t0x447b4, 0x4487c,\n\t\t0x448c0, 0x449ac,\n\t\t0x449b4, 0x44a7c,\n\t\t0x44ac0, 0x44bac,\n\t\t0x44bb4, 0x44c7c,\n\t\t0x44cc0, 0x44dac,\n\t\t0x44db4, 0x44e7c,\n\t\t0x44ec0, 0x44fac,\n\t\t0x44fb4, 0x4507c,\n\t\t0x450c0, 0x451ac,\n\t\t0x451b4, 0x451fc,\n\t\t0x45800, 0x45804,\n\t\t0x45810, 0x45830,\n\t\t0x45840, 0x45860,\n\t\t0x45868, 0x45868,\n\t\t0x45880, 0x45884,\n\t\t0x458a0, 0x458b0,\n\t\t0x45a00, 0x45a04,\n\t\t0x45a10, 0x45a30,\n\t\t0x45a40, 0x45a60,\n\t\t0x45a68, 0x45a68,\n\t\t0x45a80, 0x45a84,\n\t\t0x45aa0, 0x45ab0,\n\t\t0x460c0, 0x460e4,\n\t\t0x47000, 0x4703c,\n\t\t0x47044, 0x4708c,\n\t\t0x47200, 0x47250,\n\t\t0x47400, 0x47408,\n\t\t0x47414, 0x47420,\n\t\t0x47600, 0x47618,\n\t\t0x47800, 0x47814,\n\t\t0x47820, 0x4782c,\n\t\t0x50000, 0x50084,\n\t\t0x50090, 0x500cc,\n\t\t0x50300, 0x50384,\n\t\t0x50400, 0x50400,\n\t\t0x50800, 0x50884,\n\t\t0x50890, 0x508cc,\n\t\t0x50b00, 0x50b84,\n\t\t0x50c00, 0x50c00,\n\t\t0x51000, 0x51020,\n\t\t0x51028, 0x510b0,\n\t\t0x51300, 0x51324,\n\t};\n\n\tu32 *buf_end = (u32 *)((char *)buf + buf_size);\n\tconst unsigned int *reg_ranges;\n\tint reg_ranges_size, range;\n\tunsigned int chip_version = CHELSIO_CHIP_VERSION(adap->params.chip);\n\n\t \n\tswitch (chip_version) {\n\tcase CHELSIO_T4:\n\t\treg_ranges = t4_reg_ranges;\n\t\treg_ranges_size = ARRAY_SIZE(t4_reg_ranges);\n\t\tbreak;\n\n\tcase CHELSIO_T5:\n\t\treg_ranges = t5_reg_ranges;\n\t\treg_ranges_size = ARRAY_SIZE(t5_reg_ranges);\n\t\tbreak;\n\n\tcase CHELSIO_T6:\n\t\treg_ranges = t6_reg_ranges;\n\t\treg_ranges_size = ARRAY_SIZE(t6_reg_ranges);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Unsupported chip version %d\\n\", chip_version);\n\t\treturn;\n\t}\n\n\t \n\tmemset(buf, 0, buf_size);\n\tfor (range = 0; range < reg_ranges_size; range += 2) {\n\t\tunsigned int reg = reg_ranges[range];\n\t\tunsigned int last_reg = reg_ranges[range + 1];\n\t\tu32 *bufp = (u32 *)((char *)buf + reg);\n\n\t\t \n\t\twhile (reg <= last_reg && bufp < buf_end) {\n\t\t\t*bufp++ = t4_read_reg(adap, reg);\n\t\t\treg += sizeof(u32);\n\t\t}\n\t}\n}\n\n#define EEPROM_STAT_ADDR   0x7bfc\n#define VPD_BASE           0x400\n#define VPD_BASE_OLD       0\n#define VPD_LEN            1024\n\n \nint t4_eeprom_ptov(unsigned int phys_addr, unsigned int fn, unsigned int sz)\n{\n\tfn *= sz;\n\tif (phys_addr < 1024)\n\t\treturn phys_addr + (31 << 10);\n\tif (phys_addr < 1024 + fn)\n\t\treturn 31744 - fn + phys_addr - 1024;\n\tif (phys_addr < EEPROMSIZE)\n\t\treturn phys_addr - 1024 - fn;\n\treturn -EINVAL;\n}\n\n \nint t4_seeprom_wp(struct adapter *adapter, bool enable)\n{\n\tunsigned int v = enable ? 0xc : 0;\n\tint ret = pci_write_vpd(adapter->pdev, EEPROM_STAT_ADDR, 4, &v);\n\treturn ret < 0 ? ret : 0;\n}\n\n \nint t4_get_raw_vpd_params(struct adapter *adapter, struct vpd_params *p)\n{\n\tunsigned int id_len, pn_len, sn_len, na_len;\n\tint id, sn, pn, na, addr, ret = 0;\n\tu8 *vpd, base_val = 0;\n\n\tvpd = vmalloc(VPD_LEN);\n\tif (!vpd)\n\t\treturn -ENOMEM;\n\n\t \n\tret = pci_read_vpd(adapter->pdev, VPD_BASE, 1, &base_val);\n\tif (ret < 0)\n\t\tgoto out;\n\n\taddr = base_val == PCI_VPD_LRDT_ID_STRING ? VPD_BASE : VPD_BASE_OLD;\n\n\tret = pci_read_vpd(adapter->pdev, addr, VPD_LEN, vpd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = pci_vpd_find_id_string(vpd, VPD_LEN, &id_len);\n\tif (ret < 0)\n\t\tgoto out;\n\tid = ret;\n\n\tret = pci_vpd_check_csum(vpd, VPD_LEN);\n\tif (ret) {\n\t\tdev_err(adapter->pdev_dev, \"VPD checksum incorrect or missing\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = pci_vpd_find_ro_info_keyword(vpd, VPD_LEN,\n\t\t\t\t\t   PCI_VPD_RO_KEYWORD_SERIALNO, &sn_len);\n\tif (ret < 0)\n\t\tgoto out;\n\tsn = ret;\n\n\tret = pci_vpd_find_ro_info_keyword(vpd, VPD_LEN,\n\t\t\t\t\t   PCI_VPD_RO_KEYWORD_PARTNO, &pn_len);\n\tif (ret < 0)\n\t\tgoto out;\n\tpn = ret;\n\n\tret = pci_vpd_find_ro_info_keyword(vpd, VPD_LEN, \"NA\", &na_len);\n\tif (ret < 0)\n\t\tgoto out;\n\tna = ret;\n\n\tmemcpy(p->id, vpd + id, min_t(unsigned int, id_len, ID_LEN));\n\tstrim(p->id);\n\tmemcpy(p->sn, vpd + sn, min_t(unsigned int, sn_len, SERNUM_LEN));\n\tstrim(p->sn);\n\tmemcpy(p->pn, vpd + pn, min_t(unsigned int, pn_len, PN_LEN));\n\tstrim(p->pn);\n\tmemcpy(p->na, vpd + na, min_t(unsigned int, na_len, MACADDR_LEN));\n\tstrim(p->na);\n\nout:\n\tvfree(vpd);\n\tif (ret < 0) {\n\t\tdev_err(adapter->pdev_dev, \"error reading VPD\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint t4_get_vpd_params(struct adapter *adapter, struct vpd_params *p)\n{\n\tu32 cclk_param, cclk_val;\n\tint ret;\n\n\t \n\tret = t4_get_raw_vpd_params(adapter, p);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcclk_param = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t      FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_CCLK));\n\tret = t4_query_params(adapter, adapter->mbox, adapter->pf, 0,\n\t\t\t      1, &cclk_param, &cclk_val);\n\n\tif (ret)\n\t\treturn ret;\n\tp->cclk = cclk_val;\n\n\treturn 0;\n}\n\n \nint t4_get_pfres(struct adapter *adapter)\n{\n\tstruct pf_resources *pfres = &adapter->params.pfres;\n\tstruct fw_pfvf_cmd cmd, rpl;\n\tint v;\n\tu32 word;\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PFVF_CMD) |\n\t\t\t\t    FW_CMD_REQUEST_F |\n\t\t\t\t    FW_CMD_READ_F |\n\t\t\t\t    FW_PFVF_CMD_PFN_V(adapter->pf) |\n\t\t\t\t    FW_PFVF_CMD_VFN_V(0));\n\tcmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\n\tv = t4_wr_mbox(adapter, adapter->mbox, &cmd, sizeof(cmd), &rpl);\n\tif (v != FW_SUCCESS)\n\t\treturn v;\n\n\t \n\tword = be32_to_cpu(rpl.niqflint_niq);\n\tpfres->niqflint = FW_PFVF_CMD_NIQFLINT_G(word);\n\tpfres->niq = FW_PFVF_CMD_NIQ_G(word);\n\n\tword = be32_to_cpu(rpl.type_to_neq);\n\tpfres->neq = FW_PFVF_CMD_NEQ_G(word);\n\tpfres->pmask = FW_PFVF_CMD_PMASK_G(word);\n\n\tword = be32_to_cpu(rpl.tc_to_nexactf);\n\tpfres->tc = FW_PFVF_CMD_TC_G(word);\n\tpfres->nvi = FW_PFVF_CMD_NVI_G(word);\n\tpfres->nexactf = FW_PFVF_CMD_NEXACTF_G(word);\n\n\tword = be32_to_cpu(rpl.r_caps_to_nethctrl);\n\tpfres->r_caps = FW_PFVF_CMD_R_CAPS_G(word);\n\tpfres->wx_caps = FW_PFVF_CMD_WX_CAPS_G(word);\n\tpfres->nethctrl = FW_PFVF_CMD_NETHCTRL_G(word);\n\n\treturn 0;\n}\n\n \nenum {\n\tSF_ATTEMPTS = 10,              \n\n\t \n\tSF_PROG_PAGE    = 2,           \n\tSF_WR_DISABLE   = 4,           \n\tSF_RD_STATUS    = 5,           \n\tSF_WR_ENABLE    = 6,           \n\tSF_RD_DATA_FAST = 0xb,         \n\tSF_RD_ID        = 0x9f,        \n\tSF_ERASE_SECTOR = 0xd8,        \n};\n\n \nstatic int sf1_read(struct adapter *adapter, unsigned int byte_cnt, int cont,\n\t\t    int lock, u32 *valp)\n{\n\tint ret;\n\n\tif (!byte_cnt || byte_cnt > 4)\n\t\treturn -EINVAL;\n\tif (t4_read_reg(adapter, SF_OP_A) & SF_BUSY_F)\n\t\treturn -EBUSY;\n\tt4_write_reg(adapter, SF_OP_A, SF_LOCK_V(lock) |\n\t\t     SF_CONT_V(cont) | BYTECNT_V(byte_cnt - 1));\n\tret = t4_wait_op_done(adapter, SF_OP_A, SF_BUSY_F, 0, SF_ATTEMPTS, 5);\n\tif (!ret)\n\t\t*valp = t4_read_reg(adapter, SF_DATA_A);\n\treturn ret;\n}\n\n \nstatic int sf1_write(struct adapter *adapter, unsigned int byte_cnt, int cont,\n\t\t     int lock, u32 val)\n{\n\tif (!byte_cnt || byte_cnt > 4)\n\t\treturn -EINVAL;\n\tif (t4_read_reg(adapter, SF_OP_A) & SF_BUSY_F)\n\t\treturn -EBUSY;\n\tt4_write_reg(adapter, SF_DATA_A, val);\n\tt4_write_reg(adapter, SF_OP_A, SF_LOCK_V(lock) |\n\t\t     SF_CONT_V(cont) | BYTECNT_V(byte_cnt - 1) | OP_V(1));\n\treturn t4_wait_op_done(adapter, SF_OP_A, SF_BUSY_F, 0, SF_ATTEMPTS, 5);\n}\n\n \nstatic int flash_wait_op(struct adapter *adapter, int attempts, int delay)\n{\n\tint ret;\n\tu32 status;\n\n\twhile (1) {\n\t\tif ((ret = sf1_write(adapter, 1, 1, 1, SF_RD_STATUS)) != 0 ||\n\t\t    (ret = sf1_read(adapter, 1, 0, 1, &status)) != 0)\n\t\t\treturn ret;\n\t\tif (!(status & 1))\n\t\t\treturn 0;\n\t\tif (--attempts == 0)\n\t\t\treturn -EAGAIN;\n\t\tif (delay)\n\t\t\tmsleep(delay);\n\t}\n}\n\n \nint t4_read_flash(struct adapter *adapter, unsigned int addr,\n\t\t  unsigned int nwords, u32 *data, int byte_oriented)\n{\n\tint ret;\n\n\tif (addr + nwords * sizeof(u32) > adapter->params.sf_size || (addr & 3))\n\t\treturn -EINVAL;\n\n\taddr = swab32(addr) | SF_RD_DATA_FAST;\n\n\tif ((ret = sf1_write(adapter, 4, 1, 0, addr)) != 0 ||\n\t    (ret = sf1_read(adapter, 1, 1, 0, data)) != 0)\n\t\treturn ret;\n\n\tfor ( ; nwords; nwords--, data++) {\n\t\tret = sf1_read(adapter, 4, nwords > 1, nwords == 1, data);\n\t\tif (nwords == 1)\n\t\t\tt4_write_reg(adapter, SF_OP_A, 0);     \n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (byte_oriented)\n\t\t\t*data = (__force __u32)(cpu_to_be32(*data));\n\t}\n\treturn 0;\n}\n\n \nstatic int t4_write_flash(struct adapter *adapter, unsigned int addr,\n\t\t\t  unsigned int n, const u8 *data, bool byte_oriented)\n{\n\tunsigned int i, c, left, val, offset = addr & 0xff;\n\tu32 buf[64];\n\tint ret;\n\n\tif (addr >= adapter->params.sf_size || offset + n > SF_PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tval = swab32(addr) | SF_PROG_PAGE;\n\n\tif ((ret = sf1_write(adapter, 1, 0, 1, SF_WR_ENABLE)) != 0 ||\n\t    (ret = sf1_write(adapter, 4, 1, 1, val)) != 0)\n\t\tgoto unlock;\n\n\tfor (left = n; left; left -= c, data += c) {\n\t\tc = min(left, 4U);\n\t\tfor (val = 0, i = 0; i < c; ++i) {\n\t\t\tif (byte_oriented)\n\t\t\t\tval = (val << 8) + data[i];\n\t\t\telse\n\t\t\t\tval = (val << 8) + data[c - i - 1];\n\t\t}\n\n\t\tret = sf1_write(adapter, c, c != left, 1, val);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\tret = flash_wait_op(adapter, 8, 1);\n\tif (ret)\n\t\tgoto unlock;\n\n\tt4_write_reg(adapter, SF_OP_A, 0);     \n\n\t \n\tret = t4_read_flash(adapter, addr & ~0xff, ARRAY_SIZE(buf), buf,\n\t\t\t    byte_oriented);\n\tif (ret)\n\t\treturn ret;\n\n\tif (memcmp(data - n, (u8 *)buf + offset, n)) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"failed to correctly write the flash page at %#x\\n\",\n\t\t\taddr);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n\nunlock:\n\tt4_write_reg(adapter, SF_OP_A, 0);     \n\treturn ret;\n}\n\n \nint t4_get_fw_version(struct adapter *adapter, u32 *vers)\n{\n\treturn t4_read_flash(adapter, FLASH_FW_START +\n\t\t\t     offsetof(struct fw_hdr, fw_ver), 1,\n\t\t\t     vers, 0);\n}\n\n \nint t4_get_bs_version(struct adapter *adapter, u32 *vers)\n{\n\treturn t4_read_flash(adapter, FLASH_FWBOOTSTRAP_START +\n\t\t\t     offsetof(struct fw_hdr, fw_ver), 1,\n\t\t\t     vers, 0);\n}\n\n \nint t4_get_tp_version(struct adapter *adapter, u32 *vers)\n{\n\treturn t4_read_flash(adapter, FLASH_FW_START +\n\t\t\t     offsetof(struct fw_hdr, tp_microcode_ver),\n\t\t\t     1, vers, 0);\n}\n\n \nint t4_get_exprom_version(struct adapter *adap, u32 *vers)\n{\n\tstruct exprom_header {\n\t\tunsigned char hdr_arr[16];\t \n\t\tunsigned char hdr_ver[4];\t \n\t} *hdr;\n\tu32 exprom_header_buf[DIV_ROUND_UP(sizeof(struct exprom_header),\n\t\t\t\t\t   sizeof(u32))];\n\tint ret;\n\n\tret = t4_read_flash(adap, FLASH_EXP_ROM_START,\n\t\t\t    ARRAY_SIZE(exprom_header_buf), exprom_header_buf,\n\t\t\t    0);\n\tif (ret)\n\t\treturn ret;\n\n\thdr = (struct exprom_header *)exprom_header_buf;\n\tif (hdr->hdr_arr[0] != 0x55 || hdr->hdr_arr[1] != 0xaa)\n\t\treturn -ENOENT;\n\n\t*vers = (FW_HDR_FW_VER_MAJOR_V(hdr->hdr_ver[0]) |\n\t\t FW_HDR_FW_VER_MINOR_V(hdr->hdr_ver[1]) |\n\t\t FW_HDR_FW_VER_MICRO_V(hdr->hdr_ver[2]) |\n\t\t FW_HDR_FW_VER_BUILD_V(hdr->hdr_ver[3]));\n\treturn 0;\n}\n\n \nint t4_get_vpd_version(struct adapter *adapter, u32 *vers)\n{\n\tu32 vpdrev_param;\n\tint ret;\n\n\tvpdrev_param = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t\tFW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_VPDREV));\n\tret = t4_query_params(adapter, adapter->mbox, adapter->pf, 0,\n\t\t\t      1, &vpdrev_param, vers);\n\tif (ret)\n\t\t*vers = 0;\n\treturn ret;\n}\n\n \nint t4_get_scfg_version(struct adapter *adapter, u32 *vers)\n{\n\tu32 scfgrev_param;\n\tint ret;\n\n\tscfgrev_param = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_SCFGREV));\n\tret = t4_query_params(adapter, adapter->mbox, adapter->pf, 0,\n\t\t\t      1, &scfgrev_param, vers);\n\tif (ret)\n\t\t*vers = 0;\n\treturn ret;\n}\n\n \nint t4_get_version_info(struct adapter *adapter)\n{\n\tint ret = 0;\n\n\t#define FIRST_RET(__getvinfo) \\\n\tdo { \\\n\t\tint __ret = __getvinfo; \\\n\t\tif (__ret && !ret) \\\n\t\t\tret = __ret; \\\n\t} while (0)\n\n\tFIRST_RET(t4_get_fw_version(adapter, &adapter->params.fw_vers));\n\tFIRST_RET(t4_get_bs_version(adapter, &adapter->params.bs_vers));\n\tFIRST_RET(t4_get_tp_version(adapter, &adapter->params.tp_vers));\n\tFIRST_RET(t4_get_exprom_version(adapter, &adapter->params.er_vers));\n\tFIRST_RET(t4_get_scfg_version(adapter, &adapter->params.scfg_vers));\n\tFIRST_RET(t4_get_vpd_version(adapter, &adapter->params.vpd_vers));\n\n\t#undef FIRST_RET\n\treturn ret;\n}\n\n \nvoid t4_dump_version_info(struct adapter *adapter)\n{\n\t \n\tdev_info(adapter->pdev_dev, \"Chelsio %s rev %d\\n\",\n\t\t adapter->params.vpd.id,\n\t\t CHELSIO_CHIP_RELEASE(adapter->params.chip));\n\tdev_info(adapter->pdev_dev, \"S/N: %s, P/N: %s\\n\",\n\t\t adapter->params.vpd.sn, adapter->params.vpd.pn);\n\n\t \n\tif (!adapter->params.fw_vers)\n\t\tdev_warn(adapter->pdev_dev, \"No firmware loaded\\n\");\n\telse\n\t\tdev_info(adapter->pdev_dev, \"Firmware version: %u.%u.%u.%u\\n\",\n\t\t\t FW_HDR_FW_VER_MAJOR_G(adapter->params.fw_vers),\n\t\t\t FW_HDR_FW_VER_MINOR_G(adapter->params.fw_vers),\n\t\t\t FW_HDR_FW_VER_MICRO_G(adapter->params.fw_vers),\n\t\t\t FW_HDR_FW_VER_BUILD_G(adapter->params.fw_vers));\n\n\t \n\tif (!adapter->params.bs_vers)\n\t\tdev_info(adapter->pdev_dev, \"No bootstrap loaded\\n\");\n\telse\n\t\tdev_info(adapter->pdev_dev, \"Bootstrap version: %u.%u.%u.%u\\n\",\n\t\t\t FW_HDR_FW_VER_MAJOR_G(adapter->params.bs_vers),\n\t\t\t FW_HDR_FW_VER_MINOR_G(adapter->params.bs_vers),\n\t\t\t FW_HDR_FW_VER_MICRO_G(adapter->params.bs_vers),\n\t\t\t FW_HDR_FW_VER_BUILD_G(adapter->params.bs_vers));\n\n\t \n\tif (!adapter->params.tp_vers)\n\t\tdev_warn(adapter->pdev_dev, \"No TP Microcode loaded\\n\");\n\telse\n\t\tdev_info(adapter->pdev_dev,\n\t\t\t \"TP Microcode version: %u.%u.%u.%u\\n\",\n\t\t\t FW_HDR_FW_VER_MAJOR_G(adapter->params.tp_vers),\n\t\t\t FW_HDR_FW_VER_MINOR_G(adapter->params.tp_vers),\n\t\t\t FW_HDR_FW_VER_MICRO_G(adapter->params.tp_vers),\n\t\t\t FW_HDR_FW_VER_BUILD_G(adapter->params.tp_vers));\n\n\t \n\tif (!adapter->params.er_vers)\n\t\tdev_info(adapter->pdev_dev, \"No Expansion ROM loaded\\n\");\n\telse\n\t\tdev_info(adapter->pdev_dev,\n\t\t\t \"Expansion ROM version: %u.%u.%u.%u\\n\",\n\t\t\t FW_HDR_FW_VER_MAJOR_G(adapter->params.er_vers),\n\t\t\t FW_HDR_FW_VER_MINOR_G(adapter->params.er_vers),\n\t\t\t FW_HDR_FW_VER_MICRO_G(adapter->params.er_vers),\n\t\t\t FW_HDR_FW_VER_BUILD_G(adapter->params.er_vers));\n\n\t \n\tdev_info(adapter->pdev_dev, \"Serial Configuration version: %#x\\n\",\n\t\t adapter->params.scfg_vers);\n\n\t \n\tdev_info(adapter->pdev_dev, \"VPD version: %#x\\n\",\n\t\t adapter->params.vpd_vers);\n}\n\n \nint t4_check_fw_version(struct adapter *adap)\n{\n\tint i, ret, major, minor, micro;\n\tint exp_major, exp_minor, exp_micro;\n\tunsigned int chip_version = CHELSIO_CHIP_VERSION(adap->params.chip);\n\n\tret = t4_get_fw_version(adap, &adap->params.fw_vers);\n\t \n\tfor (i = 0; (ret == -EBUSY || ret == -EAGAIN) && i < 3; i++)\n\t\tret = t4_get_fw_version(adap, &adap->params.fw_vers);\n\n\tif (ret)\n\t\treturn ret;\n\n\tmajor = FW_HDR_FW_VER_MAJOR_G(adap->params.fw_vers);\n\tminor = FW_HDR_FW_VER_MINOR_G(adap->params.fw_vers);\n\tmicro = FW_HDR_FW_VER_MICRO_G(adap->params.fw_vers);\n\n\tswitch (chip_version) {\n\tcase CHELSIO_T4:\n\t\texp_major = T4FW_MIN_VERSION_MAJOR;\n\t\texp_minor = T4FW_MIN_VERSION_MINOR;\n\t\texp_micro = T4FW_MIN_VERSION_MICRO;\n\t\tbreak;\n\tcase CHELSIO_T5:\n\t\texp_major = T5FW_MIN_VERSION_MAJOR;\n\t\texp_minor = T5FW_MIN_VERSION_MINOR;\n\t\texp_micro = T5FW_MIN_VERSION_MICRO;\n\t\tbreak;\n\tcase CHELSIO_T6:\n\t\texp_major = T6FW_MIN_VERSION_MAJOR;\n\t\texp_minor = T6FW_MIN_VERSION_MINOR;\n\t\texp_micro = T6FW_MIN_VERSION_MICRO;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adap->pdev_dev, \"Unsupported chip type, %x\\n\",\n\t\t\tadap->chip);\n\t\treturn -EINVAL;\n\t}\n\n\tif (major < exp_major || (major == exp_major && minor < exp_minor) ||\n\t    (major == exp_major && minor == exp_minor && micro < exp_micro)) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Card has firmware version %u.%u.%u, minimum \"\n\t\t\t\"supported firmware is %u.%u.%u.\\n\", major, minor,\n\t\t\tmicro, exp_major, exp_minor, exp_micro);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n \nstatic int fw_compatible(const struct fw_hdr *hdr1, const struct fw_hdr *hdr2)\n{\n\n\t \n\tif (hdr1->chip == hdr2->chip && hdr1->fw_ver == hdr2->fw_ver)\n\t\treturn 1;\n\n#define SAME_INTF(x) (hdr1->intfver_##x == hdr2->intfver_##x)\n\tif (hdr1->chip == hdr2->chip && SAME_INTF(nic) && SAME_INTF(vnic) &&\n\t    SAME_INTF(ri) && SAME_INTF(iscsi) && SAME_INTF(fcoe))\n\t\treturn 1;\n#undef SAME_INTF\n\n\treturn 0;\n}\n\n \nstatic int should_install_fs_fw(struct adapter *adap, int card_fw_usable,\n\t\t\t\tint k, int c)\n{\n\tconst char *reason;\n\n\tif (!card_fw_usable) {\n\t\treason = \"incompatible or unusable\";\n\t\tgoto install;\n\t}\n\n\tif (k > c) {\n\t\treason = \"older than the version supported with this driver\";\n\t\tgoto install;\n\t}\n\n\treturn 0;\n\ninstall:\n\tdev_err(adap->pdev_dev, \"firmware on card (%u.%u.%u.%u) is %s, \"\n\t\t\"installing firmware %u.%u.%u.%u on card.\\n\",\n\t\tFW_HDR_FW_VER_MAJOR_G(c), FW_HDR_FW_VER_MINOR_G(c),\n\t\tFW_HDR_FW_VER_MICRO_G(c), FW_HDR_FW_VER_BUILD_G(c), reason,\n\t\tFW_HDR_FW_VER_MAJOR_G(k), FW_HDR_FW_VER_MINOR_G(k),\n\t\tFW_HDR_FW_VER_MICRO_G(k), FW_HDR_FW_VER_BUILD_G(k));\n\n\treturn 1;\n}\n\nint t4_prep_fw(struct adapter *adap, struct fw_info *fw_info,\n\t       const u8 *fw_data, unsigned int fw_size,\n\t       struct fw_hdr *card_fw, enum dev_state state,\n\t       int *reset)\n{\n\tint ret, card_fw_usable, fs_fw_usable;\n\tconst struct fw_hdr *fs_fw;\n\tconst struct fw_hdr *drv_fw;\n\n\tdrv_fw = &fw_info->fw_hdr;\n\n\t \n\tret = t4_read_flash(adap, FLASH_FW_START,\n\t\t\t    sizeof(*card_fw) / sizeof(uint32_t),\n\t\t\t    (uint32_t *)card_fw, 1);\n\tif (ret == 0) {\n\t\tcard_fw_usable = fw_compatible(drv_fw, (const void *)card_fw);\n\t} else {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Unable to read card's firmware header: %d\\n\", ret);\n\t\tcard_fw_usable = 0;\n\t}\n\n\tif (fw_data != NULL) {\n\t\tfs_fw = (const void *)fw_data;\n\t\tfs_fw_usable = fw_compatible(drv_fw, fs_fw);\n\t} else {\n\t\tfs_fw = NULL;\n\t\tfs_fw_usable = 0;\n\t}\n\n\tif (card_fw_usable && card_fw->fw_ver == drv_fw->fw_ver &&\n\t    (!fs_fw_usable || fs_fw->fw_ver == drv_fw->fw_ver)) {\n\t\t \n\t} else if (fs_fw_usable && state == DEV_STATE_UNINIT &&\n\t\t   should_install_fs_fw(adap, card_fw_usable,\n\t\t\t\t\tbe32_to_cpu(fs_fw->fw_ver),\n\t\t\t\t\tbe32_to_cpu(card_fw->fw_ver))) {\n\t\tret = t4_fw_upgrade(adap, adap->mbox, fw_data,\n\t\t\t\t    fw_size, 0);\n\t\tif (ret != 0) {\n\t\t\tdev_err(adap->pdev_dev,\n\t\t\t\t\"failed to install firmware: %d\\n\", ret);\n\t\t\tgoto bye;\n\t\t}\n\n\t\t \n\t\t*card_fw = *fs_fw;\n\t\tcard_fw_usable = 1;\n\t\t*reset = 0;\t \n\t}\n\n\tif (!card_fw_usable) {\n\t\tuint32_t d, c, k;\n\n\t\td = be32_to_cpu(drv_fw->fw_ver);\n\t\tc = be32_to_cpu(card_fw->fw_ver);\n\t\tk = fs_fw ? be32_to_cpu(fs_fw->fw_ver) : 0;\n\n\t\tdev_err(adap->pdev_dev, \"Cannot find a usable firmware: \"\n\t\t\t\"chip state %d, \"\n\t\t\t\"driver compiled with %d.%d.%d.%d, \"\n\t\t\t\"card has %d.%d.%d.%d, filesystem has %d.%d.%d.%d\\n\",\n\t\t\tstate,\n\t\t\tFW_HDR_FW_VER_MAJOR_G(d), FW_HDR_FW_VER_MINOR_G(d),\n\t\t\tFW_HDR_FW_VER_MICRO_G(d), FW_HDR_FW_VER_BUILD_G(d),\n\t\t\tFW_HDR_FW_VER_MAJOR_G(c), FW_HDR_FW_VER_MINOR_G(c),\n\t\t\tFW_HDR_FW_VER_MICRO_G(c), FW_HDR_FW_VER_BUILD_G(c),\n\t\t\tFW_HDR_FW_VER_MAJOR_G(k), FW_HDR_FW_VER_MINOR_G(k),\n\t\t\tFW_HDR_FW_VER_MICRO_G(k), FW_HDR_FW_VER_BUILD_G(k));\n\t\tret = -EINVAL;\n\t\tgoto bye;\n\t}\n\n\t \n\tadap->params.fw_vers = be32_to_cpu(card_fw->fw_ver);\n\tadap->params.tp_vers = be32_to_cpu(card_fw->tp_microcode_ver);\n\nbye:\n\treturn ret;\n}\n\n \nstatic int t4_flash_erase_sectors(struct adapter *adapter, int start, int end)\n{\n\tint ret = 0;\n\n\tif (end >= adapter->params.sf_nsec)\n\t\treturn -EINVAL;\n\n\twhile (start <= end) {\n\t\tif ((ret = sf1_write(adapter, 1, 0, 1, SF_WR_ENABLE)) != 0 ||\n\t\t    (ret = sf1_write(adapter, 4, 0, 1,\n\t\t\t\t     SF_ERASE_SECTOR | (start << 8))) != 0 ||\n\t\t    (ret = flash_wait_op(adapter, 14, 500)) != 0) {\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"erase of flash sector %d failed, error %d\\n\",\n\t\t\t\tstart, ret);\n\t\t\tbreak;\n\t\t}\n\t\tstart++;\n\t}\n\tt4_write_reg(adapter, SF_OP_A, 0);     \n\treturn ret;\n}\n\n \nunsigned int t4_flash_cfg_addr(struct adapter *adapter)\n{\n\tif (adapter->params.sf_size == 0x100000)\n\t\treturn FLASH_FPGA_CFG_START;\n\telse\n\t\treturn FLASH_CFG_START;\n}\n\n \nstatic bool t4_fw_matches_chip(const struct adapter *adap,\n\t\t\t       const struct fw_hdr *hdr)\n{\n\t \n\tif ((is_t4(adap->params.chip) && hdr->chip == FW_HDR_CHIP_T4) ||\n\t    (is_t5(adap->params.chip) && hdr->chip == FW_HDR_CHIP_T5) ||\n\t    (is_t6(adap->params.chip) && hdr->chip == FW_HDR_CHIP_T6))\n\t\treturn true;\n\n\tdev_err(adap->pdev_dev,\n\t\t\"FW image (%d) is not suitable for this adapter (%d)\\n\",\n\t\thdr->chip, CHELSIO_CHIP_VERSION(adap->params.chip));\n\treturn false;\n}\n\n \nint t4_load_fw(struct adapter *adap, const u8 *fw_data, unsigned int size)\n{\n\tu32 csum;\n\tint ret, addr;\n\tunsigned int i;\n\tu8 first_page[SF_PAGE_SIZE];\n\tconst __be32 *p = (const __be32 *)fw_data;\n\tconst struct fw_hdr *hdr = (const struct fw_hdr *)fw_data;\n\tunsigned int sf_sec_size = adap->params.sf_size / adap->params.sf_nsec;\n\tunsigned int fw_start_sec = FLASH_FW_START_SEC;\n\tunsigned int fw_size = FLASH_FW_MAX_SIZE;\n\tunsigned int fw_start = FLASH_FW_START;\n\n\tif (!size) {\n\t\tdev_err(adap->pdev_dev, \"FW image has no data\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (size & 511) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"FW image size not multiple of 512 bytes\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((unsigned int)be16_to_cpu(hdr->len512) * 512 != size) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"FW image size differs from size in FW header\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (size > fw_size) {\n\t\tdev_err(adap->pdev_dev, \"FW image too large, max is %u bytes\\n\",\n\t\t\tfw_size);\n\t\treturn -EFBIG;\n\t}\n\tif (!t4_fw_matches_chip(adap, hdr))\n\t\treturn -EINVAL;\n\n\tfor (csum = 0, i = 0; i < size / sizeof(csum); i++)\n\t\tcsum += be32_to_cpu(p[i]);\n\n\tif (csum != 0xffffffff) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"corrupted firmware image, checksum %#x\\n\", csum);\n\t\treturn -EINVAL;\n\t}\n\n\ti = DIV_ROUND_UP(size, sf_sec_size);         \n\tret = t4_flash_erase_sectors(adap, fw_start_sec, fw_start_sec + i - 1);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tmemcpy(first_page, fw_data, SF_PAGE_SIZE);\n\t((struct fw_hdr *)first_page)->fw_ver = cpu_to_be32(0xffffffff);\n\tret = t4_write_flash(adap, fw_start, SF_PAGE_SIZE, first_page, true);\n\tif (ret)\n\t\tgoto out;\n\n\taddr = fw_start;\n\tfor (size -= SF_PAGE_SIZE; size; size -= SF_PAGE_SIZE) {\n\t\taddr += SF_PAGE_SIZE;\n\t\tfw_data += SF_PAGE_SIZE;\n\t\tret = t4_write_flash(adap, addr, SF_PAGE_SIZE, fw_data, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = t4_write_flash(adap, fw_start + offsetof(struct fw_hdr, fw_ver),\n\t\t\t     sizeof(hdr->fw_ver), (const u8 *)&hdr->fw_ver,\n\t\t\t     true);\nout:\n\tif (ret)\n\t\tdev_err(adap->pdev_dev, \"firmware download failed, error %d\\n\",\n\t\t\tret);\n\telse\n\t\tret = t4_get_fw_version(adap, &adap->params.fw_vers);\n\treturn ret;\n}\n\n \nint t4_phy_fw_ver(struct adapter *adap, int *phy_fw_ver)\n{\n\tu32 param, val;\n\tint ret;\n\n\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_PHYFW) |\n\t\t FW_PARAMS_PARAM_Y_V(adap->params.portvec) |\n\t\t FW_PARAMS_PARAM_Z_V(FW_PARAMS_PARAM_DEV_PHYFW_VERSION));\n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1,\n\t\t\t      &param, &val);\n\tif (ret)\n\t\treturn ret;\n\t*phy_fw_ver = val;\n\treturn 0;\n}\n\n \nint t4_load_phy_fw(struct adapter *adap, int win,\n\t\t   int (*phy_fw_version)(const u8 *, size_t),\n\t\t   const u8 *phy_fw_data, size_t phy_fw_size)\n{\n\tint cur_phy_fw_ver = 0, new_phy_fw_vers = 0;\n\tunsigned long mtype = 0, maddr = 0;\n\tu32 param, val;\n\tint ret;\n\n\t \n\tif (phy_fw_version) {\n\t\tnew_phy_fw_vers = phy_fw_version(phy_fw_data, phy_fw_size);\n\t\tret = t4_phy_fw_ver(adap, &cur_phy_fw_ver);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (cur_phy_fw_ver >= new_phy_fw_vers) {\n\t\t\tCH_WARN(adap, \"PHY Firmware already up-to-date, \"\n\t\t\t\t\"version %#x\\n\", cur_phy_fw_ver);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_PHYFW) |\n\t\t FW_PARAMS_PARAM_Y_V(adap->params.portvec) |\n\t\t FW_PARAMS_PARAM_Z_V(FW_PARAMS_PARAM_DEV_PHYFW_DOWNLOAD));\n\tval = phy_fw_size;\n\tret = t4_query_params_rw(adap, adap->mbox, adap->pf, 0, 1,\n\t\t\t\t &param, &val, 1, true);\n\tif (ret < 0)\n\t\treturn ret;\n\tmtype = val >> 8;\n\tmaddr = (val & 0xff) << 16;\n\n\t \n\tspin_lock_bh(&adap->win0_lock);\n\tret = t4_memory_rw(adap, win, mtype, maddr,\n\t\t\t   phy_fw_size, (__be32 *)phy_fw_data,\n\t\t\t   T4_MEMORY_WRITE);\n\tspin_unlock_bh(&adap->win0_lock);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_PHYFW) |\n\t\t FW_PARAMS_PARAM_Y_V(adap->params.portvec) |\n\t\t FW_PARAMS_PARAM_Z_V(FW_PARAMS_PARAM_DEV_PHYFW_DOWNLOAD));\n\tret = t4_set_params_timeout(adap, adap->mbox, adap->pf, 0, 1,\n\t\t\t\t    &param, &val, 30000);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (phy_fw_version) {\n\t\tret = t4_phy_fw_ver(adap, &cur_phy_fw_ver);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (cur_phy_fw_ver != new_phy_fw_vers) {\n\t\t\tCH_WARN(adap, \"PHY Firmware did not update: \"\n\t\t\t\t\"version on adapter %#x, \"\n\t\t\t\t\"version flashed %#x\\n\",\n\t\t\t\tcur_phy_fw_ver, new_phy_fw_vers);\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n \nint t4_fwcache(struct adapter *adap, enum fw_params_param_dev_fwcache op)\n{\n\tstruct fw_params_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_vfn =\n\t\tcpu_to_be32(FW_CMD_OP_V(FW_PARAMS_CMD) |\n\t\t\t    FW_CMD_REQUEST_F | FW_CMD_WRITE_F |\n\t\t\t    FW_PARAMS_CMD_PFN_V(adap->pf) |\n\t\t\t    FW_PARAMS_CMD_VFN_V(0));\n\tc.retval_len16 = cpu_to_be32(FW_LEN16(c));\n\tc.param[0].mnem =\n\t\tcpu_to_be32(FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t\t    FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_FWCACHE));\n\tc.param[0].val = cpu_to_be32(op);\n\n\treturn t4_wr_mbox(adap, adap->mbox, &c, sizeof(c), NULL);\n}\n\nvoid t4_cim_read_pif_la(struct adapter *adap, u32 *pif_req, u32 *pif_rsp,\n\t\t\tunsigned int *pif_req_wrptr,\n\t\t\tunsigned int *pif_rsp_wrptr)\n{\n\tint i, j;\n\tu32 cfg, val, req, rsp;\n\n\tcfg = t4_read_reg(adap, CIM_DEBUGCFG_A);\n\tif (cfg & LADBGEN_F)\n\t\tt4_write_reg(adap, CIM_DEBUGCFG_A, cfg ^ LADBGEN_F);\n\n\tval = t4_read_reg(adap, CIM_DEBUGSTS_A);\n\treq = POLADBGWRPTR_G(val);\n\trsp = PILADBGWRPTR_G(val);\n\tif (pif_req_wrptr)\n\t\t*pif_req_wrptr = req;\n\tif (pif_rsp_wrptr)\n\t\t*pif_rsp_wrptr = rsp;\n\n\tfor (i = 0; i < CIM_PIFLA_SIZE; i++) {\n\t\tfor (j = 0; j < 6; j++) {\n\t\t\tt4_write_reg(adap, CIM_DEBUGCFG_A, POLADBGRDPTR_V(req) |\n\t\t\t\t     PILADBGRDPTR_V(rsp));\n\t\t\t*pif_req++ = t4_read_reg(adap, CIM_PO_LA_DEBUGDATA_A);\n\t\t\t*pif_rsp++ = t4_read_reg(adap, CIM_PI_LA_DEBUGDATA_A);\n\t\t\treq++;\n\t\t\trsp++;\n\t\t}\n\t\treq = (req + 2) & POLADBGRDPTR_M;\n\t\trsp = (rsp + 2) & PILADBGRDPTR_M;\n\t}\n\tt4_write_reg(adap, CIM_DEBUGCFG_A, cfg);\n}\n\nvoid t4_cim_read_ma_la(struct adapter *adap, u32 *ma_req, u32 *ma_rsp)\n{\n\tu32 cfg;\n\tint i, j, idx;\n\n\tcfg = t4_read_reg(adap, CIM_DEBUGCFG_A);\n\tif (cfg & LADBGEN_F)\n\t\tt4_write_reg(adap, CIM_DEBUGCFG_A, cfg ^ LADBGEN_F);\n\n\tfor (i = 0; i < CIM_MALA_SIZE; i++) {\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tidx = 8 * i + j;\n\t\t\tt4_write_reg(adap, CIM_DEBUGCFG_A, POLADBGRDPTR_V(idx) |\n\t\t\t\t     PILADBGRDPTR_V(idx));\n\t\t\t*ma_req++ = t4_read_reg(adap, CIM_PO_LA_MADEBUGDATA_A);\n\t\t\t*ma_rsp++ = t4_read_reg(adap, CIM_PI_LA_MADEBUGDATA_A);\n\t\t}\n\t}\n\tt4_write_reg(adap, CIM_DEBUGCFG_A, cfg);\n}\n\nvoid t4_ulprx_read_la(struct adapter *adap, u32 *la_buf)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tu32 *p = la_buf + i;\n\n\t\tt4_write_reg(adap, ULP_RX_LA_CTL_A, i);\n\t\tj = t4_read_reg(adap, ULP_RX_LA_WRPTR_A);\n\t\tt4_write_reg(adap, ULP_RX_LA_RDPTR_A, j);\n\t\tfor (j = 0; j < ULPRX_LA_SIZE; j++, p += 8)\n\t\t\t*p = t4_read_reg(adap, ULP_RX_LA_RDDATA_A);\n\t}\n}\n\n \n#define ADVERT_MASK (FW_PORT_CAP32_SPEED_V(FW_PORT_CAP32_SPEED_M) | \\\n\t\t     FW_PORT_CAP32_ANEG)\n\n \nstatic fw_port_cap32_t fwcaps16_to_caps32(fw_port_cap16_t caps16)\n{\n\tfw_port_cap32_t caps32 = 0;\n\n\t#define CAP16_TO_CAP32(__cap) \\\n\t\tdo { \\\n\t\t\tif (caps16 & FW_PORT_CAP_##__cap) \\\n\t\t\t\tcaps32 |= FW_PORT_CAP32_##__cap; \\\n\t\t} while (0)\n\n\tCAP16_TO_CAP32(SPEED_100M);\n\tCAP16_TO_CAP32(SPEED_1G);\n\tCAP16_TO_CAP32(SPEED_25G);\n\tCAP16_TO_CAP32(SPEED_10G);\n\tCAP16_TO_CAP32(SPEED_40G);\n\tCAP16_TO_CAP32(SPEED_100G);\n\tCAP16_TO_CAP32(FC_RX);\n\tCAP16_TO_CAP32(FC_TX);\n\tCAP16_TO_CAP32(ANEG);\n\tCAP16_TO_CAP32(FORCE_PAUSE);\n\tCAP16_TO_CAP32(MDIAUTO);\n\tCAP16_TO_CAP32(MDISTRAIGHT);\n\tCAP16_TO_CAP32(FEC_RS);\n\tCAP16_TO_CAP32(FEC_BASER_RS);\n\tCAP16_TO_CAP32(802_3_PAUSE);\n\tCAP16_TO_CAP32(802_3_ASM_DIR);\n\n\t#undef CAP16_TO_CAP32\n\n\treturn caps32;\n}\n\n \nstatic fw_port_cap16_t fwcaps32_to_caps16(fw_port_cap32_t caps32)\n{\n\tfw_port_cap16_t caps16 = 0;\n\n\t#define CAP32_TO_CAP16(__cap) \\\n\t\tdo { \\\n\t\t\tif (caps32 & FW_PORT_CAP32_##__cap) \\\n\t\t\t\tcaps16 |= FW_PORT_CAP_##__cap; \\\n\t\t} while (0)\n\n\tCAP32_TO_CAP16(SPEED_100M);\n\tCAP32_TO_CAP16(SPEED_1G);\n\tCAP32_TO_CAP16(SPEED_10G);\n\tCAP32_TO_CAP16(SPEED_25G);\n\tCAP32_TO_CAP16(SPEED_40G);\n\tCAP32_TO_CAP16(SPEED_100G);\n\tCAP32_TO_CAP16(FC_RX);\n\tCAP32_TO_CAP16(FC_TX);\n\tCAP32_TO_CAP16(802_3_PAUSE);\n\tCAP32_TO_CAP16(802_3_ASM_DIR);\n\tCAP32_TO_CAP16(ANEG);\n\tCAP32_TO_CAP16(FORCE_PAUSE);\n\tCAP32_TO_CAP16(MDIAUTO);\n\tCAP32_TO_CAP16(MDISTRAIGHT);\n\tCAP32_TO_CAP16(FEC_RS);\n\tCAP32_TO_CAP16(FEC_BASER_RS);\n\n\t#undef CAP32_TO_CAP16\n\n\treturn caps16;\n}\n\n \nstatic inline enum cc_pause fwcap_to_cc_pause(fw_port_cap32_t fw_pause)\n{\n\tenum cc_pause cc_pause = 0;\n\n\tif (fw_pause & FW_PORT_CAP32_FC_RX)\n\t\tcc_pause |= PAUSE_RX;\n\tif (fw_pause & FW_PORT_CAP32_FC_TX)\n\t\tcc_pause |= PAUSE_TX;\n\n\treturn cc_pause;\n}\n\n \nstatic inline fw_port_cap32_t cc_to_fwcap_pause(enum cc_pause cc_pause)\n{\n\t \n\tfw_port_cap32_t fw_pause = 0;\n\n\tif (cc_pause & PAUSE_RX)\n\t\tfw_pause |= FW_PORT_CAP32_FC_RX;\n\tif (cc_pause & PAUSE_TX)\n\t\tfw_pause |= FW_PORT_CAP32_FC_TX;\n\tif (!(cc_pause & PAUSE_AUTONEG))\n\t\tfw_pause |= FW_PORT_CAP32_FORCE_PAUSE;\n\n\t \n\tif (cc_pause & PAUSE_RX) {\n\t\tif (cc_pause & PAUSE_TX)\n\t\t\tfw_pause |= FW_PORT_CAP32_802_3_PAUSE;\n\t\telse\n\t\t\tfw_pause |= FW_PORT_CAP32_802_3_ASM_DIR |\n\t\t\t\t    FW_PORT_CAP32_802_3_PAUSE;\n\t} else if (cc_pause & PAUSE_TX) {\n\t\tfw_pause |= FW_PORT_CAP32_802_3_ASM_DIR;\n\t}\n\n\treturn fw_pause;\n}\n\n \nstatic inline enum cc_fec fwcap_to_cc_fec(fw_port_cap32_t fw_fec)\n{\n\tenum cc_fec cc_fec = 0;\n\n\tif (fw_fec & FW_PORT_CAP32_FEC_RS)\n\t\tcc_fec |= FEC_RS;\n\tif (fw_fec & FW_PORT_CAP32_FEC_BASER_RS)\n\t\tcc_fec |= FEC_BASER_RS;\n\n\treturn cc_fec;\n}\n\n \nstatic inline fw_port_cap32_t cc_to_fwcap_fec(enum cc_fec cc_fec)\n{\n\tfw_port_cap32_t fw_fec = 0;\n\n\tif (cc_fec & FEC_RS)\n\t\tfw_fec |= FW_PORT_CAP32_FEC_RS;\n\tif (cc_fec & FEC_BASER_RS)\n\t\tfw_fec |= FW_PORT_CAP32_FEC_BASER_RS;\n\n\treturn fw_fec;\n}\n\n \nfw_port_cap32_t t4_link_acaps(struct adapter *adapter, unsigned int port,\n\t\t\t      struct link_config *lc)\n{\n\tfw_port_cap32_t fw_fc, fw_fec, acaps;\n\tunsigned int fw_mdi;\n\tchar cc_fec;\n\n\tfw_mdi = (FW_PORT_CAP32_MDI_V(FW_PORT_CAP32_MDI_AUTO) & lc->pcaps);\n\n\t \n\tfw_fc = cc_to_fwcap_pause(lc->requested_fc);\n\n\t \n\tif (lc->requested_fec & FEC_AUTO)\n\t\tcc_fec = fwcap_to_cc_fec(lc->def_acaps);\n\telse\n\t\tcc_fec = lc->requested_fec;\n\tfw_fec = cc_to_fwcap_fec(cc_fec);\n\n\t \n\tif (!(lc->pcaps & FW_PORT_CAP32_ANEG)) {\n\t\tacaps = lc->acaps | fw_fc | fw_fec;\n\t\tlc->fc = lc->requested_fc & ~PAUSE_AUTONEG;\n\t\tlc->fec = cc_fec;\n\t} else if (lc->autoneg == AUTONEG_DISABLE) {\n\t\tacaps = lc->speed_caps | fw_fc | fw_fec | fw_mdi;\n\t\tlc->fc = lc->requested_fc & ~PAUSE_AUTONEG;\n\t\tlc->fec = cc_fec;\n\t} else {\n\t\tacaps = lc->acaps | fw_fc | fw_fec | fw_mdi;\n\t}\n\n\t \n\tif ((acaps & ~lc->pcaps) & ~FW_PORT_CAP32_FORCE_PAUSE) {\n\t\tdev_err(adapter->pdev_dev, \"Requested Port Capabilities %#x exceed Physical Port Capabilities %#x\\n\",\n\t\t\tacaps, lc->pcaps);\n\t\treturn -EINVAL;\n\t}\n\n\treturn acaps;\n}\n\n \nint t4_link_l1cfg_core(struct adapter *adapter, unsigned int mbox,\n\t\t       unsigned int port, struct link_config *lc,\n\t\t       u8 sleep_ok, int timeout)\n{\n\tunsigned int fw_caps = adapter->params.fw_caps_support;\n\tstruct fw_port_cmd cmd;\n\tfw_port_cap32_t rcap;\n\tint ret;\n\n\tif (!(lc->pcaps & FW_PORT_CAP32_ANEG) &&\n\t    lc->autoneg == AUTONEG_ENABLE) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trcap = t4_link_acaps(adapter, port, lc);\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PORT_CMD) |\n\t\t\t\t       FW_CMD_REQUEST_F | FW_CMD_EXEC_F |\n\t\t\t\t       FW_PORT_CMD_PORTID_V(port));\n\tcmd.action_to_len16 =\n\t\tcpu_to_be32(FW_PORT_CMD_ACTION_V(fw_caps == FW_CAPS16\n\t\t\t\t\t\t ? FW_PORT_ACTION_L1_CFG\n\t\t\t\t\t\t : FW_PORT_ACTION_L1_CFG32) |\n\t\t\t\t\t\t FW_LEN16(cmd));\n\tif (fw_caps == FW_CAPS16)\n\t\tcmd.u.l1cfg.rcap = cpu_to_be32(fwcaps32_to_caps16(rcap));\n\telse\n\t\tcmd.u.l1cfg32.rcap32 = cpu_to_be32(rcap);\n\n\tret = t4_wr_mbox_meat_timeout(adapter, mbox, &cmd, sizeof(cmd), NULL,\n\t\t\t\t      sleep_ok, timeout);\n\n\t \n\tif (ret) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"Requested Port Capabilities %#x rejected, error %d\\n\",\n\t\t\trcap, -ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nint t4_restart_aneg(struct adapter *adap, unsigned int mbox, unsigned int port)\n{\n\tunsigned int fw_caps = adap->params.fw_caps_support;\n\tstruct fw_port_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PORT_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F | FW_CMD_EXEC_F |\n\t\t\t\t     FW_PORT_CMD_PORTID_V(port));\n\tc.action_to_len16 =\n\t\tcpu_to_be32(FW_PORT_CMD_ACTION_V(fw_caps == FW_CAPS16\n\t\t\t\t\t\t ? FW_PORT_ACTION_L1_CFG\n\t\t\t\t\t\t : FW_PORT_ACTION_L1_CFG32) |\n\t\t\t    FW_LEN16(c));\n\tif (fw_caps == FW_CAPS16)\n\t\tc.u.l1cfg.rcap = cpu_to_be32(FW_PORT_CAP_ANEG);\n\telse\n\t\tc.u.l1cfg32.rcap32 = cpu_to_be32(FW_PORT_CAP32_ANEG);\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n}\n\ntypedef void (*int_handler_t)(struct adapter *adap);\n\nstruct intr_info {\n\tunsigned int mask;        \n\tconst char *msg;          \n\tshort stat_idx;           \n\tunsigned short fatal;     \n\tint_handler_t int_handler;  \n};\n\n \nstatic int t4_handle_intr_status(struct adapter *adapter, unsigned int reg,\n\t\t\t\t const struct intr_info *acts)\n{\n\tint fatal = 0;\n\tunsigned int mask = 0;\n\tunsigned int status = t4_read_reg(adapter, reg);\n\n\tfor ( ; acts->mask; ++acts) {\n\t\tif (!(status & acts->mask))\n\t\t\tcontinue;\n\t\tif (acts->fatal) {\n\t\t\tfatal++;\n\t\t\tdev_alert(adapter->pdev_dev, \"%s (0x%x)\\n\", acts->msg,\n\t\t\t\t  status & acts->mask);\n\t\t} else if (acts->msg && printk_ratelimit())\n\t\t\tdev_warn(adapter->pdev_dev, \"%s (0x%x)\\n\", acts->msg,\n\t\t\t\t status & acts->mask);\n\t\tif (acts->int_handler)\n\t\t\tacts->int_handler(adapter);\n\t\tmask |= acts->mask;\n\t}\n\tstatus &= mask;\n\tif (status)                            \n\t\tt4_write_reg(adapter, reg, status);\n\treturn fatal;\n}\n\n \nstatic void pcie_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info sysbus_intr_info[] = {\n\t\t{ RNPP_F, \"RXNP array parity error\", -1, 1 },\n\t\t{ RPCP_F, \"RXPC array parity error\", -1, 1 },\n\t\t{ RCIP_F, \"RXCIF array parity error\", -1, 1 },\n\t\t{ RCCP_F, \"Rx completions control array parity error\", -1, 1 },\n\t\t{ RFTP_F, \"RXFT array parity error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\tstatic const struct intr_info pcie_port_intr_info[] = {\n\t\t{ TPCP_F, \"TXPC array parity error\", -1, 1 },\n\t\t{ TNPP_F, \"TXNP array parity error\", -1, 1 },\n\t\t{ TFTP_F, \"TXFT array parity error\", -1, 1 },\n\t\t{ TCAP_F, \"TXCA array parity error\", -1, 1 },\n\t\t{ TCIP_F, \"TXCIF array parity error\", -1, 1 },\n\t\t{ RCAP_F, \"RXCA array parity error\", -1, 1 },\n\t\t{ OTDD_F, \"outbound request TLP discarded\", -1, 1 },\n\t\t{ RDPE_F, \"Rx data parity error\", -1, 1 },\n\t\t{ TDUE_F, \"Tx uncorrectable data error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\tstatic const struct intr_info pcie_intr_info[] = {\n\t\t{ MSIADDRLPERR_F, \"MSI AddrL parity error\", -1, 1 },\n\t\t{ MSIADDRHPERR_F, \"MSI AddrH parity error\", -1, 1 },\n\t\t{ MSIDATAPERR_F, \"MSI data parity error\", -1, 1 },\n\t\t{ MSIXADDRLPERR_F, \"MSI-X AddrL parity error\", -1, 1 },\n\t\t{ MSIXADDRHPERR_F, \"MSI-X AddrH parity error\", -1, 1 },\n\t\t{ MSIXDATAPERR_F, \"MSI-X data parity error\", -1, 1 },\n\t\t{ MSIXDIPERR_F, \"MSI-X DI parity error\", -1, 1 },\n\t\t{ PIOCPLPERR_F, \"PCI PIO completion FIFO parity error\", -1, 1 },\n\t\t{ PIOREQPERR_F, \"PCI PIO request FIFO parity error\", -1, 1 },\n\t\t{ TARTAGPERR_F, \"PCI PCI target tag FIFO parity error\", -1, 1 },\n\t\t{ CCNTPERR_F, \"PCI CMD channel count parity error\", -1, 1 },\n\t\t{ CREQPERR_F, \"PCI CMD channel request parity error\", -1, 1 },\n\t\t{ CRSPPERR_F, \"PCI CMD channel response parity error\", -1, 1 },\n\t\t{ DCNTPERR_F, \"PCI DMA channel count parity error\", -1, 1 },\n\t\t{ DREQPERR_F, \"PCI DMA channel request parity error\", -1, 1 },\n\t\t{ DRSPPERR_F, \"PCI DMA channel response parity error\", -1, 1 },\n\t\t{ HCNTPERR_F, \"PCI HMA channel count parity error\", -1, 1 },\n\t\t{ HREQPERR_F, \"PCI HMA channel request parity error\", -1, 1 },\n\t\t{ HRSPPERR_F, \"PCI HMA channel response parity error\", -1, 1 },\n\t\t{ CFGSNPPERR_F, \"PCI config snoop FIFO parity error\", -1, 1 },\n\t\t{ FIDPERR_F, \"PCI FID parity error\", -1, 1 },\n\t\t{ INTXCLRPERR_F, \"PCI INTx clear parity error\", -1, 1 },\n\t\t{ MATAGPERR_F, \"PCI MA tag parity error\", -1, 1 },\n\t\t{ PIOTAGPERR_F, \"PCI PIO tag parity error\", -1, 1 },\n\t\t{ RXCPLPERR_F, \"PCI Rx completion parity error\", -1, 1 },\n\t\t{ RXWRPERR_F, \"PCI Rx write parity error\", -1, 1 },\n\t\t{ RPLPERR_F, \"PCI replay buffer parity error\", -1, 1 },\n\t\t{ PCIESINT_F, \"PCI core secondary fault\", -1, 1 },\n\t\t{ PCIEPINT_F, \"PCI core primary fault\", -1, 1 },\n\t\t{ UNXSPLCPLERR_F, \"PCI unexpected split completion error\",\n\t\t  -1, 0 },\n\t\t{ 0 }\n\t};\n\n\tstatic struct intr_info t5_pcie_intr_info[] = {\n\t\t{ MSTGRPPERR_F, \"Master Response Read Queue parity error\",\n\t\t  -1, 1 },\n\t\t{ MSTTIMEOUTPERR_F, \"Master Timeout FIFO parity error\", -1, 1 },\n\t\t{ MSIXSTIPERR_F, \"MSI-X STI SRAM parity error\", -1, 1 },\n\t\t{ MSIXADDRLPERR_F, \"MSI-X AddrL parity error\", -1, 1 },\n\t\t{ MSIXADDRHPERR_F, \"MSI-X AddrH parity error\", -1, 1 },\n\t\t{ MSIXDATAPERR_F, \"MSI-X data parity error\", -1, 1 },\n\t\t{ MSIXDIPERR_F, \"MSI-X DI parity error\", -1, 1 },\n\t\t{ PIOCPLGRPPERR_F, \"PCI PIO completion Group FIFO parity error\",\n\t\t  -1, 1 },\n\t\t{ PIOREQGRPPERR_F, \"PCI PIO request Group FIFO parity error\",\n\t\t  -1, 1 },\n\t\t{ TARTAGPERR_F, \"PCI PCI target tag FIFO parity error\", -1, 1 },\n\t\t{ MSTTAGQPERR_F, \"PCI master tag queue parity error\", -1, 1 },\n\t\t{ CREQPERR_F, \"PCI CMD channel request parity error\", -1, 1 },\n\t\t{ CRSPPERR_F, \"PCI CMD channel response parity error\", -1, 1 },\n\t\t{ DREQWRPERR_F, \"PCI DMA channel write request parity error\",\n\t\t  -1, 1 },\n\t\t{ DREQPERR_F, \"PCI DMA channel request parity error\", -1, 1 },\n\t\t{ DRSPPERR_F, \"PCI DMA channel response parity error\", -1, 1 },\n\t\t{ HREQWRPERR_F, \"PCI HMA channel count parity error\", -1, 1 },\n\t\t{ HREQPERR_F, \"PCI HMA channel request parity error\", -1, 1 },\n\t\t{ HRSPPERR_F, \"PCI HMA channel response parity error\", -1, 1 },\n\t\t{ CFGSNPPERR_F, \"PCI config snoop FIFO parity error\", -1, 1 },\n\t\t{ FIDPERR_F, \"PCI FID parity error\", -1, 1 },\n\t\t{ VFIDPERR_F, \"PCI INTx clear parity error\", -1, 1 },\n\t\t{ MAGRPPERR_F, \"PCI MA group FIFO parity error\", -1, 1 },\n\t\t{ PIOTAGPERR_F, \"PCI PIO tag parity error\", -1, 1 },\n\t\t{ IPRXHDRGRPPERR_F, \"PCI IP Rx header group parity error\",\n\t\t  -1, 1 },\n\t\t{ IPRXDATAGRPPERR_F, \"PCI IP Rx data group parity error\",\n\t\t  -1, 1 },\n\t\t{ RPLPERR_F, \"PCI IP replay buffer parity error\", -1, 1 },\n\t\t{ IPSOTPERR_F, \"PCI IP SOT buffer parity error\", -1, 1 },\n\t\t{ TRGT1GRPPERR_F, \"PCI TRGT1 group FIFOs parity error\", -1, 1 },\n\t\t{ READRSPERR_F, \"Outbound read error\", -1, 0 },\n\t\t{ 0 }\n\t};\n\n\tint fat;\n\n\tif (is_t4(adapter->params.chip))\n\t\tfat = t4_handle_intr_status(adapter,\n\t\t\t\tPCIE_CORE_UTL_SYSTEM_BUS_AGENT_STATUS_A,\n\t\t\t\tsysbus_intr_info) +\n\t\t\tt4_handle_intr_status(adapter,\n\t\t\t\t\tPCIE_CORE_UTL_PCI_EXPRESS_PORT_STATUS_A,\n\t\t\t\t\tpcie_port_intr_info) +\n\t\t\tt4_handle_intr_status(adapter, PCIE_INT_CAUSE_A,\n\t\t\t\t\t      pcie_intr_info);\n\telse\n\t\tfat = t4_handle_intr_status(adapter, PCIE_INT_CAUSE_A,\n\t\t\t\t\t    t5_pcie_intr_info);\n\n\tif (fat)\n\t\tt4_fatal_err(adapter);\n}\n\n \nstatic void tp_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info tp_intr_info[] = {\n\t\t{ 0x3fffffff, \"TP parity error\", -1, 1 },\n\t\t{ FLMTXFLSTEMPTY_F, \"TP out of Tx pages\", -1, 1 },\n\t\t{ 0 }\n\t};\n\n\tif (t4_handle_intr_status(adapter, TP_INT_CAUSE_A, tp_intr_info))\n\t\tt4_fatal_err(adapter);\n}\n\n \nstatic void sge_intr_handler(struct adapter *adapter)\n{\n\tu32 v = 0, perr;\n\tu32 err;\n\n\tstatic const struct intr_info sge_intr_info[] = {\n\t\t{ ERR_CPL_EXCEED_IQE_SIZE_F,\n\t\t  \"SGE received CPL exceeding IQE size\", -1, 1 },\n\t\t{ ERR_INVALID_CIDX_INC_F,\n\t\t  \"SGE GTS CIDX increment too large\", -1, 0 },\n\t\t{ ERR_CPL_OPCODE_0_F, \"SGE received 0-length CPL\", -1, 0 },\n\t\t{ DBFIFO_LP_INT_F, NULL, -1, 0, t4_db_full },\n\t\t{ ERR_DATA_CPL_ON_HIGH_QID1_F | ERR_DATA_CPL_ON_HIGH_QID0_F,\n\t\t  \"SGE IQID > 1023 received CPL for FL\", -1, 0 },\n\t\t{ ERR_BAD_DB_PIDX3_F, \"SGE DBP 3 pidx increment too large\", -1,\n\t\t  0 },\n\t\t{ ERR_BAD_DB_PIDX2_F, \"SGE DBP 2 pidx increment too large\", -1,\n\t\t  0 },\n\t\t{ ERR_BAD_DB_PIDX1_F, \"SGE DBP 1 pidx increment too large\", -1,\n\t\t  0 },\n\t\t{ ERR_BAD_DB_PIDX0_F, \"SGE DBP 0 pidx increment too large\", -1,\n\t\t  0 },\n\t\t{ ERR_ING_CTXT_PRIO_F,\n\t\t  \"SGE too many priority ingress contexts\", -1, 0 },\n\t\t{ INGRESS_SIZE_ERR_F, \"SGE illegal ingress QID\", -1, 0 },\n\t\t{ EGRESS_SIZE_ERR_F, \"SGE illegal egress QID\", -1, 0 },\n\t\t{ 0 }\n\t};\n\n\tstatic struct intr_info t4t5_sge_intr_info[] = {\n\t\t{ ERR_DROPPED_DB_F, NULL, -1, 0, t4_db_dropped },\n\t\t{ DBFIFO_HP_INT_F, NULL, -1, 0, t4_db_full },\n\t\t{ ERR_EGR_CTXT_PRIO_F,\n\t\t  \"SGE too many priority egress contexts\", -1, 0 },\n\t\t{ 0 }\n\t};\n\n\tperr = t4_read_reg(adapter, SGE_INT_CAUSE1_A);\n\tif (perr) {\n\t\tv |= perr;\n\t\tdev_alert(adapter->pdev_dev, \"SGE Cause1 Parity Error %#x\\n\",\n\t\t\t  perr);\n\t}\n\n\tperr = t4_read_reg(adapter, SGE_INT_CAUSE2_A);\n\tif (perr) {\n\t\tv |= perr;\n\t\tdev_alert(adapter->pdev_dev, \"SGE Cause2 Parity Error %#x\\n\",\n\t\t\t  perr);\n\t}\n\n\tif (CHELSIO_CHIP_VERSION(adapter->params.chip) >= CHELSIO_T5) {\n\t\tperr = t4_read_reg(adapter, SGE_INT_CAUSE5_A);\n\t\t \n\t\tperr &= ~ERR_T_RXCRC_F;\n\t\tif (perr) {\n\t\t\tv |= perr;\n\t\t\tdev_alert(adapter->pdev_dev,\n\t\t\t\t  \"SGE Cause5 Parity Error %#x\\n\", perr);\n\t\t}\n\t}\n\n\tv |= t4_handle_intr_status(adapter, SGE_INT_CAUSE3_A, sge_intr_info);\n\tif (CHELSIO_CHIP_VERSION(adapter->params.chip) <= CHELSIO_T5)\n\t\tv |= t4_handle_intr_status(adapter, SGE_INT_CAUSE3_A,\n\t\t\t\t\t   t4t5_sge_intr_info);\n\n\terr = t4_read_reg(adapter, SGE_ERROR_STATS_A);\n\tif (err & ERROR_QID_VALID_F) {\n\t\tdev_err(adapter->pdev_dev, \"SGE error for queue %u\\n\",\n\t\t\tERROR_QID_G(err));\n\t\tif (err & UNCAPTURED_ERROR_F)\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"SGE UNCAPTURED_ERROR set (clearing)\\n\");\n\t\tt4_write_reg(adapter, SGE_ERROR_STATS_A, ERROR_QID_VALID_F |\n\t\t\t     UNCAPTURED_ERROR_F);\n\t}\n\n\tif (v != 0)\n\t\tt4_fatal_err(adapter);\n}\n\n#define CIM_OBQ_INTR (OBQULP0PARERR_F | OBQULP1PARERR_F | OBQULP2PARERR_F |\\\n\t\t      OBQULP3PARERR_F | OBQSGEPARERR_F | OBQNCSIPARERR_F)\n#define CIM_IBQ_INTR (IBQTP0PARERR_F | IBQTP1PARERR_F | IBQULPPARERR_F |\\\n\t\t      IBQSGEHIPARERR_F | IBQSGELOPARERR_F | IBQNCSIPARERR_F)\n\n \nstatic void cim_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info cim_intr_info[] = {\n\t\t{ PREFDROPINT_F, \"CIM control register prefetch drop\", -1, 1 },\n\t\t{ CIM_OBQ_INTR, \"CIM OBQ parity error\", -1, 1 },\n\t\t{ CIM_IBQ_INTR, \"CIM IBQ parity error\", -1, 1 },\n\t\t{ MBUPPARERR_F, \"CIM mailbox uP parity error\", -1, 1 },\n\t\t{ MBHOSTPARERR_F, \"CIM mailbox host parity error\", -1, 1 },\n\t\t{ TIEQINPARERRINT_F, \"CIM TIEQ outgoing parity error\", -1, 1 },\n\t\t{ TIEQOUTPARERRINT_F, \"CIM TIEQ incoming parity error\", -1, 1 },\n\t\t{ TIMER0INT_F, \"CIM TIMER0 interrupt\", -1, 1 },\n\t\t{ 0 }\n\t};\n\tstatic const struct intr_info cim_upintr_info[] = {\n\t\t{ RSVDSPACEINT_F, \"CIM reserved space access\", -1, 1 },\n\t\t{ ILLTRANSINT_F, \"CIM illegal transaction\", -1, 1 },\n\t\t{ ILLWRINT_F, \"CIM illegal write\", -1, 1 },\n\t\t{ ILLRDINT_F, \"CIM illegal read\", -1, 1 },\n\t\t{ ILLRDBEINT_F, \"CIM illegal read BE\", -1, 1 },\n\t\t{ ILLWRBEINT_F, \"CIM illegal write BE\", -1, 1 },\n\t\t{ SGLRDBOOTINT_F, \"CIM single read from boot space\", -1, 1 },\n\t\t{ SGLWRBOOTINT_F, \"CIM single write to boot space\", -1, 1 },\n\t\t{ BLKWRBOOTINT_F, \"CIM block write to boot space\", -1, 1 },\n\t\t{ SGLRDFLASHINT_F, \"CIM single read from flash space\", -1, 1 },\n\t\t{ SGLWRFLASHINT_F, \"CIM single write to flash space\", -1, 1 },\n\t\t{ BLKWRFLASHINT_F, \"CIM block write to flash space\", -1, 1 },\n\t\t{ SGLRDEEPROMINT_F, \"CIM single EEPROM read\", -1, 1 },\n\t\t{ SGLWREEPROMINT_F, \"CIM single EEPROM write\", -1, 1 },\n\t\t{ BLKRDEEPROMINT_F, \"CIM block EEPROM read\", -1, 1 },\n\t\t{ BLKWREEPROMINT_F, \"CIM block EEPROM write\", -1, 1 },\n\t\t{ SGLRDCTLINT_F, \"CIM single read from CTL space\", -1, 1 },\n\t\t{ SGLWRCTLINT_F, \"CIM single write to CTL space\", -1, 1 },\n\t\t{ BLKRDCTLINT_F, \"CIM block read from CTL space\", -1, 1 },\n\t\t{ BLKWRCTLINT_F, \"CIM block write to CTL space\", -1, 1 },\n\t\t{ SGLRDPLINT_F, \"CIM single read from PL space\", -1, 1 },\n\t\t{ SGLWRPLINT_F, \"CIM single write to PL space\", -1, 1 },\n\t\t{ BLKRDPLINT_F, \"CIM block read from PL space\", -1, 1 },\n\t\t{ BLKWRPLINT_F, \"CIM block write to PL space\", -1, 1 },\n\t\t{ REQOVRLOOKUPINT_F, \"CIM request FIFO overwrite\", -1, 1 },\n\t\t{ RSPOVRLOOKUPINT_F, \"CIM response FIFO overwrite\", -1, 1 },\n\t\t{ TIMEOUTINT_F, \"CIM PIF timeout\", -1, 1 },\n\t\t{ TIMEOUTMAINT_F, \"CIM PIF MA timeout\", -1, 1 },\n\t\t{ 0 }\n\t};\n\n\tu32 val, fw_err;\n\tint fat;\n\n\tfw_err = t4_read_reg(adapter, PCIE_FW_A);\n\tif (fw_err & PCIE_FW_ERR_F)\n\t\tt4_report_fw_error(adapter);\n\n\t \n\n\tval = t4_read_reg(adapter, CIM_HOST_INT_CAUSE_A);\n\tif (val & TIMER0INT_F)\n\t\tif (!(fw_err & PCIE_FW_ERR_F) ||\n\t\t    (PCIE_FW_EVAL_G(fw_err) != PCIE_FW_EVAL_CRASH))\n\t\t\tt4_write_reg(adapter, CIM_HOST_INT_CAUSE_A,\n\t\t\t\t     TIMER0INT_F);\n\n\tfat = t4_handle_intr_status(adapter, CIM_HOST_INT_CAUSE_A,\n\t\t\t\t    cim_intr_info) +\n\t      t4_handle_intr_status(adapter, CIM_HOST_UPACC_INT_CAUSE_A,\n\t\t\t\t    cim_upintr_info);\n\tif (fat)\n\t\tt4_fatal_err(adapter);\n}\n\n \nstatic void ulprx_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info ulprx_intr_info[] = {\n\t\t{ 0x1800000, \"ULPRX context error\", -1, 1 },\n\t\t{ 0x7fffff, \"ULPRX parity error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\n\tif (t4_handle_intr_status(adapter, ULP_RX_INT_CAUSE_A, ulprx_intr_info))\n\t\tt4_fatal_err(adapter);\n}\n\n \nstatic void ulptx_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info ulptx_intr_info[] = {\n\t\t{ PBL_BOUND_ERR_CH3_F, \"ULPTX channel 3 PBL out of bounds\", -1,\n\t\t  0 },\n\t\t{ PBL_BOUND_ERR_CH2_F, \"ULPTX channel 2 PBL out of bounds\", -1,\n\t\t  0 },\n\t\t{ PBL_BOUND_ERR_CH1_F, \"ULPTX channel 1 PBL out of bounds\", -1,\n\t\t  0 },\n\t\t{ PBL_BOUND_ERR_CH0_F, \"ULPTX channel 0 PBL out of bounds\", -1,\n\t\t  0 },\n\t\t{ 0xfffffff, \"ULPTX parity error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\n\tif (t4_handle_intr_status(adapter, ULP_TX_INT_CAUSE_A, ulptx_intr_info))\n\t\tt4_fatal_err(adapter);\n}\n\n \nstatic void pmtx_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info pmtx_intr_info[] = {\n\t\t{ PCMD_LEN_OVFL0_F, \"PMTX channel 0 pcmd too large\", -1, 1 },\n\t\t{ PCMD_LEN_OVFL1_F, \"PMTX channel 1 pcmd too large\", -1, 1 },\n\t\t{ PCMD_LEN_OVFL2_F, \"PMTX channel 2 pcmd too large\", -1, 1 },\n\t\t{ ZERO_C_CMD_ERROR_F, \"PMTX 0-length pcmd\", -1, 1 },\n\t\t{ PMTX_FRAMING_ERROR_F, \"PMTX framing error\", -1, 1 },\n\t\t{ OESPI_PAR_ERROR_F, \"PMTX oespi parity error\", -1, 1 },\n\t\t{ DB_OPTIONS_PAR_ERROR_F, \"PMTX db_options parity error\",\n\t\t  -1, 1 },\n\t\t{ ICSPI_PAR_ERROR_F, \"PMTX icspi parity error\", -1, 1 },\n\t\t{ PMTX_C_PCMD_PAR_ERROR_F, \"PMTX c_pcmd parity error\", -1, 1},\n\t\t{ 0 }\n\t};\n\n\tif (t4_handle_intr_status(adapter, PM_TX_INT_CAUSE_A, pmtx_intr_info))\n\t\tt4_fatal_err(adapter);\n}\n\n \nstatic void pmrx_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info pmrx_intr_info[] = {\n\t\t{ ZERO_E_CMD_ERROR_F, \"PMRX 0-length pcmd\", -1, 1 },\n\t\t{ PMRX_FRAMING_ERROR_F, \"PMRX framing error\", -1, 1 },\n\t\t{ OCSPI_PAR_ERROR_F, \"PMRX ocspi parity error\", -1, 1 },\n\t\t{ DB_OPTIONS_PAR_ERROR_F, \"PMRX db_options parity error\",\n\t\t  -1, 1 },\n\t\t{ IESPI_PAR_ERROR_F, \"PMRX iespi parity error\", -1, 1 },\n\t\t{ PMRX_E_PCMD_PAR_ERROR_F, \"PMRX e_pcmd parity error\", -1, 1},\n\t\t{ 0 }\n\t};\n\n\tif (t4_handle_intr_status(adapter, PM_RX_INT_CAUSE_A, pmrx_intr_info))\n\t\tt4_fatal_err(adapter);\n}\n\n \nstatic void cplsw_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info cplsw_intr_info[] = {\n\t\t{ CIM_OP_MAP_PERR_F, \"CPLSW CIM op_map parity error\", -1, 1 },\n\t\t{ CIM_OVFL_ERROR_F, \"CPLSW CIM overflow\", -1, 1 },\n\t\t{ TP_FRAMING_ERROR_F, \"CPLSW TP framing error\", -1, 1 },\n\t\t{ SGE_FRAMING_ERROR_F, \"CPLSW SGE framing error\", -1, 1 },\n\t\t{ CIM_FRAMING_ERROR_F, \"CPLSW CIM framing error\", -1, 1 },\n\t\t{ ZERO_SWITCH_ERROR_F, \"CPLSW no-switch error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\n\tif (t4_handle_intr_status(adapter, CPL_INTR_CAUSE_A, cplsw_intr_info))\n\t\tt4_fatal_err(adapter);\n}\n\n \nstatic void le_intr_handler(struct adapter *adap)\n{\n\tenum chip_type chip = CHELSIO_CHIP_VERSION(adap->params.chip);\n\tstatic const struct intr_info le_intr_info[] = {\n\t\t{ LIPMISS_F, \"LE LIP miss\", -1, 0 },\n\t\t{ LIP0_F, \"LE 0 LIP error\", -1, 0 },\n\t\t{ PARITYERR_F, \"LE parity error\", -1, 1 },\n\t\t{ UNKNOWNCMD_F, \"LE unknown command\", -1, 1 },\n\t\t{ REQQPARERR_F, \"LE request queue parity error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\n\tstatic struct intr_info t6_le_intr_info[] = {\n\t\t{ T6_LIPMISS_F, \"LE LIP miss\", -1, 0 },\n\t\t{ T6_LIP0_F, \"LE 0 LIP error\", -1, 0 },\n\t\t{ CMDTIDERR_F, \"LE cmd tid error\", -1, 1 },\n\t\t{ TCAMINTPERR_F, \"LE parity error\", -1, 1 },\n\t\t{ T6_UNKNOWNCMD_F, \"LE unknown command\", -1, 1 },\n\t\t{ SSRAMINTPERR_F, \"LE request queue parity error\", -1, 1 },\n\t\t{ HASHTBLMEMCRCERR_F, \"LE hash table mem crc error\", -1, 0 },\n\t\t{ 0 }\n\t};\n\n\tif (t4_handle_intr_status(adap, LE_DB_INT_CAUSE_A,\n\t\t\t\t  (chip <= CHELSIO_T5) ?\n\t\t\t\t  le_intr_info : t6_le_intr_info))\n\t\tt4_fatal_err(adap);\n}\n\n \nstatic void mps_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info mps_rx_intr_info[] = {\n\t\t{ 0xffffff, \"MPS Rx parity error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\tstatic const struct intr_info mps_tx_intr_info[] = {\n\t\t{ TPFIFO_V(TPFIFO_M), \"MPS Tx TP FIFO parity error\", -1, 1 },\n\t\t{ NCSIFIFO_F, \"MPS Tx NC-SI FIFO parity error\", -1, 1 },\n\t\t{ TXDATAFIFO_V(TXDATAFIFO_M), \"MPS Tx data FIFO parity error\",\n\t\t  -1, 1 },\n\t\t{ TXDESCFIFO_V(TXDESCFIFO_M), \"MPS Tx desc FIFO parity error\",\n\t\t  -1, 1 },\n\t\t{ BUBBLE_F, \"MPS Tx underflow\", -1, 1 },\n\t\t{ SECNTERR_F, \"MPS Tx SOP/EOP error\", -1, 1 },\n\t\t{ FRMERR_F, \"MPS Tx framing error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\tstatic const struct intr_info t6_mps_tx_intr_info[] = {\n\t\t{ TPFIFO_V(TPFIFO_M), \"MPS Tx TP FIFO parity error\", -1, 1 },\n\t\t{ NCSIFIFO_F, \"MPS Tx NC-SI FIFO parity error\", -1, 1 },\n\t\t{ TXDATAFIFO_V(TXDATAFIFO_M), \"MPS Tx data FIFO parity error\",\n\t\t  -1, 1 },\n\t\t{ TXDESCFIFO_V(TXDESCFIFO_M), \"MPS Tx desc FIFO parity error\",\n\t\t  -1, 1 },\n\t\t \n\t\t{ SECNTERR_F, \"MPS Tx SOP/EOP error\", -1, 1 },\n\t\t{ FRMERR_F, \"MPS Tx framing error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\tstatic const struct intr_info mps_trc_intr_info[] = {\n\t\t{ FILTMEM_V(FILTMEM_M), \"MPS TRC filter parity error\", -1, 1 },\n\t\t{ PKTFIFO_V(PKTFIFO_M), \"MPS TRC packet FIFO parity error\",\n\t\t  -1, 1 },\n\t\t{ MISCPERR_F, \"MPS TRC misc parity error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\tstatic const struct intr_info mps_stat_sram_intr_info[] = {\n\t\t{ 0x1fffff, \"MPS statistics SRAM parity error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\tstatic const struct intr_info mps_stat_tx_intr_info[] = {\n\t\t{ 0xfffff, \"MPS statistics Tx FIFO parity error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\tstatic const struct intr_info mps_stat_rx_intr_info[] = {\n\t\t{ 0xffffff, \"MPS statistics Rx FIFO parity error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\tstatic const struct intr_info mps_cls_intr_info[] = {\n\t\t{ MATCHSRAM_F, \"MPS match SRAM parity error\", -1, 1 },\n\t\t{ MATCHTCAM_F, \"MPS match TCAM parity error\", -1, 1 },\n\t\t{ HASHSRAM_F, \"MPS hash SRAM parity error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\n\tint fat;\n\n\tfat = t4_handle_intr_status(adapter, MPS_RX_PERR_INT_CAUSE_A,\n\t\t\t\t    mps_rx_intr_info) +\n\t      t4_handle_intr_status(adapter, MPS_TX_INT_CAUSE_A,\n\t\t\t\t    is_t6(adapter->params.chip)\n\t\t\t\t    ? t6_mps_tx_intr_info\n\t\t\t\t    : mps_tx_intr_info) +\n\t      t4_handle_intr_status(adapter, MPS_TRC_INT_CAUSE_A,\n\t\t\t\t    mps_trc_intr_info) +\n\t      t4_handle_intr_status(adapter, MPS_STAT_PERR_INT_CAUSE_SRAM_A,\n\t\t\t\t    mps_stat_sram_intr_info) +\n\t      t4_handle_intr_status(adapter, MPS_STAT_PERR_INT_CAUSE_TX_FIFO_A,\n\t\t\t\t    mps_stat_tx_intr_info) +\n\t      t4_handle_intr_status(adapter, MPS_STAT_PERR_INT_CAUSE_RX_FIFO_A,\n\t\t\t\t    mps_stat_rx_intr_info) +\n\t      t4_handle_intr_status(adapter, MPS_CLS_INT_CAUSE_A,\n\t\t\t\t    mps_cls_intr_info);\n\n\tt4_write_reg(adapter, MPS_INT_CAUSE_A, 0);\n\tt4_read_reg(adapter, MPS_INT_CAUSE_A);                     \n\tif (fat)\n\t\tt4_fatal_err(adapter);\n}\n\n#define MEM_INT_MASK (PERR_INT_CAUSE_F | ECC_CE_INT_CAUSE_F | \\\n\t\t      ECC_UE_INT_CAUSE_F)\n\n \nstatic void mem_intr_handler(struct adapter *adapter, int idx)\n{\n\tstatic const char name[4][7] = { \"EDC0\", \"EDC1\", \"MC/MC0\", \"MC1\" };\n\n\tunsigned int addr, cnt_addr, v;\n\n\tif (idx <= MEM_EDC1) {\n\t\taddr = EDC_REG(EDC_INT_CAUSE_A, idx);\n\t\tcnt_addr = EDC_REG(EDC_ECC_STATUS_A, idx);\n\t} else if (idx == MEM_MC) {\n\t\tif (is_t4(adapter->params.chip)) {\n\t\t\taddr = MC_INT_CAUSE_A;\n\t\t\tcnt_addr = MC_ECC_STATUS_A;\n\t\t} else {\n\t\t\taddr = MC_P_INT_CAUSE_A;\n\t\t\tcnt_addr = MC_P_ECC_STATUS_A;\n\t\t}\n\t} else {\n\t\taddr = MC_REG(MC_P_INT_CAUSE_A, 1);\n\t\tcnt_addr = MC_REG(MC_P_ECC_STATUS_A, 1);\n\t}\n\n\tv = t4_read_reg(adapter, addr) & MEM_INT_MASK;\n\tif (v & PERR_INT_CAUSE_F)\n\t\tdev_alert(adapter->pdev_dev, \"%s FIFO parity error\\n\",\n\t\t\t  name[idx]);\n\tif (v & ECC_CE_INT_CAUSE_F) {\n\t\tu32 cnt = ECC_CECNT_G(t4_read_reg(adapter, cnt_addr));\n\n\t\tt4_edc_err_read(adapter, idx);\n\n\t\tt4_write_reg(adapter, cnt_addr, ECC_CECNT_V(ECC_CECNT_M));\n\t\tif (printk_ratelimit())\n\t\t\tdev_warn(adapter->pdev_dev,\n\t\t\t\t \"%u %s correctable ECC data error%s\\n\",\n\t\t\t\t cnt, name[idx], cnt > 1 ? \"s\" : \"\");\n\t}\n\tif (v & ECC_UE_INT_CAUSE_F)\n\t\tdev_alert(adapter->pdev_dev,\n\t\t\t  \"%s uncorrectable ECC data error\\n\", name[idx]);\n\n\tt4_write_reg(adapter, addr, v);\n\tif (v & (PERR_INT_CAUSE_F | ECC_UE_INT_CAUSE_F))\n\t\tt4_fatal_err(adapter);\n}\n\n \nstatic void ma_intr_handler(struct adapter *adap)\n{\n\tu32 v, status = t4_read_reg(adap, MA_INT_CAUSE_A);\n\n\tif (status & MEM_PERR_INT_CAUSE_F) {\n\t\tdev_alert(adap->pdev_dev,\n\t\t\t  \"MA parity error, parity status %#x\\n\",\n\t\t\t  t4_read_reg(adap, MA_PARITY_ERROR_STATUS1_A));\n\t\tif (is_t5(adap->params.chip))\n\t\t\tdev_alert(adap->pdev_dev,\n\t\t\t\t  \"MA parity error, parity status %#x\\n\",\n\t\t\t\t  t4_read_reg(adap,\n\t\t\t\t\t      MA_PARITY_ERROR_STATUS2_A));\n\t}\n\tif (status & MEM_WRAP_INT_CAUSE_F) {\n\t\tv = t4_read_reg(adap, MA_INT_WRAP_STATUS_A);\n\t\tdev_alert(adap->pdev_dev, \"MA address wrap-around error by \"\n\t\t\t  \"client %u to address %#x\\n\",\n\t\t\t  MEM_WRAP_CLIENT_NUM_G(v),\n\t\t\t  MEM_WRAP_ADDRESS_G(v) << 4);\n\t}\n\tt4_write_reg(adap, MA_INT_CAUSE_A, status);\n\tt4_fatal_err(adap);\n}\n\n \nstatic void smb_intr_handler(struct adapter *adap)\n{\n\tstatic const struct intr_info smb_intr_info[] = {\n\t\t{ MSTTXFIFOPARINT_F, \"SMB master Tx FIFO parity error\", -1, 1 },\n\t\t{ MSTRXFIFOPARINT_F, \"SMB master Rx FIFO parity error\", -1, 1 },\n\t\t{ SLVFIFOPARINT_F, \"SMB slave FIFO parity error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\n\tif (t4_handle_intr_status(adap, SMB_INT_CAUSE_A, smb_intr_info))\n\t\tt4_fatal_err(adap);\n}\n\n \nstatic void ncsi_intr_handler(struct adapter *adap)\n{\n\tstatic const struct intr_info ncsi_intr_info[] = {\n\t\t{ CIM_DM_PRTY_ERR_F, \"NC-SI CIM parity error\", -1, 1 },\n\t\t{ MPS_DM_PRTY_ERR_F, \"NC-SI MPS parity error\", -1, 1 },\n\t\t{ TXFIFO_PRTY_ERR_F, \"NC-SI Tx FIFO parity error\", -1, 1 },\n\t\t{ RXFIFO_PRTY_ERR_F, \"NC-SI Rx FIFO parity error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\n\tif (t4_handle_intr_status(adap, NCSI_INT_CAUSE_A, ncsi_intr_info))\n\t\tt4_fatal_err(adap);\n}\n\n \nstatic void xgmac_intr_handler(struct adapter *adap, int port)\n{\n\tu32 v, int_cause_reg;\n\n\tif (is_t4(adap->params.chip))\n\t\tint_cause_reg = PORT_REG(port, XGMAC_PORT_INT_CAUSE_A);\n\telse\n\t\tint_cause_reg = T5_PORT_REG(port, MAC_PORT_INT_CAUSE_A);\n\n\tv = t4_read_reg(adap, int_cause_reg);\n\n\tv &= TXFIFO_PRTY_ERR_F | RXFIFO_PRTY_ERR_F;\n\tif (!v)\n\t\treturn;\n\n\tif (v & TXFIFO_PRTY_ERR_F)\n\t\tdev_alert(adap->pdev_dev, \"XGMAC %d Tx FIFO parity error\\n\",\n\t\t\t  port);\n\tif (v & RXFIFO_PRTY_ERR_F)\n\t\tdev_alert(adap->pdev_dev, \"XGMAC %d Rx FIFO parity error\\n\",\n\t\t\t  port);\n\tt4_write_reg(adap, PORT_REG(port, XGMAC_PORT_INT_CAUSE_A), v);\n\tt4_fatal_err(adap);\n}\n\n \nstatic void pl_intr_handler(struct adapter *adap)\n{\n\tstatic const struct intr_info pl_intr_info[] = {\n\t\t{ FATALPERR_F, \"T4 fatal parity error\", -1, 1 },\n\t\t{ PERRVFID_F, \"PL VFID_MAP parity error\", -1, 1 },\n\t\t{ 0 }\n\t};\n\n\tif (t4_handle_intr_status(adap, PL_PL_INT_CAUSE_A, pl_intr_info))\n\t\tt4_fatal_err(adap);\n}\n\n#define PF_INTR_MASK (PFSW_F)\n#define GLBL_INTR_MASK (CIM_F | MPS_F | PL_F | PCIE_F | MC_F | EDC0_F | \\\n\t\tEDC1_F | LE_F | TP_F | MA_F | PM_TX_F | PM_RX_F | ULP_RX_F | \\\n\t\tCPL_SWITCH_F | SGE_F | ULP_TX_F | SF_F)\n\n \nint t4_slow_intr_handler(struct adapter *adapter)\n{\n\t \n\tu32 raw_cause = t4_read_reg(adapter, PL_INT_CAUSE_A);\n\tu32 enable = t4_read_reg(adapter, PL_INT_ENABLE_A);\n\tu32 cause = raw_cause & enable;\n\n\tif (!(cause & GLBL_INTR_MASK))\n\t\treturn 0;\n\tif (cause & CIM_F)\n\t\tcim_intr_handler(adapter);\n\tif (cause & MPS_F)\n\t\tmps_intr_handler(adapter);\n\tif (cause & NCSI_F)\n\t\tncsi_intr_handler(adapter);\n\tif (cause & PL_F)\n\t\tpl_intr_handler(adapter);\n\tif (cause & SMB_F)\n\t\tsmb_intr_handler(adapter);\n\tif (cause & XGMAC0_F)\n\t\txgmac_intr_handler(adapter, 0);\n\tif (cause & XGMAC1_F)\n\t\txgmac_intr_handler(adapter, 1);\n\tif (cause & XGMAC_KR0_F)\n\t\txgmac_intr_handler(adapter, 2);\n\tif (cause & XGMAC_KR1_F)\n\t\txgmac_intr_handler(adapter, 3);\n\tif (cause & PCIE_F)\n\t\tpcie_intr_handler(adapter);\n\tif (cause & MC_F)\n\t\tmem_intr_handler(adapter, MEM_MC);\n\tif (is_t5(adapter->params.chip) && (cause & MC1_F))\n\t\tmem_intr_handler(adapter, MEM_MC1);\n\tif (cause & EDC0_F)\n\t\tmem_intr_handler(adapter, MEM_EDC0);\n\tif (cause & EDC1_F)\n\t\tmem_intr_handler(adapter, MEM_EDC1);\n\tif (cause & LE_F)\n\t\tle_intr_handler(adapter);\n\tif (cause & TP_F)\n\t\ttp_intr_handler(adapter);\n\tif (cause & MA_F)\n\t\tma_intr_handler(adapter);\n\tif (cause & PM_TX_F)\n\t\tpmtx_intr_handler(adapter);\n\tif (cause & PM_RX_F)\n\t\tpmrx_intr_handler(adapter);\n\tif (cause & ULP_RX_F)\n\t\tulprx_intr_handler(adapter);\n\tif (cause & CPL_SWITCH_F)\n\t\tcplsw_intr_handler(adapter);\n\tif (cause & SGE_F)\n\t\tsge_intr_handler(adapter);\n\tif (cause & ULP_TX_F)\n\t\tulptx_intr_handler(adapter);\n\n\t \n\tt4_write_reg(adapter, PL_INT_CAUSE_A, raw_cause & GLBL_INTR_MASK);\n\t(void)t4_read_reg(adapter, PL_INT_CAUSE_A);  \n\treturn 1;\n}\n\n \nvoid t4_intr_enable(struct adapter *adapter)\n{\n\tu32 val = 0;\n\tu32 whoami = t4_read_reg(adapter, PL_WHOAMI_A);\n\tu32 pf = CHELSIO_CHIP_VERSION(adapter->params.chip) <= CHELSIO_T5 ?\n\t\t\tSOURCEPF_G(whoami) : T6_SOURCEPF_G(whoami);\n\n\tif (CHELSIO_CHIP_VERSION(adapter->params.chip) <= CHELSIO_T5)\n\t\tval = ERR_DROPPED_DB_F | ERR_EGR_CTXT_PRIO_F | DBFIFO_HP_INT_F;\n\tt4_write_reg(adapter, SGE_INT_ENABLE3_A, ERR_CPL_EXCEED_IQE_SIZE_F |\n\t\t     ERR_INVALID_CIDX_INC_F | ERR_CPL_OPCODE_0_F |\n\t\t     ERR_DATA_CPL_ON_HIGH_QID1_F | INGRESS_SIZE_ERR_F |\n\t\t     ERR_DATA_CPL_ON_HIGH_QID0_F | ERR_BAD_DB_PIDX3_F |\n\t\t     ERR_BAD_DB_PIDX2_F | ERR_BAD_DB_PIDX1_F |\n\t\t     ERR_BAD_DB_PIDX0_F | ERR_ING_CTXT_PRIO_F |\n\t\t     DBFIFO_LP_INT_F | EGRESS_SIZE_ERR_F | val);\n\tt4_write_reg(adapter, MYPF_REG(PL_PF_INT_ENABLE_A), PF_INTR_MASK);\n\tt4_set_reg_field(adapter, PL_INT_MAP0_A, 0, 1 << pf);\n}\n\n \nvoid t4_intr_disable(struct adapter *adapter)\n{\n\tu32 whoami, pf;\n\n\tif (pci_channel_offline(adapter->pdev))\n\t\treturn;\n\n\twhoami = t4_read_reg(adapter, PL_WHOAMI_A);\n\tpf = CHELSIO_CHIP_VERSION(adapter->params.chip) <= CHELSIO_T5 ?\n\t\t\tSOURCEPF_G(whoami) : T6_SOURCEPF_G(whoami);\n\n\tt4_write_reg(adapter, MYPF_REG(PL_PF_INT_ENABLE_A), 0);\n\tt4_set_reg_field(adapter, PL_INT_MAP0_A, 1 << pf, 0);\n}\n\nunsigned int t4_chip_rss_size(struct adapter *adap)\n{\n\tif (CHELSIO_CHIP_VERSION(adap->params.chip) <= CHELSIO_T5)\n\t\treturn RSS_NENTRIES;\n\telse\n\t\treturn T6_RSS_NENTRIES;\n}\n\n \nint t4_config_rss_range(struct adapter *adapter, int mbox, unsigned int viid,\n\t\t\tint start, int n, const u16 *rspq, unsigned int nrspq)\n{\n\tint ret;\n\tconst u16 *rsp = rspq;\n\tconst u16 *rsp_end = rspq + nrspq;\n\tstruct fw_rss_ind_tbl_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_RSS_IND_TBL_CMD) |\n\t\t\t       FW_CMD_REQUEST_F | FW_CMD_WRITE_F |\n\t\t\t       FW_RSS_IND_TBL_CMD_VIID_V(viid));\n\tcmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\n\n\t \n\twhile (n > 0) {\n\t\tint nq = min(n, 32);\n\t\t__be32 *qp = &cmd.iq0_to_iq2;\n\n\t\tcmd.niqid = cpu_to_be16(nq);\n\t\tcmd.startidx = cpu_to_be16(start);\n\n\t\tstart += nq;\n\t\tn -= nq;\n\n\t\twhile (nq > 0) {\n\t\t\tunsigned int v;\n\n\t\t\tv = FW_RSS_IND_TBL_CMD_IQ0_V(*rsp);\n\t\t\tif (++rsp >= rsp_end)\n\t\t\t\trsp = rspq;\n\t\t\tv |= FW_RSS_IND_TBL_CMD_IQ1_V(*rsp);\n\t\t\tif (++rsp >= rsp_end)\n\t\t\t\trsp = rspq;\n\t\t\tv |= FW_RSS_IND_TBL_CMD_IQ2_V(*rsp);\n\t\t\tif (++rsp >= rsp_end)\n\t\t\t\trsp = rspq;\n\n\t\t\t*qp++ = cpu_to_be32(v);\n\t\t\tnq -= 3;\n\t\t}\n\n\t\tret = t4_wr_mbox(adapter, mbox, &cmd, sizeof(cmd), NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nint t4_config_glbl_rss(struct adapter *adapter, int mbox, unsigned int mode,\n\t\t       unsigned int flags)\n{\n\tstruct fw_rss_glb_config_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_write = cpu_to_be32(FW_CMD_OP_V(FW_RSS_GLB_CONFIG_CMD) |\n\t\t\t\t    FW_CMD_REQUEST_F | FW_CMD_WRITE_F);\n\tc.retval_len16 = cpu_to_be32(FW_LEN16(c));\n\tif (mode == FW_RSS_GLB_CONFIG_CMD_MODE_MANUAL) {\n\t\tc.u.manual.mode_pkd =\n\t\t\tcpu_to_be32(FW_RSS_GLB_CONFIG_CMD_MODE_V(mode));\n\t} else if (mode == FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL) {\n\t\tc.u.basicvirtual.mode_pkd =\n\t\t\tcpu_to_be32(FW_RSS_GLB_CONFIG_CMD_MODE_V(mode));\n\t\tc.u.basicvirtual.synmapen_to_hashtoeplitz = cpu_to_be32(flags);\n\t} else\n\t\treturn -EINVAL;\n\treturn t4_wr_mbox(adapter, mbox, &c, sizeof(c), NULL);\n}\n\n \nint t4_config_vi_rss(struct adapter *adapter, int mbox, unsigned int viid,\n\t\t     unsigned int flags, unsigned int defq)\n{\n\tstruct fw_rss_vi_config_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_RSS_VI_CONFIG_CMD) |\n\t\t\t\t   FW_CMD_REQUEST_F | FW_CMD_WRITE_F |\n\t\t\t\t   FW_RSS_VI_CONFIG_CMD_VIID_V(viid));\n\tc.retval_len16 = cpu_to_be32(FW_LEN16(c));\n\tc.u.basicvirtual.defaultq_to_udpen = cpu_to_be32(flags |\n\t\t\t\t\tFW_RSS_VI_CONFIG_CMD_DEFAULTQ_V(defq));\n\treturn t4_wr_mbox(adapter, mbox, &c, sizeof(c), NULL);\n}\n\n \nstatic int rd_rss_row(struct adapter *adap, int row, u32 *val)\n{\n\tt4_write_reg(adap, TP_RSS_LKP_TABLE_A, 0xfff00000 | row);\n\treturn t4_wait_op_done_val(adap, TP_RSS_LKP_TABLE_A, LKPTBLROWVLD_F, 1,\n\t\t\t\t   5, 0, val);\n}\n\n \nint t4_read_rss(struct adapter *adapter, u16 *map)\n{\n\tint i, ret, nentries;\n\tu32 val;\n\n\tnentries = t4_chip_rss_size(adapter);\n\tfor (i = 0; i < nentries / 2; ++i) {\n\t\tret = rd_rss_row(adapter, i, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*map++ = LKPTBLQUEUE0_G(val);\n\t\t*map++ = LKPTBLQUEUE1_G(val);\n\t}\n\treturn 0;\n}\n\nstatic unsigned int t4_use_ldst(struct adapter *adap)\n{\n\treturn (adap->flags & CXGB4_FW_OK) && !adap->use_bd;\n}\n\n \nstatic int t4_tp_fw_ldst_rw(struct adapter *adap, int cmd, u32 *vals,\n\t\t\t    unsigned int nregs, unsigned int start_index,\n\t\t\t    unsigned int rw, bool sleep_ok)\n{\n\tint ret = 0;\n\tunsigned int i;\n\tstruct fw_ldst_cmd c;\n\n\tfor (i = 0; i < nregs; i++) {\n\t\tmemset(&c, 0, sizeof(c));\n\t\tc.op_to_addrspace = cpu_to_be32(FW_CMD_OP_V(FW_LDST_CMD) |\n\t\t\t\t\t\tFW_CMD_REQUEST_F |\n\t\t\t\t\t\t(rw ? FW_CMD_READ_F :\n\t\t\t\t\t\t      FW_CMD_WRITE_F) |\n\t\t\t\t\t\tFW_LDST_CMD_ADDRSPACE_V(cmd));\n\t\tc.cycles_to_len16 = cpu_to_be32(FW_LEN16(c));\n\n\t\tc.u.addrval.addr = cpu_to_be32(start_index + i);\n\t\tc.u.addrval.val  = rw ? 0 : cpu_to_be32(vals[i]);\n\t\tret = t4_wr_mbox_meat(adap, adap->mbox, &c, sizeof(c), &c,\n\t\t\t\t      sleep_ok);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (rw)\n\t\t\tvals[i] = be32_to_cpu(c.u.addrval.val);\n\t}\n\treturn 0;\n}\n\n \nstatic void t4_tp_indirect_rw(struct adapter *adap, u32 reg_addr, u32 reg_data,\n\t\t\t      u32 *buff, u32 nregs, u32 start_index, int rw,\n\t\t\t      bool sleep_ok)\n{\n\tint rc = -EINVAL;\n\tint cmd;\n\n\tswitch (reg_addr) {\n\tcase TP_PIO_ADDR_A:\n\t\tcmd = FW_LDST_ADDRSPC_TP_PIO;\n\t\tbreak;\n\tcase TP_TM_PIO_ADDR_A:\n\t\tcmd = FW_LDST_ADDRSPC_TP_TM_PIO;\n\t\tbreak;\n\tcase TP_MIB_INDEX_A:\n\t\tcmd = FW_LDST_ADDRSPC_TP_MIB;\n\t\tbreak;\n\tdefault:\n\t\tgoto indirect_access;\n\t}\n\n\tif (t4_use_ldst(adap))\n\t\trc = t4_tp_fw_ldst_rw(adap, cmd, buff, nregs, start_index, rw,\n\t\t\t\t      sleep_ok);\n\nindirect_access:\n\n\tif (rc) {\n\t\tif (rw)\n\t\t\tt4_read_indirect(adap, reg_addr, reg_data, buff, nregs,\n\t\t\t\t\t start_index);\n\t\telse\n\t\t\tt4_write_indirect(adap, reg_addr, reg_data, buff, nregs,\n\t\t\t\t\t  start_index);\n\t}\n}\n\n \nvoid t4_tp_pio_read(struct adapter *adap, u32 *buff, u32 nregs,\n\t\t    u32 start_index, bool sleep_ok)\n{\n\tt4_tp_indirect_rw(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A, buff, nregs,\n\t\t\t  start_index, 1, sleep_ok);\n}\n\n \nstatic void t4_tp_pio_write(struct adapter *adap, u32 *buff, u32 nregs,\n\t\t\t    u32 start_index, bool sleep_ok)\n{\n\tt4_tp_indirect_rw(adap, TP_PIO_ADDR_A, TP_PIO_DATA_A, buff, nregs,\n\t\t\t  start_index, 0, sleep_ok);\n}\n\n \nvoid t4_tp_tm_pio_read(struct adapter *adap, u32 *buff, u32 nregs,\n\t\t       u32 start_index, bool sleep_ok)\n{\n\tt4_tp_indirect_rw(adap, TP_TM_PIO_ADDR_A, TP_TM_PIO_DATA_A, buff,\n\t\t\t  nregs, start_index, 1, sleep_ok);\n}\n\n \nvoid t4_tp_mib_read(struct adapter *adap, u32 *buff, u32 nregs, u32 start_index,\n\t\t    bool sleep_ok)\n{\n\tt4_tp_indirect_rw(adap, TP_MIB_INDEX_A, TP_MIB_DATA_A, buff, nregs,\n\t\t\t  start_index, 1, sleep_ok);\n}\n\n \nvoid t4_read_rss_key(struct adapter *adap, u32 *key, bool sleep_ok)\n{\n\tt4_tp_pio_read(adap, key, 10, TP_RSS_SECRET_KEY0_A, sleep_ok);\n}\n\n \nvoid t4_write_rss_key(struct adapter *adap, const u32 *key, int idx,\n\t\t      bool sleep_ok)\n{\n\tu8 rss_key_addr_cnt = 16;\n\tu32 vrt = t4_read_reg(adap, TP_RSS_CONFIG_VRT_A);\n\n\t \n\tif ((CHELSIO_CHIP_VERSION(adap->params.chip) > CHELSIO_T5) &&\n\t    (vrt & KEYEXTEND_F) && (KEYMODE_G(vrt) == 3))\n\t\trss_key_addr_cnt = 32;\n\n\tt4_tp_pio_write(adap, (void *)key, 10, TP_RSS_SECRET_KEY0_A, sleep_ok);\n\n\tif (idx >= 0 && idx < rss_key_addr_cnt) {\n\t\tif (rss_key_addr_cnt > 16)\n\t\t\tt4_write_reg(adap, TP_RSS_CONFIG_VRT_A,\n\t\t\t\t     KEYWRADDRX_V(idx >> 4) |\n\t\t\t\t     T6_VFWRADDR_V(idx) | KEYWREN_F);\n\t\telse\n\t\t\tt4_write_reg(adap, TP_RSS_CONFIG_VRT_A,\n\t\t\t\t     KEYWRADDR_V(idx) | KEYWREN_F);\n\t}\n}\n\n \nvoid t4_read_rss_pf_config(struct adapter *adapter, unsigned int index,\n\t\t\t   u32 *valp, bool sleep_ok)\n{\n\tt4_tp_pio_read(adapter, valp, 1, TP_RSS_PF0_CONFIG_A + index, sleep_ok);\n}\n\n \nvoid t4_read_rss_vf_config(struct adapter *adapter, unsigned int index,\n\t\t\t   u32 *vfl, u32 *vfh, bool sleep_ok)\n{\n\tu32 vrt, mask, data;\n\n\tif (CHELSIO_CHIP_VERSION(adapter->params.chip) <= CHELSIO_T5) {\n\t\tmask = VFWRADDR_V(VFWRADDR_M);\n\t\tdata = VFWRADDR_V(index);\n\t} else {\n\t\t mask =  T6_VFWRADDR_V(T6_VFWRADDR_M);\n\t\t data = T6_VFWRADDR_V(index);\n\t}\n\n\t \n\tvrt = t4_read_reg(adapter, TP_RSS_CONFIG_VRT_A);\n\tvrt &= ~(VFRDRG_F | VFWREN_F | KEYWREN_F | mask);\n\tvrt |= data | VFRDEN_F;\n\tt4_write_reg(adapter, TP_RSS_CONFIG_VRT_A, vrt);\n\n\t \n\tt4_tp_pio_read(adapter, vfl, 1, TP_RSS_VFL_CONFIG_A, sleep_ok);\n\tt4_tp_pio_read(adapter, vfh, 1, TP_RSS_VFH_CONFIG_A, sleep_ok);\n}\n\n \nu32 t4_read_rss_pf_map(struct adapter *adapter, bool sleep_ok)\n{\n\tu32 pfmap;\n\n\tt4_tp_pio_read(adapter, &pfmap, 1, TP_RSS_PF_MAP_A, sleep_ok);\n\treturn pfmap;\n}\n\n \nu32 t4_read_rss_pf_mask(struct adapter *adapter, bool sleep_ok)\n{\n\tu32 pfmask;\n\n\tt4_tp_pio_read(adapter, &pfmask, 1, TP_RSS_PF_MSK_A, sleep_ok);\n\treturn pfmask;\n}\n\n \nvoid t4_tp_get_tcp_stats(struct adapter *adap, struct tp_tcp_stats *v4,\n\t\t\t struct tp_tcp_stats *v6, bool sleep_ok)\n{\n\tu32 val[TP_MIB_TCP_RXT_SEG_LO_A - TP_MIB_TCP_OUT_RST_A + 1];\n\n#define STAT_IDX(x) ((TP_MIB_TCP_##x##_A) - TP_MIB_TCP_OUT_RST_A)\n#define STAT(x)     val[STAT_IDX(x)]\n#define STAT64(x)   (((u64)STAT(x##_HI) << 32) | STAT(x##_LO))\n\n\tif (v4) {\n\t\tt4_tp_mib_read(adap, val, ARRAY_SIZE(val),\n\t\t\t       TP_MIB_TCP_OUT_RST_A, sleep_ok);\n\t\tv4->tcp_out_rsts = STAT(OUT_RST);\n\t\tv4->tcp_in_segs  = STAT64(IN_SEG);\n\t\tv4->tcp_out_segs = STAT64(OUT_SEG);\n\t\tv4->tcp_retrans_segs = STAT64(RXT_SEG);\n\t}\n\tif (v6) {\n\t\tt4_tp_mib_read(adap, val, ARRAY_SIZE(val),\n\t\t\t       TP_MIB_TCP_V6OUT_RST_A, sleep_ok);\n\t\tv6->tcp_out_rsts = STAT(OUT_RST);\n\t\tv6->tcp_in_segs  = STAT64(IN_SEG);\n\t\tv6->tcp_out_segs = STAT64(OUT_SEG);\n\t\tv6->tcp_retrans_segs = STAT64(RXT_SEG);\n\t}\n#undef STAT64\n#undef STAT\n#undef STAT_IDX\n}\n\n \nvoid t4_tp_get_err_stats(struct adapter *adap, struct tp_err_stats *st,\n\t\t\t bool sleep_ok)\n{\n\tint nchan = adap->params.arch.nchan;\n\n\tt4_tp_mib_read(adap, st->mac_in_errs, nchan, TP_MIB_MAC_IN_ERR_0_A,\n\t\t       sleep_ok);\n\tt4_tp_mib_read(adap, st->hdr_in_errs, nchan, TP_MIB_HDR_IN_ERR_0_A,\n\t\t       sleep_ok);\n\tt4_tp_mib_read(adap, st->tcp_in_errs, nchan, TP_MIB_TCP_IN_ERR_0_A,\n\t\t       sleep_ok);\n\tt4_tp_mib_read(adap, st->tnl_cong_drops, nchan,\n\t\t       TP_MIB_TNL_CNG_DROP_0_A, sleep_ok);\n\tt4_tp_mib_read(adap, st->ofld_chan_drops, nchan,\n\t\t       TP_MIB_OFD_CHN_DROP_0_A, sleep_ok);\n\tt4_tp_mib_read(adap, st->tnl_tx_drops, nchan, TP_MIB_TNL_DROP_0_A,\n\t\t       sleep_ok);\n\tt4_tp_mib_read(adap, st->ofld_vlan_drops, nchan,\n\t\t       TP_MIB_OFD_VLN_DROP_0_A, sleep_ok);\n\tt4_tp_mib_read(adap, st->tcp6_in_errs, nchan,\n\t\t       TP_MIB_TCP_V6IN_ERR_0_A, sleep_ok);\n\tt4_tp_mib_read(adap, &st->ofld_no_neigh, 2, TP_MIB_OFD_ARP_DROP_A,\n\t\t       sleep_ok);\n}\n\n \nvoid t4_tp_get_cpl_stats(struct adapter *adap, struct tp_cpl_stats *st,\n\t\t\t bool sleep_ok)\n{\n\tint nchan = adap->params.arch.nchan;\n\n\tt4_tp_mib_read(adap, st->req, nchan, TP_MIB_CPL_IN_REQ_0_A, sleep_ok);\n\n\tt4_tp_mib_read(adap, st->rsp, nchan, TP_MIB_CPL_OUT_RSP_0_A, sleep_ok);\n}\n\n \nvoid t4_tp_get_rdma_stats(struct adapter *adap, struct tp_rdma_stats *st,\n\t\t\t  bool sleep_ok)\n{\n\tt4_tp_mib_read(adap, &st->rqe_dfr_pkt, 2, TP_MIB_RQE_DFR_PKT_A,\n\t\t       sleep_ok);\n}\n\n \nvoid t4_get_fcoe_stats(struct adapter *adap, unsigned int idx,\n\t\t       struct tp_fcoe_stats *st, bool sleep_ok)\n{\n\tu32 val[2];\n\n\tt4_tp_mib_read(adap, &st->frames_ddp, 1, TP_MIB_FCOE_DDP_0_A + idx,\n\t\t       sleep_ok);\n\n\tt4_tp_mib_read(adap, &st->frames_drop, 1,\n\t\t       TP_MIB_FCOE_DROP_0_A + idx, sleep_ok);\n\n\tt4_tp_mib_read(adap, val, 2, TP_MIB_FCOE_BYTE_0_HI_A + 2 * idx,\n\t\t       sleep_ok);\n\n\tst->octets_ddp = ((u64)val[0] << 32) | val[1];\n}\n\n \nvoid t4_get_usm_stats(struct adapter *adap, struct tp_usm_stats *st,\n\t\t      bool sleep_ok)\n{\n\tu32 val[4];\n\n\tt4_tp_mib_read(adap, val, 4, TP_MIB_USM_PKTS_A, sleep_ok);\n\tst->frames = val[0];\n\tst->drops = val[1];\n\tst->octets = ((u64)val[2] << 32) | val[3];\n}\n\n \nvoid t4_read_mtu_tbl(struct adapter *adap, u16 *mtus, u8 *mtu_log)\n{\n\tu32 v;\n\tint i;\n\n\tfor (i = 0; i < NMTUS; ++i) {\n\t\tt4_write_reg(adap, TP_MTU_TABLE_A,\n\t\t\t     MTUINDEX_V(0xff) | MTUVALUE_V(i));\n\t\tv = t4_read_reg(adap, TP_MTU_TABLE_A);\n\t\tmtus[i] = MTUVALUE_G(v);\n\t\tif (mtu_log)\n\t\t\tmtu_log[i] = MTUWIDTH_G(v);\n\t}\n}\n\n \nvoid t4_read_cong_tbl(struct adapter *adap, u16 incr[NMTUS][NCCTRL_WIN])\n{\n\tunsigned int mtu, w;\n\n\tfor (mtu = 0; mtu < NMTUS; ++mtu)\n\t\tfor (w = 0; w < NCCTRL_WIN; ++w) {\n\t\t\tt4_write_reg(adap, TP_CCTRL_TABLE_A,\n\t\t\t\t     ROWINDEX_V(0xffff) | (mtu << 5) | w);\n\t\t\tincr[mtu][w] = (u16)t4_read_reg(adap,\n\t\t\t\t\t\tTP_CCTRL_TABLE_A) & 0x1fff;\n\t\t}\n}\n\n \nvoid t4_tp_wr_bits_indirect(struct adapter *adap, unsigned int addr,\n\t\t\t    unsigned int mask, unsigned int val)\n{\n\tt4_write_reg(adap, TP_PIO_ADDR_A, addr);\n\tval |= t4_read_reg(adap, TP_PIO_DATA_A) & ~mask;\n\tt4_write_reg(adap, TP_PIO_DATA_A, val);\n}\n\n \nstatic void init_cong_ctrl(unsigned short *a, unsigned short *b)\n{\n\ta[0] = a[1] = a[2] = a[3] = a[4] = a[5] = a[6] = a[7] = a[8] = 1;\n\ta[9] = 2;\n\ta[10] = 3;\n\ta[11] = 4;\n\ta[12] = 5;\n\ta[13] = 6;\n\ta[14] = 7;\n\ta[15] = 8;\n\ta[16] = 9;\n\ta[17] = 10;\n\ta[18] = 14;\n\ta[19] = 17;\n\ta[20] = 21;\n\ta[21] = 25;\n\ta[22] = 30;\n\ta[23] = 35;\n\ta[24] = 45;\n\ta[25] = 60;\n\ta[26] = 80;\n\ta[27] = 100;\n\ta[28] = 200;\n\ta[29] = 300;\n\ta[30] = 400;\n\ta[31] = 500;\n\n\tb[0] = b[1] = b[2] = b[3] = b[4] = b[5] = b[6] = b[7] = b[8] = 0;\n\tb[9] = b[10] = 1;\n\tb[11] = b[12] = 2;\n\tb[13] = b[14] = b[15] = b[16] = 3;\n\tb[17] = b[18] = b[19] = b[20] = b[21] = 4;\n\tb[22] = b[23] = b[24] = b[25] = b[26] = b[27] = 5;\n\tb[28] = b[29] = 6;\n\tb[30] = b[31] = 7;\n}\n\n \n#define CC_MIN_INCR 2U\n\n \nvoid t4_load_mtus(struct adapter *adap, const unsigned short *mtus,\n\t\t  const unsigned short *alpha, const unsigned short *beta)\n{\n\tstatic const unsigned int avg_pkts[NCCTRL_WIN] = {\n\t\t2, 6, 10, 14, 20, 28, 40, 56, 80, 112, 160, 224, 320, 448, 640,\n\t\t896, 1281, 1792, 2560, 3584, 5120, 7168, 10240, 14336, 20480,\n\t\t28672, 40960, 57344, 81920, 114688, 163840, 229376\n\t};\n\n\tunsigned int i, w;\n\n\tfor (i = 0; i < NMTUS; ++i) {\n\t\tunsigned int mtu = mtus[i];\n\t\tunsigned int log2 = fls(mtu);\n\n\t\tif (!(mtu & ((1 << log2) >> 2)))      \n\t\t\tlog2--;\n\t\tt4_write_reg(adap, TP_MTU_TABLE_A, MTUINDEX_V(i) |\n\t\t\t     MTUWIDTH_V(log2) | MTUVALUE_V(mtu));\n\n\t\tfor (w = 0; w < NCCTRL_WIN; ++w) {\n\t\t\tunsigned int inc;\n\n\t\t\tinc = max(((mtu - 40) * alpha[w]) / avg_pkts[w],\n\t\t\t\t  CC_MIN_INCR);\n\n\t\t\tt4_write_reg(adap, TP_CCTRL_TABLE_A, (i << 21) |\n\t\t\t\t     (w << 16) | (beta[w] << 13) | inc);\n\t\t}\n\t}\n}\n\n \nstatic u64 chan_rate(struct adapter *adap, unsigned int bytes256)\n{\n\tu64 v = bytes256 * adap->params.vpd.cclk;\n\n\treturn v * 62 + v / 2;\n}\n\n \nvoid t4_get_chan_txrate(struct adapter *adap, u64 *nic_rate, u64 *ofld_rate)\n{\n\tu32 v;\n\n\tv = t4_read_reg(adap, TP_TX_TRATE_A);\n\tnic_rate[0] = chan_rate(adap, TNLRATE0_G(v));\n\tnic_rate[1] = chan_rate(adap, TNLRATE1_G(v));\n\tif (adap->params.arch.nchan == NCHAN) {\n\t\tnic_rate[2] = chan_rate(adap, TNLRATE2_G(v));\n\t\tnic_rate[3] = chan_rate(adap, TNLRATE3_G(v));\n\t}\n\n\tv = t4_read_reg(adap, TP_TX_ORATE_A);\n\tofld_rate[0] = chan_rate(adap, OFDRATE0_G(v));\n\tofld_rate[1] = chan_rate(adap, OFDRATE1_G(v));\n\tif (adap->params.arch.nchan == NCHAN) {\n\t\tofld_rate[2] = chan_rate(adap, OFDRATE2_G(v));\n\t\tofld_rate[3] = chan_rate(adap, OFDRATE3_G(v));\n\t}\n}\n\n \nint t4_set_trace_filter(struct adapter *adap, const struct trace_params *tp,\n\t\t\tint idx, int enable)\n{\n\tint i, ofst = idx * 4;\n\tu32 data_reg, mask_reg, cfg;\n\n\tif (!enable) {\n\t\tt4_write_reg(adap, MPS_TRC_FILTER_MATCH_CTL_A_A + ofst, 0);\n\t\treturn 0;\n\t}\n\n\tcfg = t4_read_reg(adap, MPS_TRC_CFG_A);\n\tif (cfg & TRCMULTIFILTER_F) {\n\t\t \n\t\tif (tp->snap_len > ((10 * 1024 / 4) - (2 * 8)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tif (tp->snap_len > 9600 || idx)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tp->port > (is_t4(adap->params.chip) ? 11 : 19) || tp->invert > 1 ||\n\t    tp->skip_len > TFLENGTH_M || tp->skip_ofst > TFOFFSET_M ||\n\t    tp->min_len > TFMINPKTSIZE_M)\n\t\treturn -EINVAL;\n\n\t \n\tt4_write_reg(adap, MPS_TRC_FILTER_MATCH_CTL_A_A + ofst, 0);\n\n\tidx *= (MPS_TRC_FILTER1_MATCH_A - MPS_TRC_FILTER0_MATCH_A);\n\tdata_reg = MPS_TRC_FILTER0_MATCH_A + idx;\n\tmask_reg = MPS_TRC_FILTER0_DONT_CARE_A + idx;\n\n\tfor (i = 0; i < TRACE_LEN / 4; i++, data_reg += 4, mask_reg += 4) {\n\t\tt4_write_reg(adap, data_reg, tp->data[i]);\n\t\tt4_write_reg(adap, mask_reg, ~tp->mask[i]);\n\t}\n\tt4_write_reg(adap, MPS_TRC_FILTER_MATCH_CTL_B_A + ofst,\n\t\t     TFCAPTUREMAX_V(tp->snap_len) |\n\t\t     TFMINPKTSIZE_V(tp->min_len));\n\tt4_write_reg(adap, MPS_TRC_FILTER_MATCH_CTL_A_A + ofst,\n\t\t     TFOFFSET_V(tp->skip_ofst) | TFLENGTH_V(tp->skip_len) |\n\t\t     (is_t4(adap->params.chip) ?\n\t\t     TFPORT_V(tp->port) | TFEN_F | TFINVERTMATCH_V(tp->invert) :\n\t\t     T5_TFPORT_V(tp->port) | T5_TFEN_F |\n\t\t     T5_TFINVERTMATCH_V(tp->invert)));\n\n\treturn 0;\n}\n\n \nvoid t4_get_trace_filter(struct adapter *adap, struct trace_params *tp, int idx,\n\t\t\t int *enabled)\n{\n\tu32 ctla, ctlb;\n\tint i, ofst = idx * 4;\n\tu32 data_reg, mask_reg;\n\n\tctla = t4_read_reg(adap, MPS_TRC_FILTER_MATCH_CTL_A_A + ofst);\n\tctlb = t4_read_reg(adap, MPS_TRC_FILTER_MATCH_CTL_B_A + ofst);\n\n\tif (is_t4(adap->params.chip)) {\n\t\t*enabled = !!(ctla & TFEN_F);\n\t\ttp->port =  TFPORT_G(ctla);\n\t\ttp->invert = !!(ctla & TFINVERTMATCH_F);\n\t} else {\n\t\t*enabled = !!(ctla & T5_TFEN_F);\n\t\ttp->port = T5_TFPORT_G(ctla);\n\t\ttp->invert = !!(ctla & T5_TFINVERTMATCH_F);\n\t}\n\ttp->snap_len = TFCAPTUREMAX_G(ctlb);\n\ttp->min_len = TFMINPKTSIZE_G(ctlb);\n\ttp->skip_ofst = TFOFFSET_G(ctla);\n\ttp->skip_len = TFLENGTH_G(ctla);\n\n\tofst = (MPS_TRC_FILTER1_MATCH_A - MPS_TRC_FILTER0_MATCH_A) * idx;\n\tdata_reg = MPS_TRC_FILTER0_MATCH_A + ofst;\n\tmask_reg = MPS_TRC_FILTER0_DONT_CARE_A + ofst;\n\n\tfor (i = 0; i < TRACE_LEN / 4; i++, data_reg += 4, mask_reg += 4) {\n\t\ttp->mask[i] = ~t4_read_reg(adap, mask_reg);\n\t\ttp->data[i] = t4_read_reg(adap, data_reg) & tp->mask[i];\n\t}\n}\n\n \nvoid t4_pmtx_get_stats(struct adapter *adap, u32 cnt[], u64 cycles[])\n{\n\tint i;\n\tu32 data[2];\n\n\tfor (i = 0; i < adap->params.arch.pm_stats_cnt; i++) {\n\t\tt4_write_reg(adap, PM_TX_STAT_CONFIG_A, i + 1);\n\t\tcnt[i] = t4_read_reg(adap, PM_TX_STAT_COUNT_A);\n\t\tif (is_t4(adap->params.chip)) {\n\t\t\tcycles[i] = t4_read_reg64(adap, PM_TX_STAT_LSB_A);\n\t\t} else {\n\t\t\tt4_read_indirect(adap, PM_TX_DBG_CTRL_A,\n\t\t\t\t\t PM_TX_DBG_DATA_A, data, 2,\n\t\t\t\t\t PM_TX_DBG_STAT_MSB_A);\n\t\t\tcycles[i] = (((u64)data[0] << 32) | data[1]);\n\t\t}\n\t}\n}\n\n \nvoid t4_pmrx_get_stats(struct adapter *adap, u32 cnt[], u64 cycles[])\n{\n\tint i;\n\tu32 data[2];\n\n\tfor (i = 0; i < adap->params.arch.pm_stats_cnt; i++) {\n\t\tt4_write_reg(adap, PM_RX_STAT_CONFIG_A, i + 1);\n\t\tcnt[i] = t4_read_reg(adap, PM_RX_STAT_COUNT_A);\n\t\tif (is_t4(adap->params.chip)) {\n\t\t\tcycles[i] = t4_read_reg64(adap, PM_RX_STAT_LSB_A);\n\t\t} else {\n\t\t\tt4_read_indirect(adap, PM_RX_DBG_CTRL_A,\n\t\t\t\t\t PM_RX_DBG_DATA_A, data, 2,\n\t\t\t\t\t PM_RX_DBG_STAT_MSB_A);\n\t\t\tcycles[i] = (((u64)data[0] << 32) | data[1]);\n\t\t}\n\t}\n}\n\n \nstatic inline unsigned int compute_mps_bg_map(struct adapter *adapter,\n\t\t\t\t\t      int pidx)\n{\n\tunsigned int chip_version, nports;\n\n\tchip_version = CHELSIO_CHIP_VERSION(adapter->params.chip);\n\tnports = 1 << NUMPORTS_G(t4_read_reg(adapter, MPS_CMN_CTL_A));\n\n\tswitch (chip_version) {\n\tcase CHELSIO_T4:\n\tcase CHELSIO_T5:\n\t\tswitch (nports) {\n\t\tcase 1: return 0xf;\n\t\tcase 2: return 3 << (2 * pidx);\n\t\tcase 4: return 1 << pidx;\n\t\t}\n\t\tbreak;\n\n\tcase CHELSIO_T6:\n\t\tswitch (nports) {\n\t\tcase 2: return 1 << (2 * pidx);\n\t\t}\n\t\tbreak;\n\t}\n\n\tdev_err(adapter->pdev_dev, \"Need MPS Buffer Group Map for Chip %0x, Nports %d\\n\",\n\t\tchip_version, nports);\n\n\treturn 0;\n}\n\n \nunsigned int t4_get_mps_bg_map(struct adapter *adapter, int pidx)\n{\n\tu8 *mps_bg_map;\n\tunsigned int nports;\n\n\tnports = 1 << NUMPORTS_G(t4_read_reg(adapter, MPS_CMN_CTL_A));\n\tif (pidx >= nports) {\n\t\tCH_WARN(adapter, \"MPS Port Index %d >= Nports %d\\n\",\n\t\t\tpidx, nports);\n\t\treturn 0;\n\t}\n\n\t \n\tmps_bg_map = adapter->params.mps_bg_map;\n\tif (mps_bg_map[pidx])\n\t\treturn mps_bg_map[pidx];\n\n\t \n\tif (adapter->flags & CXGB4_FW_OK) {\n\t\tu32 param, val;\n\t\tint ret;\n\n\t\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_MPSBGMAP));\n\t\tret = t4_query_params_ns(adapter, adapter->mbox, adapter->pf,\n\t\t\t\t\t 0, 1, &param, &val);\n\t\tif (!ret) {\n\t\t\tint p;\n\n\t\t\t \n\t\t\tfor (p = 0; p < MAX_NPORTS; p++, val >>= 8)\n\t\t\t\tmps_bg_map[p] = val & 0xff;\n\n\t\t\treturn mps_bg_map[pidx];\n\t\t}\n\t}\n\n\t \n\tmps_bg_map[pidx] = compute_mps_bg_map(adapter, pidx);\n\treturn mps_bg_map[pidx];\n}\n\n \nstatic unsigned int t4_get_tp_e2c_map(struct adapter *adapter, int pidx)\n{\n\tunsigned int nports;\n\tu32 param, val = 0;\n\tint ret;\n\n\tnports = 1 << NUMPORTS_G(t4_read_reg(adapter, MPS_CMN_CTL_A));\n\tif (pidx >= nports) {\n\t\tCH_WARN(adapter, \"TP E2C Channel Port Index %d >= Nports %d\\n\",\n\t\t\tpidx, nports);\n\t\treturn 0;\n\t}\n\n\t \n\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_TPCHMAP));\n\tret = t4_query_params_ns(adapter, adapter->mbox, adapter->pf,\n\t\t\t\t 0, 1, &param, &val);\n\tif (!ret)\n\t\treturn (val >> (8 * pidx)) & 0xff;\n\n\treturn 0;\n}\n\n \nunsigned int t4_get_tp_ch_map(struct adapter *adap, int pidx)\n{\n\tunsigned int chip_version = CHELSIO_CHIP_VERSION(adap->params.chip);\n\tunsigned int nports = 1 << NUMPORTS_G(t4_read_reg(adap, MPS_CMN_CTL_A));\n\n\tif (pidx >= nports) {\n\t\tdev_warn(adap->pdev_dev, \"TP Port Index %d >= Nports %d\\n\",\n\t\t\t pidx, nports);\n\t\treturn 0;\n\t}\n\n\tswitch (chip_version) {\n\tcase CHELSIO_T4:\n\tcase CHELSIO_T5:\n\t\t \n\t\tswitch (nports) {\n\t\tcase 1: return 0xf;\n\t\tcase 2: return 3 << (2 * pidx);\n\t\tcase 4: return 1 << pidx;\n\t\t}\n\t\tbreak;\n\n\tcase CHELSIO_T6:\n\t\tswitch (nports) {\n\t\tcase 1:\n\t\tcase 2: return 1 << pidx;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdev_err(adap->pdev_dev, \"Need TP Channel Map for Chip %0x, Nports %d\\n\",\n\t\tchip_version, nports);\n\treturn 0;\n}\n\n \nconst char *t4_get_port_type_description(enum fw_port_type port_type)\n{\n\tstatic const char *const port_type_description[] = {\n\t\t\"Fiber_XFI\",\n\t\t\"Fiber_XAUI\",\n\t\t\"BT_SGMII\",\n\t\t\"BT_XFI\",\n\t\t\"BT_XAUI\",\n\t\t\"KX4\",\n\t\t\"CX4\",\n\t\t\"KX\",\n\t\t\"KR\",\n\t\t\"SFP\",\n\t\t\"BP_AP\",\n\t\t\"BP4_AP\",\n\t\t\"QSFP_10G\",\n\t\t\"QSA\",\n\t\t\"QSFP\",\n\t\t\"BP40_BA\",\n\t\t\"KR4_100G\",\n\t\t\"CR4_QSFP\",\n\t\t\"CR_QSFP\",\n\t\t\"CR2_QSFP\",\n\t\t\"SFP28\",\n\t\t\"KR_SFP28\",\n\t\t\"KR_XLAUI\"\n\t};\n\n\tif (port_type < ARRAY_SIZE(port_type_description))\n\t\treturn port_type_description[port_type];\n\treturn \"UNKNOWN\";\n}\n\n \nvoid t4_get_port_stats_offset(struct adapter *adap, int idx,\n\t\t\t      struct port_stats *stats,\n\t\t\t      struct port_stats *offset)\n{\n\tu64 *s, *o;\n\tint i;\n\n\tt4_get_port_stats(adap, idx, stats);\n\tfor (i = 0, s = (u64 *)stats, o = (u64 *)offset;\n\t\t\ti < (sizeof(struct port_stats) / sizeof(u64));\n\t\t\ti++, s++, o++)\n\t\t*s -= *o;\n}\n\n \nvoid t4_get_port_stats(struct adapter *adap, int idx, struct port_stats *p)\n{\n\tu32 bgmap = t4_get_mps_bg_map(adap, idx);\n\tu32 stat_ctl = t4_read_reg(adap, MPS_STAT_CTL_A);\n\n#define GET_STAT(name) \\\n\tt4_read_reg64(adap, \\\n\t(is_t4(adap->params.chip) ? PORT_REG(idx, MPS_PORT_STAT_##name##_L) : \\\n\tT5_PORT_REG(idx, MPS_PORT_STAT_##name##_L)))\n#define GET_STAT_COM(name) t4_read_reg64(adap, MPS_STAT_##name##_L)\n\n\tp->tx_octets           = GET_STAT(TX_PORT_BYTES);\n\tp->tx_frames           = GET_STAT(TX_PORT_FRAMES);\n\tp->tx_bcast_frames     = GET_STAT(TX_PORT_BCAST);\n\tp->tx_mcast_frames     = GET_STAT(TX_PORT_MCAST);\n\tp->tx_ucast_frames     = GET_STAT(TX_PORT_UCAST);\n\tp->tx_error_frames     = GET_STAT(TX_PORT_ERROR);\n\tp->tx_frames_64        = GET_STAT(TX_PORT_64B);\n\tp->tx_frames_65_127    = GET_STAT(TX_PORT_65B_127B);\n\tp->tx_frames_128_255   = GET_STAT(TX_PORT_128B_255B);\n\tp->tx_frames_256_511   = GET_STAT(TX_PORT_256B_511B);\n\tp->tx_frames_512_1023  = GET_STAT(TX_PORT_512B_1023B);\n\tp->tx_frames_1024_1518 = GET_STAT(TX_PORT_1024B_1518B);\n\tp->tx_frames_1519_max  = GET_STAT(TX_PORT_1519B_MAX);\n\tp->tx_drop             = GET_STAT(TX_PORT_DROP);\n\tp->tx_pause            = GET_STAT(TX_PORT_PAUSE);\n\tp->tx_ppp0             = GET_STAT(TX_PORT_PPP0);\n\tp->tx_ppp1             = GET_STAT(TX_PORT_PPP1);\n\tp->tx_ppp2             = GET_STAT(TX_PORT_PPP2);\n\tp->tx_ppp3             = GET_STAT(TX_PORT_PPP3);\n\tp->tx_ppp4             = GET_STAT(TX_PORT_PPP4);\n\tp->tx_ppp5             = GET_STAT(TX_PORT_PPP5);\n\tp->tx_ppp6             = GET_STAT(TX_PORT_PPP6);\n\tp->tx_ppp7             = GET_STAT(TX_PORT_PPP7);\n\n\tif (CHELSIO_CHIP_VERSION(adap->params.chip) >= CHELSIO_T5) {\n\t\tif (stat_ctl & COUNTPAUSESTATTX_F)\n\t\t\tp->tx_frames_64 -= p->tx_pause;\n\t\tif (stat_ctl & COUNTPAUSEMCTX_F)\n\t\t\tp->tx_mcast_frames -= p->tx_pause;\n\t}\n\tp->rx_octets           = GET_STAT(RX_PORT_BYTES);\n\tp->rx_frames           = GET_STAT(RX_PORT_FRAMES);\n\tp->rx_bcast_frames     = GET_STAT(RX_PORT_BCAST);\n\tp->rx_mcast_frames     = GET_STAT(RX_PORT_MCAST);\n\tp->rx_ucast_frames     = GET_STAT(RX_PORT_UCAST);\n\tp->rx_too_long         = GET_STAT(RX_PORT_MTU_ERROR);\n\tp->rx_jabber           = GET_STAT(RX_PORT_MTU_CRC_ERROR);\n\tp->rx_fcs_err          = GET_STAT(RX_PORT_CRC_ERROR);\n\tp->rx_len_err          = GET_STAT(RX_PORT_LEN_ERROR);\n\tp->rx_symbol_err       = GET_STAT(RX_PORT_SYM_ERROR);\n\tp->rx_runt             = GET_STAT(RX_PORT_LESS_64B);\n\tp->rx_frames_64        = GET_STAT(RX_PORT_64B);\n\tp->rx_frames_65_127    = GET_STAT(RX_PORT_65B_127B);\n\tp->rx_frames_128_255   = GET_STAT(RX_PORT_128B_255B);\n\tp->rx_frames_256_511   = GET_STAT(RX_PORT_256B_511B);\n\tp->rx_frames_512_1023  = GET_STAT(RX_PORT_512B_1023B);\n\tp->rx_frames_1024_1518 = GET_STAT(RX_PORT_1024B_1518B);\n\tp->rx_frames_1519_max  = GET_STAT(RX_PORT_1519B_MAX);\n\tp->rx_pause            = GET_STAT(RX_PORT_PAUSE);\n\tp->rx_ppp0             = GET_STAT(RX_PORT_PPP0);\n\tp->rx_ppp1             = GET_STAT(RX_PORT_PPP1);\n\tp->rx_ppp2             = GET_STAT(RX_PORT_PPP2);\n\tp->rx_ppp3             = GET_STAT(RX_PORT_PPP3);\n\tp->rx_ppp4             = GET_STAT(RX_PORT_PPP4);\n\tp->rx_ppp5             = GET_STAT(RX_PORT_PPP5);\n\tp->rx_ppp6             = GET_STAT(RX_PORT_PPP6);\n\tp->rx_ppp7             = GET_STAT(RX_PORT_PPP7);\n\n\tif (CHELSIO_CHIP_VERSION(adap->params.chip) >= CHELSIO_T5) {\n\t\tif (stat_ctl & COUNTPAUSESTATRX_F)\n\t\t\tp->rx_frames_64 -= p->rx_pause;\n\t\tif (stat_ctl & COUNTPAUSEMCRX_F)\n\t\t\tp->rx_mcast_frames -= p->rx_pause;\n\t}\n\n\tp->rx_ovflow0 = (bgmap & 1) ? GET_STAT_COM(RX_BG_0_MAC_DROP_FRAME) : 0;\n\tp->rx_ovflow1 = (bgmap & 2) ? GET_STAT_COM(RX_BG_1_MAC_DROP_FRAME) : 0;\n\tp->rx_ovflow2 = (bgmap & 4) ? GET_STAT_COM(RX_BG_2_MAC_DROP_FRAME) : 0;\n\tp->rx_ovflow3 = (bgmap & 8) ? GET_STAT_COM(RX_BG_3_MAC_DROP_FRAME) : 0;\n\tp->rx_trunc0 = (bgmap & 1) ? GET_STAT_COM(RX_BG_0_MAC_TRUNC_FRAME) : 0;\n\tp->rx_trunc1 = (bgmap & 2) ? GET_STAT_COM(RX_BG_1_MAC_TRUNC_FRAME) : 0;\n\tp->rx_trunc2 = (bgmap & 4) ? GET_STAT_COM(RX_BG_2_MAC_TRUNC_FRAME) : 0;\n\tp->rx_trunc3 = (bgmap & 8) ? GET_STAT_COM(RX_BG_3_MAC_TRUNC_FRAME) : 0;\n\n#undef GET_STAT\n#undef GET_STAT_COM\n}\n\n \nvoid t4_get_lb_stats(struct adapter *adap, int idx, struct lb_port_stats *p)\n{\n\tu32 bgmap = t4_get_mps_bg_map(adap, idx);\n\n#define GET_STAT(name) \\\n\tt4_read_reg64(adap, \\\n\t(is_t4(adap->params.chip) ? \\\n\tPORT_REG(idx, MPS_PORT_STAT_LB_PORT_##name##_L) : \\\n\tT5_PORT_REG(idx, MPS_PORT_STAT_LB_PORT_##name##_L)))\n#define GET_STAT_COM(name) t4_read_reg64(adap, MPS_STAT_##name##_L)\n\n\tp->octets           = GET_STAT(BYTES);\n\tp->frames           = GET_STAT(FRAMES);\n\tp->bcast_frames     = GET_STAT(BCAST);\n\tp->mcast_frames     = GET_STAT(MCAST);\n\tp->ucast_frames     = GET_STAT(UCAST);\n\tp->error_frames     = GET_STAT(ERROR);\n\n\tp->frames_64        = GET_STAT(64B);\n\tp->frames_65_127    = GET_STAT(65B_127B);\n\tp->frames_128_255   = GET_STAT(128B_255B);\n\tp->frames_256_511   = GET_STAT(256B_511B);\n\tp->frames_512_1023  = GET_STAT(512B_1023B);\n\tp->frames_1024_1518 = GET_STAT(1024B_1518B);\n\tp->frames_1519_max  = GET_STAT(1519B_MAX);\n\tp->drop             = GET_STAT(DROP_FRAMES);\n\n\tp->ovflow0 = (bgmap & 1) ? GET_STAT_COM(RX_BG_0_LB_DROP_FRAME) : 0;\n\tp->ovflow1 = (bgmap & 2) ? GET_STAT_COM(RX_BG_1_LB_DROP_FRAME) : 0;\n\tp->ovflow2 = (bgmap & 4) ? GET_STAT_COM(RX_BG_2_LB_DROP_FRAME) : 0;\n\tp->ovflow3 = (bgmap & 8) ? GET_STAT_COM(RX_BG_3_LB_DROP_FRAME) : 0;\n\tp->trunc0 = (bgmap & 1) ? GET_STAT_COM(RX_BG_0_LB_TRUNC_FRAME) : 0;\n\tp->trunc1 = (bgmap & 2) ? GET_STAT_COM(RX_BG_1_LB_TRUNC_FRAME) : 0;\n\tp->trunc2 = (bgmap & 4) ? GET_STAT_COM(RX_BG_2_LB_TRUNC_FRAME) : 0;\n\tp->trunc3 = (bgmap & 8) ? GET_STAT_COM(RX_BG_3_LB_TRUNC_FRAME) : 0;\n\n#undef GET_STAT\n#undef GET_STAT_COM\n}\n\n \nvoid t4_mk_filtdelwr(unsigned int ftid, struct fw_filter_wr *wr, int qid)\n{\n\tmemset(wr, 0, sizeof(*wr));\n\twr->op_pkd = cpu_to_be32(FW_WR_OP_V(FW_FILTER_WR));\n\twr->len16_pkd = cpu_to_be32(FW_WR_LEN16_V(sizeof(*wr) / 16));\n\twr->tid_to_iq = cpu_to_be32(FW_FILTER_WR_TID_V(ftid) |\n\t\t\t\t    FW_FILTER_WR_NOREPLY_V(qid < 0));\n\twr->del_filter_to_l2tix = cpu_to_be32(FW_FILTER_WR_DEL_FILTER_F);\n\tif (qid >= 0)\n\t\twr->rx_chan_rx_rpl_iq =\n\t\t\tcpu_to_be16(FW_FILTER_WR_RX_RPL_IQ_V(qid));\n}\n\n#define INIT_CMD(var, cmd, rd_wr) do { \\\n\t(var).op_to_write = cpu_to_be32(FW_CMD_OP_V(FW_##cmd##_CMD) | \\\n\t\t\t\t\tFW_CMD_REQUEST_F | \\\n\t\t\t\t\tFW_CMD_##rd_wr##_F); \\\n\t(var).retval_len16 = cpu_to_be32(FW_LEN16(var)); \\\n} while (0)\n\nint t4_fwaddrspace_write(struct adapter *adap, unsigned int mbox,\n\t\t\t  u32 addr, u32 val)\n{\n\tu32 ldst_addrspace;\n\tstruct fw_ldst_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tldst_addrspace = FW_LDST_CMD_ADDRSPACE_V(FW_LDST_ADDRSPC_FIRMWARE);\n\tc.op_to_addrspace = cpu_to_be32(FW_CMD_OP_V(FW_LDST_CMD) |\n\t\t\t\t\tFW_CMD_REQUEST_F |\n\t\t\t\t\tFW_CMD_WRITE_F |\n\t\t\t\t\tldst_addrspace);\n\tc.cycles_to_len16 = cpu_to_be32(FW_LEN16(c));\n\tc.u.addrval.addr = cpu_to_be32(addr);\n\tc.u.addrval.val = cpu_to_be32(val);\n\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n}\n\n \nint t4_mdio_rd(struct adapter *adap, unsigned int mbox, unsigned int phy_addr,\n\t       unsigned int mmd, unsigned int reg, u16 *valp)\n{\n\tint ret;\n\tu32 ldst_addrspace;\n\tstruct fw_ldst_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tldst_addrspace = FW_LDST_CMD_ADDRSPACE_V(FW_LDST_ADDRSPC_MDIO);\n\tc.op_to_addrspace = cpu_to_be32(FW_CMD_OP_V(FW_LDST_CMD) |\n\t\t\t\t\tFW_CMD_REQUEST_F | FW_CMD_READ_F |\n\t\t\t\t\tldst_addrspace);\n\tc.cycles_to_len16 = cpu_to_be32(FW_LEN16(c));\n\tc.u.mdio.paddr_mmd = cpu_to_be16(FW_LDST_CMD_PADDR_V(phy_addr) |\n\t\t\t\t\t FW_LDST_CMD_MMD_V(mmd));\n\tc.u.mdio.raddr = cpu_to_be16(reg);\n\n\tret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);\n\tif (ret == 0)\n\t\t*valp = be16_to_cpu(c.u.mdio.rval);\n\treturn ret;\n}\n\n \nint t4_mdio_wr(struct adapter *adap, unsigned int mbox, unsigned int phy_addr,\n\t       unsigned int mmd, unsigned int reg, u16 val)\n{\n\tu32 ldst_addrspace;\n\tstruct fw_ldst_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tldst_addrspace = FW_LDST_CMD_ADDRSPACE_V(FW_LDST_ADDRSPC_MDIO);\n\tc.op_to_addrspace = cpu_to_be32(FW_CMD_OP_V(FW_LDST_CMD) |\n\t\t\t\t\tFW_CMD_REQUEST_F | FW_CMD_WRITE_F |\n\t\t\t\t\tldst_addrspace);\n\tc.cycles_to_len16 = cpu_to_be32(FW_LEN16(c));\n\tc.u.mdio.paddr_mmd = cpu_to_be16(FW_LDST_CMD_PADDR_V(phy_addr) |\n\t\t\t\t\t FW_LDST_CMD_MMD_V(mmd));\n\tc.u.mdio.raddr = cpu_to_be16(reg);\n\tc.u.mdio.rval = cpu_to_be16(val);\n\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n}\n\n \nvoid t4_sge_decode_idma_state(struct adapter *adapter, int state)\n{\n\tstatic const char * const t4_decode[] = {\n\t\t\"IDMA_IDLE\",\n\t\t\"IDMA_PUSH_MORE_CPL_FIFO\",\n\t\t\"IDMA_PUSH_CPL_MSG_HEADER_TO_FIFO\",\n\t\t\"Not used\",\n\t\t\"IDMA_PHYSADDR_SEND_PCIEHDR\",\n\t\t\"IDMA_PHYSADDR_SEND_PAYLOAD_FIRST\",\n\t\t\"IDMA_PHYSADDR_SEND_PAYLOAD\",\n\t\t\"IDMA_SEND_FIFO_TO_IMSG\",\n\t\t\"IDMA_FL_REQ_DATA_FL_PREP\",\n\t\t\"IDMA_FL_REQ_DATA_FL\",\n\t\t\"IDMA_FL_DROP\",\n\t\t\"IDMA_FL_H_REQ_HEADER_FL\",\n\t\t\"IDMA_FL_H_SEND_PCIEHDR\",\n\t\t\"IDMA_FL_H_PUSH_CPL_FIFO\",\n\t\t\"IDMA_FL_H_SEND_CPL\",\n\t\t\"IDMA_FL_H_SEND_IP_HDR_FIRST\",\n\t\t\"IDMA_FL_H_SEND_IP_HDR\",\n\t\t\"IDMA_FL_H_REQ_NEXT_HEADER_FL\",\n\t\t\"IDMA_FL_H_SEND_NEXT_PCIEHDR\",\n\t\t\"IDMA_FL_H_SEND_IP_HDR_PADDING\",\n\t\t\"IDMA_FL_D_SEND_PCIEHDR\",\n\t\t\"IDMA_FL_D_SEND_CPL_AND_IP_HDR\",\n\t\t\"IDMA_FL_D_REQ_NEXT_DATA_FL\",\n\t\t\"IDMA_FL_SEND_PCIEHDR\",\n\t\t\"IDMA_FL_PUSH_CPL_FIFO\",\n\t\t\"IDMA_FL_SEND_CPL\",\n\t\t\"IDMA_FL_SEND_PAYLOAD_FIRST\",\n\t\t\"IDMA_FL_SEND_PAYLOAD\",\n\t\t\"IDMA_FL_REQ_NEXT_DATA_FL\",\n\t\t\"IDMA_FL_SEND_NEXT_PCIEHDR\",\n\t\t\"IDMA_FL_SEND_PADDING\",\n\t\t\"IDMA_FL_SEND_COMPLETION_TO_IMSG\",\n\t\t\"IDMA_FL_SEND_FIFO_TO_IMSG\",\n\t\t\"IDMA_FL_REQ_DATAFL_DONE\",\n\t\t\"IDMA_FL_REQ_HEADERFL_DONE\",\n\t};\n\tstatic const char * const t5_decode[] = {\n\t\t\"IDMA_IDLE\",\n\t\t\"IDMA_ALMOST_IDLE\",\n\t\t\"IDMA_PUSH_MORE_CPL_FIFO\",\n\t\t\"IDMA_PUSH_CPL_MSG_HEADER_TO_FIFO\",\n\t\t\"IDMA_SGEFLRFLUSH_SEND_PCIEHDR\",\n\t\t\"IDMA_PHYSADDR_SEND_PCIEHDR\",\n\t\t\"IDMA_PHYSADDR_SEND_PAYLOAD_FIRST\",\n\t\t\"IDMA_PHYSADDR_SEND_PAYLOAD\",\n\t\t\"IDMA_SEND_FIFO_TO_IMSG\",\n\t\t\"IDMA_FL_REQ_DATA_FL\",\n\t\t\"IDMA_FL_DROP\",\n\t\t\"IDMA_FL_DROP_SEND_INC\",\n\t\t\"IDMA_FL_H_REQ_HEADER_FL\",\n\t\t\"IDMA_FL_H_SEND_PCIEHDR\",\n\t\t\"IDMA_FL_H_PUSH_CPL_FIFO\",\n\t\t\"IDMA_FL_H_SEND_CPL\",\n\t\t\"IDMA_FL_H_SEND_IP_HDR_FIRST\",\n\t\t\"IDMA_FL_H_SEND_IP_HDR\",\n\t\t\"IDMA_FL_H_REQ_NEXT_HEADER_FL\",\n\t\t\"IDMA_FL_H_SEND_NEXT_PCIEHDR\",\n\t\t\"IDMA_FL_H_SEND_IP_HDR_PADDING\",\n\t\t\"IDMA_FL_D_SEND_PCIEHDR\",\n\t\t\"IDMA_FL_D_SEND_CPL_AND_IP_HDR\",\n\t\t\"IDMA_FL_D_REQ_NEXT_DATA_FL\",\n\t\t\"IDMA_FL_SEND_PCIEHDR\",\n\t\t\"IDMA_FL_PUSH_CPL_FIFO\",\n\t\t\"IDMA_FL_SEND_CPL\",\n\t\t\"IDMA_FL_SEND_PAYLOAD_FIRST\",\n\t\t\"IDMA_FL_SEND_PAYLOAD\",\n\t\t\"IDMA_FL_REQ_NEXT_DATA_FL\",\n\t\t\"IDMA_FL_SEND_NEXT_PCIEHDR\",\n\t\t\"IDMA_FL_SEND_PADDING\",\n\t\t\"IDMA_FL_SEND_COMPLETION_TO_IMSG\",\n\t};\n\tstatic const char * const t6_decode[] = {\n\t\t\"IDMA_IDLE\",\n\t\t\"IDMA_PUSH_MORE_CPL_FIFO\",\n\t\t\"IDMA_PUSH_CPL_MSG_HEADER_TO_FIFO\",\n\t\t\"IDMA_SGEFLRFLUSH_SEND_PCIEHDR\",\n\t\t\"IDMA_PHYSADDR_SEND_PCIEHDR\",\n\t\t\"IDMA_PHYSADDR_SEND_PAYLOAD_FIRST\",\n\t\t\"IDMA_PHYSADDR_SEND_PAYLOAD\",\n\t\t\"IDMA_FL_REQ_DATA_FL\",\n\t\t\"IDMA_FL_DROP\",\n\t\t\"IDMA_FL_DROP_SEND_INC\",\n\t\t\"IDMA_FL_H_REQ_HEADER_FL\",\n\t\t\"IDMA_FL_H_SEND_PCIEHDR\",\n\t\t\"IDMA_FL_H_PUSH_CPL_FIFO\",\n\t\t\"IDMA_FL_H_SEND_CPL\",\n\t\t\"IDMA_FL_H_SEND_IP_HDR_FIRST\",\n\t\t\"IDMA_FL_H_SEND_IP_HDR\",\n\t\t\"IDMA_FL_H_REQ_NEXT_HEADER_FL\",\n\t\t\"IDMA_FL_H_SEND_NEXT_PCIEHDR\",\n\t\t\"IDMA_FL_H_SEND_IP_HDR_PADDING\",\n\t\t\"IDMA_FL_D_SEND_PCIEHDR\",\n\t\t\"IDMA_FL_D_SEND_CPL_AND_IP_HDR\",\n\t\t\"IDMA_FL_D_REQ_NEXT_DATA_FL\",\n\t\t\"IDMA_FL_SEND_PCIEHDR\",\n\t\t\"IDMA_FL_PUSH_CPL_FIFO\",\n\t\t\"IDMA_FL_SEND_CPL\",\n\t\t\"IDMA_FL_SEND_PAYLOAD_FIRST\",\n\t\t\"IDMA_FL_SEND_PAYLOAD\",\n\t\t\"IDMA_FL_REQ_NEXT_DATA_FL\",\n\t\t\"IDMA_FL_SEND_NEXT_PCIEHDR\",\n\t\t\"IDMA_FL_SEND_PADDING\",\n\t\t\"IDMA_FL_SEND_COMPLETION_TO_IMSG\",\n\t};\n\tstatic const u32 sge_regs[] = {\n\t\tSGE_DEBUG_DATA_LOW_INDEX_2_A,\n\t\tSGE_DEBUG_DATA_LOW_INDEX_3_A,\n\t\tSGE_DEBUG_DATA_HIGH_INDEX_10_A,\n\t};\n\tconst char **sge_idma_decode;\n\tint sge_idma_decode_nstates;\n\tint i;\n\tunsigned int chip_version = CHELSIO_CHIP_VERSION(adapter->params.chip);\n\n\t \n\tswitch (chip_version) {\n\tcase CHELSIO_T4:\n\t\tsge_idma_decode = (const char **)t4_decode;\n\t\tsge_idma_decode_nstates = ARRAY_SIZE(t4_decode);\n\t\tbreak;\n\n\tcase CHELSIO_T5:\n\t\tsge_idma_decode = (const char **)t5_decode;\n\t\tsge_idma_decode_nstates = ARRAY_SIZE(t5_decode);\n\t\tbreak;\n\n\tcase CHELSIO_T6:\n\t\tsge_idma_decode = (const char **)t6_decode;\n\t\tsge_idma_decode_nstates = ARRAY_SIZE(t6_decode);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"Unsupported chip version %d\\n\", chip_version);\n\t\treturn;\n\t}\n\n\tif (is_t4(adapter->params.chip)) {\n\t\tsge_idma_decode = (const char **)t4_decode;\n\t\tsge_idma_decode_nstates = ARRAY_SIZE(t4_decode);\n\t} else {\n\t\tsge_idma_decode = (const char **)t5_decode;\n\t\tsge_idma_decode_nstates = ARRAY_SIZE(t5_decode);\n\t}\n\n\tif (state < sge_idma_decode_nstates)\n\t\tCH_WARN(adapter, \"idma state %s\\n\", sge_idma_decode[state]);\n\telse\n\t\tCH_WARN(adapter, \"idma state %d unknown\\n\", state);\n\n\tfor (i = 0; i < ARRAY_SIZE(sge_regs); i++)\n\t\tCH_WARN(adapter, \"SGE register %#x value %#x\\n\",\n\t\t\tsge_regs[i], t4_read_reg(adapter, sge_regs[i]));\n}\n\n \nint t4_sge_ctxt_flush(struct adapter *adap, unsigned int mbox, int ctxt_type)\n{\n\tint ret;\n\tu32 ldst_addrspace;\n\tstruct fw_ldst_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tldst_addrspace = FW_LDST_CMD_ADDRSPACE_V(ctxt_type == CTXT_EGRESS ?\n\t\t\t\t\t\t FW_LDST_ADDRSPC_SGE_EGRC :\n\t\t\t\t\t\t FW_LDST_ADDRSPC_SGE_INGC);\n\tc.op_to_addrspace = cpu_to_be32(FW_CMD_OP_V(FW_LDST_CMD) |\n\t\t\t\t\tFW_CMD_REQUEST_F | FW_CMD_READ_F |\n\t\t\t\t\tldst_addrspace);\n\tc.cycles_to_len16 = cpu_to_be32(FW_LEN16(c));\n\tc.u.idctxt.msg_ctxtflush = cpu_to_be32(FW_LDST_CMD_CTXTFLUSH_F);\n\n\tret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);\n\treturn ret;\n}\n\n \nint t4_read_sge_dbqtimers(struct adapter *adap, unsigned int ndbqtimers,\n\t\t\t  u16 *dbqtimers)\n{\n\tint ret, dbqtimerix;\n\n\tret = 0;\n\tdbqtimerix = 0;\n\twhile (dbqtimerix < ndbqtimers) {\n\t\tint nparams, param;\n\t\tu32 params[7], vals[7];\n\n\t\tnparams = ndbqtimers - dbqtimerix;\n\t\tif (nparams > ARRAY_SIZE(params))\n\t\t\tnparams = ARRAY_SIZE(params);\n\n\t\tfor (param = 0; param < nparams; param++)\n\t\t\tparams[param] =\n\t\t\t  (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t\t   FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_DBQ_TIMER) |\n\t\t\t   FW_PARAMS_PARAM_Y_V(dbqtimerix + param));\n\t\tret = t4_query_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t\t      nparams, params, vals);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tfor (param = 0; param < nparams; param++)\n\t\t\tdbqtimers[dbqtimerix++] = vals[param];\n\t}\n\treturn ret;\n}\n\n \nint t4_fw_hello(struct adapter *adap, unsigned int mbox, unsigned int evt_mbox,\n\t\tenum dev_master master, enum dev_state *state)\n{\n\tint ret;\n\tstruct fw_hello_cmd c;\n\tu32 v;\n\tunsigned int master_mbox;\n\tint retries = FW_CMD_HELLO_RETRIES;\n\nretry:\n\tmemset(&c, 0, sizeof(c));\n\tINIT_CMD(c, HELLO, WRITE);\n\tc.err_to_clearinit = cpu_to_be32(\n\t\tFW_HELLO_CMD_MASTERDIS_V(master == MASTER_CANT) |\n\t\tFW_HELLO_CMD_MASTERFORCE_V(master == MASTER_MUST) |\n\t\tFW_HELLO_CMD_MBMASTER_V(master == MASTER_MUST ?\n\t\t\t\t\tmbox : FW_HELLO_CMD_MBMASTER_M) |\n\t\tFW_HELLO_CMD_MBASYNCNOT_V(evt_mbox) |\n\t\tFW_HELLO_CMD_STAGE_V(fw_hello_cmd_stage_os) |\n\t\tFW_HELLO_CMD_CLEARINIT_F);\n\n\t \n\tret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);\n\tif (ret < 0) {\n\t\tif ((ret == -EBUSY || ret == -ETIMEDOUT) && retries-- > 0)\n\t\t\tgoto retry;\n\t\tif (t4_read_reg(adap, PCIE_FW_A) & PCIE_FW_ERR_F)\n\t\t\tt4_report_fw_error(adap);\n\t\treturn ret;\n\t}\n\n\tv = be32_to_cpu(c.err_to_clearinit);\n\tmaster_mbox = FW_HELLO_CMD_MBMASTER_G(v);\n\tif (state) {\n\t\tif (v & FW_HELLO_CMD_ERR_F)\n\t\t\t*state = DEV_STATE_ERR;\n\t\telse if (v & FW_HELLO_CMD_INIT_F)\n\t\t\t*state = DEV_STATE_INIT;\n\t\telse\n\t\t\t*state = DEV_STATE_UNINIT;\n\t}\n\n\t \n\tif ((v & (FW_HELLO_CMD_ERR_F|FW_HELLO_CMD_INIT_F)) == 0 &&\n\t    master_mbox != mbox) {\n\t\tint waiting = FW_CMD_HELLO_TIMEOUT;\n\n\t\t \n\t\tfor (;;) {\n\t\t\tu32 pcie_fw;\n\n\t\t\tmsleep(50);\n\t\t\twaiting -= 50;\n\n\t\t\t \n\t\t\tpcie_fw = t4_read_reg(adap, PCIE_FW_A);\n\t\t\tif (!(pcie_fw & (PCIE_FW_ERR_F|PCIE_FW_INIT_F))) {\n\t\t\t\tif (waiting <= 0) {\n\t\t\t\t\tif (retries-- > 0)\n\t\t\t\t\t\tgoto retry;\n\n\t\t\t\t\treturn -ETIMEDOUT;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (state) {\n\t\t\t\tif (pcie_fw & PCIE_FW_ERR_F)\n\t\t\t\t\t*state = DEV_STATE_ERR;\n\t\t\t\telse if (pcie_fw & PCIE_FW_INIT_F)\n\t\t\t\t\t*state = DEV_STATE_INIT;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (master_mbox == PCIE_FW_MASTER_M &&\n\t\t\t    (pcie_fw & PCIE_FW_MASTER_VLD_F))\n\t\t\t\tmaster_mbox = PCIE_FW_MASTER_G(pcie_fw);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn master_mbox;\n}\n\n \nint t4_fw_bye(struct adapter *adap, unsigned int mbox)\n{\n\tstruct fw_bye_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tINIT_CMD(c, BYE, WRITE);\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n}\n\n \nint t4_early_init(struct adapter *adap, unsigned int mbox)\n{\n\tstruct fw_initialize_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tINIT_CMD(c, INITIALIZE, WRITE);\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n}\n\n \nint t4_fw_reset(struct adapter *adap, unsigned int mbox, int reset)\n{\n\tstruct fw_reset_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tINIT_CMD(c, RESET, WRITE);\n\tc.val = cpu_to_be32(reset);\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n}\n\n \nstatic int t4_fw_halt(struct adapter *adap, unsigned int mbox, int force)\n{\n\tint ret = 0;\n\n\t \n\tif (mbox <= PCIE_FW_MASTER_M) {\n\t\tstruct fw_reset_cmd c;\n\n\t\tmemset(&c, 0, sizeof(c));\n\t\tINIT_CMD(c, RESET, WRITE);\n\t\tc.val = cpu_to_be32(PIORST_F | PIORSTMODE_F);\n\t\tc.halt_pkd = cpu_to_be32(FW_RESET_CMD_HALT_F);\n\t\tret = t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n\t}\n\n\t \n\tif (ret == 0 || force) {\n\t\tt4_set_reg_field(adap, CIM_BOOT_CFG_A, UPCRST_F, UPCRST_F);\n\t\tt4_set_reg_field(adap, PCIE_FW_A, PCIE_FW_HALT_F,\n\t\t\t\t PCIE_FW_HALT_F);\n\t}\n\n\t \n\treturn ret;\n}\n\n \nstatic int t4_fw_restart(struct adapter *adap, unsigned int mbox, int reset)\n{\n\tif (reset) {\n\t\t \n\t\tt4_set_reg_field(adap, PCIE_FW_A, PCIE_FW_HALT_F, 0);\n\n\t\t \n\t\tif (mbox <= PCIE_FW_MASTER_M) {\n\t\t\tt4_set_reg_field(adap, CIM_BOOT_CFG_A, UPCRST_F, 0);\n\t\t\tmsleep(100);\n\t\t\tif (t4_fw_reset(adap, mbox,\n\t\t\t\t\tPIORST_F | PIORSTMODE_F) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tt4_write_reg(adap, PL_RST_A, PIORST_F | PIORSTMODE_F);\n\t\tmsleep(2000);\n\t} else {\n\t\tint ms;\n\n\t\tt4_set_reg_field(adap, CIM_BOOT_CFG_A, UPCRST_F, 0);\n\t\tfor (ms = 0; ms < FW_CMD_MAX_TIMEOUT; ) {\n\t\t\tif (!(t4_read_reg(adap, PCIE_FW_A) & PCIE_FW_HALT_F))\n\t\t\t\treturn 0;\n\t\t\tmsleep(100);\n\t\t\tms += 100;\n\t\t}\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\n}\n\n \nint t4_fw_upgrade(struct adapter *adap, unsigned int mbox,\n\t\t  const u8 *fw_data, unsigned int size, int force)\n{\n\tconst struct fw_hdr *fw_hdr = (const struct fw_hdr *)fw_data;\n\tint reset, ret;\n\n\tif (!t4_fw_matches_chip(adap, fw_hdr))\n\t\treturn -EINVAL;\n\n\t \n\tadap->flags &= ~CXGB4_FW_OK;\n\n\tret = t4_fw_halt(adap, mbox, force);\n\tif (ret < 0 && !force)\n\t\tgoto out;\n\n\tret = t4_load_fw(adap, fw_data, size);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\t(void)t4_load_cfg(adap, NULL, 0);\n\n\t \n\treset = ((be32_to_cpu(fw_hdr->flags) & FW_HDR_FLAGS_RESET_HALT) == 0);\n\tret = t4_fw_restart(adap, mbox, reset);\n\n\t \n\t(void)t4_init_devlog_params(adap);\nout:\n\tadap->flags |= CXGB4_FW_OK;\n\treturn ret;\n}\n\n \nint t4_fl_pkt_align(struct adapter *adap)\n{\n\tu32 sge_control, sge_control2;\n\tunsigned int ingpadboundary, ingpackboundary, fl_align, ingpad_shift;\n\n\tsge_control = t4_read_reg(adap, SGE_CONTROL_A);\n\n\t \n\tif (CHELSIO_CHIP_VERSION(adap->params.chip) <= CHELSIO_T5)\n\t\tingpad_shift = INGPADBOUNDARY_SHIFT_X;\n\telse\n\t\tingpad_shift = T6_INGPADBOUNDARY_SHIFT_X;\n\n\tingpadboundary = 1 << (INGPADBOUNDARY_G(sge_control) + ingpad_shift);\n\n\tfl_align = ingpadboundary;\n\tif (!is_t4(adap->params.chip)) {\n\t\t \n\t\tsge_control2 = t4_read_reg(adap, SGE_CONTROL2_A);\n\t\tingpackboundary = INGPACKBOUNDARY_G(sge_control2);\n\t\tif (ingpackboundary == INGPACKBOUNDARY_16B_X)\n\t\t\tingpackboundary = 16;\n\t\telse\n\t\t\tingpackboundary = 1 << (ingpackboundary +\n\t\t\t\t\t\tINGPACKBOUNDARY_SHIFT_X);\n\n\t\tfl_align = max(ingpadboundary, ingpackboundary);\n\t}\n\treturn fl_align;\n}\n\n \nint t4_fixup_host_params(struct adapter *adap, unsigned int page_size,\n\t\t\t unsigned int cache_line_size)\n{\n\tunsigned int page_shift = fls(page_size) - 1;\n\tunsigned int sge_hps = page_shift - 10;\n\tunsigned int stat_len = cache_line_size > 64 ? 128 : 64;\n\tunsigned int fl_align = cache_line_size < 32 ? 32 : cache_line_size;\n\tunsigned int fl_align_log = fls(fl_align) - 1;\n\n\tt4_write_reg(adap, SGE_HOST_PAGE_SIZE_A,\n\t\t     HOSTPAGESIZEPF0_V(sge_hps) |\n\t\t     HOSTPAGESIZEPF1_V(sge_hps) |\n\t\t     HOSTPAGESIZEPF2_V(sge_hps) |\n\t\t     HOSTPAGESIZEPF3_V(sge_hps) |\n\t\t     HOSTPAGESIZEPF4_V(sge_hps) |\n\t\t     HOSTPAGESIZEPF5_V(sge_hps) |\n\t\t     HOSTPAGESIZEPF6_V(sge_hps) |\n\t\t     HOSTPAGESIZEPF7_V(sge_hps));\n\n\tif (is_t4(adap->params.chip)) {\n\t\tt4_set_reg_field(adap, SGE_CONTROL_A,\n\t\t\t\t INGPADBOUNDARY_V(INGPADBOUNDARY_M) |\n\t\t\t\t EGRSTATUSPAGESIZE_F,\n\t\t\t\t INGPADBOUNDARY_V(fl_align_log -\n\t\t\t\t\t\t  INGPADBOUNDARY_SHIFT_X) |\n\t\t\t\t EGRSTATUSPAGESIZE_V(stat_len != 64));\n\t} else {\n\t\tunsigned int pack_align;\n\t\tunsigned int ingpad, ingpack;\n\n\t\t \n\n\t\t \n\t\tpack_align = fl_align;\n\t\tif (pci_is_pcie(adap->pdev)) {\n\t\t\tunsigned int mps, mps_log;\n\t\t\tu16 devctl;\n\n\t\t\t \n\t\t\tpcie_capability_read_word(adap->pdev, PCI_EXP_DEVCTL,\n\t\t\t\t\t\t  &devctl);\n\t\t\tmps_log = ((devctl & PCI_EXP_DEVCTL_PAYLOAD) >> 5) + 7;\n\t\t\tmps = 1 << mps_log;\n\t\t\tif (mps > pack_align)\n\t\t\t\tpack_align = mps;\n\t\t}\n\n\t\t \n\t\tif (pack_align <= 16) {\n\t\t\tingpack = INGPACKBOUNDARY_16B_X;\n\t\t\tfl_align = 16;\n\t\t} else if (pack_align == 32) {\n\t\t\tingpack = INGPACKBOUNDARY_64B_X;\n\t\t\tfl_align = 64;\n\t\t} else {\n\t\t\tunsigned int pack_align_log = fls(pack_align) - 1;\n\n\t\t\tingpack = pack_align_log - INGPACKBOUNDARY_SHIFT_X;\n\t\t\tfl_align = pack_align;\n\t\t}\n\n\t\t \n\t\tif (is_t5(adap->params.chip))\n\t\t\tingpad = INGPADBOUNDARY_32B_X;\n\t\telse\n\t\t\tingpad = T6_INGPADBOUNDARY_8B_X;\n\n\t\tt4_set_reg_field(adap, SGE_CONTROL_A,\n\t\t\t\t INGPADBOUNDARY_V(INGPADBOUNDARY_M) |\n\t\t\t\t EGRSTATUSPAGESIZE_F,\n\t\t\t\t INGPADBOUNDARY_V(ingpad) |\n\t\t\t\t EGRSTATUSPAGESIZE_V(stat_len != 64));\n\t\tt4_set_reg_field(adap, SGE_CONTROL2_A,\n\t\t\t\t INGPACKBOUNDARY_V(INGPACKBOUNDARY_M),\n\t\t\t\t INGPACKBOUNDARY_V(ingpack));\n\t}\n\t \n\tt4_write_reg(adap, SGE_FL_BUFFER_SIZE0_A, page_size);\n\tt4_write_reg(adap, SGE_FL_BUFFER_SIZE2_A,\n\t\t     (t4_read_reg(adap, SGE_FL_BUFFER_SIZE2_A) + fl_align-1)\n\t\t     & ~(fl_align-1));\n\tt4_write_reg(adap, SGE_FL_BUFFER_SIZE3_A,\n\t\t     (t4_read_reg(adap, SGE_FL_BUFFER_SIZE3_A) + fl_align-1)\n\t\t     & ~(fl_align-1));\n\n\tt4_write_reg(adap, ULP_RX_TDDP_PSZ_A, HPZ0_V(page_shift - 12));\n\n\treturn 0;\n}\n\n \nint t4_fw_initialize(struct adapter *adap, unsigned int mbox)\n{\n\tstruct fw_initialize_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tINIT_CMD(c, INITIALIZE, WRITE);\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n}\n\n \nint t4_query_params_rw(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\t       unsigned int vf, unsigned int nparams, const u32 *params,\n\t\t       u32 *val, int rw, bool sleep_ok)\n{\n\tint i, ret;\n\tstruct fw_params_cmd c;\n\t__be32 *p = &c.param[0].mnem;\n\n\tif (nparams > 7)\n\t\treturn -EINVAL;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PARAMS_CMD) |\n\t\t\t\t  FW_CMD_REQUEST_F | FW_CMD_READ_F |\n\t\t\t\t  FW_PARAMS_CMD_PFN_V(pf) |\n\t\t\t\t  FW_PARAMS_CMD_VFN_V(vf));\n\tc.retval_len16 = cpu_to_be32(FW_LEN16(c));\n\n\tfor (i = 0; i < nparams; i++) {\n\t\t*p++ = cpu_to_be32(*params++);\n\t\tif (rw)\n\t\t\t*p = cpu_to_be32(*(val + i));\n\t\tp++;\n\t}\n\n\tret = t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), &c, sleep_ok);\n\tif (ret == 0)\n\t\tfor (i = 0, p = &c.param[0].val; i < nparams; i++, p += 2)\n\t\t\t*val++ = be32_to_cpu(*p);\n\treturn ret;\n}\n\nint t4_query_params(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\t    unsigned int vf, unsigned int nparams, const u32 *params,\n\t\t    u32 *val)\n{\n\treturn t4_query_params_rw(adap, mbox, pf, vf, nparams, params, val, 0,\n\t\t\t\t  true);\n}\n\nint t4_query_params_ns(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\t       unsigned int vf, unsigned int nparams, const u32 *params,\n\t\t       u32 *val)\n{\n\treturn t4_query_params_rw(adap, mbox, pf, vf, nparams, params, val, 0,\n\t\t\t\t  false);\n}\n\n \nint t4_set_params_timeout(struct adapter *adap, unsigned int mbox,\n\t\t\t  unsigned int pf, unsigned int vf,\n\t\t\t  unsigned int nparams, const u32 *params,\n\t\t\t  const u32 *val, int timeout)\n{\n\tstruct fw_params_cmd c;\n\t__be32 *p = &c.param[0].mnem;\n\n\tif (nparams > 7)\n\t\treturn -EINVAL;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PARAMS_CMD) |\n\t\t\t\t  FW_CMD_REQUEST_F | FW_CMD_WRITE_F |\n\t\t\t\t  FW_PARAMS_CMD_PFN_V(pf) |\n\t\t\t\t  FW_PARAMS_CMD_VFN_V(vf));\n\tc.retval_len16 = cpu_to_be32(FW_LEN16(c));\n\n\twhile (nparams--) {\n\t\t*p++ = cpu_to_be32(*params++);\n\t\t*p++ = cpu_to_be32(*val++);\n\t}\n\n\treturn t4_wr_mbox_timeout(adap, mbox, &c, sizeof(c), NULL, timeout);\n}\n\n \nint t4_set_params(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\t  unsigned int vf, unsigned int nparams, const u32 *params,\n\t\t  const u32 *val)\n{\n\treturn t4_set_params_timeout(adap, mbox, pf, vf, nparams, params, val,\n\t\t\t\t     FW_CMD_MAX_TIMEOUT);\n}\n\n \nint t4_cfg_pfvf(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\tunsigned int vf, unsigned int txq, unsigned int txq_eth_ctrl,\n\t\tunsigned int rxqi, unsigned int rxq, unsigned int tc,\n\t\tunsigned int vi, unsigned int cmask, unsigned int pmask,\n\t\tunsigned int nexact, unsigned int rcaps, unsigned int wxcaps)\n{\n\tstruct fw_pfvf_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PFVF_CMD) | FW_CMD_REQUEST_F |\n\t\t\t\t  FW_CMD_WRITE_F | FW_PFVF_CMD_PFN_V(pf) |\n\t\t\t\t  FW_PFVF_CMD_VFN_V(vf));\n\tc.retval_len16 = cpu_to_be32(FW_LEN16(c));\n\tc.niqflint_niq = cpu_to_be32(FW_PFVF_CMD_NIQFLINT_V(rxqi) |\n\t\t\t\t     FW_PFVF_CMD_NIQ_V(rxq));\n\tc.type_to_neq = cpu_to_be32(FW_PFVF_CMD_CMASK_V(cmask) |\n\t\t\t\t    FW_PFVF_CMD_PMASK_V(pmask) |\n\t\t\t\t    FW_PFVF_CMD_NEQ_V(txq));\n\tc.tc_to_nexactf = cpu_to_be32(FW_PFVF_CMD_TC_V(tc) |\n\t\t\t\t      FW_PFVF_CMD_NVI_V(vi) |\n\t\t\t\t      FW_PFVF_CMD_NEXACTF_V(nexact));\n\tc.r_caps_to_nethctrl = cpu_to_be32(FW_PFVF_CMD_R_CAPS_V(rcaps) |\n\t\t\t\t\tFW_PFVF_CMD_WX_CAPS_V(wxcaps) |\n\t\t\t\t\tFW_PFVF_CMD_NETHCTRL_V(txq_eth_ctrl));\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n}\n\n \nint t4_alloc_vi(struct adapter *adap, unsigned int mbox, unsigned int port,\n\t\tunsigned int pf, unsigned int vf, unsigned int nmac, u8 *mac,\n\t\tunsigned int *rss_size, u8 *vivld, u8 *vin)\n{\n\tint ret;\n\tstruct fw_vi_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_VI_CMD) | FW_CMD_REQUEST_F |\n\t\t\t\t  FW_CMD_WRITE_F | FW_CMD_EXEC_F |\n\t\t\t\t  FW_VI_CMD_PFN_V(pf) | FW_VI_CMD_VFN_V(vf));\n\tc.alloc_to_len16 = cpu_to_be32(FW_VI_CMD_ALLOC_F | FW_LEN16(c));\n\tc.portid_pkd = FW_VI_CMD_PORTID_V(port);\n\tc.nmac = nmac - 1;\n\n\tret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mac) {\n\t\tmemcpy(mac, c.mac, sizeof(c.mac));\n\t\tswitch (nmac) {\n\t\tcase 5:\n\t\t\tmemcpy(mac + 24, c.nmac3, sizeof(c.nmac3));\n\t\t\tfallthrough;\n\t\tcase 4:\n\t\t\tmemcpy(mac + 18, c.nmac2, sizeof(c.nmac2));\n\t\t\tfallthrough;\n\t\tcase 3:\n\t\t\tmemcpy(mac + 12, c.nmac1, sizeof(c.nmac1));\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tmemcpy(mac + 6,  c.nmac0, sizeof(c.nmac0));\n\t\t}\n\t}\n\tif (rss_size)\n\t\t*rss_size = FW_VI_CMD_RSSSIZE_G(be16_to_cpu(c.rsssize_pkd));\n\n\tif (vivld)\n\t\t*vivld = FW_VI_CMD_VFVLD_G(be32_to_cpu(c.alloc_to_len16));\n\n\tif (vin)\n\t\t*vin = FW_VI_CMD_VIN_G(be32_to_cpu(c.alloc_to_len16));\n\n\treturn FW_VI_CMD_VIID_G(be16_to_cpu(c.type_viid));\n}\n\n \nint t4_free_vi(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t       unsigned int vf, unsigned int viid)\n{\n\tstruct fw_vi_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_VI_CMD) |\n\t\t\t\t  FW_CMD_REQUEST_F |\n\t\t\t\t  FW_CMD_EXEC_F |\n\t\t\t\t  FW_VI_CMD_PFN_V(pf) |\n\t\t\t\t  FW_VI_CMD_VFN_V(vf));\n\tc.alloc_to_len16 = cpu_to_be32(FW_VI_CMD_FREE_F | FW_LEN16(c));\n\tc.type_viid = cpu_to_be16(FW_VI_CMD_VIID_V(viid));\n\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);\n}\n\n \nint t4_set_rxmode(struct adapter *adap, unsigned int mbox, unsigned int viid,\n\t\t  unsigned int viid_mirror, int mtu, int promisc, int all_multi,\n\t\t  int bcast, int vlanex, bool sleep_ok)\n{\n\tstruct fw_vi_rxmode_cmd c, c_mirror;\n\tint ret;\n\n\t \n\tif (mtu < 0)\n\t\tmtu = FW_RXMODE_MTU_NO_CHG;\n\tif (promisc < 0)\n\t\tpromisc = FW_VI_RXMODE_CMD_PROMISCEN_M;\n\tif (all_multi < 0)\n\t\tall_multi = FW_VI_RXMODE_CMD_ALLMULTIEN_M;\n\tif (bcast < 0)\n\t\tbcast = FW_VI_RXMODE_CMD_BROADCASTEN_M;\n\tif (vlanex < 0)\n\t\tvlanex = FW_VI_RXMODE_CMD_VLANEXEN_M;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_RXMODE_CMD) |\n\t\t\t\t   FW_CMD_REQUEST_F | FW_CMD_WRITE_F |\n\t\t\t\t   FW_VI_RXMODE_CMD_VIID_V(viid));\n\tc.retval_len16 = cpu_to_be32(FW_LEN16(c));\n\tc.mtu_to_vlanexen =\n\t\tcpu_to_be32(FW_VI_RXMODE_CMD_MTU_V(mtu) |\n\t\t\t    FW_VI_RXMODE_CMD_PROMISCEN_V(promisc) |\n\t\t\t    FW_VI_RXMODE_CMD_ALLMULTIEN_V(all_multi) |\n\t\t\t    FW_VI_RXMODE_CMD_BROADCASTEN_V(bcast) |\n\t\t\t    FW_VI_RXMODE_CMD_VLANEXEN_V(vlanex));\n\n\tif (viid_mirror) {\n\t\tmemcpy(&c_mirror, &c, sizeof(c_mirror));\n\t\tc_mirror.op_to_viid =\n\t\t\tcpu_to_be32(FW_CMD_OP_V(FW_VI_RXMODE_CMD) |\n\t\t\t\t    FW_CMD_REQUEST_F | FW_CMD_WRITE_F |\n\t\t\t\t    FW_VI_RXMODE_CMD_VIID_V(viid_mirror));\n\t}\n\n\tret = t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), NULL, sleep_ok);\n\tif (ret)\n\t\treturn ret;\n\n\tif (viid_mirror)\n\t\tret = t4_wr_mbox_meat(adap, mbox, &c_mirror, sizeof(c_mirror),\n\t\t\t\t      NULL, sleep_ok);\n\n\treturn ret;\n}\n\n \nint t4_free_encap_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\t   int idx, bool sleep_ok)\n{\n\tstruct fw_vi_mac_exact *p;\n\tstruct fw_vi_mac_cmd c;\n\tint ret = 0;\n\tu32 exact;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\n\t\t\t\t   FW_CMD_REQUEST_F | FW_CMD_WRITE_F |\n\t\t\t\t   FW_CMD_EXEC_V(0) |\n\t\t\t\t   FW_VI_MAC_CMD_VIID_V(viid));\n\texact = FW_VI_MAC_CMD_ENTRY_TYPE_V(FW_VI_MAC_TYPE_EXACTMAC);\n\tc.freemacs_to_len16 = cpu_to_be32(FW_VI_MAC_CMD_FREEMACS_V(0) |\n\t\t\t\t\t  exact |\n\t\t\t\t\t  FW_CMD_LEN16_V(1));\n\tp = c.u.exact;\n\tp->valid_to_idx = cpu_to_be16(FW_VI_MAC_CMD_VALID_F |\n\t\t\t\t      FW_VI_MAC_CMD_IDX_V(idx));\n\teth_zero_addr(p->macaddr);\n\tret = t4_wr_mbox_meat(adap, adap->mbox, &c, sizeof(c), &c, sleep_ok);\n\treturn ret;\n}\n\n \nint t4_free_raw_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\t const u8 *addr, const u8 *mask, unsigned int idx,\n\t\t\t u8 lookup_type, u8 port_id, bool sleep_ok)\n{\n\tstruct fw_vi_mac_cmd c;\n\tstruct fw_vi_mac_raw *p = &c.u.raw;\n\tu32 val;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\n\t\t\t\t   FW_CMD_REQUEST_F | FW_CMD_WRITE_F |\n\t\t\t\t   FW_CMD_EXEC_V(0) |\n\t\t\t\t   FW_VI_MAC_CMD_VIID_V(viid));\n\tval = FW_CMD_LEN16_V(1) |\n\t      FW_VI_MAC_CMD_ENTRY_TYPE_V(FW_VI_MAC_TYPE_RAW);\n\tc.freemacs_to_len16 = cpu_to_be32(FW_VI_MAC_CMD_FREEMACS_V(0) |\n\t\t\t\t\t  FW_CMD_LEN16_V(val));\n\n\tp->raw_idx_pkd = cpu_to_be32(FW_VI_MAC_CMD_RAW_IDX_V(idx) |\n\t\t\t\t     FW_VI_MAC_ID_BASED_FREE);\n\n\t \n\tp->data0_pkd = cpu_to_be32(DATALKPTYPE_V(lookup_type) |\n\t\t\t\t   DATAPORTNUM_V(port_id));\n\t \n\tp->data0m_pkd = cpu_to_be64(DATALKPTYPE_V(DATALKPTYPE_M) |\n\t\t\t\t    DATAPORTNUM_V(DATAPORTNUM_M));\n\n\t \n\tmemcpy((u8 *)&p->data1[0] + 2, addr, ETH_ALEN);\n\tmemcpy((u8 *)&p->data1m[0] + 2, mask, ETH_ALEN);\n\n\treturn t4_wr_mbox_meat(adap, adap->mbox, &c, sizeof(c), &c, sleep_ok);\n}\n\n \nint t4_alloc_encap_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\t    const u8 *addr, const u8 *mask, unsigned int vni,\n\t\t\t    unsigned int vni_mask, u8 dip_hit, u8 lookup_type,\n\t\t\t    bool sleep_ok)\n{\n\tstruct fw_vi_mac_cmd c;\n\tstruct fw_vi_mac_vni *p = c.u.exact_vni;\n\tint ret = 0;\n\tu32 val;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\n\t\t\t\t   FW_CMD_REQUEST_F | FW_CMD_WRITE_F |\n\t\t\t\t   FW_VI_MAC_CMD_VIID_V(viid));\n\tval = FW_CMD_LEN16_V(1) |\n\t      FW_VI_MAC_CMD_ENTRY_TYPE_V(FW_VI_MAC_TYPE_EXACTMAC_VNI);\n\tc.freemacs_to_len16 = cpu_to_be32(val);\n\tp->valid_to_idx = cpu_to_be16(FW_VI_MAC_CMD_VALID_F |\n\t\t\t\t      FW_VI_MAC_CMD_IDX_V(FW_VI_MAC_ADD_MAC));\n\tmemcpy(p->macaddr, addr, sizeof(p->macaddr));\n\tmemcpy(p->macaddr_mask, mask, sizeof(p->macaddr_mask));\n\n\tp->lookup_type_to_vni =\n\t\tcpu_to_be32(FW_VI_MAC_CMD_VNI_V(vni) |\n\t\t\t    FW_VI_MAC_CMD_DIP_HIT_V(dip_hit) |\n\t\t\t    FW_VI_MAC_CMD_LOOKUP_TYPE_V(lookup_type));\n\tp->vni_mask_pkd = cpu_to_be32(FW_VI_MAC_CMD_VNI_MASK_V(vni_mask));\n\tret = t4_wr_mbox_meat(adap, adap->mbox, &c, sizeof(c), &c, sleep_ok);\n\tif (ret == 0)\n\t\tret = FW_VI_MAC_CMD_IDX_G(be16_to_cpu(p->valid_to_idx));\n\treturn ret;\n}\n\n \nint t4_alloc_raw_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\t  const u8 *addr, const u8 *mask, unsigned int idx,\n\t\t\t  u8 lookup_type, u8 port_id, bool sleep_ok)\n{\n\tint ret = 0;\n\tstruct fw_vi_mac_cmd c;\n\tstruct fw_vi_mac_raw *p = &c.u.raw;\n\tu32 val;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\n\t\t\t\t   FW_CMD_REQUEST_F | FW_CMD_WRITE_F |\n\t\t\t\t   FW_VI_MAC_CMD_VIID_V(viid));\n\tval = FW_CMD_LEN16_V(1) |\n\t      FW_VI_MAC_CMD_ENTRY_TYPE_V(FW_VI_MAC_TYPE_RAW);\n\tc.freemacs_to_len16 = cpu_to_be32(val);\n\n\t \n\tp->raw_idx_pkd = cpu_to_be32(FW_VI_MAC_CMD_RAW_IDX_V(idx));\n\n\t \n\tp->data0_pkd = cpu_to_be32(DATALKPTYPE_V(lookup_type) |\n\t\t\t\t   DATAPORTNUM_V(port_id));\n\t \n\tp->data0m_pkd = cpu_to_be64(DATALKPTYPE_V(DATALKPTYPE_M) |\n\t\t\t\t    DATAPORTNUM_V(DATAPORTNUM_M));\n\n\t \n\tmemcpy((u8 *)&p->data1[0] + 2, addr, ETH_ALEN);\n\tmemcpy((u8 *)&p->data1m[0] + 2, mask, ETH_ALEN);\n\n\tret = t4_wr_mbox_meat(adap, adap->mbox, &c, sizeof(c), &c, sleep_ok);\n\tif (ret == 0) {\n\t\tret = FW_VI_MAC_CMD_RAW_IDX_G(be32_to_cpu(p->raw_idx_pkd));\n\t\tif (ret != idx)\n\t\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}\n\n \nint t4_alloc_mac_filt(struct adapter *adap, unsigned int mbox,\n\t\t      unsigned int viid, bool free, unsigned int naddr,\n\t\t      const u8 **addr, u16 *idx, u64 *hash, bool sleep_ok)\n{\n\tint offset, ret = 0;\n\tstruct fw_vi_mac_cmd c;\n\tunsigned int nfilters = 0;\n\tunsigned int max_naddr = adap->params.arch.mps_tcam_size;\n\tunsigned int rem = naddr;\n\n\tif (naddr > max_naddr)\n\t\treturn -EINVAL;\n\n\tfor (offset = 0; offset < naddr ;  ) {\n\t\tunsigned int fw_naddr = (rem < ARRAY_SIZE(c.u.exact) ?\n\t\t\t\t\t rem : ARRAY_SIZE(c.u.exact));\n\t\tsize_t len16 = DIV_ROUND_UP(offsetof(struct fw_vi_mac_cmd,\n\t\t\t\t\t\t     u.exact[fw_naddr]), 16);\n\t\tstruct fw_vi_mac_exact *p;\n\t\tint i;\n\n\t\tmemset(&c, 0, sizeof(c));\n\t\tc.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\n\t\t\t\t\t   FW_CMD_REQUEST_F |\n\t\t\t\t\t   FW_CMD_WRITE_F |\n\t\t\t\t\t   FW_CMD_EXEC_V(free) |\n\t\t\t\t\t   FW_VI_MAC_CMD_VIID_V(viid));\n\t\tc.freemacs_to_len16 =\n\t\t\tcpu_to_be32(FW_VI_MAC_CMD_FREEMACS_V(free) |\n\t\t\t\t    FW_CMD_LEN16_V(len16));\n\n\t\tfor (i = 0, p = c.u.exact; i < fw_naddr; i++, p++) {\n\t\t\tp->valid_to_idx =\n\t\t\t\tcpu_to_be16(FW_VI_MAC_CMD_VALID_F |\n\t\t\t\t\t    FW_VI_MAC_CMD_IDX_V(\n\t\t\t\t\t\t    FW_VI_MAC_ADD_MAC));\n\t\t\tmemcpy(p->macaddr, addr[offset + i],\n\t\t\t       sizeof(p->macaddr));\n\t\t}\n\n\t\t \n\t\tret = t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), &c, sleep_ok);\n\t\tif (ret && ret != -FW_ENOMEM)\n\t\t\tbreak;\n\n\t\tfor (i = 0, p = c.u.exact; i < fw_naddr; i++, p++) {\n\t\t\tu16 index = FW_VI_MAC_CMD_IDX_G(\n\t\t\t\t\tbe16_to_cpu(p->valid_to_idx));\n\n\t\t\tif (idx)\n\t\t\t\tidx[offset + i] = (index >= max_naddr ?\n\t\t\t\t\t\t   0xffff : index);\n\t\t\tif (index < max_naddr)\n\t\t\t\tnfilters++;\n\t\t\telse if (hash)\n\t\t\t\t*hash |= (1ULL <<\n\t\t\t\t\t  hash_mac_addr(addr[offset + i]));\n\t\t}\n\n\t\tfree = false;\n\t\toffset += fw_naddr;\n\t\trem -= fw_naddr;\n\t}\n\n\tif (ret == 0 || ret == -FW_ENOMEM)\n\t\tret = nfilters;\n\treturn ret;\n}\n\n \nint t4_free_mac_filt(struct adapter *adap, unsigned int mbox,\n\t\t     unsigned int viid, unsigned int naddr,\n\t\t     const u8 **addr, bool sleep_ok)\n{\n\tint offset, ret = 0;\n\tstruct fw_vi_mac_cmd c;\n\tunsigned int nfilters = 0;\n\tunsigned int max_naddr = is_t4(adap->params.chip) ?\n\t\t\t\t       NUM_MPS_CLS_SRAM_L_INSTANCES :\n\t\t\t\t       NUM_MPS_T5_CLS_SRAM_L_INSTANCES;\n\tunsigned int rem = naddr;\n\n\tif (naddr > max_naddr)\n\t\treturn -EINVAL;\n\n\tfor (offset = 0; offset < (int)naddr ;  ) {\n\t\tunsigned int fw_naddr = (rem < ARRAY_SIZE(c.u.exact)\n\t\t\t\t\t ? rem\n\t\t\t\t\t : ARRAY_SIZE(c.u.exact));\n\t\tsize_t len16 = DIV_ROUND_UP(offsetof(struct fw_vi_mac_cmd,\n\t\t\t\t\t\t     u.exact[fw_naddr]), 16);\n\t\tstruct fw_vi_mac_exact *p;\n\t\tint i;\n\n\t\tmemset(&c, 0, sizeof(c));\n\t\tc.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t     FW_CMD_EXEC_V(0) |\n\t\t\t\t     FW_VI_MAC_CMD_VIID_V(viid));\n\t\tc.freemacs_to_len16 =\n\t\t\t\tcpu_to_be32(FW_VI_MAC_CMD_FREEMACS_V(0) |\n\t\t\t\t\t    FW_CMD_LEN16_V(len16));\n\n\t\tfor (i = 0, p = c.u.exact; i < (int)fw_naddr; i++, p++) {\n\t\t\tp->valid_to_idx = cpu_to_be16(\n\t\t\t\tFW_VI_MAC_CMD_VALID_F |\n\t\t\t\tFW_VI_MAC_CMD_IDX_V(FW_VI_MAC_MAC_BASED_FREE));\n\t\t\tmemcpy(p->macaddr, addr[offset+i], sizeof(p->macaddr));\n\t\t}\n\n\t\tret = t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), &c, sleep_ok);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tfor (i = 0, p = c.u.exact; i < fw_naddr; i++, p++) {\n\t\t\tu16 index = FW_VI_MAC_CMD_IDX_G(\n\t\t\t\t\t\tbe16_to_cpu(p->valid_to_idx));\n\n\t\t\tif (index < max_naddr)\n\t\t\t\tnfilters++;\n\t\t}\n\n\t\toffset += fw_naddr;\n\t\trem -= fw_naddr;\n\t}\n\n\tif (ret == 0)\n\t\tret = nfilters;\n\treturn ret;\n}\n\n \nint t4_change_mac(struct adapter *adap, unsigned int mbox, unsigned int viid,\n\t\t  int idx, const u8 *addr, bool persist, u8 *smt_idx)\n{\n\tint ret, mode;\n\tstruct fw_vi_mac_cmd c;\n\tstruct fw_vi_mac_exact *p = c.u.exact;\n\tunsigned int max_mac_addr = adap->params.arch.mps_tcam_size;\n\n\tif (idx < 0)                              \n\t\tidx = persist ? FW_VI_MAC_ADD_PERSIST_MAC : FW_VI_MAC_ADD_MAC;\n\tmode = smt_idx ? FW_VI_MAC_SMT_AND_MPSTCAM : FW_VI_MAC_MPS_TCAM_ENTRY;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\n\t\t\t\t   FW_CMD_REQUEST_F | FW_CMD_WRITE_F |\n\t\t\t\t   FW_VI_MAC_CMD_VIID_V(viid));\n\tc.freemacs_to_len16 = cpu_to_be32(FW_CMD_LEN16_V(1));\n\tp->valid_to_idx = cpu_to_be16(FW_VI_MAC_CMD_VALID_F |\n\t\t\t\t      FW_VI_MAC_CMD_SMAC_RESULT_V(mode) |\n\t\t\t\t      FW_VI_MAC_CMD_IDX_V(idx));\n\tmemcpy(p->macaddr, addr, sizeof(p->macaddr));\n\n\tret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);\n\tif (ret == 0) {\n\t\tret = FW_VI_MAC_CMD_IDX_G(be16_to_cpu(p->valid_to_idx));\n\t\tif (ret >= max_mac_addr)\n\t\t\tret = -ENOMEM;\n\t\tif (smt_idx) {\n\t\t\tif (adap->params.viid_smt_extn_support) {\n\t\t\t\t*smt_idx = FW_VI_MAC_CMD_SMTID_G\n\t\t\t\t\t\t    (be32_to_cpu(c.op_to_viid));\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (CHELSIO_CHIP_VERSION(adap->params.chip) <=\n\t\t\t\t\t\t\t\t     CHELSIO_T5)\n\t\t\t\t\t*smt_idx = (viid & FW_VIID_VIN_M) << 1;\n\t\t\t\telse\n\t\t\t\t\t*smt_idx = (viid & FW_VIID_VIN_M);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nint t4_set_addr_hash(struct adapter *adap, unsigned int mbox, unsigned int viid,\n\t\t     bool ucast, u64 vec, bool sleep_ok)\n{\n\tstruct fw_vi_mac_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\n\t\t\t\t   FW_CMD_REQUEST_F | FW_CMD_WRITE_F |\n\t\t\t\t   FW_VI_ENABLE_CMD_VIID_V(viid));\n\tc.freemacs_to_len16 = cpu_to_be32(FW_VI_MAC_CMD_HASHVECEN_F |\n\t\t\t\t\t  FW_VI_MAC_CMD_HASHUNIEN_V(ucast) |\n\t\t\t\t\t  FW_CMD_LEN16_V(1));\n\tc.u.hash.hashvec = cpu_to_be64(vec);\n\treturn t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), NULL, sleep_ok);\n}\n\n \nint t4_enable_vi_params(struct adapter *adap, unsigned int mbox,\n\t\t\tunsigned int viid, bool rx_en, bool tx_en, bool dcb_en)\n{\n\tstruct fw_vi_enable_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_ENABLE_CMD) |\n\t\t\t\t   FW_CMD_REQUEST_F | FW_CMD_EXEC_F |\n\t\t\t\t   FW_VI_ENABLE_CMD_VIID_V(viid));\n\tc.ien_to_len16 = cpu_to_be32(FW_VI_ENABLE_CMD_IEN_V(rx_en) |\n\t\t\t\t     FW_VI_ENABLE_CMD_EEN_V(tx_en) |\n\t\t\t\t     FW_VI_ENABLE_CMD_DCB_INFO_V(dcb_en) |\n\t\t\t\t     FW_LEN16(c));\n\treturn t4_wr_mbox_ns(adap, mbox, &c, sizeof(c), NULL);\n}\n\n \nint t4_enable_vi(struct adapter *adap, unsigned int mbox, unsigned int viid,\n\t\t bool rx_en, bool tx_en)\n{\n\treturn t4_enable_vi_params(adap, mbox, viid, rx_en, tx_en, 0);\n}\n\n \nint t4_enable_pi_params(struct adapter *adap, unsigned int mbox,\n\t\t\tstruct port_info *pi,\n\t\t\tbool rx_en, bool tx_en, bool dcb_en)\n{\n\tint ret = t4_enable_vi_params(adap, mbox, pi->viid,\n\t\t\t\t      rx_en, tx_en, dcb_en);\n\tif (ret)\n\t\treturn ret;\n\tt4_os_link_changed(adap, pi->port_id,\n\t\t\t   rx_en && tx_en && pi->link_cfg.link_ok);\n\treturn 0;\n}\n\n \nint t4_identify_port(struct adapter *adap, unsigned int mbox, unsigned int viid,\n\t\t     unsigned int nblinks)\n{\n\tstruct fw_vi_enable_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_ENABLE_CMD) |\n\t\t\t\t   FW_CMD_REQUEST_F | FW_CMD_EXEC_F |\n\t\t\t\t   FW_VI_ENABLE_CMD_VIID_V(viid));\n\tc.ien_to_len16 = cpu_to_be32(FW_VI_ENABLE_CMD_LED_F | FW_LEN16(c));\n\tc.blinkdur = cpu_to_be16(nblinks);\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n}\n\n \nint t4_iq_stop(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t       unsigned int vf, unsigned int iqtype, unsigned int iqid,\n\t       unsigned int fl0id, unsigned int fl1id)\n{\n\tstruct fw_iq_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_IQ_CMD) | FW_CMD_REQUEST_F |\n\t\t\t\t  FW_CMD_EXEC_F | FW_IQ_CMD_PFN_V(pf) |\n\t\t\t\t  FW_IQ_CMD_VFN_V(vf));\n\tc.alloc_to_len16 = cpu_to_be32(FW_IQ_CMD_IQSTOP_F | FW_LEN16(c));\n\tc.type_to_iqandstindex = cpu_to_be32(FW_IQ_CMD_TYPE_V(iqtype));\n\tc.iqid = cpu_to_be16(iqid);\n\tc.fl0id = cpu_to_be16(fl0id);\n\tc.fl1id = cpu_to_be16(fl1id);\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n}\n\n \nint t4_iq_free(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t       unsigned int vf, unsigned int iqtype, unsigned int iqid,\n\t       unsigned int fl0id, unsigned int fl1id)\n{\n\tstruct fw_iq_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_IQ_CMD) | FW_CMD_REQUEST_F |\n\t\t\t\t  FW_CMD_EXEC_F | FW_IQ_CMD_PFN_V(pf) |\n\t\t\t\t  FW_IQ_CMD_VFN_V(vf));\n\tc.alloc_to_len16 = cpu_to_be32(FW_IQ_CMD_FREE_F | FW_LEN16(c));\n\tc.type_to_iqandstindex = cpu_to_be32(FW_IQ_CMD_TYPE_V(iqtype));\n\tc.iqid = cpu_to_be16(iqid);\n\tc.fl0id = cpu_to_be16(fl0id);\n\tc.fl1id = cpu_to_be16(fl1id);\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n}\n\n \nint t4_eth_eq_free(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\t   unsigned int vf, unsigned int eqid)\n{\n\tstruct fw_eq_eth_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_EQ_ETH_CMD) |\n\t\t\t\t  FW_CMD_REQUEST_F | FW_CMD_EXEC_F |\n\t\t\t\t  FW_EQ_ETH_CMD_PFN_V(pf) |\n\t\t\t\t  FW_EQ_ETH_CMD_VFN_V(vf));\n\tc.alloc_to_len16 = cpu_to_be32(FW_EQ_ETH_CMD_FREE_F | FW_LEN16(c));\n\tc.eqid_pkd = cpu_to_be32(FW_EQ_ETH_CMD_EQID_V(eqid));\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n}\n\n \nint t4_ctrl_eq_free(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\t    unsigned int vf, unsigned int eqid)\n{\n\tstruct fw_eq_ctrl_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_EQ_CTRL_CMD) |\n\t\t\t\t  FW_CMD_REQUEST_F | FW_CMD_EXEC_F |\n\t\t\t\t  FW_EQ_CTRL_CMD_PFN_V(pf) |\n\t\t\t\t  FW_EQ_CTRL_CMD_VFN_V(vf));\n\tc.alloc_to_len16 = cpu_to_be32(FW_EQ_CTRL_CMD_FREE_F | FW_LEN16(c));\n\tc.cmpliqid_eqid = cpu_to_be32(FW_EQ_CTRL_CMD_EQID_V(eqid));\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n}\n\n \nint t4_ofld_eq_free(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\t    unsigned int vf, unsigned int eqid)\n{\n\tstruct fw_eq_ofld_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_EQ_OFLD_CMD) |\n\t\t\t\t  FW_CMD_REQUEST_F | FW_CMD_EXEC_F |\n\t\t\t\t  FW_EQ_OFLD_CMD_PFN_V(pf) |\n\t\t\t\t  FW_EQ_OFLD_CMD_VFN_V(vf));\n\tc.alloc_to_len16 = cpu_to_be32(FW_EQ_OFLD_CMD_FREE_F | FW_LEN16(c));\n\tc.eqid_pkd = cpu_to_be32(FW_EQ_OFLD_CMD_EQID_V(eqid));\n\treturn t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);\n}\n\n \nstatic const char *t4_link_down_rc_str(unsigned char link_down_rc)\n{\n\tstatic const char * const reason[] = {\n\t\t\"Link Down\",\n\t\t\"Remote Fault\",\n\t\t\"Auto-negotiation Failure\",\n\t\t\"Reserved\",\n\t\t\"Insufficient Airflow\",\n\t\t\"Unable To Determine Reason\",\n\t\t\"No RX Signal Detected\",\n\t\t\"Reserved\",\n\t};\n\n\tif (link_down_rc >= ARRAY_SIZE(reason))\n\t\treturn \"Bad Reason Code\";\n\n\treturn reason[link_down_rc];\n}\n\n \nstatic unsigned int fwcap_to_speed(fw_port_cap32_t caps)\n{\n\t#define TEST_SPEED_RETURN(__caps_speed, __speed) \\\n\t\tdo { \\\n\t\t\tif (caps & FW_PORT_CAP32_SPEED_##__caps_speed) \\\n\t\t\t\treturn __speed; \\\n\t\t} while (0)\n\n\tTEST_SPEED_RETURN(400G, 400000);\n\tTEST_SPEED_RETURN(200G, 200000);\n\tTEST_SPEED_RETURN(100G, 100000);\n\tTEST_SPEED_RETURN(50G,   50000);\n\tTEST_SPEED_RETURN(40G,   40000);\n\tTEST_SPEED_RETURN(25G,   25000);\n\tTEST_SPEED_RETURN(10G,   10000);\n\tTEST_SPEED_RETURN(1G,     1000);\n\tTEST_SPEED_RETURN(100M,    100);\n\n\t#undef TEST_SPEED_RETURN\n\n\treturn 0;\n}\n\n \nstatic fw_port_cap32_t fwcap_to_fwspeed(fw_port_cap32_t acaps)\n{\n\t#define TEST_SPEED_RETURN(__caps_speed) \\\n\t\tdo { \\\n\t\t\tif (acaps & FW_PORT_CAP32_SPEED_##__caps_speed) \\\n\t\t\t\treturn FW_PORT_CAP32_SPEED_##__caps_speed; \\\n\t\t} while (0)\n\n\tTEST_SPEED_RETURN(400G);\n\tTEST_SPEED_RETURN(200G);\n\tTEST_SPEED_RETURN(100G);\n\tTEST_SPEED_RETURN(50G);\n\tTEST_SPEED_RETURN(40G);\n\tTEST_SPEED_RETURN(25G);\n\tTEST_SPEED_RETURN(10G);\n\tTEST_SPEED_RETURN(1G);\n\tTEST_SPEED_RETURN(100M);\n\n\t#undef TEST_SPEED_RETURN\n\n\treturn 0;\n}\n\n \nstatic fw_port_cap32_t lstatus_to_fwcap(u32 lstatus)\n{\n\tfw_port_cap32_t linkattr = 0;\n\n\t \n\tif (lstatus & FW_PORT_CMD_RXPAUSE_F)\n\t\tlinkattr |= FW_PORT_CAP32_FC_RX;\n\tif (lstatus & FW_PORT_CMD_TXPAUSE_F)\n\t\tlinkattr |= FW_PORT_CAP32_FC_TX;\n\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_100M))\n\t\tlinkattr |= FW_PORT_CAP32_SPEED_100M;\n\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_1G))\n\t\tlinkattr |= FW_PORT_CAP32_SPEED_1G;\n\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_10G))\n\t\tlinkattr |= FW_PORT_CAP32_SPEED_10G;\n\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_25G))\n\t\tlinkattr |= FW_PORT_CAP32_SPEED_25G;\n\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_40G))\n\t\tlinkattr |= FW_PORT_CAP32_SPEED_40G;\n\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_100G))\n\t\tlinkattr |= FW_PORT_CAP32_SPEED_100G;\n\n\treturn linkattr;\n}\n\n \nvoid t4_handle_get_port_info(struct port_info *pi, const __be64 *rpl)\n{\n\tconst struct fw_port_cmd *cmd = (const void *)rpl;\n\tfw_port_cap32_t pcaps, acaps, lpacaps, linkattr;\n\tstruct link_config *lc = &pi->link_cfg;\n\tstruct adapter *adapter = pi->adapter;\n\tunsigned int speed, fc, fec, adv_fc;\n\tenum fw_port_module_type mod_type;\n\tint action, link_ok, linkdnrc;\n\tenum fw_port_type port_type;\n\n\t \n\taction = FW_PORT_CMD_ACTION_G(be32_to_cpu(cmd->action_to_len16));\n\tswitch (action) {\n\tcase FW_PORT_ACTION_GET_PORT_INFO: {\n\t\tu32 lstatus = be32_to_cpu(cmd->u.info.lstatus_to_modtype);\n\n\t\tlink_ok = (lstatus & FW_PORT_CMD_LSTATUS_F) != 0;\n\t\tlinkdnrc = FW_PORT_CMD_LINKDNRC_G(lstatus);\n\t\tport_type = FW_PORT_CMD_PTYPE_G(lstatus);\n\t\tmod_type = FW_PORT_CMD_MODTYPE_G(lstatus);\n\t\tpcaps = fwcaps16_to_caps32(be16_to_cpu(cmd->u.info.pcap));\n\t\tacaps = fwcaps16_to_caps32(be16_to_cpu(cmd->u.info.acap));\n\t\tlpacaps = fwcaps16_to_caps32(be16_to_cpu(cmd->u.info.lpacap));\n\t\tlinkattr = lstatus_to_fwcap(lstatus);\n\t\tbreak;\n\t}\n\n\tcase FW_PORT_ACTION_GET_PORT_INFO32: {\n\t\tu32 lstatus32;\n\n\t\tlstatus32 = be32_to_cpu(cmd->u.info32.lstatus32_to_cbllen32);\n\t\tlink_ok = (lstatus32 & FW_PORT_CMD_LSTATUS32_F) != 0;\n\t\tlinkdnrc = FW_PORT_CMD_LINKDNRC32_G(lstatus32);\n\t\tport_type = FW_PORT_CMD_PORTTYPE32_G(lstatus32);\n\t\tmod_type = FW_PORT_CMD_MODTYPE32_G(lstatus32);\n\t\tpcaps = be32_to_cpu(cmd->u.info32.pcaps32);\n\t\tacaps = be32_to_cpu(cmd->u.info32.acaps32);\n\t\tlpacaps = be32_to_cpu(cmd->u.info32.lpacaps32);\n\t\tlinkattr = be32_to_cpu(cmd->u.info32.linkattr32);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tdev_err(adapter->pdev_dev, \"Handle Port Information: Bad Command/Action %#x\\n\",\n\t\t\tbe32_to_cpu(cmd->action_to_len16));\n\t\treturn;\n\t}\n\n\tfec = fwcap_to_cc_fec(acaps);\n\tadv_fc = fwcap_to_cc_pause(acaps);\n\tfc = fwcap_to_cc_pause(linkattr);\n\tspeed = fwcap_to_speed(linkattr);\n\n\t \n\tlc->new_module = false;\n\tlc->redo_l1cfg = false;\n\n\tif (mod_type != pi->mod_type) {\n\t\t \n\t\tlc->pcaps = pcaps;\n\n\t\t \n\t\tlc->def_acaps = acaps;\n\n\t\t \n\t\tpi->port_type = port_type;\n\n\t\t \n\t\tpi->mod_type = mod_type;\n\n\t\t \n\t\tlc->new_module = t4_is_inserted_mod_type(mod_type);\n\n\t\tt4_os_portmod_changed(adapter, pi->port_id);\n\t}\n\n\tif (link_ok != lc->link_ok || speed != lc->speed ||\n\t    fc != lc->fc || adv_fc != lc->advertised_fc ||\n\t    fec != lc->fec) {\n\t\t \n\t\tif (!link_ok && lc->link_ok) {\n\t\t\tlc->link_down_rc = linkdnrc;\n\t\t\tdev_warn_ratelimited(adapter->pdev_dev,\n\t\t\t\t\t     \"Port %d link down, reason: %s\\n\",\n\t\t\t\t\t     pi->tx_chan,\n\t\t\t\t\t     t4_link_down_rc_str(linkdnrc));\n\t\t}\n\t\tlc->link_ok = link_ok;\n\t\tlc->speed = speed;\n\t\tlc->advertised_fc = adv_fc;\n\t\tlc->fc = fc;\n\t\tlc->fec = fec;\n\n\t\tlc->lpacaps = lpacaps;\n\t\tlc->acaps = acaps & ADVERT_MASK;\n\n\t\t \n\t\tif (!(lc->acaps & FW_PORT_CAP32_ANEG)) {\n\t\t\tlc->autoneg = AUTONEG_DISABLE;\n\t\t} else if (lc->acaps & FW_PORT_CAP32_ANEG) {\n\t\t\tlc->autoneg = AUTONEG_ENABLE;\n\t\t} else {\n\t\t\t \n\t\t\tlc->acaps = 0;\n\t\t\tlc->speed_caps = fwcap_to_fwspeed(acaps);\n\t\t\tlc->autoneg = AUTONEG_DISABLE;\n\t\t}\n\n\t\tt4_os_link_changed(adapter, pi->port_id, link_ok);\n\t}\n\n\t \n\tif (lc->new_module && lc->redo_l1cfg) {\n\t\tstruct link_config old_lc;\n\t\tint ret;\n\n\t\t \n\t\told_lc = *lc;\n\t\tret = t4_link_l1cfg_ns(adapter, adapter->mbox, pi->lport, lc);\n\t\tif (ret) {\n\t\t\t*lc = old_lc;\n\t\t\tdev_warn(adapter->pdev_dev,\n\t\t\t\t \"Attempt to update new Transceiver Module settings failed\\n\");\n\t\t}\n\t}\n\tlc->new_module = false;\n\tlc->redo_l1cfg = false;\n}\n\n \nint t4_update_port_info(struct port_info *pi)\n{\n\tunsigned int fw_caps = pi->adapter->params.fw_caps_support;\n\tstruct fw_port_cmd port_cmd;\n\tint ret;\n\n\tmemset(&port_cmd, 0, sizeof(port_cmd));\n\tport_cmd.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PORT_CMD) |\n\t\t\t\t\t    FW_CMD_REQUEST_F | FW_CMD_READ_F |\n\t\t\t\t\t    FW_PORT_CMD_PORTID_V(pi->tx_chan));\n\tport_cmd.action_to_len16 = cpu_to_be32(\n\t\tFW_PORT_CMD_ACTION_V(fw_caps == FW_CAPS16\n\t\t\t\t     ? FW_PORT_ACTION_GET_PORT_INFO\n\t\t\t\t     : FW_PORT_ACTION_GET_PORT_INFO32) |\n\t\tFW_LEN16(port_cmd));\n\tret = t4_wr_mbox(pi->adapter, pi->adapter->mbox,\n\t\t\t &port_cmd, sizeof(port_cmd), &port_cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tt4_handle_get_port_info(pi, (__be64 *)&port_cmd);\n\treturn 0;\n}\n\n \nint t4_get_link_params(struct port_info *pi, unsigned int *link_okp,\n\t\t       unsigned int *speedp, unsigned int *mtup)\n{\n\tunsigned int fw_caps = pi->adapter->params.fw_caps_support;\n\tunsigned int action, link_ok, mtu;\n\tstruct fw_port_cmd port_cmd;\n\tfw_port_cap32_t linkattr;\n\tint ret;\n\n\tmemset(&port_cmd, 0, sizeof(port_cmd));\n\tport_cmd.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PORT_CMD) |\n\t\t\t\t\t    FW_CMD_REQUEST_F | FW_CMD_READ_F |\n\t\t\t\t\t    FW_PORT_CMD_PORTID_V(pi->tx_chan));\n\taction = (fw_caps == FW_CAPS16\n\t\t  ? FW_PORT_ACTION_GET_PORT_INFO\n\t\t  : FW_PORT_ACTION_GET_PORT_INFO32);\n\tport_cmd.action_to_len16 = cpu_to_be32(\n\t\tFW_PORT_CMD_ACTION_V(action) |\n\t\tFW_LEN16(port_cmd));\n\tret = t4_wr_mbox(pi->adapter, pi->adapter->mbox,\n\t\t\t &port_cmd, sizeof(port_cmd), &port_cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tif (action == FW_PORT_ACTION_GET_PORT_INFO) {\n\t\tu32 lstatus = be32_to_cpu(port_cmd.u.info.lstatus_to_modtype);\n\n\t\tlink_ok = !!(lstatus & FW_PORT_CMD_LSTATUS_F);\n\t\tlinkattr = lstatus_to_fwcap(lstatus);\n\t\tmtu = be16_to_cpu(port_cmd.u.info.mtu);\n\t} else {\n\t\tu32 lstatus32 =\n\t\t\t   be32_to_cpu(port_cmd.u.info32.lstatus32_to_cbllen32);\n\n\t\tlink_ok = !!(lstatus32 & FW_PORT_CMD_LSTATUS32_F);\n\t\tlinkattr = be32_to_cpu(port_cmd.u.info32.linkattr32);\n\t\tmtu = FW_PORT_CMD_MTU32_G(\n\t\t\tbe32_to_cpu(port_cmd.u.info32.auxlinfo32_mtu32));\n\t}\n\n\tif (link_okp)\n\t\t*link_okp = link_ok;\n\tif (speedp)\n\t\t*speedp = fwcap_to_speed(linkattr);\n\tif (mtup)\n\t\t*mtup = mtu;\n\n\treturn 0;\n}\n\n \nint t4_handle_fw_rpl(struct adapter *adap, const __be64 *rpl)\n{\n\tu8 opcode = *(const u8 *)rpl;\n\n\t \n\tconst struct fw_port_cmd *p = (const void *)rpl;\n\tunsigned int action =\n\t\tFW_PORT_CMD_ACTION_G(be32_to_cpu(p->action_to_len16));\n\n\tif (opcode == FW_PORT_CMD &&\n\t    (action == FW_PORT_ACTION_GET_PORT_INFO ||\n\t     action == FW_PORT_ACTION_GET_PORT_INFO32)) {\n\t\tint i;\n\t\tint chan = FW_PORT_CMD_PORTID_G(be32_to_cpu(p->op_to_portid));\n\t\tstruct port_info *pi = NULL;\n\n\t\tfor_each_port(adap, i) {\n\t\t\tpi = adap2pinfo(adap, i);\n\t\t\tif (pi->tx_chan == chan)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tt4_handle_get_port_info(pi, rpl);\n\t} else {\n\t\tdev_warn(adap->pdev_dev, \"Unknown firmware reply %d\\n\",\n\t\t\t opcode);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void get_pci_mode(struct adapter *adapter, struct pci_params *p)\n{\n\tu16 val;\n\n\tif (pci_is_pcie(adapter->pdev)) {\n\t\tpcie_capability_read_word(adapter->pdev, PCI_EXP_LNKSTA, &val);\n\t\tp->speed = val & PCI_EXP_LNKSTA_CLS;\n\t\tp->width = (val & PCI_EXP_LNKSTA_NLW) >> 4;\n\t}\n}\n\n \nstatic void init_link_config(struct link_config *lc, fw_port_cap32_t pcaps,\n\t\t\t     fw_port_cap32_t acaps)\n{\n\tlc->pcaps = pcaps;\n\tlc->def_acaps = acaps;\n\tlc->lpacaps = 0;\n\tlc->speed_caps = 0;\n\tlc->speed = 0;\n\tlc->requested_fc = lc->fc = PAUSE_RX | PAUSE_TX;\n\n\t \n\tlc->requested_fec = FEC_AUTO;\n\tlc->fec = fwcap_to_cc_fec(lc->def_acaps);\n\n\t \n\tif (lc->pcaps & FW_PORT_CAP32_ANEG) {\n\t\tlc->acaps = lc->pcaps & ADVERT_MASK;\n\t\tlc->autoneg = AUTONEG_ENABLE;\n\t\tlc->requested_fc |= PAUSE_AUTONEG;\n\t} else {\n\t\tlc->acaps = 0;\n\t\tlc->autoneg = AUTONEG_DISABLE;\n\t\tlc->speed_caps = fwcap_to_fwspeed(acaps);\n\t}\n}\n\n#define CIM_PF_NOACCESS 0xeeeeeeee\n\nint t4_wait_dev_ready(void __iomem *regs)\n{\n\tu32 whoami;\n\n\twhoami = readl(regs + PL_WHOAMI_A);\n\tif (whoami != 0xffffffff && whoami != CIM_PF_NOACCESS)\n\t\treturn 0;\n\n\tmsleep(500);\n\twhoami = readl(regs + PL_WHOAMI_A);\n\treturn (whoami != 0xffffffff && whoami != CIM_PF_NOACCESS ? 0 : -EIO);\n}\n\nstruct flash_desc {\n\tu32 vendor_and_model_id;\n\tu32 size_mb;\n};\n\nstatic int t4_get_flash_params(struct adapter *adap)\n{\n\t \n\tstatic struct flash_desc supported_flash[] = {\n\t\t{ 0x150201, 4 << 20 },        \n\t};\n\n\tunsigned int part, manufacturer;\n\tunsigned int density, size = 0;\n\tu32 flashid = 0;\n\tint ret;\n\n\t \n\n\tret = sf1_write(adap, 1, 1, 0, SF_RD_ID);\n\tif (!ret)\n\t\tret = sf1_read(adap, 3, 0, 1, &flashid);\n\tt4_write_reg(adap, SF_OP_A, 0);                     \n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (part = 0; part < ARRAY_SIZE(supported_flash); part++)\n\t\tif (supported_flash[part].vendor_and_model_id == flashid) {\n\t\t\tadap->params.sf_size = supported_flash[part].size_mb;\n\t\t\tadap->params.sf_nsec =\n\t\t\t\tadap->params.sf_size / SF_SEC_SIZE;\n\t\t\tgoto found;\n\t\t}\n\n\t \n\tmanufacturer = flashid & 0xff;\n\tswitch (manufacturer) {\n\tcase 0x20: {  \n\t\t \n\t\tdensity = (flashid >> 16) & 0xff;\n\t\tswitch (density) {\n\t\tcase 0x14:  \n\t\t\tsize = 1 << 20;\n\t\t\tbreak;\n\t\tcase 0x15:  \n\t\t\tsize = 1 << 21;\n\t\t\tbreak;\n\t\tcase 0x16:  \n\t\t\tsize = 1 << 22;\n\t\t\tbreak;\n\t\tcase 0x17:  \n\t\t\tsize = 1 << 23;\n\t\t\tbreak;\n\t\tcase 0x18:  \n\t\t\tsize = 1 << 24;\n\t\t\tbreak;\n\t\tcase 0x19:  \n\t\t\tsize = 1 << 25;\n\t\t\tbreak;\n\t\tcase 0x20:  \n\t\t\tsize = 1 << 26;\n\t\t\tbreak;\n\t\tcase 0x21:  \n\t\t\tsize = 1 << 27;\n\t\t\tbreak;\n\t\tcase 0x22:  \n\t\t\tsize = 1 << 28;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 0x9d: {  \n\t\t \n\t\tdensity = (flashid >> 16) & 0xff;\n\t\tswitch (density) {\n\t\tcase 0x16:  \n\t\t\tsize = 1 << 25;\n\t\t\tbreak;\n\t\tcase 0x17:  \n\t\t\tsize = 1 << 26;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 0xc2: {  \n\t\t \n\t\tdensity = (flashid >> 16) & 0xff;\n\t\tswitch (density) {\n\t\tcase 0x17:  \n\t\t\tsize = 1 << 23;\n\t\t\tbreak;\n\t\tcase 0x18:  \n\t\t\tsize = 1 << 24;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 0xef: {  \n\t\t \n\t\tdensity = (flashid >> 16) & 0xff;\n\t\tswitch (density) {\n\t\tcase 0x17:  \n\t\t\tsize = 1 << 23;\n\t\t\tbreak;\n\t\tcase 0x18:  \n\t\t\tsize = 1 << 24;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\t}\n\n\t \n\tif (size == 0) {\n\t\tdev_warn(adap->pdev_dev, \"Unknown Flash Part, ID = %#x, assuming 4MB\\n\",\n\t\t\t flashid);\n\t\tsize = 1 << 22;\n\t}\n\n\t \n\tadap->params.sf_size = size;\n\tadap->params.sf_nsec = size / SF_SEC_SIZE;\n\nfound:\n\tif (adap->params.sf_size < FLASH_MIN_SIZE)\n\t\tdev_warn(adap->pdev_dev, \"WARNING: Flash Part ID %#x, size %#x < %#x\\n\",\n\t\t\t flashid, adap->params.sf_size, FLASH_MIN_SIZE);\n\treturn 0;\n}\n\n \nint t4_prep_adapter(struct adapter *adapter)\n{\n\tint ret, ver;\n\tuint16_t device_id;\n\tu32 pl_rev;\n\n\tget_pci_mode(adapter, &adapter->params.pci);\n\tpl_rev = REV_G(t4_read_reg(adapter, PL_REV_A));\n\n\tret = t4_get_flash_params(adapter);\n\tif (ret < 0) {\n\t\tdev_err(adapter->pdev_dev, \"error %d identifying flash\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tpci_read_config_word(adapter->pdev, PCI_DEVICE_ID, &device_id);\n\tver = device_id >> 12;\n\tadapter->params.chip = 0;\n\tswitch (ver) {\n\tcase CHELSIO_T4:\n\t\tadapter->params.chip |= CHELSIO_CHIP_CODE(CHELSIO_T4, pl_rev);\n\t\tadapter->params.arch.sge_fl_db = DBPRIO_F;\n\t\tadapter->params.arch.mps_tcam_size =\n\t\t\t\t NUM_MPS_CLS_SRAM_L_INSTANCES;\n\t\tadapter->params.arch.mps_rplc_size = 128;\n\t\tadapter->params.arch.nchan = NCHAN;\n\t\tadapter->params.arch.pm_stats_cnt = PM_NSTATS;\n\t\tadapter->params.arch.vfcount = 128;\n\t\t \n\t\tadapter->params.arch.cng_ch_bits_log = 2;\n\t\tbreak;\n\tcase CHELSIO_T5:\n\t\tadapter->params.chip |= CHELSIO_CHIP_CODE(CHELSIO_T5, pl_rev);\n\t\tadapter->params.arch.sge_fl_db = DBPRIO_F | DBTYPE_F;\n\t\tadapter->params.arch.mps_tcam_size =\n\t\t\t\t NUM_MPS_T5_CLS_SRAM_L_INSTANCES;\n\t\tadapter->params.arch.mps_rplc_size = 128;\n\t\tadapter->params.arch.nchan = NCHAN;\n\t\tadapter->params.arch.pm_stats_cnt = PM_NSTATS;\n\t\tadapter->params.arch.vfcount = 128;\n\t\tadapter->params.arch.cng_ch_bits_log = 2;\n\t\tbreak;\n\tcase CHELSIO_T6:\n\t\tadapter->params.chip |= CHELSIO_CHIP_CODE(CHELSIO_T6, pl_rev);\n\t\tadapter->params.arch.sge_fl_db = 0;\n\t\tadapter->params.arch.mps_tcam_size =\n\t\t\t\t NUM_MPS_T5_CLS_SRAM_L_INSTANCES;\n\t\tadapter->params.arch.mps_rplc_size = 256;\n\t\tadapter->params.arch.nchan = 2;\n\t\tadapter->params.arch.pm_stats_cnt = T6_PM_NSTATS;\n\t\tadapter->params.arch.vfcount = 256;\n\t\t \n\t\tadapter->params.arch.cng_ch_bits_log = 3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(adapter->pdev_dev, \"Device %d is not supported\\n\",\n\t\t\tdevice_id);\n\t\treturn -EINVAL;\n\t}\n\n\tadapter->params.cim_la_size = CIMLA_SIZE;\n\tinit_cong_ctrl(adapter->params.a_wnd, adapter->params.b_wnd);\n\n\t \n\tadapter->params.nports = 1;\n\tadapter->params.portvec = 1;\n\tadapter->params.vpd.cclk = 50000;\n\n\t \n\tpcie_capability_clear_and_set_word(adapter->pdev, PCI_EXP_DEVCTL2,\n\t\t\t\t\t   PCI_EXP_DEVCTL2_COMP_TIMEOUT, 0xd);\n\treturn 0;\n}\n\n \nint t4_shutdown_adapter(struct adapter *adapter)\n{\n\tint port;\n\n\tt4_intr_disable(adapter);\n\tt4_write_reg(adapter, DBG_GPIO_EN_A, 0);\n\tfor_each_port(adapter, port) {\n\t\tu32 a_port_cfg = is_t4(adapter->params.chip) ?\n\t\t\t\t       PORT_REG(port, XGMAC_PORT_CFG_A) :\n\t\t\t\t       T5_PORT_REG(port, MAC_PORT_CFG_A);\n\n\t\tt4_write_reg(adapter, a_port_cfg,\n\t\t\t     t4_read_reg(adapter, a_port_cfg)\n\t\t\t     & ~SIGNAL_DET_V(1));\n\t}\n\tt4_set_reg_field(adapter, SGE_CONTROL_A, GLOBALENABLE_F, 0);\n\n\treturn 0;\n}\n\n \nint t4_bar2_sge_qregs(struct adapter *adapter,\n\t\t      unsigned int qid,\n\t\t      enum t4_bar2_qtype qtype,\n\t\t      int user,\n\t\t      u64 *pbar2_qoffset,\n\t\t      unsigned int *pbar2_qid)\n{\n\tunsigned int page_shift, page_size, qpp_shift, qpp_mask;\n\tu64 bar2_page_offset, bar2_qoffset;\n\tunsigned int bar2_qid, bar2_qid_offset, bar2_qinferred;\n\n\t \n\tif (!user && is_t4(adapter->params.chip))\n\t\treturn -EINVAL;\n\n\t \n\tpage_shift = adapter->params.sge.hps + 10;\n\tpage_size = 1 << page_shift;\n\n\t \n\tqpp_shift = (qtype == T4_BAR2_QTYPE_EGRESS\n\t\t     ? adapter->params.sge.eq_qpp\n\t\t     : adapter->params.sge.iq_qpp);\n\tqpp_mask = (1 << qpp_shift) - 1;\n\n\t \n\tbar2_page_offset = ((u64)(qid >> qpp_shift) << page_shift);\n\tbar2_qid = qid & qpp_mask;\n\tbar2_qid_offset = bar2_qid * SGE_UDB_SIZE;\n\n\t \n\tbar2_qoffset = bar2_page_offset;\n\tbar2_qinferred = (bar2_qid_offset < page_size);\n\tif (bar2_qinferred) {\n\t\tbar2_qoffset += bar2_qid_offset;\n\t\tbar2_qid = 0;\n\t}\n\n\t*pbar2_qoffset = bar2_qoffset;\n\t*pbar2_qid = bar2_qid;\n\treturn 0;\n}\n\n \nint t4_init_devlog_params(struct adapter *adap)\n{\n\tstruct devlog_params *dparams = &adap->params.devlog;\n\tu32 pf_dparams;\n\tunsigned int devlog_meminfo;\n\tstruct fw_devlog_cmd devlog_cmd;\n\tint ret;\n\n\t \n\tpf_dparams =\n\t\tt4_read_reg(adap, PCIE_FW_REG(PCIE_FW_PF_A, PCIE_FW_PF_DEVLOG));\n\tif (pf_dparams) {\n\t\tunsigned int nentries, nentries128;\n\n\t\tdparams->memtype = PCIE_FW_PF_DEVLOG_MEMTYPE_G(pf_dparams);\n\t\tdparams->start = PCIE_FW_PF_DEVLOG_ADDR16_G(pf_dparams) << 4;\n\n\t\tnentries128 = PCIE_FW_PF_DEVLOG_NENTRIES128_G(pf_dparams);\n\t\tnentries = (nentries128 + 1) * 128;\n\t\tdparams->size = nentries * sizeof(struct fw_devlog_e);\n\n\t\treturn 0;\n\t}\n\n\t \n\tmemset(&devlog_cmd, 0, sizeof(devlog_cmd));\n\tdevlog_cmd.op_to_write = cpu_to_be32(FW_CMD_OP_V(FW_DEVLOG_CMD) |\n\t\t\t\t\t     FW_CMD_REQUEST_F | FW_CMD_READ_F);\n\tdevlog_cmd.retval_len16 = cpu_to_be32(FW_LEN16(devlog_cmd));\n\tret = t4_wr_mbox(adap, adap->mbox, &devlog_cmd, sizeof(devlog_cmd),\n\t\t\t &devlog_cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tdevlog_meminfo =\n\t\tbe32_to_cpu(devlog_cmd.memtype_devlog_memaddr16_devlog);\n\tdparams->memtype = FW_DEVLOG_CMD_MEMTYPE_DEVLOG_G(devlog_meminfo);\n\tdparams->start = FW_DEVLOG_CMD_MEMADDR16_DEVLOG_G(devlog_meminfo) << 4;\n\tdparams->size = be32_to_cpu(devlog_cmd.memsize_devlog);\n\n\treturn 0;\n}\n\n \nint t4_init_sge_params(struct adapter *adapter)\n{\n\tstruct sge_params *sge_params = &adapter->params.sge;\n\tu32 hps, qpp;\n\tunsigned int s_hps, s_qpp;\n\n\t \n\thps = t4_read_reg(adapter, SGE_HOST_PAGE_SIZE_A);\n\ts_hps = (HOSTPAGESIZEPF0_S +\n\t\t (HOSTPAGESIZEPF1_S - HOSTPAGESIZEPF0_S) * adapter->pf);\n\tsge_params->hps = ((hps >> s_hps) & HOSTPAGESIZEPF0_M);\n\n\t \n\ts_qpp = (QUEUESPERPAGEPF0_S +\n\t\t(QUEUESPERPAGEPF1_S - QUEUESPERPAGEPF0_S) * adapter->pf);\n\tqpp = t4_read_reg(adapter, SGE_EGRESS_QUEUES_PER_PAGE_PF_A);\n\tsge_params->eq_qpp = ((qpp >> s_qpp) & QUEUESPERPAGEPF0_M);\n\tqpp = t4_read_reg(adapter, SGE_INGRESS_QUEUES_PER_PAGE_PF_A);\n\tsge_params->iq_qpp = ((qpp >> s_qpp) & QUEUESPERPAGEPF0_M);\n\n\treturn 0;\n}\n\n \nint t4_init_tp_params(struct adapter *adap, bool sleep_ok)\n{\n\tu32 param, val, v;\n\tint chan, ret;\n\n\n\tv = t4_read_reg(adap, TP_TIMER_RESOLUTION_A);\n\tadap->params.tp.tre = TIMERRESOLUTION_G(v);\n\tadap->params.tp.dack_re = DELAYEDACKRESOLUTION_G(v);\n\n\t \n\tfor (chan = 0; chan < NCHAN; chan++)\n\t\tadap->params.tp.tx_modq[chan] = chan;\n\n\t \n\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_FILTER) |\n\t\t FW_PARAMS_PARAM_Y_V(FW_PARAM_DEV_FILTER_MODE_MASK));\n\n\t \n\tret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1,\n\t\t\t      &param, &val);\n\tif (ret == 0) {\n\t\tdev_info(adap->pdev_dev,\n\t\t\t \"Current filter mode/mask 0x%x:0x%x\\n\",\n\t\t\t FW_PARAMS_PARAM_FILTER_MODE_G(val),\n\t\t\t FW_PARAMS_PARAM_FILTER_MASK_G(val));\n\t\tadap->params.tp.vlan_pri_map =\n\t\t\tFW_PARAMS_PARAM_FILTER_MODE_G(val);\n\t\tadap->params.tp.filter_mask =\n\t\t\tFW_PARAMS_PARAM_FILTER_MASK_G(val);\n\t} else {\n\t\tdev_info(adap->pdev_dev,\n\t\t\t \"Failed to read filter mode/mask via fw api, using indirect-reg-read\\n\");\n\n\t\t \n\t\tt4_tp_pio_read(adap, &adap->params.tp.vlan_pri_map, 1,\n\t\t\t       TP_VLAN_PRI_MAP_A, sleep_ok);\n\n\t\t \n\t\tadap->params.tp.filter_mask = adap->params.tp.vlan_pri_map;\n\t}\n\n\tt4_tp_pio_read(adap, &adap->params.tp.ingress_config, 1,\n\t\t       TP_INGRESS_CONFIG_A, sleep_ok);\n\n\t \n\tif (CHELSIO_CHIP_VERSION(adap->params.chip) > CHELSIO_T5) {\n\t\tv = t4_read_reg(adap, TP_OUT_CONFIG_A);\n\t\tadap->params.tp.rx_pkt_encap = (v & CRXPKTENC_F) ? 1 : 0;\n\t}\n\n\t \n\tadap->params.tp.fcoe_shift = t4_filter_field_shift(adap, FCOE_F);\n\tadap->params.tp.port_shift = t4_filter_field_shift(adap, PORT_F);\n\tadap->params.tp.vnic_shift = t4_filter_field_shift(adap, VNIC_ID_F);\n\tadap->params.tp.vlan_shift = t4_filter_field_shift(adap, VLAN_F);\n\tadap->params.tp.tos_shift = t4_filter_field_shift(adap, TOS_F);\n\tadap->params.tp.protocol_shift = t4_filter_field_shift(adap,\n\t\t\t\t\t\t\t       PROTOCOL_F);\n\tadap->params.tp.ethertype_shift = t4_filter_field_shift(adap,\n\t\t\t\t\t\t\t\tETHERTYPE_F);\n\tadap->params.tp.macmatch_shift = t4_filter_field_shift(adap,\n\t\t\t\t\t\t\t       MACMATCH_F);\n\tadap->params.tp.matchtype_shift = t4_filter_field_shift(adap,\n\t\t\t\t\t\t\t\tMPSHITTYPE_F);\n\tadap->params.tp.frag_shift = t4_filter_field_shift(adap,\n\t\t\t\t\t\t\t   FRAGMENTATION_F);\n\n\t \n\tif ((adap->params.tp.ingress_config & VNIC_F) == 0)\n\t\tadap->params.tp.vnic_shift = -1;\n\n\tv = t4_read_reg(adap, LE_3_DB_HASH_MASK_GEN_IPV4_T6_A);\n\tadap->params.tp.hash_filter_mask = v;\n\tv = t4_read_reg(adap, LE_4_DB_HASH_MASK_GEN_IPV4_T6_A);\n\tadap->params.tp.hash_filter_mask |= ((u64)v << 32);\n\treturn 0;\n}\n\n \nint t4_filter_field_shift(const struct adapter *adap, int filter_sel)\n{\n\tunsigned int filter_mode = adap->params.tp.vlan_pri_map;\n\tunsigned int sel;\n\tint field_shift;\n\n\tif ((filter_mode & filter_sel) == 0)\n\t\treturn -1;\n\n\tfor (sel = 1, field_shift = 0; sel < filter_sel; sel <<= 1) {\n\t\tswitch (filter_mode & sel) {\n\t\tcase FCOE_F:\n\t\t\tfield_shift += FT_FCOE_W;\n\t\t\tbreak;\n\t\tcase PORT_F:\n\t\t\tfield_shift += FT_PORT_W;\n\t\t\tbreak;\n\t\tcase VNIC_ID_F:\n\t\t\tfield_shift += FT_VNIC_ID_W;\n\t\t\tbreak;\n\t\tcase VLAN_F:\n\t\t\tfield_shift += FT_VLAN_W;\n\t\t\tbreak;\n\t\tcase TOS_F:\n\t\t\tfield_shift += FT_TOS_W;\n\t\t\tbreak;\n\t\tcase PROTOCOL_F:\n\t\t\tfield_shift += FT_PROTOCOL_W;\n\t\t\tbreak;\n\t\tcase ETHERTYPE_F:\n\t\t\tfield_shift += FT_ETHERTYPE_W;\n\t\t\tbreak;\n\t\tcase MACMATCH_F:\n\t\t\tfield_shift += FT_MACMATCH_W;\n\t\t\tbreak;\n\t\tcase MPSHITTYPE_F:\n\t\t\tfield_shift += FT_MPSHITTYPE_W;\n\t\t\tbreak;\n\t\tcase FRAGMENTATION_F:\n\t\t\tfield_shift += FT_FRAGMENTATION_W;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn field_shift;\n}\n\nint t4_init_rss_mode(struct adapter *adap, int mbox)\n{\n\tint i, ret;\n\tstruct fw_rss_vi_config_cmd rvc;\n\n\tmemset(&rvc, 0, sizeof(rvc));\n\n\tfor_each_port(adap, i) {\n\t\tstruct port_info *p = adap2pinfo(adap, i);\n\n\t\trvc.op_to_viid =\n\t\t\tcpu_to_be32(FW_CMD_OP_V(FW_RSS_VI_CONFIG_CMD) |\n\t\t\t\t    FW_CMD_REQUEST_F | FW_CMD_READ_F |\n\t\t\t\t    FW_RSS_VI_CONFIG_CMD_VIID_V(p->viid));\n\t\trvc.retval_len16 = cpu_to_be32(FW_LEN16(rvc));\n\t\tret = t4_wr_mbox(adap, mbox, &rvc, sizeof(rvc), &rvc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tp->rss_mode = be32_to_cpu(rvc.u.basicvirtual.defaultq_to_udpen);\n\t}\n\treturn 0;\n}\n\n \nint t4_init_portinfo(struct port_info *pi, int mbox,\n\t\t     int port, int pf, int vf, u8 mac[])\n{\n\tstruct adapter *adapter = pi->adapter;\n\tunsigned int fw_caps = adapter->params.fw_caps_support;\n\tstruct fw_port_cmd cmd;\n\tunsigned int rss_size;\n\tenum fw_port_type port_type;\n\tint mdio_addr;\n\tfw_port_cap32_t pcaps, acaps;\n\tu8 vivld = 0, vin = 0;\n\tint ret;\n\n\t \n\tif (fw_caps == FW_CAPS_UNKNOWN) {\n\t\tu32 param, val;\n\n\t\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_PFVF) |\n\t\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_PFVF_PORT_CAPS32));\n\t\tval = 1;\n\t\tret = t4_set_params(adapter, mbox, pf, vf, 1, &param, &val);\n\t\tfw_caps = (ret == 0 ? FW_CAPS32 : FW_CAPS16);\n\t\tadapter->params.fw_caps_support = fw_caps;\n\t}\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PORT_CMD) |\n\t\t\t\t       FW_CMD_REQUEST_F | FW_CMD_READ_F |\n\t\t\t\t       FW_PORT_CMD_PORTID_V(port));\n\tcmd.action_to_len16 = cpu_to_be32(\n\t\tFW_PORT_CMD_ACTION_V(fw_caps == FW_CAPS16\n\t\t\t\t     ? FW_PORT_ACTION_GET_PORT_INFO\n\t\t\t\t     : FW_PORT_ACTION_GET_PORT_INFO32) |\n\t\tFW_LEN16(cmd));\n\tret = t4_wr_mbox(pi->adapter, mbox, &cmd, sizeof(cmd), &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (fw_caps == FW_CAPS16) {\n\t\tu32 lstatus = be32_to_cpu(cmd.u.info.lstatus_to_modtype);\n\n\t\tport_type = FW_PORT_CMD_PTYPE_G(lstatus);\n\t\tmdio_addr = ((lstatus & FW_PORT_CMD_MDIOCAP_F)\n\t\t\t     ? FW_PORT_CMD_MDIOADDR_G(lstatus)\n\t\t\t     : -1);\n\t\tpcaps = fwcaps16_to_caps32(be16_to_cpu(cmd.u.info.pcap));\n\t\tacaps = fwcaps16_to_caps32(be16_to_cpu(cmd.u.info.acap));\n\t} else {\n\t\tu32 lstatus32 = be32_to_cpu(cmd.u.info32.lstatus32_to_cbllen32);\n\n\t\tport_type = FW_PORT_CMD_PORTTYPE32_G(lstatus32);\n\t\tmdio_addr = ((lstatus32 & FW_PORT_CMD_MDIOCAP32_F)\n\t\t\t     ? FW_PORT_CMD_MDIOADDR32_G(lstatus32)\n\t\t\t     : -1);\n\t\tpcaps = be32_to_cpu(cmd.u.info32.pcaps32);\n\t\tacaps = be32_to_cpu(cmd.u.info32.acaps32);\n\t}\n\n\tret = t4_alloc_vi(pi->adapter, mbox, port, pf, vf, 1, mac, &rss_size,\n\t\t\t  &vivld, &vin);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpi->viid = ret;\n\tpi->tx_chan = port;\n\tpi->lport = port;\n\tpi->rss_size = rss_size;\n\tpi->rx_cchan = t4_get_tp_e2c_map(pi->adapter, port);\n\n\t \n\tif (adapter->params.viid_smt_extn_support) {\n\t\tpi->vivld = vivld;\n\t\tpi->vin = vin;\n\t} else {\n\t\t \n\t\tpi->vivld = FW_VIID_VIVLD_G(pi->viid);\n\t\tpi->vin =  FW_VIID_VIN_G(pi->viid);\n\t}\n\n\tpi->port_type = port_type;\n\tpi->mdio_addr = mdio_addr;\n\tpi->mod_type = FW_PORT_MOD_TYPE_NA;\n\n\tinit_link_config(&pi->link_cfg, pcaps, acaps);\n\treturn 0;\n}\n\nint t4_port_init(struct adapter *adap, int mbox, int pf, int vf)\n{\n\tu8 addr[6];\n\tint ret, i, j = 0;\n\n\tfor_each_port(adap, i) {\n\t\tstruct port_info *pi = adap2pinfo(adap, i);\n\n\t\twhile ((adap->params.portvec & (1 << j)) == 0)\n\t\t\tj++;\n\n\t\tret = t4_init_portinfo(pi, mbox, j, pf, vf, addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\teth_hw_addr_set(adap->port[i], addr);\n\t\tj++;\n\t}\n\treturn 0;\n}\n\nint t4_init_port_mirror(struct port_info *pi, u8 mbox, u8 port, u8 pf, u8 vf,\n\t\t\tu16 *mirror_viid)\n{\n\tint ret;\n\n\tret = t4_alloc_vi(pi->adapter, mbox, port, pf, vf, 1, NULL, NULL,\n\t\t\t  NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (mirror_viid)\n\t\t*mirror_viid = ret;\n\n\treturn 0;\n}\n\n \nvoid t4_read_cimq_cfg(struct adapter *adap, u16 *base, u16 *size, u16 *thres)\n{\n\tunsigned int i, v;\n\tint cim_num_obq = is_t4(adap->params.chip) ?\n\t\t\t\tCIM_NUM_OBQ : CIM_NUM_OBQ_T5;\n\n\tfor (i = 0; i < CIM_NUM_IBQ; i++) {\n\t\tt4_write_reg(adap, CIM_QUEUE_CONFIG_REF_A, IBQSELECT_F |\n\t\t\t     QUENUMSELECT_V(i));\n\t\tv = t4_read_reg(adap, CIM_QUEUE_CONFIG_CTRL_A);\n\t\t \n\t\t*base++ = CIMQBASE_G(v) * 256;\n\t\t*size++ = CIMQSIZE_G(v) * 256;\n\t\t*thres++ = QUEFULLTHRSH_G(v) * 8;  \n\t}\n\tfor (i = 0; i < cim_num_obq; i++) {\n\t\tt4_write_reg(adap, CIM_QUEUE_CONFIG_REF_A, OBQSELECT_F |\n\t\t\t     QUENUMSELECT_V(i));\n\t\tv = t4_read_reg(adap, CIM_QUEUE_CONFIG_CTRL_A);\n\t\t \n\t\t*base++ = CIMQBASE_G(v) * 256;\n\t\t*size++ = CIMQSIZE_G(v) * 256;\n\t}\n}\n\n \nint t4_read_cim_ibq(struct adapter *adap, unsigned int qid, u32 *data, size_t n)\n{\n\tint i, err, attempts;\n\tunsigned int addr;\n\tconst unsigned int nwords = CIM_IBQ_SIZE * 4;\n\n\tif (qid > 5 || (n & 3))\n\t\treturn -EINVAL;\n\n\taddr = qid * nwords;\n\tif (n > nwords)\n\t\tn = nwords;\n\n\t \n\tattempts = 1000000;\n\n\tfor (i = 0; i < n; i++, addr++) {\n\t\tt4_write_reg(adap, CIM_IBQ_DBG_CFG_A, IBQDBGADDR_V(addr) |\n\t\t\t     IBQDBGEN_F);\n\t\terr = t4_wait_op_done(adap, CIM_IBQ_DBG_CFG_A, IBQDBGBUSY_F, 0,\n\t\t\t\t      attempts, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*data++ = t4_read_reg(adap, CIM_IBQ_DBG_DATA_A);\n\t}\n\tt4_write_reg(adap, CIM_IBQ_DBG_CFG_A, 0);\n\treturn i;\n}\n\n \nint t4_read_cim_obq(struct adapter *adap, unsigned int qid, u32 *data, size_t n)\n{\n\tint i, err;\n\tunsigned int addr, v, nwords;\n\tint cim_num_obq = is_t4(adap->params.chip) ?\n\t\t\t\tCIM_NUM_OBQ : CIM_NUM_OBQ_T5;\n\n\tif ((qid > (cim_num_obq - 1)) || (n & 3))\n\t\treturn -EINVAL;\n\n\tt4_write_reg(adap, CIM_QUEUE_CONFIG_REF_A, OBQSELECT_F |\n\t\t     QUENUMSELECT_V(qid));\n\tv = t4_read_reg(adap, CIM_QUEUE_CONFIG_CTRL_A);\n\n\taddr = CIMQBASE_G(v) * 64;     \n\tnwords = CIMQSIZE_G(v) * 64;   \n\tif (n > nwords)\n\t\tn = nwords;\n\n\tfor (i = 0; i < n; i++, addr++) {\n\t\tt4_write_reg(adap, CIM_OBQ_DBG_CFG_A, OBQDBGADDR_V(addr) |\n\t\t\t     OBQDBGEN_F);\n\t\terr = t4_wait_op_done(adap, CIM_OBQ_DBG_CFG_A, OBQDBGBUSY_F, 0,\n\t\t\t\t      2, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*data++ = t4_read_reg(adap, CIM_OBQ_DBG_DATA_A);\n\t}\n\tt4_write_reg(adap, CIM_OBQ_DBG_CFG_A, 0);\n\treturn i;\n}\n\n \nint t4_cim_read(struct adapter *adap, unsigned int addr, unsigned int n,\n\t\tunsigned int *valp)\n{\n\tint ret = 0;\n\n\tif (t4_read_reg(adap, CIM_HOST_ACC_CTRL_A) & HOSTBUSY_F)\n\t\treturn -EBUSY;\n\n\tfor ( ; !ret && n--; addr += 4) {\n\t\tt4_write_reg(adap, CIM_HOST_ACC_CTRL_A, addr);\n\t\tret = t4_wait_op_done(adap, CIM_HOST_ACC_CTRL_A, HOSTBUSY_F,\n\t\t\t\t      0, 5, 2);\n\t\tif (!ret)\n\t\t\t*valp++ = t4_read_reg(adap, CIM_HOST_ACC_DATA_A);\n\t}\n\treturn ret;\n}\n\n \nint t4_cim_write(struct adapter *adap, unsigned int addr, unsigned int n,\n\t\t const unsigned int *valp)\n{\n\tint ret = 0;\n\n\tif (t4_read_reg(adap, CIM_HOST_ACC_CTRL_A) & HOSTBUSY_F)\n\t\treturn -EBUSY;\n\n\tfor ( ; !ret && n--; addr += 4) {\n\t\tt4_write_reg(adap, CIM_HOST_ACC_DATA_A, *valp++);\n\t\tt4_write_reg(adap, CIM_HOST_ACC_CTRL_A, addr | HOSTWRITE_F);\n\t\tret = t4_wait_op_done(adap, CIM_HOST_ACC_CTRL_A, HOSTBUSY_F,\n\t\t\t\t      0, 5, 2);\n\t}\n\treturn ret;\n}\n\nstatic int t4_cim_write1(struct adapter *adap, unsigned int addr,\n\t\t\t unsigned int val)\n{\n\treturn t4_cim_write(adap, addr, 1, &val);\n}\n\n \nint t4_cim_read_la(struct adapter *adap, u32 *la_buf, unsigned int *wrptr)\n{\n\tint i, ret;\n\tunsigned int cfg, val, idx;\n\n\tret = t4_cim_read(adap, UP_UP_DBG_LA_CFG_A, 1, &cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cfg & UPDBGLAEN_F) {\t \n\t\tret = t4_cim_write1(adap, UP_UP_DBG_LA_CFG_A, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = t4_cim_read(adap, UP_UP_DBG_LA_CFG_A, 1, &val);\n\tif (ret)\n\t\tgoto restart;\n\n\tidx = UPDBGLAWRPTR_G(val);\n\tif (wrptr)\n\t\t*wrptr = idx;\n\n\tfor (i = 0; i < adap->params.cim_la_size; i++) {\n\t\tret = t4_cim_write1(adap, UP_UP_DBG_LA_CFG_A,\n\t\t\t\t    UPDBGLARDPTR_V(idx) | UPDBGLARDEN_F);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = t4_cim_read(adap, UP_UP_DBG_LA_CFG_A, 1, &val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (val & UPDBGLARDEN_F) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = t4_cim_read(adap, UP_UP_DBG_LA_DATA_A, 1, &la_buf[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tif (is_t6(adap->params.chip) && (idx & 0xf) >= 9)\n\t\t\tidx = (idx & 0xff0) + 0x10;\n\t\telse\n\t\t\tidx++;\n\t\t \n\t\tidx &= UPDBGLARDPTR_M;\n\t}\nrestart:\n\tif (cfg & UPDBGLAEN_F) {\n\t\tint r = t4_cim_write1(adap, UP_UP_DBG_LA_CFG_A,\n\t\t\t\t      cfg & ~UPDBGLARDEN_F);\n\t\tif (!ret)\n\t\t\tret = r;\n\t}\n\treturn ret;\n}\n\n \nvoid t4_tp_read_la(struct adapter *adap, u64 *la_buf, unsigned int *wrptr)\n{\n\tbool last_incomplete;\n\tunsigned int i, cfg, val, idx;\n\n\tcfg = t4_read_reg(adap, TP_DBG_LA_CONFIG_A) & 0xffff;\n\tif (cfg & DBGLAENABLE_F)\t\t\t \n\t\tt4_write_reg(adap, TP_DBG_LA_CONFIG_A,\n\t\t\t     adap->params.tp.la_mask | (cfg ^ DBGLAENABLE_F));\n\n\tval = t4_read_reg(adap, TP_DBG_LA_CONFIG_A);\n\tidx = DBGLAWPTR_G(val);\n\tlast_incomplete = DBGLAMODE_G(val) >= 2 && (val & DBGLAWHLF_F) == 0;\n\tif (last_incomplete)\n\t\tidx = (idx + 1) & DBGLARPTR_M;\n\tif (wrptr)\n\t\t*wrptr = idx;\n\n\tval &= 0xffff;\n\tval &= ~DBGLARPTR_V(DBGLARPTR_M);\n\tval |= adap->params.tp.la_mask;\n\n\tfor (i = 0; i < TPLA_SIZE; i++) {\n\t\tt4_write_reg(adap, TP_DBG_LA_CONFIG_A, DBGLARPTR_V(idx) | val);\n\t\tla_buf[i] = t4_read_reg64(adap, TP_DBG_LA_DATAL_A);\n\t\tidx = (idx + 1) & DBGLARPTR_M;\n\t}\n\n\t \n\tif (last_incomplete)\n\t\tla_buf[TPLA_SIZE - 1] = ~0ULL;\n\n\tif (cfg & DBGLAENABLE_F)                     \n\t\tt4_write_reg(adap, TP_DBG_LA_CONFIG_A,\n\t\t\t     cfg | adap->params.tp.la_mask);\n}\n\n \n#define SGE_IDMA_WARN_THRESH 1\n#define SGE_IDMA_WARN_REPEAT 300\n\n \nvoid t4_idma_monitor_init(struct adapter *adapter,\n\t\t\t  struct sge_idma_monitor_state *idma)\n{\n\t \n\tidma->idma_1s_thresh = core_ticks_per_usec(adapter) * 1000000;  \n\tidma->idma_stalled[0] = 0;\n\tidma->idma_stalled[1] = 0;\n}\n\n \nvoid t4_idma_monitor(struct adapter *adapter,\n\t\t     struct sge_idma_monitor_state *idma,\n\t\t     int hz, int ticks)\n{\n\tint i, idma_same_state_cnt[2];\n\n\t  \n\tt4_write_reg(adapter, SGE_DEBUG_INDEX_A, 13);\n\tidma_same_state_cnt[0] = t4_read_reg(adapter, SGE_DEBUG_DATA_HIGH_A);\n\tidma_same_state_cnt[1] = t4_read_reg(adapter, SGE_DEBUG_DATA_LOW_A);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tu32 debug0, debug11;\n\n\t\t \n\t\tif (idma_same_state_cnt[i] < idma->idma_1s_thresh) {\n\t\t\tif (idma->idma_stalled[i] >= SGE_IDMA_WARN_THRESH * hz)\n\t\t\t\tdev_warn(adapter->pdev_dev, \"SGE idma%d, queue %u, \"\n\t\t\t\t\t \"resumed after %d seconds\\n\",\n\t\t\t\t\t i, idma->idma_qid[i],\n\t\t\t\t\t idma->idma_stalled[i] / hz);\n\t\t\tidma->idma_stalled[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (idma->idma_stalled[i] == 0) {\n\t\t\tidma->idma_stalled[i] = hz;\n\t\t\tidma->idma_warn[i] = 0;\n\t\t} else {\n\t\t\tidma->idma_stalled[i] += ticks;\n\t\t\tidma->idma_warn[i] -= ticks;\n\t\t}\n\n\t\tif (idma->idma_stalled[i] < SGE_IDMA_WARN_THRESH * hz)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (idma->idma_warn[i] > 0)\n\t\t\tcontinue;\n\t\tidma->idma_warn[i] = SGE_IDMA_WARN_REPEAT * hz;\n\n\t\t \n\t\tt4_write_reg(adapter, SGE_DEBUG_INDEX_A, 0);\n\t\tdebug0 = t4_read_reg(adapter, SGE_DEBUG_DATA_LOW_A);\n\t\tidma->idma_state[i] = (debug0 >> (i * 9)) & 0x3f;\n\n\t\tt4_write_reg(adapter, SGE_DEBUG_INDEX_A, 11);\n\t\tdebug11 = t4_read_reg(adapter, SGE_DEBUG_DATA_LOW_A);\n\t\tidma->idma_qid[i] = (debug11 >> (i * 16)) & 0xffff;\n\n\t\tdev_warn(adapter->pdev_dev, \"SGE idma%u, queue %u, potentially stuck in \"\n\t\t\t \"state %u for %d seconds (debug0=%#x, debug11=%#x)\\n\",\n\t\t\t i, idma->idma_qid[i], idma->idma_state[i],\n\t\t\t idma->idma_stalled[i] / hz,\n\t\t\t debug0, debug11);\n\t\tt4_sge_decode_idma_state(adapter, idma->idma_state[i]);\n\t}\n}\n\n \nint t4_load_cfg(struct adapter *adap, const u8 *cfg_data, unsigned int size)\n{\n\tint ret, i, n, cfg_addr;\n\tunsigned int addr;\n\tunsigned int flash_cfg_start_sec;\n\tunsigned int sf_sec_size = adap->params.sf_size / adap->params.sf_nsec;\n\n\tcfg_addr = t4_flash_cfg_addr(adap);\n\tif (cfg_addr < 0)\n\t\treturn cfg_addr;\n\n\taddr = cfg_addr;\n\tflash_cfg_start_sec = addr / SF_SEC_SIZE;\n\n\tif (size > FLASH_CFG_MAX_SIZE) {\n\t\tdev_err(adap->pdev_dev, \"cfg file too large, max is %u bytes\\n\",\n\t\t\tFLASH_CFG_MAX_SIZE);\n\t\treturn -EFBIG;\n\t}\n\n\ti = DIV_ROUND_UP(FLASH_CFG_MAX_SIZE,\t \n\t\t\t sf_sec_size);\n\tret = t4_flash_erase_sectors(adap, flash_cfg_start_sec,\n\t\t\t\t     flash_cfg_start_sec + i - 1);\n\t \n\tif (ret || size == 0)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < size; i += SF_PAGE_SIZE) {\n\t\tif ((size - i) <  SF_PAGE_SIZE)\n\t\t\tn = size - i;\n\t\telse\n\t\t\tn = SF_PAGE_SIZE;\n\t\tret = t4_write_flash(adap, addr, n, cfg_data, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\taddr += SF_PAGE_SIZE;\n\t\tcfg_data += SF_PAGE_SIZE;\n\t}\n\nout:\n\tif (ret)\n\t\tdev_err(adap->pdev_dev, \"config file %s failed %d\\n\",\n\t\t\t(size == 0 ? \"clear\" : \"download\"), ret);\n\treturn ret;\n}\n\n \nint t4_set_vf_mac_acl(struct adapter *adapter, unsigned int vf,\n\t\t      unsigned int naddr, u8 *addr)\n{\n\tstruct fw_acl_mac_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_ACL_MAC_CMD) |\n\t\t\t\t    FW_CMD_REQUEST_F |\n\t\t\t\t    FW_CMD_WRITE_F |\n\t\t\t\t    FW_ACL_MAC_CMD_PFN_V(adapter->pf) |\n\t\t\t\t    FW_ACL_MAC_CMD_VFN_V(vf));\n\n\t \n\tcmd.en_to_len16 = cpu_to_be32((unsigned int)FW_LEN16(cmd));\n\tcmd.nmac = naddr;\n\n\tswitch (adapter->pf) {\n\tcase 3:\n\t\tmemcpy(cmd.macaddr3, addr, sizeof(cmd.macaddr3));\n\t\tbreak;\n\tcase 2:\n\t\tmemcpy(cmd.macaddr2, addr, sizeof(cmd.macaddr2));\n\t\tbreak;\n\tcase 1:\n\t\tmemcpy(cmd.macaddr1, addr, sizeof(cmd.macaddr1));\n\t\tbreak;\n\tcase 0:\n\t\tmemcpy(cmd.macaddr0, addr, sizeof(cmd.macaddr0));\n\t\tbreak;\n\t}\n\n\treturn t4_wr_mbox(adapter, adapter->mbox, &cmd, sizeof(cmd), &cmd);\n}\n\n \nvoid t4_read_pace_tbl(struct adapter *adap, unsigned int pace_vals[NTX_SCHED])\n{\n\tunsigned int i, v;\n\n\tfor (i = 0; i < NTX_SCHED; i++) {\n\t\tt4_write_reg(adap, TP_PACE_TABLE_A, 0xffff0000 + i);\n\t\tv = t4_read_reg(adap, TP_PACE_TABLE_A);\n\t\tpace_vals[i] = dack_ticks_to_usec(adap, v);\n\t}\n}\n\n \nvoid t4_get_tx_sched(struct adapter *adap, unsigned int sched,\n\t\t     unsigned int *kbps, unsigned int *ipg, bool sleep_ok)\n{\n\tunsigned int v, addr, bpt, cpt;\n\n\tif (kbps) {\n\t\taddr = TP_TX_MOD_Q1_Q0_RATE_LIMIT_A - sched / 2;\n\t\tt4_tp_tm_pio_read(adap, &v, 1, addr, sleep_ok);\n\t\tif (sched & 1)\n\t\t\tv >>= 16;\n\t\tbpt = (v >> 8) & 0xff;\n\t\tcpt = v & 0xff;\n\t\tif (!cpt) {\n\t\t\t*kbps = 0;\t \n\t\t} else {\n\t\t\tv = (adap->params.vpd.cclk * 1000) / cpt;  \n\t\t\t*kbps = (v * bpt) / 125;\n\t\t}\n\t}\n\tif (ipg) {\n\t\taddr = TP_TX_MOD_Q1_Q0_TIMER_SEPARATOR_A - sched / 2;\n\t\tt4_tp_tm_pio_read(adap, &v, 1, addr, sleep_ok);\n\t\tif (sched & 1)\n\t\t\tv >>= 16;\n\t\tv &= 0xffff;\n\t\t*ipg = (10000 * v) / core_ticks_per_usec(adap);\n\t}\n}\n\n \nint t4_sge_ctxt_rd(struct adapter *adap, unsigned int mbox, unsigned int cid,\n\t\t   enum ctxt_type ctype, u32 *data)\n{\n\tstruct fw_ldst_cmd c;\n\tint ret;\n\n\tif (ctype == CTXT_FLM)\n\t\tret = FW_LDST_ADDRSPC_SGE_FLMC;\n\telse\n\t\tret = FW_LDST_ADDRSPC_SGE_CONMC;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_addrspace = cpu_to_be32(FW_CMD_OP_V(FW_LDST_CMD) |\n\t\t\t\t\tFW_CMD_REQUEST_F | FW_CMD_READ_F |\n\t\t\t\t\tFW_LDST_CMD_ADDRSPACE_V(ret));\n\tc.cycles_to_len16 = cpu_to_be32(FW_LEN16(c));\n\tc.u.idctxt.physid = cpu_to_be32(cid);\n\n\tret = t4_wr_mbox(adap, mbox, &c, sizeof(c), &c);\n\tif (ret == 0) {\n\t\tdata[0] = be32_to_cpu(c.u.idctxt.ctxt_data0);\n\t\tdata[1] = be32_to_cpu(c.u.idctxt.ctxt_data1);\n\t\tdata[2] = be32_to_cpu(c.u.idctxt.ctxt_data2);\n\t\tdata[3] = be32_to_cpu(c.u.idctxt.ctxt_data3);\n\t\tdata[4] = be32_to_cpu(c.u.idctxt.ctxt_data4);\n\t\tdata[5] = be32_to_cpu(c.u.idctxt.ctxt_data5);\n\t}\n\treturn ret;\n}\n\n \nint t4_sge_ctxt_rd_bd(struct adapter *adap, unsigned int cid,\n\t\t      enum ctxt_type ctype, u32 *data)\n{\n\tint i, ret;\n\n\tt4_write_reg(adap, SGE_CTXT_CMD_A, CTXTQID_V(cid) | CTXTTYPE_V(ctype));\n\tret = t4_wait_op_done(adap, SGE_CTXT_CMD_A, BUSY_F, 0, 3, 1);\n\tif (!ret)\n\t\tfor (i = SGE_CTXT_DATA0_A; i <= SGE_CTXT_DATA5_A; i += 4)\n\t\t\t*data++ = t4_read_reg(adap, i);\n\treturn ret;\n}\n\nint t4_sched_params(struct adapter *adapter, u8 type, u8 level, u8 mode,\n\t\t    u8 rateunit, u8 ratemode, u8 channel, u8 class,\n\t\t    u32 minrate, u32 maxrate, u16 weight, u16 pktsize,\n\t\t    u16 burstsize)\n{\n\tstruct fw_sched_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_write = cpu_to_be32(FW_CMD_OP_V(FW_SCHED_CMD) |\n\t\t\t\t      FW_CMD_REQUEST_F |\n\t\t\t\t      FW_CMD_WRITE_F);\n\tcmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\n\n\tcmd.u.params.sc = FW_SCHED_SC_PARAMS;\n\tcmd.u.params.type = type;\n\tcmd.u.params.level = level;\n\tcmd.u.params.mode = mode;\n\tcmd.u.params.ch = channel;\n\tcmd.u.params.cl = class;\n\tcmd.u.params.unit = rateunit;\n\tcmd.u.params.rate = ratemode;\n\tcmd.u.params.min = cpu_to_be32(minrate);\n\tcmd.u.params.max = cpu_to_be32(maxrate);\n\tcmd.u.params.weight = cpu_to_be16(weight);\n\tcmd.u.params.pktsize = cpu_to_be16(pktsize);\n\tcmd.u.params.burstsize = cpu_to_be16(burstsize);\n\n\treturn t4_wr_mbox_meat(adapter, adapter->mbox, &cmd, sizeof(cmd),\n\t\t\t       NULL, 1);\n}\n\n \nint t4_i2c_rd(struct adapter *adap, unsigned int mbox, int port,\n\t      unsigned int devid, unsigned int offset,\n\t      unsigned int len, u8 *buf)\n{\n\tstruct fw_ldst_cmd ldst_cmd, ldst_rpl;\n\tunsigned int i2c_max = sizeof(ldst_cmd.u.i2c.data);\n\tint ret = 0;\n\n\tif (len > I2C_PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tif (offset < I2C_PAGE_SIZE && offset + len > I2C_PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tmemset(&ldst_cmd, 0, sizeof(ldst_cmd));\n\tldst_cmd.op_to_addrspace =\n\t\tcpu_to_be32(FW_CMD_OP_V(FW_LDST_CMD) |\n\t\t\t    FW_CMD_REQUEST_F |\n\t\t\t    FW_CMD_READ_F |\n\t\t\t    FW_LDST_CMD_ADDRSPACE_V(FW_LDST_ADDRSPC_I2C));\n\tldst_cmd.cycles_to_len16 = cpu_to_be32(FW_LEN16(ldst_cmd));\n\tldst_cmd.u.i2c.pid = (port < 0 ? 0xff : port);\n\tldst_cmd.u.i2c.did = devid;\n\n\twhile (len > 0) {\n\t\tunsigned int i2c_len = (len < i2c_max) ? len : i2c_max;\n\n\t\tldst_cmd.u.i2c.boffset = offset;\n\t\tldst_cmd.u.i2c.blen = i2c_len;\n\n\t\tret = t4_wr_mbox(adap, mbox, &ldst_cmd, sizeof(ldst_cmd),\n\t\t\t\t &ldst_rpl);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tmemcpy(buf, ldst_rpl.u.i2c.data, i2c_len);\n\t\toffset += i2c_len;\n\t\tbuf += i2c_len;\n\t\tlen -= i2c_len;\n\t}\n\n\treturn ret;\n}\n\n \nint t4_set_vlan_acl(struct adapter *adap, unsigned int mbox, unsigned int vf,\n\t\t    u16 vlan)\n{\n\tstruct fw_acl_vlan_cmd vlan_cmd;\n\tunsigned int enable;\n\n\tenable = (vlan ? FW_ACL_VLAN_CMD_EN_F : 0);\n\tmemset(&vlan_cmd, 0, sizeof(vlan_cmd));\n\tvlan_cmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_ACL_VLAN_CMD) |\n\t\t\t\t\t FW_CMD_REQUEST_F |\n\t\t\t\t\t FW_CMD_WRITE_F |\n\t\t\t\t\t FW_CMD_EXEC_F |\n\t\t\t\t\t FW_ACL_VLAN_CMD_PFN_V(adap->pf) |\n\t\t\t\t\t FW_ACL_VLAN_CMD_VFN_V(vf));\n\tvlan_cmd.en_to_len16 = cpu_to_be32(enable | FW_LEN16(vlan_cmd));\n\t \n\tvlan_cmd.dropnovlan_fm = (enable\n\t\t\t\t  ? (FW_ACL_VLAN_CMD_DROPNOVLAN_F |\n\t\t\t\t     FW_ACL_VLAN_CMD_FM_F) : 0);\n\tif (enable != 0) {\n\t\tvlan_cmd.nvlan = 1;\n\t\tvlan_cmd.vlanid[0] = cpu_to_be16(vlan);\n\t}\n\n\treturn t4_wr_mbox(adap, adap->mbox, &vlan_cmd, sizeof(vlan_cmd), NULL);\n}\n\n \nstatic void modify_device_id(int device_id, u8 *boot_data)\n{\n\tstruct cxgb4_pcir_data *pcir_header;\n\tstruct legacy_pci_rom_hdr *header;\n\tu8 *cur_header = boot_data;\n\tu16 pcir_offset;\n\n\t  \n\tdo {\n\t\theader = (struct legacy_pci_rom_hdr *)cur_header;\n\t\tpcir_offset = le16_to_cpu(header->pcir_offset);\n\t\tpcir_header = (struct cxgb4_pcir_data *)(cur_header +\n\t\t\t      pcir_offset);\n\n\t\t \n\t\tif (pcir_header->code_type == CXGB4_HDR_CODE1) {\n\t\t\tu8 csum = 0;\n\t\t\tint i;\n\n\t\t\t \n\t\t\tpcir_header->device_id = cpu_to_le16(device_id);\n\n\t\t\t \n\t\t\theader->cksum = 0x0;\n\n\t\t\t \n\t\t\tfor (i = 0; i < (header->size512 * 512); i++)\n\t\t\t\tcsum += cur_header[i];\n\n\t\t\t \n\t\t\tcur_header[7] = -csum;\n\n\t\t} else if (pcir_header->code_type == CXGB4_HDR_CODE2) {\n\t\t\t \n\t\t\tpcir_header->device_id = cpu_to_le16(device_id);\n\t\t}\n\n\t\t \n\t\tcur_header += header->size512 * 512;\n\t} while (!(pcir_header->indicator & CXGB4_HDR_INDI));\n}\n\n \nint t4_load_boot(struct adapter *adap, u8 *boot_data,\n\t\t unsigned int boot_addr, unsigned int size)\n{\n\tunsigned int sf_sec_size = adap->params.sf_size / adap->params.sf_nsec;\n\tunsigned int boot_sector = (boot_addr * 1024);\n\tstruct cxgb4_pci_exp_rom_header *header;\n\tstruct cxgb4_pcir_data *pcir_header;\n\tint pcir_offset;\n\tunsigned int i;\n\tu16 device_id;\n\tint ret, addr;\n\n\t \n\tif ((boot_sector + size) >> 16 > FLASH_FW_START_SEC) {\n\t\tdev_err(adap->pdev_dev, \"boot image encroaching on firmware region\\n\");\n\t\treturn -EFBIG;\n\t}\n\n\t \n\theader = (struct cxgb4_pci_exp_rom_header *)boot_data;\n\tpcir_offset = le16_to_cpu(header->pcir_offset);\n\t \n\tpcir_header = (struct cxgb4_pcir_data *)&boot_data[pcir_offset];\n\n\t \n\tif (size < BOOT_MIN_SIZE || size > BOOT_MAX_SIZE) {\n\t\tdev_err(adap->pdev_dev, \"boot image too small/large\\n\");\n\t\treturn -EFBIG;\n\t}\n\n\tif (le16_to_cpu(header->signature) != BOOT_SIGNATURE) {\n\t\tdev_err(adap->pdev_dev, \"Boot image missing signature\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (le32_to_cpu(pcir_header->signature) != PCIR_SIGNATURE) {\n\t\tdev_err(adap->pdev_dev, \"PCI header missing signature\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (le16_to_cpu(pcir_header->vendor_id) != PCI_VENDOR_ID_CHELSIO) {\n\t\tdev_err(adap->pdev_dev, \"Vendor ID missing signature\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ti = DIV_ROUND_UP(size ? size : FLASH_FW_START,  sf_sec_size);\n\tret = t4_flash_erase_sectors(adap, boot_sector >> 16,\n\t\t\t\t     (boot_sector >> 16) + i - 1);\n\n\t \n\tif (ret || size == 0)\n\t\tgoto out;\n\t \n\tpci_read_config_word(adap->pdev, PCI_DEVICE_ID, &device_id);\n        \n\tdevice_id = device_id & 0xf0ff;\n\n\t  \n\tif (le16_to_cpu(pcir_header->device_id) != device_id) {\n\t\t \n\t\tmodify_device_id(device_id, boot_data);\n\t}\n\n\t \n\taddr = boot_sector;\n\tfor (size -= SF_PAGE_SIZE; size; size -= SF_PAGE_SIZE) {\n\t\taddr += SF_PAGE_SIZE;\n\t\tboot_data += SF_PAGE_SIZE;\n\t\tret = t4_write_flash(adap, addr, SF_PAGE_SIZE, boot_data,\n\t\t\t\t     false);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = t4_write_flash(adap, boot_sector, SF_PAGE_SIZE,\n\t\t\t     (const u8 *)header, false);\n\nout:\n\tif (ret)\n\t\tdev_err(adap->pdev_dev, \"boot image load failed, error %d\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\n \nstatic int t4_flash_bootcfg_addr(struct adapter *adapter)\n{\n\t \n\tif (adapter->params.sf_size <\n\t    FLASH_BOOTCFG_START + FLASH_BOOTCFG_MAX_SIZE)\n\t\treturn -ENOSPC;\n\n\treturn FLASH_BOOTCFG_START;\n}\n\nint t4_load_bootcfg(struct adapter *adap, const u8 *cfg_data, unsigned int size)\n{\n\tunsigned int sf_sec_size = adap->params.sf_size / adap->params.sf_nsec;\n\tstruct cxgb4_bootcfg_data *header;\n\tunsigned int flash_cfg_start_sec;\n\tunsigned int addr, npad;\n\tint ret, i, n, cfg_addr;\n\n\tcfg_addr = t4_flash_bootcfg_addr(adap);\n\tif (cfg_addr < 0)\n\t\treturn cfg_addr;\n\n\taddr = cfg_addr;\n\tflash_cfg_start_sec = addr / SF_SEC_SIZE;\n\n\tif (size > FLASH_BOOTCFG_MAX_SIZE) {\n\t\tdev_err(adap->pdev_dev, \"bootcfg file too large, max is %u bytes\\n\",\n\t\t\tFLASH_BOOTCFG_MAX_SIZE);\n\t\treturn -EFBIG;\n\t}\n\n\theader = (struct cxgb4_bootcfg_data *)cfg_data;\n\tif (le16_to_cpu(header->signature) != BOOT_CFG_SIG) {\n\t\tdev_err(adap->pdev_dev, \"Wrong bootcfg signature\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ti = DIV_ROUND_UP(FLASH_BOOTCFG_MAX_SIZE,\n\t\t\t sf_sec_size);\n\tret = t4_flash_erase_sectors(adap, flash_cfg_start_sec,\n\t\t\t\t     flash_cfg_start_sec + i - 1);\n\n\t \n\tif (ret || size == 0)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < size; i += SF_PAGE_SIZE) {\n\t\tn = min_t(u32, size - i, SF_PAGE_SIZE);\n\n\t\tret = t4_write_flash(adap, addr, n, cfg_data, false);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\taddr += SF_PAGE_SIZE;\n\t\tcfg_data += SF_PAGE_SIZE;\n\t}\n\n\tnpad = ((size + 4 - 1) & ~3) - size;\n\tfor (i = 0; i < npad; i++) {\n\t\tu8 data = 0;\n\n\t\tret = t4_write_flash(adap, cfg_addr + size + i, 1, &data,\n\t\t\t\t     false);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (ret)\n\t\tdev_err(adap->pdev_dev, \"boot config data %s failed %d\\n\",\n\t\t\t(size == 0 ? \"clear\" : \"download\"), ret);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}