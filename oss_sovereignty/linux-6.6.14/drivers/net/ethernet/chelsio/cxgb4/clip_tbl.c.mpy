{
  "module_name": "clip_tbl.c",
  "hash_id": "fe0e04806a3b7426f6c8d67da44b3ac9c954cf740519acf11ba081320d3d98d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/clip_tbl.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/jhash.h>\n#include <linux/if_vlan.h>\n#include <net/addrconf.h>\n#include \"cxgb4.h\"\n#include \"clip_tbl.h\"\n\nstatic inline unsigned int ipv4_clip_hash(struct clip_tbl *c, const u32 *key)\n{\n\tunsigned int clipt_size_half = c->clipt_size / 2;\n\n\treturn jhash_1word(*key, 0) % clipt_size_half;\n}\n\nstatic inline unsigned int ipv6_clip_hash(struct clip_tbl *d, const u32 *key)\n{\n\tunsigned int clipt_size_half = d->clipt_size / 2;\n\tu32 xor = key[0] ^ key[1] ^ key[2] ^ key[3];\n\n\treturn clipt_size_half +\n\t\t(jhash_1word(xor, 0) % clipt_size_half);\n}\n\nstatic unsigned int clip_addr_hash(struct clip_tbl *ctbl, const u32 *addr,\n\t\t\t\t   u8 v6)\n{\n\treturn v6 ? ipv6_clip_hash(ctbl, addr) :\n\t\t\tipv4_clip_hash(ctbl, addr);\n}\n\nstatic int clip6_get_mbox(const struct net_device *dev,\n\t\t\t  const struct in6_addr *lip)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct fw_clip_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_write = htonl(FW_CMD_OP_V(FW_CLIP_CMD) |\n\t\t\t      FW_CMD_REQUEST_F | FW_CMD_WRITE_F);\n\tc.alloc_to_len16 = htonl(FW_CLIP_CMD_ALLOC_F | FW_LEN16(c));\n\t*(__be64 *)&c.ip_hi = *(__be64 *)(lip->s6_addr);\n\t*(__be64 *)&c.ip_lo = *(__be64 *)(lip->s6_addr + 8);\n\treturn t4_wr_mbox_meat(adap, adap->mbox, &c, sizeof(c), &c, false);\n}\n\nstatic int clip6_release_mbox(const struct net_device *dev,\n\t\t\t      const struct in6_addr *lip)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct fw_clip_cmd c;\n\n\tmemset(&c, 0, sizeof(c));\n\tc.op_to_write = htonl(FW_CMD_OP_V(FW_CLIP_CMD) |\n\t\t\t      FW_CMD_REQUEST_F | FW_CMD_READ_F);\n\tc.alloc_to_len16 = htonl(FW_CLIP_CMD_FREE_F | FW_LEN16(c));\n\t*(__be64 *)&c.ip_hi = *(__be64 *)(lip->s6_addr);\n\t*(__be64 *)&c.ip_lo = *(__be64 *)(lip->s6_addr + 8);\n\treturn t4_wr_mbox_meat(adap, adap->mbox, &c, sizeof(c), &c, false);\n}\n\nint cxgb4_clip_get(const struct net_device *dev, const u32 *lip, u8 v6)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct clip_tbl *ctbl = adap->clipt;\n\tstruct clip_entry *ce, *cte;\n\tu32 *addr = (u32 *)lip;\n\tint hash;\n\tint ret = -1;\n\n\tif (!ctbl)\n\t\treturn 0;\n\n\thash = clip_addr_hash(ctbl, addr, v6);\n\n\tread_lock_bh(&ctbl->lock);\n\tlist_for_each_entry(cte, &ctbl->hash_list[hash], list) {\n\t\tif (cte->addr6.sin6_family == AF_INET6 && v6)\n\t\t\tret = memcmp(lip, cte->addr6.sin6_addr.s6_addr,\n\t\t\t\t     sizeof(struct in6_addr));\n\t\telse if (cte->addr.sin_family == AF_INET && !v6)\n\t\t\tret = memcmp(lip, (char *)(&cte->addr.sin_addr),\n\t\t\t\t     sizeof(struct in_addr));\n\t\tif (!ret) {\n\t\t\tce = cte;\n\t\t\tread_unlock_bh(&ctbl->lock);\n\t\t\trefcount_inc(&ce->refcnt);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tread_unlock_bh(&ctbl->lock);\n\n\twrite_lock_bh(&ctbl->lock);\n\tif (!list_empty(&ctbl->ce_free_head)) {\n\t\tce = list_first_entry(&ctbl->ce_free_head,\n\t\t\t\t      struct clip_entry, list);\n\t\tlist_del_init(&ce->list);\n\t\tspin_lock_init(&ce->lock);\n\t\trefcount_set(&ce->refcnt, 0);\n\t\tatomic_dec(&ctbl->nfree);\n\t\tlist_add_tail(&ce->list, &ctbl->hash_list[hash]);\n\t\tif (v6) {\n\t\t\tce->addr6.sin6_family = AF_INET6;\n\t\t\tmemcpy(ce->addr6.sin6_addr.s6_addr,\n\t\t\t       lip, sizeof(struct in6_addr));\n\t\t\tret = clip6_get_mbox(dev, (const struct in6_addr *)lip);\n\t\t\tif (ret) {\n\t\t\t\twrite_unlock_bh(&ctbl->lock);\n\t\t\t\tdev_err(adap->pdev_dev,\n\t\t\t\t\t\"CLIP FW cmd failed with error %d, \"\n\t\t\t\t\t\"Connections using %pI6c wont be \"\n\t\t\t\t\t\"offloaded\",\n\t\t\t\t\tret, ce->addr6.sin6_addr.s6_addr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tce->addr.sin_family = AF_INET;\n\t\t\tmemcpy((char *)(&ce->addr.sin_addr), lip,\n\t\t\t       sizeof(struct in_addr));\n\t\t}\n\t} else {\n\t\twrite_unlock_bh(&ctbl->lock);\n\t\tdev_info(adap->pdev_dev, \"CLIP table overflow, \"\n\t\t\t \"Connections using %pI6c wont be offloaded\",\n\t\t\t (void *)lip);\n\t\treturn -ENOMEM;\n\t}\n\twrite_unlock_bh(&ctbl->lock);\n\trefcount_set(&ce->refcnt, 1);\n\treturn 0;\n}\nEXPORT_SYMBOL(cxgb4_clip_get);\n\nvoid cxgb4_clip_release(const struct net_device *dev, const u32 *lip, u8 v6)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct clip_tbl *ctbl = adap->clipt;\n\tstruct clip_entry *ce, *cte;\n\tu32 *addr = (u32 *)lip;\n\tint hash;\n\tint ret = -1;\n\n\tif (!ctbl)\n\t\treturn;\n\n\thash = clip_addr_hash(ctbl, addr, v6);\n\n\tread_lock_bh(&ctbl->lock);\n\tlist_for_each_entry(cte, &ctbl->hash_list[hash], list) {\n\t\tif (cte->addr6.sin6_family == AF_INET6 && v6)\n\t\t\tret = memcmp(lip, cte->addr6.sin6_addr.s6_addr,\n\t\t\t\t     sizeof(struct in6_addr));\n\t\telse if (cte->addr.sin_family == AF_INET && !v6)\n\t\t\tret = memcmp(lip, (char *)(&cte->addr.sin_addr),\n\t\t\t\t     sizeof(struct in_addr));\n\t\tif (!ret) {\n\t\t\tce = cte;\n\t\t\tread_unlock_bh(&ctbl->lock);\n\t\t\tgoto found;\n\t\t}\n\t}\n\tread_unlock_bh(&ctbl->lock);\n\n\treturn;\nfound:\n\twrite_lock_bh(&ctbl->lock);\n\tspin_lock_bh(&ce->lock);\n\tif (refcount_dec_and_test(&ce->refcnt)) {\n\t\tlist_del_init(&ce->list);\n\t\tlist_add_tail(&ce->list, &ctbl->ce_free_head);\n\t\tatomic_inc(&ctbl->nfree);\n\t\tif (v6)\n\t\t\tclip6_release_mbox(dev, (const struct in6_addr *)lip);\n\t}\n\tspin_unlock_bh(&ce->lock);\n\twrite_unlock_bh(&ctbl->lock);\n}\nEXPORT_SYMBOL(cxgb4_clip_release);\n\n \nstatic int cxgb4_update_dev_clip(struct net_device *root_dev,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct inet6_dev *idev = NULL;\n\tstruct inet6_ifaddr *ifa;\n\tint ret = 0;\n\n\tidev = __in6_dev_get(root_dev);\n\tif (!idev)\n\t\treturn ret;\n\n\tread_lock_bh(&idev->lock);\n\tlist_for_each_entry(ifa, &idev->addr_list, if_list) {\n\t\tret = cxgb4_clip_get(dev, (const u32 *)ifa->addr.s6_addr, 1);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tread_unlock_bh(&idev->lock);\n\n\treturn ret;\n}\n\nint cxgb4_update_root_dev_clip(struct net_device *dev)\n{\n\tstruct net_device *root_dev = NULL;\n\tint i, ret = 0;\n\n\t \n\tret = cxgb4_update_dev_clip(dev, dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\troot_dev = netdev_master_upper_dev_get_rcu(dev);\n\tif (root_dev) {\n\t\tret = cxgb4_update_dev_clip(root_dev, dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < VLAN_N_VID; i++) {\n\t\troot_dev = __vlan_find_dev_deep_rcu(dev, htons(ETH_P_8021Q), i);\n\t\tif (!root_dev)\n\t\t\tcontinue;\n\n\t\tret = cxgb4_update_dev_clip(root_dev, dev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(cxgb4_update_root_dev_clip);\n\nint clip_tbl_show(struct seq_file *seq, void *v)\n{\n\tstruct adapter *adapter = seq->private;\n\tstruct clip_tbl *ctbl = adapter->clipt;\n\tstruct clip_entry *ce;\n\tchar ip[60];\n\tint i;\n\n\tread_lock_bh(&ctbl->lock);\n\n\tseq_puts(seq, \"IP Address                  Users\\n\");\n\tfor (i = 0 ; i < ctbl->clipt_size;  ++i) {\n\t\tlist_for_each_entry(ce, &ctbl->hash_list[i], list) {\n\t\t\tip[0] = '\\0';\n\t\t\tsprintf(ip, \"%pISc\", &ce->addr);\n\t\t\tseq_printf(seq, \"%-25s   %u\\n\", ip,\n\t\t\t\t   refcount_read(&ce->refcnt));\n\t\t}\n\t}\n\tseq_printf(seq, \"Free clip entries : %d\\n\", atomic_read(&ctbl->nfree));\n\n\tread_unlock_bh(&ctbl->lock);\n\n\treturn 0;\n}\n\nstruct clip_tbl *t4_init_clip_tbl(unsigned int clipt_start,\n\t\t\t\t  unsigned int clipt_end)\n{\n\tstruct clip_entry *cl_list;\n\tstruct clip_tbl *ctbl;\n\tunsigned int clipt_size;\n\tint i;\n\n\tif (clipt_start >= clipt_end)\n\t\treturn NULL;\n\tclipt_size = clipt_end - clipt_start + 1;\n\tif (clipt_size < CLIPT_MIN_HASH_BUCKETS)\n\t\treturn NULL;\n\n\tctbl = kvzalloc(struct_size(ctbl, hash_list, clipt_size), GFP_KERNEL);\n\tif (!ctbl)\n\t\treturn NULL;\n\n\tctbl->clipt_start = clipt_start;\n\tctbl->clipt_size = clipt_size;\n\tINIT_LIST_HEAD(&ctbl->ce_free_head);\n\n\tatomic_set(&ctbl->nfree, clipt_size);\n\trwlock_init(&ctbl->lock);\n\n\tfor (i = 0; i < ctbl->clipt_size; ++i)\n\t\tINIT_LIST_HEAD(&ctbl->hash_list[i]);\n\n\tcl_list = kvcalloc(clipt_size, sizeof(struct clip_entry), GFP_KERNEL);\n\tif (!cl_list) {\n\t\tkvfree(ctbl);\n\t\treturn NULL;\n\t}\n\tctbl->cl_list = (void *)cl_list;\n\n\tfor (i = 0; i < clipt_size; i++) {\n\t\tINIT_LIST_HEAD(&cl_list[i].list);\n\t\tlist_add_tail(&cl_list[i].list, &ctbl->ce_free_head);\n\t}\n\n\treturn ctbl;\n}\n\nvoid t4_cleanup_clip_tbl(struct adapter *adap)\n{\n\tstruct clip_tbl *ctbl = adap->clipt;\n\n\tif (ctbl) {\n\t\tkvfree(ctbl->cl_list);\n\t\tkvfree(ctbl);\n\t}\n}\nEXPORT_SYMBOL(t4_cleanup_clip_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}