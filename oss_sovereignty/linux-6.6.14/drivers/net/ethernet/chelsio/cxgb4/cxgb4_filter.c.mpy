{
  "module_name": "cxgb4_filter.c",
  "hash_id": "1e5e5f528e83805d4bd4e086059dac501369bd92b7fa3bdfd6a2216274e8eb23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c",
  "human_readable_source": " \n#include <net/ipv6.h>\n\n#include \"cxgb4.h\"\n#include \"t4_regs.h\"\n#include \"t4_tcb.h\"\n#include \"t4_values.h\"\n#include \"clip_tbl.h\"\n#include \"l2t.h\"\n#include \"smt.h\"\n#include \"t4fw_api.h\"\n#include \"cxgb4_filter.h\"\n\nstatic inline bool is_field_set(u32 val, u32 mask)\n{\n\treturn val || mask;\n}\n\nstatic inline bool unsupported(u32 conf, u32 conf_mask, u32 val, u32 mask)\n{\n\treturn !(conf & conf_mask) && is_field_set(val, mask);\n}\n\nstatic int set_tcb_field(struct adapter *adap, struct filter_entry *f,\n\t\t\t unsigned int ftid,  u16 word, u64 mask, u64 val,\n\t\t\t int no_reply)\n{\n\tstruct cpl_set_tcb_field *req;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(sizeof(struct cpl_set_tcb_field), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treq = (struct cpl_set_tcb_field *)__skb_put_zero(skb, sizeof(*req));\n\tINIT_TP_WR_CPL(req, CPL_SET_TCB_FIELD, ftid);\n\treq->reply_ctrl = htons(REPLY_CHAN_V(0) |\n\t\t\t\tQUEUENO_V(adap->sge.fw_evtq.abs_id) |\n\t\t\t\tNO_REPLY_V(no_reply));\n\treq->word_cookie = htons(TCB_WORD_V(word) | TCB_COOKIE_V(ftid));\n\treq->mask = cpu_to_be64(mask);\n\treq->val = cpu_to_be64(val);\n\tset_wr_txq(skb, CPL_PRIORITY_CONTROL, f->fs.val.iport & 0x3);\n\tt4_ofld_send(adap, skb);\n\treturn 0;\n}\n\n \nstatic int set_tcb_tflag(struct adapter *adap, struct filter_entry *f,\n\t\t\t unsigned int ftid, unsigned int bit_pos,\n\t\t\t unsigned int val, int no_reply)\n{\n\treturn set_tcb_field(adap, f, ftid,  TCB_T_FLAGS_W, 1ULL << bit_pos,\n\t\t\t     (unsigned long long)val << bit_pos, no_reply);\n}\n\nstatic void mk_abort_req_ulp(struct cpl_abort_req *abort_req, unsigned int tid)\n{\n\tstruct ulp_txpkt *txpkt = (struct ulp_txpkt *)abort_req;\n\tstruct ulptx_idata *sc = (struct ulptx_idata *)(txpkt + 1);\n\n\ttxpkt->cmd_dest = htonl(ULPTX_CMD_V(ULP_TX_PKT) | ULP_TXPKT_DEST_V(0));\n\ttxpkt->len = htonl(DIV_ROUND_UP(sizeof(*abort_req), 16));\n\tsc->cmd_more = htonl(ULPTX_CMD_V(ULP_TX_SC_IMM));\n\tsc->len = htonl(sizeof(*abort_req) - sizeof(struct work_request_hdr));\n\tOPCODE_TID(abort_req) = htonl(MK_OPCODE_TID(CPL_ABORT_REQ, tid));\n\tabort_req->rsvd0 = htonl(0);\n\tabort_req->rsvd1 = 0;\n\tabort_req->cmd = CPL_ABORT_NO_RST;\n}\n\nstatic void mk_abort_rpl_ulp(struct cpl_abort_rpl *abort_rpl, unsigned int tid)\n{\n\tstruct ulp_txpkt *txpkt = (struct ulp_txpkt *)abort_rpl;\n\tstruct ulptx_idata *sc = (struct ulptx_idata *)(txpkt + 1);\n\n\ttxpkt->cmd_dest = htonl(ULPTX_CMD_V(ULP_TX_PKT) | ULP_TXPKT_DEST_V(0));\n\ttxpkt->len = htonl(DIV_ROUND_UP(sizeof(*abort_rpl), 16));\n\tsc->cmd_more = htonl(ULPTX_CMD_V(ULP_TX_SC_IMM));\n\tsc->len = htonl(sizeof(*abort_rpl) - sizeof(struct work_request_hdr));\n\tOPCODE_TID(abort_rpl) = htonl(MK_OPCODE_TID(CPL_ABORT_RPL, tid));\n\tabort_rpl->rsvd0 = htonl(0);\n\tabort_rpl->rsvd1 = 0;\n\tabort_rpl->cmd = CPL_ABORT_NO_RST;\n}\n\nstatic void mk_set_tcb_ulp(struct filter_entry *f,\n\t\t\t   struct cpl_set_tcb_field *req,\n\t\t\t   unsigned int word, u64 mask, u64 val,\n\t\t\t   u8 cookie, int no_reply)\n{\n\tstruct ulp_txpkt *txpkt = (struct ulp_txpkt *)req;\n\tstruct ulptx_idata *sc = (struct ulptx_idata *)(txpkt + 1);\n\n\ttxpkt->cmd_dest = htonl(ULPTX_CMD_V(ULP_TX_PKT) | ULP_TXPKT_DEST_V(0));\n\ttxpkt->len = htonl(DIV_ROUND_UP(sizeof(*req), 16));\n\tsc->cmd_more = htonl(ULPTX_CMD_V(ULP_TX_SC_IMM));\n\tsc->len = htonl(sizeof(*req) - sizeof(struct work_request_hdr));\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_SET_TCB_FIELD, f->tid));\n\treq->reply_ctrl = htons(NO_REPLY_V(no_reply) | REPLY_CHAN_V(0) |\n\t\t\t\tQUEUENO_V(0));\n\treq->word_cookie = htons(TCB_WORD_V(word) | TCB_COOKIE_V(cookie));\n\treq->mask = cpu_to_be64(mask);\n\treq->val = cpu_to_be64(val);\n\tsc = (struct ulptx_idata *)(req + 1);\n\tsc->cmd_more = htonl(ULPTX_CMD_V(ULP_TX_SC_NOOP));\n\tsc->len = htonl(0);\n}\n\nstatic int configure_filter_smac(struct adapter *adap, struct filter_entry *f)\n{\n\tint err;\n\n\t \n\terr = set_tcb_field(adap, f, f->tid, TCB_SMAC_SEL_W,\n\t\t\t    TCB_SMAC_SEL_V(TCB_SMAC_SEL_M),\n\t\t\t    TCB_SMAC_SEL_V(f->smt->idx), 1);\n\tif (err)\n\t\tgoto smac_err;\n\n\terr = set_tcb_tflag(adap, f, f->tid, TF_CCTRL_CWR_S, 1, 1);\n\tif (!err)\n\t\treturn 0;\n\nsmac_err:\n\tdev_err(adap->pdev_dev, \"filter %u smac config failed with error %u\\n\",\n\t\tf->tid, err);\n\treturn err;\n}\n\nstatic void set_nat_params(struct adapter *adap, struct filter_entry *f,\n\t\t\t   unsigned int tid, bool dip, bool sip, bool dp,\n\t\t\t   bool sp)\n{\n\tu8 *nat_lp = (u8 *)&f->fs.nat_lport;\n\tu8 *nat_fp = (u8 *)&f->fs.nat_fport;\n\n\tif (dip) {\n\t\tif (f->fs.type) {\n\t\t\tset_tcb_field(adap, f, tid, TCB_SND_UNA_RAW_W,\n\t\t\t\t      WORD_MASK, f->fs.nat_lip[15] |\n\t\t\t\t      f->fs.nat_lip[14] << 8 |\n\t\t\t\t      f->fs.nat_lip[13] << 16 |\n\t\t\t\t      (u64)f->fs.nat_lip[12] << 24, 1);\n\n\t\t\tset_tcb_field(adap, f, tid, TCB_SND_UNA_RAW_W + 1,\n\t\t\t\t      WORD_MASK, f->fs.nat_lip[11] |\n\t\t\t\t      f->fs.nat_lip[10] << 8 |\n\t\t\t\t      f->fs.nat_lip[9] << 16 |\n\t\t\t\t      (u64)f->fs.nat_lip[8] << 24, 1);\n\n\t\t\tset_tcb_field(adap, f, tid, TCB_SND_UNA_RAW_W + 2,\n\t\t\t\t      WORD_MASK, f->fs.nat_lip[7] |\n\t\t\t\t      f->fs.nat_lip[6] << 8 |\n\t\t\t\t      f->fs.nat_lip[5] << 16 |\n\t\t\t\t      (u64)f->fs.nat_lip[4] << 24, 1);\n\n\t\t\tset_tcb_field(adap, f, tid, TCB_SND_UNA_RAW_W + 3,\n\t\t\t\t      WORD_MASK, f->fs.nat_lip[3] |\n\t\t\t\t      f->fs.nat_lip[2] << 8 |\n\t\t\t\t      f->fs.nat_lip[1] << 16 |\n\t\t\t\t      (u64)f->fs.nat_lip[0] << 24, 1);\n\t\t} else {\n\t\t\tset_tcb_field(adap, f, tid, TCB_RX_FRAG3_LEN_RAW_W,\n\t\t\t\t      WORD_MASK, f->fs.nat_lip[3] |\n\t\t\t\t      f->fs.nat_lip[2] << 8 |\n\t\t\t\t      f->fs.nat_lip[1] << 16 |\n\t\t\t\t      (u64)f->fs.nat_lip[0] << 24, 1);\n\t\t}\n\t}\n\n\tif (sip) {\n\t\tif (f->fs.type) {\n\t\t\tset_tcb_field(adap, f, tid, TCB_RX_FRAG2_PTR_RAW_W,\n\t\t\t\t      WORD_MASK, f->fs.nat_fip[15] |\n\t\t\t\t      f->fs.nat_fip[14] << 8 |\n\t\t\t\t      f->fs.nat_fip[13] << 16 |\n\t\t\t\t      (u64)f->fs.nat_fip[12] << 24, 1);\n\n\t\t\tset_tcb_field(adap, f, tid, TCB_RX_FRAG2_PTR_RAW_W + 1,\n\t\t\t\t      WORD_MASK, f->fs.nat_fip[11] |\n\t\t\t\t      f->fs.nat_fip[10] << 8 |\n\t\t\t\t      f->fs.nat_fip[9] << 16 |\n\t\t\t\t      (u64)f->fs.nat_fip[8] << 24, 1);\n\n\t\t\tset_tcb_field(adap, f, tid, TCB_RX_FRAG2_PTR_RAW_W + 2,\n\t\t\t\t      WORD_MASK, f->fs.nat_fip[7] |\n\t\t\t\t      f->fs.nat_fip[6] << 8 |\n\t\t\t\t      f->fs.nat_fip[5] << 16 |\n\t\t\t\t      (u64)f->fs.nat_fip[4] << 24, 1);\n\n\t\t\tset_tcb_field(adap, f, tid, TCB_RX_FRAG2_PTR_RAW_W + 3,\n\t\t\t\t      WORD_MASK, f->fs.nat_fip[3] |\n\t\t\t\t      f->fs.nat_fip[2] << 8 |\n\t\t\t\t      f->fs.nat_fip[1] << 16 |\n\t\t\t\t      (u64)f->fs.nat_fip[0] << 24, 1);\n\n\t\t} else {\n\t\t\tset_tcb_field(adap, f, tid,\n\t\t\t\t      TCB_RX_FRAG3_START_IDX_OFFSET_RAW_W,\n\t\t\t\t      WORD_MASK, f->fs.nat_fip[3] |\n\t\t\t\t      f->fs.nat_fip[2] << 8 |\n\t\t\t\t      f->fs.nat_fip[1] << 16 |\n\t\t\t\t      (u64)f->fs.nat_fip[0] << 24, 1);\n\t\t}\n\t}\n\n\tset_tcb_field(adap, f, tid, TCB_PDU_HDR_LEN_W, WORD_MASK,\n\t\t      (dp ? (nat_lp[1] | nat_lp[0] << 8) : 0) |\n\t\t      (sp ? (nat_fp[1] << 16 | (u64)nat_fp[0] << 24) : 0),\n\t\t      1);\n}\n\n \nstatic int validate_filter(struct net_device *dev,\n\t\t\t   struct ch_filter_specification *fs)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\tu32 fconf, iconf;\n\n\t \n\ticonf = adapter->params.tp.ingress_config;\n\tfconf = fs->hash ? adapter->params.tp.filter_mask :\n\t\t\t   adapter->params.tp.vlan_pri_map;\n\n\tif (unsupported(fconf, FCOE_F, fs->val.fcoe, fs->mask.fcoe) ||\n\t    unsupported(fconf, PORT_F, fs->val.iport, fs->mask.iport) ||\n\t    unsupported(fconf, TOS_F, fs->val.tos, fs->mask.tos) ||\n\t    unsupported(fconf, ETHERTYPE_F, fs->val.ethtype,\n\t\t\tfs->mask.ethtype) ||\n\t    unsupported(fconf, MACMATCH_F, fs->val.macidx, fs->mask.macidx) ||\n\t    unsupported(fconf, MPSHITTYPE_F, fs->val.matchtype,\n\t\t\tfs->mask.matchtype) ||\n\t    unsupported(fconf, FRAGMENTATION_F, fs->val.frag, fs->mask.frag) ||\n\t    unsupported(fconf, PROTOCOL_F, fs->val.proto, fs->mask.proto) ||\n\t    unsupported(fconf, VNIC_ID_F, fs->val.pfvf_vld,\n\t\t\tfs->mask.pfvf_vld) ||\n\t    unsupported(fconf, VNIC_ID_F, fs->val.ovlan_vld,\n\t\t\tfs->mask.ovlan_vld) ||\n\t    unsupported(fconf, VNIC_ID_F, fs->val.encap_vld,\n\t\t\tfs->mask.encap_vld) ||\n\t    unsupported(fconf, VLAN_F, fs->val.ivlan_vld, fs->mask.ivlan_vld))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((is_field_set(fs->val.pfvf_vld, fs->mask.pfvf_vld) &&\n\t     is_field_set(fs->val.ovlan_vld, fs->mask.ovlan_vld)) ||\n\t    (is_field_set(fs->val.pfvf_vld, fs->mask.pfvf_vld) &&\n\t     is_field_set(fs->val.encap_vld, fs->mask.encap_vld)) ||\n\t    (is_field_set(fs->val.ovlan_vld, fs->mask.ovlan_vld) &&\n\t     is_field_set(fs->val.encap_vld, fs->mask.encap_vld)))\n\t\treturn -EOPNOTSUPP;\n\tif (unsupported(iconf, VNIC_F, fs->val.pfvf_vld, fs->mask.pfvf_vld) ||\n\t    (is_field_set(fs->val.ovlan_vld, fs->mask.ovlan_vld) &&\n\t     (iconf & VNIC_F)))\n\t\treturn -EOPNOTSUPP;\n\tif (fs->val.pf > 0x7 || fs->val.vf > 0x7f)\n\t\treturn -ERANGE;\n\tfs->mask.pf &= 0x7;\n\tfs->mask.vf &= 0x7f;\n\n\t \n\tif (fs->action == FILTER_SWITCH &&\n\t    fs->eport >= adapter->params.nports)\n\t\treturn -ERANGE;\n\n\t \n\tif (fs->val.iport >= adapter->params.nports)\n\t\treturn -ERANGE;\n\n\t \n\tif (is_t4(adapter->params.chip) &&\n\t    fs->action == FILTER_SWITCH &&\n\t    (fs->newvlan == VLAN_REMOVE ||\n\t     fs->newvlan == VLAN_REWRITE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (fs->val.encap_vld &&\n\t    CHELSIO_CHIP_VERSION(adapter->params.chip) < CHELSIO_T6)\n\t\treturn -EOPNOTSUPP;\n\treturn 0;\n}\n\nstatic int get_filter_steerq(struct net_device *dev,\n\t\t\t     struct ch_filter_specification *fs)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\tint iq;\n\n\t \n\tif (!fs->dirsteer) {\n\t\tif (fs->iq)\n\t\t\treturn -EINVAL;\n\t\tiq = 0;\n\t} else {\n\t\tstruct port_info *pi = netdev_priv(dev);\n\n\t\t \n\t\tif (fs->iq < pi->nqsets)\n\t\t\tiq = adapter->sge.ethrxq[pi->first_qset +\n\t\t\t\t\t\t fs->iq].rspq.abs_id;\n\t\telse\n\t\t\tiq = fs->iq;\n\t}\n\n\treturn iq;\n}\n\nstatic int get_filter_count(struct adapter *adapter, unsigned int fidx,\n\t\t\t    u64 *pkts, u64 *bytes, bool hash)\n{\n\tunsigned int tcb_base, tcbaddr;\n\tunsigned int word_offset;\n\tstruct filter_entry *f;\n\t__be64 be64_byte_count;\n\tint ret;\n\n\ttcb_base = t4_read_reg(adapter, TP_CMM_TCB_BASE_A);\n\tif (is_hashfilter(adapter) && hash) {\n\t\tif (tid_out_of_range(&adapter->tids, fidx))\n\t\t\treturn -E2BIG;\n\t\tf = adapter->tids.tid_tab[fidx - adapter->tids.tid_base];\n\t\tif (!f)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif ((fidx != (adapter->tids.nftids + adapter->tids.nsftids +\n\t\t\t      adapter->tids.nhpftids - 1)) &&\n\t\t    fidx >= (adapter->tids.nftids + adapter->tids.nhpftids))\n\t\t\treturn -E2BIG;\n\n\t\tif (fidx < adapter->tids.nhpftids)\n\t\t\tf = &adapter->tids.hpftid_tab[fidx];\n\t\telse\n\t\t\tf = &adapter->tids.ftid_tab[fidx -\n\t\t\t\t\t\t    adapter->tids.nhpftids];\n\t\tif (!f->valid)\n\t\t\treturn -EINVAL;\n\t}\n\ttcbaddr = tcb_base + f->tid * TCB_SIZE;\n\n\tspin_lock(&adapter->win0_lock);\n\tif (is_t4(adapter->params.chip)) {\n\t\t__be64 be64_count;\n\n\t\t \n\t\t*bytes = 0;\n\n\t\t \n\t\tword_offset = 4;\n\t\tret = t4_memory_rw(adapter, MEMWIN_NIC, MEM_EDC0,\n\t\t\t\t   tcbaddr + (word_offset * sizeof(__be32)),\n\t\t\t\t   sizeof(be64_count),\n\t\t\t\t   (__be32 *)&be64_count,\n\t\t\t\t   T4_MEMORY_READ);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t*pkts = be64_to_cpu(be64_count);\n\t} else {\n\t\t__be32 be32_count;\n\n\t\t \n\t\tword_offset = 4;\n\t\tret = t4_memory_rw(adapter, MEMWIN_NIC, MEM_EDC0,\n\t\t\t\t   tcbaddr + (word_offset * sizeof(__be32)),\n\t\t\t\t   sizeof(be64_byte_count),\n\t\t\t\t   &be64_byte_count,\n\t\t\t\t   T4_MEMORY_READ);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t*bytes = be64_to_cpu(be64_byte_count);\n\n\t\t \n\t\tword_offset = 6;\n\t\tret = t4_memory_rw(adapter, MEMWIN_NIC, MEM_EDC0,\n\t\t\t\t   tcbaddr + (word_offset * sizeof(__be32)),\n\t\t\t\t   sizeof(be32_count),\n\t\t\t\t   &be32_count,\n\t\t\t\t   T4_MEMORY_READ);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t*pkts = (u64)be32_to_cpu(be32_count);\n\t}\n\nout:\n\tspin_unlock(&adapter->win0_lock);\n\treturn ret;\n}\n\nint cxgb4_get_filter_counters(struct net_device *dev, unsigned int fidx,\n\t\t\t      u64 *hitcnt, u64 *bytecnt, bool hash)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\n\treturn get_filter_count(adapter, fidx, hitcnt, bytecnt, hash);\n}\n\nstatic bool cxgb4_filter_prio_in_range(struct tid_info *t, u32 idx, u8 nslots,\n\t\t\t\t       u32 prio)\n{\n\tstruct filter_entry *prev_tab, *next_tab, *prev_fe, *next_fe;\n\tu32 prev_ftid, next_ftid;\n\n\t \n\n\t \n\tif (idx < t->nhpftids) {\n\t\t \n\t\tif (test_bit(idx, t->hpftid_bmap))\n\t\t\treturn false;\n\n\t\tnext_tab = t->hpftid_tab;\n\t\tnext_ftid = find_next_bit(t->hpftid_bmap, t->nhpftids, idx);\n\t\tif (next_ftid >= t->nhpftids) {\n\t\t\t \n\t\t\tnext_ftid = find_first_bit(t->ftid_bmap, t->nftids);\n\t\t\tif (next_ftid >= t->nftids)\n\t\t\t\tnext_ftid = idx;\n\t\t\telse\n\t\t\t\tnext_tab = t->ftid_tab;\n\t\t}\n\n\t\t \n\t\tprev_ftid = find_last_bit(t->hpftid_bmap, idx);\n\t\tif (prev_ftid >= idx)\n\t\t\tprev_ftid = idx;\n\n\t\tprev_tab = t->hpftid_tab;\n\t} else {\n\t\tidx -= t->nhpftids;\n\n\t\t \n\t\tif (test_bit(idx, t->ftid_bmap))\n\t\t\treturn false;\n\n\t\tprev_tab = t->ftid_tab;\n\t\tprev_ftid = find_last_bit(t->ftid_bmap, idx);\n\t\tif (prev_ftid >= idx) {\n\t\t\t \n\t\t\tprev_ftid = find_last_bit(t->hpftid_bmap, t->nhpftids);\n\t\t\tif (prev_ftid >= t->nhpftids)\n\t\t\t\tprev_ftid = idx;\n\t\t\telse\n\t\t\t\tprev_tab = t->hpftid_tab;\n\t\t}\n\n\t\t \n\t\tnext_ftid = find_next_bit(t->ftid_bmap, t->nftids, idx);\n\t\tif (next_ftid >= t->nftids)\n\t\t\tnext_ftid = idx;\n\n\t\tnext_tab = t->ftid_tab;\n\t}\n\n\tnext_fe = &next_tab[next_ftid];\n\n\t \n\tprev_fe = &prev_tab[prev_ftid & ~(nslots - 1)];\n\tif (!prev_fe->fs.type)\n\t\tprev_fe = &prev_tab[prev_ftid];\n\n\tif ((prev_fe->valid && prev_fe->fs.tc_prio > prio) ||\n\t    (next_fe->valid && next_fe->fs.tc_prio < prio))\n\t\treturn false;\n\n\treturn true;\n}\n\nint cxgb4_get_free_ftid(struct net_device *dev, u8 family, bool hash_en,\n\t\t\tu32 tc_prio)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct tid_info *t = &adap->tids;\n\tu32 bmap_ftid, max_ftid;\n\tstruct filter_entry *f;\n\tunsigned long *bmap;\n\tbool found = false;\n\tu8 i, cnt, n;\n\tint ftid = 0;\n\n\t \n\tn = 1;\n\tif (family == PF_INET6) {\n\t\tn++;\n\t\tif (CHELSIO_CHIP_VERSION(adap->params.chip) < CHELSIO_T6)\n\t\t\tn += 2;\n\t}\n\n\t \n\n\tspin_lock_bh(&t->ftid_lock);\n\n\tftid = (tc_prio <= t->nhpftids) ? 0 : t->nhpftids;\n\tmax_ftid = t->nftids + t->nhpftids;\n\twhile (ftid < max_ftid) {\n\t\tif (ftid < t->nhpftids) {\n\t\t\t \n\t\t\tif ((t->tc_hash_tids_max_prio &&\n\t\t\t     tc_prio > t->tc_hash_tids_max_prio) ||\n\t\t\t     (ftid + n) > t->nhpftids) {\n\t\t\t\tftid = t->nhpftids;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbmap = t->hpftid_bmap;\n\t\t\tbmap_ftid = ftid;\n\t\t} else if (hash_en) {\n\t\t\t \n\t\t\tftid = find_last_bit(t->hpftid_bmap, t->nhpftids);\n\t\t\tif (ftid < t->nhpftids) {\n\t\t\t\tf = &t->hpftid_tab[ftid];\n\t\t\t\tif (f->valid && tc_prio < f->fs.tc_prio)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tftid = find_first_bit(t->ftid_bmap, t->nftids);\n\t\t\tif (ftid < t->nftids) {\n\t\t\t\tf = &t->ftid_tab[ftid];\n\t\t\t\tif (f->valid && tc_prio > f->fs.tc_prio)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfound = true;\n\t\t\tftid = t->nhpftids;\n\t\t\tgoto out_unlock;\n\t\t} else {\n\t\t\t \n\t\t\tif (t->tc_hash_tids_max_prio &&\n\t\t\t    tc_prio < t->tc_hash_tids_max_prio)\n\t\t\t\tbreak;\n\n\t\t\tif (ftid + n > max_ftid)\n\t\t\t\tbreak;\n\n\t\t\tbmap = t->ftid_bmap;\n\t\t\tbmap_ftid = ftid - t->nhpftids;\n\t\t}\n\n\t\tcnt = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (test_bit(bmap_ftid + i, bmap))\n\t\t\t\tbreak;\n\t\t\tcnt++;\n\t\t}\n\n\t\tif (cnt == n) {\n\t\t\t \n\t\t\tif (cxgb4_filter_prio_in_range(t, ftid, n,\n\t\t\t\t\t\t       tc_prio)) {\n\t\t\t\tftid &= ~(n - 1);\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tftid += n;\n\t}\n\nout_unlock:\n\tspin_unlock_bh(&t->ftid_lock);\n\treturn found ? ftid : -ENOMEM;\n}\n\nstatic int cxgb4_set_ftid(struct tid_info *t, int fidx, int family,\n\t\t\t  unsigned int chip_ver)\n{\n\tspin_lock_bh(&t->ftid_lock);\n\n\tif (test_bit(fidx, t->ftid_bmap)) {\n\t\tspin_unlock_bh(&t->ftid_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tif (family == PF_INET) {\n\t\t__set_bit(fidx, t->ftid_bmap);\n\t} else {\n\t\tif (chip_ver < CHELSIO_T6)\n\t\t\tbitmap_allocate_region(t->ftid_bmap, fidx, 2);\n\t\telse\n\t\t\tbitmap_allocate_region(t->ftid_bmap, fidx, 1);\n\t}\n\n\tspin_unlock_bh(&t->ftid_lock);\n\treturn 0;\n}\n\nstatic int cxgb4_set_hpftid(struct tid_info *t, int fidx, int family)\n{\n\tspin_lock_bh(&t->ftid_lock);\n\n\tif (test_bit(fidx, t->hpftid_bmap)) {\n\t\tspin_unlock_bh(&t->ftid_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tif (family == PF_INET)\n\t\t__set_bit(fidx, t->hpftid_bmap);\n\telse\n\t\tbitmap_allocate_region(t->hpftid_bmap, fidx, 1);\n\n\tspin_unlock_bh(&t->ftid_lock);\n\treturn 0;\n}\n\nstatic void cxgb4_clear_ftid(struct tid_info *t, int fidx, int family,\n\t\t\t     unsigned int chip_ver)\n{\n\tspin_lock_bh(&t->ftid_lock);\n\tif (family == PF_INET) {\n\t\t__clear_bit(fidx, t->ftid_bmap);\n\t} else {\n\t\tif (chip_ver < CHELSIO_T6)\n\t\t\tbitmap_release_region(t->ftid_bmap, fidx, 2);\n\t\telse\n\t\t\tbitmap_release_region(t->ftid_bmap, fidx, 1);\n\t}\n\tspin_unlock_bh(&t->ftid_lock);\n}\n\nstatic void cxgb4_clear_hpftid(struct tid_info *t, int fidx, int family)\n{\n\tspin_lock_bh(&t->ftid_lock);\n\n\tif (family == PF_INET)\n\t\t__clear_bit(fidx, t->hpftid_bmap);\n\telse\n\t\tbitmap_release_region(t->hpftid_bmap, fidx, 1);\n\n\tspin_unlock_bh(&t->ftid_lock);\n}\n\n \nstatic int del_filter_wr(struct adapter *adapter, int fidx)\n{\n\tstruct fw_filter_wr *fwr;\n\tstruct filter_entry *f;\n\tstruct sk_buff *skb;\n\tunsigned int len;\n\n\tif (fidx < adapter->tids.nhpftids)\n\t\tf = &adapter->tids.hpftid_tab[fidx];\n\telse\n\t\tf = &adapter->tids.ftid_tab[fidx - adapter->tids.nhpftids];\n\n\tlen = sizeof(*fwr);\n\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tfwr = __skb_put(skb, len);\n\tt4_mk_filtdelwr(f->tid, fwr, adapter->sge.fw_evtq.abs_id);\n\n\t \n\tf->pending = 1;\n\tt4_mgmt_tx(adapter, skb);\n\treturn 0;\n}\n\n \nint set_filter_wr(struct adapter *adapter, int fidx)\n{\n\tstruct fw_filter2_wr *fwr;\n\tstruct filter_entry *f;\n\tstruct sk_buff *skb;\n\n\tif (fidx < adapter->tids.nhpftids)\n\t\tf = &adapter->tids.hpftid_tab[fidx];\n\telse\n\t\tf = &adapter->tids.ftid_tab[fidx - adapter->tids.nhpftids];\n\n\tskb = alloc_skb(sizeof(*fwr), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t \n\tif (f->fs.newdmac || f->fs.newvlan) {\n\t\t \n\t\tf->l2t = t4_l2t_alloc_switching(adapter, f->fs.vlan,\n\t\t\t\t\t\tf->fs.eport, f->fs.dmac);\n\t\tif (!f->l2t) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tif (f->fs.newsmac) {\n\t\tf->smt = cxgb4_smt_alloc_switching(f->dev, f->fs.smac);\n\t\tif (!f->smt) {\n\t\t\tif (f->l2t) {\n\t\t\t\tcxgb4_l2t_release(f->l2t);\n\t\t\t\tf->l2t = NULL;\n\t\t\t}\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfwr = __skb_put_zero(skb, sizeof(*fwr));\n\n\t \n\tif (adapter->params.filter2_wr_support)\n\t\tfwr->op_pkd = htonl(FW_WR_OP_V(FW_FILTER2_WR));\n\telse\n\t\tfwr->op_pkd = htonl(FW_WR_OP_V(FW_FILTER_WR));\n\tfwr->len16_pkd = htonl(FW_WR_LEN16_V(sizeof(*fwr) / 16));\n\tfwr->tid_to_iq =\n\t\thtonl(FW_FILTER_WR_TID_V(f->tid) |\n\t\t      FW_FILTER_WR_RQTYPE_V(f->fs.type) |\n\t\t      FW_FILTER_WR_NOREPLY_V(0) |\n\t\t      FW_FILTER_WR_IQ_V(f->fs.iq));\n\tfwr->del_filter_to_l2tix =\n\t\thtonl(FW_FILTER_WR_RPTTID_V(f->fs.rpttid) |\n\t\t      FW_FILTER_WR_DROP_V(f->fs.action == FILTER_DROP) |\n\t\t      FW_FILTER_WR_DIRSTEER_V(f->fs.dirsteer) |\n\t\t      FW_FILTER_WR_MASKHASH_V(f->fs.maskhash) |\n\t\t      FW_FILTER_WR_DIRSTEERHASH_V(f->fs.dirsteerhash) |\n\t\t      FW_FILTER_WR_LPBK_V(f->fs.action == FILTER_SWITCH) |\n\t\t      FW_FILTER_WR_DMAC_V(f->fs.newdmac) |\n\t\t      FW_FILTER_WR_SMAC_V(f->fs.newsmac) |\n\t\t      FW_FILTER_WR_INSVLAN_V(f->fs.newvlan == VLAN_INSERT ||\n\t\t\t\t\t     f->fs.newvlan == VLAN_REWRITE) |\n\t\t      FW_FILTER_WR_RMVLAN_V(f->fs.newvlan == VLAN_REMOVE ||\n\t\t\t\t\t    f->fs.newvlan == VLAN_REWRITE) |\n\t\t      FW_FILTER_WR_HITCNTS_V(f->fs.hitcnts) |\n\t\t      FW_FILTER_WR_TXCHAN_V(f->fs.eport) |\n\t\t      FW_FILTER_WR_PRIO_V(f->fs.prio) |\n\t\t      FW_FILTER_WR_L2TIX_V(f->l2t ? f->l2t->idx : 0));\n\tfwr->ethtype = htons(f->fs.val.ethtype);\n\tfwr->ethtypem = htons(f->fs.mask.ethtype);\n\tfwr->frag_to_ovlan_vldm =\n\t\t(FW_FILTER_WR_FRAG_V(f->fs.val.frag) |\n\t\t FW_FILTER_WR_FRAGM_V(f->fs.mask.frag) |\n\t\t FW_FILTER_WR_IVLAN_VLD_V(f->fs.val.ivlan_vld) |\n\t\t FW_FILTER_WR_OVLAN_VLD_V(f->fs.val.ovlan_vld) |\n\t\t FW_FILTER_WR_IVLAN_VLDM_V(f->fs.mask.ivlan_vld) |\n\t\t FW_FILTER_WR_OVLAN_VLDM_V(f->fs.mask.ovlan_vld));\n\tif (f->fs.newsmac)\n\t\tfwr->smac_sel = f->smt->idx;\n\tfwr->rx_chan_rx_rpl_iq =\n\t\thtons(FW_FILTER_WR_RX_CHAN_V(0) |\n\t\t      FW_FILTER_WR_RX_RPL_IQ_V(adapter->sge.fw_evtq.abs_id));\n\tfwr->maci_to_matchtypem =\n\t\thtonl(FW_FILTER_WR_MACI_V(f->fs.val.macidx) |\n\t\t      FW_FILTER_WR_MACIM_V(f->fs.mask.macidx) |\n\t\t      FW_FILTER_WR_FCOE_V(f->fs.val.fcoe) |\n\t\t      FW_FILTER_WR_FCOEM_V(f->fs.mask.fcoe) |\n\t\t      FW_FILTER_WR_PORT_V(f->fs.val.iport) |\n\t\t      FW_FILTER_WR_PORTM_V(f->fs.mask.iport) |\n\t\t      FW_FILTER_WR_MATCHTYPE_V(f->fs.val.matchtype) |\n\t\t      FW_FILTER_WR_MATCHTYPEM_V(f->fs.mask.matchtype));\n\tfwr->ptcl = f->fs.val.proto;\n\tfwr->ptclm = f->fs.mask.proto;\n\tfwr->ttyp = f->fs.val.tos;\n\tfwr->ttypm = f->fs.mask.tos;\n\tfwr->ivlan = htons(f->fs.val.ivlan);\n\tfwr->ivlanm = htons(f->fs.mask.ivlan);\n\tfwr->ovlan = htons(f->fs.val.ovlan);\n\tfwr->ovlanm = htons(f->fs.mask.ovlan);\n\tmemcpy(fwr->lip, f->fs.val.lip, sizeof(fwr->lip));\n\tmemcpy(fwr->lipm, f->fs.mask.lip, sizeof(fwr->lipm));\n\tmemcpy(fwr->fip, f->fs.val.fip, sizeof(fwr->fip));\n\tmemcpy(fwr->fipm, f->fs.mask.fip, sizeof(fwr->fipm));\n\tfwr->lp = htons(f->fs.val.lport);\n\tfwr->lpm = htons(f->fs.mask.lport);\n\tfwr->fp = htons(f->fs.val.fport);\n\tfwr->fpm = htons(f->fs.mask.fport);\n\n\tif (adapter->params.filter2_wr_support) {\n\t\tu8 *nat_lp = (u8 *)&f->fs.nat_lport;\n\t\tu8 *nat_fp = (u8 *)&f->fs.nat_fport;\n\n\t\tfwr->natmode_to_ulp_type =\n\t\t\tFW_FILTER2_WR_ULP_TYPE_V(f->fs.nat_mode ?\n\t\t\t\t\t\t ULP_MODE_TCPDDP :\n\t\t\t\t\t\t ULP_MODE_NONE) |\n\t\t\tFW_FILTER2_WR_NATMODE_V(f->fs.nat_mode);\n\t\tmemcpy(fwr->newlip, f->fs.nat_lip, sizeof(fwr->newlip));\n\t\tmemcpy(fwr->newfip, f->fs.nat_fip, sizeof(fwr->newfip));\n\t\tfwr->newlport = htons(nat_lp[1] | nat_lp[0] << 8);\n\t\tfwr->newfport = htons(nat_fp[1] | nat_fp[0] << 8);\n\t}\n\n\t \n\tf->pending = 1;\n\tset_wr_txq(skb, CPL_PRIORITY_CONTROL, f->fs.val.iport & 0x3);\n\tt4_ofld_send(adapter, skb);\n\treturn 0;\n}\n\n \nint writable_filter(struct filter_entry *f)\n{\n\tif (f->locked)\n\t\treturn -EPERM;\n\tif (f->pending)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n \nint delete_filter(struct adapter *adapter, unsigned int fidx)\n{\n\tstruct filter_entry *f;\n\tint ret;\n\n\tif (fidx >= adapter->tids.nftids + adapter->tids.nsftids +\n\t\t    adapter->tids.nhpftids)\n\t\treturn -EINVAL;\n\n\tif (fidx < adapter->tids.nhpftids)\n\t\tf = &adapter->tids.hpftid_tab[fidx];\n\telse\n\t\tf = &adapter->tids.ftid_tab[fidx - adapter->tids.nhpftids];\n\tret = writable_filter(f);\n\tif (ret)\n\t\treturn ret;\n\tif (f->valid)\n\t\treturn del_filter_wr(adapter, fidx);\n\n\treturn 0;\n}\n\n \nvoid clear_filter(struct adapter *adap, struct filter_entry *f)\n{\n\tstruct port_info *pi = netdev_priv(f->dev);\n\n\t \n\tif (f->l2t)\n\t\tcxgb4_l2t_release(f->l2t);\n\n\tif (f->smt)\n\t\tcxgb4_smt_release(f->smt);\n\n\tif (f->fs.val.encap_vld && f->fs.val.ovlan_vld)\n\t\tt4_free_encap_mac_filt(adap, pi->viid,\n\t\t\t\t       f->fs.val.ovlan & 0x1ff, 0);\n\n\tif ((f->fs.hash || is_t6(adap->params.chip)) && f->fs.type)\n\t\tcxgb4_clip_release(f->dev, (const u32 *)&f->fs.val.lip, 1);\n\n\t \n\tmemset(f, 0, sizeof(*f));\n}\n\nvoid clear_all_filters(struct adapter *adapter)\n{\n\tstruct net_device *dev = adapter->port[0];\n\tunsigned int i;\n\n\tif (adapter->tids.hpftid_tab) {\n\t\tstruct filter_entry *f = &adapter->tids.hpftid_tab[0];\n\n\t\tfor (i = 0; i < adapter->tids.nhpftids; i++, f++)\n\t\t\tif (f->valid || f->pending)\n\t\t\t\tcxgb4_del_filter(dev, i, &f->fs);\n\t}\n\n\tif (adapter->tids.ftid_tab) {\n\t\tstruct filter_entry *f = &adapter->tids.ftid_tab[0];\n\t\tunsigned int max_ftid = adapter->tids.nftids +\n\t\t\t\t\tadapter->tids.nsftids +\n\t\t\t\t\tadapter->tids.nhpftids;\n\n\t\t \n\t\tfor (i = adapter->tids.nhpftids; i < max_ftid; i++, f++)\n\t\t\tif (f->valid || f->pending)\n\t\t\t\tcxgb4_del_filter(dev, i, &f->fs);\n\t}\n\n\t \n\tif (is_hashfilter(adapter) && adapter->tids.tid_tab) {\n\t\tstruct filter_entry *f;\n\t\tunsigned int sb;\n\n\t\tfor (i = adapter->tids.hash_base;\n\t\t     i <= adapter->tids.ntids; i++) {\n\t\t\tf = (struct filter_entry *)\n\t\t\t\tadapter->tids.tid_tab[i];\n\n\t\t\tif (f && (f->valid || f->pending))\n\t\t\t\tcxgb4_del_filter(dev, f->tid, &f->fs);\n\t\t}\n\n\t\tsb = adapter->tids.stid_base;\n\t\tfor (i = 0; i < sb; i++) {\n\t\t\tf = (struct filter_entry *)adapter->tids.tid_tab[i];\n\n\t\t\tif (f && (f->valid || f->pending))\n\t\t\t\tcxgb4_del_filter(dev, f->tid, &f->fs);\n\t\t}\n\t}\n}\n\n \nstatic void fill_default_mask(struct ch_filter_specification *fs)\n{\n\tunsigned int lip = 0, lip_mask = 0;\n\tunsigned int fip = 0, fip_mask = 0;\n\tunsigned int i;\n\n\tif (fs->val.iport && !fs->mask.iport)\n\t\tfs->mask.iport |= ~0;\n\tif (fs->val.fcoe && !fs->mask.fcoe)\n\t\tfs->mask.fcoe |= ~0;\n\tif (fs->val.matchtype && !fs->mask.matchtype)\n\t\tfs->mask.matchtype |= ~0;\n\tif (fs->val.macidx && !fs->mask.macidx)\n\t\tfs->mask.macidx |= ~0;\n\tif (fs->val.ethtype && !fs->mask.ethtype)\n\t\tfs->mask.ethtype |= ~0;\n\tif (fs->val.ivlan && !fs->mask.ivlan)\n\t\tfs->mask.ivlan |= ~0;\n\tif (fs->val.ovlan && !fs->mask.ovlan)\n\t\tfs->mask.ovlan |= ~0;\n\tif (fs->val.frag && !fs->mask.frag)\n\t\tfs->mask.frag |= ~0;\n\tif (fs->val.tos && !fs->mask.tos)\n\t\tfs->mask.tos |= ~0;\n\tif (fs->val.proto && !fs->mask.proto)\n\t\tfs->mask.proto |= ~0;\n\tif (fs->val.pfvf_vld && !fs->mask.pfvf_vld)\n\t\tfs->mask.pfvf_vld |= ~0;\n\tif (fs->val.pf && !fs->mask.pf)\n\t\tfs->mask.pf |= ~0;\n\tif (fs->val.vf && !fs->mask.vf)\n\t\tfs->mask.vf |= ~0;\n\n\tfor (i = 0; i < ARRAY_SIZE(fs->val.lip); i++) {\n\t\tlip |= fs->val.lip[i];\n\t\tlip_mask |= fs->mask.lip[i];\n\t\tfip |= fs->val.fip[i];\n\t\tfip_mask |= fs->mask.fip[i];\n\t}\n\n\tif (lip && !lip_mask)\n\t\tmemset(fs->mask.lip, ~0, sizeof(fs->mask.lip));\n\n\tif (fip && !fip_mask)\n\t\tmemset(fs->mask.fip, ~0, sizeof(fs->mask.lip));\n\n\tif (fs->val.lport && !fs->mask.lport)\n\t\tfs->mask.lport = ~0;\n\tif (fs->val.fport && !fs->mask.fport)\n\t\tfs->mask.fport = ~0;\n}\n\nstatic bool is_addr_all_mask(u8 *ipmask, int family)\n{\n\tif (family == AF_INET) {\n\t\tstruct in_addr *addr;\n\n\t\taddr = (struct in_addr *)ipmask;\n\t\tif (addr->s_addr == htonl(0xffffffff))\n\t\t\treturn true;\n\t} else if (family == AF_INET6) {\n\t\tstruct in6_addr *addr6;\n\n\t\taddr6 = (struct in6_addr *)ipmask;\n\t\tif (addr6->s6_addr32[0] == htonl(0xffffffff) &&\n\t\t    addr6->s6_addr32[1] == htonl(0xffffffff) &&\n\t\t    addr6->s6_addr32[2] == htonl(0xffffffff) &&\n\t\t    addr6->s6_addr32[3] == htonl(0xffffffff))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool is_inaddr_any(u8 *ip, int family)\n{\n\tint addr_type;\n\n\tif (family == AF_INET) {\n\t\tstruct in_addr *addr;\n\n\t\taddr = (struct in_addr *)ip;\n\t\tif (addr->s_addr == htonl(INADDR_ANY))\n\t\t\treturn true;\n\t} else if (family == AF_INET6) {\n\t\tstruct in6_addr *addr6;\n\n\t\taddr6 = (struct in6_addr *)ip;\n\t\taddr_type = ipv6_addr_type((const struct in6_addr *)\n\t\t\t\t\t   &addr6);\n\t\tif (addr_type == IPV6_ADDR_ANY)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool is_filter_exact_match(struct adapter *adap,\n\t\t\t   struct ch_filter_specification *fs)\n{\n\tstruct tp_params *tp = &adap->params.tp;\n\tu64 hash_filter_mask = tp->hash_filter_mask;\n\tu64 ntuple_mask = 0;\n\n\tif (!is_hashfilter(adap))\n\t\treturn false;\n\n\tif ((atomic_read(&adap->tids.hash_tids_in_use) +\n\t     atomic_read(&adap->tids.tids_in_use)) >=\n\t    (adap->tids.nhash + (adap->tids.stid_base - adap->tids.tid_base)))\n\t\treturn false;\n\n\t  \n\tif (fs->mask.encap_vld)\n\t\treturn false;\n\n\tif (fs->type) {\n\t\tif (is_inaddr_any(fs->val.fip, AF_INET6) ||\n\t\t    !is_addr_all_mask(fs->mask.fip, AF_INET6))\n\t\t\treturn false;\n\n\t\tif (is_inaddr_any(fs->val.lip, AF_INET6) ||\n\t\t    !is_addr_all_mask(fs->mask.lip, AF_INET6))\n\t\t\treturn false;\n\t} else {\n\t\tif (is_inaddr_any(fs->val.fip, AF_INET) ||\n\t\t    !is_addr_all_mask(fs->mask.fip, AF_INET))\n\t\t\treturn false;\n\n\t\tif (is_inaddr_any(fs->val.lip, AF_INET) ||\n\t\t    !is_addr_all_mask(fs->mask.lip, AF_INET))\n\t\t\treturn false;\n\t}\n\n\tif (!fs->val.lport || fs->mask.lport != 0xffff)\n\t\treturn false;\n\n\tif (!fs->val.fport || fs->mask.fport != 0xffff)\n\t\treturn false;\n\n\t \n\tif (tp->fcoe_shift >= 0)\n\t\tntuple_mask |= (u64)fs->mask.fcoe << tp->fcoe_shift;\n\n\tif (tp->port_shift >= 0)\n\t\tntuple_mask |= (u64)fs->mask.iport << tp->port_shift;\n\n\tif (tp->vnic_shift >= 0) {\n\t\tif ((adap->params.tp.ingress_config & VNIC_F))\n\t\t\tntuple_mask |= (u64)fs->mask.pfvf_vld << tp->vnic_shift;\n\t\telse\n\t\t\tntuple_mask |= (u64)fs->mask.ovlan_vld <<\n\t\t\t\ttp->vnic_shift;\n\t}\n\n\tif (tp->vlan_shift >= 0)\n\t\tntuple_mask |= (u64)fs->mask.ivlan << tp->vlan_shift;\n\n\tif (tp->tos_shift >= 0)\n\t\tntuple_mask |= (u64)fs->mask.tos << tp->tos_shift;\n\n\tif (tp->protocol_shift >= 0)\n\t\tntuple_mask |= (u64)fs->mask.proto << tp->protocol_shift;\n\n\tif (tp->ethertype_shift >= 0)\n\t\tntuple_mask |= (u64)fs->mask.ethtype << tp->ethertype_shift;\n\n\tif (tp->macmatch_shift >= 0)\n\t\tntuple_mask |= (u64)fs->mask.macidx << tp->macmatch_shift;\n\n\tif (tp->matchtype_shift >= 0)\n\t\tntuple_mask |= (u64)fs->mask.matchtype << tp->matchtype_shift;\n\n\tif (tp->frag_shift >= 0)\n\t\tntuple_mask |= (u64)fs->mask.frag << tp->frag_shift;\n\n\tif (ntuple_mask != hash_filter_mask)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic u64 hash_filter_ntuple(struct ch_filter_specification *fs,\n\t\t\t      struct net_device *dev)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct tp_params *tp = &adap->params.tp;\n\tu64 ntuple = 0;\n\n\t \n\tif (tp->vlan_shift >= 0 && fs->mask.ivlan)\n\t\tntuple |= (FT_VLAN_VLD_F | fs->val.ivlan) << tp->vlan_shift;\n\n\tif (tp->port_shift >= 0 && fs->mask.iport)\n\t\tntuple |= (u64)fs->val.iport << tp->port_shift;\n\n\tif (tp->protocol_shift >= 0) {\n\t\tif (!fs->val.proto)\n\t\t\tntuple |= (u64)IPPROTO_TCP << tp->protocol_shift;\n\t\telse\n\t\t\tntuple |= (u64)fs->val.proto << tp->protocol_shift;\n\t}\n\n\tif (tp->tos_shift >= 0 && fs->mask.tos)\n\t\tntuple |= (u64)(fs->val.tos) << tp->tos_shift;\n\n\tif (tp->vnic_shift >= 0) {\n\t\tif ((adap->params.tp.ingress_config & USE_ENC_IDX_F) &&\n\t\t    fs->mask.encap_vld)\n\t\t\tntuple |= (u64)((fs->val.encap_vld << 16) |\n\t\t\t\t\t(fs->val.ovlan)) << tp->vnic_shift;\n\t\telse if ((adap->params.tp.ingress_config & VNIC_F) &&\n\t\t\t fs->mask.pfvf_vld)\n\t\t\tntuple |= (u64)((fs->val.pfvf_vld << 16) |\n\t\t\t\t\t(fs->val.pf << 13) |\n\t\t\t\t\t(fs->val.vf)) << tp->vnic_shift;\n\t\telse\n\t\t\tntuple |= (u64)((fs->val.ovlan_vld << 16) |\n\t\t\t\t\t(fs->val.ovlan)) << tp->vnic_shift;\n\t}\n\n\tif (tp->macmatch_shift >= 0 && fs->mask.macidx)\n\t\tntuple |= (u64)(fs->val.macidx) << tp->macmatch_shift;\n\n\tif (tp->ethertype_shift >= 0 && fs->mask.ethtype)\n\t\tntuple |= (u64)(fs->val.ethtype) << tp->ethertype_shift;\n\n\tif (tp->matchtype_shift >= 0 && fs->mask.matchtype)\n\t\tntuple |= (u64)(fs->val.matchtype) << tp->matchtype_shift;\n\n\tif (tp->frag_shift >= 0 && fs->mask.frag)\n\t\tntuple |= (u64)(fs->val.frag) << tp->frag_shift;\n\n\tif (tp->fcoe_shift >= 0 && fs->mask.fcoe)\n\t\tntuple |= (u64)(fs->val.fcoe) << tp->fcoe_shift;\n\treturn ntuple;\n}\n\nstatic void mk_act_open_req6(struct filter_entry *f, struct sk_buff *skb,\n\t\t\t     unsigned int qid_filterid, struct adapter *adap)\n{\n\tstruct cpl_t6_act_open_req6 *t6req = NULL;\n\tstruct cpl_act_open_req6 *req = NULL;\n\n\tt6req = (struct cpl_t6_act_open_req6 *)__skb_put(skb, sizeof(*t6req));\n\tINIT_TP_WR(t6req, 0);\n\treq = (struct cpl_act_open_req6 *)t6req;\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_ACT_OPEN_REQ6, qid_filterid));\n\treq->local_port = cpu_to_be16(f->fs.val.lport);\n\treq->peer_port = cpu_to_be16(f->fs.val.fport);\n\treq->local_ip_hi = *(__be64 *)(&f->fs.val.lip);\n\treq->local_ip_lo = *(((__be64 *)&f->fs.val.lip) + 1);\n\treq->peer_ip_hi = *(__be64 *)(&f->fs.val.fip);\n\treq->peer_ip_lo = *(((__be64 *)&f->fs.val.fip) + 1);\n\treq->opt0 = cpu_to_be64(NAGLE_V(f->fs.newvlan == VLAN_REMOVE ||\n\t\t\t\t\tf->fs.newvlan == VLAN_REWRITE) |\n\t\t\t\tDELACK_V(f->fs.hitcnts) |\n\t\t\t\tL2T_IDX_V(f->l2t ? f->l2t->idx : 0) |\n\t\t\t\tSMAC_SEL_V((cxgb4_port_viid(f->dev) &\n\t\t\t\t\t    0x7F) << 1) |\n\t\t\t\tTX_CHAN_V(f->fs.eport) |\n\t\t\t\tNO_CONG_V(f->fs.rpttid) |\n\t\t\t\tULP_MODE_V(f->fs.nat_mode ?\n\t\t\t\t\t   ULP_MODE_TCPDDP : ULP_MODE_NONE) |\n\t\t\t\tTCAM_BYPASS_F | NON_OFFLOAD_F);\n\tt6req->params = cpu_to_be64(FILTER_TUPLE_V(hash_filter_ntuple(&f->fs,\n\t\t\t\t\t\t\t\t      f->dev)));\n\tt6req->opt2 = htonl(RSS_QUEUE_VALID_F |\n\t\t\t    RSS_QUEUE_V(f->fs.iq) |\n\t\t\t    TX_QUEUE_V(f->fs.nat_mode) |\n\t\t\t    T5_OPT_2_VALID_F |\n\t\t\t    RX_CHANNEL_V(cxgb4_port_e2cchan(f->dev)) |\n\t\t\t    PACE_V((f->fs.maskhash) |\n\t\t\t\t   ((f->fs.dirsteerhash) << 1)));\n}\n\nstatic void mk_act_open_req(struct filter_entry *f, struct sk_buff *skb,\n\t\t\t    unsigned int qid_filterid, struct adapter *adap)\n{\n\tstruct cpl_t6_act_open_req *t6req = NULL;\n\tstruct cpl_act_open_req *req = NULL;\n\n\tt6req = (struct cpl_t6_act_open_req *)__skb_put(skb, sizeof(*t6req));\n\tINIT_TP_WR(t6req, 0);\n\treq = (struct cpl_act_open_req *)t6req;\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_ACT_OPEN_REQ, qid_filterid));\n\treq->local_port = cpu_to_be16(f->fs.val.lport);\n\treq->peer_port = cpu_to_be16(f->fs.val.fport);\n\tmemcpy(&req->local_ip, f->fs.val.lip, 4);\n\tmemcpy(&req->peer_ip, f->fs.val.fip, 4);\n\treq->opt0 = cpu_to_be64(NAGLE_V(f->fs.newvlan == VLAN_REMOVE ||\n\t\t\t\t\tf->fs.newvlan == VLAN_REWRITE) |\n\t\t\t\tDELACK_V(f->fs.hitcnts) |\n\t\t\t\tL2T_IDX_V(f->l2t ? f->l2t->idx : 0) |\n\t\t\t\tSMAC_SEL_V((cxgb4_port_viid(f->dev) &\n\t\t\t\t\t    0x7F) << 1) |\n\t\t\t\tTX_CHAN_V(f->fs.eport) |\n\t\t\t\tNO_CONG_V(f->fs.rpttid) |\n\t\t\t\tULP_MODE_V(f->fs.nat_mode ?\n\t\t\t\t\t   ULP_MODE_TCPDDP : ULP_MODE_NONE) |\n\t\t\t\tTCAM_BYPASS_F | NON_OFFLOAD_F);\n\n\tt6req->params = cpu_to_be64(FILTER_TUPLE_V(hash_filter_ntuple(&f->fs,\n\t\t\t\t\t\t\t\t      f->dev)));\n\tt6req->opt2 = htonl(RSS_QUEUE_VALID_F |\n\t\t\t    RSS_QUEUE_V(f->fs.iq) |\n\t\t\t    TX_QUEUE_V(f->fs.nat_mode) |\n\t\t\t    T5_OPT_2_VALID_F |\n\t\t\t    RX_CHANNEL_V(cxgb4_port_e2cchan(f->dev)) |\n\t\t\t    PACE_V((f->fs.maskhash) |\n\t\t\t\t   ((f->fs.dirsteerhash) << 1)));\n}\n\nstatic int cxgb4_set_hash_filter(struct net_device *dev,\n\t\t\t\t struct ch_filter_specification *fs,\n\t\t\t\t struct filter_ctx *ctx)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct tid_info *t = &adapter->tids;\n\tstruct filter_entry *f;\n\tstruct sk_buff *skb;\n\tint iq, atid, size;\n\tint ret = 0;\n\tu32 iconf;\n\n\tfill_default_mask(fs);\n\tret = validate_filter(dev, fs);\n\tif (ret)\n\t\treturn ret;\n\n\tiq = get_filter_steerq(dev, fs);\n\tif (iq < 0)\n\t\treturn iq;\n\n\tf = kzalloc(sizeof(*f), GFP_KERNEL);\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tf->fs = *fs;\n\tf->ctx = ctx;\n\tf->dev = dev;\n\tf->fs.iq = iq;\n\n\t \n\tif (f->fs.newdmac || f->fs.newvlan) {\n\t\t \n\t\tf->l2t = t4_l2t_alloc_switching(adapter, f->fs.vlan,\n\t\t\t\t\t\tf->fs.eport, f->fs.dmac);\n\t\tif (!f->l2t) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\t \n\tif (f->fs.newsmac) {\n\t\tf->smt = cxgb4_smt_alloc_switching(f->dev, f->fs.smac);\n\t\tif (!f->smt) {\n\t\t\tif (f->l2t) {\n\t\t\t\tcxgb4_l2t_release(f->l2t);\n\t\t\t\tf->l2t = NULL;\n\t\t\t}\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_l2t;\n\t\t}\n\t}\n\n\tatid = cxgb4_alloc_atid(t, f);\n\tif (atid < 0) {\n\t\tret = atid;\n\t\tgoto free_smt;\n\t}\n\n\ticonf = adapter->params.tp.ingress_config;\n\tif (iconf & VNIC_F) {\n\t\tf->fs.val.ovlan = (fs->val.pf << 13) | fs->val.vf;\n\t\tf->fs.mask.ovlan = (fs->mask.pf << 13) | fs->mask.vf;\n\t\tf->fs.val.ovlan_vld = fs->val.pfvf_vld;\n\t\tf->fs.mask.ovlan_vld = fs->mask.pfvf_vld;\n\t} else if (iconf & USE_ENC_IDX_F) {\n\t\tif (f->fs.val.encap_vld) {\n\t\t\tstruct port_info *pi = netdev_priv(f->dev);\n\t\t\tstatic const u8 match_all_mac[] = { 0, 0, 0, 0, 0, 0 };\n\n\t\t\t \n\t\t\tret = t4_alloc_encap_mac_filt(adapter, pi->viid,\n\t\t\t\t\t\t      match_all_mac,\n\t\t\t\t\t\t      match_all_mac,\n\t\t\t\t\t\t      f->fs.val.vni,\n\t\t\t\t\t\t      f->fs.mask.vni,\n\t\t\t\t\t\t      0, 1, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_atid;\n\n\t\t\tf->fs.val.ovlan = ret;\n\t\t\tf->fs.mask.ovlan = 0xffff;\n\t\t\tf->fs.val.ovlan_vld = 1;\n\t\t\tf->fs.mask.ovlan_vld = 1;\n\t\t}\n\t}\n\n\tsize = sizeof(struct cpl_t6_act_open_req);\n\tif (f->fs.type) {\n\t\tret = cxgb4_clip_get(f->dev, (const u32 *)&f->fs.val.lip, 1);\n\t\tif (ret)\n\t\t\tgoto free_mps;\n\n\t\tskb = alloc_skb(size, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_clip;\n\t\t}\n\n\t\tmk_act_open_req6(f, skb,\n\t\t\t\t ((adapter->sge.fw_evtq.abs_id << 14) | atid),\n\t\t\t\t adapter);\n\t} else {\n\t\tskb = alloc_skb(size, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_mps;\n\t\t}\n\n\t\tmk_act_open_req(f, skb,\n\t\t\t\t((adapter->sge.fw_evtq.abs_id << 14) | atid),\n\t\t\t\tadapter);\n\t}\n\n\tf->pending = 1;\n\tset_wr_txq(skb, CPL_PRIORITY_SETUP, f->fs.val.iport & 0x3);\n\tt4_ofld_send(adapter, skb);\n\treturn 0;\n\nfree_clip:\n\tcxgb4_clip_release(f->dev, (const u32 *)&f->fs.val.lip, 1);\n\nfree_mps:\n\tif (f->fs.val.encap_vld && f->fs.val.ovlan_vld)\n\t\tt4_free_encap_mac_filt(adapter, pi->viid, f->fs.val.ovlan, 1);\n\nfree_atid:\n\tcxgb4_free_atid(t, atid);\n\nfree_smt:\n\tif (f->smt) {\n\t\tcxgb4_smt_release(f->smt);\n\t\tf->smt = NULL;\n\t}\n\nfree_l2t:\n\tif (f->l2t) {\n\t\tcxgb4_l2t_release(f->l2t);\n\t\tf->l2t = NULL;\n\t}\n\nout_err:\n\tkfree(f);\n\treturn ret;\n}\n\n \nint __cxgb4_set_filter(struct net_device *dev, int ftid,\n\t\t       struct ch_filter_specification *fs,\n\t\t       struct filter_ctx *ctx)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\tunsigned int max_fidx, fidx, chip_ver;\n\tint iq, ret, filter_id = ftid;\n\tstruct filter_entry *f, *tab;\n\tu32 iconf;\n\n\tchip_ver = CHELSIO_CHIP_VERSION(adapter->params.chip);\n\tif (fs->hash) {\n\t\tif (is_hashfilter(adapter))\n\t\t\treturn cxgb4_set_hash_filter(dev, fs, ctx);\n\t\tnetdev_err(dev, \"%s: Exact-match filters only supported with Hash Filter configuration\\n\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmax_fidx = adapter->tids.nftids + adapter->tids.nhpftids;\n\tif (filter_id != (max_fidx + adapter->tids.nsftids - 1) &&\n\t    filter_id >= max_fidx)\n\t\treturn -E2BIG;\n\n\tfill_default_mask(fs);\n\n\tret = validate_filter(dev, fs);\n\tif (ret)\n\t\treturn ret;\n\n\tiq = get_filter_steerq(dev, fs);\n\tif (iq < 0)\n\t\treturn iq;\n\n\tif (fs->prio) {\n\t\ttab = &adapter->tids.hpftid_tab[0];\n\t} else {\n\t\ttab = &adapter->tids.ftid_tab[0];\n\t\tfilter_id = ftid - adapter->tids.nhpftids;\n\t}\n\n\t \n\tif (fs->type == 0) {  \n\t\t \n\t\tif (chip_ver < CHELSIO_T6)\n\t\t\tfidx = filter_id & ~0x3;\n\t\telse\n\t\t\tfidx = filter_id & ~0x1;\n\n\t\tif (fidx != filter_id && tab[fidx].fs.type) {\n\t\t\tf = &tab[fidx];\n\t\t\tif (f->valid) {\n\t\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\t\"Invalid location. IPv6 requires 4 slots and is occupying slots %u to %u\\n\",\n\t\t\t\t\tfidx, fidx + 3);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else {  \n\t\tif (chip_ver < CHELSIO_T6) {\n\t\t\t \n\t\t\tif (filter_id & 0x3) {\n\t\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\t\"Invalid location. IPv6 must be aligned on a 4-slot boundary\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (fidx = filter_id + 1; fidx < filter_id + 4;\n\t\t\t     fidx++) {\n\t\t\t\tf = &tab[fidx];\n\t\t\t\tif (f->valid) {\n\t\t\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\t\t\"Invalid location.  IPv6 requires 4 slots and an IPv4 filter exists at %u\\n\",\n\t\t\t\t\t\tfidx);\n\t\t\t\t\treturn -EBUSY;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (filter_id & 0x1)\n\t\t\t\treturn -EINVAL;\n\t\t\t \n\t\t\tfidx = filter_id + 1;\n\t\t\tf = &tab[fidx];\n\t\t\tif (f->valid) {\n\t\t\t\tpr_err(\"%s: IPv6 filter requires 2 indices. IPv4 filter already present at %d. Please remove IPv4 filter first.\\n\",\n\t\t\t\t       __func__, fidx);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tf = &tab[filter_id];\n\tif (f->valid)\n\t\treturn -EBUSY;\n\n\tif (fs->prio) {\n\t\tfidx = filter_id + adapter->tids.hpftid_base;\n\t\tret = cxgb4_set_hpftid(&adapter->tids, filter_id,\n\t\t\t\t       fs->type ? PF_INET6 : PF_INET);\n\t} else {\n\t\tfidx = filter_id + adapter->tids.ftid_base;\n\t\tret = cxgb4_set_ftid(&adapter->tids, filter_id,\n\t\t\t\t     fs->type ? PF_INET6 : PF_INET,\n\t\t\t\t     chip_ver);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = writable_filter(f);\n\tif (ret)\n\t\tgoto free_tid;\n\n\tif (is_t6(adapter->params.chip) && fs->type &&\n\t    ipv6_addr_type((const struct in6_addr *)fs->val.lip) !=\n\t    IPV6_ADDR_ANY) {\n\t\tret = cxgb4_clip_get(dev, (const u32 *)&fs->val.lip, 1);\n\t\tif (ret)\n\t\t\tgoto free_tid;\n\t}\n\n\t \n\tf->fs = *fs;\n\tf->fs.iq = iq;\n\tf->dev = dev;\n\n\ticonf = adapter->params.tp.ingress_config;\n\tif (iconf & VNIC_F) {\n\t\tf->fs.val.ovlan = (fs->val.pf << 13) | fs->val.vf;\n\t\tf->fs.mask.ovlan = (fs->mask.pf << 13) | fs->mask.vf;\n\t\tf->fs.val.ovlan_vld = fs->val.pfvf_vld;\n\t\tf->fs.mask.ovlan_vld = fs->mask.pfvf_vld;\n\t} else if (iconf & USE_ENC_IDX_F) {\n\t\tif (f->fs.val.encap_vld) {\n\t\t\tstruct port_info *pi = netdev_priv(f->dev);\n\t\t\tstatic const u8 match_all_mac[] = { 0, 0, 0, 0, 0, 0 };\n\n\t\t\t \n\t\t\tret = t4_alloc_encap_mac_filt(adapter, pi->viid,\n\t\t\t\t\t\t      match_all_mac,\n\t\t\t\t\t\t      match_all_mac,\n\t\t\t\t\t\t      f->fs.val.vni,\n\t\t\t\t\t\t      f->fs.mask.vni,\n\t\t\t\t\t\t      0, 1, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto free_tid;\n\n\t\t\tf->fs.val.ovlan = ret;\n\t\t\tf->fs.mask.ovlan = 0x1ff;\n\t\t\tf->fs.val.ovlan_vld = 1;\n\t\t\tf->fs.mask.ovlan_vld = 1;\n\t\t}\n\t}\n\n\t \n\tf->ctx = ctx;\n\tf->tid = fidx;  \n\tret = set_filter_wr(adapter, ftid);\n\tif (ret)\n\t\tgoto free_tid;\n\n\treturn ret;\n\nfree_tid:\n\tif (f->fs.prio)\n\t\tcxgb4_clear_hpftid(&adapter->tids, filter_id,\n\t\t\t\t   fs->type ? PF_INET6 : PF_INET);\n\telse\n\t\tcxgb4_clear_ftid(&adapter->tids, filter_id,\n\t\t\t\t fs->type ? PF_INET6 : PF_INET,\n\t\t\t\t chip_ver);\n\n\tclear_filter(adapter, f);\n\treturn ret;\n}\n\nstatic int cxgb4_del_hash_filter(struct net_device *dev, int filter_id,\n\t\t\t\t struct filter_ctx *ctx)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\tstruct tid_info *t = &adapter->tids;\n\tstruct cpl_abort_req *abort_req;\n\tstruct cpl_abort_rpl *abort_rpl;\n\tstruct cpl_set_tcb_field *req;\n\tstruct ulptx_idata *aligner;\n\tstruct work_request_hdr *wr;\n\tstruct filter_entry *f;\n\tstruct sk_buff *skb;\n\tunsigned int wrlen;\n\tint ret;\n\n\tnetdev_dbg(dev, \"%s: filter_id = %d ; nftids = %d\\n\",\n\t\t   __func__, filter_id, adapter->tids.nftids);\n\n\tif (tid_out_of_range(t, filter_id))\n\t\treturn -E2BIG;\n\n\tf = lookup_tid(t, filter_id);\n\tif (!f) {\n\t\tnetdev_err(dev, \"%s: no filter entry for filter_id = %d\",\n\t\t\t   __func__, filter_id);\n\t\treturn -EINVAL;\n\t}\n\n\tret = writable_filter(f);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!f->valid)\n\t\treturn -EINVAL;\n\n\tf->ctx = ctx;\n\tf->pending = 1;\n\twrlen = roundup(sizeof(*wr) + (sizeof(*req) + sizeof(*aligner))\n\t\t\t+ sizeof(*abort_req) + sizeof(*abort_rpl), 16);\n\tskb = alloc_skb(wrlen, GFP_KERNEL);\n\tif (!skb) {\n\t\tnetdev_err(dev, \"%s: could not allocate skb ..\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tset_wr_txq(skb, CPL_PRIORITY_CONTROL, f->fs.val.iport & 0x3);\n\treq = (struct cpl_set_tcb_field *)__skb_put(skb, wrlen);\n\tINIT_ULPTX_WR(req, wrlen, 0, 0);\n\twr = (struct work_request_hdr *)req;\n\twr++;\n\treq = (struct cpl_set_tcb_field *)wr;\n\tmk_set_tcb_ulp(f, req, TCB_RSS_INFO_W, TCB_RSS_INFO_V(TCB_RSS_INFO_M),\n\t\t       TCB_RSS_INFO_V(adapter->sge.fw_evtq.abs_id), 0, 1);\n\taligner = (struct ulptx_idata *)(req + 1);\n\tabort_req = (struct cpl_abort_req *)(aligner + 1);\n\tmk_abort_req_ulp(abort_req, f->tid);\n\tabort_rpl = (struct cpl_abort_rpl *)(abort_req + 1);\n\tmk_abort_rpl_ulp(abort_rpl, f->tid);\n\tt4_ofld_send(adapter, skb);\n\treturn 0;\n}\n\n \nint __cxgb4_del_filter(struct net_device *dev, int filter_id,\n\t\t       struct ch_filter_specification *fs,\n\t\t       struct filter_ctx *ctx)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\tunsigned int max_fidx, chip_ver;\n\tstruct filter_entry *f;\n\tint ret;\n\n\tchip_ver = CHELSIO_CHIP_VERSION(adapter->params.chip);\n\tif (fs && fs->hash) {\n\t\tif (is_hashfilter(adapter))\n\t\t\treturn cxgb4_del_hash_filter(dev, filter_id, ctx);\n\t\tnetdev_err(dev, \"%s: Exact-match filters only supported with Hash Filter configuration\\n\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmax_fidx = adapter->tids.nftids + adapter->tids.nhpftids;\n\tif (filter_id != (max_fidx + adapter->tids.nsftids - 1) &&\n\t    filter_id >= max_fidx)\n\t\treturn -E2BIG;\n\n\tif (filter_id < adapter->tids.nhpftids)\n\t\tf = &adapter->tids.hpftid_tab[filter_id];\n\telse\n\t\tf = &adapter->tids.ftid_tab[filter_id - adapter->tids.nhpftids];\n\n\tret = writable_filter(f);\n\tif (ret)\n\t\treturn ret;\n\n\tif (f->valid) {\n\t\tf->ctx = ctx;\n\t\tif (f->fs.prio)\n\t\t\tcxgb4_clear_hpftid(&adapter->tids,\n\t\t\t\t\t   f->tid - adapter->tids.hpftid_base,\n\t\t\t\t\t   f->fs.type ? PF_INET6 : PF_INET);\n\t\telse\n\t\t\tcxgb4_clear_ftid(&adapter->tids,\n\t\t\t\t\t f->tid - adapter->tids.ftid_base,\n\t\t\t\t\t f->fs.type ? PF_INET6 : PF_INET,\n\t\t\t\t\t chip_ver);\n\t\treturn del_filter_wr(adapter, filter_id);\n\t}\n\n\t \n\tif (ctx) {\n\t\tctx->result = 0;\n\t\tcomplete(&ctx->completion);\n\t}\n\treturn ret;\n}\n\nint cxgb4_set_filter(struct net_device *dev, int filter_id,\n\t\t     struct ch_filter_specification *fs)\n{\n\tstruct filter_ctx ctx;\n\tint ret;\n\n\tinit_completion(&ctx.completion);\n\n\tret = __cxgb4_set_filter(dev, filter_id, fs, &ctx);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = wait_for_completion_timeout(&ctx.completion, 10 * HZ);\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\tret = ctx.result;\nout:\n\treturn ret;\n}\n\nint cxgb4_del_filter(struct net_device *dev, int filter_id,\n\t\t     struct ch_filter_specification *fs)\n{\n\tstruct filter_ctx ctx;\n\tint ret;\n\n\tif (netdev2adap(dev)->flags & CXGB4_SHUTTING_DOWN)\n\t\treturn 0;\n\n\tinit_completion(&ctx.completion);\n\n\tret = __cxgb4_del_filter(dev, filter_id, fs, &ctx);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = wait_for_completion_timeout(&ctx.completion, 10 * HZ);\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\tret = ctx.result;\nout:\n\treturn ret;\n}\n\nstatic int configure_filter_tcb(struct adapter *adap, unsigned int tid,\n\t\t\t\tstruct filter_entry *f)\n{\n\tif (f->fs.hitcnts) {\n\t\tset_tcb_field(adap, f, tid, TCB_TIMESTAMP_W,\n\t\t\t      TCB_TIMESTAMP_V(TCB_TIMESTAMP_M),\n\t\t\t      TCB_TIMESTAMP_V(0ULL),\n\t\t\t      1);\n\t\tset_tcb_field(adap, f, tid, TCB_RTT_TS_RECENT_AGE_W,\n\t\t\t      TCB_RTT_TS_RECENT_AGE_V(TCB_RTT_TS_RECENT_AGE_M),\n\t\t\t      TCB_RTT_TS_RECENT_AGE_V(0ULL),\n\t\t\t      1);\n\t}\n\n\tif (f->fs.newdmac)\n\t\tset_tcb_tflag(adap, f, tid, TF_CCTRL_ECE_S, 1,\n\t\t\t      1);\n\n\tif (f->fs.newvlan == VLAN_INSERT ||\n\t    f->fs.newvlan == VLAN_REWRITE)\n\t\tset_tcb_tflag(adap, f, tid, TF_CCTRL_RFR_S, 1,\n\t\t\t      1);\n\tif (f->fs.newsmac)\n\t\tconfigure_filter_smac(adap, f);\n\n\tif (f->fs.nat_mode) {\n\t\tswitch (f->fs.nat_mode) {\n\t\tcase NAT_MODE_DIP:\n\t\t\tset_nat_params(adap, f, tid, true, false, false, false);\n\t\t\tbreak;\n\n\t\tcase NAT_MODE_DIP_DP:\n\t\t\tset_nat_params(adap, f, tid, true, false, true, false);\n\t\t\tbreak;\n\n\t\tcase NAT_MODE_DIP_DP_SIP:\n\t\t\tset_nat_params(adap, f, tid, true, true, true, false);\n\t\t\tbreak;\n\t\tcase NAT_MODE_DIP_DP_SP:\n\t\t\tset_nat_params(adap, f, tid, true, false, true, true);\n\t\t\tbreak;\n\n\t\tcase NAT_MODE_SIP_SP:\n\t\t\tset_nat_params(adap, f, tid, false, true, false, true);\n\t\t\tbreak;\n\n\t\tcase NAT_MODE_DIP_SIP_SP:\n\t\t\tset_nat_params(adap, f, tid, true, true, false, true);\n\t\t\tbreak;\n\n\t\tcase NAT_MODE_ALL:\n\t\t\tset_nat_params(adap, f, tid, true, true, true, true);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"%s: Invalid NAT mode: %d\\n\",\n\t\t\t       __func__, f->fs.nat_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid hash_del_filter_rpl(struct adapter *adap,\n\t\t\t const struct cpl_abort_rpl_rss *rpl)\n{\n\tunsigned int status = rpl->status;\n\tstruct tid_info *t = &adap->tids;\n\tunsigned int tid = GET_TID(rpl);\n\tstruct filter_ctx *ctx = NULL;\n\tstruct filter_entry *f;\n\n\tdev_dbg(adap->pdev_dev, \"%s: status = %u; tid = %u\\n\",\n\t\t__func__, status, tid);\n\n\tf = lookup_tid(t, tid);\n\tif (!f) {\n\t\tdev_err(adap->pdev_dev, \"%s:could not find filter entry\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\tctx = f->ctx;\n\tf->ctx = NULL;\n\tclear_filter(adap, f);\n\tcxgb4_remove_tid(t, 0, tid, 0);\n\tkfree(f);\n\tif (ctx) {\n\t\tctx->result = 0;\n\t\tcomplete(&ctx->completion);\n\t}\n}\n\nvoid hash_filter_rpl(struct adapter *adap, const struct cpl_act_open_rpl *rpl)\n{\n\tunsigned int ftid = TID_TID_G(AOPEN_ATID_G(ntohl(rpl->atid_status)));\n\tunsigned int status  = AOPEN_STATUS_G(ntohl(rpl->atid_status));\n\tstruct tid_info *t = &adap->tids;\n\tunsigned int tid = GET_TID(rpl);\n\tstruct filter_ctx *ctx = NULL;\n\tstruct filter_entry *f;\n\n\tdev_dbg(adap->pdev_dev, \"%s: tid = %u; atid = %u; status = %u\\n\",\n\t\t__func__, tid, ftid, status);\n\n\tf = lookup_atid(t, ftid);\n\tif (!f) {\n\t\tdev_err(adap->pdev_dev, \"%s:could not find filter entry\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\tctx = f->ctx;\n\tf->ctx = NULL;\n\n\tswitch (status) {\n\tcase CPL_ERR_NONE:\n\t\tf->tid = tid;\n\t\tf->pending = 0;\n\t\tf->valid = 1;\n\t\tcxgb4_insert_tid(t, f, f->tid, 0);\n\t\tcxgb4_free_atid(t, ftid);\n\t\tif (ctx) {\n\t\t\tctx->tid = f->tid;\n\t\t\tctx->result = 0;\n\t\t}\n\t\tif (configure_filter_tcb(adap, tid, f)) {\n\t\t\tclear_filter(adap, f);\n\t\t\tcxgb4_remove_tid(t, 0, tid, 0);\n\t\t\tkfree(f);\n\t\t\tif (ctx) {\n\t\t\t\tctx->result = -EINVAL;\n\t\t\t\tcomplete(&ctx->completion);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tswitch (f->fs.action) {\n\t\tcase FILTER_PASS:\n\t\t\tif (f->fs.dirsteer)\n\t\t\t\tset_tcb_tflag(adap, f, tid,\n\t\t\t\t\t      TF_DIRECT_STEER_S, 1, 1);\n\t\t\tbreak;\n\t\tcase FILTER_DROP:\n\t\t\tset_tcb_tflag(adap, f, tid, TF_DROP_S, 1, 1);\n\t\t\tbreak;\n\t\tcase FILTER_SWITCH:\n\t\t\tset_tcb_tflag(adap, f, tid, TF_LPBK_S, 1, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\tif (status != CPL_ERR_TCAM_FULL)\n\t\t\tdev_err(adap->pdev_dev, \"%s: filter creation PROBLEM; status = %u\\n\",\n\t\t\t\t__func__, status);\n\n\t\tif (ctx) {\n\t\t\tif (status == CPL_ERR_TCAM_FULL)\n\t\t\t\tctx->result = -ENOSPC;\n\t\t\telse\n\t\t\t\tctx->result = -EINVAL;\n\t\t}\n\t\tclear_filter(adap, f);\n\t\tcxgb4_free_atid(t, ftid);\n\t\tkfree(f);\n\t}\n\tif (ctx)\n\t\tcomplete(&ctx->completion);\n}\n\n \nvoid filter_rpl(struct adapter *adap, const struct cpl_set_tcb_rpl *rpl)\n{\n\tunsigned int tid = GET_TID(rpl);\n\tstruct filter_entry *f = NULL;\n\tunsigned int max_fidx;\n\tint idx;\n\n\tmax_fidx = adap->tids.nftids + adap->tids.nsftids;\n\t \n\tif (adap->tids.ftid_tab) {\n\t\tidx = tid - adap->tids.hpftid_base;\n\t\tif (idx < adap->tids.nhpftids) {\n\t\t\tf = &adap->tids.hpftid_tab[idx];\n\t\t} else {\n\t\t\t \n\t\t\tidx = tid - adap->tids.ftid_base;\n\t\t\tif (idx >= max_fidx)\n\t\t\t\treturn;\n\t\t\tf = &adap->tids.ftid_tab[idx];\n\t\t\tidx += adap->tids.nhpftids;\n\t\t}\n\n\t\tif (f->tid != tid)\n\t\t\treturn;\n\t}\n\n\t \n\tif (f) {\n\t\tunsigned int ret = TCB_COOKIE_G(rpl->cookie);\n\t\tstruct filter_ctx *ctx;\n\n\t\t \n\t\tctx = f->ctx;\n\t\tf->ctx = NULL;\n\n\t\tif (ret == FW_FILTER_WR_FLT_DELETED) {\n\t\t\t \n\t\t\tclear_filter(adap, f);\n\t\t\tif (ctx)\n\t\t\t\tctx->result = 0;\n\t\t} else if (ret == FW_FILTER_WR_FLT_ADDED) {\n\t\t\tf->pending = 0;   \n\t\t\tf->valid = 1;\n\t\t\tif (ctx) {\n\t\t\t\tctx->result = 0;\n\t\t\t\tctx->tid = idx;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdev_err(adap->pdev_dev, \"filter %u setup failed with error %u\\n\",\n\t\t\t\tidx, ret);\n\t\t\tclear_filter(adap, f);\n\t\t\tif (ctx)\n\t\t\t\tctx->result = -EINVAL;\n\t\t}\n\t\tif (ctx)\n\t\t\tcomplete(&ctx->completion);\n\t}\n}\n\nvoid init_hash_filter(struct adapter *adap)\n{\n\tu32 reg;\n\n\t \n\tif (is_t6(adap->params.chip)) {\n\t\tif (is_offload(adap)) {\n\t\t\tif (!(t4_read_reg(adap, TP_GLOBAL_CONFIG_A)\n\t\t\t   & ACTIVEFILTERCOUNTS_F)) {\n\t\t\t\tdev_err(adap->pdev_dev, \"Invalid hash filter + ofld config\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treg = t4_read_reg(adap, LE_DB_RSP_CODE_0_A);\n\t\t\tif (TCAM_ACTV_HIT_G(reg) != 4) {\n\t\t\t\tdev_err(adap->pdev_dev, \"Invalid hash filter config\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treg = t4_read_reg(adap, LE_DB_RSP_CODE_1_A);\n\t\t\tif (HASH_ACTV_HIT_G(reg) != 4) {\n\t\t\t\tdev_err(adap->pdev_dev, \"Invalid hash filter config\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tdev_err(adap->pdev_dev, \"Hash filter supported only on T6\\n\");\n\t\treturn;\n\t}\n\n\tadap->params.hash_filter = 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}