{
  "module_name": "smt.c",
  "hash_id": "19fc66d02246af99a575f80d96bcb8ddb37d5e4175719ccb814c40a99fc6af0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/smt.c",
  "human_readable_source": " \n\n#include \"cxgb4.h\"\n#include \"smt.h\"\n#include \"t4_msg.h\"\n#include \"t4fw_api.h\"\n#include \"t4_regs.h\"\n#include \"t4_values.h\"\n\nstruct smt_data *t4_init_smt(void)\n{\n\tunsigned int smt_size;\n\tstruct smt_data *s;\n\tint i;\n\n\tsmt_size = SMT_SIZE;\n\n\ts = kvzalloc(struct_size(s, smtab, smt_size), GFP_KERNEL);\n\tif (!s)\n\t\treturn NULL;\n\ts->smt_size = smt_size;\n\trwlock_init(&s->lock);\n\tfor (i = 0; i < s->smt_size; ++i) {\n\t\ts->smtab[i].idx = i;\n\t\ts->smtab[i].state = SMT_STATE_UNUSED;\n\t\teth_zero_addr(s->smtab[i].src_mac);\n\t\tspin_lock_init(&s->smtab[i].lock);\n\t\ts->smtab[i].refcnt = 0;\n\t}\n\treturn s;\n}\n\nstatic struct smt_entry *find_or_alloc_smte(struct smt_data *s, u8 *smac)\n{\n\tstruct smt_entry *first_free = NULL;\n\tstruct smt_entry *e, *end;\n\n\tfor (e = &s->smtab[0], end = &s->smtab[s->smt_size]; e != end; ++e) {\n\t\tif (e->refcnt == 0) {\n\t\t\tif (!first_free)\n\t\t\t\tfirst_free = e;\n\t\t} else {\n\t\t\tif (e->state == SMT_STATE_SWITCHING) {\n\t\t\t\t \n\t\t\t\tif (memcmp(e->src_mac, smac, ETH_ALEN) == 0)\n\t\t\t\t\tgoto found_reuse;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (first_free) {\n\t\te = first_free;\n\t\tgoto found;\n\t}\n\treturn NULL;\n\nfound:\n\te->state = SMT_STATE_UNUSED;\n\nfound_reuse:\n\treturn e;\n}\n\nstatic void t4_smte_free(struct smt_entry *e)\n{\n\tif (e->refcnt == 0) {   \n\t\te->state = SMT_STATE_UNUSED;\n\t}\n}\n\n \nvoid cxgb4_smt_release(struct smt_entry *e)\n{\n\tspin_lock_bh(&e->lock);\n\tif ((--e->refcnt) == 0)\n\t\tt4_smte_free(e);\n\tspin_unlock_bh(&e->lock);\n}\nEXPORT_SYMBOL(cxgb4_smt_release);\n\nvoid do_smt_write_rpl(struct adapter *adap, const struct cpl_smt_write_rpl *rpl)\n{\n\tunsigned int smtidx = TID_TID_G(GET_TID(rpl));\n\tstruct smt_data *s = adap->smt;\n\n\tif (unlikely(rpl->status != CPL_ERR_NONE)) {\n\t\tstruct smt_entry *e = &s->smtab[smtidx];\n\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Unexpected SMT_WRITE_RPL status %u for entry %u\\n\",\n\t\t\trpl->status, smtidx);\n\t\tspin_lock(&e->lock);\n\t\te->state = SMT_STATE_ERROR;\n\t\tspin_unlock(&e->lock);\n\t\treturn;\n\t}\n}\n\nstatic int write_smt_entry(struct adapter *adapter, struct smt_entry *e)\n{\n\tstruct cpl_t6_smt_write_req *t6req;\n\tstruct smt_data *s = adapter->smt;\n\tstruct cpl_smt_write_req *req;\n\tstruct sk_buff *skb;\n\tint size;\n\tu8 row;\n\n\tif (CHELSIO_CHIP_VERSION(adapter->params.chip) <= CHELSIO_T5) {\n\t\tsize = sizeof(*req);\n\t\tskb = alloc_skb(size, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\treq = (struct cpl_smt_write_req *)__skb_put(skb, size);\n\t\tINIT_TP_WR(req, 0);\n\n\t\t \n\t\trow = (e->idx >> 1);\n\t\tif (e->idx & 1) {\n\t\t\treq->pfvf1 = 0x0;\n\t\t\tmemcpy(req->src_mac1, e->src_mac, ETH_ALEN);\n\n\t\t\t \n\t\t\treq->pfvf0 = 0x0;\n\t\t\tmemcpy(req->src_mac0, s->smtab[e->idx - 1].src_mac,\n\t\t\t       ETH_ALEN);\n\t\t} else {\n\t\t\treq->pfvf0 = 0x0;\n\t\t\tmemcpy(req->src_mac0, e->src_mac, ETH_ALEN);\n\n\t\t\t \n\t\t\treq->pfvf1 = 0x0;\n\t\t\tmemcpy(req->src_mac1, s->smtab[e->idx + 1].src_mac,\n\t\t\t       ETH_ALEN);\n\t\t}\n\t} else {\n\t\tsize = sizeof(*t6req);\n\t\tskb = alloc_skb(size, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\tt6req = (struct cpl_t6_smt_write_req *)__skb_put(skb, size);\n\t\tINIT_TP_WR(t6req, 0);\n\t\treq = (struct cpl_smt_write_req *)t6req;\n\n\t\t \n\t\treq->pfvf0 = 0x0;\n\t\tmemcpy(req->src_mac0, s->smtab[e->idx].src_mac, ETH_ALEN);\n\t\trow = e->idx;\n\t}\n\n\tOPCODE_TID(req) =\n\t\thtonl(MK_OPCODE_TID(CPL_SMT_WRITE_REQ, e->idx |\n\t\t\t\t    TID_QID_V(adapter->sge.fw_evtq.abs_id)));\n\treq->params = htonl(SMTW_NORPL_V(0) |\n\t\t\t    SMTW_IDX_V(row) |\n\t\t\t    SMTW_OVLAN_IDX_V(0));\n\tt4_mgmt_tx(adapter, skb);\n\treturn 0;\n}\n\nstatic struct smt_entry *t4_smt_alloc_switching(struct adapter *adap, u16 pfvf,\n\t\t\t\t\t\tu8 *smac)\n{\n\tstruct smt_data *s = adap->smt;\n\tstruct smt_entry *e;\n\n\twrite_lock_bh(&s->lock);\n\te = find_or_alloc_smte(s, smac);\n\tif (e) {\n\t\tspin_lock(&e->lock);\n\t\tif (!e->refcnt) {\n\t\t\te->refcnt = 1;\n\t\t\te->state = SMT_STATE_SWITCHING;\n\t\t\te->pfvf = pfvf;\n\t\t\tmemcpy(e->src_mac, smac, ETH_ALEN);\n\t\t\twrite_smt_entry(adap, e);\n\t\t} else {\n\t\t\t++e->refcnt;\n\t\t}\n\t\tspin_unlock(&e->lock);\n\t}\n\twrite_unlock_bh(&s->lock);\n\treturn e;\n}\n\n \nstruct smt_entry *cxgb4_smt_alloc_switching(struct net_device *dev, u8 *smac)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\n\treturn t4_smt_alloc_switching(adap, 0x0, smac);\n}\nEXPORT_SYMBOL(cxgb4_smt_alloc_switching);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}