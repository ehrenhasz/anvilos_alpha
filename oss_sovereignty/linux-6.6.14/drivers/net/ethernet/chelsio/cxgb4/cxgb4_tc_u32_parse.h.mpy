{
  "module_name": "cxgb4_tc_u32_parse.h",
  "hash_id": "848e5ed11c8525b8032c03b88cb8ac6d9426d89f606b1efc6598746258dca9a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_u32_parse.h",
  "human_readable_source": " \n\n#ifndef __CXGB4_TC_U32_PARSE_H\n#define __CXGB4_TC_U32_PARSE_H\n\nstruct cxgb4_match_field {\n\tint off;  \n\t \n\tint (*val)(struct ch_filter_specification *f, __be32 val, __be32 mask);\n};\n\n \nstatic inline int cxgb4_fill_ipv4_tos(struct ch_filter_specification *f,\n\t\t\t\t      __be32 val, __be32 mask)\n{\n\tf->val.tos  = (ntohl(val)  >> 16) & 0x000000FF;\n\tf->mask.tos = (ntohl(mask) >> 16) & 0x000000FF;\n\n\treturn 0;\n}\n\nstatic inline int cxgb4_fill_ipv4_frag(struct ch_filter_specification *f,\n\t\t\t\t       __be32 val, __be32 mask)\n{\n\tu32 mask_val;\n\tu8 frag_val;\n\n\tfrag_val = (ntohl(val) >> 13) & 0x00000007;\n\tmask_val = ntohl(mask) & 0x0000FFFF;\n\n\tif (frag_val == 0x1 && mask_val != 0x3FFF) {  \n\t\tf->val.frag = 1;\n\t\tf->mask.frag = 1;\n\t} else if (frag_val == 0x2 && mask_val != 0x3FFF) {  \n\t\tf->val.frag = 0;\n\t\tf->mask.frag = 1;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int cxgb4_fill_ipv4_proto(struct ch_filter_specification *f,\n\t\t\t\t\t__be32 val, __be32 mask)\n{\n\tf->val.proto  = (ntohl(val)  >> 16) & 0x000000FF;\n\tf->mask.proto = (ntohl(mask) >> 16) & 0x000000FF;\n\n\treturn 0;\n}\n\nstatic inline int cxgb4_fill_ipv4_src_ip(struct ch_filter_specification *f,\n\t\t\t\t\t __be32 val, __be32 mask)\n{\n\tmemcpy(&f->val.fip[0],  &val,  sizeof(u32));\n\tmemcpy(&f->mask.fip[0], &mask, sizeof(u32));\n\n\treturn 0;\n}\n\nstatic inline int cxgb4_fill_ipv4_dst_ip(struct ch_filter_specification *f,\n\t\t\t\t\t __be32 val, __be32 mask)\n{\n\tmemcpy(&f->val.lip[0],  &val,  sizeof(u32));\n\tmemcpy(&f->mask.lip[0], &mask, sizeof(u32));\n\n\treturn 0;\n}\n\nstatic const struct cxgb4_match_field cxgb4_ipv4_fields[] = {\n\t{ .off = 0,  .val = cxgb4_fill_ipv4_tos },\n\t{ .off = 4,  .val = cxgb4_fill_ipv4_frag },\n\t{ .off = 8,  .val = cxgb4_fill_ipv4_proto },\n\t{ .off = 12, .val = cxgb4_fill_ipv4_src_ip },\n\t{ .off = 16, .val = cxgb4_fill_ipv4_dst_ip },\n\t{ .val = NULL }\n};\n\n \nstatic inline int cxgb4_fill_ipv6_tos(struct ch_filter_specification *f,\n\t\t\t\t      __be32 val, __be32 mask)\n{\n\tf->val.tos  = (ntohl(val)  >> 20) & 0x000000FF;\n\tf->mask.tos = (ntohl(mask) >> 20) & 0x000000FF;\n\n\treturn 0;\n}\n\nstatic inline int cxgb4_fill_ipv6_proto(struct ch_filter_specification *f,\n\t\t\t\t\t__be32 val, __be32 mask)\n{\n\tf->val.proto  = (ntohl(val)  >> 8) & 0x000000FF;\n\tf->mask.proto = (ntohl(mask) >> 8) & 0x000000FF;\n\n\treturn 0;\n}\n\nstatic inline int cxgb4_fill_ipv6_src_ip0(struct ch_filter_specification *f,\n\t\t\t\t\t  __be32 val, __be32 mask)\n{\n\tmemcpy(&f->val.fip[0],  &val,  sizeof(u32));\n\tmemcpy(&f->mask.fip[0], &mask, sizeof(u32));\n\n\treturn 0;\n}\n\nstatic inline int cxgb4_fill_ipv6_src_ip1(struct ch_filter_specification *f,\n\t\t\t\t\t  __be32 val, __be32 mask)\n{\n\tmemcpy(&f->val.fip[4],  &val,  sizeof(u32));\n\tmemcpy(&f->mask.fip[4], &mask, sizeof(u32));\n\n\treturn 0;\n}\n\nstatic inline int cxgb4_fill_ipv6_src_ip2(struct ch_filter_specification *f,\n\t\t\t\t\t  __be32 val, __be32 mask)\n{\n\tmemcpy(&f->val.fip[8],  &val,  sizeof(u32));\n\tmemcpy(&f->mask.fip[8], &mask, sizeof(u32));\n\n\treturn 0;\n}\n\nstatic inline int cxgb4_fill_ipv6_src_ip3(struct ch_filter_specification *f,\n\t\t\t\t\t  __be32 val, __be32 mask)\n{\n\tmemcpy(&f->val.fip[12],  &val,  sizeof(u32));\n\tmemcpy(&f->mask.fip[12], &mask, sizeof(u32));\n\n\treturn 0;\n}\n\nstatic inline int cxgb4_fill_ipv6_dst_ip0(struct ch_filter_specification *f,\n\t\t\t\t\t  __be32 val, __be32 mask)\n{\n\tmemcpy(&f->val.lip[0],  &val,  sizeof(u32));\n\tmemcpy(&f->mask.lip[0], &mask, sizeof(u32));\n\n\treturn 0;\n}\n\nstatic inline int cxgb4_fill_ipv6_dst_ip1(struct ch_filter_specification *f,\n\t\t\t\t\t  __be32 val, __be32 mask)\n{\n\tmemcpy(&f->val.lip[4],  &val,  sizeof(u32));\n\tmemcpy(&f->mask.lip[4], &mask, sizeof(u32));\n\n\treturn 0;\n}\n\nstatic inline int cxgb4_fill_ipv6_dst_ip2(struct ch_filter_specification *f,\n\t\t\t\t\t  __be32 val, __be32 mask)\n{\n\tmemcpy(&f->val.lip[8],  &val,  sizeof(u32));\n\tmemcpy(&f->mask.lip[8], &mask, sizeof(u32));\n\n\treturn 0;\n}\n\nstatic inline int cxgb4_fill_ipv6_dst_ip3(struct ch_filter_specification *f,\n\t\t\t\t\t  __be32 val, __be32 mask)\n{\n\tmemcpy(&f->val.lip[12],  &val,  sizeof(u32));\n\tmemcpy(&f->mask.lip[12], &mask, sizeof(u32));\n\n\treturn 0;\n}\n\nstatic const struct cxgb4_match_field cxgb4_ipv6_fields[] = {\n\t{ .off = 0,  .val = cxgb4_fill_ipv6_tos },\n\t{ .off = 4,  .val = cxgb4_fill_ipv6_proto },\n\t{ .off = 8,  .val = cxgb4_fill_ipv6_src_ip0 },\n\t{ .off = 12, .val = cxgb4_fill_ipv6_src_ip1 },\n\t{ .off = 16, .val = cxgb4_fill_ipv6_src_ip2 },\n\t{ .off = 20, .val = cxgb4_fill_ipv6_src_ip3 },\n\t{ .off = 24, .val = cxgb4_fill_ipv6_dst_ip0 },\n\t{ .off = 28, .val = cxgb4_fill_ipv6_dst_ip1 },\n\t{ .off = 32, .val = cxgb4_fill_ipv6_dst_ip2 },\n\t{ .off = 36, .val = cxgb4_fill_ipv6_dst_ip3 },\n\t{ .val = NULL }\n};\n\n \nstatic inline int cxgb4_fill_l4_ports(struct ch_filter_specification *f,\n\t\t\t\t      __be32 val, __be32 mask)\n{\n\tf->val.fport  = ntohl(val)  >> 16;\n\tf->mask.fport = ntohl(mask) >> 16;\n\tf->val.lport  = ntohl(val)  & 0x0000FFFF;\n\tf->mask.lport = ntohl(mask) & 0x0000FFFF;\n\n\treturn 0;\n};\n\nstatic const struct cxgb4_match_field cxgb4_tcp_fields[] = {\n\t{ .off = 0, .val = cxgb4_fill_l4_ports },\n\t{ .val = NULL }\n};\n\nstatic const struct cxgb4_match_field cxgb4_udp_fields[] = {\n\t{ .off = 0, .val = cxgb4_fill_l4_ports },\n\t{ .val = NULL }\n};\n\nstruct cxgb4_next_header {\n\t \n\tstruct tc_u32_sel sel;\n\tstruct tc_u32_key key;\n\t \n\tconst struct cxgb4_match_field *jump;\n};\n\n \nstatic const struct cxgb4_next_header cxgb4_ipv4_jumps[] = {\n\t{\n\t\t \n\t\t.sel = {\n\t\t\t.off = 0,\n\t\t\t.offoff = 0,\n\t\t\t.offshift = 6,\n\t\t\t.offmask = cpu_to_be16(0x0f00),\n\t\t},\n\t\t.key = {\n\t\t\t.off = 8,\n\t\t\t.val = cpu_to_be32(0x00060000),\n\t\t\t.mask = cpu_to_be32(0x00ff0000),\n\t\t},\n\t\t.jump = cxgb4_tcp_fields,\n\t},\n\t{\n\t\t \n\t\t.sel = {\n\t\t\t.off = 0,\n\t\t\t.offoff = 0,\n\t\t\t.offshift = 6,\n\t\t\t.offmask = cpu_to_be16(0x0f00),\n\t\t},\n\t\t.key = {\n\t\t\t.off = 8,\n\t\t\t.val = cpu_to_be32(0x00110000),\n\t\t\t.mask = cpu_to_be32(0x00ff0000),\n\t\t},\n\t\t.jump = cxgb4_udp_fields,\n\t},\n\t{ .jump = NULL },\n};\n\n \nstatic const struct cxgb4_next_header cxgb4_ipv6_jumps[] = {\n\t{\n\t\t \n\t\t.sel = {\n\t\t\t.off = 40,\n\t\t\t.offoff = 0,\n\t\t\t.offshift = 0,\n\t\t\t.offmask = 0,\n\t\t},\n\t\t.key = {\n\t\t\t.off = 4,\n\t\t\t.val = cpu_to_be32(0x00000600),\n\t\t\t.mask = cpu_to_be32(0x0000ff00),\n\t\t},\n\t\t.jump = cxgb4_tcp_fields,\n\t},\n\t{\n\t\t \n\t\t.sel = {\n\t\t\t.off = 40,\n\t\t\t.offoff = 0,\n\t\t\t.offshift = 0,\n\t\t\t.offmask = 0,\n\t\t},\n\t\t.key = {\n\t\t\t.off = 4,\n\t\t\t.val = cpu_to_be32(0x00001100),\n\t\t\t.mask = cpu_to_be32(0x0000ff00),\n\t\t},\n\t\t.jump = cxgb4_udp_fields,\n\t},\n\t{ .jump = NULL },\n};\n\nstruct cxgb4_link {\n\tconst struct cxgb4_match_field *match_field;   \n\tstruct ch_filter_specification fs;  \n\tu32 link_handle;          \n\tunsigned long *tid_map;   \n};\n\nstruct cxgb4_tc_u32_table {\n\tunsigned int size;           \n\tstruct cxgb4_link table[];  \n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}