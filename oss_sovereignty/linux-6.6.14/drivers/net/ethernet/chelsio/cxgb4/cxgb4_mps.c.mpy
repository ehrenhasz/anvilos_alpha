{
  "module_name": "cxgb4_mps.c",
  "hash_id": "28aa9c7309c460049d9501e8644c8913470d8539a8c3ee9de69f4b3dd45b37b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/cxgb4_mps.c",
  "human_readable_source": "\n \n\n#include \"cxgb4.h\"\n\nstatic int cxgb4_mps_ref_dec_by_mac(struct adapter *adap,\n\t\t\t\t    const u8 *addr, const u8 *mask)\n{\n\tu8 bitmask[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\tstruct mps_entries_ref *mps_entry, *tmp;\n\tint ret = -EINVAL;\n\n\tspin_lock_bh(&adap->mps_ref_lock);\n\tlist_for_each_entry_safe(mps_entry, tmp, &adap->mps_ref, list) {\n\t\tif (ether_addr_equal(mps_entry->addr, addr) &&\n\t\t    ether_addr_equal(mps_entry->mask, mask ? mask : bitmask)) {\n\t\t\tif (!refcount_dec_and_test(&mps_entry->refcnt)) {\n\t\t\t\tspin_unlock_bh(&adap->mps_ref_lock);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tlist_del(&mps_entry->list);\n\t\t\tkfree(mps_entry);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&adap->mps_ref_lock);\n\treturn ret;\n}\n\nstatic int cxgb4_mps_ref_dec(struct adapter *adap, u16 idx)\n{\n\tstruct mps_entries_ref *mps_entry, *tmp;\n\tint ret = -EINVAL;\n\n\tspin_lock(&adap->mps_ref_lock);\n\tlist_for_each_entry_safe(mps_entry, tmp, &adap->mps_ref, list) {\n\t\tif (mps_entry->idx == idx) {\n\t\t\tif (!refcount_dec_and_test(&mps_entry->refcnt)) {\n\t\t\t\tspin_unlock(&adap->mps_ref_lock);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tlist_del(&mps_entry->list);\n\t\t\tkfree(mps_entry);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&adap->mps_ref_lock);\n\treturn ret;\n}\n\nstatic int cxgb4_mps_ref_inc(struct adapter *adap, const u8 *mac_addr,\n\t\t\t     u16 idx, const u8 *mask)\n{\n\tu8 bitmask[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\tstruct mps_entries_ref *mps_entry;\n\tint ret = 0;\n\n\tspin_lock_bh(&adap->mps_ref_lock);\n\tlist_for_each_entry(mps_entry, &adap->mps_ref, list) {\n\t\tif (mps_entry->idx == idx) {\n\t\t\trefcount_inc(&mps_entry->refcnt);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tmps_entry = kzalloc(sizeof(*mps_entry), GFP_ATOMIC);\n\tif (!mps_entry) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tether_addr_copy(mps_entry->mask, mask ? mask : bitmask);\n\tether_addr_copy(mps_entry->addr, mac_addr);\n\tmps_entry->idx = idx;\n\trefcount_set(&mps_entry->refcnt, 1);\n\tlist_add_tail(&mps_entry->list, &adap->mps_ref);\nunlock:\n\tspin_unlock_bh(&adap->mps_ref_lock);\n\treturn ret;\n}\n\nint cxgb4_free_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\tunsigned int naddr, const u8 **addr, bool sleep_ok)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < naddr; i++) {\n\t\tif (!cxgb4_mps_ref_dec_by_mac(adap, addr[i], NULL)) {\n\t\t\tret = t4_free_mac_filt(adap, adap->mbox, viid,\n\t\t\t\t\t       1, &addr[i], sleep_ok);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\treturn naddr;\n}\n\nint cxgb4_alloc_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\t bool free, unsigned int naddr, const u8 **addr,\n\t\t\t u16 *idx, u64 *hash, bool sleep_ok)\n{\n\tint ret, i;\n\n\tret = t4_alloc_mac_filt(adap, adap->mbox, viid, free,\n\t\t\t\tnaddr, addr, idx, hash, sleep_ok);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < naddr; i++) {\n\t\tif (idx[i] != 0xffff) {\n\t\t\tif (cxgb4_mps_ref_inc(adap, addr[i], idx[i], NULL)) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tgoto out;\nerror:\n\tcxgb4_free_mac_filt(adap, viid, naddr, addr, sleep_ok);\n\nout:\n\t \n\treturn ret;\n}\n\nint cxgb4_update_mac_filt(struct port_info *pi, unsigned int viid,\n\t\t\t  int *tcam_idx, const u8 *addr,\n\t\t\t  bool persistent, u8 *smt_idx)\n{\n\tint ret;\n\n\tret = cxgb4_change_mac(pi, viid, tcam_idx,\n\t\t\t       addr, persistent, smt_idx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcxgb4_mps_ref_inc(pi->adapter, addr, *tcam_idx, NULL);\n\treturn ret;\n}\n\nint cxgb4_free_raw_mac_filt(struct adapter *adap,\n\t\t\t    unsigned int viid,\n\t\t\t    const u8 *addr,\n\t\t\t    const u8 *mask,\n\t\t\t    unsigned int idx,\n\t\t\t    u8 lookup_type,\n\t\t\t    u8 port_id,\n\t\t\t    bool sleep_ok)\n{\n\tint ret = 0;\n\n\tif (!cxgb4_mps_ref_dec(adap, idx))\n\t\tret = t4_free_raw_mac_filt(adap, viid, addr,\n\t\t\t\t\t   mask, idx, lookup_type,\n\t\t\t\t\t   port_id, sleep_ok);\n\n\treturn ret;\n}\n\nint cxgb4_alloc_raw_mac_filt(struct adapter *adap,\n\t\t\t     unsigned int viid,\n\t\t\t     const u8 *addr,\n\t\t\t     const u8 *mask,\n\t\t\t     unsigned int idx,\n\t\t\t     u8 lookup_type,\n\t\t\t     u8 port_id,\n\t\t\t     bool sleep_ok)\n{\n\tint ret;\n\n\tret = t4_alloc_raw_mac_filt(adap, viid, addr,\n\t\t\t\t    mask, idx, lookup_type,\n\t\t\t\t    port_id, sleep_ok);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cxgb4_mps_ref_inc(adap, addr, ret, mask)) {\n\t\tret = -ENOMEM;\n\t\tt4_free_raw_mac_filt(adap, viid, addr,\n\t\t\t\t     mask, idx, lookup_type,\n\t\t\t\t     port_id, sleep_ok);\n\t}\n\n\treturn ret;\n}\n\nint cxgb4_free_encap_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\t      int idx, bool sleep_ok)\n{\n\tint ret = 0;\n\n\tif (!cxgb4_mps_ref_dec(adap, idx))\n\t\tret = t4_free_encap_mac_filt(adap, viid, idx, sleep_ok);\n\n\treturn ret;\n}\n\nint cxgb4_alloc_encap_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\t       const u8 *addr, const u8 *mask,\n\t\t\t       unsigned int vni, unsigned int vni_mask,\n\t\t\t       u8 dip_hit, u8 lookup_type, bool sleep_ok)\n{\n\tint ret;\n\n\tret = t4_alloc_encap_mac_filt(adap, viid, addr, mask, vni, vni_mask,\n\t\t\t\t      dip_hit, lookup_type, sleep_ok);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cxgb4_mps_ref_inc(adap, addr, ret, mask)) {\n\t\tret = -ENOMEM;\n\t\tt4_free_encap_mac_filt(adap, viid, ret, sleep_ok);\n\t}\n\treturn ret;\n}\n\nint cxgb4_init_mps_ref_entries(struct adapter *adap)\n{\n\tspin_lock_init(&adap->mps_ref_lock);\n\tINIT_LIST_HEAD(&adap->mps_ref);\n\n\treturn 0;\n}\n\nvoid cxgb4_free_mps_ref_entries(struct adapter *adap)\n{\n\tstruct mps_entries_ref *mps_entry, *tmp;\n\n\tif (list_empty(&adap->mps_ref))\n\t\treturn;\n\n\tspin_lock(&adap->mps_ref_lock);\n\tlist_for_each_entry_safe(mps_entry, tmp, &adap->mps_ref, list) {\n\t\tlist_del(&mps_entry->list);\n\t\tkfree(mps_entry);\n\t}\n\tspin_unlock(&adap->mps_ref_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}