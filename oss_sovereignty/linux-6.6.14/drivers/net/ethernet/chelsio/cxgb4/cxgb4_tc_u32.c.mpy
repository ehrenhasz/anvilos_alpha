{
  "module_name": "cxgb4_tc_u32.c",
  "hash_id": "eb80c14f5f7820e895edd9e35fb7701ecad83aeba41a5b0e688019b4629e4f7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_u32.c",
  "human_readable_source": " \n\n#include <net/tc_act/tc_gact.h>\n#include <net/tc_act/tc_mirred.h>\n\n#include \"cxgb4.h\"\n#include \"cxgb4_filter.h\"\n#include \"cxgb4_tc_u32_parse.h\"\n#include \"cxgb4_tc_u32.h\"\n\n \nstatic int fill_match_fields(struct adapter *adap,\n\t\t\t     struct ch_filter_specification *fs,\n\t\t\t     struct tc_cls_u32_offload *cls,\n\t\t\t     const struct cxgb4_match_field *entry,\n\t\t\t     bool next_header)\n{\n\tunsigned int i, j;\n\t__be32 val, mask;\n\tint off, err;\n\tbool found;\n\n\tfor (i = 0; i < cls->knode.sel->nkeys; i++) {\n\t\toff = cls->knode.sel->keys[i].off;\n\t\tval = cls->knode.sel->keys[i].val;\n\t\tmask = cls->knode.sel->keys[i].mask;\n\n\t\tif (next_header) {\n\t\t\t \n\t\t\tif (!cls->knode.sel->keys[i].offmask)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t \n\t\t\tif (cls->knode.sel->keys[i].offmask)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tfound = false;\n\n\t\tfor (j = 0; entry[j].val; j++) {\n\t\t\tif (off == entry[j].off) {\n\t\t\t\tfound = true;\n\t\t\t\terr = entry[j].val(fs, val, mask);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fill_action_fields(struct adapter *adap,\n\t\t\t      struct ch_filter_specification *fs,\n\t\t\t      struct tc_cls_u32_offload *cls)\n{\n\tunsigned int num_actions = 0;\n\tconst struct tc_action *a;\n\tstruct tcf_exts *exts;\n\tint i;\n\n\texts = cls->knode.exts;\n\tif (!tcf_exts_has_actions(exts))\n\t\treturn -EINVAL;\n\n\ttcf_exts_for_each_action(i, a, exts) {\n\t\t \n\t\tif (num_actions)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (is_tcf_gact_shot(a)) {\n\t\t\tfs->action = FILTER_DROP;\n\t\t\tnum_actions++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (is_tcf_mirred_egress_redirect(a)) {\n\t\t\tstruct net_device *n_dev, *target_dev;\n\t\t\tbool found = false;\n\t\t\tunsigned int i;\n\n\t\t\ttarget_dev = tcf_mirred_dev(a);\n\t\t\tfor_each_port(adap, i) {\n\t\t\t\tn_dev = adap->port[i];\n\t\t\t\tif (target_dev == n_dev) {\n\t\t\t\t\tfs->action = FILTER_SWITCH;\n\t\t\t\t\tfs->eport = i;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!found)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnum_actions++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint cxgb4_config_knode(struct net_device *dev, struct tc_cls_u32_offload *cls)\n{\n\tconst struct cxgb4_match_field *start, *link_start = NULL;\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct adapter *adapter = netdev2adap(dev);\n\t__be16 protocol = cls->common.protocol;\n\tstruct ch_filter_specification fs;\n\tstruct cxgb4_tc_u32_table *t;\n\tstruct cxgb4_link *link;\n\tu32 uhtid, link_uhtid;\n\tbool is_ipv6 = false;\n\tu8 inet_family;\n\tint filter_id;\n\tint ret;\n\n\tif (!can_tc_u32_offload(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (protocol != htons(ETH_P_IP) && protocol != htons(ETH_P_IPV6))\n\t\treturn -EOPNOTSUPP;\n\n\tinet_family = (protocol == htons(ETH_P_IPV6)) ? PF_INET6 : PF_INET;\n\n\t \n\tfilter_id = cxgb4_get_free_ftid(dev, inet_family, false,\n\t\t\t\t\tTC_U32_NODE(cls->knode.handle));\n\tif (filter_id < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"No free LETCAM index available\");\n\t\treturn -ENOMEM;\n\t}\n\n\tt = adapter->tc_u32;\n\tuhtid = TC_U32_USERHTID(cls->knode.handle);\n\tlink_uhtid = TC_U32_USERHTID(cls->knode.link_handle);\n\n\t \n\tif (uhtid != 0x800 && uhtid >= t->size)\n\t\treturn -EINVAL;\n\n\t \n\tif (link_uhtid >= t->size)\n\t\treturn -EINVAL;\n\n\tmemset(&fs, 0, sizeof(fs));\n\n\tif (filter_id < adapter->tids.nhpftids)\n\t\tfs.prio = 1;\n\tfs.tc_prio = cls->common.prio;\n\tfs.tc_cookie = cls->knode.handle;\n\n\tif (protocol == htons(ETH_P_IPV6)) {\n\t\tstart = cxgb4_ipv6_fields;\n\t\tis_ipv6 = true;\n\t} else {\n\t\tstart = cxgb4_ipv4_fields;\n\t\tis_ipv6 = false;\n\t}\n\n\tif (uhtid != 0x800) {\n\t\t \n\t\tif (!t->table[uhtid - 1].link_handle)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tlink_start = t->table[uhtid - 1].match_field;\n\t\tif (!link_start)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (link_uhtid) {\n\t\tconst struct cxgb4_next_header *next;\n\t\tbool found = false;\n\t\tunsigned int i, j;\n\t\t__be32 val, mask;\n\t\tint off;\n\n\t\tif (t->table[link_uhtid - 1].link_handle) {\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"Link handle exists for: 0x%x\\n\",\n\t\t\t\tlink_uhtid);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnext = is_ipv6 ? cxgb4_ipv6_jumps : cxgb4_ipv4_jumps;\n\n\t\t \n\t\tfor (i = 0; next[i].jump; i++) {\n\t\t\tif (next[i].sel.offoff != cls->knode.sel->offoff ||\n\t\t\t    next[i].sel.offshift != cls->knode.sel->offshift ||\n\t\t\t    next[i].sel.offmask != cls->knode.sel->offmask ||\n\t\t\t    next[i].sel.off != cls->knode.sel->off)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tfor (j = 0; j < cls->knode.sel->nkeys; j++) {\n\t\t\t\toff = cls->knode.sel->keys[j].off;\n\t\t\t\tval = cls->knode.sel->keys[j].val;\n\t\t\t\tmask = cls->knode.sel->keys[j].mask;\n\n\t\t\t\tif (next[i].key.off == off &&\n\t\t\t\t    next[i].key.val == val &&\n\t\t\t\t    next[i].key.mask == mask) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!found)\n\t\t\t\tcontinue;  \n\n\t\t\t \n\t\t\tret = fill_match_fields(adapter, &fs, cls,\n\t\t\t\t\t\tstart, false);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tlink = &t->table[link_uhtid - 1];\n\t\t\tlink->match_field = next[i].jump;\n\t\t\tlink->link_handle = cls->knode.handle;\n\t\t\tmemcpy(&link->fs, &fs, sizeof(fs));\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!found)\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (uhtid != 0x800 && t->table[uhtid - 1].link_handle) {\n\t\t \n\t\tmemcpy(&fs, &t->table[uhtid - 1].fs, sizeof(fs));\n\t\tret = fill_match_fields(adapter, &fs, cls,\n\t\t\t\t\tlink_start, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = fill_match_fields(adapter, &fs, cls, start, false);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = fill_action_fields(adapter, &fs, cls);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\n\t \n\tfs.val.iport = netdev2pinfo(dev)->port_id;\n\tfs.mask.iport = ~0;\n\n\t \n\tfs.hitcnts = 1;\n\n\t \n\tfs.type = is_ipv6 ? 1 : 0;\n\n\t \n\tret = cxgb4_set_filter(dev, filter_id, &fs);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (uhtid != 0x800 && t->table[uhtid - 1].link_handle)\n\t\tset_bit(filter_id, t->table[uhtid - 1].tid_map);\n\nout:\n\treturn ret;\n}\n\nint cxgb4_delete_knode(struct net_device *dev, struct tc_cls_u32_offload *cls)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\tunsigned int filter_id, max_tids, i, j;\n\tstruct cxgb4_link *link = NULL;\n\tstruct cxgb4_tc_u32_table *t;\n\tstruct filter_entry *f;\n\tbool found = false;\n\tu32 handle, uhtid;\n\tu8 nslots;\n\tint ret;\n\n\tif (!can_tc_u32_offload(dev))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tmax_tids = adapter->tids.nhpftids + adapter->tids.nftids;\n\n\tspin_lock_bh(&adapter->tids.ftid_lock);\n\tfilter_id = 0;\n\twhile (filter_id < max_tids) {\n\t\tif (filter_id < adapter->tids.nhpftids) {\n\t\t\ti = filter_id;\n\t\t\tf = &adapter->tids.hpftid_tab[i];\n\t\t\tif (f->valid && f->fs.tc_cookie == cls->knode.handle) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ti = find_next_bit(adapter->tids.hpftid_bmap,\n\t\t\t\t\t  adapter->tids.nhpftids, i + 1);\n\t\t\tif (i >= adapter->tids.nhpftids) {\n\t\t\t\tfilter_id = adapter->tids.nhpftids;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfilter_id = i;\n\t\t} else {\n\t\t\ti = filter_id - adapter->tids.nhpftids;\n\t\t\tf = &adapter->tids.ftid_tab[i];\n\t\t\tif (f->valid && f->fs.tc_cookie == cls->knode.handle) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ti = find_next_bit(adapter->tids.ftid_bmap,\n\t\t\t\t\t  adapter->tids.nftids, i + 1);\n\t\t\tif (i >= adapter->tids.nftids)\n\t\t\t\tbreak;\n\n\t\t\tfilter_id = i + adapter->tids.nhpftids;\n\t\t}\n\n\t\tnslots = 0;\n\t\tif (f->fs.type) {\n\t\t\tnslots++;\n\t\t\tif (CHELSIO_CHIP_VERSION(adapter->params.chip) <\n\t\t\t    CHELSIO_T6)\n\t\t\t\tnslots += 2;\n\t\t}\n\n\t\tfilter_id += nslots;\n\t}\n\tspin_unlock_bh(&adapter->tids.ftid_lock);\n\n\tif (!found)\n\t\treturn -ERANGE;\n\n\tt = adapter->tc_u32;\n\thandle = cls->knode.handle;\n\tuhtid = TC_U32_USERHTID(cls->knode.handle);\n\n\t \n\tif (uhtid != 0x800 && uhtid >= t->size)\n\t\treturn -EINVAL;\n\n\t \n\tif (uhtid != 0x800) {\n\t\tlink = &t->table[uhtid - 1];\n\t\tif (!link->link_handle)\n\t\t\treturn -EINVAL;\n\n\t\tif (!test_bit(filter_id, link->tid_map))\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = cxgb4_del_filter(dev, filter_id, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tif (link)\n\t\tclear_bit(filter_id, link->tid_map);\n\n\t \n\tfor (i = 0; i < t->size; i++) {\n\t\tlink = &t->table[i];\n\n\t\tif (link->link_handle == handle) {\n\t\t\tfor (j = 0; j < max_tids; j++) {\n\t\t\t\tif (!test_bit(j, link->tid_map))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tret = __cxgb4_del_filter(dev, j, NULL, NULL);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tclear_bit(j, link->tid_map);\n\t\t\t}\n\n\t\t\t \n\t\t\tlink->match_field = NULL;\n\t\t\tlink->link_handle = 0;\n\t\t\tmemset(&link->fs, 0, sizeof(link->fs));\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\nvoid cxgb4_cleanup_tc_u32(struct adapter *adap)\n{\n\tstruct cxgb4_tc_u32_table *t;\n\tunsigned int i;\n\n\tif (!adap->tc_u32)\n\t\treturn;\n\n\t \n\tt = adap->tc_u32;\n\tfor (i = 0; i < t->size; i++) {\n\t\tstruct cxgb4_link *link = &t->table[i];\n\n\t\tkvfree(link->tid_map);\n\t}\n\tkvfree(adap->tc_u32);\n}\n\nstruct cxgb4_tc_u32_table *cxgb4_init_tc_u32(struct adapter *adap)\n{\n\tunsigned int max_tids = adap->tids.nftids + adap->tids.nhpftids;\n\tstruct cxgb4_tc_u32_table *t;\n\tunsigned int i;\n\n\tif (!max_tids)\n\t\treturn NULL;\n\n\tt = kvzalloc(struct_size(t, table, max_tids), GFP_KERNEL);\n\tif (!t)\n\t\treturn NULL;\n\n\tt->size = max_tids;\n\n\tfor (i = 0; i < t->size; i++) {\n\t\tstruct cxgb4_link *link = &t->table[i];\n\t\tunsigned int bmap_size;\n\n\t\tbmap_size = BITS_TO_LONGS(max_tids);\n\t\tlink->tid_map = kvcalloc(bmap_size, sizeof(unsigned long),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!link->tid_map)\n\t\t\tgoto out_no_mem;\n\t\tbitmap_zero(link->tid_map, max_tids);\n\t}\n\n\treturn t;\n\nout_no_mem:\n\tfor (i = 0; i < t->size; i++) {\n\t\tstruct cxgb4_link *link = &t->table[i];\n\t\tkvfree(link->tid_map);\n\t}\n\tkvfree(t);\n\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}