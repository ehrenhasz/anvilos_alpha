{
  "module_name": "cxgb4_tc_mqprio.c",
  "hash_id": "3b0637fe379782f7ae6c0869ee849756bdf40fb991da067a2bed0ac7389d7e2c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/cxgb4_tc_mqprio.c",
  "human_readable_source": "\n \n\n#include \"cxgb4.h\"\n#include \"cxgb4_tc_mqprio.h\"\n#include \"sched.h\"\n\nstatic int cxgb4_mqprio_validate(struct net_device *dev,\n\t\t\t\t struct tc_mqprio_qopt_offload *mqprio)\n{\n\tu64 min_rate = 0, max_rate = 0, max_link_rate;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tu32 speed, qcount = 0, qoffset = 0;\n\tu32 start_a, start_b, end_a, end_b;\n\tint ret;\n\tu8 i, j;\n\n\tif (!mqprio->qopt.num_tc)\n\t\treturn 0;\n\n\tif (mqprio->qopt.hw != TC_MQPRIO_HW_OFFLOAD_TCS) {\n\t\tnetdev_err(dev, \"Only full TC hardware offload is supported\\n\");\n\t\treturn -EINVAL;\n\t} else if (mqprio->mode != TC_MQPRIO_MODE_CHANNEL) {\n\t\tnetdev_err(dev, \"Only channel mode offload is supported\\n\");\n\t\treturn -EINVAL;\n\t} else if (mqprio->shaper != TC_MQPRIO_SHAPER_BW_RATE) {\n\t\tnetdev_err(dev,\t\"Only bandwidth rate shaper supported\\n\");\n\t\treturn -EINVAL;\n\t} else if (mqprio->qopt.num_tc > adap->params.nsched_cls) {\n\t\tnetdev_err(dev,\n\t\t\t   \"Only %u traffic classes supported by hardware\\n\",\n\t\t\t   adap->params.nsched_cls);\n\t\treturn -ERANGE;\n\t}\n\n\tret = t4_get_link_params(pi, NULL, &speed, NULL);\n\tif (ret) {\n\t\tnetdev_err(dev, \"Failed to get link speed, ret: %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmax_link_rate = (u64)speed * 1000 * 1000;\n\n\tfor (i = 0; i < mqprio->qopt.num_tc; i++) {\n\t\tqoffset = max_t(u16, mqprio->qopt.offset[i], qoffset);\n\t\tqcount += mqprio->qopt.count[i];\n\n\t\tstart_a = mqprio->qopt.offset[i];\n\t\tend_a = start_a + mqprio->qopt.count[i] - 1;\n\t\tfor (j = i + 1; j < mqprio->qopt.num_tc; j++) {\n\t\t\tstart_b = mqprio->qopt.offset[j];\n\t\t\tend_b = start_b + mqprio->qopt.count[j] - 1;\n\n\t\t\t \n\t\t\tif (!mqprio->qopt.count[i])\n\t\t\t\tbreak;\n\n\t\t\tif (!mqprio->qopt.count[j])\n\t\t\t\tcontinue;\n\n\t\t\tif (max_t(u32, start_a, start_b) <=\n\t\t\t    min_t(u32, end_a, end_b)) {\n\t\t\t\tnetdev_err(dev,\n\t\t\t\t\t   \"Queues can't overlap across tc\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmin_rate += (mqprio->min_rate[i] * 8);\n\t\tmax_rate += (mqprio->max_rate[i] * 8);\n\t}\n\n\tif (qoffset >= adap->tids.neotids || qcount > adap->tids.neotids)\n\t\treturn -ENOMEM;\n\n\tif (min_rate > max_link_rate || max_rate > max_link_rate) {\n\t\tnetdev_err(dev,\n\t\t\t   \"Total Min/Max (%llu/%llu) Rate > supported (%llu)\\n\",\n\t\t\t   min_rate, max_rate, max_link_rate);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxgb4_init_eosw_txq(struct net_device *dev,\n\t\t\t       struct sge_eosw_txq *eosw_txq,\n\t\t\t       u32 eotid, u32 hwqid)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct tx_sw_desc *ring;\n\n\tmemset(eosw_txq, 0, sizeof(*eosw_txq));\n\n\tring = kcalloc(CXGB4_EOSW_TXQ_DEFAULT_DESC_NUM,\n\t\t       sizeof(*ring), GFP_KERNEL);\n\tif (!ring)\n\t\treturn -ENOMEM;\n\n\teosw_txq->desc = ring;\n\teosw_txq->ndesc = CXGB4_EOSW_TXQ_DEFAULT_DESC_NUM;\n\tspin_lock_init(&eosw_txq->lock);\n\teosw_txq->state = CXGB4_EO_STATE_CLOSED;\n\teosw_txq->eotid = eotid;\n\teosw_txq->hwtid = adap->tids.eotid_base + eosw_txq->eotid;\n\teosw_txq->cred = adap->params.ofldq_wr_cred;\n\teosw_txq->hwqid = hwqid;\n\teosw_txq->netdev = dev;\n\ttasklet_setup(&eosw_txq->qresume_tsk, cxgb4_ethofld_restart);\n\treturn 0;\n}\n\nstatic void cxgb4_clean_eosw_txq(struct net_device *dev,\n\t\t\t\t struct sge_eosw_txq *eosw_txq)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tcxgb4_eosw_txq_free_desc(adap, eosw_txq, eosw_txq->ndesc);\n\teosw_txq->pidx = 0;\n\teosw_txq->last_pidx = 0;\n\teosw_txq->cidx = 0;\n\teosw_txq->last_cidx = 0;\n\teosw_txq->flowc_idx = 0;\n\teosw_txq->inuse = 0;\n\teosw_txq->cred = adap->params.ofldq_wr_cred;\n\teosw_txq->ncompl = 0;\n\teosw_txq->last_compl = 0;\n\teosw_txq->state = CXGB4_EO_STATE_CLOSED;\n}\n\nstatic void cxgb4_free_eosw_txq(struct net_device *dev,\n\t\t\t\tstruct sge_eosw_txq *eosw_txq)\n{\n\tspin_lock_bh(&eosw_txq->lock);\n\tcxgb4_clean_eosw_txq(dev, eosw_txq);\n\tkfree(eosw_txq->desc);\n\tspin_unlock_bh(&eosw_txq->lock);\n\ttasklet_kill(&eosw_txq->qresume_tsk);\n}\n\nstatic int cxgb4_mqprio_alloc_hw_resources(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct sge_ofld_rxq *eorxq;\n\tstruct sge_eohw_txq *eotxq;\n\tint ret, msix = 0;\n\tu32 i;\n\n\t \n\tif (!refcount_read(&adap->tc_mqprio->refcnt)) {\n\t\tadap->sge.eohw_rxq = kcalloc(adap->sge.eoqsets,\n\t\t\t\t\t     sizeof(struct sge_ofld_rxq),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!adap->sge.eohw_rxq)\n\t\t\treturn -ENOMEM;\n\n\t\tadap->sge.eohw_txq = kcalloc(adap->sge.eoqsets,\n\t\t\t\t\t     sizeof(struct sge_eohw_txq),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!adap->sge.eohw_txq) {\n\t\t\tkfree(adap->sge.eohw_rxq);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trefcount_set(&adap->tc_mqprio->refcnt, 1);\n\t} else {\n\t\trefcount_inc(&adap->tc_mqprio->refcnt);\n\t}\n\n\tif (!(adap->flags & CXGB4_USING_MSIX))\n\t\tmsix = -((int)adap->sge.intrq.abs_id + 1);\n\n\tfor (i = 0; i < pi->nqsets; i++) {\n\t\teorxq = &adap->sge.eohw_rxq[pi->first_qset + i];\n\t\teotxq = &adap->sge.eohw_txq[pi->first_qset + i];\n\n\t\t \n\t\tif (msix >= 0) {\n\t\t\tmsix = cxgb4_get_msix_idx_from_bmap(adap);\n\t\t\tif (msix < 0) {\n\t\t\t\tret = msix;\n\t\t\t\tgoto out_free_queues;\n\t\t\t}\n\n\t\t\teorxq->msix = &adap->msix_info[msix];\n\t\t\tsnprintf(eorxq->msix->desc,\n\t\t\t\t sizeof(eorxq->msix->desc),\n\t\t\t\t \"%s-eorxq%d\", dev->name, i);\n\t\t}\n\n\t\tinit_rspq(adap, &eorxq->rspq,\n\t\t\t  CXGB4_EOHW_RXQ_DEFAULT_INTR_USEC,\n\t\t\t  CXGB4_EOHW_RXQ_DEFAULT_PKT_CNT,\n\t\t\t  CXGB4_EOHW_RXQ_DEFAULT_DESC_NUM,\n\t\t\t  CXGB4_EOHW_RXQ_DEFAULT_DESC_SIZE);\n\n\t\teorxq->fl.size = CXGB4_EOHW_FLQ_DEFAULT_DESC_NUM;\n\n\t\tret = t4_sge_alloc_rxq(adap, &eorxq->rspq, false,\n\t\t\t\t       dev, msix, &eorxq->fl,\n\t\t\t\t       cxgb4_ethofld_rx_handler,\n\t\t\t\t       NULL, 0);\n\t\tif (ret)\n\t\t\tgoto out_free_queues;\n\n\t\t \n\t\teotxq->q.size = CXGB4_EOHW_TXQ_DEFAULT_DESC_NUM;\n\t\tret = t4_sge_alloc_ethofld_txq(adap, eotxq, dev,\n\t\t\t\t\t       eorxq->rspq.cntxt_id);\n\t\tif (ret)\n\t\t\tgoto out_free_queues;\n\n\t\t \n\t\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\t\tret = request_irq(eorxq->msix->vec, t4_sge_intr_msix, 0,\n\t\t\t\t\t  eorxq->msix->desc, &eorxq->rspq);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_msix;\n\n\t\t\tcxgb4_set_msix_aff(adap, eorxq->msix->vec,\n\t\t\t\t\t   &eorxq->msix->aff_mask, i);\n\t\t}\n\n\t\tif (adap->flags & CXGB4_FULL_INIT_DONE)\n\t\t\tcxgb4_enable_rx(adap, &eorxq->rspq);\n\t}\n\n\treturn 0;\n\nout_free_msix:\n\twhile (i-- > 0) {\n\t\teorxq = &adap->sge.eohw_rxq[pi->first_qset + i];\n\n\t\tif (adap->flags & CXGB4_FULL_INIT_DONE)\n\t\t\tcxgb4_quiesce_rx(&eorxq->rspq);\n\n\t\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\t\tcxgb4_clear_msix_aff(eorxq->msix->vec,\n\t\t\t\t\t     eorxq->msix->aff_mask);\n\t\t\tfree_irq(eorxq->msix->vec, &eorxq->rspq);\n\t\t}\n\t}\n\nout_free_queues:\n\tfor (i = 0; i < pi->nqsets; i++) {\n\t\teorxq = &adap->sge.eohw_rxq[pi->first_qset + i];\n\t\teotxq = &adap->sge.eohw_txq[pi->first_qset + i];\n\n\t\tif (eorxq->rspq.desc)\n\t\t\tfree_rspq_fl(adap, &eorxq->rspq, &eorxq->fl);\n\t\tif (eorxq->msix)\n\t\t\tcxgb4_free_msix_idx_in_bmap(adap, eorxq->msix->idx);\n\t\tt4_sge_free_ethofld_txq(adap, eotxq);\n\t}\n\n\tif (refcount_dec_and_test(&adap->tc_mqprio->refcnt)) {\n\t\tkfree(adap->sge.eohw_txq);\n\t\tkfree(adap->sge.eohw_rxq);\n\t}\n\treturn ret;\n}\n\nstatic void cxgb4_mqprio_free_hw_resources(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct sge_ofld_rxq *eorxq;\n\tstruct sge_eohw_txq *eotxq;\n\tu32 i;\n\n\t \n\tif (!refcount_read(&adap->tc_mqprio->refcnt))\n\t\treturn;\n\n\t \n\tif (!adap->sge.eohw_rxq[pi->first_qset].rspq.desc)\n\t\treturn;\n\n\tfor (i = 0; i < pi->nqsets; i++) {\n\t\teorxq = &adap->sge.eohw_rxq[pi->first_qset + i];\n\t\teotxq = &adap->sge.eohw_txq[pi->first_qset + i];\n\n\t\t \n\t\tif (!(adap->flags & CXGB4_SHUTTING_DOWN))\n\t\t\tcxgb4_quiesce_rx(&eorxq->rspq);\n\n\t\tif (adap->flags & CXGB4_USING_MSIX) {\n\t\t\tcxgb4_clear_msix_aff(eorxq->msix->vec,\n\t\t\t\t\t     eorxq->msix->aff_mask);\n\t\t\tfree_irq(eorxq->msix->vec, &eorxq->rspq);\n\t\t\tcxgb4_free_msix_idx_in_bmap(adap, eorxq->msix->idx);\n\t\t}\n\n\t\tfree_rspq_fl(adap, &eorxq->rspq, &eorxq->fl);\n\t\tt4_sge_free_ethofld_txq(adap, eotxq);\n\t}\n\n\t \n\tif (refcount_dec_and_test(&adap->tc_mqprio->refcnt)) {\n\t\tkfree(adap->sge.eohw_txq);\n\t\tkfree(adap->sge.eohw_rxq);\n\t}\n}\n\nstatic int cxgb4_mqprio_alloc_tc(struct net_device *dev,\n\t\t\t\t struct tc_mqprio_qopt_offload *mqprio)\n{\n\tstruct ch_sched_params p = {\n\t\t.type = SCHED_CLASS_TYPE_PACKET,\n\t\t.u.params.level = SCHED_CLASS_LEVEL_CL_RL,\n\t\t.u.params.mode = SCHED_CLASS_MODE_FLOW,\n\t\t.u.params.rateunit = SCHED_CLASS_RATEUNIT_BITS,\n\t\t.u.params.ratemode = SCHED_CLASS_RATEMODE_ABS,\n\t\t.u.params.class = SCHED_CLS_NONE,\n\t\t.u.params.weight = 0,\n\t\t.u.params.pktsize = dev->mtu,\n\t};\n\tstruct cxgb4_tc_port_mqprio *tc_port_mqprio;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct sched_class *e;\n\tint ret;\n\tu8 i;\n\n\ttc_port_mqprio = &adap->tc_mqprio->port_mqprio[pi->port_id];\n\tp.u.params.channel = pi->tx_chan;\n\tfor (i = 0; i < mqprio->qopt.num_tc; i++) {\n\t\t \n\t\tp.u.params.minrate = div_u64(mqprio->min_rate[i] * 8, 1000);\n\t\tp.u.params.maxrate = div_u64(mqprio->max_rate[i] * 8, 1000);\n\n\t\t \n\t\tif (dev->mtu <= ETH_DATA_LEN)\n\t\t\tp.u.params.burstsize = 8 * dev->mtu;\n\n\t\te = cxgb4_sched_class_alloc(dev, &p);\n\t\tif (!e) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\ttc_port_mqprio->tc_hwtc_map[i] = e->idx;\n\t}\n\n\treturn 0;\n\nout_err:\n\twhile (i--)\n\t\tcxgb4_sched_class_free(dev, tc_port_mqprio->tc_hwtc_map[i]);\n\n\treturn ret;\n}\n\nstatic void cxgb4_mqprio_free_tc(struct net_device *dev)\n{\n\tstruct cxgb4_tc_port_mqprio *tc_port_mqprio;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tu8 i;\n\n\ttc_port_mqprio = &adap->tc_mqprio->port_mqprio[pi->port_id];\n\tfor (i = 0; i < tc_port_mqprio->mqprio.qopt.num_tc; i++)\n\t\tcxgb4_sched_class_free(dev, tc_port_mqprio->tc_hwtc_map[i]);\n}\n\nstatic int cxgb4_mqprio_class_bind(struct net_device *dev,\n\t\t\t\t   struct sge_eosw_txq *eosw_txq,\n\t\t\t\t   u8 tc)\n{\n\tstruct ch_sched_flowc fe;\n\tint ret;\n\n\tinit_completion(&eosw_txq->completion);\n\n\tfe.tid = eosw_txq->eotid;\n\tfe.class = tc;\n\n\tret = cxgb4_sched_class_bind(dev, &fe, SCHED_FLOWC);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_for_completion_timeout(&eosw_txq->completion,\n\t\t\t\t\t  CXGB4_FLOWC_WAIT_TIMEOUT);\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic void cxgb4_mqprio_class_unbind(struct net_device *dev,\n\t\t\t\t      struct sge_eosw_txq *eosw_txq,\n\t\t\t\t      u8 tc)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct ch_sched_flowc fe;\n\n\t \n\tif (!(adap->flags & CXGB4_SHUTTING_DOWN))\n\t\tinit_completion(&eosw_txq->completion);\n\n\tfe.tid = eosw_txq->eotid;\n\tfe.class = tc;\n\tcxgb4_sched_class_unbind(dev, &fe, SCHED_FLOWC);\n\n\tif (!(adap->flags & CXGB4_SHUTTING_DOWN))\n\t\twait_for_completion_timeout(&eosw_txq->completion,\n\t\t\t\t\t    CXGB4_FLOWC_WAIT_TIMEOUT);\n}\n\nstatic int cxgb4_mqprio_enable_offload(struct net_device *dev,\n\t\t\t\t       struct tc_mqprio_qopt_offload *mqprio)\n{\n\tstruct cxgb4_tc_port_mqprio *tc_port_mqprio;\n\tu32 qoffset, qcount, tot_qcount, qid, hwqid;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct sge_eosw_txq *eosw_txq;\n\tint eotid, ret;\n\tu16 i, j;\n\tu8 hwtc;\n\n\tret = cxgb4_mqprio_alloc_hw_resources(dev);\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\ttc_port_mqprio = &adap->tc_mqprio->port_mqprio[pi->port_id];\n\tfor (i = 0; i < mqprio->qopt.num_tc; i++) {\n\t\tqoffset = mqprio->qopt.offset[i];\n\t\tqcount = mqprio->qopt.count[i];\n\t\tfor (j = 0; j < qcount; j++) {\n\t\t\teotid = cxgb4_get_free_eotid(&adap->tids);\n\t\t\tif (eotid < 0) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_free_eotids;\n\t\t\t}\n\n\t\t\tqid = qoffset + j;\n\t\t\thwqid = pi->first_qset + (eotid % pi->nqsets);\n\t\t\teosw_txq = &tc_port_mqprio->eosw_txq[qid];\n\t\t\tret = cxgb4_init_eosw_txq(dev, eosw_txq,\n\t\t\t\t\t\t  eotid, hwqid);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_eotids;\n\n\t\t\tcxgb4_alloc_eotid(&adap->tids, eotid, eosw_txq);\n\n\t\t\thwtc = tc_port_mqprio->tc_hwtc_map[i];\n\t\t\tret = cxgb4_mqprio_class_bind(dev, eosw_txq, hwtc);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_eotids;\n\t\t}\n\t}\n\n\tmemcpy(&tc_port_mqprio->mqprio, mqprio,\n\t       sizeof(struct tc_mqprio_qopt_offload));\n\n\t \n\tret = netdev_set_num_tc(dev, mqprio->qopt.num_tc);\n\tif (ret)\n\t\tgoto out_free_eotids;\n\n\ttot_qcount = pi->nqsets;\n\tfor (i = 0; i < mqprio->qopt.num_tc; i++) {\n\t\tqcount = mqprio->qopt.count[i];\n\t\tif (qcount) {\n\t\t\tqoffset = mqprio->qopt.offset[i] + pi->nqsets;\n\t\t} else {\n\t\t\tqcount = pi->nqsets;\n\t\t\tqoffset = 0;\n\t\t}\n\n\t\tret = netdev_set_tc_queue(dev, i, qcount, qoffset);\n\t\tif (ret)\n\t\t\tgoto out_reset_tc;\n\n\t\ttot_qcount += mqprio->qopt.count[i];\n\t}\n\n\tret = netif_set_real_num_tx_queues(dev, tot_qcount);\n\tif (ret)\n\t\tgoto out_reset_tc;\n\n\ttc_port_mqprio->state = CXGB4_MQPRIO_STATE_ACTIVE;\n\treturn 0;\n\nout_reset_tc:\n\tnetdev_reset_tc(dev);\n\ti = mqprio->qopt.num_tc;\n\nout_free_eotids:\n\twhile (i-- > 0) {\n\t\tqoffset = mqprio->qopt.offset[i];\n\t\tqcount = mqprio->qopt.count[i];\n\t\tfor (j = 0; j < qcount; j++) {\n\t\t\teosw_txq = &tc_port_mqprio->eosw_txq[qoffset + j];\n\n\t\t\thwtc = tc_port_mqprio->tc_hwtc_map[i];\n\t\t\tcxgb4_mqprio_class_unbind(dev, eosw_txq, hwtc);\n\n\t\t\tcxgb4_free_eotid(&adap->tids, eosw_txq->eotid);\n\t\t\tcxgb4_free_eosw_txq(dev, eosw_txq);\n\t\t}\n\t}\n\n\tcxgb4_mqprio_free_hw_resources(dev);\n\treturn ret;\n}\n\nstatic void cxgb4_mqprio_disable_offload(struct net_device *dev)\n{\n\tstruct cxgb4_tc_port_mqprio *tc_port_mqprio;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct sge_eosw_txq *eosw_txq;\n\tu32 qoffset, qcount;\n\tu16 i, j;\n\tu8 hwtc;\n\n\ttc_port_mqprio = &adap->tc_mqprio->port_mqprio[pi->port_id];\n\tif (tc_port_mqprio->state != CXGB4_MQPRIO_STATE_ACTIVE)\n\t\treturn;\n\n\tnetdev_reset_tc(dev);\n\tnetif_set_real_num_tx_queues(dev, pi->nqsets);\n\n\tfor (i = 0; i < tc_port_mqprio->mqprio.qopt.num_tc; i++) {\n\t\tqoffset = tc_port_mqprio->mqprio.qopt.offset[i];\n\t\tqcount = tc_port_mqprio->mqprio.qopt.count[i];\n\t\tfor (j = 0; j < qcount; j++) {\n\t\t\teosw_txq = &tc_port_mqprio->eosw_txq[qoffset + j];\n\n\t\t\thwtc = tc_port_mqprio->tc_hwtc_map[i];\n\t\t\tcxgb4_mqprio_class_unbind(dev, eosw_txq, hwtc);\n\n\t\t\tcxgb4_free_eotid(&adap->tids, eosw_txq->eotid);\n\t\t\tcxgb4_free_eosw_txq(dev, eosw_txq);\n\t\t}\n\t}\n\n\tcxgb4_mqprio_free_hw_resources(dev);\n\n\t \n\tcxgb4_mqprio_free_tc(dev);\n\n\tmemset(&tc_port_mqprio->mqprio, 0,\n\t       sizeof(struct tc_mqprio_qopt_offload));\n\n\ttc_port_mqprio->state = CXGB4_MQPRIO_STATE_DISABLED;\n}\n\nint cxgb4_setup_tc_mqprio(struct net_device *dev,\n\t\t\t  struct tc_mqprio_qopt_offload *mqprio)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\tbool needs_bring_up = false;\n\tint ret;\n\n\tret = cxgb4_mqprio_validate(dev, mqprio);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&adap->tc_mqprio->mqprio_mutex);\n\n\t \n\tif (netif_running(dev)) {\n\t\tnetif_tx_stop_all_queues(dev);\n\t\tnetif_carrier_off(dev);\n\t\tneeds_bring_up = true;\n\t}\n\n\tcxgb4_mqprio_disable_offload(dev);\n\n\t \n\tif (!mqprio->qopt.num_tc)\n\t\tgoto out;\n\n\t \n\tret = cxgb4_mqprio_alloc_tc(dev, mqprio);\n\tif (ret)\n\t\tgoto out;\n\n\tret = cxgb4_mqprio_enable_offload(dev, mqprio);\n\tif (ret) {\n\t\tcxgb4_mqprio_free_tc(dev);\n\t\tgoto out;\n\t}\n\nout:\n\tif (needs_bring_up) {\n\t\tnetif_tx_start_all_queues(dev);\n\t\tnetif_carrier_on(dev);\n\t}\n\n\tmutex_unlock(&adap->tc_mqprio->mqprio_mutex);\n\treturn ret;\n}\n\nvoid cxgb4_mqprio_stop_offload(struct adapter *adap)\n{\n\tstruct cxgb4_tc_port_mqprio *tc_port_mqprio;\n\tstruct net_device *dev;\n\tu8 i;\n\n\tif (!adap->tc_mqprio || !adap->tc_mqprio->port_mqprio)\n\t\treturn;\n\n\tmutex_lock(&adap->tc_mqprio->mqprio_mutex);\n\tfor_each_port(adap, i) {\n\t\tdev = adap->port[i];\n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\ttc_port_mqprio = &adap->tc_mqprio->port_mqprio[i];\n\t\tif (!tc_port_mqprio->mqprio.qopt.num_tc)\n\t\t\tcontinue;\n\n\t\tcxgb4_mqprio_disable_offload(dev);\n\t}\n\tmutex_unlock(&adap->tc_mqprio->mqprio_mutex);\n}\n\nint cxgb4_init_tc_mqprio(struct adapter *adap)\n{\n\tstruct cxgb4_tc_port_mqprio *tc_port_mqprio, *port_mqprio;\n\tstruct cxgb4_tc_mqprio *tc_mqprio;\n\tstruct sge_eosw_txq *eosw_txq;\n\tint ret = 0;\n\tu8 i;\n\n\ttc_mqprio = kzalloc(sizeof(*tc_mqprio), GFP_KERNEL);\n\tif (!tc_mqprio)\n\t\treturn -ENOMEM;\n\n\ttc_port_mqprio = kcalloc(adap->params.nports, sizeof(*tc_port_mqprio),\n\t\t\t\t GFP_KERNEL);\n\tif (!tc_port_mqprio) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_mqprio;\n\t}\n\n\tmutex_init(&tc_mqprio->mqprio_mutex);\n\n\ttc_mqprio->port_mqprio = tc_port_mqprio;\n\tfor (i = 0; i < adap->params.nports; i++) {\n\t\tport_mqprio = &tc_mqprio->port_mqprio[i];\n\t\teosw_txq = kcalloc(adap->tids.neotids, sizeof(*eosw_txq),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!eosw_txq) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free_ports;\n\t\t}\n\t\tport_mqprio->eosw_txq = eosw_txq;\n\t}\n\n\tadap->tc_mqprio = tc_mqprio;\n\trefcount_set(&adap->tc_mqprio->refcnt, 0);\n\treturn 0;\n\nout_free_ports:\n\tfor (i = 0; i < adap->params.nports; i++) {\n\t\tport_mqprio = &tc_mqprio->port_mqprio[i];\n\t\tkfree(port_mqprio->eosw_txq);\n\t}\n\tkfree(tc_port_mqprio);\n\nout_free_mqprio:\n\tkfree(tc_mqprio);\n\treturn ret;\n}\n\nvoid cxgb4_cleanup_tc_mqprio(struct adapter *adap)\n{\n\tstruct cxgb4_tc_port_mqprio *port_mqprio;\n\tu8 i;\n\n\tif (adap->tc_mqprio) {\n\t\tmutex_lock(&adap->tc_mqprio->mqprio_mutex);\n\t\tif (adap->tc_mqprio->port_mqprio) {\n\t\t\tfor (i = 0; i < adap->params.nports; i++) {\n\t\t\t\tstruct net_device *dev = adap->port[i];\n\n\t\t\t\tif (dev)\n\t\t\t\t\tcxgb4_mqprio_disable_offload(dev);\n\t\t\t\tport_mqprio = &adap->tc_mqprio->port_mqprio[i];\n\t\t\t\tkfree(port_mqprio->eosw_txq);\n\t\t\t}\n\t\t\tkfree(adap->tc_mqprio->port_mqprio);\n\t\t}\n\t\tmutex_unlock(&adap->tc_mqprio->mqprio_mutex);\n\t\tkfree(adap->tc_mqprio);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}