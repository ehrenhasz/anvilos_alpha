{
  "module_name": "cxgb4_ethtool.c",
  "hash_id": "c6c512c2ff29ba6ab00dd288382d8bb87249fe1375a3630ad36289276ab703cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/mdio.h>\n\n#include \"cxgb4.h\"\n#include \"t4_regs.h\"\n#include \"t4fw_api.h\"\n#include \"cxgb4_cudbg.h\"\n#include \"cxgb4_filter.h\"\n#include \"cxgb4_tc_flower.h\"\n\n#define EEPROM_MAGIC 0x38E2F10C\n\nstatic u32 get_msglevel(struct net_device *dev)\n{\n\treturn netdev2adap(dev)->msg_enable;\n}\n\nstatic void set_msglevel(struct net_device *dev, u32 val)\n{\n\tnetdev2adap(dev)->msg_enable = val;\n}\n\nenum cxgb4_ethtool_tests {\n\tCXGB4_ETHTOOL_LB_TEST,\n\tCXGB4_ETHTOOL_MAX_TEST,\n};\n\nstatic const char cxgb4_selftest_strings[CXGB4_ETHTOOL_MAX_TEST][ETH_GSTRING_LEN] = {\n\t\"Loop back test (offline)\",\n};\n\nstatic const char * const flash_region_strings[] = {\n\t\"All\",\n\t\"Firmware\",\n\t\"PHY Firmware\",\n\t\"Boot\",\n\t\"Boot CFG\",\n};\n\nstatic const char stats_strings[][ETH_GSTRING_LEN] = {\n\t\"tx_octets_ok           \",\n\t\"tx_frames_ok           \",\n\t\"tx_broadcast_frames    \",\n\t\"tx_multicast_frames    \",\n\t\"tx_unicast_frames      \",\n\t\"tx_error_frames        \",\n\n\t\"tx_frames_64           \",\n\t\"tx_frames_65_to_127    \",\n\t\"tx_frames_128_to_255   \",\n\t\"tx_frames_256_to_511   \",\n\t\"tx_frames_512_to_1023  \",\n\t\"tx_frames_1024_to_1518 \",\n\t\"tx_frames_1519_to_max  \",\n\n\t\"tx_frames_dropped      \",\n\t\"tx_pause_frames        \",\n\t\"tx_ppp0_frames         \",\n\t\"tx_ppp1_frames         \",\n\t\"tx_ppp2_frames         \",\n\t\"tx_ppp3_frames         \",\n\t\"tx_ppp4_frames         \",\n\t\"tx_ppp5_frames         \",\n\t\"tx_ppp6_frames         \",\n\t\"tx_ppp7_frames         \",\n\n\t\"rx_octets_ok           \",\n\t\"rx_frames_ok           \",\n\t\"rx_broadcast_frames    \",\n\t\"rx_multicast_frames    \",\n\t\"rx_unicast_frames      \",\n\n\t\"rx_frames_too_long     \",\n\t\"rx_jabber_errors       \",\n\t\"rx_fcs_errors          \",\n\t\"rx_length_errors       \",\n\t\"rx_symbol_errors       \",\n\t\"rx_runt_frames         \",\n\n\t\"rx_frames_64           \",\n\t\"rx_frames_65_to_127    \",\n\t\"rx_frames_128_to_255   \",\n\t\"rx_frames_256_to_511   \",\n\t\"rx_frames_512_to_1023  \",\n\t\"rx_frames_1024_to_1518 \",\n\t\"rx_frames_1519_to_max  \",\n\n\t\"rx_pause_frames        \",\n\t\"rx_ppp0_frames         \",\n\t\"rx_ppp1_frames         \",\n\t\"rx_ppp2_frames         \",\n\t\"rx_ppp3_frames         \",\n\t\"rx_ppp4_frames         \",\n\t\"rx_ppp5_frames         \",\n\t\"rx_ppp6_frames         \",\n\t\"rx_ppp7_frames         \",\n\n\t\"rx_bg0_frames_dropped  \",\n\t\"rx_bg1_frames_dropped  \",\n\t\"rx_bg2_frames_dropped  \",\n\t\"rx_bg3_frames_dropped  \",\n\t\"rx_bg0_frames_trunc    \",\n\t\"rx_bg1_frames_trunc    \",\n\t\"rx_bg2_frames_trunc    \",\n\t\"rx_bg3_frames_trunc    \",\n\n\t\"tso                    \",\n\t\"uso                    \",\n\t\"tx_csum_offload        \",\n\t\"rx_csum_good           \",\n\t\"vlan_extractions       \",\n\t\"vlan_insertions        \",\n\t\"gro_packets            \",\n\t\"gro_merged             \",\n#if  IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n\t\"tx_tls_encrypted_packets\",\n\t\"tx_tls_encrypted_bytes  \",\n\t\"tx_tls_ctx              \",\n\t\"tx_tls_ooo              \",\n\t\"tx_tls_skip_no_sync_data\",\n\t\"tx_tls_drop_no_sync_data\",\n\t\"tx_tls_drop_bypass_req  \",\n#endif\n};\n\nstatic char adapter_stats_strings[][ETH_GSTRING_LEN] = {\n\t\"db_drop                \",\n\t\"db_full                \",\n\t\"db_empty               \",\n\t\"write_coal_success     \",\n\t\"write_coal_fail        \",\n};\n\nstatic char loopback_stats_strings[][ETH_GSTRING_LEN] = {\n\t\"-------Loopback----------- \",\n\t\"octets_ok              \",\n\t\"frames_ok              \",\n\t\"bcast_frames           \",\n\t\"mcast_frames           \",\n\t\"ucast_frames           \",\n\t\"error_frames           \",\n\t\"frames_64              \",\n\t\"frames_65_to_127       \",\n\t\"frames_128_to_255      \",\n\t\"frames_256_to_511      \",\n\t\"frames_512_to_1023     \",\n\t\"frames_1024_to_1518    \",\n\t\"frames_1519_to_max     \",\n\t\"frames_dropped         \",\n\t\"bg0_frames_dropped     \",\n\t\"bg1_frames_dropped     \",\n\t\"bg2_frames_dropped     \",\n\t\"bg3_frames_dropped     \",\n\t\"bg0_frames_trunc       \",\n\t\"bg1_frames_trunc       \",\n\t\"bg2_frames_trunc       \",\n\t\"bg3_frames_trunc       \",\n};\n\nstatic const char cxgb4_priv_flags_strings[][ETH_GSTRING_LEN] = {\n\t[PRIV_FLAG_PORT_TX_VM_BIT] = \"port_tx_vm_wr\",\n};\n\nstatic int get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(stats_strings) +\n\t\t       ARRAY_SIZE(adapter_stats_strings) +\n\t\t       ARRAY_SIZE(loopback_stats_strings);\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn ARRAY_SIZE(cxgb4_priv_flags_strings);\n\tcase ETH_SS_TEST:\n\t\treturn ARRAY_SIZE(cxgb4_selftest_strings);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int get_regs_len(struct net_device *dev)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\n\treturn t4_get_regs_len(adap);\n}\n\nstatic int get_eeprom_len(struct net_device *dev)\n{\n\treturn EEPROMSIZE;\n}\n\nstatic void get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\tu32 exprom_vers;\n\n\tstrscpy(info->driver, cxgb4_driver_name, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(info->bus_info));\n\tinfo->regdump_len = get_regs_len(dev);\n\n\tif (adapter->params.fw_vers)\n\t\tsnprintf(info->fw_version, sizeof(info->fw_version),\n\t\t\t \"%u.%u.%u.%u, TP %u.%u.%u.%u\",\n\t\t\t FW_HDR_FW_VER_MAJOR_G(adapter->params.fw_vers),\n\t\t\t FW_HDR_FW_VER_MINOR_G(adapter->params.fw_vers),\n\t\t\t FW_HDR_FW_VER_MICRO_G(adapter->params.fw_vers),\n\t\t\t FW_HDR_FW_VER_BUILD_G(adapter->params.fw_vers),\n\t\t\t FW_HDR_FW_VER_MAJOR_G(adapter->params.tp_vers),\n\t\t\t FW_HDR_FW_VER_MINOR_G(adapter->params.tp_vers),\n\t\t\t FW_HDR_FW_VER_MICRO_G(adapter->params.tp_vers),\n\t\t\t FW_HDR_FW_VER_BUILD_G(adapter->params.tp_vers));\n\n\tif (!t4_get_exprom_version(adapter, &exprom_vers))\n\t\tsnprintf(info->erom_version, sizeof(info->erom_version),\n\t\t\t \"%u.%u.%u.%u\",\n\t\t\t FW_HDR_FW_VER_MAJOR_G(exprom_vers),\n\t\t\t FW_HDR_FW_VER_MINOR_G(exprom_vers),\n\t\t\t FW_HDR_FW_VER_MICRO_G(exprom_vers),\n\t\t\t FW_HDR_FW_VER_BUILD_G(exprom_vers));\n\tinfo->n_priv_flags = ARRAY_SIZE(cxgb4_priv_flags_strings);\n}\n\nstatic void get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tif (stringset == ETH_SS_STATS) {\n\t\tmemcpy(data, stats_strings, sizeof(stats_strings));\n\t\tdata += sizeof(stats_strings);\n\t\tmemcpy(data, adapter_stats_strings,\n\t\t       sizeof(adapter_stats_strings));\n\t\tdata += sizeof(adapter_stats_strings);\n\t\tmemcpy(data, loopback_stats_strings,\n\t\t       sizeof(loopback_stats_strings));\n\t} else if (stringset == ETH_SS_PRIV_FLAGS) {\n\t\tmemcpy(data, cxgb4_priv_flags_strings,\n\t\t       sizeof(cxgb4_priv_flags_strings));\n\t} else if (stringset == ETH_SS_TEST) {\n\t\tmemcpy(data, cxgb4_selftest_strings,\n\t\t       sizeof(cxgb4_selftest_strings));\n\t}\n}\n\n \nstruct queue_port_stats {\n\tu64 tso;\n\tu64 uso;\n\tu64 tx_csum;\n\tu64 rx_csum;\n\tu64 vlan_ex;\n\tu64 vlan_ins;\n\tu64 gro_pkts;\n\tu64 gro_merged;\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n\tu64 tx_tls_encrypted_packets;\n\tu64 tx_tls_encrypted_bytes;\n\tu64 tx_tls_ctx;\n\tu64 tx_tls_ooo;\n\tu64 tx_tls_skip_no_sync_data;\n\tu64 tx_tls_drop_no_sync_data;\n\tu64 tx_tls_drop_bypass_req;\n#endif\n};\n\nstruct adapter_stats {\n\tu64 db_drop;\n\tu64 db_full;\n\tu64 db_empty;\n\tu64 wc_success;\n\tu64 wc_fail;\n};\n\nstatic void collect_sge_port_stats(const struct adapter *adap,\n\t\t\t\t   const struct port_info *p,\n\t\t\t\t   struct queue_port_stats *s)\n{\n\tconst struct sge_eth_txq *tx = &adap->sge.ethtxq[p->first_qset];\n\tconst struct sge_eth_rxq *rx = &adap->sge.ethrxq[p->first_qset];\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n\tconst struct ch_ktls_port_stats_debug *ktls_stats;\n#endif\n\tstruct sge_eohw_txq *eohw_tx;\n\tunsigned int i;\n\n\tmemset(s, 0, sizeof(*s));\n\tfor (i = 0; i < p->nqsets; i++, rx++, tx++) {\n\t\ts->tso += tx->tso;\n\t\ts->uso += tx->uso;\n\t\ts->tx_csum += tx->tx_cso;\n\t\ts->rx_csum += rx->stats.rx_cso;\n\t\ts->vlan_ex += rx->stats.vlan_ex;\n\t\ts->vlan_ins += tx->vlan_ins;\n\t\ts->gro_pkts += rx->stats.lro_pkts;\n\t\ts->gro_merged += rx->stats.lro_merged;\n\t}\n\n\tif (adap->sge.eohw_txq) {\n\t\teohw_tx = &adap->sge.eohw_txq[p->first_qset];\n\t\tfor (i = 0; i < p->nqsets; i++, eohw_tx++) {\n\t\t\ts->tso += eohw_tx->tso;\n\t\t\ts->uso += eohw_tx->uso;\n\t\t\ts->tx_csum += eohw_tx->tx_cso;\n\t\t\ts->vlan_ins += eohw_tx->vlan_ins;\n\t\t}\n\t}\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n\tktls_stats = &adap->ch_ktls_stats.ktls_port[p->port_id];\n\ts->tx_tls_encrypted_packets =\n\t\tatomic64_read(&ktls_stats->ktls_tx_encrypted_packets);\n\ts->tx_tls_encrypted_bytes =\n\t\tatomic64_read(&ktls_stats->ktls_tx_encrypted_bytes);\n\ts->tx_tls_ctx = atomic64_read(&ktls_stats->ktls_tx_ctx);\n\ts->tx_tls_ooo = atomic64_read(&ktls_stats->ktls_tx_ooo);\n\ts->tx_tls_skip_no_sync_data =\n\t\tatomic64_read(&ktls_stats->ktls_tx_skip_no_sync_data);\n\ts->tx_tls_drop_no_sync_data =\n\t\tatomic64_read(&ktls_stats->ktls_tx_drop_no_sync_data);\n\ts->tx_tls_drop_bypass_req =\n\t\tatomic64_read(&ktls_stats->ktls_tx_drop_bypass_req);\n#endif\n}\n\nstatic void collect_adapter_stats(struct adapter *adap, struct adapter_stats *s)\n{\n\tu64 val1, val2;\n\n\tmemset(s, 0, sizeof(*s));\n\n\ts->db_drop = adap->db_stats.db_drop;\n\ts->db_full = adap->db_stats.db_full;\n\ts->db_empty = adap->db_stats.db_empty;\n\n\tif (!is_t4(adap->params.chip)) {\n\t\tint v;\n\n\t\tv = t4_read_reg(adap, SGE_STAT_CFG_A);\n\t\tif (STATSOURCE_T5_G(v) == 7) {\n\t\t\tval2 = t4_read_reg(adap, SGE_STAT_MATCH_A);\n\t\t\tval1 = t4_read_reg(adap, SGE_STAT_TOTAL_A);\n\t\t\ts->wc_success = val1 - val2;\n\t\t\ts->wc_fail = val2;\n\t\t}\n\t}\n}\n\nstatic void get_stats(struct net_device *dev, struct ethtool_stats *stats,\n\t\t      u64 *data)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tstruct lb_port_stats s;\n\tint i;\n\tu64 *p0;\n\n\tt4_get_port_stats_offset(adapter, pi->tx_chan,\n\t\t\t\t (struct port_stats *)data,\n\t\t\t\t &pi->stats_base);\n\n\tdata += sizeof(struct port_stats) / sizeof(u64);\n\tcollect_sge_port_stats(adapter, pi, (struct queue_port_stats *)data);\n\tdata += sizeof(struct queue_port_stats) / sizeof(u64);\n\tcollect_adapter_stats(adapter, (struct adapter_stats *)data);\n\tdata += sizeof(struct adapter_stats) / sizeof(u64);\n\n\t*data++ = (u64)pi->port_id;\n\tmemset(&s, 0, sizeof(s));\n\tt4_get_lb_stats(adapter, pi->port_id, &s);\n\n\tp0 = &s.octets;\n\tfor (i = 0; i < ARRAY_SIZE(loopback_stats_strings) - 1; i++)\n\t\t*data++ = (unsigned long long)*p0++;\n}\n\nstatic void get_regs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t     void *buf)\n{\n\tstruct adapter *adap = netdev2adap(dev);\n\tsize_t buf_size;\n\n\tbuf_size = t4_get_regs_len(adap);\n\tregs->version = mk_adap_vers(adap);\n\tt4_get_regs(adap, buf, buf_size);\n}\n\nstatic int restart_autoneg(struct net_device *dev)\n{\n\tstruct port_info *p = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn -EAGAIN;\n\tif (p->link_cfg.autoneg != AUTONEG_ENABLE)\n\t\treturn -EINVAL;\n\tt4_restart_aneg(p->adapter, p->adapter->pf, p->tx_chan);\n\treturn 0;\n}\n\nstatic int identify_port(struct net_device *dev,\n\t\t\t enum ethtool_phys_id_state state)\n{\n\tunsigned int val;\n\tstruct adapter *adap = netdev2adap(dev);\n\n\tif (state == ETHTOOL_ID_ACTIVE)\n\t\tval = 0xffff;\n\telse if (state == ETHTOOL_ID_INACTIVE)\n\t\tval = 0;\n\telse\n\t\treturn -EINVAL;\n\n\treturn t4_identify_port(adap, adap->pf, netdev2pinfo(dev)->viid, val);\n}\n\n \nstatic int from_fw_port_mod_type(enum fw_port_type port_type,\n\t\t\t\t enum fw_port_module_type mod_type)\n{\n\tif (port_type == FW_PORT_TYPE_BT_SGMII ||\n\t    port_type == FW_PORT_TYPE_BT_XFI ||\n\t    port_type == FW_PORT_TYPE_BT_XAUI) {\n\t\treturn PORT_TP;\n\t} else if (port_type == FW_PORT_TYPE_FIBER_XFI ||\n\t\t   port_type == FW_PORT_TYPE_FIBER_XAUI) {\n\t\treturn PORT_FIBRE;\n\t} else if (port_type == FW_PORT_TYPE_SFP ||\n\t\t   port_type == FW_PORT_TYPE_QSFP_10G ||\n\t\t   port_type == FW_PORT_TYPE_QSA ||\n\t\t   port_type == FW_PORT_TYPE_QSFP ||\n\t\t   port_type == FW_PORT_TYPE_CR4_QSFP ||\n\t\t   port_type == FW_PORT_TYPE_CR_QSFP ||\n\t\t   port_type == FW_PORT_TYPE_CR2_QSFP ||\n\t\t   port_type == FW_PORT_TYPE_SFP28) {\n\t\tif (mod_type == FW_PORT_MOD_TYPE_LR ||\n\t\t    mod_type == FW_PORT_MOD_TYPE_SR ||\n\t\t    mod_type == FW_PORT_MOD_TYPE_ER ||\n\t\t    mod_type == FW_PORT_MOD_TYPE_LRM)\n\t\t\treturn PORT_FIBRE;\n\t\telse if (mod_type == FW_PORT_MOD_TYPE_TWINAX_PASSIVE ||\n\t\t\t mod_type == FW_PORT_MOD_TYPE_TWINAX_ACTIVE)\n\t\t\treturn PORT_DA;\n\t\telse\n\t\t\treturn PORT_OTHER;\n\t} else if (port_type == FW_PORT_TYPE_KR4_100G ||\n\t\t   port_type == FW_PORT_TYPE_KR_SFP28 ||\n\t\t   port_type == FW_PORT_TYPE_KR_XLAUI) {\n\t\treturn PORT_NONE;\n\t}\n\n\treturn PORT_OTHER;\n}\n\n \nstatic unsigned int speed_to_fw_caps(int speed)\n{\n\tif (speed == 100)\n\t\treturn FW_PORT_CAP32_SPEED_100M;\n\tif (speed == 1000)\n\t\treturn FW_PORT_CAP32_SPEED_1G;\n\tif (speed == 10000)\n\t\treturn FW_PORT_CAP32_SPEED_10G;\n\tif (speed == 25000)\n\t\treturn FW_PORT_CAP32_SPEED_25G;\n\tif (speed == 40000)\n\t\treturn FW_PORT_CAP32_SPEED_40G;\n\tif (speed == 50000)\n\t\treturn FW_PORT_CAP32_SPEED_50G;\n\tif (speed == 100000)\n\t\treturn FW_PORT_CAP32_SPEED_100G;\n\tif (speed == 200000)\n\t\treturn FW_PORT_CAP32_SPEED_200G;\n\tif (speed == 400000)\n\t\treturn FW_PORT_CAP32_SPEED_400G;\n\treturn 0;\n}\n\n \nstatic void fw_caps_to_lmm(enum fw_port_type port_type,\n\t\t\t   fw_port_cap32_t fw_caps,\n\t\t\t   unsigned long *link_mode_mask)\n{\n\t#define SET_LMM(__lmm_name) \\\n\t\tdo { \\\n\t\t\t__set_bit(ETHTOOL_LINK_MODE_ ## __lmm_name ## _BIT, \\\n\t\t\t\t  link_mode_mask); \\\n\t\t} while (0)\n\n\t#define FW_CAPS_TO_LMM(__fw_name, __lmm_name) \\\n\t\tdo { \\\n\t\t\tif (fw_caps & FW_PORT_CAP32_ ## __fw_name) \\\n\t\t\t\tSET_LMM(__lmm_name); \\\n\t\t} while (0)\n\n\tswitch (port_type) {\n\tcase FW_PORT_TYPE_BT_SGMII:\n\tcase FW_PORT_TYPE_BT_XFI:\n\tcase FW_PORT_TYPE_BT_XAUI:\n\t\tSET_LMM(TP);\n\t\tFW_CAPS_TO_LMM(SPEED_100M, 100baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseT_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_KX4:\n\tcase FW_PORT_TYPE_KX:\n\t\tSET_LMM(Backplane);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseKX_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKX4_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_KR:\n\t\tSET_LMM(Backplane);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKR_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_BP_AP:\n\t\tSET_LMM(Backplane);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseKX_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseR_FEC);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKR_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_BP4_AP:\n\t\tSET_LMM(Backplane);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseKX_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseR_FEC);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKR_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKX4_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_FIBER_XFI:\n\tcase FW_PORT_TYPE_FIBER_XAUI:\n\tcase FW_PORT_TYPE_SFP:\n\tcase FW_PORT_TYPE_QSFP_10G:\n\tcase FW_PORT_TYPE_QSA:\n\t\tSET_LMM(FIBRE);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseT_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_BP40_BA:\n\tcase FW_PORT_TYPE_QSFP:\n\t\tSET_LMM(FIBRE);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_40G, 40000baseSR4_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_CR_QSFP:\n\tcase FW_PORT_TYPE_SFP28:\n\t\tSET_LMM(FIBRE);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_25G, 25000baseCR_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_KR_SFP28:\n\t\tSET_LMM(Backplane);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKR_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_25G, 25000baseKR_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_KR_XLAUI:\n\t\tSET_LMM(Backplane);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseKX_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKR_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_40G, 40000baseKR4_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_CR2_QSFP:\n\t\tSET_LMM(FIBRE);\n\t\tFW_CAPS_TO_LMM(SPEED_50G, 50000baseSR2_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_KR4_100G:\n\tcase FW_PORT_TYPE_CR4_QSFP:\n\t\tSET_LMM(FIBRE);\n\t\tFW_CAPS_TO_LMM(SPEED_1G,  1000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKR_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_40G, 40000baseSR4_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_25G, 25000baseCR_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_50G, 50000baseCR2_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_100G, 100000baseCR4_Full);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (fw_caps & FW_PORT_CAP32_FEC_V(FW_PORT_CAP32_FEC_M)) {\n\t\tFW_CAPS_TO_LMM(FEC_RS, FEC_RS);\n\t\tFW_CAPS_TO_LMM(FEC_BASER_RS, FEC_BASER);\n\t} else {\n\t\tSET_LMM(FEC_NONE);\n\t}\n\n\tFW_CAPS_TO_LMM(ANEG, Autoneg);\n\tFW_CAPS_TO_LMM(802_3_PAUSE, Pause);\n\tFW_CAPS_TO_LMM(802_3_ASM_DIR, Asym_Pause);\n\n\t#undef FW_CAPS_TO_LMM\n\t#undef SET_LMM\n}\n\n \nstatic unsigned int lmm_to_fw_caps(const unsigned long *link_mode_mask)\n{\n\tunsigned int fw_caps = 0;\n\n\t#define LMM_TO_FW_CAPS(__lmm_name, __fw_name) \\\n\t\tdo { \\\n\t\t\tif (test_bit(ETHTOOL_LINK_MODE_ ## __lmm_name ## _BIT, \\\n\t\t\t\t     link_mode_mask)) \\\n\t\t\t\tfw_caps |= FW_PORT_CAP32_ ## __fw_name; \\\n\t\t} while (0)\n\n\tLMM_TO_FW_CAPS(100baseT_Full, SPEED_100M);\n\tLMM_TO_FW_CAPS(1000baseT_Full, SPEED_1G);\n\tLMM_TO_FW_CAPS(10000baseT_Full, SPEED_10G);\n\tLMM_TO_FW_CAPS(40000baseSR4_Full, SPEED_40G);\n\tLMM_TO_FW_CAPS(25000baseCR_Full, SPEED_25G);\n\tLMM_TO_FW_CAPS(50000baseCR2_Full, SPEED_50G);\n\tLMM_TO_FW_CAPS(100000baseCR4_Full, SPEED_100G);\n\n\t#undef LMM_TO_FW_CAPS\n\n\treturn fw_caps;\n}\n\nstatic int get_link_ksettings(struct net_device *dev,\n\t\t\t      struct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct ethtool_link_settings *base = &link_ksettings->base;\n\n\t \n\tif (!netif_running(dev))\n\t\t(void)t4_update_port_info(pi);\n\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, supported);\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, advertising);\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, lp_advertising);\n\n\tbase->port = from_fw_port_mod_type(pi->port_type, pi->mod_type);\n\n\tif (pi->mdio_addr >= 0) {\n\t\tbase->phy_address = pi->mdio_addr;\n\t\tbase->mdio_support = (pi->port_type == FW_PORT_TYPE_BT_SGMII\n\t\t\t\t      ? ETH_MDIO_SUPPORTS_C22\n\t\t\t\t      : ETH_MDIO_SUPPORTS_C45);\n\t} else {\n\t\tbase->phy_address = 255;\n\t\tbase->mdio_support = 0;\n\t}\n\n\tfw_caps_to_lmm(pi->port_type, pi->link_cfg.pcaps,\n\t\t       link_ksettings->link_modes.supported);\n\tfw_caps_to_lmm(pi->port_type,\n\t\t       t4_link_acaps(pi->adapter,\n\t\t\t\t     pi->lport,\n\t\t\t\t     &pi->link_cfg),\n\t\t       link_ksettings->link_modes.advertising);\n\tfw_caps_to_lmm(pi->port_type, pi->link_cfg.lpacaps,\n\t\t       link_ksettings->link_modes.lp_advertising);\n\n\tbase->speed = (netif_carrier_ok(dev)\n\t\t       ? pi->link_cfg.speed\n\t\t       : SPEED_UNKNOWN);\n\tbase->duplex = DUPLEX_FULL;\n\n\tbase->autoneg = pi->link_cfg.autoneg;\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_ANEG)\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     supported, Autoneg);\n\tif (pi->link_cfg.autoneg)\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, Autoneg);\n\n\treturn 0;\n}\n\nstatic int set_link_ksettings(struct net_device *dev,\n\t\t\t    const struct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct link_config *lc = &pi->link_cfg;\n\tconst struct ethtool_link_settings *base = &link_ksettings->base;\n\tstruct link_config old_lc;\n\tunsigned int fw_caps;\n\tint ret = 0;\n\n\t \n\tif (base->duplex != DUPLEX_FULL)\n\t\treturn -EINVAL;\n\n\told_lc = *lc;\n\tif (!(lc->pcaps & FW_PORT_CAP32_ANEG) ||\n\t    base->autoneg == AUTONEG_DISABLE) {\n\t\tfw_caps = speed_to_fw_caps(base->speed);\n\n\t\t \n\t\tif (!(lc->pcaps & fw_caps))\n\t\t\treturn -EINVAL;\n\n\t\tlc->speed_caps = fw_caps;\n\t\tlc->acaps = fw_caps;\n\t} else {\n\t\tfw_caps =\n\t\t\tlmm_to_fw_caps(link_ksettings->link_modes.advertising);\n\t\tif (!(lc->pcaps & fw_caps))\n\t\t\treturn -EINVAL;\n\t\tlc->speed_caps = 0;\n\t\tlc->acaps = fw_caps | FW_PORT_CAP32_ANEG;\n\t}\n\tlc->autoneg = base->autoneg;\n\n\t \n\tret = t4_link_l1cfg(pi->adapter, pi->adapter->mbox, pi->tx_chan, lc);\n\tif (ret)\n\t\t*lc = old_lc;\n\n\treturn ret;\n}\n\n \nstatic inline unsigned int fwcap_to_eth_fec(unsigned int fw_fec)\n{\n\tunsigned int eth_fec = 0;\n\n\tif (fw_fec & FW_PORT_CAP32_FEC_RS)\n\t\teth_fec |= ETHTOOL_FEC_RS;\n\tif (fw_fec & FW_PORT_CAP32_FEC_BASER_RS)\n\t\teth_fec |= ETHTOOL_FEC_BASER;\n\n\t \n\tif (!eth_fec)\n\t\teth_fec = ETHTOOL_FEC_OFF;\n\n\treturn eth_fec;\n}\n\n \nstatic inline unsigned int cc_to_eth_fec(unsigned int cc_fec)\n{\n\tunsigned int eth_fec = 0;\n\n\tif (cc_fec & FEC_AUTO)\n\t\teth_fec |= ETHTOOL_FEC_AUTO;\n\tif (cc_fec & FEC_RS)\n\t\teth_fec |= ETHTOOL_FEC_RS;\n\tif (cc_fec & FEC_BASER_RS)\n\t\teth_fec |= ETHTOOL_FEC_BASER;\n\n\t \n\tif (!eth_fec)\n\t\teth_fec = ETHTOOL_FEC_OFF;\n\n\treturn eth_fec;\n}\n\n \nstatic inline unsigned int eth_to_cc_fec(unsigned int eth_fec)\n{\n\tunsigned int cc_fec = 0;\n\n\tif (eth_fec & ETHTOOL_FEC_OFF)\n\t\treturn cc_fec;\n\n\tif (eth_fec & ETHTOOL_FEC_AUTO)\n\t\tcc_fec |= FEC_AUTO;\n\tif (eth_fec & ETHTOOL_FEC_RS)\n\t\tcc_fec |= FEC_RS;\n\tif (eth_fec & ETHTOOL_FEC_BASER)\n\t\tcc_fec |= FEC_BASER_RS;\n\n\treturn cc_fec;\n}\n\nstatic int get_fecparam(struct net_device *dev, struct ethtool_fecparam *fec)\n{\n\tconst struct port_info *pi = netdev_priv(dev);\n\tconst struct link_config *lc = &pi->link_cfg;\n\n\t \n\tfec->fec = fwcap_to_eth_fec(lc->pcaps);\n\tif (fec->fec != ETHTOOL_FEC_OFF)\n\t\tfec->fec |= ETHTOOL_FEC_AUTO;\n\n\t \n\tfec->active_fec = cc_to_eth_fec(lc->fec);\n\n\treturn 0;\n}\n\nstatic int set_fecparam(struct net_device *dev, struct ethtool_fecparam *fec)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct link_config *lc = &pi->link_cfg;\n\tstruct link_config old_lc;\n\tint ret;\n\n\t \n\told_lc = *lc;\n\n\t \n\tlc->requested_fec = eth_to_cc_fec(fec->fec);\n\tret = t4_link_l1cfg(pi->adapter, pi->adapter->mbox,\n\t\t\t    pi->tx_chan, lc);\n\tif (ret)\n\t\t*lc = old_lc;\n\treturn ret;\n}\n\nstatic void get_pauseparam(struct net_device *dev,\n\t\t\t   struct ethtool_pauseparam *epause)\n{\n\tstruct port_info *p = netdev_priv(dev);\n\n\tepause->autoneg = (p->link_cfg.requested_fc & PAUSE_AUTONEG) != 0;\n\tepause->rx_pause = (p->link_cfg.advertised_fc & PAUSE_RX) != 0;\n\tepause->tx_pause = (p->link_cfg.advertised_fc & PAUSE_TX) != 0;\n}\n\nstatic int set_pauseparam(struct net_device *dev,\n\t\t\t  struct ethtool_pauseparam *epause)\n{\n\tstruct port_info *p = netdev_priv(dev);\n\tstruct link_config *lc = &p->link_cfg;\n\n\tif (epause->autoneg == AUTONEG_DISABLE)\n\t\tlc->requested_fc = 0;\n\telse if (lc->pcaps & FW_PORT_CAP32_ANEG)\n\t\tlc->requested_fc = PAUSE_AUTONEG;\n\telse\n\t\treturn -EINVAL;\n\n\tif (epause->rx_pause)\n\t\tlc->requested_fc |= PAUSE_RX;\n\tif (epause->tx_pause)\n\t\tlc->requested_fc |= PAUSE_TX;\n\tif (netif_running(dev))\n\t\treturn t4_link_l1cfg(p->adapter, p->adapter->mbox, p->tx_chan,\n\t\t\t\t     lc);\n\treturn 0;\n}\n\nstatic void get_sge_param(struct net_device *dev, struct ethtool_ringparam *e,\n\t\t\t  struct kernel_ethtool_ringparam *kernel_e,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tconst struct port_info *pi = netdev_priv(dev);\n\tconst struct sge *s = &pi->adapter->sge;\n\n\te->rx_max_pending = MAX_RX_BUFFERS;\n\te->rx_mini_max_pending = MAX_RSPQ_ENTRIES;\n\te->rx_jumbo_max_pending = 0;\n\te->tx_max_pending = MAX_TXQ_ENTRIES;\n\n\te->rx_pending = s->ethrxq[pi->first_qset].fl.size - 8;\n\te->rx_mini_pending = s->ethrxq[pi->first_qset].rspq.size;\n\te->rx_jumbo_pending = 0;\n\te->tx_pending = s->ethtxq[pi->first_qset].q.size;\n}\n\nstatic int set_sge_param(struct net_device *dev, struct ethtool_ringparam *e,\n\t\t\t struct kernel_ethtool_ringparam *kernel_e,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tint i;\n\tconst struct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tstruct sge *s = &adapter->sge;\n\n\tif (e->rx_pending > MAX_RX_BUFFERS || e->rx_jumbo_pending ||\n\t    e->tx_pending > MAX_TXQ_ENTRIES ||\n\t    e->rx_mini_pending > MAX_RSPQ_ENTRIES ||\n\t    e->rx_mini_pending < MIN_RSPQ_ENTRIES ||\n\t    e->rx_pending < MIN_FL_ENTRIES || e->tx_pending < MIN_TXQ_ENTRIES)\n\t\treturn -EINVAL;\n\n\tif (adapter->flags & CXGB4_FULL_INIT_DONE)\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < pi->nqsets; ++i) {\n\t\ts->ethtxq[pi->first_qset + i].q.size = e->tx_pending;\n\t\ts->ethrxq[pi->first_qset + i].fl.size = e->rx_pending + 8;\n\t\ts->ethrxq[pi->first_qset + i].rspq.size = e->rx_mini_pending;\n\t}\n\treturn 0;\n}\n\n \nstatic int set_rx_intr_params(struct net_device *dev,\n\t\t\t      unsigned int us, unsigned int cnt)\n{\n\tint i, err;\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tstruct sge_eth_rxq *q = &adap->sge.ethrxq[pi->first_qset];\n\n\tfor (i = 0; i < pi->nqsets; i++, q++) {\n\t\terr = cxgb4_set_rspq_intr_params(&q->rspq, us, cnt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int set_adaptive_rx_setting(struct net_device *dev, int adaptive_rx)\n{\n\tint i;\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tstruct sge_eth_rxq *q = &adap->sge.ethrxq[pi->first_qset];\n\n\tfor (i = 0; i < pi->nqsets; i++, q++)\n\t\tq->rspq.adaptive_rx = adaptive_rx;\n\n\treturn 0;\n}\n\nstatic int get_adaptive_rx_setting(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tstruct sge_eth_rxq *q = &adap->sge.ethrxq[pi->first_qset];\n\n\treturn q->rspq.adaptive_rx;\n}\n\n \nstatic int get_dbqtimer_tick(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\n\tif (!(adap->flags & CXGB4_SGE_DBQ_TIMER))\n\t\treturn 0;\n\n\treturn adap->sge.dbqtimer_tick;\n}\n\n \nstatic int get_dbqtimer(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tstruct sge_eth_txq *txq;\n\n\ttxq = &adap->sge.ethtxq[pi->first_qset];\n\n\tif (!(adap->flags & CXGB4_SGE_DBQ_TIMER))\n\t\treturn 0;\n\n\t \n\treturn adap->sge.dbqtimer_val[txq->dbqtimerix];\n}\n\n \nstatic int set_dbqtimer_tick(struct net_device *dev, int usecs)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tstruct sge *s = &adap->sge;\n\tu32 param, val;\n\tint ret;\n\n\tif (!(adap->flags & CXGB4_SGE_DBQ_TIMER))\n\t\treturn 0;\n\n\t \n\tif (s->dbqtimer_tick == usecs)\n\t\treturn 0;\n\n\t \n\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_DBQ_TIMERTICK));\n\tval = usecs;\n\tret = t4_set_params(adap, adap->mbox, adap->pf, 0, 1, &param, &val);\n\tif (ret)\n\t\treturn ret;\n\ts->dbqtimer_tick = usecs;\n\n\t \n\tret = t4_read_sge_dbqtimers(adap, ARRAY_SIZE(s->dbqtimer_val),\n\t\t\t\t    s->dbqtimer_val);\n\treturn ret;\n}\n\n \nstatic int set_dbqtimer(struct net_device *dev, int usecs)\n{\n\tint qix, timerix, min_timerix, delta, min_delta;\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tstruct sge *s = &adap->sge;\n\tstruct sge_eth_txq *txq;\n\tu32 param, val;\n\tint ret;\n\n\tif (!(adap->flags & CXGB4_SGE_DBQ_TIMER))\n\t\treturn 0;\n\n\t \n\tmin_delta = INT_MAX;\n\tmin_timerix = 0;\n\tfor (timerix = 0; timerix < ARRAY_SIZE(s->dbqtimer_val); timerix++) {\n\t\tdelta = s->dbqtimer_val[timerix] - usecs;\n\t\tif (delta < 0)\n\t\t\tdelta = -delta;\n\t\tif (delta < min_delta) {\n\t\t\tmin_delta = delta;\n\t\t\tmin_timerix = timerix;\n\t\t}\n\t}\n\n\t \n\ttxq = &s->ethtxq[pi->first_qset];\n\tif (txq->dbqtimerix == min_timerix)\n\t\treturn 0;\n\n\tfor (qix = 0; qix < pi->nqsets; qix++, txq++) {\n\t\tif (adap->flags & CXGB4_FULL_INIT_DONE) {\n\t\t\tparam =\n\t\t\t (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DMAQ) |\n\t\t\t  FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DMAQ_EQ_TIMERIX) |\n\t\t\t  FW_PARAMS_PARAM_YZ_V(txq->q.cntxt_id));\n\t\t\tval = min_timerix;\n\t\t\tret = t4_set_params(adap, adap->mbox, adap->pf, 0,\n\t\t\t\t\t    1, &param, &val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\ttxq->dbqtimerix = min_timerix;\n\t}\n\treturn 0;\n}\n\n \nstatic int set_dbqtimer_tickval(struct net_device *dev,\n\t\t\t\tint tick_usecs, int timer_usecs)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint timer[MAX_NPORTS];\n\tunsigned int port;\n\tint ret;\n\n\t \n\tfor_each_port(adap, port)\n\t\tif (port == pi->port_id)\n\t\t\ttimer[port] = timer_usecs;\n\t\telse\n\t\t\ttimer[port] = get_dbqtimer(adap->port[port]);\n\n\t \n\tret = set_dbqtimer_tick(dev, tick_usecs);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor_each_port(adap, port) {\n\t\tret = set_dbqtimer(adap->port[port], timer[port]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_coalesce(struct net_device *dev,\n\t\t\tstruct ethtool_coalesce *coalesce,\n\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tint ret;\n\n\tset_adaptive_rx_setting(dev, coalesce->use_adaptive_rx_coalesce);\n\n\tret = set_rx_intr_params(dev, coalesce->rx_coalesce_usecs,\n\t\t\t\t coalesce->rx_max_coalesced_frames);\n\tif (ret)\n\t\treturn ret;\n\n\treturn set_dbqtimer_tickval(dev,\n\t\t\t\t    coalesce->tx_coalesce_usecs_irq,\n\t\t\t\t    coalesce->tx_coalesce_usecs);\n}\n\nstatic int get_coalesce(struct net_device *dev, struct ethtool_coalesce *c,\n\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst struct port_info *pi = netdev_priv(dev);\n\tconst struct adapter *adap = pi->adapter;\n\tconst struct sge_rspq *rq = &adap->sge.ethrxq[pi->first_qset].rspq;\n\n\tc->rx_coalesce_usecs = qtimer_val(adap, rq);\n\tc->rx_max_coalesced_frames = (rq->intr_params & QINTR_CNT_EN_F) ?\n\t\tadap->sge.counter_val[rq->pktcnt_idx] : 0;\n\tc->use_adaptive_rx_coalesce = get_adaptive_rx_setting(dev);\n\tc->tx_coalesce_usecs_irq = get_dbqtimer_tick(dev);\n\tc->tx_coalesce_usecs = get_dbqtimer(dev);\n\treturn 0;\n}\n\n \nstatic int eeprom_rd_phys(struct adapter *adap, unsigned int phys_addr, u32 *v)\n{\n\tint vaddr = t4_eeprom_ptov(phys_addr, adap->pf, EEPROMPFSIZE);\n\n\tif (vaddr >= 0)\n\t\tvaddr = pci_read_vpd(adap->pdev, vaddr, sizeof(u32), v);\n\treturn vaddr < 0 ? vaddr : 0;\n}\n\nstatic int eeprom_wr_phys(struct adapter *adap, unsigned int phys_addr, u32 v)\n{\n\tint vaddr = t4_eeprom_ptov(phys_addr, adap->pf, EEPROMPFSIZE);\n\n\tif (vaddr >= 0)\n\t\tvaddr = pci_write_vpd(adap->pdev, vaddr, sizeof(u32), &v);\n\treturn vaddr < 0 ? vaddr : 0;\n}\n\n#define EEPROM_MAGIC 0x38E2F10C\n\nstatic int get_eeprom(struct net_device *dev, struct ethtool_eeprom *e,\n\t\t      u8 *data)\n{\n\tint i, err = 0;\n\tstruct adapter *adapter = netdev2adap(dev);\n\tu8 *buf = kvzalloc(EEPROMSIZE, GFP_KERNEL);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\te->magic = EEPROM_MAGIC;\n\tfor (i = e->offset & ~3; !err && i < e->offset + e->len; i += 4)\n\t\terr = eeprom_rd_phys(adapter, i, (u32 *)&buf[i]);\n\n\tif (!err)\n\t\tmemcpy(data, buf + e->offset, e->len);\n\tkvfree(buf);\n\treturn err;\n}\n\nstatic int set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\n\t\t      u8 *data)\n{\n\tu8 *buf;\n\tint err = 0;\n\tu32 aligned_offset, aligned_len, *p;\n\tstruct adapter *adapter = netdev2adap(dev);\n\n\tif (eeprom->magic != EEPROM_MAGIC)\n\t\treturn -EINVAL;\n\n\taligned_offset = eeprom->offset & ~3;\n\taligned_len = (eeprom->len + (eeprom->offset & 3) + 3) & ~3;\n\n\tif (adapter->pf > 0) {\n\t\tu32 start = 1024 + adapter->pf * EEPROMPFSIZE;\n\n\t\tif (aligned_offset < start ||\n\t\t    aligned_offset + aligned_len > start + EEPROMPFSIZE)\n\t\t\treturn -EPERM;\n\t}\n\n\tif (aligned_offset != eeprom->offset || aligned_len != eeprom->len) {\n\t\t \n\t\tbuf = kvzalloc(aligned_len, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\terr = eeprom_rd_phys(adapter, aligned_offset, (u32 *)buf);\n\t\tif (!err && aligned_len > 4)\n\t\t\terr = eeprom_rd_phys(adapter,\n\t\t\t\t\t     aligned_offset + aligned_len - 4,\n\t\t\t\t\t     (u32 *)&buf[aligned_len - 4]);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tmemcpy(buf + (eeprom->offset & 3), data, eeprom->len);\n\t} else {\n\t\tbuf = data;\n\t}\n\n\terr = t4_seeprom_wp(adapter, false);\n\tif (err)\n\t\tgoto out;\n\n\tfor (p = (u32 *)buf; !err && aligned_len; aligned_len -= 4, p++) {\n\t\terr = eeprom_wr_phys(adapter, aligned_offset, *p);\n\t\taligned_offset += 4;\n\t}\n\n\tif (!err)\n\t\terr = t4_seeprom_wp(adapter, true);\nout:\n\tif (buf != data)\n\t\tkvfree(buf);\n\treturn err;\n}\n\nstatic int cxgb4_ethtool_flash_bootcfg(struct net_device *netdev,\n\t\t\t\t       const u8 *data, u32 size)\n{\n\tstruct adapter *adap = netdev2adap(netdev);\n\tint ret;\n\n\tret = t4_load_bootcfg(adap, data, size);\n\tif (ret)\n\t\tdev_err(adap->pdev_dev, \"Failed to load boot cfg image\\n\");\n\n\treturn ret;\n}\n\nstatic int cxgb4_ethtool_flash_boot(struct net_device *netdev,\n\t\t\t\t    const u8 *bdata, u32 size)\n{\n\tstruct adapter *adap = netdev2adap(netdev);\n\tunsigned int offset;\n\tu8 *data;\n\tint ret;\n\n\tdata = kmemdup(bdata, size, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\toffset = OFFSET_G(t4_read_reg(adap, PF_REG(0, PCIE_PF_EXPROM_OFST_A)));\n\n\tret = t4_load_boot(adap, data, offset, size);\n\tif (ret)\n\t\tdev_err(adap->pdev_dev, \"Failed to load boot image\\n\");\n\n\tkfree(data);\n\treturn ret;\n}\n\n#define CXGB4_PHY_SIG 0x130000ea\n\nstatic int cxgb4_validate_phy_image(const u8 *data, u32 *size)\n{\n\tstruct cxgb4_fw_data *header;\n\n\theader = (struct cxgb4_fw_data *)data;\n\tif (be32_to_cpu(header->signature) != CXGB4_PHY_SIG)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cxgb4_ethtool_flash_phy(struct net_device *netdev,\n\t\t\t\t   const u8 *data, u32 size)\n{\n\tstruct adapter *adap = netdev2adap(netdev);\n\tint ret;\n\n\tret = cxgb4_validate_phy_image(data, NULL);\n\tif (ret) {\n\t\tdev_err(adap->pdev_dev, \"PHY signature mismatch\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = t4_fw_reset(adap, adap->mbox, PIORSTMODE_F | PIORST_F);\n\tif (ret < 0) {\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Set FW to RESET for flashing PHY FW failed. ret: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = t4_load_phy_fw(adap, MEMWIN_NIC, NULL, data, size);\n\tif (ret < 0) {\n\t\tdev_err(adap->pdev_dev, \"Failed to load PHY FW. ret: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxgb4_ethtool_flash_fw(struct net_device *netdev,\n\t\t\t\t  const u8 *data, u32 size)\n{\n\tstruct adapter *adap = netdev2adap(netdev);\n\tunsigned int mbox = PCIE_FW_MASTER_M + 1;\n\tint ret;\n\n\t \n\tif (adap->flags & CXGB4_FULL_INIT_DONE)\n\t\tmbox = adap->mbox;\n\n\tret = t4_fw_upgrade(adap, mbox, data, size, 1);\n\tif (ret)\n\t\tdev_err(adap->pdev_dev,\n\t\t\t\"Failed to flash firmware\\n\");\n\n\treturn ret;\n}\n\nstatic int cxgb4_ethtool_flash_region(struct net_device *netdev,\n\t\t\t\t      const u8 *data, u32 size, u32 region)\n{\n\tstruct adapter *adap = netdev2adap(netdev);\n\tint ret;\n\n\tswitch (region) {\n\tcase CXGB4_ETHTOOL_FLASH_FW:\n\t\tret = cxgb4_ethtool_flash_fw(netdev, data, size);\n\t\tbreak;\n\tcase CXGB4_ETHTOOL_FLASH_PHY:\n\t\tret = cxgb4_ethtool_flash_phy(netdev, data, size);\n\t\tbreak;\n\tcase CXGB4_ETHTOOL_FLASH_BOOT:\n\t\tret = cxgb4_ethtool_flash_boot(netdev, data, size);\n\t\tbreak;\n\tcase CXGB4_ETHTOOL_FLASH_BOOTCFG:\n\t\tret = cxgb4_ethtool_flash_bootcfg(netdev, data, size);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tdev_info(adap->pdev_dev,\n\t\t\t \"loading %s successful, reload cxgb4 driver\\n\",\n\t\t\t flash_region_strings[region]);\n\treturn ret;\n}\n\n#define CXGB4_FW_SIG 0x4368656c\n#define CXGB4_FW_SIG_OFFSET 0x160\n\nstatic int cxgb4_validate_fw_image(const u8 *data, u32 *size)\n{\n\tstruct cxgb4_fw_data *header;\n\n\theader = (struct cxgb4_fw_data *)&data[CXGB4_FW_SIG_OFFSET];\n\tif (be32_to_cpu(header->signature) != CXGB4_FW_SIG)\n\t\treturn -EINVAL;\n\n\tif (size)\n\t\t*size = be16_to_cpu(((struct fw_hdr *)data)->len512) * 512;\n\n\treturn 0;\n}\n\nstatic int cxgb4_validate_bootcfg_image(const u8 *data, u32 *size)\n{\n\tstruct cxgb4_bootcfg_data *header;\n\n\theader = (struct cxgb4_bootcfg_data *)data;\n\tif (le16_to_cpu(header->signature) != BOOT_CFG_SIG)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cxgb4_validate_boot_image(const u8 *data, u32 *size)\n{\n\tstruct cxgb4_pci_exp_rom_header *exp_header;\n\tstruct cxgb4_pcir_data *pcir_header;\n\tstruct legacy_pci_rom_hdr *header;\n\tconst u8 *cur_header = data;\n\tu16 pcir_offset;\n\n\texp_header = (struct cxgb4_pci_exp_rom_header *)data;\n\n\tif (le16_to_cpu(exp_header->signature) != BOOT_SIGNATURE)\n\t\treturn -EINVAL;\n\n\tif (size) {\n\t\tdo {\n\t\t\theader = (struct legacy_pci_rom_hdr *)cur_header;\n\t\t\tpcir_offset = le16_to_cpu(header->pcir_offset);\n\t\t\tpcir_header = (struct cxgb4_pcir_data *)(cur_header +\n\t\t\t\t      pcir_offset);\n\n\t\t\t*size += header->size512 * 512;\n\t\t\tcur_header += header->size512 * 512;\n\t\t} while (!(pcir_header->indicator & CXGB4_HDR_INDI));\n\t}\n\n\treturn 0;\n}\n\nstatic int cxgb4_ethtool_get_flash_region(const u8 *data, u32 *size)\n{\n\tif (!cxgb4_validate_fw_image(data, size))\n\t\treturn CXGB4_ETHTOOL_FLASH_FW;\n\tif (!cxgb4_validate_boot_image(data, size))\n\t\treturn CXGB4_ETHTOOL_FLASH_BOOT;\n\tif (!cxgb4_validate_phy_image(data, size))\n\t\treturn CXGB4_ETHTOOL_FLASH_PHY;\n\tif (!cxgb4_validate_bootcfg_image(data, size))\n\t\treturn CXGB4_ETHTOOL_FLASH_BOOTCFG;\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int set_flash(struct net_device *netdev, struct ethtool_flash *ef)\n{\n\tstruct adapter *adap = netdev2adap(netdev);\n\tconst struct firmware *fw;\n\tunsigned int master;\n\tu8 master_vld = 0;\n\tconst u8 *fw_data;\n\tsize_t fw_size;\n\tu32 size = 0;\n\tu32 pcie_fw;\n\tint region;\n\tint ret;\n\n\tpcie_fw = t4_read_reg(adap, PCIE_FW_A);\n\tmaster = PCIE_FW_MASTER_G(pcie_fw);\n\tif (pcie_fw & PCIE_FW_MASTER_VLD_F)\n\t\tmaster_vld = 1;\n\t \n\tif (master_vld && (master != adap->pf)) {\n\t\tdev_warn(adap->pdev_dev,\n\t\t\t \"cxgb4 driver needs to be loaded as MASTER to support FW flash\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tef->data[sizeof(ef->data) - 1] = '\\0';\n\tret = request_firmware(&fw, ef->data, adap->pdev_dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfw_data = fw->data;\n\tfw_size = fw->size;\n\tif (ef->region == ETHTOOL_FLASH_ALL_REGIONS) {\n\t\twhile (fw_size > 0) {\n\t\t\tsize = 0;\n\t\t\tregion = cxgb4_ethtool_get_flash_region(fw_data, &size);\n\t\t\tif (region < 0 || !size) {\n\t\t\t\tret = region;\n\t\t\t\tgoto out_free_fw;\n\t\t\t}\n\n\t\t\tret = cxgb4_ethtool_flash_region(netdev, fw_data, size,\n\t\t\t\t\t\t\t region);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_fw;\n\n\t\t\tfw_data += size;\n\t\t\tfw_size -= size;\n\t\t}\n\t} else {\n\t\tret = cxgb4_ethtool_flash_region(netdev, fw_data, fw_size,\n\t\t\t\t\t\t ef->region);\n\t}\n\nout_free_fw:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic int get_ts_info(struct net_device *dev, struct ethtool_ts_info *ts_info)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct  adapter *adapter = pi->adapter;\n\n\tts_info->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\t   SOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\t   SOF_TIMESTAMPING_SOFTWARE;\n\n\tts_info->so_timestamping |= SOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\t    SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\t    SOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tts_info->tx_types = (1 << HWTSTAMP_TX_OFF) |\n\t\t\t    (1 << HWTSTAMP_TX_ON);\n\n\tts_info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t      (1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t\t      (1 << HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\n\t\t\t      (1 << HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\n\t\t\t      (1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\n\t\t\t      (1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ);\n\n\tif (adapter->ptp_clock)\n\t\tts_info->phc_index = ptp_clock_index(adapter->ptp_clock);\n\telse\n\t\tts_info->phc_index = -1;\n\n\treturn 0;\n}\n\nstatic u32 get_rss_table_size(struct net_device *dev)\n{\n\tconst struct port_info *pi = netdev_priv(dev);\n\n\treturn pi->rss_size;\n}\n\nstatic int get_rss_table(struct net_device *dev, u32 *p, u8 *key, u8 *hfunc)\n{\n\tconst struct port_info *pi = netdev_priv(dev);\n\tunsigned int n = pi->rss_size;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\tif (!p)\n\t\treturn 0;\n\twhile (n--)\n\t\tp[n] = pi->rss[n];\n\treturn 0;\n}\n\nstatic int set_rss_table(struct net_device *dev, const u32 *p, const u8 *key,\n\t\t\t const u8 hfunc)\n{\n\tunsigned int i;\n\tstruct port_info *pi = netdev_priv(dev);\n\n\t \n\tif (key ||\n\t    (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))\n\t\treturn -EOPNOTSUPP;\n\tif (!p)\n\t\treturn 0;\n\n\t \n\tif (pi->adapter->flags & CXGB4_FULL_INIT_DONE) {\n\t\tfor (i = 0; i < pi->rss_size; i++)\n\t\t\tpi->rss[i] = p[i];\n\n\t\treturn cxgb4_write_rss(pi, pi->rss);\n\t}\n\n\treturn -EPERM;\n}\n\nstatic struct filter_entry *cxgb4_get_filter_entry(struct adapter *adap,\n\t\t\t\t\t\t   u32 ftid)\n{\n\tstruct tid_info *t = &adap->tids;\n\n\tif (ftid >= t->hpftid_base && ftid < t->hpftid_base + t->nhpftids)\n\t\treturn &t->hpftid_tab[ftid - t->hpftid_base];\n\n\tif (ftid >= t->ftid_base && ftid < t->ftid_base + t->nftids)\n\t\treturn &t->ftid_tab[ftid - t->ftid_base];\n\n\treturn lookup_tid(t, ftid);\n}\n\nstatic void cxgb4_fill_filter_rule(struct ethtool_rx_flow_spec *fs,\n\t\t\t\t   struct ch_filter_specification *dfs)\n{\n\tswitch (dfs->val.proto) {\n\tcase IPPROTO_TCP:\n\t\tif (dfs->type)\n\t\t\tfs->flow_type = TCP_V6_FLOW;\n\t\telse\n\t\t\tfs->flow_type = TCP_V4_FLOW;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tif (dfs->type)\n\t\t\tfs->flow_type = UDP_V6_FLOW;\n\t\telse\n\t\t\tfs->flow_type = UDP_V4_FLOW;\n\t\tbreak;\n\t}\n\n\tif (dfs->type) {\n\t\tfs->h_u.tcp_ip6_spec.psrc = cpu_to_be16(dfs->val.fport);\n\t\tfs->m_u.tcp_ip6_spec.psrc = cpu_to_be16(dfs->mask.fport);\n\t\tfs->h_u.tcp_ip6_spec.pdst = cpu_to_be16(dfs->val.lport);\n\t\tfs->m_u.tcp_ip6_spec.pdst = cpu_to_be16(dfs->mask.lport);\n\t\tmemcpy(&fs->h_u.tcp_ip6_spec.ip6src, &dfs->val.fip[0],\n\t\t       sizeof(fs->h_u.tcp_ip6_spec.ip6src));\n\t\tmemcpy(&fs->m_u.tcp_ip6_spec.ip6src, &dfs->mask.fip[0],\n\t\t       sizeof(fs->m_u.tcp_ip6_spec.ip6src));\n\t\tmemcpy(&fs->h_u.tcp_ip6_spec.ip6dst, &dfs->val.lip[0],\n\t\t       sizeof(fs->h_u.tcp_ip6_spec.ip6dst));\n\t\tmemcpy(&fs->m_u.tcp_ip6_spec.ip6dst, &dfs->mask.lip[0],\n\t\t       sizeof(fs->m_u.tcp_ip6_spec.ip6dst));\n\t\tfs->h_u.tcp_ip6_spec.tclass = dfs->val.tos;\n\t\tfs->m_u.tcp_ip6_spec.tclass = dfs->mask.tos;\n\t} else {\n\t\tfs->h_u.tcp_ip4_spec.psrc = cpu_to_be16(dfs->val.fport);\n\t\tfs->m_u.tcp_ip4_spec.psrc = cpu_to_be16(dfs->mask.fport);\n\t\tfs->h_u.tcp_ip4_spec.pdst = cpu_to_be16(dfs->val.lport);\n\t\tfs->m_u.tcp_ip4_spec.pdst = cpu_to_be16(dfs->mask.lport);\n\t\tmemcpy(&fs->h_u.tcp_ip4_spec.ip4src, &dfs->val.fip[0],\n\t\t       sizeof(fs->h_u.tcp_ip4_spec.ip4src));\n\t\tmemcpy(&fs->m_u.tcp_ip4_spec.ip4src, &dfs->mask.fip[0],\n\t\t       sizeof(fs->m_u.tcp_ip4_spec.ip4src));\n\t\tmemcpy(&fs->h_u.tcp_ip4_spec.ip4dst, &dfs->val.lip[0],\n\t\t       sizeof(fs->h_u.tcp_ip4_spec.ip4dst));\n\t\tmemcpy(&fs->m_u.tcp_ip4_spec.ip4dst, &dfs->mask.lip[0],\n\t\t       sizeof(fs->m_u.tcp_ip4_spec.ip4dst));\n\t\tfs->h_u.tcp_ip4_spec.tos = dfs->val.tos;\n\t\tfs->m_u.tcp_ip4_spec.tos = dfs->mask.tos;\n\t}\n\tfs->h_ext.vlan_tci = cpu_to_be16(dfs->val.ivlan);\n\tfs->m_ext.vlan_tci = cpu_to_be16(dfs->mask.ivlan);\n\tfs->flow_type |= FLOW_EXT;\n\n\tif (dfs->action == FILTER_DROP)\n\t\tfs->ring_cookie = RX_CLS_FLOW_DISC;\n\telse\n\t\tfs->ring_cookie = dfs->iq;\n}\n\nstatic int cxgb4_ntuple_get_filter(struct net_device *dev,\n\t\t\t\t   struct ethtool_rxnfc *cmd,\n\t\t\t\t   unsigned int loc)\n{\n\tconst struct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tstruct filter_entry *f;\n\tint ftid;\n\n\tif (!(adap->flags & CXGB4_FULL_INIT_DONE))\n\t\treturn -EAGAIN;\n\n\t \n\tif (!adap->ethtool_filters)\n\t\treturn -EOPNOTSUPP;\n\n\tif (loc >= adap->ethtool_filters->nentries)\n\t\treturn -ERANGE;\n\n\tif (!test_bit(loc, adap->ethtool_filters->port[pi->port_id].bmap))\n\t\treturn -ENOENT;\n\n\tftid = adap->ethtool_filters->port[pi->port_id].loc_array[loc];\n\n\t \n\tf = cxgb4_get_filter_entry(adap, ftid);\n\n\tcxgb4_fill_filter_rule(&cmd->fs, &f->fs);\n\n\treturn 0;\n}\n\nstatic int get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,\n\t\t     u32 *rules)\n{\n\tconst struct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = netdev2adap(dev);\n\tunsigned int count = 0, index = 0;\n\tint ret = 0;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXFH: {\n\t\tunsigned int v = pi->rss_mode;\n\n\t\tinfo->data = 0;\n\t\tswitch (info->flow_type) {\n\t\tcase TCP_V4_FLOW:\n\t\t\tif (v & FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN_F)\n\t\t\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t\t     RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\t\telse if (v & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F)\n\t\t\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST;\n\t\t\tbreak;\n\t\tcase UDP_V4_FLOW:\n\t\t\tif ((v & FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN_F) &&\n\t\t\t    (v & FW_RSS_VI_CONFIG_CMD_UDPEN_F))\n\t\t\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t\t     RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\t\telse if (v & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F)\n\t\t\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST;\n\t\t\tbreak;\n\t\tcase SCTP_V4_FLOW:\n\t\tcase AH_ESP_V4_FLOW:\n\t\tcase IPV4_FLOW:\n\t\t\tif (v & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F)\n\t\t\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST;\n\t\t\tbreak;\n\t\tcase TCP_V6_FLOW:\n\t\t\tif (v & FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN_F)\n\t\t\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t\t     RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\t\telse if (v & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F)\n\t\t\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST;\n\t\t\tbreak;\n\t\tcase UDP_V6_FLOW:\n\t\t\tif ((v & FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN_F) &&\n\t\t\t    (v & FW_RSS_VI_CONFIG_CMD_UDPEN_F))\n\t\t\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST |\n\t\t\t\t\t     RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\t\telse if (v & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F)\n\t\t\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST;\n\t\t\tbreak;\n\t\tcase SCTP_V6_FLOW:\n\t\tcase AH_ESP_V6_FLOW:\n\t\tcase IPV6_FLOW:\n\t\t\tif (v & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F)\n\t\t\t\tinfo->data = RXH_IP_SRC | RXH_IP_DST;\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase ETHTOOL_GRXRINGS:\n\t\tinfo->data = pi->nqsets;\n\t\treturn 0;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tinfo->rule_cnt =\n\t\t       adap->ethtool_filters->port[pi->port_id].in_use;\n\t\treturn 0;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\treturn cxgb4_ntuple_get_filter(dev, info, info->fs.location);\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tinfo->data = adap->ethtool_filters->nentries;\n\t\twhile (count < info->rule_cnt) {\n\t\t\tret = cxgb4_ntuple_get_filter(dev, info, index);\n\t\t\tif (!ret)\n\t\t\t\trules[count++] = index;\n\t\t\tindex++;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int cxgb4_ntuple_del_filter(struct net_device *dev,\n\t\t\t\t   struct ethtool_rxnfc *cmd)\n{\n\tstruct cxgb4_ethtool_filter_info *filter_info;\n\tstruct adapter *adapter = netdev2adap(dev);\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct filter_entry *f;\n\tu32 filter_id;\n\tint ret;\n\n\tif (!(adapter->flags & CXGB4_FULL_INIT_DONE))\n\t\treturn -EAGAIN;   \n\n\tif (!adapter->ethtool_filters)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cmd->fs.location >= adapter->ethtool_filters->nentries) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"Location must be < %u\",\n\t\t\tadapter->ethtool_filters->nentries);\n\t\treturn -ERANGE;\n\t}\n\n\tfilter_info = &adapter->ethtool_filters->port[pi->port_id];\n\n\tif (!test_bit(cmd->fs.location, filter_info->bmap))\n\t\treturn -ENOENT;\n\n\tfilter_id = filter_info->loc_array[cmd->fs.location];\n\tf = cxgb4_get_filter_entry(adapter, filter_id);\n\n\tif (f->fs.prio)\n\t\tfilter_id -= adapter->tids.hpftid_base;\n\telse if (!f->fs.hash)\n\t\tfilter_id -= (adapter->tids.ftid_base - adapter->tids.nhpftids);\n\n\tret = cxgb4_flow_rule_destroy(dev, f->fs.tc_prio, &f->fs, filter_id);\n\tif (ret)\n\t\tgoto err;\n\n\tclear_bit(cmd->fs.location, filter_info->bmap);\n\tfilter_info->in_use--;\n\nerr:\n\treturn ret;\n}\n\n \nstatic int cxgb4_ntuple_set_filter(struct net_device *netdev,\n\t\t\t\t   struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec_input input = {};\n\tstruct cxgb4_ethtool_filter_info *filter_info;\n\tstruct adapter *adapter = netdev2adap(netdev);\n\tstruct port_info *pi = netdev_priv(netdev);\n\tstruct ch_filter_specification fs;\n\tstruct ethtool_rx_flow_rule *flow;\n\tu32 tid;\n\tint ret;\n\n\tif (!(adapter->flags & CXGB4_FULL_INIT_DONE))\n\t\treturn -EAGAIN;   \n\n\tif (!adapter->ethtool_filters)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cmd->fs.location >= adapter->ethtool_filters->nentries) {\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"Location must be < %u\",\n\t\t\tadapter->ethtool_filters->nentries);\n\t\treturn -ERANGE;\n\t}\n\n\tif (test_bit(cmd->fs.location,\n\t\t     adapter->ethtool_filters->port[pi->port_id].bmap))\n\t\treturn -EEXIST;\n\n\tmemset(&fs, 0, sizeof(fs));\n\n\tinput.fs = &cmd->fs;\n\tflow = ethtool_rx_flow_rule_create(&input);\n\tif (IS_ERR(flow)) {\n\t\tret = PTR_ERR(flow);\n\t\tgoto exit;\n\t}\n\n\tfs.hitcnts = 1;\n\n\tret = cxgb4_flow_rule_replace(netdev, flow->rule, cmd->fs.location,\n\t\t\t\t      NULL, &fs, &tid);\n\tif (ret)\n\t\tgoto free;\n\n\tfilter_info = &adapter->ethtool_filters->port[pi->port_id];\n\n\tif (fs.prio)\n\t\ttid += adapter->tids.hpftid_base;\n\telse if (!fs.hash)\n\t\ttid += (adapter->tids.ftid_base - adapter->tids.nhpftids);\n\n\tfilter_info->loc_array[cmd->fs.location] = tid;\n\tset_bit(cmd->fs.location, filter_info->bmap);\n\tfilter_info->in_use++;\n\nfree:\n\tethtool_rx_flow_rule_destroy(flow);\nexit:\n\treturn ret;\n}\n\nstatic int set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tret = cxgb4_ntuple_set_filter(dev, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tret = cxgb4_ntuple_del_filter(dev, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int set_dump(struct net_device *dev, struct ethtool_dump *eth_dump)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\tu32 len = 0;\n\n\tlen = sizeof(struct cudbg_hdr) +\n\t      sizeof(struct cudbg_entity_hdr) * CUDBG_MAX_ENTITY;\n\tlen += cxgb4_get_dump_length(adapter, eth_dump->flag);\n\n\tadapter->eth_dump.flag = eth_dump->flag;\n\tadapter->eth_dump.len = len;\n\treturn 0;\n}\n\nstatic int get_dump_flag(struct net_device *dev, struct ethtool_dump *eth_dump)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\n\teth_dump->flag = adapter->eth_dump.flag;\n\teth_dump->len = adapter->eth_dump.len;\n\teth_dump->version = adapter->eth_dump.version;\n\treturn 0;\n}\n\nstatic int get_dump_data(struct net_device *dev, struct ethtool_dump *eth_dump,\n\t\t\t void *buf)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\tu32 len = 0;\n\tint ret = 0;\n\n\tif (adapter->eth_dump.flag == CXGB4_ETH_DUMP_NONE)\n\t\treturn -ENOENT;\n\n\tlen = sizeof(struct cudbg_hdr) +\n\t      sizeof(struct cudbg_entity_hdr) * CUDBG_MAX_ENTITY;\n\tlen += cxgb4_get_dump_length(adapter, adapter->eth_dump.flag);\n\tif (eth_dump->len < len)\n\t\treturn -ENOMEM;\n\n\tret = cxgb4_cudbg_collect(adapter, buf, &len, adapter->eth_dump.flag);\n\tif (ret)\n\t\treturn ret;\n\n\teth_dump->flag = adapter->eth_dump.flag;\n\teth_dump->len = len;\n\teth_dump->version = adapter->eth_dump.version;\n\treturn 0;\n}\n\nstatic bool cxgb4_fw_mod_type_info_available(unsigned int fw_mod_type)\n{\n\t \n\treturn (fw_mod_type != FW_PORT_MOD_TYPE_NONE &&\n\t\tfw_mod_type != FW_PORT_MOD_TYPE_ERROR);\n}\n\nstatic int cxgb4_get_module_info(struct net_device *dev,\n\t\t\t\t struct ethtool_modinfo *modinfo)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tu8 sff8472_comp, sff_diag_type, sff_rev;\n\tstruct adapter *adapter = pi->adapter;\n\tint ret;\n\n\tif (!cxgb4_fw_mod_type_info_available(pi->mod_type))\n\t\treturn -EINVAL;\n\n\tswitch (pi->port_type) {\n\tcase FW_PORT_TYPE_SFP:\n\tcase FW_PORT_TYPE_QSA:\n\tcase FW_PORT_TYPE_SFP28:\n\t\tret = t4_i2c_rd(adapter, adapter->mbox, pi->tx_chan,\n\t\t\t\tI2C_DEV_ADDR_A0, SFF_8472_COMP_ADDR,\n\t\t\t\tSFF_8472_COMP_LEN, &sff8472_comp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = t4_i2c_rd(adapter, adapter->mbox, pi->tx_chan,\n\t\t\t\tI2C_DEV_ADDR_A0, SFP_DIAG_TYPE_ADDR,\n\t\t\t\tSFP_DIAG_TYPE_LEN, &sff_diag_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!sff8472_comp || (sff_diag_type & SFP_DIAG_ADDRMODE)) {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t\t} else {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\t\tif (sff_diag_type & SFP_DIAG_IMPLEMENTED)\n\t\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t\t\telse\n\t\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN / 2;\n\t\t}\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_QSFP:\n\tcase FW_PORT_TYPE_QSFP_10G:\n\tcase FW_PORT_TYPE_CR_QSFP:\n\tcase FW_PORT_TYPE_CR2_QSFP:\n\tcase FW_PORT_TYPE_CR4_QSFP:\n\t\tret = t4_i2c_rd(adapter, adapter->mbox, pi->tx_chan,\n\t\t\t\tI2C_DEV_ADDR_A0, SFF_REV_ADDR,\n\t\t\t\tSFF_REV_LEN, &sff_rev);\n\t\t \n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (sff_rev >= 0x3) {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8636;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8636_LEN;\n\t\t} else {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8436;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_LEN;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cxgb4_get_module_eeprom(struct net_device *dev,\n\t\t\t\t   struct ethtool_eeprom *eprom, u8 *data)\n{\n\tint ret = 0, offset = eprom->offset, len = eprom->len;\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\tmemset(data, 0, eprom->len);\n\tif (offset + len <= I2C_PAGE_SIZE)\n\t\treturn t4_i2c_rd(adapter, adapter->mbox, pi->tx_chan,\n\t\t\t\t I2C_DEV_ADDR_A0, offset, len, data);\n\n\t \n\tif (offset <= I2C_PAGE_SIZE) {\n\t\t \n\t\tlen = I2C_PAGE_SIZE - offset;\n\t\tret =  t4_i2c_rd(adapter, adapter->mbox, pi->tx_chan,\n\t\t\t\t I2C_DEV_ADDR_A0, offset, len, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\toffset = I2C_PAGE_SIZE;\n\t\t \n\t\tlen = eprom->len - len;\n\t}\n\t \n\treturn t4_i2c_rd(adapter, adapter->mbox, pi->tx_chan, I2C_DEV_ADDR_A2,\n\t\t\t offset, len, &data[eprom->len - len]);\n}\n\nstatic u32 cxgb4_get_priv_flags(struct net_device *netdev)\n{\n\tstruct port_info *pi = netdev_priv(netdev);\n\tstruct adapter *adapter = pi->adapter;\n\n\treturn (adapter->eth_flags | pi->eth_flags);\n}\n\n \nstatic inline void set_flags(u32 *cur_flags, u32 new_flags, u32 flags)\n{\n\t*cur_flags = (*cur_flags & ~flags) | (new_flags & flags);\n}\n\nstatic int cxgb4_set_priv_flags(struct net_device *netdev, u32 flags)\n{\n\tstruct port_info *pi = netdev_priv(netdev);\n\tstruct adapter *adapter = pi->adapter;\n\n\tset_flags(&adapter->eth_flags, flags, PRIV_FLAGS_ADAP);\n\tset_flags(&pi->eth_flags, flags, PRIV_FLAGS_PORT);\n\n\treturn 0;\n}\n\nstatic void cxgb4_lb_test(struct net_device *netdev, u64 *lb_status)\n{\n\tint dev_state = netif_running(netdev);\n\n\tif (dev_state) {\n\t\tnetif_tx_stop_all_queues(netdev);\n\t\tnetif_carrier_off(netdev);\n\t}\n\n\t*lb_status = cxgb4_selftest_lb_pkt(netdev);\n\n\tif (dev_state) {\n\t\tnetif_tx_start_all_queues(netdev);\n\t\tnetif_carrier_on(netdev);\n\t}\n}\n\nstatic void cxgb4_self_test(struct net_device *netdev,\n\t\t\t    struct ethtool_test *eth_test, u64 *data)\n{\n\tstruct port_info *pi = netdev_priv(netdev);\n\tstruct adapter *adap = pi->adapter;\n\n\tmemset(data, 0, sizeof(u64) * CXGB4_ETHTOOL_MAX_TEST);\n\n\tif (!(adap->flags & CXGB4_FULL_INIT_DONE) ||\n\t    !(adap->flags & CXGB4_FW_OK)) {\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\treturn;\n\t}\n\n\tif (eth_test->flags & ETH_TEST_FL_OFFLINE)\n\t\tcxgb4_lb_test(netdev, &data[CXGB4_ETHTOOL_LB_TEST]);\n\n\tif (data[CXGB4_ETHTOOL_LB_TEST])\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n}\n\nstatic const struct ethtool_ops cxgb_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_RX_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_TX_USECS_IRQ |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE_RX,\n\t.get_link_ksettings = get_link_ksettings,\n\t.set_link_ksettings = set_link_ksettings,\n\t.get_fecparam      = get_fecparam,\n\t.set_fecparam      = set_fecparam,\n\t.get_drvinfo       = get_drvinfo,\n\t.get_msglevel      = get_msglevel,\n\t.set_msglevel      = set_msglevel,\n\t.get_ringparam     = get_sge_param,\n\t.set_ringparam     = set_sge_param,\n\t.get_coalesce      = get_coalesce,\n\t.set_coalesce      = set_coalesce,\n\t.get_eeprom_len    = get_eeprom_len,\n\t.get_eeprom        = get_eeprom,\n\t.set_eeprom        = set_eeprom,\n\t.get_pauseparam    = get_pauseparam,\n\t.set_pauseparam    = set_pauseparam,\n\t.get_link          = ethtool_op_get_link,\n\t.get_strings       = get_strings,\n\t.set_phys_id       = identify_port,\n\t.nway_reset        = restart_autoneg,\n\t.get_sset_count    = get_sset_count,\n\t.get_ethtool_stats = get_stats,\n\t.get_regs_len      = get_regs_len,\n\t.get_regs          = get_regs,\n\t.get_rxnfc         = get_rxnfc,\n\t.set_rxnfc         = set_rxnfc,\n\t.get_rxfh_indir_size = get_rss_table_size,\n\t.get_rxfh\t   = get_rss_table,\n\t.set_rxfh\t   = set_rss_table,\n\t.self_test\t   = cxgb4_self_test,\n\t.flash_device      = set_flash,\n\t.get_ts_info       = get_ts_info,\n\t.set_dump          = set_dump,\n\t.get_dump_flag     = get_dump_flag,\n\t.get_dump_data     = get_dump_data,\n\t.get_module_info   = cxgb4_get_module_info,\n\t.get_module_eeprom = cxgb4_get_module_eeprom,\n\t.get_priv_flags    = cxgb4_get_priv_flags,\n\t.set_priv_flags    = cxgb4_set_priv_flags,\n};\n\nvoid cxgb4_cleanup_ethtool_filters(struct adapter *adap)\n{\n\tstruct cxgb4_ethtool_filter_info *eth_filter_info;\n\tu8 i;\n\n\tif (!adap->ethtool_filters)\n\t\treturn;\n\n\teth_filter_info = adap->ethtool_filters->port;\n\n\tif (eth_filter_info) {\n\t\tfor (i = 0; i < adap->params.nports; i++) {\n\t\t\tkvfree(eth_filter_info[i].loc_array);\n\t\t\tbitmap_free(eth_filter_info[i].bmap);\n\t\t}\n\t\tkfree(eth_filter_info);\n\t}\n\n\tkfree(adap->ethtool_filters);\n}\n\nint cxgb4_init_ethtool_filters(struct adapter *adap)\n{\n\tstruct cxgb4_ethtool_filter_info *eth_filter_info;\n\tstruct cxgb4_ethtool_filter *eth_filter;\n\tstruct tid_info *tids = &adap->tids;\n\tu32 nentries, i;\n\tint ret;\n\n\teth_filter = kzalloc(sizeof(*eth_filter), GFP_KERNEL);\n\tif (!eth_filter)\n\t\treturn -ENOMEM;\n\n\teth_filter_info = kcalloc(adap->params.nports,\n\t\t\t\t  sizeof(*eth_filter_info),\n\t\t\t\t  GFP_KERNEL);\n\tif (!eth_filter_info) {\n\t\tret = -ENOMEM;\n\t\tgoto free_eth_filter;\n\t}\n\n\teth_filter->port = eth_filter_info;\n\n\tnentries = tids->nhpftids + tids->nftids;\n\tif (is_hashfilter(adap))\n\t\tnentries += tids->nhash +\n\t\t\t    (adap->tids.stid_base - adap->tids.tid_base);\n\teth_filter->nentries = nentries;\n\n\tfor (i = 0; i < adap->params.nports; i++) {\n\t\teth_filter->port[i].loc_array = kvzalloc(nentries, GFP_KERNEL);\n\t\tif (!eth_filter->port[i].loc_array) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_eth_finfo;\n\t\t}\n\n\t\teth_filter->port[i].bmap = bitmap_zalloc(nentries, GFP_KERNEL);\n\t\tif (!eth_filter->port[i].bmap) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_eth_finfo;\n\t\t}\n\t}\n\n\tadap->ethtool_filters = eth_filter;\n\treturn 0;\n\nfree_eth_finfo:\n\twhile (i-- > 0) {\n\t\tbitmap_free(eth_filter->port[i].bmap);\n\t\tkvfree(eth_filter->port[i].loc_array);\n\t}\n\tkfree(eth_filter_info);\n\nfree_eth_filter:\n\tkfree(eth_filter);\n\n\treturn ret;\n}\n\nvoid cxgb4_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &cxgb_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}