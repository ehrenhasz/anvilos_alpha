{
  "module_name": "cudbg_lib.c",
  "hash_id": "ff3f7663bad77e965d211c91d79541caa61e2b972a17b6b775c9d271e577b99d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c",
  "human_readable_source": "\n \n\n#include <linux/sort.h>\n#include <linux/string.h>\n\n#include \"t4_regs.h\"\n#include \"cxgb4.h\"\n#include \"cxgb4_cudbg.h\"\n#include \"cudbg_if.h\"\n#include \"cudbg_lib_common.h\"\n#include \"cudbg_entity.h\"\n#include \"cudbg_lib.h\"\n#include \"cudbg_zlib.h\"\n#include \"cxgb4_tc_mqprio.h\"\n\nstatic const u32 t6_tp_pio_array[][IREG_NUM_ELEM] = {\n\t{0x7e40, 0x7e44, 0x020, 28},  \n\t{0x7e40, 0x7e44, 0x040, 10},  \n\t{0x7e40, 0x7e44, 0x050, 10},  \n\t{0x7e40, 0x7e44, 0x060, 14},  \n\t{0x7e40, 0x7e44, 0x06F, 1},  \n\t{0x7e40, 0x7e44, 0x070, 6},  \n\t{0x7e40, 0x7e44, 0x130, 18},  \n\t{0x7e40, 0x7e44, 0x145, 19},  \n\t{0x7e40, 0x7e44, 0x160, 1},  \n\t{0x7e40, 0x7e44, 0x230, 25},  \n\t{0x7e40, 0x7e44, 0x24a, 3},  \n\t{0x7e40, 0x7e44, 0x8C0, 1}  \n};\n\nstatic const u32 t5_tp_pio_array[][IREG_NUM_ELEM] = {\n\t{0x7e40, 0x7e44, 0x020, 28},  \n\t{0x7e40, 0x7e44, 0x040, 19},  \n\t{0x7e40, 0x7e44, 0x054, 2},  \n\t{0x7e40, 0x7e44, 0x060, 13},  \n\t{0x7e40, 0x7e44, 0x06F, 1},  \n\t{0x7e40, 0x7e44, 0x120, 4},  \n\t{0x7e40, 0x7e44, 0x12b, 2},  \n\t{0x7e40, 0x7e44, 0x12f, 21},  \n\t{0x7e40, 0x7e44, 0x145, 19},  \n\t{0x7e40, 0x7e44, 0x230, 25},  \n\t{0x7e40, 0x7e44, 0x8C0, 1}  \n};\n\nstatic const u32 t6_tp_tm_pio_array[][IREG_NUM_ELEM] = {\n\t{0x7e18, 0x7e1c, 0x0, 12}\n};\n\nstatic const u32 t5_tp_tm_pio_array[][IREG_NUM_ELEM] = {\n\t{0x7e18, 0x7e1c, 0x0, 12}\n};\n\nstatic const u32 t6_tp_mib_index_array[6][IREG_NUM_ELEM] = {\n\t{0x7e50, 0x7e54, 0x0, 13},\n\t{0x7e50, 0x7e54, 0x10, 6},\n\t{0x7e50, 0x7e54, 0x18, 21},\n\t{0x7e50, 0x7e54, 0x30, 32},\n\t{0x7e50, 0x7e54, 0x50, 22},\n\t{0x7e50, 0x7e54, 0x68, 12}\n};\n\nstatic const u32 t5_tp_mib_index_array[9][IREG_NUM_ELEM] = {\n\t{0x7e50, 0x7e54, 0x0, 13},\n\t{0x7e50, 0x7e54, 0x10, 6},\n\t{0x7e50, 0x7e54, 0x18, 8},\n\t{0x7e50, 0x7e54, 0x20, 13},\n\t{0x7e50, 0x7e54, 0x30, 16},\n\t{0x7e50, 0x7e54, 0x40, 16},\n\t{0x7e50, 0x7e54, 0x50, 16},\n\t{0x7e50, 0x7e54, 0x60, 6},\n\t{0x7e50, 0x7e54, 0x68, 4}\n};\n\nstatic const u32 t5_sge_dbg_index_array[2][IREG_NUM_ELEM] = {\n\t{0x10cc, 0x10d0, 0x0, 16},\n\t{0x10cc, 0x10d4, 0x0, 16},\n};\n\nstatic const u32 t6_sge_qbase_index_array[] = {\n\t \n\t0x1250, 0x1240, 0x1244, 0x1248, 0x124c,\n};\n\nstatic const u32 t5_pcie_pdbg_array[][IREG_NUM_ELEM] = {\n\t{0x5a04, 0x5a0c, 0x00, 0x20},  \n\t{0x5a04, 0x5a0c, 0x21, 0x20},  \n\t{0x5a04, 0x5a0c, 0x41, 0x10},  \n};\n\nstatic const u32 t5_pcie_cdbg_array[][IREG_NUM_ELEM] = {\n\t{0x5a10, 0x5a18, 0x00, 0x20},  \n\t{0x5a10, 0x5a18, 0x21, 0x18},  \n};\n\nstatic const u32 t5_pm_rx_array[][IREG_NUM_ELEM] = {\n\t{0x8FD0, 0x8FD4, 0x10000, 0x20},  \n\t{0x8FD0, 0x8FD4, 0x10021, 0x0D},  \n};\n\nstatic const u32 t5_pm_tx_array[][IREG_NUM_ELEM] = {\n\t{0x8FF0, 0x8FF4, 0x10000, 0x20},  \n\t{0x8FF0, 0x8FF4, 0x10021, 0x1D},  \n};\n\nstatic const u32 t5_pcie_config_array[][2] = {\n\t{0x0, 0x34},\n\t{0x3c, 0x40},\n\t{0x50, 0x64},\n\t{0x70, 0x80},\n\t{0x94, 0xa0},\n\t{0xb0, 0xb8},\n\t{0xd0, 0xd4},\n\t{0x100, 0x128},\n\t{0x140, 0x148},\n\t{0x150, 0x164},\n\t{0x170, 0x178},\n\t{0x180, 0x194},\n\t{0x1a0, 0x1b8},\n\t{0x1c0, 0x208},\n};\n\nstatic const u32 t6_ma_ireg_array[][IREG_NUM_ELEM] = {\n\t{0x78f8, 0x78fc, 0xa000, 23},  \n\t{0x78f8, 0x78fc, 0xa400, 30},  \n\t{0x78f8, 0x78fc, 0xa800, 20}  \n};\n\nstatic const u32 t6_ma_ireg_array2[][IREG_NUM_ELEM] = {\n\t{0x78f8, 0x78fc, 0xe400, 17},  \n\t{0x78f8, 0x78fc, 0xe640, 13}  \n};\n\nstatic const u32 t6_up_cim_reg_array[][IREG_NUM_ELEM + 1] = {\n\t{0x7b50, 0x7b54, 0x2000, 0x20, 0},  \n\t{0x7b50, 0x7b54, 0x2080, 0x1d, 0},  \n\t{0x7b50, 0x7b54, 0x00, 0x20, 0},  \n\t{0x7b50, 0x7b54, 0x80, 0x20, 0},  \n\t{0x7b50, 0x7b54, 0x100, 0x11, 0},  \n\t{0x7b50, 0x7b54, 0x200, 0x10, 0},  \n\t{0x7b50, 0x7b54, 0x240, 0x2, 0},  \n\t{0x7b50, 0x7b54, 0x250, 0x2, 0},  \n\t{0x7b50, 0x7b54, 0x260, 0x2, 0},  \n\t{0x7b50, 0x7b54, 0x270, 0x2, 0},  \n\t{0x7b50, 0x7b54, 0x280, 0x20, 0},  \n\t{0x7b50, 0x7b54, 0x300, 0x20, 0},  \n\t{0x7b50, 0x7b54, 0x380, 0x14, 0},  \n\t{0x7b50, 0x7b54, 0x4900, 0x4, 0x4},  \n\t{0x7b50, 0x7b54, 0x4904, 0x4, 0x4},  \n\t{0x7b50, 0x7b54, 0x4908, 0x4, 0x4},  \n\t{0x7b50, 0x7b54, 0x4910, 0x4, 0x4},  \n\t{0x7b50, 0x7b54, 0x4914, 0x4, 0x4},  \n\t{0x7b50, 0x7b54, 0x4920, 0x10, 0x10},  \n\t{0x7b50, 0x7b54, 0x4924, 0x10, 0x10},  \n\t{0x7b50, 0x7b54, 0x4928, 0x10, 0x10},  \n\t{0x7b50, 0x7b54, 0x492c, 0x10, 0x10},  \n};\n\nstatic const u32 t5_up_cim_reg_array[][IREG_NUM_ELEM + 1] = {\n\t{0x7b50, 0x7b54, 0x2000, 0x20, 0},  \n\t{0x7b50, 0x7b54, 0x2080, 0x19, 0},  \n\t{0x7b50, 0x7b54, 0x00, 0x20, 0},  \n\t{0x7b50, 0x7b54, 0x80, 0x20, 0},  \n\t{0x7b50, 0x7b54, 0x100, 0x11, 0},  \n\t{0x7b50, 0x7b54, 0x200, 0x10, 0},  \n\t{0x7b50, 0x7b54, 0x240, 0x2, 0},  \n\t{0x7b50, 0x7b54, 0x250, 0x2, 0},  \n\t{0x7b50, 0x7b54, 0x260, 0x2, 0},  \n\t{0x7b50, 0x7b54, 0x270, 0x2, 0},  \n\t{0x7b50, 0x7b54, 0x280, 0x20, 0},  \n\t{0x7b50, 0x7b54, 0x300, 0x20, 0},  \n\t{0x7b50, 0x7b54, 0x380, 0x14, 0},  \n};\n\nstatic const u32 t6_hma_ireg_array[][IREG_NUM_ELEM] = {\n\t{0x51320, 0x51324, 0xa000, 32}  \n};\n\nu32 cudbg_get_entity_length(struct adapter *adap, u32 entity)\n{\n\tstruct cudbg_tcam tcam_region = { 0 };\n\tu32 value, n = 0, len = 0;\n\n\tswitch (entity) {\n\tcase CUDBG_REG_DUMP:\n\t\tswitch (CHELSIO_CHIP_VERSION(adap->params.chip)) {\n\t\tcase CHELSIO_T4:\n\t\t\tlen = T4_REGMAP_SIZE;\n\t\t\tbreak;\n\t\tcase CHELSIO_T5:\n\t\tcase CHELSIO_T6:\n\t\t\tlen = T5_REGMAP_SIZE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CUDBG_DEV_LOG:\n\t\tlen = adap->params.devlog.size;\n\t\tbreak;\n\tcase CUDBG_CIM_LA:\n\t\tif (is_t6(adap->params.chip)) {\n\t\t\tlen = adap->params.cim_la_size / 10 + 1;\n\t\t\tlen *= 10 * sizeof(u32);\n\t\t} else {\n\t\t\tlen = adap->params.cim_la_size / 8;\n\t\t\tlen *= 8 * sizeof(u32);\n\t\t}\n\t\tlen += sizeof(u32);  \n\t\tbreak;\n\tcase CUDBG_CIM_MA_LA:\n\t\tlen = 2 * CIM_MALA_SIZE * 5 * sizeof(u32);\n\t\tbreak;\n\tcase CUDBG_CIM_QCFG:\n\t\tlen = sizeof(struct cudbg_cim_qcfg);\n\t\tbreak;\n\tcase CUDBG_CIM_IBQ_TP0:\n\tcase CUDBG_CIM_IBQ_TP1:\n\tcase CUDBG_CIM_IBQ_ULP:\n\tcase CUDBG_CIM_IBQ_SGE0:\n\tcase CUDBG_CIM_IBQ_SGE1:\n\tcase CUDBG_CIM_IBQ_NCSI:\n\t\tlen = CIM_IBQ_SIZE * 4 * sizeof(u32);\n\t\tbreak;\n\tcase CUDBG_CIM_OBQ_ULP0:\n\t\tlen = cudbg_cim_obq_size(adap, 0);\n\t\tbreak;\n\tcase CUDBG_CIM_OBQ_ULP1:\n\t\tlen = cudbg_cim_obq_size(adap, 1);\n\t\tbreak;\n\tcase CUDBG_CIM_OBQ_ULP2:\n\t\tlen = cudbg_cim_obq_size(adap, 2);\n\t\tbreak;\n\tcase CUDBG_CIM_OBQ_ULP3:\n\t\tlen = cudbg_cim_obq_size(adap, 3);\n\t\tbreak;\n\tcase CUDBG_CIM_OBQ_SGE:\n\t\tlen = cudbg_cim_obq_size(adap, 4);\n\t\tbreak;\n\tcase CUDBG_CIM_OBQ_NCSI:\n\t\tlen = cudbg_cim_obq_size(adap, 5);\n\t\tbreak;\n\tcase CUDBG_CIM_OBQ_RXQ0:\n\t\tlen = cudbg_cim_obq_size(adap, 6);\n\t\tbreak;\n\tcase CUDBG_CIM_OBQ_RXQ1:\n\t\tlen = cudbg_cim_obq_size(adap, 7);\n\t\tbreak;\n\tcase CUDBG_EDC0:\n\t\tvalue = t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A);\n\t\tif (value & EDRAM0_ENABLE_F) {\n\t\t\tvalue = t4_read_reg(adap, MA_EDRAM0_BAR_A);\n\t\t\tlen = EDRAM0_SIZE_G(value);\n\t\t}\n\t\tlen = cudbg_mbytes_to_bytes(len);\n\t\tbreak;\n\tcase CUDBG_EDC1:\n\t\tvalue = t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A);\n\t\tif (value & EDRAM1_ENABLE_F) {\n\t\t\tvalue = t4_read_reg(adap, MA_EDRAM1_BAR_A);\n\t\t\tlen = EDRAM1_SIZE_G(value);\n\t\t}\n\t\tlen = cudbg_mbytes_to_bytes(len);\n\t\tbreak;\n\tcase CUDBG_MC0:\n\t\tvalue = t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A);\n\t\tif (value & EXT_MEM0_ENABLE_F) {\n\t\t\tvalue = t4_read_reg(adap, MA_EXT_MEMORY0_BAR_A);\n\t\t\tlen = EXT_MEM0_SIZE_G(value);\n\t\t}\n\t\tlen = cudbg_mbytes_to_bytes(len);\n\t\tbreak;\n\tcase CUDBG_MC1:\n\t\tvalue = t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A);\n\t\tif (value & EXT_MEM1_ENABLE_F) {\n\t\t\tvalue = t4_read_reg(adap, MA_EXT_MEMORY1_BAR_A);\n\t\t\tlen = EXT_MEM1_SIZE_G(value);\n\t\t}\n\t\tlen = cudbg_mbytes_to_bytes(len);\n\t\tbreak;\n\tcase CUDBG_RSS:\n\t\tlen = t4_chip_rss_size(adap) * sizeof(u16);\n\t\tbreak;\n\tcase CUDBG_RSS_VF_CONF:\n\t\tlen = adap->params.arch.vfcount *\n\t\t      sizeof(struct cudbg_rss_vf_conf);\n\t\tbreak;\n\tcase CUDBG_PATH_MTU:\n\t\tlen = NMTUS * sizeof(u16);\n\t\tbreak;\n\tcase CUDBG_PM_STATS:\n\t\tlen = sizeof(struct cudbg_pm_stats);\n\t\tbreak;\n\tcase CUDBG_HW_SCHED:\n\t\tlen = sizeof(struct cudbg_hw_sched);\n\t\tbreak;\n\tcase CUDBG_TP_INDIRECT:\n\t\tswitch (CHELSIO_CHIP_VERSION(adap->params.chip)) {\n\t\tcase CHELSIO_T5:\n\t\t\tn = sizeof(t5_tp_pio_array) +\n\t\t\t    sizeof(t5_tp_tm_pio_array) +\n\t\t\t    sizeof(t5_tp_mib_index_array);\n\t\t\tbreak;\n\t\tcase CHELSIO_T6:\n\t\t\tn = sizeof(t6_tp_pio_array) +\n\t\t\t    sizeof(t6_tp_tm_pio_array) +\n\t\t\t    sizeof(t6_tp_mib_index_array);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tn = n / (IREG_NUM_ELEM * sizeof(u32));\n\t\tlen = sizeof(struct ireg_buf) * n;\n\t\tbreak;\n\tcase CUDBG_SGE_INDIRECT:\n\t\tlen = sizeof(struct ireg_buf) * 2 +\n\t\t      sizeof(struct sge_qbase_reg_field);\n\t\tbreak;\n\tcase CUDBG_ULPRX_LA:\n\t\tlen = sizeof(struct cudbg_ulprx_la);\n\t\tbreak;\n\tcase CUDBG_TP_LA:\n\t\tlen = sizeof(struct cudbg_tp_la) + TPLA_SIZE * sizeof(u64);\n\t\tbreak;\n\tcase CUDBG_MEMINFO:\n\t\tlen = sizeof(struct cudbg_ver_hdr) +\n\t\t      sizeof(struct cudbg_meminfo);\n\t\tbreak;\n\tcase CUDBG_CIM_PIF_LA:\n\t\tlen = sizeof(struct cudbg_cim_pif_la);\n\t\tlen += 2 * CIM_PIFLA_SIZE * 6 * sizeof(u32);\n\t\tbreak;\n\tcase CUDBG_CLK:\n\t\tlen = sizeof(struct cudbg_clk_info);\n\t\tbreak;\n\tcase CUDBG_PCIE_INDIRECT:\n\t\tn = sizeof(t5_pcie_pdbg_array) / (IREG_NUM_ELEM * sizeof(u32));\n\t\tlen = sizeof(struct ireg_buf) * n * 2;\n\t\tbreak;\n\tcase CUDBG_PM_INDIRECT:\n\t\tn = sizeof(t5_pm_rx_array) / (IREG_NUM_ELEM * sizeof(u32));\n\t\tlen = sizeof(struct ireg_buf) * n * 2;\n\t\tbreak;\n\tcase CUDBG_TID_INFO:\n\t\tlen = sizeof(struct cudbg_tid_info_region_rev1);\n\t\tbreak;\n\tcase CUDBG_PCIE_CONFIG:\n\t\tlen = sizeof(u32) * CUDBG_NUM_PCIE_CONFIG_REGS;\n\t\tbreak;\n\tcase CUDBG_DUMP_CONTEXT:\n\t\tlen = cudbg_dump_context_size(adap);\n\t\tbreak;\n\tcase CUDBG_MPS_TCAM:\n\t\tlen = sizeof(struct cudbg_mps_tcam) *\n\t\t      adap->params.arch.mps_tcam_size;\n\t\tbreak;\n\tcase CUDBG_VPD_DATA:\n\t\tlen = sizeof(struct cudbg_vpd_data);\n\t\tbreak;\n\tcase CUDBG_LE_TCAM:\n\t\tcudbg_fill_le_tcam_info(adap, &tcam_region);\n\t\tlen = sizeof(struct cudbg_tcam) +\n\t\t      sizeof(struct cudbg_tid_data) * tcam_region.max_tid;\n\t\tbreak;\n\tcase CUDBG_CCTRL:\n\t\tlen = sizeof(u16) * NMTUS * NCCTRL_WIN;\n\t\tbreak;\n\tcase CUDBG_MA_INDIRECT:\n\t\tif (CHELSIO_CHIP_VERSION(adap->params.chip) > CHELSIO_T5) {\n\t\t\tn = sizeof(t6_ma_ireg_array) /\n\t\t\t    (IREG_NUM_ELEM * sizeof(u32));\n\t\t\tlen = sizeof(struct ireg_buf) * n * 2;\n\t\t}\n\t\tbreak;\n\tcase CUDBG_ULPTX_LA:\n\t\tlen = sizeof(struct cudbg_ver_hdr) +\n\t\t      sizeof(struct cudbg_ulptx_la);\n\t\tbreak;\n\tcase CUDBG_UP_CIM_INDIRECT:\n\t\tn = 0;\n\t\tif (is_t5(adap->params.chip))\n\t\t\tn = sizeof(t5_up_cim_reg_array) /\n\t\t\t    ((IREG_NUM_ELEM + 1) * sizeof(u32));\n\t\telse if (is_t6(adap->params.chip))\n\t\t\tn = sizeof(t6_up_cim_reg_array) /\n\t\t\t    ((IREG_NUM_ELEM + 1) * sizeof(u32));\n\t\tlen = sizeof(struct ireg_buf) * n;\n\t\tbreak;\n\tcase CUDBG_PBT_TABLE:\n\t\tlen = sizeof(struct cudbg_pbt_tables);\n\t\tbreak;\n\tcase CUDBG_MBOX_LOG:\n\t\tlen = sizeof(struct cudbg_mbox_log) * adap->mbox_log->size;\n\t\tbreak;\n\tcase CUDBG_HMA_INDIRECT:\n\t\tif (CHELSIO_CHIP_VERSION(adap->params.chip) > CHELSIO_T5) {\n\t\t\tn = sizeof(t6_hma_ireg_array) /\n\t\t\t    (IREG_NUM_ELEM * sizeof(u32));\n\t\t\tlen = sizeof(struct ireg_buf) * n;\n\t\t}\n\t\tbreak;\n\tcase CUDBG_HMA:\n\t\tvalue = t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A);\n\t\tif (value & HMA_MUX_F) {\n\t\t\t \n\t\t\tvalue = t4_read_reg(adap, MA_EXT_MEMORY1_BAR_A);\n\t\t\tlen = EXT_MEM1_SIZE_G(value);\n\t\t}\n\t\tlen = cudbg_mbytes_to_bytes(len);\n\t\tbreak;\n\tcase CUDBG_QDESC:\n\t\tcudbg_fill_qdesc_num_and_size(adap, NULL, &len);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn len;\n}\n\nstatic int cudbg_do_compression(struct cudbg_init *pdbg_init,\n\t\t\t\tstruct cudbg_buffer *pin_buff,\n\t\t\t\tstruct cudbg_buffer *dbg_buff)\n{\n\tstruct cudbg_buffer temp_in_buff = { 0 };\n\tint bytes_left, bytes_read, bytes;\n\tu32 offset = dbg_buff->offset;\n\tint rc;\n\n\ttemp_in_buff.offset = pin_buff->offset;\n\ttemp_in_buff.data = pin_buff->data;\n\ttemp_in_buff.size = pin_buff->size;\n\n\tbytes_left = pin_buff->size;\n\tbytes_read = 0;\n\twhile (bytes_left > 0) {\n\t\t \n\t\tbytes = min_t(unsigned long, bytes_left,\n\t\t\t      (unsigned long)CUDBG_CHUNK_SIZE);\n\t\ttemp_in_buff.data = (char *)pin_buff->data + bytes_read;\n\t\ttemp_in_buff.size = bytes;\n\t\trc = cudbg_compress_buff(pdbg_init, &temp_in_buff, dbg_buff);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tbytes_left -= bytes;\n\t\tbytes_read += bytes;\n\t}\n\n\tpin_buff->size = dbg_buff->offset - offset;\n\treturn 0;\n}\n\nstatic int cudbg_write_and_release_buff(struct cudbg_init *pdbg_init,\n\t\t\t\t\tstruct cudbg_buffer *pin_buff,\n\t\t\t\t\tstruct cudbg_buffer *dbg_buff)\n{\n\tint rc = 0;\n\n\tif (pdbg_init->compress_type == CUDBG_COMPRESSION_NONE) {\n\t\tcudbg_update_buff(pin_buff, dbg_buff);\n\t} else {\n\t\trc = cudbg_do_compression(pdbg_init, pin_buff, dbg_buff);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\nout:\n\tcudbg_put_buff(pdbg_init, pin_buff);\n\treturn rc;\n}\n\nstatic int is_fw_attached(struct cudbg_init *pdbg_init)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\n\tif (!(padap->flags & CXGB4_FW_OK) || padap->use_bd)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nvoid cudbg_align_debug_buffer(struct cudbg_buffer *dbg_buff,\n\t\t\t      struct cudbg_entity_hdr *entity_hdr)\n{\n\tu8 zero_buf[4] = {0};\n\tu8 padding, remain;\n\n\tremain = (dbg_buff->offset - entity_hdr->start_offset) % 4;\n\tpadding = 4 - remain;\n\tif (remain) {\n\t\tmemcpy(((u8 *)dbg_buff->data) + dbg_buff->offset, &zero_buf,\n\t\t       padding);\n\t\tdbg_buff->offset += padding;\n\t\tentity_hdr->num_pad = padding;\n\t}\n\tentity_hdr->size = dbg_buff->offset - entity_hdr->start_offset;\n}\n\nstruct cudbg_entity_hdr *cudbg_get_entity_hdr(void *outbuf, int i)\n{\n\tstruct cudbg_hdr *cudbg_hdr = (struct cudbg_hdr *)outbuf;\n\n\treturn (struct cudbg_entity_hdr *)\n\t       ((char *)outbuf + cudbg_hdr->hdr_len +\n\t\t(sizeof(struct cudbg_entity_hdr) * (i - 1)));\n}\n\nstatic int cudbg_read_vpd_reg(struct adapter *padap, u32 addr, u32 len,\n\t\t\t      void *dest)\n{\n\tint vaddr, rc;\n\n\tvaddr = t4_eeprom_ptov(addr, padap->pf, EEPROMPFSIZE);\n\tif (vaddr < 0)\n\t\treturn vaddr;\n\n\trc = pci_read_vpd(padap->pdev, vaddr, len, dest);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int cudbg_mem_desc_cmp(const void *a, const void *b)\n{\n\treturn ((const struct cudbg_mem_desc *)a)->base -\n\t       ((const struct cudbg_mem_desc *)b)->base;\n}\n\nint cudbg_fill_meminfo(struct adapter *padap,\n\t\t       struct cudbg_meminfo *meminfo_buff)\n{\n\tstruct cudbg_mem_desc *md;\n\tu32 lo, hi, used, alloc;\n\tint n, i;\n\n\tmemset(meminfo_buff->avail, 0,\n\t       ARRAY_SIZE(meminfo_buff->avail) *\n\t       sizeof(struct cudbg_mem_desc));\n\tmemset(meminfo_buff->mem, 0,\n\t       (ARRAY_SIZE(cudbg_region) + 3) * sizeof(struct cudbg_mem_desc));\n\tmd  = meminfo_buff->mem;\n\n\tfor (i = 0; i < ARRAY_SIZE(meminfo_buff->mem); i++) {\n\t\tmeminfo_buff->mem[i].limit = 0;\n\t\tmeminfo_buff->mem[i].idx = i;\n\t}\n\n\t \n\ti = 0;\n\tlo = t4_read_reg(padap, MA_TARGET_MEM_ENABLE_A);\n\tif (lo & EDRAM0_ENABLE_F) {\n\t\thi = t4_read_reg(padap, MA_EDRAM0_BAR_A);\n\t\tmeminfo_buff->avail[i].base =\n\t\t\tcudbg_mbytes_to_bytes(EDRAM0_BASE_G(hi));\n\t\tmeminfo_buff->avail[i].limit =\n\t\t\tmeminfo_buff->avail[i].base +\n\t\t\tcudbg_mbytes_to_bytes(EDRAM0_SIZE_G(hi));\n\t\tmeminfo_buff->avail[i].idx = 0;\n\t\ti++;\n\t}\n\n\tif (lo & EDRAM1_ENABLE_F) {\n\t\thi =  t4_read_reg(padap, MA_EDRAM1_BAR_A);\n\t\tmeminfo_buff->avail[i].base =\n\t\t\tcudbg_mbytes_to_bytes(EDRAM1_BASE_G(hi));\n\t\tmeminfo_buff->avail[i].limit =\n\t\t\tmeminfo_buff->avail[i].base +\n\t\t\tcudbg_mbytes_to_bytes(EDRAM1_SIZE_G(hi));\n\t\tmeminfo_buff->avail[i].idx = 1;\n\t\ti++;\n\t}\n\n\tif (is_t5(padap->params.chip)) {\n\t\tif (lo & EXT_MEM0_ENABLE_F) {\n\t\t\thi = t4_read_reg(padap, MA_EXT_MEMORY0_BAR_A);\n\t\t\tmeminfo_buff->avail[i].base =\n\t\t\t\tcudbg_mbytes_to_bytes(EXT_MEM_BASE_G(hi));\n\t\t\tmeminfo_buff->avail[i].limit =\n\t\t\t\tmeminfo_buff->avail[i].base +\n\t\t\t\tcudbg_mbytes_to_bytes(EXT_MEM_SIZE_G(hi));\n\t\t\tmeminfo_buff->avail[i].idx = 3;\n\t\t\ti++;\n\t\t}\n\n\t\tif (lo & EXT_MEM1_ENABLE_F) {\n\t\t\thi = t4_read_reg(padap, MA_EXT_MEMORY1_BAR_A);\n\t\t\tmeminfo_buff->avail[i].base =\n\t\t\t\tcudbg_mbytes_to_bytes(EXT_MEM1_BASE_G(hi));\n\t\t\tmeminfo_buff->avail[i].limit =\n\t\t\t\tmeminfo_buff->avail[i].base +\n\t\t\t\tcudbg_mbytes_to_bytes(EXT_MEM1_SIZE_G(hi));\n\t\t\tmeminfo_buff->avail[i].idx = 4;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\tif (lo & EXT_MEM_ENABLE_F) {\n\t\t\thi = t4_read_reg(padap, MA_EXT_MEMORY_BAR_A);\n\t\t\tmeminfo_buff->avail[i].base =\n\t\t\t\tcudbg_mbytes_to_bytes(EXT_MEM_BASE_G(hi));\n\t\t\tmeminfo_buff->avail[i].limit =\n\t\t\t\tmeminfo_buff->avail[i].base +\n\t\t\t\tcudbg_mbytes_to_bytes(EXT_MEM_SIZE_G(hi));\n\t\t\tmeminfo_buff->avail[i].idx = 2;\n\t\t\ti++;\n\t\t}\n\n\t\tif (lo & HMA_MUX_F) {\n\t\t\thi = t4_read_reg(padap, MA_EXT_MEMORY1_BAR_A);\n\t\t\tmeminfo_buff->avail[i].base =\n\t\t\t\tcudbg_mbytes_to_bytes(EXT_MEM1_BASE_G(hi));\n\t\t\tmeminfo_buff->avail[i].limit =\n\t\t\t\tmeminfo_buff->avail[i].base +\n\t\t\t\tcudbg_mbytes_to_bytes(EXT_MEM1_SIZE_G(hi));\n\t\t\tmeminfo_buff->avail[i].idx = 5;\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (!i)  \n\t\treturn CUDBG_STATUS_ENTITY_NOT_FOUND;\n\n\tmeminfo_buff->avail_c = i;\n\tsort(meminfo_buff->avail, i, sizeof(struct cudbg_mem_desc),\n\t     cudbg_mem_desc_cmp, NULL);\n\t(md++)->base = t4_read_reg(padap, SGE_DBQ_CTXT_BADDR_A);\n\t(md++)->base = t4_read_reg(padap, SGE_IMSG_CTXT_BADDR_A);\n\t(md++)->base = t4_read_reg(padap, SGE_FLM_CACHE_BADDR_A);\n\t(md++)->base = t4_read_reg(padap, TP_CMM_TCB_BASE_A);\n\t(md++)->base = t4_read_reg(padap, TP_CMM_MM_BASE_A);\n\t(md++)->base = t4_read_reg(padap, TP_CMM_TIMER_BASE_A);\n\t(md++)->base = t4_read_reg(padap, TP_CMM_MM_RX_FLST_BASE_A);\n\t(md++)->base = t4_read_reg(padap, TP_CMM_MM_TX_FLST_BASE_A);\n\t(md++)->base = t4_read_reg(padap, TP_CMM_MM_PS_FLST_BASE_A);\n\n\t \n\tmd->base = t4_read_reg(padap, TP_PMM_TX_BASE_A);\n\tmd->limit = md->base - 1 +\n\t\t    t4_read_reg(padap, TP_PMM_TX_PAGE_SIZE_A) *\n\t\t    PMTXMAXPAGE_G(t4_read_reg(padap, TP_PMM_TX_MAX_PAGE_A));\n\tmd++;\n\n\tmd->base = t4_read_reg(padap, TP_PMM_RX_BASE_A);\n\tmd->limit = md->base - 1 +\n\t\t    t4_read_reg(padap, TP_PMM_RX_PAGE_SIZE_A) *\n\t\t    PMRXMAXPAGE_G(t4_read_reg(padap, TP_PMM_RX_MAX_PAGE_A));\n\tmd++;\n\n\tif (t4_read_reg(padap, LE_DB_CONFIG_A) & HASHEN_F) {\n\t\tif (CHELSIO_CHIP_VERSION(padap->params.chip) <= CHELSIO_T5) {\n\t\t\thi = t4_read_reg(padap, LE_DB_TID_HASHBASE_A) / 4;\n\t\t\tmd->base = t4_read_reg(padap, LE_DB_HASH_TID_BASE_A);\n\t\t} else {\n\t\t\thi = t4_read_reg(padap, LE_DB_HASH_TID_BASE_A);\n\t\t\tmd->base = t4_read_reg(padap,\n\t\t\t\t\t       LE_DB_HASH_TBL_BASE_ADDR_A);\n\t\t}\n\t\tmd->limit = 0;\n\t} else {\n\t\tmd->base = 0;\n\t\tmd->idx = ARRAY_SIZE(cudbg_region);   \n\t}\n\tmd++;\n\n#define ulp_region(reg) do { \\\n\tmd->base = t4_read_reg(padap, ULP_ ## reg ## _LLIMIT_A);\\\n\t(md++)->limit = t4_read_reg(padap, ULP_ ## reg ## _ULIMIT_A);\\\n} while (0)\n\n\tulp_region(RX_ISCSI);\n\tulp_region(RX_TDDP);\n\tulp_region(TX_TPT);\n\tulp_region(RX_STAG);\n\tulp_region(RX_RQ);\n\tulp_region(RX_RQUDP);\n\tulp_region(RX_PBL);\n\tulp_region(TX_PBL);\n#undef ulp_region\n\tmd->base = 0;\n\tmd->idx = ARRAY_SIZE(cudbg_region);\n\tif (!is_t4(padap->params.chip)) {\n\t\tu32 fifo_size = t4_read_reg(padap, SGE_DBVFIFO_SIZE_A);\n\t\tu32 sge_ctrl = t4_read_reg(padap, SGE_CONTROL2_A);\n\t\tu32 size = 0;\n\n\t\tif (is_t5(padap->params.chip)) {\n\t\t\tif (sge_ctrl & VFIFO_ENABLE_F)\n\t\t\t\tsize = DBVFIFO_SIZE_G(fifo_size);\n\t\t} else {\n\t\t\tsize = T6_DBVFIFO_SIZE_G(fifo_size);\n\t\t}\n\n\t\tif (size) {\n\t\t\tmd->base = BASEADDR_G(t4_read_reg(padap,\n\t\t\t\t\t\t\t  SGE_DBVFIFO_BADDR_A));\n\t\t\tmd->limit = md->base + (size << 2) - 1;\n\t\t}\n\t}\n\n\tmd++;\n\n\tmd->base = t4_read_reg(padap, ULP_RX_CTX_BASE_A);\n\tmd->limit = 0;\n\tmd++;\n\tmd->base = t4_read_reg(padap, ULP_TX_ERR_TABLE_BASE_A);\n\tmd->limit = 0;\n\tmd++;\n\n\tmd->base = padap->vres.ocq.start;\n\tif (padap->vres.ocq.size)\n\t\tmd->limit = md->base + padap->vres.ocq.size - 1;\n\telse\n\t\tmd->idx = ARRAY_SIZE(cudbg_region);   \n\tmd++;\n\n\t \n\tfor (n = 0; n < i - 1; n++)\n\t\tif (meminfo_buff->avail[n].limit <\n\t\t    meminfo_buff->avail[n + 1].base)\n\t\t\t(md++)->base = meminfo_buff->avail[n].limit;\n\n\tif (meminfo_buff->avail[n].limit)\n\t\t(md++)->base = meminfo_buff->avail[n].limit;\n\n\tn = md - meminfo_buff->mem;\n\tmeminfo_buff->mem_c = n;\n\n\tsort(meminfo_buff->mem, n, sizeof(struct cudbg_mem_desc),\n\t     cudbg_mem_desc_cmp, NULL);\n\n\tlo = t4_read_reg(padap, CIM_SDRAM_BASE_ADDR_A);\n\thi = t4_read_reg(padap, CIM_SDRAM_ADDR_SIZE_A) + lo - 1;\n\tmeminfo_buff->up_ram_lo = lo;\n\tmeminfo_buff->up_ram_hi = hi;\n\n\tlo = t4_read_reg(padap, CIM_EXTMEM2_BASE_ADDR_A);\n\thi = t4_read_reg(padap, CIM_EXTMEM2_ADDR_SIZE_A) + lo - 1;\n\tmeminfo_buff->up_extmem2_lo = lo;\n\tmeminfo_buff->up_extmem2_hi = hi;\n\n\tlo = t4_read_reg(padap, TP_PMM_RX_MAX_PAGE_A);\n\tfor (i = 0, meminfo_buff->free_rx_cnt = 0; i < 2; i++)\n\t\tmeminfo_buff->free_rx_cnt +=\n\t\t\tFREERXPAGECOUNT_G(t4_read_reg(padap,\n\t\t\t\t\t\t      TP_FLM_FREE_RX_CNT_A));\n\n\tmeminfo_buff->rx_pages_data[0] =  PMRXMAXPAGE_G(lo);\n\tmeminfo_buff->rx_pages_data[1] =\n\t\tt4_read_reg(padap, TP_PMM_RX_PAGE_SIZE_A) >> 10;\n\tmeminfo_buff->rx_pages_data[2] = (lo & PMRXNUMCHN_F) ? 2 : 1;\n\n\tlo = t4_read_reg(padap, TP_PMM_TX_MAX_PAGE_A);\n\thi = t4_read_reg(padap, TP_PMM_TX_PAGE_SIZE_A);\n\tfor (i = 0, meminfo_buff->free_tx_cnt = 0; i < 4; i++)\n\t\tmeminfo_buff->free_tx_cnt +=\n\t\t\tFREETXPAGECOUNT_G(t4_read_reg(padap,\n\t\t\t\t\t\t      TP_FLM_FREE_TX_CNT_A));\n\n\tmeminfo_buff->tx_pages_data[0] = PMTXMAXPAGE_G(lo);\n\tmeminfo_buff->tx_pages_data[1] =\n\t\thi >= (1 << 20) ? (hi >> 20) : (hi >> 10);\n\tmeminfo_buff->tx_pages_data[2] =\n\t\thi >= (1 << 20) ? 'M' : 'K';\n\tmeminfo_buff->tx_pages_data[3] = 1 << PMTXNUMCHN_G(lo);\n\n\tmeminfo_buff->p_structs = t4_read_reg(padap, TP_CMM_MM_MAX_PSTRUCT_A);\n\tmeminfo_buff->p_structs_free_cnt =\n\t\tFREEPSTRUCTCOUNT_G(t4_read_reg(padap, TP_FLM_FREE_PS_CNT_A));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (CHELSIO_CHIP_VERSION(padap->params.chip) > CHELSIO_T5)\n\t\t\tlo = t4_read_reg(padap,\n\t\t\t\t\t MPS_RX_MAC_BG_PG_CNT0_A + i * 4);\n\t\telse\n\t\t\tlo = t4_read_reg(padap, MPS_RX_PG_RSV0_A + i * 4);\n\t\tif (is_t5(padap->params.chip)) {\n\t\t\tused = T5_USED_G(lo);\n\t\t\talloc = T5_ALLOC_G(lo);\n\t\t} else {\n\t\t\tused = USED_G(lo);\n\t\t\talloc = ALLOC_G(lo);\n\t\t}\n\t\tmeminfo_buff->port_used[i] = used;\n\t\tmeminfo_buff->port_alloc[i] = alloc;\n\t}\n\n\tfor (i = 0; i < padap->params.arch.nchan; i++) {\n\t\tif (CHELSIO_CHIP_VERSION(padap->params.chip) > CHELSIO_T5)\n\t\t\tlo = t4_read_reg(padap,\n\t\t\t\t\t MPS_RX_LPBK_BG_PG_CNT0_A + i * 4);\n\t\telse\n\t\t\tlo = t4_read_reg(padap, MPS_RX_PG_RSV4_A + i * 4);\n\t\tif (is_t5(padap->params.chip)) {\n\t\t\tused = T5_USED_G(lo);\n\t\t\talloc = T5_ALLOC_G(lo);\n\t\t} else {\n\t\t\tused = USED_G(lo);\n\t\t\talloc = ALLOC_G(lo);\n\t\t}\n\t\tmeminfo_buff->loopback_used[i] = used;\n\t\tmeminfo_buff->loopback_alloc[i] = alloc;\n\t}\n\n\treturn 0;\n}\n\nint cudbg_collect_reg_dump(struct cudbg_init *pdbg_init,\n\t\t\t   struct cudbg_buffer *dbg_buff,\n\t\t\t   struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tu32 buf_size = 0;\n\tint rc = 0;\n\n\tif (is_t4(padap->params.chip))\n\t\tbuf_size = T4_REGMAP_SIZE;\n\telse if (is_t5(padap->params.chip) || is_t6(padap->params.chip))\n\t\tbuf_size = T5_REGMAP_SIZE;\n\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, buf_size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\tt4_get_regs(padap, (void *)temp_buff.data, temp_buff.size);\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_fw_devlog(struct cudbg_init *pdbg_init,\n\t\t\t    struct cudbg_buffer *dbg_buff,\n\t\t\t    struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct devlog_params *dparams;\n\tint rc = 0;\n\n\trc = t4_init_devlog_params(padap);\n\tif (rc < 0) {\n\t\tcudbg_err->sys_err = rc;\n\t\treturn rc;\n\t}\n\n\tdparams = &padap->params.devlog;\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, dparams->size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (dparams->start != 0) {\n\t\tspin_lock(&padap->win0_lock);\n\t\trc = t4_memory_rw(padap, padap->params.drv_memwin,\n\t\t\t\t  dparams->memtype, dparams->start,\n\t\t\t\t  dparams->size,\n\t\t\t\t  (__be32 *)(char *)temp_buff.data,\n\t\t\t\t  1);\n\t\tspin_unlock(&padap->win0_lock);\n\t\tif (rc) {\n\t\t\tcudbg_err->sys_err = rc;\n\t\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_cim_la(struct cudbg_init *pdbg_init,\n\t\t\t struct cudbg_buffer *dbg_buff,\n\t\t\t struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tint size, rc;\n\tu32 cfg = 0;\n\n\tif (is_t6(padap->params.chip)) {\n\t\tsize = padap->params.cim_la_size / 10 + 1;\n\t\tsize *= 10 * sizeof(u32);\n\t} else {\n\t\tsize = padap->params.cim_la_size / 8;\n\t\tsize *= 8 * sizeof(u32);\n\t}\n\n\tsize += sizeof(cfg);\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\trc = t4_cim_read(padap, UP_UP_DBG_LA_CFG_A, 1, &cfg);\n\tif (rc) {\n\t\tcudbg_err->sys_err = rc;\n\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\treturn rc;\n\t}\n\n\tmemcpy((char *)temp_buff.data, &cfg, sizeof(cfg));\n\trc = t4_cim_read_la(padap,\n\t\t\t    (u32 *)((char *)temp_buff.data + sizeof(cfg)),\n\t\t\t    NULL);\n\tif (rc < 0) {\n\t\tcudbg_err->sys_err = rc;\n\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\treturn rc;\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_cim_ma_la(struct cudbg_init *pdbg_init,\n\t\t\t    struct cudbg_buffer *dbg_buff,\n\t\t\t    struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tint size, rc;\n\n\tsize = 2 * CIM_MALA_SIZE * 5 * sizeof(u32);\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tt4_cim_read_ma_la(padap,\n\t\t\t  (u32 *)temp_buff.data,\n\t\t\t  (u32 *)((char *)temp_buff.data +\n\t\t\t\t  5 * CIM_MALA_SIZE));\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_cim_qcfg(struct cudbg_init *pdbg_init,\n\t\t\t   struct cudbg_buffer *dbg_buff,\n\t\t\t   struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_cim_qcfg *cim_qcfg_data;\n\tint rc;\n\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_cim_qcfg),\n\t\t\t    &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tcim_qcfg_data = (struct cudbg_cim_qcfg *)temp_buff.data;\n\tcim_qcfg_data->chip = padap->params.chip;\n\trc = t4_cim_read(padap, UP_IBQ_0_RDADDR_A,\n\t\t\t ARRAY_SIZE(cim_qcfg_data->stat), cim_qcfg_data->stat);\n\tif (rc) {\n\t\tcudbg_err->sys_err = rc;\n\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\treturn rc;\n\t}\n\n\trc = t4_cim_read(padap, UP_OBQ_0_REALADDR_A,\n\t\t\t ARRAY_SIZE(cim_qcfg_data->obq_wr),\n\t\t\t cim_qcfg_data->obq_wr);\n\tif (rc) {\n\t\tcudbg_err->sys_err = rc;\n\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\treturn rc;\n\t}\n\n\tt4_read_cimq_cfg(padap, cim_qcfg_data->base, cim_qcfg_data->size,\n\t\t\t cim_qcfg_data->thres);\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nstatic int cudbg_read_cim_ibq(struct cudbg_init *pdbg_init,\n\t\t\t      struct cudbg_buffer *dbg_buff,\n\t\t\t      struct cudbg_error *cudbg_err, int qid)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tint no_of_read_words, rc = 0;\n\tu32 qsize;\n\n\t \n\tqsize = CIM_IBQ_SIZE * 4 * sizeof(u32);\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, qsize, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tno_of_read_words = t4_read_cim_ibq(padap, qid,\n\t\t\t\t\t   (u32 *)temp_buff.data, qsize);\n\t \n\tif (no_of_read_words <= 0) {\n\t\tif (!no_of_read_words)\n\t\t\trc = CUDBG_SYSTEM_ERROR;\n\t\telse\n\t\t\trc = no_of_read_words;\n\t\tcudbg_err->sys_err = rc;\n\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\treturn rc;\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_cim_ibq_tp0(struct cudbg_init *pdbg_init,\n\t\t\t      struct cudbg_buffer *dbg_buff,\n\t\t\t      struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_read_cim_ibq(pdbg_init, dbg_buff, cudbg_err, 0);\n}\n\nint cudbg_collect_cim_ibq_tp1(struct cudbg_init *pdbg_init,\n\t\t\t      struct cudbg_buffer *dbg_buff,\n\t\t\t      struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_read_cim_ibq(pdbg_init, dbg_buff, cudbg_err, 1);\n}\n\nint cudbg_collect_cim_ibq_ulp(struct cudbg_init *pdbg_init,\n\t\t\t      struct cudbg_buffer *dbg_buff,\n\t\t\t      struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_read_cim_ibq(pdbg_init, dbg_buff, cudbg_err, 2);\n}\n\nint cudbg_collect_cim_ibq_sge0(struct cudbg_init *pdbg_init,\n\t\t\t       struct cudbg_buffer *dbg_buff,\n\t\t\t       struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_read_cim_ibq(pdbg_init, dbg_buff, cudbg_err, 3);\n}\n\nint cudbg_collect_cim_ibq_sge1(struct cudbg_init *pdbg_init,\n\t\t\t       struct cudbg_buffer *dbg_buff,\n\t\t\t       struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_read_cim_ibq(pdbg_init, dbg_buff, cudbg_err, 4);\n}\n\nint cudbg_collect_cim_ibq_ncsi(struct cudbg_init *pdbg_init,\n\t\t\t       struct cudbg_buffer *dbg_buff,\n\t\t\t       struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_read_cim_ibq(pdbg_init, dbg_buff, cudbg_err, 5);\n}\n\nu32 cudbg_cim_obq_size(struct adapter *padap, int qid)\n{\n\tu32 value;\n\n\tt4_write_reg(padap, CIM_QUEUE_CONFIG_REF_A, OBQSELECT_F |\n\t\t     QUENUMSELECT_V(qid));\n\tvalue = t4_read_reg(padap, CIM_QUEUE_CONFIG_CTRL_A);\n\tvalue = CIMQSIZE_G(value) * 64;  \n\treturn value * sizeof(u32);\n}\n\nstatic int cudbg_read_cim_obq(struct cudbg_init *pdbg_init,\n\t\t\t      struct cudbg_buffer *dbg_buff,\n\t\t\t      struct cudbg_error *cudbg_err, int qid)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tint no_of_read_words, rc = 0;\n\tu32 qsize;\n\n\t \n\tqsize =  cudbg_cim_obq_size(padap, qid);\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, qsize, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tno_of_read_words = t4_read_cim_obq(padap, qid,\n\t\t\t\t\t   (u32 *)temp_buff.data, qsize);\n\t \n\tif (no_of_read_words <= 0) {\n\t\tif (!no_of_read_words)\n\t\t\trc = CUDBG_SYSTEM_ERROR;\n\t\telse\n\t\t\trc = no_of_read_words;\n\t\tcudbg_err->sys_err = rc;\n\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\treturn rc;\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_cim_obq_ulp0(struct cudbg_init *pdbg_init,\n\t\t\t       struct cudbg_buffer *dbg_buff,\n\t\t\t       struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_read_cim_obq(pdbg_init, dbg_buff, cudbg_err, 0);\n}\n\nint cudbg_collect_cim_obq_ulp1(struct cudbg_init *pdbg_init,\n\t\t\t       struct cudbg_buffer *dbg_buff,\n\t\t\t       struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_read_cim_obq(pdbg_init, dbg_buff, cudbg_err, 1);\n}\n\nint cudbg_collect_cim_obq_ulp2(struct cudbg_init *pdbg_init,\n\t\t\t       struct cudbg_buffer *dbg_buff,\n\t\t\t       struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_read_cim_obq(pdbg_init, dbg_buff, cudbg_err, 2);\n}\n\nint cudbg_collect_cim_obq_ulp3(struct cudbg_init *pdbg_init,\n\t\t\t       struct cudbg_buffer *dbg_buff,\n\t\t\t       struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_read_cim_obq(pdbg_init, dbg_buff, cudbg_err, 3);\n}\n\nint cudbg_collect_cim_obq_sge(struct cudbg_init *pdbg_init,\n\t\t\t      struct cudbg_buffer *dbg_buff,\n\t\t\t      struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_read_cim_obq(pdbg_init, dbg_buff, cudbg_err, 4);\n}\n\nint cudbg_collect_cim_obq_ncsi(struct cudbg_init *pdbg_init,\n\t\t\t       struct cudbg_buffer *dbg_buff,\n\t\t\t       struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_read_cim_obq(pdbg_init, dbg_buff, cudbg_err, 5);\n}\n\nint cudbg_collect_obq_sge_rx_q0(struct cudbg_init *pdbg_init,\n\t\t\t\tstruct cudbg_buffer *dbg_buff,\n\t\t\t\tstruct cudbg_error *cudbg_err)\n{\n\treturn cudbg_read_cim_obq(pdbg_init, dbg_buff, cudbg_err, 6);\n}\n\nint cudbg_collect_obq_sge_rx_q1(struct cudbg_init *pdbg_init,\n\t\t\t\tstruct cudbg_buffer *dbg_buff,\n\t\t\t\tstruct cudbg_error *cudbg_err)\n{\n\treturn cudbg_read_cim_obq(pdbg_init, dbg_buff, cudbg_err, 7);\n}\n\nstatic int cudbg_meminfo_get_mem_index(struct adapter *padap,\n\t\t\t\t       struct cudbg_meminfo *mem_info,\n\t\t\t\t       u8 mem_type, u8 *idx)\n{\n\tu8 i, flag;\n\n\tswitch (mem_type) {\n\tcase MEM_EDC0:\n\t\tflag = EDC0_FLAG;\n\t\tbreak;\n\tcase MEM_EDC1:\n\t\tflag = EDC1_FLAG;\n\t\tbreak;\n\tcase MEM_MC0:\n\t\t \n\t\tflag = is_t5(padap->params.chip) ? MC0_FLAG : MC_FLAG;\n\t\tbreak;\n\tcase MEM_MC1:\n\t\tflag = MC1_FLAG;\n\t\tbreak;\n\tcase MEM_HMA:\n\t\tflag = HMA_FLAG;\n\t\tbreak;\n\tdefault:\n\t\treturn CUDBG_STATUS_ENTITY_NOT_FOUND;\n\t}\n\n\tfor (i = 0; i < mem_info->avail_c; i++) {\n\t\tif (mem_info->avail[i].idx == flag) {\n\t\t\t*idx = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn CUDBG_STATUS_ENTITY_NOT_FOUND;\n}\n\n \nstatic int cudbg_get_mem_region(struct adapter *padap,\n\t\t\t\tstruct cudbg_meminfo *meminfo,\n\t\t\t\tu8 mem_type, const char *region_name,\n\t\t\t\tstruct cudbg_mem_desc *mem_desc)\n{\n\tu8 mc, found = 0;\n\tu32 idx = 0;\n\tint rc, i;\n\n\trc = cudbg_meminfo_get_mem_index(padap, meminfo, mem_type, &mc);\n\tif (rc)\n\t\treturn rc;\n\n\ti = match_string(cudbg_region, ARRAY_SIZE(cudbg_region), region_name);\n\tif (i < 0)\n\t\treturn -EINVAL;\n\n\tidx = i;\n\tfor (i = 0; i < meminfo->mem_c; i++) {\n\t\tif (meminfo->mem[i].idx >= ARRAY_SIZE(cudbg_region))\n\t\t\tcontinue;  \n\n\t\tif (!(meminfo->mem[i].limit))\n\t\t\tmeminfo->mem[i].limit =\n\t\t\t\ti < meminfo->mem_c - 1 ?\n\t\t\t\tmeminfo->mem[i + 1].base - 1 : ~0;\n\n\t\tif (meminfo->mem[i].idx == idx) {\n\t\t\t \n\t\t\tif (meminfo->mem[i].base < meminfo->avail[mc].base &&\n\t\t\t    meminfo->mem[i].limit < meminfo->avail[mc].base)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (meminfo->mem[i].base > meminfo->avail[mc].limit)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmemcpy(mem_desc, &meminfo->mem[i],\n\t\t\t       sizeof(struct cudbg_mem_desc));\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int cudbg_get_mem_relative(struct adapter *padap,\n\t\t\t\t  struct cudbg_meminfo *meminfo,\n\t\t\t\t  u8 mem_type, u32 *out_base, u32 *out_end)\n{\n\tu8 mc_idx;\n\tint rc;\n\n\trc = cudbg_meminfo_get_mem_index(padap, meminfo, mem_type, &mc_idx);\n\tif (rc)\n\t\treturn rc;\n\n\tif (*out_base < meminfo->avail[mc_idx].base)\n\t\t*out_base = 0;\n\telse\n\t\t*out_base -= meminfo->avail[mc_idx].base;\n\n\tif (*out_end > meminfo->avail[mc_idx].limit)\n\t\t*out_end = meminfo->avail[mc_idx].limit;\n\telse\n\t\t*out_end -= meminfo->avail[mc_idx].base;\n\n\treturn 0;\n}\n\n \nstatic int cudbg_get_payload_range(struct adapter *padap, u8 mem_type,\n\t\t\t\t   const char *region_name,\n\t\t\t\t   struct cudbg_region_info *payload)\n{\n\tstruct cudbg_mem_desc mem_desc = { 0 };\n\tstruct cudbg_meminfo meminfo;\n\tint rc;\n\n\trc = cudbg_fill_meminfo(padap, &meminfo);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cudbg_get_mem_region(padap, &meminfo, mem_type, region_name,\n\t\t\t\t  &mem_desc);\n\tif (rc) {\n\t\tpayload->exist = false;\n\t\treturn 0;\n\t}\n\n\tpayload->exist = true;\n\tpayload->start = mem_desc.base;\n\tpayload->end = mem_desc.limit;\n\n\treturn cudbg_get_mem_relative(padap, &meminfo, mem_type,\n\t\t\t\t      &payload->start, &payload->end);\n}\n\nstatic int cudbg_memory_read(struct cudbg_init *pdbg_init, int win,\n\t\t\t     int mtype, u32 addr, u32 len, void *hbuf)\n{\n\tu32 win_pf, memoffset, mem_aperture, mem_base;\n\tstruct adapter *adap = pdbg_init->adap;\n\tu32 pos, offset, resid;\n\tu32 *res_buf;\n\tu64 *buf;\n\tint ret;\n\n\t \n\tif (addr & 0x3 || (uintptr_t)hbuf & 0x3)\n\t\treturn -EINVAL;\n\n\tbuf = (u64 *)hbuf;\n\n\t \n\tresid = len & 0x7;\n\tlen -= resid;\n\n\tret = t4_memory_rw_init(adap, win, mtype, &memoffset, &mem_base,\n\t\t\t\t&mem_aperture);\n\tif (ret)\n\t\treturn ret;\n\n\taddr = addr + memoffset;\n\twin_pf = is_t4(adap->params.chip) ? 0 : PFNUM_V(adap->pf);\n\n\tpos = addr & ~(mem_aperture - 1);\n\toffset = addr - pos;\n\n\t \n\tt4_memory_update_win(adap, win, pos | win_pf);\n\n\t \n\twhile (len > 0) {\n\t\t*buf++ = le64_to_cpu((__force __le64)\n\t\t\t\t     t4_read_reg64(adap, mem_base + offset));\n\t\toffset += sizeof(u64);\n\t\tlen -= sizeof(u64);\n\n\t\t \n\t\tif (offset == mem_aperture) {\n\t\t\tpos += mem_aperture;\n\t\t\toffset = 0;\n\t\t\tt4_memory_update_win(adap, win, pos | win_pf);\n\t\t}\n\t}\n\n\tres_buf = (u32 *)buf;\n\t \n\twhile (resid > sizeof(u32)) {\n\t\t*res_buf++ = le32_to_cpu((__force __le32)\n\t\t\t\t\t t4_read_reg(adap, mem_base + offset));\n\t\toffset += sizeof(u32);\n\t\tresid -= sizeof(u32);\n\n\t\t \n\t\tif (offset == mem_aperture) {\n\t\t\tpos += mem_aperture;\n\t\t\toffset = 0;\n\t\t\tt4_memory_update_win(adap, win, pos | win_pf);\n\t\t}\n\t}\n\n\t \n\tif (resid)\n\t\tt4_memory_rw_residual(adap, resid, mem_base + offset,\n\t\t\t\t      (u8 *)res_buf, T4_MEMORY_READ);\n\n\treturn 0;\n}\n\n#define CUDBG_YIELD_ITERATION 256\n\nstatic int cudbg_read_fw_mem(struct cudbg_init *pdbg_init,\n\t\t\t     struct cudbg_buffer *dbg_buff, u8 mem_type,\n\t\t\t     unsigned long tot_len,\n\t\t\t     struct cudbg_error *cudbg_err)\n{\n\tstatic const char * const region_name[] = { \"Tx payload:\",\n\t\t\t\t\t\t    \"Rx payload:\" };\n\tunsigned long bytes, bytes_left, bytes_read = 0;\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_region_info payload[2];\n\tu32 yield_count = 0;\n\tint rc = 0;\n\tu8 i;\n\n\t \n\tmemset(payload, 0, sizeof(payload));\n\tfor (i = 0; i < ARRAY_SIZE(region_name); i++) {\n\t\trc = cudbg_get_payload_range(padap, mem_type, region_name[i],\n\t\t\t\t\t     &payload[i]);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tif (payload[i].exist) {\n\t\t\t \n\t\t\tpayload[i].start = roundup(payload[i].start,\n\t\t\t\t\t\t   CUDBG_CHUNK_SIZE);\n\t\t\tpayload[i].end = rounddown(payload[i].end,\n\t\t\t\t\t\t   CUDBG_CHUNK_SIZE);\n\t\t}\n\t}\n\n\tbytes_left = tot_len;\n\twhile (bytes_left > 0) {\n\t\t \n\t\tyield_count++;\n\t\tif (!(yield_count % CUDBG_YIELD_ITERATION))\n\t\t\tschedule();\n\n\t\tbytes = min_t(unsigned long, bytes_left,\n\t\t\t      (unsigned long)CUDBG_CHUNK_SIZE);\n\t\trc = cudbg_get_buff(pdbg_init, dbg_buff, bytes, &temp_buff);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(payload); i++)\n\t\t\tif (payload[i].exist &&\n\t\t\t    bytes_read >= payload[i].start &&\n\t\t\t    bytes_read + bytes <= payload[i].end)\n\t\t\t\t \n\t\t\t\tgoto skip_read;\n\n\t\tspin_lock(&padap->win0_lock);\n\t\trc = cudbg_memory_read(pdbg_init, MEMWIN_NIC, mem_type,\n\t\t\t\t       bytes_read, bytes, temp_buff.data);\n\t\tspin_unlock(&padap->win0_lock);\n\t\tif (rc) {\n\t\t\tcudbg_err->sys_err = rc;\n\t\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\t\treturn rc;\n\t\t}\n\nskip_read:\n\t\tbytes_left -= bytes;\n\t\tbytes_read += bytes;\n\t\trc = cudbg_write_and_release_buff(pdbg_init, &temp_buff,\n\t\t\t\t\t\t  dbg_buff);\n\t\tif (rc) {\n\t\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic void cudbg_t4_fwcache(struct cudbg_init *pdbg_init,\n\t\t\t     struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tint rc;\n\n\tif (is_fw_attached(pdbg_init)) {\n\t\t \n\t\trc = t4_fwcache(padap, FW_PARAM_DEV_FWCACHE_FLUSH);\n\t\tif (rc)\n\t\t\tcudbg_err->sys_warn = rc;\n\t}\n}\n\nstatic int cudbg_mem_region_size(struct cudbg_init *pdbg_init,\n\t\t\t\t struct cudbg_error *cudbg_err,\n\t\t\t\t u8 mem_type, unsigned long *region_size)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_meminfo mem_info;\n\tu8 mc_idx;\n\tint rc;\n\n\tmemset(&mem_info, 0, sizeof(struct cudbg_meminfo));\n\trc = cudbg_fill_meminfo(padap, &mem_info);\n\tif (rc) {\n\t\tcudbg_err->sys_err = rc;\n\t\treturn rc;\n\t}\n\n\tcudbg_t4_fwcache(pdbg_init, cudbg_err);\n\trc = cudbg_meminfo_get_mem_index(padap, &mem_info, mem_type, &mc_idx);\n\tif (rc) {\n\t\tcudbg_err->sys_err = rc;\n\t\treturn rc;\n\t}\n\n\tif (region_size)\n\t\t*region_size = mem_info.avail[mc_idx].limit -\n\t\t\t       mem_info.avail[mc_idx].base;\n\n\treturn 0;\n}\n\nstatic int cudbg_collect_mem_region(struct cudbg_init *pdbg_init,\n\t\t\t\t    struct cudbg_buffer *dbg_buff,\n\t\t\t\t    struct cudbg_error *cudbg_err,\n\t\t\t\t    u8 mem_type)\n{\n\tunsigned long size = 0;\n\tint rc;\n\n\trc = cudbg_mem_region_size(pdbg_init, cudbg_err, mem_type, &size);\n\tif (rc)\n\t\treturn rc;\n\n\treturn cudbg_read_fw_mem(pdbg_init, dbg_buff, mem_type, size,\n\t\t\t\t cudbg_err);\n}\n\nint cudbg_collect_edc0_meminfo(struct cudbg_init *pdbg_init,\n\t\t\t       struct cudbg_buffer *dbg_buff,\n\t\t\t       struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_collect_mem_region(pdbg_init, dbg_buff, cudbg_err,\n\t\t\t\t\tMEM_EDC0);\n}\n\nint cudbg_collect_edc1_meminfo(struct cudbg_init *pdbg_init,\n\t\t\t       struct cudbg_buffer *dbg_buff,\n\t\t\t       struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_collect_mem_region(pdbg_init, dbg_buff, cudbg_err,\n\t\t\t\t\tMEM_EDC1);\n}\n\nint cudbg_collect_mc0_meminfo(struct cudbg_init *pdbg_init,\n\t\t\t      struct cudbg_buffer *dbg_buff,\n\t\t\t      struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_collect_mem_region(pdbg_init, dbg_buff, cudbg_err,\n\t\t\t\t\tMEM_MC0);\n}\n\nint cudbg_collect_mc1_meminfo(struct cudbg_init *pdbg_init,\n\t\t\t      struct cudbg_buffer *dbg_buff,\n\t\t\t      struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_collect_mem_region(pdbg_init, dbg_buff, cudbg_err,\n\t\t\t\t\tMEM_MC1);\n}\n\nint cudbg_collect_hma_meminfo(struct cudbg_init *pdbg_init,\n\t\t\t      struct cudbg_buffer *dbg_buff,\n\t\t\t      struct cudbg_error *cudbg_err)\n{\n\treturn cudbg_collect_mem_region(pdbg_init, dbg_buff, cudbg_err,\n\t\t\t\t\tMEM_HMA);\n}\n\nint cudbg_collect_rss(struct cudbg_init *pdbg_init,\n\t\t      struct cudbg_buffer *dbg_buff,\n\t\t      struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tint rc, nentries;\n\n\tnentries = t4_chip_rss_size(padap);\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, nentries * sizeof(u16),\n\t\t\t    &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\trc = t4_read_rss(padap, (u16 *)temp_buff.data);\n\tif (rc) {\n\t\tcudbg_err->sys_err = rc;\n\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\treturn rc;\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_rss_vf_config(struct cudbg_init *pdbg_init,\n\t\t\t\tstruct cudbg_buffer *dbg_buff,\n\t\t\t\tstruct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_rss_vf_conf *vfconf;\n\tint vf, rc, vf_count;\n\n\tvf_count = padap->params.arch.vfcount;\n\trc = cudbg_get_buff(pdbg_init, dbg_buff,\n\t\t\t    vf_count * sizeof(struct cudbg_rss_vf_conf),\n\t\t\t    &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tvfconf = (struct cudbg_rss_vf_conf *)temp_buff.data;\n\tfor (vf = 0; vf < vf_count; vf++)\n\t\tt4_read_rss_vf_config(padap, vf, &vfconf[vf].rss_vf_vfl,\n\t\t\t\t      &vfconf[vf].rss_vf_vfh, true);\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_path_mtu(struct cudbg_init *pdbg_init,\n\t\t\t   struct cudbg_buffer *dbg_buff,\n\t\t\t   struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tint rc;\n\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, NMTUS * sizeof(u16),\n\t\t\t    &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tt4_read_mtu_tbl(padap, (u16 *)temp_buff.data, NULL);\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_pm_stats(struct cudbg_init *pdbg_init,\n\t\t\t   struct cudbg_buffer *dbg_buff,\n\t\t\t   struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_pm_stats *pm_stats_buff;\n\tint rc;\n\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_pm_stats),\n\t\t\t    &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tpm_stats_buff = (struct cudbg_pm_stats *)temp_buff.data;\n\tt4_pmtx_get_stats(padap, pm_stats_buff->tx_cnt, pm_stats_buff->tx_cyc);\n\tt4_pmrx_get_stats(padap, pm_stats_buff->rx_cnt, pm_stats_buff->rx_cyc);\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_hw_sched(struct cudbg_init *pdbg_init,\n\t\t\t   struct cudbg_buffer *dbg_buff,\n\t\t\t   struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_hw_sched *hw_sched_buff;\n\tint i, rc = 0;\n\n\tif (!padap->params.vpd.cclk)\n\t\treturn CUDBG_STATUS_CCLK_NOT_DEFINED;\n\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_hw_sched),\n\t\t\t    &temp_buff);\n\n\tif (rc)\n\t\treturn rc;\n\n\thw_sched_buff = (struct cudbg_hw_sched *)temp_buff.data;\n\thw_sched_buff->map = t4_read_reg(padap, TP_TX_MOD_QUEUE_REQ_MAP_A);\n\thw_sched_buff->mode = TIMERMODE_G(t4_read_reg(padap, TP_MOD_CONFIG_A));\n\tt4_read_pace_tbl(padap, hw_sched_buff->pace_tab);\n\tfor (i = 0; i < NTX_SCHED; ++i)\n\t\tt4_get_tx_sched(padap, i, &hw_sched_buff->kbps[i],\n\t\t\t\t&hw_sched_buff->ipg[i], true);\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_tp_indirect(struct cudbg_init *pdbg_init,\n\t\t\t      struct cudbg_buffer *dbg_buff,\n\t\t\t      struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct ireg_buf *ch_tp_pio;\n\tint i, rc, n = 0;\n\tu32 size;\n\n\tif (is_t5(padap->params.chip))\n\t\tn = sizeof(t5_tp_pio_array) +\n\t\t    sizeof(t5_tp_tm_pio_array) +\n\t\t    sizeof(t5_tp_mib_index_array);\n\telse\n\t\tn = sizeof(t6_tp_pio_array) +\n\t\t    sizeof(t6_tp_tm_pio_array) +\n\t\t    sizeof(t6_tp_mib_index_array);\n\n\tn = n / (IREG_NUM_ELEM * sizeof(u32));\n\tsize = sizeof(struct ireg_buf) * n;\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tch_tp_pio = (struct ireg_buf *)temp_buff.data;\n\n\t \n\tif (is_t5(padap->params.chip))\n\t\tn = sizeof(t5_tp_pio_array) / (IREG_NUM_ELEM * sizeof(u32));\n\telse if (is_t6(padap->params.chip))\n\t\tn = sizeof(t6_tp_pio_array) / (IREG_NUM_ELEM * sizeof(u32));\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct ireg_field *tp_pio = &ch_tp_pio->tp_pio;\n\t\tu32 *buff = ch_tp_pio->outbuf;\n\n\t\tif (is_t5(padap->params.chip)) {\n\t\t\ttp_pio->ireg_addr = t5_tp_pio_array[i][0];\n\t\t\ttp_pio->ireg_data = t5_tp_pio_array[i][1];\n\t\t\ttp_pio->ireg_local_offset = t5_tp_pio_array[i][2];\n\t\t\ttp_pio->ireg_offset_range = t5_tp_pio_array[i][3];\n\t\t} else if (is_t6(padap->params.chip)) {\n\t\t\ttp_pio->ireg_addr = t6_tp_pio_array[i][0];\n\t\t\ttp_pio->ireg_data = t6_tp_pio_array[i][1];\n\t\t\ttp_pio->ireg_local_offset = t6_tp_pio_array[i][2];\n\t\t\ttp_pio->ireg_offset_range = t6_tp_pio_array[i][3];\n\t\t}\n\t\tt4_tp_pio_read(padap, buff, tp_pio->ireg_offset_range,\n\t\t\t       tp_pio->ireg_local_offset, true);\n\t\tch_tp_pio++;\n\t}\n\n\t \n\tif (is_t5(padap->params.chip))\n\t\tn = sizeof(t5_tp_tm_pio_array) / (IREG_NUM_ELEM * sizeof(u32));\n\telse if (is_t6(padap->params.chip))\n\t\tn = sizeof(t6_tp_tm_pio_array) / (IREG_NUM_ELEM * sizeof(u32));\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct ireg_field *tp_pio = &ch_tp_pio->tp_pio;\n\t\tu32 *buff = ch_tp_pio->outbuf;\n\n\t\tif (is_t5(padap->params.chip)) {\n\t\t\ttp_pio->ireg_addr = t5_tp_tm_pio_array[i][0];\n\t\t\ttp_pio->ireg_data = t5_tp_tm_pio_array[i][1];\n\t\t\ttp_pio->ireg_local_offset = t5_tp_tm_pio_array[i][2];\n\t\t\ttp_pio->ireg_offset_range = t5_tp_tm_pio_array[i][3];\n\t\t} else if (is_t6(padap->params.chip)) {\n\t\t\ttp_pio->ireg_addr = t6_tp_tm_pio_array[i][0];\n\t\t\ttp_pio->ireg_data = t6_tp_tm_pio_array[i][1];\n\t\t\ttp_pio->ireg_local_offset = t6_tp_tm_pio_array[i][2];\n\t\t\ttp_pio->ireg_offset_range = t6_tp_tm_pio_array[i][3];\n\t\t}\n\t\tt4_tp_tm_pio_read(padap, buff, tp_pio->ireg_offset_range,\n\t\t\t\t  tp_pio->ireg_local_offset, true);\n\t\tch_tp_pio++;\n\t}\n\n\t \n\tif (is_t5(padap->params.chip))\n\t\tn = sizeof(t5_tp_mib_index_array) /\n\t\t    (IREG_NUM_ELEM * sizeof(u32));\n\telse if (is_t6(padap->params.chip))\n\t\tn = sizeof(t6_tp_mib_index_array) /\n\t\t    (IREG_NUM_ELEM * sizeof(u32));\n\n\tfor (i = 0; i < n ; i++) {\n\t\tstruct ireg_field *tp_pio = &ch_tp_pio->tp_pio;\n\t\tu32 *buff = ch_tp_pio->outbuf;\n\n\t\tif (is_t5(padap->params.chip)) {\n\t\t\ttp_pio->ireg_addr = t5_tp_mib_index_array[i][0];\n\t\t\ttp_pio->ireg_data = t5_tp_mib_index_array[i][1];\n\t\t\ttp_pio->ireg_local_offset =\n\t\t\t\tt5_tp_mib_index_array[i][2];\n\t\t\ttp_pio->ireg_offset_range =\n\t\t\t\tt5_tp_mib_index_array[i][3];\n\t\t} else if (is_t6(padap->params.chip)) {\n\t\t\ttp_pio->ireg_addr = t6_tp_mib_index_array[i][0];\n\t\t\ttp_pio->ireg_data = t6_tp_mib_index_array[i][1];\n\t\t\ttp_pio->ireg_local_offset =\n\t\t\t\tt6_tp_mib_index_array[i][2];\n\t\t\ttp_pio->ireg_offset_range =\n\t\t\t\tt6_tp_mib_index_array[i][3];\n\t\t}\n\t\tt4_tp_mib_read(padap, buff, tp_pio->ireg_offset_range,\n\t\t\t       tp_pio->ireg_local_offset, true);\n\t\tch_tp_pio++;\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nstatic void cudbg_read_sge_qbase_indirect_reg(struct adapter *padap,\n\t\t\t\t\t      struct sge_qbase_reg_field *qbase,\n\t\t\t\t\t      u32 func, bool is_pf)\n{\n\tu32 *buff, i;\n\n\tif (is_pf) {\n\t\tbuff = qbase->pf_data_value[func];\n\t} else {\n\t\tbuff = qbase->vf_data_value[func];\n\t\t \n\t\tfunc += 8;\n\t}\n\n\tt4_write_reg(padap, qbase->reg_addr, func);\n\tfor (i = 0; i < SGE_QBASE_DATA_REG_NUM; i++, buff++)\n\t\t*buff = t4_read_reg(padap, qbase->reg_data[i]);\n}\n\nint cudbg_collect_sge_indirect(struct cudbg_init *pdbg_init,\n\t\t\t       struct cudbg_buffer *dbg_buff,\n\t\t\t       struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct sge_qbase_reg_field *sge_qbase;\n\tstruct ireg_buf *ch_sge_dbg;\n\tu8 padap_running = 0;\n\tint i, rc;\n\tu32 size;\n\n\t \n\tfor_each_port(padap, i) {\n\t\tpadap_running = netif_running(padap->port[i]);\n\t\tif (padap_running)\n\t\t\tbreak;\n\t}\n\n\tsize = sizeof(*ch_sge_dbg) * 2;\n\tif (!padap_running)\n\t\tsize += sizeof(*sge_qbase);\n\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tch_sge_dbg = (struct ireg_buf *)temp_buff.data;\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct ireg_field *sge_pio = &ch_sge_dbg->tp_pio;\n\t\tu32 *buff = ch_sge_dbg->outbuf;\n\n\t\tsge_pio->ireg_addr = t5_sge_dbg_index_array[i][0];\n\t\tsge_pio->ireg_data = t5_sge_dbg_index_array[i][1];\n\t\tsge_pio->ireg_local_offset = t5_sge_dbg_index_array[i][2];\n\t\tsge_pio->ireg_offset_range = t5_sge_dbg_index_array[i][3];\n\t\tt4_read_indirect(padap,\n\t\t\t\t sge_pio->ireg_addr,\n\t\t\t\t sge_pio->ireg_data,\n\t\t\t\t buff,\n\t\t\t\t sge_pio->ireg_offset_range,\n\t\t\t\t sge_pio->ireg_local_offset);\n\t\tch_sge_dbg++;\n\t}\n\n\tif (CHELSIO_CHIP_VERSION(padap->params.chip) > CHELSIO_T5 &&\n\t    !padap_running) {\n\t\tsge_qbase = (struct sge_qbase_reg_field *)ch_sge_dbg;\n\t\t \n\t\tsge_qbase->reg_addr = t6_sge_qbase_index_array[0];\n\t\tfor (i = 0; i < SGE_QBASE_DATA_REG_NUM; i++)\n\t\t\tsge_qbase->reg_data[i] =\n\t\t\t\tt6_sge_qbase_index_array[i + 1];\n\n\t\tfor (i = 0; i <= PCIE_FW_MASTER_M; i++)\n\t\t\tcudbg_read_sge_qbase_indirect_reg(padap, sge_qbase,\n\t\t\t\t\t\t\t  i, true);\n\n\t\tfor (i = 0; i < padap->params.arch.vfcount; i++)\n\t\t\tcudbg_read_sge_qbase_indirect_reg(padap, sge_qbase,\n\t\t\t\t\t\t\t  i, false);\n\n\t\tsge_qbase->vfcount = padap->params.arch.vfcount;\n\t}\n\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_ulprx_la(struct cudbg_init *pdbg_init,\n\t\t\t   struct cudbg_buffer *dbg_buff,\n\t\t\t   struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_ulprx_la *ulprx_la_buff;\n\tint rc;\n\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_ulprx_la),\n\t\t\t    &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tulprx_la_buff = (struct cudbg_ulprx_la *)temp_buff.data;\n\tt4_ulprx_read_la(padap, (u32 *)ulprx_la_buff->data);\n\tulprx_la_buff->size = ULPRX_LA_SIZE;\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_tp_la(struct cudbg_init *pdbg_init,\n\t\t\tstruct cudbg_buffer *dbg_buff,\n\t\t\tstruct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_tp_la *tp_la_buff;\n\tint size, rc;\n\n\tsize = sizeof(struct cudbg_tp_la) + TPLA_SIZE *  sizeof(u64);\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\ttp_la_buff = (struct cudbg_tp_la *)temp_buff.data;\n\ttp_la_buff->mode = DBGLAMODE_G(t4_read_reg(padap, TP_DBG_LA_CONFIG_A));\n\tt4_tp_read_la(padap, (u64 *)tp_la_buff->data, NULL);\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_meminfo(struct cudbg_init *pdbg_init,\n\t\t\t  struct cudbg_buffer *dbg_buff,\n\t\t\t  struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_meminfo *meminfo_buff;\n\tstruct cudbg_ver_hdr *ver_hdr;\n\tint rc;\n\n\trc = cudbg_get_buff(pdbg_init, dbg_buff,\n\t\t\t    sizeof(struct cudbg_ver_hdr) +\n\t\t\t    sizeof(struct cudbg_meminfo),\n\t\t\t    &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tver_hdr = (struct cudbg_ver_hdr *)temp_buff.data;\n\tver_hdr->signature = CUDBG_ENTITY_SIGNATURE;\n\tver_hdr->revision = CUDBG_MEMINFO_REV;\n\tver_hdr->size = sizeof(struct cudbg_meminfo);\n\n\tmeminfo_buff = (struct cudbg_meminfo *)(temp_buff.data +\n\t\t\t\t\t\tsizeof(*ver_hdr));\n\trc = cudbg_fill_meminfo(padap, meminfo_buff);\n\tif (rc) {\n\t\tcudbg_err->sys_err = rc;\n\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\treturn rc;\n\t}\n\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_cim_pif_la(struct cudbg_init *pdbg_init,\n\t\t\t     struct cudbg_buffer *dbg_buff,\n\t\t\t     struct cudbg_error *cudbg_err)\n{\n\tstruct cudbg_cim_pif_la *cim_pif_la_buff;\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tint size, rc;\n\n\tsize = sizeof(struct cudbg_cim_pif_la) +\n\t       2 * CIM_PIFLA_SIZE * 6 * sizeof(u32);\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tcim_pif_la_buff = (struct cudbg_cim_pif_la *)temp_buff.data;\n\tcim_pif_la_buff->size = CIM_PIFLA_SIZE;\n\tt4_cim_read_pif_la(padap, (u32 *)cim_pif_la_buff->data,\n\t\t\t   (u32 *)cim_pif_la_buff->data + 6 * CIM_PIFLA_SIZE,\n\t\t\t   NULL, NULL);\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_clk_info(struct cudbg_init *pdbg_init,\n\t\t\t   struct cudbg_buffer *dbg_buff,\n\t\t\t   struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_clk_info *clk_info_buff;\n\tu64 tp_tick_us;\n\tint rc;\n\n\tif (!padap->params.vpd.cclk)\n\t\treturn CUDBG_STATUS_CCLK_NOT_DEFINED;\n\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_clk_info),\n\t\t\t    &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tclk_info_buff = (struct cudbg_clk_info *)temp_buff.data;\n\tclk_info_buff->cclk_ps = 1000000000 / padap->params.vpd.cclk;  \n\tclk_info_buff->res = t4_read_reg(padap, TP_TIMER_RESOLUTION_A);\n\tclk_info_buff->tre = TIMERRESOLUTION_G(clk_info_buff->res);\n\tclk_info_buff->dack_re = DELAYEDACKRESOLUTION_G(clk_info_buff->res);\n\ttp_tick_us = (clk_info_buff->cclk_ps << clk_info_buff->tre) / 1000000;\n\n\tclk_info_buff->dack_timer =\n\t\t(clk_info_buff->cclk_ps << clk_info_buff->dack_re) / 1000000 *\n\t\tt4_read_reg(padap, TP_DACK_TIMER_A);\n\tclk_info_buff->retransmit_min =\n\t\ttp_tick_us * t4_read_reg(padap, TP_RXT_MIN_A);\n\tclk_info_buff->retransmit_max =\n\t\ttp_tick_us * t4_read_reg(padap, TP_RXT_MAX_A);\n\tclk_info_buff->persist_timer_min =\n\t\ttp_tick_us * t4_read_reg(padap, TP_PERS_MIN_A);\n\tclk_info_buff->persist_timer_max =\n\t\ttp_tick_us * t4_read_reg(padap, TP_PERS_MAX_A);\n\tclk_info_buff->keepalive_idle_timer =\n\t\ttp_tick_us * t4_read_reg(padap, TP_KEEP_IDLE_A);\n\tclk_info_buff->keepalive_interval =\n\t\ttp_tick_us * t4_read_reg(padap, TP_KEEP_INTVL_A);\n\tclk_info_buff->initial_srtt =\n\t\ttp_tick_us * INITSRTT_G(t4_read_reg(padap, TP_INIT_SRTT_A));\n\tclk_info_buff->finwait2_timer =\n\t\ttp_tick_us * t4_read_reg(padap, TP_FINWAIT2_TIMER_A);\n\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_pcie_indirect(struct cudbg_init *pdbg_init,\n\t\t\t\tstruct cudbg_buffer *dbg_buff,\n\t\t\t\tstruct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct ireg_buf *ch_pcie;\n\tint i, rc, n;\n\tu32 size;\n\n\tn = sizeof(t5_pcie_pdbg_array) / (IREG_NUM_ELEM * sizeof(u32));\n\tsize = sizeof(struct ireg_buf) * n * 2;\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tch_pcie = (struct ireg_buf *)temp_buff.data;\n\t \n\tfor (i = 0; i < n; i++) {\n\t\tstruct ireg_field *pcie_pio = &ch_pcie->tp_pio;\n\t\tu32 *buff = ch_pcie->outbuf;\n\n\t\tpcie_pio->ireg_addr = t5_pcie_pdbg_array[i][0];\n\t\tpcie_pio->ireg_data = t5_pcie_pdbg_array[i][1];\n\t\tpcie_pio->ireg_local_offset = t5_pcie_pdbg_array[i][2];\n\t\tpcie_pio->ireg_offset_range = t5_pcie_pdbg_array[i][3];\n\t\tt4_read_indirect(padap,\n\t\t\t\t pcie_pio->ireg_addr,\n\t\t\t\t pcie_pio->ireg_data,\n\t\t\t\t buff,\n\t\t\t\t pcie_pio->ireg_offset_range,\n\t\t\t\t pcie_pio->ireg_local_offset);\n\t\tch_pcie++;\n\t}\n\n\t \n\tn = sizeof(t5_pcie_cdbg_array) / (IREG_NUM_ELEM * sizeof(u32));\n\tfor (i = 0; i < n; i++) {\n\t\tstruct ireg_field *pcie_pio = &ch_pcie->tp_pio;\n\t\tu32 *buff = ch_pcie->outbuf;\n\n\t\tpcie_pio->ireg_addr = t5_pcie_cdbg_array[i][0];\n\t\tpcie_pio->ireg_data = t5_pcie_cdbg_array[i][1];\n\t\tpcie_pio->ireg_local_offset = t5_pcie_cdbg_array[i][2];\n\t\tpcie_pio->ireg_offset_range = t5_pcie_cdbg_array[i][3];\n\t\tt4_read_indirect(padap,\n\t\t\t\t pcie_pio->ireg_addr,\n\t\t\t\t pcie_pio->ireg_data,\n\t\t\t\t buff,\n\t\t\t\t pcie_pio->ireg_offset_range,\n\t\t\t\t pcie_pio->ireg_local_offset);\n\t\tch_pcie++;\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_pm_indirect(struct cudbg_init *pdbg_init,\n\t\t\t      struct cudbg_buffer *dbg_buff,\n\t\t\t      struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct ireg_buf *ch_pm;\n\tint i, rc, n;\n\tu32 size;\n\n\tn = sizeof(t5_pm_rx_array) / (IREG_NUM_ELEM * sizeof(u32));\n\tsize = sizeof(struct ireg_buf) * n * 2;\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tch_pm = (struct ireg_buf *)temp_buff.data;\n\t \n\tfor (i = 0; i < n; i++) {\n\t\tstruct ireg_field *pm_pio = &ch_pm->tp_pio;\n\t\tu32 *buff = ch_pm->outbuf;\n\n\t\tpm_pio->ireg_addr = t5_pm_rx_array[i][0];\n\t\tpm_pio->ireg_data = t5_pm_rx_array[i][1];\n\t\tpm_pio->ireg_local_offset = t5_pm_rx_array[i][2];\n\t\tpm_pio->ireg_offset_range = t5_pm_rx_array[i][3];\n\t\tt4_read_indirect(padap,\n\t\t\t\t pm_pio->ireg_addr,\n\t\t\t\t pm_pio->ireg_data,\n\t\t\t\t buff,\n\t\t\t\t pm_pio->ireg_offset_range,\n\t\t\t\t pm_pio->ireg_local_offset);\n\t\tch_pm++;\n\t}\n\n\t \n\tn = sizeof(t5_pm_tx_array) / (IREG_NUM_ELEM * sizeof(u32));\n\tfor (i = 0; i < n; i++) {\n\t\tstruct ireg_field *pm_pio = &ch_pm->tp_pio;\n\t\tu32 *buff = ch_pm->outbuf;\n\n\t\tpm_pio->ireg_addr = t5_pm_tx_array[i][0];\n\t\tpm_pio->ireg_data = t5_pm_tx_array[i][1];\n\t\tpm_pio->ireg_local_offset = t5_pm_tx_array[i][2];\n\t\tpm_pio->ireg_offset_range = t5_pm_tx_array[i][3];\n\t\tt4_read_indirect(padap,\n\t\t\t\t pm_pio->ireg_addr,\n\t\t\t\t pm_pio->ireg_data,\n\t\t\t\t buff,\n\t\t\t\t pm_pio->ireg_offset_range,\n\t\t\t\t pm_pio->ireg_local_offset);\n\t\tch_pm++;\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_tid(struct cudbg_init *pdbg_init,\n\t\t      struct cudbg_buffer *dbg_buff,\n\t\t      struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_tid_info_region_rev1 *tid1;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_tid_info_region *tid;\n\tu32 para[2], val[2];\n\tint rc;\n\n\trc = cudbg_get_buff(pdbg_init, dbg_buff,\n\t\t\t    sizeof(struct cudbg_tid_info_region_rev1),\n\t\t\t    &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\ttid1 = (struct cudbg_tid_info_region_rev1 *)temp_buff.data;\n\ttid = &tid1->tid;\n\ttid1->ver_hdr.signature = CUDBG_ENTITY_SIGNATURE;\n\ttid1->ver_hdr.revision = CUDBG_TID_INFO_REV;\n\ttid1->ver_hdr.size = sizeof(struct cudbg_tid_info_region_rev1) -\n\t\t\t     sizeof(struct cudbg_ver_hdr);\n\n\t \n\tif (!is_fw_attached(pdbg_init))\n\t\tgoto fill_tid;\n\n#define FW_PARAM_PFVF_A(param) \\\n\t(FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_PFVF) | \\\n\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_PFVF_##param) | \\\n\t FW_PARAMS_PARAM_Y_V(0) | \\\n\t FW_PARAMS_PARAM_Z_V(0))\n\n\tpara[0] = FW_PARAM_PFVF_A(ETHOFLD_START);\n\tpara[1] = FW_PARAM_PFVF_A(ETHOFLD_END);\n\trc = t4_query_params(padap, padap->mbox, padap->pf, 0, 2, para, val);\n\tif (rc <  0) {\n\t\tcudbg_err->sys_err = rc;\n\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\treturn rc;\n\t}\n\ttid->uotid_base = val[0];\n\ttid->nuotids = val[1] - val[0] + 1;\n\n\tif (is_t5(padap->params.chip)) {\n\t\ttid->sb = t4_read_reg(padap, LE_DB_SERVER_INDEX_A) / 4;\n\t} else if (is_t6(padap->params.chip)) {\n\t\ttid1->tid_start =\n\t\t\tt4_read_reg(padap, LE_DB_ACTIVE_TABLE_START_INDEX_A);\n\t\ttid->sb = t4_read_reg(padap, LE_DB_SRVR_START_INDEX_A);\n\n\t\tpara[0] = FW_PARAM_PFVF_A(HPFILTER_START);\n\t\tpara[1] = FW_PARAM_PFVF_A(HPFILTER_END);\n\t\trc = t4_query_params(padap, padap->mbox, padap->pf, 0, 2,\n\t\t\t\t     para, val);\n\t\tif (rc < 0) {\n\t\t\tcudbg_err->sys_err = rc;\n\t\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\t\treturn rc;\n\t\t}\n\t\ttid->hpftid_base = val[0];\n\t\ttid->nhpftids = val[1] - val[0] + 1;\n\t}\n\n#undef FW_PARAM_PFVF_A\n\nfill_tid:\n\ttid->ntids = padap->tids.ntids;\n\ttid->nstids = padap->tids.nstids;\n\ttid->stid_base = padap->tids.stid_base;\n\ttid->hash_base = padap->tids.hash_base;\n\n\ttid->natids = padap->tids.natids;\n\ttid->nftids = padap->tids.nftids;\n\ttid->ftid_base = padap->tids.ftid_base;\n\ttid->aftid_base = padap->tids.aftid_base;\n\ttid->aftid_end = padap->tids.aftid_end;\n\n\ttid->sftid_base = padap->tids.sftid_base;\n\ttid->nsftids = padap->tids.nsftids;\n\n\ttid->flags = padap->flags;\n\ttid->le_db_conf = t4_read_reg(padap, LE_DB_CONFIG_A);\n\ttid->ip_users = t4_read_reg(padap, LE_DB_ACT_CNT_IPV4_A);\n\ttid->ipv6_users = t4_read_reg(padap, LE_DB_ACT_CNT_IPV6_A);\n\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_pcie_config(struct cudbg_init *pdbg_init,\n\t\t\t      struct cudbg_buffer *dbg_buff,\n\t\t\t      struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tu32 size, *value, j;\n\tint i, rc, n;\n\n\tsize = sizeof(u32) * CUDBG_NUM_PCIE_CONFIG_REGS;\n\tn = sizeof(t5_pcie_config_array) / (2 * sizeof(u32));\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tvalue = (u32 *)temp_buff.data;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = t5_pcie_config_array[i][0];\n\t\t     j <= t5_pcie_config_array[i][1]; j += 4) {\n\t\t\tt4_hw_pci_read_cfg4(padap, j, value);\n\t\t\tvalue++;\n\t\t}\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nstatic int cudbg_sge_ctxt_check_valid(u32 *buf, int type)\n{\n\tint index, bit, bit_pos = 0;\n\n\tswitch (type) {\n\tcase CTXT_EGRESS:\n\t\tbit_pos = 176;\n\t\tbreak;\n\tcase CTXT_INGRESS:\n\t\tbit_pos = 141;\n\t\tbreak;\n\tcase CTXT_FLM:\n\t\tbit_pos = 89;\n\t\tbreak;\n\t}\n\tindex = bit_pos / 32;\n\tbit =  bit_pos % 32;\n\treturn buf[index] & (1U << bit);\n}\n\nstatic int cudbg_get_ctxt_region_info(struct adapter *padap,\n\t\t\t\t      struct cudbg_region_info *ctx_info,\n\t\t\t\t      u8 *mem_type)\n{\n\tstruct cudbg_mem_desc mem_desc;\n\tstruct cudbg_meminfo meminfo;\n\tu32 i, j, value, found;\n\tu8 flq;\n\tint rc;\n\n\trc = cudbg_fill_meminfo(padap, &meminfo);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tfor (i = CTXT_EGRESS; i <= CTXT_INGRESS; i++) {\n\t\tfound = 0;\n\t\tmemset(&mem_desc, 0, sizeof(struct cudbg_mem_desc));\n\t\tfor (j = 0; j < ARRAY_SIZE(meminfo.avail); j++) {\n\t\t\trc = cudbg_get_mem_region(padap, &meminfo, j,\n\t\t\t\t\t\t  cudbg_region[i],\n\t\t\t\t\t\t  &mem_desc);\n\t\t\tif (!rc) {\n\t\t\t\tfound = 1;\n\t\t\t\trc = cudbg_get_mem_relative(padap, &meminfo, j,\n\t\t\t\t\t\t\t    &mem_desc.base,\n\t\t\t\t\t\t\t    &mem_desc.limit);\n\t\t\t\tif (rc) {\n\t\t\t\t\tctx_info[i].exist = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctx_info[i].exist = true;\n\t\t\t\tctx_info[i].start = mem_desc.base;\n\t\t\t\tctx_info[i].end = mem_desc.limit;\n\t\t\t\tmem_type[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tctx_info[i].exist = false;\n\t}\n\n\t \n\tvalue = t4_read_reg(padap, SGE_FLM_CFG_A);\n\n\t \n\tflq = HDRSTARTFLQ_G(value);\n\tctx_info[CTXT_FLM].exist = true;\n\tctx_info[CTXT_FLM].end = (CUDBG_MAX_FL_QIDS >> flq) * SGE_CTXT_SIZE;\n\n\t \n\tctx_info[CTXT_CNM].exist = true;\n\tctx_info[CTXT_CNM].end = ctx_info[CTXT_FLM].end;\n\n\treturn 0;\n}\n\nint cudbg_dump_context_size(struct adapter *padap)\n{\n\tstruct cudbg_region_info region_info[CTXT_CNM + 1] = { {0} };\n\tu8 mem_type[CTXT_INGRESS + 1] = { 0 };\n\tu32 i, size = 0;\n\tint rc;\n\n\t \n\trc = cudbg_get_ctxt_region_info(padap, region_info, mem_type);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < CTXT_CNM; i++) {\n\t\tif (!region_info[i].exist) {\n\t\t\tif (i == CTXT_EGRESS || i == CTXT_INGRESS)\n\t\t\t\tsize += CUDBG_LOWMEM_MAX_CTXT_QIDS *\n\t\t\t\t\tSGE_CTXT_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsize += (region_info[i].end - region_info[i].start + 1) /\n\t\t\tSGE_CTXT_SIZE;\n\t}\n\treturn size * sizeof(struct cudbg_ch_cntxt);\n}\n\nstatic void cudbg_read_sge_ctxt(struct cudbg_init *pdbg_init, u32 cid,\n\t\t\t\tenum ctxt_type ctype, u32 *data)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tint rc = -1;\n\n\t \n\tif (is_fw_attached(pdbg_init))\n\t\trc = t4_sge_ctxt_rd(padap, padap->mbox, cid, ctype, data);\n\tif (rc)\n\t\tt4_sge_ctxt_rd_bd(padap, cid, ctype, data);\n}\n\nstatic void cudbg_get_sge_ctxt_fw(struct cudbg_init *pdbg_init, u32 max_qid,\n\t\t\t\t  u8 ctxt_type,\n\t\t\t\t  struct cudbg_ch_cntxt **out_buff)\n{\n\tstruct cudbg_ch_cntxt *buff = *out_buff;\n\tint rc;\n\tu32 j;\n\n\tfor (j = 0; j < max_qid; j++) {\n\t\tcudbg_read_sge_ctxt(pdbg_init, j, ctxt_type, buff->data);\n\t\trc = cudbg_sge_ctxt_check_valid(buff->data, ctxt_type);\n\t\tif (!rc)\n\t\t\tcontinue;\n\n\t\tbuff->cntxt_type = ctxt_type;\n\t\tbuff->cntxt_id = j;\n\t\tbuff++;\n\t\tif (ctxt_type == CTXT_FLM) {\n\t\t\tcudbg_read_sge_ctxt(pdbg_init, j, CTXT_CNM, buff->data);\n\t\t\tbuff->cntxt_type = CTXT_CNM;\n\t\t\tbuff->cntxt_id = j;\n\t\t\tbuff++;\n\t\t}\n\t}\n\n\t*out_buff = buff;\n}\n\nint cudbg_collect_dump_context(struct cudbg_init *pdbg_init,\n\t\t\t       struct cudbg_buffer *dbg_buff,\n\t\t\t       struct cudbg_error *cudbg_err)\n{\n\tstruct cudbg_region_info region_info[CTXT_CNM + 1] = { {0} };\n\tstruct adapter *padap = pdbg_init->adap;\n\tu32 j, size, max_ctx_size, max_ctx_qid;\n\tu8 mem_type[CTXT_INGRESS + 1] = { 0 };\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_ch_cntxt *buff;\n\tu8 *ctx_buf;\n\tu8 i, k;\n\tint rc;\n\n\t \n\trc = cudbg_get_ctxt_region_info(padap, region_info, mem_type);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cudbg_dump_context_size(padap);\n\tif (rc <= 0)\n\t\treturn CUDBG_STATUS_ENTITY_NOT_FOUND;\n\n\tsize = rc;\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tmax_ctx_size = max(region_info[CTXT_EGRESS].end -\n\t\t\t   region_info[CTXT_EGRESS].start + 1,\n\t\t\t   region_info[CTXT_INGRESS].end -\n\t\t\t   region_info[CTXT_INGRESS].start + 1);\n\n\tctx_buf = kvzalloc(max_ctx_size, GFP_KERNEL);\n\tif (!ctx_buf) {\n\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\treturn -ENOMEM;\n\t}\n\n\tbuff = (struct cudbg_ch_cntxt *)temp_buff.data;\n\n\t \n\tfor (i = CTXT_EGRESS; i <= CTXT_INGRESS; i++) {\n\t\tif (!region_info[i].exist) {\n\t\t\tmax_ctx_qid = CUDBG_LOWMEM_MAX_CTXT_QIDS;\n\t\t\tcudbg_get_sge_ctxt_fw(pdbg_init, max_ctx_qid, i,\n\t\t\t\t\t      &buff);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmax_ctx_size = region_info[i].end - region_info[i].start + 1;\n\t\tmax_ctx_qid = max_ctx_size / SGE_CTXT_SIZE;\n\n\t\t \n\t\tif (is_fw_attached(pdbg_init)) {\n\t\t\tt4_sge_ctxt_flush(padap, padap->mbox, i);\n\n\t\t\trc = t4_memory_rw(padap, MEMWIN_NIC, mem_type[i],\n\t\t\t\t\t  region_info[i].start, max_ctx_size,\n\t\t\t\t\t  (__be32 *)ctx_buf, 1);\n\t\t}\n\n\t\tif (rc || !is_fw_attached(pdbg_init)) {\n\t\t\tmax_ctx_qid = CUDBG_LOWMEM_MAX_CTXT_QIDS;\n\t\t\tcudbg_get_sge_ctxt_fw(pdbg_init, max_ctx_qid, i,\n\t\t\t\t\t      &buff);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < max_ctx_qid; j++) {\n\t\t\t__be64 *dst_off;\n\t\t\tu64 *src_off;\n\n\t\t\tsrc_off = (u64 *)(ctx_buf + j * SGE_CTXT_SIZE);\n\t\t\tdst_off = (__be64 *)buff->data;\n\n\t\t\t \n\t\t\tfor (k = 0; k < SGE_CTXT_SIZE / sizeof(u64); k++)\n\t\t\t\tdst_off[k] = cpu_to_be64(src_off[k]);\n\n\t\t\trc = cudbg_sge_ctxt_check_valid(buff->data, i);\n\t\t\tif (!rc)\n\t\t\t\tcontinue;\n\n\t\t\tbuff->cntxt_type = i;\n\t\t\tbuff->cntxt_id = j;\n\t\t\tbuff++;\n\t\t}\n\t}\n\n\tkvfree(ctx_buf);\n\n\t \n\tmax_ctx_size = region_info[CTXT_FLM].end -\n\t\t       region_info[CTXT_FLM].start + 1;\n\tmax_ctx_qid = max_ctx_size / SGE_CTXT_SIZE;\n\t \n\tcudbg_get_sge_ctxt_fw(pdbg_init, max_ctx_qid, CTXT_FLM, &buff);\n\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nstatic inline void cudbg_tcamxy2valmask(u64 x, u64 y, u8 *addr, u64 *mask)\n{\n\t*mask = x | y;\n\ty = (__force u64)cpu_to_be64(y);\n\tmemcpy(addr, (char *)&y + 2, ETH_ALEN);\n}\n\nstatic void cudbg_mps_rpl_backdoor(struct adapter *padap,\n\t\t\t\t   struct fw_ldst_mps_rplc *mps_rplc)\n{\n\tif (is_t5(padap->params.chip)) {\n\t\tmps_rplc->rplc255_224 = htonl(t4_read_reg(padap,\n\t\t\t\t\t\t\t  MPS_VF_RPLCT_MAP3_A));\n\t\tmps_rplc->rplc223_192 = htonl(t4_read_reg(padap,\n\t\t\t\t\t\t\t  MPS_VF_RPLCT_MAP2_A));\n\t\tmps_rplc->rplc191_160 = htonl(t4_read_reg(padap,\n\t\t\t\t\t\t\t  MPS_VF_RPLCT_MAP1_A));\n\t\tmps_rplc->rplc159_128 = htonl(t4_read_reg(padap,\n\t\t\t\t\t\t\t  MPS_VF_RPLCT_MAP0_A));\n\t} else {\n\t\tmps_rplc->rplc255_224 = htonl(t4_read_reg(padap,\n\t\t\t\t\t\t\t  MPS_VF_RPLCT_MAP7_A));\n\t\tmps_rplc->rplc223_192 = htonl(t4_read_reg(padap,\n\t\t\t\t\t\t\t  MPS_VF_RPLCT_MAP6_A));\n\t\tmps_rplc->rplc191_160 = htonl(t4_read_reg(padap,\n\t\t\t\t\t\t\t  MPS_VF_RPLCT_MAP5_A));\n\t\tmps_rplc->rplc159_128 = htonl(t4_read_reg(padap,\n\t\t\t\t\t\t\t  MPS_VF_RPLCT_MAP4_A));\n\t}\n\tmps_rplc->rplc127_96 = htonl(t4_read_reg(padap, MPS_VF_RPLCT_MAP3_A));\n\tmps_rplc->rplc95_64 = htonl(t4_read_reg(padap, MPS_VF_RPLCT_MAP2_A));\n\tmps_rplc->rplc63_32 = htonl(t4_read_reg(padap, MPS_VF_RPLCT_MAP1_A));\n\tmps_rplc->rplc31_0 = htonl(t4_read_reg(padap, MPS_VF_RPLCT_MAP0_A));\n}\n\nstatic int cudbg_collect_tcam_index(struct cudbg_init *pdbg_init,\n\t\t\t\t    struct cudbg_mps_tcam *tcam, u32 idx)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tu64 tcamy, tcamx, val;\n\tu32 ctl, data2;\n\tint rc = 0;\n\n\tif (CHELSIO_CHIP_VERSION(padap->params.chip) >= CHELSIO_T6) {\n\t\t \n\n\t\t \n\t\tctl = CTLREQID_V(1) | CTLCMDTYPE_V(0) | CTLXYBITSEL_V(0);\n\t\tif (idx < 256)\n\t\t\tctl |= CTLTCAMINDEX_V(idx) | CTLTCAMSEL_V(0);\n\t\telse\n\t\t\tctl |= CTLTCAMINDEX_V(idx - 256) | CTLTCAMSEL_V(1);\n\n\t\tt4_write_reg(padap, MPS_CLS_TCAM_DATA2_CTL_A, ctl);\n\t\tval = t4_read_reg(padap, MPS_CLS_TCAM_RDATA1_REQ_ID1_A);\n\t\ttcamy = DMACH_G(val) << 32;\n\t\ttcamy |= t4_read_reg(padap, MPS_CLS_TCAM_RDATA0_REQ_ID1_A);\n\t\tdata2 = t4_read_reg(padap, MPS_CLS_TCAM_RDATA2_REQ_ID1_A);\n\t\ttcam->lookup_type = DATALKPTYPE_G(data2);\n\n\t\t \n\t\tif (tcam->lookup_type && tcam->lookup_type != DATALKPTYPE_M) {\n\t\t\t \n\t\t\ttcam->vniy = (data2 & DATAVIDH2_F) | DATAVIDH1_G(data2);\n\t\t\ttcam->vniy = (tcam->vniy << 16) | VIDL_G(val);\n\t\t\ttcam->dip_hit = data2 & DATADIPHIT_F;\n\t\t} else {\n\t\t\ttcam->vlan_vld = data2 & DATAVIDH2_F;\n\t\t\ttcam->ivlan = VIDL_G(val);\n\t\t}\n\n\t\ttcam->port_num = DATAPORTNUM_G(data2);\n\n\t\t \n\t\tctl |= CTLXYBITSEL_V(1);\n\t\tt4_write_reg(padap, MPS_CLS_TCAM_DATA2_CTL_A, ctl);\n\t\tval = t4_read_reg(padap, MPS_CLS_TCAM_RDATA1_REQ_ID1_A);\n\t\ttcamx = DMACH_G(val) << 32;\n\t\ttcamx |= t4_read_reg(padap, MPS_CLS_TCAM_RDATA0_REQ_ID1_A);\n\t\tdata2 = t4_read_reg(padap, MPS_CLS_TCAM_RDATA2_REQ_ID1_A);\n\t\tif (tcam->lookup_type && tcam->lookup_type != DATALKPTYPE_M) {\n\t\t\t \n\t\t\ttcam->vnix = (data2 & DATAVIDH2_F) | DATAVIDH1_G(data2);\n\t\t\ttcam->vnix = (tcam->vnix << 16) | VIDL_G(val);\n\t\t}\n\t} else {\n\t\ttcamy = t4_read_reg64(padap, MPS_CLS_TCAM_Y_L(idx));\n\t\ttcamx = t4_read_reg64(padap, MPS_CLS_TCAM_X_L(idx));\n\t}\n\n\t \n\tif (tcamx & tcamy)\n\t\treturn rc;\n\n\ttcam->cls_lo = t4_read_reg(padap, MPS_CLS_SRAM_L(idx));\n\ttcam->cls_hi = t4_read_reg(padap, MPS_CLS_SRAM_H(idx));\n\n\tif (is_t5(padap->params.chip))\n\t\ttcam->repli = (tcam->cls_lo & REPLICATE_F);\n\telse if (is_t6(padap->params.chip))\n\t\ttcam->repli = (tcam->cls_lo & T6_REPLICATE_F);\n\n\tif (tcam->repli) {\n\t\tstruct fw_ldst_cmd ldst_cmd;\n\t\tstruct fw_ldst_mps_rplc mps_rplc;\n\n\t\tmemset(&ldst_cmd, 0, sizeof(ldst_cmd));\n\t\tldst_cmd.op_to_addrspace =\n\t\t\thtonl(FW_CMD_OP_V(FW_LDST_CMD) |\n\t\t\t      FW_CMD_REQUEST_F | FW_CMD_READ_F |\n\t\t\t      FW_LDST_CMD_ADDRSPACE_V(FW_LDST_ADDRSPC_MPS));\n\t\tldst_cmd.cycles_to_len16 = htonl(FW_LEN16(ldst_cmd));\n\t\tldst_cmd.u.mps.rplc.fid_idx =\n\t\t\thtons(FW_LDST_CMD_FID_V(FW_LDST_MPS_RPLC) |\n\t\t\t      FW_LDST_CMD_IDX_V(idx));\n\n\t\t \n\t\tif (is_fw_attached(pdbg_init))\n\t\t\trc = t4_wr_mbox(padap, padap->mbox, &ldst_cmd,\n\t\t\t\t\tsizeof(ldst_cmd), &ldst_cmd);\n\n\t\tif (rc || !is_fw_attached(pdbg_init)) {\n\t\t\tcudbg_mps_rpl_backdoor(padap, &mps_rplc);\n\t\t\t \n\t\t\trc = 0;\n\t\t} else {\n\t\t\tmps_rplc = ldst_cmd.u.mps.rplc;\n\t\t}\n\n\t\ttcam->rplc[0] = ntohl(mps_rplc.rplc31_0);\n\t\ttcam->rplc[1] = ntohl(mps_rplc.rplc63_32);\n\t\ttcam->rplc[2] = ntohl(mps_rplc.rplc95_64);\n\t\ttcam->rplc[3] = ntohl(mps_rplc.rplc127_96);\n\t\tif (padap->params.arch.mps_rplc_size > CUDBG_MAX_RPLC_SIZE) {\n\t\t\ttcam->rplc[4] = ntohl(mps_rplc.rplc159_128);\n\t\t\ttcam->rplc[5] = ntohl(mps_rplc.rplc191_160);\n\t\t\ttcam->rplc[6] = ntohl(mps_rplc.rplc223_192);\n\t\t\ttcam->rplc[7] = ntohl(mps_rplc.rplc255_224);\n\t\t}\n\t}\n\tcudbg_tcamxy2valmask(tcamx, tcamy, tcam->addr, &tcam->mask);\n\ttcam->idx = idx;\n\ttcam->rplc_size = padap->params.arch.mps_rplc_size;\n\treturn rc;\n}\n\nint cudbg_collect_mps_tcam(struct cudbg_init *pdbg_init,\n\t\t\t   struct cudbg_buffer *dbg_buff,\n\t\t\t   struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tu32 size = 0, i, n, total_size = 0;\n\tstruct cudbg_mps_tcam *tcam;\n\tint rc;\n\n\tn = padap->params.arch.mps_tcam_size;\n\tsize = sizeof(struct cudbg_mps_tcam) * n;\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\ttcam = (struct cudbg_mps_tcam *)temp_buff.data;\n\tfor (i = 0; i < n; i++) {\n\t\trc = cudbg_collect_tcam_index(pdbg_init, tcam, i);\n\t\tif (rc) {\n\t\t\tcudbg_err->sys_err = rc;\n\t\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\t\treturn rc;\n\t\t}\n\t\ttotal_size += sizeof(struct cudbg_mps_tcam);\n\t\ttcam++;\n\t}\n\n\tif (!total_size) {\n\t\trc = CUDBG_SYSTEM_ERROR;\n\t\tcudbg_err->sys_err = rc;\n\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\treturn rc;\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_vpd_data(struct cudbg_init *pdbg_init,\n\t\t\t   struct cudbg_buffer *dbg_buff,\n\t\t\t   struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tchar vpd_str[CUDBG_VPD_VER_LEN + 1];\n\tstruct cudbg_vpd_data *vpd_data;\n\tstruct vpd_params vpd = { 0 };\n\tu32 vpd_vers, fw_vers;\n\tint rc;\n\n\trc = t4_get_raw_vpd_params(padap, &vpd);\n\tif (rc)\n\t\treturn rc;\n\n\trc = t4_get_fw_version(padap, &fw_vers);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cudbg_read_vpd_reg(padap, CUDBG_VPD_VER_ADDR, CUDBG_VPD_VER_LEN,\n\t\t\t\tvpd_str);\n\tif (rc)\n\t\treturn rc;\n\n\tvpd_str[CUDBG_VPD_VER_LEN] = '\\0';\n\trc = kstrtouint(vpd_str, 0, &vpd_vers);\n\tif (rc)\n\t\treturn rc;\n\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_vpd_data),\n\t\t\t    &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tvpd_data = (struct cudbg_vpd_data *)temp_buff.data;\n\tmemcpy(vpd_data->sn, vpd.sn, SERNUM_LEN + 1);\n\tmemcpy(vpd_data->bn, vpd.pn, PN_LEN + 1);\n\tmemcpy(vpd_data->na, vpd.na, MACADDR_LEN + 1);\n\tmemcpy(vpd_data->mn, vpd.id, ID_LEN + 1);\n\tvpd_data->scfg_vers = t4_read_reg(padap, PCIE_STATIC_SPARE2_A);\n\tvpd_data->vpd_vers = vpd_vers;\n\tvpd_data->fw_major = FW_HDR_FW_VER_MAJOR_G(fw_vers);\n\tvpd_data->fw_minor = FW_HDR_FW_VER_MINOR_G(fw_vers);\n\tvpd_data->fw_micro = FW_HDR_FW_VER_MICRO_G(fw_vers);\n\tvpd_data->fw_build = FW_HDR_FW_VER_BUILD_G(fw_vers);\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nstatic int cudbg_read_tid(struct cudbg_init *pdbg_init, u32 tid,\n\t\t\t  struct cudbg_tid_data *tid_data)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tint i, cmd_retry = 8;\n\tu32 val;\n\n\t \n\tfor (i = 0; i < NUM_LE_DB_DBGI_REQ_DATA_INSTANCES; i++)\n\t\tt4_write_reg(padap, LE_DB_DBGI_REQ_DATA_A + (i << 2), 0);\n\n\t \n\tval = DBGICMD_V(4) | DBGITID_V(tid);\n\tt4_write_reg(padap, LE_DB_DBGI_REQ_TCAM_CMD_A, val);\n\ttid_data->dbig_cmd = val;\n\n\tval = DBGICMDSTRT_F | DBGICMDMODE_V(1);  \n\tt4_write_reg(padap, LE_DB_DBGI_CONFIG_A, val);\n\ttid_data->dbig_conf = val;\n\n\t \n\tval = 1;\n\twhile (val) {\n\t\tval = t4_read_reg(padap, LE_DB_DBGI_CONFIG_A);\n\t\tval = val & DBGICMDBUSY_F;\n\t\tcmd_retry--;\n\t\tif (!cmd_retry)\n\t\t\treturn CUDBG_SYSTEM_ERROR;\n\t}\n\n\t \n\tval = t4_read_reg(padap, LE_DB_DBGI_RSP_STATUS_A);\n\ttid_data->dbig_rsp_stat = val;\n\tif (!(val & 1))\n\t\treturn CUDBG_SYSTEM_ERROR;\n\n\t \n\tfor (i = 0; i < NUM_LE_DB_DBGI_RSP_DATA_INSTANCES; i++)\n\t\ttid_data->data[i] = t4_read_reg(padap,\n\t\t\t\t\t\tLE_DB_DBGI_RSP_DATA_A +\n\t\t\t\t\t\t(i << 2));\n\ttid_data->tid = tid;\n\treturn 0;\n}\n\nstatic int cudbg_get_le_type(u32 tid, struct cudbg_tcam tcam_region)\n{\n\tint type = LE_ET_UNKNOWN;\n\n\tif (tid < tcam_region.server_start)\n\t\ttype = LE_ET_TCAM_CON;\n\telse if (tid < tcam_region.filter_start)\n\t\ttype = LE_ET_TCAM_SERVER;\n\telse if (tid < tcam_region.clip_start)\n\t\ttype = LE_ET_TCAM_FILTER;\n\telse if (tid < tcam_region.routing_start)\n\t\ttype = LE_ET_TCAM_CLIP;\n\telse if (tid < tcam_region.tid_hash_base)\n\t\ttype = LE_ET_TCAM_ROUTING;\n\telse if (tid < tcam_region.max_tid)\n\t\ttype = LE_ET_HASH_CON;\n\telse\n\t\ttype = LE_ET_INVALID_TID;\n\n\treturn type;\n}\n\nstatic int cudbg_is_ipv6_entry(struct cudbg_tid_data *tid_data,\n\t\t\t       struct cudbg_tcam tcam_region)\n{\n\tint ipv6 = 0;\n\tint le_type;\n\n\tle_type = cudbg_get_le_type(tid_data->tid, tcam_region);\n\tif (tid_data->tid & 1)\n\t\treturn 0;\n\n\tif (le_type == LE_ET_HASH_CON) {\n\t\tipv6 = tid_data->data[16] & 0x8000;\n\t} else if (le_type == LE_ET_TCAM_CON) {\n\t\tipv6 = tid_data->data[16] & 0x8000;\n\t\tif (ipv6)\n\t\t\tipv6 = tid_data->data[9] == 0x00C00000;\n\t} else {\n\t\tipv6 = 0;\n\t}\n\treturn ipv6;\n}\n\nvoid cudbg_fill_le_tcam_info(struct adapter *padap,\n\t\t\t     struct cudbg_tcam *tcam_region)\n{\n\tu32 value;\n\n\t \n\tvalue = t4_read_reg(padap, LE_DB_TID_HASHBASE_A);  \n\ttcam_region->tid_hash_base = value;\n\n\t \n\tvalue = t4_read_reg(padap, LE_DB_ROUTING_TABLE_INDEX_A);\n\ttcam_region->routing_start = value;\n\n\t \n\tif (is_t6(padap->params.chip))\n\t\tvalue = t4_read_reg(padap, LE_DB_CLCAM_TID_BASE_A);\n\telse\n\t\tvalue = t4_read_reg(padap, LE_DB_CLIP_TABLE_INDEX_A);\n\ttcam_region->clip_start = value;\n\n\t \n\tvalue = t4_read_reg(padap, LE_DB_FILTER_TABLE_INDEX_A);\n\ttcam_region->filter_start = value;\n\n\t \n\tvalue = t4_read_reg(padap, LE_DB_SERVER_INDEX_A);\n\ttcam_region->server_start = value;\n\n\t \n\tvalue = t4_read_reg(padap, LE_DB_CONFIG_A);\n\tif ((value >> HASHEN_S) & 1) {\n\t\tvalue = t4_read_reg(padap, LE_DB_HASH_CONFIG_A);\n\t\tif (CHELSIO_CHIP_VERSION(padap->params.chip) > CHELSIO_T5) {\n\t\t\ttcam_region->max_tid = (value & 0xFFFFF) +\n\t\t\t\t\t       tcam_region->tid_hash_base;\n\t\t} else {\n\t\t\tvalue = HASHTIDSIZE_G(value);\n\t\t\tvalue = 1 << value;\n\t\t\ttcam_region->max_tid = value +\n\t\t\t\t\t       tcam_region->tid_hash_base;\n\t\t}\n\t} else {  \n\t\tif (is_t6(padap->params.chip))\n\t\t\ttcam_region->max_tid = (value & ASLIPCOMPEN_F) ?\n\t\t\t\t\t       CUDBG_MAX_TID_COMP_EN :\n\t\t\t\t\t       CUDBG_MAX_TID_COMP_DIS;\n\t\telse\n\t\t\ttcam_region->max_tid = CUDBG_MAX_TCAM_TID;\n\t}\n\n\tif (is_t6(padap->params.chip))\n\t\ttcam_region->max_tid += CUDBG_T6_CLIP;\n}\n\nint cudbg_collect_le_tcam(struct cudbg_init *pdbg_init,\n\t\t\t  struct cudbg_buffer *dbg_buff,\n\t\t\t  struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_tcam tcam_region = { 0 };\n\tstruct cudbg_tid_data *tid_data;\n\tu32 bytes = 0;\n\tint rc, size;\n\tu32 i;\n\n\tcudbg_fill_le_tcam_info(padap, &tcam_region);\n\n\tsize = sizeof(struct cudbg_tid_data) * tcam_region.max_tid;\n\tsize += sizeof(struct cudbg_tcam);\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(temp_buff.data, &tcam_region, sizeof(struct cudbg_tcam));\n\tbytes = sizeof(struct cudbg_tcam);\n\ttid_data = (struct cudbg_tid_data *)(temp_buff.data + bytes);\n\t \n\tfor (i = 0; i < tcam_region.max_tid; ) {\n\t\trc = cudbg_read_tid(pdbg_init, i, tid_data);\n\t\tif (rc) {\n\t\t\tcudbg_err->sys_warn = CUDBG_STATUS_PARTIAL_DATA;\n\t\t\t \n\t\t\ttcam_region.max_tid = i;\n\t\t\tmemcpy(temp_buff.data, &tcam_region,\n\t\t\t       sizeof(struct cudbg_tcam));\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cudbg_is_ipv6_entry(tid_data, tcam_region)) {\n\t\t\t \n\t\t\tif (is_t6(padap->params.chip) &&\n\t\t\t    i >= tcam_region.clip_start &&\n\t\t\t    i < tcam_region.clip_start + CUDBG_T6_CLIP)\n\t\t\t\ti += 4;\n\t\t\telse  \n\t\t\t\ti += 2;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\n\t\ttid_data++;\n\t\tbytes += sizeof(struct cudbg_tid_data);\n\t}\n\nout:\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_cctrl(struct cudbg_init *pdbg_init,\n\t\t\tstruct cudbg_buffer *dbg_buff,\n\t\t\tstruct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tu32 size;\n\tint rc;\n\n\tsize = sizeof(u16) * NMTUS * NCCTRL_WIN;\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tt4_read_cong_tbl(padap, (void *)temp_buff.data);\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_ma_indirect(struct cudbg_init *pdbg_init,\n\t\t\t      struct cudbg_buffer *dbg_buff,\n\t\t\t      struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct ireg_buf *ma_indr;\n\tint i, rc, n;\n\tu32 size, j;\n\n\tif (CHELSIO_CHIP_VERSION(padap->params.chip) < CHELSIO_T6)\n\t\treturn CUDBG_STATUS_ENTITY_NOT_FOUND;\n\n\tn = sizeof(t6_ma_ireg_array) / (IREG_NUM_ELEM * sizeof(u32));\n\tsize = sizeof(struct ireg_buf) * n * 2;\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tma_indr = (struct ireg_buf *)temp_buff.data;\n\tfor (i = 0; i < n; i++) {\n\t\tstruct ireg_field *ma_fli = &ma_indr->tp_pio;\n\t\tu32 *buff = ma_indr->outbuf;\n\n\t\tma_fli->ireg_addr = t6_ma_ireg_array[i][0];\n\t\tma_fli->ireg_data = t6_ma_ireg_array[i][1];\n\t\tma_fli->ireg_local_offset = t6_ma_ireg_array[i][2];\n\t\tma_fli->ireg_offset_range = t6_ma_ireg_array[i][3];\n\t\tt4_read_indirect(padap, ma_fli->ireg_addr, ma_fli->ireg_data,\n\t\t\t\t buff, ma_fli->ireg_offset_range,\n\t\t\t\t ma_fli->ireg_local_offset);\n\t\tma_indr++;\n\t}\n\n\tn = sizeof(t6_ma_ireg_array2) / (IREG_NUM_ELEM * sizeof(u32));\n\tfor (i = 0; i < n; i++) {\n\t\tstruct ireg_field *ma_fli = &ma_indr->tp_pio;\n\t\tu32 *buff = ma_indr->outbuf;\n\n\t\tma_fli->ireg_addr = t6_ma_ireg_array2[i][0];\n\t\tma_fli->ireg_data = t6_ma_ireg_array2[i][1];\n\t\tma_fli->ireg_local_offset = t6_ma_ireg_array2[i][2];\n\t\tfor (j = 0; j < t6_ma_ireg_array2[i][3]; j++) {\n\t\t\tt4_read_indirect(padap, ma_fli->ireg_addr,\n\t\t\t\t\t ma_fli->ireg_data, buff, 1,\n\t\t\t\t\t ma_fli->ireg_local_offset);\n\t\t\tbuff++;\n\t\t\tma_fli->ireg_local_offset += 0x20;\n\t\t}\n\t\tma_indr++;\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_ulptx_la(struct cudbg_init *pdbg_init,\n\t\t\t   struct cudbg_buffer *dbg_buff,\n\t\t\t   struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_ulptx_la *ulptx_la_buff;\n\tstruct cudbg_ver_hdr *ver_hdr;\n\tu32 i, j;\n\tint rc;\n\n\trc = cudbg_get_buff(pdbg_init, dbg_buff,\n\t\t\t    sizeof(struct cudbg_ver_hdr) +\n\t\t\t    sizeof(struct cudbg_ulptx_la),\n\t\t\t    &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tver_hdr = (struct cudbg_ver_hdr *)temp_buff.data;\n\tver_hdr->signature = CUDBG_ENTITY_SIGNATURE;\n\tver_hdr->revision = CUDBG_ULPTX_LA_REV;\n\tver_hdr->size = sizeof(struct cudbg_ulptx_la);\n\n\tulptx_la_buff = (struct cudbg_ulptx_la *)(temp_buff.data +\n\t\t\t\t\t\t  sizeof(*ver_hdr));\n\tfor (i = 0; i < CUDBG_NUM_ULPTX; i++) {\n\t\tulptx_la_buff->rdptr[i] = t4_read_reg(padap,\n\t\t\t\t\t\t      ULP_TX_LA_RDPTR_0_A +\n\t\t\t\t\t\t      0x10 * i);\n\t\tulptx_la_buff->wrptr[i] = t4_read_reg(padap,\n\t\t\t\t\t\t      ULP_TX_LA_WRPTR_0_A +\n\t\t\t\t\t\t      0x10 * i);\n\t\tulptx_la_buff->rddata[i] = t4_read_reg(padap,\n\t\t\t\t\t\t       ULP_TX_LA_RDDATA_0_A +\n\t\t\t\t\t\t       0x10 * i);\n\t\tfor (j = 0; j < CUDBG_NUM_ULPTX_READ; j++)\n\t\t\tulptx_la_buff->rd_data[i][j] =\n\t\t\t\tt4_read_reg(padap,\n\t\t\t\t\t    ULP_TX_LA_RDDATA_0_A + 0x10 * i);\n\t}\n\n\tfor (i = 0; i < CUDBG_NUM_ULPTX_ASIC_READ; i++) {\n\t\tt4_write_reg(padap, ULP_TX_ASIC_DEBUG_CTRL_A, 0x1);\n\t\tulptx_la_buff->rdptr_asic[i] =\n\t\t\t\tt4_read_reg(padap, ULP_TX_ASIC_DEBUG_CTRL_A);\n\t\tulptx_la_buff->rddata_asic[i][0] =\n\t\t\t\tt4_read_reg(padap, ULP_TX_ASIC_DEBUG_0_A);\n\t\tulptx_la_buff->rddata_asic[i][1] =\n\t\t\t\tt4_read_reg(padap, ULP_TX_ASIC_DEBUG_1_A);\n\t\tulptx_la_buff->rddata_asic[i][2] =\n\t\t\t\tt4_read_reg(padap, ULP_TX_ASIC_DEBUG_2_A);\n\t\tulptx_la_buff->rddata_asic[i][3] =\n\t\t\t\tt4_read_reg(padap, ULP_TX_ASIC_DEBUG_3_A);\n\t\tulptx_la_buff->rddata_asic[i][4] =\n\t\t\t\tt4_read_reg(padap, ULP_TX_ASIC_DEBUG_4_A);\n\t\tulptx_la_buff->rddata_asic[i][5] =\n\t\t\t\tt4_read_reg(padap, PM_RX_BASE_ADDR);\n\t}\n\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_up_cim_indirect(struct cudbg_init *pdbg_init,\n\t\t\t\t  struct cudbg_buffer *dbg_buff,\n\t\t\t\t  struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tu32 local_offset, local_range;\n\tstruct ireg_buf *up_cim;\n\tu32 size, j, iter;\n\tu32 instance = 0;\n\tint i, rc, n;\n\n\tif (is_t5(padap->params.chip))\n\t\tn = sizeof(t5_up_cim_reg_array) /\n\t\t    ((IREG_NUM_ELEM + 1) * sizeof(u32));\n\telse if (is_t6(padap->params.chip))\n\t\tn = sizeof(t6_up_cim_reg_array) /\n\t\t    ((IREG_NUM_ELEM + 1) * sizeof(u32));\n\telse\n\t\treturn CUDBG_STATUS_NOT_IMPLEMENTED;\n\n\tsize = sizeof(struct ireg_buf) * n;\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tup_cim = (struct ireg_buf *)temp_buff.data;\n\tfor (i = 0; i < n; i++) {\n\t\tstruct ireg_field *up_cim_reg = &up_cim->tp_pio;\n\t\tu32 *buff = up_cim->outbuf;\n\n\t\tif (is_t5(padap->params.chip)) {\n\t\t\tup_cim_reg->ireg_addr = t5_up_cim_reg_array[i][0];\n\t\t\tup_cim_reg->ireg_data = t5_up_cim_reg_array[i][1];\n\t\t\tup_cim_reg->ireg_local_offset =\n\t\t\t\t\t\tt5_up_cim_reg_array[i][2];\n\t\t\tup_cim_reg->ireg_offset_range =\n\t\t\t\t\t\tt5_up_cim_reg_array[i][3];\n\t\t\tinstance = t5_up_cim_reg_array[i][4];\n\t\t} else if (is_t6(padap->params.chip)) {\n\t\t\tup_cim_reg->ireg_addr = t6_up_cim_reg_array[i][0];\n\t\t\tup_cim_reg->ireg_data = t6_up_cim_reg_array[i][1];\n\t\t\tup_cim_reg->ireg_local_offset =\n\t\t\t\t\t\tt6_up_cim_reg_array[i][2];\n\t\t\tup_cim_reg->ireg_offset_range =\n\t\t\t\t\t\tt6_up_cim_reg_array[i][3];\n\t\t\tinstance = t6_up_cim_reg_array[i][4];\n\t\t}\n\n\t\tswitch (instance) {\n\t\tcase NUM_CIM_CTL_TSCH_CHANNEL_INSTANCES:\n\t\t\titer = up_cim_reg->ireg_offset_range;\n\t\t\tlocal_offset = 0x120;\n\t\t\tlocal_range = 1;\n\t\t\tbreak;\n\t\tcase NUM_CIM_CTL_TSCH_CHANNEL_TSCH_CLASS_INSTANCES:\n\t\t\titer = up_cim_reg->ireg_offset_range;\n\t\t\tlocal_offset = 0x10;\n\t\t\tlocal_range = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\titer = 1;\n\t\t\tlocal_offset = 0;\n\t\t\tlocal_range = up_cim_reg->ireg_offset_range;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (j = 0; j < iter; j++, buff++) {\n\t\t\trc = t4_cim_read(padap,\n\t\t\t\t\t up_cim_reg->ireg_local_offset +\n\t\t\t\t\t (j * local_offset), local_range, buff);\n\t\t\tif (rc) {\n\t\t\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\tup_cim++;\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_pbt_tables(struct cudbg_init *pdbg_init,\n\t\t\t     struct cudbg_buffer *dbg_buff,\n\t\t\t     struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_pbt_tables *pbt;\n\tint i, rc;\n\tu32 addr;\n\n\trc = cudbg_get_buff(pdbg_init, dbg_buff,\n\t\t\t    sizeof(struct cudbg_pbt_tables),\n\t\t\t    &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tpbt = (struct cudbg_pbt_tables *)temp_buff.data;\n\t \n\taddr = CUDBG_CHAC_PBT_ADDR;\n\tfor (i = 0; i < CUDBG_PBT_DYNAMIC_ENTRIES; i++) {\n\t\trc = t4_cim_read(padap, addr + (i * 4), 1,\n\t\t\t\t &pbt->pbt_dynamic[i]);\n\t\tif (rc) {\n\t\t\tcudbg_err->sys_err = rc;\n\t\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t \n\t \n\taddr = CUDBG_CHAC_PBT_ADDR + (1 << 6);\n\tfor (i = 0; i < CUDBG_PBT_STATIC_ENTRIES; i++) {\n\t\trc = t4_cim_read(padap, addr + (i * 4), 1,\n\t\t\t\t &pbt->pbt_static[i]);\n\t\tif (rc) {\n\t\t\tcudbg_err->sys_err = rc;\n\t\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t \n\taddr = CUDBG_CHAC_PBT_LRF;\n\tfor (i = 0; i < CUDBG_LRF_ENTRIES; i++) {\n\t\trc = t4_cim_read(padap, addr + (i * 4), 1,\n\t\t\t\t &pbt->lrf_table[i]);\n\t\tif (rc) {\n\t\t\tcudbg_err->sys_err = rc;\n\t\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t \n\taddr = CUDBG_CHAC_PBT_DATA;\n\tfor (i = 0; i < CUDBG_PBT_DATA_ENTRIES; i++) {\n\t\trc = t4_cim_read(padap, addr + (i * 4), 1,\n\t\t\t\t &pbt->pbt_data[i]);\n\t\tif (rc) {\n\t\t\tcudbg_err->sys_err = rc;\n\t\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_mbox_log(struct cudbg_init *pdbg_init,\n\t\t\t   struct cudbg_buffer *dbg_buff,\n\t\t\t   struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_mbox_log *mboxlog = NULL;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct mbox_cmd_log *log = NULL;\n\tstruct mbox_cmd *entry;\n\tunsigned int entry_idx;\n\tu16 mbox_cmds;\n\tint i, k, rc;\n\tu64 flit;\n\tu32 size;\n\n\tlog = padap->mbox_log;\n\tmbox_cmds = padap->mbox_log->size;\n\tsize = sizeof(struct cudbg_mbox_log) * mbox_cmds;\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\tmboxlog = (struct cudbg_mbox_log *)temp_buff.data;\n\tfor (k = 0; k < mbox_cmds; k++) {\n\t\tentry_idx = log->cursor + k;\n\t\tif (entry_idx >= log->size)\n\t\t\tentry_idx -= log->size;\n\n\t\tentry = mbox_cmd_log_entry(log, entry_idx);\n\t\t \n\t\tif (entry->timestamp == 0)\n\t\t\tcontinue;\n\n\t\tmemcpy(&mboxlog->entry, entry, sizeof(struct mbox_cmd));\n\t\tfor (i = 0; i < MBOX_LEN / 8; i++) {\n\t\t\tflit = entry->cmd[i];\n\t\t\tmboxlog->hi[i] = (u32)(flit >> 32);\n\t\t\tmboxlog->lo[i] = (u32)flit;\n\t\t}\n\t\tmboxlog++;\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nint cudbg_collect_hma_indirect(struct cudbg_init *pdbg_init,\n\t\t\t       struct cudbg_buffer *dbg_buff,\n\t\t\t       struct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct ireg_buf *hma_indr;\n\tint i, rc, n;\n\tu32 size;\n\n\tif (CHELSIO_CHIP_VERSION(padap->params.chip) < CHELSIO_T6)\n\t\treturn CUDBG_STATUS_ENTITY_NOT_FOUND;\n\n\tn = sizeof(t6_hma_ireg_array) / (IREG_NUM_ELEM * sizeof(u32));\n\tsize = sizeof(struct ireg_buf) * n;\n\trc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);\n\tif (rc)\n\t\treturn rc;\n\n\thma_indr = (struct ireg_buf *)temp_buff.data;\n\tfor (i = 0; i < n; i++) {\n\t\tstruct ireg_field *hma_fli = &hma_indr->tp_pio;\n\t\tu32 *buff = hma_indr->outbuf;\n\n\t\thma_fli->ireg_addr = t6_hma_ireg_array[i][0];\n\t\thma_fli->ireg_data = t6_hma_ireg_array[i][1];\n\t\thma_fli->ireg_local_offset = t6_hma_ireg_array[i][2];\n\t\thma_fli->ireg_offset_range = t6_hma_ireg_array[i][3];\n\t\tt4_read_indirect(padap, hma_fli->ireg_addr, hma_fli->ireg_data,\n\t\t\t\t buff, hma_fli->ireg_offset_range,\n\t\t\t\t hma_fli->ireg_local_offset);\n\t\thma_indr++;\n\t}\n\treturn cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);\n}\n\nvoid cudbg_fill_qdesc_num_and_size(const struct adapter *padap,\n\t\t\t\t   u32 *num, u32 *size)\n{\n\tu32 tot_entries = 0, tot_size = 0;\n\n\t \n\ttot_entries += MAX_ETH_QSETS * 3;\n\ttot_entries += MAX_CTRL_QUEUES;\n\n\ttot_size += MAX_ETH_QSETS * MAX_TXQ_ENTRIES * MAX_TXQ_DESC_SIZE;\n\ttot_size += MAX_ETH_QSETS * MAX_RSPQ_ENTRIES * MAX_RXQ_DESC_SIZE;\n\ttot_size += MAX_ETH_QSETS * MAX_RX_BUFFERS * MAX_FL_DESC_SIZE;\n\ttot_size += MAX_CTRL_QUEUES * MAX_CTRL_TXQ_ENTRIES *\n\t\t    MAX_CTRL_TXQ_DESC_SIZE;\n\n\t \n\ttot_entries += INGQ_EXTRAS;\n\ttot_size += INGQ_EXTRAS * MAX_RSPQ_ENTRIES * MAX_RXQ_DESC_SIZE;\n\n\t \n\ttot_entries += 1;\n\ttot_size += MAX_TXQ_ENTRIES * MAX_TXQ_DESC_SIZE;\n\n\t \n\ttot_entries += CXGB4_TX_MAX * MAX_OFLD_QSETS;\n\ttot_entries += CXGB4_ULD_MAX * MAX_ULD_QSETS * 2;\n\n\ttot_size += CXGB4_TX_MAX * MAX_OFLD_QSETS * MAX_TXQ_ENTRIES *\n\t\t    MAX_TXQ_DESC_SIZE;\n\ttot_size += CXGB4_ULD_MAX * MAX_ULD_QSETS * MAX_RSPQ_ENTRIES *\n\t\t    MAX_RXQ_DESC_SIZE;\n\ttot_size += CXGB4_ULD_MAX * MAX_ULD_QSETS * MAX_RX_BUFFERS *\n\t\t    MAX_FL_DESC_SIZE;\n\n\t \n\ttot_entries += CXGB4_ULD_MAX * MAX_ULD_QSETS;\n\ttot_size += CXGB4_ULD_MAX * MAX_ULD_QSETS * SGE_MAX_IQ_SIZE *\n\t\t    MAX_RXQ_DESC_SIZE;\n\n\t \n\ttot_entries += MAX_OFLD_QSETS * 3;\n\ttot_size += MAX_OFLD_QSETS * MAX_TXQ_ENTRIES * MAX_TXQ_DESC_SIZE;\n\n\ttot_size += sizeof(struct cudbg_ver_hdr) +\n\t\t    sizeof(struct cudbg_qdesc_info) +\n\t\t    sizeof(struct cudbg_qdesc_entry) * tot_entries;\n\n\tif (num)\n\t\t*num = tot_entries;\n\n\tif (size)\n\t\t*size = tot_size;\n}\n\nint cudbg_collect_qdesc(struct cudbg_init *pdbg_init,\n\t\t\tstruct cudbg_buffer *dbg_buff,\n\t\t\tstruct cudbg_error *cudbg_err)\n{\n\tu32 num_queues = 0, tot_entries = 0, size = 0;\n\tstruct adapter *padap = pdbg_init->adap;\n\tstruct cudbg_buffer temp_buff = { 0 };\n\tstruct cudbg_qdesc_entry *qdesc_entry;\n\tstruct cudbg_qdesc_info *qdesc_info;\n\tstruct cudbg_ver_hdr *ver_hdr;\n\tstruct sge *s = &padap->sge;\n\tu32 i, j, cur_off, tot_len;\n\tu8 *data;\n\tint rc;\n\n\tcudbg_fill_qdesc_num_and_size(padap, &tot_entries, &size);\n\tsize = min_t(u32, size, CUDBG_DUMP_BUFF_SIZE);\n\ttot_len = size;\n\tdata = kvzalloc(size, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tver_hdr = (struct cudbg_ver_hdr *)data;\n\tver_hdr->signature = CUDBG_ENTITY_SIGNATURE;\n\tver_hdr->revision = CUDBG_QDESC_REV;\n\tver_hdr->size = sizeof(struct cudbg_qdesc_info);\n\tsize -= sizeof(*ver_hdr);\n\n\tqdesc_info = (struct cudbg_qdesc_info *)(data +\n\t\t\t\t\t\t sizeof(*ver_hdr));\n\tsize -= sizeof(*qdesc_info);\n\tqdesc_entry = (struct cudbg_qdesc_entry *)qdesc_info->data;\n\n#define QDESC_GET(q, desc, type, label) do { \\\n\tif (size <= 0) { \\\n\t\tgoto label; \\\n\t} \\\n\tif (desc) { \\\n\t\tcudbg_fill_qdesc_##q(q, type, qdesc_entry); \\\n\t\tsize -= sizeof(*qdesc_entry) + qdesc_entry->data_size; \\\n\t\tnum_queues++; \\\n\t\tqdesc_entry = cudbg_next_qdesc(qdesc_entry); \\\n\t} \\\n} while (0)\n\n#define QDESC_GET_TXQ(q, type, label) do { \\\n\tstruct sge_txq *txq = (struct sge_txq *)q; \\\n\tQDESC_GET(txq, txq->desc, type, label); \\\n} while (0)\n\n#define QDESC_GET_RXQ(q, type, label) do { \\\n\tstruct sge_rspq *rxq = (struct sge_rspq *)q; \\\n\tQDESC_GET(rxq, rxq->desc, type, label); \\\n} while (0)\n\n#define QDESC_GET_FLQ(q, type, label) do { \\\n\tstruct sge_fl *flq = (struct sge_fl *)q; \\\n\tQDESC_GET(flq, flq->desc, type, label); \\\n} while (0)\n\n\t \n\tfor (i = 0; i < s->ethqsets; i++)\n\t\tQDESC_GET_TXQ(&s->ethtxq[i].q, CUDBG_QTYPE_NIC_TXQ, out);\n\n\t \n\tfor (i = 0; i < s->ethqsets; i++)\n\t\tQDESC_GET_RXQ(&s->ethrxq[i].rspq, CUDBG_QTYPE_NIC_RXQ, out);\n\n\t \n\tfor (i = 0; i < s->ethqsets; i++)\n\t\tQDESC_GET_FLQ(&s->ethrxq[i].fl, CUDBG_QTYPE_NIC_FLQ, out);\n\n\t \n\tfor (i = 0; i < padap->params.nports; i++)\n\t\tQDESC_GET_TXQ(&s->ctrlq[i].q, CUDBG_QTYPE_CTRLQ, out);\n\n\t \n\tQDESC_GET_RXQ(&s->fw_evtq, CUDBG_QTYPE_FWEVTQ, out);\n\n\t \n\tQDESC_GET_RXQ(&s->intrq, CUDBG_QTYPE_INTRQ, out);\n\n\t \n\tQDESC_GET_TXQ(&s->ptptxq.q, CUDBG_QTYPE_PTP_TXQ, out);\n\n\t \n\tmutex_lock(&uld_mutex);\n\n\tif (s->uld_txq_info) {\n\t\tstruct sge_uld_txq_info *utxq;\n\n\t\t \n\t\tfor (j = 0; j < CXGB4_TX_MAX; j++) {\n\t\t\tif (!s->uld_txq_info[j])\n\t\t\t\tcontinue;\n\n\t\t\tutxq = s->uld_txq_info[j];\n\t\t\tfor (i = 0; i < utxq->ntxq; i++)\n\t\t\t\tQDESC_GET_TXQ(&utxq->uldtxq[i].q,\n\t\t\t\t\t      cudbg_uld_txq_to_qtype(j),\n\t\t\t\t\t      out_unlock_uld);\n\t\t}\n\t}\n\n\tif (s->uld_rxq_info) {\n\t\tstruct sge_uld_rxq_info *urxq;\n\t\tu32 base;\n\n\t\t \n\t\tfor (j = 0; j < CXGB4_ULD_MAX; j++) {\n\t\t\tif (!s->uld_rxq_info[j])\n\t\t\t\tcontinue;\n\n\t\t\turxq = s->uld_rxq_info[j];\n\t\t\tfor (i = 0; i < urxq->nrxq; i++)\n\t\t\t\tQDESC_GET_RXQ(&urxq->uldrxq[i].rspq,\n\t\t\t\t\t      cudbg_uld_rxq_to_qtype(j),\n\t\t\t\t\t      out_unlock_uld);\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < CXGB4_ULD_MAX; j++) {\n\t\t\tif (!s->uld_rxq_info[j])\n\t\t\t\tcontinue;\n\n\t\t\turxq = s->uld_rxq_info[j];\n\t\t\tfor (i = 0; i < urxq->nrxq; i++)\n\t\t\t\tQDESC_GET_FLQ(&urxq->uldrxq[i].fl,\n\t\t\t\t\t      cudbg_uld_flq_to_qtype(j),\n\t\t\t\t\t      out_unlock_uld);\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < CXGB4_ULD_MAX; j++) {\n\t\t\tif (!s->uld_rxq_info[j])\n\t\t\t\tcontinue;\n\n\t\t\turxq = s->uld_rxq_info[j];\n\t\t\tbase = urxq->nrxq;\n\t\t\tfor (i = 0; i < urxq->nciq; i++)\n\t\t\t\tQDESC_GET_RXQ(&urxq->uldrxq[base + i].rspq,\n\t\t\t\t\t      cudbg_uld_ciq_to_qtype(j),\n\t\t\t\t\t      out_unlock_uld);\n\t\t}\n\t}\n\tmutex_unlock(&uld_mutex);\n\n\tif (!padap->tc_mqprio)\n\t\tgoto out;\n\n\tmutex_lock(&padap->tc_mqprio->mqprio_mutex);\n\t \n\tif (s->eohw_txq)\n\t\tfor (i = 0; i < s->eoqsets; i++)\n\t\t\tQDESC_GET_TXQ(&s->eohw_txq[i].q,\n\t\t\t\t      CUDBG_QTYPE_ETHOFLD_TXQ, out_unlock_mqprio);\n\n\t \n\tif (s->eohw_rxq) {\n\t\tfor (i = 0; i < s->eoqsets; i++)\n\t\t\tQDESC_GET_RXQ(&s->eohw_rxq[i].rspq,\n\t\t\t\t      CUDBG_QTYPE_ETHOFLD_RXQ, out_unlock_mqprio);\n\n\t\tfor (i = 0; i < s->eoqsets; i++)\n\t\t\tQDESC_GET_FLQ(&s->eohw_rxq[i].fl,\n\t\t\t\t      CUDBG_QTYPE_ETHOFLD_FLQ, out_unlock_mqprio);\n\t}\n\nout_unlock_mqprio:\n\tmutex_unlock(&padap->tc_mqprio->mqprio_mutex);\n\nout:\n\tqdesc_info->qdesc_entry_size = sizeof(*qdesc_entry);\n\tqdesc_info->num_queues = num_queues;\n\tcur_off = 0;\n\twhile (tot_len) {\n\t\tu32 chunk_size = min_t(u32, tot_len, CUDBG_CHUNK_SIZE);\n\n\t\trc = cudbg_get_buff(pdbg_init, dbg_buff, chunk_size,\n\t\t\t\t    &temp_buff);\n\t\tif (rc) {\n\t\t\tcudbg_err->sys_warn = CUDBG_STATUS_PARTIAL_DATA;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tmemcpy(temp_buff.data, data + cur_off, chunk_size);\n\t\ttot_len -= chunk_size;\n\t\tcur_off += chunk_size;\n\t\trc = cudbg_write_and_release_buff(pdbg_init, &temp_buff,\n\t\t\t\t\t\t  dbg_buff);\n\t\tif (rc) {\n\t\t\tcudbg_put_buff(pdbg_init, &temp_buff);\n\t\t\tcudbg_err->sys_warn = CUDBG_STATUS_PARTIAL_DATA;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\nout_free:\n\tkvfree(data);\n\n#undef QDESC_GET_FLQ\n#undef QDESC_GET_RXQ\n#undef QDESC_GET_TXQ\n#undef QDESC_GET\n\n\treturn rc;\n\nout_unlock_uld:\n\tmutex_unlock(&uld_mutex);\n\tgoto out;\n}\n\nint cudbg_collect_flash(struct cudbg_init *pdbg_init,\n\t\t\tstruct cudbg_buffer *dbg_buff,\n\t\t\tstruct cudbg_error *cudbg_err)\n{\n\tstruct adapter *padap = pdbg_init->adap;\n\tu32 count = padap->params.sf_size, n;\n\tstruct cudbg_buffer temp_buff = {0};\n\tu32 addr, i;\n\tint rc;\n\n\taddr = FLASH_EXP_ROM_START;\n\n\tfor (i = 0; i < count; i += SF_PAGE_SIZE) {\n\t\tn = min_t(u32, count - i, SF_PAGE_SIZE);\n\n\t\trc = cudbg_get_buff(pdbg_init, dbg_buff, n, &temp_buff);\n\t\tif (rc) {\n\t\t\tcudbg_err->sys_warn = CUDBG_STATUS_PARTIAL_DATA;\n\t\t\tgoto out;\n\t\t}\n\t\trc = t4_read_flash(padap, addr, n, (u32 *)temp_buff.data, 0);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\taddr += (n * 4);\n\t\trc = cudbg_write_and_release_buff(pdbg_init, &temp_buff,\n\t\t\t\t\t\t  dbg_buff);\n\t\tif (rc) {\n\t\t\tcudbg_err->sys_warn = CUDBG_STATUS_PARTIAL_DATA;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}