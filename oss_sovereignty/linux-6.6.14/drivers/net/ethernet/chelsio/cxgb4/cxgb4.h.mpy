{
  "module_name": "cxgb4.h",
  "hash_id": "a1921a15a0e47b3798b896ddbedee46754474e8e5cb818298a962bc50d09190a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h",
  "human_readable_source": " \n\n#ifndef __CXGB4_H__\n#define __CXGB4_H__\n\n#include \"t4_hw.h\"\n\n#include <linux/bitops.h>\n#include <linux/cache.h>\n#include <linux/ethtool.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/vmalloc.h>\n#include <linux/rhashtable.h>\n#include <linux/etherdevice.h>\n#include <linux/net_tstamp.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/ptp_classify.h>\n#include <linux/crash_dump.h>\n#include <linux/thermal.h>\n#include <asm/io.h>\n#include \"t4_chip_type.h\"\n#include \"cxgb4_uld.h\"\n#include \"t4fw_api.h\"\n\n#define CH_WARN(adap, fmt, ...) dev_warn(adap->pdev_dev, fmt, ## __VA_ARGS__)\nextern struct list_head adapter_list;\nextern struct list_head uld_list;\nextern struct mutex uld_mutex;\n\n \n#define ETHTXQ_STOP_THRES \\\n\t(1 + DIV_ROUND_UP((3 * MAX_SKB_FRAGS) / 2 + (MAX_SKB_FRAGS & 1), 8))\n\n#define FW_PARAM_DEV(param) \\\n\t(FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) | \\\n\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_##param))\n\n#define FW_PARAM_PFVF(param) \\\n\t(FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_PFVF) | \\\n\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_PFVF_##param) |  \\\n\t FW_PARAMS_PARAM_Y_V(0) | \\\n\t FW_PARAMS_PARAM_Z_V(0))\n\nenum {\n\tMAX_NPORTS\t= 4,      \n\tSERNUM_LEN\t= 24,     \n\tID_LEN\t\t= 16,     \n\tPN_LEN\t\t= 16,     \n\tMACADDR_LEN\t= 12,     \n};\n\nenum {\n\tT4_REGMAP_SIZE = (160 * 1024),\n\tT5_REGMAP_SIZE = (332 * 1024),\n};\n\nenum {\n\tMEM_EDC0,\n\tMEM_EDC1,\n\tMEM_MC,\n\tMEM_MC0 = MEM_MC,\n\tMEM_MC1,\n\tMEM_HMA,\n};\n\nenum {\n\tMEMWIN0_APERTURE = 2048,\n\tMEMWIN0_BASE     = 0x1b800,\n\tMEMWIN1_APERTURE = 32768,\n\tMEMWIN1_BASE     = 0x28000,\n\tMEMWIN1_BASE_T5  = 0x52000,\n\tMEMWIN2_APERTURE = 65536,\n\tMEMWIN2_BASE     = 0x30000,\n\tMEMWIN2_APERTURE_T5 = 131072,\n\tMEMWIN2_BASE_T5  = 0x60000,\n};\n\nenum dev_master {\n\tMASTER_CANT,\n\tMASTER_MAY,\n\tMASTER_MUST\n};\n\nenum dev_state {\n\tDEV_STATE_UNINIT,\n\tDEV_STATE_INIT,\n\tDEV_STATE_ERR\n};\n\nenum cc_pause {\n\tPAUSE_RX      = 1 << 0,\n\tPAUSE_TX      = 1 << 1,\n\tPAUSE_AUTONEG = 1 << 2\n};\n\nenum cc_fec {\n\tFEC_AUTO      = 1 << 0,\t  \n\tFEC_RS        = 1 << 1,   \n\tFEC_BASER_RS  = 1 << 2    \n};\n\nenum {\n\tCXGB4_ETHTOOL_FLASH_FW = 1,\n\tCXGB4_ETHTOOL_FLASH_PHY = 2,\n\tCXGB4_ETHTOOL_FLASH_BOOT = 3,\n\tCXGB4_ETHTOOL_FLASH_BOOTCFG = 4\n};\n\nenum cxgb4_netdev_tls_ops {\n\tCXGB4_TLSDEV_OPS  = 1,\n\tCXGB4_XFRMDEV_OPS\n};\n\nstruct cxgb4_bootcfg_data {\n\t__le16 signature;\n\t__u8 reserved[2];\n};\n\nstruct cxgb4_pcir_data {\n\t__le32 signature;\t \n\t__le16 vendor_id;\t \n\t__le16 device_id;\t \n\t__u8 vital_product[2];\t \n\t__u8 length[2];\t\t \n\t__u8 revision;\t\t \n\t__u8 class_code[3];\t \n\t__u8 image_length[2];\t \n\t__u8 code_revision[2];\t \n\t__u8 code_type;\n\t__u8 indicator;\n\t__u8 reserved[2];\n};\n\n \nstruct cxgb4_pci_exp_rom_header {\n\t__le16 signature;\t \n\t__u8 reserved[22];\t \n\t__le16 pcir_offset;\t \n};\n\n \nstruct legacy_pci_rom_hdr {\n\t__u8 signature[2];\t \n\t__u8 size512;\t\t \n\t__u8 initentry_point[4];\n\t__u8 cksum;\t\t \n\t__u8 reserved[16];\t \n\t__le16 pcir_offset;\t \n};\n\n#define CXGB4_HDR_CODE1 0x00\n#define CXGB4_HDR_CODE2 0x03\n#define CXGB4_HDR_INDI 0x80\n\n \nenum {\n\tBOOT_CFG_SIG = 0x4243,\n\tBOOT_SIZE_INC = 512,\n\tBOOT_SIGNATURE = 0xaa55,\n\tBOOT_MIN_SIZE = sizeof(struct cxgb4_pci_exp_rom_header),\n\tBOOT_MAX_SIZE = 1024 * BOOT_SIZE_INC,\n\tPCIR_SIGNATURE = 0x52494350\n};\n\nstruct port_stats {\n\tu64 tx_octets;             \n\tu64 tx_frames;             \n\tu64 tx_bcast_frames;       \n\tu64 tx_mcast_frames;       \n\tu64 tx_ucast_frames;       \n\tu64 tx_error_frames;       \n\n\tu64 tx_frames_64;          \n\tu64 tx_frames_65_127;\n\tu64 tx_frames_128_255;\n\tu64 tx_frames_256_511;\n\tu64 tx_frames_512_1023;\n\tu64 tx_frames_1024_1518;\n\tu64 tx_frames_1519_max;\n\n\tu64 tx_drop;               \n\tu64 tx_pause;              \n\tu64 tx_ppp0;               \n\tu64 tx_ppp1;               \n\tu64 tx_ppp2;               \n\tu64 tx_ppp3;               \n\tu64 tx_ppp4;               \n\tu64 tx_ppp5;               \n\tu64 tx_ppp6;               \n\tu64 tx_ppp7;               \n\n\tu64 rx_octets;             \n\tu64 rx_frames;             \n\tu64 rx_bcast_frames;       \n\tu64 rx_mcast_frames;       \n\tu64 rx_ucast_frames;       \n\tu64 rx_too_long;           \n\tu64 rx_jabber;             \n\tu64 rx_fcs_err;            \n\tu64 rx_len_err;            \n\tu64 rx_symbol_err;         \n\tu64 rx_runt;               \n\n\tu64 rx_frames_64;          \n\tu64 rx_frames_65_127;\n\tu64 rx_frames_128_255;\n\tu64 rx_frames_256_511;\n\tu64 rx_frames_512_1023;\n\tu64 rx_frames_1024_1518;\n\tu64 rx_frames_1519_max;\n\n\tu64 rx_pause;              \n\tu64 rx_ppp0;               \n\tu64 rx_ppp1;               \n\tu64 rx_ppp2;               \n\tu64 rx_ppp3;               \n\tu64 rx_ppp4;               \n\tu64 rx_ppp5;               \n\tu64 rx_ppp6;               \n\tu64 rx_ppp7;               \n\n\tu64 rx_ovflow0;            \n\tu64 rx_ovflow1;            \n\tu64 rx_ovflow2;            \n\tu64 rx_ovflow3;            \n\tu64 rx_trunc0;             \n\tu64 rx_trunc1;             \n\tu64 rx_trunc2;             \n\tu64 rx_trunc3;             \n};\n\nstruct lb_port_stats {\n\tu64 octets;\n\tu64 frames;\n\tu64 bcast_frames;\n\tu64 mcast_frames;\n\tu64 ucast_frames;\n\tu64 error_frames;\n\n\tu64 frames_64;\n\tu64 frames_65_127;\n\tu64 frames_128_255;\n\tu64 frames_256_511;\n\tu64 frames_512_1023;\n\tu64 frames_1024_1518;\n\tu64 frames_1519_max;\n\n\tu64 drop;\n\n\tu64 ovflow0;\n\tu64 ovflow1;\n\tu64 ovflow2;\n\tu64 ovflow3;\n\tu64 trunc0;\n\tu64 trunc1;\n\tu64 trunc2;\n\tu64 trunc3;\n};\n\nstruct tp_tcp_stats {\n\tu32 tcp_out_rsts;\n\tu64 tcp_in_segs;\n\tu64 tcp_out_segs;\n\tu64 tcp_retrans_segs;\n};\n\nstruct tp_usm_stats {\n\tu32 frames;\n\tu32 drops;\n\tu64 octets;\n};\n\nstruct tp_fcoe_stats {\n\tu32 frames_ddp;\n\tu32 frames_drop;\n\tu64 octets_ddp;\n};\n\nstruct tp_err_stats {\n\tu32 mac_in_errs[4];\n\tu32 hdr_in_errs[4];\n\tu32 tcp_in_errs[4];\n\tu32 tnl_cong_drops[4];\n\tu32 ofld_chan_drops[4];\n\tu32 tnl_tx_drops[4];\n\tu32 ofld_vlan_drops[4];\n\tu32 tcp6_in_errs[4];\n\tu32 ofld_no_neigh;\n\tu32 ofld_cong_defer;\n};\n\nstruct tp_cpl_stats {\n\tu32 req[4];\n\tu32 rsp[4];\n};\n\nstruct tp_rdma_stats {\n\tu32 rqe_dfr_pkt;\n\tu32 rqe_dfr_mod;\n};\n\nstruct sge_params {\n\tu32 hps;\t\t\t \n\tu32 eq_qpp;\t\t\t \n\tu32 iq_qpp;\t\t\t \n};\n\nstruct tp_params {\n\tunsigned int tre;             \n\tunsigned int la_mask;         \n\tunsigned short tx_modq_map;   \n\t\t\t\t      \n\n\tuint32_t dack_re;             \n\tunsigned short tx_modq[NCHAN];\t \n\n\tu32 vlan_pri_map;                \n\tu32 filter_mask;\n\tu32 ingress_config;              \n\n\t \n\tint rx_pkt_encap;\n\n\t \n\tint fcoe_shift;\n\tint port_shift;\n\tint vnic_shift;\n\tint vlan_shift;\n\tint tos_shift;\n\tint protocol_shift;\n\tint ethertype_shift;\n\tint macmatch_shift;\n\tint matchtype_shift;\n\tint frag_shift;\n\n\tu64 hash_filter_mask;\n};\n\nstruct vpd_params {\n\tunsigned int cclk;\n\tu8 sn[SERNUM_LEN + 1];\n\tu8 id[ID_LEN + 1];\n\tu8 pn[PN_LEN + 1];\n\tu8 na[MACADDR_LEN + 1];\n};\n\n \nstruct pf_resources {\n\tunsigned int nvi;\t\t \n\tunsigned int neq;\t\t \n\tunsigned int nethctrl;\t\t \n\tunsigned int niqflint;\t\t \n\tunsigned int niq;\t\t \n\tunsigned int tc;\t\t \n\tunsigned int pmask;\t\t \n\tunsigned int nexactf;\t\t \n\tunsigned int r_caps;\t\t \n\tunsigned int wx_caps;\t\t \n};\n\nstruct pci_params {\n\tunsigned char speed;\n\tunsigned char width;\n};\n\nstruct devlog_params {\n\tu32 memtype;                     \n\tu32 start;                       \n\tu32 size;                        \n};\n\n \nstruct arch_specific_params {\n\tu8 nchan;\n\tu8 pm_stats_cnt;\n\tu8 cng_ch_bits_log;\t\t \n\tu16 mps_rplc_size;\n\tu16 vfcount;\n\tu32 sge_fl_db;\n\tu16 mps_tcam_size;\n};\n\nstruct adapter_params {\n\tstruct sge_params sge;\n\tstruct tp_params  tp;\n\tstruct vpd_params vpd;\n\tstruct pf_resources pfres;\n\tstruct pci_params pci;\n\tstruct devlog_params devlog;\n\tenum pcie_memwin drv_memwin;\n\n\tunsigned int cim_la_size;\n\n\tunsigned int sf_size;              \n\tunsigned int sf_nsec;              \n\n\tunsigned int fw_vers;\t\t   \n\tunsigned int bs_vers;\t\t   \n\tunsigned int tp_vers;\t\t   \n\tunsigned int er_vers;\t\t   \n\tunsigned int scfg_vers;\t\t   \n\tunsigned int vpd_vers;\t\t   \n\tu8 api_vers[7];\n\n\tunsigned short mtus[NMTUS];\n\tunsigned short a_wnd[NCCTRL_WIN];\n\tunsigned short b_wnd[NCCTRL_WIN];\n\n\tunsigned char nports;              \n\tunsigned char portvec;\n\tenum chip_type chip;                \n\tstruct arch_specific_params arch;   \n\tunsigned char offload;\n\tunsigned char crypto;\t\t \n\tunsigned char ethofld;\t\t \n\n\tunsigned char bypass;\n\tunsigned char hash_filter;\n\n\tunsigned int ofldq_wr_cred;\n\tbool ulptx_memwrite_dsgl;           \n\n\tunsigned int nsched_cls;           \n\tunsigned int max_ordird_qp;        \n\tunsigned int max_ird_adapter;      \n\tbool fr_nsmr_tpte_wr_support;\t   \n\tu8 fw_caps_support;\t\t \n\tbool filter2_wr_support;\t \n\tunsigned int viid_smt_extn_support:1;  \n\n\t \n\tu8 mps_bg_map[MAX_NPORTS];\t \n\tbool write_w_imm_support;        \n\tbool write_cmpl_support;         \n};\n\n \nstruct sge_idma_monitor_state {\n\tunsigned int idma_1s_thresh;\t \n\tunsigned int idma_stalled[2];\t \n\tunsigned int idma_state[2];\t \n\tunsigned int idma_qid[2];\t \n\tunsigned int idma_warn[2];\t \n};\n\n \nstruct mbox_cmd {\n\tu64 cmd[MBOX_LEN / 8];\t\t \n\tu64 timestamp;\t\t\t \n\tu32 seqno;\t\t\t \n\ts16 access;\t\t\t \n\ts16 execute;\t\t\t \n};\n\nstruct mbox_cmd_log {\n\tunsigned int size;\t\t \n\tunsigned int cursor;\t\t \n\tu32 seqno;\t\t\t \n\t \n};\n\n \nstatic inline struct mbox_cmd *mbox_cmd_log_entry(struct mbox_cmd_log *log,\n\t\t\t\t\t\t  unsigned int entry_idx)\n{\n\treturn &((struct mbox_cmd *)&(log)[1])[entry_idx];\n}\n\n#define FW_VERSION(chip) ( \\\n\t\tFW_HDR_FW_VER_MAJOR_G(chip##FW_VERSION_MAJOR) | \\\n\t\tFW_HDR_FW_VER_MINOR_G(chip##FW_VERSION_MINOR) | \\\n\t\tFW_HDR_FW_VER_MICRO_G(chip##FW_VERSION_MICRO) | \\\n\t\tFW_HDR_FW_VER_BUILD_G(chip##FW_VERSION_BUILD))\n#define FW_INTFVER(chip, intf) (FW_HDR_INTFVER_##intf)\n\nstruct cxgb4_ethtool_lb_test {\n\tstruct completion completion;\n\tint result;\n\tint loopback;\n};\n\nstruct fw_info {\n\tu8 chip;\n\tchar *fs_name;\n\tchar *fw_mod_name;\n\tstruct fw_hdr fw_hdr;\n};\n\nstruct trace_params {\n\tu32 data[TRACE_LEN / 4];\n\tu32 mask[TRACE_LEN / 4];\n\tunsigned short snap_len;\n\tunsigned short min_len;\n\tunsigned char skip_ofst;\n\tunsigned char skip_len;\n\tunsigned char invert;\n\tunsigned char port;\n};\n\nstruct cxgb4_fw_data {\n\t__be32 signature;\n\t__u8 reserved[4];\n};\n\n \n\ntypedef u16 fw_port_cap16_t;\t \ntypedef u32 fw_port_cap32_t;\t \n\nenum fw_caps {\n\tFW_CAPS_UNKNOWN\t= 0,\t \n\tFW_CAPS16\t= 1,\t \n\tFW_CAPS32\t= 2,\t \n};\n\nstruct link_config {\n\tfw_port_cap32_t pcaps;            \n\tfw_port_cap32_t def_acaps;        \n\tfw_port_cap32_t acaps;            \n\tfw_port_cap32_t lpacaps;          \n\n\tfw_port_cap32_t speed_caps;       \n\tunsigned int   speed;             \n\n\tenum cc_pause  requested_fc;      \n\tenum cc_pause  fc;                \n\tenum cc_pause  advertised_fc;     \n\n\tenum cc_fec    requested_fec;\t  \n\tenum cc_fec    fec;\t\t  \n\n\tunsigned char  autoneg;           \n\n\tunsigned char  link_ok;           \n\tunsigned char  link_down_rc;      \n\n\tbool new_module;\t\t  \n\tbool redo_l1cfg;\t\t  \n};\n\n#define FW_LEN16(fw_struct) FW_CMD_LEN16_V(sizeof(fw_struct) / 16)\n\nenum {\n\tMAX_ETH_QSETS = 32,            \n\tMAX_OFLD_QSETS = 16,           \n\tMAX_CTRL_QUEUES = NCHAN,       \n};\n\nenum {\n\tMAX_TXQ_ENTRIES      = 16384,\n\tMAX_CTRL_TXQ_ENTRIES = 1024,\n\tMAX_RSPQ_ENTRIES     = 16384,\n\tMAX_RX_BUFFERS       = 16384,\n\tMIN_TXQ_ENTRIES      = 32,\n\tMIN_CTRL_TXQ_ENTRIES = 32,\n\tMIN_RSPQ_ENTRIES     = 128,\n\tMIN_FL_ENTRIES       = 16\n};\n\nenum {\n\tMAX_TXQ_DESC_SIZE      = 64,\n\tMAX_RXQ_DESC_SIZE      = 128,\n\tMAX_FL_DESC_SIZE       = 8,\n\tMAX_CTRL_TXQ_DESC_SIZE = 64,\n};\n\nenum {\n\tINGQ_EXTRAS = 2,         \n\t\t\t\t \n\tMAX_INGQ = MAX_ETH_QSETS + INGQ_EXTRAS,\n};\n\nenum {\n\tPRIV_FLAG_PORT_TX_VM_BIT,\n};\n\n#define PRIV_FLAG_PORT_TX_VM\t\tBIT(PRIV_FLAG_PORT_TX_VM_BIT)\n\n#define PRIV_FLAGS_ADAP\t\t\t0\n#define PRIV_FLAGS_PORT\t\t\tPRIV_FLAG_PORT_TX_VM\n\nstruct adapter;\nstruct sge_rspq;\n\n#include \"cxgb4_dcb.h\"\n\n#ifdef CONFIG_CHELSIO_T4_FCOE\n#include \"cxgb4_fcoe.h\"\n#endif  \n\nstruct port_info {\n\tstruct adapter *adapter;\n\tu16    viid;\n\tint    xact_addr_filt;         \n\tu16    rss_size;               \n\ts8     mdio_addr;\n\tenum fw_port_type port_type;\n\tu8     mod_type;\n\tu8     port_id;\n\tu8     tx_chan;\n\tu8     lport;                  \n\tu8     nqsets;                 \n\tu8     first_qset;             \n\tu8     rss_mode;\n\tstruct link_config link_cfg;\n\tu16   *rss;\n\tstruct port_stats stats_base;\n#ifdef CONFIG_CHELSIO_T4_DCB\n\tstruct port_dcb_info dcb;      \n#endif\n#ifdef CONFIG_CHELSIO_T4_FCOE\n\tstruct cxgb_fcoe fcoe;\n#endif  \n\tbool rxtstamp;   \n\tstruct hwtstamp_config tstamp_config;\n\tbool ptp_enable;\n\tstruct sched_table *sched_tbl;\n\tu32 eth_flags;\n\n\t \n\tu8 vin;\n\tu8 vivld;\n\tu8 smt_idx;\n\tu8 rx_cchan;\n\n\tbool tc_block_shared;\n\n\t \n\tu16 viid_mirror;\n\tu16 nmirrorqsets;\n\tu32 vi_mirror_count;\n\tstruct mutex vi_mirror_mutex;  \n\tstruct cxgb4_ethtool_lb_test ethtool_lb;\n};\n\nstruct dentry;\nstruct work_struct;\n\nenum {                                  \n\tCXGB4_FULL_INIT_DONE\t\t= (1 << 0),\n\tCXGB4_DEV_ENABLED\t\t= (1 << 1),\n\tCXGB4_USING_MSI\t\t\t= (1 << 2),\n\tCXGB4_USING_MSIX\t\t= (1 << 3),\n\tCXGB4_FW_OK\t\t\t= (1 << 4),\n\tCXGB4_RSS_TNLALLLOOKUP\t\t= (1 << 5),\n\tCXGB4_USING_SOFT_PARAMS\t\t= (1 << 6),\n\tCXGB4_MASTER_PF\t\t\t= (1 << 7),\n\tCXGB4_FW_OFLD_CONN\t\t= (1 << 9),\n\tCXGB4_ROOT_NO_RELAXED_ORDERING\t= (1 << 10),\n\tCXGB4_SHUTTING_DOWN\t\t= (1 << 11),\n\tCXGB4_SGE_DBQ_TIMER\t\t= (1 << 12),\n};\n\nenum {\n\tULP_CRYPTO_LOOKASIDE = 1 << 0,\n\tULP_CRYPTO_IPSEC_INLINE = 1 << 1,\n\tULP_CRYPTO_KTLS_INLINE  = 1 << 3,\n};\n\n#define CXGB4_MIRROR_RXQ_DEFAULT_DESC_NUM 1024\n#define CXGB4_MIRROR_RXQ_DEFAULT_DESC_SIZE 64\n#define CXGB4_MIRROR_RXQ_DEFAULT_INTR_USEC 5\n#define CXGB4_MIRROR_RXQ_DEFAULT_PKT_CNT 8\n\n#define CXGB4_MIRROR_FLQ_DEFAULT_DESC_NUM 72\n\nstruct rx_sw_desc;\n\nstruct sge_fl {                      \n\tunsigned int avail;          \n\tunsigned int pend_cred;      \n\tunsigned int cidx;           \n\tunsigned int pidx;           \n\tunsigned long alloc_failed;  \n\tunsigned long large_alloc_failed;\n\tunsigned long mapping_err;   \n\tunsigned long low;           \n\tunsigned long starving;\n\t \n\tunsigned int cntxt_id;       \n\tunsigned int size;           \n\tstruct rx_sw_desc *sdesc;    \n\t__be64 *desc;                \n\tdma_addr_t addr;             \n\tvoid __iomem *bar2_addr;     \n\tunsigned int bar2_qid;       \n};\n\n \nstruct pkt_gl {\n\tu64 sgetstamp;\t\t     \n\tstruct page_frag frags[MAX_SKB_FRAGS];\n\tvoid *va;                          \n\tunsigned int nfrags;               \n\tunsigned int tot_len;              \n};\n\ntypedef int (*rspq_handler_t)(struct sge_rspq *q, const __be64 *rsp,\n\t\t\t      const struct pkt_gl *gl);\ntypedef void (*rspq_flush_handler_t)(struct sge_rspq *q);\n \nstruct t4_lro_mgr {\n#define MAX_LRO_SESSIONS\t\t64\n\tu8 lro_session_cnt;          \n\tunsigned long lro_pkts;      \n\tunsigned long lro_merged;    \n\tstruct sk_buff_head lroq;    \n};\n\nstruct sge_rspq {                    \n\tstruct napi_struct napi;\n\tconst __be64 *cur_desc;      \n\tunsigned int cidx;           \n\tu8 gen;                      \n\tu8 intr_params;              \n\tu8 next_intr_params;         \n\tu8 adaptive_rx;\n\tu8 pktcnt_idx;               \n\tu8 uld;                      \n\tu8 idx;                      \n\tint offset;                  \n\tu16 cntxt_id;                \n\tu16 abs_id;                  \n\t__be64 *desc;                \n\tdma_addr_t phys_addr;        \n\tvoid __iomem *bar2_addr;     \n\tunsigned int bar2_qid;       \n\tunsigned int iqe_len;        \n\tunsigned int size;           \n\tstruct adapter *adap;\n\tstruct net_device *netdev;   \n\trspq_handler_t handler;\n\trspq_flush_handler_t flush_handler;\n\tstruct t4_lro_mgr lro_mgr;\n};\n\nstruct sge_eth_stats {               \n\tunsigned long pkts;          \n\tunsigned long lro_pkts;      \n\tunsigned long lro_merged;    \n\tunsigned long rx_cso;        \n\tunsigned long vlan_ex;       \n\tunsigned long rx_drops;      \n\tunsigned long bad_rx_pkts;   \n};\n\nstruct sge_eth_rxq {                 \n\tstruct sge_rspq rspq;\n\tstruct sge_fl fl;\n\tstruct sge_eth_stats stats;\n\tstruct msix_info *msix;\n} ____cacheline_aligned_in_smp;\n\nstruct sge_ofld_stats {              \n\tunsigned long pkts;          \n\tunsigned long imm;           \n\tunsigned long an;            \n\tunsigned long nomem;         \n};\n\nstruct sge_ofld_rxq {                \n\tstruct sge_rspq rspq;\n\tstruct sge_fl fl;\n\tstruct sge_ofld_stats stats;\n\tstruct msix_info *msix;\n} ____cacheline_aligned_in_smp;\n\nstruct tx_desc {\n\t__be64 flit[8];\n};\n\nstruct ulptx_sgl;\n\nstruct tx_sw_desc {\n\tstruct sk_buff *skb;  \n\tdma_addr_t addr[MAX_SKB_FRAGS + 1];  \n};\n\nstruct sge_txq {\n\tunsigned int  in_use;        \n\tunsigned int  q_type;\t     \n\tunsigned int  size;          \n\tunsigned int  cidx;          \n\tunsigned int  pidx;          \n\tunsigned long stops;         \n\tunsigned long restarts;      \n\tunsigned int  cntxt_id;      \n\tstruct tx_desc *desc;        \n\tstruct tx_sw_desc *sdesc;    \n\tstruct sge_qstat *stat;      \n\tdma_addr_t    phys_addr;     \n\tspinlock_t db_lock;\n\tint db_disabled;\n\tunsigned short db_pidx;\n\tunsigned short db_pidx_inc;\n\tvoid __iomem *bar2_addr;     \n\tunsigned int bar2_qid;       \n};\n\nstruct sge_eth_txq {                 \n\tstruct sge_txq q;\n\tstruct netdev_queue *txq;    \n#ifdef CONFIG_CHELSIO_T4_DCB\n\tu8 dcb_prio;\t\t     \n#endif\n\tu8 dbqt;                     \n\tunsigned int dbqtimerix;     \n\tunsigned long tso;           \n\tunsigned long uso;           \n\tunsigned long tx_cso;        \n\tunsigned long vlan_ins;      \n\tunsigned long mapping_err;   \n} ____cacheline_aligned_in_smp;\n\nstruct sge_uld_txq {                \n\tstruct sge_txq q;\n\tstruct adapter *adap;\n\tstruct sk_buff_head sendq;   \n\tstruct tasklet_struct qresume_tsk;  \n\tbool service_ofldq_running;  \n\tu8 full;                     \n\tunsigned long mapping_err;   \n} ____cacheline_aligned_in_smp;\n\nstruct sge_ctrl_txq {                \n\tstruct sge_txq q;\n\tstruct adapter *adap;\n\tstruct sk_buff_head sendq;   \n\tstruct tasklet_struct qresume_tsk;  \n\tu8 full;                     \n} ____cacheline_aligned_in_smp;\n\nstruct sge_uld_rxq_info {\n\tchar name[IFNAMSIZ];\t \n\tstruct sge_ofld_rxq *uldrxq;  \n\tu16 *rspq_id;\t\t \n\tu16 nrxq;\t\t \n\tu16 nciq;\t\t \n\tu8 uld;\t\t\t \n};\n\nstruct sge_uld_txq_info {\n\tstruct sge_uld_txq *uldtxq;  \n\tatomic_t users;\t\t \n\tu16 ntxq;\t\t \n};\n\n \nstruct cxgb4_uld_list {\n\tstruct cxgb4_uld_info uld_info;\n\tstruct list_head list_node;\n\tenum cxgb4_uld uld_type;\n};\n\nenum sge_eosw_state {\n\tCXGB4_EO_STATE_CLOSED = 0,  \n\tCXGB4_EO_STATE_FLOWC_OPEN_SEND,  \n\tCXGB4_EO_STATE_FLOWC_OPEN_REPLY,  \n\tCXGB4_EO_STATE_ACTIVE,  \n\tCXGB4_EO_STATE_FLOWC_CLOSE_SEND,  \n\tCXGB4_EO_STATE_FLOWC_CLOSE_REPLY,  \n};\n\nstruct sge_eosw_txq {\n\tspinlock_t lock;  \n\tenum sge_eosw_state state;  \n\tstruct tx_sw_desc *desc;  \n\tu32 ndesc;  \n\tu32 pidx;  \n\tu32 last_pidx;  \n\tu32 cidx;  \n\tu32 last_cidx;  \n\tu32 flowc_idx;  \n\tu32 inuse;  \n\n\tu32 cred;  \n\tu32 ncompl;  \n\tu32 last_compl;  \n\n\tu32 eotid;  \n\tu32 hwtid;  \n\n\tu32 hwqid;  \n\tstruct net_device *netdev;  \n\tstruct tasklet_struct qresume_tsk;  \n\tstruct completion completion;  \n};\n\nstruct sge_eohw_txq {\n\tspinlock_t lock;  \n\tstruct sge_txq q;  \n\tstruct adapter *adap;  \n\tunsigned long tso;  \n\tunsigned long uso;  \n\tunsigned long tx_cso;  \n\tunsigned long vlan_ins;  \n\tunsigned long mapping_err;  \n};\n\nstruct sge {\n\tstruct sge_eth_txq ethtxq[MAX_ETH_QSETS];\n\tstruct sge_eth_txq ptptxq;\n\tstruct sge_ctrl_txq ctrlq[MAX_CTRL_QUEUES];\n\n\tstruct sge_eth_rxq ethrxq[MAX_ETH_QSETS];\n\tstruct sge_rspq fw_evtq ____cacheline_aligned_in_smp;\n\tstruct sge_uld_rxq_info **uld_rxq_info;\n\tstruct sge_uld_txq_info **uld_txq_info;\n\n\tstruct sge_rspq intrq ____cacheline_aligned_in_smp;\n\tspinlock_t intrq_lock;\n\n\tstruct sge_eohw_txq *eohw_txq;\n\tstruct sge_ofld_rxq *eohw_rxq;\n\n\tstruct sge_eth_rxq *mirror_rxq[NCHAN];\n\n\tu16 max_ethqsets;            \n\tu16 ethqsets;                \n\tu16 ethtxq_rover;            \n\tu16 ofldqsets;               \n\tu16 nqs_per_uld;\t     \n\tu16 eoqsets;                 \n\tu16 mirrorqsets;             \n\n\tu16 timer_val[SGE_NTIMERS];\n\tu8 counter_val[SGE_NCOUNTERS];\n\tu16 dbqtimer_tick;\n\tu16 dbqtimer_val[SGE_NDBQTIMERS];\n\tu32 fl_pg_order;             \n\tu32 stat_len;                \n\tu32 pktshift;                \n\tu32 fl_align;                \n\tu32 fl_starve_thres;         \n\n\tstruct sge_idma_monitor_state idma_monitor;\n\tunsigned int egr_start;\n\tunsigned int egr_sz;\n\tunsigned int ingr_start;\n\tunsigned int ingr_sz;\n\tvoid **egr_map;     \n\tstruct sge_rspq **ingr_map;  \n\tunsigned long *starving_fl;\n\tunsigned long *txq_maperr;\n\tunsigned long *blocked_fl;\n\tstruct timer_list rx_timer;  \n\tstruct timer_list tx_timer;  \n\n\tint fwevtq_msix_idx;  \n\tint nd_msix_idx;  \n};\n\n#define for_each_ethrxq(sge, i) for (i = 0; i < (sge)->ethqsets; i++)\n#define for_each_ofldtxq(sge, i) for (i = 0; i < (sge)->ofldqsets; i++)\n\nstruct l2t_data;\n\n#ifdef CONFIG_PCI_IOV\n\n \n#define NUM_OF_PF_WITH_SRIOV 4\n\n#endif\n\nstruct doorbell_stats {\n\tu32 db_drop;\n\tu32 db_empty;\n\tu32 db_full;\n};\n\nstruct hash_mac_addr {\n\tstruct list_head list;\n\tu8 addr[ETH_ALEN];\n\tunsigned int iface_mac;\n};\n\nstruct msix_bmap {\n\tunsigned long *msix_bmap;\n\tunsigned int mapsize;\n\tspinlock_t lock;  \n};\n\nstruct msix_info {\n\tunsigned short vec;\n\tchar desc[IFNAMSIZ + 10];\n\tunsigned int idx;\n\tcpumask_var_t aff_mask;\n};\n\nstruct vf_info {\n\tunsigned char vf_mac_addr[ETH_ALEN];\n\tunsigned int tx_rate;\n\tbool pf_set_mac;\n\tu16 vlan;\n\tint link_state;\n};\n\nenum {\n\tHMA_DMA_MAPPED_FLAG = 1\n};\n\nstruct hma_data {\n\tunsigned char flags;\n\tstruct sg_table *sgt;\n\tdma_addr_t *phy_addr;\t \n};\n\nstruct mbox_list {\n\tstruct list_head list;\n};\n\n#if IS_ENABLED(CONFIG_THERMAL)\nstruct ch_thermal {\n\tstruct thermal_zone_device *tzdev;\n};\n#endif\n\nstruct mps_entries_ref {\n\tstruct list_head list;\n\tu8 addr[ETH_ALEN];\n\tu8 mask[ETH_ALEN];\n\tu16 idx;\n\trefcount_t refcnt;\n};\n\nstruct cxgb4_ethtool_filter_info {\n\tu32 *loc_array;  \n\tunsigned long *bmap;  \n\tu32 in_use;  \n};\n\nstruct cxgb4_ethtool_filter {\n\tu32 nentries;  \n\tstruct cxgb4_ethtool_filter_info *port;  \n};\n\nstruct adapter {\n\tvoid __iomem *regs;\n\tvoid __iomem *bar2;\n\tu32 t4_bar0;\n\tstruct pci_dev *pdev;\n\tstruct device *pdev_dev;\n\tconst char *name;\n\tunsigned int mbox;\n\tunsigned int pf;\n\tunsigned int flags;\n\tunsigned int adap_idx;\n\tenum chip_type chip;\n\tu32 eth_flags;\n\n\tint msg_enable;\n\t__be16 vxlan_port;\n\t__be16 geneve_port;\n\n\tstruct adapter_params params;\n\tstruct cxgb4_virt_res vres;\n\tunsigned int swintr;\n\n\t \n\tstruct msix_info *msix_info;\n\tstruct msix_bmap msix_bmap;\n\n\tstruct doorbell_stats db_stats;\n\tstruct sge sge;\n\n\tstruct net_device *port[MAX_NPORTS];\n\tu8 chan_map[NCHAN];                    \n\n\tstruct vf_info *vfinfo;\n\tu8 num_vfs;\n\n\tu32 filter_mode;\n\tunsigned int l2t_start;\n\tunsigned int l2t_end;\n\tstruct l2t_data *l2t;\n\tunsigned int clipt_start;\n\tunsigned int clipt_end;\n\tstruct clip_tbl *clipt;\n\tunsigned int rawf_start;\n\tunsigned int rawf_cnt;\n\tstruct smt_data *smt;\n\tstruct cxgb4_uld_info *uld;\n\tvoid *uld_handle[CXGB4_ULD_MAX];\n\tunsigned int num_uld;\n\tunsigned int num_ofld_uld;\n\tstruct list_head list_node;\n\tstruct list_head rcu_node;\n\tstruct list_head mac_hlist;  \n\tstruct list_head mps_ref;\n\tspinlock_t mps_ref_lock;  \n\n\tvoid *iscsi_ppm;\n\n\tstruct tid_info tids;\n\tvoid **tid_release_head;\n\tspinlock_t tid_release_lock;\n\tstruct workqueue_struct *workq;\n\tstruct work_struct tid_release_task;\n\tstruct work_struct db_full_task;\n\tstruct work_struct db_drop_task;\n\tstruct work_struct fatal_err_notify_task;\n\tbool tid_release_task_busy;\n\n\t \n\tspinlock_t mbox_lock;\n\tstruct mbox_list mlist;\n\n\t \n#define T4_OS_LOG_MBOX_CMDS 256\n\tstruct mbox_cmd_log *mbox_log;\n\n\tstruct mutex uld_mutex;\n\n\tstruct dentry *debugfs_root;\n\tbool use_bd;      \n\tbool trace_rss;\t \n\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info ptp_clock_info;\n\tstruct sk_buff *ptp_tx_skb;\n\t \n\tspinlock_t ptp_lock;\n\tspinlock_t stats_lock;\n\tspinlock_t win0_lock ____cacheline_aligned_in_smp;\n\n\t \n\tstruct cxgb4_tc_u32_table *tc_u32;\n\tstruct chcr_ktls chcr_ktls;\n\tstruct chcr_stats_debug chcr_stats;\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\n\tstruct ch_ktls_stats_debug ch_ktls_stats;\n#endif\n#if IS_ENABLED(CONFIG_CHELSIO_IPSEC_INLINE)\n\tstruct ch_ipsec_stats_debug ch_ipsec_stats;\n#endif\n\n\t \n\tbool tc_flower_initialized;\n\tstruct rhashtable flower_tbl;\n\tstruct rhashtable_params flower_ht_params;\n\tstruct timer_list flower_stats_timer;\n\tstruct work_struct flower_stats_work;\n\n\t \n\tstruct ethtool_dump eth_dump;\n\n\t \n\tstruct hma_data hma;\n\n\tstruct srq_data *srq;\n\n\t \n\tstruct vmcoredd_data vmcoredd;\n#if IS_ENABLED(CONFIG_THERMAL)\n\tstruct ch_thermal ch_thermal;\n#endif\n\n\t \n\tstruct cxgb4_tc_mqprio *tc_mqprio;\n\n\t \n\tstruct cxgb4_tc_matchall *tc_matchall;\n\n\t \n\tstruct cxgb4_ethtool_filter *ethtool_filters;\n};\n\n \nstruct ch_sched_params {\n\tu8   type;                      \n\tunion {\n\t\tstruct {\n\t\t\tu8   level;     \n\t\t\tu8   mode;      \n\t\t\tu8   rateunit;  \n\t\t\tu8   ratemode;  \n\t\t\tu8   channel;   \n\t\t\tu8   class;     \n\t\t\tu32  minrate;   \n\t\t\tu32  maxrate;   \n\t\t\tu16  weight;    \n\t\t\tu16  pktsize;   \n\t\t\tu16  burstsize;   \n\t\t} params;\n\t} u;\n};\n\nenum {\n\tSCHED_CLASS_TYPE_PACKET = 0,     \n};\n\nenum {\n\tSCHED_CLASS_LEVEL_CL_RL = 0,     \n\tSCHED_CLASS_LEVEL_CH_RL = 2,     \n};\n\nenum {\n\tSCHED_CLASS_MODE_CLASS = 0,      \n\tSCHED_CLASS_MODE_FLOW,           \n};\n\nenum {\n\tSCHED_CLASS_RATEUNIT_BITS = 0,   \n};\n\nenum {\n\tSCHED_CLASS_RATEMODE_ABS = 1,    \n};\n\n \nstruct ch_sched_queue {\n\ts8   queue;     \n\ts8   class;     \n};\n\n \nstruct ch_sched_flowc {\n\ts32 tid;    \n\ts8  class;  \n};\n\n \n#define ETHTYPE_BITWIDTH 16\n#define FRAG_BITWIDTH 1\n#define MACIDX_BITWIDTH 9\n#define FCOE_BITWIDTH 1\n#define IPORT_BITWIDTH 3\n#define MATCHTYPE_BITWIDTH 3\n#define PROTO_BITWIDTH 8\n#define TOS_BITWIDTH 8\n#define PF_BITWIDTH 8\n#define VF_BITWIDTH 8\n#define IVLAN_BITWIDTH 16\n#define OVLAN_BITWIDTH 16\n#define ENCAP_VNI_BITWIDTH 24\n\n \nstruct ch_filter_tuple {\n\t \n\tuint32_t ethtype:ETHTYPE_BITWIDTH;       \n\tuint32_t frag:FRAG_BITWIDTH;             \n\tuint32_t ivlan_vld:1;                    \n\tuint32_t ovlan_vld:1;                    \n\tuint32_t pfvf_vld:1;                     \n\tuint32_t encap_vld:1;\t\t\t \n\tuint32_t macidx:MACIDX_BITWIDTH;         \n\tuint32_t fcoe:FCOE_BITWIDTH;             \n\tuint32_t iport:IPORT_BITWIDTH;           \n\tuint32_t matchtype:MATCHTYPE_BITWIDTH;   \n\tuint32_t proto:PROTO_BITWIDTH;           \n\tuint32_t tos:TOS_BITWIDTH;               \n\tuint32_t pf:PF_BITWIDTH;                 \n\tuint32_t vf:VF_BITWIDTH;                 \n\tuint32_t ivlan:IVLAN_BITWIDTH;           \n\tuint32_t ovlan:OVLAN_BITWIDTH;           \n\tuint32_t vni:ENCAP_VNI_BITWIDTH;\t \n\n\t \n\tuint8_t lip[16];         \n\tuint8_t fip[16];         \n\tuint16_t lport;          \n\tuint16_t fport;          \n};\n\n \nstruct ch_filter_specification {\n\t \n\tuint32_t hitcnts:1;      \n\tuint32_t prio:1;         \n\n\t \n\tuint32_t type:1;         \n\tu32 hash:1;\t\t \n\n\t \n\tuint32_t action:2;       \n\n\tuint32_t rpttid:1;       \n\n\tuint32_t dirsteer:1;     \n\tuint32_t iq:10;          \n\n\tuint32_t maskhash:1;     \n\tuint32_t dirsteerhash:1; \n\t\t\t\t \n\n\t \n\tuint32_t eport:2;        \n\tuint32_t newdmac:1;      \n\tuint32_t newsmac:1;      \n\tuint32_t newvlan:2;      \n\tuint32_t nat_mode:3;     \n\tuint8_t dmac[ETH_ALEN];  \n\tuint8_t smac[ETH_ALEN];  \n\tuint16_t vlan;           \n\n\tu8 nat_lip[16];\t\t \n\tu8 nat_fip[16];\t\t \n\tu16 nat_lport;\t\t \n\tu16 nat_fport;\t\t \n\n\tu32 tc_prio;\t\t \n\tu64 tc_cookie;\t\t \n\n\t \n\tu8 rsvd[12];\n\n\t \n\tstruct ch_filter_tuple val;\n\tstruct ch_filter_tuple mask;\n};\n\nenum {\n\tFILTER_PASS = 0,         \n\tFILTER_DROP,\n\tFILTER_SWITCH\n};\n\nenum {\n\tVLAN_NOCHANGE = 0,       \n\tVLAN_REMOVE,\n\tVLAN_INSERT,\n\tVLAN_REWRITE\n};\n\nenum {\n\tNAT_MODE_NONE = 0,\t \n\tNAT_MODE_DIP,\t\t \n\tNAT_MODE_DIP_DP,\t \n\tNAT_MODE_DIP_DP_SIP,\t \n\tNAT_MODE_DIP_DP_SP,\t \n\tNAT_MODE_SIP_SP,\t \n\tNAT_MODE_DIP_SIP_SP,\t \n\tNAT_MODE_ALL\t\t \n};\n\n#define CXGB4_FILTER_TYPE_MAX 2\n\n \nstruct filter_entry {\n\t \n\tu32 valid:1;             \n\tu32 locked:1;            \n\n\tu32 pending:1;           \n\tstruct filter_ctx *ctx;  \n\tstruct l2t_entry *l2t;   \n\tstruct smt_entry *smt;   \n\tstruct net_device *dev;  \n\tu32 tid;                 \n\n\t \n\tstruct ch_filter_specification fs;\n};\n\nstatic inline int is_offload(const struct adapter *adap)\n{\n\treturn adap->params.offload;\n}\n\nstatic inline int is_hashfilter(const struct adapter *adap)\n{\n\treturn adap->params.hash_filter;\n}\n\nstatic inline int is_pci_uld(const struct adapter *adap)\n{\n\treturn adap->params.crypto;\n}\n\nstatic inline int is_uld(const struct adapter *adap)\n{\n\treturn (adap->params.offload || adap->params.crypto);\n}\n\nstatic inline int is_ethofld(const struct adapter *adap)\n{\n\treturn adap->params.ethofld;\n}\n\nstatic inline u32 t4_read_reg(struct adapter *adap, u32 reg_addr)\n{\n\treturn readl(adap->regs + reg_addr);\n}\n\nstatic inline void t4_write_reg(struct adapter *adap, u32 reg_addr, u32 val)\n{\n\twritel(val, adap->regs + reg_addr);\n}\n\n#ifndef readq\nstatic inline u64 readq(const volatile void __iomem *addr)\n{\n\treturn readl(addr) + ((u64)readl(addr + 4) << 32);\n}\n\nstatic inline void writeq(u64 val, volatile void __iomem *addr)\n{\n\twritel(val, addr);\n\twritel(val >> 32, addr + 4);\n}\n#endif\n\nstatic inline u64 t4_read_reg64(struct adapter *adap, u32 reg_addr)\n{\n\treturn readq(adap->regs + reg_addr);\n}\n\nstatic inline void t4_write_reg64(struct adapter *adap, u32 reg_addr, u64 val)\n{\n\twriteq(val, adap->regs + reg_addr);\n}\n\n \nstatic inline void t4_set_hw_addr(struct adapter *adapter, int port_idx,\n\t\t\t\t  u8 hw_addr[])\n{\n\teth_hw_addr_set(adapter->port[port_idx], hw_addr);\n\tether_addr_copy(adapter->port[port_idx]->perm_addr, hw_addr);\n}\n\n \nstatic inline struct port_info *netdev2pinfo(const struct net_device *dev)\n{\n\treturn netdev_priv(dev);\n}\n\n \nstatic inline struct port_info *adap2pinfo(struct adapter *adap, int idx)\n{\n\treturn netdev_priv(adap->port[idx]);\n}\n\n \nstatic inline struct adapter *netdev2adap(const struct net_device *dev)\n{\n\treturn netdev2pinfo(dev)->adapter;\n}\n\n \nstatic inline unsigned int mk_adap_vers(struct adapter *ap)\n{\n\treturn CHELSIO_CHIP_VERSION(ap->params.chip) |\n\t\t(CHELSIO_CHIP_RELEASE(ap->params.chip) << 10) | (1 << 16);\n}\n\n \nstatic inline unsigned int qtimer_val(const struct adapter *adap,\n\t\t\t\t      const struct sge_rspq *q)\n{\n\tunsigned int idx = q->intr_params >> 1;\n\n\treturn idx < SGE_NTIMERS ? adap->sge.timer_val[idx] : 0;\n}\n\n \nextern char cxgb4_driver_name[];\n\nvoid t4_os_portmod_changed(struct adapter *adap, int port_id);\nvoid t4_os_link_changed(struct adapter *adap, int port_id, int link_stat);\n\nvoid t4_free_sge_resources(struct adapter *adap);\nvoid t4_free_ofld_rxqs(struct adapter *adap, int n, struct sge_ofld_rxq *q);\nirq_handler_t t4_intr_handler(struct adapter *adap);\nnetdev_tx_t t4_start_xmit(struct sk_buff *skb, struct net_device *dev);\nint cxgb4_selftest_lb_pkt(struct net_device *netdev);\nint t4_ethrx_handler(struct sge_rspq *q, const __be64 *rsp,\n\t\t     const struct pkt_gl *gl);\nint t4_mgmt_tx(struct adapter *adap, struct sk_buff *skb);\nint t4_ofld_send(struct adapter *adap, struct sk_buff *skb);\nint t4_sge_alloc_rxq(struct adapter *adap, struct sge_rspq *iq, bool fwevtq,\n\t\t     struct net_device *dev, int intr_idx,\n\t\t     struct sge_fl *fl, rspq_handler_t hnd,\n\t\t     rspq_flush_handler_t flush_handler, int cong);\nint t4_sge_alloc_eth_txq(struct adapter *adap, struct sge_eth_txq *txq,\n\t\t\t struct net_device *dev, struct netdev_queue *netdevq,\n\t\t\t unsigned int iqid, u8 dbqt);\nint t4_sge_alloc_ctrl_txq(struct adapter *adap, struct sge_ctrl_txq *txq,\n\t\t\t  struct net_device *dev, unsigned int iqid,\n\t\t\t  unsigned int cmplqid);\nint t4_sge_mod_ctrl_txq(struct adapter *adap, unsigned int eqid,\n\t\t\tunsigned int cmplqid);\nint t4_sge_alloc_uld_txq(struct adapter *adap, struct sge_uld_txq *txq,\n\t\t\t struct net_device *dev, unsigned int iqid,\n\t\t\t unsigned int uld_type);\nint t4_sge_alloc_ethofld_txq(struct adapter *adap, struct sge_eohw_txq *txq,\n\t\t\t     struct net_device *dev, u32 iqid);\nvoid t4_sge_free_ethofld_txq(struct adapter *adap, struct sge_eohw_txq *txq);\nirqreturn_t t4_sge_intr_msix(int irq, void *cookie);\nint t4_sge_init(struct adapter *adap);\nvoid t4_sge_start(struct adapter *adap);\nvoid t4_sge_stop(struct adapter *adap);\nint t4_sge_eth_txq_egress_update(struct adapter *adap, struct sge_eth_txq *q,\n\t\t\t\t int maxreclaim);\nvoid cxgb4_set_ethtool_ops(struct net_device *netdev);\nint cxgb4_write_rss(const struct port_info *pi, const u16 *queues);\nenum cpl_tx_tnl_lso_type cxgb_encap_offload_supported(struct sk_buff *skb);\nextern int dbfifo_int_thresh;\n\n#define for_each_port(adapter, iter) \\\n\tfor (iter = 0; iter < (adapter)->params.nports; ++iter)\n\nstatic inline int is_bypass(struct adapter *adap)\n{\n\treturn adap->params.bypass;\n}\n\nstatic inline int is_bypass_device(int device)\n{\n\t \n\tswitch (device) {\n\tcase 0x440b:\n\tcase 0x440c:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline int is_10gbt_device(int device)\n{\n\t \n\tswitch (device) {\n\tcase 0x4409:\n\tcase 0x4486:\n\t\treturn 1;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline unsigned int core_ticks_per_usec(const struct adapter *adap)\n{\n\treturn adap->params.vpd.cclk / 1000;\n}\n\nstatic inline unsigned int us_to_core_ticks(const struct adapter *adap,\n\t\t\t\t\t    unsigned int us)\n{\n\treturn (us * adap->params.vpd.cclk) / 1000;\n}\n\nstatic inline unsigned int core_ticks_to_us(const struct adapter *adapter,\n\t\t\t\t\t    unsigned int ticks)\n{\n\t \n\treturn ((ticks * 1000 + adapter->params.vpd.cclk/2) /\n\t\tadapter->params.vpd.cclk);\n}\n\nstatic inline unsigned int dack_ticks_to_usec(const struct adapter *adap,\n\t\t\t\t\t      unsigned int ticks)\n{\n\treturn (ticks << adap->params.tp.dack_re) / core_ticks_per_usec(adap);\n}\n\nvoid t4_set_reg_field(struct adapter *adap, unsigned int addr, u32 mask,\n\t\t      u32 val);\n\nint t4_wr_mbox_meat_timeout(struct adapter *adap, int mbox, const void *cmd,\n\t\t\t    int size, void *rpl, bool sleep_ok, int timeout);\nint t4_wr_mbox_meat(struct adapter *adap, int mbox, const void *cmd, int size,\n\t\t    void *rpl, bool sleep_ok);\n\nstatic inline int t4_wr_mbox_timeout(struct adapter *adap, int mbox,\n\t\t\t\t     const void *cmd, int size, void *rpl,\n\t\t\t\t     int timeout)\n{\n\treturn t4_wr_mbox_meat_timeout(adap, mbox, cmd, size, rpl, true,\n\t\t\t\t       timeout);\n}\n\nstatic inline int t4_wr_mbox(struct adapter *adap, int mbox, const void *cmd,\n\t\t\t     int size, void *rpl)\n{\n\treturn t4_wr_mbox_meat(adap, mbox, cmd, size, rpl, true);\n}\n\nstatic inline int t4_wr_mbox_ns(struct adapter *adap, int mbox, const void *cmd,\n\t\t\t\tint size, void *rpl)\n{\n\treturn t4_wr_mbox_meat(adap, mbox, cmd, size, rpl, false);\n}\n\n \nstatic inline int hash_mac_addr(const u8 *addr)\n{\n\tu32 a = ((u32)addr[0] << 16) | ((u32)addr[1] << 8) | addr[2];\n\tu32 b = ((u32)addr[3] << 16) | ((u32)addr[4] << 8) | addr[5];\n\n\ta ^= b;\n\ta ^= (a >> 12);\n\ta ^= (a >> 6);\n\treturn a & 0x3f;\n}\n\nint cxgb4_set_rspq_intr_params(struct sge_rspq *q, unsigned int us,\n\t\t\t       unsigned int cnt);\nstatic inline void init_rspq(struct adapter *adap, struct sge_rspq *q,\n\t\t\t     unsigned int us, unsigned int cnt,\n\t\t\t     unsigned int size, unsigned int iqe_size)\n{\n\tq->adap = adap;\n\tcxgb4_set_rspq_intr_params(q, us, cnt);\n\tq->iqe_len = iqe_size;\n\tq->size = size;\n}\n\n \nstatic inline bool t4_is_inserted_mod_type(unsigned int fw_mod_type)\n{\n\treturn (fw_mod_type != FW_PORT_MOD_TYPE_NONE &&\n\t\tfw_mod_type != FW_PORT_MOD_TYPE_NOTSUPPORTED &&\n\t\tfw_mod_type != FW_PORT_MOD_TYPE_UNKNOWN &&\n\t\tfw_mod_type != FW_PORT_MOD_TYPE_ERROR);\n}\n\nvoid t4_write_indirect(struct adapter *adap, unsigned int addr_reg,\n\t\t       unsigned int data_reg, const u32 *vals,\n\t\t       unsigned int nregs, unsigned int start_idx);\nvoid t4_read_indirect(struct adapter *adap, unsigned int addr_reg,\n\t\t      unsigned int data_reg, u32 *vals, unsigned int nregs,\n\t\t      unsigned int start_idx);\nvoid t4_hw_pci_read_cfg4(struct adapter *adapter, int reg, u32 *val);\n\nstruct fw_filter_wr;\n\nvoid t4_intr_enable(struct adapter *adapter);\nvoid t4_intr_disable(struct adapter *adapter);\nint t4_slow_intr_handler(struct adapter *adapter);\n\nint t4_wait_dev_ready(void __iomem *regs);\n\nfw_port_cap32_t t4_link_acaps(struct adapter *adapter, unsigned int port,\n\t\t\t      struct link_config *lc);\nint t4_link_l1cfg_core(struct adapter *adap, unsigned int mbox,\n\t\t       unsigned int port, struct link_config *lc,\n\t\t       u8 sleep_ok, int timeout);\n\nstatic inline int t4_link_l1cfg(struct adapter *adapter, unsigned int mbox,\n\t\t\t\tunsigned int port, struct link_config *lc)\n{\n\treturn t4_link_l1cfg_core(adapter, mbox, port, lc,\n\t\t\t\t  true, FW_CMD_MAX_TIMEOUT);\n}\n\nstatic inline int t4_link_l1cfg_ns(struct adapter *adapter, unsigned int mbox,\n\t\t\t\t   unsigned int port, struct link_config *lc)\n{\n\treturn t4_link_l1cfg_core(adapter, mbox, port, lc,\n\t\t\t\t  false, FW_CMD_MAX_TIMEOUT);\n}\n\nint t4_restart_aneg(struct adapter *adap, unsigned int mbox, unsigned int port);\n\nu32 t4_read_pcie_cfg4(struct adapter *adap, int reg);\nu32 t4_get_util_window(struct adapter *adap);\nvoid t4_setup_memwin(struct adapter *adap, u32 memwin_base, u32 window);\n\nint t4_memory_rw_init(struct adapter *adap, int win, int mtype, u32 *mem_off,\n\t\t      u32 *mem_base, u32 *mem_aperture);\nvoid t4_memory_update_win(struct adapter *adap, int win, u32 addr);\nvoid t4_memory_rw_residual(struct adapter *adap, u32 off, u32 addr, u8 *buf,\n\t\t\t   int dir);\n#define T4_MEMORY_WRITE\t0\n#define T4_MEMORY_READ\t1\nint t4_memory_rw(struct adapter *adap, int win, int mtype, u32 addr, u32 len,\n\t\t void *buf, int dir);\nstatic inline int t4_memory_write(struct adapter *adap, int mtype, u32 addr,\n\t\t\t\t  u32 len, __be32 *buf)\n{\n\treturn t4_memory_rw(adap, 0, mtype, addr, len, buf, 0);\n}\n\nunsigned int t4_get_regs_len(struct adapter *adapter);\nvoid t4_get_regs(struct adapter *adap, void *buf, size_t buf_size);\n\nint t4_eeprom_ptov(unsigned int phys_addr, unsigned int fn, unsigned int sz);\nint t4_seeprom_wp(struct adapter *adapter, bool enable);\nint t4_get_raw_vpd_params(struct adapter *adapter, struct vpd_params *p);\nint t4_get_vpd_params(struct adapter *adapter, struct vpd_params *p);\nint t4_get_pfres(struct adapter *adapter);\nint t4_read_flash(struct adapter *adapter, unsigned int addr,\n\t\t  unsigned int nwords, u32 *data, int byte_oriented);\nint t4_load_fw(struct adapter *adapter, const u8 *fw_data, unsigned int size);\nint t4_load_phy_fw(struct adapter *adap, int win,\n\t\t   int (*phy_fw_version)(const u8 *, size_t),\n\t\t   const u8 *phy_fw_data, size_t phy_fw_size);\nint t4_phy_fw_ver(struct adapter *adap, int *phy_fw_ver);\nint t4_fwcache(struct adapter *adap, enum fw_params_param_dev_fwcache op);\nint t4_fw_upgrade(struct adapter *adap, unsigned int mbox,\n\t\t  const u8 *fw_data, unsigned int size, int force);\nint t4_fl_pkt_align(struct adapter *adap);\nunsigned int t4_flash_cfg_addr(struct adapter *adapter);\nint t4_check_fw_version(struct adapter *adap);\nint t4_load_cfg(struct adapter *adapter, const u8 *cfg_data, unsigned int size);\nint t4_get_fw_version(struct adapter *adapter, u32 *vers);\nint t4_get_bs_version(struct adapter *adapter, u32 *vers);\nint t4_get_tp_version(struct adapter *adapter, u32 *vers);\nint t4_get_exprom_version(struct adapter *adapter, u32 *vers);\nint t4_get_scfg_version(struct adapter *adapter, u32 *vers);\nint t4_get_vpd_version(struct adapter *adapter, u32 *vers);\nint t4_get_version_info(struct adapter *adapter);\nvoid t4_dump_version_info(struct adapter *adapter);\nint t4_prep_fw(struct adapter *adap, struct fw_info *fw_info,\n\t       const u8 *fw_data, unsigned int fw_size,\n\t       struct fw_hdr *card_fw, enum dev_state state, int *reset);\nint t4_prep_adapter(struct adapter *adapter);\nint t4_shutdown_adapter(struct adapter *adapter);\n\nenum t4_bar2_qtype { T4_BAR2_QTYPE_EGRESS, T4_BAR2_QTYPE_INGRESS };\nint t4_bar2_sge_qregs(struct adapter *adapter,\n\t\t      unsigned int qid,\n\t\t      enum t4_bar2_qtype qtype,\n\t\t      int user,\n\t\t      u64 *pbar2_qoffset,\n\t\t      unsigned int *pbar2_qid);\n\nunsigned int qtimer_val(const struct adapter *adap,\n\t\t\tconst struct sge_rspq *q);\n\nint t4_init_devlog_params(struct adapter *adapter);\nint t4_init_sge_params(struct adapter *adapter);\nint t4_init_tp_params(struct adapter *adap, bool sleep_ok);\nint t4_filter_field_shift(const struct adapter *adap, int filter_sel);\nint t4_init_rss_mode(struct adapter *adap, int mbox);\nint t4_init_portinfo(struct port_info *pi, int mbox,\n\t\t     int port, int pf, int vf, u8 mac[]);\nint t4_port_init(struct adapter *adap, int mbox, int pf, int vf);\nint t4_init_port_mirror(struct port_info *pi, u8 mbox, u8 port, u8 pf, u8 vf,\n\t\t\tu16 *mirror_viid);\nvoid t4_fatal_err(struct adapter *adapter);\nunsigned int t4_chip_rss_size(struct adapter *adapter);\nint t4_config_rss_range(struct adapter *adapter, int mbox, unsigned int viid,\n\t\t\tint start, int n, const u16 *rspq, unsigned int nrspq);\nint t4_config_glbl_rss(struct adapter *adapter, int mbox, unsigned int mode,\n\t\t       unsigned int flags);\nint t4_config_vi_rss(struct adapter *adapter, int mbox, unsigned int viid,\n\t\t     unsigned int flags, unsigned int defq);\nint t4_read_rss(struct adapter *adapter, u16 *entries);\nvoid t4_read_rss_key(struct adapter *adapter, u32 *key, bool sleep_ok);\nvoid t4_write_rss_key(struct adapter *adap, const u32 *key, int idx,\n\t\t      bool sleep_ok);\nvoid t4_read_rss_pf_config(struct adapter *adapter, unsigned int index,\n\t\t\t   u32 *valp, bool sleep_ok);\nvoid t4_read_rss_vf_config(struct adapter *adapter, unsigned int index,\n\t\t\t   u32 *vfl, u32 *vfh, bool sleep_ok);\nu32 t4_read_rss_pf_map(struct adapter *adapter, bool sleep_ok);\nu32 t4_read_rss_pf_mask(struct adapter *adapter, bool sleep_ok);\n\nunsigned int t4_get_mps_bg_map(struct adapter *adapter, int pidx);\nunsigned int t4_get_tp_ch_map(struct adapter *adapter, int pidx);\nvoid t4_pmtx_get_stats(struct adapter *adap, u32 cnt[], u64 cycles[]);\nvoid t4_pmrx_get_stats(struct adapter *adap, u32 cnt[], u64 cycles[]);\nint t4_read_cim_ibq(struct adapter *adap, unsigned int qid, u32 *data,\n\t\t    size_t n);\nint t4_read_cim_obq(struct adapter *adap, unsigned int qid, u32 *data,\n\t\t    size_t n);\nint t4_cim_read(struct adapter *adap, unsigned int addr, unsigned int n,\n\t\tunsigned int *valp);\nint t4_cim_write(struct adapter *adap, unsigned int addr, unsigned int n,\n\t\t const unsigned int *valp);\nint t4_cim_read_la(struct adapter *adap, u32 *la_buf, unsigned int *wrptr);\nvoid t4_cim_read_pif_la(struct adapter *adap, u32 *pif_req, u32 *pif_rsp,\n\t\t\tunsigned int *pif_req_wrptr,\n\t\t\tunsigned int *pif_rsp_wrptr);\nvoid t4_cim_read_ma_la(struct adapter *adap, u32 *ma_req, u32 *ma_rsp);\nvoid t4_read_cimq_cfg(struct adapter *adap, u16 *base, u16 *size, u16 *thres);\nconst char *t4_get_port_type_description(enum fw_port_type port_type);\nvoid t4_get_port_stats(struct adapter *adap, int idx, struct port_stats *p);\nvoid t4_get_port_stats_offset(struct adapter *adap, int idx,\n\t\t\t      struct port_stats *stats,\n\t\t\t      struct port_stats *offset);\nvoid t4_get_lb_stats(struct adapter *adap, int idx, struct lb_port_stats *p);\nvoid t4_read_mtu_tbl(struct adapter *adap, u16 *mtus, u8 *mtu_log);\nvoid t4_read_cong_tbl(struct adapter *adap, u16 incr[NMTUS][NCCTRL_WIN]);\nvoid t4_tp_wr_bits_indirect(struct adapter *adap, unsigned int addr,\n\t\t\t    unsigned int mask, unsigned int val);\nvoid t4_tp_read_la(struct adapter *adap, u64 *la_buf, unsigned int *wrptr);\nvoid t4_tp_get_err_stats(struct adapter *adap, struct tp_err_stats *st,\n\t\t\t bool sleep_ok);\nvoid t4_tp_get_cpl_stats(struct adapter *adap, struct tp_cpl_stats *st,\n\t\t\t bool sleep_ok);\nvoid t4_tp_get_rdma_stats(struct adapter *adap, struct tp_rdma_stats *st,\n\t\t\t  bool sleep_ok);\nvoid t4_get_usm_stats(struct adapter *adap, struct tp_usm_stats *st,\n\t\t      bool sleep_ok);\nvoid t4_tp_get_tcp_stats(struct adapter *adap, struct tp_tcp_stats *v4,\n\t\t\t struct tp_tcp_stats *v6, bool sleep_ok);\nvoid t4_get_fcoe_stats(struct adapter *adap, unsigned int idx,\n\t\t       struct tp_fcoe_stats *st, bool sleep_ok);\nvoid t4_load_mtus(struct adapter *adap, const unsigned short *mtus,\n\t\t  const unsigned short *alpha, const unsigned short *beta);\n\nvoid t4_ulprx_read_la(struct adapter *adap, u32 *la_buf);\n\nvoid t4_get_chan_txrate(struct adapter *adap, u64 *nic_rate, u64 *ofld_rate);\nvoid t4_mk_filtdelwr(unsigned int ftid, struct fw_filter_wr *wr, int qid);\n\nvoid t4_wol_magic_enable(struct adapter *adap, unsigned int port,\n\t\t\t const u8 *addr);\nint t4_wol_pat_enable(struct adapter *adap, unsigned int port, unsigned int map,\n\t\t      u64 mask0, u64 mask1, unsigned int crc, bool enable);\n\nint t4_fw_hello(struct adapter *adap, unsigned int mbox, unsigned int evt_mbox,\n\t\tenum dev_master master, enum dev_state *state);\nint t4_fw_bye(struct adapter *adap, unsigned int mbox);\nint t4_early_init(struct adapter *adap, unsigned int mbox);\nint t4_fw_reset(struct adapter *adap, unsigned int mbox, int reset);\nint t4_fixup_host_params(struct adapter *adap, unsigned int page_size,\n\t\t\t  unsigned int cache_line_size);\nint t4_fw_initialize(struct adapter *adap, unsigned int mbox);\nint t4_query_params(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\t    unsigned int vf, unsigned int nparams, const u32 *params,\n\t\t    u32 *val);\nint t4_query_params_ns(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\t       unsigned int vf, unsigned int nparams, const u32 *params,\n\t\t       u32 *val);\nint t4_query_params_rw(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\t       unsigned int vf, unsigned int nparams, const u32 *params,\n\t\t       u32 *val, int rw, bool sleep_ok);\nint t4_set_params_timeout(struct adapter *adap, unsigned int mbox,\n\t\t\t  unsigned int pf, unsigned int vf,\n\t\t\t  unsigned int nparams, const u32 *params,\n\t\t\t  const u32 *val, int timeout);\nint t4_set_params(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\t  unsigned int vf, unsigned int nparams, const u32 *params,\n\t\t  const u32 *val);\nint t4_cfg_pfvf(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\tunsigned int vf, unsigned int txq, unsigned int txq_eth_ctrl,\n\t\tunsigned int rxqi, unsigned int rxq, unsigned int tc,\n\t\tunsigned int vi, unsigned int cmask, unsigned int pmask,\n\t\tunsigned int nexact, unsigned int rcaps, unsigned int wxcaps);\nint t4_alloc_vi(struct adapter *adap, unsigned int mbox, unsigned int port,\n\t\tunsigned int pf, unsigned int vf, unsigned int nmac, u8 *mac,\n\t\tunsigned int *rss_size, u8 *vivld, u8 *vin);\nint t4_free_vi(struct adapter *adap, unsigned int mbox,\n\t       unsigned int pf, unsigned int vf,\n\t       unsigned int viid);\nint t4_set_rxmode(struct adapter *adap, unsigned int mbox, unsigned int viid,\n\t\t  unsigned int viid_mirror, int mtu, int promisc, int all_multi,\n\t\t  int bcast, int vlanex, bool sleep_ok);\nint t4_free_raw_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\t const u8 *addr, const u8 *mask, unsigned int idx,\n\t\t\t u8 lookup_type, u8 port_id, bool sleep_ok);\nint t4_free_encap_mac_filt(struct adapter *adap, unsigned int viid, int idx,\n\t\t\t   bool sleep_ok);\nint t4_alloc_encap_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\t    const u8 *addr, const u8 *mask, unsigned int vni,\n\t\t\t    unsigned int vni_mask, u8 dip_hit, u8 lookup_type,\n\t\t\t    bool sleep_ok);\nint t4_alloc_raw_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\t  const u8 *addr, const u8 *mask, unsigned int idx,\n\t\t\t  u8 lookup_type, u8 port_id, bool sleep_ok);\nint t4_alloc_mac_filt(struct adapter *adap, unsigned int mbox,\n\t\t      unsigned int viid, bool free, unsigned int naddr,\n\t\t      const u8 **addr, u16 *idx, u64 *hash, bool sleep_ok);\nint t4_free_mac_filt(struct adapter *adap, unsigned int mbox,\n\t\t     unsigned int viid, unsigned int naddr,\n\t\t     const u8 **addr, bool sleep_ok);\nint t4_change_mac(struct adapter *adap, unsigned int mbox, unsigned int viid,\n\t\t  int idx, const u8 *addr, bool persist, u8 *smt_idx);\nint t4_set_addr_hash(struct adapter *adap, unsigned int mbox, unsigned int viid,\n\t\t     bool ucast, u64 vec, bool sleep_ok);\nint t4_enable_vi_params(struct adapter *adap, unsigned int mbox,\n\t\t\tunsigned int viid, bool rx_en, bool tx_en, bool dcb_en);\nint t4_enable_pi_params(struct adapter *adap, unsigned int mbox,\n\t\t\tstruct port_info *pi,\n\t\t\tbool rx_en, bool tx_en, bool dcb_en);\nint t4_enable_vi(struct adapter *adap, unsigned int mbox, unsigned int viid,\n\t\t bool rx_en, bool tx_en);\nint t4_identify_port(struct adapter *adap, unsigned int mbox, unsigned int viid,\n\t\t     unsigned int nblinks);\nint t4_mdio_rd(struct adapter *adap, unsigned int mbox, unsigned int phy_addr,\n\t       unsigned int mmd, unsigned int reg, u16 *valp);\nint t4_mdio_wr(struct adapter *adap, unsigned int mbox, unsigned int phy_addr,\n\t       unsigned int mmd, unsigned int reg, u16 val);\nint t4_iq_stop(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t       unsigned int vf, unsigned int iqtype, unsigned int iqid,\n\t       unsigned int fl0id, unsigned int fl1id);\nint t4_iq_free(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t       unsigned int vf, unsigned int iqtype, unsigned int iqid,\n\t       unsigned int fl0id, unsigned int fl1id);\nint t4_eth_eq_free(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\t   unsigned int vf, unsigned int eqid);\nint t4_ctrl_eq_free(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\t    unsigned int vf, unsigned int eqid);\nint t4_ofld_eq_free(struct adapter *adap, unsigned int mbox, unsigned int pf,\n\t\t    unsigned int vf, unsigned int eqid);\nint t4_sge_ctxt_flush(struct adapter *adap, unsigned int mbox, int ctxt_type);\nint t4_read_sge_dbqtimers(struct adapter *adap, unsigned int ndbqtimers,\n\t\t\t  u16 *dbqtimers);\nvoid t4_handle_get_port_info(struct port_info *pi, const __be64 *rpl);\nint t4_update_port_info(struct port_info *pi);\nint t4_get_link_params(struct port_info *pi, unsigned int *link_okp,\n\t\t       unsigned int *speedp, unsigned int *mtup);\nint t4_handle_fw_rpl(struct adapter *adap, const __be64 *rpl);\nvoid t4_db_full(struct adapter *adapter);\nvoid t4_db_dropped(struct adapter *adapter);\nint t4_set_trace_filter(struct adapter *adapter, const struct trace_params *tp,\n\t\t\tint filter_index, int enable);\nvoid t4_get_trace_filter(struct adapter *adapter, struct trace_params *tp,\n\t\t\t int filter_index, int *enabled);\nint t4_fwaddrspace_write(struct adapter *adap, unsigned int mbox,\n\t\t\t u32 addr, u32 val);\nvoid t4_read_pace_tbl(struct adapter *adap, unsigned int pace_vals[NTX_SCHED]);\nvoid t4_get_tx_sched(struct adapter *adap, unsigned int sched,\n\t\t     unsigned int *kbps, unsigned int *ipg, bool sleep_ok);\nint t4_sge_ctxt_rd(struct adapter *adap, unsigned int mbox, unsigned int cid,\n\t\t   enum ctxt_type ctype, u32 *data);\nint t4_sge_ctxt_rd_bd(struct adapter *adap, unsigned int cid,\n\t\t      enum ctxt_type ctype, u32 *data);\nint t4_sched_params(struct adapter *adapter, u8 type, u8 level, u8 mode,\n\t\t    u8 rateunit, u8 ratemode, u8 channel, u8 class,\n\t\t    u32 minrate, u32 maxrate, u16 weight, u16 pktsize,\n\t\t    u16 burstsize);\nvoid t4_sge_decode_idma_state(struct adapter *adapter, int state);\nvoid t4_idma_monitor_init(struct adapter *adapter,\n\t\t\t  struct sge_idma_monitor_state *idma);\nvoid t4_idma_monitor(struct adapter *adapter,\n\t\t     struct sge_idma_monitor_state *idma,\n\t\t     int hz, int ticks);\nint t4_set_vf_mac_acl(struct adapter *adapter, unsigned int vf,\n\t\t      unsigned int naddr, u8 *addr);\nvoid t4_tp_pio_read(struct adapter *adap, u32 *buff, u32 nregs,\n\t\t    u32 start_index, bool sleep_ok);\nvoid t4_tp_tm_pio_read(struct adapter *adap, u32 *buff, u32 nregs,\n\t\t       u32 start_index, bool sleep_ok);\nvoid t4_tp_mib_read(struct adapter *adap, u32 *buff, u32 nregs,\n\t\t    u32 start_index, bool sleep_ok);\n\nvoid t4_uld_mem_free(struct adapter *adap);\nint t4_uld_mem_alloc(struct adapter *adap);\nvoid t4_uld_clean_up(struct adapter *adap);\nvoid t4_register_netevent_notifier(void);\nint t4_i2c_rd(struct adapter *adap, unsigned int mbox, int port,\n\t      unsigned int devid, unsigned int offset,\n\t      unsigned int len, u8 *buf);\nint t4_load_boot(struct adapter *adap, u8 *boot_data,\n\t\t unsigned int boot_addr, unsigned int size);\nint t4_load_bootcfg(struct adapter *adap,\n\t\t    const u8 *cfg_data, unsigned int size);\nvoid free_rspq_fl(struct adapter *adap, struct sge_rspq *rq, struct sge_fl *fl);\nvoid free_tx_desc(struct adapter *adap, struct sge_txq *q,\n\t\t  unsigned int n, bool unmap);\nvoid cxgb4_eosw_txq_free_desc(struct adapter *adap, struct sge_eosw_txq *txq,\n\t\t\t      u32 ndesc);\nint cxgb4_ethofld_send_flowc(struct net_device *dev, u32 eotid, u32 tc);\nvoid cxgb4_ethofld_restart(struct tasklet_struct *t);\nint cxgb4_ethofld_rx_handler(struct sge_rspq *q, const __be64 *rsp,\n\t\t\t     const struct pkt_gl *si);\nvoid free_txq(struct adapter *adap, struct sge_txq *q);\nvoid cxgb4_reclaim_completed_tx(struct adapter *adap,\n\t\t\t\tstruct sge_txq *q, bool unmap);\nint cxgb4_map_skb(struct device *dev, const struct sk_buff *skb,\n\t\t  dma_addr_t *addr);\nvoid cxgb4_inline_tx_skb(const struct sk_buff *skb, const struct sge_txq *q,\n\t\t\t void *pos);\nvoid cxgb4_write_sgl(const struct sk_buff *skb, struct sge_txq *q,\n\t\t     struct ulptx_sgl *sgl, u64 *end, unsigned int start,\n\t\t     const dma_addr_t *addr);\nvoid cxgb4_write_partial_sgl(const struct sk_buff *skb, struct sge_txq *q,\n\t\t\t     struct ulptx_sgl *sgl, u64 *end,\n\t\t\t     const dma_addr_t *addr, u32 start, u32 send_len);\nvoid cxgb4_ring_tx_db(struct adapter *adap, struct sge_txq *q, int n);\nint t4_set_vlan_acl(struct adapter *adap, unsigned int mbox, unsigned int vf,\n\t\t    u16 vlan);\nint cxgb4_dcb_enabled(const struct net_device *dev);\n\nint cxgb4_thermal_init(struct adapter *adap);\nint cxgb4_thermal_remove(struct adapter *adap);\nint cxgb4_set_msix_aff(struct adapter *adap, unsigned short vec,\n\t\t       cpumask_var_t *aff_mask, int idx);\nvoid cxgb4_clear_msix_aff(unsigned short vec, cpumask_var_t aff_mask);\n\nint cxgb4_change_mac(struct port_info *pi, unsigned int viid,\n\t\t     int *tcam_idx, const u8 *addr,\n\t\t     bool persistent, u8 *smt_idx);\n\nint cxgb4_alloc_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\t bool free, unsigned int naddr,\n\t\t\t const u8 **addr, u16 *idx,\n\t\t\t u64 *hash, bool sleep_ok);\nint cxgb4_free_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\tunsigned int naddr, const u8 **addr, bool sleep_ok);\nint cxgb4_init_mps_ref_entries(struct adapter *adap);\nvoid cxgb4_free_mps_ref_entries(struct adapter *adap);\nint cxgb4_alloc_encap_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\t       const u8 *addr, const u8 *mask,\n\t\t\t       unsigned int vni, unsigned int vni_mask,\n\t\t\t       u8 dip_hit, u8 lookup_type, bool sleep_ok);\nint cxgb4_free_encap_mac_filt(struct adapter *adap, unsigned int viid,\n\t\t\t      int idx, bool sleep_ok);\nint cxgb4_free_raw_mac_filt(struct adapter *adap,\n\t\t\t    unsigned int viid,\n\t\t\t    const u8 *addr,\n\t\t\t    const u8 *mask,\n\t\t\t    unsigned int idx,\n\t\t\t    u8 lookup_type,\n\t\t\t    u8 port_id,\n\t\t\t    bool sleep_ok);\nint cxgb4_alloc_raw_mac_filt(struct adapter *adap,\n\t\t\t     unsigned int viid,\n\t\t\t     const u8 *addr,\n\t\t\t     const u8 *mask,\n\t\t\t     unsigned int idx,\n\t\t\t     u8 lookup_type,\n\t\t\t     u8 port_id,\n\t\t\t     bool sleep_ok);\nint cxgb4_update_mac_filt(struct port_info *pi, unsigned int viid,\n\t\t\t  int *tcam_idx, const u8 *addr,\n\t\t\t  bool persistent, u8 *smt_idx);\nint cxgb4_get_msix_idx_from_bmap(struct adapter *adap);\nvoid cxgb4_free_msix_idx_in_bmap(struct adapter *adap, u32 msix_idx);\nvoid cxgb4_enable_rx(struct adapter *adap, struct sge_rspq *q);\nvoid cxgb4_quiesce_rx(struct sge_rspq *q);\nint cxgb4_port_mirror_alloc(struct net_device *dev);\nvoid cxgb4_port_mirror_free(struct net_device *dev);\n#if IS_ENABLED(CONFIG_CHELSIO_TLS_DEVICE)\nint cxgb4_set_ktls_feature(struct adapter *adap, bool enable);\n#endif\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}