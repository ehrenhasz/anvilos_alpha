{
  "module_name": "sched.c",
  "hash_id": "bc4b16681006bebc89b393fcb70de39b9ba6499f2c223fc7c27f9b5b5e98df74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4/sched.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n\n#include \"cxgb4.h\"\n#include \"sched.h\"\n\nstatic int t4_sched_class_fw_cmd(struct port_info *pi,\n\t\t\t\t struct ch_sched_params *p,\n\t\t\t\t enum sched_fw_ops op)\n{\n\tstruct adapter *adap = pi->adapter;\n\tstruct sched_table *s = pi->sched_tbl;\n\tstruct sched_class *e;\n\tint err = 0;\n\n\te = &s->tab[p->u.params.class];\n\tswitch (op) {\n\tcase SCHED_FW_OP_ADD:\n\tcase SCHED_FW_OP_DEL:\n\t\terr = t4_sched_params(adap, p->type,\n\t\t\t\t      p->u.params.level, p->u.params.mode,\n\t\t\t\t      p->u.params.rateunit,\n\t\t\t\t      p->u.params.ratemode,\n\t\t\t\t      p->u.params.channel, e->idx,\n\t\t\t\t      p->u.params.minrate, p->u.params.maxrate,\n\t\t\t\t      p->u.params.weight, p->u.params.pktsize,\n\t\t\t\t      p->u.params.burstsize);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int t4_sched_bind_unbind_op(struct port_info *pi, void *arg,\n\t\t\t\t   enum sched_bind_type type, bool bind)\n{\n\tstruct adapter *adap = pi->adapter;\n\tu32 fw_mnem, fw_class, fw_param;\n\tunsigned int pf = adap->pf;\n\tunsigned int vf = 0;\n\tint err = 0;\n\n\tswitch (type) {\n\tcase SCHED_QUEUE: {\n\t\tstruct sched_queue_entry *qe;\n\n\t\tqe = (struct sched_queue_entry *)arg;\n\n\t\t \n\t\tfw_mnem = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DMAQ) |\n\t\t\t   FW_PARAMS_PARAM_X_V(\n\t\t\t\t   FW_PARAMS_PARAM_DMAQ_EQ_SCHEDCLASS_ETH));\n\t\tfw_class = bind ? qe->param.class : FW_SCHED_CLS_NONE;\n\t\tfw_param = (fw_mnem | FW_PARAMS_PARAM_YZ_V(qe->cntxt_id));\n\n\t\tpf = adap->pf;\n\t\tvf = 0;\n\n\t\terr = t4_set_params(adap, adap->mbox, pf, vf, 1,\n\t\t\t\t    &fw_param, &fw_class);\n\t\tbreak;\n\t}\n\tcase SCHED_FLOWC: {\n\t\tstruct sched_flowc_entry *fe;\n\n\t\tfe = (struct sched_flowc_entry *)arg;\n\n\t\tfw_class = bind ? fe->param.class : FW_SCHED_CLS_NONE;\n\t\terr = cxgb4_ethofld_send_flowc(adap->port[pi->port_id],\n\t\t\t\t\t       fe->param.tid, fw_class);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void *t4_sched_entry_lookup(struct port_info *pi,\n\t\t\t\t   enum sched_bind_type type,\n\t\t\t\t   const u32 val)\n{\n\tstruct sched_table *s = pi->sched_tbl;\n\tstruct sched_class *e, *end;\n\tvoid *found = NULL;\n\n\t \n\tend = &s->tab[s->sched_size];\n\tfor (e = &s->tab[0]; e != end; ++e) {\n\t\tif (e->state == SCHED_STATE_UNUSED ||\n\t\t    e->bind_type != type)\n\t\t\tcontinue;\n\n\t\tswitch (type) {\n\t\tcase SCHED_QUEUE: {\n\t\t\tstruct sched_queue_entry *qe;\n\n\t\t\tlist_for_each_entry(qe, &e->entry_list, list) {\n\t\t\t\tif (qe->cntxt_id == val) {\n\t\t\t\t\tfound = qe;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase SCHED_FLOWC: {\n\t\t\tstruct sched_flowc_entry *fe;\n\n\t\t\tlist_for_each_entry(fe, &e->entry_list, list) {\n\t\t\t\tif (fe->param.tid == val) {\n\t\t\t\t\tfound = fe;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}\n\nstruct sched_class *cxgb4_sched_queue_lookup(struct net_device *dev,\n\t\t\t\t\t     struct ch_sched_queue *p)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct sched_queue_entry *qe = NULL;\n\tstruct adapter *adap = pi->adapter;\n\tstruct sge_eth_txq *txq;\n\n\tif (p->queue < 0 || p->queue >= pi->nqsets)\n\t\treturn NULL;\n\n\ttxq = &adap->sge.ethtxq[pi->first_qset + p->queue];\n\tqe = t4_sched_entry_lookup(pi, SCHED_QUEUE, txq->q.cntxt_id);\n\treturn qe ? &pi->sched_tbl->tab[qe->param.class] : NULL;\n}\n\nstatic int t4_sched_queue_unbind(struct port_info *pi, struct ch_sched_queue *p)\n{\n\tstruct sched_queue_entry *qe = NULL;\n\tstruct adapter *adap = pi->adapter;\n\tstruct sge_eth_txq *txq;\n\tstruct sched_class *e;\n\tint err = 0;\n\n\tif (p->queue < 0 || p->queue >= pi->nqsets)\n\t\treturn -ERANGE;\n\n\ttxq = &adap->sge.ethtxq[pi->first_qset + p->queue];\n\n\t \n\tqe = t4_sched_entry_lookup(pi, SCHED_QUEUE, txq->q.cntxt_id);\n\tif (qe) {\n\t\terr = t4_sched_bind_unbind_op(pi, (void *)qe, SCHED_QUEUE,\n\t\t\t\t\t      false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\te = &pi->sched_tbl->tab[qe->param.class];\n\t\tlist_del(&qe->list);\n\t\tkvfree(qe);\n\t\tif (atomic_dec_and_test(&e->refcnt))\n\t\t\tcxgb4_sched_class_free(adap->port[pi->port_id], e->idx);\n\t}\n\treturn err;\n}\n\nstatic int t4_sched_queue_bind(struct port_info *pi, struct ch_sched_queue *p)\n{\n\tstruct sched_table *s = pi->sched_tbl;\n\tstruct sched_queue_entry *qe = NULL;\n\tstruct adapter *adap = pi->adapter;\n\tstruct sge_eth_txq *txq;\n\tstruct sched_class *e;\n\tunsigned int qid;\n\tint err = 0;\n\n\tif (p->queue < 0 || p->queue >= pi->nqsets)\n\t\treturn -ERANGE;\n\n\tqe = kvzalloc(sizeof(struct sched_queue_entry), GFP_KERNEL);\n\tif (!qe)\n\t\treturn -ENOMEM;\n\n\ttxq = &adap->sge.ethtxq[pi->first_qset + p->queue];\n\tqid = txq->q.cntxt_id;\n\n\t \n\terr = t4_sched_queue_unbind(pi, p);\n\tif (err)\n\t\tgoto out_err;\n\n\t \n\tqe->cntxt_id = qid;\n\tmemcpy(&qe->param, p, sizeof(qe->param));\n\n\te = &s->tab[qe->param.class];\n\terr = t4_sched_bind_unbind_op(pi, (void *)qe, SCHED_QUEUE, true);\n\tif (err)\n\t\tgoto out_err;\n\n\tlist_add_tail(&qe->list, &e->entry_list);\n\te->bind_type = SCHED_QUEUE;\n\tatomic_inc(&e->refcnt);\n\treturn err;\n\nout_err:\n\tkvfree(qe);\n\treturn err;\n}\n\nstatic int t4_sched_flowc_unbind(struct port_info *pi, struct ch_sched_flowc *p)\n{\n\tstruct sched_flowc_entry *fe = NULL;\n\tstruct adapter *adap = pi->adapter;\n\tstruct sched_class *e;\n\tint err = 0;\n\n\tif (p->tid < 0 || p->tid >= adap->tids.neotids)\n\t\treturn -ERANGE;\n\n\t \n\tfe = t4_sched_entry_lookup(pi, SCHED_FLOWC, p->tid);\n\tif (fe) {\n\t\terr = t4_sched_bind_unbind_op(pi, (void *)fe, SCHED_FLOWC,\n\t\t\t\t\t      false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\te = &pi->sched_tbl->tab[fe->param.class];\n\t\tlist_del(&fe->list);\n\t\tkvfree(fe);\n\t\tif (atomic_dec_and_test(&e->refcnt))\n\t\t\tcxgb4_sched_class_free(adap->port[pi->port_id], e->idx);\n\t}\n\treturn err;\n}\n\nstatic int t4_sched_flowc_bind(struct port_info *pi, struct ch_sched_flowc *p)\n{\n\tstruct sched_table *s = pi->sched_tbl;\n\tstruct sched_flowc_entry *fe = NULL;\n\tstruct adapter *adap = pi->adapter;\n\tstruct sched_class *e;\n\tint err = 0;\n\n\tif (p->tid < 0 || p->tid >= adap->tids.neotids)\n\t\treturn -ERANGE;\n\n\tfe = kvzalloc(sizeof(*fe), GFP_KERNEL);\n\tif (!fe)\n\t\treturn -ENOMEM;\n\n\t \n\terr = t4_sched_flowc_unbind(pi, p);\n\tif (err)\n\t\tgoto out_err;\n\n\t \n\tmemcpy(&fe->param, p, sizeof(fe->param));\n\n\te = &s->tab[fe->param.class];\n\terr = t4_sched_bind_unbind_op(pi, (void *)fe, SCHED_FLOWC, true);\n\tif (err)\n\t\tgoto out_err;\n\n\tlist_add_tail(&fe->list, &e->entry_list);\n\te->bind_type = SCHED_FLOWC;\n\tatomic_inc(&e->refcnt);\n\treturn err;\n\nout_err:\n\tkvfree(fe);\n\treturn err;\n}\n\nstatic void t4_sched_class_unbind_all(struct port_info *pi,\n\t\t\t\t      struct sched_class *e,\n\t\t\t\t      enum sched_bind_type type)\n{\n\tif (!e)\n\t\treturn;\n\n\tswitch (type) {\n\tcase SCHED_QUEUE: {\n\t\tstruct sched_queue_entry *qe;\n\n\t\tlist_for_each_entry(qe, &e->entry_list, list)\n\t\t\tt4_sched_queue_unbind(pi, &qe->param);\n\t\tbreak;\n\t}\n\tcase SCHED_FLOWC: {\n\t\tstruct sched_flowc_entry *fe;\n\n\t\tlist_for_each_entry(fe, &e->entry_list, list)\n\t\t\tt4_sched_flowc_unbind(pi, &fe->param);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int t4_sched_class_bind_unbind_op(struct port_info *pi, void *arg,\n\t\t\t\t\t enum sched_bind_type type, bool bind)\n{\n\tint err = 0;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase SCHED_QUEUE: {\n\t\tstruct ch_sched_queue *qe = (struct ch_sched_queue *)arg;\n\n\t\tif (bind)\n\t\t\terr = t4_sched_queue_bind(pi, qe);\n\t\telse\n\t\t\terr = t4_sched_queue_unbind(pi, qe);\n\t\tbreak;\n\t}\n\tcase SCHED_FLOWC: {\n\t\tstruct ch_sched_flowc *fe = (struct ch_sched_flowc *)arg;\n\n\t\tif (bind)\n\t\t\terr = t4_sched_flowc_bind(pi, fe);\n\t\telse\n\t\t\terr = t4_sched_flowc_unbind(pi, fe);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nint cxgb4_sched_class_bind(struct net_device *dev, void *arg,\n\t\t\t   enum sched_bind_type type)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tu8 class_id;\n\n\tif (!can_sched(dev))\n\t\treturn -ENOTSUPP;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase SCHED_QUEUE: {\n\t\tstruct ch_sched_queue *qe = (struct ch_sched_queue *)arg;\n\n\t\tclass_id = qe->class;\n\t\tbreak;\n\t}\n\tcase SCHED_FLOWC: {\n\t\tstruct ch_sched_flowc *fe = (struct ch_sched_flowc *)arg;\n\n\t\tclass_id = fe->class;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!valid_class_id(dev, class_id))\n\t\treturn -EINVAL;\n\n\tif (class_id == SCHED_CLS_NONE)\n\t\treturn -ENOTSUPP;\n\n\treturn t4_sched_class_bind_unbind_op(pi, arg, type, true);\n\n}\n\n \nint cxgb4_sched_class_unbind(struct net_device *dev, void *arg,\n\t\t\t     enum sched_bind_type type)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tu8 class_id;\n\n\tif (!can_sched(dev))\n\t\treturn -ENOTSUPP;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase SCHED_QUEUE: {\n\t\tstruct ch_sched_queue *qe = (struct ch_sched_queue *)arg;\n\n\t\tclass_id = qe->class;\n\t\tbreak;\n\t}\n\tcase SCHED_FLOWC: {\n\t\tstruct ch_sched_flowc *fe = (struct ch_sched_flowc *)arg;\n\n\t\tclass_id = fe->class;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!valid_class_id(dev, class_id))\n\t\treturn -EINVAL;\n\n\treturn t4_sched_class_bind_unbind_op(pi, arg, type, false);\n}\n\n \nstatic struct sched_class *t4_sched_class_lookup(struct port_info *pi,\n\t\t\t\t\t\tconst struct ch_sched_params *p)\n{\n\tstruct sched_table *s = pi->sched_tbl;\n\tstruct sched_class *found = NULL;\n\tstruct sched_class *e, *end;\n\n\tif (!p) {\n\t\t \n\t\tend = &s->tab[s->sched_size];\n\t\tfor (e = &s->tab[0]; e != end; ++e) {\n\t\t\tif (e->state == SCHED_STATE_UNUSED) {\n\t\t\t\tfound = e;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tstruct ch_sched_params info;\n\t\tstruct ch_sched_params tp;\n\n\t\tmemcpy(&tp, p, sizeof(tp));\n\t\t \n\t\ttp.u.params.class = SCHED_CLS_NONE;\n\n\t\tend = &s->tab[s->sched_size];\n\t\tfor (e = &s->tab[0]; e != end; ++e) {\n\t\t\tif (e->state == SCHED_STATE_UNUSED)\n\t\t\t\tcontinue;\n\n\t\t\tmemcpy(&info, &e->info, sizeof(info));\n\t\t\t \n\t\t\tinfo.u.params.class = SCHED_CLS_NONE;\n\n\t\t\tif ((info.type == tp.type) &&\n\t\t\t    (!memcmp(&info.u.params, &tp.u.params,\n\t\t\t\t     sizeof(info.u.params)))) {\n\t\t\t\tfound = e;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic struct sched_class *t4_sched_class_alloc(struct port_info *pi,\n\t\t\t\t\t\tstruct ch_sched_params *p)\n{\n\tstruct sched_class *e = NULL;\n\tu8 class_id;\n\tint err;\n\n\tif (!p)\n\t\treturn NULL;\n\n\tclass_id = p->u.params.class;\n\n\t \n\tif (class_id != SCHED_CLS_NONE)\n\t\treturn NULL;\n\n\t \n\tif (p->u.params.mode == SCHED_CLASS_MODE_FLOW)\n\t\te = t4_sched_class_lookup(pi, p);\n\n\tif (!e) {\n\t\tstruct ch_sched_params np;\n\n\t\t \n\t\te = t4_sched_class_lookup(pi, NULL);\n\t\tif (!e)\n\t\t\treturn NULL;\n\n\t\tmemcpy(&np, p, sizeof(np));\n\t\tnp.u.params.class = e->idx;\n\t\t \n\t\terr = t4_sched_class_fw_cmd(pi, &np, SCHED_FW_OP_ADD);\n\t\tif (err)\n\t\t\treturn NULL;\n\t\tmemcpy(&e->info, &np, sizeof(e->info));\n\t\tatomic_set(&e->refcnt, 0);\n\t\te->state = SCHED_STATE_ACTIVE;\n\t}\n\n\treturn e;\n}\n\n \nstruct sched_class *cxgb4_sched_class_alloc(struct net_device *dev,\n\t\t\t\t\t    struct ch_sched_params *p)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tu8 class_id;\n\n\tif (!can_sched(dev))\n\t\treturn NULL;\n\n\tclass_id = p->u.params.class;\n\tif (!valid_class_id(dev, class_id))\n\t\treturn NULL;\n\n\treturn t4_sched_class_alloc(pi, p);\n}\n\n \nvoid cxgb4_sched_class_free(struct net_device *dev, u8 classid)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct sched_table *s = pi->sched_tbl;\n\tstruct ch_sched_params p;\n\tstruct sched_class *e;\n\tu32 speed;\n\tint ret;\n\n\te = &s->tab[classid];\n\tif (!atomic_read(&e->refcnt) && e->state != SCHED_STATE_UNUSED) {\n\t\t \n\t\tmemcpy(&p, &e->info, sizeof(p));\n\t\t \n\t\tp.u.params.mode = 0;\n\t\tp.u.params.minrate = 0;\n\t\tp.u.params.pktsize = 0;\n\n\t\tret = t4_get_link_params(pi, NULL, &speed, NULL);\n\t\tif (!ret)\n\t\t\tp.u.params.maxrate = speed * 1000;  \n\t\telse\n\t\t\tp.u.params.maxrate = SCHED_MAX_RATE_KBPS;\n\n\t\tt4_sched_class_fw_cmd(pi, &p, SCHED_FW_OP_DEL);\n\n\t\te->state = SCHED_STATE_UNUSED;\n\t\tmemset(&e->info, 0, sizeof(e->info));\n\t}\n}\n\nstatic void t4_sched_class_free(struct net_device *dev, struct sched_class *e)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\n\tt4_sched_class_unbind_all(pi, e, e->bind_type);\n\tcxgb4_sched_class_free(dev, e->idx);\n}\n\nstruct sched_table *t4_init_sched(unsigned int sched_size)\n{\n\tstruct sched_table *s;\n\tunsigned int i;\n\n\ts = kvzalloc(struct_size(s, tab, sched_size), GFP_KERNEL);\n\tif (!s)\n\t\treturn NULL;\n\n\ts->sched_size = sched_size;\n\n\tfor (i = 0; i < s->sched_size; i++) {\n\t\tmemset(&s->tab[i], 0, sizeof(struct sched_class));\n\t\ts->tab[i].idx = i;\n\t\ts->tab[i].state = SCHED_STATE_UNUSED;\n\t\tINIT_LIST_HEAD(&s->tab[i].entry_list);\n\t\tatomic_set(&s->tab[i].refcnt, 0);\n\t}\n\treturn s;\n}\n\nvoid t4_cleanup_sched(struct adapter *adap)\n{\n\tstruct sched_table *s;\n\tunsigned int j, i;\n\n\tfor_each_port(adap, j) {\n\t\tstruct port_info *pi = netdev2pinfo(adap->port[j]);\n\n\t\ts = pi->sched_tbl;\n\t\tif (!s)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < s->sched_size; i++) {\n\t\t\tstruct sched_class *e;\n\n\t\t\te = &s->tab[i];\n\t\t\tif (e->state == SCHED_STATE_ACTIVE)\n\t\t\t\tt4_sched_class_free(adap->port[j], e);\n\t\t}\n\t\tkvfree(s);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}