{
  "module_name": "xgmac.c",
  "hash_id": "2d3363b1bfd3091c76e74f6778ebecb8ee597e021a4b6c4e7d2ae273188bd977",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb3/xgmac.c",
  "human_readable_source": " \n#include \"common.h\"\n#include \"regs.h\"\n\n \n#define EXACT_ADDR_FILTERS 8\n\nstatic inline int macidx(const struct cmac *mac)\n{\n\treturn mac->offset / (XGMAC0_1_BASE_ADDR - XGMAC0_0_BASE_ADDR);\n}\n\nstatic void xaui_serdes_reset(struct cmac *mac)\n{\n\tstatic const unsigned int clear[] = {\n\t\tF_PWRDN0 | F_PWRDN1, F_RESETPLL01, F_RESET0 | F_RESET1,\n\t\tF_PWRDN2 | F_PWRDN3, F_RESETPLL23, F_RESET2 | F_RESET3\n\t};\n\n\tint i;\n\tstruct adapter *adap = mac->adapter;\n\tu32 ctrl = A_XGM_SERDES_CTRL0 + mac->offset;\n\n\tt3_write_reg(adap, ctrl, adap->params.vpd.xauicfg[macidx(mac)] |\n\t\t     F_RESET3 | F_RESET2 | F_RESET1 | F_RESET0 |\n\t\t     F_PWRDN3 | F_PWRDN2 | F_PWRDN1 | F_PWRDN0 |\n\t\t     F_RESETPLL23 | F_RESETPLL01);\n\tt3_read_reg(adap, ctrl);\n\tudelay(15);\n\n\tfor (i = 0; i < ARRAY_SIZE(clear); i++) {\n\t\tt3_set_reg_field(adap, ctrl, clear[i], 0);\n\t\tudelay(15);\n\t}\n}\n\nvoid t3b_pcs_reset(struct cmac *mac)\n{\n\tt3_set_reg_field(mac->adapter, A_XGM_RESET_CTRL + mac->offset,\n\t\t\t F_PCS_RESET_, 0);\n\tudelay(20);\n\tt3_set_reg_field(mac->adapter, A_XGM_RESET_CTRL + mac->offset, 0,\n\t\t\t F_PCS_RESET_);\n}\n\nint t3_mac_reset(struct cmac *mac)\n{\n\tstatic const struct addr_val_pair mac_reset_avp[] = {\n\t\t{A_XGM_TX_CTRL, 0},\n\t\t{A_XGM_RX_CTRL, 0},\n\t\t{A_XGM_RX_CFG, F_DISPAUSEFRAMES | F_EN1536BFRAMES |\n\t\t F_RMFCS | F_ENJUMBO | F_ENHASHMCAST},\n\t\t{A_XGM_RX_HASH_LOW, 0},\n\t\t{A_XGM_RX_HASH_HIGH, 0},\n\t\t{A_XGM_RX_EXACT_MATCH_LOW_1, 0},\n\t\t{A_XGM_RX_EXACT_MATCH_LOW_2, 0},\n\t\t{A_XGM_RX_EXACT_MATCH_LOW_3, 0},\n\t\t{A_XGM_RX_EXACT_MATCH_LOW_4, 0},\n\t\t{A_XGM_RX_EXACT_MATCH_LOW_5, 0},\n\t\t{A_XGM_RX_EXACT_MATCH_LOW_6, 0},\n\t\t{A_XGM_RX_EXACT_MATCH_LOW_7, 0},\n\t\t{A_XGM_RX_EXACT_MATCH_LOW_8, 0},\n\t\t{A_XGM_STAT_CTRL, F_CLRSTATS}\n\t};\n\tu32 val;\n\tstruct adapter *adap = mac->adapter;\n\tunsigned int oft = mac->offset;\n\n\tt3_write_reg(adap, A_XGM_RESET_CTRL + oft, F_MAC_RESET_);\n\tt3_read_reg(adap, A_XGM_RESET_CTRL + oft);\t \n\n\tt3_write_regs(adap, mac_reset_avp, ARRAY_SIZE(mac_reset_avp), oft);\n\tt3_set_reg_field(adap, A_XGM_RXFIFO_CFG + oft,\n\t\t\t F_RXSTRFRWRD | F_DISERRFRAMES,\n\t\t\t uses_xaui(adap) ? 0 : F_RXSTRFRWRD);\n\tt3_set_reg_field(adap, A_XGM_TXFIFO_CFG + oft, 0, F_UNDERUNFIX);\n\n\tif (uses_xaui(adap)) {\n\t\tif (adap->params.rev == 0) {\n\t\t\tt3_set_reg_field(adap, A_XGM_SERDES_CTRL + oft, 0,\n\t\t\t\t\t F_RXENABLE | F_TXENABLE);\n\t\t\tif (t3_wait_op_done(adap, A_XGM_SERDES_STATUS1 + oft,\n\t\t\t\t\t    F_CMULOCK, 1, 5, 2)) {\n\t\t\t\tCH_ERR(adap,\n\t\t\t\t       \"MAC %d XAUI SERDES CMU lock failed\\n\",\n\t\t\t\t       macidx(mac));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tt3_set_reg_field(adap, A_XGM_SERDES_CTRL + oft, 0,\n\t\t\t\t\t F_SERDESRESET_);\n\t\t} else\n\t\t\txaui_serdes_reset(mac);\n\t}\n\n\tt3_set_reg_field(adap, A_XGM_RX_MAX_PKT_SIZE + oft,\n\t\t\t V_RXMAXFRAMERSIZE(M_RXMAXFRAMERSIZE),\n\t\t\t V_RXMAXFRAMERSIZE(MAX_FRAME_SIZE) | F_RXENFRAMER);\n\tval = F_MAC_RESET_ | F_XGMAC_STOP_EN;\n\n\tif (is_10G(adap))\n\t\tval |= F_PCS_RESET_;\n\telse if (uses_xaui(adap))\n\t\tval |= F_PCS_RESET_ | F_XG2G_RESET_;\n\telse\n\t\tval |= F_RGMII_RESET_ | F_XG2G_RESET_;\n\tt3_write_reg(adap, A_XGM_RESET_CTRL + oft, val);\n\tt3_read_reg(adap, A_XGM_RESET_CTRL + oft);\t \n\tif ((val & F_PCS_RESET_) && adap->params.rev) {\n\t\tmsleep(1);\n\t\tt3b_pcs_reset(mac);\n\t}\n\n\tmemset(&mac->stats, 0, sizeof(mac->stats));\n\treturn 0;\n}\n\nstatic int t3b2_mac_reset(struct cmac *mac)\n{\n\tstruct adapter *adap = mac->adapter;\n\tunsigned int oft = mac->offset, store;\n\tint idx = macidx(mac);\n\tu32 val;\n\n\tif (!macidx(mac))\n\t\tt3_set_reg_field(adap, A_MPS_CFG, F_PORT0ACTIVE, 0);\n\telse\n\t\tt3_set_reg_field(adap, A_MPS_CFG, F_PORT1ACTIVE, 0);\n\n\t \n\tt3_set_reg_field(adap, A_MPS_CFG, F_ENFORCEPKT, 0);\n\t \n\tt3_set_reg_field(adap, A_XGM_TX_CFG + oft, F_TXPAUSEEN, 0);\n\n\tt3_write_reg(adap, A_XGM_RESET_CTRL + oft, F_MAC_RESET_);\n\tt3_read_reg(adap, A_XGM_RESET_CTRL + oft);     \n\n\t \n\tt3_write_reg(adap, A_TP_PIO_ADDR, A_TP_TX_DROP_CFG_CH0 + idx);\n\tstore = t3_read_reg(adap, A_TP_TX_DROP_CFG_CH0 + idx);\n\n\tmsleep(10);\n\n\t \n\tt3_write_reg(adap, A_TP_PIO_ADDR, A_TP_TX_DROP_CFG_CH0 + idx);\n\tt3_write_reg(adap, A_TP_PIO_DATA, 0xc0000011);\n\n\t \n\t \n\tif (t3_wait_op_done(adap, A_XGM_RX_MAX_PKT_SIZE_ERR_CNT + oft,\n\t\t\t    0x80000000, 1, 1000, 2)) {\n\t\tCH_ERR(adap, \"MAC %d Rx fifo drain failed\\n\",\n\t\t       macidx(mac));\n\t\treturn -1;\n\t}\n\n\tt3_write_reg(adap, A_XGM_RESET_CTRL + oft, 0);\n\tt3_read_reg(adap, A_XGM_RESET_CTRL + oft);     \n\n\tval = F_MAC_RESET_;\n\tif (is_10G(adap))\n\t\tval |= F_PCS_RESET_;\n\telse if (uses_xaui(adap))\n\t\tval |= F_PCS_RESET_ | F_XG2G_RESET_;\n\telse\n\t\tval |= F_RGMII_RESET_ | F_XG2G_RESET_;\n\tt3_write_reg(adap, A_XGM_RESET_CTRL + oft, val);\n\tt3_read_reg(adap, A_XGM_RESET_CTRL + oft);   \n\tif ((val & F_PCS_RESET_) && adap->params.rev) {\n\t\tmsleep(1);\n\t\tt3b_pcs_reset(mac);\n\t}\n\tt3_write_reg(adap, A_XGM_RX_CFG + oft,\n\t\t     F_DISPAUSEFRAMES | F_EN1536BFRAMES |\n\t\t     F_RMFCS | F_ENJUMBO | F_ENHASHMCAST);\n\n\t \n\tt3_write_reg(adap, A_TP_PIO_ADDR, A_TP_TX_DROP_CFG_CH0 + idx);\n\tt3_write_reg(adap, A_TP_PIO_DATA, store);\n\n\tif (!idx)\n\t\tt3_set_reg_field(adap, A_MPS_CFG, 0, F_PORT0ACTIVE);\n\telse\n\t\tt3_set_reg_field(adap, A_MPS_CFG, 0, F_PORT1ACTIVE);\n\n\t \n\tt3_set_reg_field(adap, A_MPS_CFG, F_ENFORCEPKT, 1);\n\n\t \n\tt3_set_reg_field(adap, A_MPS_CFG, F_ENFORCEPKT, 1);\n\n\treturn 0;\n}\n\n \nstatic void set_addr_filter(struct cmac *mac, int idx, const u8 * addr)\n{\n\tu32 addr_lo, addr_hi;\n\tunsigned int oft = mac->offset + idx * 8;\n\n\taddr_lo = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) | addr[0];\n\taddr_hi = (addr[5] << 8) | addr[4];\n\n\tt3_write_reg(mac->adapter, A_XGM_RX_EXACT_MATCH_LOW_1 + oft, addr_lo);\n\tt3_write_reg(mac->adapter, A_XGM_RX_EXACT_MATCH_HIGH_1 + oft, addr_hi);\n}\n\n \nint t3_mac_set_address(struct cmac *mac, unsigned int idx, const u8 addr[6])\n{\n\tif (idx >= mac->nucast)\n\t\treturn -EINVAL;\n\tset_addr_filter(mac, idx, addr);\n\treturn 0;\n}\n\n \nint t3_mac_set_num_ucast(struct cmac *mac, int n)\n{\n\tif (n > EXACT_ADDR_FILTERS)\n\t\treturn -EINVAL;\n\tmac->nucast = n;\n\treturn 0;\n}\n\nvoid t3_mac_disable_exact_filters(struct cmac *mac)\n{\n\tunsigned int i, reg = mac->offset + A_XGM_RX_EXACT_MATCH_LOW_1;\n\n\tfor (i = 0; i < EXACT_ADDR_FILTERS; i++, reg += 8) {\n\t\tu32 v = t3_read_reg(mac->adapter, reg);\n\t\tt3_write_reg(mac->adapter, reg, v);\n\t}\n\tt3_read_reg(mac->adapter, A_XGM_RX_EXACT_MATCH_LOW_1);\t \n}\n\nvoid t3_mac_enable_exact_filters(struct cmac *mac)\n{\n\tunsigned int i, reg = mac->offset + A_XGM_RX_EXACT_MATCH_HIGH_1;\n\n\tfor (i = 0; i < EXACT_ADDR_FILTERS; i++, reg += 8) {\n\t\tu32 v = t3_read_reg(mac->adapter, reg);\n\t\tt3_write_reg(mac->adapter, reg, v);\n\t}\n\tt3_read_reg(mac->adapter, A_XGM_RX_EXACT_MATCH_LOW_1);\t \n}\n\n \nstatic int hash_hw_addr(const u8 * addr)\n{\n\tint hash = 0, octet, bit, i = 0, c;\n\n\tfor (octet = 0; octet < 6; ++octet)\n\t\tfor (c = addr[octet], bit = 0; bit < 8; c >>= 1, ++bit) {\n\t\t\thash ^= (c & 1) << i;\n\t\t\tif (++i == 6)\n\t\t\t\ti = 0;\n\t\t}\n\treturn hash;\n}\n\nint t3_mac_set_rx_mode(struct cmac *mac, struct net_device *dev)\n{\n\tu32 val, hash_lo, hash_hi;\n\tstruct adapter *adap = mac->adapter;\n\tunsigned int oft = mac->offset;\n\n\tval = t3_read_reg(adap, A_XGM_RX_CFG + oft) & ~F_COPYALLFRAMES;\n\tif (dev->flags & IFF_PROMISC)\n\t\tval |= F_COPYALLFRAMES;\n\tt3_write_reg(adap, A_XGM_RX_CFG + oft, val);\n\n\tif (dev->flags & IFF_ALLMULTI)\n\t\thash_lo = hash_hi = 0xffffffff;\n\telse {\n\t\tstruct netdev_hw_addr *ha;\n\t\tint exact_addr_idx = mac->nucast;\n\n\t\thash_lo = hash_hi = 0;\n\t\tnetdev_for_each_mc_addr(ha, dev)\n\t\t\tif (exact_addr_idx < EXACT_ADDR_FILTERS)\n\t\t\t\tset_addr_filter(mac, exact_addr_idx++,\n\t\t\t\t\t\tha->addr);\n\t\t\telse {\n\t\t\t\tint hash = hash_hw_addr(ha->addr);\n\n\t\t\t\tif (hash < 32)\n\t\t\t\t\thash_lo |= (1 << hash);\n\t\t\t\telse\n\t\t\t\t\thash_hi |= (1 << (hash - 32));\n\t\t\t}\n\t}\n\n\tt3_write_reg(adap, A_XGM_RX_HASH_LOW + oft, hash_lo);\n\tt3_write_reg(adap, A_XGM_RX_HASH_HIGH + oft, hash_hi);\n\treturn 0;\n}\n\nstatic int rx_fifo_hwm(int mtu)\n{\n\tint hwm;\n\n\thwm = max(MAC_RXFIFO_SIZE - 3 * mtu, (MAC_RXFIFO_SIZE * 38) / 100);\n\treturn min(hwm, MAC_RXFIFO_SIZE - 8192);\n}\n\nint t3_mac_set_mtu(struct cmac *mac, unsigned int mtu)\n{\n\tint hwm, lwm, divisor;\n\tint ipg;\n\tunsigned int thres, v, reg;\n\tstruct adapter *adap = mac->adapter;\n\n\t \n\tmtu += 14;\n\tif (mtu > 1536)\n\t\tmtu += 4;\n\n\tif (mtu > MAX_FRAME_SIZE - 4)\n\t\treturn -EINVAL;\n\tt3_write_reg(adap, A_XGM_RX_MAX_PKT_SIZE + mac->offset, mtu);\n\n\tif (adap->params.rev >= T3_REV_B2 &&\n\t    (t3_read_reg(adap, A_XGM_RX_CTRL + mac->offset) & F_RXEN)) {\n\t\tt3_mac_disable_exact_filters(mac);\n\t\tv = t3_read_reg(adap, A_XGM_RX_CFG + mac->offset);\n\t\tt3_set_reg_field(adap, A_XGM_RX_CFG + mac->offset,\n\t\t\t\t F_ENHASHMCAST | F_COPYALLFRAMES, F_DISBCAST);\n\n\t\treg = adap->params.rev == T3_REV_B2 ?\n\t\t\tA_XGM_RX_MAX_PKT_SIZE_ERR_CNT : A_XGM_RXFIFO_CFG;\n\n\t\t \n\t\tif (t3_wait_op_done(adap, reg + mac->offset,\n\t\t\t\t    F_RXFIFO_EMPTY, 1, 20, 5)) {\n\t\t\tt3_write_reg(adap, A_XGM_RX_CFG + mac->offset, v);\n\t\t\tt3_mac_enable_exact_filters(mac);\n\t\t\treturn -EIO;\n\t\t}\n\t\tt3_set_reg_field(adap, A_XGM_RX_MAX_PKT_SIZE + mac->offset,\n\t\t\t\t V_RXMAXPKTSIZE(M_RXMAXPKTSIZE),\n\t\t\t\t V_RXMAXPKTSIZE(mtu));\n\t\tt3_write_reg(adap, A_XGM_RX_CFG + mac->offset, v);\n\t\tt3_mac_enable_exact_filters(mac);\n\t} else\n\t\tt3_set_reg_field(adap, A_XGM_RX_MAX_PKT_SIZE + mac->offset,\n\t\t\t\t V_RXMAXPKTSIZE(M_RXMAXPKTSIZE),\n\t\t\t\t V_RXMAXPKTSIZE(mtu));\n\n\t \n\thwm = rx_fifo_hwm(mtu);\n\tlwm = min(3 * (int)mtu, MAC_RXFIFO_SIZE / 4);\n\tv = t3_read_reg(adap, A_XGM_RXFIFO_CFG + mac->offset);\n\tv &= ~V_RXFIFOPAUSELWM(M_RXFIFOPAUSELWM);\n\tv |= V_RXFIFOPAUSELWM(lwm / 8);\n\tif (G_RXFIFOPAUSEHWM(v))\n\t\tv = (v & ~V_RXFIFOPAUSEHWM(M_RXFIFOPAUSEHWM)) |\n\t\t    V_RXFIFOPAUSEHWM(hwm / 8);\n\n\tt3_write_reg(adap, A_XGM_RXFIFO_CFG + mac->offset, v);\n\n\t \n\tthres = (adap->params.vpd.cclk * 1000) / 15625;\n\tthres = (thres * mtu) / 1000;\n\tif (is_10G(adap))\n\t\tthres /= 10;\n\tthres = mtu > thres ? (mtu - thres + 7) / 8 : 0;\n\tthres = max(thres, 8U);\t \n\tipg = (adap->params.rev == T3_REV_C) ? 0 : 1;\n\tt3_set_reg_field(adap, A_XGM_TXFIFO_CFG + mac->offset,\n\t\t\t V_TXFIFOTHRESH(M_TXFIFOTHRESH) | V_TXIPG(M_TXIPG),\n\t\t\t V_TXFIFOTHRESH(thres) | V_TXIPG(ipg));\n\n\tif (adap->params.rev > 0) {\n\t\tdivisor = (adap->params.rev == T3_REV_C) ? 64 : 8;\n\t\tt3_write_reg(adap, A_XGM_PAUSE_TIMER + mac->offset,\n\t\t\t     (hwm - lwm) * 4 / divisor);\n\t}\n\tt3_write_reg(adap, A_XGM_TX_PAUSE_QUANTA + mac->offset,\n\t\t     MAC_RXFIFO_SIZE * 4 * 8 / 512);\n\treturn 0;\n}\n\nint t3_mac_set_speed_duplex_fc(struct cmac *mac, int speed, int duplex, int fc)\n{\n\tu32 val;\n\tstruct adapter *adap = mac->adapter;\n\tunsigned int oft = mac->offset;\n\n\tif (duplex >= 0 && duplex != DUPLEX_FULL)\n\t\treturn -EINVAL;\n\tif (speed >= 0) {\n\t\tif (speed == SPEED_10)\n\t\t\tval = V_PORTSPEED(0);\n\t\telse if (speed == SPEED_100)\n\t\t\tval = V_PORTSPEED(1);\n\t\telse if (speed == SPEED_1000)\n\t\t\tval = V_PORTSPEED(2);\n\t\telse if (speed == SPEED_10000)\n\t\t\tval = V_PORTSPEED(3);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tt3_set_reg_field(adap, A_XGM_PORT_CFG + oft,\n\t\t\t\t V_PORTSPEED(M_PORTSPEED), val);\n\t}\n\n\tval = t3_read_reg(adap, A_XGM_RXFIFO_CFG + oft);\n\tval &= ~V_RXFIFOPAUSEHWM(M_RXFIFOPAUSEHWM);\n\tif (fc & PAUSE_TX) {\n\t\tu32 rx_max_pkt_size =\n\t\t    G_RXMAXPKTSIZE(t3_read_reg(adap,\n\t\t\t\t\t       A_XGM_RX_MAX_PKT_SIZE + oft));\n\t\tval |= V_RXFIFOPAUSEHWM(rx_fifo_hwm(rx_max_pkt_size) / 8);\n\t}\n\tt3_write_reg(adap, A_XGM_RXFIFO_CFG + oft, val);\n\n\tt3_set_reg_field(adap, A_XGM_TX_CFG + oft, F_TXPAUSEEN,\n\t\t\t (fc & PAUSE_RX) ? F_TXPAUSEEN : 0);\n\treturn 0;\n}\n\nint t3_mac_enable(struct cmac *mac, int which)\n{\n\tint idx = macidx(mac);\n\tstruct adapter *adap = mac->adapter;\n\tunsigned int oft = mac->offset;\n\tstruct mac_stats *s = &mac->stats;\n\n\tif (which & MAC_DIRECTION_TX) {\n\t\tt3_write_reg(adap, A_TP_PIO_ADDR, A_TP_TX_DROP_CFG_CH0 + idx);\n\t\tt3_write_reg(adap, A_TP_PIO_DATA,\n\t\t\t     adap->params.rev == T3_REV_C ?\n\t\t\t     0xc4ffff01 : 0xc0ede401);\n\t\tt3_write_reg(adap, A_TP_PIO_ADDR, A_TP_TX_DROP_MODE);\n\t\tt3_set_reg_field(adap, A_TP_PIO_DATA, 1 << idx,\n\t\t\t\t adap->params.rev == T3_REV_C ? 0 : 1 << idx);\n\n\t\tt3_write_reg(adap, A_XGM_TX_CTRL + oft, F_TXEN);\n\n\t\tt3_write_reg(adap, A_TP_PIO_ADDR, A_TP_TX_DROP_CNT_CH0 + idx);\n\t\tmac->tx_mcnt = s->tx_frames;\n\t\tmac->tx_tcnt = (G_TXDROPCNTCH0RCVD(t3_read_reg(adap,\n\t\t\t\t\t\t\tA_TP_PIO_DATA)));\n\t\tmac->tx_xcnt = (G_TXSPI4SOPCNT(t3_read_reg(adap,\n\t\t\t\t\t\tA_XGM_TX_SPI4_SOP_EOP_CNT +\n\t\t\t\t\t\toft)));\n\t\tmac->rx_mcnt = s->rx_frames;\n\t\tmac->rx_pause = s->rx_pause;\n\t\tmac->rx_xcnt = (G_TXSPI4SOPCNT(t3_read_reg(adap,\n\t\t\t\t\t\tA_XGM_RX_SPI4_SOP_EOP_CNT +\n\t\t\t\t\t\toft)));\n\t\tmac->rx_ocnt = s->rx_fifo_ovfl;\n\t\tmac->txen = F_TXEN;\n\t\tmac->toggle_cnt = 0;\n\t}\n\tif (which & MAC_DIRECTION_RX)\n\t\tt3_write_reg(adap, A_XGM_RX_CTRL + oft, F_RXEN);\n\treturn 0;\n}\n\nint t3_mac_disable(struct cmac *mac, int which)\n{\n\tstruct adapter *adap = mac->adapter;\n\n\tif (which & MAC_DIRECTION_TX) {\n\t\tt3_write_reg(adap, A_XGM_TX_CTRL + mac->offset, 0);\n\t\tmac->txen = 0;\n\t}\n\tif (which & MAC_DIRECTION_RX) {\n\t\tint val = F_MAC_RESET_;\n\n\t\tt3_set_reg_field(mac->adapter, A_XGM_RESET_CTRL + mac->offset,\n\t\t\t\t F_PCS_RESET_, 0);\n\t\tmsleep(100);\n\t\tt3_write_reg(adap, A_XGM_RX_CTRL + mac->offset, 0);\n\t\tif (is_10G(adap))\n\t\t\tval |= F_PCS_RESET_;\n\t\telse if (uses_xaui(adap))\n\t\t\tval |= F_PCS_RESET_ | F_XG2G_RESET_;\n\t\telse\n\t\t\tval |= F_RGMII_RESET_ | F_XG2G_RESET_;\n\t\tt3_write_reg(mac->adapter, A_XGM_RESET_CTRL + mac->offset, val);\n\t}\n\treturn 0;\n}\n\nint t3b2_mac_watchdog_task(struct cmac *mac)\n{\n\tstruct adapter *adap = mac->adapter;\n\tstruct mac_stats *s = &mac->stats;\n\tunsigned int tx_tcnt, tx_xcnt;\n\tu64 tx_mcnt = s->tx_frames;\n\tint status;\n\n\tstatus = 0;\n\ttx_xcnt = 1;\t\t \n\ttx_tcnt = mac->tx_tcnt;\t \n\tif (tx_mcnt == mac->tx_mcnt && mac->rx_pause == s->rx_pause) {\n\t\ttx_xcnt = (G_TXSPI4SOPCNT(t3_read_reg(adap,\n\t\t\t\t\t\tA_XGM_TX_SPI4_SOP_EOP_CNT +\n\t\t\t\t\t       \tmac->offset)));\n\t\tif (tx_xcnt == 0) {\n\t\t\tt3_write_reg(adap, A_TP_PIO_ADDR,\n\t\t\t\t     A_TP_TX_DROP_CNT_CH0 + macidx(mac));\n\t\t\ttx_tcnt = (G_TXDROPCNTCH0RCVD(t3_read_reg(adap,\n\t\t\t\t\t\t      A_TP_PIO_DATA)));\n\t\t} else {\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tmac->toggle_cnt = 0;\n\t\tgoto out;\n\t}\n\n\tif ((tx_tcnt != mac->tx_tcnt) && (mac->tx_xcnt == 0)) {\n\t\tif (mac->toggle_cnt > 4) {\n\t\t\tstatus = 2;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tstatus = 1;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tmac->toggle_cnt = 0;\n\t\tgoto out;\n\t}\n\nout:\n\tmac->tx_tcnt = tx_tcnt;\n\tmac->tx_xcnt = tx_xcnt;\n\tmac->tx_mcnt = s->tx_frames;\n\tmac->rx_pause = s->rx_pause;\n\tif (status == 1) {\n\t\tt3_write_reg(adap, A_XGM_TX_CTRL + mac->offset, 0);\n\t\tt3_read_reg(adap, A_XGM_TX_CTRL + mac->offset);   \n\t\tt3_write_reg(adap, A_XGM_TX_CTRL + mac->offset, mac->txen);\n\t\tt3_read_reg(adap, A_XGM_TX_CTRL + mac->offset);   \n\t\tmac->toggle_cnt++;\n\t} else if (status == 2) {\n\t\tt3b2_mac_reset(mac);\n\t\tmac->toggle_cnt = 0;\n\t}\n\treturn status;\n}\n\n \nconst struct mac_stats *t3_mac_update_stats(struct cmac *mac)\n{\n#define RMON_READ(mac, addr) t3_read_reg(mac->adapter, addr + mac->offset)\n#define RMON_UPDATE(mac, name, reg) \\\n\t(mac)->stats.name += (u64)RMON_READ(mac, A_XGM_STAT_##reg)\n#define RMON_UPDATE64(mac, name, reg_lo, reg_hi) \\\n\t(mac)->stats.name += RMON_READ(mac, A_XGM_STAT_##reg_lo) + \\\n\t\t\t     ((u64)RMON_READ(mac, A_XGM_STAT_##reg_hi) << 32)\n\n\tu32 v, lo;\n\n\tRMON_UPDATE64(mac, rx_octets, RX_BYTES_LOW, RX_BYTES_HIGH);\n\tRMON_UPDATE64(mac, rx_frames, RX_FRAMES_LOW, RX_FRAMES_HIGH);\n\tRMON_UPDATE(mac, rx_mcast_frames, RX_MCAST_FRAMES);\n\tRMON_UPDATE(mac, rx_bcast_frames, RX_BCAST_FRAMES);\n\tRMON_UPDATE(mac, rx_fcs_errs, RX_CRC_ERR_FRAMES);\n\tRMON_UPDATE(mac, rx_pause, RX_PAUSE_FRAMES);\n\tRMON_UPDATE(mac, rx_jabber, RX_JABBER_FRAMES);\n\tRMON_UPDATE(mac, rx_short, RX_SHORT_FRAMES);\n\tRMON_UPDATE(mac, rx_symbol_errs, RX_SYM_CODE_ERR_FRAMES);\n\n\tRMON_UPDATE(mac, rx_too_long, RX_OVERSIZE_FRAMES);\n\n\tv = RMON_READ(mac, A_XGM_RX_MAX_PKT_SIZE_ERR_CNT);\n\tif (mac->adapter->params.rev == T3_REV_B2)\n\t\tv &= 0x7fffffff;\n\tmac->stats.rx_too_long += v;\n\n\tRMON_UPDATE(mac, rx_frames_64, RX_64B_FRAMES);\n\tRMON_UPDATE(mac, rx_frames_65_127, RX_65_127B_FRAMES);\n\tRMON_UPDATE(mac, rx_frames_128_255, RX_128_255B_FRAMES);\n\tRMON_UPDATE(mac, rx_frames_256_511, RX_256_511B_FRAMES);\n\tRMON_UPDATE(mac, rx_frames_512_1023, RX_512_1023B_FRAMES);\n\tRMON_UPDATE(mac, rx_frames_1024_1518, RX_1024_1518B_FRAMES);\n\tRMON_UPDATE(mac, rx_frames_1519_max, RX_1519_MAXB_FRAMES);\n\n\tRMON_UPDATE64(mac, tx_octets, TX_BYTE_LOW, TX_BYTE_HIGH);\n\tRMON_UPDATE64(mac, tx_frames, TX_FRAME_LOW, TX_FRAME_HIGH);\n\tRMON_UPDATE(mac, tx_mcast_frames, TX_MCAST);\n\tRMON_UPDATE(mac, tx_bcast_frames, TX_BCAST);\n\tRMON_UPDATE(mac, tx_pause, TX_PAUSE);\n\t \n\tRMON_UPDATE(mac, tx_underrun, TX_ERR_FRAMES);\n\n\tRMON_UPDATE(mac, tx_frames_64, TX_64B_FRAMES);\n\tRMON_UPDATE(mac, tx_frames_65_127, TX_65_127B_FRAMES);\n\tRMON_UPDATE(mac, tx_frames_128_255, TX_128_255B_FRAMES);\n\tRMON_UPDATE(mac, tx_frames_256_511, TX_256_511B_FRAMES);\n\tRMON_UPDATE(mac, tx_frames_512_1023, TX_512_1023B_FRAMES);\n\tRMON_UPDATE(mac, tx_frames_1024_1518, TX_1024_1518B_FRAMES);\n\tRMON_UPDATE(mac, tx_frames_1519_max, TX_1519_MAXB_FRAMES);\n\n\t \n\tt3_write_reg(mac->adapter, A_TP_MIB_INDEX, mac->offset ? 51 : 50);\n\tv = t3_read_reg(mac->adapter, A_TP_MIB_RDATA);\n\tlo = (u32) mac->stats.rx_cong_drops;\n\tmac->stats.rx_cong_drops += (u64) (v - lo);\n\n\treturn &mac->stats;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}