{
  "module_name": "ael1002.c",
  "hash_id": "7dc185a777e39d763ab5e8e4d42ab363c7ba8c885bd429c2d7f51872a10d6763",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb3/ael1002.c",
  "human_readable_source": " \n#include \"common.h\"\n#include \"regs.h\"\n\nenum {\n\tAEL100X_TX_CONFIG1 = 0xc002,\n\tAEL1002_PWR_DOWN_HI = 0xc011,\n\tAEL1002_PWR_DOWN_LO = 0xc012,\n\tAEL1002_XFI_EQL = 0xc015,\n\tAEL1002_LB_EN = 0xc017,\n\tAEL_OPT_SETTINGS = 0xc017,\n\tAEL_I2C_CTRL = 0xc30a,\n\tAEL_I2C_DATA = 0xc30b,\n\tAEL_I2C_STAT = 0xc30c,\n\tAEL2005_GPIO_CTRL = 0xc214,\n\tAEL2005_GPIO_STAT = 0xc215,\n\n\tAEL2020_GPIO_INTR   = 0xc103,\t \n\tAEL2020_GPIO_CTRL   = 0xc108,\t \n\tAEL2020_GPIO_STAT   = 0xc10c,\t \n\tAEL2020_GPIO_CFG    = 0xc110,\t \n\n\tAEL2020_GPIO_SDA    = 0,\t \n\tAEL2020_GPIO_MODDET = 1,\t \n\tAEL2020_GPIO_0      = 3,\t \n\tAEL2020_GPIO_1      = 2,\t \n\tAEL2020_GPIO_LSTAT  = AEL2020_GPIO_1,  \n};\n\nenum { edc_none, edc_sr, edc_twinax };\n\n \nenum {\n\tMODULE_DEV_ADDR\t= 0xa0,\n\tSFF_DEV_ADDR\t= 0xa2,\n};\n\n \nenum {\n\tphy_transtype_unknown = 0,\n\tphy_transtype_sfp     = 3,\n\tphy_transtype_xfp     = 6,\n};\n\n#define AEL2005_MODDET_IRQ 4\n\nstruct reg_val {\n\tunsigned short mmd_addr;\n\tunsigned short reg_addr;\n\tunsigned short clear_bits;\n\tunsigned short set_bits;\n};\n\nstatic int set_phy_regs(struct cphy *phy, const struct reg_val *rv)\n{\n\tint err;\n\n\tfor (err = 0; rv->mmd_addr && !err; rv++) {\n\t\tif (rv->clear_bits == 0xffff)\n\t\t\terr = t3_mdio_write(phy, rv->mmd_addr, rv->reg_addr,\n\t\t\t\t\t    rv->set_bits);\n\t\telse\n\t\t\terr = t3_mdio_change_bits(phy, rv->mmd_addr,\n\t\t\t\t\t\t  rv->reg_addr, rv->clear_bits,\n\t\t\t\t\t\t  rv->set_bits);\n\t}\n\treturn err;\n}\n\nstatic void ael100x_txon(struct cphy *phy)\n{\n\tint tx_on_gpio =\n\t\tphy->mdio.prtad == 0 ? F_GPIO7_OUT_VAL : F_GPIO2_OUT_VAL;\n\n\tmsleep(100);\n\tt3_set_reg_field(phy->adapter, A_T3DBG_GPIO_EN, 0, tx_on_gpio);\n\tmsleep(30);\n}\n\n \nstatic int ael_i2c_rd(struct cphy *phy, int dev_addr, int word_addr)\n{\n\tint i, err;\n\tunsigned int stat, data;\n\n\terr = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL_I2C_CTRL,\n\t\t\t    (dev_addr << 8) | (1 << 8) | word_addr);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < 200; i++) {\n\t\tmsleep(1);\n\t\terr = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL_I2C_STAT, &stat);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif ((stat & 3) == 1) {\n\t\t\terr = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL_I2C_DATA,\n\t\t\t\t\t   &data);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\treturn data >> 8;\n\t\t}\n\t}\n\tCH_WARN(phy->adapter, \"PHY %u i2c read of dev.addr %#x.%#x timed out\\n\",\n\t\tphy->mdio.prtad, dev_addr, word_addr);\n\treturn -ETIMEDOUT;\n}\n\nstatic int ael1002_power_down(struct cphy *phy, int enable)\n{\n\tint err;\n\n\terr = t3_mdio_write(phy, MDIO_MMD_PMAPMD, MDIO_PMA_TXDIS, !!enable);\n\tif (!err)\n\t\terr = mdio_set_flag(&phy->mdio, phy->mdio.prtad,\n\t\t\t\t    MDIO_MMD_PMAPMD, MDIO_CTRL1,\n\t\t\t\t    MDIO_CTRL1_LPOWER, enable);\n\treturn err;\n}\n\nstatic int ael1002_reset(struct cphy *phy, int wait)\n{\n\tint err;\n\n\tif ((err = ael1002_power_down(phy, 0)) ||\n\t    (err = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL100X_TX_CONFIG1, 1)) ||\n\t    (err = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL1002_PWR_DOWN_HI, 0)) ||\n\t    (err = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL1002_PWR_DOWN_LO, 0)) ||\n\t    (err = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL1002_XFI_EQL, 0x18)) ||\n\t    (err = t3_mdio_change_bits(phy, MDIO_MMD_PMAPMD, AEL1002_LB_EN,\n\t\t\t\t       0, 1 << 5)))\n\t\treturn err;\n\treturn 0;\n}\n\nstatic int ael1002_intr_noop(struct cphy *phy)\n{\n\treturn 0;\n}\n\n \nstatic int get_link_status_r(struct cphy *phy, int *link_ok, int *speed,\n\t\t\t     int *duplex, int *fc)\n{\n\tif (link_ok) {\n\t\tunsigned int stat0, stat1, stat2;\n\t\tint err = t3_mdio_read(phy, MDIO_MMD_PMAPMD,\n\t\t\t\t       MDIO_PMA_RXDET, &stat0);\n\n\t\tif (!err)\n\t\t\terr = t3_mdio_read(phy, MDIO_MMD_PCS,\n\t\t\t\t\t   MDIO_PCS_10GBRT_STAT1, &stat1);\n\t\tif (!err)\n\t\t\terr = t3_mdio_read(phy, MDIO_MMD_PHYXS,\n\t\t\t\t\t   MDIO_PHYXS_LNSTAT, &stat2);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*link_ok = (stat0 & stat1 & (stat2 >> 12)) & 1;\n\t}\n\tif (speed)\n\t\t*speed = SPEED_10000;\n\tif (duplex)\n\t\t*duplex = DUPLEX_FULL;\n\treturn 0;\n}\n\nstatic const struct cphy_ops ael1002_ops = {\n\t.reset = ael1002_reset,\n\t.intr_enable = ael1002_intr_noop,\n\t.intr_disable = ael1002_intr_noop,\n\t.intr_clear = ael1002_intr_noop,\n\t.intr_handler = ael1002_intr_noop,\n\t.get_link_status = get_link_status_r,\n\t.power_down = ael1002_power_down,\n\t.mmds = MDIO_DEVS_PMAPMD | MDIO_DEVS_PCS | MDIO_DEVS_PHYXS,\n};\n\nint t3_ael1002_phy_prep(struct cphy *phy, struct adapter *adapter,\n\t\t\tint phy_addr, const struct mdio_ops *mdio_ops)\n{\n\tcphy_init(phy, adapter, phy_addr, &ael1002_ops, mdio_ops,\n\t\t  SUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_FIBRE,\n\t\t   \"10GBASE-R\");\n\tael100x_txon(phy);\n\treturn 0;\n}\n\nstatic int ael1006_reset(struct cphy *phy, int wait)\n{\n\treturn t3_phy_reset(phy, MDIO_MMD_PMAPMD, wait);\n}\n\nstatic const struct cphy_ops ael1006_ops = {\n\t.reset = ael1006_reset,\n\t.intr_enable = t3_phy_lasi_intr_enable,\n\t.intr_disable = t3_phy_lasi_intr_disable,\n\t.intr_clear = t3_phy_lasi_intr_clear,\n\t.intr_handler = t3_phy_lasi_intr_handler,\n\t.get_link_status = get_link_status_r,\n\t.power_down = ael1002_power_down,\n\t.mmds = MDIO_DEVS_PMAPMD | MDIO_DEVS_PCS | MDIO_DEVS_PHYXS,\n};\n\nint t3_ael1006_phy_prep(struct cphy *phy, struct adapter *adapter,\n\t\t\t     int phy_addr, const struct mdio_ops *mdio_ops)\n{\n\tcphy_init(phy, adapter, phy_addr, &ael1006_ops, mdio_ops,\n\t\t  SUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_FIBRE,\n\t\t   \"10GBASE-SR\");\n\tael100x_txon(phy);\n\treturn 0;\n}\n\n \nstatic int ael2xxx_get_module_type(struct cphy *phy, int delay_ms)\n{\n\tint v;\n\n\tif (delay_ms)\n\t\tmsleep(delay_ms);\n\n\t \n\tv = ael_i2c_rd(phy, MODULE_DEV_ADDR, 3);\n\tif (v < 0)\n\t\treturn v;\n\n\tif (v == 0x10)\n\t\treturn phy_modtype_sr;\n\tif (v == 0x20)\n\t\treturn phy_modtype_lr;\n\tif (v == 0x40)\n\t\treturn phy_modtype_lrm;\n\n\tv = ael_i2c_rd(phy, MODULE_DEV_ADDR, 6);\n\tif (v < 0)\n\t\treturn v;\n\tif (v != 4)\n\t\tgoto unknown;\n\n\tv = ael_i2c_rd(phy, MODULE_DEV_ADDR, 10);\n\tif (v < 0)\n\t\treturn v;\n\n\tif (v & 0x80) {\n\t\tv = ael_i2c_rd(phy, MODULE_DEV_ADDR, 0x12);\n\t\tif (v < 0)\n\t\t\treturn v;\n\t\treturn v > 10 ? phy_modtype_twinax_long : phy_modtype_twinax;\n\t}\nunknown:\n\treturn phy_modtype_unknown;\n}\n\n \nstatic int ael2005_setup_sr_edc(struct cphy *phy)\n{\n\tstatic const struct reg_val regs[] = {\n\t\t{ MDIO_MMD_PMAPMD, 0xc003, 0xffff, 0x181 },\n\t\t{ MDIO_MMD_PMAPMD, 0xc010, 0xffff, 0x448a },\n\t\t{ MDIO_MMD_PMAPMD, 0xc04a, 0xffff, 0x5200 },\n\t\t{ 0, 0, 0, 0 }\n\t};\n\n\tint i, err;\n\n\terr = set_phy_regs(phy, regs);\n\tif (err)\n\t\treturn err;\n\n\tmsleep(50);\n\n\tif (phy->priv != edc_sr)\n\t\terr = t3_get_edc_fw(phy, EDC_OPT_AEL2005,\n\t\t\t\t    EDC_OPT_AEL2005_SIZE);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <  EDC_OPT_AEL2005_SIZE / sizeof(u16) && !err; i += 2)\n\t\terr = t3_mdio_write(phy, MDIO_MMD_PMAPMD,\n\t\t\t\t    phy->phy_cache[i],\n\t\t\t\t    phy->phy_cache[i + 1]);\n\tif (!err)\n\t\tphy->priv = edc_sr;\n\treturn err;\n}\n\nstatic int ael2005_setup_twinax_edc(struct cphy *phy, int modtype)\n{\n\tstatic const struct reg_val regs[] = {\n\t\t{ MDIO_MMD_PMAPMD, 0xc04a, 0xffff, 0x5a00 },\n\t\t{ 0, 0, 0, 0 }\n\t};\n\tstatic const struct reg_val preemphasis[] = {\n\t\t{ MDIO_MMD_PMAPMD, 0xc014, 0xffff, 0xfe16 },\n\t\t{ MDIO_MMD_PMAPMD, 0xc015, 0xffff, 0xa000 },\n\t\t{ 0, 0, 0, 0 }\n\t};\n\tint i, err;\n\n\terr = set_phy_regs(phy, regs);\n\tif (!err && modtype == phy_modtype_twinax_long)\n\t\terr = set_phy_regs(phy, preemphasis);\n\tif (err)\n\t\treturn err;\n\n\tmsleep(50);\n\n\tif (phy->priv != edc_twinax)\n\t\terr = t3_get_edc_fw(phy, EDC_TWX_AEL2005,\n\t\t\t\t    EDC_TWX_AEL2005_SIZE);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <  EDC_TWX_AEL2005_SIZE / sizeof(u16) && !err; i += 2)\n\t\terr = t3_mdio_write(phy, MDIO_MMD_PMAPMD,\n\t\t\t\t    phy->phy_cache[i],\n\t\t\t\t    phy->phy_cache[i + 1]);\n\tif (!err)\n\t\tphy->priv = edc_twinax;\n\treturn err;\n}\n\nstatic int ael2005_get_module_type(struct cphy *phy, int delay_ms)\n{\n\tint v;\n\tunsigned int stat;\n\n\tv = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL2005_GPIO_CTRL, &stat);\n\tif (v)\n\t\treturn v;\n\n\tif (stat & (1 << 8))\t\t\t \n\t\treturn phy_modtype_none;\n\n\treturn ael2xxx_get_module_type(phy, delay_ms);\n}\n\nstatic int ael2005_intr_enable(struct cphy *phy)\n{\n\tint err = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL2005_GPIO_CTRL, 0x200);\n\treturn err ? err : t3_phy_lasi_intr_enable(phy);\n}\n\nstatic int ael2005_intr_disable(struct cphy *phy)\n{\n\tint err = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL2005_GPIO_CTRL, 0x100);\n\treturn err ? err : t3_phy_lasi_intr_disable(phy);\n}\n\nstatic int ael2005_intr_clear(struct cphy *phy)\n{\n\tint err = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL2005_GPIO_CTRL, 0xd00);\n\treturn err ? err : t3_phy_lasi_intr_clear(phy);\n}\n\nstatic int ael2005_reset(struct cphy *phy, int wait)\n{\n\tstatic const struct reg_val regs0[] = {\n\t\t{ MDIO_MMD_PMAPMD, 0xc001, 0, 1 << 5 },\n\t\t{ MDIO_MMD_PMAPMD, 0xc017, 0, 1 << 5 },\n\t\t{ MDIO_MMD_PMAPMD, 0xc013, 0xffff, 0xf341 },\n\t\t{ MDIO_MMD_PMAPMD, 0xc210, 0xffff, 0x8000 },\n\t\t{ MDIO_MMD_PMAPMD, 0xc210, 0xffff, 0x8100 },\n\t\t{ MDIO_MMD_PMAPMD, 0xc210, 0xffff, 0x8000 },\n\t\t{ MDIO_MMD_PMAPMD, 0xc210, 0xffff, 0 },\n\t\t{ 0, 0, 0, 0 }\n\t};\n\tstatic const struct reg_val regs1[] = {\n\t\t{ MDIO_MMD_PMAPMD, 0xca00, 0xffff, 0x0080 },\n\t\t{ MDIO_MMD_PMAPMD, 0xca12, 0xffff, 0 },\n\t\t{ 0, 0, 0, 0 }\n\t};\n\n\tint err;\n\tunsigned int lasi_ctrl;\n\n\terr = t3_mdio_read(phy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL,\n\t\t\t   &lasi_ctrl);\n\tif (err)\n\t\treturn err;\n\n\terr = t3_phy_reset(phy, MDIO_MMD_PMAPMD, 0);\n\tif (err)\n\t\treturn err;\n\n\tmsleep(125);\n\tphy->priv = edc_none;\n\terr = set_phy_regs(phy, regs0);\n\tif (err)\n\t\treturn err;\n\n\tmsleep(50);\n\n\terr = ael2005_get_module_type(phy, 0);\n\tif (err < 0)\n\t\treturn err;\n\tphy->modtype = err;\n\n\tif (err == phy_modtype_twinax || err == phy_modtype_twinax_long)\n\t\terr = ael2005_setup_twinax_edc(phy, err);\n\telse\n\t\terr = ael2005_setup_sr_edc(phy);\n\tif (err)\n\t\treturn err;\n\n\terr = set_phy_regs(phy, regs1);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (lasi_ctrl & 1)\n\t\terr = ael2005_intr_enable(phy);\n\treturn err;\n}\n\nstatic int ael2005_intr_handler(struct cphy *phy)\n{\n\tunsigned int stat;\n\tint ret, edc_needed, cause = 0;\n\n\tret = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL2005_GPIO_STAT, &stat);\n\tif (ret)\n\t\treturn ret;\n\n\tif (stat & AEL2005_MODDET_IRQ) {\n\t\tret = t3_mdio_write(phy, MDIO_MMD_PMAPMD, AEL2005_GPIO_CTRL,\n\t\t\t\t    0xd00);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = ael2005_get_module_type(phy, 300);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tphy->modtype = ret;\n\t\tif (ret == phy_modtype_none)\n\t\t\tedc_needed = phy->priv;        \n\t\telse if (ret == phy_modtype_twinax ||\n\t\t\t ret == phy_modtype_twinax_long)\n\t\t\tedc_needed = edc_twinax;\n\t\telse\n\t\t\tedc_needed = edc_sr;\n\n\t\tif (edc_needed != phy->priv) {\n\t\t\tret = ael2005_reset(phy, 0);\n\t\t\treturn ret ? ret : cphy_cause_module_change;\n\t\t}\n\t\tcause = cphy_cause_module_change;\n\t}\n\n\tret = t3_phy_lasi_intr_handler(phy);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret |= cause;\n\treturn ret ? ret : cphy_cause_link_change;\n}\n\nstatic const struct cphy_ops ael2005_ops = {\n\t.reset           = ael2005_reset,\n\t.intr_enable     = ael2005_intr_enable,\n\t.intr_disable    = ael2005_intr_disable,\n\t.intr_clear      = ael2005_intr_clear,\n\t.intr_handler    = ael2005_intr_handler,\n\t.get_link_status = get_link_status_r,\n\t.power_down      = ael1002_power_down,\n\t.mmds            = MDIO_DEVS_PMAPMD | MDIO_DEVS_PCS | MDIO_DEVS_PHYXS,\n};\n\nint t3_ael2005_phy_prep(struct cphy *phy, struct adapter *adapter,\n\t\t\tint phy_addr, const struct mdio_ops *mdio_ops)\n{\n\tcphy_init(phy, adapter, phy_addr, &ael2005_ops, mdio_ops,\n\t\t  SUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_FIBRE |\n\t\t  SUPPORTED_IRQ, \"10GBASE-R\");\n\tmsleep(125);\n\treturn t3_mdio_change_bits(phy, MDIO_MMD_PMAPMD, AEL_OPT_SETTINGS, 0,\n\t\t\t\t   1 << 5);\n}\n\n \nstatic int ael2020_setup_sr_edc(struct cphy *phy)\n{\n\tstatic const struct reg_val regs[] = {\n\t\t \n\t\t{ MDIO_MMD_PMAPMD, 0xcc01, 0xffff, 0x488a },\n\n\t\t \n\t\t{ MDIO_MMD_PMAPMD, 0xcb1b, 0xffff, 0x0200 },\n\t\t{ MDIO_MMD_PMAPMD, 0xcb1c, 0xffff, 0x00f0 },\n\t\t{ MDIO_MMD_PMAPMD, 0xcc06, 0xffff, 0x00e0 },\n\n\t\t \n\t\t{ 0, 0, 0, 0 }\n\t};\n\tint err;\n\n\terr = set_phy_regs(phy, regs);\n\tmsleep(50);\n\tif (err)\n\t\treturn err;\n\n\tphy->priv = edc_sr;\n\treturn 0;\n}\n\n \nstatic int ael2020_setup_twinax_edc(struct cphy *phy, int modtype)\n{\n\t \n\tstatic const struct reg_val uCclock40MHz[] = {\n\t\t{ MDIO_MMD_PMAPMD, 0xff28, 0xffff, 0x4001 },\n\t\t{ MDIO_MMD_PMAPMD, 0xff2a, 0xffff, 0x0002 },\n\t\t{ 0, 0, 0, 0 }\n\t};\n\n\t \n\tstatic const struct reg_val uCclockActivate[] = {\n\t\t{ MDIO_MMD_PMAPMD, 0xd000, 0xffff, 0x5200 },\n\t\t{ 0, 0, 0, 0 }\n\t};\n\n\t \n\tstatic const struct reg_val uCactivate[] = {\n\t\t{ MDIO_MMD_PMAPMD, 0xd080, 0xffff, 0x0100 },\n\t\t{ MDIO_MMD_PMAPMD, 0xd092, 0xffff, 0x0000 },\n\t\t{ 0, 0, 0, 0 }\n\t};\n\tint i, err;\n\n\t \n\terr = set_phy_regs(phy, uCclock40MHz);\n\tmsleep(500);\n\tif (err)\n\t\treturn err;\n\terr = set_phy_regs(phy, uCclockActivate);\n\tmsleep(500);\n\tif (err)\n\t\treturn err;\n\n\tif (phy->priv != edc_twinax)\n\t\terr = t3_get_edc_fw(phy, EDC_TWX_AEL2020,\n\t\t\t\t    EDC_TWX_AEL2020_SIZE);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <  EDC_TWX_AEL2020_SIZE / sizeof(u16) && !err; i += 2)\n\t\terr = t3_mdio_write(phy, MDIO_MMD_PMAPMD,\n\t\t\t\t    phy->phy_cache[i],\n\t\t\t\t    phy->phy_cache[i + 1]);\n\t \n\terr = set_phy_regs(phy, uCactivate);\n\tif (!err)\n\t\tphy->priv = edc_twinax;\n\treturn err;\n}\n\n \nstatic int ael2020_get_module_type(struct cphy *phy, int delay_ms)\n{\n\tint v;\n\tunsigned int stat;\n\n\tv = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL2020_GPIO_STAT, &stat);\n\tif (v)\n\t\treturn v;\n\n\tif (stat & (0x1 << (AEL2020_GPIO_MODDET*4))) {\n\t\t \n\t\treturn phy_modtype_none;\n\t}\n\n\treturn ael2xxx_get_module_type(phy, delay_ms);\n}\n\n \nstatic int ael2020_intr_enable(struct cphy *phy)\n{\n\tstatic const struct reg_val regs[] = {\n\t\t \n\t\t{ MDIO_MMD_PMAPMD, AEL2020_GPIO_CFG+AEL2020_GPIO_LSTAT,\n\t\t\t0xffff, 0x4 },\n\t\t{ MDIO_MMD_PMAPMD, AEL2020_GPIO_CTRL,\n\t\t\t0xffff, 0x8 << (AEL2020_GPIO_LSTAT*4) },\n\n\t\t  \n\t\t{ MDIO_MMD_PMAPMD, AEL2020_GPIO_CTRL,\n\t\t\t0xffff, 0x2 << (AEL2020_GPIO_MODDET*4) },\n\n\t\t \n\t\t{ 0, 0, 0, 0 }\n\t};\n\tint err, link_ok = 0;\n\n\t \n\terr = set_phy_regs(phy, regs);\n\tif (err)\n\t\treturn err;\n\n\terr = get_link_status_r(phy, &link_ok, NULL, NULL, NULL);\n\tif (err)\n\t\treturn err;\n\tif (link_ok)\n\t\tt3_link_changed(phy->adapter,\n\t\t\t\tphy2portid(phy));\n\n\terr = t3_phy_lasi_intr_enable(phy);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic int ael2020_intr_disable(struct cphy *phy)\n{\n\tstatic const struct reg_val regs[] = {\n\t\t \n\t\t{ MDIO_MMD_PMAPMD, AEL2020_GPIO_CTRL,\n\t\t\t0xffff, 0xb << (AEL2020_GPIO_LSTAT*4) },\n\n\t\t \n\t\t{ MDIO_MMD_PMAPMD, AEL2020_GPIO_CTRL,\n\t\t\t0xffff, 0x1 << (AEL2020_GPIO_MODDET*4) },\n\n\t\t \n\t\t{ 0, 0, 0, 0 }\n\t};\n\tint err;\n\n\t \n\terr = set_phy_regs(phy, regs);\n\tif (err)\n\t\treturn err;\n\n\treturn t3_phy_lasi_intr_disable(phy);\n}\n\n \nstatic int ael2020_intr_clear(struct cphy *phy)\n{\n\t \n\tunsigned int stat;\n\tint err = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL2020_GPIO_INTR, &stat);\n\treturn err ? err : t3_phy_lasi_intr_clear(phy);\n}\n\nstatic const struct reg_val ael2020_reset_regs[] = {\n\t \n\t{ MDIO_MMD_PMAPMD, 0xc003, 0xffff, 0x3101 },\n\n\t \n\t{ MDIO_MMD_PMAPMD, 0xcd40, 0xffff, 0x0001 },\n\n\t \n\t{ MDIO_MMD_PMAPMD, 0xff02, 0xffff, 0x0023 },\n\t{ MDIO_MMD_PMAPMD, 0xff03, 0xffff, 0x0000 },\n\t{ MDIO_MMD_PMAPMD, 0xff04, 0xffff, 0x0000 },\n\n\t \n\t{ 0, 0, 0, 0 }\n};\n \nstatic int ael2020_reset(struct cphy *phy, int wait)\n{\n\tint err;\n\tunsigned int lasi_ctrl;\n\n\t \n\terr = t3_mdio_read(phy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL,\n\t\t\t   &lasi_ctrl);\n\tif (err)\n\t\treturn err;\n\n\terr = t3_phy_reset(phy, MDIO_MMD_PMAPMD, 125);\n\tif (err)\n\t\treturn err;\n\tmsleep(100);\n\n\t \n\tphy->priv = edc_none;\n\terr = set_phy_regs(phy, ael2020_reset_regs);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ael2020_get_module_type(phy, 0);\n\tif (err < 0)\n\t\treturn err;\n\tphy->modtype = (u8)err;\n\tif (err == phy_modtype_twinax || err == phy_modtype_twinax_long)\n\t\terr = ael2020_setup_twinax_edc(phy, err);\n\telse\n\t\terr = ael2020_setup_sr_edc(phy);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (lasi_ctrl & 1)\n\t\terr = ael2005_intr_enable(phy);\n\treturn err;\n}\n\n \nstatic int ael2020_intr_handler(struct cphy *phy)\n{\n\tunsigned int stat;\n\tint ret, edc_needed, cause = 0;\n\n\tret = t3_mdio_read(phy, MDIO_MMD_PMAPMD, AEL2020_GPIO_INTR, &stat);\n\tif (ret)\n\t\treturn ret;\n\n\tif (stat & (0x1 << AEL2020_GPIO_MODDET)) {\n\t\t \n\t\tret = ael2020_get_module_type(phy, 300);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tphy->modtype = (u8)ret;\n\t\tif (ret == phy_modtype_none)\n\t\t\tedc_needed = phy->priv;        \n\t\telse if (ret == phy_modtype_twinax ||\n\t\t\t ret == phy_modtype_twinax_long)\n\t\t\tedc_needed = edc_twinax;\n\t\telse\n\t\t\tedc_needed = edc_sr;\n\n\t\tif (edc_needed != phy->priv) {\n\t\t\tret = ael2020_reset(phy, 0);\n\t\t\treturn ret ? ret : cphy_cause_module_change;\n\t\t}\n\t\tcause = cphy_cause_module_change;\n\t}\n\n\tret = t3_phy_lasi_intr_handler(phy);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret |= cause;\n\treturn ret ? ret : cphy_cause_link_change;\n}\n\nstatic const struct cphy_ops ael2020_ops = {\n\t.reset           = ael2020_reset,\n\t.intr_enable     = ael2020_intr_enable,\n\t.intr_disable    = ael2020_intr_disable,\n\t.intr_clear      = ael2020_intr_clear,\n\t.intr_handler    = ael2020_intr_handler,\n\t.get_link_status = get_link_status_r,\n\t.power_down      = ael1002_power_down,\n\t.mmds\t\t = MDIO_DEVS_PMAPMD | MDIO_DEVS_PCS | MDIO_DEVS_PHYXS,\n};\n\nint t3_ael2020_phy_prep(struct cphy *phy, struct adapter *adapter, int phy_addr,\n\t\t\tconst struct mdio_ops *mdio_ops)\n{\n\tcphy_init(phy, adapter, phy_addr, &ael2020_ops, mdio_ops,\n\t\t  SUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_FIBRE |\n\t\t  SUPPORTED_IRQ, \"10GBASE-R\");\n\tmsleep(125);\n\n\treturn set_phy_regs(phy, ael2020_reset_regs);\n}\n\n \nstatic int get_link_status_x(struct cphy *phy, int *link_ok, int *speed,\n\t\t\t     int *duplex, int *fc)\n{\n\tif (link_ok) {\n\t\tunsigned int stat0, stat1, stat2;\n\t\tint err = t3_mdio_read(phy, MDIO_MMD_PMAPMD,\n\t\t\t\t       MDIO_PMA_RXDET, &stat0);\n\n\t\tif (!err)\n\t\t\terr = t3_mdio_read(phy, MDIO_MMD_PCS,\n\t\t\t\t\t   MDIO_PCS_10GBX_STAT1, &stat1);\n\t\tif (!err)\n\t\t\terr = t3_mdio_read(phy, MDIO_MMD_PHYXS,\n\t\t\t\t\t   MDIO_PHYXS_LNSTAT, &stat2);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*link_ok = (stat0 & (stat1 >> 12) & (stat2 >> 12)) & 1;\n\t}\n\tif (speed)\n\t\t*speed = SPEED_10000;\n\tif (duplex)\n\t\t*duplex = DUPLEX_FULL;\n\treturn 0;\n}\n\nstatic const struct cphy_ops qt2045_ops = {\n\t.reset = ael1006_reset,\n\t.intr_enable = t3_phy_lasi_intr_enable,\n\t.intr_disable = t3_phy_lasi_intr_disable,\n\t.intr_clear = t3_phy_lasi_intr_clear,\n\t.intr_handler = t3_phy_lasi_intr_handler,\n\t.get_link_status = get_link_status_x,\n\t.power_down = ael1002_power_down,\n\t.mmds = MDIO_DEVS_PMAPMD | MDIO_DEVS_PCS | MDIO_DEVS_PHYXS,\n};\n\nint t3_qt2045_phy_prep(struct cphy *phy, struct adapter *adapter,\n\t\t       int phy_addr, const struct mdio_ops *mdio_ops)\n{\n\tunsigned int stat;\n\n\tcphy_init(phy, adapter, phy_addr, &qt2045_ops, mdio_ops,\n\t\t  SUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_TP,\n\t\t  \"10GBASE-CX4\");\n\n\t \n\tif (!phy_addr &&\n\t    !t3_mdio_read(phy, MDIO_MMD_PMAPMD, MDIO_STAT1, &stat) &&\n\t    stat == 0xffff)\n\t\tphy->mdio.prtad = 1;\n\treturn 0;\n}\n\nstatic int xaui_direct_reset(struct cphy *phy, int wait)\n{\n\treturn 0;\n}\n\nstatic int xaui_direct_get_link_status(struct cphy *phy, int *link_ok,\n\t\t\t\t       int *speed, int *duplex, int *fc)\n{\n\tif (link_ok) {\n\t\tunsigned int status;\n\t\tint prtad = phy->mdio.prtad;\n\n\t\tstatus = t3_read_reg(phy->adapter,\n\t\t\t\t     XGM_REG(A_XGM_SERDES_STAT0, prtad)) |\n\t\t    t3_read_reg(phy->adapter,\n\t\t\t\t    XGM_REG(A_XGM_SERDES_STAT1, prtad)) |\n\t\t    t3_read_reg(phy->adapter,\n\t\t\t\tXGM_REG(A_XGM_SERDES_STAT2, prtad)) |\n\t\t    t3_read_reg(phy->adapter,\n\t\t\t\tXGM_REG(A_XGM_SERDES_STAT3, prtad));\n\t\t*link_ok = !(status & F_LOWSIG0);\n\t}\n\tif (speed)\n\t\t*speed = SPEED_10000;\n\tif (duplex)\n\t\t*duplex = DUPLEX_FULL;\n\treturn 0;\n}\n\nstatic int xaui_direct_power_down(struct cphy *phy, int enable)\n{\n\treturn 0;\n}\n\nstatic const struct cphy_ops xaui_direct_ops = {\n\t.reset = xaui_direct_reset,\n\t.intr_enable = ael1002_intr_noop,\n\t.intr_disable = ael1002_intr_noop,\n\t.intr_clear = ael1002_intr_noop,\n\t.intr_handler = ael1002_intr_noop,\n\t.get_link_status = xaui_direct_get_link_status,\n\t.power_down = xaui_direct_power_down,\n};\n\nint t3_xaui_direct_phy_prep(struct cphy *phy, struct adapter *adapter,\n\t\t\t    int phy_addr, const struct mdio_ops *mdio_ops)\n{\n\tcphy_init(phy, adapter, phy_addr, &xaui_direct_ops, mdio_ops,\n\t\t  SUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_TP,\n\t\t  \"10GBASE-CX4\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}