{
  "module_name": "mc5.c",
  "hash_id": "794621bb2d2919a7e924d73b1a3977d700046fda247c807e5e99a9074ab728ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb3/mc5.c",
  "human_readable_source": " \n#include \"common.h\"\n#include \"regs.h\"\n\nenum {\n\tIDT75P52100 = 4,\n\tIDT75N43102 = 5\n};\n\n \nenum {\n\tDBGI_MODE_MBUS = 0,\n\tDBGI_MODE_IDT52100 = 5\n};\n\n \n#define IDT_CMD_READ   0\n#define IDT_CMD_WRITE  1\n#define IDT_CMD_SEARCH 2\n#define IDT_CMD_LEARN  3\n\n \n#define IDT_LAR_ADR0   \t0x180006\n#define IDT_LAR_MODE144\t0xffff0000\n\n \n#define IDT_SCR_ADR0  0x180000\n#define IDT_SSR0_ADR0 0x180002\n#define IDT_SSR1_ADR0 0x180004\n\n \n#define IDT_GMR_BASE_ADR0 0x180020\n\n \n#define IDT_DATARY_BASE_ADR0 0\n#define IDT_MSKARY_BASE_ADR0 0x80000\n\n \n#define IDT4_CMD_SEARCH144 3\n#define IDT4_CMD_WRITE     4\n#define IDT4_CMD_READ      5\n\n \n#define IDT4_SCR_ADR0  0x3\n\n \n#define IDT4_GMR_BASE0 0x10\n#define IDT4_GMR_BASE1 0x20\n#define IDT4_GMR_BASE2 0x30\n\n \n#define IDT4_DATARY_BASE_ADR0 0x1000000\n#define IDT4_MSKARY_BASE_ADR0 0x2000000\n\n#define MAX_WRITE_ATTEMPTS 5\n\n#define MAX_ROUTES 2048\n\n \nstatic int mc5_cmd_write(struct adapter *adapter, u32 cmd)\n{\n\tt3_write_reg(adapter, A_MC5_DB_DBGI_REQ_CMD, cmd);\n\treturn t3_wait_op_done(adapter, A_MC5_DB_DBGI_RSP_STATUS,\n\t\t\t       F_DBGIRSPVALID, 1, MAX_WRITE_ATTEMPTS, 1);\n}\n\nstatic inline void dbgi_wr_data3(struct adapter *adapter, u32 v1, u32 v2,\n\t\t\t\t u32 v3)\n{\n\tt3_write_reg(adapter, A_MC5_DB_DBGI_REQ_DATA0, v1);\n\tt3_write_reg(adapter, A_MC5_DB_DBGI_REQ_DATA1, v2);\n\tt3_write_reg(adapter, A_MC5_DB_DBGI_REQ_DATA2, v3);\n}\n\n \nstatic int mc5_write(struct adapter *adapter, u32 addr_lo, u32 cmd)\n{\n\tt3_write_reg(adapter, A_MC5_DB_DBGI_REQ_ADDR0, addr_lo);\n\tif (mc5_cmd_write(adapter, cmd) == 0)\n\t\treturn 0;\n\tCH_ERR(adapter, \"MC5 timeout writing to TCAM address 0x%x\\n\",\n\t       addr_lo);\n\treturn -1;\n}\n\nstatic int init_mask_data_array(struct mc5 *mc5, u32 mask_array_base,\n\t\t\t\tu32 data_array_base, u32 write_cmd,\n\t\t\t\tint addr_shift)\n{\n\tunsigned int i;\n\tstruct adapter *adap = mc5->adapter;\n\n\t \n\tunsigned int size72 = mc5->tcam_size;\n\tunsigned int server_base = t3_read_reg(adap, A_MC5_DB_SERVER_INDEX);\n\n\tif (mc5->mode == MC5_MODE_144_BIT) {\n\t\tsize72 *= 2;\t \n\t\tserver_base *= 2;\n\t}\n\n\t \n\tdbgi_wr_data3(adap, 0, 0, 0);\n\tfor (i = 0; i < size72; i++)\n\t\tif (mc5_write(adap, data_array_base + (i << addr_shift),\n\t\t\t      write_cmd))\n\t\t\treturn -1;\n\n\t \n\tdbgi_wr_data3(adap, 0xffffffff, 0xffffffff, 0xff);\n\tfor (i = 0; i < size72; i++) {\n\t\tif (i == server_base)\t \n\t\t\tt3_write_reg(adap, A_MC5_DB_DBGI_REQ_DATA0,\n\t\t\t\t     mc5->mode == MC5_MODE_144_BIT ?\n\t\t\t\t     0xfffffff9 : 0xfffffffd);\n\t\tif (mc5_write(adap, mask_array_base + (i << addr_shift),\n\t\t\t      write_cmd))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int init_idt52100(struct mc5 *mc5)\n{\n\tint i;\n\tstruct adapter *adap = mc5->adapter;\n\n\tt3_write_reg(adap, A_MC5_DB_RSP_LATENCY,\n\t\t     V_RDLAT(0x15) | V_LRNLAT(0x15) | V_SRCHLAT(0x15));\n\tt3_write_reg(adap, A_MC5_DB_PART_ID_INDEX, 2);\n\n\t \n\tt3_write_reg(adap, A_MC5_DB_POPEN_DATA_WR_CMD, IDT_CMD_WRITE);\n\tt3_write_reg(adap, A_MC5_DB_POPEN_MASK_WR_CMD, IDT_CMD_WRITE);\n\tt3_write_reg(adap, A_MC5_DB_AOPEN_SRCH_CMD, IDT_CMD_SEARCH);\n\tt3_write_reg(adap, A_MC5_DB_AOPEN_LRN_CMD, IDT_CMD_LEARN);\n\tt3_write_reg(adap, A_MC5_DB_SYN_SRCH_CMD, IDT_CMD_SEARCH | 0x6000);\n\tt3_write_reg(adap, A_MC5_DB_SYN_LRN_CMD, IDT_CMD_LEARN);\n\tt3_write_reg(adap, A_MC5_DB_ACK_SRCH_CMD, IDT_CMD_SEARCH);\n\tt3_write_reg(adap, A_MC5_DB_ACK_LRN_CMD, IDT_CMD_LEARN);\n\tt3_write_reg(adap, A_MC5_DB_ILOOKUP_CMD, IDT_CMD_SEARCH);\n\tt3_write_reg(adap, A_MC5_DB_ELOOKUP_CMD, IDT_CMD_SEARCH | 0x7000);\n\tt3_write_reg(adap, A_MC5_DB_DATA_WRITE_CMD, IDT_CMD_WRITE);\n\tt3_write_reg(adap, A_MC5_DB_DATA_READ_CMD, IDT_CMD_READ);\n\n\t \n\tt3_write_reg(adap, A_MC5_DB_DBGI_CONFIG, DBGI_MODE_IDT52100);\n\n\t \n\tdbgi_wr_data3(adap, IDT_LAR_MODE144, 0, 0);\n\tif (mc5_write(adap, IDT_LAR_ADR0, IDT_CMD_WRITE))\n\t\tgoto err;\n\n\t \n\tdbgi_wr_data3(adap, 0xffffffff, 0xffffffff, 0);\n\tif (mc5_write(adap, IDT_SSR0_ADR0, IDT_CMD_WRITE) ||\n\t    mc5_write(adap, IDT_SSR1_ADR0, IDT_CMD_WRITE))\n\t\tgoto err;\n\n\t \n\tfor (i = 0; i < 32; ++i) {\n\t\tif (i >= 12 && i < 15)\n\t\t\tdbgi_wr_data3(adap, 0xfffffff9, 0xffffffff, 0xff);\n\t\telse if (i == 15)\n\t\t\tdbgi_wr_data3(adap, 0xfffffff9, 0xffff8007, 0xff);\n\t\telse\n\t\t\tdbgi_wr_data3(adap, 0xffffffff, 0xffffffff, 0xff);\n\n\t\tif (mc5_write(adap, IDT_GMR_BASE_ADR0 + i, IDT_CMD_WRITE))\n\t\t\tgoto err;\n\t}\n\n\t \n\tdbgi_wr_data3(adap, 1, 0, 0);\n\tif (mc5_write(adap, IDT_SCR_ADR0, IDT_CMD_WRITE))\n\t\tgoto err;\n\n\treturn init_mask_data_array(mc5, IDT_MSKARY_BASE_ADR0,\n\t\t\t\t    IDT_DATARY_BASE_ADR0, IDT_CMD_WRITE, 0);\nerr:\n\treturn -EIO;\n}\n\nstatic int init_idt43102(struct mc5 *mc5)\n{\n\tint i;\n\tstruct adapter *adap = mc5->adapter;\n\n\tt3_write_reg(adap, A_MC5_DB_RSP_LATENCY,\n\t\t     adap->params.rev == 0 ? V_RDLAT(0xd) | V_SRCHLAT(0x11) :\n\t\t     V_RDLAT(0xd) | V_SRCHLAT(0x12));\n\n\t \n\tt3_write_reg(adap, A_MC5_DB_POPEN_DATA_WR_CMD, IDT4_CMD_WRITE);\n\tt3_write_reg(adap, A_MC5_DB_POPEN_MASK_WR_CMD, IDT4_CMD_WRITE);\n\tt3_write_reg(adap, A_MC5_DB_AOPEN_SRCH_CMD,\n\t\t     IDT4_CMD_SEARCH144 | 0x3800);\n\tt3_write_reg(adap, A_MC5_DB_SYN_SRCH_CMD, IDT4_CMD_SEARCH144);\n\tt3_write_reg(adap, A_MC5_DB_ACK_SRCH_CMD, IDT4_CMD_SEARCH144 | 0x3800);\n\tt3_write_reg(adap, A_MC5_DB_ILOOKUP_CMD, IDT4_CMD_SEARCH144 | 0x3800);\n\tt3_write_reg(adap, A_MC5_DB_ELOOKUP_CMD, IDT4_CMD_SEARCH144 | 0x800);\n\tt3_write_reg(adap, A_MC5_DB_DATA_WRITE_CMD, IDT4_CMD_WRITE);\n\tt3_write_reg(adap, A_MC5_DB_DATA_READ_CMD, IDT4_CMD_READ);\n\n\tt3_write_reg(adap, A_MC5_DB_PART_ID_INDEX, 3);\n\n\t \n\tt3_write_reg(adap, A_MC5_DB_DBGI_CONFIG, DBGI_MODE_IDT52100);\n\n\t \n\tdbgi_wr_data3(adap, 0xffffffff, 0xffffffff, 0xff);\n\tfor (i = 0; i < 7; ++i)\n\t\tif (mc5_write(adap, IDT4_GMR_BASE0 + i, IDT4_CMD_WRITE))\n\t\t\tgoto err;\n\n\tfor (i = 0; i < 4; ++i)\n\t\tif (mc5_write(adap, IDT4_GMR_BASE2 + i, IDT4_CMD_WRITE))\n\t\t\tgoto err;\n\n\tdbgi_wr_data3(adap, 0xfffffff9, 0xffffffff, 0xff);\n\tif (mc5_write(adap, IDT4_GMR_BASE1, IDT4_CMD_WRITE) ||\n\t    mc5_write(adap, IDT4_GMR_BASE1 + 1, IDT4_CMD_WRITE) ||\n\t    mc5_write(adap, IDT4_GMR_BASE1 + 4, IDT4_CMD_WRITE))\n\t\tgoto err;\n\n\tdbgi_wr_data3(adap, 0xfffffff9, 0xffff8007, 0xff);\n\tif (mc5_write(adap, IDT4_GMR_BASE1 + 5, IDT4_CMD_WRITE))\n\t\tgoto err;\n\n\t \n\tdbgi_wr_data3(adap, 0xf0000000, 0, 0);\n\tif (mc5_write(adap, IDT4_SCR_ADR0, IDT4_CMD_WRITE))\n\t\tgoto err;\n\n\treturn init_mask_data_array(mc5, IDT4_MSKARY_BASE_ADR0,\n\t\t\t\t    IDT4_DATARY_BASE_ADR0, IDT4_CMD_WRITE, 1);\nerr:\n\treturn -EIO;\n}\n\n \nstatic inline void mc5_dbgi_mode_enable(const struct mc5 *mc5)\n{\n\tt3_write_reg(mc5->adapter, A_MC5_DB_CONFIG,\n\t\t     V_TMMODE(mc5->mode == MC5_MODE_72_BIT) | F_DBGIEN);\n}\n\n \nstatic void mc5_dbgi_mode_disable(const struct mc5 *mc5)\n{\n\tt3_write_reg(mc5->adapter, A_MC5_DB_CONFIG,\n\t\t     V_TMMODE(mc5->mode == MC5_MODE_72_BIT) |\n\t\t     V_COMPEN(mc5->mode == MC5_MODE_72_BIT) |\n\t\t     V_PRTYEN(mc5->parity_enabled) | F_MBUSEN);\n}\n\n \nint t3_mc5_init(struct mc5 *mc5, unsigned int nservers, unsigned int nfilters,\n\t\tunsigned int nroutes)\n{\n\tu32 cfg;\n\tint err;\n\tunsigned int tcam_size = mc5->tcam_size;\n\tstruct adapter *adap = mc5->adapter;\n\n\tif (!tcam_size)\n\t\treturn 0;\n\n\tif (nroutes > MAX_ROUTES || nroutes + nservers + nfilters > tcam_size)\n\t\treturn -EINVAL;\n\n\t \n\tcfg = t3_read_reg(adap, A_MC5_DB_CONFIG) & ~F_TMMODE;\n\tcfg |= V_TMMODE(mc5->mode == MC5_MODE_72_BIT) | F_TMRST;\n\tt3_write_reg(adap, A_MC5_DB_CONFIG, cfg);\n\tif (t3_wait_op_done(adap, A_MC5_DB_CONFIG, F_TMRDY, 1, 500, 0)) {\n\t\tCH_ERR(adap, \"TCAM reset timed out\\n\");\n\t\treturn -1;\n\t}\n\n\tt3_write_reg(adap, A_MC5_DB_ROUTING_TABLE_INDEX, tcam_size - nroutes);\n\tt3_write_reg(adap, A_MC5_DB_FILTER_TABLE,\n\t\t     tcam_size - nroutes - nfilters);\n\tt3_write_reg(adap, A_MC5_DB_SERVER_INDEX,\n\t\t     tcam_size - nroutes - nfilters - nservers);\n\n\tmc5->parity_enabled = 1;\n\n\t \n\tt3_write_reg(adap, A_MC5_DB_DBGI_REQ_ADDR1, 0);\n\tt3_write_reg(adap, A_MC5_DB_DBGI_REQ_ADDR2, 0);\n\n\tmc5_dbgi_mode_enable(mc5);\n\n\tswitch (mc5->part_type) {\n\tcase IDT75P52100:\n\t\terr = init_idt52100(mc5);\n\t\tbreak;\n\tcase IDT75N43102:\n\t\terr = init_idt43102(mc5);\n\t\tbreak;\n\tdefault:\n\t\tCH_ERR(adap, \"Unsupported TCAM type %d\\n\", mc5->part_type);\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmc5_dbgi_mode_disable(mc5);\n\treturn err;\n}\n\n\n#define MC5_INT_FATAL (F_PARITYERR | F_REQQPARERR | F_DISPQPARERR)\n\n \nvoid t3_mc5_intr_handler(struct mc5 *mc5)\n{\n\tstruct adapter *adap = mc5->adapter;\n\tu32 cause = t3_read_reg(adap, A_MC5_DB_INT_CAUSE);\n\n\tif ((cause & F_PARITYERR) && mc5->parity_enabled) {\n\t\tCH_ALERT(adap, \"MC5 parity error\\n\");\n\t\tmc5->stats.parity_err++;\n\t}\n\n\tif (cause & F_REQQPARERR) {\n\t\tCH_ALERT(adap, \"MC5 request queue parity error\\n\");\n\t\tmc5->stats.reqq_parity_err++;\n\t}\n\n\tif (cause & F_DISPQPARERR) {\n\t\tCH_ALERT(adap, \"MC5 dispatch queue parity error\\n\");\n\t\tmc5->stats.dispq_parity_err++;\n\t}\n\n\tif (cause & F_ACTRGNFULL)\n\t\tmc5->stats.active_rgn_full++;\n\tif (cause & F_NFASRCHFAIL)\n\t\tmc5->stats.nfa_srch_err++;\n\tif (cause & F_UNKNOWNCMD)\n\t\tmc5->stats.unknown_cmd++;\n\tif (cause & F_DELACTEMPTY)\n\t\tmc5->stats.del_act_empty++;\n\tif (cause & MC5_INT_FATAL)\n\t\tt3_fatal_err(adap);\n\n\tt3_write_reg(adap, A_MC5_DB_INT_CAUSE, cause);\n}\n\nvoid t3_mc5_prep(struct adapter *adapter, struct mc5 *mc5, int mode)\n{\n#define K * 1024\n\n\tstatic unsigned int tcam_part_size[] = {\t \n\t\t64 K, 128 K, 256 K, 32 K\n\t};\n\n#undef K\n\n\tu32 cfg = t3_read_reg(adapter, A_MC5_DB_CONFIG);\n\n\tmc5->adapter = adapter;\n\tmc5->mode = (unsigned char)mode;\n\tmc5->part_type = (unsigned char)G_TMTYPE(cfg);\n\tif (cfg & F_TMTYPEHI)\n\t\tmc5->part_type |= 4;\n\n\tmc5->tcam_size = tcam_part_size[G_TMPARTSIZE(cfg)];\n\tif (mode == MC5_MODE_144_BIT)\n\t\tmc5->tcam_size /= 2;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}