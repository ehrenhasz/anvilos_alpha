{
  "module_name": "t3_hw.c",
  "hash_id": "229510b70613ddddb520252edc773abaad65ca574acbe5161e48dc67f72bbc03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb3/t3_hw.c",
  "human_readable_source": " \n#include <linux/etherdevice.h>\n#include \"common.h\"\n#include \"regs.h\"\n#include \"sge_defs.h\"\n#include \"firmware_exports.h\"\n\nstatic void t3_port_intr_clear(struct adapter *adapter, int idx);\n\n \n\nint t3_wait_op_done_val(struct adapter *adapter, int reg, u32 mask,\n\t\t\tint polarity, int attempts, int delay, u32 *valp)\n{\n\twhile (1) {\n\t\tu32 val = t3_read_reg(adapter, reg);\n\n\t\tif (!!(val & mask) == polarity) {\n\t\t\tif (valp)\n\t\t\t\t*valp = val;\n\t\t\treturn 0;\n\t\t}\n\t\tif (--attempts == 0)\n\t\t\treturn -EAGAIN;\n\t\tif (delay)\n\t\t\tudelay(delay);\n\t}\n}\n\n \nvoid t3_write_regs(struct adapter *adapter, const struct addr_val_pair *p,\n\t\t   int n, unsigned int offset)\n{\n\twhile (n--) {\n\t\tt3_write_reg(adapter, p->reg_addr + offset, p->val);\n\t\tp++;\n\t}\n}\n\n \nvoid t3_set_reg_field(struct adapter *adapter, unsigned int addr, u32 mask,\n\t\t      u32 val)\n{\n\tu32 v = t3_read_reg(adapter, addr) & ~mask;\n\n\tt3_write_reg(adapter, addr, v | val);\n\tt3_read_reg(adapter, addr);\t \n}\n\n \nstatic void t3_read_indirect(struct adapter *adap, unsigned int addr_reg,\n\t\t\t     unsigned int data_reg, u32 *vals,\n\t\t\t     unsigned int nregs, unsigned int start_idx)\n{\n\twhile (nregs--) {\n\t\tt3_write_reg(adap, addr_reg, start_idx);\n\t\t*vals++ = t3_read_reg(adap, data_reg);\n\t\tstart_idx++;\n\t}\n}\n\n \nint t3_mc7_bd_read(struct mc7 *mc7, unsigned int start, unsigned int n,\n\t\t   u64 *buf)\n{\n\tstatic const int shift[] = { 0, 0, 16, 24 };\n\tstatic const int step[] = { 0, 32, 16, 8 };\n\n\tunsigned int size64 = mc7->size / 8;\t \n\tstruct adapter *adap = mc7->adapter;\n\n\tif (start >= size64 || start + n > size64)\n\t\treturn -EINVAL;\n\n\tstart *= (8 << mc7->width);\n\twhile (n--) {\n\t\tint i;\n\t\tu64 val64 = 0;\n\n\t\tfor (i = (1 << mc7->width) - 1; i >= 0; --i) {\n\t\t\tint attempts = 10;\n\t\t\tu32 val;\n\n\t\t\tt3_write_reg(adap, mc7->offset + A_MC7_BD_ADDR, start);\n\t\t\tt3_write_reg(adap, mc7->offset + A_MC7_BD_OP, 0);\n\t\t\tval = t3_read_reg(adap, mc7->offset + A_MC7_BD_OP);\n\t\t\twhile ((val & F_BUSY) && attempts--)\n\t\t\t\tval = t3_read_reg(adap,\n\t\t\t\t\t\t  mc7->offset + A_MC7_BD_OP);\n\t\t\tif (val & F_BUSY)\n\t\t\t\treturn -EIO;\n\n\t\t\tval = t3_read_reg(adap, mc7->offset + A_MC7_BD_DATA1);\n\t\t\tif (mc7->width == 0) {\n\t\t\t\tval64 = t3_read_reg(adap,\n\t\t\t\t\t\t    mc7->offset +\n\t\t\t\t\t\t    A_MC7_BD_DATA0);\n\t\t\t\tval64 |= (u64) val << 32;\n\t\t\t} else {\n\t\t\t\tif (mc7->width > 1)\n\t\t\t\t\tval >>= shift[mc7->width];\n\t\t\t\tval64 |= (u64) val << (step[mc7->width] * i);\n\t\t\t}\n\t\t\tstart += 8;\n\t\t}\n\t\t*buf++ = val64;\n\t}\n\treturn 0;\n}\n\n \nstatic void mi1_init(struct adapter *adap, const struct adapter_info *ai)\n{\n\tu32 clkdiv = adap->params.vpd.cclk / (2 * adap->params.vpd.mdc) - 1;\n\tu32 val = F_PREEN | V_CLKDIV(clkdiv);\n\n\tt3_write_reg(adap, A_MI1_CFG, val);\n}\n\n#define MDIO_ATTEMPTS 20\n\n \nstatic int t3_mi1_read(struct net_device *dev, int phy_addr, int mmd_addr,\n\t\t       u16 reg_addr)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tint ret;\n\tu32 addr = V_REGADDR(reg_addr) | V_PHYADDR(phy_addr);\n\n\tmutex_lock(&adapter->mdio_lock);\n\tt3_set_reg_field(adapter, A_MI1_CFG, V_ST(M_ST), V_ST(1));\n\tt3_write_reg(adapter, A_MI1_ADDR, addr);\n\tt3_write_reg(adapter, A_MI1_OP, V_MDI_OP(2));\n\tret = t3_wait_op_done(adapter, A_MI1_OP, F_BUSY, 0, MDIO_ATTEMPTS, 10);\n\tif (!ret)\n\t\tret = t3_read_reg(adapter, A_MI1_DATA);\n\tmutex_unlock(&adapter->mdio_lock);\n\treturn ret;\n}\n\nstatic int t3_mi1_write(struct net_device *dev, int phy_addr, int mmd_addr,\n\t\t\tu16 reg_addr, u16 val)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tint ret;\n\tu32 addr = V_REGADDR(reg_addr) | V_PHYADDR(phy_addr);\n\n\tmutex_lock(&adapter->mdio_lock);\n\tt3_set_reg_field(adapter, A_MI1_CFG, V_ST(M_ST), V_ST(1));\n\tt3_write_reg(adapter, A_MI1_ADDR, addr);\n\tt3_write_reg(adapter, A_MI1_DATA, val);\n\tt3_write_reg(adapter, A_MI1_OP, V_MDI_OP(1));\n\tret = t3_wait_op_done(adapter, A_MI1_OP, F_BUSY, 0, MDIO_ATTEMPTS, 10);\n\tmutex_unlock(&adapter->mdio_lock);\n\treturn ret;\n}\n\nstatic const struct mdio_ops mi1_mdio_ops = {\n\t.read = t3_mi1_read,\n\t.write = t3_mi1_write,\n\t.mode_support = MDIO_SUPPORTS_C22\n};\n\n \nstatic int mi1_wr_addr(struct adapter *adapter, int phy_addr, int mmd_addr,\n\t\t       int reg_addr)\n{\n\tu32 addr = V_REGADDR(mmd_addr) | V_PHYADDR(phy_addr);\n\n\tt3_set_reg_field(adapter, A_MI1_CFG, V_ST(M_ST), 0);\n\tt3_write_reg(adapter, A_MI1_ADDR, addr);\n\tt3_write_reg(adapter, A_MI1_DATA, reg_addr);\n\tt3_write_reg(adapter, A_MI1_OP, V_MDI_OP(0));\n\treturn t3_wait_op_done(adapter, A_MI1_OP, F_BUSY, 0,\n\t\t\t       MDIO_ATTEMPTS, 10);\n}\n\n \nstatic int mi1_ext_read(struct net_device *dev, int phy_addr, int mmd_addr,\n\t\t\tu16 reg_addr)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tint ret;\n\n\tmutex_lock(&adapter->mdio_lock);\n\tret = mi1_wr_addr(adapter, phy_addr, mmd_addr, reg_addr);\n\tif (!ret) {\n\t\tt3_write_reg(adapter, A_MI1_OP, V_MDI_OP(3));\n\t\tret = t3_wait_op_done(adapter, A_MI1_OP, F_BUSY, 0,\n\t\t\t\t      MDIO_ATTEMPTS, 10);\n\t\tif (!ret)\n\t\t\tret = t3_read_reg(adapter, A_MI1_DATA);\n\t}\n\tmutex_unlock(&adapter->mdio_lock);\n\treturn ret;\n}\n\nstatic int mi1_ext_write(struct net_device *dev, int phy_addr, int mmd_addr,\n\t\t\t u16 reg_addr, u16 val)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tint ret;\n\n\tmutex_lock(&adapter->mdio_lock);\n\tret = mi1_wr_addr(adapter, phy_addr, mmd_addr, reg_addr);\n\tif (!ret) {\n\t\tt3_write_reg(adapter, A_MI1_DATA, val);\n\t\tt3_write_reg(adapter, A_MI1_OP, V_MDI_OP(1));\n\t\tret = t3_wait_op_done(adapter, A_MI1_OP, F_BUSY, 0,\n\t\t\t\t      MDIO_ATTEMPTS, 10);\n\t}\n\tmutex_unlock(&adapter->mdio_lock);\n\treturn ret;\n}\n\nstatic const struct mdio_ops mi1_mdio_ext_ops = {\n\t.read = mi1_ext_read,\n\t.write = mi1_ext_write,\n\t.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22\n};\n\n \nint t3_mdio_change_bits(struct cphy *phy, int mmd, int reg, unsigned int clear,\n\t\t\tunsigned int set)\n{\n\tint ret;\n\tunsigned int val;\n\n\tret = t3_mdio_read(phy, mmd, reg, &val);\n\tif (!ret) {\n\t\tval &= ~clear;\n\t\tret = t3_mdio_write(phy, mmd, reg, val | set);\n\t}\n\treturn ret;\n}\n\n \nint t3_phy_reset(struct cphy *phy, int mmd, int wait)\n{\n\tint err;\n\tunsigned int ctl;\n\n\terr = t3_mdio_change_bits(phy, mmd, MDIO_CTRL1, MDIO_CTRL1_LPOWER,\n\t\t\t\t  MDIO_CTRL1_RESET);\n\tif (err || !wait)\n\t\treturn err;\n\n\tdo {\n\t\terr = t3_mdio_read(phy, mmd, MDIO_CTRL1, &ctl);\n\t\tif (err)\n\t\t\treturn err;\n\t\tctl &= MDIO_CTRL1_RESET;\n\t\tif (ctl)\n\t\t\tmsleep(1);\n\t} while (ctl && --wait);\n\n\treturn ctl ? -1 : 0;\n}\n\n \nint t3_phy_advertise(struct cphy *phy, unsigned int advert)\n{\n\tint err;\n\tunsigned int val = 0;\n\n\terr = t3_mdio_read(phy, MDIO_DEVAD_NONE, MII_CTRL1000, &val);\n\tif (err)\n\t\treturn err;\n\n\tval &= ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL);\n\tif (advert & ADVERTISED_1000baseT_Half)\n\t\tval |= ADVERTISE_1000HALF;\n\tif (advert & ADVERTISED_1000baseT_Full)\n\t\tval |= ADVERTISE_1000FULL;\n\n\terr = t3_mdio_write(phy, MDIO_DEVAD_NONE, MII_CTRL1000, val);\n\tif (err)\n\t\treturn err;\n\n\tval = 1;\n\tif (advert & ADVERTISED_10baseT_Half)\n\t\tval |= ADVERTISE_10HALF;\n\tif (advert & ADVERTISED_10baseT_Full)\n\t\tval |= ADVERTISE_10FULL;\n\tif (advert & ADVERTISED_100baseT_Half)\n\t\tval |= ADVERTISE_100HALF;\n\tif (advert & ADVERTISED_100baseT_Full)\n\t\tval |= ADVERTISE_100FULL;\n\tif (advert & ADVERTISED_Pause)\n\t\tval |= ADVERTISE_PAUSE_CAP;\n\tif (advert & ADVERTISED_Asym_Pause)\n\t\tval |= ADVERTISE_PAUSE_ASYM;\n\treturn t3_mdio_write(phy, MDIO_DEVAD_NONE, MII_ADVERTISE, val);\n}\n\n \nint t3_phy_advertise_fiber(struct cphy *phy, unsigned int advert)\n{\n\tunsigned int val = 0;\n\n\tif (advert & ADVERTISED_1000baseT_Half)\n\t\tval |= ADVERTISE_1000XHALF;\n\tif (advert & ADVERTISED_1000baseT_Full)\n\t\tval |= ADVERTISE_1000XFULL;\n\tif (advert & ADVERTISED_Pause)\n\t\tval |= ADVERTISE_1000XPAUSE;\n\tif (advert & ADVERTISED_Asym_Pause)\n\t\tval |= ADVERTISE_1000XPSE_ASYM;\n\treturn t3_mdio_write(phy, MDIO_DEVAD_NONE, MII_ADVERTISE, val);\n}\n\n \nint t3_set_phy_speed_duplex(struct cphy *phy, int speed, int duplex)\n{\n\tint err;\n\tunsigned int ctl;\n\n\terr = t3_mdio_read(phy, MDIO_DEVAD_NONE, MII_BMCR, &ctl);\n\tif (err)\n\t\treturn err;\n\n\tif (speed >= 0) {\n\t\tctl &= ~(BMCR_SPEED100 | BMCR_SPEED1000 | BMCR_ANENABLE);\n\t\tif (speed == SPEED_100)\n\t\t\tctl |= BMCR_SPEED100;\n\t\telse if (speed == SPEED_1000)\n\t\t\tctl |= BMCR_SPEED1000;\n\t}\n\tif (duplex >= 0) {\n\t\tctl &= ~(BMCR_FULLDPLX | BMCR_ANENABLE);\n\t\tif (duplex == DUPLEX_FULL)\n\t\t\tctl |= BMCR_FULLDPLX;\n\t}\n\tif (ctl & BMCR_SPEED1000)  \n\t\tctl |= BMCR_ANENABLE;\n\treturn t3_mdio_write(phy, MDIO_DEVAD_NONE, MII_BMCR, ctl);\n}\n\nint t3_phy_lasi_intr_enable(struct cphy *phy)\n{\n\treturn t3_mdio_write(phy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL,\n\t\t\t     MDIO_PMA_LASI_LSALARM);\n}\n\nint t3_phy_lasi_intr_disable(struct cphy *phy)\n{\n\treturn t3_mdio_write(phy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL, 0);\n}\n\nint t3_phy_lasi_intr_clear(struct cphy *phy)\n{\n\tu32 val;\n\n\treturn t3_mdio_read(phy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_STAT, &val);\n}\n\nint t3_phy_lasi_intr_handler(struct cphy *phy)\n{\n\tunsigned int status;\n\tint err = t3_mdio_read(phy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_STAT,\n\t\t\t       &status);\n\n\tif (err)\n\t\treturn err;\n\treturn (status & MDIO_PMA_LASI_LSALARM) ? cphy_cause_link_change : 0;\n}\n\nstatic const struct adapter_info t3_adap_info[] = {\n\t{1, 1, 0,\n\t F_GPIO2_OEN | F_GPIO4_OEN |\n\t F_GPIO2_OUT_VAL | F_GPIO4_OUT_VAL, { S_GPIO3, S_GPIO5 }, 0,\n\t &mi1_mdio_ops, \"Chelsio PE9000\"},\n\t{1, 1, 0,\n\t F_GPIO2_OEN | F_GPIO4_OEN |\n\t F_GPIO2_OUT_VAL | F_GPIO4_OUT_VAL, { S_GPIO3, S_GPIO5 }, 0,\n\t &mi1_mdio_ops, \"Chelsio T302\"},\n\t{1, 0, 0,\n\t F_GPIO1_OEN | F_GPIO6_OEN | F_GPIO7_OEN | F_GPIO10_OEN |\n\t F_GPIO11_OEN | F_GPIO1_OUT_VAL | F_GPIO6_OUT_VAL | F_GPIO10_OUT_VAL,\n\t { 0 }, SUPPORTED_10000baseT_Full | SUPPORTED_AUI,\n\t &mi1_mdio_ext_ops, \"Chelsio T310\"},\n\t{1, 1, 0,\n\t F_GPIO1_OEN | F_GPIO2_OEN | F_GPIO4_OEN | F_GPIO5_OEN | F_GPIO6_OEN |\n\t F_GPIO7_OEN | F_GPIO10_OEN | F_GPIO11_OEN | F_GPIO1_OUT_VAL |\n\t F_GPIO5_OUT_VAL | F_GPIO6_OUT_VAL | F_GPIO10_OUT_VAL,\n\t { S_GPIO9, S_GPIO3 }, SUPPORTED_10000baseT_Full | SUPPORTED_AUI,\n\t &mi1_mdio_ext_ops, \"Chelsio T320\"},\n\t{},\n\t{},\n\t{1, 0, 0,\n\t F_GPIO1_OEN | F_GPIO2_OEN | F_GPIO4_OEN | F_GPIO6_OEN | F_GPIO7_OEN |\n\t F_GPIO10_OEN | F_GPIO1_OUT_VAL | F_GPIO6_OUT_VAL | F_GPIO10_OUT_VAL,\n\t { S_GPIO9 }, SUPPORTED_10000baseT_Full | SUPPORTED_AUI,\n\t &mi1_mdio_ext_ops, \"Chelsio T310\" },\n\t{1, 0, 0,\n\t F_GPIO1_OEN | F_GPIO6_OEN | F_GPIO7_OEN |\n\t F_GPIO1_OUT_VAL | F_GPIO6_OUT_VAL,\n\t { S_GPIO9 }, SUPPORTED_10000baseT_Full | SUPPORTED_AUI,\n\t &mi1_mdio_ext_ops, \"Chelsio N320E-G2\" },\n};\n\n \nconst struct adapter_info *t3_get_adapter_info(unsigned int id)\n{\n\treturn id < ARRAY_SIZE(t3_adap_info) ? &t3_adap_info[id] : NULL;\n}\n\nstruct port_type_info {\n\tint (*phy_prep)(struct cphy *phy, struct adapter *adapter,\n\t\t\tint phy_addr, const struct mdio_ops *ops);\n};\n\nstatic const struct port_type_info port_types[] = {\n\t{ NULL },\n\t{ t3_ael1002_phy_prep },\n\t{ t3_vsc8211_phy_prep },\n\t{ NULL},\n\t{ t3_xaui_direct_phy_prep },\n\t{ t3_ael2005_phy_prep },\n\t{ t3_qt2045_phy_prep },\n\t{ t3_ael1006_phy_prep },\n\t{ NULL },\n\t{ t3_aq100x_phy_prep },\n\t{ t3_ael2020_phy_prep },\n};\n\n#define VPD_ENTRY(name, len) \\\n\tu8 name##_kword[2]; u8 name##_len; u8 name##_data[len]\n\n \nstruct t3_vpd {\n\tu8 id_tag;\n\tu8 id_len[2];\n\tu8 id_data[16];\n\tu8 vpdr_tag;\n\tu8 vpdr_len[2];\n\tVPD_ENTRY(pn, 16);\t \n\tVPD_ENTRY(ec, 16);\t \n\tVPD_ENTRY(sn, SERNUM_LEN);  \n\tVPD_ENTRY(na, 12);\t \n\tVPD_ENTRY(cclk, 6);\t \n\tVPD_ENTRY(mclk, 6);\t \n\tVPD_ENTRY(uclk, 6);\t \n\tVPD_ENTRY(mdc, 6);\t \n\tVPD_ENTRY(mt, 2);\t \n\tVPD_ENTRY(xaui0cfg, 6);\t \n\tVPD_ENTRY(xaui1cfg, 6);\t \n\tVPD_ENTRY(port0, 2);\t \n\tVPD_ENTRY(port1, 2);\t \n\tVPD_ENTRY(port2, 2);\t \n\tVPD_ENTRY(port3, 2);\t \n\tVPD_ENTRY(rv, 1);\t \n\tu32 pad;\t\t \n};\n\n#define EEPROM_STAT_ADDR  0x4000\n#define VPD_BASE          0xc00\n\n \nint t3_seeprom_wp(struct adapter *adapter, int enable)\n{\n\tu32 data = enable ? 0xc : 0;\n\tint ret;\n\n\t \n\tret = pci_write_vpd_any(adapter->pdev, EEPROM_STAT_ADDR, sizeof(u32),\n\t\t\t\t&data);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int vpdstrtouint(char *s, u8 len, unsigned int base, unsigned int *val)\n{\n\tchar tok[256];\n\n\tmemcpy(tok, s, len);\n\ttok[len] = 0;\n\treturn kstrtouint(strim(tok), base, val);\n}\n\nstatic int vpdstrtou16(char *s, u8 len, unsigned int base, u16 *val)\n{\n\tchar tok[256];\n\n\tmemcpy(tok, s, len);\n\ttok[len] = 0;\n\treturn kstrtou16(strim(tok), base, val);\n}\n\n \nstatic int get_vpd_params(struct adapter *adapter, struct vpd_params *p)\n{\n\tstruct t3_vpd vpd;\n\tu8 base_val = 0;\n\tint addr, ret;\n\n\t \n\tret = pci_read_vpd(adapter->pdev, VPD_BASE, 1, &base_val);\n\tif (ret < 0)\n\t\treturn ret;\n\taddr = base_val == PCI_VPD_LRDT_ID_STRING ? VPD_BASE : 0;\n\n\tret = pci_read_vpd(adapter->pdev, addr, sizeof(vpd), &vpd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = vpdstrtouint(vpd.cclk_data, vpd.cclk_len, 10, &p->cclk);\n\tif (ret)\n\t\treturn ret;\n\tret = vpdstrtouint(vpd.mclk_data, vpd.mclk_len, 10, &p->mclk);\n\tif (ret)\n\t\treturn ret;\n\tret = vpdstrtouint(vpd.uclk_data, vpd.uclk_len, 10, &p->uclk);\n\tif (ret)\n\t\treturn ret;\n\tret = vpdstrtouint(vpd.mdc_data, vpd.mdc_len, 10, &p->mdc);\n\tif (ret)\n\t\treturn ret;\n\tret = vpdstrtouint(vpd.mt_data, vpd.mt_len, 10, &p->mem_timing);\n\tif (ret)\n\t\treturn ret;\n\tmemcpy(p->sn, vpd.sn_data, SERNUM_LEN);\n\n\t \n\tif (adapter->params.rev == 0 && !vpd.port0_data[0]) {\n\t\tp->port_type[0] = uses_xaui(adapter) ? 1 : 2;\n\t\tp->port_type[1] = uses_xaui(adapter) ? 6 : 2;\n\t} else {\n\t\tp->port_type[0] = hex_to_bin(vpd.port0_data[0]);\n\t\tp->port_type[1] = hex_to_bin(vpd.port1_data[0]);\n\t\tret = vpdstrtou16(vpd.xaui0cfg_data, vpd.xaui0cfg_len, 16,\n\t\t\t\t  &p->xauicfg[0]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = vpdstrtou16(vpd.xaui1cfg_data, vpd.xaui1cfg_len, 16,\n\t\t\t\t  &p->xauicfg[1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = hex2bin(p->eth_base, vpd.na_data, 6);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nenum {\n\tSF_ATTEMPTS = 5,\t \n\tSF_SEC_SIZE = 64 * 1024,\t \n\tSF_SIZE = SF_SEC_SIZE * 8,\t \n\n\t \n\tSF_PROG_PAGE = 2,\t \n\tSF_WR_DISABLE = 4,\t \n\tSF_RD_STATUS = 5,\t \n\tSF_WR_ENABLE = 6,\t \n\tSF_RD_DATA_FAST = 0xb,\t \n\tSF_ERASE_SECTOR = 0xd8,\t \n\n\tFW_FLASH_BOOT_ADDR = 0x70000,\t \n\tFW_VERS_ADDR = 0x7fffc,     \n\tFW_MIN_SIZE = 8             \n};\n\n \nstatic int sf1_read(struct adapter *adapter, unsigned int byte_cnt, int cont,\n\t\t    u32 *valp)\n{\n\tint ret;\n\n\tif (!byte_cnt || byte_cnt > 4)\n\t\treturn -EINVAL;\n\tif (t3_read_reg(adapter, A_SF_OP) & F_BUSY)\n\t\treturn -EBUSY;\n\tt3_write_reg(adapter, A_SF_OP, V_CONT(cont) | V_BYTECNT(byte_cnt - 1));\n\tret = t3_wait_op_done(adapter, A_SF_OP, F_BUSY, 0, SF_ATTEMPTS, 10);\n\tif (!ret)\n\t\t*valp = t3_read_reg(adapter, A_SF_DATA);\n\treturn ret;\n}\n\n \nstatic int sf1_write(struct adapter *adapter, unsigned int byte_cnt, int cont,\n\t\t     u32 val)\n{\n\tif (!byte_cnt || byte_cnt > 4)\n\t\treturn -EINVAL;\n\tif (t3_read_reg(adapter, A_SF_OP) & F_BUSY)\n\t\treturn -EBUSY;\n\tt3_write_reg(adapter, A_SF_DATA, val);\n\tt3_write_reg(adapter, A_SF_OP,\n\t\t     V_CONT(cont) | V_BYTECNT(byte_cnt - 1) | V_OP(1));\n\treturn t3_wait_op_done(adapter, A_SF_OP, F_BUSY, 0, SF_ATTEMPTS, 10);\n}\n\n \nstatic int flash_wait_op(struct adapter *adapter, int attempts, int delay)\n{\n\tint ret;\n\tu32 status;\n\n\twhile (1) {\n\t\tif ((ret = sf1_write(adapter, 1, 1, SF_RD_STATUS)) != 0 ||\n\t\t    (ret = sf1_read(adapter, 1, 0, &status)) != 0)\n\t\t\treturn ret;\n\t\tif (!(status & 1))\n\t\t\treturn 0;\n\t\tif (--attempts == 0)\n\t\t\treturn -EAGAIN;\n\t\tif (delay)\n\t\t\tmsleep(delay);\n\t}\n}\n\n \nstatic int t3_read_flash(struct adapter *adapter, unsigned int addr,\n\t\t\t unsigned int nwords, u32 *data, int byte_oriented)\n{\n\tint ret;\n\n\tif (addr + nwords * sizeof(u32) > SF_SIZE || (addr & 3))\n\t\treturn -EINVAL;\n\n\taddr = swab32(addr) | SF_RD_DATA_FAST;\n\n\tif ((ret = sf1_write(adapter, 4, 1, addr)) != 0 ||\n\t    (ret = sf1_read(adapter, 1, 1, data)) != 0)\n\t\treturn ret;\n\n\tfor (; nwords; nwords--, data++) {\n\t\tret = sf1_read(adapter, 4, nwords > 1, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (byte_oriented)\n\t\t\t*data = htonl(*data);\n\t}\n\treturn 0;\n}\n\n \nstatic int t3_write_flash(struct adapter *adapter, unsigned int addr,\n\t\t\t  unsigned int n, const u8 *data)\n{\n\tint ret;\n\tu32 buf[64];\n\tunsigned int i, c, left, val, offset = addr & 0xff;\n\n\tif (addr + n > SF_SIZE || offset + n > 256)\n\t\treturn -EINVAL;\n\n\tval = swab32(addr) | SF_PROG_PAGE;\n\n\tif ((ret = sf1_write(adapter, 1, 0, SF_WR_ENABLE)) != 0 ||\n\t    (ret = sf1_write(adapter, 4, 1, val)) != 0)\n\t\treturn ret;\n\n\tfor (left = n; left; left -= c) {\n\t\tc = min(left, 4U);\n\t\tfor (val = 0, i = 0; i < c; ++i)\n\t\t\tval = (val << 8) + *data++;\n\n\t\tret = sf1_write(adapter, c, c != left, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif ((ret = flash_wait_op(adapter, 5, 1)) != 0)\n\t\treturn ret;\n\n\t \n\tret = t3_read_flash(adapter, addr & ~0xff, ARRAY_SIZE(buf), buf, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (memcmp(data - n, (u8 *) buf + offset, n))\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \nint t3_get_tp_version(struct adapter *adapter, u32 *vers)\n{\n\tint ret;\n\n\t \n\tt3_write_reg(adapter, A_TP_EMBED_OP_FIELD0, 0);\n\tret = t3_wait_op_done(adapter, A_TP_EMBED_OP_FIELD0,\n\t\t\t      1, 1, 5, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t*vers = t3_read_reg(adapter, A_TP_EMBED_OP_FIELD1);\n\n\treturn 0;\n}\n\n \nint t3_check_tpsram_version(struct adapter *adapter)\n{\n\tint ret;\n\tu32 vers;\n\tunsigned int major, minor;\n\n\tif (adapter->params.rev == T3_REV_A)\n\t\treturn 0;\n\n\n\tret = t3_get_tp_version(adapter, &vers);\n\tif (ret)\n\t\treturn ret;\n\n\tmajor = G_TP_VERSION_MAJOR(vers);\n\tminor = G_TP_VERSION_MINOR(vers);\n\n\tif (major == TP_VERSION_MAJOR && minor == TP_VERSION_MINOR)\n\t\treturn 0;\n\telse {\n\t\tCH_ERR(adapter, \"found wrong TP version (%u.%u), \"\n\t\t       \"driver compiled for version %d.%d\\n\", major, minor,\n\t\t       TP_VERSION_MAJOR, TP_VERSION_MINOR);\n\t}\n\treturn -EINVAL;\n}\n\n \nint t3_check_tpsram(struct adapter *adapter, const u8 *tp_sram,\n\t\t    unsigned int size)\n{\n\tu32 csum;\n\tunsigned int i;\n\tconst __be32 *p = (const __be32 *)tp_sram;\n\n\t \n\tfor (csum = 0, i = 0; i < size / sizeof(csum); i++)\n\t\tcsum += ntohl(p[i]);\n\tif (csum != 0xffffffff) {\n\t\tCH_ERR(adapter, \"corrupted protocol SRAM image, checksum %u\\n\",\n\t\t       csum);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nenum fw_version_type {\n\tFW_VERSION_N3,\n\tFW_VERSION_T3\n};\n\n \nint t3_get_fw_version(struct adapter *adapter, u32 *vers)\n{\n\treturn t3_read_flash(adapter, FW_VERS_ADDR, 1, vers, 0);\n}\n\n \nint t3_check_fw_version(struct adapter *adapter)\n{\n\tint ret;\n\tu32 vers;\n\tunsigned int type, major, minor;\n\n\tret = t3_get_fw_version(adapter, &vers);\n\tif (ret)\n\t\treturn ret;\n\n\ttype = G_FW_VERSION_TYPE(vers);\n\tmajor = G_FW_VERSION_MAJOR(vers);\n\tminor = G_FW_VERSION_MINOR(vers);\n\n\tif (type == FW_VERSION_T3 && major == FW_VERSION_MAJOR &&\n\t    minor == FW_VERSION_MINOR)\n\t\treturn 0;\n\telse if (major != FW_VERSION_MAJOR || minor < FW_VERSION_MINOR)\n\t\tCH_WARN(adapter, \"found old FW minor version(%u.%u), \"\n\t\t        \"driver compiled for version %u.%u\\n\", major, minor,\n\t\t\tFW_VERSION_MAJOR, FW_VERSION_MINOR);\n\telse {\n\t\tCH_WARN(adapter, \"found newer FW version(%u.%u), \"\n\t\t        \"driver compiled for version %u.%u\\n\", major, minor,\n\t\t\tFW_VERSION_MAJOR, FW_VERSION_MINOR);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int t3_flash_erase_sectors(struct adapter *adapter, int start, int end)\n{\n\twhile (start <= end) {\n\t\tint ret;\n\n\t\tif ((ret = sf1_write(adapter, 1, 0, SF_WR_ENABLE)) != 0 ||\n\t\t    (ret = sf1_write(adapter, 4, 0,\n\t\t\t\t     SF_ERASE_SECTOR | (start << 8))) != 0 ||\n\t\t    (ret = flash_wait_op(adapter, 5, 500)) != 0)\n\t\t\treturn ret;\n\t\tstart++;\n\t}\n\treturn 0;\n}\n\n \nint t3_load_fw(struct adapter *adapter, const u8 *fw_data, unsigned int size)\n{\n\tu32 csum;\n\tunsigned int i;\n\tconst __be32 *p = (const __be32 *)fw_data;\n\tint ret, addr, fw_sector = FW_FLASH_BOOT_ADDR >> 16;\n\n\tif ((size & 3) || size < FW_MIN_SIZE)\n\t\treturn -EINVAL;\n\tif (size > FW_VERS_ADDR + 8 - FW_FLASH_BOOT_ADDR)\n\t\treturn -EFBIG;\n\n\tfor (csum = 0, i = 0; i < size / sizeof(csum); i++)\n\t\tcsum += ntohl(p[i]);\n\tif (csum != 0xffffffff) {\n\t\tCH_ERR(adapter, \"corrupted firmware image, checksum %u\\n\",\n\t\t       csum);\n\t\treturn -EINVAL;\n\t}\n\n\tret = t3_flash_erase_sectors(adapter, fw_sector, fw_sector);\n\tif (ret)\n\t\tgoto out;\n\n\tsize -= 8;\t\t \n\tfor (addr = FW_FLASH_BOOT_ADDR; size;) {\n\t\tunsigned int chunk_size = min(size, 256U);\n\n\t\tret = t3_write_flash(adapter, addr, chunk_size, fw_data);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\taddr += chunk_size;\n\t\tfw_data += chunk_size;\n\t\tsize -= chunk_size;\n\t}\n\n\tret = t3_write_flash(adapter, FW_VERS_ADDR, 4, fw_data);\nout:\n\tif (ret)\n\t\tCH_ERR(adapter, \"firmware download failed, error %d\\n\", ret);\n\treturn ret;\n}\n\n#define CIM_CTL_BASE 0x2000\n\n \nint t3_cim_ctl_blk_read(struct adapter *adap, unsigned int addr,\n\t\t\tunsigned int n, unsigned int *valp)\n{\n\tint ret = 0;\n\n\tif (t3_read_reg(adap, A_CIM_HOST_ACC_CTRL) & F_HOSTBUSY)\n\t\treturn -EBUSY;\n\n\tfor ( ; !ret && n--; addr += 4) {\n\t\tt3_write_reg(adap, A_CIM_HOST_ACC_CTRL, CIM_CTL_BASE + addr);\n\t\tret = t3_wait_op_done(adap, A_CIM_HOST_ACC_CTRL, F_HOSTBUSY,\n\t\t\t\t      0, 5, 2);\n\t\tif (!ret)\n\t\t\t*valp++ = t3_read_reg(adap, A_CIM_HOST_ACC_DATA);\n\t}\n\treturn ret;\n}\n\nstatic void t3_gate_rx_traffic(struct cmac *mac, u32 *rx_cfg,\n\t\t\t       u32 *rx_hash_high, u32 *rx_hash_low)\n{\n\t \n\tt3_mac_disable_exact_filters(mac);\n\n\t \n\t*rx_cfg = t3_read_reg(mac->adapter, A_XGM_RX_CFG);\n\tt3_set_reg_field(mac->adapter, A_XGM_RX_CFG,\n\t\t\t F_ENHASHMCAST | F_DISBCAST | F_COPYALLFRAMES,\n\t\t\t F_DISBCAST);\n\n\t*rx_hash_high = t3_read_reg(mac->adapter, A_XGM_RX_HASH_HIGH);\n\tt3_write_reg(mac->adapter, A_XGM_RX_HASH_HIGH, 0);\n\n\t*rx_hash_low = t3_read_reg(mac->adapter, A_XGM_RX_HASH_LOW);\n\tt3_write_reg(mac->adapter, A_XGM_RX_HASH_LOW, 0);\n\n\t \n\tmsleep(1);\n}\n\nstatic void t3_open_rx_traffic(struct cmac *mac, u32 rx_cfg,\n\t\t\t       u32 rx_hash_high, u32 rx_hash_low)\n{\n\tt3_mac_enable_exact_filters(mac);\n\tt3_set_reg_field(mac->adapter, A_XGM_RX_CFG,\n\t\t\t F_ENHASHMCAST | F_DISBCAST | F_COPYALLFRAMES,\n\t\t\t rx_cfg);\n\tt3_write_reg(mac->adapter, A_XGM_RX_HASH_HIGH, rx_hash_high);\n\tt3_write_reg(mac->adapter, A_XGM_RX_HASH_LOW, rx_hash_low);\n}\n\n \nvoid t3_link_changed(struct adapter *adapter, int port_id)\n{\n\tint link_ok, speed, duplex, fc;\n\tstruct port_info *pi = adap2pinfo(adapter, port_id);\n\tstruct cphy *phy = &pi->phy;\n\tstruct cmac *mac = &pi->mac;\n\tstruct link_config *lc = &pi->link_config;\n\n\tphy->ops->get_link_status(phy, &link_ok, &speed, &duplex, &fc);\n\n\tif (!lc->link_ok && link_ok) {\n\t\tu32 rx_cfg, rx_hash_high, rx_hash_low;\n\t\tu32 status;\n\n\t\tt3_xgm_intr_enable(adapter, port_id);\n\t\tt3_gate_rx_traffic(mac, &rx_cfg, &rx_hash_high, &rx_hash_low);\n\t\tt3_write_reg(adapter, A_XGM_RX_CTRL + mac->offset, 0);\n\t\tt3_mac_enable(mac, MAC_DIRECTION_RX);\n\n\t\tstatus = t3_read_reg(adapter, A_XGM_INT_STATUS + mac->offset);\n\t\tif (status & F_LINKFAULTCHANGE) {\n\t\t\tmac->stats.link_faults++;\n\t\t\tpi->link_fault = 1;\n\t\t}\n\t\tt3_open_rx_traffic(mac, rx_cfg, rx_hash_high, rx_hash_low);\n\t}\n\n\tif (lc->requested_fc & PAUSE_AUTONEG)\n\t\tfc &= lc->requested_fc;\n\telse\n\t\tfc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);\n\n\tif (link_ok == lc->link_ok && speed == lc->speed &&\n\t    duplex == lc->duplex && fc == lc->fc)\n\t\treturn;                             \n\n\tif (link_ok != lc->link_ok && adapter->params.rev > 0 &&\n\t    uses_xaui(adapter)) {\n\t\tif (link_ok)\n\t\t\tt3b_pcs_reset(mac);\n\t\tt3_write_reg(adapter, A_XGM_XAUI_ACT_CTRL + mac->offset,\n\t\t\t     link_ok ? F_TXACTENABLE | F_RXEN : 0);\n\t}\n\tlc->link_ok = link_ok;\n\tlc->speed = speed < 0 ? SPEED_INVALID : speed;\n\tlc->duplex = duplex < 0 ? DUPLEX_INVALID : duplex;\n\n\tif (link_ok && speed >= 0 && lc->autoneg == AUTONEG_ENABLE) {\n\t\t \n\t\tt3_mac_set_speed_duplex_fc(mac, speed, duplex, fc);\n\t\tlc->fc = fc;\n\t}\n\n\tt3_os_link_changed(adapter, port_id, link_ok && !pi->link_fault,\n\t\t\t   speed, duplex, fc);\n}\n\nvoid t3_link_fault(struct adapter *adapter, int port_id)\n{\n\tstruct port_info *pi = adap2pinfo(adapter, port_id);\n\tstruct cmac *mac = &pi->mac;\n\tstruct cphy *phy = &pi->phy;\n\tstruct link_config *lc = &pi->link_config;\n\tint link_ok, speed, duplex, fc, link_fault;\n\tu32 rx_cfg, rx_hash_high, rx_hash_low;\n\n\tt3_gate_rx_traffic(mac, &rx_cfg, &rx_hash_high, &rx_hash_low);\n\n\tif (adapter->params.rev > 0 && uses_xaui(adapter))\n\t\tt3_write_reg(adapter, A_XGM_XAUI_ACT_CTRL + mac->offset, 0);\n\n\tt3_write_reg(adapter, A_XGM_RX_CTRL + mac->offset, 0);\n\tt3_mac_enable(mac, MAC_DIRECTION_RX);\n\n\tt3_open_rx_traffic(mac, rx_cfg, rx_hash_high, rx_hash_low);\n\n\tlink_fault = t3_read_reg(adapter,\n\t\t\t\t A_XGM_INT_STATUS + mac->offset);\n\tlink_fault &= F_LINKFAULTCHANGE;\n\n\tlink_ok = lc->link_ok;\n\tspeed = lc->speed;\n\tduplex = lc->duplex;\n\tfc = lc->fc;\n\n\tphy->ops->get_link_status(phy, &link_ok, &speed, &duplex, &fc);\n\n\tif (link_fault) {\n\t\tlc->link_ok = 0;\n\t\tlc->speed = SPEED_INVALID;\n\t\tlc->duplex = DUPLEX_INVALID;\n\n\t\tt3_os_link_fault(adapter, port_id, 0);\n\n\t\t \n\t\tif (link_ok)\n\t\t\tmac->stats.link_faults++;\n\t} else {\n\t\tif (link_ok)\n\t\t\tt3_write_reg(adapter, A_XGM_XAUI_ACT_CTRL + mac->offset,\n\t\t\t\t     F_TXACTENABLE | F_RXEN);\n\n\t\tpi->link_fault = 0;\n\t\tlc->link_ok = (unsigned char)link_ok;\n\t\tlc->speed = speed < 0 ? SPEED_INVALID : speed;\n\t\tlc->duplex = duplex < 0 ? DUPLEX_INVALID : duplex;\n\t\tt3_os_link_fault(adapter, port_id, link_ok);\n\t}\n}\n\n \nint t3_link_start(struct cphy *phy, struct cmac *mac, struct link_config *lc)\n{\n\tunsigned int fc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);\n\n\tlc->link_ok = 0;\n\tif (lc->supported & SUPPORTED_Autoneg) {\n\t\tlc->advertising &= ~(ADVERTISED_Asym_Pause | ADVERTISED_Pause);\n\t\tif (fc) {\n\t\t\tlc->advertising |= ADVERTISED_Asym_Pause;\n\t\t\tif (fc & PAUSE_RX)\n\t\t\t\tlc->advertising |= ADVERTISED_Pause;\n\t\t}\n\t\tphy->ops->advertise(phy, lc->advertising);\n\n\t\tif (lc->autoneg == AUTONEG_DISABLE) {\n\t\t\tlc->speed = lc->requested_speed;\n\t\t\tlc->duplex = lc->requested_duplex;\n\t\t\tlc->fc = (unsigned char)fc;\n\t\t\tt3_mac_set_speed_duplex_fc(mac, lc->speed, lc->duplex,\n\t\t\t\t\t\t   fc);\n\t\t\t \n\t\t\tphy->ops->set_speed_duplex(phy, lc->speed, lc->duplex);\n\t\t} else\n\t\t\tphy->ops->autoneg_enable(phy);\n\t} else {\n\t\tt3_mac_set_speed_duplex_fc(mac, -1, -1, fc);\n\t\tlc->fc = (unsigned char)fc;\n\t\tphy->ops->reset(phy, 0);\n\t}\n\treturn 0;\n}\n\n \nvoid t3_set_vlan_accel(struct adapter *adapter, unsigned int ports, int on)\n{\n\tt3_set_reg_field(adapter, A_TP_OUT_CONFIG,\n\t\t\t ports << S_VLANEXTRACTIONENABLE,\n\t\t\t on ? (ports << S_VLANEXTRACTIONENABLE) : 0);\n}\n\nstruct intr_info {\n\tunsigned int mask;\t \n\tconst char *msg;\t \n\tshort stat_idx;\t\t \n\tunsigned short fatal;\t \n};\n\n \nstatic int t3_handle_intr_status(struct adapter *adapter, unsigned int reg,\n\t\t\t\t unsigned int mask,\n\t\t\t\t const struct intr_info *acts,\n\t\t\t\t unsigned long *stats)\n{\n\tint fatal = 0;\n\tunsigned int status = t3_read_reg(adapter, reg) & mask;\n\n\tfor (; acts->mask; ++acts) {\n\t\tif (!(status & acts->mask))\n\t\t\tcontinue;\n\t\tif (acts->fatal) {\n\t\t\tfatal++;\n\t\t\tCH_ALERT(adapter, \"%s (0x%x)\\n\",\n\t\t\t\t acts->msg, status & acts->mask);\n\t\t\tstatus &= ~acts->mask;\n\t\t} else if (acts->msg)\n\t\t\tCH_WARN(adapter, \"%s (0x%x)\\n\",\n\t\t\t\tacts->msg, status & acts->mask);\n\t\tif (acts->stat_idx >= 0)\n\t\t\tstats[acts->stat_idx]++;\n\t}\n\tif (status)\t\t \n\t\tt3_write_reg(adapter, reg, status);\n\treturn fatal;\n}\n\n#define SGE_INTR_MASK (F_RSPQDISABLED | \\\n\t\t       F_UC_REQ_FRAMINGERROR | F_R_REQ_FRAMINGERROR | \\\n\t\t       F_CPPARITYERROR | F_OCPARITYERROR | F_RCPARITYERROR | \\\n\t\t       F_IRPARITYERROR | V_ITPARITYERROR(M_ITPARITYERROR) | \\\n\t\t       V_FLPARITYERROR(M_FLPARITYERROR) | F_LODRBPARITYERROR | \\\n\t\t       F_HIDRBPARITYERROR | F_LORCQPARITYERROR | \\\n\t\t       F_HIRCQPARITYERROR | F_LOPRIORITYDBFULL | \\\n\t\t       F_HIPRIORITYDBFULL | F_LOPRIORITYDBEMPTY | \\\n\t\t       F_HIPRIORITYDBEMPTY | F_HIPIODRBDROPERR | \\\n\t\t       F_LOPIODRBDROPERR)\n#define MC5_INTR_MASK (F_PARITYERR | F_ACTRGNFULL | F_UNKNOWNCMD | \\\n\t\t       F_REQQPARERR | F_DISPQPARERR | F_DELACTEMPTY | \\\n\t\t       F_NFASRCHFAIL)\n#define MC7_INTR_MASK (F_AE | F_UE | F_CE | V_PE(M_PE))\n#define XGM_INTR_MASK (V_TXFIFO_PRTY_ERR(M_TXFIFO_PRTY_ERR) | \\\n\t\t       V_RXFIFO_PRTY_ERR(M_RXFIFO_PRTY_ERR) | \\\n\t\t       F_TXFIFO_UNDERRUN)\n#define PCIX_INTR_MASK (F_MSTDETPARERR | F_SIGTARABT | F_RCVTARABT | \\\n\t\t\tF_RCVMSTABT | F_SIGSYSERR | F_DETPARERR | \\\n\t\t\tF_SPLCMPDIS | F_UNXSPLCMP | F_RCVSPLCMPERR | \\\n\t\t\tF_DETCORECCERR | F_DETUNCECCERR | F_PIOPARERR | \\\n\t\t\tV_WFPARERR(M_WFPARERR) | V_RFPARERR(M_RFPARERR) | \\\n\t\t\tV_CFPARERR(M_CFPARERR)  )\n#define PCIE_INTR_MASK (F_UNXSPLCPLERRR | F_UNXSPLCPLERRC | F_PCIE_PIOPARERR |\\\n\t\t\tF_PCIE_WFPARERR | F_PCIE_RFPARERR | F_PCIE_CFPARERR | \\\n\t\t\t  \\\n\t\t\tF_RETRYBUFPARERR | F_RETRYLUTPARERR | F_RXPARERR | \\\n\t\t\tF_TXPARERR | V_BISTERR(M_BISTERR))\n#define ULPRX_INTR_MASK (F_PARERRDATA | F_PARERRPCMD | F_ARBPF1PERR | \\\n\t\t\t F_ARBPF0PERR | F_ARBFPERR | F_PCMDMUXPERR | \\\n\t\t\t F_DATASELFRAMEERR1 | F_DATASELFRAMEERR0)\n#define ULPTX_INTR_MASK 0xfc\n#define CPLSW_INTR_MASK (F_CIM_OP_MAP_PERR | F_TP_FRAMING_ERROR | \\\n\t\t\t F_SGE_FRAMING_ERROR | F_CIM_FRAMING_ERROR | \\\n\t\t\t F_ZERO_SWITCH_ERROR)\n#define CIM_INTR_MASK (F_BLKWRPLINT | F_BLKRDPLINT | F_BLKWRCTLINT | \\\n\t\t       F_BLKRDCTLINT | F_BLKWRFLASHINT | F_BLKRDFLASHINT | \\\n\t\t       F_SGLWRFLASHINT | F_WRBLKFLASHINT | F_BLKWRBOOTINT | \\\n\t \t       F_FLASHRANGEINT | F_SDRAMRANGEINT | F_RSVDSPACEINT | \\\n\t\t       F_DRAMPARERR | F_ICACHEPARERR | F_DCACHEPARERR | \\\n\t\t       F_OBQSGEPARERR | F_OBQULPHIPARERR | F_OBQULPLOPARERR | \\\n\t\t       F_IBQSGELOPARERR | F_IBQSGEHIPARERR | F_IBQULPPARERR | \\\n\t\t       F_IBQTPPARERR | F_ITAGPARERR | F_DTAGPARERR)\n#define PMTX_INTR_MASK (F_ZERO_C_CMD_ERROR | ICSPI_FRM_ERR | OESPI_FRM_ERR | \\\n\t\t\tV_ICSPI_PAR_ERROR(M_ICSPI_PAR_ERROR) | \\\n\t\t\tV_OESPI_PAR_ERROR(M_OESPI_PAR_ERROR))\n#define PMRX_INTR_MASK (F_ZERO_E_CMD_ERROR | IESPI_FRM_ERR | OCSPI_FRM_ERR | \\\n\t\t\tV_IESPI_PAR_ERROR(M_IESPI_PAR_ERROR) | \\\n\t\t\tV_OCSPI_PAR_ERROR(M_OCSPI_PAR_ERROR))\n#define MPS_INTR_MASK (V_TX0TPPARERRENB(M_TX0TPPARERRENB) | \\\n\t\t       V_TX1TPPARERRENB(M_TX1TPPARERRENB) | \\\n\t\t       V_RXTPPARERRENB(M_RXTPPARERRENB) | \\\n\t\t       V_MCAPARERRENB(M_MCAPARERRENB))\n#define XGM_EXTRA_INTR_MASK (F_LINKFAULTCHANGE)\n#define PL_INTR_MASK (F_T3DBG | F_XGMAC0_0 | F_XGMAC0_1 | F_MC5A | F_PM1_TX | \\\n\t\t      F_PM1_RX | F_ULP2_TX | F_ULP2_RX | F_TP1 | F_CIM | \\\n\t\t      F_MC7_CM | F_MC7_PMTX | F_MC7_PMRX | F_SGE3 | F_PCIM0 | \\\n\t\t      F_MPS0 | F_CPL_SWITCH)\n \nstatic void pci_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info pcix1_intr_info[] = {\n\t\t{F_MSTDETPARERR, \"PCI master detected parity error\", -1, 1},\n\t\t{F_SIGTARABT, \"PCI signaled target abort\", -1, 1},\n\t\t{F_RCVTARABT, \"PCI received target abort\", -1, 1},\n\t\t{F_RCVMSTABT, \"PCI received master abort\", -1, 1},\n\t\t{F_SIGSYSERR, \"PCI signaled system error\", -1, 1},\n\t\t{F_DETPARERR, \"PCI detected parity error\", -1, 1},\n\t\t{F_SPLCMPDIS, \"PCI split completion discarded\", -1, 1},\n\t\t{F_UNXSPLCMP, \"PCI unexpected split completion error\", -1, 1},\n\t\t{F_RCVSPLCMPERR, \"PCI received split completion error\", -1,\n\t\t 1},\n\t\t{F_DETCORECCERR, \"PCI correctable ECC error\",\n\t\t STAT_PCI_CORR_ECC, 0},\n\t\t{F_DETUNCECCERR, \"PCI uncorrectable ECC error\", -1, 1},\n\t\t{F_PIOPARERR, \"PCI PIO FIFO parity error\", -1, 1},\n\t\t{V_WFPARERR(M_WFPARERR), \"PCI write FIFO parity error\", -1,\n\t\t 1},\n\t\t{V_RFPARERR(M_RFPARERR), \"PCI read FIFO parity error\", -1,\n\t\t 1},\n\t\t{V_CFPARERR(M_CFPARERR), \"PCI command FIFO parity error\", -1,\n\t\t 1},\n\t\t{V_MSIXPARERR(M_MSIXPARERR), \"PCI MSI-X table/PBA parity \"\n\t\t \"error\", -1, 1},\n\t\t{0}\n\t};\n\n\tif (t3_handle_intr_status(adapter, A_PCIX_INT_CAUSE, PCIX_INTR_MASK,\n\t\t\t\t  pcix1_intr_info, adapter->irq_stats))\n\t\tt3_fatal_err(adapter);\n}\n\n \nstatic void pcie_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info pcie_intr_info[] = {\n\t\t{F_PEXERR, \"PCI PEX error\", -1, 1},\n\t\t{F_UNXSPLCPLERRR,\n\t\t \"PCI unexpected split completion DMA read error\", -1, 1},\n\t\t{F_UNXSPLCPLERRC,\n\t\t \"PCI unexpected split completion DMA command error\", -1, 1},\n\t\t{F_PCIE_PIOPARERR, \"PCI PIO FIFO parity error\", -1, 1},\n\t\t{F_PCIE_WFPARERR, \"PCI write FIFO parity error\", -1, 1},\n\t\t{F_PCIE_RFPARERR, \"PCI read FIFO parity error\", -1, 1},\n\t\t{F_PCIE_CFPARERR, \"PCI command FIFO parity error\", -1, 1},\n\t\t{V_PCIE_MSIXPARERR(M_PCIE_MSIXPARERR),\n\t\t \"PCI MSI-X table/PBA parity error\", -1, 1},\n\t\t{F_RETRYBUFPARERR, \"PCI retry buffer parity error\", -1, 1},\n\t\t{F_RETRYLUTPARERR, \"PCI retry LUT parity error\", -1, 1},\n\t\t{F_RXPARERR, \"PCI Rx parity error\", -1, 1},\n\t\t{F_TXPARERR, \"PCI Tx parity error\", -1, 1},\n\t\t{V_BISTERR(M_BISTERR), \"PCI BIST error\", -1, 1},\n\t\t{0}\n\t};\n\n\tif (t3_read_reg(adapter, A_PCIE_INT_CAUSE) & F_PEXERR)\n\t\tCH_ALERT(adapter, \"PEX error code 0x%x\\n\",\n\t\t\t t3_read_reg(adapter, A_PCIE_PEX_ERR));\n\n\tif (t3_handle_intr_status(adapter, A_PCIE_INT_CAUSE, PCIE_INTR_MASK,\n\t\t\t\t  pcie_intr_info, adapter->irq_stats))\n\t\tt3_fatal_err(adapter);\n}\n\n \nstatic void tp_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info tp_intr_info[] = {\n\t\t{0xffffff, \"TP parity error\", -1, 1},\n\t\t{0x1000000, \"TP out of Rx pages\", -1, 1},\n\t\t{0x2000000, \"TP out of Tx pages\", -1, 1},\n\t\t{0}\n\t};\n\n\tstatic const struct intr_info tp_intr_info_t3c[] = {\n\t\t{0x1fffffff, \"TP parity error\", -1, 1},\n\t\t{F_FLMRXFLSTEMPTY, \"TP out of Rx pages\", -1, 1},\n\t\t{F_FLMTXFLSTEMPTY, \"TP out of Tx pages\", -1, 1},\n\t\t{0}\n\t};\n\n\tif (t3_handle_intr_status(adapter, A_TP_INT_CAUSE, 0xffffffff,\n\t\t\t\t  adapter->params.rev < T3_REV_C ?\n\t\t\t\t  tp_intr_info : tp_intr_info_t3c, NULL))\n\t\tt3_fatal_err(adapter);\n}\n\n \nstatic void cim_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info cim_intr_info[] = {\n\t\t{F_RSVDSPACEINT, \"CIM reserved space write\", -1, 1},\n\t\t{F_SDRAMRANGEINT, \"CIM SDRAM address out of range\", -1, 1},\n\t\t{F_FLASHRANGEINT, \"CIM flash address out of range\", -1, 1},\n\t\t{F_BLKWRBOOTINT, \"CIM block write to boot space\", -1, 1},\n\t\t{F_WRBLKFLASHINT, \"CIM write to cached flash space\", -1, 1},\n\t\t{F_SGLWRFLASHINT, \"CIM single write to flash space\", -1, 1},\n\t\t{F_BLKRDFLASHINT, \"CIM block read from flash space\", -1, 1},\n\t\t{F_BLKWRFLASHINT, \"CIM block write to flash space\", -1, 1},\n\t\t{F_BLKRDCTLINT, \"CIM block read from CTL space\", -1, 1},\n\t\t{F_BLKWRCTLINT, \"CIM block write to CTL space\", -1, 1},\n\t\t{F_BLKRDPLINT, \"CIM block read from PL space\", -1, 1},\n\t\t{F_BLKWRPLINT, \"CIM block write to PL space\", -1, 1},\n\t\t{F_DRAMPARERR, \"CIM DRAM parity error\", -1, 1},\n\t\t{F_ICACHEPARERR, \"CIM icache parity error\", -1, 1},\n\t\t{F_DCACHEPARERR, \"CIM dcache parity error\", -1, 1},\n\t\t{F_OBQSGEPARERR, \"CIM OBQ SGE parity error\", -1, 1},\n\t\t{F_OBQULPHIPARERR, \"CIM OBQ ULPHI parity error\", -1, 1},\n\t\t{F_OBQULPLOPARERR, \"CIM OBQ ULPLO parity error\", -1, 1},\n\t\t{F_IBQSGELOPARERR, \"CIM IBQ SGELO parity error\", -1, 1},\n\t\t{F_IBQSGEHIPARERR, \"CIM IBQ SGEHI parity error\", -1, 1},\n\t\t{F_IBQULPPARERR, \"CIM IBQ ULP parity error\", -1, 1},\n\t\t{F_IBQTPPARERR, \"CIM IBQ TP parity error\", -1, 1},\n\t\t{F_ITAGPARERR, \"CIM itag parity error\", -1, 1},\n\t\t{F_DTAGPARERR, \"CIM dtag parity error\", -1, 1},\n\t\t{0}\n\t};\n\n\tif (t3_handle_intr_status(adapter, A_CIM_HOST_INT_CAUSE, 0xffffffff,\n\t\t\t\t  cim_intr_info, NULL))\n\t\tt3_fatal_err(adapter);\n}\n\n \nstatic void ulprx_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info ulprx_intr_info[] = {\n\t\t{F_PARERRDATA, \"ULP RX data parity error\", -1, 1},\n\t\t{F_PARERRPCMD, \"ULP RX command parity error\", -1, 1},\n\t\t{F_ARBPF1PERR, \"ULP RX ArbPF1 parity error\", -1, 1},\n\t\t{F_ARBPF0PERR, \"ULP RX ArbPF0 parity error\", -1, 1},\n\t\t{F_ARBFPERR, \"ULP RX ArbF parity error\", -1, 1},\n\t\t{F_PCMDMUXPERR, \"ULP RX PCMDMUX parity error\", -1, 1},\n\t\t{F_DATASELFRAMEERR1, \"ULP RX frame error\", -1, 1},\n\t\t{F_DATASELFRAMEERR0, \"ULP RX frame error\", -1, 1},\n\t\t{0}\n\t};\n\n\tif (t3_handle_intr_status(adapter, A_ULPRX_INT_CAUSE, 0xffffffff,\n\t\t\t\t  ulprx_intr_info, NULL))\n\t\tt3_fatal_err(adapter);\n}\n\n \nstatic void ulptx_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info ulptx_intr_info[] = {\n\t\t{F_PBL_BOUND_ERR_CH0, \"ULP TX channel 0 PBL out of bounds\",\n\t\t STAT_ULP_CH0_PBL_OOB, 0},\n\t\t{F_PBL_BOUND_ERR_CH1, \"ULP TX channel 1 PBL out of bounds\",\n\t\t STAT_ULP_CH1_PBL_OOB, 0},\n\t\t{0xfc, \"ULP TX parity error\", -1, 1},\n\t\t{0}\n\t};\n\n\tif (t3_handle_intr_status(adapter, A_ULPTX_INT_CAUSE, 0xffffffff,\n\t\t\t\t  ulptx_intr_info, adapter->irq_stats))\n\t\tt3_fatal_err(adapter);\n}\n\n#define ICSPI_FRM_ERR (F_ICSPI0_FIFO2X_RX_FRAMING_ERROR | \\\n\tF_ICSPI1_FIFO2X_RX_FRAMING_ERROR | F_ICSPI0_RX_FRAMING_ERROR | \\\n\tF_ICSPI1_RX_FRAMING_ERROR | F_ICSPI0_TX_FRAMING_ERROR | \\\n\tF_ICSPI1_TX_FRAMING_ERROR)\n#define OESPI_FRM_ERR (F_OESPI0_RX_FRAMING_ERROR | \\\n\tF_OESPI1_RX_FRAMING_ERROR | F_OESPI0_TX_FRAMING_ERROR | \\\n\tF_OESPI1_TX_FRAMING_ERROR | F_OESPI0_OFIFO2X_TX_FRAMING_ERROR | \\\n\tF_OESPI1_OFIFO2X_TX_FRAMING_ERROR)\n\n \nstatic void pmtx_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info pmtx_intr_info[] = {\n\t\t{F_ZERO_C_CMD_ERROR, \"PMTX 0-length pcmd\", -1, 1},\n\t\t{ICSPI_FRM_ERR, \"PMTX ispi framing error\", -1, 1},\n\t\t{OESPI_FRM_ERR, \"PMTX ospi framing error\", -1, 1},\n\t\t{V_ICSPI_PAR_ERROR(M_ICSPI_PAR_ERROR),\n\t\t \"PMTX ispi parity error\", -1, 1},\n\t\t{V_OESPI_PAR_ERROR(M_OESPI_PAR_ERROR),\n\t\t \"PMTX ospi parity error\", -1, 1},\n\t\t{0}\n\t};\n\n\tif (t3_handle_intr_status(adapter, A_PM1_TX_INT_CAUSE, 0xffffffff,\n\t\t\t\t  pmtx_intr_info, NULL))\n\t\tt3_fatal_err(adapter);\n}\n\n#define IESPI_FRM_ERR (F_IESPI0_FIFO2X_RX_FRAMING_ERROR | \\\n\tF_IESPI1_FIFO2X_RX_FRAMING_ERROR | F_IESPI0_RX_FRAMING_ERROR | \\\n\tF_IESPI1_RX_FRAMING_ERROR | F_IESPI0_TX_FRAMING_ERROR | \\\n\tF_IESPI1_TX_FRAMING_ERROR)\n#define OCSPI_FRM_ERR (F_OCSPI0_RX_FRAMING_ERROR | \\\n\tF_OCSPI1_RX_FRAMING_ERROR | F_OCSPI0_TX_FRAMING_ERROR | \\\n\tF_OCSPI1_TX_FRAMING_ERROR | F_OCSPI0_OFIFO2X_TX_FRAMING_ERROR | \\\n\tF_OCSPI1_OFIFO2X_TX_FRAMING_ERROR)\n\n \nstatic void pmrx_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info pmrx_intr_info[] = {\n\t\t{F_ZERO_E_CMD_ERROR, \"PMRX 0-length pcmd\", -1, 1},\n\t\t{IESPI_FRM_ERR, \"PMRX ispi framing error\", -1, 1},\n\t\t{OCSPI_FRM_ERR, \"PMRX ospi framing error\", -1, 1},\n\t\t{V_IESPI_PAR_ERROR(M_IESPI_PAR_ERROR),\n\t\t \"PMRX ispi parity error\", -1, 1},\n\t\t{V_OCSPI_PAR_ERROR(M_OCSPI_PAR_ERROR),\n\t\t \"PMRX ospi parity error\", -1, 1},\n\t\t{0}\n\t};\n\n\tif (t3_handle_intr_status(adapter, A_PM1_RX_INT_CAUSE, 0xffffffff,\n\t\t\t\t  pmrx_intr_info, NULL))\n\t\tt3_fatal_err(adapter);\n}\n\n \nstatic void cplsw_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info cplsw_intr_info[] = {\n\t\t{F_CIM_OP_MAP_PERR, \"CPL switch CIM parity error\", -1, 1},\n\t\t{F_CIM_OVFL_ERROR, \"CPL switch CIM overflow\", -1, 1},\n\t\t{F_TP_FRAMING_ERROR, \"CPL switch TP framing error\", -1, 1},\n\t\t{F_SGE_FRAMING_ERROR, \"CPL switch SGE framing error\", -1, 1},\n\t\t{F_CIM_FRAMING_ERROR, \"CPL switch CIM framing error\", -1, 1},\n\t\t{F_ZERO_SWITCH_ERROR, \"CPL switch no-switch error\", -1, 1},\n\t\t{0}\n\t};\n\n\tif (t3_handle_intr_status(adapter, A_CPL_INTR_CAUSE, 0xffffffff,\n\t\t\t\t  cplsw_intr_info, NULL))\n\t\tt3_fatal_err(adapter);\n}\n\n \nstatic void mps_intr_handler(struct adapter *adapter)\n{\n\tstatic const struct intr_info mps_intr_info[] = {\n\t\t{0x1ff, \"MPS parity error\", -1, 1},\n\t\t{0}\n\t};\n\n\tif (t3_handle_intr_status(adapter, A_MPS_INT_CAUSE, 0xffffffff,\n\t\t\t\t  mps_intr_info, NULL))\n\t\tt3_fatal_err(adapter);\n}\n\n#define MC7_INTR_FATAL (F_UE | V_PE(M_PE) | F_AE)\n\n \nstatic void mc7_intr_handler(struct mc7 *mc7)\n{\n\tstruct adapter *adapter = mc7->adapter;\n\tu32 cause = t3_read_reg(adapter, mc7->offset + A_MC7_INT_CAUSE);\n\n\tif (cause & F_CE) {\n\t\tmc7->stats.corr_err++;\n\t\tCH_WARN(adapter, \"%s MC7 correctable error at addr 0x%x, \"\n\t\t\t\"data 0x%x 0x%x 0x%x\\n\", mc7->name,\n\t\t\tt3_read_reg(adapter, mc7->offset + A_MC7_CE_ADDR),\n\t\t\tt3_read_reg(adapter, mc7->offset + A_MC7_CE_DATA0),\n\t\t\tt3_read_reg(adapter, mc7->offset + A_MC7_CE_DATA1),\n\t\t\tt3_read_reg(adapter, mc7->offset + A_MC7_CE_DATA2));\n\t}\n\n\tif (cause & F_UE) {\n\t\tmc7->stats.uncorr_err++;\n\t\tCH_ALERT(adapter, \"%s MC7 uncorrectable error at addr 0x%x, \"\n\t\t\t \"data 0x%x 0x%x 0x%x\\n\", mc7->name,\n\t\t\t t3_read_reg(adapter, mc7->offset + A_MC7_UE_ADDR),\n\t\t\t t3_read_reg(adapter, mc7->offset + A_MC7_UE_DATA0),\n\t\t\t t3_read_reg(adapter, mc7->offset + A_MC7_UE_DATA1),\n\t\t\t t3_read_reg(adapter, mc7->offset + A_MC7_UE_DATA2));\n\t}\n\n\tif (G_PE(cause)) {\n\t\tmc7->stats.parity_err++;\n\t\tCH_ALERT(adapter, \"%s MC7 parity error 0x%x\\n\",\n\t\t\t mc7->name, G_PE(cause));\n\t}\n\n\tif (cause & F_AE) {\n\t\tu32 addr = 0;\n\n\t\tif (adapter->params.rev > 0)\n\t\t\taddr = t3_read_reg(adapter,\n\t\t\t\t\t   mc7->offset + A_MC7_ERR_ADDR);\n\t\tmc7->stats.addr_err++;\n\t\tCH_ALERT(adapter, \"%s MC7 address error: 0x%x\\n\",\n\t\t\t mc7->name, addr);\n\t}\n\n\tif (cause & MC7_INTR_FATAL)\n\t\tt3_fatal_err(adapter);\n\n\tt3_write_reg(adapter, mc7->offset + A_MC7_INT_CAUSE, cause);\n}\n\n#define XGM_INTR_FATAL (V_TXFIFO_PRTY_ERR(M_TXFIFO_PRTY_ERR) | \\\n\t\t\tV_RXFIFO_PRTY_ERR(M_RXFIFO_PRTY_ERR))\n \nstatic int mac_intr_handler(struct adapter *adap, unsigned int idx)\n{\n\tstruct cmac *mac = &adap2pinfo(adap, idx)->mac;\n\t \n\tu32 cause = t3_read_reg(adap, A_XGM_INT_CAUSE + mac->offset) &\n\t\t    ~F_RXFIFO_OVERFLOW;\n\n\tif (cause & V_TXFIFO_PRTY_ERR(M_TXFIFO_PRTY_ERR)) {\n\t\tmac->stats.tx_fifo_parity_err++;\n\t\tCH_ALERT(adap, \"port%d: MAC TX FIFO parity error\\n\", idx);\n\t}\n\tif (cause & V_RXFIFO_PRTY_ERR(M_RXFIFO_PRTY_ERR)) {\n\t\tmac->stats.rx_fifo_parity_err++;\n\t\tCH_ALERT(adap, \"port%d: MAC RX FIFO parity error\\n\", idx);\n\t}\n\tif (cause & F_TXFIFO_UNDERRUN)\n\t\tmac->stats.tx_fifo_urun++;\n\tif (cause & F_RXFIFO_OVERFLOW)\n\t\tmac->stats.rx_fifo_ovfl++;\n\tif (cause & V_SERDES_LOS(M_SERDES_LOS))\n\t\tmac->stats.serdes_signal_loss++;\n\tif (cause & F_XAUIPCSCTCERR)\n\t\tmac->stats.xaui_pcs_ctc_err++;\n\tif (cause & F_XAUIPCSALIGNCHANGE)\n\t\tmac->stats.xaui_pcs_align_change++;\n\tif (cause & F_XGM_INT) {\n\t\tt3_set_reg_field(adap,\n\t\t\t\t A_XGM_INT_ENABLE + mac->offset,\n\t\t\t\t F_XGM_INT, 0);\n\t\tmac->stats.link_faults++;\n\n\t\tt3_os_link_fault_handler(adap, idx);\n\t}\n\n\tif (cause & XGM_INTR_FATAL)\n\t\tt3_fatal_err(adap);\n\n\tt3_write_reg(adap, A_XGM_INT_CAUSE + mac->offset, cause);\n\treturn cause != 0;\n}\n\n \nint t3_phy_intr_handler(struct adapter *adapter)\n{\n\tu32 i, cause = t3_read_reg(adapter, A_T3DBG_INT_CAUSE);\n\n\tfor_each_port(adapter, i) {\n\t\tstruct port_info *p = adap2pinfo(adapter, i);\n\n\t\tif (!(p->phy.caps & SUPPORTED_IRQ))\n\t\t\tcontinue;\n\n\t\tif (cause & (1 << adapter_info(adapter)->gpio_intr[i])) {\n\t\t\tint phy_cause = p->phy.ops->intr_handler(&p->phy);\n\n\t\t\tif (phy_cause & cphy_cause_link_change)\n\t\t\t\tt3_link_changed(adapter, i);\n\t\t\tif (phy_cause & cphy_cause_fifo_error)\n\t\t\t\tp->phy.fifo_errors++;\n\t\t\tif (phy_cause & cphy_cause_module_change)\n\t\t\t\tt3_os_phymod_changed(adapter, i);\n\t\t}\n\t}\n\n\tt3_write_reg(adapter, A_T3DBG_INT_CAUSE, cause);\n\treturn 0;\n}\n\n \nint t3_slow_intr_handler(struct adapter *adapter)\n{\n\tu32 cause = t3_read_reg(adapter, A_PL_INT_CAUSE0);\n\n\tcause &= adapter->slow_intr_mask;\n\tif (!cause)\n\t\treturn 0;\n\tif (cause & F_PCIM0) {\n\t\tif (is_pcie(adapter))\n\t\t\tpcie_intr_handler(adapter);\n\t\telse\n\t\t\tpci_intr_handler(adapter);\n\t}\n\tif (cause & F_SGE3)\n\t\tt3_sge_err_intr_handler(adapter);\n\tif (cause & F_MC7_PMRX)\n\t\tmc7_intr_handler(&adapter->pmrx);\n\tif (cause & F_MC7_PMTX)\n\t\tmc7_intr_handler(&adapter->pmtx);\n\tif (cause & F_MC7_CM)\n\t\tmc7_intr_handler(&adapter->cm);\n\tif (cause & F_CIM)\n\t\tcim_intr_handler(adapter);\n\tif (cause & F_TP1)\n\t\ttp_intr_handler(adapter);\n\tif (cause & F_ULP2_RX)\n\t\tulprx_intr_handler(adapter);\n\tif (cause & F_ULP2_TX)\n\t\tulptx_intr_handler(adapter);\n\tif (cause & F_PM1_RX)\n\t\tpmrx_intr_handler(adapter);\n\tif (cause & F_PM1_TX)\n\t\tpmtx_intr_handler(adapter);\n\tif (cause & F_CPL_SWITCH)\n\t\tcplsw_intr_handler(adapter);\n\tif (cause & F_MPS0)\n\t\tmps_intr_handler(adapter);\n\tif (cause & F_MC5A)\n\t\tt3_mc5_intr_handler(&adapter->mc5);\n\tif (cause & F_XGMAC0_0)\n\t\tmac_intr_handler(adapter, 0);\n\tif (cause & F_XGMAC0_1)\n\t\tmac_intr_handler(adapter, 1);\n\tif (cause & F_T3DBG)\n\t\tt3_os_ext_intr_handler(adapter);\n\n\t \n\tt3_write_reg(adapter, A_PL_INT_CAUSE0, cause);\n\tt3_read_reg(adapter, A_PL_INT_CAUSE0);\t \n\treturn 1;\n}\n\nstatic unsigned int calc_gpio_intr(struct adapter *adap)\n{\n\tunsigned int i, gpi_intr = 0;\n\n\tfor_each_port(adap, i)\n\t\tif ((adap2pinfo(adap, i)->phy.caps & SUPPORTED_IRQ) &&\n\t\t    adapter_info(adap)->gpio_intr[i])\n\t\t\tgpi_intr |= 1 << adapter_info(adap)->gpio_intr[i];\n\treturn gpi_intr;\n}\n\n \nvoid t3_intr_enable(struct adapter *adapter)\n{\n\tstatic const struct addr_val_pair intr_en_avp[] = {\n\t\t{A_SG_INT_ENABLE, SGE_INTR_MASK},\n\t\t{A_MC7_INT_ENABLE, MC7_INTR_MASK},\n\t\t{A_MC7_INT_ENABLE - MC7_PMRX_BASE_ADDR + MC7_PMTX_BASE_ADDR,\n\t\t MC7_INTR_MASK},\n\t\t{A_MC7_INT_ENABLE - MC7_PMRX_BASE_ADDR + MC7_CM_BASE_ADDR,\n\t\t MC7_INTR_MASK},\n\t\t{A_MC5_DB_INT_ENABLE, MC5_INTR_MASK},\n\t\t{A_ULPRX_INT_ENABLE, ULPRX_INTR_MASK},\n\t\t{A_PM1_TX_INT_ENABLE, PMTX_INTR_MASK},\n\t\t{A_PM1_RX_INT_ENABLE, PMRX_INTR_MASK},\n\t\t{A_CIM_HOST_INT_ENABLE, CIM_INTR_MASK},\n\t\t{A_MPS_INT_ENABLE, MPS_INTR_MASK},\n\t};\n\n\tadapter->slow_intr_mask = PL_INTR_MASK;\n\n\tt3_write_regs(adapter, intr_en_avp, ARRAY_SIZE(intr_en_avp), 0);\n\tt3_write_reg(adapter, A_TP_INT_ENABLE,\n\t\t     adapter->params.rev >= T3_REV_C ? 0x2bfffff : 0x3bfffff);\n\n\tif (adapter->params.rev > 0) {\n\t\tt3_write_reg(adapter, A_CPL_INTR_ENABLE,\n\t\t\t     CPLSW_INTR_MASK | F_CIM_OVFL_ERROR);\n\t\tt3_write_reg(adapter, A_ULPTX_INT_ENABLE,\n\t\t\t     ULPTX_INTR_MASK | F_PBL_BOUND_ERR_CH0 |\n\t\t\t     F_PBL_BOUND_ERR_CH1);\n\t} else {\n\t\tt3_write_reg(adapter, A_CPL_INTR_ENABLE, CPLSW_INTR_MASK);\n\t\tt3_write_reg(adapter, A_ULPTX_INT_ENABLE, ULPTX_INTR_MASK);\n\t}\n\n\tt3_write_reg(adapter, A_T3DBG_INT_ENABLE, calc_gpio_intr(adapter));\n\n\tif (is_pcie(adapter))\n\t\tt3_write_reg(adapter, A_PCIE_INT_ENABLE, PCIE_INTR_MASK);\n\telse\n\t\tt3_write_reg(adapter, A_PCIX_INT_ENABLE, PCIX_INTR_MASK);\n\tt3_write_reg(adapter, A_PL_INT_ENABLE0, adapter->slow_intr_mask);\n\tt3_read_reg(adapter, A_PL_INT_ENABLE0);\t \n}\n\n \nvoid t3_intr_disable(struct adapter *adapter)\n{\n\tt3_write_reg(adapter, A_PL_INT_ENABLE0, 0);\n\tt3_read_reg(adapter, A_PL_INT_ENABLE0);\t \n\tadapter->slow_intr_mask = 0;\n}\n\n \nvoid t3_intr_clear(struct adapter *adapter)\n{\n\tstatic const unsigned int cause_reg_addr[] = {\n\t\tA_SG_INT_CAUSE,\n\t\tA_SG_RSPQ_FL_STATUS,\n\t\tA_PCIX_INT_CAUSE,\n\t\tA_MC7_INT_CAUSE,\n\t\tA_MC7_INT_CAUSE - MC7_PMRX_BASE_ADDR + MC7_PMTX_BASE_ADDR,\n\t\tA_MC7_INT_CAUSE - MC7_PMRX_BASE_ADDR + MC7_CM_BASE_ADDR,\n\t\tA_CIM_HOST_INT_CAUSE,\n\t\tA_TP_INT_CAUSE,\n\t\tA_MC5_DB_INT_CAUSE,\n\t\tA_ULPRX_INT_CAUSE,\n\t\tA_ULPTX_INT_CAUSE,\n\t\tA_CPL_INTR_CAUSE,\n\t\tA_PM1_TX_INT_CAUSE,\n\t\tA_PM1_RX_INT_CAUSE,\n\t\tA_MPS_INT_CAUSE,\n\t\tA_T3DBG_INT_CAUSE,\n\t};\n\tunsigned int i;\n\n\t \n\tfor_each_port(adapter, i)\n\t    t3_port_intr_clear(adapter, i);\n\n\tfor (i = 0; i < ARRAY_SIZE(cause_reg_addr); ++i)\n\t\tt3_write_reg(adapter, cause_reg_addr[i], 0xffffffff);\n\n\tif (is_pcie(adapter))\n\t\tt3_write_reg(adapter, A_PCIE_PEX_ERR, 0xffffffff);\n\tt3_write_reg(adapter, A_PL_INT_CAUSE0, 0xffffffff);\n\tt3_read_reg(adapter, A_PL_INT_CAUSE0);\t \n}\n\nvoid t3_xgm_intr_enable(struct adapter *adapter, int idx)\n{\n\tstruct port_info *pi = adap2pinfo(adapter, idx);\n\n\tt3_write_reg(adapter, A_XGM_XGM_INT_ENABLE + pi->mac.offset,\n\t\t     XGM_EXTRA_INTR_MASK);\n}\n\nvoid t3_xgm_intr_disable(struct adapter *adapter, int idx)\n{\n\tstruct port_info *pi = adap2pinfo(adapter, idx);\n\n\tt3_write_reg(adapter, A_XGM_XGM_INT_DISABLE + pi->mac.offset,\n\t\t     0x7ff);\n}\n\n \nvoid t3_port_intr_enable(struct adapter *adapter, int idx)\n{\n\tstruct cphy *phy = &adap2pinfo(adapter, idx)->phy;\n\n\tt3_write_reg(adapter, XGM_REG(A_XGM_INT_ENABLE, idx), XGM_INTR_MASK);\n\tt3_read_reg(adapter, XGM_REG(A_XGM_INT_ENABLE, idx));  \n\tphy->ops->intr_enable(phy);\n}\n\n \nvoid t3_port_intr_disable(struct adapter *adapter, int idx)\n{\n\tstruct cphy *phy = &adap2pinfo(adapter, idx)->phy;\n\n\tt3_write_reg(adapter, XGM_REG(A_XGM_INT_ENABLE, idx), 0);\n\tt3_read_reg(adapter, XGM_REG(A_XGM_INT_ENABLE, idx));  \n\tphy->ops->intr_disable(phy);\n}\n\n \nstatic void t3_port_intr_clear(struct adapter *adapter, int idx)\n{\n\tstruct cphy *phy = &adap2pinfo(adapter, idx)->phy;\n\n\tt3_write_reg(adapter, XGM_REG(A_XGM_INT_CAUSE, idx), 0xffffffff);\n\tt3_read_reg(adapter, XGM_REG(A_XGM_INT_CAUSE, idx));  \n\tphy->ops->intr_clear(phy);\n}\n\n#define SG_CONTEXT_CMD_ATTEMPTS 100\n\n \nstatic int t3_sge_write_context(struct adapter *adapter, unsigned int id,\n\t\t\t\tunsigned int type)\n{\n\tif (type == F_RESPONSEQ) {\n\t\t \n\t\tt3_write_reg(adapter, A_SG_CONTEXT_MASK0, 0xffffffff);\n\t\tt3_write_reg(adapter, A_SG_CONTEXT_MASK1, 0xffffffff);\n\t\tt3_write_reg(adapter, A_SG_CONTEXT_MASK2, 0x17ffffff);\n\t\tt3_write_reg(adapter, A_SG_CONTEXT_MASK3, 0xffffffff);\n\t} else {\n\t\tt3_write_reg(adapter, A_SG_CONTEXT_MASK0, 0xffffffff);\n\t\tt3_write_reg(adapter, A_SG_CONTEXT_MASK1, 0xffffffff);\n\t\tt3_write_reg(adapter, A_SG_CONTEXT_MASK2, 0xffffffff);\n\t\tt3_write_reg(adapter, A_SG_CONTEXT_MASK3, 0xffffffff);\n\t}\n\tt3_write_reg(adapter, A_SG_CONTEXT_CMD,\n\t\t     V_CONTEXT_CMD_OPCODE(1) | type | V_CONTEXT(id));\n\treturn t3_wait_op_done(adapter, A_SG_CONTEXT_CMD, F_CONTEXT_CMD_BUSY,\n\t\t\t       0, SG_CONTEXT_CMD_ATTEMPTS, 1);\n}\n\n \nstatic int clear_sge_ctxt(struct adapter *adap, unsigned int id,\n\t\t\t  unsigned int type)\n{\n\tt3_write_reg(adap, A_SG_CONTEXT_DATA0, 0);\n\tt3_write_reg(adap, A_SG_CONTEXT_DATA1, 0);\n\tt3_write_reg(adap, A_SG_CONTEXT_DATA2, 0);\n\tt3_write_reg(adap, A_SG_CONTEXT_DATA3, 0);\n\tt3_write_reg(adap, A_SG_CONTEXT_MASK0, 0xffffffff);\n\tt3_write_reg(adap, A_SG_CONTEXT_MASK1, 0xffffffff);\n\tt3_write_reg(adap, A_SG_CONTEXT_MASK2, 0xffffffff);\n\tt3_write_reg(adap, A_SG_CONTEXT_MASK3, 0xffffffff);\n\tt3_write_reg(adap, A_SG_CONTEXT_CMD,\n\t\t     V_CONTEXT_CMD_OPCODE(1) | type | V_CONTEXT(id));\n\treturn t3_wait_op_done(adap, A_SG_CONTEXT_CMD, F_CONTEXT_CMD_BUSY,\n\t\t\t       0, SG_CONTEXT_CMD_ATTEMPTS, 1);\n}\n\n \nint t3_sge_init_ecntxt(struct adapter *adapter, unsigned int id, int gts_enable,\n\t\t       enum sge_context_type type, int respq, u64 base_addr,\n\t\t       unsigned int size, unsigned int token, int gen,\n\t\t       unsigned int cidx)\n{\n\tunsigned int credits = type == SGE_CNTXT_OFLD ? 0 : FW_WR_NUM;\n\n\tif (base_addr & 0xfff)\t \n\t\treturn -EINVAL;\n\tif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\n\t\treturn -EBUSY;\n\n\tbase_addr >>= 12;\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA0, V_EC_INDEX(cidx) |\n\t\t     V_EC_CREDITS(credits) | V_EC_GTS(gts_enable));\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA1, V_EC_SIZE(size) |\n\t\t     V_EC_BASE_LO(base_addr & 0xffff));\n\tbase_addr >>= 16;\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA2, base_addr);\n\tbase_addr >>= 32;\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA3,\n\t\t     V_EC_BASE_HI(base_addr & 0xf) | V_EC_RESPQ(respq) |\n\t\t     V_EC_TYPE(type) | V_EC_GEN(gen) | V_EC_UP_TOKEN(token) |\n\t\t     F_EC_VALID);\n\treturn t3_sge_write_context(adapter, id, F_EGRESS);\n}\n\n \nint t3_sge_init_flcntxt(struct adapter *adapter, unsigned int id,\n\t\t\tint gts_enable, u64 base_addr, unsigned int size,\n\t\t\tunsigned int bsize, unsigned int cong_thres, int gen,\n\t\t\tunsigned int cidx)\n{\n\tif (base_addr & 0xfff)\t \n\t\treturn -EINVAL;\n\tif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\n\t\treturn -EBUSY;\n\n\tbase_addr >>= 12;\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA0, base_addr);\n\tbase_addr >>= 32;\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA1,\n\t\t     V_FL_BASE_HI((u32) base_addr) |\n\t\t     V_FL_INDEX_LO(cidx & M_FL_INDEX_LO));\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA2, V_FL_SIZE(size) |\n\t\t     V_FL_GEN(gen) | V_FL_INDEX_HI(cidx >> 12) |\n\t\t     V_FL_ENTRY_SIZE_LO(bsize & M_FL_ENTRY_SIZE_LO));\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA3,\n\t\t     V_FL_ENTRY_SIZE_HI(bsize >> (32 - S_FL_ENTRY_SIZE_LO)) |\n\t\t     V_FL_CONG_THRES(cong_thres) | V_FL_GTS(gts_enable));\n\treturn t3_sge_write_context(adapter, id, F_FREELIST);\n}\n\n \nint t3_sge_init_rspcntxt(struct adapter *adapter, unsigned int id,\n\t\t\t int irq_vec_idx, u64 base_addr, unsigned int size,\n\t\t\t unsigned int fl_thres, int gen, unsigned int cidx)\n{\n\tunsigned int intr = 0;\n\n\tif (base_addr & 0xfff)\t \n\t\treturn -EINVAL;\n\tif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\n\t\treturn -EBUSY;\n\n\tbase_addr >>= 12;\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA0, V_CQ_SIZE(size) |\n\t\t     V_CQ_INDEX(cidx));\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA1, base_addr);\n\tbase_addr >>= 32;\n\tif (irq_vec_idx >= 0)\n\t\tintr = V_RQ_MSI_VEC(irq_vec_idx) | F_RQ_INTR_EN;\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA2,\n\t\t     V_CQ_BASE_HI((u32) base_addr) | intr | V_RQ_GEN(gen));\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA3, fl_thres);\n\treturn t3_sge_write_context(adapter, id, F_RESPONSEQ);\n}\n\n \nint t3_sge_init_cqcntxt(struct adapter *adapter, unsigned int id, u64 base_addr,\n\t\t\tunsigned int size, int rspq, int ovfl_mode,\n\t\t\tunsigned int credits, unsigned int credit_thres)\n{\n\tif (base_addr & 0xfff)\t \n\t\treturn -EINVAL;\n\tif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\n\t\treturn -EBUSY;\n\n\tbase_addr >>= 12;\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA0, V_CQ_SIZE(size));\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA1, base_addr);\n\tbase_addr >>= 32;\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA2,\n\t\t     V_CQ_BASE_HI((u32) base_addr) | V_CQ_RSPQ(rspq) |\n\t\t     V_CQ_GEN(1) | V_CQ_OVERFLOW_MODE(ovfl_mode) |\n\t\t     V_CQ_ERR(ovfl_mode));\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA3, V_CQ_CREDITS(credits) |\n\t\t     V_CQ_CREDIT_THRES(credit_thres));\n\treturn t3_sge_write_context(adapter, id, F_CQ);\n}\n\n \nint t3_sge_enable_ecntxt(struct adapter *adapter, unsigned int id, int enable)\n{\n\tif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\n\t\treturn -EBUSY;\n\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK0, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK1, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK2, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK3, F_EC_VALID);\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA3, V_EC_VALID(enable));\n\tt3_write_reg(adapter, A_SG_CONTEXT_CMD,\n\t\t     V_CONTEXT_CMD_OPCODE(1) | F_EGRESS | V_CONTEXT(id));\n\treturn t3_wait_op_done(adapter, A_SG_CONTEXT_CMD, F_CONTEXT_CMD_BUSY,\n\t\t\t       0, SG_CONTEXT_CMD_ATTEMPTS, 1);\n}\n\n \nint t3_sge_disable_fl(struct adapter *adapter, unsigned int id)\n{\n\tif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\n\t\treturn -EBUSY;\n\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK0, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK1, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK2, V_FL_SIZE(M_FL_SIZE));\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK3, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA2, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_CMD,\n\t\t     V_CONTEXT_CMD_OPCODE(1) | F_FREELIST | V_CONTEXT(id));\n\treturn t3_wait_op_done(adapter, A_SG_CONTEXT_CMD, F_CONTEXT_CMD_BUSY,\n\t\t\t       0, SG_CONTEXT_CMD_ATTEMPTS, 1);\n}\n\n \nint t3_sge_disable_rspcntxt(struct adapter *adapter, unsigned int id)\n{\n\tif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\n\t\treturn -EBUSY;\n\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK0, V_CQ_SIZE(M_CQ_SIZE));\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK1, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK2, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK3, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA0, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_CMD,\n\t\t     V_CONTEXT_CMD_OPCODE(1) | F_RESPONSEQ | V_CONTEXT(id));\n\treturn t3_wait_op_done(adapter, A_SG_CONTEXT_CMD, F_CONTEXT_CMD_BUSY,\n\t\t\t       0, SG_CONTEXT_CMD_ATTEMPTS, 1);\n}\n\n \nint t3_sge_disable_cqcntxt(struct adapter *adapter, unsigned int id)\n{\n\tif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\n\t\treturn -EBUSY;\n\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK0, V_CQ_SIZE(M_CQ_SIZE));\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK1, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK2, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_MASK3, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA0, 0);\n\tt3_write_reg(adapter, A_SG_CONTEXT_CMD,\n\t\t     V_CONTEXT_CMD_OPCODE(1) | F_CQ | V_CONTEXT(id));\n\treturn t3_wait_op_done(adapter, A_SG_CONTEXT_CMD, F_CONTEXT_CMD_BUSY,\n\t\t\t       0, SG_CONTEXT_CMD_ATTEMPTS, 1);\n}\n\n \nint t3_sge_cqcntxt_op(struct adapter *adapter, unsigned int id, unsigned int op,\n\t\t      unsigned int credits)\n{\n\tu32 val;\n\n\tif (t3_read_reg(adapter, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\n\t\treturn -EBUSY;\n\n\tt3_write_reg(adapter, A_SG_CONTEXT_DATA0, credits << 16);\n\tt3_write_reg(adapter, A_SG_CONTEXT_CMD, V_CONTEXT_CMD_OPCODE(op) |\n\t\t     V_CONTEXT(id) | F_CQ);\n\tif (t3_wait_op_done_val(adapter, A_SG_CONTEXT_CMD, F_CONTEXT_CMD_BUSY,\n\t\t\t\t0, SG_CONTEXT_CMD_ATTEMPTS, 1, &val))\n\t\treturn -EIO;\n\n\tif (op >= 2 && op < 7) {\n\t\tif (adapter->params.rev > 0)\n\t\t\treturn G_CQ_INDEX(val);\n\n\t\tt3_write_reg(adapter, A_SG_CONTEXT_CMD,\n\t\t\t     V_CONTEXT_CMD_OPCODE(0) | F_CQ | V_CONTEXT(id));\n\t\tif (t3_wait_op_done(adapter, A_SG_CONTEXT_CMD,\n\t\t\t\t    F_CONTEXT_CMD_BUSY, 0,\n\t\t\t\t    SG_CONTEXT_CMD_ATTEMPTS, 1))\n\t\t\treturn -EIO;\n\t\treturn G_CQ_INDEX(t3_read_reg(adapter, A_SG_CONTEXT_DATA0));\n\t}\n\treturn 0;\n}\n\n \nvoid t3_config_rss(struct adapter *adapter, unsigned int rss_config,\n\t\t   const u8 * cpus, const u16 *rspq)\n{\n\tint i, j, cpu_idx = 0, q_idx = 0;\n\n\tif (cpus)\n\t\tfor (i = 0; i < RSS_TABLE_SIZE; ++i) {\n\t\t\tu32 val = i << 16;\n\n\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\tval |= (cpus[cpu_idx++] & 0x3f) << (8 * j);\n\t\t\t\tif (cpus[cpu_idx] == 0xff)\n\t\t\t\t\tcpu_idx = 0;\n\t\t\t}\n\t\t\tt3_write_reg(adapter, A_TP_RSS_LKP_TABLE, val);\n\t\t}\n\n\tif (rspq)\n\t\tfor (i = 0; i < RSS_TABLE_SIZE; ++i) {\n\t\t\tt3_write_reg(adapter, A_TP_RSS_MAP_TABLE,\n\t\t\t\t     (i << 16) | rspq[q_idx++]);\n\t\t\tif (rspq[q_idx] == 0xffff)\n\t\t\t\tq_idx = 0;\n\t\t}\n\n\tt3_write_reg(adapter, A_TP_RSS_CONFIG, rss_config);\n}\n\n \nvoid t3_tp_set_offload_mode(struct adapter *adap, int enable)\n{\n\tif (is_offload(adap) || !enable)\n\t\tt3_set_reg_field(adap, A_TP_IN_CONFIG, F_NICMODE,\n\t\t\t\t V_NICMODE(!enable));\n}\n\n \nstatic inline unsigned int pm_num_pages(unsigned int mem_size,\n\t\t\t\t\tunsigned int pg_size)\n{\n\tunsigned int n = mem_size / pg_size;\n\n\treturn n - n % 24;\n}\n\n#define mem_region(adap, start, size, reg) \\\n\tt3_write_reg((adap), A_ ## reg, (start)); \\\n\tstart += size\n\n \nstatic void partition_mem(struct adapter *adap, const struct tp_params *p)\n{\n\tunsigned int m, pstructs, tids = t3_mc5_size(&adap->mc5);\n\tunsigned int timers = 0, timers_shift = 22;\n\n\tif (adap->params.rev > 0) {\n\t\tif (tids <= 16 * 1024) {\n\t\t\ttimers = 1;\n\t\t\ttimers_shift = 16;\n\t\t} else if (tids <= 64 * 1024) {\n\t\t\ttimers = 2;\n\t\t\ttimers_shift = 18;\n\t\t} else if (tids <= 256 * 1024) {\n\t\t\ttimers = 3;\n\t\t\ttimers_shift = 20;\n\t\t}\n\t}\n\n\tt3_write_reg(adap, A_TP_PMM_SIZE,\n\t\t     p->chan_rx_size | (p->chan_tx_size >> 16));\n\n\tt3_write_reg(adap, A_TP_PMM_TX_BASE, 0);\n\tt3_write_reg(adap, A_TP_PMM_TX_PAGE_SIZE, p->tx_pg_size);\n\tt3_write_reg(adap, A_TP_PMM_TX_MAX_PAGE, p->tx_num_pgs);\n\tt3_set_reg_field(adap, A_TP_PARA_REG3, V_TXDATAACKIDX(M_TXDATAACKIDX),\n\t\t\t V_TXDATAACKIDX(fls(p->tx_pg_size) - 12));\n\n\tt3_write_reg(adap, A_TP_PMM_RX_BASE, 0);\n\tt3_write_reg(adap, A_TP_PMM_RX_PAGE_SIZE, p->rx_pg_size);\n\tt3_write_reg(adap, A_TP_PMM_RX_MAX_PAGE, p->rx_num_pgs);\n\n\tpstructs = p->rx_num_pgs + p->tx_num_pgs;\n\t \n\tpstructs += 48;\n\tpstructs -= pstructs % 24;\n\tt3_write_reg(adap, A_TP_CMM_MM_MAX_PSTRUCT, pstructs);\n\n\tm = tids * TCB_SIZE;\n\tmem_region(adap, m, (64 << 10) * 64, SG_EGR_CNTX_BADDR);\n\tmem_region(adap, m, (64 << 10) * 64, SG_CQ_CONTEXT_BADDR);\n\tt3_write_reg(adap, A_TP_CMM_TIMER_BASE, V_CMTIMERMAXNUM(timers) | m);\n\tm += ((p->ntimer_qs - 1) << timers_shift) + (1 << 22);\n\tmem_region(adap, m, pstructs * 64, TP_CMM_MM_BASE);\n\tmem_region(adap, m, 64 * (pstructs / 24), TP_CMM_MM_PS_FLST_BASE);\n\tmem_region(adap, m, 64 * (p->rx_num_pgs / 24), TP_CMM_MM_RX_FLST_BASE);\n\tmem_region(adap, m, 64 * (p->tx_num_pgs / 24), TP_CMM_MM_TX_FLST_BASE);\n\n\tm = (m + 4095) & ~0xfff;\n\tt3_write_reg(adap, A_CIM_SDRAM_BASE_ADDR, m);\n\tt3_write_reg(adap, A_CIM_SDRAM_ADDR_SIZE, p->cm_size - m);\n\n\ttids = (p->cm_size - m - (3 << 20)) / 3072 - 32;\n\tm = t3_mc5_size(&adap->mc5) - adap->params.mc5.nservers -\n\t    adap->params.mc5.nfilters - adap->params.mc5.nroutes;\n\tif (tids < m)\n\t\tadap->params.mc5.nservers += m - tids;\n}\n\nstatic inline void tp_wr_indirect(struct adapter *adap, unsigned int addr,\n\t\t\t\t  u32 val)\n{\n\tt3_write_reg(adap, A_TP_PIO_ADDR, addr);\n\tt3_write_reg(adap, A_TP_PIO_DATA, val);\n}\n\nstatic void tp_config(struct adapter *adap, const struct tp_params *p)\n{\n\tt3_write_reg(adap, A_TP_GLOBAL_CONFIG, F_TXPACINGENABLE | F_PATHMTU |\n\t\t     F_IPCHECKSUMOFFLOAD | F_UDPCHECKSUMOFFLOAD |\n\t\t     F_TCPCHECKSUMOFFLOAD | V_IPTTL(64));\n\tt3_write_reg(adap, A_TP_TCP_OPTIONS, V_MTUDEFAULT(576) |\n\t\t     F_MTUENABLE | V_WINDOWSCALEMODE(1) |\n\t\t     V_TIMESTAMPSMODE(1) | V_SACKMODE(1) | V_SACKRX(1));\n\tt3_write_reg(adap, A_TP_DACK_CONFIG, V_AUTOSTATE3(1) |\n\t\t     V_AUTOSTATE2(1) | V_AUTOSTATE1(0) |\n\t\t     V_BYTETHRESHOLD(26880) | V_MSSTHRESHOLD(2) |\n\t\t     F_AUTOCAREFUL | F_AUTOENABLE | V_DACK_MODE(1));\n\tt3_set_reg_field(adap, A_TP_IN_CONFIG, F_RXFBARBPRIO | F_TXFBARBPRIO,\n\t\t\t F_IPV6ENABLE | F_NICMODE);\n\tt3_write_reg(adap, A_TP_TX_RESOURCE_LIMIT, 0x18141814);\n\tt3_write_reg(adap, A_TP_PARA_REG4, 0x5050105);\n\tt3_set_reg_field(adap, A_TP_PARA_REG6, 0,\n\t\t\t adap->params.rev > 0 ? F_ENABLEESND :\n\t\t\t F_T3A_ENABLEESND);\n\n\tt3_set_reg_field(adap, A_TP_PC_CONFIG,\n\t\t\t F_ENABLEEPCMDAFULL,\n\t\t\t F_ENABLEOCSPIFULL |F_TXDEFERENABLE | F_HEARBEATDACK |\n\t\t\t F_TXCONGESTIONMODE | F_RXCONGESTIONMODE);\n\tt3_set_reg_field(adap, A_TP_PC_CONFIG2, F_CHDRAFULL,\n\t\t\t F_ENABLEIPV6RSS | F_ENABLENONOFDTNLSYN |\n\t\t\t F_ENABLEARPMISS | F_DISBLEDAPARBIT0);\n\tt3_write_reg(adap, A_TP_PROXY_FLOW_CNTL, 1080);\n\tt3_write_reg(adap, A_TP_PROXY_FLOW_CNTL, 1000);\n\n\tif (adap->params.rev > 0) {\n\t\ttp_wr_indirect(adap, A_TP_EGRESS_CONFIG, F_REWRITEFORCETOSIZE);\n\t\tt3_set_reg_field(adap, A_TP_PARA_REG3, F_TXPACEAUTO,\n\t\t\t\t F_TXPACEAUTO);\n\t\tt3_set_reg_field(adap, A_TP_PC_CONFIG, F_LOCKTID, F_LOCKTID);\n\t\tt3_set_reg_field(adap, A_TP_PARA_REG3, 0, F_TXPACEAUTOSTRICT);\n\t} else\n\t\tt3_set_reg_field(adap, A_TP_PARA_REG3, 0, F_TXPACEFIXED);\n\n\tif (adap->params.rev == T3_REV_C)\n\t\tt3_set_reg_field(adap, A_TP_PC_CONFIG,\n\t\t\t\t V_TABLELATENCYDELTA(M_TABLELATENCYDELTA),\n\t\t\t\t V_TABLELATENCYDELTA(4));\n\n\tt3_write_reg(adap, A_TP_TX_MOD_QUEUE_WEIGHT1, 0);\n\tt3_write_reg(adap, A_TP_TX_MOD_QUEUE_WEIGHT0, 0);\n\tt3_write_reg(adap, A_TP_MOD_CHANNEL_WEIGHT, 0);\n\tt3_write_reg(adap, A_TP_MOD_RATE_LIMIT, 0xf2200000);\n}\n\n \n#define TP_TMR_RES 50\n\n \n#define TP_DACK_TIMER 50\n#define TP_RTO_MIN    250\n\n \nstatic void tp_set_timers(struct adapter *adap, unsigned int core_clk)\n{\n\tunsigned int tre = fls(core_clk / (1000000 / TP_TMR_RES)) - 1;\n\tunsigned int dack_re = fls(core_clk / 5000) - 1;\t \n\tunsigned int tstamp_re = fls(core_clk / 1000);\t \n\tunsigned int tps = core_clk >> tre;\n\n\tt3_write_reg(adap, A_TP_TIMER_RESOLUTION, V_TIMERRESOLUTION(tre) |\n\t\t     V_DELAYEDACKRESOLUTION(dack_re) |\n\t\t     V_TIMESTAMPRESOLUTION(tstamp_re));\n\tt3_write_reg(adap, A_TP_DACK_TIMER,\n\t\t     (core_clk >> dack_re) / (1000 / TP_DACK_TIMER));\n\tt3_write_reg(adap, A_TP_TCP_BACKOFF_REG0, 0x3020100);\n\tt3_write_reg(adap, A_TP_TCP_BACKOFF_REG1, 0x7060504);\n\tt3_write_reg(adap, A_TP_TCP_BACKOFF_REG2, 0xb0a0908);\n\tt3_write_reg(adap, A_TP_TCP_BACKOFF_REG3, 0xf0e0d0c);\n\tt3_write_reg(adap, A_TP_SHIFT_CNT, V_SYNSHIFTMAX(6) |\n\t\t     V_RXTSHIFTMAXR1(4) | V_RXTSHIFTMAXR2(15) |\n\t\t     V_PERSHIFTBACKOFFMAX(8) | V_PERSHIFTMAX(8) |\n\t\t     V_KEEPALIVEMAX(9));\n\n#define SECONDS * tps\n\n\tt3_write_reg(adap, A_TP_MSL, adap->params.rev > 0 ? 0 : 2 SECONDS);\n\tt3_write_reg(adap, A_TP_RXT_MIN, tps / (1000 / TP_RTO_MIN));\n\tt3_write_reg(adap, A_TP_RXT_MAX, 64 SECONDS);\n\tt3_write_reg(adap, A_TP_PERS_MIN, 5 SECONDS);\n\tt3_write_reg(adap, A_TP_PERS_MAX, 64 SECONDS);\n\tt3_write_reg(adap, A_TP_KEEP_IDLE, 7200 SECONDS);\n\tt3_write_reg(adap, A_TP_KEEP_INTVL, 75 SECONDS);\n\tt3_write_reg(adap, A_TP_INIT_SRTT, 3 SECONDS);\n\tt3_write_reg(adap, A_TP_FINWAIT2_TIMER, 600 SECONDS);\n\n#undef SECONDS\n}\n\n \nstatic int t3_tp_set_coalescing_size(struct adapter *adap,\n\t\t\t\t     unsigned int size, int psh)\n{\n\tu32 val;\n\n\tif (size > MAX_RX_COALESCING_LEN)\n\t\treturn -EINVAL;\n\n\tval = t3_read_reg(adap, A_TP_PARA_REG3);\n\tval &= ~(F_RXCOALESCEENABLE | F_RXCOALESCEPSHEN);\n\n\tif (size) {\n\t\tval |= F_RXCOALESCEENABLE;\n\t\tif (psh)\n\t\t\tval |= F_RXCOALESCEPSHEN;\n\t\tsize = min(MAX_RX_COALESCING_LEN, size);\n\t\tt3_write_reg(adap, A_TP_PARA_REG2, V_RXCOALESCESIZE(size) |\n\t\t\t     V_MAXRXDATA(MAX_RX_COALESCING_LEN));\n\t}\n\tt3_write_reg(adap, A_TP_PARA_REG3, val);\n\treturn 0;\n}\n\n \nstatic void t3_tp_set_max_rxsize(struct adapter *adap, unsigned int size)\n{\n\tt3_write_reg(adap, A_TP_PARA_REG7,\n\t\t     V_PMMAXXFERLEN0(size) | V_PMMAXXFERLEN1(size));\n}\n\nstatic void init_mtus(unsigned short mtus[])\n{\n\t \n\tmtus[0] = 88;\n\tmtus[1] = 88;\n\tmtus[2] = 256;\n\tmtus[3] = 512;\n\tmtus[4] = 576;\n\tmtus[5] = 1024;\n\tmtus[6] = 1280;\n\tmtus[7] = 1492;\n\tmtus[8] = 1500;\n\tmtus[9] = 2002;\n\tmtus[10] = 2048;\n\tmtus[11] = 4096;\n\tmtus[12] = 4352;\n\tmtus[13] = 8192;\n\tmtus[14] = 9000;\n\tmtus[15] = 9600;\n}\n\n \nstatic void init_cong_ctrl(unsigned short *a, unsigned short *b)\n{\n\ta[0] = a[1] = a[2] = a[3] = a[4] = a[5] = a[6] = a[7] = a[8] = 1;\n\ta[9] = 2;\n\ta[10] = 3;\n\ta[11] = 4;\n\ta[12] = 5;\n\ta[13] = 6;\n\ta[14] = 7;\n\ta[15] = 8;\n\ta[16] = 9;\n\ta[17] = 10;\n\ta[18] = 14;\n\ta[19] = 17;\n\ta[20] = 21;\n\ta[21] = 25;\n\ta[22] = 30;\n\ta[23] = 35;\n\ta[24] = 45;\n\ta[25] = 60;\n\ta[26] = 80;\n\ta[27] = 100;\n\ta[28] = 200;\n\ta[29] = 300;\n\ta[30] = 400;\n\ta[31] = 500;\n\n\tb[0] = b[1] = b[2] = b[3] = b[4] = b[5] = b[6] = b[7] = b[8] = 0;\n\tb[9] = b[10] = 1;\n\tb[11] = b[12] = 2;\n\tb[13] = b[14] = b[15] = b[16] = 3;\n\tb[17] = b[18] = b[19] = b[20] = b[21] = 4;\n\tb[22] = b[23] = b[24] = b[25] = b[26] = b[27] = 5;\n\tb[28] = b[29] = 6;\n\tb[30] = b[31] = 7;\n}\n\n \n#define CC_MIN_INCR 2U\n\n \nvoid t3_load_mtus(struct adapter *adap, unsigned short mtus[NMTUS],\n\t\t  unsigned short alpha[NCCTRL_WIN],\n\t\t  unsigned short beta[NCCTRL_WIN], unsigned short mtu_cap)\n{\n\tstatic const unsigned int avg_pkts[NCCTRL_WIN] = {\n\t\t2, 6, 10, 14, 20, 28, 40, 56, 80, 112, 160, 224, 320, 448, 640,\n\t\t896, 1281, 1792, 2560, 3584, 5120, 7168, 10240, 14336, 20480,\n\t\t28672, 40960, 57344, 81920, 114688, 163840, 229376\n\t};\n\n\tunsigned int i, w;\n\n\tfor (i = 0; i < NMTUS; ++i) {\n\t\tunsigned int mtu = min(mtus[i], mtu_cap);\n\t\tunsigned int log2 = fls(mtu);\n\n\t\tif (!(mtu & ((1 << log2) >> 2)))\t \n\t\t\tlog2--;\n\t\tt3_write_reg(adap, A_TP_MTU_TABLE,\n\t\t\t     (i << 24) | (log2 << 16) | mtu);\n\n\t\tfor (w = 0; w < NCCTRL_WIN; ++w) {\n\t\t\tunsigned int inc;\n\n\t\t\tinc = max(((mtu - 40) * alpha[w]) / avg_pkts[w],\n\t\t\t\t  CC_MIN_INCR);\n\n\t\t\tt3_write_reg(adap, A_TP_CCTRL_TABLE, (i << 21) |\n\t\t\t\t     (w << 16) | (beta[w] << 13) | inc);\n\t\t}\n\t}\n}\n\n \nvoid t3_tp_get_mib_stats(struct adapter *adap, struct tp_mib_stats *tps)\n{\n\tt3_read_indirect(adap, A_TP_MIB_INDEX, A_TP_MIB_RDATA, (u32 *) tps,\n\t\t\t sizeof(*tps) / sizeof(u32), 0);\n}\n\n#define ulp_region(adap, name, start, len) \\\n\tt3_write_reg((adap), A_ULPRX_ ## name ## _LLIMIT, (start)); \\\n\tt3_write_reg((adap), A_ULPRX_ ## name ## _ULIMIT, \\\n\t\t     (start) + (len) - 1); \\\n\tstart += len\n\n#define ulptx_region(adap, name, start, len) \\\n\tt3_write_reg((adap), A_ULPTX_ ## name ## _LLIMIT, (start)); \\\n\tt3_write_reg((adap), A_ULPTX_ ## name ## _ULIMIT, \\\n\t\t     (start) + (len) - 1)\n\nstatic void ulp_config(struct adapter *adap, const struct tp_params *p)\n{\n\tunsigned int m = p->chan_rx_size;\n\n\tulp_region(adap, ISCSI, m, p->chan_rx_size / 8);\n\tulp_region(adap, TDDP, m, p->chan_rx_size / 8);\n\tulptx_region(adap, TPT, m, p->chan_rx_size / 4);\n\tulp_region(adap, STAG, m, p->chan_rx_size / 4);\n\tulp_region(adap, RQ, m, p->chan_rx_size / 4);\n\tulptx_region(adap, PBL, m, p->chan_rx_size / 4);\n\tulp_region(adap, PBL, m, p->chan_rx_size / 4);\n\tt3_write_reg(adap, A_ULPRX_TDDP_TAGMASK, 0xffffffff);\n}\n\n \nint t3_set_proto_sram(struct adapter *adap, const u8 *data)\n{\n\tint i;\n\tconst __be32 *buf = (const __be32 *)data;\n\n\tfor (i = 0; i < PROTO_SRAM_LINES; i++) {\n\t\tt3_write_reg(adap, A_TP_EMBED_OP_FIELD5, be32_to_cpu(*buf++));\n\t\tt3_write_reg(adap, A_TP_EMBED_OP_FIELD4, be32_to_cpu(*buf++));\n\t\tt3_write_reg(adap, A_TP_EMBED_OP_FIELD3, be32_to_cpu(*buf++));\n\t\tt3_write_reg(adap, A_TP_EMBED_OP_FIELD2, be32_to_cpu(*buf++));\n\t\tt3_write_reg(adap, A_TP_EMBED_OP_FIELD1, be32_to_cpu(*buf++));\n\n\t\tt3_write_reg(adap, A_TP_EMBED_OP_FIELD0, i << 1 | 1 << 31);\n\t\tif (t3_wait_op_done(adap, A_TP_EMBED_OP_FIELD0, 1, 1, 5, 1))\n\t\t\treturn -EIO;\n\t}\n\tt3_write_reg(adap, A_TP_EMBED_OP_FIELD0, 0);\n\n\treturn 0;\n}\n\nvoid t3_config_trace_filter(struct adapter *adapter,\n\t\t\t    const struct trace_params *tp, int filter_index,\n\t\t\t    int invert, int enable)\n{\n\tu32 addr, key[4], mask[4];\n\n\tkey[0] = tp->sport | (tp->sip << 16);\n\tkey[1] = (tp->sip >> 16) | (tp->dport << 16);\n\tkey[2] = tp->dip;\n\tkey[3] = tp->proto | (tp->vlan << 8) | (tp->intf << 20);\n\n\tmask[0] = tp->sport_mask | (tp->sip_mask << 16);\n\tmask[1] = (tp->sip_mask >> 16) | (tp->dport_mask << 16);\n\tmask[2] = tp->dip_mask;\n\tmask[3] = tp->proto_mask | (tp->vlan_mask << 8) | (tp->intf_mask << 20);\n\n\tif (invert)\n\t\tkey[3] |= (1 << 29);\n\tif (enable)\n\t\tkey[3] |= (1 << 28);\n\n\taddr = filter_index ? A_TP_RX_TRC_KEY0 : A_TP_TX_TRC_KEY0;\n\ttp_wr_indirect(adapter, addr++, key[0]);\n\ttp_wr_indirect(adapter, addr++, mask[0]);\n\ttp_wr_indirect(adapter, addr++, key[1]);\n\ttp_wr_indirect(adapter, addr++, mask[1]);\n\ttp_wr_indirect(adapter, addr++, key[2]);\n\ttp_wr_indirect(adapter, addr++, mask[2]);\n\ttp_wr_indirect(adapter, addr++, key[3]);\n\ttp_wr_indirect(adapter, addr, mask[3]);\n\tt3_read_reg(adapter, A_TP_PIO_DATA);\n}\n\n \nint t3_config_sched(struct adapter *adap, unsigned int kbps, int sched)\n{\n\tunsigned int v, tps, cpt, bpt, delta, mindelta = ~0;\n\tunsigned int clk = adap->params.vpd.cclk * 1000;\n\tunsigned int selected_cpt = 0, selected_bpt = 0;\n\n\tif (kbps > 0) {\n\t\tkbps *= 125;\t \n\t\tfor (cpt = 1; cpt <= 255; cpt++) {\n\t\t\ttps = clk / cpt;\n\t\t\tbpt = (kbps + tps / 2) / tps;\n\t\t\tif (bpt > 0 && bpt <= 255) {\n\t\t\t\tv = bpt * tps;\n\t\t\t\tdelta = v >= kbps ? v - kbps : kbps - v;\n\t\t\t\tif (delta <= mindelta) {\n\t\t\t\t\tmindelta = delta;\n\t\t\t\t\tselected_cpt = cpt;\n\t\t\t\t\tselected_bpt = bpt;\n\t\t\t\t}\n\t\t\t} else if (selected_cpt)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!selected_cpt)\n\t\t\treturn -EINVAL;\n\t}\n\tt3_write_reg(adap, A_TP_TM_PIO_ADDR,\n\t\t     A_TP_TX_MOD_Q1_Q0_RATE_LIMIT - sched / 2);\n\tv = t3_read_reg(adap, A_TP_TM_PIO_DATA);\n\tif (sched & 1)\n\t\tv = (v & 0xffff) | (selected_cpt << 16) | (selected_bpt << 24);\n\telse\n\t\tv = (v & 0xffff0000) | selected_cpt | (selected_bpt << 8);\n\tt3_write_reg(adap, A_TP_TM_PIO_DATA, v);\n\treturn 0;\n}\n\nstatic int tp_init(struct adapter *adap, const struct tp_params *p)\n{\n\tint busy = 0;\n\n\ttp_config(adap, p);\n\tt3_set_vlan_accel(adap, 3, 0);\n\n\tif (is_offload(adap)) {\n\t\ttp_set_timers(adap, adap->params.vpd.cclk * 1000);\n\t\tt3_write_reg(adap, A_TP_RESET, F_FLSTINITENABLE);\n\t\tbusy = t3_wait_op_done(adap, A_TP_RESET, F_FLSTINITENABLE,\n\t\t\t\t       0, 1000, 5);\n\t\tif (busy)\n\t\t\tCH_ERR(adap, \"TP initialization timed out\\n\");\n\t}\n\n\tif (!busy)\n\t\tt3_write_reg(adap, A_TP_RESET, F_TPRESET);\n\treturn busy;\n}\n\n \nstatic void chan_init_hw(struct adapter *adap, unsigned int chan_map)\n{\n\tint i;\n\n\tif (chan_map != 3) {                                  \n\t\tt3_set_reg_field(adap, A_ULPRX_CTL, F_ROUND_ROBIN, 0);\n\t\tt3_set_reg_field(adap, A_ULPTX_CONFIG, F_CFG_RR_ARB, 0);\n\t\tt3_write_reg(adap, A_MPS_CFG, F_TPRXPORTEN | F_ENFORCEPKT |\n\t\t\t     (chan_map == 1 ? F_TPTXPORT0EN | F_PORT0ACTIVE :\n\t\t\t\t\t      F_TPTXPORT1EN | F_PORT1ACTIVE));\n\t\tt3_write_reg(adap, A_PM1_TX_CFG,\n\t\t\t     chan_map == 1 ? 0xffffffff : 0);\n\t} else {                                              \n\t\tt3_set_reg_field(adap, A_ULPRX_CTL, 0, F_ROUND_ROBIN);\n\t\tt3_set_reg_field(adap, A_ULPTX_CONFIG, 0, F_CFG_RR_ARB);\n\t\tt3_write_reg(adap, A_ULPTX_DMA_WEIGHT,\n\t\t\t     V_D1_WEIGHT(16) | V_D0_WEIGHT(16));\n\t\tt3_write_reg(adap, A_MPS_CFG, F_TPTXPORT0EN | F_TPTXPORT1EN |\n\t\t\t     F_TPRXPORTEN | F_PORT0ACTIVE | F_PORT1ACTIVE |\n\t\t\t     F_ENFORCEPKT);\n\t\tt3_write_reg(adap, A_PM1_TX_CFG, 0x80008000);\n\t\tt3_set_reg_field(adap, A_TP_PC_CONFIG, 0, F_TXTOSQUEUEMAPMODE);\n\t\tt3_write_reg(adap, A_TP_TX_MOD_QUEUE_REQ_MAP,\n\t\t\t     V_TX_MOD_QUEUE_REQ_MAP(0xaa));\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tt3_write_reg(adap, A_TP_TX_MOD_QUE_TABLE,\n\t\t\t\t     (i << 16) | 0x1010);\n\t}\n}\n\nstatic int calibrate_xgm(struct adapter *adapter)\n{\n\tif (uses_xaui(adapter)) {\n\t\tunsigned int v, i;\n\n\t\tfor (i = 0; i < 5; ++i) {\n\t\t\tt3_write_reg(adapter, A_XGM_XAUI_IMP, 0);\n\t\t\tt3_read_reg(adapter, A_XGM_XAUI_IMP);\n\t\t\tmsleep(1);\n\t\t\tv = t3_read_reg(adapter, A_XGM_XAUI_IMP);\n\t\t\tif (!(v & (F_XGM_CALFAULT | F_CALBUSY))) {\n\t\t\t\tt3_write_reg(adapter, A_XGM_XAUI_IMP,\n\t\t\t\t\t     V_XAUIIMP(G_CALIMP(v) >> 2));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tCH_ERR(adapter, \"MAC calibration failed\\n\");\n\t\treturn -1;\n\t} else {\n\t\tt3_write_reg(adapter, A_XGM_RGMII_IMP,\n\t\t\t     V_RGMIIIMPPD(2) | V_RGMIIIMPPU(3));\n\t\tt3_set_reg_field(adapter, A_XGM_RGMII_IMP, F_XGM_IMPSETUPDATE,\n\t\t\t\t F_XGM_IMPSETUPDATE);\n\t}\n\treturn 0;\n}\n\nstatic void calibrate_xgm_t3b(struct adapter *adapter)\n{\n\tif (!uses_xaui(adapter)) {\n\t\tt3_write_reg(adapter, A_XGM_RGMII_IMP, F_CALRESET |\n\t\t\t     F_CALUPDATE | V_RGMIIIMPPD(2) | V_RGMIIIMPPU(3));\n\t\tt3_set_reg_field(adapter, A_XGM_RGMII_IMP, F_CALRESET, 0);\n\t\tt3_set_reg_field(adapter, A_XGM_RGMII_IMP, 0,\n\t\t\t\t F_XGM_IMPSETUPDATE);\n\t\tt3_set_reg_field(adapter, A_XGM_RGMII_IMP, F_XGM_IMPSETUPDATE,\n\t\t\t\t 0);\n\t\tt3_set_reg_field(adapter, A_XGM_RGMII_IMP, F_CALUPDATE, 0);\n\t\tt3_set_reg_field(adapter, A_XGM_RGMII_IMP, 0, F_CALUPDATE);\n\t}\n}\n\nstruct mc7_timing_params {\n\tunsigned char ActToPreDly;\n\tunsigned char ActToRdWrDly;\n\tunsigned char PreCyc;\n\tunsigned char RefCyc[5];\n\tunsigned char BkCyc;\n\tunsigned char WrToRdDly;\n\tunsigned char RdToWrDly;\n};\n\n \nstatic int wrreg_wait(struct adapter *adapter, unsigned int addr, u32 val)\n{\n\tt3_write_reg(adapter, addr, val);\n\tt3_read_reg(adapter, addr);\t \n\tif (!(t3_read_reg(adapter, addr) & F_BUSY))\n\t\treturn 0;\n\tCH_ERR(adapter, \"write to MC7 register 0x%x timed out\\n\", addr);\n\treturn -EIO;\n}\n\nstatic int mc7_init(struct mc7 *mc7, unsigned int mc7_clock, int mem_type)\n{\n\tstatic const unsigned int mc7_mode[] = {\n\t\t0x632, 0x642, 0x652, 0x432, 0x442\n\t};\n\tstatic const struct mc7_timing_params mc7_timings[] = {\n\t\t{12, 3, 4, {20, 28, 34, 52, 0}, 15, 6, 4},\n\t\t{12, 4, 5, {20, 28, 34, 52, 0}, 16, 7, 4},\n\t\t{12, 5, 6, {20, 28, 34, 52, 0}, 17, 8, 4},\n\t\t{9, 3, 4, {15, 21, 26, 39, 0}, 12, 6, 4},\n\t\t{9, 4, 5, {15, 21, 26, 39, 0}, 13, 7, 4}\n\t};\n\n\tu32 val;\n\tunsigned int width, density, slow, attempts;\n\tstruct adapter *adapter = mc7->adapter;\n\tconst struct mc7_timing_params *p = &mc7_timings[mem_type];\n\n\tif (!mc7->size)\n\t\treturn 0;\n\n\tval = t3_read_reg(adapter, mc7->offset + A_MC7_CFG);\n\tslow = val & F_SLOW;\n\twidth = G_WIDTH(val);\n\tdensity = G_DEN(val);\n\n\tt3_write_reg(adapter, mc7->offset + A_MC7_CFG, val | F_IFEN);\n\tval = t3_read_reg(adapter, mc7->offset + A_MC7_CFG);\t \n\tmsleep(1);\n\n\tif (!slow) {\n\t\tt3_write_reg(adapter, mc7->offset + A_MC7_CAL, F_SGL_CAL_EN);\n\t\tt3_read_reg(adapter, mc7->offset + A_MC7_CAL);\n\t\tmsleep(1);\n\t\tif (t3_read_reg(adapter, mc7->offset + A_MC7_CAL) &\n\t\t    (F_BUSY | F_SGL_CAL_EN | F_CAL_FAULT)) {\n\t\t\tCH_ERR(adapter, \"%s MC7 calibration timed out\\n\",\n\t\t\t       mc7->name);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tt3_write_reg(adapter, mc7->offset + A_MC7_PARM,\n\t\t     V_ACTTOPREDLY(p->ActToPreDly) |\n\t\t     V_ACTTORDWRDLY(p->ActToRdWrDly) | V_PRECYC(p->PreCyc) |\n\t\t     V_REFCYC(p->RefCyc[density]) | V_BKCYC(p->BkCyc) |\n\t\t     V_WRTORDDLY(p->WrToRdDly) | V_RDTOWRDLY(p->RdToWrDly));\n\n\tt3_write_reg(adapter, mc7->offset + A_MC7_CFG,\n\t\t     val | F_CLKEN | F_TERM150);\n\tt3_read_reg(adapter, mc7->offset + A_MC7_CFG);\t \n\n\tif (!slow)\n\t\tt3_set_reg_field(adapter, mc7->offset + A_MC7_DLL, F_DLLENB,\n\t\t\t\t F_DLLENB);\n\tudelay(1);\n\n\tval = slow ? 3 : 6;\n\tif (wrreg_wait(adapter, mc7->offset + A_MC7_PRE, 0) ||\n\t    wrreg_wait(adapter, mc7->offset + A_MC7_EXT_MODE2, 0) ||\n\t    wrreg_wait(adapter, mc7->offset + A_MC7_EXT_MODE3, 0) ||\n\t    wrreg_wait(adapter, mc7->offset + A_MC7_EXT_MODE1, val))\n\t\tgoto out_fail;\n\n\tif (!slow) {\n\t\tt3_write_reg(adapter, mc7->offset + A_MC7_MODE, 0x100);\n\t\tt3_set_reg_field(adapter, mc7->offset + A_MC7_DLL, F_DLLRST, 0);\n\t\tudelay(5);\n\t}\n\n\tif (wrreg_wait(adapter, mc7->offset + A_MC7_PRE, 0) ||\n\t    wrreg_wait(adapter, mc7->offset + A_MC7_REF, 0) ||\n\t    wrreg_wait(adapter, mc7->offset + A_MC7_REF, 0) ||\n\t    wrreg_wait(adapter, mc7->offset + A_MC7_MODE,\n\t\t       mc7_mode[mem_type]) ||\n\t    wrreg_wait(adapter, mc7->offset + A_MC7_EXT_MODE1, val | 0x380) ||\n\t    wrreg_wait(adapter, mc7->offset + A_MC7_EXT_MODE1, val))\n\t\tgoto out_fail;\n\n\t \n\tmc7_clock = mc7_clock * 7812 + mc7_clock / 2;\t \n\tmc7_clock /= 1000000;\t \n\n\tt3_write_reg(adapter, mc7->offset + A_MC7_REF,\n\t\t     F_PERREFEN | V_PREREFDIV(mc7_clock));\n\tt3_read_reg(adapter, mc7->offset + A_MC7_REF);\t \n\n\tt3_write_reg(adapter, mc7->offset + A_MC7_ECC, F_ECCGENEN | F_ECCCHKEN);\n\tt3_write_reg(adapter, mc7->offset + A_MC7_BIST_DATA, 0);\n\tt3_write_reg(adapter, mc7->offset + A_MC7_BIST_ADDR_BEG, 0);\n\tt3_write_reg(adapter, mc7->offset + A_MC7_BIST_ADDR_END,\n\t\t     (mc7->size << width) - 1);\n\tt3_write_reg(adapter, mc7->offset + A_MC7_BIST_OP, V_OP(1));\n\tt3_read_reg(adapter, mc7->offset + A_MC7_BIST_OP);\t \n\n\tattempts = 50;\n\tdo {\n\t\tmsleep(250);\n\t\tval = t3_read_reg(adapter, mc7->offset + A_MC7_BIST_OP);\n\t} while ((val & F_BUSY) && --attempts);\n\tif (val & F_BUSY) {\n\t\tCH_ERR(adapter, \"%s MC7 BIST timed out\\n\", mc7->name);\n\t\tgoto out_fail;\n\t}\n\n\t \n\tt3_set_reg_field(adapter, mc7->offset + A_MC7_CFG, 0, F_RDY);\n\treturn 0;\n\nout_fail:\n\treturn -1;\n}\n\nstatic void config_pcie(struct adapter *adap)\n{\n\tstatic const u16 ack_lat[4][6] = {\n\t\t{237, 416, 559, 1071, 2095, 4143},\n\t\t{128, 217, 289, 545, 1057, 2081},\n\t\t{73, 118, 154, 282, 538, 1050},\n\t\t{67, 107, 86, 150, 278, 534}\n\t};\n\tstatic const u16 rpl_tmr[4][6] = {\n\t\t{711, 1248, 1677, 3213, 6285, 12429},\n\t\t{384, 651, 867, 1635, 3171, 6243},\n\t\t{219, 354, 462, 846, 1614, 3150},\n\t\t{201, 321, 258, 450, 834, 1602}\n\t};\n\n\tu16 val, devid;\n\tunsigned int log2_width, pldsize;\n\tunsigned int fst_trn_rx, fst_trn_tx, acklat, rpllmt;\n\n\tpcie_capability_read_word(adap->pdev, PCI_EXP_DEVCTL, &val);\n\tpldsize = (val & PCI_EXP_DEVCTL_PAYLOAD) >> 5;\n\n\tpci_read_config_word(adap->pdev, 0x2, &devid);\n\tif (devid == 0x37) {\n\t\tpcie_capability_write_word(adap->pdev, PCI_EXP_DEVCTL,\n\t\t\t\t\t   val & ~PCI_EXP_DEVCTL_READRQ &\n\t\t\t\t\t   ~PCI_EXP_DEVCTL_PAYLOAD);\n\t\tpldsize = 0;\n\t}\n\n\tpcie_capability_read_word(adap->pdev, PCI_EXP_LNKCTL, &val);\n\n\tfst_trn_tx = G_NUMFSTTRNSEQ(t3_read_reg(adap, A_PCIE_PEX_CTRL0));\n\tfst_trn_rx = adap->params.rev == 0 ? fst_trn_tx :\n\t    G_NUMFSTTRNSEQRX(t3_read_reg(adap, A_PCIE_MODE));\n\tlog2_width = fls(adap->params.pci.width) - 1;\n\tacklat = ack_lat[log2_width][pldsize];\n\tif (val & PCI_EXP_LNKCTL_ASPM_L0S)\t \n\t\tacklat += fst_trn_tx * 4;\n\trpllmt = rpl_tmr[log2_width][pldsize] + fst_trn_rx * 4;\n\n\tif (adap->params.rev == 0)\n\t\tt3_set_reg_field(adap, A_PCIE_PEX_CTRL1,\n\t\t\t\t V_T3A_ACKLAT(M_T3A_ACKLAT),\n\t\t\t\t V_T3A_ACKLAT(acklat));\n\telse\n\t\tt3_set_reg_field(adap, A_PCIE_PEX_CTRL1, V_ACKLAT(M_ACKLAT),\n\t\t\t\t V_ACKLAT(acklat));\n\n\tt3_set_reg_field(adap, A_PCIE_PEX_CTRL0, V_REPLAYLMT(M_REPLAYLMT),\n\t\t\t V_REPLAYLMT(rpllmt));\n\n\tt3_write_reg(adap, A_PCIE_PEX_ERR, 0xffffffff);\n\tt3_set_reg_field(adap, A_PCIE_CFG, 0,\n\t\t\t F_ENABLELINKDWNDRST | F_ENABLELINKDOWNRST |\n\t\t\t F_PCIE_DMASTOPEN | F_PCIE_CLIDECEN);\n}\n\n \nint t3_init_hw(struct adapter *adapter, u32 fw_params)\n{\n\tint err = -EIO, attempts, i;\n\tconst struct vpd_params *vpd = &adapter->params.vpd;\n\n\tif (adapter->params.rev > 0)\n\t\tcalibrate_xgm_t3b(adapter);\n\telse if (calibrate_xgm(adapter))\n\t\tgoto out_err;\n\n\tif (vpd->mclk) {\n\t\tpartition_mem(adapter, &adapter->params.tp);\n\n\t\tif (mc7_init(&adapter->pmrx, vpd->mclk, vpd->mem_timing) ||\n\t\t    mc7_init(&adapter->pmtx, vpd->mclk, vpd->mem_timing) ||\n\t\t    mc7_init(&adapter->cm, vpd->mclk, vpd->mem_timing) ||\n\t\t    t3_mc5_init(&adapter->mc5, adapter->params.mc5.nservers,\n\t\t\t\tadapter->params.mc5.nfilters,\n\t\t\t\tadapter->params.mc5.nroutes))\n\t\t\tgoto out_err;\n\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tif (clear_sge_ctxt(adapter, i, F_CQ))\n\t\t\t\tgoto out_err;\n\t}\n\n\tif (tp_init(adapter, &adapter->params.tp))\n\t\tgoto out_err;\n\n\tt3_tp_set_coalescing_size(adapter,\n\t\t\t\t  min(adapter->params.sge.max_pkt_size,\n\t\t\t\t      MAX_RX_COALESCING_LEN), 1);\n\tt3_tp_set_max_rxsize(adapter,\n\t\t\t     min(adapter->params.sge.max_pkt_size, 16384U));\n\tulp_config(adapter, &adapter->params.tp);\n\n\tif (is_pcie(adapter))\n\t\tconfig_pcie(adapter);\n\telse\n\t\tt3_set_reg_field(adapter, A_PCIX_CFG, 0,\n\t\t\t\t F_DMASTOPEN | F_CLIDECEN);\n\n\tif (adapter->params.rev == T3_REV_C)\n\t\tt3_set_reg_field(adapter, A_ULPTX_CONFIG, 0,\n\t\t\t\t F_CFG_CQE_SOP_MASK);\n\n\tt3_write_reg(adapter, A_PM1_RX_CFG, 0xffffffff);\n\tt3_write_reg(adapter, A_PM1_RX_MODE, 0);\n\tt3_write_reg(adapter, A_PM1_TX_MODE, 0);\n\tchan_init_hw(adapter, adapter->params.chan_map);\n\tt3_sge_init(adapter, &adapter->params.sge);\n\tt3_set_reg_field(adapter, A_PL_RST, 0, F_FATALPERREN);\n\n\tt3_write_reg(adapter, A_T3DBG_GPIO_ACT_LOW, calc_gpio_intr(adapter));\n\n\tt3_write_reg(adapter, A_CIM_HOST_ACC_DATA, vpd->uclk | fw_params);\n\tt3_write_reg(adapter, A_CIM_BOOT_CFG,\n\t\t     V_BOOTADDR(FW_FLASH_BOOT_ADDR >> 2));\n\tt3_read_reg(adapter, A_CIM_BOOT_CFG);\t \n\n\tattempts = 100;\n\tdo {\t\t\t \n\t\tmsleep(20);\n\t} while (t3_read_reg(adapter, A_CIM_HOST_ACC_DATA) && --attempts);\n\tif (!attempts) {\n\t\tCH_ERR(adapter, \"uP initialization timed out\\n\");\n\t\tgoto out_err;\n\t}\n\n\terr = 0;\nout_err:\n\treturn err;\n}\n\n \nstatic void get_pci_mode(struct adapter *adapter, struct pci_params *p)\n{\n\tstatic unsigned short speed_map[] = { 33, 66, 100, 133 };\n\tu32 pci_mode;\n\n\tif (pci_is_pcie(adapter->pdev)) {\n\t\tu16 val;\n\n\t\tp->variant = PCI_VARIANT_PCIE;\n\t\tpcie_capability_read_word(adapter->pdev, PCI_EXP_LNKSTA, &val);\n\t\tp->width = (val >> 4) & 0x3f;\n\t\treturn;\n\t}\n\n\tpci_mode = t3_read_reg(adapter, A_PCIX_MODE);\n\tp->speed = speed_map[G_PCLKRANGE(pci_mode)];\n\tp->width = (pci_mode & F_64BIT) ? 64 : 32;\n\tpci_mode = G_PCIXINITPAT(pci_mode);\n\tif (pci_mode == 0)\n\t\tp->variant = PCI_VARIANT_PCI;\n\telse if (pci_mode < 4)\n\t\tp->variant = PCI_VARIANT_PCIX_MODE1_PARITY;\n\telse if (pci_mode < 8)\n\t\tp->variant = PCI_VARIANT_PCIX_MODE1_ECC;\n\telse\n\t\tp->variant = PCI_VARIANT_PCIX_266_MODE2;\n}\n\n \nstatic void init_link_config(struct link_config *lc, unsigned int caps)\n{\n\tlc->supported = caps;\n\tlc->requested_speed = lc->speed = SPEED_INVALID;\n\tlc->requested_duplex = lc->duplex = DUPLEX_INVALID;\n\tlc->requested_fc = lc->fc = PAUSE_RX | PAUSE_TX;\n\tif (lc->supported & SUPPORTED_Autoneg) {\n\t\tlc->advertising = lc->supported;\n\t\tlc->autoneg = AUTONEG_ENABLE;\n\t\tlc->requested_fc |= PAUSE_AUTONEG;\n\t} else {\n\t\tlc->advertising = 0;\n\t\tlc->autoneg = AUTONEG_DISABLE;\n\t}\n}\n\n \nstatic unsigned int mc7_calc_size(u32 cfg)\n{\n\tunsigned int width = G_WIDTH(cfg);\n\tunsigned int banks = !!(cfg & F_BKS) + 1;\n\tunsigned int org = !!(cfg & F_ORG) + 1;\n\tunsigned int density = G_DEN(cfg);\n\tunsigned int MBs = ((256 << density) * banks) / (org << width);\n\n\treturn MBs << 20;\n}\n\nstatic void mc7_prep(struct adapter *adapter, struct mc7 *mc7,\n\t\t     unsigned int base_addr, const char *name)\n{\n\tu32 cfg;\n\n\tmc7->adapter = adapter;\n\tmc7->name = name;\n\tmc7->offset = base_addr - MC7_PMRX_BASE_ADDR;\n\tcfg = t3_read_reg(adapter, mc7->offset + A_MC7_CFG);\n\tmc7->size = G_DEN(cfg) == M_DEN ? 0 : mc7_calc_size(cfg);\n\tmc7->width = G_WIDTH(cfg);\n}\n\nstatic void mac_prep(struct cmac *mac, struct adapter *adapter, int index)\n{\n\tu16 devid;\n\n\tmac->adapter = adapter;\n\tpci_read_config_word(adapter->pdev, 0x2, &devid);\n\n\tif (devid == 0x37 && !adapter->params.vpd.xauicfg[1])\n\t\tindex = 0;\n\tmac->offset = (XGMAC0_1_BASE_ADDR - XGMAC0_0_BASE_ADDR) * index;\n\tmac->nucast = 1;\n\n\tif (adapter->params.rev == 0 && uses_xaui(adapter)) {\n\t\tt3_write_reg(adapter, A_XGM_SERDES_CTRL + mac->offset,\n\t\t\t     is_10G(adapter) ? 0x2901c04 : 0x2301c04);\n\t\tt3_set_reg_field(adapter, A_XGM_PORT_CFG + mac->offset,\n\t\t\t\t F_ENRGMII, 0);\n\t}\n}\n\nstatic void early_hw_init(struct adapter *adapter,\n\t\t\t  const struct adapter_info *ai)\n{\n\tu32 val = V_PORTSPEED(is_10G(adapter) ? 3 : 2);\n\n\tmi1_init(adapter, ai);\n\tt3_write_reg(adapter, A_I2C_CFG,\t \n\t\t     V_I2C_CLKDIV(adapter->params.vpd.cclk / 80 - 1));\n\tt3_write_reg(adapter, A_T3DBG_GPIO_EN,\n\t\t     ai->gpio_out | F_GPIO0_OEN | F_GPIO0_OUT_VAL);\n\tt3_write_reg(adapter, A_MC5_DB_SERVER_INDEX, 0);\n\tt3_write_reg(adapter, A_SG_OCO_BASE, V_BASE1(0xfff));\n\n\tif (adapter->params.rev == 0 || !uses_xaui(adapter))\n\t\tval |= F_ENRGMII;\n\n\t \n\tt3_write_reg(adapter, A_XGM_PORT_CFG, val);\n\tt3_read_reg(adapter, A_XGM_PORT_CFG);\n\n\tval |= F_CLKDIVRESET_;\n\tt3_write_reg(adapter, A_XGM_PORT_CFG, val);\n\tt3_read_reg(adapter, A_XGM_PORT_CFG);\n\tt3_write_reg(adapter, XGM_REG(A_XGM_PORT_CFG, 1), val);\n\tt3_read_reg(adapter, A_XGM_PORT_CFG);\n}\n\n \nint t3_reset_adapter(struct adapter *adapter)\n{\n\tint i, save_and_restore_pcie =\n\t    adapter->params.rev < T3_REV_B2 && is_pcie(adapter);\n\tuint16_t devid = 0;\n\n\tif (save_and_restore_pcie)\n\t\tpci_save_state(adapter->pdev);\n\tt3_write_reg(adapter, A_PL_RST, F_CRSTWRM | F_CRSTWRMMODE);\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tmsleep(50);\n\t\tpci_read_config_word(adapter->pdev, 0x00, &devid);\n\t\tif (devid == 0x1425)\n\t\t\tbreak;\n\t}\n\n\tif (devid != 0x1425)\n\t\treturn -1;\n\n\tif (save_and_restore_pcie)\n\t\tpci_restore_state(adapter->pdev);\n\treturn 0;\n}\n\nstatic int init_parity(struct adapter *adap)\n{\n\tint i, err, addr;\n\n\tif (t3_read_reg(adap, A_SG_CONTEXT_CMD) & F_CONTEXT_CMD_BUSY)\n\t\treturn -EBUSY;\n\n\tfor (err = i = 0; !err && i < 16; i++)\n\t\terr = clear_sge_ctxt(adap, i, F_EGRESS);\n\tfor (i = 0xfff0; !err && i <= 0xffff; i++)\n\t\terr = clear_sge_ctxt(adap, i, F_EGRESS);\n\tfor (i = 0; !err && i < SGE_QSETS; i++)\n\t\terr = clear_sge_ctxt(adap, i, F_RESPONSEQ);\n\tif (err)\n\t\treturn err;\n\n\tt3_write_reg(adap, A_CIM_IBQ_DBG_DATA, 0);\n\tfor (i = 0; i < 4; i++)\n\t\tfor (addr = 0; addr <= M_IBQDBGADDR; addr++) {\n\t\t\tt3_write_reg(adap, A_CIM_IBQ_DBG_CFG, F_IBQDBGEN |\n\t\t\t\t     F_IBQDBGWR | V_IBQDBGQID(i) |\n\t\t\t\t     V_IBQDBGADDR(addr));\n\t\t\terr = t3_wait_op_done(adap, A_CIM_IBQ_DBG_CFG,\n\t\t\t\t\t      F_IBQDBGBUSY, 0, 2, 1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\treturn 0;\n}\n\n \nint t3_prep_adapter(struct adapter *adapter, const struct adapter_info *ai,\n\t\t    int reset)\n{\n\tint ret;\n\tunsigned int i, j = -1;\n\n\tget_pci_mode(adapter, &adapter->params.pci);\n\n\tadapter->params.info = ai;\n\tadapter->params.nports = ai->nports0 + ai->nports1;\n\tadapter->params.chan_map = (!!ai->nports0) | (!!ai->nports1 << 1);\n\tadapter->params.rev = t3_read_reg(adapter, A_PL_REV);\n\t \n\tadapter->params.linkpoll_period = 10;\n\tadapter->params.stats_update_period = is_10G(adapter) ?\n\t    MAC_STATS_ACCUM_SECS : (MAC_STATS_ACCUM_SECS * 10);\n\tadapter->params.pci.vpd_cap_addr =\n\t    pci_find_capability(adapter->pdev, PCI_CAP_ID_VPD);\n\tif (!adapter->params.pci.vpd_cap_addr)\n\t\treturn -ENODEV;\n\tret = get_vpd_params(adapter, &adapter->params.vpd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (reset && t3_reset_adapter(adapter))\n\t\treturn -1;\n\n\tt3_sge_prep(adapter, &adapter->params.sge);\n\n\tif (adapter->params.vpd.mclk) {\n\t\tstruct tp_params *p = &adapter->params.tp;\n\n\t\tmc7_prep(adapter, &adapter->pmrx, MC7_PMRX_BASE_ADDR, \"PMRX\");\n\t\tmc7_prep(adapter, &adapter->pmtx, MC7_PMTX_BASE_ADDR, \"PMTX\");\n\t\tmc7_prep(adapter, &adapter->cm, MC7_CM_BASE_ADDR, \"CM\");\n\n\t\tp->nchan = adapter->params.chan_map == 3 ? 2 : 1;\n\t\tp->pmrx_size = t3_mc7_size(&adapter->pmrx);\n\t\tp->pmtx_size = t3_mc7_size(&adapter->pmtx);\n\t\tp->cm_size = t3_mc7_size(&adapter->cm);\n\t\tp->chan_rx_size = p->pmrx_size / 2;\t \n\t\tp->chan_tx_size = p->pmtx_size / p->nchan;\n\t\tp->rx_pg_size = 64 * 1024;\n\t\tp->tx_pg_size = is_10G(adapter) ? 64 * 1024 : 16 * 1024;\n\t\tp->rx_num_pgs = pm_num_pages(p->chan_rx_size, p->rx_pg_size);\n\t\tp->tx_num_pgs = pm_num_pages(p->chan_tx_size, p->tx_pg_size);\n\t\tp->ntimer_qs = p->cm_size >= (128 << 20) ||\n\t\t    adapter->params.rev > 0 ? 12 : 6;\n\t}\n\n\tadapter->params.offload = t3_mc7_size(&adapter->pmrx) &&\n\t\t\t\t  t3_mc7_size(&adapter->pmtx) &&\n\t\t\t\t  t3_mc7_size(&adapter->cm);\n\n\tif (is_offload(adapter)) {\n\t\tadapter->params.mc5.nservers = DEFAULT_NSERVERS;\n\t\tadapter->params.mc5.nfilters = adapter->params.rev > 0 ?\n\t\t    DEFAULT_NFILTERS : 0;\n\t\tadapter->params.mc5.nroutes = 0;\n\t\tt3_mc5_prep(adapter, &adapter->mc5, MC5_MODE_144_BIT);\n\n\t\tinit_mtus(adapter->params.mtus);\n\t\tinit_cong_ctrl(adapter->params.a_wnd, adapter->params.b_wnd);\n\t}\n\n\tearly_hw_init(adapter, ai);\n\tret = init_parity(adapter);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_port(adapter, i) {\n\t\tu8 hw_addr[6];\n\t\tconst struct port_type_info *pti;\n\t\tstruct port_info *p = adap2pinfo(adapter, i);\n\n\t\twhile (!adapter->params.vpd.port_type[++j])\n\t\t\t;\n\n\t\tpti = &port_types[adapter->params.vpd.port_type[j]];\n\t\tif (!pti->phy_prep) {\n\t\t\tCH_ALERT(adapter, \"Invalid port type index %d\\n\",\n\t\t\t\t adapter->params.vpd.port_type[j]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tp->phy.mdio.dev = adapter->port[i];\n\t\tret = pti->phy_prep(&p->phy, adapter, ai->phy_base_addr + j,\n\t\t\t\t    ai->mdio_ops);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmac_prep(&p->mac, adapter, j);\n\n\t\t \n\t\tmemcpy(hw_addr, adapter->params.vpd.eth_base, 5);\n\t\thw_addr[5] = adapter->params.vpd.eth_base[5] + i;\n\n\t\teth_hw_addr_set(adapter->port[i], hw_addr);\n\t\tinit_link_config(&p->link_config, p->phy.caps);\n\t\tp->phy.ops->power_down(&p->phy, 1);\n\n\t\t \n\t\tif (!(p->phy.caps & SUPPORTED_IRQ) &&\n\t\t    adapter->params.linkpoll_period > 10)\n\t\t\tadapter->params.linkpoll_period = 10;\n\t}\n\n\treturn 0;\n}\n\nvoid t3_led_ready(struct adapter *adapter)\n{\n\tt3_set_reg_field(adapter, A_T3DBG_GPIO_EN, F_GPIO0_OUT_VAL,\n\t\t\t F_GPIO0_OUT_VAL);\n}\n\nint t3_replay_prep_adapter(struct adapter *adapter)\n{\n\tconst struct adapter_info *ai = adapter->params.info;\n\tunsigned int i, j = -1;\n\tint ret;\n\n\tearly_hw_init(adapter, ai);\n\tret = init_parity(adapter);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_port(adapter, i) {\n\t\tconst struct port_type_info *pti;\n\t\tstruct port_info *p = adap2pinfo(adapter, i);\n\n\t\twhile (!adapter->params.vpd.port_type[++j])\n\t\t\t;\n\n\t\tpti = &port_types[adapter->params.vpd.port_type[j]];\n\t\tret = pti->phy_prep(&p->phy, adapter, p->phy.mdio.prtad, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tp->phy.ops->power_down(&p->phy, 1);\n\t}\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}