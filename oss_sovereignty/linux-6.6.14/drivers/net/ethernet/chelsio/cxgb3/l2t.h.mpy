{
  "module_name": "l2t.h",
  "hash_id": "c92305118d407a2bae25c1fba6412df8c3e33cab1a1a923de16e2983cc3424cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb3/l2t.h",
  "human_readable_source": " \n#ifndef _CHELSIO_L2T_H\n#define _CHELSIO_L2T_H\n\n#include <linux/spinlock.h>\n#include \"t3cdev.h\"\n#include <linux/atomic.h>\n\nenum {\n\tL2T_STATE_VALID,\t \n\tL2T_STATE_STALE,\t \n\tL2T_STATE_RESOLVING,\t \n\tL2T_STATE_UNUSED\t \n};\n\nstruct neighbour;\nstruct sk_buff;\n\n \nstruct l2t_entry {\n\tu16 state;\t\t \n\tu16 idx;\t\t \n\tu32 addr;\t\t \n\tint ifindex;\t\t \n\tu16 smt_idx;\t\t \n\tu16 vlan;\t\t \n\tstruct neighbour *neigh;\t \n\tstruct l2t_entry *first;\t \n\tstruct l2t_entry *next;\t \n\tstruct sk_buff_head arpq;\t \n\tspinlock_t lock;\n\tatomic_t refcnt;\t \n\tu8 dmac[6];\t\t \n};\n\nstruct l2t_data {\n\tunsigned int nentries;\t \n\tstruct l2t_entry *rover;\t \n\tatomic_t nfree;\t\t \n\trwlock_t lock;\n\tstruct rcu_head rcu_head;\t \n\tstruct l2t_entry l2tab[];\n};\n\ntypedef void (*arp_failure_handler_func)(struct t3cdev * dev,\n\t\t\t\t\t struct sk_buff * skb);\n\n \nstruct l2t_skb_cb {\n\tarp_failure_handler_func arp_failure_handler;\n};\n\n#define L2T_SKB_CB(skb) ((struct l2t_skb_cb *)(skb)->cb)\n\nstatic inline void set_arp_failure_handler(struct sk_buff *skb,\n\t\t\t\t\t   arp_failure_handler_func hnd)\n{\n\tL2T_SKB_CB(skb)->arp_failure_handler = hnd;\n}\n\n \n#define L2DATA(cdev) (rcu_dereference((cdev)->l2opt))\n\n#define W_TCB_L2T_IX    0\n#define S_TCB_L2T_IX    7\n#define M_TCB_L2T_IX    0x7ffULL\n#define V_TCB_L2T_IX(x) ((x) << S_TCB_L2T_IX)\n\nvoid t3_l2e_free(struct l2t_data *d, struct l2t_entry *e);\nvoid t3_l2t_update(struct t3cdev *dev, struct neighbour *neigh);\nstruct l2t_entry *t3_l2t_get(struct t3cdev *cdev, struct dst_entry *dst,\n\t\t\t     struct net_device *dev, const void *daddr);\nint t3_l2t_send_slow(struct t3cdev *dev, struct sk_buff *skb,\n\t\t     struct l2t_entry *e);\nvoid t3_l2t_send_event(struct t3cdev *dev, struct l2t_entry *e);\nstruct l2t_data *t3_init_l2t(unsigned int l2t_capacity);\n\nint cxgb3_ofld_send(struct t3cdev *dev, struct sk_buff *skb);\n\nstatic inline int l2t_send(struct t3cdev *dev, struct sk_buff *skb,\n\t\t\t   struct l2t_entry *e)\n{\n\tif (likely(e->state == L2T_STATE_VALID))\n\t\treturn cxgb3_ofld_send(dev, skb);\n\treturn t3_l2t_send_slow(dev, skb, e);\n}\n\nstatic inline void l2t_release(struct t3cdev *t, struct l2t_entry *e)\n{\n\tstruct l2t_data *d;\n\n\trcu_read_lock();\n\td = L2DATA(t);\n\n\tif (atomic_dec_and_test(&e->refcnt) && d)\n\t\tt3_l2e_free(d, e);\n\n\trcu_read_unlock();\n}\n\nstatic inline void l2t_hold(struct l2t_data *d, struct l2t_entry *e)\n{\n\tif (d && atomic_add_return(1, &e->refcnt) == 1)\t \n\t\tatomic_dec(&d->nfree);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}