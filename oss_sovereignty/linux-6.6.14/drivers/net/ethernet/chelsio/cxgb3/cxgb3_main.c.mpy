{
  "module_name": "cxgb3_main.c",
  "hash_id": "b5017c6392cd421489622ba69a62b0a1646def2e4896a3d77d0514d4236d9c0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/mdio.h>\n#include <linux/sockios.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/rtnetlink.h>\n#include <linux/firmware.h>\n#include <linux/log2.h>\n#include <linux/stringify.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/nospec.h>\n\n#include \"common.h\"\n#include \"cxgb3_ioctl.h\"\n#include \"regs.h\"\n#include \"cxgb3_offload.h\"\n#include \"version.h\"\n\n#include \"cxgb3_ctl_defs.h\"\n#include \"t3_cpl.h\"\n#include \"firmware_exports.h\"\n\nenum {\n\tMAX_TXQ_ENTRIES = 16384,\n\tMAX_CTRL_TXQ_ENTRIES = 1024,\n\tMAX_RSPQ_ENTRIES = 16384,\n\tMAX_RX_BUFFERS = 16384,\n\tMAX_RX_JUMBO_BUFFERS = 16384,\n\tMIN_TXQ_ENTRIES = 4,\n\tMIN_CTRL_TXQ_ENTRIES = 4,\n\tMIN_RSPQ_ENTRIES = 32,\n\tMIN_FL_ENTRIES = 32\n};\n\n#define PORT_MASK ((1 << MAX_NPORTS) - 1)\n\n#define DFLT_MSG_ENABLE (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK | \\\n\t\t\t NETIF_MSG_TIMER | NETIF_MSG_IFDOWN | NETIF_MSG_IFUP |\\\n\t\t\t NETIF_MSG_RX_ERR | NETIF_MSG_TX_ERR)\n\n#define EEPROM_MAGIC 0x38E2F10C\n\n#define CH_DEVICE(devid, idx) \\\n\t{ PCI_VENDOR_ID_CHELSIO, devid, PCI_ANY_ID, PCI_ANY_ID, 0, 0, idx }\n\nstatic const struct pci_device_id cxgb3_pci_tbl[] = {\n\tCH_DEVICE(0x20, 0),\t \n\tCH_DEVICE(0x21, 1),\t \n\tCH_DEVICE(0x22, 2),\t \n\tCH_DEVICE(0x23, 3),\t \n\tCH_DEVICE(0x24, 1),\t \n\tCH_DEVICE(0x25, 3),\t \n\tCH_DEVICE(0x26, 2),\t \n\tCH_DEVICE(0x30, 2),\t \n\tCH_DEVICE(0x31, 3),\t \n\tCH_DEVICE(0x32, 1),\t \n\tCH_DEVICE(0x35, 6),\t \n\tCH_DEVICE(0x36, 3),\t \n\tCH_DEVICE(0x37, 7),\t \n\t{0,}\n};\n\nMODULE_DESCRIPTION(DRV_DESC);\nMODULE_AUTHOR(\"Chelsio Communications\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DEVICE_TABLE(pci, cxgb3_pci_tbl);\n\nstatic int dflt_msg_enable = DFLT_MSG_ENABLE;\n\nmodule_param(dflt_msg_enable, int, 0644);\nMODULE_PARM_DESC(dflt_msg_enable, \"Chelsio T3 default message enable bitmap\");\n\n \nstatic int msi = 2;\n\nmodule_param(msi, int, 0644);\nMODULE_PARM_DESC(msi, \"whether to use MSI or MSI-X\");\n\n \n\nstatic int ofld_disable = 0;\n\nmodule_param(ofld_disable, int, 0644);\nMODULE_PARM_DESC(ofld_disable, \"whether to enable offload at init time or not\");\n\n \nstruct workqueue_struct *cxgb3_wq;\n\n \nstatic void link_report(struct net_device *dev)\n{\n\tif (!netif_carrier_ok(dev))\n\t\tnetdev_info(dev, \"link down\\n\");\n\telse {\n\t\tconst char *s = \"10Mbps\";\n\t\tconst struct port_info *p = netdev_priv(dev);\n\n\t\tswitch (p->link_config.speed) {\n\t\tcase SPEED_10000:\n\t\t\ts = \"10Gbps\";\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\ts = \"1000Mbps\";\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\ts = \"100Mbps\";\n\t\t\tbreak;\n\t\t}\n\n\t\tnetdev_info(dev, \"link up, %s, %s-duplex\\n\",\n\t\t\t    s, p->link_config.duplex == DUPLEX_FULL\n\t\t\t    ? \"full\" : \"half\");\n\t}\n}\n\nstatic void enable_tx_fifo_drain(struct adapter *adapter,\n\t\t\t\t struct port_info *pi)\n{\n\tt3_set_reg_field(adapter, A_XGM_TXFIFO_CFG + pi->mac.offset, 0,\n\t\t\t F_ENDROPPKT);\n\tt3_write_reg(adapter, A_XGM_RX_CTRL + pi->mac.offset, 0);\n\tt3_write_reg(adapter, A_XGM_TX_CTRL + pi->mac.offset, F_TXEN);\n\tt3_write_reg(adapter, A_XGM_RX_CTRL + pi->mac.offset, F_RXEN);\n}\n\nstatic void disable_tx_fifo_drain(struct adapter *adapter,\n\t\t\t\t  struct port_info *pi)\n{\n\tt3_set_reg_field(adapter, A_XGM_TXFIFO_CFG + pi->mac.offset,\n\t\t\t F_ENDROPPKT, 0);\n}\n\nvoid t3_os_link_fault(struct adapter *adap, int port_id, int state)\n{\n\tstruct net_device *dev = adap->port[port_id];\n\tstruct port_info *pi = netdev_priv(dev);\n\n\tif (state == netif_carrier_ok(dev))\n\t\treturn;\n\n\tif (state) {\n\t\tstruct cmac *mac = &pi->mac;\n\n\t\tnetif_carrier_on(dev);\n\n\t\tdisable_tx_fifo_drain(adap, pi);\n\n\t\t \n\t\tt3_xgm_intr_disable(adap, pi->port_id);\n\t\tt3_read_reg(adap, A_XGM_INT_STATUS +\n\t\t\t\t    pi->mac.offset);\n\t\tt3_write_reg(adap,\n\t\t\t     A_XGM_INT_CAUSE + pi->mac.offset,\n\t\t\t     F_XGM_INT);\n\n\t\tt3_set_reg_field(adap,\n\t\t\t\t A_XGM_INT_ENABLE +\n\t\t\t\t pi->mac.offset,\n\t\t\t\t F_XGM_INT, F_XGM_INT);\n\t\tt3_xgm_intr_enable(adap, pi->port_id);\n\n\t\tt3_mac_enable(mac, MAC_DIRECTION_TX);\n\t} else {\n\t\tnetif_carrier_off(dev);\n\n\t\t \n\t\tenable_tx_fifo_drain(adap, pi);\n\t}\n\tlink_report(dev);\n}\n\n \nvoid t3_os_link_changed(struct adapter *adapter, int port_id, int link_stat,\n\t\t\tint speed, int duplex, int pause)\n{\n\tstruct net_device *dev = adapter->port[port_id];\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct cmac *mac = &pi->mac;\n\n\t \n\tif (!netif_running(dev))\n\t\treturn;\n\n\tif (link_stat != netif_carrier_ok(dev)) {\n\t\tif (link_stat) {\n\t\t\tdisable_tx_fifo_drain(adapter, pi);\n\n\t\t\tt3_mac_enable(mac, MAC_DIRECTION_RX);\n\n\t\t\t \n\t\t\tt3_xgm_intr_disable(adapter, pi->port_id);\n\t\t\tt3_read_reg(adapter, A_XGM_INT_STATUS +\n\t\t\t\t    pi->mac.offset);\n\t\t\tt3_write_reg(adapter,\n\t\t\t\t     A_XGM_INT_CAUSE + pi->mac.offset,\n\t\t\t\t     F_XGM_INT);\n\n\t\t\tt3_set_reg_field(adapter,\n\t\t\t\t\t A_XGM_INT_ENABLE + pi->mac.offset,\n\t\t\t\t\t F_XGM_INT, F_XGM_INT);\n\t\t\tt3_xgm_intr_enable(adapter, pi->port_id);\n\n\t\t\tnetif_carrier_on(dev);\n\t\t} else {\n\t\t\tnetif_carrier_off(dev);\n\n\t\t\tt3_xgm_intr_disable(adapter, pi->port_id);\n\t\t\tt3_read_reg(adapter, A_XGM_INT_STATUS + pi->mac.offset);\n\t\t\tt3_set_reg_field(adapter,\n\t\t\t\t\t A_XGM_INT_ENABLE + pi->mac.offset,\n\t\t\t\t\t F_XGM_INT, 0);\n\n\t\t\tif (is_10G(adapter))\n\t\t\t\tpi->phy.ops->power_down(&pi->phy, 1);\n\n\t\t\tt3_read_reg(adapter, A_XGM_INT_STATUS + pi->mac.offset);\n\t\t\tt3_mac_disable(mac, MAC_DIRECTION_RX);\n\t\t\tt3_link_start(&pi->phy, mac, &pi->link_config);\n\n\t\t\t \n\t\t\tenable_tx_fifo_drain(adapter, pi);\n\t\t}\n\n\t\tlink_report(dev);\n\t}\n}\n\n \nvoid t3_os_phymod_changed(struct adapter *adap, int port_id)\n{\n\tstatic const char *mod_str[] = {\n\t\tNULL, \"SR\", \"LR\", \"LRM\", \"TWINAX\", \"TWINAX\", \"unknown\"\n\t};\n\n\tconst struct net_device *dev = adap->port[port_id];\n\tconst struct port_info *pi = netdev_priv(dev);\n\n\tif (pi->phy.modtype == phy_modtype_none)\n\t\tnetdev_info(dev, \"PHY module unplugged\\n\");\n\telse\n\t\tnetdev_info(dev, \"%s PHY module inserted\\n\",\n\t\t\t    mod_str[pi->phy.modtype]);\n}\n\nstatic void cxgb_set_rxmode(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\n\tt3_mac_set_rx_mode(&pi->mac, dev);\n}\n\n \nstatic void link_start(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct cmac *mac = &pi->mac;\n\n\tt3_mac_reset(mac);\n\tt3_mac_set_num_ucast(mac, MAX_MAC_IDX);\n\tt3_mac_set_mtu(mac, dev->mtu);\n\tt3_mac_set_address(mac, LAN_MAC_IDX, dev->dev_addr);\n\tt3_mac_set_address(mac, SAN_MAC_IDX, pi->iscsic.mac_addr);\n\tt3_mac_set_rx_mode(mac, dev);\n\tt3_link_start(&pi->phy, mac, &pi->link_config);\n\tt3_mac_enable(mac, MAC_DIRECTION_RX | MAC_DIRECTION_TX);\n}\n\nstatic inline void cxgb_disable_msi(struct adapter *adapter)\n{\n\tif (adapter->flags & USING_MSIX) {\n\t\tpci_disable_msix(adapter->pdev);\n\t\tadapter->flags &= ~USING_MSIX;\n\t} else if (adapter->flags & USING_MSI) {\n\t\tpci_disable_msi(adapter->pdev);\n\t\tadapter->flags &= ~USING_MSI;\n\t}\n}\n\n \nstatic irqreturn_t t3_async_intr_handler(int irq, void *cookie)\n{\n\tt3_slow_intr_handler(cookie);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void name_msix_vecs(struct adapter *adap)\n{\n\tint i, j, msi_idx = 1, n = sizeof(adap->msix_info[0].desc) - 1;\n\n\tsnprintf(adap->msix_info[0].desc, n, \"%s\", adap->name);\n\tadap->msix_info[0].desc[n] = 0;\n\n\tfor_each_port(adap, j) {\n\t\tstruct net_device *d = adap->port[j];\n\t\tconst struct port_info *pi = netdev_priv(d);\n\n\t\tfor (i = 0; i < pi->nqsets; i++, msi_idx++) {\n\t\t\tsnprintf(adap->msix_info[msi_idx].desc, n,\n\t\t\t\t \"%s-%d\", d->name, pi->first_qset + i);\n\t\t\tadap->msix_info[msi_idx].desc[n] = 0;\n\t\t}\n\t}\n}\n\nstatic int request_msix_data_irqs(struct adapter *adap)\n{\n\tint i, j, err, qidx = 0;\n\n\tfor_each_port(adap, i) {\n\t\tint nqsets = adap2pinfo(adap, i)->nqsets;\n\n\t\tfor (j = 0; j < nqsets; ++j) {\n\t\t\terr = request_irq(adap->msix_info[qidx + 1].vec,\n\t\t\t\t\t  t3_intr_handler(adap,\n\t\t\t\t\t\t\t  adap->sge.qs[qidx].\n\t\t\t\t\t\t\t  rspq.polling), 0,\n\t\t\t\t\t  adap->msix_info[qidx + 1].desc,\n\t\t\t\t\t  &adap->sge.qs[qidx]);\n\t\t\tif (err) {\n\t\t\t\twhile (--qidx >= 0)\n\t\t\t\t\tfree_irq(adap->msix_info[qidx + 1].vec,\n\t\t\t\t\t\t &adap->sge.qs[qidx]);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tqidx++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void free_irq_resources(struct adapter *adapter)\n{\n\tif (adapter->flags & USING_MSIX) {\n\t\tint i, n = 0;\n\n\t\tfree_irq(adapter->msix_info[0].vec, adapter);\n\t\tfor_each_port(adapter, i)\n\t\t\tn += adap2pinfo(adapter, i)->nqsets;\n\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tfree_irq(adapter->msix_info[i + 1].vec,\n\t\t\t\t &adapter->sge.qs[i]);\n\t} else\n\t\tfree_irq(adapter->pdev->irq, adapter);\n}\n\nstatic int await_mgmt_replies(struct adapter *adap, unsigned long init_cnt,\n\t\t\t      unsigned long n)\n{\n\tint attempts = 10;\n\n\twhile (adap->sge.qs[0].rspq.offload_pkts < init_cnt + n) {\n\t\tif (!--attempts)\n\t\t\treturn -ETIMEDOUT;\n\t\tmsleep(10);\n\t}\n\treturn 0;\n}\n\nstatic int init_tp_parity(struct adapter *adap)\n{\n\tint i;\n\tstruct sk_buff *skb;\n\tstruct cpl_set_tcb_field *greq;\n\tunsigned long cnt = adap->sge.qs[0].rspq.offload_pkts;\n\n\tt3_tp_set_offload_mode(adap, 1);\n\n\tfor (i = 0; i < 16; i++) {\n\t\tstruct cpl_smt_write_req *req;\n\n\t\tskb = alloc_skb(sizeof(*req), GFP_KERNEL);\n\t\tif (!skb)\n\t\t\tskb = adap->nofail_skb;\n\t\tif (!skb)\n\t\t\tgoto alloc_skb_fail;\n\n\t\treq = __skb_put_zero(skb, sizeof(*req));\n\t\treq->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_FORWARD));\n\t\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_SMT_WRITE_REQ, i));\n\t\treq->mtu_idx = NMTUS - 1;\n\t\treq->iff = i;\n\t\tt3_mgmt_tx(adap, skb);\n\t\tif (skb == adap->nofail_skb) {\n\t\t\tawait_mgmt_replies(adap, cnt, i + 1);\n\t\t\tadap->nofail_skb = alloc_skb(sizeof(*greq), GFP_KERNEL);\n\t\t\tif (!adap->nofail_skb)\n\t\t\t\tgoto alloc_skb_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 2048; i++) {\n\t\tstruct cpl_l2t_write_req *req;\n\n\t\tskb = alloc_skb(sizeof(*req), GFP_KERNEL);\n\t\tif (!skb)\n\t\t\tskb = adap->nofail_skb;\n\t\tif (!skb)\n\t\t\tgoto alloc_skb_fail;\n\n\t\treq = __skb_put_zero(skb, sizeof(*req));\n\t\treq->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_FORWARD));\n\t\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_L2T_WRITE_REQ, i));\n\t\treq->params = htonl(V_L2T_W_IDX(i));\n\t\tt3_mgmt_tx(adap, skb);\n\t\tif (skb == adap->nofail_skb) {\n\t\t\tawait_mgmt_replies(adap, cnt, 16 + i + 1);\n\t\t\tadap->nofail_skb = alloc_skb(sizeof(*greq), GFP_KERNEL);\n\t\t\tif (!adap->nofail_skb)\n\t\t\t\tgoto alloc_skb_fail;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 2048; i++) {\n\t\tstruct cpl_rte_write_req *req;\n\n\t\tskb = alloc_skb(sizeof(*req), GFP_KERNEL);\n\t\tif (!skb)\n\t\t\tskb = adap->nofail_skb;\n\t\tif (!skb)\n\t\t\tgoto alloc_skb_fail;\n\n\t\treq = __skb_put_zero(skb, sizeof(*req));\n\t\treq->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_FORWARD));\n\t\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_RTE_WRITE_REQ, i));\n\t\treq->l2t_idx = htonl(V_L2T_W_IDX(i));\n\t\tt3_mgmt_tx(adap, skb);\n\t\tif (skb == adap->nofail_skb) {\n\t\t\tawait_mgmt_replies(adap, cnt, 16 + 2048 + i + 1);\n\t\t\tadap->nofail_skb = alloc_skb(sizeof(*greq), GFP_KERNEL);\n\t\t\tif (!adap->nofail_skb)\n\t\t\t\tgoto alloc_skb_fail;\n\t\t}\n\t}\n\n\tskb = alloc_skb(sizeof(*greq), GFP_KERNEL);\n\tif (!skb)\n\t\tskb = adap->nofail_skb;\n\tif (!skb)\n\t\tgoto alloc_skb_fail;\n\n\tgreq = __skb_put_zero(skb, sizeof(*greq));\n\tgreq->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_FORWARD));\n\tOPCODE_TID(greq) = htonl(MK_OPCODE_TID(CPL_SET_TCB_FIELD, 0));\n\tgreq->mask = cpu_to_be64(1);\n\tt3_mgmt_tx(adap, skb);\n\n\ti = await_mgmt_replies(adap, cnt, 16 + 2048 + 2048 + 1);\n\tif (skb == adap->nofail_skb) {\n\t\ti = await_mgmt_replies(adap, cnt, 16 + 2048 + 2048 + 1);\n\t\tadap->nofail_skb = alloc_skb(sizeof(*greq), GFP_KERNEL);\n\t}\n\n\tt3_tp_set_offload_mode(adap, 0);\n\treturn i;\n\nalloc_skb_fail:\n\tt3_tp_set_offload_mode(adap, 0);\n\treturn -ENOMEM;\n}\n\n \nstatic void setup_rss(struct adapter *adap)\n{\n\tint i;\n\tunsigned int nq0 = adap2pinfo(adap, 0)->nqsets;\n\tunsigned int nq1 = adap->port[1] ? adap2pinfo(adap, 1)->nqsets : 1;\n\tu8 cpus[SGE_QSETS + 1];\n\tu16 rspq_map[RSS_TABLE_SIZE + 1];\n\n\tfor (i = 0; i < SGE_QSETS; ++i)\n\t\tcpus[i] = i;\n\tcpus[SGE_QSETS] = 0xff;\t \n\n\tfor (i = 0; i < RSS_TABLE_SIZE / 2; ++i) {\n\t\trspq_map[i] = i % nq0;\n\t\trspq_map[i + RSS_TABLE_SIZE / 2] = (i % nq1) + nq0;\n\t}\n\trspq_map[RSS_TABLE_SIZE] = 0xffff;  \n\n\tt3_config_rss(adap, F_RQFEEDBACKENABLE | F_TNLLKPEN | F_TNLMAPEN |\n\t\t      F_TNLPRTEN | F_TNL2TUPEN | F_TNL4TUPEN |\n\t\t      V_RRCPLCPUSIZE(6) | F_HASHTOEPLITZ, cpus, rspq_map);\n}\n\nstatic void ring_dbs(struct adapter *adap)\n{\n\tint i, j;\n\n\tfor (i = 0; i < SGE_QSETS; i++) {\n\t\tstruct sge_qset *qs = &adap->sge.qs[i];\n\n\t\tif (qs->adap)\n\t\t\tfor (j = 0; j < SGE_TXQ_PER_SET; j++)\n\t\t\t\tt3_write_reg(adap, A_SG_KDOORBELL, F_SELEGRCNTX | V_EGRCNTX(qs->txq[j].cntxt_id));\n\t}\n}\n\nstatic void init_napi(struct adapter *adap)\n{\n\tint i;\n\n\tfor (i = 0; i < SGE_QSETS; i++) {\n\t\tstruct sge_qset *qs = &adap->sge.qs[i];\n\n\t\tif (qs->adap)\n\t\t\tnetif_napi_add(qs->netdev, &qs->napi, qs->napi.poll);\n\t}\n\n\t \n\tadap->flags |= NAPI_INIT;\n}\n\n \nstatic void quiesce_rx(struct adapter *adap)\n{\n\tint i;\n\n\tfor (i = 0; i < SGE_QSETS; i++)\n\t\tif (adap->sge.qs[i].adap)\n\t\t\tnapi_disable(&adap->sge.qs[i].napi);\n}\n\nstatic void enable_all_napi(struct adapter *adap)\n{\n\tint i;\n\tfor (i = 0; i < SGE_QSETS; i++)\n\t\tif (adap->sge.qs[i].adap)\n\t\t\tnapi_enable(&adap->sge.qs[i].napi);\n}\n\n \nstatic int setup_sge_qsets(struct adapter *adap)\n{\n\tint i, j, err, irq_idx = 0, qset_idx = 0;\n\tunsigned int ntxq = SGE_TXQ_PER_SET;\n\n\tif (adap->params.rev > 0 && !(adap->flags & USING_MSI))\n\t\tirq_idx = -1;\n\n\tfor_each_port(adap, i) {\n\t\tstruct net_device *dev = adap->port[i];\n\t\tstruct port_info *pi = netdev_priv(dev);\n\n\t\tpi->qs = &adap->sge.qs[pi->first_qset];\n\t\tfor (j = 0; j < pi->nqsets; ++j, ++qset_idx) {\n\t\t\terr = t3_sge_alloc_qset(adap, qset_idx, 1,\n\t\t\t\t(adap->flags & USING_MSIX) ? qset_idx + 1 :\n\t\t\t\t\t\t\t     irq_idx,\n\t\t\t\t&adap->params.sge.qset[qset_idx], ntxq, dev,\n\t\t\t\tnetdev_get_tx_queue(dev, j));\n\t\t\tif (err) {\n\t\t\t\tt3_free_sge_resources(adap);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t attr_show(struct device *d, char *buf,\n\t\t\t ssize_t(*format) (struct net_device *, char *))\n{\n\tssize_t len;\n\n\t \n\trtnl_lock();\n\tlen = (*format) (to_net_dev(d), buf);\n\trtnl_unlock();\n\treturn len;\n}\n\nstatic ssize_t attr_store(struct device *d,\n\t\t\t  const char *buf, size_t len,\n\t\t\t  ssize_t(*set) (struct net_device *, unsigned int),\n\t\t\t  unsigned int min_val, unsigned int max_val)\n{\n\tssize_t ret;\n\tunsigned int val;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tret = kstrtouint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val < min_val || val > max_val)\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\tret = (*set) (to_net_dev(d), val);\n\tif (!ret)\n\t\tret = len;\n\trtnl_unlock();\n\treturn ret;\n}\n\n#define CXGB3_SHOW(name, val_expr) \\\nstatic ssize_t format_##name(struct net_device *dev, char *buf) \\\n{ \\\n\tstruct port_info *pi = netdev_priv(dev); \\\n\tstruct adapter *adap = pi->adapter; \\\n\treturn sprintf(buf, \"%u\\n\", val_expr); \\\n} \\\nstatic ssize_t show_##name(struct device *d, struct device_attribute *attr, \\\n\t\t\t   char *buf) \\\n{ \\\n\treturn attr_show(d, buf, format_##name); \\\n}\n\nstatic ssize_t set_nfilters(struct net_device *dev, unsigned int val)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\tint min_tids = is_offload(adap) ? MC5_MIN_TIDS : 0;\n\n\tif (adap->flags & FULL_INIT_DONE)\n\t\treturn -EBUSY;\n\tif (val && adap->params.rev == 0)\n\t\treturn -EINVAL;\n\tif (val > t3_mc5_size(&adap->mc5) - adap->params.mc5.nservers -\n\t    min_tids)\n\t\treturn -EINVAL;\n\tadap->params.mc5.nfilters = val;\n\treturn 0;\n}\n\nstatic ssize_t store_nfilters(struct device *d, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t len)\n{\n\treturn attr_store(d, buf, len, set_nfilters, 0, ~0);\n}\n\nstatic ssize_t set_nservers(struct net_device *dev, unsigned int val)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adap = pi->adapter;\n\n\tif (adap->flags & FULL_INIT_DONE)\n\t\treturn -EBUSY;\n\tif (val > t3_mc5_size(&adap->mc5) - adap->params.mc5.nfilters -\n\t    MC5_MIN_TIDS)\n\t\treturn -EINVAL;\n\tadap->params.mc5.nservers = val;\n\treturn 0;\n}\n\nstatic ssize_t store_nservers(struct device *d, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t len)\n{\n\treturn attr_store(d, buf, len, set_nservers, 0, ~0);\n}\n\n#define CXGB3_ATTR_R(name, val_expr) \\\nCXGB3_SHOW(name, val_expr) \\\nstatic DEVICE_ATTR(name, 0444, show_##name, NULL)\n\n#define CXGB3_ATTR_RW(name, val_expr, store_method) \\\nCXGB3_SHOW(name, val_expr) \\\nstatic DEVICE_ATTR(name, 0644, show_##name, store_method)\n\nCXGB3_ATTR_R(cam_size, t3_mc5_size(&adap->mc5));\nCXGB3_ATTR_RW(nfilters, adap->params.mc5.nfilters, store_nfilters);\nCXGB3_ATTR_RW(nservers, adap->params.mc5.nservers, store_nservers);\n\nstatic struct attribute *cxgb3_attrs[] = {\n\t&dev_attr_cam_size.attr,\n\t&dev_attr_nfilters.attr,\n\t&dev_attr_nservers.attr,\n\tNULL\n};\n\nstatic const struct attribute_group cxgb3_attr_group = {\n\t.attrs = cxgb3_attrs,\n};\n\nstatic ssize_t tm_attr_show(struct device *d,\n\t\t\t    char *buf, int sched)\n{\n\tstruct port_info *pi = netdev_priv(to_net_dev(d));\n\tstruct adapter *adap = pi->adapter;\n\tunsigned int v, addr, bpt, cpt;\n\tssize_t len;\n\n\taddr = A_TP_TX_MOD_Q1_Q0_RATE_LIMIT - sched / 2;\n\trtnl_lock();\n\tt3_write_reg(adap, A_TP_TM_PIO_ADDR, addr);\n\tv = t3_read_reg(adap, A_TP_TM_PIO_DATA);\n\tif (sched & 1)\n\t\tv >>= 16;\n\tbpt = (v >> 8) & 0xff;\n\tcpt = v & 0xff;\n\tif (!cpt)\n\t\tlen = sprintf(buf, \"disabled\\n\");\n\telse {\n\t\tv = (adap->params.vpd.cclk * 1000) / cpt;\n\t\tlen = sprintf(buf, \"%u Kbps\\n\", (v * bpt) / 125);\n\t}\n\trtnl_unlock();\n\treturn len;\n}\n\nstatic ssize_t tm_attr_store(struct device *d,\n\t\t\t     const char *buf, size_t len, int sched)\n{\n\tstruct port_info *pi = netdev_priv(to_net_dev(d));\n\tstruct adapter *adap = pi->adapter;\n\tunsigned int val;\n\tssize_t ret;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tret = kstrtouint(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val > 10000000)\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\tret = t3_config_sched(adap, val, sched);\n\tif (!ret)\n\t\tret = len;\n\trtnl_unlock();\n\treturn ret;\n}\n\n#define TM_ATTR(name, sched) \\\nstatic ssize_t show_##name(struct device *d, struct device_attribute *attr, \\\n\t\t\t   char *buf) \\\n{ \\\n\treturn tm_attr_show(d, buf, sched); \\\n} \\\nstatic ssize_t store_##name(struct device *d, struct device_attribute *attr, \\\n\t\t\t    const char *buf, size_t len) \\\n{ \\\n\treturn tm_attr_store(d, buf, len, sched); \\\n} \\\nstatic DEVICE_ATTR(name, 0644, show_##name, store_##name)\n\nTM_ATTR(sched0, 0);\nTM_ATTR(sched1, 1);\nTM_ATTR(sched2, 2);\nTM_ATTR(sched3, 3);\nTM_ATTR(sched4, 4);\nTM_ATTR(sched5, 5);\nTM_ATTR(sched6, 6);\nTM_ATTR(sched7, 7);\n\nstatic struct attribute *offload_attrs[] = {\n\t&dev_attr_sched0.attr,\n\t&dev_attr_sched1.attr,\n\t&dev_attr_sched2.attr,\n\t&dev_attr_sched3.attr,\n\t&dev_attr_sched4.attr,\n\t&dev_attr_sched5.attr,\n\t&dev_attr_sched6.attr,\n\t&dev_attr_sched7.attr,\n\tNULL\n};\n\nstatic const struct attribute_group offload_attr_group = {\n\t.attrs = offload_attrs,\n};\n\n \nstatic inline int offload_tx(struct t3cdev *tdev, struct sk_buff *skb)\n{\n\tint ret;\n\n\tlocal_bh_disable();\n\tret = t3_offload_tx(tdev, skb);\n\tlocal_bh_enable();\n\treturn ret;\n}\n\nstatic int write_smt_entry(struct adapter *adapter, int idx)\n{\n\tstruct cpl_smt_write_req *req;\n\tstruct port_info *pi = netdev_priv(adapter->port[idx]);\n\tstruct sk_buff *skb = alloc_skb(sizeof(*req), GFP_KERNEL);\n\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treq = __skb_put(skb, sizeof(*req));\n\treq->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_FORWARD));\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_SMT_WRITE_REQ, idx));\n\treq->mtu_idx = NMTUS - 1;\t \n\treq->iff = idx;\n\tmemcpy(req->src_mac0, adapter->port[idx]->dev_addr, ETH_ALEN);\n\tmemcpy(req->src_mac1, pi->iscsic.mac_addr, ETH_ALEN);\n\tskb->priority = 1;\n\toffload_tx(&adapter->tdev, skb);\n\treturn 0;\n}\n\nstatic int init_smt(struct adapter *adapter)\n{\n\tint i;\n\n\tfor_each_port(adapter, i)\n\t    write_smt_entry(adapter, i);\n\treturn 0;\n}\n\nstatic void init_port_mtus(struct adapter *adapter)\n{\n\tunsigned int mtus = adapter->port[0]->mtu;\n\n\tif (adapter->port[1])\n\t\tmtus |= adapter->port[1]->mtu << 16;\n\tt3_write_reg(adapter, A_TP_MTU_PORT_TABLE, mtus);\n}\n\nstatic int send_pktsched_cmd(struct adapter *adap, int sched, int qidx, int lo,\n\t\t\t      int hi, int port)\n{\n\tstruct sk_buff *skb;\n\tstruct mngt_pktsched_wr *req;\n\tint ret;\n\n\tskb = alloc_skb(sizeof(*req), GFP_KERNEL);\n\tif (!skb)\n\t\tskb = adap->nofail_skb;\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treq = skb_put(skb, sizeof(*req));\n\treq->wr_hi = htonl(V_WR_OP(FW_WROPCODE_MNGT));\n\treq->mngt_opcode = FW_MNGTOPCODE_PKTSCHED_SET;\n\treq->sched = sched;\n\treq->idx = qidx;\n\treq->min = lo;\n\treq->max = hi;\n\treq->binding = port;\n\tret = t3_mgmt_tx(adap, skb);\n\tif (skb == adap->nofail_skb) {\n\t\tadap->nofail_skb = alloc_skb(sizeof(struct cpl_set_tcb_field),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!adap->nofail_skb)\n\t\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}\n\nstatic int bind_qsets(struct adapter *adap)\n{\n\tint i, j, err = 0;\n\n\tfor_each_port(adap, i) {\n\t\tconst struct port_info *pi = adap2pinfo(adap, i);\n\n\t\tfor (j = 0; j < pi->nqsets; ++j) {\n\t\t\tint ret = send_pktsched_cmd(adap, 1,\n\t\t\t\t\t\t    pi->first_qset + j, -1,\n\t\t\t\t\t\t    -1, i);\n\t\t\tif (ret)\n\t\t\t\terr = ret;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n#define FW_VERSION __stringify(FW_VERSION_MAJOR) \".\"\t\t\t\\\n\t__stringify(FW_VERSION_MINOR) \".\" __stringify(FW_VERSION_MICRO)\n#define FW_FNAME \"cxgb3/t3fw-\" FW_VERSION \".bin\"\n#define TPSRAM_VERSION __stringify(TP_VERSION_MAJOR) \".\"\t\t\\\n\t__stringify(TP_VERSION_MINOR) \".\" __stringify(TP_VERSION_MICRO)\n#define TPSRAM_NAME \"cxgb3/t3%c_psram-\" TPSRAM_VERSION \".bin\"\n#define AEL2005_OPT_EDC_NAME \"cxgb3/ael2005_opt_edc.bin\"\n#define AEL2005_TWX_EDC_NAME \"cxgb3/ael2005_twx_edc.bin\"\n#define AEL2020_TWX_EDC_NAME \"cxgb3/ael2020_twx_edc.bin\"\nMODULE_FIRMWARE(FW_FNAME);\nMODULE_FIRMWARE(\"cxgb3/t3b_psram-\" TPSRAM_VERSION \".bin\");\nMODULE_FIRMWARE(\"cxgb3/t3c_psram-\" TPSRAM_VERSION \".bin\");\nMODULE_FIRMWARE(AEL2005_OPT_EDC_NAME);\nMODULE_FIRMWARE(AEL2005_TWX_EDC_NAME);\nMODULE_FIRMWARE(AEL2020_TWX_EDC_NAME);\n\nstatic inline const char *get_edc_fw_name(int edc_idx)\n{\n\tconst char *fw_name = NULL;\n\n\tswitch (edc_idx) {\n\tcase EDC_OPT_AEL2005:\n\t\tfw_name = AEL2005_OPT_EDC_NAME;\n\t\tbreak;\n\tcase EDC_TWX_AEL2005:\n\t\tfw_name = AEL2005_TWX_EDC_NAME;\n\t\tbreak;\n\tcase EDC_TWX_AEL2020:\n\t\tfw_name = AEL2020_TWX_EDC_NAME;\n\t\tbreak;\n\t}\n\treturn fw_name;\n}\n\nint t3_get_edc_fw(struct cphy *phy, int edc_idx, int size)\n{\n\tstruct adapter *adapter = phy->adapter;\n\tconst struct firmware *fw;\n\tconst char *fw_name;\n\tu32 csum;\n\tconst __be32 *p;\n\tu16 *cache = phy->phy_cache;\n\tint i, ret = -EINVAL;\n\n\tfw_name = get_edc_fw_name(edc_idx);\n\tif (fw_name)\n\t\tret = request_firmware(&fw, fw_name, &adapter->pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"could not upgrade firmware: unable to load %s\\n\",\n\t\t\tfw_name);\n\t\treturn ret;\n\t}\n\n\t \n\tif (fw->size > size + 4) {\n\t\tCH_ERR(adapter, \"firmware image too large %u, expected %d\\n\",\n\t\t       (unsigned int)fw->size, size + 4);\n\t\tret = -EINVAL;\n\t}\n\n\t \n\tp = (const __be32 *)fw->data;\n\tfor (csum = 0, i = 0; i < fw->size / sizeof(csum); i++)\n\t\tcsum += ntohl(p[i]);\n\n\tif (csum != 0xffffffff) {\n\t\tCH_ERR(adapter, \"corrupted firmware image, checksum %u\\n\",\n\t\t       csum);\n\t\tret = -EINVAL;\n\t}\n\n\tfor (i = 0; i < size / 4 ; i++) {\n\t\t*cache++ = (be32_to_cpu(p[i]) & 0xffff0000) >> 16;\n\t\t*cache++ = be32_to_cpu(p[i]) & 0xffff;\n\t}\n\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int upgrade_fw(struct adapter *adap)\n{\n\tint ret;\n\tconst struct firmware *fw;\n\tstruct device *dev = &adap->pdev->dev;\n\n\tret = request_firmware(&fw, FW_FNAME, dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not upgrade firmware: unable to load %s\\n\",\n\t\t\tFW_FNAME);\n\t\treturn ret;\n\t}\n\tret = t3_load_fw(adap, fw->data, fw->size);\n\trelease_firmware(fw);\n\n\tif (ret == 0)\n\t\tdev_info(dev, \"successful upgrade to firmware %d.%d.%d\\n\",\n\t\t\t FW_VERSION_MAJOR, FW_VERSION_MINOR, FW_VERSION_MICRO);\n\telse\n\t\tdev_err(dev, \"failed to upgrade to firmware %d.%d.%d\\n\",\n\t\t\tFW_VERSION_MAJOR, FW_VERSION_MINOR, FW_VERSION_MICRO);\n\n\treturn ret;\n}\n\nstatic inline char t3rev2char(struct adapter *adapter)\n{\n\tchar rev = 0;\n\n\tswitch(adapter->params.rev) {\n\tcase T3_REV_B:\n\tcase T3_REV_B2:\n\t\trev = 'b';\n\t\tbreak;\n\tcase T3_REV_C:\n\t\trev = 'c';\n\t\tbreak;\n\t}\n\treturn rev;\n}\n\nstatic int update_tpsram(struct adapter *adap)\n{\n\tconst struct firmware *tpsram;\n\tchar buf[64];\n\tstruct device *dev = &adap->pdev->dev;\n\tint ret;\n\tchar rev;\n\n\trev = t3rev2char(adap);\n\tif (!rev)\n\t\treturn 0;\n\n\tsnprintf(buf, sizeof(buf), TPSRAM_NAME, rev);\n\n\tret = request_firmware(&tpsram, buf, dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not load TP SRAM: unable to load %s\\n\",\n\t\t\tbuf);\n\t\treturn ret;\n\t}\n\n\tret = t3_check_tpsram(adap, tpsram->data, tpsram->size);\n\tif (ret)\n\t\tgoto release_tpsram;\n\n\tret = t3_set_proto_sram(adap, tpsram->data);\n\tif (ret == 0)\n\t\tdev_info(dev,\n\t\t\t \"successful update of protocol engine \"\n\t\t\t \"to %d.%d.%d\\n\",\n\t\t\t TP_VERSION_MAJOR, TP_VERSION_MINOR, TP_VERSION_MICRO);\n\telse\n\t\tdev_err(dev, \"failed to update of protocol engine %d.%d.%d\\n\",\n\t\t\tTP_VERSION_MAJOR, TP_VERSION_MINOR, TP_VERSION_MICRO);\n\tif (ret)\n\t\tdev_err(dev, \"loading protocol SRAM failed\\n\");\n\nrelease_tpsram:\n\trelease_firmware(tpsram);\n\n\treturn ret;\n}\n\n \nstatic void t3_synchronize_rx(struct adapter *adap, const struct port_info *p)\n{\n\tint i;\n\n\tfor (i = p->first_qset; i < p->first_qset + p->nqsets; i++) {\n\t\tstruct sge_rspq *q = &adap->sge.qs[i].rspq;\n\n\t\tspin_lock_irq(&q->lock);\n\t\tspin_unlock_irq(&q->lock);\n\t}\n}\n\nstatic void cxgb_vlan_mode(struct net_device *dev, netdev_features_t features)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\tif (adapter->params.rev > 0) {\n\t\tt3_set_vlan_accel(adapter, 1 << pi->port_id,\n\t\t\t\t  features & NETIF_F_HW_VLAN_CTAG_RX);\n\t} else {\n\t\t \n\t\tunsigned int i, have_vlans = features & NETIF_F_HW_VLAN_CTAG_RX;\n\n\t\tfor_each_port(adapter, i)\n\t\t\thave_vlans |=\n\t\t\t\tadapter->port[i]->features &\n\t\t\t\tNETIF_F_HW_VLAN_CTAG_RX;\n\n\t\tt3_set_vlan_accel(adapter, 1, have_vlans);\n\t}\n\tt3_synchronize_rx(adapter, pi);\n}\n\n \nstatic int cxgb_up(struct adapter *adap)\n{\n\tint i, err;\n\n\tif (!(adap->flags & FULL_INIT_DONE)) {\n\t\terr = t3_check_fw_version(adap);\n\t\tif (err == -EINVAL) {\n\t\t\terr = upgrade_fw(adap);\n\t\t\tCH_WARN(adap, \"FW upgrade to %d.%d.%d %s\\n\",\n\t\t\t\tFW_VERSION_MAJOR, FW_VERSION_MINOR,\n\t\t\t\tFW_VERSION_MICRO, err ? \"failed\" : \"succeeded\");\n\t\t}\n\n\t\terr = t3_check_tpsram_version(adap);\n\t\tif (err == -EINVAL) {\n\t\t\terr = update_tpsram(adap);\n\t\t\tCH_WARN(adap, \"TP upgrade to %d.%d.%d %s\\n\",\n\t\t\t\tTP_VERSION_MAJOR, TP_VERSION_MINOR,\n\t\t\t\tTP_VERSION_MICRO, err ? \"failed\" : \"succeeded\");\n\t\t}\n\n\t\t \n\t\tt3_intr_clear(adap);\n\n\t\terr = t3_init_hw(adap, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tt3_set_reg_field(adap, A_TP_PARA_REG5, 0, F_RXDDPOFFINIT);\n\t\tt3_write_reg(adap, A_ULPRX_TDDP_PSZ, V_HPZ0(PAGE_SHIFT - 12));\n\n\t\terr = setup_sge_qsets(adap);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfor_each_port(adap, i)\n\t\t\tcxgb_vlan_mode(adap->port[i], adap->port[i]->features);\n\n\t\tsetup_rss(adap);\n\t\tif (!(adap->flags & NAPI_INIT))\n\t\t\tinit_napi(adap);\n\n\t\tt3_start_sge_timers(adap);\n\t\tadap->flags |= FULL_INIT_DONE;\n\t}\n\n\tt3_intr_clear(adap);\n\n\tif (adap->flags & USING_MSIX) {\n\t\tname_msix_vecs(adap);\n\t\terr = request_irq(adap->msix_info[0].vec,\n\t\t\t\t  t3_async_intr_handler, 0,\n\t\t\t\t  adap->msix_info[0].desc, adap);\n\t\tif (err)\n\t\t\tgoto irq_err;\n\n\t\terr = request_msix_data_irqs(adap);\n\t\tif (err) {\n\t\t\tfree_irq(adap->msix_info[0].vec, adap);\n\t\t\tgoto irq_err;\n\t\t}\n\t} else {\n\t\terr = request_irq(adap->pdev->irq,\n\t\t\t\t  t3_intr_handler(adap, adap->sge.qs[0].rspq.polling),\n\t\t\t\t  (adap->flags & USING_MSI) ? 0 : IRQF_SHARED,\n\t\t\t\t  adap->name, adap);\n\t\tif (err)\n\t\t\tgoto irq_err;\n\t}\n\n\tenable_all_napi(adap);\n\tt3_sge_start(adap);\n\tt3_intr_enable(adap);\n\n\tif (adap->params.rev >= T3_REV_C && !(adap->flags & TP_PARITY_INIT) &&\n\t    is_offload(adap) && init_tp_parity(adap) == 0)\n\t\tadap->flags |= TP_PARITY_INIT;\n\n\tif (adap->flags & TP_PARITY_INIT) {\n\t\tt3_write_reg(adap, A_TP_INT_CAUSE,\n\t\t\t     F_CMCACHEPERR | F_ARPLUTPERR);\n\t\tt3_write_reg(adap, A_TP_INT_ENABLE, 0x7fbfffff);\n\t}\n\n\tif (!(adap->flags & QUEUES_BOUND)) {\n\t\tint ret = bind_qsets(adap);\n\n\t\tif (ret < 0) {\n\t\t\tCH_ERR(adap, \"failed to bind qsets, err %d\\n\", ret);\n\t\t\tt3_intr_disable(adap);\n\t\t\tquiesce_rx(adap);\n\t\t\tfree_irq_resources(adap);\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tadap->flags |= QUEUES_BOUND;\n\t}\n\nout:\n\treturn err;\nirq_err:\n\tCH_ERR(adap, \"request_irq failed, err %d\\n\", err);\n\tgoto out;\n}\n\n \nstatic void cxgb_down(struct adapter *adapter, int on_wq)\n{\n\tt3_sge_stop(adapter);\n\tspin_lock_irq(&adapter->work_lock);\t \n\tt3_intr_disable(adapter);\n\tspin_unlock_irq(&adapter->work_lock);\n\n\tfree_irq_resources(adapter);\n\tquiesce_rx(adapter);\n\tt3_sge_stop(adapter);\n\tif (!on_wq)\n\t\tflush_workqueue(cxgb3_wq); \n}\n\nstatic void schedule_chk_task(struct adapter *adap)\n{\n\tunsigned int timeo;\n\n\ttimeo = adap->params.linkpoll_period ?\n\t    (HZ * adap->params.linkpoll_period) / 10 :\n\t    adap->params.stats_update_period * HZ;\n\tif (timeo)\n\t\tqueue_delayed_work(cxgb3_wq, &adap->adap_check_task, timeo);\n}\n\nstatic int offload_open(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tstruct t3cdev *tdev = dev2t3cdev(dev);\n\tint adap_up = adapter->open_device_map & PORT_MASK;\n\tint err;\n\n\tif (test_and_set_bit(OFFLOAD_DEVMAP_BIT, &adapter->open_device_map))\n\t\treturn 0;\n\n\tif (!adap_up && (err = cxgb_up(adapter)) < 0)\n\t\tgoto out;\n\n\tt3_tp_set_offload_mode(adapter, 1);\n\ttdev->lldev = adapter->port[0];\n\terr = cxgb3_offload_activate(adapter);\n\tif (err)\n\t\tgoto out;\n\n\tinit_port_mtus(adapter);\n\tt3_load_mtus(adapter, adapter->params.mtus, adapter->params.a_wnd,\n\t\t     adapter->params.b_wnd,\n\t\t     adapter->params.rev == 0 ?\n\t\t     adapter->port[0]->mtu : 0xffff);\n\tinit_smt(adapter);\n\n\tif (sysfs_create_group(&tdev->lldev->dev.kobj, &offload_attr_group))\n\t\tdev_dbg(&dev->dev, \"cannot create sysfs group\\n\");\n\n\t \n\tcxgb3_add_clients(tdev);\n\nout:\n\t \n\tif (err) {\n\t\tt3_tp_set_offload_mode(adapter, 0);\n\t\tclear_bit(OFFLOAD_DEVMAP_BIT, &adapter->open_device_map);\n\t\tcxgb3_set_dummy_ops(tdev);\n\t}\n\treturn err;\n}\n\nstatic int offload_close(struct t3cdev *tdev)\n{\n\tstruct adapter *adapter = tdev2adap(tdev);\n\tstruct t3c_data *td = T3C_DATA(tdev);\n\n\tif (!test_bit(OFFLOAD_DEVMAP_BIT, &adapter->open_device_map))\n\t\treturn 0;\n\n\t \n\tcxgb3_remove_clients(tdev);\n\n\tsysfs_remove_group(&tdev->lldev->dev.kobj, &offload_attr_group);\n\n\t \n\tflush_work(&td->tid_release_task);\n\n\ttdev->lldev = NULL;\n\tcxgb3_set_dummy_ops(tdev);\n\tt3_tp_set_offload_mode(adapter, 0);\n\tclear_bit(OFFLOAD_DEVMAP_BIT, &adapter->open_device_map);\n\n\tif (!adapter->open_device_map)\n\t\tcxgb_down(adapter, 0);\n\n\tcxgb3_offload_deactivate(adapter);\n\treturn 0;\n}\n\nstatic int cxgb_open(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tint other_ports = adapter->open_device_map & PORT_MASK;\n\tint err;\n\n\tif (!adapter->open_device_map && (err = cxgb_up(adapter)) < 0)\n\t\treturn err;\n\n\tset_bit(pi->port_id, &adapter->open_device_map);\n\tif (is_offload(adapter) && !ofld_disable) {\n\t\terr = offload_open(dev);\n\t\tif (err)\n\t\t\tpr_warn(\"Could not initialize offload capabilities\\n\");\n\t}\n\n\tnetif_set_real_num_tx_queues(dev, pi->nqsets);\n\terr = netif_set_real_num_rx_queues(dev, pi->nqsets);\n\tif (err)\n\t\treturn err;\n\tlink_start(dev);\n\tt3_port_intr_enable(adapter, pi->port_id);\n\tnetif_tx_start_all_queues(dev);\n\tif (!other_ports)\n\t\tschedule_chk_task(adapter);\n\n\tcxgb3_event_notify(&adapter->tdev, OFFLOAD_PORT_UP, pi->port_id);\n\treturn 0;\n}\n\nstatic int __cxgb_close(struct net_device *dev, int on_wq)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\t\n\tif (!adapter->open_device_map)\n\t\treturn 0;\n\n\t \n\tt3_xgm_intr_disable(adapter, pi->port_id);\n\tt3_read_reg(adapter, A_XGM_INT_STATUS + pi->mac.offset);\n\n\tt3_port_intr_disable(adapter, pi->port_id);\n\tnetif_tx_stop_all_queues(dev);\n\tpi->phy.ops->power_down(&pi->phy, 1);\n\tnetif_carrier_off(dev);\n\tt3_mac_disable(&pi->mac, MAC_DIRECTION_TX | MAC_DIRECTION_RX);\n\n\tspin_lock_irq(&adapter->work_lock);\t \n\tclear_bit(pi->port_id, &adapter->open_device_map);\n\tspin_unlock_irq(&adapter->work_lock);\n\n\tif (!(adapter->open_device_map & PORT_MASK))\n\t\tcancel_delayed_work_sync(&adapter->adap_check_task);\n\n\tif (!adapter->open_device_map)\n\t\tcxgb_down(adapter, on_wq);\n\n\tcxgb3_event_notify(&adapter->tdev, OFFLOAD_PORT_DOWN, pi->port_id);\n\treturn 0;\n}\n\nstatic int cxgb_close(struct net_device *dev)\n{\n\treturn __cxgb_close(dev, 0);\n}\n\nstatic struct net_device_stats *cxgb_get_stats(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tstruct net_device_stats *ns = &dev->stats;\n\tconst struct mac_stats *pstats;\n\n\tspin_lock(&adapter->stats_lock);\n\tpstats = t3_mac_update_stats(&pi->mac);\n\tspin_unlock(&adapter->stats_lock);\n\n\tns->tx_bytes = pstats->tx_octets;\n\tns->tx_packets = pstats->tx_frames;\n\tns->rx_bytes = pstats->rx_octets;\n\tns->rx_packets = pstats->rx_frames;\n\tns->multicast = pstats->rx_mcast_frames;\n\n\tns->tx_errors = pstats->tx_underrun;\n\tns->rx_errors = pstats->rx_symbol_errs + pstats->rx_fcs_errs +\n\t    pstats->rx_too_long + pstats->rx_jabber + pstats->rx_short +\n\t    pstats->rx_fifo_ovfl;\n\n\t \n\tns->rx_length_errors = pstats->rx_jabber + pstats->rx_too_long;\n\tns->rx_over_errors = 0;\n\tns->rx_crc_errors = pstats->rx_fcs_errs;\n\tns->rx_frame_errors = pstats->rx_symbol_errs;\n\tns->rx_fifo_errors = pstats->rx_fifo_ovfl;\n\tns->rx_missed_errors = pstats->rx_cong_drops;\n\n\t \n\tns->tx_aborted_errors = 0;\n\tns->tx_carrier_errors = 0;\n\tns->tx_fifo_errors = pstats->tx_underrun;\n\tns->tx_heartbeat_errors = 0;\n\tns->tx_window_errors = 0;\n\treturn ns;\n}\n\nstatic u32 get_msglevel(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\treturn adapter->msg_enable;\n}\n\nstatic void set_msglevel(struct net_device *dev, u32 val)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\tadapter->msg_enable = val;\n}\n\nstatic const char stats_strings[][ETH_GSTRING_LEN] = {\n\t\"TxOctetsOK         \",\n\t\"TxFramesOK         \",\n\t\"TxMulticastFramesOK\",\n\t\"TxBroadcastFramesOK\",\n\t\"TxPauseFrames      \",\n\t\"TxUnderrun         \",\n\t\"TxExtUnderrun      \",\n\n\t\"TxFrames64         \",\n\t\"TxFrames65To127    \",\n\t\"TxFrames128To255   \",\n\t\"TxFrames256To511   \",\n\t\"TxFrames512To1023  \",\n\t\"TxFrames1024To1518 \",\n\t\"TxFrames1519ToMax  \",\n\n\t\"RxOctetsOK         \",\n\t\"RxFramesOK         \",\n\t\"RxMulticastFramesOK\",\n\t\"RxBroadcastFramesOK\",\n\t\"RxPauseFrames      \",\n\t\"RxFCSErrors        \",\n\t\"RxSymbolErrors     \",\n\t\"RxShortErrors      \",\n\t\"RxJabberErrors     \",\n\t\"RxLengthErrors     \",\n\t\"RxFIFOoverflow     \",\n\n\t\"RxFrames64         \",\n\t\"RxFrames65To127    \",\n\t\"RxFrames128To255   \",\n\t\"RxFrames256To511   \",\n\t\"RxFrames512To1023  \",\n\t\"RxFrames1024To1518 \",\n\t\"RxFrames1519ToMax  \",\n\n\t\"PhyFIFOErrors      \",\n\t\"TSO                \",\n\t\"VLANextractions    \",\n\t\"VLANinsertions     \",\n\t\"TxCsumOffload      \",\n\t\"RxCsumGood         \",\n\t\"LroAggregated      \",\n\t\"LroFlushed         \",\n\t\"LroNoDesc          \",\n\t\"RxDrops            \",\n\n\t\"CheckTXEnToggled   \",\n\t\"CheckResets        \",\n\n\t\"LinkFaults         \",\n};\n\nstatic int get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(stats_strings);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n#define T3_REGMAP_SIZE (3 * 1024)\n\nstatic int get_regs_len(struct net_device *dev)\n{\n\treturn T3_REGMAP_SIZE;\n}\n\nstatic int get_eeprom_len(struct net_device *dev)\n{\n\treturn EEPROMSIZE;\n}\n\nstatic void get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tu32 fw_vers = 0;\n\tu32 tp_vers = 0;\n\n\tspin_lock(&adapter->stats_lock);\n\tt3_get_fw_version(adapter, &fw_vers);\n\tt3_get_tp_version(adapter, &tp_vers);\n\tspin_unlock(&adapter->stats_lock);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(info->bus_info));\n\tif (fw_vers)\n\t\tsnprintf(info->fw_version, sizeof(info->fw_version),\n\t\t\t \"%s %u.%u.%u TP %u.%u.%u\",\n\t\t\t G_FW_VERSION_TYPE(fw_vers) ? \"T\" : \"N\",\n\t\t\t G_FW_VERSION_MAJOR(fw_vers),\n\t\t\t G_FW_VERSION_MINOR(fw_vers),\n\t\t\t G_FW_VERSION_MICRO(fw_vers),\n\t\t\t G_TP_VERSION_MAJOR(tp_vers),\n\t\t\t G_TP_VERSION_MINOR(tp_vers),\n\t\t\t G_TP_VERSION_MICRO(tp_vers));\n}\n\nstatic void get_strings(struct net_device *dev, u32 stringset, u8 * data)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\tmemcpy(data, stats_strings, sizeof(stats_strings));\n}\n\nstatic unsigned long collect_sge_port_stats(struct adapter *adapter,\n\t\t\t\t\t    struct port_info *p, int idx)\n{\n\tint i;\n\tunsigned long tot = 0;\n\n\tfor (i = p->first_qset; i < p->first_qset + p->nqsets; ++i)\n\t\ttot += adapter->sge.qs[i].port_stats[idx];\n\treturn tot;\n}\n\nstatic void get_stats(struct net_device *dev, struct ethtool_stats *stats,\n\t\t      u64 *data)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tconst struct mac_stats *s;\n\n\tspin_lock(&adapter->stats_lock);\n\ts = t3_mac_update_stats(&pi->mac);\n\tspin_unlock(&adapter->stats_lock);\n\n\t*data++ = s->tx_octets;\n\t*data++ = s->tx_frames;\n\t*data++ = s->tx_mcast_frames;\n\t*data++ = s->tx_bcast_frames;\n\t*data++ = s->tx_pause;\n\t*data++ = s->tx_underrun;\n\t*data++ = s->tx_fifo_urun;\n\n\t*data++ = s->tx_frames_64;\n\t*data++ = s->tx_frames_65_127;\n\t*data++ = s->tx_frames_128_255;\n\t*data++ = s->tx_frames_256_511;\n\t*data++ = s->tx_frames_512_1023;\n\t*data++ = s->tx_frames_1024_1518;\n\t*data++ = s->tx_frames_1519_max;\n\n\t*data++ = s->rx_octets;\n\t*data++ = s->rx_frames;\n\t*data++ = s->rx_mcast_frames;\n\t*data++ = s->rx_bcast_frames;\n\t*data++ = s->rx_pause;\n\t*data++ = s->rx_fcs_errs;\n\t*data++ = s->rx_symbol_errs;\n\t*data++ = s->rx_short;\n\t*data++ = s->rx_jabber;\n\t*data++ = s->rx_too_long;\n\t*data++ = s->rx_fifo_ovfl;\n\n\t*data++ = s->rx_frames_64;\n\t*data++ = s->rx_frames_65_127;\n\t*data++ = s->rx_frames_128_255;\n\t*data++ = s->rx_frames_256_511;\n\t*data++ = s->rx_frames_512_1023;\n\t*data++ = s->rx_frames_1024_1518;\n\t*data++ = s->rx_frames_1519_max;\n\n\t*data++ = pi->phy.fifo_errors;\n\n\t*data++ = collect_sge_port_stats(adapter, pi, SGE_PSTAT_TSO);\n\t*data++ = collect_sge_port_stats(adapter, pi, SGE_PSTAT_VLANEX);\n\t*data++ = collect_sge_port_stats(adapter, pi, SGE_PSTAT_VLANINS);\n\t*data++ = collect_sge_port_stats(adapter, pi, SGE_PSTAT_TX_CSUM);\n\t*data++ = collect_sge_port_stats(adapter, pi, SGE_PSTAT_RX_CSUM_GOOD);\n\t*data++ = 0;\n\t*data++ = 0;\n\t*data++ = 0;\n\t*data++ = s->rx_cong_drops;\n\n\t*data++ = s->num_toggled;\n\t*data++ = s->num_resets;\n\n\t*data++ = s->link_faults;\n}\n\nstatic inline void reg_block_dump(struct adapter *ap, void *buf,\n\t\t\t\t  unsigned int start, unsigned int end)\n{\n\tu32 *p = buf + start;\n\n\tfor (; start <= end; start += sizeof(u32))\n\t\t*p++ = t3_read_reg(ap, start);\n}\n\nstatic void get_regs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t     void *buf)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *ap = pi->adapter;\n\n\t \n\tregs->version = 3 | (ap->params.rev << 10) | (is_pcie(ap) << 31);\n\n\t \n\tmemset(buf, 0, T3_REGMAP_SIZE);\n\treg_block_dump(ap, buf, 0, A_SG_RSPQ_CREDIT_RETURN);\n\treg_block_dump(ap, buf, A_SG_HI_DRB_HI_THRSH, A_ULPRX_PBL_ULIMIT);\n\treg_block_dump(ap, buf, A_ULPTX_CONFIG, A_MPS_INT_CAUSE);\n\treg_block_dump(ap, buf, A_CPL_SWITCH_CNTRL, A_CPL_MAP_TBL_DATA);\n\treg_block_dump(ap, buf, A_SMB_GLOBAL_TIME_CFG, A_XGM_SERDES_STAT3);\n\treg_block_dump(ap, buf, A_XGM_SERDES_STATUS0,\n\t\t       XGM_REG(A_XGM_SERDES_STAT3, 1));\n\treg_block_dump(ap, buf, XGM_REG(A_XGM_SERDES_STATUS0, 1),\n\t\t       XGM_REG(A_XGM_RX_SPI4_SOP_EOP_CNT, 1));\n}\n\nstatic int restart_autoneg(struct net_device *dev)\n{\n\tstruct port_info *p = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn -EAGAIN;\n\tif (p->link_config.autoneg != AUTONEG_ENABLE)\n\t\treturn -EINVAL;\n\tp->phy.ops->autoneg_restart(&p->phy);\n\treturn 0;\n}\n\nstatic int set_phys_id(struct net_device *dev,\n\t\t       enum ethtool_phys_id_state state)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\treturn 1;\t \n\n\tcase ETHTOOL_ID_OFF:\n\t\tt3_set_reg_field(adapter, A_T3DBG_GPIO_EN, F_GPIO0_OUT_VAL, 0);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_ON:\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tt3_set_reg_field(adapter, A_T3DBG_GPIO_EN, F_GPIO0_OUT_VAL,\n\t\t\t F_GPIO0_OUT_VAL);\n\t}\n\n\treturn 0;\n}\n\nstatic int get_link_ksettings(struct net_device *dev,\n\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tstruct port_info *p = netdev_priv(dev);\n\tu32 supported;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tp->link_config.supported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tp->link_config.advertising);\n\n\tif (netif_carrier_ok(dev)) {\n\t\tcmd->base.speed = p->link_config.speed;\n\t\tcmd->base.duplex = p->link_config.duplex;\n\t} else {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tethtool_convert_link_mode_to_legacy_u32(&supported,\n\t\t\t\t\t\tcmd->link_modes.supported);\n\n\tcmd->base.port = (supported & SUPPORTED_TP) ? PORT_TP : PORT_FIBRE;\n\tcmd->base.phy_address = p->phy.mdio.prtad;\n\tcmd->base.autoneg = p->link_config.autoneg;\n\treturn 0;\n}\n\nstatic int speed_duplex_to_caps(int speed, int duplex)\n{\n\tint cap = 0;\n\n\tswitch (speed) {\n\tcase SPEED_10:\n\t\tif (duplex == DUPLEX_FULL)\n\t\t\tcap = SUPPORTED_10baseT_Full;\n\t\telse\n\t\t\tcap = SUPPORTED_10baseT_Half;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tif (duplex == DUPLEX_FULL)\n\t\t\tcap = SUPPORTED_100baseT_Full;\n\t\telse\n\t\t\tcap = SUPPORTED_100baseT_Half;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tif (duplex == DUPLEX_FULL)\n\t\t\tcap = SUPPORTED_1000baseT_Full;\n\t\telse\n\t\t\tcap = SUPPORTED_1000baseT_Half;\n\t\tbreak;\n\tcase SPEED_10000:\n\t\tif (duplex == DUPLEX_FULL)\n\t\t\tcap = SUPPORTED_10000baseT_Full;\n\t}\n\treturn cap;\n}\n\n#define ADVERTISED_MASK (ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full | \\\n\t\t      ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full | \\\n\t\t      ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full | \\\n\t\t      ADVERTISED_10000baseT_Full)\n\nstatic int set_link_ksettings(struct net_device *dev,\n\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct port_info *p = netdev_priv(dev);\n\tstruct link_config *lc = &p->link_config;\n\tu32 advertising;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\tif (!(lc->supported & SUPPORTED_Autoneg)) {\n\t\t \n\t\tif (cmd->base.autoneg == AUTONEG_DISABLE) {\n\t\t\tu32 speed = cmd->base.speed;\n\t\t\tint cap = speed_duplex_to_caps(speed, cmd->base.duplex);\n\t\t\tif (lc->supported & cap)\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->base.autoneg == AUTONEG_DISABLE) {\n\t\tu32 speed = cmd->base.speed;\n\t\tint cap = speed_duplex_to_caps(speed, cmd->base.duplex);\n\n\t\tif (!(lc->supported & cap) || (speed == SPEED_1000))\n\t\t\treturn -EINVAL;\n\t\tlc->requested_speed = speed;\n\t\tlc->requested_duplex = cmd->base.duplex;\n\t\tlc->advertising = 0;\n\t} else {\n\t\tadvertising &= ADVERTISED_MASK;\n\t\tadvertising &= lc->supported;\n\t\tif (!advertising)\n\t\t\treturn -EINVAL;\n\t\tlc->requested_speed = SPEED_INVALID;\n\t\tlc->requested_duplex = DUPLEX_INVALID;\n\t\tlc->advertising = advertising | ADVERTISED_Autoneg;\n\t}\n\tlc->autoneg = cmd->base.autoneg;\n\tif (netif_running(dev))\n\t\tt3_link_start(&p->phy, &p->mac, lc);\n\treturn 0;\n}\n\nstatic void get_pauseparam(struct net_device *dev,\n\t\t\t   struct ethtool_pauseparam *epause)\n{\n\tstruct port_info *p = netdev_priv(dev);\n\n\tepause->autoneg = (p->link_config.requested_fc & PAUSE_AUTONEG) != 0;\n\tepause->rx_pause = (p->link_config.fc & PAUSE_RX) != 0;\n\tepause->tx_pause = (p->link_config.fc & PAUSE_TX) != 0;\n}\n\nstatic int set_pauseparam(struct net_device *dev,\n\t\t\t  struct ethtool_pauseparam *epause)\n{\n\tstruct port_info *p = netdev_priv(dev);\n\tstruct link_config *lc = &p->link_config;\n\n\tif (epause->autoneg == AUTONEG_DISABLE)\n\t\tlc->requested_fc = 0;\n\telse if (lc->supported & SUPPORTED_Autoneg)\n\t\tlc->requested_fc = PAUSE_AUTONEG;\n\telse\n\t\treturn -EINVAL;\n\n\tif (epause->rx_pause)\n\t\tlc->requested_fc |= PAUSE_RX;\n\tif (epause->tx_pause)\n\t\tlc->requested_fc |= PAUSE_TX;\n\tif (lc->autoneg == AUTONEG_ENABLE) {\n\t\tif (netif_running(dev))\n\t\t\tt3_link_start(&p->phy, &p->mac, lc);\n\t} else {\n\t\tlc->fc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);\n\t\tif (netif_running(dev))\n\t\t\tt3_mac_set_speed_duplex_fc(&p->mac, -1, -1, lc->fc);\n\t}\n\treturn 0;\n}\n\nstatic void get_sge_param(struct net_device *dev, struct ethtool_ringparam *e,\n\t\t\t  struct kernel_ethtool_ringparam *kernel_e,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tconst struct qset_params *q = &adapter->params.sge.qset[pi->first_qset];\n\n\te->rx_max_pending = MAX_RX_BUFFERS;\n\te->rx_jumbo_max_pending = MAX_RX_JUMBO_BUFFERS;\n\te->tx_max_pending = MAX_TXQ_ENTRIES;\n\n\te->rx_pending = q->fl_size;\n\te->rx_mini_pending = q->rspq_size;\n\te->rx_jumbo_pending = q->jumbo_size;\n\te->tx_pending = q->txq_size[0];\n}\n\nstatic int set_sge_param(struct net_device *dev, struct ethtool_ringparam *e,\n\t\t\t struct kernel_ethtool_ringparam *kernel_e,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tstruct qset_params *q;\n\tint i;\n\n\tif (e->rx_pending > MAX_RX_BUFFERS ||\n\t    e->rx_jumbo_pending > MAX_RX_JUMBO_BUFFERS ||\n\t    e->tx_pending > MAX_TXQ_ENTRIES ||\n\t    e->rx_mini_pending > MAX_RSPQ_ENTRIES ||\n\t    e->rx_mini_pending < MIN_RSPQ_ENTRIES ||\n\t    e->rx_pending < MIN_FL_ENTRIES ||\n\t    e->rx_jumbo_pending < MIN_FL_ENTRIES ||\n\t    e->tx_pending < adapter->params.nports * MIN_TXQ_ENTRIES)\n\t\treturn -EINVAL;\n\n\tif (adapter->flags & FULL_INIT_DONE)\n\t\treturn -EBUSY;\n\n\tq = &adapter->params.sge.qset[pi->first_qset];\n\tfor (i = 0; i < pi->nqsets; ++i, ++q) {\n\t\tq->rspq_size = e->rx_mini_pending;\n\t\tq->fl_size = e->rx_pending;\n\t\tq->jumbo_size = e->rx_jumbo_pending;\n\t\tq->txq_size[0] = e->tx_pending;\n\t\tq->txq_size[1] = e->tx_pending;\n\t\tq->txq_size[2] = e->tx_pending;\n\t}\n\treturn 0;\n}\n\nstatic int set_coalesce(struct net_device *dev, struct ethtool_coalesce *c,\n\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tstruct qset_params *qsp;\n\tstruct sge_qset *qs;\n\tint i;\n\n\tif (c->rx_coalesce_usecs * 10 > M_NEWTIMER)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < pi->nqsets; i++) {\n\t\tqsp = &adapter->params.sge.qset[i];\n\t\tqs = &adapter->sge.qs[i];\n\t\tqsp->coalesce_usecs = c->rx_coalesce_usecs;\n\t\tt3_update_qset_coalesce(qs, qsp);\n\t}\n\n\treturn 0;\n}\n\nstatic int get_coalesce(struct net_device *dev, struct ethtool_coalesce *c,\n\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tstruct qset_params *q = adapter->params.sge.qset;\n\n\tc->rx_coalesce_usecs = q->coalesce_usecs;\n\treturn 0;\n}\n\nstatic int get_eeprom(struct net_device *dev, struct ethtool_eeprom *e,\n\t\t      u8 * data)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tint cnt;\n\n\te->magic = EEPROM_MAGIC;\n\tcnt = pci_read_vpd(adapter->pdev, e->offset, e->len, data);\n\tif (cnt < 0)\n\t\treturn cnt;\n\n\te->len = cnt;\n\n\treturn 0;\n}\n\nstatic int set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\n\t\t      u8 * data)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tu32 aligned_offset, aligned_len;\n\tu8 *buf;\n\tint err;\n\n\tif (eeprom->magic != EEPROM_MAGIC)\n\t\treturn -EINVAL;\n\n\taligned_offset = eeprom->offset & ~3;\n\taligned_len = (eeprom->len + (eeprom->offset & 3) + 3) & ~3;\n\n\tif (aligned_offset != eeprom->offset || aligned_len != eeprom->len) {\n\t\tbuf = kmalloc(aligned_len, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\terr = pci_read_vpd(adapter->pdev, aligned_offset, aligned_len,\n\t\t\t\t   buf);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tmemcpy(buf + (eeprom->offset & 3), data, eeprom->len);\n\t} else\n\t\tbuf = data;\n\n\terr = t3_seeprom_wp(adapter, 0);\n\tif (err)\n\t\tgoto out;\n\n\terr = pci_write_vpd(adapter->pdev, aligned_offset, aligned_len, buf);\n\tif (err >= 0)\n\t\terr = t3_seeprom_wp(adapter, 1);\nout:\n\tif (buf != data)\n\t\tkfree(buf);\n\treturn err < 0 ? err : 0;\n}\n\nstatic void get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\twol->supported = 0;\n\twol->wolopts = 0;\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n}\n\nstatic const struct ethtool_ops cxgb_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS,\n\t.get_drvinfo = get_drvinfo,\n\t.get_msglevel = get_msglevel,\n\t.set_msglevel = set_msglevel,\n\t.get_ringparam = get_sge_param,\n\t.set_ringparam = set_sge_param,\n\t.get_coalesce = get_coalesce,\n\t.set_coalesce = set_coalesce,\n\t.get_eeprom_len = get_eeprom_len,\n\t.get_eeprom = get_eeprom,\n\t.set_eeprom = set_eeprom,\n\t.get_pauseparam = get_pauseparam,\n\t.set_pauseparam = set_pauseparam,\n\t.get_link = ethtool_op_get_link,\n\t.get_strings = get_strings,\n\t.set_phys_id = set_phys_id,\n\t.nway_reset = restart_autoneg,\n\t.get_sset_count = get_sset_count,\n\t.get_ethtool_stats = get_stats,\n\t.get_regs_len = get_regs_len,\n\t.get_regs = get_regs,\n\t.get_wol = get_wol,\n\t.get_link_ksettings = get_link_ksettings,\n\t.set_link_ksettings = set_link_ksettings,\n};\n\nstatic int cxgb_in_range(int val, int lo, int hi)\n{\n\treturn val < 0 || (val <= hi && val >= lo);\n}\n\nstatic int cxgb_siocdevprivate(struct net_device *dev,\n\t\t\t       struct ifreq *ifreq,\n\t\t\t       void __user *useraddr,\n\t\t\t       int cmd)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tint ret;\n\n\tif (cmd != SIOCCHIOCTL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&cmd, useraddr, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase CHELSIO_SET_QSET_PARAMS:{\n\t\tint i;\n\t\tstruct qset_params *q;\n\t\tstruct ch_qset_params t;\n\t\tint q1 = pi->first_qset;\n\t\tint nqsets = pi->nqsets;\n\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&t, useraddr, sizeof(t)))\n\t\t\treturn -EFAULT;\n\t\tif (t.cmd != CHELSIO_SET_QSET_PARAMS)\n\t\t\treturn -EINVAL;\n\t\tif (t.qset_idx >= SGE_QSETS)\n\t\t\treturn -EINVAL;\n\t\tif (!cxgb_in_range(t.intr_lat, 0, M_NEWTIMER) ||\n\t\t    !cxgb_in_range(t.cong_thres, 0, 255) ||\n\t\t    !cxgb_in_range(t.txq_size[0], MIN_TXQ_ENTRIES,\n\t\t\t      MAX_TXQ_ENTRIES) ||\n\t\t    !cxgb_in_range(t.txq_size[1], MIN_TXQ_ENTRIES,\n\t\t\t      MAX_TXQ_ENTRIES) ||\n\t\t    !cxgb_in_range(t.txq_size[2], MIN_CTRL_TXQ_ENTRIES,\n\t\t\t      MAX_CTRL_TXQ_ENTRIES) ||\n\t\t    !cxgb_in_range(t.fl_size[0], MIN_FL_ENTRIES,\n\t\t\t      MAX_RX_BUFFERS) ||\n\t\t    !cxgb_in_range(t.fl_size[1], MIN_FL_ENTRIES,\n\t\t\t      MAX_RX_JUMBO_BUFFERS) ||\n\t\t    !cxgb_in_range(t.rspq_size, MIN_RSPQ_ENTRIES,\n\t\t\t      MAX_RSPQ_ENTRIES))\n\t\t\treturn -EINVAL;\n\n\t\tif ((adapter->flags & FULL_INIT_DONE) &&\n\t\t\t(t.rspq_size >= 0 || t.fl_size[0] >= 0 ||\n\t\t\tt.fl_size[1] >= 0 || t.txq_size[0] >= 0 ||\n\t\t\tt.txq_size[1] >= 0 || t.txq_size[2] >= 0 ||\n\t\t\tt.polling >= 0 || t.cong_thres >= 0))\n\t\t\treturn -EBUSY;\n\n\t\t \n\t\tif (test_bit(OFFLOAD_DEVMAP_BIT, &adapter->open_device_map)) {\n\t\t\tq1 = 0;\n\t\t\tfor_each_port(adapter, i) {\n\t\t\t\tpi = adap2pinfo(adapter, i);\n\t\t\t\tnqsets += pi->first_qset + pi->nqsets;\n\t\t\t}\n\t\t}\n\n\t\tif (t.qset_idx < q1)\n\t\t\treturn -EINVAL;\n\t\tif (t.qset_idx > q1 + nqsets - 1)\n\t\t\treturn -EINVAL;\n\n\t\tq = &adapter->params.sge.qset[t.qset_idx];\n\n\t\tif (t.rspq_size >= 0)\n\t\t\tq->rspq_size = t.rspq_size;\n\t\tif (t.fl_size[0] >= 0)\n\t\t\tq->fl_size = t.fl_size[0];\n\t\tif (t.fl_size[1] >= 0)\n\t\t\tq->jumbo_size = t.fl_size[1];\n\t\tif (t.txq_size[0] >= 0)\n\t\t\tq->txq_size[0] = t.txq_size[0];\n\t\tif (t.txq_size[1] >= 0)\n\t\t\tq->txq_size[1] = t.txq_size[1];\n\t\tif (t.txq_size[2] >= 0)\n\t\t\tq->txq_size[2] = t.txq_size[2];\n\t\tif (t.cong_thres >= 0)\n\t\t\tq->cong_thres = t.cong_thres;\n\t\tif (t.intr_lat >= 0) {\n\t\t\tstruct sge_qset *qs =\n\t\t\t\t&adapter->sge.qs[t.qset_idx];\n\n\t\t\tq->coalesce_usecs = t.intr_lat;\n\t\t\tt3_update_qset_coalesce(qs, q);\n\t\t}\n\t\tif (t.polling >= 0) {\n\t\t\tif (adapter->flags & USING_MSIX)\n\t\t\t\tq->polling = t.polling;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tif (adapter->params.rev == 0 &&\n\t\t\t\t\t!(adapter->flags & USING_MSI))\n\t\t\t\t\tt.polling = 0;\n\n\t\t\t\tfor (i = 0; i < SGE_QSETS; i++) {\n\t\t\t\t\tq = &adapter->params.sge.\n\t\t\t\t\t\tqset[i];\n\t\t\t\t\tq->polling = t.polling;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t.lro >= 0) {\n\t\t\tif (t.lro)\n\t\t\t\tdev->wanted_features |= NETIF_F_GRO;\n\t\t\telse\n\t\t\t\tdev->wanted_features &= ~NETIF_F_GRO;\n\t\t\tnetdev_update_features(dev);\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase CHELSIO_GET_QSET_PARAMS:{\n\t\tstruct qset_params *q;\n\t\tstruct ch_qset_params t;\n\t\tint q1 = pi->first_qset;\n\t\tint nqsets = pi->nqsets;\n\t\tint i;\n\n\t\tif (copy_from_user(&t, useraddr, sizeof(t)))\n\t\t\treturn -EFAULT;\n\n\t\tif (t.cmd != CHELSIO_GET_QSET_PARAMS)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (test_bit(OFFLOAD_DEVMAP_BIT, &adapter->open_device_map)) {\n\t\t\tq1 = 0;\n\t\t\tfor_each_port(adapter, i) {\n\t\t\t\tpi = adap2pinfo(adapter, i);\n\t\t\t\tnqsets = pi->first_qset + pi->nqsets;\n\t\t\t}\n\t\t}\n\n\t\tif (t.qset_idx >= nqsets)\n\t\t\treturn -EINVAL;\n\t\tt.qset_idx = array_index_nospec(t.qset_idx, nqsets);\n\n\t\tq = &adapter->params.sge.qset[q1 + t.qset_idx];\n\t\tt.rspq_size = q->rspq_size;\n\t\tt.txq_size[0] = q->txq_size[0];\n\t\tt.txq_size[1] = q->txq_size[1];\n\t\tt.txq_size[2] = q->txq_size[2];\n\t\tt.fl_size[0] = q->fl_size;\n\t\tt.fl_size[1] = q->jumbo_size;\n\t\tt.polling = q->polling;\n\t\tt.lro = !!(dev->features & NETIF_F_GRO);\n\t\tt.intr_lat = q->coalesce_usecs;\n\t\tt.cong_thres = q->cong_thres;\n\t\tt.qnum = q1;\n\n\t\tif (adapter->flags & USING_MSIX)\n\t\t\tt.vector = adapter->msix_info[q1 + t.qset_idx + 1].vec;\n\t\telse\n\t\t\tt.vector = adapter->pdev->irq;\n\n\t\tif (copy_to_user(useraddr, &t, sizeof(t)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase CHELSIO_SET_QSET_NUM:{\n\t\tstruct ch_reg edata;\n\t\tunsigned int i, first_qset = 0, other_qsets = 0;\n\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (adapter->flags & FULL_INIT_DONE)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&edata, useraddr, sizeof(edata)))\n\t\t\treturn -EFAULT;\n\t\tif (edata.cmd != CHELSIO_SET_QSET_NUM)\n\t\t\treturn -EINVAL;\n\t\tif (edata.val < 1 ||\n\t\t\t(edata.val > 1 && !(adapter->flags & USING_MSIX)))\n\t\t\treturn -EINVAL;\n\n\t\tfor_each_port(adapter, i)\n\t\t\tif (adapter->port[i] && adapter->port[i] != dev)\n\t\t\t\tother_qsets += adap2pinfo(adapter, i)->nqsets;\n\n\t\tif (edata.val + other_qsets > SGE_QSETS)\n\t\t\treturn -EINVAL;\n\n\t\tpi->nqsets = edata.val;\n\n\t\tfor_each_port(adapter, i)\n\t\t\tif (adapter->port[i]) {\n\t\t\t\tpi = adap2pinfo(adapter, i);\n\t\t\t\tpi->first_qset = first_qset;\n\t\t\t\tfirst_qset += pi->nqsets;\n\t\t\t}\n\t\tbreak;\n\t}\n\tcase CHELSIO_GET_QSET_NUM:{\n\t\tstruct ch_reg edata;\n\n\t\tmemset(&edata, 0, sizeof(struct ch_reg));\n\n\t\tedata.cmd = CHELSIO_GET_QSET_NUM;\n\t\tedata.val = pi->nqsets;\n\t\tif (copy_to_user(useraddr, &edata, sizeof(edata)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase CHELSIO_LOAD_FW:{\n\t\tu8 *fw_data;\n\t\tstruct ch_mem_range t;\n\n\t\tif (!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&t, useraddr, sizeof(t)))\n\t\t\treturn -EFAULT;\n\t\tif (t.cmd != CHELSIO_LOAD_FW)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tfw_data = memdup_user(useraddr + sizeof(t), t.len);\n\t\tif (IS_ERR(fw_data))\n\t\t\treturn PTR_ERR(fw_data);\n\n\t\tret = t3_load_fw(adapter, fw_data, t.len);\n\t\tkfree(fw_data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase CHELSIO_SETMTUTAB:{\n\t\tstruct ch_mtus m;\n\t\tint i;\n\n\t\tif (!is_offload(adapter))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (offload_running(adapter))\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&m, useraddr, sizeof(m)))\n\t\t\treturn -EFAULT;\n\t\tif (m.cmd != CHELSIO_SETMTUTAB)\n\t\t\treturn -EINVAL;\n\t\tif (m.nmtus != NMTUS)\n\t\t\treturn -EINVAL;\n\t\tif (m.mtus[0] < 81)\t \n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tfor (i = 1; i < NMTUS; ++i)\n\t\t\tif (m.mtus[i] < m.mtus[i - 1])\n\t\t\t\treturn -EINVAL;\n\n\t\tmemcpy(adapter->params.mtus, m.mtus,\n\t\t\tsizeof(adapter->params.mtus));\n\t\tbreak;\n\t}\n\tcase CHELSIO_GET_PM:{\n\t\tstruct tp_params *p = &adapter->params.tp;\n\t\tstruct ch_pm m = {.cmd = CHELSIO_GET_PM };\n\n\t\tif (!is_offload(adapter))\n\t\t\treturn -EOPNOTSUPP;\n\t\tm.tx_pg_sz = p->tx_pg_size;\n\t\tm.tx_num_pg = p->tx_num_pgs;\n\t\tm.rx_pg_sz = p->rx_pg_size;\n\t\tm.rx_num_pg = p->rx_num_pgs;\n\t\tm.pm_total = p->pmtx_size + p->chan_rx_size * p->nchan;\n\t\tif (copy_to_user(useraddr, &m, sizeof(m)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\tcase CHELSIO_SET_PM:{\n\t\tstruct ch_pm m;\n\t\tstruct tp_params *p = &adapter->params.tp;\n\n\t\tif (!is_offload(adapter))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (adapter->flags & FULL_INIT_DONE)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&m, useraddr, sizeof(m)))\n\t\t\treturn -EFAULT;\n\t\tif (m.cmd != CHELSIO_SET_PM)\n\t\t\treturn -EINVAL;\n\t\tif (!is_power_of_2(m.rx_pg_sz) ||\n\t\t\t!is_power_of_2(m.tx_pg_sz))\n\t\t\treturn -EINVAL;\t \n\t\tif (!(m.rx_pg_sz & 0x14000))\n\t\t\treturn -EINVAL;\t \n\t\tif (!(m.tx_pg_sz & 0x1554000))\n\t\t\treturn -EINVAL;\n\t\tif (m.tx_num_pg == -1)\n\t\t\tm.tx_num_pg = p->tx_num_pgs;\n\t\tif (m.rx_num_pg == -1)\n\t\t\tm.rx_num_pg = p->rx_num_pgs;\n\t\tif (m.tx_num_pg % 24 || m.rx_num_pg % 24)\n\t\t\treturn -EINVAL;\n\t\tif (m.rx_num_pg * m.rx_pg_sz > p->chan_rx_size ||\n\t\t\tm.tx_num_pg * m.tx_pg_sz > p->chan_tx_size)\n\t\t\treturn -EINVAL;\n\t\tp->rx_pg_size = m.rx_pg_sz;\n\t\tp->tx_pg_size = m.tx_pg_sz;\n\t\tp->rx_num_pgs = m.rx_num_pg;\n\t\tp->tx_num_pgs = m.tx_num_pg;\n\t\tbreak;\n\t}\n\tcase CHELSIO_GET_MEM:{\n\t\tstruct ch_mem_range t;\n\t\tstruct mc7 *mem;\n\t\tu64 buf[32];\n\n\t\tif (!is_offload(adapter))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (!(adapter->flags & FULL_INIT_DONE))\n\t\t\treturn -EIO;\t \n\t\tif (copy_from_user(&t, useraddr, sizeof(t)))\n\t\t\treturn -EFAULT;\n\t\tif (t.cmd != CHELSIO_GET_MEM)\n\t\t\treturn -EINVAL;\n\t\tif ((t.addr & 7) || (t.len & 7))\n\t\t\treturn -EINVAL;\n\t\tif (t.mem_id == MEM_CM)\n\t\t\tmem = &adapter->cm;\n\t\telse if (t.mem_id == MEM_PMRX)\n\t\t\tmem = &adapter->pmrx;\n\t\telse if (t.mem_id == MEM_PMTX)\n\t\t\tmem = &adapter->pmtx;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tt.version = 3 | (adapter->params.rev << 10);\n\t\tif (copy_to_user(useraddr, &t, sizeof(t)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tuseraddr += sizeof(t);\t \n\t\twhile (t.len) {\n\t\t\tunsigned int chunk =\n\t\t\t\tmin_t(unsigned int, t.len, sizeof(buf));\n\n\t\t\tret =\n\t\t\t\tt3_mc7_bd_read(mem, t.addr / 8, chunk / 8,\n\t\t\t\t\t\tbuf);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (copy_to_user(useraddr, buf, chunk))\n\t\t\t\treturn -EFAULT;\n\t\t\tuseraddr += chunk;\n\t\t\tt.addr += chunk;\n\t\t\tt.len -= chunk;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CHELSIO_SET_TRACE_FILTER:{\n\t\tstruct ch_trace t;\n\t\tconst struct trace_params *tp;\n\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (!offload_running(adapter))\n\t\t\treturn -EAGAIN;\n\t\tif (copy_from_user(&t, useraddr, sizeof(t)))\n\t\t\treturn -EFAULT;\n\t\tif (t.cmd != CHELSIO_SET_TRACE_FILTER)\n\t\t\treturn -EINVAL;\n\n\t\ttp = (const struct trace_params *)&t.sip;\n\t\tif (t.config_tx)\n\t\t\tt3_config_trace_filter(adapter, tp, 0,\n\t\t\t\t\t\tt.invert_match,\n\t\t\t\t\t\tt.trace_tx);\n\t\tif (t.config_rx)\n\t\t\tt3_config_trace_filter(adapter, tp, 1,\n\t\t\t\t\t\tt.invert_match,\n\t\t\t\t\t\tt.trace_rx);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int cxgb_ioctl(struct net_device *dev, struct ifreq *req, int cmd)\n{\n\tstruct mii_ioctl_data *data = if_mii(req);\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\t \n\t\tif (is_10G(adapter) &&\n\t\t    !mdio_phy_id_is_c45(data->phy_id) &&\n\t\t    (data->phy_id & 0x1f00) &&\n\t\t    !(data->phy_id & 0xe0e0))\n\t\t\tdata->phy_id = mdio_phy_id_c45(data->phy_id >> 8,\n\t\t\t\t\t\t       data->phy_id & 0x1f);\n\t\tfallthrough;\n\tcase SIOCGMIIPHY:\n\t\treturn mdio_mii_ioctl(&pi->phy.mdio, data, cmd);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int cxgb_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tint ret;\n\n\tif ((ret = t3_mac_set_mtu(&pi->mac, new_mtu)))\n\t\treturn ret;\n\tdev->mtu = new_mtu;\n\tinit_port_mtus(adapter);\n\tif (adapter->params.rev == 0 && offload_running(adapter))\n\t\tt3_load_mtus(adapter, adapter->params.mtus,\n\t\t\t     adapter->params.a_wnd, adapter->params.b_wnd,\n\t\t\t     adapter->port[0]->mtu);\n\treturn 0;\n}\n\nstatic int cxgb_set_mac_addr(struct net_device *dev, void *p)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\tt3_mac_set_address(&pi->mac, LAN_MAC_IDX, dev->dev_addr);\n\tif (offload_running(adapter))\n\t\twrite_smt_entry(adapter, pi->port_id);\n\treturn 0;\n}\n\nstatic netdev_features_t cxgb_fix_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\t \n\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\n\telse\n\t\tfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\n\n\treturn features;\n}\n\nstatic int cxgb_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tnetdev_features_t changed = dev->features ^ features;\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tcxgb_vlan_mode(dev, features);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void cxgb_netpoll(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tint qidx;\n\n\tfor (qidx = pi->first_qset; qidx < pi->first_qset + pi->nqsets; qidx++) {\n\t\tstruct sge_qset *qs = &adapter->sge.qs[qidx];\n\t\tvoid *source;\n\n\t\tif (adapter->flags & USING_MSIX)\n\t\t\tsource = qs;\n\t\telse\n\t\t\tsource = adapter;\n\n\t\tt3_intr_handler(adapter, qs->rspq.polling) (0, source);\n\t}\n}\n#endif\n\n \nstatic void mac_stats_update(struct adapter *adapter)\n{\n\tint i;\n\n\tfor_each_port(adapter, i) {\n\t\tstruct net_device *dev = adapter->port[i];\n\t\tstruct port_info *p = netdev_priv(dev);\n\n\t\tif (netif_running(dev)) {\n\t\t\tspin_lock(&adapter->stats_lock);\n\t\t\tt3_mac_update_stats(&p->mac);\n\t\t\tspin_unlock(&adapter->stats_lock);\n\t\t}\n\t}\n}\n\nstatic void check_link_status(struct adapter *adapter)\n{\n\tint i;\n\n\tfor_each_port(adapter, i) {\n\t\tstruct net_device *dev = adapter->port[i];\n\t\tstruct port_info *p = netdev_priv(dev);\n\t\tint link_fault;\n\n\t\tspin_lock_irq(&adapter->work_lock);\n\t\tlink_fault = p->link_fault;\n\t\tspin_unlock_irq(&adapter->work_lock);\n\n\t\tif (link_fault) {\n\t\t\tt3_link_fault(adapter, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(p->phy.caps & SUPPORTED_IRQ) && netif_running(dev)) {\n\t\t\tt3_xgm_intr_disable(adapter, i);\n\t\t\tt3_read_reg(adapter, A_XGM_INT_STATUS + p->mac.offset);\n\n\t\t\tt3_link_changed(adapter, i);\n\t\t\tt3_xgm_intr_enable(adapter, i);\n\t\t}\n\t}\n}\n\nstatic void check_t3b2_mac(struct adapter *adapter)\n{\n\tint i;\n\n\tif (!rtnl_trylock())\t \n\t\treturn;\n\n\tfor_each_port(adapter, i) {\n\t\tstruct net_device *dev = adapter->port[i];\n\t\tstruct port_info *p = netdev_priv(dev);\n\t\tint status;\n\n\t\tif (!netif_running(dev))\n\t\t\tcontinue;\n\n\t\tstatus = 0;\n\t\tif (netif_running(dev) && netif_carrier_ok(dev))\n\t\t\tstatus = t3b2_mac_watchdog_task(&p->mac);\n\t\tif (status == 1)\n\t\t\tp->mac.stats.num_toggled++;\n\t\telse if (status == 2) {\n\t\t\tstruct cmac *mac = &p->mac;\n\n\t\t\tt3_mac_set_mtu(mac, dev->mtu);\n\t\t\tt3_mac_set_address(mac, LAN_MAC_IDX, dev->dev_addr);\n\t\t\tcxgb_set_rxmode(dev);\n\t\t\tt3_link_start(&p->phy, mac, &p->link_config);\n\t\t\tt3_mac_enable(mac, MAC_DIRECTION_RX | MAC_DIRECTION_TX);\n\t\t\tt3_port_intr_enable(adapter, p->port_id);\n\t\t\tp->mac.stats.num_resets++;\n\t\t}\n\t}\n\trtnl_unlock();\n}\n\n\nstatic void t3_adap_check_task(struct work_struct *work)\n{\n\tstruct adapter *adapter = container_of(work, struct adapter,\n\t\t\t\t\t       adap_check_task.work);\n\tconst struct adapter_params *p = &adapter->params;\n\tint port;\n\tunsigned int v, status, reset;\n\n\tadapter->check_task_cnt++;\n\n\tcheck_link_status(adapter);\n\n\t \n\tif (!p->linkpoll_period ||\n\t    (adapter->check_task_cnt * p->linkpoll_period) / 10 >=\n\t    p->stats_update_period) {\n\t\tmac_stats_update(adapter);\n\t\tadapter->check_task_cnt = 0;\n\t}\n\n\tif (p->rev == T3_REV_B2)\n\t\tcheck_t3b2_mac(adapter);\n\n\t \n\tfor_each_port(adapter, port) {\n\t\tstruct cmac *mac =  &adap2pinfo(adapter, port)->mac;\n\t\tu32 cause;\n\n\t\tcause = t3_read_reg(adapter, A_XGM_INT_CAUSE + mac->offset);\n\t\treset = 0;\n\t\tif (cause & F_RXFIFO_OVERFLOW) {\n\t\t\tmac->stats.rx_fifo_ovfl++;\n\t\t\treset |= F_RXFIFO_OVERFLOW;\n\t\t}\n\n\t\tt3_write_reg(adapter, A_XGM_INT_CAUSE + mac->offset, reset);\n\t}\n\n\t \n\tstatus = t3_read_reg(adapter, A_SG_INT_CAUSE);\n\treset = 0;\n\n\tif (status & F_FLEMPTY) {\n\t\tstruct sge_qset *qs = &adapter->sge.qs[0];\n\t\tint i = 0;\n\n\t\treset |= F_FLEMPTY;\n\n\t\tv = (t3_read_reg(adapter, A_SG_RSPQ_FL_STATUS) >> S_FL0EMPTY) &\n\t\t    0xffff;\n\n\t\twhile (v) {\n\t\t\tqs->fl[i].empty += (v & 1);\n\t\t\tif (i)\n\t\t\t\tqs++;\n\t\t\ti ^= 1;\n\t\t\tv >>= 1;\n\t\t}\n\t}\n\n\tt3_write_reg(adapter, A_SG_INT_CAUSE, reset);\n\n\t \n\tspin_lock_irq(&adapter->work_lock);\n\tif (adapter->open_device_map & PORT_MASK)\n\t\tschedule_chk_task(adapter);\n\tspin_unlock_irq(&adapter->work_lock);\n}\n\nstatic void db_full_task(struct work_struct *work)\n{\n\tstruct adapter *adapter = container_of(work, struct adapter,\n\t\t\t\t\t       db_full_task);\n\n\tcxgb3_event_notify(&adapter->tdev, OFFLOAD_DB_FULL, 0);\n}\n\nstatic void db_empty_task(struct work_struct *work)\n{\n\tstruct adapter *adapter = container_of(work, struct adapter,\n\t\t\t\t\t       db_empty_task);\n\n\tcxgb3_event_notify(&adapter->tdev, OFFLOAD_DB_EMPTY, 0);\n}\n\nstatic void db_drop_task(struct work_struct *work)\n{\n\tstruct adapter *adapter = container_of(work, struct adapter,\n\t\t\t\t\t       db_drop_task);\n\tunsigned long delay = 1000;\n\tunsigned short r;\n\n\tcxgb3_event_notify(&adapter->tdev, OFFLOAD_DB_DROP, 0);\n\n\t \n\tget_random_bytes(&r, 2);\n\tdelay += r & 1023;\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tschedule_timeout(usecs_to_jiffies(delay));\n\tring_dbs(adapter);\n}\n\n \nstatic void ext_intr_task(struct work_struct *work)\n{\n\tstruct adapter *adapter = container_of(work, struct adapter,\n\t\t\t\t\t       ext_intr_handler_task);\n\tint i;\n\n\t \n\tfor_each_port(adapter, i) {\n\t\tstruct net_device *dev = adapter->port[i];\n\t\tstruct port_info *p = netdev_priv(dev);\n\n\t\tt3_xgm_intr_disable(adapter, i);\n\t\tt3_read_reg(adapter, A_XGM_INT_STATUS + p->mac.offset);\n\t}\n\n\t \n\tt3_phy_intr_handler(adapter);\n\n\tfor_each_port(adapter, i)\n\t\tt3_xgm_intr_enable(adapter, i);\n\n\t \n\tspin_lock_irq(&adapter->work_lock);\n\tif (adapter->slow_intr_mask) {\n\t\tadapter->slow_intr_mask |= F_T3DBG;\n\t\tt3_write_reg(adapter, A_PL_INT_CAUSE0, F_T3DBG);\n\t\tt3_write_reg(adapter, A_PL_INT_ENABLE0,\n\t\t\t     adapter->slow_intr_mask);\n\t}\n\tspin_unlock_irq(&adapter->work_lock);\n}\n\n \nvoid t3_os_ext_intr_handler(struct adapter *adapter)\n{\n\t \n\tspin_lock(&adapter->work_lock);\n\tif (adapter->slow_intr_mask) {\n\t\tadapter->slow_intr_mask &= ~F_T3DBG;\n\t\tt3_write_reg(adapter, A_PL_INT_ENABLE0,\n\t\t\t     adapter->slow_intr_mask);\n\t\tqueue_work(cxgb3_wq, &adapter->ext_intr_handler_task);\n\t}\n\tspin_unlock(&adapter->work_lock);\n}\n\nvoid t3_os_link_fault_handler(struct adapter *adapter, int port_id)\n{\n\tstruct net_device *netdev = adapter->port[port_id];\n\tstruct port_info *pi = netdev_priv(netdev);\n\n\tspin_lock(&adapter->work_lock);\n\tpi->link_fault = 1;\n\tspin_unlock(&adapter->work_lock);\n}\n\nstatic int t3_adapter_error(struct adapter *adapter, int reset, int on_wq)\n{\n\tint i, ret = 0;\n\n\tif (is_offload(adapter) &&\n\t    test_bit(OFFLOAD_DEVMAP_BIT, &adapter->open_device_map)) {\n\t\tcxgb3_event_notify(&adapter->tdev, OFFLOAD_STATUS_DOWN, 0);\n\t\toffload_close(&adapter->tdev);\n\t}\n\n\t \n\tfor_each_port(adapter, i) {\n\t\tstruct net_device *netdev = adapter->port[i];\n\n\t\tif (netif_running(netdev))\n\t\t\t__cxgb_close(netdev, on_wq);\n\t}\n\n\t \n\tt3_stop_sge_timers(adapter);\n\n\tadapter->flags &= ~FULL_INIT_DONE;\n\n\tif (reset)\n\t\tret = t3_reset_adapter(adapter);\n\n\tpci_disable_device(adapter->pdev);\n\n\treturn ret;\n}\n\nstatic int t3_reenable_adapter(struct adapter *adapter)\n{\n\tif (pci_enable_device(adapter->pdev)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Cannot re-enable PCI device after reset.\\n\");\n\t\tgoto err;\n\t}\n\tpci_set_master(adapter->pdev);\n\tpci_restore_state(adapter->pdev);\n\tpci_save_state(adapter->pdev);\n\n\t \n\tt3_free_sge_resources(adapter);\n\n\tif (t3_replay_prep_adapter(adapter))\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\treturn -1;\n}\n\nstatic void t3_resume_ports(struct adapter *adapter)\n{\n\tint i;\n\n\t \n\tfor_each_port(adapter, i) {\n\t\tstruct net_device *netdev = adapter->port[i];\n\n\t\tif (netif_running(netdev)) {\n\t\t\tif (cxgb_open(netdev)) {\n\t\t\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\t\t\"can't bring device back up\"\n\t\t\t\t\t\" after reset\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_offload(adapter) && !ofld_disable)\n\t\tcxgb3_event_notify(&adapter->tdev, OFFLOAD_STATUS_UP, 0);\n}\n\n \nstatic void fatal_error_task(struct work_struct *work)\n{\n\tstruct adapter *adapter = container_of(work, struct adapter,\n\t\t\t\t\t       fatal_error_handler_task);\n\tint err = 0;\n\n\trtnl_lock();\n\terr = t3_adapter_error(adapter, 1, 1);\n\tif (!err)\n\t\terr = t3_reenable_adapter(adapter);\n\tif (!err)\n\t\tt3_resume_ports(adapter);\n\n\tCH_ALERT(adapter, \"adapter reset %s\\n\", err ? \"failed\" : \"succeeded\");\n\trtnl_unlock();\n}\n\nvoid t3_fatal_err(struct adapter *adapter)\n{\n\tunsigned int fw_status[4];\n\n\tif (adapter->flags & FULL_INIT_DONE) {\n\t\tt3_sge_stop_dma(adapter);\n\t\tt3_write_reg(adapter, A_XGM_TX_CTRL, 0);\n\t\tt3_write_reg(adapter, A_XGM_RX_CTRL, 0);\n\t\tt3_write_reg(adapter, XGM_REG(A_XGM_TX_CTRL, 1), 0);\n\t\tt3_write_reg(adapter, XGM_REG(A_XGM_RX_CTRL, 1), 0);\n\n\t\tspin_lock(&adapter->work_lock);\n\t\tt3_intr_disable(adapter);\n\t\tqueue_work(cxgb3_wq, &adapter->fatal_error_handler_task);\n\t\tspin_unlock(&adapter->work_lock);\n\t}\n\tCH_ALERT(adapter, \"encountered fatal error, operation suspended\\n\");\n\tif (!t3_cim_ctl_blk_read(adapter, 0xa0, 4, fw_status))\n\t\tCH_ALERT(adapter, \"FW status: 0x%x, 0x%x, 0x%x, 0x%x\\n\",\n\t\t\t fw_status[0], fw_status[1],\n\t\t\t fw_status[2], fw_status[3]);\n}\n\n \nstatic pci_ers_result_t t3_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t     pci_channel_state_t state)\n{\n\tstruct adapter *adapter = pci_get_drvdata(pdev);\n\n\tif (state == pci_channel_io_perm_failure)\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\n\tt3_adapter_error(adapter, 0, 0);\n\n\t \n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n \nstatic pci_ers_result_t t3_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct adapter *adapter = pci_get_drvdata(pdev);\n\n\tif (!t3_reenable_adapter(adapter))\n\t\treturn PCI_ERS_RESULT_RECOVERED;\n\n\treturn PCI_ERS_RESULT_DISCONNECT;\n}\n\n \nstatic void t3_io_resume(struct pci_dev *pdev)\n{\n\tstruct adapter *adapter = pci_get_drvdata(pdev);\n\n\tCH_ALERT(adapter, \"adapter recovering, PEX ERR 0x%x\\n\",\n\t\t t3_read_reg(adapter, A_PCIE_PEX_ERR));\n\n\trtnl_lock();\n\tt3_resume_ports(adapter);\n\trtnl_unlock();\n}\n\nstatic const struct pci_error_handlers t3_err_handler = {\n\t.error_detected = t3_io_error_detected,\n\t.slot_reset = t3_io_slot_reset,\n\t.resume = t3_io_resume,\n};\n\n \nstatic void set_nqsets(struct adapter *adap)\n{\n\tint i, j = 0;\n\tint num_cpus = netif_get_num_default_rss_queues();\n\tint hwports = adap->params.nports;\n\tint nqsets = adap->msix_nvectors - 1;\n\n\tif (adap->params.rev > 0 && adap->flags & USING_MSIX) {\n\t\tif (hwports == 2 &&\n\t\t    (hwports * nqsets > SGE_QSETS ||\n\t\t     num_cpus >= nqsets / hwports))\n\t\t\tnqsets /= hwports;\n\t\tif (nqsets > num_cpus)\n\t\t\tnqsets = num_cpus;\n\t\tif (nqsets < 1 || hwports == 4)\n\t\t\tnqsets = 1;\n\t} else {\n\t\tnqsets = 1;\n\t}\n\n\tfor_each_port(adap, i) {\n\t\tstruct port_info *pi = adap2pinfo(adap, i);\n\n\t\tpi->first_qset = j;\n\t\tpi->nqsets = nqsets;\n\t\tj = pi->first_qset + nqsets;\n\n\t\tdev_info(&adap->pdev->dev,\n\t\t\t \"Port %d using %d queue sets.\\n\", i, nqsets);\n\t}\n}\n\nstatic int cxgb_enable_msix(struct adapter *adap)\n{\n\tstruct msix_entry entries[SGE_QSETS + 1];\n\tint vectors;\n\tint i;\n\n\tvectors = ARRAY_SIZE(entries);\n\tfor (i = 0; i < vectors; ++i)\n\t\tentries[i].entry = i;\n\n\tvectors = pci_enable_msix_range(adap->pdev, entries,\n\t\t\t\t\tadap->params.nports + 1, vectors);\n\tif (vectors < 0)\n\t\treturn vectors;\n\n\tfor (i = 0; i < vectors; ++i)\n\t\tadap->msix_info[i].vec = entries[i].vector;\n\tadap->msix_nvectors = vectors;\n\n\treturn 0;\n}\n\nstatic void print_port_info(struct adapter *adap, const struct adapter_info *ai)\n{\n\tstatic const char *pci_variant[] = {\n\t\t\"PCI\", \"PCI-X\", \"PCI-X ECC\", \"PCI-X 266\", \"PCI Express\"\n\t};\n\n\tint i;\n\tchar buf[80];\n\n\tif (is_pcie(adap))\n\t\tsnprintf(buf, sizeof(buf), \"%s x%d\",\n\t\t\t pci_variant[adap->params.pci.variant],\n\t\t\t adap->params.pci.width);\n\telse\n\t\tsnprintf(buf, sizeof(buf), \"%s %dMHz/%d-bit\",\n\t\t\t pci_variant[adap->params.pci.variant],\n\t\t\t adap->params.pci.speed, adap->params.pci.width);\n\n\tfor_each_port(adap, i) {\n\t\tstruct net_device *dev = adap->port[i];\n\t\tconst struct port_info *pi = netdev_priv(dev);\n\n\t\tif (!test_bit(i, &adap->registered_device_map))\n\t\t\tcontinue;\n\t\tnetdev_info(dev, \"%s %s %sNIC (rev %d) %s%s\\n\",\n\t\t\t    ai->desc, pi->phy.desc,\n\t\t\t    is_offload(adap) ? \"R\" : \"\", adap->params.rev, buf,\n\t\t\t    (adap->flags & USING_MSIX) ? \" MSI-X\" :\n\t\t\t    (adap->flags & USING_MSI) ? \" MSI\" : \"\");\n\t\tif (adap->name == dev->name && adap->params.vpd.mclk)\n\t\t\tpr_info(\"%s: %uMB CM, %uMB PMTX, %uMB PMRX, S/N: %s\\n\",\n\t\t\t       adap->name, t3_mc7_size(&adap->cm) >> 20,\n\t\t\t       t3_mc7_size(&adap->pmtx) >> 20,\n\t\t\t       t3_mc7_size(&adap->pmrx) >> 20,\n\t\t\t       adap->params.vpd.sn);\n\t}\n}\n\nstatic const struct net_device_ops cxgb_netdev_ops = {\n\t.ndo_open\t\t= cxgb_open,\n\t.ndo_stop\t\t= cxgb_close,\n\t.ndo_start_xmit\t\t= t3_eth_xmit,\n\t.ndo_get_stats\t\t= cxgb_get_stats,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_rx_mode\t= cxgb_set_rxmode,\n\t.ndo_eth_ioctl\t\t= cxgb_ioctl,\n\t.ndo_siocdevprivate\t= cxgb_siocdevprivate,\n\t.ndo_change_mtu\t\t= cxgb_change_mtu,\n\t.ndo_set_mac_address\t= cxgb_set_mac_addr,\n\t.ndo_fix_features\t= cxgb_fix_features,\n\t.ndo_set_features\t= cxgb_set_features,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= cxgb_netpoll,\n#endif\n};\n\nstatic void cxgb3_init_iscsi_mac(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\n\tmemcpy(pi->iscsic.mac_addr, dev->dev_addr, ETH_ALEN);\n\tpi->iscsic.mac_addr[3] |= 0x80;\n}\n\n#define TSO_FLAGS (NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_TSO_ECN)\n#define VLAN_FEAT (NETIF_F_SG | NETIF_F_IP_CSUM | TSO_FLAGS | \\\n\t\t\tNETIF_F_IPV6_CSUM | NETIF_F_HIGHDMA)\nstatic int init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint i, err;\n\tresource_size_t mmio_start, mmio_len;\n\tconst struct adapter_info *ai;\n\tstruct adapter *adapter = NULL;\n\tstruct port_info *pi;\n\n\tif (!cxgb3_wq) {\n\t\tcxgb3_wq = create_singlethread_workqueue(DRV_NAME);\n\t\tif (!cxgb3_wq) {\n\t\t\tpr_err(\"cannot initialize work queue\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot enable PCI device\\n\");\n\t\tgoto out;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err) {\n\t\t \n\t\tdev_info(&pdev->dev, \"cannot obtain PCI resources\\n\");\n\t\tgoto out_disable_device;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"no usable DMA configuration\\n\");\n\t\tgoto out_release_regions;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_save_state(pdev);\n\n\tmmio_start = pci_resource_start(pdev, 0);\n\tmmio_len = pci_resource_len(pdev, 0);\n\tai = t3_get_adapter_info(ent->driver_data);\n\n\tadapter = kzalloc(sizeof(*adapter), GFP_KERNEL);\n\tif (!adapter) {\n\t\terr = -ENOMEM;\n\t\tgoto out_release_regions;\n\t}\n\n\tadapter->nofail_skb =\n\t\talloc_skb(sizeof(struct cpl_set_tcb_field), GFP_KERNEL);\n\tif (!adapter->nofail_skb) {\n\t\tdev_err(&pdev->dev, \"cannot allocate nofail buffer\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_free_adapter;\n\t}\n\n\tadapter->regs = ioremap(mmio_start, mmio_len);\n\tif (!adapter->regs) {\n\t\tdev_err(&pdev->dev, \"cannot map device registers\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_free_adapter_nofail;\n\t}\n\n\tadapter->pdev = pdev;\n\tadapter->name = pci_name(pdev);\n\tadapter->msg_enable = dflt_msg_enable;\n\tadapter->mmio_len = mmio_len;\n\n\tmutex_init(&adapter->mdio_lock);\n\tspin_lock_init(&adapter->work_lock);\n\tspin_lock_init(&adapter->stats_lock);\n\n\tINIT_LIST_HEAD(&adapter->adapter_list);\n\tINIT_WORK(&adapter->ext_intr_handler_task, ext_intr_task);\n\tINIT_WORK(&adapter->fatal_error_handler_task, fatal_error_task);\n\n\tINIT_WORK(&adapter->db_full_task, db_full_task);\n\tINIT_WORK(&adapter->db_empty_task, db_empty_task);\n\tINIT_WORK(&adapter->db_drop_task, db_drop_task);\n\n\tINIT_DELAYED_WORK(&adapter->adap_check_task, t3_adap_check_task);\n\n\tfor (i = 0; i < ai->nports0 + ai->nports1; ++i) {\n\t\tstruct net_device *netdev;\n\n\t\tnetdev = alloc_etherdev_mq(sizeof(struct port_info), SGE_QSETS);\n\t\tif (!netdev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_dev;\n\t\t}\n\n\t\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\t\tadapter->port[i] = netdev;\n\t\tpi = netdev_priv(netdev);\n\t\tpi->adapter = adapter;\n\t\tpi->port_id = i;\n\t\tnetif_carrier_off(netdev);\n\t\tnetdev->irq = pdev->irq;\n\t\tnetdev->mem_start = mmio_start;\n\t\tnetdev->mem_end = mmio_start + mmio_len - 1;\n\t\tnetdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM |\n\t\t\tNETIF_F_TSO | NETIF_F_RXCSUM | NETIF_F_HW_VLAN_CTAG_RX;\n\t\tnetdev->features |= netdev->hw_features |\n\t\t\t\t    NETIF_F_HW_VLAN_CTAG_TX;\n\t\tnetdev->vlan_features |= netdev->features & VLAN_FEAT;\n\n\t\tnetdev->features |= NETIF_F_HIGHDMA;\n\n\t\tnetdev->netdev_ops = &cxgb_netdev_ops;\n\t\tnetdev->ethtool_ops = &cxgb_ethtool_ops;\n\t\tnetdev->min_mtu = 81;\n\t\tnetdev->max_mtu = ETH_MAX_MTU;\n\t\tnetdev->dev_port = pi->port_id;\n\t}\n\n\tpci_set_drvdata(pdev, adapter);\n\tif (t3_prep_adapter(adapter, ai, 1) < 0) {\n\t\terr = -ENODEV;\n\t\tgoto out_free_dev;\n\t}\n\n\t \n\tfor_each_port(adapter, i) {\n\t\terr = register_netdev(adapter->port[i]);\n\t\tif (err)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"cannot register net device %s, skipping\\n\",\n\t\t\t\t adapter->port[i]->name);\n\t\telse {\n\t\t\t \n\t\t\tif (!adapter->registered_device_map)\n\t\t\t\tadapter->name = adapter->port[i]->name;\n\n\t\t\t__set_bit(i, &adapter->registered_device_map);\n\t\t}\n\t}\n\tif (!adapter->registered_device_map) {\n\t\tdev_err(&pdev->dev, \"could not register any net devices\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out_free_dev;\n\t}\n\n\tfor_each_port(adapter, i)\n\t\tcxgb3_init_iscsi_mac(adapter->port[i]);\n\n\t \n\tt3_led_ready(adapter);\n\n\tif (is_offload(adapter)) {\n\t\t__set_bit(OFFLOAD_DEVMAP_BIT, &adapter->registered_device_map);\n\t\tcxgb3_adapter_ofld(adapter);\n\t}\n\n\t \n\tif (msi > 1 && cxgb_enable_msix(adapter) == 0)\n\t\tadapter->flags |= USING_MSIX;\n\telse if (msi > 0 && pci_enable_msi(pdev) == 0)\n\t\tadapter->flags |= USING_MSI;\n\n\tset_nqsets(adapter);\n\n\terr = sysfs_create_group(&adapter->port[0]->dev.kobj,\n\t\t\t\t &cxgb3_attr_group);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot create sysfs group\\n\");\n\t\tgoto out_close_led;\n\t}\n\n\tprint_port_info(adapter, ai);\n\treturn 0;\n\nout_close_led:\n\tt3_set_reg_field(adapter, A_T3DBG_GPIO_EN, F_GPIO0_OUT_VAL, 0);\n\nout_free_dev:\n\tiounmap(adapter->regs);\n\tfor (i = ai->nports0 + ai->nports1 - 1; i >= 0; --i)\n\t\tif (adapter->port[i])\n\t\t\tfree_netdev(adapter->port[i]);\n\nout_free_adapter_nofail:\n\tkfree_skb(adapter->nofail_skb);\n\nout_free_adapter:\n\tkfree(adapter);\n\nout_release_regions:\n\tpci_release_regions(pdev);\nout_disable_device:\n\tpci_disable_device(pdev);\nout:\n\treturn err;\n}\n\nstatic void remove_one(struct pci_dev *pdev)\n{\n\tstruct adapter *adapter = pci_get_drvdata(pdev);\n\n\tif (adapter) {\n\t\tint i;\n\n\t\tt3_sge_stop(adapter);\n\t\tsysfs_remove_group(&adapter->port[0]->dev.kobj,\n\t\t\t\t   &cxgb3_attr_group);\n\n\t\tif (is_offload(adapter)) {\n\t\t\tcxgb3_adapter_unofld(adapter);\n\t\t\tif (test_bit(OFFLOAD_DEVMAP_BIT,\n\t\t\t\t     &adapter->open_device_map))\n\t\t\t\toffload_close(&adapter->tdev);\n\t\t}\n\n\t\tfor_each_port(adapter, i)\n\t\t    if (test_bit(i, &adapter->registered_device_map))\n\t\t\tunregister_netdev(adapter->port[i]);\n\n\t\tt3_stop_sge_timers(adapter);\n\t\tt3_free_sge_resources(adapter);\n\t\tcxgb_disable_msi(adapter);\n\n\t\tfor_each_port(adapter, i)\n\t\t\tif (adapter->port[i])\n\t\t\t\tfree_netdev(adapter->port[i]);\n\n\t\tiounmap(adapter->regs);\n\t\tkfree_skb(adapter->nofail_skb);\n\t\tkfree(adapter);\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t}\n}\n\nstatic struct pci_driver driver = {\n\t.name = DRV_NAME,\n\t.id_table = cxgb3_pci_tbl,\n\t.probe = init_one,\n\t.remove = remove_one,\n\t.err_handler = &t3_err_handler,\n};\n\nstatic int __init cxgb3_init_module(void)\n{\n\tint ret;\n\n\tcxgb3_offload_init();\n\n\tret = pci_register_driver(&driver);\n\treturn ret;\n}\n\nstatic void __exit cxgb3_cleanup_module(void)\n{\n\tpci_unregister_driver(&driver);\n\tif (cxgb3_wq)\n\t\tdestroy_workqueue(cxgb3_wq);\n}\n\nmodule_init(cxgb3_init_module);\nmodule_exit(cxgb3_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}