{
  "module_name": "vsc7326.c",
  "hash_id": "bf24c87977e3a569fa67fc3e9ba99705f3add46c80a1731f5352420710d03da9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb/vsc7326.c",
  "human_readable_source": "\n \n\n \n\n#include \"gmac.h\"\n#include \"elmer0.h\"\n#include \"vsc7326_reg.h\"\n\n \n#define STATS_TICK_SECS 15\n \n#define MAJOR_UPDATE_TICKS (1800 / STATS_TICK_SECS)\n\n \n#define WM_DISABLE\t0x01a01fff\n#define WM_ENABLE\t0x014a03F0\n\nstruct init_table {\n\tu32 addr;\n\tu32 data;\n};\n\nstruct _cmac_instance {\n\tu32 index;\n\tu32 ticks;\n};\n\n#define INITBLOCK_SLEEP\t0xffffffff\n\nstatic void vsc_read(adapter_t *adapter, u32 addr, u32 *val)\n{\n\tu32 status, vlo, vhi;\n\tint i;\n\n\tspin_lock_bh(&adapter->mac_lock);\n\tt1_tpi_read(adapter, (addr << 2) + 4, &vlo);\n\ti = 0;\n\tdo {\n\t\tt1_tpi_read(adapter, (REG_LOCAL_STATUS << 2) + 4, &vlo);\n\t\tt1_tpi_read(adapter, REG_LOCAL_STATUS << 2, &vhi);\n\t\tstatus = (vhi << 16) | vlo;\n\t\ti++;\n\t} while (((status & 1) == 0) && (i < 50));\n\tif (i == 50)\n\t\tpr_err(\"Invalid tpi read from MAC, breaking loop.\\n\");\n\n\tt1_tpi_read(adapter, (REG_LOCAL_DATA << 2) + 4, &vlo);\n\tt1_tpi_read(adapter, REG_LOCAL_DATA << 2, &vhi);\n\n\t*val = (vhi << 16) | vlo;\n\n\t \n\tspin_unlock_bh(&adapter->mac_lock);\n}\n\nstatic void vsc_write(adapter_t *adapter, u32 addr, u32 data)\n{\n\tspin_lock_bh(&adapter->mac_lock);\n\tt1_tpi_write(adapter, (addr << 2) + 4, data & 0xFFFF);\n\tt1_tpi_write(adapter, addr << 2, (data >> 16) & 0xFFFF);\n\t \n\tspin_unlock_bh(&adapter->mac_lock);\n}\n\n \nstatic void vsc7326_full_reset(adapter_t* adapter)\n{\n\tu32 val;\n\tu32 result = 0xffff;\n\n\tt1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval &= ~1;\n\tt1_tpi_write(adapter, A_ELMER0_GPO, val);\n\tudelay(2);\n\tval |= 0x1;\t \n\tval |= 0x800;\t \n\tt1_tpi_write(adapter, A_ELMER0_GPO, val);\n\tmdelay(1);\n\tvsc_write(adapter, REG_SW_RESET, 0x80000001);\n\tdo {\n\t\tmdelay(1);\n\t\tvsc_read(adapter, REG_SW_RESET, &result);\n\t} while (result != 0x0);\n}\n\nstatic struct init_table vsc7326_reset[] = {\n\t{      REG_IFACE_MODE, 0x00000000 },\n\t{         REG_CRC_CFG, 0x00000020 },\n\t{   REG_PLL_CLK_SPEED, 0x00050c00 },\n\t{   REG_PLL_CLK_SPEED, 0x00050c00 },\n\t{            REG_MSCH, 0x00002f14 },\n\t{       REG_SPI4_MISC, 0x00040409 },\n\t{     REG_SPI4_DESKEW, 0x00080000 },\n\t{ REG_SPI4_ING_SETUP2, 0x08080004 },\n\t{ REG_SPI4_ING_SETUP0, 0x04111004 },\n\t{ REG_SPI4_EGR_SETUP0, 0x80001a04 },\n\t{ REG_SPI4_ING_SETUP1, 0x02010000 },\n\t{      REG_AGE_INC(0), 0x00000000 },\n\t{      REG_AGE_INC(1), 0x00000000 },\n\t{     REG_ING_CONTROL, 0x0a200011 },\n\t{     REG_EGR_CONTROL, 0xa0010091 },\n};\n\nstatic struct init_table vsc7326_portinit[4][22] = {\n\t{\t \n\t\t\t \n\t\t{           REG_DBG(0), 0x000004f0 },\n\t\t{           REG_HDX(0), 0x00073101 },\n\t\t{        REG_TEST(0,0), 0x00000022 },\n\t\t{        REG_TEST(1,0), 0x00000022 },\n\t\t{  REG_TOP_BOTTOM(0,0), 0x003f0000 },\n\t\t{  REG_TOP_BOTTOM(1,0), 0x00120000 },\n\t\t{ REG_HIGH_LOW_WM(0,0), 0x07460757 },\n\t\t{ REG_HIGH_LOW_WM(1,0), WM_DISABLE },\n\t\t{   REG_CT_THRHLD(0,0), 0x00000000 },\n\t\t{   REG_CT_THRHLD(1,0), 0x00000000 },\n\t\t{         REG_BUCKE(0), 0x0002ffff },\n\t\t{         REG_BUCKI(0), 0x0002ffff },\n\t\t{        REG_TEST(0,0), 0x00000020 },\n\t\t{        REG_TEST(1,0), 0x00000020 },\n\t\t\t \n\t\t{       REG_MAX_LEN(0), 0x00002710 },\n\t\t{     REG_PORT_FAIL(0), 0x00000002 },\n\t\t{    REG_NORMALIZER(0), 0x00000a64 },\n\t\t{        REG_DENORM(0), 0x00000010 },\n\t\t{     REG_STICK_BIT(0), 0x03baa370 },\n\t\t{     REG_DEV_SETUP(0), 0x00000083 },\n\t\t{     REG_DEV_SETUP(0), 0x00000082 },\n\t\t{      REG_MODE_CFG(0), 0x0200259f },\n\t},\n\t{\t \n\t\t\t \n\t\t{           REG_DBG(1), 0x000004f0 },\n\t\t{           REG_HDX(1), 0x00073101 },\n\t\t{        REG_TEST(0,1), 0x00000022 },\n\t\t{        REG_TEST(1,1), 0x00000022 },\n\t\t{  REG_TOP_BOTTOM(0,1), 0x007e003f },\n\t\t{  REG_TOP_BOTTOM(1,1), 0x00240012 },\n\t\t{ REG_HIGH_LOW_WM(0,1), 0x07460757 },\n\t\t{ REG_HIGH_LOW_WM(1,1), WM_DISABLE },\n\t\t{   REG_CT_THRHLD(0,1), 0x00000000 },\n\t\t{   REG_CT_THRHLD(1,1), 0x00000000 },\n\t\t{         REG_BUCKE(1), 0x0002ffff },\n\t\t{         REG_BUCKI(1), 0x0002ffff },\n\t\t{        REG_TEST(0,1), 0x00000020 },\n\t\t{        REG_TEST(1,1), 0x00000020 },\n\t\t\t \n\t\t{       REG_MAX_LEN(1), 0x00002710 },\n\t\t{     REG_PORT_FAIL(1), 0x00000002 },\n\t\t{    REG_NORMALIZER(1), 0x00000a64 },\n\t\t{        REG_DENORM(1), 0x00000010 },\n\t\t{     REG_STICK_BIT(1), 0x03baa370 },\n\t\t{     REG_DEV_SETUP(1), 0x00000083 },\n\t\t{     REG_DEV_SETUP(1), 0x00000082 },\n\t\t{      REG_MODE_CFG(1), 0x0200259f },\n\t},\n\t{\t \n\t\t\t \n\t\t{           REG_DBG(2), 0x000004f0 },\n\t\t{           REG_HDX(2), 0x00073101 },\n\t\t{        REG_TEST(0,2), 0x00000022 },\n\t\t{        REG_TEST(1,2), 0x00000022 },\n\t\t{  REG_TOP_BOTTOM(0,2), 0x00bd007e },\n\t\t{  REG_TOP_BOTTOM(1,2), 0x00360024 },\n\t\t{ REG_HIGH_LOW_WM(0,2), 0x07460757 },\n\t\t{ REG_HIGH_LOW_WM(1,2), WM_DISABLE },\n\t\t{   REG_CT_THRHLD(0,2), 0x00000000 },\n\t\t{   REG_CT_THRHLD(1,2), 0x00000000 },\n\t\t{         REG_BUCKE(2), 0x0002ffff },\n\t\t{         REG_BUCKI(2), 0x0002ffff },\n\t\t{        REG_TEST(0,2), 0x00000020 },\n\t\t{        REG_TEST(1,2), 0x00000020 },\n\t\t\t \n\t\t{       REG_MAX_LEN(2), 0x00002710 },\n\t\t{     REG_PORT_FAIL(2), 0x00000002 },\n\t\t{    REG_NORMALIZER(2), 0x00000a64 },\n\t\t{        REG_DENORM(2), 0x00000010 },\n\t\t{     REG_STICK_BIT(2), 0x03baa370 },\n\t\t{     REG_DEV_SETUP(2), 0x00000083 },\n\t\t{     REG_DEV_SETUP(2), 0x00000082 },\n\t\t{      REG_MODE_CFG(2), 0x0200259f },\n\t},\n\t{\t \n\t\t\t \n\t\t{           REG_DBG(3), 0x000004f0 },\n\t\t{           REG_HDX(3), 0x00073101 },\n\t\t{        REG_TEST(0,3), 0x00000022 },\n\t\t{        REG_TEST(1,3), 0x00000022 },\n\t\t{  REG_TOP_BOTTOM(0,3), 0x00fc00bd },\n\t\t{  REG_TOP_BOTTOM(1,3), 0x00480036 },\n\t\t{ REG_HIGH_LOW_WM(0,3), 0x07460757 },\n\t\t{ REG_HIGH_LOW_WM(1,3), WM_DISABLE },\n\t\t{   REG_CT_THRHLD(0,3), 0x00000000 },\n\t\t{   REG_CT_THRHLD(1,3), 0x00000000 },\n\t\t{         REG_BUCKE(3), 0x0002ffff },\n\t\t{         REG_BUCKI(3), 0x0002ffff },\n\t\t{        REG_TEST(0,3), 0x00000020 },\n\t\t{        REG_TEST(1,3), 0x00000020 },\n\t\t\t \n\t\t{       REG_MAX_LEN(3), 0x00002710 },\n\t\t{     REG_PORT_FAIL(3), 0x00000002 },\n\t\t{    REG_NORMALIZER(3), 0x00000a64 },\n\t\t{        REG_DENORM(3), 0x00000010 },\n\t\t{     REG_STICK_BIT(3), 0x03baa370 },\n\t\t{     REG_DEV_SETUP(3), 0x00000083 },\n\t\t{     REG_DEV_SETUP(3), 0x00000082 },\n\t\t{      REG_MODE_CFG(3), 0x0200259f },\n\t},\n};\n\nstatic void run_table(adapter_t *adapter, struct init_table *ib, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (ib[i].addr == INITBLOCK_SLEEP) {\n\t\t\tudelay( ib[i].data );\n\t\t\tpr_err(\"sleep %d us\\n\",ib[i].data);\n\t\t} else\n\t\t\tvsc_write( adapter, ib[i].addr, ib[i].data );\n\t}\n}\n\nstatic int bist_rd(adapter_t *adapter, int moduleid, int address)\n{\n\tint data = 0;\n\tu32 result = 0;\n\n\tif ((address != 0x0) &&\n\t    (address != 0x1) &&\n\t    (address != 0x2) &&\n\t    (address != 0xd) &&\n\t    (address != 0xe))\n\t\t\tpr_err(\"No bist address: 0x%x\\n\", address);\n\n\tdata = ((0x00 << 24) | ((address & 0xff) << 16) | (0x00 << 8) |\n\t\t((moduleid & 0xff) << 0));\n\tvsc_write(adapter, REG_RAM_BIST_CMD, data);\n\n\tudelay(10);\n\n\tvsc_read(adapter, REG_RAM_BIST_RESULT, &result);\n\tif ((result & (1 << 9)) != 0x0)\n\t\tpr_err(\"Still in bist read: 0x%x\\n\", result);\n\telse if ((result & (1 << 8)) != 0x0)\n\t\tpr_err(\"bist read error: 0x%x\\n\", result);\n\n\treturn result & 0xff;\n}\n\nstatic int bist_wr(adapter_t *adapter, int moduleid, int address, int value)\n{\n\tint data = 0;\n\tu32 result = 0;\n\n\tif ((address != 0x0) &&\n\t    (address != 0x1) &&\n\t    (address != 0x2) &&\n\t    (address != 0xd) &&\n\t    (address != 0xe))\n\t\t\tpr_err(\"No bist address: 0x%x\\n\", address);\n\n\tif (value > 255)\n\t\tpr_err(\"Suspicious write out of range value: 0x%x\\n\", value);\n\n\tdata = ((0x01 << 24) | ((address & 0xff) << 16) | (value << 8) |\n\t\t((moduleid & 0xff) << 0));\n\tvsc_write(adapter, REG_RAM_BIST_CMD, data);\n\n\tudelay(5);\n\n\tvsc_read(adapter, REG_RAM_BIST_CMD, &result);\n\tif ((result & (1 << 27)) != 0x0)\n\t\tpr_err(\"Still in bist write: 0x%x\\n\", result);\n\telse if ((result & (1 << 26)) != 0x0)\n\t\tpr_err(\"bist write error: 0x%x\\n\", result);\n\n\treturn 0;\n}\n\nstatic int run_bist(adapter_t *adapter, int moduleid)\n{\n\t \n\t(void) bist_wr(adapter,moduleid, 0x00, 0x02);\n\t(void) bist_wr(adapter,moduleid, 0x01, 0x01);\n\n\treturn 0;\n}\n\nstatic int check_bist(adapter_t *adapter, int moduleid)\n{\n\tint result=0;\n\tint column=0;\n\t \n\tresult = bist_rd(adapter,moduleid, 0x02);\n\tcolumn = ((bist_rd(adapter,moduleid, 0x0e)<<8) +\n\t\t\t(bist_rd(adapter,moduleid, 0x0d)));\n\tif ((result & 3) != 0x3)\n\t\tpr_err(\"Result: 0x%x  BIST error in ram %d, column: 0x%04x\\n\",\n\t\t\tresult, moduleid, column);\n\treturn 0;\n}\n\nstatic int enable_mem(adapter_t *adapter, int moduleid)\n{\n\t \n\t(void) bist_wr(adapter,moduleid, 0x00, 0x00);\n\treturn 0;\n}\n\nstatic int run_bist_all(adapter_t *adapter)\n{\n\tint port = 0;\n\tu32 val = 0;\n\n\tvsc_write(adapter, REG_MEM_BIST, 0x5);\n\tvsc_read(adapter, REG_MEM_BIST, &val);\n\n\tfor (port = 0; port < 12; port++)\n\t\tvsc_write(adapter, REG_DEV_SETUP(port), 0x0);\n\n\tudelay(300);\n\tvsc_write(adapter, REG_SPI4_MISC, 0x00040409);\n\tudelay(300);\n\n\t(void) run_bist(adapter,13);\n\t(void) run_bist(adapter,14);\n\t(void) run_bist(adapter,20);\n\t(void) run_bist(adapter,21);\n\tmdelay(200);\n\t(void) check_bist(adapter,13);\n\t(void) check_bist(adapter,14);\n\t(void) check_bist(adapter,20);\n\t(void) check_bist(adapter,21);\n\tudelay(100);\n\t(void) enable_mem(adapter,13);\n\t(void) enable_mem(adapter,14);\n\t(void) enable_mem(adapter,20);\n\t(void) enable_mem(adapter,21);\n\tudelay(300);\n\tvsc_write(adapter, REG_SPI4_MISC, 0x60040400);\n\tudelay(300);\n\tfor (port = 0; port < 12; port++)\n\t\tvsc_write(adapter, REG_DEV_SETUP(port), 0x1);\n\n\tudelay(300);\n\tvsc_write(adapter, REG_MEM_BIST, 0x0);\n\tmdelay(10);\n\treturn 0;\n}\n\nstatic int mac_intr_handler(struct cmac *mac)\n{\n\treturn 0;\n}\n\nstatic int mac_intr_enable(struct cmac *mac)\n{\n\treturn 0;\n}\n\nstatic int mac_intr_disable(struct cmac *mac)\n{\n\treturn 0;\n}\n\nstatic int mac_intr_clear(struct cmac *mac)\n{\n\treturn 0;\n}\n\n \nstatic int mac_set_address(struct cmac* mac, const u8 addr[6])\n{\n\tu32 val;\n\tint port = mac->instance->index;\n\n\tvsc_write(mac->adapter, REG_MAC_LOW_ADDR(port),\n\t\t  (addr[3] << 16) | (addr[4] << 8) | addr[5]);\n\tvsc_write(mac->adapter, REG_MAC_HIGH_ADDR(port),\n\t\t  (addr[0] << 16) | (addr[1] << 8) | addr[2]);\n\n\tvsc_read(mac->adapter, REG_ING_FFILT_UM_EN, &val);\n\tval &= ~0xf0000000;\n\tvsc_write(mac->adapter, REG_ING_FFILT_UM_EN, val | (port << 28));\n\n\tvsc_write(mac->adapter, REG_ING_FFILT_MASK0,\n\t\t  0xffff0000 | (addr[4] << 8) | addr[5]);\n\tvsc_write(mac->adapter, REG_ING_FFILT_MASK1,\n\t\t  0xffff0000 | (addr[2] << 8) | addr[3]);\n\tvsc_write(mac->adapter, REG_ING_FFILT_MASK2,\n\t\t  0xffff0000 | (addr[0] << 8) | addr[1]);\n\treturn 0;\n}\n\nstatic int mac_get_address(struct cmac *mac, u8 addr[6])\n{\n\tu32 addr_lo, addr_hi;\n\tint port = mac->instance->index;\n\n\tvsc_read(mac->adapter, REG_MAC_LOW_ADDR(port), &addr_lo);\n\tvsc_read(mac->adapter, REG_MAC_HIGH_ADDR(port), &addr_hi);\n\n\taddr[0] = (u8) (addr_hi >> 16);\n\taddr[1] = (u8) (addr_hi >> 8);\n\taddr[2] = (u8) addr_hi;\n\taddr[3] = (u8) (addr_lo >> 16);\n\taddr[4] = (u8) (addr_lo >> 8);\n\taddr[5] = (u8) addr_lo;\n\treturn 0;\n}\n\n \nstatic int mac_reset(struct cmac *mac)\n{\n\tint index = mac->instance->index;\n\n\trun_table(mac->adapter, vsc7326_portinit[index],\n\t\t  ARRAY_SIZE(vsc7326_portinit[index]));\n\n\treturn 0;\n}\n\nstatic int mac_set_rx_mode(struct cmac *mac, struct t1_rx_mode *rm)\n{\n\tu32 v;\n\tint port = mac->instance->index;\n\n\tvsc_read(mac->adapter, REG_ING_FFILT_UM_EN, &v);\n\tv |= 1 << 12;\n\n\tif (t1_rx_mode_promisc(rm))\n\t\tv &= ~(1 << (port + 16));\n\telse\n\t\tv |= 1 << (port + 16);\n\n\tvsc_write(mac->adapter, REG_ING_FFILT_UM_EN, v);\n\treturn 0;\n}\n\nstatic int mac_set_mtu(struct cmac *mac, int mtu)\n{\n\tint port = mac->instance->index;\n\n\t \n\tvsc_write(mac->adapter, REG_MAX_LEN(port), mtu + 14 + 4);\n\treturn 0;\n}\n\nstatic int mac_set_speed_duplex_fc(struct cmac *mac, int speed, int duplex,\n\t\t\t\t   int fc)\n{\n\tu32 v;\n\tint enable, port = mac->instance->index;\n\n\tif (speed >= 0 && speed != SPEED_10 && speed != SPEED_100 &&\n\t    speed != SPEED_1000)\n\t\treturn -1;\n\tif (duplex > 0 && duplex != DUPLEX_FULL)\n\t\treturn -1;\n\n\tif (speed >= 0) {\n\t\tvsc_read(mac->adapter, REG_MODE_CFG(port), &v);\n\t\tenable = v & 3;              \n\t\tv &= ~0xf;\n\t\tv |= 4;                      \n\t\tif (speed == SPEED_1000)\n\t\t\tv |= 8;              \n\t\tenable |= v;\n\t\tvsc_write(mac->adapter, REG_MODE_CFG(port), v);\n\n\t\tif (speed == SPEED_1000)\n\t\t\tv = 0x82;\n\t\telse if (speed == SPEED_100)\n\t\t\tv = 0x84;\n\t\telse\t \n\t\t\tv = 0x86;\n\t\tvsc_write(mac->adapter, REG_DEV_SETUP(port), v | 1);  \n\t\tvsc_write(mac->adapter, REG_DEV_SETUP(port), v);\n\t\tvsc_read(mac->adapter, REG_DBG(port), &v);\n\t\tv &= ~0xff00;\n\t\tif (speed == SPEED_1000)\n\t\t\tv |= 0x400;\n\t\telse if (speed == SPEED_100)\n\t\t\tv |= 0x2000;\n\t\telse\t \n\t\t\tv |= 0xff00;\n\t\tvsc_write(mac->adapter, REG_DBG(port), v);\n\n\t\tvsc_write(mac->adapter, REG_TX_IFG(port),\n\t\t\t  speed == SPEED_1000 ? 5 : 0x11);\n\t\tif (duplex == DUPLEX_HALF)\n\t\t\tenable = 0x0;\t \n\t\telse if (speed == SPEED_1000)\n\t\t\tenable = 0xc;\n\t\telse\t \n\t\t\tenable = 0x4;\n\t\tenable |= 0x9 << 10;\t \n\t\tenable |= 0x6 << 6;\t \n\t\tenable |= 0x1 << 4;\t \n\t\tenable |= 0x3;\t\t \n\t\tvsc_write(mac->adapter, REG_MODE_CFG(port), enable);\n\n\t}\n\n\tvsc_read(mac->adapter, REG_PAUSE_CFG(port), &v);\n\tv &= 0xfff0ffff;\n\tv |= 0x20000;       \n\tif (fc & PAUSE_RX)\n\t\tv |= 0x40000;\n\tif (fc & PAUSE_TX)\n\t\tv |= 0x80000;\n\tif (fc == (PAUSE_RX | PAUSE_TX))\n\t\tv |= 0x10000;\n\tvsc_write(mac->adapter, REG_PAUSE_CFG(port), v);\n\treturn 0;\n}\n\nstatic int mac_enable(struct cmac *mac, int which)\n{\n\tu32 val;\n\tint port = mac->instance->index;\n\n\t \n\tvsc_write(mac->adapter, REG_HIGH_LOW_WM(1,port), WM_ENABLE);\n\n\tvsc_read(mac->adapter, REG_MODE_CFG(port), &val);\n\tif (which & MAC_DIRECTION_RX)\n\t\tval |= 0x2;\n\tif (which & MAC_DIRECTION_TX)\n\t\tval |= 1;\n\tvsc_write(mac->adapter, REG_MODE_CFG(port), val);\n\treturn 0;\n}\n\nstatic int mac_disable(struct cmac *mac, int which)\n{\n\tu32 val;\n\tint i, port = mac->instance->index;\n\n\t \n\tmac_reset(mac);\n\n\tvsc_read(mac->adapter, REG_MODE_CFG(port), &val);\n\tif (which & MAC_DIRECTION_RX)\n\t\tval &= ~0x2;\n\tif (which & MAC_DIRECTION_TX)\n\t\tval &= ~0x1;\n\tvsc_write(mac->adapter, REG_MODE_CFG(port), val);\n\tvsc_read(mac->adapter, REG_MODE_CFG(port), &val);\n\n\t \n\tfor (i = 0; i <= 0x3a; ++i)\n\t\tvsc_write(mac->adapter, CRA(4, port, i), 0);\n\n\t \n\tmemset(&mac->stats, 0, sizeof(struct cmac_statistics));\n\n\treturn 0;\n}\n\nstatic void rmon_update(struct cmac *mac, unsigned int addr, u64 *stat)\n{\n\tu32 v, lo;\n\n\tvsc_read(mac->adapter, addr, &v);\n\tlo = *stat;\n\t*stat = *stat - lo + v;\n\n\tif (v == 0)\n\t\treturn;\n\n\tif (v < lo)\n\t\t*stat += (1ULL << 32);\n}\n\nstatic void port_stats_update(struct cmac *mac)\n{\n\tstruct {\n\t\tunsigned int reg;\n\t\tunsigned int offset;\n\t} hw_stats[] = {\n\n#define HW_STAT(reg, stat_name) \\\n\t{ reg, offsetof(struct cmac_statistics, stat_name) / sizeof(u64) }\n\n\t\t \n\t\tHW_STAT(RxUnicast, RxUnicastFramesOK),\n\t\tHW_STAT(RxMulticast, RxMulticastFramesOK),\n\t\tHW_STAT(RxBroadcast, RxBroadcastFramesOK),\n\t\tHW_STAT(Crc, RxFCSErrors),\n\t\tHW_STAT(RxAlignment, RxAlignErrors),\n\t\tHW_STAT(RxOversize, RxFrameTooLongErrors),\n\t\tHW_STAT(RxPause, RxPauseFrames),\n\t\tHW_STAT(RxJabbers, RxJabberErrors),\n\t\tHW_STAT(RxFragments, RxRuntErrors),\n\t\tHW_STAT(RxUndersize, RxRuntErrors),\n\t\tHW_STAT(RxSymbolCarrier, RxSymbolErrors),\n\t\tHW_STAT(RxSize1519ToMax, RxJumboFramesOK),\n\n\t\t \n\t\tHW_STAT(TxUnicast, TxUnicastFramesOK),\n\t\tHW_STAT(TxMulticast, TxMulticastFramesOK),\n\t\tHW_STAT(TxBroadcast, TxBroadcastFramesOK),\n\t\tHW_STAT(TxPause, TxPauseFrames),\n\t\tHW_STAT(TxUnderrun, TxUnderrun),\n\t\tHW_STAT(TxSize1519ToMax, TxJumboFramesOK),\n\t}, *p = hw_stats;\n\tunsigned int port = mac->instance->index;\n\tu64 *stats = (u64 *)&mac->stats;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hw_stats); i++)\n\t\trmon_update(mac, CRA(0x4, port, p->reg), stats + p->offset);\n\n\trmon_update(mac, REG_TX_OK_BYTES(port), &mac->stats.TxOctetsOK);\n\trmon_update(mac, REG_RX_OK_BYTES(port), &mac->stats.RxOctetsOK);\n\trmon_update(mac, REG_RX_BAD_BYTES(port), &mac->stats.RxOctetsBad);\n}\n\n \nstatic const struct cmac_statistics *mac_update_statistics(struct cmac *mac,\n\t\t\t\t\t\t\t   int flag)\n{\n\tif (flag == MAC_STATS_UPDATE_FULL ||\n\t    mac->instance->ticks >= MAJOR_UPDATE_TICKS) {\n\t\tport_stats_update(mac);\n\t\tmac->instance->ticks = 0;\n\t} else {\n\t\tint port = mac->instance->index;\n\n\t\trmon_update(mac, REG_RX_OK_BYTES(port),\n\t\t\t    &mac->stats.RxOctetsOK);\n\t\trmon_update(mac, REG_RX_BAD_BYTES(port),\n\t\t\t    &mac->stats.RxOctetsBad);\n\t\trmon_update(mac, REG_TX_OK_BYTES(port),\n\t\t\t    &mac->stats.TxOctetsOK);\n\t\tmac->instance->ticks++;\n\t}\n\treturn &mac->stats;\n}\n\nstatic void mac_destroy(struct cmac *mac)\n{\n\tkfree(mac);\n}\n\nstatic const struct cmac_ops vsc7326_ops = {\n\t.destroy                  = mac_destroy,\n\t.reset                    = mac_reset,\n\t.interrupt_handler        = mac_intr_handler,\n\t.interrupt_enable         = mac_intr_enable,\n\t.interrupt_disable        = mac_intr_disable,\n\t.interrupt_clear          = mac_intr_clear,\n\t.enable                   = mac_enable,\n\t.disable                  = mac_disable,\n\t.set_mtu                  = mac_set_mtu,\n\t.set_rx_mode              = mac_set_rx_mode,\n\t.set_speed_duplex_fc      = mac_set_speed_duplex_fc,\n\t.statistics_update        = mac_update_statistics,\n\t.macaddress_get           = mac_get_address,\n\t.macaddress_set           = mac_set_address,\n};\n\nstatic struct cmac *vsc7326_mac_create(adapter_t *adapter, int index)\n{\n\tstruct cmac *mac;\n\tu32 val;\n\tint i;\n\n\tmac = kzalloc(sizeof(*mac) + sizeof(cmac_instance), GFP_KERNEL);\n\tif (!mac)\n\t\treturn NULL;\n\n\tmac->ops = &vsc7326_ops;\n\tmac->instance = (cmac_instance *)(mac + 1);\n\tmac->adapter  = adapter;\n\n\tmac->instance->index = index;\n\tmac->instance->ticks = 0;\n\n\ti = 0;\n\tdo {\n\t\tu32 vhi, vlo;\n\n\t\tvhi = vlo = 0;\n\t\tt1_tpi_read(adapter, (REG_LOCAL_STATUS << 2) + 4, &vlo);\n\t\tudelay(1);\n\t\tt1_tpi_read(adapter, REG_LOCAL_STATUS << 2, &vhi);\n\t\tudelay(5);\n\t\tval = (vhi << 16) | vlo;\n\t} while ((++i < 10000) && (val == 0xffffffff));\n\n\treturn mac;\n}\n\nstatic int vsc7326_mac_reset(adapter_t *adapter)\n{\n\tvsc7326_full_reset(adapter);\n\t(void) run_bist_all(adapter);\n\trun_table(adapter, vsc7326_reset, ARRAY_SIZE(vsc7326_reset));\n\treturn 0;\n}\n\nconst struct gmac t1_vsc7326_ops = {\n\t.stats_update_period = STATS_TICK_SECS,\n\t.create              = vsc7326_mac_create,\n\t.reset               = vsc7326_mac_reset,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}