{
  "module_name": "mv88e1xxx.c",
  "hash_id": "89eebf1a5897c8a15694f1b7708c4b16a1140978bcc1e90c343b55ed006f6284",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb/mv88e1xxx.c",
  "human_readable_source": "\n \n#include \"common.h\"\n#include \"mv88e1xxx.h\"\n#include \"cphy.h\"\n#include \"elmer0.h\"\n\n \n#define CROSSOVER_MDI   0\n#define CROSSOVER_MDIX  1\n#define CROSSOVER_AUTO  3\n\n#define INTR_ENABLE_MASK 0x6CA0\n\n \nstatic void mdio_set_bit(struct cphy *cphy, int reg, u32 bitval)\n{\n\tu32 val;\n\n\t(void) simple_mdio_read(cphy, reg, &val);\n\t(void) simple_mdio_write(cphy, reg, val | bitval);\n}\n\n \nstatic void mdio_clear_bit(struct cphy *cphy, int reg, u32 bitval)\n{\n\tu32 val;\n\n\t(void) simple_mdio_read(cphy, reg, &val);\n\t(void) simple_mdio_write(cphy, reg, val & ~bitval);\n}\n\n \nstatic int mv88e1xxx_reset(struct cphy *cphy, int wait)\n{\n\tu32 ctl;\n\tint time_out = 1000;\n\n\tmdio_set_bit(cphy, MII_BMCR, BMCR_RESET);\n\n\tdo {\n\t\t(void) simple_mdio_read(cphy, MII_BMCR, &ctl);\n\t\tctl &= BMCR_RESET;\n\t\tif (ctl)\n\t\t\tudelay(1);\n\t} while (ctl && --time_out);\n\n\treturn ctl ? -1 : 0;\n}\n\nstatic int mv88e1xxx_interrupt_enable(struct cphy *cphy)\n{\n\t \n\t(void) simple_mdio_write(cphy, MV88E1XXX_INTERRUPT_ENABLE_REGISTER,\n\t\t   INTR_ENABLE_MASK);\n\n\t \n\tif (t1_is_asic(cphy->adapter)) {\n\t\tu32 elmer;\n\n\t\tt1_tpi_read(cphy->adapter, A_ELMER0_INT_ENABLE, &elmer);\n\t\telmer |= ELMER0_GP_BIT1;\n\t\tif (is_T2(cphy->adapter))\n\t\t    elmer |= ELMER0_GP_BIT2 | ELMER0_GP_BIT3 | ELMER0_GP_BIT4;\n\t\tt1_tpi_write(cphy->adapter, A_ELMER0_INT_ENABLE, elmer);\n\t}\n\treturn 0;\n}\n\nstatic int mv88e1xxx_interrupt_disable(struct cphy *cphy)\n{\n\t \n\t(void) simple_mdio_write(cphy, MV88E1XXX_INTERRUPT_ENABLE_REGISTER, 0);\n\n\t \n\tif (t1_is_asic(cphy->adapter)) {\n\t\tu32 elmer;\n\n\t\tt1_tpi_read(cphy->adapter, A_ELMER0_INT_ENABLE, &elmer);\n\t\telmer &= ~ELMER0_GP_BIT1;\n\t\tif (is_T2(cphy->adapter))\n\t\t    elmer &= ~(ELMER0_GP_BIT2|ELMER0_GP_BIT3|ELMER0_GP_BIT4);\n\t\tt1_tpi_write(cphy->adapter, A_ELMER0_INT_ENABLE, elmer);\n\t}\n\treturn 0;\n}\n\nstatic int mv88e1xxx_interrupt_clear(struct cphy *cphy)\n{\n\tu32 elmer;\n\n\t \n\t(void) simple_mdio_read(cphy,\n\t\t\tMV88E1XXX_INTERRUPT_STATUS_REGISTER, &elmer);\n\n\t \n\tif (t1_is_asic(cphy->adapter)) {\n\t\tt1_tpi_read(cphy->adapter, A_ELMER0_INT_CAUSE, &elmer);\n\t\telmer |= ELMER0_GP_BIT1;\n\t\tif (is_T2(cphy->adapter))\n\t\t    elmer |= ELMER0_GP_BIT2|ELMER0_GP_BIT3|ELMER0_GP_BIT4;\n\t\tt1_tpi_write(cphy->adapter, A_ELMER0_INT_CAUSE, elmer);\n\t}\n\treturn 0;\n}\n\n \nstatic int mv88e1xxx_set_speed_duplex(struct cphy *phy, int speed, int duplex)\n{\n\tu32 ctl;\n\n\t(void) simple_mdio_read(phy, MII_BMCR, &ctl);\n\tif (speed >= 0) {\n\t\tctl &= ~(BMCR_SPEED100 | BMCR_SPEED1000 | BMCR_ANENABLE);\n\t\tif (speed == SPEED_100)\n\t\t\tctl |= BMCR_SPEED100;\n\t\telse if (speed == SPEED_1000)\n\t\t\tctl |= BMCR_SPEED1000;\n\t}\n\tif (duplex >= 0) {\n\t\tctl &= ~(BMCR_FULLDPLX | BMCR_ANENABLE);\n\t\tif (duplex == DUPLEX_FULL)\n\t\t\tctl |= BMCR_FULLDPLX;\n\t}\n\tif (ctl & BMCR_SPEED1000)   \n\t\tctl |= BMCR_ANENABLE;\n\t(void) simple_mdio_write(phy, MII_BMCR, ctl);\n\treturn 0;\n}\n\nstatic int mv88e1xxx_crossover_set(struct cphy *cphy, int crossover)\n{\n\tu32 data32;\n\n\t(void) simple_mdio_read(cphy,\n\t\t\tMV88E1XXX_SPECIFIC_CNTRL_REGISTER, &data32);\n\tdata32 &= ~V_PSCR_MDI_XOVER_MODE(M_PSCR_MDI_XOVER_MODE);\n\tdata32 |= V_PSCR_MDI_XOVER_MODE(crossover);\n\t(void) simple_mdio_write(cphy,\n\t\t\tMV88E1XXX_SPECIFIC_CNTRL_REGISTER, data32);\n\treturn 0;\n}\n\nstatic int mv88e1xxx_autoneg_enable(struct cphy *cphy)\n{\n\tu32 ctl;\n\n\t(void) mv88e1xxx_crossover_set(cphy, CROSSOVER_AUTO);\n\n\t(void) simple_mdio_read(cphy, MII_BMCR, &ctl);\n\t \n\tctl |= BMCR_ANENABLE | BMCR_ANRESTART;\n\t(void) simple_mdio_write(cphy, MII_BMCR, ctl);\n\treturn 0;\n}\n\nstatic int mv88e1xxx_autoneg_disable(struct cphy *cphy)\n{\n\tu32 ctl;\n\n\t \n\t(void) mv88e1xxx_crossover_set(cphy, CROSSOVER_MDI);\n\n\t \n\t(void) simple_mdio_read(cphy, MII_BMCR, &ctl);\n\tctl &= ~BMCR_ANENABLE;\n\t(void) simple_mdio_write(cphy, MII_BMCR, ctl | BMCR_ANRESTART);\n\treturn 0;\n}\n\nstatic int mv88e1xxx_autoneg_restart(struct cphy *cphy)\n{\n\tmdio_set_bit(cphy, MII_BMCR, BMCR_ANRESTART);\n\treturn 0;\n}\n\nstatic int mv88e1xxx_advertise(struct cphy *phy, unsigned int advertise_map)\n{\n\tu32 val = 0;\n\n\tif (advertise_map &\n\t    (ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full)) {\n\t\t(void) simple_mdio_read(phy, MII_GBCR, &val);\n\t\tval &= ~(GBCR_ADV_1000HALF | GBCR_ADV_1000FULL);\n\t\tif (advertise_map & ADVERTISED_1000baseT_Half)\n\t\t\tval |= GBCR_ADV_1000HALF;\n\t\tif (advertise_map & ADVERTISED_1000baseT_Full)\n\t\t\tval |= GBCR_ADV_1000FULL;\n\t}\n\t(void) simple_mdio_write(phy, MII_GBCR, val);\n\n\tval = 1;\n\tif (advertise_map & ADVERTISED_10baseT_Half)\n\t\tval |= ADVERTISE_10HALF;\n\tif (advertise_map & ADVERTISED_10baseT_Full)\n\t\tval |= ADVERTISE_10FULL;\n\tif (advertise_map & ADVERTISED_100baseT_Half)\n\t\tval |= ADVERTISE_100HALF;\n\tif (advertise_map & ADVERTISED_100baseT_Full)\n\t\tval |= ADVERTISE_100FULL;\n\tif (advertise_map & ADVERTISED_PAUSE)\n\t\tval |= ADVERTISE_PAUSE;\n\tif (advertise_map & ADVERTISED_ASYM_PAUSE)\n\t\tval |= ADVERTISE_PAUSE_ASYM;\n\t(void) simple_mdio_write(phy, MII_ADVERTISE, val);\n\treturn 0;\n}\n\nstatic int mv88e1xxx_set_loopback(struct cphy *cphy, int on)\n{\n\tif (on)\n\t\tmdio_set_bit(cphy, MII_BMCR, BMCR_LOOPBACK);\n\telse\n\t\tmdio_clear_bit(cphy, MII_BMCR, BMCR_LOOPBACK);\n\treturn 0;\n}\n\nstatic int mv88e1xxx_get_link_status(struct cphy *cphy, int *link_ok,\n\t\t\t\t     int *speed, int *duplex, int *fc)\n{\n\tu32 status;\n\tint sp = -1, dplx = -1, pause = 0;\n\n\t(void) simple_mdio_read(cphy,\n\t\t\tMV88E1XXX_SPECIFIC_STATUS_REGISTER, &status);\n\tif ((status & V_PSSR_STATUS_RESOLVED) != 0) {\n\t\tif (status & V_PSSR_RX_PAUSE)\n\t\t\tpause |= PAUSE_RX;\n\t\tif (status & V_PSSR_TX_PAUSE)\n\t\t\tpause |= PAUSE_TX;\n\t\tdplx = (status & V_PSSR_DUPLEX) ? DUPLEX_FULL : DUPLEX_HALF;\n\t\tsp = G_PSSR_SPEED(status);\n\t\tif (sp == 0)\n\t\t\tsp = SPEED_10;\n\t\telse if (sp == 1)\n\t\t\tsp = SPEED_100;\n\t\telse\n\t\t\tsp = SPEED_1000;\n\t}\n\tif (link_ok)\n\t\t*link_ok = (status & V_PSSR_LINK) != 0;\n\tif (speed)\n\t\t*speed = sp;\n\tif (duplex)\n\t\t*duplex = dplx;\n\tif (fc)\n\t\t*fc = pause;\n\treturn 0;\n}\n\nstatic int mv88e1xxx_downshift_set(struct cphy *cphy, int downshift_enable)\n{\n\tu32 val;\n\n\t(void) simple_mdio_read(cphy,\n\t\tMV88E1XXX_EXT_PHY_SPECIFIC_CNTRL_REGISTER, &val);\n\n\t \n\tval &= ~(V_DOWNSHIFT_ENABLE | V_DOWNSHIFT_CNT(M_DOWNSHIFT_CNT));\n\n\tif (downshift_enable)\n\t\tval |= V_DOWNSHIFT_ENABLE | V_DOWNSHIFT_CNT(2);\n\t(void) simple_mdio_write(cphy,\n\t\t\tMV88E1XXX_EXT_PHY_SPECIFIC_CNTRL_REGISTER, val);\n\treturn 0;\n}\n\nstatic int mv88e1xxx_interrupt_handler(struct cphy *cphy)\n{\n\tint cphy_cause = 0;\n\tu32 status;\n\n\t \n\twhile (1) {\n\t\tu32 cause;\n\n\t\t(void) simple_mdio_read(cphy,\n\t\t\t\tMV88E1XXX_INTERRUPT_STATUS_REGISTER,\n\t\t\t\t&cause);\n\t\tcause &= INTR_ENABLE_MASK;\n\t\tif (!cause)\n\t\t\tbreak;\n\n\t\tif (cause & MV88E1XXX_INTR_LINK_CHNG) {\n\t\t\t(void) simple_mdio_read(cphy,\n\t\t\t\tMV88E1XXX_SPECIFIC_STATUS_REGISTER, &status);\n\n\t\t\tif (status & MV88E1XXX_INTR_LINK_CHNG)\n\t\t\t\tcphy->state |= PHY_LINK_UP;\n\t\t\telse {\n\t\t\t\tcphy->state &= ~PHY_LINK_UP;\n\t\t\t\tif (cphy->state & PHY_AUTONEG_EN)\n\t\t\t\t\tcphy->state &= ~PHY_AUTONEG_RDY;\n\t\t\t\tcphy_cause |= cphy_cause_link_change;\n\t\t\t}\n\t\t}\n\n\t\tif (cause & MV88E1XXX_INTR_AUTONEG_DONE)\n\t\t\tcphy->state |= PHY_AUTONEG_RDY;\n\n\t\tif ((cphy->state & (PHY_LINK_UP | PHY_AUTONEG_RDY)) ==\n\t\t\t(PHY_LINK_UP | PHY_AUTONEG_RDY))\n\t\t\t\tcphy_cause |= cphy_cause_link_change;\n\t}\n\treturn cphy_cause;\n}\n\nstatic void mv88e1xxx_destroy(struct cphy *cphy)\n{\n\tkfree(cphy);\n}\n\nstatic const struct cphy_ops mv88e1xxx_ops = {\n\t.destroy              = mv88e1xxx_destroy,\n\t.reset                = mv88e1xxx_reset,\n\t.interrupt_enable     = mv88e1xxx_interrupt_enable,\n\t.interrupt_disable    = mv88e1xxx_interrupt_disable,\n\t.interrupt_clear      = mv88e1xxx_interrupt_clear,\n\t.interrupt_handler    = mv88e1xxx_interrupt_handler,\n\t.autoneg_enable       = mv88e1xxx_autoneg_enable,\n\t.autoneg_disable      = mv88e1xxx_autoneg_disable,\n\t.autoneg_restart      = mv88e1xxx_autoneg_restart,\n\t.advertise            = mv88e1xxx_advertise,\n\t.set_loopback         = mv88e1xxx_set_loopback,\n\t.set_speed_duplex     = mv88e1xxx_set_speed_duplex,\n\t.get_link_status      = mv88e1xxx_get_link_status,\n};\n\nstatic struct cphy *mv88e1xxx_phy_create(struct net_device *dev, int phy_addr,\n\t\t\t\t\t const struct mdio_ops *mdio_ops)\n{\n\tstruct adapter *adapter = netdev_priv(dev);\n\tstruct cphy *cphy = kzalloc(sizeof(*cphy), GFP_KERNEL);\n\n\tif (!cphy)\n\t\treturn NULL;\n\n\tcphy_init(cphy, dev, phy_addr, &mv88e1xxx_ops, mdio_ops);\n\n\t \n\tif ((board_info(adapter)->caps & SUPPORTED_TP) &&\n\t    board_info(adapter)->chip_phy == CHBT_PHY_88E1111) {\n\t\t \n\t\t(void) simple_mdio_write(cphy,\n\t\t\t\tMV88E1XXX_EXTENDED_ADDR_REGISTER, 0xB);\n\t\t(void) simple_mdio_write(cphy,\n\t\t\t\tMV88E1XXX_EXTENDED_REGISTER, 0x8004);\n\t}\n\t(void) mv88e1xxx_downshift_set(cphy, 1);    \n\n\t \n\tif (is_T2(adapter)) {\n\t\t(void) simple_mdio_write(cphy,\n\t\t\t\tMV88E1XXX_LED_CONTROL_REGISTER, 0x1);\n\t}\n\n\treturn cphy;\n}\n\nstatic int mv88e1xxx_phy_reset(adapter_t* adapter)\n{\n\treturn 0;\n}\n\nconst struct gphy t1_mv88e1xxx_ops = {\n\t.create = mv88e1xxx_phy_create,\n\t.reset =  mv88e1xxx_phy_reset\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}