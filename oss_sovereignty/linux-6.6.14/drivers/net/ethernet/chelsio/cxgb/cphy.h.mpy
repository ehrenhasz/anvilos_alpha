{
  "module_name": "cphy.h",
  "hash_id": "4bdc37eae6ea1e6083905268823bc9a4b2b3a51f63ece6e626bd0050cbf0d74b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb/cphy.h",
  "human_readable_source": " \n \n\n#ifndef _CXGB_CPHY_H_\n#define _CXGB_CPHY_H_\n\n#include \"common.h\"\n\nstruct mdio_ops {\n\tvoid (*init)(adapter_t *adapter, const struct board_info *bi);\n\tint  (*read)(struct net_device *dev, int phy_addr, int mmd_addr,\n\t\t     u16 reg_addr);\n\tint  (*write)(struct net_device *dev, int phy_addr, int mmd_addr,\n\t\t      u16 reg_addr, u16 val);\n\tunsigned mode_support;\n};\n\n \nenum {\n\tcphy_cause_link_change = 0x1,\n\tcphy_cause_error = 0x2,\n\tcphy_cause_fifo_error = 0x3\n};\n\nenum {\n\tPHY_LINK_UP = 0x1,\n\tPHY_AUTONEG_RDY = 0x2,\n\tPHY_AUTONEG_EN = 0x4\n};\n\nstruct cphy;\n\n \nstruct cphy_ops {\n\tvoid (*destroy)(struct cphy *);\n\tint (*reset)(struct cphy *, int wait);\n\n\tint (*interrupt_enable)(struct cphy *);\n\tint (*interrupt_disable)(struct cphy *);\n\tint (*interrupt_clear)(struct cphy *);\n\tint (*interrupt_handler)(struct cphy *);\n\n\tint (*autoneg_enable)(struct cphy *);\n\tint (*autoneg_disable)(struct cphy *);\n\tint (*autoneg_restart)(struct cphy *);\n\n\tint (*advertise)(struct cphy *phy, unsigned int advertise_map);\n\tint (*set_loopback)(struct cphy *, int on);\n\tint (*set_speed_duplex)(struct cphy *phy, int speed, int duplex);\n\tint (*get_link_status)(struct cphy *phy, int *link_ok, int *speed,\n\t\t\t       int *duplex, int *fc);\n\n\tu32 mmds;\n};\n\n \nstruct cphy {\n\tint state;\t \n\tadapter_t *adapter;                   \n\n\tstruct delayed_work phy_update;\n\n\tu16 bmsr;\n\tint count;\n\tint act_count;\n\tint act_on;\n\n\tu32 elmer_gpo;\n\n\tconst struct cphy_ops *ops;             \n\tstruct mdio_if_info mdio;\n\tstruct cphy_instance *instance;\n};\n\n \nstatic inline int cphy_mdio_read(struct cphy *cphy, int mmd, int reg,\n\t\t\t\t unsigned int *valp)\n{\n\tint rc = cphy->mdio.mdio_read(cphy->mdio.dev, cphy->mdio.prtad, mmd,\n\t\t\t\t      reg);\n\t*valp = (rc >= 0) ? rc : -1;\n\treturn (rc >= 0) ? 0 : rc;\n}\n\nstatic inline int cphy_mdio_write(struct cphy *cphy, int mmd, int reg,\n\t\t\t\t  unsigned int val)\n{\n\treturn cphy->mdio.mdio_write(cphy->mdio.dev, cphy->mdio.prtad, mmd,\n\t\t\t\t     reg, val);\n}\n\nstatic inline int simple_mdio_read(struct cphy *cphy, int reg,\n\t\t\t\t   unsigned int *valp)\n{\n\treturn cphy_mdio_read(cphy, MDIO_DEVAD_NONE, reg, valp);\n}\n\nstatic inline int simple_mdio_write(struct cphy *cphy, int reg,\n\t\t\t\t    unsigned int val)\n{\n\treturn cphy_mdio_write(cphy, MDIO_DEVAD_NONE, reg, val);\n}\n\n \nstatic inline void cphy_init(struct cphy *phy, struct net_device *dev,\n\t\t\t     int phy_addr, const struct cphy_ops *phy_ops,\n\t\t\t     const struct mdio_ops *mdio_ops)\n{\n\tstruct adapter *adapter = netdev_priv(dev);\n\tphy->adapter = adapter;\n\tphy->ops     = phy_ops;\n\tif (mdio_ops) {\n\t\tphy->mdio.prtad = phy_addr;\n\t\tphy->mdio.mmds = phy_ops->mmds;\n\t\tphy->mdio.mode_support = mdio_ops->mode_support;\n\t\tphy->mdio.mdio_read = mdio_ops->read;\n\t\tphy->mdio.mdio_write = mdio_ops->write;\n\t}\n\tphy->mdio.dev = dev;\n}\n\n \nstruct gphy {\n\t \n\tstruct cphy *(*create)(struct net_device *dev, int phy_addr,\n\t\t\t       const struct mdio_ops *mdio_ops);\n\n\t \n\tint (*reset)(adapter_t *adapter);\n};\n\nextern const struct gphy t1_my3126_ops;\nextern const struct gphy t1_mv88e1xxx_ops;\nextern const struct gphy t1_vsc8244_ops;\nextern const struct gphy t1_mv88x201x_ops;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}