{
  "module_name": "subr.c",
  "hash_id": "a876bdd892b68464e20ac375995894ffe527368fec7f8b76529a1653fa2626eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb/subr.c",
  "human_readable_source": "\n \n\n#include \"common.h\"\n#include \"elmer0.h\"\n#include \"regs.h\"\n#include \"gmac.h\"\n#include \"cphy.h\"\n#include \"sge.h\"\n#include \"tp.h\"\n#include \"espi.h\"\n\n \nstatic int t1_wait_op_done(adapter_t *adapter, int reg, u32 mask, int polarity,\n\t\t\t   int attempts, int delay)\n{\n\twhile (1) {\n\t\tu32 val = readl(adapter->regs + reg) & mask;\n\n\t\tif (!!val == polarity)\n\t\t\treturn 0;\n\t\tif (--attempts == 0)\n\t\t\treturn 1;\n\t\tif (delay)\n\t\t\tudelay(delay);\n\t}\n}\n\n#define TPI_ATTEMPTS 50\n\n \nint __t1_tpi_write(adapter_t *adapter, u32 addr, u32 value)\n{\n\tint tpi_busy;\n\n\twritel(addr, adapter->regs + A_TPI_ADDR);\n\twritel(value, adapter->regs + A_TPI_WR_DATA);\n\twritel(F_TPIWR, adapter->regs + A_TPI_CSR);\n\n\ttpi_busy = t1_wait_op_done(adapter, A_TPI_CSR, F_TPIRDY, 1,\n\t\t\t\t   TPI_ATTEMPTS, 3);\n\tif (tpi_busy)\n\t\tpr_alert(\"%s: TPI write to 0x%x failed\\n\",\n\t\t\t adapter->name, addr);\n\treturn tpi_busy;\n}\n\nint t1_tpi_write(adapter_t *adapter, u32 addr, u32 value)\n{\n\tint ret;\n\n\tspin_lock(&adapter->tpi_lock);\n\tret = __t1_tpi_write(adapter, addr, value);\n\tspin_unlock(&adapter->tpi_lock);\n\treturn ret;\n}\n\n \nint __t1_tpi_read(adapter_t *adapter, u32 addr, u32 *valp)\n{\n\tint tpi_busy;\n\n\twritel(addr, adapter->regs + A_TPI_ADDR);\n\twritel(0, adapter->regs + A_TPI_CSR);\n\n\ttpi_busy = t1_wait_op_done(adapter, A_TPI_CSR, F_TPIRDY, 1,\n\t\t\t\t   TPI_ATTEMPTS, 3);\n\tif (tpi_busy)\n\t\tpr_alert(\"%s: TPI read from 0x%x failed\\n\",\n\t\t\t adapter->name, addr);\n\telse\n\t\t*valp = readl(adapter->regs + A_TPI_RD_DATA);\n\treturn tpi_busy;\n}\n\nint t1_tpi_read(adapter_t *adapter, u32 addr, u32 *valp)\n{\n\tint ret;\n\n\tspin_lock(&adapter->tpi_lock);\n\tret = __t1_tpi_read(adapter, addr, valp);\n\tspin_unlock(&adapter->tpi_lock);\n\treturn ret;\n}\n\n \nstatic void t1_tpi_par(adapter_t *adapter, u32 value)\n{\n\twritel(V_TPIPAR(value), adapter->regs + A_TPI_PAR);\n}\n\n \nvoid t1_link_changed(adapter_t *adapter, int port_id)\n{\n\tint link_ok, speed, duplex, fc;\n\tstruct cphy *phy = adapter->port[port_id].phy;\n\tstruct link_config *lc = &adapter->port[port_id].link_config;\n\n\tphy->ops->get_link_status(phy, &link_ok, &speed, &duplex, &fc);\n\n\tlc->speed = speed < 0 ? SPEED_INVALID : speed;\n\tlc->duplex = duplex < 0 ? DUPLEX_INVALID : duplex;\n\tif (!(lc->requested_fc & PAUSE_AUTONEG))\n\t\tfc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);\n\n\tif (link_ok && speed >= 0 && lc->autoneg == AUTONEG_ENABLE) {\n\t\t \n\t\tstruct cmac *mac = adapter->port[port_id].mac;\n\n\t\tmac->ops->set_speed_duplex_fc(mac, speed, duplex, fc);\n\t\tlc->fc = (unsigned char)fc;\n\t}\n\tt1_link_negotiated(adapter, port_id, link_ok, speed, duplex, fc);\n}\n\nstatic bool t1_pci_intr_handler(adapter_t *adapter)\n{\n\tu32 pcix_cause;\n\n\tpci_read_config_dword(adapter->pdev, A_PCICFG_INTR_CAUSE, &pcix_cause);\n\n\tif (pcix_cause) {\n\t\tpci_write_config_dword(adapter->pdev, A_PCICFG_INTR_CAUSE,\n\t\t\t\t       pcix_cause);\n\t\t \n\t\tt1_interrupts_disable(adapter);\n\t\tadapter->pending_thread_intr |= F_PL_INTR_SGE_ERR;\n\t\tpr_alert(\"%s: PCI error encountered.\\n\", adapter->name);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n#ifdef CONFIG_CHELSIO_T1_1G\n#include \"fpga_defs.h\"\n\n \nstatic int fpga_phy_intr_handler(adapter_t *adapter)\n{\n\tint p;\n\tu32 cause = readl(adapter->regs + FPGA_GMAC_ADDR_INTERRUPT_CAUSE);\n\n\tfor_each_port(adapter, p)\n\t\tif (cause & (1 << p)) {\n\t\t\tstruct cphy *phy = adapter->port[p].phy;\n\t\t\tint phy_cause = phy->ops->interrupt_handler(phy);\n\n\t\t\tif (phy_cause & cphy_cause_link_change)\n\t\t\t\tt1_link_changed(adapter, p);\n\t\t}\n\twritel(cause, adapter->regs + FPGA_GMAC_ADDR_INTERRUPT_CAUSE);\n\treturn 0;\n}\n\n \nstatic irqreturn_t fpga_slow_intr(adapter_t *adapter)\n{\n\tu32 cause = readl(adapter->regs + A_PL_CAUSE);\n\tirqreturn_t ret = IRQ_NONE;\n\n\tcause &= ~F_PL_INTR_SGE_DATA;\n\tif (cause & F_PL_INTR_SGE_ERR) {\n\t\tif (t1_sge_intr_error_handler(adapter->sge))\n\t\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\tif (cause & FPGA_PCIX_INTERRUPT_GMAC)\n\t\tfpga_phy_intr_handler(adapter);\n\n\tif (cause & FPGA_PCIX_INTERRUPT_TP) {\n\t\t \n\t\tu32 tp_cause = readl(adapter->regs + FPGA_TP_ADDR_INTERRUPT_CAUSE);\n\n\t\t \n\t\twritel(tp_cause, adapter->regs + FPGA_TP_ADDR_INTERRUPT_CAUSE);\n\t}\n\tif (cause & FPGA_PCIX_INTERRUPT_PCIX) {\n\t\tif (t1_pci_intr_handler(adapter))\n\t\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\t \n\tif (cause)\n\t\twritel(cause, adapter->regs + A_PL_CAUSE);\n\n\tif (ret != IRQ_NONE)\n\t\treturn ret;\n\n\treturn cause == 0 ? IRQ_NONE : IRQ_HANDLED;\n}\n#endif\n\n \nstatic int mi1_wait_until_ready(adapter_t *adapter, int mi1_reg)\n{\n\tint attempts = 100, busy;\n\n\tdo {\n\t\tu32 val;\n\n\t\t__t1_tpi_read(adapter, mi1_reg, &val);\n\t\tbusy = val & F_MI1_OP_BUSY;\n\t\tif (busy)\n\t\t\tudelay(10);\n\t} while (busy && --attempts);\n\tif (busy)\n\t\tpr_alert(\"%s: MDIO operation timed out\\n\", adapter->name);\n\treturn busy;\n}\n\n \nstatic void mi1_mdio_init(adapter_t *adapter, const struct board_info *bi)\n{\n\tu32 clkdiv = bi->clock_elmer0 / (2 * bi->mdio_mdc) - 1;\n\tu32 val = F_MI1_PREAMBLE_ENABLE | V_MI1_MDI_INVERT(bi->mdio_mdiinv) |\n\t\tV_MI1_MDI_ENABLE(bi->mdio_mdien) | V_MI1_CLK_DIV(clkdiv);\n\n\tif (!(bi->caps & SUPPORTED_10000baseT_Full))\n\t\tval |= V_MI1_SOF(1);\n\tt1_tpi_write(adapter, A_ELMER0_PORT0_MI1_CFG, val);\n}\n\n#if defined(CONFIG_CHELSIO_T1_1G)\n \nstatic int mi1_mdio_read(struct net_device *dev, int phy_addr, int mmd_addr,\n\t\t\t u16 reg_addr)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tu32 addr = V_MI1_REG_ADDR(reg_addr) | V_MI1_PHY_ADDR(phy_addr);\n\tunsigned int val;\n\n\tspin_lock(&adapter->tpi_lock);\n\t__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_ADDR, addr);\n\t__t1_tpi_write(adapter,\n\t\t\tA_ELMER0_PORT0_MI1_OP, MI1_OP_DIRECT_READ);\n\tmi1_wait_until_ready(adapter, A_ELMER0_PORT0_MI1_OP);\n\t__t1_tpi_read(adapter, A_ELMER0_PORT0_MI1_DATA, &val);\n\tspin_unlock(&adapter->tpi_lock);\n\treturn val;\n}\n\nstatic int mi1_mdio_write(struct net_device *dev, int phy_addr, int mmd_addr,\n\t\t\t  u16 reg_addr, u16 val)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tu32 addr = V_MI1_REG_ADDR(reg_addr) | V_MI1_PHY_ADDR(phy_addr);\n\n\tspin_lock(&adapter->tpi_lock);\n\t__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_ADDR, addr);\n\t__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_DATA, val);\n\t__t1_tpi_write(adapter,\n\t\t\tA_ELMER0_PORT0_MI1_OP, MI1_OP_DIRECT_WRITE);\n\tmi1_wait_until_ready(adapter, A_ELMER0_PORT0_MI1_OP);\n\tspin_unlock(&adapter->tpi_lock);\n\treturn 0;\n}\n\nstatic const struct mdio_ops mi1_mdio_ops = {\n\t.init = mi1_mdio_init,\n\t.read = mi1_mdio_read,\n\t.write = mi1_mdio_write,\n\t.mode_support = MDIO_SUPPORTS_C22\n};\n\n#endif\n\nstatic int mi1_mdio_ext_read(struct net_device *dev, int phy_addr, int mmd_addr,\n\t\t\t     u16 reg_addr)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tu32 addr = V_MI1_REG_ADDR(mmd_addr) | V_MI1_PHY_ADDR(phy_addr);\n\tunsigned int val;\n\n\tspin_lock(&adapter->tpi_lock);\n\n\t \n\t__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_ADDR, addr);\n\t__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_DATA, reg_addr);\n\t__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_OP,\n\t\t       MI1_OP_INDIRECT_ADDRESS);\n\tmi1_wait_until_ready(adapter, A_ELMER0_PORT0_MI1_OP);\n\n\t \n\t__t1_tpi_write(adapter,\n\t\t\tA_ELMER0_PORT0_MI1_OP, MI1_OP_INDIRECT_READ);\n\tmi1_wait_until_ready(adapter, A_ELMER0_PORT0_MI1_OP);\n\n\t \n\t__t1_tpi_read(adapter, A_ELMER0_PORT0_MI1_DATA, &val);\n\tspin_unlock(&adapter->tpi_lock);\n\treturn val;\n}\n\nstatic int mi1_mdio_ext_write(struct net_device *dev, int phy_addr,\n\t\t\t      int mmd_addr, u16 reg_addr, u16 val)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tu32 addr = V_MI1_REG_ADDR(mmd_addr) | V_MI1_PHY_ADDR(phy_addr);\n\n\tspin_lock(&adapter->tpi_lock);\n\n\t \n\t__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_ADDR, addr);\n\t__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_DATA, reg_addr);\n\t__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_OP,\n\t\t       MI1_OP_INDIRECT_ADDRESS);\n\tmi1_wait_until_ready(adapter, A_ELMER0_PORT0_MI1_OP);\n\n\t \n\t__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_DATA, val);\n\t__t1_tpi_write(adapter, A_ELMER0_PORT0_MI1_OP, MI1_OP_INDIRECT_WRITE);\n\tmi1_wait_until_ready(adapter, A_ELMER0_PORT0_MI1_OP);\n\tspin_unlock(&adapter->tpi_lock);\n\treturn 0;\n}\n\nstatic const struct mdio_ops mi1_mdio_ext_ops = {\n\t.init = mi1_mdio_init,\n\t.read = mi1_mdio_ext_read,\n\t.write = mi1_mdio_ext_write,\n\t.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22\n};\n\nenum {\n\tCH_BRD_T110_1CU,\n\tCH_BRD_N110_1F,\n\tCH_BRD_N210_1F,\n\tCH_BRD_T210_1F,\n\tCH_BRD_T210_1CU,\n\tCH_BRD_N204_4CU,\n};\n\nstatic const struct board_info t1_board[] = {\n\t{\n\t\t.board\t\t= CHBT_BOARD_CHT110,\n\t\t.port_number\t= 1,\n\t\t.caps\t\t= SUPPORTED_10000baseT_Full,\n\t\t.chip_term\t= CHBT_TERM_T1,\n\t\t.chip_mac\t= CHBT_MAC_PM3393,\n\t\t.chip_phy\t= CHBT_PHY_MY3126,\n\t\t.clock_core\t= 125000000,\n\t\t.clock_mc3\t= 150000000,\n\t\t.clock_mc4\t= 125000000,\n\t\t.espi_nports\t= 1,\n\t\t.clock_elmer0\t= 44,\n\t\t.mdio_mdien\t= 1,\n\t\t.mdio_mdiinv\t= 1,\n\t\t.mdio_mdc\t= 1,\n\t\t.mdio_phybaseaddr = 1,\n\t\t.gmac\t\t= &t1_pm3393_ops,\n\t\t.gphy\t\t= &t1_my3126_ops,\n\t\t.mdio_ops\t= &mi1_mdio_ext_ops,\n\t\t.desc\t\t= \"Chelsio T110 1x10GBase-CX4 TOE\",\n\t},\n\n\t{\n\t\t.board\t\t= CHBT_BOARD_N110,\n\t\t.port_number\t= 1,\n\t\t.caps\t\t= SUPPORTED_10000baseT_Full | SUPPORTED_FIBRE,\n\t\t.chip_term\t= CHBT_TERM_T1,\n\t\t.chip_mac\t= CHBT_MAC_PM3393,\n\t\t.chip_phy\t= CHBT_PHY_88X2010,\n\t\t.clock_core\t= 125000000,\n\t\t.espi_nports\t= 1,\n\t\t.clock_elmer0\t= 44,\n\t\t.mdio_mdien\t= 0,\n\t\t.mdio_mdiinv\t= 0,\n\t\t.mdio_mdc\t= 1,\n\t\t.mdio_phybaseaddr = 0,\n\t\t.gmac\t\t= &t1_pm3393_ops,\n\t\t.gphy\t\t= &t1_mv88x201x_ops,\n\t\t.mdio_ops\t= &mi1_mdio_ext_ops,\n\t\t.desc\t\t= \"Chelsio N110 1x10GBaseX NIC\",\n\t},\n\n\t{\n\t\t.board\t\t= CHBT_BOARD_N210,\n\t\t.port_number\t= 1,\n\t\t.caps\t\t= SUPPORTED_10000baseT_Full | SUPPORTED_FIBRE,\n\t\t.chip_term\t= CHBT_TERM_T2,\n\t\t.chip_mac\t= CHBT_MAC_PM3393,\n\t\t.chip_phy\t= CHBT_PHY_88X2010,\n\t\t.clock_core\t= 125000000,\n\t\t.espi_nports\t= 1,\n\t\t.clock_elmer0\t= 44,\n\t\t.mdio_mdien\t= 0,\n\t\t.mdio_mdiinv\t= 0,\n\t\t.mdio_mdc\t= 1,\n\t\t.mdio_phybaseaddr = 0,\n\t\t.gmac\t\t= &t1_pm3393_ops,\n\t\t.gphy\t\t= &t1_mv88x201x_ops,\n\t\t.mdio_ops\t= &mi1_mdio_ext_ops,\n\t\t.desc\t\t= \"Chelsio N210 1x10GBaseX NIC\",\n\t},\n\n\t{\n\t\t.board\t\t= CHBT_BOARD_CHT210,\n\t\t.port_number\t= 1,\n\t\t.caps\t\t= SUPPORTED_10000baseT_Full,\n\t\t.chip_term\t= CHBT_TERM_T2,\n\t\t.chip_mac\t= CHBT_MAC_PM3393,\n\t\t.chip_phy\t= CHBT_PHY_88X2010,\n\t\t.clock_core\t= 125000000,\n\t\t.clock_mc3\t= 133000000,\n\t\t.clock_mc4\t= 125000000,\n\t\t.espi_nports\t= 1,\n\t\t.clock_elmer0\t= 44,\n\t\t.mdio_mdien\t= 0,\n\t\t.mdio_mdiinv\t= 0,\n\t\t.mdio_mdc\t= 1,\n\t\t.mdio_phybaseaddr = 0,\n\t\t.gmac\t\t= &t1_pm3393_ops,\n\t\t.gphy\t\t= &t1_mv88x201x_ops,\n\t\t.mdio_ops\t= &mi1_mdio_ext_ops,\n\t\t.desc\t\t= \"Chelsio T210 1x10GBaseX TOE\",\n\t},\n\n\t{\n\t\t.board\t\t= CHBT_BOARD_CHT210,\n\t\t.port_number\t= 1,\n\t\t.caps\t\t= SUPPORTED_10000baseT_Full,\n\t\t.chip_term\t= CHBT_TERM_T2,\n\t\t.chip_mac\t= CHBT_MAC_PM3393,\n\t\t.chip_phy\t= CHBT_PHY_MY3126,\n\t\t.clock_core\t= 125000000,\n\t\t.clock_mc3\t= 133000000,\n\t\t.clock_mc4\t= 125000000,\n\t\t.espi_nports\t= 1,\n\t\t.clock_elmer0\t= 44,\n\t\t.mdio_mdien\t= 1,\n\t\t.mdio_mdiinv\t= 1,\n\t\t.mdio_mdc\t= 1,\n\t\t.mdio_phybaseaddr = 1,\n\t\t.gmac\t\t= &t1_pm3393_ops,\n\t\t.gphy\t\t= &t1_my3126_ops,\n\t\t.mdio_ops\t= &mi1_mdio_ext_ops,\n\t\t.desc\t\t= \"Chelsio T210 1x10GBase-CX4 TOE\",\n\t},\n\n#ifdef CONFIG_CHELSIO_T1_1G\n\t{\n\t\t.board\t\t= CHBT_BOARD_CHN204,\n\t\t.port_number\t= 4,\n\t\t.caps\t\t= SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full\n\t\t\t\t| SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full\n\t\t\t\t| SUPPORTED_1000baseT_Full | SUPPORTED_Autoneg |\n\t\t\t\t  SUPPORTED_PAUSE | SUPPORTED_TP,\n\t\t.chip_term\t= CHBT_TERM_T2,\n\t\t.chip_mac\t= CHBT_MAC_VSC7321,\n\t\t.chip_phy\t= CHBT_PHY_88E1111,\n\t\t.clock_core\t= 100000000,\n\t\t.espi_nports\t= 4,\n\t\t.clock_elmer0\t= 44,\n\t\t.mdio_mdien\t= 0,\n\t\t.mdio_mdiinv\t= 0,\n\t\t.mdio_mdc\t= 0,\n\t\t.mdio_phybaseaddr = 4,\n\t\t.gmac\t\t= &t1_vsc7326_ops,\n\t\t.gphy\t\t= &t1_mv88e1xxx_ops,\n\t\t.mdio_ops\t= &mi1_mdio_ops,\n\t\t.desc\t\t= \"Chelsio N204 4x100/1000BaseT NIC\",\n\t},\n#endif\n\n};\n\nconst struct pci_device_id t1_pci_tbl[] = {\n\tCH_DEVICE(8, 0, CH_BRD_T110_1CU),\n\tCH_DEVICE(8, 1, CH_BRD_T110_1CU),\n\tCH_DEVICE(7, 0, CH_BRD_N110_1F),\n\tCH_DEVICE(10, 1, CH_BRD_N210_1F),\n\tCH_DEVICE(11, 1, CH_BRD_T210_1F),\n\tCH_DEVICE(14, 1, CH_BRD_T210_1CU),\n\tCH_DEVICE(16, 1, CH_BRD_N204_4CU),\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(pci, t1_pci_tbl);\n\n \nconst struct board_info *t1_get_board_info(unsigned int board_id)\n{\n\treturn board_id < ARRAY_SIZE(t1_board) ? &t1_board[board_id] : NULL;\n}\n\nstruct chelsio_vpd_t {\n\tu32 format_version;\n\tu8 serial_number[16];\n\tu8 mac_base_address[6];\n\tu8 pad[2];            \n};\n\n#define EEPROMSIZE        (8 * 1024)\n#define EEPROM_MAX_POLL   4\n\n \nint t1_seeprom_read(adapter_t *adapter, u32 addr, __le32 *data)\n{\n\tint i = EEPROM_MAX_POLL;\n\tu16 val;\n\tu32 v;\n\n\tif (addr >= EEPROMSIZE || (addr & 3))\n\t\treturn -EINVAL;\n\n\tpci_write_config_word(adapter->pdev, A_PCICFG_VPD_ADDR, (u16)addr);\n\tdo {\n\t\tudelay(50);\n\t\tpci_read_config_word(adapter->pdev, A_PCICFG_VPD_ADDR, &val);\n\t} while (!(val & F_VPD_OP_FLAG) && --i);\n\n\tif (!(val & F_VPD_OP_FLAG)) {\n\t\tpr_err(\"%s: reading EEPROM address 0x%x failed\\n\",\n\t\t       adapter->name, addr);\n\t\treturn -EIO;\n\t}\n\tpci_read_config_dword(adapter->pdev, A_PCICFG_VPD_DATA, &v);\n\t*data = cpu_to_le32(v);\n\treturn 0;\n}\n\nstatic int t1_eeprom_vpd_get(adapter_t *adapter, struct chelsio_vpd_t *vpd)\n{\n\tint addr, ret = 0;\n\n\tfor (addr = 0; !ret && addr < sizeof(*vpd); addr += sizeof(u32))\n\t\tret = t1_seeprom_read(adapter, addr,\n\t\t\t\t      (__le32 *)((u8 *)vpd + addr));\n\n\treturn ret;\n}\n\n \nstatic int vpd_macaddress_get(adapter_t *adapter, int index, u8 mac_addr[])\n{\n\tstruct chelsio_vpd_t vpd;\n\n\tif (t1_eeprom_vpd_get(adapter, &vpd))\n\t\treturn 1;\n\tmemcpy(mac_addr, vpd.mac_base_address, 5);\n\tmac_addr[5] = vpd.mac_base_address[5] + index;\n\treturn 0;\n}\n\n \nint t1_link_start(struct cphy *phy, struct cmac *mac, struct link_config *lc)\n{\n\tunsigned int fc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);\n\n\tif (lc->supported & SUPPORTED_Autoneg) {\n\t\tlc->advertising &= ~(ADVERTISED_ASYM_PAUSE | ADVERTISED_PAUSE);\n\t\tif (fc) {\n\t\t\tif (fc == ((PAUSE_RX | PAUSE_TX) &\n\t\t\t\t   (mac->adapter->params.nports < 2)))\n\t\t\t\tlc->advertising |= ADVERTISED_PAUSE;\n\t\t\telse {\n\t\t\t\tlc->advertising |= ADVERTISED_ASYM_PAUSE;\n\t\t\t\tif (fc == PAUSE_RX)\n\t\t\t\t\tlc->advertising |= ADVERTISED_PAUSE;\n\t\t\t}\n\t\t}\n\t\tphy->ops->advertise(phy, lc->advertising);\n\n\t\tif (lc->autoneg == AUTONEG_DISABLE) {\n\t\t\tlc->speed = lc->requested_speed;\n\t\t\tlc->duplex = lc->requested_duplex;\n\t\t\tlc->fc = (unsigned char)fc;\n\t\t\tmac->ops->set_speed_duplex_fc(mac, lc->speed,\n\t\t\t\t\t\t      lc->duplex, fc);\n\t\t\t \n\t\t\tphy->state = PHY_AUTONEG_RDY;\n\t\t\tphy->ops->set_speed_duplex(phy, lc->speed, lc->duplex);\n\t\t\tphy->ops->reset(phy, 0);\n\t\t} else {\n\t\t\tphy->state = PHY_AUTONEG_EN;\n\t\t\tphy->ops->autoneg_enable(phy);  \n\t\t}\n\t} else {\n\t\tphy->state = PHY_AUTONEG_RDY;\n\t\tmac->ops->set_speed_duplex_fc(mac, -1, -1, fc);\n\t\tlc->fc = (unsigned char)fc;\n\t\tphy->ops->reset(phy, 0);\n\t}\n\treturn 0;\n}\n\n \nint t1_elmer0_ext_intr_handler(adapter_t *adapter)\n{\n\tstruct cphy *phy;\n\tint phy_cause;\n\tu32 cause;\n\n\tt1_tpi_read(adapter, A_ELMER0_INT_CAUSE, &cause);\n\n\tswitch (board_info(adapter)->board) {\n#ifdef CONFIG_CHELSIO_T1_1G\n\tcase CHBT_BOARD_CHT204:\n\tcase CHBT_BOARD_CHT204E:\n\tcase CHBT_BOARD_CHN204:\n\tcase CHBT_BOARD_CHT204V: {\n\t\tint i, port_bit;\n\t\tfor_each_port(adapter, i) {\n\t\t\tport_bit = i + 1;\n\t\t\tif (!(cause & (1 << port_bit)))\n\t\t\t\tcontinue;\n\n\t\t\tphy = adapter->port[i].phy;\n\t\t\tphy_cause = phy->ops->interrupt_handler(phy);\n\t\t\tif (phy_cause & cphy_cause_link_change)\n\t\t\t\tt1_link_changed(adapter, i);\n\t\t}\n\t\tbreak;\n\t}\n\tcase CHBT_BOARD_CHT101:\n\t\tif (cause & ELMER0_GP_BIT1) {  \n\t\t\tphy = adapter->port[0].phy;\n\t\t\tphy_cause = phy->ops->interrupt_handler(phy);\n\t\t\tif (phy_cause & cphy_cause_link_change)\n\t\t\t\tt1_link_changed(adapter, 0);\n\t\t}\n\t\tbreak;\n\tcase CHBT_BOARD_7500: {\n\t\tint p;\n\t\t \n\t\tfor_each_port(adapter, p) {\n\t\t\tphy = adapter->port[p].phy;\n\t\t\tphy_cause = phy->ops->interrupt_handler(phy);\n\t\t\tif (phy_cause & cphy_cause_link_change)\n\t\t\t    t1_link_changed(adapter, p);\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\tcase CHBT_BOARD_CHT210:\n\tcase CHBT_BOARD_N210:\n\tcase CHBT_BOARD_N110:\n\t\tif (cause & ELMER0_GP_BIT6) {  \n\t\t\tphy = adapter->port[0].phy;\n\t\t\tphy_cause = phy->ops->interrupt_handler(phy);\n\t\t\tif (phy_cause & cphy_cause_link_change)\n\t\t\t\tt1_link_changed(adapter, 0);\n\t\t}\n\t\tbreak;\n\tcase CHBT_BOARD_8000:\n\tcase CHBT_BOARD_CHT110:\n\t\tif (netif_msg_intr(adapter))\n\t\t\tdev_dbg(&adapter->pdev->dev,\n\t\t\t\t\"External interrupt cause 0x%x\\n\", cause);\n\t\tif (cause & ELMER0_GP_BIT1) {         \n\t\t\tstruct cmac *mac = adapter->port[0].mac;\n\n\t\t\tmac->ops->interrupt_handler(mac);\n\t\t}\n\t\tif (cause & ELMER0_GP_BIT5) {         \n\t\t\tu32 mod_detect;\n\n\t\t\tt1_tpi_read(adapter,\n\t\t\t\t\tA_ELMER0_GPI_STAT, &mod_detect);\n\t\t\tif (netif_msg_link(adapter))\n\t\t\t\tdev_info(&adapter->pdev->dev, \"XPAK %s\\n\",\n\t\t\t\t\t mod_detect ? \"removed\" : \"inserted\");\n\t\t}\n\t\tbreak;\n\t}\n\tt1_tpi_write(adapter, A_ELMER0_INT_CAUSE, cause);\n\treturn 0;\n}\n\n \nvoid t1_interrupts_enable(adapter_t *adapter)\n{\n\tunsigned int i;\n\n\tadapter->slow_intr_mask = F_PL_INTR_SGE_ERR | F_PL_INTR_TP;\n\n\tt1_sge_intr_enable(adapter->sge);\n\tt1_tp_intr_enable(adapter->tp);\n\tif (adapter->espi) {\n\t\tadapter->slow_intr_mask |= F_PL_INTR_ESPI;\n\t\tt1_espi_intr_enable(adapter->espi);\n\t}\n\n\t \n\tfor_each_port(adapter, i) {\n\t\tadapter->port[i].mac->ops->interrupt_enable(adapter->port[i].mac);\n\t\tadapter->port[i].phy->ops->interrupt_enable(adapter->port[i].phy);\n\t}\n\n\t \n\tif (t1_is_asic(adapter)) {\n\t\tu32 pl_intr = readl(adapter->regs + A_PL_ENABLE);\n\n\t\t \n\t\tpci_write_config_dword(adapter->pdev, A_PCICFG_INTR_ENABLE,\n\t\t\t\t       0xffffffff);\n\n\t\tadapter->slow_intr_mask |= F_PL_INTR_EXT | F_PL_INTR_PCIX;\n\t\tpl_intr |= F_PL_INTR_EXT | F_PL_INTR_PCIX;\n\t\twritel(pl_intr, adapter->regs + A_PL_ENABLE);\n\t}\n}\n\n \nvoid t1_interrupts_disable(adapter_t* adapter)\n{\n\tunsigned int i;\n\n\tt1_sge_intr_disable(adapter->sge);\n\tt1_tp_intr_disable(adapter->tp);\n\tif (adapter->espi)\n\t\tt1_espi_intr_disable(adapter->espi);\n\n\t \n\tfor_each_port(adapter, i) {\n\t\tadapter->port[i].mac->ops->interrupt_disable(adapter->port[i].mac);\n\t\tadapter->port[i].phy->ops->interrupt_disable(adapter->port[i].phy);\n\t}\n\n\t \n\tif (t1_is_asic(adapter))\n\t\twritel(0, adapter->regs + A_PL_ENABLE);\n\n\t \n\tpci_write_config_dword(adapter->pdev, A_PCICFG_INTR_ENABLE, 0);\n\n\tadapter->slow_intr_mask = 0;\n}\n\n \nvoid t1_interrupts_clear(adapter_t* adapter)\n{\n\tunsigned int i;\n\n\tt1_sge_intr_clear(adapter->sge);\n\tt1_tp_intr_clear(adapter->tp);\n\tif (adapter->espi)\n\t\tt1_espi_intr_clear(adapter->espi);\n\n\t \n\tfor_each_port(adapter, i) {\n\t\tadapter->port[i].mac->ops->interrupt_clear(adapter->port[i].mac);\n\t\tadapter->port[i].phy->ops->interrupt_clear(adapter->port[i].phy);\n\t}\n\n\t \n\tif (t1_is_asic(adapter)) {\n\t\tu32 pl_intr = readl(adapter->regs + A_PL_CAUSE);\n\n\t\twritel(pl_intr | F_PL_INTR_EXT | F_PL_INTR_PCIX,\n\t\t       adapter->regs + A_PL_CAUSE);\n\t}\n\n\t \n\tpci_write_config_dword(adapter->pdev, A_PCICFG_INTR_CAUSE, 0xffffffff);\n}\n\n \nstatic irqreturn_t asic_slow_intr(adapter_t *adapter)\n{\n\tu32 cause = readl(adapter->regs + A_PL_CAUSE);\n\tirqreturn_t ret = IRQ_HANDLED;\n\n\tcause &= adapter->slow_intr_mask;\n\tif (!cause)\n\t\treturn IRQ_NONE;\n\tif (cause & F_PL_INTR_SGE_ERR) {\n\t\tif (t1_sge_intr_error_handler(adapter->sge))\n\t\t\tret = IRQ_WAKE_THREAD;\n\t}\n\tif (cause & F_PL_INTR_TP)\n\t\tt1_tp_intr_handler(adapter->tp);\n\tif (cause & F_PL_INTR_ESPI)\n\t\tt1_espi_intr_handler(adapter->espi);\n\tif (cause & F_PL_INTR_PCIX) {\n\t\tif (t1_pci_intr_handler(adapter))\n\t\t\tret = IRQ_WAKE_THREAD;\n\t}\n\tif (cause & F_PL_INTR_EXT) {\n\t\t \n\t\tadapter->pending_thread_intr |= F_PL_INTR_EXT;\n\t\tadapter->slow_intr_mask &= ~F_PL_INTR_EXT;\n\t\twritel(adapter->slow_intr_mask | F_PL_INTR_SGE_DATA,\n\t\t       adapter->regs + A_PL_ENABLE);\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\t \n\twritel(cause, adapter->regs + A_PL_CAUSE);\n\treadl(adapter->regs + A_PL_CAUSE);  \n\treturn ret;\n}\n\nirqreturn_t t1_slow_intr_handler(adapter_t *adapter)\n{\n#ifdef CONFIG_CHELSIO_T1_1G\n\tif (!t1_is_asic(adapter))\n\t\treturn fpga_slow_intr(adapter);\n#endif\n\treturn asic_slow_intr(adapter);\n}\n\n \nstatic void power_sequence_xpak(adapter_t* adapter)\n{\n\tu32 mod_detect;\n\tu32 gpo;\n\n\t \n\tt1_tpi_read(adapter, A_ELMER0_GPI_STAT, &mod_detect);\n\tif (!(ELMER0_GP_BIT5 & mod_detect)) {\n\t\t \n\t\tt1_tpi_read(adapter, A_ELMER0_GPO, &gpo);\n\t\tgpo |= ELMER0_GP_BIT18;\n\t\tt1_tpi_write(adapter, A_ELMER0_GPO, gpo);\n\t}\n}\n\nint t1_get_board_rev(adapter_t *adapter, const struct board_info *bi,\n\t\t     struct adapter_params *p)\n{\n\tp->chip_version = bi->chip_term;\n\tp->is_asic = (p->chip_version != CHBT_TERM_FPGA);\n\tif (p->chip_version == CHBT_TERM_T1 ||\n\t    p->chip_version == CHBT_TERM_T2 ||\n\t    p->chip_version == CHBT_TERM_FPGA) {\n\t\tu32 val = readl(adapter->regs + A_TP_PC_CONFIG);\n\n\t\tval = G_TP_PC_REV(val);\n\t\tif (val == 2)\n\t\t\tp->chip_revision = TERM_T1B;\n\t\telse if (val == 3)\n\t\t\tp->chip_revision = TERM_T2;\n\t\telse\n\t\t\treturn -1;\n\t} else\n\t\treturn -1;\n\treturn 0;\n}\n\n \nstatic int board_init(adapter_t *adapter, const struct board_info *bi)\n{\n\tswitch (bi->board) {\n\tcase CHBT_BOARD_8000:\n\tcase CHBT_BOARD_N110:\n\tcase CHBT_BOARD_N210:\n\tcase CHBT_BOARD_CHT210:\n\t\tt1_tpi_par(adapter, 0xf);\n\t\tt1_tpi_write(adapter, A_ELMER0_GPO, 0x800);\n\t\tbreak;\n\tcase CHBT_BOARD_CHT110:\n\t\tt1_tpi_par(adapter, 0xf);\n\t\tt1_tpi_write(adapter, A_ELMER0_GPO, 0x1800);\n\n\t\t \n\t\tpower_sequence_xpak(adapter);\n\t\tbreak;\n#ifdef CONFIG_CHELSIO_T1_1G\n\tcase CHBT_BOARD_CHT204E:\n\t\t \n\tcase CHBT_BOARD_CHT204:\n\tcase CHBT_BOARD_CHT204V:\n\tcase CHBT_BOARD_CHN204:\n\t\tt1_tpi_par(adapter, 0xf);\n\t\tt1_tpi_write(adapter, A_ELMER0_GPO, 0x804);\n\t\tbreak;\n\tcase CHBT_BOARD_CHT101:\n\tcase CHBT_BOARD_7500:\n\t\tt1_tpi_par(adapter, 0xf);\n\t\tt1_tpi_write(adapter, A_ELMER0_GPO, 0x1804);\n\t\tbreak;\n#endif\n\t}\n\treturn 0;\n}\n\n \nint t1_init_hw_modules(adapter_t *adapter)\n{\n\tint err = -EIO;\n\tconst struct board_info *bi = board_info(adapter);\n\n\tif (!bi->clock_mc4) {\n\t\tu32 val = readl(adapter->regs + A_MC4_CFG);\n\n\t\twritel(val | F_READY | F_MC4_SLOW, adapter->regs + A_MC4_CFG);\n\t\twritel(F_M_BUS_ENABLE | F_TCAM_RESET,\n\t\t       adapter->regs + A_MC5_CONFIG);\n\t}\n\n\tif (adapter->espi && t1_espi_init(adapter->espi, bi->chip_mac,\n\t\t\t\t\t  bi->espi_nports))\n\t\tgoto out_err;\n\n\tif (t1_tp_reset(adapter->tp, &adapter->params.tp, bi->clock_core))\n\t\tgoto out_err;\n\n\terr = t1_sge_configure(adapter->sge, &adapter->params.sge);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = 0;\nout_err:\n\treturn err;\n}\n\n \nstatic void get_pci_mode(adapter_t *adapter, struct chelsio_pci_params *p)\n{\n\tstatic const unsigned short speed_map[] = { 33, 66, 100, 133 };\n\tu32 pci_mode;\n\n\tpci_read_config_dword(adapter->pdev, A_PCICFG_MODE, &pci_mode);\n\tp->speed = speed_map[G_PCI_MODE_CLK(pci_mode)];\n\tp->width = (pci_mode & F_PCI_MODE_64BIT) ? 64 : 32;\n\tp->is_pcix = (pci_mode & F_PCI_MODE_PCIX) != 0;\n}\n\n \nvoid t1_free_sw_modules(adapter_t *adapter)\n{\n\tunsigned int i;\n\n\tfor_each_port(adapter, i) {\n\t\tstruct cmac *mac = adapter->port[i].mac;\n\t\tstruct cphy *phy = adapter->port[i].phy;\n\n\t\tif (mac)\n\t\t\tmac->ops->destroy(mac);\n\t\tif (phy)\n\t\t\tphy->ops->destroy(phy);\n\t}\n\n\tif (adapter->sge)\n\t\tt1_sge_destroy(adapter->sge);\n\tif (adapter->tp)\n\t\tt1_tp_destroy(adapter->tp);\n\tif (adapter->espi)\n\t\tt1_espi_destroy(adapter->espi);\n}\n\nstatic void init_link_config(struct link_config *lc,\n\t\t\t     const struct board_info *bi)\n{\n\tlc->supported = bi->caps;\n\tlc->requested_speed = lc->speed = SPEED_INVALID;\n\tlc->requested_duplex = lc->duplex = DUPLEX_INVALID;\n\tlc->requested_fc = lc->fc = PAUSE_RX | PAUSE_TX;\n\tif (lc->supported & SUPPORTED_Autoneg) {\n\t\tlc->advertising = lc->supported;\n\t\tlc->autoneg = AUTONEG_ENABLE;\n\t\tlc->requested_fc |= PAUSE_AUTONEG;\n\t} else {\n\t\tlc->advertising = 0;\n\t\tlc->autoneg = AUTONEG_DISABLE;\n\t}\n}\n\n \nint t1_init_sw_modules(adapter_t *adapter, const struct board_info *bi)\n{\n\tunsigned int i;\n\n\tadapter->params.brd_info = bi;\n\tadapter->params.nports = bi->port_number;\n\tadapter->params.stats_update_period = bi->gmac->stats_update_period;\n\n\tadapter->sge = t1_sge_create(adapter, &adapter->params.sge);\n\tif (!adapter->sge) {\n\t\tpr_err(\"%s: SGE initialization failed\\n\",\n\t\t       adapter->name);\n\t\tgoto error;\n\t}\n\n\tif (bi->espi_nports && !(adapter->espi = t1_espi_create(adapter))) {\n\t\tpr_err(\"%s: ESPI initialization failed\\n\",\n\t\t       adapter->name);\n\t\tgoto error;\n\t}\n\n\tadapter->tp = t1_tp_create(adapter, &adapter->params.tp);\n\tif (!adapter->tp) {\n\t\tpr_err(\"%s: TP initialization failed\\n\",\n\t\t       adapter->name);\n\t\tgoto error;\n\t}\n\n\tboard_init(adapter, bi);\n\tbi->mdio_ops->init(adapter, bi);\n\tif (bi->gphy->reset)\n\t\tbi->gphy->reset(adapter);\n\tif (bi->gmac->reset)\n\t\tbi->gmac->reset(adapter);\n\n\tfor_each_port(adapter, i) {\n\t\tu8 hw_addr[6];\n\t\tstruct cmac *mac;\n\t\tint phy_addr = bi->mdio_phybaseaddr + i;\n\n\t\tadapter->port[i].phy = bi->gphy->create(adapter->port[i].dev,\n\t\t\t\t\t\t\tphy_addr, bi->mdio_ops);\n\t\tif (!adapter->port[i].phy) {\n\t\t\tpr_err(\"%s: PHY %d initialization failed\\n\",\n\t\t\t       adapter->name, i);\n\t\t\tgoto error;\n\t\t}\n\n\t\tadapter->port[i].mac = mac = bi->gmac->create(adapter, i);\n\t\tif (!mac) {\n\t\t\tpr_err(\"%s: MAC %d initialization failed\\n\",\n\t\t\t       adapter->name, i);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (!t1_is_asic(adapter) || bi->chip_mac == CHBT_MAC_DUMMY)\n\t\t\tmac->ops->macaddress_get(mac, hw_addr);\n\t\telse if (vpd_macaddress_get(adapter, i, hw_addr)) {\n\t\t\tpr_err(\"%s: could not read MAC address from VPD ROM\\n\",\n\t\t\t       adapter->port[i].dev->name);\n\t\t\tgoto error;\n\t\t}\n\t\teth_hw_addr_set(adapter->port[i].dev, hw_addr);\n\t\tinit_link_config(&adapter->port[i].link_config, bi);\n\t}\n\n\tget_pci_mode(adapter, &adapter->params.pci);\n\tt1_interrupts_clear(adapter);\n\treturn 0;\n\nerror:\n\tt1_free_sw_modules(adapter);\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}