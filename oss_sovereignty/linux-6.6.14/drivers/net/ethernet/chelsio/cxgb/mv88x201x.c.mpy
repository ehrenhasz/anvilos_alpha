{
  "module_name": "mv88x201x.c",
  "hash_id": "c3d3101135d4576f7f7f24dbfd24dea504f515ab5caf4d769159b692df84c458",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb/mv88x201x.c",
  "human_readable_source": "\n \n\n#include \"cphy.h\"\n#include \"elmer0.h\"\n\n \n#define MV88x2010_LINK_STATUS_BUGS    1\n\nstatic int led_init(struct cphy *cphy)\n{\n\t \n\tcphy_mdio_write(cphy, MDIO_MMD_PCS, 0x8304, 0xdddd);\n\treturn 0;\n}\n\nstatic int led_link(struct cphy *cphy, u32 do_enable)\n{\n\tu32 led = 0;\n#define LINK_ENABLE_BIT 0x1\n\n\tcphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_CTRL2, &led);\n\n\tif (do_enable & LINK_ENABLE_BIT) {\n\t\tled |= LINK_ENABLE_BIT;\n\t\tcphy_mdio_write(cphy, MDIO_MMD_PMAPMD, MDIO_CTRL2, led);\n\t} else {\n\t\tled &= ~LINK_ENABLE_BIT;\n\t\tcphy_mdio_write(cphy, MDIO_MMD_PMAPMD, MDIO_CTRL2, led);\n\t}\n\treturn 0;\n}\n\n \nstatic int mv88x201x_reset(struct cphy *cphy, int wait)\n{\n\t \n\treturn 0;\n}\n\nstatic int mv88x201x_interrupt_enable(struct cphy *cphy)\n{\n\t \n\tcphy_mdio_write(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL,\n\t\t\tMDIO_PMA_LASI_LSALARM);\n\n\t \n\tif (t1_is_asic(cphy->adapter)) {\n\t\tu32 elmer;\n\n\t\tt1_tpi_read(cphy->adapter, A_ELMER0_INT_ENABLE, &elmer);\n\t\telmer |= ELMER0_GP_BIT6;\n\t\tt1_tpi_write(cphy->adapter, A_ELMER0_INT_ENABLE, elmer);\n\t}\n\treturn 0;\n}\n\nstatic int mv88x201x_interrupt_disable(struct cphy *cphy)\n{\n\t \n\tcphy_mdio_write(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL, 0x0);\n\n\t \n\tif (t1_is_asic(cphy->adapter)) {\n\t\tu32 elmer;\n\n\t\tt1_tpi_read(cphy->adapter, A_ELMER0_INT_ENABLE, &elmer);\n\t\telmer &= ~ELMER0_GP_BIT6;\n\t\tt1_tpi_write(cphy->adapter, A_ELMER0_INT_ENABLE, elmer);\n\t}\n\treturn 0;\n}\n\nstatic int mv88x201x_interrupt_clear(struct cphy *cphy)\n{\n\tu32 elmer;\n\tu32 val;\n\n#ifdef MV88x2010_LINK_STATUS_BUGS\n\t \n\tcphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_RXSTAT, &val);\n\tcphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_TXSTAT, &val);\n\tcphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_STAT, &val);\n\n\t \n\tcphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_STAT1, &val);\n#endif\n\n\t \n\tcphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_STAT1, &val);\n\t \n\tcphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_STAT, &val);\n\n#ifdef MV88x2010_LINK_STATUS_BUGS\n\t \n\tcphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_RXSTAT, &val);\n\tcphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_TXSTAT, &val);\n#endif\n\n\t \n\tif (t1_is_asic(cphy->adapter)) {\n\t\tt1_tpi_read(cphy->adapter, A_ELMER0_INT_CAUSE, &elmer);\n\t\telmer |= ELMER0_GP_BIT6;\n\t\tt1_tpi_write(cphy->adapter, A_ELMER0_INT_CAUSE, elmer);\n\t}\n\treturn 0;\n}\n\nstatic int mv88x201x_interrupt_handler(struct cphy *cphy)\n{\n\t \n\tmv88x201x_interrupt_clear(cphy);\n\n\t \n\treturn cphy_cause_link_change;\n}\n\nstatic int mv88x201x_set_loopback(struct cphy *cphy, int on)\n{\n\treturn 0;\n}\n\nstatic int mv88x201x_get_link_status(struct cphy *cphy, int *link_ok,\n\t\t\t\t     int *speed, int *duplex, int *fc)\n{\n\tu32 val = 0;\n\n\tif (link_ok) {\n\t\t \n\t\tcphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_STAT1, &val);\n\t\tval &= MDIO_STAT1_LSTATUS;\n\t\t*link_ok = (val == MDIO_STAT1_LSTATUS);\n\t\t \n\t\tled_link(cphy, *link_ok);\n\t}\n\tif (speed)\n\t\t*speed = SPEED_10000;\n\tif (duplex)\n\t\t*duplex = DUPLEX_FULL;\n\tif (fc)\n\t\t*fc = PAUSE_RX | PAUSE_TX;\n\treturn 0;\n}\n\nstatic void mv88x201x_destroy(struct cphy *cphy)\n{\n\tkfree(cphy);\n}\n\nstatic const struct cphy_ops mv88x201x_ops = {\n\t.destroy           = mv88x201x_destroy,\n\t.reset             = mv88x201x_reset,\n\t.interrupt_enable  = mv88x201x_interrupt_enable,\n\t.interrupt_disable = mv88x201x_interrupt_disable,\n\t.interrupt_clear   = mv88x201x_interrupt_clear,\n\t.interrupt_handler = mv88x201x_interrupt_handler,\n\t.get_link_status   = mv88x201x_get_link_status,\n\t.set_loopback      = mv88x201x_set_loopback,\n\t.mmds              = (MDIO_DEVS_PMAPMD | MDIO_DEVS_PCS |\n\t\t\t      MDIO_DEVS_PHYXS | MDIO_DEVS_WIS),\n};\n\nstatic struct cphy *mv88x201x_phy_create(struct net_device *dev, int phy_addr,\n\t\t\t\t\t const struct mdio_ops *mdio_ops)\n{\n\tu32 val;\n\tstruct cphy *cphy = kzalloc(sizeof(*cphy), GFP_KERNEL);\n\n\tif (!cphy)\n\t\treturn NULL;\n\n\tcphy_init(cphy, dev, phy_addr, &mv88x201x_ops, mdio_ops);\n\n\t \n\tcphy_mdio_read(cphy, MDIO_MMD_PCS, 0x8300, &val);\n\tcphy_mdio_write(cphy, MDIO_MMD_PCS, 0x8300, val | 1);\n\n\t \n\tcphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_STAT2, &val);\n\tcphy_mdio_read(cphy, MDIO_MMD_PCS, MDIO_STAT2, &val);\n\n\t \n\tled_init(cphy);\n\treturn cphy;\n}\n\n \nstatic int mv88x201x_phy_reset(adapter_t *adapter)\n{\n\tu32 val;\n\n\tt1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval &= ~4;\n\tt1_tpi_write(adapter, A_ELMER0_GPO, val);\n\tmsleep(100);\n\n\tt1_tpi_write(adapter, A_ELMER0_GPO, val | 4);\n\tmsleep(1000);\n\n\t \n\tt1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval |= 0x8000;\n\tt1_tpi_write(adapter, A_ELMER0_GPO, val);\n\tudelay(100);\n\treturn 0;\n}\n\nconst struct gphy t1_mv88x201x_ops = {\n\t.create = mv88x201x_phy_create,\n\t.reset = mv88x201x_phy_reset\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}