{
  "module_name": "tp.c",
  "hash_id": "c1b6dd34b6d663131b22799292c560dd8107d10c322f77743d46bea3c1a7c026",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb/tp.c",
  "human_readable_source": "\n \n#include \"common.h\"\n#include \"regs.h\"\n#include \"tp.h\"\n#ifdef CONFIG_CHELSIO_T1_1G\n#include \"fpga_defs.h\"\n#endif\n\nstruct petp {\n\tadapter_t *adapter;\n};\n\n \n#define DROP_MSEC 16\n#define DROP_PKTS_CNT  1\n\nstatic void tp_init(adapter_t * ap, const struct tp_params *p,\n\t\t    unsigned int tp_clk)\n{\n\tu32 val;\n\n\tif (!t1_is_asic(ap))\n\t\treturn;\n\n\tval = F_TP_IN_CSPI_CPL | F_TP_IN_CSPI_CHECK_IP_CSUM |\n\t\tF_TP_IN_CSPI_CHECK_TCP_CSUM | F_TP_IN_ESPI_ETHERNET;\n\tif (!p->pm_size)\n\t\tval |= F_OFFLOAD_DISABLE;\n\telse\n\t\tval |= F_TP_IN_ESPI_CHECK_IP_CSUM | F_TP_IN_ESPI_CHECK_TCP_CSUM;\n\twritel(val, ap->regs + A_TP_IN_CONFIG);\n\twritel(F_TP_OUT_CSPI_CPL |\n\t       F_TP_OUT_ESPI_ETHERNET |\n\t       F_TP_OUT_ESPI_GENERATE_IP_CSUM |\n\t       F_TP_OUT_ESPI_GENERATE_TCP_CSUM, ap->regs + A_TP_OUT_CONFIG);\n\twritel(V_IP_TTL(64) |\n\t       F_PATH_MTU    |\n\t       V_5TUPLE_LOOKUP(p->use_5tuple_mode) |\n\t       V_SYN_COOKIE_PARAMETER(29), ap->regs + A_TP_GLOBAL_CONFIG);\n\t \n\tif (is_T2(ap) && ap->params.nports > 1) {\n\t\tu32 drop_ticks = DROP_MSEC * (tp_clk / 1000);\n\n\t\twritel(F_ENABLE_TX_DROP | F_ENABLE_TX_ERROR |\n\t\t       V_DROP_TICKS_CNT(drop_ticks) |\n\t\t       V_NUM_PKTS_DROPPED(DROP_PKTS_CNT),\n\t\t       ap->regs + A_TP_TX_DROP_CONFIG);\n\t}\n}\n\nvoid t1_tp_destroy(struct petp *tp)\n{\n\tkfree(tp);\n}\n\nstruct petp *t1_tp_create(adapter_t *adapter, struct tp_params *p)\n{\n\tstruct petp *tp = kzalloc(sizeof(*tp), GFP_KERNEL);\n\n\tif (!tp)\n\t\treturn NULL;\n\n\ttp->adapter = adapter;\n\n\treturn tp;\n}\n\nvoid t1_tp_intr_enable(struct petp *tp)\n{\n\tu32 tp_intr = readl(tp->adapter->regs + A_PL_ENABLE);\n\n#ifdef CONFIG_CHELSIO_T1_1G\n\tif (!t1_is_asic(tp->adapter)) {\n\t\t \n\t\twritel(0xffffffff,\n\t\t       tp->adapter->regs + FPGA_TP_ADDR_INTERRUPT_ENABLE);\n\t\twritel(tp_intr | FPGA_PCIX_INTERRUPT_TP,\n\t\t       tp->adapter->regs + A_PL_ENABLE);\n\t} else\n#endif\n\t{\n\t\t \n\t\twritel(0, tp->adapter->regs + A_TP_INT_ENABLE);\n\t\twritel(tp_intr | F_PL_INTR_TP,\n\t\t       tp->adapter->regs + A_PL_ENABLE);\n\t}\n}\n\nvoid t1_tp_intr_disable(struct petp *tp)\n{\n\tu32 tp_intr = readl(tp->adapter->regs + A_PL_ENABLE);\n\n#ifdef CONFIG_CHELSIO_T1_1G\n\tif (!t1_is_asic(tp->adapter)) {\n\t\t \n\t\twritel(0, tp->adapter->regs + FPGA_TP_ADDR_INTERRUPT_ENABLE);\n\t\twritel(tp_intr & ~FPGA_PCIX_INTERRUPT_TP,\n\t\t       tp->adapter->regs + A_PL_ENABLE);\n\t} else\n#endif\n\t{\n\t\twritel(0, tp->adapter->regs + A_TP_INT_ENABLE);\n\t\twritel(tp_intr & ~F_PL_INTR_TP,\n\t\t       tp->adapter->regs + A_PL_ENABLE);\n\t}\n}\n\nvoid t1_tp_intr_clear(struct petp *tp)\n{\n#ifdef CONFIG_CHELSIO_T1_1G\n\tif (!t1_is_asic(tp->adapter)) {\n\t\twritel(0xffffffff,\n\t\t       tp->adapter->regs + FPGA_TP_ADDR_INTERRUPT_CAUSE);\n\t\twritel(FPGA_PCIX_INTERRUPT_TP, tp->adapter->regs + A_PL_CAUSE);\n\t\treturn;\n\t}\n#endif\n\twritel(0xffffffff, tp->adapter->regs + A_TP_INT_CAUSE);\n\twritel(F_PL_INTR_TP, tp->adapter->regs + A_PL_CAUSE);\n}\n\nint t1_tp_intr_handler(struct petp *tp)\n{\n\tu32 cause;\n\n#ifdef CONFIG_CHELSIO_T1_1G\n\t \n\tif (!t1_is_asic(tp->adapter))\n\t\treturn 1;\n#endif\n\n\tcause = readl(tp->adapter->regs + A_TP_INT_CAUSE);\n\twritel(cause, tp->adapter->regs + A_TP_INT_CAUSE);\n\treturn 0;\n}\n\nstatic void set_csum_offload(struct petp *tp, u32 csum_bit, int enable)\n{\n\tu32 val = readl(tp->adapter->regs + A_TP_GLOBAL_CONFIG);\n\n\tif (enable)\n\t\tval |= csum_bit;\n\telse\n\t\tval &= ~csum_bit;\n\twritel(val, tp->adapter->regs + A_TP_GLOBAL_CONFIG);\n}\n\nvoid t1_tp_set_ip_checksum_offload(struct petp *tp, int enable)\n{\n\tset_csum_offload(tp, F_IP_CSUM, enable);\n}\n\nvoid t1_tp_set_tcp_checksum_offload(struct petp *tp, int enable)\n{\n\tset_csum_offload(tp, F_TCP_CSUM, enable);\n}\n\n \nint t1_tp_reset(struct petp *tp, struct tp_params *p, unsigned int tp_clk)\n{\n\tadapter_t *adapter = tp->adapter;\n\n\ttp_init(adapter, p, tp_clk);\n\twritel(F_TP_RESET, adapter->regs +  A_TP_RESET);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}