{
  "module_name": "espi.c",
  "hash_id": "39b0d996b6a885064b446a9e494a0733d7f890b4ec8cb99ca547bde09268bdec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb/espi.c",
  "human_readable_source": "\n \n\n#include \"common.h\"\n#include \"regs.h\"\n#include \"espi.h\"\n\nstruct peespi {\n\tadapter_t *adapter;\n\tstruct espi_intr_counts intr_cnt;\n\tu32 misc_ctrl;\n\tspinlock_t lock;\n};\n\n#define ESPI_INTR_MASK (F_DIP4ERR | F_RXDROP | F_TXDROP | F_RXOVERFLOW | \\\n\t\t\tF_RAMPARITYERR | F_DIP2PARITYERR)\n#define MON_MASK  (V_MONITORED_PORT_NUM(3) | F_MONITORED_DIRECTION \\\n\t\t   | F_MONITORED_INTERFACE)\n\n#define TRICN_CNFG 14\n#define TRICN_CMD_READ  0x11\n#define TRICN_CMD_WRITE 0x21\n#define TRICN_CMD_ATTEMPTS 10\n\nstatic int tricn_write(adapter_t *adapter, int bundle_addr, int module_addr,\n\t\t       int ch_addr, int reg_offset, u32 wr_data)\n{\n\tint busy, attempts = TRICN_CMD_ATTEMPTS;\n\n\twritel(V_WRITE_DATA(wr_data) |\n\t       V_REGISTER_OFFSET(reg_offset) |\n\t       V_CHANNEL_ADDR(ch_addr) | V_MODULE_ADDR(module_addr) |\n\t       V_BUNDLE_ADDR(bundle_addr) |\n\t       V_SPI4_COMMAND(TRICN_CMD_WRITE),\n\t       adapter->regs + A_ESPI_CMD_ADDR);\n\twritel(0, adapter->regs + A_ESPI_GOSTAT);\n\n\tdo {\n\t\tbusy = readl(adapter->regs + A_ESPI_GOSTAT) & F_ESPI_CMD_BUSY;\n\t} while (busy && --attempts);\n\n\tif (busy)\n\t\tpr_err(\"%s: TRICN write timed out\\n\", adapter->name);\n\n\treturn busy;\n}\n\nstatic int tricn_init(adapter_t *adapter)\n{\n\tint i, sme = 1;\n\n\tif (!(readl(adapter->regs + A_ESPI_RX_RESET)  & F_RX_CLK_STATUS)) {\n\t\tpr_err(\"%s: ESPI clock not ready\\n\", adapter->name);\n\t\treturn -1;\n\t}\n\n\twritel(F_ESPI_RX_CORE_RST, adapter->regs + A_ESPI_RX_RESET);\n\n\tif (sme) {\n\t\ttricn_write(adapter, 0, 0, 0, TRICN_CNFG, 0x81);\n\t\ttricn_write(adapter, 0, 1, 0, TRICN_CNFG, 0x81);\n\t\ttricn_write(adapter, 0, 2, 0, TRICN_CNFG, 0x81);\n\t}\n\tfor (i = 1; i <= 8; i++)\n\t\ttricn_write(adapter, 0, 0, i, TRICN_CNFG, 0xf1);\n\tfor (i = 1; i <= 2; i++)\n\t\ttricn_write(adapter, 0, 1, i, TRICN_CNFG, 0xf1);\n\tfor (i = 1; i <= 3; i++)\n\t\ttricn_write(adapter, 0, 2, i, TRICN_CNFG, 0xe1);\n\ttricn_write(adapter, 0, 2, 4, TRICN_CNFG, 0xf1);\n\ttricn_write(adapter, 0, 2, 5, TRICN_CNFG, 0xe1);\n\ttricn_write(adapter, 0, 2, 6, TRICN_CNFG, 0xf1);\n\ttricn_write(adapter, 0, 2, 7, TRICN_CNFG, 0x80);\n\ttricn_write(adapter, 0, 2, 8, TRICN_CNFG, 0xf1);\n\n\twritel(F_ESPI_RX_CORE_RST | F_ESPI_RX_LNK_RST,\n\t       adapter->regs + A_ESPI_RX_RESET);\n\n\treturn 0;\n}\n\nvoid t1_espi_intr_enable(struct peespi *espi)\n{\n\tu32 enable, pl_intr = readl(espi->adapter->regs + A_PL_ENABLE);\n\n\t \n\tenable = t1_is_T1B(espi->adapter) ? 0 : ESPI_INTR_MASK;\n\twritel(enable, espi->adapter->regs + A_ESPI_INTR_ENABLE);\n\twritel(pl_intr | F_PL_INTR_ESPI, espi->adapter->regs + A_PL_ENABLE);\n}\n\nvoid t1_espi_intr_clear(struct peespi *espi)\n{\n\treadl(espi->adapter->regs + A_ESPI_DIP2_ERR_COUNT);\n\twritel(0xffffffff, espi->adapter->regs + A_ESPI_INTR_STATUS);\n\twritel(F_PL_INTR_ESPI, espi->adapter->regs + A_PL_CAUSE);\n}\n\nvoid t1_espi_intr_disable(struct peespi *espi)\n{\n\tu32 pl_intr = readl(espi->adapter->regs + A_PL_ENABLE);\n\n\twritel(0, espi->adapter->regs + A_ESPI_INTR_ENABLE);\n\twritel(pl_intr & ~F_PL_INTR_ESPI, espi->adapter->regs + A_PL_ENABLE);\n}\n\nint t1_espi_intr_handler(struct peespi *espi)\n{\n\tu32 status = readl(espi->adapter->regs + A_ESPI_INTR_STATUS);\n\n\tif (status & F_DIP4ERR)\n\t\tespi->intr_cnt.DIP4_err++;\n\tif (status & F_RXDROP)\n\t\tespi->intr_cnt.rx_drops++;\n\tif (status & F_TXDROP)\n\t\tespi->intr_cnt.tx_drops++;\n\tif (status & F_RXOVERFLOW)\n\t\tespi->intr_cnt.rx_ovflw++;\n\tif (status & F_RAMPARITYERR)\n\t\tespi->intr_cnt.parity_err++;\n\tif (status & F_DIP2PARITYERR) {\n\t\tespi->intr_cnt.DIP2_parity_err++;\n\n\t\t \n\t\treadl(espi->adapter->regs + A_ESPI_DIP2_ERR_COUNT);\n\t}\n\n\t \n\tif (status && t1_is_T1B(espi->adapter))\n\t\tstatus = 1;\n\twritel(status, espi->adapter->regs + A_ESPI_INTR_STATUS);\n\treturn 0;\n}\n\nconst struct espi_intr_counts *t1_espi_get_intr_counts(struct peespi *espi)\n{\n\treturn &espi->intr_cnt;\n}\n\nstatic void espi_setup_for_pm3393(adapter_t *adapter)\n{\n\tu32 wmark = t1_is_T1B(adapter) ? 0x4000 : 0x3200;\n\n\twritel(0x1f4, adapter->regs + A_ESPI_SCH_TOKEN0);\n\twritel(0x1f4, adapter->regs + A_ESPI_SCH_TOKEN1);\n\twritel(0x1f4, adapter->regs + A_ESPI_SCH_TOKEN2);\n\twritel(0x1f4, adapter->regs + A_ESPI_SCH_TOKEN3);\n\twritel(0x100, adapter->regs + A_ESPI_RX_FIFO_ALMOST_EMPTY_WATERMARK);\n\twritel(wmark, adapter->regs + A_ESPI_RX_FIFO_ALMOST_FULL_WATERMARK);\n\twritel(3, adapter->regs + A_ESPI_CALENDAR_LENGTH);\n\twritel(0x08000008, adapter->regs + A_ESPI_TRAIN);\n\twritel(V_RX_NPORTS(1) | V_TX_NPORTS(1), adapter->regs + A_PORT_CONFIG);\n}\n\nstatic void espi_setup_for_vsc7321(adapter_t *adapter)\n{\n\twritel(0x1f4, adapter->regs + A_ESPI_SCH_TOKEN0);\n\twritel(0x1f401f4, adapter->regs + A_ESPI_SCH_TOKEN1);\n\twritel(0x1f4, adapter->regs + A_ESPI_SCH_TOKEN2);\n\twritel(0xa00, adapter->regs + A_ESPI_RX_FIFO_ALMOST_FULL_WATERMARK);\n\twritel(0x1ff, adapter->regs + A_ESPI_RX_FIFO_ALMOST_EMPTY_WATERMARK);\n\twritel(1, adapter->regs + A_ESPI_CALENDAR_LENGTH);\n\twritel(V_RX_NPORTS(4) | V_TX_NPORTS(4), adapter->regs + A_PORT_CONFIG);\n\n\twritel(0x08000008, adapter->regs + A_ESPI_TRAIN);\n}\n\n \nstatic void espi_setup_for_ixf1010(adapter_t *adapter, int nports)\n{\n\twritel(1, adapter->regs + A_ESPI_CALENDAR_LENGTH);\n\tif (nports == 4) {\n\t\tif (is_T2(adapter)) {\n\t\t\twritel(0xf00, adapter->regs + A_ESPI_RX_FIFO_ALMOST_FULL_WATERMARK);\n\t\t\twritel(0x3c0, adapter->regs + A_ESPI_RX_FIFO_ALMOST_EMPTY_WATERMARK);\n\t\t} else {\n\t\t\twritel(0x7ff, adapter->regs + A_ESPI_RX_FIFO_ALMOST_FULL_WATERMARK);\n\t\t\twritel(0x1ff, adapter->regs + A_ESPI_RX_FIFO_ALMOST_EMPTY_WATERMARK);\n\t\t}\n\t} else {\n\t\twritel(0x1fff, adapter->regs + A_ESPI_RX_FIFO_ALMOST_FULL_WATERMARK);\n\t\twritel(0x7ff, adapter->regs + A_ESPI_RX_FIFO_ALMOST_EMPTY_WATERMARK);\n\t}\n\twritel(V_RX_NPORTS(nports) | V_TX_NPORTS(nports), adapter->regs + A_PORT_CONFIG);\n\n}\n\nint t1_espi_init(struct peespi *espi, int mac_type, int nports)\n{\n\tu32 status_enable_extra = 0;\n\tadapter_t *adapter = espi->adapter;\n\n\t \n\twritel(0, adapter->regs + A_ESPI_TRAIN);\n\n\tif (is_T2(adapter)) {\n\t\twritel(V_OUT_OF_SYNC_COUNT(4) |\n\t\t       V_DIP2_PARITY_ERR_THRES(3) |\n\t\t       V_DIP4_THRES(1), adapter->regs + A_ESPI_MISC_CONTROL);\n\t\twritel(nports == 4 ? 0x200040 : 0x1000080,\n\t\t       adapter->regs + A_ESPI_MAXBURST1_MAXBURST2);\n\t} else\n\t\twritel(0x800100, adapter->regs + A_ESPI_MAXBURST1_MAXBURST2);\n\n\tif (mac_type == CHBT_MAC_PM3393)\n\t\tespi_setup_for_pm3393(adapter);\n\telse if (mac_type == CHBT_MAC_VSC7321)\n\t\tespi_setup_for_vsc7321(adapter);\n\telse if (mac_type == CHBT_MAC_IXF1010) {\n\t\tstatus_enable_extra = F_INTEL1010MODE;\n\t\tespi_setup_for_ixf1010(adapter, nports);\n\t} else\n\t\treturn -1;\n\n\twritel(status_enable_extra | F_RXSTATUSENABLE,\n\t       adapter->regs + A_ESPI_FIFO_STATUS_ENABLE);\n\n\tif (is_T2(adapter)) {\n\t\ttricn_init(adapter);\n\t\t \n\t\tespi->misc_ctrl = readl(adapter->regs + A_ESPI_MISC_CONTROL);\n\t\tespi->misc_ctrl &= ~MON_MASK;\n\t\tespi->misc_ctrl |= F_MONITORED_DIRECTION;\n\t\tif (adapter->params.nports == 1)\n\t\t\tespi->misc_ctrl |= F_MONITORED_INTERFACE;\n\t\twritel(espi->misc_ctrl, adapter->regs + A_ESPI_MISC_CONTROL);\n\t\tspin_lock_init(&espi->lock);\n\t}\n\n\treturn 0;\n}\n\nvoid t1_espi_destroy(struct peespi *espi)\n{\n\tkfree(espi);\n}\n\nstruct peespi *t1_espi_create(adapter_t *adapter)\n{\n\tstruct peespi *espi = kzalloc(sizeof(*espi), GFP_KERNEL);\n\n\tif (espi)\n\t\tespi->adapter = adapter;\n\treturn espi;\n}\n\n#if 0\nvoid t1_espi_set_misc_ctrl(adapter_t *adapter, u32 val)\n{\n\tstruct peespi *espi = adapter->espi;\n\n\tif (!is_T2(adapter))\n\t\treturn;\n\tspin_lock(&espi->lock);\n\tespi->misc_ctrl = (val & ~MON_MASK) |\n\t\t\t  (espi->misc_ctrl & MON_MASK);\n\twritel(espi->misc_ctrl, adapter->regs + A_ESPI_MISC_CONTROL);\n\tspin_unlock(&espi->lock);\n}\n#endif   \n\nu32 t1_espi_get_mon(adapter_t *adapter, u32 addr, u8 wait)\n{\n\tstruct peespi *espi = adapter->espi;\n\tu32 sel;\n\n\tif (!is_T2(adapter))\n\t\treturn 0;\n\n\tsel = V_MONITORED_PORT_NUM((addr & 0x3c) >> 2);\n\tif (!wait) {\n\t\tif (!spin_trylock(&espi->lock))\n\t\t\treturn 0;\n\t} else\n\t\tspin_lock(&espi->lock);\n\n\tif ((sel != (espi->misc_ctrl & MON_MASK))) {\n\t\twritel(((espi->misc_ctrl & ~MON_MASK) | sel),\n\t\t       adapter->regs + A_ESPI_MISC_CONTROL);\n\t\tsel = readl(adapter->regs + A_ESPI_SCH_TOKEN3);\n\t\twritel(espi->misc_ctrl, adapter->regs + A_ESPI_MISC_CONTROL);\n\t} else\n\t\tsel = readl(adapter->regs + A_ESPI_SCH_TOKEN3);\n\tspin_unlock(&espi->lock);\n\treturn sel;\n}\n\n \nint t1_espi_get_mon_t204(adapter_t *adapter, u32 *valp, u8 wait)\n{\n\tstruct peespi *espi = adapter->espi;\n\tu8 i, nport = (u8)adapter->params.nports;\n\n\tif (!wait) {\n\t\tif (!spin_trylock(&espi->lock))\n\t\t\treturn -1;\n\t} else\n\t\tspin_lock(&espi->lock);\n\n\tif ((espi->misc_ctrl & MON_MASK) != F_MONITORED_DIRECTION) {\n\t\tespi->misc_ctrl = (espi->misc_ctrl & ~MON_MASK) |\n\t\t\t\t\tF_MONITORED_DIRECTION;\n\t\twritel(espi->misc_ctrl, adapter->regs + A_ESPI_MISC_CONTROL);\n\t}\n\tfor (i = 0 ; i < nport; i++, valp++) {\n\t\tif (i) {\n\t\t\twritel(espi->misc_ctrl | V_MONITORED_PORT_NUM(i),\n\t\t\t       adapter->regs + A_ESPI_MISC_CONTROL);\n\t\t}\n\t\t*valp = readl(adapter->regs + A_ESPI_SCH_TOKEN3);\n\t}\n\n\twritel(espi->misc_ctrl, adapter->regs + A_ESPI_MISC_CONTROL);\n\tspin_unlock(&espi->lock);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}