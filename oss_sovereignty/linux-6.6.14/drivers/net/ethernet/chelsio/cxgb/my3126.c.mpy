{
  "module_name": "my3126.c",
  "hash_id": "3a1757282770ddf690e0f12499a5bad84cc9904aea0c4a2ce749c74168937206",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb/my3126.c",
  "human_readable_source": "\n \n#include \"cphy.h\"\n#include \"elmer0.h\"\n#include \"suni1x10gexp_regs.h\"\n\n \nstatic int my3126_reset(struct cphy *cphy, int wait)\n{\n\t \n\treturn 0;\n}\n\nstatic int my3126_interrupt_enable(struct cphy *cphy)\n{\n\tschedule_delayed_work(&cphy->phy_update, HZ/30);\n\tt1_tpi_read(cphy->adapter, A_ELMER0_GPO, &cphy->elmer_gpo);\n\treturn 0;\n}\n\nstatic int my3126_interrupt_disable(struct cphy *cphy)\n{\n\tcancel_delayed_work_sync(&cphy->phy_update);\n\treturn 0;\n}\n\nstatic int my3126_interrupt_clear(struct cphy *cphy)\n{\n\treturn 0;\n}\n\n#define OFFSET(REG_ADDR)    (REG_ADDR << 2)\n\nstatic int my3126_interrupt_handler(struct cphy *cphy)\n{\n\tu32 val;\n\tu16 val16;\n\tu16 status;\n\tu32 act_count;\n\tadapter_t *adapter;\n\tadapter = cphy->adapter;\n\n\tif (cphy->count == 50) {\n\t\tcphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_STAT1, &val);\n\t\tval16 = (u16) val;\n\t\tstatus = cphy->bmsr ^ val16;\n\n\t\tif (status & MDIO_STAT1_LSTATUS)\n\t\t\tt1_link_changed(adapter, 0);\n\t\tcphy->bmsr = val16;\n\n\t\t \n\t\tcphy->count = 0;\n\t}\n\n\tt1_tpi_write(adapter, OFFSET(SUNI1x10GEXP_REG_MSTAT_CONTROL),\n\t\tSUNI1x10GEXP_BITMSK_MSTAT_SNAP);\n\tt1_tpi_read(adapter,\n\t\tOFFSET(SUNI1x10GEXP_REG_MSTAT_COUNTER_1_LOW), &act_count);\n\tt1_tpi_read(adapter,\n\t\tOFFSET(SUNI1x10GEXP_REG_MSTAT_COUNTER_33_LOW), &val);\n\tact_count += val;\n\n\t \n\tt1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tcphy->elmer_gpo = val;\n\n\tif ( (val & (1 << 8)) || (val & (1 << 19)) ||\n\t     (cphy->act_count == act_count) || cphy->act_on ) {\n\t\tif (is_T2(adapter))\n\t\t\tval |= (1 << 9);\n\t\telse if (t1_is_T1B(adapter))\n\t\t\tval |= (1 << 20);\n\t\tcphy->act_on = 0;\n\t} else {\n\t\tif (is_T2(adapter))\n\t\t\tval &= ~(1 << 9);\n\t\telse if (t1_is_T1B(adapter))\n\t\t\tval &= ~(1 << 20);\n\t\tcphy->act_on = 1;\n\t}\n\n\tt1_tpi_write(adapter, A_ELMER0_GPO, val);\n\n\tcphy->elmer_gpo = val;\n\tcphy->act_count = act_count;\n\tcphy->count++;\n\n\treturn cphy_cause_link_change;\n}\n\nstatic void my3126_poll(struct work_struct *work)\n{\n\tstruct cphy *cphy = container_of(work, struct cphy, phy_update.work);\n\n\tmy3126_interrupt_handler(cphy);\n}\n\nstatic int my3126_set_loopback(struct cphy *cphy, int on)\n{\n\treturn 0;\n}\n\n \nstatic int my3126_get_link_status(struct cphy *cphy,\n\t\t\tint *link_ok, int *speed, int *duplex, int *fc)\n{\n\tu32 val;\n\tu16 val16;\n\tadapter_t *adapter;\n\n\tadapter = cphy->adapter;\n\tcphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_STAT1, &val);\n\tval16 = (u16) val;\n\n\t \n\tt1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tcphy->elmer_gpo = val;\n\n\t*link_ok = (val16 & MDIO_STAT1_LSTATUS);\n\n\tif (*link_ok) {\n\t\t \n\t\tif (is_T2(adapter))\n\t\t\t val &= ~(1 << 8);\n\t\telse if (t1_is_T1B(adapter))\n\t\t\t val &= ~(1 << 19);\n\t} else {\n\t\t \n\t\tif (is_T2(adapter))\n\t\t\t val |= (1 << 8);\n\t\telse if (t1_is_T1B(adapter))\n\t\t\t val |= (1 << 19);\n\t}\n\n\tt1_tpi_write(adapter, A_ELMER0_GPO, val);\n\tcphy->elmer_gpo = val;\n\t*speed = SPEED_10000;\n\t*duplex = DUPLEX_FULL;\n\n\t \n\tif (fc)\n\t\t*fc = PAUSE_RX | PAUSE_TX;\n\n\treturn 0;\n}\n\nstatic void my3126_destroy(struct cphy *cphy)\n{\n\tkfree(cphy);\n}\n\nstatic const struct cphy_ops my3126_ops = {\n\t.destroy\t\t= my3126_destroy,\n\t.reset\t\t\t= my3126_reset,\n\t.interrupt_enable\t= my3126_interrupt_enable,\n\t.interrupt_disable\t= my3126_interrupt_disable,\n\t.interrupt_clear\t= my3126_interrupt_clear,\n\t.interrupt_handler\t= my3126_interrupt_handler,\n\t.get_link_status\t= my3126_get_link_status,\n\t.set_loopback\t\t= my3126_set_loopback,\n\t.mmds\t\t\t= (MDIO_DEVS_PMAPMD | MDIO_DEVS_PCS |\n\t\t\t\t   MDIO_DEVS_PHYXS),\n};\n\nstatic struct cphy *my3126_phy_create(struct net_device *dev,\n\t\t\tint phy_addr, const struct mdio_ops *mdio_ops)\n{\n\tstruct cphy *cphy = kzalloc(sizeof (*cphy), GFP_KERNEL);\n\n\tif (!cphy)\n\t\treturn NULL;\n\n\tcphy_init(cphy, dev, phy_addr, &my3126_ops, mdio_ops);\n\tINIT_DELAYED_WORK(&cphy->phy_update, my3126_poll);\n\tcphy->bmsr = 0;\n\n\treturn cphy;\n}\n\n \nstatic int my3126_phy_reset(adapter_t * adapter)\n{\n\tu32 val;\n\n\tt1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval &= ~4;\n\tt1_tpi_write(adapter, A_ELMER0_GPO, val);\n\tmsleep(100);\n\n\tt1_tpi_write(adapter, A_ELMER0_GPO, val | 4);\n\tmsleep(1000);\n\n\t \n\tt1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval |= 0x8000;\n\tt1_tpi_write(adapter, A_ELMER0_GPO, val);\n\tudelay(100);\n\treturn 0;\n}\n\nconst struct gphy t1_my3126_ops = {\n\t.create = my3126_phy_create,\n\t.reset = my3126_phy_reset\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}