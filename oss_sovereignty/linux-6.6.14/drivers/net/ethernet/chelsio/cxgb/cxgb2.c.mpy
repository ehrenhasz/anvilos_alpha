{
  "module_name": "cxgb2.c",
  "hash_id": "ceaf36fe14efb3bd4b4cc108b218575cb1dc31a45bcefc9de718f87ca7cb926d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb/cxgb2.c",
  "human_readable_source": " \n\n#include \"common.h\"\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/mii.h>\n#include <linux/sockios.h>\n#include <linux/dma-mapping.h>\n#include <linux/uaccess.h>\n\n#include \"cpl5_cmd.h\"\n#include \"regs.h\"\n#include \"gmac.h\"\n#include \"cphy.h\"\n#include \"sge.h\"\n#include \"tp.h\"\n#include \"espi.h\"\n#include \"elmer0.h\"\n\n#include <linux/workqueue.h>\n\nstatic inline void schedule_mac_stats_update(struct adapter *ap, int secs)\n{\n\tschedule_delayed_work(&ap->stats_update_task, secs * HZ);\n}\n\nstatic inline void cancel_mac_stats_update(struct adapter *ap)\n{\n\tcancel_delayed_work(&ap->stats_update_task);\n}\n\n#define MAX_CMDQ_ENTRIES\t16384\n#define MAX_CMDQ1_ENTRIES\t1024\n#define MAX_RX_BUFFERS\t\t16384\n#define MAX_RX_JUMBO_BUFFERS\t16384\n#define MAX_TX_BUFFERS_HIGH\t16384U\n#define MAX_TX_BUFFERS_LOW\t1536U\n#define MAX_TX_BUFFERS\t\t1460U\n#define MIN_FL_ENTRIES\t\t32\n\n#define DFLT_MSG_ENABLE (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK | \\\n\t\t\t NETIF_MSG_TIMER | NETIF_MSG_IFDOWN | NETIF_MSG_IFUP |\\\n\t\t\t NETIF_MSG_RX_ERR | NETIF_MSG_TX_ERR)\n\n \n#define EEPROM_SIZE 32\n\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_AUTHOR(\"Chelsio Communications\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int dflt_msg_enable = DFLT_MSG_ENABLE;\n\nmodule_param(dflt_msg_enable, int, 0);\nMODULE_PARM_DESC(dflt_msg_enable, \"Chelsio T1 default message enable bitmap\");\n\n#define HCLOCK 0x0\n#define LCLOCK 0x1\n\n \nstatic int t1_clock(struct adapter *adapter, int mode);\nstatic int t1powersave = 1;\t \n\nmodule_param(t1powersave, int, 0);\nMODULE_PARM_DESC(t1powersave, \"Enable/Disable T1 powersaving mode\");\n\nstatic int disable_msi = 0;\nmodule_param(disable_msi, int, 0);\nMODULE_PARM_DESC(disable_msi, \"Disable Message Signaled Interrupt (MSI)\");\n\n \nstatic void t1_set_rxmode(struct net_device *dev)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tstruct cmac *mac = adapter->port[dev->if_port].mac;\n\tstruct t1_rx_mode rm;\n\n\trm.dev = dev;\n\tmac->ops->set_rx_mode(mac, &rm);\n}\n\nstatic void link_report(struct port_info *p)\n{\n\tif (!netif_carrier_ok(p->dev))\n\t\tnetdev_info(p->dev, \"link down\\n\");\n\telse {\n\t\tconst char *s = \"10Mbps\";\n\n\t\tswitch (p->link_config.speed) {\n\t\t\tcase SPEED_10000: s = \"10Gbps\"; break;\n\t\t\tcase SPEED_1000:  s = \"1000Mbps\"; break;\n\t\t\tcase SPEED_100:   s = \"100Mbps\"; break;\n\t\t}\n\n\t\tnetdev_info(p->dev, \"link up, %s, %s-duplex\\n\",\n\t\t\t    s, p->link_config.duplex == DUPLEX_FULL\n\t\t\t    ? \"full\" : \"half\");\n\t}\n}\n\nvoid t1_link_negotiated(struct adapter *adapter, int port_id, int link_stat,\n\t\t\tint speed, int duplex, int pause)\n{\n\tstruct port_info *p = &adapter->port[port_id];\n\n\tif (link_stat != netif_carrier_ok(p->dev)) {\n\t\tif (link_stat)\n\t\t\tnetif_carrier_on(p->dev);\n\t\telse\n\t\t\tnetif_carrier_off(p->dev);\n\t\tlink_report(p);\n\n\t\t \n\t\tif ((speed > 0) && (adapter->params.nports > 1)) {\n\t\t\tunsigned int sched_speed = 10;\n\t\t\tswitch (speed) {\n\t\t\tcase SPEED_1000:\n\t\t\t\tsched_speed = 1000;\n\t\t\t\tbreak;\n\t\t\tcase SPEED_100:\n\t\t\t\tsched_speed = 100;\n\t\t\t\tbreak;\n\t\t\tcase SPEED_10:\n\t\t\t\tsched_speed = 10;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt1_sched_update_parms(adapter->sge, port_id, 0, sched_speed);\n\t\t}\n\t}\n}\n\nstatic void link_start(struct port_info *p)\n{\n\tstruct cmac *mac = p->mac;\n\n\tmac->ops->reset(mac);\n\tif (mac->ops->macaddress_set)\n\t\tmac->ops->macaddress_set(mac, p->dev->dev_addr);\n\tt1_set_rxmode(p->dev);\n\tt1_link_start(p->phy, mac, &p->link_config);\n\tmac->ops->enable(mac, MAC_DIRECTION_RX | MAC_DIRECTION_TX);\n}\n\nstatic void enable_hw_csum(struct adapter *adapter)\n{\n\tif (adapter->port[0].dev->hw_features & NETIF_F_TSO)\n\t\tt1_tp_set_ip_checksum_offload(adapter->tp, 1);\t \n\tt1_tp_set_tcp_checksum_offload(adapter->tp, 1);\n}\n\n \nstatic int cxgb_up(struct adapter *adapter)\n{\n\tint err = 0;\n\n\tif (!(adapter->flags & FULL_INIT_DONE)) {\n\t\terr = t1_init_hw_modules(adapter);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tenable_hw_csum(adapter);\n\t\tadapter->flags |= FULL_INIT_DONE;\n\t}\n\n\tt1_interrupts_clear(adapter);\n\n\tadapter->params.has_msi = !disable_msi && !pci_enable_msi(adapter->pdev);\n\terr = request_threaded_irq(adapter->pdev->irq, t1_interrupt,\n\t\t\t\t   t1_interrupt_thread,\n\t\t\t\t   adapter->params.has_msi ? 0 : IRQF_SHARED,\n\t\t\t\t   adapter->name, adapter);\n\tif (err) {\n\t\tif (adapter->params.has_msi)\n\t\t\tpci_disable_msi(adapter->pdev);\n\n\t\tgoto out_err;\n\t}\n\n\tt1_sge_start(adapter->sge);\n\tt1_interrupts_enable(adapter);\nout_err:\n\treturn err;\n}\n\n \nstatic void cxgb_down(struct adapter *adapter)\n{\n\tt1_sge_stop(adapter->sge);\n\tt1_interrupts_disable(adapter);\n\tfree_irq(adapter->pdev->irq, adapter);\n\tif (adapter->params.has_msi)\n\t\tpci_disable_msi(adapter->pdev);\n}\n\nstatic int cxgb_open(struct net_device *dev)\n{\n\tint err;\n\tstruct adapter *adapter = dev->ml_priv;\n\tint other_ports = adapter->open_device_map & PORT_MASK;\n\n\tnapi_enable(&adapter->napi);\n\tif (!adapter->open_device_map && (err = cxgb_up(adapter)) < 0) {\n\t\tnapi_disable(&adapter->napi);\n\t\treturn err;\n\t}\n\n\t__set_bit(dev->if_port, &adapter->open_device_map);\n\tlink_start(&adapter->port[dev->if_port]);\n\tnetif_start_queue(dev);\n\tif (!other_ports && adapter->params.stats_update_period)\n\t\tschedule_mac_stats_update(adapter,\n\t\t\t\t\t  adapter->params.stats_update_period);\n\n\tt1_vlan_mode(adapter, dev->features);\n\treturn 0;\n}\n\nstatic int cxgb_close(struct net_device *dev)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tstruct port_info *p = &adapter->port[dev->if_port];\n\tstruct cmac *mac = p->mac;\n\n\tnetif_stop_queue(dev);\n\tnapi_disable(&adapter->napi);\n\tmac->ops->disable(mac, MAC_DIRECTION_TX | MAC_DIRECTION_RX);\n\tnetif_carrier_off(dev);\n\n\tclear_bit(dev->if_port, &adapter->open_device_map);\n\tif (adapter->params.stats_update_period &&\n\t    !(adapter->open_device_map & PORT_MASK)) {\n\t\t \n\t\tsmp_mb__after_atomic();\n\t\tspin_lock(&adapter->work_lock);    \n\t\tspin_unlock(&adapter->work_lock);\n\t\tcancel_mac_stats_update(adapter);\n\t}\n\n\tif (!adapter->open_device_map)\n\t\tcxgb_down(adapter);\n\treturn 0;\n}\n\nstatic struct net_device_stats *t1_get_stats(struct net_device *dev)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tstruct port_info *p = &adapter->port[dev->if_port];\n\tstruct net_device_stats *ns = &dev->stats;\n\tconst struct cmac_statistics *pstats;\n\n\t \n\tpstats = p->mac->ops->statistics_update(p->mac,\n\t\t\t\t\t\tMAC_STATS_UPDATE_FULL);\n\n\tns->tx_packets = pstats->TxUnicastFramesOK +\n\t\tpstats->TxMulticastFramesOK + pstats->TxBroadcastFramesOK;\n\n\tns->rx_packets = pstats->RxUnicastFramesOK +\n\t\tpstats->RxMulticastFramesOK + pstats->RxBroadcastFramesOK;\n\n\tns->tx_bytes = pstats->TxOctetsOK;\n\tns->rx_bytes = pstats->RxOctetsOK;\n\n\tns->tx_errors = pstats->TxLateCollisions + pstats->TxLengthErrors +\n\t\tpstats->TxUnderrun + pstats->TxFramesAbortedDueToXSCollisions;\n\tns->rx_errors = pstats->RxDataErrors + pstats->RxJabberErrors +\n\t\tpstats->RxFCSErrors + pstats->RxAlignErrors +\n\t\tpstats->RxSequenceErrors + pstats->RxFrameTooLongErrors +\n\t\tpstats->RxSymbolErrors + pstats->RxRuntErrors;\n\n\tns->multicast  = pstats->RxMulticastFramesOK;\n\tns->collisions = pstats->TxTotalCollisions;\n\n\t \n\tns->rx_length_errors = pstats->RxFrameTooLongErrors +\n\t\tpstats->RxJabberErrors;\n\tns->rx_over_errors   = 0;\n\tns->rx_crc_errors    = pstats->RxFCSErrors;\n\tns->rx_frame_errors  = pstats->RxAlignErrors;\n\tns->rx_fifo_errors   = 0;\n\tns->rx_missed_errors = 0;\n\n\t \n\tns->tx_aborted_errors   = pstats->TxFramesAbortedDueToXSCollisions;\n\tns->tx_carrier_errors   = 0;\n\tns->tx_fifo_errors      = pstats->TxUnderrun;\n\tns->tx_heartbeat_errors = 0;\n\tns->tx_window_errors    = pstats->TxLateCollisions;\n\treturn ns;\n}\n\nstatic u32 get_msglevel(struct net_device *dev)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\n\treturn adapter->msg_enable;\n}\n\nstatic void set_msglevel(struct net_device *dev, u32 val)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\n\tadapter->msg_enable = val;\n}\n\nstatic const char stats_strings[][ETH_GSTRING_LEN] = {\n\t\"TxOctetsOK\",\n\t\"TxOctetsBad\",\n\t\"TxUnicastFramesOK\",\n\t\"TxMulticastFramesOK\",\n\t\"TxBroadcastFramesOK\",\n\t\"TxPauseFrames\",\n\t\"TxFramesWithDeferredXmissions\",\n\t\"TxLateCollisions\",\n\t\"TxTotalCollisions\",\n\t\"TxFramesAbortedDueToXSCollisions\",\n\t\"TxUnderrun\",\n\t\"TxLengthErrors\",\n\t\"TxInternalMACXmitError\",\n\t\"TxFramesWithExcessiveDeferral\",\n\t\"TxFCSErrors\",\n\t\"TxJumboFramesOk\",\n\t\"TxJumboOctetsOk\",\n\t\n\t\"RxOctetsOK\",\n\t\"RxOctetsBad\",\n\t\"RxUnicastFramesOK\",\n\t\"RxMulticastFramesOK\",\n\t\"RxBroadcastFramesOK\",\n\t\"RxPauseFrames\",\n\t\"RxFCSErrors\",\n\t\"RxAlignErrors\",\n\t\"RxSymbolErrors\",\n\t\"RxDataErrors\",\n\t\"RxSequenceErrors\",\n\t\"RxRuntErrors\",\n\t\"RxJabberErrors\",\n\t\"RxInternalMACRcvError\",\n\t\"RxInRangeLengthErrors\",\n\t\"RxOutOfRangeLengthField\",\n\t\"RxFrameTooLongErrors\",\n\t\"RxJumboFramesOk\",\n\t\"RxJumboOctetsOk\",\n\n\t \n\t\"RxCsumGood\",\n\t\"TxCsumOffload\",\n\t\"TxTso\",\n\t\"RxVlan\",\n\t\"TxVlan\",\n\t\"TxNeedHeadroom\", \n\t\n\t \n\t\"rx drops\",\n\t\"pure_rsps\",\n\t\"unhandled irqs\",\n\t\"respQ_empty\",\n\t\"respQ_overflow\",\n\t\"freelistQ_empty\",\n\t\"pkt_too_big\",\n\t\"pkt_mismatch\",\n\t\"cmdQ_full0\",\n\t\"cmdQ_full1\",\n\n\t\"espi_DIP2ParityErr\",\n\t\"espi_DIP4Err\",\n\t\"espi_RxDrops\",\n\t\"espi_TxDrops\",\n\t\"espi_RxOvfl\",\n\t\"espi_ParityErr\"\n};\n\n#define T2_REGMAP_SIZE (3 * 1024)\n\nstatic int get_regs_len(struct net_device *dev)\n{\n\treturn T2_REGMAP_SIZE;\n}\n\nstatic void get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(info->bus_info));\n}\n\nstatic int get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(stats_strings);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\tmemcpy(data, stats_strings, sizeof(stats_strings));\n}\n\nstatic void get_stats(struct net_device *dev, struct ethtool_stats *stats,\n\t\t      u64 *data)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tstruct cmac *mac = adapter->port[dev->if_port].mac;\n\tconst struct cmac_statistics *s;\n\tconst struct sge_intr_counts *t;\n\tstruct sge_port_stats ss;\n\n\ts = mac->ops->statistics_update(mac, MAC_STATS_UPDATE_FULL);\n\tt = t1_sge_get_intr_counts(adapter->sge);\n\tt1_sge_get_port_stats(adapter->sge, dev->if_port, &ss);\n\n\t*data++ = s->TxOctetsOK;\n\t*data++ = s->TxOctetsBad;\n\t*data++ = s->TxUnicastFramesOK;\n\t*data++ = s->TxMulticastFramesOK;\n\t*data++ = s->TxBroadcastFramesOK;\n\t*data++ = s->TxPauseFrames;\n\t*data++ = s->TxFramesWithDeferredXmissions;\n\t*data++ = s->TxLateCollisions;\n\t*data++ = s->TxTotalCollisions;\n\t*data++ = s->TxFramesAbortedDueToXSCollisions;\n\t*data++ = s->TxUnderrun;\n\t*data++ = s->TxLengthErrors;\n\t*data++ = s->TxInternalMACXmitError;\n\t*data++ = s->TxFramesWithExcessiveDeferral;\n\t*data++ = s->TxFCSErrors;\n\t*data++ = s->TxJumboFramesOK;\n\t*data++ = s->TxJumboOctetsOK;\n\n\t*data++ = s->RxOctetsOK;\n\t*data++ = s->RxOctetsBad;\n\t*data++ = s->RxUnicastFramesOK;\n\t*data++ = s->RxMulticastFramesOK;\n\t*data++ = s->RxBroadcastFramesOK;\n\t*data++ = s->RxPauseFrames;\n\t*data++ = s->RxFCSErrors;\n\t*data++ = s->RxAlignErrors;\n\t*data++ = s->RxSymbolErrors;\n\t*data++ = s->RxDataErrors;\n\t*data++ = s->RxSequenceErrors;\n\t*data++ = s->RxRuntErrors;\n\t*data++ = s->RxJabberErrors;\n\t*data++ = s->RxInternalMACRcvError;\n\t*data++ = s->RxInRangeLengthErrors;\n\t*data++ = s->RxOutOfRangeLengthField;\n\t*data++ = s->RxFrameTooLongErrors;\n\t*data++ = s->RxJumboFramesOK;\n\t*data++ = s->RxJumboOctetsOK;\n\n\t*data++ = ss.rx_cso_good;\n\t*data++ = ss.tx_cso;\n\t*data++ = ss.tx_tso;\n\t*data++ = ss.vlan_xtract;\n\t*data++ = ss.vlan_insert;\n\t*data++ = ss.tx_need_hdrroom;\n\t\n\t*data++ = t->rx_drops;\n\t*data++ = t->pure_rsps;\n\t*data++ = t->unhandled_irqs;\n\t*data++ = t->respQ_empty;\n\t*data++ = t->respQ_overflow;\n\t*data++ = t->freelistQ_empty;\n\t*data++ = t->pkt_too_big;\n\t*data++ = t->pkt_mismatch;\n\t*data++ = t->cmdQ_full[0];\n\t*data++ = t->cmdQ_full[1];\n\n\tif (adapter->espi) {\n\t\tconst struct espi_intr_counts *e;\n\n\t\te = t1_espi_get_intr_counts(adapter->espi);\n\t\t*data++ = e->DIP2_parity_err;\n\t\t*data++ = e->DIP4_err;\n\t\t*data++ = e->rx_drops;\n\t\t*data++ = e->tx_drops;\n\t\t*data++ = e->rx_ovflw;\n\t\t*data++ = e->parity_err;\n\t}\n}\n\nstatic inline void reg_block_dump(struct adapter *ap, void *buf,\n\t\t\t\t  unsigned int start, unsigned int end)\n{\n\tu32 *p = buf + start;\n\n\tfor ( ; start <= end; start += sizeof(u32))\n\t\t*p++ = readl(ap->regs + start);\n}\n\nstatic void get_regs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t     void *buf)\n{\n\tstruct adapter *ap = dev->ml_priv;\n\n\t \n\tregs->version = 2;\n\n\tmemset(buf, 0, T2_REGMAP_SIZE);\n\treg_block_dump(ap, buf, 0, A_SG_RESPACCUTIMER);\n\treg_block_dump(ap, buf, A_MC3_CFG, A_MC4_INT_CAUSE);\n\treg_block_dump(ap, buf, A_TPI_ADDR, A_TPI_PAR);\n\treg_block_dump(ap, buf, A_TP_IN_CONFIG, A_TP_TX_DROP_COUNT);\n\treg_block_dump(ap, buf, A_RAT_ROUTE_CONTROL, A_RAT_INTR_CAUSE);\n\treg_block_dump(ap, buf, A_CSPI_RX_AE_WM, A_CSPI_INTR_ENABLE);\n\treg_block_dump(ap, buf, A_ESPI_SCH_TOKEN0, A_ESPI_GOSTAT);\n\treg_block_dump(ap, buf, A_ULP_ULIMIT, A_ULP_PIO_CTRL);\n\treg_block_dump(ap, buf, A_PL_ENABLE, A_PL_CAUSE);\n\treg_block_dump(ap, buf, A_MC5_CONFIG, A_MC5_MASK_WRITE_CMD);\n}\n\nstatic int get_link_ksettings(struct net_device *dev,\n\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tstruct port_info *p = &adapter->port[dev->if_port];\n\tu32 supported, advertising;\n\n\tsupported = p->link_config.supported;\n\tadvertising = p->link_config.advertising;\n\n\tif (netif_carrier_ok(dev)) {\n\t\tcmd->base.speed = p->link_config.speed;\n\t\tcmd->base.duplex = p->link_config.duplex;\n\t} else {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tcmd->base.port = (supported & SUPPORTED_TP) ? PORT_TP : PORT_FIBRE;\n\tcmd->base.phy_address = p->phy->mdio.prtad;\n\tcmd->base.autoneg = p->link_config.autoneg;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int speed_duplex_to_caps(int speed, int duplex)\n{\n\tint cap = 0;\n\n\tswitch (speed) {\n\tcase SPEED_10:\n\t\tif (duplex == DUPLEX_FULL)\n\t\t\tcap = SUPPORTED_10baseT_Full;\n\t\telse\n\t\t\tcap = SUPPORTED_10baseT_Half;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tif (duplex == DUPLEX_FULL)\n\t\t\tcap = SUPPORTED_100baseT_Full;\n\t\telse\n\t\t\tcap = SUPPORTED_100baseT_Half;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tif (duplex == DUPLEX_FULL)\n\t\t\tcap = SUPPORTED_1000baseT_Full;\n\t\telse\n\t\t\tcap = SUPPORTED_1000baseT_Half;\n\t\tbreak;\n\tcase SPEED_10000:\n\t\tif (duplex == DUPLEX_FULL)\n\t\t\tcap = SUPPORTED_10000baseT_Full;\n\t}\n\treturn cap;\n}\n\n#define ADVERTISED_MASK (ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full | \\\n\t\t      ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full | \\\n\t\t      ADVERTISED_1000baseT_Half | ADVERTISED_1000baseT_Full | \\\n\t\t      ADVERTISED_10000baseT_Full)\n\nstatic int set_link_ksettings(struct net_device *dev,\n\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tstruct port_info *p = &adapter->port[dev->if_port];\n\tstruct link_config *lc = &p->link_config;\n\tu32 advertising;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\tif (!(lc->supported & SUPPORTED_Autoneg))\n\t\treturn -EOPNOTSUPP;              \n\n\tif (cmd->base.autoneg == AUTONEG_DISABLE) {\n\t\tu32 speed = cmd->base.speed;\n\t\tint cap = speed_duplex_to_caps(speed, cmd->base.duplex);\n\n\t\tif (!(lc->supported & cap) || (speed == SPEED_1000))\n\t\t\treturn -EINVAL;\n\t\tlc->requested_speed = speed;\n\t\tlc->requested_duplex = cmd->base.duplex;\n\t\tlc->advertising = 0;\n\t} else {\n\t\tadvertising &= ADVERTISED_MASK;\n\t\tif (advertising & (advertising - 1))\n\t\t\tadvertising = lc->supported;\n\t\tadvertising &= lc->supported;\n\t\tif (!advertising)\n\t\t\treturn -EINVAL;\n\t\tlc->requested_speed = SPEED_INVALID;\n\t\tlc->requested_duplex = DUPLEX_INVALID;\n\t\tlc->advertising = advertising | ADVERTISED_Autoneg;\n\t}\n\tlc->autoneg = cmd->base.autoneg;\n\tif (netif_running(dev))\n\t\tt1_link_start(p->phy, p->mac, lc);\n\treturn 0;\n}\n\nstatic void get_pauseparam(struct net_device *dev,\n\t\t\t   struct ethtool_pauseparam *epause)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tstruct port_info *p = &adapter->port[dev->if_port];\n\n\tepause->autoneg = (p->link_config.requested_fc & PAUSE_AUTONEG) != 0;\n\tepause->rx_pause = (p->link_config.fc & PAUSE_RX) != 0;\n\tepause->tx_pause = (p->link_config.fc & PAUSE_TX) != 0;\n}\n\nstatic int set_pauseparam(struct net_device *dev,\n\t\t\t  struct ethtool_pauseparam *epause)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tstruct port_info *p = &adapter->port[dev->if_port];\n\tstruct link_config *lc = &p->link_config;\n\n\tif (epause->autoneg == AUTONEG_DISABLE)\n\t\tlc->requested_fc = 0;\n\telse if (lc->supported & SUPPORTED_Autoneg)\n\t\tlc->requested_fc = PAUSE_AUTONEG;\n\telse\n\t\treturn -EINVAL;\n\n\tif (epause->rx_pause)\n\t\tlc->requested_fc |= PAUSE_RX;\n\tif (epause->tx_pause)\n\t\tlc->requested_fc |= PAUSE_TX;\n\tif (lc->autoneg == AUTONEG_ENABLE) {\n\t\tif (netif_running(dev))\n\t\t\tt1_link_start(p->phy, p->mac, lc);\n\t} else {\n\t\tlc->fc = lc->requested_fc & (PAUSE_RX | PAUSE_TX);\n\t\tif (netif_running(dev))\n\t\t\tp->mac->ops->set_speed_duplex_fc(p->mac, -1, -1,\n\t\t\t\t\t\t\t lc->fc);\n\t}\n\treturn 0;\n}\n\nstatic void get_sge_param(struct net_device *dev, struct ethtool_ringparam *e,\n\t\t\t  struct kernel_ethtool_ringparam *kernel_e,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tint jumbo_fl = t1_is_T1B(adapter) ? 1 : 0;\n\n\te->rx_max_pending = MAX_RX_BUFFERS;\n\te->rx_jumbo_max_pending = MAX_RX_JUMBO_BUFFERS;\n\te->tx_max_pending = MAX_CMDQ_ENTRIES;\n\n\te->rx_pending = adapter->params.sge.freelQ_size[!jumbo_fl];\n\te->rx_jumbo_pending = adapter->params.sge.freelQ_size[jumbo_fl];\n\te->tx_pending = adapter->params.sge.cmdQ_size[0];\n}\n\nstatic int set_sge_param(struct net_device *dev, struct ethtool_ringparam *e,\n\t\t\t struct kernel_ethtool_ringparam *kernel_e,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tint jumbo_fl = t1_is_T1B(adapter) ? 1 : 0;\n\n\tif (e->rx_pending > MAX_RX_BUFFERS || e->rx_mini_pending ||\n\t    e->rx_jumbo_pending > MAX_RX_JUMBO_BUFFERS ||\n\t    e->tx_pending > MAX_CMDQ_ENTRIES ||\n\t    e->rx_pending < MIN_FL_ENTRIES ||\n\t    e->rx_jumbo_pending < MIN_FL_ENTRIES ||\n\t    e->tx_pending < (adapter->params.nports + 1) * (MAX_SKB_FRAGS + 1))\n\t\treturn -EINVAL;\n\n\tif (adapter->flags & FULL_INIT_DONE)\n\t\treturn -EBUSY;\n\n\tadapter->params.sge.freelQ_size[!jumbo_fl] = e->rx_pending;\n\tadapter->params.sge.freelQ_size[jumbo_fl] = e->rx_jumbo_pending;\n\tadapter->params.sge.cmdQ_size[0] = e->tx_pending;\n\tadapter->params.sge.cmdQ_size[1] = e->tx_pending > MAX_CMDQ1_ENTRIES ?\n\t\tMAX_CMDQ1_ENTRIES : e->tx_pending;\n\treturn 0;\n}\n\nstatic int set_coalesce(struct net_device *dev, struct ethtool_coalesce *c,\n\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\n\tadapter->params.sge.rx_coalesce_usecs = c->rx_coalesce_usecs;\n\tadapter->params.sge.coalesce_enable = c->use_adaptive_rx_coalesce;\n\tadapter->params.sge.sample_interval_usecs = c->rate_sample_interval;\n\tt1_sge_set_coalesce_params(adapter->sge, &adapter->params.sge);\n\treturn 0;\n}\n\nstatic int get_coalesce(struct net_device *dev, struct ethtool_coalesce *c,\n\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\n\tc->rx_coalesce_usecs = adapter->params.sge.rx_coalesce_usecs;\n\tc->rate_sample_interval = adapter->params.sge.sample_interval_usecs;\n\tc->use_adaptive_rx_coalesce = adapter->params.sge.coalesce_enable;\n\treturn 0;\n}\n\nstatic int get_eeprom_len(struct net_device *dev)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\n\treturn t1_is_asic(adapter) ? EEPROM_SIZE : 0;\n}\n\n#define EEPROM_MAGIC(ap) \\\n\t(PCI_VENDOR_ID_CHELSIO | ((ap)->params.chip_version << 16))\n\nstatic int get_eeprom(struct net_device *dev, struct ethtool_eeprom *e,\n\t\t      u8 *data)\n{\n\tint i;\n\tu8 buf[EEPROM_SIZE] __attribute__((aligned(4)));\n\tstruct adapter *adapter = dev->ml_priv;\n\n\te->magic = EEPROM_MAGIC(adapter);\n\tfor (i = e->offset & ~3; i < e->offset + e->len; i += sizeof(u32))\n\t\tt1_seeprom_read(adapter, i, (__le32 *)&buf[i]);\n\tmemcpy(data, buf + e->offset, e->len);\n\treturn 0;\n}\n\nstatic const struct ethtool_ops t1_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE_RX |\n\t\t\t\t     ETHTOOL_COALESCE_RATE_SAMPLE_INTERVAL,\n\t.get_drvinfo       = get_drvinfo,\n\t.get_msglevel      = get_msglevel,\n\t.set_msglevel      = set_msglevel,\n\t.get_ringparam     = get_sge_param,\n\t.set_ringparam     = set_sge_param,\n\t.get_coalesce      = get_coalesce,\n\t.set_coalesce      = set_coalesce,\n\t.get_eeprom_len    = get_eeprom_len,\n\t.get_eeprom        = get_eeprom,\n\t.get_pauseparam    = get_pauseparam,\n\t.set_pauseparam    = set_pauseparam,\n\t.get_link          = ethtool_op_get_link,\n\t.get_strings       = get_strings,\n\t.get_sset_count\t   = get_sset_count,\n\t.get_ethtool_stats = get_stats,\n\t.get_regs_len      = get_regs_len,\n\t.get_regs          = get_regs,\n\t.get_link_ksettings = get_link_ksettings,\n\t.set_link_ksettings = set_link_ksettings,\n};\n\nstatic int t1_ioctl(struct net_device *dev, struct ifreq *req, int cmd)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tstruct mdio_if_info *mdio = &adapter->port[dev->if_port].phy->mdio;\n\n\treturn mdio_mii_ioctl(mdio, if_mii(req), cmd);\n}\n\nstatic int t1_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tint ret;\n\tstruct adapter *adapter = dev->ml_priv;\n\tstruct cmac *mac = adapter->port[dev->if_port].mac;\n\n\tif (!mac->ops->set_mtu)\n\t\treturn -EOPNOTSUPP;\n\tif ((ret = mac->ops->set_mtu(mac, new_mtu)))\n\t\treturn ret;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic int t1_set_mac_addr(struct net_device *dev, void *p)\n{\n\tstruct adapter *adapter = dev->ml_priv;\n\tstruct cmac *mac = adapter->port[dev->if_port].mac;\n\tstruct sockaddr *addr = p;\n\n\tif (!mac->ops->macaddress_set)\n\t\treturn -EOPNOTSUPP;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\tmac->ops->macaddress_set(mac, dev->dev_addr);\n\treturn 0;\n}\n\nstatic netdev_features_t t1_fix_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\t \n\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\n\telse\n\t\tfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\n\n\treturn features;\n}\n\nstatic int t1_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tnetdev_features_t changed = dev->features ^ features;\n\tstruct adapter *adapter = dev->ml_priv;\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tt1_vlan_mode(adapter, features);\n\n\treturn 0;\n}\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void t1_netpoll(struct net_device *dev)\n{\n\tunsigned long flags;\n\tstruct adapter *adapter = dev->ml_priv;\n\n\tlocal_irq_save(flags);\n\tt1_interrupt(adapter->pdev->irq, adapter);\n\tlocal_irq_restore(flags);\n}\n#endif\n\n \nstatic void mac_stats_task(struct work_struct *work)\n{\n\tint i;\n\tstruct adapter *adapter =\n\t\tcontainer_of(work, struct adapter, stats_update_task.work);\n\n\tfor_each_port(adapter, i) {\n\t\tstruct port_info *p = &adapter->port[i];\n\n\t\tif (netif_running(p->dev))\n\t\t\tp->mac->ops->statistics_update(p->mac,\n\t\t\t\t\t\t       MAC_STATS_UPDATE_FAST);\n\t}\n\n\t \n\tspin_lock(&adapter->work_lock);\n\tif (adapter->open_device_map & PORT_MASK)\n\t\tschedule_mac_stats_update(adapter,\n\t\t\t\t\t  adapter->params.stats_update_period);\n\tspin_unlock(&adapter->work_lock);\n}\n\nstatic const struct net_device_ops cxgb_netdev_ops = {\n\t.ndo_open\t\t= cxgb_open,\n\t.ndo_stop\t\t= cxgb_close,\n\t.ndo_start_xmit\t\t= t1_start_xmit,\n\t.ndo_get_stats\t\t= t1_get_stats,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_rx_mode\t= t1_set_rxmode,\n\t.ndo_eth_ioctl\t\t= t1_ioctl,\n\t.ndo_change_mtu\t\t= t1_change_mtu,\n\t.ndo_set_mac_address\t= t1_set_mac_addr,\n\t.ndo_fix_features\t= t1_fix_features,\n\t.ndo_set_features\t= t1_set_features,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= t1_netpoll,\n#endif\n};\n\nstatic int init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tunsigned long mmio_start, mmio_len;\n\tconst struct board_info *bi;\n\tstruct adapter *adapter = NULL;\n\tstruct port_info *pi;\n\tint i, err;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\n\t\tpr_err(\"%s: cannot find PCI device memory base address\\n\",\n\t\t       pci_name(pdev));\n\t\terr = -ENODEV;\n\t\tgoto out_disable_pdev;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tpr_err(\"%s: no usable DMA configuration\\n\", pci_name(pdev));\n\t\tgoto out_disable_pdev;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err) {\n\t\tpr_err(\"%s: cannot obtain PCI resources\\n\", pci_name(pdev));\n\t\tgoto out_disable_pdev;\n\t}\n\n\tpci_set_master(pdev);\n\n\tmmio_start = pci_resource_start(pdev, 0);\n\tmmio_len = pci_resource_len(pdev, 0);\n\tbi = t1_get_board_info(ent->driver_data);\n\n\tfor (i = 0; i < bi->port_number; ++i) {\n\t\tstruct net_device *netdev;\n\n\t\tnetdev = alloc_etherdev(adapter ? 0 : sizeof(*adapter));\n\t\tif (!netdev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free_dev;\n\t\t}\n\n\t\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\n\t\tif (!adapter) {\n\t\t\tadapter = netdev_priv(netdev);\n\t\t\tadapter->pdev = pdev;\n\t\t\tadapter->port[0].dev = netdev;   \n\n\t\t\tadapter->regs = ioremap(mmio_start, mmio_len);\n\t\t\tif (!adapter->regs) {\n\t\t\t\tpr_err(\"%s: cannot map device registers\\n\",\n\t\t\t\t       pci_name(pdev));\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_free_dev;\n\t\t\t}\n\n\t\t\tif (t1_get_board_rev(adapter, bi, &adapter->params)) {\n\t\t\t\terr = -ENODEV;\t   \n\t\t\t\tgoto out_free_dev;\n\t\t\t}\n\n\t\t\tadapter->name = pci_name(pdev);\n\t\t\tadapter->msg_enable = dflt_msg_enable;\n\t\t\tadapter->mmio_len = mmio_len;\n\n\t\t\tspin_lock_init(&adapter->tpi_lock);\n\t\t\tspin_lock_init(&adapter->work_lock);\n\t\t\tspin_lock_init(&adapter->async_lock);\n\t\t\tspin_lock_init(&adapter->mac_lock);\n\n\t\t\tINIT_DELAYED_WORK(&adapter->stats_update_task,\n\t\t\t\t\t  mac_stats_task);\n\n\t\t\tpci_set_drvdata(pdev, netdev);\n\t\t}\n\n\t\tpi = &adapter->port[i];\n\t\tpi->dev = netdev;\n\t\tnetif_carrier_off(netdev);\n\t\tnetdev->irq = pdev->irq;\n\t\tnetdev->if_port = i;\n\t\tnetdev->mem_start = mmio_start;\n\t\tnetdev->mem_end = mmio_start + mmio_len - 1;\n\t\tnetdev->ml_priv = adapter;\n\t\tnetdev->hw_features |= NETIF_F_SG | NETIF_F_IP_CSUM |\n\t\t\tNETIF_F_RXCSUM;\n\t\tnetdev->features |= NETIF_F_SG | NETIF_F_IP_CSUM |\n\t\t\tNETIF_F_RXCSUM | NETIF_F_LLTX | NETIF_F_HIGHDMA;\n\n\t\tif (vlan_tso_capable(adapter)) {\n\t\t\tnetdev->features |=\n\t\t\t\tNETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\tNETIF_F_HW_VLAN_CTAG_RX;\n\t\t\tnetdev->hw_features |= NETIF_F_HW_VLAN_CTAG_RX;\n\n\t\t\t \n\t\t\tif (!(is_T2(adapter)) || bi->port_number != 4) {\n\t\t\t\tnetdev->hw_features |= NETIF_F_TSO;\n\t\t\t\tnetdev->features |= NETIF_F_TSO;\n\t\t\t}\n\t\t}\n\n\t\tnetdev->netdev_ops = &cxgb_netdev_ops;\n\t\tnetdev->hard_header_len += (netdev->hw_features & NETIF_F_TSO) ?\n\t\t\tsizeof(struct cpl_tx_pkt_lso) : sizeof(struct cpl_tx_pkt);\n\n\t\tnetif_napi_add(netdev, &adapter->napi, t1_poll);\n\n\t\tnetdev->ethtool_ops = &t1_ethtool_ops;\n\n\t\tswitch (bi->board) {\n\t\tcase CHBT_BOARD_CHT110:\n\t\tcase CHBT_BOARD_N110:\n\t\tcase CHBT_BOARD_N210:\n\t\tcase CHBT_BOARD_CHT210:\n\t\t\tnetdev->max_mtu = PM3393_MAX_FRAME_SIZE -\n\t\t\t\t\t  (ETH_HLEN + ETH_FCS_LEN);\n\t\t\tbreak;\n\t\tcase CHBT_BOARD_CHN204:\n\t\t\tnetdev->max_mtu = VSC7326_MAX_MTU;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev->max_mtu = ETH_DATA_LEN;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (t1_init_sw_modules(adapter, bi) < 0) {\n\t\terr = -ENODEV;\n\t\tgoto out_free_dev;\n\t}\n\n\t \n\tfor (i = 0; i < bi->port_number; ++i) {\n\t\terr = register_netdev(adapter->port[i].dev);\n\t\tif (err)\n\t\t\tpr_warn(\"%s: cannot register net device %s, skipping\\n\",\n\t\t\t\tpci_name(pdev), adapter->port[i].dev->name);\n\t\telse {\n\t\t\t \n\t\t\tif (!adapter->registered_device_map)\n\t\t\t\tadapter->name = adapter->port[i].dev->name;\n\n\t\t\t__set_bit(i, &adapter->registered_device_map);\n\t\t}\n\t}\n\tif (!adapter->registered_device_map) {\n\t\tpr_err(\"%s: could not register any net devices\\n\",\n\t\t       pci_name(pdev));\n\t\terr = -EINVAL;\n\t\tgoto out_release_adapter_res;\n\t}\n\n\tpr_info(\"%s: %s (rev %d), %s %dMHz/%d-bit\\n\",\n\t\tadapter->name, bi->desc, adapter->params.chip_revision,\n\t\tadapter->params.pci.is_pcix ? \"PCIX\" : \"PCI\",\n\t\tadapter->params.pci.speed, adapter->params.pci.width);\n\n\t \n\tif (t1powersave)\n\t\tadapter->t1powersave = LCLOCK;\t \n\telse\n\t\tadapter->t1powersave = HCLOCK;\n\tif (t1_is_T1B(adapter))\n\t\tt1_clock(adapter, t1powersave);\n\n\treturn 0;\n\nout_release_adapter_res:\n\tt1_free_sw_modules(adapter);\nout_free_dev:\n\tif (adapter) {\n\t\tif (adapter->regs)\n\t\t\tiounmap(adapter->regs);\n\t\tfor (i = bi->port_number - 1; i >= 0; --i)\n\t\t\tif (adapter->port[i].dev)\n\t\t\t\tfree_netdev(adapter->port[i].dev);\n\t}\n\tpci_release_regions(pdev);\nout_disable_pdev:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\nstatic void bit_bang(struct adapter *adapter, int bitdata, int nbits)\n{\n\tint data;\n\tint i;\n\tu32 val;\n\n\tenum {\n\t\tS_CLOCK = 1 << 3,\n\t\tS_DATA = 1 << 4\n\t};\n\n\tfor (i = (nbits - 1); i > -1; i--) {\n\n\t\tudelay(50);\n\n\t\tdata = ((bitdata >> i) & 0x1);\n\t\t__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\n\t\tif (data)\n\t\t\tval |= S_DATA;\n\t\telse\n\t\t\tval &= ~S_DATA;\n\n\t\tudelay(50);\n\n\t\t \n\t\tval &= ~S_CLOCK;\n\t\t__t1_tpi_write(adapter, A_ELMER0_GPO, val);\n\n\t\tudelay(50);\n\n\t\t \n\t\tval |= S_CLOCK;\n\t\t__t1_tpi_write(adapter, A_ELMER0_GPO, val);\n\n\t}\n}\n\nstatic int t1_clock(struct adapter *adapter, int mode)\n{\n\tu32 val;\n\tint M_CORE_VAL;\n\tint M_MEM_VAL;\n\n\tenum {\n\t\tM_CORE_BITS\t= 9,\n\t\tT_CORE_VAL\t= 0,\n\t\tT_CORE_BITS\t= 2,\n\t\tN_CORE_VAL\t= 0,\n\t\tN_CORE_BITS\t= 2,\n\t\tM_MEM_BITS\t= 9,\n\t\tT_MEM_VAL\t= 0,\n\t\tT_MEM_BITS\t= 2,\n\t\tN_MEM_VAL\t= 0,\n\t\tN_MEM_BITS\t= 2,\n\t\tNP_LOAD\t\t= 1 << 17,\n\t\tS_LOAD_MEM\t= 1 << 5,\n\t\tS_LOAD_CORE\t= 1 << 6,\n\t\tS_CLOCK\t\t= 1 << 3\n\t};\n\n\tif (!t1_is_T1B(adapter))\n\t\treturn -ENODEV;\t \n\n\tif (mode & 2)\n\t\treturn 0;\t \n\n\tif ((adapter->t1powersave & 1) == (mode & 1))\n\t\treturn -EALREADY;\t \n\n\tif ((mode & 1) == HCLOCK) {\n\t\tM_CORE_VAL = 0x14;\n\t\tM_MEM_VAL = 0x18;\n\t\tadapter->t1powersave = HCLOCK;\t \n\t} else {\n\t\tM_CORE_VAL = 0xe;\n\t\tM_MEM_VAL = 0x10;\n\t\tadapter->t1powersave = LCLOCK;\t \n\t}\n\n\t \n\tspin_lock(&adapter->tpi_lock);\n\n\t \n\t__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval |= NP_LOAD;\n\tudelay(50);\n\t__t1_tpi_write(adapter, A_ELMER0_GPO, val);\n\tudelay(50);\n\t__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval &= ~S_LOAD_CORE;\n\tval &= ~S_CLOCK;\n\t__t1_tpi_write(adapter, A_ELMER0_GPO, val);\n\tudelay(50);\n\n\t \n\tbit_bang(adapter, T_CORE_VAL, T_CORE_BITS);\n\tbit_bang(adapter, N_CORE_VAL, N_CORE_BITS);\n\tbit_bang(adapter, M_CORE_VAL, M_CORE_BITS);\n\tudelay(50);\n\n\t \n\t__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval |= S_LOAD_CORE;\n\tudelay(50);\n\t__t1_tpi_write(adapter, A_ELMER0_GPO, val);\n\tudelay(50);\n\t__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval &= ~S_LOAD_CORE;\n\tudelay(50);\n\t__t1_tpi_write(adapter, A_ELMER0_GPO, val);\n\tudelay(50);\n\n\t \n\t__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval |= NP_LOAD;\n\tudelay(50);\n\t__t1_tpi_write(adapter, A_ELMER0_GPO, val);\n\tudelay(50);\n\t__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval &= ~S_LOAD_MEM;\n\tval &= ~S_CLOCK;\n\tudelay(50);\n\t__t1_tpi_write(adapter, A_ELMER0_GPO, val);\n\tudelay(50);\n\n\t \n\tbit_bang(adapter, T_MEM_VAL, T_MEM_BITS);\n\tbit_bang(adapter, N_MEM_VAL, N_MEM_BITS);\n\tbit_bang(adapter, M_MEM_VAL, M_MEM_BITS);\n\tudelay(50);\n\n\t \n\t__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval |= S_LOAD_MEM;\n\tudelay(50);\n\t__t1_tpi_write(adapter, A_ELMER0_GPO, val);\n\tudelay(50);\n\t__t1_tpi_read(adapter, A_ELMER0_GPO, &val);\n\tval &= ~S_LOAD_MEM;\n\tudelay(50);\n\t__t1_tpi_write(adapter, A_ELMER0_GPO, val);\n\n\tspin_unlock(&adapter->tpi_lock);\n\n\treturn 0;\n}\n\nstatic inline void t1_sw_reset(struct pci_dev *pdev)\n{\n\tpci_write_config_dword(pdev, A_PCICFG_PM_CSR, 3);\n\tpci_write_config_dword(pdev, A_PCICFG_PM_CSR, 0);\n}\n\nstatic void remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct adapter *adapter = dev->ml_priv;\n\tint i;\n\n\tfor_each_port(adapter, i) {\n\t\tif (test_bit(i, &adapter->registered_device_map))\n\t\t\tunregister_netdev(adapter->port[i].dev);\n\t}\n\n\tt1_free_sw_modules(adapter);\n\tiounmap(adapter->regs);\n\n\twhile (--i >= 0) {\n\t\tif (adapter->port[i].dev)\n\t\t\tfree_netdev(adapter->port[i].dev);\n\t}\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tt1_sw_reset(pdev);\n}\n\nstatic struct pci_driver cxgb_pci_driver = {\n\t.name     = DRV_NAME,\n\t.id_table = t1_pci_tbl,\n\t.probe    = init_one,\n\t.remove   = remove_one,\n};\n\nmodule_pci_driver(cxgb_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}