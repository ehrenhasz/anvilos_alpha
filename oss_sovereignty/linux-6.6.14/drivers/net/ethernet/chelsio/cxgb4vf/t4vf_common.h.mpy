{
  "module_name": "t4vf_common.h",
  "hash_id": "cb8d5fb26fc092166c7155caafb4f23b3c8ca1786555b0f55cc6bb12ca03d2ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4vf/t4vf_common.h",
  "human_readable_source": " \n\n#ifndef __T4VF_COMMON_H__\n#define __T4VF_COMMON_H__\n\n#include \"../cxgb4/t4_hw.h\"\n#include \"../cxgb4/t4fw_api.h\"\n\n#define CHELSIO_CHIP_CODE(version, revision) (((version) << 4) | (revision))\n#define CHELSIO_CHIP_VERSION(code) (((code) >> 4) & 0xf)\n#define CHELSIO_CHIP_RELEASE(code) ((code) & 0xf)\n\n \n#define CHELSIO_T4\t\t0x4\n#define CHELSIO_T5\t\t0x5\n#define CHELSIO_T6\t\t0x6\n\nenum chip_type {\n\tT4_A1 = CHELSIO_CHIP_CODE(CHELSIO_T4, 1),\n\tT4_A2 = CHELSIO_CHIP_CODE(CHELSIO_T4, 2),\n\tT4_FIRST_REV\t= T4_A1,\n\tT4_LAST_REV\t= T4_A2,\n\n\tT5_A0 = CHELSIO_CHIP_CODE(CHELSIO_T5, 0),\n\tT5_A1 = CHELSIO_CHIP_CODE(CHELSIO_T5, 1),\n\tT5_FIRST_REV\t= T5_A0,\n\tT5_LAST_REV\t= T5_A1,\n};\n\n \n#define FW_LEN16(fw_struct) FW_CMD_LEN16_V(sizeof(fw_struct) / 16)\n\n \nstruct t4vf_port_stats {\n\t \n\tu64 tx_bcast_bytes;\t\t \n\tu64 tx_bcast_frames;\n\tu64 tx_mcast_bytes;\t\t \n\tu64 tx_mcast_frames;\n\tu64 tx_ucast_bytes;\t\t \n\tu64 tx_ucast_frames;\n\tu64 tx_drop_frames;\t\t \n\tu64 tx_offload_bytes;\t\t \n\tu64 tx_offload_frames;\n\n\t \n\tu64 rx_bcast_bytes;\t\t \n\tu64 rx_bcast_frames;\n\tu64 rx_mcast_bytes;\t\t \n\tu64 rx_mcast_frames;\n\tu64 rx_ucast_bytes;\n\tu64 rx_ucast_frames;\t\t \n\n\tu64 rx_err_frames;\t\t \n};\n\n \ntypedef u16 fw_port_cap16_t;     \ntypedef u32 fw_port_cap32_t;     \n\nenum fw_caps {\n\tFW_CAPS_UNKNOWN\t= 0,\t \n\tFW_CAPS16\t= 1,\t \n\tFW_CAPS32\t= 2,\t \n};\n\nenum cc_pause {\n\tPAUSE_RX\t= 1 << 0,\n\tPAUSE_TX\t= 1 << 1,\n\tPAUSE_AUTONEG\t= 1 << 2\n};\n\nenum cc_fec {\n\tFEC_AUTO\t= 1 << 0,\t \n\tFEC_RS\t\t= 1 << 1,\t \n\tFEC_BASER_RS\t= 1 << 2,\t \n};\n\nstruct link_config {\n\tfw_port_cap32_t pcaps;\t\t \n\tfw_port_cap32_t\tacaps;\t\t \n\tfw_port_cap32_t\tlpacaps;\t \n\n\tfw_port_cap32_t\tspeed_caps;\t \n\tu32\t\tspeed;\t\t \n\n\tenum cc_pause\trequested_fc;\t \n\tenum cc_pause\tfc;\t\t \n\tenum cc_pause   advertised_fc;   \n\n\tenum cc_fec\tauto_fec;\t \n\tenum cc_fec\trequested_fec;\t \n\tenum cc_fec\tfec;\t\t \n\n\tunsigned char\tautoneg;\t \n\n\tunsigned char\tlink_ok;\t \n\tunsigned char\tlink_down_rc;\t \n};\n\n \nstatic inline bool is_x_10g_port(const struct link_config *lc)\n{\n\tfw_port_cap32_t speeds, high_speeds;\n\n\tspeeds = FW_PORT_CAP32_SPEED_V(FW_PORT_CAP32_SPEED_G(lc->pcaps));\n\thigh_speeds =\n\t\tspeeds & ~(FW_PORT_CAP32_SPEED_100M | FW_PORT_CAP32_SPEED_1G);\n\n\treturn high_speeds != 0;\n}\n\n \nstruct dev_params {\n\tu32 fwrev;\t\t\t \n\tu32 tprev;\t\t\t \n};\n\n \nstruct sge_params {\n\tu32 sge_control;\t\t \n\tu32 sge_control2;\t\t \n\tu32 sge_host_page_size;\t\t \n\tu32 sge_egress_queues_per_page;\t \n\tu32 sge_ingress_queues_per_page; \n\tu32 sge_vf_hps;                  \n\tu32 sge_vf_eq_qpp;\t\t \n\tu32 sge_vf_iq_qpp;\t\t \n\tu32 sge_fl_buffer_size[16];\t \n\tu32 sge_ingress_rx_threshold;\t \n\tu32 sge_congestion_control;      \n\tu32 sge_timer_value_0_and_1;\t \n\tu32 sge_timer_value_2_and_3;\n\tu32 sge_timer_value_4_and_5;\n};\n\n \nstruct vpd_params {\n\tu32 cclk;\t\t\t \n};\n\n \nstruct arch_specific_params {\n\tu32 sge_fl_db;\n\tu16 mps_tcam_size;\n};\n\n \nstruct rss_params {\n\tunsigned int mode;\t\t \n\tunion {\n\t    struct {\n\t\tunsigned int synmapen:1;\t \n\t\tunsigned int syn4tupenipv6:1;\t \n\t\tunsigned int syn2tupenipv6:1;\t \n\t\tunsigned int syn4tupenipv4:1;\t \n\t\tunsigned int syn2tupenipv4:1;\t \n\t\tunsigned int ofdmapen:1;\t \n\t\tunsigned int tnlmapen:1;\t \n\t\tunsigned int tnlalllookup:1;\t \n\t\tunsigned int hashtoeplitz:1;\t \n\t    } basicvirtual;\n\t} u;\n};\n\n \nunion rss_vi_config {\n    struct {\n\tu16 defaultq;\t\t\t \n\tunsigned int ip6fourtupen:1;\t \n\tunsigned int ip6twotupen:1;\t \n\tunsigned int ip4fourtupen:1;\t \n\tunsigned int ip4twotupen:1;\t \n\tint udpen;\t\t\t \n    } basicvirtual;\n};\n\n \nstruct vf_resources {\n\tunsigned int nvi;\t\t \n\tunsigned int neq;\t\t \n\tunsigned int nethctrl;\t\t \n\tunsigned int niqflint;\t\t \n\tunsigned int niq;\t\t \n\tunsigned int tc;\t\t \n\tunsigned int pmask;\t\t \n\tunsigned int nexactf;\t\t \n\tunsigned int r_caps;\t\t \n\tunsigned int wx_caps;\t\t \n};\n\n \nstruct adapter_params {\n\tstruct dev_params dev;\t\t \n\tstruct sge_params sge;\t\t \n\tstruct vpd_params vpd;\t\t \n\tstruct rss_params rss;\t\t \n\tstruct vf_resources vfres;\t \n\tstruct arch_specific_params arch;  \n\tenum chip_type chip;\t\t \n\tu8 nports;\t\t\t \n\tu8 fw_caps_support;\t\t \n};\n\n \nstruct mbox_cmd {\n\tu64 cmd[MBOX_LEN / 8];\t\t \n\tu64 timestamp;\t\t\t \n\tu32 seqno;\t\t\t \n\ts16 access;\t\t\t \n\ts16 execute;\t\t\t \n};\n\nstruct mbox_cmd_log {\n\tunsigned int size;\t\t \n\tunsigned int cursor;\t\t \n\tu32 seqno;\t\t\t \n\t \n};\n\n \nstatic inline struct mbox_cmd *mbox_cmd_log_entry(struct mbox_cmd_log *log,\n\t\t\t\t\t\t  unsigned int entry_idx)\n{\n\treturn &((struct mbox_cmd *)&(log)[1])[entry_idx];\n}\n\n#include \"adapter.h\"\n\n#ifndef PCI_VENDOR_ID_CHELSIO\n# define PCI_VENDOR_ID_CHELSIO 0x1425\n#endif\n\n#define for_each_port(adapter, iter) \\\n\tfor (iter = 0; iter < (adapter)->params.nports; iter++)\n\nstatic inline unsigned int core_ticks_per_usec(const struct adapter *adapter)\n{\n\treturn adapter->params.vpd.cclk / 1000;\n}\n\nstatic inline unsigned int us_to_core_ticks(const struct adapter *adapter,\n\t\t\t\t\t    unsigned int us)\n{\n\treturn (us * adapter->params.vpd.cclk) / 1000;\n}\n\nstatic inline unsigned int core_ticks_to_us(const struct adapter *adapter,\n\t\t\t\t\t    unsigned int ticks)\n{\n\treturn (ticks * 1000) / adapter->params.vpd.cclk;\n}\n\nint t4vf_wr_mbox_core(struct adapter *, const void *, int, void *, bool);\n\nstatic inline int t4vf_wr_mbox(struct adapter *adapter, const void *cmd,\n\t\t\t       int size, void *rpl)\n{\n\treturn t4vf_wr_mbox_core(adapter, cmd, size, rpl, true);\n}\n\nstatic inline int t4vf_wr_mbox_ns(struct adapter *adapter, const void *cmd,\n\t\t\t\t  int size, void *rpl)\n{\n\treturn t4vf_wr_mbox_core(adapter, cmd, size, rpl, false);\n}\n\n#define CHELSIO_PCI_ID_VER(dev_id)  ((dev_id) >> 12)\n\nstatic inline int is_t4(enum chip_type chip)\n{\n\treturn CHELSIO_CHIP_VERSION(chip) == CHELSIO_T4;\n}\n\n \nstatic inline int hash_mac_addr(const u8 *addr)\n{\n\tu32 a = ((u32)addr[0] << 16) | ((u32)addr[1] << 8) | addr[2];\n\tu32 b = ((u32)addr[3] << 16) | ((u32)addr[4] << 8) | addr[5];\n\n\ta ^= b;\n\ta ^= (a >> 12);\n\ta ^= (a >> 6);\n\treturn a & 0x3f;\n}\n\nint t4vf_wait_dev_ready(struct adapter *);\nint t4vf_port_init(struct adapter *, int);\n\nint t4vf_fw_reset(struct adapter *);\nint t4vf_set_params(struct adapter *, unsigned int, const u32 *, const u32 *);\n\nint t4vf_fl_pkt_align(struct adapter *adapter);\nenum t4_bar2_qtype { T4_BAR2_QTYPE_EGRESS, T4_BAR2_QTYPE_INGRESS };\nint t4vf_bar2_sge_qregs(struct adapter *adapter,\n\t\t\tunsigned int qid,\n\t\t\tenum t4_bar2_qtype qtype,\n\t\t\tu64 *pbar2_qoffset,\n\t\t\tunsigned int *pbar2_qid);\n\nunsigned int t4vf_get_pf_from_vf(struct adapter *);\nint t4vf_get_sge_params(struct adapter *);\nint t4vf_get_vpd_params(struct adapter *);\nint t4vf_get_dev_params(struct adapter *);\nint t4vf_get_rss_glb_config(struct adapter *);\nint t4vf_get_vfres(struct adapter *);\n\nint t4vf_read_rss_vi_config(struct adapter *, unsigned int,\n\t\t\t    union rss_vi_config *);\nint t4vf_write_rss_vi_config(struct adapter *, unsigned int,\n\t\t\t     union rss_vi_config *);\nint t4vf_config_rss_range(struct adapter *, unsigned int, int, int,\n\t\t\t  const u16 *, int);\n\nint t4vf_alloc_vi(struct adapter *, int);\nint t4vf_free_vi(struct adapter *, int);\nint t4vf_enable_vi(struct adapter *adapter, unsigned int viid, bool rx_en,\n\t\t   bool tx_en);\nint t4vf_enable_pi(struct adapter *adapter, struct port_info *pi, bool rx_en,\n\t\t   bool tx_en);\nint t4vf_identify_port(struct adapter *, unsigned int, unsigned int);\n\nint t4vf_set_rxmode(struct adapter *, unsigned int, int, int, int, int, int,\n\t\t    bool);\nint t4vf_alloc_mac_filt(struct adapter *, unsigned int, bool, unsigned int,\n\t\t\tconst u8 **, u16 *, u64 *, bool);\nint t4vf_free_mac_filt(struct adapter *, unsigned int, unsigned int naddr,\n\t\t       const u8 **, bool);\nint t4vf_change_mac(struct adapter *, unsigned int, int, const u8 *, bool);\nint t4vf_set_addr_hash(struct adapter *, unsigned int, bool, u64, bool);\nint t4vf_get_port_stats(struct adapter *, int, struct t4vf_port_stats *);\n\nint t4vf_iq_free(struct adapter *, unsigned int, unsigned int, unsigned int,\n\t\t unsigned int);\nint t4vf_eth_eq_free(struct adapter *, unsigned int);\n\nint t4vf_update_port_info(struct port_info *pi);\nint t4vf_handle_fw_rpl(struct adapter *, const __be64 *);\nint t4vf_prep_adapter(struct adapter *);\nint t4vf_get_vf_mac_acl(struct adapter *adapter, unsigned int port,\n\t\t\tunsigned int *naddr, u8 *addr);\nint t4vf_get_vf_vlan_acl(struct adapter *adapter);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}