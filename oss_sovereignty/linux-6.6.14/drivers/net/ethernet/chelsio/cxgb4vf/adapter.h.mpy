{
  "module_name": "adapter.h",
  "hash_id": "3fa3c671ca0c6ad95c0e55948cd48dbda8d6da6a4e78b409fab36ead15fdfe94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4vf/adapter.h",
  "human_readable_source": " \n\n \n\n#ifndef __CXGB4VF_ADAPTER_H__\n#define __CXGB4VF_ADAPTER_H__\n\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/skbuff.h>\n#include <linux/if_ether.h>\n#include <linux/netdevice.h>\n\n#include \"../cxgb4/t4_hw.h\"\n\n \nenum {\n\tMAX_NPORTS\t= 1,\t\t \n\tMAX_PORT_QSETS\t= 8,\t\t \n\tMAX_ETH_QSETS\t= MAX_NPORTS*MAX_PORT_QSETS,\n\n\t \n\tMSIX_FW\t\t= 0,\t\t \n\tMSIX_IQFLINT\t= 1,\t\t \n\tMSIX_EXTRAS\t= 1,\n\tMSIX_ENTRIES\t= MAX_ETH_QSETS + MSIX_EXTRAS,\n\n\t \n\tINGQ_EXTRAS\t= 2,\t\t \n\t\t\t\t\t \n\tMAX_INGQ\t= MAX_ETH_QSETS+INGQ_EXTRAS,\n\tMAX_EGRQ\t= MAX_ETH_QSETS*2,\n};\n\n \nstruct adapter;\nstruct sge_eth_rxq;\nstruct sge_rspq;\n\n \nstruct port_info {\n\tstruct adapter *adapter;\t \n\tu32 vlan_id;\t\t\t \n\tu16 viid;\t\t\t \n\tint xact_addr_filt;\t\t \n\tu16 rss_size;\t\t\t \n\tu8 pidx;\t\t\t \n\ts8 mdio_addr;\n\tu8 port_type;\t\t\t \n\tu8 mod_type;\t\t\t \n\tu8 port_id;\t\t\t \n\tu8 nqsets;\t\t\t \n\tu8 first_qset;\t\t\t \n\tstruct link_config link_cfg;\t \n};\n\n \n\n \nstruct rx_sw_desc;\nstruct sge_fl {\n\tunsigned int avail;\t\t \n\tunsigned int pend_cred;\t\t \n\tunsigned int cidx;\t\t \n\tunsigned int pidx;\t\t \n\tunsigned long alloc_failed;\t \n\tunsigned long large_alloc_failed;\n\tunsigned long starving;\t\t \n\n\t \n\n\tunsigned int cntxt_id;\t\t \n\tunsigned int abs_id;\t\t \n\tunsigned int size;\t\t \n\tstruct rx_sw_desc *sdesc;\t \n\t__be64 *desc;\t\t\t \n\tdma_addr_t addr;\t\t \n\tvoid __iomem *bar2_addr;\t \n\tunsigned int bar2_qid;\t\t \n};\n\n \nstruct pkt_gl {\n\tstruct page_frag frags[MAX_SKB_FRAGS];\n\tvoid *va;\t\t\t \n\tunsigned int nfrags;\t\t \n\tunsigned int tot_len;\t\t \n};\n\ntypedef int (*rspq_handler_t)(struct sge_rspq *, const __be64 *,\n\t\t\t      const struct pkt_gl *);\n\n \nstruct sge_rspq {\n\tstruct napi_struct napi;\t \n\tconst __be64 *cur_desc;\t\t \n\tunsigned int cidx;\t\t \n\tu8 gen;\t\t\t\t \n\tu8 next_intr_params;\t\t \n\tint offset;\t\t\t \n\n\tunsigned int unhandled_irqs;\t \n\n\t \n\n\tu8 intr_params;\t\t\t \n\tu8 pktcnt_idx;\t\t\t \n\tu8 idx;\t\t\t\t \n\tu16 cntxt_id;\t\t\t \n\tu16 abs_id;\t\t\t \n\t__be64 *desc;\t\t\t \n\tdma_addr_t phys_addr;\t\t \n\tvoid __iomem *bar2_addr;\t \n\tunsigned int bar2_qid;\t\t \n\tunsigned int iqe_len;\t\t \n\tunsigned int size;\t\t \n\tstruct adapter *adapter;\t \n\tstruct net_device *netdev;\t \n\trspq_handler_t handler;\t\t \n};\n\n \nstruct sge_eth_stats {\n\tunsigned long pkts;\t\t \n\tunsigned long lro_pkts;\t\t \n\tunsigned long lro_merged;\t \n\tunsigned long rx_cso;\t\t \n\tunsigned long vlan_ex;\t\t \n\tunsigned long rx_drops;\t\t \n};\n\n \nstruct sge_eth_rxq {\n\tstruct sge_rspq rspq;\t\t \n\tstruct sge_fl fl;\t\t \n\tstruct sge_eth_stats stats;\t \n};\n\n \nstruct tx_desc {\n\t \n\t__be64 flit[SGE_EQ_IDXSIZE/sizeof(__be64)];\n};\nstruct tx_sw_desc;\nstruct sge_txq {\n\tunsigned int in_use;\t\t \n\tunsigned int size;\t\t \n\tunsigned int cidx;\t\t \n\tunsigned int pidx;\t\t \n\tunsigned long stops;\t\t \n\tunsigned long restarts;\t\t \n\n\t \n\n\tunsigned int cntxt_id;\t\t \n\tunsigned int abs_id;\t\t \n\tstruct tx_desc *desc;\t\t \n\tstruct tx_sw_desc *sdesc;\t \n\tstruct sge_qstat *stat;\t\t \n\tdma_addr_t phys_addr;\t\t \n\tvoid __iomem *bar2_addr;\t \n\tunsigned int bar2_qid;\t\t \n};\n\n \nstruct sge_eth_txq {\n\tstruct sge_txq q;\t\t \n\tstruct netdev_queue *txq;\t \n\tunsigned long tso;\t\t \n\tunsigned long tx_cso;\t\t \n\tunsigned long vlan_ins;\t\t \n\tunsigned long mapping_err;\t \n};\n\n \nstruct sge {\n\t \n\tstruct sge_eth_txq ethtxq[MAX_ETH_QSETS];\n\tstruct sge_eth_rxq ethrxq[MAX_ETH_QSETS];\n\n\t \n\tstruct sge_rspq fw_evtq ____cacheline_aligned_in_smp;\n\n\tstruct sge_rspq intrq ____cacheline_aligned_in_smp;\n\tspinlock_t intrq_lock;\n\n\t \n\tDECLARE_BITMAP(starving_fl, MAX_EGRQ);\n\tstruct timer_list rx_timer;\n\n\t \n\tstruct timer_list tx_timer;\n\n\t \n\n\tu16 max_ethqsets;\t\t \n\tu16 ethqsets;\t\t\t \n\tu16 ethtxq_rover;\t\t \n\tu16 timer_val[SGE_NTIMERS];\t \n\tu8 counter_val[SGE_NCOUNTERS];\t \n\n\t \n\tu32 fl_pg_order;\t\t \n\tu32 stat_len;\t\t\t \n\tu32 pktshift;\t\t\t \n\tu32 fl_align;\t\t\t \n\tu32 fl_starve_thres;\t\t \n\n\t \n\tunsigned int egr_base;\n\tunsigned int ingr_base;\n\tvoid *egr_map[MAX_EGRQ];\n\tstruct sge_rspq *ingr_map[MAX_INGQ];\n};\n\n \n#define EQ_IDX(s, abs_id) ((unsigned int)((abs_id) - (s)->egr_base))\n#define IQ_IDX(s, abs_id) ((unsigned int)((abs_id) - (s)->ingr_base))\n\n#define EQ_MAP(s, abs_id) ((s)->egr_map[EQ_IDX(s, abs_id)])\n#define IQ_MAP(s, abs_id) ((s)->ingr_map[IQ_IDX(s, abs_id)])\n\n \n#define for_each_ethrxq(sge, iter) \\\n\tfor (iter = 0; iter < (sge)->ethqsets; iter++)\n\nstruct hash_mac_addr {\n\tstruct list_head list;\n\tu8 addr[ETH_ALEN];\n\tunsigned int iface_mac;\n};\n\nstruct mbox_list {\n\tstruct list_head list;\n};\n\n \nstruct adapter {\n\t \n\tvoid __iomem *regs;\n\tvoid __iomem *bar2;\n\tstruct pci_dev *pdev;\n\tstruct device *pdev_dev;\n\n\t \n\tunsigned long registered_device_map;\n\tunsigned long open_device_map;\n\tunsigned long flags;\n\tstruct adapter_params params;\n\n\t \n\tstruct {\n\t\tunsigned short vec;\n\t\tchar desc[22];\n\t} msix_info[MSIX_ENTRIES];\n\tstruct sge sge;\n\n\t \n\tstruct net_device *port[MAX_NPORTS];\n\tconst char *name;\n\tunsigned int msg_enable;\n\n\t \n\tstruct dentry *debugfs_root;\n\n\t \n\tspinlock_t stats_lock;\n\n\t \n\tspinlock_t mbox_lock;\n\tstruct mbox_list mlist;\n\n\t \n#define T4VF_OS_LOG_MBOX_CMDS 256\n\tstruct mbox_cmd_log *mbox_log;\n\n\t \n\tstruct list_head mac_hlist;\n};\n\nenum {  \n\tCXGB4VF_FULL_INIT_DONE\t\t\t= (1UL << 0),\n\tCXGB4VF_USING_MSI\t\t\t= (1UL << 1),\n\tCXGB4VF_USING_MSIX\t\t\t= (1UL << 2),\n\tCXGB4VF_QUEUES_BOUND\t\t\t= (1UL << 3),\n\tCXGB4VF_ROOT_NO_RELAXED_ORDERING\t= (1UL << 4),\n\tCXGB4VF_FW_OK\t\t\t\t= (1UL << 5),\n};\n\n \n\n \nstatic inline u32 t4_read_reg(struct adapter *adapter, u32 reg_addr)\n{\n\treturn readl(adapter->regs + reg_addr);\n}\n\n \nstatic inline void t4_write_reg(struct adapter *adapter, u32 reg_addr, u32 val)\n{\n\twritel(val, adapter->regs + reg_addr);\n}\n\n#ifndef readq\nstatic inline u64 readq(const volatile void __iomem *addr)\n{\n\treturn readl(addr) + ((u64)readl(addr + 4) << 32);\n}\n\nstatic inline void writeq(u64 val, volatile void __iomem *addr)\n{\n\twritel(val, addr);\n\twritel(val >> 32, addr + 4);\n}\n#endif\n\n \nstatic inline u64 t4_read_reg64(struct adapter *adapter, u32 reg_addr)\n{\n\treturn readq(adapter->regs + reg_addr);\n}\n\n \nstatic inline void t4_write_reg64(struct adapter *adapter, u32 reg_addr,\n\t\t\t\t  u64 val)\n{\n\twriteq(val, adapter->regs + reg_addr);\n}\n\n \nstatic inline const char *port_name(struct adapter *adapter, int pidx)\n{\n\treturn adapter->port[pidx]->name;\n}\n\n \nstatic inline void t4_os_set_hw_addr(struct adapter *adapter, int pidx,\n\t\t\t\t     u8 hw_addr[])\n{\n\teth_hw_addr_set(adapter->port[pidx], hw_addr);\n}\n\n \nstatic inline struct port_info *netdev2pinfo(const struct net_device *dev)\n{\n\treturn netdev_priv(dev);\n}\n\n \nstatic inline struct port_info *adap2pinfo(struct adapter *adapter, int pidx)\n{\n\treturn netdev_priv(adapter->port[pidx]);\n}\n\n \nstatic inline struct adapter *netdev2adap(const struct net_device *dev)\n{\n\treturn netdev2pinfo(dev)->adapter;\n}\n\n \nvoid t4vf_os_link_changed(struct adapter *, int, int);\nvoid t4vf_os_portmod_changed(struct adapter *, int);\n\n \nint t4vf_sge_alloc_rxq(struct adapter *, struct sge_rspq *, bool,\n\t\t       struct net_device *, int,\n\t\t       struct sge_fl *, rspq_handler_t);\nint t4vf_sge_alloc_eth_txq(struct adapter *, struct sge_eth_txq *,\n\t\t\t   struct net_device *, struct netdev_queue *,\n\t\t\t   unsigned int);\nvoid t4vf_free_sge_resources(struct adapter *);\n\nnetdev_tx_t t4vf_eth_xmit(struct sk_buff *, struct net_device *);\nint t4vf_ethrx_handler(struct sge_rspq *, const __be64 *,\n\t\t       const struct pkt_gl *);\n\nirq_handler_t t4vf_intr_handler(struct adapter *);\nirqreturn_t t4vf_sge_intr_msix(int, void *);\n\nint t4vf_sge_init(struct adapter *);\nvoid t4vf_sge_start(struct adapter *);\nvoid t4vf_sge_stop(struct adapter *);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}