{
  "module_name": "cxgb4vf_main.c",
  "hash_id": "6a906e8c23af91b504235f0df549dfd66897a3215b389b69eb73b52c844f4ddb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/debugfs.h>\n#include <linux/ethtool.h>\n#include <linux/mdio.h>\n\n#include \"t4vf_common.h\"\n#include \"t4vf_defs.h\"\n\n#include \"../cxgb4/t4_regs.h\"\n#include \"../cxgb4/t4_msg.h\"\n\n \n#define DRV_DESC \"Chelsio T4/T5/T6 Virtual Function (VF) Network Driver\"\n\n \n\n \n#define DFLT_MSG_ENABLE (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK | \\\n\t\t\t NETIF_MSG_TIMER | NETIF_MSG_IFDOWN | NETIF_MSG_IFUP |\\\n\t\t\t NETIF_MSG_RX_ERR | NETIF_MSG_TX_ERR)\n\n \n#define MSI_MSIX\t2\n#define MSI_MSI\t\t1\n#define MSI_DEFAULT\tMSI_MSIX\n\nstatic int msi = MSI_DEFAULT;\n\nmodule_param(msi, int, 0644);\nMODULE_PARM_DESC(msi, \"whether to use MSI-X or MSI\");\n\n \n\nenum {\n\tMAX_TXQ_ENTRIES\t\t= 16384,\n\tMAX_RSPQ_ENTRIES\t= 16384,\n\tMAX_RX_BUFFERS\t\t= 16384,\n\n\tMIN_TXQ_ENTRIES\t\t= 32,\n\tMIN_RSPQ_ENTRIES\t= 128,\n\tMIN_FL_ENTRIES\t\t= 16,\n\n\t \n\tEQ_UNIT = SGE_EQ_IDXSIZE,\n\tFL_PER_EQ_UNIT = EQ_UNIT / sizeof(__be64),\n\tMIN_FL_RESID = FL_PER_EQ_UNIT,\n};\n\n \n\nstatic struct dentry *cxgb4vf_debugfs_root;\n\n \n\n \nvoid t4vf_os_link_changed(struct adapter *adapter, int pidx, int link_ok)\n{\n\tstruct net_device *dev = adapter->port[pidx];\n\n\t \n\tif (!netif_running(dev) || link_ok == netif_carrier_ok(dev))\n\t\treturn;\n\n\t \n\tif (link_ok) {\n\t\tconst char *s;\n\t\tconst char *fc;\n\t\tconst struct port_info *pi = netdev_priv(dev);\n\n\t\tnetif_carrier_on(dev);\n\n\t\tswitch (pi->link_cfg.speed) {\n\t\tcase 100:\n\t\t\ts = \"100Mbps\";\n\t\t\tbreak;\n\t\tcase 1000:\n\t\t\ts = \"1Gbps\";\n\t\t\tbreak;\n\t\tcase 10000:\n\t\t\ts = \"10Gbps\";\n\t\t\tbreak;\n\t\tcase 25000:\n\t\t\ts = \"25Gbps\";\n\t\t\tbreak;\n\t\tcase 40000:\n\t\t\ts = \"40Gbps\";\n\t\t\tbreak;\n\t\tcase 100000:\n\t\t\ts = \"100Gbps\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ts = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch ((int)pi->link_cfg.fc) {\n\t\tcase PAUSE_RX:\n\t\t\tfc = \"RX\";\n\t\t\tbreak;\n\n\t\tcase PAUSE_TX:\n\t\t\tfc = \"TX\";\n\t\t\tbreak;\n\n\t\tcase PAUSE_RX | PAUSE_TX:\n\t\t\tfc = \"RX/TX\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfc = \"no\";\n\t\t\tbreak;\n\t\t}\n\n\t\tnetdev_info(dev, \"link up, %s, full-duplex, %s PAUSE\\n\", s, fc);\n\t} else {\n\t\tnetif_carrier_off(dev);\n\t\tnetdev_info(dev, \"link down\\n\");\n\t}\n}\n\n \nvoid t4vf_os_portmod_changed(struct adapter *adapter, int pidx)\n{\n\tstatic const char * const mod_str[] = {\n\t\tNULL, \"LR\", \"SR\", \"ER\", \"passive DA\", \"active DA\", \"LRM\"\n\t};\n\tconst struct net_device *dev = adapter->port[pidx];\n\tconst struct port_info *pi = netdev_priv(dev);\n\n\tif (pi->mod_type == FW_PORT_MOD_TYPE_NONE)\n\t\tdev_info(adapter->pdev_dev, \"%s: port module unplugged\\n\",\n\t\t\t dev->name);\n\telse if (pi->mod_type < ARRAY_SIZE(mod_str))\n\t\tdev_info(adapter->pdev_dev, \"%s: %s port module inserted\\n\",\n\t\t\t dev->name, mod_str[pi->mod_type]);\n\telse if (pi->mod_type == FW_PORT_MOD_TYPE_NOTSUPPORTED)\n\t\tdev_info(adapter->pdev_dev, \"%s: unsupported optical port \"\n\t\t\t \"module inserted\\n\", dev->name);\n\telse if (pi->mod_type == FW_PORT_MOD_TYPE_UNKNOWN)\n\t\tdev_info(adapter->pdev_dev, \"%s: unknown port module inserted,\"\n\t\t\t \"forcing TWINAX\\n\", dev->name);\n\telse if (pi->mod_type == FW_PORT_MOD_TYPE_ERROR)\n\t\tdev_info(adapter->pdev_dev, \"%s: transceiver module error\\n\",\n\t\t\t dev->name);\n\telse\n\t\tdev_info(adapter->pdev_dev, \"%s: unknown module type %d \"\n\t\t\t \"inserted\\n\", dev->name, pi->mod_type);\n}\n\nstatic int cxgb4vf_set_addr_hash(struct port_info *pi)\n{\n\tstruct adapter *adapter = pi->adapter;\n\tu64 vec = 0;\n\tbool ucast = false;\n\tstruct hash_mac_addr *entry;\n\n\t \n\tlist_for_each_entry(entry, &adapter->mac_hlist, list) {\n\t\tucast |= is_unicast_ether_addr(entry->addr);\n\t\tvec |= (1ULL << hash_mac_addr(entry->addr));\n\t}\n\treturn t4vf_set_addr_hash(adapter, pi->viid, ucast, vec, false);\n}\n\n \nstatic int cxgb4vf_change_mac(struct port_info *pi, unsigned int viid,\n\t\t\t      int *tcam_idx, const u8 *addr, bool persistent)\n{\n\tstruct hash_mac_addr *new_entry, *entry;\n\tstruct adapter *adapter = pi->adapter;\n\tint ret;\n\n\tret = t4vf_change_mac(adapter, viid, *tcam_idx, addr, persistent);\n\t \n\tif (ret == -ENOMEM) {\n\t\t \n\t\tlist_for_each_entry(entry, &adapter->mac_hlist, list) {\n\t\t\tif (entry->iface_mac) {\n\t\t\t\tether_addr_copy(entry->addr, addr);\n\t\t\t\tgoto set_hash;\n\t\t\t}\n\t\t}\n\t\tnew_entry = kzalloc(sizeof(*new_entry), GFP_KERNEL);\n\t\tif (!new_entry)\n\t\t\treturn -ENOMEM;\n\t\tether_addr_copy(new_entry->addr, addr);\n\t\tnew_entry->iface_mac = true;\n\t\tlist_add_tail(&new_entry->list, &adapter->mac_hlist);\nset_hash:\n\t\tret = cxgb4vf_set_addr_hash(pi);\n\t} else if (ret >= 0) {\n\t\t*tcam_idx = ret;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \n\n\n\n\n \nstatic int link_start(struct net_device *dev)\n{\n\tint ret;\n\tstruct port_info *pi = netdev_priv(dev);\n\n\t \n\tret = t4vf_set_rxmode(pi->adapter, pi->viid, dev->mtu, -1, -1, -1, 1,\n\t\t\t      true);\n\tif (ret == 0)\n\t\tret = cxgb4vf_change_mac(pi, pi->viid,\n\t\t\t\t\t &pi->xact_addr_filt,\n\t\t\t\t\t dev->dev_addr, true);\n\n\t \n\tif (ret == 0)\n\t\tret = t4vf_enable_pi(pi->adapter, pi, true, true);\n\n\treturn ret;\n}\n\n \nstatic void name_msix_vecs(struct adapter *adapter)\n{\n\tint namelen = sizeof(adapter->msix_info[0].desc) - 1;\n\tint pidx;\n\n\t \n\tsnprintf(adapter->msix_info[MSIX_FW].desc, namelen,\n\t\t \"%s-FWeventq\", adapter->name);\n\tadapter->msix_info[MSIX_FW].desc[namelen] = 0;\n\n\t \n\tfor_each_port(adapter, pidx) {\n\t\tstruct net_device *dev = adapter->port[pidx];\n\t\tconst struct port_info *pi = netdev_priv(dev);\n\t\tint qs, msi;\n\n\t\tfor (qs = 0, msi = MSIX_IQFLINT; qs < pi->nqsets; qs++, msi++) {\n\t\t\tsnprintf(adapter->msix_info[msi].desc, namelen,\n\t\t\t\t \"%s-%d\", dev->name, qs);\n\t\t\tadapter->msix_info[msi].desc[namelen] = 0;\n\t\t}\n\t}\n}\n\n \nstatic int request_msix_queue_irqs(struct adapter *adapter)\n{\n\tstruct sge *s = &adapter->sge;\n\tint rxq, msi, err;\n\n\t \n\terr = request_irq(adapter->msix_info[MSIX_FW].vec, t4vf_sge_intr_msix,\n\t\t\t  0, adapter->msix_info[MSIX_FW].desc, &s->fw_evtq);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmsi = MSIX_IQFLINT;\n\tfor_each_ethrxq(s, rxq) {\n\t\terr = request_irq(adapter->msix_info[msi].vec,\n\t\t\t\t  t4vf_sge_intr_msix, 0,\n\t\t\t\t  adapter->msix_info[msi].desc,\n\t\t\t\t  &s->ethrxq[rxq].rspq);\n\t\tif (err)\n\t\t\tgoto err_free_irqs;\n\t\tmsi++;\n\t}\n\treturn 0;\n\nerr_free_irqs:\n\twhile (--rxq >= 0)\n\t\tfree_irq(adapter->msix_info[--msi].vec, &s->ethrxq[rxq].rspq);\n\tfree_irq(adapter->msix_info[MSIX_FW].vec, &s->fw_evtq);\n\treturn err;\n}\n\n \nstatic void free_msix_queue_irqs(struct adapter *adapter)\n{\n\tstruct sge *s = &adapter->sge;\n\tint rxq, msi;\n\n\tfree_irq(adapter->msix_info[MSIX_FW].vec, &s->fw_evtq);\n\tmsi = MSIX_IQFLINT;\n\tfor_each_ethrxq(s, rxq)\n\t\tfree_irq(adapter->msix_info[msi++].vec,\n\t\t\t &s->ethrxq[rxq].rspq);\n}\n\n \nstatic void qenable(struct sge_rspq *rspq)\n{\n\tnapi_enable(&rspq->napi);\n\n\t \n\tt4_write_reg(rspq->adapter, T4VF_SGE_BASE_ADDR + SGE_VF_GTS,\n\t\t     CIDXINC_V(0) |\n\t\t     SEINTARM_V(rspq->intr_params) |\n\t\t     INGRESSQID_V(rspq->cntxt_id));\n}\n\n \nstatic void enable_rx(struct adapter *adapter)\n{\n\tint rxq;\n\tstruct sge *s = &adapter->sge;\n\n\tfor_each_ethrxq(s, rxq)\n\t\tqenable(&s->ethrxq[rxq].rspq);\n\tqenable(&s->fw_evtq);\n\n\t \n\tif (adapter->flags & CXGB4VF_USING_MSI)\n\t\tt4_write_reg(adapter, T4VF_SGE_BASE_ADDR + SGE_VF_GTS,\n\t\t\t     CIDXINC_V(0) |\n\t\t\t     SEINTARM_V(s->intrq.intr_params) |\n\t\t\t     INGRESSQID_V(s->intrq.cntxt_id));\n\n}\n\n \nstatic void quiesce_rx(struct adapter *adapter)\n{\n\tstruct sge *s = &adapter->sge;\n\tint rxq;\n\n\tfor_each_ethrxq(s, rxq)\n\t\tnapi_disable(&s->ethrxq[rxq].rspq.napi);\n\tnapi_disable(&s->fw_evtq.napi);\n}\n\n \nstatic int fwevtq_handler(struct sge_rspq *rspq, const __be64 *rsp,\n\t\t\t  const struct pkt_gl *gl)\n{\n\t \n\tstruct adapter *adapter = rspq->adapter;\n\tu8 opcode = ((const struct rss_header *)rsp)->opcode;\n\tvoid *cpl = (void *)(rsp + 1);\n\n\tswitch (opcode) {\n\tcase CPL_FW6_MSG: {\n\t\t \n\t\tconst struct cpl_fw6_msg *fw_msg = cpl;\n\t\tif (fw_msg->type == FW6_TYPE_CMD_RPL)\n\t\t\tt4vf_handle_fw_rpl(adapter, fw_msg->data);\n\t\tbreak;\n\t}\n\n\tcase CPL_FW4_MSG: {\n\t\t \n\t\tconst struct cpl_sge_egr_update *p = (void *)(rsp + 3);\n\t\topcode = CPL_OPCODE_G(ntohl(p->opcode_qid));\n\t\tif (opcode != CPL_SGE_EGR_UPDATE) {\n\t\t\tdev_err(adapter->pdev_dev, \"unexpected FW4/CPL %#x on FW event queue\\n\"\n\t\t\t\t, opcode);\n\t\t\tbreak;\n\t\t}\n\t\tcpl = (void *)p;\n\t}\n\t\tfallthrough;\n\n\tcase CPL_SGE_EGR_UPDATE: {\n\t\t \n\t\tconst struct cpl_sge_egr_update *p = cpl;\n\t\tunsigned int qid = EGR_QID_G(be32_to_cpu(p->opcode_qid));\n\t\tstruct sge *s = &adapter->sge;\n\t\tstruct sge_txq *tq;\n\t\tstruct sge_eth_txq *txq;\n\t\tunsigned int eq_idx;\n\n\t\t \n\t\teq_idx = EQ_IDX(s, qid);\n\t\tif (unlikely(eq_idx >= MAX_EGRQ)) {\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"Egress Update QID %d out of range\\n\", qid);\n\t\t\tbreak;\n\t\t}\n\t\ttq = s->egr_map[eq_idx];\n\t\tif (unlikely(tq == NULL)) {\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"Egress Update QID %d TXQ=NULL\\n\", qid);\n\t\t\tbreak;\n\t\t}\n\t\ttxq = container_of(tq, struct sge_eth_txq, q);\n\t\tif (unlikely(tq->abs_id != qid)) {\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"Egress Update QID %d refers to TXQ %d\\n\",\n\t\t\t\tqid, tq->abs_id);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\ttxq->q.restarts++;\n\t\tnetif_tx_wake_queue(txq->txq);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tdev_err(adapter->pdev_dev,\n\t\t\t\"unexpected CPL %#x on FW event queue\\n\", opcode);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int setup_sge_queues(struct adapter *adapter)\n{\n\tstruct sge *s = &adapter->sge;\n\tint err, pidx, msix;\n\n\t \n\tbitmap_zero(s->starving_fl, MAX_EGRQ);\n\n\t \n\tif (adapter->flags & CXGB4VF_USING_MSI) {\n\t\terr = t4vf_sge_alloc_rxq(adapter, &s->intrq, false,\n\t\t\t\t\t adapter->port[0], 0, NULL, NULL);\n\t\tif (err)\n\t\t\tgoto err_free_queues;\n\t}\n\n\t \n\terr = t4vf_sge_alloc_rxq(adapter, &s->fw_evtq, true, adapter->port[0],\n\t\t\t\t MSIX_FW, NULL, fwevtq_handler);\n\tif (err)\n\t\tgoto err_free_queues;\n\n\t \n\tmsix = MSIX_IQFLINT;\n\tfor_each_port(adapter, pidx) {\n\t\tstruct net_device *dev = adapter->port[pidx];\n\t\tstruct port_info *pi = netdev_priv(dev);\n\t\tstruct sge_eth_rxq *rxq = &s->ethrxq[pi->first_qset];\n\t\tstruct sge_eth_txq *txq = &s->ethtxq[pi->first_qset];\n\t\tint qs;\n\n\t\tfor (qs = 0; qs < pi->nqsets; qs++, rxq++, txq++) {\n\t\t\terr = t4vf_sge_alloc_rxq(adapter, &rxq->rspq, false,\n\t\t\t\t\t\t dev, msix++,\n\t\t\t\t\t\t &rxq->fl, t4vf_ethrx_handler);\n\t\t\tif (err)\n\t\t\t\tgoto err_free_queues;\n\n\t\t\terr = t4vf_sge_alloc_eth_txq(adapter, txq, dev,\n\t\t\t\t\t     netdev_get_tx_queue(dev, qs),\n\t\t\t\t\t     s->fw_evtq.cntxt_id);\n\t\t\tif (err)\n\t\t\t\tgoto err_free_queues;\n\n\t\t\trxq->rspq.idx = qs;\n\t\t\tmemset(&rxq->stats, 0, sizeof(rxq->stats));\n\t\t}\n\t}\n\n\t \n\ts->egr_base = s->ethtxq[0].q.abs_id - s->ethtxq[0].q.cntxt_id;\n\ts->ingr_base = s->ethrxq[0].rspq.abs_id - s->ethrxq[0].rspq.cntxt_id;\n\tIQ_MAP(s, s->fw_evtq.abs_id) = &s->fw_evtq;\n\tfor_each_port(adapter, pidx) {\n\t\tstruct net_device *dev = adapter->port[pidx];\n\t\tstruct port_info *pi = netdev_priv(dev);\n\t\tstruct sge_eth_rxq *rxq = &s->ethrxq[pi->first_qset];\n\t\tstruct sge_eth_txq *txq = &s->ethtxq[pi->first_qset];\n\t\tint qs;\n\n\t\tfor (qs = 0; qs < pi->nqsets; qs++, rxq++, txq++) {\n\t\t\tIQ_MAP(s, rxq->rspq.abs_id) = &rxq->rspq;\n\t\t\tEQ_MAP(s, txq->q.abs_id) = &txq->q;\n\n\t\t\t \n\t\t\trxq->fl.abs_id = rxq->fl.cntxt_id + s->egr_base;\n\t\t\tEQ_MAP(s, rxq->fl.abs_id) = &rxq->fl;\n\t\t}\n\t}\n\treturn 0;\n\nerr_free_queues:\n\tt4vf_free_sge_resources(adapter);\n\treturn err;\n}\n\n \nstatic int setup_rss(struct adapter *adapter)\n{\n\tint pidx;\n\n\tfor_each_port(adapter, pidx) {\n\t\tstruct port_info *pi = adap2pinfo(adapter, pidx);\n\t\tstruct sge_eth_rxq *rxq = &adapter->sge.ethrxq[pi->first_qset];\n\t\tu16 rss[MAX_PORT_QSETS];\n\t\tint qs, err;\n\n\t\tfor (qs = 0; qs < pi->nqsets; qs++)\n\t\t\trss[qs] = rxq[qs].rspq.abs_id;\n\n\t\terr = t4vf_config_rss_range(adapter, pi->viid,\n\t\t\t\t\t    0, pi->rss_size, rss, pi->nqsets);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tswitch (adapter->params.rss.mode) {\n\t\tcase FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL:\n\t\t\t \n\t\t\tif (!adapter->params.rss.u.basicvirtual.tnlalllookup) {\n\t\t\t\tunion rss_vi_config config;\n\t\t\t\terr = t4vf_read_rss_vi_config(adapter,\n\t\t\t\t\t\t\t      pi->viid,\n\t\t\t\t\t\t\t      &config);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tconfig.basicvirtual.defaultq =\n\t\t\t\t\trxq[0].rspq.abs_id;\n\t\t\t\terr = t4vf_write_rss_vi_config(adapter,\n\t\t\t\t\t\t\t       pi->viid,\n\t\t\t\t\t\t\t       &config);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int adapter_up(struct adapter *adapter)\n{\n\tint err;\n\n\t \n\tif ((adapter->flags & CXGB4VF_FULL_INIT_DONE) == 0) {\n\t\terr = setup_sge_queues(adapter);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = setup_rss(adapter);\n\t\tif (err) {\n\t\t\tt4vf_free_sge_resources(adapter);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (adapter->flags & CXGB4VF_USING_MSIX)\n\t\t\tname_msix_vecs(adapter);\n\n\t\tadapter->flags |= CXGB4VF_FULL_INIT_DONE;\n\t}\n\n\t \n\tBUG_ON((adapter->flags &\n\t       (CXGB4VF_USING_MSIX | CXGB4VF_USING_MSI)) == 0);\n\tif (adapter->flags & CXGB4VF_USING_MSIX)\n\t\terr = request_msix_queue_irqs(adapter);\n\telse\n\t\terr = request_irq(adapter->pdev->irq,\n\t\t\t\t  t4vf_intr_handler(adapter), 0,\n\t\t\t\t  adapter->name, adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev, \"request_irq failed, err %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\t \n\tenable_rx(adapter);\n\tt4vf_sge_start(adapter);\n\n\treturn 0;\n}\n\n \nstatic void adapter_down(struct adapter *adapter)\n{\n\t \n\tif (adapter->flags & CXGB4VF_USING_MSIX)\n\t\tfree_msix_queue_irqs(adapter);\n\telse\n\t\tfree_irq(adapter->pdev->irq, adapter);\n\n\t \n\tquiesce_rx(adapter);\n}\n\n \nstatic int cxgb4vf_open(struct net_device *dev)\n{\n\tint err;\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\t \n\tif (!(adapter->flags & CXGB4VF_FW_OK))\n\t\treturn -ENXIO;\n\n\t \n\tif (adapter->open_device_map == 0) {\n\t\terr = adapter_up(adapter);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = t4vf_update_port_info(pi);\n\tif (err < 0)\n\t\tgoto err_unwind;\n\n\t \n\terr = link_start(dev);\n\tif (err)\n\t\tgoto err_unwind;\n\n\tpi->vlan_id = t4vf_get_vf_vlan_acl(adapter);\n\n\tnetif_tx_start_all_queues(dev);\n\tset_bit(pi->port_id, &adapter->open_device_map);\n\treturn 0;\n\nerr_unwind:\n\tif (adapter->open_device_map == 0)\n\t\tadapter_down(adapter);\n\treturn err;\n}\n\n \nstatic int cxgb4vf_stop(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\tnetif_tx_stop_all_queues(dev);\n\tnetif_carrier_off(dev);\n\tt4vf_enable_pi(adapter, pi, false, false);\n\n\tclear_bit(pi->port_id, &adapter->open_device_map);\n\tif (adapter->open_device_map == 0)\n\t\tadapter_down(adapter);\n\treturn 0;\n}\n\n \nstatic struct net_device_stats *cxgb4vf_get_stats(struct net_device *dev)\n{\n\tstruct t4vf_port_stats stats;\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tstruct net_device_stats *ns = &dev->stats;\n\tint err;\n\n\tspin_lock(&adapter->stats_lock);\n\terr = t4vf_get_port_stats(adapter, pi->pidx, &stats);\n\tspin_unlock(&adapter->stats_lock);\n\n\tmemset(ns, 0, sizeof(*ns));\n\tif (err)\n\t\treturn ns;\n\n\tns->tx_bytes = (stats.tx_bcast_bytes + stats.tx_mcast_bytes +\n\t\t\tstats.tx_ucast_bytes + stats.tx_offload_bytes);\n\tns->tx_packets = (stats.tx_bcast_frames + stats.tx_mcast_frames +\n\t\t\t  stats.tx_ucast_frames + stats.tx_offload_frames);\n\tns->rx_bytes = (stats.rx_bcast_bytes + stats.rx_mcast_bytes +\n\t\t\tstats.rx_ucast_bytes);\n\tns->rx_packets = (stats.rx_bcast_frames + stats.rx_mcast_frames +\n\t\t\t  stats.rx_ucast_frames);\n\tns->multicast = stats.rx_mcast_frames;\n\tns->tx_errors = stats.tx_drop_frames;\n\tns->rx_errors = stats.rx_err_frames;\n\n\treturn ns;\n}\n\nstatic int cxgb4vf_mac_sync(struct net_device *netdev, const u8 *mac_addr)\n{\n\tstruct port_info *pi = netdev_priv(netdev);\n\tstruct adapter *adapter = pi->adapter;\n\tint ret;\n\tu64 mhash = 0;\n\tu64 uhash = 0;\n\tbool free = false;\n\tbool ucast = is_unicast_ether_addr(mac_addr);\n\tconst u8 *maclist[1] = {mac_addr};\n\tstruct hash_mac_addr *new_entry;\n\n\tret = t4vf_alloc_mac_filt(adapter, pi->viid, free, 1, maclist,\n\t\t\t\t  NULL, ucast ? &uhash : &mhash, false);\n\tif (ret < 0)\n\t\tgoto out;\n\t \n\tif (uhash || mhash) {\n\t\tnew_entry = kzalloc(sizeof(*new_entry), GFP_ATOMIC);\n\t\tif (!new_entry)\n\t\t\treturn -ENOMEM;\n\t\tether_addr_copy(new_entry->addr, mac_addr);\n\t\tlist_add_tail(&new_entry->list, &adapter->mac_hlist);\n\t\tret = cxgb4vf_set_addr_hash(pi);\n\t}\nout:\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int cxgb4vf_mac_unsync(struct net_device *netdev, const u8 *mac_addr)\n{\n\tstruct port_info *pi = netdev_priv(netdev);\n\tstruct adapter *adapter = pi->adapter;\n\tint ret;\n\tconst u8 *maclist[1] = {mac_addr};\n\tstruct hash_mac_addr *entry, *tmp;\n\n\t \n\tlist_for_each_entry_safe(entry, tmp, &adapter->mac_hlist, list) {\n\t\tif (ether_addr_equal(entry->addr, mac_addr)) {\n\t\t\tlist_del(&entry->list);\n\t\t\tkfree(entry);\n\t\t\treturn cxgb4vf_set_addr_hash(pi);\n\t\t}\n\t}\n\n\tret = t4vf_free_mac_filt(adapter, pi->viid, 1, maclist, false);\n\treturn ret < 0 ? -EINVAL : 0;\n}\n\n \nstatic int set_rxmode(struct net_device *dev, int mtu, bool sleep_ok)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\n\t__dev_uc_sync(dev, cxgb4vf_mac_sync, cxgb4vf_mac_unsync);\n\t__dev_mc_sync(dev, cxgb4vf_mac_sync, cxgb4vf_mac_unsync);\n\treturn t4vf_set_rxmode(pi->adapter, pi->viid, -1,\n\t\t\t       (dev->flags & IFF_PROMISC) != 0,\n\t\t\t       (dev->flags & IFF_ALLMULTI) != 0,\n\t\t\t       1, -1, sleep_ok);\n}\n\n \nstatic void cxgb4vf_set_rxmode(struct net_device *dev)\n{\n\t \n\tset_rxmode(dev, -1, false);\n}\n\n \nstatic int closest_timer(const struct sge *s, int us)\n{\n\tint i, timer_idx = 0, min_delta = INT_MAX;\n\n\tfor (i = 0; i < ARRAY_SIZE(s->timer_val); i++) {\n\t\tint delta = us - s->timer_val[i];\n\t\tif (delta < 0)\n\t\t\tdelta = -delta;\n\t\tif (delta < min_delta) {\n\t\t\tmin_delta = delta;\n\t\t\ttimer_idx = i;\n\t\t}\n\t}\n\treturn timer_idx;\n}\n\nstatic int closest_thres(const struct sge *s, int thres)\n{\n\tint i, delta, pktcnt_idx = 0, min_delta = INT_MAX;\n\n\tfor (i = 0; i < ARRAY_SIZE(s->counter_val); i++) {\n\t\tdelta = thres - s->counter_val[i];\n\t\tif (delta < 0)\n\t\t\tdelta = -delta;\n\t\tif (delta < min_delta) {\n\t\t\tmin_delta = delta;\n\t\t\tpktcnt_idx = i;\n\t\t}\n\t}\n\treturn pktcnt_idx;\n}\n\n \nstatic unsigned int qtimer_val(const struct adapter *adapter,\n\t\t\t       const struct sge_rspq *rspq)\n{\n\tunsigned int timer_idx = QINTR_TIMER_IDX_G(rspq->intr_params);\n\n\treturn timer_idx < SGE_NTIMERS\n\t\t? adapter->sge.timer_val[timer_idx]\n\t\t: 0;\n}\n\n \nstatic int set_rxq_intr_params(struct adapter *adapter, struct sge_rspq *rspq,\n\t\t\t       unsigned int us, unsigned int cnt)\n{\n\tunsigned int timer_idx;\n\n\t \n\tif ((us | cnt) == 0)\n\t\tcnt = 1;\n\n\t \n\tif (cnt) {\n\t\tint err;\n\t\tu32 v, pktcnt_idx;\n\n\t\tpktcnt_idx = closest_thres(&adapter->sge, cnt);\n\t\tif (rspq->desc && rspq->pktcnt_idx != pktcnt_idx) {\n\t\t\tv = FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DMAQ) |\n\t\t\t    FW_PARAMS_PARAM_X_V(\n\t\t\t\t\tFW_PARAMS_PARAM_DMAQ_IQ_INTCNTTHRESH) |\n\t\t\t    FW_PARAMS_PARAM_YZ_V(rspq->cntxt_id);\n\t\t\terr = t4vf_set_params(adapter, 1, &v, &pktcnt_idx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\trspq->pktcnt_idx = pktcnt_idx;\n\t}\n\n\t \n\ttimer_idx = (us == 0\n\t\t     ? SGE_TIMER_RSTRT_CNTR\n\t\t     : closest_timer(&adapter->sge, us));\n\n\t \n\trspq->intr_params = (QINTR_TIMER_IDX_V(timer_idx) |\n\t\t\t     QINTR_CNT_EN_V(cnt > 0));\n\treturn 0;\n}\n\n \nstatic inline unsigned int mk_adap_vers(const struct adapter *adapter)\n{\n\t \n\treturn CHELSIO_CHIP_VERSION(adapter->params.chip) | (0x3f << 10);\n}\n\n \nstatic int cxgb4vf_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tint ret = 0;\n\n\tswitch (cmd) {\n\t     \n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic int cxgb4vf_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tint ret;\n\tstruct port_info *pi = netdev_priv(dev);\n\n\tret = t4vf_set_rxmode(pi->adapter, pi->viid, new_mtu,\n\t\t\t      -1, -1, -1, -1, true);\n\tif (!ret)\n\t\tdev->mtu = new_mtu;\n\treturn ret;\n}\n\nstatic netdev_features_t cxgb4vf_fix_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\t \n\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\n\telse\n\t\tfeatures &= ~NETIF_F_HW_VLAN_CTAG_TX;\n\n\treturn features;\n}\n\nstatic int cxgb4vf_set_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tnetdev_features_t changed = dev->features ^ features;\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tt4vf_set_rxmode(pi->adapter, pi->viid, -1, -1, -1, -1,\n\t\t\t\tfeatures & NETIF_F_HW_VLAN_CTAG_TX, 0);\n\n\treturn 0;\n}\n\n \nstatic int cxgb4vf_set_mac_addr(struct net_device *dev, void *_addr)\n{\n\tint ret;\n\tstruct sockaddr *addr = _addr;\n\tstruct port_info *pi = netdev_priv(dev);\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tret = cxgb4vf_change_mac(pi, pi->viid, &pi->xact_addr_filt,\n\t\t\t\t addr->sa_data, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void cxgb4vf_poll_controller(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\tif (adapter->flags & CXGB4VF_USING_MSIX) {\n\t\tstruct sge_eth_rxq *rxq;\n\t\tint nqsets;\n\n\t\trxq = &adapter->sge.ethrxq[pi->first_qset];\n\t\tfor (nqsets = pi->nqsets; nqsets; nqsets--) {\n\t\t\tt4vf_sge_intr_msix(0, &rxq->rspq);\n\t\t\trxq++;\n\t\t}\n\t} else\n\t\tt4vf_intr_handler(adapter)(0, adapter);\n}\n#endif\n\n \n\n \nstatic int from_fw_port_mod_type(enum fw_port_type port_type,\n\t\t\t\t enum fw_port_module_type mod_type)\n{\n\tif (port_type == FW_PORT_TYPE_BT_SGMII ||\n\t    port_type == FW_PORT_TYPE_BT_XFI ||\n\t    port_type == FW_PORT_TYPE_BT_XAUI) {\n\t\treturn PORT_TP;\n\t} else if (port_type == FW_PORT_TYPE_FIBER_XFI ||\n\t\t   port_type == FW_PORT_TYPE_FIBER_XAUI) {\n\t\treturn PORT_FIBRE;\n\t} else if (port_type == FW_PORT_TYPE_SFP ||\n\t\t   port_type == FW_PORT_TYPE_QSFP_10G ||\n\t\t   port_type == FW_PORT_TYPE_QSA ||\n\t\t   port_type == FW_PORT_TYPE_QSFP ||\n\t\t   port_type == FW_PORT_TYPE_CR4_QSFP ||\n\t\t   port_type == FW_PORT_TYPE_CR_QSFP ||\n\t\t   port_type == FW_PORT_TYPE_CR2_QSFP ||\n\t\t   port_type == FW_PORT_TYPE_SFP28) {\n\t\tif (mod_type == FW_PORT_MOD_TYPE_LR ||\n\t\t    mod_type == FW_PORT_MOD_TYPE_SR ||\n\t\t    mod_type == FW_PORT_MOD_TYPE_ER ||\n\t\t    mod_type == FW_PORT_MOD_TYPE_LRM)\n\t\t\treturn PORT_FIBRE;\n\t\telse if (mod_type == FW_PORT_MOD_TYPE_TWINAX_PASSIVE ||\n\t\t\t mod_type == FW_PORT_MOD_TYPE_TWINAX_ACTIVE)\n\t\t\treturn PORT_DA;\n\t\telse\n\t\t\treturn PORT_OTHER;\n\t} else if (port_type == FW_PORT_TYPE_KR4_100G ||\n\t\t   port_type == FW_PORT_TYPE_KR_SFP28 ||\n\t\t   port_type == FW_PORT_TYPE_KR_XLAUI) {\n\t\treturn PORT_NONE;\n\t}\n\n\treturn PORT_OTHER;\n}\n\n \nstatic void fw_caps_to_lmm(enum fw_port_type port_type,\n\t\t\t   unsigned int fw_caps,\n\t\t\t   unsigned long *link_mode_mask)\n{\n\t#define SET_LMM(__lmm_name) \\\n\t\t__set_bit(ETHTOOL_LINK_MODE_ ## __lmm_name ## _BIT, \\\n\t\t\t  link_mode_mask)\n\n\t#define FW_CAPS_TO_LMM(__fw_name, __lmm_name) \\\n\t\tdo { \\\n\t\t\tif (fw_caps & FW_PORT_CAP32_ ## __fw_name) \\\n\t\t\t\tSET_LMM(__lmm_name); \\\n\t\t} while (0)\n\n\tswitch (port_type) {\n\tcase FW_PORT_TYPE_BT_SGMII:\n\tcase FW_PORT_TYPE_BT_XFI:\n\tcase FW_PORT_TYPE_BT_XAUI:\n\t\tSET_LMM(TP);\n\t\tFW_CAPS_TO_LMM(SPEED_100M, 100baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseT_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_KX4:\n\tcase FW_PORT_TYPE_KX:\n\t\tSET_LMM(Backplane);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseKX_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKX4_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_KR:\n\t\tSET_LMM(Backplane);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKR_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_BP_AP:\n\t\tSET_LMM(Backplane);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseKX_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseR_FEC);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKR_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_BP4_AP:\n\t\tSET_LMM(Backplane);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseKX_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseR_FEC);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKR_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKX4_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_FIBER_XFI:\n\tcase FW_PORT_TYPE_FIBER_XAUI:\n\tcase FW_PORT_TYPE_SFP:\n\tcase FW_PORT_TYPE_QSFP_10G:\n\tcase FW_PORT_TYPE_QSA:\n\t\tSET_LMM(FIBRE);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseT_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_BP40_BA:\n\tcase FW_PORT_TYPE_QSFP:\n\t\tSET_LMM(FIBRE);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_40G, 40000baseSR4_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_CR_QSFP:\n\tcase FW_PORT_TYPE_SFP28:\n\t\tSET_LMM(FIBRE);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_25G, 25000baseCR_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_KR_SFP28:\n\t\tSET_LMM(Backplane);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKR_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_25G, 25000baseKR_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_KR_XLAUI:\n\t\tSET_LMM(Backplane);\n\t\tFW_CAPS_TO_LMM(SPEED_1G, 1000baseKX_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKR_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_40G, 40000baseKR4_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_CR2_QSFP:\n\t\tSET_LMM(FIBRE);\n\t\tFW_CAPS_TO_LMM(SPEED_50G, 50000baseSR2_Full);\n\t\tbreak;\n\n\tcase FW_PORT_TYPE_KR4_100G:\n\tcase FW_PORT_TYPE_CR4_QSFP:\n\t\tSET_LMM(FIBRE);\n\t\tFW_CAPS_TO_LMM(SPEED_1G,  1000baseT_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_10G, 10000baseKR_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_40G, 40000baseSR4_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_25G, 25000baseCR_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_50G, 50000baseCR2_Full);\n\t\tFW_CAPS_TO_LMM(SPEED_100G, 100000baseCR4_Full);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (fw_caps & FW_PORT_CAP32_FEC_V(FW_PORT_CAP32_FEC_M)) {\n\t\tFW_CAPS_TO_LMM(FEC_RS, FEC_RS);\n\t\tFW_CAPS_TO_LMM(FEC_BASER_RS, FEC_BASER);\n\t} else {\n\t\tSET_LMM(FEC_NONE);\n\t}\n\n\tFW_CAPS_TO_LMM(ANEG, Autoneg);\n\tFW_CAPS_TO_LMM(802_3_PAUSE, Pause);\n\tFW_CAPS_TO_LMM(802_3_ASM_DIR, Asym_Pause);\n\n\t#undef FW_CAPS_TO_LMM\n\t#undef SET_LMM\n}\n\nstatic int cxgb4vf_get_link_ksettings(struct net_device *dev,\n\t\t\t\t  struct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\tstruct ethtool_link_settings *base = &link_ksettings->base;\n\n\t \n\tif (!netif_running(dev))\n\t\t(void)t4vf_update_port_info(pi);\n\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, supported);\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, advertising);\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, lp_advertising);\n\n\tbase->port = from_fw_port_mod_type(pi->port_type, pi->mod_type);\n\n\tif (pi->mdio_addr >= 0) {\n\t\tbase->phy_address = pi->mdio_addr;\n\t\tbase->mdio_support = (pi->port_type == FW_PORT_TYPE_BT_SGMII\n\t\t\t\t      ? ETH_MDIO_SUPPORTS_C22\n\t\t\t\t      : ETH_MDIO_SUPPORTS_C45);\n\t} else {\n\t\tbase->phy_address = 255;\n\t\tbase->mdio_support = 0;\n\t}\n\n\tfw_caps_to_lmm(pi->port_type, pi->link_cfg.pcaps,\n\t\t       link_ksettings->link_modes.supported);\n\tfw_caps_to_lmm(pi->port_type, pi->link_cfg.acaps,\n\t\t       link_ksettings->link_modes.advertising);\n\tfw_caps_to_lmm(pi->port_type, pi->link_cfg.lpacaps,\n\t\t       link_ksettings->link_modes.lp_advertising);\n\n\tif (netif_carrier_ok(dev)) {\n\t\tbase->speed = pi->link_cfg.speed;\n\t\tbase->duplex = DUPLEX_FULL;\n\t} else {\n\t\tbase->speed = SPEED_UNKNOWN;\n\t\tbase->duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tbase->autoneg = pi->link_cfg.autoneg;\n\tif (pi->link_cfg.pcaps & FW_PORT_CAP32_ANEG)\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     supported, Autoneg);\n\tif (pi->link_cfg.autoneg)\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, Autoneg);\n\n\treturn 0;\n}\n\n \nstatic inline unsigned int fwcap_to_eth_fec(unsigned int fw_fec)\n{\n\tunsigned int eth_fec = 0;\n\n\tif (fw_fec & FW_PORT_CAP32_FEC_RS)\n\t\teth_fec |= ETHTOOL_FEC_RS;\n\tif (fw_fec & FW_PORT_CAP32_FEC_BASER_RS)\n\t\teth_fec |= ETHTOOL_FEC_BASER;\n\n\t \n\tif (!eth_fec)\n\t\teth_fec = ETHTOOL_FEC_OFF;\n\n\treturn eth_fec;\n}\n\n \nstatic inline unsigned int cc_to_eth_fec(unsigned int cc_fec)\n{\n\tunsigned int eth_fec = 0;\n\n\tif (cc_fec & FEC_AUTO)\n\t\teth_fec |= ETHTOOL_FEC_AUTO;\n\tif (cc_fec & FEC_RS)\n\t\teth_fec |= ETHTOOL_FEC_RS;\n\tif (cc_fec & FEC_BASER_RS)\n\t\teth_fec |= ETHTOOL_FEC_BASER;\n\n\t \n\tif (!eth_fec)\n\t\teth_fec = ETHTOOL_FEC_OFF;\n\n\treturn eth_fec;\n}\n\nstatic int cxgb4vf_get_fecparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_fecparam *fec)\n{\n\tconst struct port_info *pi = netdev_priv(dev);\n\tconst struct link_config *lc = &pi->link_cfg;\n\n\t \n\tfec->fec = fwcap_to_eth_fec(lc->pcaps);\n\tif (fec->fec != ETHTOOL_FEC_OFF)\n\t\tfec->fec |= ETHTOOL_FEC_AUTO;\n\n\t \n\tfec->active_fec = cc_to_eth_fec(lc->fec);\n\treturn 0;\n}\n\n \nstatic void cxgb4vf_get_drvinfo(struct net_device *dev,\n\t\t\t\tstruct ethtool_drvinfo *drvinfo)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\n\tstrscpy(drvinfo->driver, KBUILD_MODNAME, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->bus_info, pci_name(to_pci_dev(dev->dev.parent)),\n\t\tsizeof(drvinfo->bus_info));\n\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t \"%u.%u.%u.%u, TP %u.%u.%u.%u\",\n\t\t FW_HDR_FW_VER_MAJOR_G(adapter->params.dev.fwrev),\n\t\t FW_HDR_FW_VER_MINOR_G(adapter->params.dev.fwrev),\n\t\t FW_HDR_FW_VER_MICRO_G(adapter->params.dev.fwrev),\n\t\t FW_HDR_FW_VER_BUILD_G(adapter->params.dev.fwrev),\n\t\t FW_HDR_FW_VER_MAJOR_G(adapter->params.dev.tprev),\n\t\t FW_HDR_FW_VER_MINOR_G(adapter->params.dev.tprev),\n\t\t FW_HDR_FW_VER_MICRO_G(adapter->params.dev.tprev),\n\t\t FW_HDR_FW_VER_BUILD_G(adapter->params.dev.tprev));\n}\n\n \nstatic u32 cxgb4vf_get_msglevel(struct net_device *dev)\n{\n\treturn netdev2adap(dev)->msg_enable;\n}\n\n \nstatic void cxgb4vf_set_msglevel(struct net_device *dev, u32 msglevel)\n{\n\tnetdev2adap(dev)->msg_enable = msglevel;\n}\n\n \nstatic void cxgb4vf_get_ringparam(struct net_device *dev,\n\t\t\t\t  struct ethtool_ringparam *rp,\n\t\t\t\t  struct kernel_ethtool_ringparam *kernel_rp,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tconst struct port_info *pi = netdev_priv(dev);\n\tconst struct sge *s = &pi->adapter->sge;\n\n\trp->rx_max_pending = MAX_RX_BUFFERS;\n\trp->rx_mini_max_pending = MAX_RSPQ_ENTRIES;\n\trp->rx_jumbo_max_pending = 0;\n\trp->tx_max_pending = MAX_TXQ_ENTRIES;\n\n\trp->rx_pending = s->ethrxq[pi->first_qset].fl.size - MIN_FL_RESID;\n\trp->rx_mini_pending = s->ethrxq[pi->first_qset].rspq.size;\n\trp->rx_jumbo_pending = 0;\n\trp->tx_pending = s->ethtxq[pi->first_qset].q.size;\n}\n\n \nstatic int cxgb4vf_set_ringparam(struct net_device *dev,\n\t\t\t\t struct ethtool_ringparam *rp,\n\t\t\t\t struct kernel_ethtool_ringparam *kernel_rp,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tconst struct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tstruct sge *s = &adapter->sge;\n\tint qs;\n\n\tif (rp->rx_pending > MAX_RX_BUFFERS ||\n\t    rp->rx_jumbo_pending ||\n\t    rp->tx_pending > MAX_TXQ_ENTRIES ||\n\t    rp->rx_mini_pending > MAX_RSPQ_ENTRIES ||\n\t    rp->rx_mini_pending < MIN_RSPQ_ENTRIES ||\n\t    rp->rx_pending < MIN_FL_ENTRIES ||\n\t    rp->tx_pending < MIN_TXQ_ENTRIES)\n\t\treturn -EINVAL;\n\n\tif (adapter->flags & CXGB4VF_FULL_INIT_DONE)\n\t\treturn -EBUSY;\n\n\tfor (qs = pi->first_qset; qs < pi->first_qset + pi->nqsets; qs++) {\n\t\ts->ethrxq[qs].fl.size = rp->rx_pending + MIN_FL_RESID;\n\t\ts->ethrxq[qs].rspq.size = rp->rx_mini_pending;\n\t\ts->ethtxq[qs].q.size = rp->tx_pending;\n\t}\n\treturn 0;\n}\n\n \nstatic int cxgb4vf_get_coalesce(struct net_device *dev,\n\t\t\t\tstruct ethtool_coalesce *coalesce,\n\t\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst struct port_info *pi = netdev_priv(dev);\n\tconst struct adapter *adapter = pi->adapter;\n\tconst struct sge_rspq *rspq = &adapter->sge.ethrxq[pi->first_qset].rspq;\n\n\tcoalesce->rx_coalesce_usecs = qtimer_val(adapter, rspq);\n\tcoalesce->rx_max_coalesced_frames =\n\t\t((rspq->intr_params & QINTR_CNT_EN_F)\n\t\t ? adapter->sge.counter_val[rspq->pktcnt_idx]\n\t\t : 0);\n\treturn 0;\n}\n\n \nstatic int cxgb4vf_set_coalesce(struct net_device *dev,\n\t\t\t\tstruct ethtool_coalesce *coalesce,\n\t\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst struct port_info *pi = netdev_priv(dev);\n\tstruct adapter *adapter = pi->adapter;\n\n\treturn set_rxq_intr_params(adapter,\n\t\t\t\t   &adapter->sge.ethrxq[pi->first_qset].rspq,\n\t\t\t\t   coalesce->rx_coalesce_usecs,\n\t\t\t\t   coalesce->rx_max_coalesced_frames);\n}\n\n \nstatic void cxgb4vf_get_pauseparam(struct net_device *dev,\n\t\t\t\t   struct ethtool_pauseparam *pauseparam)\n{\n\tstruct port_info *pi = netdev_priv(dev);\n\n\tpauseparam->autoneg = (pi->link_cfg.requested_fc & PAUSE_AUTONEG) != 0;\n\tpauseparam->rx_pause = (pi->link_cfg.advertised_fc & PAUSE_RX) != 0;\n\tpauseparam->tx_pause = (pi->link_cfg.advertised_fc & PAUSE_TX) != 0;\n}\n\n \nstatic int cxgb4vf_phys_id(struct net_device *dev,\n\t\t\t   enum ethtool_phys_id_state state)\n{\n\tunsigned int val;\n\tstruct port_info *pi = netdev_priv(dev);\n\n\tif (state == ETHTOOL_ID_ACTIVE)\n\t\tval = 0xffff;\n\telse if (state == ETHTOOL_ID_INACTIVE)\n\t\tval = 0;\n\telse\n\t\treturn -EINVAL;\n\n\treturn t4vf_identify_port(pi->adapter, pi->viid, val);\n}\n\n \nstruct queue_port_stats {\n\tu64 tso;\n\tu64 tx_csum;\n\tu64 rx_csum;\n\tu64 vlan_ex;\n\tu64 vlan_ins;\n\tu64 lro_pkts;\n\tu64 lro_merged;\n};\n\n \nstatic const char stats_strings[][ETH_GSTRING_LEN] = {\n\t \n\t\"TxBroadcastBytes  \",\n\t\"TxBroadcastFrames \",\n\t\"TxMulticastBytes  \",\n\t\"TxMulticastFrames \",\n\t\"TxUnicastBytes    \",\n\t\"TxUnicastFrames   \",\n\t\"TxDroppedFrames   \",\n\t\"TxOffloadBytes    \",\n\t\"TxOffloadFrames   \",\n\t\"RxBroadcastBytes  \",\n\t\"RxBroadcastFrames \",\n\t\"RxMulticastBytes  \",\n\t\"RxMulticastFrames \",\n\t\"RxUnicastBytes    \",\n\t\"RxUnicastFrames   \",\n\t\"RxErrorFrames     \",\n\n\t \n\t\"TSO               \",\n\t\"TxCsumOffload     \",\n\t\"RxCsumGood        \",\n\t\"VLANextractions   \",\n\t\"VLANinsertions    \",\n\t\"GROPackets        \",\n\t\"GROMerged         \",\n};\n\n \nstatic int cxgb4vf_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(stats_strings);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\t \n}\n\n \nstatic void cxgb4vf_get_strings(struct net_device *dev,\n\t\t\t\tu32 sset,\n\t\t\t\tu8 *data)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(data, stats_strings, sizeof(stats_strings));\n\t\tbreak;\n\t}\n}\n\n \nstatic void collect_sge_port_stats(const struct adapter *adapter,\n\t\t\t\t   const struct port_info *pi,\n\t\t\t\t   struct queue_port_stats *stats)\n{\n\tconst struct sge_eth_txq *txq = &adapter->sge.ethtxq[pi->first_qset];\n\tconst struct sge_eth_rxq *rxq = &adapter->sge.ethrxq[pi->first_qset];\n\tint qs;\n\n\tmemset(stats, 0, sizeof(*stats));\n\tfor (qs = 0; qs < pi->nqsets; qs++, rxq++, txq++) {\n\t\tstats->tso += txq->tso;\n\t\tstats->tx_csum += txq->tx_cso;\n\t\tstats->rx_csum += rxq->stats.rx_cso;\n\t\tstats->vlan_ex += rxq->stats.vlan_ex;\n\t\tstats->vlan_ins += txq->vlan_ins;\n\t\tstats->lro_pkts += rxq->stats.lro_pkts;\n\t\tstats->lro_merged += rxq->stats.lro_merged;\n\t}\n}\n\n \nstatic void cxgb4vf_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t      struct ethtool_stats *stats,\n\t\t\t\t      u64 *data)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct adapter *adapter = pi->adapter;\n\tint err = t4vf_get_port_stats(adapter, pi->pidx,\n\t\t\t\t      (struct t4vf_port_stats *)data);\n\tif (err)\n\t\tmemset(data, 0, sizeof(struct t4vf_port_stats));\n\n\tdata += sizeof(struct t4vf_port_stats) / sizeof(u64);\n\tcollect_sge_port_stats(adapter, pi, (struct queue_port_stats *)data);\n}\n\n \nstatic int cxgb4vf_get_regs_len(struct net_device *dev)\n{\n\treturn T4VF_REGMAP_SIZE;\n}\n\n \nstatic void reg_block_dump(struct adapter *adapter, void *regbuf,\n\t\t\t   unsigned int start, unsigned int end)\n{\n\tu32 *bp = regbuf + start - T4VF_REGMAP_START;\n\n\tfor ( ; start <= end; start += sizeof(u32)) {\n\t\t \n\t\tif (start == T4VF_CIM_BASE_ADDR + CIM_VF_EXT_MAILBOX_CTRL)\n\t\t\t*bp++ = 0xffff;\n\t\telse\n\t\t\t*bp++ = t4_read_reg(adapter, start);\n\t}\n}\n\n \nstatic void cxgb4vf_get_regs(struct net_device *dev,\n\t\t\t     struct ethtool_regs *regs,\n\t\t\t     void *regbuf)\n{\n\tstruct adapter *adapter = netdev2adap(dev);\n\n\tregs->version = mk_adap_vers(adapter);\n\n\t \n\tmemset(regbuf, 0, T4VF_REGMAP_SIZE);\n\n\treg_block_dump(adapter, regbuf,\n\t\t       T4VF_SGE_BASE_ADDR + T4VF_MOD_MAP_SGE_FIRST,\n\t\t       T4VF_SGE_BASE_ADDR + T4VF_MOD_MAP_SGE_LAST);\n\treg_block_dump(adapter, regbuf,\n\t\t       T4VF_MPS_BASE_ADDR + T4VF_MOD_MAP_MPS_FIRST,\n\t\t       T4VF_MPS_BASE_ADDR + T4VF_MOD_MAP_MPS_LAST);\n\n\t \n\treg_block_dump(adapter, regbuf,\n\t\t       T4VF_PL_BASE_ADDR + T4VF_MOD_MAP_PL_FIRST,\n\t\t       T4VF_PL_BASE_ADDR + (is_t4(adapter->params.chip)\n\t\t       ? PL_VF_WHOAMI_A : PL_VF_REVISION_A));\n\treg_block_dump(adapter, regbuf,\n\t\t       T4VF_CIM_BASE_ADDR + T4VF_MOD_MAP_CIM_FIRST,\n\t\t       T4VF_CIM_BASE_ADDR + T4VF_MOD_MAP_CIM_LAST);\n\n\treg_block_dump(adapter, regbuf,\n\t\t       T4VF_MBDATA_BASE_ADDR + T4VF_MBDATA_FIRST,\n\t\t       T4VF_MBDATA_BASE_ADDR + T4VF_MBDATA_LAST);\n}\n\n \nstatic void cxgb4vf_get_wol(struct net_device *dev,\n\t\t\t    struct ethtool_wolinfo *wol)\n{\n\twol->supported = 0;\n\twol->wolopts = 0;\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n}\n\n \n#define TSO_FLAGS (NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_TSO_ECN)\n#define VLAN_FEAT (NETIF_F_SG | NETIF_F_IP_CSUM | TSO_FLAGS | \\\n\t\t   NETIF_F_GRO | NETIF_F_IPV6_CSUM | NETIF_F_HIGHDMA)\n\nstatic const struct ethtool_ops cxgb4vf_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_RX_MAX_FRAMES,\n\t.get_link_ksettings\t= cxgb4vf_get_link_ksettings,\n\t.get_fecparam\t\t= cxgb4vf_get_fecparam,\n\t.get_drvinfo\t\t= cxgb4vf_get_drvinfo,\n\t.get_msglevel\t\t= cxgb4vf_get_msglevel,\n\t.set_msglevel\t\t= cxgb4vf_set_msglevel,\n\t.get_ringparam\t\t= cxgb4vf_get_ringparam,\n\t.set_ringparam\t\t= cxgb4vf_set_ringparam,\n\t.get_coalesce\t\t= cxgb4vf_get_coalesce,\n\t.set_coalesce\t\t= cxgb4vf_set_coalesce,\n\t.get_pauseparam\t\t= cxgb4vf_get_pauseparam,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= cxgb4vf_get_strings,\n\t.set_phys_id\t\t= cxgb4vf_phys_id,\n\t.get_sset_count\t\t= cxgb4vf_get_sset_count,\n\t.get_ethtool_stats\t= cxgb4vf_get_ethtool_stats,\n\t.get_regs_len\t\t= cxgb4vf_get_regs_len,\n\t.get_regs\t\t= cxgb4vf_get_regs,\n\t.get_wol\t\t= cxgb4vf_get_wol,\n};\n\n \n\n \nstatic int mboxlog_show(struct seq_file *seq, void *v)\n{\n\tstruct adapter *adapter = seq->private;\n\tstruct mbox_cmd_log *log = adapter->mbox_log;\n\tstruct mbox_cmd *entry;\n\tint entry_idx, i;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(seq,\n\t\t\t   \"%10s  %15s  %5s  %5s  %s\\n\",\n\t\t\t   \"Seq#\", \"Tstamp\", \"Atime\", \"Etime\",\n\t\t\t   \"Command/Reply\");\n\t\treturn 0;\n\t}\n\n\tentry_idx = log->cursor + ((uintptr_t)v - 2);\n\tif (entry_idx >= log->size)\n\t\tentry_idx -= log->size;\n\tentry = mbox_cmd_log_entry(log, entry_idx);\n\n\t \n\tif (entry->timestamp == 0)\n\t\treturn 0;\n\n\tseq_printf(seq, \"%10u  %15llu  %5d  %5d\",\n\t\t   entry->seqno, entry->timestamp,\n\t\t   entry->access, entry->execute);\n\tfor (i = 0; i < MBOX_LEN / 8; i++) {\n\t\tu64 flit = entry->cmd[i];\n\t\tu32 hi = (u32)(flit >> 32);\n\t\tu32 lo = (u32)flit;\n\n\t\tseq_printf(seq, \"  %08x %08x\", hi, lo);\n\t}\n\tseq_puts(seq, \"\\n\");\n\treturn 0;\n}\n\nstatic inline void *mboxlog_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct adapter *adapter = seq->private;\n\tstruct mbox_cmd_log *log = adapter->mbox_log;\n\n\treturn ((pos <= log->size) ? (void *)(uintptr_t)(pos + 1) : NULL);\n}\n\nstatic void *mboxlog_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn *pos ? mboxlog_get_idx(seq, *pos) : SEQ_START_TOKEN;\n}\n\nstatic void *mboxlog_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn mboxlog_get_idx(seq, *pos);\n}\n\nstatic void mboxlog_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic const struct seq_operations mboxlog_sops = {\n\t.start = mboxlog_start,\n\t.next  = mboxlog_next,\n\t.stop  = mboxlog_stop,\n\t.show  = mboxlog_show\n};\n\nDEFINE_SEQ_ATTRIBUTE(mboxlog);\n \n#define QPL\t4\n\nstatic int sge_qinfo_show(struct seq_file *seq, void *v)\n{\n\tstruct adapter *adapter = seq->private;\n\tint eth_entries = DIV_ROUND_UP(adapter->sge.ethqsets, QPL);\n\tint qs, r = (uintptr_t)v - 1;\n\n\tif (r)\n\t\tseq_putc(seq, '\\n');\n\n\t#define S3(fmt_spec, s, v) \\\n\t\tdo {\\\n\t\t\tseq_printf(seq, \"%-12s\", s); \\\n\t\t\tfor (qs = 0; qs < n; ++qs) \\\n\t\t\t\tseq_printf(seq, \" %16\" fmt_spec, v); \\\n\t\t\tseq_putc(seq, '\\n'); \\\n\t\t} while (0)\n\t#define S(s, v)\t\tS3(\"s\", s, v)\n\t#define T(s, v)\t\tS3(\"u\", s, txq[qs].v)\n\t#define R(s, v)\t\tS3(\"u\", s, rxq[qs].v)\n\n\tif (r < eth_entries) {\n\t\tconst struct sge_eth_rxq *rxq = &adapter->sge.ethrxq[r * QPL];\n\t\tconst struct sge_eth_txq *txq = &adapter->sge.ethtxq[r * QPL];\n\t\tint n = min(QPL, adapter->sge.ethqsets - QPL * r);\n\n\t\tS(\"QType:\", \"Ethernet\");\n\t\tS(\"Interface:\",\n\t\t  (rxq[qs].rspq.netdev\n\t\t   ? rxq[qs].rspq.netdev->name\n\t\t   : \"N/A\"));\n\t\tS3(\"d\", \"Port:\",\n\t\t   (rxq[qs].rspq.netdev\n\t\t    ? ((struct port_info *)\n\t\t       netdev_priv(rxq[qs].rspq.netdev))->port_id\n\t\t    : -1));\n\t\tT(\"TxQ ID:\", q.abs_id);\n\t\tT(\"TxQ size:\", q.size);\n\t\tT(\"TxQ inuse:\", q.in_use);\n\t\tT(\"TxQ PIdx:\", q.pidx);\n\t\tT(\"TxQ CIdx:\", q.cidx);\n\t\tR(\"RspQ ID:\", rspq.abs_id);\n\t\tR(\"RspQ size:\", rspq.size);\n\t\tR(\"RspQE size:\", rspq.iqe_len);\n\t\tS3(\"u\", \"Intr delay:\", qtimer_val(adapter, &rxq[qs].rspq));\n\t\tS3(\"u\", \"Intr pktcnt:\",\n\t\t   adapter->sge.counter_val[rxq[qs].rspq.pktcnt_idx]);\n\t\tR(\"RspQ CIdx:\", rspq.cidx);\n\t\tR(\"RspQ Gen:\", rspq.gen);\n\t\tR(\"FL ID:\", fl.abs_id);\n\t\tR(\"FL size:\", fl.size - MIN_FL_RESID);\n\t\tR(\"FL avail:\", fl.avail);\n\t\tR(\"FL PIdx:\", fl.pidx);\n\t\tR(\"FL CIdx:\", fl.cidx);\n\t\treturn 0;\n\t}\n\n\tr -= eth_entries;\n\tif (r == 0) {\n\t\tconst struct sge_rspq *evtq = &adapter->sge.fw_evtq;\n\n\t\tseq_printf(seq, \"%-12s %16s\\n\", \"QType:\", \"FW event queue\");\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"RspQ ID:\", evtq->abs_id);\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"Intr delay:\",\n\t\t\t   qtimer_val(adapter, evtq));\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"Intr pktcnt:\",\n\t\t\t   adapter->sge.counter_val[evtq->pktcnt_idx]);\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"RspQ Cidx:\", evtq->cidx);\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"RspQ Gen:\", evtq->gen);\n\t} else if (r == 1) {\n\t\tconst struct sge_rspq *intrq = &adapter->sge.intrq;\n\n\t\tseq_printf(seq, \"%-12s %16s\\n\", \"QType:\", \"Interrupt Queue\");\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"RspQ ID:\", intrq->abs_id);\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"Intr delay:\",\n\t\t\t   qtimer_val(adapter, intrq));\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"Intr pktcnt:\",\n\t\t\t   adapter->sge.counter_val[intrq->pktcnt_idx]);\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"RspQ Cidx:\", intrq->cidx);\n\t\tseq_printf(seq, \"%-12s %16u\\n\", \"RspQ Gen:\", intrq->gen);\n\t}\n\n\t#undef R\n\t#undef T\n\t#undef S\n\t#undef S3\n\n\treturn 0;\n}\n\n \nstatic int sge_queue_entries(const struct adapter *adapter)\n{\n\treturn DIV_ROUND_UP(adapter->sge.ethqsets, QPL) + 1 +\n\t\t((adapter->flags & CXGB4VF_USING_MSI) != 0);\n}\n\nstatic void *sge_queue_start(struct seq_file *seq, loff_t *pos)\n{\n\tint entries = sge_queue_entries(seq->private);\n\n\treturn *pos < entries ? (void *)((uintptr_t)*pos + 1) : NULL;\n}\n\nstatic void sge_queue_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic void *sge_queue_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tint entries = sge_queue_entries(seq->private);\n\n\t++*pos;\n\treturn *pos < entries ? (void *)((uintptr_t)*pos + 1) : NULL;\n}\n\nstatic const struct seq_operations sge_qinfo_sops = {\n\t.start = sge_queue_start,\n\t.next  = sge_queue_next,\n\t.stop  = sge_queue_stop,\n\t.show  = sge_qinfo_show\n};\n\nDEFINE_SEQ_ATTRIBUTE(sge_qinfo);\n\n \n#define QPL\t4\n\nstatic int sge_qstats_show(struct seq_file *seq, void *v)\n{\n\tstruct adapter *adapter = seq->private;\n\tint eth_entries = DIV_ROUND_UP(adapter->sge.ethqsets, QPL);\n\tint qs, r = (uintptr_t)v - 1;\n\n\tif (r)\n\t\tseq_putc(seq, '\\n');\n\n\t#define S3(fmt, s, v) \\\n\t\tdo { \\\n\t\t\tseq_printf(seq, \"%-16s\", s); \\\n\t\t\tfor (qs = 0; qs < n; ++qs) \\\n\t\t\t\tseq_printf(seq, \" %8\" fmt, v); \\\n\t\t\tseq_putc(seq, '\\n'); \\\n\t\t} while (0)\n\t#define S(s, v)\t\tS3(\"s\", s, v)\n\n\t#define T3(fmt, s, v)\tS3(fmt, s, txq[qs].v)\n\t#define T(s, v)\t\tT3(\"lu\", s, v)\n\n\t#define R3(fmt, s, v)\tS3(fmt, s, rxq[qs].v)\n\t#define R(s, v)\t\tR3(\"lu\", s, v)\n\n\tif (r < eth_entries) {\n\t\tconst struct sge_eth_rxq *rxq = &adapter->sge.ethrxq[r * QPL];\n\t\tconst struct sge_eth_txq *txq = &adapter->sge.ethtxq[r * QPL];\n\t\tint n = min(QPL, adapter->sge.ethqsets - QPL * r);\n\n\t\tS(\"QType:\", \"Ethernet\");\n\t\tS(\"Interface:\",\n\t\t  (rxq[qs].rspq.netdev\n\t\t   ? rxq[qs].rspq.netdev->name\n\t\t   : \"N/A\"));\n\t\tR3(\"u\", \"RspQNullInts:\", rspq.unhandled_irqs);\n\t\tR(\"RxPackets:\", stats.pkts);\n\t\tR(\"RxCSO:\", stats.rx_cso);\n\t\tR(\"VLANxtract:\", stats.vlan_ex);\n\t\tR(\"LROmerged:\", stats.lro_merged);\n\t\tR(\"LROpackets:\", stats.lro_pkts);\n\t\tR(\"RxDrops:\", stats.rx_drops);\n\t\tT(\"TSO:\", tso);\n\t\tT(\"TxCSO:\", tx_cso);\n\t\tT(\"VLANins:\", vlan_ins);\n\t\tT(\"TxQFull:\", q.stops);\n\t\tT(\"TxQRestarts:\", q.restarts);\n\t\tT(\"TxMapErr:\", mapping_err);\n\t\tR(\"FLAllocErr:\", fl.alloc_failed);\n\t\tR(\"FLLrgAlcErr:\", fl.large_alloc_failed);\n\t\tR(\"FLStarving:\", fl.starving);\n\t\treturn 0;\n\t}\n\n\tr -= eth_entries;\n\tif (r == 0) {\n\t\tconst struct sge_rspq *evtq = &adapter->sge.fw_evtq;\n\n\t\tseq_printf(seq, \"%-8s %16s\\n\", \"QType:\", \"FW event queue\");\n\t\tseq_printf(seq, \"%-16s %8u\\n\", \"RspQNullInts:\",\n\t\t\t   evtq->unhandled_irqs);\n\t\tseq_printf(seq, \"%-16s %8u\\n\", \"RspQ CIdx:\", evtq->cidx);\n\t\tseq_printf(seq, \"%-16s %8u\\n\", \"RspQ Gen:\", evtq->gen);\n\t} else if (r == 1) {\n\t\tconst struct sge_rspq *intrq = &adapter->sge.intrq;\n\n\t\tseq_printf(seq, \"%-8s %16s\\n\", \"QType:\", \"Interrupt Queue\");\n\t\tseq_printf(seq, \"%-16s %8u\\n\", \"RspQNullInts:\",\n\t\t\t   intrq->unhandled_irqs);\n\t\tseq_printf(seq, \"%-16s %8u\\n\", \"RspQ CIdx:\", intrq->cidx);\n\t\tseq_printf(seq, \"%-16s %8u\\n\", \"RspQ Gen:\", intrq->gen);\n\t}\n\n\t#undef R\n\t#undef T\n\t#undef S\n\t#undef R3\n\t#undef T3\n\t#undef S3\n\n\treturn 0;\n}\n\n \nstatic int sge_qstats_entries(const struct adapter *adapter)\n{\n\treturn DIV_ROUND_UP(adapter->sge.ethqsets, QPL) + 1 +\n\t\t((adapter->flags & CXGB4VF_USING_MSI) != 0);\n}\n\nstatic void *sge_qstats_start(struct seq_file *seq, loff_t *pos)\n{\n\tint entries = sge_qstats_entries(seq->private);\n\n\treturn *pos < entries ? (void *)((uintptr_t)*pos + 1) : NULL;\n}\n\nstatic void sge_qstats_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic void *sge_qstats_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tint entries = sge_qstats_entries(seq->private);\n\n\t(*pos)++;\n\treturn *pos < entries ? (void *)((uintptr_t)*pos + 1) : NULL;\n}\n\nstatic const struct seq_operations sge_qstats_sops = {\n\t.start = sge_qstats_start,\n\t.next  = sge_qstats_next,\n\t.stop  = sge_qstats_stop,\n\t.show  = sge_qstats_show\n};\n\nDEFINE_SEQ_ATTRIBUTE(sge_qstats);\n\n \nstatic int resources_show(struct seq_file *seq, void *v)\n{\n\tstruct adapter *adapter = seq->private;\n\tstruct vf_resources *vfres = &adapter->params.vfres;\n\n\t#define S(desc, fmt, var) \\\n\t\tseq_printf(seq, \"%-60s \" fmt \"\\n\", \\\n\t\t\t   desc \" (\" #var \"):\", vfres->var)\n\n\tS(\"Virtual Interfaces\", \"%d\", nvi);\n\tS(\"Egress Queues\", \"%d\", neq);\n\tS(\"Ethernet Control\", \"%d\", nethctrl);\n\tS(\"Ingress Queues/w Free Lists/Interrupts\", \"%d\", niqflint);\n\tS(\"Ingress Queues\", \"%d\", niq);\n\tS(\"Traffic Class\", \"%d\", tc);\n\tS(\"Port Access Rights Mask\", \"%#x\", pmask);\n\tS(\"MAC Address Filters\", \"%d\", nexactf);\n\tS(\"Firmware Command Read Capabilities\", \"%#x\", r_caps);\n\tS(\"Firmware Command Write/Execute Capabilities\", \"%#x\", wx_caps);\n\n\t#undef S\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(resources);\n\n \nstatic int interfaces_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"Interface  Port   VIID\\n\");\n\t} else {\n\t\tstruct adapter *adapter = seq->private;\n\t\tint pidx = (uintptr_t)v - 2;\n\t\tstruct net_device *dev = adapter->port[pidx];\n\t\tstruct port_info *pi = netdev_priv(dev);\n\n\t\tseq_printf(seq, \"%9s  %4d  %#5x\\n\",\n\t\t\t   dev->name, pi->port_id, pi->viid);\n\t}\n\treturn 0;\n}\n\nstatic inline void *interfaces_get_idx(struct adapter *adapter, loff_t pos)\n{\n\treturn pos <= adapter->params.nports\n\t\t? (void *)(uintptr_t)(pos + 1)\n\t\t: NULL;\n}\n\nstatic void *interfaces_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn *pos\n\t\t? interfaces_get_idx(seq->private, *pos)\n\t\t: SEQ_START_TOKEN;\n}\n\nstatic void *interfaces_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn interfaces_get_idx(seq->private, *pos);\n}\n\nstatic void interfaces_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic const struct seq_operations interfaces_sops = {\n\t.start = interfaces_start,\n\t.next  = interfaces_next,\n\t.stop  = interfaces_stop,\n\t.show  = interfaces_show\n};\n\nDEFINE_SEQ_ATTRIBUTE(interfaces);\n\n \nstruct cxgb4vf_debugfs_entry {\n\tconst char *name;\t\t \n\tumode_t mode;\t\t\t \n\tconst struct file_operations *fops;\n};\n\nstatic struct cxgb4vf_debugfs_entry debugfs_files[] = {\n\t{ \"mboxlog\",    0444, &mboxlog_fops },\n\t{ \"sge_qinfo\",  0444, &sge_qinfo_fops },\n\t{ \"sge_qstats\", 0444, &sge_qstats_fops },\n\t{ \"resources\",  0444, &resources_fops },\n\t{ \"interfaces\", 0444, &interfaces_fops },\n};\n\n \n\n \nstatic int setup_debugfs(struct adapter *adapter)\n{\n\tint i;\n\n\tBUG_ON(IS_ERR_OR_NULL(adapter->debugfs_root));\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(debugfs_files); i++)\n\t\tdebugfs_create_file(debugfs_files[i].name,\n\t\t\t\t    debugfs_files[i].mode,\n\t\t\t\t    adapter->debugfs_root, adapter,\n\t\t\t\t    debugfs_files[i].fops);\n\n\treturn 0;\n}\n\n \nstatic void cleanup_debugfs(struct adapter *adapter)\n{\n\tBUG_ON(IS_ERR_OR_NULL(adapter->debugfs_root));\n\n\t \n\t \n}\n\n \nstatic void size_nports_qsets(struct adapter *adapter)\n{\n\tstruct vf_resources *vfres = &adapter->params.vfres;\n\tunsigned int ethqsets, pmask_nports;\n\n\t \n\tadapter->params.nports = vfres->nvi;\n\tif (adapter->params.nports > MAX_NPORTS) {\n\t\tdev_warn(adapter->pdev_dev, \"only using %d of %d maximum\"\n\t\t\t \" allowed virtual interfaces\\n\", MAX_NPORTS,\n\t\t\t adapter->params.nports);\n\t\tadapter->params.nports = MAX_NPORTS;\n\t}\n\n\t \n\tpmask_nports = hweight32(adapter->params.vfres.pmask);\n\tif (pmask_nports < adapter->params.nports) {\n\t\tdev_warn(adapter->pdev_dev, \"only using %d of %d provisioned\"\n\t\t\t \" virtual interfaces; limited by Port Access Rights\"\n\t\t\t \" mask %#x\\n\", pmask_nports, adapter->params.nports,\n\t\t\t adapter->params.vfres.pmask);\n\t\tadapter->params.nports = pmask_nports;\n\t}\n\n\t \n\tethqsets = vfres->niqflint - 1 - (msi == MSI_MSI);\n\tif (vfres->nethctrl != ethqsets)\n\t\tethqsets = min(vfres->nethctrl, ethqsets);\n\tif (vfres->neq < ethqsets*2)\n\t\tethqsets = vfres->neq/2;\n\tif (ethqsets > MAX_ETH_QSETS)\n\t\tethqsets = MAX_ETH_QSETS;\n\tadapter->sge.max_ethqsets = ethqsets;\n\n\tif (adapter->sge.max_ethqsets < adapter->params.nports) {\n\t\tdev_warn(adapter->pdev_dev, \"only using %d of %d available\"\n\t\t\t \" virtual interfaces (too few Queue Sets)\\n\",\n\t\t\t adapter->sge.max_ethqsets, adapter->params.nports);\n\t\tadapter->params.nports = adapter->sge.max_ethqsets;\n\t}\n}\n\n \nstatic int adap_init0(struct adapter *adapter)\n{\n\tstruct sge_params *sge_params = &adapter->params.sge;\n\tstruct sge *s = &adapter->sge;\n\tint err;\n\tu32 param, val = 0;\n\n\t \n\terr = t4vf_fw_reset(adapter);\n\tif (err < 0) {\n\t\tdev_err(adapter->pdev_dev, \"FW reset failed: err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = t4vf_get_dev_params(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev, \"unable to retrieve adapter\"\n\t\t\t\" device parameters: err=%d\\n\", err);\n\t\treturn err;\n\t}\n\terr = t4vf_get_vpd_params(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev, \"unable to retrieve adapter\"\n\t\t\t\" VPD parameters: err=%d\\n\", err);\n\t\treturn err;\n\t}\n\terr = t4vf_get_sge_params(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev, \"unable to retrieve adapter\"\n\t\t\t\" SGE parameters: err=%d\\n\", err);\n\t\treturn err;\n\t}\n\terr = t4vf_get_rss_glb_config(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev, \"unable to retrieve adapter\"\n\t\t\t\" RSS parameters: err=%d\\n\", err);\n\t\treturn err;\n\t}\n\tif (adapter->params.rss.mode !=\n\t    FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL) {\n\t\tdev_err(adapter->pdev_dev, \"unable to operate with global RSS\"\n\t\t\t\" mode %d\\n\", adapter->params.rss.mode);\n\t\treturn -EINVAL;\n\t}\n\terr = t4vf_sge_init(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev, \"unable to use adapter parameters:\"\n\t\t\t\" err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tparam = FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_PFVF) |\n\t\tFW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_PFVF_CPLFW4MSG_ENCAP);\n\tval = 1;\n\t(void) t4vf_set_params(adapter, 1, &param, &val);\n\n\t \n\ts->timer_val[0] = core_ticks_to_us(adapter,\n\t\tTIMERVALUE0_G(sge_params->sge_timer_value_0_and_1));\n\ts->timer_val[1] = core_ticks_to_us(adapter,\n\t\tTIMERVALUE1_G(sge_params->sge_timer_value_0_and_1));\n\ts->timer_val[2] = core_ticks_to_us(adapter,\n\t\tTIMERVALUE0_G(sge_params->sge_timer_value_2_and_3));\n\ts->timer_val[3] = core_ticks_to_us(adapter,\n\t\tTIMERVALUE1_G(sge_params->sge_timer_value_2_and_3));\n\ts->timer_val[4] = core_ticks_to_us(adapter,\n\t\tTIMERVALUE0_G(sge_params->sge_timer_value_4_and_5));\n\ts->timer_val[5] = core_ticks_to_us(adapter,\n\t\tTIMERVALUE1_G(sge_params->sge_timer_value_4_and_5));\n\n\ts->counter_val[0] = THRESHOLD_0_G(sge_params->sge_ingress_rx_threshold);\n\ts->counter_val[1] = THRESHOLD_1_G(sge_params->sge_ingress_rx_threshold);\n\ts->counter_val[2] = THRESHOLD_2_G(sge_params->sge_ingress_rx_threshold);\n\ts->counter_val[3] = THRESHOLD_3_G(sge_params->sge_ingress_rx_threshold);\n\n\t \n\terr = t4vf_get_vfres(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev, \"unable to get virtual interface\"\n\t\t\t\" resources: err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tif (adapter->params.vfres.pmask == 0) {\n\t\tdev_err(adapter->pdev_dev, \"no port access configured\\n\"\n\t\t\t\"usable!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (adapter->params.vfres.nvi == 0) {\n\t\tdev_err(adapter->pdev_dev, \"no virtual interfaces configured/\"\n\t\t\t\"usable!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsize_nports_qsets(adapter);\n\n\tadapter->flags |= CXGB4VF_FW_OK;\n\treturn 0;\n}\n\nstatic inline void init_rspq(struct sge_rspq *rspq, u8 timer_idx,\n\t\t\t     u8 pkt_cnt_idx, unsigned int size,\n\t\t\t     unsigned int iqe_size)\n{\n\trspq->intr_params = (QINTR_TIMER_IDX_V(timer_idx) |\n\t\t\t     (pkt_cnt_idx < SGE_NCOUNTERS ?\n\t\t\t      QINTR_CNT_EN_F : 0));\n\trspq->pktcnt_idx = (pkt_cnt_idx < SGE_NCOUNTERS\n\t\t\t    ? pkt_cnt_idx\n\t\t\t    : 0);\n\trspq->iqe_len = iqe_size;\n\trspq->size = size;\n}\n\n \nstatic void cfg_queues(struct adapter *adapter)\n{\n\tstruct sge *s = &adapter->sge;\n\tint q10g, n10g, qidx, pidx, qs;\n\tsize_t iqe_size;\n\n\t \n\tBUG_ON((adapter->flags &\n\t       (CXGB4VF_USING_MSIX | CXGB4VF_USING_MSI)) == 0);\n\n\t \n\tn10g = 0;\n\tfor_each_port(adapter, pidx)\n\t\tn10g += is_x_10g_port(&adap2pinfo(adapter, pidx)->link_cfg);\n\n\t \n\tif (n10g == 0)\n\t\tq10g = 0;\n\telse {\n\t\tint n1g = (adapter->params.nports - n10g);\n\t\tq10g = (adapter->sge.max_ethqsets - n1g) / n10g;\n\t\tif (q10g > num_online_cpus())\n\t\t\tq10g = num_online_cpus();\n\t}\n\n\t \n\tqidx = 0;\n\tfor_each_port(adapter, pidx) {\n\t\tstruct port_info *pi = adap2pinfo(adapter, pidx);\n\n\t\tpi->first_qset = qidx;\n\t\tpi->nqsets = is_x_10g_port(&pi->link_cfg) ? q10g : 1;\n\t\tqidx += pi->nqsets;\n\t}\n\ts->ethqsets = qidx;\n\n\t \n\tiqe_size = 64;\n\n\t \n\tfor (qs = 0; qs < s->max_ethqsets; qs++) {\n\t\tstruct sge_eth_rxq *rxq = &s->ethrxq[qs];\n\t\tstruct sge_eth_txq *txq = &s->ethtxq[qs];\n\n\t\tinit_rspq(&rxq->rspq, 0, 0, 1024, iqe_size);\n\t\trxq->fl.size = 72;\n\t\ttxq->q.size = 1024;\n\t}\n\n\t \n\tinit_rspq(&s->fw_evtq, SGE_TIMER_RSTRT_CNTR, 0, 512, iqe_size);\n\n\t \n\tinit_rspq(&s->intrq, SGE_TIMER_RSTRT_CNTR, 0, MSIX_ENTRIES + 1,\n\t\t  iqe_size);\n}\n\n \nstatic void reduce_ethqs(struct adapter *adapter, int n)\n{\n\tint i;\n\tstruct port_info *pi;\n\n\t \n\tBUG_ON(n < adapter->params.nports);\n\twhile (n < adapter->sge.ethqsets)\n\t\tfor_each_port(adapter, i) {\n\t\t\tpi = adap2pinfo(adapter, i);\n\t\t\tif (pi->nqsets > 1) {\n\t\t\t\tpi->nqsets--;\n\t\t\t\tadapter->sge.ethqsets--;\n\t\t\t\tif (adapter->sge.ethqsets <= n)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t \n\tn = 0;\n\tfor_each_port(adapter, i) {\n\t\tpi = adap2pinfo(adapter, i);\n\t\tpi->first_qset = n;\n\t\tn += pi->nqsets;\n\t}\n}\n\n \nstatic int enable_msix(struct adapter *adapter)\n{\n\tint i, want, need, nqsets;\n\tstruct msix_entry entries[MSIX_ENTRIES];\n\tstruct sge *s = &adapter->sge;\n\n\tfor (i = 0; i < MSIX_ENTRIES; ++i)\n\t\tentries[i].entry = i;\n\n\t \n\twant = s->max_ethqsets + MSIX_EXTRAS;\n\tneed = adapter->params.nports + MSIX_EXTRAS;\n\n\twant = pci_enable_msix_range(adapter->pdev, entries, need, want);\n\tif (want < 0)\n\t\treturn want;\n\n\tnqsets = want - MSIX_EXTRAS;\n\tif (nqsets < s->max_ethqsets) {\n\t\tdev_warn(adapter->pdev_dev, \"only enough MSI-X vectors\"\n\t\t\t \" for %d Queue Sets\\n\", nqsets);\n\t\ts->max_ethqsets = nqsets;\n\t\tif (nqsets < s->ethqsets)\n\t\t\treduce_ethqs(adapter, nqsets);\n\t}\n\tfor (i = 0; i < want; ++i)\n\t\tadapter->msix_info[i].vec = entries[i].vector;\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops cxgb4vf_netdev_ops\t= {\n\t.ndo_open\t\t= cxgb4vf_open,\n\t.ndo_stop\t\t= cxgb4vf_stop,\n\t.ndo_start_xmit\t\t= t4vf_eth_xmit,\n\t.ndo_get_stats\t\t= cxgb4vf_get_stats,\n\t.ndo_set_rx_mode\t= cxgb4vf_set_rxmode,\n\t.ndo_set_mac_address\t= cxgb4vf_set_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= cxgb4vf_do_ioctl,\n\t.ndo_change_mtu\t\t= cxgb4vf_change_mtu,\n\t.ndo_fix_features\t= cxgb4vf_fix_features,\n\t.ndo_set_features\t= cxgb4vf_set_features,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= cxgb4vf_poll_controller,\n#endif\n};\n\n \nstatic unsigned int cxgb4vf_get_port_mask(struct adapter *adapter)\n{\n\tunsigned int naddr = 1, pidx = 0;\n\tunsigned int pmask, rmask = 0;\n\tu8 mac[ETH_ALEN];\n\tint err;\n\n\tpmask = adapter->params.vfres.pmask;\n\twhile (pmask) {\n\t\tif (pmask & 1) {\n\t\t\terr = t4vf_get_vf_mac_acl(adapter, pidx, &naddr, mac);\n\t\t\tif (!err && !is_zero_ether_addr(mac))\n\t\t\t\trmask |= (1 << pidx);\n\t\t}\n\t\tpmask >>= 1;\n\t\tpidx++;\n\t}\n\tif (!rmask)\n\t\trmask = adapter->params.vfres.pmask;\n\n\treturn rmask;\n}\n\n \nstatic int cxgb4vf_pci_probe(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *ent)\n{\n\tstruct adapter *adapter;\n\tstruct net_device *netdev;\n\tstruct port_info *pi;\n\tunsigned int pmask;\n\tint err, pidx;\n\n\t \n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err, \"cannot enable PCI device\\n\");\n\n\t \n\terr = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot obtain PCI resources\\n\");\n\t\tgoto err_disable_device;\n\t}\n\n\t \n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"no usable DMA configuration\\n\");\n\t\tgoto err_release_regions;\n\t}\n\n\t \n\tpci_set_master(pdev);\n\n\t \n\tadapter = kzalloc(sizeof(*adapter), GFP_KERNEL);\n\tif (!adapter) {\n\t\terr = -ENOMEM;\n\t\tgoto err_release_regions;\n\t}\n\tpci_set_drvdata(pdev, adapter);\n\tadapter->pdev = pdev;\n\tadapter->pdev_dev = &pdev->dev;\n\n\tadapter->mbox_log = kzalloc(sizeof(*adapter->mbox_log) +\n\t\t\t\t    (sizeof(struct mbox_cmd) *\n\t\t\t\t     T4VF_OS_LOG_MBOX_CMDS),\n\t\t\t\t    GFP_KERNEL);\n\tif (!adapter->mbox_log) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_adapter;\n\t}\n\tadapter->mbox_log->size = T4VF_OS_LOG_MBOX_CMDS;\n\n\t \n\tspin_lock_init(&adapter->stats_lock);\n\tspin_lock_init(&adapter->mbox_lock);\n\tINIT_LIST_HEAD(&adapter->mlist.list);\n\n\t \n\tadapter->regs = pci_ioremap_bar(pdev, 0);\n\tif (!adapter->regs) {\n\t\tdev_err(&pdev->dev, \"cannot map device registers\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_free_adapter;\n\t}\n\n\t \n\terr = t4vf_prep_adapter(adapter);\n\tif (err) {\n\t\tdev_err(adapter->pdev_dev, \"device didn't become ready:\"\n\t\t\t\" err=%d\\n\", err);\n\t\tgoto err_unmap_bar0;\n\t}\n\n\t \n\tif (!is_t4(adapter->params.chip)) {\n\t\tadapter->bar2 = ioremap_wc(pci_resource_start(pdev, 2),\n\t\t\t\t\t   pci_resource_len(pdev, 2));\n\t\tif (!adapter->bar2) {\n\t\t\tdev_err(adapter->pdev_dev, \"cannot map BAR2 doorbells\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_unmap_bar0;\n\t\t}\n\t}\n\t \n\tadapter->name = pci_name(pdev);\n\tadapter->msg_enable = DFLT_MSG_ENABLE;\n\n\t \n\tif (!pcie_relaxed_ordering_enabled(pdev))\n\t\tadapter->flags |= CXGB4VF_ROOT_NO_RELAXED_ORDERING;\n\n\terr = adap_init0(adapter);\n\tif (err)\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Adapter initialization failed, error %d. Continuing in debug mode\\n\",\n\t\t\terr);\n\n\t \n\tINIT_LIST_HEAD(&adapter->mac_hlist);\n\n\t \n\tpmask = cxgb4vf_get_port_mask(adapter);\n\tfor_each_port(adapter, pidx) {\n\t\tint port_id, viid;\n\t\tu8 mac[ETH_ALEN];\n\t\tunsigned int naddr = 1;\n\n\t\t \n\t\tif (pmask == 0)\n\t\t\tbreak;\n\t\tport_id = ffs(pmask) - 1;\n\t\tpmask &= ~(1 << port_id);\n\n\t\t \n\t\tnetdev = alloc_etherdev_mq(sizeof(struct port_info),\n\t\t\t\t\t   MAX_PORT_QSETS);\n\t\tif (netdev == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_dev;\n\t\t}\n\t\tadapter->port[pidx] = netdev;\n\t\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\t\tpi = netdev_priv(netdev);\n\t\tpi->adapter = adapter;\n\t\tpi->pidx = pidx;\n\t\tpi->port_id = port_id;\n\n\t\t \n\t\tpi->xact_addr_filt = -1;\n\t\tnetdev->irq = pdev->irq;\n\n\t\tnetdev->hw_features = NETIF_F_SG | TSO_FLAGS | NETIF_F_GRO |\n\t\t\tNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | NETIF_F_RXCSUM |\n\t\t\tNETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX;\n\t\tnetdev->features = netdev->hw_features | NETIF_F_HIGHDMA;\n\t\tnetdev->vlan_features = netdev->features & VLAN_FEAT;\n\n\t\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\t\tnetdev->min_mtu = 81;\n\t\tnetdev->max_mtu = ETH_MAX_MTU;\n\n\t\tnetdev->netdev_ops = &cxgb4vf_netdev_ops;\n\t\tnetdev->ethtool_ops = &cxgb4vf_ethtool_ops;\n\t\tnetdev->dev_port = pi->port_id;\n\n\t\t \n\t\tif (!(adapter->flags & CXGB4VF_FW_OK))\n\t\t\tcontinue;\n\n\t\tviid = t4vf_alloc_vi(adapter, port_id);\n\t\tif (viid < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"cannot allocate VI for port %d: err=%d\\n\",\n\t\t\t\tport_id, viid);\n\t\t\terr = viid;\n\t\t\tgoto err_free_dev;\n\t\t}\n\t\tpi->viid = viid;\n\n\t\t \n\t\terr = t4vf_port_init(adapter, pidx);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"cannot initialize port %d\\n\",\n\t\t\t\tpidx);\n\t\t\tgoto err_free_dev;\n\t\t}\n\n\t\terr = t4vf_get_vf_mac_acl(adapter, port_id, &naddr, mac);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"unable to determine MAC ACL address, \"\n\t\t\t\t\"continuing anyway.. (status %d)\\n\", err);\n\t\t} else if (naddr && adapter->params.vfres.nvi == 1) {\n\t\t\tstruct sockaddr addr;\n\n\t\t\tether_addr_copy(addr.sa_data, mac);\n\t\t\terr = cxgb4vf_set_mac_addr(netdev, &addr);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"unable to set MAC address %pM\\n\",\n\t\t\t\t\tmac);\n\t\t\t\tgoto err_free_dev;\n\t\t\t}\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Using assigned MAC ACL: %pM\\n\", mac);\n\t\t}\n\t}\n\n\t \n\tif (msi == MSI_MSIX && enable_msix(adapter) == 0)\n\t\tadapter->flags |= CXGB4VF_USING_MSIX;\n\telse {\n\t\tif (msi == MSI_MSIX) {\n\t\t\tdev_info(adapter->pdev_dev,\n\t\t\t\t \"Unable to use MSI-X Interrupts; falling \"\n\t\t\t\t \"back to MSI Interrupts\\n\");\n\n\t\t\t \n\t\t\tmsi = MSI_MSI;\n\t\t\tsize_nports_qsets(adapter);\n\t\t}\n\t\terr = pci_enable_msi(pdev);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Unable to allocate MSI Interrupts;\"\n\t\t\t\t\" err=%d\\n\", err);\n\t\t\tgoto err_free_dev;\n\t\t}\n\t\tadapter->flags |= CXGB4VF_USING_MSI;\n\t}\n\n\t \n\tcfg_queues(adapter);\n\n\t \n\tfor_each_port(adapter, pidx) {\n\t\tstruct port_info *pi = netdev_priv(adapter->port[pidx]);\n\t\tnetdev = adapter->port[pidx];\n\t\tif (netdev == NULL)\n\t\t\tcontinue;\n\n\t\tnetif_set_real_num_tx_queues(netdev, pi->nqsets);\n\t\tnetif_set_real_num_rx_queues(netdev, pi->nqsets);\n\n\t\terr = register_netdev(netdev);\n\t\tif (err) {\n\t\t\tdev_warn(&pdev->dev, \"cannot register net device %s,\"\n\t\t\t\t \" skipping\\n\", netdev->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnetif_carrier_off(netdev);\n\t\tset_bit(pidx, &adapter->registered_device_map);\n\t}\n\tif (adapter->registered_device_map == 0) {\n\t\tdev_err(&pdev->dev, \"could not register any net devices\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_disable_interrupts;\n\t}\n\n\t \n\tif (!IS_ERR_OR_NULL(cxgb4vf_debugfs_root)) {\n\t\tadapter->debugfs_root =\n\t\t\tdebugfs_create_dir(pci_name(pdev),\n\t\t\t\t\t   cxgb4vf_debugfs_root);\n\t\tsetup_debugfs(adapter);\n\t}\n\n\t \n\tfor_each_port(adapter, pidx) {\n\t\tdev_info(adapter->pdev_dev, \"%s: Chelsio VF NIC PCIe %s\\n\",\n\t\t\t adapter->port[pidx]->name,\n\t\t\t (adapter->flags & CXGB4VF_USING_MSIX) ? \"MSI-X\" :\n\t\t\t (adapter->flags & CXGB4VF_USING_MSI)  ? \"MSI\" : \"\");\n\t}\n\n\t \n\treturn 0;\n\n\t \nerr_disable_interrupts:\n\tif (adapter->flags & CXGB4VF_USING_MSIX) {\n\t\tpci_disable_msix(adapter->pdev);\n\t\tadapter->flags &= ~CXGB4VF_USING_MSIX;\n\t} else if (adapter->flags & CXGB4VF_USING_MSI) {\n\t\tpci_disable_msi(adapter->pdev);\n\t\tadapter->flags &= ~CXGB4VF_USING_MSI;\n\t}\n\nerr_free_dev:\n\tfor_each_port(adapter, pidx) {\n\t\tnetdev = adapter->port[pidx];\n\t\tif (netdev == NULL)\n\t\t\tcontinue;\n\t\tpi = netdev_priv(netdev);\n\t\tif (pi->viid)\n\t\t\tt4vf_free_vi(adapter, pi->viid);\n\t\tif (test_bit(pidx, &adapter->registered_device_map))\n\t\t\tunregister_netdev(netdev);\n\t\tfree_netdev(netdev);\n\t}\n\n\tif (!is_t4(adapter->params.chip))\n\t\tiounmap(adapter->bar2);\n\nerr_unmap_bar0:\n\tiounmap(adapter->regs);\n\nerr_free_adapter:\n\tkfree(adapter->mbox_log);\n\tkfree(adapter);\n\nerr_release_regions:\n\tpci_release_regions(pdev);\n\nerr_disable_device:\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\n \nstatic void cxgb4vf_pci_remove(struct pci_dev *pdev)\n{\n\tstruct adapter *adapter = pci_get_drvdata(pdev);\n\tstruct hash_mac_addr *entry, *tmp;\n\n\t \n\tif (adapter) {\n\t\tint pidx;\n\n\t\t \n\t\tfor_each_port(adapter, pidx)\n\t\t\tif (test_bit(pidx, &adapter->registered_device_map))\n\t\t\t\tunregister_netdev(adapter->port[pidx]);\n\t\tt4vf_sge_stop(adapter);\n\t\tif (adapter->flags & CXGB4VF_USING_MSIX) {\n\t\t\tpci_disable_msix(adapter->pdev);\n\t\t\tadapter->flags &= ~CXGB4VF_USING_MSIX;\n\t\t} else if (adapter->flags & CXGB4VF_USING_MSI) {\n\t\t\tpci_disable_msi(adapter->pdev);\n\t\t\tadapter->flags &= ~CXGB4VF_USING_MSI;\n\t\t}\n\n\t\t \n\t\tif (!IS_ERR_OR_NULL(adapter->debugfs_root)) {\n\t\t\tcleanup_debugfs(adapter);\n\t\t\tdebugfs_remove_recursive(adapter->debugfs_root);\n\t\t}\n\n\t\t \n\t\tt4vf_free_sge_resources(adapter);\n\t\tfor_each_port(adapter, pidx) {\n\t\t\tstruct net_device *netdev = adapter->port[pidx];\n\t\t\tstruct port_info *pi;\n\n\t\t\tif (netdev == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tpi = netdev_priv(netdev);\n\t\t\tif (pi->viid)\n\t\t\t\tt4vf_free_vi(adapter, pi->viid);\n\t\t\tfree_netdev(netdev);\n\t\t}\n\t\tiounmap(adapter->regs);\n\t\tif (!is_t4(adapter->params.chip))\n\t\t\tiounmap(adapter->bar2);\n\t\tkfree(adapter->mbox_log);\n\t\tlist_for_each_entry_safe(entry, tmp, &adapter->mac_hlist,\n\t\t\t\t\t list) {\n\t\t\tlist_del(&entry->list);\n\t\t\tkfree(entry);\n\t\t}\n\t\tkfree(adapter);\n\t}\n\n\t \n\tpci_disable_device(pdev);\n\tpci_release_regions(pdev);\n}\n\n \nstatic void cxgb4vf_pci_shutdown(struct pci_dev *pdev)\n{\n\tstruct adapter *adapter;\n\tint pidx;\n\n\tadapter = pci_get_drvdata(pdev);\n\tif (!adapter)\n\t\treturn;\n\n\t \n\tfor_each_port(adapter, pidx)\n\t\tif (test_bit(pidx, &adapter->registered_device_map))\n\t\t\tunregister_netdev(adapter->port[pidx]);\n\n\t \n\tt4vf_sge_stop(adapter);\n\tif (adapter->flags & CXGB4VF_USING_MSIX) {\n\t\tpci_disable_msix(adapter->pdev);\n\t\tadapter->flags &= ~CXGB4VF_USING_MSIX;\n\t} else if (adapter->flags & CXGB4VF_USING_MSI) {\n\t\tpci_disable_msi(adapter->pdev);\n\t\tadapter->flags &= ~CXGB4VF_USING_MSI;\n\t}\n\n\t \n\tt4vf_free_sge_resources(adapter);\n\tpci_set_drvdata(pdev, NULL);\n}\n\n \n#define CH_PCI_DEVICE_ID_TABLE_DEFINE_BEGIN \\\n\tstatic const struct pci_device_id cxgb4vf_pci_tbl[] = {\n#define CH_PCI_DEVICE_ID_FUNCTION\t0x8\n\n#define CH_PCI_ID_TABLE_ENTRY(devid) \\\n\t\t{ PCI_VDEVICE(CHELSIO, (devid)), 0 }\n\n#define CH_PCI_DEVICE_ID_TABLE_DEFINE_END { 0, } }\n\n#include \"../cxgb4/t4_pci_id_tbl.h\"\n\nMODULE_DESCRIPTION(DRV_DESC);\nMODULE_AUTHOR(\"Chelsio Communications\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DEVICE_TABLE(pci, cxgb4vf_pci_tbl);\n\nstatic struct pci_driver cxgb4vf_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= cxgb4vf_pci_tbl,\n\t.probe\t\t= cxgb4vf_pci_probe,\n\t.remove\t\t= cxgb4vf_pci_remove,\n\t.shutdown\t= cxgb4vf_pci_shutdown,\n};\n\n \nstatic int __init cxgb4vf_module_init(void)\n{\n\tint ret;\n\n\t \n\tif (msi != MSI_MSIX && msi != MSI_MSI) {\n\t\tpr_warn(\"bad module parameter msi=%d; must be %d (MSI-X or MSI) or %d (MSI)\\n\",\n\t\t\tmsi, MSI_MSIX, MSI_MSI);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcxgb4vf_debugfs_root = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\n\tret = pci_register_driver(&cxgb4vf_driver);\n\tif (ret < 0)\n\t\tdebugfs_remove(cxgb4vf_debugfs_root);\n\treturn ret;\n}\n\n \nstatic void __exit cxgb4vf_module_exit(void)\n{\n\tpci_unregister_driver(&cxgb4vf_driver);\n\tdebugfs_remove(cxgb4vf_debugfs_root);\n}\n\nmodule_init(cxgb4vf_module_init);\nmodule_exit(cxgb4vf_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}