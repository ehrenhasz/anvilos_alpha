{
  "module_name": "t4vf_hw.c",
  "hash_id": "a952544c865b8d6a310a7f02525417609a1815af36a4178319b20c26b7822f48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/cxgb4vf/t4vf_hw.c",
  "human_readable_source": " \n\n#include <linux/ethtool.h>\n#include <linux/pci.h>\n\n#include \"t4vf_common.h\"\n#include \"t4vf_defs.h\"\n\n#include \"../cxgb4/t4_regs.h\"\n#include \"../cxgb4/t4_values.h\"\n#include \"../cxgb4/t4fw_api.h\"\n\n \nint t4vf_wait_dev_ready(struct adapter *adapter)\n{\n\tconst u32 whoami = T4VF_PL_BASE_ADDR + PL_VF_WHOAMI;\n\tconst u32 notready1 = 0xffffffff;\n\tconst u32 notready2 = 0xeeeeeeee;\n\tu32 val;\n\n\tval = t4_read_reg(adapter, whoami);\n\tif (val != notready1 && val != notready2)\n\t\treturn 0;\n\tmsleep(500);\n\tval = t4_read_reg(adapter, whoami);\n\tif (val != notready1 && val != notready2)\n\t\treturn 0;\n\telse\n\t\treturn -EIO;\n}\n\n \nstatic void get_mbox_rpl(struct adapter *adapter, __be64 *rpl, int size,\n\t\t\t u32 mbox_data)\n{\n\tfor ( ; size; size -= 8, mbox_data += 8)\n\t\t*rpl++ = cpu_to_be64(t4_read_reg64(adapter, mbox_data));\n}\n\n \nstatic void t4vf_record_mbox(struct adapter *adapter, const __be64 *cmd,\n\t\t\t     int size, int access, int execute)\n{\n\tstruct mbox_cmd_log *log = adapter->mbox_log;\n\tstruct mbox_cmd *entry;\n\tint i;\n\n\tentry = mbox_cmd_log_entry(log, log->cursor++);\n\tif (log->cursor == log->size)\n\t\tlog->cursor = 0;\n\n\tfor (i = 0; i < size / 8; i++)\n\t\tentry->cmd[i] = be64_to_cpu(cmd[i]);\n\twhile (i < MBOX_LEN / 8)\n\t\tentry->cmd[i++] = 0;\n\tentry->timestamp = jiffies;\n\tentry->seqno = log->seqno++;\n\tentry->access = access;\n\tentry->execute = execute;\n}\n\n \nint t4vf_wr_mbox_core(struct adapter *adapter, const void *cmd, int size,\n\t\t      void *rpl, bool sleep_ok)\n{\n\tstatic const int delay[] = {\n\t\t1, 1, 3, 5, 10, 10, 20, 50, 100\n\t};\n\n\tu16 access = 0, execute = 0;\n\tu32 v, mbox_data;\n\tint i, ms, delay_idx, ret;\n\tconst __be64 *p;\n\tu32 mbox_ctl = T4VF_CIM_BASE_ADDR + CIM_VF_EXT_MAILBOX_CTRL;\n\tu32 cmd_op = FW_CMD_OP_G(be32_to_cpu(((struct fw_cmd_hdr *)cmd)->hi));\n\t__be64 cmd_rpl[MBOX_LEN / 8];\n\tstruct mbox_list entry;\n\n\t \n\tif (CHELSIO_CHIP_VERSION(adapter->params.chip) <= CHELSIO_T5)\n\t\tmbox_data = T4VF_MBDATA_BASE_ADDR;\n\telse\n\t\tmbox_data = T6VF_MBDATA_BASE_ADDR;\n\n\t \n\tif ((size % 16) != 0 ||\n\t    size > NUM_CIM_VF_MAILBOX_DATA_INSTANCES * 4)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock(&adapter->mbox_lock);\n\tlist_add_tail(&entry.list, &adapter->mlist.list);\n\tspin_unlock(&adapter->mbox_lock);\n\n\tdelay_idx = 0;\n\tms = delay[0];\n\n\tfor (i = 0; ; i += ms) {\n\t\t \n\t\tif (i > FW_CMD_MAX_TIMEOUT) {\n\t\t\tspin_lock(&adapter->mbox_lock);\n\t\t\tlist_del(&entry.list);\n\t\t\tspin_unlock(&adapter->mbox_lock);\n\t\t\tret = -EBUSY;\n\t\t\tt4vf_record_mbox(adapter, cmd, size, access, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (list_first_entry(&adapter->mlist.list, struct mbox_list,\n\t\t\t\t     list) == &entry)\n\t\t\tbreak;\n\n\t\t \n\t\tif (sleep_ok) {\n\t\t\tms = delay[delay_idx];   \n\t\t\tif (delay_idx < ARRAY_SIZE(delay) - 1)\n\t\t\t\tdelay_idx++;\n\t\t\tmsleep(ms);\n\t\t} else {\n\t\t\tmdelay(ms);\n\t\t}\n\t}\n\n\t \n\tv = MBOWNER_G(t4_read_reg(adapter, mbox_ctl));\n\tfor (i = 0; v == MBOX_OWNER_NONE && i < 3; i++)\n\t\tv = MBOWNER_G(t4_read_reg(adapter, mbox_ctl));\n\tif (v != MBOX_OWNER_DRV) {\n\t\tspin_lock(&adapter->mbox_lock);\n\t\tlist_del(&entry.list);\n\t\tspin_unlock(&adapter->mbox_lock);\n\t\tret = (v == MBOX_OWNER_FW) ? -EBUSY : -ETIMEDOUT;\n\t\tt4vf_record_mbox(adapter, cmd, size, access, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (cmd_op != FW_VI_STATS_CMD)\n\t\tt4vf_record_mbox(adapter, cmd, size, access, 0);\n\tfor (i = 0, p = cmd; i < size; i += 8)\n\t\tt4_write_reg64(adapter, mbox_data + i, be64_to_cpu(*p++));\n\tt4_read_reg(adapter, mbox_data);          \n\n\tt4_write_reg(adapter, mbox_ctl,\n\t\t     MBMSGVALID_F | MBOWNER_V(MBOX_OWNER_FW));\n\tt4_read_reg(adapter, mbox_ctl);           \n\n\t \n\tdelay_idx = 0;\n\tms = delay[0];\n\n\tfor (i = 0; i < FW_CMD_MAX_TIMEOUT; i += ms) {\n\t\tif (sleep_ok) {\n\t\t\tms = delay[delay_idx];\n\t\t\tif (delay_idx < ARRAY_SIZE(delay) - 1)\n\t\t\t\tdelay_idx++;\n\t\t\tmsleep(ms);\n\t\t} else\n\t\t\tmdelay(ms);\n\n\t\t \n\t\tv = t4_read_reg(adapter, mbox_ctl);\n\t\tif (MBOWNER_G(v) == MBOX_OWNER_DRV) {\n\t\t\t \n\t\t\tif ((v & MBMSGVALID_F) == 0) {\n\t\t\t\tt4_write_reg(adapter, mbox_ctl,\n\t\t\t\t\t     MBOWNER_V(MBOX_OWNER_NONE));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tget_mbox_rpl(adapter, cmd_rpl, size, mbox_data);\n\n\t\t\t \n\t\t\tv = be64_to_cpu(cmd_rpl[0]);\n\n\t\t\tif (rpl) {\n\t\t\t\t \n\t\t\t\tWARN_ON((be32_to_cpu(*(const __be32 *)cmd)\n\t\t\t\t\t & FW_CMD_REQUEST_F) == 0);\n\t\t\t\tmemcpy(rpl, cmd_rpl, size);\n\t\t\t\tWARN_ON((be32_to_cpu(*(__be32 *)rpl)\n\t\t\t\t\t & FW_CMD_REQUEST_F) != 0);\n\t\t\t}\n\t\t\tt4_write_reg(adapter, mbox_ctl,\n\t\t\t\t     MBOWNER_V(MBOX_OWNER_NONE));\n\t\t\texecute = i + ms;\n\t\t\tif (cmd_op != FW_VI_STATS_CMD)\n\t\t\t\tt4vf_record_mbox(adapter, cmd_rpl, size, access,\n\t\t\t\t\t\t execute);\n\t\t\tspin_lock(&adapter->mbox_lock);\n\t\t\tlist_del(&entry.list);\n\t\t\tspin_unlock(&adapter->mbox_lock);\n\t\t\treturn -FW_CMD_RETVAL_G(v);\n\t\t}\n\t}\n\n\t \n\tret = -ETIMEDOUT;\n\tt4vf_record_mbox(adapter, cmd, size, access, ret);\n\tspin_lock(&adapter->mbox_lock);\n\tlist_del(&entry.list);\n\tspin_unlock(&adapter->mbox_lock);\n\treturn ret;\n}\n\n \n#define ADVERT_MASK (FW_PORT_CAP32_SPEED_V(FW_PORT_CAP32_SPEED_M) | \\\n\t\t     FW_PORT_CAP32_802_3_PAUSE | \\\n\t\t     FW_PORT_CAP32_802_3_ASM_DIR | \\\n\t\t     FW_PORT_CAP32_FEC_V(FW_PORT_CAP32_FEC_M) | \\\n\t\t     FW_PORT_CAP32_ANEG)\n\n \nstatic fw_port_cap32_t fwcaps16_to_caps32(fw_port_cap16_t caps16)\n{\n\tfw_port_cap32_t caps32 = 0;\n\n\t#define CAP16_TO_CAP32(__cap) \\\n\t\tdo { \\\n\t\t\tif (caps16 & FW_PORT_CAP_##__cap) \\\n\t\t\t\tcaps32 |= FW_PORT_CAP32_##__cap; \\\n\t\t} while (0)\n\n\tCAP16_TO_CAP32(SPEED_100M);\n\tCAP16_TO_CAP32(SPEED_1G);\n\tCAP16_TO_CAP32(SPEED_25G);\n\tCAP16_TO_CAP32(SPEED_10G);\n\tCAP16_TO_CAP32(SPEED_40G);\n\tCAP16_TO_CAP32(SPEED_100G);\n\tCAP16_TO_CAP32(FC_RX);\n\tCAP16_TO_CAP32(FC_TX);\n\tCAP16_TO_CAP32(ANEG);\n\tCAP16_TO_CAP32(MDIAUTO);\n\tCAP16_TO_CAP32(MDISTRAIGHT);\n\tCAP16_TO_CAP32(FEC_RS);\n\tCAP16_TO_CAP32(FEC_BASER_RS);\n\tCAP16_TO_CAP32(802_3_PAUSE);\n\tCAP16_TO_CAP32(802_3_ASM_DIR);\n\n\t#undef CAP16_TO_CAP32\n\n\treturn caps32;\n}\n\n \nstatic inline enum cc_pause fwcap_to_cc_pause(fw_port_cap32_t fw_pause)\n{\n\tenum cc_pause cc_pause = 0;\n\n\tif (fw_pause & FW_PORT_CAP32_FC_RX)\n\t\tcc_pause |= PAUSE_RX;\n\tif (fw_pause & FW_PORT_CAP32_FC_TX)\n\t\tcc_pause |= PAUSE_TX;\n\n\treturn cc_pause;\n}\n\n \nstatic inline enum cc_fec fwcap_to_cc_fec(fw_port_cap32_t fw_fec)\n{\n\tenum cc_fec cc_fec = 0;\n\n\tif (fw_fec & FW_PORT_CAP32_FEC_RS)\n\t\tcc_fec |= FEC_RS;\n\tif (fw_fec & FW_PORT_CAP32_FEC_BASER_RS)\n\t\tcc_fec |= FEC_BASER_RS;\n\n\treturn cc_fec;\n}\n\n \nstatic unsigned int fwcap_to_speed(fw_port_cap32_t caps)\n{\n\t#define TEST_SPEED_RETURN(__caps_speed, __speed) \\\n\t\tdo { \\\n\t\t\tif (caps & FW_PORT_CAP32_SPEED_##__caps_speed) \\\n\t\t\t\treturn __speed; \\\n\t\t} while (0)\n\n\tTEST_SPEED_RETURN(400G, 400000);\n\tTEST_SPEED_RETURN(200G, 200000);\n\tTEST_SPEED_RETURN(100G, 100000);\n\tTEST_SPEED_RETURN(50G,   50000);\n\tTEST_SPEED_RETURN(40G,   40000);\n\tTEST_SPEED_RETURN(25G,   25000);\n\tTEST_SPEED_RETURN(10G,   10000);\n\tTEST_SPEED_RETURN(1G,     1000);\n\tTEST_SPEED_RETURN(100M,    100);\n\n\t#undef TEST_SPEED_RETURN\n\n\treturn 0;\n}\n\n \nstatic fw_port_cap32_t fwcap_to_fwspeed(fw_port_cap32_t acaps)\n{\n\t#define TEST_SPEED_RETURN(__caps_speed) \\\n\t\tdo { \\\n\t\t\tif (acaps & FW_PORT_CAP32_SPEED_##__caps_speed) \\\n\t\t\t\treturn FW_PORT_CAP32_SPEED_##__caps_speed; \\\n\t\t} while (0)\n\n\tTEST_SPEED_RETURN(400G);\n\tTEST_SPEED_RETURN(200G);\n\tTEST_SPEED_RETURN(100G);\n\tTEST_SPEED_RETURN(50G);\n\tTEST_SPEED_RETURN(40G);\n\tTEST_SPEED_RETURN(25G);\n\tTEST_SPEED_RETURN(10G);\n\tTEST_SPEED_RETURN(1G);\n\tTEST_SPEED_RETURN(100M);\n\n\t#undef TEST_SPEED_RETURN\n\treturn 0;\n}\n\n \nstatic void init_link_config(struct link_config *lc,\n\t\t\t     fw_port_cap32_t pcaps,\n\t\t\t     fw_port_cap32_t acaps)\n{\n\tlc->pcaps = pcaps;\n\tlc->lpacaps = 0;\n\tlc->speed_caps = 0;\n\tlc->speed = 0;\n\tlc->requested_fc = lc->fc = PAUSE_RX | PAUSE_TX;\n\n\t \n\tlc->auto_fec = fwcap_to_cc_fec(acaps);\n\tlc->requested_fec = FEC_AUTO;\n\tlc->fec = lc->auto_fec;\n\n\t \n\tif (lc->pcaps & FW_PORT_CAP32_ANEG) {\n\t\tlc->acaps = acaps & ADVERT_MASK;\n\t\tlc->autoneg = AUTONEG_ENABLE;\n\t\tlc->requested_fc |= PAUSE_AUTONEG;\n\t} else {\n\t\tlc->acaps = 0;\n\t\tlc->autoneg = AUTONEG_DISABLE;\n\t\tlc->speed_caps = fwcap_to_fwspeed(acaps);\n\t}\n}\n\n \nint t4vf_port_init(struct adapter *adapter, int pidx)\n{\n\tstruct port_info *pi = adap2pinfo(adapter, pidx);\n\tunsigned int fw_caps = adapter->params.fw_caps_support;\n\tstruct fw_vi_cmd vi_cmd, vi_rpl;\n\tstruct fw_port_cmd port_cmd, port_rpl;\n\tenum fw_port_type port_type;\n\tint mdio_addr;\n\tfw_port_cap32_t pcaps, acaps;\n\tint ret;\n\n\t \n\tif (fw_caps == FW_CAPS_UNKNOWN) {\n\t\tu32 param, val;\n\n\t\tparam = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_PFVF) |\n\t\t\t FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_PFVF_PORT_CAPS32));\n\t\tval = 1;\n\t\tret = t4vf_set_params(adapter, 1, &param, &val);\n\t\tfw_caps = (ret == 0 ? FW_CAPS32 : FW_CAPS16);\n\t\tadapter->params.fw_caps_support = fw_caps;\n\t}\n\n\t \n\tmemset(&vi_cmd, 0, sizeof(vi_cmd));\n\tvi_cmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_VI_CMD) |\n\t\t\t\t       FW_CMD_REQUEST_F |\n\t\t\t\t       FW_CMD_READ_F);\n\tvi_cmd.alloc_to_len16 = cpu_to_be32(FW_LEN16(vi_cmd));\n\tvi_cmd.type_viid = cpu_to_be16(FW_VI_CMD_VIID_V(pi->viid));\n\tret = t4vf_wr_mbox(adapter, &vi_cmd, sizeof(vi_cmd), &vi_rpl);\n\tif (ret != FW_SUCCESS)\n\t\treturn ret;\n\n\tBUG_ON(pi->port_id != FW_VI_CMD_PORTID_G(vi_rpl.portid_pkd));\n\tpi->rss_size = FW_VI_CMD_RSSSIZE_G(be16_to_cpu(vi_rpl.rsssize_pkd));\n\tt4_os_set_hw_addr(adapter, pidx, vi_rpl.mac);\n\n\t \n\tif (!(adapter->params.vfres.r_caps & FW_CMD_CAP_PORT))\n\t\treturn 0;\n\n\tmemset(&port_cmd, 0, sizeof(port_cmd));\n\tport_cmd.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PORT_CMD) |\n\t\t\t\t\t    FW_CMD_REQUEST_F |\n\t\t\t\t\t    FW_CMD_READ_F |\n\t\t\t\t\t    FW_PORT_CMD_PORTID_V(pi->port_id));\n\tport_cmd.action_to_len16 = cpu_to_be32(\n\t\tFW_PORT_CMD_ACTION_V(fw_caps == FW_CAPS16\n\t\t\t\t     ? FW_PORT_ACTION_GET_PORT_INFO\n\t\t\t\t     : FW_PORT_ACTION_GET_PORT_INFO32) |\n\t\tFW_LEN16(port_cmd));\n\tret = t4vf_wr_mbox(adapter, &port_cmd, sizeof(port_cmd), &port_rpl);\n\tif (ret != FW_SUCCESS)\n\t\treturn ret;\n\n\t \n\tif (fw_caps == FW_CAPS16) {\n\t\tu32 lstatus = be32_to_cpu(port_rpl.u.info.lstatus_to_modtype);\n\n\t\tport_type = FW_PORT_CMD_PTYPE_G(lstatus);\n\t\tmdio_addr = ((lstatus & FW_PORT_CMD_MDIOCAP_F)\n\t\t\t     ? FW_PORT_CMD_MDIOADDR_G(lstatus)\n\t\t\t     : -1);\n\t\tpcaps = fwcaps16_to_caps32(be16_to_cpu(port_rpl.u.info.pcap));\n\t\tacaps = fwcaps16_to_caps32(be16_to_cpu(port_rpl.u.info.acap));\n\t} else {\n\t\tu32 lstatus32 =\n\t\t\t   be32_to_cpu(port_rpl.u.info32.lstatus32_to_cbllen32);\n\n\t\tport_type = FW_PORT_CMD_PORTTYPE32_G(lstatus32);\n\t\tmdio_addr = ((lstatus32 & FW_PORT_CMD_MDIOCAP32_F)\n\t\t\t     ? FW_PORT_CMD_MDIOADDR32_G(lstatus32)\n\t\t\t     : -1);\n\t\tpcaps = be32_to_cpu(port_rpl.u.info32.pcaps32);\n\t\tacaps = be32_to_cpu(port_rpl.u.info32.acaps32);\n\t}\n\n\tpi->port_type = port_type;\n\tpi->mdio_addr = mdio_addr;\n\tpi->mod_type = FW_PORT_MOD_TYPE_NA;\n\n\tinit_link_config(&pi->link_cfg, pcaps, acaps);\n\treturn 0;\n}\n\n \nint t4vf_fw_reset(struct adapter *adapter)\n{\n\tstruct fw_reset_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_write = cpu_to_be32(FW_CMD_OP_V(FW_RESET_CMD) |\n\t\t\t\t      FW_CMD_WRITE_F);\n\tcmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\n\treturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\n}\n\n \nstatic int t4vf_query_params(struct adapter *adapter, unsigned int nparams,\n\t\t\t     const u32 *params, u32 *vals)\n{\n\tint i, ret;\n\tstruct fw_params_cmd cmd, rpl;\n\tstruct fw_params_param *p;\n\tsize_t len16;\n\n\tif (nparams > 7)\n\t\treturn -EINVAL;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PARAMS_CMD) |\n\t\t\t\t    FW_CMD_REQUEST_F |\n\t\t\t\t    FW_CMD_READ_F);\n\tlen16 = DIV_ROUND_UP(offsetof(struct fw_params_cmd,\n\t\t\t\t      param[nparams].mnem), 16);\n\tcmd.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(len16));\n\tfor (i = 0, p = &cmd.param[0]; i < nparams; i++, p++)\n\t\tp->mnem = htonl(*params++);\n\n\tret = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\n\tif (ret == 0)\n\t\tfor (i = 0, p = &rpl.param[0]; i < nparams; i++, p++)\n\t\t\t*vals++ = be32_to_cpu(p->val);\n\treturn ret;\n}\n\n \nint t4vf_set_params(struct adapter *adapter, unsigned int nparams,\n\t\t    const u32 *params, const u32 *vals)\n{\n\tint i;\n\tstruct fw_params_cmd cmd;\n\tstruct fw_params_param *p;\n\tsize_t len16;\n\n\tif (nparams > 7)\n\t\treturn -EINVAL;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PARAMS_CMD) |\n\t\t\t\t    FW_CMD_REQUEST_F |\n\t\t\t\t    FW_CMD_WRITE_F);\n\tlen16 = DIV_ROUND_UP(offsetof(struct fw_params_cmd,\n\t\t\t\t      param[nparams]), 16);\n\tcmd.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(len16));\n\tfor (i = 0, p = &cmd.param[0]; i < nparams; i++, p++) {\n\t\tp->mnem = cpu_to_be32(*params++);\n\t\tp->val = cpu_to_be32(*vals++);\n\t}\n\n\treturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\n}\n\n \nint t4vf_fl_pkt_align(struct adapter *adapter)\n{\n\tu32 sge_control, sge_control2;\n\tunsigned int ingpadboundary, ingpackboundary, fl_align, ingpad_shift;\n\n\tsge_control = adapter->params.sge.sge_control;\n\n\t \n\tif (CHELSIO_CHIP_VERSION(adapter->params.chip) <= CHELSIO_T5)\n\t\tingpad_shift = INGPADBOUNDARY_SHIFT_X;\n\telse\n\t\tingpad_shift = T6_INGPADBOUNDARY_SHIFT_X;\n\n\tingpadboundary = 1 << (INGPADBOUNDARY_G(sge_control) + ingpad_shift);\n\n\tfl_align = ingpadboundary;\n\tif (!is_t4(adapter->params.chip)) {\n\t\t \n\t\tsge_control2 = adapter->params.sge.sge_control2;\n\t\tingpackboundary = INGPACKBOUNDARY_G(sge_control2);\n\t\tif (ingpackboundary == INGPACKBOUNDARY_16B_X)\n\t\t\tingpackboundary = 16;\n\t\telse\n\t\t\tingpackboundary = 1 << (ingpackboundary +\n\t\t\t\t\t\tINGPACKBOUNDARY_SHIFT_X);\n\n\t\tfl_align = max(ingpadboundary, ingpackboundary);\n\t}\n\treturn fl_align;\n}\n\n \nint t4vf_bar2_sge_qregs(struct adapter *adapter,\n\t\t\tunsigned int qid,\n\t\t\tenum t4_bar2_qtype qtype,\n\t\t\tu64 *pbar2_qoffset,\n\t\t\tunsigned int *pbar2_qid)\n{\n\tunsigned int page_shift, page_size, qpp_shift, qpp_mask;\n\tu64 bar2_page_offset, bar2_qoffset;\n\tunsigned int bar2_qid, bar2_qid_offset, bar2_qinferred;\n\n\t \n\tif (is_t4(adapter->params.chip))\n\t\treturn -EINVAL;\n\n\t \n\tpage_shift = adapter->params.sge.sge_vf_hps + 10;\n\tpage_size = 1 << page_shift;\n\n\t \n\tqpp_shift = (qtype == T4_BAR2_QTYPE_EGRESS\n\t\t     ? adapter->params.sge.sge_vf_eq_qpp\n\t\t     : adapter->params.sge.sge_vf_iq_qpp);\n\tqpp_mask = (1 << qpp_shift) - 1;\n\n\t \n\tbar2_page_offset = ((u64)(qid >> qpp_shift) << page_shift);\n\tbar2_qid = qid & qpp_mask;\n\tbar2_qid_offset = bar2_qid * SGE_UDB_SIZE;\n\n\t \n\tbar2_qoffset = bar2_page_offset;\n\tbar2_qinferred = (bar2_qid_offset < page_size);\n\tif (bar2_qinferred) {\n\t\tbar2_qoffset += bar2_qid_offset;\n\t\tbar2_qid = 0;\n\t}\n\n\t*pbar2_qoffset = bar2_qoffset;\n\t*pbar2_qid = bar2_qid;\n\treturn 0;\n}\n\nunsigned int t4vf_get_pf_from_vf(struct adapter *adapter)\n{\n\tu32 whoami;\n\n\twhoami = t4_read_reg(adapter, T4VF_PL_BASE_ADDR + PL_VF_WHOAMI_A);\n\treturn (CHELSIO_CHIP_VERSION(adapter->params.chip) <= CHELSIO_T5 ?\n\t\t\tSOURCEPF_G(whoami) : T6_SOURCEPF_G(whoami));\n}\n\n \nint t4vf_get_sge_params(struct adapter *adapter)\n{\n\tstruct sge_params *sge_params = &adapter->params.sge;\n\tu32 params[7], vals[7];\n\tint v;\n\n\tparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\n\t\t     FW_PARAMS_PARAM_XYZ_V(SGE_CONTROL_A));\n\tparams[1] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\n\t\t     FW_PARAMS_PARAM_XYZ_V(SGE_HOST_PAGE_SIZE_A));\n\tparams[2] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\n\t\t     FW_PARAMS_PARAM_XYZ_V(SGE_FL_BUFFER_SIZE0_A));\n\tparams[3] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\n\t\t     FW_PARAMS_PARAM_XYZ_V(SGE_FL_BUFFER_SIZE1_A));\n\tparams[4] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\n\t\t     FW_PARAMS_PARAM_XYZ_V(SGE_TIMER_VALUE_0_AND_1_A));\n\tparams[5] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\n\t\t     FW_PARAMS_PARAM_XYZ_V(SGE_TIMER_VALUE_2_AND_3_A));\n\tparams[6] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\n\t\t     FW_PARAMS_PARAM_XYZ_V(SGE_TIMER_VALUE_4_AND_5_A));\n\tv = t4vf_query_params(adapter, 7, params, vals);\n\tif (v)\n\t\treturn v;\n\tsge_params->sge_control = vals[0];\n\tsge_params->sge_host_page_size = vals[1];\n\tsge_params->sge_fl_buffer_size[0] = vals[2];\n\tsge_params->sge_fl_buffer_size[1] = vals[3];\n\tsge_params->sge_timer_value_0_and_1 = vals[4];\n\tsge_params->sge_timer_value_2_and_3 = vals[5];\n\tsge_params->sge_timer_value_4_and_5 = vals[6];\n\n\t \n\tif (!is_t4(adapter->params.chip)) {\n\t\tparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\n\t\t\t     FW_PARAMS_PARAM_XYZ_V(SGE_CONTROL2_A));\n\t\tv = t4vf_query_params(adapter, 1, params, vals);\n\t\tif (v != FW_SUCCESS) {\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"Unable to get SGE Control2; \"\n\t\t\t\t\"probably old firmware.\\n\");\n\t\t\treturn v;\n\t\t}\n\t\tsge_params->sge_control2 = vals[0];\n\t}\n\n\tparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\n\t\t     FW_PARAMS_PARAM_XYZ_V(SGE_INGRESS_RX_THRESHOLD_A));\n\tparams[1] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\n\t\t     FW_PARAMS_PARAM_XYZ_V(SGE_CONM_CTRL_A));\n\tv = t4vf_query_params(adapter, 2, params, vals);\n\tif (v)\n\t\treturn v;\n\tsge_params->sge_ingress_rx_threshold = vals[0];\n\tsge_params->sge_congestion_control = vals[1];\n\n\t \n\tif (!is_t4(adapter->params.chip)) {\n\t\tunsigned int pf, s_hps, s_qpp;\n\n\t\tparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\n\t\t\t     FW_PARAMS_PARAM_XYZ_V(\n\t\t\t\t     SGE_EGRESS_QUEUES_PER_PAGE_VF_A));\n\t\tparams[1] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_REG) |\n\t\t\t     FW_PARAMS_PARAM_XYZ_V(\n\t\t\t\t     SGE_INGRESS_QUEUES_PER_PAGE_VF_A));\n\t\tv = t4vf_query_params(adapter, 2, params, vals);\n\t\tif (v != FW_SUCCESS) {\n\t\t\tdev_warn(adapter->pdev_dev,\n\t\t\t\t \"Unable to get VF SGE Queues/Page; \"\n\t\t\t\t \"probably old firmware.\\n\");\n\t\t\treturn v;\n\t\t}\n\t\tsge_params->sge_egress_queues_per_page = vals[0];\n\t\tsge_params->sge_ingress_queues_per_page = vals[1];\n\n\t\t \n\t\tpf = t4vf_get_pf_from_vf(adapter);\n\t\ts_hps = (HOSTPAGESIZEPF0_S +\n\t\t\t (HOSTPAGESIZEPF1_S - HOSTPAGESIZEPF0_S) * pf);\n\t\tsge_params->sge_vf_hps =\n\t\t\t((sge_params->sge_host_page_size >> s_hps)\n\t\t\t & HOSTPAGESIZEPF0_M);\n\n\t\ts_qpp = (QUEUESPERPAGEPF0_S +\n\t\t\t (QUEUESPERPAGEPF1_S - QUEUESPERPAGEPF0_S) * pf);\n\t\tsge_params->sge_vf_eq_qpp =\n\t\t\t((sge_params->sge_egress_queues_per_page >> s_qpp)\n\t\t\t & QUEUESPERPAGEPF0_M);\n\t\tsge_params->sge_vf_iq_qpp =\n\t\t\t((sge_params->sge_ingress_queues_per_page >> s_qpp)\n\t\t\t & QUEUESPERPAGEPF0_M);\n\t}\n\n\treturn 0;\n}\n\n \nint t4vf_get_vpd_params(struct adapter *adapter)\n{\n\tstruct vpd_params *vpd_params = &adapter->params.vpd;\n\tu32 params[7], vals[7];\n\tint v;\n\n\tparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t     FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_CCLK));\n\tv = t4vf_query_params(adapter, 1, params, vals);\n\tif (v)\n\t\treturn v;\n\tvpd_params->cclk = vals[0];\n\n\treturn 0;\n}\n\n \nint t4vf_get_dev_params(struct adapter *adapter)\n{\n\tstruct dev_params *dev_params = &adapter->params.dev;\n\tu32 params[7], vals[7];\n\tint v;\n\n\tparams[0] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t     FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_FWREV));\n\tparams[1] = (FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |\n\t\t     FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_TPREV));\n\tv = t4vf_query_params(adapter, 2, params, vals);\n\tif (v)\n\t\treturn v;\n\tdev_params->fwrev = vals[0];\n\tdev_params->tprev = vals[1];\n\n\treturn 0;\n}\n\n \nint t4vf_get_rss_glb_config(struct adapter *adapter)\n{\n\tstruct rss_params *rss = &adapter->params.rss;\n\tstruct fw_rss_glb_config_cmd cmd, rpl;\n\tint v;\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_write = cpu_to_be32(FW_CMD_OP_V(FW_RSS_GLB_CONFIG_CMD) |\n\t\t\t\t      FW_CMD_REQUEST_F |\n\t\t\t\t      FW_CMD_READ_F);\n\tcmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\n\tv = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\n\tif (v)\n\t\treturn v;\n\n\t \n\trss->mode = FW_RSS_GLB_CONFIG_CMD_MODE_G(\n\t\t\tbe32_to_cpu(rpl.u.manual.mode_pkd));\n\tswitch (rss->mode) {\n\tcase FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL: {\n\t\tu32 word = be32_to_cpu(\n\t\t\t\trpl.u.basicvirtual.synmapen_to_hashtoeplitz);\n\n\t\trss->u.basicvirtual.synmapen =\n\t\t\t((word & FW_RSS_GLB_CONFIG_CMD_SYNMAPEN_F) != 0);\n\t\trss->u.basicvirtual.syn4tupenipv6 =\n\t\t\t((word & FW_RSS_GLB_CONFIG_CMD_SYN4TUPENIPV6_F) != 0);\n\t\trss->u.basicvirtual.syn2tupenipv6 =\n\t\t\t((word & FW_RSS_GLB_CONFIG_CMD_SYN2TUPENIPV6_F) != 0);\n\t\trss->u.basicvirtual.syn4tupenipv4 =\n\t\t\t((word & FW_RSS_GLB_CONFIG_CMD_SYN4TUPENIPV4_F) != 0);\n\t\trss->u.basicvirtual.syn2tupenipv4 =\n\t\t\t((word & FW_RSS_GLB_CONFIG_CMD_SYN2TUPENIPV4_F) != 0);\n\n\t\trss->u.basicvirtual.ofdmapen =\n\t\t\t((word & FW_RSS_GLB_CONFIG_CMD_OFDMAPEN_F) != 0);\n\n\t\trss->u.basicvirtual.tnlmapen =\n\t\t\t((word & FW_RSS_GLB_CONFIG_CMD_TNLMAPEN_F) != 0);\n\t\trss->u.basicvirtual.tnlalllookup =\n\t\t\t((word  & FW_RSS_GLB_CONFIG_CMD_TNLALLLKP_F) != 0);\n\n\t\trss->u.basicvirtual.hashtoeplitz =\n\t\t\t((word & FW_RSS_GLB_CONFIG_CMD_HASHTOEPLITZ_F) != 0);\n\n\t\t \n\t\tif (!rss->u.basicvirtual.tnlmapen)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint t4vf_get_vfres(struct adapter *adapter)\n{\n\tstruct vf_resources *vfres = &adapter->params.vfres;\n\tstruct fw_pfvf_cmd cmd, rpl;\n\tint v;\n\tu32 word;\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PFVF_CMD) |\n\t\t\t\t    FW_CMD_REQUEST_F |\n\t\t\t\t    FW_CMD_READ_F);\n\tcmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\n\tv = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\n\tif (v)\n\t\treturn v;\n\n\t \n\tword = be32_to_cpu(rpl.niqflint_niq);\n\tvfres->niqflint = FW_PFVF_CMD_NIQFLINT_G(word);\n\tvfres->niq = FW_PFVF_CMD_NIQ_G(word);\n\n\tword = be32_to_cpu(rpl.type_to_neq);\n\tvfres->neq = FW_PFVF_CMD_NEQ_G(word);\n\tvfres->pmask = FW_PFVF_CMD_PMASK_G(word);\n\n\tword = be32_to_cpu(rpl.tc_to_nexactf);\n\tvfres->tc = FW_PFVF_CMD_TC_G(word);\n\tvfres->nvi = FW_PFVF_CMD_NVI_G(word);\n\tvfres->nexactf = FW_PFVF_CMD_NEXACTF_G(word);\n\n\tword = be32_to_cpu(rpl.r_caps_to_nethctrl);\n\tvfres->r_caps = FW_PFVF_CMD_R_CAPS_G(word);\n\tvfres->wx_caps = FW_PFVF_CMD_WX_CAPS_G(word);\n\tvfres->nethctrl = FW_PFVF_CMD_NETHCTRL_G(word);\n\n\treturn 0;\n}\n\n \nint t4vf_read_rss_vi_config(struct adapter *adapter, unsigned int viid,\n\t\t\t    union rss_vi_config *config)\n{\n\tstruct fw_rss_vi_config_cmd cmd, rpl;\n\tint v;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_RSS_VI_CONFIG_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_READ_F |\n\t\t\t\t     FW_RSS_VI_CONFIG_CMD_VIID(viid));\n\tcmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\n\tv = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\n\tif (v)\n\t\treturn v;\n\n\tswitch (adapter->params.rss.mode) {\n\tcase FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL: {\n\t\tu32 word = be32_to_cpu(rpl.u.basicvirtual.defaultq_to_udpen);\n\n\t\tconfig->basicvirtual.ip6fourtupen =\n\t\t\t((word & FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN_F) != 0);\n\t\tconfig->basicvirtual.ip6twotupen =\n\t\t\t((word & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F) != 0);\n\t\tconfig->basicvirtual.ip4fourtupen =\n\t\t\t((word & FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN_F) != 0);\n\t\tconfig->basicvirtual.ip4twotupen =\n\t\t\t((word & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F) != 0);\n\t\tconfig->basicvirtual.udpen =\n\t\t\t((word & FW_RSS_VI_CONFIG_CMD_UDPEN_F) != 0);\n\t\tconfig->basicvirtual.defaultq =\n\t\t\tFW_RSS_VI_CONFIG_CMD_DEFAULTQ_G(word);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint t4vf_write_rss_vi_config(struct adapter *adapter, unsigned int viid,\n\t\t\t     union rss_vi_config *config)\n{\n\tstruct fw_rss_vi_config_cmd cmd, rpl;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_RSS_VI_CONFIG_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t     FW_RSS_VI_CONFIG_CMD_VIID(viid));\n\tcmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\n\tswitch (adapter->params.rss.mode) {\n\tcase FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL: {\n\t\tu32 word = 0;\n\n\t\tif (config->basicvirtual.ip6fourtupen)\n\t\t\tword |= FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN_F;\n\t\tif (config->basicvirtual.ip6twotupen)\n\t\t\tword |= FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F;\n\t\tif (config->basicvirtual.ip4fourtupen)\n\t\t\tword |= FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN_F;\n\t\tif (config->basicvirtual.ip4twotupen)\n\t\t\tword |= FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F;\n\t\tif (config->basicvirtual.udpen)\n\t\t\tword |= FW_RSS_VI_CONFIG_CMD_UDPEN_F;\n\t\tword |= FW_RSS_VI_CONFIG_CMD_DEFAULTQ_V(\n\t\t\t\tconfig->basicvirtual.defaultq);\n\t\tcmd.u.basicvirtual.defaultq_to_udpen = cpu_to_be32(word);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\n}\n\n \nint t4vf_config_rss_range(struct adapter *adapter, unsigned int viid,\n\t\t\t  int start, int n, const u16 *rspq, int nrspq)\n{\n\tconst u16 *rsp = rspq;\n\tconst u16 *rsp_end = rspq+nrspq;\n\tstruct fw_rss_ind_tbl_cmd cmd;\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_RSS_IND_TBL_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t     FW_RSS_IND_TBL_CMD_VIID_V(viid));\n\tcmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\n\n\t \n\twhile (n > 0) {\n\t\t__be32 *qp = &cmd.iq0_to_iq2;\n\t\tint nq = min(n, 32);\n\t\tint ret;\n\n\t\t \n\t\tcmd.niqid = cpu_to_be16(nq);\n\t\tcmd.startidx = cpu_to_be16(start);\n\n\t\t \n\t\tstart += nq;\n\t\tn -= nq;\n\n\t\t \n\t\twhile (nq > 0) {\n\t\t\t \n\t\t\tu16 qbuf[3];\n\t\t\tu16 *qbp = qbuf;\n\t\t\tint nqbuf = min(3, nq);\n\n\t\t\tnq -= nqbuf;\n\t\t\tqbuf[0] = qbuf[1] = qbuf[2] = 0;\n\t\t\twhile (nqbuf) {\n\t\t\t\tnqbuf--;\n\t\t\t\t*qbp++ = *rsp++;\n\t\t\t\tif (rsp >= rsp_end)\n\t\t\t\t\trsp = rspq;\n\t\t\t}\n\t\t\t*qp++ = cpu_to_be32(FW_RSS_IND_TBL_CMD_IQ0_V(qbuf[0]) |\n\t\t\t\t\t    FW_RSS_IND_TBL_CMD_IQ1_V(qbuf[1]) |\n\t\t\t\t\t    FW_RSS_IND_TBL_CMD_IQ2_V(qbuf[2]));\n\t\t}\n\n\t\t \n\t\tret = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nint t4vf_alloc_vi(struct adapter *adapter, int port_id)\n{\n\tstruct fw_vi_cmd cmd, rpl;\n\tint v;\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_VI_CMD) |\n\t\t\t\t    FW_CMD_REQUEST_F |\n\t\t\t\t    FW_CMD_WRITE_F |\n\t\t\t\t    FW_CMD_EXEC_F);\n\tcmd.alloc_to_len16 = cpu_to_be32(FW_LEN16(cmd) |\n\t\t\t\t\t FW_VI_CMD_ALLOC_F);\n\tcmd.portid_pkd = FW_VI_CMD_PORTID_V(port_id);\n\tv = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\n\tif (v)\n\t\treturn v;\n\n\treturn FW_VI_CMD_VIID_G(be16_to_cpu(rpl.type_viid));\n}\n\n \nint t4vf_free_vi(struct adapter *adapter, int viid)\n{\n\tstruct fw_vi_cmd cmd;\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_VI_CMD) |\n\t\t\t\t    FW_CMD_REQUEST_F |\n\t\t\t\t    FW_CMD_EXEC_F);\n\tcmd.alloc_to_len16 = cpu_to_be32(FW_LEN16(cmd) |\n\t\t\t\t\t FW_VI_CMD_FREE_F);\n\tcmd.type_viid = cpu_to_be16(FW_VI_CMD_VIID_V(viid));\n\treturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\n}\n\n \nint t4vf_enable_vi(struct adapter *adapter, unsigned int viid,\n\t\t   bool rx_en, bool tx_en)\n{\n\tstruct fw_vi_enable_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_ENABLE_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_EXEC_F |\n\t\t\t\t     FW_VI_ENABLE_CMD_VIID_V(viid));\n\tcmd.ien_to_len16 = cpu_to_be32(FW_VI_ENABLE_CMD_IEN_V(rx_en) |\n\t\t\t\t       FW_VI_ENABLE_CMD_EEN_V(tx_en) |\n\t\t\t\t       FW_LEN16(cmd));\n\treturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\n}\n\n \nint t4vf_enable_pi(struct adapter *adapter, struct port_info *pi,\n\t\t   bool rx_en, bool tx_en)\n{\n\tint ret = t4vf_enable_vi(adapter, pi->viid, rx_en, tx_en);\n\n\tif (ret)\n\t\treturn ret;\n\tt4vf_os_link_changed(adapter, pi->pidx,\n\t\t\t     rx_en && tx_en && pi->link_cfg.link_ok);\n\treturn 0;\n}\n\n \nint t4vf_identify_port(struct adapter *adapter, unsigned int viid,\n\t\t       unsigned int nblinks)\n{\n\tstruct fw_vi_enable_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_ENABLE_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_EXEC_F |\n\t\t\t\t     FW_VI_ENABLE_CMD_VIID_V(viid));\n\tcmd.ien_to_len16 = cpu_to_be32(FW_VI_ENABLE_CMD_LED_F |\n\t\t\t\t       FW_LEN16(cmd));\n\tcmd.blinkdur = cpu_to_be16(nblinks);\n\treturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\n}\n\n \nint t4vf_set_rxmode(struct adapter *adapter, unsigned int viid,\n\t\t    int mtu, int promisc, int all_multi, int bcast, int vlanex,\n\t\t    bool sleep_ok)\n{\n\tstruct fw_vi_rxmode_cmd cmd;\n\n\t \n\tif (mtu < 0)\n\t\tmtu = FW_VI_RXMODE_CMD_MTU_M;\n\tif (promisc < 0)\n\t\tpromisc = FW_VI_RXMODE_CMD_PROMISCEN_M;\n\tif (all_multi < 0)\n\t\tall_multi = FW_VI_RXMODE_CMD_ALLMULTIEN_M;\n\tif (bcast < 0)\n\t\tbcast = FW_VI_RXMODE_CMD_BROADCASTEN_M;\n\tif (vlanex < 0)\n\t\tvlanex = FW_VI_RXMODE_CMD_VLANEXEN_M;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_RXMODE_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t     FW_VI_RXMODE_CMD_VIID_V(viid));\n\tcmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\n\tcmd.mtu_to_vlanexen =\n\t\tcpu_to_be32(FW_VI_RXMODE_CMD_MTU_V(mtu) |\n\t\t\t    FW_VI_RXMODE_CMD_PROMISCEN_V(promisc) |\n\t\t\t    FW_VI_RXMODE_CMD_ALLMULTIEN_V(all_multi) |\n\t\t\t    FW_VI_RXMODE_CMD_BROADCASTEN_V(bcast) |\n\t\t\t    FW_VI_RXMODE_CMD_VLANEXEN_V(vlanex));\n\treturn t4vf_wr_mbox_core(adapter, &cmd, sizeof(cmd), NULL, sleep_ok);\n}\n\n \nint t4vf_alloc_mac_filt(struct adapter *adapter, unsigned int viid, bool free,\n\t\t\tunsigned int naddr, const u8 **addr, u16 *idx,\n\t\t\tu64 *hash, bool sleep_ok)\n{\n\tint offset, ret = 0;\n\tunsigned nfilters = 0;\n\tunsigned int rem = naddr;\n\tstruct fw_vi_mac_cmd cmd, rpl;\n\tunsigned int max_naddr = adapter->params.arch.mps_tcam_size;\n\n\tif (naddr > max_naddr)\n\t\treturn -EINVAL;\n\n\tfor (offset = 0; offset < naddr;  ) {\n\t\tunsigned int fw_naddr = (rem < ARRAY_SIZE(cmd.u.exact)\n\t\t\t\t\t ? rem\n\t\t\t\t\t : ARRAY_SIZE(cmd.u.exact));\n\t\tsize_t len16 = DIV_ROUND_UP(offsetof(struct fw_vi_mac_cmd,\n\t\t\t\t\t\t     u.exact[fw_naddr]), 16);\n\t\tstruct fw_vi_mac_exact *p;\n\t\tint i;\n\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\n\t\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t\t     (free ? FW_CMD_EXEC_F : 0) |\n\t\t\t\t\t     FW_VI_MAC_CMD_VIID_V(viid));\n\t\tcmd.freemacs_to_len16 =\n\t\t\tcpu_to_be32(FW_VI_MAC_CMD_FREEMACS_V(free) |\n\t\t\t\t    FW_CMD_LEN16_V(len16));\n\n\t\tfor (i = 0, p = cmd.u.exact; i < fw_naddr; i++, p++) {\n\t\t\tp->valid_to_idx = cpu_to_be16(\n\t\t\t\tFW_VI_MAC_CMD_VALID_F |\n\t\t\t\tFW_VI_MAC_CMD_IDX_V(FW_VI_MAC_ADD_MAC));\n\t\t\tmemcpy(p->macaddr, addr[offset+i], sizeof(p->macaddr));\n\t\t}\n\n\n\t\tret = t4vf_wr_mbox_core(adapter, &cmd, sizeof(cmd), &rpl,\n\t\t\t\t\tsleep_ok);\n\t\tif (ret && ret != -ENOMEM)\n\t\t\tbreak;\n\n\t\tfor (i = 0, p = rpl.u.exact; i < fw_naddr; i++, p++) {\n\t\t\tu16 index = FW_VI_MAC_CMD_IDX_G(\n\t\t\t\tbe16_to_cpu(p->valid_to_idx));\n\n\t\t\tif (idx)\n\t\t\t\tidx[offset+i] =\n\t\t\t\t\t(index >= max_naddr\n\t\t\t\t\t ? 0xffff\n\t\t\t\t\t : index);\n\t\t\tif (index < max_naddr)\n\t\t\t\tnfilters++;\n\t\t\telse if (hash)\n\t\t\t\t*hash |= (1ULL << hash_mac_addr(addr[offset+i]));\n\t\t}\n\n\t\tfree = false;\n\t\toffset += fw_naddr;\n\t\trem -= fw_naddr;\n\t}\n\n\t \n\tif (ret == 0 || ret == -ENOMEM)\n\t\tret = nfilters;\n\treturn ret;\n}\n\n \nint t4vf_free_mac_filt(struct adapter *adapter, unsigned int viid,\n\t\t       unsigned int naddr, const u8 **addr, bool sleep_ok)\n{\n\tint offset, ret = 0;\n\tstruct fw_vi_mac_cmd cmd;\n\tunsigned int nfilters = 0;\n\tunsigned int max_naddr = adapter->params.arch.mps_tcam_size;\n\tunsigned int rem = naddr;\n\n\tif (naddr > max_naddr)\n\t\treturn -EINVAL;\n\n\tfor (offset = 0; offset < (int)naddr ;  ) {\n\t\tunsigned int fw_naddr = (rem < ARRAY_SIZE(cmd.u.exact) ?\n\t\t\t\t\t rem : ARRAY_SIZE(cmd.u.exact));\n\t\tsize_t len16 = DIV_ROUND_UP(offsetof(struct fw_vi_mac_cmd,\n\t\t\t\t\t\t     u.exact[fw_naddr]), 16);\n\t\tstruct fw_vi_mac_exact *p;\n\t\tint i;\n\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t     FW_CMD_EXEC_V(0) |\n\t\t\t\t     FW_VI_MAC_CMD_VIID_V(viid));\n\t\tcmd.freemacs_to_len16 =\n\t\t\t\tcpu_to_be32(FW_VI_MAC_CMD_FREEMACS_V(0) |\n\t\t\t\t\t    FW_CMD_LEN16_V(len16));\n\n\t\tfor (i = 0, p = cmd.u.exact; i < (int)fw_naddr; i++, p++) {\n\t\t\tp->valid_to_idx = cpu_to_be16(\n\t\t\t\tFW_VI_MAC_CMD_VALID_F |\n\t\t\t\tFW_VI_MAC_CMD_IDX_V(FW_VI_MAC_MAC_BASED_FREE));\n\t\t\tmemcpy(p->macaddr, addr[offset+i], sizeof(p->macaddr));\n\t\t}\n\n\t\tret = t4vf_wr_mbox_core(adapter, &cmd, sizeof(cmd), &cmd,\n\t\t\t\t\tsleep_ok);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tfor (i = 0, p = cmd.u.exact; i < fw_naddr; i++, p++) {\n\t\t\tu16 index = FW_VI_MAC_CMD_IDX_G(\n\t\t\t\t\t\tbe16_to_cpu(p->valid_to_idx));\n\n\t\t\tif (index < max_naddr)\n\t\t\t\tnfilters++;\n\t\t}\n\n\t\toffset += fw_naddr;\n\t\trem -= fw_naddr;\n\t}\n\n\tif (ret == 0)\n\t\tret = nfilters;\n\treturn ret;\n}\n\n \nint t4vf_change_mac(struct adapter *adapter, unsigned int viid,\n\t\t    int idx, const u8 *addr, bool persist)\n{\n\tint ret;\n\tstruct fw_vi_mac_cmd cmd, rpl;\n\tstruct fw_vi_mac_exact *p = &cmd.u.exact[0];\n\tsize_t len16 = DIV_ROUND_UP(offsetof(struct fw_vi_mac_cmd,\n\t\t\t\t\t     u.exact[1]), 16);\n\tunsigned int max_mac_addr = adapter->params.arch.mps_tcam_size;\n\n\t \n\tif (idx < 0)\n\t\tidx = persist ? FW_VI_MAC_ADD_PERSIST_MAC : FW_VI_MAC_ADD_MAC;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t     FW_VI_MAC_CMD_VIID_V(viid));\n\tcmd.freemacs_to_len16 = cpu_to_be32(FW_CMD_LEN16_V(len16));\n\tp->valid_to_idx = cpu_to_be16(FW_VI_MAC_CMD_VALID_F |\n\t\t\t\t      FW_VI_MAC_CMD_IDX_V(idx));\n\tmemcpy(p->macaddr, addr, sizeof(p->macaddr));\n\n\tret = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\n\tif (ret == 0) {\n\t\tp = &rpl.u.exact[0];\n\t\tret = FW_VI_MAC_CMD_IDX_G(be16_to_cpu(p->valid_to_idx));\n\t\tif (ret >= max_mac_addr)\n\t\t\tret = -ENOMEM;\n\t}\n\treturn ret;\n}\n\n \nint t4vf_set_addr_hash(struct adapter *adapter, unsigned int viid,\n\t\t       bool ucast, u64 vec, bool sleep_ok)\n{\n\tstruct fw_vi_mac_cmd cmd;\n\tsize_t len16 = DIV_ROUND_UP(offsetof(struct fw_vi_mac_cmd,\n\t\t\t\t\t     u.exact[0]), 16);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_MAC_CMD) |\n\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t     FW_CMD_WRITE_F |\n\t\t\t\t     FW_VI_ENABLE_CMD_VIID_V(viid));\n\tcmd.freemacs_to_len16 = cpu_to_be32(FW_VI_MAC_CMD_HASHVECEN_F |\n\t\t\t\t\t    FW_VI_MAC_CMD_HASHUNIEN_V(ucast) |\n\t\t\t\t\t    FW_CMD_LEN16_V(len16));\n\tcmd.u.hash.hashvec = cpu_to_be64(vec);\n\treturn t4vf_wr_mbox_core(adapter, &cmd, sizeof(cmd), NULL, sleep_ok);\n}\n\n \nint t4vf_get_port_stats(struct adapter *adapter, int pidx,\n\t\t\tstruct t4vf_port_stats *s)\n{\n\tstruct port_info *pi = adap2pinfo(adapter, pidx);\n\tstruct fw_vi_stats_vf fwstats;\n\tunsigned int rem = VI_VF_NUM_STATS;\n\t__be64 *fwsp = (__be64 *)&fwstats;\n\n\t \n\twhile (rem) {\n\t\tunsigned int ix = VI_VF_NUM_STATS - rem;\n\t\tunsigned int nstats = min(6U, rem);\n\t\tstruct fw_vi_stats_cmd cmd, rpl;\n\t\tsize_t len = (offsetof(struct fw_vi_stats_cmd, u) +\n\t\t\t      sizeof(struct fw_vi_stats_ctl));\n\t\tsize_t len16 = DIV_ROUND_UP(len, 16);\n\t\tint ret;\n\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.op_to_viid = cpu_to_be32(FW_CMD_OP_V(FW_VI_STATS_CMD) |\n\t\t\t\t\t     FW_VI_STATS_CMD_VIID_V(pi->viid) |\n\t\t\t\t\t     FW_CMD_REQUEST_F |\n\t\t\t\t\t     FW_CMD_READ_F);\n\t\tcmd.retval_len16 = cpu_to_be32(FW_CMD_LEN16_V(len16));\n\t\tcmd.u.ctl.nstats_ix =\n\t\t\tcpu_to_be16(FW_VI_STATS_CMD_IX_V(ix) |\n\t\t\t\t    FW_VI_STATS_CMD_NSTATS_V(nstats));\n\t\tret = t4vf_wr_mbox_ns(adapter, &cmd, len, &rpl);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmemcpy(fwsp, &rpl.u.ctl.stat0, sizeof(__be64) * nstats);\n\n\t\trem -= nstats;\n\t\tfwsp += nstats;\n\t}\n\n\t \n\ts->tx_bcast_bytes = be64_to_cpu(fwstats.tx_bcast_bytes);\n\ts->tx_bcast_frames = be64_to_cpu(fwstats.tx_bcast_frames);\n\ts->tx_mcast_bytes = be64_to_cpu(fwstats.tx_mcast_bytes);\n\ts->tx_mcast_frames = be64_to_cpu(fwstats.tx_mcast_frames);\n\ts->tx_ucast_bytes = be64_to_cpu(fwstats.tx_ucast_bytes);\n\ts->tx_ucast_frames = be64_to_cpu(fwstats.tx_ucast_frames);\n\ts->tx_drop_frames = be64_to_cpu(fwstats.tx_drop_frames);\n\ts->tx_offload_bytes = be64_to_cpu(fwstats.tx_offload_bytes);\n\ts->tx_offload_frames = be64_to_cpu(fwstats.tx_offload_frames);\n\n\ts->rx_bcast_bytes = be64_to_cpu(fwstats.rx_bcast_bytes);\n\ts->rx_bcast_frames = be64_to_cpu(fwstats.rx_bcast_frames);\n\ts->rx_mcast_bytes = be64_to_cpu(fwstats.rx_mcast_bytes);\n\ts->rx_mcast_frames = be64_to_cpu(fwstats.rx_mcast_frames);\n\ts->rx_ucast_bytes = be64_to_cpu(fwstats.rx_ucast_bytes);\n\ts->rx_ucast_frames = be64_to_cpu(fwstats.rx_ucast_frames);\n\n\ts->rx_err_frames = be64_to_cpu(fwstats.rx_err_frames);\n\n\treturn 0;\n}\n\n \nint t4vf_iq_free(struct adapter *adapter, unsigned int iqtype,\n\t\t unsigned int iqid, unsigned int fl0id, unsigned int fl1id)\n{\n\tstruct fw_iq_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_IQ_CMD) |\n\t\t\t\t    FW_CMD_REQUEST_F |\n\t\t\t\t    FW_CMD_EXEC_F);\n\tcmd.alloc_to_len16 = cpu_to_be32(FW_IQ_CMD_FREE_F |\n\t\t\t\t\t FW_LEN16(cmd));\n\tcmd.type_to_iqandstindex =\n\t\tcpu_to_be32(FW_IQ_CMD_TYPE_V(iqtype));\n\n\tcmd.iqid = cpu_to_be16(iqid);\n\tcmd.fl0id = cpu_to_be16(fl0id);\n\tcmd.fl1id = cpu_to_be16(fl1id);\n\treturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\n}\n\n \nint t4vf_eth_eq_free(struct adapter *adapter, unsigned int eqid)\n{\n\tstruct fw_eq_eth_cmd cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_EQ_ETH_CMD) |\n\t\t\t\t    FW_CMD_REQUEST_F |\n\t\t\t\t    FW_CMD_EXEC_F);\n\tcmd.alloc_to_len16 = cpu_to_be32(FW_EQ_ETH_CMD_FREE_F |\n\t\t\t\t\t FW_LEN16(cmd));\n\tcmd.eqid_pkd = cpu_to_be32(FW_EQ_ETH_CMD_EQID_V(eqid));\n\treturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\n}\n\n \nstatic const char *t4vf_link_down_rc_str(unsigned char link_down_rc)\n{\n\tstatic const char * const reason[] = {\n\t\t\"Link Down\",\n\t\t\"Remote Fault\",\n\t\t\"Auto-negotiation Failure\",\n\t\t\"Reserved\",\n\t\t\"Insufficient Airflow\",\n\t\t\"Unable To Determine Reason\",\n\t\t\"No RX Signal Detected\",\n\t\t\"Reserved\",\n\t};\n\n\tif (link_down_rc >= ARRAY_SIZE(reason))\n\t\treturn \"Bad Reason Code\";\n\n\treturn reason[link_down_rc];\n}\n\n \nstatic void t4vf_handle_get_port_info(struct port_info *pi,\n\t\t\t\t      const struct fw_port_cmd *cmd)\n{\n\tfw_port_cap32_t pcaps, acaps, lpacaps, linkattr;\n\tstruct link_config *lc = &pi->link_cfg;\n\tstruct adapter *adapter = pi->adapter;\n\tunsigned int speed, fc, fec, adv_fc;\n\tenum fw_port_module_type mod_type;\n\tint action, link_ok, linkdnrc;\n\tenum fw_port_type port_type;\n\n\t \n\taction = FW_PORT_CMD_ACTION_G(be32_to_cpu(cmd->action_to_len16));\n\tswitch (action) {\n\tcase FW_PORT_ACTION_GET_PORT_INFO: {\n\t\tu32 lstatus = be32_to_cpu(cmd->u.info.lstatus_to_modtype);\n\n\t\tlink_ok = (lstatus & FW_PORT_CMD_LSTATUS_F) != 0;\n\t\tlinkdnrc = FW_PORT_CMD_LINKDNRC_G(lstatus);\n\t\tport_type = FW_PORT_CMD_PTYPE_G(lstatus);\n\t\tmod_type = FW_PORT_CMD_MODTYPE_G(lstatus);\n\t\tpcaps = fwcaps16_to_caps32(be16_to_cpu(cmd->u.info.pcap));\n\t\tacaps = fwcaps16_to_caps32(be16_to_cpu(cmd->u.info.acap));\n\t\tlpacaps = fwcaps16_to_caps32(be16_to_cpu(cmd->u.info.lpacap));\n\n\t\t \n\t\tlinkattr = 0;\n\t\tif (lstatus & FW_PORT_CMD_RXPAUSE_F)\n\t\t\tlinkattr |= FW_PORT_CAP32_FC_RX;\n\t\tif (lstatus & FW_PORT_CMD_TXPAUSE_F)\n\t\t\tlinkattr |= FW_PORT_CAP32_FC_TX;\n\t\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_100M))\n\t\t\tlinkattr |= FW_PORT_CAP32_SPEED_100M;\n\t\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_1G))\n\t\t\tlinkattr |= FW_PORT_CAP32_SPEED_1G;\n\t\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_10G))\n\t\t\tlinkattr |= FW_PORT_CAP32_SPEED_10G;\n\t\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_25G))\n\t\t\tlinkattr |= FW_PORT_CAP32_SPEED_25G;\n\t\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_40G))\n\t\t\tlinkattr |= FW_PORT_CAP32_SPEED_40G;\n\t\tif (lstatus & FW_PORT_CMD_LSPEED_V(FW_PORT_CAP_SPEED_100G))\n\t\t\tlinkattr |= FW_PORT_CAP32_SPEED_100G;\n\n\t\tbreak;\n\t}\n\n\tcase FW_PORT_ACTION_GET_PORT_INFO32: {\n\t\tu32 lstatus32;\n\n\t\tlstatus32 = be32_to_cpu(cmd->u.info32.lstatus32_to_cbllen32);\n\t\tlink_ok = (lstatus32 & FW_PORT_CMD_LSTATUS32_F) != 0;\n\t\tlinkdnrc = FW_PORT_CMD_LINKDNRC32_G(lstatus32);\n\t\tport_type = FW_PORT_CMD_PORTTYPE32_G(lstatus32);\n\t\tmod_type = FW_PORT_CMD_MODTYPE32_G(lstatus32);\n\t\tpcaps = be32_to_cpu(cmd->u.info32.pcaps32);\n\t\tacaps = be32_to_cpu(cmd->u.info32.acaps32);\n\t\tlpacaps = be32_to_cpu(cmd->u.info32.lpacaps32);\n\t\tlinkattr = be32_to_cpu(cmd->u.info32.linkattr32);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tdev_err(adapter->pdev_dev, \"Handle Port Information: Bad Command/Action %#x\\n\",\n\t\t\tbe32_to_cpu(cmd->action_to_len16));\n\t\treturn;\n\t}\n\n\tfec = fwcap_to_cc_fec(acaps);\n\tadv_fc = fwcap_to_cc_pause(acaps);\n\tfc = fwcap_to_cc_pause(linkattr);\n\tspeed = fwcap_to_speed(linkattr);\n\n\tif (mod_type != pi->mod_type) {\n\t\t \n\t\tlc->auto_fec = fec;\n\n\t\t \n\t\tpi->port_type = port_type;\n\n\t\tpi->mod_type = mod_type;\n\t\tt4vf_os_portmod_changed(adapter, pi->pidx);\n\t}\n\n\tif (link_ok != lc->link_ok || speed != lc->speed ||\n\t    fc != lc->fc || adv_fc != lc->advertised_fc ||\n\t    fec != lc->fec) {\n\t\t \n\t\tif (!link_ok && lc->link_ok) {\n\t\t\tlc->link_down_rc = linkdnrc;\n\t\t\tdev_warn_ratelimited(adapter->pdev_dev,\n\t\t\t\t\t     \"Port %d link down, reason: %s\\n\",\n\t\t\t\t\t     pi->port_id,\n\t\t\t\t\t     t4vf_link_down_rc_str(linkdnrc));\n\t\t}\n\t\tlc->link_ok = link_ok;\n\t\tlc->speed = speed;\n\t\tlc->advertised_fc = adv_fc;\n\t\tlc->fc = fc;\n\t\tlc->fec = fec;\n\n\t\tlc->pcaps = pcaps;\n\t\tlc->lpacaps = lpacaps;\n\t\tlc->acaps = acaps & ADVERT_MASK;\n\n\t\t \n\t\tif (!(lc->pcaps & FW_PORT_CAP32_ANEG)) {\n\t\t\tlc->autoneg = AUTONEG_DISABLE;\n\t\t} else if (lc->acaps & FW_PORT_CAP32_ANEG) {\n\t\t\tlc->autoneg = AUTONEG_ENABLE;\n\t\t} else {\n\t\t\t \n\t\t\tlc->acaps = 0;\n\t\t\tlc->speed_caps = fwcap_to_speed(acaps);\n\t\t\tlc->autoneg = AUTONEG_DISABLE;\n\t\t}\n\n\t\tt4vf_os_link_changed(adapter, pi->pidx, link_ok);\n\t}\n}\n\n \nint t4vf_update_port_info(struct port_info *pi)\n{\n\tunsigned int fw_caps = pi->adapter->params.fw_caps_support;\n\tstruct fw_port_cmd port_cmd;\n\tint ret;\n\n\tmemset(&port_cmd, 0, sizeof(port_cmd));\n\tport_cmd.op_to_portid = cpu_to_be32(FW_CMD_OP_V(FW_PORT_CMD) |\n\t\t\t\t\t    FW_CMD_REQUEST_F | FW_CMD_READ_F |\n\t\t\t\t\t    FW_PORT_CMD_PORTID_V(pi->port_id));\n\tport_cmd.action_to_len16 = cpu_to_be32(\n\t\tFW_PORT_CMD_ACTION_V(fw_caps == FW_CAPS16\n\t\t\t\t     ? FW_PORT_ACTION_GET_PORT_INFO\n\t\t\t\t     : FW_PORT_ACTION_GET_PORT_INFO32) |\n\t\tFW_LEN16(port_cmd));\n\tret = t4vf_wr_mbox(pi->adapter, &port_cmd, sizeof(port_cmd),\n\t\t\t   &port_cmd);\n\tif (ret)\n\t\treturn ret;\n\tt4vf_handle_get_port_info(pi, &port_cmd);\n\treturn 0;\n}\n\n \nint t4vf_handle_fw_rpl(struct adapter *adapter, const __be64 *rpl)\n{\n\tconst struct fw_cmd_hdr *cmd_hdr = (const struct fw_cmd_hdr *)rpl;\n\tu8 opcode = FW_CMD_OP_G(be32_to_cpu(cmd_hdr->hi));\n\n\tswitch (opcode) {\n\tcase FW_PORT_CMD: {\n\t\t \n\t\tconst struct fw_port_cmd *port_cmd =\n\t\t\t(const struct fw_port_cmd *)rpl;\n\t\tint action = FW_PORT_CMD_ACTION_G(\n\t\t\tbe32_to_cpu(port_cmd->action_to_len16));\n\t\tint port_id, pidx;\n\n\t\tif (action != FW_PORT_ACTION_GET_PORT_INFO &&\n\t\t    action != FW_PORT_ACTION_GET_PORT_INFO32) {\n\t\t\tdev_err(adapter->pdev_dev,\n\t\t\t\t\"Unknown firmware PORT reply action %x\\n\",\n\t\t\t\taction);\n\t\t\tbreak;\n\t\t}\n\n\t\tport_id = FW_PORT_CMD_PORTID_G(\n\t\t\tbe32_to_cpu(port_cmd->op_to_portid));\n\t\tfor_each_port(adapter, pidx) {\n\t\t\tstruct port_info *pi = adap2pinfo(adapter, pidx);\n\n\t\t\tif (pi->port_id != port_id)\n\t\t\t\tcontinue;\n\t\t\tt4vf_handle_get_port_info(pi, port_cmd);\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tdev_err(adapter->pdev_dev, \"Unknown firmware reply %X\\n\",\n\t\t\topcode);\n\t}\n\treturn 0;\n}\n\nint t4vf_prep_adapter(struct adapter *adapter)\n{\n\tint err;\n\tunsigned int chipid;\n\n\t \n\terr = t4vf_wait_dev_ready(adapter);\n\tif (err)\n\t\treturn err;\n\n\t \n\tadapter->params.nports = 1;\n\tadapter->params.vfres.pmask = 1;\n\tadapter->params.vpd.cclk = 50000;\n\n\tadapter->params.chip = 0;\n\tswitch (CHELSIO_PCI_ID_VER(adapter->pdev->device)) {\n\tcase CHELSIO_T4:\n\t\tadapter->params.chip |= CHELSIO_CHIP_CODE(CHELSIO_T4, 0);\n\t\tadapter->params.arch.sge_fl_db = DBPRIO_F;\n\t\tadapter->params.arch.mps_tcam_size =\n\t\t\t\tNUM_MPS_CLS_SRAM_L_INSTANCES;\n\t\tbreak;\n\n\tcase CHELSIO_T5:\n\t\tchipid = REV_G(t4_read_reg(adapter, PL_VF_REV_A));\n\t\tadapter->params.chip |= CHELSIO_CHIP_CODE(CHELSIO_T5, chipid);\n\t\tadapter->params.arch.sge_fl_db = DBPRIO_F | DBTYPE_F;\n\t\tadapter->params.arch.mps_tcam_size =\n\t\t\t\tNUM_MPS_T5_CLS_SRAM_L_INSTANCES;\n\t\tbreak;\n\n\tcase CHELSIO_T6:\n\t\tchipid = REV_G(t4_read_reg(adapter, PL_VF_REV_A));\n\t\tadapter->params.chip |= CHELSIO_CHIP_CODE(CHELSIO_T6, chipid);\n\t\tadapter->params.arch.sge_fl_db = 0;\n\t\tadapter->params.arch.mps_tcam_size =\n\t\t\t\tNUM_MPS_T5_CLS_SRAM_L_INSTANCES;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nint t4vf_get_vf_mac_acl(struct adapter *adapter, unsigned int port,\n\t\t\tunsigned int *naddr, u8 *addr)\n{\n\tstruct fw_acl_mac_cmd cmd;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_ACL_MAC_CMD) |\n\t\t\t\t    FW_CMD_REQUEST_F |\n\t\t\t\t    FW_CMD_READ_F);\n\tcmd.en_to_len16 = cpu_to_be32((unsigned int)FW_LEN16(cmd));\n\tret = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cmd.nmac < *naddr)\n\t\t*naddr = cmd.nmac;\n\n\tswitch (port) {\n\tcase 3:\n\t\tmemcpy(addr, cmd.macaddr3, sizeof(cmd.macaddr3));\n\t\tbreak;\n\tcase 2:\n\t\tmemcpy(addr, cmd.macaddr2, sizeof(cmd.macaddr2));\n\t\tbreak;\n\tcase 1:\n\t\tmemcpy(addr, cmd.macaddr1, sizeof(cmd.macaddr1));\n\t\tbreak;\n\tcase 0:\n\t\tmemcpy(addr, cmd.macaddr0, sizeof(cmd.macaddr0));\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nint t4vf_get_vf_vlan_acl(struct adapter *adapter)\n{\n\tstruct fw_acl_vlan_cmd cmd;\n\tint vlan = 0;\n\tint ret = 0;\n\n\tcmd.op_to_vfn = htonl(FW_CMD_OP_V(FW_ACL_VLAN_CMD) |\n\t\t\t      FW_CMD_REQUEST_F | FW_CMD_READ_F);\n\n\t \n\tcmd.en_to_len16 = cpu_to_be32((unsigned int)FW_LEN16(cmd));\n\n\tret = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &cmd);\n\n\tif (!ret)\n\t\tvlan = be16_to_cpu(cmd.vlanid[0]);\n\n\treturn vlan;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}