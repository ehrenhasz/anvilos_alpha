{
  "module_name": "chcr_common.h",
  "hash_id": "87edf84b36e569a00ee59ee711282f0b36b1f50647983f460226415471b2eb2f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/inline_crypto/ch_ktls/chcr_common.h",
  "human_readable_source": " \n \n\n#ifndef __CHCR_COMMON_H__\n#define __CHCR_COMMON_H__\n\n#include \"cxgb4.h\"\n\n#define CHCR_MAX_SALT                      4\n#define CHCR_KEYCTX_MAC_KEY_SIZE_128       0\n#define CHCR_KEYCTX_CIPHER_KEY_SIZE_128    0\n#define CHCR_SCMD_CIPHER_MODE_AES_GCM      2\n#define CHCR_SCMD_CIPHER_MODE_AES_CTR      3\n#define CHCR_CPL_TX_SEC_PDU_LEN_64BIT      2\n#define CHCR_SCMD_SEQ_NO_CTRL_64BIT        3\n#define CHCR_SCMD_PROTO_VERSION_TLS        0\n#define CHCR_SCMD_PROTO_VERSION_GENERIC    4\n#define CHCR_SCMD_AUTH_MODE_GHASH          4\n#define AES_BLOCK_LEN                      16\n\nstruct ktls_key_ctx {\n\t__be32 ctx_hdr;\n\tu8 salt[CHCR_MAX_SALT];\n\t__be64 iv_to_auth;\n\tunsigned char key[TLS_CIPHER_AES_GCM_128_KEY_SIZE +\n\t\t\t  TLS_CIPHER_AES_GCM_256_TAG_SIZE];\n};\n\n \n#define KEY_CONTEXT_CTX_LEN_S           24\n#define KEY_CONTEXT_CTX_LEN_V(x)        ((x) << KEY_CONTEXT_CTX_LEN_S)\n\n#define KEY_CONTEXT_SALT_PRESENT_S      10\n#define KEY_CONTEXT_SALT_PRESENT_V(x)   ((x) << KEY_CONTEXT_SALT_PRESENT_S)\n#define KEY_CONTEXT_SALT_PRESENT_F      KEY_CONTEXT_SALT_PRESENT_V(1U)\n\n#define KEY_CONTEXT_VALID_S     0\n#define KEY_CONTEXT_VALID_V(x)  ((x) << KEY_CONTEXT_VALID_S)\n#define KEY_CONTEXT_VALID_F     KEY_CONTEXT_VALID_V(1U)\n\n#define KEY_CONTEXT_CK_SIZE_S           6\n#define KEY_CONTEXT_CK_SIZE_V(x)        ((x) << KEY_CONTEXT_CK_SIZE_S)\n\n#define KEY_CONTEXT_MK_SIZE_S           2\n#define KEY_CONTEXT_MK_SIZE_V(x)        ((x) << KEY_CONTEXT_MK_SIZE_S)\n\n#define KEY_CONTEXT_OPAD_PRESENT_S      11\n#define KEY_CONTEXT_OPAD_PRESENT_V(x)   ((x) << KEY_CONTEXT_OPAD_PRESENT_S)\n#define KEY_CONTEXT_OPAD_PRESENT_F      KEY_CONTEXT_OPAD_PRESENT_V(1U)\n\n#define FILL_KEY_CTX_HDR(ck_size, mk_size, ctx_len) \\\n\t\thtonl(KEY_CONTEXT_MK_SIZE_V(mk_size) | \\\n\t\t      KEY_CONTEXT_CK_SIZE_V(ck_size) | \\\n\t\t      KEY_CONTEXT_VALID_F | \\\n\t\t      KEY_CONTEXT_SALT_PRESENT_F | \\\n\t\t      KEY_CONTEXT_CTX_LEN_V((ctx_len)))\n\nstatic inline void *chcr_copy_to_txd(const void *src, const struct sge_txq *q,\n\t\t\t\t     void *pos, int length)\n{\n\tint left = (void *)q->stat - pos;\n\tu64 *p;\n\n\tif (likely(length <= left)) {\n\t\tmemcpy(pos, src, length);\n\t\tpos += length;\n\t} else {\n\t\tmemcpy(pos, src, left);\n\t\tmemcpy(q->desc, src + left, length - left);\n\t\tpos = (void *)q->desc + (length - left);\n\t}\n\t \n\tp = PTR_ALIGN(pos, 8);\n\tif ((uintptr_t)p & 8) {\n\t\t*p = 0;\n\t\treturn p + 1;\n\t}\n\treturn p;\n}\n\nstatic inline unsigned int chcr_txq_avail(const struct sge_txq *q)\n{\n\treturn q->size - 1 - q->in_use;\n}\n\nstatic inline void chcr_txq_advance(struct sge_txq *q, unsigned int n)\n{\n\tq->in_use += n;\n\tq->pidx += n;\n\tif (q->pidx >= q->size)\n\t\tq->pidx -= q->size;\n}\n\nstatic inline void chcr_eth_txq_stop(struct sge_eth_txq *q)\n{\n\tnetif_tx_stop_queue(q->txq);\n\tq->q.stops++;\n}\n\nstatic inline unsigned int chcr_sgl_len(unsigned int n)\n{\n\tn--;\n\treturn (3 * n) / 2 + (n & 1) + 2;\n}\n\nstatic inline unsigned int chcr_flits_to_desc(unsigned int n)\n{\n\tWARN_ON(n > SGE_MAX_WR_LEN / 8);\n\treturn DIV_ROUND_UP(n, 8);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}