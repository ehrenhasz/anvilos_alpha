{
  "module_name": "chtls_hw.c",
  "hash_id": "1cb23dd2b839c62dce18f56bd8a52d22e36c142e63618329465e0f3131c6670e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/inline_crypto/chtls/chtls_hw.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <linux/skbuff.h>\n#include <linux/timer.h>\n#include <linux/notifier.h>\n#include <linux/inetdevice.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/tls.h>\n#include <net/tls.h>\n\n#include \"chtls.h\"\n#include \"chtls_cm.h\"\n\nstatic void __set_tcb_field_direct(struct chtls_sock *csk,\n\t\t\t\t   struct cpl_set_tcb_field *req, u16 word,\n\t\t\t\t   u64 mask, u64 val, u8 cookie, int no_reply)\n{\n\tstruct ulptx_idata *sc;\n\n\tINIT_TP_WR_CPL(req, CPL_SET_TCB_FIELD, csk->tid);\n\treq->wr.wr_mid |= htonl(FW_WR_FLOWID_V(csk->tid));\n\treq->reply_ctrl = htons(NO_REPLY_V(no_reply) |\n\t\t\t\tQUEUENO_V(csk->rss_qid));\n\treq->word_cookie = htons(TCB_WORD_V(word) | TCB_COOKIE_V(cookie));\n\treq->mask = cpu_to_be64(mask);\n\treq->val = cpu_to_be64(val);\n\tsc = (struct ulptx_idata *)(req + 1);\n\tsc->cmd_more = htonl(ULPTX_CMD_V(ULP_TX_SC_NOOP));\n\tsc->len = htonl(0);\n}\n\nstatic void __set_tcb_field(struct sock *sk, struct sk_buff *skb, u16 word,\n\t\t\t    u64 mask, u64 val, u8 cookie, int no_reply)\n{\n\tstruct cpl_set_tcb_field *req;\n\tstruct chtls_sock *csk;\n\tstruct ulptx_idata *sc;\n\tunsigned int wrlen;\n\n\twrlen = roundup(sizeof(*req) + sizeof(*sc), 16);\n\tcsk = rcu_dereference_sk_user_data(sk);\n\n\treq = (struct cpl_set_tcb_field *)__skb_put(skb, wrlen);\n\t__set_tcb_field_direct(csk, req, word, mask, val, cookie, no_reply);\n\tset_wr_txq(skb, CPL_PRIORITY_CONTROL, csk->port_id);\n}\n\n \nstatic int chtls_set_tcb_field(struct sock *sk, u16 word, u64 mask, u64 val)\n{\n\tstruct cpl_set_tcb_field *req;\n\tunsigned int credits_needed;\n\tstruct chtls_sock *csk;\n\tstruct ulptx_idata *sc;\n\tstruct sk_buff *skb;\n\tunsigned int wrlen;\n\tint ret;\n\n\twrlen = roundup(sizeof(*req) + sizeof(*sc), 16);\n\n\tskb = alloc_skb(wrlen, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcredits_needed = DIV_ROUND_UP(wrlen, 16);\n\tcsk = rcu_dereference_sk_user_data(sk);\n\n\t__set_tcb_field(sk, skb, word, mask, val, 0, 1);\n\tskb_set_queue_mapping(skb, (csk->txq_idx << 1) | CPL_PRIORITY_DATA);\n\tcsk->wr_credits -= credits_needed;\n\tcsk->wr_unacked += credits_needed;\n\tenqueue_wr(csk, skb);\n\tret = cxgb4_ofld_send(csk->egress_dev, skb);\n\tif (ret < 0)\n\t\tkfree_skb(skb);\n\treturn ret < 0 ? ret : 0;\n}\n\nvoid chtls_set_tcb_field_rpl_skb(struct sock *sk, u16 word,\n\t\t\t\t u64 mask, u64 val, u8 cookie,\n\t\t\t\t int through_l2t)\n{\n\tstruct sk_buff *skb;\n\tunsigned int wrlen;\n\n\twrlen = sizeof(struct cpl_set_tcb_field) + sizeof(struct ulptx_idata);\n\twrlen = roundup(wrlen, 16);\n\n\tskb = alloc_skb(wrlen, GFP_KERNEL | __GFP_NOFAIL);\n\tif (!skb)\n\t\treturn;\n\n\t__set_tcb_field(sk, skb, word, mask, val, cookie, 0);\n\tsend_or_defer(sk, tcp_sk(sk), skb, through_l2t);\n}\n\n \nint chtls_set_tcb_tflag(struct sock *sk, unsigned int bit_pos, int val)\n{\n\treturn chtls_set_tcb_field(sk, 1, 1ULL << bit_pos,\n\t\t\t\t   (u64)val << bit_pos);\n}\n\nstatic int chtls_set_tcb_keyid(struct sock *sk, int keyid)\n{\n\treturn chtls_set_tcb_field(sk, 31, 0xFFFFFFFFULL, keyid);\n}\n\nstatic int chtls_set_tcb_seqno(struct sock *sk)\n{\n\treturn chtls_set_tcb_field(sk, 28, ~0ULL, 0);\n}\n\nstatic int chtls_set_tcb_quiesce(struct sock *sk, int val)\n{\n\treturn chtls_set_tcb_field(sk, 1, (1ULL << TF_RX_QUIESCE_S),\n\t\t\t\t   TF_RX_QUIESCE_V(val));\n}\n\nvoid chtls_set_quiesce_ctrl(struct sock *sk, int val)\n{\n\tstruct chtls_sock *csk;\n\tstruct sk_buff *skb;\n\tunsigned int wrlen;\n\tint ret;\n\n\twrlen = sizeof(struct cpl_set_tcb_field) + sizeof(struct ulptx_idata);\n\twrlen = roundup(wrlen, 16);\n\n\tskb = alloc_skb(wrlen, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tcsk = rcu_dereference_sk_user_data(sk);\n\n\t__set_tcb_field(sk, skb, 1, TF_RX_QUIESCE_V(1), 0, 0, 1);\n\tset_wr_txq(skb, CPL_PRIORITY_CONTROL, csk->port_id);\n\tret = cxgb4_ofld_send(csk->egress_dev, skb);\n\tif (ret < 0)\n\t\tkfree_skb(skb);\n}\n\n \nint chtls_init_kmap(struct chtls_dev *cdev, struct cxgb4_lld_info *lldi)\n{\n\tunsigned int num_key_ctx, bsize;\n\tint ksize;\n\n\tnum_key_ctx = (lldi->vr->key.size / TLS_KEY_CONTEXT_SZ);\n\tbsize = BITS_TO_LONGS(num_key_ctx);\n\n\tcdev->kmap.size = num_key_ctx;\n\tcdev->kmap.available = bsize;\n\tksize = sizeof(*cdev->kmap.addr) * bsize;\n\tcdev->kmap.addr = kvzalloc(ksize, GFP_KERNEL);\n\tif (!cdev->kmap.addr)\n\t\treturn -ENOMEM;\n\n\tcdev->kmap.start = lldi->vr->key.start;\n\tspin_lock_init(&cdev->kmap.lock);\n\treturn 0;\n}\n\nstatic int get_new_keyid(struct chtls_sock *csk, u32 optname)\n{\n\tstruct net_device *dev = csk->egress_dev;\n\tstruct chtls_dev *cdev = csk->cdev;\n\tstruct chtls_hws *hws;\n\tstruct adapter *adap;\n\tint keyid;\n\n\tadap = netdev2adap(dev);\n\thws = &csk->tlshws;\n\n\tspin_lock_bh(&cdev->kmap.lock);\n\tkeyid = find_first_zero_bit(cdev->kmap.addr, cdev->kmap.size);\n\tif (keyid < cdev->kmap.size) {\n\t\t__set_bit(keyid, cdev->kmap.addr);\n\t\tif (optname == TLS_RX)\n\t\t\thws->rxkey = keyid;\n\t\telse\n\t\t\thws->txkey = keyid;\n\t\tatomic_inc(&adap->chcr_stats.tls_key);\n\t} else {\n\t\tkeyid = -1;\n\t}\n\tspin_unlock_bh(&cdev->kmap.lock);\n\treturn keyid;\n}\n\nvoid free_tls_keyid(struct sock *sk)\n{\n\tstruct chtls_sock *csk = rcu_dereference_sk_user_data(sk);\n\tstruct net_device *dev = csk->egress_dev;\n\tstruct chtls_dev *cdev = csk->cdev;\n\tstruct chtls_hws *hws;\n\tstruct adapter *adap;\n\n\tif (!cdev->kmap.addr)\n\t\treturn;\n\n\tadap = netdev2adap(dev);\n\thws = &csk->tlshws;\n\n\tspin_lock_bh(&cdev->kmap.lock);\n\tif (hws->rxkey >= 0) {\n\t\t__clear_bit(hws->rxkey, cdev->kmap.addr);\n\t\tatomic_dec(&adap->chcr_stats.tls_key);\n\t\thws->rxkey = -1;\n\t}\n\tif (hws->txkey >= 0) {\n\t\t__clear_bit(hws->txkey, cdev->kmap.addr);\n\t\tatomic_dec(&adap->chcr_stats.tls_key);\n\t\thws->txkey = -1;\n\t}\n\tspin_unlock_bh(&cdev->kmap.lock);\n}\n\nunsigned int keyid_to_addr(int start_addr, int keyid)\n{\n\treturn (start_addr + (keyid * TLS_KEY_CONTEXT_SZ)) >> 5;\n}\n\nstatic void chtls_rxkey_ivauth(struct _key_ctx *kctx)\n{\n\tkctx->iv_to_auth = cpu_to_be64(KEYCTX_TX_WR_IV_V(6ULL) |\n\t\t\t\t  KEYCTX_TX_WR_AAD_V(1ULL) |\n\t\t\t\t  KEYCTX_TX_WR_AADST_V(5ULL) |\n\t\t\t\t  KEYCTX_TX_WR_CIPHER_V(14ULL) |\n\t\t\t\t  KEYCTX_TX_WR_CIPHERST_V(0ULL) |\n\t\t\t\t  KEYCTX_TX_WR_AUTH_V(14ULL) |\n\t\t\t\t  KEYCTX_TX_WR_AUTHST_V(16ULL) |\n\t\t\t\t  KEYCTX_TX_WR_AUTHIN_V(16ULL));\n}\n\nstatic int chtls_key_info(struct chtls_sock *csk,\n\t\t\t  struct _key_ctx *kctx,\n\t\t\t  u32 keylen, u32 optname,\n\t\t\t  int cipher_type)\n{\n\tunsigned char key[AES_MAX_KEY_SIZE];\n\tunsigned char *key_p, *salt;\n\tunsigned char ghash_h[AEAD_H_SIZE];\n\tint ck_size, key_ctx_size, kctx_mackey_size, salt_size;\n\tstruct crypto_aes_ctx aes;\n\tint ret;\n\n\tkey_ctx_size = sizeof(struct _key_ctx) +\n\t\t       roundup(keylen, 16) + AEAD_H_SIZE;\n\n\t \n\tswitch (cipher_type) {\n\tcase TLS_CIPHER_AES_GCM_128: {\n\t\tstruct tls12_crypto_info_aes_gcm_128 *gcm_ctx_128 =\n\t\t\t(struct tls12_crypto_info_aes_gcm_128 *)\n\t\t\t\t\t&csk->tlshws.crypto_info;\n\t\tmemcpy(key, gcm_ctx_128->key, keylen);\n\n\t\tkey_p            = gcm_ctx_128->key;\n\t\tsalt             = gcm_ctx_128->salt;\n\t\tck_size          = CHCR_KEYCTX_CIPHER_KEY_SIZE_128;\n\t\tsalt_size        = TLS_CIPHER_AES_GCM_128_SALT_SIZE;\n\t\tkctx_mackey_size = CHCR_KEYCTX_MAC_KEY_SIZE_128;\n\t\tbreak;\n\t}\n\tcase TLS_CIPHER_AES_GCM_256: {\n\t\tstruct tls12_crypto_info_aes_gcm_256 *gcm_ctx_256 =\n\t\t\t(struct tls12_crypto_info_aes_gcm_256 *)\n\t\t\t\t\t&csk->tlshws.crypto_info;\n\t\tmemcpy(key, gcm_ctx_256->key, keylen);\n\n\t\tkey_p            = gcm_ctx_256->key;\n\t\tsalt             = gcm_ctx_256->salt;\n\t\tck_size          = CHCR_KEYCTX_CIPHER_KEY_SIZE_256;\n\t\tsalt_size        = TLS_CIPHER_AES_GCM_256_SALT_SIZE;\n\t\tkctx_mackey_size = CHCR_KEYCTX_MAC_KEY_SIZE_256;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpr_err(\"GCM: Invalid key length %d\\n\", keylen);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = aes_expandkey(&aes, key, keylen);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(ghash_h, 0, AEAD_H_SIZE);\n\taes_encrypt(&aes, ghash_h, ghash_h);\n\tmemzero_explicit(&aes, sizeof(aes));\n\tcsk->tlshws.keylen = key_ctx_size;\n\n\t \n\tif (optname == TLS_RX) {\n\t\tint key_ctx;\n\n\t\tkey_ctx = ((key_ctx_size >> 4) << 3);\n\t\tkctx->ctx_hdr = FILL_KEY_CRX_HDR(ck_size,\n\t\t\t\t\t\t kctx_mackey_size,\n\t\t\t\t\t\t 0, 0, key_ctx);\n\t\tchtls_rxkey_ivauth(kctx);\n\t} else {\n\t\tkctx->ctx_hdr = FILL_KEY_CTX_HDR(ck_size,\n\t\t\t\t\t\t kctx_mackey_size,\n\t\t\t\t\t\t 0, 0, key_ctx_size >> 4);\n\t}\n\n\tmemcpy(kctx->salt, salt, salt_size);\n\tmemcpy(kctx->key, key_p, keylen);\n\tmemcpy(kctx->key + keylen, ghash_h, AEAD_H_SIZE);\n\t \n\tmemset(key_p, 0, keylen);\n\n\treturn 0;\n}\n\nstatic void chtls_set_scmd(struct chtls_sock *csk)\n{\n\tstruct chtls_hws *hws = &csk->tlshws;\n\n\thws->scmd.seqno_numivs =\n\t\tSCMD_SEQ_NO_CTRL_V(3) |\n\t\tSCMD_PROTO_VERSION_V(0) |\n\t\tSCMD_ENC_DEC_CTRL_V(0) |\n\t\tSCMD_CIPH_AUTH_SEQ_CTRL_V(1) |\n\t\tSCMD_CIPH_MODE_V(2) |\n\t\tSCMD_AUTH_MODE_V(4) |\n\t\tSCMD_HMAC_CTRL_V(0) |\n\t\tSCMD_IV_SIZE_V(4) |\n\t\tSCMD_NUM_IVS_V(1);\n\n\thws->scmd.ivgen_hdrlen =\n\t\tSCMD_IV_GEN_CTRL_V(1) |\n\t\tSCMD_KEY_CTX_INLINE_V(0) |\n\t\tSCMD_TLS_FRAG_ENABLE_V(1);\n}\n\nint chtls_setkey(struct chtls_sock *csk, u32 keylen,\n\t\t u32 optname, int cipher_type)\n{\n\tstruct tls_key_req *kwr;\n\tstruct chtls_dev *cdev;\n\tstruct _key_ctx *kctx;\n\tint wrlen, klen, len;\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tint keyid;\n\tint kaddr;\n\tint ret;\n\n\tcdev = csk->cdev;\n\tsk = csk->sk;\n\n\tklen = roundup((keylen + AEAD_H_SIZE) + sizeof(*kctx), 32);\n\twrlen = roundup(sizeof(*kwr), 16);\n\tlen = klen + wrlen;\n\n\t \n\tif (optname == TLS_TX) {\n\t\tlock_sock(sk);\n\t\tif (skb_queue_len(&csk->txq))\n\t\t\tchtls_push_frames(csk, 0);\n\t\trelease_sock(sk);\n\t}\n\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tkeyid = get_new_keyid(csk, optname);\n\tif (keyid < 0) {\n\t\tret = -ENOSPC;\n\t\tgoto out_nokey;\n\t}\n\n\tkaddr = keyid_to_addr(cdev->kmap.start, keyid);\n\tkwr = (struct tls_key_req *)__skb_put_zero(skb, len);\n\tkwr->wr.op_to_compl =\n\t\tcpu_to_be32(FW_WR_OP_V(FW_ULPTX_WR) | FW_WR_COMPL_F |\n\t\t      FW_WR_ATOMIC_V(1U));\n\tkwr->wr.flowid_len16 =\n\t\tcpu_to_be32(FW_WR_LEN16_V(DIV_ROUND_UP(len, 16) |\n\t\t\t    FW_WR_FLOWID_V(csk->tid)));\n\tkwr->wr.protocol = 0;\n\tkwr->wr.mfs = htons(TLS_MFS);\n\tkwr->wr.reneg_to_write_rx = optname;\n\n\t \n\tkwr->req.cmd = cpu_to_be32(ULPTX_CMD_V(ULP_TX_MEM_WRITE) |\n\t\t\t    T5_ULP_MEMIO_ORDER_V(1) |\n\t\t\t    T5_ULP_MEMIO_IMM_V(1));\n\tkwr->req.len16 = cpu_to_be32((csk->tid << 8) |\n\t\t\t      DIV_ROUND_UP(len - sizeof(kwr->wr), 16));\n\tkwr->req.dlen = cpu_to_be32(ULP_MEMIO_DATA_LEN_V(klen >> 5));\n\tkwr->req.lock_addr = cpu_to_be32(ULP_MEMIO_ADDR_V(kaddr));\n\n\t \n\tkwr->sc_imm.cmd_more = cpu_to_be32(ULPTX_CMD_V(ULP_TX_SC_IMM));\n\tkwr->sc_imm.len = cpu_to_be32(klen);\n\n\tlock_sock(sk);\n\t \n\tkctx = (struct _key_ctx *)(kwr + 1);\n\tret = chtls_key_info(csk, kctx, keylen, optname, cipher_type);\n\tif (ret)\n\t\tgoto out_notcb;\n\n\tif (unlikely(csk_flag(sk, CSK_ABORT_SHUTDOWN)))\n\t\tgoto out_notcb;\n\n\tset_wr_txq(skb, CPL_PRIORITY_DATA, csk->tlshws.txqid);\n\tcsk->wr_credits -= DIV_ROUND_UP(len, 16);\n\tcsk->wr_unacked += DIV_ROUND_UP(len, 16);\n\tenqueue_wr(csk, skb);\n\tcxgb4_ofld_send(csk->egress_dev, skb);\n\tskb = NULL;\n\n\tchtls_set_scmd(csk);\n\t \n\tif (optname == TLS_RX) {\n\t\tret = chtls_set_tcb_keyid(sk, keyid);\n\t\tif (ret)\n\t\t\tgoto out_notcb;\n\t\tret = chtls_set_tcb_field(sk, 0,\n\t\t\t\t\t  TCB_ULP_RAW_V(TCB_ULP_RAW_M),\n\t\t\t\t\t  TCB_ULP_RAW_V((TF_TLS_KEY_SIZE_V(1) |\n\t\t\t\t\t  TF_TLS_CONTROL_V(1) |\n\t\t\t\t\t  TF_TLS_ACTIVE_V(1) |\n\t\t\t\t\t  TF_TLS_ENABLE_V(1))));\n\t\tif (ret)\n\t\t\tgoto out_notcb;\n\t\tret = chtls_set_tcb_seqno(sk);\n\t\tif (ret)\n\t\t\tgoto out_notcb;\n\t\tret = chtls_set_tcb_quiesce(sk, 0);\n\t\tif (ret)\n\t\t\tgoto out_notcb;\n\t\tcsk->tlshws.rxkey = keyid;\n\t} else {\n\t\tcsk->tlshws.tx_seq_no = 0;\n\t\tcsk->tlshws.txkey = keyid;\n\t}\n\n\trelease_sock(sk);\n\treturn ret;\nout_notcb:\n\trelease_sock(sk);\n\tfree_tls_keyid(sk);\nout_nokey:\n\tkfree_skb(skb);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}