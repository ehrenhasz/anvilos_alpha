{
  "module_name": "chtls.h",
  "hash_id": "e2cbc6d911075943ddaaef8606edaa9ca0fc2c9f802e285a4146c23b079cd457",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/chelsio/inline_crypto/chtls/chtls.h",
  "human_readable_source": " \n \n\n#ifndef __CHTLS_H__\n#define __CHTLS_H__\n\n#include <crypto/aes.h>\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <crypto/sha1.h>\n#include <crypto/sha2.h>\n#include <crypto/authenc.h>\n#include <crypto/ctr.h>\n#include <crypto/gf128mul.h>\n#include <crypto/internal/aead.h>\n#include <crypto/null.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/aead.h>\n#include <crypto/scatterwalk.h>\n#include <crypto/internal/hash.h>\n#include <linux/tls.h>\n#include <net/tls.h>\n#include <net/tls_prot.h>\n#include <net/tls_toe.h>\n\n#include \"t4fw_api.h\"\n#include \"t4_msg.h\"\n#include \"cxgb4.h\"\n#include \"cxgb4_uld.h\"\n#include \"l2t.h\"\n#include \"chcr_algo.h\"\n#include \"chcr_core.h\"\n#include \"chcr_crypto.h\"\n\n#define CHTLS_DRV_VERSION \"1.0.0.0-ko\"\n\n#define TLS_KEYCTX_RXFLIT_CNT_S 24\n#define TLS_KEYCTX_RXFLIT_CNT_V(x) ((x) << TLS_KEYCTX_RXFLIT_CNT_S)\n\n#define TLS_KEYCTX_RXPROT_VER_S 20\n#define TLS_KEYCTX_RXPROT_VER_M 0xf\n#define TLS_KEYCTX_RXPROT_VER_V(x) ((x) << TLS_KEYCTX_RXPROT_VER_S)\n\n#define TLS_KEYCTX_RXCIPH_MODE_S 16\n#define TLS_KEYCTX_RXCIPH_MODE_M 0xf\n#define TLS_KEYCTX_RXCIPH_MODE_V(x) ((x) << TLS_KEYCTX_RXCIPH_MODE_S)\n\n#define TLS_KEYCTX_RXAUTH_MODE_S 12\n#define TLS_KEYCTX_RXAUTH_MODE_M 0xf\n#define TLS_KEYCTX_RXAUTH_MODE_V(x) ((x) << TLS_KEYCTX_RXAUTH_MODE_S)\n\n#define TLS_KEYCTX_RXCIAU_CTRL_S 11\n#define TLS_KEYCTX_RXCIAU_CTRL_V(x) ((x) << TLS_KEYCTX_RXCIAU_CTRL_S)\n\n#define TLS_KEYCTX_RX_SEQCTR_S 9\n#define TLS_KEYCTX_RX_SEQCTR_M 0x3\n#define TLS_KEYCTX_RX_SEQCTR_V(x) ((x) << TLS_KEYCTX_RX_SEQCTR_S)\n\n#define TLS_KEYCTX_RX_VALID_S 8\n#define TLS_KEYCTX_RX_VALID_V(x) ((x) << TLS_KEYCTX_RX_VALID_S)\n\n#define TLS_KEYCTX_RXCK_SIZE_S 3\n#define TLS_KEYCTX_RXCK_SIZE_M 0x7\n#define TLS_KEYCTX_RXCK_SIZE_V(x) ((x) << TLS_KEYCTX_RXCK_SIZE_S)\n\n#define TLS_KEYCTX_RXMK_SIZE_S 0\n#define TLS_KEYCTX_RXMK_SIZE_M 0x7\n#define TLS_KEYCTX_RXMK_SIZE_V(x) ((x) << TLS_KEYCTX_RXMK_SIZE_S)\n\n#define KEYCTX_TX_WR_IV_S  55\n#define KEYCTX_TX_WR_IV_M  0x1ffULL\n#define KEYCTX_TX_WR_IV_V(x) ((x) << KEYCTX_TX_WR_IV_S)\n#define KEYCTX_TX_WR_IV_G(x) \\\n\t(((x) >> KEYCTX_TX_WR_IV_S) & KEYCTX_TX_WR_IV_M)\n\n#define KEYCTX_TX_WR_AAD_S 47\n#define KEYCTX_TX_WR_AAD_M 0xffULL\n#define KEYCTX_TX_WR_AAD_V(x) ((x) << KEYCTX_TX_WR_AAD_S)\n#define KEYCTX_TX_WR_AAD_G(x) (((x) >> KEYCTX_TX_WR_AAD_S) & \\\n\t\t\t\tKEYCTX_TX_WR_AAD_M)\n\n#define KEYCTX_TX_WR_AADST_S 39\n#define KEYCTX_TX_WR_AADST_M 0xffULL\n#define KEYCTX_TX_WR_AADST_V(x) ((x) << KEYCTX_TX_WR_AADST_S)\n#define KEYCTX_TX_WR_AADST_G(x) \\\n\t(((x) >> KEYCTX_TX_WR_AADST_S) & KEYCTX_TX_WR_AADST_M)\n\n#define KEYCTX_TX_WR_CIPHER_S 30\n#define KEYCTX_TX_WR_CIPHER_M 0x1ffULL\n#define KEYCTX_TX_WR_CIPHER_V(x) ((x) << KEYCTX_TX_WR_CIPHER_S)\n#define KEYCTX_TX_WR_CIPHER_G(x) \\\n\t(((x) >> KEYCTX_TX_WR_CIPHER_S) & KEYCTX_TX_WR_CIPHER_M)\n\n#define KEYCTX_TX_WR_CIPHERST_S 23\n#define KEYCTX_TX_WR_CIPHERST_M 0x7f\n#define KEYCTX_TX_WR_CIPHERST_V(x) ((x) << KEYCTX_TX_WR_CIPHERST_S)\n#define KEYCTX_TX_WR_CIPHERST_G(x) \\\n\t(((x) >> KEYCTX_TX_WR_CIPHERST_S) & KEYCTX_TX_WR_CIPHERST_M)\n\n#define KEYCTX_TX_WR_AUTH_S 14\n#define KEYCTX_TX_WR_AUTH_M 0x1ff\n#define KEYCTX_TX_WR_AUTH_V(x) ((x) << KEYCTX_TX_WR_AUTH_S)\n#define KEYCTX_TX_WR_AUTH_G(x) \\\n\t(((x) >> KEYCTX_TX_WR_AUTH_S) & KEYCTX_TX_WR_AUTH_M)\n\n#define KEYCTX_TX_WR_AUTHST_S 7\n#define KEYCTX_TX_WR_AUTHST_M 0x7f\n#define KEYCTX_TX_WR_AUTHST_V(x) ((x) << KEYCTX_TX_WR_AUTHST_S)\n#define KEYCTX_TX_WR_AUTHST_G(x) \\\n\t(((x) >> KEYCTX_TX_WR_AUTHST_S) & KEYCTX_TX_WR_AUTHST_M)\n\n#define KEYCTX_TX_WR_AUTHIN_S 0\n#define KEYCTX_TX_WR_AUTHIN_M 0x7f\n#define KEYCTX_TX_WR_AUTHIN_V(x) ((x) << KEYCTX_TX_WR_AUTHIN_S)\n#define KEYCTX_TX_WR_AUTHIN_G(x) \\\n\t(((x) >> KEYCTX_TX_WR_AUTHIN_S) & KEYCTX_TX_WR_AUTHIN_M)\n\nstruct sge_opaque_hdr {\n\tvoid *dev;\n\tdma_addr_t addr[MAX_SKB_FRAGS + 1];\n};\n\n#define MAX_IVS_PAGE\t\t\t256\n#define TLS_KEY_CONTEXT_SZ\t\t64\n#define CIPHER_BLOCK_SIZE\t\t16\n#define GCM_TAG_SIZE\t\t\t16\n#define KEY_ON_MEM_SZ\t\t\t16\n#define AEAD_EXPLICIT_DATA_SIZE\t\t8\n#define TLS_HEADER_LENGTH\t\t5\n#define SCMD_CIPH_MODE_AES_GCM\t\t2\n \n#define TLS_MFS\t\t\t\t16384\n\n#define RSS_HDR sizeof(struct rss_header)\n#define TLS_WR_CPL_LEN \\\n\t(sizeof(struct fw_tlstx_data_wr) + sizeof(struct cpl_tx_tls_sfo))\n\nenum {\n\tCHTLS_KEY_CONTEXT_DSGL,\n\tCHTLS_KEY_CONTEXT_IMM,\n\tCHTLS_KEY_CONTEXT_DDR,\n};\n\nenum {\n\tCHTLS_LISTEN_START,\n\tCHTLS_LISTEN_STOP,\n};\n\n \nenum {\n\tCPL_RET_BUF_DONE =    1,    \n\tCPL_RET_BAD_MSG =     2,    \n\tCPL_RET_UNKNOWN_TID = 4     \n};\n\n#define LISTEN_INFO_HASH_SIZE 32\n#define RSPQ_HASH_BITS 5\nstruct listen_info {\n\tstruct listen_info *next;   \n\tstruct sock *sk;            \n\tunsigned int stid;          \n};\n\nenum {\n\tT4_LISTEN_START_PENDING,\n\tT4_LISTEN_STARTED\n};\n\nenum csk_flags {\n\tCSK_CALLBACKS_CHKD,\t \n\tCSK_ABORT_REQ_RCVD,\t \n\tCSK_TX_MORE_DATA,\t \n\tCSK_TX_WAIT_IDLE,\t \n\tCSK_ABORT_SHUTDOWN,\t \n\tCSK_ABORT_RPL_PENDING,\t \n\tCSK_CLOSE_CON_REQUESTED, \n\tCSK_TX_DATA_SENT,\t \n\tCSK_TX_FAILOVER,\t \n\tCSK_UPDATE_RCV_WND,\t \n\tCSK_RST_ABORTED,\t \n\tCSK_TLS_HANDSHK,\t \n\tCSK_CONN_INLINE,\t \n};\n\nenum chtls_cdev_state {\n\tCHTLS_CDEV_STATE_UP = 1\n};\n\nstruct listen_ctx {\n\tstruct sock *lsk;\n\tstruct chtls_dev *cdev;\n\tstruct sk_buff_head synq;\n\tu32 state;\n};\n\nstruct key_map {\n\tunsigned long *addr;\n\tunsigned int start;\n\tunsigned int available;\n\tunsigned int size;\n\tspinlock_t lock;  \n} __packed;\n\nstruct tls_scmd {\n\tu32 seqno_numivs;\n\tu32 ivgen_hdrlen;\n};\n\nstruct chtls_dev {\n\tstruct tls_toe_device tlsdev;\n\tstruct list_head list;\n\tstruct cxgb4_lld_info *lldi;\n\tstruct pci_dev *pdev;\n\tstruct listen_info *listen_hash_tab[LISTEN_INFO_HASH_SIZE];\n\tspinlock_t listen_lock;  \n\tstruct net_device **ports;\n\tstruct tid_info *tids;\n\tunsigned int pfvf;\n\tconst unsigned short *mtus;\n\n\tstruct idr hwtid_idr;\n\tstruct idr stid_idr;\n\n\tspinlock_t idr_lock ____cacheline_aligned_in_smp;\n\n\tstruct net_device *egr_dev[NCHAN * 2];\n\tstruct sk_buff *rspq_skb_cache[1 << RSPQ_HASH_BITS];\n\tstruct sk_buff *askb;\n\n\tstruct sk_buff_head deferq;\n\tstruct work_struct deferq_task;\n\n\tstruct list_head list_node;\n\tstruct list_head rcu_node;\n\tstruct list_head na_node;\n\tunsigned int send_page_order;\n\tint max_host_sndbuf;\n\tu32 round_robin_cnt;\n\tstruct key_map kmap;\n\tunsigned int cdev_state;\n};\n\nstruct chtls_listen {\n\tstruct chtls_dev *cdev;\n\tstruct sock *sk;\n};\n\nstruct chtls_hws {\n\tstruct sk_buff_head sk_recv_queue;\n\tu8 txqid;\n\tu8 ofld;\n\tu16 type;\n\tu16 rstate;\n\tu16 keyrpl;\n\tu16 pldlen;\n\tu16 rcvpld;\n\tu16 compute;\n\tu16 expansion;\n\tu16 keylen;\n\tu16 pdus;\n\tu16 adjustlen;\n\tu16 ivsize;\n\tu16 txleft;\n\tu32 mfs;\n\ts32 txkey;\n\ts32 rxkey;\n\tu32 fcplenmax;\n\tu32 copied_seq;\n\tu64 tx_seq_no;\n\tstruct tls_scmd scmd;\n\tunion {\n\t\tstruct tls12_crypto_info_aes_gcm_128 aes_gcm_128;\n\t\tstruct tls12_crypto_info_aes_gcm_256 aes_gcm_256;\n\t} crypto_info;\n};\n\nstruct chtls_sock {\n\tstruct sock *sk;\n\tstruct chtls_dev *cdev;\n\tstruct l2t_entry *l2t_entry;     \n\tstruct net_device *egress_dev;   \n\n\tstruct sk_buff_head txq;\n\tstruct sk_buff *wr_skb_head;\n\tstruct sk_buff *wr_skb_tail;\n\tstruct sk_buff *ctrl_skb_cache;\n\tstruct sk_buff *txdata_skb_cache;  \n\tstruct kref kref;\n\tunsigned long flags;\n\tu32 opt2;\n\tu32 wr_credits;\n\tu32 wr_unacked;\n\tu32 wr_max_credits;\n\tu32 wr_nondata;\n\tu32 hwtid;                \n\tu32 txq_idx;\n\tu32 rss_qid;\n\tu32 tid;\n\tu32 idr;\n\tu32 mss;\n\tu32 ulp_mode;\n\tu32 tx_chan;\n\tu32 rx_chan;\n\tu32 sndbuf;\n\tu32 txplen_max;\n\tu32 mtu_idx;            \n\tu32 smac_idx;\n\tu8 port_id;\n\tu8 tos;\n\tu16 resv2;\n\tu32 delack_mode;\n\tu32 delack_seq;\n\tu32 snd_win;\n\tu32 rcv_win;\n\n\tvoid *passive_reap_next;         \n\tstruct chtls_hws tlshws;\n\tstruct synq {\n\t\tstruct sk_buff *next;\n\t\tstruct sk_buff *prev;\n\t} synq;\n\tstruct listen_ctx *listen_ctx;\n};\n\nstruct tls_hdr {\n\tu8  type;\n\tu16 version;\n\tu16 length;\n} __packed;\n\nstruct tlsrx_cmp_hdr {\n\tu8  type;\n\tu16 version;\n\tu16 length;\n\n\tu64 tls_seq;\n\tu16 reserved1;\n\tu8  res_to_mac_error;\n} __packed;\n\n \n#define TLSRX_HDR_PKT_INT_ERROR_S   4\n#define TLSRX_HDR_PKT_INT_ERROR_M   0x1\n#define TLSRX_HDR_PKT_INT_ERROR_V(x) \\\n\t((x) << TLSRX_HDR_PKT_INT_ERROR_S)\n#define TLSRX_HDR_PKT_INT_ERROR_G(x) \\\n\t(((x) >> TLSRX_HDR_PKT_INT_ERROR_S) & TLSRX_HDR_PKT_INT_ERROR_M)\n#define TLSRX_HDR_PKT_INT_ERROR_F   TLSRX_HDR_PKT_INT_ERROR_V(1U)\n\n#define TLSRX_HDR_PKT_SPP_ERROR_S        3\n#define TLSRX_HDR_PKT_SPP_ERROR_M        0x1\n#define TLSRX_HDR_PKT_SPP_ERROR_V(x)     ((x) << TLSRX_HDR_PKT_SPP_ERROR)\n#define TLSRX_HDR_PKT_SPP_ERROR_G(x)     \\\n\t(((x) >> TLSRX_HDR_PKT_SPP_ERROR_S) & TLSRX_HDR_PKT_SPP_ERROR_M)\n#define TLSRX_HDR_PKT_SPP_ERROR_F        TLSRX_HDR_PKT_SPP_ERROR_V(1U)\n\n#define TLSRX_HDR_PKT_CCDX_ERROR_S       2\n#define TLSRX_HDR_PKT_CCDX_ERROR_M       0x1\n#define TLSRX_HDR_PKT_CCDX_ERROR_V(x)    ((x) << TLSRX_HDR_PKT_CCDX_ERROR_S)\n#define TLSRX_HDR_PKT_CCDX_ERROR_G(x)    \\\n\t(((x) >> TLSRX_HDR_PKT_CCDX_ERROR_S) & TLSRX_HDR_PKT_CCDX_ERROR_M)\n#define TLSRX_HDR_PKT_CCDX_ERROR_F       TLSRX_HDR_PKT_CCDX_ERROR_V(1U)\n\n#define TLSRX_HDR_PKT_PAD_ERROR_S        1\n#define TLSRX_HDR_PKT_PAD_ERROR_M        0x1\n#define TLSRX_HDR_PKT_PAD_ERROR_V(x)     ((x) << TLSRX_HDR_PKT_PAD_ERROR_S)\n#define TLSRX_HDR_PKT_PAD_ERROR_G(x)     \\\n\t(((x) >> TLSRX_HDR_PKT_PAD_ERROR_S) & TLSRX_HDR_PKT_PAD_ERROR_M)\n#define TLSRX_HDR_PKT_PAD_ERROR_F        TLSRX_HDR_PKT_PAD_ERROR_V(1U)\n\n#define TLSRX_HDR_PKT_MAC_ERROR_S        0\n#define TLSRX_HDR_PKT_MAC_ERROR_M        0x1\n#define TLSRX_HDR_PKT_MAC_ERROR_V(x)     ((x) << TLSRX_HDR_PKT_MAC_ERROR)\n#define TLSRX_HDR_PKT_MAC_ERROR_G(x)     \\\n\t(((x) >> S_TLSRX_HDR_PKT_MAC_ERROR_S) & TLSRX_HDR_PKT_MAC_ERROR_M)\n#define TLSRX_HDR_PKT_MAC_ERROR_F        TLSRX_HDR_PKT_MAC_ERROR_V(1U)\n\n#define TLSRX_HDR_PKT_ERROR_M           0x1F\n#define CONTENT_TYPE_ERROR\t\t0x7F\n\nstruct ulp_mem_rw {\n\t__be32 cmd;\n\t__be32 len16;              \n\t__be32 dlen;               \n\t__be32 lock_addr;\n};\n\nstruct tls_key_wr {\n\t__be32 op_to_compl;\n\t__be32 flowid_len16;\n\t__be32 ftid;\n\tu8   reneg_to_write_rx;\n\tu8   protocol;\n\t__be16 mfs;\n};\n\nstruct tls_key_req {\n\tstruct tls_key_wr wr;\n\tstruct ulp_mem_rw req;\n\tstruct ulptx_idata sc_imm;\n};\n\n \nstruct wr_skb_cb {\n\tstruct l2t_skb_cb l2t;           \n\tstruct sk_buff *next_wr;         \n};\n\n \nstruct blog_skb_cb {\n\tvoid (*backlog_rcv)(struct sock *sk, struct sk_buff *skb);\n\tstruct chtls_dev *cdev;\n};\n\n \nstruct ulp_skb_cb {\n\tstruct wr_skb_cb wr;\t\t \n\tu16 flags;\t\t\t \n\tu8 psh;\n\tu8 ulp_mode;\t\t\t \n\tu32 seq;\t\t\t \n\tunion {  \n\t\tstruct {\n\t\t\tu8  type;\n\t\t\tu8  ofld;\n\t\t\tu8  iv;\n\t\t} tls;\n\t} ulp;\n};\n\n#define ULP_SKB_CB(skb) ((struct ulp_skb_cb *)&((skb)->cb[0]))\n#define BLOG_SKB_CB(skb) ((struct blog_skb_cb *)(skb)->cb)\n\n \nenum {\n\tULPCB_FLAG_NEED_HDR  = 1 << 0,\t \n\tULPCB_FLAG_NO_APPEND = 1 << 1,\t \n\tULPCB_FLAG_BARRIER   = 1 << 2,\t \n\tULPCB_FLAG_HOLD      = 1 << 3,\t \n\tULPCB_FLAG_COMPL     = 1 << 4,\t \n\tULPCB_FLAG_URG       = 1 << 5,\t \n\tULPCB_FLAG_TLS_HDR   = 1 << 6,   \n\tULPCB_FLAG_NO_HDR    = 1 << 7,   \n};\n\n \n#define skb_ulp_mode(skb)  (ULP_SKB_CB(skb)->ulp_mode)\n#define TCP_PAGE(sk)   (sk->sk_frag.page)\n#define TCP_OFF(sk)    (sk->sk_frag.offset)\n\nstatic inline struct chtls_dev *to_chtls_dev(struct tls_toe_device *tlsdev)\n{\n\treturn container_of(tlsdev, struct chtls_dev, tlsdev);\n}\n\nstatic inline void csk_set_flag(struct chtls_sock *csk,\n\t\t\t\tenum csk_flags flag)\n{\n\t__set_bit(flag, &csk->flags);\n}\n\nstatic inline void csk_reset_flag(struct chtls_sock *csk,\n\t\t\t\t  enum csk_flags flag)\n{\n\t__clear_bit(flag, &csk->flags);\n}\n\nstatic inline bool csk_conn_inline(const struct chtls_sock *csk)\n{\n\treturn test_bit(CSK_CONN_INLINE, &csk->flags);\n}\n\nstatic inline int csk_flag(const struct sock *sk, enum csk_flags flag)\n{\n\tstruct chtls_sock *csk = rcu_dereference_sk_user_data(sk);\n\n\tif (!csk_conn_inline(csk))\n\t\treturn 0;\n\treturn test_bit(flag, &csk->flags);\n}\n\nstatic inline int csk_flag_nochk(const struct chtls_sock *csk,\n\t\t\t\t enum csk_flags flag)\n{\n\treturn test_bit(flag, &csk->flags);\n}\n\nstatic inline void *cplhdr(struct sk_buff *skb)\n{\n\treturn skb->data;\n}\n\nstatic inline int is_neg_adv(unsigned int status)\n{\n\treturn status == CPL_ERR_RTX_NEG_ADVICE ||\n\t       status == CPL_ERR_KEEPALV_NEG_ADVICE ||\n\t       status == CPL_ERR_PERSIST_NEG_ADVICE;\n}\n\nstatic inline void process_cpl_msg(void (*fn)(struct sock *, struct sk_buff *),\n\t\t\t\t   struct sock *sk,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tskb_reset_transport_header(skb);\n\n\tbh_lock_sock(sk);\n\tif (unlikely(sock_owned_by_user(sk))) {\n\t\tBLOG_SKB_CB(skb)->backlog_rcv = fn;\n\t\t__sk_add_backlog(sk, skb);\n\t} else {\n\t\tfn(sk, skb);\n\t}\n\tbh_unlock_sock(sk);\n}\n\nstatic inline void chtls_sock_free(struct kref *ref)\n{\n\tstruct chtls_sock *csk = container_of(ref, struct chtls_sock,\n\t\t\t\t\t      kref);\n\tkfree(csk);\n}\n\nstatic inline void __chtls_sock_put(const char *fn, struct chtls_sock *csk)\n{\n\tkref_put(&csk->kref, chtls_sock_free);\n}\n\nstatic inline void __chtls_sock_get(const char *fn,\n\t\t\t\t    struct chtls_sock *csk)\n{\n\tkref_get(&csk->kref);\n}\n\nstatic inline void send_or_defer(struct sock *sk, struct tcp_sock *tp,\n\t\t\t\t struct sk_buff *skb, int through_l2t)\n{\n\tstruct chtls_sock *csk = rcu_dereference_sk_user_data(sk);\n\n\tif (through_l2t) {\n\t\t \n\t\tcxgb4_l2t_send(csk->egress_dev, skb, csk->l2t_entry);\n\t} else {\n\t\t \n\t\tcxgb4_ofld_send(csk->egress_dev, skb);\n\t}\n}\n\ntypedef int (*chtls_handler_func)(struct chtls_dev *, struct sk_buff *);\nextern chtls_handler_func chtls_handlers[NUM_CPL_CMDS];\nvoid chtls_install_cpl_ops(struct sock *sk);\nint chtls_init_kmap(struct chtls_dev *cdev, struct cxgb4_lld_info *lldi);\nvoid chtls_listen_stop(struct chtls_dev *cdev, struct sock *sk);\nint chtls_listen_start(struct chtls_dev *cdev, struct sock *sk);\nvoid chtls_close(struct sock *sk, long timeout);\nint chtls_disconnect(struct sock *sk, int flags);\nvoid chtls_shutdown(struct sock *sk, int how);\nvoid chtls_destroy_sock(struct sock *sk);\nint chtls_sendmsg(struct sock *sk, struct msghdr *msg, size_t size);\nint chtls_recvmsg(struct sock *sk, struct msghdr *msg,\n\t\t  size_t len, int flags, int *addr_len);\nvoid chtls_splice_eof(struct socket *sock);\nint send_tx_flowc_wr(struct sock *sk, int compl,\n\t\t     u32 snd_nxt, u32 rcv_nxt);\nvoid chtls_tcp_push(struct sock *sk, int flags);\nint chtls_push_frames(struct chtls_sock *csk, int comp);\nint chtls_set_tcb_tflag(struct sock *sk, unsigned int bit_pos, int val);\nvoid chtls_set_tcb_field_rpl_skb(struct sock *sk, u16 word,\n\t\t\t\t u64 mask, u64 val, u8 cookie,\n\t\t\t\t int through_l2t);\nint chtls_setkey(struct chtls_sock *csk, u32 keylen, u32 mode, int cipher_type);\nvoid chtls_set_quiesce_ctrl(struct sock *sk, int val);\nvoid skb_entail(struct sock *sk, struct sk_buff *skb, int flags);\nunsigned int keyid_to_addr(int start_addr, int keyid);\nvoid free_tls_keyid(struct sock *sk);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}