{
  "module_name": "yellowfin.c",
  "hash_id": "729e6cb6c47bfec47d9f74aa1616f20c55233130120e18926f58d1567c56a75d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/packetengines/yellowfin.c",
  "human_readable_source": " \n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DRV_NAME\t\"yellowfin\"\n#define DRV_VERSION\t\"2.1\"\n#define DRV_RELDATE\t\"Sep 11, 2006\"\n\n \n\nstatic int debug = 1;\t\t\t \n \nstatic int max_interrupt_work = 20;\nstatic int mtu;\n#ifdef YF_PROTOTYPE\t\t\t \n \nstatic int bogus_rx;\nstatic int dma_ctrl = 0x004A0263; \t\t\t \nstatic int fifo_cfg = 0x0020;\t\t\t\t \n#elif defined(YF_NEW)\t\t\t\t\t \nstatic int dma_ctrl = 0x00CAC277;\t\t\t \nstatic int fifo_cfg = 0x0028;\n#else\nstatic const int dma_ctrl = 0x004A0263; \t\t\t \nstatic const int fifo_cfg = 0x0020;\t\t\t\t \n#endif\n\n \nstatic int rx_copybreak;\n\n \n#define MAX_UNITS 8\t\t\t\t \nstatic int options[MAX_UNITS] = {-1, -1, -1, -1, -1, -1, -1, -1};\nstatic int full_duplex[MAX_UNITS] = {-1, -1, -1, -1, -1, -1, -1, -1};\n\n \nstatic int gx_fix;\n\n \n\n \n#define TX_RING_SIZE\t16\n#define TX_QUEUE_SIZE\t12\t\t \n#define RX_RING_SIZE\t64\n#define STATUS_TOTAL_SIZE\tTX_RING_SIZE*sizeof(struct tx_status_words)\n#define TX_TOTAL_SIZE\t\t2*TX_RING_SIZE*sizeof(struct yellowfin_desc)\n#define RX_TOTAL_SIZE\t\tRX_RING_SIZE*sizeof(struct yellowfin_desc)\n\n \n \n#define TX_TIMEOUT  (2*HZ)\n#define PKT_BUF_SZ\t\t1536\t\t\t \n\n#define yellowfin_debug debug\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/mii.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/ethtool.h>\n#include <linux/crc32.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <asm/processor.h>\t\t \n#include <asm/unaligned.h>\n#include <asm/io.h>\n\n \nstatic const char version[] =\n  KERN_INFO DRV_NAME \".c:v1.05  1/09/2001  Written by Donald Becker <becker@scyld.com>\\n\"\n  \"  (unofficial 2.4.x port, \" DRV_VERSION \", \" DRV_RELDATE \")\\n\";\n\nMODULE_AUTHOR(\"Donald Becker <becker@scyld.com>\");\nMODULE_DESCRIPTION(\"Packet Engines Yellowfin G-NIC Gigabit Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(max_interrupt_work, int, 0);\nmodule_param(mtu, int, 0);\nmodule_param(debug, int, 0);\nmodule_param(rx_copybreak, int, 0);\nmodule_param_array(options, int, NULL, 0);\nmodule_param_array(full_duplex, int, NULL, 0);\nmodule_param(gx_fix, int, 0);\nMODULE_PARM_DESC(max_interrupt_work, \"G-NIC maximum events handled per interrupt\");\nMODULE_PARM_DESC(mtu, \"G-NIC MTU (all boards)\");\nMODULE_PARM_DESC(debug, \"G-NIC debug level (0-7)\");\nMODULE_PARM_DESC(rx_copybreak, \"G-NIC copy breakpoint for copy-only-tiny-frames\");\nMODULE_PARM_DESC(options, \"G-NIC: Bits 0-3: media type, bit 17: full duplex\");\nMODULE_PARM_DESC(full_duplex, \"G-NIC full duplex setting(s) (1)\");\nMODULE_PARM_DESC(gx_fix, \"G-NIC: enable GX server chipset bug workaround (0-1)\");\n\n \n\n\n\nenum capability_flags {\n\tHasMII=1, FullTxStatus=2, IsGigabit=4, HasMulticastBug=8, FullRxStatus=16,\n\tHasMACAddrBug=32,  \n\tDontUseEeprom=64,  \n};\n\n \nenum {\n\tYELLOWFIN_SIZE\t= 0x100,\n};\n\nstruct pci_id_info {\n        const char *name;\n        struct match_info {\n                int     pci, pci_mask, subsystem, subsystem_mask;\n                int revision, revision_mask;                             \n        } id;\n        int drv_flags;                           \n};\n\nstatic const struct pci_id_info pci_id_tbl[] = {\n\t{\"Yellowfin G-NIC Gigabit Ethernet\", { 0x07021000, 0xffffffff},\n\t FullTxStatus | IsGigabit | HasMulticastBug | HasMACAddrBug | DontUseEeprom},\n\t{\"Symbios SYM83C885\", { 0x07011000, 0xffffffff},\n\t  HasMII | DontUseEeprom },\n\t{ }\n};\n\nstatic const struct pci_device_id yellowfin_pci_tbl[] = {\n\t{ 0x1000, 0x0702, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ 0x1000, 0x0701, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1 },\n\t{ }\n};\nMODULE_DEVICE_TABLE (pci, yellowfin_pci_tbl);\n\n\n \nenum yellowfin_offsets {\n\tTxCtrl=0x00, TxStatus=0x04, TxPtr=0x0C,\n\tTxIntrSel=0x10, TxBranchSel=0x14, TxWaitSel=0x18,\n\tRxCtrl=0x40, RxStatus=0x44, RxPtr=0x4C,\n\tRxIntrSel=0x50, RxBranchSel=0x54, RxWaitSel=0x58,\n\tEventStatus=0x80, IntrEnb=0x82, IntrClear=0x84, IntrStatus=0x86,\n\tChipRev=0x8C, DMACtrl=0x90, TxThreshold=0x94,\n\tCnfg=0xA0, FrameGap0=0xA2, FrameGap1=0xA4,\n\tMII_Cmd=0xA6, MII_Addr=0xA8, MII_Wr_Data=0xAA, MII_Rd_Data=0xAC,\n\tMII_Status=0xAE,\n\tRxDepth=0xB8, FlowCtrl=0xBC,\n\tAddrMode=0xD0, StnAddr=0xD2, HashTbl=0xD8, FIFOcfg=0xF8,\n\tEEStatus=0xF0, EECtrl=0xF1, EEAddr=0xF2, EERead=0xF3, EEWrite=0xF4,\n\tEEFeature=0xF5,\n};\n\n \nstruct yellowfin_desc {\n\t__le32 dbdma_cmd;\n\t__le32 addr;\n\t__le32 branch_addr;\n\t__le32 result_status;\n};\n\nstruct tx_status_words {\n#ifdef __BIG_ENDIAN\n\tu16 tx_errs;\n\tu16 tx_cnt;\n\tu16 paused;\n\tu16 total_tx_cnt;\n#else   \n\tu16 tx_cnt;\n\tu16 tx_errs;\n\tu16 total_tx_cnt;\n\tu16 paused;\n#endif  \n};\n\n \nenum desc_cmd_bits {\n\tCMD_TX_PKT=0x10000000, CMD_RX_BUF=0x20000000, CMD_TXSTATUS=0x30000000,\n\tCMD_NOP=0x60000000, CMD_STOP=0x70000000,\n\tBRANCH_ALWAYS=0x0C0000, INTR_ALWAYS=0x300000, WAIT_ALWAYS=0x030000,\n\tBRANCH_IFTRUE=0x040000,\n};\n\n \nenum desc_status_bits { RX_EOP=0x0040, };\n\n \nenum intr_status_bits {\n\tIntrRxDone=0x01, IntrRxInvalid=0x02, IntrRxPCIFault=0x04,IntrRxPCIErr=0x08,\n\tIntrTxDone=0x10, IntrTxInvalid=0x20, IntrTxPCIFault=0x40,IntrTxPCIErr=0x80,\n\tIntrEarlyRx=0x100, IntrWakeup=0x200, };\n\n#define PRIV_ALIGN\t31 \t \n#define MII_CNT\t\t4\nstruct yellowfin_private {\n\t \n\tstruct yellowfin_desc *rx_ring;\n\tstruct yellowfin_desc *tx_ring;\n\tstruct sk_buff* rx_skbuff[RX_RING_SIZE];\n\tstruct sk_buff* tx_skbuff[TX_RING_SIZE];\n\tdma_addr_t rx_ring_dma;\n\tdma_addr_t tx_ring_dma;\n\n\tstruct tx_status_words *tx_status;\n\tdma_addr_t tx_status_dma;\n\n\tstruct timer_list timer;\t \n\t \n\tint chip_id, drv_flags;\n\tstruct pci_dev *pci_dev;\n\tunsigned int cur_rx, dirty_rx;\t\t \n\tunsigned int rx_buf_sz;\t\t\t\t \n\tstruct tx_status_words *tx_tail_desc;\n\tunsigned int cur_tx, dirty_tx;\n\tint tx_threshold;\n\tunsigned int tx_full:1;\t\t\t\t \n\tunsigned int full_duplex:1;\t\t\t \n\tunsigned int duplex_lock:1;\n\tunsigned int medialock:1;\t\t\t \n\tunsigned int default_port:4;\t\t \n\t \n\tint mii_cnt;\t\t\t\t\t\t \n\tu16 advertising;\t\t\t\t\t \n\tunsigned char phys[MII_CNT];\t\t \n\tspinlock_t lock;\n\tvoid __iomem *base;\n};\n\nstatic int read_eeprom(void __iomem *ioaddr, int location);\nstatic int mdio_read(void __iomem *ioaddr, int phy_id, int location);\nstatic void mdio_write(void __iomem *ioaddr, int phy_id, int location, int value);\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic int yellowfin_open(struct net_device *dev);\nstatic void yellowfin_timer(struct timer_list *t);\nstatic void yellowfin_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic int yellowfin_init_ring(struct net_device *dev);\nstatic netdev_tx_t yellowfin_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev);\nstatic irqreturn_t yellowfin_interrupt(int irq, void *dev_instance);\nstatic int yellowfin_rx(struct net_device *dev);\nstatic void yellowfin_error(struct net_device *dev, int intr_status);\nstatic int yellowfin_close(struct net_device *dev);\nstatic void set_rx_mode(struct net_device *dev);\nstatic const struct ethtool_ops ethtool_ops;\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open \t\t= yellowfin_open,\n\t.ndo_stop \t\t= yellowfin_close,\n\t.ndo_start_xmit \t= yellowfin_start_xmit,\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_eth_ioctl\t\t= netdev_ioctl,\n\t.ndo_tx_timeout \t= yellowfin_tx_timeout,\n};\n\nstatic int yellowfin_init_one(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct yellowfin_private *np;\n\tint irq;\n\tint chip_idx = ent->driver_data;\n\tstatic int find_cnt;\n\tvoid __iomem *ioaddr;\n\tint i, option = find_cnt < MAX_UNITS ? options[find_cnt] : 0;\n\tint drv_flags = pci_id_tbl[chip_idx].drv_flags;\n        void *ring_space;\n        dma_addr_t ring_dma;\n#ifdef USE_IO_OPS\n\tint bar = 0;\n#else\n\tint bar = 1;\n#endif\n\tu8 addr[ETH_ALEN];\n\n \n#ifndef MODULE\n\tstatic int printed_version;\n\tif (!printed_version++)\n\t\tprintk(version);\n#endif\n\n\ti = pci_enable_device(pdev);\n\tif (i) return i;\n\n\tdev = alloc_etherdev(sizeof(*np));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tnp = netdev_priv(dev);\n\n\tif (pci_request_regions(pdev, DRV_NAME))\n\t\tgoto err_out_free_netdev;\n\n\tpci_set_master (pdev);\n\n\tioaddr = pci_iomap(pdev, bar, YELLOWFIN_SIZE);\n\tif (!ioaddr)\n\t\tgoto err_out_free_res;\n\n\tirq = pdev->irq;\n\n\tif (drv_flags & DontUseEeprom)\n\t\tfor (i = 0; i < 6; i++)\n\t\t\taddr[i] = ioread8(ioaddr + StnAddr + i);\n\telse {\n\t\tint ee_offset = (read_eeprom(ioaddr, 6) == 0xff ? 0x100 : 0);\n\t\tfor (i = 0; i < 6; i++)\n\t\t\taddr[i] = read_eeprom(ioaddr, ee_offset + i);\n\t}\n\teth_hw_addr_set(dev, addr);\n\n\t \n\tiowrite32(0x80000000, ioaddr + DMACtrl);\n\n\tpci_set_drvdata(pdev, dev);\n\tspin_lock_init(&np->lock);\n\n\tnp->pci_dev = pdev;\n\tnp->chip_id = chip_idx;\n\tnp->drv_flags = drv_flags;\n\tnp->base = ioaddr;\n\n\tring_space = dma_alloc_coherent(&pdev->dev, TX_TOTAL_SIZE, &ring_dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ring_space)\n\t\tgoto err_out_cleardev;\n\tnp->tx_ring = ring_space;\n\tnp->tx_ring_dma = ring_dma;\n\n\tring_space = dma_alloc_coherent(&pdev->dev, RX_TOTAL_SIZE, &ring_dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ring_space)\n\t\tgoto err_out_unmap_tx;\n\tnp->rx_ring = ring_space;\n\tnp->rx_ring_dma = ring_dma;\n\n\tring_space = dma_alloc_coherent(&pdev->dev, STATUS_TOTAL_SIZE,\n\t\t\t\t\t&ring_dma, GFP_KERNEL);\n\tif (!ring_space)\n\t\tgoto err_out_unmap_rx;\n\tnp->tx_status = ring_space;\n\tnp->tx_status_dma = ring_dma;\n\n\tif (dev->mem_start)\n\t\toption = dev->mem_start;\n\n\t \n\tif (option > 0) {\n\t\tif (option & 0x200)\n\t\t\tnp->full_duplex = 1;\n\t\tnp->default_port = option & 15;\n\t\tif (np->default_port)\n\t\t\tnp->medialock = 1;\n\t}\n\tif (find_cnt < MAX_UNITS  &&  full_duplex[find_cnt] > 0)\n\t\tnp->full_duplex = 1;\n\n\tif (np->full_duplex)\n\t\tnp->duplex_lock = 1;\n\n\t \n\tdev->netdev_ops = &netdev_ops;\n\tdev->ethtool_ops = &ethtool_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\tif (mtu)\n\t\tdev->mtu = mtu;\n\n\ti = register_netdev(dev);\n\tif (i)\n\t\tgoto err_out_unmap_status;\n\n\tnetdev_info(dev, \"%s type %8x at %p, %pM, IRQ %d\\n\",\n\t\t    pci_id_tbl[chip_idx].name,\n\t\t    ioread32(ioaddr + ChipRev), ioaddr,\n\t\t    dev->dev_addr, irq);\n\n\tif (np->drv_flags & HasMII) {\n\t\tint phy, phy_idx = 0;\n\t\tfor (phy = 0; phy < 32 && phy_idx < MII_CNT; phy++) {\n\t\t\tint mii_status = mdio_read(ioaddr, phy, 1);\n\t\t\tif (mii_status != 0xffff  &&  mii_status != 0x0000) {\n\t\t\t\tnp->phys[phy_idx++] = phy;\n\t\t\t\tnp->advertising = mdio_read(ioaddr, phy, 4);\n\t\t\t\tnetdev_info(dev, \"MII PHY found at address %d, status 0x%04x advertising %04x\\n\",\n\t\t\t\t\t    phy, mii_status, np->advertising);\n\t\t\t}\n\t\t}\n\t\tnp->mii_cnt = phy_idx;\n\t}\n\n\tfind_cnt++;\n\n\treturn 0;\n\nerr_out_unmap_status:\n\tdma_free_coherent(&pdev->dev, STATUS_TOTAL_SIZE, np->tx_status,\n\t\t\t  np->tx_status_dma);\nerr_out_unmap_rx:\n\tdma_free_coherent(&pdev->dev, RX_TOTAL_SIZE, np->rx_ring,\n\t\t\t  np->rx_ring_dma);\nerr_out_unmap_tx:\n\tdma_free_coherent(&pdev->dev, TX_TOTAL_SIZE, np->tx_ring,\n\t\t\t  np->tx_ring_dma);\nerr_out_cleardev:\n\tpci_iounmap(pdev, ioaddr);\nerr_out_free_res:\n\tpci_release_regions(pdev);\nerr_out_free_netdev:\n\tfree_netdev (dev);\n\treturn -ENODEV;\n}\n\nstatic int read_eeprom(void __iomem *ioaddr, int location)\n{\n\tint bogus_cnt = 10000;\t\t \n\n\tiowrite8(location, ioaddr + EEAddr);\n\tiowrite8(0x30 | ((location >> 8) & 7), ioaddr + EECtrl);\n\twhile ((ioread8(ioaddr + EEStatus) & 0x80)  &&  --bogus_cnt > 0)\n\t\t;\n\treturn ioread8(ioaddr + EERead);\n}\n\n \n\nstatic int mdio_read(void __iomem *ioaddr, int phy_id, int location)\n{\n\tint i;\n\n\tiowrite16((phy_id<<8) + location, ioaddr + MII_Addr);\n\tiowrite16(1, ioaddr + MII_Cmd);\n\tfor (i = 10000; i >= 0; i--)\n\t\tif ((ioread16(ioaddr + MII_Status) & 1) == 0)\n\t\t\tbreak;\n\treturn ioread16(ioaddr + MII_Rd_Data);\n}\n\nstatic void mdio_write(void __iomem *ioaddr, int phy_id, int location, int value)\n{\n\tint i;\n\n\tiowrite16((phy_id<<8) + location, ioaddr + MII_Addr);\n\tiowrite16(value, ioaddr + MII_Wr_Data);\n\n\t \n\tfor (i = 10000; i >= 0; i--)\n\t\tif ((ioread16(ioaddr + MII_Status) & 1) == 0)\n\t\t\tbreak;\n}\n\n\nstatic int yellowfin_open(struct net_device *dev)\n{\n\tstruct yellowfin_private *yp = netdev_priv(dev);\n\tconst int irq = yp->pci_dev->irq;\n\tvoid __iomem *ioaddr = yp->base;\n\tint i, rc;\n\n\t \n\tiowrite32(0x80000000, ioaddr + DMACtrl);\n\n\trc = request_irq(irq, yellowfin_interrupt, IRQF_SHARED, dev->name, dev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = yellowfin_init_ring(dev);\n\tif (rc < 0)\n\t\tgoto err_free_irq;\n\n\tiowrite32(yp->rx_ring_dma, ioaddr + RxPtr);\n\tiowrite32(yp->tx_ring_dma, ioaddr + TxPtr);\n\n\tfor (i = 0; i < 6; i++)\n\t\tiowrite8(dev->dev_addr[i], ioaddr + StnAddr + i);\n\n\t \n\tiowrite32(0x00800080, ioaddr + TxIntrSel); \t \n\tiowrite32(0x00800080, ioaddr + TxBranchSel);\t \n\tiowrite32(0x00400040, ioaddr + TxWaitSel); \t \n\tiowrite32(0x00400040, ioaddr + RxIntrSel);\t \n\tiowrite32(0x00400040, ioaddr + RxBranchSel);\t \n\tiowrite32(0x00400040, ioaddr + RxWaitSel);\t \n\n\t \n\tiowrite32(dma_ctrl, ioaddr + DMACtrl);\n\tiowrite16(fifo_cfg, ioaddr + FIFOcfg);\n\t \n\tiowrite32(0x0030FFFF, ioaddr + FlowCtrl);\n\n\typ->tx_threshold = 32;\n\tiowrite32(yp->tx_threshold, ioaddr + TxThreshold);\n\n\tif (dev->if_port == 0)\n\t\tdev->if_port = yp->default_port;\n\n\tnetif_start_queue(dev);\n\n\t \n\tif (yp->drv_flags & IsGigabit) {\n\t\t \n\t\typ->full_duplex = 1;\n\t\tiowrite16(0x01CF, ioaddr + Cnfg);\n\t} else {\n\t\tiowrite16(0x0018, ioaddr + FrameGap0);  \n\t\tiowrite16(0x1018, ioaddr + FrameGap1);\n\t\tiowrite16(0x101C | (yp->full_duplex ? 2 : 0), ioaddr + Cnfg);\n\t}\n\tset_rx_mode(dev);\n\n\t \n\tiowrite16(0x81ff, ioaddr + IntrEnb);\t\t\t \n\tiowrite16(0x0000, ioaddr + EventStatus);\t\t \n\tiowrite32(0x80008000, ioaddr + RxCtrl);\t\t \n\tiowrite32(0x80008000, ioaddr + TxCtrl);\n\n\tif (yellowfin_debug > 2) {\n\t\tnetdev_printk(KERN_DEBUG, dev, \"Done %s()\\n\", __func__);\n\t}\n\n\t \n\ttimer_setup(&yp->timer, yellowfin_timer, 0);\n\typ->timer.expires = jiffies + 3*HZ;\n\tadd_timer(&yp->timer);\nout:\n\treturn rc;\n\nerr_free_irq:\n\tfree_irq(irq, dev);\n\tgoto out;\n}\n\nstatic void yellowfin_timer(struct timer_list *t)\n{\n\tstruct yellowfin_private *yp = from_timer(yp, t, timer);\n\tstruct net_device *dev = pci_get_drvdata(yp->pci_dev);\n\tvoid __iomem *ioaddr = yp->base;\n\tint next_tick = 60*HZ;\n\n\tif (yellowfin_debug > 3) {\n\t\tnetdev_printk(KERN_DEBUG, dev, \"Yellowfin timer tick, status %08x\\n\",\n\t\t\t      ioread16(ioaddr + IntrStatus));\n\t}\n\n\tif (yp->mii_cnt) {\n\t\tint bmsr = mdio_read(ioaddr, yp->phys[0], MII_BMSR);\n\t\tint lpa = mdio_read(ioaddr, yp->phys[0], MII_LPA);\n\t\tint negotiated = lpa & yp->advertising;\n\t\tif (yellowfin_debug > 1)\n\t\t\tnetdev_printk(KERN_DEBUG, dev, \"MII #%d status register is %04x, link partner capability %04x\\n\",\n\t\t\t\t      yp->phys[0], bmsr, lpa);\n\n\t\typ->full_duplex = mii_duplex(yp->duplex_lock, negotiated);\n\n\t\tiowrite16(0x101C | (yp->full_duplex ? 2 : 0), ioaddr + Cnfg);\n\n\t\tif (bmsr & BMSR_LSTATUS)\n\t\t\tnext_tick = 60*HZ;\n\t\telse\n\t\t\tnext_tick = 3*HZ;\n\t}\n\n\typ->timer.expires = jiffies + next_tick;\n\tadd_timer(&yp->timer);\n}\n\nstatic void yellowfin_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct yellowfin_private *yp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = yp->base;\n\n\tnetdev_warn(dev, \"Yellowfin transmit timed out at %d/%d Tx status %04x, Rx status %04x, resetting...\\n\",\n\t\t    yp->cur_tx, yp->dirty_tx,\n\t\t    ioread32(ioaddr + TxStatus),\n\t\t    ioread32(ioaddr + RxStatus));\n\n\t \n\tif (yellowfin_debug) {\n\t\tint i;\n\t\tpr_warn(\"  Rx ring %p: \", yp->rx_ring);\n\t\tfor (i = 0; i < RX_RING_SIZE; i++)\n\t\t\tpr_cont(\" %08x\", yp->rx_ring[i].result_status);\n\t\tpr_cont(\"\\n\");\n\t\tpr_warn(\"  Tx ring %p: \", yp->tx_ring);\n\t\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\t\tpr_cont(\" %04x /%08x\",\n\t\t\t       yp->tx_status[i].tx_errs,\n\t\t\t       yp->tx_ring[i].result_status);\n\t\tpr_cont(\"\\n\");\n\t}\n\n\t \n\tdev->if_port = 0;\n\n\t \n\tiowrite32(0x10001000, yp->base + TxCtrl);\n\tif (yp->cur_tx - yp->dirty_tx < TX_QUEUE_SIZE)\n\t\tnetif_wake_queue (dev);\t\t \n\n\tnetif_trans_update(dev);  \n\tdev->stats.tx_errors++;\n}\n\n \nstatic int yellowfin_init_ring(struct net_device *dev)\n{\n\tstruct yellowfin_private *yp = netdev_priv(dev);\n\tint i, j;\n\n\typ->tx_full = 0;\n\typ->cur_rx = yp->cur_tx = 0;\n\typ->dirty_tx = 0;\n\n\typ->rx_buf_sz = (dev->mtu <= 1500 ? PKT_BUF_SZ : dev->mtu + 32);\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\typ->rx_ring[i].dbdma_cmd =\n\t\t\tcpu_to_le32(CMD_RX_BUF | INTR_ALWAYS | yp->rx_buf_sz);\n\t\typ->rx_ring[i].branch_addr = cpu_to_le32(yp->rx_ring_dma +\n\t\t\t((i+1)%RX_RING_SIZE)*sizeof(struct yellowfin_desc));\n\t}\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, yp->rx_buf_sz + 2);\n\t\typ->rx_skbuff[i] = skb;\n\t\tif (skb == NULL)\n\t\t\tbreak;\n\t\tskb_reserve(skb, 2);\t \n\t\typ->rx_ring[i].addr = cpu_to_le32(dma_map_single(&yp->pci_dev->dev,\n\t\t\t\t\t\t\t\t skb->data,\n\t\t\t\t\t\t\t\t yp->rx_buf_sz,\n\t\t\t\t\t\t\t\t DMA_FROM_DEVICE));\n\t}\n\tif (i != RX_RING_SIZE) {\n\t\tfor (j = 0; j < i; j++)\n\t\t\tdev_kfree_skb(yp->rx_skbuff[j]);\n\t\treturn -ENOMEM;\n\t}\n\typ->rx_ring[i-1].dbdma_cmd = cpu_to_le32(CMD_STOP);\n\typ->dirty_rx = (unsigned int)(i - RX_RING_SIZE);\n\n#define NO_TXSTATS\n#ifdef NO_TXSTATS\n\t \n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\typ->tx_skbuff[i] = NULL;\n\t\typ->tx_ring[i].dbdma_cmd = cpu_to_le32(CMD_STOP);\n\t\typ->tx_ring[i].branch_addr = cpu_to_le32(yp->tx_ring_dma +\n\t\t\t((i+1)%TX_RING_SIZE)*sizeof(struct yellowfin_desc));\n\t}\n\t \n\typ->tx_ring[--i].dbdma_cmd = cpu_to_le32(CMD_STOP | BRANCH_ALWAYS);\n#else\n{\n\t \n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tj = 2*i;\n\t\typ->tx_skbuff[i] = 0;\n\t\t \n\t\typ->tx_ring[j].dbdma_cmd = cpu_to_le32(CMD_STOP);\n\t\typ->tx_ring[j].branch_addr = cpu_to_le32(yp->tx_ring_dma +\n\t\t\t(j+1)*sizeof(struct yellowfin_desc));\n\t\tj++;\n\t\tif (yp->flags & FullTxStatus) {\n\t\t\typ->tx_ring[j].dbdma_cmd =\n\t\t\t\tcpu_to_le32(CMD_TXSTATUS | sizeof(*yp->tx_status));\n\t\t\typ->tx_ring[j].request_cnt = sizeof(*yp->tx_status);\n\t\t\typ->tx_ring[j].addr = cpu_to_le32(yp->tx_status_dma +\n\t\t\t\ti*sizeof(struct tx_status_words));\n\t\t} else {\n\t\t\t \n\t\t\typ->tx_ring[j].dbdma_cmd =\n\t\t\t\tcpu_to_le32(CMD_TXSTATUS | INTR_ALWAYS | 2);\n\t\t\typ->tx_ring[j].request_cnt = 2;\n\t\t\t \n\t\t\typ->tx_ring[j].addr = cpu_to_le32(yp->tx_status_dma +\n\t\t\t\ti*sizeof(struct tx_status_words) +\n\t\t\t\t&(yp->tx_status[0].tx_errs) -\n\t\t\t\t&(yp->tx_status[0]));\n\t\t}\n\t\typ->tx_ring[j].branch_addr = cpu_to_le32(yp->tx_ring_dma +\n\t\t\t((j+1)%(2*TX_RING_SIZE))*sizeof(struct yellowfin_desc));\n\t}\n\t \n\typ->tx_ring[++j].dbdma_cmd |= cpu_to_le32(BRANCH_ALWAYS | INTR_ALWAYS);\n}\n#endif\n\typ->tx_tail_desc = &yp->tx_status[0];\n\treturn 0;\n}\n\nstatic netdev_tx_t yellowfin_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tstruct yellowfin_private *yp = netdev_priv(dev);\n\tunsigned entry;\n\tint len = skb->len;\n\n\tnetif_stop_queue (dev);\n\n\t \n\n\t \n\tentry = yp->cur_tx % TX_RING_SIZE;\n\n\tif (gx_fix) {\t \n\t\tint cacheline_end = ((unsigned long)skb->data + skb->len) % 32;\n\t\t \n\t\tif (cacheline_end > 24  || cacheline_end == 0) {\n\t\t\tlen = skb->len + 32 - cacheline_end + 1;\n\t\t\tif (skb_padto(skb, len)) {\n\t\t\t\typ->tx_skbuff[entry] = NULL;\n\t\t\t\tnetif_wake_queue(dev);\n\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t}\n\t\t}\n\t}\n\typ->tx_skbuff[entry] = skb;\n\n#ifdef NO_TXSTATS\n\typ->tx_ring[entry].addr = cpu_to_le32(dma_map_single(&yp->pci_dev->dev,\n\t\t\t\t\t\t\t     skb->data,\n\t\t\t\t\t\t\t     len, DMA_TO_DEVICE));\n\typ->tx_ring[entry].result_status = 0;\n\tif (entry >= TX_RING_SIZE-1) {\n\t\t \n\t\typ->tx_ring[0].dbdma_cmd = cpu_to_le32(CMD_STOP);\n\t\typ->tx_ring[TX_RING_SIZE-1].dbdma_cmd =\n\t\t\tcpu_to_le32(CMD_TX_PKT|BRANCH_ALWAYS | len);\n\t} else {\n\t\typ->tx_ring[entry+1].dbdma_cmd = cpu_to_le32(CMD_STOP);\n\t\typ->tx_ring[entry].dbdma_cmd =\n\t\t\tcpu_to_le32(CMD_TX_PKT | BRANCH_IFTRUE | len);\n\t}\n\typ->cur_tx++;\n#else\n\typ->tx_ring[entry<<1].request_cnt = len;\n\typ->tx_ring[entry<<1].addr = cpu_to_le32(dma_map_single(&yp->pci_dev->dev,\n\t\t\t\t\t\t\t\tskb->data,\n\t\t\t\t\t\t\t\tlen, DMA_TO_DEVICE));\n\t \n\n\typ->cur_tx++;\n\t{\n\t\tunsigned next_entry = yp->cur_tx % TX_RING_SIZE;\n\t\typ->tx_ring[next_entry<<1].dbdma_cmd = cpu_to_le32(CMD_STOP);\n\t}\n\t \n\n\typ->tx_ring[entry<<1].dbdma_cmd =\n\t\tcpu_to_le32( ((entry % 6) == 0 ? CMD_TX_PKT|INTR_ALWAYS|BRANCH_IFTRUE :\n\t\t\t\t\t  CMD_TX_PKT | BRANCH_IFTRUE) | len);\n#endif\n\n\t \n\n\t \n\tiowrite32(0x10001000, yp->base + TxCtrl);\n\n\tif (yp->cur_tx - yp->dirty_tx < TX_QUEUE_SIZE)\n\t\tnetif_start_queue (dev);\t\t \n\telse\n\t\typ->tx_full = 1;\n\n\tif (yellowfin_debug > 4) {\n\t\tnetdev_printk(KERN_DEBUG, dev, \"Yellowfin transmit frame #%d queued in slot %d\\n\",\n\t\t\t      yp->cur_tx, entry);\n\t}\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic irqreturn_t yellowfin_interrupt(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct yellowfin_private *yp;\n\tvoid __iomem *ioaddr;\n\tint boguscnt = max_interrupt_work;\n\tunsigned int handled = 0;\n\n\typ = netdev_priv(dev);\n\tioaddr = yp->base;\n\n\tspin_lock (&yp->lock);\n\n\tdo {\n\t\tu16 intr_status = ioread16(ioaddr + IntrClear);\n\n\t\tif (yellowfin_debug > 4)\n\t\t\tnetdev_printk(KERN_DEBUG, dev, \"Yellowfin interrupt, status %04x\\n\",\n\t\t\t\t      intr_status);\n\n\t\tif (intr_status == 0)\n\t\t\tbreak;\n\t\thandled = 1;\n\n\t\tif (intr_status & (IntrRxDone | IntrEarlyRx)) {\n\t\t\tyellowfin_rx(dev);\n\t\t\tiowrite32(0x10001000, ioaddr + RxCtrl);\t\t \n\t\t}\n\n#ifdef NO_TXSTATS\n\t\tfor (; yp->cur_tx - yp->dirty_tx > 0; yp->dirty_tx++) {\n\t\t\tint entry = yp->dirty_tx % TX_RING_SIZE;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tif (yp->tx_ring[entry].result_status == 0)\n\t\t\t\tbreak;\n\t\t\tskb = yp->tx_skbuff[entry];\n\t\t\tdev->stats.tx_packets++;\n\t\t\tdev->stats.tx_bytes += skb->len;\n\t\t\t \n\t\t\tdma_unmap_single(&yp->pci_dev->dev,\n\t\t\t\t\t le32_to_cpu(yp->tx_ring[entry].addr),\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\tdev_consume_skb_irq(skb);\n\t\t\typ->tx_skbuff[entry] = NULL;\n\t\t}\n\t\tif (yp->tx_full &&\n\t\t    yp->cur_tx - yp->dirty_tx < TX_QUEUE_SIZE - 4) {\n\t\t\t \n\t\t\typ->tx_full = 0;\n\t\t\tnetif_wake_queue(dev);\n\t\t}\n#else\n\t\tif ((intr_status & IntrTxDone) || (yp->tx_tail_desc->tx_errs)) {\n\t\t\tunsigned dirty_tx = yp->dirty_tx;\n\n\t\t\tfor (dirty_tx = yp->dirty_tx; yp->cur_tx - dirty_tx > 0;\n\t\t\t\t dirty_tx++) {\n\t\t\t\t \n\t\t\t\tint entry = dirty_tx % TX_RING_SIZE;\n\t\t\t\tu16 tx_errs = yp->tx_status[entry].tx_errs;\n\t\t\t\tstruct sk_buff *skb;\n\n#ifndef final_version\n\t\t\t\tif (yellowfin_debug > 5)\n\t\t\t\t\tnetdev_printk(KERN_DEBUG, dev, \"Tx queue %d check, Tx status %04x %04x %04x %04x\\n\",\n\t\t\t\t\t\t      entry,\n\t\t\t\t\t\t      yp->tx_status[entry].tx_cnt,\n\t\t\t\t\t\t      yp->tx_status[entry].tx_errs,\n\t\t\t\t\t\t      yp->tx_status[entry].total_tx_cnt,\n\t\t\t\t\t\t      yp->tx_status[entry].paused);\n#endif\n\t\t\t\tif (tx_errs == 0)\n\t\t\t\t\tbreak;\t \n\t\t\t\tskb = yp->tx_skbuff[entry];\n\t\t\t\tif (tx_errs & 0xF810) {\n\t\t\t\t\t \n#ifndef final_version\n\t\t\t\t\tif (yellowfin_debug > 1)\n\t\t\t\t\t\tnetdev_printk(KERN_DEBUG, dev, \"Transmit error, Tx status %04x\\n\",\n\t\t\t\t\t\t\t      tx_errs);\n#endif\n\t\t\t\t\tdev->stats.tx_errors++;\n\t\t\t\t\tif (tx_errs & 0xF800) dev->stats.tx_aborted_errors++;\n\t\t\t\t\tif (tx_errs & 0x0800) dev->stats.tx_carrier_errors++;\n\t\t\t\t\tif (tx_errs & 0x2000) dev->stats.tx_window_errors++;\n\t\t\t\t\tif (tx_errs & 0x8000) dev->stats.tx_fifo_errors++;\n\t\t\t\t} else {\n#ifndef final_version\n\t\t\t\t\tif (yellowfin_debug > 4)\n\t\t\t\t\t\tnetdev_printk(KERN_DEBUG, dev, \"Normal transmit, Tx status %04x\\n\",\n\t\t\t\t\t\t\t      tx_errs);\n#endif\n\t\t\t\t\tdev->stats.tx_bytes += skb->len;\n\t\t\t\t\tdev->stats.collisions += tx_errs & 15;\n\t\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tdma_unmap_single(&yp->pci_dev->dev,\n\t\t\t\t\t\t yp->tx_ring[entry << 1].addr,\n\t\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\t\tdev_consume_skb_irq(skb);\n\t\t\t\typ->tx_skbuff[entry] = 0;\n\t\t\t\t \n\t\t\t\typ->tx_status[entry].tx_errs = 0;\n\t\t\t}\n\n#ifndef final_version\n\t\t\tif (yp->cur_tx - dirty_tx > TX_RING_SIZE) {\n\t\t\t\tnetdev_err(dev, \"Out-of-sync dirty pointer, %d vs. %d, full=%d\\n\",\n\t\t\t\t\t   dirty_tx, yp->cur_tx, yp->tx_full);\n\t\t\t\tdirty_tx += TX_RING_SIZE;\n\t\t\t}\n#endif\n\n\t\t\tif (yp->tx_full &&\n\t\t\t    yp->cur_tx - dirty_tx < TX_QUEUE_SIZE - 2) {\n\t\t\t\t \n\t\t\t\typ->tx_full = 0;\n\t\t\t\tnetif_wake_queue(dev);\n\t\t\t}\n\n\t\t\typ->dirty_tx = dirty_tx;\n\t\t\typ->tx_tail_desc = &yp->tx_status[dirty_tx % TX_RING_SIZE];\n\t\t}\n#endif\n\n\t\t \n\t\tif (intr_status & 0x2ee)\t \n\t\t\tyellowfin_error(dev, intr_status);\n\n\t\tif (--boguscnt < 0) {\n\t\t\tnetdev_warn(dev, \"Too much work at interrupt, status=%#04x\\n\",\n\t\t\t\t    intr_status);\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\tif (yellowfin_debug > 3)\n\t\tnetdev_printk(KERN_DEBUG, dev, \"exiting interrupt, status=%#04x\\n\",\n\t\t\t      ioread16(ioaddr + IntrStatus));\n\n\tspin_unlock (&yp->lock);\n\treturn IRQ_RETVAL(handled);\n}\n\n \nstatic int yellowfin_rx(struct net_device *dev)\n{\n\tstruct yellowfin_private *yp = netdev_priv(dev);\n\tint entry = yp->cur_rx % RX_RING_SIZE;\n\tint boguscnt = yp->dirty_rx + RX_RING_SIZE - yp->cur_rx;\n\n\tif (yellowfin_debug > 4) {\n\t\tprintk(KERN_DEBUG \" In yellowfin_rx(), entry %d status %08x\\n\",\n\t\t\t   entry, yp->rx_ring[entry].result_status);\n\t\tprintk(KERN_DEBUG \"   #%d desc. %08x %08x %08x\\n\",\n\t\t\t   entry, yp->rx_ring[entry].dbdma_cmd, yp->rx_ring[entry].addr,\n\t\t\t   yp->rx_ring[entry].result_status);\n\t}\n\n\t \n\twhile (1) {\n\t\tstruct yellowfin_desc *desc = &yp->rx_ring[entry];\n\t\tstruct sk_buff *rx_skb = yp->rx_skbuff[entry];\n\t\ts16 frame_status;\n\t\tu16 desc_status;\n\t\tint data_size, __maybe_unused yf_size;\n\t\tu8 *buf_addr;\n\n\t\tif(!desc->result_status)\n\t\t\tbreak;\n\t\tdma_sync_single_for_cpu(&yp->pci_dev->dev,\n\t\t\t\t\tle32_to_cpu(desc->addr),\n\t\t\t\t\typ->rx_buf_sz, DMA_FROM_DEVICE);\n\t\tdesc_status = le32_to_cpu(desc->result_status) >> 16;\n\t\tbuf_addr = rx_skb->data;\n\t\tdata_size = (le32_to_cpu(desc->dbdma_cmd) -\n\t\t\tle32_to_cpu(desc->result_status)) & 0xffff;\n\t\tframe_status = get_unaligned_le16(&(buf_addr[data_size - 2]));\n\t\tif (yellowfin_debug > 4)\n\t\t\tprintk(KERN_DEBUG \"  %s() status was %04x\\n\",\n\t\t\t       __func__, frame_status);\n\t\tif (--boguscnt < 0)\n\t\t\tbreak;\n\n\t\tyf_size = sizeof(struct yellowfin_desc);\n\n\t\tif ( ! (desc_status & RX_EOP)) {\n\t\t\tif (data_size != 0)\n\t\t\t\tnetdev_warn(dev, \"Oversized Ethernet frame spanned multiple buffers, status %04x, data_size %d!\\n\",\n\t\t\t\t\t    desc_status, data_size);\n\t\t\tdev->stats.rx_length_errors++;\n\t\t} else if ((yp->drv_flags & IsGigabit)  &&  (frame_status & 0x0038)) {\n\t\t\t \n\t\t\tif (yellowfin_debug > 3)\n\t\t\t\tprintk(KERN_DEBUG \"  %s() Rx error was %04x\\n\",\n\t\t\t\t       __func__, frame_status);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (frame_status & 0x0060) dev->stats.rx_length_errors++;\n\t\t\tif (frame_status & 0x0008) dev->stats.rx_frame_errors++;\n\t\t\tif (frame_status & 0x0010) dev->stats.rx_crc_errors++;\n\t\t\tif (frame_status < 0) dev->stats.rx_dropped++;\n\t\t} else if ( !(yp->drv_flags & IsGigabit)  &&\n\t\t\t\t   ((buf_addr[data_size-1] & 0x85) || buf_addr[data_size-2] & 0xC0)) {\n\t\t\tu8 status1 = buf_addr[data_size-2];\n\t\t\tu8 status2 = buf_addr[data_size-1];\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (status1 & 0xC0) dev->stats.rx_length_errors++;\n\t\t\tif (status2 & 0x03) dev->stats.rx_frame_errors++;\n\t\t\tif (status2 & 0x04) dev->stats.rx_crc_errors++;\n\t\t\tif (status2 & 0x80) dev->stats.rx_dropped++;\n#ifdef YF_PROTOTYPE\t\t \n\t\t} else if ((yp->flags & HasMACAddrBug)  &&\n\t\t\t!ether_addr_equal(le32_to_cpu(yp->rx_ring_dma +\n\t\t\t\t\t\t      entry * yf_size),\n\t\t\t\t\t  dev->dev_addr) &&\n\t\t\t!ether_addr_equal(le32_to_cpu(yp->rx_ring_dma +\n\t\t\t\t\t\t      entry * yf_size),\n\t\t\t\t\t  \"\\377\\377\\377\\377\\377\\377\")) {\n\t\t\tif (bogus_rx++ == 0)\n\t\t\t\tnetdev_warn(dev, \"Bad frame to %pM\\n\",\n\t\t\t\t\t    buf_addr);\n#endif\n\t\t} else {\n\t\t\tstruct sk_buff *skb;\n\t\t\tint pkt_len = data_size -\n\t\t\t\t(yp->chip_id ? 7 : 8 + buf_addr[data_size - 8]);\n\t\t\t \n\n#ifndef final_version\n\t\t\tif (yellowfin_debug > 4)\n\t\t\t\tprintk(KERN_DEBUG \"  %s() normal Rx pkt length %d of %d, bogus_cnt %d\\n\",\n\t\t\t\t       __func__, pkt_len, data_size, boguscnt);\n#endif\n\t\t\t \n\t\t\tif (pkt_len > rx_copybreak) {\n\t\t\t\tskb_put(skb = rx_skb, pkt_len);\n\t\t\t\tdma_unmap_single(&yp->pci_dev->dev,\n\t\t\t\t\t\t le32_to_cpu(yp->rx_ring[entry].addr),\n\t\t\t\t\t\t yp->rx_buf_sz,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\typ->rx_skbuff[entry] = NULL;\n\t\t\t} else {\n\t\t\t\tskb = netdev_alloc_skb(dev, pkt_len + 2);\n\t\t\t\tif (skb == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tskb_reserve(skb, 2);\t \n\t\t\t\tskb_copy_to_linear_data(skb, rx_skb->data, pkt_len);\n\t\t\t\tskb_put(skb, pkt_len);\n\t\t\t\tdma_sync_single_for_device(&yp->pci_dev->dev,\n\t\t\t\t\t\t\t   le32_to_cpu(desc->addr),\n\t\t\t\t\t\t\t   yp->rx_buf_sz,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\t}\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_rx(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t}\n\t\tentry = (++yp->cur_rx) % RX_RING_SIZE;\n\t}\n\n\t \n\tfor (; yp->cur_rx - yp->dirty_rx > 0; yp->dirty_rx++) {\n\t\tentry = yp->dirty_rx % RX_RING_SIZE;\n\t\tif (yp->rx_skbuff[entry] == NULL) {\n\t\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, yp->rx_buf_sz + 2);\n\t\t\tif (skb == NULL)\n\t\t\t\tbreak;\t\t\t\t \n\t\t\typ->rx_skbuff[entry] = skb;\n\t\t\tskb_reserve(skb, 2);\t \n\t\t\typ->rx_ring[entry].addr = cpu_to_le32(dma_map_single(&yp->pci_dev->dev,\n\t\t\t\t\t\t\t\t\t     skb->data,\n\t\t\t\t\t\t\t\t\t     yp->rx_buf_sz,\n\t\t\t\t\t\t\t\t\t     DMA_FROM_DEVICE));\n\t\t}\n\t\typ->rx_ring[entry].dbdma_cmd = cpu_to_le32(CMD_STOP);\n\t\typ->rx_ring[entry].result_status = 0;\t \n\t\tif (entry != 0)\n\t\t\typ->rx_ring[entry - 1].dbdma_cmd =\n\t\t\t\tcpu_to_le32(CMD_RX_BUF | INTR_ALWAYS | yp->rx_buf_sz);\n\t\telse\n\t\t\typ->rx_ring[RX_RING_SIZE - 1].dbdma_cmd =\n\t\t\t\tcpu_to_le32(CMD_RX_BUF | INTR_ALWAYS | BRANCH_ALWAYS\n\t\t\t\t\t\t\t| yp->rx_buf_sz);\n\t}\n\n\treturn 0;\n}\n\nstatic void yellowfin_error(struct net_device *dev, int intr_status)\n{\n\tnetdev_err(dev, \"Something Wicked happened! %04x\\n\", intr_status);\n\t \n\tif (intr_status & (IntrTxPCIErr | IntrTxPCIFault))\n\t\tdev->stats.tx_errors++;\n\tif (intr_status & (IntrRxPCIErr | IntrRxPCIFault))\n\t\tdev->stats.rx_errors++;\n}\n\nstatic int yellowfin_close(struct net_device *dev)\n{\n\tstruct yellowfin_private *yp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = yp->base;\n\tint i;\n\n\tnetif_stop_queue (dev);\n\n\tif (yellowfin_debug > 1) {\n\t\tnetdev_printk(KERN_DEBUG, dev, \"Shutting down ethercard, status was Tx %04x Rx %04x Int %02x\\n\",\n\t\t\t      ioread16(ioaddr + TxStatus),\n\t\t\t      ioread16(ioaddr + RxStatus),\n\t\t\t      ioread16(ioaddr + IntrStatus));\n\t\tnetdev_printk(KERN_DEBUG, dev, \"Queue pointers were Tx %d / %d,  Rx %d / %d\\n\",\n\t\t\t      yp->cur_tx, yp->dirty_tx,\n\t\t\t      yp->cur_rx, yp->dirty_rx);\n\t}\n\n\t \n\tiowrite16(0x0000, ioaddr + IntrEnb);\n\n\t \n\tiowrite32(0x80000000, ioaddr + RxCtrl);\n\tiowrite32(0x80000000, ioaddr + TxCtrl);\n\n\tdel_timer(&yp->timer);\n\n#if defined(__i386__)\n\tif (yellowfin_debug > 2) {\n\t\tprintk(KERN_DEBUG \"  Tx ring at %08llx:\\n\",\n\t\t\t\t(unsigned long long)yp->tx_ring_dma);\n\t\tfor (i = 0; i < TX_RING_SIZE*2; i++)\n\t\t\tprintk(KERN_DEBUG \" %c #%d desc. %08x %08x %08x %08x\\n\",\n\t\t\t\t   ioread32(ioaddr + TxPtr) == (long)&yp->tx_ring[i] ? '>' : ' ',\n\t\t\t\t   i, yp->tx_ring[i].dbdma_cmd, yp->tx_ring[i].addr,\n\t\t\t\t   yp->tx_ring[i].branch_addr, yp->tx_ring[i].result_status);\n\t\tprintk(KERN_DEBUG \"  Tx status %p:\\n\", yp->tx_status);\n\t\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\t\tprintk(KERN_DEBUG \"   #%d status %04x %04x %04x %04x\\n\",\n\t\t\t\t   i, yp->tx_status[i].tx_cnt, yp->tx_status[i].tx_errs,\n\t\t\t\t   yp->tx_status[i].total_tx_cnt, yp->tx_status[i].paused);\n\n\t\tprintk(KERN_DEBUG \"  Rx ring %08llx:\\n\",\n\t\t\t\t(unsigned long long)yp->rx_ring_dma);\n\t\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\t\tprintk(KERN_DEBUG \" %c #%d desc. %08x %08x %08x\\n\",\n\t\t\t\t   ioread32(ioaddr + RxPtr) == (long)&yp->rx_ring[i] ? '>' : ' ',\n\t\t\t\t   i, yp->rx_ring[i].dbdma_cmd, yp->rx_ring[i].addr,\n\t\t\t\t   yp->rx_ring[i].result_status);\n\t\t\tif (yellowfin_debug > 6) {\n\t\t\t\tif (get_unaligned((u8*)yp->rx_ring[i].addr) != 0x69) {\n\t\t\t\t\tint j;\n\n\t\t\t\t\tprintk(KERN_DEBUG);\n\t\t\t\t\tfor (j = 0; j < 0x50; j++)\n\t\t\t\t\t\tpr_cont(\" %04x\",\n\t\t\t\t\t\t\tget_unaligned(((u16*)yp->rx_ring[i].addr) + j));\n\t\t\t\t\tpr_cont(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif  \n\n\tfree_irq(yp->pci_dev->irq, dev);\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\typ->rx_ring[i].dbdma_cmd = cpu_to_le32(CMD_STOP);\n\t\typ->rx_ring[i].addr = cpu_to_le32(0xBADF00D0);  \n\t\tif (yp->rx_skbuff[i]) {\n\t\t\tdev_kfree_skb(yp->rx_skbuff[i]);\n\t\t}\n\t\typ->rx_skbuff[i] = NULL;\n\t}\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tdev_kfree_skb(yp->tx_skbuff[i]);\n\t\typ->tx_skbuff[i] = NULL;\n\t}\n\n#ifdef YF_PROTOTYPE\t\t\t \n\tif (yellowfin_debug > 0) {\n\t\tnetdev_printk(KERN_DEBUG, dev, \"Received %d frames that we should not have\\n\",\n\t\t\t      bogus_rx);\n\t}\n#endif\n\n\treturn 0;\n}\n\n \n\nstatic void set_rx_mode(struct net_device *dev)\n{\n\tstruct yellowfin_private *yp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = yp->base;\n\tu16 cfg_value = ioread16(ioaddr + Cnfg);\n\n\t \n\tiowrite16(cfg_value & ~0x1000, ioaddr + Cnfg);\n\tif (dev->flags & IFF_PROMISC) {\t\t\t \n\t\tiowrite16(0x000F, ioaddr + AddrMode);\n\t} else if ((netdev_mc_count(dev) > 64) ||\n\t\t   (dev->flags & IFF_ALLMULTI)) {\n\t\t \n\t\tiowrite16(0x000B, ioaddr + AddrMode);\n\t} else if (!netdev_mc_empty(dev)) {  \n\t\tstruct netdev_hw_addr *ha;\n\t\tu16 hash_table[4];\n\t\tint i;\n\n\t\tmemset(hash_table, 0, sizeof(hash_table));\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tunsigned int bit;\n\n\t\t\t \n\t\t\tif (yp->drv_flags & HasMulticastBug) {\n\t\t\t\tbit = (ether_crc_le(3, ha->addr) >> 3) & 0x3f;\n\t\t\t\thash_table[bit >> 4] |= (1 << bit);\n\t\t\t\tbit = (ether_crc_le(4, ha->addr) >> 3) & 0x3f;\n\t\t\t\thash_table[bit >> 4] |= (1 << bit);\n\t\t\t\tbit = (ether_crc_le(5, ha->addr) >> 3) & 0x3f;\n\t\t\t\thash_table[bit >> 4] |= (1 << bit);\n\t\t\t}\n\t\t\tbit = (ether_crc_le(6, ha->addr) >> 3) & 0x3f;\n\t\t\thash_table[bit >> 4] |= (1 << bit);\n\t\t}\n\t\t \n\t\tfor (i = 0; i < 4; i++)\n\t\t\tiowrite16(hash_table[i], ioaddr + HashTbl + i*2);\n\t\tiowrite16(0x0003, ioaddr + AddrMode);\n\t} else {\t\t\t\t\t \n\t\tiowrite16(0x0001, ioaddr + AddrMode);\n\t}\n\t \n\tiowrite16(cfg_value | 0x1000, ioaddr + Cnfg);\n}\n\nstatic void yellowfin_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct yellowfin_private *np = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(np->pci_dev), sizeof(info->bus_info));\n}\n\nstatic const struct ethtool_ops ethtool_ops = {\n\t.get_drvinfo = yellowfin_get_drvinfo\n};\n\nstatic int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct yellowfin_private *np = netdev_priv(dev);\n\tvoid __iomem *ioaddr = np->base;\n\tstruct mii_ioctl_data *data = if_mii(rq);\n\n\tswitch(cmd) {\n\tcase SIOCGMIIPHY:\t\t \n\t\tdata->phy_id = np->phys[0] & 0x1f;\n\t\tfallthrough;\n\n\tcase SIOCGMIIREG:\t\t \n\t\tdata->val_out = mdio_read(ioaddr, data->phy_id & 0x1f, data->reg_num & 0x1f);\n\t\treturn 0;\n\n\tcase SIOCSMIIREG:\t\t \n\t\tif (data->phy_id == np->phys[0]) {\n\t\t\tu16 value = data->val_in;\n\t\t\tswitch (data->reg_num) {\n\t\t\tcase 0:\n\t\t\t\t \n\t\t\t\tnp->medialock = (value & 0x9000) ? 0 : 1;\n\t\t\t\tif (np->medialock)\n\t\t\t\t\tnp->full_duplex = (value & 0x0100) ? 1 : 0;\n\t\t\t\tbreak;\n\t\t\tcase 4: np->advertising = value; break;\n\t\t\t}\n\t\t\t \n\t\t}\n\t\tmdio_write(ioaddr, data->phy_id & 0x1f, data->reg_num & 0x1f, data->val_in);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n\nstatic void yellowfin_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct yellowfin_private *np;\n\n\tBUG_ON(!dev);\n\tnp = netdev_priv(dev);\n\n\tdma_free_coherent(&pdev->dev, STATUS_TOTAL_SIZE, np->tx_status,\n\t\t\t  np->tx_status_dma);\n\tdma_free_coherent(&pdev->dev, RX_TOTAL_SIZE, np->rx_ring,\n\t\t\t  np->rx_ring_dma);\n\tdma_free_coherent(&pdev->dev, TX_TOTAL_SIZE, np->tx_ring,\n\t\t\t  np->tx_ring_dma);\n\tunregister_netdev (dev);\n\n\tpci_iounmap(pdev, np->base);\n\n\tpci_release_regions (pdev);\n\n\tfree_netdev (dev);\n}\n\n\nstatic struct pci_driver yellowfin_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= yellowfin_pci_tbl,\n\t.probe\t\t= yellowfin_init_one,\n\t.remove\t\t= yellowfin_remove_one,\n};\n\n\nstatic int __init yellowfin_init (void)\n{\n \n#ifdef MODULE\n\tprintk(version);\n#endif\n\treturn pci_register_driver(&yellowfin_driver);\n}\n\n\nstatic void __exit yellowfin_cleanup (void)\n{\n\tpci_unregister_driver (&yellowfin_driver);\n}\n\n\nmodule_init(yellowfin_init);\nmodule_exit(yellowfin_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}