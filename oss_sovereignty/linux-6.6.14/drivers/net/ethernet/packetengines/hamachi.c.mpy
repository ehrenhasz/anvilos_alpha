{
  "module_name": "hamachi.c",
  "hash_id": "e07023c8a02331c2f04dce91e377250c88d05659cddea63d51ef8442734dc872",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/packetengines/hamachi.c",
  "human_readable_source": " \n \n\n#define DRV_NAME\t\"hamachi\"\n#define DRV_VERSION\t\"2.1\"\n#define DRV_RELDATE\t\"Sept 11, 2006\"\n\n\n \n\nstatic int debug = 1;\t\t \n#define final_version\n#define hamachi_debug debug\n \nstatic int max_interrupt_work = 40;\nstatic int mtu;\n \n \nstatic int max_rx_latency = 0x11;\nstatic int max_rx_gap = 0x05;\nstatic int min_rx_pkt = 0x18;\nstatic int max_tx_latency = 0x00;\nstatic int max_tx_gap = 0x00;\nstatic int min_tx_pkt = 0x30;\n\n \nstatic int rx_copybreak;\n\n \nstatic int force32;\n\n\n \n#define MAX_UNITS 8\t\t\t\t \nstatic int options[MAX_UNITS] = {-1, -1, -1, -1, -1, -1, -1, -1};\nstatic int full_duplex[MAX_UNITS] = {-1, -1, -1, -1, -1, -1, -1, -1};\n \nstatic int rx_params[MAX_UNITS] = {-1, -1, -1, -1, -1, -1, -1, -1};\nstatic int tx_params[MAX_UNITS] = {-1, -1, -1, -1, -1, -1, -1, -1};\n\n \n\n \n \n#define TX_RING_SIZE\t64\n#define RX_RING_SIZE\t512\n#define TX_TOTAL_SIZE\tTX_RING_SIZE*sizeof(struct hamachi_desc)\n#define RX_TOTAL_SIZE\tRX_RING_SIZE*sizeof(struct hamachi_desc)\n\n \n\n \n \n\n \n#define RX_CHECKSUM\n\n \n \n#define TX_TIMEOUT  (5*HZ)\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n\n#include <linux/uaccess.h>\n#include <asm/processor.h>\t \n#include <asm/io.h>\n#include <asm/unaligned.h>\n#include <asm/cache.h>\n\nstatic const char version[] =\nKERN_INFO DRV_NAME \".c:v\" DRV_VERSION \" \" DRV_RELDATE \"  Written by Donald Becker\\n\"\n\"   Some modifications by Eric kasten <kasten@nscl.msu.edu>\\n\"\n\"   Further modifications by Keith Underwood <keithu@parl.clemson.edu>\\n\";\n\n\n \n#ifndef IP_MF\n  #define IP_MF 0x2000    \n#endif\n\n \n#ifndef IP_OFFSET\n  #ifdef IPOPT_OFFSET\n    #define IP_OFFSET IPOPT_OFFSET\n  #else\n    #define IP_OFFSET 2\n  #endif\n#endif\n\n#define RUN_AT(x) (jiffies + (x))\n\n#ifndef ADDRLEN\n#define ADDRLEN 32\n#endif\n\n \n#if ADDRLEN == 64\n#define cpu_to_leXX(addr)\tcpu_to_le64(addr)\n#define leXX_to_cpu(addr)\tle64_to_cpu(addr)\n#else\n#define cpu_to_leXX(addr)\tcpu_to_le32(addr)\n#define leXX_to_cpu(addr)\tle32_to_cpu(addr)\n#endif\n\n\n \n\n \n \n#define PKT_BUF_SZ\t\t1536\n\n \n#define MAX_FRAME_SIZE  1518\n\n \n\nstatic void hamachi_timer(struct timer_list *t);\n\nenum capability_flags {CanHaveMII=1, };\nstatic const struct chip_info {\n\tu16\tvendor_id, device_id, device_id_mask, pad;\n\tconst char *name;\n\tvoid (*media_timer)(struct timer_list *t);\n\tint flags;\n} chip_tbl[] = {\n\t{0x1318, 0x0911, 0xffff, 0, \"Hamachi GNIC-II\", hamachi_timer, 0},\n\t{0,},\n};\n\n \nenum hamachi_offsets {\n\tTxDMACtrl=0x00, TxCmd=0x04, TxStatus=0x06, TxPtr=0x08, TxCurPtr=0x10,\n\tRxDMACtrl=0x20, RxCmd=0x24, RxStatus=0x26, RxPtr=0x28, RxCurPtr=0x30,\n\tPCIClkMeas=0x060, MiscStatus=0x066, ChipRev=0x68, ChipReset=0x06B,\n\tLEDCtrl=0x06C, VirtualJumpers=0x06D, GPIO=0x6E,\n\tTxChecksum=0x074, RxChecksum=0x076,\n\tTxIntrCtrl=0x078, RxIntrCtrl=0x07C,\n\tInterruptEnable=0x080, InterruptClear=0x084, IntrStatus=0x088,\n\tEventStatus=0x08C,\n\tMACCnfg=0x0A0, FrameGap0=0x0A2, FrameGap1=0x0A4,\n\t \n\tMACCnfg2=0x0B0, RxDepth=0x0B8, FlowCtrl=0x0BC, MaxFrameSize=0x0CE,\n\tAddrMode=0x0D0, StationAddr=0x0D2,\n\t \n\tANCtrl=0x0E0, ANStatus=0x0E2, ANXchngCtrl=0x0E4, ANAdvertise=0x0E8,\n\tANLinkPartnerAbility=0x0EA,\n\tEECmdStatus=0x0F0, EEData=0x0F1, EEAddr=0x0F2,\n\tFIFOcfg=0x0F8,\n};\n\n \nenum MII_offsets {\n\tMII_Cmd=0xA6, MII_Addr=0xA8, MII_Wr_Data=0xAA, MII_Rd_Data=0xAC,\n\tMII_Status=0xAE,\n};\n\n \nenum intr_status_bits {\n\tIntrRxDone=0x01, IntrRxPCIFault=0x02, IntrRxPCIErr=0x04,\n\tIntrTxDone=0x100, IntrTxPCIFault=0x200, IntrTxPCIErr=0x400,\n\tLinkChange=0x10000, NegotiationChange=0x20000, StatsMax=0x40000, };\n\n \nstruct hamachi_desc {\n\t__le32 status_n_length;\n#if ADDRLEN == 64\n\tu32 pad;\n\t__le64 addr;\n#else\n\t__le32 addr;\n#endif\n};\n\n \nenum desc_status_bits {\n\tDescOwn=0x80000000, DescEndPacket=0x40000000, DescEndRing=0x20000000,\n\tDescIntr=0x10000000,\n};\n\n#define PRIV_ALIGN\t15  \t\t\t \n#define MII_CNT\t\t4\nstruct hamachi_private {\n\t \n\tstruct hamachi_desc *rx_ring;\n\tstruct hamachi_desc *tx_ring;\n\tstruct sk_buff* rx_skbuff[RX_RING_SIZE];\n\tstruct sk_buff* tx_skbuff[TX_RING_SIZE];\n\tdma_addr_t tx_ring_dma;\n\tdma_addr_t rx_ring_dma;\n\tstruct timer_list timer;\t\t \n\t \n\tspinlock_t lock;\n\tint chip_id;\n\tunsigned int cur_rx, dirty_rx;\t\t \n\tunsigned int cur_tx, dirty_tx;\n\tunsigned int rx_buf_sz;\t\t\t \n\tunsigned int tx_full:1;\t\t\t \n\tunsigned int duplex_lock:1;\n\tunsigned int default_port:4;\t\t \n\t \n\tint mii_cnt;\t\t\t\t\t\t\t\t \n\tstruct mii_if_info mii_if;\t\t \n\tunsigned char phys[MII_CNT];\t\t \n\tu32 rx_int_var, tx_int_var;\t \n\tu32 option;\t\t\t\t\t\t\t \n\tstruct pci_dev *pci_dev;\n\tvoid __iomem *base;\n};\n\nMODULE_AUTHOR(\"Donald Becker <becker@scyld.com>, Eric Kasten <kasten@nscl.msu.edu>, Keith Underwood <keithu@parl.clemson.edu>\");\nMODULE_DESCRIPTION(\"Packet Engines 'Hamachi' GNIC-II Gigabit Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(max_interrupt_work, int, 0);\nmodule_param(mtu, int, 0);\nmodule_param(debug, int, 0);\nmodule_param(min_rx_pkt, int, 0);\nmodule_param(max_rx_gap, int, 0);\nmodule_param(max_rx_latency, int, 0);\nmodule_param(min_tx_pkt, int, 0);\nmodule_param(max_tx_gap, int, 0);\nmodule_param(max_tx_latency, int, 0);\nmodule_param(rx_copybreak, int, 0);\nmodule_param_array(rx_params, int, NULL, 0);\nmodule_param_array(tx_params, int, NULL, 0);\nmodule_param_array(options, int, NULL, 0);\nmodule_param_array(full_duplex, int, NULL, 0);\nmodule_param(force32, int, 0);\nMODULE_PARM_DESC(max_interrupt_work, \"GNIC-II maximum events handled per interrupt\");\nMODULE_PARM_DESC(mtu, \"GNIC-II MTU (all boards)\");\nMODULE_PARM_DESC(debug, \"GNIC-II debug level (0-7)\");\nMODULE_PARM_DESC(min_rx_pkt, \"GNIC-II minimum Rx packets processed between interrupts\");\nMODULE_PARM_DESC(max_rx_gap, \"GNIC-II maximum Rx inter-packet gap in 8.192 microsecond units\");\nMODULE_PARM_DESC(max_rx_latency, \"GNIC-II time between Rx interrupts in 8.192 microsecond units\");\nMODULE_PARM_DESC(min_tx_pkt, \"GNIC-II minimum Tx packets processed between interrupts\");\nMODULE_PARM_DESC(max_tx_gap, \"GNIC-II maximum Tx inter-packet gap in 8.192 microsecond units\");\nMODULE_PARM_DESC(max_tx_latency, \"GNIC-II time between Tx interrupts in 8.192 microsecond units\");\nMODULE_PARM_DESC(rx_copybreak, \"GNIC-II copy breakpoint for copy-only-tiny-frames\");\nMODULE_PARM_DESC(rx_params, \"GNIC-II min_rx_pkt+max_rx_gap+max_rx_latency\");\nMODULE_PARM_DESC(tx_params, \"GNIC-II min_tx_pkt+max_tx_gap+max_tx_latency\");\nMODULE_PARM_DESC(options, \"GNIC-II Bits 0-3: media type, bits 4-6: as force32, bit 7: half duplex, bit 9 full duplex\");\nMODULE_PARM_DESC(full_duplex, \"GNIC-II full duplex setting(s) (1)\");\nMODULE_PARM_DESC(force32, \"GNIC-II: Bit 0: 32 bit PCI, bit 1: disable parity, bit 2: 64 bit PCI (all boards)\");\n\nstatic int read_eeprom(void __iomem *ioaddr, int location);\nstatic int mdio_read(struct net_device *dev, int phy_id, int location);\nstatic void mdio_write(struct net_device *dev, int phy_id, int location, int value);\nstatic int hamachi_open(struct net_device *dev);\nstatic int hamachi_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic int hamachi_siocdevprivate(struct net_device *dev, struct ifreq *rq,\n\t\t\t\t  void __user *data, int cmd);\nstatic void hamachi_timer(struct timer_list *t);\nstatic void hamachi_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic void hamachi_init_ring(struct net_device *dev);\nstatic netdev_tx_t hamachi_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev);\nstatic irqreturn_t hamachi_interrupt(int irq, void *dev_instance);\nstatic int hamachi_rx(struct net_device *dev);\nstatic inline int hamachi_tx(struct net_device *dev);\nstatic void hamachi_error(struct net_device *dev, int intr_status);\nstatic int hamachi_close(struct net_device *dev);\nstatic struct net_device_stats *hamachi_get_stats(struct net_device *dev);\nstatic void set_rx_mode(struct net_device *dev);\nstatic const struct ethtool_ops ethtool_ops;\nstatic const struct ethtool_ops ethtool_ops_no_mii;\n\nstatic const struct net_device_ops hamachi_netdev_ops = {\n\t.ndo_open\t\t= hamachi_open,\n\t.ndo_stop\t\t= hamachi_close,\n\t.ndo_start_xmit\t\t= hamachi_start_xmit,\n\t.ndo_get_stats\t\t= hamachi_get_stats,\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_tx_timeout\t\t= hamachi_tx_timeout,\n\t.ndo_eth_ioctl\t\t= hamachi_ioctl,\n\t.ndo_siocdevprivate\t= hamachi_siocdevprivate,\n};\n\n\nstatic int hamachi_init_one(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct hamachi_private *hmp;\n\tint option, i, rx_int_var, tx_int_var, boguscnt;\n\tint chip_id = ent->driver_data;\n\tint irq;\n\tvoid __iomem *ioaddr;\n\tunsigned long base;\n\tstatic int card_idx;\n\tstruct net_device *dev;\n\tvoid *ring_space;\n\tdma_addr_t ring_dma;\n\tint ret = -ENOMEM;\n\tu8 addr[ETH_ALEN];\n\n \n#ifndef MODULE\n\tstatic int printed_version;\n\tif (!printed_version++)\n\t\tprintk(version);\n#endif\n\n\tif (pci_enable_device(pdev)) {\n\t\tret = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tbase = pci_resource_start(pdev, 0);\n#ifdef __alpha__\t\t\t\t \n\tbase |= (pci_resource_start(pdev, 1) << 32);\n#endif\n\n\tpci_set_master(pdev);\n\n\ti = pci_request_regions(pdev, DRV_NAME);\n\tif (i)\n\t\treturn i;\n\n\tirq = pdev->irq;\n\tioaddr = ioremap(base, 0x400);\n\tif (!ioaddr)\n\t\tgoto err_out_release;\n\n\tdev = alloc_etherdev(sizeof(struct hamachi_private));\n\tif (!dev)\n\t\tgoto err_out_iounmap;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tfor (i = 0; i < 6; i++)\n\t\taddr[i] = read_eeprom(ioaddr, 4 + i);\n\teth_hw_addr_set(dev, addr);\n\n#if ! defined(final_version)\n\tif (hamachi_debug > 4)\n\t\tfor (i = 0; i < 0x10; i++)\n\t\t\tprintk(\"%2.2x%s\",\n\t\t\t\t   read_eeprom(ioaddr, i), i % 16 != 15 ? \" \" : \"\\n\");\n#endif\n\n\thmp = netdev_priv(dev);\n\tspin_lock_init(&hmp->lock);\n\n\thmp->mii_if.dev = dev;\n\thmp->mii_if.mdio_read = mdio_read;\n\thmp->mii_if.mdio_write = mdio_write;\n\thmp->mii_if.phy_id_mask = 0x1f;\n\thmp->mii_if.reg_num_mask = 0x1f;\n\n\tring_space = dma_alloc_coherent(&pdev->dev, TX_TOTAL_SIZE, &ring_dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ring_space)\n\t\tgoto err_out_cleardev;\n\thmp->tx_ring = ring_space;\n\thmp->tx_ring_dma = ring_dma;\n\n\tring_space = dma_alloc_coherent(&pdev->dev, RX_TOTAL_SIZE, &ring_dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ring_space)\n\t\tgoto err_out_unmap_tx;\n\thmp->rx_ring = ring_space;\n\thmp->rx_ring_dma = ring_dma;\n\n\t \n\toption = card_idx < MAX_UNITS ? options[card_idx] : 0;\n\tif (dev->mem_start)\n\t\toption = dev->mem_start;\n\n\t \n\tforce32 = force32 ? force32 :\n\t\t((option  >= 0) ? ((option & 0x00000070) >> 4) : 0 );\n\tif (force32)\n\t\twriteb(force32, ioaddr + VirtualJumpers);\n\n\t \n\twriteb(0x01, ioaddr + ChipReset);\n\n\t \n\tudelay(10);\n\ti = readb(ioaddr + PCIClkMeas);\n\tfor (boguscnt = 0; (!(i & 0x080)) && boguscnt < 1000; boguscnt++){\n\t\tudelay(10);\n\t\ti = readb(ioaddr + PCIClkMeas);\n\t}\n\n\thmp->base = ioaddr;\n\tpci_set_drvdata(pdev, dev);\n\n\thmp->chip_id = chip_id;\n\thmp->pci_dev = pdev;\n\n\t \n\tif (option > 0) {\n\t\thmp->option = option;\n\t\tif (option & 0x200)\n\t\t\thmp->mii_if.full_duplex = 1;\n\t\telse if (option & 0x080)\n\t\t\thmp->mii_if.full_duplex = 0;\n\t\thmp->default_port = option & 15;\n\t\tif (hmp->default_port)\n\t\t\thmp->mii_if.force_media = 1;\n\t}\n\tif (card_idx < MAX_UNITS  &&  full_duplex[card_idx] > 0)\n\t\thmp->mii_if.full_duplex = 1;\n\n\t \n\tif (hmp->mii_if.full_duplex || (option & 0x080))\n\t\thmp->duplex_lock = 1;\n\n\t \n\tmax_rx_latency = max_rx_latency & 0x00ff;\n\tmax_rx_gap = max_rx_gap & 0x00ff;\n\tmin_rx_pkt = min_rx_pkt & 0x00ff;\n\tmax_tx_latency = max_tx_latency & 0x00ff;\n\tmax_tx_gap = max_tx_gap & 0x00ff;\n\tmin_tx_pkt = min_tx_pkt & 0x00ff;\n\n\trx_int_var = card_idx < MAX_UNITS ? rx_params[card_idx] : -1;\n\ttx_int_var = card_idx < MAX_UNITS ? tx_params[card_idx] : -1;\n\thmp->rx_int_var = rx_int_var >= 0 ? rx_int_var :\n\t\t(min_rx_pkt << 16 | max_rx_gap << 8 | max_rx_latency);\n\thmp->tx_int_var = tx_int_var >= 0 ? tx_int_var :\n\t\t(min_tx_pkt << 16 | max_tx_gap << 8 | max_tx_latency);\n\n\n\t \n\tdev->netdev_ops = &hamachi_netdev_ops;\n\tdev->ethtool_ops = (chip_tbl[hmp->chip_id].flags & CanHaveMII) ?\n\t\t&ethtool_ops : &ethtool_ops_no_mii;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tif (mtu)\n\t\tdev->mtu = mtu;\n\n\ti = register_netdev(dev);\n\tif (i) {\n\t\tret = i;\n\t\tgoto err_out_unmap_rx;\n\t}\n\n\tprintk(KERN_INFO \"%s: %s type %x at %p, %pM, IRQ %d.\\n\",\n\t\t   dev->name, chip_tbl[chip_id].name, readl(ioaddr + ChipRev),\n\t\t   ioaddr, dev->dev_addr, irq);\n\ti = readb(ioaddr + PCIClkMeas);\n\tprintk(KERN_INFO \"%s:  %d-bit %d Mhz PCI bus (%d), Virtual Jumpers \"\n\t\t   \"%2.2x, LPA %4.4x.\\n\",\n\t\t   dev->name, readw(ioaddr + MiscStatus) & 1 ? 64 : 32,\n\t\t   i ? 2000/(i&0x7f) : 0, i&0x7f, (int)readb(ioaddr + VirtualJumpers),\n\t\t   readw(ioaddr + ANLinkPartnerAbility));\n\n\tif (chip_tbl[hmp->chip_id].flags & CanHaveMII) {\n\t\tint phy, phy_idx = 0;\n\t\tfor (phy = 0; phy < 32 && phy_idx < MII_CNT; phy++) {\n\t\t\tint mii_status = mdio_read(dev, phy, MII_BMSR);\n\t\t\tif (mii_status != 0xffff  &&\n\t\t\t\tmii_status != 0x0000) {\n\t\t\t\thmp->phys[phy_idx++] = phy;\n\t\t\t\thmp->mii_if.advertising = mdio_read(dev, phy, MII_ADVERTISE);\n\t\t\t\tprintk(KERN_INFO \"%s: MII PHY found at address %d, status \"\n\t\t\t\t\t   \"0x%4.4x advertising %4.4x.\\n\",\n\t\t\t\t\t   dev->name, phy, mii_status, hmp->mii_if.advertising);\n\t\t\t}\n\t\t}\n\t\thmp->mii_cnt = phy_idx;\n\t\tif (hmp->mii_cnt > 0)\n\t\t\thmp->mii_if.phy_id = hmp->phys[0];\n\t\telse\n\t\t\tmemset(&hmp->mii_if, 0, sizeof(hmp->mii_if));\n\t}\n\t \n\twritew(0x0400, ioaddr + ANXchngCtrl);\t \n\twritew(0x08e0, ioaddr + ANAdvertise);\t \n\twritew(0x1000, ioaddr + ANCtrl);\t\t\t \n\n\tcard_idx++;\n\treturn 0;\n\nerr_out_unmap_rx:\n\tdma_free_coherent(&pdev->dev, RX_TOTAL_SIZE, hmp->rx_ring,\n\t\t\t  hmp->rx_ring_dma);\nerr_out_unmap_tx:\n\tdma_free_coherent(&pdev->dev, TX_TOTAL_SIZE, hmp->tx_ring,\n\t\t\t  hmp->tx_ring_dma);\nerr_out_cleardev:\n\tfree_netdev (dev);\nerr_out_iounmap:\n\tiounmap(ioaddr);\nerr_out_release:\n\tpci_release_regions(pdev);\nerr_out:\n\treturn ret;\n}\n\nstatic int read_eeprom(void __iomem *ioaddr, int location)\n{\n\tint bogus_cnt = 1000;\n\n\t \n\twhile ((readb(ioaddr + EECmdStatus) & 0x40)  && --bogus_cnt > 0);\n\twritew(location, ioaddr + EEAddr);\n\twriteb(0x02, ioaddr + EECmdStatus);\n\tbogus_cnt = 1000;\n\twhile ((readb(ioaddr + EECmdStatus) & 0x40)  && --bogus_cnt > 0);\n\tif (hamachi_debug > 5)\n\t\tprintk(\"   EEPROM status is %2.2x after %d ticks.\\n\",\n\t\t\t   (int)readb(ioaddr + EECmdStatus), 1000- bogus_cnt);\n\treturn readb(ioaddr + EEData);\n}\n\n \n\nstatic int mdio_read(struct net_device *dev, int phy_id, int location)\n{\n\tstruct hamachi_private *hmp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = hmp->base;\n\tint i;\n\n\t \n\tfor (i = 10000; i >= 0; i--)\n\t\tif ((readw(ioaddr + MII_Status) & 1) == 0)\n\t\t\tbreak;\n\twritew((phy_id<<8) + location, ioaddr + MII_Addr);\n\twritew(0x0001, ioaddr + MII_Cmd);\n\tfor (i = 10000; i >= 0; i--)\n\t\tif ((readw(ioaddr + MII_Status) & 1) == 0)\n\t\t\tbreak;\n\treturn readw(ioaddr + MII_Rd_Data);\n}\n\nstatic void mdio_write(struct net_device *dev, int phy_id, int location, int value)\n{\n\tstruct hamachi_private *hmp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = hmp->base;\n\tint i;\n\n\t \n\tfor (i = 10000; i >= 0; i--)\n\t\tif ((readw(ioaddr + MII_Status) & 1) == 0)\n\t\t\tbreak;\n\twritew((phy_id<<8) + location, ioaddr + MII_Addr);\n\twritew(value, ioaddr + MII_Wr_Data);\n\n\t \n\tfor (i = 10000; i >= 0; i--)\n\t\tif ((readw(ioaddr + MII_Status) & 1) == 0)\n\t\t\tbreak;\n}\n\n\nstatic int hamachi_open(struct net_device *dev)\n{\n\tstruct hamachi_private *hmp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = hmp->base;\n\tint i;\n\tu32 rx_int_var, tx_int_var;\n\tu16 fifo_info;\n\n\ti = request_irq(hmp->pci_dev->irq, hamachi_interrupt, IRQF_SHARED,\n\t\t\tdev->name, dev);\n\tif (i)\n\t\treturn i;\n\n\thamachi_init_ring(dev);\n\n#if ADDRLEN == 64\n\t \n\twritel(hmp->rx_ring_dma, ioaddr + RxPtr);\n\twritel(hmp->rx_ring_dma >> 32, ioaddr + RxPtr + 4);\n\twritel(hmp->tx_ring_dma, ioaddr + TxPtr);\n\twritel(hmp->tx_ring_dma >> 32, ioaddr + TxPtr + 4);\n#else\n\twritel(hmp->rx_ring_dma, ioaddr + RxPtr);\n\twritel(hmp->tx_ring_dma, ioaddr + TxPtr);\n#endif\n\n\t \n\tfor (i = 0; i < 6; i++)\n\t\twriteb(dev->dev_addr[i], ioaddr + StationAddr + i);\n\n\t \n\n\t \n\tfifo_info = (readw(ioaddr + GPIO) & 0x00C0) >> 6;\n\tswitch (fifo_info){\n\t\tcase 0 :\n\t\t\t \n\t\t\twritew(0x0000, ioaddr + FIFOcfg);\n\t\t\tbreak;\n\t\tcase 1 :\n\t\t\t \n\t\t\twritew(0x0028, ioaddr + FIFOcfg);\n\t\t\tbreak;\n\t\tcase 2 :\n\t\t\t \n\t\t\twritew(0x004C, ioaddr + FIFOcfg);\n\t\t\tbreak;\n\t\tcase 3 :\n\t\t\t \n\t\t\twritew(0x006C, ioaddr + FIFOcfg);\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tprintk(KERN_WARNING \"%s:  Unsupported external memory config!\\n\",\n\t\t\t\tdev->name);\n\t\t\t \n\t\t\twritew(0x0000, ioaddr + FIFOcfg);\n\t\t\tbreak;\n\t}\n\n\tif (dev->if_port == 0)\n\t\tdev->if_port = hmp->default_port;\n\n\n\t \n\t \n\tif (hmp->duplex_lock != 1)\n\t\thmp->mii_if.full_duplex = 1;\n\n\t \n\twritew(0x0001, ioaddr + RxChecksum);\n\twritew(0x0000, ioaddr + TxChecksum);\n\twritew(0x8000, ioaddr + MACCnfg);  \n\twritew(0x215F, ioaddr + MACCnfg);\n\twritew(0x000C, ioaddr + FrameGap0);\n\t \n\twritew(0x1018, ioaddr + FrameGap1);\n\t \n\twritew(0x0780, ioaddr + MACCnfg2);  \n\t \n\twritel(0x0030FFFF, ioaddr + FlowCtrl);\n\twritew(MAX_FRAME_SIZE, ioaddr + MaxFrameSize); \t \n\n\t \n\twritew(0x0400, ioaddr + ANXchngCtrl);\t \n\t \n\twriteb(0x03, ioaddr + LEDCtrl);\n\n\t \n\n\trx_int_var = hmp->rx_int_var;\n\ttx_int_var = hmp->tx_int_var;\n\n\tif (hamachi_debug > 1) {\n\t\tprintk(\"max_tx_latency: %d, max_tx_gap: %d, min_tx_pkt: %d\\n\",\n\t\t\ttx_int_var & 0x00ff, (tx_int_var & 0x00ff00) >> 8,\n\t\t\t(tx_int_var & 0x00ff0000) >> 16);\n\t\tprintk(\"max_rx_latency: %d, max_rx_gap: %d, min_rx_pkt: %d\\n\",\n\t\t\trx_int_var & 0x00ff, (rx_int_var & 0x00ff00) >> 8,\n\t\t\t(rx_int_var & 0x00ff0000) >> 16);\n\t\tprintk(\"rx_int_var: %x, tx_int_var: %x\\n\", rx_int_var, tx_int_var);\n\t}\n\n\twritel(tx_int_var, ioaddr + TxIntrCtrl);\n\twritel(rx_int_var, ioaddr + RxIntrCtrl);\n\n\tset_rx_mode(dev);\n\n\tnetif_start_queue(dev);\n\n\t \n\twritel(0x80878787, ioaddr + InterruptEnable);\n\twritew(0x0000, ioaddr + EventStatus);\t \n\n\t \n\t \n#if ADDRLEN == 64\n\twritew(0x005D, ioaddr + RxDMACtrl); \t\t \n\twritew(0x005D, ioaddr + TxDMACtrl);\n#else\n\twritew(0x001D, ioaddr + RxDMACtrl);\n\twritew(0x001D, ioaddr + TxDMACtrl);\n#endif\n\twritew(0x0001, ioaddr + RxCmd);\n\n\tif (hamachi_debug > 2) {\n\t\tprintk(KERN_DEBUG \"%s: Done hamachi_open(), status: Rx %x Tx %x.\\n\",\n\t\t\t   dev->name, readw(ioaddr + RxStatus), readw(ioaddr + TxStatus));\n\t}\n\t \n\ttimer_setup(&hmp->timer, hamachi_timer, 0);\n\thmp->timer.expires = RUN_AT((24*HZ)/10);\t\t\t \n\tadd_timer(&hmp->timer);\n\n\treturn 0;\n}\n\nstatic inline int hamachi_tx(struct net_device *dev)\n{\n\tstruct hamachi_private *hmp = netdev_priv(dev);\n\n\t \n\tfor (; hmp->cur_tx - hmp->dirty_tx > 0; hmp->dirty_tx++) {\n\t\tint entry = hmp->dirty_tx % TX_RING_SIZE;\n\t\tstruct sk_buff *skb;\n\n\t\tif (hmp->tx_ring[entry].status_n_length & cpu_to_le32(DescOwn))\n\t\t\tbreak;\n\t\t \n\t\tskb = hmp->tx_skbuff[entry];\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&hmp->pci_dev->dev,\n\t\t\t\t\t leXX_to_cpu(hmp->tx_ring[entry].addr),\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(skb);\n\t\t\thmp->tx_skbuff[entry] = NULL;\n\t\t}\n\t\thmp->tx_ring[entry].status_n_length = 0;\n\t\tif (entry >= TX_RING_SIZE-1)\n\t\t\thmp->tx_ring[TX_RING_SIZE-1].status_n_length |=\n\t\t\t\tcpu_to_le32(DescEndRing);\n\t\tdev->stats.tx_packets++;\n\t}\n\n\treturn 0;\n}\n\nstatic void hamachi_timer(struct timer_list *t)\n{\n\tstruct hamachi_private *hmp = from_timer(hmp, t, timer);\n\tstruct net_device *dev = hmp->mii_if.dev;\n\tvoid __iomem *ioaddr = hmp->base;\n\tint next_tick = 10*HZ;\n\n\tif (hamachi_debug > 2) {\n\t\tprintk(KERN_INFO \"%s: Hamachi Autonegotiation status %4.4x, LPA \"\n\t\t\t   \"%4.4x.\\n\", dev->name, readw(ioaddr + ANStatus),\n\t\t\t   readw(ioaddr + ANLinkPartnerAbility));\n\t\tprintk(KERN_INFO \"%s: Autonegotiation regs %4.4x %4.4x %4.4x \"\n\t\t       \"%4.4x %4.4x %4.4x.\\n\", dev->name,\n\t\t       readw(ioaddr + 0x0e0),\n\t\t       readw(ioaddr + 0x0e2),\n\t\t       readw(ioaddr + 0x0e4),\n\t\t       readw(ioaddr + 0x0e6),\n\t\t       readw(ioaddr + 0x0e8),\n\t\t       readw(ioaddr + 0x0eA));\n\t}\n\t \n\thmp->timer.expires = RUN_AT(next_tick);\n\tadd_timer(&hmp->timer);\n}\n\nstatic void hamachi_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tint i;\n\tstruct hamachi_private *hmp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = hmp->base;\n\n\tprintk(KERN_WARNING \"%s: Hamachi transmit timed out, status %8.8x,\"\n\t\t   \" resetting...\\n\", dev->name, (int)readw(ioaddr + TxStatus));\n\n\t{\n\t\tprintk(KERN_DEBUG \"  Rx ring %p: \", hmp->rx_ring);\n\t\tfor (i = 0; i < RX_RING_SIZE; i++)\n\t\t\tprintk(KERN_CONT \" %8.8x\",\n\t\t\t       le32_to_cpu(hmp->rx_ring[i].status_n_length));\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tprintk(KERN_DEBUG\"  Tx ring %p: \", hmp->tx_ring);\n\t\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\t\tprintk(KERN_CONT \" %4.4x\",\n\t\t\t       le32_to_cpu(hmp->tx_ring[i].status_n_length));\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\n\t \n\tdev->if_port = 0;\n\t \n\n\tfor (i = 0; i < RX_RING_SIZE; i++)\n\t\thmp->rx_ring[i].status_n_length &= cpu_to_le32(~DescOwn);\n\n\t \n\tfor (i = 0; i < TX_RING_SIZE; i++){\n\t\tstruct sk_buff *skb;\n\n\t\tif (i >= TX_RING_SIZE - 1)\n\t\t\thmp->tx_ring[i].status_n_length =\n\t\t\t\tcpu_to_le32(DescEndRing) |\n\t\t\t\t(hmp->tx_ring[i].status_n_length &\n\t\t\t\t cpu_to_le32(0x0000ffff));\n\t\telse\n\t\t\thmp->tx_ring[i].status_n_length &= cpu_to_le32(0x0000ffff);\n\t\tskb = hmp->tx_skbuff[i];\n\t\tif (skb){\n\t\t\tdma_unmap_single(&hmp->pci_dev->dev,\n\t\t\t\t\t leXX_to_cpu(hmp->tx_ring[i].addr),\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(skb);\n\t\t\thmp->tx_skbuff[i] = NULL;\n\t\t}\n\t}\n\n\tudelay(60);  \n\twritew(0x0002, ioaddr + RxCmd);  \n\n\twriteb(0x01, ioaddr + ChipReset);   \n\n\thmp->tx_full = 0;\n\thmp->cur_rx = hmp->cur_tx = 0;\n\thmp->dirty_rx = hmp->dirty_tx = 0;\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++){\n\t\tstruct sk_buff *skb = hmp->rx_skbuff[i];\n\n\t\tif (skb){\n\t\t\tdma_unmap_single(&hmp->pci_dev->dev,\n\t\t\t\t\t leXX_to_cpu(hmp->rx_ring[i].addr),\n\t\t\t\t\t hmp->rx_buf_sz, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(skb);\n\t\t\thmp->rx_skbuff[i] = NULL;\n\t\t}\n\t}\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = netdev_alloc_skb_ip_align(dev, hmp->rx_buf_sz);\n\t\thmp->rx_skbuff[i] = skb;\n\t\tif (skb == NULL)\n\t\t\tbreak;\n\n\t\thmp->rx_ring[i].addr = cpu_to_leXX(dma_map_single(&hmp->pci_dev->dev,\n\t\t\t\t\t\t\t\t  skb->data,\n\t\t\t\t\t\t\t\t  hmp->rx_buf_sz,\n\t\t\t\t\t\t\t\t  DMA_FROM_DEVICE));\n\t\thmp->rx_ring[i].status_n_length = cpu_to_le32(DescOwn |\n\t\t\tDescEndPacket | DescIntr | (hmp->rx_buf_sz - 2));\n\t}\n\thmp->dirty_rx = (unsigned int)(i - RX_RING_SIZE);\n\t \n\thmp->rx_ring[RX_RING_SIZE-1].status_n_length |= cpu_to_le32(DescEndRing);\n\n\t \n\tnetif_trans_update(dev);  \n\tdev->stats.tx_errors++;\n\n\t \n\twritew(0x0002, ioaddr + TxCmd);  \n\twritew(0x0001, ioaddr + TxCmd);  \n\twritew(0x0001, ioaddr + RxCmd);  \n\n\tnetif_wake_queue(dev);\n}\n\n\n \nstatic void hamachi_init_ring(struct net_device *dev)\n{\n\tstruct hamachi_private *hmp = netdev_priv(dev);\n\tint i;\n\n\thmp->tx_full = 0;\n\thmp->cur_rx = hmp->cur_tx = 0;\n\thmp->dirty_rx = hmp->dirty_tx = 0;\n\n\t \n\thmp->rx_buf_sz = (dev->mtu <= 1492 ? PKT_BUF_SZ :\n\t\t(((dev->mtu+26+7) & ~7) + 16));\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\thmp->rx_ring[i].status_n_length = 0;\n\t\thmp->rx_skbuff[i] = NULL;\n\t}\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, hmp->rx_buf_sz + 2);\n\t\thmp->rx_skbuff[i] = skb;\n\t\tif (skb == NULL)\n\t\t\tbreak;\n\t\tskb_reserve(skb, 2);  \n\t\thmp->rx_ring[i].addr = cpu_to_leXX(dma_map_single(&hmp->pci_dev->dev,\n\t\t\t\t\t\t\t\t  skb->data,\n\t\t\t\t\t\t\t\t  hmp->rx_buf_sz,\n\t\t\t\t\t\t\t\t  DMA_FROM_DEVICE));\n\t\t \n\t\thmp->rx_ring[i].status_n_length = cpu_to_le32(DescOwn |\n\t\t\tDescEndPacket | DescIntr | (hmp->rx_buf_sz -2));\n\t}\n\thmp->dirty_rx = (unsigned int)(i - RX_RING_SIZE);\n\thmp->rx_ring[RX_RING_SIZE-1].status_n_length |= cpu_to_le32(DescEndRing);\n\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\thmp->tx_skbuff[i] = NULL;\n\t\thmp->tx_ring[i].status_n_length = 0;\n\t}\n\t \n\thmp->tx_ring[TX_RING_SIZE-1].status_n_length |= cpu_to_le32(DescEndRing);\n}\n\n\nstatic netdev_tx_t hamachi_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct hamachi_private *hmp = netdev_priv(dev);\n\tunsigned entry;\n\tu16 status;\n\n\t \n\tif (hmp->tx_full) {\n\t\t \n\t\tprintk(KERN_WARNING \"%s: Hamachi transmit queue full at slot %d.\\n\",dev->name, hmp->cur_tx);\n\n\t\t \n\t\t \n\t\tstatus=readw(hmp->base + TxStatus);\n\t\tif( !(status & 0x0001) || (status & 0x0002))\n\t\t\twritew(0x0001, hmp->base + TxCmd);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\n\t \n\tentry = hmp->cur_tx % TX_RING_SIZE;\n\n\thmp->tx_skbuff[entry] = skb;\n\n\thmp->tx_ring[entry].addr = cpu_to_leXX(dma_map_single(&hmp->pci_dev->dev,\n\t\t\t\t\t\t\t      skb->data,\n\t\t\t\t\t\t\t      skb->len,\n\t\t\t\t\t\t\t      DMA_TO_DEVICE));\n\n\t \n\tif (entry >= TX_RING_SIZE-1)\t\t  \n\t\thmp->tx_ring[entry].status_n_length = cpu_to_le32(DescOwn |\n\t\t\tDescEndPacket | DescEndRing | DescIntr | skb->len);\n\telse\n\t\thmp->tx_ring[entry].status_n_length = cpu_to_le32(DescOwn |\n\t\t\tDescEndPacket | DescIntr | skb->len);\n\thmp->cur_tx++;\n\n\t \n\n\t \n\t \n\tstatus=readw(hmp->base + TxStatus);\n\tif( !(status & 0x0001) || (status & 0x0002))\n\t\twritew(0x0001, hmp->base + TxCmd);\n\n\t \n\thamachi_tx(dev);\n\n\t \n\tif ((hmp->cur_tx - hmp->dirty_tx) < (TX_RING_SIZE - 4))\n\t\tnetif_wake_queue(dev);   \n\telse {\n\t\thmp->tx_full = 1;\n\t\tnetif_stop_queue(dev);\n\t}\n\n\tif (hamachi_debug > 4) {\n\t\tprintk(KERN_DEBUG \"%s: Hamachi transmit frame #%d queued in slot %d.\\n\",\n\t\t\t   dev->name, hmp->cur_tx, entry);\n\t}\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic irqreturn_t hamachi_interrupt(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct hamachi_private *hmp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = hmp->base;\n\tlong boguscnt = max_interrupt_work;\n\tint handled = 0;\n\n#ifndef final_version\t\t\t \n\tif (dev == NULL) {\n\t\tprintk (KERN_ERR \"hamachi_interrupt(): irq %d for unknown device.\\n\", irq);\n\t\treturn IRQ_NONE;\n\t}\n#endif\n\n\tspin_lock(&hmp->lock);\n\n\tdo {\n\t\tu32 intr_status = readl(ioaddr + InterruptClear);\n\n\t\tif (hamachi_debug > 4)\n\t\t\tprintk(KERN_DEBUG \"%s: Hamachi interrupt, status %4.4x.\\n\",\n\t\t\t\t   dev->name, intr_status);\n\n\t\tif (intr_status == 0)\n\t\t\tbreak;\n\n\t\thandled = 1;\n\n\t\tif (intr_status & IntrRxDone)\n\t\t\thamachi_rx(dev);\n\n\t\tif (intr_status & IntrTxDone){\n\t\t\t \n\t\t\tif (hmp->tx_full){\n\t\t\t\tfor (; hmp->cur_tx - hmp->dirty_tx > 0; hmp->dirty_tx++){\n\t\t\t\t\tint entry = hmp->dirty_tx % TX_RING_SIZE;\n\t\t\t\t\tstruct sk_buff *skb;\n\n\t\t\t\t\tif (hmp->tx_ring[entry].status_n_length & cpu_to_le32(DescOwn))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tskb = hmp->tx_skbuff[entry];\n\t\t\t\t\t \n\t\t\t\t\tif (skb){\n\t\t\t\t\t\tdma_unmap_single(&hmp->pci_dev->dev,\n\t\t\t\t\t\t\t\t leXX_to_cpu(hmp->tx_ring[entry].addr),\n\t\t\t\t\t\t\t\t skb->len,\n\t\t\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\t\t\tdev_consume_skb_irq(skb);\n\t\t\t\t\t\thmp->tx_skbuff[entry] = NULL;\n\t\t\t\t\t}\n\t\t\t\t\thmp->tx_ring[entry].status_n_length = 0;\n\t\t\t\t\tif (entry >= TX_RING_SIZE-1)\n\t\t\t\t\t\thmp->tx_ring[TX_RING_SIZE-1].status_n_length |=\n\t\t\t\t\t\t\tcpu_to_le32(DescEndRing);\n\t\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\t}\n\t\t\t\tif (hmp->cur_tx - hmp->dirty_tx < TX_RING_SIZE - 4){\n\t\t\t\t\t \n\t\t\t\t\thmp->tx_full = 0;\n\t\t\t\t\tnetif_wake_queue(dev);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnetif_wake_queue(dev);\n\t\t\t}\n\t\t}\n\n\n\t\t \n\t\tif (intr_status &\n\t\t\t(IntrTxPCIFault | IntrTxPCIErr | IntrRxPCIFault | IntrRxPCIErr |\n\t\t\t LinkChange | NegotiationChange | StatsMax))\n\t\t\thamachi_error(dev, intr_status);\n\n\t\tif (--boguscnt < 0) {\n\t\t\tprintk(KERN_WARNING \"%s: Too much work at interrupt, status=0x%4.4x.\\n\",\n\t\t\t\t   dev->name, intr_status);\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\tif (hamachi_debug > 3)\n\t\tprintk(KERN_DEBUG \"%s: exiting interrupt, status=%#4.4x.\\n\",\n\t\t\t   dev->name, readl(ioaddr + IntrStatus));\n\n#ifndef final_version\n\t \n\t{\n\t\tstatic int stopit = 10;\n\t\tif (dev->start == 0  &&  --stopit < 0) {\n\t\t\tprintk(KERN_ERR \"%s: Emergency stop, looping startup interrupt.\\n\",\n\t\t\t\t   dev->name);\n\t\t\tfree_irq(irq, dev);\n\t\t}\n\t}\n#endif\n\n\tspin_unlock(&hmp->lock);\n\treturn IRQ_RETVAL(handled);\n}\n\n \nstatic int hamachi_rx(struct net_device *dev)\n{\n\tstruct hamachi_private *hmp = netdev_priv(dev);\n\tint entry = hmp->cur_rx % RX_RING_SIZE;\n\tint boguscnt = (hmp->dirty_rx + RX_RING_SIZE) - hmp->cur_rx;\n\n\tif (hamachi_debug > 4) {\n\t\tprintk(KERN_DEBUG \" In hamachi_rx(), entry %d status %4.4x.\\n\",\n\t\t\t   entry, hmp->rx_ring[entry].status_n_length);\n\t}\n\n\t \n\twhile (1) {\n\t\tstruct hamachi_desc *desc = &(hmp->rx_ring[entry]);\n\t\tu32 desc_status = le32_to_cpu(desc->status_n_length);\n\t\tu16 data_size = desc_status;\t \n\t\tu8 *buf_addr;\n\t\ts32 frame_status;\n\n\t\tif (desc_status & DescOwn)\n\t\t\tbreak;\n\t\tdma_sync_single_for_cpu(&hmp->pci_dev->dev,\n\t\t\t\t\tleXX_to_cpu(desc->addr),\n\t\t\t\t\thmp->rx_buf_sz, DMA_FROM_DEVICE);\n\t\tbuf_addr = (u8 *) hmp->rx_skbuff[entry]->data;\n\t\tframe_status = get_unaligned_le32(&(buf_addr[data_size - 12]));\n\t\tif (hamachi_debug > 4)\n\t\t\tprintk(KERN_DEBUG \"  hamachi_rx() status was %8.8x.\\n\",\n\t\t\t\tframe_status);\n\t\tif (--boguscnt < 0)\n\t\t\tbreak;\n\t\tif ( ! (desc_status & DescEndPacket)) {\n\t\t\tprintk(KERN_WARNING \"%s: Oversized Ethernet frame spanned \"\n\t\t\t\t   \"multiple buffers, entry %#x length %d status %4.4x!\\n\",\n\t\t\t\t   dev->name, hmp->cur_rx, data_size, desc_status);\n\t\t\tprintk(KERN_WARNING \"%s: Oversized Ethernet frame %p vs %p.\\n\",\n\t\t\t\t   dev->name, desc, &hmp->rx_ring[hmp->cur_rx % RX_RING_SIZE]);\n\t\t\tprintk(KERN_WARNING \"%s: Oversized Ethernet frame -- next status %x/%x last status %x.\\n\",\n\t\t\t\t   dev->name,\n\t\t\t\t   le32_to_cpu(hmp->rx_ring[(hmp->cur_rx+1) % RX_RING_SIZE].status_n_length) & 0xffff0000,\n\t\t\t\t   le32_to_cpu(hmp->rx_ring[(hmp->cur_rx+1) % RX_RING_SIZE].status_n_length) & 0x0000ffff,\n\t\t\t\t   le32_to_cpu(hmp->rx_ring[(hmp->cur_rx-1) % RX_RING_SIZE].status_n_length));\n\t\t\tdev->stats.rx_length_errors++;\n\t\t}  \n\t\tif (frame_status & 0x00380000) {\n\t\t\t \n\t\t\tif (hamachi_debug > 2)\n\t\t\t\tprintk(KERN_DEBUG \"  hamachi_rx() Rx error was %8.8x.\\n\",\n\t\t\t\t\t   frame_status);\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (frame_status & 0x00600000)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\tif (frame_status & 0x00080000)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\tif (frame_status & 0x00100000)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (frame_status < 0)\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t} else {\n\t\t\tstruct sk_buff *skb;\n\t\t\t \n\t\t\tu16 pkt_len = (frame_status & 0x07ff) - 4;\n#ifdef RX_CHECKSUM\n\t\t\tu32 pfck = *(u32 *) &buf_addr[data_size - 8];\n#endif\n\n\n#ifndef final_version\n\t\t\tif (hamachi_debug > 4)\n\t\t\t\tprintk(KERN_DEBUG \"  hamachi_rx() normal Rx pkt length %d\"\n\t\t\t\t\t   \" of %d, bogus_cnt %d.\\n\",\n\t\t\t\t\t   pkt_len, data_size, boguscnt);\n\t\t\tif (hamachi_debug > 5)\n\t\t\t\tprintk(KERN_DEBUG\"%s:  rx status %8.8x %8.8x %8.8x %8.8x %8.8x.\\n\",\n\t\t\t\t\t   dev->name,\n\t\t\t\t\t   *(s32*)&(buf_addr[data_size - 20]),\n\t\t\t\t\t   *(s32*)&(buf_addr[data_size - 16]),\n\t\t\t\t\t   *(s32*)&(buf_addr[data_size - 12]),\n\t\t\t\t\t   *(s32*)&(buf_addr[data_size - 8]),\n\t\t\t\t\t   *(s32*)&(buf_addr[data_size - 4]));\n#endif\n\t\t\t \n\t\t\tif (pkt_len < rx_copybreak &&\n\t\t\t    (skb = netdev_alloc_skb(dev, pkt_len + 2)) != NULL) {\n#ifdef RX_CHECKSUM\n\t\t\t\tprintk(KERN_ERR \"%s: rx_copybreak non-zero \"\n\t\t\t\t  \"not good with RX_CHECKSUM\\n\", dev->name);\n#endif\n\t\t\t\tskb_reserve(skb, 2);\t \n\t\t\t\tdma_sync_single_for_cpu(&hmp->pci_dev->dev,\n\t\t\t\t\t\t\tleXX_to_cpu(hmp->rx_ring[entry].addr),\n\t\t\t\t\t\t\thmp->rx_buf_sz,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\t \n#if 1 || USE_IP_COPYSUM\n\t\t\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t\thmp->rx_skbuff[entry]->data, pkt_len);\n\t\t\t\tskb_put(skb, pkt_len);\n#else\n\t\t\t\tskb_put_data(skb, hmp->rx_ring_dma\n\t\t\t\t\t     + entry*sizeof(*desc), pkt_len);\n#endif\n\t\t\t\tdma_sync_single_for_device(&hmp->pci_dev->dev,\n\t\t\t\t\t\t\t   leXX_to_cpu(hmp->rx_ring[entry].addr),\n\t\t\t\t\t\t\t   hmp->rx_buf_sz,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\t} else {\n\t\t\t\tdma_unmap_single(&hmp->pci_dev->dev,\n\t\t\t\t\t\t leXX_to_cpu(hmp->rx_ring[entry].addr),\n\t\t\t\t\t\t hmp->rx_buf_sz,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tskb_put(skb = hmp->rx_skbuff[entry], pkt_len);\n\t\t\t\thmp->rx_skbuff[entry] = NULL;\n\t\t\t}\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\n\n#ifdef RX_CHECKSUM\n\t\t\t \n\t\t\tif (pfck>>24 == 0x91 || pfck>>24 == 0x51) {\n\t\t\t\tstruct iphdr *ih = (struct iphdr *) skb->data;\n\t\t\t\t \n\t\t\t\tif (ntohs(ih->tot_len) >= 46){\n\t\t\t\t\t \n\t\t\t\t\tif (!(ih->frag_off & cpu_to_be16(IP_MF|IP_OFFSET))) {\n\t\t\t\t\t\tu32 inv = *(u32 *) &buf_addr[data_size - 16];\n\t\t\t\t\t\tu32 *p = (u32 *) &buf_addr[data_size - 20];\n\t\t\t\t\t\tregister u32 crc, p_r, p_r1;\n\n\t\t\t\t\t\tif (inv & 4) {\n\t\t\t\t\t\t\tinv &= ~4;\n\t\t\t\t\t\t\t--p;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp_r = *p;\n\t\t\t\t\t\tp_r1 = *(p-1);\n\t\t\t\t\t\tswitch (inv) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tcrc = (p_r & 0xffff) + (p_r >> 16);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tcrc = (p_r >> 16) + (p_r & 0xffff)\n\t\t\t\t\t\t\t\t\t+ (p_r1 >> 16 & 0xff00);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tcrc = p_r + (p_r1 >> 16);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tcrc = p_r + (p_r1 & 0xff00) + (p_r1 >> 16);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\t  crc = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (crc & 0xffff0000) {\n\t\t\t\t\t\t\tcrc &= 0xffff;\n\t\t\t\t\t\t\t++crc;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t \n\t\t\t\t\t\tskb->csum = ntohs(pfck & 0xffff);\n\t\t\t\t\t\tif (skb->csum > crc)\n\t\t\t\t\t\t\tskb->csum -= crc;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tskb->csum += (~crc & 0xffff);\n\t\t\t\t\t\t \n\t\t\t\t\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif   \n\n\t\t\tnetif_rx(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t}\n\t\tentry = (++hmp->cur_rx) % RX_RING_SIZE;\n\t}\n\n\t \n\tfor (; hmp->cur_rx - hmp->dirty_rx > 0; hmp->dirty_rx++) {\n\t\tstruct hamachi_desc *desc;\n\n\t\tentry = hmp->dirty_rx % RX_RING_SIZE;\n\t\tdesc = &(hmp->rx_ring[entry]);\n\t\tif (hmp->rx_skbuff[entry] == NULL) {\n\t\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, hmp->rx_buf_sz + 2);\n\n\t\t\thmp->rx_skbuff[entry] = skb;\n\t\t\tif (skb == NULL)\n\t\t\t\tbreak;\t\t \n\t\t\tskb_reserve(skb, 2);\t \n\t\t\tdesc->addr = cpu_to_leXX(dma_map_single(&hmp->pci_dev->dev,\n\t\t\t\t\t\t\t\tskb->data,\n\t\t\t\t\t\t\t\thmp->rx_buf_sz,\n\t\t\t\t\t\t\t\tDMA_FROM_DEVICE));\n\t\t}\n\t\tdesc->status_n_length = cpu_to_le32(hmp->rx_buf_sz);\n\t\tif (entry >= RX_RING_SIZE-1)\n\t\t\tdesc->status_n_length |= cpu_to_le32(DescOwn |\n\t\t\t\tDescEndPacket | DescEndRing | DescIntr);\n\t\telse\n\t\t\tdesc->status_n_length |= cpu_to_le32(DescOwn |\n\t\t\t\tDescEndPacket | DescIntr);\n\t}\n\n\t \n\t \n\tif (readw(hmp->base + RxStatus) & 0x0002)\n\t\twritew(0x0001, hmp->base + RxCmd);\n\n\treturn 0;\n}\n\n \nstatic void hamachi_error(struct net_device *dev, int intr_status)\n{\n\tstruct hamachi_private *hmp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = hmp->base;\n\n\tif (intr_status & (LinkChange|NegotiationChange)) {\n\t\tif (hamachi_debug > 1)\n\t\t\tprintk(KERN_INFO \"%s: Link changed: AutoNegotiation Ctrl\"\n\t\t\t\t   \" %4.4x, Status %4.4x %4.4x Intr status %4.4x.\\n\",\n\t\t\t\t   dev->name, readw(ioaddr + 0x0E0), readw(ioaddr + 0x0E2),\n\t\t\t\t   readw(ioaddr + ANLinkPartnerAbility),\n\t\t\t\t   readl(ioaddr + IntrStatus));\n\t\tif (readw(ioaddr + ANStatus) & 0x20)\n\t\t\twriteb(0x01, ioaddr + LEDCtrl);\n\t\telse\n\t\t\twriteb(0x03, ioaddr + LEDCtrl);\n\t}\n\tif (intr_status & StatsMax) {\n\t\thamachi_get_stats(dev);\n\t\t \n\t\treadl(ioaddr + 0x370);\n\t\treadl(ioaddr + 0x3F0);\n\t}\n\tif ((intr_status & ~(LinkChange|StatsMax|NegotiationChange|IntrRxDone|IntrTxDone)) &&\n\t    hamachi_debug)\n\t\tprintk(KERN_ERR \"%s: Something Wicked happened! %4.4x.\\n\",\n\t\t       dev->name, intr_status);\n\t \n\tif (intr_status & (IntrTxPCIErr | IntrTxPCIFault))\n\t\tdev->stats.tx_fifo_errors++;\n\tif (intr_status & (IntrRxPCIErr | IntrRxPCIFault))\n\t\tdev->stats.rx_fifo_errors++;\n}\n\nstatic int hamachi_close(struct net_device *dev)\n{\n\tstruct hamachi_private *hmp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = hmp->base;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tnetif_stop_queue(dev);\n\n\tif (hamachi_debug > 1) {\n\t\tprintk(KERN_DEBUG \"%s: Shutting down ethercard, status was Tx %4.4x Rx %4.4x Int %2.2x.\\n\",\n\t\t\t   dev->name, readw(ioaddr + TxStatus),\n\t\t\t   readw(ioaddr + RxStatus), readl(ioaddr + IntrStatus));\n\t\tprintk(KERN_DEBUG \"%s: Queue pointers were Tx %d / %d,  Rx %d / %d.\\n\",\n\t\t\t   dev->name, hmp->cur_tx, hmp->dirty_tx, hmp->cur_rx, hmp->dirty_rx);\n\t}\n\n\t \n\twritel(0x0000, ioaddr + InterruptEnable);\n\n\t \n\twritel(2, ioaddr + RxCmd);\n\twritew(2, ioaddr + TxCmd);\n\n#ifdef __i386__\n\tif (hamachi_debug > 2) {\n\t\tprintk(KERN_DEBUG \"  Tx ring at %8.8x:\\n\",\n\t\t\t   (int)hmp->tx_ring_dma);\n\t\tfor (i = 0; i < TX_RING_SIZE; i++)\n\t\t\tprintk(KERN_DEBUG \" %c #%d desc. %8.8x %8.8x.\\n\",\n\t\t\t\t   readl(ioaddr + TxCurPtr) == (long)&hmp->tx_ring[i] ? '>' : ' ',\n\t\t\t\t   i, hmp->tx_ring[i].status_n_length, hmp->tx_ring[i].addr);\n\t\tprintk(KERN_DEBUG \"  Rx ring %8.8x:\\n\",\n\t\t\t   (int)hmp->rx_ring_dma);\n\t\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\t\tprintk(KERN_DEBUG \" %c #%d desc. %4.4x %8.8x\\n\",\n\t\t\t\t   readl(ioaddr + RxCurPtr) == (long)&hmp->rx_ring[i] ? '>' : ' ',\n\t\t\t\t   i, hmp->rx_ring[i].status_n_length, hmp->rx_ring[i].addr);\n\t\t\tif (hamachi_debug > 6) {\n\t\t\t\tif (*(u8*)hmp->rx_skbuff[i]->data != 0x69) {\n\t\t\t\t\tu16 *addr = (u16 *)\n\t\t\t\t\t\thmp->rx_skbuff[i]->data;\n\t\t\t\t\tint j;\n\t\t\t\t\tprintk(KERN_DEBUG \"Addr: \");\n\t\t\t\t\tfor (j = 0; j < 0x50; j++)\n\t\t\t\t\t\tprintk(\" %4.4x\", addr[j]);\n\t\t\t\t\tprintk(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif  \n\n\tfree_irq(hmp->pci_dev->irq, dev);\n\n\tdel_timer_sync(&hmp->timer);\n\n\t \n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tskb = hmp->rx_skbuff[i];\n\t\thmp->rx_ring[i].status_n_length = 0;\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&hmp->pci_dev->dev,\n\t\t\t\t\t leXX_to_cpu(hmp->rx_ring[i].addr),\n\t\t\t\t\t hmp->rx_buf_sz, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(skb);\n\t\t\thmp->rx_skbuff[i] = NULL;\n\t\t}\n\t\thmp->rx_ring[i].addr = cpu_to_leXX(0xBADF00D0);  \n\t}\n\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\tskb = hmp->tx_skbuff[i];\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&hmp->pci_dev->dev,\n\t\t\t\t\t leXX_to_cpu(hmp->tx_ring[i].addr),\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(skb);\n\t\t\thmp->tx_skbuff[i] = NULL;\n\t\t}\n\t}\n\n\twriteb(0x00, ioaddr + LEDCtrl);\n\n\treturn 0;\n}\n\nstatic struct net_device_stats *hamachi_get_stats(struct net_device *dev)\n{\n\tstruct hamachi_private *hmp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = hmp->base;\n\n\t \n         \n\t \n\n\t \n\tdev->stats.rx_bytes = readl(ioaddr + 0x330);\n\t \n\tdev->stats.tx_bytes = readl(ioaddr + 0x3B0);\n\t \n\tdev->stats.multicast = readl(ioaddr + 0x320);\n\n\t \n\tdev->stats.rx_length_errors = readl(ioaddr + 0x368);\n\t \n\tdev->stats.rx_over_errors = readl(ioaddr + 0x35C);\n\t \n\tdev->stats.rx_crc_errors = readl(ioaddr + 0x360);\n\t \n\tdev->stats.rx_frame_errors = readl(ioaddr + 0x364);\n\t \n\tdev->stats.rx_missed_errors = readl(ioaddr + 0x36C);\n\n\treturn &dev->stats;\n}\n\nstatic void set_rx_mode(struct net_device *dev)\n{\n\tstruct hamachi_private *hmp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = hmp->base;\n\n\tif (dev->flags & IFF_PROMISC) {\t\t\t \n\t\twritew(0x000F, ioaddr + AddrMode);\n\t} else if ((netdev_mc_count(dev) > 63) || (dev->flags & IFF_ALLMULTI)) {\n\t\t \n\t\twritew(0x000B, ioaddr + AddrMode);\n\t} else if (!netdev_mc_empty(dev)) {  \n\t\tstruct netdev_hw_addr *ha;\n\t\tint i = 0;\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\twritel(*(u32 *)(ha->addr), ioaddr + 0x100 + i*8);\n\t\t\twritel(0x20000 | (*(u16 *)&ha->addr[4]),\n\t\t\t\t   ioaddr + 0x104 + i*8);\n\t\t\ti++;\n\t\t}\n\t\t \n\t\tfor (; i < 64; i++)\n\t\t\twritel(0, ioaddr + 0x104 + i*8);\n\t\twritew(0x0003, ioaddr + AddrMode);\n\t} else {\t\t\t\t\t \n\t\twritew(0x0001, ioaddr + AddrMode);\n\t}\n}\n\nstatic int check_if_running(struct net_device *dev)\n{\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void hamachi_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct hamachi_private *np = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(np->pci_dev), sizeof(info->bus_info));\n}\n\nstatic int hamachi_get_link_ksettings(struct net_device *dev,\n\t\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tstruct hamachi_private *np = netdev_priv(dev);\n\tspin_lock_irq(&np->lock);\n\tmii_ethtool_get_link_ksettings(&np->mii_if, cmd);\n\tspin_unlock_irq(&np->lock);\n\treturn 0;\n}\n\nstatic int hamachi_set_link_ksettings(struct net_device *dev,\n\t\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct hamachi_private *np = netdev_priv(dev);\n\tint res;\n\tspin_lock_irq(&np->lock);\n\tres = mii_ethtool_set_link_ksettings(&np->mii_if, cmd);\n\tspin_unlock_irq(&np->lock);\n\treturn res;\n}\n\nstatic int hamachi_nway_reset(struct net_device *dev)\n{\n\tstruct hamachi_private *np = netdev_priv(dev);\n\treturn mii_nway_restart(&np->mii_if);\n}\n\nstatic u32 hamachi_get_link(struct net_device *dev)\n{\n\tstruct hamachi_private *np = netdev_priv(dev);\n\treturn mii_link_ok(&np->mii_if);\n}\n\nstatic const struct ethtool_ops ethtool_ops = {\n\t.begin = check_if_running,\n\t.get_drvinfo = hamachi_get_drvinfo,\n\t.nway_reset = hamachi_nway_reset,\n\t.get_link = hamachi_get_link,\n\t.get_link_ksettings = hamachi_get_link_ksettings,\n\t.set_link_ksettings = hamachi_set_link_ksettings,\n};\n\nstatic const struct ethtool_ops ethtool_ops_no_mii = {\n\t.begin = check_if_running,\n\t.get_drvinfo = hamachi_get_drvinfo,\n};\n\n \nstatic int hamachi_siocdevprivate(struct net_device *dev, struct ifreq *rq,\n\t\t\t\t  void __user *data, int cmd)\n{\n\tstruct hamachi_private *np = netdev_priv(dev);\n\tu32 *d = (u32 *)&rq->ifr_ifru;\n\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\n\tif (cmd != SIOCDEVPRIVATE + 3)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\twritel(d[0], np->base + TxIntrCtrl);\n\twritel(d[1], np->base + RxIntrCtrl);\n\tprintk(KERN_NOTICE \"%s: tx %08x, rx %08x intr\\n\", dev->name,\n\t       (u32)readl(np->base + TxIntrCtrl),\n\t       (u32)readl(np->base + RxIntrCtrl));\n\n\treturn 0;\n}\n\nstatic int hamachi_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct hamachi_private *np = netdev_priv(dev);\n\tstruct mii_ioctl_data *data = if_mii(rq);\n\tint rc;\n\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&np->lock);\n\trc = generic_mii_ioctl(&np->mii_if, data, cmd, NULL);\n\tspin_unlock_irq(&np->lock);\n\n\treturn rc;\n}\n\n\nstatic void hamachi_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tif (dev) {\n\t\tstruct hamachi_private *hmp = netdev_priv(dev);\n\n\t\tdma_free_coherent(&pdev->dev, RX_TOTAL_SIZE, hmp->rx_ring,\n\t\t\t\t  hmp->rx_ring_dma);\n\t\tdma_free_coherent(&pdev->dev, TX_TOTAL_SIZE, hmp->tx_ring,\n\t\t\t\t  hmp->tx_ring_dma);\n\t\tunregister_netdev(dev);\n\t\tiounmap(hmp->base);\n\t\tfree_netdev(dev);\n\t\tpci_release_regions(pdev);\n\t}\n}\n\nstatic const struct pci_device_id hamachi_pci_tbl[] = {\n\t{ 0x1318, 0x0911, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, hamachi_pci_tbl);\n\nstatic struct pci_driver hamachi_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= hamachi_pci_tbl,\n\t.probe\t\t= hamachi_init_one,\n\t.remove\t\t= hamachi_remove_one,\n};\n\nstatic int __init hamachi_init (void)\n{\n \n#ifdef MODULE\n\tprintk(version);\n#endif\n\treturn pci_register_driver(&hamachi_driver);\n}\n\nstatic void __exit hamachi_exit (void)\n{\n\tpci_unregister_driver(&hamachi_driver);\n}\n\n\nmodule_init(hamachi_init);\nmodule_exit(hamachi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}