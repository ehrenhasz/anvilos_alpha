{
  "module_name": "lantiq_etop.c",
  "hash_id": "790025f6cd0fa4224a62719593a8a17e7d71ebb3af970fdfd79f0771f4d3c421",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/lantiq_etop.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/uaccess.h>\n#include <linux/in.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/phy.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/skbuff.h>\n#include <linux/mm.h>\n#include <linux/platform_device.h>\n#include <linux/ethtool.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/property.h>\n\n#include <asm/checksum.h>\n\n#include <lantiq_soc.h>\n#include <xway_dma.h>\n#include <lantiq_platform.h>\n\n#define LTQ_ETOP_MDIO\t\t0x11804\n#define MDIO_REQUEST\t\t0x80000000\n#define MDIO_READ\t\t0x40000000\n#define MDIO_ADDR_MASK\t\t0x1f\n#define MDIO_ADDR_OFFSET\t0x15\n#define MDIO_REG_MASK\t\t0x1f\n#define MDIO_REG_OFFSET\t\t0x10\n#define MDIO_VAL_MASK\t\t0xffff\n\n#define PPE32_CGEN\t\t0x800\n#define LQ_PPE32_ENET_MAC_CFG\t0x1840\n\n#define LTQ_ETOP_ENETS0\t\t0x11850\n#define LTQ_ETOP_MAC_DA0\t0x1186C\n#define LTQ_ETOP_MAC_DA1\t0x11870\n#define LTQ_ETOP_CFG\t\t0x16020\n#define LTQ_ETOP_IGPLEN\t\t0x16080\n\n#define MAX_DMA_CHAN\t\t0x8\n#define MAX_DMA_CRC_LEN\t\t0x4\n#define MAX_DMA_DATA_LEN\t0x600\n\n#define ETOP_FTCU\t\tBIT(28)\n#define ETOP_MII_MASK\t\t0xf\n#define ETOP_MII_NORMAL\t\t0xd\n#define ETOP_MII_REVERSE\t0xe\n#define ETOP_PLEN_UNDER\t\t0x40\n#define ETOP_CGEN\t\t0x800\n\n \n#define LTQ_ETOP_TX_CHANNEL\t1\n#define LTQ_ETOP_RX_CHANNEL\t6\n#define IS_TX(x)\t\t((x) == LTQ_ETOP_TX_CHANNEL)\n#define IS_RX(x)\t\t((x) == LTQ_ETOP_RX_CHANNEL)\n\n#define ltq_etop_r32(x)\t\tltq_r32(ltq_etop_membase + (x))\n#define ltq_etop_w32(x, y)\tltq_w32(x, ltq_etop_membase + (y))\n#define ltq_etop_w32_mask(x, y, z)\t\\\n\t\tltq_w32_mask(x, y, ltq_etop_membase + (z))\n\n#define DRV_VERSION\t\"1.0\"\n\nstatic void __iomem *ltq_etop_membase;\n\nstruct ltq_etop_chan {\n\tint idx;\n\tint tx_free;\n\tstruct net_device *netdev;\n\tstruct napi_struct napi;\n\tstruct ltq_dma_channel dma;\n\tstruct sk_buff *skb[LTQ_DESC_NUM];\n};\n\nstruct ltq_etop_priv {\n\tstruct net_device *netdev;\n\tstruct platform_device *pdev;\n\tstruct ltq_eth_data *pldata;\n\tstruct resource *res;\n\n\tstruct mii_bus *mii_bus;\n\n\tstruct ltq_etop_chan ch[MAX_DMA_CHAN];\n\tint tx_free[MAX_DMA_CHAN >> 1];\n\n\tint tx_burst_len;\n\tint rx_burst_len;\n\n\tspinlock_t lock;\n};\n\nstatic int\nltq_etop_alloc_skb(struct ltq_etop_chan *ch)\n{\n\tstruct ltq_etop_priv *priv = netdev_priv(ch->netdev);\n\n\tch->skb[ch->dma.desc] = netdev_alloc_skb(ch->netdev, MAX_DMA_DATA_LEN);\n\tif (!ch->skb[ch->dma.desc])\n\t\treturn -ENOMEM;\n\tch->dma.desc_base[ch->dma.desc].addr =\n\t\tdma_map_single(&priv->pdev->dev, ch->skb[ch->dma.desc]->data,\n\t\t\t       MAX_DMA_DATA_LEN, DMA_FROM_DEVICE);\n\tch->dma.desc_base[ch->dma.desc].addr =\n\t\tCPHYSADDR(ch->skb[ch->dma.desc]->data);\n\tch->dma.desc_base[ch->dma.desc].ctl =\n\t\tLTQ_DMA_OWN | LTQ_DMA_RX_OFFSET(NET_IP_ALIGN) |\n\t\tMAX_DMA_DATA_LEN;\n\tskb_reserve(ch->skb[ch->dma.desc], NET_IP_ALIGN);\n\treturn 0;\n}\n\nstatic void\nltq_etop_hw_receive(struct ltq_etop_chan *ch)\n{\n\tstruct ltq_etop_priv *priv = netdev_priv(ch->netdev);\n\tstruct ltq_dma_desc *desc = &ch->dma.desc_base[ch->dma.desc];\n\tstruct sk_buff *skb = ch->skb[ch->dma.desc];\n\tint len = (desc->ctl & LTQ_DMA_SIZE_MASK) - MAX_DMA_CRC_LEN;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (ltq_etop_alloc_skb(ch)) {\n\t\tnetdev_err(ch->netdev,\n\t\t\t   \"failed to allocate new rx buffer, stopping DMA\\n\");\n\t\tltq_dma_close(&ch->dma);\n\t}\n\tch->dma.desc++;\n\tch->dma.desc %= LTQ_DESC_NUM;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tskb_put(skb, len);\n\tskb->protocol = eth_type_trans(skb, ch->netdev);\n\tnetif_receive_skb(skb);\n}\n\nstatic int\nltq_etop_poll_rx(struct napi_struct *napi, int budget)\n{\n\tstruct ltq_etop_chan *ch = container_of(napi,\n\t\t\t\tstruct ltq_etop_chan, napi);\n\tint work_done = 0;\n\n\twhile (work_done < budget) {\n\t\tstruct ltq_dma_desc *desc = &ch->dma.desc_base[ch->dma.desc];\n\n\t\tif ((desc->ctl & (LTQ_DMA_OWN | LTQ_DMA_C)) != LTQ_DMA_C)\n\t\t\tbreak;\n\t\tltq_etop_hw_receive(ch);\n\t\twork_done++;\n\t}\n\tif (work_done < budget) {\n\t\tnapi_complete_done(&ch->napi, work_done);\n\t\tltq_dma_ack_irq(&ch->dma);\n\t}\n\treturn work_done;\n}\n\nstatic int\nltq_etop_poll_tx(struct napi_struct *napi, int budget)\n{\n\tstruct ltq_etop_chan *ch =\n\t\tcontainer_of(napi, struct ltq_etop_chan, napi);\n\tstruct ltq_etop_priv *priv = netdev_priv(ch->netdev);\n\tstruct netdev_queue *txq =\n\t\tnetdev_get_tx_queue(ch->netdev, ch->idx >> 1);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\twhile ((ch->dma.desc_base[ch->tx_free].ctl &\n\t\t\t(LTQ_DMA_OWN | LTQ_DMA_C)) == LTQ_DMA_C) {\n\t\tdev_kfree_skb_any(ch->skb[ch->tx_free]);\n\t\tch->skb[ch->tx_free] = NULL;\n\t\tmemset(&ch->dma.desc_base[ch->tx_free], 0,\n\t\t       sizeof(struct ltq_dma_desc));\n\t\tch->tx_free++;\n\t\tch->tx_free %= LTQ_DESC_NUM;\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tif (netif_tx_queue_stopped(txq))\n\t\tnetif_tx_start_queue(txq);\n\tnapi_complete(&ch->napi);\n\tltq_dma_ack_irq(&ch->dma);\n\treturn 1;\n}\n\nstatic irqreturn_t\nltq_etop_dma_irq(int irq, void *_priv)\n{\n\tstruct ltq_etop_priv *priv = _priv;\n\tint ch = irq - LTQ_DMA_CH0_INT;\n\n\tnapi_schedule(&priv->ch[ch].napi);\n\treturn IRQ_HANDLED;\n}\n\nstatic void\nltq_etop_free_channel(struct net_device *dev, struct ltq_etop_chan *ch)\n{\n\tstruct ltq_etop_priv *priv = netdev_priv(dev);\n\n\tltq_dma_free(&ch->dma);\n\tif (ch->dma.irq)\n\t\tfree_irq(ch->dma.irq, priv);\n\tif (IS_RX(ch->idx)) {\n\t\tint desc;\n\n\t\tfor (desc = 0; desc < LTQ_DESC_NUM; desc++)\n\t\t\tdev_kfree_skb_any(ch->skb[ch->dma.desc]);\n\t}\n}\n\nstatic void\nltq_etop_hw_exit(struct net_device *dev)\n{\n\tstruct ltq_etop_priv *priv = netdev_priv(dev);\n\tint i;\n\n\tltq_pmu_disable(PMU_PPE);\n\tfor (i = 0; i < MAX_DMA_CHAN; i++)\n\t\tif (IS_TX(i) || IS_RX(i))\n\t\t\tltq_etop_free_channel(dev, &priv->ch[i]);\n}\n\nstatic int\nltq_etop_hw_init(struct net_device *dev)\n{\n\tstruct ltq_etop_priv *priv = netdev_priv(dev);\n\tint i;\n\tint err;\n\n\tltq_pmu_enable(PMU_PPE);\n\n\tswitch (priv->pldata->mii_mode) {\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tltq_etop_w32_mask(ETOP_MII_MASK, ETOP_MII_REVERSE,\n\t\t\t\t  LTQ_ETOP_CFG);\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tltq_etop_w32_mask(ETOP_MII_MASK, ETOP_MII_NORMAL,\n\t\t\t\t  LTQ_ETOP_CFG);\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_err(dev, \"unknown mii mode %d\\n\",\n\t\t\t   priv->pldata->mii_mode);\n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\tltq_etop_w32(PPE32_CGEN, LQ_PPE32_ENET_MAC_CFG);\n\n\tltq_dma_init_port(DMA_PORT_ETOP, priv->tx_burst_len, priv->rx_burst_len);\n\n\tfor (i = 0; i < MAX_DMA_CHAN; i++) {\n\t\tint irq = LTQ_DMA_CH0_INT + i;\n\t\tstruct ltq_etop_chan *ch = &priv->ch[i];\n\n\t\tch->dma.nr = i;\n\t\tch->idx = ch->dma.nr;\n\t\tch->dma.dev = &priv->pdev->dev;\n\n\t\tif (IS_TX(i)) {\n\t\t\tltq_dma_alloc_tx(&ch->dma);\n\t\t\terr = request_irq(irq, ltq_etop_dma_irq, 0, \"etop_tx\", priv);\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(dev,\n\t\t\t\t\t   \"Unable to get Tx DMA IRQ %d\\n\",\n\t\t\t\t\t   irq);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (IS_RX(i)) {\n\t\t\tltq_dma_alloc_rx(&ch->dma);\n\t\t\tfor (ch->dma.desc = 0; ch->dma.desc < LTQ_DESC_NUM;\n\t\t\t\t\tch->dma.desc++)\n\t\t\t\tif (ltq_etop_alloc_skb(ch))\n\t\t\t\t\treturn -ENOMEM;\n\t\t\tch->dma.desc = 0;\n\t\t\terr = request_irq(irq, ltq_etop_dma_irq, 0, \"etop_rx\", priv);\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(dev,\n\t\t\t\t\t   \"Unable to get Rx DMA IRQ %d\\n\",\n\t\t\t\t\t   irq);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tch->dma.irq = irq;\n\t}\n\treturn 0;\n}\n\nstatic void\nltq_etop_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, \"Lantiq ETOP\", sizeof(info->driver));\n\tstrscpy(info->bus_info, \"internal\", sizeof(info->bus_info));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n}\n\nstatic const struct ethtool_ops ltq_etop_ethtool_ops = {\n\t.get_drvinfo = ltq_etop_get_drvinfo,\n\t.nway_reset = phy_ethtool_nway_reset,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\nstatic int\nltq_etop_mdio_wr(struct mii_bus *bus, int phy_addr, int phy_reg, u16 phy_data)\n{\n\tu32 val = MDIO_REQUEST |\n\t\t((phy_addr & MDIO_ADDR_MASK) << MDIO_ADDR_OFFSET) |\n\t\t((phy_reg & MDIO_REG_MASK) << MDIO_REG_OFFSET) |\n\t\tphy_data;\n\n\twhile (ltq_etop_r32(LTQ_ETOP_MDIO) & MDIO_REQUEST)\n\t\t;\n\tltq_etop_w32(val, LTQ_ETOP_MDIO);\n\treturn 0;\n}\n\nstatic int\nltq_etop_mdio_rd(struct mii_bus *bus, int phy_addr, int phy_reg)\n{\n\tu32 val = MDIO_REQUEST | MDIO_READ |\n\t\t((phy_addr & MDIO_ADDR_MASK) << MDIO_ADDR_OFFSET) |\n\t\t((phy_reg & MDIO_REG_MASK) << MDIO_REG_OFFSET);\n\n\twhile (ltq_etop_r32(LTQ_ETOP_MDIO) & MDIO_REQUEST)\n\t\t;\n\tltq_etop_w32(val, LTQ_ETOP_MDIO);\n\twhile (ltq_etop_r32(LTQ_ETOP_MDIO) & MDIO_REQUEST)\n\t\t;\n\tval = ltq_etop_r32(LTQ_ETOP_MDIO) & MDIO_VAL_MASK;\n\treturn val;\n}\n\nstatic void\nltq_etop_mdio_link(struct net_device *dev)\n{\n\t \n}\n\nstatic int\nltq_etop_mdio_probe(struct net_device *dev)\n{\n\tstruct ltq_etop_priv *priv = netdev_priv(dev);\n\tstruct phy_device *phydev;\n\n\tphydev = phy_find_first(priv->mii_bus);\n\n\tif (!phydev) {\n\t\tnetdev_err(dev, \"no PHY found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tphydev = phy_connect(dev, phydev_name(phydev),\n\t\t\t     &ltq_etop_mdio_link, priv->pldata->mii_mode);\n\n\tif (IS_ERR(phydev)) {\n\t\tnetdev_err(dev, \"Could not attach to PHY\\n\");\n\t\treturn PTR_ERR(phydev);\n\t}\n\n\tphy_set_max_speed(phydev, SPEED_100);\n\n\tphy_attached_info(phydev);\n\n\treturn 0;\n}\n\nstatic int\nltq_etop_mdio_init(struct net_device *dev)\n{\n\tstruct ltq_etop_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus) {\n\t\tnetdev_err(dev, \"failed to allocate mii bus\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tpriv->mii_bus->priv = dev;\n\tpriv->mii_bus->read = ltq_etop_mdio_rd;\n\tpriv->mii_bus->write = ltq_etop_mdio_wr;\n\tpriv->mii_bus->name = \"ltq_mii\";\n\tsnprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, \"%s-%x\",\n\t\t priv->pdev->name, priv->pdev->id);\n\tif (mdiobus_register(priv->mii_bus)) {\n\t\terr = -ENXIO;\n\t\tgoto err_out_free_mdiobus;\n\t}\n\n\tif (ltq_etop_mdio_probe(dev)) {\n\t\terr = -ENXIO;\n\t\tgoto err_out_unregister_bus;\n\t}\n\treturn 0;\n\nerr_out_unregister_bus:\n\tmdiobus_unregister(priv->mii_bus);\nerr_out_free_mdiobus:\n\tmdiobus_free(priv->mii_bus);\nerr_out:\n\treturn err;\n}\n\nstatic void\nltq_etop_mdio_cleanup(struct net_device *dev)\n{\n\tstruct ltq_etop_priv *priv = netdev_priv(dev);\n\n\tphy_disconnect(dev->phydev);\n\tmdiobus_unregister(priv->mii_bus);\n\tmdiobus_free(priv->mii_bus);\n}\n\nstatic int\nltq_etop_open(struct net_device *dev)\n{\n\tstruct ltq_etop_priv *priv = netdev_priv(dev);\n\tint i;\n\n\tfor (i = 0; i < MAX_DMA_CHAN; i++) {\n\t\tstruct ltq_etop_chan *ch = &priv->ch[i];\n\n\t\tif (!IS_TX(i) && (!IS_RX(i)))\n\t\t\tcontinue;\n\t\tltq_dma_open(&ch->dma);\n\t\tltq_dma_enable_irq(&ch->dma);\n\t\tnapi_enable(&ch->napi);\n\t}\n\tphy_start(dev->phydev);\n\tnetif_tx_start_all_queues(dev);\n\treturn 0;\n}\n\nstatic int\nltq_etop_stop(struct net_device *dev)\n{\n\tstruct ltq_etop_priv *priv = netdev_priv(dev);\n\tint i;\n\n\tnetif_tx_stop_all_queues(dev);\n\tphy_stop(dev->phydev);\n\tfor (i = 0; i < MAX_DMA_CHAN; i++) {\n\t\tstruct ltq_etop_chan *ch = &priv->ch[i];\n\n\t\tif (!IS_RX(i) && !IS_TX(i))\n\t\t\tcontinue;\n\t\tnapi_disable(&ch->napi);\n\t\tltq_dma_close(&ch->dma);\n\t}\n\treturn 0;\n}\n\nstatic netdev_tx_t\nltq_etop_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tint queue = skb_get_queue_mapping(skb);\n\tstruct netdev_queue *txq = netdev_get_tx_queue(dev, queue);\n\tstruct ltq_etop_priv *priv = netdev_priv(dev);\n\tstruct ltq_etop_chan *ch = &priv->ch[(queue << 1) | 1];\n\tstruct ltq_dma_desc *desc = &ch->dma.desc_base[ch->dma.desc];\n\tint len;\n\tunsigned long flags;\n\tu32 byte_offset;\n\n\tlen = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;\n\n\tif ((desc->ctl & (LTQ_DMA_OWN | LTQ_DMA_C)) || ch->skb[ch->dma.desc]) {\n\t\tnetdev_err(dev, \"tx ring full\\n\");\n\t\tnetif_tx_stop_queue(txq);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tbyte_offset = CPHYSADDR(skb->data) % (priv->tx_burst_len * 4);\n\tch->skb[ch->dma.desc] = skb;\n\n\tnetif_trans_update(dev);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tdesc->addr = ((unsigned int)dma_map_single(&priv->pdev->dev, skb->data, len,\n\t\t\t\t\t\tDMA_TO_DEVICE)) - byte_offset;\n\t \n\twmb();\n\tdesc->ctl = LTQ_DMA_OWN | LTQ_DMA_SOP | LTQ_DMA_EOP |\n\t\tLTQ_DMA_TX_OFFSET(byte_offset) | (len & LTQ_DMA_SIZE_MASK);\n\tch->dma.desc++;\n\tch->dma.desc %= LTQ_DESC_NUM;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tif (ch->dma.desc_base[ch->dma.desc].ctl & LTQ_DMA_OWN)\n\t\tnetif_tx_stop_queue(txq);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int\nltq_etop_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct ltq_etop_priv *priv = netdev_priv(dev);\n\tunsigned long flags;\n\n\tdev->mtu = new_mtu;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tltq_etop_w32((ETOP_PLEN_UNDER << 16) | new_mtu, LTQ_ETOP_IGPLEN);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int\nltq_etop_set_mac_address(struct net_device *dev, void *p)\n{\n\tint ret = eth_mac_addr(dev, p);\n\n\tif (!ret) {\n\t\tstruct ltq_etop_priv *priv = netdev_priv(dev);\n\t\tunsigned long flags;\n\n\t\t \n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tltq_etop_w32(*((u32 *)dev->dev_addr), LTQ_ETOP_MAC_DA0);\n\t\tltq_etop_w32(*((u16 *)&dev->dev_addr[4]) << 16,\n\t\t\t     LTQ_ETOP_MAC_DA1);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t}\n\treturn ret;\n}\n\nstatic void\nltq_etop_set_multicast_list(struct net_device *dev)\n{\n\tstruct ltq_etop_priv *priv = netdev_priv(dev);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tif ((dev->flags & IFF_PROMISC) || (dev->flags & IFF_ALLMULTI))\n\t\tltq_etop_w32_mask(ETOP_FTCU, 0, LTQ_ETOP_ENETS0);\n\telse\n\t\tltq_etop_w32_mask(0, ETOP_FTCU, LTQ_ETOP_ENETS0);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic int\nltq_etop_init(struct net_device *dev)\n{\n\tstruct ltq_etop_priv *priv = netdev_priv(dev);\n\tstruct sockaddr mac;\n\tint err;\n\tbool random_mac = false;\n\n\tdev->watchdog_timeo = 10 * HZ;\n\terr = ltq_etop_hw_init(dev);\n\tif (err)\n\t\tgoto err_hw;\n\tltq_etop_change_mtu(dev, 1500);\n\n\tmemcpy(&mac, &priv->pldata->mac, sizeof(struct sockaddr));\n\tif (!is_valid_ether_addr(mac.sa_data)) {\n\t\tpr_warn(\"etop: invalid MAC, using random\\n\");\n\t\teth_random_addr(mac.sa_data);\n\t\trandom_mac = true;\n\t}\n\n\terr = ltq_etop_set_mac_address(dev, &mac);\n\tif (err)\n\t\tgoto err_netdev;\n\n\t \n\tif (random_mac)\n\t\tdev->addr_assign_type = NET_ADDR_RANDOM;\n\n\tltq_etop_set_multicast_list(dev);\n\terr = ltq_etop_mdio_init(dev);\n\tif (err)\n\t\tgoto err_netdev;\n\treturn 0;\n\nerr_netdev:\n\tunregister_netdev(dev);\n\tfree_netdev(dev);\nerr_hw:\n\tltq_etop_hw_exit(dev);\n\treturn err;\n}\n\nstatic void\nltq_etop_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tint err;\n\n\tltq_etop_hw_exit(dev);\n\terr = ltq_etop_hw_init(dev);\n\tif (err)\n\t\tgoto err_hw;\n\tnetif_trans_update(dev);\n\tnetif_wake_queue(dev);\n\treturn;\n\nerr_hw:\n\tltq_etop_hw_exit(dev);\n\tnetdev_err(dev, \"failed to restart etop after TX timeout\\n\");\n}\n\nstatic const struct net_device_ops ltq_eth_netdev_ops = {\n\t.ndo_open = ltq_etop_open,\n\t.ndo_stop = ltq_etop_stop,\n\t.ndo_start_xmit = ltq_etop_tx,\n\t.ndo_change_mtu = ltq_etop_change_mtu,\n\t.ndo_eth_ioctl = phy_do_ioctl,\n\t.ndo_set_mac_address = ltq_etop_set_mac_address,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_set_rx_mode = ltq_etop_set_multicast_list,\n\t.ndo_select_queue = dev_pick_tx_zero,\n\t.ndo_init = ltq_etop_init,\n\t.ndo_tx_timeout = ltq_etop_tx_timeout,\n};\n\nstatic int __init\nltq_etop_probe(struct platform_device *pdev)\n{\n\tstruct net_device *dev;\n\tstruct ltq_etop_priv *priv;\n\tstruct resource *res;\n\tint err;\n\tint i;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"failed to get etop resource\\n\");\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\n\tres = devm_request_mem_region(&pdev->dev, res->start,\n\t\t\t\t      resource_size(res), dev_name(&pdev->dev));\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"failed to request etop resource\\n\");\n\t\terr = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\tltq_etop_membase = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\tresource_size(res));\n\tif (!ltq_etop_membase) {\n\t\tdev_err(&pdev->dev, \"failed to remap etop engine %d\\n\",\n\t\t\tpdev->id);\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tdev = alloc_etherdev_mq(sizeof(struct ltq_etop_priv), 4);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tstrcpy(dev->name, \"eth%d\");\n\tdev->netdev_ops = &ltq_eth_netdev_ops;\n\tdev->ethtool_ops = &ltq_etop_ethtool_ops;\n\tpriv = netdev_priv(dev);\n\tpriv->res = res;\n\tpriv->pdev = pdev;\n\tpriv->pldata = dev_get_platdata(&pdev->dev);\n\tpriv->netdev = dev;\n\tspin_lock_init(&priv->lock);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\terr = device_property_read_u32(&pdev->dev, \"lantiq,tx-burst-length\", &priv->tx_burst_len);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"unable to read tx-burst-length property\\n\");\n\t\tgoto err_free;\n\t}\n\n\terr = device_property_read_u32(&pdev->dev, \"lantiq,rx-burst-length\", &priv->rx_burst_len);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"unable to read rx-burst-length property\\n\");\n\t\tgoto err_free;\n\t}\n\n\tfor (i = 0; i < MAX_DMA_CHAN; i++) {\n\t\tif (IS_TX(i))\n\t\t\tnetif_napi_add_weight(dev, &priv->ch[i].napi,\n\t\t\t\t\t      ltq_etop_poll_tx, 8);\n\t\telse if (IS_RX(i))\n\t\t\tnetif_napi_add_weight(dev, &priv->ch[i].napi,\n\t\t\t\t\t      ltq_etop_poll_rx, 32);\n\t\tpriv->ch[i].netdev = dev;\n\t}\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto err_free;\n\n\tplatform_set_drvdata(pdev, dev);\n\treturn 0;\n\nerr_free:\n\tfree_netdev(dev);\nerr_out:\n\treturn err;\n}\n\nstatic int\nltq_etop_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\n\tif (dev) {\n\t\tnetif_tx_stop_all_queues(dev);\n\t\tltq_etop_hw_exit(dev);\n\t\tltq_etop_mdio_cleanup(dev);\n\t\tunregister_netdev(dev);\n\t}\n\treturn 0;\n}\n\nstatic struct platform_driver ltq_mii_driver = {\n\t.remove = ltq_etop_remove,\n\t.driver = {\n\t\t.name = \"ltq_etop\",\n\t},\n};\n\nstatic int __init\ninit_ltq_etop(void)\n{\n\tint ret = platform_driver_probe(&ltq_mii_driver, ltq_etop_probe);\n\n\tif (ret)\n\t\tpr_err(\"ltq_etop: Error registering platform driver!\");\n\treturn ret;\n}\n\nstatic void __exit\nexit_ltq_etop(void)\n{\n\tplatform_driver_unregister(&ltq_mii_driver);\n}\n\nmodule_init(init_ltq_etop);\nmodule_exit(exit_ltq_etop);\n\nMODULE_AUTHOR(\"John Crispin <blogic@openwrt.org>\");\nMODULE_DESCRIPTION(\"Lantiq SoC ETOP\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}