{
  "module_name": "lpc_eth.c",
  "hash_id": "ed3984e4baaca96c355378b5c1d21a09304299b3765350119aa540641b2b9b34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/nxp/lpc_eth.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/crc32.h>\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/soc/nxp/lpc32xx-misc.h>\n\n#define MODNAME \"lpc-eth\"\n#define DRV_VERSION \"1.00\"\n\n#define ENET_MAXF_SIZE 1536\n#define ENET_RX_DESC 48\n#define ENET_TX_DESC 16\n\n#define NAPI_WEIGHT 16\n\n \n#define LPC_ENET_MAC1(x)\t\t\t(x + 0x000)\n#define LPC_ENET_MAC2(x)\t\t\t(x + 0x004)\n#define LPC_ENET_IPGT(x)\t\t\t(x + 0x008)\n#define LPC_ENET_IPGR(x)\t\t\t(x + 0x00C)\n#define LPC_ENET_CLRT(x)\t\t\t(x + 0x010)\n#define LPC_ENET_MAXF(x)\t\t\t(x + 0x014)\n#define LPC_ENET_SUPP(x)\t\t\t(x + 0x018)\n#define LPC_ENET_TEST(x)\t\t\t(x + 0x01C)\n#define LPC_ENET_MCFG(x)\t\t\t(x + 0x020)\n#define LPC_ENET_MCMD(x)\t\t\t(x + 0x024)\n#define LPC_ENET_MADR(x)\t\t\t(x + 0x028)\n#define LPC_ENET_MWTD(x)\t\t\t(x + 0x02C)\n#define LPC_ENET_MRDD(x)\t\t\t(x + 0x030)\n#define LPC_ENET_MIND(x)\t\t\t(x + 0x034)\n#define LPC_ENET_SA0(x)\t\t\t\t(x + 0x040)\n#define LPC_ENET_SA1(x)\t\t\t\t(x + 0x044)\n#define LPC_ENET_SA2(x)\t\t\t\t(x + 0x048)\n#define LPC_ENET_COMMAND(x)\t\t\t(x + 0x100)\n#define LPC_ENET_STATUS(x)\t\t\t(x + 0x104)\n#define LPC_ENET_RXDESCRIPTOR(x)\t\t(x + 0x108)\n#define LPC_ENET_RXSTATUS(x)\t\t\t(x + 0x10C)\n#define LPC_ENET_RXDESCRIPTORNUMBER(x)\t\t(x + 0x110)\n#define LPC_ENET_RXPRODUCEINDEX(x)\t\t(x + 0x114)\n#define LPC_ENET_RXCONSUMEINDEX(x)\t\t(x + 0x118)\n#define LPC_ENET_TXDESCRIPTOR(x)\t\t(x + 0x11C)\n#define LPC_ENET_TXSTATUS(x)\t\t\t(x + 0x120)\n#define LPC_ENET_TXDESCRIPTORNUMBER(x)\t\t(x + 0x124)\n#define LPC_ENET_TXPRODUCEINDEX(x)\t\t(x + 0x128)\n#define LPC_ENET_TXCONSUMEINDEX(x)\t\t(x + 0x12C)\n#define LPC_ENET_TSV0(x)\t\t\t(x + 0x158)\n#define LPC_ENET_TSV1(x)\t\t\t(x + 0x15C)\n#define LPC_ENET_RSV(x)\t\t\t\t(x + 0x160)\n#define LPC_ENET_FLOWCONTROLCOUNTER(x)\t\t(x + 0x170)\n#define LPC_ENET_FLOWCONTROLSTATUS(x)\t\t(x + 0x174)\n#define LPC_ENET_RXFILTER_CTRL(x)\t\t(x + 0x200)\n#define LPC_ENET_RXFILTERWOLSTATUS(x)\t\t(x + 0x204)\n#define LPC_ENET_RXFILTERWOLCLEAR(x)\t\t(x + 0x208)\n#define LPC_ENET_HASHFILTERL(x)\t\t\t(x + 0x210)\n#define LPC_ENET_HASHFILTERH(x)\t\t\t(x + 0x214)\n#define LPC_ENET_INTSTATUS(x)\t\t\t(x + 0xFE0)\n#define LPC_ENET_INTENABLE(x)\t\t\t(x + 0xFE4)\n#define LPC_ENET_INTCLEAR(x)\t\t\t(x + 0xFE8)\n#define LPC_ENET_INTSET(x)\t\t\t(x + 0xFEC)\n#define LPC_ENET_POWERDOWN(x)\t\t\t(x + 0xFF4)\n\n \n#define LPC_MAC1_RECV_ENABLE\t\t\t(1 << 0)\n#define LPC_MAC1_PASS_ALL_RX_FRAMES\t\t(1 << 1)\n#define LPC_MAC1_RX_FLOW_CONTROL\t\t(1 << 2)\n#define LPC_MAC1_TX_FLOW_CONTROL\t\t(1 << 3)\n#define LPC_MAC1_LOOPBACK\t\t\t(1 << 4)\n#define LPC_MAC1_RESET_TX\t\t\t(1 << 8)\n#define LPC_MAC1_RESET_MCS_TX\t\t\t(1 << 9)\n#define LPC_MAC1_RESET_RX\t\t\t(1 << 10)\n#define LPC_MAC1_RESET_MCS_RX\t\t\t(1 << 11)\n#define LPC_MAC1_SIMULATION_RESET\t\t(1 << 14)\n#define LPC_MAC1_SOFT_RESET\t\t\t(1 << 15)\n\n \n#define LPC_MAC2_FULL_DUPLEX\t\t\t(1 << 0)\n#define LPC_MAC2_FRAME_LENGTH_CHECKING\t\t(1 << 1)\n#define LPC_MAC2_HUGH_LENGTH_CHECKING\t\t(1 << 2)\n#define LPC_MAC2_DELAYED_CRC\t\t\t(1 << 3)\n#define LPC_MAC2_CRC_ENABLE\t\t\t(1 << 4)\n#define LPC_MAC2_PAD_CRC_ENABLE\t\t\t(1 << 5)\n#define LPC_MAC2_VLAN_PAD_ENABLE\t\t(1 << 6)\n#define LPC_MAC2_AUTO_DETECT_PAD_ENABLE\t\t(1 << 7)\n#define LPC_MAC2_PURE_PREAMBLE_ENFORCEMENT\t(1 << 8)\n#define LPC_MAC2_LONG_PREAMBLE_ENFORCEMENT\t(1 << 9)\n#define LPC_MAC2_NO_BACKOFF\t\t\t(1 << 12)\n#define LPC_MAC2_BACK_PRESSURE\t\t\t(1 << 13)\n#define LPC_MAC2_EXCESS_DEFER\t\t\t(1 << 14)\n\n \n#define LPC_IPGT_LOAD(n)\t\t\t((n) & 0x7F)\n\n \n#define LPC_IPGR_LOAD_PART2(n)\t\t\t((n) & 0x7F)\n#define LPC_IPGR_LOAD_PART1(n)\t\t\t(((n) & 0x7F) << 8)\n\n \n#define LPC_CLRT_LOAD_RETRY_MAX(n)\t\t((n) & 0xF)\n#define LPC_CLRT_LOAD_COLLISION_WINDOW(n)\t(((n) & 0x3F) << 8)\n\n \n#define LPC_MAXF_LOAD_MAX_FRAME_LEN(n)\t\t((n) & 0xFFFF)\n\n \n#define LPC_SUPP_SPEED\t\t\t\t(1 << 8)\n#define LPC_SUPP_RESET_RMII\t\t\t(1 << 11)\n\n \n#define LPC_TEST_SHORTCUT_PAUSE_QUANTA\t\t(1 << 0)\n#define LPC_TEST_PAUSE\t\t\t\t(1 << 1)\n#define LPC_TEST_BACKPRESSURE\t\t\t(1 << 2)\n\n \n#define LPC_MCFG_SCAN_INCREMENT\t\t\t(1 << 0)\n#define LPC_MCFG_SUPPRESS_PREAMBLE\t\t(1 << 1)\n#define LPC_MCFG_CLOCK_SELECT(n)\t\t(((n) & 0x7) << 2)\n#define LPC_MCFG_CLOCK_HOST_DIV_4\t\t0\n#define LPC_MCFG_CLOCK_HOST_DIV_6\t\t2\n#define LPC_MCFG_CLOCK_HOST_DIV_8\t\t3\n#define LPC_MCFG_CLOCK_HOST_DIV_10\t\t4\n#define LPC_MCFG_CLOCK_HOST_DIV_14\t\t5\n#define LPC_MCFG_CLOCK_HOST_DIV_20\t\t6\n#define LPC_MCFG_CLOCK_HOST_DIV_28\t\t7\n#define LPC_MCFG_RESET_MII_MGMT\t\t\t(1 << 15)\n\n \n#define LPC_MCMD_READ\t\t\t\t(1 << 0)\n#define LPC_MCMD_SCAN\t\t\t\t(1 << 1)\n\n \n#define LPC_MADR_REGISTER_ADDRESS(n)\t\t((n) & 0x1F)\n#define LPC_MADR_PHY_0ADDRESS(n)\t\t(((n) & 0x1F) << 8)\n\n \n#define LPC_MWDT_WRITE(n)\t\t\t((n) & 0xFFFF)\n\n \n#define LPC_MRDD_READ_MASK\t\t\t0xFFFF\n\n \n#define LPC_MIND_BUSY\t\t\t\t(1 << 0)\n#define LPC_MIND_SCANNING\t\t\t(1 << 1)\n#define LPC_MIND_NOT_VALID\t\t\t(1 << 2)\n#define LPC_MIND_MII_LINK_FAIL\t\t\t(1 << 3)\n\n \n#define LPC_COMMAND_RXENABLE\t\t\t(1 << 0)\n#define LPC_COMMAND_TXENABLE\t\t\t(1 << 1)\n#define LPC_COMMAND_REG_RESET\t\t\t(1 << 3)\n#define LPC_COMMAND_TXRESET\t\t\t(1 << 4)\n#define LPC_COMMAND_RXRESET\t\t\t(1 << 5)\n#define LPC_COMMAND_PASSRUNTFRAME\t\t(1 << 6)\n#define LPC_COMMAND_PASSRXFILTER\t\t(1 << 7)\n#define LPC_COMMAND_TXFLOWCONTROL\t\t(1 << 8)\n#define LPC_COMMAND_RMII\t\t\t(1 << 9)\n#define LPC_COMMAND_FULLDUPLEX\t\t\t(1 << 10)\n\n \n#define LPC_STATUS_RXACTIVE\t\t\t(1 << 0)\n#define LPC_STATUS_TXACTIVE\t\t\t(1 << 1)\n\n \n#define LPC_TSV0_CRC_ERROR\t\t\t(1 << 0)\n#define LPC_TSV0_LENGTH_CHECK_ERROR\t\t(1 << 1)\n#define LPC_TSV0_LENGTH_OUT_OF_RANGE\t\t(1 << 2)\n#define LPC_TSV0_DONE\t\t\t\t(1 << 3)\n#define LPC_TSV0_MULTICAST\t\t\t(1 << 4)\n#define LPC_TSV0_BROADCAST\t\t\t(1 << 5)\n#define LPC_TSV0_PACKET_DEFER\t\t\t(1 << 6)\n#define LPC_TSV0_ESCESSIVE_DEFER\t\t(1 << 7)\n#define LPC_TSV0_ESCESSIVE_COLLISION\t\t(1 << 8)\n#define LPC_TSV0_LATE_COLLISION\t\t\t(1 << 9)\n#define LPC_TSV0_GIANT\t\t\t\t(1 << 10)\n#define LPC_TSV0_UNDERRUN\t\t\t(1 << 11)\n#define LPC_TSV0_TOTAL_BYTES(n)\t\t\t(((n) >> 12) & 0xFFFF)\n#define LPC_TSV0_CONTROL_FRAME\t\t\t(1 << 28)\n#define LPC_TSV0_PAUSE\t\t\t\t(1 << 29)\n#define LPC_TSV0_BACKPRESSURE\t\t\t(1 << 30)\n#define LPC_TSV0_VLAN\t\t\t\t(1 << 31)\n\n \n#define LPC_TSV1_TRANSMIT_BYTE_COUNT(n)\t\t((n) & 0xFFFF)\n#define LPC_TSV1_COLLISION_COUNT(n)\t\t(((n) >> 16) & 0xF)\n\n \n#define LPC_RSV_RECEIVED_BYTE_COUNT(n)\t\t((n) & 0xFFFF)\n#define LPC_RSV_RXDV_EVENT_IGNORED\t\t(1 << 16)\n#define LPC_RSV_RXDV_EVENT_PREVIOUSLY_SEEN\t(1 << 17)\n#define LPC_RSV_CARRIER_EVNT_PREVIOUS_SEEN\t(1 << 18)\n#define LPC_RSV_RECEIVE_CODE_VIOLATION\t\t(1 << 19)\n#define LPC_RSV_CRC_ERROR\t\t\t(1 << 20)\n#define LPC_RSV_LENGTH_CHECK_ERROR\t\t(1 << 21)\n#define LPC_RSV_LENGTH_OUT_OF_RANGE\t\t(1 << 22)\n#define LPC_RSV_RECEIVE_OK\t\t\t(1 << 23)\n#define LPC_RSV_MULTICAST\t\t\t(1 << 24)\n#define LPC_RSV_BROADCAST\t\t\t(1 << 25)\n#define LPC_RSV_DRIBBLE_NIBBLE\t\t\t(1 << 26)\n#define LPC_RSV_CONTROL_FRAME\t\t\t(1 << 27)\n#define LPC_RSV_PAUSE\t\t\t\t(1 << 28)\n#define LPC_RSV_UNSUPPORTED_OPCODE\t\t(1 << 29)\n#define LPC_RSV_VLAN\t\t\t\t(1 << 30)\n\n \n#define LPC_FCCR_MIRRORCOUNTER(n)\t\t((n) & 0xFFFF)\n#define LPC_FCCR_PAUSETIMER(n)\t\t\t(((n) >> 16) & 0xFFFF)\n\n \n#define LPC_FCCR_MIRRORCOUNTERCURRENT(n)\t((n) & 0xFFFF)\n\n \n#define LPC_RXFLTRW_ACCEPTUNICAST\t\t(1 << 0)\n#define LPC_RXFLTRW_ACCEPTUBROADCAST\t\t(1 << 1)\n#define LPC_RXFLTRW_ACCEPTUMULTICAST\t\t(1 << 2)\n#define LPC_RXFLTRW_ACCEPTUNICASTHASH\t\t(1 << 3)\n#define LPC_RXFLTRW_ACCEPTUMULTICASTHASH\t(1 << 4)\n#define LPC_RXFLTRW_ACCEPTPERFECT\t\t(1 << 5)\n\n \n#define LPC_RXFLTRWSTS_MAGICPACKETENWOL\t\t(1 << 12)\n#define LPC_RXFLTRWSTS_RXFILTERENWOL\t\t(1 << 13)\n\n \n#define LPC_RXFLTRWSTS_RXFILTERWOL\t\t(1 << 7)\n#define LPC_RXFLTRWSTS_MAGICPACKETWOL\t\t(1 << 8)\n\n \n#define LPC_MACINT_RXOVERRUNINTEN\t\t(1 << 0)\n#define LPC_MACINT_RXERRORONINT\t\t\t(1 << 1)\n#define LPC_MACINT_RXFINISHEDINTEN\t\t(1 << 2)\n#define LPC_MACINT_RXDONEINTEN\t\t\t(1 << 3)\n#define LPC_MACINT_TXUNDERRUNINTEN\t\t(1 << 4)\n#define LPC_MACINT_TXERRORINTEN\t\t\t(1 << 5)\n#define LPC_MACINT_TXFINISHEDINTEN\t\t(1 << 6)\n#define LPC_MACINT_TXDONEINTEN\t\t\t(1 << 7)\n#define LPC_MACINT_SOFTINTEN\t\t\t(1 << 12)\n#define LPC_MACINT_WAKEUPINTEN\t\t\t(1 << 13)\n\n \n#define LPC_POWERDOWN_MACAHB\t\t\t(1 << 31)\n\nstatic phy_interface_t lpc_phy_interface_mode(struct device *dev)\n{\n\tif (dev && dev->of_node) {\n\t\tconst char *mode = of_get_property(dev->of_node,\n\t\t\t\t\t\t   \"phy-mode\", NULL);\n\t\tif (mode && !strcmp(mode, \"mii\"))\n\t\t\treturn PHY_INTERFACE_MODE_MII;\n\t}\n\treturn PHY_INTERFACE_MODE_RMII;\n}\n\nstatic bool use_iram_for_net(struct device *dev)\n{\n\tif (dev && dev->of_node)\n\t\treturn of_property_read_bool(dev->of_node, \"use-iram\");\n\treturn false;\n}\n\n \n#define RXSTATUS_SIZE\t\t\t0x000007FF\n#define RXSTATUS_CONTROL\t\t(1 << 18)\n#define RXSTATUS_VLAN\t\t\t(1 << 19)\n#define RXSTATUS_FILTER\t\t\t(1 << 20)\n#define RXSTATUS_MULTICAST\t\t(1 << 21)\n#define RXSTATUS_BROADCAST\t\t(1 << 22)\n#define RXSTATUS_CRC\t\t\t(1 << 23)\n#define RXSTATUS_SYMBOL\t\t\t(1 << 24)\n#define RXSTATUS_LENGTH\t\t\t(1 << 25)\n#define RXSTATUS_RANGE\t\t\t(1 << 26)\n#define RXSTATUS_ALIGN\t\t\t(1 << 27)\n#define RXSTATUS_OVERRUN\t\t(1 << 28)\n#define RXSTATUS_NODESC\t\t\t(1 << 29)\n#define RXSTATUS_LAST\t\t\t(1 << 30)\n#define RXSTATUS_ERROR\t\t\t(1 << 31)\n\n#define RXSTATUS_STATUS_ERROR \\\n\t(RXSTATUS_NODESC | RXSTATUS_OVERRUN | RXSTATUS_ALIGN | \\\n\t RXSTATUS_RANGE | RXSTATUS_LENGTH | RXSTATUS_SYMBOL | RXSTATUS_CRC)\n\n \n#define RXDESC_CONTROL_SIZE\t\t0x000007FF\n#define RXDESC_CONTROL_INT\t\t(1 << 31)\n\n \n#define TXSTATUS_COLLISIONS_GET(x)\t(((x) >> 21) & 0xF)\n#define TXSTATUS_DEFER\t\t\t(1 << 25)\n#define TXSTATUS_EXCESSDEFER\t\t(1 << 26)\n#define TXSTATUS_EXCESSCOLL\t\t(1 << 27)\n#define TXSTATUS_LATECOLL\t\t(1 << 28)\n#define TXSTATUS_UNDERRUN\t\t(1 << 29)\n#define TXSTATUS_NODESC\t\t\t(1 << 30)\n#define TXSTATUS_ERROR\t\t\t(1 << 31)\n\n \n#define TXDESC_CONTROL_SIZE\t\t0x000007FF\n#define TXDESC_CONTROL_OVERRIDE\t\t(1 << 26)\n#define TXDESC_CONTROL_HUGE\t\t(1 << 27)\n#define TXDESC_CONTROL_PAD\t\t(1 << 28)\n#define TXDESC_CONTROL_CRC\t\t(1 << 29)\n#define TXDESC_CONTROL_LAST\t\t(1 << 30)\n#define TXDESC_CONTROL_INT\t\t(1 << 31)\n\n \nstruct txrx_desc_t {\n\t__le32 packet;\n\t__le32 control;\n};\nstruct rx_status_t {\n\t__le32 statusinfo;\n\t__le32 statushashcrc;\n};\n\n \nstruct netdata_local {\n\tstruct platform_device\t*pdev;\n\tstruct net_device\t*ndev;\n\tstruct device_node\t*phy_node;\n\tspinlock_t\t\tlock;\n\tvoid __iomem\t\t*net_base;\n\tu32\t\t\tmsg_enable;\n\tunsigned int\t\tskblen[ENET_TX_DESC];\n\tunsigned int\t\tlast_tx_idx;\n\tunsigned int\t\tnum_used_tx_buffs;\n\tstruct mii_bus\t\t*mii_bus;\n\tstruct clk\t\t*clk;\n\tdma_addr_t\t\tdma_buff_base_p;\n\tvoid\t\t\t*dma_buff_base_v;\n\tsize_t\t\t\tdma_buff_size;\n\tstruct txrx_desc_t\t*tx_desc_v;\n\tu32\t\t\t*tx_stat_v;\n\tvoid\t\t\t*tx_buff_v;\n\tstruct txrx_desc_t\t*rx_desc_v;\n\tstruct rx_status_t\t*rx_stat_v;\n\tvoid\t\t\t*rx_buff_v;\n\tint\t\t\tlink;\n\tint\t\t\tspeed;\n\tint\t\t\tduplex;\n\tstruct napi_struct\tnapi;\n};\n\n \nstatic void __lpc_set_mac(struct netdata_local *pldat, const u8 *mac)\n{\n\tu32 tmp;\n\n\t \n\ttmp = mac[0] | ((u32)mac[1] << 8);\n\twritel(tmp, LPC_ENET_SA2(pldat->net_base));\n\ttmp = mac[2] | ((u32)mac[3] << 8);\n\twritel(tmp, LPC_ENET_SA1(pldat->net_base));\n\ttmp = mac[4] | ((u32)mac[5] << 8);\n\twritel(tmp, LPC_ENET_SA0(pldat->net_base));\n\n\tnetdev_dbg(pldat->ndev, \"Ethernet MAC address %pM\\n\", mac);\n}\n\nstatic void __lpc_get_mac(struct netdata_local *pldat, u8 *mac)\n{\n\tu32 tmp;\n\n\t \n\ttmp = readl(LPC_ENET_SA2(pldat->net_base));\n\tmac[0] = tmp & 0xFF;\n\tmac[1] = tmp >> 8;\n\ttmp = readl(LPC_ENET_SA1(pldat->net_base));\n\tmac[2] = tmp & 0xFF;\n\tmac[3] = tmp >> 8;\n\ttmp = readl(LPC_ENET_SA0(pldat->net_base));\n\tmac[4] = tmp & 0xFF;\n\tmac[5] = tmp >> 8;\n}\n\nstatic void __lpc_params_setup(struct netdata_local *pldat)\n{\n\tu32 tmp;\n\n\tif (pldat->duplex == DUPLEX_FULL) {\n\t\ttmp = readl(LPC_ENET_MAC2(pldat->net_base));\n\t\ttmp |= LPC_MAC2_FULL_DUPLEX;\n\t\twritel(tmp, LPC_ENET_MAC2(pldat->net_base));\n\t\ttmp = readl(LPC_ENET_COMMAND(pldat->net_base));\n\t\ttmp |= LPC_COMMAND_FULLDUPLEX;\n\t\twritel(tmp, LPC_ENET_COMMAND(pldat->net_base));\n\t\twritel(LPC_IPGT_LOAD(0x15), LPC_ENET_IPGT(pldat->net_base));\n\t} else {\n\t\ttmp = readl(LPC_ENET_MAC2(pldat->net_base));\n\t\ttmp &= ~LPC_MAC2_FULL_DUPLEX;\n\t\twritel(tmp, LPC_ENET_MAC2(pldat->net_base));\n\t\ttmp = readl(LPC_ENET_COMMAND(pldat->net_base));\n\t\ttmp &= ~LPC_COMMAND_FULLDUPLEX;\n\t\twritel(tmp, LPC_ENET_COMMAND(pldat->net_base));\n\t\twritel(LPC_IPGT_LOAD(0x12), LPC_ENET_IPGT(pldat->net_base));\n\t}\n\n\tif (pldat->speed == SPEED_100)\n\t\twritel(LPC_SUPP_SPEED, LPC_ENET_SUPP(pldat->net_base));\n\telse\n\t\twritel(0, LPC_ENET_SUPP(pldat->net_base));\n}\n\nstatic void __lpc_eth_reset(struct netdata_local *pldat)\n{\n\t \n\twritel((LPC_MAC1_RESET_TX | LPC_MAC1_RESET_MCS_TX | LPC_MAC1_RESET_RX |\n\t\tLPC_MAC1_RESET_MCS_RX | LPC_MAC1_SIMULATION_RESET |\n\t\tLPC_MAC1_SOFT_RESET), LPC_ENET_MAC1(pldat->net_base));\n\twritel((LPC_COMMAND_REG_RESET | LPC_COMMAND_TXRESET |\n\t\tLPC_COMMAND_RXRESET), LPC_ENET_COMMAND(pldat->net_base));\n}\n\nstatic int __lpc_mii_mngt_reset(struct netdata_local *pldat)\n{\n\t \n\twritel(LPC_MCFG_RESET_MII_MGMT, LPC_ENET_MCFG(pldat->net_base));\n\n\t \n\twritel(LPC_MCFG_CLOCK_SELECT(LPC_MCFG_CLOCK_HOST_DIV_28),\n\t       LPC_ENET_MCFG(pldat->net_base));\n\n\treturn 0;\n}\n\nstatic inline phys_addr_t __va_to_pa(void *addr, struct netdata_local *pldat)\n{\n\tphys_addr_t phaddr;\n\n\tphaddr = addr - pldat->dma_buff_base_v;\n\tphaddr += pldat->dma_buff_base_p;\n\n\treturn phaddr;\n}\n\nstatic void lpc_eth_enable_int(void __iomem *regbase)\n{\n\twritel((LPC_MACINT_RXDONEINTEN | LPC_MACINT_TXDONEINTEN),\n\t       LPC_ENET_INTENABLE(regbase));\n}\n\nstatic void lpc_eth_disable_int(void __iomem *regbase)\n{\n\twritel(0, LPC_ENET_INTENABLE(regbase));\n}\n\n \nstatic void __lpc_txrx_desc_setup(struct netdata_local *pldat)\n{\n\tu32 *ptxstat;\n\tvoid *tbuff;\n\tint i;\n\tstruct txrx_desc_t *ptxrxdesc;\n\tstruct rx_status_t *prxstat;\n\n\ttbuff = PTR_ALIGN(pldat->dma_buff_base_v, 16);\n\n\t \n\tpldat->tx_desc_v = tbuff;\n\ttbuff += sizeof(struct txrx_desc_t) * ENET_TX_DESC;\n\n\tpldat->tx_stat_v = tbuff;\n\ttbuff += sizeof(u32) * ENET_TX_DESC;\n\n\ttbuff = PTR_ALIGN(tbuff, 16);\n\tpldat->tx_buff_v = tbuff;\n\ttbuff += ENET_MAXF_SIZE * ENET_TX_DESC;\n\n\t \n\tpldat->rx_desc_v = tbuff;\n\ttbuff += sizeof(struct txrx_desc_t) * ENET_RX_DESC;\n\n\ttbuff = PTR_ALIGN(tbuff, 16);\n\tpldat->rx_stat_v = tbuff;\n\ttbuff += sizeof(struct rx_status_t) * ENET_RX_DESC;\n\n\ttbuff = PTR_ALIGN(tbuff, 16);\n\tpldat->rx_buff_v = tbuff;\n\ttbuff += ENET_MAXF_SIZE * ENET_RX_DESC;\n\n\t \n\tfor (i = 0; i < ENET_TX_DESC; i++) {\n\t\tptxstat = &pldat->tx_stat_v[i];\n\t\tptxrxdesc = &pldat->tx_desc_v[i];\n\n\t\tptxrxdesc->packet = __va_to_pa(\n\t\t\t\tpldat->tx_buff_v + i * ENET_MAXF_SIZE, pldat);\n\t\tptxrxdesc->control = 0;\n\t\t*ptxstat = 0;\n\t}\n\n\t \n\tfor (i = 0; i < ENET_RX_DESC; i++) {\n\t\tprxstat = &pldat->rx_stat_v[i];\n\t\tptxrxdesc = &pldat->rx_desc_v[i];\n\n\t\tptxrxdesc->packet = __va_to_pa(\n\t\t\t\tpldat->rx_buff_v + i * ENET_MAXF_SIZE, pldat);\n\t\tptxrxdesc->control = RXDESC_CONTROL_INT | (ENET_MAXF_SIZE - 1);\n\t\tprxstat->statusinfo = 0;\n\t\tprxstat->statushashcrc = 0;\n\t}\n\n\t \n\twritel((ENET_TX_DESC - 1),\n\t       LPC_ENET_TXDESCRIPTORNUMBER(pldat->net_base));\n\twritel(__va_to_pa(pldat->tx_desc_v, pldat),\n\t       LPC_ENET_TXDESCRIPTOR(pldat->net_base));\n\twritel(__va_to_pa(pldat->tx_stat_v, pldat),\n\t       LPC_ENET_TXSTATUS(pldat->net_base));\n\twritel((ENET_RX_DESC - 1),\n\t       LPC_ENET_RXDESCRIPTORNUMBER(pldat->net_base));\n\twritel(__va_to_pa(pldat->rx_desc_v, pldat),\n\t       LPC_ENET_RXDESCRIPTOR(pldat->net_base));\n\twritel(__va_to_pa(pldat->rx_stat_v, pldat),\n\t       LPC_ENET_RXSTATUS(pldat->net_base));\n}\n\nstatic void __lpc_eth_init(struct netdata_local *pldat)\n{\n\tu32 tmp;\n\n\t \n\ttmp = readl(LPC_ENET_COMMAND(pldat->net_base));\n\ttmp &= ~LPC_COMMAND_RXENABLE | LPC_COMMAND_TXENABLE;\n\twritel(tmp, LPC_ENET_COMMAND(pldat->net_base));\n\ttmp = readl(LPC_ENET_MAC1(pldat->net_base));\n\ttmp &= ~LPC_MAC1_RECV_ENABLE;\n\twritel(tmp, LPC_ENET_MAC1(pldat->net_base));\n\n\t \n\twritel(LPC_MAC1_PASS_ALL_RX_FRAMES, LPC_ENET_MAC1(pldat->net_base));\n\twritel((LPC_MAC2_PAD_CRC_ENABLE | LPC_MAC2_CRC_ENABLE),\n\t       LPC_ENET_MAC2(pldat->net_base));\n\twritel(ENET_MAXF_SIZE, LPC_ENET_MAXF(pldat->net_base));\n\n\t \n\twritel((LPC_CLRT_LOAD_RETRY_MAX(0xF) |\n\t\tLPC_CLRT_LOAD_COLLISION_WINDOW(0x37)),\n\t       LPC_ENET_CLRT(pldat->net_base));\n\twritel(LPC_IPGR_LOAD_PART2(0x12), LPC_ENET_IPGR(pldat->net_base));\n\n\tif (lpc_phy_interface_mode(&pldat->pdev->dev) == PHY_INTERFACE_MODE_MII)\n\t\twritel(LPC_COMMAND_PASSRUNTFRAME,\n\t\t       LPC_ENET_COMMAND(pldat->net_base));\n\telse {\n\t\twritel((LPC_COMMAND_PASSRUNTFRAME | LPC_COMMAND_RMII),\n\t\t       LPC_ENET_COMMAND(pldat->net_base));\n\t\twritel(LPC_SUPP_RESET_RMII, LPC_ENET_SUPP(pldat->net_base));\n\t}\n\n\t__lpc_params_setup(pldat);\n\n\t \n\t__lpc_txrx_desc_setup(pldat);\n\n\t \n\twritel((LPC_RXFLTRW_ACCEPTUBROADCAST | LPC_RXFLTRW_ACCEPTPERFECT),\n\t       LPC_ENET_RXFILTER_CTRL(pldat->net_base));\n\n\t \n\tpldat->num_used_tx_buffs = 0;\n\tpldat->last_tx_idx =\n\t\treadl(LPC_ENET_TXCONSUMEINDEX(pldat->net_base));\n\n\t \n\twritel(0xFFFF, LPC_ENET_INTCLEAR(pldat->net_base));\n\tsmp_wmb();\n\tlpc_eth_enable_int(pldat->net_base);\n\n\t \n\ttmp = readl(LPC_ENET_COMMAND(pldat->net_base));\n\ttmp |= LPC_COMMAND_RXENABLE | LPC_COMMAND_TXENABLE;\n\twritel(tmp, LPC_ENET_COMMAND(pldat->net_base));\n\ttmp = readl(LPC_ENET_MAC1(pldat->net_base));\n\ttmp |= LPC_MAC1_RECV_ENABLE;\n\twritel(tmp, LPC_ENET_MAC1(pldat->net_base));\n}\n\nstatic void __lpc_eth_shutdown(struct netdata_local *pldat)\n{\n\t \n\t__lpc_eth_reset(pldat);\n\twritel(0, LPC_ENET_MAC1(pldat->net_base));\n\twritel(0, LPC_ENET_MAC2(pldat->net_base));\n}\n\n \nstatic int lpc_mdio_read(struct mii_bus *bus, int phy_id, int phyreg)\n{\n\tstruct netdata_local *pldat = bus->priv;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(100);\n\tint lps;\n\n\twritel(((phy_id << 8) | phyreg), LPC_ENET_MADR(pldat->net_base));\n\twritel(LPC_MCMD_READ, LPC_ENET_MCMD(pldat->net_base));\n\n\t \n\twhile (readl(LPC_ENET_MIND(pldat->net_base)) & LPC_MIND_BUSY) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -EIO;\n\t\tcpu_relax();\n\t}\n\n\tlps = readl(LPC_ENET_MRDD(pldat->net_base));\n\twritel(0, LPC_ENET_MCMD(pldat->net_base));\n\n\treturn lps;\n}\n\nstatic int lpc_mdio_write(struct mii_bus *bus, int phy_id, int phyreg,\n\t\t\tu16 phydata)\n{\n\tstruct netdata_local *pldat = bus->priv;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(100);\n\n\twritel(((phy_id << 8) | phyreg), LPC_ENET_MADR(pldat->net_base));\n\twritel(phydata, LPC_ENET_MWTD(pldat->net_base));\n\n\t \n\twhile (readl(LPC_ENET_MIND(pldat->net_base)) & LPC_MIND_BUSY) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -EIO;\n\t\tcpu_relax();\n\t}\n\n\treturn 0;\n}\n\nstatic int lpc_mdio_reset(struct mii_bus *bus)\n{\n\treturn __lpc_mii_mngt_reset((struct netdata_local *)bus->priv);\n}\n\nstatic void lpc_handle_link_change(struct net_device *ndev)\n{\n\tstruct netdata_local *pldat = netdev_priv(ndev);\n\tstruct phy_device *phydev = ndev->phydev;\n\tunsigned long flags;\n\n\tbool status_change = false;\n\n\tspin_lock_irqsave(&pldat->lock, flags);\n\n\tif (phydev->link) {\n\t\tif ((pldat->speed != phydev->speed) ||\n\t\t    (pldat->duplex != phydev->duplex)) {\n\t\t\tpldat->speed = phydev->speed;\n\t\t\tpldat->duplex = phydev->duplex;\n\t\t\tstatus_change = true;\n\t\t}\n\t}\n\n\tif (phydev->link != pldat->link) {\n\t\tif (!phydev->link) {\n\t\t\tpldat->speed = 0;\n\t\t\tpldat->duplex = -1;\n\t\t}\n\t\tpldat->link = phydev->link;\n\n\t\tstatus_change = true;\n\t}\n\n\tspin_unlock_irqrestore(&pldat->lock, flags);\n\n\tif (status_change)\n\t\t__lpc_params_setup(pldat);\n}\n\nstatic int lpc_mii_probe(struct net_device *ndev)\n{\n\tstruct netdata_local *pldat = netdev_priv(ndev);\n\tstruct phy_device *phydev;\n\n\t \n\tif (lpc_phy_interface_mode(&pldat->pdev->dev) == PHY_INTERFACE_MODE_MII)\n\t\tnetdev_info(ndev, \"using MII interface\\n\");\n\telse\n\t\tnetdev_info(ndev, \"using RMII interface\\n\");\n\n\tif (pldat->phy_node)\n\t\tphydev =  of_phy_find_device(pldat->phy_node);\n\telse\n\t\tphydev = phy_find_first(pldat->mii_bus);\n\tif (!phydev) {\n\t\tnetdev_err(ndev, \"no PHY found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tphydev = phy_connect(ndev, phydev_name(phydev),\n\t\t\t     &lpc_handle_link_change,\n\t\t\t     lpc_phy_interface_mode(&pldat->pdev->dev));\n\tif (IS_ERR(phydev)) {\n\t\tnetdev_err(ndev, \"Could not attach to PHY\\n\");\n\t\treturn PTR_ERR(phydev);\n\t}\n\n\tphy_set_max_speed(phydev, SPEED_100);\n\n\tpldat->link = 0;\n\tpldat->speed = 0;\n\tpldat->duplex = -1;\n\n\tphy_attached_info(phydev);\n\n\treturn 0;\n}\n\nstatic int lpc_mii_init(struct netdata_local *pldat)\n{\n\tstruct device_node *node;\n\tint err = -ENXIO;\n\n\tpldat->mii_bus = mdiobus_alloc();\n\tif (!pldat->mii_bus) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (lpc_phy_interface_mode(&pldat->pdev->dev) == PHY_INTERFACE_MODE_MII)\n\t\twritel(LPC_COMMAND_PASSRUNTFRAME,\n\t\t       LPC_ENET_COMMAND(pldat->net_base));\n\telse {\n\t\twritel((LPC_COMMAND_PASSRUNTFRAME | LPC_COMMAND_RMII),\n\t\t       LPC_ENET_COMMAND(pldat->net_base));\n\t\twritel(LPC_SUPP_RESET_RMII, LPC_ENET_SUPP(pldat->net_base));\n\t}\n\n\tpldat->mii_bus->name = \"lpc_mii_bus\";\n\tpldat->mii_bus->read = &lpc_mdio_read;\n\tpldat->mii_bus->write = &lpc_mdio_write;\n\tpldat->mii_bus->reset = &lpc_mdio_reset;\n\tsnprintf(pldat->mii_bus->id, MII_BUS_ID_SIZE, \"%s-%x\",\n\t\t pldat->pdev->name, pldat->pdev->id);\n\tpldat->mii_bus->priv = pldat;\n\tpldat->mii_bus->parent = &pldat->pdev->dev;\n\n\tnode = of_get_child_by_name(pldat->pdev->dev.of_node, \"mdio\");\n\terr = of_mdiobus_register(pldat->mii_bus, node);\n\tof_node_put(node);\n\tif (err)\n\t\tgoto err_out_unregister_bus;\n\n\terr = lpc_mii_probe(pldat->ndev);\n\tif (err)\n\t\tgoto err_out_unregister_bus;\n\n\treturn 0;\n\nerr_out_unregister_bus:\n\tmdiobus_unregister(pldat->mii_bus);\n\tmdiobus_free(pldat->mii_bus);\nerr_out:\n\treturn err;\n}\n\nstatic void __lpc_handle_xmit(struct net_device *ndev)\n{\n\tstruct netdata_local *pldat = netdev_priv(ndev);\n\tu32 txcidx, *ptxstat, txstat;\n\n\ttxcidx = readl(LPC_ENET_TXCONSUMEINDEX(pldat->net_base));\n\twhile (pldat->last_tx_idx != txcidx) {\n\t\tunsigned int skblen = pldat->skblen[pldat->last_tx_idx];\n\n\t\t \n\t\tptxstat = &pldat->tx_stat_v[pldat->last_tx_idx];\n\t\ttxstat = *ptxstat;\n\n\t\t \n\t\tpldat->num_used_tx_buffs--;\n\t\tpldat->last_tx_idx++;\n\t\tif (pldat->last_tx_idx >= ENET_TX_DESC)\n\t\t\tpldat->last_tx_idx = 0;\n\n\t\t \n\t\tndev->stats.collisions += TXSTATUS_COLLISIONS_GET(txstat);\n\n\t\t \n\t\tif (txstat & TXSTATUS_ERROR) {\n\t\t\tif (txstat & TXSTATUS_UNDERRUN) {\n\t\t\t\t \n\t\t\t\tndev->stats.tx_fifo_errors++;\n\t\t\t}\n\t\t\tif (txstat & TXSTATUS_LATECOLL) {\n\t\t\t\t \n\t\t\t\tndev->stats.tx_aborted_errors++;\n\t\t\t}\n\t\t\tif (txstat & TXSTATUS_EXCESSCOLL) {\n\t\t\t\t \n\t\t\t\tndev->stats.tx_aborted_errors++;\n\t\t\t}\n\t\t\tif (txstat & TXSTATUS_EXCESSDEFER) {\n\t\t\t\t \n\t\t\t\tndev->stats.tx_aborted_errors++;\n\t\t\t}\n\t\t\tndev->stats.tx_errors++;\n\t\t} else {\n\t\t\t \n\t\t\tndev->stats.tx_packets++;\n\t\t\tndev->stats.tx_bytes += skblen;\n\t\t}\n\n\t\ttxcidx = readl(LPC_ENET_TXCONSUMEINDEX(pldat->net_base));\n\t}\n\n\tif (pldat->num_used_tx_buffs <= ENET_TX_DESC/2) {\n\t\tif (netif_queue_stopped(ndev))\n\t\t\tnetif_wake_queue(ndev);\n\t}\n}\n\nstatic int __lpc_handle_recv(struct net_device *ndev, int budget)\n{\n\tstruct netdata_local *pldat = netdev_priv(ndev);\n\tstruct sk_buff *skb;\n\tu32 rxconsidx, len, ethst;\n\tstruct rx_status_t *prxstat;\n\tint rx_done = 0;\n\n\t \n\trxconsidx = readl(LPC_ENET_RXCONSUMEINDEX(pldat->net_base));\n\twhile (rx_done < budget && rxconsidx !=\n\t\t\treadl(LPC_ENET_RXPRODUCEINDEX(pldat->net_base))) {\n\t\t \n\t\tprxstat = &pldat->rx_stat_v[rxconsidx];\n\t\tlen = (prxstat->statusinfo & RXSTATUS_SIZE) + 1;\n\n\t\t \n\t\tethst = prxstat->statusinfo;\n\t\tif ((ethst & (RXSTATUS_ERROR | RXSTATUS_STATUS_ERROR)) ==\n\t\t    (RXSTATUS_ERROR | RXSTATUS_RANGE))\n\t\t\tethst &= ~RXSTATUS_ERROR;\n\n\t\tif (ethst & RXSTATUS_ERROR) {\n\t\t\tint si = prxstat->statusinfo;\n\t\t\t \n\t\t\tif (si & RXSTATUS_OVERRUN) {\n\t\t\t\t \n\t\t\t\tndev->stats.rx_fifo_errors++;\n\t\t\t} else if (si & RXSTATUS_CRC) {\n\t\t\t\t \n\t\t\t\tndev->stats.rx_crc_errors++;\n\t\t\t} else if (si & RXSTATUS_LENGTH) {\n\t\t\t\t \n\t\t\t\tndev->stats.rx_length_errors++;\n\t\t\t} else if (si & RXSTATUS_ERROR) {\n\t\t\t\t \n\t\t\t\tndev->stats.rx_length_errors++;\n\t\t\t}\n\t\t\tndev->stats.rx_errors++;\n\t\t} else {\n\t\t\t \n\t\t\tskb = dev_alloc_skb(len);\n\t\t\tif (!skb) {\n\t\t\t\tndev->stats.rx_dropped++;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tskb_put_data(skb,\n\t\t\t\t\t     pldat->rx_buff_v + rxconsidx * ENET_MAXF_SIZE,\n\t\t\t\t\t     len);\n\n\t\t\t\t \n\t\t\t\tskb->protocol = eth_type_trans(skb, ndev);\n\t\t\t\tnetif_receive_skb(skb);\n\t\t\t\tndev->stats.rx_packets++;\n\t\t\t\tndev->stats.rx_bytes += len;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\trxconsidx = rxconsidx + 1;\n\t\tif (rxconsidx >= ENET_RX_DESC)\n\t\t\trxconsidx = 0;\n\t\twritel(rxconsidx,\n\t\t       LPC_ENET_RXCONSUMEINDEX(pldat->net_base));\n\t\trx_done++;\n\t}\n\n\treturn rx_done;\n}\n\nstatic int lpc_eth_poll(struct napi_struct *napi, int budget)\n{\n\tstruct netdata_local *pldat = container_of(napi,\n\t\t\tstruct netdata_local, napi);\n\tstruct net_device *ndev = pldat->ndev;\n\tint rx_done = 0;\n\tstruct netdev_queue *txq = netdev_get_tx_queue(ndev, 0);\n\n\t__netif_tx_lock(txq, smp_processor_id());\n\t__lpc_handle_xmit(ndev);\n\t__netif_tx_unlock(txq);\n\trx_done = __lpc_handle_recv(ndev, budget);\n\n\tif (rx_done < budget) {\n\t\tnapi_complete_done(napi, rx_done);\n\t\tlpc_eth_enable_int(pldat->net_base);\n\t}\n\n\treturn rx_done;\n}\n\nstatic irqreturn_t __lpc_eth_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *ndev = dev_id;\n\tstruct netdata_local *pldat = netdev_priv(ndev);\n\tu32 tmp;\n\n\tspin_lock(&pldat->lock);\n\n\ttmp = readl(LPC_ENET_INTSTATUS(pldat->net_base));\n\t \n\twritel(tmp, LPC_ENET_INTCLEAR(pldat->net_base));\n\n\tlpc_eth_disable_int(pldat->net_base);\n\tif (likely(napi_schedule_prep(&pldat->napi)))\n\t\t__napi_schedule(&pldat->napi);\n\n\tspin_unlock(&pldat->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int lpc_eth_close(struct net_device *ndev)\n{\n\tunsigned long flags;\n\tstruct netdata_local *pldat = netdev_priv(ndev);\n\n\tif (netif_msg_ifdown(pldat))\n\t\tdev_dbg(&pldat->pdev->dev, \"shutting down %s\\n\", ndev->name);\n\n\tnapi_disable(&pldat->napi);\n\tnetif_stop_queue(ndev);\n\n\tspin_lock_irqsave(&pldat->lock, flags);\n\t__lpc_eth_reset(pldat);\n\tnetif_carrier_off(ndev);\n\twritel(0, LPC_ENET_MAC1(pldat->net_base));\n\twritel(0, LPC_ENET_MAC2(pldat->net_base));\n\tspin_unlock_irqrestore(&pldat->lock, flags);\n\n\tif (ndev->phydev)\n\t\tphy_stop(ndev->phydev);\n\tclk_disable_unprepare(pldat->clk);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t lpc_eth_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *ndev)\n{\n\tstruct netdata_local *pldat = netdev_priv(ndev);\n\tu32 len, txidx;\n\tu32 *ptxstat;\n\tstruct txrx_desc_t *ptxrxdesc;\n\n\tlen = skb->len;\n\n\tspin_lock_irq(&pldat->lock);\n\n\tif (pldat->num_used_tx_buffs >= (ENET_TX_DESC - 1)) {\n\t\t \n\t\tnetif_stop_queue(ndev);\n\t\tspin_unlock_irq(&pldat->lock);\n\t\tWARN(1, \"BUG! TX request when no free TX buffers!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\ttxidx = readl(LPC_ENET_TXPRODUCEINDEX(pldat->net_base));\n\n\t \n\tptxstat = &pldat->tx_stat_v[txidx];\n\t*ptxstat = 0;\n\tptxrxdesc = &pldat->tx_desc_v[txidx];\n\tptxrxdesc->control =\n\t\t(len - 1) | TXDESC_CONTROL_LAST | TXDESC_CONTROL_INT;\n\n\t \n\tmemcpy(pldat->tx_buff_v + txidx * ENET_MAXF_SIZE, skb->data, len);\n\n\t \n\tpldat->skblen[txidx] = len;\n\tpldat->num_used_tx_buffs++;\n\n\t \n\ttxidx++;\n\tif (txidx >= ENET_TX_DESC)\n\t\ttxidx = 0;\n\twritel(txidx, LPC_ENET_TXPRODUCEINDEX(pldat->net_base));\n\n\t \n\tif (pldat->num_used_tx_buffs >= (ENET_TX_DESC - 1))\n\t\tnetif_stop_queue(ndev);\n\n\tspin_unlock_irq(&pldat->lock);\n\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int lpc_set_mac_address(struct net_device *ndev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\tstruct netdata_local *pldat = netdev_priv(ndev);\n\tunsigned long flags;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\teth_hw_addr_set(ndev, addr->sa_data);\n\n\tspin_lock_irqsave(&pldat->lock, flags);\n\n\t \n\t__lpc_set_mac(pldat, ndev->dev_addr);\n\n\tspin_unlock_irqrestore(&pldat->lock, flags);\n\n\treturn 0;\n}\n\nstatic void lpc_eth_set_multicast_list(struct net_device *ndev)\n{\n\tstruct netdata_local *pldat = netdev_priv(ndev);\n\tstruct netdev_hw_addr_list *mcptr = &ndev->mc;\n\tstruct netdev_hw_addr *ha;\n\tu32 tmp32, hash_val, hashlo, hashhi;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pldat->lock, flags);\n\n\t \n\t__lpc_set_mac(pldat, ndev->dev_addr);\n\n\ttmp32 =  LPC_RXFLTRW_ACCEPTUBROADCAST | LPC_RXFLTRW_ACCEPTPERFECT;\n\n\tif (ndev->flags & IFF_PROMISC)\n\t\ttmp32 |= LPC_RXFLTRW_ACCEPTUNICAST |\n\t\t\tLPC_RXFLTRW_ACCEPTUMULTICAST;\n\tif (ndev->flags & IFF_ALLMULTI)\n\t\ttmp32 |= LPC_RXFLTRW_ACCEPTUMULTICAST;\n\n\tif (netdev_hw_addr_list_count(mcptr))\n\t\ttmp32 |= LPC_RXFLTRW_ACCEPTUMULTICASTHASH;\n\n\twritel(tmp32, LPC_ENET_RXFILTER_CTRL(pldat->net_base));\n\n\n\t \n\thashlo = 0x0;\n\thashhi = 0x0;\n\n\t \n\tnetdev_hw_addr_list_for_each(ha, mcptr) {\n\t\thash_val = (ether_crc(6, ha->addr) >> 23) & 0x3F;\n\n\t\tif (hash_val >= 32)\n\t\t\thashhi |= 1 << (hash_val - 32);\n\t\telse\n\t\t\thashlo |= 1 << hash_val;\n\t}\n\n\twritel(hashlo, LPC_ENET_HASHFILTERL(pldat->net_base));\n\twritel(hashhi, LPC_ENET_HASHFILTERH(pldat->net_base));\n\n\tspin_unlock_irqrestore(&pldat->lock, flags);\n}\n\nstatic int lpc_eth_open(struct net_device *ndev)\n{\n\tstruct netdata_local *pldat = netdev_priv(ndev);\n\tint ret;\n\n\tif (netif_msg_ifup(pldat))\n\t\tdev_dbg(&pldat->pdev->dev, \"enabling %s\\n\", ndev->name);\n\n\tret = clk_prepare_enable(pldat->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tphy_resume(ndev->phydev);\n\n\t \n\t__lpc_eth_reset(pldat);\n\t__lpc_eth_init(pldat);\n\n\t \n\tphy_start(ndev->phydev);\n\tnetif_start_queue(ndev);\n\tnapi_enable(&pldat->napi);\n\n\treturn 0;\n}\n\n \nstatic void lpc_eth_ethtool_getdrvinfo(struct net_device *ndev,\n\tstruct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, MODNAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, dev_name(ndev->dev.parent),\n\t\tsizeof(info->bus_info));\n}\n\nstatic u32 lpc_eth_ethtool_getmsglevel(struct net_device *ndev)\n{\n\tstruct netdata_local *pldat = netdev_priv(ndev);\n\n\treturn pldat->msg_enable;\n}\n\nstatic void lpc_eth_ethtool_setmsglevel(struct net_device *ndev, u32 level)\n{\n\tstruct netdata_local *pldat = netdev_priv(ndev);\n\n\tpldat->msg_enable = level;\n}\n\nstatic const struct ethtool_ops lpc_eth_ethtool_ops = {\n\t.get_drvinfo\t= lpc_eth_ethtool_getdrvinfo,\n\t.get_msglevel\t= lpc_eth_ethtool_getmsglevel,\n\t.set_msglevel\t= lpc_eth_ethtool_setmsglevel,\n\t.get_link\t= ethtool_op_get_link,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\nstatic const struct net_device_ops lpc_netdev_ops = {\n\t.ndo_open\t\t= lpc_eth_open,\n\t.ndo_stop\t\t= lpc_eth_close,\n\t.ndo_start_xmit\t\t= lpc_eth_hard_start_xmit,\n\t.ndo_set_rx_mode\t= lpc_eth_set_multicast_list,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl_running,\n\t.ndo_set_mac_address\t= lpc_set_mac_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int lpc_eth_drv_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct netdata_local *pldat;\n\tstruct net_device *ndev;\n\tdma_addr_t dma_handle;\n\tstruct resource *res;\n\tu8 addr[ETH_ALEN];\n\tint irq, ret;\n\n\t \n\tlpc32xx_set_phy_interface_mode(lpc_phy_interface_mode(dev));\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tirq = platform_get_irq(pdev, 0);\n\tif (!res || irq < 0) {\n\t\tdev_err(dev, \"error getting resources.\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_exit;\n\t}\n\n\t \n\tndev = alloc_etherdev(sizeof(struct netdata_local));\n\tif (!ndev) {\n\t\tdev_err(dev, \"could not allocate device.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_exit;\n\t}\n\n\tSET_NETDEV_DEV(ndev, dev);\n\n\tpldat = netdev_priv(ndev);\n\tpldat->pdev = pdev;\n\tpldat->ndev = ndev;\n\n\tspin_lock_init(&pldat->lock);\n\n\t \n\tndev->irq = irq;\n\n\t \n\tpldat->clk = clk_get(dev, NULL);\n\tif (IS_ERR(pldat->clk)) {\n\t\tdev_err(dev, \"error getting clock.\\n\");\n\t\tret = PTR_ERR(pldat->clk);\n\t\tgoto err_out_free_dev;\n\t}\n\n\t \n\tret = clk_prepare_enable(pldat->clk);\n\tif (ret)\n\t\tgoto err_out_clk_put;\n\n\t \n\tpldat->net_base = ioremap(res->start, resource_size(res));\n\tif (!pldat->net_base) {\n\t\tdev_err(dev, \"failed to map registers\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_out_disable_clocks;\n\t}\n\tret = request_irq(ndev->irq, __lpc_eth_interrupt, 0,\n\t\t\t  ndev->name, ndev);\n\tif (ret) {\n\t\tdev_err(dev, \"error requesting interrupt.\\n\");\n\t\tgoto err_out_iounmap;\n\t}\n\n\t \n\tndev->netdev_ops = &lpc_netdev_ops;\n\tndev->ethtool_ops = &lpc_eth_ethtool_ops;\n\tndev->watchdog_timeo = msecs_to_jiffies(2500);\n\n\t \n\tpldat->dma_buff_size = (ENET_TX_DESC + ENET_RX_DESC) * (ENET_MAXF_SIZE +\n\t\tsizeof(struct txrx_desc_t) + sizeof(struct rx_status_t));\n\n\tif (use_iram_for_net(dev)) {\n\t\tif (pldat->dma_buff_size >\n\t\t    lpc32xx_return_iram(&pldat->dma_buff_base_v, &dma_handle)) {\n\t\t\tpldat->dma_buff_base_v = NULL;\n\t\t\tpldat->dma_buff_size = 0;\n\t\t\tnetdev_err(ndev,\n\t\t\t\t\"IRAM not big enough for net buffers, using SDRAM instead.\\n\");\n\t\t}\n\t}\n\n\tif (pldat->dma_buff_base_v == NULL) {\n\t\tret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\t\tif (ret)\n\t\t\tgoto err_out_free_irq;\n\n\t\tpldat->dma_buff_size = PAGE_ALIGN(pldat->dma_buff_size);\n\n\t\t \n\t\tpldat->dma_buff_base_v =\n\t\t\tdma_alloc_coherent(dev,\n\t\t\t\t\t   pldat->dma_buff_size, &dma_handle,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (pldat->dma_buff_base_v == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_out_free_irq;\n\t\t}\n\t}\n\tpldat->dma_buff_base_p = dma_handle;\n\n\tnetdev_dbg(ndev, \"IO address space     :%pR\\n\", res);\n\tnetdev_dbg(ndev, \"IO address size      :%zd\\n\",\n\t\t\t(size_t)resource_size(res));\n\tnetdev_dbg(ndev, \"IO address (mapped)  :0x%p\\n\",\n\t\t\tpldat->net_base);\n\tnetdev_dbg(ndev, \"IRQ number           :%d\\n\", ndev->irq);\n\tnetdev_dbg(ndev, \"DMA buffer size      :%zd\\n\", pldat->dma_buff_size);\n\tnetdev_dbg(ndev, \"DMA buffer P address :%pad\\n\",\n\t\t\t&pldat->dma_buff_base_p);\n\tnetdev_dbg(ndev, \"DMA buffer V address :0x%p\\n\",\n\t\t\tpldat->dma_buff_base_v);\n\n\tpldat->phy_node = of_parse_phandle(np, \"phy-handle\", 0);\n\n\t \n\t__lpc_get_mac(pldat, addr);\n\teth_hw_addr_set(ndev, addr);\n\n\tif (!is_valid_ether_addr(ndev->dev_addr)) {\n\t\tof_get_ethdev_address(np, ndev);\n\t}\n\tif (!is_valid_ether_addr(ndev->dev_addr))\n\t\teth_hw_addr_random(ndev);\n\n\t \n\t__lpc_eth_shutdown(pldat);\n\n\t \n\tpldat->msg_enable = NETIF_MSG_LINK;\n\n\t \n\t__lpc_mii_mngt_reset(pldat);\n\n\t \n\tpldat->link = 0;\n\tpldat->speed = 100;\n\tpldat->duplex = DUPLEX_FULL;\n\t__lpc_params_setup(pldat);\n\n\tnetif_napi_add_weight(ndev, &pldat->napi, lpc_eth_poll, NAPI_WEIGHT);\n\n\tret = register_netdev(ndev);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot register net device, aborting.\\n\");\n\t\tgoto err_out_dma_unmap;\n\t}\n\tplatform_set_drvdata(pdev, ndev);\n\n\tret = lpc_mii_init(pldat);\n\tif (ret)\n\t\tgoto err_out_unregister_netdev;\n\n\tnetdev_info(ndev, \"LPC mac at 0x%08lx irq %d\\n\",\n\t       (unsigned long)res->start, ndev->irq);\n\n\tdevice_init_wakeup(dev, 1);\n\tdevice_set_wakeup_enable(dev, 0);\n\n\treturn 0;\n\nerr_out_unregister_netdev:\n\tunregister_netdev(ndev);\nerr_out_dma_unmap:\n\tif (!use_iram_for_net(dev) ||\n\t    pldat->dma_buff_size > lpc32xx_return_iram(NULL, NULL))\n\t\tdma_free_coherent(dev, pldat->dma_buff_size,\n\t\t\t\t  pldat->dma_buff_base_v,\n\t\t\t\t  pldat->dma_buff_base_p);\nerr_out_free_irq:\n\tfree_irq(ndev->irq, ndev);\nerr_out_iounmap:\n\tiounmap(pldat->net_base);\nerr_out_disable_clocks:\n\tclk_disable_unprepare(pldat->clk);\nerr_out_clk_put:\n\tclk_put(pldat->clk);\nerr_out_free_dev:\n\tfree_netdev(ndev);\nerr_exit:\n\tpr_err(\"%s: not found (%d).\\n\", MODNAME, ret);\n\treturn ret;\n}\n\nstatic int lpc_eth_drv_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct netdata_local *pldat = netdev_priv(ndev);\n\n\tunregister_netdev(ndev);\n\n\tif (!use_iram_for_net(&pldat->pdev->dev) ||\n\t    pldat->dma_buff_size > lpc32xx_return_iram(NULL, NULL))\n\t\tdma_free_coherent(&pldat->pdev->dev, pldat->dma_buff_size,\n\t\t\t\t  pldat->dma_buff_base_v,\n\t\t\t\t  pldat->dma_buff_base_p);\n\tfree_irq(ndev->irq, ndev);\n\tiounmap(pldat->net_base);\n\tmdiobus_unregister(pldat->mii_bus);\n\tmdiobus_free(pldat->mii_bus);\n\tclk_disable_unprepare(pldat->clk);\n\tclk_put(pldat->clk);\n\tfree_netdev(ndev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int lpc_eth_drv_suspend(struct platform_device *pdev,\n\tpm_message_t state)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct netdata_local *pldat = netdev_priv(ndev);\n\n\tif (device_may_wakeup(&pdev->dev))\n\t\tenable_irq_wake(ndev->irq);\n\n\tif (ndev) {\n\t\tif (netif_running(ndev)) {\n\t\t\tnetif_device_detach(ndev);\n\t\t\t__lpc_eth_shutdown(pldat);\n\t\t\tclk_disable_unprepare(pldat->clk);\n\n\t\t\t \n\t\t\t__lpc_eth_reset(pldat);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int lpc_eth_drv_resume(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct netdata_local *pldat;\n\tint ret;\n\n\tif (device_may_wakeup(&pdev->dev))\n\t\tdisable_irq_wake(ndev->irq);\n\n\tif (ndev) {\n\t\tif (netif_running(ndev)) {\n\t\t\tpldat = netdev_priv(ndev);\n\n\t\t\t \n\t\t\tret = clk_enable(pldat->clk);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\t__lpc_eth_reset(pldat);\n\t\t\t__lpc_eth_init(pldat);\n\n\t\t\tnetif_device_attach(ndev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct of_device_id lpc_eth_match[] = {\n\t{ .compatible = \"nxp,lpc-eth\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lpc_eth_match);\n\nstatic struct platform_driver lpc_eth_driver = {\n\t.probe\t\t= lpc_eth_drv_probe,\n\t.remove\t\t= lpc_eth_drv_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= lpc_eth_drv_suspend,\n\t.resume\t\t= lpc_eth_drv_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= MODNAME,\n\t\t.of_match_table = lpc_eth_match,\n\t},\n};\n\nmodule_platform_driver(lpc_eth_driver);\n\nMODULE_AUTHOR(\"Kevin Wells <kevin.wells@nxp.com>\");\nMODULE_AUTHOR(\"Roland Stigge <stigge@antcom.de>\");\nMODULE_DESCRIPTION(\"LPC Ethernet Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}