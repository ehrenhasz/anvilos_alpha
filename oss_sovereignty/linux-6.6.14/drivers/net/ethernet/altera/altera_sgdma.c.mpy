{
  "module_name": "altera_sgdma.c",
  "hash_id": "e52b500e362586f57ae1bea0b96bc0c85b73e2b7df017e80f2d63bcc7efbc166",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/altera/altera_sgdma.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include \"altera_utils.h\"\n#include \"altera_tse.h\"\n#include \"altera_sgdmahw.h\"\n#include \"altera_sgdma.h\"\n\nstatic void sgdma_setup_descrip(struct sgdma_descrip __iomem *desc,\n\t\t\t\tstruct sgdma_descrip __iomem *ndesc,\n\t\t\t\tdma_addr_t ndesc_phys,\n\t\t\t\tdma_addr_t raddr,\n\t\t\t\tdma_addr_t waddr,\n\t\t\t\tu16 length,\n\t\t\t\tint generate_eop,\n\t\t\t\tint rfixed,\n\t\t\t\tint wfixed);\n\nstatic int sgdma_async_write(struct altera_tse_private *priv,\n\t\t\t      struct sgdma_descrip __iomem *desc);\n\nstatic int sgdma_async_read(struct altera_tse_private *priv);\n\nstatic dma_addr_t\nsgdma_txphysaddr(struct altera_tse_private *priv,\n\t\t struct sgdma_descrip __iomem *desc);\n\nstatic dma_addr_t\nsgdma_rxphysaddr(struct altera_tse_private *priv,\n\t\t struct sgdma_descrip __iomem *desc);\n\nstatic int sgdma_txbusy(struct altera_tse_private *priv);\n\nstatic int sgdma_rxbusy(struct altera_tse_private *priv);\n\nstatic void\nqueue_tx(struct altera_tse_private *priv, struct tse_buffer *buffer);\n\nstatic void\nqueue_rx(struct altera_tse_private *priv, struct tse_buffer *buffer);\n\nstatic struct tse_buffer *\ndequeue_tx(struct altera_tse_private *priv);\n\nstatic struct tse_buffer *\ndequeue_rx(struct altera_tse_private *priv);\n\nstatic struct tse_buffer *\nqueue_rx_peekhead(struct altera_tse_private *priv);\n\nint sgdma_initialize(struct altera_tse_private *priv)\n{\n\tpriv->txctrlreg = SGDMA_CTRLREG_ILASTD |\n\t\t      SGDMA_CTRLREG_INTEN;\n\n\tpriv->rxctrlreg = SGDMA_CTRLREG_IDESCRIP |\n\t\t      SGDMA_CTRLREG_INTEN |\n\t\t      SGDMA_CTRLREG_ILASTD;\n\n\tINIT_LIST_HEAD(&priv->txlisthd);\n\tINIT_LIST_HEAD(&priv->rxlisthd);\n\n\tpriv->rxdescphys = (dma_addr_t) 0;\n\tpriv->txdescphys = (dma_addr_t) 0;\n\n\tpriv->rxdescphys = dma_map_single(priv->device,\n\t\t\t\t\t  (void __force *)priv->rx_dma_desc,\n\t\t\t\t\t  priv->rxdescmem, DMA_BIDIRECTIONAL);\n\n\tif (dma_mapping_error(priv->device, priv->rxdescphys)) {\n\t\tsgdma_uninitialize(priv);\n\t\tnetdev_err(priv->dev, \"error mapping rx descriptor memory\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->txdescphys = dma_map_single(priv->device,\n\t\t\t\t\t  (void __force *)priv->tx_dma_desc,\n\t\t\t\t\t  priv->txdescmem, DMA_TO_DEVICE);\n\n\tif (dma_mapping_error(priv->device, priv->txdescphys)) {\n\t\tsgdma_uninitialize(priv);\n\t\tnetdev_err(priv->dev, \"error mapping tx descriptor memory\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemset_io(priv->tx_dma_desc, 0, priv->txdescmem);\n\tmemset_io(priv->rx_dma_desc, 0, priv->rxdescmem);\n\n\tdma_sync_single_for_device(priv->device, priv->txdescphys,\n\t\t\t\t   priv->txdescmem, DMA_TO_DEVICE);\n\n\tdma_sync_single_for_device(priv->device, priv->rxdescphys,\n\t\t\t\t   priv->rxdescmem, DMA_TO_DEVICE);\n\n\treturn 0;\n}\n\nvoid sgdma_uninitialize(struct altera_tse_private *priv)\n{\n\tif (priv->rxdescphys)\n\t\tdma_unmap_single(priv->device, priv->rxdescphys,\n\t\t\t\t priv->rxdescmem, DMA_BIDIRECTIONAL);\n\n\tif (priv->txdescphys)\n\t\tdma_unmap_single(priv->device, priv->txdescphys,\n\t\t\t\t priv->txdescmem, DMA_TO_DEVICE);\n}\n\n \nvoid sgdma_reset(struct altera_tse_private *priv)\n{\n\t \n\tmemset_io(priv->tx_dma_desc, 0, priv->txdescmem);\n\tmemset_io(priv->rx_dma_desc, 0, priv->rxdescmem);\n\n\tcsrwr32(SGDMA_CTRLREG_RESET, priv->tx_dma_csr, sgdma_csroffs(control));\n\tcsrwr32(0, priv->tx_dma_csr, sgdma_csroffs(control));\n\n\tcsrwr32(SGDMA_CTRLREG_RESET, priv->rx_dma_csr, sgdma_csroffs(control));\n\tcsrwr32(0, priv->rx_dma_csr, sgdma_csroffs(control));\n}\n\n \n\nvoid sgdma_enable_rxirq(struct altera_tse_private *priv)\n{\n}\n\nvoid sgdma_enable_txirq(struct altera_tse_private *priv)\n{\n}\n\nvoid sgdma_disable_rxirq(struct altera_tse_private *priv)\n{\n}\n\nvoid sgdma_disable_txirq(struct altera_tse_private *priv)\n{\n}\n\nvoid sgdma_clear_rxirq(struct altera_tse_private *priv)\n{\n\ttse_set_bit(priv->rx_dma_csr, sgdma_csroffs(control),\n\t\t    SGDMA_CTRLREG_CLRINT);\n}\n\nvoid sgdma_clear_txirq(struct altera_tse_private *priv)\n{\n\ttse_set_bit(priv->tx_dma_csr, sgdma_csroffs(control),\n\t\t    SGDMA_CTRLREG_CLRINT);\n}\n\n \nint sgdma_tx_buffer(struct altera_tse_private *priv, struct tse_buffer *buffer)\n{\n\tstruct sgdma_descrip __iomem *descbase =\n\t\t(struct sgdma_descrip __iomem *)priv->tx_dma_desc;\n\n\tstruct sgdma_descrip __iomem *cdesc = &descbase[0];\n\tstruct sgdma_descrip __iomem *ndesc = &descbase[1];\n\n\t \n\tif (sgdma_txbusy(priv))\n\t\treturn 0;\n\n\tsgdma_setup_descrip(cdesc,\t\t\t \n\t\t\t    ndesc,\t\t\t \n\t\t\t    sgdma_txphysaddr(priv, ndesc),\n\t\t\t    buffer->dma_addr,\t\t \n\t\t\t    0,\t\t\t\t \n\t\t\t    buffer->len,\t\t \n\t\t\t    SGDMA_CONTROL_EOP,\t\t \n\t\t\t    0,\t\t\t\t \n\t\t\t    SGDMA_CONTROL_WR_FIXED);\t \n\n\tsgdma_async_write(priv, cdesc);\n\n\t \n\tqueue_tx(priv, buffer);\n\n\treturn 1;\n}\n\n\n \nu32 sgdma_tx_completions(struct altera_tse_private *priv)\n{\n\tu32 ready = 0;\n\n\tif (!sgdma_txbusy(priv) &&\n\t    ((csrrd8(priv->tx_dma_desc, sgdma_descroffs(control))\n\t     & SGDMA_CONTROL_HW_OWNED) == 0) &&\n\t    (dequeue_tx(priv))) {\n\t\tready = 1;\n\t}\n\n\treturn ready;\n}\n\nvoid sgdma_start_rxdma(struct altera_tse_private *priv)\n{\n\tsgdma_async_read(priv);\n}\n\nvoid sgdma_add_rx_desc(struct altera_tse_private *priv,\n\t\t       struct tse_buffer *rxbuffer)\n{\n\tqueue_rx(priv, rxbuffer);\n}\n\n \nu32 sgdma_rx_status(struct altera_tse_private *priv)\n{\n\tstruct sgdma_descrip __iomem *base =\n\t\t(struct sgdma_descrip __iomem *)priv->rx_dma_desc;\n\tstruct sgdma_descrip __iomem *desc = NULL;\n\tstruct tse_buffer *rxbuffer = NULL;\n\tunsigned int rxstatus = 0;\n\n\tu32 sts = csrrd32(priv->rx_dma_csr, sgdma_csroffs(status));\n\n\tdesc = &base[0];\n\tif (sts & SGDMA_STSREG_EOP) {\n\t\tunsigned int pktlength = 0;\n\t\tunsigned int pktstatus = 0;\n\t\tdma_sync_single_for_cpu(priv->device,\n\t\t\t\t\tpriv->rxdescphys,\n\t\t\t\t\tSGDMA_DESC_LEN,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\tpktlength = csrrd16(desc, sgdma_descroffs(bytes_xferred));\n\t\tpktstatus = csrrd8(desc, sgdma_descroffs(status));\n\t\trxstatus = pktstatus & ~SGDMA_STATUS_EOP;\n\t\trxstatus = rxstatus << 16;\n\t\trxstatus |= (pktlength & 0xffff);\n\n\t\tif (rxstatus) {\n\t\t\tcsrwr8(0, desc, sgdma_descroffs(status));\n\n\t\t\trxbuffer = dequeue_rx(priv);\n\t\t\tif (rxbuffer == NULL)\n\t\t\t\tnetdev_info(priv->dev,\n\t\t\t\t\t    \"sgdma rx and rx queue empty!\\n\");\n\n\t\t\t \n\t\t\tcsrwr32(0, priv->rx_dma_csr, sgdma_csroffs(control));\n\t\t\t \n\t\t\tcsrwr32(0xf, priv->rx_dma_csr, sgdma_csroffs(status));\n\n\t\t\t \n\t\t\tsgdma_async_read(priv);\n\n\t\t} else {\n\t\t\t \n\t\t\tnetdev_err(priv->dev,\n\t\t\t\t   \"SGDMA RX Error Info: %x, %x, %x\\n\",\n\t\t\t\t   sts, csrrd8(desc, sgdma_descroffs(status)),\n\t\t\t\t   rxstatus);\n\t\t}\n\t} else if (sts == 0) {\n\t\tsgdma_async_read(priv);\n\t}\n\n\treturn rxstatus;\n}\n\n\n \nstatic void sgdma_setup_descrip(struct sgdma_descrip __iomem *desc,\n\t\t\t\tstruct sgdma_descrip __iomem *ndesc,\n\t\t\t\tdma_addr_t ndesc_phys,\n\t\t\t\tdma_addr_t raddr,\n\t\t\t\tdma_addr_t waddr,\n\t\t\t\tu16 length,\n\t\t\t\tint generate_eop,\n\t\t\t\tint rfixed,\n\t\t\t\tint wfixed)\n{\n\t \n\n\tu32 ctrl = csrrd8(ndesc, sgdma_descroffs(control));\n\tctrl &= ~SGDMA_CONTROL_HW_OWNED;\n\tcsrwr8(ctrl, ndesc, sgdma_descroffs(control));\n\n\tctrl = SGDMA_CONTROL_HW_OWNED;\n\tctrl |= generate_eop;\n\tctrl |= rfixed;\n\tctrl |= wfixed;\n\n\t \n\tcsrwr32(lower_32_bits(raddr), desc, sgdma_descroffs(raddr));\n\tcsrwr32(lower_32_bits(waddr), desc, sgdma_descroffs(waddr));\n\n\tcsrwr32(0, desc, sgdma_descroffs(pad1));\n\tcsrwr32(0, desc, sgdma_descroffs(pad2));\n\tcsrwr32(lower_32_bits(ndesc_phys), desc, sgdma_descroffs(next));\n\n\tcsrwr8(ctrl, desc, sgdma_descroffs(control));\n\tcsrwr8(0, desc, sgdma_descroffs(status));\n\tcsrwr8(0, desc, sgdma_descroffs(wburst));\n\tcsrwr8(0, desc, sgdma_descroffs(rburst));\n\tcsrwr16(length, desc, sgdma_descroffs(bytes));\n\tcsrwr16(0, desc, sgdma_descroffs(bytes_xferred));\n}\n\n \nstatic int sgdma_async_read(struct altera_tse_private *priv)\n{\n\tstruct sgdma_descrip __iomem *descbase =\n\t\t(struct sgdma_descrip __iomem *)priv->rx_dma_desc;\n\n\tstruct sgdma_descrip __iomem *cdesc = &descbase[0];\n\tstruct sgdma_descrip __iomem *ndesc = &descbase[1];\n\tstruct tse_buffer *rxbuffer = NULL;\n\n\tif (!sgdma_rxbusy(priv)) {\n\t\trxbuffer = queue_rx_peekhead(priv);\n\t\tif (rxbuffer == NULL) {\n\t\t\tnetdev_err(priv->dev, \"no rx buffers available\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tsgdma_setup_descrip(cdesc,\t\t \n\t\t\t\t    ndesc,\t\t \n\t\t\t\t    sgdma_rxphysaddr(priv, ndesc),\n\t\t\t\t    0,\t\t\t \n\t\t\t\t    rxbuffer->dma_addr,  \n\t\t\t\t    0,\t\t\t \n\t\t\t\t    0,\t\t\t \n\t\t\t\t    0,\t\t\t \n\t\t\t\t    0);\t\t\t \n\n\t\tdma_sync_single_for_device(priv->device,\n\t\t\t\t\t   priv->rxdescphys,\n\t\t\t\t\t   SGDMA_DESC_LEN,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\n\t\tcsrwr32(lower_32_bits(sgdma_rxphysaddr(priv, cdesc)),\n\t\t\tpriv->rx_dma_csr,\n\t\t\tsgdma_csroffs(next_descrip));\n\n\t\tcsrwr32((priv->rxctrlreg | SGDMA_CTRLREG_START),\n\t\t\tpriv->rx_dma_csr,\n\t\t\tsgdma_csroffs(control));\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int sgdma_async_write(struct altera_tse_private *priv,\n\t\t\t     struct sgdma_descrip __iomem *desc)\n{\n\tif (sgdma_txbusy(priv))\n\t\treturn 0;\n\n\t \n\tcsrwr32(0, priv->tx_dma_csr, sgdma_csroffs(control));\n\tcsrwr32(0x1f, priv->tx_dma_csr, sgdma_csroffs(status));\n\n\tdma_sync_single_for_device(priv->device, priv->txdescphys,\n\t\t\t\t   SGDMA_DESC_LEN, DMA_TO_DEVICE);\n\n\tcsrwr32(lower_32_bits(sgdma_txphysaddr(priv, desc)),\n\t\tpriv->tx_dma_csr,\n\t\tsgdma_csroffs(next_descrip));\n\n\tcsrwr32((priv->txctrlreg | SGDMA_CTRLREG_START),\n\t\tpriv->tx_dma_csr,\n\t\tsgdma_csroffs(control));\n\n\treturn 1;\n}\n\nstatic dma_addr_t\nsgdma_txphysaddr(struct altera_tse_private *priv,\n\t\t struct sgdma_descrip __iomem *desc)\n{\n\tdma_addr_t paddr = priv->txdescmem_busaddr;\n\tuintptr_t offs = (uintptr_t)desc - (uintptr_t)priv->tx_dma_desc;\n\treturn (dma_addr_t)((uintptr_t)paddr + offs);\n}\n\nstatic dma_addr_t\nsgdma_rxphysaddr(struct altera_tse_private *priv,\n\t\t struct sgdma_descrip __iomem *desc)\n{\n\tdma_addr_t paddr = priv->rxdescmem_busaddr;\n\tuintptr_t offs = (uintptr_t)desc - (uintptr_t)priv->rx_dma_desc;\n\treturn (dma_addr_t)((uintptr_t)paddr + offs);\n}\n\n#define list_remove_head(list, entry, type, member)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tentry = NULL;\t\t\t\t\t\t\\\n\t\tif (!list_empty(list)) {\t\t\t\t\\\n\t\t\tentry = list_entry((list)->next, type, member);\t\\\n\t\t\tlist_del_init(&entry->member);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define list_peek_head(list, entry, type, member)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tentry = NULL;\t\t\t\t\t\t\\\n\t\tif (!list_empty(list)) {\t\t\t\t\\\n\t\t\tentry = list_entry((list)->next, type, member);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n \nstatic void\nqueue_tx(struct altera_tse_private *priv, struct tse_buffer *buffer)\n{\n\tlist_add_tail(&buffer->lh, &priv->txlisthd);\n}\n\n\n \nstatic void\nqueue_rx(struct altera_tse_private *priv, struct tse_buffer *buffer)\n{\n\tlist_add_tail(&buffer->lh, &priv->rxlisthd);\n}\n\n \nstatic struct tse_buffer *\ndequeue_tx(struct altera_tse_private *priv)\n{\n\tstruct tse_buffer *buffer = NULL;\n\tlist_remove_head(&priv->txlisthd, buffer, struct tse_buffer, lh);\n\treturn buffer;\n}\n\n \nstatic struct tse_buffer *\ndequeue_rx(struct altera_tse_private *priv)\n{\n\tstruct tse_buffer *buffer = NULL;\n\tlist_remove_head(&priv->rxlisthd, buffer, struct tse_buffer, lh);\n\treturn buffer;\n}\n\n \nstatic struct tse_buffer *\nqueue_rx_peekhead(struct altera_tse_private *priv)\n{\n\tstruct tse_buffer *buffer = NULL;\n\tlist_peek_head(&priv->rxlisthd, buffer, struct tse_buffer, lh);\n\treturn buffer;\n}\n\n \nstatic int sgdma_rxbusy(struct altera_tse_private *priv)\n{\n\treturn csrrd32(priv->rx_dma_csr, sgdma_csroffs(status))\n\t\t       & SGDMA_STSREG_BUSY;\n}\n\n \nstatic int sgdma_txbusy(struct altera_tse_private *priv)\n{\n\tint delay = 0;\n\n\t \n\twhile ((csrrd32(priv->tx_dma_csr, sgdma_csroffs(status))\n\t\t& SGDMA_STSREG_BUSY) && (delay++ < 100))\n\t\tudelay(1);\n\n\tif (csrrd32(priv->tx_dma_csr, sgdma_csroffs(status))\n\t    & SGDMA_STSREG_BUSY) {\n\t\tnetdev_err(priv->dev, \"timeout waiting for tx dma\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}