{
  "module_name": "altera_msgdma.c",
  "hash_id": "e5ef908469cfaa1170efeecc4ba7be14c5361c61c9a94f8ca2eb933fa696a347",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/altera/altera_msgdma.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include \"altera_utils.h\"\n#include \"altera_tse.h\"\n#include \"altera_msgdmahw.h\"\n#include \"altera_msgdma.h\"\n\n \nint msgdma_initialize(struct altera_tse_private *priv)\n{\n\treturn 0;\n}\n\nvoid msgdma_uninitialize(struct altera_tse_private *priv)\n{\n}\n\nvoid msgdma_start_rxdma(struct altera_tse_private *priv)\n{\n}\n\nvoid msgdma_reset(struct altera_tse_private *priv)\n{\n\tint counter;\n\n\t \n\tcsrwr32(MSGDMA_CSR_STAT_MASK, priv->rx_dma_csr,\n\t\tmsgdma_csroffs(status));\n\tcsrwr32(MSGDMA_CSR_CTL_RESET, priv->rx_dma_csr,\n\t\tmsgdma_csroffs(control));\n\n\tcounter = 0;\n\twhile (counter++ < ALTERA_TSE_SW_RESET_WATCHDOG_CNTR) {\n\t\tif (tse_bit_is_clear(priv->rx_dma_csr, msgdma_csroffs(status),\n\t\t\t\t     MSGDMA_CSR_STAT_RESETTING))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (counter >= ALTERA_TSE_SW_RESET_WATCHDOG_CNTR)\n\t\tnetif_warn(priv, drv, priv->dev,\n\t\t\t   \"TSE Rx mSGDMA resetting bit never cleared!\\n\");\n\n\t \n\tcsrwr32(MSGDMA_CSR_STAT_MASK, priv->rx_dma_csr, msgdma_csroffs(status));\n\n\t \n\tcsrwr32(MSGDMA_CSR_STAT_MASK, priv->tx_dma_csr,\n\t\tmsgdma_csroffs(status));\n\n\tcsrwr32(MSGDMA_CSR_CTL_RESET, priv->tx_dma_csr,\n\t\tmsgdma_csroffs(control));\n\n\tcounter = 0;\n\twhile (counter++ < ALTERA_TSE_SW_RESET_WATCHDOG_CNTR) {\n\t\tif (tse_bit_is_clear(priv->tx_dma_csr, msgdma_csroffs(status),\n\t\t\t\t     MSGDMA_CSR_STAT_RESETTING))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (counter >= ALTERA_TSE_SW_RESET_WATCHDOG_CNTR)\n\t\tnetif_warn(priv, drv, priv->dev,\n\t\t\t   \"TSE Tx mSGDMA resetting bit never cleared!\\n\");\n\n\t \n\tcsrwr32(MSGDMA_CSR_STAT_MASK, priv->tx_dma_csr, msgdma_csroffs(status));\n}\n\nvoid msgdma_disable_rxirq(struct altera_tse_private *priv)\n{\n\ttse_clear_bit(priv->rx_dma_csr, msgdma_csroffs(control),\n\t\t      MSGDMA_CSR_CTL_GLOBAL_INTR);\n}\n\nvoid msgdma_enable_rxirq(struct altera_tse_private *priv)\n{\n\ttse_set_bit(priv->rx_dma_csr, msgdma_csroffs(control),\n\t\t    MSGDMA_CSR_CTL_GLOBAL_INTR);\n}\n\nvoid msgdma_disable_txirq(struct altera_tse_private *priv)\n{\n\ttse_clear_bit(priv->tx_dma_csr, msgdma_csroffs(control),\n\t\t      MSGDMA_CSR_CTL_GLOBAL_INTR);\n}\n\nvoid msgdma_enable_txirq(struct altera_tse_private *priv)\n{\n\ttse_set_bit(priv->tx_dma_csr, msgdma_csroffs(control),\n\t\t    MSGDMA_CSR_CTL_GLOBAL_INTR);\n}\n\nvoid msgdma_clear_rxirq(struct altera_tse_private *priv)\n{\n\tcsrwr32(MSGDMA_CSR_STAT_IRQ, priv->rx_dma_csr, msgdma_csroffs(status));\n}\n\nvoid msgdma_clear_txirq(struct altera_tse_private *priv)\n{\n\tcsrwr32(MSGDMA_CSR_STAT_IRQ, priv->tx_dma_csr, msgdma_csroffs(status));\n}\n\n \nint msgdma_tx_buffer(struct altera_tse_private *priv, struct tse_buffer *buffer)\n{\n\tcsrwr32(lower_32_bits(buffer->dma_addr), priv->tx_dma_desc,\n\t\tmsgdma_descroffs(read_addr_lo));\n\tcsrwr32(upper_32_bits(buffer->dma_addr), priv->tx_dma_desc,\n\t\tmsgdma_descroffs(read_addr_hi));\n\tcsrwr32(0, priv->tx_dma_desc, msgdma_descroffs(write_addr_lo));\n\tcsrwr32(0, priv->tx_dma_desc, msgdma_descroffs(write_addr_hi));\n\tcsrwr32(buffer->len, priv->tx_dma_desc, msgdma_descroffs(len));\n\tcsrwr32(0, priv->tx_dma_desc, msgdma_descroffs(burst_seq_num));\n\tcsrwr32(MSGDMA_DESC_TX_STRIDE, priv->tx_dma_desc,\n\t\tmsgdma_descroffs(stride));\n\tcsrwr32(MSGDMA_DESC_CTL_TX_SINGLE, priv->tx_dma_desc,\n\t\tmsgdma_descroffs(control));\n\treturn 0;\n}\n\nu32 msgdma_tx_completions(struct altera_tse_private *priv)\n{\n\tu32 ready = 0;\n\tu32 inuse;\n\tu32 status;\n\n\t \n\tinuse = csrrd32(priv->tx_dma_csr, msgdma_csroffs(rw_fill_level))\n\t\t\t& 0xffff;\n\n\tif (inuse) {  \n\t\tready = max_t(int,\n\t\t\t      priv->tx_prod - priv->tx_cons - inuse - 1, 0);\n\t} else {\n\t\t \n\t\tstatus = csrrd32(priv->tx_dma_csr, msgdma_csroffs(status));\n\t\tif (status & MSGDMA_CSR_STAT_BUSY)\n\t\t\tready = priv->tx_prod - priv->tx_cons - 1;\n\t\telse\n\t\t\tready = priv->tx_prod - priv->tx_cons;\n\t}\n\treturn ready;\n}\n\n \nvoid msgdma_add_rx_desc(struct altera_tse_private *priv,\n\t\t\tstruct tse_buffer *rxbuffer)\n{\n\tu32 len = priv->rx_dma_buf_sz;\n\tdma_addr_t dma_addr = rxbuffer->dma_addr;\n\tu32 control = (MSGDMA_DESC_CTL_END_ON_EOP\n\t\t\t| MSGDMA_DESC_CTL_END_ON_LEN\n\t\t\t| MSGDMA_DESC_CTL_TR_COMP_IRQ\n\t\t\t| MSGDMA_DESC_CTL_EARLY_IRQ\n\t\t\t| MSGDMA_DESC_CTL_TR_ERR_IRQ\n\t\t\t| MSGDMA_DESC_CTL_GO);\n\n\tcsrwr32(0, priv->rx_dma_desc, msgdma_descroffs(read_addr_lo));\n\tcsrwr32(0, priv->rx_dma_desc, msgdma_descroffs(read_addr_hi));\n\tcsrwr32(lower_32_bits(dma_addr), priv->rx_dma_desc,\n\t\tmsgdma_descroffs(write_addr_lo));\n\tcsrwr32(upper_32_bits(dma_addr), priv->rx_dma_desc,\n\t\tmsgdma_descroffs(write_addr_hi));\n\tcsrwr32(len, priv->rx_dma_desc, msgdma_descroffs(len));\n\tcsrwr32(0, priv->rx_dma_desc, msgdma_descroffs(burst_seq_num));\n\tcsrwr32(0x00010001, priv->rx_dma_desc, msgdma_descroffs(stride));\n\tcsrwr32(control, priv->rx_dma_desc, msgdma_descroffs(control));\n}\n\n \nu32 msgdma_rx_status(struct altera_tse_private *priv)\n{\n\tu32 rxstatus = 0;\n\tu32 pktlength;\n\tu32 pktstatus;\n\n\tif (csrrd32(priv->rx_dma_csr, msgdma_csroffs(resp_fill_level))\n\t    & 0xffff) {\n\t\tpktlength = csrrd32(priv->rx_dma_resp,\n\t\t\t\t    msgdma_respoffs(bytes_transferred));\n\t\tpktstatus = csrrd32(priv->rx_dma_resp,\n\t\t\t\t    msgdma_respoffs(status));\n\t\trxstatus = pktstatus;\n\t\trxstatus = rxstatus << 16;\n\t\trxstatus |= (pktlength & 0xffff);\n\t}\n\treturn rxstatus;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}