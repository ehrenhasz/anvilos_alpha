{
  "module_name": "altera_tse_main.c",
  "hash_id": "142f14bf2428072f476854733eeb29857c3393049b13647fff013a4c8fbea47b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/altera/altera_tse_main.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/mdio/mdio-regmap.h>\n#include <linux/netdevice.h>\n#include <linux/of_device.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_platform.h>\n#include <linux/pcs-lynx.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/skbuff.h>\n#include <asm/cacheflush.h>\n\n#include \"altera_utils.h\"\n#include \"altera_tse.h\"\n#include \"altera_sgdma.h\"\n#include \"altera_msgdma.h\"\n\nstatic atomic_t instance_count = ATOMIC_INIT(~0);\n \nstatic int debug = -1;\nmodule_param(debug, int, 0644);\nMODULE_PARM_DESC(debug, \"Message Level (-1: default, 0: no output, 16: all)\");\n\nstatic const u32 default_msg_level = (NETIF_MSG_DRV | NETIF_MSG_PROBE |\n\t\t\t\t\tNETIF_MSG_LINK | NETIF_MSG_IFUP |\n\t\t\t\t\tNETIF_MSG_IFDOWN);\n\n#define RX_DESCRIPTORS 64\nstatic int dma_rx_num = RX_DESCRIPTORS;\nmodule_param(dma_rx_num, int, 0644);\nMODULE_PARM_DESC(dma_rx_num, \"Number of descriptors in the RX list\");\n\n#define TX_DESCRIPTORS 64\nstatic int dma_tx_num = TX_DESCRIPTORS;\nmodule_param(dma_tx_num, int, 0644);\nMODULE_PARM_DESC(dma_tx_num, \"Number of descriptors in the TX list\");\n\n\n#define POLL_PHY (-1)\n\n \n#define ALTERA_RXDMABUFFER_SIZE\t2048\n\n \n#define TSE_TX_THRESH(x)\t(x->tx_ring_size / 4)\n\n#define TXQUEUESTOP_THRESHHOLD\t2\n\nstatic const struct of_device_id altera_tse_ids[];\n\nstatic inline u32 tse_tx_avail(struct altera_tse_private *priv)\n{\n\treturn priv->tx_cons + priv->tx_ring_size - priv->tx_prod - 1;\n}\n\n \nstatic int altera_tse_mdio_read(struct mii_bus *bus, int mii_id, int regnum)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct altera_tse_private *priv = netdev_priv(ndev);\n\n\t \n\tcsrwr32((mii_id & 0x1f), priv->mac_dev,\n\t\ttse_csroffs(mdio_phy1_addr));\n\n\t \n\treturn csrrd32(priv->mac_dev,\n\t\t       tse_csroffs(mdio_phy1) + regnum * 4) & 0xffff;\n}\n\nstatic int altera_tse_mdio_write(struct mii_bus *bus, int mii_id, int regnum,\n\t\t\t\t u16 value)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct altera_tse_private *priv = netdev_priv(ndev);\n\n\t \n\tcsrwr32((mii_id & 0x1f), priv->mac_dev,\n\t\ttse_csroffs(mdio_phy1_addr));\n\n\t \n\tcsrwr32(value, priv->mac_dev, tse_csroffs(mdio_phy1) + regnum * 4);\n\treturn 0;\n}\n\nstatic int altera_tse_mdio_create(struct net_device *dev, unsigned int id)\n{\n\tstruct altera_tse_private *priv = netdev_priv(dev);\n\tstruct device_node *mdio_node = NULL;\n\tstruct device_node *child_node = NULL;\n\tstruct mii_bus *mdio = NULL;\n\tint ret;\n\n\tfor_each_child_of_node(priv->device->of_node, child_node) {\n\t\tif (of_device_is_compatible(child_node, \"altr,tse-mdio\")) {\n\t\t\tmdio_node = child_node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (mdio_node) {\n\t\tnetdev_dbg(dev, \"FOUND MDIO subnode\\n\");\n\t} else {\n\t\tnetdev_dbg(dev, \"NO MDIO subnode\\n\");\n\t\treturn 0;\n\t}\n\n\tmdio = mdiobus_alloc();\n\tif (mdio == NULL) {\n\t\tnetdev_err(dev, \"Error allocating MDIO bus\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto put_node;\n\t}\n\n\tmdio->name = ALTERA_TSE_RESOURCE_NAME;\n\tmdio->read = &altera_tse_mdio_read;\n\tmdio->write = &altera_tse_mdio_write;\n\tsnprintf(mdio->id, MII_BUS_ID_SIZE, \"%s-%u\", mdio->name, id);\n\n\tmdio->priv = dev;\n\tmdio->parent = priv->device;\n\n\tret = of_mdiobus_register(mdio, mdio_node);\n\tif (ret != 0) {\n\t\tnetdev_err(dev, \"Cannot register MDIO bus %s\\n\",\n\t\t\t   mdio->id);\n\t\tgoto out_free_mdio;\n\t}\n\tof_node_put(mdio_node);\n\n\tif (netif_msg_drv(priv))\n\t\tnetdev_info(dev, \"MDIO bus %s: created\\n\", mdio->id);\n\n\tpriv->mdio = mdio;\n\treturn 0;\nout_free_mdio:\n\tmdiobus_free(mdio);\n\tmdio = NULL;\nput_node:\n\tof_node_put(mdio_node);\n\treturn ret;\n}\n\nstatic void altera_tse_mdio_destroy(struct net_device *dev)\n{\n\tstruct altera_tse_private *priv = netdev_priv(dev);\n\n\tif (priv->mdio == NULL)\n\t\treturn;\n\n\tif (netif_msg_drv(priv))\n\t\tnetdev_info(dev, \"MDIO bus %s: removed\\n\",\n\t\t\t    priv->mdio->id);\n\n\tmdiobus_unregister(priv->mdio);\n\tmdiobus_free(priv->mdio);\n\tpriv->mdio = NULL;\n}\n\nstatic int tse_init_rx_buffer(struct altera_tse_private *priv,\n\t\t\t      struct tse_buffer *rxbuffer, int len)\n{\n\trxbuffer->skb = netdev_alloc_skb_ip_align(priv->dev, len);\n\tif (!rxbuffer->skb)\n\t\treturn -ENOMEM;\n\n\trxbuffer->dma_addr = dma_map_single(priv->device, rxbuffer->skb->data,\n\t\t\t\t\t\tlen,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\n\tif (dma_mapping_error(priv->device, rxbuffer->dma_addr)) {\n\t\tnetdev_err(priv->dev, \"%s: DMA mapping error\\n\", __func__);\n\t\tdev_kfree_skb_any(rxbuffer->skb);\n\t\treturn -EINVAL;\n\t}\n\trxbuffer->dma_addr &= (dma_addr_t)~3;\n\trxbuffer->len = len;\n\treturn 0;\n}\n\nstatic void tse_free_rx_buffer(struct altera_tse_private *priv,\n\t\t\t       struct tse_buffer *rxbuffer)\n{\n\tdma_addr_t dma_addr = rxbuffer->dma_addr;\n\tstruct sk_buff *skb = rxbuffer->skb;\n\n\tif (skb != NULL) {\n\t\tif (dma_addr)\n\t\t\tdma_unmap_single(priv->device, dma_addr,\n\t\t\t\t\t rxbuffer->len,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t\trxbuffer->skb = NULL;\n\t\trxbuffer->dma_addr = 0;\n\t}\n}\n\n \nstatic void tse_free_tx_buffer(struct altera_tse_private *priv,\n\t\t\t       struct tse_buffer *buffer)\n{\n\tif (buffer->dma_addr) {\n\t\tif (buffer->mapped_as_page)\n\t\t\tdma_unmap_page(priv->device, buffer->dma_addr,\n\t\t\t\t       buffer->len, DMA_TO_DEVICE);\n\t\telse\n\t\t\tdma_unmap_single(priv->device, buffer->dma_addr,\n\t\t\t\t\t buffer->len, DMA_TO_DEVICE);\n\t\tbuffer->dma_addr = 0;\n\t}\n\tif (buffer->skb) {\n\t\tdev_kfree_skb_any(buffer->skb);\n\t\tbuffer->skb = NULL;\n\t}\n}\n\nstatic int alloc_init_skbufs(struct altera_tse_private *priv)\n{\n\tunsigned int rx_descs = priv->rx_ring_size;\n\tunsigned int tx_descs = priv->tx_ring_size;\n\tint ret = -ENOMEM;\n\tint i;\n\n\t \n\tpriv->rx_ring = kcalloc(rx_descs, sizeof(struct tse_buffer),\n\t\t\t\tGFP_KERNEL);\n\tif (!priv->rx_ring)\n\t\tgoto err_rx_ring;\n\n\t \n\tpriv->tx_ring = kcalloc(tx_descs, sizeof(struct tse_buffer),\n\t\t\t\tGFP_KERNEL);\n\tif (!priv->tx_ring)\n\t\tgoto err_tx_ring;\n\n\tpriv->tx_cons = 0;\n\tpriv->tx_prod = 0;\n\n\t \n\tfor (i = 0; i < rx_descs; i++) {\n\t\tret = tse_init_rx_buffer(priv, &priv->rx_ring[i],\n\t\t\t\t\t priv->rx_dma_buf_sz);\n\t\tif (ret)\n\t\t\tgoto err_init_rx_buffers;\n\t}\n\n\tpriv->rx_cons = 0;\n\tpriv->rx_prod = 0;\n\n\treturn 0;\nerr_init_rx_buffers:\n\twhile (--i >= 0)\n\t\ttse_free_rx_buffer(priv, &priv->rx_ring[i]);\n\tkfree(priv->tx_ring);\nerr_tx_ring:\n\tkfree(priv->rx_ring);\nerr_rx_ring:\n\treturn ret;\n}\n\nstatic void free_skbufs(struct net_device *dev)\n{\n\tstruct altera_tse_private *priv = netdev_priv(dev);\n\tunsigned int rx_descs = priv->rx_ring_size;\n\tunsigned int tx_descs = priv->tx_ring_size;\n\tint i;\n\n\t \n\tfor (i = 0; i < rx_descs; i++)\n\t\ttse_free_rx_buffer(priv, &priv->rx_ring[i]);\n\tfor (i = 0; i < tx_descs; i++)\n\t\ttse_free_tx_buffer(priv, &priv->tx_ring[i]);\n\n\n\tkfree(priv->tx_ring);\n}\n\n \nstatic inline void tse_rx_refill(struct altera_tse_private *priv)\n{\n\tunsigned int rxsize = priv->rx_ring_size;\n\tunsigned int entry;\n\tint ret;\n\n\tfor (; priv->rx_cons - priv->rx_prod > 0;\n\t\t\tpriv->rx_prod++) {\n\t\tentry = priv->rx_prod % rxsize;\n\t\tif (likely(priv->rx_ring[entry].skb == NULL)) {\n\t\t\tret = tse_init_rx_buffer(priv, &priv->rx_ring[entry],\n\t\t\t\tpriv->rx_dma_buf_sz);\n\t\t\tif (unlikely(ret != 0))\n\t\t\t\tbreak;\n\t\t\tpriv->dmaops->add_rx_desc(priv, &priv->rx_ring[entry]);\n\t\t}\n\t}\n}\n\n \nstatic inline void tse_rx_vlan(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct ethhdr *eth_hdr;\n\tu16 vid;\n\n\tif ((dev->features & NETIF_F_HW_VLAN_CTAG_RX) &&\n\t    !__vlan_get_tag(skb, &vid)) {\n\t\teth_hdr = (struct ethhdr *)skb->data;\n\t\tmemmove(skb->data + VLAN_HLEN, eth_hdr, ETH_ALEN * 2);\n\t\tskb_pull(skb, VLAN_HLEN);\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);\n\t}\n}\n\n \nstatic int tse_rx(struct altera_tse_private *priv, int limit)\n{\n\tunsigned int entry = priv->rx_cons % priv->rx_ring_size;\n\tunsigned int next_entry;\n\tunsigned int count = 0;\n\tstruct sk_buff *skb;\n\tu32 rxstatus;\n\tu16 pktlength;\n\tu16 pktstatus;\n\n\t \n\twhile ((count < limit) &&\n\t       ((rxstatus = priv->dmaops->get_rx_status(priv)) != 0)) {\n\t\tpktstatus = rxstatus >> 16;\n\t\tpktlength = rxstatus & 0xffff;\n\n\t\tif ((pktstatus & 0xFF) || (pktlength == 0))\n\t\t\tnetdev_err(priv->dev,\n\t\t\t\t   \"RCV pktstatus %08X pktlength %08X\\n\",\n\t\t\t\t   pktstatus, pktlength);\n\n\t\t \n\t\tpktlength -= 2;\n\n\t\tcount++;\n\t\tnext_entry = (++priv->rx_cons) % priv->rx_ring_size;\n\n\t\tskb = priv->rx_ring[entry].skb;\n\t\tif (unlikely(!skb)) {\n\t\t\tnetdev_err(priv->dev,\n\t\t\t\t   \"%s: Inconsistent Rx descriptor chain\\n\",\n\t\t\t\t   __func__);\n\t\t\tpriv->dev->stats.rx_dropped++;\n\t\t\tbreak;\n\t\t}\n\t\tpriv->rx_ring[entry].skb = NULL;\n\n\t\tskb_put(skb, pktlength);\n\n\t\tdma_unmap_single(priv->device, priv->rx_ring[entry].dma_addr,\n\t\t\t\t priv->rx_ring[entry].len, DMA_FROM_DEVICE);\n\n\t\tif (netif_msg_pktdata(priv)) {\n\t\t\tnetdev_info(priv->dev, \"frame received %d bytes\\n\",\n\t\t\t\t    pktlength);\n\t\t\tprint_hex_dump(KERN_ERR, \"data: \", DUMP_PREFIX_OFFSET,\n\t\t\t\t       16, 1, skb->data, pktlength, true);\n\t\t}\n\n\t\ttse_rx_vlan(priv->dev, skb);\n\n\t\tskb->protocol = eth_type_trans(skb, priv->dev);\n\t\tskb_checksum_none_assert(skb);\n\n\t\tnapi_gro_receive(&priv->napi, skb);\n\n\t\tpriv->dev->stats.rx_packets++;\n\t\tpriv->dev->stats.rx_bytes += pktlength;\n\n\t\tentry = next_entry;\n\n\t\ttse_rx_refill(priv);\n\t}\n\n\treturn count;\n}\n\n \nstatic int tse_tx_complete(struct altera_tse_private *priv)\n{\n\tunsigned int txsize = priv->tx_ring_size;\n\tstruct tse_buffer *tx_buff;\n\tunsigned int entry;\n\tint txcomplete = 0;\n\tu32 ready;\n\n\tspin_lock(&priv->tx_lock);\n\n\tready = priv->dmaops->tx_completions(priv);\n\n\t \n\twhile (ready && (priv->tx_cons != priv->tx_prod)) {\n\t\tentry = priv->tx_cons % txsize;\n\t\ttx_buff = &priv->tx_ring[entry];\n\n\t\tif (netif_msg_tx_done(priv))\n\t\t\tnetdev_dbg(priv->dev, \"%s: curr %d, dirty %d\\n\",\n\t\t\t\t   __func__, priv->tx_prod, priv->tx_cons);\n\n\t\tif (likely(tx_buff->skb))\n\t\t\tpriv->dev->stats.tx_packets++;\n\n\t\ttse_free_tx_buffer(priv, tx_buff);\n\t\tpriv->tx_cons++;\n\n\t\ttxcomplete++;\n\t\tready--;\n\t}\n\n\tif (unlikely(netif_queue_stopped(priv->dev) &&\n\t\t     tse_tx_avail(priv) > TSE_TX_THRESH(priv))) {\n\t\tif (netif_queue_stopped(priv->dev) &&\n\t\t    tse_tx_avail(priv) > TSE_TX_THRESH(priv)) {\n\t\t\tif (netif_msg_tx_done(priv))\n\t\t\t\tnetdev_dbg(priv->dev, \"%s: restart transmit\\n\",\n\t\t\t\t\t   __func__);\n\t\t\tnetif_wake_queue(priv->dev);\n\t\t}\n\t}\n\n\tspin_unlock(&priv->tx_lock);\n\treturn txcomplete;\n}\n\n \nstatic int tse_poll(struct napi_struct *napi, int budget)\n{\n\tstruct altera_tse_private *priv =\n\t\t\tcontainer_of(napi, struct altera_tse_private, napi);\n\tunsigned long int flags;\n\tint rxcomplete = 0;\n\n\ttse_tx_complete(priv);\n\n\trxcomplete = tse_rx(priv, budget);\n\n\tif (rxcomplete < budget) {\n\n\t\tnapi_complete_done(napi, rxcomplete);\n\n\t\tnetdev_dbg(priv->dev,\n\t\t\t   \"NAPI Complete, did %d packets with budget %d\\n\",\n\t\t\t   rxcomplete, budget);\n\n\t\tspin_lock_irqsave(&priv->rxdma_irq_lock, flags);\n\t\tpriv->dmaops->enable_rxirq(priv);\n\t\tpriv->dmaops->enable_txirq(priv);\n\t\tspin_unlock_irqrestore(&priv->rxdma_irq_lock, flags);\n\t}\n\treturn rxcomplete;\n}\n\n \nstatic irqreturn_t altera_isr(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct altera_tse_private *priv;\n\n\tif (unlikely(!dev)) {\n\t\tpr_err(\"%s: invalid dev pointer\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\tpriv = netdev_priv(dev);\n\n\tspin_lock(&priv->rxdma_irq_lock);\n\t \n\tpriv->dmaops->clear_rxirq(priv);\n\tpriv->dmaops->clear_txirq(priv);\n\tspin_unlock(&priv->rxdma_irq_lock);\n\n\tif (likely(napi_schedule_prep(&priv->napi))) {\n\t\tspin_lock(&priv->rxdma_irq_lock);\n\t\tpriv->dmaops->disable_rxirq(priv);\n\t\tpriv->dmaops->disable_txirq(priv);\n\t\tspin_unlock(&priv->rxdma_irq_lock);\n\t\t__napi_schedule(&priv->napi);\n\t}\n\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic netdev_tx_t tse_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct altera_tse_private *priv = netdev_priv(dev);\n\tunsigned int nopaged_len = skb_headlen(skb);\n\tunsigned int txsize = priv->tx_ring_size;\n\tint nfrags = skb_shinfo(skb)->nr_frags;\n\tstruct tse_buffer *buffer = NULL;\n\tnetdev_tx_t ret = NETDEV_TX_OK;\n\tdma_addr_t dma_addr;\n\tunsigned int entry;\n\n\tspin_lock_bh(&priv->tx_lock);\n\n\tif (unlikely(tse_tx_avail(priv) < nfrags + 1)) {\n\t\tif (!netif_queue_stopped(dev)) {\n\t\t\tnetif_stop_queue(dev);\n\t\t\t \n\t\t\tnetdev_err(priv->dev,\n\t\t\t\t   \"%s: Tx list full when queue awake\\n\",\n\t\t\t\t   __func__);\n\t\t}\n\t\tret = NETDEV_TX_BUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tentry = priv->tx_prod % txsize;\n\tbuffer = &priv->tx_ring[entry];\n\n\tdma_addr = dma_map_single(priv->device, skb->data, nopaged_len,\n\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(priv->device, dma_addr)) {\n\t\tnetdev_err(priv->dev, \"%s: DMA mapping error\\n\", __func__);\n\t\tret = NETDEV_TX_OK;\n\t\tgoto out;\n\t}\n\n\tbuffer->skb = skb;\n\tbuffer->dma_addr = dma_addr;\n\tbuffer->len = nopaged_len;\n\n\tpriv->dmaops->tx_buffer(priv, buffer);\n\n\tskb_tx_timestamp(skb);\n\n\tpriv->tx_prod++;\n\tdev->stats.tx_bytes += skb->len;\n\n\tif (unlikely(tse_tx_avail(priv) <= TXQUEUESTOP_THRESHHOLD)) {\n\t\tif (netif_msg_hw(priv))\n\t\t\tnetdev_dbg(priv->dev, \"%s: stop transmitted packets\\n\",\n\t\t\t\t   __func__);\n\t\tnetif_stop_queue(dev);\n\t}\n\nout:\n\tspin_unlock_bh(&priv->tx_lock);\n\n\treturn ret;\n}\n\nstatic int altera_tse_phy_get_addr_mdio_create(struct net_device *dev)\n{\n\tstruct altera_tse_private *priv = netdev_priv(dev);\n\tstruct device_node *np = priv->device->of_node;\n\tint ret;\n\n\tret = of_get_phy_mode(np, &priv->phy_iface);\n\n\t \n\tif (ret)\n\t\treturn 0;\n\n\t \n\n\tif (of_property_read_u32(priv->device->of_node, \"phy-addr\",\n\t\t\t &priv->phy_addr)) {\n\t\tpriv->phy_addr = POLL_PHY;\n\t}\n\n\tif (!((priv->phy_addr == POLL_PHY) ||\n\t\t  ((priv->phy_addr >= 0) && (priv->phy_addr < PHY_MAX_ADDR)))) {\n\t\tnetdev_err(dev, \"invalid phy-addr specified %d\\n\",\n\t\t\tpriv->phy_addr);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = altera_tse_mdio_create(dev,\n\t\t\t\t\t atomic_add_return(1, &instance_count));\n\n\tif (ret)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void tse_update_mac_addr(struct altera_tse_private *priv, const u8 *addr)\n{\n\tu32 msb;\n\tu32 lsb;\n\n\tmsb = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) | addr[0];\n\tlsb = ((addr[5] << 8) | addr[4]) & 0xffff;\n\n\t \n\tcsrwr32(msb, priv->mac_dev, tse_csroffs(mac_addr_0));\n\tcsrwr32(lsb, priv->mac_dev, tse_csroffs(mac_addr_1));\n}\n\n \nstatic int reset_mac(struct altera_tse_private *priv)\n{\n\tint counter;\n\tu32 dat;\n\n\tdat = csrrd32(priv->mac_dev, tse_csroffs(command_config));\n\tdat &= ~(MAC_CMDCFG_TX_ENA | MAC_CMDCFG_RX_ENA);\n\tdat |= MAC_CMDCFG_SW_RESET | MAC_CMDCFG_CNT_RESET;\n\tcsrwr32(dat, priv->mac_dev, tse_csroffs(command_config));\n\n\tcounter = 0;\n\twhile (counter++ < ALTERA_TSE_SW_RESET_WATCHDOG_CNTR) {\n\t\tif (tse_bit_is_clear(priv->mac_dev, tse_csroffs(command_config),\n\t\t\t\t     MAC_CMDCFG_SW_RESET))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (counter >= ALTERA_TSE_SW_RESET_WATCHDOG_CNTR) {\n\t\tdat = csrrd32(priv->mac_dev, tse_csroffs(command_config));\n\t\tdat &= ~MAC_CMDCFG_SW_RESET;\n\t\tcsrwr32(dat, priv->mac_dev, tse_csroffs(command_config));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic int init_mac(struct altera_tse_private *priv)\n{\n\tunsigned int cmd = 0;\n\tu32 frm_length;\n\n\t \n\tcsrwr32(priv->rx_fifo_depth - ALTERA_TSE_RX_SECTION_EMPTY,\n\t\tpriv->mac_dev, tse_csroffs(rx_section_empty));\n\n\tcsrwr32(ALTERA_TSE_RX_SECTION_FULL, priv->mac_dev,\n\t\ttse_csroffs(rx_section_full));\n\n\tcsrwr32(ALTERA_TSE_RX_ALMOST_EMPTY, priv->mac_dev,\n\t\ttse_csroffs(rx_almost_empty));\n\n\tcsrwr32(ALTERA_TSE_RX_ALMOST_FULL, priv->mac_dev,\n\t\ttse_csroffs(rx_almost_full));\n\n\t \n\tcsrwr32(priv->tx_fifo_depth - ALTERA_TSE_TX_SECTION_EMPTY,\n\t\tpriv->mac_dev, tse_csroffs(tx_section_empty));\n\n\tcsrwr32(ALTERA_TSE_TX_SECTION_FULL, priv->mac_dev,\n\t\ttse_csroffs(tx_section_full));\n\n\tcsrwr32(ALTERA_TSE_TX_ALMOST_EMPTY, priv->mac_dev,\n\t\ttse_csroffs(tx_almost_empty));\n\n\tcsrwr32(ALTERA_TSE_TX_ALMOST_FULL, priv->mac_dev,\n\t\ttse_csroffs(tx_almost_full));\n\n\t \n\ttse_update_mac_addr(priv, priv->dev->dev_addr);\n\n\t \n\tfrm_length = ETH_HLEN + priv->dev->mtu + ETH_FCS_LEN;\n\tcsrwr32(frm_length, priv->mac_dev, tse_csroffs(frm_length));\n\n\tcsrwr32(ALTERA_TSE_TX_IPG_LENGTH, priv->mac_dev,\n\t\ttse_csroffs(tx_ipg_length));\n\n\t \n\ttse_set_bit(priv->mac_dev, tse_csroffs(rx_cmd_stat),\n\t\t    ALTERA_TSE_RX_CMD_STAT_RX_SHIFT16);\n\n\ttse_clear_bit(priv->mac_dev, tse_csroffs(tx_cmd_stat),\n\t\t      ALTERA_TSE_TX_CMD_STAT_TX_SHIFT16 |\n\t\t      ALTERA_TSE_TX_CMD_STAT_OMIT_CRC);\n\n\t \n\tcmd = csrrd32(priv->mac_dev, tse_csroffs(command_config));\n\tcmd &= ~MAC_CMDCFG_PAD_EN;\t \n\tcmd &= ~MAC_CMDCFG_CRC_FWD;\t \n\tcmd |= MAC_CMDCFG_RX_ERR_DISC;\t \n\tcmd |= MAC_CMDCFG_CNTL_FRM_ENA;\n\tcmd &= ~MAC_CMDCFG_TX_ENA;\n\tcmd &= ~MAC_CMDCFG_RX_ENA;\n\n\t \n\tcmd &= ~MAC_CMDCFG_HD_ENA;\n\tcmd &= ~MAC_CMDCFG_ETH_SPEED;\n\tcmd &= ~MAC_CMDCFG_ENA_10;\n\n\tcsrwr32(cmd, priv->mac_dev, tse_csroffs(command_config));\n\n\tcsrwr32(ALTERA_TSE_PAUSE_QUANTA, priv->mac_dev,\n\t\ttse_csroffs(pause_quanta));\n\n\tif (netif_msg_hw(priv))\n\t\tdev_dbg(priv->device,\n\t\t\t\"MAC post-initialization: CMD_CONFIG = 0x%08x\\n\", cmd);\n\n\treturn 0;\n}\n\n \nstatic void tse_set_mac(struct altera_tse_private *priv, bool enable)\n{\n\tu32 value = csrrd32(priv->mac_dev, tse_csroffs(command_config));\n\n\tif (enable)\n\t\tvalue |= MAC_CMDCFG_TX_ENA | MAC_CMDCFG_RX_ENA;\n\telse\n\t\tvalue &= ~(MAC_CMDCFG_TX_ENA | MAC_CMDCFG_RX_ENA);\n\n\tcsrwr32(value, priv->mac_dev, tse_csroffs(command_config));\n}\n\n \nstatic int tse_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (netif_running(dev)) {\n\t\tnetdev_err(dev, \"must be stopped to change its MTU\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tdev->mtu = new_mtu;\n\tnetdev_update_features(dev);\n\n\treturn 0;\n}\n\nstatic void altera_tse_set_mcfilter(struct net_device *dev)\n{\n\tstruct altera_tse_private *priv = netdev_priv(dev);\n\tstruct netdev_hw_addr *ha;\n\tint i;\n\n\t \n\tfor (i = 0; i < 64; i++)\n\t\tcsrwr32(0, priv->mac_dev, tse_csroffs(hash_table) + i * 4);\n\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tunsigned int hash = 0;\n\t\tint mac_octet;\n\n\t\tfor (mac_octet = 5; mac_octet >= 0; mac_octet--) {\n\t\t\tunsigned char xor_bit = 0;\n\t\t\tunsigned char octet = ha->addr[mac_octet];\n\t\t\tunsigned int bitshift;\n\n\t\t\tfor (bitshift = 0; bitshift < 8; bitshift++)\n\t\t\t\txor_bit ^= ((octet >> bitshift) & 0x01);\n\n\t\t\thash = (hash << 1) | xor_bit;\n\t\t}\n\t\tcsrwr32(1, priv->mac_dev, tse_csroffs(hash_table) + hash * 4);\n\t}\n}\n\n\nstatic void altera_tse_set_mcfilterall(struct net_device *dev)\n{\n\tstruct altera_tse_private *priv = netdev_priv(dev);\n\tint i;\n\n\t \n\tfor (i = 0; i < 64; i++)\n\t\tcsrwr32(1, priv->mac_dev, tse_csroffs(hash_table) + i * 4);\n}\n\n \nstatic void tse_set_rx_mode_hashfilter(struct net_device *dev)\n{\n\tstruct altera_tse_private *priv = netdev_priv(dev);\n\n\tspin_lock(&priv->mac_cfg_lock);\n\n\tif (dev->flags & IFF_PROMISC)\n\t\ttse_set_bit(priv->mac_dev, tse_csroffs(command_config),\n\t\t\t    MAC_CMDCFG_PROMIS_EN);\n\n\tif (dev->flags & IFF_ALLMULTI)\n\t\taltera_tse_set_mcfilterall(dev);\n\telse\n\t\taltera_tse_set_mcfilter(dev);\n\n\tspin_unlock(&priv->mac_cfg_lock);\n}\n\n \nstatic void tse_set_rx_mode(struct net_device *dev)\n{\n\tstruct altera_tse_private *priv = netdev_priv(dev);\n\n\tspin_lock(&priv->mac_cfg_lock);\n\n\tif ((dev->flags & IFF_PROMISC) || (dev->flags & IFF_ALLMULTI) ||\n\t    !netdev_mc_empty(dev) || !netdev_uc_empty(dev))\n\t\ttse_set_bit(priv->mac_dev, tse_csroffs(command_config),\n\t\t\t    MAC_CMDCFG_PROMIS_EN);\n\telse\n\t\ttse_clear_bit(priv->mac_dev, tse_csroffs(command_config),\n\t\t\t      MAC_CMDCFG_PROMIS_EN);\n\n\tspin_unlock(&priv->mac_cfg_lock);\n}\n\n \nstatic int tse_open(struct net_device *dev)\n{\n\tstruct altera_tse_private *priv = netdev_priv(dev);\n\tunsigned long flags;\n\tint ret = 0;\n\tint i;\n\n\t \n\tret = priv->dmaops->init_dma(priv);\n\tif (ret != 0) {\n\t\tnetdev_err(dev, \"Cannot initialize DMA\\n\");\n\t\tgoto phy_error;\n\t}\n\n\tif (netif_msg_ifup(priv))\n\t\tnetdev_warn(dev, \"device MAC address %pM\\n\",\n\t\t\t    dev->dev_addr);\n\n\tif ((priv->revision < 0xd00) || (priv->revision > 0xe00))\n\t\tnetdev_warn(dev, \"TSE revision %x\\n\", priv->revision);\n\n\tspin_lock(&priv->mac_cfg_lock);\n\n\tret = reset_mac(priv);\n\t \n\tif (ret)\n\t\tnetdev_dbg(dev, \"Cannot reset MAC core (error: %d)\\n\", ret);\n\n\tret = init_mac(priv);\n\tspin_unlock(&priv->mac_cfg_lock);\n\tif (ret) {\n\t\tnetdev_err(dev, \"Cannot init MAC core (error: %d)\\n\", ret);\n\t\tgoto alloc_skbuf_error;\n\t}\n\n\tpriv->dmaops->reset_dma(priv);\n\n\t \n\tpriv->rx_ring_size = dma_rx_num;\n\tpriv->tx_ring_size = dma_tx_num;\n\tret = alloc_init_skbufs(priv);\n\tif (ret) {\n\t\tnetdev_err(dev, \"DMA descriptors initialization failed\\n\");\n\t\tgoto alloc_skbuf_error;\n\t}\n\n\n\t \n\tret = request_irq(priv->rx_irq, altera_isr, IRQF_SHARED,\n\t\t\t  dev->name, dev);\n\tif (ret) {\n\t\tnetdev_err(dev, \"Unable to register RX interrupt %d\\n\",\n\t\t\t   priv->rx_irq);\n\t\tgoto init_error;\n\t}\n\n\t \n\tret = request_irq(priv->tx_irq, altera_isr, IRQF_SHARED,\n\t\t\t  dev->name, dev);\n\tif (ret) {\n\t\tnetdev_err(dev, \"Unable to register TX interrupt %d\\n\",\n\t\t\t   priv->tx_irq);\n\t\tgoto tx_request_irq_error;\n\t}\n\n\t \n\tspin_lock_irqsave(&priv->rxdma_irq_lock, flags);\n\tpriv->dmaops->enable_rxirq(priv);\n\tpriv->dmaops->enable_txirq(priv);\n\n\t \n\tfor (i = 0; i < priv->rx_ring_size; i++)\n\t\tpriv->dmaops->add_rx_desc(priv, &priv->rx_ring[i]);\n\n\tspin_unlock_irqrestore(&priv->rxdma_irq_lock, flags);\n\n\tret = phylink_of_phy_connect(priv->phylink, priv->device->of_node, 0);\n\tif (ret) {\n\t\tnetdev_err(dev, \"could not connect phylink (%d)\\n\", ret);\n\t\tgoto tx_request_irq_error;\n\t}\n\tphylink_start(priv->phylink);\n\n\tnapi_enable(&priv->napi);\n\tnetif_start_queue(dev);\n\n\tpriv->dmaops->start_rxdma(priv);\n\n\t \n\tspin_lock(&priv->mac_cfg_lock);\n\ttse_set_mac(priv, true);\n\tspin_unlock(&priv->mac_cfg_lock);\n\n\treturn 0;\n\ntx_request_irq_error:\n\tfree_irq(priv->rx_irq, dev);\ninit_error:\n\tfree_skbufs(dev);\nalloc_skbuf_error:\nphy_error:\n\treturn ret;\n}\n\n \nstatic int tse_shutdown(struct net_device *dev)\n{\n\tstruct altera_tse_private *priv = netdev_priv(dev);\n\tunsigned long int flags;\n\tint ret;\n\n\tphylink_stop(priv->phylink);\n\tphylink_disconnect_phy(priv->phylink);\n\tnetif_stop_queue(dev);\n\tnapi_disable(&priv->napi);\n\n\t \n\tspin_lock_irqsave(&priv->rxdma_irq_lock, flags);\n\tpriv->dmaops->disable_rxirq(priv);\n\tpriv->dmaops->disable_txirq(priv);\n\tspin_unlock_irqrestore(&priv->rxdma_irq_lock, flags);\n\n\t \n\tfree_irq(priv->rx_irq, dev);\n\tfree_irq(priv->tx_irq, dev);\n\n\t \n\tspin_lock(&priv->mac_cfg_lock);\n\tspin_lock(&priv->tx_lock);\n\n\tret = reset_mac(priv);\n\t \n\tif (ret)\n\t\tnetdev_dbg(dev, \"Cannot reset MAC core (error: %d)\\n\", ret);\n\tpriv->dmaops->reset_dma(priv);\n\tfree_skbufs(dev);\n\n\tspin_unlock(&priv->tx_lock);\n\tspin_unlock(&priv->mac_cfg_lock);\n\n\tpriv->dmaops->uninit_dma(priv);\n\n\treturn 0;\n}\n\nstatic struct net_device_ops altera_tse_netdev_ops = {\n\t.ndo_open\t\t= tse_open,\n\t.ndo_stop\t\t= tse_shutdown,\n\t.ndo_start_xmit\t\t= tse_start_xmit,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_set_rx_mode\t= tse_set_rx_mode,\n\t.ndo_change_mtu\t\t= tse_change_mtu,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic void alt_tse_mac_config(struct phylink_config *config, unsigned int mode,\n\t\t\t       const struct phylink_link_state *state)\n{\n\tstruct net_device *ndev = to_net_dev(config->dev);\n\tstruct altera_tse_private *priv = netdev_priv(ndev);\n\n\tspin_lock(&priv->mac_cfg_lock);\n\treset_mac(priv);\n\ttse_set_mac(priv, true);\n\tspin_unlock(&priv->mac_cfg_lock);\n}\n\nstatic void alt_tse_mac_link_down(struct phylink_config *config,\n\t\t\t\t  unsigned int mode, phy_interface_t interface)\n{\n}\n\nstatic void alt_tse_mac_link_up(struct phylink_config *config,\n\t\t\t\tstruct phy_device *phy, unsigned int mode,\n\t\t\t\tphy_interface_t interface, int speed,\n\t\t\t\tint duplex, bool tx_pause, bool rx_pause)\n{\n\tstruct net_device *ndev = to_net_dev(config->dev);\n\tstruct altera_tse_private *priv = netdev_priv(ndev);\n\tu32 ctrl;\n\n\tctrl = csrrd32(priv->mac_dev, tse_csroffs(command_config));\n\tctrl &= ~(MAC_CMDCFG_ENA_10 | MAC_CMDCFG_ETH_SPEED | MAC_CMDCFG_HD_ENA);\n\n\tif (duplex == DUPLEX_HALF)\n\t\tctrl |= MAC_CMDCFG_HD_ENA;\n\n\tif (speed == SPEED_1000)\n\t\tctrl |= MAC_CMDCFG_ETH_SPEED;\n\telse if (speed == SPEED_10)\n\t\tctrl |= MAC_CMDCFG_ENA_10;\n\n\tspin_lock(&priv->mac_cfg_lock);\n\tcsrwr32(ctrl, priv->mac_dev, tse_csroffs(command_config));\n\tspin_unlock(&priv->mac_cfg_lock);\n}\n\nstatic struct phylink_pcs *alt_tse_select_pcs(struct phylink_config *config,\n\t\t\t\t\t      phy_interface_t interface)\n{\n\tstruct net_device *ndev = to_net_dev(config->dev);\n\tstruct altera_tse_private *priv = netdev_priv(ndev);\n\n\tif (interface == PHY_INTERFACE_MODE_SGMII ||\n\t    interface == PHY_INTERFACE_MODE_1000BASEX)\n\t\treturn priv->pcs;\n\telse\n\t\treturn NULL;\n}\n\nstatic const struct phylink_mac_ops alt_tse_phylink_ops = {\n\t.mac_config = alt_tse_mac_config,\n\t.mac_link_down = alt_tse_mac_link_down,\n\t.mac_link_up = alt_tse_mac_link_up,\n\t.mac_select_pcs = alt_tse_select_pcs,\n};\n\nstatic int request_and_map(struct platform_device *pdev, const char *name,\n\t\t\t   struct resource **res, void __iomem **ptr)\n{\n\tstruct device *device = &pdev->dev;\n\tstruct resource *region;\n\n\t*res = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);\n\tif (*res == NULL) {\n\t\tdev_err(device, \"resource %s not defined\\n\", name);\n\t\treturn -ENODEV;\n\t}\n\n\tregion = devm_request_mem_region(device, (*res)->start,\n\t\t\t\t\t resource_size(*res), dev_name(device));\n\tif (region == NULL) {\n\t\tdev_err(device, \"unable to request %s\\n\", name);\n\t\treturn -EBUSY;\n\t}\n\n\t*ptr = devm_ioremap(device, region->start,\n\t\t\t\t    resource_size(region));\n\tif (*ptr == NULL) {\n\t\tdev_err(device, \"ioremap of %s failed!\", name);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int altera_tse_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *of_id = NULL;\n\tstruct regmap_config pcs_regmap_cfg;\n\tstruct altera_tse_private *priv;\n\tstruct mdio_regmap_config mrc;\n\tstruct resource *control_port;\n\tstruct regmap *pcs_regmap;\n\tstruct resource *dma_res;\n\tstruct resource *pcs_res;\n\tstruct mii_bus *pcs_bus;\n\tstruct net_device *ndev;\n\tvoid __iomem *descmap;\n\tint ret = -ENODEV;\n\n\tndev = alloc_etherdev(sizeof(struct altera_tse_private));\n\tif (!ndev) {\n\t\tdev_err(&pdev->dev, \"Could not allocate network device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\n\tpriv = netdev_priv(ndev);\n\tpriv->device = &pdev->dev;\n\tpriv->dev = ndev;\n\tpriv->msg_enable = netif_msg_init(debug, default_msg_level);\n\n\tof_id = of_match_device(altera_tse_ids, &pdev->dev);\n\n\tif (of_id)\n\t\tpriv->dmaops = (struct altera_dmaops *)of_id->data;\n\n\n\tif (priv->dmaops &&\n\t    priv->dmaops->altera_dtype == ALTERA_DTYPE_SGDMA) {\n\t\t \n\t\tret = request_and_map(pdev, \"s1\", &dma_res, &descmap);\n\t\tif (ret)\n\t\t\tgoto err_free_netdev;\n\n\t\t \n\t\tpriv->tx_dma_desc = descmap;\n\n\t\t \n\t\tpriv->txdescmem = resource_size(dma_res)/2;\n\n\t\tpriv->txdescmem_busaddr = (dma_addr_t)dma_res->start;\n\n\t\tpriv->rx_dma_desc = (void __iomem *)((uintptr_t)(descmap +\n\t\t\t\t\t\t     priv->txdescmem));\n\t\tpriv->rxdescmem = resource_size(dma_res)/2;\n\t\tpriv->rxdescmem_busaddr = dma_res->start;\n\t\tpriv->rxdescmem_busaddr += priv->txdescmem;\n\n\t\tif (upper_32_bits(priv->rxdescmem_busaddr)) {\n\t\t\tdev_dbg(priv->device,\n\t\t\t\t\"SGDMA bus addresses greater than 32-bits\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_netdev;\n\t\t}\n\t\tif (upper_32_bits(priv->txdescmem_busaddr)) {\n\t\t\tdev_dbg(priv->device,\n\t\t\t\t\"SGDMA bus addresses greater than 32-bits\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_netdev;\n\t\t}\n\t} else if (priv->dmaops &&\n\t\t   priv->dmaops->altera_dtype == ALTERA_DTYPE_MSGDMA) {\n\t\tret = request_and_map(pdev, \"rx_resp\", &dma_res,\n\t\t\t\t      &priv->rx_dma_resp);\n\t\tif (ret)\n\t\t\tgoto err_free_netdev;\n\n\t\tret = request_and_map(pdev, \"tx_desc\", &dma_res,\n\t\t\t\t      &priv->tx_dma_desc);\n\t\tif (ret)\n\t\t\tgoto err_free_netdev;\n\n\t\tpriv->txdescmem = resource_size(dma_res);\n\t\tpriv->txdescmem_busaddr = dma_res->start;\n\n\t\tret = request_and_map(pdev, \"rx_desc\", &dma_res,\n\t\t\t\t      &priv->rx_dma_desc);\n\t\tif (ret)\n\t\t\tgoto err_free_netdev;\n\n\t\tpriv->rxdescmem = resource_size(dma_res);\n\t\tpriv->rxdescmem_busaddr = dma_res->start;\n\n\t} else {\n\t\tret = -ENODEV;\n\t\tgoto err_free_netdev;\n\t}\n\n\tif (!dma_set_mask(priv->device, DMA_BIT_MASK(priv->dmaops->dmamask))) {\n\t\tdma_set_coherent_mask(priv->device,\n\t\t\t\t      DMA_BIT_MASK(priv->dmaops->dmamask));\n\t} else if (!dma_set_mask(priv->device, DMA_BIT_MASK(32))) {\n\t\tdma_set_coherent_mask(priv->device, DMA_BIT_MASK(32));\n\t} else {\n\t\tret = -EIO;\n\t\tgoto err_free_netdev;\n\t}\n\n\t \n\tret = request_and_map(pdev, \"control_port\", &control_port,\n\t\t\t      (void __iomem **)&priv->mac_dev);\n\tif (ret)\n\t\tgoto err_free_netdev;\n\n\t \n\tret = request_and_map(pdev, \"rx_csr\", &dma_res,\n\t\t\t      &priv->rx_dma_csr);\n\tif (ret)\n\t\tgoto err_free_netdev;\n\n\n\t \n\tret = request_and_map(pdev, \"tx_csr\", &dma_res,\n\t\t\t      &priv->tx_dma_csr);\n\tif (ret)\n\t\tgoto err_free_netdev;\n\n\tmemset(&pcs_regmap_cfg, 0, sizeof(pcs_regmap_cfg));\n\tmemset(&mrc, 0, sizeof(mrc));\n\t \n\tret = request_and_map(pdev, \"pcs\", &pcs_res, &priv->pcs_base);\n\tif (ret) {\n\t\t \n\t\tpriv->pcs_base = priv->mac_dev + tse_csroffs(mdio_phy0);\n\t\tpcs_regmap_cfg.reg_bits = 32;\n\t\t \n\t\tpcs_regmap_cfg.val_bits = 16;\n\t\tpcs_regmap_cfg.reg_shift = REGMAP_UPSHIFT(2);\n\t} else {\n\t\tpcs_regmap_cfg.reg_bits = 16;\n\t\tpcs_regmap_cfg.val_bits = 16;\n\t\tpcs_regmap_cfg.reg_shift = REGMAP_UPSHIFT(1);\n\t}\n\n\t \n\tpcs_regmap = devm_regmap_init_mmio(&pdev->dev, priv->pcs_base,\n\t\t\t\t\t   &pcs_regmap_cfg);\n\tif (IS_ERR(pcs_regmap)) {\n\t\tret = PTR_ERR(pcs_regmap);\n\t\tgoto err_free_netdev;\n\t}\n\tmrc.regmap = pcs_regmap;\n\tmrc.parent = &pdev->dev;\n\tmrc.valid_addr = 0x0;\n\tmrc.autoscan = false;\n\n\t \n\tpriv->rx_irq = platform_get_irq_byname(pdev, \"rx_irq\");\n\tif (priv->rx_irq == -ENXIO) {\n\t\tdev_err(&pdev->dev, \"cannot obtain Rx IRQ\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_free_netdev;\n\t}\n\n\t \n\tpriv->tx_irq = platform_get_irq_byname(pdev, \"tx_irq\");\n\tif (priv->tx_irq == -ENXIO) {\n\t\tdev_err(&pdev->dev, \"cannot obtain Tx IRQ\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_free_netdev;\n\t}\n\n\t \n\tif (of_property_read_u32(pdev->dev.of_node, \"rx-fifo-depth\",\n\t\t\t\t &priv->rx_fifo_depth)) {\n\t\tdev_err(&pdev->dev, \"cannot obtain rx-fifo-depth\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_free_netdev;\n\t}\n\n\tif (of_property_read_u32(pdev->dev.of_node, \"tx-fifo-depth\",\n\t\t\t\t &priv->tx_fifo_depth)) {\n\t\tdev_err(&pdev->dev, \"cannot obtain tx-fifo-depth\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_free_netdev;\n\t}\n\n\t \n\tpriv->hash_filter =\n\t\tof_property_read_bool(pdev->dev.of_node,\n\t\t\t\t      \"altr,has-hash-multicast-filter\");\n\n\t \n\tpriv->hash_filter = 0;\n\n\t \n\tpriv->added_unicast =\n\t\tof_property_read_bool(pdev->dev.of_node,\n\t\t\t\t      \"altr,has-supplementary-unicast\");\n\n\tpriv->dev->min_mtu = ETH_ZLEN + ETH_FCS_LEN;\n\t \n\tpriv->dev->max_mtu = ETH_DATA_LEN;\n\n\t \n\tof_property_read_u32(pdev->dev.of_node, \"max-frame-size\",\n\t\t\t     &priv->dev->max_mtu);\n\n\t \n\tpriv->rx_dma_buf_sz = ALTERA_RXDMABUFFER_SIZE;\n\n\t \n\tret = of_get_ethdev_address(pdev->dev.of_node, ndev);\n\tif (ret)\n\t\teth_hw_addr_random(ndev);\n\n\t \n\tret = altera_tse_phy_get_addr_mdio_create(ndev);\n\n\tif (ret)\n\t\tgoto err_free_netdev;\n\n\t \n\tndev->mem_start = control_port->start;\n\tndev->mem_end = control_port->end;\n\tndev->netdev_ops = &altera_tse_netdev_ops;\n\taltera_tse_set_ethtool_ops(ndev);\n\n\taltera_tse_netdev_ops.ndo_set_rx_mode = tse_set_rx_mode;\n\n\tif (priv->hash_filter)\n\t\taltera_tse_netdev_ops.ndo_set_rx_mode =\n\t\t\ttse_set_rx_mode_hashfilter;\n\n\t \n\tndev->hw_features &= ~NETIF_F_SG;\n\tndev->features |= ndev->hw_features | NETIF_F_HIGHDMA;\n\n\t \n\tndev->features |= NETIF_F_HW_VLAN_CTAG_RX;\n\n\t \n\tnetif_napi_add(ndev, &priv->napi, tse_poll);\n\n\tspin_lock_init(&priv->mac_cfg_lock);\n\tspin_lock_init(&priv->tx_lock);\n\tspin_lock_init(&priv->rxdma_irq_lock);\n\n\tnetif_carrier_off(ndev);\n\tret = register_netdev(ndev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register TSE net device\\n\");\n\t\tgoto err_register_netdev;\n\t}\n\n\tplatform_set_drvdata(pdev, ndev);\n\n\tpriv->revision = ioread32(&priv->mac_dev->megacore_revision);\n\n\tif (netif_msg_probe(priv))\n\t\tdev_info(&pdev->dev, \"Altera TSE MAC version %d.%d at 0x%08lx irq %d/%d\\n\",\n\t\t\t (priv->revision >> 8) & 0xff,\n\t\t\t priv->revision & 0xff,\n\t\t\t (unsigned long) control_port->start, priv->rx_irq,\n\t\t\t priv->tx_irq);\n\n\tsnprintf(mrc.name, MII_BUS_ID_SIZE, \"%s-pcs-mii\", ndev->name);\n\tpcs_bus = devm_mdio_regmap_register(&pdev->dev, &mrc);\n\tif (IS_ERR(pcs_bus)) {\n\t\tret = PTR_ERR(pcs_bus);\n\t\tgoto err_init_pcs;\n\t}\n\n\tpriv->pcs = lynx_pcs_create_mdiodev(pcs_bus, 0);\n\tif (IS_ERR(priv->pcs)) {\n\t\tret = PTR_ERR(priv->pcs);\n\t\tgoto err_init_pcs;\n\t}\n\n\tpriv->phylink_config.dev = &ndev->dev;\n\tpriv->phylink_config.type = PHYLINK_NETDEV;\n\tpriv->phylink_config.mac_capabilities = MAC_SYM_PAUSE | MAC_10 |\n\t\t\t\t\t\tMAC_100 | MAC_1000FD;\n\n\tphy_interface_set_rgmii(priv->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_MII,\n\t\t  priv->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t  priv->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_SGMII,\n\t\t  priv->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_1000BASEX,\n\t\t  priv->phylink_config.supported_interfaces);\n\n\tpriv->phylink = phylink_create(&priv->phylink_config,\n\t\t\t\t       of_fwnode_handle(priv->device->of_node),\n\t\t\t\t       priv->phy_iface, &alt_tse_phylink_ops);\n\tif (IS_ERR(priv->phylink)) {\n\t\tdev_err(&pdev->dev, \"failed to create phylink\\n\");\n\t\tret = PTR_ERR(priv->phylink);\n\t\tgoto err_init_phylink;\n\t}\n\n\treturn 0;\nerr_init_phylink:\n\tlynx_pcs_destroy(priv->pcs);\nerr_init_pcs:\n\tunregister_netdev(ndev);\nerr_register_netdev:\n\tnetif_napi_del(&priv->napi);\n\taltera_tse_mdio_destroy(ndev);\nerr_free_netdev:\n\tfree_netdev(ndev);\n\treturn ret;\n}\n\n \nstatic int altera_tse_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct altera_tse_private *priv = netdev_priv(ndev);\n\n\tplatform_set_drvdata(pdev, NULL);\n\taltera_tse_mdio_destroy(ndev);\n\tunregister_netdev(ndev);\n\tphylink_destroy(priv->phylink);\n\tlynx_pcs_destroy(priv->pcs);\n\n\tfree_netdev(ndev);\n\n\treturn 0;\n}\n\nstatic const struct altera_dmaops altera_dtype_sgdma = {\n\t.altera_dtype = ALTERA_DTYPE_SGDMA,\n\t.dmamask = 32,\n\t.reset_dma = sgdma_reset,\n\t.enable_txirq = sgdma_enable_txirq,\n\t.enable_rxirq = sgdma_enable_rxirq,\n\t.disable_txirq = sgdma_disable_txirq,\n\t.disable_rxirq = sgdma_disable_rxirq,\n\t.clear_txirq = sgdma_clear_txirq,\n\t.clear_rxirq = sgdma_clear_rxirq,\n\t.tx_buffer = sgdma_tx_buffer,\n\t.tx_completions = sgdma_tx_completions,\n\t.add_rx_desc = sgdma_add_rx_desc,\n\t.get_rx_status = sgdma_rx_status,\n\t.init_dma = sgdma_initialize,\n\t.uninit_dma = sgdma_uninitialize,\n\t.start_rxdma = sgdma_start_rxdma,\n};\n\nstatic const struct altera_dmaops altera_dtype_msgdma = {\n\t.altera_dtype = ALTERA_DTYPE_MSGDMA,\n\t.dmamask = 64,\n\t.reset_dma = msgdma_reset,\n\t.enable_txirq = msgdma_enable_txirq,\n\t.enable_rxirq = msgdma_enable_rxirq,\n\t.disable_txirq = msgdma_disable_txirq,\n\t.disable_rxirq = msgdma_disable_rxirq,\n\t.clear_txirq = msgdma_clear_txirq,\n\t.clear_rxirq = msgdma_clear_rxirq,\n\t.tx_buffer = msgdma_tx_buffer,\n\t.tx_completions = msgdma_tx_completions,\n\t.add_rx_desc = msgdma_add_rx_desc,\n\t.get_rx_status = msgdma_rx_status,\n\t.init_dma = msgdma_initialize,\n\t.uninit_dma = msgdma_uninitialize,\n\t.start_rxdma = msgdma_start_rxdma,\n};\n\nstatic const struct of_device_id altera_tse_ids[] = {\n\t{ .compatible = \"altr,tse-msgdma-1.0\", .data = &altera_dtype_msgdma, },\n\t{ .compatible = \"altr,tse-1.0\", .data = &altera_dtype_sgdma, },\n\t{ .compatible = \"ALTR,tse-1.0\", .data = &altera_dtype_sgdma, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, altera_tse_ids);\n\nstatic struct platform_driver altera_tse_driver = {\n\t.probe\t\t= altera_tse_probe,\n\t.remove\t\t= altera_tse_remove,\n\t.suspend\t= NULL,\n\t.resume\t\t= NULL,\n\t.driver\t\t= {\n\t\t.name\t= ALTERA_TSE_RESOURCE_NAME,\n\t\t.of_match_table = altera_tse_ids,\n\t},\n};\n\nmodule_platform_driver(altera_tse_driver);\n\nMODULE_AUTHOR(\"Altera Corporation\");\nMODULE_DESCRIPTION(\"Altera Triple Speed Ethernet MAC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}