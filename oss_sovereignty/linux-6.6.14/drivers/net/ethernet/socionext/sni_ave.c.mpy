{
  "module_name": "sni_ave.c",
  "hash_id": "504050204100263e55ac65f9134355015981274042a161ce522f25c3adcba665",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/socionext/sni_ave.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/types.h>\n#include <linux/u64_stats_sync.h>\n\n \n#define AVE_IDR\t\t\t0x000\t \n#define AVE_VR\t\t\t0x004\t \n#define AVE_GRR\t\t\t0x008\t \n#define AVE_CFGR\t\t0x00c\t \n\n \n#define AVE_GIMR\t\t0x100\t \n#define AVE_GISR\t\t0x104\t \n\n \n#define AVE_TXCR\t\t0x200\t \n#define AVE_RXCR\t\t0x204\t \n#define AVE_RXMAC1R\t\t0x208\t \n#define AVE_RXMAC2R\t\t0x20c\t \n#define AVE_MDIOCTR\t\t0x214\t \n#define AVE_MDIOAR\t\t0x218\t \n#define AVE_MDIOWDR\t\t0x21c\t \n#define AVE_MDIOSR\t\t0x220\t \n#define AVE_MDIORDR\t\t0x224\t \n\n \n#define AVE_DESCC\t\t0x300\t \n#define AVE_TXDC\t\t0x304\t \n#define AVE_RXDC0\t\t0x308\t \n#define AVE_IIRQC\t\t0x34c\t \n\n \n#define AVE_PKTF_BASE\t\t0x800\t \n#define AVE_PFMBYTE_BASE\t0xd00\t \n#define AVE_PFMBIT_BASE\t\t0xe00\t \n#define AVE_PFSEL_BASE\t\t0xf00\t \n#define AVE_PFEN\t\t0xffc\t \n#define AVE_PKTF(ent)\t\t(AVE_PKTF_BASE + (ent) * 0x40)\n#define AVE_PFMBYTE(ent)\t(AVE_PFMBYTE_BASE + (ent) * 8)\n#define AVE_PFMBIT(ent)\t\t(AVE_PFMBIT_BASE + (ent) * 4)\n#define AVE_PFSEL(ent)\t\t(AVE_PFSEL_BASE + (ent) * 4)\n\n \n#define AVE_DESC_SIZE_64\t12\t \n\n#define AVE_TXDM_64\t\t0x1000\t \n#define AVE_RXDM_64\t\t0x1c00\t \n\n#define AVE_TXDM_SIZE_64\t0x0ba0\t \n#define AVE_RXDM_SIZE_64\t0x6000\t \n\n \n#define AVE_DESC_SIZE_32\t8\t \n\n#define AVE_TXDM_32\t\t0x1000\t \n#define AVE_RXDM_32\t\t0x1800\t \n\n#define AVE_TXDM_SIZE_32\t0x07c0\t \n#define AVE_RXDM_SIZE_32\t0x4000\t \n\n \n#define AVE_RSTCTRL\t\t0x8028\t \n#define AVE_RSTCTRL_RMIIRST\tBIT(16)\n#define AVE_LINKSEL\t\t0x8034\t \n#define AVE_LINKSEL_100M\tBIT(0)\n\n \n#define AVE_GRR_RXFFR\t\tBIT(5)\t \n#define AVE_GRR_PHYRST\t\tBIT(4)\t \n#define AVE_GRR_GRST\t\tBIT(0)\t \n\n \n#define AVE_CFGR_FLE\t\tBIT(31)\t \n#define AVE_CFGR_CHE\t\tBIT(30)\t \n#define AVE_CFGR_MII\t\tBIT(27)\t \n#define AVE_CFGR_IPFCEN\t\tBIT(24)\t \n\n \n#define AVE_GI_PHY\t\tBIT(24)\t \n#define AVE_GI_TX\t\tBIT(16)\t \n#define AVE_GI_RXERR\t\tBIT(8)\t \n#define AVE_GI_RXOVF\t\tBIT(7)\t \n#define AVE_GI_RXDROP\t\tBIT(6)\t \n#define AVE_GI_RXIINT\t\tBIT(5)\t \n\n \n#define AVE_TXCR_FLOCTR\t\tBIT(18)\t \n#define AVE_TXCR_TXSPD_1G\tBIT(17)\n#define AVE_TXCR_TXSPD_100\tBIT(16)\n\n \n#define AVE_RXCR_RXEN\t\tBIT(30)\t \n#define AVE_RXCR_FDUPEN\t\tBIT(22)\t \n#define AVE_RXCR_FLOCTR\t\tBIT(21)\t \n#define AVE_RXCR_AFEN\t\tBIT(19)\t \n#define AVE_RXCR_DRPEN\t\tBIT(18)\t \n#define AVE_RXCR_MPSIZ_MASK\tGENMASK(10, 0)\n\n \n#define AVE_MDIOCTR_RREQ\tBIT(3)\t \n#define AVE_MDIOCTR_WREQ\tBIT(2)\t \n\n \n#define AVE_MDIOSR_STS\t\tBIT(0)\t \n\n \n#define AVE_DESCC_STATUS_MASK\tGENMASK(31, 16)\n#define AVE_DESCC_RD0\t\tBIT(8)\t \n#define AVE_DESCC_RDSTP\t\tBIT(4)\t \n#define AVE_DESCC_TD\t\tBIT(0)\t \n\n \n#define AVE_TXDC_SIZE\t\tGENMASK(27, 16)\t \n#define AVE_TXDC_ADDR\t\tGENMASK(11, 0)\t \n#define AVE_TXDC_ADDR_START\t0\n\n \n#define AVE_RXDC0_SIZE\t\tGENMASK(30, 16)\t \n#define AVE_RXDC0_ADDR\t\tGENMASK(14, 0)\t \n#define AVE_RXDC0_ADDR_START\t0\n\n \n#define AVE_IIRQC_EN0\t\tBIT(27)\t \n#define AVE_IIRQC_BSCK\t\tGENMASK(15, 0)\t \n\n \n#define AVE_STS_OWN\t\tBIT(31)\t \n#define AVE_STS_INTR\t\tBIT(29)\t \n#define AVE_STS_OK\t\tBIT(27)\t \n \n#define AVE_STS_NOCSUM\t\tBIT(28)\t \n#define AVE_STS_1ST\t\tBIT(26)\t \n#define AVE_STS_LAST\t\tBIT(25)\t \n#define AVE_STS_OWC\t\tBIT(21)\t \n#define AVE_STS_EC\t\tBIT(20)\t \n#define AVE_STS_PKTLEN_TX_MASK\tGENMASK(15, 0)\n \n#define AVE_STS_CSSV\t\tBIT(21)\t \n#define AVE_STS_CSER\t\tBIT(20)\t \n#define AVE_STS_PKTLEN_RX_MASK\tGENMASK(10, 0)\n\n \n#define AVE_PFMBYTE_MASK0\t(GENMASK(31, 8) | GENMASK(5, 0))\n#define AVE_PFMBYTE_MASK1\tGENMASK(25, 0)\n#define AVE_PFMBIT_MASK\t\tGENMASK(15, 0)\n\n#define AVE_PF_SIZE\t\t17\t \n#define AVE_PF_MULTICAST_SIZE\t7\t \n\n#define AVE_PFNUM_FILTER\t0\t \n#define AVE_PFNUM_UNICAST\t1\t \n#define AVE_PFNUM_BROADCAST\t2\t \n#define AVE_PFNUM_MULTICAST\t11\t \n\n \n#define AVE_DEFAULT_MSG_ENABLE\t(NETIF_MSG_DRV    |\t\\\n\t\t\t\t NETIF_MSG_PROBE  |\t\\\n\t\t\t\t NETIF_MSG_LINK   |\t\\\n\t\t\t\t NETIF_MSG_TIMER  |\t\\\n\t\t\t\t NETIF_MSG_IFDOWN |\t\\\n\t\t\t\t NETIF_MSG_IFUP   |\t\\\n\t\t\t\t NETIF_MSG_RX_ERR |\t\\\n\t\t\t\t NETIF_MSG_TX_ERR)\n\n \n#define AVE_NR_TXDESC\t\t64\t \n#define AVE_NR_RXDESC\t\t256\t \n\n#define AVE_DESC_OFS_CMDSTS\t0\n#define AVE_DESC_OFS_ADDRL\t4\n#define AVE_DESC_OFS_ADDRU\t8\n\n \n#define AVE_MAX_ETHFRAME\t1518\n#define AVE_FRAME_HEADROOM\t2\n\n \n#define AVE_INTM_COUNT\t\t20\n#define AVE_FORCE_TXINTCNT\t1\n\n \n#define SG_ETPINMODE\t\t0x540\n#define SG_ETPINMODE_EXTPHY\tBIT(1)\t \n#define SG_ETPINMODE_RMII(ins)\tBIT(ins)\n\n#define IS_DESC_64BIT(p)\t((p)->data->is_desc_64bit)\n\n#define AVE_MAX_CLKS\t\t4\n#define AVE_MAX_RSTS\t\t2\n\nenum desc_id {\n\tAVE_DESCID_RX,\n\tAVE_DESCID_TX,\n};\n\nenum desc_state {\n\tAVE_DESC_RX_PERMIT,\n\tAVE_DESC_RX_SUSPEND,\n\tAVE_DESC_START,\n\tAVE_DESC_STOP,\n};\n\nstruct ave_desc {\n\tstruct sk_buff\t*skbs;\n\tdma_addr_t\tskbs_dma;\n\tsize_t\t\tskbs_dmalen;\n};\n\nstruct ave_desc_info {\n\tu32\tndesc;\t\t \n\tu32\tdaddr;\t\t \n\tu32\tproc_idx;\t \n\tu32\tdone_idx;\t \n\tstruct ave_desc *desc;\t \n};\n\nstruct ave_stats {\n\tstruct\tu64_stats_sync\tsyncp;\n\tu64\tpackets;\n\tu64\tbytes;\n\tu64\terrors;\n\tu64\tdropped;\n\tu64\tcollisions;\n\tu64\tfifo_errors;\n};\n\nstruct ave_private {\n\tvoid __iomem            *base;\n\tint                     irq;\n\tint\t\t\tphy_id;\n\tunsigned int\t\tdesc_size;\n\tu32\t\t\tmsg_enable;\n\tint\t\t\tnclks;\n\tstruct clk\t\t*clk[AVE_MAX_CLKS];\n\tint\t\t\tnrsts;\n\tstruct reset_control\t*rst[AVE_MAX_RSTS];\n\tphy_interface_t\t\tphy_mode;\n\tstruct phy_device\t*phydev;\n\tstruct mii_bus\t\t*mdio;\n\tstruct regmap\t\t*regmap;\n\tunsigned int\t\tpinmode_mask;\n\tunsigned int\t\tpinmode_val;\n\tu32\t\t\twolopts;\n\n\t \n\tstruct ave_stats\tstats_rx;\n\tstruct ave_stats\tstats_tx;\n\n\t \n\tstruct net_device\t*ndev;\n\tstruct napi_struct\tnapi_rx;\n\tstruct napi_struct\tnapi_tx;\n\n\t \n\tstruct ave_desc_info\trx;\n\tstruct ave_desc_info\ttx;\n\n\t \n\tint pause_auto;\n\tint pause_rx;\n\tint pause_tx;\n\n\tconst struct ave_soc_data *data;\n};\n\nstruct ave_soc_data {\n\tbool\tis_desc_64bit;\n\tconst char\t*clock_names[AVE_MAX_CLKS];\n\tconst char\t*reset_names[AVE_MAX_RSTS];\n\tint\t(*get_pinmode)(struct ave_private *priv,\n\t\t\t       phy_interface_t phy_mode, u32 arg);\n};\n\nstatic u32 ave_desc_read(struct net_device *ndev, enum desc_id id, int entry,\n\t\t\t int offset)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tu32 addr;\n\n\taddr = ((id == AVE_DESCID_TX) ? priv->tx.daddr : priv->rx.daddr)\n\t\t+ entry * priv->desc_size + offset;\n\n\treturn readl(priv->base + addr);\n}\n\nstatic u32 ave_desc_read_cmdsts(struct net_device *ndev, enum desc_id id,\n\t\t\t\tint entry)\n{\n\treturn ave_desc_read(ndev, id, entry, AVE_DESC_OFS_CMDSTS);\n}\n\nstatic void ave_desc_write(struct net_device *ndev, enum desc_id id,\n\t\t\t   int entry, int offset, u32 val)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tu32 addr;\n\n\taddr = ((id == AVE_DESCID_TX) ? priv->tx.daddr : priv->rx.daddr)\n\t\t+ entry * priv->desc_size + offset;\n\n\twritel(val, priv->base + addr);\n}\n\nstatic void ave_desc_write_cmdsts(struct net_device *ndev, enum desc_id id,\n\t\t\t\t  int entry, u32 val)\n{\n\tave_desc_write(ndev, id, entry, AVE_DESC_OFS_CMDSTS, val);\n}\n\nstatic void ave_desc_write_addr(struct net_device *ndev, enum desc_id id,\n\t\t\t\tint entry, dma_addr_t paddr)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\n\tave_desc_write(ndev, id, entry, AVE_DESC_OFS_ADDRL,\n\t\t       lower_32_bits(paddr));\n\tif (IS_DESC_64BIT(priv))\n\t\tave_desc_write(ndev, id,\n\t\t\t       entry, AVE_DESC_OFS_ADDRU,\n\t\t\t       upper_32_bits(paddr));\n}\n\nstatic u32 ave_irq_disable_all(struct net_device *ndev)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tu32 ret;\n\n\tret = readl(priv->base + AVE_GIMR);\n\twritel(0, priv->base + AVE_GIMR);\n\n\treturn ret;\n}\n\nstatic void ave_irq_restore(struct net_device *ndev, u32 val)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\n\twritel(val, priv->base + AVE_GIMR);\n}\n\nstatic void ave_irq_enable(struct net_device *ndev, u32 bitflag)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\n\twritel(readl(priv->base + AVE_GIMR) | bitflag, priv->base + AVE_GIMR);\n\twritel(bitflag, priv->base + AVE_GISR);\n}\n\nstatic void ave_hw_write_macaddr(struct net_device *ndev,\n\t\t\t\t const unsigned char *mac_addr,\n\t\t\t\t int reg1, int reg2)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\n\twritel(mac_addr[0] | mac_addr[1] << 8 |\n\t       mac_addr[2] << 16 | mac_addr[3] << 24, priv->base + reg1);\n\twritel(mac_addr[4] | mac_addr[5] << 8, priv->base + reg2);\n}\n\nstatic void ave_hw_read_version(struct net_device *ndev, char *buf, int len)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tu32 major, minor, vr;\n\n\tvr = readl(priv->base + AVE_VR);\n\tmajor = (vr & GENMASK(15, 8)) >> 8;\n\tminor = (vr & GENMASK(7, 0));\n\tsnprintf(buf, len, \"v%u.%u\", major, minor);\n}\n\nstatic void ave_ethtool_get_drvinfo(struct net_device *ndev,\n\t\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstruct device *dev = ndev->dev.parent;\n\n\tstrscpy(info->driver, dev->driver->name, sizeof(info->driver));\n\tstrscpy(info->bus_info, dev_name(dev), sizeof(info->bus_info));\n\tave_hw_read_version(ndev, info->fw_version, sizeof(info->fw_version));\n}\n\nstatic u32 ave_ethtool_get_msglevel(struct net_device *ndev)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\n\treturn priv->msg_enable;\n}\n\nstatic void ave_ethtool_set_msglevel(struct net_device *ndev, u32 val)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\n\tpriv->msg_enable = val;\n}\n\nstatic void ave_ethtool_get_wol(struct net_device *ndev,\n\t\t\t\tstruct ethtool_wolinfo *wol)\n{\n\twol->supported = 0;\n\twol->wolopts   = 0;\n\n\tif (ndev->phydev)\n\t\tphy_ethtool_get_wol(ndev->phydev, wol);\n}\n\nstatic int __ave_ethtool_set_wol(struct net_device *ndev,\n\t\t\t\t struct ethtool_wolinfo *wol)\n{\n\tif (!ndev->phydev ||\n\t    (wol->wolopts & (WAKE_ARP | WAKE_MAGICSECURE)))\n\t\treturn -EOPNOTSUPP;\n\n\treturn phy_ethtool_set_wol(ndev->phydev, wol);\n}\n\nstatic int ave_ethtool_set_wol(struct net_device *ndev,\n\t\t\t       struct ethtool_wolinfo *wol)\n{\n\tint ret;\n\n\tret = __ave_ethtool_set_wol(ndev, wol);\n\tif (!ret)\n\t\tdevice_set_wakeup_enable(&ndev->dev, !!wol->wolopts);\n\n\treturn ret;\n}\n\nstatic void ave_ethtool_get_pauseparam(struct net_device *ndev,\n\t\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\n\tpause->autoneg  = priv->pause_auto;\n\tpause->rx_pause = priv->pause_rx;\n\tpause->tx_pause = priv->pause_tx;\n}\n\nstatic int ave_ethtool_set_pauseparam(struct net_device *ndev,\n\t\t\t\t      struct ethtool_pauseparam *pause)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tstruct phy_device *phydev = ndev->phydev;\n\n\tif (!phydev)\n\t\treturn -EINVAL;\n\n\tpriv->pause_auto = pause->autoneg;\n\tpriv->pause_rx   = pause->rx_pause;\n\tpriv->pause_tx   = pause->tx_pause;\n\n\tphy_set_asym_pause(phydev, pause->rx_pause, pause->tx_pause);\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ave_ethtool_ops = {\n\t.get_link_ksettings\t= phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= phy_ethtool_set_link_ksettings,\n\t.get_drvinfo\t\t= ave_ethtool_get_drvinfo,\n\t.nway_reset\t\t= phy_ethtool_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_msglevel\t\t= ave_ethtool_get_msglevel,\n\t.set_msglevel\t\t= ave_ethtool_set_msglevel,\n\t.get_wol\t\t= ave_ethtool_get_wol,\n\t.set_wol\t\t= ave_ethtool_set_wol,\n\t.get_pauseparam         = ave_ethtool_get_pauseparam,\n\t.set_pauseparam         = ave_ethtool_set_pauseparam,\n};\n\nstatic int ave_mdiobus_read(struct mii_bus *bus, int phyid, int regnum)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct ave_private *priv;\n\tu32 mdioctl, mdiosr;\n\tint ret;\n\n\tpriv = netdev_priv(ndev);\n\n\t \n\twritel((phyid << 8) | regnum, priv->base + AVE_MDIOAR);\n\n\t \n\tmdioctl = readl(priv->base + AVE_MDIOCTR);\n\twritel((mdioctl | AVE_MDIOCTR_RREQ) & ~AVE_MDIOCTR_WREQ,\n\t       priv->base + AVE_MDIOCTR);\n\n\tret = readl_poll_timeout(priv->base + AVE_MDIOSR, mdiosr,\n\t\t\t\t !(mdiosr & AVE_MDIOSR_STS), 20, 2000);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"failed to read (phy:%d reg:%x)\\n\",\n\t\t\t   phyid, regnum);\n\t\treturn ret;\n\t}\n\n\treturn readl(priv->base + AVE_MDIORDR) & GENMASK(15, 0);\n}\n\nstatic int ave_mdiobus_write(struct mii_bus *bus, int phyid, int regnum,\n\t\t\t     u16 val)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct ave_private *priv;\n\tu32 mdioctl, mdiosr;\n\tint ret;\n\n\tpriv = netdev_priv(ndev);\n\n\t \n\twritel((phyid << 8) | regnum, priv->base + AVE_MDIOAR);\n\n\t \n\twritel(val, priv->base + AVE_MDIOWDR);\n\n\t \n\tmdioctl = readl(priv->base + AVE_MDIOCTR);\n\twritel((mdioctl | AVE_MDIOCTR_WREQ) & ~AVE_MDIOCTR_RREQ,\n\t       priv->base + AVE_MDIOCTR);\n\n\tret = readl_poll_timeout(priv->base + AVE_MDIOSR, mdiosr,\n\t\t\t\t !(mdiosr & AVE_MDIOSR_STS), 20, 2000);\n\tif (ret)\n\t\tnetdev_err(ndev, \"failed to write (phy:%d reg:%x)\\n\",\n\t\t\t   phyid, regnum);\n\n\treturn ret;\n}\n\nstatic int ave_dma_map(struct net_device *ndev, struct ave_desc *desc,\n\t\t       void *ptr, size_t len, enum dma_data_direction dir,\n\t\t       dma_addr_t *paddr)\n{\n\tdma_addr_t map_addr;\n\n\tmap_addr = dma_map_single(ndev->dev.parent, ptr, len, dir);\n\tif (unlikely(dma_mapping_error(ndev->dev.parent, map_addr)))\n\t\treturn -ENOMEM;\n\n\tdesc->skbs_dma = map_addr;\n\tdesc->skbs_dmalen = len;\n\t*paddr = map_addr;\n\n\treturn 0;\n}\n\nstatic void ave_dma_unmap(struct net_device *ndev, struct ave_desc *desc,\n\t\t\t  enum dma_data_direction dir)\n{\n\tif (!desc->skbs_dma)\n\t\treturn;\n\n\tdma_unmap_single(ndev->dev.parent,\n\t\t\t desc->skbs_dma, desc->skbs_dmalen, dir);\n\tdesc->skbs_dma = 0;\n}\n\n \nstatic int ave_rxdesc_prepare(struct net_device *ndev, int entry)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tstruct sk_buff *skb;\n\tdma_addr_t paddr;\n\tint ret;\n\n\tskb = priv->rx.desc[entry].skbs;\n\tif (!skb) {\n\t\tskb = netdev_alloc_skb(ndev, AVE_MAX_ETHFRAME);\n\t\tif (!skb) {\n\t\t\tnetdev_err(ndev, \"can't allocate skb for Rx\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb->data += AVE_FRAME_HEADROOM;\n\t\tskb->tail += AVE_FRAME_HEADROOM;\n\t}\n\n\t \n\tave_desc_write_cmdsts(ndev, AVE_DESCID_RX, entry,\n\t\t\t      AVE_STS_INTR | AVE_STS_OWN);\n\n\t \n\tret = ave_dma_map(ndev, &priv->rx.desc[entry],\n\t\t\t  skb->data - AVE_FRAME_HEADROOM,\n\t\t\t  AVE_MAX_ETHFRAME + AVE_FRAME_HEADROOM,\n\t\t\t  DMA_FROM_DEVICE, &paddr);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"can't map skb for Rx\\n\");\n\t\tdev_kfree_skb_any(skb);\n\t\treturn ret;\n\t}\n\tpriv->rx.desc[entry].skbs = skb;\n\n\t \n\tave_desc_write_addr(ndev, AVE_DESCID_RX, entry, paddr);\n\n\t \n\tave_desc_write_cmdsts(ndev, AVE_DESCID_RX, entry,\n\t\t\t      AVE_STS_INTR | AVE_MAX_ETHFRAME);\n\n\treturn ret;\n}\n\n \nstatic int ave_desc_switch(struct net_device *ndev, enum desc_state state)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tint ret = 0;\n\tu32 val;\n\n\tswitch (state) {\n\tcase AVE_DESC_START:\n\t\twritel(AVE_DESCC_TD | AVE_DESCC_RD0, priv->base + AVE_DESCC);\n\t\tbreak;\n\n\tcase AVE_DESC_STOP:\n\t\twritel(0, priv->base + AVE_DESCC);\n\t\tif (readl_poll_timeout(priv->base + AVE_DESCC, val, !val,\n\t\t\t\t       150, 15000)) {\n\t\t\tnetdev_err(ndev, \"can't stop descriptor\\n\");\n\t\t\tret = -EBUSY;\n\t\t}\n\t\tbreak;\n\n\tcase AVE_DESC_RX_SUSPEND:\n\t\tval = readl(priv->base + AVE_DESCC);\n\t\tval |= AVE_DESCC_RDSTP;\n\t\tval &= ~AVE_DESCC_STATUS_MASK;\n\t\twritel(val, priv->base + AVE_DESCC);\n\t\tif (readl_poll_timeout(priv->base + AVE_DESCC, val,\n\t\t\t\t       val & (AVE_DESCC_RDSTP << 16),\n\t\t\t\t       150, 150000)) {\n\t\t\tnetdev_err(ndev, \"can't suspend descriptor\\n\");\n\t\t\tret = -EBUSY;\n\t\t}\n\t\tbreak;\n\n\tcase AVE_DESC_RX_PERMIT:\n\t\tval = readl(priv->base + AVE_DESCC);\n\t\tval &= ~AVE_DESCC_RDSTP;\n\t\tval &= ~AVE_DESCC_STATUS_MASK;\n\t\twritel(val, priv->base + AVE_DESCC);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int ave_tx_complete(struct net_device *ndev)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tu32 proc_idx, done_idx, ndesc, cmdsts;\n\tunsigned int nr_freebuf = 0;\n\tunsigned int tx_packets = 0;\n\tunsigned int tx_bytes = 0;\n\n\tproc_idx = priv->tx.proc_idx;\n\tdone_idx = priv->tx.done_idx;\n\tndesc    = priv->tx.ndesc;\n\n\t \n\twhile (proc_idx != done_idx) {\n\t\tcmdsts = ave_desc_read_cmdsts(ndev, AVE_DESCID_TX, done_idx);\n\n\t\t \n\t\tif (cmdsts & AVE_STS_OWN)\n\t\t\tbreak;\n\n\t\t \n\t\tif (cmdsts & AVE_STS_OK) {\n\t\t\ttx_bytes += cmdsts & AVE_STS_PKTLEN_TX_MASK;\n\t\t\t \n\t\t\tif (cmdsts & AVE_STS_LAST)\n\t\t\t\ttx_packets++;\n\t\t} else {\n\t\t\t \n\t\t\tif (cmdsts & AVE_STS_LAST) {\n\t\t\t\tpriv->stats_tx.errors++;\n\t\t\t\tif (cmdsts & (AVE_STS_OWC | AVE_STS_EC))\n\t\t\t\t\tpriv->stats_tx.collisions++;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (priv->tx.desc[done_idx].skbs) {\n\t\t\tave_dma_unmap(ndev, &priv->tx.desc[done_idx],\n\t\t\t\t      DMA_TO_DEVICE);\n\t\t\tdev_consume_skb_any(priv->tx.desc[done_idx].skbs);\n\t\t\tpriv->tx.desc[done_idx].skbs = NULL;\n\t\t\tnr_freebuf++;\n\t\t}\n\t\tdone_idx = (done_idx + 1) % ndesc;\n\t}\n\n\tpriv->tx.done_idx = done_idx;\n\n\t \n\tu64_stats_update_begin(&priv->stats_tx.syncp);\n\tpriv->stats_tx.packets += tx_packets;\n\tpriv->stats_tx.bytes   += tx_bytes;\n\tu64_stats_update_end(&priv->stats_tx.syncp);\n\n\t \n\tif (unlikely(netif_queue_stopped(ndev)) && nr_freebuf)\n\t\tnetif_wake_queue(ndev);\n\n\treturn nr_freebuf;\n}\n\nstatic int ave_rx_receive(struct net_device *ndev, int num)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tunsigned int rx_packets = 0;\n\tunsigned int rx_bytes = 0;\n\tu32 proc_idx, done_idx;\n\tstruct sk_buff *skb;\n\tunsigned int pktlen;\n\tint restpkt, npkts;\n\tu32 ndesc, cmdsts;\n\n\tproc_idx = priv->rx.proc_idx;\n\tdone_idx = priv->rx.done_idx;\n\tndesc    = priv->rx.ndesc;\n\trestpkt  = ((proc_idx + ndesc - 1) - done_idx) % ndesc;\n\n\tfor (npkts = 0; npkts < num; npkts++) {\n\t\t \n\t\tif (--restpkt < 0)\n\t\t\tbreak;\n\n\t\tcmdsts = ave_desc_read_cmdsts(ndev, AVE_DESCID_RX, proc_idx);\n\n\t\t \n\t\tif (!(cmdsts & AVE_STS_OWN))\n\t\t\tbreak;\n\n\t\tif (!(cmdsts & AVE_STS_OK)) {\n\t\t\tpriv->stats_rx.errors++;\n\t\t\tproc_idx = (proc_idx + 1) % ndesc;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpktlen = cmdsts & AVE_STS_PKTLEN_RX_MASK;\n\n\t\t \n\t\tskb = priv->rx.desc[proc_idx].skbs;\n\t\tpriv->rx.desc[proc_idx].skbs = NULL;\n\n\t\tave_dma_unmap(ndev, &priv->rx.desc[proc_idx], DMA_FROM_DEVICE);\n\n\t\tskb->dev = ndev;\n\t\tskb_put(skb, pktlen);\n\t\tskb->protocol = eth_type_trans(skb, ndev);\n\n\t\tif ((cmdsts & AVE_STS_CSSV) && (!(cmdsts & AVE_STS_CSER)))\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t\trx_packets++;\n\t\trx_bytes += pktlen;\n\n\t\tnetif_receive_skb(skb);\n\n\t\tproc_idx = (proc_idx + 1) % ndesc;\n\t}\n\n\tpriv->rx.proc_idx = proc_idx;\n\n\t \n\tu64_stats_update_begin(&priv->stats_rx.syncp);\n\tpriv->stats_rx.packets += rx_packets;\n\tpriv->stats_rx.bytes   += rx_bytes;\n\tu64_stats_update_end(&priv->stats_rx.syncp);\n\n\t \n\twhile (proc_idx != done_idx) {\n\t\tif (ave_rxdesc_prepare(ndev, done_idx))\n\t\t\tbreak;\n\t\tdone_idx = (done_idx + 1) % ndesc;\n\t}\n\n\tpriv->rx.done_idx = done_idx;\n\n\treturn npkts;\n}\n\nstatic int ave_napi_poll_rx(struct napi_struct *napi, int budget)\n{\n\tstruct ave_private *priv;\n\tstruct net_device *ndev;\n\tint num;\n\n\tpriv = container_of(napi, struct ave_private, napi_rx);\n\tndev = priv->ndev;\n\n\tnum = ave_rx_receive(ndev, budget);\n\tif (num < budget) {\n\t\tnapi_complete_done(napi, num);\n\n\t\t \n\t\tave_irq_enable(ndev, AVE_GI_RXIINT);\n\t}\n\n\treturn num;\n}\n\nstatic int ave_napi_poll_tx(struct napi_struct *napi, int budget)\n{\n\tstruct ave_private *priv;\n\tstruct net_device *ndev;\n\tint num;\n\n\tpriv = container_of(napi, struct ave_private, napi_tx);\n\tndev = priv->ndev;\n\n\tnum = ave_tx_complete(ndev);\n\tnapi_complete(napi);\n\n\t \n\tave_irq_enable(ndev, AVE_GI_TX);\n\n\treturn num;\n}\n\nstatic void ave_global_reset(struct net_device *ndev)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tu32 val;\n\n\t \n\tval = AVE_CFGR_FLE | AVE_CFGR_IPFCEN | AVE_CFGR_CHE;\n\tif (!phy_interface_mode_is_rgmii(priv->phy_mode))\n\t\tval |= AVE_CFGR_MII;\n\twritel(val, priv->base + AVE_CFGR);\n\n\t \n\tval = readl(priv->base + AVE_RSTCTRL);\n\tval &= ~AVE_RSTCTRL_RMIIRST;\n\twritel(val, priv->base + AVE_RSTCTRL);\n\n\t \n\twritel(AVE_GRR_GRST | AVE_GRR_PHYRST, priv->base + AVE_GRR);\n\tmsleep(20);\n\n\t \n\twritel(AVE_GRR_GRST, priv->base + AVE_GRR);\n\tmsleep(40);\n\n\t \n\twritel(0, priv->base + AVE_GRR);\n\tmsleep(40);\n\n\t \n\tval = readl(priv->base + AVE_RSTCTRL);\n\tval |= AVE_RSTCTRL_RMIIRST;\n\twritel(val, priv->base + AVE_RSTCTRL);\n\n\tave_irq_disable_all(ndev);\n}\n\nstatic void ave_rxfifo_reset(struct net_device *ndev)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tu32 rxcr_org;\n\n\t \n\trxcr_org = readl(priv->base + AVE_RXCR);\n\twritel(rxcr_org & (~AVE_RXCR_RXEN), priv->base + AVE_RXCR);\n\n\t \n\tave_desc_switch(ndev, AVE_DESC_RX_SUSPEND);\n\n\t \n\tave_rx_receive(ndev, priv->rx.ndesc);\n\n\t \n\twritel(AVE_GRR_RXFFR, priv->base + AVE_GRR);\n\tudelay(50);\n\n\t \n\twritel(0, priv->base + AVE_GRR);\n\tudelay(20);\n\n\t \n\twritel(AVE_GI_RXOVF, priv->base + AVE_GISR);\n\n\t \n\tave_desc_switch(ndev, AVE_DESC_RX_PERMIT);\n\n\t \n\twritel(rxcr_org, priv->base + AVE_RXCR);\n}\n\nstatic irqreturn_t ave_irq_handler(int irq, void *netdev)\n{\n\tstruct net_device *ndev = (struct net_device *)netdev;\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tu32 gimr_val, gisr_val;\n\n\tgimr_val = ave_irq_disable_all(ndev);\n\n\t \n\tgisr_val = readl(priv->base + AVE_GISR);\n\n\t \n\tif (gisr_val & AVE_GI_PHY)\n\t\twritel(AVE_GI_PHY, priv->base + AVE_GISR);\n\n\t \n\tif (gisr_val & AVE_GI_RXERR) {\n\t\twritel(AVE_GI_RXERR, priv->base + AVE_GISR);\n\t\tnetdev_err(ndev, \"receive a packet exceeding frame buffer\\n\");\n\t}\n\n\tgisr_val &= gimr_val;\n\tif (!gisr_val)\n\t\tgoto exit_isr;\n\n\t \n\tif (gisr_val & AVE_GI_RXOVF) {\n\t\tpriv->stats_rx.fifo_errors++;\n\t\tave_rxfifo_reset(ndev);\n\t\tgoto exit_isr;\n\t}\n\n\t \n\tif (gisr_val & AVE_GI_RXDROP) {\n\t\tpriv->stats_rx.dropped++;\n\t\twritel(AVE_GI_RXDROP, priv->base + AVE_GISR);\n\t}\n\n\t \n\tif (gisr_val & AVE_GI_RXIINT) {\n\t\tnapi_schedule(&priv->napi_rx);\n\t\t \n\t\tgimr_val &= ~AVE_GI_RXIINT;\n\t}\n\n\t \n\tif (gisr_val & AVE_GI_TX) {\n\t\tnapi_schedule(&priv->napi_tx);\n\t\t \n\t\tgimr_val &= ~AVE_GI_TX;\n\t}\n\nexit_isr:\n\tave_irq_restore(ndev, gimr_val);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ave_pfsel_start(struct net_device *ndev, unsigned int entry)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tu32 val;\n\n\tif (WARN_ON(entry > AVE_PF_SIZE))\n\t\treturn -EINVAL;\n\n\tval = readl(priv->base + AVE_PFEN);\n\twritel(val | BIT(entry), priv->base + AVE_PFEN);\n\n\treturn 0;\n}\n\nstatic int ave_pfsel_stop(struct net_device *ndev, unsigned int entry)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tu32 val;\n\n\tif (WARN_ON(entry > AVE_PF_SIZE))\n\t\treturn -EINVAL;\n\n\tval = readl(priv->base + AVE_PFEN);\n\twritel(val & ~BIT(entry), priv->base + AVE_PFEN);\n\n\treturn 0;\n}\n\nstatic int ave_pfsel_set_macaddr(struct net_device *ndev,\n\t\t\t\t unsigned int entry,\n\t\t\t\t const unsigned char *mac_addr,\n\t\t\t\t unsigned int set_size)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\n\tif (WARN_ON(entry > AVE_PF_SIZE))\n\t\treturn -EINVAL;\n\tif (WARN_ON(set_size > 6))\n\t\treturn -EINVAL;\n\n\tave_pfsel_stop(ndev, entry);\n\n\t \n\tave_hw_write_macaddr(ndev, mac_addr,\n\t\t\t     AVE_PKTF(entry), AVE_PKTF(entry) + 4);\n\n\t \n\twritel(GENMASK(31, set_size) & AVE_PFMBYTE_MASK0,\n\t       priv->base + AVE_PFMBYTE(entry));\n\twritel(AVE_PFMBYTE_MASK1, priv->base + AVE_PFMBYTE(entry) + 4);\n\n\t \n\twritel(AVE_PFMBIT_MASK, priv->base + AVE_PFMBIT(entry));\n\n\t \n\twritel(0, priv->base + AVE_PFSEL(entry));\n\n\t \n\tave_pfsel_start(ndev, entry);\n\n\treturn 0;\n}\n\nstatic void ave_pfsel_set_promisc(struct net_device *ndev,\n\t\t\t\t  unsigned int entry, u32 rxring)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\n\tif (WARN_ON(entry > AVE_PF_SIZE))\n\t\treturn;\n\n\tave_pfsel_stop(ndev, entry);\n\n\t \n\twritel(AVE_PFMBYTE_MASK0, priv->base + AVE_PFMBYTE(entry));\n\twritel(AVE_PFMBYTE_MASK1, priv->base + AVE_PFMBYTE(entry) + 4);\n\n\t \n\twritel(AVE_PFMBIT_MASK, priv->base + AVE_PFMBIT(entry));\n\n\t \n\twritel(rxring, priv->base + AVE_PFSEL(entry));\n\n\tave_pfsel_start(ndev, entry);\n}\n\nstatic void ave_pfsel_init(struct net_device *ndev)\n{\n\tunsigned char bcast_mac[ETH_ALEN];\n\tint i;\n\n\teth_broadcast_addr(bcast_mac);\n\n\tfor (i = 0; i < AVE_PF_SIZE; i++)\n\t\tave_pfsel_stop(ndev, i);\n\n\t \n\tave_pfsel_set_promisc(ndev, AVE_PFNUM_FILTER, 0);\n\n\t \n\tave_pfsel_set_macaddr(ndev, AVE_PFNUM_UNICAST, ndev->dev_addr, 6);\n\n\t \n\tave_pfsel_set_macaddr(ndev, AVE_PFNUM_BROADCAST, bcast_mac, 6);\n}\n\nstatic void ave_phy_adjust_link(struct net_device *ndev)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tstruct phy_device *phydev = ndev->phydev;\n\tu32 val, txcr, rxcr, rxcr_org;\n\tu16 rmt_adv = 0, lcl_adv = 0;\n\tu8 cap;\n\n\t \n\tval = readl(priv->base + AVE_TXCR);\n\tval &= ~(AVE_TXCR_TXSPD_100 | AVE_TXCR_TXSPD_1G);\n\n\tif (phy_interface_is_rgmii(phydev) && phydev->speed == SPEED_1000)\n\t\tval |= AVE_TXCR_TXSPD_1G;\n\telse if (phydev->speed == SPEED_100)\n\t\tval |= AVE_TXCR_TXSPD_100;\n\n\twritel(val, priv->base + AVE_TXCR);\n\n\t \n\tif (!phy_interface_is_rgmii(phydev)) {\n\t\tval = readl(priv->base + AVE_LINKSEL);\n\t\tif (phydev->speed == SPEED_10)\n\t\t\tval &= ~AVE_LINKSEL_100M;\n\t\telse\n\t\t\tval |= AVE_LINKSEL_100M;\n\t\twritel(val, priv->base + AVE_LINKSEL);\n\t}\n\n\t \n\trxcr = readl(priv->base + AVE_RXCR);\n\ttxcr = readl(priv->base + AVE_TXCR);\n\trxcr_org = rxcr;\n\n\tif (phydev->duplex) {\n\t\trxcr |= AVE_RXCR_FDUPEN;\n\n\t\tif (phydev->pause)\n\t\t\trmt_adv |= LPA_PAUSE_CAP;\n\t\tif (phydev->asym_pause)\n\t\t\trmt_adv |= LPA_PAUSE_ASYM;\n\n\t\tlcl_adv = linkmode_adv_to_lcl_adv_t(phydev->advertising);\n\t\tcap = mii_resolve_flowctrl_fdx(lcl_adv, rmt_adv);\n\t\tif (cap & FLOW_CTRL_TX)\n\t\t\ttxcr |= AVE_TXCR_FLOCTR;\n\t\telse\n\t\t\ttxcr &= ~AVE_TXCR_FLOCTR;\n\t\tif (cap & FLOW_CTRL_RX)\n\t\t\trxcr |= AVE_RXCR_FLOCTR;\n\t\telse\n\t\t\trxcr &= ~AVE_RXCR_FLOCTR;\n\t} else {\n\t\trxcr &= ~AVE_RXCR_FDUPEN;\n\t\trxcr &= ~AVE_RXCR_FLOCTR;\n\t\ttxcr &= ~AVE_TXCR_FLOCTR;\n\t}\n\n\tif (rxcr_org != rxcr) {\n\t\t \n\t\twritel(rxcr & ~AVE_RXCR_RXEN, priv->base + AVE_RXCR);\n\t\t \n\t\twritel(txcr, priv->base + AVE_TXCR);\n\t\twritel(rxcr, priv->base + AVE_RXCR);\n\t}\n\n\tphy_print_status(phydev);\n}\n\nstatic void ave_macaddr_init(struct net_device *ndev)\n{\n\tave_hw_write_macaddr(ndev, ndev->dev_addr, AVE_RXMAC1R, AVE_RXMAC2R);\n\n\t \n\tave_pfsel_set_macaddr(ndev, AVE_PFNUM_UNICAST, ndev->dev_addr, 6);\n}\n\nstatic int ave_init(struct net_device *ndev)\n{\n\tstruct ethtool_wolinfo wol = { .cmd = ETHTOOL_GWOL };\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tstruct device *dev = ndev->dev.parent;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *mdio_np;\n\tstruct phy_device *phydev;\n\tint nc, nr, ret;\n\n\t \n\tfor (nc = 0; nc < priv->nclks; nc++) {\n\t\tret = clk_prepare_enable(priv->clk[nc]);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"can't enable clock\\n\");\n\t\t\tgoto out_clk_disable;\n\t\t}\n\t}\n\n\tfor (nr = 0; nr < priv->nrsts; nr++) {\n\t\tret = reset_control_deassert(priv->rst[nr]);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"can't deassert reset\\n\");\n\t\t\tgoto out_reset_assert;\n\t\t}\n\t}\n\n\tret = regmap_update_bits(priv->regmap, SG_ETPINMODE,\n\t\t\t\t priv->pinmode_mask, priv->pinmode_val);\n\tif (ret)\n\t\tgoto out_reset_assert;\n\n\tave_global_reset(ndev);\n\n\tmdio_np = of_get_child_by_name(np, \"mdio\");\n\tif (!mdio_np) {\n\t\tdev_err(dev, \"mdio node not found\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_reset_assert;\n\t}\n\tret = of_mdiobus_register(priv->mdio, mdio_np);\n\tof_node_put(mdio_np);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register mdiobus\\n\");\n\t\tgoto out_reset_assert;\n\t}\n\n\tphydev = of_phy_get_and_connect(ndev, np, ave_phy_adjust_link);\n\tif (!phydev) {\n\t\tdev_err(dev, \"could not attach to PHY\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_mdio_unregister;\n\t}\n\n\tpriv->phydev = phydev;\n\n\tave_ethtool_get_wol(ndev, &wol);\n\tdevice_set_wakeup_capable(&ndev->dev, !!wol.supported);\n\n\t \n\twol.wolopts = 0;\n\t__ave_ethtool_set_wol(ndev, &wol);\n\n\tif (!phy_interface_is_rgmii(phydev))\n\t\tphy_set_max_speed(phydev, SPEED_100);\n\n\tphy_support_asym_pause(phydev);\n\n\tphydev->mac_managed_pm = true;\n\n\tphy_attached_info(phydev);\n\n\treturn 0;\n\nout_mdio_unregister:\n\tmdiobus_unregister(priv->mdio);\nout_reset_assert:\n\twhile (--nr >= 0)\n\t\treset_control_assert(priv->rst[nr]);\nout_clk_disable:\n\twhile (--nc >= 0)\n\t\tclk_disable_unprepare(priv->clk[nc]);\n\n\treturn ret;\n}\n\nstatic void ave_uninit(struct net_device *ndev)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tint i;\n\n\tphy_disconnect(priv->phydev);\n\tmdiobus_unregister(priv->mdio);\n\n\t \n\tfor (i = 0; i < priv->nrsts; i++)\n\t\treset_control_assert(priv->rst[i]);\n\tfor (i = 0; i < priv->nclks; i++)\n\t\tclk_disable_unprepare(priv->clk[i]);\n}\n\nstatic int ave_open(struct net_device *ndev)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tint entry;\n\tint ret;\n\tu32 val;\n\n\tret = request_irq(priv->irq, ave_irq_handler, IRQF_SHARED, ndev->name,\n\t\t\t  ndev);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->tx.desc = kcalloc(priv->tx.ndesc, sizeof(*priv->tx.desc),\n\t\t\t\tGFP_KERNEL);\n\tif (!priv->tx.desc) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_irq;\n\t}\n\n\tpriv->rx.desc = kcalloc(priv->rx.ndesc, sizeof(*priv->rx.desc),\n\t\t\t\tGFP_KERNEL);\n\tif (!priv->rx.desc) {\n\t\tkfree(priv->tx.desc);\n\t\tret = -ENOMEM;\n\t\tgoto out_free_irq;\n\t}\n\n\t \n\tpriv->tx.proc_idx = 0;\n\tpriv->tx.done_idx = 0;\n\tfor (entry = 0; entry < priv->tx.ndesc; entry++) {\n\t\tave_desc_write_cmdsts(ndev, AVE_DESCID_TX, entry, 0);\n\t\tave_desc_write_addr(ndev, AVE_DESCID_TX, entry, 0);\n\t}\n\twritel(AVE_TXDC_ADDR_START |\n\t       (((priv->tx.ndesc * priv->desc_size) << 16) & AVE_TXDC_SIZE),\n\t       priv->base + AVE_TXDC);\n\n\t \n\tpriv->rx.proc_idx = 0;\n\tpriv->rx.done_idx = 0;\n\tfor (entry = 0; entry < priv->rx.ndesc; entry++) {\n\t\tif (ave_rxdesc_prepare(ndev, entry))\n\t\t\tbreak;\n\t}\n\twritel(AVE_RXDC0_ADDR_START |\n\t       (((priv->rx.ndesc * priv->desc_size) << 16) & AVE_RXDC0_SIZE),\n\t       priv->base + AVE_RXDC0);\n\n\tave_desc_switch(ndev, AVE_DESC_START);\n\n\tave_pfsel_init(ndev);\n\tave_macaddr_init(ndev);\n\n\t \n\t \n\tval = AVE_RXCR_RXEN | AVE_RXCR_FDUPEN | AVE_RXCR_DRPEN |\n\t\tAVE_RXCR_FLOCTR | (AVE_MAX_ETHFRAME & AVE_RXCR_MPSIZ_MASK);\n\twritel(val, priv->base + AVE_RXCR);\n\n\t \n\t \n\twritel(AVE_TXCR_FLOCTR, priv->base + AVE_TXCR);\n\n\t \n\tval = readl(priv->base + AVE_IIRQC) & AVE_IIRQC_BSCK;\n\tval |= AVE_IIRQC_EN0 | (AVE_INTM_COUNT << 16);\n\twritel(val, priv->base + AVE_IIRQC);\n\n\tval = AVE_GI_RXIINT | AVE_GI_RXOVF | AVE_GI_TX | AVE_GI_RXDROP;\n\tave_irq_restore(ndev, val);\n\n\tnapi_enable(&priv->napi_rx);\n\tnapi_enable(&priv->napi_tx);\n\n\tphy_start(ndev->phydev);\n\tphy_start_aneg(ndev->phydev);\n\tnetif_start_queue(ndev);\n\n\treturn 0;\n\nout_free_irq:\n\tdisable_irq(priv->irq);\n\tfree_irq(priv->irq, ndev);\n\n\treturn ret;\n}\n\nstatic int ave_stop(struct net_device *ndev)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tint entry;\n\n\tave_irq_disable_all(ndev);\n\tdisable_irq(priv->irq);\n\tfree_irq(priv->irq, ndev);\n\n\tnetif_tx_disable(ndev);\n\tphy_stop(ndev->phydev);\n\tnapi_disable(&priv->napi_tx);\n\tnapi_disable(&priv->napi_rx);\n\n\tave_desc_switch(ndev, AVE_DESC_STOP);\n\n\t \n\tfor (entry = 0; entry < priv->tx.ndesc; entry++) {\n\t\tif (!priv->tx.desc[entry].skbs)\n\t\t\tcontinue;\n\n\t\tave_dma_unmap(ndev, &priv->tx.desc[entry], DMA_TO_DEVICE);\n\t\tdev_kfree_skb_any(priv->tx.desc[entry].skbs);\n\t\tpriv->tx.desc[entry].skbs = NULL;\n\t}\n\tpriv->tx.proc_idx = 0;\n\tpriv->tx.done_idx = 0;\n\n\t \n\tfor (entry = 0; entry < priv->rx.ndesc; entry++) {\n\t\tif (!priv->rx.desc[entry].skbs)\n\t\t\tcontinue;\n\n\t\tave_dma_unmap(ndev, &priv->rx.desc[entry], DMA_FROM_DEVICE);\n\t\tdev_kfree_skb_any(priv->rx.desc[entry].skbs);\n\t\tpriv->rx.desc[entry].skbs = NULL;\n\t}\n\tpriv->rx.proc_idx = 0;\n\tpriv->rx.done_idx = 0;\n\n\tkfree(priv->tx.desc);\n\tkfree(priv->rx.desc);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t ave_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tu32 proc_idx, done_idx, ndesc, cmdsts;\n\tint ret, freepkt;\n\tdma_addr_t paddr;\n\n\tproc_idx = priv->tx.proc_idx;\n\tdone_idx = priv->tx.done_idx;\n\tndesc = priv->tx.ndesc;\n\tfreepkt = ((done_idx + ndesc - 1) - proc_idx) % ndesc;\n\n\t \n\tif (unlikely(freepkt < 1)) {\n\t\tnetif_stop_queue(ndev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tif (skb_put_padto(skb, ETH_ZLEN)) {\n\t\tpriv->stats_tx.dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tret = ave_dma_map(ndev, &priv->tx.desc[proc_idx],\n\t\t\t  skb->data, skb->len, DMA_TO_DEVICE, &paddr);\n\tif (ret) {\n\t\tdev_kfree_skb_any(skb);\n\t\tpriv->stats_tx.dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tpriv->tx.desc[proc_idx].skbs = skb;\n\n\tave_desc_write_addr(ndev, AVE_DESCID_TX, proc_idx, paddr);\n\n\tcmdsts = AVE_STS_OWN | AVE_STS_1ST | AVE_STS_LAST |\n\t\t(skb->len & AVE_STS_PKTLEN_TX_MASK);\n\n\t \n\tif (!(proc_idx % AVE_FORCE_TXINTCNT) || netif_queue_stopped(ndev))\n\t\tcmdsts |= AVE_STS_INTR;\n\n\t \n\tif (skb->ip_summed == CHECKSUM_NONE ||\n\t    skb->ip_summed == CHECKSUM_UNNECESSARY)\n\t\tcmdsts |= AVE_STS_NOCSUM;\n\n\tave_desc_write_cmdsts(ndev, AVE_DESCID_TX, proc_idx, cmdsts);\n\n\tpriv->tx.proc_idx = (proc_idx + 1) % ndesc;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ave_ioctl(struct net_device *ndev, struct ifreq *ifr, int cmd)\n{\n\treturn phy_mii_ioctl(ndev->phydev, ifr, cmd);\n}\n\nstatic const u8 v4multi_macadr[] = { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 };\nstatic const u8 v6multi_macadr[] = { 0x33, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\nstatic void ave_set_rx_mode(struct net_device *ndev)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tstruct netdev_hw_addr *hw_adr;\n\tint count, mc_cnt;\n\tu32 val;\n\n\t \n\tmc_cnt = netdev_mc_count(ndev);\n\tval = readl(priv->base + AVE_RXCR);\n\tif (ndev->flags & IFF_PROMISC || !mc_cnt)\n\t\tval &= ~AVE_RXCR_AFEN;\n\telse\n\t\tval |= AVE_RXCR_AFEN;\n\twritel(val, priv->base + AVE_RXCR);\n\n\t \n\tif ((ndev->flags & IFF_ALLMULTI) || mc_cnt > AVE_PF_MULTICAST_SIZE) {\n\t\tave_pfsel_set_macaddr(ndev, AVE_PFNUM_MULTICAST,\n\t\t\t\t      v4multi_macadr, 1);\n\t\tave_pfsel_set_macaddr(ndev, AVE_PFNUM_MULTICAST + 1,\n\t\t\t\t      v6multi_macadr, 1);\n\t} else {\n\t\t \n\t\tfor (count = 0; count < AVE_PF_MULTICAST_SIZE; count++)\n\t\t\tave_pfsel_stop(ndev, AVE_PFNUM_MULTICAST + count);\n\n\t\t \n\t\tcount = 0;\n\t\tnetdev_for_each_mc_addr(hw_adr, ndev) {\n\t\t\tif (count == mc_cnt)\n\t\t\t\tbreak;\n\t\t\tave_pfsel_set_macaddr(ndev, AVE_PFNUM_MULTICAST + count,\n\t\t\t\t\t      hw_adr->addr, 6);\n\t\t\tcount++;\n\t\t}\n\t}\n}\n\nstatic void ave_get_stats64(struct net_device *ndev,\n\t\t\t    struct rtnl_link_stats64 *stats)\n{\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&priv->stats_rx.syncp);\n\t\tstats->rx_packets = priv->stats_rx.packets;\n\t\tstats->rx_bytes\t  = priv->stats_rx.bytes;\n\t} while (u64_stats_fetch_retry(&priv->stats_rx.syncp, start));\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&priv->stats_tx.syncp);\n\t\tstats->tx_packets = priv->stats_tx.packets;\n\t\tstats->tx_bytes\t  = priv->stats_tx.bytes;\n\t} while (u64_stats_fetch_retry(&priv->stats_tx.syncp, start));\n\n\tstats->rx_errors      = priv->stats_rx.errors;\n\tstats->tx_errors      = priv->stats_tx.errors;\n\tstats->rx_dropped     = priv->stats_rx.dropped;\n\tstats->tx_dropped     = priv->stats_tx.dropped;\n\tstats->rx_fifo_errors = priv->stats_rx.fifo_errors;\n\tstats->collisions     = priv->stats_tx.collisions;\n}\n\nstatic int ave_set_mac_address(struct net_device *ndev, void *p)\n{\n\tint ret = eth_mac_addr(ndev, p);\n\n\tif (ret)\n\t\treturn ret;\n\n\tave_macaddr_init(ndev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ave_netdev_ops = {\n\t.ndo_init\t\t= ave_init,\n\t.ndo_uninit\t\t= ave_uninit,\n\t.ndo_open\t\t= ave_open,\n\t.ndo_stop\t\t= ave_stop,\n\t.ndo_start_xmit\t\t= ave_start_xmit,\n\t.ndo_eth_ioctl\t\t= ave_ioctl,\n\t.ndo_set_rx_mode\t= ave_set_rx_mode,\n\t.ndo_get_stats64\t= ave_get_stats64,\n\t.ndo_set_mac_address\t= ave_set_mac_address,\n};\n\nstatic int ave_probe(struct platform_device *pdev)\n{\n\tconst struct ave_soc_data *data;\n\tstruct device *dev = &pdev->dev;\n\tchar buf[ETHTOOL_FWVERS_LEN];\n\tstruct of_phandle_args args;\n\tphy_interface_t phy_mode;\n\tstruct ave_private *priv;\n\tstruct net_device *ndev;\n\tstruct device_node *np;\n\tvoid __iomem *base;\n\tconst char *name;\n\tint i, irq, ret;\n\tu64 dma_mask;\n\tu32 ave_id;\n\n\tdata = of_device_get_match_data(dev);\n\tif (WARN_ON(!data))\n\t\treturn -EINVAL;\n\n\tnp = dev->of_node;\n\tret = of_get_phy_mode(np, &phy_mode);\n\tif (ret) {\n\t\tdev_err(dev, \"phy-mode not found\\n\");\n\t\treturn ret;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tndev = devm_alloc_etherdev(dev, sizeof(struct ave_private));\n\tif (!ndev) {\n\t\tdev_err(dev, \"can't allocate ethernet device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tndev->netdev_ops = &ave_netdev_ops;\n\tndev->ethtool_ops = &ave_ethtool_ops;\n\tSET_NETDEV_DEV(ndev, dev);\n\n\tndev->features    |= (NETIF_F_IP_CSUM | NETIF_F_RXCSUM);\n\tndev->hw_features |= (NETIF_F_IP_CSUM | NETIF_F_RXCSUM);\n\n\tndev->max_mtu = AVE_MAX_ETHFRAME - (ETH_HLEN + ETH_FCS_LEN);\n\n\tret = of_get_ethdev_address(np, ndev);\n\tif (ret) {\n\t\t \n\t\teth_hw_addr_random(ndev);\n\t\tdev_warn(dev, \"Using random MAC address: %pM\\n\",\n\t\t\t ndev->dev_addr);\n\t}\n\n\tpriv = netdev_priv(ndev);\n\tpriv->base = base;\n\tpriv->irq = irq;\n\tpriv->ndev = ndev;\n\tpriv->msg_enable = netif_msg_init(-1, AVE_DEFAULT_MSG_ENABLE);\n\tpriv->phy_mode = phy_mode;\n\tpriv->data = data;\n\n\tif (IS_DESC_64BIT(priv)) {\n\t\tpriv->desc_size = AVE_DESC_SIZE_64;\n\t\tpriv->tx.daddr  = AVE_TXDM_64;\n\t\tpriv->rx.daddr  = AVE_RXDM_64;\n\t\tdma_mask = DMA_BIT_MASK(64);\n\t} else {\n\t\tpriv->desc_size = AVE_DESC_SIZE_32;\n\t\tpriv->tx.daddr  = AVE_TXDM_32;\n\t\tpriv->rx.daddr  = AVE_RXDM_32;\n\t\tdma_mask = DMA_BIT_MASK(32);\n\t}\n\tret = dma_set_mask(dev, dma_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->tx.ndesc = AVE_NR_TXDESC;\n\tpriv->rx.ndesc = AVE_NR_RXDESC;\n\n\tu64_stats_init(&priv->stats_tx.syncp);\n\tu64_stats_init(&priv->stats_rx.syncp);\n\n\tfor (i = 0; i < AVE_MAX_CLKS; i++) {\n\t\tname = priv->data->clock_names[i];\n\t\tif (!name)\n\t\t\tbreak;\n\t\tpriv->clk[i] = devm_clk_get(dev, name);\n\t\tif (IS_ERR(priv->clk[i]))\n\t\t\treturn PTR_ERR(priv->clk[i]);\n\t\tpriv->nclks++;\n\t}\n\n\tfor (i = 0; i < AVE_MAX_RSTS; i++) {\n\t\tname = priv->data->reset_names[i];\n\t\tif (!name)\n\t\t\tbreak;\n\t\tpriv->rst[i] = devm_reset_control_get_shared(dev, name);\n\t\tif (IS_ERR(priv->rst[i]))\n\t\t\treturn PTR_ERR(priv->rst[i]);\n\t\tpriv->nrsts++;\n\t}\n\n\tret = of_parse_phandle_with_fixed_args(np,\n\t\t\t\t\t       \"socionext,syscon-phy-mode\",\n\t\t\t\t\t       1, 0, &args);\n\tif (ret) {\n\t\tdev_err(dev, \"can't get syscon-phy-mode property\\n\");\n\t\treturn ret;\n\t}\n\tpriv->regmap = syscon_node_to_regmap(args.np);\n\tof_node_put(args.np);\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(dev, \"can't map syscon-phy-mode\\n\");\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\tret = priv->data->get_pinmode(priv, phy_mode, args.args[0]);\n\tif (ret) {\n\t\tdev_err(dev, \"invalid phy-mode setting\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->mdio = devm_mdiobus_alloc(dev);\n\tif (!priv->mdio)\n\t\treturn -ENOMEM;\n\tpriv->mdio->priv = ndev;\n\tpriv->mdio->parent = dev;\n\tpriv->mdio->read = ave_mdiobus_read;\n\tpriv->mdio->write = ave_mdiobus_write;\n\tpriv->mdio->name = \"uniphier-mdio\";\n\tsnprintf(priv->mdio->id, MII_BUS_ID_SIZE, \"%s-%x\",\n\t\t pdev->name, pdev->id);\n\n\t \n\tnetif_napi_add(ndev, &priv->napi_rx, ave_napi_poll_rx);\n\tnetif_napi_add_tx(ndev, &priv->napi_tx, ave_napi_poll_tx);\n\n\tplatform_set_drvdata(pdev, ndev);\n\n\tret = register_netdev(ndev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register netdevice\\n\");\n\t\tgoto out_del_napi;\n\t}\n\n\t \n\tave_id = readl(priv->base + AVE_IDR);\n\tave_hw_read_version(ndev, buf, sizeof(buf));\n\n\tdev_info(dev, \"Socionext %c%c%c%c Ethernet IP %s (irq=%d, phy=%s)\\n\",\n\t\t (ave_id >> 24) & 0xff, (ave_id >> 16) & 0xff,\n\t\t (ave_id >> 8) & 0xff, (ave_id >> 0) & 0xff,\n\t\t buf, priv->irq, phy_modes(phy_mode));\n\n\treturn 0;\n\nout_del_napi:\n\tnetif_napi_del(&priv->napi_rx);\n\tnetif_napi_del(&priv->napi_tx);\n\n\treturn ret;\n}\n\nstatic int ave_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct ave_private *priv = netdev_priv(ndev);\n\n\tunregister_netdev(ndev);\n\tnetif_napi_del(&priv->napi_rx);\n\tnetif_napi_del(&priv->napi_tx);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ave_suspend(struct device *dev)\n{\n\tstruct ethtool_wolinfo wol = { .cmd = ETHTOOL_GWOL };\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tint ret = 0;\n\n\tif (netif_running(ndev)) {\n\t\tret = ave_stop(ndev);\n\t\tnetif_device_detach(ndev);\n\t}\n\n\tave_ethtool_get_wol(ndev, &wol);\n\tpriv->wolopts = wol.wolopts;\n\n\treturn ret;\n}\n\nstatic int ave_resume(struct device *dev)\n{\n\tstruct ethtool_wolinfo wol = { .cmd = ETHTOOL_GWOL };\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct ave_private *priv = netdev_priv(ndev);\n\tint ret = 0;\n\n\tave_global_reset(ndev);\n\n\tret = phy_init_hw(ndev->phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tave_ethtool_get_wol(ndev, &wol);\n\twol.wolopts = priv->wolopts;\n\t__ave_ethtool_set_wol(ndev, &wol);\n\n\tif (netif_running(ndev)) {\n\t\tret = ave_open(ndev);\n\t\tnetif_device_attach(ndev);\n\t}\n\n\treturn ret;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ave_pm_ops, ave_suspend, ave_resume);\n#define AVE_PM_OPS\t(&ave_pm_ops)\n#else\n#define AVE_PM_OPS\tNULL\n#endif\n\nstatic int ave_pro4_get_pinmode(struct ave_private *priv,\n\t\t\t\tphy_interface_t phy_mode, u32 arg)\n{\n\tif (arg > 0)\n\t\treturn -EINVAL;\n\n\tpriv->pinmode_mask = SG_ETPINMODE_RMII(0);\n\n\tswitch (phy_mode) {\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tpriv->pinmode_val = SG_ETPINMODE_RMII(0);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_MII:\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tpriv->pinmode_val = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ave_ld11_get_pinmode(struct ave_private *priv,\n\t\t\t\tphy_interface_t phy_mode, u32 arg)\n{\n\tif (arg > 0)\n\t\treturn -EINVAL;\n\n\tpriv->pinmode_mask = SG_ETPINMODE_EXTPHY | SG_ETPINMODE_RMII(0);\n\n\tswitch (phy_mode) {\n\tcase PHY_INTERFACE_MODE_INTERNAL:\n\t\tpriv->pinmode_val = 0;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tpriv->pinmode_val = SG_ETPINMODE_EXTPHY | SG_ETPINMODE_RMII(0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ave_ld20_get_pinmode(struct ave_private *priv,\n\t\t\t\tphy_interface_t phy_mode, u32 arg)\n{\n\tif (arg > 0)\n\t\treturn -EINVAL;\n\n\tpriv->pinmode_mask = SG_ETPINMODE_RMII(0);\n\n\tswitch (phy_mode) {\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tpriv->pinmode_val = SG_ETPINMODE_RMII(0);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tpriv->pinmode_val = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ave_pxs3_get_pinmode(struct ave_private *priv,\n\t\t\t\tphy_interface_t phy_mode, u32 arg)\n{\n\tif (arg > 1)\n\t\treturn -EINVAL;\n\n\tpriv->pinmode_mask = SG_ETPINMODE_RMII(arg);\n\n\tswitch (phy_mode) {\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tpriv->pinmode_val = SG_ETPINMODE_RMII(arg);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tpriv->pinmode_val = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ave_soc_data ave_pro4_data = {\n\t.is_desc_64bit = false,\n\t.clock_names = {\n\t\t\"gio\", \"ether\", \"ether-gb\", \"ether-phy\",\n\t},\n\t.reset_names = {\n\t\t\"gio\", \"ether\",\n\t},\n\t.get_pinmode = ave_pro4_get_pinmode,\n};\n\nstatic const struct ave_soc_data ave_pxs2_data = {\n\t.is_desc_64bit = false,\n\t.clock_names = {\n\t\t\"ether\",\n\t},\n\t.reset_names = {\n\t\t\"ether\",\n\t},\n\t.get_pinmode = ave_pro4_get_pinmode,\n};\n\nstatic const struct ave_soc_data ave_ld11_data = {\n\t.is_desc_64bit = false,\n\t.clock_names = {\n\t\t\"ether\",\n\t},\n\t.reset_names = {\n\t\t\"ether\",\n\t},\n\t.get_pinmode = ave_ld11_get_pinmode,\n};\n\nstatic const struct ave_soc_data ave_ld20_data = {\n\t.is_desc_64bit = true,\n\t.clock_names = {\n\t\t\"ether\",\n\t},\n\t.reset_names = {\n\t\t\"ether\",\n\t},\n\t.get_pinmode = ave_ld20_get_pinmode,\n};\n\nstatic const struct ave_soc_data ave_pxs3_data = {\n\t.is_desc_64bit = false,\n\t.clock_names = {\n\t\t\"ether\",\n\t},\n\t.reset_names = {\n\t\t\"ether\",\n\t},\n\t.get_pinmode = ave_pxs3_get_pinmode,\n};\n\nstatic const struct ave_soc_data ave_nx1_data = {\n\t.is_desc_64bit = true,\n\t.clock_names = {\n\t\t\"ether\",\n\t},\n\t.reset_names = {\n\t\t\"ether\",\n\t},\n\t.get_pinmode = ave_pxs3_get_pinmode,\n};\n\nstatic const struct of_device_id of_ave_match[] = {\n\t{\n\t\t.compatible = \"socionext,uniphier-pro4-ave4\",\n\t\t.data = &ave_pro4_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs2-ave4\",\n\t\t.data = &ave_pxs2_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-ld11-ave4\",\n\t\t.data = &ave_ld11_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-ld20-ave4\",\n\t\t.data = &ave_ld20_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-pxs3-ave4\",\n\t\t.data = &ave_pxs3_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-nx1-ave4\",\n\t\t.data = &ave_nx1_data,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_ave_match);\n\nstatic struct platform_driver ave_driver = {\n\t.probe  = ave_probe,\n\t.remove = ave_remove,\n\t.driver\t= {\n\t\t.name = \"ave\",\n\t\t.pm   = AVE_PM_OPS,\n\t\t.of_match_table\t= of_ave_match,\n\t},\n};\nmodule_platform_driver(ave_driver);\n\nMODULE_AUTHOR(\"Kunihiko Hayashi <hayashi.kunihiko@socionext.com>\");\nMODULE_DESCRIPTION(\"Socionext UniPhier AVE ethernet driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}