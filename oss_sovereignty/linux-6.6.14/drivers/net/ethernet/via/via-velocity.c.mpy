{
  "module_name": "via-velocity.c",
  "hash_id": "4fc5af296b696841ddbe03cf26f581562bb856d3a6bd8a0ee530f2f0baa1bf85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/via/via-velocity.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/string.h>\n#include <linux/wait.h>\n#include <linux/io.h>\n#include <linux/if.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/inetdevice.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/in.h>\n#include <linux/if_arp.h>\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/crc-ccitt.h>\n#include <linux/crc32.h>\n\n#include \"via-velocity.h\"\n\nenum velocity_bus_type {\n\tBUS_PCI,\n\tBUS_PLATFORM,\n};\n\nstatic int velocity_nics;\n\nstatic void velocity_set_power_state(struct velocity_info *vptr, char state)\n{\n\tvoid *addr = vptr->mac_regs;\n\n\tif (vptr->pdev)\n\t\tpci_set_power_state(vptr->pdev, state);\n\telse\n\t\twriteb(state, addr + 0x154);\n}\n\n \nstatic void mac_get_cam_mask(struct mac_regs __iomem *regs, u8 *mask)\n{\n\tint i;\n\n\t \n\tBYTE_REG_BITS_SET(CAMCR_PS_CAM_MASK, CAMCR_PS1 | CAMCR_PS0, &regs->CAMCR);\n\n\twriteb(0, &regs->CAMADDR);\n\n\t \n\tfor (i = 0; i < 8; i++)\n\t\t*mask++ = readb(&(regs->MARCAM[i]));\n\n\t \n\twriteb(0, &regs->CAMADDR);\n\n\t \n\tBYTE_REG_BITS_SET(CAMCR_PS_MAR, CAMCR_PS1 | CAMCR_PS0, &regs->CAMCR);\n}\n\n \nstatic void mac_set_cam_mask(struct mac_regs __iomem *regs, u8 *mask)\n{\n\tint i;\n\t \n\tBYTE_REG_BITS_SET(CAMCR_PS_CAM_MASK, CAMCR_PS1 | CAMCR_PS0, &regs->CAMCR);\n\n\twriteb(CAMADDR_CAMEN, &regs->CAMADDR);\n\n\tfor (i = 0; i < 8; i++)\n\t\twriteb(*mask++, &(regs->MARCAM[i]));\n\n\t \n\twriteb(0, &regs->CAMADDR);\n\n\t \n\tBYTE_REG_BITS_SET(CAMCR_PS_MAR, CAMCR_PS1 | CAMCR_PS0, &regs->CAMCR);\n}\n\nstatic void mac_set_vlan_cam_mask(struct mac_regs __iomem *regs, u8 *mask)\n{\n\tint i;\n\t \n\tBYTE_REG_BITS_SET(CAMCR_PS_CAM_MASK, CAMCR_PS1 | CAMCR_PS0, &regs->CAMCR);\n\n\twriteb(CAMADDR_CAMEN | CAMADDR_VCAMSL, &regs->CAMADDR);\n\n\tfor (i = 0; i < 8; i++)\n\t\twriteb(*mask++, &(regs->MARCAM[i]));\n\n\t \n\twriteb(0, &regs->CAMADDR);\n\n\t \n\tBYTE_REG_BITS_SET(CAMCR_PS_MAR, CAMCR_PS1 | CAMCR_PS0, &regs->CAMCR);\n}\n\n \nstatic void mac_set_cam(struct mac_regs __iomem *regs, int idx, const u8 *addr)\n{\n\tint i;\n\n\t \n\tBYTE_REG_BITS_SET(CAMCR_PS_CAM_DATA, CAMCR_PS1 | CAMCR_PS0, &regs->CAMCR);\n\n\tidx &= (64 - 1);\n\n\twriteb(CAMADDR_CAMEN | idx, &regs->CAMADDR);\n\n\tfor (i = 0; i < 6; i++)\n\t\twriteb(*addr++, &(regs->MARCAM[i]));\n\n\tBYTE_REG_BITS_ON(CAMCR_CAMWR, &regs->CAMCR);\n\n\tudelay(10);\n\n\twriteb(0, &regs->CAMADDR);\n\n\t \n\tBYTE_REG_BITS_SET(CAMCR_PS_MAR, CAMCR_PS1 | CAMCR_PS0, &regs->CAMCR);\n}\n\nstatic void mac_set_vlan_cam(struct mac_regs __iomem *regs, int idx,\n\t\t\t     const u8 *addr)\n{\n\n\t \n\tBYTE_REG_BITS_SET(CAMCR_PS_CAM_DATA, CAMCR_PS1 | CAMCR_PS0, &regs->CAMCR);\n\n\tidx &= (64 - 1);\n\n\twriteb(CAMADDR_CAMEN | CAMADDR_VCAMSL | idx, &regs->CAMADDR);\n\twritew(*((u16 *) addr), &regs->MARCAM[0]);\n\n\tBYTE_REG_BITS_ON(CAMCR_CAMWR, &regs->CAMCR);\n\n\tudelay(10);\n\n\twriteb(0, &regs->CAMADDR);\n\n\t \n\tBYTE_REG_BITS_SET(CAMCR_PS_MAR, CAMCR_PS1 | CAMCR_PS0, &regs->CAMCR);\n}\n\n\n \nstatic void mac_wol_reset(struct mac_regs __iomem *regs)\n{\n\n\t \n\tBYTE_REG_BITS_OFF(STICKHW_SWPTAG, &regs->STICKHW);\n\t \n\tBYTE_REG_BITS_OFF((STICKHW_DS1 | STICKHW_DS0), &regs->STICKHW);\n\n\tBYTE_REG_BITS_OFF(CHIPGCR_FCGMII, &regs->CHIPGCR);\n\tBYTE_REG_BITS_OFF(CHIPGCR_FCMODE, &regs->CHIPGCR);\n\t \n\twriteb(WOLCFG_PMEOVR, &regs->WOLCFGClr);\n\t \n\twritew(0xFFFF, &regs->WOLCRClr);\n\t \n\twritew(0xFFFF, &regs->WOLSRClr);\n}\n\nstatic const struct ethtool_ops velocity_ethtool_ops;\n\n \n\nMODULE_AUTHOR(\"VIA Networking Technologies, Inc.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"VIA Networking Velocity Family Gigabit Ethernet Adapter Driver\");\n\n#define VELOCITY_PARAM(N, D) \\\n\tstatic int N[MAX_UNITS] = OPTION_DEFAULT;\\\n\tmodule_param_array(N, int, NULL, 0); \\\n\tMODULE_PARM_DESC(N, D);\n\n#define RX_DESC_MIN     64\n#define RX_DESC_MAX     255\n#define RX_DESC_DEF     64\nVELOCITY_PARAM(RxDescriptors, \"Number of receive descriptors\");\n\n#define TX_DESC_MIN     16\n#define TX_DESC_MAX     256\n#define TX_DESC_DEF     64\nVELOCITY_PARAM(TxDescriptors, \"Number of transmit descriptors\");\n\n#define RX_THRESH_MIN   0\n#define RX_THRESH_MAX   3\n#define RX_THRESH_DEF   0\n \nVELOCITY_PARAM(rx_thresh, \"Receive fifo threshold\");\n\n#define DMA_LENGTH_MIN  0\n#define DMA_LENGTH_MAX  7\n#define DMA_LENGTH_DEF  6\n\n \nVELOCITY_PARAM(DMA_length, \"DMA length\");\n\n#define IP_ALIG_DEF     0\n \nVELOCITY_PARAM(IP_byte_align, \"Enable IP header dword aligned\");\n\n#define FLOW_CNTL_DEF   1\n#define FLOW_CNTL_MIN   1\n#define FLOW_CNTL_MAX   5\n\n \nVELOCITY_PARAM(flow_control, \"Enable flow control ability\");\n\n#define MED_LNK_DEF 0\n#define MED_LNK_MIN 0\n#define MED_LNK_MAX 5\n \nVELOCITY_PARAM(speed_duplex, \"Setting the speed and duplex mode\");\n\n#define WOL_OPT_DEF     0\n#define WOL_OPT_MIN     0\n#define WOL_OPT_MAX     7\n \nVELOCITY_PARAM(wol_opts, \"Wake On Lan options\");\n\nstatic int rx_copybreak = 200;\nmodule_param(rx_copybreak, int, 0644);\nMODULE_PARM_DESC(rx_copybreak, \"Copy breakpoint for copy-only-tiny-frames\");\n\n \nstatic struct velocity_info_tbl chip_info_table[] = {\n\t{CHIP_TYPE_VT6110, \"VIA Networking Velocity Family Gigabit Ethernet Adapter\", 1, 0x00FFFFFFUL},\n\t{ }\n};\n\n \n\nstatic const struct pci_device_id velocity_pci_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_612X) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, velocity_pci_id_table);\n\n \nstatic const struct of_device_id velocity_of_ids[] = {\n\t{ .compatible = \"via,velocity-vt6110\", .data = &chip_info_table[0] },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, velocity_of_ids);\n\n \nstatic const char *get_chip_name(enum chip_type chip_id)\n{\n\tint i;\n\tfor (i = 0; chip_info_table[i].name != NULL; i++)\n\t\tif (chip_info_table[i].chip_id == chip_id)\n\t\t\tbreak;\n\treturn chip_info_table[i].name;\n}\n\n \nstatic void velocity_set_int_opt(int *opt, int val, int min, int max, int def,\n\t\t\t\t char *name)\n{\n\tif (val == -1)\n\t\t*opt = def;\n\telse if (val < min || val > max) {\n\t\tpr_notice(\"the value of parameter %s is invalid, the valid range is (%d-%d)\\n\",\n\t\t\t  name, min, max);\n\t\t*opt = def;\n\t} else {\n\t\tpr_info(\"set value of parameter %s to %d\\n\", name, val);\n\t\t*opt = val;\n\t}\n}\n\n \nstatic void velocity_set_bool_opt(u32 *opt, int val, int def, u32 flag,\n\t\t\t\t  char *name)\n{\n\t(*opt) &= (~flag);\n\tif (val == -1)\n\t\t*opt |= (def ? flag : 0);\n\telse if (val < 0 || val > 1) {\n\t\tpr_notice(\"the value of parameter %s is invalid, the valid range is (%d-%d)\\n\",\n\t\t\t  name, 0, 1);\n\t\t*opt |= (def ? flag : 0);\n\t} else {\n\t\tpr_info(\"set parameter %s to %s\\n\",\n\t\t\tname, val ? \"TRUE\" : \"FALSE\");\n\t\t*opt |= (val ? flag : 0);\n\t}\n}\n\n \nstatic void velocity_get_options(struct velocity_opt *opts, int index)\n{\n\n\tvelocity_set_int_opt(&opts->rx_thresh, rx_thresh[index],\n\t\t\t     RX_THRESH_MIN, RX_THRESH_MAX, RX_THRESH_DEF,\n\t\t\t     \"rx_thresh\");\n\tvelocity_set_int_opt(&opts->DMA_length, DMA_length[index],\n\t\t\t     DMA_LENGTH_MIN, DMA_LENGTH_MAX, DMA_LENGTH_DEF,\n\t\t\t     \"DMA_length\");\n\tvelocity_set_int_opt(&opts->numrx, RxDescriptors[index],\n\t\t\t     RX_DESC_MIN, RX_DESC_MAX, RX_DESC_DEF,\n\t\t\t     \"RxDescriptors\");\n\tvelocity_set_int_opt(&opts->numtx, TxDescriptors[index],\n\t\t\t     TX_DESC_MIN, TX_DESC_MAX, TX_DESC_DEF,\n\t\t\t     \"TxDescriptors\");\n\n\tvelocity_set_int_opt(&opts->flow_cntl, flow_control[index],\n\t\t\t     FLOW_CNTL_MIN, FLOW_CNTL_MAX, FLOW_CNTL_DEF,\n\t\t\t     \"flow_control\");\n\tvelocity_set_bool_opt(&opts->flags, IP_byte_align[index],\n\t\t\t      IP_ALIG_DEF, VELOCITY_FLAGS_IP_ALIGN,\n\t\t\t      \"IP_byte_align\");\n\tvelocity_set_int_opt((int *) &opts->spd_dpx, speed_duplex[index],\n\t\t\t     MED_LNK_MIN, MED_LNK_MAX, MED_LNK_DEF,\n\t\t\t     \"Media link mode\");\n\tvelocity_set_int_opt(&opts->wol_opts, wol_opts[index],\n\t\t\t     WOL_OPT_MIN, WOL_OPT_MAX, WOL_OPT_DEF,\n\t\t\t     \"Wake On Lan options\");\n\topts->numrx = (opts->numrx & ~3);\n}\n\n \nstatic void velocity_init_cam_filter(struct velocity_info *vptr)\n{\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\tunsigned int vid, i = 0;\n\n\t \n\tWORD_REG_BITS_SET(MCFG_PQEN, MCFG_RTGOPT, &regs->MCFG);\n\tWORD_REG_BITS_ON(MCFG_VIDFR, &regs->MCFG);\n\n\t \n\tmemset(vptr->vCAMmask, 0, sizeof(u8) * 8);\n\tmemset(vptr->mCAMmask, 0, sizeof(u8) * 8);\n\tmac_set_vlan_cam_mask(regs, vptr->vCAMmask);\n\tmac_set_cam_mask(regs, vptr->mCAMmask);\n\n\t \n\tfor_each_set_bit(vid, vptr->active_vlans, VLAN_N_VID) {\n\t\tmac_set_vlan_cam(regs, i, (u8 *) &vid);\n\t\tvptr->vCAMmask[i / 8] |= 0x1 << (i % 8);\n\t\tif (++i >= VCAM_SIZE)\n\t\t\tbreak;\n\t}\n\tmac_set_vlan_cam_mask(regs, vptr->vCAMmask);\n}\n\nstatic int velocity_vlan_rx_add_vid(struct net_device *dev,\n\t\t\t\t    __be16 proto, u16 vid)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\n\tspin_lock_irq(&vptr->lock);\n\tset_bit(vid, vptr->active_vlans);\n\tvelocity_init_cam_filter(vptr);\n\tspin_unlock_irq(&vptr->lock);\n\treturn 0;\n}\n\nstatic int velocity_vlan_rx_kill_vid(struct net_device *dev,\n\t\t\t\t     __be16 proto, u16 vid)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\n\tspin_lock_irq(&vptr->lock);\n\tclear_bit(vid, vptr->active_vlans);\n\tvelocity_init_cam_filter(vptr);\n\tspin_unlock_irq(&vptr->lock);\n\treturn 0;\n}\n\nstatic void velocity_init_rx_ring_indexes(struct velocity_info *vptr)\n{\n\tvptr->rx.dirty = vptr->rx.filled = vptr->rx.curr = 0;\n}\n\n \nstatic void velocity_rx_reset(struct velocity_info *vptr)\n{\n\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\tint i;\n\n\tvelocity_init_rx_ring_indexes(vptr);\n\n\t \n\tfor (i = 0; i < vptr->options.numrx; ++i)\n\t\tvptr->rx.ring[i].rdesc0.len |= OWNED_BY_NIC;\n\n\twritew(vptr->options.numrx, &regs->RBRDU);\n\twritel(vptr->rx.pool_dma, &regs->RDBaseLo);\n\twritew(0, &regs->RDIdx);\n\twritew(vptr->options.numrx - 1, &regs->RDCSize);\n}\n\n \nstatic u32 velocity_get_opt_media_mode(struct velocity_info *vptr)\n{\n\tu32 status = 0;\n\n\tswitch (vptr->options.spd_dpx) {\n\tcase SPD_DPX_AUTO:\n\t\tstatus = VELOCITY_AUTONEG_ENABLE;\n\t\tbreak;\n\tcase SPD_DPX_100_FULL:\n\t\tstatus = VELOCITY_SPEED_100 | VELOCITY_DUPLEX_FULL;\n\t\tbreak;\n\tcase SPD_DPX_10_FULL:\n\t\tstatus = VELOCITY_SPEED_10 | VELOCITY_DUPLEX_FULL;\n\t\tbreak;\n\tcase SPD_DPX_100_HALF:\n\t\tstatus = VELOCITY_SPEED_100;\n\t\tbreak;\n\tcase SPD_DPX_10_HALF:\n\t\tstatus = VELOCITY_SPEED_10;\n\t\tbreak;\n\tcase SPD_DPX_1000_FULL:\n\t\tstatus = VELOCITY_SPEED_1000 | VELOCITY_DUPLEX_FULL;\n\t\tbreak;\n\t}\n\tvptr->mii_status = status;\n\treturn status;\n}\n\n \nstatic void safe_disable_mii_autopoll(struct mac_regs __iomem *regs)\n{\n\tu16 ww;\n\n\t \n\twriteb(0, &regs->MIICR);\n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tudelay(1);\n\t\tif (BYTE_REG_BITS_IS_ON(MIISR_MIDLE, &regs->MIISR))\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void enable_mii_autopoll(struct mac_regs __iomem *regs)\n{\n\tint ii;\n\n\twriteb(0, &(regs->MIICR));\n\twriteb(MIIADR_SWMPL, &regs->MIIADR);\n\n\tfor (ii = 0; ii < W_MAX_TIMEOUT; ii++) {\n\t\tudelay(1);\n\t\tif (BYTE_REG_BITS_IS_ON(MIISR_MIDLE, &regs->MIISR))\n\t\t\tbreak;\n\t}\n\n\twriteb(MIICR_MAUTO, &regs->MIICR);\n\n\tfor (ii = 0; ii < W_MAX_TIMEOUT; ii++) {\n\t\tudelay(1);\n\t\tif (!BYTE_REG_BITS_IS_ON(MIISR_MIDLE, &regs->MIISR))\n\t\t\tbreak;\n\t}\n\n}\n\n \nstatic int velocity_mii_read(struct mac_regs __iomem *regs, u8 index, u16 *data)\n{\n\tu16 ww;\n\n\t \n\tsafe_disable_mii_autopoll(regs);\n\n\twriteb(index, &regs->MIIADR);\n\n\tBYTE_REG_BITS_ON(MIICR_RCMD, &regs->MIICR);\n\n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tif (!(readb(&regs->MIICR) & MIICR_RCMD))\n\t\t\tbreak;\n\t}\n\n\t*data = readw(&regs->MIIDATA);\n\n\tenable_mii_autopoll(regs);\n\tif (ww == W_MAX_TIMEOUT)\n\t\treturn -ETIMEDOUT;\n\treturn 0;\n}\n\n \nstatic u32 mii_check_media_mode(struct mac_regs __iomem *regs)\n{\n\tu32 status = 0;\n\tu16 ANAR;\n\n\tif (!MII_REG_BITS_IS_ON(BMSR_LSTATUS, MII_BMSR, regs))\n\t\tstatus |= VELOCITY_LINK_FAIL;\n\n\tif (MII_REG_BITS_IS_ON(ADVERTISE_1000FULL, MII_CTRL1000, regs))\n\t\tstatus |= VELOCITY_SPEED_1000 | VELOCITY_DUPLEX_FULL;\n\telse if (MII_REG_BITS_IS_ON(ADVERTISE_1000HALF, MII_CTRL1000, regs))\n\t\tstatus |= (VELOCITY_SPEED_1000);\n\telse {\n\t\tvelocity_mii_read(regs, MII_ADVERTISE, &ANAR);\n\t\tif (ANAR & ADVERTISE_100FULL)\n\t\t\tstatus |= (VELOCITY_SPEED_100 | VELOCITY_DUPLEX_FULL);\n\t\telse if (ANAR & ADVERTISE_100HALF)\n\t\t\tstatus |= VELOCITY_SPEED_100;\n\t\telse if (ANAR & ADVERTISE_10FULL)\n\t\t\tstatus |= (VELOCITY_SPEED_10 | VELOCITY_DUPLEX_FULL);\n\t\telse\n\t\t\tstatus |= (VELOCITY_SPEED_10);\n\t}\n\n\tif (MII_REG_BITS_IS_ON(BMCR_ANENABLE, MII_BMCR, regs)) {\n\t\tvelocity_mii_read(regs, MII_ADVERTISE, &ANAR);\n\t\tif ((ANAR & (ADVERTISE_100FULL | ADVERTISE_100HALF | ADVERTISE_10FULL | ADVERTISE_10HALF))\n\t\t    == (ADVERTISE_100FULL | ADVERTISE_100HALF | ADVERTISE_10FULL | ADVERTISE_10HALF)) {\n\t\t\tif (MII_REG_BITS_IS_ON(ADVERTISE_1000HALF | ADVERTISE_1000FULL, MII_CTRL1000, regs))\n\t\t\t\tstatus |= VELOCITY_AUTONEG_ENABLE;\n\t\t}\n\t}\n\n\treturn status;\n}\n\n \nstatic int velocity_mii_write(struct mac_regs __iomem *regs, u8 mii_addr, u16 data)\n{\n\tu16 ww;\n\n\t \n\tsafe_disable_mii_autopoll(regs);\n\n\t \n\twriteb(mii_addr, &regs->MIIADR);\n\t \n\twritew(data, &regs->MIIDATA);\n\n\t \n\tBYTE_REG_BITS_ON(MIICR_WCMD, &regs->MIICR);\n\n\t \n\tfor (ww = 0; ww < W_MAX_TIMEOUT; ww++) {\n\t\tudelay(5);\n\t\tif (!(readb(&regs->MIICR) & MIICR_WCMD))\n\t\t\tbreak;\n\t}\n\tenable_mii_autopoll(regs);\n\n\tif (ww == W_MAX_TIMEOUT)\n\t\treturn -ETIMEDOUT;\n\treturn 0;\n}\n\n \nstatic void set_mii_flow_control(struct velocity_info *vptr)\n{\n\t \n\tswitch (vptr->options.flow_cntl) {\n\tcase FLOW_CNTL_TX:\n\t\tMII_REG_BITS_OFF(ADVERTISE_PAUSE_CAP, MII_ADVERTISE, vptr->mac_regs);\n\t\tMII_REG_BITS_ON(ADVERTISE_PAUSE_ASYM, MII_ADVERTISE, vptr->mac_regs);\n\t\tbreak;\n\n\tcase FLOW_CNTL_RX:\n\t\tMII_REG_BITS_ON(ADVERTISE_PAUSE_CAP, MII_ADVERTISE, vptr->mac_regs);\n\t\tMII_REG_BITS_ON(ADVERTISE_PAUSE_ASYM, MII_ADVERTISE, vptr->mac_regs);\n\t\tbreak;\n\n\tcase FLOW_CNTL_TX_RX:\n\t\tMII_REG_BITS_ON(ADVERTISE_PAUSE_CAP, MII_ADVERTISE, vptr->mac_regs);\n\t\tMII_REG_BITS_OFF(ADVERTISE_PAUSE_ASYM, MII_ADVERTISE, vptr->mac_regs);\n\t\tbreak;\n\n\tcase FLOW_CNTL_DISABLE:\n\t\tMII_REG_BITS_OFF(ADVERTISE_PAUSE_CAP, MII_ADVERTISE, vptr->mac_regs);\n\t\tMII_REG_BITS_OFF(ADVERTISE_PAUSE_ASYM, MII_ADVERTISE, vptr->mac_regs);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void mii_set_auto_on(struct velocity_info *vptr)\n{\n\tif (MII_REG_BITS_IS_ON(BMCR_ANENABLE, MII_BMCR, vptr->mac_regs))\n\t\tMII_REG_BITS_ON(BMCR_ANRESTART, MII_BMCR, vptr->mac_regs);\n\telse\n\t\tMII_REG_BITS_ON(BMCR_ANENABLE, MII_BMCR, vptr->mac_regs);\n}\n\nstatic u32 check_connection_type(struct mac_regs __iomem *regs)\n{\n\tu32 status = 0;\n\tu8 PHYSR0;\n\tu16 ANAR;\n\tPHYSR0 = readb(&regs->PHYSR0);\n\n\t \n\n\tif (PHYSR0 & PHYSR0_FDPX)\n\t\tstatus |= VELOCITY_DUPLEX_FULL;\n\n\tif (PHYSR0 & PHYSR0_SPDG)\n\t\tstatus |= VELOCITY_SPEED_1000;\n\telse if (PHYSR0 & PHYSR0_SPD10)\n\t\tstatus |= VELOCITY_SPEED_10;\n\telse\n\t\tstatus |= VELOCITY_SPEED_100;\n\n\tif (MII_REG_BITS_IS_ON(BMCR_ANENABLE, MII_BMCR, regs)) {\n\t\tvelocity_mii_read(regs, MII_ADVERTISE, &ANAR);\n\t\tif ((ANAR & (ADVERTISE_100FULL | ADVERTISE_100HALF | ADVERTISE_10FULL | ADVERTISE_10HALF))\n\t\t    == (ADVERTISE_100FULL | ADVERTISE_100HALF | ADVERTISE_10FULL | ADVERTISE_10HALF)) {\n\t\t\tif (MII_REG_BITS_IS_ON(ADVERTISE_1000HALF | ADVERTISE_1000FULL, MII_CTRL1000, regs))\n\t\t\t\tstatus |= VELOCITY_AUTONEG_ENABLE;\n\t\t}\n\t}\n\n\treturn status;\n}\n\n \nstatic int velocity_set_media_mode(struct velocity_info *vptr, u32 mii_status)\n{\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\n\tvptr->mii_status = mii_check_media_mode(vptr->mac_regs);\n\n\t \n\tset_mii_flow_control(vptr);\n\n\tif (PHYID_GET_PHY_ID(vptr->phy_id) == PHYID_CICADA_CS8201)\n\t\tMII_REG_BITS_ON(AUXCR_MDPPS, MII_NCONFIG, vptr->mac_regs);\n\n\t \n\tif (mii_status & VELOCITY_AUTONEG_ENABLE) {\n\t\tnetdev_info(vptr->netdev, \"Velocity is in AUTO mode\\n\");\n\t\t \n\t\tBYTE_REG_BITS_OFF(CHIPGCR_FCMODE, &regs->CHIPGCR);\n\t\t \n\t\tMII_REG_BITS_ON(ADVERTISE_100FULL | ADVERTISE_100HALF | ADVERTISE_10FULL | ADVERTISE_10HALF, MII_ADVERTISE, vptr->mac_regs);\n\t\tMII_REG_BITS_ON(ADVERTISE_1000FULL | ADVERTISE_1000HALF, MII_CTRL1000, vptr->mac_regs);\n\t\tMII_REG_BITS_ON(BMCR_SPEED1000, MII_BMCR, vptr->mac_regs);\n\n\t\t \n\t\tmii_set_auto_on(vptr);\n\t} else {\n\t\tu16 CTRL1000;\n\t\tu16 ANAR;\n\t\tu8 CHIPGCR;\n\n\t\t \n\n\t\t \n\t\tBYTE_REG_BITS_ON(CHIPGCR_FCMODE, &regs->CHIPGCR);\n\n\t\tCHIPGCR = readb(&regs->CHIPGCR);\n\n\t\tif (mii_status & VELOCITY_SPEED_1000)\n\t\t\tCHIPGCR |= CHIPGCR_FCGMII;\n\t\telse\n\t\t\tCHIPGCR &= ~CHIPGCR_FCGMII;\n\n\t\tif (mii_status & VELOCITY_DUPLEX_FULL) {\n\t\t\tCHIPGCR |= CHIPGCR_FCFDX;\n\t\t\twriteb(CHIPGCR, &regs->CHIPGCR);\n\t\t\tnetdev_info(vptr->netdev,\n\t\t\t\t    \"set Velocity to forced full mode\\n\");\n\t\t\tif (vptr->rev_id < REV_ID_VT3216_A0)\n\t\t\t\tBYTE_REG_BITS_OFF(TCR_TB2BDIS, &regs->TCR);\n\t\t} else {\n\t\t\tCHIPGCR &= ~CHIPGCR_FCFDX;\n\t\t\tnetdev_info(vptr->netdev,\n\t\t\t\t    \"set Velocity to forced half mode\\n\");\n\t\t\twriteb(CHIPGCR, &regs->CHIPGCR);\n\t\t\tif (vptr->rev_id < REV_ID_VT3216_A0)\n\t\t\t\tBYTE_REG_BITS_ON(TCR_TB2BDIS, &regs->TCR);\n\t\t}\n\n\t\tvelocity_mii_read(vptr->mac_regs, MII_CTRL1000, &CTRL1000);\n\t\tCTRL1000 &= ~(ADVERTISE_1000FULL | ADVERTISE_1000HALF);\n\t\tif ((mii_status & VELOCITY_SPEED_1000) &&\n\t\t    (mii_status & VELOCITY_DUPLEX_FULL)) {\n\t\t\tCTRL1000 |= ADVERTISE_1000FULL;\n\t\t}\n\t\tvelocity_mii_write(vptr->mac_regs, MII_CTRL1000, CTRL1000);\n\n\t\tif (!(mii_status & VELOCITY_DUPLEX_FULL) && (mii_status & VELOCITY_SPEED_10))\n\t\t\tBYTE_REG_BITS_OFF(TESTCFG_HBDIS, &regs->TESTCFG);\n\t\telse\n\t\t\tBYTE_REG_BITS_ON(TESTCFG_HBDIS, &regs->TESTCFG);\n\n\t\t \n\t\tvelocity_mii_read(vptr->mac_regs, MII_ADVERTISE, &ANAR);\n\t\tANAR &= (~(ADVERTISE_100FULL | ADVERTISE_100HALF | ADVERTISE_10FULL | ADVERTISE_10HALF));\n\t\tif (mii_status & VELOCITY_SPEED_100) {\n\t\t\tif (mii_status & VELOCITY_DUPLEX_FULL)\n\t\t\t\tANAR |= ADVERTISE_100FULL;\n\t\t\telse\n\t\t\t\tANAR |= ADVERTISE_100HALF;\n\t\t} else if (mii_status & VELOCITY_SPEED_10) {\n\t\t\tif (mii_status & VELOCITY_DUPLEX_FULL)\n\t\t\t\tANAR |= ADVERTISE_10FULL;\n\t\t\telse\n\t\t\t\tANAR |= ADVERTISE_10HALF;\n\t\t}\n\t\tvelocity_mii_write(vptr->mac_regs, MII_ADVERTISE, ANAR);\n\t\t \n\t\tmii_set_auto_on(vptr);\n\t\t \n\t}\n\t \n\t \n\treturn VELOCITY_LINK_CHANGE;\n}\n\n \nstatic void velocity_print_link_status(struct velocity_info *vptr)\n{\n\tconst char *link;\n\tconst char *speed;\n\tconst char *duplex;\n\n\tif (vptr->mii_status & VELOCITY_LINK_FAIL) {\n\t\tnetdev_notice(vptr->netdev, \"failed to detect cable link\\n\");\n\t\treturn;\n\t}\n\n\tif (vptr->options.spd_dpx == SPD_DPX_AUTO) {\n\t\tlink = \"auto-negotiation\";\n\n\t\tif (vptr->mii_status & VELOCITY_SPEED_1000)\n\t\t\tspeed = \"1000\";\n\t\telse if (vptr->mii_status & VELOCITY_SPEED_100)\n\t\t\tspeed = \"100\";\n\t\telse\n\t\t\tspeed = \"10\";\n\n\t\tif (vptr->mii_status & VELOCITY_DUPLEX_FULL)\n\t\t\tduplex = \"full\";\n\t\telse\n\t\t\tduplex = \"half\";\n\t} else {\n\t\tlink = \"forced\";\n\n\t\tswitch (vptr->options.spd_dpx) {\n\t\tcase SPD_DPX_1000_FULL:\n\t\t\tspeed = \"1000\";\n\t\t\tduplex = \"full\";\n\t\t\tbreak;\n\t\tcase SPD_DPX_100_HALF:\n\t\t\tspeed = \"100\";\n\t\t\tduplex = \"half\";\n\t\t\tbreak;\n\t\tcase SPD_DPX_100_FULL:\n\t\t\tspeed = \"100\";\n\t\t\tduplex = \"full\";\n\t\t\tbreak;\n\t\tcase SPD_DPX_10_HALF:\n\t\t\tspeed = \"10\";\n\t\t\tduplex = \"half\";\n\t\t\tbreak;\n\t\tcase SPD_DPX_10_FULL:\n\t\t\tspeed = \"10\";\n\t\t\tduplex = \"full\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tspeed = \"unknown\";\n\t\t\tduplex = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t}\n\tnetdev_notice(vptr->netdev, \"Link %s speed %sM bps %s duplex\\n\",\n\t\t      link, speed, duplex);\n}\n\n \nstatic void enable_flow_control_ability(struct velocity_info *vptr)\n{\n\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\n\tswitch (vptr->options.flow_cntl) {\n\n\tcase FLOW_CNTL_DEFAULT:\n\t\tif (BYTE_REG_BITS_IS_ON(PHYSR0_RXFLC, &regs->PHYSR0))\n\t\t\twritel(CR0_FDXRFCEN, &regs->CR0Set);\n\t\telse\n\t\t\twritel(CR0_FDXRFCEN, &regs->CR0Clr);\n\n\t\tif (BYTE_REG_BITS_IS_ON(PHYSR0_TXFLC, &regs->PHYSR0))\n\t\t\twritel(CR0_FDXTFCEN, &regs->CR0Set);\n\t\telse\n\t\t\twritel(CR0_FDXTFCEN, &regs->CR0Clr);\n\t\tbreak;\n\n\tcase FLOW_CNTL_TX:\n\t\twritel(CR0_FDXTFCEN, &regs->CR0Set);\n\t\twritel(CR0_FDXRFCEN, &regs->CR0Clr);\n\t\tbreak;\n\n\tcase FLOW_CNTL_RX:\n\t\twritel(CR0_FDXRFCEN, &regs->CR0Set);\n\t\twritel(CR0_FDXTFCEN, &regs->CR0Clr);\n\t\tbreak;\n\n\tcase FLOW_CNTL_TX_RX:\n\t\twritel(CR0_FDXTFCEN, &regs->CR0Set);\n\t\twritel(CR0_FDXRFCEN, &regs->CR0Set);\n\t\tbreak;\n\n\tcase FLOW_CNTL_DISABLE:\n\t\twritel(CR0_FDXRFCEN, &regs->CR0Clr);\n\t\twritel(CR0_FDXTFCEN, &regs->CR0Clr);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n}\n\n \nstatic int velocity_soft_reset(struct velocity_info *vptr)\n{\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\tint i = 0;\n\n\twritel(CR0_SFRST, &regs->CR0Set);\n\n\tfor (i = 0; i < W_MAX_TIMEOUT; i++) {\n\t\tudelay(5);\n\t\tif (!DWORD_REG_BITS_IS_ON(CR0_SFRST, &regs->CR0Set))\n\t\t\tbreak;\n\t}\n\n\tif (i == W_MAX_TIMEOUT) {\n\t\twritel(CR0_FORSRST, &regs->CR0Set);\n\t\t \n\t\t \n\t\tmdelay(2);\n\t}\n\treturn 0;\n}\n\n \nstatic void velocity_set_multi(struct net_device *dev)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\tu8 rx_mode;\n\tint i;\n\tstruct netdev_hw_addr *ha;\n\n\tif (dev->flags & IFF_PROMISC) {\t \n\t\twritel(0xffffffff, &regs->MARCAM[0]);\n\t\twritel(0xffffffff, &regs->MARCAM[4]);\n\t\trx_mode = (RCR_AM | RCR_AB | RCR_PROM);\n\t} else if ((netdev_mc_count(dev) > vptr->multicast_limit) ||\n\t\t   (dev->flags & IFF_ALLMULTI)) {\n\t\twritel(0xffffffff, &regs->MARCAM[0]);\n\t\twritel(0xffffffff, &regs->MARCAM[4]);\n\t\trx_mode = (RCR_AM | RCR_AB);\n\t} else {\n\t\tint offset = MCAM_SIZE - vptr->multicast_limit;\n\t\tmac_get_cam_mask(regs, vptr->mCAMmask);\n\n\t\ti = 0;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tmac_set_cam(regs, i + offset, ha->addr);\n\t\t\tvptr->mCAMmask[(offset + i) / 8] |= 1 << ((offset + i) & 7);\n\t\t\ti++;\n\t\t}\n\n\t\tmac_set_cam_mask(regs, vptr->mCAMmask);\n\t\trx_mode = RCR_AM | RCR_AB | RCR_AP;\n\t}\n\tif (dev->mtu > 1500)\n\t\trx_mode |= RCR_AL;\n\n\tBYTE_REG_BITS_ON(rx_mode, &regs->RCR);\n\n}\n\n \n\n \nstatic void mii_init(struct velocity_info *vptr, u32 mii_status)\n{\n\tu16 BMCR;\n\n\tswitch (PHYID_GET_PHY_ID(vptr->phy_id)) {\n\tcase PHYID_ICPLUS_IP101A:\n\t\tMII_REG_BITS_ON((ADVERTISE_PAUSE_ASYM | ADVERTISE_PAUSE_CAP),\n\t\t\t\t\t\tMII_ADVERTISE, vptr->mac_regs);\n\t\tif (vptr->mii_status & VELOCITY_DUPLEX_FULL)\n\t\t\tMII_REG_BITS_ON(TCSR_ECHODIS, MII_SREVISION,\n\t\t\t\t\t\t\t\tvptr->mac_regs);\n\t\telse\n\t\t\tMII_REG_BITS_OFF(TCSR_ECHODIS, MII_SREVISION,\n\t\t\t\t\t\t\t\tvptr->mac_regs);\n\t\tMII_REG_BITS_ON(PLED_LALBE, MII_TPISTATUS, vptr->mac_regs);\n\t\tbreak;\n\tcase PHYID_CICADA_CS8201:\n\t\t \n\t\tMII_REG_BITS_OFF((ADVERTISE_PAUSE_ASYM | ADVERTISE_PAUSE_CAP), MII_ADVERTISE, vptr->mac_regs);\n\t\t \n\t\tif (vptr->mii_status & VELOCITY_DUPLEX_FULL)\n\t\t\tMII_REG_BITS_ON(TCSR_ECHODIS, MII_SREVISION, vptr->mac_regs);\n\t\telse\n\t\t\tMII_REG_BITS_OFF(TCSR_ECHODIS, MII_SREVISION, vptr->mac_regs);\n\t\t \n\t\tMII_REG_BITS_ON(PLED_LALBE, MII_TPISTATUS, vptr->mac_regs);\n\t\tbreak;\n\tcase PHYID_VT3216_32BIT:\n\tcase PHYID_VT3216_64BIT:\n\t\t \n\t\tMII_REG_BITS_ON((ADVERTISE_PAUSE_ASYM | ADVERTISE_PAUSE_CAP), MII_ADVERTISE, vptr->mac_regs);\n\t\t \n\t\tif (vptr->mii_status & VELOCITY_DUPLEX_FULL)\n\t\t\tMII_REG_BITS_ON(TCSR_ECHODIS, MII_SREVISION, vptr->mac_regs);\n\t\telse\n\t\t\tMII_REG_BITS_OFF(TCSR_ECHODIS, MII_SREVISION, vptr->mac_regs);\n\t\tbreak;\n\n\tcase PHYID_MARVELL_1000:\n\tcase PHYID_MARVELL_1000S:\n\t\t \n\t\tMII_REG_BITS_ON(PSCR_ACRSTX, MII_REG_PSCR, vptr->mac_regs);\n\t\t \n\t\tMII_REG_BITS_ON((ADVERTISE_PAUSE_ASYM | ADVERTISE_PAUSE_CAP), MII_ADVERTISE, vptr->mac_regs);\n\t\tbreak;\n\tdefault:\n\t\t;\n\t}\n\tvelocity_mii_read(vptr->mac_regs, MII_BMCR, &BMCR);\n\tif (BMCR & BMCR_ISOLATE) {\n\t\tBMCR &= ~BMCR_ISOLATE;\n\t\tvelocity_mii_write(vptr->mac_regs, MII_BMCR, BMCR);\n\t}\n}\n\n \nstatic void setup_queue_timers(struct velocity_info *vptr)\n{\n\t \n\tif (vptr->rev_id >= REV_ID_VT3216_A0) {\n\t\tu8 txqueue_timer = 0;\n\t\tu8 rxqueue_timer = 0;\n\n\t\tif (vptr->mii_status & (VELOCITY_SPEED_1000 |\n\t\t\t\tVELOCITY_SPEED_100)) {\n\t\t\ttxqueue_timer = vptr->options.txqueue_timer;\n\t\t\trxqueue_timer = vptr->options.rxqueue_timer;\n\t\t}\n\n\t\twriteb(txqueue_timer, &vptr->mac_regs->TQETMR);\n\t\twriteb(rxqueue_timer, &vptr->mac_regs->RQETMR);\n\t}\n}\n\n \nstatic void setup_adaptive_interrupts(struct velocity_info *vptr)\n{\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\tu16 tx_intsup = vptr->options.tx_intsup;\n\tu16 rx_intsup = vptr->options.rx_intsup;\n\n\t \n\tvptr->int_mask = INT_MASK_DEF;\n\n\t \n\twriteb(CAMCR_PS0, &regs->CAMCR);\n\tif (tx_intsup != 0) {\n\t\tvptr->int_mask &= ~(ISR_PTXI | ISR_PTX0I | ISR_PTX1I |\n\t\t\t\tISR_PTX2I | ISR_PTX3I);\n\t\twritew(tx_intsup, &regs->ISRCTL);\n\t} else\n\t\twritew(ISRCTL_TSUPDIS, &regs->ISRCTL);\n\n\t \n\twriteb(CAMCR_PS1, &regs->CAMCR);\n\tif (rx_intsup != 0) {\n\t\tvptr->int_mask &= ~ISR_PRXI;\n\t\twritew(rx_intsup, &regs->ISRCTL);\n\t} else\n\t\twritew(ISRCTL_RSUPDIS, &regs->ISRCTL);\n\n\t \n\twriteb(0, &regs->CAMCR);\n}\n\n \nstatic void velocity_init_registers(struct velocity_info *vptr,\n\t\t\t\t    enum velocity_init_type type)\n{\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\tstruct net_device *netdev = vptr->netdev;\n\tint i, mii_status;\n\n\tmac_wol_reset(regs);\n\n\tswitch (type) {\n\tcase VELOCITY_INIT_RESET:\n\tcase VELOCITY_INIT_WOL:\n\n\t\tnetif_stop_queue(netdev);\n\n\t\t \n\t\tvelocity_rx_reset(vptr);\n\t\tmac_rx_queue_run(regs);\n\t\tmac_rx_queue_wake(regs);\n\n\t\tmii_status = velocity_get_opt_media_mode(vptr);\n\t\tif (velocity_set_media_mode(vptr, mii_status) != VELOCITY_LINK_CHANGE) {\n\t\t\tvelocity_print_link_status(vptr);\n\t\t\tif (!(vptr->mii_status & VELOCITY_LINK_FAIL))\n\t\t\t\tnetif_wake_queue(netdev);\n\t\t}\n\n\t\tenable_flow_control_ability(vptr);\n\n\t\tmac_clear_isr(regs);\n\t\twritel(CR0_STOP, &regs->CR0Clr);\n\t\twritel((CR0_DPOLL | CR0_TXON | CR0_RXON | CR0_STRT),\n\t\t\t\t\t\t\t&regs->CR0Set);\n\n\t\tbreak;\n\n\tcase VELOCITY_INIT_COLD:\n\tdefault:\n\t\t \n\t\tvelocity_soft_reset(vptr);\n\t\tmdelay(5);\n\n\t\tif (!vptr->no_eeprom) {\n\t\t\tmac_eeprom_reload(regs);\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\twriteb(netdev->dev_addr[i], regs->PAR + i);\n\t\t}\n\n\t\t \n\t\tBYTE_REG_BITS_OFF(CFGA_PACPI, &(regs->CFGA));\n\t\tmac_set_rx_thresh(regs, vptr->options.rx_thresh);\n\t\tmac_set_dma_length(regs, vptr->options.DMA_length);\n\n\t\twriteb(WOLCFG_SAM | WOLCFG_SAB, &regs->WOLCFGSet);\n\t\t \n\t\tBYTE_REG_BITS_SET(CFGB_OFSET, (CFGB_CRANDOM | CFGB_CAP | CFGB_MBA | CFGB_BAKOPT), &regs->CFGB);\n\n\t\t \n\t\tvelocity_init_cam_filter(vptr);\n\n\t\t \n\t\tvelocity_set_multi(netdev);\n\n\t\t \n\t\tenable_mii_autopoll(regs);\n\n\t\tsetup_adaptive_interrupts(vptr);\n\n\t\twritel(vptr->rx.pool_dma, &regs->RDBaseLo);\n\t\twritew(vptr->options.numrx - 1, &regs->RDCSize);\n\t\tmac_rx_queue_run(regs);\n\t\tmac_rx_queue_wake(regs);\n\n\t\twritew(vptr->options.numtx - 1, &regs->TDCSize);\n\n\t\tfor (i = 0; i < vptr->tx.numq; i++) {\n\t\t\twritel(vptr->tx.pool_dma[i], &regs->TDBaseLo[i]);\n\t\t\tmac_tx_queue_run(regs, i);\n\t\t}\n\n\t\tinit_flow_control_register(vptr);\n\n\t\twritel(CR0_STOP, &regs->CR0Clr);\n\t\twritel((CR0_DPOLL | CR0_TXON | CR0_RXON | CR0_STRT), &regs->CR0Set);\n\n\t\tmii_status = velocity_get_opt_media_mode(vptr);\n\t\tnetif_stop_queue(netdev);\n\n\t\tmii_init(vptr, mii_status);\n\n\t\tif (velocity_set_media_mode(vptr, mii_status) != VELOCITY_LINK_CHANGE) {\n\t\t\tvelocity_print_link_status(vptr);\n\t\t\tif (!(vptr->mii_status & VELOCITY_LINK_FAIL))\n\t\t\t\tnetif_wake_queue(netdev);\n\t\t}\n\n\t\tenable_flow_control_ability(vptr);\n\t\tmac_hw_mibs_init(regs);\n\t\tmac_write_int_mask(vptr->int_mask, regs);\n\t\tmac_clear_isr(regs);\n\n\t}\n}\n\nstatic void velocity_give_many_rx_descs(struct velocity_info *vptr)\n{\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\tint avail, dirty, unusable;\n\n\t \n\tif (vptr->rx.filled < 4)\n\t\treturn;\n\n\twmb();\n\n\tunusable = vptr->rx.filled & 0x0003;\n\tdirty = vptr->rx.dirty - unusable;\n\tfor (avail = vptr->rx.filled & 0xfffc; avail; avail--) {\n\t\tdirty = (dirty > 0) ? dirty - 1 : vptr->options.numrx - 1;\n\t\tvptr->rx.ring[dirty].rdesc0.len |= OWNED_BY_NIC;\n\t}\n\n\twritew(vptr->rx.filled & 0xfffc, &regs->RBRDU);\n\tvptr->rx.filled = unusable;\n}\n\n \nstatic int velocity_init_dma_rings(struct velocity_info *vptr)\n{\n\tstruct velocity_opt *opt = &vptr->options;\n\tconst unsigned int rx_ring_size = opt->numrx * sizeof(struct rx_desc);\n\tconst unsigned int tx_ring_size = opt->numtx * sizeof(struct tx_desc);\n\tdma_addr_t pool_dma;\n\tvoid *pool;\n\tunsigned int i;\n\n\t \n\tpool = dma_alloc_coherent(vptr->dev, tx_ring_size * vptr->tx.numq +\n\t\t\t\t    rx_ring_size, &pool_dma, GFP_ATOMIC);\n\tif (!pool) {\n\t\tdev_err(vptr->dev, \"%s : DMA memory allocation failed.\\n\",\n\t\t\tvptr->netdev->name);\n\t\treturn -ENOMEM;\n\t}\n\n\tvptr->rx.ring = pool;\n\tvptr->rx.pool_dma = pool_dma;\n\n\tpool += rx_ring_size;\n\tpool_dma += rx_ring_size;\n\n\tfor (i = 0; i < vptr->tx.numq; i++) {\n\t\tvptr->tx.rings[i] = pool;\n\t\tvptr->tx.pool_dma[i] = pool_dma;\n\t\tpool += tx_ring_size;\n\t\tpool_dma += tx_ring_size;\n\t}\n\n\treturn 0;\n}\n\nstatic void velocity_set_rxbufsize(struct velocity_info *vptr, int mtu)\n{\n\tvptr->rx.buf_sz = (mtu <= ETH_DATA_LEN) ? PKT_BUF_SZ : mtu + 32;\n}\n\n \nstatic int velocity_alloc_rx_buf(struct velocity_info *vptr, int idx)\n{\n\tstruct rx_desc *rd = &(vptr->rx.ring[idx]);\n\tstruct velocity_rd_info *rd_info = &(vptr->rx.info[idx]);\n\n\trd_info->skb = netdev_alloc_skb(vptr->netdev, vptr->rx.buf_sz + 64);\n\tif (rd_info->skb == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tskb_reserve(rd_info->skb,\n\t\t\t64 - ((unsigned long) rd_info->skb->data & 63));\n\trd_info->skb_dma = dma_map_single(vptr->dev, rd_info->skb->data,\n\t\t\t\t\tvptr->rx.buf_sz, DMA_FROM_DEVICE);\n\n\t \n\n\t*((u32 *) & (rd->rdesc0)) = 0;\n\trd->size = cpu_to_le16(vptr->rx.buf_sz) | RX_INTEN;\n\trd->pa_low = cpu_to_le32(rd_info->skb_dma);\n\trd->pa_high = 0;\n\treturn 0;\n}\n\n\nstatic int velocity_rx_refill(struct velocity_info *vptr)\n{\n\tint dirty = vptr->rx.dirty, done = 0;\n\n\tdo {\n\t\tstruct rx_desc *rd = vptr->rx.ring + dirty;\n\n\t\t \n\t\tif (rd->rdesc0.len & OWNED_BY_NIC)\n\t\t\tbreak;\n\n\t\tif (!vptr->rx.info[dirty].skb) {\n\t\t\tif (velocity_alloc_rx_buf(vptr, dirty) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tdone++;\n\t\tdirty = (dirty < vptr->options.numrx - 1) ? dirty + 1 : 0;\n\t} while (dirty != vptr->rx.curr);\n\n\tif (done) {\n\t\tvptr->rx.dirty = dirty;\n\t\tvptr->rx.filled += done;\n\t}\n\n\treturn done;\n}\n\n \nstatic void velocity_free_rd_ring(struct velocity_info *vptr)\n{\n\tint i;\n\n\tif (vptr->rx.info == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < vptr->options.numrx; i++) {\n\t\tstruct velocity_rd_info *rd_info = &(vptr->rx.info[i]);\n\t\tstruct rx_desc *rd = vptr->rx.ring + i;\n\n\t\tmemset(rd, 0, sizeof(*rd));\n\n\t\tif (!rd_info->skb)\n\t\t\tcontinue;\n\t\tdma_unmap_single(vptr->dev, rd_info->skb_dma, vptr->rx.buf_sz,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\trd_info->skb_dma = 0;\n\n\t\tdev_kfree_skb(rd_info->skb);\n\t\trd_info->skb = NULL;\n\t}\n\n\tkfree(vptr->rx.info);\n\tvptr->rx.info = NULL;\n}\n\n \nstatic int velocity_init_rd_ring(struct velocity_info *vptr)\n{\n\tint ret = -ENOMEM;\n\n\tvptr->rx.info = kcalloc(vptr->options.numrx,\n\t\t\t\tsizeof(struct velocity_rd_info), GFP_KERNEL);\n\tif (!vptr->rx.info)\n\t\tgoto out;\n\n\tvelocity_init_rx_ring_indexes(vptr);\n\n\tif (velocity_rx_refill(vptr) != vptr->options.numrx) {\n\t\tnetdev_err(vptr->netdev, \"failed to allocate RX buffer\\n\");\n\t\tvelocity_free_rd_ring(vptr);\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\n \nstatic int velocity_init_td_ring(struct velocity_info *vptr)\n{\n\tint j;\n\n\t \n\tfor (j = 0; j < vptr->tx.numq; j++) {\n\n\t\tvptr->tx.infos[j] = kcalloc(vptr->options.numtx,\n\t\t\t\t\t    sizeof(struct velocity_td_info),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!vptr->tx.infos[j])\t{\n\t\t\twhile (--j >= 0)\n\t\t\t\tkfree(vptr->tx.infos[j]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tvptr->tx.tail[j] = vptr->tx.curr[j] = vptr->tx.used[j] = 0;\n\t}\n\treturn 0;\n}\n\n \nstatic void velocity_free_dma_rings(struct velocity_info *vptr)\n{\n\tconst int size = vptr->options.numrx * sizeof(struct rx_desc) +\n\t\tvptr->options.numtx * sizeof(struct tx_desc) * vptr->tx.numq;\n\n\tdma_free_coherent(vptr->dev, size, vptr->rx.ring, vptr->rx.pool_dma);\n}\n\nstatic int velocity_init_rings(struct velocity_info *vptr, int mtu)\n{\n\tint ret;\n\n\tvelocity_set_rxbufsize(vptr, mtu);\n\n\tret = velocity_init_dma_rings(vptr);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = velocity_init_rd_ring(vptr);\n\tif (ret < 0)\n\t\tgoto err_free_dma_rings_0;\n\n\tret = velocity_init_td_ring(vptr);\n\tif (ret < 0)\n\t\tgoto err_free_rd_ring_1;\nout:\n\treturn ret;\n\nerr_free_rd_ring_1:\n\tvelocity_free_rd_ring(vptr);\nerr_free_dma_rings_0:\n\tvelocity_free_dma_rings(vptr);\n\tgoto out;\n}\n\n \nstatic void velocity_free_tx_buf(struct velocity_info *vptr,\n\t\tstruct velocity_td_info *tdinfo, struct tx_desc *td)\n{\n\tstruct sk_buff *skb = tdinfo->skb;\n\tint i;\n\n\t \n\tfor (i = 0; i < tdinfo->nskb_dma; i++) {\n\t\tsize_t pktlen = max_t(size_t, skb->len, ETH_ZLEN);\n\n\t\t \n\t\tif (skb_shinfo(skb)->nr_frags > 0)\n\t\t\tpktlen = max_t(size_t, pktlen,\n\t\t\t\t       td->td_buf[i].size & ~TD_QUEUE);\n\n\t\tdma_unmap_single(vptr->dev, tdinfo->skb_dma[i],\n\t\t\t\t le16_to_cpu(pktlen), DMA_TO_DEVICE);\n\t}\n\tdev_consume_skb_irq(skb);\n\ttdinfo->skb = NULL;\n}\n\n \nstatic void velocity_free_td_ring_entry(struct velocity_info *vptr,\n\t\t\t\t\t\t\t int q, int n)\n{\n\tstruct velocity_td_info *td_info = &(vptr->tx.infos[q][n]);\n\tint i;\n\n\tif (td_info == NULL)\n\t\treturn;\n\n\tif (td_info->skb) {\n\t\tfor (i = 0; i < td_info->nskb_dma; i++) {\n\t\t\tif (td_info->skb_dma[i]) {\n\t\t\t\tdma_unmap_single(vptr->dev, td_info->skb_dma[i],\n\t\t\t\t\ttd_info->skb->len, DMA_TO_DEVICE);\n\t\t\t\ttd_info->skb_dma[i] = 0;\n\t\t\t}\n\t\t}\n\t\tdev_kfree_skb(td_info->skb);\n\t\ttd_info->skb = NULL;\n\t}\n}\n\n \nstatic void velocity_free_td_ring(struct velocity_info *vptr)\n{\n\tint i, j;\n\n\tfor (j = 0; j < vptr->tx.numq; j++) {\n\t\tif (vptr->tx.infos[j] == NULL)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < vptr->options.numtx; i++)\n\t\t\tvelocity_free_td_ring_entry(vptr, j, i);\n\n\t\tkfree(vptr->tx.infos[j]);\n\t\tvptr->tx.infos[j] = NULL;\n\t}\n}\n\nstatic void velocity_free_rings(struct velocity_info *vptr)\n{\n\tvelocity_free_td_ring(vptr);\n\tvelocity_free_rd_ring(vptr);\n\tvelocity_free_dma_rings(vptr);\n}\n\n \nstatic void velocity_error(struct velocity_info *vptr, int status)\n{\n\n\tif (status & ISR_TXSTLI) {\n\t\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\n\t\tnetdev_err(vptr->netdev, \"TD structure error TDindex=%hx\\n\",\n\t\t\t   readw(&regs->TDIdx[0]));\n\t\tBYTE_REG_BITS_ON(TXESR_TDSTR, &regs->TXESR);\n\t\twritew(TRDCSR_RUN, &regs->TDCSRClr);\n\t\tnetif_stop_queue(vptr->netdev);\n\n\t\t \n\t}\n\n\tif (status & ISR_SRCI) {\n\t\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\t\tint linked;\n\n\t\tif (vptr->options.spd_dpx == SPD_DPX_AUTO) {\n\t\t\tvptr->mii_status = check_connection_type(regs);\n\n\t\t\t \n\t\t\tif (vptr->rev_id < REV_ID_VT3216_A0) {\n\t\t\t\tif (vptr->mii_status & VELOCITY_DUPLEX_FULL)\n\t\t\t\t\tBYTE_REG_BITS_ON(TCR_TB2BDIS, &regs->TCR);\n\t\t\t\telse\n\t\t\t\t\tBYTE_REG_BITS_OFF(TCR_TB2BDIS, &regs->TCR);\n\t\t\t}\n\t\t\t \n\t\t\tif (!(vptr->mii_status & VELOCITY_DUPLEX_FULL) && (vptr->mii_status & VELOCITY_SPEED_10))\n\t\t\t\tBYTE_REG_BITS_OFF(TESTCFG_HBDIS, &regs->TESTCFG);\n\t\t\telse\n\t\t\t\tBYTE_REG_BITS_ON(TESTCFG_HBDIS, &regs->TESTCFG);\n\n\t\t\tsetup_queue_timers(vptr);\n\t\t}\n\t\t \n\t\tlinked = readb(&regs->PHYSR0) & PHYSR0_LINKGD;\n\n\t\tif (linked) {\n\t\t\tvptr->mii_status &= ~VELOCITY_LINK_FAIL;\n\t\t\tnetif_carrier_on(vptr->netdev);\n\t\t} else {\n\t\t\tvptr->mii_status |= VELOCITY_LINK_FAIL;\n\t\t\tnetif_carrier_off(vptr->netdev);\n\t\t}\n\n\t\tvelocity_print_link_status(vptr);\n\t\tenable_flow_control_ability(vptr);\n\n\t\t \n\n\t\tenable_mii_autopoll(regs);\n\n\t\tif (vptr->mii_status & VELOCITY_LINK_FAIL)\n\t\t\tnetif_stop_queue(vptr->netdev);\n\t\telse\n\t\t\tnetif_wake_queue(vptr->netdev);\n\n\t}\n\tif (status & ISR_MIBFI)\n\t\tvelocity_update_hw_mibs(vptr);\n\tif (status & ISR_LSTEI)\n\t\tmac_rx_queue_wake(vptr->mac_regs);\n}\n\n \nstatic int velocity_tx_srv(struct velocity_info *vptr)\n{\n\tstruct tx_desc *td;\n\tint qnum;\n\tint full = 0;\n\tint idx;\n\tint works = 0;\n\tstruct velocity_td_info *tdinfo;\n\tstruct net_device_stats *stats = &vptr->netdev->stats;\n\n\tfor (qnum = 0; qnum < vptr->tx.numq; qnum++) {\n\t\tfor (idx = vptr->tx.tail[qnum]; vptr->tx.used[qnum] > 0;\n\t\t\tidx = (idx + 1) % vptr->options.numtx) {\n\n\t\t\t \n\t\t\ttd = &(vptr->tx.rings[qnum][idx]);\n\t\t\ttdinfo = &(vptr->tx.infos[qnum][idx]);\n\n\t\t\tif (td->tdesc0.len & OWNED_BY_NIC)\n\t\t\t\tbreak;\n\n\t\t\tif ((works++ > 15))\n\t\t\t\tbreak;\n\n\t\t\tif (td->tdesc0.TSR & TSR0_TERR) {\n\t\t\t\tstats->tx_errors++;\n\t\t\t\tstats->tx_dropped++;\n\t\t\t\tif (td->tdesc0.TSR & TSR0_CDH)\n\t\t\t\t\tstats->tx_heartbeat_errors++;\n\t\t\t\tif (td->tdesc0.TSR & TSR0_CRS)\n\t\t\t\t\tstats->tx_carrier_errors++;\n\t\t\t\tif (td->tdesc0.TSR & TSR0_ABT)\n\t\t\t\t\tstats->tx_aborted_errors++;\n\t\t\t\tif (td->tdesc0.TSR & TSR0_OWC)\n\t\t\t\t\tstats->tx_window_errors++;\n\t\t\t} else {\n\t\t\t\tstats->tx_packets++;\n\t\t\t\tstats->tx_bytes += tdinfo->skb->len;\n\t\t\t}\n\t\t\tvelocity_free_tx_buf(vptr, tdinfo, td);\n\t\t\tvptr->tx.used[qnum]--;\n\t\t}\n\t\tvptr->tx.tail[qnum] = idx;\n\n\t\tif (AVAIL_TD(vptr, qnum) < 1)\n\t\t\tfull = 1;\n\t}\n\t \n\tif (netif_queue_stopped(vptr->netdev) && (full == 0) &&\n\t    (!(vptr->mii_status & VELOCITY_LINK_FAIL))) {\n\t\tnetif_wake_queue(vptr->netdev);\n\t}\n\treturn works;\n}\n\n \nstatic inline void velocity_rx_csum(struct rx_desc *rd, struct sk_buff *skb)\n{\n\tskb_checksum_none_assert(skb);\n\n\tif (rd->rdesc1.CSM & CSM_IPKT) {\n\t\tif (rd->rdesc1.CSM & CSM_IPOK) {\n\t\t\tif ((rd->rdesc1.CSM & CSM_TCPKT) ||\n\t\t\t\t\t(rd->rdesc1.CSM & CSM_UDPKT)) {\n\t\t\t\tif (!(rd->rdesc1.CSM & CSM_TUPOK))\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t}\n\t}\n}\n\n \nstatic int velocity_rx_copy(struct sk_buff **rx_skb, int pkt_size,\n\t\t\t    struct velocity_info *vptr)\n{\n\tint ret = -1;\n\tif (pkt_size < rx_copybreak) {\n\t\tstruct sk_buff *new_skb;\n\n\t\tnew_skb = netdev_alloc_skb_ip_align(vptr->netdev, pkt_size);\n\t\tif (new_skb) {\n\t\t\tnew_skb->ip_summed = rx_skb[0]->ip_summed;\n\t\t\tskb_copy_from_linear_data(*rx_skb, new_skb->data, pkt_size);\n\t\t\t*rx_skb = new_skb;\n\t\t\tret = 0;\n\t\t}\n\n\t}\n\treturn ret;\n}\n\n \nstatic inline void velocity_iph_realign(struct velocity_info *vptr,\n\t\t\t\t\tstruct sk_buff *skb, int pkt_size)\n{\n\tif (vptr->flags & VELOCITY_FLAGS_IP_ALIGN) {\n\t\tmemmove(skb->data + 2, skb->data, pkt_size);\n\t\tskb_reserve(skb, 2);\n\t}\n}\n\n \nstatic int velocity_receive_frame(struct velocity_info *vptr, int idx)\n{\n\tstruct net_device_stats *stats = &vptr->netdev->stats;\n\tstruct velocity_rd_info *rd_info = &(vptr->rx.info[idx]);\n\tstruct rx_desc *rd = &(vptr->rx.ring[idx]);\n\tint pkt_len = le16_to_cpu(rd->rdesc0.len) & 0x3fff;\n\tstruct sk_buff *skb;\n\n\tif (unlikely(rd->rdesc0.RSR & (RSR_STP | RSR_EDP | RSR_RL))) {\n\t\tif (rd->rdesc0.RSR & (RSR_STP | RSR_EDP))\n\t\t\tnetdev_err(vptr->netdev, \"received frame spans multiple RDs\\n\");\n\t\tstats->rx_length_errors++;\n\t\treturn -EINVAL;\n\t}\n\n\tif (rd->rdesc0.RSR & RSR_MAR)\n\t\tstats->multicast++;\n\n\tskb = rd_info->skb;\n\n\tdma_sync_single_for_cpu(vptr->dev, rd_info->skb_dma,\n\t\t\t\t    vptr->rx.buf_sz, DMA_FROM_DEVICE);\n\n\tvelocity_rx_csum(rd, skb);\n\n\tif (velocity_rx_copy(&skb, pkt_len, vptr) < 0) {\n\t\tvelocity_iph_realign(vptr, skb, pkt_len);\n\t\trd_info->skb = NULL;\n\t\tdma_unmap_single(vptr->dev, rd_info->skb_dma, vptr->rx.buf_sz,\n\t\t\t\t DMA_FROM_DEVICE);\n\t} else {\n\t\tdma_sync_single_for_device(vptr->dev, rd_info->skb_dma,\n\t\t\t\t\t   vptr->rx.buf_sz, DMA_FROM_DEVICE);\n\t}\n\n\tskb_put(skb, pkt_len - 4);\n\tskb->protocol = eth_type_trans(skb, vptr->netdev);\n\n\tif (rd->rdesc0.RSR & RSR_DETAG) {\n\t\tu16 vid = swab16(le16_to_cpu(rd->rdesc1.PQTAG));\n\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);\n\t}\n\tnetif_receive_skb(skb);\n\n\tstats->rx_bytes += pkt_len;\n\tstats->rx_packets++;\n\n\treturn 0;\n}\n\n \nstatic int velocity_rx_srv(struct velocity_info *vptr, int budget_left)\n{\n\tstruct net_device_stats *stats = &vptr->netdev->stats;\n\tint rd_curr = vptr->rx.curr;\n\tint works = 0;\n\n\twhile (works < budget_left) {\n\t\tstruct rx_desc *rd = vptr->rx.ring + rd_curr;\n\n\t\tif (!vptr->rx.info[rd_curr].skb)\n\t\t\tbreak;\n\n\t\tif (rd->rdesc0.len & OWNED_BY_NIC)\n\t\t\tbreak;\n\n\t\trmb();\n\n\t\t \n\t\tif (rd->rdesc0.RSR & (RSR_RXOK | RSR_CE | RSR_RL)) {\n\t\t\tif (velocity_receive_frame(vptr, rd_curr) < 0)\n\t\t\t\tstats->rx_dropped++;\n\t\t} else {\n\t\t\tif (rd->rdesc0.RSR & RSR_CRC)\n\t\t\t\tstats->rx_crc_errors++;\n\t\t\tif (rd->rdesc0.RSR & RSR_FAE)\n\t\t\t\tstats->rx_frame_errors++;\n\n\t\t\tstats->rx_dropped++;\n\t\t}\n\n\t\trd->size |= RX_INTEN;\n\n\t\trd_curr++;\n\t\tif (rd_curr >= vptr->options.numrx)\n\t\t\trd_curr = 0;\n\t\tworks++;\n\t}\n\n\tvptr->rx.curr = rd_curr;\n\n\tif ((works > 0) && (velocity_rx_refill(vptr) > 0))\n\t\tvelocity_give_many_rx_descs(vptr);\n\n\tVAR_USED(stats);\n\treturn works;\n}\n\nstatic int velocity_poll(struct napi_struct *napi, int budget)\n{\n\tstruct velocity_info *vptr = container_of(napi,\n\t\t\tstruct velocity_info, napi);\n\tunsigned int rx_done;\n\tunsigned long flags;\n\n\t \n\trx_done = velocity_rx_srv(vptr, budget);\n\tspin_lock_irqsave(&vptr->lock, flags);\n\tvelocity_tx_srv(vptr);\n\t \n\tif (rx_done < budget) {\n\t\tnapi_complete_done(napi, rx_done);\n\t\tmac_enable_int(vptr->mac_regs);\n\t}\n\tspin_unlock_irqrestore(&vptr->lock, flags);\n\n\treturn rx_done;\n}\n\n \nstatic irqreturn_t velocity_intr(int irq, void *dev_instance)\n{\n\tstruct net_device *dev = dev_instance;\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\tu32 isr_status;\n\n\tspin_lock(&vptr->lock);\n\tisr_status = mac_read_isr(vptr->mac_regs);\n\n\t \n\tif (isr_status == 0) {\n\t\tspin_unlock(&vptr->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tmac_write_isr(vptr->mac_regs, isr_status);\n\n\tif (likely(napi_schedule_prep(&vptr->napi))) {\n\t\tmac_disable_int(vptr->mac_regs);\n\t\t__napi_schedule(&vptr->napi);\n\t}\n\n\tif (isr_status & (~(ISR_PRXI | ISR_PPRXI | ISR_PTXI | ISR_PPTXI)))\n\t\tvelocity_error(vptr, isr_status);\n\n\tspin_unlock(&vptr->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int velocity_open(struct net_device *dev)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\tint ret;\n\n\tret = velocity_init_rings(vptr, dev->mtu);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tvelocity_set_power_state(vptr, PCI_D0);\n\n\tvelocity_init_registers(vptr, VELOCITY_INIT_COLD);\n\n\tret = request_irq(dev->irq, velocity_intr, IRQF_SHARED,\n\t\t\t  dev->name, dev);\n\tif (ret < 0) {\n\t\t \n\t\tvelocity_set_power_state(vptr, PCI_D3hot);\n\t\tvelocity_free_rings(vptr);\n\t\tgoto out;\n\t}\n\n\tvelocity_give_many_rx_descs(vptr);\n\n\tmac_enable_int(vptr->mac_regs);\n\tnetif_start_queue(dev);\n\tnapi_enable(&vptr->napi);\n\tvptr->flags |= VELOCITY_FLAGS_OPENED;\nout:\n\treturn ret;\n}\n\n \nstatic void velocity_shutdown(struct velocity_info *vptr)\n{\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\tmac_disable_int(regs);\n\twritel(CR0_STOP, &regs->CR0Set);\n\twritew(0xFFFF, &regs->TDCSRClr);\n\twriteb(0xFF, &regs->RDCSRClr);\n\tsafe_disable_mii_autopoll(regs);\n\tmac_clear_isr(regs);\n}\n\n \nstatic int velocity_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\tint ret = 0;\n\n\tif (!netif_running(dev)) {\n\t\tdev->mtu = new_mtu;\n\t\tgoto out_0;\n\t}\n\n\tif (dev->mtu != new_mtu) {\n\t\tstruct velocity_info *tmp_vptr;\n\t\tunsigned long flags;\n\t\tstruct rx_info rx;\n\t\tstruct tx_info tx;\n\n\t\ttmp_vptr = kzalloc(sizeof(*tmp_vptr), GFP_KERNEL);\n\t\tif (!tmp_vptr) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_0;\n\t\t}\n\n\t\ttmp_vptr->netdev = dev;\n\t\ttmp_vptr->pdev = vptr->pdev;\n\t\ttmp_vptr->dev = vptr->dev;\n\t\ttmp_vptr->options = vptr->options;\n\t\ttmp_vptr->tx.numq = vptr->tx.numq;\n\n\t\tret = velocity_init_rings(tmp_vptr, new_mtu);\n\t\tif (ret < 0)\n\t\t\tgoto out_free_tmp_vptr_1;\n\n\t\tnapi_disable(&vptr->napi);\n\n\t\tspin_lock_irqsave(&vptr->lock, flags);\n\n\t\tnetif_stop_queue(dev);\n\t\tvelocity_shutdown(vptr);\n\n\t\trx = vptr->rx;\n\t\ttx = vptr->tx;\n\n\t\tvptr->rx = tmp_vptr->rx;\n\t\tvptr->tx = tmp_vptr->tx;\n\n\t\ttmp_vptr->rx = rx;\n\t\ttmp_vptr->tx = tx;\n\n\t\tdev->mtu = new_mtu;\n\n\t\tvelocity_init_registers(vptr, VELOCITY_INIT_COLD);\n\n\t\tvelocity_give_many_rx_descs(vptr);\n\n\t\tnapi_enable(&vptr->napi);\n\n\t\tmac_enable_int(vptr->mac_regs);\n\t\tnetif_start_queue(dev);\n\n\t\tspin_unlock_irqrestore(&vptr->lock, flags);\n\n\t\tvelocity_free_rings(tmp_vptr);\n\nout_free_tmp_vptr_1:\n\t\tkfree(tmp_vptr);\n\t}\nout_0:\n\treturn ret;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void velocity_poll_controller(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\tvelocity_intr(dev->irq, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n\n \nstatic int velocity_mii_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\tunsigned long flags;\n\tstruct mii_ioctl_data *miidata = if_mii(ifr);\n\tint err;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tmiidata->phy_id = readb(&regs->MIIADR) & 0x1f;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\t\tif (velocity_mii_read(vptr->mac_regs, miidata->reg_num & 0x1f, &(miidata->val_out)) < 0)\n\t\t\treturn -ETIMEDOUT;\n\t\tbreak;\n\tcase SIOCSMIIREG:\n\t\tspin_lock_irqsave(&vptr->lock, flags);\n\t\terr = velocity_mii_write(vptr->mac_regs, miidata->reg_num & 0x1f, miidata->val_in);\n\t\tspin_unlock_irqrestore(&vptr->lock, flags);\n\t\tcheck_connection_type(vptr->mac_regs);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n \nstatic int velocity_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\tint ret;\n\n\t \n\n\tif (!netif_running(dev))\n\t\tvelocity_set_power_state(vptr, PCI_D0);\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\t \n\tcase SIOCGMIIREG:\t \n\tcase SIOCSMIIREG:\t \n\t\tret = velocity_mii_ioctl(dev, rq, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\tif (!netif_running(dev))\n\t\tvelocity_set_power_state(vptr, PCI_D3hot);\n\n\n\treturn ret;\n}\n\n \nstatic struct net_device_stats *velocity_get_stats(struct net_device *dev)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\n\t \n\tif (!netif_running(dev))\n\t\treturn &dev->stats;\n\n\tspin_lock_irq(&vptr->lock);\n\tvelocity_update_hw_mibs(vptr);\n\tspin_unlock_irq(&vptr->lock);\n\n\tdev->stats.rx_packets = vptr->mib_counter[HW_MIB_ifRxAllPkts];\n\tdev->stats.rx_errors = vptr->mib_counter[HW_MIB_ifRxErrorPkts];\n\tdev->stats.rx_length_errors = vptr->mib_counter[HW_MIB_ifInRangeLengthErrors];\n\n\n\tdev->stats.collisions = vptr->mib_counter[HW_MIB_ifTxEtherCollisions];\n\t \n\n\n\tdev->stats.rx_crc_errors = vptr->mib_counter[HW_MIB_ifRxPktCRCE];\n\n\n\n\n\t \n\n\n\treturn &dev->stats;\n}\n\n \nstatic int velocity_close(struct net_device *dev)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\n\tnapi_disable(&vptr->napi);\n\tnetif_stop_queue(dev);\n\tvelocity_shutdown(vptr);\n\n\tif (vptr->flags & VELOCITY_FLAGS_WOL_ENABLED)\n\t\tvelocity_get_ip(vptr);\n\n\tfree_irq(dev->irq, dev);\n\n\tvelocity_free_rings(vptr);\n\n\tvptr->flags &= (~VELOCITY_FLAGS_OPENED);\n\treturn 0;\n}\n\n \nstatic netdev_tx_t velocity_xmit(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\tint qnum = 0;\n\tstruct tx_desc *td_ptr;\n\tstruct velocity_td_info *tdinfo;\n\tunsigned long flags;\n\tint pktlen;\n\tint index, prev;\n\tint i = 0;\n\n\tif (skb_padto(skb, ETH_ZLEN))\n\t\tgoto out;\n\n\t \n\tif (skb_shinfo(skb)->nr_frags > 6 && __skb_linearize(skb)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tpktlen = skb_shinfo(skb)->nr_frags == 0 ?\n\t\t\tmax_t(unsigned int, skb->len, ETH_ZLEN) :\n\t\t\t\tskb_headlen(skb);\n\n\tspin_lock_irqsave(&vptr->lock, flags);\n\n\tindex = vptr->tx.curr[qnum];\n\ttd_ptr = &(vptr->tx.rings[qnum][index]);\n\ttdinfo = &(vptr->tx.infos[qnum][index]);\n\n\ttd_ptr->tdesc1.TCR = TCR0_TIC;\n\ttd_ptr->td_buf[0].size &= ~TD_QUEUE;\n\n\t \n\ttdinfo->skb = skb;\n\ttdinfo->skb_dma[0] = dma_map_single(vptr->dev, skb->data, pktlen,\n\t\t\t\t\t\t\t\tDMA_TO_DEVICE);\n\ttd_ptr->tdesc0.len = cpu_to_le16(pktlen);\n\ttd_ptr->td_buf[0].pa_low = cpu_to_le32(tdinfo->skb_dma[0]);\n\ttd_ptr->td_buf[0].pa_high = 0;\n\ttd_ptr->td_buf[0].size = cpu_to_le16(pktlen);\n\n\t \n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\ttdinfo->skb_dma[i + 1] = skb_frag_dma_map(vptr->dev,\n\t\t\t\t\t\t\t  frag, 0,\n\t\t\t\t\t\t\t  skb_frag_size(frag),\n\t\t\t\t\t\t\t  DMA_TO_DEVICE);\n\n\t\ttd_ptr->td_buf[i + 1].pa_low = cpu_to_le32(tdinfo->skb_dma[i + 1]);\n\t\ttd_ptr->td_buf[i + 1].pa_high = 0;\n\t\ttd_ptr->td_buf[i + 1].size = cpu_to_le16(skb_frag_size(frag));\n\t}\n\ttdinfo->nskb_dma = i + 1;\n\n\ttd_ptr->tdesc1.cmd = TCPLS_NORMAL + (tdinfo->nskb_dma + 1) * 16;\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\ttd_ptr->tdesc1.vlan = cpu_to_le16(skb_vlan_tag_get(skb));\n\t\ttd_ptr->tdesc1.TCR |= TCR0_VETAG;\n\t}\n\n\t \n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tconst struct iphdr *ip = ip_hdr(skb);\n\t\tif (ip->protocol == IPPROTO_TCP)\n\t\t\ttd_ptr->tdesc1.TCR |= TCR0_TCPCK;\n\t\telse if (ip->protocol == IPPROTO_UDP)\n\t\t\ttd_ptr->tdesc1.TCR |= (TCR0_UDPCK);\n\t\ttd_ptr->tdesc1.TCR |= TCR0_IPCK;\n\t}\n\n\tprev = index - 1;\n\tif (prev < 0)\n\t\tprev = vptr->options.numtx - 1;\n\ttd_ptr->tdesc0.len |= OWNED_BY_NIC;\n\tvptr->tx.used[qnum]++;\n\tvptr->tx.curr[qnum] = (index + 1) % vptr->options.numtx;\n\n\tif (AVAIL_TD(vptr, qnum) < 1)\n\t\tnetif_stop_queue(dev);\n\n\ttd_ptr = &(vptr->tx.rings[qnum][prev]);\n\ttd_ptr->td_buf[0].size |= TD_QUEUE;\n\tmac_tx_queue_wake(vptr->mac_regs, qnum);\n\n\tspin_unlock_irqrestore(&vptr->lock, flags);\nout:\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops velocity_netdev_ops = {\n\t.ndo_open\t\t= velocity_open,\n\t.ndo_stop\t\t= velocity_close,\n\t.ndo_start_xmit\t\t= velocity_xmit,\n\t.ndo_get_stats\t\t= velocity_get_stats,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_set_rx_mode\t= velocity_set_multi,\n\t.ndo_change_mtu\t\t= velocity_change_mtu,\n\t.ndo_eth_ioctl\t\t= velocity_ioctl,\n\t.ndo_vlan_rx_add_vid\t= velocity_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= velocity_vlan_rx_kill_vid,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller = velocity_poll_controller,\n#endif\n};\n\n \nstatic void velocity_init_info(struct velocity_info *vptr,\n\t\t\t\tconst struct velocity_info_tbl *info)\n{\n\tvptr->chip_id = info->chip_id;\n\tvptr->tx.numq = info->txqueue;\n\tvptr->multicast_limit = MCAM_SIZE;\n\tspin_lock_init(&vptr->lock);\n}\n\n \nstatic int velocity_get_pci_info(struct velocity_info *vptr)\n{\n\tstruct pci_dev *pdev = vptr->pdev;\n\n\tpci_set_master(pdev);\n\n\tvptr->ioaddr = pci_resource_start(pdev, 0);\n\tvptr->memaddr = pci_resource_start(pdev, 1);\n\n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_IO)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t   \"region #0 is not an I/O resource, aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((pci_resource_flags(pdev, 1) & IORESOURCE_IO)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t   \"region #1 is an I/O resource, aborting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pci_resource_len(pdev, 1) < VELOCITY_IO_SIZE) {\n\t\tdev_err(&pdev->dev, \"region #1 is too small.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int velocity_get_platform_info(struct velocity_info *vptr)\n{\n\tstruct resource res;\n\tint ret;\n\n\tvptr->no_eeprom = of_property_read_bool(vptr->dev->of_node, \"no-eeprom\");\n\n\tret = of_address_to_resource(vptr->dev->of_node, 0, &res);\n\tif (ret) {\n\t\tdev_err(vptr->dev, \"unable to find memory address\\n\");\n\t\treturn ret;\n\t}\n\n\tvptr->memaddr = res.start;\n\n\tif (resource_size(&res) < VELOCITY_IO_SIZE) {\n\t\tdev_err(vptr->dev, \"memory region is too small.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void velocity_print_info(struct velocity_info *vptr)\n{\n\tnetdev_info(vptr->netdev, \"%s - Ethernet Address: %pM\\n\",\n\t\t    get_chip_name(vptr->chip_id), vptr->netdev->dev_addr);\n}\n\nstatic u32 velocity_get_link(struct net_device *dev)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\treturn BYTE_REG_BITS_IS_ON(PHYSR0_LINKGD, &regs->PHYSR0) ? 1 : 0;\n}\n\n \nstatic int velocity_probe(struct device *dev, int irq,\n\t\t\t   const struct velocity_info_tbl *info,\n\t\t\t   enum velocity_bus_type bustype)\n{\n\tstruct net_device *netdev;\n\tint i;\n\tstruct velocity_info *vptr;\n\tstruct mac_regs __iomem *regs;\n\tint ret = -ENOMEM;\n\tu8 addr[ETH_ALEN];\n\n\t \n\tif (velocity_nics >= MAX_UNITS) {\n\t\tdev_notice(dev, \"already found %d NICs.\\n\", velocity_nics);\n\t\treturn -ENODEV;\n\t}\n\n\tnetdev = alloc_etherdev(sizeof(struct velocity_info));\n\tif (!netdev)\n\t\tgoto out;\n\n\t \n\n\tSET_NETDEV_DEV(netdev, dev);\n\tvptr = netdev_priv(netdev);\n\n\tpr_info_once(\"%s Ver. %s\\n\", VELOCITY_FULL_DRV_NAM, VELOCITY_VERSION);\n\tpr_info_once(\"Copyright (c) 2002, 2003 VIA Networking Technologies, Inc.\\n\");\n\tpr_info_once(\"Copyright (c) 2004 Red Hat Inc.\\n\");\n\n\tnetdev->irq = irq;\n\tvptr->netdev = netdev;\n\tvptr->dev = dev;\n\n\tvelocity_init_info(vptr, info);\n\n\tif (bustype == BUS_PCI) {\n\t\tvptr->pdev = to_pci_dev(dev);\n\n\t\tret = velocity_get_pci_info(vptr);\n\t\tif (ret < 0)\n\t\t\tgoto err_free_dev;\n\t} else {\n\t\tvptr->pdev = NULL;\n\t\tret = velocity_get_platform_info(vptr);\n\t\tif (ret < 0)\n\t\t\tgoto err_free_dev;\n\t}\n\n\tregs = ioremap(vptr->memaddr, VELOCITY_IO_SIZE);\n\tif (regs == NULL) {\n\t\tret = -EIO;\n\t\tgoto err_free_dev;\n\t}\n\n\tvptr->mac_regs = regs;\n\tvptr->rev_id = readb(&regs->rev_id);\n\n\tmac_wol_reset(regs);\n\n\tfor (i = 0; i < 6; i++)\n\t\taddr[i] = readb(&regs->PAR[i]);\n\teth_hw_addr_set(netdev, addr);\n\n\n\tvelocity_get_options(&vptr->options, velocity_nics);\n\n\t \n\n\tvptr->options.flags &= info->flags;\n\n\t \n\n\tvptr->flags = vptr->options.flags | (info->flags & 0xFF000000UL);\n\n\tvptr->wol_opts = vptr->options.wol_opts;\n\tvptr->flags |= VELOCITY_FLAGS_WOL_ENABLED;\n\n\tvptr->phy_id = MII_GET_PHY_ID(vptr->mac_regs);\n\n\tnetdev->netdev_ops = &velocity_netdev_ops;\n\tnetdev->ethtool_ops = &velocity_ethtool_ops;\n\tnetif_napi_add(netdev, &vptr->napi, velocity_poll);\n\n\tnetdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_SG |\n\t\t\t   NETIF_F_HW_VLAN_CTAG_TX;\n\tnetdev->features |= NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\tNETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\tNETIF_F_IP_CSUM;\n\n\t \n\tnetdev->min_mtu = VELOCITY_MIN_MTU;\n\tnetdev->max_mtu = VELOCITY_MAX_MTU;\n\n\tret = register_netdev(netdev);\n\tif (ret < 0)\n\t\tgoto err_iounmap;\n\n\tif (!velocity_get_link(netdev)) {\n\t\tnetif_carrier_off(netdev);\n\t\tvptr->mii_status |= VELOCITY_LINK_FAIL;\n\t}\n\n\tvelocity_print_info(vptr);\n\tdev_set_drvdata(vptr->dev, netdev);\n\n\t \n\n\tvelocity_set_power_state(vptr, PCI_D3hot);\n\tvelocity_nics++;\nout:\n\treturn ret;\n\nerr_iounmap:\n\tnetif_napi_del(&vptr->napi);\n\tiounmap(regs);\nerr_free_dev:\n\tfree_netdev(netdev);\n\tgoto out;\n}\n\n \nstatic int velocity_remove(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct velocity_info *vptr = netdev_priv(netdev);\n\n\tunregister_netdev(netdev);\n\tnetif_napi_del(&vptr->napi);\n\tiounmap(vptr->mac_regs);\n\tfree_netdev(netdev);\n\tvelocity_nics--;\n\n\treturn 0;\n}\n\nstatic int velocity_pci_probe(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *ent)\n{\n\tconst struct velocity_info_tbl *info =\n\t\t\t\t\t&chip_info_table[ent->driver_data];\n\tint ret;\n\n\tret = pci_enable_device(pdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pci_request_regions(pdev, VELOCITY_NAME);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"No PCI resources.\\n\");\n\t\tgoto fail1;\n\t}\n\n\tret = velocity_probe(&pdev->dev, pdev->irq, info, BUS_PCI);\n\tif (ret == 0)\n\t\treturn 0;\n\n\tpci_release_regions(pdev);\nfail1:\n\tpci_disable_device(pdev);\n\treturn ret;\n}\n\nstatic void velocity_pci_remove(struct pci_dev *pdev)\n{\n\tvelocity_remove(&pdev->dev);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic int velocity_platform_probe(struct platform_device *pdev)\n{\n\tconst struct velocity_info_tbl *info;\n\tint irq;\n\n\tinfo = of_device_get_match_data(&pdev->dev);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tirq = irq_of_parse_and_map(pdev->dev.of_node, 0);\n\tif (!irq)\n\t\treturn -EINVAL;\n\n\treturn velocity_probe(&pdev->dev, irq, info, BUS_PLATFORM);\n}\n\nstatic int velocity_platform_remove(struct platform_device *pdev)\n{\n\tvelocity_remove(&pdev->dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic u16 wol_calc_crc(int size, u8 *pattern, u8 *mask_pattern)\n{\n\tu16 crc = 0xFFFF;\n\tu8 mask;\n\tint i, j;\n\n\tfor (i = 0; i < size; i++) {\n\t\tmask = mask_pattern[i];\n\n\t\t \n\t\tif (mask == 0x00)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif ((mask & 0x01) == 0) {\n\t\t\t\tmask >>= 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmask >>= 1;\n\t\t\tcrc = crc_ccitt(crc, &(pattern[i * 8 + j]), 1);\n\t\t}\n\t}\n\t \n\tcrc = ~crc;\n\treturn bitrev32(crc) >> 16;\n}\n\n \nstatic int velocity_set_wol(struct velocity_info *vptr)\n{\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\tenum speed_opt spd_dpx = vptr->options.spd_dpx;\n\tstatic u8 buf[256];\n\tint i;\n\n\tstatic u32 mask_pattern[2][4] = {\n\t\t{0x00203000, 0x000003C0, 0x00000000, 0x0000000},  \n\t\t{0xfffff000, 0xffffffff, 0xffffffff, 0x000ffff}\t  \n\t};\n\n\twritew(0xFFFF, &regs->WOLCRClr);\n\twriteb(WOLCFG_SAB | WOLCFG_SAM, &regs->WOLCFGSet);\n\twritew(WOLCR_MAGIC_EN, &regs->WOLCRSet);\n\n\t \n\n\tif (vptr->wol_opts & VELOCITY_WOL_UCAST)\n\t\twritew(WOLCR_UNICAST_EN, &regs->WOLCRSet);\n\n\tif (vptr->wol_opts & VELOCITY_WOL_ARP) {\n\t\tstruct arp_packet *arp = (struct arp_packet *) buf;\n\t\tu16 crc;\n\t\tmemset(buf, 0, sizeof(struct arp_packet) + 7);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\twritel(mask_pattern[0][i], &regs->ByteMask[0][i]);\n\n\t\tarp->type = htons(ETH_P_ARP);\n\t\tarp->ar_op = htons(1);\n\n\t\tmemcpy(arp->ar_tip, vptr->ip_addr, 4);\n\n\t\tcrc = wol_calc_crc((sizeof(struct arp_packet) + 7) / 8, buf,\n\t\t\t\t(u8 *) & mask_pattern[0][0]);\n\n\t\twritew(crc, &regs->PatternCRC[0]);\n\t\twritew(WOLCR_ARP_EN, &regs->WOLCRSet);\n\t}\n\n\tBYTE_REG_BITS_ON(PWCFG_WOLTYPE, &regs->PWCFGSet);\n\tBYTE_REG_BITS_ON(PWCFG_LEGACY_WOLEN, &regs->PWCFGSet);\n\n\twritew(0x0FFF, &regs->WOLSRClr);\n\n\tif (spd_dpx == SPD_DPX_1000_FULL)\n\t\tgoto mac_done;\n\n\tif (spd_dpx != SPD_DPX_AUTO)\n\t\tgoto advertise_done;\n\n\tif (vptr->mii_status & VELOCITY_AUTONEG_ENABLE) {\n\t\tif (PHYID_GET_PHY_ID(vptr->phy_id) == PHYID_CICADA_CS8201)\n\t\t\tMII_REG_BITS_ON(AUXCR_MDPPS, MII_NCONFIG, vptr->mac_regs);\n\n\t\tMII_REG_BITS_OFF(ADVERTISE_1000FULL | ADVERTISE_1000HALF, MII_CTRL1000, vptr->mac_regs);\n\t}\n\n\tif (vptr->mii_status & VELOCITY_SPEED_1000)\n\t\tMII_REG_BITS_ON(BMCR_ANRESTART, MII_BMCR, vptr->mac_regs);\n\nadvertise_done:\n\tBYTE_REG_BITS_ON(CHIPGCR_FCMODE, &regs->CHIPGCR);\n\n\t{\n\t\tu8 GCR;\n\t\tGCR = readb(&regs->CHIPGCR);\n\t\tGCR = (GCR & ~CHIPGCR_FCGMII) | CHIPGCR_FCFDX;\n\t\twriteb(GCR, &regs->CHIPGCR);\n\t}\n\nmac_done:\n\tBYTE_REG_BITS_OFF(ISR_PWEI, &regs->ISR);\n\t \n\tBYTE_REG_BITS_ON(STICKHW_SWPTAG, &regs->STICKHW);\n\t \n\tBYTE_REG_BITS_ON((STICKHW_DS1 | STICKHW_DS0), &regs->STICKHW);\n\n\treturn 0;\n}\n\n \nstatic void velocity_save_context(struct velocity_info *vptr, struct velocity_context *context)\n{\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\tu16 i;\n\tu8 __iomem *ptr = (u8 __iomem *)regs;\n\n\tfor (i = MAC_REG_PAR; i < MAC_REG_CR0_CLR; i += 4)\n\t\t*((u32 *) (context->mac_reg + i)) = readl(ptr + i);\n\n\tfor (i = MAC_REG_MAR; i < MAC_REG_TDCSR_CLR; i += 4)\n\t\t*((u32 *) (context->mac_reg + i)) = readl(ptr + i);\n\n\tfor (i = MAC_REG_RDBASE_LO; i < MAC_REG_FIFO_TEST0; i += 4)\n\t\t*((u32 *) (context->mac_reg + i)) = readl(ptr + i);\n\n}\n\nstatic int velocity_suspend(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct velocity_info *vptr = netdev_priv(netdev);\n\tunsigned long flags;\n\n\tif (!netif_running(vptr->netdev))\n\t\treturn 0;\n\n\tnetif_device_detach(vptr->netdev);\n\n\tspin_lock_irqsave(&vptr->lock, flags);\n\tif (vptr->pdev)\n\t\tpci_save_state(vptr->pdev);\n\n\tif (vptr->flags & VELOCITY_FLAGS_WOL_ENABLED) {\n\t\tvelocity_get_ip(vptr);\n\t\tvelocity_save_context(vptr, &vptr->context);\n\t\tvelocity_shutdown(vptr);\n\t\tvelocity_set_wol(vptr);\n\t\tif (vptr->pdev)\n\t\t\tpci_enable_wake(vptr->pdev, PCI_D3hot, 1);\n\t\tvelocity_set_power_state(vptr, PCI_D3hot);\n\t} else {\n\t\tvelocity_save_context(vptr, &vptr->context);\n\t\tvelocity_shutdown(vptr);\n\t\tif (vptr->pdev)\n\t\t\tpci_disable_device(vptr->pdev);\n\t\tvelocity_set_power_state(vptr, PCI_D3hot);\n\t}\n\n\tspin_unlock_irqrestore(&vptr->lock, flags);\n\treturn 0;\n}\n\n \nstatic void velocity_restore_context(struct velocity_info *vptr, struct velocity_context *context)\n{\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\tint i;\n\tu8 __iomem *ptr = (u8 __iomem *)regs;\n\n\tfor (i = MAC_REG_PAR; i < MAC_REG_CR0_SET; i += 4)\n\t\twritel(*((u32 *) (context->mac_reg + i)), ptr + i);\n\n\t \n\tfor (i = MAC_REG_CR1_SET; i < MAC_REG_CR0_CLR; i++) {\n\t\t \n\t\twriteb(~(*((u8 *) (context->mac_reg + i))), ptr + i + 4);\n\t\t \n\t\twriteb(*((u8 *) (context->mac_reg + i)), ptr + i);\n\t}\n\n\tfor (i = MAC_REG_MAR; i < MAC_REG_IMR; i += 4)\n\t\twritel(*((u32 *) (context->mac_reg + i)), ptr + i);\n\n\tfor (i = MAC_REG_RDBASE_LO; i < MAC_REG_FIFO_TEST0; i += 4)\n\t\twritel(*((u32 *) (context->mac_reg + i)), ptr + i);\n\n\tfor (i = MAC_REG_TDCSR_SET; i <= MAC_REG_RDCSR_SET; i++)\n\t\twriteb(*((u8 *) (context->mac_reg + i)), ptr + i);\n}\n\nstatic int velocity_resume(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct velocity_info *vptr = netdev_priv(netdev);\n\tunsigned long flags;\n\tint i;\n\n\tif (!netif_running(vptr->netdev))\n\t\treturn 0;\n\n\tvelocity_set_power_state(vptr, PCI_D0);\n\n\tif (vptr->pdev) {\n\t\tpci_enable_wake(vptr->pdev, PCI_D0, 0);\n\t\tpci_restore_state(vptr->pdev);\n\t}\n\n\tmac_wol_reset(vptr->mac_regs);\n\n\tspin_lock_irqsave(&vptr->lock, flags);\n\tvelocity_restore_context(vptr, &vptr->context);\n\tvelocity_init_registers(vptr, VELOCITY_INIT_WOL);\n\tmac_disable_int(vptr->mac_regs);\n\n\tvelocity_tx_srv(vptr);\n\n\tfor (i = 0; i < vptr->tx.numq; i++) {\n\t\tif (vptr->tx.used[i])\n\t\t\tmac_tx_queue_wake(vptr->mac_regs, i);\n\t}\n\n\tmac_enable_int(vptr->mac_regs);\n\tspin_unlock_irqrestore(&vptr->lock, flags);\n\tnetif_device_attach(vptr->netdev);\n\n\treturn 0;\n}\n#endif\t \n\nstatic SIMPLE_DEV_PM_OPS(velocity_pm_ops, velocity_suspend, velocity_resume);\n\n \nstatic struct pci_driver velocity_pci_driver = {\n\t.name\t\t= VELOCITY_NAME,\n\t.id_table\t= velocity_pci_id_table,\n\t.probe\t\t= velocity_pci_probe,\n\t.remove\t\t= velocity_pci_remove,\n\t.driver = {\n\t\t.pm = &velocity_pm_ops,\n\t},\n};\n\nstatic struct platform_driver velocity_platform_driver = {\n\t.probe\t\t= velocity_platform_probe,\n\t.remove\t\t= velocity_platform_remove,\n\t.driver = {\n\t\t.name = \"via-velocity\",\n\t\t.of_match_table = velocity_of_ids,\n\t\t.pm = &velocity_pm_ops,\n\t},\n};\n\n \nstatic int velocity_ethtool_up(struct net_device *dev)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\n\tif (vptr->ethtool_ops_nesting == U32_MAX)\n\t\treturn -EBUSY;\n\tif (!vptr->ethtool_ops_nesting++ && !netif_running(dev))\n\t\tvelocity_set_power_state(vptr, PCI_D0);\n\treturn 0;\n}\n\n \nstatic void velocity_ethtool_down(struct net_device *dev)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\n\tif (!--vptr->ethtool_ops_nesting && !netif_running(dev))\n\t\tvelocity_set_power_state(vptr, PCI_D3hot);\n}\n\nstatic int velocity_get_link_ksettings(struct net_device *dev,\n\t\t\t\t       struct ethtool_link_ksettings *cmd)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\tstruct mac_regs __iomem *regs = vptr->mac_regs;\n\tu32 status;\n\tu32 supported, advertising;\n\n\tstatus = check_connection_type(vptr->mac_regs);\n\n\tsupported = SUPPORTED_TP |\n\t\t\tSUPPORTED_Autoneg |\n\t\t\tSUPPORTED_10baseT_Half |\n\t\t\tSUPPORTED_10baseT_Full |\n\t\t\tSUPPORTED_100baseT_Half |\n\t\t\tSUPPORTED_100baseT_Full |\n\t\t\tSUPPORTED_1000baseT_Half |\n\t\t\tSUPPORTED_1000baseT_Full;\n\n\tadvertising = ADVERTISED_TP | ADVERTISED_Autoneg;\n\tif (vptr->options.spd_dpx == SPD_DPX_AUTO) {\n\t\tadvertising |=\n\t\t\tADVERTISED_10baseT_Half |\n\t\t\tADVERTISED_10baseT_Full |\n\t\t\tADVERTISED_100baseT_Half |\n\t\t\tADVERTISED_100baseT_Full |\n\t\t\tADVERTISED_1000baseT_Half |\n\t\t\tADVERTISED_1000baseT_Full;\n\t} else {\n\t\tswitch (vptr->options.spd_dpx) {\n\t\tcase SPD_DPX_1000_FULL:\n\t\t\tadvertising |= ADVERTISED_1000baseT_Full;\n\t\t\tbreak;\n\t\tcase SPD_DPX_100_HALF:\n\t\t\tadvertising |= ADVERTISED_100baseT_Half;\n\t\t\tbreak;\n\t\tcase SPD_DPX_100_FULL:\n\t\t\tadvertising |= ADVERTISED_100baseT_Full;\n\t\t\tbreak;\n\t\tcase SPD_DPX_10_HALF:\n\t\t\tadvertising |= ADVERTISED_10baseT_Half;\n\t\t\tbreak;\n\t\tcase SPD_DPX_10_FULL:\n\t\t\tadvertising |= ADVERTISED_10baseT_Full;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (status & VELOCITY_SPEED_1000)\n\t\tcmd->base.speed = SPEED_1000;\n\telse if (status & VELOCITY_SPEED_100)\n\t\tcmd->base.speed = SPEED_100;\n\telse\n\t\tcmd->base.speed = SPEED_10;\n\n\tcmd->base.autoneg = (status & VELOCITY_AUTONEG_ENABLE) ?\n\t\tAUTONEG_ENABLE : AUTONEG_DISABLE;\n\tcmd->base.port = PORT_TP;\n\tcmd->base.phy_address = readb(&regs->MIIADR) & 0x1F;\n\n\tif (status & VELOCITY_DUPLEX_FULL)\n\t\tcmd->base.duplex = DUPLEX_FULL;\n\telse\n\t\tcmd->base.duplex = DUPLEX_HALF;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int velocity_set_link_ksettings(struct net_device *dev,\n\t\t\t\t       const struct ethtool_link_ksettings *cmd)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\tu32 speed = cmd->base.speed;\n\tu32 curr_status;\n\tu32 new_status = 0;\n\tint ret = 0;\n\n\tcurr_status = check_connection_type(vptr->mac_regs);\n\tcurr_status &= (~VELOCITY_LINK_FAIL);\n\n\tnew_status |= ((cmd->base.autoneg) ? VELOCITY_AUTONEG_ENABLE : 0);\n\tnew_status |= ((speed == SPEED_1000) ? VELOCITY_SPEED_1000 : 0);\n\tnew_status |= ((speed == SPEED_100) ? VELOCITY_SPEED_100 : 0);\n\tnew_status |= ((speed == SPEED_10) ? VELOCITY_SPEED_10 : 0);\n\tnew_status |= ((cmd->base.duplex == DUPLEX_FULL) ?\n\t\t       VELOCITY_DUPLEX_FULL : 0);\n\n\tif ((new_status & VELOCITY_AUTONEG_ENABLE) &&\n\t    (new_status != (curr_status | VELOCITY_AUTONEG_ENABLE))) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tenum speed_opt spd_dpx;\n\n\t\tif (new_status & VELOCITY_AUTONEG_ENABLE)\n\t\t\tspd_dpx = SPD_DPX_AUTO;\n\t\telse if ((new_status & VELOCITY_SPEED_1000) &&\n\t\t\t (new_status & VELOCITY_DUPLEX_FULL)) {\n\t\t\tspd_dpx = SPD_DPX_1000_FULL;\n\t\t} else if (new_status & VELOCITY_SPEED_100)\n\t\t\tspd_dpx = (new_status & VELOCITY_DUPLEX_FULL) ?\n\t\t\t\tSPD_DPX_100_FULL : SPD_DPX_100_HALF;\n\t\telse if (new_status & VELOCITY_SPEED_10)\n\t\t\tspd_dpx = (new_status & VELOCITY_DUPLEX_FULL) ?\n\t\t\t\tSPD_DPX_10_FULL : SPD_DPX_10_HALF;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tvptr->options.spd_dpx = spd_dpx;\n\n\t\tvelocity_set_media_mode(vptr, new_status);\n\t}\n\n\treturn ret;\n}\n\nstatic void velocity_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\n\tstrscpy(info->driver, VELOCITY_NAME, sizeof(info->driver));\n\tstrscpy(info->version, VELOCITY_VERSION, sizeof(info->version));\n\tif (vptr->pdev)\n\t\tstrscpy(info->bus_info, pci_name(vptr->pdev),\n\t\t\t\t\t\tsizeof(info->bus_info));\n\telse\n\t\tstrscpy(info->bus_info, \"platform\", sizeof(info->bus_info));\n}\n\nstatic void velocity_ethtool_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\twol->supported = WAKE_PHY | WAKE_MAGIC | WAKE_UCAST | WAKE_ARP;\n\twol->wolopts |= WAKE_MAGIC;\n\t \n\tif (vptr->wol_opts & VELOCITY_WOL_UCAST)\n\t\twol->wolopts |= WAKE_UCAST;\n\tif (vptr->wol_opts & VELOCITY_WOL_ARP)\n\t\twol->wolopts |= WAKE_ARP;\n\tmemcpy(&wol->sopass, vptr->wol_passwd, 6);\n}\n\nstatic int velocity_ethtool_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\n\tif (!(wol->wolopts & (WAKE_PHY | WAKE_MAGIC | WAKE_UCAST | WAKE_ARP)))\n\t\treturn -EFAULT;\n\tvptr->wol_opts = VELOCITY_WOL_MAGIC;\n\n\t \n\n\tif (wol->wolopts & WAKE_MAGIC) {\n\t\tvptr->wol_opts |= VELOCITY_WOL_MAGIC;\n\t\tvptr->flags |= VELOCITY_FLAGS_WOL_ENABLED;\n\t}\n\tif (wol->wolopts & WAKE_UCAST) {\n\t\tvptr->wol_opts |= VELOCITY_WOL_UCAST;\n\t\tvptr->flags |= VELOCITY_FLAGS_WOL_ENABLED;\n\t}\n\tif (wol->wolopts & WAKE_ARP) {\n\t\tvptr->wol_opts |= VELOCITY_WOL_ARP;\n\t\tvptr->flags |= VELOCITY_FLAGS_WOL_ENABLED;\n\t}\n\tmemcpy(vptr->wol_passwd, wol->sopass, 6);\n\treturn 0;\n}\n\nstatic int get_pending_timer_val(int val)\n{\n\tint mult_bits = val >> 6;\n\tint mult = 1;\n\n\tswitch (mult_bits)\n\t{\n\tcase 1:\n\t\tmult = 4; break;\n\tcase 2:\n\t\tmult = 16; break;\n\tcase 3:\n\t\tmult = 64; break;\n\tcase 0:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn (val & 0x3f) * mult;\n}\n\nstatic void set_pending_timer_val(int *val, u32 us)\n{\n\tu8 mult = 0;\n\tu8 shift = 0;\n\n\tif (us >= 0x3f) {\n\t\tmult = 1;  \n\t\tshift = 2;\n\t}\n\tif (us >= 0x3f * 4) {\n\t\tmult = 2;  \n\t\tshift = 4;\n\t}\n\tif (us >= 0x3f * 16) {\n\t\tmult = 3;  \n\t\tshift = 6;\n\t}\n\n\t*val = (mult << 6) | ((us >> shift) & 0x3f);\n}\n\n\nstatic int velocity_get_coalesce(struct net_device *dev,\n\t\t\t\t struct ethtool_coalesce *ecmd,\n\t\t\t\t struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\n\tecmd->tx_max_coalesced_frames = vptr->options.tx_intsup;\n\tecmd->rx_max_coalesced_frames = vptr->options.rx_intsup;\n\n\tecmd->rx_coalesce_usecs = get_pending_timer_val(vptr->options.rxqueue_timer);\n\tecmd->tx_coalesce_usecs = get_pending_timer_val(vptr->options.txqueue_timer);\n\n\treturn 0;\n}\n\nstatic int velocity_set_coalesce(struct net_device *dev,\n\t\t\t\t struct ethtool_coalesce *ecmd,\n\t\t\t\t struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\tint max_us = 0x3f * 64;\n\tunsigned long flags;\n\n\t \n\tif (ecmd->tx_coalesce_usecs > max_us)\n\t\treturn -EINVAL;\n\tif (ecmd->rx_coalesce_usecs > max_us)\n\t\treturn -EINVAL;\n\n\tif (ecmd->tx_max_coalesced_frames > 0xff)\n\t\treturn -EINVAL;\n\tif (ecmd->rx_max_coalesced_frames > 0xff)\n\t\treturn -EINVAL;\n\n\tvptr->options.rx_intsup = ecmd->rx_max_coalesced_frames;\n\tvptr->options.tx_intsup = ecmd->tx_max_coalesced_frames;\n\n\tset_pending_timer_val(&vptr->options.rxqueue_timer,\n\t\t\tecmd->rx_coalesce_usecs);\n\tset_pending_timer_val(&vptr->options.txqueue_timer,\n\t\t\tecmd->tx_coalesce_usecs);\n\n\t \n\tspin_lock_irqsave(&vptr->lock, flags);\n\tmac_disable_int(vptr->mac_regs);\n\tsetup_adaptive_interrupts(vptr);\n\tsetup_queue_timers(vptr);\n\n\tmac_write_int_mask(vptr->int_mask, vptr->mac_regs);\n\tmac_clear_isr(vptr->mac_regs);\n\tmac_enable_int(vptr->mac_regs);\n\tspin_unlock_irqrestore(&vptr->lock, flags);\n\n\treturn 0;\n}\n\nstatic const char velocity_gstrings[][ETH_GSTRING_LEN] = {\n\t\"rx_all\",\n\t\"rx_ok\",\n\t\"tx_ok\",\n\t\"rx_error\",\n\t\"rx_runt_ok\",\n\t\"rx_runt_err\",\n\t\"rx_64\",\n\t\"tx_64\",\n\t\"rx_65_to_127\",\n\t\"tx_65_to_127\",\n\t\"rx_128_to_255\",\n\t\"tx_128_to_255\",\n\t\"rx_256_to_511\",\n\t\"tx_256_to_511\",\n\t\"rx_512_to_1023\",\n\t\"tx_512_to_1023\",\n\t\"rx_1024_to_1518\",\n\t\"tx_1024_to_1518\",\n\t\"tx_ether_collisions\",\n\t\"rx_crc_errors\",\n\t\"rx_jumbo\",\n\t\"tx_jumbo\",\n\t\"rx_mac_control_frames\",\n\t\"tx_mac_control_frames\",\n\t\"rx_frame_alignment_errors\",\n\t\"rx_long_ok\",\n\t\"rx_long_err\",\n\t\"tx_sqe_errors\",\n\t\"rx_no_buf\",\n\t\"rx_symbol_errors\",\n\t\"in_range_length_errors\",\n\t\"late_collisions\"\n};\n\nstatic void velocity_get_strings(struct net_device *dev, u32 sset, u8 *data)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(data, *velocity_gstrings, sizeof(velocity_gstrings));\n\t\tbreak;\n\t}\n}\n\nstatic int velocity_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(velocity_gstrings);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void velocity_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t       struct ethtool_stats *stats, u64 *data)\n{\n\tif (netif_running(dev)) {\n\t\tstruct velocity_info *vptr = netdev_priv(dev);\n\t\tu32 *p = vptr->mib_counter;\n\t\tint i;\n\n\t\tspin_lock_irq(&vptr->lock);\n\t\tvelocity_update_hw_mibs(vptr);\n\t\tspin_unlock_irq(&vptr->lock);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(velocity_gstrings); i++)\n\t\t\t*data++ = *p++;\n\t}\n}\n\nstatic const struct ethtool_ops velocity_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES,\n\t.get_drvinfo\t\t= velocity_get_drvinfo,\n\t.get_wol\t\t= velocity_ethtool_get_wol,\n\t.set_wol\t\t= velocity_ethtool_set_wol,\n\t.get_link\t\t= velocity_get_link,\n\t.get_strings\t\t= velocity_get_strings,\n\t.get_sset_count\t\t= velocity_get_sset_count,\n\t.get_ethtool_stats\t= velocity_get_ethtool_stats,\n\t.get_coalesce\t\t= velocity_get_coalesce,\n\t.set_coalesce\t\t= velocity_set_coalesce,\n\t.begin\t\t\t= velocity_ethtool_up,\n\t.complete\t\t= velocity_ethtool_down,\n\t.get_link_ksettings\t= velocity_get_link_ksettings,\n\t.set_link_ksettings\t= velocity_set_link_ksettings,\n};\n\n#if defined(CONFIG_PM) && defined(CONFIG_INET)\nstatic int velocity_netdev_event(struct notifier_block *nb, unsigned long notification, void *ptr)\n{\n\tstruct in_ifaddr *ifa = ptr;\n\tstruct net_device *dev = ifa->ifa_dev->dev;\n\n\tif (dev_net(dev) == &init_net &&\n\t    dev->netdev_ops == &velocity_netdev_ops)\n\t\tvelocity_get_ip(netdev_priv(dev));\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block velocity_inetaddr_notifier = {\n\t.notifier_call\t= velocity_netdev_event,\n};\n\nstatic void velocity_register_notifier(void)\n{\n\tregister_inetaddr_notifier(&velocity_inetaddr_notifier);\n}\n\nstatic void velocity_unregister_notifier(void)\n{\n\tunregister_inetaddr_notifier(&velocity_inetaddr_notifier);\n}\n\n#else\n\n#define velocity_register_notifier()\tdo {} while (0)\n#define velocity_unregister_notifier()\tdo {} while (0)\n\n#endif\t \n\n \nstatic int __init velocity_init_module(void)\n{\n\tint ret_pci, ret_platform;\n\n\tvelocity_register_notifier();\n\n\tret_pci = pci_register_driver(&velocity_pci_driver);\n\tret_platform = platform_driver_register(&velocity_platform_driver);\n\n\t \n\tif ((ret_pci < 0) && (ret_platform < 0)) {\n\t\tvelocity_unregister_notifier();\n\t\treturn ret_pci;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void __exit velocity_cleanup_module(void)\n{\n\tvelocity_unregister_notifier();\n\n\tpci_unregister_driver(&velocity_pci_driver);\n\tplatform_driver_unregister(&velocity_platform_driver);\n}\n\nmodule_init(velocity_init_module);\nmodule_exit(velocity_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}