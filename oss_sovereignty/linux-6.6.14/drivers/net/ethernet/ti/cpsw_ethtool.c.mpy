{
  "module_name": "cpsw_ethtool.c",
  "hash_id": "d331ac025071ff488178785d2fb169ce71d81757550360c714df4fc7824a5ad9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/cpsw_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/kmemleak.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/net_tstamp.h>\n#include <linux/phy.h>\n#include <linux/pm_runtime.h>\n#include <linux/skbuff.h>\n\n#include \"cpsw.h\"\n#include \"cpts.h\"\n#include \"cpsw_ale.h\"\n#include \"cpsw_priv.h\"\n#include \"davinci_cpdma.h\"\n\nstruct cpsw_hw_stats {\n\tu32\trxgoodframes;\n\tu32\trxbroadcastframes;\n\tu32\trxmulticastframes;\n\tu32\trxpauseframes;\n\tu32\trxcrcerrors;\n\tu32\trxaligncodeerrors;\n\tu32\trxoversizedframes;\n\tu32\trxjabberframes;\n\tu32\trxundersizedframes;\n\tu32\trxfragments;\n\tu32\t__pad_0[2];\n\tu32\trxoctets;\n\tu32\ttxgoodframes;\n\tu32\ttxbroadcastframes;\n\tu32\ttxmulticastframes;\n\tu32\ttxpauseframes;\n\tu32\ttxdeferredframes;\n\tu32\ttxcollisionframes;\n\tu32\ttxsinglecollframes;\n\tu32\ttxmultcollframes;\n\tu32\ttxexcessivecollisions;\n\tu32\ttxlatecollisions;\n\tu32\ttxunderrun;\n\tu32\ttxcarriersenseerrors;\n\tu32\ttxoctets;\n\tu32\toctetframes64;\n\tu32\toctetframes65t127;\n\tu32\toctetframes128t255;\n\tu32\toctetframes256t511;\n\tu32\toctetframes512t1023;\n\tu32\toctetframes1024tup;\n\tu32\tnetoctets;\n\tu32\trxsofoverruns;\n\tu32\trxmofoverruns;\n\tu32\trxdmaoverruns;\n};\n\nstruct cpsw_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint type;\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\nenum {\n\tCPSW_STATS,\n\tCPDMA_RX_STATS,\n\tCPDMA_TX_STATS,\n};\n\n#define CPSW_STAT(m)\t\tCPSW_STATS,\t\t\t\t\\\n\t\t\t\tsizeof_field(struct cpsw_hw_stats, m), \\\n\t\t\t\toffsetof(struct cpsw_hw_stats, m)\n#define CPDMA_RX_STAT(m)\tCPDMA_RX_STATS,\t\t\t\t   \\\n\t\t\t\tsizeof_field(struct cpdma_chan_stats, m), \\\n\t\t\t\toffsetof(struct cpdma_chan_stats, m)\n#define CPDMA_TX_STAT(m)\tCPDMA_TX_STATS,\t\t\t\t   \\\n\t\t\t\tsizeof_field(struct cpdma_chan_stats, m), \\\n\t\t\t\toffsetof(struct cpdma_chan_stats, m)\n\nstatic const struct cpsw_stats cpsw_gstrings_stats[] = {\n\t{ \"Good Rx Frames\", CPSW_STAT(rxgoodframes) },\n\t{ \"Broadcast Rx Frames\", CPSW_STAT(rxbroadcastframes) },\n\t{ \"Multicast Rx Frames\", CPSW_STAT(rxmulticastframes) },\n\t{ \"Pause Rx Frames\", CPSW_STAT(rxpauseframes) },\n\t{ \"Rx CRC Errors\", CPSW_STAT(rxcrcerrors) },\n\t{ \"Rx Align/Code Errors\", CPSW_STAT(rxaligncodeerrors) },\n\t{ \"Oversize Rx Frames\", CPSW_STAT(rxoversizedframes) },\n\t{ \"Rx Jabbers\", CPSW_STAT(rxjabberframes) },\n\t{ \"Undersize (Short) Rx Frames\", CPSW_STAT(rxundersizedframes) },\n\t{ \"Rx Fragments\", CPSW_STAT(rxfragments) },\n\t{ \"Rx Octets\", CPSW_STAT(rxoctets) },\n\t{ \"Good Tx Frames\", CPSW_STAT(txgoodframes) },\n\t{ \"Broadcast Tx Frames\", CPSW_STAT(txbroadcastframes) },\n\t{ \"Multicast Tx Frames\", CPSW_STAT(txmulticastframes) },\n\t{ \"Pause Tx Frames\", CPSW_STAT(txpauseframes) },\n\t{ \"Deferred Tx Frames\", CPSW_STAT(txdeferredframes) },\n\t{ \"Collisions\", CPSW_STAT(txcollisionframes) },\n\t{ \"Single Collision Tx Frames\", CPSW_STAT(txsinglecollframes) },\n\t{ \"Multiple Collision Tx Frames\", CPSW_STAT(txmultcollframes) },\n\t{ \"Excessive Collisions\", CPSW_STAT(txexcessivecollisions) },\n\t{ \"Late Collisions\", CPSW_STAT(txlatecollisions) },\n\t{ \"Tx Underrun\", CPSW_STAT(txunderrun) },\n\t{ \"Carrier Sense Errors\", CPSW_STAT(txcarriersenseerrors) },\n\t{ \"Tx Octets\", CPSW_STAT(txoctets) },\n\t{ \"Rx + Tx 64 Octet Frames\", CPSW_STAT(octetframes64) },\n\t{ \"Rx + Tx 65-127 Octet Frames\", CPSW_STAT(octetframes65t127) },\n\t{ \"Rx + Tx 128-255 Octet Frames\", CPSW_STAT(octetframes128t255) },\n\t{ \"Rx + Tx 256-511 Octet Frames\", CPSW_STAT(octetframes256t511) },\n\t{ \"Rx + Tx 512-1023 Octet Frames\", CPSW_STAT(octetframes512t1023) },\n\t{ \"Rx + Tx 1024-Up Octet Frames\", CPSW_STAT(octetframes1024tup) },\n\t{ \"Net Octets\", CPSW_STAT(netoctets) },\n\t{ \"Rx Start of Frame Overruns\", CPSW_STAT(rxsofoverruns) },\n\t{ \"Rx Middle of Frame Overruns\", CPSW_STAT(rxmofoverruns) },\n\t{ \"Rx DMA Overruns\", CPSW_STAT(rxdmaoverruns) },\n};\n\nstatic const struct cpsw_stats cpsw_gstrings_ch_stats[] = {\n\t{ \"head_enqueue\", CPDMA_RX_STAT(head_enqueue) },\n\t{ \"tail_enqueue\", CPDMA_RX_STAT(tail_enqueue) },\n\t{ \"pad_enqueue\", CPDMA_RX_STAT(pad_enqueue) },\n\t{ \"misqueued\", CPDMA_RX_STAT(misqueued) },\n\t{ \"desc_alloc_fail\", CPDMA_RX_STAT(desc_alloc_fail) },\n\t{ \"pad_alloc_fail\", CPDMA_RX_STAT(pad_alloc_fail) },\n\t{ \"runt_receive_buf\", CPDMA_RX_STAT(runt_receive_buff) },\n\t{ \"runt_transmit_buf\", CPDMA_RX_STAT(runt_transmit_buff) },\n\t{ \"empty_dequeue\", CPDMA_RX_STAT(empty_dequeue) },\n\t{ \"busy_dequeue\", CPDMA_RX_STAT(busy_dequeue) },\n\t{ \"good_dequeue\", CPDMA_RX_STAT(good_dequeue) },\n\t{ \"requeue\", CPDMA_RX_STAT(requeue) },\n\t{ \"teardown_dequeue\", CPDMA_RX_STAT(teardown_dequeue) },\n};\n\n#define CPSW_STATS_COMMON_LEN\tARRAY_SIZE(cpsw_gstrings_stats)\n#define CPSW_STATS_CH_LEN\tARRAY_SIZE(cpsw_gstrings_ch_stats)\n\nu32 cpsw_get_msglevel(struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\n\treturn priv->msg_enable;\n}\n\nvoid cpsw_set_msglevel(struct net_device *ndev, u32 value)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\n\tpriv->msg_enable = value;\n}\n\nint cpsw_get_coalesce(struct net_device *ndev, struct ethtool_coalesce *coal,\n\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\n\tcoal->rx_coalesce_usecs = cpsw->coal_intvl;\n\treturn 0;\n}\n\nint cpsw_set_coalesce(struct net_device *ndev, struct ethtool_coalesce *coal,\n\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tu32 int_ctrl;\n\tu32 num_interrupts = 0;\n\tu32 prescale = 0;\n\tu32 addnl_dvdr = 1;\n\tu32 coal_intvl = 0;\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\n\tcoal_intvl = coal->rx_coalesce_usecs;\n\n\tint_ctrl =  readl(&cpsw->wr_regs->int_control);\n\tprescale = cpsw->bus_freq_mhz * 4;\n\n\tif (!coal->rx_coalesce_usecs) {\n\t\tint_ctrl &= ~(CPSW_INTPRESCALE_MASK | CPSW_INTPACEEN);\n\t\tgoto update_return;\n\t}\n\n\tif (coal_intvl < CPSW_CMINTMIN_INTVL)\n\t\tcoal_intvl = CPSW_CMINTMIN_INTVL;\n\n\tif (coal_intvl > CPSW_CMINTMAX_INTVL) {\n\t\t \n\t\taddnl_dvdr = CPSW_INTPRESCALE_MASK / prescale;\n\n\t\tif (addnl_dvdr > 1) {\n\t\t\tprescale *= addnl_dvdr;\n\t\t\tif (coal_intvl > (CPSW_CMINTMAX_INTVL * addnl_dvdr))\n\t\t\t\tcoal_intvl = (CPSW_CMINTMAX_INTVL\n\t\t\t\t\t\t* addnl_dvdr);\n\t\t} else {\n\t\t\taddnl_dvdr = 1;\n\t\t\tcoal_intvl = CPSW_CMINTMAX_INTVL;\n\t\t}\n\t}\n\n\tnum_interrupts = (1000 * addnl_dvdr) / coal_intvl;\n\twritel(num_interrupts, &cpsw->wr_regs->rx_imax);\n\twritel(num_interrupts, &cpsw->wr_regs->tx_imax);\n\n\tint_ctrl |= CPSW_INTPACEEN;\n\tint_ctrl &= (~CPSW_INTPRESCALE_MASK);\n\tint_ctrl |= (prescale & CPSW_INTPRESCALE_MASK);\n\nupdate_return:\n\twritel(int_ctrl, &cpsw->wr_regs->int_control);\n\n\tcpsw_notice(priv, timer, \"Set coalesce to %d usecs.\\n\", coal_intvl);\n\tcpsw->coal_intvl = coal_intvl;\n\n\treturn 0;\n}\n\nint cpsw_get_sset_count(struct net_device *ndev, int sset)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn (CPSW_STATS_COMMON_LEN +\n\t\t       (cpsw->rx_ch_num + cpsw->tx_ch_num) *\n\t\t       CPSW_STATS_CH_LEN);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void cpsw_add_ch_strings(u8 **p, int ch_num, int rx_dir)\n{\n\tint ch_stats_len;\n\tint line;\n\tint i;\n\n\tch_stats_len = CPSW_STATS_CH_LEN * ch_num;\n\tfor (i = 0; i < ch_stats_len; i++) {\n\t\tline = i % CPSW_STATS_CH_LEN;\n\t\tsnprintf(*p, ETH_GSTRING_LEN,\n\t\t\t \"%s DMA chan %ld: %s\", rx_dir ? \"Rx\" : \"Tx\",\n\t\t\t (long)(i / CPSW_STATS_CH_LEN),\n\t\t\t cpsw_gstrings_ch_stats[line].stat_string);\n\t\t*p += ETH_GSTRING_LEN;\n\t}\n}\n\nvoid cpsw_get_strings(struct net_device *ndev, u32 stringset, u8 *data)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\tu8 *p = data;\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < CPSW_STATS_COMMON_LEN; i++) {\n\t\t\tmemcpy(p, cpsw_gstrings_stats[i].stat_string,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\n\t\tcpsw_add_ch_strings(&p, cpsw->rx_ch_num, 1);\n\t\tcpsw_add_ch_strings(&p, cpsw->tx_ch_num, 0);\n\t\tbreak;\n\t}\n}\n\nvoid cpsw_get_ethtool_stats(struct net_device *ndev,\n\t\t\t    struct ethtool_stats *stats, u64 *data)\n{\n\tu8 *p;\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\tstruct cpdma_chan_stats ch_stats;\n\tint i, l, ch;\n\n\t \n\tfor (l = 0; l < CPSW_STATS_COMMON_LEN; l++)\n\t\tdata[l] = readl(cpsw->hw_stats +\n\t\t\t\tcpsw_gstrings_stats[l].stat_offset);\n\n\tfor (ch = 0; ch < cpsw->rx_ch_num; ch++) {\n\t\tcpdma_chan_get_stats(cpsw->rxv[ch].ch, &ch_stats);\n\t\tfor (i = 0; i < CPSW_STATS_CH_LEN; i++, l++) {\n\t\t\tp = (u8 *)&ch_stats +\n\t\t\t\tcpsw_gstrings_ch_stats[i].stat_offset;\n\t\t\tdata[l] = *(u32 *)p;\n\t\t}\n\t}\n\n\tfor (ch = 0; ch < cpsw->tx_ch_num; ch++) {\n\t\tcpdma_chan_get_stats(cpsw->txv[ch].ch, &ch_stats);\n\t\tfor (i = 0; i < CPSW_STATS_CH_LEN; i++, l++) {\n\t\t\tp = (u8 *)&ch_stats +\n\t\t\t\tcpsw_gstrings_ch_stats[i].stat_offset;\n\t\t\tdata[l] = *(u32 *)p;\n\t\t}\n\t}\n}\n\nvoid cpsw_get_pauseparam(struct net_device *ndev,\n\t\t\t struct ethtool_pauseparam *pause)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\n\tpause->autoneg = AUTONEG_DISABLE;\n\tpause->rx_pause = priv->rx_pause ? true : false;\n\tpause->tx_pause = priv->tx_pause ? true : false;\n}\n\nvoid cpsw_get_wol(struct net_device *ndev, struct ethtool_wolinfo *wol)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint slave_no = cpsw_slave_index(cpsw, priv);\n\n\twol->supported = 0;\n\twol->wolopts = 0;\n\n\tif (cpsw->slaves[slave_no].phy)\n\t\tphy_ethtool_get_wol(cpsw->slaves[slave_no].phy, wol);\n}\n\nint cpsw_set_wol(struct net_device *ndev, struct ethtool_wolinfo *wol)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint slave_no = cpsw_slave_index(cpsw, priv);\n\n\tif (cpsw->slaves[slave_no].phy)\n\t\treturn phy_ethtool_set_wol(cpsw->slaves[slave_no].phy, wol);\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nint cpsw_get_regs_len(struct net_device *ndev)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\n\treturn cpsw_ale_get_num_entries(cpsw->ale) *\n\t       ALE_ENTRY_WORDS * sizeof(u32);\n}\n\nvoid cpsw_get_regs(struct net_device *ndev, struct ethtool_regs *regs, void *p)\n{\n\tu32 *reg = p;\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\n\t \n\tregs->version = cpsw->version;\n\n\tcpsw_ale_dump(cpsw->ale, reg);\n}\n\nint cpsw_ethtool_op_begin(struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(cpsw->dev);\n\tif (ret < 0)\n\t\tcpsw_err(priv, drv, \"ethtool begin failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nvoid cpsw_ethtool_op_complete(struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\tret = pm_runtime_put(priv->cpsw->dev);\n\tif (ret < 0)\n\t\tcpsw_err(priv, drv, \"ethtool complete failed %d\\n\", ret);\n}\n\nvoid cpsw_get_channels(struct net_device *ndev, struct ethtool_channels *ch)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\n\tch->max_rx = cpsw->quirk_irq ? 1 : CPSW_MAX_QUEUES;\n\tch->max_tx = cpsw->quirk_irq ? 1 : CPSW_MAX_QUEUES;\n\tch->max_combined = 0;\n\tch->max_other = 0;\n\tch->other_count = 0;\n\tch->rx_count = cpsw->rx_ch_num;\n\tch->tx_count = cpsw->tx_ch_num;\n\tch->combined_count = 0;\n}\n\nint cpsw_get_link_ksettings(struct net_device *ndev,\n\t\t\t    struct ethtool_link_ksettings *ecmd)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint slave_no = cpsw_slave_index(cpsw, priv);\n\n\tif (!cpsw->slaves[slave_no].phy)\n\t\treturn -EOPNOTSUPP;\n\n\tphy_ethtool_ksettings_get(cpsw->slaves[slave_no].phy, ecmd);\n\treturn 0;\n}\n\nint cpsw_set_link_ksettings(struct net_device *ndev,\n\t\t\t    const struct ethtool_link_ksettings *ecmd)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint slave_no = cpsw_slave_index(cpsw, priv);\n\n\tif (!cpsw->slaves[slave_no].phy)\n\t\treturn -EOPNOTSUPP;\n\n\treturn phy_ethtool_ksettings_set(cpsw->slaves[slave_no].phy, ecmd);\n}\n\nint cpsw_get_eee(struct net_device *ndev, struct ethtool_eee *edata)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint slave_no = cpsw_slave_index(cpsw, priv);\n\n\tif (cpsw->slaves[slave_no].phy)\n\t\treturn phy_ethtool_get_eee(cpsw->slaves[slave_no].phy, edata);\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nint cpsw_set_eee(struct net_device *ndev, struct ethtool_eee *edata)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint slave_no = cpsw_slave_index(cpsw, priv);\n\n\tif (cpsw->slaves[slave_no].phy)\n\t\treturn phy_ethtool_set_eee(cpsw->slaves[slave_no].phy, edata);\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nint cpsw_nway_reset(struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint slave_no = cpsw_slave_index(cpsw, priv);\n\n\tif (cpsw->slaves[slave_no].phy)\n\t\treturn genphy_restart_aneg(cpsw->slaves[slave_no].phy);\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic void cpsw_suspend_data_pass(struct net_device *ndev)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\tint i;\n\n\t \n\tcpsw_intr_disable(cpsw);\n\n\t \n\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\tndev = cpsw->slaves[i].ndev;\n\t\tif (!(ndev && netif_running(ndev)))\n\t\t\tcontinue;\n\n\t\tnetif_tx_stop_all_queues(ndev);\n\n\t\t \n\t\tsmp_mb__after_atomic();\n\t}\n\n\t \n\tcpdma_ctlr_stop(cpsw->dma);\n}\n\nstatic int cpsw_resume_data_pass(struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint i, ret;\n\n\t \n\tif (cpsw->usage_count) {\n\t\tret = cpsw_fill_rx_channels(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcpdma_ctlr_start(cpsw->dma);\n\t\tcpsw_intr_enable(cpsw);\n\t}\n\n\t \n\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\tndev = cpsw->slaves[i].ndev;\n\t\tif (ndev && netif_running(ndev))\n\t\t\tnetif_tx_start_all_queues(ndev);\n\t}\n\n\treturn 0;\n}\n\nstatic int cpsw_check_ch_settings(struct cpsw_common *cpsw,\n\t\t\t\t  struct ethtool_channels *ch)\n{\n\tif (cpsw->quirk_irq) {\n\t\tdev_err(cpsw->dev, \"Maximum one tx/rx queue is allowed\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ch->combined_count)\n\t\treturn -EINVAL;\n\n\t \n\tif (!ch->rx_count || !ch->tx_count)\n\t\treturn -EINVAL;\n\n\tif (ch->rx_count > cpsw->data.channels ||\n\t    ch->tx_count > cpsw->data.channels)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cpsw_update_channels_res(struct cpsw_priv *priv, int ch_num, int rx,\n\t\t\t\t    cpdma_handler_fn rx_handler)\n{\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tvoid (*handler)(void *, int, int);\n\tstruct netdev_queue *queue;\n\tstruct cpsw_vector *vec;\n\tint ret, *ch, vch;\n\n\tif (rx) {\n\t\tch = &cpsw->rx_ch_num;\n\t\tvec = cpsw->rxv;\n\t\thandler = rx_handler;\n\t} else {\n\t\tch = &cpsw->tx_ch_num;\n\t\tvec = cpsw->txv;\n\t\thandler = cpsw_tx_handler;\n\t}\n\n\twhile (*ch < ch_num) {\n\t\tvch = rx ? *ch : 7 - *ch;\n\t\tvec[*ch].ch = cpdma_chan_create(cpsw->dma, vch, handler, rx);\n\t\tqueue = netdev_get_tx_queue(priv->ndev, *ch);\n\t\tqueue->tx_maxrate = 0;\n\n\t\tif (IS_ERR(vec[*ch].ch))\n\t\t\treturn PTR_ERR(vec[*ch].ch);\n\n\t\tif (!vec[*ch].ch)\n\t\t\treturn -EINVAL;\n\n\t\tcpsw_info(priv, ifup, \"created new %d %s channel\\n\", *ch,\n\t\t\t  (rx ? \"rx\" : \"tx\"));\n\t\t(*ch)++;\n\t}\n\n\twhile (*ch > ch_num) {\n\t\t(*ch)--;\n\n\t\tret = cpdma_chan_destroy(vec[*ch].ch);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcpsw_info(priv, ifup, \"destroyed %d %s channel\\n\", *ch,\n\t\t\t  (rx ? \"rx\" : \"tx\"));\n\t}\n\n\treturn 0;\n}\n\nstatic void cpsw_fail(struct cpsw_common *cpsw)\n{\n\tstruct net_device *ndev;\n\tint i;\n\n\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\tndev = cpsw->slaves[i].ndev;\n\t\tif (ndev)\n\t\t\tdev_close(ndev);\n\t}\n}\n\nint cpsw_set_channels_common(struct net_device *ndev,\n\t\t\t     struct ethtool_channels *chs,\n\t\t\t     cpdma_handler_fn rx_handler)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tstruct net_device *sl_ndev;\n\tint i, new_pools, ret;\n\n\tret = cpsw_check_ch_settings(cpsw, chs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcpsw_suspend_data_pass(ndev);\n\n\tnew_pools = (chs->rx_count != cpsw->rx_ch_num) && cpsw->usage_count;\n\n\tret = cpsw_update_channels_res(priv, chs->rx_count, 1, rx_handler);\n\tif (ret)\n\t\tgoto err;\n\n\tret = cpsw_update_channels_res(priv, chs->tx_count, 0, rx_handler);\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\tsl_ndev = cpsw->slaves[i].ndev;\n\t\tif (!(sl_ndev && netif_running(sl_ndev)))\n\t\t\tcontinue;\n\n\t\t \n\t\tret = netif_set_real_num_tx_queues(sl_ndev, cpsw->tx_ch_num);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"cannot set real number of tx queues\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = netif_set_real_num_rx_queues(sl_ndev, cpsw->rx_ch_num);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"cannot set real number of rx queues\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tcpsw_split_res(cpsw);\n\n\tif (new_pools) {\n\t\tcpsw_destroy_xdp_rxqs(cpsw);\n\t\tret = cpsw_create_xdp_rxqs(cpsw);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = cpsw_resume_data_pass(ndev);\n\tif (!ret)\n\t\treturn 0;\nerr:\n\tdev_err(priv->dev, \"cannot update channels number, closing device\\n\");\n\tcpsw_fail(cpsw);\n\treturn ret;\n}\n\nvoid cpsw_get_ringparam(struct net_device *ndev,\n\t\t\tstruct ethtool_ringparam *ering,\n\t\t\tstruct kernel_ethtool_ringparam *kernel_ering,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\n\t \n\tering->tx_max_pending = cpsw->descs_pool_size - CPSW_MAX_QUEUES;\n\tering->tx_pending = cpdma_get_num_tx_descs(cpsw->dma);\n\tering->rx_max_pending = cpsw->descs_pool_size - CPSW_MAX_QUEUES;\n\tering->rx_pending = cpdma_get_num_rx_descs(cpsw->dma);\n}\n\nint cpsw_set_ringparam(struct net_device *ndev,\n\t\t       struct ethtool_ringparam *ering,\n\t\t       struct kernel_ethtool_ringparam *kernel_ering,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\tint descs_num, ret;\n\n\t \n\n\tif (ering->rx_mini_pending || ering->rx_jumbo_pending ||\n\t    ering->rx_pending < CPSW_MAX_QUEUES ||\n\t    ering->rx_pending > (cpsw->descs_pool_size - CPSW_MAX_QUEUES))\n\t\treturn -EINVAL;\n\n\tdescs_num = cpdma_get_num_rx_descs(cpsw->dma);\n\tif (ering->rx_pending == descs_num)\n\t\treturn 0;\n\n\tcpsw_suspend_data_pass(ndev);\n\n\tret = cpdma_set_num_rx_descs(cpsw->dma, ering->rx_pending);\n\tif (ret) {\n\t\tif (cpsw_resume_data_pass(ndev))\n\t\t\tgoto err;\n\n\t\treturn ret;\n\t}\n\n\tif (cpsw->usage_count) {\n\t\tcpsw_destroy_xdp_rxqs(cpsw);\n\t\tret = cpsw_create_xdp_rxqs(cpsw);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = cpsw_resume_data_pass(ndev);\n\tif (!ret)\n\t\treturn 0;\nerr:\n\tcpdma_set_num_rx_descs(cpsw->dma, descs_num);\n\tdev_err(cpsw->dev, \"cannot set ring params, closing device\\n\");\n\tcpsw_fail(cpsw);\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_TI_CPTS)\nint cpsw_get_ts_info(struct net_device *ndev, struct ethtool_ts_info *info)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\n\tinfo->so_timestamping =\n\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tinfo->phc_index = cpsw->cpts->phc_index;\n\tinfo->tx_types =\n\t\t(1 << HWTSTAMP_TX_OFF) |\n\t\t(1 << HWTSTAMP_TX_ON);\n\tinfo->rx_filters =\n\t\t(1 << HWTSTAMP_FILTER_NONE) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_EVENT);\n\treturn 0;\n}\n#else\nint cpsw_get_ts_info(struct net_device *ndev, struct ethtool_ts_info *info)\n{\n\tinfo->so_timestamping =\n\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_SOFTWARE;\n\tinfo->phc_index = -1;\n\tinfo->tx_types = 0;\n\tinfo->rx_filters = 0;\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}