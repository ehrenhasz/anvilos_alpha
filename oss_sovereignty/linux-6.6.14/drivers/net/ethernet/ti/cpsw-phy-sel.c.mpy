{
  "module_name": "cpsw-phy-sel.c",
  "hash_id": "da35629af5527ffc0d2fd0218cdb1ecf3e3ac0ec6435288c2627ae09e0b4da06",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/cpsw-phy-sel.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/phy.h>\n#include <linux/of.h>\n\n#include \"cpsw.h\"\n\n \n#define AM33XX_GMII_SEL_MODE_MII\t0\n#define AM33XX_GMII_SEL_MODE_RMII\t1\n#define AM33XX_GMII_SEL_MODE_RGMII\t2\n\n#define AM33XX_GMII_SEL_RMII2_IO_CLK_EN\tBIT(7)\n#define AM33XX_GMII_SEL_RMII1_IO_CLK_EN\tBIT(6)\n#define AM33XX_GMII_SEL_RGMII2_IDMODE\tBIT(5)\n#define AM33XX_GMII_SEL_RGMII1_IDMODE\tBIT(4)\n\n#define GMII_SEL_MODE_MASK\t\t0x3\n\nstruct cpsw_phy_sel_priv {\n\tstruct device\t*dev;\n\tu32 __iomem\t*gmii_sel;\n\tbool\t\trmii_clock_external;\n\tvoid (*cpsw_phy_sel)(struct cpsw_phy_sel_priv *priv,\n\t\t\t     phy_interface_t phy_mode, int slave);\n};\n\n\nstatic void cpsw_gmii_sel_am3352(struct cpsw_phy_sel_priv *priv,\n\t\t\t\t phy_interface_t phy_mode, int slave)\n{\n\tu32 reg;\n\tu32 mask;\n\tu32 mode = 0;\n\tbool rgmii_id = false;\n\n\treg = readl(priv->gmii_sel);\n\n\tswitch (phy_mode) {\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tmode = AM33XX_GMII_SEL_MODE_RMII;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tmode = AM33XX_GMII_SEL_MODE_RGMII;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tmode = AM33XX_GMII_SEL_MODE_RGMII;\n\t\trgmii_id = true;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(priv->dev,\n\t\t\t \"Unsupported PHY mode: \\\"%s\\\". Defaulting to MII.\\n\",\n\t\t\tphy_modes(phy_mode));\n\t\tfallthrough;\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tmode = AM33XX_GMII_SEL_MODE_MII;\n\t\tbreak;\n\t}\n\n\tmask = GMII_SEL_MODE_MASK << (slave * 2) | BIT(slave + 6);\n\tmask |= BIT(slave + 4);\n\tmode <<= slave * 2;\n\n\tif (priv->rmii_clock_external) {\n\t\tif (slave == 0)\n\t\t\tmode |= AM33XX_GMII_SEL_RMII1_IO_CLK_EN;\n\t\telse\n\t\t\tmode |= AM33XX_GMII_SEL_RMII2_IO_CLK_EN;\n\t}\n\n\tif (rgmii_id) {\n\t\tif (slave == 0)\n\t\t\tmode |= AM33XX_GMII_SEL_RGMII1_IDMODE;\n\t\telse\n\t\t\tmode |= AM33XX_GMII_SEL_RGMII2_IDMODE;\n\t}\n\n\treg &= ~mask;\n\treg |= mode;\n\n\twritel(reg, priv->gmii_sel);\n}\n\nstatic void cpsw_gmii_sel_dra7xx(struct cpsw_phy_sel_priv *priv,\n\t\t\t\t phy_interface_t phy_mode, int slave)\n{\n\tu32 reg;\n\tu32 mask;\n\tu32 mode = 0;\n\n\treg = readl(priv->gmii_sel);\n\n\tswitch (phy_mode) {\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tmode = AM33XX_GMII_SEL_MODE_RMII;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tmode = AM33XX_GMII_SEL_MODE_RGMII;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(priv->dev,\n\t\t\t \"Unsupported PHY mode: \\\"%s\\\". Defaulting to MII.\\n\",\n\t\t\tphy_modes(phy_mode));\n\t\tfallthrough;\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tmode = AM33XX_GMII_SEL_MODE_MII;\n\t\tbreak;\n\t}\n\n\tswitch (slave) {\n\tcase 0:\n\t\tmask = GMII_SEL_MODE_MASK;\n\t\tbreak;\n\tcase 1:\n\t\tmask = GMII_SEL_MODE_MASK << 4;\n\t\tmode <<= 4;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"invalid slave number...\\n\");\n\t\treturn;\n\t}\n\n\tif (priv->rmii_clock_external)\n\t\tdev_err(priv->dev, \"RMII External clock is not supported\\n\");\n\n\treg &= ~mask;\n\treg |= mode;\n\n\twritel(reg, priv->gmii_sel);\n}\n\nstatic struct platform_driver cpsw_phy_sel_driver;\nstatic int match(struct device *dev, const void *data)\n{\n\tconst struct device_node *node = (const struct device_node *)data;\n\treturn dev->of_node == node &&\n\t\tdev->driver == &cpsw_phy_sel_driver.driver;\n}\n\nvoid cpsw_phy_sel(struct device *dev, phy_interface_t phy_mode, int slave)\n{\n\tstruct device_node *node;\n\tstruct cpsw_phy_sel_priv *priv;\n\n\tnode = of_parse_phandle(dev->of_node, \"cpsw-phy-sel\", 0);\n\tif (!node) {\n\t\tnode = of_get_child_by_name(dev->of_node, \"cpsw-phy-sel\");\n\t\tif (!node) {\n\t\t\tdev_err(dev, \"Phy mode driver DT not found\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdev = bus_find_device(&platform_bus_type, NULL, node, match);\n\tif (!dev) {\n\t\tdev_err(dev, \"unable to find platform device for %pOF\\n\", node);\n\t\tgoto out;\n\t}\n\n\tpriv = dev_get_drvdata(dev);\n\n\tpriv->cpsw_phy_sel(priv, phy_mode, slave);\n\n\tput_device(dev);\nout:\n\tof_node_put(node);\n}\nEXPORT_SYMBOL_GPL(cpsw_phy_sel);\n\nstatic const struct of_device_id cpsw_phy_sel_id_table[] = {\n\t{\n\t\t.compatible\t= \"ti,am3352-cpsw-phy-sel\",\n\t\t.data\t\t= &cpsw_gmii_sel_am3352,\n\t},\n\t{\n\t\t.compatible\t= \"ti,dra7xx-cpsw-phy-sel\",\n\t\t.data\t\t= &cpsw_gmii_sel_dra7xx,\n\t},\n\t{\n\t\t.compatible\t= \"ti,am43xx-cpsw-phy-sel\",\n\t\t.data\t\t= &cpsw_gmii_sel_am3352,\n\t},\n\t{}\n};\n\nstatic int cpsw_phy_sel_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *of_id;\n\tstruct cpsw_phy_sel_priv *priv;\n\n\tof_id = of_match_node(cpsw_phy_sel_id_table, pdev->dev.of_node);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\tdev_err(&pdev->dev, \"unable to alloc memory for cpsw phy sel\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->dev = &pdev->dev;\n\tpriv->cpsw_phy_sel = of_id->data;\n\n\tpriv->gmii_sel = devm_platform_ioremap_resource_byname(pdev, \"gmii-sel\");\n\tif (IS_ERR(priv->gmii_sel))\n\t\treturn PTR_ERR(priv->gmii_sel);\n\n\tpriv->rmii_clock_external = of_property_read_bool(pdev->dev.of_node, \"rmii-clock-ext\");\n\n\tdev_set_drvdata(&pdev->dev, priv);\n\n\treturn 0;\n}\n\nstatic struct platform_driver cpsw_phy_sel_driver = {\n\t.probe\t\t= cpsw_phy_sel_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"cpsw-phy-sel\",\n\t\t.of_match_table = cpsw_phy_sel_id_table,\n\t},\n};\nbuiltin_platform_driver(cpsw_phy_sel_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}