{
  "module_name": "cpsw_sl.c",
  "hash_id": "82e11ce0bd499c727394a55bb4357aeba814aeb0af882bf02111e06704d6a56a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/cpsw_sl.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n\n#include \"cpsw_sl.h\"\n\n#define CPSW_SL_REG_NOTUSED U16_MAX\n\nstatic const u16 cpsw_sl_reg_map_cpsw[] = {\n\t[CPSW_SL_IDVER] = 0x00,\n\t[CPSW_SL_MACCONTROL] = 0x04,\n\t[CPSW_SL_MACSTATUS] = 0x08,\n\t[CPSW_SL_SOFT_RESET] = 0x0c,\n\t[CPSW_SL_RX_MAXLEN] = 0x10,\n\t[CPSW_SL_BOFFTEST] = 0x14,\n\t[CPSW_SL_RX_PAUSE] = 0x18,\n\t[CPSW_SL_TX_PAUSE] = 0x1c,\n\t[CPSW_SL_EMCONTROL] = 0x20,\n\t[CPSW_SL_RX_PRI_MAP] = 0x24,\n\t[CPSW_SL_TX_GAP] = 0x28,\n};\n\nstatic const u16 cpsw_sl_reg_map_66ak2hk[] = {\n\t[CPSW_SL_IDVER] = 0x00,\n\t[CPSW_SL_MACCONTROL] = 0x04,\n\t[CPSW_SL_MACSTATUS] = 0x08,\n\t[CPSW_SL_SOFT_RESET] = 0x0c,\n\t[CPSW_SL_RX_MAXLEN] = 0x10,\n\t[CPSW_SL_BOFFTEST] = CPSW_SL_REG_NOTUSED,\n\t[CPSW_SL_RX_PAUSE] = 0x18,\n\t[CPSW_SL_TX_PAUSE] = 0x1c,\n\t[CPSW_SL_EMCONTROL] = 0x20,\n\t[CPSW_SL_RX_PRI_MAP] = 0x24,\n\t[CPSW_SL_TX_GAP] = CPSW_SL_REG_NOTUSED,\n};\n\nstatic const u16 cpsw_sl_reg_map_66ak2x_xgbe[] = {\n\t[CPSW_SL_IDVER] = 0x00,\n\t[CPSW_SL_MACCONTROL] = 0x04,\n\t[CPSW_SL_MACSTATUS] = 0x08,\n\t[CPSW_SL_SOFT_RESET] = 0x0c,\n\t[CPSW_SL_RX_MAXLEN] = 0x10,\n\t[CPSW_SL_BOFFTEST] = CPSW_SL_REG_NOTUSED,\n\t[CPSW_SL_RX_PAUSE] = 0x18,\n\t[CPSW_SL_TX_PAUSE] = 0x1c,\n\t[CPSW_SL_EMCONTROL] = 0x20,\n\t[CPSW_SL_RX_PRI_MAP] = CPSW_SL_REG_NOTUSED,\n\t[CPSW_SL_TX_GAP] = 0x28,\n};\n\nstatic const u16 cpsw_sl_reg_map_66ak2elg_am65[] = {\n\t[CPSW_SL_IDVER] = CPSW_SL_REG_NOTUSED,\n\t[CPSW_SL_MACCONTROL] = 0x00,\n\t[CPSW_SL_MACSTATUS] = 0x04,\n\t[CPSW_SL_SOFT_RESET] = 0x08,\n\t[CPSW_SL_RX_MAXLEN] = CPSW_SL_REG_NOTUSED,\n\t[CPSW_SL_BOFFTEST] = 0x0c,\n\t[CPSW_SL_RX_PAUSE] = 0x10,\n\t[CPSW_SL_TX_PAUSE] = 0x40,\n\t[CPSW_SL_EMCONTROL] = 0x70,\n\t[CPSW_SL_RX_PRI_MAP] = CPSW_SL_REG_NOTUSED,\n\t[CPSW_SL_TX_GAP] = 0x74,\n};\n\n#define CPSW_SL_SOFT_RESET_BIT\t\tBIT(0)\n\n#define CPSW_SL_STATUS_PN_IDLE\t\tBIT(31)\n#define CPSW_SL_AM65_STATUS_PN_E_IDLE\tBIT(30)\n#define CPSW_SL_AM65_STATUS_PN_P_IDLE\tBIT(29)\n#define CPSW_SL_AM65_STATUS_PN_TX_IDLE\tBIT(28)\n\n#define CPSW_SL_STATUS_IDLE_MASK_BASE (CPSW_SL_STATUS_PN_IDLE)\n\n#define CPSW_SL_STATUS_IDLE_MASK_K3 \\\n\t(CPSW_SL_STATUS_IDLE_MASK_BASE | CPSW_SL_AM65_STATUS_PN_E_IDLE | \\\n\t CPSW_SL_AM65_STATUS_PN_P_IDLE | CPSW_SL_AM65_STATUS_PN_TX_IDLE)\n\n#define CPSW_SL_CTL_FUNC_BASE \\\n\t(CPSW_SL_CTL_FULLDUPLEX |\\\n\tCPSW_SL_CTL_LOOPBACK |\\\n\tCPSW_SL_CTL_RX_FLOW_EN |\\\n\tCPSW_SL_CTL_TX_FLOW_EN |\\\n\tCPSW_SL_CTL_GMII_EN |\\\n\tCPSW_SL_CTL_TX_PACE |\\\n\tCPSW_SL_CTL_GIG |\\\n\tCPSW_SL_CTL_CMD_IDLE |\\\n\tCPSW_SL_CTL_IFCTL_A |\\\n\tCPSW_SL_CTL_IFCTL_B |\\\n\tCPSW_SL_CTL_GIG_FORCE |\\\n\tCPSW_SL_CTL_EXT_EN |\\\n\tCPSW_SL_CTL_RX_CEF_EN |\\\n\tCPSW_SL_CTL_RX_CSF_EN |\\\n\tCPSW_SL_CTL_RX_CMF_EN)\n\nstruct cpsw_sl {\n\tstruct device *dev;\n\tvoid __iomem *sl_base;\n\tconst u16 *regs;\n\tu32 control_features;\n\tu32 idle_mask;\n};\n\nstruct cpsw_sl_dev_id {\n\tconst char *device_id;\n\tconst u16 *regs;\n\tconst u32 control_features;\n\tconst u32 regs_offset;\n\tconst u32 idle_mask;\n};\n\nstatic const struct cpsw_sl_dev_id cpsw_sl_id_match[] = {\n\t{\n\t\t.device_id = \"cpsw\",\n\t\t.regs = cpsw_sl_reg_map_cpsw,\n\t\t.control_features = CPSW_SL_CTL_FUNC_BASE |\n\t\t\t\t    CPSW_SL_CTL_MTEST |\n\t\t\t\t    CPSW_SL_CTL_TX_SHORT_GAP_EN |\n\t\t\t\t    CPSW_SL_CTL_TX_SG_LIM_EN,\n\t\t.idle_mask = CPSW_SL_STATUS_IDLE_MASK_BASE,\n\t},\n\t{\n\t\t.device_id = \"66ak2hk\",\n\t\t.regs = cpsw_sl_reg_map_66ak2hk,\n\t\t.control_features = CPSW_SL_CTL_FUNC_BASE |\n\t\t\t\t    CPSW_SL_CTL_TX_SHORT_GAP_EN,\n\t\t.idle_mask = CPSW_SL_STATUS_IDLE_MASK_BASE,\n\t},\n\t{\n\t\t.device_id = \"66ak2x_xgbe\",\n\t\t.regs = cpsw_sl_reg_map_66ak2x_xgbe,\n\t\t.control_features = CPSW_SL_CTL_FUNC_BASE |\n\t\t\t\t    CPSW_SL_CTL_XGIG |\n\t\t\t\t    CPSW_SL_CTL_TX_SHORT_GAP_EN |\n\t\t\t\t    CPSW_SL_CTL_CRC_TYPE |\n\t\t\t\t    CPSW_SL_CTL_XGMII_EN,\n\t\t.idle_mask = CPSW_SL_STATUS_IDLE_MASK_BASE,\n\t},\n\t{\n\t\t.device_id = \"66ak2el\",\n\t\t.regs = cpsw_sl_reg_map_66ak2elg_am65,\n\t\t.regs_offset = 0x330,\n\t\t.control_features = CPSW_SL_CTL_FUNC_BASE |\n\t\t\t\t    CPSW_SL_CTL_MTEST |\n\t\t\t\t    CPSW_SL_CTL_TX_SHORT_GAP_EN |\n\t\t\t\t    CPSW_SL_CTL_CRC_TYPE |\n\t\t\t\t    CPSW_SL_CTL_EXT_EN_RX_FLO |\n\t\t\t\t    CPSW_SL_CTL_EXT_EN_TX_FLO |\n\t\t\t\t    CPSW_SL_CTL_TX_SG_LIM_EN,\n\t\t.idle_mask = CPSW_SL_STATUS_IDLE_MASK_BASE,\n\t},\n\t{\n\t\t.device_id = \"66ak2g\",\n\t\t.regs = cpsw_sl_reg_map_66ak2elg_am65,\n\t\t.regs_offset = 0x330,\n\t\t.control_features = CPSW_SL_CTL_FUNC_BASE |\n\t\t\t\t    CPSW_SL_CTL_MTEST |\n\t\t\t\t    CPSW_SL_CTL_CRC_TYPE |\n\t\t\t\t    CPSW_SL_CTL_EXT_EN_RX_FLO |\n\t\t\t\t    CPSW_SL_CTL_EXT_EN_TX_FLO,\n\t},\n\t{\n\t\t.device_id = \"am65\",\n\t\t.regs = cpsw_sl_reg_map_66ak2elg_am65,\n\t\t.regs_offset = 0x330,\n\t\t.control_features = CPSW_SL_CTL_FUNC_BASE |\n\t\t\t\t    CPSW_SL_CTL_MTEST |\n\t\t\t\t    CPSW_SL_CTL_XGIG |\n\t\t\t\t    CPSW_SL_CTL_TX_SHORT_GAP_EN |\n\t\t\t\t    CPSW_SL_CTL_CRC_TYPE |\n\t\t\t\t    CPSW_SL_CTL_XGMII_EN |\n\t\t\t\t    CPSW_SL_CTL_EXT_EN_RX_FLO |\n\t\t\t\t    CPSW_SL_CTL_EXT_EN_TX_FLO |\n\t\t\t\t    CPSW_SL_CTL_TX_SG_LIM_EN |\n\t\t\t\t    CPSW_SL_CTL_EXT_EN_XGIG,\n\t\t.idle_mask = CPSW_SL_STATUS_IDLE_MASK_K3,\n\t},\n\t{ },\n};\n\nu32 cpsw_sl_reg_read(struct cpsw_sl *sl, enum cpsw_sl_regs reg)\n{\n\tint val;\n\n\tif (sl->regs[reg] == CPSW_SL_REG_NOTUSED) {\n\t\tdev_err(sl->dev, \"cpsw_sl: not sup r reg: %04X\\n\",\n\t\t\tsl->regs[reg]);\n\t\treturn 0;\n\t}\n\n\tval = readl(sl->sl_base + sl->regs[reg]);\n\tdev_dbg(sl->dev, \"cpsw_sl: reg: %04X r 0x%08X\\n\", sl->regs[reg], val);\n\treturn val;\n}\n\nvoid cpsw_sl_reg_write(struct cpsw_sl *sl, enum cpsw_sl_regs reg, u32 val)\n{\n\tif (sl->regs[reg] == CPSW_SL_REG_NOTUSED) {\n\t\tdev_err(sl->dev, \"cpsw_sl: not sup w reg: %04X\\n\",\n\t\t\tsl->regs[reg]);\n\t\treturn;\n\t}\n\n\tdev_dbg(sl->dev, \"cpsw_sl: reg: %04X w 0x%08X\\n\", sl->regs[reg], val);\n\twritel(val, sl->sl_base + sl->regs[reg]);\n}\n\nstatic const struct cpsw_sl_dev_id *cpsw_sl_match_id(\n\t\tconst struct cpsw_sl_dev_id *id,\n\t\tconst char *device_id)\n{\n\tif (!id || !device_id)\n\t\treturn NULL;\n\n\twhile (id->device_id) {\n\t\tif (strcmp(device_id, id->device_id) == 0)\n\t\t\treturn id;\n\t\tid++;\n\t}\n\treturn NULL;\n}\n\nstruct cpsw_sl *cpsw_sl_get(const char *device_id, struct device *dev,\n\t\t\t    void __iomem *sl_base)\n{\n\tconst struct cpsw_sl_dev_id *sl_dev_id;\n\tstruct cpsw_sl *sl;\n\n\tsl = devm_kzalloc(dev, sizeof(struct cpsw_sl), GFP_KERNEL);\n\tif (!sl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsl->dev = dev;\n\tsl->sl_base = sl_base;\n\n\tsl_dev_id = cpsw_sl_match_id(cpsw_sl_id_match, device_id);\n\tif (!sl_dev_id) {\n\t\tdev_err(sl->dev, \"cpsw_sl: dev_id %s not found.\\n\", device_id);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tsl->regs = sl_dev_id->regs;\n\tsl->control_features = sl_dev_id->control_features;\n\tsl->idle_mask = sl_dev_id->idle_mask;\n\tsl->sl_base += sl_dev_id->regs_offset;\n\n\treturn sl;\n}\n\nvoid cpsw_sl_reset(struct cpsw_sl *sl, unsigned long tmo)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(tmo);\n\n\t \n\tcpsw_sl_reg_write(sl, CPSW_SL_SOFT_RESET, CPSW_SL_SOFT_RESET_BIT);\n\n\t \n\tdo {\n\t\tusleep_range(100, 200);\n\t} while ((cpsw_sl_reg_read(sl, CPSW_SL_SOFT_RESET) &\n\t\t  CPSW_SL_SOFT_RESET_BIT) &&\n\t\t  time_after(timeout, jiffies));\n\n\tif (cpsw_sl_reg_read(sl, CPSW_SL_SOFT_RESET) & CPSW_SL_SOFT_RESET_BIT)\n\t\tdev_err(sl->dev, \"cpsw_sl failed to soft-reset.\\n\");\n}\n\nu32 cpsw_sl_ctl_set(struct cpsw_sl *sl, u32 ctl_funcs)\n{\n\tu32 val;\n\n\tif (ctl_funcs & ~sl->control_features) {\n\t\tdev_err(sl->dev, \"cpsw_sl: unsupported func 0x%08X\\n\",\n\t\t\tctl_funcs & (~sl->control_features));\n\t\treturn -EINVAL;\n\t}\n\n\tval = cpsw_sl_reg_read(sl, CPSW_SL_MACCONTROL);\n\tval |= ctl_funcs;\n\tcpsw_sl_reg_write(sl, CPSW_SL_MACCONTROL, val);\n\n\treturn 0;\n}\n\nu32 cpsw_sl_ctl_clr(struct cpsw_sl *sl, u32 ctl_funcs)\n{\n\tu32 val;\n\n\tif (ctl_funcs & ~sl->control_features) {\n\t\tdev_err(sl->dev, \"cpsw_sl: unsupported func 0x%08X\\n\",\n\t\t\tctl_funcs & (~sl->control_features));\n\t\treturn -EINVAL;\n\t}\n\n\tval = cpsw_sl_reg_read(sl, CPSW_SL_MACCONTROL);\n\tval &= ~ctl_funcs;\n\tcpsw_sl_reg_write(sl, CPSW_SL_MACCONTROL, val);\n\n\treturn 0;\n}\n\nvoid cpsw_sl_ctl_reset(struct cpsw_sl *sl)\n{\n\tcpsw_sl_reg_write(sl, CPSW_SL_MACCONTROL, 0);\n}\n\nint cpsw_sl_wait_for_idle(struct cpsw_sl *sl, unsigned long tmo)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(tmo);\n\n\tdo {\n\t\tusleep_range(100, 200);\n\t} while (!(cpsw_sl_reg_read(sl, CPSW_SL_MACSTATUS) &\n\t\t  sl->idle_mask) && time_after(timeout, jiffies));\n\n\tif (!(cpsw_sl_reg_read(sl, CPSW_SL_MACSTATUS) & sl->idle_mask)) {\n\t\tdev_err(sl->dev, \"cpsw_sl failed to soft-reset.\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}