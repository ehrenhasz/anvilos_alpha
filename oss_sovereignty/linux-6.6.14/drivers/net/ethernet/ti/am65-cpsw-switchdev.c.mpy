{
  "module_name": "am65-cpsw-switchdev.c",
  "hash_id": "e8f5de5d0ff28c50ec55644f0ee3a66c93b82140c3eb7c4caef33ca17f09d276",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/am65-cpsw-switchdev.c",
  "human_readable_source": " \n \n\n#include <linux/etherdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/netdevice.h>\n#include <linux/workqueue.h>\n#include <net/switchdev.h>\n\n#include \"am65-cpsw-nuss.h\"\n#include \"am65-cpsw-switchdev.h\"\n#include \"cpsw_ale.h\"\n\nstruct am65_cpsw_switchdev_event_work {\n\tstruct work_struct work;\n\tstruct switchdev_notifier_fdb_info fdb_info;\n\tstruct am65_cpsw_port *port;\n\tunsigned long event;\n};\n\nstatic int am65_cpsw_port_stp_state_set(struct am65_cpsw_port *port, u8 state)\n{\n\tstruct am65_cpsw_common *cpsw = port->common;\n\tu8 cpsw_state;\n\tint ret = 0;\n\n\tswitch (state) {\n\tcase BR_STATE_FORWARDING:\n\t\tcpsw_state = ALE_PORT_STATE_FORWARD;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\tcpsw_state = ALE_PORT_STATE_LEARN;\n\t\tbreak;\n\tcase BR_STATE_DISABLED:\n\t\tcpsw_state = ALE_PORT_STATE_DISABLE;\n\t\tbreak;\n\tcase BR_STATE_LISTENING:\n\tcase BR_STATE_BLOCKING:\n\t\tcpsw_state = ALE_PORT_STATE_BLOCK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = cpsw_ale_control_set(cpsw->ale, port->port_id,\n\t\t\t\t   ALE_PORT_STATE, cpsw_state);\n\tnetdev_dbg(port->ndev, \"ale state: %u\\n\", cpsw_state);\n\n\treturn ret;\n}\n\nstatic int am65_cpsw_port_attr_br_flags_set(struct am65_cpsw_port *port,\n\t\t\t\t\t    struct net_device *orig_dev,\n\t\t\t\t\t    struct switchdev_brport_flags flags)\n{\n\tstruct am65_cpsw_common *cpsw = port->common;\n\n\tif (flags.mask & BR_MCAST_FLOOD) {\n\t\tbool unreg_mcast_add = false;\n\n\t\tif (flags.val & BR_MCAST_FLOOD)\n\t\t\tunreg_mcast_add = true;\n\n\t\tnetdev_dbg(port->ndev, \"BR_MCAST_FLOOD: %d port %u\\n\",\n\t\t\t   unreg_mcast_add, port->port_id);\n\n\t\tcpsw_ale_set_unreg_mcast(cpsw->ale, BIT(port->port_id),\n\t\t\t\t\t unreg_mcast_add);\n\t}\n\n\treturn 0;\n}\n\nstatic int am65_cpsw_port_attr_br_flags_pre_set(struct net_device *netdev,\n\t\t\t\t\t\tstruct switchdev_brport_flags flags)\n{\n\tif (flags.mask & ~(BR_LEARNING | BR_MCAST_FLOOD))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int am65_cpsw_port_attr_set(struct net_device *ndev, const void *ctx,\n\t\t\t\t   const struct switchdev_attr *attr,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct am65_cpsw_port *port = am65_ndev_to_port(ndev);\n\tint ret;\n\n\tnetdev_dbg(ndev, \"attr: id %u port: %u\\n\", attr->id, port->port_id);\n\n\tswitch (attr->id) {\n\tcase SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS:\n\t\tret = am65_cpsw_port_attr_br_flags_pre_set(ndev,\n\t\t\t\t\t\t\t   attr->u.brport_flags);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_STP_STATE:\n\t\tret = am65_cpsw_port_stp_state_set(port, attr->u.stp_state);\n\t\tnetdev_dbg(ndev, \"stp state: %u\\n\", attr->u.stp_state);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:\n\t\tret = am65_cpsw_port_attr_br_flags_set(port, attr->orig_dev,\n\t\t\t\t\t\t       attr->u.brport_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic u16 am65_cpsw_get_pvid(struct am65_cpsw_port *port)\n{\n\tstruct am65_cpsw_common *cpsw = port->common;\n\tstruct am65_cpsw_host *host_p = am65_common_get_host(cpsw);\n\tu32 pvid;\n\n\tif (port->port_id)\n\t\tpvid = readl(port->port_base + AM65_CPSW_PORT_VLAN_REG_OFFSET);\n\telse\n\t\tpvid = readl(host_p->port_base + AM65_CPSW_PORT_VLAN_REG_OFFSET);\n\n\tpvid = pvid & 0xfff;\n\n\treturn pvid;\n}\n\nstatic void am65_cpsw_set_pvid(struct am65_cpsw_port *port, u16 vid, bool cfi, u32 cos)\n{\n\tstruct am65_cpsw_common *cpsw = port->common;\n\tstruct am65_cpsw_host *host_p = am65_common_get_host(cpsw);\n\tu32 pvid;\n\n\tpvid = vid;\n\tpvid |= cfi ? BIT(12) : 0;\n\tpvid |= (cos & 0x7) << 13;\n\n\tif (port->port_id)\n\t\twritel(pvid, port->port_base + AM65_CPSW_PORT_VLAN_REG_OFFSET);\n\telse\n\t\twritel(pvid, host_p->port_base + AM65_CPSW_PORT_VLAN_REG_OFFSET);\n}\n\nstatic int am65_cpsw_port_vlan_add(struct am65_cpsw_port *port, bool untag, bool pvid,\n\t\t\t\t   u16 vid, struct net_device *orig_dev)\n{\n\tbool cpu_port = netif_is_bridge_master(orig_dev);\n\tstruct am65_cpsw_common *cpsw = port->common;\n\tint unreg_mcast_mask = 0;\n\tint reg_mcast_mask = 0;\n\tint untag_mask = 0;\n\tint port_mask;\n\tint ret = 0;\n\tu32 flags;\n\n\tif (cpu_port) {\n\t\tport_mask = BIT(HOST_PORT_NUM);\n\t\tflags = orig_dev->flags;\n\t\tunreg_mcast_mask = port_mask;\n\t} else {\n\t\tport_mask = BIT(port->port_id);\n\t\tflags = port->ndev->flags;\n\t}\n\n\tif (flags & IFF_MULTICAST)\n\t\treg_mcast_mask = port_mask;\n\n\tif (untag)\n\t\tuntag_mask = port_mask;\n\n\tret = cpsw_ale_vlan_add_modify(cpsw->ale, vid, port_mask, untag_mask,\n\t\t\t\t       reg_mcast_mask, unreg_mcast_mask);\n\tif (ret) {\n\t\tnetdev_err(port->ndev, \"Unable to add vlan\\n\");\n\t\treturn ret;\n\t}\n\n\tif (cpu_port)\n\t\tcpsw_ale_add_ucast(cpsw->ale, port->slave.mac_addr,\n\t\t\t\t   HOST_PORT_NUM, ALE_VLAN | ALE_SECURE, vid);\n\tif (!pvid)\n\t\treturn ret;\n\n\tam65_cpsw_set_pvid(port, vid, 0, 0);\n\n\tnetdev_dbg(port->ndev, \"VID add: %s: vid:%u ports:%X\\n\",\n\t\t   port->ndev->name, vid, port_mask);\n\n\treturn ret;\n}\n\nstatic int am65_cpsw_port_vlan_del(struct am65_cpsw_port *port, u16 vid,\n\t\t\t\t   struct net_device *orig_dev)\n{\n\tbool cpu_port = netif_is_bridge_master(orig_dev);\n\tstruct am65_cpsw_common *cpsw = port->common;\n\tint port_mask;\n\tint ret = 0;\n\n\tif (cpu_port)\n\t\tport_mask = BIT(HOST_PORT_NUM);\n\telse\n\t\tport_mask = BIT(port->port_id);\n\n\tret = cpsw_ale_del_vlan(cpsw->ale, vid, port_mask);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tif (cpu_port)\n\t\tcpsw_ale_del_ucast(cpsw->ale, port->slave.mac_addr,\n\t\t\t\t   HOST_PORT_NUM, ALE_VLAN, vid);\n\n\tif (vid == am65_cpsw_get_pvid(port))\n\t\tam65_cpsw_set_pvid(port, 0, 0, 0);\n\n\t \n\tcpsw_ale_del_mcast(cpsw->ale, port->ndev->broadcast, port_mask,\n\t\t\t   ALE_VLAN, vid);\n\tnetdev_dbg(port->ndev, \"VID del: %s: vid:%u ports:%X\\n\",\n\t\t   port->ndev->name, vid, port_mask);\n\n\treturn ret;\n}\n\nstatic int am65_cpsw_port_vlans_add(struct am65_cpsw_port *port,\n\t\t\t\t    const struct switchdev_obj_port_vlan *vlan)\n{\n\tbool untag = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tstruct net_device *orig_dev = vlan->obj.orig_dev;\n\tbool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\n\tnetdev_dbg(port->ndev, \"VID add: %s: vid:%u flags:%X\\n\",\n\t\t   port->ndev->name, vlan->vid, vlan->flags);\n\n\treturn am65_cpsw_port_vlan_add(port, untag, pvid, vlan->vid, orig_dev);\n}\n\nstatic int am65_cpsw_port_vlans_del(struct am65_cpsw_port *port,\n\t\t\t\t    const struct switchdev_obj_port_vlan *vlan)\n\n{\n\treturn am65_cpsw_port_vlan_del(port, vlan->vid, vlan->obj.orig_dev);\n}\n\nstatic int am65_cpsw_port_mdb_add(struct am65_cpsw_port *port,\n\t\t\t\t  struct switchdev_obj_port_mdb *mdb)\n\n{\n\tstruct net_device *orig_dev = mdb->obj.orig_dev;\n\tbool cpu_port = netif_is_bridge_master(orig_dev);\n\tstruct am65_cpsw_common *cpsw = port->common;\n\tint port_mask;\n\tint err;\n\n\tif (cpu_port)\n\t\tport_mask = BIT(HOST_PORT_NUM);\n\telse\n\t\tport_mask = BIT(port->port_id);\n\n\terr = cpsw_ale_add_mcast(cpsw->ale, mdb->addr, port_mask,\n\t\t\t\t ALE_VLAN, mdb->vid, 0);\n\tnetdev_dbg(port->ndev, \"MDB add: %s: vid %u:%pM  ports: %X\\n\",\n\t\t   port->ndev->name, mdb->vid, mdb->addr, port_mask);\n\n\treturn err;\n}\n\nstatic int am65_cpsw_port_mdb_del(struct am65_cpsw_port *port,\n\t\t\t\t  struct switchdev_obj_port_mdb *mdb)\n\n{\n\tstruct net_device *orig_dev = mdb->obj.orig_dev;\n\tbool cpu_port = netif_is_bridge_master(orig_dev);\n\tstruct am65_cpsw_common *cpsw = port->common;\n\tint del_mask;\n\n\tif (cpu_port)\n\t\tdel_mask = BIT(HOST_PORT_NUM);\n\telse\n\t\tdel_mask = BIT(port->port_id);\n\n\t \n\tcpsw_ale_del_mcast(cpsw->ale, mdb->addr, del_mask,\n\t\t\t   ALE_VLAN, mdb->vid);\n\tnetdev_dbg(port->ndev, \"MDB del: %s: vid %u:%pM  ports: %X\\n\",\n\t\t   port->ndev->name, mdb->vid, mdb->addr, del_mask);\n\n\treturn 0;\n}\n\nstatic int am65_cpsw_port_obj_add(struct net_device *ndev, const void *ctx,\n\t\t\t\t  const struct switchdev_obj *obj,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_obj_port_vlan *vlan = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\tstruct switchdev_obj_port_mdb *mdb = SWITCHDEV_OBJ_PORT_MDB(obj);\n\tstruct am65_cpsw_port *port = am65_ndev_to_port(ndev);\n\tint err = 0;\n\n\tnetdev_dbg(ndev, \"obj_add: id %u port: %u\\n\", obj->id, port->port_id);\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\terr = am65_cpsw_port_vlans_add(port, vlan);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\tcase SWITCHDEV_OBJ_ID_HOST_MDB:\n\t\terr = am65_cpsw_port_mdb_add(port, mdb);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int am65_cpsw_port_obj_del(struct net_device *ndev, const void *ctx,\n\t\t\t\t  const struct switchdev_obj *obj)\n{\n\tstruct switchdev_obj_port_vlan *vlan = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\tstruct switchdev_obj_port_mdb *mdb = SWITCHDEV_OBJ_PORT_MDB(obj);\n\tstruct am65_cpsw_port *port = am65_ndev_to_port(ndev);\n\tint err = 0;\n\n\tnetdev_dbg(ndev, \"obj_del: id %u port: %u\\n\", obj->id, port->port_id);\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\terr = am65_cpsw_port_vlans_del(port, vlan);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\tcase SWITCHDEV_OBJ_ID_HOST_MDB:\n\t\terr = am65_cpsw_port_mdb_del(port, mdb);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void am65_cpsw_fdb_offload_notify(struct net_device *ndev,\n\t\t\t\t\t struct switchdev_notifier_fdb_info *rcv)\n{\n\tstruct switchdev_notifier_fdb_info info = {};\n\n\tinfo.addr = rcv->addr;\n\tinfo.vid = rcv->vid;\n\tinfo.offloaded = true;\n\tcall_switchdev_notifiers(SWITCHDEV_FDB_OFFLOADED,\n\t\t\t\t ndev, &info.info, NULL);\n}\n\nstatic void am65_cpsw_switchdev_event_work(struct work_struct *work)\n{\n\tstruct am65_cpsw_switchdev_event_work *switchdev_work =\n\t\tcontainer_of(work, struct am65_cpsw_switchdev_event_work, work);\n\tstruct am65_cpsw_port *port = switchdev_work->port;\n\tstruct switchdev_notifier_fdb_info *fdb;\n\tstruct am65_cpsw_common *cpsw = port->common;\n\tint port_id = port->port_id;\n\n\trtnl_lock();\n\tswitch (switchdev_work->event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\tfdb = &switchdev_work->fdb_info;\n\n\t\tnetdev_dbg(port->ndev, \"cpsw_fdb_add: MACID = %pM vid = %u flags = %u %u -- port %d\\n\",\n\t\t\t   fdb->addr, fdb->vid, fdb->added_by_user,\n\t\t\t   fdb->offloaded, port_id);\n\n\t\tif (!fdb->added_by_user || fdb->is_local)\n\t\t\tbreak;\n\t\tif (memcmp(port->slave.mac_addr, (u8 *)fdb->addr, ETH_ALEN) == 0)\n\t\t\tport_id = HOST_PORT_NUM;\n\n\t\tcpsw_ale_add_ucast(cpsw->ale, (u8 *)fdb->addr, port_id,\n\t\t\t\t   fdb->vid ? ALE_VLAN : 0, fdb->vid);\n\t\tam65_cpsw_fdb_offload_notify(port->ndev, fdb);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tfdb = &switchdev_work->fdb_info;\n\n\t\tnetdev_dbg(port->ndev, \"cpsw_fdb_del: MACID = %pM vid = %u flags = %u %u -- port %d\\n\",\n\t\t\t   fdb->addr, fdb->vid, fdb->added_by_user,\n\t\t\t   fdb->offloaded, port_id);\n\n\t\tif (!fdb->added_by_user || fdb->is_local)\n\t\t\tbreak;\n\t\tif (memcmp(port->slave.mac_addr, (u8 *)fdb->addr, ETH_ALEN) == 0)\n\t\t\tport_id = HOST_PORT_NUM;\n\n\t\tcpsw_ale_del_ucast(cpsw->ale, (u8 *)fdb->addr, port_id,\n\t\t\t\t   fdb->vid ? ALE_VLAN : 0, fdb->vid);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\trtnl_unlock();\n\n\tkfree(switchdev_work->fdb_info.addr);\n\tkfree(switchdev_work);\n\tdev_put(port->ndev);\n}\n\n \nstatic int am65_cpsw_switchdev_event(struct notifier_block *unused,\n\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *ndev = switchdev_notifier_info_to_dev(ptr);\n\tstruct am65_cpsw_switchdev_event_work *switchdev_work;\n\tstruct am65_cpsw_port *port = am65_ndev_to_port(ndev);\n\tstruct switchdev_notifier_fdb_info *fdb_info = ptr;\n\tint err;\n\n\tif (event == SWITCHDEV_PORT_ATTR_SET) {\n\t\terr = switchdev_handle_port_attr_set(ndev, ptr,\n\t\t\t\t\t\t     am65_cpsw_port_dev_check,\n\t\t\t\t\t\t     am65_cpsw_port_attr_set);\n\t\treturn notifier_from_errno(err);\n\t}\n\n\tif (!am65_cpsw_port_dev_check(ndev))\n\t\treturn NOTIFY_DONE;\n\n\tswitchdev_work = kzalloc(sizeof(*switchdev_work), GFP_ATOMIC);\n\tif (WARN_ON(!switchdev_work))\n\t\treturn NOTIFY_BAD;\n\n\tINIT_WORK(&switchdev_work->work, am65_cpsw_switchdev_event_work);\n\tswitchdev_work->port = port;\n\tswitchdev_work->event = event;\n\n\tswitch (event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tmemcpy(&switchdev_work->fdb_info, ptr,\n\t\t       sizeof(switchdev_work->fdb_info));\n\t\tswitchdev_work->fdb_info.addr = kzalloc(ETH_ALEN, GFP_ATOMIC);\n\t\tif (!switchdev_work->fdb_info.addr)\n\t\t\tgoto err_addr_alloc;\n\t\tether_addr_copy((u8 *)switchdev_work->fdb_info.addr,\n\t\t\t\tfdb_info->addr);\n\t\tdev_hold(ndev);\n\t\tbreak;\n\tdefault:\n\t\tkfree(switchdev_work);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tqueue_work(system_long_wq, &switchdev_work->work);\n\n\treturn NOTIFY_DONE;\n\nerr_addr_alloc:\n\tkfree(switchdev_work);\n\treturn NOTIFY_BAD;\n}\n\nstatic struct notifier_block cpsw_switchdev_notifier = {\n\t.notifier_call = am65_cpsw_switchdev_event,\n};\n\nstatic int am65_cpsw_switchdev_blocking_event(struct notifier_block *unused,\n\t\t\t\t\t      unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tint err;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_OBJ_ADD:\n\t\terr = switchdev_handle_port_obj_add(dev, ptr,\n\t\t\t\t\t\t    am65_cpsw_port_dev_check,\n\t\t\t\t\t\t    am65_cpsw_port_obj_add);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_PORT_OBJ_DEL:\n\t\terr = switchdev_handle_port_obj_del(dev, ptr,\n\t\t\t\t\t\t    am65_cpsw_port_dev_check,\n\t\t\t\t\t\t    am65_cpsw_port_obj_del);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     am65_cpsw_port_dev_check,\n\t\t\t\t\t\t     am65_cpsw_port_attr_set);\n\t\treturn notifier_from_errno(err);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block cpsw_switchdev_bl_notifier = {\n\t.notifier_call = am65_cpsw_switchdev_blocking_event,\n};\n\nint am65_cpsw_switchdev_register_notifiers(struct am65_cpsw_common *cpsw)\n{\n\tint ret = 0;\n\n\tret = register_switchdev_notifier(&cpsw_switchdev_notifier);\n\tif (ret) {\n\t\tdev_err(cpsw->dev, \"register switchdev notifier fail ret:%d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = register_switchdev_blocking_notifier(&cpsw_switchdev_bl_notifier);\n\tif (ret) {\n\t\tdev_err(cpsw->dev, \"register switchdev blocking notifier ret:%d\\n\",\n\t\t\tret);\n\t\tunregister_switchdev_notifier(&cpsw_switchdev_notifier);\n\t}\n\n\treturn ret;\n}\n\nvoid am65_cpsw_switchdev_unregister_notifiers(struct am65_cpsw_common *cpsw)\n{\n\tunregister_switchdev_blocking_notifier(&cpsw_switchdev_bl_notifier);\n\tunregister_switchdev_notifier(&cpsw_switchdev_notifier);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}