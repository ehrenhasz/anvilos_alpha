{
  "module_name": "netcp_ethss.c",
  "hash_id": "6ee32d77951dde93d6692f860400475520e7984536758dc5b9196e1ec2b44769",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/netcp_ethss.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_address.h>\n#include <linux/if_vlan.h>\n#include <linux/ptp_classify.h>\n#include <linux/net_tstamp.h>\n#include <linux/ethtool.h>\n\n#include \"cpsw.h\"\n#include \"cpsw_ale.h\"\n#include \"netcp.h\"\n#include \"cpts.h\"\n\n#define NETCP_DRIVER_NAME\t\t\"TI KeyStone Ethernet Driver\"\n#define NETCP_DRIVER_VERSION\t\t\"v1.0\"\n\n#define GBE_IDENT(reg)\t\t\t((reg >> 16) & 0xffff)\n#define GBE_MAJOR_VERSION(reg)\t\t(reg >> 8 & 0x7)\n#define GBE_MINOR_VERSION(reg)\t\t(reg & 0xff)\n#define GBE_RTL_VERSION(reg)\t\t((reg >> 11) & 0x1f)\n\n \n#define GBE_MODULE_NAME\t\t\t\"netcp-gbe\"\n#define GBE_SS_VERSION_14\t\t0x4ed2\n\n#define GBE_SS_REG_INDEX\t\t0\n#define GBE_SGMII34_REG_INDEX\t\t1\n#define GBE_SM_REG_INDEX\t\t2\n \n#define GBE13_SGMII_MODULE_OFFSET\t0x100\n \n#define GBE13_HOST_PORT_OFFSET\t\t0x34\n#define GBE13_SLAVE_PORT_OFFSET\t\t0x60\n#define GBE13_EMAC_OFFSET\t\t0x100\n#define GBE13_SLAVE_PORT2_OFFSET\t0x200\n#define GBE13_HW_STATS_OFFSET\t\t0x300\n#define GBE13_CPTS_OFFSET\t\t0x500\n#define GBE13_ALE_OFFSET\t\t0x600\n#define GBE13_HOST_PORT_NUM\t\t0\n\n \n#define GBENU_MODULE_NAME\t\t\"netcp-gbenu\"\n#define GBE_SS_ID_NU\t\t\t0x4ee6\n#define GBE_SS_ID_2U\t\t\t0x4ee8\n\n#define IS_SS_ID_MU(d) \\\n\t((GBE_IDENT((d)->ss_version) == GBE_SS_ID_NU) || \\\n\t (GBE_IDENT((d)->ss_version) == GBE_SS_ID_2U))\n\n#define IS_SS_ID_NU(d) \\\n\t(GBE_IDENT((d)->ss_version) == GBE_SS_ID_NU)\n\n#define IS_SS_ID_VER_14(d) \\\n\t(GBE_IDENT((d)->ss_version) == GBE_SS_VERSION_14)\n#define IS_SS_ID_2U(d) \\\n\t(GBE_IDENT((d)->ss_version) == GBE_SS_ID_2U)\n\n#define GBENU_SS_REG_INDEX\t\t0\n#define GBENU_SM_REG_INDEX\t\t1\n#define GBENU_SGMII_MODULE_OFFSET\t0x100\n#define GBENU_HOST_PORT_OFFSET\t\t0x1000\n#define GBENU_SLAVE_PORT_OFFSET\t\t0x2000\n#define GBENU_EMAC_OFFSET\t\t0x2330\n#define GBENU_HW_STATS_OFFSET\t\t0x1a000\n#define GBENU_CPTS_OFFSET\t\t0x1d000\n#define GBENU_ALE_OFFSET\t\t0x1e000\n#define GBENU_HOST_PORT_NUM\t\t0\n#define GBENU_SGMII_MODULE_SIZE\t\t0x100\n\n \n#define XGBE_MODULE_NAME\t\t\"netcp-xgbe\"\n#define XGBE_SS_VERSION_10\t\t0x4ee4\n\n#define XGBE_SS_REG_INDEX\t\t0\n#define XGBE_SM_REG_INDEX\t\t1\n#define XGBE_SERDES_REG_INDEX\t\t2\n\n \n#define XGBE10_SGMII_MODULE_OFFSET\t0x100\n#define IS_SS_ID_XGBE(d)\t\t((d)->ss_version == XGBE_SS_VERSION_10)\n \n#define XGBE10_HOST_PORT_OFFSET\t\t0x34\n#define XGBE10_SLAVE_PORT_OFFSET\t0x64\n#define XGBE10_EMAC_OFFSET\t\t0x400\n#define XGBE10_CPTS_OFFSET\t\t0x600\n#define XGBE10_ALE_OFFSET\t\t0x700\n#define XGBE10_HW_STATS_OFFSET\t\t0x800\n#define XGBE10_HOST_PORT_NUM\t\t0\n\n#define\tGBE_TIMER_INTERVAL\t\t\t(HZ / 2)\n\n \n#define SOFT_RESET_MASK\t\t\t\tBIT(0)\n#define SOFT_RESET\t\t\t\tBIT(0)\n#define DEVICE_EMACSL_RESET_POLL_COUNT\t\t100\n#define GMACSL_RET_WARN_RESET_INCOMPLETE\t-2\n\n#define MACSL_RX_ENABLE_CSF\t\t\tBIT(23)\n#define MACSL_ENABLE_EXT_CTL\t\t\tBIT(18)\n#define MACSL_XGMII_ENABLE\t\t\tBIT(13)\n#define MACSL_XGIG_MODE\t\t\t\tBIT(8)\n#define MACSL_GIG_MODE\t\t\t\tBIT(7)\n#define MACSL_GMII_ENABLE\t\t\tBIT(5)\n#define MACSL_FULLDUPLEX\t\t\tBIT(0)\n\n#define GBE_CTL_P0_ENABLE\t\t\tBIT(2)\n#define ETH_SW_CTL_P0_TX_CRC_REMOVE\t\tBIT(13)\n#define GBE13_REG_VAL_STAT_ENABLE_ALL\t\t0xff\n#define XGBE_REG_VAL_STAT_ENABLE_ALL\t\t0xf\n#define GBE_STATS_CD_SEL\t\t\tBIT(28)\n\n#define GBE_PORT_MASK(x)\t\t\t(BIT(x) - 1)\n#define GBE_MASK_NO_PORTS\t\t\t0\n\n#define GBE_DEF_1G_MAC_CONTROL\t\t\t\t\t\\\n\t\t(MACSL_GIG_MODE | MACSL_GMII_ENABLE |\t\t\\\n\t\t MACSL_ENABLE_EXT_CTL |\tMACSL_RX_ENABLE_CSF)\n\n#define GBE_DEF_10G_MAC_CONTROL\t\t\t\t\\\n\t\t(MACSL_XGIG_MODE | MACSL_XGMII_ENABLE |\t\t\\\n\t\t MACSL_ENABLE_EXT_CTL |\tMACSL_RX_ENABLE_CSF)\n\n#define GBE_STATSA_MODULE\t\t\t0\n#define GBE_STATSB_MODULE\t\t\t1\n#define GBE_STATSC_MODULE\t\t\t2\n#define GBE_STATSD_MODULE\t\t\t3\n\n#define GBENU_STATS0_MODULE\t\t\t0\n#define GBENU_STATS1_MODULE\t\t\t1\n#define GBENU_STATS2_MODULE\t\t\t2\n#define GBENU_STATS3_MODULE\t\t\t3\n#define GBENU_STATS4_MODULE\t\t\t4\n#define GBENU_STATS5_MODULE\t\t\t5\n#define GBENU_STATS6_MODULE\t\t\t6\n#define GBENU_STATS7_MODULE\t\t\t7\n#define GBENU_STATS8_MODULE\t\t\t8\n\n#define XGBE_STATS0_MODULE\t\t\t0\n#define XGBE_STATS1_MODULE\t\t\t1\n#define XGBE_STATS2_MODULE\t\t\t2\n\n \n#define SGMII_BASE(d, s) \\\n\t(((s) < 2) ? (d)->sgmii_port_regs : (d)->sgmii_port34_regs)\n\n#define GBE_TX_QUEUE\t\t\t\t648\n#define\tGBE_TXHOOK_ORDER\t\t\t0\n#define\tGBE_RXHOOK_ORDER\t\t\t0\n#define GBE_DEFAULT_ALE_AGEOUT\t\t\t30\n#define SLAVE_LINK_IS_XGMII(s) ((s)->link_interface >= XGMII_LINK_MAC_PHY)\n#define SLAVE_LINK_IS_RGMII(s) \\\n\t(((s)->link_interface >= RGMII_LINK_MAC_PHY) && \\\n\t ((s)->link_interface <= RGMII_LINK_MAC_PHY_NO_MDIO))\n#define SLAVE_LINK_IS_SGMII(s) \\\n\t((s)->link_interface <= SGMII_LINK_MAC_PHY_NO_MDIO)\n#define NETCP_LINK_STATE_INVALID\t\t-1\n\n#define GBE_SET_REG_OFS(p, rb, rn) p->rb##_ofs.rn = \\\n\t\toffsetof(struct gbe##_##rb, rn)\n#define GBENU_SET_REG_OFS(p, rb, rn) p->rb##_ofs.rn = \\\n\t\toffsetof(struct gbenu##_##rb, rn)\n#define XGBE_SET_REG_OFS(p, rb, rn) p->rb##_ofs.rn = \\\n\t\toffsetof(struct xgbe##_##rb, rn)\n#define GBE_REG_ADDR(p, rb, rn) (p->rb + p->rb##_ofs.rn)\n\n#define HOST_TX_PRI_MAP_DEFAULT\t\t\t0x00000000\n\n#if IS_ENABLED(CONFIG_TI_CPTS)\n \n#define TS_RX_ANX_F_EN\t\t\t\tBIT(0)\n#define TS_RX_VLAN_LT1_EN\t\t\tBIT(1)\n#define TS_RX_VLAN_LT2_EN\t\t\tBIT(2)\n#define TS_RX_ANX_D_EN\t\t\t\tBIT(3)\n#define TS_TX_ANX_F_EN\t\t\t\tBIT(4)\n#define TS_TX_VLAN_LT1_EN\t\t\tBIT(5)\n#define TS_TX_VLAN_LT2_EN\t\t\tBIT(6)\n#define TS_TX_ANX_D_EN\t\t\t\tBIT(7)\n#define TS_LT2_EN\t\t\t\tBIT(8)\n#define TS_RX_ANX_E_EN\t\t\t\tBIT(9)\n#define TS_TX_ANX_E_EN\t\t\t\tBIT(10)\n#define TS_MSG_TYPE_EN_SHIFT\t\t\t16\n#define TS_MSG_TYPE_EN_MASK\t\t\t0xffff\n\n \n#define TS_SEQ_ID_OFS_SHIFT\t\t\t16\n#define TS_SEQ_ID_OFS_MASK\t\t\t0x3f\n\n \n#define TS_107\t\t\t\t\tBIT(16)\n#define TS_129\t\t\t\t\tBIT(17)\n#define TS_130\t\t\t\t\tBIT(18)\n#define TS_131\t\t\t\t\tBIT(19)\n#define TS_132\t\t\t\t\tBIT(20)\n#define TS_319\t\t\t\t\tBIT(21)\n#define TS_320\t\t\t\t\tBIT(22)\n#define TS_TTL_NONZERO\t\t\t\tBIT(23)\n#define TS_UNI_EN\t\t\t\tBIT(24)\n#define TS_UNI_EN_SHIFT\t\t\t\t24\n\n#define TS_TX_ANX_ALL_EN\t \\\n\t(TS_TX_ANX_D_EN\t| TS_TX_ANX_E_EN | TS_TX_ANX_F_EN)\n\n#define TS_RX_ANX_ALL_EN\t \\\n\t(TS_RX_ANX_D_EN\t| TS_RX_ANX_E_EN | TS_RX_ANX_F_EN)\n\n#define TS_CTL_DST_PORT\t\t\t\tTS_319\n#define TS_CTL_DST_PORT_SHIFT\t\t\t21\n\n#define TS_CTL_MADDR_ALL\t\\\n\t(TS_107 | TS_129 | TS_130 | TS_131 | TS_132)\n\n#define TS_CTL_MADDR_SHIFT\t\t\t16\n\n \n#define EVENT_MSG_BITS (BIT(0) | BIT(1) | BIT(2) | BIT(3))\n#endif  \n\nstruct xgbe_ss_regs {\n\tu32\tid_ver;\n\tu32\tsynce_count;\n\tu32\tsynce_mux;\n\tu32\tcontrol;\n};\n\nstruct xgbe_switch_regs {\n\tu32\tid_ver;\n\tu32\tcontrol;\n\tu32\temcontrol;\n\tu32\tstat_port_en;\n\tu32\tptype;\n\tu32\tsoft_idle;\n\tu32\tthru_rate;\n\tu32\tgap_thresh;\n\tu32\ttx_start_wds;\n\tu32\tflow_control;\n\tu32\tcppi_thresh;\n};\n\nstruct xgbe_port_regs {\n\tu32\tblk_cnt;\n\tu32\tport_vlan;\n\tu32\ttx_pri_map;\n\tu32\tsa_lo;\n\tu32\tsa_hi;\n\tu32\tts_ctl;\n\tu32\tts_seq_ltype;\n\tu32\tts_vlan;\n\tu32\tts_ctl_ltype2;\n\tu32\tts_ctl2;\n\tu32\tcontrol;\n};\n\nstruct xgbe_host_port_regs {\n\tu32\tblk_cnt;\n\tu32\tport_vlan;\n\tu32\ttx_pri_map;\n\tu32\tsrc_id;\n\tu32\trx_pri_map;\n\tu32\trx_maxlen;\n};\n\nstruct xgbe_emac_regs {\n\tu32\tid_ver;\n\tu32\tmac_control;\n\tu32\tmac_status;\n\tu32\tsoft_reset;\n\tu32\trx_maxlen;\n\tu32\t__reserved_0;\n\tu32\trx_pause;\n\tu32\ttx_pause;\n\tu32\tem_control;\n\tu32\t__reserved_1;\n\tu32\ttx_gap;\n\tu32\trsvd[4];\n};\n\nstruct xgbe_host_hw_stats {\n\tu32\trx_good_frames;\n\tu32\trx_broadcast_frames;\n\tu32\trx_multicast_frames;\n\tu32\t__rsvd_0[3];\n\tu32\trx_oversized_frames;\n\tu32\t__rsvd_1;\n\tu32\trx_undersized_frames;\n\tu32\t__rsvd_2;\n\tu32\toverrun_type4;\n\tu32\toverrun_type5;\n\tu32\trx_bytes;\n\tu32\ttx_good_frames;\n\tu32\ttx_broadcast_frames;\n\tu32\ttx_multicast_frames;\n\tu32\t__rsvd_3[9];\n\tu32\ttx_bytes;\n\tu32\ttx_64byte_frames;\n\tu32\ttx_65_to_127byte_frames;\n\tu32\ttx_128_to_255byte_frames;\n\tu32\ttx_256_to_511byte_frames;\n\tu32\ttx_512_to_1023byte_frames;\n\tu32\ttx_1024byte_frames;\n\tu32\tnet_bytes;\n\tu32\trx_sof_overruns;\n\tu32\trx_mof_overruns;\n\tu32\trx_dma_overruns;\n};\n\nstruct xgbe_hw_stats {\n\tu32\trx_good_frames;\n\tu32\trx_broadcast_frames;\n\tu32\trx_multicast_frames;\n\tu32\trx_pause_frames;\n\tu32\trx_crc_errors;\n\tu32\trx_align_code_errors;\n\tu32\trx_oversized_frames;\n\tu32\trx_jabber_frames;\n\tu32\trx_undersized_frames;\n\tu32\trx_fragments;\n\tu32\toverrun_type4;\n\tu32\toverrun_type5;\n\tu32\trx_bytes;\n\tu32\ttx_good_frames;\n\tu32\ttx_broadcast_frames;\n\tu32\ttx_multicast_frames;\n\tu32\ttx_pause_frames;\n\tu32\ttx_deferred_frames;\n\tu32\ttx_collision_frames;\n\tu32\ttx_single_coll_frames;\n\tu32\ttx_mult_coll_frames;\n\tu32\ttx_excessive_collisions;\n\tu32\ttx_late_collisions;\n\tu32\ttx_underrun;\n\tu32\ttx_carrier_sense_errors;\n\tu32\ttx_bytes;\n\tu32\ttx_64byte_frames;\n\tu32\ttx_65_to_127byte_frames;\n\tu32\ttx_128_to_255byte_frames;\n\tu32\ttx_256_to_511byte_frames;\n\tu32\ttx_512_to_1023byte_frames;\n\tu32\ttx_1024byte_frames;\n\tu32\tnet_bytes;\n\tu32\trx_sof_overruns;\n\tu32\trx_mof_overruns;\n\tu32\trx_dma_overruns;\n};\n\nstruct gbenu_ss_regs {\n\tu32\tid_ver;\n\tu32\tsynce_count;\t\t \n\tu32\tsynce_mux;\t\t \n\tu32\tcontrol;\t\t \n\tu32\t__rsvd_0[2];\t\t \n\tu32\trgmii_status;\t\t \n\tu32\tss_status;\t\t \n};\n\nstruct gbenu_switch_regs {\n\tu32\tid_ver;\n\tu32\tcontrol;\n\tu32\t__rsvd_0[2];\n\tu32\temcontrol;\n\tu32\tstat_port_en;\n\tu32\tptype;\t\t\t \n\tu32\tsoft_idle;\n\tu32\tthru_rate;\t\t \n\tu32\tgap_thresh;\t\t \n\tu32\ttx_start_wds;\t\t \n\tu32\teee_prescale;\t\t \n\tu32\ttx_g_oflow_thresh_set;\t \n\tu32\ttx_g_oflow_thresh_clr;\t \n\tu32\ttx_g_buf_thresh_set_l;\t \n\tu32\ttx_g_buf_thresh_set_h;\t \n\tu32\ttx_g_buf_thresh_clr_l;\t \n\tu32\ttx_g_buf_thresh_clr_h;\t \n};\n\nstruct gbenu_port_regs {\n\tu32\t__rsvd_0;\n\tu32\tcontrol;\n\tu32\tmax_blks;\t\t \n\tu32\tmem_align1;\n\tu32\tblk_cnt;\n\tu32\tport_vlan;\n\tu32\ttx_pri_map;\t\t \n\tu32\tpri_ctl;\t\t \n\tu32\trx_pri_map;\n\tu32\trx_maxlen;\n\tu32\ttx_blks_pri;\t\t \n\tu32\t__rsvd_1;\n\tu32\tidle2lpi;\t\t \n\tu32\tlpi2idle;\t\t \n\tu32\teee_status;\t\t \n\tu32\t__rsvd_2;\n\tu32\t__rsvd_3[176];\t\t \n\tu32\t__rsvd_4[2];\n\tu32\tsa_lo;\n\tu32\tsa_hi;\n\tu32\tts_ctl;\n\tu32\tts_seq_ltype;\n\tu32\tts_vlan;\n\tu32\tts_ctl_ltype2;\n\tu32\tts_ctl2;\n};\n\nstruct gbenu_host_port_regs {\n\tu32\t__rsvd_0;\n\tu32\tcontrol;\n\tu32\tflow_id_offset;\t\t \n\tu32\t__rsvd_1;\n\tu32\tblk_cnt;\n\tu32\tport_vlan;\n\tu32\ttx_pri_map;\t\t \n\tu32\tpri_ctl;\n\tu32\trx_pri_map;\n\tu32\trx_maxlen;\n\tu32\ttx_blks_pri;\t\t \n\tu32\t__rsvd_2;\n\tu32\tidle2lpi;\t\t \n\tu32\tlpi2wake;\t\t \n\tu32\teee_status;\t\t \n\tu32\t__rsvd_3;\n\tu32\t__rsvd_4[184];\t\t \n\tu32\thost_blks_pri;\t\t \n};\n\nstruct gbenu_emac_regs {\n\tu32\tmac_control;\n\tu32\tmac_status;\n\tu32\tsoft_reset;\n\tu32\tboff_test;\n\tu32\trx_pause;\n\tu32\t__rsvd_0[11];\t\t \n\tu32\ttx_pause;\n\tu32\t__rsvd_1[11];\t\t \n\tu32\tem_control;\n\tu32\ttx_gap;\n};\n\n \nstruct gbenu_hw_stats {\n\tu32\trx_good_frames;\n\tu32\trx_broadcast_frames;\n\tu32\trx_multicast_frames;\n\tu32\trx_pause_frames;\t\t \n\tu32\trx_crc_errors;\n\tu32\trx_align_code_errors;\t\t \n\tu32\trx_oversized_frames;\n\tu32\trx_jabber_frames;\t\t \n\tu32\trx_undersized_frames;\n\tu32\trx_fragments;\t\t\t \n\tu32\tale_drop;\n\tu32\tale_overrun_drop;\n\tu32\trx_bytes;\n\tu32\ttx_good_frames;\n\tu32\ttx_broadcast_frames;\n\tu32\ttx_multicast_frames;\n\tu32\ttx_pause_frames;\t\t \n\tu32\ttx_deferred_frames;\t\t \n\tu32\ttx_collision_frames;\t\t \n\tu32\ttx_single_coll_frames;\t\t \n\tu32\ttx_mult_coll_frames;\t\t \n\tu32\ttx_excessive_collisions;\t \n\tu32\ttx_late_collisions;\t\t \n\tu32\trx_ipg_error;\t\t\t \n\tu32\ttx_carrier_sense_errors;\t \n\tu32\ttx_bytes;\n\tu32\ttx_64B_frames;\n\tu32\ttx_65_to_127B_frames;\n\tu32\ttx_128_to_255B_frames;\n\tu32\ttx_256_to_511B_frames;\n\tu32\ttx_512_to_1023B_frames;\n\tu32\ttx_1024B_frames;\n\tu32\tnet_bytes;\n\tu32\trx_bottom_fifo_drop;\n\tu32\trx_port_mask_drop;\n\tu32\trx_top_fifo_drop;\n\tu32\tale_rate_limit_drop;\n\tu32\tale_vid_ingress_drop;\n\tu32\tale_da_eq_sa_drop;\n\tu32\t__rsvd_0[3];\n\tu32\tale_unknown_ucast;\n\tu32\tale_unknown_ucast_bytes;\n\tu32\tale_unknown_mcast;\n\tu32\tale_unknown_mcast_bytes;\n\tu32\tale_unknown_bcast;\n\tu32\tale_unknown_bcast_bytes;\n\tu32\tale_pol_match;\n\tu32\tale_pol_match_red;\t\t \n\tu32\tale_pol_match_yellow;\t\t \n\tu32\t__rsvd_1[44];\n\tu32\ttx_mem_protect_err;\n\t \n\tu32\ttx_pri0;\n\tu32\ttx_pri1;\n\tu32\ttx_pri2;\n\tu32\ttx_pri3;\n\tu32\ttx_pri4;\n\tu32\ttx_pri5;\n\tu32\ttx_pri6;\n\tu32\ttx_pri7;\n\tu32\ttx_pri0_bcnt;\n\tu32\ttx_pri1_bcnt;\n\tu32\ttx_pri2_bcnt;\n\tu32\ttx_pri3_bcnt;\n\tu32\ttx_pri4_bcnt;\n\tu32\ttx_pri5_bcnt;\n\tu32\ttx_pri6_bcnt;\n\tu32\ttx_pri7_bcnt;\n\tu32\ttx_pri0_drop;\n\tu32\ttx_pri1_drop;\n\tu32\ttx_pri2_drop;\n\tu32\ttx_pri3_drop;\n\tu32\ttx_pri4_drop;\n\tu32\ttx_pri5_drop;\n\tu32\ttx_pri6_drop;\n\tu32\ttx_pri7_drop;\n\tu32\ttx_pri0_drop_bcnt;\n\tu32\ttx_pri1_drop_bcnt;\n\tu32\ttx_pri2_drop_bcnt;\n\tu32\ttx_pri3_drop_bcnt;\n\tu32\ttx_pri4_drop_bcnt;\n\tu32\ttx_pri5_drop_bcnt;\n\tu32\ttx_pri6_drop_bcnt;\n\tu32\ttx_pri7_drop_bcnt;\n};\n\n#define GBENU_HW_STATS_REG_MAP_SZ\t0x200\n\nstruct gbe_ss_regs {\n\tu32\tid_ver;\n\tu32\tsynce_count;\n\tu32\tsynce_mux;\n};\n\nstruct gbe_ss_regs_ofs {\n\tu16\tid_ver;\n\tu16\tcontrol;\n\tu16\trgmii_status;  \n};\n\nstruct gbe_switch_regs {\n\tu32\tid_ver;\n\tu32\tcontrol;\n\tu32\tsoft_reset;\n\tu32\tstat_port_en;\n\tu32\tptype;\n\tu32\tsoft_idle;\n\tu32\tthru_rate;\n\tu32\tgap_thresh;\n\tu32\ttx_start_wds;\n\tu32\tflow_control;\n};\n\nstruct gbe_switch_regs_ofs {\n\tu16\tid_ver;\n\tu16\tcontrol;\n\tu16\tsoft_reset;\n\tu16\temcontrol;\n\tu16\tstat_port_en;\n\tu16\tptype;\n\tu16\tflow_control;\n};\n\nstruct gbe_port_regs {\n\tu32\tmax_blks;\n\tu32\tblk_cnt;\n\tu32\tport_vlan;\n\tu32\ttx_pri_map;\n\tu32\tsa_lo;\n\tu32\tsa_hi;\n\tu32\tts_ctl;\n\tu32\tts_seq_ltype;\n\tu32\tts_vlan;\n\tu32\tts_ctl_ltype2;\n\tu32\tts_ctl2;\n};\n\nstruct gbe_port_regs_ofs {\n\tu16\tport_vlan;\n\tu16\ttx_pri_map;\n\tu16     rx_pri_map;\n\tu16\tsa_lo;\n\tu16\tsa_hi;\n\tu16\tts_ctl;\n\tu16\tts_seq_ltype;\n\tu16\tts_vlan;\n\tu16\tts_ctl_ltype2;\n\tu16\tts_ctl2;\n\tu16\trx_maxlen;\t \n};\n\nstruct gbe_host_port_regs {\n\tu32\tsrc_id;\n\tu32\tport_vlan;\n\tu32\trx_pri_map;\n\tu32\trx_maxlen;\n};\n\nstruct gbe_host_port_regs_ofs {\n\tu16\tport_vlan;\n\tu16\ttx_pri_map;\n\tu16\trx_maxlen;\n};\n\nstruct gbe_emac_regs {\n\tu32\tid_ver;\n\tu32\tmac_control;\n\tu32\tmac_status;\n\tu32\tsoft_reset;\n\tu32\trx_maxlen;\n\tu32\t__reserved_0;\n\tu32\trx_pause;\n\tu32\ttx_pause;\n\tu32\t__reserved_1;\n\tu32\trx_pri_map;\n\tu32\trsvd[6];\n};\n\nstruct gbe_emac_regs_ofs {\n\tu16\tmac_control;\n\tu16\tsoft_reset;\n\tu16\trx_maxlen;\n};\n\nstruct gbe_hw_stats {\n\tu32\trx_good_frames;\n\tu32\trx_broadcast_frames;\n\tu32\trx_multicast_frames;\n\tu32\trx_pause_frames;\n\tu32\trx_crc_errors;\n\tu32\trx_align_code_errors;\n\tu32\trx_oversized_frames;\n\tu32\trx_jabber_frames;\n\tu32\trx_undersized_frames;\n\tu32\trx_fragments;\n\tu32\t__pad_0[2];\n\tu32\trx_bytes;\n\tu32\ttx_good_frames;\n\tu32\ttx_broadcast_frames;\n\tu32\ttx_multicast_frames;\n\tu32\ttx_pause_frames;\n\tu32\ttx_deferred_frames;\n\tu32\ttx_collision_frames;\n\tu32\ttx_single_coll_frames;\n\tu32\ttx_mult_coll_frames;\n\tu32\ttx_excessive_collisions;\n\tu32\ttx_late_collisions;\n\tu32\ttx_underrun;\n\tu32\ttx_carrier_sense_errors;\n\tu32\ttx_bytes;\n\tu32\ttx_64byte_frames;\n\tu32\ttx_65_to_127byte_frames;\n\tu32\ttx_128_to_255byte_frames;\n\tu32\ttx_256_to_511byte_frames;\n\tu32\ttx_512_to_1023byte_frames;\n\tu32\ttx_1024byte_frames;\n\tu32\tnet_bytes;\n\tu32\trx_sof_overruns;\n\tu32\trx_mof_overruns;\n\tu32\trx_dma_overruns;\n};\n\n#define GBE_MAX_HW_STAT_MODS\t\t\t9\n#define GBE_HW_STATS_REG_MAP_SZ\t\t\t0x100\n\nstruct ts_ctl {\n\tint     uni;\n\tu8      dst_port_map;\n\tu8      maddr_map;\n\tu8      ts_mcast_type;\n};\n\nstruct gbe_slave {\n\tvoid __iomem\t\t\t*port_regs;\n\tvoid __iomem\t\t\t*emac_regs;\n\tstruct gbe_port_regs_ofs\tport_regs_ofs;\n\tstruct gbe_emac_regs_ofs\temac_regs_ofs;\n\tint\t\t\t\tslave_num;  \n\tint\t\t\t\tport_num;   \n\tatomic_t\t\t\tlink_state;\n\tbool\t\t\t\topen;\n\tstruct phy_device\t\t*phy;\n\tu32\t\t\t\tlink_interface;\n\tu32\t\t\t\tmac_control;\n\tu8\t\t\t\tphy_port_t;\n\tstruct device_node\t\t*node;\n\tstruct device_node\t\t*phy_node;\n\tstruct ts_ctl                   ts_ctl;\n\tstruct list_head\t\tslave_list;\n};\n\nstruct gbe_priv {\n\tstruct device\t\t\t*dev;\n\tstruct netcp_device\t\t*netcp_device;\n\tstruct timer_list\t\ttimer;\n\tu32\t\t\t\tnum_slaves;\n\tu32\t\t\t\tale_ports;\n\tbool\t\t\t\tenable_ale;\n\tu8\t\t\t\tmax_num_slaves;\n\tu8\t\t\t\tmax_num_ports;  \n\tu8\t\t\t\tnum_stats_mods;\n\tstruct netcp_tx_pipe\t\ttx_pipe;\n\n\tint\t\t\t\thost_port;\n\tu32\t\t\t\trx_packet_max;\n\tu32\t\t\t\tss_version;\n\tu32\t\t\t\tstats_en_mask;\n\n\tvoid __iomem\t\t\t*ss_regs;\n\tvoid __iomem\t\t\t*switch_regs;\n\tvoid __iomem\t\t\t*host_port_regs;\n\tvoid __iomem\t\t\t*ale_reg;\n\tvoid __iomem                    *cpts_reg;\n\tvoid __iomem\t\t\t*sgmii_port_regs;\n\tvoid __iomem\t\t\t*sgmii_port34_regs;\n\tvoid __iomem\t\t\t*xgbe_serdes_regs;\n\tvoid __iomem\t\t\t*hw_stats_regs[GBE_MAX_HW_STAT_MODS];\n\n\tstruct gbe_ss_regs_ofs\t\tss_regs_ofs;\n\tstruct gbe_switch_regs_ofs\tswitch_regs_ofs;\n\tstruct gbe_host_port_regs_ofs\thost_port_regs_ofs;\n\n\tstruct cpsw_ale\t\t\t*ale;\n\tunsigned int\t\t\ttx_queue_id;\n\tconst char\t\t\t*dma_chan_name;\n\n\tstruct list_head\t\tgbe_intf_head;\n\tstruct list_head\t\tsecondary_slaves;\n\tstruct net_device\t\t*dummy_ndev;\n\n\tu64\t\t\t\t*hw_stats;\n\tu32\t\t\t\t*hw_stats_prev;\n\tconst struct netcp_ethtool_stat *et_stats;\n\tint\t\t\t\tnum_et_stats;\n\t \n\tspinlock_t\t\t\thw_stats_lock;\n\n\tint                             cpts_registered;\n\tstruct cpts                     *cpts;\n\tint\t\t\t\trx_ts_enabled;\n\tint\t\t\t\ttx_ts_enabled;\n};\n\nstruct gbe_intf {\n\tstruct net_device\t*ndev;\n\tstruct device\t\t*dev;\n\tstruct gbe_priv\t\t*gbe_dev;\n\tstruct netcp_tx_pipe\ttx_pipe;\n\tstruct gbe_slave\t*slave;\n\tstruct list_head\tgbe_intf_list;\n\tunsigned long\t\tactive_vlans[BITS_TO_LONGS(VLAN_N_VID)];\n};\n\nstatic struct netcp_module gbe_module;\nstatic struct netcp_module xgbe_module;\n\n \nstruct netcp_ethtool_stat {\n\tchar desc[ETH_GSTRING_LEN];\n\tint type;\n\tu32 size;\n\tint offset;\n};\n\n#define GBE_STATSA_INFO(field)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t\"GBE_A:\"#field, GBE_STATSA_MODULE,\t\t\t\t\\\n\tsizeof_field(struct gbe_hw_stats, field),\t\t\t\\\n\toffsetof(struct gbe_hw_stats, field)\t\t\t\t\\\n}\n\n#define GBE_STATSB_INFO(field)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t\"GBE_B:\"#field, GBE_STATSB_MODULE,\t\t\t\t\\\n\tsizeof_field(struct gbe_hw_stats, field),\t\t\t\\\n\toffsetof(struct gbe_hw_stats, field)\t\t\t\t\\\n}\n\n#define GBE_STATSC_INFO(field)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t\"GBE_C:\"#field, GBE_STATSC_MODULE,\t\t\t\t\\\n\tsizeof_field(struct gbe_hw_stats, field),\t\t\t\\\n\toffsetof(struct gbe_hw_stats, field)\t\t\t\t\\\n}\n\n#define GBE_STATSD_INFO(field)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t\"GBE_D:\"#field, GBE_STATSD_MODULE,\t\t\t\t\\\n\tsizeof_field(struct gbe_hw_stats, field),\t\t\t\\\n\toffsetof(struct gbe_hw_stats, field)\t\t\t\t\\\n}\n\nstatic const struct netcp_ethtool_stat gbe13_et_stats[] = {\n\t \n\tGBE_STATSA_INFO(rx_good_frames),\n\tGBE_STATSA_INFO(rx_broadcast_frames),\n\tGBE_STATSA_INFO(rx_multicast_frames),\n\tGBE_STATSA_INFO(rx_pause_frames),\n\tGBE_STATSA_INFO(rx_crc_errors),\n\tGBE_STATSA_INFO(rx_align_code_errors),\n\tGBE_STATSA_INFO(rx_oversized_frames),\n\tGBE_STATSA_INFO(rx_jabber_frames),\n\tGBE_STATSA_INFO(rx_undersized_frames),\n\tGBE_STATSA_INFO(rx_fragments),\n\tGBE_STATSA_INFO(rx_bytes),\n\tGBE_STATSA_INFO(tx_good_frames),\n\tGBE_STATSA_INFO(tx_broadcast_frames),\n\tGBE_STATSA_INFO(tx_multicast_frames),\n\tGBE_STATSA_INFO(tx_pause_frames),\n\tGBE_STATSA_INFO(tx_deferred_frames),\n\tGBE_STATSA_INFO(tx_collision_frames),\n\tGBE_STATSA_INFO(tx_single_coll_frames),\n\tGBE_STATSA_INFO(tx_mult_coll_frames),\n\tGBE_STATSA_INFO(tx_excessive_collisions),\n\tGBE_STATSA_INFO(tx_late_collisions),\n\tGBE_STATSA_INFO(tx_underrun),\n\tGBE_STATSA_INFO(tx_carrier_sense_errors),\n\tGBE_STATSA_INFO(tx_bytes),\n\tGBE_STATSA_INFO(tx_64byte_frames),\n\tGBE_STATSA_INFO(tx_65_to_127byte_frames),\n\tGBE_STATSA_INFO(tx_128_to_255byte_frames),\n\tGBE_STATSA_INFO(tx_256_to_511byte_frames),\n\tGBE_STATSA_INFO(tx_512_to_1023byte_frames),\n\tGBE_STATSA_INFO(tx_1024byte_frames),\n\tGBE_STATSA_INFO(net_bytes),\n\tGBE_STATSA_INFO(rx_sof_overruns),\n\tGBE_STATSA_INFO(rx_mof_overruns),\n\tGBE_STATSA_INFO(rx_dma_overruns),\n\t \n\tGBE_STATSB_INFO(rx_good_frames),\n\tGBE_STATSB_INFO(rx_broadcast_frames),\n\tGBE_STATSB_INFO(rx_multicast_frames),\n\tGBE_STATSB_INFO(rx_pause_frames),\n\tGBE_STATSB_INFO(rx_crc_errors),\n\tGBE_STATSB_INFO(rx_align_code_errors),\n\tGBE_STATSB_INFO(rx_oversized_frames),\n\tGBE_STATSB_INFO(rx_jabber_frames),\n\tGBE_STATSB_INFO(rx_undersized_frames),\n\tGBE_STATSB_INFO(rx_fragments),\n\tGBE_STATSB_INFO(rx_bytes),\n\tGBE_STATSB_INFO(tx_good_frames),\n\tGBE_STATSB_INFO(tx_broadcast_frames),\n\tGBE_STATSB_INFO(tx_multicast_frames),\n\tGBE_STATSB_INFO(tx_pause_frames),\n\tGBE_STATSB_INFO(tx_deferred_frames),\n\tGBE_STATSB_INFO(tx_collision_frames),\n\tGBE_STATSB_INFO(tx_single_coll_frames),\n\tGBE_STATSB_INFO(tx_mult_coll_frames),\n\tGBE_STATSB_INFO(tx_excessive_collisions),\n\tGBE_STATSB_INFO(tx_late_collisions),\n\tGBE_STATSB_INFO(tx_underrun),\n\tGBE_STATSB_INFO(tx_carrier_sense_errors),\n\tGBE_STATSB_INFO(tx_bytes),\n\tGBE_STATSB_INFO(tx_64byte_frames),\n\tGBE_STATSB_INFO(tx_65_to_127byte_frames),\n\tGBE_STATSB_INFO(tx_128_to_255byte_frames),\n\tGBE_STATSB_INFO(tx_256_to_511byte_frames),\n\tGBE_STATSB_INFO(tx_512_to_1023byte_frames),\n\tGBE_STATSB_INFO(tx_1024byte_frames),\n\tGBE_STATSB_INFO(net_bytes),\n\tGBE_STATSB_INFO(rx_sof_overruns),\n\tGBE_STATSB_INFO(rx_mof_overruns),\n\tGBE_STATSB_INFO(rx_dma_overruns),\n\t \n\tGBE_STATSC_INFO(rx_good_frames),\n\tGBE_STATSC_INFO(rx_broadcast_frames),\n\tGBE_STATSC_INFO(rx_multicast_frames),\n\tGBE_STATSC_INFO(rx_pause_frames),\n\tGBE_STATSC_INFO(rx_crc_errors),\n\tGBE_STATSC_INFO(rx_align_code_errors),\n\tGBE_STATSC_INFO(rx_oversized_frames),\n\tGBE_STATSC_INFO(rx_jabber_frames),\n\tGBE_STATSC_INFO(rx_undersized_frames),\n\tGBE_STATSC_INFO(rx_fragments),\n\tGBE_STATSC_INFO(rx_bytes),\n\tGBE_STATSC_INFO(tx_good_frames),\n\tGBE_STATSC_INFO(tx_broadcast_frames),\n\tGBE_STATSC_INFO(tx_multicast_frames),\n\tGBE_STATSC_INFO(tx_pause_frames),\n\tGBE_STATSC_INFO(tx_deferred_frames),\n\tGBE_STATSC_INFO(tx_collision_frames),\n\tGBE_STATSC_INFO(tx_single_coll_frames),\n\tGBE_STATSC_INFO(tx_mult_coll_frames),\n\tGBE_STATSC_INFO(tx_excessive_collisions),\n\tGBE_STATSC_INFO(tx_late_collisions),\n\tGBE_STATSC_INFO(tx_underrun),\n\tGBE_STATSC_INFO(tx_carrier_sense_errors),\n\tGBE_STATSC_INFO(tx_bytes),\n\tGBE_STATSC_INFO(tx_64byte_frames),\n\tGBE_STATSC_INFO(tx_65_to_127byte_frames),\n\tGBE_STATSC_INFO(tx_128_to_255byte_frames),\n\tGBE_STATSC_INFO(tx_256_to_511byte_frames),\n\tGBE_STATSC_INFO(tx_512_to_1023byte_frames),\n\tGBE_STATSC_INFO(tx_1024byte_frames),\n\tGBE_STATSC_INFO(net_bytes),\n\tGBE_STATSC_INFO(rx_sof_overruns),\n\tGBE_STATSC_INFO(rx_mof_overruns),\n\tGBE_STATSC_INFO(rx_dma_overruns),\n\t \n\tGBE_STATSD_INFO(rx_good_frames),\n\tGBE_STATSD_INFO(rx_broadcast_frames),\n\tGBE_STATSD_INFO(rx_multicast_frames),\n\tGBE_STATSD_INFO(rx_pause_frames),\n\tGBE_STATSD_INFO(rx_crc_errors),\n\tGBE_STATSD_INFO(rx_align_code_errors),\n\tGBE_STATSD_INFO(rx_oversized_frames),\n\tGBE_STATSD_INFO(rx_jabber_frames),\n\tGBE_STATSD_INFO(rx_undersized_frames),\n\tGBE_STATSD_INFO(rx_fragments),\n\tGBE_STATSD_INFO(rx_bytes),\n\tGBE_STATSD_INFO(tx_good_frames),\n\tGBE_STATSD_INFO(tx_broadcast_frames),\n\tGBE_STATSD_INFO(tx_multicast_frames),\n\tGBE_STATSD_INFO(tx_pause_frames),\n\tGBE_STATSD_INFO(tx_deferred_frames),\n\tGBE_STATSD_INFO(tx_collision_frames),\n\tGBE_STATSD_INFO(tx_single_coll_frames),\n\tGBE_STATSD_INFO(tx_mult_coll_frames),\n\tGBE_STATSD_INFO(tx_excessive_collisions),\n\tGBE_STATSD_INFO(tx_late_collisions),\n\tGBE_STATSD_INFO(tx_underrun),\n\tGBE_STATSD_INFO(tx_carrier_sense_errors),\n\tGBE_STATSD_INFO(tx_bytes),\n\tGBE_STATSD_INFO(tx_64byte_frames),\n\tGBE_STATSD_INFO(tx_65_to_127byte_frames),\n\tGBE_STATSD_INFO(tx_128_to_255byte_frames),\n\tGBE_STATSD_INFO(tx_256_to_511byte_frames),\n\tGBE_STATSD_INFO(tx_512_to_1023byte_frames),\n\tGBE_STATSD_INFO(tx_1024byte_frames),\n\tGBE_STATSD_INFO(net_bytes),\n\tGBE_STATSD_INFO(rx_sof_overruns),\n\tGBE_STATSD_INFO(rx_mof_overruns),\n\tGBE_STATSD_INFO(rx_dma_overruns),\n};\n\n \n#define GBENU_ET_STATS_HOST_SIZE\t52\n\n#define GBENU_STATS_HOST(field)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t\"GBE_HOST:\"#field, GBENU_STATS0_MODULE,\t\t\t\\\n\tsizeof_field(struct gbenu_hw_stats, field),\t\t\\\n\toffsetof(struct gbenu_hw_stats, field)\t\t\t\\\n}\n\n \n#define GBENU_ET_STATS_PORT_SIZE\t65\n\n#define GBENU_STATS_P1(field)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t\"GBE_P1:\"#field, GBENU_STATS1_MODULE,\t\t\t\\\n\tsizeof_field(struct gbenu_hw_stats, field),\t\t\\\n\toffsetof(struct gbenu_hw_stats, field)\t\t\t\\\n}\n\n#define GBENU_STATS_P2(field)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t\"GBE_P2:\"#field, GBENU_STATS2_MODULE,\t\t\t\\\n\tsizeof_field(struct gbenu_hw_stats, field),\t\t\\\n\toffsetof(struct gbenu_hw_stats, field)\t\t\t\\\n}\n\n#define GBENU_STATS_P3(field)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t\"GBE_P3:\"#field, GBENU_STATS3_MODULE,\t\t\t\\\n\tsizeof_field(struct gbenu_hw_stats, field),\t\t\\\n\toffsetof(struct gbenu_hw_stats, field)\t\t\t\\\n}\n\n#define GBENU_STATS_P4(field)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t\"GBE_P4:\"#field, GBENU_STATS4_MODULE,\t\t\t\\\n\tsizeof_field(struct gbenu_hw_stats, field),\t\t\\\n\toffsetof(struct gbenu_hw_stats, field)\t\t\t\\\n}\n\n#define GBENU_STATS_P5(field)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t\"GBE_P5:\"#field, GBENU_STATS5_MODULE,\t\t\t\\\n\tsizeof_field(struct gbenu_hw_stats, field),\t\t\\\n\toffsetof(struct gbenu_hw_stats, field)\t\t\t\\\n}\n\n#define GBENU_STATS_P6(field)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t\"GBE_P6:\"#field, GBENU_STATS6_MODULE,\t\t\t\\\n\tsizeof_field(struct gbenu_hw_stats, field),\t\t\\\n\toffsetof(struct gbenu_hw_stats, field)\t\t\t\\\n}\n\n#define GBENU_STATS_P7(field)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t\"GBE_P7:\"#field, GBENU_STATS7_MODULE,\t\t\t\\\n\tsizeof_field(struct gbenu_hw_stats, field),\t\t\\\n\toffsetof(struct gbenu_hw_stats, field)\t\t\t\\\n}\n\n#define GBENU_STATS_P8(field)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t\"GBE_P8:\"#field, GBENU_STATS8_MODULE,\t\t\t\\\n\tsizeof_field(struct gbenu_hw_stats, field),\t\t\\\n\toffsetof(struct gbenu_hw_stats, field)\t\t\t\\\n}\n\nstatic const struct netcp_ethtool_stat gbenu_et_stats[] = {\n\t \n\tGBENU_STATS_HOST(rx_good_frames),\n\tGBENU_STATS_HOST(rx_broadcast_frames),\n\tGBENU_STATS_HOST(rx_multicast_frames),\n\tGBENU_STATS_HOST(rx_crc_errors),\n\tGBENU_STATS_HOST(rx_oversized_frames),\n\tGBENU_STATS_HOST(rx_undersized_frames),\n\tGBENU_STATS_HOST(ale_drop),\n\tGBENU_STATS_HOST(ale_overrun_drop),\n\tGBENU_STATS_HOST(rx_bytes),\n\tGBENU_STATS_HOST(tx_good_frames),\n\tGBENU_STATS_HOST(tx_broadcast_frames),\n\tGBENU_STATS_HOST(tx_multicast_frames),\n\tGBENU_STATS_HOST(tx_bytes),\n\tGBENU_STATS_HOST(tx_64B_frames),\n\tGBENU_STATS_HOST(tx_65_to_127B_frames),\n\tGBENU_STATS_HOST(tx_128_to_255B_frames),\n\tGBENU_STATS_HOST(tx_256_to_511B_frames),\n\tGBENU_STATS_HOST(tx_512_to_1023B_frames),\n\tGBENU_STATS_HOST(tx_1024B_frames),\n\tGBENU_STATS_HOST(net_bytes),\n\tGBENU_STATS_HOST(rx_bottom_fifo_drop),\n\tGBENU_STATS_HOST(rx_port_mask_drop),\n\tGBENU_STATS_HOST(rx_top_fifo_drop),\n\tGBENU_STATS_HOST(ale_rate_limit_drop),\n\tGBENU_STATS_HOST(ale_vid_ingress_drop),\n\tGBENU_STATS_HOST(ale_da_eq_sa_drop),\n\tGBENU_STATS_HOST(ale_unknown_ucast),\n\tGBENU_STATS_HOST(ale_unknown_ucast_bytes),\n\tGBENU_STATS_HOST(ale_unknown_mcast),\n\tGBENU_STATS_HOST(ale_unknown_mcast_bytes),\n\tGBENU_STATS_HOST(ale_unknown_bcast),\n\tGBENU_STATS_HOST(ale_unknown_bcast_bytes),\n\tGBENU_STATS_HOST(ale_pol_match),\n\tGBENU_STATS_HOST(ale_pol_match_red),\n\tGBENU_STATS_HOST(ale_pol_match_yellow),\n\tGBENU_STATS_HOST(tx_mem_protect_err),\n\tGBENU_STATS_HOST(tx_pri0_drop),\n\tGBENU_STATS_HOST(tx_pri1_drop),\n\tGBENU_STATS_HOST(tx_pri2_drop),\n\tGBENU_STATS_HOST(tx_pri3_drop),\n\tGBENU_STATS_HOST(tx_pri4_drop),\n\tGBENU_STATS_HOST(tx_pri5_drop),\n\tGBENU_STATS_HOST(tx_pri6_drop),\n\tGBENU_STATS_HOST(tx_pri7_drop),\n\tGBENU_STATS_HOST(tx_pri0_drop_bcnt),\n\tGBENU_STATS_HOST(tx_pri1_drop_bcnt),\n\tGBENU_STATS_HOST(tx_pri2_drop_bcnt),\n\tGBENU_STATS_HOST(tx_pri3_drop_bcnt),\n\tGBENU_STATS_HOST(tx_pri4_drop_bcnt),\n\tGBENU_STATS_HOST(tx_pri5_drop_bcnt),\n\tGBENU_STATS_HOST(tx_pri6_drop_bcnt),\n\tGBENU_STATS_HOST(tx_pri7_drop_bcnt),\n\t \n\tGBENU_STATS_P1(rx_good_frames),\n\tGBENU_STATS_P1(rx_broadcast_frames),\n\tGBENU_STATS_P1(rx_multicast_frames),\n\tGBENU_STATS_P1(rx_pause_frames),\n\tGBENU_STATS_P1(rx_crc_errors),\n\tGBENU_STATS_P1(rx_align_code_errors),\n\tGBENU_STATS_P1(rx_oversized_frames),\n\tGBENU_STATS_P1(rx_jabber_frames),\n\tGBENU_STATS_P1(rx_undersized_frames),\n\tGBENU_STATS_P1(rx_fragments),\n\tGBENU_STATS_P1(ale_drop),\n\tGBENU_STATS_P1(ale_overrun_drop),\n\tGBENU_STATS_P1(rx_bytes),\n\tGBENU_STATS_P1(tx_good_frames),\n\tGBENU_STATS_P1(tx_broadcast_frames),\n\tGBENU_STATS_P1(tx_multicast_frames),\n\tGBENU_STATS_P1(tx_pause_frames),\n\tGBENU_STATS_P1(tx_deferred_frames),\n\tGBENU_STATS_P1(tx_collision_frames),\n\tGBENU_STATS_P1(tx_single_coll_frames),\n\tGBENU_STATS_P1(tx_mult_coll_frames),\n\tGBENU_STATS_P1(tx_excessive_collisions),\n\tGBENU_STATS_P1(tx_late_collisions),\n\tGBENU_STATS_P1(rx_ipg_error),\n\tGBENU_STATS_P1(tx_carrier_sense_errors),\n\tGBENU_STATS_P1(tx_bytes),\n\tGBENU_STATS_P1(tx_64B_frames),\n\tGBENU_STATS_P1(tx_65_to_127B_frames),\n\tGBENU_STATS_P1(tx_128_to_255B_frames),\n\tGBENU_STATS_P1(tx_256_to_511B_frames),\n\tGBENU_STATS_P1(tx_512_to_1023B_frames),\n\tGBENU_STATS_P1(tx_1024B_frames),\n\tGBENU_STATS_P1(net_bytes),\n\tGBENU_STATS_P1(rx_bottom_fifo_drop),\n\tGBENU_STATS_P1(rx_port_mask_drop),\n\tGBENU_STATS_P1(rx_top_fifo_drop),\n\tGBENU_STATS_P1(ale_rate_limit_drop),\n\tGBENU_STATS_P1(ale_vid_ingress_drop),\n\tGBENU_STATS_P1(ale_da_eq_sa_drop),\n\tGBENU_STATS_P1(ale_unknown_ucast),\n\tGBENU_STATS_P1(ale_unknown_ucast_bytes),\n\tGBENU_STATS_P1(ale_unknown_mcast),\n\tGBENU_STATS_P1(ale_unknown_mcast_bytes),\n\tGBENU_STATS_P1(ale_unknown_bcast),\n\tGBENU_STATS_P1(ale_unknown_bcast_bytes),\n\tGBENU_STATS_P1(ale_pol_match),\n\tGBENU_STATS_P1(ale_pol_match_red),\n\tGBENU_STATS_P1(ale_pol_match_yellow),\n\tGBENU_STATS_P1(tx_mem_protect_err),\n\tGBENU_STATS_P1(tx_pri0_drop),\n\tGBENU_STATS_P1(tx_pri1_drop),\n\tGBENU_STATS_P1(tx_pri2_drop),\n\tGBENU_STATS_P1(tx_pri3_drop),\n\tGBENU_STATS_P1(tx_pri4_drop),\n\tGBENU_STATS_P1(tx_pri5_drop),\n\tGBENU_STATS_P1(tx_pri6_drop),\n\tGBENU_STATS_P1(tx_pri7_drop),\n\tGBENU_STATS_P1(tx_pri0_drop_bcnt),\n\tGBENU_STATS_P1(tx_pri1_drop_bcnt),\n\tGBENU_STATS_P1(tx_pri2_drop_bcnt),\n\tGBENU_STATS_P1(tx_pri3_drop_bcnt),\n\tGBENU_STATS_P1(tx_pri4_drop_bcnt),\n\tGBENU_STATS_P1(tx_pri5_drop_bcnt),\n\tGBENU_STATS_P1(tx_pri6_drop_bcnt),\n\tGBENU_STATS_P1(tx_pri7_drop_bcnt),\n\t \n\tGBENU_STATS_P2(rx_good_frames),\n\tGBENU_STATS_P2(rx_broadcast_frames),\n\tGBENU_STATS_P2(rx_multicast_frames),\n\tGBENU_STATS_P2(rx_pause_frames),\n\tGBENU_STATS_P2(rx_crc_errors),\n\tGBENU_STATS_P2(rx_align_code_errors),\n\tGBENU_STATS_P2(rx_oversized_frames),\n\tGBENU_STATS_P2(rx_jabber_frames),\n\tGBENU_STATS_P2(rx_undersized_frames),\n\tGBENU_STATS_P2(rx_fragments),\n\tGBENU_STATS_P2(ale_drop),\n\tGBENU_STATS_P2(ale_overrun_drop),\n\tGBENU_STATS_P2(rx_bytes),\n\tGBENU_STATS_P2(tx_good_frames),\n\tGBENU_STATS_P2(tx_broadcast_frames),\n\tGBENU_STATS_P2(tx_multicast_frames),\n\tGBENU_STATS_P2(tx_pause_frames),\n\tGBENU_STATS_P2(tx_deferred_frames),\n\tGBENU_STATS_P2(tx_collision_frames),\n\tGBENU_STATS_P2(tx_single_coll_frames),\n\tGBENU_STATS_P2(tx_mult_coll_frames),\n\tGBENU_STATS_P2(tx_excessive_collisions),\n\tGBENU_STATS_P2(tx_late_collisions),\n\tGBENU_STATS_P2(rx_ipg_error),\n\tGBENU_STATS_P2(tx_carrier_sense_errors),\n\tGBENU_STATS_P2(tx_bytes),\n\tGBENU_STATS_P2(tx_64B_frames),\n\tGBENU_STATS_P2(tx_65_to_127B_frames),\n\tGBENU_STATS_P2(tx_128_to_255B_frames),\n\tGBENU_STATS_P2(tx_256_to_511B_frames),\n\tGBENU_STATS_P2(tx_512_to_1023B_frames),\n\tGBENU_STATS_P2(tx_1024B_frames),\n\tGBENU_STATS_P2(net_bytes),\n\tGBENU_STATS_P2(rx_bottom_fifo_drop),\n\tGBENU_STATS_P2(rx_port_mask_drop),\n\tGBENU_STATS_P2(rx_top_fifo_drop),\n\tGBENU_STATS_P2(ale_rate_limit_drop),\n\tGBENU_STATS_P2(ale_vid_ingress_drop),\n\tGBENU_STATS_P2(ale_da_eq_sa_drop),\n\tGBENU_STATS_P2(ale_unknown_ucast),\n\tGBENU_STATS_P2(ale_unknown_ucast_bytes),\n\tGBENU_STATS_P2(ale_unknown_mcast),\n\tGBENU_STATS_P2(ale_unknown_mcast_bytes),\n\tGBENU_STATS_P2(ale_unknown_bcast),\n\tGBENU_STATS_P2(ale_unknown_bcast_bytes),\n\tGBENU_STATS_P2(ale_pol_match),\n\tGBENU_STATS_P2(ale_pol_match_red),\n\tGBENU_STATS_P2(ale_pol_match_yellow),\n\tGBENU_STATS_P2(tx_mem_protect_err),\n\tGBENU_STATS_P2(tx_pri0_drop),\n\tGBENU_STATS_P2(tx_pri1_drop),\n\tGBENU_STATS_P2(tx_pri2_drop),\n\tGBENU_STATS_P2(tx_pri3_drop),\n\tGBENU_STATS_P2(tx_pri4_drop),\n\tGBENU_STATS_P2(tx_pri5_drop),\n\tGBENU_STATS_P2(tx_pri6_drop),\n\tGBENU_STATS_P2(tx_pri7_drop),\n\tGBENU_STATS_P2(tx_pri0_drop_bcnt),\n\tGBENU_STATS_P2(tx_pri1_drop_bcnt),\n\tGBENU_STATS_P2(tx_pri2_drop_bcnt),\n\tGBENU_STATS_P2(tx_pri3_drop_bcnt),\n\tGBENU_STATS_P2(tx_pri4_drop_bcnt),\n\tGBENU_STATS_P2(tx_pri5_drop_bcnt),\n\tGBENU_STATS_P2(tx_pri6_drop_bcnt),\n\tGBENU_STATS_P2(tx_pri7_drop_bcnt),\n\t \n\tGBENU_STATS_P3(rx_good_frames),\n\tGBENU_STATS_P3(rx_broadcast_frames),\n\tGBENU_STATS_P3(rx_multicast_frames),\n\tGBENU_STATS_P3(rx_pause_frames),\n\tGBENU_STATS_P3(rx_crc_errors),\n\tGBENU_STATS_P3(rx_align_code_errors),\n\tGBENU_STATS_P3(rx_oversized_frames),\n\tGBENU_STATS_P3(rx_jabber_frames),\n\tGBENU_STATS_P3(rx_undersized_frames),\n\tGBENU_STATS_P3(rx_fragments),\n\tGBENU_STATS_P3(ale_drop),\n\tGBENU_STATS_P3(ale_overrun_drop),\n\tGBENU_STATS_P3(rx_bytes),\n\tGBENU_STATS_P3(tx_good_frames),\n\tGBENU_STATS_P3(tx_broadcast_frames),\n\tGBENU_STATS_P3(tx_multicast_frames),\n\tGBENU_STATS_P3(tx_pause_frames),\n\tGBENU_STATS_P3(tx_deferred_frames),\n\tGBENU_STATS_P3(tx_collision_frames),\n\tGBENU_STATS_P3(tx_single_coll_frames),\n\tGBENU_STATS_P3(tx_mult_coll_frames),\n\tGBENU_STATS_P3(tx_excessive_collisions),\n\tGBENU_STATS_P3(tx_late_collisions),\n\tGBENU_STATS_P3(rx_ipg_error),\n\tGBENU_STATS_P3(tx_carrier_sense_errors),\n\tGBENU_STATS_P3(tx_bytes),\n\tGBENU_STATS_P3(tx_64B_frames),\n\tGBENU_STATS_P3(tx_65_to_127B_frames),\n\tGBENU_STATS_P3(tx_128_to_255B_frames),\n\tGBENU_STATS_P3(tx_256_to_511B_frames),\n\tGBENU_STATS_P3(tx_512_to_1023B_frames),\n\tGBENU_STATS_P3(tx_1024B_frames),\n\tGBENU_STATS_P3(net_bytes),\n\tGBENU_STATS_P3(rx_bottom_fifo_drop),\n\tGBENU_STATS_P3(rx_port_mask_drop),\n\tGBENU_STATS_P3(rx_top_fifo_drop),\n\tGBENU_STATS_P3(ale_rate_limit_drop),\n\tGBENU_STATS_P3(ale_vid_ingress_drop),\n\tGBENU_STATS_P3(ale_da_eq_sa_drop),\n\tGBENU_STATS_P3(ale_unknown_ucast),\n\tGBENU_STATS_P3(ale_unknown_ucast_bytes),\n\tGBENU_STATS_P3(ale_unknown_mcast),\n\tGBENU_STATS_P3(ale_unknown_mcast_bytes),\n\tGBENU_STATS_P3(ale_unknown_bcast),\n\tGBENU_STATS_P3(ale_unknown_bcast_bytes),\n\tGBENU_STATS_P3(ale_pol_match),\n\tGBENU_STATS_P3(ale_pol_match_red),\n\tGBENU_STATS_P3(ale_pol_match_yellow),\n\tGBENU_STATS_P3(tx_mem_protect_err),\n\tGBENU_STATS_P3(tx_pri0_drop),\n\tGBENU_STATS_P3(tx_pri1_drop),\n\tGBENU_STATS_P3(tx_pri2_drop),\n\tGBENU_STATS_P3(tx_pri3_drop),\n\tGBENU_STATS_P3(tx_pri4_drop),\n\tGBENU_STATS_P3(tx_pri5_drop),\n\tGBENU_STATS_P3(tx_pri6_drop),\n\tGBENU_STATS_P3(tx_pri7_drop),\n\tGBENU_STATS_P3(tx_pri0_drop_bcnt),\n\tGBENU_STATS_P3(tx_pri1_drop_bcnt),\n\tGBENU_STATS_P3(tx_pri2_drop_bcnt),\n\tGBENU_STATS_P3(tx_pri3_drop_bcnt),\n\tGBENU_STATS_P3(tx_pri4_drop_bcnt),\n\tGBENU_STATS_P3(tx_pri5_drop_bcnt),\n\tGBENU_STATS_P3(tx_pri6_drop_bcnt),\n\tGBENU_STATS_P3(tx_pri7_drop_bcnt),\n\t \n\tGBENU_STATS_P4(rx_good_frames),\n\tGBENU_STATS_P4(rx_broadcast_frames),\n\tGBENU_STATS_P4(rx_multicast_frames),\n\tGBENU_STATS_P4(rx_pause_frames),\n\tGBENU_STATS_P4(rx_crc_errors),\n\tGBENU_STATS_P4(rx_align_code_errors),\n\tGBENU_STATS_P4(rx_oversized_frames),\n\tGBENU_STATS_P4(rx_jabber_frames),\n\tGBENU_STATS_P4(rx_undersized_frames),\n\tGBENU_STATS_P4(rx_fragments),\n\tGBENU_STATS_P4(ale_drop),\n\tGBENU_STATS_P4(ale_overrun_drop),\n\tGBENU_STATS_P4(rx_bytes),\n\tGBENU_STATS_P4(tx_good_frames),\n\tGBENU_STATS_P4(tx_broadcast_frames),\n\tGBENU_STATS_P4(tx_multicast_frames),\n\tGBENU_STATS_P4(tx_pause_frames),\n\tGBENU_STATS_P4(tx_deferred_frames),\n\tGBENU_STATS_P4(tx_collision_frames),\n\tGBENU_STATS_P4(tx_single_coll_frames),\n\tGBENU_STATS_P4(tx_mult_coll_frames),\n\tGBENU_STATS_P4(tx_excessive_collisions),\n\tGBENU_STATS_P4(tx_late_collisions),\n\tGBENU_STATS_P4(rx_ipg_error),\n\tGBENU_STATS_P4(tx_carrier_sense_errors),\n\tGBENU_STATS_P4(tx_bytes),\n\tGBENU_STATS_P4(tx_64B_frames),\n\tGBENU_STATS_P4(tx_65_to_127B_frames),\n\tGBENU_STATS_P4(tx_128_to_255B_frames),\n\tGBENU_STATS_P4(tx_256_to_511B_frames),\n\tGBENU_STATS_P4(tx_512_to_1023B_frames),\n\tGBENU_STATS_P4(tx_1024B_frames),\n\tGBENU_STATS_P4(net_bytes),\n\tGBENU_STATS_P4(rx_bottom_fifo_drop),\n\tGBENU_STATS_P4(rx_port_mask_drop),\n\tGBENU_STATS_P4(rx_top_fifo_drop),\n\tGBENU_STATS_P4(ale_rate_limit_drop),\n\tGBENU_STATS_P4(ale_vid_ingress_drop),\n\tGBENU_STATS_P4(ale_da_eq_sa_drop),\n\tGBENU_STATS_P4(ale_unknown_ucast),\n\tGBENU_STATS_P4(ale_unknown_ucast_bytes),\n\tGBENU_STATS_P4(ale_unknown_mcast),\n\tGBENU_STATS_P4(ale_unknown_mcast_bytes),\n\tGBENU_STATS_P4(ale_unknown_bcast),\n\tGBENU_STATS_P4(ale_unknown_bcast_bytes),\n\tGBENU_STATS_P4(ale_pol_match),\n\tGBENU_STATS_P4(ale_pol_match_red),\n\tGBENU_STATS_P4(ale_pol_match_yellow),\n\tGBENU_STATS_P4(tx_mem_protect_err),\n\tGBENU_STATS_P4(tx_pri0_drop),\n\tGBENU_STATS_P4(tx_pri1_drop),\n\tGBENU_STATS_P4(tx_pri2_drop),\n\tGBENU_STATS_P4(tx_pri3_drop),\n\tGBENU_STATS_P4(tx_pri4_drop),\n\tGBENU_STATS_P4(tx_pri5_drop),\n\tGBENU_STATS_P4(tx_pri6_drop),\n\tGBENU_STATS_P4(tx_pri7_drop),\n\tGBENU_STATS_P4(tx_pri0_drop_bcnt),\n\tGBENU_STATS_P4(tx_pri1_drop_bcnt),\n\tGBENU_STATS_P4(tx_pri2_drop_bcnt),\n\tGBENU_STATS_P4(tx_pri3_drop_bcnt),\n\tGBENU_STATS_P4(tx_pri4_drop_bcnt),\n\tGBENU_STATS_P4(tx_pri5_drop_bcnt),\n\tGBENU_STATS_P4(tx_pri6_drop_bcnt),\n\tGBENU_STATS_P4(tx_pri7_drop_bcnt),\n\t \n\tGBENU_STATS_P5(rx_good_frames),\n\tGBENU_STATS_P5(rx_broadcast_frames),\n\tGBENU_STATS_P5(rx_multicast_frames),\n\tGBENU_STATS_P5(rx_pause_frames),\n\tGBENU_STATS_P5(rx_crc_errors),\n\tGBENU_STATS_P5(rx_align_code_errors),\n\tGBENU_STATS_P5(rx_oversized_frames),\n\tGBENU_STATS_P5(rx_jabber_frames),\n\tGBENU_STATS_P5(rx_undersized_frames),\n\tGBENU_STATS_P5(rx_fragments),\n\tGBENU_STATS_P5(ale_drop),\n\tGBENU_STATS_P5(ale_overrun_drop),\n\tGBENU_STATS_P5(rx_bytes),\n\tGBENU_STATS_P5(tx_good_frames),\n\tGBENU_STATS_P5(tx_broadcast_frames),\n\tGBENU_STATS_P5(tx_multicast_frames),\n\tGBENU_STATS_P5(tx_pause_frames),\n\tGBENU_STATS_P5(tx_deferred_frames),\n\tGBENU_STATS_P5(tx_collision_frames),\n\tGBENU_STATS_P5(tx_single_coll_frames),\n\tGBENU_STATS_P5(tx_mult_coll_frames),\n\tGBENU_STATS_P5(tx_excessive_collisions),\n\tGBENU_STATS_P5(tx_late_collisions),\n\tGBENU_STATS_P5(rx_ipg_error),\n\tGBENU_STATS_P5(tx_carrier_sense_errors),\n\tGBENU_STATS_P5(tx_bytes),\n\tGBENU_STATS_P5(tx_64B_frames),\n\tGBENU_STATS_P5(tx_65_to_127B_frames),\n\tGBENU_STATS_P5(tx_128_to_255B_frames),\n\tGBENU_STATS_P5(tx_256_to_511B_frames),\n\tGBENU_STATS_P5(tx_512_to_1023B_frames),\n\tGBENU_STATS_P5(tx_1024B_frames),\n\tGBENU_STATS_P5(net_bytes),\n\tGBENU_STATS_P5(rx_bottom_fifo_drop),\n\tGBENU_STATS_P5(rx_port_mask_drop),\n\tGBENU_STATS_P5(rx_top_fifo_drop),\n\tGBENU_STATS_P5(ale_rate_limit_drop),\n\tGBENU_STATS_P5(ale_vid_ingress_drop),\n\tGBENU_STATS_P5(ale_da_eq_sa_drop),\n\tGBENU_STATS_P5(ale_unknown_ucast),\n\tGBENU_STATS_P5(ale_unknown_ucast_bytes),\n\tGBENU_STATS_P5(ale_unknown_mcast),\n\tGBENU_STATS_P5(ale_unknown_mcast_bytes),\n\tGBENU_STATS_P5(ale_unknown_bcast),\n\tGBENU_STATS_P5(ale_unknown_bcast_bytes),\n\tGBENU_STATS_P5(ale_pol_match),\n\tGBENU_STATS_P5(ale_pol_match_red),\n\tGBENU_STATS_P5(ale_pol_match_yellow),\n\tGBENU_STATS_P5(tx_mem_protect_err),\n\tGBENU_STATS_P5(tx_pri0_drop),\n\tGBENU_STATS_P5(tx_pri1_drop),\n\tGBENU_STATS_P5(tx_pri2_drop),\n\tGBENU_STATS_P5(tx_pri3_drop),\n\tGBENU_STATS_P5(tx_pri4_drop),\n\tGBENU_STATS_P5(tx_pri5_drop),\n\tGBENU_STATS_P5(tx_pri6_drop),\n\tGBENU_STATS_P5(tx_pri7_drop),\n\tGBENU_STATS_P5(tx_pri0_drop_bcnt),\n\tGBENU_STATS_P5(tx_pri1_drop_bcnt),\n\tGBENU_STATS_P5(tx_pri2_drop_bcnt),\n\tGBENU_STATS_P5(tx_pri3_drop_bcnt),\n\tGBENU_STATS_P5(tx_pri4_drop_bcnt),\n\tGBENU_STATS_P5(tx_pri5_drop_bcnt),\n\tGBENU_STATS_P5(tx_pri6_drop_bcnt),\n\tGBENU_STATS_P5(tx_pri7_drop_bcnt),\n\t \n\tGBENU_STATS_P6(rx_good_frames),\n\tGBENU_STATS_P6(rx_broadcast_frames),\n\tGBENU_STATS_P6(rx_multicast_frames),\n\tGBENU_STATS_P6(rx_pause_frames),\n\tGBENU_STATS_P6(rx_crc_errors),\n\tGBENU_STATS_P6(rx_align_code_errors),\n\tGBENU_STATS_P6(rx_oversized_frames),\n\tGBENU_STATS_P6(rx_jabber_frames),\n\tGBENU_STATS_P6(rx_undersized_frames),\n\tGBENU_STATS_P6(rx_fragments),\n\tGBENU_STATS_P6(ale_drop),\n\tGBENU_STATS_P6(ale_overrun_drop),\n\tGBENU_STATS_P6(rx_bytes),\n\tGBENU_STATS_P6(tx_good_frames),\n\tGBENU_STATS_P6(tx_broadcast_frames),\n\tGBENU_STATS_P6(tx_multicast_frames),\n\tGBENU_STATS_P6(tx_pause_frames),\n\tGBENU_STATS_P6(tx_deferred_frames),\n\tGBENU_STATS_P6(tx_collision_frames),\n\tGBENU_STATS_P6(tx_single_coll_frames),\n\tGBENU_STATS_P6(tx_mult_coll_frames),\n\tGBENU_STATS_P6(tx_excessive_collisions),\n\tGBENU_STATS_P6(tx_late_collisions),\n\tGBENU_STATS_P6(rx_ipg_error),\n\tGBENU_STATS_P6(tx_carrier_sense_errors),\n\tGBENU_STATS_P6(tx_bytes),\n\tGBENU_STATS_P6(tx_64B_frames),\n\tGBENU_STATS_P6(tx_65_to_127B_frames),\n\tGBENU_STATS_P6(tx_128_to_255B_frames),\n\tGBENU_STATS_P6(tx_256_to_511B_frames),\n\tGBENU_STATS_P6(tx_512_to_1023B_frames),\n\tGBENU_STATS_P6(tx_1024B_frames),\n\tGBENU_STATS_P6(net_bytes),\n\tGBENU_STATS_P6(rx_bottom_fifo_drop),\n\tGBENU_STATS_P6(rx_port_mask_drop),\n\tGBENU_STATS_P6(rx_top_fifo_drop),\n\tGBENU_STATS_P6(ale_rate_limit_drop),\n\tGBENU_STATS_P6(ale_vid_ingress_drop),\n\tGBENU_STATS_P6(ale_da_eq_sa_drop),\n\tGBENU_STATS_P6(ale_unknown_ucast),\n\tGBENU_STATS_P6(ale_unknown_ucast_bytes),\n\tGBENU_STATS_P6(ale_unknown_mcast),\n\tGBENU_STATS_P6(ale_unknown_mcast_bytes),\n\tGBENU_STATS_P6(ale_unknown_bcast),\n\tGBENU_STATS_P6(ale_unknown_bcast_bytes),\n\tGBENU_STATS_P6(ale_pol_match),\n\tGBENU_STATS_P6(ale_pol_match_red),\n\tGBENU_STATS_P6(ale_pol_match_yellow),\n\tGBENU_STATS_P6(tx_mem_protect_err),\n\tGBENU_STATS_P6(tx_pri0_drop),\n\tGBENU_STATS_P6(tx_pri1_drop),\n\tGBENU_STATS_P6(tx_pri2_drop),\n\tGBENU_STATS_P6(tx_pri3_drop),\n\tGBENU_STATS_P6(tx_pri4_drop),\n\tGBENU_STATS_P6(tx_pri5_drop),\n\tGBENU_STATS_P6(tx_pri6_drop),\n\tGBENU_STATS_P6(tx_pri7_drop),\n\tGBENU_STATS_P6(tx_pri0_drop_bcnt),\n\tGBENU_STATS_P6(tx_pri1_drop_bcnt),\n\tGBENU_STATS_P6(tx_pri2_drop_bcnt),\n\tGBENU_STATS_P6(tx_pri3_drop_bcnt),\n\tGBENU_STATS_P6(tx_pri4_drop_bcnt),\n\tGBENU_STATS_P6(tx_pri5_drop_bcnt),\n\tGBENU_STATS_P6(tx_pri6_drop_bcnt),\n\tGBENU_STATS_P6(tx_pri7_drop_bcnt),\n\t \n\tGBENU_STATS_P7(rx_good_frames),\n\tGBENU_STATS_P7(rx_broadcast_frames),\n\tGBENU_STATS_P7(rx_multicast_frames),\n\tGBENU_STATS_P7(rx_pause_frames),\n\tGBENU_STATS_P7(rx_crc_errors),\n\tGBENU_STATS_P7(rx_align_code_errors),\n\tGBENU_STATS_P7(rx_oversized_frames),\n\tGBENU_STATS_P7(rx_jabber_frames),\n\tGBENU_STATS_P7(rx_undersized_frames),\n\tGBENU_STATS_P7(rx_fragments),\n\tGBENU_STATS_P7(ale_drop),\n\tGBENU_STATS_P7(ale_overrun_drop),\n\tGBENU_STATS_P7(rx_bytes),\n\tGBENU_STATS_P7(tx_good_frames),\n\tGBENU_STATS_P7(tx_broadcast_frames),\n\tGBENU_STATS_P7(tx_multicast_frames),\n\tGBENU_STATS_P7(tx_pause_frames),\n\tGBENU_STATS_P7(tx_deferred_frames),\n\tGBENU_STATS_P7(tx_collision_frames),\n\tGBENU_STATS_P7(tx_single_coll_frames),\n\tGBENU_STATS_P7(tx_mult_coll_frames),\n\tGBENU_STATS_P7(tx_excessive_collisions),\n\tGBENU_STATS_P7(tx_late_collisions),\n\tGBENU_STATS_P7(rx_ipg_error),\n\tGBENU_STATS_P7(tx_carrier_sense_errors),\n\tGBENU_STATS_P7(tx_bytes),\n\tGBENU_STATS_P7(tx_64B_frames),\n\tGBENU_STATS_P7(tx_65_to_127B_frames),\n\tGBENU_STATS_P7(tx_128_to_255B_frames),\n\tGBENU_STATS_P7(tx_256_to_511B_frames),\n\tGBENU_STATS_P7(tx_512_to_1023B_frames),\n\tGBENU_STATS_P7(tx_1024B_frames),\n\tGBENU_STATS_P7(net_bytes),\n\tGBENU_STATS_P7(rx_bottom_fifo_drop),\n\tGBENU_STATS_P7(rx_port_mask_drop),\n\tGBENU_STATS_P7(rx_top_fifo_drop),\n\tGBENU_STATS_P7(ale_rate_limit_drop),\n\tGBENU_STATS_P7(ale_vid_ingress_drop),\n\tGBENU_STATS_P7(ale_da_eq_sa_drop),\n\tGBENU_STATS_P7(ale_unknown_ucast),\n\tGBENU_STATS_P7(ale_unknown_ucast_bytes),\n\tGBENU_STATS_P7(ale_unknown_mcast),\n\tGBENU_STATS_P7(ale_unknown_mcast_bytes),\n\tGBENU_STATS_P7(ale_unknown_bcast),\n\tGBENU_STATS_P7(ale_unknown_bcast_bytes),\n\tGBENU_STATS_P7(ale_pol_match),\n\tGBENU_STATS_P7(ale_pol_match_red),\n\tGBENU_STATS_P7(ale_pol_match_yellow),\n\tGBENU_STATS_P7(tx_mem_protect_err),\n\tGBENU_STATS_P7(tx_pri0_drop),\n\tGBENU_STATS_P7(tx_pri1_drop),\n\tGBENU_STATS_P7(tx_pri2_drop),\n\tGBENU_STATS_P7(tx_pri3_drop),\n\tGBENU_STATS_P7(tx_pri4_drop),\n\tGBENU_STATS_P7(tx_pri5_drop),\n\tGBENU_STATS_P7(tx_pri6_drop),\n\tGBENU_STATS_P7(tx_pri7_drop),\n\tGBENU_STATS_P7(tx_pri0_drop_bcnt),\n\tGBENU_STATS_P7(tx_pri1_drop_bcnt),\n\tGBENU_STATS_P7(tx_pri2_drop_bcnt),\n\tGBENU_STATS_P7(tx_pri3_drop_bcnt),\n\tGBENU_STATS_P7(tx_pri4_drop_bcnt),\n\tGBENU_STATS_P7(tx_pri5_drop_bcnt),\n\tGBENU_STATS_P7(tx_pri6_drop_bcnt),\n\tGBENU_STATS_P7(tx_pri7_drop_bcnt),\n\t \n\tGBENU_STATS_P8(rx_good_frames),\n\tGBENU_STATS_P8(rx_broadcast_frames),\n\tGBENU_STATS_P8(rx_multicast_frames),\n\tGBENU_STATS_P8(rx_pause_frames),\n\tGBENU_STATS_P8(rx_crc_errors),\n\tGBENU_STATS_P8(rx_align_code_errors),\n\tGBENU_STATS_P8(rx_oversized_frames),\n\tGBENU_STATS_P8(rx_jabber_frames),\n\tGBENU_STATS_P8(rx_undersized_frames),\n\tGBENU_STATS_P8(rx_fragments),\n\tGBENU_STATS_P8(ale_drop),\n\tGBENU_STATS_P8(ale_overrun_drop),\n\tGBENU_STATS_P8(rx_bytes),\n\tGBENU_STATS_P8(tx_good_frames),\n\tGBENU_STATS_P8(tx_broadcast_frames),\n\tGBENU_STATS_P8(tx_multicast_frames),\n\tGBENU_STATS_P8(tx_pause_frames),\n\tGBENU_STATS_P8(tx_deferred_frames),\n\tGBENU_STATS_P8(tx_collision_frames),\n\tGBENU_STATS_P8(tx_single_coll_frames),\n\tGBENU_STATS_P8(tx_mult_coll_frames),\n\tGBENU_STATS_P8(tx_excessive_collisions),\n\tGBENU_STATS_P8(tx_late_collisions),\n\tGBENU_STATS_P8(rx_ipg_error),\n\tGBENU_STATS_P8(tx_carrier_sense_errors),\n\tGBENU_STATS_P8(tx_bytes),\n\tGBENU_STATS_P8(tx_64B_frames),\n\tGBENU_STATS_P8(tx_65_to_127B_frames),\n\tGBENU_STATS_P8(tx_128_to_255B_frames),\n\tGBENU_STATS_P8(tx_256_to_511B_frames),\n\tGBENU_STATS_P8(tx_512_to_1023B_frames),\n\tGBENU_STATS_P8(tx_1024B_frames),\n\tGBENU_STATS_P8(net_bytes),\n\tGBENU_STATS_P8(rx_bottom_fifo_drop),\n\tGBENU_STATS_P8(rx_port_mask_drop),\n\tGBENU_STATS_P8(rx_top_fifo_drop),\n\tGBENU_STATS_P8(ale_rate_limit_drop),\n\tGBENU_STATS_P8(ale_vid_ingress_drop),\n\tGBENU_STATS_P8(ale_da_eq_sa_drop),\n\tGBENU_STATS_P8(ale_unknown_ucast),\n\tGBENU_STATS_P8(ale_unknown_ucast_bytes),\n\tGBENU_STATS_P8(ale_unknown_mcast),\n\tGBENU_STATS_P8(ale_unknown_mcast_bytes),\n\tGBENU_STATS_P8(ale_unknown_bcast),\n\tGBENU_STATS_P8(ale_unknown_bcast_bytes),\n\tGBENU_STATS_P8(ale_pol_match),\n\tGBENU_STATS_P8(ale_pol_match_red),\n\tGBENU_STATS_P8(ale_pol_match_yellow),\n\tGBENU_STATS_P8(tx_mem_protect_err),\n\tGBENU_STATS_P8(tx_pri0_drop),\n\tGBENU_STATS_P8(tx_pri1_drop),\n\tGBENU_STATS_P8(tx_pri2_drop),\n\tGBENU_STATS_P8(tx_pri3_drop),\n\tGBENU_STATS_P8(tx_pri4_drop),\n\tGBENU_STATS_P8(tx_pri5_drop),\n\tGBENU_STATS_P8(tx_pri6_drop),\n\tGBENU_STATS_P8(tx_pri7_drop),\n\tGBENU_STATS_P8(tx_pri0_drop_bcnt),\n\tGBENU_STATS_P8(tx_pri1_drop_bcnt),\n\tGBENU_STATS_P8(tx_pri2_drop_bcnt),\n\tGBENU_STATS_P8(tx_pri3_drop_bcnt),\n\tGBENU_STATS_P8(tx_pri4_drop_bcnt),\n\tGBENU_STATS_P8(tx_pri5_drop_bcnt),\n\tGBENU_STATS_P8(tx_pri6_drop_bcnt),\n\tGBENU_STATS_P8(tx_pri7_drop_bcnt),\n};\n\n#define XGBE_STATS0_INFO(field)\t\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\t\"GBE_0:\"#field, XGBE_STATS0_MODULE,\t\t\\\n\tsizeof_field(struct xgbe_hw_stats, field),\t\\\n\toffsetof(struct xgbe_hw_stats, field)\t\t\\\n}\n\n#define XGBE_STATS1_INFO(field)\t\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\t\"GBE_1:\"#field, XGBE_STATS1_MODULE,\t\t\\\n\tsizeof_field(struct xgbe_hw_stats, field),\t\\\n\toffsetof(struct xgbe_hw_stats, field)\t\t\\\n}\n\n#define XGBE_STATS2_INFO(field)\t\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\t\"GBE_2:\"#field, XGBE_STATS2_MODULE,\t\t\\\n\tsizeof_field(struct xgbe_hw_stats, field),\t\\\n\toffsetof(struct xgbe_hw_stats, field)\t\t\\\n}\n\nstatic const struct netcp_ethtool_stat xgbe10_et_stats[] = {\n\t \n\tXGBE_STATS0_INFO(rx_good_frames),\n\tXGBE_STATS0_INFO(rx_broadcast_frames),\n\tXGBE_STATS0_INFO(rx_multicast_frames),\n\tXGBE_STATS0_INFO(rx_oversized_frames),\n\tXGBE_STATS0_INFO(rx_undersized_frames),\n\tXGBE_STATS0_INFO(overrun_type4),\n\tXGBE_STATS0_INFO(overrun_type5),\n\tXGBE_STATS0_INFO(rx_bytes),\n\tXGBE_STATS0_INFO(tx_good_frames),\n\tXGBE_STATS0_INFO(tx_broadcast_frames),\n\tXGBE_STATS0_INFO(tx_multicast_frames),\n\tXGBE_STATS0_INFO(tx_bytes),\n\tXGBE_STATS0_INFO(tx_64byte_frames),\n\tXGBE_STATS0_INFO(tx_65_to_127byte_frames),\n\tXGBE_STATS0_INFO(tx_128_to_255byte_frames),\n\tXGBE_STATS0_INFO(tx_256_to_511byte_frames),\n\tXGBE_STATS0_INFO(tx_512_to_1023byte_frames),\n\tXGBE_STATS0_INFO(tx_1024byte_frames),\n\tXGBE_STATS0_INFO(net_bytes),\n\tXGBE_STATS0_INFO(rx_sof_overruns),\n\tXGBE_STATS0_INFO(rx_mof_overruns),\n\tXGBE_STATS0_INFO(rx_dma_overruns),\n\t \n\tXGBE_STATS1_INFO(rx_good_frames),\n\tXGBE_STATS1_INFO(rx_broadcast_frames),\n\tXGBE_STATS1_INFO(rx_multicast_frames),\n\tXGBE_STATS1_INFO(rx_pause_frames),\n\tXGBE_STATS1_INFO(rx_crc_errors),\n\tXGBE_STATS1_INFO(rx_align_code_errors),\n\tXGBE_STATS1_INFO(rx_oversized_frames),\n\tXGBE_STATS1_INFO(rx_jabber_frames),\n\tXGBE_STATS1_INFO(rx_undersized_frames),\n\tXGBE_STATS1_INFO(rx_fragments),\n\tXGBE_STATS1_INFO(overrun_type4),\n\tXGBE_STATS1_INFO(overrun_type5),\n\tXGBE_STATS1_INFO(rx_bytes),\n\tXGBE_STATS1_INFO(tx_good_frames),\n\tXGBE_STATS1_INFO(tx_broadcast_frames),\n\tXGBE_STATS1_INFO(tx_multicast_frames),\n\tXGBE_STATS1_INFO(tx_pause_frames),\n\tXGBE_STATS1_INFO(tx_deferred_frames),\n\tXGBE_STATS1_INFO(tx_collision_frames),\n\tXGBE_STATS1_INFO(tx_single_coll_frames),\n\tXGBE_STATS1_INFO(tx_mult_coll_frames),\n\tXGBE_STATS1_INFO(tx_excessive_collisions),\n\tXGBE_STATS1_INFO(tx_late_collisions),\n\tXGBE_STATS1_INFO(tx_underrun),\n\tXGBE_STATS1_INFO(tx_carrier_sense_errors),\n\tXGBE_STATS1_INFO(tx_bytes),\n\tXGBE_STATS1_INFO(tx_64byte_frames),\n\tXGBE_STATS1_INFO(tx_65_to_127byte_frames),\n\tXGBE_STATS1_INFO(tx_128_to_255byte_frames),\n\tXGBE_STATS1_INFO(tx_256_to_511byte_frames),\n\tXGBE_STATS1_INFO(tx_512_to_1023byte_frames),\n\tXGBE_STATS1_INFO(tx_1024byte_frames),\n\tXGBE_STATS1_INFO(net_bytes),\n\tXGBE_STATS1_INFO(rx_sof_overruns),\n\tXGBE_STATS1_INFO(rx_mof_overruns),\n\tXGBE_STATS1_INFO(rx_dma_overruns),\n\t \n\tXGBE_STATS2_INFO(rx_good_frames),\n\tXGBE_STATS2_INFO(rx_broadcast_frames),\n\tXGBE_STATS2_INFO(rx_multicast_frames),\n\tXGBE_STATS2_INFO(rx_pause_frames),\n\tXGBE_STATS2_INFO(rx_crc_errors),\n\tXGBE_STATS2_INFO(rx_align_code_errors),\n\tXGBE_STATS2_INFO(rx_oversized_frames),\n\tXGBE_STATS2_INFO(rx_jabber_frames),\n\tXGBE_STATS2_INFO(rx_undersized_frames),\n\tXGBE_STATS2_INFO(rx_fragments),\n\tXGBE_STATS2_INFO(overrun_type4),\n\tXGBE_STATS2_INFO(overrun_type5),\n\tXGBE_STATS2_INFO(rx_bytes),\n\tXGBE_STATS2_INFO(tx_good_frames),\n\tXGBE_STATS2_INFO(tx_broadcast_frames),\n\tXGBE_STATS2_INFO(tx_multicast_frames),\n\tXGBE_STATS2_INFO(tx_pause_frames),\n\tXGBE_STATS2_INFO(tx_deferred_frames),\n\tXGBE_STATS2_INFO(tx_collision_frames),\n\tXGBE_STATS2_INFO(tx_single_coll_frames),\n\tXGBE_STATS2_INFO(tx_mult_coll_frames),\n\tXGBE_STATS2_INFO(tx_excessive_collisions),\n\tXGBE_STATS2_INFO(tx_late_collisions),\n\tXGBE_STATS2_INFO(tx_underrun),\n\tXGBE_STATS2_INFO(tx_carrier_sense_errors),\n\tXGBE_STATS2_INFO(tx_bytes),\n\tXGBE_STATS2_INFO(tx_64byte_frames),\n\tXGBE_STATS2_INFO(tx_65_to_127byte_frames),\n\tXGBE_STATS2_INFO(tx_128_to_255byte_frames),\n\tXGBE_STATS2_INFO(tx_256_to_511byte_frames),\n\tXGBE_STATS2_INFO(tx_512_to_1023byte_frames),\n\tXGBE_STATS2_INFO(tx_1024byte_frames),\n\tXGBE_STATS2_INFO(net_bytes),\n\tXGBE_STATS2_INFO(rx_sof_overruns),\n\tXGBE_STATS2_INFO(rx_mof_overruns),\n\tXGBE_STATS2_INFO(rx_dma_overruns),\n};\n\n#define for_each_intf(i, priv) \\\n\tlist_for_each_entry((i), &(priv)->gbe_intf_head, gbe_intf_list)\n\n#define for_each_sec_slave(slave, priv) \\\n\tlist_for_each_entry((slave), &(priv)->secondary_slaves, slave_list)\n\n#define first_sec_slave(priv)\t\t\t\t\t\\\n\tlist_first_entry(&priv->secondary_slaves, \\\n\t\t\tstruct gbe_slave, slave_list)\n\nstatic void keystone_get_drvinfo(struct net_device *ndev,\n\t\t\t\t struct ethtool_drvinfo *info)\n{\n\tstrncpy(info->driver, NETCP_DRIVER_NAME, sizeof(info->driver));\n\tstrncpy(info->version, NETCP_DRIVER_VERSION, sizeof(info->version));\n}\n\nstatic u32 keystone_get_msglevel(struct net_device *ndev)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\n\treturn netcp->msg_enable;\n}\n\nstatic void keystone_set_msglevel(struct net_device *ndev, u32 value)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\n\tnetcp->msg_enable = value;\n}\n\nstatic struct gbe_intf *keystone_get_intf_data(struct netcp_intf *netcp)\n{\n\tstruct gbe_intf *gbe_intf;\n\n\tgbe_intf = netcp_module_get_intf_data(&gbe_module, netcp);\n\tif (!gbe_intf)\n\t\tgbe_intf = netcp_module_get_intf_data(&xgbe_module, netcp);\n\n\treturn gbe_intf;\n}\n\nstatic void keystone_get_stat_strings(struct net_device *ndev,\n\t\t\t\t      uint32_t stringset, uint8_t *data)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct gbe_intf *gbe_intf;\n\tstruct gbe_priv *gbe_dev;\n\tint i;\n\n\tgbe_intf = keystone_get_intf_data(netcp);\n\tif (!gbe_intf)\n\t\treturn;\n\tgbe_dev = gbe_intf->gbe_dev;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < gbe_dev->num_et_stats; i++) {\n\t\t\tmemcpy(data, gbe_dev->et_stats[i].desc,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tbreak;\n\t}\n}\n\nstatic int keystone_get_sset_count(struct net_device *ndev, int stringset)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct gbe_intf *gbe_intf;\n\tstruct gbe_priv *gbe_dev;\n\n\tgbe_intf = keystone_get_intf_data(netcp);\n\tif (!gbe_intf)\n\t\treturn -EINVAL;\n\tgbe_dev = gbe_intf->gbe_dev;\n\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\treturn 0;\n\tcase ETH_SS_STATS:\n\t\treturn gbe_dev->num_et_stats;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void gbe_reset_mod_stats(struct gbe_priv *gbe_dev, int stats_mod)\n{\n\tvoid __iomem *base = gbe_dev->hw_stats_regs[stats_mod];\n\tu32  __iomem *p_stats_entry;\n\tint i;\n\n\tfor (i = 0; i < gbe_dev->num_et_stats; i++) {\n\t\tif (gbe_dev->et_stats[i].type == stats_mod) {\n\t\t\tp_stats_entry = base + gbe_dev->et_stats[i].offset;\n\t\t\tgbe_dev->hw_stats[i] = 0;\n\t\t\tgbe_dev->hw_stats_prev[i] = readl(p_stats_entry);\n\t\t}\n\t}\n}\n\nstatic inline void gbe_update_hw_stats_entry(struct gbe_priv *gbe_dev,\n\t\t\t\t\t     int et_stats_entry)\n{\n\tvoid __iomem *base = NULL;\n\tu32  __iomem *p_stats_entry;\n\tu32 curr, delta;\n\n\t \n\tbase = gbe_dev->hw_stats_regs[gbe_dev->et_stats[et_stats_entry].type];\n\tp_stats_entry = base + gbe_dev->et_stats[et_stats_entry].offset;\n\tcurr = readl(p_stats_entry);\n\tdelta = curr - gbe_dev->hw_stats_prev[et_stats_entry];\n\tgbe_dev->hw_stats_prev[et_stats_entry] = curr;\n\tgbe_dev->hw_stats[et_stats_entry] += delta;\n}\n\nstatic void gbe_update_stats(struct gbe_priv *gbe_dev, uint64_t *data)\n{\n\tint i;\n\n\tfor (i = 0; i < gbe_dev->num_et_stats; i++) {\n\t\tgbe_update_hw_stats_entry(gbe_dev, i);\n\n\t\tif (data)\n\t\t\tdata[i] = gbe_dev->hw_stats[i];\n\t}\n}\n\nstatic inline void gbe_stats_mod_visible_ver14(struct gbe_priv *gbe_dev,\n\t\t\t\t\t       int stats_mod)\n{\n\tu32 val;\n\n\tval = readl(GBE_REG_ADDR(gbe_dev, switch_regs, stat_port_en));\n\n\tswitch (stats_mod) {\n\tcase GBE_STATSA_MODULE:\n\tcase GBE_STATSB_MODULE:\n\t\tval &= ~GBE_STATS_CD_SEL;\n\t\tbreak;\n\tcase GBE_STATSC_MODULE:\n\tcase GBE_STATSD_MODULE:\n\t\tval |= GBE_STATS_CD_SEL;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\twritel(val, GBE_REG_ADDR(gbe_dev, switch_regs, stat_port_en));\n}\n\nstatic void gbe_reset_mod_stats_ver14(struct gbe_priv *gbe_dev, int stats_mod)\n{\n\tgbe_stats_mod_visible_ver14(gbe_dev, stats_mod);\n\tgbe_reset_mod_stats(gbe_dev, stats_mod);\n}\n\nstatic void gbe_update_stats_ver14(struct gbe_priv *gbe_dev, uint64_t *data)\n{\n\tu32 half_num_et_stats = (gbe_dev->num_et_stats / 2);\n\tint et_entry, j, pair;\n\n\tfor (pair = 0; pair < 2; pair++) {\n\t\tgbe_stats_mod_visible_ver14(gbe_dev, (pair ?\n\t\t\t\t\t\t      GBE_STATSC_MODULE :\n\t\t\t\t\t\t      GBE_STATSA_MODULE));\n\n\t\tfor (j = 0; j < half_num_et_stats; j++) {\n\t\t\tet_entry = pair * half_num_et_stats + j;\n\t\t\tgbe_update_hw_stats_entry(gbe_dev, et_entry);\n\n\t\t\tif (data)\n\t\t\t\tdata[et_entry] = gbe_dev->hw_stats[et_entry];\n\t\t}\n\t}\n}\n\nstatic void keystone_get_ethtool_stats(struct net_device *ndev,\n\t\t\t\t       struct ethtool_stats *stats,\n\t\t\t\t       uint64_t *data)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct gbe_intf *gbe_intf;\n\tstruct gbe_priv *gbe_dev;\n\n\tgbe_intf = keystone_get_intf_data(netcp);\n\tif (!gbe_intf)\n\t\treturn;\n\n\tgbe_dev = gbe_intf->gbe_dev;\n\tspin_lock_bh(&gbe_dev->hw_stats_lock);\n\tif (IS_SS_ID_VER_14(gbe_dev))\n\t\tgbe_update_stats_ver14(gbe_dev, data);\n\telse\n\t\tgbe_update_stats(gbe_dev, data);\n\tspin_unlock_bh(&gbe_dev->hw_stats_lock);\n}\n\nstatic int keystone_get_link_ksettings(struct net_device *ndev,\n\t\t\t\t       struct ethtool_link_ksettings *cmd)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct phy_device *phy = ndev->phydev;\n\tstruct gbe_intf *gbe_intf;\n\n\tif (!phy)\n\t\treturn -EINVAL;\n\n\tgbe_intf = keystone_get_intf_data(netcp);\n\tif (!gbe_intf)\n\t\treturn -EINVAL;\n\n\tif (!gbe_intf->slave)\n\t\treturn -EINVAL;\n\n\tphy_ethtool_ksettings_get(phy, cmd);\n\tcmd->base.port = gbe_intf->slave->phy_port_t;\n\n\treturn 0;\n}\n\nstatic int keystone_set_link_ksettings(struct net_device *ndev,\n\t\t\t\t       const struct ethtool_link_ksettings *cmd)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct phy_device *phy = ndev->phydev;\n\tstruct gbe_intf *gbe_intf;\n\tu8 port = cmd->base.port;\n\tu32 advertising, supported;\n\tu32 features;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\tethtool_convert_link_mode_to_legacy_u32(&supported,\n\t\t\t\t\t\tcmd->link_modes.supported);\n\tfeatures = advertising & supported;\n\n\tif (!phy)\n\t\treturn -EINVAL;\n\n\tgbe_intf = keystone_get_intf_data(netcp);\n\tif (!gbe_intf)\n\t\treturn -EINVAL;\n\n\tif (!gbe_intf->slave)\n\t\treturn -EINVAL;\n\n\tif (port != gbe_intf->slave->phy_port_t) {\n\t\tif ((port == PORT_TP) && !(features & ADVERTISED_TP))\n\t\t\treturn -EINVAL;\n\n\t\tif ((port == PORT_AUI) && !(features & ADVERTISED_AUI))\n\t\t\treturn -EINVAL;\n\n\t\tif ((port == PORT_BNC) && !(features & ADVERTISED_BNC))\n\t\t\treturn -EINVAL;\n\n\t\tif ((port == PORT_MII) && !(features & ADVERTISED_MII))\n\t\t\treturn -EINVAL;\n\n\t\tif ((port == PORT_FIBRE) && !(features & ADVERTISED_FIBRE))\n\t\t\treturn -EINVAL;\n\t}\n\n\tgbe_intf->slave->phy_port_t = port;\n\treturn phy_ethtool_ksettings_set(phy, cmd);\n}\n\n#if IS_ENABLED(CONFIG_TI_CPTS)\nstatic int keystone_get_ts_info(struct net_device *ndev,\n\t\t\t\tstruct ethtool_ts_info *info)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct gbe_intf *gbe_intf;\n\n\tgbe_intf = netcp_module_get_intf_data(&gbe_module, netcp);\n\tif (!gbe_intf || !gbe_intf->gbe_dev->cpts)\n\t\treturn -EINVAL;\n\n\tinfo->so_timestamping =\n\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tinfo->phc_index = gbe_intf->gbe_dev->cpts->phc_index;\n\tinfo->tx_types =\n\t\t(1 << HWTSTAMP_TX_OFF) |\n\t\t(1 << HWTSTAMP_TX_ON);\n\tinfo->rx_filters =\n\t\t(1 << HWTSTAMP_FILTER_NONE) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_EVENT);\n\treturn 0;\n}\n#else\nstatic int keystone_get_ts_info(struct net_device *ndev,\n\t\t\t\tstruct ethtool_ts_info *info)\n{\n\tinfo->so_timestamping =\n\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_SOFTWARE;\n\tinfo->phc_index = -1;\n\tinfo->tx_types = 0;\n\tinfo->rx_filters = 0;\n\treturn 0;\n}\n#endif  \n\nstatic const struct ethtool_ops keystone_ethtool_ops = {\n\t.get_drvinfo\t\t= keystone_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_msglevel\t\t= keystone_get_msglevel,\n\t.set_msglevel\t\t= keystone_set_msglevel,\n\t.get_strings\t\t= keystone_get_stat_strings,\n\t.get_sset_count\t\t= keystone_get_sset_count,\n\t.get_ethtool_stats\t= keystone_get_ethtool_stats,\n\t.get_link_ksettings\t= keystone_get_link_ksettings,\n\t.set_link_ksettings\t= keystone_set_link_ksettings,\n\t.get_ts_info\t\t= keystone_get_ts_info,\n};\n\nstatic void gbe_set_slave_mac(struct gbe_slave *slave,\n\t\t\t      struct gbe_intf *gbe_intf)\n{\n\tstruct net_device *ndev = gbe_intf->ndev;\n\n\twritel(mac_hi(ndev->dev_addr), GBE_REG_ADDR(slave, port_regs, sa_hi));\n\twritel(mac_lo(ndev->dev_addr), GBE_REG_ADDR(slave, port_regs, sa_lo));\n}\n\nstatic int gbe_get_slave_port(struct gbe_priv *priv, u32 slave_num)\n{\n\tif (priv->host_port == 0)\n\t\treturn slave_num + 1;\n\n\treturn slave_num;\n}\n\nstatic void netcp_ethss_link_state_action(struct gbe_priv *gbe_dev,\n\t\t\t\t\t  struct net_device *ndev,\n\t\t\t\t\t  struct gbe_slave *slave,\n\t\t\t\t\t  int up)\n{\n\tstruct phy_device *phy = slave->phy;\n\tu32 mac_control = 0;\n\n\tif (up) {\n\t\tmac_control = slave->mac_control;\n\t\tif (phy && (phy->speed == SPEED_1000)) {\n\t\t\tmac_control |= MACSL_GIG_MODE;\n\t\t\tmac_control &= ~MACSL_XGIG_MODE;\n\t\t} else if (phy && (phy->speed == SPEED_10000)) {\n\t\t\tmac_control |= MACSL_XGIG_MODE;\n\t\t\tmac_control &= ~MACSL_GIG_MODE;\n\t\t}\n\n\t\twritel(mac_control, GBE_REG_ADDR(slave, emac_regs,\n\t\t\t\t\t\t mac_control));\n\n\t\tcpsw_ale_control_set(gbe_dev->ale, slave->port_num,\n\t\t\t\t     ALE_PORT_STATE,\n\t\t\t\t     ALE_PORT_STATE_FORWARD);\n\n\t\tif (ndev && slave->open &&\n\t\t    ((slave->link_interface != SGMII_LINK_MAC_PHY) &&\n\t\t    (slave->link_interface != RGMII_LINK_MAC_PHY) &&\n\t\t    (slave->link_interface != XGMII_LINK_MAC_PHY)))\n\t\t\tnetif_carrier_on(ndev);\n\t} else {\n\t\twritel(mac_control, GBE_REG_ADDR(slave, emac_regs,\n\t\t\t\t\t\t mac_control));\n\t\tcpsw_ale_control_set(gbe_dev->ale, slave->port_num,\n\t\t\t\t     ALE_PORT_STATE,\n\t\t\t\t     ALE_PORT_STATE_DISABLE);\n\t\tif (ndev &&\n\t\t    ((slave->link_interface != SGMII_LINK_MAC_PHY) &&\n\t\t    (slave->link_interface != RGMII_LINK_MAC_PHY) &&\n\t\t    (slave->link_interface != XGMII_LINK_MAC_PHY)))\n\t\t\tnetif_carrier_off(ndev);\n\t}\n\n\tif (phy)\n\t\tphy_print_status(phy);\n}\n\nstatic bool gbe_phy_link_status(struct gbe_slave *slave)\n{\n\t return !slave->phy || slave->phy->link;\n}\n\n#define RGMII_REG_STATUS_LINK\tBIT(0)\n\nstatic void netcp_2u_rgmii_get_port_link(struct gbe_priv *gbe_dev, bool *status)\n{\n\tu32 val = 0;\n\n\tval = readl(GBE_REG_ADDR(gbe_dev, ss_regs, rgmii_status));\n\t*status = !!(val & RGMII_REG_STATUS_LINK);\n}\n\nstatic void netcp_ethss_update_link_state(struct gbe_priv *gbe_dev,\n\t\t\t\t\t  struct gbe_slave *slave,\n\t\t\t\t\t  struct net_device *ndev)\n{\n\tbool sw_link_state = true, phy_link_state;\n\tint sp = slave->slave_num, link_state;\n\n\tif (!slave->open)\n\t\treturn;\n\n\tif (SLAVE_LINK_IS_RGMII(slave))\n\t\tnetcp_2u_rgmii_get_port_link(gbe_dev,\n\t\t\t\t\t     &sw_link_state);\n\tif (SLAVE_LINK_IS_SGMII(slave))\n\t\tsw_link_state =\n\t\tnetcp_sgmii_get_port_link(SGMII_BASE(gbe_dev, sp), sp);\n\n\tphy_link_state = gbe_phy_link_status(slave);\n\tlink_state = phy_link_state & sw_link_state;\n\n\tif (atomic_xchg(&slave->link_state, link_state) != link_state)\n\t\tnetcp_ethss_link_state_action(gbe_dev, ndev, slave,\n\t\t\t\t\t      link_state);\n}\n\nstatic void xgbe_adjust_link(struct net_device *ndev)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct gbe_intf *gbe_intf;\n\n\tgbe_intf = netcp_module_get_intf_data(&xgbe_module, netcp);\n\tif (!gbe_intf)\n\t\treturn;\n\n\tnetcp_ethss_update_link_state(gbe_intf->gbe_dev, gbe_intf->slave,\n\t\t\t\t      ndev);\n}\n\nstatic void gbe_adjust_link(struct net_device *ndev)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct gbe_intf *gbe_intf;\n\n\tgbe_intf = netcp_module_get_intf_data(&gbe_module, netcp);\n\tif (!gbe_intf)\n\t\treturn;\n\n\tnetcp_ethss_update_link_state(gbe_intf->gbe_dev, gbe_intf->slave,\n\t\t\t\t      ndev);\n}\n\nstatic void gbe_adjust_link_sec_slaves(struct net_device *ndev)\n{\n\tstruct gbe_priv *gbe_dev = netdev_priv(ndev);\n\tstruct gbe_slave *slave;\n\n\tfor_each_sec_slave(slave, gbe_dev)\n\t\tnetcp_ethss_update_link_state(gbe_dev, slave, NULL);\n}\n\n \nstatic int gbe_port_reset(struct gbe_slave *slave)\n{\n\tu32 i, v;\n\n\t \n\twritel(SOFT_RESET, GBE_REG_ADDR(slave, emac_regs, soft_reset));\n\n\t \n\tfor (i = 0; i < DEVICE_EMACSL_RESET_POLL_COUNT; i++) {\n\t\tv = readl(GBE_REG_ADDR(slave, emac_regs, soft_reset));\n\t\tif ((v & SOFT_RESET_MASK) != SOFT_RESET)\n\t\t\treturn 0;\n\t}\n\n\t \n\treturn GMACSL_RET_WARN_RESET_INCOMPLETE;\n}\n\n \nstatic void gbe_port_config(struct gbe_priv *gbe_dev, struct gbe_slave *slave,\n\t\t\t    int max_rx_len)\n{\n\tvoid __iomem *rx_maxlen_reg;\n\tu32 xgmii_mode;\n\n\tif (max_rx_len > NETCP_MAX_FRAME_SIZE)\n\t\tmax_rx_len = NETCP_MAX_FRAME_SIZE;\n\n\t \n\tif (IS_SS_ID_XGBE(gbe_dev) &&\n\t    (slave->link_interface >= XGMII_LINK_MAC_PHY)) {\n\t\txgmii_mode = readl(GBE_REG_ADDR(gbe_dev, ss_regs, control));\n\t\txgmii_mode |= (1 << slave->slave_num);\n\t\twritel(xgmii_mode, GBE_REG_ADDR(gbe_dev, ss_regs, control));\n\t}\n\n\tif (IS_SS_ID_MU(gbe_dev))\n\t\trx_maxlen_reg = GBE_REG_ADDR(slave, port_regs, rx_maxlen);\n\telse\n\t\trx_maxlen_reg = GBE_REG_ADDR(slave, emac_regs, rx_maxlen);\n\n\twritel(max_rx_len, rx_maxlen_reg);\n\twritel(slave->mac_control, GBE_REG_ADDR(slave, emac_regs, mac_control));\n}\n\nstatic void gbe_sgmii_rtreset(struct gbe_priv *priv,\n\t\t\t      struct gbe_slave *slave, bool set)\n{\n\tif (SLAVE_LINK_IS_XGMII(slave))\n\t\treturn;\n\n\tnetcp_sgmii_rtreset(SGMII_BASE(priv, slave->slave_num),\n\t\t\t    slave->slave_num, set);\n}\n\nstatic void gbe_slave_stop(struct gbe_intf *intf)\n{\n\tstruct gbe_priv *gbe_dev = intf->gbe_dev;\n\tstruct gbe_slave *slave = intf->slave;\n\n\tif (!IS_SS_ID_2U(gbe_dev))\n\t\tgbe_sgmii_rtreset(gbe_dev, slave, true);\n\tgbe_port_reset(slave);\n\t \n\tcpsw_ale_control_set(gbe_dev->ale, slave->port_num,\n\t\t\t     ALE_PORT_STATE, ALE_PORT_STATE_DISABLE);\n\tcpsw_ale_del_mcast(gbe_dev->ale, intf->ndev->broadcast,\n\t\t\t   1 << slave->port_num, 0, 0);\n\n\tif (!slave->phy)\n\t\treturn;\n\n\tphy_stop(slave->phy);\n\tphy_disconnect(slave->phy);\n\tslave->phy = NULL;\n}\n\nstatic void gbe_sgmii_config(struct gbe_priv *priv, struct gbe_slave *slave)\n{\n\tif (SLAVE_LINK_IS_XGMII(slave))\n\t\treturn;\n\n\tnetcp_sgmii_reset(SGMII_BASE(priv, slave->slave_num), slave->slave_num);\n\tnetcp_sgmii_config(SGMII_BASE(priv, slave->slave_num), slave->slave_num,\n\t\t\t   slave->link_interface);\n}\n\nstatic int gbe_slave_open(struct gbe_intf *gbe_intf)\n{\n\tstruct gbe_priv *priv = gbe_intf->gbe_dev;\n\tstruct gbe_slave *slave = gbe_intf->slave;\n\tphy_interface_t phy_mode;\n\tbool has_phy = false;\n\tint err;\n\n\tvoid (*hndlr)(struct net_device *) = gbe_adjust_link;\n\n\tif (!IS_SS_ID_2U(priv))\n\t\tgbe_sgmii_config(priv, slave);\n\tgbe_port_reset(slave);\n\tif (!IS_SS_ID_2U(priv))\n\t\tgbe_sgmii_rtreset(priv, slave, false);\n\tgbe_port_config(priv, slave, priv->rx_packet_max);\n\tgbe_set_slave_mac(slave, gbe_intf);\n\t \n\tif (IS_SS_ID_MU(priv))\n\t\twritel(HOST_TX_PRI_MAP_DEFAULT,\n\t\t       GBE_REG_ADDR(slave, port_regs, rx_pri_map));\n\n\t \n\tcpsw_ale_control_set(priv->ale, slave->port_num,\n\t\t\t     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);\n\tcpsw_ale_add_mcast(priv->ale, gbe_intf->ndev->broadcast,\n\t\t\t   1 << slave->port_num, 0, 0, ALE_MCAST_FWD_2);\n\n\tif (slave->link_interface == SGMII_LINK_MAC_PHY) {\n\t\thas_phy = true;\n\t\tphy_mode = PHY_INTERFACE_MODE_SGMII;\n\t\tslave->phy_port_t = PORT_MII;\n\t} else if (slave->link_interface == RGMII_LINK_MAC_PHY) {\n\t\thas_phy = true;\n\t\terr = of_get_phy_mode(slave->node, &phy_mode);\n\t\t \n\t\tif (err)\n\t\t\tphy_mode = PHY_INTERFACE_MODE_RGMII;\n\n\t\tif (!phy_interface_mode_is_rgmii(phy_mode)) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"Unsupported phy mode %d\\n\", phy_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tslave->phy_port_t = PORT_MII;\n\t} else if (slave->link_interface == XGMII_LINK_MAC_PHY) {\n\t\thas_phy = true;\n\t\tphy_mode = PHY_INTERFACE_MODE_NA;\n\t\tslave->phy_port_t = PORT_FIBRE;\n\t}\n\n\tif (has_phy) {\n\t\tif (IS_SS_ID_XGBE(priv))\n\t\t\thndlr = xgbe_adjust_link;\n\n\t\tslave->phy = of_phy_connect(gbe_intf->ndev,\n\t\t\t\t\t    slave->phy_node,\n\t\t\t\t\t    hndlr, 0,\n\t\t\t\t\t    phy_mode);\n\t\tif (!slave->phy) {\n\t\t\tdev_err(priv->dev, \"phy not found on slave %d\\n\",\n\t\t\t\tslave->slave_num);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tdev_dbg(priv->dev, \"phy found: id is: 0x%s\\n\",\n\t\t\tphydev_name(slave->phy));\n\t\tphy_start(slave->phy);\n\t}\n\treturn 0;\n}\n\nstatic void gbe_init_host_port(struct gbe_priv *priv)\n{\n\tint bypass_en = 1;\n\n\t \n\tif (IS_SS_ID_NU(priv) || IS_SS_ID_XGBE(priv))\n\t\twritel(HOST_TX_PRI_MAP_DEFAULT,\n\t\t       GBE_REG_ADDR(priv, host_port_regs, tx_pri_map));\n\n\t \n\twritel(NETCP_MAX_FRAME_SIZE, GBE_REG_ADDR(priv, host_port_regs,\n\t\t\t\t\t\t  rx_maxlen));\n\n\tcpsw_ale_start(priv->ale);\n\n\tif (priv->enable_ale)\n\t\tbypass_en = 0;\n\n\tcpsw_ale_control_set(priv->ale, 0, ALE_BYPASS, bypass_en);\n\n\tcpsw_ale_control_set(priv->ale, 0, ALE_NO_PORT_VLAN, 1);\n\n\tcpsw_ale_control_set(priv->ale, priv->host_port,\n\t\t\t     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);\n\n\tcpsw_ale_control_set(priv->ale, 0,\n\t\t\t     ALE_PORT_UNKNOWN_VLAN_MEMBER,\n\t\t\t     GBE_PORT_MASK(priv->ale_ports));\n\n\tcpsw_ale_control_set(priv->ale, 0,\n\t\t\t     ALE_PORT_UNKNOWN_MCAST_FLOOD,\n\t\t\t     GBE_PORT_MASK(priv->ale_ports - 1));\n\n\tcpsw_ale_control_set(priv->ale, 0,\n\t\t\t     ALE_PORT_UNKNOWN_REG_MCAST_FLOOD,\n\t\t\t     GBE_PORT_MASK(priv->ale_ports));\n\n\tcpsw_ale_control_set(priv->ale, 0,\n\t\t\t     ALE_PORT_UNTAGGED_EGRESS,\n\t\t\t     GBE_PORT_MASK(priv->ale_ports));\n}\n\nstatic void gbe_add_mcast_addr(struct gbe_intf *gbe_intf, u8 *addr)\n{\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\tu16 vlan_id;\n\n\tcpsw_ale_add_mcast(gbe_dev->ale, addr,\n\t\t\t   GBE_PORT_MASK(gbe_dev->ale_ports), 0, 0,\n\t\t\t   ALE_MCAST_FWD_2);\n\tfor_each_set_bit(vlan_id, gbe_intf->active_vlans, VLAN_N_VID) {\n\t\tcpsw_ale_add_mcast(gbe_dev->ale, addr,\n\t\t\t\t   GBE_PORT_MASK(gbe_dev->ale_ports),\n\t\t\t\t   ALE_VLAN, vlan_id, ALE_MCAST_FWD_2);\n\t}\n}\n\nstatic void gbe_add_ucast_addr(struct gbe_intf *gbe_intf, u8 *addr)\n{\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\tu16 vlan_id;\n\n\tcpsw_ale_add_ucast(gbe_dev->ale, addr, gbe_dev->host_port, 0, 0);\n\n\tfor_each_set_bit(vlan_id, gbe_intf->active_vlans, VLAN_N_VID)\n\t\tcpsw_ale_add_ucast(gbe_dev->ale, addr, gbe_dev->host_port,\n\t\t\t\t   ALE_VLAN, vlan_id);\n}\n\nstatic void gbe_del_mcast_addr(struct gbe_intf *gbe_intf, u8 *addr)\n{\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\tu16 vlan_id;\n\n\tcpsw_ale_del_mcast(gbe_dev->ale, addr, 0, 0, 0);\n\n\tfor_each_set_bit(vlan_id, gbe_intf->active_vlans, VLAN_N_VID) {\n\t\tcpsw_ale_del_mcast(gbe_dev->ale, addr, 0, ALE_VLAN, vlan_id);\n\t}\n}\n\nstatic void gbe_del_ucast_addr(struct gbe_intf *gbe_intf, u8 *addr)\n{\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\tu16 vlan_id;\n\n\tcpsw_ale_del_ucast(gbe_dev->ale, addr, gbe_dev->host_port, 0, 0);\n\n\tfor_each_set_bit(vlan_id, gbe_intf->active_vlans, VLAN_N_VID) {\n\t\tcpsw_ale_del_ucast(gbe_dev->ale, addr, gbe_dev->host_port,\n\t\t\t\t   ALE_VLAN, vlan_id);\n\t}\n}\n\nstatic int gbe_add_addr(void *intf_priv, struct netcp_addr *naddr)\n{\n\tstruct gbe_intf *gbe_intf = intf_priv;\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\n\tdev_dbg(gbe_dev->dev, \"ethss adding address %pM, type %d\\n\",\n\t\tnaddr->addr, naddr->type);\n\n\tswitch (naddr->type) {\n\tcase ADDR_MCAST:\n\tcase ADDR_BCAST:\n\t\tgbe_add_mcast_addr(gbe_intf, naddr->addr);\n\t\tbreak;\n\tcase ADDR_UCAST:\n\tcase ADDR_DEV:\n\t\tgbe_add_ucast_addr(gbe_intf, naddr->addr);\n\t\tbreak;\n\tcase ADDR_ANY:\n\t\t \n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int gbe_del_addr(void *intf_priv, struct netcp_addr *naddr)\n{\n\tstruct gbe_intf *gbe_intf = intf_priv;\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\n\tdev_dbg(gbe_dev->dev, \"ethss deleting address %pM, type %d\\n\",\n\t\tnaddr->addr, naddr->type);\n\n\tswitch (naddr->type) {\n\tcase ADDR_MCAST:\n\tcase ADDR_BCAST:\n\t\tgbe_del_mcast_addr(gbe_intf, naddr->addr);\n\t\tbreak;\n\tcase ADDR_UCAST:\n\tcase ADDR_DEV:\n\t\tgbe_del_ucast_addr(gbe_intf, naddr->addr);\n\t\tbreak;\n\tcase ADDR_ANY:\n\t\t \n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int gbe_add_vid(void *intf_priv, int vid)\n{\n\tstruct gbe_intf *gbe_intf = intf_priv;\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\n\tset_bit(vid, gbe_intf->active_vlans);\n\n\tcpsw_ale_add_vlan(gbe_dev->ale, vid,\n\t\t\t  GBE_PORT_MASK(gbe_dev->ale_ports),\n\t\t\t  GBE_MASK_NO_PORTS,\n\t\t\t  GBE_PORT_MASK(gbe_dev->ale_ports),\n\t\t\t  GBE_PORT_MASK(gbe_dev->ale_ports - 1));\n\n\treturn 0;\n}\n\nstatic int gbe_del_vid(void *intf_priv, int vid)\n{\n\tstruct gbe_intf *gbe_intf = intf_priv;\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\n\tcpsw_ale_del_vlan(gbe_dev->ale, vid, 0);\n\tclear_bit(vid, gbe_intf->active_vlans);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_TI_CPTS)\n\nstatic void gbe_txtstamp(void *context, struct sk_buff *skb)\n{\n\tstruct gbe_intf *gbe_intf = context;\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\n\tcpts_tx_timestamp(gbe_dev->cpts, skb);\n}\n\nstatic bool gbe_need_txtstamp(struct gbe_intf *gbe_intf,\n\t\t\t      const struct netcp_packet *p_info)\n{\n\tstruct sk_buff *skb = p_info->skb;\n\n\treturn cpts_can_timestamp(gbe_intf->gbe_dev->cpts, skb);\n}\n\nstatic int gbe_txtstamp_mark_pkt(struct gbe_intf *gbe_intf,\n\t\t\t\t struct netcp_packet *p_info)\n{\n\tstruct phy_device *phydev = p_info->skb->dev->phydev;\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\n\tif (!(skb_shinfo(p_info->skb)->tx_flags & SKBTX_HW_TSTAMP) ||\n\t    !gbe_dev->tx_ts_enabled)\n\t\treturn 0;\n\n\t \n\tif (phy_has_txtstamp(phydev)) {\n\t\tskb_shinfo(p_info->skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\treturn 0;\n\t}\n\n\tif (gbe_need_txtstamp(gbe_intf, p_info)) {\n\t\tp_info->txtstamp = gbe_txtstamp;\n\t\tp_info->ts_context = (void *)gbe_intf;\n\t\tskb_shinfo(p_info->skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t}\n\n\treturn 0;\n}\n\nstatic int gbe_rxtstamp(struct gbe_intf *gbe_intf, struct netcp_packet *p_info)\n{\n\tstruct phy_device *phydev = p_info->skb->dev->phydev;\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\n\tif (p_info->rxtstamp_complete)\n\t\treturn 0;\n\n\tif (phy_has_rxtstamp(phydev)) {\n\t\tp_info->rxtstamp_complete = true;\n\t\treturn 0;\n\t}\n\n\tif (gbe_dev->rx_ts_enabled)\n\t\tcpts_rx_timestamp(gbe_dev->cpts, p_info->skb);\n\n\tp_info->rxtstamp_complete = true;\n\n\treturn 0;\n}\n\nstatic int gbe_hwtstamp_get(struct gbe_intf *gbe_intf, struct ifreq *ifr)\n{\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\tstruct cpts *cpts = gbe_dev->cpts;\n\tstruct hwtstamp_config cfg;\n\n\tif (!cpts)\n\t\treturn -EOPNOTSUPP;\n\n\tcfg.flags = 0;\n\tcfg.tx_type = gbe_dev->tx_ts_enabled ? HWTSTAMP_TX_ON : HWTSTAMP_TX_OFF;\n\tcfg.rx_filter = gbe_dev->rx_ts_enabled;\n\n\treturn copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\n}\n\nstatic void gbe_hwtstamp(struct gbe_intf *gbe_intf)\n{\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\tstruct gbe_slave *slave = gbe_intf->slave;\n\tu32 ts_en, seq_id, ctl;\n\n\tif (!gbe_dev->rx_ts_enabled &&\n\t    !gbe_dev->tx_ts_enabled) {\n\t\twritel(0, GBE_REG_ADDR(slave, port_regs, ts_ctl));\n\t\treturn;\n\t}\n\n\tseq_id = (30 << TS_SEQ_ID_OFS_SHIFT) | ETH_P_1588;\n\tts_en = EVENT_MSG_BITS << TS_MSG_TYPE_EN_SHIFT;\n\tctl = ETH_P_1588 | TS_TTL_NONZERO |\n\t\t(slave->ts_ctl.dst_port_map << TS_CTL_DST_PORT_SHIFT) |\n\t\t(slave->ts_ctl.uni ?  TS_UNI_EN :\n\t\t\tslave->ts_ctl.maddr_map << TS_CTL_MADDR_SHIFT);\n\n\tif (gbe_dev->tx_ts_enabled)\n\t\tts_en |= (TS_TX_ANX_ALL_EN | TS_TX_VLAN_LT1_EN);\n\n\tif (gbe_dev->rx_ts_enabled)\n\t\tts_en |= (TS_RX_ANX_ALL_EN | TS_RX_VLAN_LT1_EN);\n\n\twritel(ts_en,  GBE_REG_ADDR(slave, port_regs, ts_ctl));\n\twritel(seq_id, GBE_REG_ADDR(slave, port_regs, ts_seq_ltype));\n\twritel(ctl,    GBE_REG_ADDR(slave, port_regs, ts_ctl_ltype2));\n}\n\nstatic int gbe_hwtstamp_set(struct gbe_intf *gbe_intf, struct ifreq *ifr)\n{\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\tstruct cpts *cpts = gbe_dev->cpts;\n\tstruct hwtstamp_config cfg;\n\n\tif (!cpts)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))\n\t\treturn -EFAULT;\n\n\tswitch (cfg.tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\tgbe_dev->tx_ts_enabled = 0;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tgbe_dev->tx_ts_enabled = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (cfg.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tgbe_dev->rx_ts_enabled = HWTSTAMP_FILTER_NONE;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\tgbe_dev->rx_ts_enabled = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\n\t\tcfg.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\tgbe_dev->rx_ts_enabled = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tcfg.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tgbe_hwtstamp(gbe_intf);\n\n\treturn copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\n}\n\nstatic void gbe_register_cpts(struct gbe_priv *gbe_dev)\n{\n\tif (!gbe_dev->cpts)\n\t\treturn;\n\n\tif (gbe_dev->cpts_registered > 0)\n\t\tgoto done;\n\n\tif (cpts_register(gbe_dev->cpts)) {\n\t\tdev_err(gbe_dev->dev, \"error registering cpts device\\n\");\n\t\treturn;\n\t}\n\ndone:\n\t++gbe_dev->cpts_registered;\n}\n\nstatic void gbe_unregister_cpts(struct gbe_priv *gbe_dev)\n{\n\tif (!gbe_dev->cpts || (gbe_dev->cpts_registered <= 0))\n\t\treturn;\n\n\tif (--gbe_dev->cpts_registered)\n\t\treturn;\n\n\tcpts_unregister(gbe_dev->cpts);\n}\n#else\nstatic inline int gbe_txtstamp_mark_pkt(struct gbe_intf *gbe_intf,\n\t\t\t\t\tstruct netcp_packet *p_info)\n{\n\treturn 0;\n}\n\nstatic inline int gbe_rxtstamp(struct gbe_intf *gbe_intf,\n\t\t\t       struct netcp_packet *p_info)\n{\n\treturn 0;\n}\n\nstatic inline int gbe_hwtstamp(struct gbe_intf *gbe_intf,\n\t\t\t       struct ifreq *ifr, int cmd)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void gbe_register_cpts(struct gbe_priv *gbe_dev)\n{\n}\n\nstatic inline void gbe_unregister_cpts(struct gbe_priv *gbe_dev)\n{\n}\n\nstatic inline int gbe_hwtstamp_get(struct gbe_intf *gbe_intf, struct ifreq *req)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int gbe_hwtstamp_set(struct gbe_intf *gbe_intf, struct ifreq *req)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif  \n\nstatic int gbe_set_rx_mode(void *intf_priv, bool promisc)\n{\n\tstruct gbe_intf *gbe_intf = intf_priv;\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\tstruct cpsw_ale *ale = gbe_dev->ale;\n\tunsigned long timeout;\n\tint i, ret = -ETIMEDOUT;\n\n\t \n\tfor (i = 0; i <= gbe_dev->num_slaves; i++) {\n\t\tcpsw_ale_control_set(ale, i,\n\t\t\t\t     ALE_PORT_NOLEARN, !!promisc);\n\t\tcpsw_ale_control_set(ale, i,\n\t\t\t\t     ALE_PORT_NO_SA_UPDATE, !!promisc);\n\t}\n\n\tif (!promisc) {\n\t\t \n\t\tcpsw_ale_control_set(ale, 0, ALE_P0_UNI_FLOOD, 0);\n\t\tdev_vdbg(gbe_dev->dev, \"promiscuous mode disabled\\n\");\n\t\treturn 0;\n\t}\n\n\ttimeout = jiffies + HZ;\n\n\t \n\tcpsw_ale_control_set(ale, 0, ALE_AGEOUT, 1);\n\tdo {\n\t\tcpu_relax();\n\t\tif (cpsw_ale_control_get(ale, 0, ALE_AGEOUT)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t} while (time_after(timeout, jiffies));\n\n\t \n\tif (ret && !cpsw_ale_control_get(ale, 0, ALE_AGEOUT))\n\t\treturn ret;\n\n\tcpsw_ale_control_set(ale, 0, ALE_AGEOUT, 1);\n\n\t \n\tcpsw_ale_flush_multicast(ale,\n\t\t\t\t GBE_PORT_MASK(gbe_dev->ale_ports),\n\t\t\t\t -1);\n\n\t \n\tcpsw_ale_control_set(ale, 0, ALE_P0_UNI_FLOOD, 1);\n\tdev_vdbg(gbe_dev->dev, \"promiscuous mode enabled\\n\");\n\treturn ret;\n}\n\nstatic int gbe_ioctl(void *intf_priv, struct ifreq *req, int cmd)\n{\n\tstruct gbe_intf *gbe_intf = intf_priv;\n\tstruct phy_device *phy = gbe_intf->slave->phy;\n\n\tif (!phy_has_hwtstamp(phy)) {\n\t\tswitch (cmd) {\n\t\tcase SIOCGHWTSTAMP:\n\t\t\treturn gbe_hwtstamp_get(gbe_intf, req);\n\t\tcase SIOCSHWTSTAMP:\n\t\t\treturn gbe_hwtstamp_set(gbe_intf, req);\n\t\t}\n\t}\n\n\tif (phy)\n\t\treturn phy_mii_ioctl(phy, req, cmd);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void netcp_ethss_timer(struct timer_list *t)\n{\n\tstruct gbe_priv *gbe_dev = from_timer(gbe_dev, t, timer);\n\tstruct gbe_intf *gbe_intf;\n\tstruct gbe_slave *slave;\n\n\t \n\tfor_each_intf(gbe_intf, gbe_dev) {\n\t\tif (!gbe_intf->slave->open)\n\t\t\tcontinue;\n\t\tnetcp_ethss_update_link_state(gbe_dev, gbe_intf->slave,\n\t\t\t\t\t      gbe_intf->ndev);\n\t}\n\n\t \n\tfor_each_sec_slave(slave, gbe_dev) {\n\t\tnetcp_ethss_update_link_state(gbe_dev, slave, NULL);\n\t}\n\n\t \n\tspin_lock(&gbe_dev->hw_stats_lock);\n\n\tif (IS_SS_ID_VER_14(gbe_dev))\n\t\tgbe_update_stats_ver14(gbe_dev, NULL);\n\telse\n\t\tgbe_update_stats(gbe_dev, NULL);\n\n\tspin_unlock(&gbe_dev->hw_stats_lock);\n\n\tgbe_dev->timer.expires\t= jiffies + GBE_TIMER_INTERVAL;\n\tadd_timer(&gbe_dev->timer);\n}\n\nstatic int gbe_txhook(int order, void *data, struct netcp_packet *p_info)\n{\n\tstruct gbe_intf *gbe_intf = data;\n\n\tp_info->tx_pipe = &gbe_intf->tx_pipe;\n\n\treturn gbe_txtstamp_mark_pkt(gbe_intf, p_info);\n}\n\nstatic int gbe_rxhook(int order, void *data, struct netcp_packet *p_info)\n{\n\tstruct gbe_intf *gbe_intf = data;\n\n\treturn gbe_rxtstamp(gbe_intf, p_info);\n}\n\nstatic int gbe_open(void *intf_priv, struct net_device *ndev)\n{\n\tstruct gbe_intf *gbe_intf = intf_priv;\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct gbe_slave *slave = gbe_intf->slave;\n\tint port_num = slave->port_num;\n\tu32 reg, val;\n\tint ret;\n\n\treg = readl(GBE_REG_ADDR(gbe_dev, switch_regs, id_ver));\n\tdev_dbg(gbe_dev->dev, \"initializing gbe version %d.%d (%d) GBE identification value 0x%x\\n\",\n\t\tGBE_MAJOR_VERSION(reg), GBE_MINOR_VERSION(reg),\n\t\tGBE_RTL_VERSION(reg), GBE_IDENT(reg));\n\n\t \n\tif (IS_SS_ID_XGBE(gbe_dev) || IS_SS_ID_MU(gbe_dev))\n\t\tgbe_intf->tx_pipe.flags = SWITCH_TO_PORT_IN_TAGINFO;\n\n\tif (gbe_dev->enable_ale)\n\t\tgbe_intf->tx_pipe.switch_to_port = 0;\n\telse\n\t\tgbe_intf->tx_pipe.switch_to_port = port_num;\n\n\tdev_dbg(gbe_dev->dev,\n\t\t\"opened TX channel %s: %p with to port %d, flags %d\\n\",\n\t\tgbe_intf->tx_pipe.dma_chan_name,\n\t\tgbe_intf->tx_pipe.dma_channel,\n\t\tgbe_intf->tx_pipe.switch_to_port,\n\t\tgbe_intf->tx_pipe.flags);\n\n\tgbe_slave_stop(gbe_intf);\n\n\t \n\twritel(0, GBE_REG_ADDR(gbe_dev, switch_regs, ptype));\n\n\t \n\tval = GBE_CTL_P0_ENABLE;\n\tif (IS_SS_ID_MU(gbe_dev)) {\n\t\tval |= ETH_SW_CTL_P0_TX_CRC_REMOVE;\n\t\tnetcp->hw_cap = ETH_SW_CAN_REMOVE_ETH_FCS;\n\t}\n\twritel(val, GBE_REG_ADDR(gbe_dev, switch_regs, control));\n\n\t \n\twritel(gbe_dev->stats_en_mask, GBE_REG_ADDR(gbe_dev, switch_regs,\n\t\t\t\t\t\t    stat_port_en));\n\n\tret = gbe_slave_open(gbe_intf);\n\tif (ret)\n\t\tgoto fail;\n\n\tnetcp_register_txhook(netcp, GBE_TXHOOK_ORDER, gbe_txhook, gbe_intf);\n\tnetcp_register_rxhook(netcp, GBE_RXHOOK_ORDER, gbe_rxhook, gbe_intf);\n\n\tslave->open = true;\n\tnetcp_ethss_update_link_state(gbe_dev, slave, ndev);\n\n\tgbe_register_cpts(gbe_dev);\n\n\treturn 0;\n\nfail:\n\tgbe_slave_stop(gbe_intf);\n\treturn ret;\n}\n\nstatic int gbe_close(void *intf_priv, struct net_device *ndev)\n{\n\tstruct gbe_intf *gbe_intf = intf_priv;\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct gbe_priv *gbe_dev = gbe_intf->gbe_dev;\n\n\tgbe_unregister_cpts(gbe_dev);\n\n\tgbe_slave_stop(gbe_intf);\n\n\tnetcp_unregister_rxhook(netcp, GBE_RXHOOK_ORDER, gbe_rxhook, gbe_intf);\n\tnetcp_unregister_txhook(netcp, GBE_TXHOOK_ORDER, gbe_txhook, gbe_intf);\n\n\tgbe_intf->slave->open = false;\n\tatomic_set(&gbe_intf->slave->link_state, NETCP_LINK_STATE_INVALID);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_TI_CPTS)\nstatic void init_slave_ts_ctl(struct gbe_slave *slave)\n{\n\tslave->ts_ctl.uni = 1;\n\tslave->ts_ctl.dst_port_map =\n\t\t(TS_CTL_DST_PORT >> TS_CTL_DST_PORT_SHIFT) & 0x3;\n\tslave->ts_ctl.maddr_map =\n\t\t(TS_CTL_MADDR_ALL >> TS_CTL_MADDR_SHIFT) & 0x1f;\n}\n\n#else\nstatic void init_slave_ts_ctl(struct gbe_slave *slave)\n{\n}\n#endif  \n\nstatic int init_slave(struct gbe_priv *gbe_dev, struct gbe_slave *slave,\n\t\t      struct device_node *node)\n{\n\tint port_reg_num;\n\tu32 port_reg_ofs, emac_reg_ofs;\n\tu32 port_reg_blk_sz, emac_reg_blk_sz;\n\n\tif (of_property_read_u32(node, \"slave-port\", &slave->slave_num)) {\n\t\tdev_err(gbe_dev->dev, \"missing slave-port parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(node, \"link-interface\",\n\t\t\t\t &slave->link_interface)) {\n\t\tdev_warn(gbe_dev->dev,\n\t\t\t \"missing link-interface value defaulting to 1G mac-phy link\\n\");\n\t\tslave->link_interface = SGMII_LINK_MAC_PHY;\n\t}\n\n\tslave->node = node;\n\tslave->open = false;\n\tif ((slave->link_interface == SGMII_LINK_MAC_PHY) ||\n\t    (slave->link_interface == RGMII_LINK_MAC_PHY) ||\n\t    (slave->link_interface == XGMII_LINK_MAC_PHY))\n\t\tslave->phy_node = of_parse_phandle(node, \"phy-handle\", 0);\n\tslave->port_num = gbe_get_slave_port(gbe_dev, slave->slave_num);\n\n\tif (slave->link_interface >= XGMII_LINK_MAC_PHY)\n\t\tslave->mac_control = GBE_DEF_10G_MAC_CONTROL;\n\telse\n\t\tslave->mac_control = GBE_DEF_1G_MAC_CONTROL;\n\n\t \n\tport_reg_num = slave->slave_num;\n\tif (IS_SS_ID_VER_14(gbe_dev)) {\n\t\tif (slave->slave_num > 1) {\n\t\t\tport_reg_ofs = GBE13_SLAVE_PORT2_OFFSET;\n\t\t\tport_reg_num -= 2;\n\t\t} else {\n\t\t\tport_reg_ofs = GBE13_SLAVE_PORT_OFFSET;\n\t\t}\n\t\temac_reg_ofs = GBE13_EMAC_OFFSET;\n\t\tport_reg_blk_sz = 0x30;\n\t\temac_reg_blk_sz = 0x40;\n\t} else if (IS_SS_ID_MU(gbe_dev)) {\n\t\tport_reg_ofs = GBENU_SLAVE_PORT_OFFSET;\n\t\temac_reg_ofs = GBENU_EMAC_OFFSET;\n\t\tport_reg_blk_sz = 0x1000;\n\t\temac_reg_blk_sz = 0x1000;\n\t} else if (IS_SS_ID_XGBE(gbe_dev)) {\n\t\tport_reg_ofs = XGBE10_SLAVE_PORT_OFFSET;\n\t\temac_reg_ofs = XGBE10_EMAC_OFFSET;\n\t\tport_reg_blk_sz = 0x30;\n\t\temac_reg_blk_sz = 0x40;\n\t} else {\n\t\tdev_err(gbe_dev->dev, \"unknown ethss(0x%x)\\n\",\n\t\t\tgbe_dev->ss_version);\n\t\treturn -EINVAL;\n\t}\n\n\tslave->port_regs = gbe_dev->switch_regs + port_reg_ofs +\n\t\t\t\t(port_reg_blk_sz * port_reg_num);\n\tslave->emac_regs = gbe_dev->switch_regs + emac_reg_ofs +\n\t\t\t\t(emac_reg_blk_sz * slave->slave_num);\n\n\tif (IS_SS_ID_VER_14(gbe_dev)) {\n\t\t \n\t\tGBE_SET_REG_OFS(slave, port_regs, port_vlan);\n\t\tGBE_SET_REG_OFS(slave, port_regs, tx_pri_map);\n\t\tGBE_SET_REG_OFS(slave, port_regs, sa_lo);\n\t\tGBE_SET_REG_OFS(slave, port_regs, sa_hi);\n\t\tGBE_SET_REG_OFS(slave, port_regs, ts_ctl);\n\t\tGBE_SET_REG_OFS(slave, port_regs, ts_seq_ltype);\n\t\tGBE_SET_REG_OFS(slave, port_regs, ts_vlan);\n\t\tGBE_SET_REG_OFS(slave, port_regs, ts_ctl_ltype2);\n\t\tGBE_SET_REG_OFS(slave, port_regs, ts_ctl2);\n\n\t\t \n\t\tGBE_SET_REG_OFS(slave, emac_regs, mac_control);\n\t\tGBE_SET_REG_OFS(slave, emac_regs, soft_reset);\n\t\tGBE_SET_REG_OFS(slave, emac_regs, rx_maxlen);\n\n\t} else if (IS_SS_ID_MU(gbe_dev)) {\n\t\t \n\t\tGBENU_SET_REG_OFS(slave, port_regs, port_vlan);\n\t\tGBENU_SET_REG_OFS(slave, port_regs, tx_pri_map);\n\t\tGBENU_SET_REG_OFS(slave, port_regs, rx_pri_map);\n\t\tGBENU_SET_REG_OFS(slave, port_regs, sa_lo);\n\t\tGBENU_SET_REG_OFS(slave, port_regs, sa_hi);\n\t\tGBENU_SET_REG_OFS(slave, port_regs, ts_ctl);\n\t\tGBENU_SET_REG_OFS(slave, port_regs, ts_seq_ltype);\n\t\tGBENU_SET_REG_OFS(slave, port_regs, ts_vlan);\n\t\tGBENU_SET_REG_OFS(slave, port_regs, ts_ctl_ltype2);\n\t\tGBENU_SET_REG_OFS(slave, port_regs, ts_ctl2);\n\t\tGBENU_SET_REG_OFS(slave, port_regs, rx_maxlen);\n\n\t\t \n\t\tGBENU_SET_REG_OFS(slave, emac_regs, mac_control);\n\t\tGBENU_SET_REG_OFS(slave, emac_regs, soft_reset);\n\n\t} else if (IS_SS_ID_XGBE(gbe_dev)) {\n\t\t \n\t\tXGBE_SET_REG_OFS(slave, port_regs, port_vlan);\n\t\tXGBE_SET_REG_OFS(slave, port_regs, tx_pri_map);\n\t\tXGBE_SET_REG_OFS(slave, port_regs, sa_lo);\n\t\tXGBE_SET_REG_OFS(slave, port_regs, sa_hi);\n\t\tXGBE_SET_REG_OFS(slave, port_regs, ts_ctl);\n\t\tXGBE_SET_REG_OFS(slave, port_regs, ts_seq_ltype);\n\t\tXGBE_SET_REG_OFS(slave, port_regs, ts_vlan);\n\t\tXGBE_SET_REG_OFS(slave, port_regs, ts_ctl_ltype2);\n\t\tXGBE_SET_REG_OFS(slave, port_regs, ts_ctl2);\n\n\t\t \n\t\tXGBE_SET_REG_OFS(slave, emac_regs, mac_control);\n\t\tXGBE_SET_REG_OFS(slave, emac_regs, soft_reset);\n\t\tXGBE_SET_REG_OFS(slave, emac_regs, rx_maxlen);\n\t}\n\n\tatomic_set(&slave->link_state, NETCP_LINK_STATE_INVALID);\n\n\tinit_slave_ts_ctl(slave);\n\treturn 0;\n}\n\nstatic void init_secondary_ports(struct gbe_priv *gbe_dev,\n\t\t\t\t struct device_node *node)\n{\n\tstruct device *dev = gbe_dev->dev;\n\tphy_interface_t phy_mode;\n\tstruct gbe_priv **priv;\n\tstruct device_node *port;\n\tstruct gbe_slave *slave;\n\tbool mac_phy_link = false;\n\n\tfor_each_child_of_node(node, port) {\n\t\tslave = devm_kzalloc(dev, sizeof(*slave), GFP_KERNEL);\n\t\tif (!slave) {\n\t\t\tdev_err(dev, \"memory alloc failed for secondary port(%pOFn), skipping...\\n\",\n\t\t\t\tport);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (init_slave(gbe_dev, slave, port)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to initialize secondary port(%pOFn), skipping...\\n\",\n\t\t\t\tport);\n\t\t\tdevm_kfree(dev, slave);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!IS_SS_ID_2U(gbe_dev))\n\t\t\tgbe_sgmii_config(gbe_dev, slave);\n\t\tgbe_port_reset(slave);\n\t\tgbe_port_config(gbe_dev, slave, gbe_dev->rx_packet_max);\n\t\tlist_add_tail(&slave->slave_list, &gbe_dev->secondary_slaves);\n\t\tgbe_dev->num_slaves++;\n\t\tif ((slave->link_interface == SGMII_LINK_MAC_PHY) ||\n\t\t    (slave->link_interface == XGMII_LINK_MAC_PHY))\n\t\t\tmac_phy_link = true;\n\n\t\tslave->open = true;\n\t\tif (gbe_dev->num_slaves >= gbe_dev->max_num_slaves) {\n\t\t\tof_node_put(port);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!mac_phy_link)\n\t\treturn;\n\n\t \n\tgbe_dev->dummy_ndev = alloc_netdev(sizeof(gbe_dev), \"dummy\",\n\t\t\t\t\tNET_NAME_UNKNOWN, ether_setup);\n\tif (!gbe_dev->dummy_ndev) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to allocate dummy netdev for secondary ports, skipping phy_connect()...\\n\");\n\t\treturn;\n\t}\n\tpriv = netdev_priv(gbe_dev->dummy_ndev);\n\t*priv = gbe_dev;\n\n\tif (slave->link_interface == SGMII_LINK_MAC_PHY) {\n\t\tphy_mode = PHY_INTERFACE_MODE_SGMII;\n\t\tslave->phy_port_t = PORT_MII;\n\t} else if (slave->link_interface == RGMII_LINK_MAC_PHY) {\n\t\tphy_mode = PHY_INTERFACE_MODE_RGMII;\n\t\tslave->phy_port_t = PORT_MII;\n\t} else {\n\t\tphy_mode = PHY_INTERFACE_MODE_NA;\n\t\tslave->phy_port_t = PORT_FIBRE;\n\t}\n\n\tfor_each_sec_slave(slave, gbe_dev) {\n\t\tif ((slave->link_interface != SGMII_LINK_MAC_PHY) &&\n\t\t    (slave->link_interface != RGMII_LINK_MAC_PHY) &&\n\t\t    (slave->link_interface != XGMII_LINK_MAC_PHY))\n\t\t\tcontinue;\n\t\tslave->phy =\n\t\t\tof_phy_connect(gbe_dev->dummy_ndev,\n\t\t\t\t       slave->phy_node,\n\t\t\t\t       gbe_adjust_link_sec_slaves,\n\t\t\t\t       0, phy_mode);\n\t\tif (!slave->phy) {\n\t\t\tdev_err(dev, \"phy not found for slave %d\\n\",\n\t\t\t\tslave->slave_num);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"phy found: id is: 0x%s\\n\",\n\t\t\t\tphydev_name(slave->phy));\n\t\t\tphy_start(slave->phy);\n\t\t}\n\t}\n}\n\nstatic void free_secondary_ports(struct gbe_priv *gbe_dev)\n{\n\tstruct gbe_slave *slave;\n\n\twhile (!list_empty(&gbe_dev->secondary_slaves)) {\n\t\tslave = first_sec_slave(gbe_dev);\n\n\t\tif (slave->phy)\n\t\t\tphy_disconnect(slave->phy);\n\t\tlist_del(&slave->slave_list);\n\t}\n\tif (gbe_dev->dummy_ndev)\n\t\tfree_netdev(gbe_dev->dummy_ndev);\n}\n\nstatic int set_xgbe_ethss10_priv(struct gbe_priv *gbe_dev,\n\t\t\t\t struct device_node *node)\n{\n\tstruct resource res;\n\tvoid __iomem *regs;\n\tint ret, i;\n\n\tret = of_address_to_resource(node, XGBE_SS_REG_INDEX, &res);\n\tif (ret) {\n\t\tdev_err(gbe_dev->dev,\n\t\t\t\"Can't xlate xgbe of node(%pOFn) ss address at %d\\n\",\n\t\t\tnode, XGBE_SS_REG_INDEX);\n\t\treturn ret;\n\t}\n\n\tregs = devm_ioremap_resource(gbe_dev->dev, &res);\n\tif (IS_ERR(regs)) {\n\t\tdev_err(gbe_dev->dev, \"Failed to map xgbe ss register base\\n\");\n\t\treturn PTR_ERR(regs);\n\t}\n\tgbe_dev->ss_regs = regs;\n\n\tret = of_address_to_resource(node, XGBE_SM_REG_INDEX, &res);\n\tif (ret) {\n\t\tdev_err(gbe_dev->dev,\n\t\t\t\"Can't xlate xgbe of node(%pOFn) sm address at %d\\n\",\n\t\t\tnode, XGBE_SM_REG_INDEX);\n\t\treturn ret;\n\t}\n\n\tregs = devm_ioremap_resource(gbe_dev->dev, &res);\n\tif (IS_ERR(regs)) {\n\t\tdev_err(gbe_dev->dev, \"Failed to map xgbe sm register base\\n\");\n\t\treturn PTR_ERR(regs);\n\t}\n\tgbe_dev->switch_regs = regs;\n\n\tret = of_address_to_resource(node, XGBE_SERDES_REG_INDEX, &res);\n\tif (ret) {\n\t\tdev_err(gbe_dev->dev,\n\t\t\t\"Can't xlate xgbe serdes of node(%pOFn) address at %d\\n\",\n\t\t\tnode, XGBE_SERDES_REG_INDEX);\n\t\treturn ret;\n\t}\n\n\tregs = devm_ioremap_resource(gbe_dev->dev, &res);\n\tif (IS_ERR(regs)) {\n\t\tdev_err(gbe_dev->dev, \"Failed to map xgbe serdes register base\\n\");\n\t\treturn PTR_ERR(regs);\n\t}\n\tgbe_dev->xgbe_serdes_regs = regs;\n\n\tgbe_dev->num_stats_mods = gbe_dev->max_num_ports;\n\tgbe_dev->et_stats = xgbe10_et_stats;\n\tgbe_dev->num_et_stats = ARRAY_SIZE(xgbe10_et_stats);\n\n\tgbe_dev->hw_stats = devm_kcalloc(gbe_dev->dev,\n\t\t\t\t\t gbe_dev->num_et_stats, sizeof(u64),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!gbe_dev->hw_stats) {\n\t\tdev_err(gbe_dev->dev, \"hw_stats memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgbe_dev->hw_stats_prev =\n\t\tdevm_kcalloc(gbe_dev->dev,\n\t\t\t     gbe_dev->num_et_stats, sizeof(u32),\n\t\t\t     GFP_KERNEL);\n\tif (!gbe_dev->hw_stats_prev) {\n\t\tdev_err(gbe_dev->dev,\n\t\t\t\"hw_stats_prev memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgbe_dev->ss_version = XGBE_SS_VERSION_10;\n\tgbe_dev->sgmii_port_regs = gbe_dev->ss_regs +\n\t\t\t\t\tXGBE10_SGMII_MODULE_OFFSET;\n\tgbe_dev->host_port_regs = gbe_dev->ss_regs + XGBE10_HOST_PORT_OFFSET;\n\n\tfor (i = 0; i < gbe_dev->max_num_ports; i++)\n\t\tgbe_dev->hw_stats_regs[i] = gbe_dev->switch_regs +\n\t\t\tXGBE10_HW_STATS_OFFSET + (GBE_HW_STATS_REG_MAP_SZ * i);\n\n\tgbe_dev->ale_reg = gbe_dev->switch_regs + XGBE10_ALE_OFFSET;\n\tgbe_dev->cpts_reg = gbe_dev->switch_regs + XGBE10_CPTS_OFFSET;\n\tgbe_dev->ale_ports = gbe_dev->max_num_ports;\n\tgbe_dev->host_port = XGBE10_HOST_PORT_NUM;\n\tgbe_dev->stats_en_mask = (1 << (gbe_dev->max_num_ports)) - 1;\n\n\t \n\tXGBE_SET_REG_OFS(gbe_dev, ss_regs, id_ver);\n\tXGBE_SET_REG_OFS(gbe_dev, ss_regs, control);\n\n\t \n\tXGBE_SET_REG_OFS(gbe_dev, switch_regs, id_ver);\n\tXGBE_SET_REG_OFS(gbe_dev, switch_regs, control);\n\tXGBE_SET_REG_OFS(gbe_dev, switch_regs, ptype);\n\tXGBE_SET_REG_OFS(gbe_dev, switch_regs, stat_port_en);\n\tXGBE_SET_REG_OFS(gbe_dev, switch_regs, flow_control);\n\n\t \n\tXGBE_SET_REG_OFS(gbe_dev, host_port_regs, port_vlan);\n\tXGBE_SET_REG_OFS(gbe_dev, host_port_regs, tx_pri_map);\n\tXGBE_SET_REG_OFS(gbe_dev, host_port_regs, rx_maxlen);\n\treturn 0;\n}\n\nstatic int get_gbe_resource_version(struct gbe_priv *gbe_dev,\n\t\t\t\t    struct device_node *node)\n{\n\tstruct resource res;\n\tvoid __iomem *regs;\n\tint ret;\n\n\tret = of_address_to_resource(node, GBE_SS_REG_INDEX, &res);\n\tif (ret) {\n\t\tdev_err(gbe_dev->dev,\n\t\t\t\"Can't translate of node(%pOFn) of gbe ss address at %d\\n\",\n\t\t\tnode, GBE_SS_REG_INDEX);\n\t\treturn ret;\n\t}\n\n\tregs = devm_ioremap_resource(gbe_dev->dev, &res);\n\tif (IS_ERR(regs)) {\n\t\tdev_err(gbe_dev->dev, \"Failed to map gbe register base\\n\");\n\t\treturn PTR_ERR(regs);\n\t}\n\tgbe_dev->ss_regs = regs;\n\tgbe_dev->ss_version = readl(gbe_dev->ss_regs);\n\treturn 0;\n}\n\nstatic int set_gbe_ethss14_priv(struct gbe_priv *gbe_dev,\n\t\t\t\tstruct device_node *node)\n{\n\tstruct resource res;\n\tvoid __iomem *regs;\n\tint i, ret;\n\n\tret = of_address_to_resource(node, GBE_SGMII34_REG_INDEX, &res);\n\tif (ret) {\n\t\tdev_err(gbe_dev->dev,\n\t\t\t\"Can't translate of gbe node(%pOFn) address at index %d\\n\",\n\t\t\tnode, GBE_SGMII34_REG_INDEX);\n\t\treturn ret;\n\t}\n\n\tregs = devm_ioremap_resource(gbe_dev->dev, &res);\n\tif (IS_ERR(regs)) {\n\t\tdev_err(gbe_dev->dev,\n\t\t\t\"Failed to map gbe sgmii port34 register base\\n\");\n\t\treturn PTR_ERR(regs);\n\t}\n\tgbe_dev->sgmii_port34_regs = regs;\n\n\tret = of_address_to_resource(node, GBE_SM_REG_INDEX, &res);\n\tif (ret) {\n\t\tdev_err(gbe_dev->dev,\n\t\t\t\"Can't translate of gbe node(%pOFn) address at index %d\\n\",\n\t\t\tnode, GBE_SM_REG_INDEX);\n\t\treturn ret;\n\t}\n\n\tregs = devm_ioremap_resource(gbe_dev->dev, &res);\n\tif (IS_ERR(regs)) {\n\t\tdev_err(gbe_dev->dev,\n\t\t\t\"Failed to map gbe switch module register base\\n\");\n\t\treturn PTR_ERR(regs);\n\t}\n\tgbe_dev->switch_regs = regs;\n\n\tgbe_dev->num_stats_mods = gbe_dev->max_num_slaves;\n\tgbe_dev->et_stats = gbe13_et_stats;\n\tgbe_dev->num_et_stats = ARRAY_SIZE(gbe13_et_stats);\n\n\tgbe_dev->hw_stats = devm_kcalloc(gbe_dev->dev,\n\t\t\t\t\t gbe_dev->num_et_stats, sizeof(u64),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!gbe_dev->hw_stats) {\n\t\tdev_err(gbe_dev->dev, \"hw_stats memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgbe_dev->hw_stats_prev =\n\t\tdevm_kcalloc(gbe_dev->dev,\n\t\t\t     gbe_dev->num_et_stats, sizeof(u32),\n\t\t\t     GFP_KERNEL);\n\tif (!gbe_dev->hw_stats_prev) {\n\t\tdev_err(gbe_dev->dev,\n\t\t\t\"hw_stats_prev memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgbe_dev->sgmii_port_regs = gbe_dev->ss_regs + GBE13_SGMII_MODULE_OFFSET;\n\tgbe_dev->host_port_regs = gbe_dev->switch_regs + GBE13_HOST_PORT_OFFSET;\n\n\t \n\tfor (i = 0; i < gbe_dev->max_num_slaves; i++) {\n\t\tgbe_dev->hw_stats_regs[i] =\n\t\t\tgbe_dev->switch_regs + GBE13_HW_STATS_OFFSET +\n\t\t\t(GBE_HW_STATS_REG_MAP_SZ * (i & 0x1));\n\t}\n\n\tgbe_dev->cpts_reg = gbe_dev->switch_regs + GBE13_CPTS_OFFSET;\n\tgbe_dev->ale_reg = gbe_dev->switch_regs + GBE13_ALE_OFFSET;\n\tgbe_dev->ale_ports = gbe_dev->max_num_ports;\n\tgbe_dev->host_port = GBE13_HOST_PORT_NUM;\n\tgbe_dev->stats_en_mask = GBE13_REG_VAL_STAT_ENABLE_ALL;\n\n\t \n\tGBE_SET_REG_OFS(gbe_dev, ss_regs, id_ver);\n\n\t \n\tGBE_SET_REG_OFS(gbe_dev, switch_regs, id_ver);\n\tGBE_SET_REG_OFS(gbe_dev, switch_regs, control);\n\tGBE_SET_REG_OFS(gbe_dev, switch_regs, soft_reset);\n\tGBE_SET_REG_OFS(gbe_dev, switch_regs, stat_port_en);\n\tGBE_SET_REG_OFS(gbe_dev, switch_regs, ptype);\n\tGBE_SET_REG_OFS(gbe_dev, switch_regs, flow_control);\n\n\t \n\tGBE_SET_REG_OFS(gbe_dev, host_port_regs, port_vlan);\n\tGBE_SET_REG_OFS(gbe_dev, host_port_regs, rx_maxlen);\n\treturn 0;\n}\n\nstatic int set_gbenu_ethss_priv(struct gbe_priv *gbe_dev,\n\t\t\t\tstruct device_node *node)\n{\n\tstruct resource res;\n\tvoid __iomem *regs;\n\tint i, ret;\n\n\tgbe_dev->num_stats_mods = gbe_dev->max_num_ports;\n\tgbe_dev->et_stats = gbenu_et_stats;\n\n\tif (IS_SS_ID_MU(gbe_dev))\n\t\tgbe_dev->num_et_stats = GBENU_ET_STATS_HOST_SIZE +\n\t\t\t(gbe_dev->max_num_slaves * GBENU_ET_STATS_PORT_SIZE);\n\telse\n\t\tgbe_dev->num_et_stats = GBENU_ET_STATS_HOST_SIZE +\n\t\t\t\t\tGBENU_ET_STATS_PORT_SIZE;\n\n\tgbe_dev->hw_stats = devm_kcalloc(gbe_dev->dev,\n\t\t\t\t\t gbe_dev->num_et_stats, sizeof(u64),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!gbe_dev->hw_stats) {\n\t\tdev_err(gbe_dev->dev, \"hw_stats memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgbe_dev->hw_stats_prev =\n\t\tdevm_kcalloc(gbe_dev->dev,\n\t\t\t     gbe_dev->num_et_stats, sizeof(u32),\n\t\t\t     GFP_KERNEL);\n\tif (!gbe_dev->hw_stats_prev) {\n\t\tdev_err(gbe_dev->dev,\n\t\t\t\"hw_stats_prev memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = of_address_to_resource(node, GBENU_SM_REG_INDEX, &res);\n\tif (ret) {\n\t\tdev_err(gbe_dev->dev,\n\t\t\t\"Can't translate of gbenu node(%pOFn) addr at index %d\\n\",\n\t\t\tnode, GBENU_SM_REG_INDEX);\n\t\treturn ret;\n\t}\n\n\tregs = devm_ioremap_resource(gbe_dev->dev, &res);\n\tif (IS_ERR(regs)) {\n\t\tdev_err(gbe_dev->dev,\n\t\t\t\"Failed to map gbenu switch module register base\\n\");\n\t\treturn PTR_ERR(regs);\n\t}\n\tgbe_dev->switch_regs = regs;\n\n\tif (!IS_SS_ID_2U(gbe_dev))\n\t\tgbe_dev->sgmii_port_regs =\n\t\t       gbe_dev->ss_regs + GBENU_SGMII_MODULE_OFFSET;\n\n\t \n\tgbe_dev->sgmii_port34_regs = gbe_dev->sgmii_port_regs +\n\t\t\t\t     (2 * GBENU_SGMII_MODULE_SIZE);\n\n\tgbe_dev->host_port_regs = gbe_dev->switch_regs + GBENU_HOST_PORT_OFFSET;\n\n\tfor (i = 0; i < (gbe_dev->max_num_ports); i++)\n\t\tgbe_dev->hw_stats_regs[i] = gbe_dev->switch_regs +\n\t\t\tGBENU_HW_STATS_OFFSET + (GBENU_HW_STATS_REG_MAP_SZ * i);\n\n\tgbe_dev->cpts_reg = gbe_dev->switch_regs + GBENU_CPTS_OFFSET;\n\tgbe_dev->ale_reg = gbe_dev->switch_regs + GBENU_ALE_OFFSET;\n\tgbe_dev->ale_ports = gbe_dev->max_num_ports;\n\tgbe_dev->host_port = GBENU_HOST_PORT_NUM;\n\tgbe_dev->stats_en_mask = (1 << (gbe_dev->max_num_ports)) - 1;\n\n\t \n\tGBENU_SET_REG_OFS(gbe_dev, ss_regs, id_ver);\n\t \n\tGBENU_SET_REG_OFS(gbe_dev, ss_regs, rgmii_status);\n\n\t \n\tGBENU_SET_REG_OFS(gbe_dev, switch_regs, id_ver);\n\tGBENU_SET_REG_OFS(gbe_dev, switch_regs, control);\n\tGBENU_SET_REG_OFS(gbe_dev, switch_regs, stat_port_en);\n\tGBENU_SET_REG_OFS(gbe_dev, switch_regs, ptype);\n\n\t \n\tGBENU_SET_REG_OFS(gbe_dev, host_port_regs, port_vlan);\n\tGBENU_SET_REG_OFS(gbe_dev, host_port_regs, rx_maxlen);\n\n\t \n\tGBENU_SET_REG_OFS(gbe_dev, host_port_regs, tx_pri_map);\n\treturn 0;\n}\n\nstatic int gbe_probe(struct netcp_device *netcp_device, struct device *dev,\n\t\t     struct device_node *node, void **inst_priv)\n{\n\tstruct device_node *interfaces, *interface, *cpts_node;\n\tstruct device_node *secondary_ports;\n\tstruct cpsw_ale_params ale_params;\n\tstruct gbe_priv *gbe_dev;\n\tu32 slave_num;\n\tint i, ret = 0;\n\n\tif (!node) {\n\t\tdev_err(dev, \"device tree info unavailable\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tgbe_dev = devm_kzalloc(dev, sizeof(struct gbe_priv), GFP_KERNEL);\n\tif (!gbe_dev)\n\t\treturn -ENOMEM;\n\n\tif (of_device_is_compatible(node, \"ti,netcp-gbe-5\") ||\n\t    of_device_is_compatible(node, \"ti,netcp-gbe\")) {\n\t\tgbe_dev->max_num_slaves = 4;\n\t} else if (of_device_is_compatible(node, \"ti,netcp-gbe-9\")) {\n\t\tgbe_dev->max_num_slaves = 8;\n\t} else if (of_device_is_compatible(node, \"ti,netcp-gbe-2\")) {\n\t\tgbe_dev->max_num_slaves = 1;\n\t\tgbe_module.set_rx_mode = gbe_set_rx_mode;\n\t} else if (of_device_is_compatible(node, \"ti,netcp-xgbe\")) {\n\t\tgbe_dev->max_num_slaves = 2;\n\t} else {\n\t\tdev_err(dev, \"device tree node for unknown device\\n\");\n\t\treturn -EINVAL;\n\t}\n\tgbe_dev->max_num_ports = gbe_dev->max_num_slaves + 1;\n\n\tgbe_dev->dev = dev;\n\tgbe_dev->netcp_device = netcp_device;\n\tgbe_dev->rx_packet_max = NETCP_MAX_FRAME_SIZE;\n\n\t \n\tspin_lock_init(&gbe_dev->hw_stats_lock);\n\n\tgbe_dev->enable_ale = of_property_read_bool(node, \"enable-ale\");\n\tif (gbe_dev->enable_ale)\n\t\tdev_info(dev, \"ALE enabled\\n\");\n\telse\n\t\tdev_dbg(dev, \"ALE bypass enabled*\\n\");\n\n\tret = of_property_read_u32(node, \"tx-queue\",\n\t\t\t\t   &gbe_dev->tx_queue_id);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"missing tx_queue parameter\\n\");\n\t\tgbe_dev->tx_queue_id = GBE_TX_QUEUE;\n\t}\n\n\tret = of_property_read_string(node, \"tx-channel\",\n\t\t\t\t      &gbe_dev->dma_chan_name);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"missing \\\"tx-channel\\\" parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_node_name_eq(node, \"gbe\")) {\n\t\tret = get_gbe_resource_version(gbe_dev, node);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdev_dbg(dev, \"ss_version: 0x%08x\\n\", gbe_dev->ss_version);\n\n\t\tif (IS_SS_ID_VER_14(gbe_dev))\n\t\t\tret = set_gbe_ethss14_priv(gbe_dev, node);\n\t\telse if (IS_SS_ID_MU(gbe_dev))\n\t\t\tret = set_gbenu_ethss_priv(gbe_dev, node);\n\t\telse\n\t\t\tret = -ENODEV;\n\n\t} else if (of_node_name_eq(node, \"xgbe\")) {\n\t\tret = set_xgbe_ethss10_priv(gbe_dev, node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = netcp_xgbe_serdes_init(gbe_dev->xgbe_serdes_regs,\n\t\t\t\t\t     gbe_dev->ss_regs);\n\t} else {\n\t\tdev_err(dev, \"unknown GBE node(%pOFn)\\n\", node);\n\t\tret = -ENODEV;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tinterfaces = of_get_child_by_name(node, \"interfaces\");\n\tif (!interfaces)\n\t\tdev_err(dev, \"could not find interfaces\\n\");\n\n\tret = netcp_txpipe_init(&gbe_dev->tx_pipe, netcp_device,\n\t\t\t\tgbe_dev->dma_chan_name, gbe_dev->tx_queue_id);\n\tif (ret) {\n\t\tof_node_put(interfaces);\n\t\treturn ret;\n\t}\n\n\tret = netcp_txpipe_open(&gbe_dev->tx_pipe);\n\tif (ret) {\n\t\tof_node_put(interfaces);\n\t\treturn ret;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&gbe_dev->gbe_intf_head);\n\tfor_each_child_of_node(interfaces, interface) {\n\t\tret = of_property_read_u32(interface, \"slave-port\", &slave_num);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"missing slave-port parameter, skipping interface configuration for %pOFn\\n\",\n\t\t\t\tinterface);\n\t\t\tcontinue;\n\t\t}\n\t\tgbe_dev->num_slaves++;\n\t\tif (gbe_dev->num_slaves >= gbe_dev->max_num_slaves) {\n\t\t\tof_node_put(interface);\n\t\t\tbreak;\n\t\t}\n\t}\n\tof_node_put(interfaces);\n\n\tif (!gbe_dev->num_slaves)\n\t\tdev_warn(dev, \"No network interface configured\\n\");\n\n\t \n\tsecondary_ports = of_get_child_by_name(node, \"secondary-slave-ports\");\n\tINIT_LIST_HEAD(&gbe_dev->secondary_slaves);\n\tif (secondary_ports && (gbe_dev->num_slaves <  gbe_dev->max_num_slaves))\n\t\tinit_secondary_ports(gbe_dev, secondary_ports);\n\tof_node_put(secondary_ports);\n\n\tif (!gbe_dev->num_slaves) {\n\t\tdev_err(dev,\n\t\t\t\"No network interface or secondary ports configured\\n\");\n\t\tret = -ENODEV;\n\t\tgoto free_sec_ports;\n\t}\n\n\tmemset(&ale_params, 0, sizeof(ale_params));\n\tale_params.dev\t\t= gbe_dev->dev;\n\tale_params.ale_regs\t= gbe_dev->ale_reg;\n\tale_params.ale_ageout\t= GBE_DEFAULT_ALE_AGEOUT;\n\tale_params.ale_ports\t= gbe_dev->ale_ports;\n\tale_params.dev_id\t= \"cpsw\";\n\tif (IS_SS_ID_NU(gbe_dev))\n\t\tale_params.dev_id = \"66ak2el\";\n\telse if (IS_SS_ID_2U(gbe_dev))\n\t\tale_params.dev_id = \"66ak2g\";\n\telse if (IS_SS_ID_XGBE(gbe_dev))\n\t\tale_params.dev_id = \"66ak2h-xgbe\";\n\n\tgbe_dev->ale = cpsw_ale_create(&ale_params);\n\tif (IS_ERR(gbe_dev->ale)) {\n\t\tdev_err(gbe_dev->dev, \"error initializing ale engine\\n\");\n\t\tret = PTR_ERR(gbe_dev->ale);\n\t\tgoto free_sec_ports;\n\t} else {\n\t\tdev_dbg(gbe_dev->dev, \"Created a gbe ale engine\\n\");\n\t}\n\n\tcpts_node = of_get_child_by_name(node, \"cpts\");\n\tif (!cpts_node)\n\t\tcpts_node = of_node_get(node);\n\n\tgbe_dev->cpts = cpts_create(gbe_dev->dev, gbe_dev->cpts_reg,\n\t\t\t\t    cpts_node, 0);\n\tof_node_put(cpts_node);\n\tif (IS_ENABLED(CONFIG_TI_CPTS) && IS_ERR(gbe_dev->cpts)) {\n\t\tret = PTR_ERR(gbe_dev->cpts);\n\t\tgoto free_sec_ports;\n\t}\n\n\t \n\tgbe_init_host_port(gbe_dev);\n\n\tspin_lock_bh(&gbe_dev->hw_stats_lock);\n\tfor (i = 0; i < gbe_dev->num_stats_mods; i++) {\n\t\tif (IS_SS_ID_VER_14(gbe_dev))\n\t\t\tgbe_reset_mod_stats_ver14(gbe_dev, i);\n\t\telse\n\t\t\tgbe_reset_mod_stats(gbe_dev, i);\n\t}\n\tspin_unlock_bh(&gbe_dev->hw_stats_lock);\n\n\ttimer_setup(&gbe_dev->timer, netcp_ethss_timer, 0);\n\tgbe_dev->timer.expires\t = jiffies + GBE_TIMER_INTERVAL;\n\tadd_timer(&gbe_dev->timer);\n\t*inst_priv = gbe_dev;\n\treturn 0;\n\nfree_sec_ports:\n\tfree_secondary_ports(gbe_dev);\n\treturn ret;\n}\n\nstatic int gbe_attach(void *inst_priv, struct net_device *ndev,\n\t\t      struct device_node *node, void **intf_priv)\n{\n\tstruct gbe_priv *gbe_dev = inst_priv;\n\tstruct gbe_intf *gbe_intf;\n\tint ret;\n\n\tif (!node) {\n\t\tdev_err(gbe_dev->dev, \"interface node not available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tgbe_intf = devm_kzalloc(gbe_dev->dev, sizeof(*gbe_intf), GFP_KERNEL);\n\tif (!gbe_intf)\n\t\treturn -ENOMEM;\n\n\tgbe_intf->ndev = ndev;\n\tgbe_intf->dev = gbe_dev->dev;\n\tgbe_intf->gbe_dev = gbe_dev;\n\n\tgbe_intf->slave = devm_kzalloc(gbe_dev->dev,\n\t\t\t\t\tsizeof(*gbe_intf->slave),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!gbe_intf->slave) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tif (init_slave(gbe_dev, gbe_intf->slave, node)) {\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tgbe_intf->tx_pipe = gbe_dev->tx_pipe;\n\tndev->ethtool_ops = &keystone_ethtool_ops;\n\tlist_add_tail(&gbe_intf->gbe_intf_list, &gbe_dev->gbe_intf_head);\n\t*intf_priv = gbe_intf;\n\treturn 0;\n\nfail:\n\tif (gbe_intf->slave)\n\t\tdevm_kfree(gbe_dev->dev, gbe_intf->slave);\n\tif (gbe_intf)\n\t\tdevm_kfree(gbe_dev->dev, gbe_intf);\n\treturn ret;\n}\n\nstatic int gbe_release(void *intf_priv)\n{\n\tstruct gbe_intf *gbe_intf = intf_priv;\n\n\tgbe_intf->ndev->ethtool_ops = NULL;\n\tlist_del(&gbe_intf->gbe_intf_list);\n\tdevm_kfree(gbe_intf->dev, gbe_intf->slave);\n\tdevm_kfree(gbe_intf->dev, gbe_intf);\n\treturn 0;\n}\n\nstatic int gbe_remove(struct netcp_device *netcp_device, void *inst_priv)\n{\n\tstruct gbe_priv *gbe_dev = inst_priv;\n\n\tdel_timer_sync(&gbe_dev->timer);\n\tcpts_release(gbe_dev->cpts);\n\tcpsw_ale_stop(gbe_dev->ale);\n\tnetcp_txpipe_close(&gbe_dev->tx_pipe);\n\tfree_secondary_ports(gbe_dev);\n\n\tif (!list_empty(&gbe_dev->gbe_intf_head))\n\t\tdev_alert(gbe_dev->dev,\n\t\t\t  \"unreleased ethss interfaces present\\n\");\n\n\treturn 0;\n}\n\nstatic struct netcp_module gbe_module = {\n\t.name\t\t= GBE_MODULE_NAME,\n\t.owner\t\t= THIS_MODULE,\n\t.primary\t= true,\n\t.probe\t\t= gbe_probe,\n\t.open\t\t= gbe_open,\n\t.close\t\t= gbe_close,\n\t.remove\t\t= gbe_remove,\n\t.attach\t\t= gbe_attach,\n\t.release\t= gbe_release,\n\t.add_addr\t= gbe_add_addr,\n\t.del_addr\t= gbe_del_addr,\n\t.add_vid\t= gbe_add_vid,\n\t.del_vid\t= gbe_del_vid,\n\t.ioctl\t\t= gbe_ioctl,\n};\n\nstatic struct netcp_module xgbe_module = {\n\t.name\t\t= XGBE_MODULE_NAME,\n\t.owner\t\t= THIS_MODULE,\n\t.primary\t= true,\n\t.probe\t\t= gbe_probe,\n\t.open\t\t= gbe_open,\n\t.close\t\t= gbe_close,\n\t.remove\t\t= gbe_remove,\n\t.attach\t\t= gbe_attach,\n\t.release\t= gbe_release,\n\t.add_addr\t= gbe_add_addr,\n\t.del_addr\t= gbe_del_addr,\n\t.add_vid\t= gbe_add_vid,\n\t.del_vid\t= gbe_del_vid,\n\t.ioctl\t\t= gbe_ioctl,\n};\n\nstatic int __init keystone_gbe_init(void)\n{\n\tint ret;\n\n\tret = netcp_register_module(&gbe_module);\n\tif (ret)\n\t\treturn ret;\n\n\tret = netcp_register_module(&xgbe_module);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nmodule_init(keystone_gbe_init);\n\nstatic void __exit keystone_gbe_exit(void)\n{\n\tnetcp_unregister_module(&gbe_module);\n\tnetcp_unregister_module(&xgbe_module);\n}\nmodule_exit(keystone_gbe_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"TI NETCP ETHSS driver for Keystone SOCs\");\nMODULE_AUTHOR(\"Sandeep Nair <sandeep_n@ti.com\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}