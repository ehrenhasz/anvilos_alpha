{
  "module_name": "tlan.c",
  "hash_id": "65ebf74ae8cda145cc3931df0d83034be8f8ab007b367abc1f4204ac67ee6412",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/tlan.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/hardirq.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/eisa.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/mii.h>\n\n#include \"tlan.h\"\n\n\n \nstatic\tstruct net_device\t*tlan_eisa_devices;\n\nstatic\tint\t\ttlan_devices_installed;\n\n \nstatic  int aui[MAX_TLAN_BOARDS];\nstatic  int duplex[MAX_TLAN_BOARDS];\nstatic  int speed[MAX_TLAN_BOARDS];\nstatic  int boards_found;\nmodule_param_array(aui, int, NULL, 0);\nmodule_param_array(duplex, int, NULL, 0);\nmodule_param_array(speed, int, NULL, 0);\nMODULE_PARM_DESC(aui, \"ThunderLAN use AUI port(s) (0-1)\");\nMODULE_PARM_DESC(duplex,\n\t\t \"ThunderLAN duplex setting(s) (0-default, 1-half, 2-full)\");\nMODULE_PARM_DESC(speed, \"ThunderLAN port speed setting(s) (0,10,100)\");\n\nMODULE_AUTHOR(\"Maintainer: Samuel Chessman <chessman@tux.org>\");\nMODULE_DESCRIPTION(\"Driver for TI ThunderLAN based ethernet PCI adapters\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic  int\t\tdebug;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"ThunderLAN debug mask\");\n\nstatic\tconst char tlan_signature[] = \"TLAN\";\nstatic  const char tlan_banner[] = \"ThunderLAN driver v1.17\\n\";\nstatic  int tlan_have_pci;\nstatic  int tlan_have_eisa;\n\nstatic const char * const media[] = {\n\t\"10BaseT-HD\", \"10BaseT-FD\", \"100baseTx-HD\",\n\t\"100BaseTx-FD\", \"100BaseT4\", NULL\n};\n\nstatic struct board {\n\tconst char\t*device_label;\n\tu32\t\tflags;\n\tu16\t\taddr_ofs;\n} board_info[] = {\n\t{ \"Compaq Netelligent 10 T PCI UTP\", TLAN_ADAPTER_ACTIVITY_LED, 0x83 },\n\t{ \"Compaq Netelligent 10/100 TX PCI UTP\",\n\t  TLAN_ADAPTER_ACTIVITY_LED, 0x83 },\n\t{ \"Compaq Integrated NetFlex-3/P\", TLAN_ADAPTER_NONE, 0x83 },\n\t{ \"Compaq NetFlex-3/P\",\n\t  TLAN_ADAPTER_UNMANAGED_PHY | TLAN_ADAPTER_BIT_RATE_PHY, 0x83 },\n\t{ \"Compaq NetFlex-3/P\", TLAN_ADAPTER_NONE, 0x83 },\n\t{ \"Compaq Netelligent Integrated 10/100 TX UTP\",\n\t  TLAN_ADAPTER_ACTIVITY_LED, 0x83 },\n\t{ \"Compaq Netelligent Dual 10/100 TX PCI UTP\",\n\t  TLAN_ADAPTER_NONE, 0x83 },\n\t{ \"Compaq Netelligent 10/100 TX Embedded UTP\",\n\t  TLAN_ADAPTER_NONE, 0x83 },\n\t{ \"Olicom OC-2183/2185\", TLAN_ADAPTER_USE_INTERN_10, 0x83 },\n\t{ \"Olicom OC-2325\", TLAN_ADAPTER_ACTIVITY_LED |\n\t  TLAN_ADAPTER_UNMANAGED_PHY, 0xf8 },\n\t{ \"Olicom OC-2326\", TLAN_ADAPTER_ACTIVITY_LED |\n\t  TLAN_ADAPTER_USE_INTERN_10, 0xf8 },\n\t{ \"Compaq Netelligent 10/100 TX UTP\", TLAN_ADAPTER_ACTIVITY_LED, 0x83 },\n\t{ \"Compaq Netelligent 10 T/2 PCI UTP/coax\", TLAN_ADAPTER_NONE, 0x83 },\n\t{ \"Compaq NetFlex-3/E\",\n\t  TLAN_ADAPTER_ACTIVITY_LED |\t \n\t  TLAN_ADAPTER_UNMANAGED_PHY | TLAN_ADAPTER_BIT_RATE_PHY, 0x83 },\n\t{ \"Compaq NetFlex-3/E\",\n\t  TLAN_ADAPTER_ACTIVITY_LED, 0x83 },  \n};\n\nstatic const struct pci_device_id tlan_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL10,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1 },\n\t{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETFLEX3I,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 2 },\n\t{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_THUNDER,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 3 },\n\t{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETFLEX3B,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 4 },\n\t{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100PI,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 5 },\n\t{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100D,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 6 },\n\t{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_NETEL100I,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 7 },\n\t{ PCI_VENDOR_ID_OLICOM, PCI_DEVICE_ID_OLICOM_OC2183,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 8 },\n\t{ PCI_VENDOR_ID_OLICOM, PCI_DEVICE_ID_OLICOM_OC2325,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 9 },\n\t{ PCI_VENDOR_ID_OLICOM, PCI_DEVICE_ID_OLICOM_OC2326,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 10 },\n\t{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_NETELLIGENT_10_100_WS_5100,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 11 },\n\t{ PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_NETELLIGENT_10_T2,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 12 },\n\t{ 0,}\n};\nMODULE_DEVICE_TABLE(pci, tlan_pci_tbl);\n\nstatic void\ttlan_eisa_probe(void);\nstatic void\ttlan_eisa_cleanup(void);\nstatic int      tlan_init(struct net_device *);\nstatic int\ttlan_open(struct net_device *dev);\nstatic netdev_tx_t tlan_start_tx(struct sk_buff *, struct net_device *);\nstatic irqreturn_t tlan_handle_interrupt(int, void *);\nstatic int\ttlan_close(struct net_device *);\nstatic struct\tnet_device_stats *tlan_get_stats(struct net_device *);\nstatic void\ttlan_set_multicast_list(struct net_device *);\nstatic int\ttlan_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic int      tlan_probe1(struct pci_dev *pdev, long ioaddr,\n\t\t\t    int irq, int rev, const struct pci_device_id *ent);\nstatic void\ttlan_tx_timeout(struct net_device *dev, unsigned int txqueue);\nstatic void\ttlan_tx_timeout_work(struct work_struct *work);\nstatic int\ttlan_init_one(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *ent);\n\nstatic u32\ttlan_handle_tx_eof(struct net_device *, u16);\nstatic u32\ttlan_handle_stat_overflow(struct net_device *, u16);\nstatic u32\ttlan_handle_rx_eof(struct net_device *, u16);\nstatic u32\ttlan_handle_dummy(struct net_device *, u16);\nstatic u32\ttlan_handle_tx_eoc(struct net_device *, u16);\nstatic u32\ttlan_handle_status_check(struct net_device *, u16);\nstatic u32\ttlan_handle_rx_eoc(struct net_device *, u16);\n\nstatic void\ttlan_timer(struct timer_list *t);\nstatic void\ttlan_phy_monitor(struct timer_list *t);\n\nstatic void\ttlan_reset_lists(struct net_device *);\nstatic void\ttlan_free_lists(struct net_device *);\nstatic void\ttlan_print_dio(u16);\nstatic void\ttlan_print_list(struct tlan_list *, char *, int);\nstatic void\ttlan_read_and_clear_stats(struct net_device *, int);\nstatic void\ttlan_reset_adapter(struct net_device *);\nstatic void\ttlan_finish_reset(struct net_device *);\nstatic void\ttlan_set_mac(struct net_device *, int areg, const char *mac);\n\nstatic void\t__tlan_phy_print(struct net_device *);\nstatic void\ttlan_phy_print(struct net_device *);\nstatic void\ttlan_phy_detect(struct net_device *);\nstatic void\ttlan_phy_power_down(struct net_device *);\nstatic void\ttlan_phy_power_up(struct net_device *);\nstatic void\ttlan_phy_reset(struct net_device *);\nstatic void\ttlan_phy_start_link(struct net_device *);\nstatic void\ttlan_phy_finish_auto_neg(struct net_device *);\n\n \n\nstatic bool\t__tlan_mii_read_reg(struct net_device *, u16, u16, u16 *);\nstatic void\ttlan_mii_read_reg(struct net_device *, u16, u16, u16 *);\nstatic void\ttlan_mii_send_data(u16, u32, unsigned);\nstatic void\ttlan_mii_sync(u16);\nstatic void\t__tlan_mii_write_reg(struct net_device *, u16, u16, u16);\nstatic void\ttlan_mii_write_reg(struct net_device *, u16, u16, u16);\n\nstatic void\ttlan_ee_send_start(u16);\nstatic int\ttlan_ee_send_byte(u16, u8, int);\nstatic void\ttlan_ee_receive_byte(u16, u8 *, int);\nstatic int\ttlan_ee_read_byte(struct net_device *, u8, u8 *);\n\n\nstatic inline void\ntlan_store_skb(struct tlan_list *tag, struct sk_buff *skb)\n{\n\tunsigned long addr = (unsigned long)skb;\n\ttag->buffer[9].address = addr;\n\ttag->buffer[8].address = upper_32_bits(addr);\n}\n\nstatic inline struct sk_buff *\ntlan_get_skb(const struct tlan_list *tag)\n{\n\tunsigned long addr;\n\n\taddr = tag->buffer[9].address;\n\taddr |= ((unsigned long) tag->buffer[8].address << 16) << 16;\n\treturn (struct sk_buff *) addr;\n}\n\nstatic u32\n(*tlan_int_vector[TLAN_INT_NUMBER_OF_INTS])(struct net_device *, u16) = {\n\tNULL,\n\ttlan_handle_tx_eof,\n\ttlan_handle_stat_overflow,\n\ttlan_handle_rx_eof,\n\ttlan_handle_dummy,\n\ttlan_handle_tx_eoc,\n\ttlan_handle_status_check,\n\ttlan_handle_rx_eoc\n};\n\nstatic void\ntlan_set_timer(struct net_device *dev, u32 ticks, u32 type)\n{\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->timer.function != NULL &&\n\t    priv->timer_type != TLAN_TIMER_ACTIVITY) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn;\n\t}\n\tpriv->timer.function = tlan_timer;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tpriv->timer_set_at = jiffies;\n\tpriv->timer_type = type;\n\tmod_timer(&priv->timer, jiffies + ticks);\n\n}\n\n\n \n\n\n\n\n\n \n\n\nstatic void tlan_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\n\tif (priv->dma_storage) {\n\t\tdma_free_coherent(&priv->pci_dev->dev, priv->dma_size,\n\t\t\t\t  priv->dma_storage, priv->dma_storage_dma);\n\t}\n\n#ifdef CONFIG_PCI\n\tpci_release_regions(pdev);\n#endif\n\n\tcancel_work_sync(&priv->tlan_tqueue);\n\tfree_netdev(dev);\n}\n\nstatic void tlan_start(struct net_device *dev)\n{\n\ttlan_reset_lists(dev);\n\t \n\ttlan_read_and_clear_stats(dev, TLAN_IGNORE);\n\ttlan_reset_adapter(dev);\n\tnetif_wake_queue(dev);\n}\n\nstatic void tlan_stop(struct net_device *dev)\n{\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\n\tdel_timer_sync(&priv->media_timer);\n\ttlan_read_and_clear_stats(dev, TLAN_RECORD);\n\toutl(TLAN_HC_AD_RST, dev->base_addr + TLAN_HOST_CMD);\n\t \n\ttlan_reset_adapter(dev);\n\tif (priv->timer.function != NULL) {\n\t\tdel_timer_sync(&priv->timer);\n\t\tpriv->timer.function = NULL;\n\t}\n}\n\nstatic int __maybe_unused tlan_suspend(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\n\tif (netif_running(dev))\n\t\ttlan_stop(dev);\n\n\tnetif_device_detach(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tlan_resume(struct device *dev_d)\n{\n\tstruct net_device *dev = dev_get_drvdata(dev_d);\n\tnetif_device_attach(dev);\n\n\tif (netif_running(dev))\n\t\ttlan_start(dev);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(tlan_pm_ops, tlan_suspend, tlan_resume);\n\nstatic struct pci_driver tlan_driver = {\n\t.name\t\t= \"tlan\",\n\t.id_table\t= tlan_pci_tbl,\n\t.probe\t\t= tlan_init_one,\n\t.remove\t\t= tlan_remove_one,\n\t.driver.pm\t= &tlan_pm_ops,\n};\n\nstatic int __init tlan_probe(void)\n{\n\tint rc = -ENODEV;\n\n\tpr_info(\"%s\", tlan_banner);\n\n\tTLAN_DBG(TLAN_DEBUG_PROBE, \"Starting PCI Probe....\\n\");\n\n\t \n\trc = pci_register_driver(&tlan_driver);\n\n\tif (rc != 0) {\n\t\tpr_err(\"Could not register pci driver\\n\");\n\t\tgoto err_out_pci_free;\n\t}\n\n\tTLAN_DBG(TLAN_DEBUG_PROBE, \"Starting EISA Probe....\\n\");\n\ttlan_eisa_probe();\n\n\tpr_info(\"%d device%s installed, PCI: %d  EISA: %d\\n\",\n\t\ttlan_devices_installed, tlan_devices_installed == 1 ? \"\" : \"s\",\n\t\ttlan_have_pci, tlan_have_eisa);\n\n\tif (tlan_devices_installed == 0) {\n\t\trc = -ENODEV;\n\t\tgoto  err_out_pci_unreg;\n\t}\n\treturn 0;\n\nerr_out_pci_unreg:\n\tpci_unregister_driver(&tlan_driver);\nerr_out_pci_free:\n\treturn rc;\n}\n\n\nstatic int tlan_init_one(struct pci_dev *pdev,\n\t\t\t\t   const struct pci_device_id *ent)\n{\n\treturn tlan_probe1(pdev, -1, -1, 0, ent);\n}\n\n\n \n\nstatic int tlan_probe1(struct pci_dev *pdev, long ioaddr, int irq, int rev,\n\t\t       const struct pci_device_id *ent)\n{\n\n\tstruct net_device  *dev;\n\tstruct tlan_priv  *priv;\n\tu16\t\t   device_id;\n\tint\t\t   reg, rc = -ENODEV;\n\n#ifdef CONFIG_PCI\n\tif (pdev) {\n\t\trc = pci_enable_device(pdev);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = pci_request_regions(pdev, tlan_signature);\n\t\tif (rc) {\n\t\t\tpr_err(\"Could not reserve IO regions\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\t}\n#endif   \n\n\tdev = alloc_etherdev(sizeof(struct tlan_priv));\n\tif (dev == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_regions;\n\t}\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tpriv = netdev_priv(dev);\n\n\tpriv->pci_dev = pdev;\n\tpriv->dev = dev;\n\n\t \n\tif (pdev) {\n\t\tu32\t\t   pci_io_base = 0;\n\n\t\tpriv->adapter = &board_info[ent->driver_data];\n\n\t\trc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (rc) {\n\t\t\tpr_err(\"No suitable PCI mapping available\\n\");\n\t\t\tgoto err_out_free_dev;\n\t\t}\n\n\t\tfor (reg = 0; reg <= 5; reg++) {\n\t\t\tif (pci_resource_flags(pdev, reg) & IORESOURCE_IO) {\n\t\t\t\tpci_io_base = pci_resource_start(pdev, reg);\n\t\t\t\tTLAN_DBG(TLAN_DEBUG_GNRL,\n\t\t\t\t\t \"IO mapping is available at %x.\\n\",\n\t\t\t\t\t pci_io_base);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!pci_io_base) {\n\t\t\tpr_err(\"No IO mappings available\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto err_out_free_dev;\n\t\t}\n\n\t\tdev->base_addr = pci_io_base;\n\t\tdev->irq = pdev->irq;\n\t\tpriv->adapter_rev = pdev->revision;\n\t\tpci_set_master(pdev);\n\t\tpci_set_drvdata(pdev, dev);\n\n\t} else\t{      \n\t\t \n\t\tdevice_id = inw(ioaddr + EISA_ID2);\n\t\tif (device_id == 0x20F1) {\n\t\t\tpriv->adapter = &board_info[13];  \n\t\t\tpriv->adapter_rev = 23;\t\t \n\t\t} else {\n\t\t\tpriv->adapter = &board_info[14];\n\t\t\tpriv->adapter_rev = 10;\t\t \n\t\t}\n\t\tdev->base_addr = ioaddr;\n\t\tdev->irq = irq;\n\t}\n\n\t \n\tif (dev->mem_start) {\n\t\tpriv->aui    = dev->mem_start & 0x01;\n\t\tpriv->duplex = ((dev->mem_start & 0x06) == 0x06) ? 0\n\t\t\t: (dev->mem_start & 0x06) >> 1;\n\t\tpriv->speed  = ((dev->mem_start & 0x18) == 0x18) ? 0\n\t\t\t: (dev->mem_start & 0x18) >> 3;\n\n\t\tif (priv->speed == 0x1)\n\t\t\tpriv->speed = TLAN_SPEED_10;\n\t\telse if (priv->speed == 0x2)\n\t\t\tpriv->speed = TLAN_SPEED_100;\n\n\t\tdebug = priv->debug = dev->mem_end;\n\t} else {\n\t\tpriv->aui    = aui[boards_found];\n\t\tpriv->speed  = speed[boards_found];\n\t\tpriv->duplex = duplex[boards_found];\n\t\tpriv->debug = debug;\n\t}\n\n\t \n\tINIT_WORK(&priv->tlan_tqueue, tlan_tx_timeout_work);\n\n\tspin_lock_init(&priv->lock);\n\n\trc = tlan_init(dev);\n\tif (rc) {\n\t\tpr_err(\"Could not set up device\\n\");\n\t\tgoto err_out_free_dev;\n\t}\n\n\trc = register_netdev(dev);\n\tif (rc) {\n\t\tpr_err(\"Could not register device\\n\");\n\t\tgoto err_out_uninit;\n\t}\n\n\n\ttlan_devices_installed++;\n\tboards_found++;\n\n\t \n\tif (pdev)\n\t\ttlan_have_pci++;\n\telse {\n\t\tpriv->next_device = tlan_eisa_devices;\n\t\ttlan_eisa_devices = dev;\n\t\ttlan_have_eisa++;\n\t}\n\n\tnetdev_info(dev, \"irq=%2d, io=%04x, %s, Rev. %d\\n\",\n\t\t    (int)dev->irq,\n\t\t    (int)dev->base_addr,\n\t\t    priv->adapter->device_label,\n\t\t    priv->adapter_rev);\n\treturn 0;\n\nerr_out_uninit:\n\tdma_free_coherent(&priv->pci_dev->dev, priv->dma_size,\n\t\t\t  priv->dma_storage, priv->dma_storage_dma);\nerr_out_free_dev:\n\tfree_netdev(dev);\nerr_out_regions:\n#ifdef CONFIG_PCI\n\tif (pdev)\n\t\tpci_release_regions(pdev);\nerr_out:\n#endif\n\tif (pdev)\n\t\tpci_disable_device(pdev);\n\treturn rc;\n}\n\n\nstatic void tlan_eisa_cleanup(void)\n{\n\tstruct net_device *dev;\n\tstruct tlan_priv *priv;\n\n\twhile (tlan_have_eisa) {\n\t\tdev = tlan_eisa_devices;\n\t\tpriv = netdev_priv(dev);\n\t\tif (priv->dma_storage) {\n\t\t\tdma_free_coherent(&priv->pci_dev->dev, priv->dma_size,\n\t\t\t\t\t  priv->dma_storage,\n\t\t\t\t\t  priv->dma_storage_dma);\n\t\t}\n\t\trelease_region(dev->base_addr, 0x10);\n\t\tunregister_netdev(dev);\n\t\ttlan_eisa_devices = priv->next_device;\n\t\tfree_netdev(dev);\n\t\ttlan_have_eisa--;\n\t}\n}\n\n\nstatic void __exit tlan_exit(void)\n{\n\tpci_unregister_driver(&tlan_driver);\n\n\tif (tlan_have_eisa)\n\t\ttlan_eisa_cleanup();\n\n}\n\n\n \nmodule_init(tlan_probe);\nmodule_exit(tlan_exit);\n\n\n\n \n\nstatic void  __init tlan_eisa_probe(void)\n{\n\tlong\tioaddr;\n\tint\tirq;\n\tu16\tdevice_id;\n\n\tif (!EISA_bus) {\n\t\tTLAN_DBG(TLAN_DEBUG_PROBE, \"No EISA bus present\\n\");\n\t\treturn;\n\t}\n\n\t \n\tfor (ioaddr = 0x1000; ioaddr < 0x9000; ioaddr += 0x1000) {\n\n\t\tTLAN_DBG(TLAN_DEBUG_PROBE, \"EISA_ID 0x%4x: 0x%4x\\n\",\n\t\t\t (int) ioaddr + 0xc80, inw(ioaddr + EISA_ID));\n\t\tTLAN_DBG(TLAN_DEBUG_PROBE, \"EISA_ID 0x%4x: 0x%4x\\n\",\n\t\t\t (int) ioaddr + 0xc82, inw(ioaddr + EISA_ID2));\n\n\n\t\tTLAN_DBG(TLAN_DEBUG_PROBE,\n\t\t\t \"Probing for EISA adapter at IO: 0x%4x : \",\n\t\t\t (int) ioaddr);\n\t\tif (request_region(ioaddr, 0x10, tlan_signature) == NULL)\n\t\t\tgoto out;\n\n\t\tif (inw(ioaddr + EISA_ID) != 0x110E) {\n\t\t\trelease_region(ioaddr, 0x10);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdevice_id = inw(ioaddr + EISA_ID2);\n\t\tif (device_id !=  0x20F1 && device_id != 0x40F1) {\n\t\t\trelease_region(ioaddr, 0x10);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (inb(ioaddr + EISA_CR) != 0x1) {\n\t\t\trelease_region(ioaddr, 0x10);\n\t\t\tgoto out2;\n\t\t}\n\n\t\tif (debug == 0x10)\n\t\t\tpr_info(\"Found one\\n\");\n\n\n\t\t \n\t\tswitch (inb(ioaddr + 0xcc0)) {\n\t\tcase(0x10):\n\t\t\tirq = 5;\n\t\t\tbreak;\n\t\tcase(0x20):\n\t\t\tirq = 9;\n\t\t\tbreak;\n\t\tcase(0x40):\n\t\t\tirq = 10;\n\t\t\tbreak;\n\t\tcase(0x80):\n\t\t\tirq = 11;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\n\n\t\t \n\t\ttlan_probe1(NULL, ioaddr, irq, 12, NULL);\n\t\tcontinue;\n\nout:\n\t\tif (debug == 0x10)\n\t\t\tpr_info(\"None found\\n\");\n\t\tcontinue;\n\nout2:\n\t\tif (debug == 0x10)\n\t\t\tpr_info(\"Card found but it is not enabled, skipping\\n\");\n\t\tcontinue;\n\n\t}\n\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void tlan_poll(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\ttlan_handle_interrupt(dev->irq, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n\nstatic const struct net_device_ops tlan_netdev_ops = {\n\t.ndo_open\t\t= tlan_open,\n\t.ndo_stop\t\t= tlan_close,\n\t.ndo_start_xmit\t\t= tlan_start_tx,\n\t.ndo_tx_timeout\t\t= tlan_tx_timeout,\n\t.ndo_get_stats\t\t= tlan_get_stats,\n\t.ndo_set_rx_mode\t= tlan_set_multicast_list,\n\t.ndo_eth_ioctl\t\t= tlan_ioctl,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t = tlan_poll,\n#endif\n};\n\nstatic void tlan_get_drvinfo(struct net_device *dev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\n\tstrscpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\n\tif (priv->pci_dev)\n\t\tstrscpy(info->bus_info, pci_name(priv->pci_dev),\n\t\t\tsizeof(info->bus_info));\n\telse\n\t\tstrscpy(info->bus_info, \"EISA\",\tsizeof(info->bus_info));\n}\n\nstatic int tlan_get_eeprom_len(struct net_device *dev)\n{\n\treturn TLAN_EEPROM_SIZE;\n}\n\nstatic int tlan_get_eeprom(struct net_device *dev,\n\t\t\t   struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < TLAN_EEPROM_SIZE; i++)\n\t\tif (tlan_ee_read_byte(dev, i, &data[i]))\n\t\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops tlan_ethtool_ops = {\n\t.get_drvinfo\t= tlan_get_drvinfo,\n\t.get_link\t= ethtool_op_get_link,\n\t.get_eeprom_len\t= tlan_get_eeprom_len,\n\t.get_eeprom\t= tlan_get_eeprom,\n};\n\n \n\nstatic int tlan_init(struct net_device *dev)\n{\n\tint\t\tdma_size;\n\tint\t\terr;\n\tint\t\ti;\n\tstruct tlan_priv\t*priv;\n\tu8 addr[ETH_ALEN];\n\n\tpriv = netdev_priv(dev);\n\n\tdma_size = (TLAN_NUM_RX_LISTS + TLAN_NUM_TX_LISTS)\n\t\t* (sizeof(struct tlan_list));\n\tpriv->dma_storage = dma_alloc_coherent(&priv->pci_dev->dev, dma_size,\n\t\t\t\t\t       &priv->dma_storage_dma, GFP_KERNEL);\n\tpriv->dma_size = dma_size;\n\n\tif (priv->dma_storage == NULL) {\n\t\tpr_err(\"Could not allocate lists and buffers for %s\\n\",\n\t\t       dev->name);\n\t\treturn -ENOMEM;\n\t}\n\tpriv->rx_list = (struct tlan_list *)\n\t\tALIGN((unsigned long)priv->dma_storage, 8);\n\tpriv->rx_list_dma = ALIGN(priv->dma_storage_dma, 8);\n\tpriv->tx_list = priv->rx_list + TLAN_NUM_RX_LISTS;\n\tpriv->tx_list_dma =\n\t\tpriv->rx_list_dma + sizeof(struct tlan_list)*TLAN_NUM_RX_LISTS;\n\n\terr = 0;\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\terr |= tlan_ee_read_byte(dev,\n\t\t\t\t\t (u8) priv->adapter->addr_ofs + i,\n\t\t\t\t\t addr + i);\n\tif (err) {\n\t\tpr_err(\"%s: Error reading MAC from eeprom: %d\\n\",\n\t\t       dev->name, err);\n\t}\n\t \n\tif (priv->adapter->addr_ofs == 0xf8) {\n\t\tfor (i = 0; i < ETH_ALEN; i += 2) {\n\t\t\tchar tmp = addr[i];\n\t\t\taddr[i] = addr[i + 1];\n\t\t\taddr[i + 1] = tmp;\n\t\t}\n\t}\n\teth_hw_addr_set(dev, addr);\n\n\tnetif_carrier_off(dev);\n\n\t \n\tdev->netdev_ops = &tlan_netdev_ops;\n\tdev->ethtool_ops = &tlan_ethtool_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\treturn 0;\n\n}\n\n\n\n\n \n\nstatic int tlan_open(struct net_device *dev)\n{\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\tint\t\terr;\n\n\tpriv->tlan_rev = tlan_dio_read8(dev->base_addr, TLAN_DEF_REVISION);\n\terr = request_irq(dev->irq, tlan_handle_interrupt, IRQF_SHARED,\n\t\t\t  dev->name, dev);\n\n\tif (err) {\n\t\tnetdev_err(dev, \"Cannot open because IRQ %d is already in use\\n\",\n\t\t\t   dev->irq);\n\t\treturn err;\n\t}\n\n\ttimer_setup(&priv->timer, NULL, 0);\n\ttimer_setup(&priv->media_timer, tlan_phy_monitor, 0);\n\n\ttlan_start(dev);\n\n\tTLAN_DBG(TLAN_DEBUG_GNRL, \"%s: Opened.  TLAN Chip Rev: %x\\n\",\n\t\t dev->name, priv->tlan_rev);\n\n\treturn 0;\n\n}\n\n\n\n \n\nstatic int tlan_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\tstruct mii_ioctl_data *data = if_mii(rq);\n\tu32 phy   = priv->phy[priv->phy_num];\n\n\tif (!priv->phy_online)\n\t\treturn -EAGAIN;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\t\t \n\t\tdata->phy_id = phy;\n\t\tfallthrough;\n\n\n\tcase SIOCGMIIREG:\t\t \n\t\ttlan_mii_read_reg(dev, data->phy_id & 0x1f,\n\t\t\t\t  data->reg_num & 0x1f, &data->val_out);\n\t\treturn 0;\n\n\n\tcase SIOCSMIIREG:\t\t \n\t\ttlan_mii_write_reg(dev, data->phy_id & 0x1f,\n\t\t\t\t   data->reg_num & 0x1f, data->val_in);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n\n \n\nstatic void tlan_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\n\tTLAN_DBG(TLAN_DEBUG_GNRL, \"%s: Transmit timed out.\\n\", dev->name);\n\n\t \n\ttlan_free_lists(dev);\n\ttlan_reset_lists(dev);\n\ttlan_read_and_clear_stats(dev, TLAN_IGNORE);\n\ttlan_reset_adapter(dev);\n\tnetif_trans_update(dev);  \n\tnetif_wake_queue(dev);\n\n}\n\n\n \n\nstatic void tlan_tx_timeout_work(struct work_struct *work)\n{\n\tstruct tlan_priv\t*priv =\n\t\tcontainer_of(work, struct tlan_priv, tlan_tqueue);\n\n\ttlan_tx_timeout(priv->dev, UINT_MAX);\n}\n\n\n\n \n\nstatic netdev_tx_t tlan_start_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\tdma_addr_t\ttail_list_phys;\n\tstruct tlan_list\t*tail_list;\n\tunsigned long\tflags;\n\tunsigned int    txlen;\n\n\tif (!priv->phy_online) {\n\t\tTLAN_DBG(TLAN_DEBUG_TX, \"TRANSMIT:  %s PHY is not ready\\n\",\n\t\t\t dev->name);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (skb_padto(skb, TLAN_MIN_FRAME_SIZE))\n\t\treturn NETDEV_TX_OK;\n\ttxlen = max(skb->len, (unsigned int)TLAN_MIN_FRAME_SIZE);\n\n\ttail_list = priv->tx_list + priv->tx_tail;\n\ttail_list_phys =\n\t\tpriv->tx_list_dma + sizeof(struct tlan_list)*priv->tx_tail;\n\n\tif (tail_list->c_stat != TLAN_CSTAT_UNUSED) {\n\t\tTLAN_DBG(TLAN_DEBUG_TX,\n\t\t\t \"TRANSMIT:  %s is busy (Head=%d Tail=%d)\\n\",\n\t\t\t dev->name, priv->tx_head, priv->tx_tail);\n\t\tnetif_stop_queue(dev);\n\t\tpriv->tx_busy_count++;\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\ttail_list->forward = 0;\n\n\ttail_list->buffer[0].address = dma_map_single(&priv->pci_dev->dev,\n\t\t\t\t\t\t      skb->data, txlen,\n\t\t\t\t\t\t      DMA_TO_DEVICE);\n\ttlan_store_skb(tail_list, skb);\n\n\ttail_list->frame_size = (u16) txlen;\n\ttail_list->buffer[0].count = TLAN_LAST_BUFFER | (u32) txlen;\n\ttail_list->buffer[1].count = 0;\n\ttail_list->buffer[1].address = 0;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\ttail_list->c_stat = TLAN_CSTAT_READY;\n\tif (!priv->tx_in_progress) {\n\t\tpriv->tx_in_progress = 1;\n\t\tTLAN_DBG(TLAN_DEBUG_TX,\n\t\t\t \"TRANSMIT:  Starting TX on buffer %d\\n\",\n\t\t\t priv->tx_tail);\n\t\toutl(tail_list_phys, dev->base_addr + TLAN_CH_PARM);\n\t\toutl(TLAN_HC_GO, dev->base_addr + TLAN_HOST_CMD);\n\t} else {\n\t\tTLAN_DBG(TLAN_DEBUG_TX,\n\t\t\t \"TRANSMIT:  Adding buffer %d to TX channel\\n\",\n\t\t\t priv->tx_tail);\n\t\tif (priv->tx_tail == 0) {\n\t\t\t(priv->tx_list + (TLAN_NUM_TX_LISTS - 1))->forward\n\t\t\t\t= tail_list_phys;\n\t\t} else {\n\t\t\t(priv->tx_list + (priv->tx_tail - 1))->forward\n\t\t\t\t= tail_list_phys;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tCIRC_INC(priv->tx_tail, TLAN_NUM_TX_LISTS);\n\n\treturn NETDEV_TX_OK;\n\n}\n\n\n\n\n \n\nstatic irqreturn_t tlan_handle_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device\t*dev = dev_id;\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\tu16\t\thost_int;\n\tu16\t\ttype;\n\n\tspin_lock(&priv->lock);\n\n\thost_int = inw(dev->base_addr + TLAN_HOST_INT);\n\ttype = (host_int & TLAN_HI_IT_MASK) >> 2;\n\tif (type) {\n\t\tu32\tack;\n\t\tu32\thost_cmd;\n\n\t\toutw(host_int, dev->base_addr + TLAN_HOST_INT);\n\t\tack = tlan_int_vector[type](dev, host_int);\n\n\t\tif (ack) {\n\t\t\thost_cmd = TLAN_HC_ACK | ack | (type << 18);\n\t\t\toutl(host_cmd, dev->base_addr + TLAN_HOST_CMD);\n\t\t}\n\t}\n\n\tspin_unlock(&priv->lock);\n\n\treturn IRQ_RETVAL(type);\n}\n\n\n\n\n \n\nstatic int tlan_close(struct net_device *dev)\n{\n\ttlan_stop(dev);\n\n\tfree_irq(dev->irq, dev);\n\ttlan_free_lists(dev);\n\tTLAN_DBG(TLAN_DEBUG_GNRL, \"Device %s closed.\\n\", dev->name);\n\n\treturn 0;\n\n}\n\n\n\n\n \n\nstatic struct net_device_stats *tlan_get_stats(struct net_device *dev)\n{\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\tint i;\n\n\t \n\ttlan_read_and_clear_stats(dev, TLAN_RECORD);\n\n\tTLAN_DBG(TLAN_DEBUG_RX, \"RECEIVE:  %s EOC count = %d\\n\", dev->name,\n\t\t priv->rx_eoc_count);\n\tTLAN_DBG(TLAN_DEBUG_TX, \"TRANSMIT:  %s Busy count = %d\\n\", dev->name,\n\t\t priv->tx_busy_count);\n\tif (debug & TLAN_DEBUG_GNRL) {\n\t\ttlan_print_dio(dev->base_addr);\n\t\ttlan_phy_print(dev);\n\t}\n\tif (debug & TLAN_DEBUG_LIST) {\n\t\tfor (i = 0; i < TLAN_NUM_RX_LISTS; i++)\n\t\t\ttlan_print_list(priv->rx_list + i, \"RX\", i);\n\t\tfor (i = 0; i < TLAN_NUM_TX_LISTS; i++)\n\t\t\ttlan_print_list(priv->tx_list + i, \"TX\", i);\n\t}\n\n\treturn &dev->stats;\n\n}\n\n\n\n\n \n\nstatic void tlan_set_multicast_list(struct net_device *dev)\n{\n\tstruct netdev_hw_addr *ha;\n\tu32\t\t\thash1 = 0;\n\tu32\t\t\thash2 = 0;\n\tint\t\t\ti;\n\tu32\t\t\toffset;\n\tu8\t\t\ttmp;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\ttmp = tlan_dio_read8(dev->base_addr, TLAN_NET_CMD);\n\t\ttlan_dio_write8(dev->base_addr,\n\t\t\t\tTLAN_NET_CMD, tmp | TLAN_NET_CMD_CAF);\n\t} else {\n\t\ttmp = tlan_dio_read8(dev->base_addr, TLAN_NET_CMD);\n\t\ttlan_dio_write8(dev->base_addr,\n\t\t\t\tTLAN_NET_CMD, tmp & ~TLAN_NET_CMD_CAF);\n\t\tif (dev->flags & IFF_ALLMULTI) {\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\ttlan_set_mac(dev, i + 1, NULL);\n\t\t\ttlan_dio_write32(dev->base_addr, TLAN_HASH_1,\n\t\t\t\t\t 0xffffffff);\n\t\t\ttlan_dio_write32(dev->base_addr, TLAN_HASH_2,\n\t\t\t\t\t 0xffffffff);\n\t\t} else {\n\t\t\ti = 0;\n\t\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t\tif (i < 3) {\n\t\t\t\t\ttlan_set_mac(dev, i + 1,\n\t\t\t\t\t\t     (char *) &ha->addr);\n\t\t\t\t} else {\n\t\t\t\t\toffset =\n\t\t\t\t\t\ttlan_hash_func((u8 *)&ha->addr);\n\t\t\t\t\tif (offset < 32)\n\t\t\t\t\t\thash1 |= (1 << offset);\n\t\t\t\t\telse\n\t\t\t\t\t\thash2 |= (1 << (offset - 32));\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tfor ( ; i < 3; i++)\n\t\t\t\ttlan_set_mac(dev, i + 1, NULL);\n\t\t\ttlan_dio_write32(dev->base_addr, TLAN_HASH_1, hash1);\n\t\t\ttlan_dio_write32(dev->base_addr, TLAN_HASH_2, hash2);\n\t\t}\n\t}\n\n}\n\n\n\n \n\n\n\n\n \n\nstatic u32 tlan_handle_tx_eof(struct net_device *dev, u16 host_int)\n{\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\tint\t\teoc = 0;\n\tstruct tlan_list\t*head_list;\n\tdma_addr_t\thead_list_phys;\n\tu32\t\tack = 0;\n\tu16\t\ttmp_c_stat;\n\n\tTLAN_DBG(TLAN_DEBUG_TX,\n\t\t \"TRANSMIT:  Handling TX EOF (Head=%d Tail=%d)\\n\",\n\t\t priv->tx_head, priv->tx_tail);\n\thead_list = priv->tx_list + priv->tx_head;\n\n\twhile (((tmp_c_stat = head_list->c_stat) & TLAN_CSTAT_FRM_CMP)\n\t       && (ack < 255)) {\n\t\tstruct sk_buff *skb = tlan_get_skb(head_list);\n\n\t\tack++;\n\t\tdma_unmap_single(&priv->pci_dev->dev,\n\t\t\t\t head_list->buffer[0].address,\n\t\t\t\t max(skb->len, (unsigned int)TLAN_MIN_FRAME_SIZE),\n\t\t\t\t DMA_TO_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t\thead_list->buffer[8].address = 0;\n\t\thead_list->buffer[9].address = 0;\n\n\t\tif (tmp_c_stat & TLAN_CSTAT_EOC)\n\t\t\teoc = 1;\n\n\t\tdev->stats.tx_bytes += head_list->frame_size;\n\n\t\thead_list->c_stat = TLAN_CSTAT_UNUSED;\n\t\tnetif_start_queue(dev);\n\t\tCIRC_INC(priv->tx_head, TLAN_NUM_TX_LISTS);\n\t\thead_list = priv->tx_list + priv->tx_head;\n\t}\n\n\tif (!ack)\n\t\tnetdev_info(dev,\n\t\t\t    \"Received interrupt for uncompleted TX frame\\n\");\n\n\tif (eoc) {\n\t\tTLAN_DBG(TLAN_DEBUG_TX,\n\t\t\t \"TRANSMIT:  handling TX EOC (Head=%d Tail=%d)\\n\",\n\t\t\t priv->tx_head, priv->tx_tail);\n\t\thead_list = priv->tx_list + priv->tx_head;\n\t\thead_list_phys = priv->tx_list_dma\n\t\t\t+ sizeof(struct tlan_list)*priv->tx_head;\n\t\tif ((head_list->c_stat & TLAN_CSTAT_READY)\n\t\t    == TLAN_CSTAT_READY) {\n\t\t\toutl(head_list_phys, dev->base_addr + TLAN_CH_PARM);\n\t\t\tack |= TLAN_HC_GO;\n\t\t} else {\n\t\t\tpriv->tx_in_progress = 0;\n\t\t}\n\t}\n\n\tif (priv->adapter->flags & TLAN_ADAPTER_ACTIVITY_LED) {\n\t\ttlan_dio_write8(dev->base_addr,\n\t\t\t\tTLAN_LED_REG, TLAN_LED_LINK | TLAN_LED_ACT);\n\t\tif (priv->timer.function == NULL) {\n\t\t\tpriv->timer.function = tlan_timer;\n\t\t\tpriv->timer.expires = jiffies + TLAN_TIMER_ACT_DELAY;\n\t\t\tpriv->timer_set_at = jiffies;\n\t\t\tpriv->timer_type = TLAN_TIMER_ACTIVITY;\n\t\t\tadd_timer(&priv->timer);\n\t\t} else if (priv->timer_type == TLAN_TIMER_ACTIVITY) {\n\t\t\tpriv->timer_set_at = jiffies;\n\t\t}\n\t}\n\n\treturn ack;\n\n}\n\n\n\n\n \n\nstatic u32 tlan_handle_stat_overflow(struct net_device *dev, u16 host_int)\n{\n\ttlan_read_and_clear_stats(dev, TLAN_RECORD);\n\n\treturn 1;\n\n}\n\n\n\n\n \n\nstatic u32 tlan_handle_rx_eof(struct net_device *dev, u16 host_int)\n{\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\tu32\t\tack = 0;\n\tint\t\teoc = 0;\n\tstruct tlan_list\t*head_list;\n\tstruct sk_buff\t*skb;\n\tstruct tlan_list\t*tail_list;\n\tu16\t\ttmp_c_stat;\n\tdma_addr_t\thead_list_phys;\n\n\tTLAN_DBG(TLAN_DEBUG_RX, \"RECEIVE:  handling RX EOF (Head=%d Tail=%d)\\n\",\n\t\t priv->rx_head, priv->rx_tail);\n\thead_list = priv->rx_list + priv->rx_head;\n\thead_list_phys =\n\t\tpriv->rx_list_dma + sizeof(struct tlan_list)*priv->rx_head;\n\n\twhile (((tmp_c_stat = head_list->c_stat) & TLAN_CSTAT_FRM_CMP)\n\t       && (ack < 255)) {\n\t\tdma_addr_t frame_dma = head_list->buffer[0].address;\n\t\tu32 frame_size = head_list->frame_size;\n\t\tstruct sk_buff *new_skb;\n\n\t\tack++;\n\t\tif (tmp_c_stat & TLAN_CSTAT_EOC)\n\t\t\teoc = 1;\n\n\t\tnew_skb = netdev_alloc_skb_ip_align(dev,\n\t\t\t\t\t\t    TLAN_MAX_FRAME_SIZE + 5);\n\t\tif (!new_skb)\n\t\t\tgoto drop_and_reuse;\n\n\t\tskb = tlan_get_skb(head_list);\n\t\tdma_unmap_single(&priv->pci_dev->dev, frame_dma,\n\t\t\t\t TLAN_MAX_FRAME_SIZE, DMA_FROM_DEVICE);\n\t\tskb_put(skb, frame_size);\n\n\t\tdev->stats.rx_bytes += frame_size;\n\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tnetif_rx(skb);\n\n\t\thead_list->buffer[0].address =\n\t\t\tdma_map_single(&priv->pci_dev->dev, new_skb->data,\n\t\t\t\t       TLAN_MAX_FRAME_SIZE, DMA_FROM_DEVICE);\n\n\t\ttlan_store_skb(head_list, new_skb);\ndrop_and_reuse:\n\t\thead_list->forward = 0;\n\t\thead_list->c_stat = 0;\n\t\ttail_list = priv->rx_list + priv->rx_tail;\n\t\ttail_list->forward = head_list_phys;\n\n\t\tCIRC_INC(priv->rx_head, TLAN_NUM_RX_LISTS);\n\t\tCIRC_INC(priv->rx_tail, TLAN_NUM_RX_LISTS);\n\t\thead_list = priv->rx_list + priv->rx_head;\n\t\thead_list_phys = priv->rx_list_dma\n\t\t\t+ sizeof(struct tlan_list)*priv->rx_head;\n\t}\n\n\tif (!ack)\n\t\tnetdev_info(dev,\n\t\t\t    \"Received interrupt for uncompleted RX frame\\n\");\n\n\n\tif (eoc) {\n\t\tTLAN_DBG(TLAN_DEBUG_RX,\n\t\t\t \"RECEIVE:  handling RX EOC (Head=%d Tail=%d)\\n\",\n\t\t\t priv->rx_head, priv->rx_tail);\n\t\thead_list = priv->rx_list + priv->rx_head;\n\t\thead_list_phys = priv->rx_list_dma\n\t\t\t+ sizeof(struct tlan_list)*priv->rx_head;\n\t\toutl(head_list_phys, dev->base_addr + TLAN_CH_PARM);\n\t\tack |= TLAN_HC_GO | TLAN_HC_RT;\n\t\tpriv->rx_eoc_count++;\n\t}\n\n\tif (priv->adapter->flags & TLAN_ADAPTER_ACTIVITY_LED) {\n\t\ttlan_dio_write8(dev->base_addr,\n\t\t\t\tTLAN_LED_REG, TLAN_LED_LINK | TLAN_LED_ACT);\n\t\tif (priv->timer.function == NULL)  {\n\t\t\tpriv->timer.function = tlan_timer;\n\t\t\tpriv->timer.expires = jiffies + TLAN_TIMER_ACT_DELAY;\n\t\t\tpriv->timer_set_at = jiffies;\n\t\t\tpriv->timer_type = TLAN_TIMER_ACTIVITY;\n\t\t\tadd_timer(&priv->timer);\n\t\t} else if (priv->timer_type == TLAN_TIMER_ACTIVITY) {\n\t\t\tpriv->timer_set_at = jiffies;\n\t\t}\n\t}\n\n\treturn ack;\n\n}\n\n\n\n\n \n\nstatic u32 tlan_handle_dummy(struct net_device *dev, u16 host_int)\n{\n\tnetdev_info(dev, \"Test interrupt\\n\");\n\treturn 1;\n\n}\n\n\n\n\n \n\nstatic u32 tlan_handle_tx_eoc(struct net_device *dev, u16 host_int)\n{\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\tstruct tlan_list\t\t*head_list;\n\tdma_addr_t\t\thead_list_phys;\n\tu32\t\t\tack = 1;\n\n\tif (priv->tlan_rev < 0x30) {\n\t\tTLAN_DBG(TLAN_DEBUG_TX,\n\t\t\t \"TRANSMIT:  handling TX EOC (Head=%d Tail=%d) -- IRQ\\n\",\n\t\t\t priv->tx_head, priv->tx_tail);\n\t\thead_list = priv->tx_list + priv->tx_head;\n\t\thead_list_phys = priv->tx_list_dma\n\t\t\t+ sizeof(struct tlan_list)*priv->tx_head;\n\t\tif ((head_list->c_stat & TLAN_CSTAT_READY)\n\t\t    == TLAN_CSTAT_READY) {\n\t\t\tnetif_stop_queue(dev);\n\t\t\toutl(head_list_phys, dev->base_addr + TLAN_CH_PARM);\n\t\t\tack |= TLAN_HC_GO;\n\t\t} else {\n\t\t\tpriv->tx_in_progress = 0;\n\t\t}\n\t}\n\n\treturn ack;\n\n}\n\n\n\n\n \n\nstatic u32 tlan_handle_status_check(struct net_device *dev, u16 host_int)\n{\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\tu32\t\tack;\n\tu32\t\terror;\n\tu8\t\tnet_sts;\n\tu32\t\tphy;\n\tu16\t\ttlphy_ctl;\n\tu16\t\ttlphy_sts;\n\n\tack = 1;\n\tif (host_int & TLAN_HI_IV_MASK) {\n\t\tnetif_stop_queue(dev);\n\t\terror = inl(dev->base_addr + TLAN_CH_PARM);\n\t\tnetdev_info(dev, \"Adaptor Error = 0x%x\\n\", error);\n\t\ttlan_read_and_clear_stats(dev, TLAN_RECORD);\n\t\toutl(TLAN_HC_AD_RST, dev->base_addr + TLAN_HOST_CMD);\n\n\t\tschedule_work(&priv->tlan_tqueue);\n\n\t\tnetif_wake_queue(dev);\n\t\tack = 0;\n\t} else {\n\t\tTLAN_DBG(TLAN_DEBUG_GNRL, \"%s: Status Check\\n\", dev->name);\n\t\tphy = priv->phy[priv->phy_num];\n\n\t\tnet_sts = tlan_dio_read8(dev->base_addr, TLAN_NET_STS);\n\t\tif (net_sts) {\n\t\t\ttlan_dio_write8(dev->base_addr, TLAN_NET_STS, net_sts);\n\t\t\tTLAN_DBG(TLAN_DEBUG_GNRL, \"%s:    Net_Sts = %x\\n\",\n\t\t\t\t dev->name, (unsigned) net_sts);\n\t\t}\n\t\tif ((net_sts & TLAN_NET_STS_MIRQ) &&  (priv->phy_num == 0)) {\n\t\t\t__tlan_mii_read_reg(dev, phy, TLAN_TLPHY_STS, &tlphy_sts);\n\t\t\t__tlan_mii_read_reg(dev, phy, TLAN_TLPHY_CTL, &tlphy_ctl);\n\t\t\tif (!(tlphy_sts & TLAN_TS_POLOK) &&\n\t\t\t    !(tlphy_ctl & TLAN_TC_SWAPOL)) {\n\t\t\t\ttlphy_ctl |= TLAN_TC_SWAPOL;\n\t\t\t\t__tlan_mii_write_reg(dev, phy, TLAN_TLPHY_CTL,\n\t\t\t\t\t\t     tlphy_ctl);\n\t\t\t} else if ((tlphy_sts & TLAN_TS_POLOK) &&\n\t\t\t\t   (tlphy_ctl & TLAN_TC_SWAPOL)) {\n\t\t\t\ttlphy_ctl &= ~TLAN_TC_SWAPOL;\n\t\t\t\t__tlan_mii_write_reg(dev, phy, TLAN_TLPHY_CTL,\n\t\t\t\t\t\t     tlphy_ctl);\n\t\t\t}\n\n\t\t\tif (debug)\n\t\t\t\t__tlan_phy_print(dev);\n\t\t}\n\t}\n\n\treturn ack;\n\n}\n\n\n\n\n \n\nstatic u32 tlan_handle_rx_eoc(struct net_device *dev, u16 host_int)\n{\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\tdma_addr_t\thead_list_phys;\n\tu32\t\tack = 1;\n\n\tif (priv->tlan_rev < 0x30) {\n\t\tTLAN_DBG(TLAN_DEBUG_RX,\n\t\t\t \"RECEIVE:  Handling RX EOC (head=%d tail=%d) -- IRQ\\n\",\n\t\t\t priv->rx_head, priv->rx_tail);\n\t\thead_list_phys = priv->rx_list_dma\n\t\t\t+ sizeof(struct tlan_list)*priv->rx_head;\n\t\toutl(head_list_phys, dev->base_addr + TLAN_CH_PARM);\n\t\tack |= TLAN_HC_GO | TLAN_HC_RT;\n\t\tpriv->rx_eoc_count++;\n\t}\n\n\treturn ack;\n\n}\n\n\n\n\n \n\n\n \n\nstatic void tlan_timer(struct timer_list *t)\n{\n\tstruct tlan_priv\t*priv = from_timer(priv, t, timer);\n\tstruct net_device\t*dev = priv->dev;\n\tu32\t\telapsed;\n\tunsigned long\tflags = 0;\n\n\tpriv->timer.function = NULL;\n\n\tswitch (priv->timer_type) {\n\tcase TLAN_TIMER_PHY_PDOWN:\n\t\ttlan_phy_power_down(dev);\n\t\tbreak;\n\tcase TLAN_TIMER_PHY_PUP:\n\t\ttlan_phy_power_up(dev);\n\t\tbreak;\n\tcase TLAN_TIMER_PHY_RESET:\n\t\ttlan_phy_reset(dev);\n\t\tbreak;\n\tcase TLAN_TIMER_PHY_START_LINK:\n\t\ttlan_phy_start_link(dev);\n\t\tbreak;\n\tcase TLAN_TIMER_PHY_FINISH_AN:\n\t\ttlan_phy_finish_auto_neg(dev);\n\t\tbreak;\n\tcase TLAN_TIMER_FINISH_RESET:\n\t\ttlan_finish_reset(dev);\n\t\tbreak;\n\tcase TLAN_TIMER_ACTIVITY:\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tif (priv->timer.function == NULL) {\n\t\t\telapsed = jiffies - priv->timer_set_at;\n\t\t\tif (elapsed >= TLAN_TIMER_ACT_DELAY) {\n\t\t\t\ttlan_dio_write8(dev->base_addr,\n\t\t\t\t\t\tTLAN_LED_REG, TLAN_LED_LINK);\n\t\t\t} else  {\n\t\t\t\tpriv->timer.expires = priv->timer_set_at\n\t\t\t\t\t+ TLAN_TIMER_ACT_DELAY;\n\t\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\t\tadd_timer(&priv->timer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n}\n\n\n \n\n\n \n\nstatic void tlan_reset_lists(struct net_device *dev)\n{\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\tint\t\ti;\n\tstruct tlan_list\t*list;\n\tdma_addr_t\tlist_phys;\n\tstruct sk_buff\t*skb;\n\n\tpriv->tx_head = 0;\n\tpriv->tx_tail = 0;\n\tfor (i = 0; i < TLAN_NUM_TX_LISTS; i++) {\n\t\tlist = priv->tx_list + i;\n\t\tlist->c_stat = TLAN_CSTAT_UNUSED;\n\t\tlist->buffer[0].address = 0;\n\t\tlist->buffer[2].count = 0;\n\t\tlist->buffer[2].address = 0;\n\t\tlist->buffer[8].address = 0;\n\t\tlist->buffer[9].address = 0;\n\t}\n\n\tpriv->rx_head = 0;\n\tpriv->rx_tail = TLAN_NUM_RX_LISTS - 1;\n\tfor (i = 0; i < TLAN_NUM_RX_LISTS; i++) {\n\t\tlist = priv->rx_list + i;\n\t\tlist_phys = priv->rx_list_dma + sizeof(struct tlan_list)*i;\n\t\tlist->c_stat = TLAN_CSTAT_READY;\n\t\tlist->frame_size = TLAN_MAX_FRAME_SIZE;\n\t\tlist->buffer[0].count = TLAN_MAX_FRAME_SIZE | TLAN_LAST_BUFFER;\n\t\tskb = netdev_alloc_skb_ip_align(dev, TLAN_MAX_FRAME_SIZE + 5);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tlist->buffer[0].address = dma_map_single(&priv->pci_dev->dev,\n\t\t\t\t\t\t\t skb->data,\n\t\t\t\t\t\t\t TLAN_MAX_FRAME_SIZE,\n\t\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\ttlan_store_skb(list, skb);\n\t\tlist->buffer[1].count = 0;\n\t\tlist->buffer[1].address = 0;\n\t\tlist->forward = list_phys + sizeof(struct tlan_list);\n\t}\n\n\t \n\twhile (i < TLAN_NUM_RX_LISTS) {\n\t\ttlan_store_skb(priv->rx_list + i, NULL);\n\t\t++i;\n\t}\n\tlist->forward = 0;\n\n}\n\n\nstatic void tlan_free_lists(struct net_device *dev)\n{\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\tint\t\ti;\n\tstruct tlan_list\t*list;\n\tstruct sk_buff\t*skb;\n\n\tfor (i = 0; i < TLAN_NUM_TX_LISTS; i++) {\n\t\tlist = priv->tx_list + i;\n\t\tskb = tlan_get_skb(list);\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&priv->pci_dev->dev,\n\t\t\t\t\t list->buffer[0].address,\n\t\t\t\t\t max(skb->len, (unsigned int)TLAN_MIN_FRAME_SIZE),\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tlist->buffer[8].address = 0;\n\t\t\tlist->buffer[9].address = 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < TLAN_NUM_RX_LISTS; i++) {\n\t\tlist = priv->rx_list + i;\n\t\tskb = tlan_get_skb(list);\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&priv->pci_dev->dev,\n\t\t\t\t\t list->buffer[0].address,\n\t\t\t\t\t TLAN_MAX_FRAME_SIZE, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tlist->buffer[8].address = 0;\n\t\t\tlist->buffer[9].address = 0;\n\t\t}\n\t}\n}\n\n\n\n\n \n\nstatic void tlan_print_dio(u16 io_base)\n{\n\tu32 data0, data1;\n\tint\ti;\n\n\tpr_info(\"Contents of internal registers for io base 0x%04hx\\n\",\n\t\tio_base);\n\tpr_info(\"Off.  +0        +4\\n\");\n\tfor (i = 0; i < 0x4C; i += 8) {\n\t\tdata0 = tlan_dio_read32(io_base, i);\n\t\tdata1 = tlan_dio_read32(io_base, i + 0x4);\n\t\tpr_info(\"0x%02x  0x%08x 0x%08x\\n\", i, data0, data1);\n\t}\n\n}\n\n\n\n\n \n\nstatic void tlan_print_list(struct tlan_list *list, char *type, int num)\n{\n\tint i;\n\n\tpr_info(\"%s List %d at %p\\n\", type, num, list);\n\tpr_info(\"   Forward    = 0x%08x\\n\",  list->forward);\n\tpr_info(\"   CSTAT      = 0x%04hx\\n\", list->c_stat);\n\tpr_info(\"   Frame Size = 0x%04hx\\n\", list->frame_size);\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tpr_info(\"   Buffer[%d].count, addr = 0x%08x, 0x%08x\\n\",\n\t\t\ti, list->buffer[i].count, list->buffer[i].address);\n\t}\n\n}\n\n\n\n\n \n\nstatic void tlan_read_and_clear_stats(struct net_device *dev, int record)\n{\n\tu32\t\ttx_good, tx_under;\n\tu32\t\trx_good, rx_over;\n\tu32\t\tdef_tx, crc, code;\n\tu32\t\tmulti_col, single_col;\n\tu32\t\texcess_col, late_col, loss;\n\n\toutw(TLAN_GOOD_TX_FRMS, dev->base_addr + TLAN_DIO_ADR);\n\ttx_good  = inb(dev->base_addr + TLAN_DIO_DATA);\n\ttx_good += inb(dev->base_addr + TLAN_DIO_DATA + 1) << 8;\n\ttx_good += inb(dev->base_addr + TLAN_DIO_DATA + 2) << 16;\n\ttx_under = inb(dev->base_addr + TLAN_DIO_DATA + 3);\n\n\toutw(TLAN_GOOD_RX_FRMS, dev->base_addr + TLAN_DIO_ADR);\n\trx_good  = inb(dev->base_addr + TLAN_DIO_DATA);\n\trx_good += inb(dev->base_addr + TLAN_DIO_DATA + 1) << 8;\n\trx_good += inb(dev->base_addr + TLAN_DIO_DATA + 2) << 16;\n\trx_over  = inb(dev->base_addr + TLAN_DIO_DATA + 3);\n\n\toutw(TLAN_DEFERRED_TX, dev->base_addr + TLAN_DIO_ADR);\n\tdef_tx  = inb(dev->base_addr + TLAN_DIO_DATA);\n\tdef_tx += inb(dev->base_addr + TLAN_DIO_DATA + 1) << 8;\n\tcrc     = inb(dev->base_addr + TLAN_DIO_DATA + 2);\n\tcode    = inb(dev->base_addr + TLAN_DIO_DATA + 3);\n\n\toutw(TLAN_MULTICOL_FRMS, dev->base_addr + TLAN_DIO_ADR);\n\tmulti_col   = inb(dev->base_addr + TLAN_DIO_DATA);\n\tmulti_col  += inb(dev->base_addr + TLAN_DIO_DATA + 1) << 8;\n\tsingle_col  = inb(dev->base_addr + TLAN_DIO_DATA + 2);\n\tsingle_col += inb(dev->base_addr + TLAN_DIO_DATA + 3) << 8;\n\n\toutw(TLAN_EXCESSCOL_FRMS, dev->base_addr + TLAN_DIO_ADR);\n\texcess_col = inb(dev->base_addr + TLAN_DIO_DATA);\n\tlate_col   = inb(dev->base_addr + TLAN_DIO_DATA + 1);\n\tloss       = inb(dev->base_addr + TLAN_DIO_DATA + 2);\n\n\tif (record) {\n\t\tdev->stats.rx_packets += rx_good;\n\t\tdev->stats.rx_errors  += rx_over + crc + code;\n\t\tdev->stats.tx_packets += tx_good;\n\t\tdev->stats.tx_errors  += tx_under + loss;\n\t\tdev->stats.collisions += multi_col\n\t\t\t+ single_col + excess_col + late_col;\n\n\t\tdev->stats.rx_over_errors    += rx_over;\n\t\tdev->stats.rx_crc_errors     += crc;\n\t\tdev->stats.rx_frame_errors   += code;\n\n\t\tdev->stats.tx_aborted_errors += tx_under;\n\t\tdev->stats.tx_carrier_errors += loss;\n\t}\n\n}\n\n\n\n\n \n\nstatic void\ntlan_reset_adapter(struct net_device *dev)\n{\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\tint\t\ti;\n\tu32\t\taddr;\n\tu32\t\tdata;\n\tu8\t\tdata8;\n\n\tpriv->tlan_full_duplex = false;\n\tpriv->phy_online = 0;\n\tnetif_carrier_off(dev);\n\n \n\n\tdata = inl(dev->base_addr + TLAN_HOST_CMD);\n\tdata |= TLAN_HC_AD_RST;\n\toutl(data, dev->base_addr + TLAN_HOST_CMD);\n\n\tudelay(1000);\n\n \n\n\tdata = inl(dev->base_addr + TLAN_HOST_CMD);\n\tdata |= TLAN_HC_INT_OFF;\n\toutl(data, dev->base_addr + TLAN_HOST_CMD);\n\n \n\n\tfor (i = TLAN_AREG_0; i <= TLAN_HASH_2; i += 4)\n\t\ttlan_dio_write32(dev->base_addr, (u16) i, 0);\n\n \n\n\tdata = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN | TLAN_NET_CFG_PHY_EN;\n\ttlan_dio_write16(dev->base_addr, TLAN_NET_CONFIG, (u16) data);\n\n \n\n\toutl(TLAN_HC_LD_TMR | 0x3f, dev->base_addr + TLAN_HOST_CMD);\n\toutl(TLAN_HC_LD_THR | 0x9, dev->base_addr + TLAN_HOST_CMD);\n\n \n\n\toutw(TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR);\n\taddr = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;\n\ttlan_set_bit(TLAN_NET_SIO_NMRST, addr);\n\n \n\n\tif (priv->tlan_rev >= 0x30) {\n\t\tdata8 = TLAN_ID_TX_EOC | TLAN_ID_RX_EOC;\n\t\ttlan_dio_write8(dev->base_addr, TLAN_INT_DIS, data8);\n\t}\n\ttlan_phy_detect(dev);\n\tdata = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN;\n\n\tif (priv->adapter->flags & TLAN_ADAPTER_BIT_RATE_PHY) {\n\t\tdata |= TLAN_NET_CFG_BIT;\n\t\tif (priv->aui == 1) {\n\t\t\ttlan_dio_write8(dev->base_addr, TLAN_ACOMMIT, 0x0a);\n\t\t} else if (priv->duplex == TLAN_DUPLEX_FULL) {\n\t\t\ttlan_dio_write8(dev->base_addr, TLAN_ACOMMIT, 0x00);\n\t\t\tpriv->tlan_full_duplex = true;\n\t\t} else {\n\t\t\ttlan_dio_write8(dev->base_addr, TLAN_ACOMMIT, 0x08);\n\t\t}\n\t}\n\n\t \n\tif (priv->phy_num == 0 ||\n\t   (priv->adapter->flags & TLAN_ADAPTER_USE_INTERN_10))\n\t\tdata |= TLAN_NET_CFG_PHY_EN;\n\ttlan_dio_write16(dev->base_addr, TLAN_NET_CONFIG, (u16) data);\n\n\tif (priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY)\n\t\ttlan_finish_reset(dev);\n\telse\n\t\ttlan_phy_power_down(dev);\n\n}\n\n\n\n\nstatic void\ntlan_finish_reset(struct net_device *dev)\n{\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\tu8\t\tdata;\n\tu32\t\tphy;\n\tu8\t\tsio;\n\tu16\t\tstatus;\n\tu16\t\tpartner;\n\tu16\t\ttlphy_ctl;\n\tu16\t\ttlphy_par;\n\tu16\t\ttlphy_id1, tlphy_id2;\n\tint\t\ti;\n\n\tphy = priv->phy[priv->phy_num];\n\n\tdata = TLAN_NET_CMD_NRESET | TLAN_NET_CMD_NWRAP;\n\tif (priv->tlan_full_duplex)\n\t\tdata |= TLAN_NET_CMD_DUPLEX;\n\ttlan_dio_write8(dev->base_addr, TLAN_NET_CMD, data);\n\tdata = TLAN_NET_MASK_MASK4 | TLAN_NET_MASK_MASK5;\n\tif (priv->phy_num == 0)\n\t\tdata |= TLAN_NET_MASK_MASK7;\n\ttlan_dio_write8(dev->base_addr, TLAN_NET_MASK, data);\n\ttlan_dio_write16(dev->base_addr, TLAN_MAX_RX, ((1536)+7)&~7);\n\ttlan_mii_read_reg(dev, phy, MII_GEN_ID_HI, &tlphy_id1);\n\ttlan_mii_read_reg(dev, phy, MII_GEN_ID_LO, &tlphy_id2);\n\n\tif ((priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY) ||\n\t    (priv->aui)) {\n\t\tstatus = MII_GS_LINK;\n\t\tnetdev_info(dev, \"Link forced\\n\");\n\t} else {\n\t\ttlan_mii_read_reg(dev, phy, MII_GEN_STS, &status);\n\t\tudelay(1000);\n\t\ttlan_mii_read_reg(dev, phy, MII_GEN_STS, &status);\n\t\tif (status & MII_GS_LINK) {\n\t\t\t \n\t\t\tif ((tlphy_id1 == NAT_SEM_ID1) &&\n\t\t\t    (tlphy_id2 == NAT_SEM_ID2)) {\n\t\t\t\ttlan_mii_read_reg(dev, phy, MII_AN_LPA,\n\t\t\t\t\t&partner);\n\t\t\t\ttlan_mii_read_reg(dev, phy, TLAN_TLPHY_PAR,\n\t\t\t\t\t&tlphy_par);\n\n\t\t\t\tnetdev_info(dev,\n\t\t\t\t\t\"Link active, %s %uMbps %s-Duplex\\n\",\n\t\t\t\t\t!(tlphy_par & TLAN_PHY_AN_EN_STAT)\n\t\t\t\t\t? \"forced\" : \"Autonegotiation enabled,\",\n\t\t\t\t\ttlphy_par & TLAN_PHY_SPEED_100\n\t\t\t\t\t? 100 : 10,\n\t\t\t\t\ttlphy_par & TLAN_PHY_DUPLEX_FULL\n\t\t\t\t\t? \"Full\" : \"Half\");\n\n\t\t\t\tif (tlphy_par & TLAN_PHY_AN_EN_STAT) {\n\t\t\t\t\tnetdev_info(dev, \"Partner capability:\");\n\t\t\t\t\tfor (i = 5; i < 10; i++)\n\t\t\t\t\t\tif (partner & (1 << i))\n\t\t\t\t\t\t\tpr_cont(\" %s\",\n\t\t\t\t\t\t\t\tmedia[i-5]);\n\t\t\t\t\tpr_cont(\"\\n\");\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tnetdev_info(dev, \"Link active\\n\");\n\t\t\t \n\t\t\tpriv->media_timer.expires = jiffies + HZ;\n\t\t\tadd_timer(&priv->media_timer);\n\t\t}\n\t}\n\n\tif (priv->phy_num == 0) {\n\t\ttlan_mii_read_reg(dev, phy, TLAN_TLPHY_CTL, &tlphy_ctl);\n\t\ttlphy_ctl |= TLAN_TC_INTEN;\n\t\ttlan_mii_write_reg(dev, phy, TLAN_TLPHY_CTL, tlphy_ctl);\n\t\tsio = tlan_dio_read8(dev->base_addr, TLAN_NET_SIO);\n\t\tsio |= TLAN_NET_SIO_MINTEN;\n\t\ttlan_dio_write8(dev->base_addr, TLAN_NET_SIO, sio);\n\t}\n\n\tif (status & MII_GS_LINK) {\n\t\ttlan_set_mac(dev, 0, dev->dev_addr);\n\t\tpriv->phy_online = 1;\n\t\toutb((TLAN_HC_INT_ON >> 8), dev->base_addr + TLAN_HOST_CMD + 1);\n\t\tif (debug >= 1 && debug != TLAN_DEBUG_PROBE)\n\t\t\toutb((TLAN_HC_REQ_INT >> 8),\n\t\t\t     dev->base_addr + TLAN_HOST_CMD + 1);\n\t\toutl(priv->rx_list_dma, dev->base_addr + TLAN_CH_PARM);\n\t\toutl(TLAN_HC_GO | TLAN_HC_RT, dev->base_addr + TLAN_HOST_CMD);\n\t\ttlan_dio_write8(dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK);\n\t\tnetif_carrier_on(dev);\n\t} else {\n\t\tnetdev_info(dev, \"Link inactive, will retry in 10 secs...\\n\");\n\t\ttlan_set_timer(dev, (10*HZ), TLAN_TIMER_FINISH_RESET);\n\t\treturn;\n\t}\n\ttlan_set_multicast_list(dev);\n\n}\n\n\n\n\n \n\nstatic void tlan_set_mac(struct net_device *dev, int areg, const char *mac)\n{\n\tint i;\n\n\tareg *= 6;\n\n\tif (mac != NULL) {\n\t\tfor (i = 0; i < 6; i++)\n\t\t\ttlan_dio_write8(dev->base_addr,\n\t\t\t\t\tTLAN_AREG_0 + areg + i, mac[i]);\n\t} else {\n\t\tfor (i = 0; i < 6; i++)\n\t\t\ttlan_dio_write8(dev->base_addr,\n\t\t\t\t\tTLAN_AREG_0 + areg + i, 0);\n\t}\n\n}\n\n\n\n\n \n\n\n\n \n\nstatic void __tlan_phy_print(struct net_device *dev)\n{\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\tu16 i, data0, data1, data2, data3, phy;\n\n\tlockdep_assert_held(&priv->lock);\n\n\tphy = priv->phy[priv->phy_num];\n\n\tif (priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY) {\n\t\tnetdev_info(dev, \"Unmanaged PHY\\n\");\n\t} else if (phy <= TLAN_PHY_MAX_ADDR) {\n\t\tnetdev_info(dev, \"PHY 0x%02x\\n\", phy);\n\t\tpr_info(\"   Off.  +0     +1     +2     +3\\n\");\n\t\tfor (i = 0; i < 0x20; i += 4) {\n\t\t\t__tlan_mii_read_reg(dev, phy, i, &data0);\n\t\t\t__tlan_mii_read_reg(dev, phy, i + 1, &data1);\n\t\t\t__tlan_mii_read_reg(dev, phy, i + 2, &data2);\n\t\t\t__tlan_mii_read_reg(dev, phy, i + 3, &data3);\n\t\t\tpr_info(\"   0x%02x 0x%04hx 0x%04hx 0x%04hx 0x%04hx\\n\",\n\t\t\t\ti, data0, data1, data2, data3);\n\t\t}\n\t} else {\n\t\tnetdev_info(dev, \"Invalid PHY\\n\");\n\t}\n\n}\n\nstatic void tlan_phy_print(struct net_device *dev)\n{\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t__tlan_phy_print(dev);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\n\n \n\nstatic void tlan_phy_detect(struct net_device *dev)\n{\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\tu16\t\tcontrol;\n\tu16\t\thi;\n\tu16\t\tlo;\n\tu32\t\tphy;\n\n\tif (priv->adapter->flags & TLAN_ADAPTER_UNMANAGED_PHY) {\n\t\tpriv->phy_num = 0xffff;\n\t\treturn;\n\t}\n\n\ttlan_mii_read_reg(dev, TLAN_PHY_MAX_ADDR, MII_GEN_ID_HI, &hi);\n\n\tif (hi != 0xffff)\n\t\tpriv->phy[0] = TLAN_PHY_MAX_ADDR;\n\telse\n\t\tpriv->phy[0] = TLAN_PHY_NONE;\n\n\tpriv->phy[1] = TLAN_PHY_NONE;\n\tfor (phy = 0; phy <= TLAN_PHY_MAX_ADDR; phy++) {\n\t\ttlan_mii_read_reg(dev, phy, MII_GEN_CTL, &control);\n\t\ttlan_mii_read_reg(dev, phy, MII_GEN_ID_HI, &hi);\n\t\ttlan_mii_read_reg(dev, phy, MII_GEN_ID_LO, &lo);\n\t\tif ((control != 0xffff) ||\n\t\t    (hi != 0xffff) || (lo != 0xffff)) {\n\t\t\tTLAN_DBG(TLAN_DEBUG_GNRL,\n\t\t\t\t \"PHY found at %02x %04x %04x %04x\\n\",\n\t\t\t\t phy, control, hi, lo);\n\t\t\tif ((priv->phy[1] == TLAN_PHY_NONE) &&\n\t\t\t    (phy != TLAN_PHY_MAX_ADDR)) {\n\t\t\t\tpriv->phy[1] = phy;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (priv->phy[1] != TLAN_PHY_NONE)\n\t\tpriv->phy_num = 1;\n\telse if (priv->phy[0] != TLAN_PHY_NONE)\n\t\tpriv->phy_num = 0;\n\telse\n\t\tnetdev_info(dev, \"Cannot initialize device, no PHY was found!\\n\");\n\n}\n\n\n\n\nstatic void tlan_phy_power_down(struct net_device *dev)\n{\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\tu16\t\tvalue;\n\n\tTLAN_DBG(TLAN_DEBUG_GNRL, \"%s: Powering down PHY(s).\\n\", dev->name);\n\tvalue = MII_GC_PDOWN | MII_GC_LOOPBK | MII_GC_ISOLATE;\n\ttlan_mii_sync(dev->base_addr);\n\ttlan_mii_write_reg(dev, priv->phy[priv->phy_num], MII_GEN_CTL, value);\n\tif ((priv->phy_num == 0) && (priv->phy[1] != TLAN_PHY_NONE)) {\n\t\t \n\t\tif (priv->adapter->flags & TLAN_ADAPTER_USE_INTERN_10)\n\t\t\tvalue = MII_GC_ISOLATE;  \n\t\ttlan_mii_sync(dev->base_addr);\n\t\ttlan_mii_write_reg(dev, priv->phy[1], MII_GEN_CTL, value);\n\t}\n\n\t \n\ttlan_set_timer(dev, msecs_to_jiffies(50), TLAN_TIMER_PHY_PUP);\n\n}\n\n\n\n\nstatic void tlan_phy_power_up(struct net_device *dev)\n{\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\tu16\t\tvalue;\n\n\tTLAN_DBG(TLAN_DEBUG_GNRL, \"%s: Powering up PHY.\\n\", dev->name);\n\ttlan_mii_sync(dev->base_addr);\n\tvalue = MII_GC_LOOPBK;\n\ttlan_mii_write_reg(dev, priv->phy[priv->phy_num], MII_GEN_CTL, value);\n\ttlan_mii_sync(dev->base_addr);\n\t \n\ttlan_set_timer(dev, msecs_to_jiffies(500), TLAN_TIMER_PHY_RESET);\n\n}\n\n\n\n\nstatic void tlan_phy_reset(struct net_device *dev)\n{\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\tu16\t\tphy;\n\tu16\t\tvalue;\n\tunsigned long timeout = jiffies + HZ;\n\n\tphy = priv->phy[priv->phy_num];\n\n\tTLAN_DBG(TLAN_DEBUG_GNRL, \"%s: Resetting PHY.\\n\", dev->name);\n\ttlan_mii_sync(dev->base_addr);\n\tvalue = MII_GC_LOOPBK | MII_GC_RESET;\n\ttlan_mii_write_reg(dev, phy, MII_GEN_CTL, value);\n\tdo {\n\t\ttlan_mii_read_reg(dev, phy, MII_GEN_CTL, &value);\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tnetdev_err(dev, \"PHY reset timeout\\n\");\n\t\t\treturn;\n\t\t}\n\t} while (value & MII_GC_RESET);\n\n\t \n\ttlan_set_timer(dev, msecs_to_jiffies(50), TLAN_TIMER_PHY_START_LINK);\n\n}\n\n\n\n\nstatic void tlan_phy_start_link(struct net_device *dev)\n{\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\tu16\t\tability;\n\tu16\t\tcontrol;\n\tu16\t\tdata;\n\tu16\t\tphy;\n\tu16\t\tstatus;\n\tu16\t\ttctl;\n\n\tphy = priv->phy[priv->phy_num];\n\tTLAN_DBG(TLAN_DEBUG_GNRL, \"%s: Trying to activate link.\\n\", dev->name);\n\ttlan_mii_read_reg(dev, phy, MII_GEN_STS, &status);\n\ttlan_mii_read_reg(dev, phy, MII_GEN_STS, &ability);\n\n\tif ((status & MII_GS_AUTONEG) &&\n\t    (!priv->aui)) {\n\t\tability = status >> 11;\n\t\tif (priv->speed  == TLAN_SPEED_10 &&\n\t\t    priv->duplex == TLAN_DUPLEX_HALF) {\n\t\t\ttlan_mii_write_reg(dev, phy, MII_GEN_CTL, 0x0000);\n\t\t} else if (priv->speed == TLAN_SPEED_10 &&\n\t\t\t   priv->duplex == TLAN_DUPLEX_FULL) {\n\t\t\tpriv->tlan_full_duplex = true;\n\t\t\ttlan_mii_write_reg(dev, phy, MII_GEN_CTL, 0x0100);\n\t\t} else if (priv->speed == TLAN_SPEED_100 &&\n\t\t\t   priv->duplex == TLAN_DUPLEX_HALF) {\n\t\t\ttlan_mii_write_reg(dev, phy, MII_GEN_CTL, 0x2000);\n\t\t} else if (priv->speed == TLAN_SPEED_100 &&\n\t\t\t   priv->duplex == TLAN_DUPLEX_FULL) {\n\t\t\tpriv->tlan_full_duplex = true;\n\t\t\ttlan_mii_write_reg(dev, phy, MII_GEN_CTL, 0x2100);\n\t\t} else {\n\n\t\t\t \n\t\t\ttlan_mii_write_reg(dev, phy, MII_AN_ADV,\n\t\t\t\t\t   (ability << 5) | 1);\n\t\t\t \n\t\t\ttlan_mii_write_reg(dev, phy, MII_GEN_CTL, 0x1000);\n\t\t\t \n\t\t\ttlan_mii_write_reg(dev, phy, MII_GEN_CTL, 0x1200);\n\t\t\t \n\t\t\tnetdev_info(dev, \"Starting autonegotiation\\n\");\n\t\t\ttlan_set_timer(dev, (2*HZ), TLAN_TIMER_PHY_FINISH_AN);\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\tif ((priv->aui) && (priv->phy_num != 0)) {\n\t\tpriv->phy_num = 0;\n\t\tdata = TLAN_NET_CFG_1FRAG | TLAN_NET_CFG_1CHAN\n\t\t\t| TLAN_NET_CFG_PHY_EN;\n\t\ttlan_dio_write16(dev->base_addr, TLAN_NET_CONFIG, data);\n\t\ttlan_set_timer(dev, msecs_to_jiffies(40), TLAN_TIMER_PHY_PDOWN);\n\t\treturn;\n\t} else if (priv->phy_num == 0) {\n\t\tcontrol = 0;\n\t\ttlan_mii_read_reg(dev, phy, TLAN_TLPHY_CTL, &tctl);\n\t\tif (priv->aui) {\n\t\t\ttctl |= TLAN_TC_AUISEL;\n\t\t} else {\n\t\t\ttctl &= ~TLAN_TC_AUISEL;\n\t\t\tif (priv->duplex == TLAN_DUPLEX_FULL) {\n\t\t\t\tcontrol |= MII_GC_DUPLEX;\n\t\t\t\tpriv->tlan_full_duplex = true;\n\t\t\t}\n\t\t\tif (priv->speed == TLAN_SPEED_100)\n\t\t\t\tcontrol |= MII_GC_SPEEDSEL;\n\t\t}\n\t\ttlan_mii_write_reg(dev, phy, MII_GEN_CTL, control);\n\t\ttlan_mii_write_reg(dev, phy, TLAN_TLPHY_CTL, tctl);\n\t}\n\n\t \n\ttlan_set_timer(dev, (4*HZ), TLAN_TIMER_FINISH_RESET);\n\n}\n\n\n\n\nstatic void tlan_phy_finish_auto_neg(struct net_device *dev)\n{\n\tstruct tlan_priv\t*priv = netdev_priv(dev);\n\tu16\t\tan_adv;\n\tu16\t\tan_lpa;\n\tu16\t\tmode;\n\tu16\t\tphy;\n\tu16\t\tstatus;\n\n\tphy = priv->phy[priv->phy_num];\n\n\ttlan_mii_read_reg(dev, phy, MII_GEN_STS, &status);\n\tudelay(1000);\n\ttlan_mii_read_reg(dev, phy, MII_GEN_STS, &status);\n\n\tif (!(status & MII_GS_AUTOCMPLT)) {\n\t\t \n\t\ttlan_set_timer(dev, 2 * HZ, TLAN_TIMER_PHY_FINISH_AN);\n\t\treturn;\n\t}\n\n\tnetdev_info(dev, \"Autonegotiation complete\\n\");\n\ttlan_mii_read_reg(dev, phy, MII_AN_ADV, &an_adv);\n\ttlan_mii_read_reg(dev, phy, MII_AN_LPA, &an_lpa);\n\tmode = an_adv & an_lpa & 0x03E0;\n\tif (mode & 0x0100)\n\t\tpriv->tlan_full_duplex = true;\n\telse if (!(mode & 0x0080) && (mode & 0x0040))\n\t\tpriv->tlan_full_duplex = true;\n\n\t \n\tif ((!(mode & 0x0180)) &&\n\t    (priv->adapter->flags & TLAN_ADAPTER_USE_INTERN_10) &&\n\t    (priv->phy_num != 0)) {\n\t\tpriv->phy_num = 0;\n\t\ttlan_set_timer(dev, msecs_to_jiffies(400), TLAN_TIMER_PHY_PDOWN);\n\t\treturn;\n\t}\n\n\tif (priv->phy_num == 0) {\n\t\tif ((priv->duplex == TLAN_DUPLEX_FULL) ||\n\t\t    (an_adv & an_lpa & 0x0040)) {\n\t\t\ttlan_mii_write_reg(dev, phy, MII_GEN_CTL,\n\t\t\t\t\t   MII_GC_AUTOENB | MII_GC_DUPLEX);\n\t\t\tnetdev_info(dev, \"Starting internal PHY with FULL-DUPLEX\\n\");\n\t\t} else {\n\t\t\ttlan_mii_write_reg(dev, phy, MII_GEN_CTL,\n\t\t\t\t\t   MII_GC_AUTOENB);\n\t\t\tnetdev_info(dev, \"Starting internal PHY with HALF-DUPLEX\\n\");\n\t\t}\n\t}\n\n\t \n\ttlan_set_timer(dev, msecs_to_jiffies(100), TLAN_TIMER_FINISH_RESET);\n\n}\n\n\n \n\nstatic void tlan_phy_monitor(struct timer_list *t)\n{\n\tstruct tlan_priv *priv = from_timer(priv, t, media_timer);\n\tstruct net_device *dev = priv->dev;\n\tu16     phy;\n\tu16     phy_status;\n\n\tphy = priv->phy[priv->phy_num];\n\n\t \n\ttlan_mii_read_reg(dev, phy, MII_GEN_STS, &phy_status);\n\n\t \n\tif (!(phy_status & MII_GS_LINK)) {\n\t\tif (netif_carrier_ok(dev)) {\n\t\t\tprintk(KERN_DEBUG \"TLAN: %s has lost link\\n\",\n\t\t\t       dev->name);\n\t\t\ttlan_dio_write8(dev->base_addr, TLAN_LED_REG, 0);\n\t\t\tnetif_carrier_off(dev);\n\t\t\tif (priv->adapter->flags & TLAN_ADAPTER_USE_INTERN_10) {\n\t\t\t\t \n\t\t\t\tu16 data = MII_GC_PDOWN | MII_GC_LOOPBK |\n\t\t\t\t\t   MII_GC_ISOLATE;\n\n\t\t\t\ttlan_mii_sync(dev->base_addr);\n\t\t\t\ttlan_mii_write_reg(dev, priv->phy[0],\n\t\t\t\t\t\t   MII_GEN_CTL, data);\n\t\t\t\t \n\t\t\t\tpriv->phy_num = 1;\n\t\t\t\t \n\t\t\t\ttlan_set_timer(dev, msecs_to_jiffies(400),\n\t\t\t\t\t       TLAN_TIMER_PHY_PDOWN);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((phy_status & MII_GS_LINK) && !netif_carrier_ok(dev)) {\n\t\ttlan_dio_write8(dev->base_addr, TLAN_LED_REG, TLAN_LED_LINK);\n\t\tprintk(KERN_DEBUG \"TLAN: %s has reestablished link\\n\",\n\t\t       dev->name);\n\t\tnetif_carrier_on(dev);\n\t}\n\tpriv->media_timer.expires = jiffies + HZ;\n\tadd_timer(&priv->media_timer);\n}\n\n\n \n\n\n \n\nstatic bool\n__tlan_mii_read_reg(struct net_device *dev, u16 phy, u16 reg, u16 *val)\n{\n\tu8\tnack;\n\tu16\tsio, tmp;\n\tu32\ti;\n\tbool\terr;\n\tint\tminten;\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\n\tlockdep_assert_held(&priv->lock);\n\n\terr = false;\n\toutw(TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR);\n\tsio = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;\n\n\ttlan_mii_sync(dev->base_addr);\n\n\tminten = tlan_get_bit(TLAN_NET_SIO_MINTEN, sio);\n\tif (minten)\n\t\ttlan_clear_bit(TLAN_NET_SIO_MINTEN, sio);\n\n\ttlan_mii_send_data(dev->base_addr, 0x1, 2);\t \n\ttlan_mii_send_data(dev->base_addr, 0x2, 2);\t \n\ttlan_mii_send_data(dev->base_addr, phy, 5);\t \n\ttlan_mii_send_data(dev->base_addr, reg, 5);\t \n\n\n\ttlan_clear_bit(TLAN_NET_SIO_MTXEN, sio);\t \n\n\ttlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\t\t \n\ttlan_set_bit(TLAN_NET_SIO_MCLK, sio);\n\ttlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\t\t \n\n\tnack = tlan_get_bit(TLAN_NET_SIO_MDATA, sio);\t \n\ttlan_set_bit(TLAN_NET_SIO_MCLK, sio);\t\t \n\tif (nack) {\t\t\t\t\t \n\t\tfor (i = 0; i < 16; i++) {\n\t\t\ttlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\n\t\t\ttlan_set_bit(TLAN_NET_SIO_MCLK, sio);\n\t\t}\n\t\ttmp = 0xffff;\n\t\terr = true;\n\t} else {\t\t\t\t\t \n\t\tfor (tmp = 0, i = 0x8000; i; i >>= 1) {\n\t\t\ttlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\n\t\t\tif (tlan_get_bit(TLAN_NET_SIO_MDATA, sio))\n\t\t\t\ttmp |= i;\n\t\t\ttlan_set_bit(TLAN_NET_SIO_MCLK, sio);\n\t\t}\n\t}\n\n\n\ttlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\t\t \n\ttlan_set_bit(TLAN_NET_SIO_MCLK, sio);\n\n\tif (minten)\n\t\ttlan_set_bit(TLAN_NET_SIO_MINTEN, sio);\n\n\t*val = tmp;\n\n\treturn err;\n}\n\nstatic void tlan_mii_read_reg(struct net_device *dev, u16 phy, u16 reg,\n\t\t\t      u16 *val)\n{\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t__tlan_mii_read_reg(dev, phy, reg, val);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\n \n\nstatic void tlan_mii_send_data(u16 base_port, u32 data, unsigned num_bits)\n{\n\tu16 sio;\n\tu32 i;\n\n\tif (num_bits == 0)\n\t\treturn;\n\n\toutw(TLAN_NET_SIO, base_port + TLAN_DIO_ADR);\n\tsio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;\n\ttlan_set_bit(TLAN_NET_SIO_MTXEN, sio);\n\n\tfor (i = (0x1 << (num_bits - 1)); i; i >>= 1) {\n\t\ttlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\n\t\t(void) tlan_get_bit(TLAN_NET_SIO_MCLK, sio);\n\t\tif (data & i)\n\t\t\ttlan_set_bit(TLAN_NET_SIO_MDATA, sio);\n\t\telse\n\t\t\ttlan_clear_bit(TLAN_NET_SIO_MDATA, sio);\n\t\ttlan_set_bit(TLAN_NET_SIO_MCLK, sio);\n\t\t(void) tlan_get_bit(TLAN_NET_SIO_MCLK, sio);\n\t}\n\n}\n\n\n\n\n \n\nstatic void tlan_mii_sync(u16 base_port)\n{\n\tint i;\n\tu16 sio;\n\n\toutw(TLAN_NET_SIO, base_port + TLAN_DIO_ADR);\n\tsio = base_port + TLAN_DIO_DATA + TLAN_NET_SIO;\n\n\ttlan_clear_bit(TLAN_NET_SIO_MTXEN, sio);\n\tfor (i = 0; i < 32; i++) {\n\t\ttlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\n\t\ttlan_set_bit(TLAN_NET_SIO_MCLK, sio);\n\t}\n\n}\n\n\n\n\n \n\nstatic void\n__tlan_mii_write_reg(struct net_device *dev, u16 phy, u16 reg, u16 val)\n{\n\tu16\tsio;\n\tint\tminten;\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\n\tlockdep_assert_held(&priv->lock);\n\n\toutw(TLAN_NET_SIO, dev->base_addr + TLAN_DIO_ADR);\n\tsio = dev->base_addr + TLAN_DIO_DATA + TLAN_NET_SIO;\n\n\ttlan_mii_sync(dev->base_addr);\n\n\tminten = tlan_get_bit(TLAN_NET_SIO_MINTEN, sio);\n\tif (minten)\n\t\ttlan_clear_bit(TLAN_NET_SIO_MINTEN, sio);\n\n\ttlan_mii_send_data(dev->base_addr, 0x1, 2);\t \n\ttlan_mii_send_data(dev->base_addr, 0x1, 2);\t \n\ttlan_mii_send_data(dev->base_addr, phy, 5);\t \n\ttlan_mii_send_data(dev->base_addr, reg, 5);\t \n\n\ttlan_mii_send_data(dev->base_addr, 0x2, 2);\t \n\ttlan_mii_send_data(dev->base_addr, val, 16);\t \n\n\ttlan_clear_bit(TLAN_NET_SIO_MCLK, sio);\t \n\ttlan_set_bit(TLAN_NET_SIO_MCLK, sio);\n\n\tif (minten)\n\t\ttlan_set_bit(TLAN_NET_SIO_MINTEN, sio);\n\n}\n\nstatic void\ntlan_mii_write_reg(struct net_device *dev, u16 phy, u16 reg, u16 val)\n{\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t__tlan_mii_write_reg(dev, phy, reg, val);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\n\n \n\n\n \n\nstatic void tlan_ee_send_start(u16 io_base)\n{\n\tu16\tsio;\n\n\toutw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);\n\tsio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;\n\n\ttlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\n\ttlan_set_bit(TLAN_NET_SIO_EDATA, sio);\n\ttlan_set_bit(TLAN_NET_SIO_ETXEN, sio);\n\ttlan_clear_bit(TLAN_NET_SIO_EDATA, sio);\n\ttlan_clear_bit(TLAN_NET_SIO_ECLOK, sio);\n\n}\n\n\n\n\n \n\nstatic int tlan_ee_send_byte(u16 io_base, u8 data, int stop)\n{\n\tint\terr;\n\tu8\tplace;\n\tu16\tsio;\n\n\toutw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);\n\tsio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;\n\n\t \n\tfor (place = 0x80; place != 0; place >>= 1) {\n\t\tif (place & data)\n\t\t\ttlan_set_bit(TLAN_NET_SIO_EDATA, sio);\n\t\telse\n\t\t\ttlan_clear_bit(TLAN_NET_SIO_EDATA, sio);\n\t\ttlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\n\t\ttlan_clear_bit(TLAN_NET_SIO_ECLOK, sio);\n\t}\n\ttlan_clear_bit(TLAN_NET_SIO_ETXEN, sio);\n\ttlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\n\terr = tlan_get_bit(TLAN_NET_SIO_EDATA, sio);\n\ttlan_clear_bit(TLAN_NET_SIO_ECLOK, sio);\n\ttlan_set_bit(TLAN_NET_SIO_ETXEN, sio);\n\n\tif ((!err) && stop) {\n\t\t \n\t\ttlan_clear_bit(TLAN_NET_SIO_EDATA, sio);\n\t\ttlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\n\t\ttlan_set_bit(TLAN_NET_SIO_EDATA, sio);\n\t}\n\n\treturn err;\n\n}\n\n\n\n\n \n\nstatic void tlan_ee_receive_byte(u16 io_base, u8 *data, int stop)\n{\n\tu8  place;\n\tu16 sio;\n\n\toutw(TLAN_NET_SIO, io_base + TLAN_DIO_ADR);\n\tsio = io_base + TLAN_DIO_DATA + TLAN_NET_SIO;\n\t*data = 0;\n\n\t \n\ttlan_clear_bit(TLAN_NET_SIO_ETXEN, sio);\n\tfor (place = 0x80; place; place >>= 1) {\n\t\ttlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\n\t\tif (tlan_get_bit(TLAN_NET_SIO_EDATA, sio))\n\t\t\t*data |= place;\n\t\ttlan_clear_bit(TLAN_NET_SIO_ECLOK, sio);\n\t}\n\n\ttlan_set_bit(TLAN_NET_SIO_ETXEN, sio);\n\tif (!stop) {\n\t\ttlan_clear_bit(TLAN_NET_SIO_EDATA, sio);  \n\t\ttlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\n\t\ttlan_clear_bit(TLAN_NET_SIO_ECLOK, sio);\n\t} else {\n\t\ttlan_set_bit(TLAN_NET_SIO_EDATA, sio);\t \n\t\ttlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\n\t\ttlan_clear_bit(TLAN_NET_SIO_ECLOK, sio);\n\t\t \n\t\ttlan_clear_bit(TLAN_NET_SIO_EDATA, sio);\n\t\ttlan_set_bit(TLAN_NET_SIO_ECLOK, sio);\n\t\ttlan_set_bit(TLAN_NET_SIO_EDATA, sio);\n\t}\n\n}\n\n\n\n\n \n\nstatic int tlan_ee_read_byte(struct net_device *dev, u8 ee_addr, u8 *data)\n{\n\tint err;\n\tstruct tlan_priv *priv = netdev_priv(dev);\n\tunsigned long flags = 0;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\ttlan_ee_send_start(dev->base_addr);\n\terr = tlan_ee_send_byte(dev->base_addr, 0xa0, TLAN_EEPROM_ACK);\n\tif (err) {\n\t\tret = 1;\n\t\tgoto fail;\n\t}\n\terr = tlan_ee_send_byte(dev->base_addr, ee_addr, TLAN_EEPROM_ACK);\n\tif (err) {\n\t\tret = 2;\n\t\tgoto fail;\n\t}\n\ttlan_ee_send_start(dev->base_addr);\n\terr = tlan_ee_send_byte(dev->base_addr, 0xa1, TLAN_EEPROM_ACK);\n\tif (err) {\n\t\tret = 3;\n\t\tgoto fail;\n\t}\n\ttlan_ee_receive_byte(dev->base_addr, data, TLAN_EEPROM_STOP);\nfail:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn ret;\n\n}\n\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}