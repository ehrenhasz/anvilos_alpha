{
  "module_name": "netcp.h",
  "hash_id": "a928fd9653b82989e5f11be93e148cad852281ad91aa4a356c9c027f7a4d324b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/netcp.h",
  "human_readable_source": " \n \n#ifndef __NETCP_H__\n#define __NETCP_H__\n\n#include <linux/netdevice.h>\n#include <linux/soc/ti/knav_dma.h>\n#include <linux/u64_stats_sync.h>\n\n \n#define NETCP_MAX_FRAME_SIZE\t\t9504\n\n#define SGMII_LINK_MAC_MAC_AUTONEG\t0\n#define SGMII_LINK_MAC_PHY\t\t1\n#define SGMII_LINK_MAC_MAC_FORCED\t2\n#define SGMII_LINK_MAC_FIBER\t\t3\n#define SGMII_LINK_MAC_PHY_NO_MDIO\t4\n#define RGMII_LINK_MAC_PHY\t\t5\n#define RGMII_LINK_MAC_PHY_NO_MDIO\t7\n#define XGMII_LINK_MAC_PHY\t\t10\n#define XGMII_LINK_MAC_MAC_FORCED\t11\n\nstruct netcp_device;\n\nstruct netcp_tx_pipe {\n\tstruct netcp_device\t*netcp_device;\n\tvoid\t\t\t*dma_queue;\n\tunsigned int\t\tdma_queue_id;\n\t \n\tu8\t\t\tswitch_to_port;\n#define\tSWITCH_TO_PORT_IN_TAGINFO\tBIT(0)\n\tu8\t\t\tflags;\n\tvoid\t\t\t*dma_channel;\n\tconst char\t\t*dma_chan_name;\n};\n\n#define ADDR_NEW\t\t\tBIT(0)\n#define ADDR_VALID\t\t\tBIT(1)\n\nenum netcp_addr_type {\n\tADDR_ANY,\n\tADDR_DEV,\n\tADDR_UCAST,\n\tADDR_MCAST,\n\tADDR_BCAST\n};\n\nstruct netcp_addr {\n\tstruct netcp_intf\t*netcp;\n\tunsigned char\t\taddr[ETH_ALEN];\n\tenum netcp_addr_type\ttype;\n\tunsigned int\t\tflags;\n\tstruct list_head\tnode;\n};\n\nstruct netcp_stats {\n\tstruct u64_stats_sync   syncp_rx ____cacheline_aligned_in_smp;\n\tu64                     rx_packets;\n\tu64                     rx_bytes;\n\tu32                     rx_errors;\n\tu32                     rx_dropped;\n\n\tstruct u64_stats_sync   syncp_tx ____cacheline_aligned_in_smp;\n\tu64                     tx_packets;\n\tu64                     tx_bytes;\n\tu32                     tx_errors;\n\tu32                     tx_dropped;\n};\n\nstruct netcp_intf {\n\tstruct device\t\t*dev;\n\tstruct device\t\t*ndev_dev;\n\tstruct net_device\t*ndev;\n\tbool\t\t\tbig_endian;\n\tunsigned int\t\ttx_compl_qid;\n\tvoid\t\t\t*tx_pool;\n\tstruct list_head\ttxhook_list_head;\n\tunsigned int\t\ttx_pause_threshold;\n\tvoid\t\t\t*tx_compl_q;\n\n\tunsigned int\t\ttx_resume_threshold;\n\tvoid\t\t\t*rx_queue;\n\tvoid\t\t\t*rx_pool;\n\tstruct list_head\trxhook_list_head;\n\tunsigned int\t\trx_queue_id;\n\tvoid\t\t\t*rx_fdq[KNAV_DMA_FDQ_PER_CHAN];\n\tstruct napi_struct\trx_napi;\n\tstruct napi_struct\ttx_napi;\n#define ETH_SW_CAN_REMOVE_ETH_FCS\tBIT(0)\n\tu32\t\t\thw_cap;\n\n\t \n\tstruct netcp_stats\tstats;\n\n\tvoid\t\t\t*rx_channel;\n\tconst char\t\t*dma_chan_name;\n\tu32\t\t\trx_pool_size;\n\tu32\t\t\trx_pool_region_id;\n\tu32\t\t\ttx_pool_size;\n\tu32\t\t\ttx_pool_region_id;\n\tstruct list_head\tmodule_head;\n\tstruct list_head\tinterface_list;\n\tstruct list_head\taddr_list;\n\tbool\t\t\tnetdev_registered;\n\tbool\t\t\tprimary_module_attached;\n\n\t \n\tspinlock_t\t\tlock;\n\tstruct netcp_device\t*netcp_device;\n\tstruct device_node\t*node_interface;\n\n\t \n\tu32\t\t\tmsg_enable;\n\tu32\t\t\trx_queue_depths[KNAV_DMA_FDQ_PER_CHAN];\n};\n\n#define\tNETCP_PSDATA_LEN\t\tKNAV_DMA_NUM_PS_WORDS\nstruct netcp_packet {\n\tstruct sk_buff\t\t*skb;\n\t__le32\t\t\t*epib;\n\tu32\t\t\t*psdata;\n\tu32\t\t\teflags;\n\tunsigned int\t\tpsdata_len;\n\tstruct netcp_intf\t*netcp;\n\tstruct netcp_tx_pipe\t*tx_pipe;\n\tbool\t\t\trxtstamp_complete;\n\tvoid\t\t\t*ts_context;\n\n\tvoid (*txtstamp)(void *ctx, struct sk_buff *skb);\n};\n\nstatic inline u32 *netcp_push_psdata(struct netcp_packet *p_info,\n\t\t\t\t     unsigned int bytes)\n{\n\tu32 *buf;\n\tunsigned int words;\n\n\tif ((bytes & 0x03) != 0)\n\t\treturn NULL;\n\twords = bytes >> 2;\n\n\tif ((p_info->psdata_len + words) > NETCP_PSDATA_LEN)\n\t\treturn NULL;\n\n\tp_info->psdata_len += words;\n\tbuf = &p_info->psdata[NETCP_PSDATA_LEN - p_info->psdata_len];\n\treturn buf;\n}\n\nstatic inline int netcp_align_psdata(struct netcp_packet *p_info,\n\t\t\t\t     unsigned int byte_align)\n{\n\tint padding;\n\n\tswitch (byte_align) {\n\tcase 0:\n\t\tpadding = -EINVAL;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tpadding = 0;\n\t\tbreak;\n\tcase 8:\n\t\tpadding = (p_info->psdata_len << 2) % 8;\n\t\tbreak;\n\tcase 16:\n\t\tpadding = (p_info->psdata_len << 2) % 16;\n\t\tbreak;\n\tdefault:\n\t\tpadding = (p_info->psdata_len << 2) % byte_align;\n\t\tbreak;\n\t}\n\treturn padding;\n}\n\nstruct netcp_module {\n\tconst char\t\t*name;\n\tstruct module\t\t*owner;\n\tbool\t\t\tprimary;\n\n\t \n\tint\t(*probe)(struct netcp_device *netcp_device,\n\t\t\t struct device *device, struct device_node *node,\n\t\t\t void **inst_priv);\n\tint\t(*remove)(struct netcp_device *netcp_device, void *inst_priv);\n\n\t \n\tint\t(*attach)(void *inst_priv, struct net_device *ndev,\n\t\t\t  struct device_node *node, void **intf_priv);\n\tint\t(*release)(void *intf_priv);\n\tint\t(*open)(void *intf_priv, struct net_device *ndev);\n\tint\t(*close)(void *intf_priv, struct net_device *ndev);\n\tint\t(*add_addr)(void *intf_priv, struct netcp_addr *naddr);\n\tint\t(*del_addr)(void *intf_priv, struct netcp_addr *naddr);\n\tint\t(*add_vid)(void *intf_priv, int vid);\n\tint\t(*del_vid)(void *intf_priv, int vid);\n\tint\t(*ioctl)(void *intf_priv, struct ifreq *req, int cmd);\n\tint\t(*set_rx_mode)(void *intf_priv, bool promisc);\n\n\t \n\tstruct list_head\tmodule_list;\n\tstruct list_head\tinterface_list;\n};\n\nint netcp_register_module(struct netcp_module *module);\nvoid netcp_unregister_module(struct netcp_module *module);\nvoid *netcp_module_get_intf_data(struct netcp_module *module,\n\t\t\t\t struct netcp_intf *intf);\n\nint netcp_txpipe_init(struct netcp_tx_pipe *tx_pipe,\n\t\t      struct netcp_device *netcp_device,\n\t\t      const char *dma_chan_name, unsigned int dma_queue_id);\nint netcp_txpipe_open(struct netcp_tx_pipe *tx_pipe);\nint netcp_txpipe_close(struct netcp_tx_pipe *tx_pipe);\n\ntypedef int netcp_hook_rtn(int order, void *data, struct netcp_packet *packet);\nint netcp_register_txhook(struct netcp_intf *netcp_priv, int order,\n\t\t\t  netcp_hook_rtn *hook_rtn, void *hook_data);\nint netcp_unregister_txhook(struct netcp_intf *netcp_priv, int order,\n\t\t\t    netcp_hook_rtn *hook_rtn, void *hook_data);\nint netcp_register_rxhook(struct netcp_intf *netcp_priv, int order,\n\t\t\t  netcp_hook_rtn *hook_rtn, void *hook_data);\nint netcp_unregister_rxhook(struct netcp_intf *netcp_priv, int order,\n\t\t\t    netcp_hook_rtn *hook_rtn, void *hook_data);\n\n \nint netcp_sgmii_reset(void __iomem *sgmii_ofs, int port);\nbool netcp_sgmii_rtreset(void __iomem *sgmii_ofs, int port, bool set);\nint netcp_sgmii_get_port_link(void __iomem *sgmii_ofs, int port);\nint netcp_sgmii_config(void __iomem *sgmii_ofs, int port, u32 interface);\n\n \nint netcp_xgbe_serdes_init(void __iomem *serdes_regs, void __iomem *xgbe_regs);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}