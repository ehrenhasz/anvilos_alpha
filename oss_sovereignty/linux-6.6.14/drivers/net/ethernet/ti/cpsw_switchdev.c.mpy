{
  "module_name": "cpsw_switchdev.c",
  "hash_id": "6ef541ba759e1d2a7e44fedc7a63c2d128195c2a64709e2f42de8cc1bc46f497",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/cpsw_switchdev.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/netdevice.h>\n#include <linux/workqueue.h>\n#include <net/switchdev.h>\n\n#include \"cpsw.h\"\n#include \"cpsw_ale.h\"\n#include \"cpsw_priv.h\"\n#include \"cpsw_switchdev.h\"\n\nstruct cpsw_switchdev_event_work {\n\tstruct work_struct work;\n\tstruct switchdev_notifier_fdb_info fdb_info;\n\tstruct cpsw_priv *priv;\n\tunsigned long event;\n};\n\nstatic int cpsw_port_stp_state_set(struct cpsw_priv *priv, u8 state)\n{\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tu8 cpsw_state;\n\tint ret = 0;\n\n\tswitch (state) {\n\tcase BR_STATE_FORWARDING:\n\t\tcpsw_state = ALE_PORT_STATE_FORWARD;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\tcpsw_state = ALE_PORT_STATE_LEARN;\n\t\tbreak;\n\tcase BR_STATE_DISABLED:\n\t\tcpsw_state = ALE_PORT_STATE_DISABLE;\n\t\tbreak;\n\tcase BR_STATE_LISTENING:\n\tcase BR_STATE_BLOCKING:\n\t\tcpsw_state = ALE_PORT_STATE_BLOCK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = cpsw_ale_control_set(cpsw->ale, priv->emac_port,\n\t\t\t\t   ALE_PORT_STATE, cpsw_state);\n\tdev_dbg(priv->dev, \"ale state: %u\\n\", cpsw_state);\n\n\treturn ret;\n}\n\nstatic int cpsw_port_attr_br_flags_set(struct cpsw_priv *priv,\n\t\t\t\t       struct net_device *orig_dev,\n\t\t\t\t       struct switchdev_brport_flags flags)\n{\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\n\tif (flags.mask & BR_MCAST_FLOOD) {\n\t\tbool unreg_mcast_add = false;\n\n\t\tif (flags.val & BR_MCAST_FLOOD)\n\t\t\tunreg_mcast_add = true;\n\n\t\tdev_dbg(priv->dev, \"BR_MCAST_FLOOD: %d port %u\\n\",\n\t\t\tunreg_mcast_add, priv->emac_port);\n\n\t\tcpsw_ale_set_unreg_mcast(cpsw->ale, BIT(priv->emac_port),\n\t\t\t\t\t unreg_mcast_add);\n\t}\n\n\treturn 0;\n}\n\nstatic int cpsw_port_attr_br_flags_pre_set(struct net_device *netdev,\n\t\t\t\t\t   struct switchdev_brport_flags flags)\n{\n\tif (flags.mask & ~(BR_LEARNING | BR_MCAST_FLOOD))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cpsw_port_attr_set(struct net_device *ndev, const void *ctx,\n\t\t\t      const struct switchdev_attr *attr,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\tdev_dbg(priv->dev, \"attr: id %u port: %u\\n\", attr->id, priv->emac_port);\n\n\tswitch (attr->id) {\n\tcase SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS:\n\t\tret = cpsw_port_attr_br_flags_pre_set(ndev,\n\t\t\t\t\t\t      attr->u.brport_flags);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_STP_STATE:\n\t\tret = cpsw_port_stp_state_set(priv, attr->u.stp_state);\n\t\tdev_dbg(priv->dev, \"stp state: %u\\n\", attr->u.stp_state);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:\n\t\tret = cpsw_port_attr_br_flags_set(priv, attr->orig_dev,\n\t\t\t\t\t\t  attr->u.brport_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic u16 cpsw_get_pvid(struct cpsw_priv *priv)\n{\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tu32 __iomem *port_vlan_reg;\n\tu32 pvid;\n\n\tif (priv->emac_port) {\n\t\tint reg = CPSW2_PORT_VLAN;\n\n\t\tif (cpsw->version == CPSW_VERSION_1)\n\t\t\treg = CPSW1_PORT_VLAN;\n\t\tpvid = slave_read(cpsw->slaves + (priv->emac_port - 1), reg);\n\t} else {\n\t\tport_vlan_reg = &cpsw->host_port_regs->port_vlan;\n\t\tpvid = readl(port_vlan_reg);\n\t}\n\n\tpvid = pvid & 0xfff;\n\n\treturn pvid;\n}\n\nstatic void cpsw_set_pvid(struct cpsw_priv *priv, u16 vid, bool cfi, u32 cos)\n{\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tvoid __iomem *port_vlan_reg;\n\tu32 pvid;\n\n\tpvid = vid;\n\tpvid |= cfi ? BIT(12) : 0;\n\tpvid |= (cos & 0x7) << 13;\n\n\tif (priv->emac_port) {\n\t\tint reg = CPSW2_PORT_VLAN;\n\n\t\tif (cpsw->version == CPSW_VERSION_1)\n\t\t\treg = CPSW1_PORT_VLAN;\n\t\t \n\t\tslave_write(cpsw->slaves + (priv->emac_port - 1), pvid, reg);\n\t} else {\n\t\t \n\t\tport_vlan_reg = &cpsw->host_port_regs->port_vlan;\n\t\twritel(pvid, port_vlan_reg);\n\t}\n}\n\nstatic int cpsw_port_vlan_add(struct cpsw_priv *priv, bool untag, bool pvid,\n\t\t\t      u16 vid, struct net_device *orig_dev)\n{\n\tbool cpu_port = netif_is_bridge_master(orig_dev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint unreg_mcast_mask = 0;\n\tint reg_mcast_mask = 0;\n\tint untag_mask = 0;\n\tint port_mask;\n\tint ret = 0;\n\tu32 flags;\n\n\tif (cpu_port) {\n\t\tport_mask = BIT(HOST_PORT_NUM);\n\t\tflags = orig_dev->flags;\n\t\tunreg_mcast_mask = port_mask;\n\t} else {\n\t\tport_mask = BIT(priv->emac_port);\n\t\tflags = priv->ndev->flags;\n\t}\n\n\tif (flags & IFF_MULTICAST)\n\t\treg_mcast_mask = port_mask;\n\n\tif (untag)\n\t\tuntag_mask = port_mask;\n\n\tret = cpsw_ale_vlan_add_modify(cpsw->ale, vid, port_mask, untag_mask,\n\t\t\t\t       reg_mcast_mask, unreg_mcast_mask);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Unable to add vlan\\n\");\n\t\treturn ret;\n\t}\n\n\tif (cpu_port)\n\t\tcpsw_ale_add_ucast(cpsw->ale, priv->mac_addr,\n\t\t\t\t   HOST_PORT_NUM, ALE_VLAN, vid);\n\tif (!pvid)\n\t\treturn ret;\n\n\tcpsw_set_pvid(priv, vid, 0, 0);\n\n\tdev_dbg(priv->dev, \"VID add: %s: vid:%u ports:%X\\n\",\n\t\tpriv->ndev->name, vid, port_mask);\n\treturn ret;\n}\n\nstatic int cpsw_port_vlan_del(struct cpsw_priv *priv, u16 vid,\n\t\t\t      struct net_device *orig_dev)\n{\n\tbool cpu_port = netif_is_bridge_master(orig_dev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint port_mask;\n\tint ret = 0;\n\n\tif (cpu_port)\n\t\tport_mask = BIT(HOST_PORT_NUM);\n\telse\n\t\tport_mask = BIT(priv->emac_port);\n\n\tret = cpsw_ale_vlan_del_modify(cpsw->ale, vid, port_mask);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tif (cpu_port)\n\t\tcpsw_ale_del_ucast(cpsw->ale, priv->mac_addr,\n\t\t\t\t   HOST_PORT_NUM, ALE_VLAN, vid);\n\n\tif (vid == cpsw_get_pvid(priv))\n\t\tcpsw_set_pvid(priv, 0, 0, 0);\n\n\t \n\tcpsw_ale_del_mcast(cpsw->ale, priv->ndev->broadcast,\n\t\t\t   port_mask, ALE_VLAN, vid);\n\tdev_dbg(priv->dev, \"VID del: %s: vid:%u ports:%X\\n\",\n\t\tpriv->ndev->name, vid, port_mask);\n\n\treturn ret;\n}\n\nstatic int cpsw_port_vlans_add(struct cpsw_priv *priv,\n\t\t\t       const struct switchdev_obj_port_vlan *vlan)\n{\n\tbool untag = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tstruct net_device *orig_dev = vlan->obj.orig_dev;\n\tbool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\n\tdev_dbg(priv->dev, \"VID add: %s: vid:%u flags:%X\\n\",\n\t\tpriv->ndev->name, vlan->vid, vlan->flags);\n\n\treturn cpsw_port_vlan_add(priv, untag, pvid, vlan->vid, orig_dev);\n}\n\nstatic int cpsw_port_mdb_add(struct cpsw_priv *priv,\n\t\t\t     struct switchdev_obj_port_mdb *mdb)\n\n{\n\tstruct net_device *orig_dev = mdb->obj.orig_dev;\n\tbool cpu_port = netif_is_bridge_master(orig_dev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint port_mask;\n\tint err;\n\n\tif (cpu_port)\n\t\tport_mask = BIT(HOST_PORT_NUM);\n\telse\n\t\tport_mask = BIT(priv->emac_port);\n\n\terr = cpsw_ale_add_mcast(cpsw->ale, mdb->addr, port_mask,\n\t\t\t\t ALE_VLAN, mdb->vid, 0);\n\tdev_dbg(priv->dev, \"MDB add: %s: vid %u:%pM  ports: %X\\n\",\n\t\tpriv->ndev->name, mdb->vid, mdb->addr, port_mask);\n\n\treturn err;\n}\n\nstatic int cpsw_port_mdb_del(struct cpsw_priv *priv,\n\t\t\t     struct switchdev_obj_port_mdb *mdb)\n\n{\n\tstruct net_device *orig_dev = mdb->obj.orig_dev;\n\tbool cpu_port = netif_is_bridge_master(orig_dev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint del_mask;\n\tint err;\n\n\tif (cpu_port)\n\t\tdel_mask = BIT(HOST_PORT_NUM);\n\telse\n\t\tdel_mask = BIT(priv->emac_port);\n\n\terr = cpsw_ale_del_mcast(cpsw->ale, mdb->addr, del_mask,\n\t\t\t\t ALE_VLAN, mdb->vid);\n\tdev_dbg(priv->dev, \"MDB del: %s: vid %u:%pM  ports: %X\\n\",\n\t\tpriv->ndev->name, mdb->vid, mdb->addr, del_mask);\n\n\treturn err;\n}\n\nstatic int cpsw_port_obj_add(struct net_device *ndev, const void *ctx,\n\t\t\t     const struct switchdev_obj *obj,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_obj_port_vlan *vlan = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\tstruct switchdev_obj_port_mdb *mdb = SWITCHDEV_OBJ_PORT_MDB(obj);\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tint err = 0;\n\n\tdev_dbg(priv->dev, \"obj_add: id %u port: %u\\n\",\n\t\tobj->id, priv->emac_port);\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\terr = cpsw_port_vlans_add(priv, vlan);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\tcase SWITCHDEV_OBJ_ID_HOST_MDB:\n\t\terr = cpsw_port_mdb_add(priv, mdb);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int cpsw_port_obj_del(struct net_device *ndev, const void *ctx,\n\t\t\t     const struct switchdev_obj *obj)\n{\n\tstruct switchdev_obj_port_vlan *vlan = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\tstruct switchdev_obj_port_mdb *mdb = SWITCHDEV_OBJ_PORT_MDB(obj);\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tint err = 0;\n\n\tdev_dbg(priv->dev, \"obj_del: id %u port: %u\\n\",\n\t\tobj->id, priv->emac_port);\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\terr = cpsw_port_vlan_del(priv, vlan->vid, vlan->obj.orig_dev);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\tcase SWITCHDEV_OBJ_ID_HOST_MDB:\n\t\terr = cpsw_port_mdb_del(priv, mdb);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void cpsw_fdb_offload_notify(struct net_device *ndev,\n\t\t\t\t    struct switchdev_notifier_fdb_info *rcv)\n{\n\tstruct switchdev_notifier_fdb_info info = {};\n\n\tinfo.addr = rcv->addr;\n\tinfo.vid = rcv->vid;\n\tinfo.offloaded = true;\n\tcall_switchdev_notifiers(SWITCHDEV_FDB_OFFLOADED,\n\t\t\t\t ndev, &info.info, NULL);\n}\n\nstatic void cpsw_switchdev_event_work(struct work_struct *work)\n{\n\tstruct cpsw_switchdev_event_work *switchdev_work =\n\t\tcontainer_of(work, struct cpsw_switchdev_event_work, work);\n\tstruct cpsw_priv *priv = switchdev_work->priv;\n\tstruct switchdev_notifier_fdb_info *fdb;\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint port = priv->emac_port;\n\n\trtnl_lock();\n\tswitch (switchdev_work->event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\tfdb = &switchdev_work->fdb_info;\n\n\t\tdev_dbg(cpsw->dev, \"cpsw_fdb_add: MACID = %pM vid = %u flags = %u %u -- port %d\\n\",\n\t\t\tfdb->addr, fdb->vid, fdb->added_by_user,\n\t\t\tfdb->offloaded, port);\n\n\t\tif (!fdb->added_by_user || fdb->is_local)\n\t\t\tbreak;\n\t\tif (memcmp(priv->mac_addr, (u8 *)fdb->addr, ETH_ALEN) == 0)\n\t\t\tport = HOST_PORT_NUM;\n\n\t\tcpsw_ale_add_ucast(cpsw->ale, (u8 *)fdb->addr, port,\n\t\t\t\t   fdb->vid ? ALE_VLAN : 0, fdb->vid);\n\t\tcpsw_fdb_offload_notify(priv->ndev, fdb);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tfdb = &switchdev_work->fdb_info;\n\n\t\tdev_dbg(cpsw->dev, \"cpsw_fdb_del: MACID = %pM vid = %u flags = %u %u -- port %d\\n\",\n\t\t\tfdb->addr, fdb->vid, fdb->added_by_user,\n\t\t\tfdb->offloaded, port);\n\n\t\tif (!fdb->added_by_user || fdb->is_local)\n\t\t\tbreak;\n\t\tif (memcmp(priv->mac_addr, (u8 *)fdb->addr, ETH_ALEN) == 0)\n\t\t\tport = HOST_PORT_NUM;\n\n\t\tcpsw_ale_del_ucast(cpsw->ale, (u8 *)fdb->addr, port,\n\t\t\t\t   fdb->vid ? ALE_VLAN : 0, fdb->vid);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\trtnl_unlock();\n\n\tkfree(switchdev_work->fdb_info.addr);\n\tkfree(switchdev_work);\n\tdev_put(priv->ndev);\n}\n\n \nstatic int cpsw_switchdev_event(struct notifier_block *unused,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *ndev = switchdev_notifier_info_to_dev(ptr);\n\tstruct switchdev_notifier_fdb_info *fdb_info = ptr;\n\tstruct cpsw_switchdev_event_work *switchdev_work;\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tint err;\n\n\tif (event == SWITCHDEV_PORT_ATTR_SET) {\n\t\terr = switchdev_handle_port_attr_set(ndev, ptr,\n\t\t\t\t\t\t     cpsw_port_dev_check,\n\t\t\t\t\t\t     cpsw_port_attr_set);\n\t\treturn notifier_from_errno(err);\n\t}\n\n\tif (!cpsw_port_dev_check(ndev))\n\t\treturn NOTIFY_DONE;\n\n\tswitchdev_work = kzalloc(sizeof(*switchdev_work), GFP_ATOMIC);\n\tif (WARN_ON(!switchdev_work))\n\t\treturn NOTIFY_BAD;\n\n\tINIT_WORK(&switchdev_work->work, cpsw_switchdev_event_work);\n\tswitchdev_work->priv = priv;\n\tswitchdev_work->event = event;\n\n\tswitch (event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tmemcpy(&switchdev_work->fdb_info, ptr,\n\t\t       sizeof(switchdev_work->fdb_info));\n\t\tswitchdev_work->fdb_info.addr = kzalloc(ETH_ALEN, GFP_ATOMIC);\n\t\tif (!switchdev_work->fdb_info.addr)\n\t\t\tgoto err_addr_alloc;\n\t\tether_addr_copy((u8 *)switchdev_work->fdb_info.addr,\n\t\t\t\tfdb_info->addr);\n\t\tdev_hold(ndev);\n\t\tbreak;\n\tdefault:\n\t\tkfree(switchdev_work);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tqueue_work(system_long_wq, &switchdev_work->work);\n\n\treturn NOTIFY_DONE;\n\nerr_addr_alloc:\n\tkfree(switchdev_work);\n\treturn NOTIFY_BAD;\n}\n\nstatic struct notifier_block cpsw_switchdev_notifier = {\n\t.notifier_call = cpsw_switchdev_event,\n};\n\nstatic int cpsw_switchdev_blocking_event(struct notifier_block *unused,\n\t\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tint err;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_OBJ_ADD:\n\t\terr = switchdev_handle_port_obj_add(dev, ptr,\n\t\t\t\t\t\t    cpsw_port_dev_check,\n\t\t\t\t\t\t    cpsw_port_obj_add);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_PORT_OBJ_DEL:\n\t\terr = switchdev_handle_port_obj_del(dev, ptr,\n\t\t\t\t\t\t    cpsw_port_dev_check,\n\t\t\t\t\t\t    cpsw_port_obj_del);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     cpsw_port_dev_check,\n\t\t\t\t\t\t     cpsw_port_attr_set);\n\t\treturn notifier_from_errno(err);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block cpsw_switchdev_bl_notifier = {\n\t.notifier_call = cpsw_switchdev_blocking_event,\n};\n\nint cpsw_switchdev_register_notifiers(struct cpsw_common *cpsw)\n{\n\tint ret = 0;\n\n\tret = register_switchdev_notifier(&cpsw_switchdev_notifier);\n\tif (ret) {\n\t\tdev_err(cpsw->dev, \"register switchdev notifier fail ret:%d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = register_switchdev_blocking_notifier(&cpsw_switchdev_bl_notifier);\n\tif (ret) {\n\t\tdev_err(cpsw->dev, \"register switchdev blocking notifier ret:%d\\n\",\n\t\t\tret);\n\t\tunregister_switchdev_notifier(&cpsw_switchdev_notifier);\n\t}\n\n\treturn ret;\n}\n\nvoid cpsw_switchdev_unregister_notifiers(struct cpsw_common *cpsw)\n{\n\tunregister_switchdev_blocking_notifier(&cpsw_switchdev_bl_notifier);\n\tunregister_switchdev_notifier(&cpsw_switchdev_notifier);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}