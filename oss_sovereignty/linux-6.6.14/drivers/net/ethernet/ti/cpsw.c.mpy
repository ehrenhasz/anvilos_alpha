{
  "module_name": "cpsw.c",
  "hash_id": "361ad8c4e2cd8dbe2f69036261a7300d5fd6f8c44ea727de157fc4e41a23e478",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/cpsw.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/timer.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/irqreturn.h>\n#include <linux/interrupt.h>\n#include <linux/if_ether.h>\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/net_tstamp.h>\n#include <linux/phy.h>\n#include <linux/phy/phy.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_platform.h>\n#include <linux/if_vlan.h>\n#include <linux/kmemleak.h>\n#include <linux/sys_soc.h>\n#include <net/page_pool/helpers.h>\n#include <linux/bpf.h>\n#include <linux/bpf_trace.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <net/pkt_cls.h>\n\n#include \"cpsw.h\"\n#include \"cpsw_ale.h\"\n#include \"cpsw_priv.h\"\n#include \"cpsw_sl.h\"\n#include \"cpts.h\"\n#include \"davinci_cpdma.h\"\n\n#include <net/pkt_sched.h>\n\nstatic int debug_level;\nmodule_param(debug_level, int, 0);\nMODULE_PARM_DESC(debug_level, \"cpsw debug level (NETIF_MSG bits)\");\n\nstatic int ale_ageout = 10;\nmodule_param(ale_ageout, int, 0);\nMODULE_PARM_DESC(ale_ageout, \"cpsw ale ageout interval (seconds)\");\n\nstatic int rx_packet_max = CPSW_MAX_PACKET_SIZE;\nmodule_param(rx_packet_max, int, 0);\nMODULE_PARM_DESC(rx_packet_max, \"maximum receive packet size (bytes)\");\n\nstatic int descs_pool_size = CPSW_CPDMA_DESCS_POOL_SIZE_DEFAULT;\nmodule_param(descs_pool_size, int, 0444);\nMODULE_PARM_DESC(descs_pool_size, \"Number of CPDMA CPPI descriptors in pool\");\n\n#define for_each_slave(priv, func, arg...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct cpsw_slave *slave;\t\t\t\t\\\n\t\tstruct cpsw_common *cpsw = (priv)->cpsw;\t\t\\\n\t\tint n;\t\t\t\t\t\t\t\\\n\t\tif (cpsw->data.dual_emac)\t\t\t\t\\\n\t\t\t(func)((cpsw)->slaves + priv->emac_port, ##arg);\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tfor (n = cpsw->data.slaves,\t\t\t\\\n\t\t\t\t\tslave = cpsw->slaves;\t\t\\\n\t\t\t\t\tn; n--)\t\t\t\t\\\n\t\t\t\t(func)(slave++, ##arg);\t\t\t\\\n\t} while (0)\n\nstatic int cpsw_slave_index_priv(struct cpsw_common *cpsw,\n\t\t\t\t struct cpsw_priv *priv)\n{\n\treturn cpsw->data.dual_emac ? priv->emac_port : cpsw->data.active_slave;\n}\n\nstatic int cpsw_get_slave_port(u32 slave_num)\n{\n\treturn slave_num + 1;\n}\n\nstatic int cpsw_ndo_vlan_rx_add_vid(struct net_device *ndev,\n\t\t\t\t    __be16 proto, u16 vid);\n\nstatic void cpsw_set_promiscious(struct net_device *ndev, bool enable)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\tstruct cpsw_ale *ale = cpsw->ale;\n\tint i;\n\n\tif (cpsw->data.dual_emac) {\n\t\tbool flag = false;\n\n\t\t \n\t\tfor (i = 0; i < cpsw->data.slaves; i++)\n\t\t\tif (cpsw->slaves[i].ndev->flags & IFF_PROMISC)\n\t\t\t\tflag = true;\n\n\t\tif (!enable && flag) {\n\t\t\tenable = true;\n\t\t\tdev_err(&ndev->dev, \"promiscuity not disabled as the other interface is still in promiscuity mode\\n\");\n\t\t}\n\n\t\tif (enable) {\n\t\t\t \n\t\t\tcpsw_ale_control_set(ale, 0, ALE_BYPASS, 1);\n\n\t\t\tdev_dbg(&ndev->dev, \"promiscuity enabled\\n\");\n\t\t} else {\n\t\t\t \n\t\t\tcpsw_ale_control_set(ale, 0, ALE_BYPASS, 0);\n\t\t\tdev_dbg(&ndev->dev, \"promiscuity disabled\\n\");\n\t\t}\n\t} else {\n\t\tif (enable) {\n\t\t\tunsigned long timeout = jiffies + HZ;\n\n\t\t\t \n\t\t\tfor (i = 0; i <= cpsw->data.slaves; i++) {\n\t\t\t\tcpsw_ale_control_set(ale, i,\n\t\t\t\t\t\t     ALE_PORT_NOLEARN, 1);\n\t\t\t\tcpsw_ale_control_set(ale, i,\n\t\t\t\t\t\t     ALE_PORT_NO_SA_UPDATE, 1);\n\t\t\t}\n\n\t\t\t \n\t\t\tcpsw_ale_control_set(ale, 0, ALE_AGEOUT, 1);\n\t\t\tdo {\n\t\t\t\tcpu_relax();\n\t\t\t\tif (cpsw_ale_control_get(ale, 0, ALE_AGEOUT))\n\t\t\t\t\tbreak;\n\t\t\t} while (time_after(timeout, jiffies));\n\t\t\tcpsw_ale_control_set(ale, 0, ALE_AGEOUT, 1);\n\n\t\t\t \n\t\t\tcpsw_ale_flush_multicast(ale, ALE_ALL_PORTS, -1);\n\t\t\t__hw_addr_ref_unsync_dev(&ndev->mc, ndev, NULL);\n\n\t\t\t \n\t\t\tcpsw_ale_control_set(ale, 0, ALE_P0_UNI_FLOOD, 1);\n\t\t\tdev_dbg(&ndev->dev, \"promiscuity enabled\\n\");\n\t\t} else {\n\t\t\t \n\t\t\tcpsw_ale_control_set(ale, 0, ALE_P0_UNI_FLOOD, 0);\n\n\t\t\t \n\t\t\tfor (i = 0; i <= cpsw->data.slaves; i++) {\n\t\t\t\tcpsw_ale_control_set(ale, i,\n\t\t\t\t\t\t     ALE_PORT_NOLEARN, 0);\n\t\t\t\tcpsw_ale_control_set(ale, i,\n\t\t\t\t\t\t     ALE_PORT_NO_SA_UPDATE, 0);\n\t\t\t}\n\t\t\tdev_dbg(&ndev->dev, \"promiscuity disabled\\n\");\n\t\t}\n\t}\n}\n\n \nstatic int cpsw_set_mc(struct net_device *ndev, const u8 *addr,\n\t\t       int vid, int add)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint mask, flags, ret;\n\n\tif (vid < 0) {\n\t\tif (cpsw->data.dual_emac)\n\t\t\tvid = cpsw->slaves[priv->emac_port].port_vlan;\n\t\telse\n\t\t\tvid = 0;\n\t}\n\n\tmask = cpsw->data.dual_emac ? ALE_PORT_HOST : ALE_ALL_PORTS;\n\tflags = vid ? ALE_VLAN : 0;\n\n\tif (add)\n\t\tret = cpsw_ale_add_mcast(cpsw->ale, addr, mask, flags, vid, 0);\n\telse\n\t\tret = cpsw_ale_del_mcast(cpsw->ale, addr, 0, flags, vid);\n\n\treturn ret;\n}\n\nstatic int cpsw_update_vlan_mc(struct net_device *vdev, int vid, void *ctx)\n{\n\tstruct addr_sync_ctx *sync_ctx = ctx;\n\tstruct netdev_hw_addr *ha;\n\tint found = 0, ret = 0;\n\n\tif (!vdev || !(vdev->flags & IFF_UP))\n\t\treturn 0;\n\n\t \n\tnetdev_for_each_mc_addr(ha, vdev) {\n\t\tif (ether_addr_equal(ha->addr, sync_ctx->addr)) {\n\t\t\tfound = ha->sync_cnt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found)\n\t\tsync_ctx->consumed++;\n\n\tif (sync_ctx->flush) {\n\t\tif (!found)\n\t\t\tcpsw_set_mc(sync_ctx->ndev, sync_ctx->addr, vid, 0);\n\t\treturn 0;\n\t}\n\n\tif (found)\n\t\tret = cpsw_set_mc(sync_ctx->ndev, sync_ctx->addr, vid, 1);\n\n\treturn ret;\n}\n\nstatic int cpsw_add_mc_addr(struct net_device *ndev, const u8 *addr, int num)\n{\n\tstruct addr_sync_ctx sync_ctx;\n\tint ret;\n\n\tsync_ctx.consumed = 0;\n\tsync_ctx.addr = addr;\n\tsync_ctx.ndev = ndev;\n\tsync_ctx.flush = 0;\n\n\tret = vlan_for_each(ndev, cpsw_update_vlan_mc, &sync_ctx);\n\tif (sync_ctx.consumed < num && !ret)\n\t\tret = cpsw_set_mc(ndev, addr, -1, 1);\n\n\treturn ret;\n}\n\nstatic int cpsw_del_mc_addr(struct net_device *ndev, const u8 *addr, int num)\n{\n\tstruct addr_sync_ctx sync_ctx;\n\n\tsync_ctx.consumed = 0;\n\tsync_ctx.addr = addr;\n\tsync_ctx.ndev = ndev;\n\tsync_ctx.flush = 1;\n\n\tvlan_for_each(ndev, cpsw_update_vlan_mc, &sync_ctx);\n\tif (sync_ctx.consumed == num)\n\t\tcpsw_set_mc(ndev, addr, -1, 0);\n\n\treturn 0;\n}\n\nstatic int cpsw_purge_vlan_mc(struct net_device *vdev, int vid, void *ctx)\n{\n\tstruct addr_sync_ctx *sync_ctx = ctx;\n\tstruct netdev_hw_addr *ha;\n\tint found = 0;\n\n\tif (!vdev || !(vdev->flags & IFF_UP))\n\t\treturn 0;\n\n\t \n\tnetdev_for_each_mc_addr(ha, vdev) {\n\t\tif (ether_addr_equal(ha->addr, sync_ctx->addr)) {\n\t\t\tfound = ha->sync_cnt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn 0;\n\n\tsync_ctx->consumed++;\n\tcpsw_set_mc(sync_ctx->ndev, sync_ctx->addr, vid, 0);\n\treturn 0;\n}\n\nstatic int cpsw_purge_all_mc(struct net_device *ndev, const u8 *addr, int num)\n{\n\tstruct addr_sync_ctx sync_ctx;\n\n\tsync_ctx.addr = addr;\n\tsync_ctx.ndev = ndev;\n\tsync_ctx.consumed = 0;\n\n\tvlan_for_each(ndev, cpsw_purge_vlan_mc, &sync_ctx);\n\tif (sync_ctx.consumed < num)\n\t\tcpsw_set_mc(ndev, addr, -1, 0);\n\n\treturn 0;\n}\n\nstatic void cpsw_ndo_set_rx_mode(struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint slave_port = -1;\n\n\tif (cpsw->data.dual_emac)\n\t\tslave_port = priv->emac_port + 1;\n\n\tif (ndev->flags & IFF_PROMISC) {\n\t\t \n\t\tcpsw_set_promiscious(ndev, true);\n\t\tcpsw_ale_set_allmulti(cpsw->ale, IFF_ALLMULTI, slave_port);\n\t\treturn;\n\t} else {\n\t\t \n\t\tcpsw_set_promiscious(ndev, false);\n\t}\n\n\t \n\tcpsw_ale_set_allmulti(cpsw->ale,\n\t\t\t      ndev->flags & IFF_ALLMULTI, slave_port);\n\n\t \n\t__hw_addr_ref_sync_dev(&ndev->mc, ndev, cpsw_add_mc_addr,\n\t\t\t       cpsw_del_mc_addr);\n}\n\nstatic unsigned int cpsw_rxbuf_total_len(unsigned int len)\n{\n\tlen += CPSW_HEADROOM_NA;\n\tlen += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\n\treturn SKB_DATA_ALIGN(len);\n}\n\nstatic void cpsw_rx_handler(void *token, int len, int status)\n{\n\tstruct page\t\t*new_page, *page = token;\n\tvoid\t\t\t*pa = page_address(page);\n\tstruct cpsw_meta_xdp\t*xmeta = pa + CPSW_XMETA_OFFSET;\n\tstruct cpsw_common\t*cpsw = ndev_to_cpsw(xmeta->ndev);\n\tint\t\t\tpkt_size = cpsw->rx_packet_max;\n\tint\t\t\tret = 0, port, ch = xmeta->ch;\n\tint\t\t\theadroom = CPSW_HEADROOM_NA;\n\tstruct net_device\t*ndev = xmeta->ndev;\n\tstruct cpsw_priv\t*priv;\n\tstruct page_pool\t*pool;\n\tstruct sk_buff\t\t*skb;\n\tstruct xdp_buff\t\txdp;\n\tdma_addr_t\t\tdma;\n\n\tif (cpsw->data.dual_emac && status >= 0) {\n\t\tport = CPDMA_RX_SOURCE_PORT(status);\n\t\tif (port)\n\t\t\tndev = cpsw->slaves[--port].ndev;\n\t}\n\n\tpriv = netdev_priv(ndev);\n\tpool = cpsw->page_pool[ch];\n\tif (unlikely(status < 0) || unlikely(!netif_running(ndev))) {\n\t\t \n\t\tif (cpsw->data.dual_emac && cpsw->usage_count &&\n\t\t    (status >= 0)) {\n\t\t\t \n\t\t\tnew_page = page;\n\t\t\tgoto requeue;\n\t\t}\n\n\t\t \n\t\tpage_pool_recycle_direct(pool, page);\n\t\treturn;\n\t}\n\n\tnew_page = page_pool_dev_alloc_pages(pool);\n\tif (unlikely(!new_page)) {\n\t\tnew_page = page;\n\t\tndev->stats.rx_dropped++;\n\t\tgoto requeue;\n\t}\n\n\tif (priv->xdp_prog) {\n\t\tint size = len;\n\n\t\txdp_init_buff(&xdp, PAGE_SIZE, &priv->xdp_rxq[ch]);\n\t\tif (status & CPDMA_RX_VLAN_ENCAP) {\n\t\t\theadroom += CPSW_RX_VLAN_ENCAP_HDR_SIZE;\n\t\t\tsize -= CPSW_RX_VLAN_ENCAP_HDR_SIZE;\n\t\t}\n\n\t\txdp_prepare_buff(&xdp, pa, headroom, size, false);\n\n\t\tport = priv->emac_port + cpsw->data.dual_emac;\n\t\tret = cpsw_run_xdp(priv, ch, &xdp, page, port, &len);\n\t\tif (ret != CPSW_XDP_PASS)\n\t\t\tgoto requeue;\n\n\t\theadroom = xdp.data - xdp.data_hard_start;\n\n\t\t \n\t\tstatus &= ~CPDMA_RX_VLAN_ENCAP;\n\t}\n\n\t \n\tskb = build_skb(pa, cpsw_rxbuf_total_len(pkt_size));\n\tif (!skb) {\n\t\tndev->stats.rx_dropped++;\n\t\tpage_pool_recycle_direct(pool, page);\n\t\tgoto requeue;\n\t}\n\n\tskb_reserve(skb, headroom);\n\tskb_put(skb, len);\n\tskb->dev = ndev;\n\tif (status & CPDMA_RX_VLAN_ENCAP)\n\t\tcpsw_rx_vlan_encap(skb);\n\tif (priv->rx_ts_enabled)\n\t\tcpts_rx_timestamp(cpsw->cpts, skb);\n\tskb->protocol = eth_type_trans(skb, ndev);\n\n\t \n\tskb_mark_for_recycle(skb);\n\tnetif_receive_skb(skb);\n\n\tndev->stats.rx_bytes += len;\n\tndev->stats.rx_packets++;\n\nrequeue:\n\txmeta = page_address(new_page) + CPSW_XMETA_OFFSET;\n\txmeta->ndev = ndev;\n\txmeta->ch = ch;\n\n\tdma = page_pool_get_dma_addr(new_page) + CPSW_HEADROOM_NA;\n\tret = cpdma_chan_submit_mapped(cpsw->rxv[ch].ch, new_page, dma,\n\t\t\t\t       pkt_size, 0);\n\tif (ret < 0) {\n\t\tWARN_ON(ret == -ENOMEM);\n\t\tpage_pool_recycle_direct(pool, new_page);\n\t}\n}\n\nstatic void _cpsw_adjust_link(struct cpsw_slave *slave,\n\t\t\t      struct cpsw_priv *priv, bool *link)\n{\n\tstruct phy_device\t*phy = slave->phy;\n\tu32\t\t\tmac_control = 0;\n\tu32\t\t\tslave_port;\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\n\tif (!phy)\n\t\treturn;\n\n\tslave_port = cpsw_get_slave_port(slave->slave_num);\n\n\tif (phy->link) {\n\t\tmac_control = CPSW_SL_CTL_GMII_EN;\n\n\t\tif (phy->speed == 1000)\n\t\t\tmac_control |= CPSW_SL_CTL_GIG;\n\t\tif (phy->duplex)\n\t\t\tmac_control |= CPSW_SL_CTL_FULLDUPLEX;\n\n\t\t \n\t\tif (phy->speed == 100)\n\t\t\tmac_control |= CPSW_SL_CTL_IFCTL_A;\n\t\t \n\t\telse if ((phy->speed == 10) && phy_interface_is_rgmii(phy))\n\t\t\tmac_control |= CPSW_SL_CTL_EXT_EN;  \n\n\t\tif (priv->rx_pause)\n\t\t\tmac_control |= CPSW_SL_CTL_RX_FLOW_EN;\n\n\t\tif (priv->tx_pause)\n\t\t\tmac_control |= CPSW_SL_CTL_TX_FLOW_EN;\n\n\t\tif (mac_control != slave->mac_control)\n\t\t\tcpsw_sl_ctl_set(slave->mac_sl, mac_control);\n\n\t\t \n\t\tcpsw_ale_control_set(cpsw->ale, slave_port,\n\t\t\t\t     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);\n\n\t\t*link = true;\n\n\t\tif (priv->shp_cfg_speed &&\n\t\t    priv->shp_cfg_speed != slave->phy->speed &&\n\t\t    !cpsw_shp_is_off(priv))\n\t\t\tdev_warn(priv->dev,\n\t\t\t\t \"Speed was changed, CBS shaper speeds are changed!\");\n\t} else {\n\t\tmac_control = 0;\n\t\t \n\t\tcpsw_ale_control_set(cpsw->ale, slave_port,\n\t\t\t\t     ALE_PORT_STATE, ALE_PORT_STATE_DISABLE);\n\n\t\tcpsw_sl_wait_for_idle(slave->mac_sl, 100);\n\n\t\tcpsw_sl_ctl_reset(slave->mac_sl);\n\t}\n\n\tif (mac_control != slave->mac_control)\n\t\tphy_print_status(phy);\n\n\tslave->mac_control = mac_control;\n}\n\nstatic void cpsw_adjust_link(struct net_device *ndev)\n{\n\tstruct cpsw_priv\t*priv = netdev_priv(ndev);\n\tstruct cpsw_common\t*cpsw = priv->cpsw;\n\tbool\t\t\tlink = false;\n\n\tfor_each_slave(priv, _cpsw_adjust_link, priv, &link);\n\n\tif (link) {\n\t\tif (cpsw_need_resplit(cpsw))\n\t\t\tcpsw_split_res(cpsw);\n\n\t\tnetif_carrier_on(ndev);\n\t\tif (netif_running(ndev))\n\t\t\tnetif_tx_wake_all_queues(ndev);\n\t} else {\n\t\tnetif_carrier_off(ndev);\n\t\tnetif_tx_stop_all_queues(ndev);\n\t}\n}\n\nstatic inline void cpsw_add_dual_emac_def_ale_entries(\n\t\tstruct cpsw_priv *priv, struct cpsw_slave *slave,\n\t\tu32 slave_port)\n{\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tu32 port_mask = 1 << slave_port | ALE_PORT_HOST;\n\n\tif (cpsw->version == CPSW_VERSION_1)\n\t\tslave_write(slave, slave->port_vlan, CPSW1_PORT_VLAN);\n\telse\n\t\tslave_write(slave, slave->port_vlan, CPSW2_PORT_VLAN);\n\tcpsw_ale_add_vlan(cpsw->ale, slave->port_vlan, port_mask,\n\t\t\t  port_mask, port_mask, 0);\n\tcpsw_ale_add_mcast(cpsw->ale, priv->ndev->broadcast,\n\t\t\t   ALE_PORT_HOST, ALE_VLAN, slave->port_vlan, 0);\n\tcpsw_ale_add_ucast(cpsw->ale, priv->mac_addr,\n\t\t\t   HOST_PORT_NUM, ALE_VLAN |\n\t\t\t   ALE_SECURE, slave->port_vlan);\n\tcpsw_ale_control_set(cpsw->ale, slave_port,\n\t\t\t     ALE_PORT_DROP_UNKNOWN_VLAN, 1);\n}\n\nstatic void cpsw_slave_open(struct cpsw_slave *slave, struct cpsw_priv *priv)\n{\n\tu32 slave_port;\n\tstruct phy_device *phy;\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\n\tcpsw_sl_reset(slave->mac_sl, 100);\n\tcpsw_sl_ctl_reset(slave->mac_sl);\n\n\t \n\tcpsw_sl_reg_write(slave->mac_sl, CPSW_SL_RX_PRI_MAP,\n\t\t\t  RX_PRIORITY_MAPPING);\n\n\tswitch (cpsw->version) {\n\tcase CPSW_VERSION_1:\n\t\tslave_write(slave, TX_PRIORITY_MAPPING, CPSW1_TX_PRI_MAP);\n\t\t \n\t\tslave_write(slave,\n\t\t\t    (CPSW_MAX_BLKS_TX << CPSW_MAX_BLKS_TX_SHIFT) |\n\t\t\t    CPSW_MAX_BLKS_RX, CPSW1_MAX_BLKS);\n\t\tbreak;\n\tcase CPSW_VERSION_2:\n\tcase CPSW_VERSION_3:\n\tcase CPSW_VERSION_4:\n\t\tslave_write(slave, TX_PRIORITY_MAPPING, CPSW2_TX_PRI_MAP);\n\t\t \n\t\tslave_write(slave,\n\t\t\t    (CPSW_MAX_BLKS_TX << CPSW_MAX_BLKS_TX_SHIFT) |\n\t\t\t    CPSW_MAX_BLKS_RX, CPSW2_MAX_BLKS);\n\t\tbreak;\n\t}\n\n\t \n\tcpsw_sl_reg_write(slave->mac_sl, CPSW_SL_RX_MAXLEN,\n\t\t\t  cpsw->rx_packet_max);\n\tcpsw_set_slave_mac(slave, priv);\n\n\tslave->mac_control = 0;\t \n\n\tslave_port = cpsw_get_slave_port(slave->slave_num);\n\n\tif (cpsw->data.dual_emac)\n\t\tcpsw_add_dual_emac_def_ale_entries(priv, slave, slave_port);\n\telse\n\t\tcpsw_ale_add_mcast(cpsw->ale, priv->ndev->broadcast,\n\t\t\t\t   1 << slave_port, 0, 0, ALE_MCAST_FWD_2);\n\n\tif (slave->data->phy_node) {\n\t\tphy = of_phy_connect(priv->ndev, slave->data->phy_node,\n\t\t\t\t &cpsw_adjust_link, 0, slave->data->phy_if);\n\t\tif (!phy) {\n\t\t\tdev_err(priv->dev, \"phy \\\"%pOF\\\" not found on slave %d\\n\",\n\t\t\t\tslave->data->phy_node,\n\t\t\t\tslave->slave_num);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tphy = phy_connect(priv->ndev, slave->data->phy_id,\n\t\t\t\t &cpsw_adjust_link, slave->data->phy_if);\n\t\tif (IS_ERR(phy)) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"phy \\\"%s\\\" not found on slave %d, err %ld\\n\",\n\t\t\t\tslave->data->phy_id, slave->slave_num,\n\t\t\t\tPTR_ERR(phy));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tslave->phy = phy;\n\n\tphy_attached_info(slave->phy);\n\n\tphy_start(slave->phy);\n\n\t \n\tif (!IS_ERR(slave->data->ifphy))\n\t\tphy_set_mode_ext(slave->data->ifphy, PHY_MODE_ETHERNET,\n\t\t\t\t slave->data->phy_if);\n\telse\n\t\tcpsw_phy_sel(cpsw->dev, slave->phy->interface,\n\t\t\t     slave->slave_num);\n}\n\nstatic inline void cpsw_add_default_vlan(struct cpsw_priv *priv)\n{\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tconst int vlan = cpsw->data.default_vlan;\n\tu32 reg;\n\tint i;\n\tint unreg_mcast_mask;\n\n\treg = (cpsw->version == CPSW_VERSION_1) ? CPSW1_PORT_VLAN :\n\t       CPSW2_PORT_VLAN;\n\n\twritel(vlan, &cpsw->host_port_regs->port_vlan);\n\n\tfor (i = 0; i < cpsw->data.slaves; i++)\n\t\tslave_write(cpsw->slaves + i, vlan, reg);\n\n\tif (priv->ndev->flags & IFF_ALLMULTI)\n\t\tunreg_mcast_mask = ALE_ALL_PORTS;\n\telse\n\t\tunreg_mcast_mask = ALE_PORT_1 | ALE_PORT_2;\n\n\tcpsw_ale_add_vlan(cpsw->ale, vlan, ALE_ALL_PORTS,\n\t\t\t  ALE_ALL_PORTS, ALE_ALL_PORTS,\n\t\t\t  unreg_mcast_mask);\n}\n\nstatic void cpsw_init_host_port(struct cpsw_priv *priv)\n{\n\tu32 fifo_mode;\n\tu32 control_reg;\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\n\t \n\tsoft_reset(\"cpsw\", &cpsw->regs->soft_reset);\n\tcpsw_ale_start(cpsw->ale);\n\n\t \n\tcpsw_ale_control_set(cpsw->ale, HOST_PORT_NUM, ALE_VLAN_AWARE,\n\t\t\t     CPSW_ALE_VLAN_AWARE);\n\tcontrol_reg = readl(&cpsw->regs->control);\n\tcontrol_reg |= CPSW_VLAN_AWARE | CPSW_RX_VLAN_ENCAP;\n\twritel(control_reg, &cpsw->regs->control);\n\tfifo_mode = (cpsw->data.dual_emac) ? CPSW_FIFO_DUAL_MAC_MODE :\n\t\t     CPSW_FIFO_NORMAL_MODE;\n\twritel(fifo_mode, &cpsw->host_port_regs->tx_in_ctl);\n\n\t \n\twritel_relaxed(CPDMA_TX_PRIORITY_MAP,\n\t\t       &cpsw->host_port_regs->cpdma_tx_pri_map);\n\twritel_relaxed(0, &cpsw->host_port_regs->cpdma_rx_chan_map);\n\n\tcpsw_ale_control_set(cpsw->ale, HOST_PORT_NUM,\n\t\t\t     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);\n\n\tif (!cpsw->data.dual_emac) {\n\t\tcpsw_ale_add_ucast(cpsw->ale, priv->mac_addr, HOST_PORT_NUM,\n\t\t\t\t   0, 0);\n\t\tcpsw_ale_add_mcast(cpsw->ale, priv->ndev->broadcast,\n\t\t\t\t   ALE_PORT_HOST, 0, 0, ALE_MCAST_FWD_2);\n\t}\n}\n\nstatic void cpsw_slave_stop(struct cpsw_slave *slave, struct cpsw_common *cpsw)\n{\n\tu32 slave_port;\n\n\tslave_port = cpsw_get_slave_port(slave->slave_num);\n\n\tif (!slave->phy)\n\t\treturn;\n\tphy_stop(slave->phy);\n\tphy_disconnect(slave->phy);\n\tslave->phy = NULL;\n\tcpsw_ale_control_set(cpsw->ale, slave_port,\n\t\t\t     ALE_PORT_STATE, ALE_PORT_STATE_DISABLE);\n\tcpsw_sl_reset(slave->mac_sl, 100);\n\tcpsw_sl_ctl_reset(slave->mac_sl);\n}\n\nstatic int cpsw_restore_vlans(struct net_device *vdev, int vid, void *arg)\n{\n\tstruct cpsw_priv *priv = arg;\n\n\tif (!vdev)\n\t\treturn 0;\n\n\tcpsw_ndo_vlan_rx_add_vid(priv->ndev, 0, vid);\n\treturn 0;\n}\n\n \nstatic void cpsw_restore(struct cpsw_priv *priv)\n{\n\t \n\tvlan_for_each(priv->ndev, cpsw_restore_vlans, priv);\n\n\t \n\tfor_each_slave(priv, cpsw_mqprio_resume, priv);\n\n\t \n\tfor_each_slave(priv, cpsw_cbs_resume, priv);\n}\n\nstatic int cpsw_ndo_open(struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint ret;\n\tu32 reg;\n\n\tret = pm_runtime_resume_and_get(cpsw->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnetif_carrier_off(ndev);\n\n\t \n\tret = netif_set_real_num_tx_queues(ndev, cpsw->tx_ch_num);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"cannot set real number of tx queues\\n\");\n\t\tgoto err_cleanup;\n\t}\n\n\tret = netif_set_real_num_rx_queues(ndev, cpsw->rx_ch_num);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"cannot set real number of rx queues\\n\");\n\t\tgoto err_cleanup;\n\t}\n\n\treg = cpsw->version;\n\n\tdev_info(priv->dev, \"initializing cpsw version %d.%d (%d)\\n\",\n\t\t CPSW_MAJOR_VERSION(reg), CPSW_MINOR_VERSION(reg),\n\t\t CPSW_RTL_VERSION(reg));\n\n\t \n\tif (!cpsw->usage_count)\n\t\tcpsw_init_host_port(priv);\n\tfor_each_slave(priv, cpsw_slave_open, priv);\n\n\t \n\tif (!cpsw->data.dual_emac)\n\t\tcpsw_add_default_vlan(priv);\n\telse\n\t\tcpsw_ale_add_vlan(cpsw->ale, cpsw->data.default_vlan,\n\t\t\t\t  ALE_ALL_PORTS, ALE_ALL_PORTS, 0, 0);\n\n\t \n\tif (!cpsw->usage_count) {\n\t\t \n\t\twritel_relaxed(0, &cpsw->regs->ptype);\n\n\t\t \n\t\twritel_relaxed(0x7, &cpsw->regs->stat_port_en);\n\n\t\t \n\t\twritel(0x7, &cpsw->regs->flow_control);\n\n\t\tnapi_enable(&cpsw->napi_rx);\n\t\tnapi_enable(&cpsw->napi_tx);\n\n\t\tif (cpsw->tx_irq_disabled) {\n\t\t\tcpsw->tx_irq_disabled = false;\n\t\t\tenable_irq(cpsw->irqs_table[1]);\n\t\t}\n\n\t\tif (cpsw->rx_irq_disabled) {\n\t\t\tcpsw->rx_irq_disabled = false;\n\t\t\tenable_irq(cpsw->irqs_table[0]);\n\t\t}\n\n\t\t \n\t\tret = cpsw_create_xdp_rxqs(cpsw);\n\t\tif (ret < 0)\n\t\t\tgoto err_cleanup;\n\n\t\tret = cpsw_fill_rx_channels(priv);\n\t\tif (ret < 0)\n\t\t\tgoto err_cleanup;\n\n\t\tif (cpsw->cpts) {\n\t\t\tif (cpts_register(cpsw->cpts))\n\t\t\t\tdev_err(priv->dev, \"error registering cpts device\\n\");\n\t\t\telse\n\t\t\t\twritel(0x10, &cpsw->wr_regs->misc_en);\n\t\t}\n\t}\n\n\tcpsw_restore(priv);\n\n\t \n\tif (cpsw->coal_intvl != 0) {\n\t\tstruct ethtool_coalesce coal;\n\n\t\tcoal.rx_coalesce_usecs = cpsw->coal_intvl;\n\t\tcpsw_set_coalesce(ndev, &coal, NULL, NULL);\n\t}\n\n\tcpdma_ctlr_start(cpsw->dma);\n\tcpsw_intr_enable(cpsw);\n\tcpsw->usage_count++;\n\n\treturn 0;\n\nerr_cleanup:\n\tif (!cpsw->usage_count) {\n\t\tnapi_disable(&cpsw->napi_rx);\n\t\tnapi_disable(&cpsw->napi_tx);\n\t\tcpdma_ctlr_stop(cpsw->dma);\n\t\tcpsw_destroy_xdp_rxqs(cpsw);\n\t}\n\n\tfor_each_slave(priv, cpsw_slave_stop, cpsw);\n\tpm_runtime_put_sync(cpsw->dev);\n\tnetif_carrier_off(priv->ndev);\n\treturn ret;\n}\n\nstatic int cpsw_ndo_stop(struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\n\tcpsw_info(priv, ifdown, \"shutting down cpsw device\\n\");\n\t__hw_addr_ref_unsync_dev(&ndev->mc, ndev, cpsw_purge_all_mc);\n\tnetif_tx_stop_all_queues(priv->ndev);\n\tnetif_carrier_off(priv->ndev);\n\n\tif (cpsw->usage_count <= 1) {\n\t\tnapi_disable(&cpsw->napi_rx);\n\t\tnapi_disable(&cpsw->napi_tx);\n\t\tcpts_unregister(cpsw->cpts);\n\t\tcpsw_intr_disable(cpsw);\n\t\tcpdma_ctlr_stop(cpsw->dma);\n\t\tcpsw_ale_stop(cpsw->ale);\n\t\tcpsw_destroy_xdp_rxqs(cpsw);\n\t}\n\tfor_each_slave(priv, cpsw_slave_stop, cpsw);\n\n\tif (cpsw_need_resplit(cpsw))\n\t\tcpsw_split_res(cpsw);\n\n\tcpsw->usage_count--;\n\tpm_runtime_put_sync(cpsw->dev);\n\treturn 0;\n}\n\nstatic netdev_tx_t cpsw_ndo_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tstruct cpts *cpts = cpsw->cpts;\n\tstruct netdev_queue *txq;\n\tstruct cpdma_chan *txch;\n\tint ret, q_idx;\n\n\tif (skb_put_padto(skb, CPSW_MIN_PACKET_SIZE)) {\n\t\tcpsw_err(priv, tx_err, \"packet pad failed\\n\");\n\t\tndev->stats.tx_dropped++;\n\t\treturn NET_XMIT_DROP;\n\t}\n\n\tif (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP &&\n\t    priv->tx_ts_enabled && cpts_can_timestamp(cpts, skb))\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\n\tq_idx = skb_get_queue_mapping(skb);\n\tif (q_idx >= cpsw->tx_ch_num)\n\t\tq_idx = q_idx % cpsw->tx_ch_num;\n\n\ttxch = cpsw->txv[q_idx].ch;\n\ttxq = netdev_get_tx_queue(ndev, q_idx);\n\tskb_tx_timestamp(skb);\n\tret = cpdma_chan_submit(txch, skb, skb->data, skb->len,\n\t\t\t\tpriv->emac_port + cpsw->data.dual_emac);\n\tif (unlikely(ret != 0)) {\n\t\tcpsw_err(priv, tx_err, \"desc submit failed\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tif (unlikely(!cpdma_check_free_tx_desc(txch))) {\n\t\tnetif_tx_stop_queue(txq);\n\n\t\t \n\t\tsmp_mb__after_atomic();\n\n\t\tif (cpdma_check_free_tx_desc(txch))\n\t\t\tnetif_tx_wake_queue(txq);\n\t}\n\n\treturn NETDEV_TX_OK;\nfail:\n\tndev->stats.tx_dropped++;\n\tnetif_tx_stop_queue(txq);\n\n\t \n\tsmp_mb__after_atomic();\n\n\tif (cpdma_check_free_tx_desc(txch))\n\t\tnetif_tx_wake_queue(txq);\n\n\treturn NETDEV_TX_BUSY;\n}\n\nstatic int cpsw_ndo_set_mac_address(struct net_device *ndev, void *p)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct sockaddr *addr = (struct sockaddr *)p;\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint flags = 0;\n\tu16 vid = 0;\n\tint ret;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tret = pm_runtime_resume_and_get(cpsw->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cpsw->data.dual_emac) {\n\t\tvid = cpsw->slaves[priv->emac_port].port_vlan;\n\t\tflags = ALE_VLAN;\n\t}\n\n\tcpsw_ale_del_ucast(cpsw->ale, priv->mac_addr, HOST_PORT_NUM,\n\t\t\t   flags, vid);\n\tcpsw_ale_add_ucast(cpsw->ale, addr->sa_data, HOST_PORT_NUM,\n\t\t\t   flags, vid);\n\n\tmemcpy(priv->mac_addr, addr->sa_data, ETH_ALEN);\n\teth_hw_addr_set(ndev, priv->mac_addr);\n\tfor_each_slave(priv, cpsw_set_slave_mac, priv);\n\n\tpm_runtime_put(cpsw->dev);\n\n\treturn 0;\n}\n\nstatic inline int cpsw_add_vlan_ale_entry(struct cpsw_priv *priv,\n\t\t\t\tunsigned short vid)\n{\n\tint ret;\n\tint unreg_mcast_mask = 0;\n\tint mcast_mask;\n\tu32 port_mask;\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\n\tif (cpsw->data.dual_emac) {\n\t\tport_mask = (1 << (priv->emac_port + 1)) | ALE_PORT_HOST;\n\n\t\tmcast_mask = ALE_PORT_HOST;\n\t\tif (priv->ndev->flags & IFF_ALLMULTI)\n\t\t\tunreg_mcast_mask = mcast_mask;\n\t} else {\n\t\tport_mask = ALE_ALL_PORTS;\n\t\tmcast_mask = port_mask;\n\n\t\tif (priv->ndev->flags & IFF_ALLMULTI)\n\t\t\tunreg_mcast_mask = ALE_ALL_PORTS;\n\t\telse\n\t\t\tunreg_mcast_mask = ALE_PORT_1 | ALE_PORT_2;\n\t}\n\n\tret = cpsw_ale_add_vlan(cpsw->ale, vid, port_mask, 0, port_mask,\n\t\t\t\tunreg_mcast_mask);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = cpsw_ale_add_ucast(cpsw->ale, priv->mac_addr,\n\t\t\t\t HOST_PORT_NUM, ALE_VLAN, vid);\n\tif (ret != 0)\n\t\tgoto clean_vid;\n\n\tret = cpsw_ale_add_mcast(cpsw->ale, priv->ndev->broadcast,\n\t\t\t\t mcast_mask, ALE_VLAN, vid, 0);\n\tif (ret != 0)\n\t\tgoto clean_vlan_ucast;\n\treturn 0;\n\nclean_vlan_ucast:\n\tcpsw_ale_del_ucast(cpsw->ale, priv->mac_addr,\n\t\t\t   HOST_PORT_NUM, ALE_VLAN, vid);\nclean_vid:\n\tcpsw_ale_del_vlan(cpsw->ale, vid, 0);\n\treturn ret;\n}\n\nstatic int cpsw_ndo_vlan_rx_add_vid(struct net_device *ndev,\n\t\t\t\t    __be16 proto, u16 vid)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint ret;\n\n\tif (vid == cpsw->data.default_vlan)\n\t\treturn 0;\n\n\tret = pm_runtime_resume_and_get(cpsw->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cpsw->data.dual_emac) {\n\t\t \n\t\tint i;\n\n\t\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\t\tif (vid == cpsw->slaves[i].port_vlan) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_info(priv->dev, \"Adding vlanid %d to vlan filter\\n\", vid);\n\tret = cpsw_add_vlan_ale_entry(priv, vid);\nerr:\n\tpm_runtime_put(cpsw->dev);\n\treturn ret;\n}\n\nstatic int cpsw_ndo_vlan_rx_kill_vid(struct net_device *ndev,\n\t\t\t\t     __be16 proto, u16 vid)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint ret;\n\n\tif (vid == cpsw->data.default_vlan)\n\t\treturn 0;\n\n\tret = pm_runtime_resume_and_get(cpsw->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cpsw->data.dual_emac) {\n\t\tint i;\n\n\t\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\t\tif (vid == cpsw->slaves[i].port_vlan)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\tdev_info(priv->dev, \"removing vlanid %d from vlan filter\\n\", vid);\n\tret = cpsw_ale_del_vlan(cpsw->ale, vid, 0);\n\tret |= cpsw_ale_del_ucast(cpsw->ale, priv->mac_addr,\n\t\t\t\t  HOST_PORT_NUM, ALE_VLAN, vid);\n\tret |= cpsw_ale_del_mcast(cpsw->ale, priv->ndev->broadcast,\n\t\t\t\t  0, ALE_VLAN, vid);\n\tret |= cpsw_ale_flush_multicast(cpsw->ale, ALE_PORT_HOST, vid);\nerr:\n\tpm_runtime_put(cpsw->dev);\n\treturn ret;\n}\n\nstatic int cpsw_ndo_xdp_xmit(struct net_device *ndev, int n,\n\t\t\t     struct xdp_frame **frames, u32 flags)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tstruct xdp_frame *xdpf;\n\tint i, nxmit = 0, port;\n\n\tif (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < n; i++) {\n\t\txdpf = frames[i];\n\t\tif (xdpf->len < CPSW_MIN_PACKET_SIZE)\n\t\t\tbreak;\n\n\t\tport = priv->emac_port + cpsw->data.dual_emac;\n\t\tif (cpsw_xdp_tx_frame(priv, xdpf, NULL, port))\n\t\t\tbreak;\n\t\tnxmit++;\n\t}\n\n\treturn nxmit;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void cpsw_ndo_poll_controller(struct net_device *ndev)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\n\tcpsw_intr_disable(cpsw);\n\tcpsw_rx_interrupt(cpsw->irqs_table[0], cpsw);\n\tcpsw_tx_interrupt(cpsw->irqs_table[1], cpsw);\n\tcpsw_intr_enable(cpsw);\n}\n#endif\n\nstatic const struct net_device_ops cpsw_netdev_ops = {\n\t.ndo_open\t\t= cpsw_ndo_open,\n\t.ndo_stop\t\t= cpsw_ndo_stop,\n\t.ndo_start_xmit\t\t= cpsw_ndo_start_xmit,\n\t.ndo_set_mac_address\t= cpsw_ndo_set_mac_address,\n\t.ndo_eth_ioctl\t\t= cpsw_ndo_ioctl,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_tx_timeout\t\t= cpsw_ndo_tx_timeout,\n\t.ndo_set_rx_mode\t= cpsw_ndo_set_rx_mode,\n\t.ndo_set_tx_maxrate\t= cpsw_ndo_set_tx_maxrate,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= cpsw_ndo_poll_controller,\n#endif\n\t.ndo_vlan_rx_add_vid\t= cpsw_ndo_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= cpsw_ndo_vlan_rx_kill_vid,\n\t.ndo_setup_tc           = cpsw_ndo_setup_tc,\n\t.ndo_bpf\t\t= cpsw_ndo_bpf,\n\t.ndo_xdp_xmit\t\t= cpsw_ndo_xdp_xmit,\n};\n\nstatic void cpsw_get_drvinfo(struct net_device *ndev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\tstruct platform_device\t*pdev = to_platform_device(cpsw->dev);\n\n\tstrscpy(info->driver, \"cpsw\", sizeof(info->driver));\n\tstrscpy(info->version, \"1.0\", sizeof(info->version));\n\tstrscpy(info->bus_info, pdev->name, sizeof(info->bus_info));\n}\n\nstatic int cpsw_set_pauseparam(struct net_device *ndev,\n\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tbool link;\n\n\tpriv->rx_pause = pause->rx_pause ? true : false;\n\tpriv->tx_pause = pause->tx_pause ? true : false;\n\n\tfor_each_slave(priv, _cpsw_adjust_link, priv, &link);\n\treturn 0;\n}\n\nstatic int cpsw_set_channels(struct net_device *ndev,\n\t\t\t     struct ethtool_channels *chs)\n{\n\treturn cpsw_set_channels_common(ndev, chs, cpsw_rx_handler);\n}\n\nstatic const struct ethtool_ops cpsw_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS,\n\t.get_drvinfo\t= cpsw_get_drvinfo,\n\t.get_msglevel\t= cpsw_get_msglevel,\n\t.set_msglevel\t= cpsw_set_msglevel,\n\t.get_link\t= ethtool_op_get_link,\n\t.get_ts_info\t= cpsw_get_ts_info,\n\t.get_coalesce\t= cpsw_get_coalesce,\n\t.set_coalesce\t= cpsw_set_coalesce,\n\t.get_sset_count\t\t= cpsw_get_sset_count,\n\t.get_strings\t\t= cpsw_get_strings,\n\t.get_ethtool_stats\t= cpsw_get_ethtool_stats,\n\t.get_pauseparam\t\t= cpsw_get_pauseparam,\n\t.set_pauseparam\t\t= cpsw_set_pauseparam,\n\t.get_wol\t= cpsw_get_wol,\n\t.set_wol\t= cpsw_set_wol,\n\t.get_regs_len\t= cpsw_get_regs_len,\n\t.get_regs\t= cpsw_get_regs,\n\t.begin\t\t= cpsw_ethtool_op_begin,\n\t.complete\t= cpsw_ethtool_op_complete,\n\t.get_channels\t= cpsw_get_channels,\n\t.set_channels\t= cpsw_set_channels,\n\t.get_link_ksettings\t= cpsw_get_link_ksettings,\n\t.set_link_ksettings\t= cpsw_set_link_ksettings,\n\t.get_eee\t= cpsw_get_eee,\n\t.set_eee\t= cpsw_set_eee,\n\t.nway_reset\t= cpsw_nway_reset,\n\t.get_ringparam = cpsw_get_ringparam,\n\t.set_ringparam = cpsw_set_ringparam,\n};\n\nstatic int cpsw_probe_dt(struct cpsw_platform_data *data,\n\t\t\t struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device_node *slave_node;\n\tint i = 0, ret;\n\tu32 prop;\n\n\tif (!node)\n\t\treturn -EINVAL;\n\n\tif (of_property_read_u32(node, \"slaves\", &prop)) {\n\t\tdev_err(&pdev->dev, \"Missing slaves property in the DT.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdata->slaves = prop;\n\n\tif (of_property_read_u32(node, \"active_slave\", &prop)) {\n\t\tdev_err(&pdev->dev, \"Missing active_slave property in the DT.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdata->active_slave = prop;\n\n\tdata->slave_data = devm_kcalloc(&pdev->dev,\n\t\t\t\t\tdata->slaves,\n\t\t\t\t\tsizeof(struct cpsw_slave_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!data->slave_data)\n\t\treturn -ENOMEM;\n\n\tif (of_property_read_u32(node, \"cpdma_channels\", &prop)) {\n\t\tdev_err(&pdev->dev, \"Missing cpdma_channels property in the DT.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdata->channels = prop;\n\n\tif (of_property_read_u32(node, \"bd_ram_size\", &prop)) {\n\t\tdev_err(&pdev->dev, \"Missing bd_ram_size property in the DT.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdata->bd_ram_size = prop;\n\n\tif (of_property_read_u32(node, \"mac_control\", &prop)) {\n\t\tdev_err(&pdev->dev, \"Missing mac_control property in the DT.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdata->mac_control = prop;\n\n\tif (of_property_read_bool(node, \"dual_emac\"))\n\t\tdata->dual_emac = true;\n\n\t \n\tret = of_platform_populate(node, NULL, NULL, &pdev->dev);\n\t \n\tif (ret)\n\t\tdev_warn(&pdev->dev, \"Doesn't have any child node\\n\");\n\n\tfor_each_available_child_of_node(node, slave_node) {\n\t\tstruct cpsw_slave_data *slave_data = data->slave_data + i;\n\t\tint lenp;\n\t\tconst __be32 *parp;\n\n\t\t \n\t\tif (!of_node_name_eq(slave_node, \"slave\"))\n\t\t\tcontinue;\n\n\t\tslave_data->ifphy = devm_of_phy_get(&pdev->dev, slave_node,\n\t\t\t\t\t\t    NULL);\n\t\tif (!IS_ENABLED(CONFIG_TI_CPSW_PHY_SEL) &&\n\t\t    IS_ERR(slave_data->ifphy)) {\n\t\t\tret = PTR_ERR(slave_data->ifphy);\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"%d: Error retrieving port phy: %d\\n\", i, ret);\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tslave_data->slave_node = slave_node;\n\t\tslave_data->phy_node = of_parse_phandle(slave_node,\n\t\t\t\t\t\t\t\"phy-handle\", 0);\n\t\tparp = of_get_property(slave_node, \"phy_id\", &lenp);\n\t\tif (slave_data->phy_node) {\n\t\t\tdev_dbg(&pdev->dev,\n\t\t\t\t\"slave[%d] using phy-handle=\\\"%pOF\\\"\\n\",\n\t\t\t\ti, slave_data->phy_node);\n\t\t} else if (of_phy_is_fixed_link(slave_node)) {\n\t\t\t \n\t\t\tret = of_phy_register_fixed_link(slave_node);\n\t\t\tif (ret) {\n\t\t\t\tdev_err_probe(&pdev->dev, ret, \"failed to register fixed-link phy\\n\");\n\t\t\t\tgoto err_node_put;\n\t\t\t}\n\t\t\tslave_data->phy_node = of_node_get(slave_node);\n\t\t} else if (parp) {\n\t\t\tu32 phyid;\n\t\t\tstruct device_node *mdio_node;\n\t\t\tstruct platform_device *mdio;\n\n\t\t\tif (lenp != (sizeof(__be32) * 2)) {\n\t\t\t\tdev_err(&pdev->dev, \"Invalid slave[%d] phy_id property\\n\", i);\n\t\t\t\tgoto no_phy_slave;\n\t\t\t}\n\t\t\tmdio_node = of_find_node_by_phandle(be32_to_cpup(parp));\n\t\t\tphyid = be32_to_cpup(parp+1);\n\t\t\tmdio = of_find_device_by_node(mdio_node);\n\t\t\tof_node_put(mdio_node);\n\t\t\tif (!mdio) {\n\t\t\t\tdev_err(&pdev->dev, \"Missing mdio platform device\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_node_put;\n\t\t\t}\n\t\t\tsnprintf(slave_data->phy_id, sizeof(slave_data->phy_id),\n\t\t\t\t PHY_ID_FMT, mdio->name, phyid);\n\t\t\tput_device(&mdio->dev);\n\t\t} else {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"No slave[%d] phy_id, phy-handle, or fixed-link property\\n\",\n\t\t\t\ti);\n\t\t\tgoto no_phy_slave;\n\t\t}\n\t\tret = of_get_phy_mode(slave_node, &slave_data->phy_if);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Missing or malformed slave[%d] phy-mode property\\n\",\n\t\t\t\ti);\n\t\t\tgoto err_node_put;\n\t\t}\n\nno_phy_slave:\n\t\tret = of_get_mac_address(slave_node, slave_data->mac_addr);\n\t\tif (ret) {\n\t\t\tret = ti_cm_get_macid(&pdev->dev, i,\n\t\t\t\t\t      slave_data->mac_addr);\n\t\t\tif (ret)\n\t\t\t\tgoto err_node_put;\n\t\t}\n\t\tif (data->dual_emac) {\n\t\t\tif (of_property_read_u32(slave_node, \"dual_emac_res_vlan\",\n\t\t\t\t\t\t &prop)) {\n\t\t\t\tdev_err(&pdev->dev, \"Missing dual_emac_res_vlan in DT.\\n\");\n\t\t\t\tslave_data->dual_emac_res_vlan = i+1;\n\t\t\t\tdev_err(&pdev->dev, \"Using %d as Reserved VLAN for %d slave\\n\",\n\t\t\t\t\tslave_data->dual_emac_res_vlan, i);\n\t\t\t} else {\n\t\t\t\tslave_data->dual_emac_res_vlan = prop;\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t\tif (i == data->slaves) {\n\t\t\tret = 0;\n\t\t\tgoto err_node_put;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_node_put:\n\tof_node_put(slave_node);\n\treturn ret;\n}\n\nstatic void cpsw_remove_dt(struct platform_device *pdev)\n{\n\tstruct cpsw_common *cpsw = platform_get_drvdata(pdev);\n\tstruct cpsw_platform_data *data = &cpsw->data;\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device_node *slave_node;\n\tint i = 0;\n\n\tfor_each_available_child_of_node(node, slave_node) {\n\t\tstruct cpsw_slave_data *slave_data = &data->slave_data[i];\n\n\t\tif (!of_node_name_eq(slave_node, \"slave\"))\n\t\t\tcontinue;\n\n\t\tif (of_phy_is_fixed_link(slave_node))\n\t\t\tof_phy_deregister_fixed_link(slave_node);\n\n\t\tof_node_put(slave_data->phy_node);\n\n\t\ti++;\n\t\tif (i == data->slaves) {\n\t\t\tof_node_put(slave_node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tof_platform_depopulate(&pdev->dev);\n}\n\nstatic int cpsw_probe_dual_emac(struct cpsw_priv *priv)\n{\n\tstruct cpsw_common\t\t*cpsw = priv->cpsw;\n\tstruct cpsw_platform_data\t*data = &cpsw->data;\n\tstruct net_device\t\t*ndev;\n\tstruct cpsw_priv\t\t*priv_sl2;\n\tint ret = 0;\n\n\tndev = devm_alloc_etherdev_mqs(cpsw->dev, sizeof(struct cpsw_priv),\n\t\t\t\t       CPSW_MAX_QUEUES, CPSW_MAX_QUEUES);\n\tif (!ndev) {\n\t\tdev_err(cpsw->dev, \"cpsw: error allocating net_device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv_sl2 = netdev_priv(ndev);\n\tpriv_sl2->cpsw = cpsw;\n\tpriv_sl2->ndev = ndev;\n\tpriv_sl2->dev  = &ndev->dev;\n\tpriv_sl2->msg_enable = netif_msg_init(debug_level, CPSW_DEBUG);\n\n\tif (is_valid_ether_addr(data->slave_data[1].mac_addr)) {\n\t\tmemcpy(priv_sl2->mac_addr, data->slave_data[1].mac_addr,\n\t\t\tETH_ALEN);\n\t\tdev_info(cpsw->dev, \"cpsw: Detected MACID = %pM\\n\",\n\t\t\t priv_sl2->mac_addr);\n\t} else {\n\t\teth_random_addr(priv_sl2->mac_addr);\n\t\tdev_info(cpsw->dev, \"cpsw: Random MACID = %pM\\n\",\n\t\t\t priv_sl2->mac_addr);\n\t}\n\teth_hw_addr_set(ndev, priv_sl2->mac_addr);\n\n\tpriv_sl2->emac_port = 1;\n\tcpsw->slaves[1].ndev = ndev;\n\tndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_HW_VLAN_CTAG_RX;\n\tndev->xdp_features = NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT |\n\t\t\t     NETDEV_XDP_ACT_NDO_XMIT;\n\n\tndev->netdev_ops = &cpsw_netdev_ops;\n\tndev->ethtool_ops = &cpsw_ethtool_ops;\n\n\t \n\tSET_NETDEV_DEV(ndev, cpsw->dev);\n\tndev->dev.of_node = cpsw->slaves[1].data->slave_node;\n\tret = register_netdev(ndev);\n\tif (ret)\n\t\tdev_err(cpsw->dev, \"cpsw: error registering net device\\n\");\n\n\treturn ret;\n}\n\nstatic const struct of_device_id cpsw_of_mtable[] = {\n\t{ .compatible = \"ti,cpsw\"},\n\t{ .compatible = \"ti,am335x-cpsw\"},\n\t{ .compatible = \"ti,am4372-cpsw\"},\n\t{ .compatible = \"ti,dra7-cpsw\"},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, cpsw_of_mtable);\n\nstatic const struct soc_device_attribute cpsw_soc_devices[] = {\n\t{ .family = \"AM33xx\", .revision = \"ES1.0\"},\n\t{   }\n};\n\nstatic int cpsw_probe(struct platform_device *pdev)\n{\n\tstruct device\t\t\t*dev = &pdev->dev;\n\tstruct clk\t\t\t*clk;\n\tstruct cpsw_platform_data\t*data;\n\tstruct net_device\t\t*ndev;\n\tstruct cpsw_priv\t\t*priv;\n\tvoid __iomem\t\t\t*ss_regs;\n\tstruct resource\t\t\t*ss_res;\n\tstruct gpio_descs\t\t*mode;\n\tconst struct soc_device_attribute *soc;\n\tstruct cpsw_common\t\t*cpsw;\n\tint ret = 0, ch;\n\tint irq;\n\n\tcpsw = devm_kzalloc(dev, sizeof(struct cpsw_common), GFP_KERNEL);\n\tif (!cpsw)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, cpsw);\n\tcpsw_slave_index = cpsw_slave_index_priv;\n\n\tcpsw->dev = dev;\n\n\tmode = devm_gpiod_get_array_optional(dev, \"mode\", GPIOD_OUT_LOW);\n\tif (IS_ERR(mode)) {\n\t\tret = PTR_ERR(mode);\n\t\tdev_err(dev, \"gpio request failed, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tclk = devm_clk_get(dev, \"fck\");\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tdev_err(dev, \"fck is not found %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tcpsw->bus_freq_mhz = clk_get_rate(clk) / 1000000;\n\n\tss_regs = devm_platform_get_and_ioremap_resource(pdev, 0, &ss_res);\n\tif (IS_ERR(ss_regs))\n\t\treturn PTR_ERR(ss_regs);\n\tcpsw->regs = ss_regs;\n\n\tcpsw->wr_regs = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(cpsw->wr_regs))\n\t\treturn PTR_ERR(cpsw->wr_regs);\n\n\t \n\tirq = platform_get_irq(pdev, 1);\n\tif (irq < 0)\n\t\treturn irq;\n\tcpsw->irqs_table[0] = irq;\n\n\t \n\tirq = platform_get_irq(pdev, 2);\n\tif (irq < 0)\n\t\treturn irq;\n\tcpsw->irqs_table[1] = irq;\n\n\t \n\tirq = platform_get_irq(pdev, 3);\n\tif (irq <= 0)\n\t\treturn irq;\n\tcpsw->misc_irq = irq;\n\n\t \n\tpm_runtime_enable(dev);\n\n\t \n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\tgoto clean_runtime_disable_ret;\n\n\tret = cpsw_probe_dt(&cpsw->data, pdev);\n\tif (ret)\n\t\tgoto clean_dt_ret;\n\n\tsoc = soc_device_match(cpsw_soc_devices);\n\tif (soc)\n\t\tcpsw->quirk_irq = true;\n\n\tdata = &cpsw->data;\n\tcpsw->slaves = devm_kcalloc(dev,\n\t\t\t\t    data->slaves, sizeof(struct cpsw_slave),\n\t\t\t\t    GFP_KERNEL);\n\tif (!cpsw->slaves) {\n\t\tret = -ENOMEM;\n\t\tgoto clean_dt_ret;\n\t}\n\n\tcpsw->rx_packet_max = max(rx_packet_max, CPSW_MAX_PACKET_SIZE);\n\tcpsw->descs_pool_size = descs_pool_size;\n\n\tret = cpsw_init_common(cpsw, ss_regs, ale_ageout,\n\t\t\t       ss_res->start + CPSW2_BD_OFFSET,\n\t\t\t       descs_pool_size);\n\tif (ret)\n\t\tgoto clean_dt_ret;\n\n\tch = cpsw->quirk_irq ? 0 : 7;\n\tcpsw->txv[0].ch = cpdma_chan_create(cpsw->dma, ch, cpsw_tx_handler, 0);\n\tif (IS_ERR(cpsw->txv[0].ch)) {\n\t\tdev_err(dev, \"error initializing tx dma channel\\n\");\n\t\tret = PTR_ERR(cpsw->txv[0].ch);\n\t\tgoto clean_cpts;\n\t}\n\n\tcpsw->rxv[0].ch = cpdma_chan_create(cpsw->dma, 0, cpsw_rx_handler, 1);\n\tif (IS_ERR(cpsw->rxv[0].ch)) {\n\t\tdev_err(dev, \"error initializing rx dma channel\\n\");\n\t\tret = PTR_ERR(cpsw->rxv[0].ch);\n\t\tgoto clean_cpts;\n\t}\n\tcpsw_split_res(cpsw);\n\n\t \n\tndev = devm_alloc_etherdev_mqs(dev, sizeof(struct cpsw_priv),\n\t\t\t\t       CPSW_MAX_QUEUES, CPSW_MAX_QUEUES);\n\tif (!ndev) {\n\t\tdev_err(dev, \"error allocating net_device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clean_cpts;\n\t}\n\n\tpriv = netdev_priv(ndev);\n\tpriv->cpsw = cpsw;\n\tpriv->ndev = ndev;\n\tpriv->dev  = dev;\n\tpriv->msg_enable = netif_msg_init(debug_level, CPSW_DEBUG);\n\tpriv->emac_port = 0;\n\n\tif (is_valid_ether_addr(data->slave_data[0].mac_addr)) {\n\t\tmemcpy(priv->mac_addr, data->slave_data[0].mac_addr, ETH_ALEN);\n\t\tdev_info(dev, \"Detected MACID = %pM\\n\", priv->mac_addr);\n\t} else {\n\t\teth_random_addr(priv->mac_addr);\n\t\tdev_info(dev, \"Random MACID = %pM\\n\", priv->mac_addr);\n\t}\n\n\teth_hw_addr_set(ndev, priv->mac_addr);\n\n\tcpsw->slaves[0].ndev = ndev;\n\n\tndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_HW_VLAN_CTAG_RX;\n\tndev->xdp_features = NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT |\n\t\t\t     NETDEV_XDP_ACT_NDO_XMIT;\n\n\tndev->netdev_ops = &cpsw_netdev_ops;\n\tndev->ethtool_ops = &cpsw_ethtool_ops;\n\tnetif_napi_add(ndev, &cpsw->napi_rx,\n\t\t       cpsw->quirk_irq ? cpsw_rx_poll : cpsw_rx_mq_poll);\n\tnetif_napi_add_tx(ndev, &cpsw->napi_tx,\n\t\t\t  cpsw->quirk_irq ? cpsw_tx_poll : cpsw_tx_mq_poll);\n\n\t \n\tSET_NETDEV_DEV(ndev, dev);\n\tndev->dev.of_node = cpsw->slaves[0].data->slave_node;\n\tret = register_netdev(ndev);\n\tif (ret) {\n\t\tdev_err(dev, \"error registering net device\\n\");\n\t\tret = -ENODEV;\n\t\tgoto clean_cpts;\n\t}\n\n\tif (cpsw->data.dual_emac) {\n\t\tret = cpsw_probe_dual_emac(priv);\n\t\tif (ret) {\n\t\t\tcpsw_err(priv, probe, \"error probe slave 2 emac interface\\n\");\n\t\t\tgoto clean_unregister_netdev_ret;\n\t\t}\n\t}\n\n\t \n\tret = devm_request_irq(dev, cpsw->irqs_table[0], cpsw_rx_interrupt,\n\t\t\t       0, dev_name(dev), cpsw);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error attaching irq (%d)\\n\", ret);\n\t\tgoto clean_unregister_netdev_ret;\n\t}\n\n\n\tret = devm_request_irq(dev, cpsw->irqs_table[1], cpsw_tx_interrupt,\n\t\t\t       0, dev_name(&pdev->dev), cpsw);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error attaching irq (%d)\\n\", ret);\n\t\tgoto clean_unregister_netdev_ret;\n\t}\n\n\tif (!cpsw->cpts)\n\t\tgoto skip_cpts;\n\n\tret = devm_request_irq(&pdev->dev, cpsw->misc_irq, cpsw_misc_interrupt,\n\t\t\t       0, dev_name(&pdev->dev), cpsw);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error attaching misc irq (%d)\\n\", ret);\n\t\tgoto clean_unregister_netdev_ret;\n\t}\n\n\t \n\tcpts_set_irqpoll(cpsw->cpts, false);\n\nskip_cpts:\n\tcpsw_notice(priv, probe,\n\t\t    \"initialized device (regs %pa, irq %d, pool size %d)\\n\",\n\t\t    &ss_res->start, cpsw->irqs_table[0], descs_pool_size);\n\n\tpm_runtime_put(&pdev->dev);\n\n\treturn 0;\n\nclean_unregister_netdev_ret:\n\tunregister_netdev(ndev);\nclean_cpts:\n\tcpts_release(cpsw->cpts);\n\tcpdma_ctlr_destroy(cpsw->dma);\nclean_dt_ret:\n\tcpsw_remove_dt(pdev);\n\tpm_runtime_put_sync(&pdev->dev);\nclean_runtime_disable_ret:\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic int cpsw_remove(struct platform_device *pdev)\n{\n\tstruct cpsw_common *cpsw = platform_get_drvdata(pdev);\n\tint i, ret;\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < cpsw->data.slaves; i++)\n\t\tif (cpsw->slaves[i].ndev)\n\t\t\tunregister_netdev(cpsw->slaves[i].ndev);\n\n\tcpts_release(cpsw->cpts);\n\tcpdma_ctlr_destroy(cpsw->dma);\n\tcpsw_remove_dt(pdev);\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int cpsw_suspend(struct device *dev)\n{\n\tstruct cpsw_common *cpsw = dev_get_drvdata(dev);\n\tint i;\n\n\trtnl_lock();\n\n\tfor (i = 0; i < cpsw->data.slaves; i++)\n\t\tif (cpsw->slaves[i].ndev)\n\t\t\tif (netif_running(cpsw->slaves[i].ndev))\n\t\t\t\tcpsw_ndo_stop(cpsw->slaves[i].ndev);\n\n\trtnl_unlock();\n\n\t \n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int cpsw_resume(struct device *dev)\n{\n\tstruct cpsw_common *cpsw = dev_get_drvdata(dev);\n\tint i;\n\n\t \n\tpinctrl_pm_select_default_state(dev);\n\n\t \n\trtnl_lock();\n\n\tfor (i = 0; i < cpsw->data.slaves; i++)\n\t\tif (cpsw->slaves[i].ndev)\n\t\t\tif (netif_running(cpsw->slaves[i].ndev))\n\t\t\t\tcpsw_ndo_open(cpsw->slaves[i].ndev);\n\n\trtnl_unlock();\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(cpsw_pm_ops, cpsw_suspend, cpsw_resume);\n\nstatic struct platform_driver cpsw_driver = {\n\t.driver = {\n\t\t.name\t = \"cpsw\",\n\t\t.pm\t = &cpsw_pm_ops,\n\t\t.of_match_table = cpsw_of_mtable,\n\t},\n\t.probe = cpsw_probe,\n\t.remove = cpsw_remove,\n};\n\nmodule_platform_driver(cpsw_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Cyril Chemparathy <cyril@ti.com>\");\nMODULE_AUTHOR(\"Mugunthan V N <mugunthanvnm@ti.com>\");\nMODULE_DESCRIPTION(\"TI CPSW Ethernet driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}