{
  "module_name": "netcp_core.c",
  "hash_id": "f23d6252ba2b121d9f853beeeaa3dc5674909c36387bd341127c8113c2a8b32a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/netcp_core.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_net.h>\n#include <linux/of_address.h>\n#include <linux/if_vlan.h>\n#include <linux/pm_runtime.h>\n#include <linux/platform_device.h>\n#include <linux/soc/ti/knav_qmss.h>\n#include <linux/soc/ti/knav_dma.h>\n\n#include \"netcp.h\"\n\n#define NETCP_SOP_OFFSET\t(NET_IP_ALIGN + NET_SKB_PAD)\n#define NETCP_TX_TIMEOUT\t(5 * HZ)\n#define NETCP_PACKET_SIZE\t(ETH_FRAME_LEN + ETH_FCS_LEN)\n#define NETCP_MIN_PACKET_SIZE\tETH_ZLEN\n#define NETCP_MAX_MCAST_ADDR\t16\n\n#define NETCP_EFUSE_REG_INDEX\t0\n\n#define NETCP_MOD_PROBE_SKIPPED\t1\n#define NETCP_MOD_PROBE_FAILED\t2\n\n#define NETCP_DEBUG (NETIF_MSG_HW\t| NETIF_MSG_WOL\t\t|\t\\\n\t\t    NETIF_MSG_DRV\t| NETIF_MSG_LINK\t|\t\\\n\t\t    NETIF_MSG_IFUP\t| NETIF_MSG_INTR\t|\t\\\n\t\t    NETIF_MSG_PROBE\t| NETIF_MSG_TIMER\t|\t\\\n\t\t    NETIF_MSG_IFDOWN\t| NETIF_MSG_RX_ERR\t|\t\\\n\t\t    NETIF_MSG_TX_ERR\t| NETIF_MSG_TX_DONE\t|\t\\\n\t\t    NETIF_MSG_PKTDATA\t| NETIF_MSG_TX_QUEUED\t|\t\\\n\t\t    NETIF_MSG_RX_STATUS)\n\n#define NETCP_EFUSE_ADDR_SWAP\t2\n\n#define knav_queue_get_id(q)\tknav_queue_device_control(q, \\\n\t\t\t\tKNAV_QUEUE_GET_ID, (unsigned long)NULL)\n\n#define knav_queue_enable_notify(q) knav_queue_device_control(q,\t\\\n\t\t\t\t\tKNAV_QUEUE_ENABLE_NOTIFY,\t\\\n\t\t\t\t\t(unsigned long)NULL)\n\n#define knav_queue_disable_notify(q) knav_queue_device_control(q,\t\\\n\t\t\t\t\tKNAV_QUEUE_DISABLE_NOTIFY,\t\\\n\t\t\t\t\t(unsigned long)NULL)\n\n#define knav_queue_get_count(q)\tknav_queue_device_control(q, \\\n\t\t\t\tKNAV_QUEUE_GET_COUNT, (unsigned long)NULL)\n\n#define for_each_netcp_module(module)\t\t\t\\\n\tlist_for_each_entry(module, &netcp_modules, module_list)\n\n#define for_each_netcp_device_module(netcp_device, inst_modpriv) \\\n\tlist_for_each_entry(inst_modpriv, \\\n\t\t&((netcp_device)->modpriv_head), inst_list)\n\n#define for_each_module(netcp, intf_modpriv)\t\t\t\\\n\tlist_for_each_entry(intf_modpriv, &netcp->module_head, intf_list)\n\n \nstruct netcp_device {\n\tstruct list_head\tdevice_list;\n\tstruct list_head\tinterface_head;\n\tstruct list_head\tmodpriv_head;\n\tstruct device\t\t*device;\n};\n\nstruct netcp_inst_modpriv {\n\tstruct netcp_device\t*netcp_device;\n\tstruct netcp_module\t*netcp_module;\n\tstruct list_head\tinst_list;\n\tvoid\t\t\t*module_priv;\n};\n\nstruct netcp_intf_modpriv {\n\tstruct netcp_intf\t*netcp_priv;\n\tstruct netcp_module\t*netcp_module;\n\tstruct list_head\tintf_list;\n\tvoid\t\t\t*module_priv;\n};\n\nstruct netcp_tx_cb {\n\tvoid\t*ts_context;\n\tvoid\t(*txtstamp)(void *context, struct sk_buff *skb);\n};\n\nstatic LIST_HEAD(netcp_devices);\nstatic LIST_HEAD(netcp_modules);\nstatic DEFINE_MUTEX(netcp_modules_lock);\n\nstatic int netcp_debug_level = -1;\nmodule_param(netcp_debug_level, int, 0);\nMODULE_PARM_DESC(netcp_debug_level, \"Netcp debug level (NETIF_MSG bits) (0=none,...,16=all)\");\n\n \nstatic void get_pkt_info(dma_addr_t *buff, u32 *buff_len, dma_addr_t *ndesc,\n\t\t\t struct knav_dma_desc *desc)\n{\n\t*buff_len = le32_to_cpu(desc->buff_len);\n\t*buff = le32_to_cpu(desc->buff);\n\t*ndesc = le32_to_cpu(desc->next_desc);\n}\n\nstatic void get_desc_info(u32 *desc_info, u32 *pkt_info,\n\t\t\t  struct knav_dma_desc *desc)\n{\n\t*desc_info = le32_to_cpu(desc->desc_info);\n\t*pkt_info = le32_to_cpu(desc->packet_info);\n}\n\nstatic u32 get_sw_data(int index, struct knav_dma_desc *desc)\n{\n\t \n\treturn desc->sw_data[index];\n}\n\n \n#define GET_SW_DATA0(desc) get_sw_data(0, desc)\n#define GET_SW_DATA1(desc) get_sw_data(1, desc)\n#define GET_SW_DATA2(desc) get_sw_data(2, desc)\n#define GET_SW_DATA3(desc) get_sw_data(3, desc)\n\nstatic void get_org_pkt_info(dma_addr_t *buff, u32 *buff_len,\n\t\t\t     struct knav_dma_desc *desc)\n{\n\t*buff = le32_to_cpu(desc->orig_buff);\n\t*buff_len = le32_to_cpu(desc->orig_len);\n}\n\nstatic void get_words(dma_addr_t *words, int num_words, __le32 *desc)\n{\n\tint i;\n\n\tfor (i = 0; i < num_words; i++)\n\t\twords[i] = le32_to_cpu(desc[i]);\n}\n\nstatic void set_pkt_info(dma_addr_t buff, u32 buff_len, u32 ndesc,\n\t\t\t struct knav_dma_desc *desc)\n{\n\tdesc->buff_len = cpu_to_le32(buff_len);\n\tdesc->buff = cpu_to_le32(buff);\n\tdesc->next_desc = cpu_to_le32(ndesc);\n}\n\nstatic void set_desc_info(u32 desc_info, u32 pkt_info,\n\t\t\t  struct knav_dma_desc *desc)\n{\n\tdesc->desc_info = cpu_to_le32(desc_info);\n\tdesc->packet_info = cpu_to_le32(pkt_info);\n}\n\nstatic void set_sw_data(int index, u32 data, struct knav_dma_desc *desc)\n{\n\t \n\tdesc->sw_data[index] = data;\n}\n\n \n#define SET_SW_DATA0(data, desc) set_sw_data(0, data, desc)\n#define SET_SW_DATA1(data, desc) set_sw_data(1, data, desc)\n#define SET_SW_DATA2(data, desc) set_sw_data(2, data, desc)\n#define SET_SW_DATA3(data, desc) set_sw_data(3, data, desc)\n\nstatic void set_org_pkt_info(dma_addr_t buff, u32 buff_len,\n\t\t\t     struct knav_dma_desc *desc)\n{\n\tdesc->orig_buff = cpu_to_le32(buff);\n\tdesc->orig_len = cpu_to_le32(buff_len);\n}\n\nstatic void set_words(u32 *words, int num_words, __le32 *desc)\n{\n\tint i;\n\n\tfor (i = 0; i < num_words; i++)\n\t\tdesc[i] = cpu_to_le32(words[i]);\n}\n\n \nstatic int emac_arch_get_mac_addr(char *x, void __iomem *efuse_mac, u32 swap)\n{\n\tunsigned int addr0, addr1;\n\n\taddr1 = readl(efuse_mac + 4);\n\taddr0 = readl(efuse_mac);\n\n\tswitch (swap) {\n\tcase NETCP_EFUSE_ADDR_SWAP:\n\t\taddr0 = addr1;\n\t\taddr1 = readl(efuse_mac);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tx[0] = (addr1 & 0x0000ff00) >> 8;\n\tx[1] = addr1 & 0x000000ff;\n\tx[2] = (addr0 & 0xff000000) >> 24;\n\tx[3] = (addr0 & 0x00ff0000) >> 16;\n\tx[4] = (addr0 & 0x0000ff00) >> 8;\n\tx[5] = addr0 & 0x000000ff;\n\n\treturn 0;\n}\n\n \nstatic int netcp_register_interface(struct netcp_intf *netcp)\n{\n\tint ret;\n\n\tret = register_netdev(netcp->ndev);\n\tif (!ret)\n\t\tnetcp->netdev_registered = true;\n\treturn ret;\n}\n\nstatic int netcp_module_probe(struct netcp_device *netcp_device,\n\t\t\t      struct netcp_module *module)\n{\n\tstruct device *dev = netcp_device->device;\n\tstruct device_node *devices, *interface, *node = dev->of_node;\n\tstruct device_node *child;\n\tstruct netcp_inst_modpriv *inst_modpriv;\n\tstruct netcp_intf *netcp_intf;\n\tstruct netcp_module *tmp;\n\tbool primary_module_registered = false;\n\tint ret;\n\n\t \n\tdevices = of_get_child_by_name(node, \"netcp-devices\");\n\tif (!devices) {\n\t\tdev_err(dev, \"could not find netcp-devices node\\n\");\n\t\treturn NETCP_MOD_PROBE_SKIPPED;\n\t}\n\n\tfor_each_available_child_of_node(devices, child) {\n\t\tconst char *name;\n\t\tchar node_name[32];\n\n\t\tif (of_property_read_string(child, \"label\", &name) < 0) {\n\t\t\tsnprintf(node_name, sizeof(node_name), \"%pOFn\", child);\n\t\t\tname = node_name;\n\t\t}\n\t\tif (!strcasecmp(module->name, name))\n\t\t\tbreak;\n\t}\n\n\tof_node_put(devices);\n\t \n\tif (!child) {\n\t\tdev_warn(dev, \"module(%s) not used for device\\n\", module->name);\n\t\treturn NETCP_MOD_PROBE_SKIPPED;\n\t}\n\n\tinst_modpriv = devm_kzalloc(dev, sizeof(*inst_modpriv), GFP_KERNEL);\n\tif (!inst_modpriv) {\n\t\tof_node_put(child);\n\t\treturn -ENOMEM;\n\t}\n\n\tinst_modpriv->netcp_device = netcp_device;\n\tinst_modpriv->netcp_module = module;\n\tlist_add_tail(&inst_modpriv->inst_list, &netcp_device->modpriv_head);\n\n\tret = module->probe(netcp_device, dev, child,\n\t\t\t    &inst_modpriv->module_priv);\n\tof_node_put(child);\n\tif (ret) {\n\t\tdev_err(dev, \"Probe of module(%s) failed with %d\\n\",\n\t\t\tmodule->name, ret);\n\t\tlist_del(&inst_modpriv->inst_list);\n\t\tdevm_kfree(dev, inst_modpriv);\n\t\treturn NETCP_MOD_PROBE_FAILED;\n\t}\n\n\t \n\tfor_each_netcp_module(tmp) {\n\t\tif (tmp->primary)\n\t\t\tprimary_module_registered = true;\n\t}\n\n\tif (!primary_module_registered)\n\t\treturn 0;\n\n\t \n\tlist_for_each_entry(netcp_intf, &netcp_device->interface_head,\n\t\t\t    interface_list) {\n\t\tstruct netcp_intf_modpriv *intf_modpriv;\n\n\t\tintf_modpriv = devm_kzalloc(dev, sizeof(*intf_modpriv),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!intf_modpriv)\n\t\t\treturn -ENOMEM;\n\n\t\tinterface = of_parse_phandle(netcp_intf->node_interface,\n\t\t\t\t\t     module->name, 0);\n\n\t\tif (!interface) {\n\t\t\tdevm_kfree(dev, intf_modpriv);\n\t\t\tcontinue;\n\t\t}\n\n\t\tintf_modpriv->netcp_priv = netcp_intf;\n\t\tintf_modpriv->netcp_module = module;\n\t\tlist_add_tail(&intf_modpriv->intf_list,\n\t\t\t      &netcp_intf->module_head);\n\n\t\tret = module->attach(inst_modpriv->module_priv,\n\t\t\t\t     netcp_intf->ndev, interface,\n\t\t\t\t     &intf_modpriv->module_priv);\n\t\tof_node_put(interface);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"Attach of module %s declined with %d\\n\",\n\t\t\t\tmodule->name, ret);\n\t\t\tlist_del(&intf_modpriv->intf_list);\n\t\t\tdevm_kfree(dev, intf_modpriv);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(netcp_intf,\n\t\t\t    &netcp_device->interface_head,\n\t\t\t    interface_list) {\n\t\t \n\t\tif (!netcp_intf->netdev_registered) {\n\t\t\tret = netcp_register_interface(netcp_intf);\n\t\t\tif (ret)\n\t\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint netcp_register_module(struct netcp_module *module)\n{\n\tstruct netcp_device *netcp_device;\n\tstruct netcp_module *tmp;\n\tint ret;\n\n\tif (!module->name) {\n\t\tWARN(1, \"error registering netcp module: no name\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!module->probe) {\n\t\tWARN(1, \"error registering netcp module: no probe\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&netcp_modules_lock);\n\n\tfor_each_netcp_module(tmp) {\n\t\tif (!strcasecmp(tmp->name, module->name)) {\n\t\t\tmutex_unlock(&netcp_modules_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tlist_add_tail(&module->module_list, &netcp_modules);\n\n\tlist_for_each_entry(netcp_device, &netcp_devices, device_list) {\n\t\tret = netcp_module_probe(netcp_device, module);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t}\n\tmutex_unlock(&netcp_modules_lock);\n\treturn 0;\n\nfail:\n\tmutex_unlock(&netcp_modules_lock);\n\tnetcp_unregister_module(module);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(netcp_register_module);\n\nstatic void netcp_release_module(struct netcp_device *netcp_device,\n\t\t\t\t struct netcp_module *module)\n{\n\tstruct netcp_inst_modpriv *inst_modpriv, *inst_tmp;\n\tstruct netcp_intf *netcp_intf, *netcp_tmp;\n\tstruct device *dev = netcp_device->device;\n\n\t \n\tlist_for_each_entry_safe(netcp_intf, netcp_tmp,\n\t\t\t\t &netcp_device->interface_head,\n\t\t\t\t interface_list) {\n\t\tstruct netcp_intf_modpriv *intf_modpriv, *intf_tmp;\n\n\t\tlist_for_each_entry_safe(intf_modpriv, intf_tmp,\n\t\t\t\t\t &netcp_intf->module_head,\n\t\t\t\t\t intf_list) {\n\t\t\tif (intf_modpriv->netcp_module == module) {\n\t\t\t\tmodule->release(intf_modpriv->module_priv);\n\t\t\t\tlist_del(&intf_modpriv->intf_list);\n\t\t\t\tdevm_kfree(dev, intf_modpriv);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry_safe(inst_modpriv, inst_tmp,\n\t\t\t\t &netcp_device->modpriv_head, inst_list) {\n\t\tif (inst_modpriv->netcp_module == module) {\n\t\t\tmodule->remove(netcp_device,\n\t\t\t\t       inst_modpriv->module_priv);\n\t\t\tlist_del(&inst_modpriv->inst_list);\n\t\t\tdevm_kfree(dev, inst_modpriv);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid netcp_unregister_module(struct netcp_module *module)\n{\n\tstruct netcp_device *netcp_device;\n\tstruct netcp_module *module_tmp;\n\n\tmutex_lock(&netcp_modules_lock);\n\n\tlist_for_each_entry(netcp_device, &netcp_devices, device_list) {\n\t\tnetcp_release_module(netcp_device, module);\n\t}\n\n\t \n\tfor_each_netcp_module(module_tmp) {\n\t\tif (module == module_tmp) {\n\t\t\tlist_del(&module->module_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&netcp_modules_lock);\n}\nEXPORT_SYMBOL_GPL(netcp_unregister_module);\n\nvoid *netcp_module_get_intf_data(struct netcp_module *module,\n\t\t\t\t struct netcp_intf *intf)\n{\n\tstruct netcp_intf_modpriv *intf_modpriv;\n\n\tlist_for_each_entry(intf_modpriv, &intf->module_head, intf_list)\n\t\tif (intf_modpriv->netcp_module == module)\n\t\t\treturn intf_modpriv->module_priv;\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(netcp_module_get_intf_data);\n\n \nstruct netcp_hook_list {\n\tstruct list_head\t list;\n\tnetcp_hook_rtn\t\t*hook_rtn;\n\tvoid\t\t\t*hook_data;\n\tint\t\t\t order;\n};\n\nint netcp_register_txhook(struct netcp_intf *netcp_priv, int order,\n\t\t\t  netcp_hook_rtn *hook_rtn, void *hook_data)\n{\n\tstruct netcp_hook_list *entry;\n\tstruct netcp_hook_list *next;\n\tunsigned long flags;\n\n\tentry = devm_kzalloc(netcp_priv->dev, sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->hook_rtn  = hook_rtn;\n\tentry->hook_data = hook_data;\n\tentry->order     = order;\n\n\tspin_lock_irqsave(&netcp_priv->lock, flags);\n\tlist_for_each_entry(next, &netcp_priv->txhook_list_head, list) {\n\t\tif (next->order > order)\n\t\t\tbreak;\n\t}\n\t__list_add(&entry->list, next->list.prev, &next->list);\n\tspin_unlock_irqrestore(&netcp_priv->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(netcp_register_txhook);\n\nint netcp_unregister_txhook(struct netcp_intf *netcp_priv, int order,\n\t\t\t    netcp_hook_rtn *hook_rtn, void *hook_data)\n{\n\tstruct netcp_hook_list *next, *n;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&netcp_priv->lock, flags);\n\tlist_for_each_entry_safe(next, n, &netcp_priv->txhook_list_head, list) {\n\t\tif ((next->order     == order) &&\n\t\t    (next->hook_rtn  == hook_rtn) &&\n\t\t    (next->hook_data == hook_data)) {\n\t\t\tlist_del(&next->list);\n\t\t\tspin_unlock_irqrestore(&netcp_priv->lock, flags);\n\t\t\tdevm_kfree(netcp_priv->dev, next);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&netcp_priv->lock, flags);\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(netcp_unregister_txhook);\n\nint netcp_register_rxhook(struct netcp_intf *netcp_priv, int order,\n\t\t\t  netcp_hook_rtn *hook_rtn, void *hook_data)\n{\n\tstruct netcp_hook_list *entry;\n\tstruct netcp_hook_list *next;\n\tunsigned long flags;\n\n\tentry = devm_kzalloc(netcp_priv->dev, sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->hook_rtn  = hook_rtn;\n\tentry->hook_data = hook_data;\n\tentry->order     = order;\n\n\tspin_lock_irqsave(&netcp_priv->lock, flags);\n\tlist_for_each_entry(next, &netcp_priv->rxhook_list_head, list) {\n\t\tif (next->order > order)\n\t\t\tbreak;\n\t}\n\t__list_add(&entry->list, next->list.prev, &next->list);\n\tspin_unlock_irqrestore(&netcp_priv->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(netcp_register_rxhook);\n\nint netcp_unregister_rxhook(struct netcp_intf *netcp_priv, int order,\n\t\t\t    netcp_hook_rtn *hook_rtn, void *hook_data)\n{\n\tstruct netcp_hook_list *next, *n;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&netcp_priv->lock, flags);\n\tlist_for_each_entry_safe(next, n, &netcp_priv->rxhook_list_head, list) {\n\t\tif ((next->order     == order) &&\n\t\t    (next->hook_rtn  == hook_rtn) &&\n\t\t    (next->hook_data == hook_data)) {\n\t\t\tlist_del(&next->list);\n\t\t\tspin_unlock_irqrestore(&netcp_priv->lock, flags);\n\t\t\tdevm_kfree(netcp_priv->dev, next);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&netcp_priv->lock, flags);\n\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(netcp_unregister_rxhook);\n\nstatic void netcp_frag_free(bool is_frag, void *ptr)\n{\n\tif (is_frag)\n\t\tskb_free_frag(ptr);\n\telse\n\t\tkfree(ptr);\n}\n\nstatic void netcp_free_rx_desc_chain(struct netcp_intf *netcp,\n\t\t\t\t     struct knav_dma_desc *desc)\n{\n\tstruct knav_dma_desc *ndesc;\n\tdma_addr_t dma_desc, dma_buf;\n\tunsigned int buf_len, dma_sz = sizeof(*ndesc);\n\tvoid *buf_ptr;\n\tu32 tmp;\n\n\tget_words(&dma_desc, 1, &desc->next_desc);\n\n\twhile (dma_desc) {\n\t\tndesc = knav_pool_desc_unmap(netcp->rx_pool, dma_desc, dma_sz);\n\t\tif (unlikely(!ndesc)) {\n\t\t\tdev_err(netcp->ndev_dev, \"failed to unmap Rx desc\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tget_pkt_info(&dma_buf, &tmp, &dma_desc, ndesc);\n\t\t \n\t\tbuf_ptr = (void *)GET_SW_DATA0(ndesc);\n\t\tbuf_len = (int)GET_SW_DATA1(desc);\n\t\tdma_unmap_page(netcp->dev, dma_buf, PAGE_SIZE, DMA_FROM_DEVICE);\n\t\t__free_page(buf_ptr);\n\t\tknav_pool_desc_put(netcp->rx_pool, desc);\n\t}\n\t \n\tbuf_ptr = (void *)GET_SW_DATA0(desc);\n\tbuf_len = (int)GET_SW_DATA1(desc);\n\n\tif (buf_ptr)\n\t\tnetcp_frag_free(buf_len <= PAGE_SIZE, buf_ptr);\n\tknav_pool_desc_put(netcp->rx_pool, desc);\n}\n\nstatic void netcp_empty_rx_queue(struct netcp_intf *netcp)\n{\n\tstruct netcp_stats *rx_stats = &netcp->stats;\n\tstruct knav_dma_desc *desc;\n\tunsigned int dma_sz;\n\tdma_addr_t dma;\n\n\tfor (; ;) {\n\t\tdma = knav_queue_pop(netcp->rx_queue, &dma_sz);\n\t\tif (!dma)\n\t\t\tbreak;\n\n\t\tdesc = knav_pool_desc_unmap(netcp->rx_pool, dma, dma_sz);\n\t\tif (unlikely(!desc)) {\n\t\t\tdev_err(netcp->ndev_dev, \"%s: failed to unmap Rx desc\\n\",\n\t\t\t\t__func__);\n\t\t\trx_stats->rx_errors++;\n\t\t\tcontinue;\n\t\t}\n\t\tnetcp_free_rx_desc_chain(netcp, desc);\n\t\trx_stats->rx_dropped++;\n\t}\n}\n\nstatic int netcp_process_one_rx_packet(struct netcp_intf *netcp)\n{\n\tstruct netcp_stats *rx_stats = &netcp->stats;\n\tunsigned int dma_sz, buf_len, org_buf_len;\n\tstruct knav_dma_desc *desc, *ndesc;\n\tunsigned int pkt_sz = 0, accum_sz;\n\tstruct netcp_hook_list *rx_hook;\n\tdma_addr_t dma_desc, dma_buff;\n\tstruct netcp_packet p_info;\n\tstruct sk_buff *skb;\n\tvoid *org_buf_ptr;\n\tu32 tmp;\n\n\tdma_desc = knav_queue_pop(netcp->rx_queue, &dma_sz);\n\tif (!dma_desc)\n\t\treturn -1;\n\n\tdesc = knav_pool_desc_unmap(netcp->rx_pool, dma_desc, dma_sz);\n\tif (unlikely(!desc)) {\n\t\tdev_err(netcp->ndev_dev, \"failed to unmap Rx desc\\n\");\n\t\treturn 0;\n\t}\n\n\tget_pkt_info(&dma_buff, &buf_len, &dma_desc, desc);\n\t \n\torg_buf_ptr = (void *)GET_SW_DATA0(desc);\n\torg_buf_len = (int)GET_SW_DATA1(desc);\n\n\tif (unlikely(!org_buf_ptr)) {\n\t\tdev_err(netcp->ndev_dev, \"NULL bufptr in desc\\n\");\n\t\tgoto free_desc;\n\t}\n\n\tpkt_sz &= KNAV_DMA_DESC_PKT_LEN_MASK;\n\taccum_sz = buf_len;\n\tdma_unmap_single(netcp->dev, dma_buff, buf_len, DMA_FROM_DEVICE);\n\n\t \n\tskb = build_skb(org_buf_ptr, org_buf_len);\n\tif (unlikely(!skb)) {\n\t\tdev_err(netcp->ndev_dev, \"build_skb() failed\\n\");\n\t\tgoto free_desc;\n\t}\n\n\t \n\tskb_reserve(skb, NETCP_SOP_OFFSET);\n\t__skb_put(skb, buf_len);\n\n\t \n\twhile (dma_desc) {\n\t\tstruct page *page;\n\n\t\tndesc = knav_pool_desc_unmap(netcp->rx_pool, dma_desc, dma_sz);\n\t\tif (unlikely(!ndesc)) {\n\t\t\tdev_err(netcp->ndev_dev, \"failed to unmap Rx desc\\n\");\n\t\t\tgoto free_desc;\n\t\t}\n\n\t\tget_pkt_info(&dma_buff, &buf_len, &dma_desc, ndesc);\n\t\t \n\t\tpage = (struct page *)GET_SW_DATA0(ndesc);\n\n\t\tif (likely(dma_buff && buf_len && page)) {\n\t\t\tdma_unmap_page(netcp->dev, dma_buff, PAGE_SIZE,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\t} else {\n\t\t\tdev_err(netcp->ndev_dev, \"Bad Rx desc dma_buff(%pad), len(%d), page(%p)\\n\",\n\t\t\t\t&dma_buff, buf_len, page);\n\t\t\tgoto free_desc;\n\t\t}\n\n\t\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,\n\t\t\t\toffset_in_page(dma_buff), buf_len, PAGE_SIZE);\n\t\taccum_sz += buf_len;\n\n\t\t \n\t\tknav_pool_desc_put(netcp->rx_pool, ndesc);\n\t}\n\n\t \n\tif (unlikely(pkt_sz != accum_sz))\n\t\tdev_dbg(netcp->ndev_dev, \"mismatch in packet size(%d) & sum of fragments(%d)\\n\",\n\t\t\tpkt_sz, accum_sz);\n\n\t \n\tif (!(netcp->hw_cap & ETH_SW_CAN_REMOVE_ETH_FCS))\n\t\t__pskb_trim(skb, skb->len - ETH_FCS_LEN);\n\n\t \n\tp_info.skb = skb;\n\tskb->dev = netcp->ndev;\n\tp_info.rxtstamp_complete = false;\n\tget_desc_info(&tmp, &p_info.eflags, desc);\n\tp_info.epib = desc->epib;\n\tp_info.psdata = (u32 __force *)desc->psdata;\n\tp_info.eflags = ((p_info.eflags >> KNAV_DMA_DESC_EFLAGS_SHIFT) &\n\t\t\t KNAV_DMA_DESC_EFLAGS_MASK);\n\tlist_for_each_entry(rx_hook, &netcp->rxhook_list_head, list) {\n\t\tint ret;\n\n\t\tret = rx_hook->hook_rtn(rx_hook->order, rx_hook->hook_data,\n\t\t\t\t\t&p_info);\n\t\tif (unlikely(ret)) {\n\t\t\tdev_err(netcp->ndev_dev, \"RX hook %d failed: %d\\n\",\n\t\t\t\trx_hook->order, ret);\n\t\t\t \n\t\t\trx_stats->rx_dropped++;\n\t\t\tknav_pool_desc_put(netcp->rx_pool, desc);\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\tknav_pool_desc_put(netcp->rx_pool, desc);\n\n\tu64_stats_update_begin(&rx_stats->syncp_rx);\n\trx_stats->rx_packets++;\n\trx_stats->rx_bytes += skb->len;\n\tu64_stats_update_end(&rx_stats->syncp_rx);\n\n\t \n\tskb->protocol = eth_type_trans(skb, netcp->ndev);\n\tnetif_receive_skb(skb);\n\treturn 0;\n\nfree_desc:\n\tnetcp_free_rx_desc_chain(netcp, desc);\n\trx_stats->rx_errors++;\n\treturn 0;\n}\n\nstatic int netcp_process_rx_packets(struct netcp_intf *netcp,\n\t\t\t\t    unsigned int budget)\n{\n\tint i;\n\n\tfor (i = 0; (i < budget) && !netcp_process_one_rx_packet(netcp); i++)\n\t\t;\n\treturn i;\n}\n\n \nstatic void netcp_free_rx_buf(struct netcp_intf *netcp, int fdq)\n{\n\tstruct knav_dma_desc *desc;\n\tunsigned int buf_len, dma_sz;\n\tdma_addr_t dma;\n\tvoid *buf_ptr;\n\n\t \n\twhile ((dma = knav_queue_pop(netcp->rx_fdq[fdq], &dma_sz))) {\n\t\tdesc = knav_pool_desc_unmap(netcp->rx_pool, dma, dma_sz);\n\t\tif (unlikely(!desc)) {\n\t\t\tdev_err(netcp->ndev_dev, \"failed to unmap Rx desc\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tget_org_pkt_info(&dma, &buf_len, desc);\n\t\t \n\t\tbuf_ptr = (void *)GET_SW_DATA0(desc);\n\n\t\tif (unlikely(!dma)) {\n\t\t\tdev_err(netcp->ndev_dev, \"NULL orig_buff in desc\\n\");\n\t\t\tknav_pool_desc_put(netcp->rx_pool, desc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(!buf_ptr)) {\n\t\t\tdev_err(netcp->ndev_dev, \"NULL bufptr in desc\\n\");\n\t\t\tknav_pool_desc_put(netcp->rx_pool, desc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fdq == 0) {\n\t\t\tdma_unmap_single(netcp->dev, dma, buf_len,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tnetcp_frag_free((buf_len <= PAGE_SIZE), buf_ptr);\n\t\t} else {\n\t\t\tdma_unmap_page(netcp->dev, dma, buf_len,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\t__free_page(buf_ptr);\n\t\t}\n\n\t\tknav_pool_desc_put(netcp->rx_pool, desc);\n\t}\n}\n\nstatic void netcp_rxpool_free(struct netcp_intf *netcp)\n{\n\tint i;\n\n\tfor (i = 0; i < KNAV_DMA_FDQ_PER_CHAN &&\n\t     !IS_ERR_OR_NULL(netcp->rx_fdq[i]); i++)\n\t\tnetcp_free_rx_buf(netcp, i);\n\n\tif (knav_pool_count(netcp->rx_pool) != netcp->rx_pool_size)\n\t\tdev_err(netcp->ndev_dev, \"Lost Rx (%d) descriptors\\n\",\n\t\t\tnetcp->rx_pool_size - knav_pool_count(netcp->rx_pool));\n\n\tknav_pool_destroy(netcp->rx_pool);\n\tnetcp->rx_pool = NULL;\n}\n\nstatic int netcp_allocate_rx_buf(struct netcp_intf *netcp, int fdq)\n{\n\tstruct knav_dma_desc *hwdesc;\n\tunsigned int buf_len, dma_sz;\n\tu32 desc_info, pkt_info;\n\tstruct page *page;\n\tdma_addr_t dma;\n\tvoid *bufptr;\n\tu32 sw_data[2];\n\n\t \n\thwdesc = knav_pool_desc_get(netcp->rx_pool);\n\tif (IS_ERR_OR_NULL(hwdesc)) {\n\t\tdev_dbg(netcp->ndev_dev, \"out of rx pool desc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (likely(fdq == 0)) {\n\t\tunsigned int primary_buf_len;\n\t\t \n\t\tbuf_len = NETCP_PACKET_SIZE + NETCP_SOP_OFFSET;\n\t\tprimary_buf_len = SKB_DATA_ALIGN(buf_len) +\n\t\t\t\tSKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\n\t\tbufptr = netdev_alloc_frag(primary_buf_len);\n\t\tsw_data[1] = primary_buf_len;\n\n\t\tif (unlikely(!bufptr)) {\n\t\t\tdev_warn_ratelimited(netcp->ndev_dev,\n\t\t\t\t\t     \"Primary RX buffer alloc failed\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tdma = dma_map_single(netcp->dev, bufptr, buf_len,\n\t\t\t\t     DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(netcp->dev, dma)))\n\t\t\tgoto fail;\n\n\t\t \n\t\tsw_data[0] = (u32)bufptr;\n\t} else {\n\t\t \n\t\tpage = alloc_page(GFP_ATOMIC | GFP_DMA);\n\t\tif (unlikely(!page)) {\n\t\t\tdev_warn_ratelimited(netcp->ndev_dev, \"Secondary page alloc failed\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tbuf_len = PAGE_SIZE;\n\t\tdma = dma_map_page(netcp->dev, page, 0, buf_len, DMA_TO_DEVICE);\n\t\t \n\t\tsw_data[0] = (u32)page;\n\t\tsw_data[1] = 0;\n\t}\n\n\tdesc_info =  KNAV_DMA_DESC_PS_INFO_IN_DESC;\n\tdesc_info |= buf_len & KNAV_DMA_DESC_PKT_LEN_MASK;\n\tpkt_info =  KNAV_DMA_DESC_HAS_EPIB;\n\tpkt_info |= KNAV_DMA_NUM_PS_WORDS << KNAV_DMA_DESC_PSLEN_SHIFT;\n\tpkt_info |= (netcp->rx_queue_id & KNAV_DMA_DESC_RETQ_MASK) <<\n\t\t    KNAV_DMA_DESC_RETQ_SHIFT;\n\tset_org_pkt_info(dma, buf_len, hwdesc);\n\tSET_SW_DATA0(sw_data[0], hwdesc);\n\tSET_SW_DATA1(sw_data[1], hwdesc);\n\tset_desc_info(desc_info, pkt_info, hwdesc);\n\n\t \n\tknav_pool_desc_map(netcp->rx_pool, hwdesc, sizeof(*hwdesc), &dma,\n\t\t\t   &dma_sz);\n\tknav_queue_push(netcp->rx_fdq[fdq], dma, sizeof(*hwdesc), 0);\n\treturn 0;\n\nfail:\n\tknav_pool_desc_put(netcp->rx_pool, hwdesc);\n\treturn -ENOMEM;\n}\n\n \nstatic void netcp_rxpool_refill(struct netcp_intf *netcp)\n{\n\tu32 fdq_deficit[KNAV_DMA_FDQ_PER_CHAN] = {0};\n\tint i, ret = 0;\n\n\t \n\tfor (i = 0; i < KNAV_DMA_FDQ_PER_CHAN && netcp->rx_fdq[i]; i++) {\n\t\tfdq_deficit[i] = netcp->rx_queue_depths[i] -\n\t\t\t\t knav_queue_get_count(netcp->rx_fdq[i]);\n\n\t\twhile (fdq_deficit[i]-- && !ret)\n\t\t\tret = netcp_allocate_rx_buf(netcp, i);\n\t}  \n}\n\n \nstatic int netcp_rx_poll(struct napi_struct *napi, int budget)\n{\n\tstruct netcp_intf *netcp = container_of(napi, struct netcp_intf,\n\t\t\t\t\t\trx_napi);\n\tunsigned int packets;\n\n\tpackets = netcp_process_rx_packets(netcp, budget);\n\n\tnetcp_rxpool_refill(netcp);\n\tif (packets < budget) {\n\t\tnapi_complete_done(&netcp->rx_napi, packets);\n\t\tknav_queue_enable_notify(netcp->rx_queue);\n\t}\n\n\treturn packets;\n}\n\nstatic void netcp_rx_notify(void *arg)\n{\n\tstruct netcp_intf *netcp = arg;\n\n\tknav_queue_disable_notify(netcp->rx_queue);\n\tnapi_schedule(&netcp->rx_napi);\n}\n\nstatic void netcp_free_tx_desc_chain(struct netcp_intf *netcp,\n\t\t\t\t     struct knav_dma_desc *desc,\n\t\t\t\t     unsigned int desc_sz)\n{\n\tstruct knav_dma_desc *ndesc = desc;\n\tdma_addr_t dma_desc, dma_buf;\n\tunsigned int buf_len;\n\n\twhile (ndesc) {\n\t\tget_pkt_info(&dma_buf, &buf_len, &dma_desc, ndesc);\n\n\t\tif (dma_buf && buf_len)\n\t\t\tdma_unmap_single(netcp->dev, dma_buf, buf_len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\telse\n\t\t\tdev_warn(netcp->ndev_dev, \"bad Tx desc buf(%pad), len(%d)\\n\",\n\t\t\t\t &dma_buf, buf_len);\n\n\t\tknav_pool_desc_put(netcp->tx_pool, ndesc);\n\t\tndesc = NULL;\n\t\tif (dma_desc) {\n\t\t\tndesc = knav_pool_desc_unmap(netcp->tx_pool, dma_desc,\n\t\t\t\t\t\t     desc_sz);\n\t\t\tif (!ndesc)\n\t\t\t\tdev_err(netcp->ndev_dev, \"failed to unmap Tx desc\\n\");\n\t\t}\n\t}\n}\n\nstatic int netcp_process_tx_compl_packets(struct netcp_intf *netcp,\n\t\t\t\t\t  unsigned int budget)\n{\n\tstruct netcp_stats *tx_stats = &netcp->stats;\n\tstruct knav_dma_desc *desc;\n\tstruct netcp_tx_cb *tx_cb;\n\tstruct sk_buff *skb;\n\tunsigned int dma_sz;\n\tdma_addr_t dma;\n\tint pkts = 0;\n\n\twhile (budget--) {\n\t\tdma = knav_queue_pop(netcp->tx_compl_q, &dma_sz);\n\t\tif (!dma)\n\t\t\tbreak;\n\t\tdesc = knav_pool_desc_unmap(netcp->tx_pool, dma, dma_sz);\n\t\tif (unlikely(!desc)) {\n\t\t\tdev_err(netcp->ndev_dev, \"failed to unmap Tx desc\\n\");\n\t\t\ttx_stats->tx_errors++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tskb = (struct sk_buff *)GET_SW_DATA0(desc);\n\t\tnetcp_free_tx_desc_chain(netcp, desc, dma_sz);\n\t\tif (!skb) {\n\t\t\tdev_err(netcp->ndev_dev, \"No skb in Tx desc\\n\");\n\t\t\ttx_stats->tx_errors++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttx_cb = (struct netcp_tx_cb *)skb->cb;\n\t\tif (tx_cb->txtstamp)\n\t\t\ttx_cb->txtstamp(tx_cb->ts_context, skb);\n\n\t\tif (netif_subqueue_stopped(netcp->ndev, skb) &&\n\t\t    netif_running(netcp->ndev) &&\n\t\t    (knav_pool_count(netcp->tx_pool) >\n\t\t    netcp->tx_resume_threshold)) {\n\t\t\tu16 subqueue = skb_get_queue_mapping(skb);\n\n\t\t\tnetif_wake_subqueue(netcp->ndev, subqueue);\n\t\t}\n\n\t\tu64_stats_update_begin(&tx_stats->syncp_tx);\n\t\ttx_stats->tx_packets++;\n\t\ttx_stats->tx_bytes += skb->len;\n\t\tu64_stats_update_end(&tx_stats->syncp_tx);\n\t\tdev_kfree_skb(skb);\n\t\tpkts++;\n\t}\n\treturn pkts;\n}\n\nstatic int netcp_tx_poll(struct napi_struct *napi, int budget)\n{\n\tint packets;\n\tstruct netcp_intf *netcp = container_of(napi, struct netcp_intf,\n\t\t\t\t\t\ttx_napi);\n\n\tpackets = netcp_process_tx_compl_packets(netcp, budget);\n\tif (packets < budget) {\n\t\tnapi_complete(&netcp->tx_napi);\n\t\tknav_queue_enable_notify(netcp->tx_compl_q);\n\t}\n\n\treturn packets;\n}\n\nstatic void netcp_tx_notify(void *arg)\n{\n\tstruct netcp_intf *netcp = arg;\n\n\tknav_queue_disable_notify(netcp->tx_compl_q);\n\tnapi_schedule(&netcp->tx_napi);\n}\n\nstatic struct knav_dma_desc*\nnetcp_tx_map_skb(struct sk_buff *skb, struct netcp_intf *netcp)\n{\n\tstruct knav_dma_desc *desc, *ndesc, *pdesc;\n\tunsigned int pkt_len = skb_headlen(skb);\n\tstruct device *dev = netcp->dev;\n\tdma_addr_t dma_addr;\n\tunsigned int dma_sz;\n\tint i;\n\n\t \n\tdma_addr = dma_map_single(dev, skb->data, pkt_len, DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(dev, dma_addr))) {\n\t\tdev_err(netcp->ndev_dev, \"Failed to map skb buffer\\n\");\n\t\treturn NULL;\n\t}\n\n\tdesc = knav_pool_desc_get(netcp->tx_pool);\n\tif (IS_ERR_OR_NULL(desc)) {\n\t\tdev_err(netcp->ndev_dev, \"out of TX desc\\n\");\n\t\tdma_unmap_single(dev, dma_addr, pkt_len, DMA_TO_DEVICE);\n\t\treturn NULL;\n\t}\n\n\tset_pkt_info(dma_addr, pkt_len, 0, desc);\n\tif (skb_is_nonlinear(skb)) {\n\t\tprefetchw(skb_shinfo(skb));\n\t} else {\n\t\tdesc->next_desc = 0;\n\t\tgoto upd_pkt_len;\n\t}\n\n\tpdesc = desc;\n\n\t \n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tstruct page *page = skb_frag_page(frag);\n\t\tu32 page_offset = skb_frag_off(frag);\n\t\tu32 buf_len = skb_frag_size(frag);\n\t\tdma_addr_t desc_dma;\n\t\tu32 desc_dma_32;\n\n\t\tdma_addr = dma_map_page(dev, page, page_offset, buf_len,\n\t\t\t\t\tDMA_TO_DEVICE);\n\t\tif (unlikely(!dma_addr)) {\n\t\t\tdev_err(netcp->ndev_dev, \"Failed to map skb page\\n\");\n\t\t\tgoto free_descs;\n\t\t}\n\n\t\tndesc = knav_pool_desc_get(netcp->tx_pool);\n\t\tif (IS_ERR_OR_NULL(ndesc)) {\n\t\t\tdev_err(netcp->ndev_dev, \"out of TX desc for frags\\n\");\n\t\t\tdma_unmap_page(dev, dma_addr, buf_len, DMA_TO_DEVICE);\n\t\t\tgoto free_descs;\n\t\t}\n\n\t\tdesc_dma = knav_pool_desc_virt_to_dma(netcp->tx_pool, ndesc);\n\t\tset_pkt_info(dma_addr, buf_len, 0, ndesc);\n\t\tdesc_dma_32 = (u32)desc_dma;\n\t\tset_words(&desc_dma_32, 1, &pdesc->next_desc);\n\t\tpkt_len += buf_len;\n\t\tif (pdesc != desc)\n\t\t\tknav_pool_desc_map(netcp->tx_pool, pdesc,\n\t\t\t\t\t   sizeof(*pdesc), &desc_dma, &dma_sz);\n\t\tpdesc = ndesc;\n\t}\n\tif (pdesc != desc)\n\t\tknav_pool_desc_map(netcp->tx_pool, pdesc, sizeof(*pdesc),\n\t\t\t\t   &dma_addr, &dma_sz);\n\n\t \n\tif (skb_shinfo(skb)->frag_list) {\n\t\tdev_err_ratelimited(netcp->ndev_dev, \"NETIF_F_FRAGLIST not supported\\n\");\n\t\tgoto free_descs;\n\t}\n\nupd_pkt_len:\n\tWARN_ON(pkt_len != skb->len);\n\n\tpkt_len &= KNAV_DMA_DESC_PKT_LEN_MASK;\n\tset_words(&pkt_len, 1, &desc->desc_info);\n\treturn desc;\n\nfree_descs:\n\tnetcp_free_tx_desc_chain(netcp, desc, sizeof(*desc));\n\treturn NULL;\n}\n\nstatic int netcp_tx_submit_skb(struct netcp_intf *netcp,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct knav_dma_desc *desc)\n{\n\tstruct netcp_tx_pipe *tx_pipe = NULL;\n\tstruct netcp_hook_list *tx_hook;\n\tstruct netcp_packet p_info;\n\tstruct netcp_tx_cb *tx_cb;\n\tunsigned int dma_sz;\n\tdma_addr_t dma;\n\tu32 tmp = 0;\n\tint ret = 0;\n\n\tp_info.netcp = netcp;\n\tp_info.skb = skb;\n\tp_info.tx_pipe = NULL;\n\tp_info.psdata_len = 0;\n\tp_info.ts_context = NULL;\n\tp_info.txtstamp = NULL;\n\tp_info.epib = desc->epib;\n\tp_info.psdata = (u32 __force *)desc->psdata;\n\tmemset(p_info.epib, 0, KNAV_DMA_NUM_EPIB_WORDS * sizeof(__le32));\n\n\t \n\tlist_for_each_entry(tx_hook, &netcp->txhook_list_head, list) {\n\t\tret = tx_hook->hook_rtn(tx_hook->order, tx_hook->hook_data,\n\t\t\t\t\t&p_info);\n\t\tif (unlikely(ret != 0)) {\n\t\t\tdev_err(netcp->ndev_dev, \"TX hook %d rejected the packet with reason(%d)\\n\",\n\t\t\t\ttx_hook->order, ret);\n\t\t\tret = (ret < 0) ? ret : NETDEV_TX_OK;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\ttx_pipe = p_info.tx_pipe;\n\tif (!tx_pipe) {\n\t\tdev_err(netcp->ndev_dev, \"No TX hook claimed the packet!\\n\");\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\ttx_cb = (struct netcp_tx_cb *)skb->cb;\n\ttx_cb->ts_context = p_info.ts_context;\n\ttx_cb->txtstamp = p_info.txtstamp;\n\n\t \n\tif (p_info.psdata_len) {\n\t\t \n\t\t__le32 *psdata = (void __force *)p_info.psdata;\n\n\t\tset_words((u32 *)psdata +\n\t\t\t  (KNAV_DMA_NUM_PS_WORDS - p_info.psdata_len),\n\t\t\t  p_info.psdata_len, psdata);\n\t\ttmp |= (p_info.psdata_len & KNAV_DMA_DESC_PSLEN_MASK) <<\n\t\t\tKNAV_DMA_DESC_PSLEN_SHIFT;\n\t}\n\n\ttmp |= KNAV_DMA_DESC_HAS_EPIB |\n\t\t((netcp->tx_compl_qid & KNAV_DMA_DESC_RETQ_MASK) <<\n\t\tKNAV_DMA_DESC_RETQ_SHIFT);\n\n\tif (!(tx_pipe->flags & SWITCH_TO_PORT_IN_TAGINFO)) {\n\t\ttmp |= ((tx_pipe->switch_to_port & KNAV_DMA_DESC_PSFLAG_MASK) <<\n\t\t\tKNAV_DMA_DESC_PSFLAG_SHIFT);\n\t}\n\n\tset_words(&tmp, 1, &desc->packet_info);\n\t \n\tSET_SW_DATA0((u32)skb, desc);\n\n\tif (tx_pipe->flags & SWITCH_TO_PORT_IN_TAGINFO) {\n\t\ttmp = tx_pipe->switch_to_port;\n\t\tset_words(&tmp, 1, &desc->tag_info);\n\t}\n\n\t \n\tret = knav_pool_desc_map(netcp->tx_pool, desc, sizeof(*desc), &dma,\n\t\t\t\t &dma_sz);\n\tif (unlikely(ret)) {\n\t\tdev_err(netcp->ndev_dev, \"%s() failed to map desc\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tskb_tx_timestamp(skb);\n\tknav_queue_push(tx_pipe->dma_queue, dma, dma_sz, 0);\n\nout:\n\treturn ret;\n}\n\n \nstatic netdev_tx_t netcp_ndo_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct netcp_stats *tx_stats = &netcp->stats;\n\tint subqueue = skb_get_queue_mapping(skb);\n\tstruct knav_dma_desc *desc;\n\tint desc_count, ret = 0;\n\n\tif (unlikely(skb->len <= 0)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (unlikely(skb->len < NETCP_MIN_PACKET_SIZE)) {\n\t\tret = skb_padto(skb, NETCP_MIN_PACKET_SIZE);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tdev_warn(netcp->ndev_dev, \"padding failed (%d), packet dropped\\n\",\n\t\t\t\t ret);\n\t\t\ttx_stats->tx_dropped++;\n\t\t\treturn ret;\n\t\t}\n\t\tskb->len = NETCP_MIN_PACKET_SIZE;\n\t}\n\n\tdesc = netcp_tx_map_skb(skb, netcp);\n\tif (unlikely(!desc)) {\n\t\tnetif_stop_subqueue(ndev, subqueue);\n\t\tret = -ENOBUFS;\n\t\tgoto drop;\n\t}\n\n\tret = netcp_tx_submit_skb(netcp, skb, desc);\n\tif (ret)\n\t\tgoto drop;\n\n\t \n\tdesc_count = knav_pool_count(netcp->tx_pool);\n\tif (desc_count < netcp->tx_pause_threshold) {\n\t\tdev_dbg(netcp->ndev_dev, \"pausing tx, count(%d)\\n\", desc_count);\n\t\tnetif_stop_subqueue(ndev, subqueue);\n\t}\n\treturn NETDEV_TX_OK;\n\ndrop:\n\ttx_stats->tx_dropped++;\n\tif (desc)\n\t\tnetcp_free_tx_desc_chain(netcp, desc, sizeof(*desc));\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nint netcp_txpipe_close(struct netcp_tx_pipe *tx_pipe)\n{\n\tif (tx_pipe->dma_channel) {\n\t\tknav_dma_close_channel(tx_pipe->dma_channel);\n\t\ttx_pipe->dma_channel = NULL;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(netcp_txpipe_close);\n\nint netcp_txpipe_open(struct netcp_tx_pipe *tx_pipe)\n{\n\tstruct device *dev = tx_pipe->netcp_device->device;\n\tstruct knav_dma_cfg config;\n\tint ret = 0;\n\tu8 name[16];\n\n\tmemset(&config, 0, sizeof(config));\n\tconfig.direction = DMA_MEM_TO_DEV;\n\tconfig.u.tx.filt_einfo = false;\n\tconfig.u.tx.filt_pswords = false;\n\tconfig.u.tx.priority = DMA_PRIO_MED_L;\n\n\ttx_pipe->dma_channel = knav_dma_open_channel(dev,\n\t\t\t\ttx_pipe->dma_chan_name, &config);\n\tif (IS_ERR(tx_pipe->dma_channel)) {\n\t\tdev_err(dev, \"failed opening tx chan(%s)\\n\",\n\t\t\ttx_pipe->dma_chan_name);\n\t\tret = PTR_ERR(tx_pipe->dma_channel);\n\t\tgoto err;\n\t}\n\n\tsnprintf(name, sizeof(name), \"tx-pipe-%s\", dev_name(dev));\n\ttx_pipe->dma_queue = knav_queue_open(name, tx_pipe->dma_queue_id,\n\t\t\t\t\t     KNAV_QUEUE_SHARED);\n\tif (IS_ERR(tx_pipe->dma_queue)) {\n\t\tdev_err(dev, \"Could not open DMA queue for channel \\\"%s\\\": %pe\\n\",\n\t\t\tname, tx_pipe->dma_queue);\n\t\tret = PTR_ERR(tx_pipe->dma_queue);\n\t\tgoto err;\n\t}\n\n\tdev_dbg(dev, \"opened tx pipe %s\\n\", name);\n\treturn 0;\n\nerr:\n\tif (!IS_ERR_OR_NULL(tx_pipe->dma_channel))\n\t\tknav_dma_close_channel(tx_pipe->dma_channel);\n\ttx_pipe->dma_channel = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(netcp_txpipe_open);\n\nint netcp_txpipe_init(struct netcp_tx_pipe *tx_pipe,\n\t\t      struct netcp_device *netcp_device,\n\t\t      const char *dma_chan_name, unsigned int dma_queue_id)\n{\n\tmemset(tx_pipe, 0, sizeof(*tx_pipe));\n\ttx_pipe->netcp_device = netcp_device;\n\ttx_pipe->dma_chan_name = dma_chan_name;\n\ttx_pipe->dma_queue_id = dma_queue_id;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(netcp_txpipe_init);\n\nstatic struct netcp_addr *netcp_addr_find(struct netcp_intf *netcp,\n\t\t\t\t\t  const u8 *addr,\n\t\t\t\t\t  enum netcp_addr_type type)\n{\n\tstruct netcp_addr *naddr;\n\n\tlist_for_each_entry(naddr, &netcp->addr_list, node) {\n\t\tif (naddr->type != type)\n\t\t\tcontinue;\n\t\tif (addr && memcmp(addr, naddr->addr, ETH_ALEN))\n\t\t\tcontinue;\n\t\treturn naddr;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct netcp_addr *netcp_addr_add(struct netcp_intf *netcp,\n\t\t\t\t\t const u8 *addr,\n\t\t\t\t\t enum netcp_addr_type type)\n{\n\tstruct netcp_addr *naddr;\n\n\tnaddr = devm_kmalloc(netcp->dev, sizeof(*naddr), GFP_ATOMIC);\n\tif (!naddr)\n\t\treturn NULL;\n\n\tnaddr->type = type;\n\tnaddr->flags = 0;\n\tnaddr->netcp = netcp;\n\tif (addr)\n\t\tether_addr_copy(naddr->addr, addr);\n\telse\n\t\teth_zero_addr(naddr->addr);\n\tlist_add_tail(&naddr->node, &netcp->addr_list);\n\n\treturn naddr;\n}\n\nstatic void netcp_addr_del(struct netcp_intf *netcp, struct netcp_addr *naddr)\n{\n\tlist_del(&naddr->node);\n\tdevm_kfree(netcp->dev, naddr);\n}\n\nstatic void netcp_addr_clear_mark(struct netcp_intf *netcp)\n{\n\tstruct netcp_addr *naddr;\n\n\tlist_for_each_entry(naddr, &netcp->addr_list, node)\n\t\tnaddr->flags = 0;\n}\n\nstatic void netcp_addr_add_mark(struct netcp_intf *netcp, const u8 *addr,\n\t\t\t\tenum netcp_addr_type type)\n{\n\tstruct netcp_addr *naddr;\n\n\tnaddr = netcp_addr_find(netcp, addr, type);\n\tif (naddr) {\n\t\tnaddr->flags |= ADDR_VALID;\n\t\treturn;\n\t}\n\n\tnaddr = netcp_addr_add(netcp, addr, type);\n\tif (!WARN_ON(!naddr))\n\t\tnaddr->flags |= ADDR_NEW;\n}\n\nstatic void netcp_addr_sweep_del(struct netcp_intf *netcp)\n{\n\tstruct netcp_addr *naddr, *tmp;\n\tstruct netcp_intf_modpriv *priv;\n\tstruct netcp_module *module;\n\tint error;\n\n\tlist_for_each_entry_safe(naddr, tmp, &netcp->addr_list, node) {\n\t\tif (naddr->flags & (ADDR_VALID | ADDR_NEW))\n\t\t\tcontinue;\n\t\tdev_dbg(netcp->ndev_dev, \"deleting address %pM, type %x\\n\",\n\t\t\tnaddr->addr, naddr->type);\n\t\tfor_each_module(netcp, priv) {\n\t\t\tmodule = priv->netcp_module;\n\t\t\tif (!module->del_addr)\n\t\t\t\tcontinue;\n\t\t\terror = module->del_addr(priv->module_priv,\n\t\t\t\t\t\t naddr);\n\t\t\tWARN_ON(error);\n\t\t}\n\t\tnetcp_addr_del(netcp, naddr);\n\t}\n}\n\nstatic void netcp_addr_sweep_add(struct netcp_intf *netcp)\n{\n\tstruct netcp_addr *naddr, *tmp;\n\tstruct netcp_intf_modpriv *priv;\n\tstruct netcp_module *module;\n\tint error;\n\n\tlist_for_each_entry_safe(naddr, tmp, &netcp->addr_list, node) {\n\t\tif (!(naddr->flags & ADDR_NEW))\n\t\t\tcontinue;\n\t\tdev_dbg(netcp->ndev_dev, \"adding address %pM, type %x\\n\",\n\t\t\tnaddr->addr, naddr->type);\n\n\t\tfor_each_module(netcp, priv) {\n\t\t\tmodule = priv->netcp_module;\n\t\t\tif (!module->add_addr)\n\t\t\t\tcontinue;\n\t\t\terror = module->add_addr(priv->module_priv, naddr);\n\t\t\tWARN_ON(error);\n\t\t}\n\t}\n}\n\nstatic int netcp_set_promiscuous(struct netcp_intf *netcp, bool promisc)\n{\n\tstruct netcp_intf_modpriv *priv;\n\tstruct netcp_module *module;\n\tint error;\n\n\tfor_each_module(netcp, priv) {\n\t\tmodule = priv->netcp_module;\n\t\tif (!module->set_rx_mode)\n\t\t\tcontinue;\n\n\t\terror = module->set_rx_mode(priv->module_priv, promisc);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}\n\nstatic void netcp_set_rx_mode(struct net_device *ndev)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct netdev_hw_addr *ndev_addr;\n\tbool promisc;\n\n\tpromisc = (ndev->flags & IFF_PROMISC ||\n\t\t   ndev->flags & IFF_ALLMULTI ||\n\t\t   netdev_mc_count(ndev) > NETCP_MAX_MCAST_ADDR);\n\n\tspin_lock(&netcp->lock);\n\t \n\tnetcp_addr_clear_mark(netcp);\n\n\t \n\tnetcp_addr_add_mark(netcp, ndev->broadcast, ADDR_BCAST);\n\tfor_each_dev_addr(ndev, ndev_addr)\n\t\tnetcp_addr_add_mark(netcp, ndev_addr->addr, ADDR_DEV);\n\tnetdev_for_each_uc_addr(ndev_addr, ndev)\n\t\tnetcp_addr_add_mark(netcp, ndev_addr->addr, ADDR_UCAST);\n\tnetdev_for_each_mc_addr(ndev_addr, ndev)\n\t\tnetcp_addr_add_mark(netcp, ndev_addr->addr, ADDR_MCAST);\n\n\tif (promisc)\n\t\tnetcp_addr_add_mark(netcp, NULL, ADDR_ANY);\n\n\t \n\tnetcp_addr_sweep_del(netcp);\n\tnetcp_addr_sweep_add(netcp);\n\tnetcp_set_promiscuous(netcp, promisc);\n\tspin_unlock(&netcp->lock);\n}\n\nstatic void netcp_free_navigator_resources(struct netcp_intf *netcp)\n{\n\tint i;\n\n\tif (netcp->rx_channel) {\n\t\tknav_dma_close_channel(netcp->rx_channel);\n\t\tnetcp->rx_channel = NULL;\n\t}\n\n\tif (!IS_ERR_OR_NULL(netcp->rx_pool))\n\t\tnetcp_rxpool_free(netcp);\n\n\tif (!IS_ERR_OR_NULL(netcp->rx_queue)) {\n\t\tknav_queue_close(netcp->rx_queue);\n\t\tnetcp->rx_queue = NULL;\n\t}\n\n\tfor (i = 0; i < KNAV_DMA_FDQ_PER_CHAN &&\n\t     !IS_ERR_OR_NULL(netcp->rx_fdq[i]) ; ++i) {\n\t\tknav_queue_close(netcp->rx_fdq[i]);\n\t\tnetcp->rx_fdq[i] = NULL;\n\t}\n\n\tif (!IS_ERR_OR_NULL(netcp->tx_compl_q)) {\n\t\tknav_queue_close(netcp->tx_compl_q);\n\t\tnetcp->tx_compl_q = NULL;\n\t}\n\n\tif (!IS_ERR_OR_NULL(netcp->tx_pool)) {\n\t\tknav_pool_destroy(netcp->tx_pool);\n\t\tnetcp->tx_pool = NULL;\n\t}\n}\n\nstatic int netcp_setup_navigator_resources(struct net_device *ndev)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct knav_queue_notify_config notify_cfg;\n\tstruct knav_dma_cfg config;\n\tu32 last_fdq = 0;\n\tu8 name[16];\n\tint ret;\n\tint i;\n\n\t \n\tsnprintf(name, sizeof(name), \"rx-pool-%s\", ndev->name);\n\tnetcp->rx_pool = knav_pool_create(name, netcp->rx_pool_size,\n\t\t\t\t\t\tnetcp->rx_pool_region_id);\n\tif (IS_ERR_OR_NULL(netcp->rx_pool)) {\n\t\tdev_err(netcp->ndev_dev, \"Couldn't create rx pool\\n\");\n\t\tret = PTR_ERR(netcp->rx_pool);\n\t\tgoto fail;\n\t}\n\n\tsnprintf(name, sizeof(name), \"tx-pool-%s\", ndev->name);\n\tnetcp->tx_pool = knav_pool_create(name, netcp->tx_pool_size,\n\t\t\t\t\t\tnetcp->tx_pool_region_id);\n\tif (IS_ERR_OR_NULL(netcp->tx_pool)) {\n\t\tdev_err(netcp->ndev_dev, \"Couldn't create tx pool\\n\");\n\t\tret = PTR_ERR(netcp->tx_pool);\n\t\tgoto fail;\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), \"tx-compl-%s\", ndev->name);\n\tnetcp->tx_compl_q = knav_queue_open(name, netcp->tx_compl_qid, 0);\n\tif (IS_ERR(netcp->tx_compl_q)) {\n\t\tret = PTR_ERR(netcp->tx_compl_q);\n\t\tgoto fail;\n\t}\n\tnetcp->tx_compl_qid = knav_queue_get_id(netcp->tx_compl_q);\n\n\t \n\tnotify_cfg.fn = netcp_tx_notify;\n\tnotify_cfg.fn_arg = netcp;\n\tret = knav_queue_device_control(netcp->tx_compl_q,\n\t\t\t\t\tKNAV_QUEUE_SET_NOTIFIER,\n\t\t\t\t\t(unsigned long)&notify_cfg);\n\tif (ret)\n\t\tgoto fail;\n\n\tknav_queue_disable_notify(netcp->tx_compl_q);\n\n\t \n\tsnprintf(name, sizeof(name), \"rx-compl-%s\", ndev->name);\n\tnetcp->rx_queue = knav_queue_open(name, netcp->rx_queue_id, 0);\n\tif (IS_ERR(netcp->rx_queue)) {\n\t\tret = PTR_ERR(netcp->rx_queue);\n\t\tgoto fail;\n\t}\n\tnetcp->rx_queue_id = knav_queue_get_id(netcp->rx_queue);\n\n\t \n\tnotify_cfg.fn = netcp_rx_notify;\n\tnotify_cfg.fn_arg = netcp;\n\tret = knav_queue_device_control(netcp->rx_queue,\n\t\t\t\t\tKNAV_QUEUE_SET_NOTIFIER,\n\t\t\t\t\t(unsigned long)&notify_cfg);\n\tif (ret)\n\t\tgoto fail;\n\n\tknav_queue_disable_notify(netcp->rx_queue);\n\n\t \n\tfor (i = 0; i < KNAV_DMA_FDQ_PER_CHAN && netcp->rx_queue_depths[i];\n\t     ++i) {\n\t\tsnprintf(name, sizeof(name), \"rx-fdq-%s-%d\", ndev->name, i);\n\t\tnetcp->rx_fdq[i] = knav_queue_open(name, KNAV_QUEUE_GP, 0);\n\t\tif (IS_ERR(netcp->rx_fdq[i])) {\n\t\t\tret = PTR_ERR(netcp->rx_fdq[i]);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tmemset(&config, 0, sizeof(config));\n\tconfig.direction\t\t= DMA_DEV_TO_MEM;\n\tconfig.u.rx.einfo_present\t= true;\n\tconfig.u.rx.psinfo_present\t= true;\n\tconfig.u.rx.err_mode\t\t= DMA_DROP;\n\tconfig.u.rx.desc_type\t\t= DMA_DESC_HOST;\n\tconfig.u.rx.psinfo_at_sop\t= false;\n\tconfig.u.rx.sop_offset\t\t= NETCP_SOP_OFFSET;\n\tconfig.u.rx.dst_q\t\t= netcp->rx_queue_id;\n\tconfig.u.rx.thresh\t\t= DMA_THRESH_NONE;\n\n\tfor (i = 0; i < KNAV_DMA_FDQ_PER_CHAN; ++i) {\n\t\tif (netcp->rx_fdq[i])\n\t\t\tlast_fdq = knav_queue_get_id(netcp->rx_fdq[i]);\n\t\tconfig.u.rx.fdq[i] = last_fdq;\n\t}\n\n\tnetcp->rx_channel = knav_dma_open_channel(netcp->netcp_device->device,\n\t\t\t\t\tnetcp->dma_chan_name, &config);\n\tif (IS_ERR(netcp->rx_channel)) {\n\t\tdev_err(netcp->ndev_dev, \"failed opening rx chan(%s\\n\",\n\t\t\tnetcp->dma_chan_name);\n\t\tret = PTR_ERR(netcp->rx_channel);\n\t\tgoto fail;\n\t}\n\n\tdev_dbg(netcp->ndev_dev, \"opened RX channel: %p\\n\", netcp->rx_channel);\n\treturn 0;\n\nfail:\n\tnetcp_free_navigator_resources(netcp);\n\treturn ret;\n}\n\n \nstatic int netcp_ndo_open(struct net_device *ndev)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct netcp_intf_modpriv *intf_modpriv;\n\tstruct netcp_module *module;\n\tint ret;\n\n\tnetif_carrier_off(ndev);\n\tret = netcp_setup_navigator_resources(ndev);\n\tif (ret) {\n\t\tdev_err(netcp->ndev_dev, \"Failed to setup navigator resources\\n\");\n\t\tgoto fail;\n\t}\n\n\tfor_each_module(netcp, intf_modpriv) {\n\t\tmodule = intf_modpriv->netcp_module;\n\t\tif (module->open) {\n\t\t\tret = module->open(intf_modpriv->module_priv, ndev);\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(netcp->ndev_dev, \"module open failed\\n\");\n\t\t\t\tgoto fail_open;\n\t\t\t}\n\t\t}\n\t}\n\n\tnapi_enable(&netcp->rx_napi);\n\tnapi_enable(&netcp->tx_napi);\n\tknav_queue_enable_notify(netcp->tx_compl_q);\n\tknav_queue_enable_notify(netcp->rx_queue);\n\tnetcp_rxpool_refill(netcp);\n\tnetif_tx_wake_all_queues(ndev);\n\tdev_dbg(netcp->ndev_dev, \"netcp device %s opened\\n\", ndev->name);\n\treturn 0;\n\nfail_open:\n\tfor_each_module(netcp, intf_modpriv) {\n\t\tmodule = intf_modpriv->netcp_module;\n\t\tif (module->close)\n\t\t\tmodule->close(intf_modpriv->module_priv, ndev);\n\t}\n\nfail:\n\tnetcp_free_navigator_resources(netcp);\n\treturn ret;\n}\n\n \nstatic int netcp_ndo_stop(struct net_device *ndev)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct netcp_intf_modpriv *intf_modpriv;\n\tstruct netcp_module *module;\n\tint err = 0;\n\n\tnetif_tx_stop_all_queues(ndev);\n\tnetif_carrier_off(ndev);\n\tnetcp_addr_clear_mark(netcp);\n\tnetcp_addr_sweep_del(netcp);\n\tknav_queue_disable_notify(netcp->rx_queue);\n\tknav_queue_disable_notify(netcp->tx_compl_q);\n\tnapi_disable(&netcp->rx_napi);\n\tnapi_disable(&netcp->tx_napi);\n\n\tfor_each_module(netcp, intf_modpriv) {\n\t\tmodule = intf_modpriv->netcp_module;\n\t\tif (module->close) {\n\t\t\terr = module->close(intf_modpriv->module_priv, ndev);\n\t\t\tif (err != 0)\n\t\t\t\tdev_err(netcp->ndev_dev, \"Close failed\\n\");\n\t\t}\n\t}\n\n\t \n\tnetcp_empty_rx_queue(netcp);\n\n\t \n\tnetcp_process_tx_compl_packets(netcp, netcp->tx_pool_size);\n\n\tif (knav_pool_count(netcp->tx_pool) != netcp->tx_pool_size)\n\t\tdev_err(netcp->ndev_dev, \"Lost (%d) Tx descs\\n\",\n\t\t\tnetcp->tx_pool_size - knav_pool_count(netcp->tx_pool));\n\n\tnetcp_free_navigator_resources(netcp);\n\tdev_dbg(netcp->ndev_dev, \"netcp device %s stopped\\n\", ndev->name);\n\treturn 0;\n}\n\nstatic int netcp_ndo_ioctl(struct net_device *ndev,\n\t\t\t   struct ifreq *req, int cmd)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct netcp_intf_modpriv *intf_modpriv;\n\tstruct netcp_module *module;\n\tint ret = -1, err = -EOPNOTSUPP;\n\n\tif (!netif_running(ndev))\n\t\treturn -EINVAL;\n\n\tfor_each_module(netcp, intf_modpriv) {\n\t\tmodule = intf_modpriv->netcp_module;\n\t\tif (!module->ioctl)\n\t\t\tcontinue;\n\n\t\terr = module->ioctl(intf_modpriv->module_priv, req, cmd);\n\t\tif ((err < 0) && (err != -EOPNOTSUPP)) {\n\t\t\tret = err;\n\t\t\tgoto out;\n\t\t}\n\t\tif (err == 0)\n\t\t\tret = err;\n\t}\n\nout:\n\treturn (ret == 0) ? 0 : err;\n}\n\nstatic void netcp_ndo_tx_timeout(struct net_device *ndev, unsigned int txqueue)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tunsigned int descs = knav_pool_count(netcp->tx_pool);\n\n\tdev_err(netcp->ndev_dev, \"transmit timed out tx descs(%d)\\n\", descs);\n\tnetcp_process_tx_compl_packets(netcp, netcp->tx_pool_size);\n\tnetif_trans_update(ndev);\n\tnetif_tx_wake_all_queues(ndev);\n}\n\nstatic int netcp_rx_add_vid(struct net_device *ndev, __be16 proto, u16 vid)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct netcp_intf_modpriv *intf_modpriv;\n\tstruct netcp_module *module;\n\tunsigned long flags;\n\tint err = 0;\n\n\tdev_dbg(netcp->ndev_dev, \"adding rx vlan id: %d\\n\", vid);\n\n\tspin_lock_irqsave(&netcp->lock, flags);\n\tfor_each_module(netcp, intf_modpriv) {\n\t\tmodule = intf_modpriv->netcp_module;\n\t\tif ((module->add_vid) && (vid != 0)) {\n\t\t\terr = module->add_vid(intf_modpriv->module_priv, vid);\n\t\t\tif (err != 0) {\n\t\t\t\tdev_err(netcp->ndev_dev, \"Could not add vlan id = %d\\n\",\n\t\t\t\t\tvid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&netcp->lock, flags);\n\n\treturn err;\n}\n\nstatic int netcp_rx_kill_vid(struct net_device *ndev, __be16 proto, u16 vid)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct netcp_intf_modpriv *intf_modpriv;\n\tstruct netcp_module *module;\n\tunsigned long flags;\n\tint err = 0;\n\n\tdev_dbg(netcp->ndev_dev, \"removing rx vlan id: %d\\n\", vid);\n\n\tspin_lock_irqsave(&netcp->lock, flags);\n\tfor_each_module(netcp, intf_modpriv) {\n\t\tmodule = intf_modpriv->netcp_module;\n\t\tif (module->del_vid) {\n\t\t\terr = module->del_vid(intf_modpriv->module_priv, vid);\n\t\t\tif (err != 0) {\n\t\t\t\tdev_err(netcp->ndev_dev, \"Could not delete vlan id = %d\\n\",\n\t\t\t\t\tvid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&netcp->lock, flags);\n\treturn err;\n}\n\nstatic int netcp_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t\t  void *type_data)\n{\n\tstruct tc_mqprio_qopt *mqprio = type_data;\n\tu8 num_tc;\n\tint i;\n\n\t \n\tASSERT_RTNL();\n\n\tif (type != TC_SETUP_QDISC_MQPRIO)\n\t\treturn -EOPNOTSUPP;\n\n\tmqprio->hw = TC_MQPRIO_HW_OFFLOAD_TCS;\n\tnum_tc = mqprio->num_tc;\n\n\t \n\tif ((dev->real_num_tx_queues <= 1) ||\n\t    (dev->real_num_tx_queues < num_tc))\n\t\treturn -EINVAL;\n\n\t \n\tif (num_tc) {\n\t\tnetdev_set_num_tc(dev, num_tc);\n\t\tfor (i = 0; i < num_tc; i++)\n\t\t\tnetdev_set_tc_queue(dev, i, 1, i);\n\t} else {\n\t\tnetdev_reset_tc(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnetcp_get_stats(struct net_device *ndev, struct rtnl_link_stats64 *stats)\n{\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct netcp_stats *p = &netcp->stats;\n\tu64 rxpackets, rxbytes, txpackets, txbytes;\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&p->syncp_rx);\n\t\trxpackets       = p->rx_packets;\n\t\trxbytes         = p->rx_bytes;\n\t} while (u64_stats_fetch_retry(&p->syncp_rx, start));\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&p->syncp_tx);\n\t\ttxpackets       = p->tx_packets;\n\t\ttxbytes         = p->tx_bytes;\n\t} while (u64_stats_fetch_retry(&p->syncp_tx, start));\n\n\tstats->rx_packets = rxpackets;\n\tstats->rx_bytes = rxbytes;\n\tstats->tx_packets = txpackets;\n\tstats->tx_bytes = txbytes;\n\n\t \n\tstats->rx_errors = p->rx_errors;\n\tstats->rx_dropped = p->rx_dropped;\n\tstats->tx_dropped = p->tx_dropped;\n}\n\nstatic const struct net_device_ops netcp_netdev_ops = {\n\t.ndo_open\t\t= netcp_ndo_open,\n\t.ndo_stop\t\t= netcp_ndo_stop,\n\t.ndo_start_xmit\t\t= netcp_ndo_start_xmit,\n\t.ndo_set_rx_mode\t= netcp_set_rx_mode,\n\t.ndo_eth_ioctl           = netcp_ndo_ioctl,\n\t.ndo_get_stats64        = netcp_get_stats,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_vlan_rx_add_vid\t= netcp_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= netcp_rx_kill_vid,\n\t.ndo_tx_timeout\t\t= netcp_ndo_tx_timeout,\n\t.ndo_select_queue\t= dev_pick_tx_zero,\n\t.ndo_setup_tc\t\t= netcp_setup_tc,\n};\n\nstatic int netcp_create_interface(struct netcp_device *netcp_device,\n\t\t\t\t  struct device_node *node_interface)\n{\n\tstruct device *dev = netcp_device->device;\n\tstruct device_node *node = dev->of_node;\n\tstruct netcp_intf *netcp;\n\tstruct net_device *ndev;\n\tresource_size_t size;\n\tstruct resource res;\n\tvoid __iomem *efuse = NULL;\n\tu32 efuse_mac = 0;\n\tu8 efuse_mac_addr[6];\n\tu32 temp[2];\n\tint ret = 0;\n\n\tndev = alloc_etherdev_mqs(sizeof(*netcp), 1, 1);\n\tif (!ndev) {\n\t\tdev_err(dev, \"Error allocating netdev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tndev->features |= NETIF_F_SG;\n\tndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\tndev->hw_features = ndev->features;\n\tndev->vlan_features |=  NETIF_F_SG;\n\n\t \n\tndev->min_mtu = ETH_MIN_MTU;\n\tndev->max_mtu = NETCP_MAX_FRAME_SIZE - (ETH_HLEN + ETH_FCS_LEN);\n\n\tnetcp = netdev_priv(ndev);\n\tspin_lock_init(&netcp->lock);\n\tINIT_LIST_HEAD(&netcp->module_head);\n\tINIT_LIST_HEAD(&netcp->txhook_list_head);\n\tINIT_LIST_HEAD(&netcp->rxhook_list_head);\n\tINIT_LIST_HEAD(&netcp->addr_list);\n\tu64_stats_init(&netcp->stats.syncp_rx);\n\tu64_stats_init(&netcp->stats.syncp_tx);\n\tnetcp->netcp_device = netcp_device;\n\tnetcp->dev = netcp_device->device;\n\tnetcp->ndev = ndev;\n\tnetcp->ndev_dev  = &ndev->dev;\n\tnetcp->msg_enable = netif_msg_init(netcp_debug_level, NETCP_DEBUG);\n\tnetcp->tx_pause_threshold = MAX_SKB_FRAGS;\n\tnetcp->tx_resume_threshold = netcp->tx_pause_threshold;\n\tnetcp->node_interface = node_interface;\n\n\tret = of_property_read_u32(node_interface, \"efuse-mac\", &efuse_mac);\n\tif (efuse_mac) {\n\t\tif (of_address_to_resource(node, NETCP_EFUSE_REG_INDEX, &res)) {\n\t\t\tdev_err(dev, \"could not find efuse-mac reg resource\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto quit;\n\t\t}\n\t\tsize = resource_size(&res);\n\n\t\tif (!devm_request_mem_region(dev, res.start, size,\n\t\t\t\t\t     dev_name(dev))) {\n\t\t\tdev_err(dev, \"could not reserve resource\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto quit;\n\t\t}\n\n\t\tefuse = devm_ioremap(dev, res.start, size);\n\t\tif (!efuse) {\n\t\t\tdev_err(dev, \"could not map resource\\n\");\n\t\t\tdevm_release_mem_region(dev, res.start, size);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto quit;\n\t\t}\n\n\t\temac_arch_get_mac_addr(efuse_mac_addr, efuse, efuse_mac);\n\t\tif (is_valid_ether_addr(efuse_mac_addr))\n\t\t\teth_hw_addr_set(ndev, efuse_mac_addr);\n\t\telse\n\t\t\teth_hw_addr_random(ndev);\n\n\t\tdevm_iounmap(dev, efuse);\n\t\tdevm_release_mem_region(dev, res.start, size);\n\t} else {\n\t\tret = of_get_ethdev_address(node_interface, ndev);\n\t\tif (ret)\n\t\t\teth_hw_addr_random(ndev);\n\t}\n\n\tret = of_property_read_string(node_interface, \"rx-channel\",\n\t\t\t\t      &netcp->dma_chan_name);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"missing \\\"rx-channel\\\" parameter\\n\");\n\t\tret = -ENODEV;\n\t\tgoto quit;\n\t}\n\n\tret = of_property_read_u32(node_interface, \"rx-queue\",\n\t\t\t\t   &netcp->rx_queue_id);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"missing \\\"rx-queue\\\" parameter\\n\");\n\t\tnetcp->rx_queue_id = KNAV_QUEUE_QPEND;\n\t}\n\n\tret = of_property_read_u32_array(node_interface, \"rx-queue-depth\",\n\t\t\t\t\t netcp->rx_queue_depths,\n\t\t\t\t\t KNAV_DMA_FDQ_PER_CHAN);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"missing \\\"rx-queue-depth\\\" parameter\\n\");\n\t\tnetcp->rx_queue_depths[0] = 128;\n\t}\n\n\tret = of_property_read_u32_array(node_interface, \"rx-pool\", temp, 2);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"missing \\\"rx-pool\\\" parameter\\n\");\n\t\tret = -ENODEV;\n\t\tgoto quit;\n\t}\n\tnetcp->rx_pool_size = temp[0];\n\tnetcp->rx_pool_region_id = temp[1];\n\n\tret = of_property_read_u32_array(node_interface, \"tx-pool\", temp, 2);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"missing \\\"tx-pool\\\" parameter\\n\");\n\t\tret = -ENODEV;\n\t\tgoto quit;\n\t}\n\tnetcp->tx_pool_size = temp[0];\n\tnetcp->tx_pool_region_id = temp[1];\n\n\tif (netcp->tx_pool_size < MAX_SKB_FRAGS) {\n\t\tdev_err(dev, \"tx-pool size too small, must be at least %u\\n\",\n\t\t\t(unsigned int)MAX_SKB_FRAGS);\n\t\tret = -ENODEV;\n\t\tgoto quit;\n\t}\n\n\tret = of_property_read_u32(node_interface, \"tx-completion-queue\",\n\t\t\t\t   &netcp->tx_compl_qid);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"missing \\\"tx-completion-queue\\\" parameter\\n\");\n\t\tnetcp->tx_compl_qid = KNAV_QUEUE_QPEND;\n\t}\n\n\t \n\tnetif_napi_add(ndev, &netcp->rx_napi, netcp_rx_poll);\n\tnetif_napi_add_tx(ndev, &netcp->tx_napi, netcp_tx_poll);\n\n\t \n\tndev->dev_id\t\t= 0;\n\tndev->watchdog_timeo\t= NETCP_TX_TIMEOUT;\n\tndev->netdev_ops\t= &netcp_netdev_ops;\n\tSET_NETDEV_DEV(ndev, dev);\n\n\tlist_add_tail(&netcp->interface_list, &netcp_device->interface_head);\n\treturn 0;\n\nquit:\n\tfree_netdev(ndev);\n\treturn ret;\n}\n\nstatic void netcp_delete_interface(struct netcp_device *netcp_device,\n\t\t\t\t   struct net_device *ndev)\n{\n\tstruct netcp_intf_modpriv *intf_modpriv, *tmp;\n\tstruct netcp_intf *netcp = netdev_priv(ndev);\n\tstruct netcp_module *module;\n\n\tdev_dbg(netcp_device->device, \"Removing interface \\\"%s\\\"\\n\",\n\t\tndev->name);\n\n\t \n\tlist_for_each_entry_safe(intf_modpriv, tmp, &netcp->module_head,\n\t\t\t\t intf_list) {\n\t\tmodule = intf_modpriv->netcp_module;\n\t\tdev_dbg(netcp_device->device, \"Releasing module \\\"%s\\\"\\n\",\n\t\t\tmodule->name);\n\t\tif (module->release)\n\t\t\tmodule->release(intf_modpriv->module_priv);\n\t\tlist_del(&intf_modpriv->intf_list);\n\t}\n\tWARN(!list_empty(&netcp->module_head), \"%s interface module list is not empty!\\n\",\n\t     ndev->name);\n\n\tlist_del(&netcp->interface_list);\n\n\tof_node_put(netcp->node_interface);\n\tunregister_netdev(ndev);\n\tfree_netdev(ndev);\n}\n\nstatic int netcp_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct netcp_intf *netcp_intf, *netcp_tmp;\n\tstruct device_node *child, *interfaces;\n\tstruct netcp_device *netcp_device;\n\tstruct device *dev = &pdev->dev;\n\tstruct netcp_module *module;\n\tint ret;\n\n\tif (!knav_dma_device_ready() ||\n\t    !knav_qmss_device_ready())\n\t\treturn -EPROBE_DEFER;\n\n\tif (!node) {\n\t\tdev_err(dev, \"could not find device info\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tnetcp_device = devm_kzalloc(dev, sizeof(*netcp_device), GFP_KERNEL);\n\tif (!netcp_device)\n\t\treturn -ENOMEM;\n\n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_get_sync(&pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to enable NETCP power-domain\\n\");\n\t\tpm_runtime_disable(&pdev->dev);\n\t\treturn ret;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&netcp_device->interface_head);\n\tINIT_LIST_HEAD(&netcp_device->modpriv_head);\n\tnetcp_device->device = dev;\n\tplatform_set_drvdata(pdev, netcp_device);\n\n\t \n\tinterfaces = of_get_child_by_name(node, \"netcp-interfaces\");\n\tif (!interfaces) {\n\t\tdev_err(dev, \"could not find netcp-interfaces node\\n\");\n\t\tret = -ENODEV;\n\t\tgoto probe_quit;\n\t}\n\n\tfor_each_available_child_of_node(interfaces, child) {\n\t\tret = netcp_create_interface(netcp_device, child);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"could not create interface(%pOFn)\\n\",\n\t\t\t\tchild);\n\t\t\tgoto probe_quit_interface;\n\t\t}\n\t}\n\n\tof_node_put(interfaces);\n\n\t \n\tlist_add_tail(&netcp_device->device_list, &netcp_devices);\n\n\t \n\tmutex_lock(&netcp_modules_lock);\n\tfor_each_netcp_module(module) {\n\t\tret = netcp_module_probe(netcp_device, module);\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"module(%s) probe failed\\n\", module->name);\n\t}\n\tmutex_unlock(&netcp_modules_lock);\n\treturn 0;\n\nprobe_quit_interface:\n\tlist_for_each_entry_safe(netcp_intf, netcp_tmp,\n\t\t\t\t &netcp_device->interface_head,\n\t\t\t\t interface_list) {\n\t\tnetcp_delete_interface(netcp_device, netcp_intf->ndev);\n\t}\n\n\tof_node_put(interfaces);\n\nprobe_quit:\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tplatform_set_drvdata(pdev, NULL);\n\treturn ret;\n}\n\nstatic int netcp_remove(struct platform_device *pdev)\n{\n\tstruct netcp_device *netcp_device = platform_get_drvdata(pdev);\n\tstruct netcp_intf *netcp_intf, *netcp_tmp;\n\tstruct netcp_inst_modpriv *inst_modpriv, *tmp;\n\tstruct netcp_module *module;\n\n\tlist_for_each_entry_safe(inst_modpriv, tmp, &netcp_device->modpriv_head,\n\t\t\t\t inst_list) {\n\t\tmodule = inst_modpriv->netcp_module;\n\t\tdev_dbg(&pdev->dev, \"Removing module \\\"%s\\\"\\n\", module->name);\n\t\tmodule->remove(netcp_device, inst_modpriv->module_priv);\n\t\tlist_del(&inst_modpriv->inst_list);\n\t}\n\n\t \n\tlist_for_each_entry_safe(netcp_intf, netcp_tmp,\n\t\t\t\t &netcp_device->interface_head,\n\t\t\t\t interface_list) {\n\t\tnetcp_delete_interface(netcp_device, netcp_intf->ndev);\n\t}\n\n\tWARN(!list_empty(&netcp_device->interface_head),\n\t     \"%s interface list not empty!\\n\", pdev->name);\n\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tplatform_set_drvdata(pdev, NULL);\n\treturn 0;\n}\n\nstatic const struct of_device_id of_match[] = {\n\t{ .compatible = \"ti,netcp-1.0\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_match);\n\nstatic struct platform_driver netcp_driver = {\n\t.driver = {\n\t\t.name\t\t= \"netcp-1.0\",\n\t\t.of_match_table\t= of_match,\n\t},\n\t.probe = netcp_probe,\n\t.remove = netcp_remove,\n};\nmodule_platform_driver(netcp_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"TI NETCP driver for Keystone SOCs\");\nMODULE_AUTHOR(\"Sandeep Nair <sandeep_n@ti.com\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}