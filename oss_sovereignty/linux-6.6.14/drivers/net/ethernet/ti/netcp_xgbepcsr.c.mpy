{
  "module_name": "netcp_xgbepcsr.c",
  "hash_id": "07d55dcf6c48d8134b48a2aeaa6685a15753fb47b18c28018adf4e73e90c6af0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/netcp_xgbepcsr.c",
  "human_readable_source": "\n \n#include \"netcp.h\"\n\n \n#define XGBE_CTRL_OFFSET\t\t0x0c\n#define XGBE_SGMII_1_OFFSET\t\t0x0114\n#define XGBE_SGMII_2_OFFSET\t\t0x0214\n\n \n#define PCSR_CPU_CTRL_OFFSET\t\t0x1fd0\n#define POR_EN\t\t\t\tBIT(29)\n\n#define reg_rmw(addr, value, mask) \\\n\twritel(((readl(addr) & (~(mask))) | \\\n\t\t\t(value & (mask))), (addr))\n\n \n#define MASK_WID_SH(w, s)\t\t(((1 << w) - 1) << s)\n\n \n#define VAL_SH(v, s)\t\t\t(v << s)\n\n#define PHY_A(serdes)\t\t\t0\n\nstruct serdes_cfg {\n\tu32 ofs;\n\tu32 val;\n\tu32 mask;\n};\n\nstatic struct serdes_cfg cfg_phyb_1p25g_156p25mhz_cmu0[] = {\n\t{0x0000, 0x00800002, 0x00ff00ff},\n\t{0x0014, 0x00003838, 0x0000ffff},\n\t{0x0060, 0x1c44e438, 0xffffffff},\n\t{0x0064, 0x00c18400, 0x00ffffff},\n\t{0x0068, 0x17078200, 0xffffff00},\n\t{0x006c, 0x00000014, 0x000000ff},\n\t{0x0078, 0x0000c000, 0x0000ff00},\n\t{0x0000, 0x00000003, 0x000000ff},\n};\n\nstatic struct serdes_cfg cfg_phyb_10p3125g_156p25mhz_cmu1[] = {\n\t{0x0c00, 0x00030002, 0x00ff00ff},\n\t{0x0c14, 0x00005252, 0x0000ffff},\n\t{0x0c28, 0x80000000, 0xff000000},\n\t{0x0c2c, 0x000000f6, 0x000000ff},\n\t{0x0c3c, 0x04000405, 0xff00ffff},\n\t{0x0c40, 0xc0800000, 0xffff0000},\n\t{0x0c44, 0x5a202062, 0xffffffff},\n\t{0x0c48, 0x40040424, 0xffffffff},\n\t{0x0c4c, 0x00004002, 0x0000ffff},\n\t{0x0c50, 0x19001c00, 0xff00ff00},\n\t{0x0c54, 0x00002100, 0x0000ff00},\n\t{0x0c58, 0x00000060, 0x000000ff},\n\t{0x0c60, 0x80131e7c, 0xffffffff},\n\t{0x0c64, 0x8400cb02, 0xff00ffff},\n\t{0x0c68, 0x17078200, 0xffffff00},\n\t{0x0c6c, 0x00000016, 0x000000ff},\n\t{0x0c74, 0x00000400, 0x0000ff00},\n\t{0x0c78, 0x0000c000, 0x0000ff00},\n\t{0x0c00, 0x00000003, 0x000000ff},\n};\n\nstatic struct serdes_cfg cfg_phyb_10p3125g_16bit_lane[] = {\n\t{0x0204, 0x00000080, 0x000000ff},\n\t{0x0208, 0x0000920d, 0x0000ffff},\n\t{0x0204, 0xfc000000, 0xff000000},\n\t{0x0208, 0x00009104, 0x0000ffff},\n\t{0x0210, 0x1a000000, 0xff000000},\n\t{0x0214, 0x00006b58, 0x00ffffff},\n\t{0x0218, 0x75800084, 0xffff00ff},\n\t{0x022c, 0x00300000, 0x00ff0000},\n\t{0x0230, 0x00003800, 0x0000ff00},\n\t{0x024c, 0x008f0000, 0x00ff0000},\n\t{0x0250, 0x30000000, 0xff000000},\n\t{0x0260, 0x00000002, 0x000000ff},\n\t{0x0264, 0x00000057, 0x000000ff},\n\t{0x0268, 0x00575700, 0x00ffff00},\n\t{0x0278, 0xff000000, 0xff000000},\n\t{0x0280, 0x00500050, 0x00ff00ff},\n\t{0x0284, 0x00001f15, 0x0000ffff},\n\t{0x028c, 0x00006f00, 0x0000ff00},\n\t{0x0294, 0x00000000, 0xffffff00},\n\t{0x0298, 0x00002640, 0xff00ffff},\n\t{0x029c, 0x00000003, 0x000000ff},\n\t{0x02a4, 0x00000f13, 0x0000ffff},\n\t{0x02a8, 0x0001b600, 0x00ffff00},\n\t{0x0380, 0x00000030, 0x000000ff},\n\t{0x03c0, 0x00000200, 0x0000ff00},\n\t{0x03cc, 0x00000018, 0x000000ff},\n\t{0x03cc, 0x00000000, 0x000000ff},\n};\n\nstatic struct serdes_cfg cfg_phyb_10p3125g_comlane[] = {\n\t{0x0a00, 0x00000800, 0x0000ff00},\n\t{0x0a84, 0x00000000, 0x000000ff},\n\t{0x0a8c, 0x00130000, 0x00ff0000},\n\t{0x0a90, 0x77a00000, 0xffff0000},\n\t{0x0a94, 0x00007777, 0x0000ffff},\n\t{0x0b08, 0x000f0000, 0xffff0000},\n\t{0x0b0c, 0x000f0000, 0x00ffffff},\n\t{0x0b10, 0xbe000000, 0xff000000},\n\t{0x0b14, 0x000000ff, 0x000000ff},\n\t{0x0b18, 0x00000014, 0x000000ff},\n\t{0x0b5c, 0x981b0000, 0xffff0000},\n\t{0x0b64, 0x00001100, 0x0000ff00},\n\t{0x0b78, 0x00000c00, 0x0000ff00},\n\t{0x0abc, 0xff000000, 0xff000000},\n\t{0x0ac0, 0x0000008b, 0x000000ff},\n};\n\nstatic struct serdes_cfg cfg_cm_c1_c2[] = {\n\t{0x0208, 0x00000000, 0x00000f00},\n\t{0x0208, 0x00000000, 0x0000001f},\n\t{0x0204, 0x00000000, 0x00040000},\n\t{0x0208, 0x000000a0, 0x000000e0},\n};\n\nstatic void netcp_xgbe_serdes_cmu_init(void __iomem *serdes_regs)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cfg_phyb_1p25g_156p25mhz_cmu0); i++) {\n\t\treg_rmw(serdes_regs + cfg_phyb_1p25g_156p25mhz_cmu0[i].ofs,\n\t\t\tcfg_phyb_1p25g_156p25mhz_cmu0[i].val,\n\t\t\tcfg_phyb_1p25g_156p25mhz_cmu0[i].mask);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cfg_phyb_10p3125g_156p25mhz_cmu1); i++) {\n\t\treg_rmw(serdes_regs + cfg_phyb_10p3125g_156p25mhz_cmu1[i].ofs,\n\t\t\tcfg_phyb_10p3125g_156p25mhz_cmu1[i].val,\n\t\t\tcfg_phyb_10p3125g_156p25mhz_cmu1[i].mask);\n\t}\n}\n\n \nstatic void netcp_xgbe_serdes_lane_config(\n\t\t\tvoid __iomem *serdes_regs, int lane)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cfg_phyb_10p3125g_16bit_lane); i++) {\n\t\treg_rmw(serdes_regs +\n\t\t\t\tcfg_phyb_10p3125g_16bit_lane[i].ofs +\n\t\t\t\t(0x200 * lane),\n\t\t\tcfg_phyb_10p3125g_16bit_lane[i].val,\n\t\t\tcfg_phyb_10p3125g_16bit_lane[i].mask);\n\t}\n\n\t \n\treg_rmw(serdes_regs + (0x200 * lane) + 0x0380,\n\t\t0x00000000, 0x00000010);\n\n\t \n\treg_rmw(serdes_regs + (0x200 * lane) + 0x03c0,\n\t\t0x00000000, 0x00000200);\n}\n\nstatic void netcp_xgbe_serdes_com_enable(void __iomem *serdes_regs)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cfg_phyb_10p3125g_comlane); i++) {\n\t\treg_rmw(serdes_regs + cfg_phyb_10p3125g_comlane[i].ofs,\n\t\t\tcfg_phyb_10p3125g_comlane[i].val,\n\t\t\tcfg_phyb_10p3125g_comlane[i].mask);\n\t}\n}\n\nstatic void netcp_xgbe_serdes_lane_enable(\n\t\t\tvoid __iomem *serdes_regs, int lane)\n{\n\t \n\twritel(0xe0e9e038, serdes_regs + 0x1fe0 + (4 * lane));\n}\n\nstatic void netcp_xgbe_serdes_phyb_rst_clr(void __iomem *serdes_regs)\n{\n\treg_rmw(serdes_regs + 0x0a00, 0x0000001f, 0x000000ff);\n}\n\nstatic void netcp_xgbe_serdes_pll_disable(void __iomem *serdes_regs)\n{\n\twritel(0x88000000, serdes_regs + 0x1ff4);\n}\n\nstatic void netcp_xgbe_serdes_pll_enable(void __iomem *serdes_regs)\n{\n\tnetcp_xgbe_serdes_phyb_rst_clr(serdes_regs);\n\twritel(0xee000000, serdes_regs + 0x1ff4);\n}\n\nstatic int netcp_xgbe_wait_pll_locked(void __iomem *sw_regs)\n{\n\tunsigned long timeout;\n\tint ret = 0;\n\tu32 val_1, val_0;\n\n\ttimeout = jiffies + msecs_to_jiffies(500);\n\tdo {\n\t\tval_0 = (readl(sw_regs + XGBE_SGMII_1_OFFSET) & BIT(4));\n\t\tval_1 = (readl(sw_regs + XGBE_SGMII_2_OFFSET) & BIT(4));\n\n\t\tif (val_1 && val_0)\n\t\t\treturn 0;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\tcpu_relax();\n\t} while (true);\n\n\tpr_err(\"XGBE serdes not locked: time out.\\n\");\n\treturn ret;\n}\n\nstatic void netcp_xgbe_serdes_enable_xgmii_port(void __iomem *sw_regs)\n{\n\twritel(0x03, sw_regs + XGBE_CTRL_OFFSET);\n}\n\nstatic u32 netcp_xgbe_serdes_read_tbus_val(void __iomem *serdes_regs)\n{\n\tu32 tmp;\n\n\tif (PHY_A(serdes_regs)) {\n\t\ttmp  = (readl(serdes_regs + 0x0ec) >> 24) & 0x0ff;\n\t\ttmp |= ((readl(serdes_regs + 0x0fc) >> 16) & 0x00f00);\n\t} else {\n\t\ttmp  = (readl(serdes_regs + 0x0f8) >> 16) & 0x0fff;\n\t}\n\n\treturn tmp;\n}\n\nstatic void netcp_xgbe_serdes_write_tbus_addr(void __iomem *serdes_regs,\n\t\t\t\t\t      int select, int ofs)\n{\n\tif (PHY_A(serdes_regs)) {\n\t\treg_rmw(serdes_regs + 0x0008, ((select << 5) + ofs) << 24,\n\t\t\t~0x00ffffff);\n\t\treturn;\n\t}\n\n\t \n\tswitch (select) {\n\tcase 1:\n\t\tselect = 2;\n\t\tbreak;\n\tcase 2:\n\t\tselect = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\treg_rmw(serdes_regs + 0x00fc, ((select << 8) + ofs) << 16, ~0xf800ffff);\n}\n\nstatic u32 netcp_xgbe_serdes_read_select_tbus(void __iomem *serdes_regs,\n\t\t\t\t\t      int select, int ofs)\n{\n\t \n\tnetcp_xgbe_serdes_write_tbus_addr(serdes_regs, select, ofs);\n\t \n\treturn netcp_xgbe_serdes_read_tbus_val(serdes_regs);\n}\n\nstatic void netcp_xgbe_serdes_reset_cdr(void __iomem *serdes_regs,\n\t\t\t\t\tvoid __iomem *sig_detect_reg, int lane)\n{\n\tu32 tmp, dlpf, tbus;\n\n\t \n\ttmp = netcp_xgbe_serdes_read_select_tbus(\n\t\t\tserdes_regs, lane + 1, 5);\n\n\tdlpf = tmp >> 2;\n\n\tif (dlpf < 400 || dlpf > 700) {\n\t\treg_rmw(sig_detect_reg, VAL_SH(2, 1), MASK_WID_SH(2, 1));\n\t\tmdelay(1);\n\t\treg_rmw(sig_detect_reg, VAL_SH(0, 1), MASK_WID_SH(2, 1));\n\t} else {\n\t\ttbus = netcp_xgbe_serdes_read_select_tbus(serdes_regs, lane +\n\t\t\t\t\t\t\t  1, 0xe);\n\n\t\tpr_debug(\"XGBE: CDR centered, DLPF: %4d,%d,%d.\\n\",\n\t\t\t tmp >> 2, tmp & 3, (tbus >> 2) & 3);\n\t}\n}\n\n \nstatic int netcp_xgbe_check_link_status(void __iomem *serdes_regs,\n\t\t\t\t\tvoid __iomem *sw_regs, u32 lanes,\n\t\t\t\t\tu32 *current_state, u32 *lane_down)\n{\n\tvoid __iomem *pcsr_base = sw_regs + 0x0600;\n\tvoid __iomem *sig_detect_reg;\n\tu32 pcsr_rx_stat, blk_lock, blk_errs;\n\tint loss, i, status = 1;\n\n\tfor (i = 0; i < lanes; i++) {\n\t\t \n\t\tloss = readl(serdes_regs + 0x1fc0 + 0x20 + (i * 0x04)) & 0x1;\n\n\t\t \n\t\tpcsr_rx_stat = readl(pcsr_base + 0x0c + (i * 0x80));\n\t\tblk_lock = (pcsr_rx_stat >> 30) & 0x1;\n\t\tblk_errs = (pcsr_rx_stat >> 16) & 0x0ff;\n\n\t\t \n\t\tsig_detect_reg = serdes_regs + (i * 0x200) + 0x200 + 0x04;\n\n\t\t \n\t\tif (blk_errs == 0x0ff)\n\t\t\tblk_lock = 0;\n\n\t\tswitch (current_state[i]) {\n\t\tcase 0:\n\t\t\t \n\t\t\tif (!loss && blk_lock) {\n\t\t\t\tpr_debug(\"XGBE PCSR Linked Lane: %d\\n\", i);\n\t\t\t\treg_rmw(sig_detect_reg, VAL_SH(3, 1),\n\t\t\t\t\tMASK_WID_SH(2, 1));\n\t\t\t\tcurrent_state[i] = 1;\n\t\t\t} else if (!blk_lock) {\n\t\t\t\t \n\t\t\t\tpr_debug(\"XGBE PCSR Recover Lane: %d\\n\", i);\n\t\t\t\tnetcp_xgbe_serdes_reset_cdr(serdes_regs,\n\t\t\t\t\t\t\t    sig_detect_reg, i);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tif (!blk_lock) {\n\t\t\t\t \n\t\t\t\tlane_down[i] = 1;\n\t\t\t\tcurrent_state[i] = 2;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tif (blk_lock)\n\t\t\t\t \n\t\t\t\tcurrent_state[i] = 1;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tnetcp_xgbe_serdes_reset_cdr(serdes_regs,\n\t\t\t\t\t\t\t    sig_detect_reg, i);\n\t\t\t\tcurrent_state[i] = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"XGBE: unknown current_state[%d] %d\\n\",\n\t\t\t       i, current_state[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk_errs > 0) {\n\t\t\t \n\t\t\treg_rmw(pcsr_base + 0x08 + (i * 0x80), VAL_SH(0x19, 0),\n\t\t\t\tMASK_WID_SH(8, 0));\n\n\t\t\treg_rmw(pcsr_base + 0x08 + (i * 0x80), VAL_SH(0x00, 0),\n\t\t\t\tMASK_WID_SH(8, 0));\n\t\t}\n\n\t\tstatus &= (current_state[i] == 1);\n\t}\n\n\treturn status;\n}\n\nstatic int netcp_xgbe_serdes_check_lane(void __iomem *serdes_regs,\n\t\t\t\t\tvoid __iomem *sw_regs)\n{\n\tu32 current_state[2] = {0, 0};\n\tint retries = 0, link_up;\n\tu32 lane_down[2];\n\n\tdo {\n\t\tlane_down[0] = 0;\n\t\tlane_down[1] = 0;\n\n\t\tlink_up = netcp_xgbe_check_link_status(serdes_regs, sw_regs, 2,\n\t\t\t\t\t\t       current_state,\n\t\t\t\t\t\t       lane_down);\n\n\t\t \n\t\tif (link_up)\n\t\t\tbreak;\n\n\t\tif (lane_down[0])\n\t\t\tpr_debug(\"XGBE: detected link down on lane 0\\n\");\n\n\t\tif (lane_down[1])\n\t\t\tpr_debug(\"XGBE: detected link down on lane 1\\n\");\n\n\t\tif (++retries > 1) {\n\t\t\tpr_debug(\"XGBE: timeout waiting for serdes link up\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmdelay(100);\n\t} while (!link_up);\n\n\tpr_debug(\"XGBE: PCSR link is up\\n\");\n\treturn 0;\n}\n\nstatic void netcp_xgbe_serdes_setup_cm_c1_c2(void __iomem *serdes_regs,\n\t\t\t\t\t     int lane, int cm, int c1, int c2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cfg_cm_c1_c2); i++) {\n\t\treg_rmw(serdes_regs + cfg_cm_c1_c2[i].ofs + (0x200 * lane),\n\t\t\tcfg_cm_c1_c2[i].val,\n\t\t\tcfg_cm_c1_c2[i].mask);\n\t}\n}\n\nstatic void netcp_xgbe_reset_serdes(void __iomem *serdes_regs)\n{\n\t \n\t \n\treg_rmw(serdes_regs + PCSR_CPU_CTRL_OFFSET, POR_EN, POR_EN);\n\tusleep_range(10, 100);\n\n\t \n\treg_rmw(serdes_regs + PCSR_CPU_CTRL_OFFSET, 0, POR_EN);\n\tusleep_range(10, 100);\n}\n\nstatic int netcp_xgbe_serdes_config(void __iomem *serdes_regs,\n\t\t\t\t    void __iomem *sw_regs)\n{\n\tu32 ret, i;\n\n\tnetcp_xgbe_serdes_pll_disable(serdes_regs);\n\tnetcp_xgbe_serdes_cmu_init(serdes_regs);\n\n\tfor (i = 0; i < 2; i++)\n\t\tnetcp_xgbe_serdes_lane_config(serdes_regs, i);\n\n\tnetcp_xgbe_serdes_com_enable(serdes_regs);\n\t \n\tfor (i = 0; i < 2; i++)\n\t\tnetcp_xgbe_serdes_setup_cm_c1_c2(serdes_regs, i, 0, 0, 5);\n\n\tnetcp_xgbe_serdes_pll_enable(serdes_regs);\n\tfor (i = 0; i < 2; i++)\n\t\tnetcp_xgbe_serdes_lane_enable(serdes_regs, i);\n\n\t \n\tret = netcp_xgbe_wait_pll_locked(sw_regs);\n\tif (ret)\n\t\treturn ret;\n\n\tnetcp_xgbe_serdes_enable_xgmii_port(sw_regs);\n\tnetcp_xgbe_serdes_check_lane(serdes_regs, sw_regs);\n\treturn ret;\n}\n\nint netcp_xgbe_serdes_init(void __iomem *serdes_regs, void __iomem *xgbe_regs)\n{\n\tu32 val;\n\n\t \n\tval = readl(serdes_regs + 0xa00);\n\tif (val & 0x1f) {\n\t\tpr_debug(\"XGBE: serdes already in operation - reset\\n\");\n\t\tnetcp_xgbe_reset_serdes(serdes_regs);\n\t}\n\treturn netcp_xgbe_serdes_config(serdes_regs, xgbe_regs);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}