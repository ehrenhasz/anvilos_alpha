{
  "module_name": "netcp_sgmii.c",
  "hash_id": "9fde633c793a796def6497961f86aaf79919b056b361afe80bc739878a019083",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/netcp_sgmii.c",
  "human_readable_source": "\n \n\n#include \"netcp.h\"\n\n#define SGMII_SRESET_RESET\t\tBIT(0)\n#define SGMII_SRESET_RTRESET\t\tBIT(1)\n\n#define SGMII_REG_STATUS_LOCK\t\tBIT(4)\n#define\tSGMII_REG_STATUS_LINK\t\tBIT(0)\n#define SGMII_REG_STATUS_AUTONEG\tBIT(2)\n#define SGMII_REG_CONTROL_AUTONEG\tBIT(0)\n\n#define SGMII23_OFFSET(x)\t((x - 2) * 0x100)\n#define SGMII_OFFSET(x)\t\t((x <= 1) ? (x * 0x100) : (SGMII23_OFFSET(x)))\n\n \n#define SGMII_SRESET_REG(x)   (SGMII_OFFSET(x) + 0x004)\n#define SGMII_CTL_REG(x)      (SGMII_OFFSET(x) + 0x010)\n#define SGMII_STATUS_REG(x)   (SGMII_OFFSET(x) + 0x014)\n#define SGMII_MRADV_REG(x)    (SGMII_OFFSET(x) + 0x018)\n\nstatic void sgmii_write_reg(void __iomem *base, int reg, u32 val)\n{\n\twritel(val, base + reg);\n}\n\nstatic u32 sgmii_read_reg(void __iomem *base, int reg)\n{\n\treturn readl(base + reg);\n}\n\nstatic void sgmii_write_reg_bit(void __iomem *base, int reg, u32 val)\n{\n\twritel((readl(base + reg) | val), base + reg);\n}\n\n \nint netcp_sgmii_reset(void __iomem *sgmii_ofs, int port)\n{\n\t \n\tsgmii_write_reg_bit(sgmii_ofs, SGMII_SRESET_REG(port),\n\t\t\t    SGMII_SRESET_RESET);\n\n\twhile ((sgmii_read_reg(sgmii_ofs, SGMII_SRESET_REG(port)) &\n\t\tSGMII_SRESET_RESET) != 0x0)\n\t\t;\n\n\treturn 0;\n}\n\n \nbool netcp_sgmii_rtreset(void __iomem *sgmii_ofs, int port, bool set)\n{\n\tu32 reg;\n\tbool oldval;\n\n\t \n\treg = sgmii_read_reg(sgmii_ofs, SGMII_SRESET_REG(port));\n\toldval = (reg & SGMII_SRESET_RTRESET) != 0x0;\n\tif (set)\n\t\treg |= SGMII_SRESET_RTRESET;\n\telse\n\t\treg &= ~SGMII_SRESET_RTRESET;\n\tsgmii_write_reg(sgmii_ofs, SGMII_SRESET_REG(port), reg);\n\twmb();\n\n\treturn oldval;\n}\n\nint netcp_sgmii_get_port_link(void __iomem *sgmii_ofs, int port)\n{\n\tu32 status = 0, link = 0;\n\n\tstatus = sgmii_read_reg(sgmii_ofs, SGMII_STATUS_REG(port));\n\tif ((status & SGMII_REG_STATUS_LINK) != 0)\n\t\tlink = 1;\n\treturn link;\n}\n\nint netcp_sgmii_config(void __iomem *sgmii_ofs, int port, u32 interface)\n{\n\tunsigned int i, status, mask;\n\tu32 mr_adv_ability;\n\tu32 control;\n\n\tswitch (interface) {\n\tcase SGMII_LINK_MAC_MAC_AUTONEG:\n\t\tmr_adv_ability\t= 0x9801;\n\t\tcontrol\t\t= 0x21;\n\t\tbreak;\n\n\tcase SGMII_LINK_MAC_PHY:\n\tcase SGMII_LINK_MAC_PHY_NO_MDIO:\n\t\tmr_adv_ability\t= 1;\n\t\tcontrol\t\t= 1;\n\t\tbreak;\n\n\tcase SGMII_LINK_MAC_MAC_FORCED:\n\t\tmr_adv_ability\t= 0x9801;\n\t\tcontrol\t\t= 0x20;\n\t\tbreak;\n\n\tcase SGMII_LINK_MAC_FIBER:\n\t\tmr_adv_ability\t= 0x20;\n\t\tcontrol\t\t= 0x1;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ONCE(1, \"Invalid sgmii interface: %d\\n\", interface);\n\t\treturn -EINVAL;\n\t}\n\n\tsgmii_write_reg(sgmii_ofs, SGMII_CTL_REG(port), 0);\n\n\t \n\tfor (i = 0; i < 1000; i++)  {\n\t\tusleep_range(1000, 2000);\n\t\tstatus = sgmii_read_reg(sgmii_ofs, SGMII_STATUS_REG(port));\n\t\tif ((status & SGMII_REG_STATUS_LOCK) != 0)\n\t\t\tbreak;\n\t}\n\n\tif ((status & SGMII_REG_STATUS_LOCK) == 0)\n\t\tpr_err(\"serdes PLL not locked\\n\");\n\n\tsgmii_write_reg(sgmii_ofs, SGMII_MRADV_REG(port), mr_adv_ability);\n\tsgmii_write_reg(sgmii_ofs, SGMII_CTL_REG(port), control);\n\n\tmask = SGMII_REG_STATUS_LINK;\n\tif (control & SGMII_REG_CONTROL_AUTONEG)\n\t\tmask |= SGMII_REG_STATUS_AUTONEG;\n\n\tfor (i = 0; i < 1000; i++)  {\n\t\tusleep_range(200, 500);\n\t\tstatus = sgmii_read_reg(sgmii_ofs, SGMII_STATUS_REG(port));\n\t\tif ((status & mask) == mask)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}