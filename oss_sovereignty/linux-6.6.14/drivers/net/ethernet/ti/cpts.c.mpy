{
  "module_name": "cpts.c",
  "hash_id": "087a90af491d6c2e9b32b6aed28fdea12a7009453bcb8025adc5247bb497f953",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/cpts.c",
  "human_readable_source": "\n \n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/if.h>\n#include <linux/hrtimer.h>\n#include <linux/module.h>\n#include <linux/net_tstamp.h>\n#include <linux/ptp_classify.h>\n#include <linux/time.h>\n#include <linux/uaccess.h>\n#include <linux/workqueue.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n\n#include \"cpts.h\"\n\n#define CPTS_SKB_TX_WORK_TIMEOUT 1  \n#define CPTS_SKB_RX_TX_TMO 100  \n#define CPTS_EVENT_RX_TX_TIMEOUT (100)  \n\nstruct cpts_skb_cb_data {\n\tu32 skb_mtype_seqid;\n\tunsigned long tmo;\n};\n\n#define cpts_read32(c, r)\treadl_relaxed(&c->reg->r)\n#define cpts_write32(c, v, r)\twritel_relaxed(v, &c->reg->r)\n\nstatic int cpts_event_port(struct cpts_event *event)\n{\n\treturn (event->high >> PORT_NUMBER_SHIFT) & PORT_NUMBER_MASK;\n}\n\nstatic int event_expired(struct cpts_event *event)\n{\n\treturn time_after(jiffies, event->tmo);\n}\n\nstatic int event_type(struct cpts_event *event)\n{\n\treturn (event->high >> EVENT_TYPE_SHIFT) & EVENT_TYPE_MASK;\n}\n\nstatic int cpts_fifo_pop(struct cpts *cpts, u32 *high, u32 *low)\n{\n\tu32 r = cpts_read32(cpts, intstat_raw);\n\n\tif (r & TS_PEND_RAW) {\n\t\t*high = cpts_read32(cpts, event_high);\n\t\t*low  = cpts_read32(cpts, event_low);\n\t\tcpts_write32(cpts, EVENT_POP, event_pop);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic int cpts_purge_events(struct cpts *cpts)\n{\n\tstruct list_head *this, *next;\n\tstruct cpts_event *event;\n\tint removed = 0;\n\n\tlist_for_each_safe(this, next, &cpts->events) {\n\t\tevent = list_entry(this, struct cpts_event, list);\n\t\tif (event_expired(event)) {\n\t\t\tlist_del_init(&event->list);\n\t\t\tlist_add(&event->list, &cpts->pool);\n\t\t\t++removed;\n\t\t}\n\t}\n\n\tif (removed)\n\t\tdev_dbg(cpts->dev, \"cpts: event pool cleaned up %d\\n\", removed);\n\treturn removed ? 0 : -1;\n}\n\nstatic void cpts_purge_txq(struct cpts *cpts)\n{\n\tstruct cpts_skb_cb_data *skb_cb;\n\tstruct sk_buff *skb, *tmp;\n\tint removed = 0;\n\n\tskb_queue_walk_safe(&cpts->txq, skb, tmp) {\n\t\tskb_cb = (struct cpts_skb_cb_data *)skb->cb;\n\t\tif (time_after(jiffies, skb_cb->tmo)) {\n\t\t\t__skb_unlink(skb, &cpts->txq);\n\t\t\tdev_consume_skb_any(skb);\n\t\t\t++removed;\n\t\t}\n\t}\n\n\tif (removed)\n\t\tdev_dbg(cpts->dev, \"txq cleaned up %d\\n\", removed);\n}\n\n \nstatic int cpts_fifo_read(struct cpts *cpts, int match)\n{\n\tstruct ptp_clock_event pevent;\n\tbool need_schedule = false;\n\tstruct cpts_event *event;\n\tunsigned long flags;\n\tint i, type = -1;\n\tu32 hi, lo;\n\n\tspin_lock_irqsave(&cpts->lock, flags);\n\n\tfor (i = 0; i < CPTS_FIFO_DEPTH; i++) {\n\t\tif (cpts_fifo_pop(cpts, &hi, &lo))\n\t\t\tbreak;\n\n\t\tif (list_empty(&cpts->pool) && cpts_purge_events(cpts)) {\n\t\t\tdev_warn(cpts->dev, \"cpts: event pool empty\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tevent = list_first_entry(&cpts->pool, struct cpts_event, list);\n\t\tevent->high = hi;\n\t\tevent->low = lo;\n\t\tevent->timestamp = timecounter_cyc2time(&cpts->tc, event->low);\n\t\ttype = event_type(event);\n\n\t\tdev_dbg(cpts->dev, \"CPTS_EV: %d high:%08X low:%08x\\n\",\n\t\t\ttype, event->high, event->low);\n\t\tswitch (type) {\n\t\tcase CPTS_EV_PUSH:\n\t\t\tWRITE_ONCE(cpts->cur_timestamp, lo);\n\t\t\ttimecounter_read(&cpts->tc);\n\t\t\tif (cpts->mult_new) {\n\t\t\t\tcpts->cc.mult = cpts->mult_new;\n\t\t\t\tcpts->mult_new = 0;\n\t\t\t}\n\t\t\tif (!cpts->irq_poll)\n\t\t\t\tcomplete(&cpts->ts_push_complete);\n\t\t\tbreak;\n\t\tcase CPTS_EV_TX:\n\t\tcase CPTS_EV_RX:\n\t\t\tevent->tmo = jiffies +\n\t\t\t\tmsecs_to_jiffies(CPTS_EVENT_RX_TX_TIMEOUT);\n\n\t\t\tlist_del_init(&event->list);\n\t\t\tlist_add_tail(&event->list, &cpts->events);\n\t\t\tneed_schedule = true;\n\t\t\tbreak;\n\t\tcase CPTS_EV_ROLL:\n\t\tcase CPTS_EV_HALF:\n\t\t\tbreak;\n\t\tcase CPTS_EV_HW:\n\t\t\tpevent.timestamp = event->timestamp;\n\t\t\tpevent.type = PTP_CLOCK_EXTTS;\n\t\t\tpevent.index = cpts_event_port(event) - 1;\n\t\t\tptp_clock_event(cpts->clock, &pevent);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(cpts->dev, \"cpts: unknown event type\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (type == match)\n\t\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&cpts->lock, flags);\n\n\tif (!cpts->irq_poll && need_schedule)\n\t\tptp_schedule_worker(cpts->clock, 0);\n\n\treturn type == match ? 0 : -1;\n}\n\nvoid cpts_misc_interrupt(struct cpts *cpts)\n{\n\tcpts_fifo_read(cpts, -1);\n}\nEXPORT_SYMBOL_GPL(cpts_misc_interrupt);\n\nstatic u64 cpts_systim_read(const struct cyclecounter *cc)\n{\n\tstruct cpts *cpts = container_of(cc, struct cpts, cc);\n\n\treturn READ_ONCE(cpts->cur_timestamp);\n}\n\nstatic void cpts_update_cur_time(struct cpts *cpts, int match,\n\t\t\t\t struct ptp_system_timestamp *sts)\n{\n\tunsigned long flags;\n\n\treinit_completion(&cpts->ts_push_complete);\n\n\t \n\tspin_lock_irqsave(&cpts->lock, flags);\n\tptp_read_system_prets(sts);\n\tcpts_write32(cpts, TS_PUSH, ts_push);\n\tcpts_read32(cpts, ts_push);\n\tptp_read_system_postts(sts);\n\tspin_unlock_irqrestore(&cpts->lock, flags);\n\n\tif (cpts->irq_poll && cpts_fifo_read(cpts, match) && match != -1)\n\t\tdev_err(cpts->dev, \"cpts: unable to obtain a time stamp\\n\");\n\n\tif (!cpts->irq_poll &&\n\t    !wait_for_completion_timeout(&cpts->ts_push_complete, HZ))\n\t\tdev_err(cpts->dev, \"cpts: obtain a time stamp timeout\\n\");\n}\n\n \n\nstatic int cpts_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct cpts *cpts = container_of(ptp, struct cpts, info);\n\n\tmutex_lock(&cpts->ptp_clk_mutex);\n\n\tcpts->mult_new = adjust_by_scaled_ppm(cpts->cc_mult, scaled_ppm);\n\n\tcpts_update_cur_time(cpts, CPTS_EV_PUSH, NULL);\n\n\tmutex_unlock(&cpts->ptp_clk_mutex);\n\treturn 0;\n}\n\nstatic int cpts_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct cpts *cpts = container_of(ptp, struct cpts, info);\n\n\tmutex_lock(&cpts->ptp_clk_mutex);\n\ttimecounter_adjtime(&cpts->tc, delta);\n\tmutex_unlock(&cpts->ptp_clk_mutex);\n\n\treturn 0;\n}\n\nstatic int cpts_ptp_gettimeex(struct ptp_clock_info *ptp,\n\t\t\t      struct timespec64 *ts,\n\t\t\t      struct ptp_system_timestamp *sts)\n{\n\tstruct cpts *cpts = container_of(ptp, struct cpts, info);\n\tu64 ns;\n\n\tmutex_lock(&cpts->ptp_clk_mutex);\n\n\tcpts_update_cur_time(cpts, CPTS_EV_PUSH, sts);\n\n\tns = timecounter_read(&cpts->tc);\n\tmutex_unlock(&cpts->ptp_clk_mutex);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\nstatic int cpts_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t    const struct timespec64 *ts)\n{\n\tstruct cpts *cpts = container_of(ptp, struct cpts, info);\n\tu64 ns;\n\n\tns = timespec64_to_ns(ts);\n\n\tmutex_lock(&cpts->ptp_clk_mutex);\n\ttimecounter_init(&cpts->tc, &cpts->cc, ns);\n\tmutex_unlock(&cpts->ptp_clk_mutex);\n\n\treturn 0;\n}\n\nstatic int cpts_extts_enable(struct cpts *cpts, u32 index, int on)\n{\n\tu32 v;\n\n\tif (((cpts->hw_ts_enable & BIT(index)) >> index) == on)\n\t\treturn 0;\n\n\tmutex_lock(&cpts->ptp_clk_mutex);\n\n\tv = cpts_read32(cpts, control);\n\tif (on) {\n\t\tv |= BIT(8 + index);\n\t\tcpts->hw_ts_enable |= BIT(index);\n\t} else {\n\t\tv &= ~BIT(8 + index);\n\t\tcpts->hw_ts_enable &= ~BIT(index);\n\t}\n\tcpts_write32(cpts, v, control);\n\n\tmutex_unlock(&cpts->ptp_clk_mutex);\n\n\treturn 0;\n}\n\nstatic int cpts_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t   struct ptp_clock_request *rq, int on)\n{\n\tstruct cpts *cpts = container_of(ptp, struct cpts, info);\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\treturn cpts_extts_enable(cpts, rq->extts.index, on);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic bool cpts_match_tx_ts(struct cpts *cpts, struct cpts_event *event)\n{\n\tstruct sk_buff_head txq_list;\n\tstruct sk_buff *skb, *tmp;\n\tunsigned long flags;\n\tbool found = false;\n\tu32 mtype_seqid;\n\n\tmtype_seqid = event->high &\n\t\t      ((MESSAGE_TYPE_MASK << MESSAGE_TYPE_SHIFT) |\n\t\t       (SEQUENCE_ID_MASK << SEQUENCE_ID_SHIFT) |\n\t\t       (EVENT_TYPE_MASK << EVENT_TYPE_SHIFT));\n\n\t__skb_queue_head_init(&txq_list);\n\n\tspin_lock_irqsave(&cpts->txq.lock, flags);\n\tskb_queue_splice_init(&cpts->txq, &txq_list);\n\tspin_unlock_irqrestore(&cpts->txq.lock, flags);\n\n\tskb_queue_walk_safe(&txq_list, skb, tmp) {\n\t\tstruct skb_shared_hwtstamps ssh;\n\t\tstruct cpts_skb_cb_data *skb_cb =\n\t\t\t\t\t(struct cpts_skb_cb_data *)skb->cb;\n\n\t\tif (mtype_seqid == skb_cb->skb_mtype_seqid) {\n\t\t\tmemset(&ssh, 0, sizeof(ssh));\n\t\t\tssh.hwtstamp = ns_to_ktime(event->timestamp);\n\t\t\tskb_tstamp_tx(skb, &ssh);\n\t\t\tfound = true;\n\t\t\t__skb_unlink(skb, &txq_list);\n\t\t\tdev_consume_skb_any(skb);\n\t\t\tdev_dbg(cpts->dev, \"match tx timestamp mtype_seqid %08x\\n\",\n\t\t\t\tmtype_seqid);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (time_after(jiffies, skb_cb->tmo)) {\n\t\t\t \n\t\t\tdev_dbg(cpts->dev, \"expiring tx timestamp from txq\\n\");\n\t\t\t__skb_unlink(skb, &txq_list);\n\t\t\tdev_consume_skb_any(skb);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&cpts->txq.lock, flags);\n\tskb_queue_splice(&txq_list, &cpts->txq);\n\tspin_unlock_irqrestore(&cpts->txq.lock, flags);\n\n\treturn found;\n}\n\nstatic void cpts_process_events(struct cpts *cpts)\n{\n\tstruct list_head *this, *next;\n\tstruct cpts_event *event;\n\tLIST_HEAD(events_free);\n\tunsigned long flags;\n\tLIST_HEAD(events);\n\n\tspin_lock_irqsave(&cpts->lock, flags);\n\tlist_splice_init(&cpts->events, &events);\n\tspin_unlock_irqrestore(&cpts->lock, flags);\n\n\tlist_for_each_safe(this, next, &events) {\n\t\tevent = list_entry(this, struct cpts_event, list);\n\t\tif (cpts_match_tx_ts(cpts, event) ||\n\t\t    time_after(jiffies, event->tmo)) {\n\t\t\tlist_del_init(&event->list);\n\t\t\tlist_add(&event->list, &events_free);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&cpts->lock, flags);\n\tlist_splice_tail(&events, &cpts->events);\n\tlist_splice_tail(&events_free, &cpts->pool);\n\tspin_unlock_irqrestore(&cpts->lock, flags);\n}\n\nstatic long cpts_overflow_check(struct ptp_clock_info *ptp)\n{\n\tstruct cpts *cpts = container_of(ptp, struct cpts, info);\n\tunsigned long delay = cpts->ov_check_period;\n\tunsigned long flags;\n\tu64 ns;\n\n\tmutex_lock(&cpts->ptp_clk_mutex);\n\n\tcpts_update_cur_time(cpts, -1, NULL);\n\tns = timecounter_read(&cpts->tc);\n\n\tcpts_process_events(cpts);\n\n\tspin_lock_irqsave(&cpts->txq.lock, flags);\n\tif (!skb_queue_empty(&cpts->txq)) {\n\t\tcpts_purge_txq(cpts);\n\t\tif (!skb_queue_empty(&cpts->txq))\n\t\t\tdelay = CPTS_SKB_TX_WORK_TIMEOUT;\n\t}\n\tspin_unlock_irqrestore(&cpts->txq.lock, flags);\n\n\tdev_dbg(cpts->dev, \"cpts overflow check at %lld\\n\", ns);\n\tmutex_unlock(&cpts->ptp_clk_mutex);\n\treturn (long)delay;\n}\n\nstatic const struct ptp_clock_info cpts_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"CTPS timer\",\n\t.max_adj\t= 1000000,\n\t.n_ext_ts\t= 0,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 0,\n\t.adjfine\t= cpts_ptp_adjfine,\n\t.adjtime\t= cpts_ptp_adjtime,\n\t.gettimex64\t= cpts_ptp_gettimeex,\n\t.settime64\t= cpts_ptp_settime,\n\t.enable\t\t= cpts_ptp_enable,\n\t.do_aux_work\t= cpts_overflow_check,\n};\n\nstatic int cpts_skb_get_mtype_seqid(struct sk_buff *skb, u32 *mtype_seqid)\n{\n\tunsigned int ptp_class = ptp_classify_raw(skb);\n\tstruct ptp_header *hdr;\n\tu8 msgtype;\n\tu16 seqid;\n\n\tif (ptp_class == PTP_CLASS_NONE)\n\t\treturn 0;\n\n\thdr = ptp_parse_header(skb, ptp_class);\n\tif (!hdr)\n\t\treturn 0;\n\n\tmsgtype = ptp_get_msgtype(hdr, ptp_class);\n\tseqid\t= ntohs(hdr->sequence_id);\n\n\t*mtype_seqid  = (msgtype & MESSAGE_TYPE_MASK) << MESSAGE_TYPE_SHIFT;\n\t*mtype_seqid |= (seqid & SEQUENCE_ID_MASK) << SEQUENCE_ID_SHIFT;\n\n\treturn 1;\n}\n\nstatic u64 cpts_find_ts(struct cpts *cpts, struct sk_buff *skb,\n\t\t\tint ev_type, u32 skb_mtype_seqid)\n{\n\tstruct list_head *this, *next;\n\tstruct cpts_event *event;\n\tunsigned long flags;\n\tu32 mtype_seqid;\n\tu64 ns = 0;\n\n\tcpts_fifo_read(cpts, -1);\n\tspin_lock_irqsave(&cpts->lock, flags);\n\tlist_for_each_safe(this, next, &cpts->events) {\n\t\tevent = list_entry(this, struct cpts_event, list);\n\t\tif (event_expired(event)) {\n\t\t\tlist_del_init(&event->list);\n\t\t\tlist_add(&event->list, &cpts->pool);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmtype_seqid = event->high &\n\t\t\t      ((MESSAGE_TYPE_MASK << MESSAGE_TYPE_SHIFT) |\n\t\t\t       (SEQUENCE_ID_MASK << SEQUENCE_ID_SHIFT) |\n\t\t\t       (EVENT_TYPE_MASK << EVENT_TYPE_SHIFT));\n\n\t\tif (mtype_seqid == skb_mtype_seqid) {\n\t\t\tns = event->timestamp;\n\t\t\tlist_del_init(&event->list);\n\t\t\tlist_add(&event->list, &cpts->pool);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cpts->lock, flags);\n\n\treturn ns;\n}\n\nvoid cpts_rx_timestamp(struct cpts *cpts, struct sk_buff *skb)\n{\n\tstruct cpts_skb_cb_data *skb_cb = (struct cpts_skb_cb_data *)skb->cb;\n\tstruct skb_shared_hwtstamps *ssh;\n\tint ret;\n\tu64 ns;\n\n\t \n\tskb_reset_mac_header(skb);\n\tret = cpts_skb_get_mtype_seqid(skb, &skb_cb->skb_mtype_seqid);\n\tif (!ret)\n\t\treturn;\n\n\tskb_cb->skb_mtype_seqid |= (CPTS_EV_RX << EVENT_TYPE_SHIFT);\n\n\tdev_dbg(cpts->dev, \"%s mtype seqid %08x\\n\",\n\t\t__func__, skb_cb->skb_mtype_seqid);\n\n\tns = cpts_find_ts(cpts, skb, CPTS_EV_RX, skb_cb->skb_mtype_seqid);\n\tif (!ns)\n\t\treturn;\n\tssh = skb_hwtstamps(skb);\n\tmemset(ssh, 0, sizeof(*ssh));\n\tssh->hwtstamp = ns_to_ktime(ns);\n}\nEXPORT_SYMBOL_GPL(cpts_rx_timestamp);\n\nvoid cpts_tx_timestamp(struct cpts *cpts, struct sk_buff *skb)\n{\n\tstruct cpts_skb_cb_data *skb_cb = (struct cpts_skb_cb_data *)skb->cb;\n\tint ret;\n\n\tif (!(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS))\n\t\treturn;\n\n\tret = cpts_skb_get_mtype_seqid(skb, &skb_cb->skb_mtype_seqid);\n\tif (!ret)\n\t\treturn;\n\n\tskb_cb->skb_mtype_seqid |= (CPTS_EV_TX << EVENT_TYPE_SHIFT);\n\n\tdev_dbg(cpts->dev, \"%s mtype seqid %08x\\n\",\n\t\t__func__, skb_cb->skb_mtype_seqid);\n\n\t \n\tskb_get(skb);\n\t \n\tskb_cb->tmo = jiffies + msecs_to_jiffies(CPTS_SKB_RX_TX_TMO);\n\tskb_queue_tail(&cpts->txq, skb);\n\tptp_schedule_worker(cpts->clock, 0);\n}\nEXPORT_SYMBOL_GPL(cpts_tx_timestamp);\n\nint cpts_register(struct cpts *cpts)\n{\n\tint err, i;\n\n\tskb_queue_head_init(&cpts->txq);\n\tINIT_LIST_HEAD(&cpts->events);\n\tINIT_LIST_HEAD(&cpts->pool);\n\tfor (i = 0; i < CPTS_MAX_EVENTS; i++)\n\t\tlist_add(&cpts->pool_data[i].list, &cpts->pool);\n\n\terr = clk_enable(cpts->refclk);\n\tif (err)\n\t\treturn err;\n\n\tcpts_write32(cpts, CPTS_EN, control);\n\tcpts_write32(cpts, TS_PEND_EN, int_enable);\n\n\ttimecounter_init(&cpts->tc, &cpts->cc, ktime_get_real_ns());\n\n\tcpts->clock = ptp_clock_register(&cpts->info, cpts->dev);\n\tif (IS_ERR(cpts->clock)) {\n\t\terr = PTR_ERR(cpts->clock);\n\t\tcpts->clock = NULL;\n\t\tgoto err_ptp;\n\t}\n\tcpts->phc_index = ptp_clock_index(cpts->clock);\n\n\tptp_schedule_worker(cpts->clock, cpts->ov_check_period);\n\treturn 0;\n\nerr_ptp:\n\tclk_disable(cpts->refclk);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cpts_register);\n\nvoid cpts_unregister(struct cpts *cpts)\n{\n\tif (WARN_ON(!cpts->clock))\n\t\treturn;\n\n\tptp_clock_unregister(cpts->clock);\n\tcpts->clock = NULL;\n\tcpts->phc_index = -1;\n\n\tcpts_write32(cpts, 0, int_enable);\n\tcpts_write32(cpts, 0, control);\n\n\t \n\tskb_queue_purge(&cpts->txq);\n\n\tclk_disable(cpts->refclk);\n}\nEXPORT_SYMBOL_GPL(cpts_unregister);\n\nstatic void cpts_calc_mult_shift(struct cpts *cpts)\n{\n\tu64 frac, maxsec, ns;\n\tu32 freq;\n\n\tfreq = clk_get_rate(cpts->refclk);\n\n\t \n\tmaxsec = cpts->cc.mask;\n\tdo_div(maxsec, freq);\n\t \n\tif (maxsec > 10)\n\t\tmaxsec = 10;\n\n\t \n\tcpts->ov_check_period = (HZ * maxsec) / 2;\n\tdev_info(cpts->dev, \"cpts: overflow check period %lu (jiffies)\\n\",\n\t\t cpts->ov_check_period);\n\n\tif (cpts->cc.mult || cpts->cc.shift)\n\t\treturn;\n\n\tclocks_calc_mult_shift(&cpts->cc.mult, &cpts->cc.shift,\n\t\t\t       freq, NSEC_PER_SEC, maxsec);\n\n\tfrac = 0;\n\tns = cyclecounter_cyc2ns(&cpts->cc, freq, cpts->cc.mask, &frac);\n\n\tdev_info(cpts->dev,\n\t\t \"CPTS: ref_clk_freq:%u calc_mult:%u calc_shift:%u error:%lld nsec/sec\\n\",\n\t\t freq, cpts->cc.mult, cpts->cc.shift, (ns - NSEC_PER_SEC));\n}\n\nstatic int cpts_of_mux_clk_setup(struct cpts *cpts, struct device_node *node)\n{\n\tstruct device_node *refclk_np;\n\tconst char **parent_names;\n\tunsigned int num_parents;\n\tstruct clk_hw *clk_hw;\n\tint ret = -EINVAL;\n\tu32 *mux_table;\n\n\trefclk_np = of_get_child_by_name(node, \"cpts-refclk-mux\");\n\tif (!refclk_np)\n\t\t \n\t\treturn 0;\n\n\tnum_parents = of_clk_get_parent_count(refclk_np);\n\tif (num_parents < 1) {\n\t\tdev_err(cpts->dev, \"mux-clock %s must have parents\\n\",\n\t\t\trefclk_np->name);\n\t\tgoto mux_fail;\n\t}\n\n\tparent_names = devm_kcalloc(cpts->dev, num_parents,\n\t\t\t\t    sizeof(*parent_names), GFP_KERNEL);\n\n\tmux_table = devm_kcalloc(cpts->dev, num_parents, sizeof(*mux_table),\n\t\t\t\t GFP_KERNEL);\n\tif (!mux_table || !parent_names) {\n\t\tret = -ENOMEM;\n\t\tgoto mux_fail;\n\t}\n\n\tof_clk_parent_fill(refclk_np, parent_names, num_parents);\n\n\tret = of_property_read_variable_u32_array(refclk_np, \"ti,mux-tbl\",\n\t\t\t\t\t\t  mux_table,\n\t\t\t\t\t\t  num_parents, num_parents);\n\tif (ret < 0)\n\t\tgoto mux_fail;\n\n\tclk_hw = clk_hw_register_mux_table(cpts->dev, refclk_np->name,\n\t\t\t\t\t   parent_names, num_parents,\n\t\t\t\t\t   0,\n\t\t\t\t\t   &cpts->reg->rftclk_sel, 0, 0x1F,\n\t\t\t\t\t   0, mux_table, NULL);\n\tif (IS_ERR(clk_hw)) {\n\t\tret = PTR_ERR(clk_hw);\n\t\tgoto mux_fail;\n\t}\n\n\tret = devm_add_action_or_reset(cpts->dev,\n\t\t\t\t       (void(*)(void *))clk_hw_unregister_mux,\n\t\t\t\t       clk_hw);\n\tif (ret) {\n\t\tdev_err(cpts->dev, \"add clkmux unreg action %d\", ret);\n\t\tgoto mux_fail;\n\t}\n\n\tret = of_clk_add_hw_provider(refclk_np, of_clk_hw_simple_get, clk_hw);\n\tif (ret)\n\t\tgoto mux_fail;\n\n\tret = devm_add_action_or_reset(cpts->dev,\n\t\t\t\t       (void(*)(void *))of_clk_del_provider,\n\t\t\t\t       refclk_np);\n\tif (ret) {\n\t\tdev_err(cpts->dev, \"add clkmux provider unreg action %d\", ret);\n\t\tgoto mux_fail;\n\t}\n\n\treturn ret;\n\nmux_fail:\n\tof_node_put(refclk_np);\n\treturn ret;\n}\n\nstatic int cpts_of_parse(struct cpts *cpts, struct device_node *node)\n{\n\tint ret = -EINVAL;\n\tu32 prop;\n\n\tif (!of_property_read_u32(node, \"cpts_clock_mult\", &prop))\n\t\tcpts->cc.mult = prop;\n\n\tif (!of_property_read_u32(node, \"cpts_clock_shift\", &prop))\n\t\tcpts->cc.shift = prop;\n\n\tif ((cpts->cc.mult && !cpts->cc.shift) ||\n\t    (!cpts->cc.mult && cpts->cc.shift))\n\t\tgoto of_error;\n\n\treturn cpts_of_mux_clk_setup(cpts, node);\n\nof_error:\n\tdev_err(cpts->dev, \"CPTS: Missing property in the DT.\\n\");\n\treturn ret;\n}\n\nstruct cpts *cpts_create(struct device *dev, void __iomem *regs,\n\t\t\t struct device_node *node, u32 n_ext_ts)\n{\n\tstruct cpts *cpts;\n\tint ret;\n\n\tcpts = devm_kzalloc(dev, sizeof(*cpts), GFP_KERNEL);\n\tif (!cpts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcpts->dev = dev;\n\tcpts->reg = (struct cpsw_cpts __iomem *)regs;\n\tcpts->irq_poll = true;\n\tspin_lock_init(&cpts->lock);\n\tmutex_init(&cpts->ptp_clk_mutex);\n\tinit_completion(&cpts->ts_push_complete);\n\n\tret = cpts_of_parse(cpts, node);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tcpts->refclk = devm_get_clk_from_child(dev, node, \"cpts\");\n\tif (IS_ERR(cpts->refclk))\n\t\t \n\t\tcpts->refclk = devm_clk_get(dev, \"cpts\");\n\n\tif (IS_ERR(cpts->refclk)) {\n\t\tdev_err(dev, \"Failed to get cpts refclk %ld\\n\",\n\t\t\tPTR_ERR(cpts->refclk));\n\t\treturn ERR_CAST(cpts->refclk);\n\t}\n\n\tret = clk_prepare(cpts->refclk);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tcpts->cc.read = cpts_systim_read;\n\tcpts->cc.mask = CLOCKSOURCE_MASK(32);\n\tcpts->info = cpts_info;\n\tcpts->phc_index = -1;\n\n\tif (n_ext_ts)\n\t\tcpts->info.n_ext_ts = n_ext_ts;\n\n\tcpts_calc_mult_shift(cpts);\n\t \n\tcpts->cc_mult = cpts->cc.mult;\n\n\treturn cpts;\n}\nEXPORT_SYMBOL_GPL(cpts_create);\n\nvoid cpts_release(struct cpts *cpts)\n{\n\tif (!cpts)\n\t\treturn;\n\n\tif (WARN_ON(!cpts->refclk))\n\t\treturn;\n\n\tclk_unprepare(cpts->refclk);\n}\nEXPORT_SYMBOL_GPL(cpts_release);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"TI CPTS driver\");\nMODULE_AUTHOR(\"Richard Cochran <richardcochran@gmail.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}