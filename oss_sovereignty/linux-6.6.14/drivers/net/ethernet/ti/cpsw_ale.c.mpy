{
  "module_name": "cpsw_ale.c",
  "hash_id": "34c7e3644b06519007e788f7a3fa709a4769c79ac799dd8142c2de341a35a24d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/cpsw_ale.c",
  "human_readable_source": "\n \n#include <linux/bitmap.h>\n#include <linux/if_vlan.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/stat.h>\n#include <linux/sysfs.h>\n#include <linux/etherdevice.h>\n\n#include \"cpsw_ale.h\"\n\n#define BITMASK(bits)\t\t(BIT(bits) - 1)\n\n#define ALE_VERSION_MAJOR(rev, mask) (((rev) >> 8) & (mask))\n#define ALE_VERSION_MINOR(rev)\t(rev & 0xff)\n#define ALE_VERSION_1R3\t\t0x0103\n#define ALE_VERSION_1R4\t\t0x0104\n\n \n#define ALE_IDVER\t\t0x00\n#define ALE_STATUS\t\t0x04\n#define ALE_CONTROL\t\t0x08\n#define ALE_PRESCALE\t\t0x10\n#define ALE_AGING_TIMER\t\t0x14\n#define ALE_UNKNOWNVLAN\t\t0x18\n#define ALE_TABLE_CONTROL\t0x20\n#define ALE_TABLE\t\t0x34\n#define ALE_PORTCTL\t\t0x40\n\n \n#define ALE_UNKNOWNVLAN_MEMBER\t\t\t0x90\n#define ALE_UNKNOWNVLAN_UNREG_MCAST_FLOOD\t0x94\n#define ALE_UNKNOWNVLAN_REG_MCAST_FLOOD\t\t0x98\n#define ALE_UNKNOWNVLAN_FORCE_UNTAG_EGRESS\t0x9C\n#define ALE_VLAN_MASK_MUX(reg)\t\t\t(0xc0 + (0x4 * (reg)))\n\n#define AM65_CPSW_ALE_THREAD_DEF_REG 0x134\n\n \n#define ALE_AGING_TIMER_MASK\tGENMASK(23, 0)\n\n#define ALE_RATE_LIMIT_MIN_PPS 1000\n\n \nstruct ale_entry_fld {\n\tu8 start_bit;\n\tu8 num_bits;\n\tu8 flags;\n};\n\nenum {\n\tCPSW_ALE_F_STATUS_REG = BIT(0),  \n\tCPSW_ALE_F_HW_AUTOAGING = BIT(1),  \n\n\tCPSW_ALE_F_COUNT\n};\n\n \nstruct cpsw_ale_dev_id {\n\tconst char *dev_id;\n\tu32 features;\n\tu32 tbl_entries;\n\tu32 major_ver_mask;\n\tbool nu_switch_ale;\n\tconst struct ale_entry_fld *vlan_entry_tbl;\n};\n\n#define ALE_TABLE_WRITE\t\tBIT(31)\n\n#define ALE_TYPE_FREE\t\t\t0\n#define ALE_TYPE_ADDR\t\t\t1\n#define ALE_TYPE_VLAN\t\t\t2\n#define ALE_TYPE_VLAN_ADDR\t\t3\n\n#define ALE_UCAST_PERSISTANT\t\t0\n#define ALE_UCAST_UNTOUCHED\t\t1\n#define ALE_UCAST_OUI\t\t\t2\n#define ALE_UCAST_TOUCHED\t\t3\n\n#define ALE_TABLE_SIZE_MULTIPLIER\t1024\n#define ALE_STATUS_SIZE_MASK\t\t0x1f\n\nstatic inline int cpsw_ale_get_field(u32 *ale_entry, u32 start, u32 bits)\n{\n\tint idx, idx2;\n\tu32 hi_val = 0;\n\n\tidx    = start / 32;\n\tidx2 = (start + bits - 1) / 32;\n\t \n\tif (idx != idx2) {\n\t\tidx2 = 2 - idx2;  \n\t\thi_val = ale_entry[idx2] << ((idx2 * 32) - start);\n\t}\n\tstart -= idx * 32;\n\tidx    = 2 - idx;  \n\treturn (hi_val + (ale_entry[idx] >> start)) & BITMASK(bits);\n}\n\nstatic inline void cpsw_ale_set_field(u32 *ale_entry, u32 start, u32 bits,\n\t\t\t\t      u32 value)\n{\n\tint idx, idx2;\n\n\tvalue &= BITMASK(bits);\n\tidx = start / 32;\n\tidx2 = (start + bits - 1) / 32;\n\t \n\tif (idx != idx2) {\n\t\tidx2 = 2 - idx2;  \n\t\tale_entry[idx2] &= ~(BITMASK(bits + start - (idx2 * 32)));\n\t\tale_entry[idx2] |= (value >> ((idx2 * 32) - start));\n\t}\n\tstart -= idx * 32;\n\tidx = 2 - idx;  \n\tale_entry[idx] &= ~(BITMASK(bits) << start);\n\tale_entry[idx] |=  (value << start);\n}\n\n#define DEFINE_ALE_FIELD(name, start, bits)\t\t\t\t\\\nstatic inline int cpsw_ale_get_##name(u32 *ale_entry)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn cpsw_ale_get_field(ale_entry, start, bits);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void cpsw_ale_set_##name(u32 *ale_entry, u32 value)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tcpsw_ale_set_field(ale_entry, start, bits, value);\t\t\\\n}\n\n#define DEFINE_ALE_FIELD1(name, start)\t\t\t\t\t\\\nstatic inline int cpsw_ale_get_##name(u32 *ale_entry, u32 bits)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn cpsw_ale_get_field(ale_entry, start, bits);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void cpsw_ale_set_##name(u32 *ale_entry, u32 value,\t\\\n\t\tu32 bits)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tcpsw_ale_set_field(ale_entry, start, bits, value);\t\t\\\n}\n\nenum {\n\tALE_ENT_VID_MEMBER_LIST = 0,\n\tALE_ENT_VID_UNREG_MCAST_MSK,\n\tALE_ENT_VID_REG_MCAST_MSK,\n\tALE_ENT_VID_FORCE_UNTAGGED_MSK,\n\tALE_ENT_VID_UNREG_MCAST_IDX,\n\tALE_ENT_VID_REG_MCAST_IDX,\n\tALE_ENT_VID_LAST,\n};\n\n#define ALE_FLD_ALLOWED\t\t\tBIT(0)\n#define ALE_FLD_SIZE_PORT_MASK_BITS\tBIT(1)\n#define ALE_FLD_SIZE_PORT_NUM_BITS\tBIT(2)\n\n#define ALE_ENTRY_FLD(id, start, bits)\t\\\n[id] = {\t\t\t\t\\\n\t.start_bit = start,\t\t\\\n\t.num_bits = bits,\t\t\\\n\t.flags = ALE_FLD_ALLOWED,\t\\\n}\n\n#define ALE_ENTRY_FLD_DYN_MSK_SIZE(id, start)\t\\\n[id] = {\t\t\t\t\t\\\n\t.start_bit = start,\t\t\t\\\n\t.num_bits = 0,\t\t\t\t\\\n\t.flags = ALE_FLD_ALLOWED |\t\t\\\n\t\t ALE_FLD_SIZE_PORT_MASK_BITS,\t\\\n}\n\n \nstatic const struct ale_entry_fld vlan_entry_cpsw[ALE_ENT_VID_LAST] = {\n\tALE_ENTRY_FLD(ALE_ENT_VID_MEMBER_LIST, 0, 3),\n\tALE_ENTRY_FLD(ALE_ENT_VID_UNREG_MCAST_MSK, 8, 3),\n\tALE_ENTRY_FLD(ALE_ENT_VID_REG_MCAST_MSK, 16, 3),\n\tALE_ENTRY_FLD(ALE_ENT_VID_FORCE_UNTAGGED_MSK, 24, 3),\n};\n\n \nstatic const struct ale_entry_fld vlan_entry_nu[ALE_ENT_VID_LAST] = {\n\tALE_ENTRY_FLD_DYN_MSK_SIZE(ALE_ENT_VID_MEMBER_LIST, 0),\n\tALE_ENTRY_FLD(ALE_ENT_VID_UNREG_MCAST_IDX, 20, 3),\n\tALE_ENTRY_FLD_DYN_MSK_SIZE(ALE_ENT_VID_FORCE_UNTAGGED_MSK, 24),\n\tALE_ENTRY_FLD(ALE_ENT_VID_REG_MCAST_IDX, 44, 3),\n};\n\n \nstatic const struct ale_entry_fld vlan_entry_k3_cpswxg[] = {\n\tALE_ENTRY_FLD_DYN_MSK_SIZE(ALE_ENT_VID_MEMBER_LIST, 0),\n\tALE_ENTRY_FLD_DYN_MSK_SIZE(ALE_ENT_VID_UNREG_MCAST_MSK, 12),\n\tALE_ENTRY_FLD_DYN_MSK_SIZE(ALE_ENT_VID_FORCE_UNTAGGED_MSK, 24),\n\tALE_ENTRY_FLD_DYN_MSK_SIZE(ALE_ENT_VID_REG_MCAST_MSK, 36),\n};\n\nDEFINE_ALE_FIELD(entry_type,\t\t60,\t2)\nDEFINE_ALE_FIELD(vlan_id,\t\t48,\t12)\nDEFINE_ALE_FIELD(mcast_state,\t\t62,\t2)\nDEFINE_ALE_FIELD1(port_mask,\t\t66)\nDEFINE_ALE_FIELD(super,\t\t\t65,\t1)\nDEFINE_ALE_FIELD(ucast_type,\t\t62,     2)\nDEFINE_ALE_FIELD1(port_num,\t\t66)\nDEFINE_ALE_FIELD(blocked,\t\t65,     1)\nDEFINE_ALE_FIELD(secure,\t\t64,     1)\nDEFINE_ALE_FIELD(mcast,\t\t\t40,\t1)\n\n#define NU_VLAN_UNREG_MCAST_IDX\t1\n\nstatic int cpsw_ale_entry_get_fld(struct cpsw_ale *ale,\n\t\t\t\t  u32 *ale_entry,\n\t\t\t\t  const struct ale_entry_fld *entry_tbl,\n\t\t\t\t  int fld_id)\n{\n\tconst struct ale_entry_fld *entry_fld;\n\tu32 bits;\n\n\tif (!ale || !ale_entry)\n\t\treturn -EINVAL;\n\n\tentry_fld = &entry_tbl[fld_id];\n\tif (!(entry_fld->flags & ALE_FLD_ALLOWED)) {\n\t\tdev_err(ale->params.dev, \"get: wrong ale fld id %d\\n\", fld_id);\n\t\treturn -ENOENT;\n\t}\n\n\tbits = entry_fld->num_bits;\n\tif (entry_fld->flags & ALE_FLD_SIZE_PORT_MASK_BITS)\n\t\tbits = ale->port_mask_bits;\n\n\treturn cpsw_ale_get_field(ale_entry, entry_fld->start_bit, bits);\n}\n\nstatic void cpsw_ale_entry_set_fld(struct cpsw_ale *ale,\n\t\t\t\t   u32 *ale_entry,\n\t\t\t\t   const struct ale_entry_fld *entry_tbl,\n\t\t\t\t   int fld_id,\n\t\t\t\t   u32 value)\n{\n\tconst struct ale_entry_fld *entry_fld;\n\tu32 bits;\n\n\tif (!ale || !ale_entry)\n\t\treturn;\n\n\tentry_fld = &entry_tbl[fld_id];\n\tif (!(entry_fld->flags & ALE_FLD_ALLOWED)) {\n\t\tdev_err(ale->params.dev, \"set: wrong ale fld id %d\\n\", fld_id);\n\t\treturn;\n\t}\n\n\tbits = entry_fld->num_bits;\n\tif (entry_fld->flags & ALE_FLD_SIZE_PORT_MASK_BITS)\n\t\tbits = ale->port_mask_bits;\n\n\tcpsw_ale_set_field(ale_entry, entry_fld->start_bit, bits, value);\n}\n\nstatic int cpsw_ale_vlan_get_fld(struct cpsw_ale *ale,\n\t\t\t\t u32 *ale_entry,\n\t\t\t\t int fld_id)\n{\n\treturn cpsw_ale_entry_get_fld(ale, ale_entry,\n\t\t\t\t      ale->vlan_entry_tbl, fld_id);\n}\n\nstatic void cpsw_ale_vlan_set_fld(struct cpsw_ale *ale,\n\t\t\t\t  u32 *ale_entry,\n\t\t\t\t  int fld_id,\n\t\t\t\t  u32 value)\n{\n\tcpsw_ale_entry_set_fld(ale, ale_entry,\n\t\t\t       ale->vlan_entry_tbl, fld_id, value);\n}\n\n \nstatic inline void cpsw_ale_get_addr(u32 *ale_entry, u8 *addr)\n{\n\tint i;\n\n\tfor (i = 0; i < 6; i++)\n\t\taddr[i] = cpsw_ale_get_field(ale_entry, 40 - 8*i, 8);\n}\n\nstatic inline void cpsw_ale_set_addr(u32 *ale_entry, const u8 *addr)\n{\n\tint i;\n\n\tfor (i = 0; i < 6; i++)\n\t\tcpsw_ale_set_field(ale_entry, 40 - 8*i, 8, addr[i]);\n}\n\nstatic int cpsw_ale_read(struct cpsw_ale *ale, int idx, u32 *ale_entry)\n{\n\tint i;\n\n\tWARN_ON(idx > ale->params.ale_entries);\n\n\twritel_relaxed(idx, ale->params.ale_regs + ALE_TABLE_CONTROL);\n\n\tfor (i = 0; i < ALE_ENTRY_WORDS; i++)\n\t\tale_entry[i] = readl_relaxed(ale->params.ale_regs +\n\t\t\t\t\t     ALE_TABLE + 4 * i);\n\n\treturn idx;\n}\n\nstatic int cpsw_ale_write(struct cpsw_ale *ale, int idx, u32 *ale_entry)\n{\n\tint i;\n\n\tWARN_ON(idx > ale->params.ale_entries);\n\n\tfor (i = 0; i < ALE_ENTRY_WORDS; i++)\n\t\twritel_relaxed(ale_entry[i], ale->params.ale_regs +\n\t\t\t       ALE_TABLE + 4 * i);\n\n\twritel_relaxed(idx | ALE_TABLE_WRITE, ale->params.ale_regs +\n\t\t       ALE_TABLE_CONTROL);\n\n\treturn idx;\n}\n\nstatic int cpsw_ale_match_addr(struct cpsw_ale *ale, const u8 *addr, u16 vid)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS];\n\tint type, idx;\n\n\tfor (idx = 0; idx < ale->params.ale_entries; idx++) {\n\t\tu8 entry_addr[6];\n\n\t\tcpsw_ale_read(ale, idx, ale_entry);\n\t\ttype = cpsw_ale_get_entry_type(ale_entry);\n\t\tif (type != ALE_TYPE_ADDR && type != ALE_TYPE_VLAN_ADDR)\n\t\t\tcontinue;\n\t\tif (cpsw_ale_get_vlan_id(ale_entry) != vid)\n\t\t\tcontinue;\n\t\tcpsw_ale_get_addr(ale_entry, entry_addr);\n\t\tif (ether_addr_equal(entry_addr, addr))\n\t\t\treturn idx;\n\t}\n\treturn -ENOENT;\n}\n\nstatic int cpsw_ale_match_vlan(struct cpsw_ale *ale, u16 vid)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS];\n\tint type, idx;\n\n\tfor (idx = 0; idx < ale->params.ale_entries; idx++) {\n\t\tcpsw_ale_read(ale, idx, ale_entry);\n\t\ttype = cpsw_ale_get_entry_type(ale_entry);\n\t\tif (type != ALE_TYPE_VLAN)\n\t\t\tcontinue;\n\t\tif (cpsw_ale_get_vlan_id(ale_entry) == vid)\n\t\t\treturn idx;\n\t}\n\treturn -ENOENT;\n}\n\nstatic int cpsw_ale_match_free(struct cpsw_ale *ale)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS];\n\tint type, idx;\n\n\tfor (idx = 0; idx < ale->params.ale_entries; idx++) {\n\t\tcpsw_ale_read(ale, idx, ale_entry);\n\t\ttype = cpsw_ale_get_entry_type(ale_entry);\n\t\tif (type == ALE_TYPE_FREE)\n\t\t\treturn idx;\n\t}\n\treturn -ENOENT;\n}\n\nstatic int cpsw_ale_find_ageable(struct cpsw_ale *ale)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS];\n\tint type, idx;\n\n\tfor (idx = 0; idx < ale->params.ale_entries; idx++) {\n\t\tcpsw_ale_read(ale, idx, ale_entry);\n\t\ttype = cpsw_ale_get_entry_type(ale_entry);\n\t\tif (type != ALE_TYPE_ADDR && type != ALE_TYPE_VLAN_ADDR)\n\t\t\tcontinue;\n\t\tif (cpsw_ale_get_mcast(ale_entry))\n\t\t\tcontinue;\n\t\ttype = cpsw_ale_get_ucast_type(ale_entry);\n\t\tif (type != ALE_UCAST_PERSISTANT &&\n\t\t    type != ALE_UCAST_OUI)\n\t\t\treturn idx;\n\t}\n\treturn -ENOENT;\n}\n\nstatic void cpsw_ale_flush_mcast(struct cpsw_ale *ale, u32 *ale_entry,\n\t\t\t\t int port_mask)\n{\n\tint mask;\n\n\tmask = cpsw_ale_get_port_mask(ale_entry,\n\t\t\t\t      ale->port_mask_bits);\n\tif ((mask & port_mask) == 0)\n\t\treturn;  \n\tmask &= ~port_mask;\n\n\t \n\tif (mask)\n\t\tcpsw_ale_set_port_mask(ale_entry, mask,\n\t\t\t\t       ale->port_mask_bits);\n\telse\n\t\tcpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);\n}\n\nint cpsw_ale_flush_multicast(struct cpsw_ale *ale, int port_mask, int vid)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS];\n\tint ret, idx;\n\n\tfor (idx = 0; idx < ale->params.ale_entries; idx++) {\n\t\tcpsw_ale_read(ale, idx, ale_entry);\n\t\tret = cpsw_ale_get_entry_type(ale_entry);\n\t\tif (ret != ALE_TYPE_ADDR && ret != ALE_TYPE_VLAN_ADDR)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (vid != -1 && cpsw_ale_get_vlan_id(ale_entry) != vid)\n\t\t\tcontinue;\n\n\t\tif (cpsw_ale_get_mcast(ale_entry)) {\n\t\t\tu8 addr[6];\n\n\t\t\tif (cpsw_ale_get_super(ale_entry))\n\t\t\t\tcontinue;\n\n\t\t\tcpsw_ale_get_addr(ale_entry, addr);\n\t\t\tif (!is_broadcast_ether_addr(addr))\n\t\t\t\tcpsw_ale_flush_mcast(ale, ale_entry, port_mask);\n\t\t}\n\n\t\tcpsw_ale_write(ale, idx, ale_entry);\n\t}\n\treturn 0;\n}\n\nstatic inline void cpsw_ale_set_vlan_entry_type(u32 *ale_entry,\n\t\t\t\t\t\tint flags, u16 vid)\n{\n\tif (flags & ALE_VLAN) {\n\t\tcpsw_ale_set_entry_type(ale_entry, ALE_TYPE_VLAN_ADDR);\n\t\tcpsw_ale_set_vlan_id(ale_entry, vid);\n\t} else {\n\t\tcpsw_ale_set_entry_type(ale_entry, ALE_TYPE_ADDR);\n\t}\n}\n\nint cpsw_ale_add_ucast(struct cpsw_ale *ale, const u8 *addr, int port,\n\t\t       int flags, u16 vid)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};\n\tint idx;\n\n\tcpsw_ale_set_vlan_entry_type(ale_entry, flags, vid);\n\n\tcpsw_ale_set_addr(ale_entry, addr);\n\tcpsw_ale_set_ucast_type(ale_entry, ALE_UCAST_PERSISTANT);\n\tcpsw_ale_set_secure(ale_entry, (flags & ALE_SECURE) ? 1 : 0);\n\tcpsw_ale_set_blocked(ale_entry, (flags & ALE_BLOCKED) ? 1 : 0);\n\tcpsw_ale_set_port_num(ale_entry, port, ale->port_num_bits);\n\n\tidx = cpsw_ale_match_addr(ale, addr, (flags & ALE_VLAN) ? vid : 0);\n\tif (idx < 0)\n\t\tidx = cpsw_ale_match_free(ale);\n\tif (idx < 0)\n\t\tidx = cpsw_ale_find_ageable(ale);\n\tif (idx < 0)\n\t\treturn -ENOMEM;\n\n\tcpsw_ale_write(ale, idx, ale_entry);\n\treturn 0;\n}\n\nint cpsw_ale_del_ucast(struct cpsw_ale *ale, const u8 *addr, int port,\n\t\t       int flags, u16 vid)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};\n\tint idx;\n\n\tidx = cpsw_ale_match_addr(ale, addr, (flags & ALE_VLAN) ? vid : 0);\n\tif (idx < 0)\n\t\treturn -ENOENT;\n\n\tcpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);\n\tcpsw_ale_write(ale, idx, ale_entry);\n\treturn 0;\n}\n\nint cpsw_ale_add_mcast(struct cpsw_ale *ale, const u8 *addr, int port_mask,\n\t\t       int flags, u16 vid, int mcast_state)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};\n\tint idx, mask;\n\n\tidx = cpsw_ale_match_addr(ale, addr, (flags & ALE_VLAN) ? vid : 0);\n\tif (idx >= 0)\n\t\tcpsw_ale_read(ale, idx, ale_entry);\n\n\tcpsw_ale_set_vlan_entry_type(ale_entry, flags, vid);\n\n\tcpsw_ale_set_addr(ale_entry, addr);\n\tcpsw_ale_set_super(ale_entry, (flags & ALE_SUPER) ? 1 : 0);\n\tcpsw_ale_set_mcast_state(ale_entry, mcast_state);\n\n\tmask = cpsw_ale_get_port_mask(ale_entry,\n\t\t\t\t      ale->port_mask_bits);\n\tport_mask |= mask;\n\tcpsw_ale_set_port_mask(ale_entry, port_mask,\n\t\t\t       ale->port_mask_bits);\n\n\tif (idx < 0)\n\t\tidx = cpsw_ale_match_free(ale);\n\tif (idx < 0)\n\t\tidx = cpsw_ale_find_ageable(ale);\n\tif (idx < 0)\n\t\treturn -ENOMEM;\n\n\tcpsw_ale_write(ale, idx, ale_entry);\n\treturn 0;\n}\n\nint cpsw_ale_del_mcast(struct cpsw_ale *ale, const u8 *addr, int port_mask,\n\t\t       int flags, u16 vid)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};\n\tint mcast_members = 0;\n\tint idx;\n\n\tidx = cpsw_ale_match_addr(ale, addr, (flags & ALE_VLAN) ? vid : 0);\n\tif (idx < 0)\n\t\treturn -ENOENT;\n\n\tcpsw_ale_read(ale, idx, ale_entry);\n\n\tif (port_mask) {\n\t\tmcast_members = cpsw_ale_get_port_mask(ale_entry,\n\t\t\t\t\t\t       ale->port_mask_bits);\n\t\tmcast_members &= ~port_mask;\n\t}\n\n\tif (mcast_members)\n\t\tcpsw_ale_set_port_mask(ale_entry, mcast_members,\n\t\t\t\t       ale->port_mask_bits);\n\telse\n\t\tcpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);\n\n\tcpsw_ale_write(ale, idx, ale_entry);\n\treturn 0;\n}\n\n \nstatic void cpsw_ale_set_vlan_mcast(struct cpsw_ale *ale, u32 *ale_entry,\n\t\t\t\t    int reg_mcast, int unreg_mcast)\n{\n\tint idx;\n\n\t \n\tidx = cpsw_ale_vlan_get_fld(ale, ale_entry,\n\t\t\t\t    ALE_ENT_VID_REG_MCAST_IDX);\n\twritel(reg_mcast, ale->params.ale_regs + ALE_VLAN_MASK_MUX(idx));\n\n\t \n\tidx = cpsw_ale_vlan_get_fld(ale, ale_entry,\n\t\t\t\t    ALE_ENT_VID_UNREG_MCAST_IDX);\n\twritel(unreg_mcast, ale->params.ale_regs + ALE_VLAN_MASK_MUX(idx));\n}\n\nstatic void cpsw_ale_set_vlan_untag(struct cpsw_ale *ale, u32 *ale_entry,\n\t\t\t\t    u16 vid, int untag_mask)\n{\n\tcpsw_ale_vlan_set_fld(ale, ale_entry,\n\t\t\t      ALE_ENT_VID_FORCE_UNTAGGED_MSK,\n\t\t\t      untag_mask);\n\tif (untag_mask & ALE_PORT_HOST)\n\t\tbitmap_set(ale->p0_untag_vid_mask, vid, 1);\n\telse\n\t\tbitmap_clear(ale->p0_untag_vid_mask, vid, 1);\n}\n\nint cpsw_ale_add_vlan(struct cpsw_ale *ale, u16 vid, int port_mask, int untag,\n\t\t      int reg_mcast, int unreg_mcast)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};\n\tint idx;\n\n\tidx = cpsw_ale_match_vlan(ale, vid);\n\tif (idx >= 0)\n\t\tcpsw_ale_read(ale, idx, ale_entry);\n\n\tcpsw_ale_set_entry_type(ale_entry, ALE_TYPE_VLAN);\n\tcpsw_ale_set_vlan_id(ale_entry, vid);\n\tcpsw_ale_set_vlan_untag(ale, ale_entry, vid, untag);\n\n\tif (!ale->params.nu_switch_ale) {\n\t\tcpsw_ale_vlan_set_fld(ale, ale_entry,\n\t\t\t\t      ALE_ENT_VID_REG_MCAST_MSK, reg_mcast);\n\t\tcpsw_ale_vlan_set_fld(ale, ale_entry,\n\t\t\t\t      ALE_ENT_VID_UNREG_MCAST_MSK, unreg_mcast);\n\t} else {\n\t\tcpsw_ale_vlan_set_fld(ale, ale_entry,\n\t\t\t\t      ALE_ENT_VID_UNREG_MCAST_IDX,\n\t\t\t\t      NU_VLAN_UNREG_MCAST_IDX);\n\t\tcpsw_ale_set_vlan_mcast(ale, ale_entry, reg_mcast, unreg_mcast);\n\t}\n\n\tcpsw_ale_vlan_set_fld(ale, ale_entry,\n\t\t\t      ALE_ENT_VID_MEMBER_LIST, port_mask);\n\n\tif (idx < 0)\n\t\tidx = cpsw_ale_match_free(ale);\n\tif (idx < 0)\n\t\tidx = cpsw_ale_find_ageable(ale);\n\tif (idx < 0)\n\t\treturn -ENOMEM;\n\n\tcpsw_ale_write(ale, idx, ale_entry);\n\treturn 0;\n}\n\nstatic void cpsw_ale_vlan_del_modify_int(struct cpsw_ale *ale,  u32 *ale_entry,\n\t\t\t\t\t u16 vid, int port_mask)\n{\n\tint reg_mcast, unreg_mcast;\n\tint members, untag;\n\n\tmembers = cpsw_ale_vlan_get_fld(ale, ale_entry,\n\t\t\t\t\tALE_ENT_VID_MEMBER_LIST);\n\tmembers &= ~port_mask;\n\tif (!members) {\n\t\tcpsw_ale_set_vlan_untag(ale, ale_entry, vid, 0);\n\t\tcpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);\n\t\treturn;\n\t}\n\n\tuntag = cpsw_ale_vlan_get_fld(ale, ale_entry,\n\t\t\t\t      ALE_ENT_VID_FORCE_UNTAGGED_MSK);\n\treg_mcast = cpsw_ale_vlan_get_fld(ale, ale_entry,\n\t\t\t\t\t  ALE_ENT_VID_REG_MCAST_MSK);\n\tunreg_mcast = cpsw_ale_vlan_get_fld(ale, ale_entry,\n\t\t\t\t\t    ALE_ENT_VID_UNREG_MCAST_MSK);\n\tuntag &= members;\n\treg_mcast &= members;\n\tunreg_mcast &= members;\n\n\tcpsw_ale_set_vlan_untag(ale, ale_entry, vid, untag);\n\n\tif (!ale->params.nu_switch_ale) {\n\t\tcpsw_ale_vlan_set_fld(ale, ale_entry,\n\t\t\t\t      ALE_ENT_VID_REG_MCAST_MSK, reg_mcast);\n\t\tcpsw_ale_vlan_set_fld(ale, ale_entry,\n\t\t\t\t      ALE_ENT_VID_UNREG_MCAST_MSK, unreg_mcast);\n\t} else {\n\t\tcpsw_ale_set_vlan_mcast(ale, ale_entry, reg_mcast,\n\t\t\t\t\tunreg_mcast);\n\t}\n\tcpsw_ale_vlan_set_fld(ale, ale_entry,\n\t\t\t      ALE_ENT_VID_MEMBER_LIST, members);\n}\n\nint cpsw_ale_vlan_del_modify(struct cpsw_ale *ale, u16 vid, int port_mask)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};\n\tint idx;\n\n\tidx = cpsw_ale_match_vlan(ale, vid);\n\tif (idx < 0)\n\t\treturn -ENOENT;\n\n\tcpsw_ale_read(ale, idx, ale_entry);\n\n\tcpsw_ale_vlan_del_modify_int(ale, ale_entry, vid, port_mask);\n\tcpsw_ale_write(ale, idx, ale_entry);\n\n\treturn 0;\n}\n\nint cpsw_ale_del_vlan(struct cpsw_ale *ale, u16 vid, int port_mask)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};\n\tint members, idx;\n\n\tidx = cpsw_ale_match_vlan(ale, vid);\n\tif (idx < 0)\n\t\treturn -ENOENT;\n\n\tcpsw_ale_read(ale, idx, ale_entry);\n\n\t \n\tmembers = cpsw_ale_vlan_get_fld(ale, ale_entry, ALE_ENT_VID_MEMBER_LIST);\n\tmembers &= ~port_mask;\n\n\tif (!port_mask || !members) {\n\t\t \n\t\tcpsw_ale_set_vlan_untag(ale, ale_entry, vid, 0);\n\t\tcpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);\n\t} else {\n\t\tport_mask &= ~ALE_PORT_HOST;\n\t\tcpsw_ale_vlan_del_modify_int(ale, ale_entry, vid, port_mask);\n\t}\n\n\tcpsw_ale_write(ale, idx, ale_entry);\n\n\treturn 0;\n}\n\nint cpsw_ale_vlan_add_modify(struct cpsw_ale *ale, u16 vid, int port_mask,\n\t\t\t     int untag_mask, int reg_mask, int unreg_mask)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};\n\tint reg_mcast_members, unreg_mcast_members;\n\tint vlan_members, untag_members;\n\tint idx, ret = 0;\n\n\tidx = cpsw_ale_match_vlan(ale, vid);\n\tif (idx >= 0)\n\t\tcpsw_ale_read(ale, idx, ale_entry);\n\n\tvlan_members = cpsw_ale_vlan_get_fld(ale, ale_entry,\n\t\t\t\t\t     ALE_ENT_VID_MEMBER_LIST);\n\treg_mcast_members = cpsw_ale_vlan_get_fld(ale, ale_entry,\n\t\t\t\t\t\t  ALE_ENT_VID_REG_MCAST_MSK);\n\tunreg_mcast_members =\n\t\tcpsw_ale_vlan_get_fld(ale, ale_entry,\n\t\t\t\t      ALE_ENT_VID_UNREG_MCAST_MSK);\n\tuntag_members = cpsw_ale_vlan_get_fld(ale, ale_entry,\n\t\t\t\t\t      ALE_ENT_VID_FORCE_UNTAGGED_MSK);\n\n\tvlan_members |= port_mask;\n\tuntag_members = (untag_members & ~port_mask) | untag_mask;\n\treg_mcast_members = (reg_mcast_members & ~port_mask) | reg_mask;\n\tunreg_mcast_members = (unreg_mcast_members & ~port_mask) | unreg_mask;\n\n\tret = cpsw_ale_add_vlan(ale, vid, vlan_members, untag_members,\n\t\t\t\treg_mcast_members, unreg_mcast_members);\n\tif (ret) {\n\t\tdev_err(ale->params.dev, \"Unable to add vlan\\n\");\n\t\treturn ret;\n\t}\n\tdev_dbg(ale->params.dev, \"port mask 0x%x untag 0x%x\\n\", vlan_members,\n\t\tuntag_mask);\n\n\treturn ret;\n}\n\nvoid cpsw_ale_set_unreg_mcast(struct cpsw_ale *ale, int unreg_mcast_mask,\n\t\t\t      bool add)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS];\n\tint unreg_members = 0;\n\tint type, idx;\n\n\tfor (idx = 0; idx < ale->params.ale_entries; idx++) {\n\t\tcpsw_ale_read(ale, idx, ale_entry);\n\t\ttype = cpsw_ale_get_entry_type(ale_entry);\n\t\tif (type != ALE_TYPE_VLAN)\n\t\t\tcontinue;\n\n\t\tunreg_members =\n\t\t\tcpsw_ale_vlan_get_fld(ale, ale_entry,\n\t\t\t\t\t      ALE_ENT_VID_UNREG_MCAST_MSK);\n\t\tif (add)\n\t\t\tunreg_members |= unreg_mcast_mask;\n\t\telse\n\t\t\tunreg_members &= ~unreg_mcast_mask;\n\t\tcpsw_ale_vlan_set_fld(ale, ale_entry,\n\t\t\t\t      ALE_ENT_VID_UNREG_MCAST_MSK,\n\t\t\t\t      unreg_members);\n\t\tcpsw_ale_write(ale, idx, ale_entry);\n\t}\n}\n\nstatic void cpsw_ale_vlan_set_unreg_mcast(struct cpsw_ale *ale, u32 *ale_entry,\n\t\t\t\t\t  int allmulti)\n{\n\tint unreg_mcast;\n\n\tunreg_mcast = cpsw_ale_vlan_get_fld(ale, ale_entry,\n\t\t\t\t\t    ALE_ENT_VID_UNREG_MCAST_MSK);\n\tif (allmulti)\n\t\tunreg_mcast |= ALE_PORT_HOST;\n\telse\n\t\tunreg_mcast &= ~ALE_PORT_HOST;\n\n\tcpsw_ale_vlan_set_fld(ale, ale_entry,\n\t\t\t      ALE_ENT_VID_UNREG_MCAST_MSK, unreg_mcast);\n}\n\nstatic void\ncpsw_ale_vlan_set_unreg_mcast_idx(struct cpsw_ale *ale, u32 *ale_entry,\n\t\t\t\t  int allmulti)\n{\n\tint unreg_mcast;\n\tint idx;\n\n\tidx = cpsw_ale_vlan_get_fld(ale, ale_entry,\n\t\t\t\t    ALE_ENT_VID_UNREG_MCAST_IDX);\n\n\tunreg_mcast = readl(ale->params.ale_regs + ALE_VLAN_MASK_MUX(idx));\n\n\tif (allmulti)\n\t\tunreg_mcast |= ALE_PORT_HOST;\n\telse\n\t\tunreg_mcast &= ~ALE_PORT_HOST;\n\n\twritel(unreg_mcast, ale->params.ale_regs + ALE_VLAN_MASK_MUX(idx));\n}\n\nvoid cpsw_ale_set_allmulti(struct cpsw_ale *ale, int allmulti, int port)\n{\n\tu32 ale_entry[ALE_ENTRY_WORDS];\n\tint type, idx;\n\n\tfor (idx = 0; idx < ale->params.ale_entries; idx++) {\n\t\tint vlan_members;\n\n\t\tcpsw_ale_read(ale, idx, ale_entry);\n\t\ttype = cpsw_ale_get_entry_type(ale_entry);\n\t\tif (type != ALE_TYPE_VLAN)\n\t\t\tcontinue;\n\n\t\tvlan_members = cpsw_ale_vlan_get_fld(ale, ale_entry,\n\t\t\t\t\t\t     ALE_ENT_VID_MEMBER_LIST);\n\n\t\tif (port != -1 && !(vlan_members & BIT(port)))\n\t\t\tcontinue;\n\n\t\tif (!ale->params.nu_switch_ale)\n\t\t\tcpsw_ale_vlan_set_unreg_mcast(ale, ale_entry, allmulti);\n\t\telse\n\t\t\tcpsw_ale_vlan_set_unreg_mcast_idx(ale, ale_entry,\n\t\t\t\t\t\t\t  allmulti);\n\n\t\tcpsw_ale_write(ale, idx, ale_entry);\n\t}\n}\n\nstruct ale_control_info {\n\tconst char\t*name;\n\tint\t\toffset, port_offset;\n\tint\t\tshift, port_shift;\n\tint\t\tbits;\n};\n\nstatic struct ale_control_info ale_controls[ALE_NUM_CONTROLS] = {\n\t[ALE_ENABLE]\t\t= {\n\t\t.name\t\t= \"enable\",\n\t\t.offset\t\t= ALE_CONTROL,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 31,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_CLEAR]\t\t= {\n\t\t.name\t\t= \"clear\",\n\t\t.offset\t\t= ALE_CONTROL,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 30,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_AGEOUT]\t\t= {\n\t\t.name\t\t= \"ageout\",\n\t\t.offset\t\t= ALE_CONTROL,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 29,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_P0_UNI_FLOOD]\t= {\n\t\t.name\t\t= \"port0_unicast_flood\",\n\t\t.offset\t\t= ALE_CONTROL,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 8,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_VLAN_NOLEARN]\t= {\n\t\t.name\t\t= \"vlan_nolearn\",\n\t\t.offset\t\t= ALE_CONTROL,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 7,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_NO_PORT_VLAN]\t= {\n\t\t.name\t\t= \"no_port_vlan\",\n\t\t.offset\t\t= ALE_CONTROL,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 6,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_OUI_DENY]\t\t= {\n\t\t.name\t\t= \"oui_deny\",\n\t\t.offset\t\t= ALE_CONTROL,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 5,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_BYPASS]\t\t= {\n\t\t.name\t\t= \"bypass\",\n\t\t.offset\t\t= ALE_CONTROL,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 4,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_RATE_LIMIT_TX]\t= {\n\t\t.name\t\t= \"rate_limit_tx\",\n\t\t.offset\t\t= ALE_CONTROL,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 3,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_VLAN_AWARE]\t= {\n\t\t.name\t\t= \"vlan_aware\",\n\t\t.offset\t\t= ALE_CONTROL,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 2,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_AUTH_ENABLE]\t= {\n\t\t.name\t\t= \"auth_enable\",\n\t\t.offset\t\t= ALE_CONTROL,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 1,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_RATE_LIMIT]\t= {\n\t\t.name\t\t= \"rate_limit\",\n\t\t.offset\t\t= ALE_CONTROL,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 0,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_PORT_STATE]\t= {\n\t\t.name\t\t= \"port_state\",\n\t\t.offset\t\t= ALE_PORTCTL,\n\t\t.port_offset\t= 4,\n\t\t.shift\t\t= 0,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 2,\n\t},\n\t[ALE_PORT_DROP_UNTAGGED] = {\n\t\t.name\t\t= \"drop_untagged\",\n\t\t.offset\t\t= ALE_PORTCTL,\n\t\t.port_offset\t= 4,\n\t\t.shift\t\t= 2,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_PORT_DROP_UNKNOWN_VLAN] = {\n\t\t.name\t\t= \"drop_unknown\",\n\t\t.offset\t\t= ALE_PORTCTL,\n\t\t.port_offset\t= 4,\n\t\t.shift\t\t= 3,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_PORT_NOLEARN]\t= {\n\t\t.name\t\t= \"nolearn\",\n\t\t.offset\t\t= ALE_PORTCTL,\n\t\t.port_offset\t= 4,\n\t\t.shift\t\t= 4,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_PORT_NO_SA_UPDATE]\t= {\n\t\t.name\t\t= \"no_source_update\",\n\t\t.offset\t\t= ALE_PORTCTL,\n\t\t.port_offset\t= 4,\n\t\t.shift\t\t= 5,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_PORT_MACONLY]\t= {\n\t\t.name\t\t= \"mac_only_port_mode\",\n\t\t.offset\t\t= ALE_PORTCTL,\n\t\t.port_offset\t= 4,\n\t\t.shift\t\t= 11,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_PORT_MACONLY_CAF]\t= {\n\t\t.name\t\t= \"mac_only_port_caf\",\n\t\t.offset\t\t= ALE_PORTCTL,\n\t\t.port_offset\t= 4,\n\t\t.shift\t\t= 13,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n\t[ALE_PORT_MCAST_LIMIT]\t= {\n\t\t.name\t\t= \"mcast_limit\",\n\t\t.offset\t\t= ALE_PORTCTL,\n\t\t.port_offset\t= 4,\n\t\t.shift\t\t= 16,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 8,\n\t},\n\t[ALE_PORT_BCAST_LIMIT]\t= {\n\t\t.name\t\t= \"bcast_limit\",\n\t\t.offset\t\t= ALE_PORTCTL,\n\t\t.port_offset\t= 4,\n\t\t.shift\t\t= 24,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 8,\n\t},\n\t[ALE_PORT_UNKNOWN_VLAN_MEMBER] = {\n\t\t.name\t\t= \"unknown_vlan_member\",\n\t\t.offset\t\t= ALE_UNKNOWNVLAN,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 0,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 6,\n\t},\n\t[ALE_PORT_UNKNOWN_MCAST_FLOOD] = {\n\t\t.name\t\t= \"unknown_mcast_flood\",\n\t\t.offset\t\t= ALE_UNKNOWNVLAN,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 8,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 6,\n\t},\n\t[ALE_PORT_UNKNOWN_REG_MCAST_FLOOD] = {\n\t\t.name\t\t= \"unknown_reg_flood\",\n\t\t.offset\t\t= ALE_UNKNOWNVLAN,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 16,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 6,\n\t},\n\t[ALE_PORT_UNTAGGED_EGRESS] = {\n\t\t.name\t\t= \"untagged_egress\",\n\t\t.offset\t\t= ALE_UNKNOWNVLAN,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 24,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 6,\n\t},\n\t[ALE_DEFAULT_THREAD_ID] = {\n\t\t.name\t\t= \"default_thread_id\",\n\t\t.offset\t\t= AM65_CPSW_ALE_THREAD_DEF_REG,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 0,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 6,\n\t},\n\t[ALE_DEFAULT_THREAD_ENABLE] = {\n\t\t.name\t\t= \"default_thread_id_enable\",\n\t\t.offset\t\t= AM65_CPSW_ALE_THREAD_DEF_REG,\n\t\t.port_offset\t= 0,\n\t\t.shift\t\t= 15,\n\t\t.port_shift\t= 0,\n\t\t.bits\t\t= 1,\n\t},\n};\n\nint cpsw_ale_control_set(struct cpsw_ale *ale, int port, int control,\n\t\t\t int value)\n{\n\tconst struct ale_control_info *info;\n\tint offset, shift;\n\tu32 tmp, mask;\n\n\tif (control < 0 || control >= ARRAY_SIZE(ale_controls))\n\t\treturn -EINVAL;\n\n\tinfo = &ale_controls[control];\n\tif (info->port_offset == 0 && info->port_shift == 0)\n\t\tport = 0;  \n\n\tif (port < 0 || port >= ale->params.ale_ports)\n\t\treturn -EINVAL;\n\n\tmask = BITMASK(info->bits);\n\tif (value & ~mask)\n\t\treturn -EINVAL;\n\n\toffset = info->offset + (port * info->port_offset);\n\tshift  = info->shift  + (port * info->port_shift);\n\n\ttmp = readl_relaxed(ale->params.ale_regs + offset);\n\ttmp = (tmp & ~(mask << shift)) | (value << shift);\n\twritel_relaxed(tmp, ale->params.ale_regs + offset);\n\n\treturn 0;\n}\n\nint cpsw_ale_control_get(struct cpsw_ale *ale, int port, int control)\n{\n\tconst struct ale_control_info *info;\n\tint offset, shift;\n\tu32 tmp;\n\n\tif (control < 0 || control >= ARRAY_SIZE(ale_controls))\n\t\treturn -EINVAL;\n\n\tinfo = &ale_controls[control];\n\tif (info->port_offset == 0 && info->port_shift == 0)\n\t\tport = 0;  \n\n\tif (port < 0 || port >= ale->params.ale_ports)\n\t\treturn -EINVAL;\n\n\toffset = info->offset + (port * info->port_offset);\n\tshift  = info->shift  + (port * info->port_shift);\n\n\ttmp = readl_relaxed(ale->params.ale_regs + offset) >> shift;\n\treturn tmp & BITMASK(info->bits);\n}\n\nint cpsw_ale_rx_ratelimit_mc(struct cpsw_ale *ale, int port, unsigned int ratelimit_pps)\n\n{\n\tint val = ratelimit_pps / ALE_RATE_LIMIT_MIN_PPS;\n\tu32 remainder = ratelimit_pps % ALE_RATE_LIMIT_MIN_PPS;\n\n\tif (ratelimit_pps && !val) {\n\t\tdev_err(ale->params.dev, \"ALE MC port:%d ratelimit min value 1000pps\\n\", port);\n\t\treturn -EINVAL;\n\t}\n\n\tif (remainder)\n\t\tdev_info(ale->params.dev, \"ALE port:%d MC ratelimit set to %dpps (requested %d)\\n\",\n\t\t\t port, ratelimit_pps - remainder, ratelimit_pps);\n\n\tcpsw_ale_control_set(ale, port, ALE_PORT_MCAST_LIMIT, val);\n\n\tdev_dbg(ale->params.dev, \"ALE port:%d MC ratelimit set %d\\n\",\n\t\tport, val * ALE_RATE_LIMIT_MIN_PPS);\n\treturn 0;\n}\n\nint cpsw_ale_rx_ratelimit_bc(struct cpsw_ale *ale, int port, unsigned int ratelimit_pps)\n\n{\n\tint val = ratelimit_pps / ALE_RATE_LIMIT_MIN_PPS;\n\tu32 remainder = ratelimit_pps % ALE_RATE_LIMIT_MIN_PPS;\n\n\tif (ratelimit_pps && !val) {\n\t\tdev_err(ale->params.dev, \"ALE port:%d BC ratelimit min value 1000pps\\n\", port);\n\t\treturn -EINVAL;\n\t}\n\n\tif (remainder)\n\t\tdev_info(ale->params.dev, \"ALE port:%d BC ratelimit set to %dpps (requested %d)\\n\",\n\t\t\t port, ratelimit_pps - remainder, ratelimit_pps);\n\n\tcpsw_ale_control_set(ale, port, ALE_PORT_BCAST_LIMIT, val);\n\n\tdev_dbg(ale->params.dev, \"ALE port:%d BC ratelimit set %d\\n\",\n\t\tport, val * ALE_RATE_LIMIT_MIN_PPS);\n\treturn 0;\n}\n\nstatic void cpsw_ale_timer(struct timer_list *t)\n{\n\tstruct cpsw_ale *ale = from_timer(ale, t, timer);\n\n\tcpsw_ale_control_set(ale, 0, ALE_AGEOUT, 1);\n\n\tif (ale->ageout) {\n\t\tale->timer.expires = jiffies + ale->ageout;\n\t\tadd_timer(&ale->timer);\n\t}\n}\n\nstatic void cpsw_ale_hw_aging_timer_start(struct cpsw_ale *ale)\n{\n\tu32 aging_timer;\n\n\taging_timer = ale->params.bus_freq / 1000000;\n\taging_timer *= ale->params.ale_ageout;\n\n\tif (aging_timer & ~ALE_AGING_TIMER_MASK) {\n\t\taging_timer = ALE_AGING_TIMER_MASK;\n\t\tdev_warn(ale->params.dev,\n\t\t\t \"ALE aging timer overflow, set to max\\n\");\n\t}\n\n\twritel(aging_timer, ale->params.ale_regs + ALE_AGING_TIMER);\n}\n\nstatic void cpsw_ale_hw_aging_timer_stop(struct cpsw_ale *ale)\n{\n\twritel(0, ale->params.ale_regs + ALE_AGING_TIMER);\n}\n\nstatic void cpsw_ale_aging_start(struct cpsw_ale *ale)\n{\n\tif (!ale->params.ale_ageout)\n\t\treturn;\n\n\tif (ale->features & CPSW_ALE_F_HW_AUTOAGING) {\n\t\tcpsw_ale_hw_aging_timer_start(ale);\n\t\treturn;\n\t}\n\n\ttimer_setup(&ale->timer, cpsw_ale_timer, 0);\n\tale->timer.expires = jiffies + ale->ageout;\n\tadd_timer(&ale->timer);\n}\n\nstatic void cpsw_ale_aging_stop(struct cpsw_ale *ale)\n{\n\tif (!ale->params.ale_ageout)\n\t\treturn;\n\n\tif (ale->features & CPSW_ALE_F_HW_AUTOAGING) {\n\t\tcpsw_ale_hw_aging_timer_stop(ale);\n\t\treturn;\n\t}\n\n\tdel_timer_sync(&ale->timer);\n}\n\nvoid cpsw_ale_start(struct cpsw_ale *ale)\n{\n\tunsigned long ale_prescale;\n\n\t \n\tale_prescale = ale->params.bus_freq / ALE_RATE_LIMIT_MIN_PPS;\n\twritel((u32)ale_prescale, ale->params.ale_regs + ALE_PRESCALE);\n\n\t \n\tcpsw_ale_control_set(ale, 0, ALE_RATE_LIMIT, 1);\n\n\tcpsw_ale_control_set(ale, 0, ALE_ENABLE, 1);\n\tcpsw_ale_control_set(ale, 0, ALE_CLEAR, 1);\n\n\tcpsw_ale_aging_start(ale);\n}\n\nvoid cpsw_ale_stop(struct cpsw_ale *ale)\n{\n\tcpsw_ale_aging_stop(ale);\n\tcpsw_ale_control_set(ale, 0, ALE_CLEAR, 1);\n\tcpsw_ale_control_set(ale, 0, ALE_ENABLE, 0);\n}\n\nstatic const struct cpsw_ale_dev_id cpsw_ale_id_match[] = {\n\t{\n\t\t \n\t\t.dev_id = \"cpsw\",\n\t\t.tbl_entries = 1024,\n\t\t.major_ver_mask = 0xff,\n\t\t.vlan_entry_tbl = vlan_entry_cpsw,\n\t},\n\t{\n\t\t \n\t\t.dev_id = \"66ak2h-xgbe\",\n\t\t.tbl_entries = 2048,\n\t\t.major_ver_mask = 0xff,\n\t\t.vlan_entry_tbl = vlan_entry_cpsw,\n\t},\n\t{\n\t\t.dev_id = \"66ak2el\",\n\t\t.features = CPSW_ALE_F_STATUS_REG,\n\t\t.major_ver_mask = 0x7,\n\t\t.nu_switch_ale = true,\n\t\t.vlan_entry_tbl = vlan_entry_nu,\n\t},\n\t{\n\t\t.dev_id = \"66ak2g\",\n\t\t.features = CPSW_ALE_F_STATUS_REG,\n\t\t.tbl_entries = 64,\n\t\t.major_ver_mask = 0x7,\n\t\t.nu_switch_ale = true,\n\t\t.vlan_entry_tbl = vlan_entry_nu,\n\t},\n\t{\n\t\t.dev_id = \"am65x-cpsw2g\",\n\t\t.features = CPSW_ALE_F_STATUS_REG | CPSW_ALE_F_HW_AUTOAGING,\n\t\t.tbl_entries = 64,\n\t\t.major_ver_mask = 0x7,\n\t\t.nu_switch_ale = true,\n\t\t.vlan_entry_tbl = vlan_entry_nu,\n\t},\n\t{\n\t\t.dev_id = \"j721e-cpswxg\",\n\t\t.features = CPSW_ALE_F_STATUS_REG | CPSW_ALE_F_HW_AUTOAGING,\n\t\t.major_ver_mask = 0x7,\n\t\t.vlan_entry_tbl = vlan_entry_k3_cpswxg,\n\t},\n\t{\n\t\t.dev_id = \"am64-cpswxg\",\n\t\t.features = CPSW_ALE_F_STATUS_REG | CPSW_ALE_F_HW_AUTOAGING,\n\t\t.major_ver_mask = 0x7,\n\t\t.vlan_entry_tbl = vlan_entry_k3_cpswxg,\n\t\t.tbl_entries = 512,\n\t},\n\t{ },\n};\n\nstatic const struct\ncpsw_ale_dev_id *cpsw_ale_match_id(const struct cpsw_ale_dev_id *id,\n\t\t\t\t   const char *dev_id)\n{\n\tif (!dev_id)\n\t\treturn NULL;\n\n\twhile (id->dev_id) {\n\t\tif (strcmp(dev_id, id->dev_id) == 0)\n\t\t\treturn id;\n\t\tid++;\n\t}\n\treturn NULL;\n}\n\nstruct cpsw_ale *cpsw_ale_create(struct cpsw_ale_params *params)\n{\n\tconst struct cpsw_ale_dev_id *ale_dev_id;\n\tstruct cpsw_ale *ale;\n\tu32 rev, ale_entries;\n\n\tale_dev_id = cpsw_ale_match_id(cpsw_ale_id_match, params->dev_id);\n\tif (!ale_dev_id)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tparams->ale_entries = ale_dev_id->tbl_entries;\n\tparams->major_ver_mask = ale_dev_id->major_ver_mask;\n\tparams->nu_switch_ale = ale_dev_id->nu_switch_ale;\n\n\tale = devm_kzalloc(params->dev, sizeof(*ale), GFP_KERNEL);\n\tif (!ale)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tale->p0_untag_vid_mask = devm_bitmap_zalloc(params->dev, VLAN_N_VID,\n\t\t\t\t\t\t    GFP_KERNEL);\n\tif (!ale->p0_untag_vid_mask)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tale->params = *params;\n\tale->ageout = ale->params.ale_ageout * HZ;\n\tale->features = ale_dev_id->features;\n\tale->vlan_entry_tbl = ale_dev_id->vlan_entry_tbl;\n\n\trev = readl_relaxed(ale->params.ale_regs + ALE_IDVER);\n\tale->version =\n\t\t(ALE_VERSION_MAJOR(rev, ale->params.major_ver_mask) << 8) |\n\t\t ALE_VERSION_MINOR(rev);\n\tdev_info(ale->params.dev, \"initialized cpsw ale version %d.%d\\n\",\n\t\t ALE_VERSION_MAJOR(rev, ale->params.major_ver_mask),\n\t\t ALE_VERSION_MINOR(rev));\n\n\tif (ale->features & CPSW_ALE_F_STATUS_REG &&\n\t    !ale->params.ale_entries) {\n\t\tale_entries =\n\t\t\treadl_relaxed(ale->params.ale_regs + ALE_STATUS) &\n\t\t\tALE_STATUS_SIZE_MASK;\n\t\t \n\t\tif (!ale_entries)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tale_entries *= ALE_TABLE_SIZE_MULTIPLIER;\n\t\tale->params.ale_entries = ale_entries;\n\t}\n\tdev_info(ale->params.dev,\n\t\t \"ALE Table size %ld\\n\", ale->params.ale_entries);\n\n\t \n\tale->port_mask_bits = ale->params.ale_ports;\n\tale->port_num_bits = order_base_2(ale->params.ale_ports);\n\tale->vlan_field_bits = ale->params.ale_ports;\n\n\t \n\tif (ale->params.nu_switch_ale) {\n\t\t \n\t\tale_controls[ALE_PORT_UNKNOWN_VLAN_MEMBER].bits =\n\t\t\t\t\tale->params.ale_ports;\n\t\tale_controls[ALE_PORT_UNKNOWN_VLAN_MEMBER].offset =\n\t\t\t\t\tALE_UNKNOWNVLAN_MEMBER;\n\t\tale_controls[ALE_PORT_UNKNOWN_MCAST_FLOOD].bits =\n\t\t\t\t\tale->params.ale_ports;\n\t\tale_controls[ALE_PORT_UNKNOWN_MCAST_FLOOD].shift = 0;\n\t\tale_controls[ALE_PORT_UNKNOWN_MCAST_FLOOD].offset =\n\t\t\t\t\tALE_UNKNOWNVLAN_UNREG_MCAST_FLOOD;\n\t\tale_controls[ALE_PORT_UNKNOWN_REG_MCAST_FLOOD].bits =\n\t\t\t\t\tale->params.ale_ports;\n\t\tale_controls[ALE_PORT_UNKNOWN_REG_MCAST_FLOOD].shift = 0;\n\t\tale_controls[ALE_PORT_UNKNOWN_REG_MCAST_FLOOD].offset =\n\t\t\t\t\tALE_UNKNOWNVLAN_REG_MCAST_FLOOD;\n\t\tale_controls[ALE_PORT_UNTAGGED_EGRESS].bits =\n\t\t\t\t\tale->params.ale_ports;\n\t\tale_controls[ALE_PORT_UNTAGGED_EGRESS].shift = 0;\n\t\tale_controls[ALE_PORT_UNTAGGED_EGRESS].offset =\n\t\t\t\t\tALE_UNKNOWNVLAN_FORCE_UNTAG_EGRESS;\n\t}\n\n\tcpsw_ale_control_set(ale, 0, ALE_CLEAR, 1);\n\treturn ale;\n}\n\nvoid cpsw_ale_dump(struct cpsw_ale *ale, u32 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ale->params.ale_entries; i++) {\n\t\tcpsw_ale_read(ale, i, data);\n\t\tdata += ALE_ENTRY_WORDS;\n\t}\n}\n\nvoid cpsw_ale_restore(struct cpsw_ale *ale, u32 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ale->params.ale_entries; i++) {\n\t\tcpsw_ale_write(ale, i, data);\n\t\tdata += ALE_ENTRY_WORDS;\n\t}\n}\n\nu32 cpsw_ale_get_num_entries(struct cpsw_ale *ale)\n{\n\treturn ale ? ale->params.ale_entries : 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}