{
  "module_name": "davinci_emac.c",
  "hash_id": "61cb35011b99ef1a2871db278bf81dcb58ec53fe205e4183e0eb8513033d0640",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/davinci_emac.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/ethtool.h>\n#include <linux/highmem.h>\n#include <linux/proc_fs.h>\n#include <linux/ctype.h>\n#include <linux/spinlock.h>\n#include <linux/dma-mapping.h>\n#include <linux/clk.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/semaphore.h>\n#include <linux/phy.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/pm_runtime.h>\n#include <linux/davinci_emac.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_mdio.h>\n#include <linux/of_irq.h>\n#include <linux/of_net.h>\n#include <linux/mfd/syscon.h>\n\n#include <asm/irq.h>\n#include <asm/page.h>\n\n#include \"cpsw.h\"\n#include \"davinci_cpdma.h\"\n\nstatic int debug_level;\nmodule_param(debug_level, int, 0);\nMODULE_PARM_DESC(debug_level, \"DaVinci EMAC debug level (NETIF_MSG bits)\");\n\n \n#define DAVINCI_EMAC_DEBUG\t(NETIF_MSG_DRV | \\\n\t\t\t\tNETIF_MSG_PROBE | \\\n\t\t\t\tNETIF_MSG_LINK | \\\n\t\t\t\tNETIF_MSG_TIMER | \\\n\t\t\t\tNETIF_MSG_IFDOWN | \\\n\t\t\t\tNETIF_MSG_IFUP | \\\n\t\t\t\tNETIF_MSG_RX_ERR | \\\n\t\t\t\tNETIF_MSG_TX_ERR | \\\n\t\t\t\tNETIF_MSG_TX_QUEUED | \\\n\t\t\t\tNETIF_MSG_INTR | \\\n\t\t\t\tNETIF_MSG_TX_DONE | \\\n\t\t\t\tNETIF_MSG_RX_STATUS | \\\n\t\t\t\tNETIF_MSG_PKTDATA | \\\n\t\t\t\tNETIF_MSG_HW | \\\n\t\t\t\tNETIF_MSG_WOL)\n\n \n#define EMAC_MAJOR_VERSION\t6\n#define EMAC_MINOR_VERSION\t1\n#define EMAC_MODULE_VERSION\t\"6.1\"\nMODULE_VERSION(EMAC_MODULE_VERSION);\nstatic const char emac_version_string[] = \"TI DaVinci EMAC Linux v6.1\";\n\n \n#define EMAC_DEF_PASS_CRC\t\t(0)  \n#define EMAC_DEF_QOS_EN\t\t\t(0)  \n#define EMAC_DEF_NO_BUFF_CHAIN\t\t(0)  \n#define EMAC_DEF_MACCTRL_FRAME_EN\t(0)  \n#define EMAC_DEF_SHORT_FRAME_EN\t\t(0)  \n#define EMAC_DEF_ERROR_FRAME_EN\t\t(0)  \n#define EMAC_DEF_PROM_EN\t\t(0)  \n#define EMAC_DEF_PROM_CH\t\t(0)  \n#define EMAC_DEF_BCAST_EN\t\t(1)  \n#define EMAC_DEF_BCAST_CH\t\t(0)  \n#define EMAC_DEF_MCAST_EN\t\t(1)  \n#define EMAC_DEF_MCAST_CH\t\t(0)  \n\n#define EMAC_DEF_TXPRIO_FIXED\t\t(1)  \n#define EMAC_DEF_TXPACING_EN\t\t(0)  \n\n#define EMAC_DEF_BUFFER_OFFSET\t\t(0)  \n#define EMAC_DEF_MIN_ETHPKTSIZE\t\t(60)  \n#define EMAC_DEF_MAX_FRAME_SIZE\t\t(1500 + 14 + 4 + 4)\n#define EMAC_DEF_TX_CH\t\t\t(0)  \n#define EMAC_DEF_RX_CH\t\t\t(0)  \n#define EMAC_DEF_RX_NUM_DESC\t\t(128)\n#define EMAC_DEF_MAX_TX_CH\t\t(1)  \n#define EMAC_DEF_MAX_RX_CH\t\t(1)  \n\n \n#define EMAC_DEF_TX_MAX_SERVICE\t\t(32)  \n#define EMAC_DEF_RX_MAX_SERVICE\t\t(64)  \n\n \n#define EMAC_ALL_MULTI_REG_VALUE\t(0xFFFFFFFF)\n#define EMAC_NUM_MULTICAST_BITS\t\t(64)\n#define EMAC_TX_CONTROL_TX_ENABLE_VAL\t(0x1)\n#define EMAC_RX_CONTROL_RX_ENABLE_VAL\t(0x1)\n#define EMAC_MAC_HOST_ERR_INTMASK_VAL\t(0x2)\n#define EMAC_RX_UNICAST_CLEAR_ALL\t(0xFF)\n#define EMAC_INT_MASK_CLEAR\t\t(0xFF)\n\n \n#define EMAC_RXMBP_PASSCRC_MASK\t\tBIT(30)\n#define EMAC_RXMBP_QOSEN_MASK\t\tBIT(29)\n#define EMAC_RXMBP_NOCHAIN_MASK\t\tBIT(28)\n#define EMAC_RXMBP_CMFEN_MASK\t\tBIT(24)\n#define EMAC_RXMBP_CSFEN_MASK\t\tBIT(23)\n#define EMAC_RXMBP_CEFEN_MASK\t\tBIT(22)\n#define EMAC_RXMBP_CAFEN_MASK\t\tBIT(21)\n#define EMAC_RXMBP_PROMCH_SHIFT\t\t(16)\n#define EMAC_RXMBP_PROMCH_MASK\t\t(0x7 << 16)\n#define EMAC_RXMBP_BROADEN_MASK\t\tBIT(13)\n#define EMAC_RXMBP_BROADCH_SHIFT\t(8)\n#define EMAC_RXMBP_BROADCH_MASK\t\t(0x7 << 8)\n#define EMAC_RXMBP_MULTIEN_MASK\t\tBIT(5)\n#define EMAC_RXMBP_MULTICH_SHIFT\t(0)\n#define EMAC_RXMBP_MULTICH_MASK\t\t(0x7)\n#define EMAC_RXMBP_CHMASK\t\t(0x7)\n\n \n# define EMAC_MBP_RXPROMISC\t\t(0x00200000)\n# define EMAC_MBP_PROMISCCH(ch)\t\t(((ch) & 0x7) << 16)\n# define EMAC_MBP_RXBCAST\t\t(0x00002000)\n# define EMAC_MBP_BCASTCHAN(ch)\t\t(((ch) & 0x7) << 8)\n# define EMAC_MBP_RXMCAST\t\t(0x00000020)\n# define EMAC_MBP_MCASTCHAN(ch)\t\t((ch) & 0x7)\n\n \n#define EMAC_MACCONTROL_TXPTYPE\t\tBIT(9)\n#define EMAC_MACCONTROL_TXPACEEN\tBIT(6)\n#define EMAC_MACCONTROL_GMIIEN\t\tBIT(5)\n#define EMAC_MACCONTROL_GIGABITEN\tBIT(7)\n#define EMAC_MACCONTROL_FULLDUPLEXEN\tBIT(0)\n#define EMAC_MACCONTROL_RMIISPEED_MASK\tBIT(15)\n\n \n#define EMAC_DM646X_MACCONTORL_GIG\tBIT(7)\n#define EMAC_DM646X_MACCONTORL_GIGFORCE\tBIT(17)\n\n \n#define EMAC_MACSTATUS_TXERRCODE_MASK\t(0xF00000)\n#define EMAC_MACSTATUS_TXERRCODE_SHIFT\t(20)\n#define EMAC_MACSTATUS_TXERRCH_MASK\t(0x70000)\n#define EMAC_MACSTATUS_TXERRCH_SHIFT\t(16)\n#define EMAC_MACSTATUS_RXERRCODE_MASK\t(0xF000)\n#define EMAC_MACSTATUS_RXERRCODE_SHIFT\t(12)\n#define EMAC_MACSTATUS_RXERRCH_MASK\t(0x700)\n#define EMAC_MACSTATUS_RXERRCH_SHIFT\t(8)\n\n \n#define EMAC_RX_MAX_LEN_MASK\t\t(0xFFFF)\n#define EMAC_RX_BUFFER_OFFSET_MASK\t(0xFFFF)\n\n \n#define EMAC_DM644X_MAC_IN_VECTOR_HOST_INT\tBIT(17)\n#define EMAC_DM644X_MAC_IN_VECTOR_STATPEND_INT\tBIT(16)\n#define EMAC_DM644X_MAC_IN_VECTOR_RX_INT_VEC\tBIT(8)\n#define EMAC_DM644X_MAC_IN_VECTOR_TX_INT_VEC\tBIT(0)\n\n \n#define EMAC_DM646X_MAC_IN_VECTOR_RX_INT_VEC\tBIT(EMAC_DEF_RX_CH)\n#define EMAC_DM646X_MAC_IN_VECTOR_TX_INT_VEC\tBIT(16 + EMAC_DEF_TX_CH)\n#define EMAC_DM646X_MAC_IN_VECTOR_HOST_INT\tBIT(26)\n#define EMAC_DM646X_MAC_IN_VECTOR_STATPEND_INT\tBIT(27)\n\n \n#define EMAC_CPPI_SOP_BIT\t\tBIT(31)\n#define EMAC_CPPI_EOP_BIT\t\tBIT(30)\n#define EMAC_CPPI_OWNERSHIP_BIT\t\tBIT(29)\n#define EMAC_CPPI_EOQ_BIT\t\tBIT(28)\n#define EMAC_CPPI_TEARDOWN_COMPLETE_BIT BIT(27)\n#define EMAC_CPPI_PASS_CRC_BIT\t\tBIT(26)\n#define EMAC_RX_BD_BUF_SIZE\t\t(0xFFFF)\n#define EMAC_BD_LENGTH_FOR_CACHE\t(16)  \n#define EMAC_RX_BD_PKT_LENGTH_MASK\t(0xFFFF)\n\n \n#define EMAC_MAX_TXRX_CHANNELS\t\t (8)   \n#define EMAC_DEF_MAX_MULTICAST_ADDRESSES (64)  \n\n \n#define EMAC_MACINVECTOR\t0x90\n\n#define EMAC_DM646X_MACEOIVECTOR\t0x94\n\n#define EMAC_MACINTSTATRAW\t0xB0\n#define EMAC_MACINTSTATMASKED\t0xB4\n#define EMAC_MACINTMASKSET\t0xB8\n#define EMAC_MACINTMASKCLEAR\t0xBC\n\n#define EMAC_RXMBPENABLE\t0x100\n#define EMAC_RXUNICASTSET\t0x104\n#define EMAC_RXUNICASTCLEAR\t0x108\n#define EMAC_RXMAXLEN\t\t0x10C\n#define EMAC_RXBUFFEROFFSET\t0x110\n#define EMAC_RXFILTERLOWTHRESH\t0x114\n\n#define EMAC_MACCONTROL\t\t0x160\n#define EMAC_MACSTATUS\t\t0x164\n#define EMAC_EMCONTROL\t\t0x168\n#define EMAC_FIFOCONTROL\t0x16C\n#define EMAC_MACCONFIG\t\t0x170\n#define EMAC_SOFTRESET\t\t0x174\n#define EMAC_MACSRCADDRLO\t0x1D0\n#define EMAC_MACSRCADDRHI\t0x1D4\n#define EMAC_MACHASH1\t\t0x1D8\n#define EMAC_MACHASH2\t\t0x1DC\n#define EMAC_MACADDRLO\t\t0x500\n#define EMAC_MACADDRHI\t\t0x504\n#define EMAC_MACINDEX\t\t0x508\n\n \n#define EMAC_RXGOODFRAMES\t0x200\n#define EMAC_RXBCASTFRAMES\t0x204\n#define EMAC_RXMCASTFRAMES\t0x208\n#define EMAC_RXPAUSEFRAMES\t0x20C\n#define EMAC_RXCRCERRORS\t0x210\n#define EMAC_RXALIGNCODEERRORS\t0x214\n#define EMAC_RXOVERSIZED\t0x218\n#define EMAC_RXJABBER\t\t0x21C\n#define EMAC_RXUNDERSIZED\t0x220\n#define EMAC_RXFRAGMENTS\t0x224\n#define EMAC_RXFILTERED\t\t0x228\n#define EMAC_RXQOSFILTERED\t0x22C\n#define EMAC_RXOCTETS\t\t0x230\n#define EMAC_TXGOODFRAMES\t0x234\n#define EMAC_TXBCASTFRAMES\t0x238\n#define EMAC_TXMCASTFRAMES\t0x23C\n#define EMAC_TXPAUSEFRAMES\t0x240\n#define EMAC_TXDEFERRED\t\t0x244\n#define EMAC_TXCOLLISION\t0x248\n#define EMAC_TXSINGLECOLL\t0x24C\n#define EMAC_TXMULTICOLL\t0x250\n#define EMAC_TXEXCESSIVECOLL\t0x254\n#define EMAC_TXLATECOLL\t\t0x258\n#define EMAC_TXUNDERRUN\t\t0x25C\n#define EMAC_TXCARRIERSENSE\t0x260\n#define EMAC_TXOCTETS\t\t0x264\n#define EMAC_NETOCTETS\t\t0x280\n#define EMAC_RXSOFOVERRUNS\t0x284\n#define EMAC_RXMOFOVERRUNS\t0x288\n#define EMAC_RXDMAOVERRUNS\t0x28C\n\n \n#define EMAC_CTRL_EWCTL\t\t(0x4)\n#define EMAC_CTRL_EWINTTCNT\t(0x8)\n\n \n#define EMAC_DM644X_EWINTCNT_MASK\t0x1FFFF\n#define EMAC_DM644X_INTMIN_INTVL\t0x1\n#define EMAC_DM644X_INTMAX_INTVL\t(EMAC_DM644X_EWINTCNT_MASK)\n\n \n#define EMAC_DM646X_CMINTCTRL\t0x0C\n#define EMAC_DM646X_CMRXINTEN\t0x14\n#define EMAC_DM646X_CMTXINTEN\t0x18\n#define EMAC_DM646X_CMRXINTMAX\t0x70\n#define EMAC_DM646X_CMTXINTMAX\t0x74\n\n \n#define EMAC_DM646X_INTPACEEN\t\t(0x3 << 16)\n#define EMAC_DM646X_INTPRESCALE_MASK\t(0x7FF << 0)\n#define EMAC_DM646X_CMINTMAX_CNT\t63\n#define EMAC_DM646X_CMINTMIN_CNT\t2\n#define EMAC_DM646X_CMINTMAX_INTVL\t(1000 / EMAC_DM646X_CMINTMIN_CNT)\n#define EMAC_DM646X_CMINTMIN_INTVL\t((1000 / EMAC_DM646X_CMINTMAX_CNT) + 1)\n\n\n \n#define EMAC_DM646X_MAC_EOI_C0_RXEN\t(0x01)\n#define EMAC_DM646X_MAC_EOI_C0_TXEN\t(0x02)\n\n \n#define EMAC_STATS_CLR_MASK    (0xFFFFFFFF)\n\n \nstruct emac_priv {\n\tu32 msg_enable;\n\tstruct net_device *ndev;\n\tstruct platform_device *pdev;\n\tstruct napi_struct napi;\n\tchar mac_addr[6];\n\tvoid __iomem *remap_addr;\n\tu32 emac_base_phys;\n\tvoid __iomem *emac_base;\n\tvoid __iomem *ctrl_base;\n\tstruct cpdma_ctlr *dma;\n\tstruct cpdma_chan *txchan;\n\tstruct cpdma_chan *rxchan;\n\tu32 link;  \n\tu32 speed;  \n\tu32 duplex;  \n\tu32 rx_buf_size;\n\tu32 isr_count;\n\tu32 coal_intvl;\n\tu32 bus_freq_mhz;\n\tu8 rmii_en;\n\tu8 version;\n\tu32 mac_hash1;\n\tu32 mac_hash2;\n\tu32 multicast_hash_cnt[EMAC_NUM_MULTICAST_BITS];\n\tu32 rx_addr_type;\n\tconst char *phy_id;\n\tstruct device_node *phy_node;\n\tspinlock_t lock;\n\t \n\tvoid (*int_enable) (void);\n\tvoid (*int_disable) (void);\n};\n\n \nstatic char *emac_txhost_errcodes[16] = {\n\t\"No error\", \"SOP error\", \"Ownership bit not set in SOP buffer\",\n\t\"Zero Next Buffer Descriptor Pointer Without EOP\",\n\t\"Zero Buffer Pointer\", \"Zero Buffer Length\", \"Packet Length Error\",\n\t\"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\",\n\t\"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\"\n};\n\n \nstatic char *emac_rxhost_errcodes[16] = {\n\t\"No error\", \"Reserved\", \"Ownership bit not set in input buffer\",\n\t\"Reserved\", \"Zero Buffer Pointer\", \"Reserved\", \"Reserved\",\n\t\"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\",\n\t\"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\"\n};\n\n \n#define emac_read(reg)\t\t  ioread32(priv->emac_base + (reg))\n#define emac_write(reg, val)      iowrite32(val, priv->emac_base + (reg))\n\n#define emac_ctrl_read(reg)\t  ioread32((priv->ctrl_base + (reg)))\n#define emac_ctrl_write(reg, val) iowrite32(val, (priv->ctrl_base + (reg)))\n\n \nstatic void emac_get_drvinfo(struct net_device *ndev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, emac_version_string, sizeof(info->driver));\n\tstrscpy(info->version, EMAC_MODULE_VERSION, sizeof(info->version));\n}\n\n \nstatic int emac_get_coalesce(struct net_device *ndev,\n\t\t\t     struct ethtool_coalesce *coal,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct emac_priv *priv = netdev_priv(ndev);\n\n\tcoal->rx_coalesce_usecs = priv->coal_intvl;\n\treturn 0;\n\n}\n\n \nstatic int emac_set_coalesce(struct net_device *ndev,\n\t\t\t     struct ethtool_coalesce *coal,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct emac_priv *priv = netdev_priv(ndev);\n\tu32 int_ctrl, num_interrupts = 0;\n\tu32 prescale = 0, addnl_dvdr = 1, coal_intvl = 0;\n\n\tif (!coal->rx_coalesce_usecs) {\n\t\tpriv->coal_intvl = 0;\n\n\t\tswitch (priv->version) {\n\t\tcase EMAC_VERSION_2:\n\t\t\temac_ctrl_write(EMAC_DM646X_CMINTCTRL, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\temac_ctrl_write(EMAC_CTRL_EWINTTCNT, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tcoal_intvl = coal->rx_coalesce_usecs;\n\n\tswitch (priv->version) {\n\tcase EMAC_VERSION_2:\n\t\tint_ctrl =  emac_ctrl_read(EMAC_DM646X_CMINTCTRL);\n\t\tprescale = priv->bus_freq_mhz * 4;\n\n\t\tif (coal_intvl < EMAC_DM646X_CMINTMIN_INTVL)\n\t\t\tcoal_intvl = EMAC_DM646X_CMINTMIN_INTVL;\n\n\t\tif (coal_intvl > EMAC_DM646X_CMINTMAX_INTVL) {\n\t\t\t \n\t\t\taddnl_dvdr = EMAC_DM646X_INTPRESCALE_MASK / prescale;\n\n\t\t\tif (addnl_dvdr > 1) {\n\t\t\t\tprescale *= addnl_dvdr;\n\t\t\t\tif (coal_intvl > (EMAC_DM646X_CMINTMAX_INTVL\n\t\t\t\t\t\t\t* addnl_dvdr))\n\t\t\t\t\tcoal_intvl = (EMAC_DM646X_CMINTMAX_INTVL\n\t\t\t\t\t\t\t* addnl_dvdr);\n\t\t\t} else {\n\t\t\t\taddnl_dvdr = 1;\n\t\t\t\tcoal_intvl = EMAC_DM646X_CMINTMAX_INTVL;\n\t\t\t}\n\t\t}\n\n\t\tnum_interrupts = (1000 * addnl_dvdr) / coal_intvl;\n\n\t\tint_ctrl |= EMAC_DM646X_INTPACEEN;\n\t\tint_ctrl &= (~EMAC_DM646X_INTPRESCALE_MASK);\n\t\tint_ctrl |= (prescale & EMAC_DM646X_INTPRESCALE_MASK);\n\t\temac_ctrl_write(EMAC_DM646X_CMINTCTRL, int_ctrl);\n\n\t\temac_ctrl_write(EMAC_DM646X_CMRXINTMAX, num_interrupts);\n\t\temac_ctrl_write(EMAC_DM646X_CMTXINTMAX, num_interrupts);\n\n\t\tbreak;\n\tdefault:\n\t\tint_ctrl = emac_ctrl_read(EMAC_CTRL_EWINTTCNT);\n\t\tint_ctrl &= (~EMAC_DM644X_EWINTCNT_MASK);\n\t\tprescale = coal_intvl * priv->bus_freq_mhz;\n\t\tif (prescale > EMAC_DM644X_EWINTCNT_MASK) {\n\t\t\tprescale = EMAC_DM644X_EWINTCNT_MASK;\n\t\t\tcoal_intvl = prescale / priv->bus_freq_mhz;\n\t\t}\n\t\temac_ctrl_write(EMAC_CTRL_EWINTTCNT, (int_ctrl | prescale));\n\n\t\tbreak;\n\t}\n\n\tprintk(KERN_INFO\"Set coalesce to %d usecs.\\n\", coal_intvl);\n\tpriv->coal_intvl = coal_intvl;\n\n\treturn 0;\n\n}\n\n\n \nstatic const struct ethtool_ops ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS,\n\t.get_drvinfo = emac_get_drvinfo,\n\t.get_link = ethtool_op_get_link,\n\t.get_coalesce = emac_get_coalesce,\n\t.set_coalesce =  emac_set_coalesce,\n\t.get_ts_info = ethtool_op_get_ts_info,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\n \nstatic void emac_update_phystatus(struct emac_priv *priv)\n{\n\tu32 mac_control;\n\tu32 new_duplex;\n\tu32 cur_duplex;\n\tstruct net_device *ndev = priv->ndev;\n\n\tmac_control = emac_read(EMAC_MACCONTROL);\n\tcur_duplex = (mac_control & EMAC_MACCONTROL_FULLDUPLEXEN) ?\n\t\t\tDUPLEX_FULL : DUPLEX_HALF;\n\tif (ndev->phydev)\n\t\tnew_duplex = ndev->phydev->duplex;\n\telse\n\t\tnew_duplex = DUPLEX_FULL;\n\n\t \n\tif ((priv->link) && (new_duplex != cur_duplex)) {\n\t\tpriv->duplex = new_duplex;\n\t\tif (DUPLEX_FULL == priv->duplex)\n\t\t\tmac_control |= (EMAC_MACCONTROL_FULLDUPLEXEN);\n\t\telse\n\t\t\tmac_control &= ~(EMAC_MACCONTROL_FULLDUPLEXEN);\n\t}\n\n\tif (priv->speed == SPEED_1000 && (priv->version == EMAC_VERSION_2)) {\n\t\tmac_control = emac_read(EMAC_MACCONTROL);\n\t\tmac_control |= (EMAC_DM646X_MACCONTORL_GIG |\n\t\t\t\tEMAC_DM646X_MACCONTORL_GIGFORCE);\n\t} else {\n\t\t \n\t\tmac_control &= ~(EMAC_DM646X_MACCONTORL_GIGFORCE |\n\t\t\t\t\tEMAC_DM646X_MACCONTORL_GIG);\n\n\t\tif (priv->rmii_en && (priv->speed == SPEED_100))\n\t\t\tmac_control |= EMAC_MACCONTROL_RMIISPEED_MASK;\n\t\telse\n\t\t\tmac_control &= ~EMAC_MACCONTROL_RMIISPEED_MASK;\n\t}\n\n\t \n\temac_write(EMAC_MACCONTROL, mac_control);\n\n\tif (priv->link) {\n\t\t \n\t\tif (!netif_carrier_ok(ndev))\n\t\t\tnetif_carrier_on(ndev);\n\t \n\t\tif (netif_running(ndev) && netif_queue_stopped(ndev))\n\t\t\tnetif_wake_queue(ndev);\n\t} else {\n\t\t \n\t\tif (netif_carrier_ok(ndev))\n\t\t\tnetif_carrier_off(ndev);\n\t\tif (!netif_queue_stopped(ndev))\n\t\t\tnetif_stop_queue(ndev);\n\t}\n}\n\n \nstatic u32 hash_get(u8 *addr)\n{\n\tu32 hash;\n\tu8 tmpval;\n\tint cnt;\n\thash = 0;\n\n\tfor (cnt = 0; cnt < 2; cnt++) {\n\t\ttmpval = *addr++;\n\t\thash ^= (tmpval >> 2) ^ (tmpval << 4);\n\t\ttmpval = *addr++;\n\t\thash ^= (tmpval >> 4) ^ (tmpval << 2);\n\t\ttmpval = *addr++;\n\t\thash ^= (tmpval >> 6) ^ (tmpval);\n\t}\n\n\treturn hash & 0x3F;\n}\n\n \nstatic int emac_hash_add(struct emac_priv *priv, u8 *mac_addr)\n{\n\tstruct device *emac_dev = &priv->ndev->dev;\n\tu32 rc = 0;\n\tu32 hash_bit;\n\tu32 hash_value = hash_get(mac_addr);\n\n\tif (hash_value >= EMAC_NUM_MULTICAST_BITS) {\n\t\tif (netif_msg_drv(priv)) {\n\t\t\tdev_err(emac_dev, \"DaVinci EMAC: emac_hash_add(): Invalid \"\\\n\t\t\t\t\"Hash %08x, should not be greater than %08x\",\n\t\t\t\thash_value, (EMAC_NUM_MULTICAST_BITS - 1));\n\t\t}\n\t\treturn -1;\n\t}\n\n\t \n\tif (priv->multicast_hash_cnt[hash_value] == 0) {\n\t\trc = 1;  \n\t\tif (hash_value < 32) {\n\t\t\thash_bit = BIT(hash_value);\n\t\t\tpriv->mac_hash1 |= hash_bit;\n\t\t} else {\n\t\t\thash_bit = BIT((hash_value - 32));\n\t\t\tpriv->mac_hash2 |= hash_bit;\n\t\t}\n\t}\n\n\t \n\t++priv->multicast_hash_cnt[hash_value];\n\n\treturn rc;\n}\n\n \nstatic int emac_hash_del(struct emac_priv *priv, u8 *mac_addr)\n{\n\tu32 hash_value;\n\tu32 hash_bit;\n\n\thash_value = hash_get(mac_addr);\n\tif (priv->multicast_hash_cnt[hash_value] > 0) {\n\t\t \n\t\t--priv->multicast_hash_cnt[hash_value];\n\t}\n\n\t \n\tif (priv->multicast_hash_cnt[hash_value] > 0)\n\t\treturn 0;\n\n\tif (hash_value < 32) {\n\t\thash_bit = BIT(hash_value);\n\t\tpriv->mac_hash1 &= ~hash_bit;\n\t} else {\n\t\thash_bit = BIT((hash_value - 32));\n\t\tpriv->mac_hash2 &= ~hash_bit;\n\t}\n\n\t \n\treturn 1;\n}\n\n \n#define EMAC_MULTICAST_ADD\t0\n#define EMAC_MULTICAST_DEL\t1\n#define EMAC_ALL_MULTI_SET\t2\n#define EMAC_ALL_MULTI_CLR\t3\n\n \nstatic void emac_add_mcast(struct emac_priv *priv, u32 action, u8 *mac_addr)\n{\n\tstruct device *emac_dev = &priv->ndev->dev;\n\tint update = -1;\n\n\tswitch (action) {\n\tcase EMAC_MULTICAST_ADD:\n\t\tupdate = emac_hash_add(priv, mac_addr);\n\t\tbreak;\n\tcase EMAC_MULTICAST_DEL:\n\t\tupdate = emac_hash_del(priv, mac_addr);\n\t\tbreak;\n\tcase EMAC_ALL_MULTI_SET:\n\t\tupdate = 1;\n\t\tpriv->mac_hash1 = EMAC_ALL_MULTI_REG_VALUE;\n\t\tpriv->mac_hash2 = EMAC_ALL_MULTI_REG_VALUE;\n\t\tbreak;\n\tcase EMAC_ALL_MULTI_CLR:\n\t\tupdate = 1;\n\t\tpriv->mac_hash1 = 0;\n\t\tpriv->mac_hash2 = 0;\n\t\tmemset(&(priv->multicast_hash_cnt[0]), 0,\n\t\tsizeof(priv->multicast_hash_cnt[0]) *\n\t\t       EMAC_NUM_MULTICAST_BITS);\n\t\tbreak;\n\tdefault:\n\t\tif (netif_msg_drv(priv))\n\t\t\tdev_err(emac_dev, \"DaVinci EMAC: add_mcast\"\\\n\t\t\t\t\": bad operation %d\", action);\n\t\tbreak;\n\t}\n\n\t \n\tif (update > 0) {\n\t\temac_write(EMAC_MACHASH1, priv->mac_hash1);\n\t\temac_write(EMAC_MACHASH2, priv->mac_hash2);\n\t}\n}\n\n \nstatic void emac_dev_mcast_set(struct net_device *ndev)\n{\n\tu32 mbp_enable;\n\tstruct emac_priv *priv = netdev_priv(ndev);\n\n\tmbp_enable = emac_read(EMAC_RXMBPENABLE);\n\tif (ndev->flags & IFF_PROMISC) {\n\t\tmbp_enable &= (~EMAC_MBP_PROMISCCH(EMAC_DEF_PROM_CH));\n\t\tmbp_enable |= (EMAC_MBP_RXPROMISC);\n\t} else {\n\t\tmbp_enable = (mbp_enable & ~EMAC_MBP_RXPROMISC);\n\t\tif ((ndev->flags & IFF_ALLMULTI) ||\n\t\t    netdev_mc_count(ndev) > EMAC_DEF_MAX_MULTICAST_ADDRESSES) {\n\t\t\tmbp_enable = (mbp_enable | EMAC_MBP_RXMCAST);\n\t\t\temac_add_mcast(priv, EMAC_ALL_MULTI_SET, NULL);\n\t\t} else if (!netdev_mc_empty(ndev)) {\n\t\t\tstruct netdev_hw_addr *ha;\n\n\t\t\tmbp_enable = (mbp_enable | EMAC_MBP_RXMCAST);\n\t\t\temac_add_mcast(priv, EMAC_ALL_MULTI_CLR, NULL);\n\t\t\t \n\t\t\tnetdev_for_each_mc_addr(ha, ndev) {\n\t\t\t\temac_add_mcast(priv, EMAC_MULTICAST_ADD,\n\t\t\t\t\t       (u8 *) ha->addr);\n\t\t\t}\n\t\t} else {\n\t\t\tmbp_enable = (mbp_enable & ~EMAC_MBP_RXMCAST);\n\t\t\temac_add_mcast(priv, EMAC_ALL_MULTI_CLR, NULL);\n\t\t}\n\t}\n\t \n\temac_write(EMAC_RXMBPENABLE, mbp_enable);\n}\n\n \n\n \nstatic void emac_int_disable(struct emac_priv *priv)\n{\n\tif (priv->version == EMAC_VERSION_2) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\n\t\t \n\t\temac_ctrl_write(EMAC_DM646X_CMRXINTEN, 0x0);\n\t\temac_ctrl_write(EMAC_DM646X_CMTXINTEN, 0x0);\n\t\t \n\t\tif (priv->int_disable)\n\t\t\tpriv->int_disable();\n\n\t\t \n\n\t\t \n\t\temac_write(EMAC_DM646X_MACEOIVECTOR,\n\t\t\tEMAC_DM646X_MAC_EOI_C0_RXEN);\n\n\t\t \n\t\temac_write(EMAC_DM646X_MACEOIVECTOR,\n\t\t\tEMAC_DM646X_MAC_EOI_C0_TXEN);\n\n\t\tlocal_irq_restore(flags);\n\n\t} else {\n\t\t \n\t\temac_ctrl_write(EMAC_CTRL_EWCTL, 0x0);\n\t}\n}\n\n \nstatic void emac_int_enable(struct emac_priv *priv)\n{\n\tif (priv->version == EMAC_VERSION_2) {\n\t\tif (priv->int_enable)\n\t\t\tpriv->int_enable();\n\n\t\temac_ctrl_write(EMAC_DM646X_CMRXINTEN, 0xff);\n\t\temac_ctrl_write(EMAC_DM646X_CMTXINTEN, 0xff);\n\n\t\t \n\n\t\t \n\t} else {\n\t\t \n\t\temac_ctrl_write(EMAC_CTRL_EWCTL, 0x1);\n\t}\n}\n\n \nstatic irqreturn_t emac_irq(int irq, void *dev_id)\n{\n\tstruct net_device *ndev = (struct net_device *)dev_id;\n\tstruct emac_priv *priv = netdev_priv(ndev);\n\n\t++priv->isr_count;\n\tif (likely(netif_running(priv->ndev))) {\n\t\temac_int_disable(priv);\n\t\tnapi_schedule(&priv->napi);\n\t} else {\n\t\t \n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic struct sk_buff *emac_rx_alloc(struct emac_priv *priv)\n{\n\tstruct sk_buff *skb = netdev_alloc_skb(priv->ndev, priv->rx_buf_size);\n\tif (WARN_ON(!skb))\n\t\treturn NULL;\n\tskb_reserve(skb, NET_IP_ALIGN);\n\treturn skb;\n}\n\nstatic void emac_rx_handler(void *token, int len, int status)\n{\n\tstruct sk_buff\t\t*skb = token;\n\tstruct net_device\t*ndev = skb->dev;\n\tstruct emac_priv\t*priv = netdev_priv(ndev);\n\tstruct device\t\t*emac_dev = &ndev->dev;\n\tint\t\t\tret;\n\n\t \n\tif (unlikely(!netif_running(ndev))) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\t \n\tif (status < 0) {\n\t\tndev->stats.rx_errors++;\n\t\tgoto recycle;\n\t}\n\n\t \n\tskb_put(skb, len);\n\tskb->protocol = eth_type_trans(skb, ndev);\n\tnetif_receive_skb(skb);\n\tndev->stats.rx_bytes += len;\n\tndev->stats.rx_packets++;\n\n\t \n\tskb = emac_rx_alloc(priv);\n\tif (!skb) {\n\t\tif (netif_msg_rx_err(priv) && net_ratelimit())\n\t\t\tdev_err(emac_dev, \"failed rx buffer alloc\\n\");\n\t\treturn;\n\t}\n\nrecycle:\n\tret = cpdma_chan_submit(priv->rxchan, skb, skb->data,\n\t\t\tskb_tailroom(skb), 0);\n\n\tWARN_ON(ret == -ENOMEM);\n\tif (unlikely(ret < 0))\n\t\tdev_kfree_skb_any(skb);\n}\n\nstatic void emac_tx_handler(void *token, int len, int status)\n{\n\tstruct sk_buff\t\t*skb = token;\n\tstruct net_device\t*ndev = skb->dev;\n\n\t \n\tif (unlikely(netif_queue_stopped(ndev)))\n\t\tnetif_wake_queue(ndev);\n\tndev->stats.tx_packets++;\n\tndev->stats.tx_bytes += len;\n\tdev_kfree_skb_any(skb);\n}\n\n \nstatic netdev_tx_t emac_dev_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct device *emac_dev = &ndev->dev;\n\tint ret_code;\n\tstruct emac_priv *priv = netdev_priv(ndev);\n\n\t \n\tif (unlikely(!priv->link)) {\n\t\tif (netif_msg_tx_err(priv) && net_ratelimit())\n\t\t\tdev_err(emac_dev, \"DaVinci EMAC: No link to transmit\");\n\t\tgoto fail_tx;\n\t}\n\n\tret_code = skb_put_padto(skb, EMAC_DEF_MIN_ETHPKTSIZE);\n\tif (unlikely(ret_code < 0)) {\n\t\tif (netif_msg_tx_err(priv) && net_ratelimit())\n\t\t\tdev_err(emac_dev, \"DaVinci EMAC: packet pad failed\");\n\t\tgoto fail_tx;\n\t}\n\n\tskb_tx_timestamp(skb);\n\n\tret_code = cpdma_chan_submit(priv->txchan, skb, skb->data, skb->len,\n\t\t\t\t     0);\n\tif (unlikely(ret_code != 0)) {\n\t\tif (netif_msg_tx_err(priv) && net_ratelimit())\n\t\t\tdev_err(emac_dev, \"DaVinci EMAC: desc submit failed\");\n\t\tgoto fail_tx;\n\t}\n\n\t \n\tif (unlikely(!cpdma_check_free_tx_desc(priv->txchan)))\n\t\tnetif_stop_queue(ndev);\n\n\treturn NETDEV_TX_OK;\n\nfail_tx:\n\tndev->stats.tx_dropped++;\n\tnetif_stop_queue(ndev);\n\treturn NETDEV_TX_BUSY;\n}\n\n \nstatic void emac_dev_tx_timeout(struct net_device *ndev, unsigned int txqueue)\n{\n\tstruct emac_priv *priv = netdev_priv(ndev);\n\tstruct device *emac_dev = &ndev->dev;\n\n\tif (netif_msg_tx_err(priv))\n\t\tdev_err(emac_dev, \"DaVinci EMAC: xmit timeout, restarting TX\");\n\n\tndev->stats.tx_errors++;\n\temac_int_disable(priv);\n\tcpdma_chan_stop(priv->txchan);\n\tcpdma_chan_start(priv->txchan);\n\temac_int_enable(priv);\n}\n\n \nstatic void emac_set_type0addr(struct emac_priv *priv, u32 ch, char *mac_addr)\n{\n\tu32 val;\n\tval = ((mac_addr[5] << 8) | (mac_addr[4]));\n\temac_write(EMAC_MACSRCADDRLO, val);\n\n\tval = ((mac_addr[3] << 24) | (mac_addr[2] << 16) | \\\n\t       (mac_addr[1] << 8) | (mac_addr[0]));\n\temac_write(EMAC_MACSRCADDRHI, val);\n\tval = emac_read(EMAC_RXUNICASTSET);\n\tval |= BIT(ch);\n\temac_write(EMAC_RXUNICASTSET, val);\n\tval = emac_read(EMAC_RXUNICASTCLEAR);\n\tval &= ~BIT(ch);\n\temac_write(EMAC_RXUNICASTCLEAR, val);\n}\n\n \nstatic void emac_set_type1addr(struct emac_priv *priv, u32 ch, char *mac_addr)\n{\n\tu32 val;\n\temac_write(EMAC_MACINDEX, ch);\n\tval = ((mac_addr[5] << 8) | mac_addr[4]);\n\temac_write(EMAC_MACADDRLO, val);\n\tval = ((mac_addr[3] << 24) | (mac_addr[2] << 16) | \\\n\t       (mac_addr[1] << 8) | (mac_addr[0]));\n\temac_write(EMAC_MACADDRHI, val);\n\temac_set_type0addr(priv, ch, mac_addr);\n}\n\n \nstatic void emac_set_type2addr(struct emac_priv *priv, u32 ch,\n\t\t\t       char *mac_addr, int index, int match)\n{\n\tu32 val;\n\temac_write(EMAC_MACINDEX, index);\n\tval = ((mac_addr[3] << 24) | (mac_addr[2] << 16) | \\\n\t       (mac_addr[1] << 8) | (mac_addr[0]));\n\temac_write(EMAC_MACADDRHI, val);\n\tval = ((mac_addr[5] << 8) | mac_addr[4] | ((ch & 0x7) << 16) | \\\n\t       (match << 19) | BIT(20));\n\temac_write(EMAC_MACADDRLO, val);\n\temac_set_type0addr(priv, ch, mac_addr);\n}\n\n \nstatic void emac_setmac(struct emac_priv *priv, u32 ch, char *mac_addr)\n{\n\tstruct device *emac_dev = &priv->ndev->dev;\n\n\tif (priv->rx_addr_type == 0) {\n\t\temac_set_type0addr(priv, ch, mac_addr);\n\t} else if (priv->rx_addr_type == 1) {\n\t\tu32 cnt;\n\t\tfor (cnt = 0; cnt < EMAC_MAX_TXRX_CHANNELS; cnt++)\n\t\t\temac_set_type1addr(priv, ch, mac_addr);\n\t} else if (priv->rx_addr_type == 2) {\n\t\temac_set_type2addr(priv, ch, mac_addr, ch, 1);\n\t\temac_set_type0addr(priv, ch, mac_addr);\n\t} else {\n\t\tif (netif_msg_drv(priv))\n\t\t\tdev_err(emac_dev, \"DaVinci EMAC: Wrong addressing\\n\");\n\t}\n}\n\n \nstatic int emac_dev_setmac_addr(struct net_device *ndev, void *addr)\n{\n\tstruct emac_priv *priv = netdev_priv(ndev);\n\tstruct device *emac_dev = &priv->ndev->dev;\n\tstruct sockaddr *sa = addr;\n\n\tif (!is_valid_ether_addr(sa->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\t \n\tmemcpy(priv->mac_addr, sa->sa_data, ndev->addr_len);\n\teth_hw_addr_set(ndev, sa->sa_data);\n\n\t \n\tif (netif_running(ndev)) {\n\t\temac_setmac(priv, EMAC_DEF_RX_CH, priv->mac_addr);\n\t}\n\n\tif (netif_msg_drv(priv))\n\t\tdev_notice(emac_dev, \"DaVinci EMAC: emac_dev_setmac_addr %pM\\n\",\n\t\t\t\t\tpriv->mac_addr);\n\n\treturn 0;\n}\n\n \nstatic int emac_hw_enable(struct emac_priv *priv)\n{\n\tu32 val, mbp_enable, mac_control;\n\n\t \n\temac_write(EMAC_SOFTRESET, 1);\n\twhile (emac_read(EMAC_SOFTRESET))\n\t\tcpu_relax();\n\n\t \n\temac_int_disable(priv);\n\n\t \n\tmac_control =\n\t\t(((EMAC_DEF_TXPRIO_FIXED) ? (EMAC_MACCONTROL_TXPTYPE) : 0x0) |\n\t\t((priv->speed == 1000) ? EMAC_MACCONTROL_GIGABITEN : 0x0) |\n\t\t((EMAC_DEF_TXPACING_EN) ? (EMAC_MACCONTROL_TXPACEEN) : 0x0) |\n\t\t((priv->duplex == DUPLEX_FULL) ? 0x1 : 0));\n\temac_write(EMAC_MACCONTROL, mac_control);\n\n\tmbp_enable =\n\t\t(((EMAC_DEF_PASS_CRC) ? (EMAC_RXMBP_PASSCRC_MASK) : 0x0) |\n\t\t((EMAC_DEF_QOS_EN) ? (EMAC_RXMBP_QOSEN_MASK) : 0x0) |\n\t\t ((EMAC_DEF_NO_BUFF_CHAIN) ? (EMAC_RXMBP_NOCHAIN_MASK) : 0x0) |\n\t\t ((EMAC_DEF_MACCTRL_FRAME_EN) ? (EMAC_RXMBP_CMFEN_MASK) : 0x0) |\n\t\t ((EMAC_DEF_SHORT_FRAME_EN) ? (EMAC_RXMBP_CSFEN_MASK) : 0x0) |\n\t\t ((EMAC_DEF_ERROR_FRAME_EN) ? (EMAC_RXMBP_CEFEN_MASK) : 0x0) |\n\t\t ((EMAC_DEF_PROM_EN) ? (EMAC_RXMBP_CAFEN_MASK) : 0x0) |\n\t\t ((EMAC_DEF_PROM_CH & EMAC_RXMBP_CHMASK) << \\\n\t\t\tEMAC_RXMBP_PROMCH_SHIFT) |\n\t\t ((EMAC_DEF_BCAST_EN) ? (EMAC_RXMBP_BROADEN_MASK) : 0x0) |\n\t\t ((EMAC_DEF_BCAST_CH & EMAC_RXMBP_CHMASK) << \\\n\t\t\tEMAC_RXMBP_BROADCH_SHIFT) |\n\t\t ((EMAC_DEF_MCAST_EN) ? (EMAC_RXMBP_MULTIEN_MASK) : 0x0) |\n\t\t ((EMAC_DEF_MCAST_CH & EMAC_RXMBP_CHMASK) << \\\n\t\t\tEMAC_RXMBP_MULTICH_SHIFT));\n\temac_write(EMAC_RXMBPENABLE, mbp_enable);\n\temac_write(EMAC_RXMAXLEN, (EMAC_DEF_MAX_FRAME_SIZE &\n\t\t\t\t   EMAC_RX_MAX_LEN_MASK));\n\temac_write(EMAC_RXBUFFEROFFSET, (EMAC_DEF_BUFFER_OFFSET &\n\t\t\t\t\t EMAC_RX_BUFFER_OFFSET_MASK));\n\temac_write(EMAC_RXFILTERLOWTHRESH, 0);\n\temac_write(EMAC_RXUNICASTCLEAR, EMAC_RX_UNICAST_CLEAR_ALL);\n\tpriv->rx_addr_type = (emac_read(EMAC_MACCONFIG) >> 8) & 0xFF;\n\n\temac_write(EMAC_MACINTMASKSET, EMAC_MAC_HOST_ERR_INTMASK_VAL);\n\n\temac_setmac(priv, EMAC_DEF_RX_CH, priv->mac_addr);\n\n\t \n\tval = emac_read(EMAC_MACCONTROL);\n\tval |= (EMAC_MACCONTROL_GMIIEN);\n\temac_write(EMAC_MACCONTROL, val);\n\n\t \n\tnapi_enable(&priv->napi);\n\temac_int_enable(priv);\n\treturn 0;\n\n}\n\n \nstatic int emac_poll(struct napi_struct *napi, int budget)\n{\n\tunsigned int mask;\n\tstruct emac_priv *priv = container_of(napi, struct emac_priv, napi);\n\tstruct net_device *ndev = priv->ndev;\n\tstruct device *emac_dev = &ndev->dev;\n\tu32 status = 0;\n\tu32 num_rx_pkts = 0;\n\n\t \n\tstatus = emac_read(EMAC_MACINVECTOR);\n\n\tmask = EMAC_DM644X_MAC_IN_VECTOR_TX_INT_VEC;\n\n\tif (priv->version == EMAC_VERSION_2)\n\t\tmask = EMAC_DM646X_MAC_IN_VECTOR_TX_INT_VEC;\n\n\tif (status & mask) {\n\t\tcpdma_chan_process(priv->txchan, EMAC_DEF_TX_MAX_SERVICE);\n\t}  \n\n\tmask = EMAC_DM644X_MAC_IN_VECTOR_RX_INT_VEC;\n\n\tif (priv->version == EMAC_VERSION_2)\n\t\tmask = EMAC_DM646X_MAC_IN_VECTOR_RX_INT_VEC;\n\n\tif (status & mask) {\n\t\tnum_rx_pkts = cpdma_chan_process(priv->rxchan, budget);\n\t}  \n\n\tmask = EMAC_DM644X_MAC_IN_VECTOR_HOST_INT;\n\tif (priv->version == EMAC_VERSION_2)\n\t\tmask = EMAC_DM646X_MAC_IN_VECTOR_HOST_INT;\n\n\tif (unlikely(status & mask)) {\n\t\tu32 ch, cause;\n\t\tdev_err(emac_dev, \"DaVinci EMAC: Fatal Hardware Error\\n\");\n\t\tnetif_stop_queue(ndev);\n\t\tnapi_disable(&priv->napi);\n\n\t\tstatus = emac_read(EMAC_MACSTATUS);\n\t\tcause = ((status & EMAC_MACSTATUS_TXERRCODE_MASK) >>\n\t\t\t EMAC_MACSTATUS_TXERRCODE_SHIFT);\n\t\tif (cause) {\n\t\t\tch = ((status & EMAC_MACSTATUS_TXERRCH_MASK) >>\n\t\t\t      EMAC_MACSTATUS_TXERRCH_SHIFT);\n\t\t\tif (net_ratelimit()) {\n\t\t\t\tdev_err(emac_dev, \"TX Host error %s on ch=%d\\n\",\n\t\t\t\t\t&emac_txhost_errcodes[cause][0], ch);\n\t\t\t}\n\t\t}\n\t\tcause = ((status & EMAC_MACSTATUS_RXERRCODE_MASK) >>\n\t\t\t EMAC_MACSTATUS_RXERRCODE_SHIFT);\n\t\tif (cause) {\n\t\t\tch = ((status & EMAC_MACSTATUS_RXERRCH_MASK) >>\n\t\t\t      EMAC_MACSTATUS_RXERRCH_SHIFT);\n\t\t\tif (netif_msg_hw(priv) && net_ratelimit())\n\t\t\t\tdev_err(emac_dev, \"RX Host error %s on ch=%d\\n\",\n\t\t\t\t\t&emac_rxhost_errcodes[cause][0], ch);\n\t\t}\n\t} else if (num_rx_pkts < budget) {\n\t\tnapi_complete_done(napi, num_rx_pkts);\n\t\temac_int_enable(priv);\n\t}\n\n\treturn num_rx_pkts;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void emac_poll_controller(struct net_device *ndev)\n{\n\tstruct emac_priv *priv = netdev_priv(ndev);\n\n\temac_int_disable(priv);\n\temac_irq(ndev->irq, ndev);\n\temac_int_enable(priv);\n}\n#endif\n\nstatic void emac_adjust_link(struct net_device *ndev)\n{\n\tstruct emac_priv *priv = netdev_priv(ndev);\n\tstruct phy_device *phydev = ndev->phydev;\n\tunsigned long flags;\n\tint new_state = 0;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (phydev->link) {\n\t\t \n\t\tif (phydev->duplex != priv->duplex) {\n\t\t\tnew_state = 1;\n\t\t\tpriv->duplex = phydev->duplex;\n\t\t}\n\t\tif (phydev->speed != priv->speed) {\n\t\t\tnew_state = 1;\n\t\t\tpriv->speed = phydev->speed;\n\t\t}\n\t\tif (!priv->link) {\n\t\t\tnew_state = 1;\n\t\t\tpriv->link = 1;\n\t\t}\n\n\t} else if (priv->link) {\n\t\tnew_state = 1;\n\t\tpriv->link = 0;\n\t\tpriv->speed = 0;\n\t\tpriv->duplex = ~0;\n\t}\n\tif (new_state) {\n\t\temac_update_phystatus(priv);\n\t\tphy_print_status(ndev->phydev);\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\n \n\n \nstatic int emac_devioctl(struct net_device *ndev, struct ifreq *ifrq, int cmd)\n{\n\tif (!(netif_running(ndev)))\n\t\treturn -EINVAL;\n\n\t \n\n\tif (ndev->phydev)\n\t\treturn phy_mii_ioctl(ndev->phydev, ifrq, cmd);\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic int match_first_device(struct device *dev, const void *data)\n{\n\tif (dev->parent && dev->parent->of_node)\n\t\treturn of_device_is_compatible(dev->parent->of_node,\n\t\t\t\t\t       \"ti,davinci_mdio\");\n\n\treturn !strncmp(dev_name(dev), \"davinci_mdio\", 12);\n}\n\n \nstatic int emac_dev_open(struct net_device *ndev)\n{\n\tstruct device *emac_dev = &ndev->dev;\n\tstruct resource *res;\n\tint q, m, ret;\n\tint res_num = 0, irq_num = 0;\n\tint i = 0;\n\tstruct emac_priv *priv = netdev_priv(ndev);\n\tstruct phy_device *phydev = NULL;\n\tstruct device *phy = NULL;\n\n\tret = pm_runtime_resume_and_get(&priv->pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&priv->pdev->dev, \"%s: failed to get_sync(%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tnetif_carrier_off(ndev);\n\teth_hw_addr_set(ndev, priv->mac_addr);\n\n\t \n\tpriv->rx_buf_size = EMAC_DEF_MAX_FRAME_SIZE + NET_IP_ALIGN;\n\n\tpriv->mac_hash1 = 0;\n\tpriv->mac_hash2 = 0;\n\temac_write(EMAC_MACHASH1, 0);\n\temac_write(EMAC_MACHASH2, 0);\n\n\tfor (i = 0; i < EMAC_DEF_RX_NUM_DESC; i++) {\n\t\tstruct sk_buff *skb = emac_rx_alloc(priv);\n\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tret = cpdma_chan_idle_submit(priv->rxchan, skb, skb->data,\n\t\t\t\t\t     skb_tailroom(skb), 0);\n\t\tif (WARN_ON(ret < 0))\n\t\t\tbreak;\n\t}\n\n\t \n\tif (dev_of_node(&priv->pdev->dev)) {\n\t\twhile ((ret = platform_get_irq_optional(priv->pdev, res_num)) != -ENXIO) {\n\t\t\tif (ret < 0)\n\t\t\t\tgoto rollback;\n\n\t\t\tret = request_irq(ret, emac_irq, 0, ndev->name, ndev);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(emac_dev, \"DaVinci EMAC: request_irq() failed\\n\");\n\t\t\t\tgoto rollback;\n\t\t\t}\n\t\t\tres_num++;\n\t\t}\n\t} else {\n\t\twhile ((res = platform_get_resource(priv->pdev, IORESOURCE_IRQ, res_num))) {\n\t\t\tfor (irq_num = res->start; irq_num <= res->end; irq_num++) {\n\t\t\t\tret = request_irq(irq_num, emac_irq, 0, ndev->name, ndev);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(emac_dev, \"DaVinci EMAC: request_irq() failed\\n\");\n\t\t\t\t\tgoto rollback;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres_num++;\n\t\t}\n\t\t \n\t\tres_num--;\n\t\tirq_num--;\n\t}\n\n\t \n\temac_hw_enable(priv);\n\n\t \n\tif (priv->coal_intvl != 0) {\n\t\tstruct ethtool_coalesce coal;\n\n\t\tcoal.rx_coalesce_usecs = (priv->coal_intvl << 4);\n\t\temac_set_coalesce(ndev, &coal, NULL, NULL);\n\t}\n\n\tcpdma_ctlr_start(priv->dma);\n\n\tif (priv->phy_node) {\n\t\tphydev = of_phy_connect(ndev, priv->phy_node,\n\t\t\t\t\t&emac_adjust_link, 0, 0);\n\t\tif (!phydev) {\n\t\t\tdev_err(emac_dev, \"could not connect to phy %pOF\\n\",\n\t\t\t\tpriv->phy_node);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tif (!phydev && !priv->phy_id) {\n\t\t \n\t\tphy = bus_find_device(&mdio_bus_type, NULL, NULL,\n\t\t\t\t      match_first_device);\n\t\tif (phy) {\n\t\t\tpriv->phy_id = dev_name(phy);\n\t\t\tif (!priv->phy_id || !*priv->phy_id)\n\t\t\t\tput_device(phy);\n\t\t}\n\t}\n\n\tif (!phydev && priv->phy_id && *priv->phy_id) {\n\t\tphydev = phy_connect(ndev, priv->phy_id,\n\t\t\t\t     &emac_adjust_link,\n\t\t\t\t     PHY_INTERFACE_MODE_MII);\n\t\tput_device(phy);\t \n\t\tif (IS_ERR(phydev)) {\n\t\t\tdev_err(emac_dev, \"could not connect to phy %s\\n\",\n\t\t\t\tpriv->phy_id);\n\t\t\tret = PTR_ERR(phydev);\n\t\t\tgoto err;\n\t\t}\n\n\t\tpriv->link = 0;\n\t\tpriv->speed = 0;\n\t\tpriv->duplex = ~0;\n\n\t\tphy_attached_info(phydev);\n\t}\n\n\tif (!phydev) {\n\t\t \n\t\tdev_notice(emac_dev, \"no phy, defaulting to 100/full\\n\");\n\t\tpriv->link = 1;\n\t\tpriv->speed = SPEED_100;\n\t\tpriv->duplex = DUPLEX_FULL;\n\t\temac_update_phystatus(priv);\n\t}\n\n\tif (netif_msg_drv(priv))\n\t\tdev_notice(emac_dev, \"DaVinci EMAC: Opened %s\\n\", ndev->name);\n\n\tif (phydev)\n\t\tphy_start(phydev);\n\n\treturn 0;\n\nerr:\n\temac_int_disable(priv);\n\tnapi_disable(&priv->napi);\n\nrollback:\n\tif (dev_of_node(&priv->pdev->dev)) {\n\t\tfor (q = res_num - 1; q >= 0; q--) {\n\t\t\tirq_num = platform_get_irq(priv->pdev, q);\n\t\t\tif (irq_num > 0)\n\t\t\t\tfree_irq(irq_num, ndev);\n\t\t}\n\t} else {\n\t\tfor (q = res_num; q >= 0; q--) {\n\t\t\tres = platform_get_resource(priv->pdev, IORESOURCE_IRQ, q);\n\t\t\t \n\t\t\tif (q != res_num)\n\t\t\t\tirq_num = res->end;\n\n\t\t\tfor (m = irq_num; m >= res->start; m--)\n\t\t\t\tfree_irq(m, ndev);\n\t\t}\n\t}\n\tcpdma_ctlr_stop(priv->dma);\n\tpm_runtime_put(&priv->pdev->dev);\n\treturn ret;\n}\n\n \nstatic int emac_dev_stop(struct net_device *ndev)\n{\n\tstruct resource *res;\n\tint i = 0;\n\tint irq_num;\n\tstruct emac_priv *priv = netdev_priv(ndev);\n\tstruct device *emac_dev = &ndev->dev;\n\tint ret = 0;\n\n\t \n\tnetif_stop_queue(ndev);\n\tnapi_disable(&priv->napi);\n\n\tnetif_carrier_off(ndev);\n\temac_int_disable(priv);\n\tcpdma_ctlr_stop(priv->dma);\n\temac_write(EMAC_SOFTRESET, 1);\n\n\tif (ndev->phydev)\n\t\tphy_disconnect(ndev->phydev);\n\n\t \n\tif (dev_of_node(&priv->pdev->dev)) {\n\t\tdo {\n\t\t\tret = platform_get_irq_optional(priv->pdev, i);\n\t\t\tif (ret < 0 && ret != -ENXIO)\n\t\t\t\tbreak;\n\t\t\tif (ret > 0) {\n\t\t\t\tfree_irq(ret, priv->ndev);\n\t\t\t} else {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (++i);\n\t} else {\n\t\twhile ((res = platform_get_resource(priv->pdev, IORESOURCE_IRQ, i))) {\n\t\t\tfor (irq_num = res->start; irq_num <= res->end; irq_num++)\n\t\t\t\tfree_irq(irq_num, priv->ndev);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (netif_msg_drv(priv))\n\t\tdev_notice(emac_dev, \"DaVinci EMAC: %s stopped\\n\", ndev->name);\n\n\tpm_runtime_put(&priv->pdev->dev);\n\treturn ret;\n}\n\n \nstatic struct net_device_stats *emac_dev_getnetstats(struct net_device *ndev)\n{\n\tstruct emac_priv *priv = netdev_priv(ndev);\n\tu32 mac_control;\n\tu32 stats_clear_mask;\n\tint err;\n\n\terr = pm_runtime_resume_and_get(&priv->pdev->dev);\n\tif (err < 0) {\n\t\tdev_err(&priv->pdev->dev, \"%s: failed to get_sync(%d)\\n\",\n\t\t\t__func__, err);\n\t\treturn &ndev->stats;\n\t}\n\n\t \n\n\tmac_control = emac_read(EMAC_MACCONTROL);\n\n\tif (mac_control & EMAC_MACCONTROL_GMIIEN)\n\t\tstats_clear_mask = EMAC_STATS_CLR_MASK;\n\telse\n\t\tstats_clear_mask = 0;\n\n\tndev->stats.multicast += emac_read(EMAC_RXMCASTFRAMES);\n\temac_write(EMAC_RXMCASTFRAMES, stats_clear_mask);\n\n\tndev->stats.collisions += (emac_read(EMAC_TXCOLLISION) +\n\t\t\t\t\t   emac_read(EMAC_TXSINGLECOLL) +\n\t\t\t\t\t   emac_read(EMAC_TXMULTICOLL));\n\temac_write(EMAC_TXCOLLISION, stats_clear_mask);\n\temac_write(EMAC_TXSINGLECOLL, stats_clear_mask);\n\temac_write(EMAC_TXMULTICOLL, stats_clear_mask);\n\n\tndev->stats.rx_length_errors += (emac_read(EMAC_RXOVERSIZED) +\n\t\t\t\t\t\temac_read(EMAC_RXJABBER) +\n\t\t\t\t\t\temac_read(EMAC_RXUNDERSIZED));\n\temac_write(EMAC_RXOVERSIZED, stats_clear_mask);\n\temac_write(EMAC_RXJABBER, stats_clear_mask);\n\temac_write(EMAC_RXUNDERSIZED, stats_clear_mask);\n\n\tndev->stats.rx_over_errors += (emac_read(EMAC_RXSOFOVERRUNS) +\n\t\t\t\t\t       emac_read(EMAC_RXMOFOVERRUNS));\n\temac_write(EMAC_RXSOFOVERRUNS, stats_clear_mask);\n\temac_write(EMAC_RXMOFOVERRUNS, stats_clear_mask);\n\n\tndev->stats.rx_fifo_errors += emac_read(EMAC_RXDMAOVERRUNS);\n\temac_write(EMAC_RXDMAOVERRUNS, stats_clear_mask);\n\n\tndev->stats.tx_carrier_errors +=\n\t\temac_read(EMAC_TXCARRIERSENSE);\n\temac_write(EMAC_TXCARRIERSENSE, stats_clear_mask);\n\n\tndev->stats.tx_fifo_errors += emac_read(EMAC_TXUNDERRUN);\n\temac_write(EMAC_TXUNDERRUN, stats_clear_mask);\n\n\tpm_runtime_put(&priv->pdev->dev);\n\n\treturn &ndev->stats;\n}\n\nstatic const struct net_device_ops emac_netdev_ops = {\n\t.ndo_open\t\t= emac_dev_open,\n\t.ndo_stop\t\t= emac_dev_stop,\n\t.ndo_start_xmit\t\t= emac_dev_xmit,\n\t.ndo_set_rx_mode\t= emac_dev_mcast_set,\n\t.ndo_set_mac_address\t= emac_dev_setmac_addr,\n\t.ndo_eth_ioctl\t\t= emac_devioctl,\n\t.ndo_tx_timeout\t\t= emac_dev_tx_timeout,\n\t.ndo_get_stats\t\t= emac_dev_getnetstats,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= emac_poll_controller,\n#endif\n};\n\nstatic const struct of_device_id davinci_emac_of_match[];\n\nstatic struct emac_platform_data *\ndavinci_emac_of_get_pdata(struct platform_device *pdev, struct emac_priv *priv)\n{\n\tstruct device_node *np;\n\tconst struct of_device_id *match;\n\tconst struct emac_platform_data *auxdata;\n\tstruct emac_platform_data *pdata = NULL;\n\n\tif (!IS_ENABLED(CONFIG_OF) || !pdev->dev.of_node)\n\t\treturn dev_get_platdata(&pdev->dev);\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tnp = pdev->dev.of_node;\n\tpdata->version = EMAC_VERSION_2;\n\n\tif (!is_valid_ether_addr(pdata->mac_addr))\n\t\tof_get_mac_address(np, pdata->mac_addr);\n\n\tof_property_read_u32(np, \"ti,davinci-ctrl-reg-offset\",\n\t\t\t     &pdata->ctrl_reg_offset);\n\n\tof_property_read_u32(np, \"ti,davinci-ctrl-mod-reg-offset\",\n\t\t\t     &pdata->ctrl_mod_reg_offset);\n\n\tof_property_read_u32(np, \"ti,davinci-ctrl-ram-offset\",\n\t\t\t     &pdata->ctrl_ram_offset);\n\n\tof_property_read_u32(np, \"ti,davinci-ctrl-ram-size\",\n\t\t\t     &pdata->ctrl_ram_size);\n\n\tof_property_read_u8(np, \"ti,davinci-rmii-en\", &pdata->rmii_en);\n\n\tpdata->no_bd_ram = of_property_read_bool(np, \"ti,davinci-no-bd-ram\");\n\n\tpriv->phy_node = of_parse_phandle(np, \"phy-handle\", 0);\n\tif (!priv->phy_node) {\n\t\tif (!of_phy_is_fixed_link(np))\n\t\t\tpdata->phy_id = NULL;\n\t\telse if (of_phy_register_fixed_link(np) >= 0)\n\t\t\tpriv->phy_node = of_node_get(np);\n\t}\n\n\tauxdata = pdev->dev.platform_data;\n\tif (auxdata) {\n\t\tpdata->interrupt_enable = auxdata->interrupt_enable;\n\t\tpdata->interrupt_disable = auxdata->interrupt_disable;\n\t}\n\n\tmatch = of_match_device(davinci_emac_of_match, &pdev->dev);\n\tif (match && match->data) {\n\t\tauxdata = match->data;\n\t\tpdata->version = auxdata->version;\n\t\tpdata->hw_ram_addr = auxdata->hw_ram_addr;\n\t}\n\n\treturn  pdata;\n}\n\nstatic int davinci_emac_try_get_mac(struct platform_device *pdev,\n\t\t\t\t    int instance, u8 *mac_addr)\n{\n\tif (!pdev->dev.of_node)\n\t\treturn -EINVAL;\n\n\treturn ti_cm_get_macid(&pdev->dev, instance, mac_addr);\n}\n\n \nstatic int davinci_emac_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint rc = 0;\n\tstruct resource *res, *res_ctrl;\n\tstruct net_device *ndev;\n\tstruct emac_priv *priv;\n\tunsigned long hw_ram_addr;\n\tstruct emac_platform_data *pdata;\n\tstruct cpdma_params dma_params;\n\tstruct clk *emac_clk;\n\tunsigned long emac_bus_frequency;\n\n\n\t \n\temac_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(emac_clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get EMAC clock\\n\");\n\t\treturn -EBUSY;\n\t}\n\temac_bus_frequency = clk_get_rate(emac_clk);\n\tdevm_clk_put(&pdev->dev, emac_clk);\n\n\t \n\n\tndev = alloc_etherdev(sizeof(struct emac_priv));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ndev);\n\tpriv = netdev_priv(ndev);\n\tpriv->pdev = pdev;\n\tpriv->ndev = ndev;\n\tpriv->msg_enable = netif_msg_init(debug_level, DAVINCI_EMAC_DEBUG);\n\n\tspin_lock_init(&priv->lock);\n\n\tpdata = davinci_emac_of_get_pdata(pdev, priv);\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"no platform data\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_free_netdev;\n\t}\n\n\t \n\tmemcpy(priv->mac_addr, pdata->mac_addr, ETH_ALEN);\n\tpriv->phy_id = pdata->phy_id;\n\tpriv->rmii_en = pdata->rmii_en;\n\tpriv->version = pdata->version;\n\tpriv->int_enable = pdata->interrupt_enable;\n\tpriv->int_disable = pdata->interrupt_disable;\n\n\tpriv->coal_intvl = 0;\n\tpriv->bus_freq_mhz = (u32)(emac_bus_frequency / 1000000);\n\n\t \n\tpriv->remap_addr = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(priv->remap_addr)) {\n\t\trc = PTR_ERR(priv->remap_addr);\n\t\tgoto no_pdata;\n\t}\n\tpriv->emac_base_phys = res->start + pdata->ctrl_reg_offset;\n\n\tres_ctrl = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (res_ctrl) {\n\t\tpriv->ctrl_base =\n\t\t\tdevm_ioremap_resource(&pdev->dev, res_ctrl);\n\t\tif (IS_ERR(priv->ctrl_base)) {\n\t\t\trc = PTR_ERR(priv->ctrl_base);\n\t\t\tgoto no_pdata;\n\t\t}\n\t} else {\n\t\tpriv->ctrl_base = priv->remap_addr + pdata->ctrl_mod_reg_offset;\n\t}\n\n\tpriv->emac_base = priv->remap_addr + pdata->ctrl_reg_offset;\n\tndev->base_addr = (unsigned long)priv->remap_addr;\n\n\thw_ram_addr = pdata->hw_ram_addr;\n\tif (!hw_ram_addr)\n\t\thw_ram_addr = (u32 __force)res->start + pdata->ctrl_ram_offset;\n\n\tmemset(&dma_params, 0, sizeof(dma_params));\n\tdma_params.dev\t\t\t= &pdev->dev;\n\tdma_params.dmaregs\t\t= priv->emac_base;\n\tdma_params.rxthresh\t\t= priv->emac_base + 0x120;\n\tdma_params.rxfree\t\t= priv->emac_base + 0x140;\n\tdma_params.txhdp\t\t= priv->emac_base + 0x600;\n\tdma_params.rxhdp\t\t= priv->emac_base + 0x620;\n\tdma_params.txcp\t\t\t= priv->emac_base + 0x640;\n\tdma_params.rxcp\t\t\t= priv->emac_base + 0x660;\n\tdma_params.num_chan\t\t= EMAC_MAX_TXRX_CHANNELS;\n\tdma_params.min_packet_size\t= EMAC_DEF_MIN_ETHPKTSIZE;\n\tdma_params.desc_hw_addr\t\t= hw_ram_addr;\n\tdma_params.desc_mem_size\t= pdata->ctrl_ram_size;\n\tdma_params.desc_align\t\t= 16;\n\n\tdma_params.desc_mem_phys = pdata->no_bd_ram ? 0 :\n\t\t\t(u32 __force)res->start + pdata->ctrl_ram_offset;\n\n\tpriv->dma = cpdma_ctlr_create(&dma_params);\n\tif (!priv->dma) {\n\t\tdev_err(&pdev->dev, \"error initializing DMA\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto no_pdata;\n\t}\n\n\tpriv->txchan = cpdma_chan_create(priv->dma, EMAC_DEF_TX_CH,\n\t\t\t\t\t emac_tx_handler, 0);\n\tif (IS_ERR(priv->txchan)) {\n\t\tdev_err(&pdev->dev, \"error initializing tx dma channel\\n\");\n\t\trc = PTR_ERR(priv->txchan);\n\t\tgoto err_free_dma;\n\t}\n\n\tpriv->rxchan = cpdma_chan_create(priv->dma, EMAC_DEF_RX_CH,\n\t\t\t\t\t emac_rx_handler, 1);\n\tif (IS_ERR(priv->rxchan)) {\n\t\tdev_err(&pdev->dev, \"error initializing rx dma channel\\n\");\n\t\trc = PTR_ERR(priv->rxchan);\n\t\tgoto err_free_txchan;\n\t}\n\n\trc = platform_get_irq(pdev, 0);\n\tif (rc < 0)\n\t\tgoto err_free_rxchan;\n\tndev->irq = rc;\n\n\trc = davinci_emac_try_get_mac(pdev, res_ctrl ? 0 : 1, priv->mac_addr);\n\tif (!rc)\n\t\teth_hw_addr_set(ndev, priv->mac_addr);\n\n\tif (!is_valid_ether_addr(priv->mac_addr)) {\n\t\t \n\t\teth_hw_addr_random(ndev);\n\t\tmemcpy(priv->mac_addr, ndev->dev_addr, ndev->addr_len);\n\t\tdev_warn(&pdev->dev, \"using random MAC addr: %pM\\n\",\n\t\t\t priv->mac_addr);\n\t}\n\n\tndev->netdev_ops = &emac_netdev_ops;\n\tndev->ethtool_ops = &ethtool_ops;\n\tnetif_napi_add(ndev, &priv->napi, emac_poll);\n\n\tpm_runtime_enable(&pdev->dev);\n\trc = pm_runtime_resume_and_get(&pdev->dev);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"%s: failed to get_sync(%d)\\n\",\n\t\t\t__func__, rc);\n\t\tgoto err_napi_del;\n\t}\n\n\t \n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\trc = register_netdev(ndev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"error in register_netdev\\n\");\n\t\trc = -ENODEV;\n\t\tpm_runtime_put(&pdev->dev);\n\t\tgoto err_napi_del;\n\t}\n\n\n\tif (netif_msg_probe(priv)) {\n\t\tdev_notice(&pdev->dev, \"DaVinci EMAC Probe found device \"\n\t\t\t   \"(regs: %pa, irq: %d)\\n\",\n\t\t\t   &priv->emac_base_phys, ndev->irq);\n\t}\n\tpm_runtime_put(&pdev->dev);\n\n\treturn 0;\n\nerr_napi_del:\n\tnetif_napi_del(&priv->napi);\nerr_free_rxchan:\n\tcpdma_chan_destroy(priv->rxchan);\nerr_free_txchan:\n\tcpdma_chan_destroy(priv->txchan);\nerr_free_dma:\n\tcpdma_ctlr_destroy(priv->dma);\nno_pdata:\n\tif (of_phy_is_fixed_link(np))\n\t\tof_phy_deregister_fixed_link(np);\n\tof_node_put(priv->phy_node);\nerr_free_netdev:\n\tfree_netdev(ndev);\n\treturn rc;\n}\n\n \nstatic int davinci_emac_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct emac_priv *priv = netdev_priv(ndev);\n\tstruct device_node *np = pdev->dev.of_node;\n\n\tdev_notice(&ndev->dev, \"DaVinci EMAC: davinci_emac_remove()\\n\");\n\n\tif (priv->txchan)\n\t\tcpdma_chan_destroy(priv->txchan);\n\tif (priv->rxchan)\n\t\tcpdma_chan_destroy(priv->rxchan);\n\tcpdma_ctlr_destroy(priv->dma);\n\n\tunregister_netdev(ndev);\n\tof_node_put(priv->phy_node);\n\tpm_runtime_disable(&pdev->dev);\n\tif (of_phy_is_fixed_link(np))\n\t\tof_phy_deregister_fixed_link(np);\n\tfree_netdev(ndev);\n\n\treturn 0;\n}\n\nstatic int davinci_emac_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\n\tif (netif_running(ndev))\n\t\temac_dev_stop(ndev);\n\n\treturn 0;\n}\n\nstatic int davinci_emac_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\n\tif (netif_running(ndev))\n\t\temac_dev_open(ndev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops davinci_emac_pm_ops = {\n\t.suspend\t= davinci_emac_suspend,\n\t.resume\t\t= davinci_emac_resume,\n};\n\nstatic const struct emac_platform_data am3517_emac_data = {\n\t.version\t\t= EMAC_VERSION_2,\n\t.hw_ram_addr\t\t= 0x01e20000,\n};\n\nstatic const struct emac_platform_data dm816_emac_data = {\n\t.version\t\t= EMAC_VERSION_2,\n};\n\nstatic const struct of_device_id davinci_emac_of_match[] = {\n\t{.compatible = \"ti,davinci-dm6467-emac\", },\n\t{.compatible = \"ti,am3517-emac\", .data = &am3517_emac_data, },\n\t{.compatible = \"ti,dm816-emac\", .data = &dm816_emac_data, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, davinci_emac_of_match);\n\n \nstatic struct platform_driver davinci_emac_driver = {\n\t.driver = {\n\t\t.name\t = \"davinci_emac\",\n\t\t.pm\t = &davinci_emac_pm_ops,\n\t\t.of_match_table = davinci_emac_of_match,\n\t},\n\t.probe = davinci_emac_probe,\n\t.remove = davinci_emac_remove,\n};\n\n \nstatic int __init davinci_emac_init(void)\n{\n\treturn platform_driver_register(&davinci_emac_driver);\n}\nlate_initcall(davinci_emac_init);\n\n \nstatic void __exit davinci_emac_exit(void)\n{\n\tplatform_driver_unregister(&davinci_emac_driver);\n}\nmodule_exit(davinci_emac_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"DaVinci EMAC Maintainer: Anant Gole <anantgole@ti.com>\");\nMODULE_AUTHOR(\"DaVinci EMAC Maintainer: Chaithrika U S <chaithrika@ti.com>\");\nMODULE_DESCRIPTION(\"DaVinci EMAC Ethernet driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}