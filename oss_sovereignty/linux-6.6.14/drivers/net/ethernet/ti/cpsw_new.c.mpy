{
  "module_name": "cpsw_new.c",
  "hash_id": "8b3a877e1706c3c534c0184872c8e951f9e47aaf6c5d449097cad2860c4a28e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/cpsw_new.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/platform_device.h>\n#include <linux/timer.h>\n#include <linux/module.h>\n#include <linux/irqreturn.h>\n#include <linux/interrupt.h>\n#include <linux/if_ether.h>\n#include <linux/etherdevice.h>\n#include <linux/net_tstamp.h>\n#include <linux/phy.h>\n#include <linux/phy/phy.h>\n#include <linux/delay.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_platform.h>\n#include <linux/if_vlan.h>\n#include <linux/kmemleak.h>\n#include <linux/sys_soc.h>\n\n#include <net/switchdev.h>\n#include <net/page_pool/helpers.h>\n#include <net/pkt_cls.h>\n#include <net/devlink.h>\n\n#include \"cpsw.h\"\n#include \"cpsw_ale.h\"\n#include \"cpsw_priv.h\"\n#include \"cpsw_sl.h\"\n#include \"cpsw_switchdev.h\"\n#include \"cpts.h\"\n#include \"davinci_cpdma.h\"\n\n#include <net/pkt_sched.h>\n\nstatic int debug_level;\nstatic int ale_ageout = CPSW_ALE_AGEOUT_DEFAULT;\nstatic int rx_packet_max = CPSW_MAX_PACKET_SIZE;\nstatic int descs_pool_size = CPSW_CPDMA_DESCS_POOL_SIZE_DEFAULT;\n\nstruct cpsw_devlink {\n\tstruct cpsw_common *cpsw;\n};\n\nenum cpsw_devlink_param_id {\n\tCPSW_DEVLINK_PARAM_ID_BASE = DEVLINK_PARAM_GENERIC_ID_MAX,\n\tCPSW_DL_PARAM_SWITCH_MODE,\n\tCPSW_DL_PARAM_ALE_BYPASS,\n};\n\n \nstatic int cpsw_slave_index_priv(struct cpsw_common *cpsw,\n\t\t\t\t struct cpsw_priv *priv)\n{\n\tif (priv->emac_port == HOST_PORT_NUM)\n\t\treturn -1;\n\n\treturn priv->emac_port - 1;\n}\n\nstatic bool cpsw_is_switch_en(struct cpsw_common *cpsw)\n{\n\treturn !cpsw->data.dual_emac;\n}\n\nstatic void cpsw_set_promiscious(struct net_device *ndev, bool enable)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\tbool enable_uni = false;\n\tint i;\n\n\tif (cpsw_is_switch_en(cpsw))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < cpsw->data.slaves; i++)\n\t\tif (cpsw->slaves[i].ndev &&\n\t\t    (cpsw->slaves[i].ndev->flags & IFF_PROMISC))\n\t\t\tenable_uni = true;\n\n\tif (!enable && enable_uni) {\n\t\tenable = enable_uni;\n\t\tdev_dbg(cpsw->dev, \"promiscuity not disabled as the other interface is still in promiscuity mode\\n\");\n\t}\n\n\tif (enable) {\n\t\t \n\t\tcpsw_ale_control_set(cpsw->ale, HOST_PORT_NUM,\n\t\t\t\t     ALE_P0_UNI_FLOOD, 1);\n\n\t\tdev_dbg(cpsw->dev, \"promiscuity enabled\\n\");\n\t} else {\n\t\t \n\t\tcpsw_ale_control_set(cpsw->ale, HOST_PORT_NUM,\n\t\t\t\t     ALE_P0_UNI_FLOOD, 0);\n\t\tdev_dbg(cpsw->dev, \"promiscuity disabled\\n\");\n\t}\n}\n\n \nstatic int cpsw_set_mc(struct net_device *ndev, const u8 *addr,\n\t\t       int vid, int add)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint mask, flags, ret, slave_no;\n\n\tslave_no = cpsw_slave_index(cpsw, priv);\n\tif (vid < 0)\n\t\tvid = cpsw->slaves[slave_no].port_vlan;\n\n\tmask =  ALE_PORT_HOST;\n\tflags = vid ? ALE_VLAN : 0;\n\n\tif (add)\n\t\tret = cpsw_ale_add_mcast(cpsw->ale, addr, mask, flags, vid, 0);\n\telse\n\t\tret = cpsw_ale_del_mcast(cpsw->ale, addr, 0, flags, vid);\n\n\treturn ret;\n}\n\nstatic int cpsw_update_vlan_mc(struct net_device *vdev, int vid, void *ctx)\n{\n\tstruct addr_sync_ctx *sync_ctx = ctx;\n\tstruct netdev_hw_addr *ha;\n\tint found = 0, ret = 0;\n\n\tif (!vdev || !(vdev->flags & IFF_UP))\n\t\treturn 0;\n\n\t \n\tnetdev_for_each_mc_addr(ha, vdev) {\n\t\tif (ether_addr_equal(ha->addr, sync_ctx->addr)) {\n\t\t\tfound = ha->sync_cnt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found)\n\t\tsync_ctx->consumed++;\n\n\tif (sync_ctx->flush) {\n\t\tif (!found)\n\t\t\tcpsw_set_mc(sync_ctx->ndev, sync_ctx->addr, vid, 0);\n\t\treturn 0;\n\t}\n\n\tif (found)\n\t\tret = cpsw_set_mc(sync_ctx->ndev, sync_ctx->addr, vid, 1);\n\n\treturn ret;\n}\n\nstatic int cpsw_add_mc_addr(struct net_device *ndev, const u8 *addr, int num)\n{\n\tstruct addr_sync_ctx sync_ctx;\n\tint ret;\n\n\tsync_ctx.consumed = 0;\n\tsync_ctx.addr = addr;\n\tsync_ctx.ndev = ndev;\n\tsync_ctx.flush = 0;\n\n\tret = vlan_for_each(ndev, cpsw_update_vlan_mc, &sync_ctx);\n\tif (sync_ctx.consumed < num && !ret)\n\t\tret = cpsw_set_mc(ndev, addr, -1, 1);\n\n\treturn ret;\n}\n\nstatic int cpsw_del_mc_addr(struct net_device *ndev, const u8 *addr, int num)\n{\n\tstruct addr_sync_ctx sync_ctx;\n\n\tsync_ctx.consumed = 0;\n\tsync_ctx.addr = addr;\n\tsync_ctx.ndev = ndev;\n\tsync_ctx.flush = 1;\n\n\tvlan_for_each(ndev, cpsw_update_vlan_mc, &sync_ctx);\n\tif (sync_ctx.consumed == num)\n\t\tcpsw_set_mc(ndev, addr, -1, 0);\n\n\treturn 0;\n}\n\nstatic int cpsw_purge_vlan_mc(struct net_device *vdev, int vid, void *ctx)\n{\n\tstruct addr_sync_ctx *sync_ctx = ctx;\n\tstruct netdev_hw_addr *ha;\n\tint found = 0;\n\n\tif (!vdev || !(vdev->flags & IFF_UP))\n\t\treturn 0;\n\n\t \n\tnetdev_for_each_mc_addr(ha, vdev) {\n\t\tif (ether_addr_equal(ha->addr, sync_ctx->addr)) {\n\t\t\tfound = ha->sync_cnt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn 0;\n\n\tsync_ctx->consumed++;\n\tcpsw_set_mc(sync_ctx->ndev, sync_ctx->addr, vid, 0);\n\treturn 0;\n}\n\nstatic int cpsw_purge_all_mc(struct net_device *ndev, const u8 *addr, int num)\n{\n\tstruct addr_sync_ctx sync_ctx;\n\n\tsync_ctx.addr = addr;\n\tsync_ctx.ndev = ndev;\n\tsync_ctx.consumed = 0;\n\n\tvlan_for_each(ndev, cpsw_purge_vlan_mc, &sync_ctx);\n\tif (sync_ctx.consumed < num)\n\t\tcpsw_set_mc(ndev, addr, -1, 0);\n\n\treturn 0;\n}\n\nstatic void cpsw_ndo_set_rx_mode(struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\n\tif (ndev->flags & IFF_PROMISC) {\n\t\t \n\t\tcpsw_set_promiscious(ndev, true);\n\t\tcpsw_ale_set_allmulti(cpsw->ale, IFF_ALLMULTI, priv->emac_port);\n\t\treturn;\n\t}\n\n\t \n\tcpsw_set_promiscious(ndev, false);\n\n\t \n\tcpsw_ale_set_allmulti(cpsw->ale,\n\t\t\t      ndev->flags & IFF_ALLMULTI, priv->emac_port);\n\n\t \n\t__hw_addr_ref_sync_dev(&ndev->mc, ndev, cpsw_add_mc_addr,\n\t\t\t       cpsw_del_mc_addr);\n}\n\nstatic unsigned int cpsw_rxbuf_total_len(unsigned int len)\n{\n\tlen += CPSW_HEADROOM_NA;\n\tlen += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\n\treturn SKB_DATA_ALIGN(len);\n}\n\nstatic void cpsw_rx_handler(void *token, int len, int status)\n{\n\tstruct page *new_page, *page = token;\n\tvoid *pa = page_address(page);\n\tint headroom = CPSW_HEADROOM_NA;\n\tstruct cpsw_meta_xdp *xmeta;\n\tstruct cpsw_common *cpsw;\n\tstruct net_device *ndev;\n\tint port, ch, pkt_size;\n\tstruct cpsw_priv *priv;\n\tstruct page_pool *pool;\n\tstruct sk_buff *skb;\n\tstruct xdp_buff xdp;\n\tint ret = 0;\n\tdma_addr_t dma;\n\n\txmeta = pa + CPSW_XMETA_OFFSET;\n\tcpsw = ndev_to_cpsw(xmeta->ndev);\n\tndev = xmeta->ndev;\n\tpkt_size = cpsw->rx_packet_max;\n\tch = xmeta->ch;\n\n\tif (status >= 0) {\n\t\tport = CPDMA_RX_SOURCE_PORT(status);\n\t\tif (port)\n\t\t\tndev = cpsw->slaves[--port].ndev;\n\t}\n\n\tpriv = netdev_priv(ndev);\n\tpool = cpsw->page_pool[ch];\n\n\tif (unlikely(status < 0) || unlikely(!netif_running(ndev))) {\n\t\t \n\t\tif (cpsw->usage_count && status >= 0) {\n\t\t\t \n\t\t\tnew_page = page;\n\t\t\tgoto requeue;\n\t\t}\n\n\t\t \n\t\tpage_pool_recycle_direct(pool, page);\n\t\treturn;\n\t}\n\n\tnew_page = page_pool_dev_alloc_pages(pool);\n\tif (unlikely(!new_page)) {\n\t\tnew_page = page;\n\t\tndev->stats.rx_dropped++;\n\t\tgoto requeue;\n\t}\n\n\tif (priv->xdp_prog) {\n\t\tint size = len;\n\n\t\txdp_init_buff(&xdp, PAGE_SIZE, &priv->xdp_rxq[ch]);\n\t\tif (status & CPDMA_RX_VLAN_ENCAP) {\n\t\t\theadroom += CPSW_RX_VLAN_ENCAP_HDR_SIZE;\n\t\t\tsize -= CPSW_RX_VLAN_ENCAP_HDR_SIZE;\n\t\t}\n\n\t\txdp_prepare_buff(&xdp, pa, headroom, size, false);\n\n\t\tret = cpsw_run_xdp(priv, ch, &xdp, page, priv->emac_port, &len);\n\t\tif (ret != CPSW_XDP_PASS)\n\t\t\tgoto requeue;\n\n\t\theadroom = xdp.data - xdp.data_hard_start;\n\n\t\t \n\t\tstatus &= ~CPDMA_RX_VLAN_ENCAP;\n\t}\n\n\t \n\tskb = build_skb(pa, cpsw_rxbuf_total_len(pkt_size));\n\tif (!skb) {\n\t\tndev->stats.rx_dropped++;\n\t\tpage_pool_recycle_direct(pool, page);\n\t\tgoto requeue;\n\t}\n\n\tskb->offload_fwd_mark = priv->offload_fwd_mark;\n\tskb_reserve(skb, headroom);\n\tskb_put(skb, len);\n\tskb->dev = ndev;\n\tif (status & CPDMA_RX_VLAN_ENCAP)\n\t\tcpsw_rx_vlan_encap(skb);\n\tif (priv->rx_ts_enabled)\n\t\tcpts_rx_timestamp(cpsw->cpts, skb);\n\tskb->protocol = eth_type_trans(skb, ndev);\n\n\t \n\tskb_mark_for_recycle(skb);\n\tnetif_receive_skb(skb);\n\n\tndev->stats.rx_bytes += len;\n\tndev->stats.rx_packets++;\n\nrequeue:\n\txmeta = page_address(new_page) + CPSW_XMETA_OFFSET;\n\txmeta->ndev = ndev;\n\txmeta->ch = ch;\n\n\tdma = page_pool_get_dma_addr(new_page) + CPSW_HEADROOM_NA;\n\tret = cpdma_chan_submit_mapped(cpsw->rxv[ch].ch, new_page, dma,\n\t\t\t\t       pkt_size, 0);\n\tif (ret < 0) {\n\t\tWARN_ON(ret == -ENOMEM);\n\t\tpage_pool_recycle_direct(pool, new_page);\n\t}\n}\n\nstatic int cpsw_add_vlan_ale_entry(struct cpsw_priv *priv,\n\t\t\t\t   unsigned short vid)\n{\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint unreg_mcast_mask = 0;\n\tint mcast_mask;\n\tu32 port_mask;\n\tint ret;\n\n\tport_mask = (1 << priv->emac_port) | ALE_PORT_HOST;\n\n\tmcast_mask = ALE_PORT_HOST;\n\tif (priv->ndev->flags & IFF_ALLMULTI)\n\t\tunreg_mcast_mask = mcast_mask;\n\n\tret = cpsw_ale_add_vlan(cpsw->ale, vid, port_mask, 0, port_mask,\n\t\t\t\tunreg_mcast_mask);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = cpsw_ale_add_ucast(cpsw->ale, priv->mac_addr,\n\t\t\t\t HOST_PORT_NUM, ALE_VLAN, vid);\n\tif (ret != 0)\n\t\tgoto clean_vid;\n\n\tret = cpsw_ale_add_mcast(cpsw->ale, priv->ndev->broadcast,\n\t\t\t\t mcast_mask, ALE_VLAN, vid, 0);\n\tif (ret != 0)\n\t\tgoto clean_vlan_ucast;\n\treturn 0;\n\nclean_vlan_ucast:\n\tcpsw_ale_del_ucast(cpsw->ale, priv->mac_addr,\n\t\t\t   HOST_PORT_NUM, ALE_VLAN, vid);\nclean_vid:\n\tcpsw_ale_del_vlan(cpsw->ale, vid, 0);\n\treturn ret;\n}\n\nstatic int cpsw_ndo_vlan_rx_add_vid(struct net_device *ndev,\n\t\t\t\t    __be16 proto, u16 vid)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint ret, i;\n\n\tif (cpsw_is_switch_en(cpsw)) {\n\t\tdev_dbg(cpsw->dev, \".ndo_vlan_rx_add_vid called in switch mode\\n\");\n\t\treturn 0;\n\t}\n\n\tif (vid == cpsw->data.default_vlan)\n\t\treturn 0;\n\n\tret = pm_runtime_resume_and_get(cpsw->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\tif (cpsw->slaves[i].ndev &&\n\t\t    vid == cpsw->slaves[i].port_vlan) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tdev_dbg(priv->dev, \"Adding vlanid %d to vlan filter\\n\", vid);\n\tret = cpsw_add_vlan_ale_entry(priv, vid);\nerr:\n\tpm_runtime_put(cpsw->dev);\n\treturn ret;\n}\n\nstatic int cpsw_restore_vlans(struct net_device *vdev, int vid, void *arg)\n{\n\tstruct cpsw_priv *priv = arg;\n\n\tif (!vdev || !vid)\n\t\treturn 0;\n\n\tcpsw_ndo_vlan_rx_add_vid(priv->ndev, 0, vid);\n\treturn 0;\n}\n\n \nstatic void cpsw_restore(struct cpsw_priv *priv)\n{\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\n\t \n\tvlan_for_each(priv->ndev, cpsw_restore_vlans, priv);\n\n\t \n\tcpsw_mqprio_resume(&cpsw->slaves[priv->emac_port - 1], priv);\n\n\t \n\tcpsw_cbs_resume(&cpsw->slaves[priv->emac_port - 1], priv);\n\n\tcpsw_qos_clsflower_resume(priv);\n}\n\nstatic void cpsw_init_stp_ale_entry(struct cpsw_common *cpsw)\n{\n\tstatic const char stpa[] = {0x01, 0x80, 0xc2, 0x0, 0x0, 0x0};\n\n\tcpsw_ale_add_mcast(cpsw->ale, stpa,\n\t\t\t   ALE_PORT_HOST, ALE_SUPER, 0,\n\t\t\t   ALE_MCAST_BLOCK_LEARN_FWD);\n}\n\nstatic void cpsw_init_host_port_switch(struct cpsw_common *cpsw)\n{\n\tint vlan = cpsw->data.default_vlan;\n\n\twritel(CPSW_FIFO_NORMAL_MODE, &cpsw->host_port_regs->tx_in_ctl);\n\n\twritel(vlan, &cpsw->host_port_regs->port_vlan);\n\n\tcpsw_ale_add_vlan(cpsw->ale, vlan, ALE_ALL_PORTS,\n\t\t\t  ALE_ALL_PORTS, ALE_ALL_PORTS,\n\t\t\t  ALE_PORT_1 | ALE_PORT_2);\n\n\tcpsw_init_stp_ale_entry(cpsw);\n\n\tcpsw_ale_control_set(cpsw->ale, HOST_PORT_NUM, ALE_P0_UNI_FLOOD, 1);\n\tdev_dbg(cpsw->dev, \"Set P0_UNI_FLOOD\\n\");\n\tcpsw_ale_control_set(cpsw->ale, HOST_PORT_NUM, ALE_PORT_NOLEARN, 0);\n}\n\nstatic void cpsw_init_host_port_dual_mac(struct cpsw_common *cpsw)\n{\n\tint vlan = cpsw->data.default_vlan;\n\n\twritel(CPSW_FIFO_DUAL_MAC_MODE, &cpsw->host_port_regs->tx_in_ctl);\n\n\tcpsw_ale_control_set(cpsw->ale, HOST_PORT_NUM, ALE_P0_UNI_FLOOD, 0);\n\tdev_dbg(cpsw->dev, \"unset P0_UNI_FLOOD\\n\");\n\n\twritel(vlan, &cpsw->host_port_regs->port_vlan);\n\n\tcpsw_ale_add_vlan(cpsw->ale, vlan, ALE_ALL_PORTS, ALE_ALL_PORTS, 0, 0);\n\t \n\tcpsw_ale_control_set(cpsw->ale, HOST_PORT_NUM, ALE_PORT_NOLEARN, 1);\n}\n\nstatic void cpsw_init_host_port(struct cpsw_priv *priv)\n{\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tu32 control_reg;\n\n\t \n\tsoft_reset(\"cpsw\", &cpsw->regs->soft_reset);\n\tcpsw_ale_start(cpsw->ale);\n\n\t \n\tcpsw_ale_control_set(cpsw->ale, HOST_PORT_NUM, ALE_VLAN_AWARE,\n\t\t\t     CPSW_ALE_VLAN_AWARE);\n\tcontrol_reg = readl(&cpsw->regs->control);\n\tcontrol_reg |= CPSW_VLAN_AWARE | CPSW_RX_VLAN_ENCAP;\n\twritel(control_reg, &cpsw->regs->control);\n\n\t \n\twritel_relaxed(CPDMA_TX_PRIORITY_MAP,\n\t\t       &cpsw->host_port_regs->cpdma_tx_pri_map);\n\twritel_relaxed(0, &cpsw->host_port_regs->cpdma_rx_chan_map);\n\n\t \n\twritel_relaxed(0, &cpsw->regs->ptype);\n\n\t \n\twritel_relaxed(0x7, &cpsw->regs->stat_port_en);\n\n\t \n\twritel(0x7, &cpsw->regs->flow_control);\n\n\tif (cpsw_is_switch_en(cpsw))\n\t\tcpsw_init_host_port_switch(cpsw);\n\telse\n\t\tcpsw_init_host_port_dual_mac(cpsw);\n\n\tcpsw_ale_control_set(cpsw->ale, HOST_PORT_NUM,\n\t\t\t     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);\n}\n\nstatic void cpsw_port_add_dual_emac_def_ale_entries(struct cpsw_priv *priv,\n\t\t\t\t\t\t    struct cpsw_slave *slave)\n{\n\tu32 port_mask = 1 << priv->emac_port | ALE_PORT_HOST;\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tu32 reg;\n\n\treg = (cpsw->version == CPSW_VERSION_1) ? CPSW1_PORT_VLAN :\n\t       CPSW2_PORT_VLAN;\n\tslave_write(slave, slave->port_vlan, reg);\n\n\tcpsw_ale_add_vlan(cpsw->ale, slave->port_vlan, port_mask,\n\t\t\t  port_mask, port_mask, 0);\n\tcpsw_ale_add_mcast(cpsw->ale, priv->ndev->broadcast,\n\t\t\t   ALE_PORT_HOST, ALE_VLAN, slave->port_vlan,\n\t\t\t   ALE_MCAST_FWD);\n\tcpsw_ale_add_ucast(cpsw->ale, priv->mac_addr,\n\t\t\t   HOST_PORT_NUM, ALE_VLAN |\n\t\t\t   ALE_SECURE, slave->port_vlan);\n\tcpsw_ale_control_set(cpsw->ale, priv->emac_port,\n\t\t\t     ALE_PORT_DROP_UNKNOWN_VLAN, 1);\n\t \n\tcpsw_ale_control_set(cpsw->ale, priv->emac_port,\n\t\t\t     ALE_PORT_NOLEARN, 1);\n}\n\nstatic void cpsw_port_add_switch_def_ale_entries(struct cpsw_priv *priv,\n\t\t\t\t\t\t struct cpsw_slave *slave)\n{\n\tu32 port_mask = 1 << priv->emac_port | ALE_PORT_HOST;\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tu32 reg;\n\n\tcpsw_ale_control_set(cpsw->ale, priv->emac_port,\n\t\t\t     ALE_PORT_DROP_UNKNOWN_VLAN, 0);\n\tcpsw_ale_control_set(cpsw->ale, priv->emac_port,\n\t\t\t     ALE_PORT_NOLEARN, 0);\n\t \n\tcpsw_ale_control_set(cpsw->ale, priv->emac_port,\n\t\t\t     ALE_PORT_NO_SA_UPDATE, 1);\n\n\tcpsw_ale_add_mcast(cpsw->ale, priv->ndev->broadcast,\n\t\t\t   port_mask, ALE_VLAN, slave->port_vlan,\n\t\t\t   ALE_MCAST_FWD_2);\n\tcpsw_ale_add_ucast(cpsw->ale, priv->mac_addr,\n\t\t\t   HOST_PORT_NUM, ALE_VLAN, slave->port_vlan);\n\n\treg = (cpsw->version == CPSW_VERSION_1) ? CPSW1_PORT_VLAN :\n\t       CPSW2_PORT_VLAN;\n\tslave_write(slave, slave->port_vlan, reg);\n}\n\nstatic void cpsw_adjust_link(struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tstruct cpsw_slave *slave;\n\tstruct phy_device *phy;\n\tu32 mac_control = 0;\n\n\tslave = &cpsw->slaves[priv->emac_port - 1];\n\tphy = slave->phy;\n\n\tif (!phy)\n\t\treturn;\n\n\tif (phy->link) {\n\t\tmac_control = CPSW_SL_CTL_GMII_EN;\n\n\t\tif (phy->speed == 1000)\n\t\t\tmac_control |= CPSW_SL_CTL_GIG;\n\t\tif (phy->duplex)\n\t\t\tmac_control |= CPSW_SL_CTL_FULLDUPLEX;\n\n\t\t \n\t\tif (phy->speed == 100)\n\t\t\tmac_control |= CPSW_SL_CTL_IFCTL_A;\n\t\t \n\t\telse if ((phy->speed == 10) && phy_interface_is_rgmii(phy))\n\t\t\tmac_control |= CPSW_SL_CTL_EXT_EN;  \n\n\t\tif (priv->rx_pause)\n\t\t\tmac_control |= CPSW_SL_CTL_RX_FLOW_EN;\n\n\t\tif (priv->tx_pause)\n\t\t\tmac_control |= CPSW_SL_CTL_TX_FLOW_EN;\n\n\t\tif (mac_control != slave->mac_control)\n\t\t\tcpsw_sl_ctl_set(slave->mac_sl, mac_control);\n\n\t\t \n\t\tcpsw_ale_control_set(cpsw->ale, priv->emac_port,\n\t\t\t\t     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);\n\n\t\tnetif_tx_wake_all_queues(ndev);\n\n\t\tif (priv->shp_cfg_speed &&\n\t\t    priv->shp_cfg_speed != slave->phy->speed &&\n\t\t    !cpsw_shp_is_off(priv))\n\t\t\tdev_warn(priv->dev, \"Speed was changed, CBS shaper speeds are changed!\");\n\t} else {\n\t\tnetif_tx_stop_all_queues(ndev);\n\n\t\tmac_control = 0;\n\t\t \n\t\tcpsw_ale_control_set(cpsw->ale, priv->emac_port,\n\t\t\t\t     ALE_PORT_STATE, ALE_PORT_STATE_DISABLE);\n\n\t\tcpsw_sl_wait_for_idle(slave->mac_sl, 100);\n\n\t\tcpsw_sl_ctl_reset(slave->mac_sl);\n\t}\n\n\tif (mac_control != slave->mac_control)\n\t\tphy_print_status(phy);\n\n\tslave->mac_control = mac_control;\n\n\tif (phy->link && cpsw_need_resplit(cpsw))\n\t\tcpsw_split_res(cpsw);\n}\n\nstatic void cpsw_slave_open(struct cpsw_slave *slave, struct cpsw_priv *priv)\n{\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tstruct phy_device *phy;\n\n\tcpsw_sl_reset(slave->mac_sl, 100);\n\tcpsw_sl_ctl_reset(slave->mac_sl);\n\n\t \n\tcpsw_sl_reg_write(slave->mac_sl, CPSW_SL_RX_PRI_MAP,\n\t\t\t  RX_PRIORITY_MAPPING);\n\n\tswitch (cpsw->version) {\n\tcase CPSW_VERSION_1:\n\t\tslave_write(slave, TX_PRIORITY_MAPPING, CPSW1_TX_PRI_MAP);\n\t\t \n\t\tslave_write(slave,\n\t\t\t    (CPSW_MAX_BLKS_TX << CPSW_MAX_BLKS_TX_SHIFT) |\n\t\t\t    CPSW_MAX_BLKS_RX, CPSW1_MAX_BLKS);\n\t\tbreak;\n\tcase CPSW_VERSION_2:\n\tcase CPSW_VERSION_3:\n\tcase CPSW_VERSION_4:\n\t\tslave_write(slave, TX_PRIORITY_MAPPING, CPSW2_TX_PRI_MAP);\n\t\t \n\t\tslave_write(slave,\n\t\t\t    (CPSW_MAX_BLKS_TX << CPSW_MAX_BLKS_TX_SHIFT) |\n\t\t\t    CPSW_MAX_BLKS_RX, CPSW2_MAX_BLKS);\n\t\tbreak;\n\t}\n\n\t \n\tcpsw_sl_reg_write(slave->mac_sl, CPSW_SL_RX_MAXLEN,\n\t\t\t  cpsw->rx_packet_max);\n\tcpsw_set_slave_mac(slave, priv);\n\n\tslave->mac_control = 0;\t \n\n\tif (cpsw_is_switch_en(cpsw))\n\t\tcpsw_port_add_switch_def_ale_entries(priv, slave);\n\telse\n\t\tcpsw_port_add_dual_emac_def_ale_entries(priv, slave);\n\n\tif (!slave->data->phy_node)\n\t\tdev_err(priv->dev, \"no phy found on slave %d\\n\",\n\t\t\tslave->slave_num);\n\tphy = of_phy_connect(priv->ndev, slave->data->phy_node,\n\t\t\t     &cpsw_adjust_link, 0, slave->data->phy_if);\n\tif (!phy) {\n\t\tdev_err(priv->dev, \"phy \\\"%pOF\\\" not found on slave %d\\n\",\n\t\t\tslave->data->phy_node,\n\t\t\tslave->slave_num);\n\t\treturn;\n\t}\n\tslave->phy = phy;\n\n\tphy_attached_info(slave->phy);\n\n\tphy_start(slave->phy);\n\n\t \n\tphy_set_mode_ext(slave->data->ifphy, PHY_MODE_ETHERNET,\n\t\t\t slave->data->phy_if);\n}\n\nstatic int cpsw_ndo_stop(struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tstruct cpsw_slave *slave;\n\n\tcpsw_info(priv, ifdown, \"shutting down ndev\\n\");\n\tslave = &cpsw->slaves[priv->emac_port - 1];\n\tif (slave->phy)\n\t\tphy_stop(slave->phy);\n\n\tnetif_tx_stop_all_queues(priv->ndev);\n\n\tif (slave->phy) {\n\t\tphy_disconnect(slave->phy);\n\t\tslave->phy = NULL;\n\t}\n\n\t__hw_addr_ref_unsync_dev(&ndev->mc, ndev, cpsw_purge_all_mc);\n\n\tif (cpsw->usage_count <= 1) {\n\t\tnapi_disable(&cpsw->napi_rx);\n\t\tnapi_disable(&cpsw->napi_tx);\n\t\tcpts_unregister(cpsw->cpts);\n\t\tcpsw_intr_disable(cpsw);\n\t\tcpdma_ctlr_stop(cpsw->dma);\n\t\tcpsw_ale_stop(cpsw->ale);\n\t\tcpsw_destroy_xdp_rxqs(cpsw);\n\t}\n\n\tif (cpsw_need_resplit(cpsw))\n\t\tcpsw_split_res(cpsw);\n\n\tcpsw->usage_count--;\n\tpm_runtime_put_sync(cpsw->dev);\n\treturn 0;\n}\n\nstatic int cpsw_ndo_open(struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint ret;\n\n\tdev_info(priv->dev, \"starting ndev. mode: %s\\n\",\n\t\t cpsw_is_switch_en(cpsw) ? \"switch\" : \"dual_mac\");\n\tret = pm_runtime_resume_and_get(cpsw->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = netif_set_real_num_tx_queues(ndev, cpsw->tx_ch_num);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"cannot set real number of tx queues\\n\");\n\t\tgoto pm_cleanup;\n\t}\n\n\tret = netif_set_real_num_rx_queues(ndev, cpsw->rx_ch_num);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"cannot set real number of rx queues\\n\");\n\t\tgoto pm_cleanup;\n\t}\n\n\t \n\tif (!cpsw->usage_count)\n\t\tcpsw_init_host_port(priv);\n\tcpsw_slave_open(&cpsw->slaves[priv->emac_port - 1], priv);\n\n\t \n\tif (!cpsw->usage_count) {\n\t\t \n\t\tret = cpsw_create_xdp_rxqs(cpsw);\n\t\tif (ret < 0)\n\t\t\tgoto err_cleanup;\n\n\t\tret = cpsw_fill_rx_channels(priv);\n\t\tif (ret < 0)\n\t\t\tgoto err_cleanup;\n\n\t\tif (cpsw->cpts) {\n\t\t\tif (cpts_register(cpsw->cpts))\n\t\t\t\tdev_err(priv->dev, \"error registering cpts device\\n\");\n\t\t\telse\n\t\t\t\twritel(0x10, &cpsw->wr_regs->misc_en);\n\t\t}\n\n\t\tnapi_enable(&cpsw->napi_rx);\n\t\tnapi_enable(&cpsw->napi_tx);\n\n\t\tif (cpsw->tx_irq_disabled) {\n\t\t\tcpsw->tx_irq_disabled = false;\n\t\t\tenable_irq(cpsw->irqs_table[1]);\n\t\t}\n\n\t\tif (cpsw->rx_irq_disabled) {\n\t\t\tcpsw->rx_irq_disabled = false;\n\t\t\tenable_irq(cpsw->irqs_table[0]);\n\t\t}\n\t}\n\n\tcpsw_restore(priv);\n\n\t \n\tif (cpsw->coal_intvl != 0) {\n\t\tstruct ethtool_coalesce coal;\n\n\t\tcoal.rx_coalesce_usecs = cpsw->coal_intvl;\n\t\tcpsw_set_coalesce(ndev, &coal, NULL, NULL);\n\t}\n\n\tcpdma_ctlr_start(cpsw->dma);\n\tcpsw_intr_enable(cpsw);\n\tcpsw->usage_count++;\n\n\treturn 0;\n\nerr_cleanup:\n\tcpsw_ndo_stop(ndev);\n\npm_cleanup:\n\tpm_runtime_put_sync(cpsw->dev);\n\treturn ret;\n}\n\nstatic netdev_tx_t cpsw_ndo_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tstruct cpts *cpts = cpsw->cpts;\n\tstruct netdev_queue *txq;\n\tstruct cpdma_chan *txch;\n\tint ret, q_idx;\n\n\tif (skb_put_padto(skb, READ_ONCE(priv->tx_packet_min))) {\n\t\tcpsw_err(priv, tx_err, \"packet pad failed\\n\");\n\t\tndev->stats.tx_dropped++;\n\t\treturn NET_XMIT_DROP;\n\t}\n\n\tif (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP &&\n\t    priv->tx_ts_enabled && cpts_can_timestamp(cpts, skb))\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\n\tq_idx = skb_get_queue_mapping(skb);\n\tif (q_idx >= cpsw->tx_ch_num)\n\t\tq_idx = q_idx % cpsw->tx_ch_num;\n\n\ttxch = cpsw->txv[q_idx].ch;\n\ttxq = netdev_get_tx_queue(ndev, q_idx);\n\tskb_tx_timestamp(skb);\n\tret = cpdma_chan_submit(txch, skb, skb->data, skb->len,\n\t\t\t\tpriv->emac_port);\n\tif (unlikely(ret != 0)) {\n\t\tcpsw_err(priv, tx_err, \"desc submit failed\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tif (unlikely(!cpdma_check_free_tx_desc(txch))) {\n\t\tnetif_tx_stop_queue(txq);\n\n\t\t \n\t\tsmp_mb__after_atomic();\n\n\t\tif (cpdma_check_free_tx_desc(txch))\n\t\t\tnetif_tx_wake_queue(txq);\n\t}\n\n\treturn NETDEV_TX_OK;\nfail:\n\tndev->stats.tx_dropped++;\n\tnetif_tx_stop_queue(txq);\n\n\t \n\tsmp_mb__after_atomic();\n\n\tif (cpdma_check_free_tx_desc(txch))\n\t\tnetif_tx_wake_queue(txq);\n\n\treturn NETDEV_TX_BUSY;\n}\n\nstatic int cpsw_ndo_set_mac_address(struct net_device *ndev, void *p)\n{\n\tstruct sockaddr *addr = (struct sockaddr *)p;\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint ret, slave_no;\n\tint flags = 0;\n\tu16 vid = 0;\n\n\tslave_no = cpsw_slave_index(cpsw, priv);\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tret = pm_runtime_resume_and_get(cpsw->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvid = cpsw->slaves[slave_no].port_vlan;\n\tflags = ALE_VLAN | ALE_SECURE;\n\n\tcpsw_ale_del_ucast(cpsw->ale, priv->mac_addr, HOST_PORT_NUM,\n\t\t\t   flags, vid);\n\tcpsw_ale_add_ucast(cpsw->ale, addr->sa_data, HOST_PORT_NUM,\n\t\t\t   flags, vid);\n\n\tether_addr_copy(priv->mac_addr, addr->sa_data);\n\teth_hw_addr_set(ndev, priv->mac_addr);\n\tcpsw_set_slave_mac(&cpsw->slaves[slave_no], priv);\n\n\tpm_runtime_put(cpsw->dev);\n\n\treturn 0;\n}\n\nstatic int cpsw_ndo_vlan_rx_kill_vid(struct net_device *ndev,\n\t\t\t\t     __be16 proto, u16 vid)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint ret;\n\tint i;\n\n\tif (cpsw_is_switch_en(cpsw)) {\n\t\tdev_dbg(cpsw->dev, \"ndo del vlan is called in switch mode\\n\");\n\t\treturn 0;\n\t}\n\n\tif (vid == cpsw->data.default_vlan)\n\t\treturn 0;\n\n\tret = pm_runtime_resume_and_get(cpsw->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = 0;\n\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\tif (cpsw->slaves[i].ndev &&\n\t\t    vid == cpsw->slaves[i].port_vlan) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tdev_dbg(priv->dev, \"removing vlanid %d from vlan filter\\n\", vid);\n\tret = cpsw_ale_del_vlan(cpsw->ale, vid, 0);\n\tif (ret)\n\t\tdev_err(priv->dev, \"cpsw_ale_del_vlan() failed: ret %d\\n\", ret);\n\tret = cpsw_ale_del_ucast(cpsw->ale, priv->mac_addr,\n\t\t\t\t HOST_PORT_NUM, ALE_VLAN, vid);\n\tif (ret)\n\t\tdev_err(priv->dev, \"cpsw_ale_del_ucast() failed: ret %d\\n\",\n\t\t\tret);\n\tret = cpsw_ale_del_mcast(cpsw->ale, priv->ndev->broadcast,\n\t\t\t\t 0, ALE_VLAN, vid);\n\tif (ret)\n\t\tdev_err(priv->dev, \"cpsw_ale_del_mcast failed. ret %d\\n\",\n\t\t\tret);\n\tcpsw_ale_flush_multicast(cpsw->ale, ALE_PORT_HOST, vid);\n\tret = 0;\nerr:\n\tpm_runtime_put(cpsw->dev);\n\treturn ret;\n}\n\nstatic int cpsw_ndo_get_phys_port_name(struct net_device *ndev, char *name,\n\t\t\t\t       size_t len)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tint err;\n\n\terr = snprintf(name, len, \"p%d\", priv->emac_port);\n\n\tif (err >= len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void cpsw_ndo_poll_controller(struct net_device *ndev)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\n\tcpsw_intr_disable(cpsw);\n\tcpsw_rx_interrupt(cpsw->irqs_table[0], cpsw);\n\tcpsw_tx_interrupt(cpsw->irqs_table[1], cpsw);\n\tcpsw_intr_enable(cpsw);\n}\n#endif\n\nstatic int cpsw_ndo_xdp_xmit(struct net_device *ndev, int n,\n\t\t\t     struct xdp_frame **frames, u32 flags)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct xdp_frame *xdpf;\n\tint i, nxmit = 0;\n\n\tif (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < n; i++) {\n\t\txdpf = frames[i];\n\t\tif (xdpf->len < READ_ONCE(priv->tx_packet_min))\n\t\t\tbreak;\n\n\t\tif (cpsw_xdp_tx_frame(priv, xdpf, NULL, priv->emac_port))\n\t\t\tbreak;\n\t\tnxmit++;\n\t}\n\n\treturn nxmit;\n}\n\nstatic int cpsw_get_port_parent_id(struct net_device *ndev,\n\t\t\t\t   struct netdev_phys_item_id *ppid)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\n\tppid->id_len = sizeof(cpsw->base_mac);\n\tmemcpy(&ppid->id, &cpsw->base_mac, ppid->id_len);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops cpsw_netdev_ops = {\n\t.ndo_open\t\t= cpsw_ndo_open,\n\t.ndo_stop\t\t= cpsw_ndo_stop,\n\t.ndo_start_xmit\t\t= cpsw_ndo_start_xmit,\n\t.ndo_set_mac_address\t= cpsw_ndo_set_mac_address,\n\t.ndo_eth_ioctl\t\t= cpsw_ndo_ioctl,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_tx_timeout\t\t= cpsw_ndo_tx_timeout,\n\t.ndo_set_rx_mode\t= cpsw_ndo_set_rx_mode,\n\t.ndo_set_tx_maxrate\t= cpsw_ndo_set_tx_maxrate,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= cpsw_ndo_poll_controller,\n#endif\n\t.ndo_vlan_rx_add_vid\t= cpsw_ndo_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= cpsw_ndo_vlan_rx_kill_vid,\n\t.ndo_setup_tc           = cpsw_ndo_setup_tc,\n\t.ndo_get_phys_port_name = cpsw_ndo_get_phys_port_name,\n\t.ndo_bpf\t\t= cpsw_ndo_bpf,\n\t.ndo_xdp_xmit\t\t= cpsw_ndo_xdp_xmit,\n\t.ndo_get_port_parent_id\t= cpsw_get_port_parent_id,\n};\n\nstatic void cpsw_get_drvinfo(struct net_device *ndev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\tstruct platform_device *pdev;\n\n\tpdev = to_platform_device(cpsw->dev);\n\tstrscpy(info->driver, \"cpsw-switch\", sizeof(info->driver));\n\tstrscpy(info->version, \"2.0\", sizeof(info->version));\n\tstrscpy(info->bus_info, pdev->name, sizeof(info->bus_info));\n}\n\nstatic int cpsw_set_pauseparam(struct net_device *ndev,\n\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tint slave_no;\n\n\tslave_no = cpsw_slave_index(cpsw, priv);\n\tif (!cpsw->slaves[slave_no].phy)\n\t\treturn -EINVAL;\n\n\tif (!phy_validate_pause(cpsw->slaves[slave_no].phy, pause))\n\t\treturn -EINVAL;\n\n\tpriv->rx_pause = pause->rx_pause ? true : false;\n\tpriv->tx_pause = pause->tx_pause ? true : false;\n\n\tphy_set_asym_pause(cpsw->slaves[slave_no].phy,\n\t\t\t   priv->rx_pause, priv->tx_pause);\n\n\treturn 0;\n}\n\nstatic int cpsw_set_channels(struct net_device *ndev,\n\t\t\t     struct ethtool_channels *chs)\n{\n\treturn cpsw_set_channels_common(ndev, chs, cpsw_rx_handler);\n}\n\nstatic const struct ethtool_ops cpsw_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS,\n\t.get_drvinfo\t\t= cpsw_get_drvinfo,\n\t.get_msglevel\t\t= cpsw_get_msglevel,\n\t.set_msglevel\t\t= cpsw_set_msglevel,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_ts_info\t\t= cpsw_get_ts_info,\n\t.get_coalesce\t\t= cpsw_get_coalesce,\n\t.set_coalesce\t\t= cpsw_set_coalesce,\n\t.get_sset_count\t\t= cpsw_get_sset_count,\n\t.get_strings\t\t= cpsw_get_strings,\n\t.get_ethtool_stats\t= cpsw_get_ethtool_stats,\n\t.get_pauseparam\t\t= cpsw_get_pauseparam,\n\t.set_pauseparam\t\t= cpsw_set_pauseparam,\n\t.get_wol\t\t= cpsw_get_wol,\n\t.set_wol\t\t= cpsw_set_wol,\n\t.get_regs_len\t\t= cpsw_get_regs_len,\n\t.get_regs\t\t= cpsw_get_regs,\n\t.begin\t\t\t= cpsw_ethtool_op_begin,\n\t.complete\t\t= cpsw_ethtool_op_complete,\n\t.get_channels\t\t= cpsw_get_channels,\n\t.set_channels\t\t= cpsw_set_channels,\n\t.get_link_ksettings\t= cpsw_get_link_ksettings,\n\t.set_link_ksettings\t= cpsw_set_link_ksettings,\n\t.get_eee\t\t= cpsw_get_eee,\n\t.set_eee\t\t= cpsw_set_eee,\n\t.nway_reset\t\t= cpsw_nway_reset,\n\t.get_ringparam\t\t= cpsw_get_ringparam,\n\t.set_ringparam\t\t= cpsw_set_ringparam,\n};\n\nstatic int cpsw_probe_dt(struct cpsw_common *cpsw)\n{\n\tstruct device_node *node = cpsw->dev->of_node, *tmp_node, *port_np;\n\tstruct cpsw_platform_data *data = &cpsw->data;\n\tstruct device *dev = cpsw->dev;\n\tint ret;\n\tu32 prop;\n\n\tif (!node)\n\t\treturn -EINVAL;\n\n\ttmp_node = of_get_child_by_name(node, \"ethernet-ports\");\n\tif (!tmp_node)\n\t\treturn -ENOENT;\n\tdata->slaves = of_get_child_count(tmp_node);\n\tif (data->slaves != CPSW_SLAVE_PORTS_NUM) {\n\t\tof_node_put(tmp_node);\n\t\treturn -ENOENT;\n\t}\n\n\tdata->active_slave = 0;\n\tdata->channels = CPSW_MAX_QUEUES;\n\tdata->dual_emac = true;\n\tdata->bd_ram_size = CPSW_BD_RAM_SIZE;\n\tdata->mac_control = 0;\n\n\tdata->slave_data = devm_kcalloc(dev, CPSW_SLAVE_PORTS_NUM,\n\t\t\t\t\tsizeof(struct cpsw_slave_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!data->slave_data) {\n\t\tof_node_put(tmp_node);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = devm_of_platform_populate(dev);\n\t \n\tif (ret)\n\t\tdev_warn(dev, \"Doesn't have any child node\\n\");\n\n\tfor_each_child_of_node(tmp_node, port_np) {\n\t\tstruct cpsw_slave_data *slave_data;\n\t\tu32 port_id;\n\n\t\tret = of_property_read_u32(port_np, \"reg\", &port_id);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%pOF error reading port_id %d\\n\",\n\t\t\t\tport_np, ret);\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tif (!port_id || port_id > CPSW_SLAVE_PORTS_NUM) {\n\t\t\tdev_err(dev, \"%pOF has invalid port_id %u\\n\",\n\t\t\t\tport_np, port_id);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tslave_data = &data->slave_data[port_id - 1];\n\n\t\tslave_data->disabled = !of_device_is_available(port_np);\n\t\tif (slave_data->disabled)\n\t\t\tcontinue;\n\n\t\tslave_data->slave_node = port_np;\n\t\tslave_data->ifphy = devm_of_phy_get(dev, port_np, NULL);\n\t\tif (IS_ERR(slave_data->ifphy)) {\n\t\t\tret = PTR_ERR(slave_data->ifphy);\n\t\t\tdev_err(dev, \"%pOF: Error retrieving port phy: %d\\n\",\n\t\t\t\tport_np, ret);\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tif (of_phy_is_fixed_link(port_np)) {\n\t\t\tret = of_phy_register_fixed_link(port_np);\n\t\t\tif (ret) {\n\t\t\t\tdev_err_probe(dev, ret, \"%pOF failed to register fixed-link phy\\n\",\n\t\t\t\t\t      port_np);\n\t\t\t\tgoto err_node_put;\n\t\t\t}\n\t\t\tslave_data->phy_node = of_node_get(port_np);\n\t\t} else {\n\t\t\tslave_data->phy_node =\n\t\t\t\tof_parse_phandle(port_np, \"phy-handle\", 0);\n\t\t}\n\n\t\tif (!slave_data->phy_node) {\n\t\t\tdev_err(dev, \"%pOF no phy found\\n\", port_np);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tret = of_get_phy_mode(port_np, &slave_data->phy_if);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%pOF read phy-mode err %d\\n\",\n\t\t\t\tport_np, ret);\n\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tret = of_get_mac_address(port_np, slave_data->mac_addr);\n\t\tif (ret) {\n\t\t\tret = ti_cm_get_macid(dev, port_id - 1,\n\t\t\t\t\t      slave_data->mac_addr);\n\t\t\tif (ret)\n\t\t\t\tgoto err_node_put;\n\t\t}\n\n\t\tif (of_property_read_u32(port_np, \"ti,dual-emac-pvid\",\n\t\t\t\t\t &prop)) {\n\t\t\tdev_err(dev, \"%pOF Missing dual_emac_res_vlan in DT.\\n\",\n\t\t\t\tport_np);\n\t\t\tslave_data->dual_emac_res_vlan = port_id;\n\t\t\tdev_err(dev, \"%pOF Using %d as Reserved VLAN\\n\",\n\t\t\t\tport_np, slave_data->dual_emac_res_vlan);\n\t\t} else {\n\t\t\tslave_data->dual_emac_res_vlan = prop;\n\t\t}\n\t}\n\n\tof_node_put(tmp_node);\n\treturn 0;\n\nerr_node_put:\n\tof_node_put(port_np);\n\tof_node_put(tmp_node);\n\treturn ret;\n}\n\nstatic void cpsw_remove_dt(struct cpsw_common *cpsw)\n{\n\tstruct cpsw_platform_data *data = &cpsw->data;\n\tint i = 0;\n\n\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\tstruct cpsw_slave_data *slave_data = &data->slave_data[i];\n\t\tstruct device_node *port_np = slave_data->phy_node;\n\n\t\tif (port_np) {\n\t\t\tif (of_phy_is_fixed_link(port_np))\n\t\t\t\tof_phy_deregister_fixed_link(port_np);\n\n\t\t\tof_node_put(port_np);\n\t\t}\n\t}\n}\n\nstatic int cpsw_create_ports(struct cpsw_common *cpsw)\n{\n\tstruct cpsw_platform_data *data = &cpsw->data;\n\tstruct net_device *ndev, *napi_ndev = NULL;\n\tstruct device *dev = cpsw->dev;\n\tstruct cpsw_priv *priv;\n\tint ret = 0, i = 0;\n\n\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\tstruct cpsw_slave_data *slave_data = &data->slave_data[i];\n\n\t\tif (slave_data->disabled)\n\t\t\tcontinue;\n\n\t\tndev = devm_alloc_etherdev_mqs(dev, sizeof(struct cpsw_priv),\n\t\t\t\t\t       CPSW_MAX_QUEUES,\n\t\t\t\t\t       CPSW_MAX_QUEUES);\n\t\tif (!ndev) {\n\t\t\tdev_err(dev, \"error allocating net_device\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpriv = netdev_priv(ndev);\n\t\tpriv->cpsw = cpsw;\n\t\tpriv->ndev = ndev;\n\t\tpriv->dev  = dev;\n\t\tpriv->msg_enable = netif_msg_init(debug_level, CPSW_DEBUG);\n\t\tpriv->emac_port = i + 1;\n\t\tpriv->tx_packet_min = CPSW_MIN_PACKET_SIZE;\n\n\t\tif (is_valid_ether_addr(slave_data->mac_addr)) {\n\t\t\tether_addr_copy(priv->mac_addr, slave_data->mac_addr);\n\t\t\tdev_info(cpsw->dev, \"Detected MACID = %pM\\n\",\n\t\t\t\t priv->mac_addr);\n\t\t} else {\n\t\t\teth_random_addr(slave_data->mac_addr);\n\t\t\tdev_info(cpsw->dev, \"Random MACID = %pM\\n\",\n\t\t\t\t priv->mac_addr);\n\t\t}\n\t\teth_hw_addr_set(ndev, slave_data->mac_addr);\n\t\tether_addr_copy(priv->mac_addr, slave_data->mac_addr);\n\n\t\tcpsw->slaves[i].ndev = ndev;\n\n\t\tndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER |\n\t\t\t\t  NETIF_F_HW_VLAN_CTAG_RX | NETIF_F_NETNS_LOCAL | NETIF_F_HW_TC;\n\n\t\tndev->xdp_features = NETDEV_XDP_ACT_BASIC |\n\t\t\t\t     NETDEV_XDP_ACT_REDIRECT |\n\t\t\t\t     NETDEV_XDP_ACT_NDO_XMIT;\n\n\t\tndev->netdev_ops = &cpsw_netdev_ops;\n\t\tndev->ethtool_ops = &cpsw_ethtool_ops;\n\t\tSET_NETDEV_DEV(ndev, dev);\n\n\t\tif (!napi_ndev) {\n\t\t\t \n\t\t\tnetif_napi_add(ndev, &cpsw->napi_rx,\n\t\t\t\t       cpsw->quirk_irq ? cpsw_rx_poll : cpsw_rx_mq_poll);\n\t\t\tnetif_napi_add_tx(ndev, &cpsw->napi_tx,\n\t\t\t\t\t  cpsw->quirk_irq ?\n\t\t\t\t\t  cpsw_tx_poll : cpsw_tx_mq_poll);\n\t\t}\n\n\t\tnapi_ndev = ndev;\n\t}\n\n\treturn ret;\n}\n\nstatic void cpsw_unregister_ports(struct cpsw_common *cpsw)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\tif (!cpsw->slaves[i].ndev)\n\t\t\tcontinue;\n\n\t\tunregister_netdev(cpsw->slaves[i].ndev);\n\t}\n}\n\nstatic int cpsw_register_ports(struct cpsw_common *cpsw)\n{\n\tint ret = 0, i = 0;\n\n\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\tif (!cpsw->slaves[i].ndev)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = register_netdev(cpsw->slaves[i].ndev);\n\t\tif (ret) {\n\t\t\tdev_err(cpsw->dev,\n\t\t\t\t\"cpsw: err registering net device%d\\n\", i);\n\t\t\tcpsw->slaves[i].ndev = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\tcpsw_unregister_ports(cpsw);\n\treturn ret;\n}\n\nbool cpsw_port_dev_check(const struct net_device *ndev)\n{\n\tif (ndev->netdev_ops == &cpsw_netdev_ops) {\n\t\tstruct cpsw_common *cpsw = ndev_to_cpsw(ndev);\n\n\t\treturn !cpsw->data.dual_emac;\n\t}\n\n\treturn false;\n}\n\nstatic void cpsw_port_offload_fwd_mark_update(struct cpsw_common *cpsw)\n{\n\tint set_val = 0;\n\tint i;\n\n\tif (!cpsw->ale_bypass &&\n\t    (cpsw->br_members == (ALE_PORT_1 | ALE_PORT_2)))\n\t\tset_val = 1;\n\n\tdev_dbg(cpsw->dev, \"set offload_fwd_mark %d\\n\", set_val);\n\n\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\tstruct net_device *sl_ndev = cpsw->slaves[i].ndev;\n\t\tstruct cpsw_priv *priv = netdev_priv(sl_ndev);\n\n\t\tpriv->offload_fwd_mark = set_val;\n\t}\n}\n\nstatic int cpsw_netdevice_port_link(struct net_device *ndev,\n\t\t\t\t    struct net_device *br_ndev,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\tint err;\n\n\tif (!cpsw->br_members) {\n\t\tcpsw->hw_bridge_dev = br_ndev;\n\t} else {\n\t\t \n\t\tif (cpsw->hw_bridge_dev != br_ndev)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = switchdev_bridge_port_offload(ndev, ndev, NULL, NULL, NULL,\n\t\t\t\t\t    false, extack);\n\tif (err)\n\t\treturn err;\n\n\tcpsw->br_members |= BIT(priv->emac_port);\n\n\tcpsw_port_offload_fwd_mark_update(cpsw);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void cpsw_netdevice_port_unlink(struct net_device *ndev)\n{\n\tstruct cpsw_priv *priv = netdev_priv(ndev);\n\tstruct cpsw_common *cpsw = priv->cpsw;\n\n\tswitchdev_bridge_port_unoffload(ndev, NULL, NULL, NULL);\n\n\tcpsw->br_members &= ~BIT(priv->emac_port);\n\n\tcpsw_port_offload_fwd_mark_update(cpsw);\n\n\tif (!cpsw->br_members)\n\t\tcpsw->hw_bridge_dev = NULL;\n}\n\n \nstatic int cpsw_netdevice_event(struct notifier_block *unused,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct netlink_ext_ack *extack = netdev_notifier_info_to_extack(ptr);\n\tstruct net_device *ndev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_notifier_changeupper_info *info;\n\tint ret = NOTIFY_DONE;\n\n\tif (!cpsw_port_dev_check(ndev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGEUPPER:\n\t\tinfo = ptr;\n\n\t\tif (netif_is_bridge_master(info->upper_dev)) {\n\t\t\tif (info->linking)\n\t\t\t\tret = cpsw_netdevice_port_link(ndev,\n\t\t\t\t\t\t\t       info->upper_dev,\n\t\t\t\t\t\t\t       extack);\n\t\t\telse\n\t\t\t\tcpsw_netdevice_port_unlink(ndev);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn notifier_from_errno(ret);\n}\n\nstatic struct notifier_block cpsw_netdevice_nb __read_mostly = {\n\t.notifier_call = cpsw_netdevice_event,\n};\n\nstatic int cpsw_register_notifiers(struct cpsw_common *cpsw)\n{\n\tint ret = 0;\n\n\tret = register_netdevice_notifier(&cpsw_netdevice_nb);\n\tif (ret) {\n\t\tdev_err(cpsw->dev, \"can't register netdevice notifier\\n\");\n\t\treturn ret;\n\t}\n\n\tret = cpsw_switchdev_register_notifiers(cpsw);\n\tif (ret)\n\t\tunregister_netdevice_notifier(&cpsw_netdevice_nb);\n\n\treturn ret;\n}\n\nstatic void cpsw_unregister_notifiers(struct cpsw_common *cpsw)\n{\n\tcpsw_switchdev_unregister_notifiers(cpsw);\n\tunregister_netdevice_notifier(&cpsw_netdevice_nb);\n}\n\nstatic const struct devlink_ops cpsw_devlink_ops = {\n};\n\nstatic int cpsw_dl_switch_mode_get(struct devlink *dl, u32 id,\n\t\t\t\t   struct devlink_param_gset_ctx *ctx)\n{\n\tstruct cpsw_devlink *dl_priv = devlink_priv(dl);\n\tstruct cpsw_common *cpsw = dl_priv->cpsw;\n\n\tdev_dbg(cpsw->dev, \"%s id:%u\\n\", __func__, id);\n\n\tif (id != CPSW_DL_PARAM_SWITCH_MODE)\n\t\treturn  -EOPNOTSUPP;\n\n\tctx->val.vbool = !cpsw->data.dual_emac;\n\n\treturn 0;\n}\n\nstatic int cpsw_dl_switch_mode_set(struct devlink *dl, u32 id,\n\t\t\t\t   struct devlink_param_gset_ctx *ctx)\n{\n\tstruct cpsw_devlink *dl_priv = devlink_priv(dl);\n\tstruct cpsw_common *cpsw = dl_priv->cpsw;\n\tint vlan = cpsw->data.default_vlan;\n\tbool switch_en = ctx->val.vbool;\n\tbool if_running = false;\n\tint i;\n\n\tdev_dbg(cpsw->dev, \"%s id:%u\\n\", __func__, id);\n\n\tif (id != CPSW_DL_PARAM_SWITCH_MODE)\n\t\treturn  -EOPNOTSUPP;\n\n\tif (switch_en == !cpsw->data.dual_emac)\n\t\treturn 0;\n\n\tif (!switch_en && cpsw->br_members) {\n\t\tdev_err(cpsw->dev, \"Remove ports from BR before disabling switch mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trtnl_lock();\n\n\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\tstruct cpsw_slave *slave = &cpsw->slaves[i];\n\t\tstruct net_device *sl_ndev = slave->ndev;\n\n\t\tif (!sl_ndev || !netif_running(sl_ndev))\n\t\t\tcontinue;\n\n\t\tif_running = true;\n\t}\n\n\tif (!if_running) {\n\t\t \n\t\tcpsw->data.dual_emac = !switch_en;\n\t\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\t\tstruct cpsw_slave *slave = &cpsw->slaves[i];\n\t\t\tstruct net_device *sl_ndev = slave->ndev;\n\n\t\t\tif (!sl_ndev)\n\t\t\t\tcontinue;\n\n\t\t\tif (switch_en)\n\t\t\t\tvlan = cpsw->data.default_vlan;\n\t\t\telse\n\t\t\t\tvlan = slave->data->dual_emac_res_vlan;\n\t\t\tslave->port_vlan = vlan;\n\t\t}\n\t\tgoto exit;\n\t}\n\n\tif (switch_en) {\n\t\tdev_info(cpsw->dev, \"Enable switch mode\\n\");\n\n\t\t \n\t\tcpsw_ale_control_set(cpsw->ale, 0, ALE_BYPASS, 1);\n\n\t\t \n\t\tcpsw_ale_control_set(cpsw->ale, 0, ALE_CLEAR, 1);\n\t\tcpsw_ale_control_get(cpsw->ale, 0, ALE_AGEOUT);\n\n\t\tcpsw_init_host_port_switch(cpsw);\n\n\t\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\t\tstruct cpsw_slave *slave = &cpsw->slaves[i];\n\t\t\tstruct net_device *sl_ndev = slave->ndev;\n\t\t\tstruct cpsw_priv *priv;\n\n\t\t\tif (!sl_ndev)\n\t\t\t\tcontinue;\n\n\t\t\tpriv = netdev_priv(sl_ndev);\n\t\t\tslave->port_vlan = vlan;\n\t\t\tWRITE_ONCE(priv->tx_packet_min, CPSW_MIN_PACKET_SIZE_VLAN);\n\t\t\tif (netif_running(sl_ndev))\n\t\t\t\tcpsw_port_add_switch_def_ale_entries(priv,\n\t\t\t\t\t\t\t\t     slave);\n\t\t}\n\n\t\tcpsw_ale_control_set(cpsw->ale, 0, ALE_BYPASS, 0);\n\t\tcpsw->data.dual_emac = false;\n\t} else {\n\t\tdev_info(cpsw->dev, \"Disable switch mode\\n\");\n\n\t\t \n\t\tcpsw_ale_control_set(cpsw->ale, 0, ALE_BYPASS, 1);\n\n\t\tcpsw_ale_control_set(cpsw->ale, 0, ALE_CLEAR, 1);\n\t\tcpsw_ale_control_get(cpsw->ale, 0, ALE_AGEOUT);\n\n\t\tcpsw_init_host_port_dual_mac(cpsw);\n\n\t\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\t\tstruct cpsw_slave *slave = &cpsw->slaves[i];\n\t\t\tstruct net_device *sl_ndev = slave->ndev;\n\t\t\tstruct cpsw_priv *priv;\n\n\t\t\tif (!sl_ndev)\n\t\t\t\tcontinue;\n\n\t\t\tpriv = netdev_priv(slave->ndev);\n\t\t\tslave->port_vlan = slave->data->dual_emac_res_vlan;\n\t\t\tWRITE_ONCE(priv->tx_packet_min, CPSW_MIN_PACKET_SIZE);\n\t\t\tcpsw_port_add_dual_emac_def_ale_entries(priv, slave);\n\t\t}\n\n\t\tcpsw_ale_control_set(cpsw->ale, 0, ALE_BYPASS, 0);\n\t\tcpsw->data.dual_emac = true;\n\t}\nexit:\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic int cpsw_dl_ale_ctrl_get(struct devlink *dl, u32 id,\n\t\t\t\tstruct devlink_param_gset_ctx *ctx)\n{\n\tstruct cpsw_devlink *dl_priv = devlink_priv(dl);\n\tstruct cpsw_common *cpsw = dl_priv->cpsw;\n\n\tdev_dbg(cpsw->dev, \"%s id:%u\\n\", __func__, id);\n\n\tswitch (id) {\n\tcase CPSW_DL_PARAM_ALE_BYPASS:\n\t\tctx->val.vbool = cpsw_ale_control_get(cpsw->ale, 0, ALE_BYPASS);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpsw_dl_ale_ctrl_set(struct devlink *dl, u32 id,\n\t\t\t\tstruct devlink_param_gset_ctx *ctx)\n{\n\tstruct cpsw_devlink *dl_priv = devlink_priv(dl);\n\tstruct cpsw_common *cpsw = dl_priv->cpsw;\n\tint ret = -EOPNOTSUPP;\n\n\tdev_dbg(cpsw->dev, \"%s id:%u\\n\", __func__, id);\n\n\tswitch (id) {\n\tcase CPSW_DL_PARAM_ALE_BYPASS:\n\t\tret = cpsw_ale_control_set(cpsw->ale, 0, ALE_BYPASS,\n\t\t\t\t\t   ctx->val.vbool);\n\t\tif (!ret) {\n\t\t\tcpsw->ale_bypass = ctx->val.vbool;\n\t\t\tcpsw_port_offload_fwd_mark_update(cpsw);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct devlink_param cpsw_devlink_params[] = {\n\tDEVLINK_PARAM_DRIVER(CPSW_DL_PARAM_SWITCH_MODE,\n\t\t\t     \"switch_mode\", DEVLINK_PARAM_TYPE_BOOL,\n\t\t\t     BIT(DEVLINK_PARAM_CMODE_RUNTIME),\n\t\t\t     cpsw_dl_switch_mode_get, cpsw_dl_switch_mode_set,\n\t\t\t     NULL),\n\tDEVLINK_PARAM_DRIVER(CPSW_DL_PARAM_ALE_BYPASS,\n\t\t\t     \"ale_bypass\", DEVLINK_PARAM_TYPE_BOOL,\n\t\t\t     BIT(DEVLINK_PARAM_CMODE_RUNTIME),\n\t\t\t     cpsw_dl_ale_ctrl_get, cpsw_dl_ale_ctrl_set, NULL),\n};\n\nstatic int cpsw_register_devlink(struct cpsw_common *cpsw)\n{\n\tstruct device *dev = cpsw->dev;\n\tstruct cpsw_devlink *dl_priv;\n\tint ret = 0;\n\n\tcpsw->devlink = devlink_alloc(&cpsw_devlink_ops, sizeof(*dl_priv), dev);\n\tif (!cpsw->devlink)\n\t\treturn -ENOMEM;\n\n\tdl_priv = devlink_priv(cpsw->devlink);\n\tdl_priv->cpsw = cpsw;\n\n\tret = devlink_params_register(cpsw->devlink, cpsw_devlink_params,\n\t\t\t\t      ARRAY_SIZE(cpsw_devlink_params));\n\tif (ret) {\n\t\tdev_err(dev, \"DL params reg fail ret:%d\\n\", ret);\n\t\tgoto dl_unreg;\n\t}\n\n\tdevlink_register(cpsw->devlink);\n\treturn ret;\n\ndl_unreg:\n\tdevlink_free(cpsw->devlink);\n\treturn ret;\n}\n\nstatic void cpsw_unregister_devlink(struct cpsw_common *cpsw)\n{\n\tdevlink_unregister(cpsw->devlink);\n\tdevlink_params_unregister(cpsw->devlink, cpsw_devlink_params,\n\t\t\t\t  ARRAY_SIZE(cpsw_devlink_params));\n\tdevlink_free(cpsw->devlink);\n}\n\nstatic const struct of_device_id cpsw_of_mtable[] = {\n\t{ .compatible = \"ti,cpsw-switch\"},\n\t{ .compatible = \"ti,am335x-cpsw-switch\"},\n\t{ .compatible = \"ti,am4372-cpsw-switch\"},\n\t{ .compatible = \"ti,dra7-cpsw-switch\"},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, cpsw_of_mtable);\n\nstatic const struct soc_device_attribute cpsw_soc_devices[] = {\n\t{ .family = \"AM33xx\", .revision = \"ES1.0\"},\n\t{   }\n};\n\nstatic int cpsw_probe(struct platform_device *pdev)\n{\n\tconst struct soc_device_attribute *soc;\n\tstruct device *dev = &pdev->dev;\n\tstruct cpsw_common *cpsw;\n\tstruct resource *ss_res;\n\tstruct gpio_descs *mode;\n\tvoid __iomem *ss_regs;\n\tint ret = 0, ch;\n\tstruct clk *clk;\n\tint irq;\n\n\tcpsw = devm_kzalloc(dev, sizeof(struct cpsw_common), GFP_KERNEL);\n\tif (!cpsw)\n\t\treturn -ENOMEM;\n\n\tcpsw_slave_index = cpsw_slave_index_priv;\n\n\tcpsw->dev = dev;\n\n\tcpsw->slaves = devm_kcalloc(dev,\n\t\t\t\t    CPSW_SLAVE_PORTS_NUM,\n\t\t\t\t    sizeof(struct cpsw_slave),\n\t\t\t\t    GFP_KERNEL);\n\tif (!cpsw->slaves)\n\t\treturn -ENOMEM;\n\n\tmode = devm_gpiod_get_array_optional(dev, \"mode\", GPIOD_OUT_LOW);\n\tif (IS_ERR(mode)) {\n\t\tret = PTR_ERR(mode);\n\t\tdev_err(dev, \"gpio request failed, ret %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tclk = devm_clk_get(dev, \"fck\");\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tdev_err(dev, \"fck is not found %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tcpsw->bus_freq_mhz = clk_get_rate(clk) / 1000000;\n\n\tss_regs = devm_platform_get_and_ioremap_resource(pdev, 0, &ss_res);\n\tif (IS_ERR(ss_regs)) {\n\t\tret = PTR_ERR(ss_regs);\n\t\treturn ret;\n\t}\n\tcpsw->regs = ss_regs;\n\n\tirq = platform_get_irq_byname(pdev, \"rx\");\n\tif (irq < 0)\n\t\treturn irq;\n\tcpsw->irqs_table[0] = irq;\n\n\tirq = platform_get_irq_byname(pdev, \"tx\");\n\tif (irq < 0)\n\t\treturn irq;\n\tcpsw->irqs_table[1] = irq;\n\n\tirq = platform_get_irq_byname(pdev, \"misc\");\n\tif (irq <= 0)\n\t\treturn irq;\n\tcpsw->misc_irq = irq;\n\n\tplatform_set_drvdata(pdev, cpsw);\n\t \n\tpm_runtime_enable(dev);\n\n\t \n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tpm_runtime_disable(dev);\n\t\treturn ret;\n\t}\n\n\tret = cpsw_probe_dt(cpsw);\n\tif (ret)\n\t\tgoto clean_dt_ret;\n\n\tsoc = soc_device_match(cpsw_soc_devices);\n\tif (soc)\n\t\tcpsw->quirk_irq = true;\n\n\tcpsw->rx_packet_max = rx_packet_max;\n\tcpsw->descs_pool_size = descs_pool_size;\n\teth_random_addr(cpsw->base_mac);\n\n\tret = cpsw_init_common(cpsw, ss_regs, ale_ageout,\n\t\t\t       (u32 __force)ss_res->start + CPSW2_BD_OFFSET,\n\t\t\t       descs_pool_size);\n\tif (ret)\n\t\tgoto clean_dt_ret;\n\n\tcpsw->wr_regs = cpsw->version == CPSW_VERSION_1 ?\n\t\t\tss_regs + CPSW1_WR_OFFSET :\n\t\t\tss_regs + CPSW2_WR_OFFSET;\n\n\tch = cpsw->quirk_irq ? 0 : 7;\n\tcpsw->txv[0].ch = cpdma_chan_create(cpsw->dma, ch, cpsw_tx_handler, 0);\n\tif (IS_ERR(cpsw->txv[0].ch)) {\n\t\tdev_err(dev, \"error initializing tx dma channel\\n\");\n\t\tret = PTR_ERR(cpsw->txv[0].ch);\n\t\tgoto clean_cpts;\n\t}\n\n\tcpsw->rxv[0].ch = cpdma_chan_create(cpsw->dma, 0, cpsw_rx_handler, 1);\n\tif (IS_ERR(cpsw->rxv[0].ch)) {\n\t\tdev_err(dev, \"error initializing rx dma channel\\n\");\n\t\tret = PTR_ERR(cpsw->rxv[0].ch);\n\t\tgoto clean_cpts;\n\t}\n\tcpsw_split_res(cpsw);\n\n\t \n\tret = cpsw_create_ports(cpsw);\n\tif (ret)\n\t\tgoto clean_unregister_netdev;\n\n\t \n\n\tret = devm_request_irq(dev, cpsw->irqs_table[0], cpsw_rx_interrupt,\n\t\t\t       0, dev_name(dev), cpsw);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error attaching irq (%d)\\n\", ret);\n\t\tgoto clean_unregister_netdev;\n\t}\n\n\tret = devm_request_irq(dev, cpsw->irqs_table[1], cpsw_tx_interrupt,\n\t\t\t       0, dev_name(dev), cpsw);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error attaching irq (%d)\\n\", ret);\n\t\tgoto clean_unregister_netdev;\n\t}\n\n\tif (!cpsw->cpts)\n\t\tgoto skip_cpts;\n\n\tret = devm_request_irq(dev, cpsw->misc_irq, cpsw_misc_interrupt,\n\t\t\t       0, dev_name(&pdev->dev), cpsw);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error attaching misc irq (%d)\\n\", ret);\n\t\tgoto clean_unregister_netdev;\n\t}\n\n\t \n\tcpts_set_irqpoll(cpsw->cpts, false);\n\nskip_cpts:\n\tret = cpsw_register_notifiers(cpsw);\n\tif (ret)\n\t\tgoto clean_unregister_netdev;\n\n\tret = cpsw_register_devlink(cpsw);\n\tif (ret)\n\t\tgoto clean_unregister_notifiers;\n\n\tret = cpsw_register_ports(cpsw);\n\tif (ret)\n\t\tgoto clean_unregister_notifiers;\n\n\tdev_notice(dev, \"initialized (regs %pa, pool size %d) hw_ver:%08X %d.%d (%d)\\n\",\n\t\t   &ss_res->start, descs_pool_size,\n\t\t   cpsw->version, CPSW_MAJOR_VERSION(cpsw->version),\n\t\t   CPSW_MINOR_VERSION(cpsw->version),\n\t\t   CPSW_RTL_VERSION(cpsw->version));\n\n\tpm_runtime_put(dev);\n\n\treturn 0;\n\nclean_unregister_notifiers:\n\tcpsw_unregister_notifiers(cpsw);\nclean_unregister_netdev:\n\tcpsw_unregister_ports(cpsw);\nclean_cpts:\n\tcpts_release(cpsw->cpts);\n\tcpdma_ctlr_destroy(cpsw->dma);\nclean_dt_ret:\n\tcpsw_remove_dt(cpsw);\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic int cpsw_remove(struct platform_device *pdev)\n{\n\tstruct cpsw_common *cpsw = platform_get_drvdata(pdev);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcpsw_unregister_notifiers(cpsw);\n\tcpsw_unregister_devlink(cpsw);\n\tcpsw_unregister_ports(cpsw);\n\n\tcpts_release(cpsw->cpts);\n\tcpdma_ctlr_destroy(cpsw->dma);\n\tcpsw_remove_dt(cpsw);\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\treturn 0;\n}\n\nstatic int __maybe_unused cpsw_suspend(struct device *dev)\n{\n\tstruct cpsw_common *cpsw = dev_get_drvdata(dev);\n\tint i;\n\n\trtnl_lock();\n\n\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\tstruct net_device *ndev = cpsw->slaves[i].ndev;\n\n\t\tif (!(ndev && netif_running(ndev)))\n\t\t\tcontinue;\n\n\t\tcpsw_ndo_stop(ndev);\n\t}\n\n\trtnl_unlock();\n\n\t \n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cpsw_resume(struct device *dev)\n{\n\tstruct cpsw_common *cpsw = dev_get_drvdata(dev);\n\tint i;\n\n\t \n\tpinctrl_pm_select_default_state(dev);\n\n\t \n\trtnl_lock();\n\n\tfor (i = 0; i < cpsw->data.slaves; i++) {\n\t\tstruct net_device *ndev = cpsw->slaves[i].ndev;\n\n\t\tif (!(ndev && netif_running(ndev)))\n\t\t\tcontinue;\n\n\t\tcpsw_ndo_open(ndev);\n\t}\n\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(cpsw_pm_ops, cpsw_suspend, cpsw_resume);\n\nstatic struct platform_driver cpsw_driver = {\n\t.driver = {\n\t\t.name\t = \"cpsw-switch\",\n\t\t.pm\t = &cpsw_pm_ops,\n\t\t.of_match_table = cpsw_of_mtable,\n\t},\n\t.probe = cpsw_probe,\n\t.remove = cpsw_remove,\n};\n\nmodule_platform_driver(cpsw_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TI CPSW switchdev Ethernet driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}