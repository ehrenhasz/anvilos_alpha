{
  "module_name": "icssg_prueth.c",
  "hash_id": "f447f0ee86602207428bac475e0991d40ede8ccd96f0a1449d0d69ce76bbbd9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/icssg/icssg_prueth.c",
  "human_readable_source": "\n\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dma/ti-cppi5.h>\n#include <linux/etherdevice.h>\n#include <linux/genalloc.h>\n#include <linux/if_vlan.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_platform.h>\n#include <linux/phy.h>\n#include <linux/remoteproc/pruss.h>\n#include <linux/regmap.h>\n#include <linux/remoteproc.h>\n\n#include \"icssg_prueth.h\"\n#include \"icssg_mii_rt.h\"\n#include \"../k3-cppi-desc-pool.h\"\n\n#define PRUETH_MODULE_DESCRIPTION \"PRUSS ICSSG Ethernet driver\"\n\n \n#define PRUETH_EMAC_DEBUG       (NETIF_MSG_DRV | \\\n\t\t\t\t NETIF_MSG_PROBE | \\\n\t\t\t\t NETIF_MSG_LINK | \\\n\t\t\t\t NETIF_MSG_TIMER | \\\n\t\t\t\t NETIF_MSG_IFDOWN | \\\n\t\t\t\t NETIF_MSG_IFUP | \\\n\t\t\t\t NETIF_MSG_RX_ERR | \\\n\t\t\t\t NETIF_MSG_TX_ERR | \\\n\t\t\t\t NETIF_MSG_TX_QUEUED | \\\n\t\t\t\t NETIF_MSG_INTR | \\\n\t\t\t\t NETIF_MSG_TX_DONE | \\\n\t\t\t\t NETIF_MSG_RX_STATUS | \\\n\t\t\t\t NETIF_MSG_PKTDATA | \\\n\t\t\t\t NETIF_MSG_HW | \\\n\t\t\t\t NETIF_MSG_WOL)\n\n#define prueth_napi_to_emac(napi) container_of(napi, struct prueth_emac, napi_rx)\n\n \n#define ICSSG_CTRL_RGMII_ID_MODE                BIT(24)\n\n#define IEP_DEFAULT_CYCLE_TIME_NS\t1000000\t \n\nstatic void prueth_cleanup_rx_chns(struct prueth_emac *emac,\n\t\t\t\t   struct prueth_rx_chn *rx_chn,\n\t\t\t\t   int max_rflows)\n{\n\tif (rx_chn->desc_pool)\n\t\tk3_cppi_desc_pool_destroy(rx_chn->desc_pool);\n\n\tif (rx_chn->rx_chn)\n\t\tk3_udma_glue_release_rx_chn(rx_chn->rx_chn);\n}\n\nstatic void prueth_cleanup_tx_chns(struct prueth_emac *emac)\n{\n\tint i;\n\n\tfor (i = 0; i < emac->tx_ch_num; i++) {\n\t\tstruct prueth_tx_chn *tx_chn = &emac->tx_chns[i];\n\n\t\tif (tx_chn->desc_pool)\n\t\t\tk3_cppi_desc_pool_destroy(tx_chn->desc_pool);\n\n\t\tif (tx_chn->tx_chn)\n\t\t\tk3_udma_glue_release_tx_chn(tx_chn->tx_chn);\n\n\t\t \n\t\tmemset(tx_chn, 0, sizeof(*tx_chn));\n\t}\n}\n\nstatic void prueth_ndev_del_tx_napi(struct prueth_emac *emac, int num)\n{\n\tint i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct prueth_tx_chn *tx_chn = &emac->tx_chns[i];\n\n\t\tif (tx_chn->irq)\n\t\t\tfree_irq(tx_chn->irq, tx_chn);\n\t\tnetif_napi_del(&tx_chn->napi_tx);\n\t}\n}\n\nstatic void prueth_xmit_free(struct prueth_tx_chn *tx_chn,\n\t\t\t     struct cppi5_host_desc_t *desc)\n{\n\tstruct cppi5_host_desc_t *first_desc, *next_desc;\n\tdma_addr_t buf_dma, next_desc_dma;\n\tu32 buf_dma_len;\n\n\tfirst_desc = desc;\n\tnext_desc = first_desc;\n\n\tcppi5_hdesc_get_obuf(first_desc, &buf_dma, &buf_dma_len);\n\tk3_udma_glue_tx_cppi5_to_dma_addr(tx_chn->tx_chn, &buf_dma);\n\n\tdma_unmap_single(tx_chn->dma_dev, buf_dma, buf_dma_len,\n\t\t\t DMA_TO_DEVICE);\n\n\tnext_desc_dma = cppi5_hdesc_get_next_hbdesc(first_desc);\n\tk3_udma_glue_tx_cppi5_to_dma_addr(tx_chn->tx_chn, &next_desc_dma);\n\twhile (next_desc_dma) {\n\t\tnext_desc = k3_cppi_desc_pool_dma2virt(tx_chn->desc_pool,\n\t\t\t\t\t\t       next_desc_dma);\n\t\tcppi5_hdesc_get_obuf(next_desc, &buf_dma, &buf_dma_len);\n\t\tk3_udma_glue_tx_cppi5_to_dma_addr(tx_chn->tx_chn, &buf_dma);\n\n\t\tdma_unmap_page(tx_chn->dma_dev, buf_dma, buf_dma_len,\n\t\t\t       DMA_TO_DEVICE);\n\n\t\tnext_desc_dma = cppi5_hdesc_get_next_hbdesc(next_desc);\n\t\tk3_udma_glue_tx_cppi5_to_dma_addr(tx_chn->tx_chn, &next_desc_dma);\n\n\t\tk3_cppi_desc_pool_free(tx_chn->desc_pool, next_desc);\n\t}\n\n\tk3_cppi_desc_pool_free(tx_chn->desc_pool, first_desc);\n}\n\nstatic int emac_tx_complete_packets(struct prueth_emac *emac, int chn,\n\t\t\t\t    int budget)\n{\n\tstruct net_device *ndev = emac->ndev;\n\tstruct cppi5_host_desc_t *desc_tx;\n\tstruct netdev_queue *netif_txq;\n\tstruct prueth_tx_chn *tx_chn;\n\tunsigned int total_bytes = 0;\n\tstruct sk_buff *skb;\n\tdma_addr_t desc_dma;\n\tint res, num_tx = 0;\n\tvoid **swdata;\n\n\ttx_chn = &emac->tx_chns[chn];\n\n\twhile (true) {\n\t\tres = k3_udma_glue_pop_tx_chn(tx_chn->tx_chn, &desc_dma);\n\t\tif (res == -ENODATA)\n\t\t\tbreak;\n\n\t\t \n\t\tif (cppi5_desc_is_tdcm(desc_dma)) {\n\t\t\tif (atomic_dec_and_test(&emac->tdown_cnt))\n\t\t\t\tcomplete(&emac->tdown_complete);\n\t\t\tbreak;\n\t\t}\n\n\t\tdesc_tx = k3_cppi_desc_pool_dma2virt(tx_chn->desc_pool,\n\t\t\t\t\t\t     desc_dma);\n\t\tswdata = cppi5_hdesc_get_swdata(desc_tx);\n\n\t\tskb = *(swdata);\n\t\tprueth_xmit_free(tx_chn, desc_tx);\n\n\t\tndev = skb->dev;\n\t\tndev->stats.tx_packets++;\n\t\tndev->stats.tx_bytes += skb->len;\n\t\ttotal_bytes += skb->len;\n\t\tnapi_consume_skb(skb, budget);\n\t\tnum_tx++;\n\t}\n\n\tif (!num_tx)\n\t\treturn 0;\n\n\tnetif_txq = netdev_get_tx_queue(ndev, chn);\n\tnetdev_tx_completed_queue(netif_txq, num_tx, total_bytes);\n\n\tif (netif_tx_queue_stopped(netif_txq)) {\n\t\t \n\t\t__netif_tx_lock(netif_txq, smp_processor_id());\n\t\tif (netif_running(ndev) &&\n\t\t    (k3_cppi_desc_pool_avail(tx_chn->desc_pool) >=\n\t\t     MAX_SKB_FRAGS))\n\t\t\tnetif_tx_wake_queue(netif_txq);\n\t\t__netif_tx_unlock(netif_txq);\n\t}\n\n\treturn num_tx;\n}\n\nstatic int emac_napi_tx_poll(struct napi_struct *napi_tx, int budget)\n{\n\tstruct prueth_tx_chn *tx_chn = prueth_napi_to_tx_chn(napi_tx);\n\tstruct prueth_emac *emac = tx_chn->emac;\n\tint num_tx_packets;\n\n\tnum_tx_packets = emac_tx_complete_packets(emac, tx_chn->id, budget);\n\n\tif (num_tx_packets >= budget)\n\t\treturn budget;\n\n\tif (napi_complete_done(napi_tx, num_tx_packets))\n\t\tenable_irq(tx_chn->irq);\n\n\treturn num_tx_packets;\n}\n\nstatic irqreturn_t prueth_tx_irq(int irq, void *dev_id)\n{\n\tstruct prueth_tx_chn *tx_chn = dev_id;\n\n\tdisable_irq_nosync(irq);\n\tnapi_schedule(&tx_chn->napi_tx);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int prueth_ndev_add_tx_napi(struct prueth_emac *emac)\n{\n\tstruct prueth *prueth = emac->prueth;\n\tint i, ret;\n\n\tfor (i = 0; i < emac->tx_ch_num; i++) {\n\t\tstruct prueth_tx_chn *tx_chn = &emac->tx_chns[i];\n\n\t\tnetif_napi_add_tx(emac->ndev, &tx_chn->napi_tx, emac_napi_tx_poll);\n\t\tret = request_irq(tx_chn->irq, prueth_tx_irq,\n\t\t\t\t  IRQF_TRIGGER_HIGH, tx_chn->name,\n\t\t\t\t  tx_chn);\n\t\tif (ret) {\n\t\t\tnetif_napi_del(&tx_chn->napi_tx);\n\t\t\tdev_err(prueth->dev, \"unable to request TX IRQ %d\\n\",\n\t\t\t\ttx_chn->irq);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn 0;\nfail:\n\tprueth_ndev_del_tx_napi(emac, i);\n\treturn ret;\n}\n\nstatic int prueth_init_tx_chns(struct prueth_emac *emac)\n{\n\tstatic const struct k3_ring_cfg ring_cfg = {\n\t\t.elm_size = K3_RINGACC_RING_ELSIZE_8,\n\t\t.mode = K3_RINGACC_RING_MODE_RING,\n\t\t.flags = 0,\n\t\t.size = PRUETH_MAX_TX_DESC,\n\t};\n\tstruct k3_udma_glue_tx_channel_cfg tx_cfg;\n\tstruct device *dev = emac->prueth->dev;\n\tstruct net_device *ndev = emac->ndev;\n\tint ret, slice, i;\n\tu32 hdesc_size;\n\n\tslice = prueth_emac_slice(emac);\n\tif (slice < 0)\n\t\treturn slice;\n\n\tinit_completion(&emac->tdown_complete);\n\n\thdesc_size = cppi5_hdesc_calc_size(true, PRUETH_NAV_PS_DATA_SIZE,\n\t\t\t\t\t   PRUETH_NAV_SW_DATA_SIZE);\n\tmemset(&tx_cfg, 0, sizeof(tx_cfg));\n\ttx_cfg.swdata_size = PRUETH_NAV_SW_DATA_SIZE;\n\ttx_cfg.tx_cfg = ring_cfg;\n\ttx_cfg.txcq_cfg = ring_cfg;\n\n\tfor (i = 0; i < emac->tx_ch_num; i++) {\n\t\tstruct prueth_tx_chn *tx_chn = &emac->tx_chns[i];\n\n\t\t \n\t\tsnprintf(tx_chn->name, sizeof(tx_chn->name),\n\t\t\t \"tx%d-%d\", slice, i);\n\n\t\ttx_chn->emac = emac;\n\t\ttx_chn->id = i;\n\t\ttx_chn->descs_num = PRUETH_MAX_TX_DESC;\n\n\t\ttx_chn->tx_chn =\n\t\t\tk3_udma_glue_request_tx_chn(dev, tx_chn->name,\n\t\t\t\t\t\t    &tx_cfg);\n\t\tif (IS_ERR(tx_chn->tx_chn)) {\n\t\t\tret = PTR_ERR(tx_chn->tx_chn);\n\t\t\ttx_chn->tx_chn = NULL;\n\t\t\tnetdev_err(ndev,\n\t\t\t\t   \"Failed to request tx dma ch: %d\\n\", ret);\n\t\t\tgoto fail;\n\t\t}\n\n\t\ttx_chn->dma_dev = k3_udma_glue_tx_get_dma_device(tx_chn->tx_chn);\n\t\ttx_chn->desc_pool =\n\t\t\tk3_cppi_desc_pool_create_name(tx_chn->dma_dev,\n\t\t\t\t\t\t      tx_chn->descs_num,\n\t\t\t\t\t\t      hdesc_size,\n\t\t\t\t\t\t      tx_chn->name);\n\t\tif (IS_ERR(tx_chn->desc_pool)) {\n\t\t\tret = PTR_ERR(tx_chn->desc_pool);\n\t\t\ttx_chn->desc_pool = NULL;\n\t\t\tnetdev_err(ndev, \"Failed to create tx pool: %d\\n\", ret);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tret = k3_udma_glue_tx_get_irq(tx_chn->tx_chn);\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(ndev, \"failed to get tx irq\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\ttx_chn->irq = ret;\n\n\t\tsnprintf(tx_chn->name, sizeof(tx_chn->name), \"%s-tx%d\",\n\t\t\t dev_name(dev), tx_chn->id);\n\t}\n\n\treturn 0;\n\nfail:\n\tprueth_cleanup_tx_chns(emac);\n\treturn ret;\n}\n\nstatic int prueth_init_rx_chns(struct prueth_emac *emac,\n\t\t\t       struct prueth_rx_chn *rx_chn,\n\t\t\t       char *name, u32 max_rflows,\n\t\t\t       u32 max_desc_num)\n{\n\tstruct k3_udma_glue_rx_channel_cfg rx_cfg;\n\tstruct device *dev = emac->prueth->dev;\n\tstruct net_device *ndev = emac->ndev;\n\tu32 fdqring_id, hdesc_size;\n\tint i, ret = 0, slice;\n\n\tslice = prueth_emac_slice(emac);\n\tif (slice < 0)\n\t\treturn slice;\n\n\t \n\tsnprintf(rx_chn->name, sizeof(rx_chn->name), \"%s%d\", name, slice);\n\n\thdesc_size = cppi5_hdesc_calc_size(true, PRUETH_NAV_PS_DATA_SIZE,\n\t\t\t\t\t   PRUETH_NAV_SW_DATA_SIZE);\n\tmemset(&rx_cfg, 0, sizeof(rx_cfg));\n\trx_cfg.swdata_size = PRUETH_NAV_SW_DATA_SIZE;\n\trx_cfg.flow_id_num = max_rflows;\n\trx_cfg.flow_id_base = -1;  \n\n\t \n\trx_chn->dev = dev;\n\trx_chn->descs_num = max_desc_num;\n\n\trx_chn->rx_chn = k3_udma_glue_request_rx_chn(dev, rx_chn->name,\n\t\t\t\t\t\t     &rx_cfg);\n\tif (IS_ERR(rx_chn->rx_chn)) {\n\t\tret = PTR_ERR(rx_chn->rx_chn);\n\t\trx_chn->rx_chn = NULL;\n\t\tnetdev_err(ndev, \"Failed to request rx dma ch: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\trx_chn->dma_dev = k3_udma_glue_rx_get_dma_device(rx_chn->rx_chn);\n\trx_chn->desc_pool = k3_cppi_desc_pool_create_name(rx_chn->dma_dev,\n\t\t\t\t\t\t\t  rx_chn->descs_num,\n\t\t\t\t\t\t\t  hdesc_size,\n\t\t\t\t\t\t\t  rx_chn->name);\n\tif (IS_ERR(rx_chn->desc_pool)) {\n\t\tret = PTR_ERR(rx_chn->desc_pool);\n\t\trx_chn->desc_pool = NULL;\n\t\tnetdev_err(ndev, \"Failed to create rx pool: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\temac->rx_flow_id_base = k3_udma_glue_rx_get_flow_id_base(rx_chn->rx_chn);\n\tnetdev_dbg(ndev, \"flow id base = %d\\n\", emac->rx_flow_id_base);\n\n\tfdqring_id = K3_RINGACC_RING_ID_ANY;\n\tfor (i = 0; i < rx_cfg.flow_id_num; i++) {\n\t\tstruct k3_ring_cfg rxring_cfg = {\n\t\t\t.elm_size = K3_RINGACC_RING_ELSIZE_8,\n\t\t\t.mode = K3_RINGACC_RING_MODE_RING,\n\t\t\t.flags = 0,\n\t\t};\n\t\tstruct k3_ring_cfg fdqring_cfg = {\n\t\t\t.elm_size = K3_RINGACC_RING_ELSIZE_8,\n\t\t\t.flags = K3_RINGACC_RING_SHARED,\n\t\t};\n\t\tstruct k3_udma_glue_rx_flow_cfg rx_flow_cfg = {\n\t\t\t.rx_cfg = rxring_cfg,\n\t\t\t.rxfdq_cfg = fdqring_cfg,\n\t\t\t.ring_rxq_id = K3_RINGACC_RING_ID_ANY,\n\t\t\t.src_tag_lo_sel =\n\t\t\t\tK3_UDMA_GLUE_SRC_TAG_LO_USE_REMOTE_SRC_TAG,\n\t\t};\n\n\t\trx_flow_cfg.ring_rxfdq0_id = fdqring_id;\n\t\trx_flow_cfg.rx_cfg.size = max_desc_num;\n\t\trx_flow_cfg.rxfdq_cfg.size = max_desc_num;\n\t\trx_flow_cfg.rxfdq_cfg.mode = emac->prueth->pdata.fdqring_mode;\n\n\t\tret = k3_udma_glue_rx_flow_init(rx_chn->rx_chn,\n\t\t\t\t\t\ti, &rx_flow_cfg);\n\t\tif (ret) {\n\t\t\tnetdev_err(ndev, \"Failed to init rx flow%d %d\\n\",\n\t\t\t\t   i, ret);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (!i)\n\t\t\tfdqring_id = k3_udma_glue_rx_flow_get_fdq_id(rx_chn->rx_chn,\n\t\t\t\t\t\t\t\t     i);\n\t\trx_chn->irq[i] = k3_udma_glue_rx_get_irq(rx_chn->rx_chn, i);\n\t\tif (rx_chn->irq[i] <= 0) {\n\t\t\tret = rx_chn->irq[i];\n\t\t\tnetdev_err(ndev, \"Failed to get rx dma irq\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail:\n\tprueth_cleanup_rx_chns(emac, rx_chn, max_rflows);\n\treturn ret;\n}\n\nstatic int prueth_dma_rx_push(struct prueth_emac *emac,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      struct prueth_rx_chn *rx_chn)\n{\n\tstruct net_device *ndev = emac->ndev;\n\tstruct cppi5_host_desc_t *desc_rx;\n\tu32 pkt_len = skb_tailroom(skb);\n\tdma_addr_t desc_dma;\n\tdma_addr_t buf_dma;\n\tvoid **swdata;\n\n\tdesc_rx = k3_cppi_desc_pool_alloc(rx_chn->desc_pool);\n\tif (!desc_rx) {\n\t\tnetdev_err(ndev, \"rx push: failed to allocate descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdesc_dma = k3_cppi_desc_pool_virt2dma(rx_chn->desc_pool, desc_rx);\n\n\tbuf_dma = dma_map_single(rx_chn->dma_dev, skb->data, pkt_len, DMA_FROM_DEVICE);\n\tif (unlikely(dma_mapping_error(rx_chn->dma_dev, buf_dma))) {\n\t\tk3_cppi_desc_pool_free(rx_chn->desc_pool, desc_rx);\n\t\tnetdev_err(ndev, \"rx push: failed to map rx pkt buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcppi5_hdesc_init(desc_rx, CPPI5_INFO0_HDESC_EPIB_PRESENT,\n\t\t\t PRUETH_NAV_PS_DATA_SIZE);\n\tk3_udma_glue_rx_dma_to_cppi5_addr(rx_chn->rx_chn, &buf_dma);\n\tcppi5_hdesc_attach_buf(desc_rx, buf_dma, skb_tailroom(skb), buf_dma, skb_tailroom(skb));\n\n\tswdata = cppi5_hdesc_get_swdata(desc_rx);\n\t*swdata = skb;\n\n\treturn k3_udma_glue_push_rx_chn(rx_chn->rx_chn, 0,\n\t\t\t\t\tdesc_rx, desc_dma);\n}\n\nstatic u64 icssg_ts_to_ns(u32 hi_sw, u32 hi, u32 lo, u32 cycle_time_ns)\n{\n\tu32 iepcount_lo, iepcount_hi, hi_rollover_count;\n\tu64 ns;\n\n\tiepcount_lo = lo & GENMASK(19, 0);\n\tiepcount_hi = (hi & GENMASK(11, 0)) << 12 | lo >> 20;\n\thi_rollover_count = hi >> 11;\n\n\tns = ((u64)hi_rollover_count) << 23 | (iepcount_hi + hi_sw);\n\tns = ns * cycle_time_ns + iepcount_lo;\n\n\treturn ns;\n}\n\nstatic void emac_rx_timestamp(struct prueth_emac *emac,\n\t\t\t      struct sk_buff *skb, u32 *psdata)\n{\n\tstruct skb_shared_hwtstamps *ssh;\n\tu64 ns;\n\n\tu32 hi_sw = readl(emac->prueth->shram.va +\n\t\t\t  TIMESYNC_FW_WC_COUNT_HI_SW_OFFSET_OFFSET);\n\tns = icssg_ts_to_ns(hi_sw, psdata[1], psdata[0],\n\t\t\t    IEP_DEFAULT_CYCLE_TIME_NS);\n\n\tssh = skb_hwtstamps(skb);\n\tmemset(ssh, 0, sizeof(*ssh));\n\tssh->hwtstamp = ns_to_ktime(ns);\n}\n\nstatic int emac_rx_packet(struct prueth_emac *emac, u32 flow_id)\n{\n\tstruct prueth_rx_chn *rx_chn = &emac->rx_chns;\n\tu32 buf_dma_len, pkt_len, port_id = 0;\n\tstruct net_device *ndev = emac->ndev;\n\tstruct cppi5_host_desc_t *desc_rx;\n\tstruct sk_buff *skb, *new_skb;\n\tdma_addr_t desc_dma, buf_dma;\n\tvoid **swdata;\n\tu32 *psdata;\n\tint ret;\n\n\tret = k3_udma_glue_pop_rx_chn(rx_chn->rx_chn, flow_id, &desc_dma);\n\tif (ret) {\n\t\tif (ret != -ENODATA)\n\t\t\tnetdev_err(ndev, \"rx pop: failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (cppi5_desc_is_tdcm(desc_dma))  \n\t\treturn 0;\n\n\tdesc_rx = k3_cppi_desc_pool_dma2virt(rx_chn->desc_pool, desc_dma);\n\n\tswdata = cppi5_hdesc_get_swdata(desc_rx);\n\tskb = *swdata;\n\n\tpsdata = cppi5_hdesc_get_psdata(desc_rx);\n\t \n\tif (emac->rx_ts_enabled)\n\t\temac_rx_timestamp(emac, skb, psdata);\n\n\tcppi5_hdesc_get_obuf(desc_rx, &buf_dma, &buf_dma_len);\n\tk3_udma_glue_rx_cppi5_to_dma_addr(rx_chn->rx_chn, &buf_dma);\n\tpkt_len = cppi5_hdesc_get_pktlen(desc_rx);\n\t \n\tpkt_len -= 4;\n\tcppi5_desc_get_tags_ids(&desc_rx->hdr, &port_id, NULL);\n\n\tdma_unmap_single(rx_chn->dma_dev, buf_dma, buf_dma_len, DMA_FROM_DEVICE);\n\tk3_cppi_desc_pool_free(rx_chn->desc_pool, desc_rx);\n\n\tskb->dev = ndev;\n\tnew_skb = netdev_alloc_skb_ip_align(ndev, PRUETH_MAX_PKT_SIZE);\n\t \n\tif (!new_skb) {\n\t\tndev->stats.rx_dropped++;\n\t\tnew_skb = skb;\n\t} else {\n\t\t \n\t\tskb_put(skb, pkt_len);\n\t\tskb->protocol = eth_type_trans(skb, ndev);\n\t\tnapi_gro_receive(&emac->napi_rx, skb);\n\t\tndev->stats.rx_bytes += pkt_len;\n\t\tndev->stats.rx_packets++;\n\t}\n\n\t \n\tret = prueth_dma_rx_push(emac, new_skb, &emac->rx_chns);\n\tif (WARN_ON(ret < 0)) {\n\t\tdev_kfree_skb_any(new_skb);\n\t\tndev->stats.rx_errors++;\n\t\tndev->stats.rx_dropped++;\n\t}\n\n\treturn ret;\n}\n\nstatic void prueth_rx_cleanup(void *data, dma_addr_t desc_dma)\n{\n\tstruct prueth_rx_chn *rx_chn = data;\n\tstruct cppi5_host_desc_t *desc_rx;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_dma;\n\tu32 buf_dma_len;\n\tvoid **swdata;\n\n\tdesc_rx = k3_cppi_desc_pool_dma2virt(rx_chn->desc_pool, desc_dma);\n\tswdata = cppi5_hdesc_get_swdata(desc_rx);\n\tskb = *swdata;\n\tcppi5_hdesc_get_obuf(desc_rx, &buf_dma, &buf_dma_len);\n\tk3_udma_glue_rx_cppi5_to_dma_addr(rx_chn->rx_chn, &buf_dma);\n\n\tdma_unmap_single(rx_chn->dma_dev, buf_dma, buf_dma_len,\n\t\t\t DMA_FROM_DEVICE);\n\tk3_cppi_desc_pool_free(rx_chn->desc_pool, desc_rx);\n\n\tdev_kfree_skb_any(skb);\n}\n\nstatic int emac_get_tx_ts(struct prueth_emac *emac,\n\t\t\t  struct emac_tx_ts_response *rsp)\n{\n\tstruct prueth *prueth = emac->prueth;\n\tint slice = prueth_emac_slice(emac);\n\tint addr;\n\n\taddr = icssg_queue_pop(prueth, slice == 0 ?\n\t\t\t       ICSSG_TS_POP_SLICE0 : ICSSG_TS_POP_SLICE1);\n\tif (addr < 0)\n\t\treturn addr;\n\n\tmemcpy_fromio(rsp, prueth->shram.va + addr, sizeof(*rsp));\n\t \n\ticssg_queue_push(prueth, slice == 0 ?\n\t\t\t ICSSG_TS_PUSH_SLICE0 : ICSSG_TS_PUSH_SLICE1, addr);\n\n\treturn 0;\n}\n\nstatic void tx_ts_work(struct prueth_emac *emac)\n{\n\tstruct skb_shared_hwtstamps ssh;\n\tstruct emac_tx_ts_response tsr;\n\tstruct sk_buff *skb;\n\tint ret = 0;\n\tu32 hi_sw;\n\tu64 ns;\n\n\t \n\twhile (1) {\n\t\tret = emac_get_tx_ts(emac, &tsr);\n\t\tif (ret)  \n\t\t\tbreak;\n\n\t\tif (tsr.cookie >= PRUETH_MAX_TX_TS_REQUESTS ||\n\t\t    !emac->tx_ts_skb[tsr.cookie]) {\n\t\t\tnetdev_err(emac->ndev, \"Invalid TX TS cookie 0x%x\\n\",\n\t\t\t\t   tsr.cookie);\n\t\t\tbreak;\n\t\t}\n\n\t\tskb = emac->tx_ts_skb[tsr.cookie];\n\t\temac->tx_ts_skb[tsr.cookie] = NULL;\t \n\t\tif (!skb) {\n\t\t\tnetdev_err(emac->ndev, \"Driver Bug! got NULL skb\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\thi_sw = readl(emac->prueth->shram.va +\n\t\t\t      TIMESYNC_FW_WC_COUNT_HI_SW_OFFSET_OFFSET);\n\t\tns = icssg_ts_to_ns(hi_sw, tsr.hi_ts, tsr.lo_ts,\n\t\t\t\t    IEP_DEFAULT_CYCLE_TIME_NS);\n\n\t\tmemset(&ssh, 0, sizeof(ssh));\n\t\tssh.hwtstamp = ns_to_ktime(ns);\n\n\t\tskb_tstamp_tx(skb, &ssh);\n\t\tdev_consume_skb_any(skb);\n\n\t\tif (atomic_dec_and_test(&emac->tx_ts_pending))\t \n\t\t\tbreak;\n\t}\n}\n\nstatic int prueth_tx_ts_cookie_get(struct prueth_emac *emac)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < PRUETH_MAX_TX_TS_REQUESTS; i++) {\n\t\tif (!emac->tx_ts_skb[i]) {\n\t\t\temac->tx_ts_skb[i] = ERR_PTR(-EBUSY);  \n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -EBUSY;\n}\n\n \nstatic enum netdev_tx emac_ndo_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct cppi5_host_desc_t *first_desc, *next_desc, *cur_desc;\n\tstruct prueth_emac *emac = netdev_priv(ndev);\n\tstruct netdev_queue *netif_txq;\n\tstruct prueth_tx_chn *tx_chn;\n\tdma_addr_t desc_dma, buf_dma;\n\tint i, ret = 0, q_idx;\n\tbool in_tx_ts = 0;\n\tint tx_ts_cookie;\n\tvoid **swdata;\n\tu32 pkt_len;\n\tu32 *epib;\n\n\tpkt_len = skb_headlen(skb);\n\tq_idx = skb_get_queue_mapping(skb);\n\n\ttx_chn = &emac->tx_chns[q_idx];\n\tnetif_txq = netdev_get_tx_queue(ndev, q_idx);\n\n\t \n\tbuf_dma = dma_map_single(tx_chn->dma_dev, skb->data, pkt_len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(tx_chn->dma_dev, buf_dma)) {\n\t\tnetdev_err(ndev, \"tx: failed to map skb buffer\\n\");\n\t\tret = NETDEV_TX_OK;\n\t\tgoto drop_free_skb;\n\t}\n\n\tfirst_desc = k3_cppi_desc_pool_alloc(tx_chn->desc_pool);\n\tif (!first_desc) {\n\t\tnetdev_dbg(ndev, \"tx: failed to allocate descriptor\\n\");\n\t\tdma_unmap_single(tx_chn->dma_dev, buf_dma, pkt_len, DMA_TO_DEVICE);\n\t\tgoto drop_stop_q_busy;\n\t}\n\n\tcppi5_hdesc_init(first_desc, CPPI5_INFO0_HDESC_EPIB_PRESENT,\n\t\t\t PRUETH_NAV_PS_DATA_SIZE);\n\tcppi5_hdesc_set_pkttype(first_desc, 0);\n\tepib = first_desc->epib;\n\tepib[0] = 0;\n\tepib[1] = 0;\n\tif (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP &&\n\t    emac->tx_ts_enabled) {\n\t\ttx_ts_cookie = prueth_tx_ts_cookie_get(emac);\n\t\tif (tx_ts_cookie >= 0) {\n\t\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\t\t \n\t\t\tepib[0] = (u32)tx_ts_cookie;\n\t\t\tepib[1] = 0x80000000;\t \n\t\t\temac->tx_ts_skb[tx_ts_cookie] = skb_get(skb);\n\t\t\tin_tx_ts = 1;\n\t\t}\n\t}\n\n\t \n\tcppi5_desc_set_tags_ids(&first_desc->hdr, 0, (emac->port_id | (q_idx << 8)));\n\tk3_udma_glue_tx_dma_to_cppi5_addr(tx_chn->tx_chn, &buf_dma);\n\tcppi5_hdesc_attach_buf(first_desc, buf_dma, pkt_len, buf_dma, pkt_len);\n\tswdata = cppi5_hdesc_get_swdata(first_desc);\n\t*swdata = skb;\n\n\t \n\tcur_desc = first_desc;\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tu32 frag_size = skb_frag_size(frag);\n\n\t\tnext_desc = k3_cppi_desc_pool_alloc(tx_chn->desc_pool);\n\t\tif (!next_desc) {\n\t\t\tnetdev_err(ndev,\n\t\t\t\t   \"tx: failed to allocate frag. descriptor\\n\");\n\t\t\tgoto free_desc_stop_q_busy_cleanup_tx_ts;\n\t\t}\n\n\t\tbuf_dma = skb_frag_dma_map(tx_chn->dma_dev, frag, 0, frag_size,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(tx_chn->dma_dev, buf_dma)) {\n\t\t\tnetdev_err(ndev, \"tx: Failed to map skb page\\n\");\n\t\t\tk3_cppi_desc_pool_free(tx_chn->desc_pool, next_desc);\n\t\t\tret = NETDEV_TX_OK;\n\t\t\tgoto cleanup_tx_ts;\n\t\t}\n\n\t\tcppi5_hdesc_reset_hbdesc(next_desc);\n\t\tk3_udma_glue_tx_dma_to_cppi5_addr(tx_chn->tx_chn, &buf_dma);\n\t\tcppi5_hdesc_attach_buf(next_desc,\n\t\t\t\t       buf_dma, frag_size, buf_dma, frag_size);\n\n\t\tdesc_dma = k3_cppi_desc_pool_virt2dma(tx_chn->desc_pool,\n\t\t\t\t\t\t      next_desc);\n\t\tk3_udma_glue_tx_dma_to_cppi5_addr(tx_chn->tx_chn, &desc_dma);\n\t\tcppi5_hdesc_link_hbdesc(cur_desc, desc_dma);\n\n\t\tpkt_len += frag_size;\n\t\tcur_desc = next_desc;\n\t}\n\tWARN_ON_ONCE(pkt_len != skb->len);\n\n\t \n\tnetdev_tx_sent_queue(netif_txq, pkt_len);\n\n\tcppi5_hdesc_set_pktlen(first_desc, pkt_len);\n\tdesc_dma = k3_cppi_desc_pool_virt2dma(tx_chn->desc_pool, first_desc);\n\t \n\n\tskb_tx_timestamp(skb);   \n\tret = k3_udma_glue_push_tx_chn(tx_chn->tx_chn, first_desc, desc_dma);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"tx: push failed: %d\\n\", ret);\n\t\tgoto drop_free_descs;\n\t}\n\n\tif (in_tx_ts)\n\t\tatomic_inc(&emac->tx_ts_pending);\n\n\tif (k3_cppi_desc_pool_avail(tx_chn->desc_pool) < MAX_SKB_FRAGS) {\n\t\tnetif_tx_stop_queue(netif_txq);\n\t\t \n\t\tsmp_mb__after_atomic();\n\n\t\tif (k3_cppi_desc_pool_avail(tx_chn->desc_pool) >=\n\t\t    MAX_SKB_FRAGS)\n\t\t\tnetif_tx_wake_queue(netif_txq);\n\t}\n\n\treturn NETDEV_TX_OK;\n\ncleanup_tx_ts:\n\tif (in_tx_ts) {\n\t\tdev_kfree_skb_any(emac->tx_ts_skb[tx_ts_cookie]);\n\t\temac->tx_ts_skb[tx_ts_cookie] = NULL;\n\t}\n\ndrop_free_descs:\n\tprueth_xmit_free(tx_chn, first_desc);\n\ndrop_free_skb:\n\tdev_kfree_skb_any(skb);\n\n\t \n\tndev->stats.tx_dropped++;\n\tnetdev_err(ndev, \"tx: error: %d\\n\", ret);\n\n\treturn ret;\n\nfree_desc_stop_q_busy_cleanup_tx_ts:\n\tif (in_tx_ts) {\n\t\tdev_kfree_skb_any(emac->tx_ts_skb[tx_ts_cookie]);\n\t\temac->tx_ts_skb[tx_ts_cookie] = NULL;\n\t}\n\tprueth_xmit_free(tx_chn, first_desc);\n\ndrop_stop_q_busy:\n\tnetif_tx_stop_queue(netif_txq);\n\treturn NETDEV_TX_BUSY;\n}\n\nstatic void prueth_tx_cleanup(void *data, dma_addr_t desc_dma)\n{\n\tstruct prueth_tx_chn *tx_chn = data;\n\tstruct cppi5_host_desc_t *desc_tx;\n\tstruct sk_buff *skb;\n\tvoid **swdata;\n\n\tdesc_tx = k3_cppi_desc_pool_dma2virt(tx_chn->desc_pool, desc_dma);\n\tswdata = cppi5_hdesc_get_swdata(desc_tx);\n\tskb = *(swdata);\n\tprueth_xmit_free(tx_chn, desc_tx);\n\n\tdev_kfree_skb_any(skb);\n}\n\nstatic irqreturn_t prueth_tx_ts_irq(int irq, void *dev_id)\n{\n\tstruct prueth_emac *emac = dev_id;\n\n\t \n\ttx_ts_work(emac);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t prueth_rx_irq(int irq, void *dev_id)\n{\n\tstruct prueth_emac *emac = dev_id;\n\n\tdisable_irq_nosync(irq);\n\tnapi_schedule(&emac->napi_rx);\n\n\treturn IRQ_HANDLED;\n}\n\nstruct icssg_firmwares {\n\tchar *pru;\n\tchar *rtu;\n\tchar *txpru;\n};\n\nstatic struct icssg_firmwares icssg_emac_firmwares[] = {\n\t{\n\t\t.pru = \"ti-pruss/am65x-sr2-pru0-prueth-fw.elf\",\n\t\t.rtu = \"ti-pruss/am65x-sr2-rtu0-prueth-fw.elf\",\n\t\t.txpru = \"ti-pruss/am65x-sr2-txpru0-prueth-fw.elf\",\n\t},\n\t{\n\t\t.pru = \"ti-pruss/am65x-sr2-pru1-prueth-fw.elf\",\n\t\t.rtu = \"ti-pruss/am65x-sr2-rtu1-prueth-fw.elf\",\n\t\t.txpru = \"ti-pruss/am65x-sr2-txpru1-prueth-fw.elf\",\n\t}\n};\n\nstatic int prueth_emac_start(struct prueth *prueth, struct prueth_emac *emac)\n{\n\tstruct icssg_firmwares *firmwares;\n\tstruct device *dev = prueth->dev;\n\tint slice, ret;\n\n\tfirmwares = icssg_emac_firmwares;\n\n\tslice = prueth_emac_slice(emac);\n\tif (slice < 0) {\n\t\tnetdev_err(emac->ndev, \"invalid port\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = icssg_config(prueth, emac, slice);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rproc_set_firmware(prueth->pru[slice], firmwares[slice].pru);\n\tret = rproc_boot(prueth->pru[slice]);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to boot PRU%d: %d\\n\", slice, ret);\n\t\treturn -EINVAL;\n\t}\n\n\tret = rproc_set_firmware(prueth->rtu[slice], firmwares[slice].rtu);\n\tret = rproc_boot(prueth->rtu[slice]);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to boot RTU%d: %d\\n\", slice, ret);\n\t\tgoto halt_pru;\n\t}\n\n\tret = rproc_set_firmware(prueth->txpru[slice], firmwares[slice].txpru);\n\tret = rproc_boot(prueth->txpru[slice]);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to boot TX_PRU%d: %d\\n\", slice, ret);\n\t\tgoto halt_rtu;\n\t}\n\n\temac->fw_running = 1;\n\treturn 0;\n\nhalt_rtu:\n\trproc_shutdown(prueth->rtu[slice]);\n\nhalt_pru:\n\trproc_shutdown(prueth->pru[slice]);\n\n\treturn ret;\n}\n\nstatic void prueth_emac_stop(struct prueth_emac *emac)\n{\n\tstruct prueth *prueth = emac->prueth;\n\tint slice;\n\n\tswitch (emac->port_id) {\n\tcase PRUETH_PORT_MII0:\n\t\tslice = ICSS_SLICE0;\n\t\tbreak;\n\tcase PRUETH_PORT_MII1:\n\t\tslice = ICSS_SLICE1;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(emac->ndev, \"invalid port\\n\");\n\t\treturn;\n\t}\n\n\temac->fw_running = 0;\n\trproc_shutdown(prueth->txpru[slice]);\n\trproc_shutdown(prueth->rtu[slice]);\n\trproc_shutdown(prueth->pru[slice]);\n}\n\nstatic void prueth_cleanup_tx_ts(struct prueth_emac *emac)\n{\n\tint i;\n\n\tfor (i = 0; i < PRUETH_MAX_TX_TS_REQUESTS; i++) {\n\t\tif (emac->tx_ts_skb[i]) {\n\t\t\tdev_kfree_skb_any(emac->tx_ts_skb[i]);\n\t\t\temac->tx_ts_skb[i] = NULL;\n\t\t}\n\t}\n}\n\n \nstatic void emac_adjust_link(struct net_device *ndev)\n{\n\tstruct prueth_emac *emac = netdev_priv(ndev);\n\tstruct phy_device *phydev = ndev->phydev;\n\tstruct prueth *prueth = emac->prueth;\n\tbool new_state = false;\n\tunsigned long flags;\n\n\tif (phydev->link) {\n\t\t \n\t\tif (phydev->duplex != emac->duplex) {\n\t\t\tnew_state = true;\n\t\t\temac->duplex = phydev->duplex;\n\t\t}\n\t\tif (phydev->speed != emac->speed) {\n\t\t\tnew_state = true;\n\t\t\temac->speed = phydev->speed;\n\t\t}\n\t\tif (!emac->link) {\n\t\t\tnew_state = true;\n\t\t\temac->link = 1;\n\t\t}\n\t} else if (emac->link) {\n\t\tnew_state = true;\n\t\temac->link = 0;\n\n\t\t \n\t\temac->speed = SPEED_1000;\n\n\t\t \n\t\temac->duplex = DUPLEX_FULL;\n\t}\n\n\tif (new_state) {\n\t\tphy_print_status(phydev);\n\n\t\t \n\t\tif (emac->link) {\n\t\t\t \n\t\t\ticssg_update_rgmii_cfg(prueth->miig_rt, emac);\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&emac->lock, flags);\n\t\t\ticssg_config_ipg(emac);\n\t\t\tspin_unlock_irqrestore(&emac->lock, flags);\n\t\t\ticssg_config_set_speed(emac);\n\t\t\temac_set_port_state(emac, ICSSG_EMAC_PORT_FORWARD);\n\n\t\t} else {\n\t\t\temac_set_port_state(emac, ICSSG_EMAC_PORT_DISABLE);\n\t\t}\n\t}\n\n\tif (emac->link) {\n\t\t \n\t\tnetif_tx_wake_all_queues(ndev);\n\t} else {\n\t\tnetif_tx_stop_all_queues(ndev);\n\t\tprueth_cleanup_tx_ts(emac);\n\t}\n}\n\nstatic int emac_napi_rx_poll(struct napi_struct *napi_rx, int budget)\n{\n\tstruct prueth_emac *emac = prueth_napi_to_emac(napi_rx);\n\tint rx_flow = PRUETH_RX_FLOW_DATA;\n\tint flow = PRUETH_MAX_RX_FLOWS;\n\tint num_rx = 0;\n\tint cur_budget;\n\tint ret;\n\n\twhile (flow--) {\n\t\tcur_budget = budget - num_rx;\n\n\t\twhile (cur_budget--) {\n\t\t\tret = emac_rx_packet(emac, flow);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tnum_rx++;\n\t\t}\n\n\t\tif (num_rx >= budget)\n\t\t\tbreak;\n\t}\n\n\tif (num_rx < budget && napi_complete_done(napi_rx, num_rx))\n\t\tenable_irq(emac->rx_chns.irq[rx_flow]);\n\n\treturn num_rx;\n}\n\nstatic int prueth_prepare_rx_chan(struct prueth_emac *emac,\n\t\t\t\t  struct prueth_rx_chn *chn,\n\t\t\t\t  int buf_size)\n{\n\tstruct sk_buff *skb;\n\tint i, ret;\n\n\tfor (i = 0; i < chn->descs_num; i++) {\n\t\tskb = __netdev_alloc_skb_ip_align(NULL, buf_size, GFP_KERNEL);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tret = prueth_dma_rx_push(emac, skb, chn);\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(emac->ndev,\n\t\t\t\t   \"cannot submit skb for rx chan %s ret %d\\n\",\n\t\t\t\t   chn->name, ret);\n\t\t\tkfree_skb(skb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void prueth_reset_tx_chan(struct prueth_emac *emac, int ch_num,\n\t\t\t\t bool free_skb)\n{\n\tint i;\n\n\tfor (i = 0; i < ch_num; i++) {\n\t\tif (free_skb)\n\t\t\tk3_udma_glue_reset_tx_chn(emac->tx_chns[i].tx_chn,\n\t\t\t\t\t\t  &emac->tx_chns[i],\n\t\t\t\t\t\t  prueth_tx_cleanup);\n\t\tk3_udma_glue_disable_tx_chn(emac->tx_chns[i].tx_chn);\n\t}\n}\n\nstatic void prueth_reset_rx_chan(struct prueth_rx_chn *chn,\n\t\t\t\t int num_flows, bool disable)\n{\n\tint i;\n\n\tfor (i = 0; i < num_flows; i++)\n\t\tk3_udma_glue_reset_rx_chn(chn->rx_chn, i, chn,\n\t\t\t\t\t  prueth_rx_cleanup, !!i);\n\tif (disable)\n\t\tk3_udma_glue_disable_rx_chn(chn->rx_chn);\n}\n\nstatic int emac_phy_connect(struct prueth_emac *emac)\n{\n\tstruct prueth *prueth = emac->prueth;\n\tstruct net_device *ndev = emac->ndev;\n\t \n\tndev->phydev = of_phy_connect(emac->ndev, emac->phy_node,\n\t\t\t\t      &emac_adjust_link, 0,\n\t\t\t\t      emac->phy_if);\n\tif (!ndev->phydev) {\n\t\tdev_err(prueth->dev, \"couldn't connect to phy %s\\n\",\n\t\t\temac->phy_node->full_name);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tphy_remove_link_mode(ndev->phydev, ETHTOOL_LINK_MODE_10baseT_Half_BIT);\n\tphy_remove_link_mode(ndev->phydev, ETHTOOL_LINK_MODE_100baseT_Half_BIT);\n\tphy_remove_link_mode(ndev->phydev, ETHTOOL_LINK_MODE_1000baseT_Half_BIT);\n\tphy_remove_link_mode(ndev->phydev, ETHTOOL_LINK_MODE_Pause_BIT);\n\tphy_remove_link_mode(ndev->phydev, ETHTOOL_LINK_MODE_Asym_Pause_BIT);\n\n\tif (emac->phy_if == PHY_INTERFACE_MODE_MII)\n\t\tphy_set_max_speed(ndev->phydev, SPEED_100);\n\n\treturn 0;\n}\n\nstatic u64 prueth_iep_gettime(void *clockops_data, struct ptp_system_timestamp *sts)\n{\n\tu32 hi_rollover_count, hi_rollover_count_r;\n\tstruct prueth_emac *emac = clockops_data;\n\tstruct prueth *prueth = emac->prueth;\n\tvoid __iomem *fw_hi_r_count_addr;\n\tvoid __iomem *fw_count_hi_addr;\n\tu32 iepcount_hi, iepcount_hi_r;\n\tunsigned long flags;\n\tu32 iepcount_lo;\n\tu64 ts = 0;\n\n\tfw_count_hi_addr = prueth->shram.va + TIMESYNC_FW_WC_COUNT_HI_SW_OFFSET_OFFSET;\n\tfw_hi_r_count_addr = prueth->shram.va + TIMESYNC_FW_WC_HI_ROLLOVER_COUNT_OFFSET;\n\n\tlocal_irq_save(flags);\n\tdo {\n\t\tiepcount_hi = icss_iep_get_count_hi(emac->iep);\n\t\tiepcount_hi += readl(fw_count_hi_addr);\n\t\thi_rollover_count = readl(fw_hi_r_count_addr);\n\t\tptp_read_system_prets(sts);\n\t\tiepcount_lo = icss_iep_get_count_low(emac->iep);\n\t\tptp_read_system_postts(sts);\n\n\t\tiepcount_hi_r = icss_iep_get_count_hi(emac->iep);\n\t\tiepcount_hi_r += readl(fw_count_hi_addr);\n\t\thi_rollover_count_r = readl(fw_hi_r_count_addr);\n\t} while ((iepcount_hi_r != iepcount_hi) ||\n\t\t (hi_rollover_count != hi_rollover_count_r));\n\tlocal_irq_restore(flags);\n\n\tts = ((u64)hi_rollover_count) << 23 | iepcount_hi;\n\tts = ts * (u64)IEP_DEFAULT_CYCLE_TIME_NS + iepcount_lo;\n\n\treturn ts;\n}\n\nstatic void prueth_iep_settime(void *clockops_data, u64 ns)\n{\n\tstruct icssg_setclock_desc __iomem *sc_descp;\n\tstruct prueth_emac *emac = clockops_data;\n\tstruct icssg_setclock_desc sc_desc;\n\tu64 cyclecount;\n\tu32 cycletime;\n\tint timeout;\n\n\tif (!emac->fw_running)\n\t\treturn;\n\n\tsc_descp = emac->prueth->shram.va + TIMESYNC_FW_WC_SETCLOCK_DESC_OFFSET;\n\n\tcycletime = IEP_DEFAULT_CYCLE_TIME_NS;\n\tcyclecount = ns / cycletime;\n\n\tmemset(&sc_desc, 0, sizeof(sc_desc));\n\tsc_desc.margin = cycletime - 1000;\n\tsc_desc.cyclecounter0_set = cyclecount & GENMASK(31, 0);\n\tsc_desc.cyclecounter1_set = (cyclecount & GENMASK(63, 32)) >> 32;\n\tsc_desc.iepcount_set = ns % cycletime;\n\tsc_desc.CMP0_current = cycletime - 4; \n\n\tmemcpy_toio(sc_descp, &sc_desc, sizeof(sc_desc));\n\n\twriteb(1, &sc_descp->request);\n\n\ttimeout = 5;\t \n\twhile (timeout--) {\n\t\tif (readb(&sc_descp->acknowledgment))\n\t\t\treturn;\n\n\t\tusleep_range(500, 1000);\n\t}\n\n\tdev_err(emac->prueth->dev, \"settime timeout\\n\");\n}\n\nstatic int prueth_perout_enable(void *clockops_data,\n\t\t\t\tstruct ptp_perout_request *req, int on,\n\t\t\t\tu64 *cmp)\n{\n\tstruct prueth_emac *emac = clockops_data;\n\tu32 reduction_factor = 0, offset = 0;\n\tstruct timespec64 ts;\n\tu64 ns_period;\n\n\tif (!on)\n\t\treturn 0;\n\n\t \n\tts.tv_sec = req->period.sec;\n\tts.tv_nsec = req->period.nsec;\n\tns_period = timespec64_to_ns(&ts);\n\n\t \n\tif (ns_period < IEP_DEFAULT_CYCLE_TIME_NS)\n\t\treturn -ENXIO;\n\n\treduction_factor = ns_period / IEP_DEFAULT_CYCLE_TIME_NS;\n\toffset = ns_period % IEP_DEFAULT_CYCLE_TIME_NS;\n\n\t \n\tif (offset < 5 * NSEC_PER_USEC)\n\t\toffset = 5 * NSEC_PER_USEC;\n\n\t \n\tif (offset > IEP_DEFAULT_CYCLE_TIME_NS - 8)\n\t\toffset = IEP_DEFAULT_CYCLE_TIME_NS - 8;\n\n\t \n\t*cmp = (u64)offset << 32;\n\n\twritel(reduction_factor, emac->prueth->shram.va +\n\t\tTIMESYNC_FW_WC_SYNCOUT_REDUCTION_FACTOR_OFFSET);\n\n\twritel(0, emac->prueth->shram.va +\n\t\tTIMESYNC_FW_WC_SYNCOUT_START_TIME_CYCLECOUNT_OFFSET);\n\n\treturn 0;\n}\n\nconst struct icss_iep_clockops prueth_iep_clockops = {\n\t.settime = prueth_iep_settime,\n\t.gettime = prueth_iep_gettime,\n\t.perout_enable = prueth_perout_enable,\n};\n\n \nstatic int emac_ndo_open(struct net_device *ndev)\n{\n\tstruct prueth_emac *emac = netdev_priv(ndev);\n\tint ret, i, num_data_chn = emac->tx_ch_num;\n\tstruct prueth *prueth = emac->prueth;\n\tint slice = prueth_emac_slice(emac);\n\tstruct device *dev = prueth->dev;\n\tint max_rx_flows;\n\tint rx_flow;\n\n\t \n\tif (!prueth->emacs_initialized) {\n\t\tmemset_io(prueth->msmcram.va, 0, prueth->msmcram.size);\n\t\tmemset_io(prueth->shram.va, 0, ICSSG_CONFIG_OFFSET_SLICE1 * PRUETH_NUM_MACS);\n\t}\n\n\t \n\tether_addr_copy(emac->mac_addr, ndev->dev_addr);\n\n\ticssg_class_set_mac_addr(prueth->miig_rt, slice, emac->mac_addr);\n\ticssg_ft1_set_mac_addr(prueth->miig_rt, slice, emac->mac_addr);\n\n\ticssg_class_default(prueth->miig_rt, slice, 0);\n\n\t \n\tret = netif_set_real_num_tx_queues(ndev, num_data_chn);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot set real number of tx queues\\n\");\n\t\treturn ret;\n\t}\n\n\tinit_completion(&emac->cmd_complete);\n\tret = prueth_init_tx_chns(emac);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init tx channel: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmax_rx_flows = PRUETH_MAX_RX_FLOWS;\n\tret = prueth_init_rx_chns(emac, &emac->rx_chns, \"rx\",\n\t\t\t\t  max_rx_flows, PRUETH_MAX_RX_DESC);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init rx channel: %d\\n\", ret);\n\t\tgoto cleanup_tx;\n\t}\n\n\tret = prueth_ndev_add_tx_napi(emac);\n\tif (ret)\n\t\tgoto cleanup_rx;\n\n\t \n\trx_flow = PRUETH_RX_FLOW_DATA;\n\tret = request_irq(emac->rx_chns.irq[rx_flow], prueth_rx_irq,\n\t\t\t  IRQF_TRIGGER_HIGH, dev_name(dev), emac);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to request RX IRQ\\n\");\n\t\tgoto cleanup_napi;\n\t}\n\n\t \n\tret = prueth_emac_start(prueth, emac);\n\tif (ret)\n\t\tgoto free_rx_irq;\n\n\ticssg_mii_update_mtu(prueth->mii_rt, slice, ndev->max_mtu);\n\n\tif (!prueth->emacs_initialized) {\n\t\tret = icss_iep_init(emac->iep, &prueth_iep_clockops,\n\t\t\t\t    emac, IEP_DEFAULT_CYCLE_TIME_NS);\n\t}\n\n\tret = request_threaded_irq(emac->tx_ts_irq, NULL, prueth_tx_ts_irq,\n\t\t\t\t   IRQF_ONESHOT, dev_name(dev), emac);\n\tif (ret)\n\t\tgoto stop;\n\n\t \n\tret = prueth_prepare_rx_chan(emac, &emac->rx_chns, PRUETH_MAX_PKT_SIZE);\n\tif (ret)\n\t\tgoto free_tx_ts_irq;\n\n\tret = k3_udma_glue_enable_rx_chn(emac->rx_chns.rx_chn);\n\tif (ret)\n\t\tgoto reset_rx_chn;\n\n\tfor (i = 0; i < emac->tx_ch_num; i++) {\n\t\tret = k3_udma_glue_enable_tx_chn(emac->tx_chns[i].tx_chn);\n\t\tif (ret)\n\t\t\tgoto reset_tx_chan;\n\t}\n\n\t \n\tfor (i = 0; i < emac->tx_ch_num; i++)\n\t\tnapi_enable(&emac->tx_chns[i].napi_tx);\n\tnapi_enable(&emac->napi_rx);\n\n\t \n\tphy_start(ndev->phydev);\n\n\tprueth->emacs_initialized++;\n\n\tqueue_work(system_long_wq, &emac->stats_work.work);\n\n\treturn 0;\n\nreset_tx_chan:\n\t \n\tprueth_reset_tx_chan(emac, i, false);\nreset_rx_chn:\n\tprueth_reset_rx_chan(&emac->rx_chns, max_rx_flows, false);\nfree_tx_ts_irq:\n\tfree_irq(emac->tx_ts_irq, emac);\nstop:\n\tprueth_emac_stop(emac);\nfree_rx_irq:\n\tfree_irq(emac->rx_chns.irq[rx_flow], emac);\ncleanup_napi:\n\tprueth_ndev_del_tx_napi(emac, emac->tx_ch_num);\ncleanup_rx:\n\tprueth_cleanup_rx_chns(emac, &emac->rx_chns, max_rx_flows);\ncleanup_tx:\n\tprueth_cleanup_tx_chns(emac);\n\n\treturn ret;\n}\n\n \nstatic int emac_ndo_stop(struct net_device *ndev)\n{\n\tstruct prueth_emac *emac = netdev_priv(ndev);\n\tstruct prueth *prueth = emac->prueth;\n\tint rx_flow = PRUETH_RX_FLOW_DATA;\n\tint max_rx_flows;\n\tint ret, i;\n\n\t \n\tnetif_tx_stop_all_queues(ndev);\n\n\t \n\tif (ndev->phydev)\n\t\tphy_stop(ndev->phydev);\n\n\ticssg_class_disable(prueth->miig_rt, prueth_emac_slice(emac));\n\n\tatomic_set(&emac->tdown_cnt, emac->tx_ch_num);\n\t \n\tsmp_mb__after_atomic();\n\t \n\treinit_completion(&emac->tdown_complete);\n\tfor (i = 0; i < emac->tx_ch_num; i++)\n\t\tk3_udma_glue_tdown_tx_chn(emac->tx_chns[i].tx_chn, false);\n\n\tret = wait_for_completion_timeout(&emac->tdown_complete,\n\t\t\t\t\t  msecs_to_jiffies(1000));\n\tif (!ret)\n\t\tnetdev_err(ndev, \"tx teardown timeout\\n\");\n\n\tprueth_reset_tx_chan(emac, emac->tx_ch_num, true);\n\tfor (i = 0; i < emac->tx_ch_num; i++)\n\t\tnapi_disable(&emac->tx_chns[i].napi_tx);\n\n\tmax_rx_flows = PRUETH_MAX_RX_FLOWS;\n\tk3_udma_glue_tdown_rx_chn(emac->rx_chns.rx_chn, true);\n\n\tprueth_reset_rx_chan(&emac->rx_chns, max_rx_flows, true);\n\n\tnapi_disable(&emac->napi_rx);\n\n\tcancel_work_sync(&emac->rx_mode_work);\n\n\t \n\tcancel_delayed_work_sync(&emac->stats_work);\n\n\t \n\tprueth_emac_stop(emac);\n\n\tif (prueth->emacs_initialized == 1)\n\t\ticss_iep_exit(emac->iep);\n\n\t \n\tprueth_emac_stop(emac);\n\n\tfree_irq(emac->tx_ts_irq, emac);\n\n\tfree_irq(emac->rx_chns.irq[rx_flow], emac);\n\tprueth_ndev_del_tx_napi(emac, emac->tx_ch_num);\n\tprueth_cleanup_tx_chns(emac);\n\n\tprueth_cleanup_rx_chns(emac, &emac->rx_chns, max_rx_flows);\n\tprueth_cleanup_tx_chns(emac);\n\n\tprueth->emacs_initialized--;\n\n\treturn 0;\n}\n\nstatic void emac_ndo_tx_timeout(struct net_device *ndev, unsigned int txqueue)\n{\n\tndev->stats.tx_errors++;\n}\n\nstatic void emac_ndo_set_rx_mode_work(struct work_struct *work)\n{\n\tstruct prueth_emac *emac = container_of(work, struct prueth_emac, rx_mode_work);\n\tstruct net_device *ndev = emac->ndev;\n\tbool promisc, allmulti;\n\n\tif (!netif_running(ndev))\n\t\treturn;\n\n\tpromisc = ndev->flags & IFF_PROMISC;\n\tallmulti = ndev->flags & IFF_ALLMULTI;\n\temac_set_port_state(emac, ICSSG_EMAC_PORT_UC_FLOODING_DISABLE);\n\temac_set_port_state(emac, ICSSG_EMAC_PORT_MC_FLOODING_DISABLE);\n\n\tif (promisc) {\n\t\temac_set_port_state(emac, ICSSG_EMAC_PORT_UC_FLOODING_ENABLE);\n\t\temac_set_port_state(emac, ICSSG_EMAC_PORT_MC_FLOODING_ENABLE);\n\t\treturn;\n\t}\n\n\tif (allmulti) {\n\t\temac_set_port_state(emac, ICSSG_EMAC_PORT_MC_FLOODING_ENABLE);\n\t\treturn;\n\t}\n\n\tif (!netdev_mc_empty(ndev)) {\n\t\temac_set_port_state(emac, ICSSG_EMAC_PORT_MC_FLOODING_ENABLE);\n\t\treturn;\n\t}\n}\n\n \nstatic void emac_ndo_set_rx_mode(struct net_device *ndev)\n{\n\tstruct prueth_emac *emac = netdev_priv(ndev);\n\n\tqueue_work(emac->cmd_wq, &emac->rx_mode_work);\n}\n\nstatic int emac_set_ts_config(struct net_device *ndev, struct ifreq *ifr)\n{\n\tstruct prueth_emac *emac = netdev_priv(ndev);\n\tstruct hwtstamp_config config;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\tswitch (config.tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\temac->tx_ts_enabled = 0;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\temac->tx_ts_enabled = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\temac->rx_ts_enabled = 0;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_ALL:\n\tcase HWTSTAMP_FILTER_SOME:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\t\temac->rx_ts_enabled = 1;\n\t\tconfig.rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\n\t\t-EFAULT : 0;\n}\n\nstatic int emac_get_ts_config(struct net_device *ndev, struct ifreq *ifr)\n{\n\tstruct prueth_emac *emac = netdev_priv(ndev);\n\tstruct hwtstamp_config config;\n\n\tconfig.flags = 0;\n\tconfig.tx_type = emac->tx_ts_enabled ? HWTSTAMP_TX_ON : HWTSTAMP_TX_OFF;\n\tconfig.rx_filter = emac->rx_ts_enabled ? HWTSTAMP_FILTER_ALL : HWTSTAMP_FILTER_NONE;\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\n\t\t\t    -EFAULT : 0;\n}\n\nstatic int emac_ndo_ioctl(struct net_device *ndev, struct ifreq *ifr, int cmd)\n{\n\tswitch (cmd) {\n\tcase SIOCGHWTSTAMP:\n\t\treturn emac_get_ts_config(ndev, ifr);\n\tcase SIOCSHWTSTAMP:\n\t\treturn emac_set_ts_config(ndev, ifr);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn phy_do_ioctl(ndev, ifr, cmd);\n}\n\nstatic void emac_ndo_get_stats64(struct net_device *ndev,\n\t\t\t\t struct rtnl_link_stats64 *stats)\n{\n\tstruct prueth_emac *emac = netdev_priv(ndev);\n\n\temac_update_hardware_stats(emac);\n\n\tstats->rx_packets     = emac_get_stat_by_name(emac, \"rx_packets\");\n\tstats->rx_bytes       = emac_get_stat_by_name(emac, \"rx_bytes\");\n\tstats->tx_packets     = emac_get_stat_by_name(emac, \"tx_packets\");\n\tstats->tx_bytes       = emac_get_stat_by_name(emac, \"tx_bytes\");\n\tstats->rx_crc_errors  = emac_get_stat_by_name(emac, \"rx_crc_errors\");\n\tstats->rx_over_errors = emac_get_stat_by_name(emac, \"rx_over_errors\");\n\tstats->multicast      = emac_get_stat_by_name(emac, \"rx_multicast_frames\");\n\n\tstats->rx_errors  = ndev->stats.rx_errors;\n\tstats->rx_dropped = ndev->stats.rx_dropped;\n\tstats->tx_errors  = ndev->stats.tx_errors;\n\tstats->tx_dropped = ndev->stats.tx_dropped;\n}\n\nstatic const struct net_device_ops emac_netdev_ops = {\n\t.ndo_open = emac_ndo_open,\n\t.ndo_stop = emac_ndo_stop,\n\t.ndo_start_xmit = emac_ndo_start_xmit,\n\t.ndo_set_mac_address = eth_mac_addr,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_tx_timeout = emac_ndo_tx_timeout,\n\t.ndo_set_rx_mode = emac_ndo_set_rx_mode,\n\t.ndo_eth_ioctl = emac_ndo_ioctl,\n\t.ndo_get_stats64 = emac_ndo_get_stats64,\n};\n\n \nstatic int prueth_node_port(struct device_node *eth_node)\n{\n\tu32 port_id;\n\tint ret;\n\n\tret = of_property_read_u32(eth_node, \"reg\", &port_id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (port_id == 0)\n\t\treturn PRUETH_PORT_MII0;\n\telse if (port_id == 1)\n\t\treturn PRUETH_PORT_MII1;\n\telse\n\t\treturn PRUETH_PORT_INVALID;\n}\n\n \nstatic int prueth_node_mac(struct device_node *eth_node)\n{\n\tu32 port_id;\n\tint ret;\n\n\tret = of_property_read_u32(eth_node, \"reg\", &port_id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (port_id == 0)\n\t\treturn PRUETH_MAC0;\n\telse if (port_id == 1)\n\t\treturn PRUETH_MAC1;\n\telse\n\t\treturn PRUETH_MAC_INVALID;\n}\n\nstatic int prueth_netdev_init(struct prueth *prueth,\n\t\t\t      struct device_node *eth_node)\n{\n\tint ret, num_tx_chn = PRUETH_MAX_TX_QUEUES;\n\tstruct prueth_emac *emac;\n\tstruct net_device *ndev;\n\tenum prueth_port port;\n\tconst char *irq_name;\n\tenum prueth_mac mac;\n\n\tport = prueth_node_port(eth_node);\n\tif (port == PRUETH_PORT_INVALID)\n\t\treturn -EINVAL;\n\n\tmac = prueth_node_mac(eth_node);\n\tif (mac == PRUETH_MAC_INVALID)\n\t\treturn -EINVAL;\n\n\tndev = alloc_etherdev_mq(sizeof(*emac), num_tx_chn);\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\temac = netdev_priv(ndev);\n\temac->prueth = prueth;\n\temac->ndev = ndev;\n\temac->port_id = port;\n\temac->cmd_wq = create_singlethread_workqueue(\"icssg_cmd_wq\");\n\tif (!emac->cmd_wq) {\n\t\tret = -ENOMEM;\n\t\tgoto free_ndev;\n\t}\n\tINIT_WORK(&emac->rx_mode_work, emac_ndo_set_rx_mode_work);\n\n\tINIT_DELAYED_WORK(&emac->stats_work, emac_stats_work_handler);\n\n\tret = pruss_request_mem_region(prueth->pruss,\n\t\t\t\t       port == PRUETH_PORT_MII0 ?\n\t\t\t\t       PRUSS_MEM_DRAM0 : PRUSS_MEM_DRAM1,\n\t\t\t\t       &emac->dram);\n\tif (ret) {\n\t\tdev_err(prueth->dev, \"unable to get DRAM: %d\\n\", ret);\n\t\tret = -ENOMEM;\n\t\tgoto free_wq;\n\t}\n\n\temac->tx_ch_num = 1;\n\n\tirq_name = \"tx_ts0\";\n\tif (emac->port_id == PRUETH_PORT_MII1)\n\t\tirq_name = \"tx_ts1\";\n\temac->tx_ts_irq = platform_get_irq_byname_optional(prueth->pdev, irq_name);\n\tif (emac->tx_ts_irq < 0) {\n\t\tret = dev_err_probe(prueth->dev, emac->tx_ts_irq, \"could not get tx_ts_irq\\n\");\n\t\tgoto free;\n\t}\n\n\tSET_NETDEV_DEV(ndev, prueth->dev);\n\tspin_lock_init(&emac->lock);\n\tmutex_init(&emac->cmd_lock);\n\n\temac->phy_node = of_parse_phandle(eth_node, \"phy-handle\", 0);\n\tif (!emac->phy_node && !of_phy_is_fixed_link(eth_node)) {\n\t\tdev_err(prueth->dev, \"couldn't find phy-handle\\n\");\n\t\tret = -ENODEV;\n\t\tgoto free;\n\t} else if (of_phy_is_fixed_link(eth_node)) {\n\t\tret = of_phy_register_fixed_link(eth_node);\n\t\tif (ret) {\n\t\t\tret = dev_err_probe(prueth->dev, ret,\n\t\t\t\t\t    \"failed to register fixed-link phy\\n\");\n\t\t\tgoto free;\n\t\t}\n\n\t\temac->phy_node = eth_node;\n\t}\n\n\tret = of_get_phy_mode(eth_node, &emac->phy_if);\n\tif (ret) {\n\t\tdev_err(prueth->dev, \"could not get phy-mode property\\n\");\n\t\tgoto free;\n\t}\n\n\tif (emac->phy_if != PHY_INTERFACE_MODE_MII &&\n\t    !phy_interface_mode_is_rgmii(emac->phy_if)) {\n\t\tdev_err(prueth->dev, \"PHY mode unsupported %s\\n\", phy_modes(emac->phy_if));\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\t \n\tswitch (emac->phy_if) {\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\temac->phy_if = PHY_INTERFACE_MODE_RGMII_RXID;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\temac->phy_if = PHY_INTERFACE_MODE_RGMII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tdev_err(prueth->dev, \"RGMII mode without TX delay is not supported\");\n\t\tret = -EINVAL;\n\t\tgoto free;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tret = of_get_ethdev_address(eth_node, ndev);\n\tif (!is_valid_ether_addr(ndev->dev_addr)) {\n\t\teth_hw_addr_random(ndev);\n\t\tdev_warn(prueth->dev, \"port %d: using random MAC addr: %pM\\n\",\n\t\t\t port, ndev->dev_addr);\n\t}\n\tether_addr_copy(emac->mac_addr, ndev->dev_addr);\n\n\tndev->min_mtu = PRUETH_MIN_PKT_SIZE;\n\tndev->max_mtu = PRUETH_MAX_MTU;\n\tndev->netdev_ops = &emac_netdev_ops;\n\tndev->ethtool_ops = &icssg_ethtool_ops;\n\tndev->hw_features = NETIF_F_SG;\n\tndev->features = ndev->hw_features;\n\n\tnetif_napi_add(ndev, &emac->napi_rx, emac_napi_rx_poll);\n\tprueth->emac[mac] = emac;\n\n\treturn 0;\n\nfree:\n\tpruss_release_mem_region(prueth->pruss, &emac->dram);\nfree_wq:\n\tdestroy_workqueue(emac->cmd_wq);\nfree_ndev:\n\temac->ndev = NULL;\n\tprueth->emac[mac] = NULL;\n\tfree_netdev(ndev);\n\n\treturn ret;\n}\n\nstatic void prueth_netdev_exit(struct prueth *prueth,\n\t\t\t       struct device_node *eth_node)\n{\n\tstruct prueth_emac *emac;\n\tenum prueth_mac mac;\n\n\tmac = prueth_node_mac(eth_node);\n\tif (mac == PRUETH_MAC_INVALID)\n\t\treturn;\n\n\temac = prueth->emac[mac];\n\tif (!emac)\n\t\treturn;\n\n\tif (of_phy_is_fixed_link(emac->phy_node))\n\t\tof_phy_deregister_fixed_link(emac->phy_node);\n\n\tnetif_napi_del(&emac->napi_rx);\n\n\tpruss_release_mem_region(prueth->pruss, &emac->dram);\n\tdestroy_workqueue(emac->cmd_wq);\n\tfree_netdev(emac->ndev);\n\tprueth->emac[mac] = NULL;\n}\n\nstatic int prueth_get_cores(struct prueth *prueth, int slice)\n{\n\tstruct device *dev = prueth->dev;\n\tenum pruss_pru_id pruss_id;\n\tstruct device_node *np;\n\tint idx = -1, ret;\n\n\tnp = dev->of_node;\n\n\tswitch (slice) {\n\tcase ICSS_SLICE0:\n\t\tidx = 0;\n\t\tbreak;\n\tcase ICSS_SLICE1:\n\t\tidx = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tprueth->pru[slice] = pru_rproc_get(np, idx, &pruss_id);\n\tif (IS_ERR(prueth->pru[slice])) {\n\t\tret = PTR_ERR(prueth->pru[slice]);\n\t\tprueth->pru[slice] = NULL;\n\t\treturn dev_err_probe(dev, ret, \"unable to get PRU%d\\n\", slice);\n\t}\n\tprueth->pru_id[slice] = pruss_id;\n\n\tidx++;\n\tprueth->rtu[slice] = pru_rproc_get(np, idx, NULL);\n\tif (IS_ERR(prueth->rtu[slice])) {\n\t\tret = PTR_ERR(prueth->rtu[slice]);\n\t\tprueth->rtu[slice] = NULL;\n\t\treturn dev_err_probe(dev, ret, \"unable to get RTU%d\\n\", slice);\n\t}\n\n\tidx++;\n\tprueth->txpru[slice] = pru_rproc_get(np, idx, NULL);\n\tif (IS_ERR(prueth->txpru[slice])) {\n\t\tret = PTR_ERR(prueth->txpru[slice]);\n\t\tprueth->txpru[slice] = NULL;\n\t\treturn dev_err_probe(dev, ret, \"unable to get TX_PRU%d\\n\", slice);\n\t}\n\n\treturn 0;\n}\n\nstatic void prueth_put_cores(struct prueth *prueth, int slice)\n{\n\tif (prueth->txpru[slice])\n\t\tpru_rproc_put(prueth->txpru[slice]);\n\n\tif (prueth->rtu[slice])\n\t\tpru_rproc_put(prueth->rtu[slice]);\n\n\tif (prueth->pru[slice])\n\t\tpru_rproc_put(prueth->pru[slice]);\n}\n\nstatic const struct of_device_id prueth_dt_match[];\n\nstatic int prueth_probe(struct platform_device *pdev)\n{\n\tstruct device_node *eth_node, *eth_ports_node;\n\tstruct device_node  *eth0_node = NULL;\n\tstruct device_node  *eth1_node = NULL;\n\tstruct genpool_data_align gp_data = {\n\t\t.align = SZ_64K,\n\t};\n\tconst struct of_device_id *match;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np;\n\tstruct prueth *prueth;\n\tstruct pruss *pruss;\n\tu32 msmc_ram_size;\n\tint i, ret;\n\n\tnp = dev->of_node;\n\n\tmatch = of_match_device(prueth_dt_match, dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tprueth = devm_kzalloc(dev, sizeof(*prueth), GFP_KERNEL);\n\tif (!prueth)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, prueth);\n\tprueth->pdev = pdev;\n\tprueth->pdata = *(const struct prueth_pdata *)match->data;\n\n\tprueth->dev = dev;\n\teth_ports_node = of_get_child_by_name(np, \"ethernet-ports\");\n\tif (!eth_ports_node)\n\t\treturn -ENOENT;\n\n\tfor_each_child_of_node(eth_ports_node, eth_node) {\n\t\tu32 reg;\n\n\t\tif (strcmp(eth_node->name, \"port\"))\n\t\t\tcontinue;\n\t\tret = of_property_read_u32(eth_node, \"reg\", &reg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%pOF error reading port_id %d\\n\",\n\t\t\t\teth_node, ret);\n\t\t}\n\n\t\tof_node_get(eth_node);\n\n\t\tif (reg == 0) {\n\t\t\teth0_node = eth_node;\n\t\t\tif (!of_device_is_available(eth0_node)) {\n\t\t\t\tof_node_put(eth0_node);\n\t\t\t\teth0_node = NULL;\n\t\t\t}\n\t\t} else if (reg == 1) {\n\t\t\teth1_node = eth_node;\n\t\t\tif (!of_device_is_available(eth1_node)) {\n\t\t\t\tof_node_put(eth1_node);\n\t\t\t\teth1_node = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(dev, \"port reg should be 0 or 1\\n\");\n\t\t}\n\t}\n\n\tof_node_put(eth_ports_node);\n\n\t \n\tif (!eth0_node && !eth1_node) {\n\t\tdev_err(dev, \"neither port0 nor port1 node available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (eth0_node == eth1_node) {\n\t\tdev_err(dev, \"port0 and port1 can't have same reg\\n\");\n\t\tof_node_put(eth0_node);\n\t\treturn -ENODEV;\n\t}\n\n\tprueth->eth_node[PRUETH_MAC0] = eth0_node;\n\tprueth->eth_node[PRUETH_MAC1] = eth1_node;\n\n\tprueth->miig_rt = syscon_regmap_lookup_by_phandle(np, \"ti,mii-g-rt\");\n\tif (IS_ERR(prueth->miig_rt)) {\n\t\tdev_err(dev, \"couldn't get ti,mii-g-rt syscon regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tprueth->mii_rt = syscon_regmap_lookup_by_phandle(np, \"ti,mii-rt\");\n\tif (IS_ERR(prueth->mii_rt)) {\n\t\tdev_err(dev, \"couldn't get ti,mii-rt syscon regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (eth0_node) {\n\t\tret = prueth_get_cores(prueth, ICSS_SLICE0);\n\t\tif (ret)\n\t\t\tgoto put_cores;\n\t}\n\n\tif (eth1_node) {\n\t\tret = prueth_get_cores(prueth, ICSS_SLICE1);\n\t\tif (ret)\n\t\t\tgoto put_cores;\n\t}\n\n\tpruss = pruss_get(eth0_node ?\n\t\t\t  prueth->pru[ICSS_SLICE0] : prueth->pru[ICSS_SLICE1]);\n\tif (IS_ERR(pruss)) {\n\t\tret = PTR_ERR(pruss);\n\t\tdev_err(dev, \"unable to get pruss handle\\n\");\n\t\tgoto put_cores;\n\t}\n\n\tprueth->pruss = pruss;\n\n\tret = pruss_request_mem_region(pruss, PRUSS_MEM_SHRD_RAM2,\n\t\t\t\t       &prueth->shram);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to get PRUSS SHRD RAM2: %d\\n\", ret);\n\t\tgoto put_pruss;\n\t}\n\n\tprueth->sram_pool = of_gen_pool_get(np, \"sram\", 0);\n\tif (!prueth->sram_pool) {\n\t\tdev_err(dev, \"unable to get SRAM pool\\n\");\n\t\tret = -ENODEV;\n\n\t\tgoto put_mem;\n\t}\n\n\tmsmc_ram_size = MSMC_RAM_SIZE;\n\n\t \n\tprueth->msmcram.va =\n\t\t(void __iomem *)gen_pool_alloc_algo(prueth->sram_pool,\n\t\t\t\t\t\t    msmc_ram_size,\n\t\t\t\t\t\t    gen_pool_first_fit_align,\n\t\t\t\t\t\t    &gp_data);\n\n\tif (!prueth->msmcram.va) {\n\t\tret = -ENOMEM;\n\t\tdev_err(dev, \"unable to allocate MSMC resource\\n\");\n\t\tgoto put_mem;\n\t}\n\tprueth->msmcram.pa = gen_pool_virt_to_phys(prueth->sram_pool,\n\t\t\t\t\t\t   (unsigned long)prueth->msmcram.va);\n\tprueth->msmcram.size = msmc_ram_size;\n\tmemset_io(prueth->msmcram.va, 0, msmc_ram_size);\n\tdev_dbg(dev, \"sram: pa %llx va %p size %zx\\n\", prueth->msmcram.pa,\n\t\tprueth->msmcram.va, prueth->msmcram.size);\n\n\tprueth->iep0 = icss_iep_get_idx(np, 0);\n\tif (IS_ERR(prueth->iep0)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(prueth->iep0), \"iep0 get failed\\n\");\n\t\tprueth->iep0 = NULL;\n\t\tgoto free_pool;\n\t}\n\n\tprueth->iep1 = icss_iep_get_idx(np, 1);\n\tif (IS_ERR(prueth->iep1)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(prueth->iep1), \"iep1 get failed\\n\");\n\t\tgoto put_iep0;\n\t}\n\n\tif (prueth->pdata.quirk_10m_link_issue) {\n\t\t \n\t\ticss_iep_init_fw(prueth->iep1);\n\t}\n\n\t \n\tif (eth0_node) {\n\t\tret = prueth_netdev_init(prueth, eth0_node);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"netdev init %s failed\\n\",\n\t\t\t\t      eth0_node->name);\n\t\t\tgoto exit_iep;\n\t\t}\n\t\tprueth->emac[PRUETH_MAC0]->iep = prueth->iep0;\n\t}\n\n\tif (eth1_node) {\n\t\tret = prueth_netdev_init(prueth, eth1_node);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"netdev init %s failed\\n\",\n\t\t\t\t      eth1_node->name);\n\t\t\tgoto netdev_exit;\n\t\t}\n\n\t\tprueth->emac[PRUETH_MAC1]->iep = prueth->iep0;\n\t}\n\n\t \n\tif (eth0_node) {\n\t\tret = register_netdev(prueth->emac[PRUETH_MAC0]->ndev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"can't register netdev for port MII0\");\n\t\t\tgoto netdev_exit;\n\t\t}\n\n\t\tprueth->registered_netdevs[PRUETH_MAC0] = prueth->emac[PRUETH_MAC0]->ndev;\n\n\t\temac_phy_connect(prueth->emac[PRUETH_MAC0]);\n\t\tphy_attached_info(prueth->emac[PRUETH_MAC0]->ndev->phydev);\n\t}\n\n\tif (eth1_node) {\n\t\tret = register_netdev(prueth->emac[PRUETH_MAC1]->ndev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"can't register netdev for port MII1\");\n\t\t\tgoto netdev_unregister;\n\t\t}\n\n\t\tprueth->registered_netdevs[PRUETH_MAC1] = prueth->emac[PRUETH_MAC1]->ndev;\n\t\temac_phy_connect(prueth->emac[PRUETH_MAC1]);\n\t\tphy_attached_info(prueth->emac[PRUETH_MAC1]->ndev->phydev);\n\t}\n\n\tdev_info(dev, \"TI PRU ethernet driver initialized: %s EMAC mode\\n\",\n\t\t (!eth0_node || !eth1_node) ? \"single\" : \"dual\");\n\n\tif (eth1_node)\n\t\tof_node_put(eth1_node);\n\tif (eth0_node)\n\t\tof_node_put(eth0_node);\n\treturn 0;\n\nnetdev_unregister:\n\tfor (i = 0; i < PRUETH_NUM_MACS; i++) {\n\t\tif (!prueth->registered_netdevs[i])\n\t\t\tcontinue;\n\t\tif (prueth->emac[i]->ndev->phydev) {\n\t\t\tphy_disconnect(prueth->emac[i]->ndev->phydev);\n\t\t\tprueth->emac[i]->ndev->phydev = NULL;\n\t\t}\n\t\tunregister_netdev(prueth->registered_netdevs[i]);\n\t}\n\nnetdev_exit:\n\tfor (i = 0; i < PRUETH_NUM_MACS; i++) {\n\t\teth_node = prueth->eth_node[i];\n\t\tif (!eth_node)\n\t\t\tcontinue;\n\n\t\tprueth_netdev_exit(prueth, eth_node);\n\t}\n\nexit_iep:\n\tif (prueth->pdata.quirk_10m_link_issue)\n\t\ticss_iep_exit_fw(prueth->iep1);\n\ticss_iep_put(prueth->iep1);\n\nput_iep0:\n\ticss_iep_put(prueth->iep0);\n\tprueth->iep0 = NULL;\n\tprueth->iep1 = NULL;\n\nfree_pool:\n\tgen_pool_free(prueth->sram_pool,\n\t\t      (unsigned long)prueth->msmcram.va, msmc_ram_size);\n\nput_mem:\n\tpruss_release_mem_region(prueth->pruss, &prueth->shram);\n\nput_pruss:\n\tpruss_put(prueth->pruss);\n\nput_cores:\n\tif (eth1_node) {\n\t\tprueth_put_cores(prueth, ICSS_SLICE1);\n\t\tof_node_put(eth1_node);\n\t}\n\n\tif (eth0_node) {\n\t\tprueth_put_cores(prueth, ICSS_SLICE0);\n\t\tof_node_put(eth0_node);\n\t}\n\n\treturn ret;\n}\n\nstatic void prueth_remove(struct platform_device *pdev)\n{\n\tstruct prueth *prueth = platform_get_drvdata(pdev);\n\tstruct device_node *eth_node;\n\tint i;\n\n\tfor (i = 0; i < PRUETH_NUM_MACS; i++) {\n\t\tif (!prueth->registered_netdevs[i])\n\t\t\tcontinue;\n\t\tphy_stop(prueth->emac[i]->ndev->phydev);\n\t\tphy_disconnect(prueth->emac[i]->ndev->phydev);\n\t\tprueth->emac[i]->ndev->phydev = NULL;\n\t\tunregister_netdev(prueth->registered_netdevs[i]);\n\t}\n\n\tfor (i = 0; i < PRUETH_NUM_MACS; i++) {\n\t\teth_node = prueth->eth_node[i];\n\t\tif (!eth_node)\n\t\t\tcontinue;\n\n\t\tprueth_netdev_exit(prueth, eth_node);\n\t}\n\n\tif (prueth->pdata.quirk_10m_link_issue)\n\t\ticss_iep_exit_fw(prueth->iep1);\n\n\ticss_iep_put(prueth->iep1);\n\ticss_iep_put(prueth->iep0);\n\n\tgen_pool_free(prueth->sram_pool,\n\t\t      (unsigned long)prueth->msmcram.va,\n\t\t      MSMC_RAM_SIZE);\n\n\tpruss_release_mem_region(prueth->pruss, &prueth->shram);\n\n\tpruss_put(prueth->pruss);\n\n\tif (prueth->eth_node[PRUETH_MAC1])\n\t\tprueth_put_cores(prueth, ICSS_SLICE1);\n\n\tif (prueth->eth_node[PRUETH_MAC0])\n\t\tprueth_put_cores(prueth, ICSS_SLICE0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int prueth_suspend(struct device *dev)\n{\n\tstruct prueth *prueth = dev_get_drvdata(dev);\n\tstruct net_device *ndev;\n\tint i, ret;\n\n\tfor (i = 0; i < PRUETH_NUM_MACS; i++) {\n\t\tndev = prueth->registered_netdevs[i];\n\n\t\tif (!ndev)\n\t\t\tcontinue;\n\n\t\tif (netif_running(ndev)) {\n\t\t\tnetif_device_detach(ndev);\n\t\t\tret = emac_ndo_stop(ndev);\n\t\t\tif (ret < 0) {\n\t\t\t\tnetdev_err(ndev, \"failed to stop: %d\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int prueth_resume(struct device *dev)\n{\n\tstruct prueth *prueth = dev_get_drvdata(dev);\n\tstruct net_device *ndev;\n\tint i, ret;\n\n\tfor (i = 0; i < PRUETH_NUM_MACS; i++) {\n\t\tndev = prueth->registered_netdevs[i];\n\n\t\tif (!ndev)\n\t\t\tcontinue;\n\n\t\tif (netif_running(ndev)) {\n\t\t\tret = emac_ndo_open(ndev);\n\t\t\tif (ret < 0) {\n\t\t\t\tnetdev_err(ndev, \"failed to start: %d\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tnetif_device_attach(ndev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct dev_pm_ops prueth_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(prueth_suspend, prueth_resume)\n};\n\nstatic const struct prueth_pdata am654_icssg_pdata = {\n\t.fdqring_mode = K3_RINGACC_RING_MODE_MESSAGE,\n\t.quirk_10m_link_issue = 1,\n};\n\nstatic const struct of_device_id prueth_dt_match[] = {\n\t{ .compatible = \"ti,am654-icssg-prueth\", .data = &am654_icssg_pdata },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, prueth_dt_match);\n\nstatic struct platform_driver prueth_driver = {\n\t.probe = prueth_probe,\n\t.remove_new = prueth_remove,\n\t.driver = {\n\t\t.name = \"icssg-prueth\",\n\t\t.of_match_table = prueth_dt_match,\n\t\t.pm = &prueth_dev_pm_ops,\n\t},\n};\nmodule_platform_driver(prueth_driver);\n\nMODULE_AUTHOR(\"Roger Quadros <rogerq@ti.com>\");\nMODULE_AUTHOR(\"Md Danish Anwar <danishanwar@ti.com>\");\nMODULE_DESCRIPTION(\"PRUSS ICSSG Ethernet Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}