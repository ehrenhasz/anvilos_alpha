{
  "module_name": "icssg_classifier.c",
  "hash_id": "6ac7b72f31c1627c40f548ad713878647a585c25772d3bb641c416f590945729",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/icssg/icssg_classifier.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/types.h>\n#include <linux/regmap.h>\n\n#include \"icssg_prueth.h\"\n\n#define ICSSG_NUM_CLASSIFIERS\t16\n#define ICSSG_NUM_FT1_SLOTS\t8\n#define ICSSG_NUM_FT3_SLOTS\t16\n\n#define ICSSG_NUM_CLASSIFIERS_IN_USE\t5\n\n \n#define FT1_NUM_SLOTS\t8\n#define FT1_SLOT_SIZE\t0x10\t \n\n \n#define FT1_DA0\t\t0x0\n#define FT1_DA1\t\t0x4\n#define FT1_DA0_MASK\t0x8\n#define FT1_DA1_MASK\t0xc\n\n#define FT1_N_REG(slize, n, reg)\t\\\n\t(offs[slice].ft1_slot_base + FT1_SLOT_SIZE * (n) + (reg))\n\n#define FT1_LEN_MASK\t\tGENMASK(19, 16)\n#define FT1_LEN_SHIFT\t\t16\n#define FT1_LEN(len)\t\t(((len) << FT1_LEN_SHIFT) & FT1_LEN_MASK)\n#define FT1_START_MASK\t\tGENMASK(14, 0)\n#define FT1_START(start)\t((start) & FT1_START_MASK)\n#define FT1_MATCH_SLOT(n)\t(GENMASK(23, 16) & (BIT(n) << 16))\n\n \nenum ft1_cfg_type {\n\tFT1_CFG_TYPE_DISABLED = 0,\n\tFT1_CFG_TYPE_EQ,\n\tFT1_CFG_TYPE_GT,\n\tFT1_CFG_TYPE_LT,\n};\n\n#define FT1_CFG_SHIFT(n)\t(2 * (n))\n#define FT1_CFG_MASK(n)\t\t(0x3 << FT1_CFG_SHIFT((n)))\n\n \n#define FT3_NUM_SLOTS\t16\n#define FT3_SLOT_SIZE\t0x20\t \n\n \n#define FT3_START\t\t0\n#define FT3_START_AUTO\t\t0x4\n#define FT3_START_OFFSET\t0x8\n#define FT3_JUMP_OFFSET\t\t0xc\n#define FT3_LEN\t\t\t0x10\n#define FT3_CFG\t\t\t0x14\n#define FT3_T\t\t\t0x18\n#define FT3_T_MASK\t\t0x1c\n\n#define FT3_N_REG(slize, n, reg)\t\\\n\t(offs[slice].ft3_slot_base + FT3_SLOT_SIZE * (n) + (reg))\n\n \n#define RX_CLASS_AND_EN\t\t0\n#define RX_CLASS_OR_EN\t\t0x4\n#define RX_CLASS_NUM_SLOTS\t16\n#define RX_CLASS_EN_SIZE\t0x8\t \n\n#define RX_CLASS_N_REG(slice, n, reg)\t\\\n\t(offs[slice].rx_class_base + RX_CLASS_EN_SIZE * (n) + (reg))\n\n \n#define RX_CLASS_GATES_SIZE\t0x4\t \n\n#define RX_CLASS_GATES_N_REG(slice, n)\t\\\n\t(offs[slice].rx_class_gates_base + RX_CLASS_GATES_SIZE * (n))\n\n#define RX_CLASS_GATES_ALLOW_MASK\tBIT(6)\n#define RX_CLASS_GATES_RAW_MASK\t\tBIT(5)\n#define RX_CLASS_GATES_PHASE_MASK\tBIT(4)\n\n \n#define RX_CLASS_FT_UC\t\t\t\tBIT(31)\n#define RX_CLASS_FT_MC\t\t\tBIT(30)\n#define RX_CLASS_FT_BC\t\t\tBIT(29)\n#define RX_CLASS_FT_FW\t\t\tBIT(28)\n#define RX_CLASS_FT_RCV\t\t\tBIT(27)\n#define RX_CLASS_FT_VLAN\t\tBIT(26)\n#define RX_CLASS_FT_DA_P\t\tBIT(25)\n#define RX_CLASS_FT_DA_I\t\tBIT(24)\n#define RX_CLASS_FT_FT1_MATCH_MASK\tGENMASK(23, 16)\n#define RX_CLASS_FT_FT1_MATCH_SHIFT\t16\n#define RX_CLASS_FT_FT3_MATCH_MASK\tGENMASK(15, 0)\n#define RX_CLASS_FT_FT3_MATCH_SHIFT\t0\n\n#define RX_CLASS_FT_FT1_MATCH(slot)\t\\\n\t((BIT(slot) << RX_CLASS_FT_FT1_MATCH_SHIFT) & \\\n\tRX_CLASS_FT_FT1_MATCH_MASK)\n\n \nenum rx_class_sel_type {\n\tRX_CLASS_SEL_TYPE_OR = 0,\n\tRX_CLASS_SEL_TYPE_AND = 1,\n\tRX_CLASS_SEL_TYPE_OR_AND_AND = 2,\n\tRX_CLASS_SEL_TYPE_OR_OR_AND = 3,\n};\n\n#define FT1_CFG_SHIFT(n)\t(2 * (n))\n#define FT1_CFG_MASK(n)\t\t(0x3 << FT1_CFG_SHIFT((n)))\n\n#define RX_CLASS_SEL_SHIFT(n)\t(2 * (n))\n#define RX_CLASS_SEL_MASK(n)\t(0x3 << RX_CLASS_SEL_SHIFT((n)))\n\n#define ICSSG_CFG_OFFSET\t0\n#define MAC_INTERFACE_0\t\t0x18\n#define MAC_INTERFACE_1\t\t0x1c\n\n#define ICSSG_CFG_RX_L2_G_EN\tBIT(2)\n\n \nstruct miig_rt_offsets {\n\tu32 mac0;\n\tu32 mac1;\n\tu32 ft1_start_len;\n\tu32 ft1_cfg;\n\tu32 ft1_slot_base;\n\tu32 ft3_slot_base;\n\tu32 ft3_p_base;\n\tu32 ft_rx_ptr;\n\tu32 rx_class_base;\n\tu32 rx_class_cfg1;\n\tu32 rx_class_cfg2;\n\tu32 rx_class_gates_base;\n\tu32 rx_green;\n\tu32 rx_rate_cfg_base;\n\tu32 rx_rate_src_sel0;\n\tu32 rx_rate_src_sel1;\n\tu32 tx_rate_cfg_base;\n\tu32 stat_base;\n\tu32 tx_hsr_tag;\n\tu32 tx_hsr_seq;\n\tu32 tx_vlan_type;\n\tu32 tx_vlan_ins;\n};\n\n \nstatic const struct miig_rt_offsets offs[] = {\n\t \n\t{\n\t\t0x8,\n\t\t0xc,\n\t\t0x80,\n\t\t0x84,\n\t\t0x88,\n\t\t0x108,\n\t\t0x308,\n\t\t0x408,\n\t\t0x40c,\n\t\t0x48c,\n\t\t0x490,\n\t\t0x494,\n\t\t0x4d4,\n\t\t0x4e4,\n\t\t0x504,\n\t\t0x508,\n\t\t0x50c,\n\t\t0x54c,\n\t\t0x63c,\n\t\t0x640,\n\t\t0x644,\n\t\t0x648,\n\t},\n\t \n\t{\n\t\t0x10,\n\t\t0x14,\n\t\t0x64c,\n\t\t0x650,\n\t\t0x654,\n\t\t0x6d4,\n\t\t0x8d4,\n\t\t0x9d4,\n\t\t0x9d8,\n\t\t0xa58,\n\t\t0xa5c,\n\t\t0xa60,\n\t\t0xaa0,\n\t\t0xab0,\n\t\t0xad0,\n\t\t0xad4,\n\t\t0xad8,\n\t\t0xb18,\n\t\t0xc08,\n\t\t0xc0c,\n\t\t0xc10,\n\t\t0xc14,\n\t},\n};\n\nstatic void rx_class_ft1_set_start_len(struct regmap *miig_rt, int slice,\n\t\t\t\t       u16 start, u8 len)\n{\n\tu32 offset, val;\n\n\toffset = offs[slice].ft1_start_len;\n\tval = FT1_LEN(len) | FT1_START(start);\n\tregmap_write(miig_rt, offset, val);\n}\n\nstatic void rx_class_ft1_set_da(struct regmap *miig_rt, int slice,\n\t\t\t\tint n, const u8 *addr)\n{\n\tu32 offset;\n\n\toffset = FT1_N_REG(slice, n, FT1_DA0);\n\tregmap_write(miig_rt, offset, (u32)(addr[0] | addr[1] << 8 |\n\t\t     addr[2] << 16 | addr[3] << 24));\n\toffset = FT1_N_REG(slice, n, FT1_DA1);\n\tregmap_write(miig_rt, offset, (u32)(addr[4] | addr[5] << 8));\n}\n\nstatic void rx_class_ft1_set_da_mask(struct regmap *miig_rt, int slice,\n\t\t\t\t     int n, const u8 *addr)\n{\n\tu32 offset;\n\n\toffset = FT1_N_REG(slice, n, FT1_DA0_MASK);\n\tregmap_write(miig_rt, offset, (u32)(addr[0] | addr[1] << 8 |\n\t\t     addr[2] << 16 | addr[3] << 24));\n\toffset = FT1_N_REG(slice, n, FT1_DA1_MASK);\n\tregmap_write(miig_rt, offset, (u32)(addr[4] | addr[5] << 8));\n}\n\nstatic void rx_class_ft1_cfg_set_type(struct regmap *miig_rt, int slice, int n,\n\t\t\t\t      enum ft1_cfg_type type)\n{\n\tu32 offset;\n\n\toffset = offs[slice].ft1_cfg;\n\tregmap_update_bits(miig_rt, offset, FT1_CFG_MASK(n),\n\t\t\t   type << FT1_CFG_SHIFT(n));\n}\n\nstatic void rx_class_sel_set_type(struct regmap *miig_rt, int slice, int n,\n\t\t\t\t  enum rx_class_sel_type type)\n{\n\tu32 offset;\n\n\toffset = offs[slice].rx_class_cfg1;\n\tregmap_update_bits(miig_rt, offset, RX_CLASS_SEL_MASK(n),\n\t\t\t   type << RX_CLASS_SEL_SHIFT(n));\n}\n\nstatic void rx_class_set_and(struct regmap *miig_rt, int slice, int n,\n\t\t\t     u32 data)\n{\n\tu32 offset;\n\n\toffset = RX_CLASS_N_REG(slice, n, RX_CLASS_AND_EN);\n\tregmap_write(miig_rt, offset, data);\n}\n\nstatic void rx_class_set_or(struct regmap *miig_rt, int slice, int n,\n\t\t\t    u32 data)\n{\n\tu32 offset;\n\n\toffset = RX_CLASS_N_REG(slice, n, RX_CLASS_OR_EN);\n\tregmap_write(miig_rt, offset, data);\n}\n\nvoid icssg_class_set_host_mac_addr(struct regmap *miig_rt, const u8 *mac)\n{\n\tregmap_write(miig_rt, MAC_INTERFACE_0, (u32)(mac[0] | mac[1] << 8 |\n\t\t     mac[2] << 16 | mac[3] << 24));\n\tregmap_write(miig_rt, MAC_INTERFACE_1, (u32)(mac[4] | mac[5] << 8));\n}\n\nvoid icssg_class_set_mac_addr(struct regmap *miig_rt, int slice, u8 *mac)\n{\n\tregmap_write(miig_rt, offs[slice].mac0, (u32)(mac[0] | mac[1] << 8 |\n\t\t     mac[2] << 16 | mac[3] << 24));\n\tregmap_write(miig_rt, offs[slice].mac1, (u32)(mac[4] | mac[5] << 8));\n}\n\n \nvoid icssg_class_disable(struct regmap *miig_rt, int slice)\n{\n\tu32 data, offset;\n\tint n;\n\n\t \n\tregmap_update_bits(miig_rt, ICSSG_CFG_OFFSET, ICSSG_CFG_RX_L2_G_EN,\n\t\t\t   ICSSG_CFG_RX_L2_G_EN);\n\n\tfor (n = 0; n < ICSSG_NUM_CLASSIFIERS; n++) {\n\t\t \n\t\trx_class_set_and(miig_rt, slice, n, 0);\n\t\t \n\t\trx_class_set_or(miig_rt, slice, n, 0);\n\n\t\t \n\t\trx_class_sel_set_type(miig_rt, slice, n, RX_CLASS_SEL_TYPE_OR);\n\n\t\t \n\t\toffset = RX_CLASS_GATES_N_REG(slice, n);\n\t\tregmap_read(miig_rt, offset, &data);\n\t\t \n\t\tdata &= ~RX_CLASS_GATES_RAW_MASK;\n\t\t \n\t\tdata |= RX_CLASS_GATES_ALLOW_MASK | RX_CLASS_GATES_PHASE_MASK;\n\t\tregmap_write(miig_rt, offset, data);\n\t}\n\n\t \n\tfor (n = 0; n < ICSSG_NUM_FT1_SLOTS; n++) {\n\t\tconst u8 addr[] = { 0, 0, 0, 0, 0, 0, };\n\n\t\trx_class_ft1_cfg_set_type(miig_rt, slice, n,\n\t\t\t\t\t  FT1_CFG_TYPE_DISABLED);\n\t\trx_class_ft1_set_da(miig_rt, slice, n, addr);\n\t\trx_class_ft1_set_da_mask(miig_rt, slice, n, addr);\n\t}\n\n\t \n\tregmap_write(miig_rt, offs[slice].rx_class_cfg2, 0);\n}\n\nvoid icssg_class_default(struct regmap *miig_rt, int slice, bool allmulti)\n{\n\tu32 data;\n\n\t \n\ticssg_class_disable(miig_rt, slice);\n\n\t \n\t \n\tdata = RX_CLASS_FT_BC | RX_CLASS_FT_DA_P;\n\n\t \n\tif (allmulti)\n\t\tdata |= RX_CLASS_FT_MC;\n\n\trx_class_set_or(miig_rt, slice, 0, data);\n\n\t \n\trx_class_sel_set_type(miig_rt, slice, 0, RX_CLASS_SEL_TYPE_OR_OR_AND);\n\n\t \n\tregmap_write(miig_rt, offs[slice].rx_class_cfg2, 0);\n}\n\n \nvoid icssg_ft1_set_mac_addr(struct regmap *miig_rt, int slice, u8 *mac_addr)\n{\n\tconst u8 mask_addr[] = { 0, 0, 0, 0, 0, 0, };\n\n\trx_class_ft1_set_start_len(miig_rt, slice, 0, 6);\n\trx_class_ft1_set_da(miig_rt, slice, 0, mac_addr);\n\trx_class_ft1_set_da_mask(miig_rt, slice, 0, mask_addr);\n\trx_class_ft1_cfg_set_type(miig_rt, slice, 0, FT1_CFG_TYPE_EQ);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}