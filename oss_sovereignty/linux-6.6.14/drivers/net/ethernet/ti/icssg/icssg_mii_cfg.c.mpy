{
  "module_name": "icssg_mii_cfg.c",
  "hash_id": "4315aea92575622a18a5835ea92343da5f62bbedcaf79c3e7e2542b918eff701",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/icssg/icssg_mii_cfg.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\n#include \"icssg_mii_rt.h\"\n#include \"icssg_prueth.h\"\n\nvoid icssg_mii_update_ipg(struct regmap *mii_rt, int mii, u32 ipg)\n{\n\tu32 val;\n\n\tif (mii == ICSS_MII0) {\n\t\tregmap_write(mii_rt, PRUSS_MII_RT_TX_IPG0, ipg);\n\t} else {\n\t\tregmap_read(mii_rt, PRUSS_MII_RT_TX_IPG0, &val);\n\t\tregmap_write(mii_rt, PRUSS_MII_RT_TX_IPG1, ipg);\n\t\tregmap_write(mii_rt, PRUSS_MII_RT_TX_IPG0, val);\n\t}\n}\n\nvoid icssg_mii_update_mtu(struct regmap *mii_rt, int mii, int mtu)\n{\n\tmtu += (ETH_HLEN + ETH_FCS_LEN);\n\tif (mii == ICSS_MII0) {\n\t\tregmap_update_bits(mii_rt,\n\t\t\t\t   PRUSS_MII_RT_RX_FRMS0,\n\t\t\t\t   PRUSS_MII_RT_RX_FRMS_MAX_FRM_MASK,\n\t\t\t\t   (mtu - 1) << PRUSS_MII_RT_RX_FRMS_MAX_FRM_SHIFT);\n\t} else {\n\t\tregmap_update_bits(mii_rt,\n\t\t\t\t   PRUSS_MII_RT_RX_FRMS1,\n\t\t\t\t   PRUSS_MII_RT_RX_FRMS_MAX_FRM_MASK,\n\t\t\t\t   (mtu - 1) << PRUSS_MII_RT_RX_FRMS_MAX_FRM_SHIFT);\n\t}\n}\n\nvoid icssg_update_rgmii_cfg(struct regmap *miig_rt, struct prueth_emac *emac)\n{\n\tu32 gig_en_mask, gig_val = 0, full_duplex_mask, full_duplex_val = 0;\n\tint slice = prueth_emac_slice(emac);\n\tu32 inband_en_mask, inband_val = 0;\n\n\tgig_en_mask = (slice == ICSS_MII0) ? RGMII_CFG_GIG_EN_MII0 :\n\t\t\t\t\tRGMII_CFG_GIG_EN_MII1;\n\tif (emac->speed == SPEED_1000)\n\t\tgig_val = gig_en_mask;\n\tregmap_update_bits(miig_rt, RGMII_CFG_OFFSET, gig_en_mask, gig_val);\n\n\tinband_en_mask = (slice == ICSS_MII0) ? RGMII_CFG_INBAND_EN_MII0 :\n\t\t\t\t\tRGMII_CFG_INBAND_EN_MII1;\n\tif (emac->speed == SPEED_10 && phy_interface_mode_is_rgmii(emac->phy_if))\n\t\tinband_val = inband_en_mask;\n\tregmap_update_bits(miig_rt, RGMII_CFG_OFFSET, inband_en_mask, inband_val);\n\n\tfull_duplex_mask = (slice == ICSS_MII0) ? RGMII_CFG_FULL_DUPLEX_MII0 :\n\t\t\t\t\t   RGMII_CFG_FULL_DUPLEX_MII1;\n\tif (emac->duplex == DUPLEX_FULL)\n\t\tfull_duplex_val = full_duplex_mask;\n\tregmap_update_bits(miig_rt, RGMII_CFG_OFFSET, full_duplex_mask,\n\t\t\t   full_duplex_val);\n}\n\nvoid icssg_miig_set_interface_mode(struct regmap *miig_rt, int mii, phy_interface_t phy_if)\n{\n\tu32 val, mask, shift;\n\n\tmask = mii == ICSS_MII0 ? ICSSG_CFG_MII0_MODE : ICSSG_CFG_MII1_MODE;\n\tshift =  mii == ICSS_MII0 ? ICSSG_CFG_MII0_MODE_SHIFT : ICSSG_CFG_MII1_MODE_SHIFT;\n\n\tval = MII_MODE_RGMII;\n\tif (phy_if == PHY_INTERFACE_MODE_MII)\n\t\tval = MII_MODE_MII;\n\n\tval <<= shift;\n\tregmap_update_bits(miig_rt, ICSSG_CFG_OFFSET, mask, val);\n\tregmap_read(miig_rt, ICSSG_CFG_OFFSET, &val);\n}\n\nu32 icssg_rgmii_cfg_get_bitfield(struct regmap *miig_rt, u32 mask, u32 shift)\n{\n\tu32 val;\n\n\tregmap_read(miig_rt, RGMII_CFG_OFFSET, &val);\n\tval &= mask;\n\tval >>= shift;\n\n\treturn val;\n}\n\nu32 icssg_rgmii_get_speed(struct regmap *miig_rt, int mii)\n{\n\tu32 shift = RGMII_CFG_SPEED_MII0_SHIFT, mask = RGMII_CFG_SPEED_MII0;\n\n\tif (mii == ICSS_MII1) {\n\t\tshift = RGMII_CFG_SPEED_MII1_SHIFT;\n\t\tmask = RGMII_CFG_SPEED_MII1;\n\t}\n\n\treturn icssg_rgmii_cfg_get_bitfield(miig_rt, mask, shift);\n}\n\nu32 icssg_rgmii_get_fullduplex(struct regmap *miig_rt, int mii)\n{\n\tu32 shift = RGMII_CFG_FULLDUPLEX_MII0_SHIFT;\n\tu32 mask = RGMII_CFG_FULLDUPLEX_MII0;\n\n\tif (mii == ICSS_MII1) {\n\t\tshift = RGMII_CFG_FULLDUPLEX_MII1_SHIFT;\n\t\tmask = RGMII_CFG_FULLDUPLEX_MII1;\n\t}\n\n\treturn icssg_rgmii_cfg_get_bitfield(miig_rt, mask, shift);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}