{
  "module_name": "icss_iep.c",
  "hash_id": "44c61226fe9035fad9229fe306ef1f469dae678f985e2fbd62b8b8857a5cfdd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/icssg/icss_iep.c",
  "human_readable_source": "\n\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/timekeeping.h>\n#include <linux/interrupt.h>\n#include <linux/of_irq.h>\n\n#include \"icss_iep.h\"\n\n#define IEP_MAX_DEF_INC\t\t0xf\n#define IEP_MAX_COMPEN_INC\t\t0xfff\n#define IEP_MAX_COMPEN_COUNT\t0xffffff\n\n#define IEP_GLOBAL_CFG_CNT_ENABLE\tBIT(0)\n#define IEP_GLOBAL_CFG_DEFAULT_INC_MASK\t\tGENMASK(7, 4)\n#define IEP_GLOBAL_CFG_DEFAULT_INC_SHIFT\t4\n#define IEP_GLOBAL_CFG_COMPEN_INC_MASK\t\tGENMASK(19, 8)\n#define IEP_GLOBAL_CFG_COMPEN_INC_SHIFT\t\t8\n\n#define IEP_GLOBAL_STATUS_CNT_OVF\tBIT(0)\n\n#define IEP_CMP_CFG_SHADOW_EN\t\tBIT(17)\n#define IEP_CMP_CFG_CMP0_RST_CNT_EN\tBIT(0)\n#define IEP_CMP_CFG_CMP_EN(cmp)\t\t(GENMASK(16, 1) & (1 << ((cmp) + 1)))\n\n#define IEP_CMP_STATUS(cmp)\t\t(1 << (cmp))\n\n#define IEP_SYNC_CTRL_SYNC_EN\t\tBIT(0)\n#define IEP_SYNC_CTRL_SYNC_N_EN(n)\t(GENMASK(2, 1) & (BIT(1) << (n)))\n\n#define IEP_MIN_CMP\t0\n#define IEP_MAX_CMP\t15\n\n#define ICSS_IEP_64BIT_COUNTER_SUPPORT\t\tBIT(0)\n#define ICSS_IEP_SLOW_COMPEN_REG_SUPPORT\tBIT(1)\n#define ICSS_IEP_SHADOW_MODE_SUPPORT\t\tBIT(2)\n\n#define LATCH_INDEX(ts_index)\t\t\t((ts_index) + 6)\n#define IEP_CAP_CFG_CAPNR_1ST_EVENT_EN(n)\tBIT(LATCH_INDEX(n))\n#define IEP_CAP_CFG_CAP_ASYNC_EN(n)\t\tBIT(LATCH_INDEX(n) + 10)\n\nenum {\n\tICSS_IEP_GLOBAL_CFG_REG,\n\tICSS_IEP_GLOBAL_STATUS_REG,\n\tICSS_IEP_COMPEN_REG,\n\tICSS_IEP_SLOW_COMPEN_REG,\n\tICSS_IEP_COUNT_REG0,\n\tICSS_IEP_COUNT_REG1,\n\tICSS_IEP_CAPTURE_CFG_REG,\n\tICSS_IEP_CAPTURE_STAT_REG,\n\n\tICSS_IEP_CAP6_RISE_REG0,\n\tICSS_IEP_CAP6_RISE_REG1,\n\n\tICSS_IEP_CAP7_RISE_REG0,\n\tICSS_IEP_CAP7_RISE_REG1,\n\n\tICSS_IEP_CMP_CFG_REG,\n\tICSS_IEP_CMP_STAT_REG,\n\tICSS_IEP_CMP0_REG0,\n\tICSS_IEP_CMP0_REG1,\n\tICSS_IEP_CMP1_REG0,\n\tICSS_IEP_CMP1_REG1,\n\n\tICSS_IEP_CMP8_REG0,\n\tICSS_IEP_CMP8_REG1,\n\tICSS_IEP_SYNC_CTRL_REG,\n\tICSS_IEP_SYNC0_STAT_REG,\n\tICSS_IEP_SYNC1_STAT_REG,\n\tICSS_IEP_SYNC_PWIDTH_REG,\n\tICSS_IEP_SYNC0_PERIOD_REG,\n\tICSS_IEP_SYNC1_DELAY_REG,\n\tICSS_IEP_SYNC_START_REG,\n\tICSS_IEP_MAX_REGS,\n};\n\n \nstruct icss_iep_plat_data {\n\tstruct regmap_config *config;\n\tu32 reg_offs[ICSS_IEP_MAX_REGS];\n\tu32 flags;\n};\n\nstruct icss_iep {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tconst struct icss_iep_plat_data *plat_data;\n\tstruct regmap *map;\n\tstruct device_node *client_np;\n\tunsigned long refclk_freq;\n\tint clk_tick_time;\t \n\tstruct ptp_clock_info ptp_info;\n\tstruct ptp_clock *ptp_clock;\n\tstruct mutex ptp_clk_mutex;\t \n\tspinlock_t irq_lock;  \n\tu32 def_inc;\n\ts16 slow_cmp_inc;\n\tu32 slow_cmp_count;\n\tconst struct icss_iep_clockops *ops;\n\tvoid *clockops_data;\n\tu32 cycle_time_ns;\n\tu32 perout_enabled;\n\tbool pps_enabled;\n\tint cap_cmp_irq;\n\tu64 period;\n\tu32 latch_enable;\n};\n\n \nint icss_iep_get_count_hi(struct icss_iep *iep)\n{\n\tu32 val = 0;\n\n\tif (iep && (iep->plat_data->flags & ICSS_IEP_64BIT_COUNTER_SUPPORT))\n\t\tval = readl(iep->base + iep->plat_data->reg_offs[ICSS_IEP_COUNT_REG1]);\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(icss_iep_get_count_hi);\n\n \nint icss_iep_get_count_low(struct icss_iep *iep)\n{\n\tu32 val = 0;\n\n\tif (iep)\n\t\tval = readl(iep->base + iep->plat_data->reg_offs[ICSS_IEP_COUNT_REG0]);\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(icss_iep_get_count_low);\n\n \nint icss_iep_get_ptp_clock_idx(struct icss_iep *iep)\n{\n\tif (!iep || !iep->ptp_clock)\n\t\treturn -1;\n\treturn ptp_clock_index(iep->ptp_clock);\n}\nEXPORT_SYMBOL_GPL(icss_iep_get_ptp_clock_idx);\n\nstatic void icss_iep_set_counter(struct icss_iep *iep, u64 ns)\n{\n\tif (iep->plat_data->flags & ICSS_IEP_64BIT_COUNTER_SUPPORT)\n\t\twritel(upper_32_bits(ns), iep->base +\n\t\t       iep->plat_data->reg_offs[ICSS_IEP_COUNT_REG1]);\n\twritel(lower_32_bits(ns), iep->base + iep->plat_data->reg_offs[ICSS_IEP_COUNT_REG0]);\n}\n\nstatic void icss_iep_update_to_next_boundary(struct icss_iep *iep, u64 start_ns);\n\n \nstatic void icss_iep_settime(struct icss_iep *iep, u64 ns)\n{\n\tunsigned long flags;\n\n\tif (iep->ops && iep->ops->settime) {\n\t\tiep->ops->settime(iep->clockops_data, ns);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&iep->irq_lock, flags);\n\tif (iep->pps_enabled || iep->perout_enabled)\n\t\twritel(0, iep->base + iep->plat_data->reg_offs[ICSS_IEP_SYNC_CTRL_REG]);\n\n\ticss_iep_set_counter(iep, ns);\n\n\tif (iep->pps_enabled || iep->perout_enabled) {\n\t\ticss_iep_update_to_next_boundary(iep, ns);\n\t\twritel(IEP_SYNC_CTRL_SYNC_N_EN(0) | IEP_SYNC_CTRL_SYNC_EN,\n\t\t       iep->base + iep->plat_data->reg_offs[ICSS_IEP_SYNC_CTRL_REG]);\n\t}\n\tspin_unlock_irqrestore(&iep->irq_lock, flags);\n}\n\n \nstatic u64 icss_iep_gettime(struct icss_iep *iep,\n\t\t\t    struct ptp_system_timestamp *sts)\n{\n\tu32 ts_hi = 0, ts_lo;\n\tunsigned long flags;\n\n\tif (iep->ops && iep->ops->gettime)\n\t\treturn iep->ops->gettime(iep->clockops_data, sts);\n\n\t \n\tlocal_irq_save(flags);\n\n\t \n\tptp_read_system_prets(sts);\n\tts_lo = readl(iep->base + iep->plat_data->reg_offs[ICSS_IEP_COUNT_REG0]);\n\tptp_read_system_postts(sts);\n\tif (iep->plat_data->flags & ICSS_IEP_64BIT_COUNTER_SUPPORT)\n\t\tts_hi = readl(iep->base + iep->plat_data->reg_offs[ICSS_IEP_COUNT_REG1]);\n\n\tlocal_irq_restore(flags);\n\n\treturn (u64)ts_lo | (u64)ts_hi << 32;\n}\n\nstatic void icss_iep_enable(struct icss_iep *iep)\n{\n\tregmap_update_bits(iep->map, ICSS_IEP_GLOBAL_CFG_REG,\n\t\t\t   IEP_GLOBAL_CFG_CNT_ENABLE,\n\t\t\t   IEP_GLOBAL_CFG_CNT_ENABLE);\n}\n\nstatic void icss_iep_disable(struct icss_iep *iep)\n{\n\tregmap_update_bits(iep->map, ICSS_IEP_GLOBAL_CFG_REG,\n\t\t\t   IEP_GLOBAL_CFG_CNT_ENABLE,\n\t\t\t   0);\n}\n\nstatic void icss_iep_enable_shadow_mode(struct icss_iep *iep)\n{\n\tu32 cycle_time;\n\tint cmp;\n\n\tcycle_time = iep->cycle_time_ns - iep->def_inc;\n\n\ticss_iep_disable(iep);\n\n\t \n\tregmap_update_bits(iep->map, ICSS_IEP_CMP_CFG_REG,\n\t\t\t   IEP_CMP_CFG_SHADOW_EN, 0);\n\n\t \n\tregmap_update_bits(iep->map, ICSS_IEP_CMP_CFG_REG,\n\t\t\t   IEP_CMP_CFG_SHADOW_EN, IEP_CMP_CFG_SHADOW_EN);\n\n\t \n\ticss_iep_set_counter(iep, 0);\n\n\t \n\tregmap_update_bits(iep->map, ICSS_IEP_GLOBAL_STATUS_REG,\n\t\t\t   IEP_GLOBAL_STATUS_CNT_OVF,\n\t\t\t   IEP_GLOBAL_STATUS_CNT_OVF);\n\n\t \n\tfor (cmp = IEP_MIN_CMP; cmp < IEP_MAX_CMP; cmp++) {\n\t\tregmap_update_bits(iep->map, ICSS_IEP_CMP_STAT_REG,\n\t\t\t\t   IEP_CMP_STATUS(cmp), IEP_CMP_STATUS(cmp));\n\t}\n\n\t \n\tregmap_update_bits(iep->map, ICSS_IEP_CMP_CFG_REG,\n\t\t\t   IEP_CMP_CFG_CMP0_RST_CNT_EN,\n\t\t\t   IEP_CMP_CFG_CMP0_RST_CNT_EN);\n\t \n\tregmap_update_bits(iep->map, ICSS_IEP_CMP_CFG_REG,\n\t\t\t   IEP_CMP_CFG_CMP_EN(0),\n\t\t\t   IEP_CMP_CFG_CMP_EN(0));\n\n\t \n\tregmap_write(iep->map, ICSS_IEP_CMP0_REG0, cycle_time);\n\tif (iep->plat_data->flags & ICSS_IEP_64BIT_COUNTER_SUPPORT)\n\t\tregmap_write(iep->map, ICSS_IEP_CMP0_REG1, cycle_time);\n\n\ticss_iep_set_counter(iep, 0);\n\ticss_iep_enable(iep);\n}\n\nstatic void icss_iep_set_default_inc(struct icss_iep *iep, u8 def_inc)\n{\n\tregmap_update_bits(iep->map, ICSS_IEP_GLOBAL_CFG_REG,\n\t\t\t   IEP_GLOBAL_CFG_DEFAULT_INC_MASK,\n\t\t\t   def_inc << IEP_GLOBAL_CFG_DEFAULT_INC_SHIFT);\n}\n\nstatic void icss_iep_set_compensation_inc(struct icss_iep *iep, u16 compen_inc)\n{\n\tstruct device *dev = regmap_get_device(iep->map);\n\n\tif (compen_inc > IEP_MAX_COMPEN_INC) {\n\t\tdev_err(dev, \"%s: too high compensation inc %d\\n\",\n\t\t\t__func__, compen_inc);\n\t\tcompen_inc = IEP_MAX_COMPEN_INC;\n\t}\n\n\tregmap_update_bits(iep->map, ICSS_IEP_GLOBAL_CFG_REG,\n\t\t\t   IEP_GLOBAL_CFG_COMPEN_INC_MASK,\n\t\t\t   compen_inc << IEP_GLOBAL_CFG_COMPEN_INC_SHIFT);\n}\n\nstatic void icss_iep_set_compensation_count(struct icss_iep *iep,\n\t\t\t\t\t    u32 compen_count)\n{\n\tstruct device *dev = regmap_get_device(iep->map);\n\n\tif (compen_count > IEP_MAX_COMPEN_COUNT) {\n\t\tdev_err(dev, \"%s: too high compensation count %d\\n\",\n\t\t\t__func__, compen_count);\n\t\tcompen_count = IEP_MAX_COMPEN_COUNT;\n\t}\n\n\tregmap_write(iep->map, ICSS_IEP_COMPEN_REG, compen_count);\n}\n\nstatic void icss_iep_set_slow_compensation_count(struct icss_iep *iep,\n\t\t\t\t\t\t u32 compen_count)\n{\n\tregmap_write(iep->map, ICSS_IEP_SLOW_COMPEN_REG, compen_count);\n}\n\n \nstatic int icss_iep_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct icss_iep *iep = container_of(ptp, struct icss_iep, ptp_info);\n\ts32 ppb = scaled_ppm_to_ppb(scaled_ppm);\n\tu32 cyc_count;\n\tu16 cmp_inc;\n\n\tmutex_lock(&iep->ptp_clk_mutex);\n\n\t \n\n\tif (iep->cycle_time_ns)\n\t\tiep->slow_cmp_inc = iep->clk_tick_time;\t \n\telse\n\t\tiep->slow_cmp_inc = 1;\t \n\n\tif (ppb < 0) {\n\t\tiep->slow_cmp_inc = -iep->slow_cmp_inc;\n\t\tppb = -ppb;\n\t}\n\n\tcyc_count = NSEC_PER_SEC;\t\t \n\tcyc_count /= ppb;\t\t \n\n\t \n\tif (!iep->cycle_time_ns)\n\t\tcyc_count /= iep->clk_tick_time;\n\tiep->slow_cmp_count = cyc_count;\n\n\t \n\tcmp_inc = iep->clk_tick_time + iep->slow_cmp_inc;\n\ticss_iep_set_compensation_inc(iep, cmp_inc);\n\ticss_iep_set_slow_compensation_count(iep, iep->slow_cmp_count);\n\n\tmutex_unlock(&iep->ptp_clk_mutex);\n\n\treturn 0;\n}\n\nstatic int icss_iep_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct icss_iep *iep = container_of(ptp, struct icss_iep, ptp_info);\n\ts64 ns;\n\n\tmutex_lock(&iep->ptp_clk_mutex);\n\tif (iep->ops && iep->ops->adjtime) {\n\t\tiep->ops->adjtime(iep->clockops_data, delta);\n\t} else {\n\t\tns = icss_iep_gettime(iep, NULL);\n\t\tns += delta;\n\t\ticss_iep_settime(iep, ns);\n\t}\n\tmutex_unlock(&iep->ptp_clk_mutex);\n\n\treturn 0;\n}\n\nstatic int icss_iep_ptp_gettimeex(struct ptp_clock_info *ptp,\n\t\t\t\t  struct timespec64 *ts,\n\t\t\t\t  struct ptp_system_timestamp *sts)\n{\n\tstruct icss_iep *iep = container_of(ptp, struct icss_iep, ptp_info);\n\tu64 ns;\n\n\tmutex_lock(&iep->ptp_clk_mutex);\n\tns = icss_iep_gettime(iep, sts);\n\t*ts = ns_to_timespec64(ns);\n\tmutex_unlock(&iep->ptp_clk_mutex);\n\n\treturn 0;\n}\n\nstatic int icss_iep_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t\tconst struct timespec64 *ts)\n{\n\tstruct icss_iep *iep = container_of(ptp, struct icss_iep, ptp_info);\n\tu64 ns;\n\n\tmutex_lock(&iep->ptp_clk_mutex);\n\tns = timespec64_to_ns(ts);\n\ticss_iep_settime(iep, ns);\n\tmutex_unlock(&iep->ptp_clk_mutex);\n\n\treturn 0;\n}\n\nstatic void icss_iep_update_to_next_boundary(struct icss_iep *iep, u64 start_ns)\n{\n\tu64 ns, p_ns;\n\tu32 offset;\n\n\tns = icss_iep_gettime(iep, NULL);\n\tif (start_ns < ns)\n\t\tstart_ns = ns;\n\tp_ns = iep->period;\n\t \n\tstart_ns += p_ns - 1;\n\toffset = do_div(start_ns, p_ns);\n\tstart_ns = start_ns * p_ns;\n\t \n\tif (p_ns - offset < 10)\n\t\tstart_ns += p_ns;\n\n\tregmap_write(iep->map, ICSS_IEP_CMP1_REG0, lower_32_bits(start_ns));\n\tif (iep->plat_data->flags & ICSS_IEP_64BIT_COUNTER_SUPPORT)\n\t\tregmap_write(iep->map, ICSS_IEP_CMP1_REG1, upper_32_bits(start_ns));\n}\n\nstatic int icss_iep_perout_enable_hw(struct icss_iep *iep,\n\t\t\t\t     struct ptp_perout_request *req, int on)\n{\n\tint ret;\n\tu64 cmp;\n\n\tif (iep->ops && iep->ops->perout_enable) {\n\t\tret = iep->ops->perout_enable(iep->clockops_data, req, on, &cmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (on) {\n\t\t\t \n\t\t\tregmap_write(iep->map, ICSS_IEP_CMP1_REG0, lower_32_bits(cmp));\n\t\t\tif (iep->plat_data->flags & ICSS_IEP_64BIT_COUNTER_SUPPORT)\n\t\t\t\tregmap_write(iep->map, ICSS_IEP_CMP1_REG1, upper_32_bits(cmp));\n\t\t\t \n\t\t\tregmap_write(iep->map, ICSS_IEP_SYNC_PWIDTH_REG, 1000000);\n\t\t\tregmap_write(iep->map, ICSS_IEP_SYNC0_PERIOD_REG, 0);\n\t\t\tregmap_write(iep->map, ICSS_IEP_SYNC_START_REG, 0);\n\t\t\tregmap_write(iep->map, ICSS_IEP_SYNC_CTRL_REG, 0);  \n\t\t\t \n\t\t\tregmap_update_bits(iep->map, ICSS_IEP_CMP_CFG_REG,\n\t\t\t\t\t   IEP_CMP_CFG_CMP_EN(1), IEP_CMP_CFG_CMP_EN(1));\n\t\t} else {\n\t\t\t \n\t\t\tregmap_update_bits(iep->map, ICSS_IEP_CMP_CFG_REG,\n\t\t\t\t\t   IEP_CMP_CFG_CMP_EN(1), 0);\n\n\t\t\t \n\t\t\tregmap_write(iep->map, ICSS_IEP_CMP1_REG0, 0);\n\t\t\tif (iep->plat_data->flags & ICSS_IEP_64BIT_COUNTER_SUPPORT)\n\t\t\t\tregmap_write(iep->map, ICSS_IEP_CMP1_REG1, 0);\n\t\t}\n\t} else {\n\t\tif (on) {\n\t\t\tu64 start_ns;\n\n\t\t\tiep->period = ((u64)req->period.sec * NSEC_PER_SEC) +\n\t\t\t\t      req->period.nsec;\n\t\t\tstart_ns = ((u64)req->period.sec * NSEC_PER_SEC)\n\t\t\t\t   + req->period.nsec;\n\t\t\ticss_iep_update_to_next_boundary(iep, start_ns);\n\n\t\t\t \n\t\t\tregmap_write(iep->map, ICSS_IEP_SYNC_CTRL_REG,\n\t\t\t\t     IEP_SYNC_CTRL_SYNC_N_EN(0) | IEP_SYNC_CTRL_SYNC_EN);\n\t\t\t \n\t\t\tregmap_update_bits(iep->map, ICSS_IEP_CMP_CFG_REG,\n\t\t\t\t\t   IEP_CMP_CFG_CMP_EN(1), IEP_CMP_CFG_CMP_EN(1));\n\t\t} else {\n\t\t\t \n\t\t\tregmap_update_bits(iep->map, ICSS_IEP_CMP_CFG_REG,\n\t\t\t\t\t   IEP_CMP_CFG_CMP_EN(1), 0);\n\n\t\t\t \n\t\t\tregmap_write(iep->map, ICSS_IEP_CMP1_REG0, 0);\n\t\t\tif (iep->plat_data->flags & ICSS_IEP_64BIT_COUNTER_SUPPORT)\n\t\t\t\tregmap_write(iep->map, ICSS_IEP_CMP1_REG1, 0);\n\n\t\t\t \n\t\t\tregmap_write(iep->map, ICSS_IEP_SYNC_CTRL_REG, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int icss_iep_perout_enable(struct icss_iep *iep,\n\t\t\t\t  struct ptp_perout_request *req, int on)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tmutex_lock(&iep->ptp_clk_mutex);\n\n\tif (iep->pps_enabled) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tif (iep->perout_enabled == !!on)\n\t\tgoto exit;\n\n\tspin_lock_irqsave(&iep->irq_lock, flags);\n\tret = icss_iep_perout_enable_hw(iep, req, on);\n\tif (!ret)\n\t\tiep->perout_enabled = !!on;\n\tspin_unlock_irqrestore(&iep->irq_lock, flags);\n\nexit:\n\tmutex_unlock(&iep->ptp_clk_mutex);\n\n\treturn ret;\n}\n\nstatic int icss_iep_pps_enable(struct icss_iep *iep, int on)\n{\n\tstruct ptp_clock_request rq;\n\tstruct timespec64 ts;\n\tunsigned long flags;\n\tint ret = 0;\n\tu64 ns;\n\n\tmutex_lock(&iep->ptp_clk_mutex);\n\n\tif (iep->perout_enabled) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tif (iep->pps_enabled == !!on)\n\t\tgoto exit;\n\n\tspin_lock_irqsave(&iep->irq_lock, flags);\n\n\trq.perout.index = 0;\n\tif (on) {\n\t\tns = icss_iep_gettime(iep, NULL);\n\t\tts = ns_to_timespec64(ns);\n\t\trq.perout.period.sec = 1;\n\t\trq.perout.period.nsec = 0;\n\t\trq.perout.start.sec = ts.tv_sec + 2;\n\t\trq.perout.start.nsec = 0;\n\t\tret = icss_iep_perout_enable_hw(iep, &rq.perout, on);\n\t} else {\n\t\tret = icss_iep_perout_enable_hw(iep, &rq.perout, on);\n\t}\n\n\tif (!ret)\n\t\tiep->pps_enabled = !!on;\n\n\tspin_unlock_irqrestore(&iep->irq_lock, flags);\n\nexit:\n\tmutex_unlock(&iep->ptp_clk_mutex);\n\n\treturn ret;\n}\n\nstatic int icss_iep_extts_enable(struct icss_iep *iep, u32 index, int on)\n{\n\tu32 val, cap, ret = 0;\n\n\tmutex_lock(&iep->ptp_clk_mutex);\n\n\tif (iep->ops && iep->ops->extts_enable) {\n\t\tret = iep->ops->extts_enable(iep->clockops_data, index, on);\n\t\tgoto exit;\n\t}\n\n\tif (((iep->latch_enable & BIT(index)) >> index) == on)\n\t\tgoto exit;\n\n\tregmap_read(iep->map, ICSS_IEP_CAPTURE_CFG_REG, &val);\n\tcap = IEP_CAP_CFG_CAP_ASYNC_EN(index) | IEP_CAP_CFG_CAPNR_1ST_EVENT_EN(index);\n\tif (on) {\n\t\tval |= cap;\n\t\tiep->latch_enable |= BIT(index);\n\t} else {\n\t\tval &= ~cap;\n\t\tiep->latch_enable &= ~BIT(index);\n\t}\n\tregmap_write(iep->map, ICSS_IEP_CAPTURE_CFG_REG, val);\n\nexit:\n\tmutex_unlock(&iep->ptp_clk_mutex);\n\n\treturn ret;\n}\n\nstatic int icss_iep_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t       struct ptp_clock_request *rq, int on)\n{\n\tstruct icss_iep *iep = container_of(ptp, struct icss_iep, ptp_info);\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_PEROUT:\n\t\treturn icss_iep_perout_enable(iep, &rq->perout, on);\n\tcase PTP_CLK_REQ_PPS:\n\t\treturn icss_iep_pps_enable(iep, on);\n\tcase PTP_CLK_REQ_EXTTS:\n\t\treturn icss_iep_extts_enable(iep, rq->extts.index, on);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic struct ptp_clock_info icss_iep_ptp_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ICSS IEP timer\",\n\t.max_adj\t= 10000000,\n\t.adjfine\t= icss_iep_ptp_adjfine,\n\t.adjtime\t= icss_iep_ptp_adjtime,\n\t.gettimex64\t= icss_iep_ptp_gettimeex,\n\t.settime64\t= icss_iep_ptp_settime,\n\t.enable\t\t= icss_iep_ptp_enable,\n};\n\nstruct icss_iep *icss_iep_get_idx(struct device_node *np, int idx)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *iep_np;\n\tstruct icss_iep *iep;\n\n\tiep_np = of_parse_phandle(np, \"ti,iep\", idx);\n\tif (!iep_np || !of_device_is_available(iep_np))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdev = of_find_device_by_node(iep_np);\n\tof_node_put(iep_np);\n\n\tif (!pdev)\n\t\t \n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tiep = platform_get_drvdata(pdev);\n\tif (!iep)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tdevice_lock(iep->dev);\n\tif (iep->client_np) {\n\t\tdevice_unlock(iep->dev);\n\t\tdev_err(iep->dev, \"IEP is already acquired by %s\",\n\t\t\tiep->client_np->name);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tiep->client_np = np;\n\tdevice_unlock(iep->dev);\n\tget_device(iep->dev);\n\n\treturn iep;\n}\nEXPORT_SYMBOL_GPL(icss_iep_get_idx);\n\nstruct icss_iep *icss_iep_get(struct device_node *np)\n{\n\treturn icss_iep_get_idx(np, 0);\n}\nEXPORT_SYMBOL_GPL(icss_iep_get);\n\nvoid icss_iep_put(struct icss_iep *iep)\n{\n\tdevice_lock(iep->dev);\n\tiep->client_np = NULL;\n\tdevice_unlock(iep->dev);\n\tput_device(iep->dev);\n}\nEXPORT_SYMBOL_GPL(icss_iep_put);\n\nvoid icss_iep_init_fw(struct icss_iep *iep)\n{\n\t \n\tiep->clk_tick_time = iep->def_inc;\n\tiep->cycle_time_ns = 0;\n\tiep->ops = NULL;\n\tiep->clockops_data = NULL;\n\ticss_iep_set_default_inc(iep, iep->def_inc);\n\ticss_iep_set_compensation_inc(iep, iep->def_inc);\n\ticss_iep_set_compensation_count(iep, 0);\n\tregmap_write(iep->map, ICSS_IEP_SYNC_PWIDTH_REG, iep->refclk_freq / 10);  \n\tregmap_write(iep->map, ICSS_IEP_SYNC0_PERIOD_REG, 0);\n\tif (iep->plat_data->flags & ICSS_IEP_SLOW_COMPEN_REG_SUPPORT)\n\t\ticss_iep_set_slow_compensation_count(iep, 0);\n\n\ticss_iep_enable(iep);\n\ticss_iep_settime(iep, 0);\n}\nEXPORT_SYMBOL_GPL(icss_iep_init_fw);\n\nvoid icss_iep_exit_fw(struct icss_iep *iep)\n{\n\ticss_iep_disable(iep);\n}\nEXPORT_SYMBOL_GPL(icss_iep_exit_fw);\n\nint icss_iep_init(struct icss_iep *iep, const struct icss_iep_clockops *clkops,\n\t\t  void *clockops_data, u32 cycle_time_ns)\n{\n\tint ret = 0;\n\n\tiep->cycle_time_ns = cycle_time_ns;\n\tiep->clk_tick_time = iep->def_inc;\n\tiep->ops = clkops;\n\tiep->clockops_data = clockops_data;\n\ticss_iep_set_default_inc(iep, iep->def_inc);\n\ticss_iep_set_compensation_inc(iep, iep->def_inc);\n\ticss_iep_set_compensation_count(iep, 0);\n\tregmap_write(iep->map, ICSS_IEP_SYNC_PWIDTH_REG, iep->refclk_freq / 10);  \n\tregmap_write(iep->map, ICSS_IEP_SYNC0_PERIOD_REG, 0);\n\tif (iep->plat_data->flags & ICSS_IEP_SLOW_COMPEN_REG_SUPPORT)\n\t\ticss_iep_set_slow_compensation_count(iep, 0);\n\n\tif (!(iep->plat_data->flags & ICSS_IEP_64BIT_COUNTER_SUPPORT) ||\n\t    !(iep->plat_data->flags & ICSS_IEP_SLOW_COMPEN_REG_SUPPORT))\n\t\tgoto skip_perout;\n\n\tif (iep->ops && iep->ops->perout_enable) {\n\t\tiep->ptp_info.n_per_out = 1;\n\t\tiep->ptp_info.pps = 1;\n\t}\n\n\tif (iep->ops && iep->ops->extts_enable)\n\t\tiep->ptp_info.n_ext_ts = 2;\n\nskip_perout:\n\tif (cycle_time_ns)\n\t\ticss_iep_enable_shadow_mode(iep);\n\telse\n\t\ticss_iep_enable(iep);\n\ticss_iep_settime(iep, ktime_get_real_ns());\n\n\tiep->ptp_clock = ptp_clock_register(&iep->ptp_info, iep->dev);\n\tif (IS_ERR(iep->ptp_clock)) {\n\t\tret = PTR_ERR(iep->ptp_clock);\n\t\tiep->ptp_clock = NULL;\n\t\tdev_err(iep->dev, \"Failed to register ptp clk %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(icss_iep_init);\n\nint icss_iep_exit(struct icss_iep *iep)\n{\n\tif (iep->ptp_clock) {\n\t\tptp_clock_unregister(iep->ptp_clock);\n\t\tiep->ptp_clock = NULL;\n\t}\n\ticss_iep_disable(iep);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(icss_iep_exit);\n\nstatic int icss_iep_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct icss_iep *iep;\n\tstruct clk *iep_clk;\n\n\tiep = devm_kzalloc(dev, sizeof(*iep), GFP_KERNEL);\n\tif (!iep)\n\t\treturn -ENOMEM;\n\n\tiep->dev = dev;\n\tiep->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(iep->base))\n\t\treturn -ENODEV;\n\n\tiep_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(iep_clk))\n\t\treturn PTR_ERR(iep_clk);\n\n\tiep->refclk_freq = clk_get_rate(iep_clk);\n\n\tiep->def_inc = NSEC_PER_SEC / iep->refclk_freq;\t \n\tif (iep->def_inc > IEP_MAX_DEF_INC) {\n\t\tdev_err(dev, \"Failed to set def_inc %d.  IEP_clock is too slow to be supported\\n\",\n\t\t\tiep->def_inc);\n\t\treturn -EINVAL;\n\t}\n\n\tiep->plat_data = device_get_match_data(dev);\n\tif (!iep->plat_data)\n\t\treturn -EINVAL;\n\n\tiep->map = devm_regmap_init(dev, NULL, iep, iep->plat_data->config);\n\tif (IS_ERR(iep->map)) {\n\t\tdev_err(dev, \"Failed to create regmap for IEP %ld\\n\",\n\t\t\tPTR_ERR(iep->map));\n\t\treturn PTR_ERR(iep->map);\n\t}\n\n\tiep->ptp_info = icss_iep_ptp_info;\n\tmutex_init(&iep->ptp_clk_mutex);\n\tspin_lock_init(&iep->irq_lock);\n\tdev_set_drvdata(dev, iep);\n\ticss_iep_disable(iep);\n\n\treturn 0;\n}\n\nstatic bool am654_icss_iep_valid_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ICSS_IEP_GLOBAL_CFG_REG ... ICSS_IEP_SYNC_START_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nstatic int icss_iep_regmap_write(void *context, unsigned int reg,\n\t\t\t\t unsigned int val)\n{\n\tstruct icss_iep *iep = context;\n\n\twritel(val, iep->base + iep->plat_data->reg_offs[reg]);\n\n\treturn 0;\n}\n\nstatic int icss_iep_regmap_read(void *context, unsigned int reg,\n\t\t\t\tunsigned int *val)\n{\n\tstruct icss_iep *iep = context;\n\n\t*val = readl(iep->base + iep->plat_data->reg_offs[reg]);\n\n\treturn 0;\n}\n\nstatic struct regmap_config am654_icss_iep_regmap_config = {\n\t.name = \"icss iep\",\n\t.reg_stride = 1,\n\t.reg_write = icss_iep_regmap_write,\n\t.reg_read = icss_iep_regmap_read,\n\t.writeable_reg = am654_icss_iep_valid_reg,\n\t.readable_reg = am654_icss_iep_valid_reg,\n\t.fast_io = 1,\n};\n\nstatic const struct icss_iep_plat_data am654_icss_iep_plat_data = {\n\t.flags = ICSS_IEP_64BIT_COUNTER_SUPPORT |\n\t\t ICSS_IEP_SLOW_COMPEN_REG_SUPPORT |\n\t\t ICSS_IEP_SHADOW_MODE_SUPPORT,\n\t.reg_offs = {\n\t\t[ICSS_IEP_GLOBAL_CFG_REG] = 0x00,\n\t\t[ICSS_IEP_COMPEN_REG] = 0x08,\n\t\t[ICSS_IEP_SLOW_COMPEN_REG] = 0x0C,\n\t\t[ICSS_IEP_COUNT_REG0] = 0x10,\n\t\t[ICSS_IEP_COUNT_REG1] = 0x14,\n\t\t[ICSS_IEP_CAPTURE_CFG_REG] = 0x18,\n\t\t[ICSS_IEP_CAPTURE_STAT_REG] = 0x1c,\n\n\t\t[ICSS_IEP_CAP6_RISE_REG0] = 0x50,\n\t\t[ICSS_IEP_CAP6_RISE_REG1] = 0x54,\n\n\t\t[ICSS_IEP_CAP7_RISE_REG0] = 0x60,\n\t\t[ICSS_IEP_CAP7_RISE_REG1] = 0x64,\n\n\t\t[ICSS_IEP_CMP_CFG_REG] = 0x70,\n\t\t[ICSS_IEP_CMP_STAT_REG] = 0x74,\n\t\t[ICSS_IEP_CMP0_REG0] = 0x78,\n\t\t[ICSS_IEP_CMP0_REG1] = 0x7c,\n\t\t[ICSS_IEP_CMP1_REG0] = 0x80,\n\t\t[ICSS_IEP_CMP1_REG1] = 0x84,\n\n\t\t[ICSS_IEP_CMP8_REG0] = 0xc0,\n\t\t[ICSS_IEP_CMP8_REG1] = 0xc4,\n\t\t[ICSS_IEP_SYNC_CTRL_REG] = 0x180,\n\t\t[ICSS_IEP_SYNC0_STAT_REG] = 0x188,\n\t\t[ICSS_IEP_SYNC1_STAT_REG] = 0x18c,\n\t\t[ICSS_IEP_SYNC_PWIDTH_REG] = 0x190,\n\t\t[ICSS_IEP_SYNC0_PERIOD_REG] = 0x194,\n\t\t[ICSS_IEP_SYNC1_DELAY_REG] = 0x198,\n\t\t[ICSS_IEP_SYNC_START_REG] = 0x19c,\n\t},\n\t.config = &am654_icss_iep_regmap_config,\n};\n\nstatic const struct of_device_id icss_iep_of_match[] = {\n\t{\n\t\t.compatible = \"ti,am654-icss-iep\",\n\t\t.data = &am654_icss_iep_plat_data,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, icss_iep_of_match);\n\nstatic struct platform_driver icss_iep_driver = {\n\t.driver = {\n\t\t.name = \"icss-iep\",\n\t\t.of_match_table = icss_iep_of_match,\n\t},\n\t.probe = icss_iep_probe,\n};\nmodule_platform_driver(icss_iep_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TI ICSS IEP driver\");\nMODULE_AUTHOR(\"Roger Quadros <rogerq@ti.com>\");\nMODULE_AUTHOR(\"Md Danish Anwar <danishanwar@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}