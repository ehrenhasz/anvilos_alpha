{
  "module_name": "icssg_config.c",
  "hash_id": "814d3d6be3cccc57f7bcec09bd758d850ffc89ca402db30062535787c2fe0488",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/icssg/icssg_config.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n#include <linux/regmap.h>\n#include <uapi/linux/if_ether.h>\n#include \"icssg_config.h\"\n#include \"icssg_prueth.h\"\n#include \"icssg_switch_map.h\"\n#include \"icssg_mii_rt.h\"\n\n \n\n \n#define MII_RT_TX_IPG_100M\t0x17\n#define MII_RT_TX_IPG_1G\t0xb\n\n#define\tICSSG_QUEUES_MAX\t\t64\n#define\tICSSG_QUEUE_OFFSET\t\t0xd00\n#define\tICSSG_QUEUE_PEEK_OFFSET\t\t0xe00\n#define\tICSSG_QUEUE_CNT_OFFSET\t\t0xe40\n#define\tICSSG_QUEUE_RESET_OFFSET\t0xf40\n\n#define\tICSSG_NUM_TX_QUEUES\t8\n\n#define\tRECYCLE_Q_SLICE0\t16\n#define\tRECYCLE_Q_SLICE1\t17\n\n#define\tICSSG_NUM_OTHER_QUEUES\t5\t \n\n#define\tPORT_HI_Q_SLICE0\t32\n#define\tPORT_LO_Q_SLICE0\t33\n#define\tHOST_HI_Q_SLICE0\t34\n#define\tHOST_LO_Q_SLICE0\t35\n#define\tHOST_SPL_Q_SLICE0\t40\t \n\n#define\tPORT_HI_Q_SLICE1\t36\n#define\tPORT_LO_Q_SLICE1\t37\n#define\tHOST_HI_Q_SLICE1\t38\n#define\tHOST_LO_Q_SLICE1\t39\n#define\tHOST_SPL_Q_SLICE1\t41\t \n\n#define MII_RXCFG_DEFAULT\t(PRUSS_MII_RT_RXCFG_RX_ENABLE | \\\n\t\t\t\t PRUSS_MII_RT_RXCFG_RX_DATA_RDY_MODE_DIS | \\\n\t\t\t\t PRUSS_MII_RT_RXCFG_RX_L2_EN | \\\n\t\t\t\t PRUSS_MII_RT_RXCFG_RX_L2_EOF_SCLR_DIS)\n\n#define MII_TXCFG_DEFAULT\t(PRUSS_MII_RT_TXCFG_TX_ENABLE | \\\n\t\t\t\t PRUSS_MII_RT_TXCFG_TX_AUTO_PREAMBLE | \\\n\t\t\t\t PRUSS_MII_RT_TXCFG_TX_32_MODE_EN | \\\n\t\t\t\t PRUSS_MII_RT_TXCFG_TX_IPG_WIRE_CLK_EN)\n\n#define ICSSG_CFG_DEFAULT\t(ICSSG_CFG_TX_L1_EN | \\\n\t\t\t\t ICSSG_CFG_TX_L2_EN | ICSSG_CFG_RX_L2_G_EN | \\\n\t\t\t\t ICSSG_CFG_TX_PRU_EN | \\\n\t\t\t\t ICSSG_CFG_SGMII_MODE)\n\n#define FDB_GEN_CFG1\t\t0x60\n#define SMEM_VLAN_OFFSET\t8\n#define SMEM_VLAN_OFFSET_MASK\tGENMASK(25, 8)\n\n#define FDB_GEN_CFG2\t\t0x64\n#define FDB_VLAN_EN\t\tBIT(6)\n#define FDB_HOST_EN\t\tBIT(2)\n#define FDB_PRU1_EN\t\tBIT(1)\n#define FDB_PRU0_EN\t\tBIT(0)\n#define FDB_EN_ALL\t\t(FDB_PRU0_EN | FDB_PRU1_EN | \\\n\t\t\t\t FDB_HOST_EN | FDB_VLAN_EN)\n\n \nstruct map {\n\tint queue;\n\tu32 pd_addr_start;\n\tu32 flags;\n\tbool special;\n};\n\n \nstatic const struct map hwq_map[2][ICSSG_NUM_OTHER_QUEUES] = {\n\t{\n\t\t{ PORT_HI_Q_SLICE0, PORT_DESC0_HI, 0x200000, 0 },\n\t\t{ PORT_LO_Q_SLICE0, PORT_DESC0_LO, 0, 0 },\n\t\t{ HOST_HI_Q_SLICE0, HOST_DESC0_HI, 0x200000, 0 },\n\t\t{ HOST_LO_Q_SLICE0, HOST_DESC0_LO, 0, 0 },\n\t\t{ HOST_SPL_Q_SLICE0, HOST_SPPD0, 0x400000, 1 },\n\t},\n\t{\n\t\t{ PORT_HI_Q_SLICE1, PORT_DESC1_HI, 0xa00000, 0 },\n\t\t{ PORT_LO_Q_SLICE1, PORT_DESC1_LO, 0x800000, 0 },\n\t\t{ HOST_HI_Q_SLICE1, HOST_DESC1_HI, 0xa00000, 0 },\n\t\t{ HOST_LO_Q_SLICE1, HOST_DESC1_LO, 0x800000, 0 },\n\t\t{ HOST_SPL_Q_SLICE1, HOST_SPPD1, 0xc00000, 1 },\n\t},\n};\n\nstatic void icssg_config_mii_init(struct prueth_emac *emac)\n{\n\tu32 rxcfg, txcfg, rxcfg_reg, txcfg_reg, pcnt_reg;\n\tstruct prueth *prueth = emac->prueth;\n\tint slice = prueth_emac_slice(emac);\n\tstruct regmap *mii_rt;\n\n\tmii_rt = prueth->mii_rt;\n\n\trxcfg_reg = (slice == ICSS_MII0) ? PRUSS_MII_RT_RXCFG0 :\n\t\t\t\t       PRUSS_MII_RT_RXCFG1;\n\ttxcfg_reg = (slice == ICSS_MII0) ? PRUSS_MII_RT_TXCFG0 :\n\t\t\t\t       PRUSS_MII_RT_TXCFG1;\n\tpcnt_reg = (slice == ICSS_MII0) ? PRUSS_MII_RT_RX_PCNT0 :\n\t\t\t\t       PRUSS_MII_RT_RX_PCNT1;\n\n\trxcfg = MII_RXCFG_DEFAULT;\n\ttxcfg = MII_TXCFG_DEFAULT;\n\n\tif (slice == ICSS_MII1)\n\t\trxcfg |= PRUSS_MII_RT_RXCFG_RX_MUX_SEL;\n\n\t \n\tif (emac->phy_if == PHY_INTERFACE_MODE_MII && slice == ICSS_MII0)\n\t\ttxcfg |= PRUSS_MII_RT_TXCFG_TX_MUX_SEL;\n\telse if (emac->phy_if != PHY_INTERFACE_MODE_MII && slice == ICSS_MII1)\n\t\ttxcfg |= PRUSS_MII_RT_TXCFG_TX_MUX_SEL;\n\n\tregmap_write(mii_rt, rxcfg_reg, rxcfg);\n\tregmap_write(mii_rt, txcfg_reg, txcfg);\n\tregmap_write(mii_rt, pcnt_reg, 0x1);\n}\n\nstatic void icssg_miig_queues_init(struct prueth *prueth, int slice)\n{\n\tstruct regmap *miig_rt = prueth->miig_rt;\n\tvoid __iomem *smem = prueth->shram.va;\n\tu8 pd[ICSSG_SPECIAL_PD_SIZE];\n\tint queue = 0, i, j;\n\tu32 *pdword;\n\n\t \n\tif (slice)\n\t\tqueue = ICSSG_NUM_TX_QUEUES;\n\n\tfor (i = 0; i < ICSSG_NUM_TX_QUEUES; i++) {\n\t\tregmap_write(miig_rt, ICSSG_QUEUE_RESET_OFFSET, queue);\n\t\tqueue++;\n\t}\n\n\tqueue = slice ? RECYCLE_Q_SLICE1 : RECYCLE_Q_SLICE0;\n\tregmap_write(miig_rt, ICSSG_QUEUE_RESET_OFFSET, queue);\n\n\tfor (i = 0; i < ICSSG_NUM_OTHER_QUEUES; i++) {\n\t\tregmap_write(miig_rt, ICSSG_QUEUE_RESET_OFFSET,\n\t\t\t     hwq_map[slice][i].queue);\n\t}\n\n\t \n\t \n\n\tpdword = (u32 *)pd;\n\tfor (j = 0; j < ICSSG_NUM_OTHER_QUEUES; j++) {\n\t\tconst struct map *mp;\n\t\tint pd_size, num_pds;\n\t\tu32 pdaddr;\n\n\t\tmp = &hwq_map[slice][j];\n\t\tif (mp->special) {\n\t\t\tpd_size = ICSSG_SPECIAL_PD_SIZE;\n\t\t\tnum_pds = ICSSG_NUM_SPECIAL_PDS;\n\t\t} else\t{\n\t\t\tpd_size = ICSSG_NORMAL_PD_SIZE;\n\t\t\tnum_pds = ICSSG_NUM_NORMAL_PDS;\n\t\t}\n\n\t\tfor (i = 0; i < num_pds; i++) {\n\t\t\tmemset(pd, 0, pd_size);\n\n\t\t\tpdword[0] &= ICSSG_FLAG_MASK;\n\t\t\tpdword[0] |= mp->flags;\n\t\t\tpdaddr = mp->pd_addr_start + i * pd_size;\n\n\t\t\tmemcpy_toio(smem + pdaddr, pd, pd_size);\n\t\t\tqueue = mp->queue;\n\t\t\tregmap_write(miig_rt, ICSSG_QUEUE_OFFSET + 4 * queue,\n\t\t\t\t     pdaddr);\n\t\t}\n\t}\n}\n\nvoid icssg_config_ipg(struct prueth_emac *emac)\n{\n\tstruct prueth *prueth = emac->prueth;\n\tint slice = prueth_emac_slice(emac);\n\n\tswitch (emac->speed) {\n\tcase SPEED_1000:\n\t\ticssg_mii_update_ipg(prueth->mii_rt, slice, MII_RT_TX_IPG_1G);\n\t\tbreak;\n\tcase SPEED_100:\n\t\ticssg_mii_update_ipg(prueth->mii_rt, slice, MII_RT_TX_IPG_100M);\n\t\tbreak;\n\tcase SPEED_10:\n\t\t \n\t\ticssg_mii_update_ipg(prueth->mii_rt, slice, MII_RT_TX_IPG_100M);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tnetdev_err(emac->ndev, \"Unsupported link speed\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void emac_r30_cmd_init(struct prueth_emac *emac)\n{\n\tstruct icssg_r30_cmd __iomem *p;\n\tint i;\n\n\tp = emac->dram.va + MGR_R30_CMD_OFFSET;\n\n\tfor (i = 0; i < 4; i++)\n\t\twritel(EMAC_NONE, &p->cmd[i]);\n}\n\nstatic int emac_r30_is_done(struct prueth_emac *emac)\n{\n\tconst struct icssg_r30_cmd __iomem *p;\n\tu32 cmd;\n\tint i;\n\n\tp = emac->dram.va + MGR_R30_CMD_OFFSET;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tcmd = readl(&p->cmd[i]);\n\t\tif (cmd != EMAC_NONE)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int prueth_emac_buffer_setup(struct prueth_emac *emac)\n{\n\tstruct icssg_buffer_pool_cfg __iomem *bpool_cfg;\n\tstruct icssg_rxq_ctx __iomem *rxq_ctx;\n\tstruct prueth *prueth = emac->prueth;\n\tint slice = prueth_emac_slice(emac);\n\tu32 addr;\n\tint i;\n\n\t \n\n\taddr = lower_32_bits(prueth->msmcram.pa);\n\tif (slice)\n\t\taddr += PRUETH_NUM_BUF_POOLS * PRUETH_EMAC_BUF_POOL_SIZE;\n\n\tif (addr % SZ_64K) {\n\t\tdev_warn(prueth->dev, \"buffer pool needs to be 64KB aligned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbpool_cfg = emac->dram.va + BUFFER_POOL_0_ADDR_OFFSET;\n\t \n\twritel(addr, &bpool_cfg[0].addr);\n\twritel(0, &bpool_cfg[0].len);\n\n\tfor (i = PRUETH_EMAC_BUF_POOL_START;\n\t     i < PRUETH_EMAC_BUF_POOL_START + PRUETH_NUM_BUF_POOLS;\n\t     i++) {\n\t\twritel(addr, &bpool_cfg[i].addr);\n\t\twritel(PRUETH_EMAC_BUF_POOL_SIZE, &bpool_cfg[i].len);\n\t\taddr += PRUETH_EMAC_BUF_POOL_SIZE;\n\t}\n\n\tif (!slice)\n\t\taddr += PRUETH_NUM_BUF_POOLS * PRUETH_EMAC_BUF_POOL_SIZE;\n\telse\n\t\taddr += PRUETH_EMAC_RX_CTX_BUF_SIZE * 2;\n\n\t \n\trxq_ctx = emac->dram.va + HOST_RX_Q_PRE_CONTEXT_OFFSET;\n\tfor (i = 0; i < 3; i++)\n\t\twritel(addr, &rxq_ctx->start[i]);\n\n\taddr += PRUETH_EMAC_RX_CTX_BUF_SIZE;\n\twritel(addr, &rxq_ctx->end);\n\n\t \n\trxq_ctx = emac->dram.va + HOST_RX_Q_EXP_CONTEXT_OFFSET;\n\tfor (i = 0; i < 3; i++)\n\t\twritel(addr, &rxq_ctx->start[i]);\n\n\taddr += PRUETH_EMAC_RX_CTX_BUF_SIZE;\n\twritel(addr, &rxq_ctx->end);\n\n\treturn 0;\n}\n\nstatic void icssg_init_emac_mode(struct prueth *prueth)\n{\n\t \n\tu8 mac[ETH_ALEN] = { 0 };\n\n\tif (prueth->emacs_initialized)\n\t\treturn;\n\n\tregmap_update_bits(prueth->miig_rt, FDB_GEN_CFG1,\n\t\t\t   SMEM_VLAN_OFFSET_MASK, 0);\n\tregmap_write(prueth->miig_rt, FDB_GEN_CFG2, 0);\n\t \n\ticssg_class_set_host_mac_addr(prueth->miig_rt, mac);\n}\n\nint icssg_config(struct prueth *prueth, struct prueth_emac *emac, int slice)\n{\n\tvoid __iomem *config = emac->dram.va + ICSSG_CONFIG_OFFSET;\n\tstruct icssg_flow_cfg __iomem *flow_cfg;\n\tint ret;\n\n\ticssg_init_emac_mode(prueth);\n\n\tmemset_io(config, 0, TAS_GATE_MASK_LIST0);\n\ticssg_miig_queues_init(prueth, slice);\n\n\temac->speed = SPEED_1000;\n\temac->duplex = DUPLEX_FULL;\n\tif (!phy_interface_mode_is_rgmii(emac->phy_if)) {\n\t\temac->speed = SPEED_100;\n\t\temac->duplex = DUPLEX_FULL;\n\t}\n\tregmap_update_bits(prueth->miig_rt, ICSSG_CFG_OFFSET,\n\t\t\t   ICSSG_CFG_DEFAULT, ICSSG_CFG_DEFAULT);\n\ticssg_miig_set_interface_mode(prueth->miig_rt, slice, emac->phy_if);\n\ticssg_config_mii_init(emac);\n\ticssg_config_ipg(emac);\n\ticssg_update_rgmii_cfg(prueth->miig_rt, emac);\n\n\t \n\tpruss_cfg_gpimode(prueth->pruss, prueth->pru_id[slice],\n\t\t\t  PRUSS_GPI_MODE_MII);\n\n\t \n\tpruss_cfg_xfr_enable(prueth->pruss, PRU_TYPE_PRU, true);\n\tpruss_cfg_xfr_enable(prueth->pruss, PRU_TYPE_RTU, true);\n\n\t \n\tpru_rproc_set_ctable(prueth->pru[slice], PRU_C28, 0x100 << 8);\n\tpru_rproc_set_ctable(prueth->rtu[slice], PRU_C28, 0x100 << 8);\n\tpru_rproc_set_ctable(prueth->txpru[slice], PRU_C28, 0x100 << 8);\n\n\tflow_cfg = config + PSI_L_REGULAR_FLOW_ID_BASE_OFFSET;\n\twritew(emac->rx_flow_id_base, &flow_cfg->rx_base_flow);\n\twritew(0, &flow_cfg->mgm_base_flow);\n\twriteb(0, config + SPL_PKT_DEFAULT_PRIORITY);\n\twriteb(0, config + QUEUE_NUM_UNTAGGED);\n\n\tret = prueth_emac_buffer_setup(emac);\n\tif (ret)\n\t\treturn ret;\n\n\temac_r30_cmd_init(emac);\n\n\treturn 0;\n}\n\n \nstatic const struct icssg_r30_cmd emac_r32_bitmask[] = {\n\t{{0xffff0004, 0xffff0100, 0xffff0004, EMAC_NONE}},\t \n\t{{0xfffb0040, 0xfeff0200, 0xfeff0200, EMAC_NONE}},\t \n\t{{0xffbb0000, 0xfcff0000, 0xdcfb0000, EMAC_NONE}},\t \n\t{{0xffbb0000, 0xfcff0000, 0xfcff2000, EMAC_NONE}},\t \n\t{{0xffff0001, EMAC_NONE,  EMAC_NONE, EMAC_NONE}},\t \n\t{{0xfffe0002, EMAC_NONE,  EMAC_NONE, EMAC_NONE}},\t \n\t{{0xfffc0000, EMAC_NONE,  EMAC_NONE, EMAC_NONE}},\t \n\t{{EMAC_NONE,  0xffff0020, EMAC_NONE, EMAC_NONE}},\t \n\t{{EMAC_NONE,  0xdfff1000, EMAC_NONE, EMAC_NONE}},\t \n\t{{EMAC_NONE,  0xefff2000, EMAC_NONE, EMAC_NONE}},\t \n\t{{EMAC_NONE,  0xcfff0000, EMAC_NONE, EMAC_NONE}},\t \n\t{{EMAC_NONE,  EMAC_NONE,  0xffff0400, EMAC_NONE}},\t \n\t{{EMAC_NONE,  EMAC_NONE,  0xfbff0000, EMAC_NONE}},\t \n\t{{EMAC_NONE,  EMAC_NONE,  0xffff0800, EMAC_NONE}},\t \n\t{{EMAC_NONE,  EMAC_NONE,  0xf7ff0000, EMAC_NONE}},\t \n\t{{EMAC_NONE,  0xffff4000, EMAC_NONE, EMAC_NONE}},\t \n\t{{EMAC_NONE,  0xbfff0000, EMAC_NONE, EMAC_NONE}},\t \n\t{{0xffff0010,  EMAC_NONE, 0xffff0010, EMAC_NONE}},\t \n\t{{0xffef0000,  EMAC_NONE, 0xffef0000, EMAC_NONE}}\t \n};\n\nint emac_set_port_state(struct prueth_emac *emac,\n\t\t\tenum icssg_port_state_cmd cmd)\n{\n\tstruct icssg_r30_cmd __iomem *p;\n\tint ret = -ETIMEDOUT;\n\tint done = 0;\n\tint i;\n\n\tp = emac->dram.va + MGR_R30_CMD_OFFSET;\n\n\tif (cmd >= ICSSG_EMAC_PORT_MAX_COMMANDS) {\n\t\tnetdev_err(emac->ndev, \"invalid port command\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmutex_lock(&emac->cmd_lock);\n\n\tfor (i = 0; i < 4; i++)\n\t\twritel(emac_r32_bitmask[cmd].cmd[i], &p->cmd[i]);\n\n\t \n\tret = read_poll_timeout(emac_r30_is_done, done, done == 1,\n\t\t\t\t1000, 10000, false, emac);\n\n\tif (ret == -ETIMEDOUT)\n\t\tnetdev_err(emac->ndev, \"timeout waiting for command done\\n\");\n\n\tmutex_unlock(&emac->cmd_lock);\n\n\treturn ret;\n}\n\nvoid icssg_config_set_speed(struct prueth_emac *emac)\n{\n\tu8 fw_speed;\n\n\tswitch (emac->speed) {\n\tcase SPEED_1000:\n\t\tfw_speed = FW_LINK_SPEED_1G;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tfw_speed = FW_LINK_SPEED_100M;\n\t\tbreak;\n\tcase SPEED_10:\n\t\tfw_speed = FW_LINK_SPEED_10M;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tnetdev_err(emac->ndev, \"Unsupported link speed\\n\");\n\t\treturn;\n\t}\n\n\twriteb(fw_speed, emac->dram.va + PORT_LINK_SPEED_OFFSET);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}