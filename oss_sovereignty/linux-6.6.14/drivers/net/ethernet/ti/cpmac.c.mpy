{
  "module_name": "cpmac.c",
  "hash_id": "e7e740041560aa43327b4de3b60297b647aeff26f62ba6f7cd201770a482b36e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/cpmac.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n\n#include <linux/netdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/skbuff.h>\n#include <linux/mii.h>\n#include <linux/phy.h>\n#include <linux/phy_fixed.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/clk.h>\n#include <linux/gpio.h>\n#include <linux/atomic.h>\n\n#include <asm/mach-ar7/ar7.h>\n\nMODULE_AUTHOR(\"Eugene Konev <ejka@imfi.kspu.ru>\");\nMODULE_DESCRIPTION(\"TI AR7 ethernet driver (CPMAC)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:cpmac\");\n\nstatic int debug_level = 8;\nstatic int dumb_switch;\n\n \nmodule_param(debug_level, int, 0444);\nmodule_param(dumb_switch, int, 0444);\n\nMODULE_PARM_DESC(debug_level, \"Number of NETIF_MSG bits to enable\");\nMODULE_PARM_DESC(dumb_switch, \"Assume switch is not connected to MDIO bus\");\n\n#define CPMAC_VERSION \"0.5.2\"\n \n#define CPMAC_SKB_SIZE\t\t(ETH_FRAME_LEN + ETH_FCS_LEN + VLAN_HLEN)\n#define CPMAC_QUEUES\t8\n\n \n#define CPMAC_TX_CONTROL\t\t0x0004\n#define CPMAC_TX_TEARDOWN\t\t0x0008\n#define CPMAC_RX_CONTROL\t\t0x0014\n#define CPMAC_RX_TEARDOWN\t\t0x0018\n#define CPMAC_MBP\t\t\t0x0100\n#define MBP_RXPASSCRC\t\t\t0x40000000\n#define MBP_RXQOS\t\t\t0x20000000\n#define MBP_RXNOCHAIN\t\t\t0x10000000\n#define MBP_RXCMF\t\t\t0x01000000\n#define MBP_RXSHORT\t\t\t0x00800000\n#define MBP_RXCEF\t\t\t0x00400000\n#define MBP_RXPROMISC\t\t\t0x00200000\n#define MBP_PROMISCCHAN(channel)\t(((channel) & 0x7) << 16)\n#define MBP_RXBCAST\t\t\t0x00002000\n#define MBP_BCASTCHAN(channel)\t\t(((channel) & 0x7) << 8)\n#define MBP_RXMCAST\t\t\t0x00000020\n#define MBP_MCASTCHAN(channel)\t\t((channel) & 0x7)\n#define CPMAC_UNICAST_ENABLE\t\t0x0104\n#define CPMAC_UNICAST_CLEAR\t\t0x0108\n#define CPMAC_MAX_LENGTH\t\t0x010c\n#define CPMAC_BUFFER_OFFSET\t\t0x0110\n#define CPMAC_MAC_CONTROL\t\t0x0160\n#define MAC_TXPTYPE\t\t\t0x00000200\n#define MAC_TXPACE\t\t\t0x00000040\n#define MAC_MII\t\t\t\t0x00000020\n#define MAC_TXFLOW\t\t\t0x00000010\n#define MAC_RXFLOW\t\t\t0x00000008\n#define MAC_MTEST\t\t\t0x00000004\n#define MAC_LOOPBACK\t\t\t0x00000002\n#define MAC_FDX\t\t\t\t0x00000001\n#define CPMAC_MAC_STATUS\t\t0x0164\n#define MAC_STATUS_QOS\t\t\t0x00000004\n#define MAC_STATUS_RXFLOW\t\t0x00000002\n#define MAC_STATUS_TXFLOW\t\t0x00000001\n#define CPMAC_TX_INT_ENABLE\t\t0x0178\n#define CPMAC_TX_INT_CLEAR\t\t0x017c\n#define CPMAC_MAC_INT_VECTOR\t\t0x0180\n#define MAC_INT_STATUS\t\t\t0x00080000\n#define MAC_INT_HOST\t\t\t0x00040000\n#define MAC_INT_RX\t\t\t0x00020000\n#define MAC_INT_TX\t\t\t0x00010000\n#define CPMAC_MAC_EOI_VECTOR\t\t0x0184\n#define CPMAC_RX_INT_ENABLE\t\t0x0198\n#define CPMAC_RX_INT_CLEAR\t\t0x019c\n#define CPMAC_MAC_INT_ENABLE\t\t0x01a8\n#define CPMAC_MAC_INT_CLEAR\t\t0x01ac\n#define CPMAC_MAC_ADDR_LO(channel)\t(0x01b0 + (channel) * 4)\n#define CPMAC_MAC_ADDR_MID\t\t0x01d0\n#define CPMAC_MAC_ADDR_HI\t\t0x01d4\n#define CPMAC_MAC_HASH_LO\t\t0x01d8\n#define CPMAC_MAC_HASH_HI\t\t0x01dc\n#define CPMAC_TX_PTR(channel)\t\t(0x0600 + (channel) * 4)\n#define CPMAC_RX_PTR(channel)\t\t(0x0620 + (channel) * 4)\n#define CPMAC_TX_ACK(channel)\t\t(0x0640 + (channel) * 4)\n#define CPMAC_RX_ACK(channel)\t\t(0x0660 + (channel) * 4)\n#define CPMAC_REG_END\t\t\t0x0680\n\n \n#define CPMAC_STATS_RX_GOOD\t\t0x0200\n#define CPMAC_STATS_RX_BCAST\t\t0x0204\n#define CPMAC_STATS_RX_MCAST\t\t0x0208\n#define CPMAC_STATS_RX_PAUSE\t\t0x020c\n#define CPMAC_STATS_RX_CRC\t\t0x0210\n#define CPMAC_STATS_RX_ALIGN\t\t0x0214\n#define CPMAC_STATS_RX_OVER\t\t0x0218\n#define CPMAC_STATS_RX_JABBER\t\t0x021c\n#define CPMAC_STATS_RX_UNDER\t\t0x0220\n#define CPMAC_STATS_RX_FRAG\t\t0x0224\n#define CPMAC_STATS_RX_FILTER\t\t0x0228\n#define CPMAC_STATS_RX_QOSFILTER\t0x022c\n#define CPMAC_STATS_RX_OCTETS\t\t0x0230\n\n#define CPMAC_STATS_TX_GOOD\t\t0x0234\n#define CPMAC_STATS_TX_BCAST\t\t0x0238\n#define CPMAC_STATS_TX_MCAST\t\t0x023c\n#define CPMAC_STATS_TX_PAUSE\t\t0x0240\n#define CPMAC_STATS_TX_DEFER\t\t0x0244\n#define CPMAC_STATS_TX_COLLISION\t0x0248\n#define CPMAC_STATS_TX_SINGLECOLL\t0x024c\n#define CPMAC_STATS_TX_MULTICOLL\t0x0250\n#define CPMAC_STATS_TX_EXCESSCOLL\t0x0254\n#define CPMAC_STATS_TX_LATECOLL\t\t0x0258\n#define CPMAC_STATS_TX_UNDERRUN\t\t0x025c\n#define CPMAC_STATS_TX_CARRIERSENSE\t0x0260\n#define CPMAC_STATS_TX_OCTETS\t\t0x0264\n\n#define cpmac_read(base, reg)\t\t(readl((void __iomem *)(base) + (reg)))\n#define cpmac_write(base, reg, val)\t(writel(val, (void __iomem *)(base) + \\\n\t\t\t\t\t\t(reg)))\n\n \n#define CPMAC_MDIO_VERSION\t\t0x0000\n#define CPMAC_MDIO_CONTROL\t\t0x0004\n#define MDIOC_IDLE\t\t\t0x80000000\n#define MDIOC_ENABLE\t\t\t0x40000000\n#define MDIOC_PREAMBLE\t\t\t0x00100000\n#define MDIOC_FAULT\t\t\t0x00080000\n#define MDIOC_FAULTDETECT\t\t0x00040000\n#define MDIOC_INTTEST\t\t\t0x00020000\n#define MDIOC_CLKDIV(div)\t\t((div) & 0xff)\n#define CPMAC_MDIO_ALIVE\t\t0x0008\n#define CPMAC_MDIO_LINK\t\t\t0x000c\n#define CPMAC_MDIO_ACCESS(channel)\t(0x0080 + (channel) * 8)\n#define MDIO_BUSY\t\t\t0x80000000\n#define MDIO_WRITE\t\t\t0x40000000\n#define MDIO_REG(reg)\t\t\t(((reg) & 0x1f) << 21)\n#define MDIO_PHY(phy)\t\t\t(((phy) & 0x1f) << 16)\n#define MDIO_DATA(data)\t\t\t((data) & 0xffff)\n#define CPMAC_MDIO_PHYSEL(channel)\t(0x0084 + (channel) * 8)\n#define PHYSEL_LINKSEL\t\t\t0x00000040\n#define PHYSEL_LINKINT\t\t\t0x00000020\n\nstruct cpmac_desc {\n\tu32 hw_next;\n\tu32 hw_data;\n\tu16 buflen;\n\tu16 bufflags;\n\tu16 datalen;\n\tu16 dataflags;\n#define CPMAC_SOP\t\t\t0x8000\n#define CPMAC_EOP\t\t\t0x4000\n#define CPMAC_OWN\t\t\t0x2000\n#define CPMAC_EOQ\t\t\t0x1000\n\tstruct sk_buff *skb;\n\tstruct cpmac_desc *next;\n\tstruct cpmac_desc *prev;\n\tdma_addr_t mapping;\n\tdma_addr_t data_mapping;\n};\n\nstruct cpmac_priv {\n\tspinlock_t lock;\n\tspinlock_t rx_lock;\n\tstruct cpmac_desc *rx_head;\n\tint ring_size;\n\tstruct cpmac_desc *desc_ring;\n\tdma_addr_t dma_ring;\n\tvoid __iomem *regs;\n\tstruct mii_bus *mii_bus;\n\tchar phy_name[MII_BUS_ID_SIZE + 3];\n\tint oldlink, oldspeed, oldduplex;\n\tu32 msg_enable;\n\tstruct net_device *dev;\n\tstruct work_struct reset_work;\n\tstruct platform_device *pdev;\n\tstruct napi_struct napi;\n\tatomic_t reset_pending;\n};\n\nstatic irqreturn_t cpmac_irq(int, void *);\nstatic void cpmac_hw_start(struct net_device *dev);\nstatic void cpmac_hw_stop(struct net_device *dev);\nstatic int cpmac_stop(struct net_device *dev);\nstatic int cpmac_open(struct net_device *dev);\n\nstatic void cpmac_dump_regs(struct net_device *dev)\n{\n\tint i;\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\n\tfor (i = 0; i < CPMAC_REG_END; i += 4) {\n\t\tif (i % 16 == 0) {\n\t\t\tif (i)\n\t\t\t\tprintk(\"\\n\");\n\t\t\tprintk(\"%s: reg[%p]:\", dev->name, priv->regs + i);\n\t\t}\n\t\tprintk(\" %08x\", cpmac_read(priv->regs, i));\n\t}\n\tprintk(\"\\n\");\n}\n\nstatic void cpmac_dump_desc(struct net_device *dev, struct cpmac_desc *desc)\n{\n\tint i;\n\n\tprintk(\"%s: desc[%p]:\", dev->name, desc);\n\tfor (i = 0; i < sizeof(*desc) / 4; i++)\n\t\tprintk(\" %08x\", ((u32 *)desc)[i]);\n\tprintk(\"\\n\");\n}\n\nstatic void cpmac_dump_all_desc(struct net_device *dev)\n{\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\tstruct cpmac_desc *dump = priv->rx_head;\n\n\tdo {\n\t\tcpmac_dump_desc(dev, dump);\n\t\tdump = dump->next;\n\t} while (dump != priv->rx_head);\n}\n\nstatic void cpmac_dump_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tint i;\n\n\tprintk(\"%s: skb 0x%p, len=%d\\n\", dev->name, skb, skb->len);\n\tfor (i = 0; i < skb->len; i++) {\n\t\tif (i % 16 == 0) {\n\t\t\tif (i)\n\t\t\t\tprintk(\"\\n\");\n\t\t\tprintk(\"%s: data[%p]:\", dev->name, skb->data + i);\n\t\t}\n\t\tprintk(\" %02x\", ((u8 *)skb->data)[i]);\n\t}\n\tprintk(\"\\n\");\n}\n\nstatic int cpmac_mdio_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\tu32 val;\n\n\twhile (cpmac_read(bus->priv, CPMAC_MDIO_ACCESS(0)) & MDIO_BUSY)\n\t\tcpu_relax();\n\tcpmac_write(bus->priv, CPMAC_MDIO_ACCESS(0), MDIO_BUSY | MDIO_REG(reg) |\n\t\t    MDIO_PHY(phy_id));\n\twhile ((val = cpmac_read(bus->priv, CPMAC_MDIO_ACCESS(0))) & MDIO_BUSY)\n\t\tcpu_relax();\n\n\treturn MDIO_DATA(val);\n}\n\nstatic int cpmac_mdio_write(struct mii_bus *bus, int phy_id,\n\t\t\t    int reg, u16 val)\n{\n\twhile (cpmac_read(bus->priv, CPMAC_MDIO_ACCESS(0)) & MDIO_BUSY)\n\t\tcpu_relax();\n\tcpmac_write(bus->priv, CPMAC_MDIO_ACCESS(0), MDIO_BUSY | MDIO_WRITE |\n\t\t    MDIO_REG(reg) | MDIO_PHY(phy_id) | MDIO_DATA(val));\n\n\treturn 0;\n}\n\nstatic int cpmac_mdio_reset(struct mii_bus *bus)\n{\n\tstruct clk *cpmac_clk;\n\n\tcpmac_clk = clk_get(&bus->dev, \"cpmac\");\n\tif (IS_ERR(cpmac_clk)) {\n\t\tpr_err(\"unable to get cpmac clock\\n\");\n\t\treturn -1;\n\t}\n\tar7_device_reset(AR7_RESET_BIT_MDIO);\n\tcpmac_write(bus->priv, CPMAC_MDIO_CONTROL, MDIOC_ENABLE |\n\t\t    MDIOC_CLKDIV(clk_get_rate(cpmac_clk) / 2200000 - 1));\n\n\treturn 0;\n}\n\nstatic struct mii_bus *cpmac_mii;\n\nstatic void cpmac_set_multicast_list(struct net_device *dev)\n{\n\tstruct netdev_hw_addr *ha;\n\tu8 tmp;\n\tu32 mbp, bit, hash[2] = { 0, };\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\n\tmbp = cpmac_read(priv->regs, CPMAC_MBP);\n\tif (dev->flags & IFF_PROMISC) {\n\t\tcpmac_write(priv->regs, CPMAC_MBP, (mbp & ~MBP_PROMISCCHAN(0)) |\n\t\t\t    MBP_RXPROMISC);\n\t} else {\n\t\tcpmac_write(priv->regs, CPMAC_MBP, mbp & ~MBP_RXPROMISC);\n\t\tif (dev->flags & IFF_ALLMULTI) {\n\t\t\t \n\t\t\tcpmac_write(priv->regs, CPMAC_MAC_HASH_LO, 0xffffffff);\n\t\t\tcpmac_write(priv->regs, CPMAC_MAC_HASH_HI, 0xffffffff);\n\t\t} else {\n\t\t\t \n\t\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t\tbit = 0;\n\t\t\t\ttmp = ha->addr[0];\n\t\t\t\tbit  ^= (tmp >> 2) ^ (tmp << 4);\n\t\t\t\ttmp = ha->addr[1];\n\t\t\t\tbit  ^= (tmp >> 4) ^ (tmp << 2);\n\t\t\t\ttmp = ha->addr[2];\n\t\t\t\tbit  ^= (tmp >> 6) ^ tmp;\n\t\t\t\ttmp = ha->addr[3];\n\t\t\t\tbit  ^= (tmp >> 2) ^ (tmp << 4);\n\t\t\t\ttmp = ha->addr[4];\n\t\t\t\tbit  ^= (tmp >> 4) ^ (tmp << 2);\n\t\t\t\ttmp = ha->addr[5];\n\t\t\t\tbit  ^= (tmp >> 6) ^ tmp;\n\t\t\t\tbit &= 0x3f;\n\t\t\t\thash[bit / 32] |= 1 << (bit % 32);\n\t\t\t}\n\n\t\t\tcpmac_write(priv->regs, CPMAC_MAC_HASH_LO, hash[0]);\n\t\t\tcpmac_write(priv->regs, CPMAC_MAC_HASH_HI, hash[1]);\n\t\t}\n\t}\n}\n\nstatic struct sk_buff *cpmac_rx_one(struct cpmac_priv *priv,\n\t\t\t\t    struct cpmac_desc *desc)\n{\n\tstruct sk_buff *skb, *result = NULL;\n\n\tif (unlikely(netif_msg_hw(priv)))\n\t\tcpmac_dump_desc(priv->dev, desc);\n\tcpmac_write(priv->regs, CPMAC_RX_ACK(0), (u32)desc->mapping);\n\tif (unlikely(!desc->datalen)) {\n\t\tif (netif_msg_rx_err(priv) && net_ratelimit())\n\t\t\tnetdev_warn(priv->dev, \"rx: spurious interrupt\\n\");\n\n\t\treturn NULL;\n\t}\n\n\tskb = netdev_alloc_skb_ip_align(priv->dev, CPMAC_SKB_SIZE);\n\tif (likely(skb)) {\n\t\tskb_put(desc->skb, desc->datalen);\n\t\tdesc->skb->protocol = eth_type_trans(desc->skb, priv->dev);\n\t\tskb_checksum_none_assert(desc->skb);\n\t\tpriv->dev->stats.rx_packets++;\n\t\tpriv->dev->stats.rx_bytes += desc->datalen;\n\t\tresult = desc->skb;\n\t\tdma_unmap_single(&priv->dev->dev, desc->data_mapping,\n\t\t\t\t CPMAC_SKB_SIZE, DMA_FROM_DEVICE);\n\t\tdesc->skb = skb;\n\t\tdesc->data_mapping = dma_map_single(&priv->dev->dev, skb->data,\n\t\t\t\t\t\t    CPMAC_SKB_SIZE,\n\t\t\t\t\t\t    DMA_FROM_DEVICE);\n\t\tdesc->hw_data = (u32)desc->data_mapping;\n\t\tif (unlikely(netif_msg_pktdata(priv))) {\n\t\t\tnetdev_dbg(priv->dev, \"received packet:\\n\");\n\t\t\tcpmac_dump_skb(priv->dev, result);\n\t\t}\n\t} else {\n\t\tif (netif_msg_rx_err(priv) && net_ratelimit())\n\t\t\tnetdev_warn(priv->dev,\n\t\t\t\t    \"low on skbs, dropping packet\\n\");\n\n\t\tpriv->dev->stats.rx_dropped++;\n\t}\n\n\tdesc->buflen = CPMAC_SKB_SIZE;\n\tdesc->dataflags = CPMAC_OWN;\n\n\treturn result;\n}\n\nstatic int cpmac_poll(struct napi_struct *napi, int budget)\n{\n\tstruct sk_buff *skb;\n\tstruct cpmac_desc *desc, *restart;\n\tstruct cpmac_priv *priv = container_of(napi, struct cpmac_priv, napi);\n\tint received = 0, processed = 0;\n\n\tspin_lock(&priv->rx_lock);\n\tif (unlikely(!priv->rx_head)) {\n\t\tif (netif_msg_rx_err(priv) && net_ratelimit())\n\t\t\tnetdev_warn(priv->dev, \"rx: polling, but no queue\\n\");\n\n\t\tspin_unlock(&priv->rx_lock);\n\t\tnapi_complete(napi);\n\t\treturn 0;\n\t}\n\n\tdesc = priv->rx_head;\n\trestart = NULL;\n\twhile (((desc->dataflags & CPMAC_OWN) == 0) && (received < budget)) {\n\t\tprocessed++;\n\n\t\tif ((desc->dataflags & CPMAC_EOQ) != 0) {\n\t\t\t \n\t\t\tif (unlikely(restart)) {\n\t\t\t\tif (netif_msg_rx_err(priv))\n\t\t\t\t\tnetdev_err(priv->dev, \"poll found a\"\n\t\t\t\t\t\t   \" duplicate EOQ: %p and %p\\n\",\n\t\t\t\t\t\t   restart, desc);\n\t\t\t\tgoto fatal_error;\n\t\t\t}\n\n\t\t\trestart = desc->next;\n\t\t}\n\n\t\tskb = cpmac_rx_one(priv, desc);\n\t\tif (likely(skb)) {\n\t\t\tnetif_receive_skb(skb);\n\t\t\treceived++;\n\t\t}\n\t\tdesc = desc->next;\n\t}\n\n\tif (desc != priv->rx_head) {\n\t\t \n\t\tdesc->prev->hw_next = (u32)0;\n\t\tpriv->rx_head->prev->hw_next = priv->rx_head->mapping;\n\t}\n\n\t \n\n\tif (!restart &&\n\t     (priv->rx_head->prev->dataflags & (CPMAC_OWN|CPMAC_EOQ))\n\t\t    == CPMAC_EOQ &&\n\t     (priv->rx_head->dataflags & CPMAC_OWN) != 0) {\n\t\t \n\t\tpriv->rx_head->prev->dataflags &= ~CPMAC_EOQ;\n\t\trestart = priv->rx_head;\n\t}\n\n\tif (restart) {\n\t\tpriv->dev->stats.rx_errors++;\n\t\tpriv->dev->stats.rx_fifo_errors++;\n\t\tif (netif_msg_rx_err(priv) && net_ratelimit())\n\t\t\tnetdev_warn(priv->dev, \"rx dma ring overrun\\n\");\n\n\t\tif (unlikely((restart->dataflags & CPMAC_OWN) == 0)) {\n\t\t\tif (netif_msg_drv(priv))\n\t\t\t\tnetdev_err(priv->dev, \"cpmac_poll is trying \"\n\t\t\t\t\t\"to restart rx from a descriptor \"\n\t\t\t\t\t\"that's not free: %p\\n\", restart);\n\t\t\tgoto fatal_error;\n\t\t}\n\n\t\tcpmac_write(priv->regs, CPMAC_RX_PTR(0), restart->mapping);\n\t}\n\n\tpriv->rx_head = desc;\n\tspin_unlock(&priv->rx_lock);\n\tif (unlikely(netif_msg_rx_status(priv)))\n\t\tnetdev_dbg(priv->dev, \"poll processed %d packets\\n\", received);\n\n\tif (processed == 0) {\n\t\t \n\t\tnapi_complete(napi);\n\t\tcpmac_write(priv->regs, CPMAC_RX_INT_ENABLE, 1);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n\nfatal_error:\n\t \n\tif (netif_msg_drv(priv)) {\n\t\tnetdev_err(priv->dev, \"cpmac_poll is confused. \"\n\t\t\t   \"Resetting hardware\\n\");\n\t\tcpmac_dump_all_desc(priv->dev);\n\t\tnetdev_dbg(priv->dev, \"RX_PTR(0)=0x%08x RX_ACK(0)=0x%08x\\n\",\n\t\t\t   cpmac_read(priv->regs, CPMAC_RX_PTR(0)),\n\t\t\t   cpmac_read(priv->regs, CPMAC_RX_ACK(0)));\n\t}\n\n\tspin_unlock(&priv->rx_lock);\n\tnapi_complete(napi);\n\tnetif_tx_stop_all_queues(priv->dev);\n\tnapi_disable(&priv->napi);\n\n\tatomic_inc(&priv->reset_pending);\n\tcpmac_hw_stop(priv->dev);\n\tif (!schedule_work(&priv->reset_work))\n\t\tatomic_dec(&priv->reset_pending);\n\n\treturn 0;\n\n}\n\nstatic netdev_tx_t cpmac_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tint queue;\n\tunsigned int len;\n\tstruct cpmac_desc *desc;\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\n\tif (unlikely(atomic_read(&priv->reset_pending)))\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (unlikely(skb_padto(skb, ETH_ZLEN)))\n\t\treturn NETDEV_TX_OK;\n\n\tlen = max_t(unsigned int, skb->len, ETH_ZLEN);\n\tqueue = skb_get_queue_mapping(skb);\n\tnetif_stop_subqueue(dev, queue);\n\n\tdesc = &priv->desc_ring[queue];\n\tif (unlikely(desc->dataflags & CPMAC_OWN)) {\n\t\tif (netif_msg_tx_err(priv) && net_ratelimit())\n\t\t\tnetdev_warn(dev, \"tx dma ring full\\n\");\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tspin_lock(&priv->lock);\n\tspin_unlock(&priv->lock);\n\tdesc->dataflags = CPMAC_SOP | CPMAC_EOP | CPMAC_OWN;\n\tdesc->skb = skb;\n\tdesc->data_mapping = dma_map_single(&dev->dev, skb->data, len,\n\t\t\t\t\t    DMA_TO_DEVICE);\n\tdesc->hw_data = (u32)desc->data_mapping;\n\tdesc->datalen = len;\n\tdesc->buflen = len;\n\tif (unlikely(netif_msg_tx_queued(priv)))\n\t\tnetdev_dbg(dev, \"sending 0x%p, len=%d\\n\", skb, skb->len);\n\tif (unlikely(netif_msg_hw(priv)))\n\t\tcpmac_dump_desc(dev, desc);\n\tif (unlikely(netif_msg_pktdata(priv)))\n\t\tcpmac_dump_skb(dev, skb);\n\tcpmac_write(priv->regs, CPMAC_TX_PTR(queue), (u32)desc->mapping);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void cpmac_end_xmit(struct net_device *dev, int queue)\n{\n\tstruct cpmac_desc *desc;\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\n\tdesc = &priv->desc_ring[queue];\n\tcpmac_write(priv->regs, CPMAC_TX_ACK(queue), (u32)desc->mapping);\n\tif (likely(desc->skb)) {\n\t\tspin_lock(&priv->lock);\n\t\tdev->stats.tx_packets++;\n\t\tdev->stats.tx_bytes += desc->skb->len;\n\t\tspin_unlock(&priv->lock);\n\t\tdma_unmap_single(&dev->dev, desc->data_mapping, desc->skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\n\t\tif (unlikely(netif_msg_tx_done(priv)))\n\t\t\tnetdev_dbg(dev, \"sent 0x%p, len=%d\\n\",\n\t\t\t\t   desc->skb, desc->skb->len);\n\n\t\tdev_consume_skb_irq(desc->skb);\n\t\tdesc->skb = NULL;\n\t\tif (__netif_subqueue_stopped(dev, queue))\n\t\t\tnetif_wake_subqueue(dev, queue);\n\t} else {\n\t\tif (netif_msg_tx_err(priv) && net_ratelimit())\n\t\t\tnetdev_warn(dev, \"end_xmit: spurious interrupt\\n\");\n\t\tif (__netif_subqueue_stopped(dev, queue))\n\t\t\tnetif_wake_subqueue(dev, queue);\n\t}\n}\n\nstatic void cpmac_hw_stop(struct net_device *dev)\n{\n\tint i;\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\tstruct plat_cpmac_data *pdata = dev_get_platdata(&priv->pdev->dev);\n\n\tar7_device_reset(pdata->reset_bit);\n\tcpmac_write(priv->regs, CPMAC_RX_CONTROL,\n\t\t    cpmac_read(priv->regs, CPMAC_RX_CONTROL) & ~1);\n\tcpmac_write(priv->regs, CPMAC_TX_CONTROL,\n\t\t    cpmac_read(priv->regs, CPMAC_TX_CONTROL) & ~1);\n\tfor (i = 0; i < 8; i++) {\n\t\tcpmac_write(priv->regs, CPMAC_TX_PTR(i), 0);\n\t\tcpmac_write(priv->regs, CPMAC_RX_PTR(i), 0);\n\t}\n\tcpmac_write(priv->regs, CPMAC_UNICAST_CLEAR, 0xff);\n\tcpmac_write(priv->regs, CPMAC_RX_INT_CLEAR, 0xff);\n\tcpmac_write(priv->regs, CPMAC_TX_INT_CLEAR, 0xff);\n\tcpmac_write(priv->regs, CPMAC_MAC_INT_CLEAR, 0xff);\n\tcpmac_write(priv->regs, CPMAC_MAC_CONTROL,\n\t\t    cpmac_read(priv->regs, CPMAC_MAC_CONTROL) & ~MAC_MII);\n}\n\nstatic void cpmac_hw_start(struct net_device *dev)\n{\n\tint i;\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\tstruct plat_cpmac_data *pdata = dev_get_platdata(&priv->pdev->dev);\n\n\tar7_device_reset(pdata->reset_bit);\n\tfor (i = 0; i < 8; i++) {\n\t\tcpmac_write(priv->regs, CPMAC_TX_PTR(i), 0);\n\t\tcpmac_write(priv->regs, CPMAC_RX_PTR(i), 0);\n\t}\n\tcpmac_write(priv->regs, CPMAC_RX_PTR(0), priv->rx_head->mapping);\n\n\tcpmac_write(priv->regs, CPMAC_MBP, MBP_RXSHORT | MBP_RXBCAST |\n\t\t    MBP_RXMCAST);\n\tcpmac_write(priv->regs, CPMAC_BUFFER_OFFSET, 0);\n\tfor (i = 0; i < 8; i++)\n\t\tcpmac_write(priv->regs, CPMAC_MAC_ADDR_LO(i), dev->dev_addr[5]);\n\tcpmac_write(priv->regs, CPMAC_MAC_ADDR_MID, dev->dev_addr[4]);\n\tcpmac_write(priv->regs, CPMAC_MAC_ADDR_HI, dev->dev_addr[0] |\n\t\t    (dev->dev_addr[1] << 8) | (dev->dev_addr[2] << 16) |\n\t\t    (dev->dev_addr[3] << 24));\n\tcpmac_write(priv->regs, CPMAC_MAX_LENGTH, CPMAC_SKB_SIZE);\n\tcpmac_write(priv->regs, CPMAC_UNICAST_CLEAR, 0xff);\n\tcpmac_write(priv->regs, CPMAC_RX_INT_CLEAR, 0xff);\n\tcpmac_write(priv->regs, CPMAC_TX_INT_CLEAR, 0xff);\n\tcpmac_write(priv->regs, CPMAC_MAC_INT_CLEAR, 0xff);\n\tcpmac_write(priv->regs, CPMAC_UNICAST_ENABLE, 1);\n\tcpmac_write(priv->regs, CPMAC_RX_INT_ENABLE, 1);\n\tcpmac_write(priv->regs, CPMAC_TX_INT_ENABLE, 0xff);\n\tcpmac_write(priv->regs, CPMAC_MAC_INT_ENABLE, 3);\n\n\tcpmac_write(priv->regs, CPMAC_RX_CONTROL,\n\t\t    cpmac_read(priv->regs, CPMAC_RX_CONTROL) | 1);\n\tcpmac_write(priv->regs, CPMAC_TX_CONTROL,\n\t\t    cpmac_read(priv->regs, CPMAC_TX_CONTROL) | 1);\n\tcpmac_write(priv->regs, CPMAC_MAC_CONTROL,\n\t\t    cpmac_read(priv->regs, CPMAC_MAC_CONTROL) | MAC_MII |\n\t\t    MAC_FDX);\n}\n\nstatic void cpmac_clear_rx(struct net_device *dev)\n{\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\tstruct cpmac_desc *desc;\n\tint i;\n\n\tif (unlikely(!priv->rx_head))\n\t\treturn;\n\tdesc = priv->rx_head;\n\tfor (i = 0; i < priv->ring_size; i++) {\n\t\tif ((desc->dataflags & CPMAC_OWN) == 0) {\n\t\t\tif (netif_msg_rx_err(priv) && net_ratelimit())\n\t\t\t\tnetdev_warn(dev, \"packet dropped\\n\");\n\t\t\tif (unlikely(netif_msg_hw(priv)))\n\t\t\t\tcpmac_dump_desc(dev, desc);\n\t\t\tdesc->dataflags = CPMAC_OWN;\n\t\t\tdev->stats.rx_dropped++;\n\t\t}\n\t\tdesc->hw_next = desc->next->mapping;\n\t\tdesc = desc->next;\n\t}\n\tpriv->rx_head->prev->hw_next = 0;\n}\n\nstatic void cpmac_clear_tx(struct net_device *dev)\n{\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\tint i;\n\n\tif (unlikely(!priv->desc_ring))\n\t\treturn;\n\tfor (i = 0; i < CPMAC_QUEUES; i++) {\n\t\tpriv->desc_ring[i].dataflags = 0;\n\t\tif (priv->desc_ring[i].skb) {\n\t\t\tdev_kfree_skb_any(priv->desc_ring[i].skb);\n\t\t\tpriv->desc_ring[i].skb = NULL;\n\t\t}\n\t}\n}\n\nstatic void cpmac_hw_error(struct work_struct *work)\n{\n\tstruct cpmac_priv *priv =\n\t\tcontainer_of(work, struct cpmac_priv, reset_work);\n\n\tspin_lock(&priv->rx_lock);\n\tcpmac_clear_rx(priv->dev);\n\tspin_unlock(&priv->rx_lock);\n\tcpmac_clear_tx(priv->dev);\n\tcpmac_hw_start(priv->dev);\n\tbarrier();\n\tatomic_dec(&priv->reset_pending);\n\n\tnetif_tx_wake_all_queues(priv->dev);\n\tcpmac_write(priv->regs, CPMAC_MAC_INT_ENABLE, 3);\n}\n\nstatic void cpmac_check_status(struct net_device *dev)\n{\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\n\tu32 macstatus = cpmac_read(priv->regs, CPMAC_MAC_STATUS);\n\tint rx_channel = (macstatus >> 8) & 7;\n\tint rx_code = (macstatus >> 12) & 15;\n\tint tx_channel = (macstatus >> 16) & 7;\n\tint tx_code = (macstatus >> 20) & 15;\n\n\tif (rx_code || tx_code) {\n\t\tif (netif_msg_drv(priv) && net_ratelimit()) {\n\t\t\t \n\t\t\tif (rx_code)\n\t\t\t\tnetdev_warn(dev, \"host error %d on rx \"\n\t\t\t\t\t\"channel %d (macstatus %08x), resetting\\n\",\n\t\t\t\t\trx_code, rx_channel, macstatus);\n\t\t\tif (tx_code)\n\t\t\t\tnetdev_warn(dev, \"host error %d on tx \"\n\t\t\t\t\t\"channel %d (macstatus %08x), resetting\\n\",\n\t\t\t\t\ttx_code, tx_channel, macstatus);\n\t\t}\n\n\t\tnetif_tx_stop_all_queues(dev);\n\t\tcpmac_hw_stop(dev);\n\t\tif (schedule_work(&priv->reset_work))\n\t\t\tatomic_inc(&priv->reset_pending);\n\t\tif (unlikely(netif_msg_hw(priv)))\n\t\t\tcpmac_dump_regs(dev);\n\t}\n\tcpmac_write(priv->regs, CPMAC_MAC_INT_CLEAR, 0xff);\n}\n\nstatic irqreturn_t cpmac_irq(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct cpmac_priv *priv;\n\tint queue;\n\tu32 status;\n\n\tpriv = netdev_priv(dev);\n\n\tstatus = cpmac_read(priv->regs, CPMAC_MAC_INT_VECTOR);\n\n\tif (unlikely(netif_msg_intr(priv)))\n\t\tnetdev_dbg(dev, \"interrupt status: 0x%08x\\n\", status);\n\n\tif (status & MAC_INT_TX)\n\t\tcpmac_end_xmit(dev, (status & 7));\n\n\tif (status & MAC_INT_RX) {\n\t\tqueue = (status >> 8) & 7;\n\t\tif (napi_schedule_prep(&priv->napi)) {\n\t\t\tcpmac_write(priv->regs, CPMAC_RX_INT_CLEAR, 1 << queue);\n\t\t\t__napi_schedule(&priv->napi);\n\t\t}\n\t}\n\n\tcpmac_write(priv->regs, CPMAC_MAC_EOI_VECTOR, 0);\n\n\tif (unlikely(status & (MAC_INT_HOST | MAC_INT_STATUS)))\n\t\tcpmac_check_status(dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void cpmac_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\n\tspin_lock(&priv->lock);\n\tdev->stats.tx_errors++;\n\tspin_unlock(&priv->lock);\n\tif (netif_msg_tx_err(priv) && net_ratelimit())\n\t\tnetdev_warn(dev, \"transmit timeout\\n\");\n\n\tatomic_inc(&priv->reset_pending);\n\tbarrier();\n\tcpmac_clear_tx(dev);\n\tbarrier();\n\tatomic_dec(&priv->reset_pending);\n\n\tnetif_tx_wake_all_queues(priv->dev);\n}\n\nstatic void cpmac_get_ringparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_ringparam *ring,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\n\tring->rx_max_pending = 1024;\n\tring->rx_mini_max_pending = 1;\n\tring->rx_jumbo_max_pending = 1;\n\tring->tx_max_pending = 1;\n\n\tring->rx_pending = priv->ring_size;\n\tring->rx_mini_pending = 1;\n\tring->rx_jumbo_pending = 1;\n\tring->tx_pending = 1;\n}\n\nstatic int cpmac_set_ringparam(struct net_device *dev,\n\t\t\t       struct ethtool_ringparam *ring,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\tpriv->ring_size = ring->rx_pending;\n\n\treturn 0;\n}\n\nstatic void cpmac_get_drvinfo(struct net_device *dev,\n\t\t\t      struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, \"cpmac\", sizeof(info->driver));\n\tstrscpy(info->version, CPMAC_VERSION, sizeof(info->version));\n\tsnprintf(info->bus_info, sizeof(info->bus_info), \"%s\", \"cpmac\");\n}\n\nstatic const struct ethtool_ops cpmac_ethtool_ops = {\n\t.get_drvinfo = cpmac_get_drvinfo,\n\t.get_link = ethtool_op_get_link,\n\t.get_ringparam = cpmac_get_ringparam,\n\t.set_ringparam = cpmac_set_ringparam,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\nstatic void cpmac_adjust_link(struct net_device *dev)\n{\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\tint new_state = 0;\n\n\tspin_lock(&priv->lock);\n\tif (dev->phydev->link) {\n\t\tnetif_tx_start_all_queues(dev);\n\t\tif (dev->phydev->duplex != priv->oldduplex) {\n\t\t\tnew_state = 1;\n\t\t\tpriv->oldduplex = dev->phydev->duplex;\n\t\t}\n\n\t\tif (dev->phydev->speed != priv->oldspeed) {\n\t\t\tnew_state = 1;\n\t\t\tpriv->oldspeed = dev->phydev->speed;\n\t\t}\n\n\t\tif (!priv->oldlink) {\n\t\t\tnew_state = 1;\n\t\t\tpriv->oldlink = 1;\n\t\t}\n\t} else if (priv->oldlink) {\n\t\tnew_state = 1;\n\t\tpriv->oldlink = 0;\n\t\tpriv->oldspeed = 0;\n\t\tpriv->oldduplex = -1;\n\t}\n\n\tif (new_state && netif_msg_link(priv) && net_ratelimit())\n\t\tphy_print_status(dev->phydev);\n\n\tspin_unlock(&priv->lock);\n}\n\nstatic int cpmac_open(struct net_device *dev)\n{\n\tint i, size, res;\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\tstruct resource *mem;\n\tstruct cpmac_desc *desc;\n\tstruct sk_buff *skb;\n\n\tmem = platform_get_resource_byname(priv->pdev, IORESOURCE_MEM, \"regs\");\n\tif (!request_mem_region(mem->start, resource_size(mem), dev->name)) {\n\t\tif (netif_msg_drv(priv))\n\t\t\tnetdev_err(dev, \"failed to request registers\\n\");\n\n\t\tres = -ENXIO;\n\t\tgoto fail_reserve;\n\t}\n\n\tpriv->regs = ioremap(mem->start, resource_size(mem));\n\tif (!priv->regs) {\n\t\tif (netif_msg_drv(priv))\n\t\t\tnetdev_err(dev, \"failed to remap registers\\n\");\n\n\t\tres = -ENXIO;\n\t\tgoto fail_remap;\n\t}\n\n\tsize = priv->ring_size + CPMAC_QUEUES;\n\tpriv->desc_ring = dma_alloc_coherent(&dev->dev,\n\t\t\t\t\t     sizeof(struct cpmac_desc) * size,\n\t\t\t\t\t     &priv->dma_ring,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!priv->desc_ring) {\n\t\tres = -ENOMEM;\n\t\tgoto fail_alloc;\n\t}\n\n\tfor (i = 0; i < size; i++)\n\t\tpriv->desc_ring[i].mapping = priv->dma_ring + sizeof(*desc) * i;\n\n\tpriv->rx_head = &priv->desc_ring[CPMAC_QUEUES];\n\tfor (i = 0, desc = priv->rx_head; i < priv->ring_size; i++, desc++) {\n\t\tskb = netdev_alloc_skb_ip_align(dev, CPMAC_SKB_SIZE);\n\t\tif (unlikely(!skb)) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto fail_desc;\n\t\t}\n\t\tdesc->skb = skb;\n\t\tdesc->data_mapping = dma_map_single(&dev->dev, skb->data,\n\t\t\t\t\t\t    CPMAC_SKB_SIZE,\n\t\t\t\t\t\t    DMA_FROM_DEVICE);\n\t\tdesc->hw_data = (u32)desc->data_mapping;\n\t\tdesc->buflen = CPMAC_SKB_SIZE;\n\t\tdesc->dataflags = CPMAC_OWN;\n\t\tdesc->next = &priv->rx_head[(i + 1) % priv->ring_size];\n\t\tdesc->next->prev = desc;\n\t\tdesc->hw_next = (u32)desc->next->mapping;\n\t}\n\n\tpriv->rx_head->prev->hw_next = (u32)0;\n\n\tres = request_irq(dev->irq, cpmac_irq, IRQF_SHARED, dev->name, dev);\n\tif (res) {\n\t\tif (netif_msg_drv(priv))\n\t\t\tnetdev_err(dev, \"failed to obtain irq\\n\");\n\n\t\tgoto fail_irq;\n\t}\n\n\tatomic_set(&priv->reset_pending, 0);\n\tINIT_WORK(&priv->reset_work, cpmac_hw_error);\n\tcpmac_hw_start(dev);\n\n\tnapi_enable(&priv->napi);\n\tphy_start(dev->phydev);\n\n\treturn 0;\n\nfail_irq:\nfail_desc:\n\tfor (i = 0; i < priv->ring_size; i++) {\n\t\tif (priv->rx_head[i].skb) {\n\t\t\tdma_unmap_single(&dev->dev,\n\t\t\t\t\t priv->rx_head[i].data_mapping,\n\t\t\t\t\t CPMAC_SKB_SIZE,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tkfree_skb(priv->rx_head[i].skb);\n\t\t}\n\t}\n\tdma_free_coherent(&dev->dev, sizeof(struct cpmac_desc) * size,\n\t\t\t  priv->desc_ring, priv->dma_ring);\n\nfail_alloc:\n\tiounmap(priv->regs);\n\nfail_remap:\n\trelease_mem_region(mem->start, resource_size(mem));\n\nfail_reserve:\n\treturn res;\n}\n\nstatic int cpmac_stop(struct net_device *dev)\n{\n\tint i;\n\tstruct cpmac_priv *priv = netdev_priv(dev);\n\tstruct resource *mem;\n\n\tnetif_tx_stop_all_queues(dev);\n\n\tcancel_work_sync(&priv->reset_work);\n\tnapi_disable(&priv->napi);\n\tphy_stop(dev->phydev);\n\n\tcpmac_hw_stop(dev);\n\n\tfor (i = 0; i < 8; i++)\n\t\tcpmac_write(priv->regs, CPMAC_TX_PTR(i), 0);\n\tcpmac_write(priv->regs, CPMAC_RX_PTR(0), 0);\n\tcpmac_write(priv->regs, CPMAC_MBP, 0);\n\n\tfree_irq(dev->irq, dev);\n\tiounmap(priv->regs);\n\tmem = platform_get_resource_byname(priv->pdev, IORESOURCE_MEM, \"regs\");\n\trelease_mem_region(mem->start, resource_size(mem));\n\tpriv->rx_head = &priv->desc_ring[CPMAC_QUEUES];\n\tfor (i = 0; i < priv->ring_size; i++) {\n\t\tif (priv->rx_head[i].skb) {\n\t\t\tdma_unmap_single(&dev->dev,\n\t\t\t\t\t priv->rx_head[i].data_mapping,\n\t\t\t\t\t CPMAC_SKB_SIZE,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tkfree_skb(priv->rx_head[i].skb);\n\t\t}\n\t}\n\n\tdma_free_coherent(&dev->dev, sizeof(struct cpmac_desc) *\n\t\t\t  (CPMAC_QUEUES + priv->ring_size),\n\t\t\t  priv->desc_ring, priv->dma_ring);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops cpmac_netdev_ops = {\n\t.ndo_open\t\t= cpmac_open,\n\t.ndo_stop\t\t= cpmac_stop,\n\t.ndo_start_xmit\t\t= cpmac_start_xmit,\n\t.ndo_tx_timeout\t\t= cpmac_tx_timeout,\n\t.ndo_set_rx_mode\t= cpmac_set_multicast_list,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl_running,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n};\n\nstatic int external_switch;\n\nstatic int cpmac_probe(struct platform_device *pdev)\n{\n\tint rc, phy_id;\n\tchar mdio_bus_id[MII_BUS_ID_SIZE];\n\tstruct resource *mem;\n\tstruct cpmac_priv *priv;\n\tstruct net_device *dev;\n\tstruct plat_cpmac_data *pdata;\n\tstruct phy_device *phydev = NULL;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\n\tif (external_switch || dumb_switch) {\n\t\tstrncpy(mdio_bus_id, \"fixed-0\", MII_BUS_ID_SIZE);  \n\t\tphy_id = pdev->id;\n\t} else {\n\t\tfor (phy_id = 0; phy_id < PHY_MAX_ADDR; phy_id++) {\n\t\t\tif (!(pdata->phy_mask & (1 << phy_id)))\n\t\t\t\tcontinue;\n\t\t\tif (!mdiobus_get_phy(cpmac_mii, phy_id))\n\t\t\t\tcontinue;\n\t\t\tstrncpy(mdio_bus_id, cpmac_mii->id, MII_BUS_ID_SIZE);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (phy_id == PHY_MAX_ADDR) {\n\t\tdev_err(&pdev->dev, \"no PHY present, falling back \"\n\t\t\t\"to switch on MDIO bus 0\\n\");\n\t\tstrncpy(mdio_bus_id, \"fixed-0\", MII_BUS_ID_SIZE);  \n\t\tphy_id = pdev->id;\n\t}\n\tmdio_bus_id[sizeof(mdio_bus_id) - 1] = '\\0';\n\n\tdev = alloc_etherdev_mq(sizeof(*priv), CPMAC_QUEUES);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tplatform_set_drvdata(pdev, dev);\n\tpriv = netdev_priv(dev);\n\n\tpriv->pdev = pdev;\n\tmem = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"regs\");\n\tif (!mem) {\n\t\trc = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tdev->irq = platform_get_irq_byname(pdev, \"irq\");\n\n\tdev->netdev_ops = &cpmac_netdev_ops;\n\tdev->ethtool_ops = &cpmac_ethtool_ops;\n\n\tnetif_napi_add(dev, &priv->napi, cpmac_poll);\n\n\tspin_lock_init(&priv->lock);\n\tspin_lock_init(&priv->rx_lock);\n\tpriv->dev = dev;\n\tpriv->ring_size = 64;\n\tpriv->msg_enable = netif_msg_init(debug_level, 0xff);\n\teth_hw_addr_set(dev, pdata->dev_addr);\n\n\tsnprintf(priv->phy_name, MII_BUS_ID_SIZE, PHY_ID_FMT,\n\t\t\t\t\t\tmdio_bus_id, phy_id);\n\n\tphydev = phy_connect(dev, priv->phy_name, cpmac_adjust_link,\n\t\t\t     PHY_INTERFACE_MODE_MII);\n\n\tif (IS_ERR(phydev)) {\n\t\tif (netif_msg_drv(priv))\n\t\t\tdev_err(&pdev->dev, \"Could not attach to PHY\\n\");\n\n\t\trc = PTR_ERR(phydev);\n\t\tgoto fail;\n\t}\n\n\trc = register_netdev(dev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Could not register net device\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (netif_msg_probe(priv)) {\n\t\tdev_info(&pdev->dev, \"regs: %p, irq: %d, phy: %s, \"\n\t\t\t \"mac: %pM\\n\", (void *)mem->start, dev->irq,\n\t\t\t priv->phy_name, dev->dev_addr);\n\t}\n\n\treturn 0;\n\nfail:\n\tfree_netdev(dev);\n\treturn rc;\n}\n\nstatic int cpmac_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\n\tunregister_netdev(dev);\n\tfree_netdev(dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver cpmac_driver = {\n\t.driver = {\n\t\t.name \t= \"cpmac\",\n\t},\n\t.probe \t= cpmac_probe,\n\t.remove = cpmac_remove,\n};\n\nint __init cpmac_init(void)\n{\n\tu32 mask;\n\tint i, res;\n\n\tcpmac_mii = mdiobus_alloc();\n\tif (cpmac_mii == NULL)\n\t\treturn -ENOMEM;\n\n\tcpmac_mii->name = \"cpmac-mii\";\n\tcpmac_mii->read = cpmac_mdio_read;\n\tcpmac_mii->write = cpmac_mdio_write;\n\tcpmac_mii->reset = cpmac_mdio_reset;\n\n\tcpmac_mii->priv = ioremap(AR7_REGS_MDIO, 256);\n\n\tif (!cpmac_mii->priv) {\n\t\tpr_err(\"Can't ioremap mdio registers\\n\");\n\t\tres = -ENXIO;\n\t\tgoto fail_alloc;\n\t}\n\n\t \n\tar7_gpio_disable(26);\n\tar7_gpio_disable(27);\n\tar7_device_reset(AR7_RESET_BIT_CPMAC_LO);\n\tar7_device_reset(AR7_RESET_BIT_CPMAC_HI);\n\tar7_device_reset(AR7_RESET_BIT_EPHY);\n\n\tcpmac_mii->reset(cpmac_mii);\n\n\tfor (i = 0; i < 300; i++) {\n\t\tmask = cpmac_read(cpmac_mii->priv, CPMAC_MDIO_ALIVE);\n\t\tif (mask)\n\t\t\tbreak;\n\t\telse\n\t\t\tmsleep(10);\n\t}\n\n\tmask &= 0x7fffffff;\n\tif (mask & (mask - 1)) {\n\t\texternal_switch = 1;\n\t\tmask = 0;\n\t}\n\n\tcpmac_mii->phy_mask = ~(mask | 0x80000000);\n\tsnprintf(cpmac_mii->id, MII_BUS_ID_SIZE, \"cpmac-1\");\n\n\tres = mdiobus_register(cpmac_mii);\n\tif (res)\n\t\tgoto fail_mii;\n\n\tres = platform_driver_register(&cpmac_driver);\n\tif (res)\n\t\tgoto fail_cpmac;\n\n\treturn 0;\n\nfail_cpmac:\n\tmdiobus_unregister(cpmac_mii);\n\nfail_mii:\n\tiounmap(cpmac_mii->priv);\n\nfail_alloc:\n\tmdiobus_free(cpmac_mii);\n\n\treturn res;\n}\n\nvoid __exit cpmac_exit(void)\n{\n\tplatform_driver_unregister(&cpmac_driver);\n\tmdiobus_unregister(cpmac_mii);\n\tiounmap(cpmac_mii->priv);\n\tmdiobus_free(cpmac_mii);\n}\n\nmodule_init(cpmac_init);\nmodule_exit(cpmac_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}