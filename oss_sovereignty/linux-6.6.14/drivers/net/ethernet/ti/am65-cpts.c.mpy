{
  "module_name": "am65-cpts.c",
  "hash_id": "9890f409d1478901be1729b7dc6422fe84048bf6a9edf83c2afe599a63831c3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/am65-cpts.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/err.h>\n#include <linux/if_vlan.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/net_tstamp.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/ptp_classify.h>\n#include <linux/ptp_clock_kernel.h>\n\n#include \"am65-cpts.h\"\n\nstruct am65_genf_regs {\n\tu32 comp_lo;\t \n\tu32 comp_hi;\t \n\tu32 control;\t \n\tu32 length;\t \n\tu32 ppm_low;\t \n\tu32 ppm_hi;\t \n\tu32 ts_nudge;\t \n} __aligned(32) __packed;\n\n#define AM65_CPTS_GENF_MAX_NUM 9\n#define AM65_CPTS_ESTF_MAX_NUM 8\n\nstruct am65_cpts_regs {\n\tu32 idver;\t\t \n\tu32 control;\t\t \n\tu32 rftclk_sel;\t\t \n\tu32 ts_push;\t\t \n\tu32 ts_load_val_lo;\t \n\tu32 ts_load_en;\t\t \n\tu32 ts_comp_lo;\t\t \n\tu32 ts_comp_length;\t \n\tu32 intstat_raw;\t \n\tu32 intstat_masked;\t \n\tu32 int_enable;\t\t \n\tu32 ts_comp_nudge;\t \n\tu32 event_pop;\t\t \n\tu32 event_0;\t\t \n\tu32 event_1;\t\t \n\tu32 event_2;\t\t \n\tu32 event_3;\t\t \n\tu32 ts_load_val_hi;\t \n\tu32 ts_comp_hi;\t\t \n\tu32 ts_add_val;\t\t \n\tu32 ts_ppm_low;\t\t \n\tu32 ts_ppm_hi;\t\t \n\tu32 ts_nudge;\t\t \n\tu32 reserv[33];\n\tstruct am65_genf_regs genf[AM65_CPTS_GENF_MAX_NUM];\n\tstruct am65_genf_regs estf[AM65_CPTS_ESTF_MAX_NUM];\n};\n\n \n#define AM65_CPTS_CONTROL_EN\t\t\tBIT(0)\n#define AM65_CPTS_CONTROL_INT_TEST\t\tBIT(1)\n#define AM65_CPTS_CONTROL_TS_COMP_POLARITY\tBIT(2)\n#define AM65_CPTS_CONTROL_TSTAMP_EN\t\tBIT(3)\n#define AM65_CPTS_CONTROL_SEQUENCE_EN\t\tBIT(4)\n#define AM65_CPTS_CONTROL_64MODE\t\tBIT(5)\n#define AM65_CPTS_CONTROL_TS_COMP_TOG\t\tBIT(6)\n#define AM65_CPTS_CONTROL_TS_PPM_DIR\t\tBIT(7)\n#define AM65_CPTS_CONTROL_HW1_TS_PUSH_EN\tBIT(8)\n#define AM65_CPTS_CONTROL_HW2_TS_PUSH_EN\tBIT(9)\n#define AM65_CPTS_CONTROL_HW3_TS_PUSH_EN\tBIT(10)\n#define AM65_CPTS_CONTROL_HW4_TS_PUSH_EN\tBIT(11)\n#define AM65_CPTS_CONTROL_HW5_TS_PUSH_EN\tBIT(12)\n#define AM65_CPTS_CONTROL_HW6_TS_PUSH_EN\tBIT(13)\n#define AM65_CPTS_CONTROL_HW7_TS_PUSH_EN\tBIT(14)\n#define AM65_CPTS_CONTROL_HW8_TS_PUSH_EN\tBIT(15)\n#define AM65_CPTS_CONTROL_HW1_TS_PUSH_OFFSET\t(8)\n\n#define AM65_CPTS_CONTROL_TX_GENF_CLR_EN\tBIT(17)\n\n#define AM65_CPTS_CONTROL_TS_SYNC_SEL_MASK\t(0xF)\n#define AM65_CPTS_CONTROL_TS_SYNC_SEL_SHIFT\t(28)\n\n \n#define AM65_CPTS_RFTCLK_SEL_MASK\t\t(0x1F)\n\n \n#define AM65_CPTS_TS_PUSH\t\t\tBIT(0)\n\n \n#define AM65_CPTS_TS_LOAD_EN\t\t\tBIT(0)\n\n \n#define AM65_CPTS_INTSTAT_RAW_TS_PEND\t\tBIT(0)\n\n \n#define AM65_CPTS_INTSTAT_MASKED_TS_PEND\tBIT(0)\n\n \n#define AM65_CPTS_INT_ENABLE_TS_PEND_EN\t\tBIT(0)\n\n \n#define AM65_CPTS_TS_COMP_NUDGE_MASK\t\t(0xFF)\n\n \n#define AM65_CPTS_EVENT_POP\t\t\tBIT(0)\n\n \n#define AM65_CPTS_EVENT_1_SEQUENCE_ID_MASK\tGENMASK(15, 0)\n\n#define AM65_CPTS_EVENT_1_MESSAGE_TYPE_MASK\tGENMASK(19, 16)\n#define AM65_CPTS_EVENT_1_MESSAGE_TYPE_SHIFT\t(16)\n\n#define AM65_CPTS_EVENT_1_EVENT_TYPE_MASK\tGENMASK(23, 20)\n#define AM65_CPTS_EVENT_1_EVENT_TYPE_SHIFT\t(20)\n\n#define AM65_CPTS_EVENT_1_PORT_NUMBER_MASK\tGENMASK(28, 24)\n#define AM65_CPTS_EVENT_1_PORT_NUMBER_SHIFT\t(24)\n\n \n#define AM65_CPTS_EVENT_2_REG_DOMAIN_MASK\t(0xFF)\n#define AM65_CPTS_EVENT_2_REG_DOMAIN_SHIFT\t(0)\n\nenum {\n\tAM65_CPTS_EV_PUSH,\t \n\tAM65_CPTS_EV_ROLL,\t \n\tAM65_CPTS_EV_HALF,\t \n\tAM65_CPTS_EV_HW,\t\t \n\tAM65_CPTS_EV_RX,\t\t \n\tAM65_CPTS_EV_TX,\t\t \n\tAM65_CPTS_EV_TS_COMP,\t \n\tAM65_CPTS_EV_HOST,\t \n};\n\nstruct am65_cpts_event {\n\tstruct list_head list;\n\tunsigned long tmo;\n\tu32 event1;\n\tu32 event2;\n\tu64 timestamp;\n};\n\n#define AM65_CPTS_FIFO_DEPTH\t\t(16)\n#define AM65_CPTS_MAX_EVENTS\t\t(32)\n#define AM65_CPTS_EVENT_RX_TX_TIMEOUT\t(20)  \n#define AM65_CPTS_SKB_TX_WORK_TIMEOUT\t1  \n#define AM65_CPTS_MIN_PPM\t\t0x400\n\nstruct am65_cpts {\n\tstruct device *dev;\n\tstruct am65_cpts_regs __iomem *reg;\n\tstruct ptp_clock_info ptp_info;\n\tstruct ptp_clock *ptp_clock;\n\tint phc_index;\n\tstruct clk_hw *clk_mux_hw;\n\tstruct device_node *clk_mux_np;\n\tstruct clk *refclk;\n\tu32 refclk_freq;\n\tstruct list_head events;\n\tstruct list_head pool;\n\tstruct am65_cpts_event pool_data[AM65_CPTS_MAX_EVENTS];\n\tspinlock_t lock;  \n\tu32 ext_ts_inputs;\n\tu32 genf_num;\n\tu32 ts_add_val;\n\tint irq;\n\tstruct mutex ptp_clk_lock;  \n\tu64 timestamp;\n\tu32 genf_enable;\n\tu32 hw_ts_enable;\n\tu32 estf_enable;\n\tstruct sk_buff_head txq;\n\tbool pps_enabled;\n\tbool pps_present;\n\tu32 pps_hw_ts_idx;\n\tu32 pps_genf_idx;\n\t \n\tu64 sr_cpts_ns;\n\tu64 sr_ktime_ns;\n\tu32 sr_control;\n\tu32 sr_int_enable;\n\tu32 sr_rftclk_sel;\n\tu32 sr_ts_ppm_hi;\n\tu32 sr_ts_ppm_low;\n\tstruct am65_genf_regs sr_genf[AM65_CPTS_GENF_MAX_NUM];\n\tstruct am65_genf_regs sr_estf[AM65_CPTS_ESTF_MAX_NUM];\n};\n\nstruct am65_cpts_skb_cb_data {\n\tunsigned long tmo;\n\tu32 skb_mtype_seqid;\n};\n\n#define am65_cpts_write32(c, v, r) writel(v, &(c)->reg->r)\n#define am65_cpts_read32(c, r) readl(&(c)->reg->r)\n\nstatic void am65_cpts_settime(struct am65_cpts *cpts, u64 start_tstamp)\n{\n\tu32 val;\n\n\tval = upper_32_bits(start_tstamp);\n\tam65_cpts_write32(cpts, val, ts_load_val_hi);\n\tval = lower_32_bits(start_tstamp);\n\tam65_cpts_write32(cpts, val, ts_load_val_lo);\n\n\tam65_cpts_write32(cpts, AM65_CPTS_TS_LOAD_EN, ts_load_en);\n}\n\nstatic void am65_cpts_set_add_val(struct am65_cpts *cpts)\n{\n\t \n\tcpts->ts_add_val = (NSEC_PER_SEC / cpts->refclk_freq - 1) & 0x7;\n\n\tam65_cpts_write32(cpts, cpts->ts_add_val, ts_add_val);\n}\n\nstatic void am65_cpts_disable(struct am65_cpts *cpts)\n{\n\tam65_cpts_write32(cpts, 0, control);\n\tam65_cpts_write32(cpts, 0, int_enable);\n}\n\nstatic int am65_cpts_event_get_port(struct am65_cpts_event *event)\n{\n\treturn (event->event1 & AM65_CPTS_EVENT_1_PORT_NUMBER_MASK) >>\n\t\tAM65_CPTS_EVENT_1_PORT_NUMBER_SHIFT;\n}\n\nstatic int am65_cpts_event_get_type(struct am65_cpts_event *event)\n{\n\treturn (event->event1 & AM65_CPTS_EVENT_1_EVENT_TYPE_MASK) >>\n\t\tAM65_CPTS_EVENT_1_EVENT_TYPE_SHIFT;\n}\n\nstatic int am65_cpts_cpts_purge_events(struct am65_cpts *cpts)\n{\n\tstruct list_head *this, *next;\n\tstruct am65_cpts_event *event;\n\tint removed = 0;\n\n\tlist_for_each_safe(this, next, &cpts->events) {\n\t\tevent = list_entry(this, struct am65_cpts_event, list);\n\t\tif (time_after(jiffies, event->tmo)) {\n\t\t\tlist_del_init(&event->list);\n\t\t\tlist_add(&event->list, &cpts->pool);\n\t\t\t++removed;\n\t\t}\n\t}\n\n\tif (removed)\n\t\tdev_dbg(cpts->dev, \"event pool cleaned up %d\\n\", removed);\n\treturn removed ? 0 : -1;\n}\n\nstatic bool am65_cpts_fifo_pop_event(struct am65_cpts *cpts,\n\t\t\t\t     struct am65_cpts_event *event)\n{\n\tu32 r = am65_cpts_read32(cpts, intstat_raw);\n\n\tif (r & AM65_CPTS_INTSTAT_RAW_TS_PEND) {\n\t\tevent->timestamp = am65_cpts_read32(cpts, event_0);\n\t\tevent->event1 = am65_cpts_read32(cpts, event_1);\n\t\tevent->event2 = am65_cpts_read32(cpts, event_2);\n\t\tevent->timestamp |= (u64)am65_cpts_read32(cpts, event_3) << 32;\n\t\tam65_cpts_write32(cpts, AM65_CPTS_EVENT_POP, event_pop);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int am65_cpts_fifo_read(struct am65_cpts *cpts)\n{\n\tstruct ptp_clock_event pevent;\n\tstruct am65_cpts_event *event;\n\tbool schedule = false;\n\tint i, type, ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cpts->lock, flags);\n\tfor (i = 0; i < AM65_CPTS_FIFO_DEPTH; i++) {\n\t\tevent = list_first_entry_or_null(&cpts->pool,\n\t\t\t\t\t\t struct am65_cpts_event, list);\n\n\t\tif (!event) {\n\t\t\tif (am65_cpts_cpts_purge_events(cpts)) {\n\t\t\t\tdev_err(cpts->dev, \"cpts: event pool empty\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (am65_cpts_fifo_pop_event(cpts, event))\n\t\t\tbreak;\n\n\t\ttype = am65_cpts_event_get_type(event);\n\t\tswitch (type) {\n\t\tcase AM65_CPTS_EV_PUSH:\n\t\t\tcpts->timestamp = event->timestamp;\n\t\t\tdev_dbg(cpts->dev, \"AM65_CPTS_EV_PUSH t:%llu\\n\",\n\t\t\t\tcpts->timestamp);\n\t\t\tbreak;\n\t\tcase AM65_CPTS_EV_RX:\n\t\tcase AM65_CPTS_EV_TX:\n\t\t\tevent->tmo = jiffies +\n\t\t\t\tmsecs_to_jiffies(AM65_CPTS_EVENT_RX_TX_TIMEOUT);\n\n\t\t\tlist_del_init(&event->list);\n\t\t\tlist_add_tail(&event->list, &cpts->events);\n\n\t\t\tdev_dbg(cpts->dev,\n\t\t\t\t\"AM65_CPTS_EV_TX e1:%08x e2:%08x t:%lld\\n\",\n\t\t\t\tevent->event1, event->event2,\n\t\t\t\tevent->timestamp);\n\t\t\tschedule = true;\n\t\t\tbreak;\n\t\tcase AM65_CPTS_EV_HW:\n\t\t\tpevent.index = am65_cpts_event_get_port(event) - 1;\n\t\t\tpevent.timestamp = event->timestamp;\n\t\t\tif (cpts->pps_enabled && pevent.index == cpts->pps_hw_ts_idx) {\n\t\t\t\tpevent.type = PTP_CLOCK_PPSUSR;\n\t\t\t\tpevent.pps_times.ts_real = ns_to_timespec64(pevent.timestamp);\n\t\t\t} else {\n\t\t\t\tpevent.type = PTP_CLOCK_EXTTS;\n\t\t\t}\n\t\t\tdev_dbg(cpts->dev, \"AM65_CPTS_EV_HW:%s p:%d t:%llu\\n\",\n\t\t\t\tpevent.type == PTP_CLOCK_EXTTS ?\n\t\t\t\t\"extts\" : \"pps\",\n\t\t\t\tpevent.index, event->timestamp);\n\n\t\t\tptp_clock_event(cpts->ptp_clock, &pevent);\n\t\t\tbreak;\n\t\tcase AM65_CPTS_EV_HOST:\n\t\t\tbreak;\n\t\tcase AM65_CPTS_EV_ROLL:\n\t\tcase AM65_CPTS_EV_HALF:\n\t\tcase AM65_CPTS_EV_TS_COMP:\n\t\t\tdev_dbg(cpts->dev,\n\t\t\t\t\"AM65_CPTS_EVT: %d e1:%08x e2:%08x t:%lld\\n\",\n\t\t\t\ttype,\n\t\t\t\tevent->event1, event->event2,\n\t\t\t\tevent->timestamp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(cpts->dev, \"cpts: unknown event type\\n\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tspin_unlock_irqrestore(&cpts->lock, flags);\n\n\tif (schedule)\n\t\tptp_schedule_worker(cpts->ptp_clock, 0);\n\n\treturn ret;\n}\n\nstatic u64 am65_cpts_gettime(struct am65_cpts *cpts,\n\t\t\t     struct ptp_system_timestamp *sts)\n{\n\tunsigned long flags;\n\tu64 val = 0;\n\n\t \n\tam65_cpts_write32(cpts, 0, int_enable);\n\n\t \n\tspin_lock_irqsave(&cpts->lock, flags);\n\tptp_read_system_prets(sts);\n\tam65_cpts_write32(cpts, AM65_CPTS_TS_PUSH, ts_push);\n\tam65_cpts_read32(cpts, ts_push);\n\tptp_read_system_postts(sts);\n\tspin_unlock_irqrestore(&cpts->lock, flags);\n\n\tam65_cpts_fifo_read(cpts);\n\n\tam65_cpts_write32(cpts, AM65_CPTS_INT_ENABLE_TS_PEND_EN, int_enable);\n\n\tval = cpts->timestamp;\n\n\treturn val;\n}\n\nstatic irqreturn_t am65_cpts_interrupt(int irq, void *dev_id)\n{\n\tstruct am65_cpts *cpts = dev_id;\n\n\tif (am65_cpts_fifo_read(cpts))\n\t\tdev_dbg(cpts->dev, \"cpts: unable to obtain a time stamp\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int am65_cpts_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct am65_cpts *cpts = container_of(ptp, struct am65_cpts, ptp_info);\n\tu32 estf_ctrl_val = 0, estf_ppm_hi = 0, estf_ppm_low = 0;\n\ts32 ppb = scaled_ppm_to_ppb(scaled_ppm);\n\tint pps_index = cpts->pps_genf_idx;\n\tu64 adj_period, pps_adj_period;\n\tu32 ctrl_val, ppm_hi, ppm_low;\n\tunsigned long flags;\n\tint neg_adj = 0, i;\n\n\tif (ppb < 0) {\n\t\tneg_adj = 1;\n\t\tppb = -ppb;\n\t}\n\n\t \n\tadj_period = div_u64(cpts->refclk_freq, ppb);\n\n\tmutex_lock(&cpts->ptp_clk_lock);\n\n\tctrl_val = am65_cpts_read32(cpts, control);\n\tif (neg_adj)\n\t\tctrl_val |= AM65_CPTS_CONTROL_TS_PPM_DIR;\n\telse\n\t\tctrl_val &= ~AM65_CPTS_CONTROL_TS_PPM_DIR;\n\n\tppm_hi = upper_32_bits(adj_period) & 0x3FF;\n\tppm_low = lower_32_bits(adj_period);\n\n\tif (cpts->pps_enabled) {\n\t\testf_ctrl_val = am65_cpts_read32(cpts, genf[pps_index].control);\n\t\tif (neg_adj)\n\t\t\testf_ctrl_val &= ~BIT(1);\n\t\telse\n\t\t\testf_ctrl_val |= BIT(1);\n\n\t\t \n\t\tpps_adj_period = adj_period * (cpts->ts_add_val + 1);\n\t\testf_ppm_hi = upper_32_bits(pps_adj_period) & 0x3FF;\n\t\testf_ppm_low = lower_32_bits(pps_adj_period);\n\t}\n\n\tspin_lock_irqsave(&cpts->lock, flags);\n\n\t \n\n\tam65_cpts_write32(cpts, ctrl_val, control);\n\tam65_cpts_write32(cpts, ppm_hi, ts_ppm_hi);\n\tam65_cpts_write32(cpts, ppm_low, ts_ppm_low);\n\n\tif (cpts->pps_enabled) {\n\t\tam65_cpts_write32(cpts, estf_ctrl_val, genf[pps_index].control);\n\t\tam65_cpts_write32(cpts, estf_ppm_hi, genf[pps_index].ppm_hi);\n\t\tam65_cpts_write32(cpts, estf_ppm_low, genf[pps_index].ppm_low);\n\t}\n\n\tfor (i = 0; i < AM65_CPTS_ESTF_MAX_NUM; i++) {\n\t\tif (cpts->estf_enable & BIT(i)) {\n\t\t\tam65_cpts_write32(cpts, estf_ctrl_val, estf[i].control);\n\t\t\tam65_cpts_write32(cpts, estf_ppm_hi, estf[i].ppm_hi);\n\t\t\tam65_cpts_write32(cpts, estf_ppm_low, estf[i].ppm_low);\n\t\t}\n\t}\n\t \n\tspin_unlock_irqrestore(&cpts->lock, flags);\n\n\tmutex_unlock(&cpts->ptp_clk_lock);\n\n\treturn 0;\n}\n\nstatic int am65_cpts_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct am65_cpts *cpts = container_of(ptp, struct am65_cpts, ptp_info);\n\ts64 ns;\n\n\tmutex_lock(&cpts->ptp_clk_lock);\n\tns = am65_cpts_gettime(cpts, NULL);\n\tns += delta;\n\tam65_cpts_settime(cpts, ns);\n\tmutex_unlock(&cpts->ptp_clk_lock);\n\n\treturn 0;\n}\n\nstatic int am65_cpts_ptp_gettimex(struct ptp_clock_info *ptp,\n\t\t\t\t  struct timespec64 *ts,\n\t\t\t\t  struct ptp_system_timestamp *sts)\n{\n\tstruct am65_cpts *cpts = container_of(ptp, struct am65_cpts, ptp_info);\n\tu64 ns;\n\n\tmutex_lock(&cpts->ptp_clk_lock);\n\tns = am65_cpts_gettime(cpts, sts);\n\tmutex_unlock(&cpts->ptp_clk_lock);\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\nu64 am65_cpts_ns_gettime(struct am65_cpts *cpts)\n{\n\tu64 ns;\n\n\t \n\tmutex_lock(&cpts->ptp_clk_lock);\n\tns = am65_cpts_gettime(cpts, NULL);\n\tmutex_unlock(&cpts->ptp_clk_lock);\n\n\treturn ns;\n}\nEXPORT_SYMBOL_GPL(am65_cpts_ns_gettime);\n\nstatic int am65_cpts_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t\t const struct timespec64 *ts)\n{\n\tstruct am65_cpts *cpts = container_of(ptp, struct am65_cpts, ptp_info);\n\tu64 ns;\n\n\tns = timespec64_to_ns(ts);\n\tmutex_lock(&cpts->ptp_clk_lock);\n\tam65_cpts_settime(cpts, ns);\n\tmutex_unlock(&cpts->ptp_clk_lock);\n\n\treturn 0;\n}\n\nstatic void am65_cpts_extts_enable_hw(struct am65_cpts *cpts, u32 index, int on)\n{\n\tu32 v;\n\n\tv = am65_cpts_read32(cpts, control);\n\tif (on) {\n\t\tv |= BIT(AM65_CPTS_CONTROL_HW1_TS_PUSH_OFFSET + index);\n\t\tcpts->hw_ts_enable |= BIT(index);\n\t} else {\n\t\tv &= ~BIT(AM65_CPTS_CONTROL_HW1_TS_PUSH_OFFSET + index);\n\t\tcpts->hw_ts_enable &= ~BIT(index);\n\t}\n\tam65_cpts_write32(cpts, v, control);\n}\n\nstatic int am65_cpts_extts_enable(struct am65_cpts *cpts, u32 index, int on)\n{\n\tif (index >= cpts->ptp_info.n_ext_ts)\n\t\treturn -ENXIO;\n\n\tif (cpts->pps_present && index == cpts->pps_hw_ts_idx)\n\t\treturn -EINVAL;\n\n\tif (((cpts->hw_ts_enable & BIT(index)) >> index) == on)\n\t\treturn 0;\n\n\tmutex_lock(&cpts->ptp_clk_lock);\n\tam65_cpts_extts_enable_hw(cpts, index, on);\n\tmutex_unlock(&cpts->ptp_clk_lock);\n\n\tdev_dbg(cpts->dev, \"%s: ExtTS:%u %s\\n\",\n\t\t__func__, index, on ? \"enabled\" : \"disabled\");\n\n\treturn 0;\n}\n\nint am65_cpts_estf_enable(struct am65_cpts *cpts, int idx,\n\t\t\t  struct am65_cpts_estf_cfg *cfg)\n{\n\tu64 cycles;\n\tu32 val;\n\n\tcycles = cfg->ns_period * cpts->refclk_freq;\n\tcycles = DIV_ROUND_UP(cycles, NSEC_PER_SEC);\n\tif (cycles > U32_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tam65_cpts_write32(cpts, 0, estf[idx].length);\n\n\tval = upper_32_bits(cfg->ns_start);\n\tam65_cpts_write32(cpts, val, estf[idx].comp_hi);\n\tval = lower_32_bits(cfg->ns_start);\n\tam65_cpts_write32(cpts, val, estf[idx].comp_lo);\n\tval = lower_32_bits(cycles);\n\tam65_cpts_write32(cpts, val, estf[idx].length);\n\tam65_cpts_write32(cpts, 0, estf[idx].control);\n\tam65_cpts_write32(cpts, 0, estf[idx].ppm_hi);\n\tam65_cpts_write32(cpts, 0, estf[idx].ppm_low);\n\n\tcpts->estf_enable |= BIT(idx);\n\n\tdev_dbg(cpts->dev, \"%s: ESTF:%u enabled\\n\", __func__, idx);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(am65_cpts_estf_enable);\n\nvoid am65_cpts_estf_disable(struct am65_cpts *cpts, int idx)\n{\n\tam65_cpts_write32(cpts, 0, estf[idx].length);\n\tcpts->estf_enable &= ~BIT(idx);\n\n\tdev_dbg(cpts->dev, \"%s: ESTF:%u disabled\\n\", __func__, idx);\n}\nEXPORT_SYMBOL_GPL(am65_cpts_estf_disable);\n\nstatic void am65_cpts_perout_enable_hw(struct am65_cpts *cpts,\n\t\t\t\t       struct ptp_perout_request *req, int on)\n{\n\tu64 ns_period, ns_start, cycles;\n\tstruct timespec64 ts;\n\tu32 val;\n\n\tif (on) {\n\t\tts.tv_sec = req->period.sec;\n\t\tts.tv_nsec = req->period.nsec;\n\t\tns_period = timespec64_to_ns(&ts);\n\n\t\tcycles = (ns_period * cpts->refclk_freq) / NSEC_PER_SEC;\n\n\t\tts.tv_sec = req->start.sec;\n\t\tts.tv_nsec = req->start.nsec;\n\t\tns_start = timespec64_to_ns(&ts);\n\n\t\tval = upper_32_bits(ns_start);\n\t\tam65_cpts_write32(cpts, val, genf[req->index].comp_hi);\n\t\tval = lower_32_bits(ns_start);\n\t\tam65_cpts_write32(cpts, val, genf[req->index].comp_lo);\n\t\tval = lower_32_bits(cycles);\n\t\tam65_cpts_write32(cpts, val, genf[req->index].length);\n\n\t\tam65_cpts_write32(cpts, 0, genf[req->index].control);\n\t\tam65_cpts_write32(cpts, 0, genf[req->index].ppm_hi);\n\t\tam65_cpts_write32(cpts, 0, genf[req->index].ppm_low);\n\n\t\tcpts->genf_enable |= BIT(req->index);\n\t} else {\n\t\tam65_cpts_write32(cpts, 0, genf[req->index].length);\n\n\t\tcpts->genf_enable &= ~BIT(req->index);\n\t}\n}\n\nstatic int am65_cpts_perout_enable(struct am65_cpts *cpts,\n\t\t\t\t   struct ptp_perout_request *req, int on)\n{\n\tif (req->index >= cpts->ptp_info.n_per_out)\n\t\treturn -ENXIO;\n\n\tif (cpts->pps_present && req->index == cpts->pps_genf_idx)\n\t\treturn -EINVAL;\n\n\tif (!!(cpts->genf_enable & BIT(req->index)) == !!on)\n\t\treturn 0;\n\n\tmutex_lock(&cpts->ptp_clk_lock);\n\tam65_cpts_perout_enable_hw(cpts, req, on);\n\tmutex_unlock(&cpts->ptp_clk_lock);\n\n\tdev_dbg(cpts->dev, \"%s: GenF:%u %s\\n\",\n\t\t__func__, req->index, on ? \"enabled\" : \"disabled\");\n\n\treturn 0;\n}\n\nstatic int am65_cpts_pps_enable(struct am65_cpts *cpts, int on)\n{\n\tint ret = 0;\n\tstruct timespec64 ts;\n\tstruct ptp_clock_request rq;\n\tu64 ns;\n\n\tif (!cpts->pps_present)\n\t\treturn -EINVAL;\n\n\tif (cpts->pps_enabled == !!on)\n\t\treturn 0;\n\n\tmutex_lock(&cpts->ptp_clk_lock);\n\n\tif (on) {\n\t\tam65_cpts_extts_enable_hw(cpts, cpts->pps_hw_ts_idx, on);\n\n\t\tns = am65_cpts_gettime(cpts, NULL);\n\t\tts = ns_to_timespec64(ns);\n\t\trq.perout.period.sec = 1;\n\t\trq.perout.period.nsec = 0;\n\t\trq.perout.start.sec = ts.tv_sec + 2;\n\t\trq.perout.start.nsec = 0;\n\t\trq.perout.index = cpts->pps_genf_idx;\n\n\t\tam65_cpts_perout_enable_hw(cpts, &rq.perout, on);\n\t\tcpts->pps_enabled = true;\n\t} else {\n\t\trq.perout.index = cpts->pps_genf_idx;\n\t\tam65_cpts_perout_enable_hw(cpts, &rq.perout, on);\n\t\tam65_cpts_extts_enable_hw(cpts, cpts->pps_hw_ts_idx, on);\n\t\tcpts->pps_enabled = false;\n\t}\n\n\tmutex_unlock(&cpts->ptp_clk_lock);\n\n\tdev_dbg(cpts->dev, \"%s: pps: %s\\n\",\n\t\t__func__, on ? \"enabled\" : \"disabled\");\n\treturn ret;\n}\n\nstatic int am65_cpts_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t\tstruct ptp_clock_request *rq, int on)\n{\n\tstruct am65_cpts *cpts = container_of(ptp, struct am65_cpts, ptp_info);\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\treturn am65_cpts_extts_enable(cpts, rq->extts.index, on);\n\tcase PTP_CLK_REQ_PEROUT:\n\t\treturn am65_cpts_perout_enable(cpts, &rq->perout, on);\n\tcase PTP_CLK_REQ_PPS:\n\t\treturn am65_cpts_pps_enable(cpts, on);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic long am65_cpts_ts_work(struct ptp_clock_info *ptp);\n\nstatic struct ptp_clock_info am65_ptp_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"CTPS timer\",\n\t.adjfine\t= am65_cpts_ptp_adjfine,\n\t.adjtime\t= am65_cpts_ptp_adjtime,\n\t.gettimex64\t= am65_cpts_ptp_gettimex,\n\t.settime64\t= am65_cpts_ptp_settime,\n\t.enable\t\t= am65_cpts_ptp_enable,\n\t.do_aux_work\t= am65_cpts_ts_work,\n};\n\nstatic bool am65_cpts_match_tx_ts(struct am65_cpts *cpts,\n\t\t\t\t  struct am65_cpts_event *event)\n{\n\tstruct sk_buff_head txq_list;\n\tstruct sk_buff *skb, *tmp;\n\tunsigned long flags;\n\tbool found = false;\n\tu32 mtype_seqid;\n\n\tmtype_seqid = event->event1 &\n\t\t      (AM65_CPTS_EVENT_1_MESSAGE_TYPE_MASK |\n\t\t       AM65_CPTS_EVENT_1_EVENT_TYPE_MASK |\n\t\t       AM65_CPTS_EVENT_1_SEQUENCE_ID_MASK);\n\n\t__skb_queue_head_init(&txq_list);\n\n\tspin_lock_irqsave(&cpts->txq.lock, flags);\n\tskb_queue_splice_init(&cpts->txq, &txq_list);\n\tspin_unlock_irqrestore(&cpts->txq.lock, flags);\n\n\t \n\tskb_queue_walk_safe(&txq_list, skb, tmp) {\n\t\tstruct skb_shared_hwtstamps ssh;\n\t\tstruct am65_cpts_skb_cb_data *skb_cb =\n\t\t\t\t\t(struct am65_cpts_skb_cb_data *)skb->cb;\n\n\t\tif (mtype_seqid == skb_cb->skb_mtype_seqid) {\n\t\t\tu64 ns = event->timestamp;\n\n\t\t\tmemset(&ssh, 0, sizeof(ssh));\n\t\t\tssh.hwtstamp = ns_to_ktime(ns);\n\t\t\tskb_tstamp_tx(skb, &ssh);\n\t\t\tfound = true;\n\t\t\t__skb_unlink(skb, &txq_list);\n\t\t\tdev_consume_skb_any(skb);\n\t\t\tdev_dbg(cpts->dev,\n\t\t\t\t\"match tx timestamp mtype_seqid %08x\\n\",\n\t\t\t\tmtype_seqid);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (time_after(jiffies, skb_cb->tmo)) {\n\t\t\t \n\t\t\tdev_dbg(cpts->dev,\n\t\t\t\t\"expiring tx timestamp mtype_seqid %08x\\n\",\n\t\t\t\tmtype_seqid);\n\t\t\t__skb_unlink(skb, &txq_list);\n\t\t\tdev_consume_skb_any(skb);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&cpts->txq.lock, flags);\n\tskb_queue_splice(&txq_list, &cpts->txq);\n\tspin_unlock_irqrestore(&cpts->txq.lock, flags);\n\n\treturn found;\n}\n\nstatic void am65_cpts_find_ts(struct am65_cpts *cpts)\n{\n\tstruct am65_cpts_event *event;\n\tstruct list_head *this, *next;\n\tLIST_HEAD(events_free);\n\tunsigned long flags;\n\tLIST_HEAD(events);\n\n\tspin_lock_irqsave(&cpts->lock, flags);\n\tlist_splice_init(&cpts->events, &events);\n\tspin_unlock_irqrestore(&cpts->lock, flags);\n\n\tlist_for_each_safe(this, next, &events) {\n\t\tevent = list_entry(this, struct am65_cpts_event, list);\n\t\tif (am65_cpts_match_tx_ts(cpts, event) ||\n\t\t    time_after(jiffies, event->tmo)) {\n\t\t\tlist_del_init(&event->list);\n\t\t\tlist_add(&event->list, &events_free);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&cpts->lock, flags);\n\tlist_splice_tail(&events, &cpts->events);\n\tlist_splice_tail(&events_free, &cpts->pool);\n\tspin_unlock_irqrestore(&cpts->lock, flags);\n}\n\nstatic long am65_cpts_ts_work(struct ptp_clock_info *ptp)\n{\n\tstruct am65_cpts *cpts = container_of(ptp, struct am65_cpts, ptp_info);\n\tunsigned long flags;\n\tlong delay = -1;\n\n\tam65_cpts_find_ts(cpts);\n\n\tspin_lock_irqsave(&cpts->txq.lock, flags);\n\tif (!skb_queue_empty(&cpts->txq))\n\t\tdelay = AM65_CPTS_SKB_TX_WORK_TIMEOUT;\n\tspin_unlock_irqrestore(&cpts->txq.lock, flags);\n\n\treturn delay;\n}\n\n \nvoid am65_cpts_rx_enable(struct am65_cpts *cpts, bool en)\n{\n\tu32 val;\n\n\tmutex_lock(&cpts->ptp_clk_lock);\n\tval = am65_cpts_read32(cpts, control);\n\tif (en)\n\t\tval |= AM65_CPTS_CONTROL_TSTAMP_EN;\n\telse\n\t\tval &= ~AM65_CPTS_CONTROL_TSTAMP_EN;\n\tam65_cpts_write32(cpts, val, control);\n\tmutex_unlock(&cpts->ptp_clk_lock);\n}\nEXPORT_SYMBOL_GPL(am65_cpts_rx_enable);\n\nstatic int am65_skb_get_mtype_seqid(struct sk_buff *skb, u32 *mtype_seqid)\n{\n\tunsigned int ptp_class = ptp_classify_raw(skb);\n\tstruct ptp_header *hdr;\n\tu8 msgtype;\n\tu16 seqid;\n\n\tif (ptp_class == PTP_CLASS_NONE)\n\t\treturn 0;\n\n\thdr = ptp_parse_header(skb, ptp_class);\n\tif (!hdr)\n\t\treturn 0;\n\n\tmsgtype = ptp_get_msgtype(hdr, ptp_class);\n\tseqid\t= ntohs(hdr->sequence_id);\n\n\t*mtype_seqid  = (msgtype << AM65_CPTS_EVENT_1_MESSAGE_TYPE_SHIFT) &\n\t\t\tAM65_CPTS_EVENT_1_MESSAGE_TYPE_MASK;\n\t*mtype_seqid |= (seqid & AM65_CPTS_EVENT_1_SEQUENCE_ID_MASK);\n\n\treturn 1;\n}\n\n \nvoid am65_cpts_tx_timestamp(struct am65_cpts *cpts, struct sk_buff *skb)\n{\n\tstruct am65_cpts_skb_cb_data *skb_cb = (void *)skb->cb;\n\n\tif (!(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS))\n\t\treturn;\n\n\t \n\tskb_get(skb);\n\t \n\tskb_cb->tmo = jiffies + msecs_to_jiffies(100);\n\tskb_queue_tail(&cpts->txq, skb);\n\tptp_schedule_worker(cpts->ptp_clock, 0);\n}\nEXPORT_SYMBOL_GPL(am65_cpts_tx_timestamp);\n\n \nvoid am65_cpts_prep_tx_timestamp(struct am65_cpts *cpts, struct sk_buff *skb)\n{\n\tstruct am65_cpts_skb_cb_data *skb_cb = (void *)skb->cb;\n\tint ret;\n\n\tif (!(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP))\n\t\treturn;\n\n\tret = am65_skb_get_mtype_seqid(skb, &skb_cb->skb_mtype_seqid);\n\tif (!ret)\n\t\treturn;\n\tskb_cb->skb_mtype_seqid |= (AM65_CPTS_EV_TX <<\n\t\t\t\t   AM65_CPTS_EVENT_1_EVENT_TYPE_SHIFT);\n\n\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n}\nEXPORT_SYMBOL_GPL(am65_cpts_prep_tx_timestamp);\n\nint am65_cpts_phc_index(struct am65_cpts *cpts)\n{\n\treturn cpts->phc_index;\n}\nEXPORT_SYMBOL_GPL(am65_cpts_phc_index);\n\nstatic void cpts_free_clk_mux(void *data)\n{\n\tstruct am65_cpts *cpts = data;\n\n\tof_clk_del_provider(cpts->clk_mux_np);\n\tclk_hw_unregister_mux(cpts->clk_mux_hw);\n\tof_node_put(cpts->clk_mux_np);\n}\n\nstatic int cpts_of_mux_clk_setup(struct am65_cpts *cpts,\n\t\t\t\t struct device_node *node)\n{\n\tunsigned int num_parents;\n\tconst char **parent_names;\n\tchar *clk_mux_name;\n\tvoid __iomem *reg;\n\tint ret = -EINVAL;\n\n\tcpts->clk_mux_np = of_get_child_by_name(node, \"refclk-mux\");\n\tif (!cpts->clk_mux_np)\n\t\treturn 0;\n\n\tnum_parents = of_clk_get_parent_count(cpts->clk_mux_np);\n\tif (num_parents < 1) {\n\t\tdev_err(cpts->dev, \"mux-clock %pOF must have parents\\n\",\n\t\t\tcpts->clk_mux_np);\n\t\tgoto mux_fail;\n\t}\n\n\tparent_names = devm_kcalloc(cpts->dev, sizeof(char *), num_parents,\n\t\t\t\t    GFP_KERNEL);\n\tif (!parent_names) {\n\t\tret = -ENOMEM;\n\t\tgoto mux_fail;\n\t}\n\n\tof_clk_parent_fill(cpts->clk_mux_np, parent_names, num_parents);\n\n\tclk_mux_name = devm_kasprintf(cpts->dev, GFP_KERNEL, \"%s.%pOFn\",\n\t\t\t\t      dev_name(cpts->dev), cpts->clk_mux_np);\n\tif (!clk_mux_name) {\n\t\tret = -ENOMEM;\n\t\tgoto mux_fail;\n\t}\n\n\treg = &cpts->reg->rftclk_sel;\n\t \n\tcpts->clk_mux_hw = clk_hw_register_mux(NULL, clk_mux_name,\n\t\t\t\t\t       parent_names, num_parents,\n\t\t\t\t\t       0, reg, 0, 5, 0, NULL);\n\tif (IS_ERR(cpts->clk_mux_hw)) {\n\t\tret = PTR_ERR(cpts->clk_mux_hw);\n\t\tgoto mux_fail;\n\t}\n\n\tret = of_clk_add_hw_provider(cpts->clk_mux_np, of_clk_hw_simple_get,\n\t\t\t\t     cpts->clk_mux_hw);\n\tif (ret)\n\t\tgoto clk_hw_register;\n\n\tret = devm_add_action_or_reset(cpts->dev, cpts_free_clk_mux, cpts);\n\tif (ret)\n\t\tdev_err(cpts->dev, \"failed to add clkmux reset action %d\", ret);\n\n\treturn ret;\n\nclk_hw_register:\n\tclk_hw_unregister_mux(cpts->clk_mux_hw);\nmux_fail:\n\tof_node_put(cpts->clk_mux_np);\n\treturn ret;\n}\n\nstatic int am65_cpts_of_parse(struct am65_cpts *cpts, struct device_node *node)\n{\n\tu32 prop[2];\n\n\tif (!of_property_read_u32(node, \"ti,cpts-ext-ts-inputs\", &prop[0]))\n\t\tcpts->ext_ts_inputs = prop[0];\n\n\tif (!of_property_read_u32(node, \"ti,cpts-periodic-outputs\", &prop[0]))\n\t\tcpts->genf_num = prop[0];\n\n\tif (!of_property_read_u32_array(node, \"ti,pps\", prop, 2)) {\n\t\tcpts->pps_present = true;\n\n\t\tif (prop[0] > 7) {\n\t\t\tdev_err(cpts->dev, \"invalid HWx_TS_PUSH index: %u provided\\n\", prop[0]);\n\t\t\tcpts->pps_present = false;\n\t\t}\n\t\tif (prop[1] > 1) {\n\t\t\tdev_err(cpts->dev, \"invalid GENFy index: %u provided\\n\", prop[1]);\n\t\t\tcpts->pps_present = false;\n\t\t}\n\t\tif (cpts->pps_present) {\n\t\t\tcpts->pps_hw_ts_idx = prop[0];\n\t\t\tcpts->pps_genf_idx = prop[1];\n\t\t}\n\t}\n\n\treturn cpts_of_mux_clk_setup(cpts, node);\n}\n\nvoid am65_cpts_release(struct am65_cpts *cpts)\n{\n\tptp_clock_unregister(cpts->ptp_clock);\n\tam65_cpts_disable(cpts);\n\tclk_disable_unprepare(cpts->refclk);\n}\nEXPORT_SYMBOL_GPL(am65_cpts_release);\n\nstruct am65_cpts *am65_cpts_create(struct device *dev, void __iomem *regs,\n\t\t\t\t   struct device_node *node)\n{\n\tstruct am65_cpts *cpts;\n\tint ret, i;\n\n\tcpts = devm_kzalloc(dev, sizeof(*cpts), GFP_KERNEL);\n\tif (!cpts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcpts->dev = dev;\n\tcpts->reg = (struct am65_cpts_regs __iomem *)regs;\n\n\tcpts->irq = of_irq_get_byname(node, \"cpts\");\n\tif (cpts->irq <= 0) {\n\t\tret = cpts->irq ?: -ENXIO;\n\t\tdev_err_probe(dev, ret, \"Failed to get IRQ number\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = am65_cpts_of_parse(cpts, node);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tmutex_init(&cpts->ptp_clk_lock);\n\tINIT_LIST_HEAD(&cpts->events);\n\tINIT_LIST_HEAD(&cpts->pool);\n\tspin_lock_init(&cpts->lock);\n\tskb_queue_head_init(&cpts->txq);\n\n\tfor (i = 0; i < AM65_CPTS_MAX_EVENTS; i++)\n\t\tlist_add(&cpts->pool_data[i].list, &cpts->pool);\n\n\tcpts->refclk = devm_get_clk_from_child(dev, node, \"cpts\");\n\tif (IS_ERR(cpts->refclk)) {\n\t\tret = PTR_ERR(cpts->refclk);\n\t\tdev_err_probe(dev, ret, \"Failed to get refclk\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = clk_prepare_enable(cpts->refclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable refclk %d\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tcpts->refclk_freq = clk_get_rate(cpts->refclk);\n\n\tam65_ptp_info.max_adj = cpts->refclk_freq / AM65_CPTS_MIN_PPM;\n\tcpts->ptp_info = am65_ptp_info;\n\n\tif (cpts->ext_ts_inputs)\n\t\tcpts->ptp_info.n_ext_ts = cpts->ext_ts_inputs;\n\tif (cpts->genf_num)\n\t\tcpts->ptp_info.n_per_out = cpts->genf_num;\n\tif (cpts->pps_present)\n\t\tcpts->ptp_info.pps = 1;\n\n\tam65_cpts_set_add_val(cpts);\n\n\tam65_cpts_write32(cpts, AM65_CPTS_CONTROL_EN |\n\t\t\t  AM65_CPTS_CONTROL_64MODE |\n\t\t\t  AM65_CPTS_CONTROL_TX_GENF_CLR_EN,\n\t\t\t  control);\n\tam65_cpts_write32(cpts, AM65_CPTS_INT_ENABLE_TS_PEND_EN, int_enable);\n\n\t \n\tam65_cpts_settime(cpts, ktime_to_ns(ktime_get_real()));\n\n\tcpts->ptp_clock = ptp_clock_register(&cpts->ptp_info, cpts->dev);\n\tif (IS_ERR_OR_NULL(cpts->ptp_clock)) {\n\t\tdev_err(dev, \"Failed to register ptp clk %ld\\n\",\n\t\t\tPTR_ERR(cpts->ptp_clock));\n\t\tret = cpts->ptp_clock ? PTR_ERR(cpts->ptp_clock) : -ENODEV;\n\t\tgoto refclk_disable;\n\t}\n\tcpts->phc_index = ptp_clock_index(cpts->ptp_clock);\n\n\tret = devm_request_threaded_irq(dev, cpts->irq, NULL,\n\t\t\t\t\tam65_cpts_interrupt,\n\t\t\t\t\tIRQF_ONESHOT, dev_name(dev), cpts);\n\tif (ret < 0) {\n\t\tdev_err(cpts->dev, \"error attaching irq %d\\n\", ret);\n\t\tgoto reset_ptpclk;\n\t}\n\n\tdev_info(dev, \"CPTS ver 0x%08x, freq:%u, add_val:%u pps:%d\\n\",\n\t\t am65_cpts_read32(cpts, idver),\n\t\t cpts->refclk_freq, cpts->ts_add_val, cpts->pps_present);\n\n\treturn cpts;\n\nreset_ptpclk:\n\tam65_cpts_release(cpts);\nrefclk_disable:\n\tclk_disable_unprepare(cpts->refclk);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(am65_cpts_create);\n\nvoid am65_cpts_suspend(struct am65_cpts *cpts)\n{\n\t \n\tcpts->sr_control = am65_cpts_read32(cpts, control);\n\tcpts->sr_int_enable = am65_cpts_read32(cpts, int_enable);\n\tcpts->sr_rftclk_sel = am65_cpts_read32(cpts, rftclk_sel);\n\tcpts->sr_ts_ppm_hi = am65_cpts_read32(cpts, ts_ppm_hi);\n\tcpts->sr_ts_ppm_low = am65_cpts_read32(cpts, ts_ppm_low);\n\tcpts->sr_cpts_ns = am65_cpts_gettime(cpts, NULL);\n\tcpts->sr_ktime_ns = ktime_to_ns(ktime_get_real());\n\tam65_cpts_disable(cpts);\n\tclk_disable(cpts->refclk);\n\n\t \n\tmemcpy_fromio(&cpts->sr_genf, &cpts->reg->genf, sizeof(cpts->sr_genf));\n\n\t \n\tmemcpy_fromio(&cpts->sr_estf, &cpts->reg->estf, sizeof(cpts->sr_estf));\n}\nEXPORT_SYMBOL_GPL(am65_cpts_suspend);\n\nvoid am65_cpts_resume(struct am65_cpts *cpts)\n{\n\tint i;\n\ts64 ktime_ns;\n\n\t \n\tclk_enable(cpts->refclk);\n\tam65_cpts_write32(cpts, cpts->sr_rftclk_sel, rftclk_sel);\n\tam65_cpts_set_add_val(cpts);\n\tam65_cpts_write32(cpts, cpts->sr_control, control);\n\tam65_cpts_write32(cpts, cpts->sr_int_enable, int_enable);\n\n\t \n\tktime_ns = ktime_to_ns(ktime_get_real());\n\tktime_ns -= cpts->sr_ktime_ns;\n\tam65_cpts_settime(cpts, cpts->sr_cpts_ns + ktime_ns);\n\n\t \n\tam65_cpts_write32(cpts, cpts->sr_ts_ppm_hi, ts_ppm_hi);\n\tam65_cpts_write32(cpts, cpts->sr_ts_ppm_low, ts_ppm_low);\n\n\t \n\tfor (i = 0; i < AM65_CPTS_GENF_MAX_NUM; i++) {\n\t\tam65_cpts_write32(cpts, 0, genf[i].length);\t \n\t\tam65_cpts_write32(cpts, cpts->sr_genf[i].comp_hi, genf[i].comp_hi);\n\t\tam65_cpts_write32(cpts, cpts->sr_genf[i].comp_lo, genf[i].comp_lo);\n\t\tam65_cpts_write32(cpts, cpts->sr_genf[i].length, genf[i].length);\n\t\tam65_cpts_write32(cpts, cpts->sr_genf[i].control, genf[i].control);\n\t\tam65_cpts_write32(cpts, cpts->sr_genf[i].ppm_hi, genf[i].ppm_hi);\n\t\tam65_cpts_write32(cpts, cpts->sr_genf[i].ppm_low, genf[i].ppm_low);\n\t}\n\n\t \n\tfor (i = 0; i < AM65_CPTS_ESTF_MAX_NUM; i++) {\n\t\tam65_cpts_write32(cpts, 0, estf[i].length);\t \n\t\tam65_cpts_write32(cpts, cpts->sr_estf[i].comp_hi, estf[i].comp_hi);\n\t\tam65_cpts_write32(cpts, cpts->sr_estf[i].comp_lo, estf[i].comp_lo);\n\t\tam65_cpts_write32(cpts, cpts->sr_estf[i].length, estf[i].length);\n\t\tam65_cpts_write32(cpts, cpts->sr_estf[i].control, estf[i].control);\n\t\tam65_cpts_write32(cpts, cpts->sr_estf[i].ppm_hi, estf[i].ppm_hi);\n\t\tam65_cpts_write32(cpts, cpts->sr_estf[i].ppm_low, estf[i].ppm_low);\n\t}\n}\nEXPORT_SYMBOL_GPL(am65_cpts_resume);\n\nstatic int am65_cpts_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct am65_cpts *cpts;\n\tvoid __iomem *base;\n\n\tbase = devm_platform_ioremap_resource_byname(pdev, \"cpts\");\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tcpts = am65_cpts_create(dev, base, node);\n\treturn PTR_ERR_OR_ZERO(cpts);\n}\n\nstatic const struct of_device_id am65_cpts_of_match[] = {\n\t{ .compatible = \"ti,am65-cpts\", },\n\t{ .compatible = \"ti,j721e-cpts\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, am65_cpts_of_match);\n\nstatic struct platform_driver am65_cpts_driver = {\n\t.probe\t\t= am65_cpts_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"am65-cpts\",\n\t\t.of_match_table = am65_cpts_of_match,\n\t},\n};\nmodule_platform_driver(am65_cpts_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Grygorii Strashko <grygorii.strashko@ti.com>\");\nMODULE_DESCRIPTION(\"TI K3 AM65 CPTS driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}