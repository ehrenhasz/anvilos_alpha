{
  "module_name": "am65-cpsw-nuss.c",
  "hash_id": "b13893a76727bcc63fb90409b1f38284776f7179d9d15811bf092cbb8f85ce6e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ti/am65-cpsw-nuss.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/etherdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/kmemleak.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/net_tstamp.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#include <linux/phylink.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/rtnetlink.h>\n#include <linux/mfd/syscon.h>\n#include <linux/sys_soc.h>\n#include <linux/dma/ti-cppi5.h>\n#include <linux/dma/k3-udma-glue.h>\n#include <net/switchdev.h>\n\n#include \"cpsw_ale.h\"\n#include \"cpsw_sl.h\"\n#include \"am65-cpsw-nuss.h\"\n#include \"am65-cpsw-switchdev.h\"\n#include \"k3-cppi-desc-pool.h\"\n#include \"am65-cpts.h\"\n\n#define AM65_CPSW_SS_BASE\t0x0\n#define AM65_CPSW_SGMII_BASE\t0x100\n#define AM65_CPSW_XGMII_BASE\t0x2100\n#define AM65_CPSW_CPSW_NU_BASE\t0x20000\n#define AM65_CPSW_NU_PORTS_BASE\t0x1000\n#define AM65_CPSW_NU_FRAM_BASE\t0x12000\n#define AM65_CPSW_NU_STATS_BASE\t0x1a000\n#define AM65_CPSW_NU_ALE_BASE\t0x1e000\n#define AM65_CPSW_NU_CPTS_BASE\t0x1d000\n\n#define AM65_CPSW_NU_PORTS_OFFSET\t0x1000\n#define AM65_CPSW_NU_STATS_PORT_OFFSET\t0x200\n#define AM65_CPSW_NU_FRAM_PORT_OFFSET\t0x200\n\n#define AM65_CPSW_MAX_PORTS\t8\n\n#define AM65_CPSW_MIN_PACKET_SIZE\tVLAN_ETH_ZLEN\n#define AM65_CPSW_MAX_PACKET_SIZE\t2024\n\n#define AM65_CPSW_REG_CTL\t\t0x004\n#define AM65_CPSW_REG_STAT_PORT_EN\t0x014\n#define AM65_CPSW_REG_PTYPE\t\t0x018\n\n#define AM65_CPSW_P0_REG_CTL\t\t\t0x004\n#define AM65_CPSW_PORT0_REG_FLOW_ID_OFFSET\t0x008\n\n#define AM65_CPSW_PORT_REG_PRI_CTL\t\t0x01c\n#define AM65_CPSW_PORT_REG_RX_PRI_MAP\t\t0x020\n#define AM65_CPSW_PORT_REG_RX_MAXLEN\t\t0x024\n\n#define AM65_CPSW_PORTN_REG_SA_L\t\t0x308\n#define AM65_CPSW_PORTN_REG_SA_H\t\t0x30c\n#define AM65_CPSW_PORTN_REG_TS_CTL              0x310\n#define AM65_CPSW_PORTN_REG_TS_SEQ_LTYPE_REG\t0x314\n#define AM65_CPSW_PORTN_REG_TS_VLAN_LTYPE_REG\t0x318\n#define AM65_CPSW_PORTN_REG_TS_CTL_LTYPE2       0x31C\n\n#define AM65_CPSW_SGMII_CONTROL_REG\t\t0x010\n#define AM65_CPSW_SGMII_MR_ADV_ABILITY_REG\t0x018\n#define AM65_CPSW_SGMII_CONTROL_MR_AN_ENABLE\tBIT(0)\n\n#define AM65_CPSW_CTL_VLAN_AWARE\t\tBIT(1)\n#define AM65_CPSW_CTL_P0_ENABLE\t\t\tBIT(2)\n#define AM65_CPSW_CTL_P0_TX_CRC_REMOVE\t\tBIT(13)\n#define AM65_CPSW_CTL_P0_RX_PAD\t\t\tBIT(14)\n\n \n#define AM65_CPSW_P0_REG_CTL_RX_CHECKSUM_EN\tBIT(0)\n#define AM65_CPSW_P0_REG_CTL_RX_REMAP_VLAN\tBIT(16)\n\n \n#define AM65_CPSW_PORT_REG_PRI_CTL_RX_PTYPE_RROBIN\tBIT(8)\n\n \n#define AM65_CPSW_PN_TS_CTL_TX_ANX_F_EN\t\tBIT(4)\n#define AM65_CPSW_PN_TS_CTL_TX_VLAN_LT1_EN\tBIT(5)\n#define AM65_CPSW_PN_TS_CTL_TX_VLAN_LT2_EN\tBIT(6)\n#define AM65_CPSW_PN_TS_CTL_TX_ANX_D_EN\t\tBIT(7)\n#define AM65_CPSW_PN_TS_CTL_TX_ANX_E_EN\t\tBIT(10)\n#define AM65_CPSW_PN_TS_CTL_TX_HOST_TS_EN\tBIT(11)\n#define AM65_CPSW_PN_TS_CTL_MSG_TYPE_EN_SHIFT\t16\n\n \n#define AM65_CPSW_PN_TS_SEQ_ID_OFFSET_SHIFT\t16\n\n \n#define AM65_CPSW_PN_TS_CTL_LTYPE2_TS_107\tBIT(16)\n#define AM65_CPSW_PN_TS_CTL_LTYPE2_TS_129\tBIT(17)\n#define AM65_CPSW_PN_TS_CTL_LTYPE2_TS_130\tBIT(18)\n#define AM65_CPSW_PN_TS_CTL_LTYPE2_TS_131\tBIT(19)\n#define AM65_CPSW_PN_TS_CTL_LTYPE2_TS_132\tBIT(20)\n#define AM65_CPSW_PN_TS_CTL_LTYPE2_TS_319\tBIT(21)\n#define AM65_CPSW_PN_TS_CTL_LTYPE2_TS_320\tBIT(22)\n#define AM65_CPSW_PN_TS_CTL_LTYPE2_TS_TTL_NONZERO BIT(23)\n\n \n#define AM65_CPSW_TS_EVENT_MSG_TYPE_BITS (BIT(0) | BIT(1) | BIT(2) | BIT(3))\n\n#define AM65_CPSW_TS_SEQ_ID_OFFSET (0x1e)\n\n#define AM65_CPSW_TS_TX_ANX_ALL_EN\t\t\\\n\t(AM65_CPSW_PN_TS_CTL_TX_ANX_D_EN |\t\\\n\t AM65_CPSW_PN_TS_CTL_TX_ANX_E_EN |\t\\\n\t AM65_CPSW_PN_TS_CTL_TX_ANX_F_EN)\n\n#define AM65_CPSW_ALE_AGEOUT_DEFAULT\t30\n \n#define AM65_CPSW_MAX_TX_DESC\t500\n#define AM65_CPSW_MAX_RX_DESC\t500\n\n#define AM65_CPSW_NAV_PS_DATA_SIZE 16\n#define AM65_CPSW_NAV_SW_DATA_SIZE 16\n\n#define AM65_CPSW_DEBUG\t(NETIF_MSG_HW | NETIF_MSG_DRV | NETIF_MSG_LINK | \\\n\t\t\t NETIF_MSG_IFUP\t| NETIF_MSG_PROBE | NETIF_MSG_IFDOWN | \\\n\t\t\t NETIF_MSG_RX_ERR | NETIF_MSG_TX_ERR)\n\nstatic void am65_cpsw_port_set_sl_mac(struct am65_cpsw_port *slave,\n\t\t\t\t      const u8 *dev_addr)\n{\n\tu32 mac_hi = (dev_addr[0] << 0) | (dev_addr[1] << 8) |\n\t\t     (dev_addr[2] << 16) | (dev_addr[3] << 24);\n\tu32 mac_lo = (dev_addr[4] << 0) | (dev_addr[5] << 8);\n\n\twritel(mac_hi, slave->port_base + AM65_CPSW_PORTN_REG_SA_H);\n\twritel(mac_lo, slave->port_base + AM65_CPSW_PORTN_REG_SA_L);\n}\n\nstatic void am65_cpsw_sl_ctl_reset(struct am65_cpsw_port *port)\n{\n\tcpsw_sl_reset(port->slave.mac_sl, 100);\n\t \n\twritel(AM65_CPSW_MAX_PACKET_SIZE,\n\t       port->port_base + AM65_CPSW_PORT_REG_RX_MAXLEN);\n}\n\nstatic void am65_cpsw_nuss_get_ver(struct am65_cpsw_common *common)\n{\n\tcommon->nuss_ver = readl(common->ss_base);\n\tcommon->cpsw_ver = readl(common->cpsw_base);\n\tdev_info(common->dev,\n\t\t \"initializing am65 cpsw nuss version 0x%08X, cpsw version 0x%08X Ports: %u quirks:%08x\\n\",\n\t\tcommon->nuss_ver,\n\t\tcommon->cpsw_ver,\n\t\tcommon->port_num + 1,\n\t\tcommon->pdata.quirks);\n}\n\nstatic int am65_cpsw_nuss_ndo_slave_add_vid(struct net_device *ndev,\n\t\t\t\t\t    __be16 proto, u16 vid)\n{\n\tstruct am65_cpsw_common *common = am65_ndev_to_common(ndev);\n\tstruct am65_cpsw_port *port = am65_ndev_to_port(ndev);\n\tu32 port_mask, unreg_mcast = 0;\n\tint ret;\n\n\tif (!common->is_emac_mode)\n\t\treturn 0;\n\n\tif (!netif_running(ndev) || !vid)\n\t\treturn 0;\n\n\tret = pm_runtime_resume_and_get(common->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tport_mask = BIT(port->port_id) | ALE_PORT_HOST;\n\tif (!vid)\n\t\tunreg_mcast = port_mask;\n\tdev_info(common->dev, \"Adding vlan %d to vlan filter\\n\", vid);\n\tret = cpsw_ale_vlan_add_modify(common->ale, vid, port_mask,\n\t\t\t\t       unreg_mcast, port_mask, 0);\n\n\tpm_runtime_put(common->dev);\n\treturn ret;\n}\n\nstatic int am65_cpsw_nuss_ndo_slave_kill_vid(struct net_device *ndev,\n\t\t\t\t\t     __be16 proto, u16 vid)\n{\n\tstruct am65_cpsw_common *common = am65_ndev_to_common(ndev);\n\tstruct am65_cpsw_port *port = am65_ndev_to_port(ndev);\n\tint ret;\n\n\tif (!common->is_emac_mode)\n\t\treturn 0;\n\n\tif (!netif_running(ndev) || !vid)\n\t\treturn 0;\n\n\tret = pm_runtime_resume_and_get(common->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(common->dev, \"Removing vlan %d from vlan filter\\n\", vid);\n\tret = cpsw_ale_del_vlan(common->ale, vid,\n\t\t\t\tBIT(port->port_id) | ALE_PORT_HOST);\n\n\tpm_runtime_put(common->dev);\n\treturn ret;\n}\n\nstatic void am65_cpsw_slave_set_promisc(struct am65_cpsw_port *port,\n\t\t\t\t\tbool promisc)\n{\n\tstruct am65_cpsw_common *common = port->common;\n\n\tif (promisc && !common->is_emac_mode) {\n\t\tdev_dbg(common->dev, \"promisc mode requested in switch mode\");\n\t\treturn;\n\t}\n\n\tif (promisc) {\n\t\t \n\t\tcpsw_ale_control_set(common->ale, port->port_id,\n\t\t\t\t     ALE_PORT_MACONLY_CAF, 1);\n\t\tdev_dbg(common->dev, \"promisc enabled\\n\");\n\t} else {\n\t\t \n\t\tcpsw_ale_control_set(common->ale, port->port_id,\n\t\t\t\t     ALE_PORT_MACONLY_CAF, 0);\n\t\tdev_dbg(common->dev, \"promisc disabled\\n\");\n\t}\n}\n\nstatic void am65_cpsw_nuss_ndo_slave_set_rx_mode(struct net_device *ndev)\n{\n\tstruct am65_cpsw_common *common = am65_ndev_to_common(ndev);\n\tstruct am65_cpsw_port *port = am65_ndev_to_port(ndev);\n\tu32 port_mask;\n\tbool promisc;\n\n\tpromisc = !!(ndev->flags & IFF_PROMISC);\n\tam65_cpsw_slave_set_promisc(port, promisc);\n\n\tif (promisc)\n\t\treturn;\n\n\t \n\tcpsw_ale_set_allmulti(common->ale,\n\t\t\t      ndev->flags & IFF_ALLMULTI, port->port_id);\n\n\tport_mask = ALE_PORT_HOST;\n\t \n\tcpsw_ale_flush_multicast(common->ale, port_mask, -1);\n\n\tif (!netdev_mc_empty(ndev)) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\t \n\t\tnetdev_for_each_mc_addr(ha, ndev) {\n\t\t\tcpsw_ale_add_mcast(common->ale, ha->addr,\n\t\t\t\t\t   port_mask, 0, 0, 0);\n\t\t}\n\t}\n}\n\nstatic void am65_cpsw_nuss_ndo_host_tx_timeout(struct net_device *ndev,\n\t\t\t\t\t       unsigned int txqueue)\n{\n\tstruct am65_cpsw_common *common = am65_ndev_to_common(ndev);\n\tstruct am65_cpsw_tx_chn *tx_chn;\n\tstruct netdev_queue *netif_txq;\n\tunsigned long trans_start;\n\n\tnetif_txq = netdev_get_tx_queue(ndev, txqueue);\n\ttx_chn = &common->tx_chns[txqueue];\n\ttrans_start = READ_ONCE(netif_txq->trans_start);\n\n\tnetdev_err(ndev, \"txq:%d DRV_XOFF:%d tmo:%u dql_avail:%d free_desc:%zu\\n\",\n\t\t   txqueue,\n\t\t   netif_tx_queue_stopped(netif_txq),\n\t\t   jiffies_to_msecs(jiffies - trans_start),\n\t\t   dql_avail(&netif_txq->dql),\n\t\t   k3_cppi_desc_pool_avail(tx_chn->desc_pool));\n\n\tif (netif_tx_queue_stopped(netif_txq)) {\n\t\t \n\t\ttxq_trans_update(netif_txq);\n\t\tnetif_tx_wake_queue(netif_txq);\n\t}\n}\n\nstatic int am65_cpsw_nuss_rx_push(struct am65_cpsw_common *common,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct am65_cpsw_rx_chn *rx_chn = &common->rx_chns;\n\tstruct cppi5_host_desc_t *desc_rx;\n\tstruct device *dev = common->dev;\n\tu32 pkt_len = skb_tailroom(skb);\n\tdma_addr_t desc_dma;\n\tdma_addr_t buf_dma;\n\tvoid *swdata;\n\n\tdesc_rx = k3_cppi_desc_pool_alloc(rx_chn->desc_pool);\n\tif (!desc_rx) {\n\t\tdev_err(dev, \"Failed to allocate RXFDQ descriptor\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdesc_dma = k3_cppi_desc_pool_virt2dma(rx_chn->desc_pool, desc_rx);\n\n\tbuf_dma = dma_map_single(rx_chn->dma_dev, skb->data, pkt_len,\n\t\t\t\t DMA_FROM_DEVICE);\n\tif (unlikely(dma_mapping_error(rx_chn->dma_dev, buf_dma))) {\n\t\tk3_cppi_desc_pool_free(rx_chn->desc_pool, desc_rx);\n\t\tdev_err(dev, \"Failed to map rx skb buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcppi5_hdesc_init(desc_rx, CPPI5_INFO0_HDESC_EPIB_PRESENT,\n\t\t\t AM65_CPSW_NAV_PS_DATA_SIZE);\n\tk3_udma_glue_rx_dma_to_cppi5_addr(rx_chn->rx_chn, &buf_dma);\n\tcppi5_hdesc_attach_buf(desc_rx, buf_dma, skb_tailroom(skb), buf_dma, skb_tailroom(skb));\n\tswdata = cppi5_hdesc_get_swdata(desc_rx);\n\t*((void **)swdata) = skb;\n\n\treturn k3_udma_glue_push_rx_chn(rx_chn->rx_chn, 0, desc_rx, desc_dma);\n}\n\nvoid am65_cpsw_nuss_set_p0_ptype(struct am65_cpsw_common *common)\n{\n\tstruct am65_cpsw_host *host_p = am65_common_get_host(common);\n\tu32 val, pri_map;\n\n\t \n\tval = readl(host_p->port_base + AM65_CPSW_PORT_REG_PRI_CTL);\n\n\tif (common->pf_p0_rx_ptype_rrobin) {\n\t\tval |= AM65_CPSW_PORT_REG_PRI_CTL_RX_PTYPE_RROBIN;\n\t\t \n\t\tpri_map = 0x0;\n\t} else {\n\t\tval &= ~AM65_CPSW_PORT_REG_PRI_CTL_RX_PTYPE_RROBIN;\n\t\t \n\t\tpri_map = 0x76543210;\n\t}\n\n\twritel(pri_map, host_p->port_base + AM65_CPSW_PORT_REG_RX_PRI_MAP);\n\twritel(val, host_p->port_base + AM65_CPSW_PORT_REG_PRI_CTL);\n}\n\nstatic void am65_cpsw_init_host_port_switch(struct am65_cpsw_common *common);\nstatic void am65_cpsw_init_host_port_emac(struct am65_cpsw_common *common);\nstatic void am65_cpsw_init_port_switch_ale(struct am65_cpsw_port *port);\nstatic void am65_cpsw_init_port_emac_ale(struct am65_cpsw_port *port);\n\nstatic int am65_cpsw_nuss_common_open(struct am65_cpsw_common *common)\n{\n\tstruct am65_cpsw_host *host_p = am65_common_get_host(common);\n\tint port_idx, i, ret;\n\tstruct sk_buff *skb;\n\tu32 val, port_mask;\n\n\tif (common->usage_count)\n\t\treturn 0;\n\n\t \n\twritel(AM65_CPSW_CTL_P0_ENABLE | AM65_CPSW_CTL_P0_TX_CRC_REMOVE |\n\t       AM65_CPSW_CTL_VLAN_AWARE | AM65_CPSW_CTL_P0_RX_PAD,\n\t       common->cpsw_base + AM65_CPSW_REG_CTL);\n\t \n\twritel(AM65_CPSW_MAX_PACKET_SIZE,\n\t       host_p->port_base + AM65_CPSW_PORT_REG_RX_MAXLEN);\n\t \n\twritel(common->rx_flow_id_base,\n\t       host_p->port_base + AM65_CPSW_PORT0_REG_FLOW_ID_OFFSET);\n\twritel(AM65_CPSW_P0_REG_CTL_RX_CHECKSUM_EN | AM65_CPSW_P0_REG_CTL_RX_REMAP_VLAN,\n\t       host_p->port_base + AM65_CPSW_P0_REG_CTL);\n\n\tam65_cpsw_nuss_set_p0_ptype(common);\n\n\t \n\tval = BIT(HOST_PORT_NUM);\n\tfor (port_idx = 0; port_idx < common->port_num; port_idx++) {\n\t\tstruct am65_cpsw_port *port = &common->ports[port_idx];\n\n\t\tif (!port->disabled)\n\t\t\tval |=  BIT(port->port_id);\n\t}\n\twritel(val, common->cpsw_base + AM65_CPSW_REG_STAT_PORT_EN);\n\n\t \n\twritel(0, common->cpsw_base + AM65_CPSW_REG_PTYPE);\n\n\tcpsw_ale_start(common->ale);\n\n\t \n\tcpsw_ale_control_set(common->ale, HOST_PORT_NUM,\n\t\t\t     ALE_DEFAULT_THREAD_ID, 0);\n\tcpsw_ale_control_set(common->ale, HOST_PORT_NUM,\n\t\t\t     ALE_DEFAULT_THREAD_ENABLE, 1);\n\t \n\tcpsw_ale_control_set(common->ale, HOST_PORT_NUM, ALE_VLAN_AWARE, 1);\n\tcpsw_ale_control_set(common->ale, HOST_PORT_NUM,\n\t\t\t     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);\n\n\t \n\tport_mask = GENMASK(common->port_num, 0) &\n\t\t    ~common->disabled_ports_mask;\n\n\tcpsw_ale_add_vlan(common->ale, 0, port_mask,\n\t\t\t  port_mask, port_mask,\n\t\t\t  port_mask & ~ALE_PORT_HOST);\n\n\tif (common->is_emac_mode)\n\t\tam65_cpsw_init_host_port_emac(common);\n\telse\n\t\tam65_cpsw_init_host_port_switch(common);\n\n\tam65_cpsw_qos_tx_p0_rate_init(common);\n\n\tfor (i = 0; i < common->rx_chns.descs_num; i++) {\n\t\tskb = __netdev_alloc_skb_ip_align(NULL,\n\t\t\t\t\t\t  AM65_CPSW_MAX_PACKET_SIZE,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tdev_err(common->dev, \"cannot allocate skb\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tret = am65_cpsw_nuss_rx_push(common, skb);\n\t\tif (ret < 0) {\n\t\t\tdev_err(common->dev,\n\t\t\t\t\"cannot submit skb to channel rx, error %d\\n\",\n\t\t\t\tret);\n\t\t\tkfree_skb(skb);\n\t\t\treturn ret;\n\t\t}\n\t\tkmemleak_not_leak(skb);\n\t}\n\tk3_udma_glue_enable_rx_chn(common->rx_chns.rx_chn);\n\n\tfor (i = 0; i < common->tx_ch_num; i++) {\n\t\tret = k3_udma_glue_enable_tx_chn(common->tx_chns[i].tx_chn);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tnapi_enable(&common->tx_chns[i].napi_tx);\n\t}\n\n\tnapi_enable(&common->napi_rx);\n\tif (common->rx_irq_disabled) {\n\t\tcommon->rx_irq_disabled = false;\n\t\tenable_irq(common->rx_chns.irq);\n\t}\n\n\tdev_dbg(common->dev, \"cpsw_nuss started\\n\");\n\treturn 0;\n}\n\nstatic void am65_cpsw_nuss_tx_cleanup(void *data, dma_addr_t desc_dma);\nstatic void am65_cpsw_nuss_rx_cleanup(void *data, dma_addr_t desc_dma);\n\nstatic int am65_cpsw_nuss_common_stop(struct am65_cpsw_common *common)\n{\n\tint i;\n\n\tif (common->usage_count != 1)\n\t\treturn 0;\n\n\tcpsw_ale_control_set(common->ale, HOST_PORT_NUM,\n\t\t\t     ALE_PORT_STATE, ALE_PORT_STATE_DISABLE);\n\n\t \n\tatomic_set(&common->tdown_cnt, common->tx_ch_num);\n\t \n\tsmp_mb__after_atomic();\n\treinit_completion(&common->tdown_complete);\n\n\tfor (i = 0; i < common->tx_ch_num; i++)\n\t\tk3_udma_glue_tdown_tx_chn(common->tx_chns[i].tx_chn, false);\n\n\ti = wait_for_completion_timeout(&common->tdown_complete,\n\t\t\t\t\tmsecs_to_jiffies(1000));\n\tif (!i)\n\t\tdev_err(common->dev, \"tx timeout\\n\");\n\tfor (i = 0; i < common->tx_ch_num; i++)\n\t\tnapi_disable(&common->tx_chns[i].napi_tx);\n\n\tfor (i = 0; i < common->tx_ch_num; i++) {\n\t\tk3_udma_glue_reset_tx_chn(common->tx_chns[i].tx_chn,\n\t\t\t\t\t  &common->tx_chns[i],\n\t\t\t\t\t  am65_cpsw_nuss_tx_cleanup);\n\t\tk3_udma_glue_disable_tx_chn(common->tx_chns[i].tx_chn);\n\t}\n\n\treinit_completion(&common->tdown_complete);\n\tk3_udma_glue_tdown_rx_chn(common->rx_chns.rx_chn, true);\n\n\tif (common->pdata.quirks & AM64_CPSW_QUIRK_DMA_RX_TDOWN_IRQ) {\n\t\ti = wait_for_completion_timeout(&common->tdown_complete, msecs_to_jiffies(1000));\n\t\tif (!i)\n\t\t\tdev_err(common->dev, \"rx teardown timeout\\n\");\n\t}\n\n\tnapi_disable(&common->napi_rx);\n\n\tfor (i = 0; i < AM65_CPSW_MAX_RX_FLOWS; i++)\n\t\tk3_udma_glue_reset_rx_chn(common->rx_chns.rx_chn, i,\n\t\t\t\t\t  &common->rx_chns,\n\t\t\t\t\t  am65_cpsw_nuss_rx_cleanup, !!i);\n\n\tk3_udma_glue_disable_rx_chn(common->rx_chns.rx_chn);\n\n\tcpsw_ale_stop(common->ale);\n\n\twritel(0, common->cpsw_base + AM65_CPSW_REG_CTL);\n\twritel(0, common->cpsw_base + AM65_CPSW_REG_STAT_PORT_EN);\n\n\tdev_dbg(common->dev, \"cpsw_nuss stopped\\n\");\n\treturn 0;\n}\n\nstatic int am65_cpsw_nuss_ndo_slave_stop(struct net_device *ndev)\n{\n\tstruct am65_cpsw_common *common = am65_ndev_to_common(ndev);\n\tstruct am65_cpsw_port *port = am65_ndev_to_port(ndev);\n\tint ret;\n\n\tphylink_stop(port->slave.phylink);\n\n\tnetif_tx_stop_all_queues(ndev);\n\n\tphylink_disconnect_phy(port->slave.phylink);\n\n\tret = am65_cpsw_nuss_common_stop(common);\n\tif (ret)\n\t\treturn ret;\n\n\tcommon->usage_count--;\n\tpm_runtime_put(common->dev);\n\treturn 0;\n}\n\nstatic int cpsw_restore_vlans(struct net_device *vdev, int vid, void *arg)\n{\n\tstruct am65_cpsw_port *port = arg;\n\n\tif (!vdev)\n\t\treturn 0;\n\n\treturn am65_cpsw_nuss_ndo_slave_add_vid(port->ndev, 0, vid);\n}\n\nstatic int am65_cpsw_nuss_ndo_slave_open(struct net_device *ndev)\n{\n\tstruct am65_cpsw_common *common = am65_ndev_to_common(ndev);\n\tstruct am65_cpsw_port *port = am65_ndev_to_port(ndev);\n\tint ret, i;\n\tu32 reg;\n\n\tret = pm_runtime_resume_and_get(common->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tcpsw_sl_ctl_set(port->slave.mac_sl, CPSW_SL_CTL_CMD_IDLE);\n\tcpsw_sl_wait_for_idle(port->slave.mac_sl, 100);\n\tcpsw_sl_ctl_reset(port->slave.mac_sl);\n\n\t \n\tcpsw_sl_reg_write(port->slave.mac_sl, CPSW_SL_SOFT_RESET, 1);\n\tmdelay(1);\n\treg = cpsw_sl_reg_read(port->slave.mac_sl, CPSW_SL_SOFT_RESET);\n\tif (reg) {\n\t\tdev_err(common->dev, \"soft RESET didn't complete\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto runtime_put;\n\t}\n\n\t \n\tret = netif_set_real_num_tx_queues(ndev, common->tx_ch_num);\n\tif (ret) {\n\t\tdev_err(common->dev, \"cannot set real number of tx queues\\n\");\n\t\tgoto runtime_put;\n\t}\n\n\tret = netif_set_real_num_rx_queues(ndev, AM65_CPSW_MAX_RX_QUEUES);\n\tif (ret) {\n\t\tdev_err(common->dev, \"cannot set real number of rx queues\\n\");\n\t\tgoto runtime_put;\n\t}\n\n\tfor (i = 0; i < common->tx_ch_num; i++) {\n\t\tstruct netdev_queue *txq = netdev_get_tx_queue(ndev, i);\n\n\t\tnetdev_tx_reset_queue(txq);\n\t\ttxq->tx_maxrate =  common->tx_chns[i].rate_mbps;\n\t}\n\n\tret = am65_cpsw_nuss_common_open(common);\n\tif (ret)\n\t\tgoto runtime_put;\n\n\tcommon->usage_count++;\n\n\tam65_cpsw_port_set_sl_mac(port, ndev->dev_addr);\n\n\tif (common->is_emac_mode)\n\t\tam65_cpsw_init_port_emac_ale(port);\n\telse\n\t\tam65_cpsw_init_port_switch_ale(port);\n\n\t \n\tam65_cpsw_sl_ctl_reset(port);\n\n\tret = phylink_of_phy_connect(port->slave.phylink, port->slave.phy_node, 0);\n\tif (ret)\n\t\tgoto error_cleanup;\n\n\t \n\tvlan_for_each(ndev, cpsw_restore_vlans, port);\n\n\tphylink_start(port->slave.phylink);\n\n\treturn 0;\n\nerror_cleanup:\n\tam65_cpsw_nuss_ndo_slave_stop(ndev);\n\treturn ret;\n\nruntime_put:\n\tpm_runtime_put(common->dev);\n\treturn ret;\n}\n\nstatic void am65_cpsw_nuss_rx_cleanup(void *data, dma_addr_t desc_dma)\n{\n\tstruct am65_cpsw_rx_chn *rx_chn = data;\n\tstruct cppi5_host_desc_t *desc_rx;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_dma;\n\tu32 buf_dma_len;\n\tvoid **swdata;\n\n\tdesc_rx = k3_cppi_desc_pool_dma2virt(rx_chn->desc_pool, desc_dma);\n\tswdata = cppi5_hdesc_get_swdata(desc_rx);\n\tskb = *swdata;\n\tcppi5_hdesc_get_obuf(desc_rx, &buf_dma, &buf_dma_len);\n\tk3_udma_glue_rx_cppi5_to_dma_addr(rx_chn->rx_chn, &buf_dma);\n\n\tdma_unmap_single(rx_chn->dma_dev, buf_dma, buf_dma_len, DMA_FROM_DEVICE);\n\tk3_cppi_desc_pool_free(rx_chn->desc_pool, desc_rx);\n\n\tdev_kfree_skb_any(skb);\n}\n\nstatic void am65_cpsw_nuss_rx_ts(struct sk_buff *skb, u32 *psdata)\n{\n\tstruct skb_shared_hwtstamps *ssh;\n\tu64 ns;\n\n\tns = ((u64)psdata[1] << 32) | psdata[0];\n\n\tssh = skb_hwtstamps(skb);\n\tmemset(ssh, 0, sizeof(*ssh));\n\tssh->hwtstamp = ns_to_ktime(ns);\n}\n\n \n#define AM65_CPSW_RX_PSD_CSUM_ADD\tGENMASK(15, 0)\n#define AM65_CPSW_RX_PSD_CSUM_ERR\tBIT(16)\n#define AM65_CPSW_RX_PSD_IS_FRAGMENT\tBIT(17)\n#define AM65_CPSW_RX_PSD_IS_TCP\t\tBIT(18)\n#define AM65_CPSW_RX_PSD_IPV6_VALID\tBIT(19)\n#define AM65_CPSW_RX_PSD_IPV4_VALID\tBIT(20)\n\nstatic void am65_cpsw_nuss_rx_csum(struct sk_buff *skb, u32 csum_info)\n{\n\t \n\tskb_checksum_none_assert(skb);\n\n\tif (unlikely(!(skb->dev->features & NETIF_F_RXCSUM)))\n\t\treturn;\n\n\tif ((csum_info & (AM65_CPSW_RX_PSD_IPV6_VALID |\n\t\t\t  AM65_CPSW_RX_PSD_IPV4_VALID)) &&\n\t\t\t  !(csum_info & AM65_CPSW_RX_PSD_CSUM_ERR)) {\n\t\t \n\t\tif (!(csum_info & AM65_CPSW_RX_PSD_IS_FRAGMENT))\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n}\n\nstatic int am65_cpsw_nuss_rx_packets(struct am65_cpsw_common *common,\n\t\t\t\t     u32 flow_idx)\n{\n\tstruct am65_cpsw_rx_chn *rx_chn = &common->rx_chns;\n\tu32 buf_dma_len, pkt_len, port_id = 0, csum_info;\n\tstruct am65_cpsw_ndev_priv *ndev_priv;\n\tstruct am65_cpsw_ndev_stats *stats;\n\tstruct cppi5_host_desc_t *desc_rx;\n\tstruct device *dev = common->dev;\n\tstruct sk_buff *skb, *new_skb;\n\tdma_addr_t desc_dma, buf_dma;\n\tstruct am65_cpsw_port *port;\n\tstruct net_device *ndev;\n\tvoid **swdata;\n\tu32 *psdata;\n\tint ret = 0;\n\n\tret = k3_udma_glue_pop_rx_chn(rx_chn->rx_chn, flow_idx, &desc_dma);\n\tif (ret) {\n\t\tif (ret != -ENODATA)\n\t\t\tdev_err(dev, \"RX: pop chn fail %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (cppi5_desc_is_tdcm(desc_dma)) {\n\t\tdev_dbg(dev, \"%s RX tdown flow: %u\\n\", __func__, flow_idx);\n\t\tif (common->pdata.quirks & AM64_CPSW_QUIRK_DMA_RX_TDOWN_IRQ)\n\t\t\tcomplete(&common->tdown_complete);\n\t\treturn 0;\n\t}\n\n\tdesc_rx = k3_cppi_desc_pool_dma2virt(rx_chn->desc_pool, desc_dma);\n\tdev_dbg(dev, \"%s flow_idx: %u desc %pad\\n\",\n\t\t__func__, flow_idx, &desc_dma);\n\n\tswdata = cppi5_hdesc_get_swdata(desc_rx);\n\tskb = *swdata;\n\tcppi5_hdesc_get_obuf(desc_rx, &buf_dma, &buf_dma_len);\n\tk3_udma_glue_rx_cppi5_to_dma_addr(rx_chn->rx_chn, &buf_dma);\n\tpkt_len = cppi5_hdesc_get_pktlen(desc_rx);\n\tcppi5_desc_get_tags_ids(&desc_rx->hdr, &port_id, NULL);\n\tdev_dbg(dev, \"%s rx port_id:%d\\n\", __func__, port_id);\n\tport = am65_common_get_port(common, port_id);\n\tndev = port->ndev;\n\tskb->dev = ndev;\n\n\tpsdata = cppi5_hdesc_get_psdata(desc_rx);\n\t \n\tif (port->rx_ts_enabled)\n\t\tam65_cpsw_nuss_rx_ts(skb, psdata);\n\tcsum_info = psdata[2];\n\tdev_dbg(dev, \"%s rx csum_info:%#x\\n\", __func__, csum_info);\n\n\tdma_unmap_single(rx_chn->dma_dev, buf_dma, buf_dma_len, DMA_FROM_DEVICE);\n\n\tk3_cppi_desc_pool_free(rx_chn->desc_pool, desc_rx);\n\n\tnew_skb = netdev_alloc_skb_ip_align(ndev, AM65_CPSW_MAX_PACKET_SIZE);\n\tif (new_skb) {\n\t\tndev_priv = netdev_priv(ndev);\n\t\tam65_cpsw_nuss_set_offload_fwd_mark(skb, ndev_priv->offload_fwd_mark);\n\t\tskb_put(skb, pkt_len);\n\t\tskb->protocol = eth_type_trans(skb, ndev);\n\t\tam65_cpsw_nuss_rx_csum(skb, csum_info);\n\t\tnapi_gro_receive(&common->napi_rx, skb);\n\n\t\tstats = this_cpu_ptr(ndev_priv->stats);\n\n\t\tu64_stats_update_begin(&stats->syncp);\n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += pkt_len;\n\t\tu64_stats_update_end(&stats->syncp);\n\t\tkmemleak_not_leak(new_skb);\n\t} else {\n\t\tndev->stats.rx_dropped++;\n\t\tnew_skb = skb;\n\t}\n\n\tif (netif_dormant(ndev)) {\n\t\tdev_kfree_skb_any(new_skb);\n\t\tndev->stats.rx_dropped++;\n\t\treturn 0;\n\t}\n\n\tret = am65_cpsw_nuss_rx_push(common, new_skb);\n\tif (WARN_ON(ret < 0)) {\n\t\tdev_kfree_skb_any(new_skb);\n\t\tndev->stats.rx_errors++;\n\t\tndev->stats.rx_dropped++;\n\t}\n\n\treturn ret;\n}\n\nstatic int am65_cpsw_nuss_rx_poll(struct napi_struct *napi_rx, int budget)\n{\n\tstruct am65_cpsw_common *common = am65_cpsw_napi_to_common(napi_rx);\n\tint flow = AM65_CPSW_MAX_RX_FLOWS;\n\tint cur_budget, ret;\n\tint num_rx = 0;\n\n\t \n\twhile (flow--) {\n\t\tcur_budget = budget - num_rx;\n\n\t\twhile (cur_budget--) {\n\t\t\tret = am65_cpsw_nuss_rx_packets(common, flow);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tnum_rx++;\n\t\t}\n\n\t\tif (num_rx >= budget)\n\t\t\tbreak;\n\t}\n\n\tdev_dbg(common->dev, \"%s num_rx:%d %d\\n\", __func__, num_rx, budget);\n\n\tif (num_rx < budget && napi_complete_done(napi_rx, num_rx)) {\n\t\tif (common->rx_irq_disabled) {\n\t\t\tcommon->rx_irq_disabled = false;\n\t\t\tenable_irq(common->rx_chns.irq);\n\t\t}\n\t}\n\n\treturn num_rx;\n}\n\nstatic void am65_cpsw_nuss_xmit_free(struct am65_cpsw_tx_chn *tx_chn,\n\t\t\t\t     struct cppi5_host_desc_t *desc)\n{\n\tstruct cppi5_host_desc_t *first_desc, *next_desc;\n\tdma_addr_t buf_dma, next_desc_dma;\n\tu32 buf_dma_len;\n\n\tfirst_desc = desc;\n\tnext_desc = first_desc;\n\n\tcppi5_hdesc_get_obuf(first_desc, &buf_dma, &buf_dma_len);\n\tk3_udma_glue_tx_cppi5_to_dma_addr(tx_chn->tx_chn, &buf_dma);\n\n\tdma_unmap_single(tx_chn->dma_dev, buf_dma, buf_dma_len, DMA_TO_DEVICE);\n\n\tnext_desc_dma = cppi5_hdesc_get_next_hbdesc(first_desc);\n\tk3_udma_glue_tx_cppi5_to_dma_addr(tx_chn->tx_chn, &next_desc_dma);\n\twhile (next_desc_dma) {\n\t\tnext_desc = k3_cppi_desc_pool_dma2virt(tx_chn->desc_pool,\n\t\t\t\t\t\t       next_desc_dma);\n\t\tcppi5_hdesc_get_obuf(next_desc, &buf_dma, &buf_dma_len);\n\t\tk3_udma_glue_tx_cppi5_to_dma_addr(tx_chn->tx_chn, &buf_dma);\n\n\t\tdma_unmap_page(tx_chn->dma_dev, buf_dma, buf_dma_len,\n\t\t\t       DMA_TO_DEVICE);\n\n\t\tnext_desc_dma = cppi5_hdesc_get_next_hbdesc(next_desc);\n\t\tk3_udma_glue_tx_cppi5_to_dma_addr(tx_chn->tx_chn, &next_desc_dma);\n\n\t\tk3_cppi_desc_pool_free(tx_chn->desc_pool, next_desc);\n\t}\n\n\tk3_cppi_desc_pool_free(tx_chn->desc_pool, first_desc);\n}\n\nstatic void am65_cpsw_nuss_tx_cleanup(void *data, dma_addr_t desc_dma)\n{\n\tstruct am65_cpsw_tx_chn *tx_chn = data;\n\tstruct cppi5_host_desc_t *desc_tx;\n\tstruct sk_buff *skb;\n\tvoid **swdata;\n\n\tdesc_tx = k3_cppi_desc_pool_dma2virt(tx_chn->desc_pool, desc_dma);\n\tswdata = cppi5_hdesc_get_swdata(desc_tx);\n\tskb = *(swdata);\n\tam65_cpsw_nuss_xmit_free(tx_chn, desc_tx);\n\n\tdev_kfree_skb_any(skb);\n}\n\nstatic struct sk_buff *\nam65_cpsw_nuss_tx_compl_packet(struct am65_cpsw_tx_chn *tx_chn,\n\t\t\t       dma_addr_t desc_dma)\n{\n\tstruct am65_cpsw_ndev_priv *ndev_priv;\n\tstruct am65_cpsw_ndev_stats *stats;\n\tstruct cppi5_host_desc_t *desc_tx;\n\tstruct net_device *ndev;\n\tstruct sk_buff *skb;\n\tvoid **swdata;\n\n\tdesc_tx = k3_cppi_desc_pool_dma2virt(tx_chn->desc_pool,\n\t\t\t\t\t     desc_dma);\n\tswdata = cppi5_hdesc_get_swdata(desc_tx);\n\tskb = *(swdata);\n\tam65_cpsw_nuss_xmit_free(tx_chn, desc_tx);\n\n\tndev = skb->dev;\n\n\tam65_cpts_tx_timestamp(tx_chn->common->cpts, skb);\n\n\tndev_priv = netdev_priv(ndev);\n\tstats = this_cpu_ptr(ndev_priv->stats);\n\tu64_stats_update_begin(&stats->syncp);\n\tstats->tx_packets++;\n\tstats->tx_bytes += skb->len;\n\tu64_stats_update_end(&stats->syncp);\n\n\treturn skb;\n}\n\nstatic void am65_cpsw_nuss_tx_wake(struct am65_cpsw_tx_chn *tx_chn, struct net_device *ndev,\n\t\t\t\t   struct netdev_queue *netif_txq)\n{\n\tif (netif_tx_queue_stopped(netif_txq)) {\n\t\t \n\t\t__netif_tx_lock(netif_txq, smp_processor_id());\n\t\tif (netif_running(ndev) &&\n\t\t    (k3_cppi_desc_pool_avail(tx_chn->desc_pool) >= MAX_SKB_FRAGS))\n\t\t\tnetif_tx_wake_queue(netif_txq);\n\n\t\t__netif_tx_unlock(netif_txq);\n\t}\n}\n\nstatic int am65_cpsw_nuss_tx_compl_packets(struct am65_cpsw_common *common,\n\t\t\t\t\t   int chn, unsigned int budget)\n{\n\tstruct device *dev = common->dev;\n\tstruct am65_cpsw_tx_chn *tx_chn;\n\tstruct netdev_queue *netif_txq;\n\tunsigned int total_bytes = 0;\n\tstruct net_device *ndev;\n\tstruct sk_buff *skb;\n\tdma_addr_t desc_dma;\n\tint res, num_tx = 0;\n\n\ttx_chn = &common->tx_chns[chn];\n\n\twhile (true) {\n\t\tspin_lock(&tx_chn->lock);\n\t\tres = k3_udma_glue_pop_tx_chn(tx_chn->tx_chn, &desc_dma);\n\t\tspin_unlock(&tx_chn->lock);\n\t\tif (res == -ENODATA)\n\t\t\tbreak;\n\n\t\tif (cppi5_desc_is_tdcm(desc_dma)) {\n\t\t\tif (atomic_dec_and_test(&common->tdown_cnt))\n\t\t\t\tcomplete(&common->tdown_complete);\n\t\t\tbreak;\n\t\t}\n\n\t\tskb = am65_cpsw_nuss_tx_compl_packet(tx_chn, desc_dma);\n\t\ttotal_bytes = skb->len;\n\t\tndev = skb->dev;\n\t\tnapi_consume_skb(skb, budget);\n\t\tnum_tx++;\n\n\t\tnetif_txq = netdev_get_tx_queue(ndev, chn);\n\n\t\tnetdev_tx_completed_queue(netif_txq, num_tx, total_bytes);\n\n\t\tam65_cpsw_nuss_tx_wake(tx_chn, ndev, netif_txq);\n\t}\n\n\tdev_dbg(dev, \"%s:%u pkt:%d\\n\", __func__, chn, num_tx);\n\n\treturn num_tx;\n}\n\nstatic int am65_cpsw_nuss_tx_compl_packets_2g(struct am65_cpsw_common *common,\n\t\t\t\t\t      int chn, unsigned int budget)\n{\n\tstruct device *dev = common->dev;\n\tstruct am65_cpsw_tx_chn *tx_chn;\n\tstruct netdev_queue *netif_txq;\n\tunsigned int total_bytes = 0;\n\tstruct net_device *ndev;\n\tstruct sk_buff *skb;\n\tdma_addr_t desc_dma;\n\tint res, num_tx = 0;\n\n\ttx_chn = &common->tx_chns[chn];\n\n\twhile (true) {\n\t\tres = k3_udma_glue_pop_tx_chn(tx_chn->tx_chn, &desc_dma);\n\t\tif (res == -ENODATA)\n\t\t\tbreak;\n\n\t\tif (cppi5_desc_is_tdcm(desc_dma)) {\n\t\t\tif (atomic_dec_and_test(&common->tdown_cnt))\n\t\t\t\tcomplete(&common->tdown_complete);\n\t\t\tbreak;\n\t\t}\n\n\t\tskb = am65_cpsw_nuss_tx_compl_packet(tx_chn, desc_dma);\n\n\t\tndev = skb->dev;\n\t\ttotal_bytes += skb->len;\n\t\tnapi_consume_skb(skb, budget);\n\t\tnum_tx++;\n\t}\n\n\tif (!num_tx)\n\t\treturn 0;\n\n\tnetif_txq = netdev_get_tx_queue(ndev, chn);\n\n\tnetdev_tx_completed_queue(netif_txq, num_tx, total_bytes);\n\n\tam65_cpsw_nuss_tx_wake(tx_chn, ndev, netif_txq);\n\n\tdev_dbg(dev, \"%s:%u pkt:%d\\n\", __func__, chn, num_tx);\n\n\treturn num_tx;\n}\n\nstatic int am65_cpsw_nuss_tx_poll(struct napi_struct *napi_tx, int budget)\n{\n\tstruct am65_cpsw_tx_chn *tx_chn = am65_cpsw_napi_to_tx_chn(napi_tx);\n\tint num_tx;\n\n\tif (AM65_CPSW_IS_CPSW2G(tx_chn->common))\n\t\tnum_tx = am65_cpsw_nuss_tx_compl_packets_2g(tx_chn->common, tx_chn->id, budget);\n\telse\n\t\tnum_tx = am65_cpsw_nuss_tx_compl_packets(tx_chn->common, tx_chn->id, budget);\n\n\tif (num_tx >= budget)\n\t\treturn budget;\n\n\tif (napi_complete_done(napi_tx, num_tx))\n\t\tenable_irq(tx_chn->irq);\n\n\treturn 0;\n}\n\nstatic irqreturn_t am65_cpsw_nuss_rx_irq(int irq, void *dev_id)\n{\n\tstruct am65_cpsw_common *common = dev_id;\n\n\tcommon->rx_irq_disabled = true;\n\tdisable_irq_nosync(irq);\n\tnapi_schedule(&common->napi_rx);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t am65_cpsw_nuss_tx_irq(int irq, void *dev_id)\n{\n\tstruct am65_cpsw_tx_chn *tx_chn = dev_id;\n\n\tdisable_irq_nosync(irq);\n\tnapi_schedule(&tx_chn->napi_tx);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic netdev_tx_t am65_cpsw_nuss_ndo_slave_xmit(struct sk_buff *skb,\n\t\t\t\t\t\t struct net_device *ndev)\n{\n\tstruct am65_cpsw_common *common = am65_ndev_to_common(ndev);\n\tstruct cppi5_host_desc_t *first_desc, *next_desc, *cur_desc;\n\tstruct am65_cpsw_port *port = am65_ndev_to_port(ndev);\n\tstruct device *dev = common->dev;\n\tstruct am65_cpsw_tx_chn *tx_chn;\n\tstruct netdev_queue *netif_txq;\n\tdma_addr_t desc_dma, buf_dma;\n\tint ret, q_idx, i;\n\tvoid **swdata;\n\tu32 *psdata;\n\tu32 pkt_len;\n\n\t \n\tpkt_len = skb_headlen(skb);\n\n\t \n\tif (port->tx_ts_enabled)\n\t\tam65_cpts_prep_tx_timestamp(common->cpts, skb);\n\n\tq_idx = skb_get_queue_mapping(skb);\n\tdev_dbg(dev, \"%s skb_queue:%d\\n\", __func__, q_idx);\n\n\ttx_chn = &common->tx_chns[q_idx];\n\tnetif_txq = netdev_get_tx_queue(ndev, q_idx);\n\n\t \n\tbuf_dma = dma_map_single(tx_chn->dma_dev, skb->data, pkt_len,\n\t\t\t\t DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(tx_chn->dma_dev, buf_dma))) {\n\t\tdev_err(dev, \"Failed to map tx skb buffer\\n\");\n\t\tndev->stats.tx_errors++;\n\t\tgoto err_free_skb;\n\t}\n\n\tfirst_desc = k3_cppi_desc_pool_alloc(tx_chn->desc_pool);\n\tif (!first_desc) {\n\t\tdev_dbg(dev, \"Failed to allocate descriptor\\n\");\n\t\tdma_unmap_single(tx_chn->dma_dev, buf_dma, pkt_len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tgoto busy_stop_q;\n\t}\n\n\tcppi5_hdesc_init(first_desc, CPPI5_INFO0_HDESC_EPIB_PRESENT,\n\t\t\t AM65_CPSW_NAV_PS_DATA_SIZE);\n\tcppi5_desc_set_pktids(&first_desc->hdr, 0, 0x3FFF);\n\tcppi5_hdesc_set_pkttype(first_desc, 0x7);\n\tcppi5_desc_set_tags_ids(&first_desc->hdr, 0, port->port_id);\n\n\tk3_udma_glue_tx_dma_to_cppi5_addr(tx_chn->tx_chn, &buf_dma);\n\tcppi5_hdesc_attach_buf(first_desc, buf_dma, pkt_len, buf_dma, pkt_len);\n\tswdata = cppi5_hdesc_get_swdata(first_desc);\n\t*(swdata) = skb;\n\tpsdata = cppi5_hdesc_get_psdata(first_desc);\n\n\t \n\tpsdata[2] = 0;\n\tif (likely(skb->ip_summed == CHECKSUM_PARTIAL)) {\n\t\tunsigned int cs_start, cs_offset;\n\n\t\tcs_start = skb_transport_offset(skb);\n\t\tcs_offset = cs_start + skb->csum_offset;\n\t\t \n\t\tpsdata[2] = ((cs_offset + 1) << 24) |\n\t\t\t    ((cs_start + 1) << 16) | (skb->len - cs_start);\n\t\tdev_dbg(dev, \"%s tx psdata:%#x\\n\", __func__, psdata[2]);\n\t}\n\n\tif (!skb_is_nonlinear(skb))\n\t\tgoto done_tx;\n\n\tdev_dbg(dev, \"fragmented SKB\\n\");\n\n\t \n\tcur_desc = first_desc;\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tu32 frag_size = skb_frag_size(frag);\n\n\t\tnext_desc = k3_cppi_desc_pool_alloc(tx_chn->desc_pool);\n\t\tif (!next_desc) {\n\t\t\tdev_err(dev, \"Failed to allocate descriptor\\n\");\n\t\t\tgoto busy_free_descs;\n\t\t}\n\n\t\tbuf_dma = skb_frag_dma_map(tx_chn->dma_dev, frag, 0, frag_size,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t\tif (unlikely(dma_mapping_error(tx_chn->dma_dev, buf_dma))) {\n\t\t\tdev_err(dev, \"Failed to map tx skb page\\n\");\n\t\t\tk3_cppi_desc_pool_free(tx_chn->desc_pool, next_desc);\n\t\t\tndev->stats.tx_errors++;\n\t\t\tgoto err_free_descs;\n\t\t}\n\n\t\tcppi5_hdesc_reset_hbdesc(next_desc);\n\t\tk3_udma_glue_tx_dma_to_cppi5_addr(tx_chn->tx_chn, &buf_dma);\n\t\tcppi5_hdesc_attach_buf(next_desc,\n\t\t\t\t       buf_dma, frag_size, buf_dma, frag_size);\n\n\t\tdesc_dma = k3_cppi_desc_pool_virt2dma(tx_chn->desc_pool,\n\t\t\t\t\t\t      next_desc);\n\t\tk3_udma_glue_tx_dma_to_cppi5_addr(tx_chn->tx_chn, &desc_dma);\n\t\tcppi5_hdesc_link_hbdesc(cur_desc, desc_dma);\n\n\t\tpkt_len += frag_size;\n\t\tcur_desc = next_desc;\n\t}\n\tWARN_ON(pkt_len != skb->len);\n\ndone_tx:\n\tskb_tx_timestamp(skb);\n\n\t \n\tnetdev_tx_sent_queue(netif_txq, pkt_len);\n\n\tcppi5_hdesc_set_pktlen(first_desc, pkt_len);\n\tdesc_dma = k3_cppi_desc_pool_virt2dma(tx_chn->desc_pool, first_desc);\n\tif (AM65_CPSW_IS_CPSW2G(common)) {\n\t\tret = k3_udma_glue_push_tx_chn(tx_chn->tx_chn, first_desc, desc_dma);\n\t} else {\n\t\tspin_lock_bh(&tx_chn->lock);\n\t\tret = k3_udma_glue_push_tx_chn(tx_chn->tx_chn, first_desc, desc_dma);\n\t\tspin_unlock_bh(&tx_chn->lock);\n\t}\n\tif (ret) {\n\t\tdev_err(dev, \"can't push desc %d\\n\", ret);\n\t\t \n\t\tnetdev_tx_completed_queue(netif_txq, 1, pkt_len);\n\t\tndev->stats.tx_errors++;\n\t\tgoto err_free_descs;\n\t}\n\n\tif (k3_cppi_desc_pool_avail(tx_chn->desc_pool) < MAX_SKB_FRAGS) {\n\t\tnetif_tx_stop_queue(netif_txq);\n\t\t \n\t\tsmp_mb__after_atomic();\n\t\tdev_dbg(dev, \"netif_tx_stop_queue %d\\n\", q_idx);\n\n\t\t \n\t\tif (k3_cppi_desc_pool_avail(tx_chn->desc_pool) >=\n\t\t    MAX_SKB_FRAGS) {\n\t\t\tnetif_tx_wake_queue(netif_txq);\n\t\t\tdev_dbg(dev, \"netif_tx_wake_queue %d\\n\", q_idx);\n\t\t}\n\t}\n\n\treturn NETDEV_TX_OK;\n\nerr_free_descs:\n\tam65_cpsw_nuss_xmit_free(tx_chn, first_desc);\nerr_free_skb:\n\tndev->stats.tx_dropped++;\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n\nbusy_free_descs:\n\tam65_cpsw_nuss_xmit_free(tx_chn, first_desc);\nbusy_stop_q:\n\tnetif_tx_stop_queue(netif_txq);\n\treturn NETDEV_TX_BUSY;\n}\n\nstatic int am65_cpsw_nuss_ndo_slave_set_mac_address(struct net_device *ndev,\n\t\t\t\t\t\t    void *addr)\n{\n\tstruct am65_cpsw_common *common = am65_ndev_to_common(ndev);\n\tstruct am65_cpsw_port *port = am65_ndev_to_port(ndev);\n\tstruct sockaddr *sockaddr = (struct sockaddr *)addr;\n\tint ret;\n\n\tret = eth_prepare_mac_addr_change(ndev, addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pm_runtime_resume_and_get(common->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcpsw_ale_del_ucast(common->ale, ndev->dev_addr,\n\t\t\t   HOST_PORT_NUM, 0, 0);\n\tcpsw_ale_add_ucast(common->ale, sockaddr->sa_data,\n\t\t\t   HOST_PORT_NUM, ALE_SECURE, 0);\n\n\tam65_cpsw_port_set_sl_mac(port, addr);\n\teth_commit_mac_addr_change(ndev, sockaddr);\n\n\tpm_runtime_put(common->dev);\n\n\treturn 0;\n}\n\nstatic int am65_cpsw_nuss_hwtstamp_set(struct net_device *ndev,\n\t\t\t\t       struct ifreq *ifr)\n{\n\tstruct am65_cpsw_common *common = am65_ndev_to_common(ndev);\n\tstruct am65_cpsw_port *port = am65_ndev_to_port(ndev);\n\tu32 ts_ctrl, seq_id, ts_ctrl_ltype2, ts_vlan_ltype;\n\tstruct hwtstamp_config cfg;\n\n\tif (!IS_ENABLED(CONFIG_TI_K3_AM65_CPTS))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))\n\t\treturn -EFAULT;\n\n\t \n\tswitch (cfg.tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\tcase HWTSTAMP_TX_ON:\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (cfg.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tport->rx_ts_enabled = false;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_ALL:\n\tcase HWTSTAMP_FILTER_SOME:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\t\tport->rx_ts_enabled = true;\n\t\tcfg.rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tport->tx_ts_enabled = (cfg.tx_type == HWTSTAMP_TX_ON);\n\n\t \n\tseq_id = (AM65_CPSW_TS_SEQ_ID_OFFSET <<\n\t\t  AM65_CPSW_PN_TS_SEQ_ID_OFFSET_SHIFT) | ETH_P_1588;\n\n\tts_vlan_ltype = ETH_P_8021Q;\n\n\tts_ctrl_ltype2 = ETH_P_1588 |\n\t\t\t AM65_CPSW_PN_TS_CTL_LTYPE2_TS_107 |\n\t\t\t AM65_CPSW_PN_TS_CTL_LTYPE2_TS_129 |\n\t\t\t AM65_CPSW_PN_TS_CTL_LTYPE2_TS_130 |\n\t\t\t AM65_CPSW_PN_TS_CTL_LTYPE2_TS_131 |\n\t\t\t AM65_CPSW_PN_TS_CTL_LTYPE2_TS_132 |\n\t\t\t AM65_CPSW_PN_TS_CTL_LTYPE2_TS_319 |\n\t\t\t AM65_CPSW_PN_TS_CTL_LTYPE2_TS_320 |\n\t\t\t AM65_CPSW_PN_TS_CTL_LTYPE2_TS_TTL_NONZERO;\n\n\tts_ctrl = AM65_CPSW_TS_EVENT_MSG_TYPE_BITS <<\n\t\t  AM65_CPSW_PN_TS_CTL_MSG_TYPE_EN_SHIFT;\n\n\tif (port->tx_ts_enabled)\n\t\tts_ctrl |= AM65_CPSW_TS_TX_ANX_ALL_EN |\n\t\t\t   AM65_CPSW_PN_TS_CTL_TX_VLAN_LT1_EN;\n\n\twritel(seq_id, port->port_base + AM65_CPSW_PORTN_REG_TS_SEQ_LTYPE_REG);\n\twritel(ts_vlan_ltype, port->port_base +\n\t       AM65_CPSW_PORTN_REG_TS_VLAN_LTYPE_REG);\n\twritel(ts_ctrl_ltype2, port->port_base +\n\t       AM65_CPSW_PORTN_REG_TS_CTL_LTYPE2);\n\twritel(ts_ctrl, port->port_base + AM65_CPSW_PORTN_REG_TS_CTL);\n\n\t \n\tam65_cpts_rx_enable(common->cpts, port->rx_ts_enabled);\n\n\treturn copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\n}\n\nstatic int am65_cpsw_nuss_hwtstamp_get(struct net_device *ndev,\n\t\t\t\t       struct ifreq *ifr)\n{\n\tstruct am65_cpsw_port *port = am65_ndev_to_port(ndev);\n\tstruct hwtstamp_config cfg;\n\n\tif (!IS_ENABLED(CONFIG_TI_K3_AM65_CPTS))\n\t\treturn -EOPNOTSUPP;\n\n\tcfg.flags = 0;\n\tcfg.tx_type = port->tx_ts_enabled ?\n\t\t      HWTSTAMP_TX_ON : HWTSTAMP_TX_OFF;\n\tcfg.rx_filter = port->rx_ts_enabled ?\n\t\t\tHWTSTAMP_FILTER_ALL : HWTSTAMP_FILTER_NONE;\n\n\treturn copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\n}\n\nstatic int am65_cpsw_nuss_ndo_slave_ioctl(struct net_device *ndev,\n\t\t\t\t\t  struct ifreq *req, int cmd)\n{\n\tstruct am65_cpsw_port *port = am65_ndev_to_port(ndev);\n\n\tif (!netif_running(ndev))\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SIOCSHWTSTAMP:\n\t\treturn am65_cpsw_nuss_hwtstamp_set(ndev, req);\n\tcase SIOCGHWTSTAMP:\n\t\treturn am65_cpsw_nuss_hwtstamp_get(ndev, req);\n\t}\n\n\treturn phylink_mii_ioctl(port->slave.phylink, req, cmd);\n}\n\nstatic void am65_cpsw_nuss_ndo_get_stats(struct net_device *dev,\n\t\t\t\t\t struct rtnl_link_stats64 *stats)\n{\n\tstruct am65_cpsw_ndev_priv *ndev_priv = netdev_priv(dev);\n\tunsigned int start;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct am65_cpsw_ndev_stats *cpu_stats;\n\t\tu64 rx_packets;\n\t\tu64 rx_bytes;\n\t\tu64 tx_packets;\n\t\tu64 tx_bytes;\n\n\t\tcpu_stats = per_cpu_ptr(ndev_priv->stats, cpu);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&cpu_stats->syncp);\n\t\t\trx_packets = cpu_stats->rx_packets;\n\t\t\trx_bytes   = cpu_stats->rx_bytes;\n\t\t\ttx_packets = cpu_stats->tx_packets;\n\t\t\ttx_bytes   = cpu_stats->tx_bytes;\n\t\t} while (u64_stats_fetch_retry(&cpu_stats->syncp, start));\n\n\t\tstats->rx_packets += rx_packets;\n\t\tstats->rx_bytes   += rx_bytes;\n\t\tstats->tx_packets += tx_packets;\n\t\tstats->tx_bytes   += tx_bytes;\n\t}\n\n\tstats->rx_errors\t= dev->stats.rx_errors;\n\tstats->rx_dropped\t= dev->stats.rx_dropped;\n\tstats->tx_dropped\t= dev->stats.tx_dropped;\n}\n\nstatic const struct net_device_ops am65_cpsw_nuss_netdev_ops = {\n\t.ndo_open\t\t= am65_cpsw_nuss_ndo_slave_open,\n\t.ndo_stop\t\t= am65_cpsw_nuss_ndo_slave_stop,\n\t.ndo_start_xmit\t\t= am65_cpsw_nuss_ndo_slave_xmit,\n\t.ndo_set_rx_mode\t= am65_cpsw_nuss_ndo_slave_set_rx_mode,\n\t.ndo_get_stats64        = am65_cpsw_nuss_ndo_get_stats,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= am65_cpsw_nuss_ndo_slave_set_mac_address,\n\t.ndo_tx_timeout\t\t= am65_cpsw_nuss_ndo_host_tx_timeout,\n\t.ndo_vlan_rx_add_vid\t= am65_cpsw_nuss_ndo_slave_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= am65_cpsw_nuss_ndo_slave_kill_vid,\n\t.ndo_eth_ioctl\t\t= am65_cpsw_nuss_ndo_slave_ioctl,\n\t.ndo_setup_tc           = am65_cpsw_qos_ndo_setup_tc,\n\t.ndo_set_tx_maxrate\t= am65_cpsw_qos_ndo_tx_p0_set_maxrate,\n};\n\nstatic void am65_cpsw_disable_phy(struct phy *phy)\n{\n\tphy_power_off(phy);\n\tphy_exit(phy);\n}\n\nstatic int am65_cpsw_enable_phy(struct phy *phy)\n{\n\tint ret;\n\n\tret = phy_init(phy);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = phy_power_on(phy);\n\tif (ret < 0) {\n\t\tphy_exit(phy);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void am65_cpsw_disable_serdes_phy(struct am65_cpsw_common *common)\n{\n\tstruct am65_cpsw_port *port;\n\tstruct phy *phy;\n\tint i;\n\n\tfor (i = 0; i < common->port_num; i++) {\n\t\tport = &common->ports[i];\n\t\tphy = port->slave.serdes_phy;\n\t\tif (phy)\n\t\t\tam65_cpsw_disable_phy(phy);\n\t}\n}\n\nstatic int am65_cpsw_init_serdes_phy(struct device *dev, struct device_node *port_np,\n\t\t\t\t     struct am65_cpsw_port *port)\n{\n\tconst char *name = \"serdes\";\n\tstruct phy *phy;\n\tint ret;\n\n\tphy = devm_of_phy_optional_get(dev, port_np, name);\n\tif (IS_ERR_OR_NULL(phy))\n\t\treturn PTR_ERR_OR_ZERO(phy);\n\n\t \n\tport->slave.serdes_phy = phy;\n\n\tret =  am65_cpsw_enable_phy(phy);\n\tif (ret < 0)\n\t\tgoto err_phy;\n\n\treturn 0;\n\nerr_phy:\n\tdevm_phy_put(dev, phy);\n\treturn ret;\n}\n\nstatic void am65_cpsw_nuss_mac_config(struct phylink_config *config, unsigned int mode,\n\t\t\t\t      const struct phylink_link_state *state)\n{\n\tstruct am65_cpsw_slave_data *slave = container_of(config, struct am65_cpsw_slave_data,\n\t\t\t\t\t\t\t  phylink_config);\n\tstruct am65_cpsw_port *port = container_of(slave, struct am65_cpsw_port, slave);\n\tstruct am65_cpsw_common *common = port->common;\n\n\tif (common->pdata.extra_modes & BIT(state->interface)) {\n\t\tif (state->interface == PHY_INTERFACE_MODE_SGMII) {\n\t\t\twritel(ADVERTISE_SGMII,\n\t\t\t       port->sgmii_base + AM65_CPSW_SGMII_MR_ADV_ABILITY_REG);\n\t\t\tcpsw_sl_ctl_set(port->slave.mac_sl, CPSW_SL_CTL_EXT_EN);\n\t\t} else {\n\t\t\tcpsw_sl_ctl_clr(port->slave.mac_sl, CPSW_SL_CTL_EXT_EN);\n\t\t}\n\n\t\tif (state->interface == PHY_INTERFACE_MODE_USXGMII) {\n\t\t\tcpsw_sl_ctl_set(port->slave.mac_sl,\n\t\t\t\t\tCPSW_SL_CTL_XGIG | CPSW_SL_CTL_XGMII_EN);\n\t\t} else {\n\t\t\tcpsw_sl_ctl_clr(port->slave.mac_sl,\n\t\t\t\t\tCPSW_SL_CTL_XGIG | CPSW_SL_CTL_XGMII_EN);\n\t\t}\n\n\t\twritel(AM65_CPSW_SGMII_CONTROL_MR_AN_ENABLE,\n\t\t       port->sgmii_base + AM65_CPSW_SGMII_CONTROL_REG);\n\t}\n}\n\nstatic void am65_cpsw_nuss_mac_link_down(struct phylink_config *config, unsigned int mode,\n\t\t\t\t\t phy_interface_t interface)\n{\n\tstruct am65_cpsw_slave_data *slave = container_of(config, struct am65_cpsw_slave_data,\n\t\t\t\t\t\t\t  phylink_config);\n\tstruct am65_cpsw_port *port = container_of(slave, struct am65_cpsw_port, slave);\n\tstruct am65_cpsw_common *common = port->common;\n\tstruct net_device *ndev = port->ndev;\n\tu32 mac_control;\n\tint tmo;\n\n\t \n\tcpsw_ale_control_set(common->ale, port->port_id, ALE_PORT_STATE, ALE_PORT_STATE_DISABLE);\n\n\tcpsw_sl_ctl_set(port->slave.mac_sl, CPSW_SL_CTL_CMD_IDLE);\n\n\ttmo = cpsw_sl_wait_for_idle(port->slave.mac_sl, 100);\n\tdev_dbg(common->dev, \"down msc_sl %08x tmo %d\\n\",\n\t\tcpsw_sl_reg_read(port->slave.mac_sl, CPSW_SL_MACSTATUS), tmo);\n\n\t \n\tmac_control = CPSW_SL_CTL_GMII_EN | CPSW_SL_CTL_GIG | CPSW_SL_CTL_IFCTL_A |\n\t\t      CPSW_SL_CTL_FULLDUPLEX | CPSW_SL_CTL_RX_FLOW_EN | CPSW_SL_CTL_TX_FLOW_EN;\n\t \n\tif (phy_interface_mode_is_rgmii(interface))\n\t\tmac_control |= CPSW_SL_CTL_EXT_EN;\n\t \n\tcpsw_sl_ctl_clr(port->slave.mac_sl, mac_control);\n\n\tam65_cpsw_qos_link_down(ndev);\n\tnetif_tx_stop_all_queues(ndev);\n}\n\nstatic void am65_cpsw_nuss_mac_link_up(struct phylink_config *config, struct phy_device *phy,\n\t\t\t\t       unsigned int mode, phy_interface_t interface, int speed,\n\t\t\t\t       int duplex, bool tx_pause, bool rx_pause)\n{\n\tstruct am65_cpsw_slave_data *slave = container_of(config, struct am65_cpsw_slave_data,\n\t\t\t\t\t\t\t  phylink_config);\n\tstruct am65_cpsw_port *port = container_of(slave, struct am65_cpsw_port, slave);\n\tstruct am65_cpsw_common *common = port->common;\n\tu32 mac_control = CPSW_SL_CTL_GMII_EN;\n\tstruct net_device *ndev = port->ndev;\n\n\t \n\tcpsw_sl_ctl_clr(port->slave.mac_sl, CPSW_SL_CTL_CMD_IDLE);\n\n\tif (speed == SPEED_1000)\n\t\tmac_control |= CPSW_SL_CTL_GIG;\n\t \n\tif (speed == SPEED_10 && phy_interface_mode_is_rgmii(interface))\n\t\t \n\t\tmac_control |= CPSW_SL_CTL_EXT_EN;\n\tif (speed == SPEED_100 && interface == PHY_INTERFACE_MODE_RMII)\n\t\tmac_control |= CPSW_SL_CTL_IFCTL_A;\n\tif (duplex)\n\t\tmac_control |= CPSW_SL_CTL_FULLDUPLEX;\n\n\t \n\tif (rx_pause)\n\t\tmac_control |= CPSW_SL_CTL_RX_FLOW_EN;\n\n\tif (tx_pause)\n\t\tmac_control |= CPSW_SL_CTL_TX_FLOW_EN;\n\n\tcpsw_sl_ctl_set(port->slave.mac_sl, mac_control);\n\n\t \n\tcpsw_ale_control_set(common->ale, port->port_id, ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);\n\n\tam65_cpsw_qos_link_up(ndev, speed);\n\tnetif_tx_wake_all_queues(ndev);\n}\n\nstatic const struct phylink_mac_ops am65_cpsw_phylink_mac_ops = {\n\t.mac_config = am65_cpsw_nuss_mac_config,\n\t.mac_link_down = am65_cpsw_nuss_mac_link_down,\n\t.mac_link_up = am65_cpsw_nuss_mac_link_up,\n};\n\nstatic void am65_cpsw_nuss_slave_disable_unused(struct am65_cpsw_port *port)\n{\n\tstruct am65_cpsw_common *common = port->common;\n\n\tif (!port->disabled)\n\t\treturn;\n\n\tcpsw_ale_control_set(common->ale, port->port_id,\n\t\t\t     ALE_PORT_STATE, ALE_PORT_STATE_DISABLE);\n\n\tcpsw_sl_reset(port->slave.mac_sl, 100);\n\tcpsw_sl_ctl_reset(port->slave.mac_sl);\n}\n\nstatic void am65_cpsw_nuss_free_tx_chns(void *data)\n{\n\tstruct am65_cpsw_common *common = data;\n\tint i;\n\n\tfor (i = 0; i < common->tx_ch_num; i++) {\n\t\tstruct am65_cpsw_tx_chn *tx_chn = &common->tx_chns[i];\n\n\t\tif (!IS_ERR_OR_NULL(tx_chn->desc_pool))\n\t\t\tk3_cppi_desc_pool_destroy(tx_chn->desc_pool);\n\n\t\tif (!IS_ERR_OR_NULL(tx_chn->tx_chn))\n\t\t\tk3_udma_glue_release_tx_chn(tx_chn->tx_chn);\n\n\t\tmemset(tx_chn, 0, sizeof(*tx_chn));\n\t}\n}\n\nvoid am65_cpsw_nuss_remove_tx_chns(struct am65_cpsw_common *common)\n{\n\tstruct device *dev = common->dev;\n\tint i;\n\n\tdevm_remove_action(dev, am65_cpsw_nuss_free_tx_chns, common);\n\n\tcommon->tx_ch_rate_msk = 0;\n\tfor (i = 0; i < common->tx_ch_num; i++) {\n\t\tstruct am65_cpsw_tx_chn *tx_chn = &common->tx_chns[i];\n\n\t\tif (tx_chn->irq)\n\t\t\tdevm_free_irq(dev, tx_chn->irq, tx_chn);\n\n\t\tnetif_napi_del(&tx_chn->napi_tx);\n\n\t\tif (!IS_ERR_OR_NULL(tx_chn->desc_pool))\n\t\t\tk3_cppi_desc_pool_destroy(tx_chn->desc_pool);\n\n\t\tif (!IS_ERR_OR_NULL(tx_chn->tx_chn))\n\t\t\tk3_udma_glue_release_tx_chn(tx_chn->tx_chn);\n\n\t\tmemset(tx_chn, 0, sizeof(*tx_chn));\n\t}\n}\n\nstatic int am65_cpsw_nuss_ndev_add_tx_napi(struct am65_cpsw_common *common)\n{\n\tstruct device *dev = common->dev;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < common->tx_ch_num; i++) {\n\t\tstruct am65_cpsw_tx_chn *tx_chn = &common->tx_chns[i];\n\n\t\tnetif_napi_add_tx(common->dma_ndev, &tx_chn->napi_tx,\n\t\t\t\t  am65_cpsw_nuss_tx_poll);\n\n\t\tret = devm_request_irq(dev, tx_chn->irq,\n\t\t\t\t       am65_cpsw_nuss_tx_irq,\n\t\t\t\t       IRQF_TRIGGER_HIGH,\n\t\t\t\t       tx_chn->tx_chn_name, tx_chn);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failure requesting tx%u irq %u, %d\\n\",\n\t\t\t\ttx_chn->id, tx_chn->irq, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\treturn ret;\n}\n\nstatic int am65_cpsw_nuss_init_tx_chns(struct am65_cpsw_common *common)\n{\n\tu32  max_desc_num = ALIGN(AM65_CPSW_MAX_TX_DESC, MAX_SKB_FRAGS);\n\tstruct k3_udma_glue_tx_channel_cfg tx_cfg = { 0 };\n\tstruct device *dev = common->dev;\n\tstruct k3_ring_cfg ring_cfg = {\n\t\t.elm_size = K3_RINGACC_RING_ELSIZE_8,\n\t\t.mode = K3_RINGACC_RING_MODE_RING,\n\t\t.flags = 0\n\t};\n\tu32 hdesc_size;\n\tint i, ret = 0;\n\n\thdesc_size = cppi5_hdesc_calc_size(true, AM65_CPSW_NAV_PS_DATA_SIZE,\n\t\t\t\t\t   AM65_CPSW_NAV_SW_DATA_SIZE);\n\n\ttx_cfg.swdata_size = AM65_CPSW_NAV_SW_DATA_SIZE;\n\ttx_cfg.tx_cfg = ring_cfg;\n\ttx_cfg.txcq_cfg = ring_cfg;\n\ttx_cfg.tx_cfg.size = max_desc_num;\n\ttx_cfg.txcq_cfg.size = max_desc_num;\n\n\tfor (i = 0; i < common->tx_ch_num; i++) {\n\t\tstruct am65_cpsw_tx_chn *tx_chn = &common->tx_chns[i];\n\n\t\tsnprintf(tx_chn->tx_chn_name,\n\t\t\t sizeof(tx_chn->tx_chn_name), \"tx%d\", i);\n\n\t\tspin_lock_init(&tx_chn->lock);\n\t\ttx_chn->common = common;\n\t\ttx_chn->id = i;\n\t\ttx_chn->descs_num = max_desc_num;\n\n\t\ttx_chn->tx_chn =\n\t\t\tk3_udma_glue_request_tx_chn(dev,\n\t\t\t\t\t\t    tx_chn->tx_chn_name,\n\t\t\t\t\t\t    &tx_cfg);\n\t\tif (IS_ERR(tx_chn->tx_chn)) {\n\t\t\tret = dev_err_probe(dev, PTR_ERR(tx_chn->tx_chn),\n\t\t\t\t\t    \"Failed to request tx dma channel\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\ttx_chn->dma_dev = k3_udma_glue_tx_get_dma_device(tx_chn->tx_chn);\n\n\t\ttx_chn->desc_pool = k3_cppi_desc_pool_create_name(tx_chn->dma_dev,\n\t\t\t\t\t\t\t\t  tx_chn->descs_num,\n\t\t\t\t\t\t\t\t  hdesc_size,\n\t\t\t\t\t\t\t\t  tx_chn->tx_chn_name);\n\t\tif (IS_ERR(tx_chn->desc_pool)) {\n\t\t\tret = PTR_ERR(tx_chn->desc_pool);\n\t\t\tdev_err(dev, \"Failed to create poll %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\ttx_chn->irq = k3_udma_glue_tx_get_irq(tx_chn->tx_chn);\n\t\tif (tx_chn->irq < 0) {\n\t\t\tdev_err(dev, \"Failed to get tx dma irq %d\\n\",\n\t\t\t\ttx_chn->irq);\n\t\t\tret = tx_chn->irq;\n\t\t\tgoto err;\n\t\t}\n\n\t\tsnprintf(tx_chn->tx_chn_name,\n\t\t\t sizeof(tx_chn->tx_chn_name), \"%s-tx%d\",\n\t\t\t dev_name(dev), tx_chn->id);\n\t}\n\n\tret = am65_cpsw_nuss_ndev_add_tx_napi(common);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to add tx NAPI %d\\n\", ret);\n\t\tgoto err;\n\t}\n\nerr:\n\ti = devm_add_action(dev, am65_cpsw_nuss_free_tx_chns, common);\n\tif (i) {\n\t\tdev_err(dev, \"Failed to add free_tx_chns action %d\\n\", i);\n\t\treturn i;\n\t}\n\n\treturn ret;\n}\n\nstatic void am65_cpsw_nuss_free_rx_chns(void *data)\n{\n\tstruct am65_cpsw_common *common = data;\n\tstruct am65_cpsw_rx_chn *rx_chn;\n\n\trx_chn = &common->rx_chns;\n\n\tif (!IS_ERR_OR_NULL(rx_chn->desc_pool))\n\t\tk3_cppi_desc_pool_destroy(rx_chn->desc_pool);\n\n\tif (!IS_ERR_OR_NULL(rx_chn->rx_chn))\n\t\tk3_udma_glue_release_rx_chn(rx_chn->rx_chn);\n}\n\nstatic void am65_cpsw_nuss_remove_rx_chns(void *data)\n{\n\tstruct am65_cpsw_common *common = data;\n\tstruct am65_cpsw_rx_chn *rx_chn;\n\tstruct device *dev = common->dev;\n\n\trx_chn = &common->rx_chns;\n\tdevm_remove_action(dev, am65_cpsw_nuss_free_rx_chns, common);\n\n\tif (!(rx_chn->irq < 0))\n\t\tdevm_free_irq(dev, rx_chn->irq, common);\n\n\tnetif_napi_del(&common->napi_rx);\n\n\tif (!IS_ERR_OR_NULL(rx_chn->desc_pool))\n\t\tk3_cppi_desc_pool_destroy(rx_chn->desc_pool);\n\n\tif (!IS_ERR_OR_NULL(rx_chn->rx_chn))\n\t\tk3_udma_glue_release_rx_chn(rx_chn->rx_chn);\n\n\tcommon->rx_flow_id_base = -1;\n}\n\nstatic int am65_cpsw_nuss_init_rx_chns(struct am65_cpsw_common *common)\n{\n\tstruct am65_cpsw_rx_chn *rx_chn = &common->rx_chns;\n\tstruct k3_udma_glue_rx_channel_cfg rx_cfg = { 0 };\n\tu32  max_desc_num = AM65_CPSW_MAX_RX_DESC;\n\tstruct device *dev = common->dev;\n\tu32 hdesc_size;\n\tu32 fdqring_id;\n\tint i, ret = 0;\n\n\thdesc_size = cppi5_hdesc_calc_size(true, AM65_CPSW_NAV_PS_DATA_SIZE,\n\t\t\t\t\t   AM65_CPSW_NAV_SW_DATA_SIZE);\n\n\trx_cfg.swdata_size = AM65_CPSW_NAV_SW_DATA_SIZE;\n\trx_cfg.flow_id_num = AM65_CPSW_MAX_RX_FLOWS;\n\trx_cfg.flow_id_base = common->rx_flow_id_base;\n\n\t \n\trx_chn->dev = dev;\n\trx_chn->descs_num = max_desc_num;\n\n\trx_chn->rx_chn = k3_udma_glue_request_rx_chn(dev, \"rx\", &rx_cfg);\n\tif (IS_ERR(rx_chn->rx_chn)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(rx_chn->rx_chn),\n\t\t\t\t    \"Failed to request rx dma channel\\n\");\n\t\tgoto err;\n\t}\n\trx_chn->dma_dev = k3_udma_glue_rx_get_dma_device(rx_chn->rx_chn);\n\n\trx_chn->desc_pool = k3_cppi_desc_pool_create_name(rx_chn->dma_dev,\n\t\t\t\t\t\t\t  rx_chn->descs_num,\n\t\t\t\t\t\t\t  hdesc_size, \"rx\");\n\tif (IS_ERR(rx_chn->desc_pool)) {\n\t\tret = PTR_ERR(rx_chn->desc_pool);\n\t\tdev_err(dev, \"Failed to create rx poll %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tcommon->rx_flow_id_base =\n\t\t\tk3_udma_glue_rx_get_flow_id_base(rx_chn->rx_chn);\n\tdev_info(dev, \"set new flow-id-base %u\\n\", common->rx_flow_id_base);\n\n\tfdqring_id = K3_RINGACC_RING_ID_ANY;\n\tfor (i = 0; i < rx_cfg.flow_id_num; i++) {\n\t\tstruct k3_ring_cfg rxring_cfg = {\n\t\t\t.elm_size = K3_RINGACC_RING_ELSIZE_8,\n\t\t\t.mode = K3_RINGACC_RING_MODE_RING,\n\t\t\t.flags = 0,\n\t\t};\n\t\tstruct k3_ring_cfg fdqring_cfg = {\n\t\t\t.elm_size = K3_RINGACC_RING_ELSIZE_8,\n\t\t\t.flags = K3_RINGACC_RING_SHARED,\n\t\t};\n\t\tstruct k3_udma_glue_rx_flow_cfg rx_flow_cfg = {\n\t\t\t.rx_cfg = rxring_cfg,\n\t\t\t.rxfdq_cfg = fdqring_cfg,\n\t\t\t.ring_rxq_id = K3_RINGACC_RING_ID_ANY,\n\t\t\t.src_tag_lo_sel =\n\t\t\t\tK3_UDMA_GLUE_SRC_TAG_LO_USE_REMOTE_SRC_TAG,\n\t\t};\n\n\t\trx_flow_cfg.ring_rxfdq0_id = fdqring_id;\n\t\trx_flow_cfg.rx_cfg.size = max_desc_num;\n\t\trx_flow_cfg.rxfdq_cfg.size = max_desc_num;\n\t\trx_flow_cfg.rxfdq_cfg.mode = common->pdata.fdqring_mode;\n\n\t\tret = k3_udma_glue_rx_flow_init(rx_chn->rx_chn,\n\t\t\t\t\t\ti, &rx_flow_cfg);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to init rx flow%d %d\\n\", i, ret);\n\t\t\tgoto err;\n\t\t}\n\t\tif (!i)\n\t\t\tfdqring_id =\n\t\t\t\tk3_udma_glue_rx_flow_get_fdq_id(rx_chn->rx_chn,\n\t\t\t\t\t\t\t\ti);\n\n\t\trx_chn->irq = k3_udma_glue_rx_get_irq(rx_chn->rx_chn, i);\n\n\t\tif (rx_chn->irq <= 0) {\n\t\t\tdev_err(dev, \"Failed to get rx dma irq %d\\n\",\n\t\t\t\trx_chn->irq);\n\t\t\tret = -ENXIO;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tnetif_napi_add(common->dma_ndev, &common->napi_rx,\n\t\t       am65_cpsw_nuss_rx_poll);\n\n\tret = devm_request_irq(dev, rx_chn->irq,\n\t\t\t       am65_cpsw_nuss_rx_irq,\n\t\t\t       IRQF_TRIGGER_HIGH, dev_name(dev), common);\n\tif (ret) {\n\t\tdev_err(dev, \"failure requesting rx irq %u, %d\\n\",\n\t\t\trx_chn->irq, ret);\n\t\tgoto err;\n\t}\n\nerr:\n\ti = devm_add_action(dev, am65_cpsw_nuss_free_rx_chns, common);\n\tif (i) {\n\t\tdev_err(dev, \"Failed to add free_rx_chns action %d\\n\", i);\n\t\treturn i;\n\t}\n\n\treturn ret;\n}\n\nstatic int am65_cpsw_nuss_init_host_p(struct am65_cpsw_common *common)\n{\n\tstruct am65_cpsw_host *host_p = am65_common_get_host(common);\n\n\thost_p->common = common;\n\thost_p->port_base = common->cpsw_base + AM65_CPSW_NU_PORTS_BASE;\n\thost_p->stat_base = common->cpsw_base + AM65_CPSW_NU_STATS_BASE;\n\n\treturn 0;\n}\n\nstatic int am65_cpsw_am654_get_efuse_macid(struct device_node *of_node,\n\t\t\t\t\t   int slave, u8 *mac_addr)\n{\n\tu32 mac_lo, mac_hi, offset;\n\tstruct regmap *syscon;\n\tint ret;\n\n\tsyscon = syscon_regmap_lookup_by_phandle(of_node, \"ti,syscon-efuse\");\n\tif (IS_ERR(syscon)) {\n\t\tif (PTR_ERR(syscon) == -ENODEV)\n\t\t\treturn 0;\n\t\treturn PTR_ERR(syscon);\n\t}\n\n\tret = of_property_read_u32_index(of_node, \"ti,syscon-efuse\", 1,\n\t\t\t\t\t &offset);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_read(syscon, offset, &mac_lo);\n\tregmap_read(syscon, offset + 4, &mac_hi);\n\n\tmac_addr[0] = (mac_hi >> 8) & 0xff;\n\tmac_addr[1] = mac_hi & 0xff;\n\tmac_addr[2] = (mac_lo >> 24) & 0xff;\n\tmac_addr[3] = (mac_lo >> 16) & 0xff;\n\tmac_addr[4] = (mac_lo >> 8) & 0xff;\n\tmac_addr[5] = mac_lo & 0xff;\n\n\treturn 0;\n}\n\nstatic int am65_cpsw_init_cpts(struct am65_cpsw_common *common)\n{\n\tstruct device *dev = common->dev;\n\tstruct device_node *node;\n\tstruct am65_cpts *cpts;\n\tvoid __iomem *reg_base;\n\n\tif (!IS_ENABLED(CONFIG_TI_K3_AM65_CPTS))\n\t\treturn 0;\n\n\tnode = of_get_child_by_name(dev->of_node, \"cpts\");\n\tif (!node) {\n\t\tdev_err(dev, \"%s cpts not found\\n\", __func__);\n\t\treturn -ENOENT;\n\t}\n\n\treg_base = common->cpsw_base + AM65_CPSW_NU_CPTS_BASE;\n\tcpts = am65_cpts_create(dev, reg_base, node);\n\tif (IS_ERR(cpts)) {\n\t\tint ret = PTR_ERR(cpts);\n\n\t\tof_node_put(node);\n\t\tdev_err(dev, \"cpts create err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tcommon->cpts = cpts;\n\t \n\tpm_runtime_forbid(dev);\n\n\treturn 0;\n}\n\nstatic int am65_cpsw_nuss_init_slave_ports(struct am65_cpsw_common *common)\n{\n\tstruct device_node *node, *port_np;\n\tstruct device *dev = common->dev;\n\tint ret;\n\n\tnode = of_get_child_by_name(dev->of_node, \"ethernet-ports\");\n\tif (!node)\n\t\treturn -ENOENT;\n\n\tfor_each_child_of_node(node, port_np) {\n\t\tstruct am65_cpsw_port *port;\n\t\tu32 port_id;\n\n\t\t \n\t\tif (strcmp(port_np->name, \"port\"))\n\t\t\tcontinue;\n\n\t\tret = of_property_read_u32(port_np, \"reg\", &port_id);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%pOF error reading port_id %d\\n\",\n\t\t\t\tport_np, ret);\n\t\t\tgoto of_node_put;\n\t\t}\n\n\t\tif (!port_id || port_id > common->port_num) {\n\t\t\tdev_err(dev, \"%pOF has invalid port_id %u %s\\n\",\n\t\t\t\tport_np, port_id, port_np->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto of_node_put;\n\t\t}\n\n\t\tport = am65_common_get_port(common, port_id);\n\t\tport->port_id = port_id;\n\t\tport->common = common;\n\t\tport->port_base = common->cpsw_base + AM65_CPSW_NU_PORTS_BASE +\n\t\t\t\t  AM65_CPSW_NU_PORTS_OFFSET * (port_id);\n\t\tif (common->pdata.extra_modes)\n\t\t\tport->sgmii_base = common->ss_base + AM65_CPSW_SGMII_BASE * (port_id);\n\t\tport->stat_base = common->cpsw_base + AM65_CPSW_NU_STATS_BASE +\n\t\t\t\t  (AM65_CPSW_NU_STATS_PORT_OFFSET * port_id);\n\t\tport->name = of_get_property(port_np, \"label\", NULL);\n\t\tport->fetch_ram_base =\n\t\t\t\tcommon->cpsw_base + AM65_CPSW_NU_FRAM_BASE +\n\t\t\t\t(AM65_CPSW_NU_FRAM_PORT_OFFSET * (port_id - 1));\n\n\t\tport->slave.mac_sl = cpsw_sl_get(\"am65\", dev, port->port_base);\n\t\tif (IS_ERR(port->slave.mac_sl)) {\n\t\t\tret = PTR_ERR(port->slave.mac_sl);\n\t\t\tgoto of_node_put;\n\t\t}\n\n\t\tport->disabled = !of_device_is_available(port_np);\n\t\tif (port->disabled) {\n\t\t\tcommon->disabled_ports_mask |= BIT(port->port_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tport->slave.ifphy = devm_of_phy_get(dev, port_np, NULL);\n\t\tif (IS_ERR(port->slave.ifphy)) {\n\t\t\tret = PTR_ERR(port->slave.ifphy);\n\t\t\tdev_err(dev, \"%pOF error retrieving port phy: %d\\n\",\n\t\t\t\tport_np, ret);\n\t\t\tgoto of_node_put;\n\t\t}\n\n\t\t \n\t\tret = am65_cpsw_init_serdes_phy(dev, port_np, port);\n\t\tif (ret)\n\t\t\tgoto of_node_put;\n\n\t\tport->slave.mac_only =\n\t\t\t\tof_property_read_bool(port_np, \"ti,mac-only\");\n\n\t\t \n\t\tport->slave.phy_node = port_np;\n\t\tret = of_get_phy_mode(port_np, &port->slave.phy_if);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%pOF read phy-mode err %d\\n\",\n\t\t\t\tport_np, ret);\n\t\t\tgoto of_node_put;\n\t\t}\n\n\t\tret = phy_set_mode_ext(port->slave.ifphy, PHY_MODE_ETHERNET, port->slave.phy_if);\n\t\tif (ret)\n\t\t\tgoto of_node_put;\n\n\t\tret = of_get_mac_address(port_np, port->slave.mac_addr);\n\t\tif (ret) {\n\t\t\tam65_cpsw_am654_get_efuse_macid(port_np,\n\t\t\t\t\t\t\tport->port_id,\n\t\t\t\t\t\t\tport->slave.mac_addr);\n\t\t\tif (!is_valid_ether_addr(port->slave.mac_addr)) {\n\t\t\t\teth_random_addr(port->slave.mac_addr);\n\t\t\t\tdev_err(dev, \"Use random MAC address\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tof_node_put(node);\n\n\t \n\tif (!(~common->disabled_ports_mask & GENMASK(common->port_num, 1))) {\n\t\tdev_err(dev, \"No Ext. port are available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n\nof_node_put:\n\tof_node_put(port_np);\n\tof_node_put(node);\n\treturn ret;\n}\n\nstatic void am65_cpsw_pcpu_stats_free(void *data)\n{\n\tstruct am65_cpsw_ndev_stats __percpu *stats = data;\n\n\tfree_percpu(stats);\n}\n\nstatic void am65_cpsw_nuss_phylink_cleanup(struct am65_cpsw_common *common)\n{\n\tstruct am65_cpsw_port *port;\n\tint i;\n\n\tfor (i = 0; i < common->port_num; i++) {\n\t\tport = &common->ports[i];\n\t\tif (port->slave.phylink)\n\t\t\tphylink_destroy(port->slave.phylink);\n\t}\n}\n\nstatic int\nam65_cpsw_nuss_init_port_ndev(struct am65_cpsw_common *common, u32 port_idx)\n{\n\tstruct am65_cpsw_ndev_priv *ndev_priv;\n\tstruct device *dev = common->dev;\n\tstruct am65_cpsw_port *port;\n\tstruct phylink *phylink;\n\tint ret;\n\n\tport = &common->ports[port_idx];\n\n\tif (port->disabled)\n\t\treturn 0;\n\n\t \n\tport->ndev = devm_alloc_etherdev_mqs(common->dev,\n\t\t\t\t\t     sizeof(struct am65_cpsw_ndev_priv),\n\t\t\t\t\t     AM65_CPSW_MAX_TX_QUEUES,\n\t\t\t\t\t     AM65_CPSW_MAX_RX_QUEUES);\n\tif (!port->ndev) {\n\t\tdev_err(dev, \"error allocating slave net_device %u\\n\",\n\t\t\tport->port_id);\n\t\treturn -ENOMEM;\n\t}\n\n\tndev_priv = netdev_priv(port->ndev);\n\tndev_priv->port = port;\n\tndev_priv->msg_enable = AM65_CPSW_DEBUG;\n\tSET_NETDEV_DEV(port->ndev, dev);\n\n\teth_hw_addr_set(port->ndev, port->slave.mac_addr);\n\n\tport->ndev->min_mtu = AM65_CPSW_MIN_PACKET_SIZE;\n\tport->ndev->max_mtu = AM65_CPSW_MAX_PACKET_SIZE -\n\t\t\t      (VLAN_ETH_HLEN + ETH_FCS_LEN);\n\tport->ndev->hw_features = NETIF_F_SG |\n\t\t\t\t  NETIF_F_RXCSUM |\n\t\t\t\t  NETIF_F_HW_CSUM |\n\t\t\t\t  NETIF_F_HW_TC;\n\tport->ndev->features = port->ndev->hw_features |\n\t\t\t       NETIF_F_HW_VLAN_CTAG_FILTER;\n\tport->ndev->vlan_features |=  NETIF_F_SG;\n\tport->ndev->netdev_ops = &am65_cpsw_nuss_netdev_ops;\n\tport->ndev->ethtool_ops = &am65_cpsw_ethtool_ops_slave;\n\n\t \n\tport->slave.phylink_config.dev = &port->ndev->dev;\n\tport->slave.phylink_config.type = PHYLINK_NETDEV;\n\tport->slave.phylink_config.mac_capabilities = MAC_SYM_PAUSE | MAC_10 | MAC_100 |\n\t\t\t\t\t\t      MAC_1000FD | MAC_5000FD;\n\tport->slave.phylink_config.mac_managed_pm = true;  \n\n\tswitch (port->slave.phy_if) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tphy_interface_set_rgmii(port->slave.phylink_config.supported_interfaces);\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\t__set_bit(PHY_INTERFACE_MODE_RMII,\n\t\t\t  port->slave.phylink_config.supported_interfaces);\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\tif (common->pdata.extra_modes & BIT(port->slave.phy_if)) {\n\t\t\t__set_bit(port->slave.phy_if,\n\t\t\t\t  port->slave.phylink_config.supported_interfaces);\n\t\t} else {\n\t\t\tdev_err(dev, \"selected phy-mode is not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"selected phy-mode is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tphylink = phylink_create(&port->slave.phylink_config,\n\t\t\t\t of_node_to_fwnode(port->slave.phy_node),\n\t\t\t\t port->slave.phy_if,\n\t\t\t\t &am65_cpsw_phylink_mac_ops);\n\tif (IS_ERR(phylink))\n\t\treturn PTR_ERR(phylink);\n\n\tport->slave.phylink = phylink;\n\n\t \n\tif (common->pdata.quirks & AM65_CPSW_QUIRK_I2027_NO_TX_CSUM)\n\t\tport->ndev->features &= ~NETIF_F_HW_CSUM;\n\n\tndev_priv->stats = netdev_alloc_pcpu_stats(struct am65_cpsw_ndev_stats);\n\tif (!ndev_priv->stats)\n\t\treturn -ENOMEM;\n\n\tret = devm_add_action_or_reset(dev, am65_cpsw_pcpu_stats_free,\n\t\t\t\t       ndev_priv->stats);\n\tif (ret)\n\t\tdev_err(dev, \"failed to add percpu stat free action %d\\n\", ret);\n\n\tif (!common->dma_ndev)\n\t\tcommon->dma_ndev = port->ndev;\n\n\treturn ret;\n}\n\nstatic int am65_cpsw_nuss_init_ndevs(struct am65_cpsw_common *common)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < common->port_num; i++) {\n\t\tret = am65_cpsw_nuss_init_port_ndev(common, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void am65_cpsw_nuss_cleanup_ndev(struct am65_cpsw_common *common)\n{\n\tstruct am65_cpsw_port *port;\n\tint i;\n\n\tfor (i = 0; i < common->port_num; i++) {\n\t\tport = &common->ports[i];\n\t\tif (port->ndev && port->ndev->reg_state == NETREG_REGISTERED)\n\t\t\tunregister_netdev(port->ndev);\n\t}\n}\n\nstatic void am65_cpsw_port_offload_fwd_mark_update(struct am65_cpsw_common *common)\n{\n\tint set_val = 0;\n\tint i;\n\n\tif (common->br_members == (GENMASK(common->port_num, 1) & ~common->disabled_ports_mask))\n\t\tset_val = 1;\n\n\tdev_dbg(common->dev, \"set offload_fwd_mark %d\\n\", set_val);\n\n\tfor (i = 1; i <= common->port_num; i++) {\n\t\tstruct am65_cpsw_port *port = am65_common_get_port(common, i);\n\t\tstruct am65_cpsw_ndev_priv *priv;\n\n\t\tif (!port->ndev)\n\t\t\tcontinue;\n\n\t\tpriv = am65_ndev_to_priv(port->ndev);\n\t\tpriv->offload_fwd_mark = set_val;\n\t}\n}\n\nbool am65_cpsw_port_dev_check(const struct net_device *ndev)\n{\n\tif (ndev->netdev_ops == &am65_cpsw_nuss_netdev_ops) {\n\t\tstruct am65_cpsw_common *common = am65_ndev_to_common(ndev);\n\n\t\treturn !common->is_emac_mode;\n\t}\n\n\treturn false;\n}\n\nstatic int am65_cpsw_netdevice_port_link(struct net_device *ndev,\n\t\t\t\t\t struct net_device *br_ndev,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct am65_cpsw_common *common = am65_ndev_to_common(ndev);\n\tstruct am65_cpsw_ndev_priv *priv = am65_ndev_to_priv(ndev);\n\tint err;\n\n\tif (!common->br_members) {\n\t\tcommon->hw_bridge_dev = br_ndev;\n\t} else {\n\t\t \n\t\tif (common->hw_bridge_dev != br_ndev)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = switchdev_bridge_port_offload(ndev, ndev, NULL, NULL, NULL,\n\t\t\t\t\t    false, extack);\n\tif (err)\n\t\treturn err;\n\n\tcommon->br_members |= BIT(priv->port->port_id);\n\n\tam65_cpsw_port_offload_fwd_mark_update(common);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void am65_cpsw_netdevice_port_unlink(struct net_device *ndev)\n{\n\tstruct am65_cpsw_common *common = am65_ndev_to_common(ndev);\n\tstruct am65_cpsw_ndev_priv *priv = am65_ndev_to_priv(ndev);\n\n\tswitchdev_bridge_port_unoffload(ndev, NULL, NULL, NULL);\n\n\tcommon->br_members &= ~BIT(priv->port->port_id);\n\n\tam65_cpsw_port_offload_fwd_mark_update(common);\n\n\tif (!common->br_members)\n\t\tcommon->hw_bridge_dev = NULL;\n}\n\n \nstatic int am65_cpsw_netdevice_event(struct notifier_block *unused,\n\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct netlink_ext_ack *extack = netdev_notifier_info_to_extack(ptr);\n\tstruct net_device *ndev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_notifier_changeupper_info *info;\n\tint ret = NOTIFY_DONE;\n\n\tif (!am65_cpsw_port_dev_check(ndev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGEUPPER:\n\t\tinfo = ptr;\n\n\t\tif (netif_is_bridge_master(info->upper_dev)) {\n\t\t\tif (info->linking)\n\t\t\t\tret = am65_cpsw_netdevice_port_link(ndev,\n\t\t\t\t\t\t\t\t    info->upper_dev,\n\t\t\t\t\t\t\t\t    extack);\n\t\t\telse\n\t\t\t\tam65_cpsw_netdevice_port_unlink(ndev);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn notifier_from_errno(ret);\n}\n\nstatic int am65_cpsw_register_notifiers(struct am65_cpsw_common *cpsw)\n{\n\tint ret = 0;\n\n\tif (AM65_CPSW_IS_CPSW2G(cpsw) ||\n\t    !IS_REACHABLE(CONFIG_TI_K3_AM65_CPSW_SWITCHDEV))\n\t\treturn 0;\n\n\tcpsw->am65_cpsw_netdevice_nb.notifier_call = &am65_cpsw_netdevice_event;\n\tret = register_netdevice_notifier(&cpsw->am65_cpsw_netdevice_nb);\n\tif (ret) {\n\t\tdev_err(cpsw->dev, \"can't register netdevice notifier\\n\");\n\t\treturn ret;\n\t}\n\n\tret = am65_cpsw_switchdev_register_notifiers(cpsw);\n\tif (ret)\n\t\tunregister_netdevice_notifier(&cpsw->am65_cpsw_netdevice_nb);\n\n\treturn ret;\n}\n\nstatic void am65_cpsw_unregister_notifiers(struct am65_cpsw_common *cpsw)\n{\n\tif (AM65_CPSW_IS_CPSW2G(cpsw) ||\n\t    !IS_REACHABLE(CONFIG_TI_K3_AM65_CPSW_SWITCHDEV))\n\t\treturn;\n\n\tam65_cpsw_switchdev_unregister_notifiers(cpsw);\n\tunregister_netdevice_notifier(&cpsw->am65_cpsw_netdevice_nb);\n}\n\nstatic const struct devlink_ops am65_cpsw_devlink_ops = {};\n\nstatic void am65_cpsw_init_stp_ale_entry(struct am65_cpsw_common *cpsw)\n{\n\tcpsw_ale_add_mcast(cpsw->ale, eth_stp_addr, ALE_PORT_HOST, ALE_SUPER, 0,\n\t\t\t   ALE_MCAST_BLOCK_LEARN_FWD);\n}\n\nstatic void am65_cpsw_init_host_port_switch(struct am65_cpsw_common *common)\n{\n\tstruct am65_cpsw_host *host = am65_common_get_host(common);\n\n\twritel(common->default_vlan, host->port_base + AM65_CPSW_PORT_VLAN_REG_OFFSET);\n\n\tam65_cpsw_init_stp_ale_entry(common);\n\n\tcpsw_ale_control_set(common->ale, HOST_PORT_NUM, ALE_P0_UNI_FLOOD, 1);\n\tdev_dbg(common->dev, \"Set P0_UNI_FLOOD\\n\");\n\tcpsw_ale_control_set(common->ale, HOST_PORT_NUM, ALE_PORT_NOLEARN, 0);\n}\n\nstatic void am65_cpsw_init_host_port_emac(struct am65_cpsw_common *common)\n{\n\tstruct am65_cpsw_host *host = am65_common_get_host(common);\n\n\twritel(0, host->port_base + AM65_CPSW_PORT_VLAN_REG_OFFSET);\n\n\tcpsw_ale_control_set(common->ale, HOST_PORT_NUM, ALE_P0_UNI_FLOOD, 0);\n\tdev_dbg(common->dev, \"unset P0_UNI_FLOOD\\n\");\n\n\t \n\tcpsw_ale_control_set(common->ale, HOST_PORT_NUM, ALE_PORT_NOLEARN, 1);\n}\n\nstatic int am65_cpsw_dl_switch_mode_get(struct devlink *dl, u32 id,\n\t\t\t\t\tstruct devlink_param_gset_ctx *ctx)\n{\n\tstruct am65_cpsw_devlink *dl_priv = devlink_priv(dl);\n\tstruct am65_cpsw_common *common = dl_priv->common;\n\n\tdev_dbg(common->dev, \"%s id:%u\\n\", __func__, id);\n\n\tif (id != AM65_CPSW_DL_PARAM_SWITCH_MODE)\n\t\treturn -EOPNOTSUPP;\n\n\tctx->val.vbool = !common->is_emac_mode;\n\n\treturn 0;\n}\n\nstatic void am65_cpsw_init_port_emac_ale(struct  am65_cpsw_port *port)\n{\n\tstruct am65_cpsw_slave_data *slave = &port->slave;\n\tstruct am65_cpsw_common *common = port->common;\n\tu32 port_mask;\n\n\twritel(slave->port_vlan, port->port_base + AM65_CPSW_PORT_VLAN_REG_OFFSET);\n\n\tif (slave->mac_only)\n\t\t \n\t\tcpsw_ale_control_set(common->ale, port->port_id,\n\t\t\t\t     ALE_PORT_MACONLY, 1);\n\n\tcpsw_ale_control_set(common->ale, port->port_id, ALE_PORT_NOLEARN, 1);\n\n\tport_mask = BIT(port->port_id) | ALE_PORT_HOST;\n\n\tcpsw_ale_add_ucast(common->ale, port->ndev->dev_addr,\n\t\t\t   HOST_PORT_NUM, ALE_SECURE, slave->port_vlan);\n\tcpsw_ale_add_mcast(common->ale, port->ndev->broadcast,\n\t\t\t   port_mask, ALE_VLAN, slave->port_vlan, ALE_MCAST_FWD_2);\n}\n\nstatic void am65_cpsw_init_port_switch_ale(struct am65_cpsw_port *port)\n{\n\tstruct am65_cpsw_slave_data *slave = &port->slave;\n\tstruct am65_cpsw_common *cpsw = port->common;\n\tu32 port_mask;\n\n\tcpsw_ale_control_set(cpsw->ale, port->port_id,\n\t\t\t     ALE_PORT_NOLEARN, 0);\n\n\tcpsw_ale_add_ucast(cpsw->ale, port->ndev->dev_addr,\n\t\t\t   HOST_PORT_NUM, ALE_SECURE | ALE_BLOCKED | ALE_VLAN,\n\t\t\t   slave->port_vlan);\n\n\tport_mask = BIT(port->port_id) | ALE_PORT_HOST;\n\n\tcpsw_ale_add_mcast(cpsw->ale, port->ndev->broadcast,\n\t\t\t   port_mask, ALE_VLAN, slave->port_vlan,\n\t\t\t   ALE_MCAST_FWD_2);\n\n\twritel(slave->port_vlan, port->port_base + AM65_CPSW_PORT_VLAN_REG_OFFSET);\n\n\tcpsw_ale_control_set(cpsw->ale, port->port_id,\n\t\t\t     ALE_PORT_MACONLY, 0);\n}\n\nstatic int am65_cpsw_dl_switch_mode_set(struct devlink *dl, u32 id,\n\t\t\t\t\tstruct devlink_param_gset_ctx *ctx)\n{\n\tstruct am65_cpsw_devlink *dl_priv = devlink_priv(dl);\n\tstruct am65_cpsw_common *cpsw = dl_priv->common;\n\tbool switch_en = ctx->val.vbool;\n\tbool if_running = false;\n\tint i;\n\n\tdev_dbg(cpsw->dev, \"%s id:%u\\n\", __func__, id);\n\n\tif (id != AM65_CPSW_DL_PARAM_SWITCH_MODE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (switch_en == !cpsw->is_emac_mode)\n\t\treturn 0;\n\n\tif (!switch_en && cpsw->br_members) {\n\t\tdev_err(cpsw->dev, \"Remove ports from bridge before disabling switch mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trtnl_lock();\n\n\tcpsw->is_emac_mode = !switch_en;\n\n\tfor (i = 0; i < cpsw->port_num; i++) {\n\t\tstruct net_device *sl_ndev = cpsw->ports[i].ndev;\n\n\t\tif (!sl_ndev || !netif_running(sl_ndev))\n\t\t\tcontinue;\n\n\t\tif_running = true;\n\t}\n\n\tif (!if_running) {\n\t\t \n\t\tfor (i = 0; i < cpsw->port_num; i++) {\n\t\t\tstruct net_device *sl_ndev = cpsw->ports[i].ndev;\n\t\t\tstruct am65_cpsw_slave_data *slave;\n\n\t\t\tif (!sl_ndev)\n\t\t\t\tcontinue;\n\n\t\t\tslave = am65_ndev_to_slave(sl_ndev);\n\t\t\tif (switch_en)\n\t\t\t\tslave->port_vlan = cpsw->default_vlan;\n\t\t\telse\n\t\t\t\tslave->port_vlan = 0;\n\t\t}\n\n\t\tgoto exit;\n\t}\n\n\tcpsw_ale_control_set(cpsw->ale, 0, ALE_BYPASS, 1);\n\t \n\tcpsw_ale_control_set(cpsw->ale, HOST_PORT_NUM, ALE_CLEAR, 1);\n\tcpsw_ale_control_get(cpsw->ale, HOST_PORT_NUM, ALE_AGEOUT);\n\n\tif (switch_en) {\n\t\tdev_info(cpsw->dev, \"Enable switch mode\\n\");\n\n\t\tam65_cpsw_init_host_port_switch(cpsw);\n\n\t\tfor (i = 0; i < cpsw->port_num; i++) {\n\t\t\tstruct net_device *sl_ndev = cpsw->ports[i].ndev;\n\t\t\tstruct am65_cpsw_slave_data *slave;\n\t\t\tstruct am65_cpsw_port *port;\n\n\t\t\tif (!sl_ndev)\n\t\t\t\tcontinue;\n\n\t\t\tport = am65_ndev_to_port(sl_ndev);\n\t\t\tslave = am65_ndev_to_slave(sl_ndev);\n\t\t\tslave->port_vlan = cpsw->default_vlan;\n\n\t\t\tif (netif_running(sl_ndev))\n\t\t\t\tam65_cpsw_init_port_switch_ale(port);\n\t\t}\n\n\t} else {\n\t\tdev_info(cpsw->dev, \"Disable switch mode\\n\");\n\n\t\tam65_cpsw_init_host_port_emac(cpsw);\n\n\t\tfor (i = 0; i < cpsw->port_num; i++) {\n\t\t\tstruct net_device *sl_ndev = cpsw->ports[i].ndev;\n\t\t\tstruct am65_cpsw_port *port;\n\n\t\t\tif (!sl_ndev)\n\t\t\t\tcontinue;\n\n\t\t\tport = am65_ndev_to_port(sl_ndev);\n\t\t\tport->slave.port_vlan = 0;\n\t\t\tif (netif_running(sl_ndev))\n\t\t\t\tam65_cpsw_init_port_emac_ale(port);\n\t\t}\n\t}\n\tcpsw_ale_control_set(cpsw->ale, HOST_PORT_NUM, ALE_BYPASS, 0);\nexit:\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic const struct devlink_param am65_cpsw_devlink_params[] = {\n\tDEVLINK_PARAM_DRIVER(AM65_CPSW_DL_PARAM_SWITCH_MODE, \"switch_mode\",\n\t\t\t     DEVLINK_PARAM_TYPE_BOOL,\n\t\t\t     BIT(DEVLINK_PARAM_CMODE_RUNTIME),\n\t\t\t     am65_cpsw_dl_switch_mode_get,\n\t\t\t     am65_cpsw_dl_switch_mode_set, NULL),\n};\n\nstatic int am65_cpsw_nuss_register_devlink(struct am65_cpsw_common *common)\n{\n\tstruct devlink_port_attrs attrs = {};\n\tstruct am65_cpsw_devlink *dl_priv;\n\tstruct device *dev = common->dev;\n\tstruct devlink_port *dl_port;\n\tstruct am65_cpsw_port *port;\n\tint ret = 0;\n\tint i;\n\n\tcommon->devlink =\n\t\tdevlink_alloc(&am65_cpsw_devlink_ops, sizeof(*dl_priv), dev);\n\tif (!common->devlink)\n\t\treturn -ENOMEM;\n\n\tdl_priv = devlink_priv(common->devlink);\n\tdl_priv->common = common;\n\n\t \n\tif (!AM65_CPSW_IS_CPSW2G(common) &&\n\t    IS_ENABLED(CONFIG_TI_K3_AM65_CPSW_SWITCHDEV)) {\n\t\tret = devlink_params_register(common->devlink,\n\t\t\t\t\t      am65_cpsw_devlink_params,\n\t\t\t\t\t      ARRAY_SIZE(am65_cpsw_devlink_params));\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"devlink params reg fail ret:%d\\n\", ret);\n\t\t\tgoto dl_unreg;\n\t\t}\n\t}\n\n\tfor (i = 1; i <= common->port_num; i++) {\n\t\tport = am65_common_get_port(common, i);\n\t\tdl_port = &port->devlink_port;\n\n\t\tif (port->ndev)\n\t\t\tattrs.flavour = DEVLINK_PORT_FLAVOUR_PHYSICAL;\n\t\telse\n\t\t\tattrs.flavour = DEVLINK_PORT_FLAVOUR_UNUSED;\n\t\tattrs.phys.port_number = port->port_id;\n\t\tattrs.switch_id.id_len = sizeof(resource_size_t);\n\t\tmemcpy(attrs.switch_id.id, common->switch_id, attrs.switch_id.id_len);\n\t\tdevlink_port_attrs_set(dl_port, &attrs);\n\n\t\tret = devlink_port_register(common->devlink, dl_port, port->port_id);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"devlink_port reg fail for port %d, ret:%d\\n\",\n\t\t\t\tport->port_id, ret);\n\t\t\tgoto dl_port_unreg;\n\t\t}\n\t}\n\tdevlink_register(common->devlink);\n\treturn ret;\n\ndl_port_unreg:\n\tfor (i = i - 1; i >= 1; i--) {\n\t\tport = am65_common_get_port(common, i);\n\t\tdl_port = &port->devlink_port;\n\n\t\tdevlink_port_unregister(dl_port);\n\t}\ndl_unreg:\n\tdevlink_free(common->devlink);\n\treturn ret;\n}\n\nstatic void am65_cpsw_unregister_devlink(struct am65_cpsw_common *common)\n{\n\tstruct devlink_port *dl_port;\n\tstruct am65_cpsw_port *port;\n\tint i;\n\n\tdevlink_unregister(common->devlink);\n\n\tfor (i = 1; i <= common->port_num; i++) {\n\t\tport = am65_common_get_port(common, i);\n\t\tdl_port = &port->devlink_port;\n\n\t\tdevlink_port_unregister(dl_port);\n\t}\n\n\tif (!AM65_CPSW_IS_CPSW2G(common) &&\n\t    IS_ENABLED(CONFIG_TI_K3_AM65_CPSW_SWITCHDEV))\n\t\tdevlink_params_unregister(common->devlink,\n\t\t\t\t\t  am65_cpsw_devlink_params,\n\t\t\t\t\t  ARRAY_SIZE(am65_cpsw_devlink_params));\n\n\tdevlink_free(common->devlink);\n}\n\nstatic int am65_cpsw_nuss_register_ndevs(struct am65_cpsw_common *common)\n{\n\tstruct device *dev = common->dev;\n\tstruct am65_cpsw_port *port;\n\tint ret = 0, i;\n\n\t \n\tret = am65_cpsw_nuss_init_tx_chns(common);\n\tif (ret)\n\t\treturn ret;\n\tret = am65_cpsw_nuss_init_rx_chns(common);\n\tif (ret)\n\t\treturn ret;\n\n\tret = am65_cpsw_nuss_register_devlink(common);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < common->port_num; i++) {\n\t\tport = &common->ports[i];\n\n\t\tif (!port->ndev)\n\t\t\tcontinue;\n\n\t\tSET_NETDEV_DEVLINK_PORT(port->ndev, &port->devlink_port);\n\n\t\tret = register_netdev(port->ndev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"error registering slave net device%i %d\\n\",\n\t\t\t\ti, ret);\n\t\t\tgoto err_cleanup_ndev;\n\t\t}\n\t}\n\n\tret = am65_cpsw_register_notifiers(common);\n\tif (ret)\n\t\tgoto err_cleanup_ndev;\n\n\t \n\n\treturn 0;\n\nerr_cleanup_ndev:\n\tam65_cpsw_nuss_cleanup_ndev(common);\n\tam65_cpsw_unregister_devlink(common);\n\n\treturn ret;\n}\n\nint am65_cpsw_nuss_update_tx_chns(struct am65_cpsw_common *common, int num_tx)\n{\n\tint ret;\n\n\tcommon->tx_ch_num = num_tx;\n\tret = am65_cpsw_nuss_init_tx_chns(common);\n\n\treturn ret;\n}\n\nstruct am65_cpsw_soc_pdata {\n\tu32\tquirks_dis;\n};\n\nstatic const struct am65_cpsw_soc_pdata am65x_soc_sr2_0 = {\n\t.quirks_dis = AM65_CPSW_QUIRK_I2027_NO_TX_CSUM,\n};\n\nstatic const struct soc_device_attribute am65_cpsw_socinfo[] = {\n\t{ .family = \"AM65X\",\n\t  .revision = \"SR2.0\",\n\t  .data = &am65x_soc_sr2_0\n\t},\n\t{ }\n};\n\nstatic const struct am65_cpsw_pdata am65x_sr1_0 = {\n\t.quirks = AM65_CPSW_QUIRK_I2027_NO_TX_CSUM,\n\t.ale_dev_id = \"am65x-cpsw2g\",\n\t.fdqring_mode = K3_RINGACC_RING_MODE_MESSAGE,\n};\n\nstatic const struct am65_cpsw_pdata j721e_pdata = {\n\t.quirks = 0,\n\t.ale_dev_id = \"am65x-cpsw2g\",\n\t.fdqring_mode = K3_RINGACC_RING_MODE_MESSAGE,\n};\n\nstatic const struct am65_cpsw_pdata am64x_cpswxg_pdata = {\n\t.quirks = AM64_CPSW_QUIRK_DMA_RX_TDOWN_IRQ,\n\t.ale_dev_id = \"am64-cpswxg\",\n\t.fdqring_mode = K3_RINGACC_RING_MODE_RING,\n};\n\nstatic const struct am65_cpsw_pdata j7200_cpswxg_pdata = {\n\t.quirks = 0,\n\t.ale_dev_id = \"am64-cpswxg\",\n\t.fdqring_mode = K3_RINGACC_RING_MODE_RING,\n\t.extra_modes = BIT(PHY_INTERFACE_MODE_QSGMII) | BIT(PHY_INTERFACE_MODE_SGMII),\n};\n\nstatic const struct am65_cpsw_pdata j721e_cpswxg_pdata = {\n\t.quirks = 0,\n\t.ale_dev_id = \"am64-cpswxg\",\n\t.fdqring_mode = K3_RINGACC_RING_MODE_MESSAGE,\n\t.extra_modes = BIT(PHY_INTERFACE_MODE_QSGMII) | BIT(PHY_INTERFACE_MODE_SGMII),\n};\n\nstatic const struct am65_cpsw_pdata j784s4_cpswxg_pdata = {\n\t.quirks = 0,\n\t.ale_dev_id = \"am64-cpswxg\",\n\t.fdqring_mode = K3_RINGACC_RING_MODE_MESSAGE,\n\t.extra_modes = BIT(PHY_INTERFACE_MODE_QSGMII) | BIT(PHY_INTERFACE_MODE_USXGMII),\n};\n\nstatic const struct of_device_id am65_cpsw_nuss_of_mtable[] = {\n\t{ .compatible = \"ti,am654-cpsw-nuss\", .data = &am65x_sr1_0},\n\t{ .compatible = \"ti,j721e-cpsw-nuss\", .data = &j721e_pdata},\n\t{ .compatible = \"ti,am642-cpsw-nuss\", .data = &am64x_cpswxg_pdata},\n\t{ .compatible = \"ti,j7200-cpswxg-nuss\", .data = &j7200_cpswxg_pdata},\n\t{ .compatible = \"ti,j721e-cpswxg-nuss\", .data = &j721e_cpswxg_pdata},\n\t{ .compatible = \"ti,j784s4-cpswxg-nuss\", .data = &j784s4_cpswxg_pdata},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, am65_cpsw_nuss_of_mtable);\n\nstatic void am65_cpsw_nuss_apply_socinfo(struct am65_cpsw_common *common)\n{\n\tconst struct soc_device_attribute *soc;\n\n\tsoc = soc_device_match(am65_cpsw_socinfo);\n\tif (soc && soc->data) {\n\t\tconst struct am65_cpsw_soc_pdata *socdata = soc->data;\n\n\t\t \n\t\tcommon->pdata.quirks &= ~socdata->quirks_dis;\n\t}\n}\n\nstatic int am65_cpsw_nuss_probe(struct platform_device *pdev)\n{\n\tstruct cpsw_ale_params ale_params = { 0 };\n\tconst struct of_device_id *of_id;\n\tstruct device *dev = &pdev->dev;\n\tstruct am65_cpsw_common *common;\n\tstruct device_node *node;\n\tstruct resource *res;\n\tstruct clk *clk;\n\tu64 id_temp;\n\tint ret, i;\n\tint ale_entries;\n\n\tcommon = devm_kzalloc(dev, sizeof(struct am65_cpsw_common), GFP_KERNEL);\n\tif (!common)\n\t\treturn -ENOMEM;\n\tcommon->dev = dev;\n\n\tof_id = of_match_device(am65_cpsw_nuss_of_mtable, dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\tcommon->pdata = *(const struct am65_cpsw_pdata *)of_id->data;\n\n\tam65_cpsw_nuss_apply_socinfo(common);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"cpsw_nuss\");\n\tcommon->ss_base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(common->ss_base))\n\t\treturn PTR_ERR(common->ss_base);\n\tcommon->cpsw_base = common->ss_base + AM65_CPSW_CPSW_NU_BASE;\n\t \n\tid_temp = cpu_to_be64(res->start);\n\tmemcpy(common->switch_id, &id_temp, sizeof(res->start));\n\n\tnode = of_get_child_by_name(dev->of_node, \"ethernet-ports\");\n\tif (!node)\n\t\treturn -ENOENT;\n\tcommon->port_num = of_get_child_count(node);\n\tof_node_put(node);\n\tif (common->port_num < 1 || common->port_num > AM65_CPSW_MAX_PORTS)\n\t\treturn -ENOENT;\n\n\tcommon->rx_flow_id_base = -1;\n\tinit_completion(&common->tdown_complete);\n\tcommon->tx_ch_num = 1;\n\tcommon->pf_p0_rx_ptype_rrobin = false;\n\tcommon->default_vlan = 1;\n\n\tcommon->ports = devm_kcalloc(dev, common->port_num,\n\t\t\t\t     sizeof(*common->ports),\n\t\t\t\t     GFP_KERNEL);\n\tif (!common->ports)\n\t\treturn -ENOMEM;\n\n\tclk = devm_clk_get(dev, \"fck\");\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(clk), \"getting fck clock\\n\");\n\tcommon->bus_freq = clk_get_rate(clk);\n\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tpm_runtime_disable(dev);\n\t\treturn ret;\n\t}\n\n\tnode = of_get_child_by_name(dev->of_node, \"mdio\");\n\tif (!node) {\n\t\tdev_warn(dev, \"MDIO node not found\\n\");\n\t} else if (of_device_is_available(node)) {\n\t\tstruct platform_device *mdio_pdev;\n\n\t\tmdio_pdev = of_platform_device_create(node, NULL, dev);\n\t\tif (!mdio_pdev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_pm_clear;\n\t\t}\n\n\t\tcommon->mdio_dev =  &mdio_pdev->dev;\n\t}\n\tof_node_put(node);\n\n\tam65_cpsw_nuss_get_ver(common);\n\n\tret = am65_cpsw_nuss_init_host_p(common);\n\tif (ret)\n\t\tgoto err_of_clear;\n\n\tret = am65_cpsw_nuss_init_slave_ports(common);\n\tif (ret)\n\t\tgoto err_of_clear;\n\n\t \n\tale_params.dev = dev;\n\tale_params.ale_ageout = AM65_CPSW_ALE_AGEOUT_DEFAULT;\n\tale_params.ale_ports = common->port_num + 1;\n\tale_params.ale_regs = common->cpsw_base + AM65_CPSW_NU_ALE_BASE;\n\tale_params.dev_id = common->pdata.ale_dev_id;\n\tale_params.bus_freq = common->bus_freq;\n\n\tcommon->ale = cpsw_ale_create(&ale_params);\n\tif (IS_ERR(common->ale)) {\n\t\tdev_err(dev, \"error initializing ale engine\\n\");\n\t\tret = PTR_ERR(common->ale);\n\t\tgoto err_of_clear;\n\t}\n\n\tale_entries = common->ale->params.ale_entries;\n\tcommon->ale_context = devm_kzalloc(dev,\n\t\t\t\t\t   ale_entries * ALE_ENTRY_WORDS * sizeof(u32),\n\t\t\t\t\t   GFP_KERNEL);\n\tret = am65_cpsw_init_cpts(common);\n\tif (ret)\n\t\tgoto err_of_clear;\n\n\t \n\tfor (i = 0; i < common->port_num; i++)\n\t\tam65_cpsw_nuss_slave_disable_unused(&common->ports[i]);\n\n\tdev_set_drvdata(dev, common);\n\n\tcommon->is_emac_mode = true;\n\n\tret = am65_cpsw_nuss_init_ndevs(common);\n\tif (ret)\n\t\tgoto err_free_phylink;\n\n\tret = am65_cpsw_nuss_register_ndevs(common);\n\tif (ret)\n\t\tgoto err_free_phylink;\n\n\tpm_runtime_put(dev);\n\treturn 0;\n\nerr_free_phylink:\n\tam65_cpsw_nuss_phylink_cleanup(common);\n\tam65_cpts_release(common->cpts);\nerr_of_clear:\n\tif (common->mdio_dev)\n\t\tof_platform_device_destroy(common->mdio_dev, NULL);\nerr_pm_clear:\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic int am65_cpsw_nuss_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct am65_cpsw_common *common;\n\tint ret;\n\n\tcommon = dev_get_drvdata(dev);\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tam65_cpsw_unregister_devlink(common);\n\tam65_cpsw_unregister_notifiers(common);\n\n\t \n\tam65_cpsw_nuss_cleanup_ndev(common);\n\tam65_cpsw_nuss_phylink_cleanup(common);\n\tam65_cpts_release(common->cpts);\n\tam65_cpsw_disable_serdes_phy(common);\n\n\tif (common->mdio_dev)\n\t\tof_platform_device_destroy(common->mdio_dev, NULL);\n\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\treturn 0;\n}\n\nstatic int am65_cpsw_nuss_suspend(struct device *dev)\n{\n\tstruct am65_cpsw_common *common = dev_get_drvdata(dev);\n\tstruct am65_cpsw_host *host_p = am65_common_get_host(common);\n\tstruct am65_cpsw_port *port;\n\tstruct net_device *ndev;\n\tint i, ret;\n\n\tcpsw_ale_dump(common->ale, common->ale_context);\n\thost_p->vid_context = readl(host_p->port_base + AM65_CPSW_PORT_VLAN_REG_OFFSET);\n\tfor (i = 0; i < common->port_num; i++) {\n\t\tport = &common->ports[i];\n\t\tndev = port->ndev;\n\n\t\tif (!ndev)\n\t\t\tcontinue;\n\n\t\tport->vid_context = readl(port->port_base + AM65_CPSW_PORT_VLAN_REG_OFFSET);\n\t\tnetif_device_detach(ndev);\n\t\tif (netif_running(ndev)) {\n\t\t\trtnl_lock();\n\t\t\tret = am65_cpsw_nuss_ndo_slave_stop(ndev);\n\t\t\trtnl_unlock();\n\t\t\tif (ret < 0) {\n\t\t\t\tnetdev_err(ndev, \"failed to stop: %d\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tam65_cpts_suspend(common->cpts);\n\n\tam65_cpsw_nuss_remove_rx_chns(common);\n\tam65_cpsw_nuss_remove_tx_chns(common);\n\n\treturn 0;\n}\n\nstatic int am65_cpsw_nuss_resume(struct device *dev)\n{\n\tstruct am65_cpsw_common *common = dev_get_drvdata(dev);\n\tstruct am65_cpsw_port *port;\n\tstruct net_device *ndev;\n\tint i, ret;\n\tstruct am65_cpsw_host *host_p = am65_common_get_host(common);\n\n\tret = am65_cpsw_nuss_init_tx_chns(common);\n\tif (ret)\n\t\treturn ret;\n\tret = am65_cpsw_nuss_init_rx_chns(common);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (common->rx_irq_disabled)\n\t\tdisable_irq(common->rx_chns.irq);\n\n\tam65_cpts_resume(common->cpts);\n\n\tfor (i = 0; i < common->port_num; i++) {\n\t\tport = &common->ports[i];\n\t\tndev = port->ndev;\n\n\t\tif (!ndev)\n\t\t\tcontinue;\n\n\t\tif (netif_running(ndev)) {\n\t\t\trtnl_lock();\n\t\t\tret = am65_cpsw_nuss_ndo_slave_open(ndev);\n\t\t\trtnl_unlock();\n\t\t\tif (ret < 0) {\n\t\t\t\tnetdev_err(ndev, \"failed to start: %d\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tnetif_device_attach(ndev);\n\t\twritel(port->vid_context, port->port_base + AM65_CPSW_PORT_VLAN_REG_OFFSET);\n\t}\n\n\twritel(host_p->vid_context, host_p->port_base + AM65_CPSW_PORT_VLAN_REG_OFFSET);\n\tcpsw_ale_restore(common->ale, common->ale_context);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops am65_cpsw_nuss_dev_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(am65_cpsw_nuss_suspend, am65_cpsw_nuss_resume)\n};\n\nstatic struct platform_driver am65_cpsw_nuss_driver = {\n\t.driver = {\n\t\t.name\t = AM65_CPSW_DRV_NAME,\n\t\t.of_match_table = am65_cpsw_nuss_of_mtable,\n\t\t.pm = &am65_cpsw_nuss_dev_pm_ops,\n\t},\n\t.probe = am65_cpsw_nuss_probe,\n\t.remove = am65_cpsw_nuss_remove,\n};\n\nmodule_platform_driver(am65_cpsw_nuss_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Grygorii Strashko <grygorii.strashko@ti.com>\");\nMODULE_DESCRIPTION(\"TI AM65 CPSW Ethernet driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}