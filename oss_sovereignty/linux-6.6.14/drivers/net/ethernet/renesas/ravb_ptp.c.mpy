{
  "module_name": "ravb_ptp.c",
  "hash_id": "81404d3ac5dc9eeeaca992fb440110fb9b6f1f711329dce13396ec176da2ce1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/renesas/ravb_ptp.c",
  "human_readable_source": "\n \n\n#include \"ravb.h\"\n\nstatic int ravb_ptp_tcr_request(struct ravb_private *priv, u32 request)\n{\n\tstruct net_device *ndev = priv->ndev;\n\tint error;\n\n\terror = ravb_wait(ndev, GCCR, GCCR_TCR, GCCR_TCR_NOREQ);\n\tif (error)\n\t\treturn error;\n\n\travb_modify(ndev, GCCR, request, request);\n\treturn ravb_wait(ndev, GCCR, GCCR_TCR, GCCR_TCR_NOREQ);\n}\n\n \nstatic int ravb_ptp_time_read(struct ravb_private *priv, struct timespec64 *ts)\n{\n\tstruct net_device *ndev = priv->ndev;\n\tint error;\n\n\terror = ravb_ptp_tcr_request(priv, GCCR_TCR_CAPTURE);\n\tif (error)\n\t\treturn error;\n\n\tts->tv_nsec = ravb_read(ndev, GCT0);\n\tts->tv_sec  = ravb_read(ndev, GCT1) |\n\t\t((s64)ravb_read(ndev, GCT2) << 32);\n\n\treturn 0;\n}\n\n \nstatic int ravb_ptp_time_write(struct ravb_private *priv,\n\t\t\t\tconst struct timespec64 *ts)\n{\n\tstruct net_device *ndev = priv->ndev;\n\tint error;\n\tu32 gccr;\n\n\terror = ravb_ptp_tcr_request(priv, GCCR_TCR_RESET);\n\tif (error)\n\t\treturn error;\n\n\tgccr = ravb_read(ndev, GCCR);\n\tif (gccr & GCCR_LTO)\n\t\treturn -EBUSY;\n\travb_write(ndev, ts->tv_nsec, GTO0);\n\travb_write(ndev, ts->tv_sec,  GTO1);\n\travb_write(ndev, (ts->tv_sec >> 32) & 0xffff, GTO2);\n\travb_write(ndev, gccr | GCCR_LTO, GCCR);\n\n\treturn 0;\n}\n\n \nstatic int ravb_ptp_update_compare(struct ravb_private *priv, u32 ns)\n{\n\tstruct net_device *ndev = priv->ndev;\n\t \n\tu32 gti_ns_plus_1 = (priv->ptp.current_addend >> 20) + 1;\n\tu32 gccr;\n\n\tif (ns < gti_ns_plus_1)\n\t\tns = gti_ns_plus_1;\n\telse if (ns > 0 - gti_ns_plus_1)\n\t\tns = 0 - gti_ns_plus_1;\n\n\tgccr = ravb_read(ndev, GCCR);\n\tif (gccr & GCCR_LPTC)\n\t\treturn -EBUSY;\n\travb_write(ndev, ns, GPTC);\n\travb_write(ndev, gccr | GCCR_LPTC, GCCR);\n\n\treturn 0;\n}\n\n \nstatic int ravb_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct ravb_private *priv = container_of(ptp, struct ravb_private,\n\t\t\t\t\t\t ptp.info);\n\tstruct net_device *ndev = priv->ndev;\n\tunsigned long flags;\n\tu32 addend;\n\tu32 gccr;\n\n\taddend = (u32)adjust_by_scaled_ppm(priv->ptp.default_addend,\n\t\t\t\t\t   scaled_ppm);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tpriv->ptp.current_addend = addend;\n\n\tgccr = ravb_read(ndev, GCCR);\n\tif (gccr & GCCR_LTI) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\travb_write(ndev, addend & GTI_TIV, GTI);\n\travb_write(ndev, gccr | GCCR_LTI, GCCR);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ravb_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct ravb_private *priv = container_of(ptp, struct ravb_private,\n\t\t\t\t\t\t ptp.info);\n\tstruct timespec64 ts;\n\tunsigned long flags;\n\tint error;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\terror = ravb_ptp_time_read(priv, &ts);\n\tif (!error) {\n\t\tu64 now = ktime_to_ns(timespec64_to_ktime(ts));\n\n\t\tts = ns_to_timespec64(now + delta);\n\t\terror = ravb_ptp_time_write(priv, &ts);\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn error;\n}\n\nstatic int ravb_ptp_gettime64(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tstruct ravb_private *priv = container_of(ptp, struct ravb_private,\n\t\t\t\t\t\t ptp.info);\n\tunsigned long flags;\n\tint error;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\terror = ravb_ptp_time_read(priv, ts);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn error;\n}\n\nstatic int ravb_ptp_settime64(struct ptp_clock_info *ptp,\n\t\t\t      const struct timespec64 *ts)\n{\n\tstruct ravb_private *priv = container_of(ptp, struct ravb_private,\n\t\t\t\t\t\t ptp.info);\n\tunsigned long flags;\n\tint error;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\terror = ravb_ptp_time_write(priv, ts);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn error;\n}\n\nstatic int ravb_ptp_extts(struct ptp_clock_info *ptp,\n\t\t\t  struct ptp_extts_request *req, int on)\n{\n\tstruct ravb_private *priv = container_of(ptp, struct ravb_private,\n\t\t\t\t\t\t ptp.info);\n\tconst struct ravb_hw_info *info = priv->info;\n\tstruct net_device *ndev = priv->ndev;\n\tunsigned long flags;\n\n\t \n\tif (req->flags & ~(PTP_ENABLE_FEATURE |\n\t\t\t   PTP_RISING_EDGE |\n\t\t\t   PTP_FALLING_EDGE |\n\t\t\t   PTP_STRICT_FLAGS))\n\t\treturn -EOPNOTSUPP;\n\n\tif (req->index)\n\t\treturn -EINVAL;\n\n\tif (priv->ptp.extts[req->index] == on)\n\t\treturn 0;\n\tpriv->ptp.extts[req->index] = on;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (!info->irq_en_dis)\n\t\travb_modify(ndev, GIC, GIC_PTCE, on ? GIC_PTCE : 0);\n\telse if (on)\n\t\travb_write(ndev, GIE_PTCS, GIE);\n\telse\n\t\travb_write(ndev, GID_PTCD, GID);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ravb_ptp_perout(struct ptp_clock_info *ptp,\n\t\t\t   struct ptp_perout_request *req, int on)\n{\n\tstruct ravb_private *priv = container_of(ptp, struct ravb_private,\n\t\t\t\t\t\t ptp.info);\n\tconst struct ravb_hw_info *info = priv->info;\n\tstruct net_device *ndev = priv->ndev;\n\tstruct ravb_ptp_perout *perout;\n\tunsigned long flags;\n\tint error = 0;\n\n\t \n\tif (req->flags)\n\t\treturn -EOPNOTSUPP;\n\n\tif (req->index)\n\t\treturn -EINVAL;\n\n\tif (on) {\n\t\tu64 start_ns;\n\t\tu64 period_ns;\n\n\t\tstart_ns = req->start.sec * NSEC_PER_SEC + req->start.nsec;\n\t\tperiod_ns = req->period.sec * NSEC_PER_SEC + req->period.nsec;\n\n\t\tif (start_ns > U32_MAX) {\n\t\t\tnetdev_warn(ndev,\n\t\t\t\t    \"ptp: start value (nsec) is over limit. Maximum size of start is only 32 bits\\n\");\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tif (period_ns > U32_MAX) {\n\t\t\tnetdev_warn(ndev,\n\t\t\t\t    \"ptp: period value (nsec) is over limit. Maximum size of period is only 32 bits\\n\");\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\n\t\tperout = &priv->ptp.perout[req->index];\n\t\tperout->target = (u32)start_ns;\n\t\tperout->period = (u32)period_ns;\n\t\terror = ravb_ptp_update_compare(priv, (u32)start_ns);\n\t\tif (!error) {\n\t\t\t \n\t\t\tif (!info->irq_en_dis)\n\t\t\t\travb_modify(ndev, GIC, GIC_PTME, GIC_PTME);\n\t\t\telse\n\t\t\t\travb_write(ndev, GIE_PTMS0, GIE);\n\t\t}\n\t} else\t{\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\n\t\tperout = &priv->ptp.perout[req->index];\n\t\tperout->period = 0;\n\n\t\t \n\t\tif (!info->irq_en_dis)\n\t\t\travb_modify(ndev, GIC, GIC_PTME, 0);\n\t\telse\n\t\t\travb_write(ndev, GID_PTMD0, GID);\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn error;\n}\n\nstatic int ravb_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t   struct ptp_clock_request *req, int on)\n{\n\tswitch (req->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\treturn ravb_ptp_extts(ptp, &req->extts, on);\n\tcase PTP_CLK_REQ_PEROUT:\n\t\treturn ravb_ptp_perout(ptp, &req->perout, on);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct ptp_clock_info ravb_ptp_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ravb clock\",\n\t.max_adj\t= 50000000,\n\t.n_ext_ts\t= N_EXT_TS,\n\t.n_per_out\t= N_PER_OUT,\n\t.adjfine\t= ravb_ptp_adjfine,\n\t.adjtime\t= ravb_ptp_adjtime,\n\t.gettime64\t= ravb_ptp_gettime64,\n\t.settime64\t= ravb_ptp_settime64,\n\t.enable\t\t= ravb_ptp_enable,\n};\n\n \nvoid ravb_ptp_interrupt(struct net_device *ndev)\n{\n\tstruct ravb_private *priv = netdev_priv(ndev);\n\tu32 gis = ravb_read(ndev, GIS);\n\n\tgis &= ravb_read(ndev, GIC);\n\tif (gis & GIS_PTCF) {\n\t\tstruct ptp_clock_event event;\n\n\t\tevent.type = PTP_CLOCK_EXTTS;\n\t\tevent.index = 0;\n\t\tevent.timestamp = ravb_read(ndev, GCPT);\n\t\tptp_clock_event(priv->ptp.clock, &event);\n\t}\n\tif (gis & GIS_PTMF) {\n\t\tstruct ravb_ptp_perout *perout = priv->ptp.perout;\n\n\t\tif (perout->period) {\n\t\t\tperout->target += perout->period;\n\t\t\travb_ptp_update_compare(priv, perout->target);\n\t\t}\n\t}\n\n\travb_write(ndev, ~(gis | GIS_RESERVED), GIS);\n}\n\nvoid ravb_ptp_init(struct net_device *ndev, struct platform_device *pdev)\n{\n\tstruct ravb_private *priv = netdev_priv(ndev);\n\tunsigned long flags;\n\n\tpriv->ptp.info = ravb_ptp_info;\n\n\tpriv->ptp.default_addend = ravb_read(ndev, GTI);\n\tpriv->ptp.current_addend = priv->ptp.default_addend;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\travb_wait(ndev, GCCR, GCCR_TCR, GCCR_TCR_NOREQ);\n\travb_modify(ndev, GCCR, GCCR_TCSS, GCCR_TCSS_ADJGPTP);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tpriv->ptp.clock = ptp_clock_register(&priv->ptp.info, &pdev->dev);\n}\n\nvoid ravb_ptp_stop(struct net_device *ndev)\n{\n\tstruct ravb_private *priv = netdev_priv(ndev);\n\n\travb_write(ndev, 0, GIC);\n\travb_write(ndev, 0, GIS);\n\n\tptp_clock_unregister(priv->ptp.clock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}