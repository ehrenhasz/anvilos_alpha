{
  "module_name": "rcar_gen4_ptp.c",
  "hash_id": "b3424b332bf91d65239872747d09ab26f2da150f24bff21655106094c414a3cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/renesas/rcar_gen4_ptp.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/etherdevice.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"rcar_gen4_ptp.h\"\n#define ptp_to_priv(ptp)\tcontainer_of(ptp, struct rcar_gen4_ptp_private, info)\n\nstatic const struct rcar_gen4_ptp_reg_offset s4_offs = {\n\t.enable = PTPTMEC,\n\t.disable = PTPTMDC,\n\t.increment = PTPTIVC0,\n\t.config_t0 = PTPTOVC00,\n\t.config_t1 = PTPTOVC10,\n\t.config_t2 = PTPTOVC20,\n\t.monitor_t0 = PTPGPTPTM00,\n\t.monitor_t1 = PTPGPTPTM10,\n\t.monitor_t2 = PTPGPTPTM20,\n};\n\nstatic int rcar_gen4_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct rcar_gen4_ptp_private *ptp_priv = ptp_to_priv(ptp);\n\tbool neg_adj = scaled_ppm < 0 ? true : false;\n\ts64 addend = ptp_priv->default_addend;\n\ts64 diff;\n\n\tif (neg_adj)\n\t\tscaled_ppm = -scaled_ppm;\n\tdiff = div_s64(addend * scaled_ppm_to_ppb(scaled_ppm), NSEC_PER_SEC);\n\taddend = neg_adj ? addend - diff : addend + diff;\n\n\tiowrite32(addend, ptp_priv->addr + ptp_priv->offs->increment);\n\n\treturn 0;\n}\n\n \nstatic void _rcar_gen4_ptp_gettime(struct ptp_clock_info *ptp,\n\t\t\t\t   struct timespec64 *ts)\n{\n\tstruct rcar_gen4_ptp_private *ptp_priv = ptp_to_priv(ptp);\n\n\tts->tv_nsec = ioread32(ptp_priv->addr + ptp_priv->offs->monitor_t0);\n\tts->tv_sec = ioread32(ptp_priv->addr + ptp_priv->offs->monitor_t1) |\n\t\t     ((s64)ioread32(ptp_priv->addr + ptp_priv->offs->monitor_t2) << 32);\n}\n\nstatic int rcar_gen4_ptp_gettime(struct ptp_clock_info *ptp,\n\t\t\t\t struct timespec64 *ts)\n{\n\tstruct rcar_gen4_ptp_private *ptp_priv = ptp_to_priv(ptp);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ptp_priv->lock, flags);\n\t_rcar_gen4_ptp_gettime(ptp, ts);\n\tspin_unlock_irqrestore(&ptp_priv->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void _rcar_gen4_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t\t   const struct timespec64 *ts)\n{\n\tstruct rcar_gen4_ptp_private *ptp_priv = ptp_to_priv(ptp);\n\n\tiowrite32(1, ptp_priv->addr + ptp_priv->offs->disable);\n\tiowrite32(0, ptp_priv->addr + ptp_priv->offs->config_t2);\n\tiowrite32(0, ptp_priv->addr + ptp_priv->offs->config_t1);\n\tiowrite32(0, ptp_priv->addr + ptp_priv->offs->config_t0);\n\tiowrite32(1, ptp_priv->addr + ptp_priv->offs->enable);\n\tiowrite32(ts->tv_sec >> 32, ptp_priv->addr + ptp_priv->offs->config_t2);\n\tiowrite32(ts->tv_sec, ptp_priv->addr + ptp_priv->offs->config_t1);\n\tiowrite32(ts->tv_nsec, ptp_priv->addr + ptp_priv->offs->config_t0);\n}\n\nstatic int rcar_gen4_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t\t const struct timespec64 *ts)\n{\n\tstruct rcar_gen4_ptp_private *ptp_priv = ptp_to_priv(ptp);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ptp_priv->lock, flags);\n\t_rcar_gen4_ptp_settime(ptp, ts);\n\tspin_unlock_irqrestore(&ptp_priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int rcar_gen4_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct rcar_gen4_ptp_private *ptp_priv = ptp_to_priv(ptp);\n\tstruct timespec64 ts;\n\tunsigned long flags;\n\ts64 now;\n\n\tspin_lock_irqsave(&ptp_priv->lock, flags);\n\t_rcar_gen4_ptp_gettime(ptp, &ts);\n\tnow = ktime_to_ns(timespec64_to_ktime(ts));\n\tts = ns_to_timespec64(now + delta);\n\t_rcar_gen4_ptp_settime(ptp, &ts);\n\tspin_unlock_irqrestore(&ptp_priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic int rcar_gen4_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t\tstruct ptp_clock_request *rq, int on)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic struct ptp_clock_info rcar_gen4_ptp_info = {\n\t.owner = THIS_MODULE,\n\t.name = \"rcar_gen4_ptp\",\n\t.max_adj = 50000000,\n\t.adjfine = rcar_gen4_ptp_adjfine,\n\t.adjtime = rcar_gen4_ptp_adjtime,\n\t.gettime64 = rcar_gen4_ptp_gettime,\n\t.settime64 = rcar_gen4_ptp_settime,\n\t.enable = rcar_gen4_ptp_enable,\n};\n\nstatic void rcar_gen4_ptp_set_offs(struct rcar_gen4_ptp_private *ptp_priv,\n\t\t\t\t   enum rcar_gen4_ptp_reg_layout layout)\n{\n\tWARN_ON(layout != RCAR_GEN4_PTP_REG_LAYOUT_S4);\n\n\tptp_priv->offs = &s4_offs;\n}\n\nint rcar_gen4_ptp_register(struct rcar_gen4_ptp_private *ptp_priv,\n\t\t\t   enum rcar_gen4_ptp_reg_layout layout, u32 clock)\n{\n\tif (ptp_priv->initialized)\n\t\treturn 0;\n\n\tspin_lock_init(&ptp_priv->lock);\n\n\trcar_gen4_ptp_set_offs(ptp_priv, layout);\n\n\tptp_priv->default_addend = clock;\n\tiowrite32(ptp_priv->default_addend, ptp_priv->addr + ptp_priv->offs->increment);\n\tptp_priv->clock = ptp_clock_register(&ptp_priv->info, NULL);\n\tif (IS_ERR(ptp_priv->clock))\n\t\treturn PTR_ERR(ptp_priv->clock);\n\n\tiowrite32(0x01, ptp_priv->addr + ptp_priv->offs->enable);\n\tptp_priv->initialized = true;\n\n\treturn 0;\n}\n\nint rcar_gen4_ptp_unregister(struct rcar_gen4_ptp_private *ptp_priv)\n{\n\tiowrite32(1, ptp_priv->addr + ptp_priv->offs->disable);\n\n\treturn ptp_clock_unregister(ptp_priv->clock);\n}\n\nstruct rcar_gen4_ptp_private *rcar_gen4_ptp_alloc(struct platform_device *pdev)\n{\n\tstruct rcar_gen4_ptp_private *ptp;\n\n\tptp = devm_kzalloc(&pdev->dev, sizeof(*ptp), GFP_KERNEL);\n\tif (!ptp)\n\t\treturn NULL;\n\n\tptp->info = rcar_gen4_ptp_info;\n\n\treturn ptp;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}