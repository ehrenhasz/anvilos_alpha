{
  "module_name": "rswitch.c",
  "hash_id": "a2673ae0607d94a9da2bf7b4fd6cda4c0c9233edd3ff2b50b7c253c6b911d2cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/renesas/rswitch.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/etherdevice.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/net_tstamp.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/sys_soc.h>\n\n#include \"rswitch.h\"\n\nstatic int rswitch_reg_wait(void __iomem *addr, u32 offs, u32 mask, u32 expected)\n{\n\tu32 val;\n\n\treturn readl_poll_timeout_atomic(addr + offs, val, (val & mask) == expected,\n\t\t\t\t\t 1, RSWITCH_TIMEOUT_US);\n}\n\nstatic void rswitch_modify(void __iomem *addr, enum rswitch_reg reg, u32 clear, u32 set)\n{\n\tiowrite32((ioread32(addr + reg) & ~clear) | set, addr + reg);\n}\n\n \nstatic void rswitch_reset(struct rswitch_private *priv)\n{\n\tiowrite32(RRC_RR, priv->addr + RRC);\n\tiowrite32(RRC_RR_CLR, priv->addr + RRC);\n}\n\nstatic void rswitch_clock_enable(struct rswitch_private *priv)\n{\n\tiowrite32(RCEC_ACE_DEFAULT | RCEC_RCE, priv->addr + RCEC);\n}\n\nstatic void rswitch_clock_disable(struct rswitch_private *priv)\n{\n\tiowrite32(RCDC_RCD, priv->addr + RCDC);\n}\n\nstatic bool rswitch_agent_clock_is_enabled(void __iomem *coma_addr, int port)\n{\n\tu32 val = ioread32(coma_addr + RCEC);\n\n\tif (val & RCEC_RCE)\n\t\treturn (val & BIT(port)) ? true : false;\n\telse\n\t\treturn false;\n}\n\nstatic void rswitch_agent_clock_ctrl(void __iomem *coma_addr, int port, int enable)\n{\n\tu32 val;\n\n\tif (enable) {\n\t\tval = ioread32(coma_addr + RCEC);\n\t\tiowrite32(val | RCEC_RCE | BIT(port), coma_addr + RCEC);\n\t} else {\n\t\tval = ioread32(coma_addr + RCDC);\n\t\tiowrite32(val | BIT(port), coma_addr + RCDC);\n\t}\n}\n\nstatic int rswitch_bpool_config(struct rswitch_private *priv)\n{\n\tu32 val;\n\n\tval = ioread32(priv->addr + CABPIRM);\n\tif (val & CABPIRM_BPR)\n\t\treturn 0;\n\n\tiowrite32(CABPIRM_BPIOG, priv->addr + CABPIRM);\n\n\treturn rswitch_reg_wait(priv->addr, CABPIRM, CABPIRM_BPR, CABPIRM_BPR);\n}\n\nstatic void rswitch_coma_init(struct rswitch_private *priv)\n{\n\tiowrite32(CABPPFLC_INIT_VALUE, priv->addr + CABPPFLC0);\n}\n\n \nstatic void rswitch_top_init(struct rswitch_private *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < RSWITCH_MAX_NUM_QUEUES; i++)\n\t\tiowrite32((i / 16) << (GWCA_INDEX * 8), priv->addr + TPEMIMC7(i));\n}\n\n \nstatic void rswitch_fwd_init(struct rswitch_private *priv)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < RSWITCH_NUM_PORTS; i++) {\n\t\tiowrite32(FWPC0_DEFAULT, priv->addr + FWPC0(i));\n\t\tiowrite32(0, priv->addr + FWPBFC(i));\n\t}\n\n\tfor (i = 0; i < RSWITCH_NUM_PORTS; i++) {\n\t\tiowrite32(priv->rdev[i]->rx_queue->index,\n\t\t\t  priv->addr + FWPBFCSDC(GWCA_INDEX, i));\n\t\tiowrite32(BIT(priv->gwca.index), priv->addr + FWPBFC(i));\n\t}\n\n\t \n\tiowrite32(FWPC0_DEFAULT, priv->addr + FWPC0(priv->gwca.index));\n\tiowrite32(FWPC1_DDE, priv->addr + FWPC1(priv->gwca.index));\n\tiowrite32(0, priv->addr + FWPBFC(priv->gwca.index));\n\tiowrite32(GENMASK(RSWITCH_NUM_PORTS - 1, 0), priv->addr + FWPBFC(priv->gwca.index));\n}\n\n \nstatic int rswitch_gwca_change_mode(struct rswitch_private *priv,\n\t\t\t\t    enum rswitch_gwca_mode mode)\n{\n\tint ret;\n\n\tif (!rswitch_agent_clock_is_enabled(priv->addr, priv->gwca.index))\n\t\trswitch_agent_clock_ctrl(priv->addr, priv->gwca.index, 1);\n\n\tiowrite32(mode, priv->addr + GWMC);\n\n\tret = rswitch_reg_wait(priv->addr, GWMS, GWMS_OPS_MASK, mode);\n\n\tif (mode == GWMC_OPC_DISABLE)\n\t\trswitch_agent_clock_ctrl(priv->addr, priv->gwca.index, 0);\n\n\treturn ret;\n}\n\nstatic int rswitch_gwca_mcast_table_reset(struct rswitch_private *priv)\n{\n\tiowrite32(GWMTIRM_MTIOG, priv->addr + GWMTIRM);\n\n\treturn rswitch_reg_wait(priv->addr, GWMTIRM, GWMTIRM_MTR, GWMTIRM_MTR);\n}\n\nstatic int rswitch_gwca_axi_ram_reset(struct rswitch_private *priv)\n{\n\tiowrite32(GWARIRM_ARIOG, priv->addr + GWARIRM);\n\n\treturn rswitch_reg_wait(priv->addr, GWARIRM, GWARIRM_ARR, GWARIRM_ARR);\n}\n\nstatic bool rswitch_is_any_data_irq(struct rswitch_private *priv, u32 *dis, bool tx)\n{\n\tu32 *mask = tx ? priv->gwca.tx_irq_bits : priv->gwca.rx_irq_bits;\n\tint i;\n\n\tfor (i = 0; i < RSWITCH_NUM_IRQ_REGS; i++) {\n\t\tif (dis[i] & mask[i])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void rswitch_get_data_irq_status(struct rswitch_private *priv, u32 *dis)\n{\n\tint i;\n\n\tfor (i = 0; i < RSWITCH_NUM_IRQ_REGS; i++) {\n\t\tdis[i] = ioread32(priv->addr + GWDIS(i));\n\t\tdis[i] &= ioread32(priv->addr + GWDIE(i));\n\t}\n}\n\nstatic void rswitch_enadis_data_irq(struct rswitch_private *priv, int index, bool enable)\n{\n\tu32 offs = enable ? GWDIE(index / 32) : GWDID(index / 32);\n\n\tiowrite32(BIT(index % 32), priv->addr + offs);\n}\n\nstatic void rswitch_ack_data_irq(struct rswitch_private *priv, int index)\n{\n\tu32 offs = GWDIS(index / 32);\n\n\tiowrite32(BIT(index % 32), priv->addr + offs);\n}\n\nstatic int rswitch_next_queue_index(struct rswitch_gwca_queue *gq, bool cur, int num)\n{\n\tint index = cur ? gq->cur : gq->dirty;\n\n\tif (index + num >= gq->ring_size)\n\t\tindex = (index + num) % gq->ring_size;\n\telse\n\t\tindex += num;\n\n\treturn index;\n}\n\nstatic int rswitch_get_num_cur_queues(struct rswitch_gwca_queue *gq)\n{\n\tif (gq->cur >= gq->dirty)\n\t\treturn gq->cur - gq->dirty;\n\telse\n\t\treturn gq->ring_size - gq->dirty + gq->cur;\n}\n\nstatic bool rswitch_is_queue_rxed(struct rswitch_gwca_queue *gq)\n{\n\tstruct rswitch_ext_ts_desc *desc = &gq->rx_ring[gq->dirty];\n\n\tif ((desc->desc.die_dt & DT_MASK) != DT_FEMPTY)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int rswitch_gwca_queue_alloc_skb(struct rswitch_gwca_queue *gq,\n\t\t\t\t\tint start_index, int num)\n{\n\tint i, index;\n\n\tfor (i = 0; i < num; i++) {\n\t\tindex = (i + start_index) % gq->ring_size;\n\t\tif (gq->skbs[index])\n\t\t\tcontinue;\n\t\tgq->skbs[index] = netdev_alloc_skb_ip_align(gq->ndev,\n\t\t\t\t\t\t\t    PKT_BUF_SZ + RSWITCH_ALIGN - 1);\n\t\tif (!gq->skbs[index])\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i--; i >= 0; i--) {\n\t\tindex = (i + start_index) % gq->ring_size;\n\t\tdev_kfree_skb(gq->skbs[index]);\n\t\tgq->skbs[index] = NULL;\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic void rswitch_gwca_queue_free(struct net_device *ndev,\n\t\t\t\t    struct rswitch_gwca_queue *gq)\n{\n\tint i;\n\n\tif (!gq->dir_tx) {\n\t\tdma_free_coherent(ndev->dev.parent,\n\t\t\t\t  sizeof(struct rswitch_ext_ts_desc) *\n\t\t\t\t  (gq->ring_size + 1), gq->rx_ring, gq->ring_dma);\n\t\tgq->rx_ring = NULL;\n\n\t\tfor (i = 0; i < gq->ring_size; i++)\n\t\t\tdev_kfree_skb(gq->skbs[i]);\n\t} else {\n\t\tdma_free_coherent(ndev->dev.parent,\n\t\t\t\t  sizeof(struct rswitch_ext_desc) *\n\t\t\t\t  (gq->ring_size + 1), gq->tx_ring, gq->ring_dma);\n\t\tgq->tx_ring = NULL;\n\t}\n\n\tkfree(gq->skbs);\n\tgq->skbs = NULL;\n}\n\nstatic void rswitch_gwca_ts_queue_free(struct rswitch_private *priv)\n{\n\tstruct rswitch_gwca_queue *gq = &priv->gwca.ts_queue;\n\n\tdma_free_coherent(&priv->pdev->dev,\n\t\t\t  sizeof(struct rswitch_ts_desc) * (gq->ring_size + 1),\n\t\t\t  gq->ts_ring, gq->ring_dma);\n\tgq->ts_ring = NULL;\n}\n\nstatic int rswitch_gwca_queue_alloc(struct net_device *ndev,\n\t\t\t\t    struct rswitch_private *priv,\n\t\t\t\t    struct rswitch_gwca_queue *gq,\n\t\t\t\t    bool dir_tx, int ring_size)\n{\n\tint i, bit;\n\n\tgq->dir_tx = dir_tx;\n\tgq->ring_size = ring_size;\n\tgq->ndev = ndev;\n\n\tgq->skbs = kcalloc(gq->ring_size, sizeof(*gq->skbs), GFP_KERNEL);\n\tif (!gq->skbs)\n\t\treturn -ENOMEM;\n\n\tif (!dir_tx) {\n\t\trswitch_gwca_queue_alloc_skb(gq, 0, gq->ring_size);\n\n\t\tgq->rx_ring = dma_alloc_coherent(ndev->dev.parent,\n\t\t\t\t\t\t sizeof(struct rswitch_ext_ts_desc) *\n\t\t\t\t\t\t (gq->ring_size + 1), &gq->ring_dma, GFP_KERNEL);\n\t} else {\n\t\tgq->tx_ring = dma_alloc_coherent(ndev->dev.parent,\n\t\t\t\t\t\t sizeof(struct rswitch_ext_desc) *\n\t\t\t\t\t\t (gq->ring_size + 1), &gq->ring_dma, GFP_KERNEL);\n\t}\n\n\tif (!gq->rx_ring && !gq->tx_ring)\n\t\tgoto out;\n\n\ti = gq->index / 32;\n\tbit = BIT(gq->index % 32);\n\tif (dir_tx)\n\t\tpriv->gwca.tx_irq_bits[i] |= bit;\n\telse\n\t\tpriv->gwca.rx_irq_bits[i] |= bit;\n\n\treturn 0;\n\nout:\n\trswitch_gwca_queue_free(ndev, gq);\n\n\treturn -ENOMEM;\n}\n\nstatic void rswitch_desc_set_dptr(struct rswitch_desc *desc, dma_addr_t addr)\n{\n\tdesc->dptrl = cpu_to_le32(lower_32_bits(addr));\n\tdesc->dptrh = upper_32_bits(addr) & 0xff;\n}\n\nstatic dma_addr_t rswitch_desc_get_dptr(const struct rswitch_desc *desc)\n{\n\treturn __le32_to_cpu(desc->dptrl) | (u64)(desc->dptrh) << 32;\n}\n\nstatic int rswitch_gwca_queue_format(struct net_device *ndev,\n\t\t\t\t     struct rswitch_private *priv,\n\t\t\t\t     struct rswitch_gwca_queue *gq)\n{\n\tint ring_size = sizeof(struct rswitch_ext_desc) * gq->ring_size;\n\tstruct rswitch_ext_desc *desc;\n\tstruct rswitch_desc *linkfix;\n\tdma_addr_t dma_addr;\n\tint i;\n\n\tmemset(gq->tx_ring, 0, ring_size);\n\tfor (i = 0, desc = gq->tx_ring; i < gq->ring_size; i++, desc++) {\n\t\tif (!gq->dir_tx) {\n\t\t\tdma_addr = dma_map_single(ndev->dev.parent,\n\t\t\t\t\t\t  gq->skbs[i]->data, PKT_BUF_SZ,\n\t\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(ndev->dev.parent, dma_addr))\n\t\t\t\tgoto err;\n\n\t\t\tdesc->desc.info_ds = cpu_to_le16(PKT_BUF_SZ);\n\t\t\trswitch_desc_set_dptr(&desc->desc, dma_addr);\n\t\t\tdesc->desc.die_dt = DT_FEMPTY | DIE;\n\t\t} else {\n\t\t\tdesc->desc.die_dt = DT_EEMPTY | DIE;\n\t\t}\n\t}\n\trswitch_desc_set_dptr(&desc->desc, gq->ring_dma);\n\tdesc->desc.die_dt = DT_LINKFIX;\n\n\tlinkfix = &priv->gwca.linkfix_table[gq->index];\n\tlinkfix->die_dt = DT_LINKFIX;\n\trswitch_desc_set_dptr(linkfix, gq->ring_dma);\n\n\tiowrite32(GWDCC_BALR | (gq->dir_tx ? GWDCC_DCP(GWCA_IPV_NUM) | GWDCC_DQT : 0) | GWDCC_EDE,\n\t\t  priv->addr + GWDCC_OFFS(gq->index));\n\n\treturn 0;\n\nerr:\n\tif (!gq->dir_tx) {\n\t\tfor (i--, desc = gq->tx_ring; i >= 0; i--, desc++) {\n\t\t\tdma_addr = rswitch_desc_get_dptr(&desc->desc);\n\t\t\tdma_unmap_single(ndev->dev.parent, dma_addr, PKT_BUF_SZ,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t}\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic void rswitch_gwca_ts_queue_fill(struct rswitch_private *priv,\n\t\t\t\t       int start_index, int num)\n{\n\tstruct rswitch_gwca_queue *gq = &priv->gwca.ts_queue;\n\tstruct rswitch_ts_desc *desc;\n\tint i, index;\n\n\tfor (i = 0; i < num; i++) {\n\t\tindex = (i + start_index) % gq->ring_size;\n\t\tdesc = &gq->ts_ring[index];\n\t\tdesc->desc.die_dt = DT_FEMPTY_ND | DIE;\n\t}\n}\n\nstatic int rswitch_gwca_queue_ext_ts_fill(struct net_device *ndev,\n\t\t\t\t\t  struct rswitch_gwca_queue *gq,\n\t\t\t\t\t  int start_index, int num)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\tstruct rswitch_ext_ts_desc *desc;\n\tdma_addr_t dma_addr;\n\tint i, index;\n\n\tfor (i = 0; i < num; i++) {\n\t\tindex = (i + start_index) % gq->ring_size;\n\t\tdesc = &gq->rx_ring[index];\n\t\tif (!gq->dir_tx) {\n\t\t\tdma_addr = dma_map_single(ndev->dev.parent,\n\t\t\t\t\t\t  gq->skbs[index]->data, PKT_BUF_SZ,\n\t\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(ndev->dev.parent, dma_addr))\n\t\t\t\tgoto err;\n\n\t\t\tdesc->desc.info_ds = cpu_to_le16(PKT_BUF_SZ);\n\t\t\trswitch_desc_set_dptr(&desc->desc, dma_addr);\n\t\t\tdma_wmb();\n\t\t\tdesc->desc.die_dt = DT_FEMPTY | DIE;\n\t\t\tdesc->info1 = cpu_to_le64(INFO1_SPN(rdev->etha->index));\n\t\t} else {\n\t\t\tdesc->desc.die_dt = DT_EEMPTY | DIE;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tif (!gq->dir_tx) {\n\t\tfor (i--; i >= 0; i--) {\n\t\t\tindex = (i + start_index) % gq->ring_size;\n\t\t\tdesc = &gq->rx_ring[index];\n\t\t\tdma_addr = rswitch_desc_get_dptr(&desc->desc);\n\t\t\tdma_unmap_single(ndev->dev.parent, dma_addr, PKT_BUF_SZ,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t}\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic int rswitch_gwca_queue_ext_ts_format(struct net_device *ndev,\n\t\t\t\t\t    struct rswitch_private *priv,\n\t\t\t\t\t    struct rswitch_gwca_queue *gq)\n{\n\tint ring_size = sizeof(struct rswitch_ext_ts_desc) * gq->ring_size;\n\tstruct rswitch_ext_ts_desc *desc;\n\tstruct rswitch_desc *linkfix;\n\tint err;\n\n\tmemset(gq->rx_ring, 0, ring_size);\n\terr = rswitch_gwca_queue_ext_ts_fill(ndev, gq, 0, gq->ring_size);\n\tif (err < 0)\n\t\treturn err;\n\n\tdesc = &gq->rx_ring[gq->ring_size];\t \n\trswitch_desc_set_dptr(&desc->desc, gq->ring_dma);\n\tdesc->desc.die_dt = DT_LINKFIX;\n\n\tlinkfix = &priv->gwca.linkfix_table[gq->index];\n\tlinkfix->die_dt = DT_LINKFIX;\n\trswitch_desc_set_dptr(linkfix, gq->ring_dma);\n\n\tiowrite32(GWDCC_BALR | (gq->dir_tx ? GWDCC_DCP(GWCA_IPV_NUM) | GWDCC_DQT : 0) |\n\t\t  GWDCC_ETS | GWDCC_EDE,\n\t\t  priv->addr + GWDCC_OFFS(gq->index));\n\n\treturn 0;\n}\n\nstatic int rswitch_gwca_linkfix_alloc(struct rswitch_private *priv)\n{\n\tint i, num_queues = priv->gwca.num_queues;\n\tstruct rswitch_gwca *gwca = &priv->gwca;\n\tstruct device *dev = &priv->pdev->dev;\n\n\tgwca->linkfix_table_size = sizeof(struct rswitch_desc) * num_queues;\n\tgwca->linkfix_table = dma_alloc_coherent(dev, gwca->linkfix_table_size,\n\t\t\t\t\t\t &gwca->linkfix_table_dma, GFP_KERNEL);\n\tif (!gwca->linkfix_table)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < num_queues; i++)\n\t\tgwca->linkfix_table[i].die_dt = DT_EOS;\n\n\treturn 0;\n}\n\nstatic void rswitch_gwca_linkfix_free(struct rswitch_private *priv)\n{\n\tstruct rswitch_gwca *gwca = &priv->gwca;\n\n\tif (gwca->linkfix_table)\n\t\tdma_free_coherent(&priv->pdev->dev, gwca->linkfix_table_size,\n\t\t\t\t  gwca->linkfix_table, gwca->linkfix_table_dma);\n\tgwca->linkfix_table = NULL;\n}\n\nstatic int rswitch_gwca_ts_queue_alloc(struct rswitch_private *priv)\n{\n\tstruct rswitch_gwca_queue *gq = &priv->gwca.ts_queue;\n\tstruct rswitch_ts_desc *desc;\n\n\tgq->ring_size = TS_RING_SIZE;\n\tgq->ts_ring = dma_alloc_coherent(&priv->pdev->dev,\n\t\t\t\t\t sizeof(struct rswitch_ts_desc) *\n\t\t\t\t\t (gq->ring_size + 1), &gq->ring_dma, GFP_KERNEL);\n\n\tif (!gq->ts_ring)\n\t\treturn -ENOMEM;\n\n\trswitch_gwca_ts_queue_fill(priv, 0, TS_RING_SIZE);\n\tdesc = &gq->ts_ring[gq->ring_size];\n\tdesc->desc.die_dt = DT_LINKFIX;\n\trswitch_desc_set_dptr(&desc->desc, gq->ring_dma);\n\tINIT_LIST_HEAD(&priv->gwca.ts_info_list);\n\n\treturn 0;\n}\n\nstatic struct rswitch_gwca_queue *rswitch_gwca_get(struct rswitch_private *priv)\n{\n\tstruct rswitch_gwca_queue *gq;\n\tint index;\n\n\tindex = find_first_zero_bit(priv->gwca.used, priv->gwca.num_queues);\n\tif (index >= priv->gwca.num_queues)\n\t\treturn NULL;\n\tset_bit(index, priv->gwca.used);\n\tgq = &priv->gwca.queues[index];\n\tmemset(gq, 0, sizeof(*gq));\n\tgq->index = index;\n\n\treturn gq;\n}\n\nstatic void rswitch_gwca_put(struct rswitch_private *priv,\n\t\t\t     struct rswitch_gwca_queue *gq)\n{\n\tclear_bit(gq->index, priv->gwca.used);\n}\n\nstatic int rswitch_txdmac_alloc(struct net_device *ndev)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\tstruct rswitch_private *priv = rdev->priv;\n\tint err;\n\n\trdev->tx_queue = rswitch_gwca_get(priv);\n\tif (!rdev->tx_queue)\n\t\treturn -EBUSY;\n\n\terr = rswitch_gwca_queue_alloc(ndev, priv, rdev->tx_queue, true, TX_RING_SIZE);\n\tif (err < 0) {\n\t\trswitch_gwca_put(priv, rdev->tx_queue);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void rswitch_txdmac_free(struct net_device *ndev)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\n\trswitch_gwca_queue_free(ndev, rdev->tx_queue);\n\trswitch_gwca_put(rdev->priv, rdev->tx_queue);\n}\n\nstatic int rswitch_txdmac_init(struct rswitch_private *priv, int index)\n{\n\tstruct rswitch_device *rdev = priv->rdev[index];\n\n\treturn rswitch_gwca_queue_format(rdev->ndev, priv, rdev->tx_queue);\n}\n\nstatic int rswitch_rxdmac_alloc(struct net_device *ndev)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\tstruct rswitch_private *priv = rdev->priv;\n\tint err;\n\n\trdev->rx_queue = rswitch_gwca_get(priv);\n\tif (!rdev->rx_queue)\n\t\treturn -EBUSY;\n\n\terr = rswitch_gwca_queue_alloc(ndev, priv, rdev->rx_queue, false, RX_RING_SIZE);\n\tif (err < 0) {\n\t\trswitch_gwca_put(priv, rdev->rx_queue);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void rswitch_rxdmac_free(struct net_device *ndev)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\n\trswitch_gwca_queue_free(ndev, rdev->rx_queue);\n\trswitch_gwca_put(rdev->priv, rdev->rx_queue);\n}\n\nstatic int rswitch_rxdmac_init(struct rswitch_private *priv, int index)\n{\n\tstruct rswitch_device *rdev = priv->rdev[index];\n\tstruct net_device *ndev = rdev->ndev;\n\n\treturn rswitch_gwca_queue_ext_ts_format(ndev, priv, rdev->rx_queue);\n}\n\nstatic int rswitch_gwca_hw_init(struct rswitch_private *priv)\n{\n\tint i, err;\n\n\terr = rswitch_gwca_change_mode(priv, GWMC_OPC_DISABLE);\n\tif (err < 0)\n\t\treturn err;\n\terr = rswitch_gwca_change_mode(priv, GWMC_OPC_CONFIG);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rswitch_gwca_mcast_table_reset(priv);\n\tif (err < 0)\n\t\treturn err;\n\terr = rswitch_gwca_axi_ram_reset(priv);\n\tif (err < 0)\n\t\treturn err;\n\n\tiowrite32(GWVCC_VEM_SC_TAG, priv->addr + GWVCC);\n\tiowrite32(0, priv->addr + GWTTFC);\n\tiowrite32(lower_32_bits(priv->gwca.linkfix_table_dma), priv->addr + GWDCBAC1);\n\tiowrite32(upper_32_bits(priv->gwca.linkfix_table_dma), priv->addr + GWDCBAC0);\n\tiowrite32(lower_32_bits(priv->gwca.ts_queue.ring_dma), priv->addr + GWTDCAC10);\n\tiowrite32(upper_32_bits(priv->gwca.ts_queue.ring_dma), priv->addr + GWTDCAC00);\n\tiowrite32(GWCA_TS_IRQ_BIT, priv->addr + GWTSDCC0);\n\n\tiowrite32(GWTPC_PPPL(GWCA_IPV_NUM), priv->addr + GWTPC0);\n\n\tfor (i = 0; i < RSWITCH_NUM_PORTS; i++) {\n\t\terr = rswitch_rxdmac_init(priv, i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = rswitch_txdmac_init(priv, i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = rswitch_gwca_change_mode(priv, GWMC_OPC_DISABLE);\n\tif (err < 0)\n\t\treturn err;\n\treturn rswitch_gwca_change_mode(priv, GWMC_OPC_OPERATION);\n}\n\nstatic int rswitch_gwca_hw_deinit(struct rswitch_private *priv)\n{\n\tint err;\n\n\terr = rswitch_gwca_change_mode(priv, GWMC_OPC_DISABLE);\n\tif (err < 0)\n\t\treturn err;\n\terr = rswitch_gwca_change_mode(priv, GWMC_OPC_RESET);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn rswitch_gwca_change_mode(priv, GWMC_OPC_DISABLE);\n}\n\nstatic int rswitch_gwca_halt(struct rswitch_private *priv)\n{\n\tint err;\n\n\tpriv->gwca_halt = true;\n\terr = rswitch_gwca_hw_deinit(priv);\n\tdev_err(&priv->pdev->dev, \"halted (%d)\\n\", err);\n\n\treturn err;\n}\n\nstatic bool rswitch_rx(struct net_device *ndev, int *quota)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\tstruct rswitch_gwca_queue *gq = rdev->rx_queue;\n\tstruct rswitch_ext_ts_desc *desc;\n\tint limit, boguscnt, num, ret;\n\tstruct sk_buff *skb;\n\tdma_addr_t dma_addr;\n\tu16 pkt_len;\n\tu32 get_ts;\n\n\tif (*quota <= 0)\n\t\treturn true;\n\n\tboguscnt = min_t(int, gq->ring_size, *quota);\n\tlimit = boguscnt;\n\n\tdesc = &gq->rx_ring[gq->cur];\n\twhile ((desc->desc.die_dt & DT_MASK) != DT_FEMPTY) {\n\t\tdma_rmb();\n\t\tpkt_len = le16_to_cpu(desc->desc.info_ds) & RX_DS;\n\t\tskb = gq->skbs[gq->cur];\n\t\tgq->skbs[gq->cur] = NULL;\n\t\tdma_addr = rswitch_desc_get_dptr(&desc->desc);\n\t\tdma_unmap_single(ndev->dev.parent, dma_addr, PKT_BUF_SZ, DMA_FROM_DEVICE);\n\t\tget_ts = rdev->priv->ptp_priv->tstamp_rx_ctrl & RCAR_GEN4_RXTSTAMP_TYPE_V2_L2_EVENT;\n\t\tif (get_ts) {\n\t\t\tstruct skb_shared_hwtstamps *shhwtstamps;\n\t\t\tstruct timespec64 ts;\n\n\t\t\tshhwtstamps = skb_hwtstamps(skb);\n\t\t\tmemset(shhwtstamps, 0, sizeof(*shhwtstamps));\n\t\t\tts.tv_sec = __le32_to_cpu(desc->ts_sec);\n\t\t\tts.tv_nsec = __le32_to_cpu(desc->ts_nsec & cpu_to_le32(0x3fffffff));\n\t\t\tshhwtstamps->hwtstamp = timespec64_to_ktime(ts);\n\t\t}\n\t\tskb_put(skb, pkt_len);\n\t\tskb->protocol = eth_type_trans(skb, ndev);\n\t\tnapi_gro_receive(&rdev->napi, skb);\n\t\trdev->ndev->stats.rx_packets++;\n\t\trdev->ndev->stats.rx_bytes += pkt_len;\n\n\t\tgq->cur = rswitch_next_queue_index(gq, true, 1);\n\t\tdesc = &gq->rx_ring[gq->cur];\n\n\t\tif (--boguscnt <= 0)\n\t\t\tbreak;\n\t}\n\n\tnum = rswitch_get_num_cur_queues(gq);\n\tret = rswitch_gwca_queue_alloc_skb(gq, gq->dirty, num);\n\tif (ret < 0)\n\t\tgoto err;\n\tret = rswitch_gwca_queue_ext_ts_fill(ndev, gq, gq->dirty, num);\n\tif (ret < 0)\n\t\tgoto err;\n\tgq->dirty = rswitch_next_queue_index(gq, false, num);\n\n\t*quota -= limit - boguscnt;\n\n\treturn boguscnt <= 0;\n\nerr:\n\trswitch_gwca_halt(rdev->priv);\n\n\treturn 0;\n}\n\nstatic int rswitch_tx_free(struct net_device *ndev, bool free_txed_only)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\tstruct rswitch_gwca_queue *gq = rdev->tx_queue;\n\tstruct rswitch_ext_desc *desc;\n\tdma_addr_t dma_addr;\n\tstruct sk_buff *skb;\n\tint free_num = 0;\n\tint size;\n\n\tfor (; rswitch_get_num_cur_queues(gq) > 0;\n\t     gq->dirty = rswitch_next_queue_index(gq, false, 1)) {\n\t\tdesc = &gq->tx_ring[gq->dirty];\n\t\tif (free_txed_only && (desc->desc.die_dt & DT_MASK) != DT_FEMPTY)\n\t\t\tbreak;\n\n\t\tdma_rmb();\n\t\tsize = le16_to_cpu(desc->desc.info_ds) & TX_DS;\n\t\tskb = gq->skbs[gq->dirty];\n\t\tif (skb) {\n\t\t\tdma_addr = rswitch_desc_get_dptr(&desc->desc);\n\t\t\tdma_unmap_single(ndev->dev.parent, dma_addr,\n\t\t\t\t\t size, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(gq->skbs[gq->dirty]);\n\t\t\tgq->skbs[gq->dirty] = NULL;\n\t\t\tfree_num++;\n\t\t}\n\t\tdesc->desc.die_dt = DT_EEMPTY;\n\t\trdev->ndev->stats.tx_packets++;\n\t\trdev->ndev->stats.tx_bytes += size;\n\t}\n\n\treturn free_num;\n}\n\nstatic int rswitch_poll(struct napi_struct *napi, int budget)\n{\n\tstruct net_device *ndev = napi->dev;\n\tstruct rswitch_private *priv;\n\tstruct rswitch_device *rdev;\n\tunsigned long flags;\n\tint quota = budget;\n\n\trdev = netdev_priv(ndev);\n\tpriv = rdev->priv;\n\nretry:\n\trswitch_tx_free(ndev, true);\n\n\tif (rswitch_rx(ndev, &quota))\n\t\tgoto out;\n\telse if (rdev->priv->gwca_halt)\n\t\tgoto err;\n\telse if (rswitch_is_queue_rxed(rdev->rx_queue))\n\t\tgoto retry;\n\n\tnetif_wake_subqueue(ndev, 0);\n\n\tif (napi_complete_done(napi, budget - quota)) {\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\trswitch_enadis_data_irq(priv, rdev->tx_queue->index, true);\n\t\trswitch_enadis_data_irq(priv, rdev->rx_queue->index, true);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t}\n\nout:\n\treturn budget - quota;\n\nerr:\n\tnapi_complete(napi);\n\n\treturn 0;\n}\n\nstatic void rswitch_queue_interrupt(struct net_device *ndev)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\n\tif (napi_schedule_prep(&rdev->napi)) {\n\t\tspin_lock(&rdev->priv->lock);\n\t\trswitch_enadis_data_irq(rdev->priv, rdev->tx_queue->index, false);\n\t\trswitch_enadis_data_irq(rdev->priv, rdev->rx_queue->index, false);\n\t\tspin_unlock(&rdev->priv->lock);\n\t\t__napi_schedule(&rdev->napi);\n\t}\n}\n\nstatic irqreturn_t rswitch_data_irq(struct rswitch_private *priv, u32 *dis)\n{\n\tstruct rswitch_gwca_queue *gq;\n\tint i, index, bit;\n\n\tfor (i = 0; i < priv->gwca.num_queues; i++) {\n\t\tgq = &priv->gwca.queues[i];\n\t\tindex = gq->index / 32;\n\t\tbit = BIT(gq->index % 32);\n\t\tif (!(dis[index] & bit))\n\t\t\tcontinue;\n\n\t\trswitch_ack_data_irq(priv, gq->index);\n\t\trswitch_queue_interrupt(gq->ndev);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rswitch_gwca_irq(int irq, void *dev_id)\n{\n\tstruct rswitch_private *priv = dev_id;\n\tu32 dis[RSWITCH_NUM_IRQ_REGS];\n\tirqreturn_t ret = IRQ_NONE;\n\n\trswitch_get_data_irq_status(priv, dis);\n\n\tif (rswitch_is_any_data_irq(priv, dis, true) ||\n\t    rswitch_is_any_data_irq(priv, dis, false))\n\t\tret = rswitch_data_irq(priv, dis);\n\n\treturn ret;\n}\n\nstatic int rswitch_gwca_request_irqs(struct rswitch_private *priv)\n{\n\tchar *resource_name, *irq_name;\n\tint i, ret, irq;\n\n\tfor (i = 0; i < GWCA_NUM_IRQS; i++) {\n\t\tresource_name = kasprintf(GFP_KERNEL, GWCA_IRQ_RESOURCE_NAME, i);\n\t\tif (!resource_name)\n\t\t\treturn -ENOMEM;\n\n\t\tirq = platform_get_irq_byname(priv->pdev, resource_name);\n\t\tkfree(resource_name);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tirq_name = devm_kasprintf(&priv->pdev->dev, GFP_KERNEL,\n\t\t\t\t\t  GWCA_IRQ_NAME, i);\n\t\tif (!irq_name)\n\t\t\treturn -ENOMEM;\n\n\t\tret = devm_request_irq(&priv->pdev->dev, irq, rswitch_gwca_irq,\n\t\t\t\t       0, irq_name, priv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rswitch_ts(struct rswitch_private *priv)\n{\n\tstruct rswitch_gwca_queue *gq = &priv->gwca.ts_queue;\n\tstruct rswitch_gwca_ts_info *ts_info, *ts_info2;\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tstruct rswitch_ts_desc *desc;\n\tstruct timespec64 ts;\n\tu32 tag, port;\n\tint num;\n\n\tdesc = &gq->ts_ring[gq->cur];\n\twhile ((desc->desc.die_dt & DT_MASK) != DT_FEMPTY_ND) {\n\t\tdma_rmb();\n\n\t\tport = TS_DESC_DPN(__le32_to_cpu(desc->desc.dptrl));\n\t\ttag = TS_DESC_TSUN(__le32_to_cpu(desc->desc.dptrl));\n\n\t\tlist_for_each_entry_safe(ts_info, ts_info2, &priv->gwca.ts_info_list, list) {\n\t\t\tif (!(ts_info->port == port && ts_info->tag == tag))\n\t\t\t\tcontinue;\n\n\t\t\tmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\n\t\t\tts.tv_sec = __le32_to_cpu(desc->ts_sec);\n\t\t\tts.tv_nsec = __le32_to_cpu(desc->ts_nsec & cpu_to_le32(0x3fffffff));\n\t\t\tshhwtstamps.hwtstamp = timespec64_to_ktime(ts);\n\t\t\tskb_tstamp_tx(ts_info->skb, &shhwtstamps);\n\t\t\tdev_consume_skb_irq(ts_info->skb);\n\t\t\tlist_del(&ts_info->list);\n\t\t\tkfree(ts_info);\n\t\t\tbreak;\n\t\t}\n\n\t\tgq->cur = rswitch_next_queue_index(gq, true, 1);\n\t\tdesc = &gq->ts_ring[gq->cur];\n\t}\n\n\tnum = rswitch_get_num_cur_queues(gq);\n\trswitch_gwca_ts_queue_fill(priv, gq->dirty, num);\n\tgq->dirty = rswitch_next_queue_index(gq, false, num);\n}\n\nstatic irqreturn_t rswitch_gwca_ts_irq(int irq, void *dev_id)\n{\n\tstruct rswitch_private *priv = dev_id;\n\n\tif (ioread32(priv->addr + GWTSDIS) & GWCA_TS_IRQ_BIT) {\n\t\tiowrite32(GWCA_TS_IRQ_BIT, priv->addr + GWTSDIS);\n\t\trswitch_ts(priv);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int rswitch_gwca_ts_request_irqs(struct rswitch_private *priv)\n{\n\tint irq;\n\n\tirq = platform_get_irq_byname(priv->pdev, GWCA_TS_IRQ_RESOURCE_NAME);\n\tif (irq < 0)\n\t\treturn irq;\n\n\treturn devm_request_irq(&priv->pdev->dev, irq, rswitch_gwca_ts_irq,\n\t\t\t\t0, GWCA_TS_IRQ_NAME, priv);\n}\n\n \nstatic int rswitch_etha_change_mode(struct rswitch_etha *etha,\n\t\t\t\t    enum rswitch_etha_mode mode)\n{\n\tint ret;\n\n\tif (!rswitch_agent_clock_is_enabled(etha->coma_addr, etha->index))\n\t\trswitch_agent_clock_ctrl(etha->coma_addr, etha->index, 1);\n\n\tiowrite32(mode, etha->addr + EAMC);\n\n\tret = rswitch_reg_wait(etha->addr, EAMS, EAMS_OPS_MASK, mode);\n\n\tif (mode == EAMC_OPC_DISABLE)\n\t\trswitch_agent_clock_ctrl(etha->coma_addr, etha->index, 0);\n\n\treturn ret;\n}\n\nstatic void rswitch_etha_read_mac_address(struct rswitch_etha *etha)\n{\n\tu32 mrmac0 = ioread32(etha->addr + MRMAC0);\n\tu32 mrmac1 = ioread32(etha->addr + MRMAC1);\n\tu8 *mac = &etha->mac_addr[0];\n\n\tmac[0] = (mrmac0 >>  8) & 0xFF;\n\tmac[1] = (mrmac0 >>  0) & 0xFF;\n\tmac[2] = (mrmac1 >> 24) & 0xFF;\n\tmac[3] = (mrmac1 >> 16) & 0xFF;\n\tmac[4] = (mrmac1 >>  8) & 0xFF;\n\tmac[5] = (mrmac1 >>  0) & 0xFF;\n}\n\nstatic void rswitch_etha_write_mac_address(struct rswitch_etha *etha, const u8 *mac)\n{\n\tiowrite32((mac[0] << 8) | mac[1], etha->addr + MRMAC0);\n\tiowrite32((mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5],\n\t\t  etha->addr + MRMAC1);\n}\n\nstatic int rswitch_etha_wait_link_verification(struct rswitch_etha *etha)\n{\n\tiowrite32(MLVC_PLV, etha->addr + MLVC);\n\n\treturn rswitch_reg_wait(etha->addr, MLVC, MLVC_PLV, 0);\n}\n\nstatic void rswitch_rmac_setting(struct rswitch_etha *etha, const u8 *mac)\n{\n\tu32 val;\n\n\trswitch_etha_write_mac_address(etha, mac);\n\n\tswitch (etha->speed) {\n\tcase 100:\n\t\tval = MPIC_LSC_100M;\n\t\tbreak;\n\tcase 1000:\n\t\tval = MPIC_LSC_1G;\n\t\tbreak;\n\tcase 2500:\n\t\tval = MPIC_LSC_2_5G;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tiowrite32(MPIC_PIS_GMII | val, etha->addr + MPIC);\n}\n\nstatic void rswitch_etha_enable_mii(struct rswitch_etha *etha)\n{\n\trswitch_modify(etha->addr, MPIC, MPIC_PSMCS_MASK | MPIC_PSMHT_MASK,\n\t\t       MPIC_PSMCS(etha->psmcs) | MPIC_PSMHT(0x06));\n\trswitch_modify(etha->addr, MPSM, 0, MPSM_MFF_C45);\n}\n\nstatic int rswitch_etha_hw_init(struct rswitch_etha *etha, const u8 *mac)\n{\n\tint err;\n\n\terr = rswitch_etha_change_mode(etha, EAMC_OPC_DISABLE);\n\tif (err < 0)\n\t\treturn err;\n\terr = rswitch_etha_change_mode(etha, EAMC_OPC_CONFIG);\n\tif (err < 0)\n\t\treturn err;\n\n\tiowrite32(EAVCC_VEM_SC_TAG, etha->addr + EAVCC);\n\trswitch_rmac_setting(etha, mac);\n\trswitch_etha_enable_mii(etha);\n\n\terr = rswitch_etha_wait_link_verification(etha);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rswitch_etha_change_mode(etha, EAMC_OPC_DISABLE);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn rswitch_etha_change_mode(etha, EAMC_OPC_OPERATION);\n}\n\nstatic int rswitch_etha_set_access(struct rswitch_etha *etha, bool read,\n\t\t\t\t   int phyad, int devad, int regad, int data)\n{\n\tint pop = read ? MDIO_READ_C45 : MDIO_WRITE_C45;\n\tu32 val;\n\tint ret;\n\n\tif (devad == 0xffffffff)\n\t\treturn -ENODEV;\n\n\twritel(MMIS1_CLEAR_FLAGS, etha->addr + MMIS1);\n\n\tval = MPSM_PSME | MPSM_MFF_C45;\n\tiowrite32((regad << 16) | (devad << 8) | (phyad << 3) | val, etha->addr + MPSM);\n\n\tret = rswitch_reg_wait(etha->addr, MMIS1, MMIS1_PAACS, MMIS1_PAACS);\n\tif (ret)\n\t\treturn ret;\n\n\trswitch_modify(etha->addr, MMIS1, MMIS1_PAACS, MMIS1_PAACS);\n\n\tif (read) {\n\t\twritel((pop << 13) | (devad << 8) | (phyad << 3) | val, etha->addr + MPSM);\n\n\t\tret = rswitch_reg_wait(etha->addr, MMIS1, MMIS1_PRACS, MMIS1_PRACS);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = (ioread32(etha->addr + MPSM) & MPSM_PRD_MASK) >> 16;\n\n\t\trswitch_modify(etha->addr, MMIS1, MMIS1_PRACS, MMIS1_PRACS);\n\t} else {\n\t\tiowrite32((data << 16) | (pop << 13) | (devad << 8) | (phyad << 3) | val,\n\t\t\t  etha->addr + MPSM);\n\n\t\tret = rswitch_reg_wait(etha->addr, MMIS1, MMIS1_PWACS, MMIS1_PWACS);\n\t}\n\n\treturn ret;\n}\n\nstatic int rswitch_etha_mii_read_c45(struct mii_bus *bus, int addr, int devad,\n\t\t\t\t     int regad)\n{\n\tstruct rswitch_etha *etha = bus->priv;\n\n\treturn rswitch_etha_set_access(etha, true, addr, devad, regad, 0);\n}\n\nstatic int rswitch_etha_mii_write_c45(struct mii_bus *bus, int addr, int devad,\n\t\t\t\t      int regad, u16 val)\n{\n\tstruct rswitch_etha *etha = bus->priv;\n\n\treturn rswitch_etha_set_access(etha, false, addr, devad, regad, val);\n}\n\n \nstatic struct device_node *rswitch_get_port_node(struct rswitch_device *rdev)\n{\n\tstruct device_node *ports, *port;\n\tint err = 0;\n\tu32 index;\n\n\tports = of_get_child_by_name(rdev->ndev->dev.parent->of_node,\n\t\t\t\t     \"ethernet-ports\");\n\tif (!ports)\n\t\treturn NULL;\n\n\tfor_each_child_of_node(ports, port) {\n\t\terr = of_property_read_u32(port, \"reg\", &index);\n\t\tif (err < 0) {\n\t\t\tport = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (index == rdev->etha->index) {\n\t\t\tif (!of_device_is_available(port))\n\t\t\t\tport = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tof_node_put(ports);\n\n\treturn port;\n}\n\nstatic int rswitch_etha_get_params(struct rswitch_device *rdev)\n{\n\tu32 max_speed;\n\tint err;\n\n\tif (!rdev->np_port)\n\t\treturn 0;\t \n\n\terr = of_get_phy_mode(rdev->np_port, &rdev->etha->phy_interface);\n\tif (err)\n\t\treturn err;\n\n\terr = of_property_read_u32(rdev->np_port, \"max-speed\", &max_speed);\n\tif (!err) {\n\t\trdev->etha->speed = max_speed;\n\t\treturn 0;\n\t}\n\n\t \n\tswitch (rdev->etha->phy_interface) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\trdev->etha->speed = SPEED_100;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\trdev->etha->speed = SPEED_1000;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\trdev->etha->speed = SPEED_2500;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rswitch_mii_register(struct rswitch_device *rdev)\n{\n\tstruct device_node *mdio_np;\n\tstruct mii_bus *mii_bus;\n\tint err;\n\n\tmii_bus = mdiobus_alloc();\n\tif (!mii_bus)\n\t\treturn -ENOMEM;\n\n\tmii_bus->name = \"rswitch_mii\";\n\tsprintf(mii_bus->id, \"etha%d\", rdev->etha->index);\n\tmii_bus->priv = rdev->etha;\n\tmii_bus->read_c45 = rswitch_etha_mii_read_c45;\n\tmii_bus->write_c45 = rswitch_etha_mii_write_c45;\n\tmii_bus->parent = &rdev->priv->pdev->dev;\n\n\tmdio_np = of_get_child_by_name(rdev->np_port, \"mdio\");\n\terr = of_mdiobus_register(mii_bus, mdio_np);\n\tif (err < 0) {\n\t\tmdiobus_free(mii_bus);\n\t\tgoto out;\n\t}\n\n\trdev->etha->mii = mii_bus;\n\nout:\n\tof_node_put(mdio_np);\n\n\treturn err;\n}\n\nstatic void rswitch_mii_unregister(struct rswitch_device *rdev)\n{\n\tif (rdev->etha->mii) {\n\t\tmdiobus_unregister(rdev->etha->mii);\n\t\tmdiobus_free(rdev->etha->mii);\n\t\trdev->etha->mii = NULL;\n\t}\n}\n\nstatic void rswitch_adjust_link(struct net_device *ndev)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\tstruct phy_device *phydev = ndev->phydev;\n\n\tif (phydev->link != rdev->etha->link) {\n\t\tphy_print_status(phydev);\n\t\tif (phydev->link)\n\t\t\tphy_power_on(rdev->serdes);\n\t\telse if (rdev->serdes->power_count)\n\t\t\tphy_power_off(rdev->serdes);\n\n\t\trdev->etha->link = phydev->link;\n\n\t\tif (!rdev->priv->etha_no_runtime_change &&\n\t\t    phydev->speed != rdev->etha->speed) {\n\t\t\trdev->etha->speed = phydev->speed;\n\n\t\t\trswitch_etha_hw_init(rdev->etha, rdev->ndev->dev_addr);\n\t\t\tphy_set_speed(rdev->serdes, rdev->etha->speed);\n\t\t}\n\t}\n}\n\nstatic void rswitch_phy_remove_link_mode(struct rswitch_device *rdev,\n\t\t\t\t\t struct phy_device *phydev)\n{\n\tif (!rdev->priv->etha_no_runtime_change)\n\t\treturn;\n\n\tswitch (rdev->etha->speed) {\n\tcase SPEED_2500:\n\t\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_1000baseT_Full_BIT);\n\t\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_100baseT_Full_BIT);\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_2500baseX_Full_BIT);\n\t\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_100baseT_Full_BIT);\n\t\tbreak;\n\tcase SPEED_100:\n\t\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_2500baseX_Full_BIT);\n\t\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_1000baseT_Full_BIT);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tphy_set_max_speed(phydev, rdev->etha->speed);\n}\n\nstatic int rswitch_phy_device_init(struct rswitch_device *rdev)\n{\n\tstruct phy_device *phydev;\n\tstruct device_node *phy;\n\tint err = -ENOENT;\n\n\tif (!rdev->np_port)\n\t\treturn -ENODEV;\n\n\tphy = of_parse_phandle(rdev->np_port, \"phy-handle\", 0);\n\tif (!phy)\n\t\treturn -ENODEV;\n\n\t \n\tphydev = of_phy_find_device(phy);\n\tif (!phydev)\n\t\tgoto out;\n\t__set_bit(rdev->etha->phy_interface, phydev->host_interfaces);\n\n\tphydev = of_phy_connect(rdev->ndev, phy, rswitch_adjust_link, 0,\n\t\t\t\trdev->etha->phy_interface);\n\tif (!phydev)\n\t\tgoto out;\n\n\tphy_set_max_speed(phydev, SPEED_2500);\n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_10baseT_Half_BIT);\n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_10baseT_Full_BIT);\n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_100baseT_Half_BIT);\n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_1000baseT_Half_BIT);\n\trswitch_phy_remove_link_mode(rdev, phydev);\n\n\tphy_attached_info(phydev);\n\n\terr = 0;\nout:\n\tof_node_put(phy);\n\n\treturn err;\n}\n\nstatic void rswitch_phy_device_deinit(struct rswitch_device *rdev)\n{\n\tif (rdev->ndev->phydev)\n\t\tphy_disconnect(rdev->ndev->phydev);\n}\n\nstatic int rswitch_serdes_set_params(struct rswitch_device *rdev)\n{\n\tint err;\n\n\terr = phy_set_mode_ext(rdev->serdes, PHY_MODE_ETHERNET,\n\t\t\t       rdev->etha->phy_interface);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn phy_set_speed(rdev->serdes, rdev->etha->speed);\n}\n\nstatic int rswitch_ether_port_init_one(struct rswitch_device *rdev)\n{\n\tint err;\n\n\tif (!rdev->etha->operated) {\n\t\terr = rswitch_etha_hw_init(rdev->etha, rdev->ndev->dev_addr);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (rdev->priv->etha_no_runtime_change)\n\t\t\trdev->etha->operated = true;\n\t}\n\n\terr = rswitch_mii_register(rdev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rswitch_phy_device_init(rdev);\n\tif (err < 0)\n\t\tgoto err_phy_device_init;\n\n\trdev->serdes = devm_of_phy_get(&rdev->priv->pdev->dev, rdev->np_port, NULL);\n\tif (IS_ERR(rdev->serdes)) {\n\t\terr = PTR_ERR(rdev->serdes);\n\t\tgoto err_serdes_phy_get;\n\t}\n\n\terr = rswitch_serdes_set_params(rdev);\n\tif (err < 0)\n\t\tgoto err_serdes_set_params;\n\n\treturn 0;\n\nerr_serdes_set_params:\nerr_serdes_phy_get:\n\trswitch_phy_device_deinit(rdev);\n\nerr_phy_device_init:\n\trswitch_mii_unregister(rdev);\n\n\treturn err;\n}\n\nstatic void rswitch_ether_port_deinit_one(struct rswitch_device *rdev)\n{\n\trswitch_phy_device_deinit(rdev);\n\trswitch_mii_unregister(rdev);\n}\n\nstatic int rswitch_ether_port_init_all(struct rswitch_private *priv)\n{\n\tint i, err;\n\n\trswitch_for_each_enabled_port(priv, i) {\n\t\terr = rswitch_ether_port_init_one(priv->rdev[i]);\n\t\tif (err)\n\t\t\tgoto err_init_one;\n\t}\n\n\trswitch_for_each_enabled_port(priv, i) {\n\t\terr = phy_init(priv->rdev[i]->serdes);\n\t\tif (err)\n\t\t\tgoto err_serdes;\n\t}\n\n\treturn 0;\n\nerr_serdes:\n\trswitch_for_each_enabled_port_continue_reverse(priv, i)\n\t\tphy_exit(priv->rdev[i]->serdes);\n\ti = RSWITCH_NUM_PORTS;\n\nerr_init_one:\n\trswitch_for_each_enabled_port_continue_reverse(priv, i)\n\t\trswitch_ether_port_deinit_one(priv->rdev[i]);\n\n\treturn err;\n}\n\nstatic void rswitch_ether_port_deinit_all(struct rswitch_private *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < RSWITCH_NUM_PORTS; i++) {\n\t\tphy_exit(priv->rdev[i]->serdes);\n\t\trswitch_ether_port_deinit_one(priv->rdev[i]);\n\t}\n}\n\nstatic int rswitch_open(struct net_device *ndev)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\tunsigned long flags;\n\n\tphy_start(ndev->phydev);\n\n\tnapi_enable(&rdev->napi);\n\tnetif_start_queue(ndev);\n\n\tspin_lock_irqsave(&rdev->priv->lock, flags);\n\trswitch_enadis_data_irq(rdev->priv, rdev->tx_queue->index, true);\n\trswitch_enadis_data_irq(rdev->priv, rdev->rx_queue->index, true);\n\tspin_unlock_irqrestore(&rdev->priv->lock, flags);\n\n\tif (bitmap_empty(rdev->priv->opened_ports, RSWITCH_NUM_PORTS))\n\t\tiowrite32(GWCA_TS_IRQ_BIT, rdev->priv->addr + GWTSDIE);\n\n\tbitmap_set(rdev->priv->opened_ports, rdev->port, 1);\n\n\treturn 0;\n};\n\nstatic int rswitch_stop(struct net_device *ndev)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\tstruct rswitch_gwca_ts_info *ts_info, *ts_info2;\n\tunsigned long flags;\n\n\tnetif_tx_stop_all_queues(ndev);\n\tbitmap_clear(rdev->priv->opened_ports, rdev->port, 1);\n\n\tif (bitmap_empty(rdev->priv->opened_ports, RSWITCH_NUM_PORTS))\n\t\tiowrite32(GWCA_TS_IRQ_BIT, rdev->priv->addr + GWTSDID);\n\n\tlist_for_each_entry_safe(ts_info, ts_info2, &rdev->priv->gwca.ts_info_list, list) {\n\t\tif (ts_info->port != rdev->port)\n\t\t\tcontinue;\n\t\tdev_kfree_skb_irq(ts_info->skb);\n\t\tlist_del(&ts_info->list);\n\t\tkfree(ts_info);\n\t}\n\n\tspin_lock_irqsave(&rdev->priv->lock, flags);\n\trswitch_enadis_data_irq(rdev->priv, rdev->tx_queue->index, false);\n\trswitch_enadis_data_irq(rdev->priv, rdev->rx_queue->index, false);\n\tspin_unlock_irqrestore(&rdev->priv->lock, flags);\n\n\tphy_stop(ndev->phydev);\n\tnapi_disable(&rdev->napi);\n\n\treturn 0;\n};\n\nstatic netdev_tx_t rswitch_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\tstruct rswitch_gwca_queue *gq = rdev->tx_queue;\n\tnetdev_tx_t ret = NETDEV_TX_OK;\n\tstruct rswitch_ext_desc *desc;\n\tdma_addr_t dma_addr;\n\n\tif (rswitch_get_num_cur_queues(gq) >= gq->ring_size - 1) {\n\t\tnetif_stop_subqueue(ndev, 0);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (skb_put_padto(skb, ETH_ZLEN))\n\t\treturn ret;\n\n\tdma_addr = dma_map_single(ndev->dev.parent, skb->data, skb->len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(ndev->dev.parent, dma_addr))\n\t\tgoto err_kfree;\n\n\tgq->skbs[gq->cur] = skb;\n\tdesc = &gq->tx_ring[gq->cur];\n\trswitch_desc_set_dptr(&desc->desc, dma_addr);\n\tdesc->desc.info_ds = cpu_to_le16(skb->len);\n\n\tdesc->info1 = cpu_to_le64(INFO1_DV(BIT(rdev->etha->index)) |\n\t\t\t\t  INFO1_IPV(GWCA_IPV_NUM) | INFO1_FMT);\n\tif (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {\n\t\tstruct rswitch_gwca_ts_info *ts_info;\n\n\t\tts_info = kzalloc(sizeof(*ts_info), GFP_ATOMIC);\n\t\tif (!ts_info)\n\t\t\tgoto err_unmap;\n\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\trdev->ts_tag++;\n\t\tdesc->info1 |= cpu_to_le64(INFO1_TSUN(rdev->ts_tag) | INFO1_TXC);\n\n\t\tts_info->skb = skb_get(skb);\n\t\tts_info->port = rdev->port;\n\t\tts_info->tag = rdev->ts_tag;\n\t\tlist_add_tail(&ts_info->list, &rdev->priv->gwca.ts_info_list);\n\n\t\tskb_tx_timestamp(skb);\n\t}\n\n\tdma_wmb();\n\n\tdesc->desc.die_dt = DT_FSINGLE | DIE;\n\twmb();\t \n\n\tgq->cur = rswitch_next_queue_index(gq, true, 1);\n\trswitch_modify(rdev->addr, GWTRC(gq->index), 0, BIT(gq->index % 32));\n\n\treturn ret;\n\nerr_unmap:\n\tdma_unmap_single(ndev->dev.parent, dma_addr, skb->len, DMA_TO_DEVICE);\n\nerr_kfree:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nstatic struct net_device_stats *rswitch_get_stats(struct net_device *ndev)\n{\n\treturn &ndev->stats;\n}\n\nstatic int rswitch_hwstamp_get(struct net_device *ndev, struct ifreq *req)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\tstruct rcar_gen4_ptp_private *ptp_priv;\n\tstruct hwtstamp_config config;\n\n\tptp_priv = rdev->priv->ptp_priv;\n\n\tconfig.flags = 0;\n\tconfig.tx_type = ptp_priv->tstamp_tx_ctrl ? HWTSTAMP_TX_ON :\n\t\t\t\t\t\t    HWTSTAMP_TX_OFF;\n\tswitch (ptp_priv->tstamp_rx_ctrl & RCAR_GEN4_RXTSTAMP_TYPE) {\n\tcase RCAR_GEN4_RXTSTAMP_TYPE_V2_L2_EVENT:\n\t\tconfig.rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\n\t\tbreak;\n\tcase RCAR_GEN4_RXTSTAMP_TYPE_ALL:\n\t\tconfig.rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tbreak;\n\tdefault:\n\t\tconfig.rx_filter = HWTSTAMP_FILTER_NONE;\n\t\tbreak;\n\t}\n\n\treturn copy_to_user(req->ifr_data, &config, sizeof(config)) ? -EFAULT : 0;\n}\n\nstatic int rswitch_hwstamp_set(struct net_device *ndev, struct ifreq *req)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\tu32 tstamp_rx_ctrl = RCAR_GEN4_RXTSTAMP_ENABLED;\n\tstruct hwtstamp_config config;\n\tu32 tstamp_tx_ctrl;\n\n\tif (copy_from_user(&config, req->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\tif (config.flags)\n\t\treturn -EINVAL;\n\n\tswitch (config.tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\ttstamp_tx_ctrl = 0;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\ttstamp_tx_ctrl = RCAR_GEN4_TXTSTAMP_ENABLED;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\ttstamp_rx_ctrl = 0;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\t\ttstamp_rx_ctrl |= RCAR_GEN4_RXTSTAMP_TYPE_V2_L2_EVENT;\n\t\tbreak;\n\tdefault:\n\t\tconfig.rx_filter = HWTSTAMP_FILTER_ALL;\n\t\ttstamp_rx_ctrl |= RCAR_GEN4_RXTSTAMP_TYPE_ALL;\n\t\tbreak;\n\t}\n\n\trdev->priv->ptp_priv->tstamp_tx_ctrl = tstamp_tx_ctrl;\n\trdev->priv->ptp_priv->tstamp_rx_ctrl = tstamp_rx_ctrl;\n\n\treturn copy_to_user(req->ifr_data, &config, sizeof(config)) ? -EFAULT : 0;\n}\n\nstatic int rswitch_eth_ioctl(struct net_device *ndev, struct ifreq *req, int cmd)\n{\n\tif (!netif_running(ndev))\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SIOCGHWTSTAMP:\n\t\treturn rswitch_hwstamp_get(ndev, req);\n\tcase SIOCSHWTSTAMP:\n\t\treturn rswitch_hwstamp_set(ndev, req);\n\tdefault:\n\t\treturn phy_mii_ioctl(ndev->phydev, req, cmd);\n\t}\n}\n\nstatic const struct net_device_ops rswitch_netdev_ops = {\n\t.ndo_open = rswitch_open,\n\t.ndo_stop = rswitch_stop,\n\t.ndo_start_xmit = rswitch_start_xmit,\n\t.ndo_get_stats = rswitch_get_stats,\n\t.ndo_eth_ioctl = rswitch_eth_ioctl,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_set_mac_address = eth_mac_addr,\n};\n\nstatic int rswitch_get_ts_info(struct net_device *ndev, struct ethtool_ts_info *info)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\n\tinfo->phc_index = ptp_clock_index(rdev->priv->ptp_priv->clock);\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF) | BIT(HWTSTAMP_TX_ON);\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE) | BIT(HWTSTAMP_FILTER_ALL);\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops rswitch_ethtool_ops = {\n\t.get_ts_info = rswitch_get_ts_info,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\nstatic const struct of_device_id renesas_eth_sw_of_table[] = {\n\t{ .compatible = \"renesas,r8a779f0-ether-switch\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, renesas_eth_sw_of_table);\n\nstatic void rswitch_etha_init(struct rswitch_private *priv, int index)\n{\n\tstruct rswitch_etha *etha = &priv->etha[index];\n\n\tmemset(etha, 0, sizeof(*etha));\n\tetha->index = index;\n\tetha->addr = priv->addr + RSWITCH_ETHA_OFFSET + index * RSWITCH_ETHA_SIZE;\n\tetha->coma_addr = priv->addr;\n\n\t \n\tetha->psmcs = clk_get_rate(priv->clk) / 100000 / (25 * 2) - 1;\n}\n\nstatic int rswitch_device_alloc(struct rswitch_private *priv, int index)\n{\n\tstruct platform_device *pdev = priv->pdev;\n\tstruct rswitch_device *rdev;\n\tstruct net_device *ndev;\n\tint err;\n\n\tif (index >= RSWITCH_NUM_PORTS)\n\t\treturn -EINVAL;\n\n\tndev = alloc_etherdev_mqs(sizeof(struct rswitch_device), 1, 1);\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\tether_setup(ndev);\n\n\trdev = netdev_priv(ndev);\n\trdev->ndev = ndev;\n\trdev->priv = priv;\n\tpriv->rdev[index] = rdev;\n\trdev->port = index;\n\trdev->etha = &priv->etha[index];\n\trdev->addr = priv->addr;\n\n\tndev->base_addr = (unsigned long)rdev->addr;\n\tsnprintf(ndev->name, IFNAMSIZ, \"tsn%d\", index);\n\tndev->netdev_ops = &rswitch_netdev_ops;\n\tndev->ethtool_ops = &rswitch_ethtool_ops;\n\n\tnetif_napi_add(ndev, &rdev->napi, rswitch_poll);\n\n\trdev->np_port = rswitch_get_port_node(rdev);\n\trdev->disabled = !rdev->np_port;\n\terr = of_get_ethdev_address(rdev->np_port, ndev);\n\tof_node_put(rdev->np_port);\n\tif (err) {\n\t\tif (is_valid_ether_addr(rdev->etha->mac_addr))\n\t\t\teth_hw_addr_set(ndev, rdev->etha->mac_addr);\n\t\telse\n\t\t\teth_hw_addr_random(ndev);\n\t}\n\n\terr = rswitch_etha_get_params(rdev);\n\tif (err < 0)\n\t\tgoto out_get_params;\n\n\tif (rdev->priv->gwca.speed < rdev->etha->speed)\n\t\trdev->priv->gwca.speed = rdev->etha->speed;\n\n\terr = rswitch_rxdmac_alloc(ndev);\n\tif (err < 0)\n\t\tgoto out_rxdmac;\n\n\terr = rswitch_txdmac_alloc(ndev);\n\tif (err < 0)\n\t\tgoto out_txdmac;\n\n\treturn 0;\n\nout_txdmac:\n\trswitch_rxdmac_free(ndev);\n\nout_rxdmac:\nout_get_params:\n\tnetif_napi_del(&rdev->napi);\n\tfree_netdev(ndev);\n\n\treturn err;\n}\n\nstatic void rswitch_device_free(struct rswitch_private *priv, int index)\n{\n\tstruct rswitch_device *rdev = priv->rdev[index];\n\tstruct net_device *ndev = rdev->ndev;\n\n\trswitch_txdmac_free(ndev);\n\trswitch_rxdmac_free(ndev);\n\tnetif_napi_del(&rdev->napi);\n\tfree_netdev(ndev);\n}\n\nstatic int rswitch_init(struct rswitch_private *priv)\n{\n\tint i, err;\n\n\tfor (i = 0; i < RSWITCH_NUM_PORTS; i++)\n\t\trswitch_etha_init(priv, i);\n\n\trswitch_clock_enable(priv);\n\tfor (i = 0; i < RSWITCH_NUM_PORTS; i++)\n\t\trswitch_etha_read_mac_address(&priv->etha[i]);\n\n\trswitch_reset(priv);\n\n\trswitch_clock_enable(priv);\n\trswitch_top_init(priv);\n\terr = rswitch_bpool_config(priv);\n\tif (err < 0)\n\t\treturn err;\n\n\trswitch_coma_init(priv);\n\n\terr = rswitch_gwca_linkfix_alloc(priv);\n\tif (err < 0)\n\t\treturn -ENOMEM;\n\n\terr = rswitch_gwca_ts_queue_alloc(priv);\n\tif (err < 0)\n\t\tgoto err_ts_queue_alloc;\n\n\tfor (i = 0; i < RSWITCH_NUM_PORTS; i++) {\n\t\terr = rswitch_device_alloc(priv, i);\n\t\tif (err < 0) {\n\t\t\tfor (i--; i >= 0; i--)\n\t\t\t\trswitch_device_free(priv, i);\n\t\t\tgoto err_device_alloc;\n\t\t}\n\t}\n\n\trswitch_fwd_init(priv);\n\n\terr = rcar_gen4_ptp_register(priv->ptp_priv, RCAR_GEN4_PTP_REG_LAYOUT_S4,\n\t\t\t\t     RCAR_GEN4_PTP_CLOCK_S4);\n\tif (err < 0)\n\t\tgoto err_ptp_register;\n\n\terr = rswitch_gwca_request_irqs(priv);\n\tif (err < 0)\n\t\tgoto err_gwca_request_irq;\n\n\terr = rswitch_gwca_ts_request_irqs(priv);\n\tif (err < 0)\n\t\tgoto err_gwca_ts_request_irq;\n\n\terr = rswitch_gwca_hw_init(priv);\n\tif (err < 0)\n\t\tgoto err_gwca_hw_init;\n\n\terr = rswitch_ether_port_init_all(priv);\n\tif (err)\n\t\tgoto err_ether_port_init_all;\n\n\trswitch_for_each_enabled_port(priv, i) {\n\t\terr = register_netdev(priv->rdev[i]->ndev);\n\t\tif (err) {\n\t\t\trswitch_for_each_enabled_port_continue_reverse(priv, i)\n\t\t\t\tunregister_netdev(priv->rdev[i]->ndev);\n\t\t\tgoto err_register_netdev;\n\t\t}\n\t}\n\n\trswitch_for_each_enabled_port(priv, i)\n\t\tnetdev_info(priv->rdev[i]->ndev, \"MAC address %pM\\n\",\n\t\t\t    priv->rdev[i]->ndev->dev_addr);\n\n\treturn 0;\n\nerr_register_netdev:\n\trswitch_ether_port_deinit_all(priv);\n\nerr_ether_port_init_all:\n\trswitch_gwca_hw_deinit(priv);\n\nerr_gwca_hw_init:\nerr_gwca_ts_request_irq:\nerr_gwca_request_irq:\n\trcar_gen4_ptp_unregister(priv->ptp_priv);\n\nerr_ptp_register:\n\tfor (i = 0; i < RSWITCH_NUM_PORTS; i++)\n\t\trswitch_device_free(priv, i);\n\nerr_device_alloc:\n\trswitch_gwca_ts_queue_free(priv);\n\nerr_ts_queue_alloc:\n\trswitch_gwca_linkfix_free(priv);\n\n\treturn err;\n}\n\nstatic const struct soc_device_attribute rswitch_soc_no_speed_change[]  = {\n\t{ .soc_id = \"r8a779f0\", .revision = \"ES1.0\" },\n\t{   }\n};\n\nstatic int renesas_eth_sw_probe(struct platform_device *pdev)\n{\n\tconst struct soc_device_attribute *attr;\n\tstruct rswitch_private *priv;\n\tstruct resource *res;\n\tint ret;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"secure_base\");\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"invalid resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&priv->lock);\n\n\tpriv->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tattr = soc_device_match(rswitch_soc_no_speed_change);\n\tif (attr)\n\t\tpriv->etha_no_runtime_change = true;\n\n\tpriv->ptp_priv = rcar_gen4_ptp_alloc(pdev);\n\tif (!priv->ptp_priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\tpriv->pdev = pdev;\n\tpriv->addr = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(priv->addr))\n\t\treturn PTR_ERR(priv->addr);\n\n\tpriv->ptp_priv->addr = priv->addr + RCAR_GEN4_GPTP_OFFSET_S4;\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(40));\n\tif (ret < 0) {\n\t\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tpriv->gwca.index = AGENT_INDEX_GWCA;\n\tpriv->gwca.num_queues = min(RSWITCH_NUM_PORTS * NUM_QUEUES_PER_NDEV,\n\t\t\t\t    RSWITCH_MAX_NUM_QUEUES);\n\tpriv->gwca.queues = devm_kcalloc(&pdev->dev, priv->gwca.num_queues,\n\t\t\t\t\t sizeof(*priv->gwca.queues), GFP_KERNEL);\n\tif (!priv->gwca.queues)\n\t\treturn -ENOMEM;\n\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tret = rswitch_init(priv);\n\tif (ret < 0) {\n\t\tpm_runtime_put(&pdev->dev);\n\t\tpm_runtime_disable(&pdev->dev);\n\t\treturn ret;\n\t}\n\n\tdevice_set_wakeup_capable(&pdev->dev, 1);\n\n\treturn ret;\n}\n\nstatic void rswitch_deinit(struct rswitch_private *priv)\n{\n\tint i;\n\n\trswitch_gwca_hw_deinit(priv);\n\trcar_gen4_ptp_unregister(priv->ptp_priv);\n\n\trswitch_for_each_enabled_port(priv, i) {\n\t\tstruct rswitch_device *rdev = priv->rdev[i];\n\n\t\tunregister_netdev(rdev->ndev);\n\t\trswitch_ether_port_deinit_one(rdev);\n\t\tphy_exit(priv->rdev[i]->serdes);\n\t}\n\n\tfor (i = 0; i < RSWITCH_NUM_PORTS; i++)\n\t\trswitch_device_free(priv, i);\n\n\trswitch_gwca_ts_queue_free(priv);\n\trswitch_gwca_linkfix_free(priv);\n\n\trswitch_clock_disable(priv);\n}\n\nstatic int renesas_eth_sw_remove(struct platform_device *pdev)\n{\n\tstruct rswitch_private *priv = platform_get_drvdata(pdev);\n\n\trswitch_deinit(priv);\n\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tplatform_set_drvdata(pdev, NULL);\n\n\treturn 0;\n}\n\nstatic struct platform_driver renesas_eth_sw_driver_platform = {\n\t.probe = renesas_eth_sw_probe,\n\t.remove = renesas_eth_sw_remove,\n\t.driver = {\n\t\t.name = \"renesas_eth_sw\",\n\t\t.of_match_table = renesas_eth_sw_of_table,\n\t}\n};\nmodule_platform_driver(renesas_eth_sw_driver_platform);\nMODULE_AUTHOR(\"Yoshihiro Shimoda\");\nMODULE_DESCRIPTION(\"Renesas Ethernet Switch device driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}