{
  "module_name": "ibmveth.c",
  "hash_id": "9886ea0a71f999e8debb67f3d185c6033ac387077036016f47a5d83ee510e4b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ibm/ibmveth.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/pm.h>\n#include <linux/ethtool.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/slab.h>\n#include <asm/hvcall.h>\n#include <linux/atomic.h>\n#include <asm/vio.h>\n#include <asm/iommu.h>\n#include <asm/firmware.h>\n#include <net/tcp.h>\n#include <net/ip6_checksum.h>\n\n#include \"ibmveth.h\"\n\nstatic irqreturn_t ibmveth_interrupt(int irq, void *dev_instance);\nstatic void ibmveth_rxq_harvest_buffer(struct ibmveth_adapter *adapter);\nstatic unsigned long ibmveth_get_desired_dma(struct vio_dev *vdev);\n\nstatic struct kobj_type ktype_veth_pool;\n\n\nstatic const char ibmveth_driver_name[] = \"ibmveth\";\nstatic const char ibmveth_driver_string[] = \"IBM Power Virtual Ethernet Driver\";\n#define ibmveth_driver_version \"1.06\"\n\nMODULE_AUTHOR(\"Santiago Leon <santil@linux.vnet.ibm.com>\");\nMODULE_DESCRIPTION(\"IBM Power Virtual Ethernet Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(ibmveth_driver_version);\n\nstatic unsigned int tx_copybreak __read_mostly = 128;\nmodule_param(tx_copybreak, uint, 0644);\nMODULE_PARM_DESC(tx_copybreak,\n\t\"Maximum size of packet that is copied to a new buffer on transmit\");\n\nstatic unsigned int rx_copybreak __read_mostly = 128;\nmodule_param(rx_copybreak, uint, 0644);\nMODULE_PARM_DESC(rx_copybreak,\n\t\"Maximum size of packet that is copied to a new buffer on receive\");\n\nstatic unsigned int rx_flush __read_mostly = 0;\nmodule_param(rx_flush, uint, 0644);\nMODULE_PARM_DESC(rx_flush, \"Flush receive buffers before use\");\n\nstatic bool old_large_send __read_mostly;\nmodule_param(old_large_send, bool, 0444);\nMODULE_PARM_DESC(old_large_send,\n\t\"Use old large send method on firmware that supports the new method\");\n\nstruct ibmveth_stat {\n\tchar name[ETH_GSTRING_LEN];\n\tint offset;\n};\n\n#define IBMVETH_STAT_OFF(stat) offsetof(struct ibmveth_adapter, stat)\n#define IBMVETH_GET_STAT(a, off) *((u64 *)(((unsigned long)(a)) + off))\n\nstatic struct ibmveth_stat ibmveth_stats[] = {\n\t{ \"replenish_task_cycles\", IBMVETH_STAT_OFF(replenish_task_cycles) },\n\t{ \"replenish_no_mem\", IBMVETH_STAT_OFF(replenish_no_mem) },\n\t{ \"replenish_add_buff_failure\",\n\t\t\tIBMVETH_STAT_OFF(replenish_add_buff_failure) },\n\t{ \"replenish_add_buff_success\",\n\t\t\tIBMVETH_STAT_OFF(replenish_add_buff_success) },\n\t{ \"rx_invalid_buffer\", IBMVETH_STAT_OFF(rx_invalid_buffer) },\n\t{ \"rx_no_buffer\", IBMVETH_STAT_OFF(rx_no_buffer) },\n\t{ \"tx_map_failed\", IBMVETH_STAT_OFF(tx_map_failed) },\n\t{ \"tx_send_failed\", IBMVETH_STAT_OFF(tx_send_failed) },\n\t{ \"fw_enabled_ipv4_csum\", IBMVETH_STAT_OFF(fw_ipv4_csum_support) },\n\t{ \"fw_enabled_ipv6_csum\", IBMVETH_STAT_OFF(fw_ipv6_csum_support) },\n\t{ \"tx_large_packets\", IBMVETH_STAT_OFF(tx_large_packets) },\n\t{ \"rx_large_packets\", IBMVETH_STAT_OFF(rx_large_packets) },\n\t{ \"fw_enabled_large_send\", IBMVETH_STAT_OFF(fw_large_send_support) }\n};\n\n \nstatic inline u32 ibmveth_rxq_flags(struct ibmveth_adapter *adapter)\n{\n\treturn be32_to_cpu(adapter->rx_queue.queue_addr[adapter->rx_queue.index].flags_off);\n}\n\nstatic inline int ibmveth_rxq_toggle(struct ibmveth_adapter *adapter)\n{\n\treturn (ibmveth_rxq_flags(adapter) & IBMVETH_RXQ_TOGGLE) >>\n\t\t\tIBMVETH_RXQ_TOGGLE_SHIFT;\n}\n\nstatic inline int ibmveth_rxq_pending_buffer(struct ibmveth_adapter *adapter)\n{\n\treturn ibmveth_rxq_toggle(adapter) == adapter->rx_queue.toggle;\n}\n\nstatic inline int ibmveth_rxq_buffer_valid(struct ibmveth_adapter *adapter)\n{\n\treturn ibmveth_rxq_flags(adapter) & IBMVETH_RXQ_VALID;\n}\n\nstatic inline int ibmveth_rxq_frame_offset(struct ibmveth_adapter *adapter)\n{\n\treturn ibmveth_rxq_flags(adapter) & IBMVETH_RXQ_OFF_MASK;\n}\n\nstatic inline int ibmveth_rxq_large_packet(struct ibmveth_adapter *adapter)\n{\n\treturn ibmveth_rxq_flags(adapter) & IBMVETH_RXQ_LRG_PKT;\n}\n\nstatic inline int ibmveth_rxq_frame_length(struct ibmveth_adapter *adapter)\n{\n\treturn be32_to_cpu(adapter->rx_queue.queue_addr[adapter->rx_queue.index].length);\n}\n\nstatic inline int ibmveth_rxq_csum_good(struct ibmveth_adapter *adapter)\n{\n\treturn ibmveth_rxq_flags(adapter) & IBMVETH_RXQ_CSUM_GOOD;\n}\n\nstatic unsigned int ibmveth_real_max_tx_queues(void)\n{\n\tunsigned int n_cpu = num_online_cpus();\n\n\treturn min(n_cpu, IBMVETH_MAX_QUEUES);\n}\n\n \nstatic void ibmveth_init_buffer_pool(struct ibmveth_buff_pool *pool,\n\t\t\t\t     u32 pool_index, u32 pool_size,\n\t\t\t\t     u32 buff_size, u32 pool_active)\n{\n\tpool->size = pool_size;\n\tpool->index = pool_index;\n\tpool->buff_size = buff_size;\n\tpool->threshold = pool_size * 7 / 8;\n\tpool->active = pool_active;\n}\n\n \nstatic int ibmveth_alloc_buffer_pool(struct ibmveth_buff_pool *pool)\n{\n\tint i;\n\n\tpool->free_map = kmalloc_array(pool->size, sizeof(u16), GFP_KERNEL);\n\n\tif (!pool->free_map)\n\t\treturn -1;\n\n\tpool->dma_addr = kcalloc(pool->size, sizeof(dma_addr_t), GFP_KERNEL);\n\tif (!pool->dma_addr) {\n\t\tkfree(pool->free_map);\n\t\tpool->free_map = NULL;\n\t\treturn -1;\n\t}\n\n\tpool->skbuff = kcalloc(pool->size, sizeof(void *), GFP_KERNEL);\n\n\tif (!pool->skbuff) {\n\t\tkfree(pool->dma_addr);\n\t\tpool->dma_addr = NULL;\n\n\t\tkfree(pool->free_map);\n\t\tpool->free_map = NULL;\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < pool->size; ++i)\n\t\tpool->free_map[i] = i;\n\n\tatomic_set(&pool->available, 0);\n\tpool->producer_index = 0;\n\tpool->consumer_index = 0;\n\n\treturn 0;\n}\n\nstatic inline void ibmveth_flush_buffer(void *addr, unsigned long length)\n{\n\tunsigned long offset;\n\n\tfor (offset = 0; offset < length; offset += SMP_CACHE_BYTES)\n\t\tasm(\"dcbf %0,%1,1\" :: \"b\" (addr), \"r\" (offset));\n}\n\n \nstatic void ibmveth_replenish_buffer_pool(struct ibmveth_adapter *adapter,\n\t\t\t\t\t  struct ibmveth_buff_pool *pool)\n{\n\tu32 i;\n\tu32 count = pool->size - atomic_read(&pool->available);\n\tu32 buffers_added = 0;\n\tstruct sk_buff *skb;\n\tunsigned int free_index, index;\n\tu64 correlator;\n\tunsigned long lpar_rc;\n\tdma_addr_t dma_addr;\n\n\tmb();\n\n\tfor (i = 0; i < count; ++i) {\n\t\tunion ibmveth_buf_desc desc;\n\n\t\tskb = netdev_alloc_skb(adapter->netdev, pool->buff_size);\n\n\t\tif (!skb) {\n\t\t\tnetdev_dbg(adapter->netdev,\n\t\t\t\t   \"replenish: unable to allocate skb\\n\");\n\t\t\tadapter->replenish_no_mem++;\n\t\t\tbreak;\n\t\t}\n\n\t\tfree_index = pool->consumer_index;\n\t\tpool->consumer_index++;\n\t\tif (pool->consumer_index >= pool->size)\n\t\t\tpool->consumer_index = 0;\n\t\tindex = pool->free_map[free_index];\n\n\t\tBUG_ON(index == IBM_VETH_INVALID_MAP);\n\t\tBUG_ON(pool->skbuff[index] != NULL);\n\n\t\tdma_addr = dma_map_single(&adapter->vdev->dev, skb->data,\n\t\t\t\tpool->buff_size, DMA_FROM_DEVICE);\n\n\t\tif (dma_mapping_error(&adapter->vdev->dev, dma_addr))\n\t\t\tgoto failure;\n\n\t\tpool->free_map[free_index] = IBM_VETH_INVALID_MAP;\n\t\tpool->dma_addr[index] = dma_addr;\n\t\tpool->skbuff[index] = skb;\n\n\t\tcorrelator = ((u64)pool->index << 32) | index;\n\t\t*(u64 *)skb->data = correlator;\n\n\t\tdesc.fields.flags_len = IBMVETH_BUF_VALID | pool->buff_size;\n\t\tdesc.fields.address = dma_addr;\n\n\t\tif (rx_flush) {\n\t\t\tunsigned int len = min(pool->buff_size,\n\t\t\t\t\t\tadapter->netdev->mtu +\n\t\t\t\t\t\tIBMVETH_BUFF_OH);\n\t\t\tibmveth_flush_buffer(skb->data, len);\n\t\t}\n\t\tlpar_rc = h_add_logical_lan_buffer(adapter->vdev->unit_address,\n\t\t\t\t\t\t   desc.desc);\n\n\t\tif (lpar_rc != H_SUCCESS) {\n\t\t\tgoto failure;\n\t\t} else {\n\t\t\tbuffers_added++;\n\t\t\tadapter->replenish_add_buff_success++;\n\t\t}\n\t}\n\n\tmb();\n\tatomic_add(buffers_added, &(pool->available));\n\treturn;\n\nfailure:\n\tpool->free_map[free_index] = index;\n\tpool->skbuff[index] = NULL;\n\tif (pool->consumer_index == 0)\n\t\tpool->consumer_index = pool->size - 1;\n\telse\n\t\tpool->consumer_index--;\n\tif (!dma_mapping_error(&adapter->vdev->dev, dma_addr))\n\t\tdma_unmap_single(&adapter->vdev->dev,\n\t\t                 pool->dma_addr[index], pool->buff_size,\n\t\t                 DMA_FROM_DEVICE);\n\tdev_kfree_skb_any(skb);\n\tadapter->replenish_add_buff_failure++;\n\n\tmb();\n\tatomic_add(buffers_added, &(pool->available));\n}\n\n \nstatic void ibmveth_update_rx_no_buffer(struct ibmveth_adapter *adapter)\n{\n\t__be64 *p = adapter->buffer_list_addr + 4096 - 8;\n\n\tadapter->rx_no_buffer = be64_to_cpup(p);\n}\n\n \nstatic void ibmveth_replenish_task(struct ibmveth_adapter *adapter)\n{\n\tint i;\n\n\tadapter->replenish_task_cycles++;\n\n\tfor (i = (IBMVETH_NUM_BUFF_POOLS - 1); i >= 0; i--) {\n\t\tstruct ibmveth_buff_pool *pool = &adapter->rx_buff_pool[i];\n\n\t\tif (pool->active &&\n\t\t    (atomic_read(&pool->available) < pool->threshold))\n\t\t\tibmveth_replenish_buffer_pool(adapter, pool);\n\t}\n\n\tibmveth_update_rx_no_buffer(adapter);\n}\n\n \nstatic void ibmveth_free_buffer_pool(struct ibmveth_adapter *adapter,\n\t\t\t\t     struct ibmveth_buff_pool *pool)\n{\n\tint i;\n\n\tkfree(pool->free_map);\n\tpool->free_map = NULL;\n\n\tif (pool->skbuff && pool->dma_addr) {\n\t\tfor (i = 0; i < pool->size; ++i) {\n\t\t\tstruct sk_buff *skb = pool->skbuff[i];\n\t\t\tif (skb) {\n\t\t\t\tdma_unmap_single(&adapter->vdev->dev,\n\t\t\t\t\t\t pool->dma_addr[i],\n\t\t\t\t\t\t pool->buff_size,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tpool->skbuff[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pool->dma_addr) {\n\t\tkfree(pool->dma_addr);\n\t\tpool->dma_addr = NULL;\n\t}\n\n\tif (pool->skbuff) {\n\t\tkfree(pool->skbuff);\n\t\tpool->skbuff = NULL;\n\t}\n}\n\n \nstatic void ibmveth_remove_buffer_from_pool(struct ibmveth_adapter *adapter,\n\t\t\t\t\t    u64 correlator)\n{\n\tunsigned int pool  = correlator >> 32;\n\tunsigned int index = correlator & 0xffffffffUL;\n\tunsigned int free_index;\n\tstruct sk_buff *skb;\n\n\tBUG_ON(pool >= IBMVETH_NUM_BUFF_POOLS);\n\tBUG_ON(index >= adapter->rx_buff_pool[pool].size);\n\n\tskb = adapter->rx_buff_pool[pool].skbuff[index];\n\n\tBUG_ON(skb == NULL);\n\n\tadapter->rx_buff_pool[pool].skbuff[index] = NULL;\n\n\tdma_unmap_single(&adapter->vdev->dev,\n\t\t\t adapter->rx_buff_pool[pool].dma_addr[index],\n\t\t\t adapter->rx_buff_pool[pool].buff_size,\n\t\t\t DMA_FROM_DEVICE);\n\n\tfree_index = adapter->rx_buff_pool[pool].producer_index;\n\tadapter->rx_buff_pool[pool].producer_index++;\n\tif (adapter->rx_buff_pool[pool].producer_index >=\n\t    adapter->rx_buff_pool[pool].size)\n\t\tadapter->rx_buff_pool[pool].producer_index = 0;\n\tadapter->rx_buff_pool[pool].free_map[free_index] = index;\n\n\tmb();\n\n\tatomic_dec(&(adapter->rx_buff_pool[pool].available));\n}\n\n \nstatic inline struct sk_buff *ibmveth_rxq_get_buffer(struct ibmveth_adapter *adapter)\n{\n\tu64 correlator = adapter->rx_queue.queue_addr[adapter->rx_queue.index].correlator;\n\tunsigned int pool = correlator >> 32;\n\tunsigned int index = correlator & 0xffffffffUL;\n\n\tBUG_ON(pool >= IBMVETH_NUM_BUFF_POOLS);\n\tBUG_ON(index >= adapter->rx_buff_pool[pool].size);\n\n\treturn adapter->rx_buff_pool[pool].skbuff[index];\n}\n\n \nstatic int ibmveth_rxq_recycle_buffer(struct ibmveth_adapter *adapter)\n{\n\tu32 q_index = adapter->rx_queue.index;\n\tu64 correlator = adapter->rx_queue.queue_addr[q_index].correlator;\n\tunsigned int pool = correlator >> 32;\n\tunsigned int index = correlator & 0xffffffffUL;\n\tunion ibmveth_buf_desc desc;\n\tunsigned long lpar_rc;\n\tint ret = 1;\n\n\tBUG_ON(pool >= IBMVETH_NUM_BUFF_POOLS);\n\tBUG_ON(index >= adapter->rx_buff_pool[pool].size);\n\n\tif (!adapter->rx_buff_pool[pool].active) {\n\t\tibmveth_rxq_harvest_buffer(adapter);\n\t\tibmveth_free_buffer_pool(adapter, &adapter->rx_buff_pool[pool]);\n\t\tgoto out;\n\t}\n\n\tdesc.fields.flags_len = IBMVETH_BUF_VALID |\n\t\tadapter->rx_buff_pool[pool].buff_size;\n\tdesc.fields.address = adapter->rx_buff_pool[pool].dma_addr[index];\n\n\tlpar_rc = h_add_logical_lan_buffer(adapter->vdev->unit_address, desc.desc);\n\n\tif (lpar_rc != H_SUCCESS) {\n\t\tnetdev_dbg(adapter->netdev, \"h_add_logical_lan_buffer failed \"\n\t\t\t   \"during recycle rc=%ld\", lpar_rc);\n\t\tibmveth_remove_buffer_from_pool(adapter, adapter->rx_queue.queue_addr[adapter->rx_queue.index].correlator);\n\t\tret = 0;\n\t}\n\n\tif (++adapter->rx_queue.index == adapter->rx_queue.num_slots) {\n\t\tadapter->rx_queue.index = 0;\n\t\tadapter->rx_queue.toggle = !adapter->rx_queue.toggle;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic void ibmveth_rxq_harvest_buffer(struct ibmveth_adapter *adapter)\n{\n\tibmveth_remove_buffer_from_pool(adapter, adapter->rx_queue.queue_addr[adapter->rx_queue.index].correlator);\n\n\tif (++adapter->rx_queue.index == adapter->rx_queue.num_slots) {\n\t\tadapter->rx_queue.index = 0;\n\t\tadapter->rx_queue.toggle = !adapter->rx_queue.toggle;\n\t}\n}\n\nstatic void ibmveth_free_tx_ltb(struct ibmveth_adapter *adapter, int idx)\n{\n\tdma_unmap_single(&adapter->vdev->dev, adapter->tx_ltb_dma[idx],\n\t\t\t adapter->tx_ltb_size, DMA_TO_DEVICE);\n\tkfree(adapter->tx_ltb_ptr[idx]);\n\tadapter->tx_ltb_ptr[idx] = NULL;\n}\n\nstatic int ibmveth_allocate_tx_ltb(struct ibmveth_adapter *adapter, int idx)\n{\n\tadapter->tx_ltb_ptr[idx] = kzalloc(adapter->tx_ltb_size,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!adapter->tx_ltb_ptr[idx]) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"unable to allocate tx long term buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tadapter->tx_ltb_dma[idx] = dma_map_single(&adapter->vdev->dev,\n\t\t\t\t\t\t  adapter->tx_ltb_ptr[idx],\n\t\t\t\t\t\t  adapter->tx_ltb_size,\n\t\t\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(&adapter->vdev->dev, adapter->tx_ltb_dma[idx])) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"unable to DMA map tx long term buffer\\n\");\n\t\tkfree(adapter->tx_ltb_ptr[idx]);\n\t\tadapter->tx_ltb_ptr[idx] = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int ibmveth_register_logical_lan(struct ibmveth_adapter *adapter,\n        union ibmveth_buf_desc rxq_desc, u64 mac_address)\n{\n\tint rc, try_again = 1;\n\n\t \nretry:\n\trc = h_register_logical_lan(adapter->vdev->unit_address,\n\t\t\t\t    adapter->buffer_list_dma, rxq_desc.desc,\n\t\t\t\t    adapter->filter_list_dma, mac_address);\n\n\tif (rc != H_SUCCESS && try_again) {\n\t\tdo {\n\t\t\trc = h_free_logical_lan(adapter->vdev->unit_address);\n\t\t} while (H_IS_LONG_BUSY(rc) || (rc == H_BUSY));\n\n\t\ttry_again = 0;\n\t\tgoto retry;\n\t}\n\n\treturn rc;\n}\n\nstatic int ibmveth_open(struct net_device *netdev)\n{\n\tstruct ibmveth_adapter *adapter = netdev_priv(netdev);\n\tu64 mac_address;\n\tint rxq_entries = 1;\n\tunsigned long lpar_rc;\n\tint rc;\n\tunion ibmveth_buf_desc rxq_desc;\n\tint i;\n\tstruct device *dev;\n\n\tnetdev_dbg(netdev, \"open starting\\n\");\n\n\tnapi_enable(&adapter->napi);\n\n\tfor(i = 0; i < IBMVETH_NUM_BUFF_POOLS; i++)\n\t\trxq_entries += adapter->rx_buff_pool[i].size;\n\n\trc = -ENOMEM;\n\tadapter->buffer_list_addr = (void*) get_zeroed_page(GFP_KERNEL);\n\tif (!adapter->buffer_list_addr) {\n\t\tnetdev_err(netdev, \"unable to allocate list pages\\n\");\n\t\tgoto out;\n\t}\n\n\tadapter->filter_list_addr = (void*) get_zeroed_page(GFP_KERNEL);\n\tif (!adapter->filter_list_addr) {\n\t\tnetdev_err(netdev, \"unable to allocate filter pages\\n\");\n\t\tgoto out_free_buffer_list;\n\t}\n\n\tdev = &adapter->vdev->dev;\n\n\tadapter->rx_queue.queue_len = sizeof(struct ibmveth_rx_q_entry) *\n\t\t\t\t\t\trxq_entries;\n\tadapter->rx_queue.queue_addr =\n\t\tdma_alloc_coherent(dev, adapter->rx_queue.queue_len,\n\t\t\t\t   &adapter->rx_queue.queue_dma, GFP_KERNEL);\n\tif (!adapter->rx_queue.queue_addr)\n\t\tgoto out_free_filter_list;\n\n\tadapter->buffer_list_dma = dma_map_single(dev,\n\t\t\tadapter->buffer_list_addr, 4096, DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(dev, adapter->buffer_list_dma)) {\n\t\tnetdev_err(netdev, \"unable to map buffer list pages\\n\");\n\t\tgoto out_free_queue_mem;\n\t}\n\n\tadapter->filter_list_dma = dma_map_single(dev,\n\t\t\tadapter->filter_list_addr, 4096, DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(dev, adapter->filter_list_dma)) {\n\t\tnetdev_err(netdev, \"unable to map filter list pages\\n\");\n\t\tgoto out_unmap_buffer_list;\n\t}\n\n\tfor (i = 0; i < netdev->real_num_tx_queues; i++) {\n\t\tif (ibmveth_allocate_tx_ltb(adapter, i))\n\t\t\tgoto out_free_tx_ltb;\n\t}\n\n\tadapter->rx_queue.index = 0;\n\tadapter->rx_queue.num_slots = rxq_entries;\n\tadapter->rx_queue.toggle = 1;\n\n\tmac_address = ether_addr_to_u64(netdev->dev_addr);\n\n\trxq_desc.fields.flags_len = IBMVETH_BUF_VALID |\n\t\t\t\t\tadapter->rx_queue.queue_len;\n\trxq_desc.fields.address = adapter->rx_queue.queue_dma;\n\n\tnetdev_dbg(netdev, \"buffer list @ 0x%p\\n\", adapter->buffer_list_addr);\n\tnetdev_dbg(netdev, \"filter list @ 0x%p\\n\", adapter->filter_list_addr);\n\tnetdev_dbg(netdev, \"receive q   @ 0x%p\\n\", adapter->rx_queue.queue_addr);\n\n\th_vio_signal(adapter->vdev->unit_address, VIO_IRQ_DISABLE);\n\n\tlpar_rc = ibmveth_register_logical_lan(adapter, rxq_desc, mac_address);\n\n\tif (lpar_rc != H_SUCCESS) {\n\t\tnetdev_err(netdev, \"h_register_logical_lan failed with %ld\\n\",\n\t\t\t   lpar_rc);\n\t\tnetdev_err(netdev, \"buffer TCE:0x%llx filter TCE:0x%llx rxq \"\n\t\t\t   \"desc:0x%llx MAC:0x%llx\\n\",\n\t\t\t\t     adapter->buffer_list_dma,\n\t\t\t\t     adapter->filter_list_dma,\n\t\t\t\t     rxq_desc.desc,\n\t\t\t\t     mac_address);\n\t\trc = -ENONET;\n\t\tgoto out_unmap_filter_list;\n\t}\n\n\tfor (i = 0; i < IBMVETH_NUM_BUFF_POOLS; i++) {\n\t\tif (!adapter->rx_buff_pool[i].active)\n\t\t\tcontinue;\n\t\tif (ibmveth_alloc_buffer_pool(&adapter->rx_buff_pool[i])) {\n\t\t\tnetdev_err(netdev, \"unable to alloc pool\\n\");\n\t\t\tadapter->rx_buff_pool[i].active = 0;\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_free_buffer_pools;\n\t\t}\n\t}\n\n\tnetdev_dbg(netdev, \"registering irq 0x%x\\n\", netdev->irq);\n\trc = request_irq(netdev->irq, ibmveth_interrupt, 0, netdev->name,\n\t\t\t netdev);\n\tif (rc != 0) {\n\t\tnetdev_err(netdev, \"unable to request irq 0x%x, rc %d\\n\",\n\t\t\t   netdev->irq, rc);\n\t\tdo {\n\t\t\tlpar_rc = h_free_logical_lan(adapter->vdev->unit_address);\n\t\t} while (H_IS_LONG_BUSY(lpar_rc) || (lpar_rc == H_BUSY));\n\n\t\tgoto out_free_buffer_pools;\n\t}\n\n\trc = -ENOMEM;\n\n\tnetdev_dbg(netdev, \"initial replenish cycle\\n\");\n\tibmveth_interrupt(netdev->irq, netdev);\n\n\tnetif_tx_start_all_queues(netdev);\n\n\tnetdev_dbg(netdev, \"open complete\\n\");\n\n\treturn 0;\n\nout_free_buffer_pools:\n\twhile (--i >= 0) {\n\t\tif (adapter->rx_buff_pool[i].active)\n\t\t\tibmveth_free_buffer_pool(adapter,\n\t\t\t\t\t\t &adapter->rx_buff_pool[i]);\n\t}\nout_unmap_filter_list:\n\tdma_unmap_single(dev, adapter->filter_list_dma, 4096,\n\t\t\t DMA_BIDIRECTIONAL);\n\nout_free_tx_ltb:\n\twhile (--i >= 0) {\n\t\tibmveth_free_tx_ltb(adapter, i);\n\t}\n\nout_unmap_buffer_list:\n\tdma_unmap_single(dev, adapter->buffer_list_dma, 4096,\n\t\t\t DMA_BIDIRECTIONAL);\nout_free_queue_mem:\n\tdma_free_coherent(dev, adapter->rx_queue.queue_len,\n\t\t\t  adapter->rx_queue.queue_addr,\n\t\t\t  adapter->rx_queue.queue_dma);\nout_free_filter_list:\n\tfree_page((unsigned long)adapter->filter_list_addr);\nout_free_buffer_list:\n\tfree_page((unsigned long)adapter->buffer_list_addr);\nout:\n\tnapi_disable(&adapter->napi);\n\treturn rc;\n}\n\nstatic int ibmveth_close(struct net_device *netdev)\n{\n\tstruct ibmveth_adapter *adapter = netdev_priv(netdev);\n\tstruct device *dev = &adapter->vdev->dev;\n\tlong lpar_rc;\n\tint i;\n\n\tnetdev_dbg(netdev, \"close starting\\n\");\n\n\tnapi_disable(&adapter->napi);\n\n\tnetif_tx_stop_all_queues(netdev);\n\n\th_vio_signal(adapter->vdev->unit_address, VIO_IRQ_DISABLE);\n\n\tdo {\n\t\tlpar_rc = h_free_logical_lan(adapter->vdev->unit_address);\n\t} while (H_IS_LONG_BUSY(lpar_rc) || (lpar_rc == H_BUSY));\n\n\tif (lpar_rc != H_SUCCESS) {\n\t\tnetdev_err(netdev, \"h_free_logical_lan failed with %lx, \"\n\t\t\t   \"continuing with close\\n\", lpar_rc);\n\t}\n\n\tfree_irq(netdev->irq, netdev);\n\n\tibmveth_update_rx_no_buffer(adapter);\n\n\tdma_unmap_single(dev, adapter->buffer_list_dma, 4096,\n\t\t\t DMA_BIDIRECTIONAL);\n\tfree_page((unsigned long)adapter->buffer_list_addr);\n\n\tdma_unmap_single(dev, adapter->filter_list_dma, 4096,\n\t\t\t DMA_BIDIRECTIONAL);\n\tfree_page((unsigned long)adapter->filter_list_addr);\n\n\tdma_free_coherent(dev, adapter->rx_queue.queue_len,\n\t\t\t  adapter->rx_queue.queue_addr,\n\t\t\t  adapter->rx_queue.queue_dma);\n\n\tfor (i = 0; i < IBMVETH_NUM_BUFF_POOLS; i++)\n\t\tif (adapter->rx_buff_pool[i].active)\n\t\t\tibmveth_free_buffer_pool(adapter,\n\t\t\t\t\t\t &adapter->rx_buff_pool[i]);\n\n\tfor (i = 0; i < netdev->real_num_tx_queues; i++)\n\t\tibmveth_free_tx_ltb(adapter, i);\n\n\tnetdev_dbg(netdev, \"close complete\\n\");\n\n\treturn 0;\n}\n\nstatic int ibmveth_set_link_ksettings(struct net_device *dev,\n\t\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct ibmveth_adapter *adapter = netdev_priv(dev);\n\n\treturn ethtool_virtdev_set_link_ksettings(dev, cmd,\n\t\t\t\t\t\t  &adapter->speed,\n\t\t\t\t\t\t  &adapter->duplex);\n}\n\nstatic int ibmveth_get_link_ksettings(struct net_device *dev,\n\t\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tstruct ibmveth_adapter *adapter = netdev_priv(dev);\n\n\tcmd->base.speed = adapter->speed;\n\tcmd->base.duplex = adapter->duplex;\n\tcmd->base.port = PORT_OTHER;\n\n\treturn 0;\n}\n\nstatic void ibmveth_init_link_settings(struct net_device *dev)\n{\n\tstruct ibmveth_adapter *adapter = netdev_priv(dev);\n\n\tadapter->speed = SPEED_1000;\n\tadapter->duplex = DUPLEX_FULL;\n}\n\nstatic void netdev_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, ibmveth_driver_name, sizeof(info->driver));\n\tstrscpy(info->version, ibmveth_driver_version, sizeof(info->version));\n}\n\nstatic netdev_features_t ibmveth_fix_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\t \n\n\tif (!(features & NETIF_F_RXCSUM))\n\t\tfeatures &= ~NETIF_F_CSUM_MASK;\n\n\treturn features;\n}\n\nstatic int ibmveth_set_csum_offload(struct net_device *dev, u32 data)\n{\n\tstruct ibmveth_adapter *adapter = netdev_priv(dev);\n\tunsigned long set_attr, clr_attr, ret_attr;\n\tunsigned long set_attr6, clr_attr6;\n\tlong ret, ret4, ret6;\n\tint rc1 = 0, rc2 = 0;\n\tint restart = 0;\n\n\tif (netif_running(dev)) {\n\t\trestart = 1;\n\t\tibmveth_close(dev);\n\t}\n\n\tset_attr = 0;\n\tclr_attr = 0;\n\tset_attr6 = 0;\n\tclr_attr6 = 0;\n\n\tif (data) {\n\t\tset_attr = IBMVETH_ILLAN_IPV4_TCP_CSUM;\n\t\tset_attr6 = IBMVETH_ILLAN_IPV6_TCP_CSUM;\n\t} else {\n\t\tclr_attr = IBMVETH_ILLAN_IPV4_TCP_CSUM;\n\t\tclr_attr6 = IBMVETH_ILLAN_IPV6_TCP_CSUM;\n\t}\n\n\tret = h_illan_attributes(adapter->vdev->unit_address, 0, 0, &ret_attr);\n\n\tif (ret == H_SUCCESS &&\n\t    (ret_attr & IBMVETH_ILLAN_PADDED_PKT_CSUM)) {\n\t\tret4 = h_illan_attributes(adapter->vdev->unit_address, clr_attr,\n\t\t\t\t\t set_attr, &ret_attr);\n\n\t\tif (ret4 != H_SUCCESS) {\n\t\t\tnetdev_err(dev, \"unable to change IPv4 checksum \"\n\t\t\t\t\t\"offload settings. %d rc=%ld\\n\",\n\t\t\t\t\tdata, ret4);\n\n\t\t\th_illan_attributes(adapter->vdev->unit_address,\n\t\t\t\t\t   set_attr, clr_attr, &ret_attr);\n\n\t\t\tif (data == 1)\n\t\t\t\tdev->features &= ~NETIF_F_IP_CSUM;\n\n\t\t} else {\n\t\t\tadapter->fw_ipv4_csum_support = data;\n\t\t}\n\n\t\tret6 = h_illan_attributes(adapter->vdev->unit_address,\n\t\t\t\t\t clr_attr6, set_attr6, &ret_attr);\n\n\t\tif (ret6 != H_SUCCESS) {\n\t\t\tnetdev_err(dev, \"unable to change IPv6 checksum \"\n\t\t\t\t\t\"offload settings. %d rc=%ld\\n\",\n\t\t\t\t\tdata, ret6);\n\n\t\t\th_illan_attributes(adapter->vdev->unit_address,\n\t\t\t\t\t   set_attr6, clr_attr6, &ret_attr);\n\n\t\t\tif (data == 1)\n\t\t\t\tdev->features &= ~NETIF_F_IPV6_CSUM;\n\n\t\t} else\n\t\t\tadapter->fw_ipv6_csum_support = data;\n\n\t\tif (ret4 == H_SUCCESS || ret6 == H_SUCCESS)\n\t\t\tadapter->rx_csum = data;\n\t\telse\n\t\t\trc1 = -EIO;\n\t} else {\n\t\trc1 = -EIO;\n\t\tnetdev_err(dev, \"unable to change checksum offload settings.\"\n\t\t\t\t     \" %d rc=%ld ret_attr=%lx\\n\", data, ret,\n\t\t\t\t     ret_attr);\n\t}\n\n\tif (restart)\n\t\trc2 = ibmveth_open(dev);\n\n\treturn rc1 ? rc1 : rc2;\n}\n\nstatic int ibmveth_set_tso(struct net_device *dev, u32 data)\n{\n\tstruct ibmveth_adapter *adapter = netdev_priv(dev);\n\tunsigned long set_attr, clr_attr, ret_attr;\n\tlong ret1, ret2;\n\tint rc1 = 0, rc2 = 0;\n\tint restart = 0;\n\n\tif (netif_running(dev)) {\n\t\trestart = 1;\n\t\tibmveth_close(dev);\n\t}\n\n\tset_attr = 0;\n\tclr_attr = 0;\n\n\tif (data)\n\t\tset_attr = IBMVETH_ILLAN_LRG_SR_ENABLED;\n\telse\n\t\tclr_attr = IBMVETH_ILLAN_LRG_SR_ENABLED;\n\n\tret1 = h_illan_attributes(adapter->vdev->unit_address, 0, 0, &ret_attr);\n\n\tif (ret1 == H_SUCCESS && (ret_attr & IBMVETH_ILLAN_LRG_SND_SUPPORT) &&\n\t    !old_large_send) {\n\t\tret2 = h_illan_attributes(adapter->vdev->unit_address, clr_attr,\n\t\t\t\t\t  set_attr, &ret_attr);\n\n\t\tif (ret2 != H_SUCCESS) {\n\t\t\tnetdev_err(dev, \"unable to change tso settings. %d rc=%ld\\n\",\n\t\t\t\t   data, ret2);\n\n\t\t\th_illan_attributes(adapter->vdev->unit_address,\n\t\t\t\t\t   set_attr, clr_attr, &ret_attr);\n\n\t\t\tif (data == 1)\n\t\t\t\tdev->features &= ~(NETIF_F_TSO | NETIF_F_TSO6);\n\t\t\trc1 = -EIO;\n\n\t\t} else {\n\t\t\tadapter->fw_large_send_support = data;\n\t\t\tadapter->large_send = data;\n\t\t}\n\t} else {\n\t\t \n\t\tif (data == 1) {\n\t\t\tdev->features &= ~NETIF_F_TSO6;\n\t\t\tnetdev_info(dev, \"TSO feature requires all partitions to have updated driver\");\n\t\t}\n\t\tadapter->large_send = data;\n\t}\n\n\tif (restart)\n\t\trc2 = ibmveth_open(dev);\n\n\treturn rc1 ? rc1 : rc2;\n}\n\nstatic int ibmveth_set_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\tstruct ibmveth_adapter *adapter = netdev_priv(dev);\n\tint rx_csum = !!(features & NETIF_F_RXCSUM);\n\tint large_send = !!(features & (NETIF_F_TSO | NETIF_F_TSO6));\n\tint rc1 = 0, rc2 = 0;\n\n\tif (rx_csum != adapter->rx_csum) {\n\t\trc1 = ibmveth_set_csum_offload(dev, rx_csum);\n\t\tif (rc1 && !adapter->rx_csum)\n\t\t\tdev->features =\n\t\t\t\tfeatures & ~(NETIF_F_CSUM_MASK |\n\t\t\t\t\t     NETIF_F_RXCSUM);\n\t}\n\n\tif (large_send != adapter->large_send) {\n\t\trc2 = ibmveth_set_tso(dev, large_send);\n\t\tif (rc2 && !adapter->large_send)\n\t\t\tdev->features =\n\t\t\t\tfeatures & ~(NETIF_F_TSO | NETIF_F_TSO6);\n\t}\n\n\treturn rc1 ? rc1 : rc2;\n}\n\nstatic void ibmveth_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tint i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(ibmveth_stats); i++, data += ETH_GSTRING_LEN)\n\t\tmemcpy(data, ibmveth_stats[i].name, ETH_GSTRING_LEN);\n}\n\nstatic int ibmveth_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(ibmveth_stats);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void ibmveth_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t      struct ethtool_stats *stats, u64 *data)\n{\n\tint i;\n\tstruct ibmveth_adapter *adapter = netdev_priv(dev);\n\n\tfor (i = 0; i < ARRAY_SIZE(ibmveth_stats); i++)\n\t\tdata[i] = IBMVETH_GET_STAT(adapter, ibmveth_stats[i].offset);\n}\n\nstatic void ibmveth_get_channels(struct net_device *netdev,\n\t\t\t\t struct ethtool_channels *channels)\n{\n\tchannels->max_tx = ibmveth_real_max_tx_queues();\n\tchannels->tx_count = netdev->real_num_tx_queues;\n\n\tchannels->max_rx = netdev->real_num_rx_queues;\n\tchannels->rx_count = netdev->real_num_rx_queues;\n}\n\nstatic int ibmveth_set_channels(struct net_device *netdev,\n\t\t\t\tstruct ethtool_channels *channels)\n{\n\tstruct ibmveth_adapter *adapter = netdev_priv(netdev);\n\tunsigned int old = netdev->real_num_tx_queues,\n\t\t     goal = channels->tx_count;\n\tint rc, i;\n\n\t \n\tif (!(netdev->flags & IFF_UP))\n\t\treturn netif_set_real_num_tx_queues(netdev, goal);\n\n\t \n\tnetif_tx_stop_all_queues(netdev);\n\n\t \n\tfor (i = old; i < goal; i++) {\n\t\tif (adapter->tx_ltb_ptr[i])\n\t\t\tcontinue;\n\n\t\trc = ibmveth_allocate_tx_ltb(adapter, i);\n\t\tif (!rc)\n\t\t\tcontinue;\n\n\t\t \n\t\tnetdev_err(netdev, \"Failed to allocate more tx queues, returning to %d queues\\n\",\n\t\t\t   old);\n\t\tgoal = old;\n\t\told = i;\n\t\tbreak;\n\t}\n\trc = netif_set_real_num_tx_queues(netdev, goal);\n\tif (rc) {\n\t\tnetdev_err(netdev, \"Failed to set real tx queues, returning to %d queues\\n\",\n\t\t\t   old);\n\t\tgoal = old;\n\t\told = i;\n\t}\n\t \n\tfor (i = old; i > goal; i--) {\n\t\tif (adapter->tx_ltb_ptr[i - 1])\n\t\t\tibmveth_free_tx_ltb(adapter, i - 1);\n\t}\n\n\tnetif_tx_wake_all_queues(netdev);\n\n\treturn rc;\n}\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.get_drvinfo\t\t         = netdev_get_drvinfo,\n\t.get_link\t\t         = ethtool_op_get_link,\n\t.get_strings\t\t         = ibmveth_get_strings,\n\t.get_sset_count\t\t         = ibmveth_get_sset_count,\n\t.get_ethtool_stats\t         = ibmveth_get_ethtool_stats,\n\t.get_link_ksettings\t         = ibmveth_get_link_ksettings,\n\t.set_link_ksettings              = ibmveth_set_link_ksettings,\n\t.get_channels\t\t\t = ibmveth_get_channels,\n\t.set_channels\t\t\t = ibmveth_set_channels\n};\n\nstatic int ibmveth_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ibmveth_send(struct ibmveth_adapter *adapter,\n\t\t\tunsigned long desc, unsigned long mss)\n{\n\tunsigned long correlator;\n\tunsigned int retry_count;\n\tunsigned long ret;\n\n\t \n\tretry_count = 1024;\n\tcorrelator = 0;\n\tdo {\n\t\tret = h_send_logical_lan(adapter->vdev->unit_address, desc,\n\t\t\t\t\t correlator, &correlator, mss,\n\t\t\t\t\t adapter->fw_large_send_support);\n\t} while ((ret == H_BUSY) && (retry_count--));\n\n\tif (ret != H_SUCCESS && ret != H_DROPPED) {\n\t\tnetdev_err(adapter->netdev, \"tx: h_send_logical_lan failed \"\n\t\t\t   \"with rc=%ld\\n\", ret);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ibmveth_is_packet_unsupported(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *netdev)\n{\n\tstruct ethhdr *ether_header;\n\tint ret = 0;\n\n\tether_header = eth_hdr(skb);\n\n\tif (ether_addr_equal(ether_header->h_dest, netdev->dev_addr)) {\n\t\tnetdev_dbg(netdev, \"veth doesn't support loopback packets, dropping packet.\\n\");\n\t\tnetdev->stats.tx_dropped++;\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic netdev_tx_t ibmveth_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *netdev)\n{\n\tstruct ibmveth_adapter *adapter = netdev_priv(netdev);\n\tunsigned int desc_flags, total_bytes;\n\tunion ibmveth_buf_desc desc;\n\tint i, queue_num = skb_get_queue_mapping(skb);\n\tunsigned long mss = 0;\n\n\tif (ibmveth_is_packet_unsupported(skb, netdev))\n\t\tgoto out;\n\t \n\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t    ((skb->protocol == htons(ETH_P_IP) &&\n\t      ip_hdr(skb)->protocol != IPPROTO_TCP) ||\n\t     (skb->protocol == htons(ETH_P_IPV6) &&\n\t      ipv6_hdr(skb)->nexthdr != IPPROTO_TCP)) &&\n\t    skb_checksum_help(skb)) {\n\n\t\tnetdev_err(netdev, \"tx: failed to checksum packet\\n\");\n\t\tnetdev->stats.tx_dropped++;\n\t\tgoto out;\n\t}\n\n\tdesc_flags = IBMVETH_BUF_VALID;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tunsigned char *buf = skb_transport_header(skb) +\n\t\t\t\t\t\tskb->csum_offset;\n\n\t\tdesc_flags |= (IBMVETH_BUF_NO_CSUM | IBMVETH_BUF_CSUM_GOOD);\n\n\t\t \n\t\tbuf[0] = 0;\n\t\tbuf[1] = 0;\n\n\t\tif (skb_is_gso(skb) && adapter->fw_large_send_support)\n\t\t\tdesc_flags |= IBMVETH_BUF_LRG_SND;\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL && skb_is_gso(skb)) {\n\t\tif (adapter->fw_large_send_support) {\n\t\t\tmss = (unsigned long)skb_shinfo(skb)->gso_size;\n\t\t\tadapter->tx_large_packets++;\n\t\t} else if (!skb_is_gso_v6(skb)) {\n\t\t\t \n\t\t\tip_hdr(skb)->check = 0xffff;\n\t\t\ttcp_hdr(skb)->check =\n\t\t\t\tcpu_to_be16(skb_shinfo(skb)->gso_size);\n\t\t\tadapter->tx_large_packets++;\n\t\t}\n\t}\n\n\t \n\tif (unlikely(skb->len > adapter->tx_ltb_size)) {\n\t\tnetdev_err(adapter->netdev, \"tx: packet size (%u) exceeds ltb (%u)\\n\",\n\t\t\t   skb->len, adapter->tx_ltb_size);\n\t\tnetdev->stats.tx_dropped++;\n\t\tgoto out;\n\t}\n\tmemcpy(adapter->tx_ltb_ptr[queue_num], skb->data, skb_headlen(skb));\n\ttotal_bytes = skb_headlen(skb);\n\t \n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tmemcpy(adapter->tx_ltb_ptr[queue_num] + total_bytes,\n\t\t       skb_frag_address_safe(frag), skb_frag_size(frag));\n\t\ttotal_bytes += skb_frag_size(frag);\n\t}\n\n\tif (unlikely(total_bytes != skb->len)) {\n\t\tnetdev_err(adapter->netdev, \"tx: incorrect packet len copied into ltb (%u != %u)\\n\",\n\t\t\t   skb->len, total_bytes);\n\t\tnetdev->stats.tx_dropped++;\n\t\tgoto out;\n\t}\n\tdesc.fields.flags_len = desc_flags | skb->len;\n\tdesc.fields.address = adapter->tx_ltb_dma[queue_num];\n\t \n\tdma_wmb();\n\n\tif (ibmveth_send(adapter, desc.desc, mss)) {\n\t\tadapter->tx_send_failed++;\n\t\tnetdev->stats.tx_dropped++;\n\t} else {\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += skb->len;\n\t}\n\nout:\n\tdev_consume_skb_any(skb);\n\treturn NETDEV_TX_OK;\n\n\n}\n\nstatic void ibmveth_rx_mss_helper(struct sk_buff *skb, u16 mss, int lrg_pkt)\n{\n\tstruct tcphdr *tcph;\n\tint offset = 0;\n\tint hdr_len;\n\n\t \n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tstruct iphdr *iph = (struct iphdr *)skb->data;\n\n\t\tif (iph->protocol == IPPROTO_TCP) {\n\t\t\toffset = iph->ihl * 4;\n\t\t\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tstruct ipv6hdr *iph6 = (struct ipv6hdr *)skb->data;\n\n\t\tif (iph6->nexthdr == IPPROTO_TCP) {\n\t\t\toffset = sizeof(struct ipv6hdr);\n\t\t\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV6;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n\t \n\ttcph = (struct tcphdr *)(skb->data + offset);\n\tif (lrg_pkt) {\n\t\tskb_shinfo(skb)->gso_size = mss;\n\t} else if (offset) {\n\t\tskb_shinfo(skb)->gso_size = ntohs(tcph->check);\n\t\ttcph->check = 0;\n\t}\n\n\tif (skb_shinfo(skb)->gso_size) {\n\t\thdr_len = offset + tcph->doff * 4;\n\t\tskb_shinfo(skb)->gso_segs =\n\t\t\t\tDIV_ROUND_UP(skb->len - hdr_len,\n\t\t\t\t\t     skb_shinfo(skb)->gso_size);\n\t}\n}\n\nstatic void ibmveth_rx_csum_helper(struct sk_buff *skb,\n\t\t\t\t   struct ibmveth_adapter *adapter)\n{\n\tstruct iphdr *iph = NULL;\n\tstruct ipv6hdr *iph6 = NULL;\n\t__be16 skb_proto = 0;\n\tu16 iphlen = 0;\n\tu16 iph_proto = 0;\n\tu16 tcphdrlen = 0;\n\n\tskb_proto = be16_to_cpu(skb->protocol);\n\n\tif (skb_proto == ETH_P_IP) {\n\t\tiph = (struct iphdr *)skb->data;\n\n\t\t \n\t\tif (iph->check == 0xffff) {\n\t\t\tiph->check = 0;\n\t\t\tiph->check = ip_fast_csum((unsigned char *)iph,\n\t\t\t\t\t\t  iph->ihl);\n\t\t}\n\n\t\tiphlen = iph->ihl * 4;\n\t\tiph_proto = iph->protocol;\n\t} else if (skb_proto == ETH_P_IPV6) {\n\t\tiph6 = (struct ipv6hdr *)skb->data;\n\t\tiphlen = sizeof(struct ipv6hdr);\n\t\tiph_proto = iph6->nexthdr;\n\t}\n\n\t \n\n\tif (iph_proto == IPPROTO_TCP) {\n\t\tstruct tcphdr *tcph = (struct tcphdr *)(skb->data + iphlen);\n\n\t\tif (tcph->check == 0x0000) {\n\t\t\t \n\t\t\ttcphdrlen = skb->len - iphlen;\n\t\t\tif (skb_proto == ETH_P_IP)\n\t\t\t\ttcph->check =\n\t\t\t\t ~csum_tcpudp_magic(iph->saddr,\n\t\t\t\tiph->daddr, tcphdrlen, iph_proto, 0);\n\t\t\telse if (skb_proto == ETH_P_IPV6)\n\t\t\t\ttcph->check =\n\t\t\t\t ~csum_ipv6_magic(&iph6->saddr,\n\t\t\t\t&iph6->daddr, tcphdrlen, iph_proto, 0);\n\t\t\t \n\t\t\tskb_partial_csum_set(skb, iphlen,\n\t\t\t\t\t     offsetof(struct tcphdr, check));\n\t\t\tskb_reset_network_header(skb);\n\t\t}\n\t}\n}\n\nstatic int ibmveth_poll(struct napi_struct *napi, int budget)\n{\n\tstruct ibmveth_adapter *adapter =\n\t\t\tcontainer_of(napi, struct ibmveth_adapter, napi);\n\tstruct net_device *netdev = adapter->netdev;\n\tint frames_processed = 0;\n\tunsigned long lpar_rc;\n\tu16 mss = 0;\n\n\twhile (frames_processed < budget) {\n\t\tif (!ibmveth_rxq_pending_buffer(adapter))\n\t\t\tbreak;\n\n\t\tsmp_rmb();\n\t\tif (!ibmveth_rxq_buffer_valid(adapter)) {\n\t\t\twmb();  \n\t\t\tadapter->rx_invalid_buffer++;\n\t\t\tnetdev_dbg(netdev, \"recycling invalid buffer\\n\");\n\t\t\tibmveth_rxq_recycle_buffer(adapter);\n\t\t} else {\n\t\t\tstruct sk_buff *skb, *new_skb;\n\t\t\tint length = ibmveth_rxq_frame_length(adapter);\n\t\t\tint offset = ibmveth_rxq_frame_offset(adapter);\n\t\t\tint csum_good = ibmveth_rxq_csum_good(adapter);\n\t\t\tint lrg_pkt = ibmveth_rxq_large_packet(adapter);\n\t\t\t__sum16 iph_check = 0;\n\n\t\t\tskb = ibmveth_rxq_get_buffer(adapter);\n\n\t\t\t \n\t\t\tif (lrg_pkt) {\n\t\t\t\t__be64 *rxmss = (__be64 *)(skb->data + 8);\n\n\t\t\t\tmss = (u16)be64_to_cpu(*rxmss);\n\t\t\t}\n\n\t\t\tnew_skb = NULL;\n\t\t\tif (length < rx_copybreak)\n\t\t\t\tnew_skb = netdev_alloc_skb(netdev, length);\n\n\t\t\tif (new_skb) {\n\t\t\t\tskb_copy_to_linear_data(new_skb,\n\t\t\t\t\t\t\tskb->data + offset,\n\t\t\t\t\t\t\tlength);\n\t\t\t\tif (rx_flush)\n\t\t\t\t\tibmveth_flush_buffer(skb->data,\n\t\t\t\t\t\tlength + offset);\n\t\t\t\tif (!ibmveth_rxq_recycle_buffer(adapter))\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t\tskb = new_skb;\n\t\t\t} else {\n\t\t\t\tibmveth_rxq_harvest_buffer(adapter);\n\t\t\t\tskb_reserve(skb, offset);\n\t\t\t}\n\n\t\t\tskb_put(skb, length);\n\t\t\tskb->protocol = eth_type_trans(skb, netdev);\n\n\t\t\t \n\t\t\tif (skb->protocol == cpu_to_be16(ETH_P_IP)) {\n\t\t\t\tstruct iphdr *iph = (struct iphdr *)skb->data;\n\n\t\t\t\tiph_check = iph->check;\n\t\t\t}\n\n\t\t\tif ((length > netdev->mtu + ETH_HLEN) ||\n\t\t\t    lrg_pkt || iph_check == 0xffff) {\n\t\t\t\tibmveth_rx_mss_helper(skb, mss, lrg_pkt);\n\t\t\t\tadapter->rx_large_packets++;\n\t\t\t}\n\n\t\t\tif (csum_good) {\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t\tibmveth_rx_csum_helper(skb, adapter);\n\t\t\t}\n\n\t\t\tnapi_gro_receive(napi, skb);\t \n\n\t\t\tnetdev->stats.rx_packets++;\n\t\t\tnetdev->stats.rx_bytes += length;\n\t\t\tframes_processed++;\n\t\t}\n\t}\n\n\tibmveth_replenish_task(adapter);\n\n\tif (frames_processed < budget) {\n\t\tnapi_complete_done(napi, frames_processed);\n\n\t\t \n\t\tlpar_rc = h_vio_signal(adapter->vdev->unit_address,\n\t\t\t\t       VIO_IRQ_ENABLE);\n\n\t\tBUG_ON(lpar_rc != H_SUCCESS);\n\n\t\tif (ibmveth_rxq_pending_buffer(adapter) &&\n\t\t    napi_reschedule(napi)) {\n\t\t\tlpar_rc = h_vio_signal(adapter->vdev->unit_address,\n\t\t\t\t\t       VIO_IRQ_DISABLE);\n\t\t}\n\t}\n\n\treturn frames_processed;\n}\n\nstatic irqreturn_t ibmveth_interrupt(int irq, void *dev_instance)\n{\n\tstruct net_device *netdev = dev_instance;\n\tstruct ibmveth_adapter *adapter = netdev_priv(netdev);\n\tunsigned long lpar_rc;\n\n\tif (napi_schedule_prep(&adapter->napi)) {\n\t\tlpar_rc = h_vio_signal(adapter->vdev->unit_address,\n\t\t\t\t       VIO_IRQ_DISABLE);\n\t\tBUG_ON(lpar_rc != H_SUCCESS);\n\t\t__napi_schedule(&adapter->napi);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void ibmveth_set_multicast_list(struct net_device *netdev)\n{\n\tstruct ibmveth_adapter *adapter = netdev_priv(netdev);\n\tunsigned long lpar_rc;\n\n\tif ((netdev->flags & IFF_PROMISC) ||\n\t    (netdev_mc_count(netdev) > adapter->mcastFilterSize)) {\n\t\tlpar_rc = h_multicast_ctrl(adapter->vdev->unit_address,\n\t\t\t\t\t   IbmVethMcastEnableRecv |\n\t\t\t\t\t   IbmVethMcastDisableFiltering,\n\t\t\t\t\t   0);\n\t\tif (lpar_rc != H_SUCCESS) {\n\t\t\tnetdev_err(netdev, \"h_multicast_ctrl rc=%ld when \"\n\t\t\t\t   \"entering promisc mode\\n\", lpar_rc);\n\t\t}\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\t\t \n\t\tlpar_rc = h_multicast_ctrl(adapter->vdev->unit_address,\n\t\t\t\t\t   IbmVethMcastEnableRecv |\n\t\t\t\t\t   IbmVethMcastDisableFiltering |\n\t\t\t\t\t   IbmVethMcastClearFilterTable,\n\t\t\t\t\t   0);\n\t\tif (lpar_rc != H_SUCCESS) {\n\t\t\tnetdev_err(netdev, \"h_multicast_ctrl rc=%ld when \"\n\t\t\t\t   \"attempting to clear filter table\\n\",\n\t\t\t\t   lpar_rc);\n\t\t}\n\t\t \n\t\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\t\t \n\t\t\tu64 mcast_addr;\n\t\t\tmcast_addr = ether_addr_to_u64(ha->addr);\n\t\t\tlpar_rc = h_multicast_ctrl(adapter->vdev->unit_address,\n\t\t\t\t\t\t   IbmVethMcastAddFilter,\n\t\t\t\t\t\t   mcast_addr);\n\t\t\tif (lpar_rc != H_SUCCESS) {\n\t\t\t\tnetdev_err(netdev, \"h_multicast_ctrl rc=%ld \"\n\t\t\t\t\t   \"when adding an entry to the filter \"\n\t\t\t\t\t   \"table\\n\", lpar_rc);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tlpar_rc = h_multicast_ctrl(adapter->vdev->unit_address,\n\t\t\t\t\t   IbmVethMcastEnableFiltering,\n\t\t\t\t\t   0);\n\t\tif (lpar_rc != H_SUCCESS) {\n\t\t\tnetdev_err(netdev, \"h_multicast_ctrl rc=%ld when \"\n\t\t\t\t   \"enabling filtering\\n\", lpar_rc);\n\t\t}\n\t}\n}\n\nstatic int ibmveth_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct ibmveth_adapter *adapter = netdev_priv(dev);\n\tstruct vio_dev *viodev = adapter->vdev;\n\tint new_mtu_oh = new_mtu + IBMVETH_BUFF_OH;\n\tint i, rc;\n\tint need_restart = 0;\n\n\tfor (i = 0; i < IBMVETH_NUM_BUFF_POOLS; i++)\n\t\tif (new_mtu_oh <= adapter->rx_buff_pool[i].buff_size)\n\t\t\tbreak;\n\n\tif (i == IBMVETH_NUM_BUFF_POOLS)\n\t\treturn -EINVAL;\n\n\t \n\tif (netif_running(adapter->netdev)) {\n\t\tneed_restart = 1;\n\t\tibmveth_close(adapter->netdev);\n\t}\n\n\t \n\tfor (i = 0; i < IBMVETH_NUM_BUFF_POOLS; i++) {\n\t\tadapter->rx_buff_pool[i].active = 1;\n\n\t\tif (new_mtu_oh <= adapter->rx_buff_pool[i].buff_size) {\n\t\t\tdev->mtu = new_mtu;\n\t\t\tvio_cmo_set_dev_desired(viodev,\n\t\t\t\t\t\tibmveth_get_desired_dma\n\t\t\t\t\t\t(viodev));\n\t\t\tif (need_restart) {\n\t\t\t\treturn ibmveth_open(adapter->netdev);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (need_restart && (rc = ibmveth_open(adapter->netdev)))\n\t\treturn rc;\n\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void ibmveth_poll_controller(struct net_device *dev)\n{\n\tibmveth_replenish_task(netdev_priv(dev));\n\tibmveth_interrupt(dev->irq, dev);\n}\n#endif\n\n \nstatic unsigned long ibmveth_get_desired_dma(struct vio_dev *vdev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(&vdev->dev);\n\tstruct ibmveth_adapter *adapter;\n\tstruct iommu_table *tbl;\n\tunsigned long ret;\n\tint i;\n\tint rxqentries = 1;\n\n\ttbl = get_iommu_table_base(&vdev->dev);\n\n\t \n\tif (netdev == NULL)\n\t\treturn IOMMU_PAGE_ALIGN(IBMVETH_IO_ENTITLEMENT_DEFAULT, tbl);\n\n\tadapter = netdev_priv(netdev);\n\n\tret = IBMVETH_BUFF_LIST_SIZE + IBMVETH_FILT_LIST_SIZE;\n\tret += IOMMU_PAGE_ALIGN(netdev->mtu, tbl);\n\t \n\tret += IOMMU_PAGE_ALIGN(IBMVETH_MAX_TX_BUF_SIZE, tbl);\n\n\tfor (i = 0; i < IBMVETH_NUM_BUFF_POOLS; i++) {\n\t\t \n\t\tif (adapter->rx_buff_pool[i].active)\n\t\t\tret +=\n\t\t\t    adapter->rx_buff_pool[i].size *\n\t\t\t    IOMMU_PAGE_ALIGN(adapter->rx_buff_pool[i].\n\t\t\t\t\t     buff_size, tbl);\n\t\trxqentries += adapter->rx_buff_pool[i].size;\n\t}\n\t \n\tret += IOMMU_PAGE_ALIGN(\n\t\trxqentries * sizeof(struct ibmveth_rx_q_entry), tbl);\n\n\treturn ret;\n}\n\nstatic int ibmveth_set_mac_addr(struct net_device *dev, void *p)\n{\n\tstruct ibmveth_adapter *adapter = netdev_priv(dev);\n\tstruct sockaddr *addr = p;\n\tu64 mac_address;\n\tint rc;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tmac_address = ether_addr_to_u64(addr->sa_data);\n\trc = h_change_logical_lan_mac(adapter->vdev->unit_address, mac_address);\n\tif (rc) {\n\t\tnetdev_err(adapter->netdev, \"h_change_logical_lan_mac failed with rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ibmveth_netdev_ops = {\n\t.ndo_open\t\t= ibmveth_open,\n\t.ndo_stop\t\t= ibmveth_close,\n\t.ndo_start_xmit\t\t= ibmveth_start_xmit,\n\t.ndo_set_rx_mode\t= ibmveth_set_multicast_list,\n\t.ndo_eth_ioctl\t\t= ibmveth_ioctl,\n\t.ndo_change_mtu\t\t= ibmveth_change_mtu,\n\t.ndo_fix_features\t= ibmveth_fix_features,\n\t.ndo_set_features\t= ibmveth_set_features,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address    = ibmveth_set_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= ibmveth_poll_controller,\n#endif\n};\n\nstatic int ibmveth_probe(struct vio_dev *dev, const struct vio_device_id *id)\n{\n\tint rc, i, mac_len;\n\tstruct net_device *netdev;\n\tstruct ibmveth_adapter *adapter;\n\tunsigned char *mac_addr_p;\n\t__be32 *mcastFilterSize_p;\n\tlong ret;\n\tunsigned long ret_attr;\n\n\tdev_dbg(&dev->dev, \"entering ibmveth_probe for UA 0x%x\\n\",\n\t\tdev->unit_address);\n\n\tmac_addr_p = (unsigned char *)vio_get_attribute(dev, VETH_MAC_ADDR,\n\t\t\t\t\t\t\t&mac_len);\n\tif (!mac_addr_p) {\n\t\tdev_err(&dev->dev, \"Can't find VETH_MAC_ADDR attribute\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (mac_len == 8)\n\t\tmac_addr_p += 2;\n\telse if (mac_len != 6) {\n\t\tdev_err(&dev->dev, \"VETH_MAC_ADDR attribute wrong len %d\\n\",\n\t\t\tmac_len);\n\t\treturn -EINVAL;\n\t}\n\n\tmcastFilterSize_p = (__be32 *)vio_get_attribute(dev,\n\t\t\t\t\t\t\tVETH_MCAST_FILTER_SIZE,\n\t\t\t\t\t\t\tNULL);\n\tif (!mcastFilterSize_p) {\n\t\tdev_err(&dev->dev, \"Can't find VETH_MCAST_FILTER_SIZE \"\n\t\t\t\"attribute\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnetdev = alloc_etherdev_mqs(sizeof(struct ibmveth_adapter), IBMVETH_MAX_QUEUES, 1);\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tadapter = netdev_priv(netdev);\n\tdev_set_drvdata(&dev->dev, netdev);\n\n\tadapter->vdev = dev;\n\tadapter->netdev = netdev;\n\tadapter->mcastFilterSize = be32_to_cpu(*mcastFilterSize_p);\n\tibmveth_init_link_settings(netdev);\n\n\tnetif_napi_add_weight(netdev, &adapter->napi, ibmveth_poll, 16);\n\n\tnetdev->irq = dev->irq;\n\tnetdev->netdev_ops = &ibmveth_netdev_ops;\n\tnetdev->ethtool_ops = &netdev_ethtool_ops;\n\tSET_NETDEV_DEV(netdev, &dev->dev);\n\tnetdev->hw_features = NETIF_F_SG;\n\tif (vio_get_attribute(dev, \"ibm,illan-options\", NULL) != NULL) {\n\t\tnetdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\n\t\t\t\t       NETIF_F_RXCSUM;\n\t}\n\n\tnetdev->features |= netdev->hw_features;\n\n\tret = h_illan_attributes(adapter->vdev->unit_address, 0, 0, &ret_attr);\n\n\t \n\tif (ret == H_SUCCESS && (ret_attr & IBMVETH_ILLAN_LRG_SND_SUPPORT) &&\n\t    !old_large_send) {\n\t\tnetdev->hw_features |= NETIF_F_TSO | NETIF_F_TSO6;\n\t\tnetdev->features |= netdev->hw_features;\n\t} else {\n\t\tnetdev->hw_features |= NETIF_F_TSO;\n\t}\n\n\tadapter->is_active_trunk = false;\n\tif (ret == H_SUCCESS && (ret_attr & IBMVETH_ILLAN_ACTIVE_TRUNK)) {\n\t\tadapter->is_active_trunk = true;\n\t\tnetdev->hw_features |= NETIF_F_FRAGLIST;\n\t\tnetdev->features |= NETIF_F_FRAGLIST;\n\t}\n\n\tnetdev->min_mtu = IBMVETH_MIN_MTU;\n\tnetdev->max_mtu = ETH_MAX_MTU - IBMVETH_BUFF_OH;\n\n\teth_hw_addr_set(netdev, mac_addr_p);\n\n\tif (firmware_has_feature(FW_FEATURE_CMO))\n\t\tmemcpy(pool_count, pool_count_cmo, sizeof(pool_count));\n\n\tfor (i = 0; i < IBMVETH_NUM_BUFF_POOLS; i++) {\n\t\tstruct kobject *kobj = &adapter->rx_buff_pool[i].kobj;\n\t\tint error;\n\n\t\tibmveth_init_buffer_pool(&adapter->rx_buff_pool[i], i,\n\t\t\t\t\t pool_count[i], pool_size[i],\n\t\t\t\t\t pool_active[i]);\n\t\terror = kobject_init_and_add(kobj, &ktype_veth_pool,\n\t\t\t\t\t     &dev->dev.kobj, \"pool%d\", i);\n\t\tif (!error)\n\t\t\tkobject_uevent(kobj, KOBJ_ADD);\n\t}\n\n\trc = netif_set_real_num_tx_queues(netdev, min(num_online_cpus(),\n\t\t\t\t\t\t      IBMVETH_DEFAULT_QUEUES));\n\tif (rc) {\n\t\tnetdev_dbg(netdev, \"failed to set number of tx queues rc=%d\\n\",\n\t\t\t   rc);\n\t\tfree_netdev(netdev);\n\t\treturn rc;\n\t}\n\tadapter->tx_ltb_size = PAGE_ALIGN(IBMVETH_MAX_TX_BUF_SIZE);\n\tfor (i = 0; i < IBMVETH_MAX_QUEUES; i++)\n\t\tadapter->tx_ltb_ptr[i] = NULL;\n\n\tnetdev_dbg(netdev, \"adapter @ 0x%p\\n\", adapter);\n\tnetdev_dbg(netdev, \"registering netdev...\\n\");\n\n\tibmveth_set_features(netdev, netdev->features);\n\n\trc = register_netdev(netdev);\n\n\tif (rc) {\n\t\tnetdev_dbg(netdev, \"failed to register netdev rc=%d\\n\", rc);\n\t\tfree_netdev(netdev);\n\t\treturn rc;\n\t}\n\n\tnetdev_dbg(netdev, \"registered\\n\");\n\n\treturn 0;\n}\n\nstatic void ibmveth_remove(struct vio_dev *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(&dev->dev);\n\tstruct ibmveth_adapter *adapter = netdev_priv(netdev);\n\tint i;\n\n\tfor (i = 0; i < IBMVETH_NUM_BUFF_POOLS; i++)\n\t\tkobject_put(&adapter->rx_buff_pool[i].kobj);\n\n\tunregister_netdev(netdev);\n\n\tfree_netdev(netdev);\n\tdev_set_drvdata(&dev->dev, NULL);\n}\n\nstatic struct attribute veth_active_attr;\nstatic struct attribute veth_num_attr;\nstatic struct attribute veth_size_attr;\n\nstatic ssize_t veth_pool_show(struct kobject *kobj,\n\t\t\t      struct attribute *attr, char *buf)\n{\n\tstruct ibmveth_buff_pool *pool = container_of(kobj,\n\t\t\t\t\t\t      struct ibmveth_buff_pool,\n\t\t\t\t\t\t      kobj);\n\n\tif (attr == &veth_active_attr)\n\t\treturn sprintf(buf, \"%d\\n\", pool->active);\n\telse if (attr == &veth_num_attr)\n\t\treturn sprintf(buf, \"%d\\n\", pool->size);\n\telse if (attr == &veth_size_attr)\n\t\treturn sprintf(buf, \"%d\\n\", pool->buff_size);\n\treturn 0;\n}\n\nstatic ssize_t veth_pool_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct ibmveth_buff_pool *pool = container_of(kobj,\n\t\t\t\t\t\t      struct ibmveth_buff_pool,\n\t\t\t\t\t\t      kobj);\n\tstruct net_device *netdev = dev_get_drvdata(kobj_to_dev(kobj->parent));\n\tstruct ibmveth_adapter *adapter = netdev_priv(netdev);\n\tlong value = simple_strtol(buf, NULL, 10);\n\tlong rc;\n\n\tif (attr == &veth_active_attr) {\n\t\tif (value && !pool->active) {\n\t\t\tif (netif_running(netdev)) {\n\t\t\t\tif (ibmveth_alloc_buffer_pool(pool)) {\n\t\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t\t   \"unable to alloc pool\\n\");\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t\tpool->active = 1;\n\t\t\t\tibmveth_close(netdev);\n\t\t\t\tif ((rc = ibmveth_open(netdev)))\n\t\t\t\t\treturn rc;\n\t\t\t} else {\n\t\t\t\tpool->active = 1;\n\t\t\t}\n\t\t} else if (!value && pool->active) {\n\t\t\tint mtu = netdev->mtu + IBMVETH_BUFF_OH;\n\t\t\tint i;\n\t\t\t \n\t\t\tfor (i = 0; i < IBMVETH_NUM_BUFF_POOLS; i++) {\n\t\t\t\tif (pool == &adapter->rx_buff_pool[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!adapter->rx_buff_pool[i].active)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (mtu <= adapter->rx_buff_pool[i].buff_size)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == IBMVETH_NUM_BUFF_POOLS) {\n\t\t\t\tnetdev_err(netdev, \"no active pool >= MTU\\n\");\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\n\t\t\tif (netif_running(netdev)) {\n\t\t\t\tibmveth_close(netdev);\n\t\t\t\tpool->active = 0;\n\t\t\t\tif ((rc = ibmveth_open(netdev)))\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tpool->active = 0;\n\t\t}\n\t} else if (attr == &veth_num_attr) {\n\t\tif (value <= 0 || value > IBMVETH_MAX_POOL_COUNT) {\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (netif_running(netdev)) {\n\t\t\t\tibmveth_close(netdev);\n\t\t\t\tpool->size = value;\n\t\t\t\tif ((rc = ibmveth_open(netdev)))\n\t\t\t\t\treturn rc;\n\t\t\t} else {\n\t\t\t\tpool->size = value;\n\t\t\t}\n\t\t}\n\t} else if (attr == &veth_size_attr) {\n\t\tif (value <= IBMVETH_BUFF_OH || value > IBMVETH_MAX_BUF_SIZE) {\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (netif_running(netdev)) {\n\t\t\t\tibmveth_close(netdev);\n\t\t\t\tpool->buff_size = value;\n\t\t\t\tif ((rc = ibmveth_open(netdev)))\n\t\t\t\t\treturn rc;\n\t\t\t} else {\n\t\t\t\tpool->buff_size = value;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tibmveth_interrupt(netdev->irq, netdev);\n\treturn count;\n}\n\n\n#define ATTR(_name, _mode)\t\t\t\t\\\n\tstruct attribute veth_##_name##_attr = {\t\\\n\t.name = __stringify(_name), .mode = _mode,\t\\\n\t};\n\nstatic ATTR(active, 0644);\nstatic ATTR(num, 0644);\nstatic ATTR(size, 0644);\n\nstatic struct attribute *veth_pool_attrs[] = {\n\t&veth_active_attr,\n\t&veth_num_attr,\n\t&veth_size_attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(veth_pool);\n\nstatic const struct sysfs_ops veth_pool_ops = {\n\t.show   = veth_pool_show,\n\t.store  = veth_pool_store,\n};\n\nstatic struct kobj_type ktype_veth_pool = {\n\t.release        = NULL,\n\t.sysfs_ops      = &veth_pool_ops,\n\t.default_groups = veth_pool_groups,\n};\n\nstatic int ibmveth_resume(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tibmveth_interrupt(netdev->irq, netdev);\n\treturn 0;\n}\n\nstatic const struct vio_device_id ibmveth_device_table[] = {\n\t{ \"network\", \"IBM,l-lan\"},\n\t{ \"\", \"\" }\n};\nMODULE_DEVICE_TABLE(vio, ibmveth_device_table);\n\nstatic const struct dev_pm_ops ibmveth_pm_ops = {\n\t.resume = ibmveth_resume\n};\n\nstatic struct vio_driver ibmveth_driver = {\n\t.id_table\t= ibmveth_device_table,\n\t.probe\t\t= ibmveth_probe,\n\t.remove\t\t= ibmveth_remove,\n\t.get_desired_dma = ibmveth_get_desired_dma,\n\t.name\t\t= ibmveth_driver_name,\n\t.pm\t\t= &ibmveth_pm_ops,\n};\n\nstatic int __init ibmveth_module_init(void)\n{\n\tprintk(KERN_DEBUG \"%s: %s %s\\n\", ibmveth_driver_name,\n\t       ibmveth_driver_string, ibmveth_driver_version);\n\n\treturn vio_register_driver(&ibmveth_driver);\n}\n\nstatic void __exit ibmveth_module_exit(void)\n{\n\tvio_unregister_driver(&ibmveth_driver);\n}\n\nmodule_init(ibmveth_module_init);\nmodule_exit(ibmveth_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}