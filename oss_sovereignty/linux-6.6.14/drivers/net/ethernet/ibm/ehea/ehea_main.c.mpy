{
  "module_name": "ehea_main.c",
  "hash_id": "c6e5166cfcc1420d382f2f18de07cc332f06645c7b814862cf86ee42f5d6ccbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ibm/ehea/ehea_main.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/device.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/if.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/if_ether.h>\n#include <linux/notifier.h>\n#include <linux/reboot.h>\n#include <linux/memory.h>\n#include <asm/kexec.h>\n#include <linux/mutex.h>\n#include <linux/prefetch.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n\n#include <net/ip.h>\n\n#include \"ehea.h\"\n#include \"ehea_qmr.h\"\n#include \"ehea_phyp.h\"\n\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Christoph Raisch <raisch@de.ibm.com>\");\nMODULE_DESCRIPTION(\"IBM eServer HEA Driver\");\nMODULE_VERSION(DRV_VERSION);\n\n\nstatic int msg_level = -1;\nstatic int rq1_entries = EHEA_DEF_ENTRIES_RQ1;\nstatic int rq2_entries = EHEA_DEF_ENTRIES_RQ2;\nstatic int rq3_entries = EHEA_DEF_ENTRIES_RQ3;\nstatic int sq_entries = EHEA_DEF_ENTRIES_SQ;\nstatic int use_mcs = 1;\nstatic int prop_carrier_state;\n\nmodule_param(msg_level, int, 0);\nmodule_param(rq1_entries, int, 0);\nmodule_param(rq2_entries, int, 0);\nmodule_param(rq3_entries, int, 0);\nmodule_param(sq_entries, int, 0);\nmodule_param(prop_carrier_state, int, 0);\nmodule_param(use_mcs, int, 0);\n\nMODULE_PARM_DESC(msg_level, \"msg_level\");\nMODULE_PARM_DESC(prop_carrier_state, \"Propagate carrier state of physical \"\n\t\t \"port to stack. 1:yes, 0:no.  Default = 0 \");\nMODULE_PARM_DESC(rq3_entries, \"Number of entries for Receive Queue 3 \"\n\t\t \"[2^x - 1], x = [7..14]. Default = \"\n\t\t __MODULE_STRING(EHEA_DEF_ENTRIES_RQ3) \")\");\nMODULE_PARM_DESC(rq2_entries, \"Number of entries for Receive Queue 2 \"\n\t\t \"[2^x - 1], x = [7..14]. Default = \"\n\t\t __MODULE_STRING(EHEA_DEF_ENTRIES_RQ2) \")\");\nMODULE_PARM_DESC(rq1_entries, \"Number of entries for Receive Queue 1 \"\n\t\t \"[2^x - 1], x = [7..14]. Default = \"\n\t\t __MODULE_STRING(EHEA_DEF_ENTRIES_RQ1) \")\");\nMODULE_PARM_DESC(sq_entries, \" Number of entries for the Send Queue  \"\n\t\t \"[2^x - 1], x = [7..14]. Default = \"\n\t\t __MODULE_STRING(EHEA_DEF_ENTRIES_SQ) \")\");\nMODULE_PARM_DESC(use_mcs, \" Multiple receive queues, 1: enable, 0: disable, \"\n\t\t \"Default = 1\");\n\nstatic int port_name_cnt;\nstatic LIST_HEAD(adapter_list);\nstatic unsigned long ehea_driver_flags;\nstatic DEFINE_MUTEX(dlpar_mem_lock);\nstatic struct ehea_fw_handle_array ehea_fw_handles;\nstatic struct ehea_bcmc_reg_array ehea_bcmc_regs;\n\n\nstatic int ehea_probe_adapter(struct platform_device *dev);\n\nstatic int ehea_remove(struct platform_device *dev);\n\nstatic const struct of_device_id ehea_module_device_table[] = {\n\t{\n\t\t.name = \"lhea\",\n\t\t.compatible = \"IBM,lhea\",\n\t},\n\t{\n\t\t.type = \"network\",\n\t\t.compatible = \"IBM,lhea-ethernet\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ehea_module_device_table);\n\nstatic const struct of_device_id ehea_device_table[] = {\n\t{\n\t\t.name = \"lhea\",\n\t\t.compatible = \"IBM,lhea\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ehea_device_table);\n\nstatic struct platform_driver ehea_driver = {\n\t.driver = {\n\t\t.name = \"ehea\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = ehea_device_table,\n\t},\n\t.probe = ehea_probe_adapter,\n\t.remove = ehea_remove,\n};\n\nvoid ehea_dump(void *adr, int len, char *msg)\n{\n\tint x;\n\tunsigned char *deb = adr;\n\tfor (x = 0; x < len; x += 16) {\n\t\tpr_info(\"%s adr=%p ofs=%04x %016llx %016llx\\n\",\n\t\t\tmsg, deb, x, *((u64 *)&deb[0]), *((u64 *)&deb[8]));\n\t\tdeb += 16;\n\t}\n}\n\nstatic void ehea_schedule_port_reset(struct ehea_port *port)\n{\n\tif (!test_bit(__EHEA_DISABLE_PORT_RESET, &port->flags))\n\t\tschedule_work(&port->reset_task);\n}\n\nstatic void ehea_update_firmware_handles(void)\n{\n\tstruct ehea_fw_handle_entry *arr = NULL;\n\tstruct ehea_adapter *adapter;\n\tint num_adapters = 0;\n\tint num_ports = 0;\n\tint num_portres = 0;\n\tint i = 0;\n\tint num_fw_handles, k, l;\n\n\t \n\tmutex_lock(&ehea_fw_handles.lock);\n\n\tlist_for_each_entry(adapter, &adapter_list, list) {\n\t\tnum_adapters++;\n\n\t\tfor (k = 0; k < EHEA_MAX_PORTS; k++) {\n\t\t\tstruct ehea_port *port = adapter->port[k];\n\n\t\t\tif (!port || (port->state != EHEA_PORT_UP))\n\t\t\t\tcontinue;\n\n\t\t\tnum_ports++;\n\t\t\tnum_portres += port->num_def_qps;\n\t\t}\n\t}\n\n\tnum_fw_handles = num_adapters * EHEA_NUM_ADAPTER_FW_HANDLES +\n\t\t\t num_ports * EHEA_NUM_PORT_FW_HANDLES +\n\t\t\t num_portres * EHEA_NUM_PORTRES_FW_HANDLES;\n\n\tif (num_fw_handles) {\n\t\tarr = kcalloc(num_fw_handles, sizeof(*arr), GFP_KERNEL);\n\t\tif (!arr)\n\t\t\tgoto out;   \n\t} else\n\t\tgoto out_update;\n\n\tlist_for_each_entry(adapter, &adapter_list, list) {\n\t\tif (num_adapters == 0)\n\t\t\tbreak;\n\n\t\tfor (k = 0; k < EHEA_MAX_PORTS; k++) {\n\t\t\tstruct ehea_port *port = adapter->port[k];\n\n\t\t\tif (!port || (port->state != EHEA_PORT_UP) ||\n\t\t\t    (num_ports == 0))\n\t\t\t\tcontinue;\n\n\t\t\tfor (l = 0; l < port->num_def_qps; l++) {\n\t\t\t\tstruct ehea_port_res *pr = &port->port_res[l];\n\n\t\t\t\tarr[i].adh = adapter->handle;\n\t\t\t\tarr[i++].fwh = pr->qp->fw_handle;\n\t\t\t\tarr[i].adh = adapter->handle;\n\t\t\t\tarr[i++].fwh = pr->send_cq->fw_handle;\n\t\t\t\tarr[i].adh = adapter->handle;\n\t\t\t\tarr[i++].fwh = pr->recv_cq->fw_handle;\n\t\t\t\tarr[i].adh = adapter->handle;\n\t\t\t\tarr[i++].fwh = pr->eq->fw_handle;\n\t\t\t\tarr[i].adh = adapter->handle;\n\t\t\t\tarr[i++].fwh = pr->send_mr.handle;\n\t\t\t\tarr[i].adh = adapter->handle;\n\t\t\t\tarr[i++].fwh = pr->recv_mr.handle;\n\t\t\t}\n\t\t\tarr[i].adh = adapter->handle;\n\t\t\tarr[i++].fwh = port->qp_eq->fw_handle;\n\t\t\tnum_ports--;\n\t\t}\n\n\t\tarr[i].adh = adapter->handle;\n\t\tarr[i++].fwh = adapter->neq->fw_handle;\n\n\t\tif (adapter->mr.handle) {\n\t\t\tarr[i].adh = adapter->handle;\n\t\t\tarr[i++].fwh = adapter->mr.handle;\n\t\t}\n\t\tnum_adapters--;\n\t}\n\nout_update:\n\tkfree(ehea_fw_handles.arr);\n\tehea_fw_handles.arr = arr;\n\tehea_fw_handles.num_entries = i;\nout:\n\tmutex_unlock(&ehea_fw_handles.lock);\n}\n\nstatic void ehea_update_bcmc_registrations(void)\n{\n\tunsigned long flags;\n\tstruct ehea_bcmc_reg_entry *arr = NULL;\n\tstruct ehea_adapter *adapter;\n\tstruct ehea_mc_list *mc_entry;\n\tint num_registrations = 0;\n\tint i = 0;\n\tint k;\n\n\tspin_lock_irqsave(&ehea_bcmc_regs.lock, flags);\n\n\t \n\tlist_for_each_entry(adapter, &adapter_list, list)\n\t\tfor (k = 0; k < EHEA_MAX_PORTS; k++) {\n\t\t\tstruct ehea_port *port = adapter->port[k];\n\n\t\t\tif (!port || (port->state != EHEA_PORT_UP))\n\t\t\t\tcontinue;\n\n\t\t\tnum_registrations += 2;\t \n\n\t\t\tlist_for_each_entry(mc_entry, &port->mc_list->list,list)\n\t\t\t\tnum_registrations += 2;\n\t\t}\n\n\tif (num_registrations) {\n\t\tarr = kcalloc(num_registrations, sizeof(*arr), GFP_ATOMIC);\n\t\tif (!arr)\n\t\t\tgoto out;   \n\t} else\n\t\tgoto out_update;\n\n\tlist_for_each_entry(adapter, &adapter_list, list) {\n\t\tfor (k = 0; k < EHEA_MAX_PORTS; k++) {\n\t\t\tstruct ehea_port *port = adapter->port[k];\n\n\t\t\tif (!port || (port->state != EHEA_PORT_UP))\n\t\t\t\tcontinue;\n\n\t\t\tif (num_registrations == 0)\n\t\t\t\tgoto out_update;\n\n\t\t\tarr[i].adh = adapter->handle;\n\t\t\tarr[i].port_id = port->logical_port_id;\n\t\t\tarr[i].reg_type = EHEA_BCMC_BROADCAST |\n\t\t\t\t\t  EHEA_BCMC_UNTAGGED;\n\t\t\tarr[i++].macaddr = port->mac_addr;\n\n\t\t\tarr[i].adh = adapter->handle;\n\t\t\tarr[i].port_id = port->logical_port_id;\n\t\t\tarr[i].reg_type = EHEA_BCMC_BROADCAST |\n\t\t\t\t\t  EHEA_BCMC_VLANID_ALL;\n\t\t\tarr[i++].macaddr = port->mac_addr;\n\t\t\tnum_registrations -= 2;\n\n\t\t\tlist_for_each_entry(mc_entry,\n\t\t\t\t\t    &port->mc_list->list, list) {\n\t\t\t\tif (num_registrations == 0)\n\t\t\t\t\tgoto out_update;\n\n\t\t\t\tarr[i].adh = adapter->handle;\n\t\t\t\tarr[i].port_id = port->logical_port_id;\n\t\t\t\tarr[i].reg_type = EHEA_BCMC_MULTICAST |\n\t\t\t\t\t\t  EHEA_BCMC_UNTAGGED;\n\t\t\t\tif (mc_entry->macaddr == 0)\n\t\t\t\t\tarr[i].reg_type |= EHEA_BCMC_SCOPE_ALL;\n\t\t\t\tarr[i++].macaddr = mc_entry->macaddr;\n\n\t\t\t\tarr[i].adh = adapter->handle;\n\t\t\t\tarr[i].port_id = port->logical_port_id;\n\t\t\t\tarr[i].reg_type = EHEA_BCMC_MULTICAST |\n\t\t\t\t\t\t  EHEA_BCMC_VLANID_ALL;\n\t\t\t\tif (mc_entry->macaddr == 0)\n\t\t\t\t\tarr[i].reg_type |= EHEA_BCMC_SCOPE_ALL;\n\t\t\t\tarr[i++].macaddr = mc_entry->macaddr;\n\t\t\t\tnum_registrations -= 2;\n\t\t\t}\n\t\t}\n\t}\n\nout_update:\n\tkfree(ehea_bcmc_regs.arr);\n\tehea_bcmc_regs.arr = arr;\n\tehea_bcmc_regs.num_entries = i;\nout:\n\tspin_unlock_irqrestore(&ehea_bcmc_regs.lock, flags);\n}\n\nstatic void ehea_get_stats64(struct net_device *dev,\n\t\t\t     struct rtnl_link_stats64 *stats)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tu64 rx_packets = 0, tx_packets = 0, rx_bytes = 0, tx_bytes = 0;\n\tint i;\n\n\tfor (i = 0; i < port->num_def_qps; i++) {\n\t\trx_packets += port->port_res[i].rx_packets;\n\t\trx_bytes   += port->port_res[i].rx_bytes;\n\t}\n\n\tfor (i = 0; i < port->num_def_qps; i++) {\n\t\ttx_packets += port->port_res[i].tx_packets;\n\t\ttx_bytes   += port->port_res[i].tx_bytes;\n\t}\n\n\tstats->tx_packets = tx_packets;\n\tstats->rx_bytes = rx_bytes;\n\tstats->tx_bytes = tx_bytes;\n\tstats->rx_packets = rx_packets;\n\n\tstats->multicast = port->stats.multicast;\n\tstats->rx_errors = port->stats.rx_errors;\n}\n\nstatic void ehea_update_stats(struct work_struct *work)\n{\n\tstruct ehea_port *port =\n\t\tcontainer_of(work, struct ehea_port, stats_work.work);\n\tstruct net_device *dev = port->netdev;\n\tstruct rtnl_link_stats64 *stats = &port->stats;\n\tstruct hcp_ehea_port_cb2 *cb2;\n\tu64 hret;\n\n\tcb2 = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!cb2) {\n\t\tnetdev_err(dev, \"No mem for cb2. Some interface statistics were not updated\\n\");\n\t\tgoto resched;\n\t}\n\n\thret = ehea_h_query_ehea_port(port->adapter->handle,\n\t\t\t\t      port->logical_port_id,\n\t\t\t\t      H_PORT_CB2, H_PORT_CB2_ALL, cb2);\n\tif (hret != H_SUCCESS) {\n\t\tnetdev_err(dev, \"query_ehea_port failed\\n\");\n\t\tgoto out_herr;\n\t}\n\n\tif (netif_msg_hw(port))\n\t\tehea_dump(cb2, sizeof(*cb2), \"net_device_stats\");\n\n\tstats->multicast = cb2->rxmcp;\n\tstats->rx_errors = cb2->rxuerr;\n\nout_herr:\n\tfree_page((unsigned long)cb2);\nresched:\n\tschedule_delayed_work(&port->stats_work,\n\t\t\t      round_jiffies_relative(msecs_to_jiffies(1000)));\n}\n\nstatic void ehea_refill_rq1(struct ehea_port_res *pr, int index, int nr_of_wqes)\n{\n\tstruct sk_buff **skb_arr_rq1 = pr->rq1_skba.arr;\n\tstruct net_device *dev = pr->port->netdev;\n\tint max_index_mask = pr->rq1_skba.len - 1;\n\tint fill_wqes = pr->rq1_skba.os_skbs + nr_of_wqes;\n\tint adder = 0;\n\tint i;\n\n\tpr->rq1_skba.os_skbs = 0;\n\n\tif (unlikely(test_bit(__EHEA_STOP_XFER, &ehea_driver_flags))) {\n\t\tif (nr_of_wqes > 0)\n\t\t\tpr->rq1_skba.index = index;\n\t\tpr->rq1_skba.os_skbs = fill_wqes;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < fill_wqes; i++) {\n\t\tif (!skb_arr_rq1[index]) {\n\t\t\tskb_arr_rq1[index] = netdev_alloc_skb(dev,\n\t\t\t\t\t\t\t      EHEA_L_PKT_SIZE);\n\t\t\tif (!skb_arr_rq1[index]) {\n\t\t\t\tpr->rq1_skba.os_skbs = fill_wqes - i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tindex--;\n\t\tindex &= max_index_mask;\n\t\tadder++;\n\t}\n\n\tif (adder == 0)\n\t\treturn;\n\n\t \n\tehea_update_rq1a(pr->qp, adder);\n}\n\nstatic void ehea_init_fill_rq1(struct ehea_port_res *pr, int nr_rq1a)\n{\n\tstruct sk_buff **skb_arr_rq1 = pr->rq1_skba.arr;\n\tstruct net_device *dev = pr->port->netdev;\n\tint i;\n\n\tif (nr_rq1a > pr->rq1_skba.len) {\n\t\tnetdev_err(dev, \"NR_RQ1A bigger than skb array len\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nr_rq1a; i++) {\n\t\tskb_arr_rq1[i] = netdev_alloc_skb(dev, EHEA_L_PKT_SIZE);\n\t\tif (!skb_arr_rq1[i])\n\t\t\tbreak;\n\t}\n\t \n\tehea_update_rq1a(pr->qp, i - 1);\n}\n\nstatic int ehea_refill_rq_def(struct ehea_port_res *pr,\n\t\t\t      struct ehea_q_skb_arr *q_skba, int rq_nr,\n\t\t\t      int num_wqes, int wqe_type, int packet_size)\n{\n\tstruct net_device *dev = pr->port->netdev;\n\tstruct ehea_qp *qp = pr->qp;\n\tstruct sk_buff **skb_arr = q_skba->arr;\n\tstruct ehea_rwqe *rwqe;\n\tint i, index, max_index_mask, fill_wqes;\n\tint adder = 0;\n\tint ret = 0;\n\n\tfill_wqes = q_skba->os_skbs + num_wqes;\n\tq_skba->os_skbs = 0;\n\n\tif (unlikely(test_bit(__EHEA_STOP_XFER, &ehea_driver_flags))) {\n\t\tq_skba->os_skbs = fill_wqes;\n\t\treturn ret;\n\t}\n\n\tindex = q_skba->index;\n\tmax_index_mask = q_skba->len - 1;\n\tfor (i = 0; i < fill_wqes; i++) {\n\t\tu64 tmp_addr;\n\t\tstruct sk_buff *skb;\n\n\t\tskb = netdev_alloc_skb_ip_align(dev, packet_size);\n\t\tif (!skb) {\n\t\t\tq_skba->os_skbs = fill_wqes - i;\n\t\t\tif (q_skba->os_skbs == q_skba->len - 2) {\n\t\t\t\tnetdev_info(pr->port->netdev,\n\t\t\t\t\t    \"rq%i ran dry - no mem for skb\\n\",\n\t\t\t\t\t    rq_nr);\n\t\t\t\tret = -ENOMEM;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tskb_arr[index] = skb;\n\t\ttmp_addr = ehea_map_vaddr(skb->data);\n\t\tif (tmp_addr == -1) {\n\t\t\tdev_consume_skb_any(skb);\n\t\t\tq_skba->os_skbs = fill_wqes - i;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\trwqe = ehea_get_next_rwqe(qp, rq_nr);\n\t\trwqe->wr_id = EHEA_BMASK_SET(EHEA_WR_ID_TYPE, wqe_type)\n\t\t\t    | EHEA_BMASK_SET(EHEA_WR_ID_INDEX, index);\n\t\trwqe->sg_list[0].l_key = pr->recv_mr.lkey;\n\t\trwqe->sg_list[0].vaddr = tmp_addr;\n\t\trwqe->sg_list[0].len = packet_size;\n\t\trwqe->data_segments = 1;\n\n\t\tindex++;\n\t\tindex &= max_index_mask;\n\t\tadder++;\n\t}\n\n\tq_skba->index = index;\n\tif (adder == 0)\n\t\tgoto out;\n\n\t \n\tiosync();\n\tif (rq_nr == 2)\n\t\tehea_update_rq2a(pr->qp, adder);\n\telse\n\t\tehea_update_rq3a(pr->qp, adder);\nout:\n\treturn ret;\n}\n\n\nstatic int ehea_refill_rq2(struct ehea_port_res *pr, int nr_of_wqes)\n{\n\treturn ehea_refill_rq_def(pr, &pr->rq2_skba, 2,\n\t\t\t\t  nr_of_wqes, EHEA_RWQE2_TYPE,\n\t\t\t\t  EHEA_RQ2_PKT_SIZE);\n}\n\n\nstatic int ehea_refill_rq3(struct ehea_port_res *pr, int nr_of_wqes)\n{\n\treturn ehea_refill_rq_def(pr, &pr->rq3_skba, 3,\n\t\t\t\t  nr_of_wqes, EHEA_RWQE3_TYPE,\n\t\t\t\t  EHEA_MAX_PACKET_SIZE);\n}\n\nstatic inline int ehea_check_cqe(struct ehea_cqe *cqe, int *rq_num)\n{\n\t*rq_num = (cqe->type & EHEA_CQE_TYPE_RQ) >> 5;\n\tif ((cqe->status & EHEA_CQE_STAT_ERR_MASK) == 0)\n\t\treturn 0;\n\tif (((cqe->status & EHEA_CQE_STAT_ERR_TCP) != 0) &&\n\t    (cqe->header_length == 0))\n\t\treturn 0;\n\treturn -EINVAL;\n}\n\nstatic inline void ehea_fill_skb(struct net_device *dev,\n\t\t\t\t struct sk_buff *skb, struct ehea_cqe *cqe,\n\t\t\t\t struct ehea_port_res *pr)\n{\n\tint length = cqe->num_bytes_transfered - 4;\t \n\n\tskb_put(skb, length);\n\tskb->protocol = eth_type_trans(skb, dev);\n\n\t \n\tif (cqe->status & EHEA_CQE_BLIND_CKSUM) {\n\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\t\tskb->csum = csum_unfold(~cqe->inet_checksum_value);\n\t} else\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tskb_record_rx_queue(skb, pr - &pr->port->port_res[0]);\n}\n\nstatic inline struct sk_buff *get_skb_by_index(struct sk_buff **skb_array,\n\t\t\t\t\t       int arr_len,\n\t\t\t\t\t       struct ehea_cqe *cqe)\n{\n\tint skb_index = EHEA_BMASK_GET(EHEA_WR_ID_INDEX, cqe->wr_id);\n\tstruct sk_buff *skb;\n\tvoid *pref;\n\tint x;\n\n\tx = skb_index + 1;\n\tx &= (arr_len - 1);\n\n\tpref = skb_array[x];\n\tif (pref) {\n\t\tprefetchw(pref);\n\t\tprefetchw(pref + EHEA_CACHE_LINE);\n\n\t\tpref = (skb_array[x]->data);\n\t\tprefetch(pref);\n\t\tprefetch(pref + EHEA_CACHE_LINE);\n\t\tprefetch(pref + EHEA_CACHE_LINE * 2);\n\t\tprefetch(pref + EHEA_CACHE_LINE * 3);\n\t}\n\n\tskb = skb_array[skb_index];\n\tskb_array[skb_index] = NULL;\n\treturn skb;\n}\n\nstatic inline struct sk_buff *get_skb_by_index_ll(struct sk_buff **skb_array,\n\t\t\t\t\t\t  int arr_len, int wqe_index)\n{\n\tstruct sk_buff *skb;\n\tvoid *pref;\n\tint x;\n\n\tx = wqe_index + 1;\n\tx &= (arr_len - 1);\n\n\tpref = skb_array[x];\n\tif (pref) {\n\t\tprefetchw(pref);\n\t\tprefetchw(pref + EHEA_CACHE_LINE);\n\n\t\tpref = (skb_array[x]->data);\n\t\tprefetchw(pref);\n\t\tprefetchw(pref + EHEA_CACHE_LINE);\n\t}\n\n\tskb = skb_array[wqe_index];\n\tskb_array[wqe_index] = NULL;\n\treturn skb;\n}\n\nstatic int ehea_treat_poll_error(struct ehea_port_res *pr, int rq,\n\t\t\t\t struct ehea_cqe *cqe, int *processed_rq2,\n\t\t\t\t int *processed_rq3)\n{\n\tstruct sk_buff *skb;\n\n\tif (cqe->status & EHEA_CQE_STAT_ERR_TCP)\n\t\tpr->p_stats.err_tcp_cksum++;\n\tif (cqe->status & EHEA_CQE_STAT_ERR_IP)\n\t\tpr->p_stats.err_ip_cksum++;\n\tif (cqe->status & EHEA_CQE_STAT_ERR_CRC)\n\t\tpr->p_stats.err_frame_crc++;\n\n\tif (rq == 2) {\n\t\t*processed_rq2 += 1;\n\t\tskb = get_skb_by_index(pr->rq2_skba.arr, pr->rq2_skba.len, cqe);\n\t\tdev_kfree_skb(skb);\n\t} else if (rq == 3) {\n\t\t*processed_rq3 += 1;\n\t\tskb = get_skb_by_index(pr->rq3_skba.arr, pr->rq3_skba.len, cqe);\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tif (cqe->status & EHEA_CQE_STAT_FAT_ERR_MASK) {\n\t\tif (netif_msg_rx_err(pr->port)) {\n\t\t\tpr_err(\"Critical receive error for QP %d. Resetting port.\\n\",\n\t\t\t       pr->qp->init_attr.qp_nr);\n\t\t\tehea_dump(cqe, sizeof(*cqe), \"CQE\");\n\t\t}\n\t\tehea_schedule_port_reset(pr->port);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ehea_proc_rwqes(struct net_device *dev,\n\t\t\t   struct ehea_port_res *pr,\n\t\t\t   int budget)\n{\n\tstruct ehea_port *port = pr->port;\n\tstruct ehea_qp *qp = pr->qp;\n\tstruct ehea_cqe *cqe;\n\tstruct sk_buff *skb;\n\tstruct sk_buff **skb_arr_rq1 = pr->rq1_skba.arr;\n\tstruct sk_buff **skb_arr_rq2 = pr->rq2_skba.arr;\n\tstruct sk_buff **skb_arr_rq3 = pr->rq3_skba.arr;\n\tint skb_arr_rq1_len = pr->rq1_skba.len;\n\tint skb_arr_rq2_len = pr->rq2_skba.len;\n\tint skb_arr_rq3_len = pr->rq3_skba.len;\n\tint processed, processed_rq1, processed_rq2, processed_rq3;\n\tu64 processed_bytes = 0;\n\tint wqe_index, last_wqe_index, rq, port_reset;\n\n\tprocessed = processed_rq1 = processed_rq2 = processed_rq3 = 0;\n\tlast_wqe_index = 0;\n\n\tcqe = ehea_poll_rq1(qp, &wqe_index);\n\twhile ((processed < budget) && cqe) {\n\t\tehea_inc_rq1(qp);\n\t\tprocessed_rq1++;\n\t\tprocessed++;\n\t\tif (netif_msg_rx_status(port))\n\t\t\tehea_dump(cqe, sizeof(*cqe), \"CQE\");\n\n\t\tlast_wqe_index = wqe_index;\n\t\trmb();\n\t\tif (!ehea_check_cqe(cqe, &rq)) {\n\t\t\tif (rq == 1) {\n\t\t\t\t \n\t\t\t\tskb = get_skb_by_index_ll(skb_arr_rq1,\n\t\t\t\t\t\t\t  skb_arr_rq1_len,\n\t\t\t\t\t\t\t  wqe_index);\n\t\t\t\tif (unlikely(!skb)) {\n\t\t\t\t\tnetif_info(port, rx_err, dev,\n\t\t\t\t\t\t  \"LL rq1: skb=NULL\\n\");\n\n\t\t\t\t\tskb = netdev_alloc_skb(dev,\n\t\t\t\t\t\t\t       EHEA_L_PKT_SIZE);\n\t\t\t\t\tif (!skb)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tskb_copy_to_linear_data(skb, ((char *)cqe) + 64,\n\t\t\t\t\t\t cqe->num_bytes_transfered - 4);\n\t\t\t\tehea_fill_skb(dev, skb, cqe, pr);\n\t\t\t} else if (rq == 2) {\n\t\t\t\t \n\t\t\t\tskb = get_skb_by_index(skb_arr_rq2,\n\t\t\t\t\t\t       skb_arr_rq2_len, cqe);\n\t\t\t\tif (unlikely(!skb)) {\n\t\t\t\t\tnetif_err(port, rx_err, dev,\n\t\t\t\t\t\t  \"rq2: skb=NULL\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tehea_fill_skb(dev, skb, cqe, pr);\n\t\t\t\tprocessed_rq2++;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tskb = get_skb_by_index(skb_arr_rq3,\n\t\t\t\t\t\t       skb_arr_rq3_len, cqe);\n\t\t\t\tif (unlikely(!skb)) {\n\t\t\t\t\tnetif_err(port, rx_err, dev,\n\t\t\t\t\t\t  \"rq3: skb=NULL\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tehea_fill_skb(dev, skb, cqe, pr);\n\t\t\t\tprocessed_rq3++;\n\t\t\t}\n\n\t\t\tprocessed_bytes += skb->len;\n\n\t\t\tif (cqe->status & EHEA_CQE_VLAN_TAG_XTRACT)\n\t\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\n\t\t\t\t\t\t       cqe->vlan_tag);\n\n\t\t\tnapi_gro_receive(&pr->napi, skb);\n\t\t} else {\n\t\t\tpr->p_stats.poll_receive_errors++;\n\t\t\tport_reset = ehea_treat_poll_error(pr, rq, cqe,\n\t\t\t\t\t\t\t   &processed_rq2,\n\t\t\t\t\t\t\t   &processed_rq3);\n\t\t\tif (port_reset)\n\t\t\t\tbreak;\n\t\t}\n\t\tcqe = ehea_poll_rq1(qp, &wqe_index);\n\t}\n\n\tpr->rx_packets += processed;\n\tpr->rx_bytes += processed_bytes;\n\n\tehea_refill_rq1(pr, last_wqe_index, processed_rq1);\n\tehea_refill_rq2(pr, processed_rq2);\n\tehea_refill_rq3(pr, processed_rq3);\n\n\treturn processed;\n}\n\n#define SWQE_RESTART_CHECK 0xdeadbeaff00d0000ull\n\nstatic void reset_sq_restart_flag(struct ehea_port *port)\n{\n\tint i;\n\n\tfor (i = 0; i < port->num_def_qps; i++) {\n\t\tstruct ehea_port_res *pr = &port->port_res[i];\n\t\tpr->sq_restart_flag = 0;\n\t}\n\twake_up(&port->restart_wq);\n}\n\nstatic void check_sqs(struct ehea_port *port)\n{\n\tstruct ehea_swqe *swqe;\n\tint swqe_index;\n\tint i;\n\n\tfor (i = 0; i < port->num_def_qps; i++) {\n\t\tstruct ehea_port_res *pr = &port->port_res[i];\n\t\tint ret;\n\t\tswqe = ehea_get_swqe(pr->qp, &swqe_index);\n\t\tmemset(swqe, 0, SWQE_HEADER_SIZE);\n\t\tatomic_dec(&pr->swqe_avail);\n\n\t\tswqe->tx_control |= EHEA_SWQE_PURGE;\n\t\tswqe->wr_id = SWQE_RESTART_CHECK;\n\t\tswqe->tx_control |= EHEA_SWQE_SIGNALLED_COMPLETION;\n\t\tswqe->tx_control |= EHEA_SWQE_IMM_DATA_PRESENT;\n\t\tswqe->immediate_data_length = 80;\n\n\t\tehea_post_swqe(pr->qp, swqe);\n\n\t\tret = wait_event_timeout(port->restart_wq,\n\t\t\t\t\t pr->sq_restart_flag == 0,\n\t\t\t\t\t msecs_to_jiffies(100));\n\n\t\tif (!ret) {\n\t\t\tpr_err(\"HW/SW queues out of sync\\n\");\n\t\t\tehea_schedule_port_reset(pr->port);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n\nstatic struct ehea_cqe *ehea_proc_cqes(struct ehea_port_res *pr, int my_quota)\n{\n\tstruct sk_buff *skb;\n\tstruct ehea_cq *send_cq = pr->send_cq;\n\tstruct ehea_cqe *cqe;\n\tint quota = my_quota;\n\tint cqe_counter = 0;\n\tint swqe_av = 0;\n\tint index;\n\tstruct netdev_queue *txq = netdev_get_tx_queue(pr->port->netdev,\n\t\t\t\t\t\tpr - &pr->port->port_res[0]);\n\n\tcqe = ehea_poll_cq(send_cq);\n\twhile (cqe && (quota > 0)) {\n\t\tehea_inc_cq(send_cq);\n\n\t\tcqe_counter++;\n\t\trmb();\n\n\t\tif (cqe->wr_id == SWQE_RESTART_CHECK) {\n\t\t\tpr->sq_restart_flag = 1;\n\t\t\tswqe_av++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cqe->status & EHEA_CQE_STAT_ERR_MASK) {\n\t\t\tpr_err(\"Bad send completion status=0x%04X\\n\",\n\t\t\t       cqe->status);\n\n\t\t\tif (netif_msg_tx_err(pr->port))\n\t\t\t\tehea_dump(cqe, sizeof(*cqe), \"Send CQE\");\n\n\t\t\tif (cqe->status & EHEA_CQE_STAT_RESET_MASK) {\n\t\t\t\tpr_err(\"Resetting port\\n\");\n\t\t\t\tehea_schedule_port_reset(pr->port);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (netif_msg_tx_done(pr->port))\n\t\t\tehea_dump(cqe, sizeof(*cqe), \"CQE\");\n\n\t\tif (likely(EHEA_BMASK_GET(EHEA_WR_ID_TYPE, cqe->wr_id)\n\t\t\t   == EHEA_SWQE2_TYPE)) {\n\n\t\t\tindex = EHEA_BMASK_GET(EHEA_WR_ID_INDEX, cqe->wr_id);\n\t\t\tskb = pr->sq_skba.arr[index];\n\t\t\tdev_consume_skb_any(skb);\n\t\t\tpr->sq_skba.arr[index] = NULL;\n\t\t}\n\n\t\tswqe_av += EHEA_BMASK_GET(EHEA_WR_ID_REFILL, cqe->wr_id);\n\t\tquota--;\n\n\t\tcqe = ehea_poll_cq(send_cq);\n\t}\n\n\tehea_update_feca(send_cq, cqe_counter);\n\tatomic_add(swqe_av, &pr->swqe_avail);\n\n\tif (unlikely(netif_tx_queue_stopped(txq) &&\n\t\t     (atomic_read(&pr->swqe_avail) >= pr->swqe_refill_th))) {\n\t\t__netif_tx_lock(txq, smp_processor_id());\n\t\tif (netif_tx_queue_stopped(txq) &&\n\t\t    (atomic_read(&pr->swqe_avail) >= pr->swqe_refill_th))\n\t\t\tnetif_tx_wake_queue(txq);\n\t\t__netif_tx_unlock(txq);\n\t}\n\n\twake_up(&pr->port->swqe_avail_wq);\n\n\treturn cqe;\n}\n\n#define EHEA_POLL_MAX_CQES 65535\n\nstatic int ehea_poll(struct napi_struct *napi, int budget)\n{\n\tstruct ehea_port_res *pr = container_of(napi, struct ehea_port_res,\n\t\t\t\t\t\tnapi);\n\tstruct net_device *dev = pr->port->netdev;\n\tstruct ehea_cqe *cqe;\n\tstruct ehea_cqe *cqe_skb = NULL;\n\tint wqe_index;\n\tint rx = 0;\n\n\tcqe_skb = ehea_proc_cqes(pr, EHEA_POLL_MAX_CQES);\n\trx += ehea_proc_rwqes(dev, pr, budget - rx);\n\n\twhile (rx != budget) {\n\t\tnapi_complete(napi);\n\t\tehea_reset_cq_ep(pr->recv_cq);\n\t\tehea_reset_cq_ep(pr->send_cq);\n\t\tehea_reset_cq_n1(pr->recv_cq);\n\t\tehea_reset_cq_n1(pr->send_cq);\n\t\trmb();\n\t\tcqe = ehea_poll_rq1(pr->qp, &wqe_index);\n\t\tcqe_skb = ehea_poll_cq(pr->send_cq);\n\n\t\tif (!cqe && !cqe_skb)\n\t\t\treturn rx;\n\n\t\tif (!napi_reschedule(napi))\n\t\t\treturn rx;\n\n\t\tcqe_skb = ehea_proc_cqes(pr, EHEA_POLL_MAX_CQES);\n\t\trx += ehea_proc_rwqes(dev, pr, budget - rx);\n\t}\n\n\treturn rx;\n}\n\nstatic irqreturn_t ehea_recv_irq_handler(int irq, void *param)\n{\n\tstruct ehea_port_res *pr = param;\n\n\tnapi_schedule(&pr->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ehea_qp_aff_irq_handler(int irq, void *param)\n{\n\tstruct ehea_port *port = param;\n\tstruct ehea_eqe *eqe;\n\tstruct ehea_qp *qp;\n\tu32 qp_token;\n\tu64 resource_type, aer, aerr;\n\tint reset_port = 0;\n\n\teqe = ehea_poll_eq(port->qp_eq);\n\n\twhile (eqe) {\n\t\tqp_token = EHEA_BMASK_GET(EHEA_EQE_QP_TOKEN, eqe->entry);\n\t\tpr_err(\"QP aff_err: entry=0x%llx, token=0x%x\\n\",\n\t\t       eqe->entry, qp_token);\n\n\t\tqp = port->port_res[qp_token].qp;\n\n\t\tresource_type = ehea_error_data(port->adapter, qp->fw_handle,\n\t\t\t\t\t\t&aer, &aerr);\n\n\t\tif (resource_type == EHEA_AER_RESTYPE_QP) {\n\t\t\tif ((aer & EHEA_AER_RESET_MASK) ||\n\t\t\t    (aerr & EHEA_AERR_RESET_MASK))\n\t\t\t\t reset_port = 1;\n\t\t} else\n\t\t\treset_port = 1;    \n\n\t\teqe = ehea_poll_eq(port->qp_eq);\n\t}\n\n\tif (reset_port) {\n\t\tpr_err(\"Resetting port\\n\");\n\t\tehea_schedule_port_reset(port);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct ehea_port *ehea_get_port(struct ehea_adapter *adapter,\n\t\t\t\t       int logical_port)\n{\n\tint i;\n\n\tfor (i = 0; i < EHEA_MAX_PORTS; i++)\n\t\tif (adapter->port[i])\n\t\t\tif (adapter->port[i]->logical_port_id == logical_port)\n\t\t\t\treturn adapter->port[i];\n\treturn NULL;\n}\n\nint ehea_sense_port_attr(struct ehea_port *port)\n{\n\tint ret;\n\tu64 hret;\n\tstruct hcp_ehea_port_cb0 *cb0;\n\n\t \n\tcb0 = (void *)get_zeroed_page(GFP_ATOMIC);\n\tif (!cb0) {\n\t\tpr_err(\"no mem for cb0\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\thret = ehea_h_query_ehea_port(port->adapter->handle,\n\t\t\t\t      port->logical_port_id, H_PORT_CB0,\n\t\t\t\t      EHEA_BMASK_SET(H_PORT_CB0_ALL, 0xFFFF),\n\t\t\t\t      cb0);\n\tif (hret != H_SUCCESS) {\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\n\t \n\tport->mac_addr = cb0->port_mac_addr << 16;\n\n\tif (!is_valid_ether_addr((u8 *)&port->mac_addr)) {\n\t\tret = -EADDRNOTAVAIL;\n\t\tgoto out_free;\n\t}\n\n\t \n\tswitch (cb0->port_speed) {\n\tcase H_SPEED_10M_H:\n\t\tport->port_speed = EHEA_SPEED_10M;\n\t\tport->full_duplex = 0;\n\t\tbreak;\n\tcase H_SPEED_10M_F:\n\t\tport->port_speed = EHEA_SPEED_10M;\n\t\tport->full_duplex = 1;\n\t\tbreak;\n\tcase H_SPEED_100M_H:\n\t\tport->port_speed = EHEA_SPEED_100M;\n\t\tport->full_duplex = 0;\n\t\tbreak;\n\tcase H_SPEED_100M_F:\n\t\tport->port_speed = EHEA_SPEED_100M;\n\t\tport->full_duplex = 1;\n\t\tbreak;\n\tcase H_SPEED_1G_F:\n\t\tport->port_speed = EHEA_SPEED_1G;\n\t\tport->full_duplex = 1;\n\t\tbreak;\n\tcase H_SPEED_10G_F:\n\t\tport->port_speed = EHEA_SPEED_10G;\n\t\tport->full_duplex = 1;\n\t\tbreak;\n\tdefault:\n\t\tport->port_speed = 0;\n\t\tport->full_duplex = 0;\n\t\tbreak;\n\t}\n\n\tport->autoneg = 1;\n\tport->num_mcs = cb0->num_default_qps;\n\n\t \n\tif (use_mcs)\n\t\tport->num_def_qps = cb0->num_default_qps;\n\telse\n\t\tport->num_def_qps = 1;\n\n\tif (!port->num_def_qps) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tret = 0;\nout_free:\n\tif (ret || netif_msg_probe(port))\n\t\tehea_dump(cb0, sizeof(*cb0), \"ehea_sense_port_attr\");\n\tfree_page((unsigned long)cb0);\nout:\n\treturn ret;\n}\n\nint ehea_set_portspeed(struct ehea_port *port, u32 port_speed)\n{\n\tstruct hcp_ehea_port_cb4 *cb4;\n\tu64 hret;\n\tint ret = 0;\n\n\tcb4 = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!cb4) {\n\t\tpr_err(\"no mem for cb4\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcb4->port_speed = port_speed;\n\n\tnetif_carrier_off(port->netdev);\n\n\thret = ehea_h_modify_ehea_port(port->adapter->handle,\n\t\t\t\t       port->logical_port_id,\n\t\t\t\t       H_PORT_CB4, H_PORT_CB4_SPEED, cb4);\n\tif (hret == H_SUCCESS) {\n\t\tport->autoneg = port_speed == EHEA_SPEED_AUTONEG ? 1 : 0;\n\n\t\thret = ehea_h_query_ehea_port(port->adapter->handle,\n\t\t\t\t\t      port->logical_port_id,\n\t\t\t\t\t      H_PORT_CB4, H_PORT_CB4_SPEED,\n\t\t\t\t\t      cb4);\n\t\tif (hret == H_SUCCESS) {\n\t\t\tswitch (cb4->port_speed) {\n\t\t\tcase H_SPEED_10M_H:\n\t\t\t\tport->port_speed = EHEA_SPEED_10M;\n\t\t\t\tport->full_duplex = 0;\n\t\t\t\tbreak;\n\t\t\tcase H_SPEED_10M_F:\n\t\t\t\tport->port_speed = EHEA_SPEED_10M;\n\t\t\t\tport->full_duplex = 1;\n\t\t\t\tbreak;\n\t\t\tcase H_SPEED_100M_H:\n\t\t\t\tport->port_speed = EHEA_SPEED_100M;\n\t\t\t\tport->full_duplex = 0;\n\t\t\t\tbreak;\n\t\t\tcase H_SPEED_100M_F:\n\t\t\t\tport->port_speed = EHEA_SPEED_100M;\n\t\t\t\tport->full_duplex = 1;\n\t\t\t\tbreak;\n\t\t\tcase H_SPEED_1G_F:\n\t\t\t\tport->port_speed = EHEA_SPEED_1G;\n\t\t\t\tport->full_duplex = 1;\n\t\t\t\tbreak;\n\t\t\tcase H_SPEED_10G_F:\n\t\t\t\tport->port_speed = EHEA_SPEED_10G;\n\t\t\t\tport->full_duplex = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tport->port_speed = 0;\n\t\t\t\tport->full_duplex = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tpr_err(\"Failed sensing port speed\\n\");\n\t\t\tret = -EIO;\n\t\t}\n\t} else {\n\t\tif (hret == H_AUTHORITY) {\n\t\t\tpr_info(\"Hypervisor denied setting port speed\\n\");\n\t\t\tret = -EPERM;\n\t\t} else {\n\t\t\tret = -EIO;\n\t\t\tpr_err(\"Failed setting port speed\\n\");\n\t\t}\n\t}\n\tif (!prop_carrier_state || (port->phy_link == EHEA_PHY_LINK_UP))\n\t\tnetif_carrier_on(port->netdev);\n\n\tfree_page((unsigned long)cb4);\nout:\n\treturn ret;\n}\n\nstatic void ehea_parse_eqe(struct ehea_adapter *adapter, u64 eqe)\n{\n\tint ret;\n\tu8 ec;\n\tu8 portnum;\n\tstruct ehea_port *port;\n\tstruct net_device *dev;\n\n\tec = EHEA_BMASK_GET(NEQE_EVENT_CODE, eqe);\n\tportnum = EHEA_BMASK_GET(NEQE_PORTNUM, eqe);\n\tport = ehea_get_port(adapter, portnum);\n\tif (!port) {\n\t\tnetdev_err(NULL, \"unknown portnum %x\\n\", portnum);\n\t\treturn;\n\t}\n\tdev = port->netdev;\n\n\tswitch (ec) {\n\tcase EHEA_EC_PORTSTATE_CHG:\t \n\n\t\tif (EHEA_BMASK_GET(NEQE_PORT_UP, eqe)) {\n\t\t\tif (!netif_carrier_ok(dev)) {\n\t\t\t\tret = ehea_sense_port_attr(port);\n\t\t\t\tif (ret) {\n\t\t\t\t\tnetdev_err(dev, \"failed resensing port attributes\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tnetif_info(port, link, dev,\n\t\t\t\t\t   \"Logical port up: %dMbps %s Duplex\\n\",\n\t\t\t\t\t   port->port_speed,\n\t\t\t\t\t   port->full_duplex == 1 ?\n\t\t\t\t\t   \"Full\" : \"Half\");\n\n\t\t\t\tnetif_carrier_on(dev);\n\t\t\t\tnetif_wake_queue(dev);\n\t\t\t}\n\t\t} else\n\t\t\tif (netif_carrier_ok(dev)) {\n\t\t\t\tnetif_info(port, link, dev,\n\t\t\t\t\t   \"Logical port down\\n\");\n\t\t\t\tnetif_carrier_off(dev);\n\t\t\t\tnetif_tx_disable(dev);\n\t\t\t}\n\n\t\tif (EHEA_BMASK_GET(NEQE_EXTSWITCH_PORT_UP, eqe)) {\n\t\t\tport->phy_link = EHEA_PHY_LINK_UP;\n\t\t\tnetif_info(port, link, dev,\n\t\t\t\t   \"Physical port up\\n\");\n\t\t\tif (prop_carrier_state)\n\t\t\t\tnetif_carrier_on(dev);\n\t\t} else {\n\t\t\tport->phy_link = EHEA_PHY_LINK_DOWN;\n\t\t\tnetif_info(port, link, dev,\n\t\t\t\t   \"Physical port down\\n\");\n\t\t\tif (prop_carrier_state)\n\t\t\t\tnetif_carrier_off(dev);\n\t\t}\n\n\t\tif (EHEA_BMASK_GET(NEQE_EXTSWITCH_PRIMARY, eqe))\n\t\t\tnetdev_info(dev,\n\t\t\t\t    \"External switch port is primary port\\n\");\n\t\telse\n\t\t\tnetdev_info(dev,\n\t\t\t\t    \"External switch port is backup port\\n\");\n\n\t\tbreak;\n\tcase EHEA_EC_ADAPTER_MALFUNC:\n\t\tnetdev_err(dev, \"Adapter malfunction\\n\");\n\t\tbreak;\n\tcase EHEA_EC_PORT_MALFUNC:\n\t\tnetdev_info(dev, \"Port malfunction\\n\");\n\t\tnetif_carrier_off(dev);\n\t\tnetif_tx_disable(dev);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(dev, \"unknown event code %x, eqe=0x%llX\\n\", ec, eqe);\n\t\tbreak;\n\t}\n}\n\nstatic void ehea_neq_tasklet(struct tasklet_struct *t)\n{\n\tstruct ehea_adapter *adapter = from_tasklet(adapter, t, neq_tasklet);\n\tstruct ehea_eqe *eqe;\n\tu64 event_mask;\n\n\teqe = ehea_poll_eq(adapter->neq);\n\tpr_debug(\"eqe=%p\\n\", eqe);\n\n\twhile (eqe) {\n\t\tpr_debug(\"*eqe=%lx\\n\", (unsigned long) eqe->entry);\n\t\tehea_parse_eqe(adapter, eqe->entry);\n\t\teqe = ehea_poll_eq(adapter->neq);\n\t\tpr_debug(\"next eqe=%p\\n\", eqe);\n\t}\n\n\tevent_mask = EHEA_BMASK_SET(NELR_PORTSTATE_CHG, 1)\n\t\t   | EHEA_BMASK_SET(NELR_ADAPTER_MALFUNC, 1)\n\t\t   | EHEA_BMASK_SET(NELR_PORT_MALFUNC, 1);\n\n\tehea_h_reset_events(adapter->handle,\n\t\t\t    adapter->neq->fw_handle, event_mask);\n}\n\nstatic irqreturn_t ehea_interrupt_neq(int irq, void *param)\n{\n\tstruct ehea_adapter *adapter = param;\n\ttasklet_hi_schedule(&adapter->neq_tasklet);\n\treturn IRQ_HANDLED;\n}\n\n\nstatic int ehea_fill_port_res(struct ehea_port_res *pr)\n{\n\tint ret;\n\tstruct ehea_qp_init_attr *init_attr = &pr->qp->init_attr;\n\n\tehea_init_fill_rq1(pr, pr->rq1_skba.len);\n\n\tret = ehea_refill_rq2(pr, init_attr->act_nr_rwqes_rq2 - 1);\n\n\tret |= ehea_refill_rq3(pr, init_attr->act_nr_rwqes_rq3 - 1);\n\n\treturn ret;\n}\n\nstatic int ehea_reg_interrupts(struct net_device *dev)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tstruct ehea_port_res *pr;\n\tint i, ret;\n\n\n\tsnprintf(port->int_aff_name, EHEA_IRQ_NAME_SIZE - 1, \"%s-aff\",\n\t\t dev->name);\n\n\tret = ibmebus_request_irq(port->qp_eq->attr.ist1,\n\t\t\t\t  ehea_qp_aff_irq_handler,\n\t\t\t\t  0, port->int_aff_name, port);\n\tif (ret) {\n\t\tnetdev_err(dev, \"failed registering irq for qp_aff_irq_handler:ist=%X\\n\",\n\t\t\t   port->qp_eq->attr.ist1);\n\t\tgoto out_free_qpeq;\n\t}\n\n\tnetif_info(port, ifup, dev,\n\t\t   \"irq_handle 0x%X for function qp_aff_irq_handler registered\\n\",\n\t\t   port->qp_eq->attr.ist1);\n\n\n\tfor (i = 0; i < port->num_def_qps; i++) {\n\t\tpr = &port->port_res[i];\n\t\tsnprintf(pr->int_send_name, EHEA_IRQ_NAME_SIZE - 1,\n\t\t\t \"%s-queue%d\", dev->name, i);\n\t\tret = ibmebus_request_irq(pr->eq->attr.ist1,\n\t\t\t\t\t  ehea_recv_irq_handler,\n\t\t\t\t\t  0, pr->int_send_name, pr);\n\t\tif (ret) {\n\t\t\tnetdev_err(dev, \"failed registering irq for ehea_queue port_res_nr:%d, ist=%X\\n\",\n\t\t\t\t   i, pr->eq->attr.ist1);\n\t\t\tgoto out_free_req;\n\t\t}\n\t\tnetif_info(port, ifup, dev,\n\t\t\t   \"irq_handle 0x%X for function ehea_queue_int %d registered\\n\",\n\t\t\t   pr->eq->attr.ist1, i);\n\t}\nout:\n\treturn ret;\n\n\nout_free_req:\n\twhile (--i >= 0) {\n\t\tu32 ist = port->port_res[i].eq->attr.ist1;\n\t\tibmebus_free_irq(ist, &port->port_res[i]);\n\t}\n\nout_free_qpeq:\n\tibmebus_free_irq(port->qp_eq->attr.ist1, port);\n\ti = port->num_def_qps;\n\n\tgoto out;\n\n}\n\nstatic void ehea_free_interrupts(struct net_device *dev)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tstruct ehea_port_res *pr;\n\tint i;\n\n\t \n\n\tfor (i = 0; i < port->num_def_qps; i++) {\n\t\tpr = &port->port_res[i];\n\t\tibmebus_free_irq(pr->eq->attr.ist1, pr);\n\t\tnetif_info(port, intr, dev,\n\t\t\t   \"free send irq for res %d with handle 0x%X\\n\",\n\t\t\t   i, pr->eq->attr.ist1);\n\t}\n\n\t \n\tibmebus_free_irq(port->qp_eq->attr.ist1, port);\n\tnetif_info(port, intr, dev,\n\t\t   \"associated event interrupt for handle 0x%X freed\\n\",\n\t\t   port->qp_eq->attr.ist1);\n}\n\nstatic int ehea_configure_port(struct ehea_port *port)\n{\n\tint ret, i;\n\tu64 hret, mask;\n\tstruct hcp_ehea_port_cb0 *cb0;\n\n\tret = -ENOMEM;\n\tcb0 = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!cb0)\n\t\tgoto out;\n\n\tcb0->port_rc = EHEA_BMASK_SET(PXLY_RC_VALID, 1)\n\t\t     | EHEA_BMASK_SET(PXLY_RC_IP_CHKSUM, 1)\n\t\t     | EHEA_BMASK_SET(PXLY_RC_TCP_UDP_CHKSUM, 1)\n\t\t     | EHEA_BMASK_SET(PXLY_RC_VLAN_XTRACT, 1)\n\t\t     | EHEA_BMASK_SET(PXLY_RC_VLAN_TAG_FILTER,\n\t\t\t\t      PXLY_RC_VLAN_FILTER)\n\t\t     | EHEA_BMASK_SET(PXLY_RC_JUMBO_FRAME, 1);\n\n\tfor (i = 0; i < port->num_mcs; i++)\n\t\tif (use_mcs)\n\t\t\tcb0->default_qpn_arr[i] =\n\t\t\t\tport->port_res[i].qp->init_attr.qp_nr;\n\t\telse\n\t\t\tcb0->default_qpn_arr[i] =\n\t\t\t\tport->port_res[0].qp->init_attr.qp_nr;\n\n\tif (netif_msg_ifup(port))\n\t\tehea_dump(cb0, sizeof(*cb0), \"ehea_configure_port\");\n\n\tmask = EHEA_BMASK_SET(H_PORT_CB0_PRC, 1)\n\t     | EHEA_BMASK_SET(H_PORT_CB0_DEFQPNARRAY, 1);\n\n\thret = ehea_h_modify_ehea_port(port->adapter->handle,\n\t\t\t\t       port->logical_port_id,\n\t\t\t\t       H_PORT_CB0, mask, cb0);\n\tret = -EIO;\n\tif (hret != H_SUCCESS)\n\t\tgoto out_free;\n\n\tret = 0;\n\nout_free:\n\tfree_page((unsigned long)cb0);\nout:\n\treturn ret;\n}\n\nstatic int ehea_gen_smrs(struct ehea_port_res *pr)\n{\n\tint ret;\n\tstruct ehea_adapter *adapter = pr->port->adapter;\n\n\tret = ehea_gen_smr(adapter, &adapter->mr, &pr->send_mr);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ehea_gen_smr(adapter, &adapter->mr, &pr->recv_mr);\n\tif (ret)\n\t\tgoto out_free;\n\n\treturn 0;\n\nout_free:\n\tehea_rem_mr(&pr->send_mr);\nout:\n\tpr_err(\"Generating SMRS failed\\n\");\n\treturn -EIO;\n}\n\nstatic int ehea_rem_smrs(struct ehea_port_res *pr)\n{\n\tif ((ehea_rem_mr(&pr->send_mr)) ||\n\t    (ehea_rem_mr(&pr->recv_mr)))\n\t\treturn -EIO;\n\telse\n\t\treturn 0;\n}\n\nstatic int ehea_init_q_skba(struct ehea_q_skb_arr *q_skba, int max_q_entries)\n{\n\tint arr_size = sizeof(void *) * max_q_entries;\n\n\tq_skba->arr = vzalloc(arr_size);\n\tif (!q_skba->arr)\n\t\treturn -ENOMEM;\n\n\tq_skba->len = max_q_entries;\n\tq_skba->index = 0;\n\tq_skba->os_skbs = 0;\n\n\treturn 0;\n}\n\nstatic int ehea_init_port_res(struct ehea_port *port, struct ehea_port_res *pr,\n\t\t\t      struct port_res_cfg *pr_cfg, int queue_token)\n{\n\tstruct ehea_adapter *adapter = port->adapter;\n\tenum ehea_eq_type eq_type = EHEA_EQ;\n\tstruct ehea_qp_init_attr *init_attr = NULL;\n\tint ret = -EIO;\n\tu64 tx_bytes, rx_bytes, tx_packets, rx_packets;\n\n\ttx_bytes = pr->tx_bytes;\n\ttx_packets = pr->tx_packets;\n\trx_bytes = pr->rx_bytes;\n\trx_packets = pr->rx_packets;\n\n\tmemset(pr, 0, sizeof(struct ehea_port_res));\n\n\tpr->tx_bytes = tx_bytes;\n\tpr->tx_packets = tx_packets;\n\tpr->rx_bytes = rx_bytes;\n\tpr->rx_packets = rx_packets;\n\n\tpr->port = port;\n\n\tpr->eq = ehea_create_eq(adapter, eq_type, EHEA_MAX_ENTRIES_EQ, 0);\n\tif (!pr->eq) {\n\t\tpr_err(\"create_eq failed (eq)\\n\");\n\t\tgoto out_free;\n\t}\n\n\tpr->recv_cq = ehea_create_cq(adapter, pr_cfg->max_entries_rcq,\n\t\t\t\t     pr->eq->fw_handle,\n\t\t\t\t     port->logical_port_id);\n\tif (!pr->recv_cq) {\n\t\tpr_err(\"create_cq failed (cq_recv)\\n\");\n\t\tgoto out_free;\n\t}\n\n\tpr->send_cq = ehea_create_cq(adapter, pr_cfg->max_entries_scq,\n\t\t\t\t     pr->eq->fw_handle,\n\t\t\t\t     port->logical_port_id);\n\tif (!pr->send_cq) {\n\t\tpr_err(\"create_cq failed (cq_send)\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (netif_msg_ifup(port))\n\t\tpr_info(\"Send CQ: act_nr_cqes=%d, Recv CQ: act_nr_cqes=%d\\n\",\n\t\t\tpr->send_cq->attr.act_nr_of_cqes,\n\t\t\tpr->recv_cq->attr.act_nr_of_cqes);\n\n\tinit_attr = kzalloc(sizeof(*init_attr), GFP_KERNEL);\n\tif (!init_attr) {\n\t\tret = -ENOMEM;\n\t\tpr_err(\"no mem for ehea_qp_init_attr\\n\");\n\t\tgoto out_free;\n\t}\n\n\tinit_attr->low_lat_rq1 = 1;\n\tinit_attr->signalingtype = 1;\t \n\tinit_attr->rq_count = 3;\n\tinit_attr->qp_token = queue_token;\n\tinit_attr->max_nr_send_wqes = pr_cfg->max_entries_sq;\n\tinit_attr->max_nr_rwqes_rq1 = pr_cfg->max_entries_rq1;\n\tinit_attr->max_nr_rwqes_rq2 = pr_cfg->max_entries_rq2;\n\tinit_attr->max_nr_rwqes_rq3 = pr_cfg->max_entries_rq3;\n\tinit_attr->wqe_size_enc_sq = EHEA_SG_SQ;\n\tinit_attr->wqe_size_enc_rq1 = EHEA_SG_RQ1;\n\tinit_attr->wqe_size_enc_rq2 = EHEA_SG_RQ2;\n\tinit_attr->wqe_size_enc_rq3 = EHEA_SG_RQ3;\n\tinit_attr->rq2_threshold = EHEA_RQ2_THRESHOLD;\n\tinit_attr->rq3_threshold = EHEA_RQ3_THRESHOLD;\n\tinit_attr->port_nr = port->logical_port_id;\n\tinit_attr->send_cq_handle = pr->send_cq->fw_handle;\n\tinit_attr->recv_cq_handle = pr->recv_cq->fw_handle;\n\tinit_attr->aff_eq_handle = port->qp_eq->fw_handle;\n\n\tpr->qp = ehea_create_qp(adapter, adapter->pd, init_attr);\n\tif (!pr->qp) {\n\t\tpr_err(\"create_qp failed\\n\");\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\n\tif (netif_msg_ifup(port))\n\t\tpr_info(\"QP: qp_nr=%d\\n act_nr_snd_wqe=%d\\n nr_rwqe_rq1=%d\\n nr_rwqe_rq2=%d\\n nr_rwqe_rq3=%d\\n\",\n\t\t\tinit_attr->qp_nr,\n\t\t\tinit_attr->act_nr_send_wqes,\n\t\t\tinit_attr->act_nr_rwqes_rq1,\n\t\t\tinit_attr->act_nr_rwqes_rq2,\n\t\t\tinit_attr->act_nr_rwqes_rq3);\n\n\tpr->sq_skba_size = init_attr->act_nr_send_wqes + 1;\n\n\tret = ehea_init_q_skba(&pr->sq_skba, pr->sq_skba_size);\n\tret |= ehea_init_q_skba(&pr->rq1_skba, init_attr->act_nr_rwqes_rq1 + 1);\n\tret |= ehea_init_q_skba(&pr->rq2_skba, init_attr->act_nr_rwqes_rq2 + 1);\n\tret |= ehea_init_q_skba(&pr->rq3_skba, init_attr->act_nr_rwqes_rq3 + 1);\n\tif (ret)\n\t\tgoto out_free;\n\n\tpr->swqe_refill_th = init_attr->act_nr_send_wqes / 10;\n\tif (ehea_gen_smrs(pr) != 0) {\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\n\tatomic_set(&pr->swqe_avail, init_attr->act_nr_send_wqes - 1);\n\n\tkfree(init_attr);\n\n\tnetif_napi_add(pr->port->netdev, &pr->napi, ehea_poll);\n\n\tret = 0;\n\tgoto out;\n\nout_free:\n\tkfree(init_attr);\n\tvfree(pr->sq_skba.arr);\n\tvfree(pr->rq1_skba.arr);\n\tvfree(pr->rq2_skba.arr);\n\tvfree(pr->rq3_skba.arr);\n\tehea_destroy_qp(pr->qp);\n\tehea_destroy_cq(pr->send_cq);\n\tehea_destroy_cq(pr->recv_cq);\n\tehea_destroy_eq(pr->eq);\nout:\n\treturn ret;\n}\n\nstatic int ehea_clean_portres(struct ehea_port *port, struct ehea_port_res *pr)\n{\n\tint ret, i;\n\n\tif (pr->qp)\n\t\tnetif_napi_del(&pr->napi);\n\n\tret = ehea_destroy_qp(pr->qp);\n\n\tif (!ret) {\n\t\tehea_destroy_cq(pr->send_cq);\n\t\tehea_destroy_cq(pr->recv_cq);\n\t\tehea_destroy_eq(pr->eq);\n\n\t\tfor (i = 0; i < pr->rq1_skba.len; i++)\n\t\t\tdev_kfree_skb(pr->rq1_skba.arr[i]);\n\n\t\tfor (i = 0; i < pr->rq2_skba.len; i++)\n\t\t\tdev_kfree_skb(pr->rq2_skba.arr[i]);\n\n\t\tfor (i = 0; i < pr->rq3_skba.len; i++)\n\t\t\tdev_kfree_skb(pr->rq3_skba.arr[i]);\n\n\t\tfor (i = 0; i < pr->sq_skba.len; i++)\n\t\t\tdev_kfree_skb(pr->sq_skba.arr[i]);\n\n\t\tvfree(pr->rq1_skba.arr);\n\t\tvfree(pr->rq2_skba.arr);\n\t\tvfree(pr->rq3_skba.arr);\n\t\tvfree(pr->sq_skba.arr);\n\t\tret = ehea_rem_smrs(pr);\n\t}\n\treturn ret;\n}\n\nstatic void write_swqe2_immediate(struct sk_buff *skb, struct ehea_swqe *swqe,\n\t\t\t\t  u32 lkey)\n{\n\tint skb_data_size = skb_headlen(skb);\n\tu8 *imm_data = &swqe->u.immdata_desc.immediate_data[0];\n\tstruct ehea_vsgentry *sg1entry = &swqe->u.immdata_desc.sg_entry;\n\tunsigned int immediate_len = SWQE2_MAX_IMM;\n\n\tswqe->descriptors = 0;\n\n\tif (skb_is_gso(skb)) {\n\t\tswqe->tx_control |= EHEA_SWQE_TSO;\n\t\tswqe->mss = skb_shinfo(skb)->gso_size;\n\t\t \n\t\timmediate_len = skb_tcp_all_headers(skb);\n\t}\n\n\tif (skb_is_gso(skb) || skb_data_size >= SWQE2_MAX_IMM) {\n\t\tskb_copy_from_linear_data(skb, imm_data, immediate_len);\n\t\tswqe->immediate_data_length = immediate_len;\n\n\t\tif (skb_data_size > immediate_len) {\n\t\t\tsg1entry->l_key = lkey;\n\t\t\tsg1entry->len = skb_data_size - immediate_len;\n\t\t\tsg1entry->vaddr =\n\t\t\t\tehea_map_vaddr(skb->data + immediate_len);\n\t\t\tswqe->descriptors++;\n\t\t}\n\t} else {\n\t\tskb_copy_from_linear_data(skb, imm_data, skb_data_size);\n\t\tswqe->immediate_data_length = skb_data_size;\n\t}\n}\n\nstatic inline void write_swqe2_data(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t    struct ehea_swqe *swqe, u32 lkey)\n{\n\tstruct ehea_vsgentry *sg_list, *sg1entry, *sgentry;\n\tskb_frag_t *frag;\n\tint nfrags, sg1entry_contains_frag_data, i;\n\n\tnfrags = skb_shinfo(skb)->nr_frags;\n\tsg1entry = &swqe->u.immdata_desc.sg_entry;\n\tsg_list = (struct ehea_vsgentry *)&swqe->u.immdata_desc.sg_list;\n\tsg1entry_contains_frag_data = 0;\n\n\twrite_swqe2_immediate(skb, swqe, lkey);\n\n\t \n\tif (nfrags > 0) {\n\t\tif (swqe->descriptors == 0) {\n\t\t\t \n\t\t\tfrag = &skb_shinfo(skb)->frags[0];\n\n\t\t\t \n\t\t\tsg1entry->l_key = lkey;\n\t\t\tsg1entry->len = skb_frag_size(frag);\n\t\t\tsg1entry->vaddr =\n\t\t\t\tehea_map_vaddr(skb_frag_address(frag));\n\t\t\tswqe->descriptors++;\n\t\t\tsg1entry_contains_frag_data = 1;\n\t\t}\n\n\t\tfor (i = sg1entry_contains_frag_data; i < nfrags; i++) {\n\n\t\t\tfrag = &skb_shinfo(skb)->frags[i];\n\t\t\tsgentry = &sg_list[i - sg1entry_contains_frag_data];\n\n\t\t\tsgentry->l_key = lkey;\n\t\t\tsgentry->len = skb_frag_size(frag);\n\t\t\tsgentry->vaddr = ehea_map_vaddr(skb_frag_address(frag));\n\t\t\tswqe->descriptors++;\n\t\t}\n\t}\n}\n\nstatic int ehea_broadcast_reg_helper(struct ehea_port *port, u32 hcallid)\n{\n\tint ret = 0;\n\tu64 hret;\n\tu8 reg_type;\n\n\t \n\treg_type = EHEA_BCMC_BROADCAST | EHEA_BCMC_UNTAGGED;\n\thret = ehea_h_reg_dereg_bcmc(port->adapter->handle,\n\t\t\t\t     port->logical_port_id,\n\t\t\t\t     reg_type, port->mac_addr, 0, hcallid);\n\tif (hret != H_SUCCESS) {\n\t\tpr_err(\"%sregistering bc address failed (tagged)\\n\",\n\t\t       hcallid == H_REG_BCMC ? \"\" : \"de\");\n\t\tret = -EIO;\n\t\tgoto out_herr;\n\t}\n\n\t \n\treg_type = EHEA_BCMC_BROADCAST | EHEA_BCMC_VLANID_ALL;\n\thret = ehea_h_reg_dereg_bcmc(port->adapter->handle,\n\t\t\t\t     port->logical_port_id,\n\t\t\t\t     reg_type, port->mac_addr, 0, hcallid);\n\tif (hret != H_SUCCESS) {\n\t\tpr_err(\"%sregistering bc address failed (vlan)\\n\",\n\t\t       hcallid == H_REG_BCMC ? \"\" : \"de\");\n\t\tret = -EIO;\n\t}\nout_herr:\n\treturn ret;\n}\n\nstatic int ehea_set_mac_addr(struct net_device *dev, void *sa)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tstruct sockaddr *mac_addr = sa;\n\tstruct hcp_ehea_port_cb0 *cb0;\n\tint ret;\n\tu64 hret;\n\n\tif (!is_valid_ether_addr(mac_addr->sa_data)) {\n\t\tret = -EADDRNOTAVAIL;\n\t\tgoto out;\n\t}\n\n\tcb0 = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!cb0) {\n\t\tpr_err(\"no mem for cb0\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(&(cb0->port_mac_addr), &(mac_addr->sa_data[0]), ETH_ALEN);\n\n\tcb0->port_mac_addr = cb0->port_mac_addr >> 16;\n\n\thret = ehea_h_modify_ehea_port(port->adapter->handle,\n\t\t\t\t       port->logical_port_id, H_PORT_CB0,\n\t\t\t\t       EHEA_BMASK_SET(H_PORT_CB0_MAC, 1), cb0);\n\tif (hret != H_SUCCESS) {\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\n\teth_hw_addr_set(dev, mac_addr->sa_data);\n\n\t \n\tif (port->state == EHEA_PORT_UP) {\n\t\tret = ehea_broadcast_reg_helper(port, H_DEREG_BCMC);\n\t\tif (ret)\n\t\t\tgoto out_upregs;\n\t}\n\n\tport->mac_addr = cb0->port_mac_addr << 16;\n\n\t \n\tif (port->state == EHEA_PORT_UP) {\n\t\tret = ehea_broadcast_reg_helper(port, H_REG_BCMC);\n\t\tif (ret)\n\t\t\tgoto out_upregs;\n\t}\n\n\tret = 0;\n\nout_upregs:\n\tehea_update_bcmc_registrations();\nout_free:\n\tfree_page((unsigned long)cb0);\nout:\n\treturn ret;\n}\n\nstatic void ehea_promiscuous_error(u64 hret, int enable)\n{\n\tif (hret == H_AUTHORITY)\n\t\tpr_info(\"Hypervisor denied %sabling promiscuous mode\\n\",\n\t\t\tenable == 1 ? \"en\" : \"dis\");\n\telse\n\t\tpr_err(\"failed %sabling promiscuous mode\\n\",\n\t\t       enable == 1 ? \"en\" : \"dis\");\n}\n\nstatic void ehea_promiscuous(struct net_device *dev, int enable)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tstruct hcp_ehea_port_cb7 *cb7;\n\tu64 hret;\n\n\tif (enable == port->promisc)\n\t\treturn;\n\n\tcb7 = (void *)get_zeroed_page(GFP_ATOMIC);\n\tif (!cb7) {\n\t\tpr_err(\"no mem for cb7\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tcb7->def_uc_qpn = enable == 1 ? port->port_res[0].qp->fw_handle : 0;\n\n\thret = ehea_h_modify_ehea_port(port->adapter->handle,\n\t\t\t\t       port->logical_port_id,\n\t\t\t\t       H_PORT_CB7, H_PORT_CB7_DUCQPN, cb7);\n\tif (hret) {\n\t\tehea_promiscuous_error(hret, enable);\n\t\tgoto out;\n\t}\n\n\tport->promisc = enable;\nout:\n\tfree_page((unsigned long)cb7);\n}\n\nstatic u64 ehea_multicast_reg_helper(struct ehea_port *port, u64 mc_mac_addr,\n\t\t\t\t     u32 hcallid)\n{\n\tu64 hret;\n\tu8 reg_type;\n\n\treg_type = EHEA_BCMC_MULTICAST | EHEA_BCMC_UNTAGGED;\n\tif (mc_mac_addr == 0)\n\t\treg_type |= EHEA_BCMC_SCOPE_ALL;\n\n\thret = ehea_h_reg_dereg_bcmc(port->adapter->handle,\n\t\t\t\t     port->logical_port_id,\n\t\t\t\t     reg_type, mc_mac_addr, 0, hcallid);\n\tif (hret)\n\t\tgoto out;\n\n\treg_type = EHEA_BCMC_MULTICAST | EHEA_BCMC_VLANID_ALL;\n\tif (mc_mac_addr == 0)\n\t\treg_type |= EHEA_BCMC_SCOPE_ALL;\n\n\thret = ehea_h_reg_dereg_bcmc(port->adapter->handle,\n\t\t\t\t     port->logical_port_id,\n\t\t\t\t     reg_type, mc_mac_addr, 0, hcallid);\nout:\n\treturn hret;\n}\n\nstatic int ehea_drop_multicast_list(struct net_device *dev)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tstruct ehea_mc_list *mc_entry = port->mc_list;\n\tstruct list_head *pos;\n\tstruct list_head *temp;\n\tint ret = 0;\n\tu64 hret;\n\n\tlist_for_each_safe(pos, temp, &(port->mc_list->list)) {\n\t\tmc_entry = list_entry(pos, struct ehea_mc_list, list);\n\n\t\thret = ehea_multicast_reg_helper(port, mc_entry->macaddr,\n\t\t\t\t\t\t H_DEREG_BCMC);\n\t\tif (hret) {\n\t\t\tpr_err(\"failed deregistering mcast MAC\\n\");\n\t\t\tret = -EIO;\n\t\t}\n\n\t\tlist_del(pos);\n\t\tkfree(mc_entry);\n\t}\n\treturn ret;\n}\n\nstatic void ehea_allmulti(struct net_device *dev, int enable)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tu64 hret;\n\n\tif (!port->allmulti) {\n\t\tif (enable) {\n\t\t\t \n\t\t\tehea_drop_multicast_list(dev);\n\t\t\thret = ehea_multicast_reg_helper(port, 0, H_REG_BCMC);\n\t\t\tif (!hret)\n\t\t\t\tport->allmulti = 1;\n\t\t\telse\n\t\t\t\tnetdev_err(dev,\n\t\t\t\t\t   \"failed enabling IFF_ALLMULTI\\n\");\n\t\t}\n\t} else {\n\t\tif (!enable) {\n\t\t\t \n\t\t\thret = ehea_multicast_reg_helper(port, 0, H_DEREG_BCMC);\n\t\t\tif (!hret)\n\t\t\t\tport->allmulti = 0;\n\t\t\telse\n\t\t\t\tnetdev_err(dev,\n\t\t\t\t\t   \"failed disabling IFF_ALLMULTI\\n\");\n\t\t}\n\t}\n}\n\nstatic void ehea_add_multicast_entry(struct ehea_port *port, u8 *mc_mac_addr)\n{\n\tstruct ehea_mc_list *ehea_mcl_entry;\n\tu64 hret;\n\n\tehea_mcl_entry = kzalloc(sizeof(*ehea_mcl_entry), GFP_ATOMIC);\n\tif (!ehea_mcl_entry)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&ehea_mcl_entry->list);\n\n\tmemcpy(&ehea_mcl_entry->macaddr, mc_mac_addr, ETH_ALEN);\n\n\thret = ehea_multicast_reg_helper(port, ehea_mcl_entry->macaddr,\n\t\t\t\t\t H_REG_BCMC);\n\tif (!hret)\n\t\tlist_add(&ehea_mcl_entry->list, &port->mc_list->list);\n\telse {\n\t\tpr_err(\"failed registering mcast MAC\\n\");\n\t\tkfree(ehea_mcl_entry);\n\t}\n}\n\nstatic void ehea_set_multicast_list(struct net_device *dev)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tstruct netdev_hw_addr *ha;\n\tint ret;\n\n\tehea_promiscuous(dev, !!(dev->flags & IFF_PROMISC));\n\n\tif (dev->flags & IFF_ALLMULTI) {\n\t\tehea_allmulti(dev, 1);\n\t\tgoto out;\n\t}\n\tehea_allmulti(dev, 0);\n\n\tif (!netdev_mc_empty(dev)) {\n\t\tret = ehea_drop_multicast_list(dev);\n\t\tif (ret) {\n\t\t\t \n\t\t\tehea_allmulti(dev, 1);\n\t\t}\n\n\t\tif (netdev_mc_count(dev) > port->adapter->max_mc_mac) {\n\t\t\tpr_info(\"Mcast registration limit reached (0x%llx). Use ALLMULTI!\\n\",\n\t\t\t\tport->adapter->max_mc_mac);\n\t\t\tgoto out;\n\t\t}\n\n\t\tnetdev_for_each_mc_addr(ha, dev)\n\t\t\tehea_add_multicast_entry(port, ha->addr);\n\n\t}\nout:\n\tehea_update_bcmc_registrations();\n}\n\nstatic void xmit_common(struct sk_buff *skb, struct ehea_swqe *swqe)\n{\n\tswqe->tx_control |= EHEA_SWQE_IMM_DATA_PRESENT | EHEA_SWQE_CRC;\n\n\tif (vlan_get_protocol(skb) != htons(ETH_P_IP))\n\t\treturn;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tswqe->tx_control |= EHEA_SWQE_IP_CHECKSUM;\n\n\tswqe->ip_start = skb_network_offset(skb);\n\tswqe->ip_end = swqe->ip_start + ip_hdrlen(skb) - 1;\n\n\tswitch (ip_hdr(skb)->protocol) {\n\tcase IPPROTO_UDP:\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\tswqe->tx_control |= EHEA_SWQE_TCP_CHECKSUM;\n\n\t\tswqe->tcp_offset = swqe->ip_end + 1 +\n\t\t\t\t   offsetof(struct udphdr, check);\n\t\tbreak;\n\n\tcase IPPROTO_TCP:\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\tswqe->tx_control |= EHEA_SWQE_TCP_CHECKSUM;\n\n\t\tswqe->tcp_offset = swqe->ip_end + 1 +\n\t\t\t\t   offsetof(struct tcphdr, check);\n\t\tbreak;\n\t}\n}\n\nstatic void ehea_xmit2(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct ehea_swqe *swqe, u32 lkey)\n{\n\tswqe->tx_control |= EHEA_SWQE_DESCRIPTORS_PRESENT;\n\n\txmit_common(skb, swqe);\n\n\twrite_swqe2_data(skb, dev, swqe, lkey);\n}\n\nstatic void ehea_xmit3(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct ehea_swqe *swqe)\n{\n\tu8 *imm_data = &swqe->u.immdata_nodesc.immediate_data[0];\n\n\txmit_common(skb, swqe);\n\n\tif (!skb->data_len)\n\t\tskb_copy_from_linear_data(skb, imm_data, skb->len);\n\telse\n\t\tskb_copy_bits(skb, 0, imm_data, skb->len);\n\n\tswqe->immediate_data_length = skb->len;\n\tdev_consume_skb_any(skb);\n}\n\nstatic netdev_tx_t ehea_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tstruct ehea_swqe *swqe;\n\tu32 lkey;\n\tint swqe_index;\n\tstruct ehea_port_res *pr;\n\tstruct netdev_queue *txq;\n\n\tpr = &port->port_res[skb_get_queue_mapping(skb)];\n\ttxq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));\n\n\tswqe = ehea_get_swqe(pr->qp, &swqe_index);\n\tmemset(swqe, 0, SWQE_HEADER_SIZE);\n\tatomic_dec(&pr->swqe_avail);\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\tswqe->tx_control |= EHEA_SWQE_VLAN_INSERT;\n\t\tswqe->vlan_tag = skb_vlan_tag_get(skb);\n\t}\n\n\tpr->tx_packets++;\n\tpr->tx_bytes += skb->len;\n\n\tif (skb->len <= SWQE3_MAX_IMM) {\n\t\tu32 sig_iv = port->sig_comp_iv;\n\t\tu32 swqe_num = pr->swqe_id_counter;\n\t\tehea_xmit3(skb, dev, swqe);\n\t\tswqe->wr_id = EHEA_BMASK_SET(EHEA_WR_ID_TYPE, EHEA_SWQE3_TYPE)\n\t\t\t| EHEA_BMASK_SET(EHEA_WR_ID_COUNT, swqe_num);\n\t\tif (pr->swqe_ll_count >= (sig_iv - 1)) {\n\t\t\tswqe->wr_id |= EHEA_BMASK_SET(EHEA_WR_ID_REFILL,\n\t\t\t\t\t\t      sig_iv);\n\t\t\tswqe->tx_control |= EHEA_SWQE_SIGNALLED_COMPLETION;\n\t\t\tpr->swqe_ll_count = 0;\n\t\t} else\n\t\t\tpr->swqe_ll_count += 1;\n\t} else {\n\t\tswqe->wr_id =\n\t\t\tEHEA_BMASK_SET(EHEA_WR_ID_TYPE, EHEA_SWQE2_TYPE)\n\t\t      | EHEA_BMASK_SET(EHEA_WR_ID_COUNT, pr->swqe_id_counter)\n\t\t      | EHEA_BMASK_SET(EHEA_WR_ID_REFILL, 1)\n\t\t      | EHEA_BMASK_SET(EHEA_WR_ID_INDEX, pr->sq_skba.index);\n\t\tpr->sq_skba.arr[pr->sq_skba.index] = skb;\n\n\t\tpr->sq_skba.index++;\n\t\tpr->sq_skba.index &= (pr->sq_skba.len - 1);\n\n\t\tlkey = pr->send_mr.lkey;\n\t\tehea_xmit2(skb, dev, swqe, lkey);\n\t\tswqe->tx_control |= EHEA_SWQE_SIGNALLED_COMPLETION;\n\t}\n\tpr->swqe_id_counter += 1;\n\n\tnetif_info(port, tx_queued, dev,\n\t\t   \"post swqe on QP %d\\n\", pr->qp->init_attr.qp_nr);\n\tif (netif_msg_tx_queued(port))\n\t\tehea_dump(swqe, 512, \"swqe\");\n\n\tif (unlikely(test_bit(__EHEA_STOP_XFER, &ehea_driver_flags))) {\n\t\tnetif_tx_stop_queue(txq);\n\t\tswqe->tx_control |= EHEA_SWQE_PURGE;\n\t}\n\n\tehea_post_swqe(pr->qp, swqe);\n\n\tif (unlikely(atomic_read(&pr->swqe_avail) <= 1)) {\n\t\tpr->p_stats.queue_stopped++;\n\t\tnetif_tx_stop_queue(txq);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ehea_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tstruct ehea_adapter *adapter = port->adapter;\n\tstruct hcp_ehea_port_cb1 *cb1;\n\tint index;\n\tu64 hret;\n\tint err = 0;\n\n\tcb1 = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!cb1) {\n\t\tpr_err(\"no mem for cb1\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\thret = ehea_h_query_ehea_port(adapter->handle, port->logical_port_id,\n\t\t\t\t      H_PORT_CB1, H_PORT_CB1_ALL, cb1);\n\tif (hret != H_SUCCESS) {\n\t\tpr_err(\"query_ehea_port failed\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tindex = (vid / 64);\n\tcb1->vlan_filter[index] |= ((u64)(0x8000000000000000 >> (vid & 0x3F)));\n\n\thret = ehea_h_modify_ehea_port(adapter->handle, port->logical_port_id,\n\t\t\t\t       H_PORT_CB1, H_PORT_CB1_ALL, cb1);\n\tif (hret != H_SUCCESS) {\n\t\tpr_err(\"modify_ehea_port failed\\n\");\n\t\terr = -EINVAL;\n\t}\nout:\n\tfree_page((unsigned long)cb1);\n\treturn err;\n}\n\nstatic int ehea_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tstruct ehea_adapter *adapter = port->adapter;\n\tstruct hcp_ehea_port_cb1 *cb1;\n\tint index;\n\tu64 hret;\n\tint err = 0;\n\n\tcb1 = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!cb1) {\n\t\tpr_err(\"no mem for cb1\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\thret = ehea_h_query_ehea_port(adapter->handle, port->logical_port_id,\n\t\t\t\t      H_PORT_CB1, H_PORT_CB1_ALL, cb1);\n\tif (hret != H_SUCCESS) {\n\t\tpr_err(\"query_ehea_port failed\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tindex = (vid / 64);\n\tcb1->vlan_filter[index] &= ~((u64)(0x8000000000000000 >> (vid & 0x3F)));\n\n\thret = ehea_h_modify_ehea_port(adapter->handle, port->logical_port_id,\n\t\t\t\t       H_PORT_CB1, H_PORT_CB1_ALL, cb1);\n\tif (hret != H_SUCCESS) {\n\t\tpr_err(\"modify_ehea_port failed\\n\");\n\t\terr = -EINVAL;\n\t}\nout:\n\tfree_page((unsigned long)cb1);\n\treturn err;\n}\n\nstatic int ehea_activate_qp(struct ehea_adapter *adapter, struct ehea_qp *qp)\n{\n\tint ret = -EIO;\n\tu64 hret;\n\tu16 dummy16 = 0;\n\tu64 dummy64 = 0;\n\tstruct hcp_modify_qp_cb0 *cb0;\n\n\tcb0 = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!cb0) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\thret = ehea_h_query_ehea_qp(adapter->handle, 0, qp->fw_handle,\n\t\t\t\t    EHEA_BMASK_SET(H_QPCB0_ALL, 0xFFFF), cb0);\n\tif (hret != H_SUCCESS) {\n\t\tpr_err(\"query_ehea_qp failed (1)\\n\");\n\t\tgoto out;\n\t}\n\n\tcb0->qp_ctl_reg = H_QP_CR_STATE_INITIALIZED;\n\thret = ehea_h_modify_ehea_qp(adapter->handle, 0, qp->fw_handle,\n\t\t\t\t     EHEA_BMASK_SET(H_QPCB0_QP_CTL_REG, 1), cb0,\n\t\t\t\t     &dummy64, &dummy64, &dummy16, &dummy16);\n\tif (hret != H_SUCCESS) {\n\t\tpr_err(\"modify_ehea_qp failed (1)\\n\");\n\t\tgoto out;\n\t}\n\n\thret = ehea_h_query_ehea_qp(adapter->handle, 0, qp->fw_handle,\n\t\t\t\t    EHEA_BMASK_SET(H_QPCB0_ALL, 0xFFFF), cb0);\n\tif (hret != H_SUCCESS) {\n\t\tpr_err(\"query_ehea_qp failed (2)\\n\");\n\t\tgoto out;\n\t}\n\n\tcb0->qp_ctl_reg = H_QP_CR_ENABLED | H_QP_CR_STATE_INITIALIZED;\n\thret = ehea_h_modify_ehea_qp(adapter->handle, 0, qp->fw_handle,\n\t\t\t\t     EHEA_BMASK_SET(H_QPCB0_QP_CTL_REG, 1), cb0,\n\t\t\t\t     &dummy64, &dummy64, &dummy16, &dummy16);\n\tif (hret != H_SUCCESS) {\n\t\tpr_err(\"modify_ehea_qp failed (2)\\n\");\n\t\tgoto out;\n\t}\n\n\thret = ehea_h_query_ehea_qp(adapter->handle, 0, qp->fw_handle,\n\t\t\t\t    EHEA_BMASK_SET(H_QPCB0_ALL, 0xFFFF), cb0);\n\tif (hret != H_SUCCESS) {\n\t\tpr_err(\"query_ehea_qp failed (3)\\n\");\n\t\tgoto out;\n\t}\n\n\tcb0->qp_ctl_reg = H_QP_CR_ENABLED | H_QP_CR_STATE_RDY2SND;\n\thret = ehea_h_modify_ehea_qp(adapter->handle, 0, qp->fw_handle,\n\t\t\t\t     EHEA_BMASK_SET(H_QPCB0_QP_CTL_REG, 1), cb0,\n\t\t\t\t     &dummy64, &dummy64, &dummy16, &dummy16);\n\tif (hret != H_SUCCESS) {\n\t\tpr_err(\"modify_ehea_qp failed (3)\\n\");\n\t\tgoto out;\n\t}\n\n\thret = ehea_h_query_ehea_qp(adapter->handle, 0, qp->fw_handle,\n\t\t\t\t    EHEA_BMASK_SET(H_QPCB0_ALL, 0xFFFF), cb0);\n\tif (hret != H_SUCCESS) {\n\t\tpr_err(\"query_ehea_qp failed (4)\\n\");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tfree_page((unsigned long)cb0);\n\treturn ret;\n}\n\nstatic int ehea_port_res_setup(struct ehea_port *port, int def_qps)\n{\n\tint ret, i;\n\tstruct port_res_cfg pr_cfg, pr_cfg_small_rx;\n\tenum ehea_eq_type eq_type = EHEA_EQ;\n\n\tport->qp_eq = ehea_create_eq(port->adapter, eq_type,\n\t\t\t\t   EHEA_MAX_ENTRIES_EQ, 1);\n\tif (!port->qp_eq) {\n\t\tret = -EINVAL;\n\t\tpr_err(\"ehea_create_eq failed (qp_eq)\\n\");\n\t\tgoto out_kill_eq;\n\t}\n\n\tpr_cfg.max_entries_rcq = rq1_entries + rq2_entries + rq3_entries;\n\tpr_cfg.max_entries_scq = sq_entries * 2;\n\tpr_cfg.max_entries_sq = sq_entries;\n\tpr_cfg.max_entries_rq1 = rq1_entries;\n\tpr_cfg.max_entries_rq2 = rq2_entries;\n\tpr_cfg.max_entries_rq3 = rq3_entries;\n\n\tpr_cfg_small_rx.max_entries_rcq = 1;\n\tpr_cfg_small_rx.max_entries_scq = sq_entries;\n\tpr_cfg_small_rx.max_entries_sq = sq_entries;\n\tpr_cfg_small_rx.max_entries_rq1 = 1;\n\tpr_cfg_small_rx.max_entries_rq2 = 1;\n\tpr_cfg_small_rx.max_entries_rq3 = 1;\n\n\tfor (i = 0; i < def_qps; i++) {\n\t\tret = ehea_init_port_res(port, &port->port_res[i], &pr_cfg, i);\n\t\tif (ret)\n\t\t\tgoto out_clean_pr;\n\t}\n\tfor (i = def_qps; i < def_qps; i++) {\n\t\tret = ehea_init_port_res(port, &port->port_res[i],\n\t\t\t\t\t &pr_cfg_small_rx, i);\n\t\tif (ret)\n\t\t\tgoto out_clean_pr;\n\t}\n\n\treturn 0;\n\nout_clean_pr:\n\twhile (--i >= 0)\n\t\tehea_clean_portres(port, &port->port_res[i]);\n\nout_kill_eq:\n\tehea_destroy_eq(port->qp_eq);\n\treturn ret;\n}\n\nstatic int ehea_clean_all_portres(struct ehea_port *port)\n{\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < port->num_def_qps; i++)\n\t\tret |= ehea_clean_portres(port, &port->port_res[i]);\n\n\tret |= ehea_destroy_eq(port->qp_eq);\n\n\treturn ret;\n}\n\nstatic void ehea_remove_adapter_mr(struct ehea_adapter *adapter)\n{\n\tif (adapter->active_ports)\n\t\treturn;\n\n\tehea_rem_mr(&adapter->mr);\n}\n\nstatic int ehea_add_adapter_mr(struct ehea_adapter *adapter)\n{\n\tif (adapter->active_ports)\n\t\treturn 0;\n\n\treturn ehea_reg_kernel_mr(adapter, &adapter->mr);\n}\n\nstatic int ehea_up(struct net_device *dev)\n{\n\tint ret, i;\n\tstruct ehea_port *port = netdev_priv(dev);\n\n\tif (port->state == EHEA_PORT_UP)\n\t\treturn 0;\n\n\tret = ehea_port_res_setup(port, port->num_def_qps);\n\tif (ret) {\n\t\tnetdev_err(dev, \"port_res_failed\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = ehea_configure_port(port);\n\tif (ret) {\n\t\tnetdev_err(dev, \"ehea_configure_port failed. ret:%d\\n\", ret);\n\t\tgoto out_clean_pr;\n\t}\n\n\tret = ehea_reg_interrupts(dev);\n\tif (ret) {\n\t\tnetdev_err(dev, \"reg_interrupts failed. ret:%d\\n\", ret);\n\t\tgoto out_clean_pr;\n\t}\n\n\tfor (i = 0; i < port->num_def_qps; i++) {\n\t\tret = ehea_activate_qp(port->adapter, port->port_res[i].qp);\n\t\tif (ret) {\n\t\t\tnetdev_err(dev, \"activate_qp failed\\n\");\n\t\t\tgoto out_free_irqs;\n\t\t}\n\t}\n\n\tfor (i = 0; i < port->num_def_qps; i++) {\n\t\tret = ehea_fill_port_res(&port->port_res[i]);\n\t\tif (ret) {\n\t\t\tnetdev_err(dev, \"out_free_irqs\\n\");\n\t\t\tgoto out_free_irqs;\n\t\t}\n\t}\n\n\tret = ehea_broadcast_reg_helper(port, H_REG_BCMC);\n\tif (ret) {\n\t\tret = -EIO;\n\t\tgoto out_free_irqs;\n\t}\n\n\tport->state = EHEA_PORT_UP;\n\n\tret = 0;\n\tgoto out;\n\nout_free_irqs:\n\tehea_free_interrupts(dev);\n\nout_clean_pr:\n\tehea_clean_all_portres(port);\nout:\n\tif (ret)\n\t\tnetdev_info(dev, \"Failed starting. ret=%i\\n\", ret);\n\n\tehea_update_bcmc_registrations();\n\tehea_update_firmware_handles();\n\n\treturn ret;\n}\n\nstatic void port_napi_disable(struct ehea_port *port)\n{\n\tint i;\n\n\tfor (i = 0; i < port->num_def_qps; i++)\n\t\tnapi_disable(&port->port_res[i].napi);\n}\n\nstatic void port_napi_enable(struct ehea_port *port)\n{\n\tint i;\n\n\tfor (i = 0; i < port->num_def_qps; i++)\n\t\tnapi_enable(&port->port_res[i].napi);\n}\n\nstatic int ehea_open(struct net_device *dev)\n{\n\tint ret;\n\tstruct ehea_port *port = netdev_priv(dev);\n\n\tmutex_lock(&port->port_lock);\n\n\tnetif_info(port, ifup, dev, \"enabling port\\n\");\n\n\tnetif_carrier_off(dev);\n\n\tret = ehea_up(dev);\n\tif (!ret) {\n\t\tport_napi_enable(port);\n\t\tnetif_tx_start_all_queues(dev);\n\t}\n\n\tmutex_unlock(&port->port_lock);\n\tschedule_delayed_work(&port->stats_work,\n\t\t\t      round_jiffies_relative(msecs_to_jiffies(1000)));\n\n\treturn ret;\n}\n\nstatic int ehea_down(struct net_device *dev)\n{\n\tint ret;\n\tstruct ehea_port *port = netdev_priv(dev);\n\n\tif (port->state == EHEA_PORT_DOWN)\n\t\treturn 0;\n\n\tehea_drop_multicast_list(dev);\n\tehea_allmulti(dev, 0);\n\tehea_broadcast_reg_helper(port, H_DEREG_BCMC);\n\n\tehea_free_interrupts(dev);\n\n\tport->state = EHEA_PORT_DOWN;\n\n\tehea_update_bcmc_registrations();\n\n\tret = ehea_clean_all_portres(port);\n\tif (ret)\n\t\tnetdev_info(dev, \"Failed freeing resources. ret=%i\\n\", ret);\n\n\tehea_update_firmware_handles();\n\n\treturn ret;\n}\n\nstatic int ehea_stop(struct net_device *dev)\n{\n\tint ret;\n\tstruct ehea_port *port = netdev_priv(dev);\n\n\tnetif_info(port, ifdown, dev, \"disabling port\\n\");\n\n\tset_bit(__EHEA_DISABLE_PORT_RESET, &port->flags);\n\tcancel_work_sync(&port->reset_task);\n\tcancel_delayed_work_sync(&port->stats_work);\n\tmutex_lock(&port->port_lock);\n\tnetif_tx_stop_all_queues(dev);\n\tport_napi_disable(port);\n\tret = ehea_down(dev);\n\tmutex_unlock(&port->port_lock);\n\tclear_bit(__EHEA_DISABLE_PORT_RESET, &port->flags);\n\treturn ret;\n}\n\nstatic void ehea_purge_sq(struct ehea_qp *orig_qp)\n{\n\tstruct ehea_qp qp = *orig_qp;\n\tstruct ehea_qp_init_attr *init_attr = &qp.init_attr;\n\tstruct ehea_swqe *swqe;\n\tint wqe_index;\n\tint i;\n\n\tfor (i = 0; i < init_attr->act_nr_send_wqes; i++) {\n\t\tswqe = ehea_get_swqe(&qp, &wqe_index);\n\t\tswqe->tx_control |= EHEA_SWQE_PURGE;\n\t}\n}\n\nstatic void ehea_flush_sq(struct ehea_port *port)\n{\n\tint i;\n\n\tfor (i = 0; i < port->num_def_qps; i++) {\n\t\tstruct ehea_port_res *pr = &port->port_res[i];\n\t\tint swqe_max = pr->sq_skba_size - 2 - pr->swqe_ll_count;\n\t\tint ret;\n\n\t\tret = wait_event_timeout(port->swqe_avail_wq,\n\t\t\t atomic_read(&pr->swqe_avail) >= swqe_max,\n\t\t\t msecs_to_jiffies(100));\n\n\t\tif (!ret) {\n\t\t\tpr_err(\"WARNING: sq not flushed completely\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int ehea_stop_qps(struct net_device *dev)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tstruct ehea_adapter *adapter = port->adapter;\n\tstruct hcp_modify_qp_cb0 *cb0;\n\tint ret = -EIO;\n\tint dret;\n\tint i;\n\tu64 hret;\n\tu64 dummy64 = 0;\n\tu16 dummy16 = 0;\n\n\tcb0 = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!cb0) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < (port->num_def_qps); i++) {\n\t\tstruct ehea_port_res *pr =  &port->port_res[i];\n\t\tstruct ehea_qp *qp = pr->qp;\n\n\t\t \n\t\tehea_purge_sq(qp);\n\n\t\t \n\t\thret = ehea_h_query_ehea_qp(adapter->handle, 0, qp->fw_handle,\n\t\t\t\t\t    EHEA_BMASK_SET(H_QPCB0_ALL, 0xFFFF),\n\t\t\t\t\t    cb0);\n\t\tif (hret != H_SUCCESS) {\n\t\t\tpr_err(\"query_ehea_qp failed (1)\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tcb0->qp_ctl_reg = (cb0->qp_ctl_reg & H_QP_CR_RES_STATE) << 8;\n\t\tcb0->qp_ctl_reg &= ~H_QP_CR_ENABLED;\n\n\t\thret = ehea_h_modify_ehea_qp(adapter->handle, 0, qp->fw_handle,\n\t\t\t\t\t     EHEA_BMASK_SET(H_QPCB0_QP_CTL_REG,\n\t\t\t\t\t\t\t    1), cb0, &dummy64,\n\t\t\t\t\t     &dummy64, &dummy16, &dummy16);\n\t\tif (hret != H_SUCCESS) {\n\t\t\tpr_err(\"modify_ehea_qp failed (1)\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\thret = ehea_h_query_ehea_qp(adapter->handle, 0, qp->fw_handle,\n\t\t\t\t\t    EHEA_BMASK_SET(H_QPCB0_ALL, 0xFFFF),\n\t\t\t\t\t    cb0);\n\t\tif (hret != H_SUCCESS) {\n\t\t\tpr_err(\"query_ehea_qp failed (2)\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tdret = ehea_rem_smrs(pr);\n\t\tif (dret) {\n\t\t\tpr_err(\"unreg shared memory region failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tfree_page((unsigned long)cb0);\n\n\treturn ret;\n}\n\nstatic void ehea_update_rqs(struct ehea_qp *orig_qp, struct ehea_port_res *pr)\n{\n\tstruct ehea_qp qp = *orig_qp;\n\tstruct ehea_qp_init_attr *init_attr = &qp.init_attr;\n\tstruct ehea_rwqe *rwqe;\n\tstruct sk_buff **skba_rq2 = pr->rq2_skba.arr;\n\tstruct sk_buff **skba_rq3 = pr->rq3_skba.arr;\n\tstruct sk_buff *skb;\n\tu32 lkey = pr->recv_mr.lkey;\n\n\n\tint i;\n\tint index;\n\n\tfor (i = 0; i < init_attr->act_nr_rwqes_rq2 + 1; i++) {\n\t\trwqe = ehea_get_next_rwqe(&qp, 2);\n\t\trwqe->sg_list[0].l_key = lkey;\n\t\tindex = EHEA_BMASK_GET(EHEA_WR_ID_INDEX, rwqe->wr_id);\n\t\tskb = skba_rq2[index];\n\t\tif (skb)\n\t\t\trwqe->sg_list[0].vaddr = ehea_map_vaddr(skb->data);\n\t}\n\n\tfor (i = 0; i < init_attr->act_nr_rwqes_rq3 + 1; i++) {\n\t\trwqe = ehea_get_next_rwqe(&qp, 3);\n\t\trwqe->sg_list[0].l_key = lkey;\n\t\tindex = EHEA_BMASK_GET(EHEA_WR_ID_INDEX, rwqe->wr_id);\n\t\tskb = skba_rq3[index];\n\t\tif (skb)\n\t\t\trwqe->sg_list[0].vaddr = ehea_map_vaddr(skb->data);\n\t}\n}\n\nstatic int ehea_restart_qps(struct net_device *dev)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tstruct ehea_adapter *adapter = port->adapter;\n\tint ret = 0;\n\tint i;\n\n\tstruct hcp_modify_qp_cb0 *cb0;\n\tu64 hret;\n\tu64 dummy64 = 0;\n\tu16 dummy16 = 0;\n\n\tcb0 = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!cb0)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < (port->num_def_qps); i++) {\n\t\tstruct ehea_port_res *pr =  &port->port_res[i];\n\t\tstruct ehea_qp *qp = pr->qp;\n\n\t\tret = ehea_gen_smrs(pr);\n\t\tif (ret) {\n\t\t\tnetdev_err(dev, \"creation of shared memory regions failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tehea_update_rqs(qp, pr);\n\n\t\t \n\t\thret = ehea_h_query_ehea_qp(adapter->handle, 0, qp->fw_handle,\n\t\t\t\t\t    EHEA_BMASK_SET(H_QPCB0_ALL, 0xFFFF),\n\t\t\t\t\t    cb0);\n\t\tif (hret != H_SUCCESS) {\n\t\t\tnetdev_err(dev, \"query_ehea_qp failed (1)\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcb0->qp_ctl_reg = (cb0->qp_ctl_reg & H_QP_CR_RES_STATE) << 8;\n\t\tcb0->qp_ctl_reg |= H_QP_CR_ENABLED;\n\n\t\thret = ehea_h_modify_ehea_qp(adapter->handle, 0, qp->fw_handle,\n\t\t\t\t\t     EHEA_BMASK_SET(H_QPCB0_QP_CTL_REG,\n\t\t\t\t\t\t\t    1), cb0, &dummy64,\n\t\t\t\t\t     &dummy64, &dummy16, &dummy16);\n\t\tif (hret != H_SUCCESS) {\n\t\t\tnetdev_err(dev, \"modify_ehea_qp failed (1)\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\thret = ehea_h_query_ehea_qp(adapter->handle, 0, qp->fw_handle,\n\t\t\t\t\t    EHEA_BMASK_SET(H_QPCB0_ALL, 0xFFFF),\n\t\t\t\t\t    cb0);\n\t\tif (hret != H_SUCCESS) {\n\t\t\tnetdev_err(dev, \"query_ehea_qp failed (2)\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tehea_refill_rq1(pr, pr->rq1_skba.index, 0);\n\t\tehea_refill_rq2(pr, 0);\n\t\tehea_refill_rq3(pr, 0);\n\t}\nout:\n\tfree_page((unsigned long)cb0);\n\n\treturn ret;\n}\n\nstatic void ehea_reset_port(struct work_struct *work)\n{\n\tint ret;\n\tstruct ehea_port *port =\n\t\tcontainer_of(work, struct ehea_port, reset_task);\n\tstruct net_device *dev = port->netdev;\n\n\tmutex_lock(&dlpar_mem_lock);\n\tport->resets++;\n\tmutex_lock(&port->port_lock);\n\tnetif_tx_disable(dev);\n\n\tport_napi_disable(port);\n\n\tehea_down(dev);\n\n\tret = ehea_up(dev);\n\tif (ret)\n\t\tgoto out;\n\n\tehea_set_multicast_list(dev);\n\n\tnetif_info(port, timer, dev, \"reset successful\\n\");\n\n\tport_napi_enable(port);\n\n\tnetif_tx_wake_all_queues(dev);\nout:\n\tmutex_unlock(&port->port_lock);\n\tmutex_unlock(&dlpar_mem_lock);\n}\n\nstatic void ehea_rereg_mrs(void)\n{\n\tint ret, i;\n\tstruct ehea_adapter *adapter;\n\n\tpr_info(\"LPAR memory changed - re-initializing driver\\n\");\n\n\tlist_for_each_entry(adapter, &adapter_list, list)\n\t\tif (adapter->active_ports) {\n\t\t\t \n\t\t\tfor (i = 0; i < EHEA_MAX_PORTS; i++) {\n\t\t\t\tstruct ehea_port *port = adapter->port[i];\n\t\t\t\tstruct net_device *dev;\n\n\t\t\t\tif (!port)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdev = port->netdev;\n\n\t\t\t\tif (dev->flags & IFF_UP) {\n\t\t\t\t\tmutex_lock(&port->port_lock);\n\t\t\t\t\tnetif_tx_disable(dev);\n\t\t\t\t\tehea_flush_sq(port);\n\t\t\t\t\tret = ehea_stop_qps(dev);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tmutex_unlock(&port->port_lock);\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tport_napi_disable(port);\n\t\t\t\t\tmutex_unlock(&port->port_lock);\n\t\t\t\t}\n\t\t\t\treset_sq_restart_flag(port);\n\t\t\t}\n\n\t\t\t \n\t\t\tret = ehea_rem_mr(&adapter->mr);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"unregister MR failed - driver inoperable!\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\tclear_bit(__EHEA_STOP_XFER, &ehea_driver_flags);\n\n\tlist_for_each_entry(adapter, &adapter_list, list)\n\t\tif (adapter->active_ports) {\n\t\t\t \n\t\t\tret = ehea_reg_kernel_mr(adapter, &adapter->mr);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"register MR failed - driver inoperable!\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (i = 0; i < EHEA_MAX_PORTS; i++) {\n\t\t\t\tstruct ehea_port *port = adapter->port[i];\n\n\t\t\t\tif (port) {\n\t\t\t\t\tstruct net_device *dev = port->netdev;\n\n\t\t\t\t\tif (dev->flags & IFF_UP) {\n\t\t\t\t\t\tmutex_lock(&port->port_lock);\n\t\t\t\t\t\tret = ehea_restart_qps(dev);\n\t\t\t\t\t\tif (!ret) {\n\t\t\t\t\t\t\tcheck_sqs(port);\n\t\t\t\t\t\t\tport_napi_enable(port);\n\t\t\t\t\t\t\tnetif_tx_wake_all_queues(dev);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnetdev_err(dev, \"Unable to restart QPS\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmutex_unlock(&port->port_lock);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpr_info(\"re-initializing driver complete\\n\");\nout:\n\treturn;\n}\n\nstatic void ehea_tx_watchdog(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\n\tif (netif_carrier_ok(dev) &&\n\t    !test_bit(__EHEA_STOP_XFER, &ehea_driver_flags))\n\t\tehea_schedule_port_reset(port);\n}\n\nstatic int ehea_sense_adapter_attr(struct ehea_adapter *adapter)\n{\n\tstruct hcp_query_ehea *cb;\n\tu64 hret;\n\tint ret;\n\n\tcb = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!cb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\thret = ehea_h_query_ehea(adapter->handle, cb);\n\n\tif (hret != H_SUCCESS) {\n\t\tret = -EIO;\n\t\tgoto out_herr;\n\t}\n\n\tadapter->max_mc_mac = cb->max_mc_mac - 1;\n\tret = 0;\n\nout_herr:\n\tfree_page((unsigned long)cb);\nout:\n\treturn ret;\n}\n\nstatic int ehea_get_jumboframe_status(struct ehea_port *port, int *jumbo)\n{\n\tstruct hcp_ehea_port_cb4 *cb4;\n\tu64 hret;\n\tint ret = 0;\n\n\t*jumbo = 0;\n\n\t \n\tcb4 = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!cb4) {\n\t\tpr_err(\"no mem for cb4\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t} else {\n\t\thret = ehea_h_query_ehea_port(port->adapter->handle,\n\t\t\t\t\t      port->logical_port_id,\n\t\t\t\t\t      H_PORT_CB4,\n\t\t\t\t\t      H_PORT_CB4_JUMBO, cb4);\n\t\tif (hret == H_SUCCESS) {\n\t\t\tif (cb4->jumbo_frame)\n\t\t\t\t*jumbo = 1;\n\t\t\telse {\n\t\t\t\tcb4->jumbo_frame = 1;\n\t\t\t\thret = ehea_h_modify_ehea_port(port->adapter->\n\t\t\t\t\t\t\t       handle,\n\t\t\t\t\t\t\t       port->\n\t\t\t\t\t\t\t       logical_port_id,\n\t\t\t\t\t\t\t       H_PORT_CB4,\n\t\t\t\t\t\t\t       H_PORT_CB4_JUMBO,\n\t\t\t\t\t\t\t       cb4);\n\t\t\t\tif (hret == H_SUCCESS)\n\t\t\t\t\t*jumbo = 1;\n\t\t\t}\n\t\t} else\n\t\t\tret = -EINVAL;\n\n\t\tfree_page((unsigned long)cb4);\n\t}\nout:\n\treturn ret;\n}\n\nstatic ssize_t log_port_id_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ehea_port *port = container_of(dev, struct ehea_port, ofdev.dev);\n\treturn sprintf(buf, \"%d\", port->logical_port_id);\n}\n\nstatic DEVICE_ATTR_RO(log_port_id);\n\nstatic void logical_port_release(struct device *dev)\n{\n\tstruct ehea_port *port = container_of(dev, struct ehea_port, ofdev.dev);\n\tof_node_put(port->ofdev.dev.of_node);\n}\n\nstatic struct device *ehea_register_port(struct ehea_port *port,\n\t\t\t\t\t struct device_node *dn)\n{\n\tint ret;\n\n\tport->ofdev.dev.of_node = of_node_get(dn);\n\tport->ofdev.dev.parent = &port->adapter->ofdev->dev;\n\tport->ofdev.dev.bus = &ibmebus_bus_type;\n\n\tdev_set_name(&port->ofdev.dev, \"port%d\", port_name_cnt++);\n\tport->ofdev.dev.release = logical_port_release;\n\n\tret = of_device_register(&port->ofdev);\n\tif (ret) {\n\t\tpr_err(\"failed to register device. ret=%d\\n\", ret);\n\t\tput_device(&port->ofdev.dev);\n\t\tgoto out;\n\t}\n\n\tret = device_create_file(&port->ofdev.dev, &dev_attr_log_port_id);\n\tif (ret) {\n\t\tpr_err(\"failed to register attributes, ret=%d\\n\", ret);\n\t\tgoto out_unreg_of_dev;\n\t}\n\n\treturn &port->ofdev.dev;\n\nout_unreg_of_dev:\n\tof_device_unregister(&port->ofdev);\nout:\n\treturn NULL;\n}\n\nstatic void ehea_unregister_port(struct ehea_port *port)\n{\n\tdevice_remove_file(&port->ofdev.dev, &dev_attr_log_port_id);\n\tof_device_unregister(&port->ofdev);\n}\n\nstatic const struct net_device_ops ehea_netdev_ops = {\n\t.ndo_open\t\t= ehea_open,\n\t.ndo_stop\t\t= ehea_stop,\n\t.ndo_start_xmit\t\t= ehea_start_xmit,\n\t.ndo_get_stats64\t= ehea_get_stats64,\n\t.ndo_set_mac_address\t= ehea_set_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_rx_mode\t= ehea_set_multicast_list,\n\t.ndo_vlan_rx_add_vid\t= ehea_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= ehea_vlan_rx_kill_vid,\n\t.ndo_tx_timeout\t\t= ehea_tx_watchdog,\n};\n\nstatic struct ehea_port *ehea_setup_single_port(struct ehea_adapter *adapter,\n\t\t\t\t\t u32 logical_port_id,\n\t\t\t\t\t struct device_node *dn)\n{\n\tint ret;\n\tstruct net_device *dev;\n\tstruct ehea_port *port;\n\tstruct device *port_dev;\n\tint jumbo;\n\n\t \n\tdev = alloc_etherdev_mq(sizeof(struct ehea_port), EHEA_MAX_PORT_RES);\n\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tport = netdev_priv(dev);\n\n\tmutex_init(&port->port_lock);\n\tport->state = EHEA_PORT_DOWN;\n\tport->sig_comp_iv = sq_entries / 10;\n\n\tport->adapter = adapter;\n\tport->netdev = dev;\n\tport->logical_port_id = logical_port_id;\n\n\tport->msg_enable = netif_msg_init(msg_level, EHEA_MSG_DEFAULT);\n\n\tport->mc_list = kzalloc(sizeof(struct ehea_mc_list), GFP_KERNEL);\n\tif (!port->mc_list) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_ethdev;\n\t}\n\n\tINIT_LIST_HEAD(&port->mc_list->list);\n\n\tret = ehea_sense_port_attr(port);\n\tif (ret)\n\t\tgoto out_free_mc_list;\n\n\tnetif_set_real_num_rx_queues(dev, port->num_def_qps);\n\tnetif_set_real_num_tx_queues(dev, port->num_def_qps);\n\n\tport_dev = ehea_register_port(port, dn);\n\tif (!port_dev)\n\t\tgoto out_free_mc_list;\n\n\tSET_NETDEV_DEV(dev, port_dev);\n\n\t \n\teth_hw_addr_set(dev, (u8 *)&port->mac_addr);\n\n\tdev->netdev_ops = &ehea_netdev_ops;\n\tehea_set_ethtool_ops(dev);\n\n\tdev->hw_features = NETIF_F_SG | NETIF_F_TSO |\n\t\t      NETIF_F_IP_CSUM | NETIF_F_HW_VLAN_CTAG_TX;\n\tdev->features = NETIF_F_SG | NETIF_F_TSO |\n\t\t      NETIF_F_HIGHDMA | NETIF_F_IP_CSUM |\n\t\t      NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |\n\t\t      NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_RXCSUM;\n\tdev->vlan_features = NETIF_F_SG | NETIF_F_TSO | NETIF_F_HIGHDMA |\n\t\t\tNETIF_F_IP_CSUM;\n\tdev->watchdog_timeo = EHEA_WATCH_DOG_TIMEOUT;\n\n\t \n\tdev->min_mtu = ETH_MIN_MTU;\n\tdev->max_mtu = EHEA_MAX_PACKET_SIZE;\n\n\tINIT_WORK(&port->reset_task, ehea_reset_port);\n\tINIT_DELAYED_WORK(&port->stats_work, ehea_update_stats);\n\n\tinit_waitqueue_head(&port->swqe_avail_wq);\n\tinit_waitqueue_head(&port->restart_wq);\n\n\tret = register_netdev(dev);\n\tif (ret) {\n\t\tpr_err(\"register_netdev failed. ret=%d\\n\", ret);\n\t\tgoto out_unreg_port;\n\t}\n\n\tret = ehea_get_jumboframe_status(port, &jumbo);\n\tif (ret)\n\t\tnetdev_err(dev, \"failed determining jumbo frame status\\n\");\n\n\tnetdev_info(dev, \"Jumbo frames are %sabled\\n\",\n\t\t    jumbo == 1 ? \"en\" : \"dis\");\n\n\tadapter->active_ports++;\n\n\treturn port;\n\nout_unreg_port:\n\tehea_unregister_port(port);\n\nout_free_mc_list:\n\tkfree(port->mc_list);\n\nout_free_ethdev:\n\tfree_netdev(dev);\n\nout_err:\n\tpr_err(\"setting up logical port with id=%d failed, ret=%d\\n\",\n\t       logical_port_id, ret);\n\treturn NULL;\n}\n\nstatic void ehea_shutdown_single_port(struct ehea_port *port)\n{\n\tstruct ehea_adapter *adapter = port->adapter;\n\n\tcancel_work_sync(&port->reset_task);\n\tcancel_delayed_work_sync(&port->stats_work);\n\tunregister_netdev(port->netdev);\n\tehea_unregister_port(port);\n\tkfree(port->mc_list);\n\tfree_netdev(port->netdev);\n\tadapter->active_ports--;\n}\n\nstatic int ehea_setup_ports(struct ehea_adapter *adapter)\n{\n\tstruct device_node *lhea_dn;\n\tstruct device_node *eth_dn = NULL;\n\n\tconst u32 *dn_log_port_id;\n\tint i = 0;\n\n\tlhea_dn = adapter->ofdev->dev.of_node;\n\twhile ((eth_dn = of_get_next_child(lhea_dn, eth_dn))) {\n\n\t\tdn_log_port_id = of_get_property(eth_dn, \"ibm,hea-port-no\",\n\t\t\t\t\t\t NULL);\n\t\tif (!dn_log_port_id) {\n\t\t\tpr_err(\"bad device node: eth_dn name=%pOF\\n\", eth_dn);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ehea_add_adapter_mr(adapter)) {\n\t\t\tpr_err(\"creating MR failed\\n\");\n\t\t\tof_node_put(eth_dn);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tadapter->port[i] = ehea_setup_single_port(adapter,\n\t\t\t\t\t\t\t  *dn_log_port_id,\n\t\t\t\t\t\t\t  eth_dn);\n\t\tif (adapter->port[i])\n\t\t\tnetdev_info(adapter->port[i]->netdev,\n\t\t\t\t    \"logical port id #%d\\n\", *dn_log_port_id);\n\t\telse\n\t\t\tehea_remove_adapter_mr(adapter);\n\n\t\ti++;\n\t}\n\treturn 0;\n}\n\nstatic struct device_node *ehea_get_eth_dn(struct ehea_adapter *adapter,\n\t\t\t\t\t   u32 logical_port_id)\n{\n\tstruct device_node *lhea_dn;\n\tstruct device_node *eth_dn = NULL;\n\tconst u32 *dn_log_port_id;\n\n\tlhea_dn = adapter->ofdev->dev.of_node;\n\twhile ((eth_dn = of_get_next_child(lhea_dn, eth_dn))) {\n\n\t\tdn_log_port_id = of_get_property(eth_dn, \"ibm,hea-port-no\",\n\t\t\t\t\t\t NULL);\n\t\tif (dn_log_port_id)\n\t\t\tif (*dn_log_port_id == logical_port_id)\n\t\t\t\treturn eth_dn;\n\t}\n\n\treturn NULL;\n}\n\nstatic ssize_t probe_port_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct ehea_adapter *adapter = dev_get_drvdata(dev);\n\tstruct ehea_port *port;\n\tstruct device_node *eth_dn = NULL;\n\tint i;\n\n\tu32 logical_port_id;\n\n\tsscanf(buf, \"%d\", &logical_port_id);\n\n\tport = ehea_get_port(adapter, logical_port_id);\n\n\tif (port) {\n\t\tnetdev_info(port->netdev, \"adding port with logical port id=%d failed: port already configured\\n\",\n\t\t\t    logical_port_id);\n\t\treturn -EINVAL;\n\t}\n\n\teth_dn = ehea_get_eth_dn(adapter, logical_port_id);\n\n\tif (!eth_dn) {\n\t\tpr_info(\"no logical port with id %d found\\n\", logical_port_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ehea_add_adapter_mr(adapter)) {\n\t\tpr_err(\"creating MR failed\\n\");\n\t\tof_node_put(eth_dn);\n\t\treturn -EIO;\n\t}\n\n\tport = ehea_setup_single_port(adapter, logical_port_id, eth_dn);\n\n\tof_node_put(eth_dn);\n\n\tif (port) {\n\t\tfor (i = 0; i < EHEA_MAX_PORTS; i++)\n\t\t\tif (!adapter->port[i]) {\n\t\t\t\tadapter->port[i] = port;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tnetdev_info(port->netdev, \"added: (logical port id=%d)\\n\",\n\t\t\t    logical_port_id);\n\t} else {\n\t\tehea_remove_adapter_mr(adapter);\n\t\treturn -EIO;\n\t}\n\n\treturn (ssize_t) count;\n}\n\nstatic ssize_t remove_port_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct ehea_adapter *adapter = dev_get_drvdata(dev);\n\tstruct ehea_port *port;\n\tint i;\n\tu32 logical_port_id;\n\n\tsscanf(buf, \"%d\", &logical_port_id);\n\n\tport = ehea_get_port(adapter, logical_port_id);\n\n\tif (port) {\n\t\tnetdev_info(port->netdev, \"removed: (logical port id=%d)\\n\",\n\t\t\t    logical_port_id);\n\n\t\tehea_shutdown_single_port(port);\n\n\t\tfor (i = 0; i < EHEA_MAX_PORTS; i++)\n\t\t\tif (adapter->port[i] == port) {\n\t\t\t\tadapter->port[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t} else {\n\t\tpr_err(\"removing port with logical port id=%d failed. port not configured.\\n\",\n\t\t       logical_port_id);\n\t\treturn -EINVAL;\n\t}\n\n\tehea_remove_adapter_mr(adapter);\n\n\treturn (ssize_t) count;\n}\n\nstatic DEVICE_ATTR_WO(probe_port);\nstatic DEVICE_ATTR_WO(remove_port);\n\nstatic int ehea_create_device_sysfs(struct platform_device *dev)\n{\n\tint ret = device_create_file(&dev->dev, &dev_attr_probe_port);\n\tif (ret)\n\t\tgoto out;\n\n\tret = device_create_file(&dev->dev, &dev_attr_remove_port);\nout:\n\treturn ret;\n}\n\nstatic void ehea_remove_device_sysfs(struct platform_device *dev)\n{\n\tdevice_remove_file(&dev->dev, &dev_attr_probe_port);\n\tdevice_remove_file(&dev->dev, &dev_attr_remove_port);\n}\n\nstatic int ehea_reboot_notifier(struct notifier_block *nb,\n\t\t\t\tunsigned long action, void *unused)\n{\n\tif (action == SYS_RESTART) {\n\t\tpr_info(\"Reboot: freeing all eHEA resources\\n\");\n\t\tibmebus_unregister_driver(&ehea_driver);\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block ehea_reboot_nb = {\n\t.notifier_call = ehea_reboot_notifier,\n};\n\nstatic int ehea_mem_notifier(struct notifier_block *nb,\n\t\t\t     unsigned long action, void *data)\n{\n\tint ret = NOTIFY_BAD;\n\tstruct memory_notify *arg = data;\n\n\tmutex_lock(&dlpar_mem_lock);\n\n\tswitch (action) {\n\tcase MEM_CANCEL_OFFLINE:\n\t\tpr_info(\"memory offlining canceled\");\n\t\tfallthrough;\t \n\n\tcase MEM_ONLINE:\n\t\tpr_info(\"memory is going online\");\n\t\tset_bit(__EHEA_STOP_XFER, &ehea_driver_flags);\n\t\tif (ehea_add_sect_bmap(arg->start_pfn, arg->nr_pages))\n\t\t\tgoto out_unlock;\n\t\tehea_rereg_mrs();\n\t\tbreak;\n\n\tcase MEM_GOING_OFFLINE:\n\t\tpr_info(\"memory is going offline\");\n\t\tset_bit(__EHEA_STOP_XFER, &ehea_driver_flags);\n\t\tif (ehea_rem_sect_bmap(arg->start_pfn, arg->nr_pages))\n\t\t\tgoto out_unlock;\n\t\tehea_rereg_mrs();\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tehea_update_firmware_handles();\n\tret = NOTIFY_OK;\n\nout_unlock:\n\tmutex_unlock(&dlpar_mem_lock);\n\treturn ret;\n}\n\nstatic struct notifier_block ehea_mem_nb = {\n\t.notifier_call = ehea_mem_notifier,\n};\n\nstatic void ehea_crash_handler(void)\n{\n\tint i;\n\n\tif (ehea_fw_handles.arr)\n\t\tfor (i = 0; i < ehea_fw_handles.num_entries; i++)\n\t\t\tehea_h_free_resource(ehea_fw_handles.arr[i].adh,\n\t\t\t\t\t     ehea_fw_handles.arr[i].fwh,\n\t\t\t\t\t     FORCE_FREE);\n\n\tif (ehea_bcmc_regs.arr)\n\t\tfor (i = 0; i < ehea_bcmc_regs.num_entries; i++)\n\t\t\tehea_h_reg_dereg_bcmc(ehea_bcmc_regs.arr[i].adh,\n\t\t\t\t\t      ehea_bcmc_regs.arr[i].port_id,\n\t\t\t\t\t      ehea_bcmc_regs.arr[i].reg_type,\n\t\t\t\t\t      ehea_bcmc_regs.arr[i].macaddr,\n\t\t\t\t\t      0, H_DEREG_BCMC);\n}\n\nstatic atomic_t ehea_memory_hooks_registered;\n\n \nstatic int ehea_register_memory_hooks(void)\n{\n\tint ret = 0;\n\n\tif (atomic_inc_return(&ehea_memory_hooks_registered) > 1)\n\t\treturn 0;\n\n\tret = ehea_create_busmap();\n\tif (ret) {\n\t\tpr_info(\"ehea_create_busmap failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = register_reboot_notifier(&ehea_reboot_nb);\n\tif (ret) {\n\t\tpr_info(\"register_reboot_notifier failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = register_memory_notifier(&ehea_mem_nb);\n\tif (ret) {\n\t\tpr_info(\"register_memory_notifier failed\\n\");\n\t\tgoto out2;\n\t}\n\n\tret = crash_shutdown_register(ehea_crash_handler);\n\tif (ret) {\n\t\tpr_info(\"crash_shutdown_register failed\\n\");\n\t\tgoto out3;\n\t}\n\n\treturn 0;\n\nout3:\n\tunregister_memory_notifier(&ehea_mem_nb);\nout2:\n\tunregister_reboot_notifier(&ehea_reboot_nb);\nout:\n\tatomic_dec(&ehea_memory_hooks_registered);\n\treturn ret;\n}\n\nstatic void ehea_unregister_memory_hooks(void)\n{\n\t \n\tif (atomic_read(&ehea_memory_hooks_registered) == 0)\n\t\treturn;\n\n\tunregister_reboot_notifier(&ehea_reboot_nb);\n\tif (crash_shutdown_unregister(ehea_crash_handler))\n\t\tpr_info(\"failed unregistering crash handler\\n\");\n\tunregister_memory_notifier(&ehea_mem_nb);\n}\n\nstatic int ehea_probe_adapter(struct platform_device *dev)\n{\n\tstruct ehea_adapter *adapter;\n\tconst u64 *adapter_handle;\n\tint ret;\n\tint i;\n\n\tret = ehea_register_memory_hooks();\n\tif (ret)\n\t\treturn ret;\n\n\tif (!dev || !dev->dev.of_node) {\n\t\tpr_err(\"Invalid ibmebus device probed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tadapter = devm_kzalloc(&dev->dev, sizeof(*adapter), GFP_KERNEL);\n\tif (!adapter) {\n\t\tret = -ENOMEM;\n\t\tdev_err(&dev->dev, \"no mem for ehea_adapter\\n\");\n\t\tgoto out;\n\t}\n\n\tlist_add(&adapter->list, &adapter_list);\n\n\tadapter->ofdev = dev;\n\n\tadapter_handle = of_get_property(dev->dev.of_node, \"ibm,hea-handle\",\n\t\t\t\t\t NULL);\n\tif (adapter_handle)\n\t\tadapter->handle = *adapter_handle;\n\n\tif (!adapter->handle) {\n\t\tdev_err(&dev->dev, \"failed getting handle for adapter\"\n\t\t\t\" '%pOF'\\n\", dev->dev.of_node);\n\t\tret = -ENODEV;\n\t\tgoto out_free_ad;\n\t}\n\n\tadapter->pd = EHEA_PD_ID;\n\n\tplatform_set_drvdata(dev, adapter);\n\n\n\t \n\t \n\tret = ehea_sense_adapter_attr(adapter);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"sense_adapter_attr failed: %d\\n\", ret);\n\t\tgoto out_free_ad;\n\t}\n\n\tadapter->neq = ehea_create_eq(adapter,\n\t\t\t\t      EHEA_NEQ, EHEA_MAX_ENTRIES_EQ, 1);\n\tif (!adapter->neq) {\n\t\tret = -EIO;\n\t\tdev_err(&dev->dev, \"NEQ creation failed\\n\");\n\t\tgoto out_free_ad;\n\t}\n\n\ttasklet_setup(&adapter->neq_tasklet, ehea_neq_tasklet);\n\n\tret = ehea_create_device_sysfs(dev);\n\tif (ret)\n\t\tgoto out_kill_eq;\n\n\tret = ehea_setup_ports(adapter);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"setup_ports failed\\n\");\n\t\tgoto out_rem_dev_sysfs;\n\t}\n\n\tret = ibmebus_request_irq(adapter->neq->attr.ist1,\n\t\t\t\t  ehea_interrupt_neq, 0,\n\t\t\t\t  \"ehea_neq\", adapter);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"requesting NEQ IRQ failed\\n\");\n\t\tgoto out_shutdown_ports;\n\t}\n\n\t \n\ttasklet_hi_schedule(&adapter->neq_tasklet);\n\n\tret = 0;\n\tgoto out;\n\nout_shutdown_ports:\n\tfor (i = 0; i < EHEA_MAX_PORTS; i++)\n\t\tif (adapter->port[i]) {\n\t\t\tehea_shutdown_single_port(adapter->port[i]);\n\t\t\tadapter->port[i] = NULL;\n\t\t}\n\nout_rem_dev_sysfs:\n\tehea_remove_device_sysfs(dev);\n\nout_kill_eq:\n\tehea_destroy_eq(adapter->neq);\n\nout_free_ad:\n\tlist_del(&adapter->list);\n\nout:\n\tehea_update_firmware_handles();\n\n\treturn ret;\n}\n\nstatic int ehea_remove(struct platform_device *dev)\n{\n\tstruct ehea_adapter *adapter = platform_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < EHEA_MAX_PORTS; i++)\n\t\tif (adapter->port[i]) {\n\t\t\tehea_shutdown_single_port(adapter->port[i]);\n\t\t\tadapter->port[i] = NULL;\n\t\t}\n\n\tehea_remove_device_sysfs(dev);\n\n\tibmebus_free_irq(adapter->neq->attr.ist1, adapter);\n\ttasklet_kill(&adapter->neq_tasklet);\n\n\tehea_destroy_eq(adapter->neq);\n\tehea_remove_adapter_mr(adapter);\n\tlist_del(&adapter->list);\n\n\tehea_update_firmware_handles();\n\n\treturn 0;\n}\n\nstatic int check_module_parm(void)\n{\n\tint ret = 0;\n\n\tif ((rq1_entries < EHEA_MIN_ENTRIES_QP) ||\n\t    (rq1_entries > EHEA_MAX_ENTRIES_RQ1)) {\n\t\tpr_info(\"Bad parameter: rq1_entries\\n\");\n\t\tret = -EINVAL;\n\t}\n\tif ((rq2_entries < EHEA_MIN_ENTRIES_QP) ||\n\t    (rq2_entries > EHEA_MAX_ENTRIES_RQ2)) {\n\t\tpr_info(\"Bad parameter: rq2_entries\\n\");\n\t\tret = -EINVAL;\n\t}\n\tif ((rq3_entries < EHEA_MIN_ENTRIES_QP) ||\n\t    (rq3_entries > EHEA_MAX_ENTRIES_RQ3)) {\n\t\tpr_info(\"Bad parameter: rq3_entries\\n\");\n\t\tret = -EINVAL;\n\t}\n\tif ((sq_entries < EHEA_MIN_ENTRIES_QP) ||\n\t    (sq_entries > EHEA_MAX_ENTRIES_SQ)) {\n\t\tpr_info(\"Bad parameter: sq_entries\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t capabilities_show(struct device_driver *drv, char *buf)\n{\n\treturn sprintf(buf, \"%d\", EHEA_CAPABILITIES);\n}\n\nstatic DRIVER_ATTR_RO(capabilities);\n\nstatic int __init ehea_module_init(void)\n{\n\tint ret;\n\n\tpr_info(\"IBM eHEA ethernet device driver (Release %s)\\n\", DRV_VERSION);\n\n\tmemset(&ehea_fw_handles, 0, sizeof(ehea_fw_handles));\n\tmemset(&ehea_bcmc_regs, 0, sizeof(ehea_bcmc_regs));\n\n\tmutex_init(&ehea_fw_handles.lock);\n\tspin_lock_init(&ehea_bcmc_regs.lock);\n\n\tret = check_module_parm();\n\tif (ret)\n\t\tgoto out;\n\n\tret = ibmebus_register_driver(&ehea_driver);\n\tif (ret) {\n\t\tpr_err(\"failed registering eHEA device driver on ebus\\n\");\n\t\tgoto out;\n\t}\n\n\tret = driver_create_file(&ehea_driver.driver,\n\t\t\t\t &driver_attr_capabilities);\n\tif (ret) {\n\t\tpr_err(\"failed to register capabilities attribute, ret=%d\\n\",\n\t\t       ret);\n\t\tgoto out2;\n\t}\n\n\treturn ret;\n\nout2:\n\tibmebus_unregister_driver(&ehea_driver);\nout:\n\treturn ret;\n}\n\nstatic void __exit ehea_module_exit(void)\n{\n\tdriver_remove_file(&ehea_driver.driver, &driver_attr_capabilities);\n\tibmebus_unregister_driver(&ehea_driver);\n\tehea_unregister_memory_hooks();\n\tkfree(ehea_fw_handles.arr);\n\tkfree(ehea_bcmc_regs.arr);\n\tehea_destroy_busmap();\n}\n\nmodule_init(ehea_module_init);\nmodule_exit(ehea_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}