{
  "module_name": "ehea_ethtool.c",
  "hash_id": "640ff304ddfbe604f0247aeaa238f9e6156f77ccb00388a3fc72c34ddae30792",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ibm/ehea/ehea_ethtool.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"ehea.h\"\n#include \"ehea_phyp.h\"\n\nstatic int ehea_get_link_ksettings(struct net_device *dev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tu32 supported, advertising;\n\tu32 speed;\n\tint ret;\n\n\tret = ehea_sense_port_attr(port);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (netif_carrier_ok(dev)) {\n\t\tswitch (port->port_speed) {\n\t\tcase EHEA_SPEED_10M:\n\t\t\tspeed = SPEED_10;\n\t\t\tbreak;\n\t\tcase EHEA_SPEED_100M:\n\t\t\tspeed = SPEED_100;\n\t\t\tbreak;\n\t\tcase EHEA_SPEED_1G:\n\t\t\tspeed = SPEED_1000;\n\t\t\tbreak;\n\t\tcase EHEA_SPEED_10G:\n\t\t\tspeed = SPEED_10000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tspeed = -1;\n\t\t\tbreak;  \n\t\t}\n\t\tcmd->base.duplex = port->full_duplex == 1 ?\n\t\t\t\t\t\t     DUPLEX_FULL : DUPLEX_HALF;\n\t} else {\n\t\tspeed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\tcmd->base.speed = speed;\n\n\tif (cmd->base.speed == SPEED_10000) {\n\t\tsupported = (SUPPORTED_10000baseT_Full | SUPPORTED_FIBRE);\n\t\tadvertising = (ADVERTISED_10000baseT_Full | ADVERTISED_FIBRE);\n\t\tcmd->base.port = PORT_FIBRE;\n\t} else {\n\t\tsupported = (SUPPORTED_1000baseT_Full | SUPPORTED_100baseT_Full\n\t\t\t       | SUPPORTED_100baseT_Half | SUPPORTED_10baseT_Full\n\t\t\t       | SUPPORTED_10baseT_Half | SUPPORTED_Autoneg\n\t\t\t       | SUPPORTED_TP);\n\t\tadvertising = (ADVERTISED_1000baseT_Full | ADVERTISED_Autoneg\n\t\t\t\t | ADVERTISED_TP);\n\t\tcmd->base.port = PORT_TP;\n\t}\n\n\tcmd->base.autoneg = port->autoneg == 1 ?\n\t\tAUTONEG_ENABLE : AUTONEG_DISABLE;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int ehea_set_link_ksettings(struct net_device *dev,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tint ret = 0;\n\tu32 sp;\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tsp = EHEA_SPEED_AUTONEG;\n\t\tgoto doit;\n\t}\n\n\tswitch (cmd->base.speed) {\n\tcase SPEED_10:\n\t\tif (cmd->base.duplex == DUPLEX_FULL)\n\t\t\tsp = H_SPEED_10M_F;\n\t\telse\n\t\t\tsp = H_SPEED_10M_H;\n\t\tbreak;\n\n\tcase SPEED_100:\n\t\tif (cmd->base.duplex == DUPLEX_FULL)\n\t\t\tsp = H_SPEED_100M_F;\n\t\telse\n\t\t\tsp = H_SPEED_100M_H;\n\t\tbreak;\n\n\tcase SPEED_1000:\n\t\tif (cmd->base.duplex == DUPLEX_FULL)\n\t\t\tsp = H_SPEED_1G_F;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase SPEED_10000:\n\t\tif (cmd->base.duplex == DUPLEX_FULL)\n\t\t\tsp = H_SPEED_10G_F;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tgoto out;\ndoit:\n\tret = ehea_set_portspeed(port, sp);\n\n\tif (!ret)\n\t\tnetdev_info(dev,\n\t\t\t    \"Port speed successfully set: %dMbps %s Duplex\\n\",\n\t\t\t    port->port_speed,\n\t\t\t    port->full_duplex == 1 ? \"Full\" : \"Half\");\nout:\n\treturn ret;\n}\n\nstatic int ehea_nway_reset(struct net_device *dev)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tint ret;\n\n\tret = ehea_set_portspeed(port, EHEA_SPEED_AUTONEG);\n\n\tif (!ret)\n\t\tnetdev_info(port->netdev,\n\t\t\t    \"Port speed successfully set: %dMbps %s Duplex\\n\",\n\t\t\t    port->port_speed,\n\t\t\t    port->full_duplex == 1 ? \"Full\" : \"Half\");\n\treturn ret;\n}\n\nstatic void ehea_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n}\n\nstatic u32 ehea_get_msglevel(struct net_device *dev)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\treturn port->msg_enable;\n}\n\nstatic void ehea_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct ehea_port *port = netdev_priv(dev);\n\tport->msg_enable = value;\n}\n\nstatic const char ehea_ethtool_stats_keys[][ETH_GSTRING_LEN] = {\n\t{\"sig_comp_iv\"},\n\t{\"swqe_refill_th\"},\n\t{\"port resets\"},\n\t{\"Receive errors\"},\n\t{\"TCP cksum errors\"},\n\t{\"IP cksum errors\"},\n\t{\"Frame cksum errors\"},\n\t{\"num SQ stopped\"},\n\t{\"PR0 free_swqes\"},\n\t{\"PR1 free_swqes\"},\n\t{\"PR2 free_swqes\"},\n\t{\"PR3 free_swqes\"},\n\t{\"PR4 free_swqes\"},\n\t{\"PR5 free_swqes\"},\n\t{\"PR6 free_swqes\"},\n\t{\"PR7 free_swqes\"},\n\t{\"PR8 free_swqes\"},\n\t{\"PR9 free_swqes\"},\n\t{\"PR10 free_swqes\"},\n\t{\"PR11 free_swqes\"},\n\t{\"PR12 free_swqes\"},\n\t{\"PR13 free_swqes\"},\n\t{\"PR14 free_swqes\"},\n\t{\"PR15 free_swqes\"},\n};\n\nstatic void ehea_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tif (stringset == ETH_SS_STATS) {\n\t\tmemcpy(data, &ehea_ethtool_stats_keys,\n\t\t       sizeof(ehea_ethtool_stats_keys));\n\t}\n}\n\nstatic int ehea_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(ehea_ethtool_stats_keys);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void ehea_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t     struct ethtool_stats *stats, u64 *data)\n{\n\tint i, k, tmp;\n\tstruct ehea_port *port = netdev_priv(dev);\n\n\tfor (i = 0; i < ehea_get_sset_count(dev, ETH_SS_STATS); i++)\n\t\tdata[i] = 0;\n\ti = 0;\n\n\tdata[i++] = port->sig_comp_iv;\n\tdata[i++] = port->port_res[0].swqe_refill_th;\n\tdata[i++] = port->resets;\n\n\tfor (k = 0, tmp = 0; k < EHEA_MAX_PORT_RES; k++)\n\t\ttmp += port->port_res[k].p_stats.poll_receive_errors;\n\tdata[i++] = tmp;\n\n\tfor (k = 0, tmp = 0; k < EHEA_MAX_PORT_RES; k++)\n\t\ttmp += port->port_res[k].p_stats.err_tcp_cksum;\n\tdata[i++] = tmp;\n\n\tfor (k = 0, tmp = 0; k < EHEA_MAX_PORT_RES; k++)\n\t\ttmp += port->port_res[k].p_stats.err_ip_cksum;\n\tdata[i++] = tmp;\n\n\tfor (k = 0, tmp = 0; k < EHEA_MAX_PORT_RES; k++)\n\t\ttmp += port->port_res[k].p_stats.err_frame_crc;\n\tdata[i++] = tmp;\n\n\tfor (k = 0, tmp = 0; k < EHEA_MAX_PORT_RES; k++)\n\t\ttmp += port->port_res[k].p_stats.queue_stopped;\n\tdata[i++] = tmp;\n\n\tfor (k = 0; k < 16; k++)\n\t\tdata[i++] = atomic_read(&port->port_res[k].swqe_avail);\n}\n\nstatic const struct ethtool_ops ehea_ethtool_ops = {\n\t.get_drvinfo = ehea_get_drvinfo,\n\t.get_msglevel = ehea_get_msglevel,\n\t.set_msglevel = ehea_set_msglevel,\n\t.get_link = ethtool_op_get_link,\n\t.get_strings = ehea_get_strings,\n\t.get_sset_count = ehea_get_sset_count,\n\t.get_ethtool_stats = ehea_get_ethtool_stats,\n\t.nway_reset = ehea_nway_reset,\t\t \n\t.get_link_ksettings = ehea_get_link_ksettings,\n\t.set_link_ksettings = ehea_set_link_ksettings,\n};\n\nvoid ehea_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &ehea_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}