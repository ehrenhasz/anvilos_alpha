{
  "module_name": "ehea_phyp.c",
  "hash_id": "b24c1cf82537f453c1e819d9a5e7483521e2fce55fd76480ba7b32e63f25f919",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ibm/ehea/ehea_phyp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"ehea_phyp.h\"\n\n\nstatic inline u16 get_order_of_qentries(u16 queue_entries)\n{\n\tu8 ld = 1;\t\t \n\twhile (((1U << ld) - 1) < queue_entries)\n\t\tld++;\n\treturn ld - 1;\n}\n\n \n#define H_ALL_RES_TYPE_QP\t 1\n#define H_ALL_RES_TYPE_CQ\t 2\n#define H_ALL_RES_TYPE_EQ\t 3\n#define H_ALL_RES_TYPE_MR\t 5\n#define H_ALL_RES_TYPE_MW\t 6\n\nstatic long ehea_plpar_hcall_norets(unsigned long opcode,\n\t\t\t\t    unsigned long arg1,\n\t\t\t\t    unsigned long arg2,\n\t\t\t\t    unsigned long arg3,\n\t\t\t\t    unsigned long arg4,\n\t\t\t\t    unsigned long arg5,\n\t\t\t\t    unsigned long arg6,\n\t\t\t\t    unsigned long arg7)\n{\n\tlong ret;\n\tint i, sleep_msecs;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tret = plpar_hcall_norets(opcode, arg1, arg2, arg3, arg4,\n\t\t\t\t\t arg5, arg6, arg7);\n\n\t\tif (H_IS_LONG_BUSY(ret)) {\n\t\t\tsleep_msecs = get_longbusy_msecs(ret);\n\t\t\tmsleep_interruptible(sleep_msecs);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret < H_SUCCESS)\n\t\t\tpr_err(\"opcode=%lx ret=%lx\"\n\t\t\t       \" arg1=%lx arg2=%lx arg3=%lx arg4=%lx\"\n\t\t\t       \" arg5=%lx arg6=%lx arg7=%lx\\n\",\n\t\t\t       opcode, ret,\n\t\t\t       arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n\n\t\treturn ret;\n\t}\n\n\treturn H_BUSY;\n}\n\nstatic long ehea_plpar_hcall9(unsigned long opcode,\n\t\t\t      unsigned long *outs,  \n\t\t\t      unsigned long arg1,\n\t\t\t      unsigned long arg2,\n\t\t\t      unsigned long arg3,\n\t\t\t      unsigned long arg4,\n\t\t\t      unsigned long arg5,\n\t\t\t      unsigned long arg6,\n\t\t\t      unsigned long arg7,\n\t\t\t      unsigned long arg8,\n\t\t\t      unsigned long arg9)\n{\n\tlong ret;\n\tint i, sleep_msecs;\n\tu8 cb_cat;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tret = plpar_hcall9(opcode, outs,\n\t\t\t\t   arg1, arg2, arg3, arg4, arg5,\n\t\t\t\t   arg6, arg7, arg8, arg9);\n\n\t\tif (H_IS_LONG_BUSY(ret)) {\n\t\t\tsleep_msecs = get_longbusy_msecs(ret);\n\t\t\tmsleep_interruptible(sleep_msecs);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcb_cat = EHEA_BMASK_GET(H_MEHEAPORT_CAT, arg2);\n\n\t\tif ((ret < H_SUCCESS) && !(((ret == H_AUTHORITY)\n\t\t    && (opcode == H_MODIFY_HEA_PORT))\n\t\t    && (((cb_cat == H_PORT_CB4) && ((arg3 == H_PORT_CB4_JUMBO)\n\t\t    || (arg3 == H_PORT_CB4_SPEED))) || ((cb_cat == H_PORT_CB7)\n\t\t    && (arg3 == H_PORT_CB7_DUCQPN)))))\n\t\t\tpr_err(\"opcode=%lx ret=%lx\"\n\t\t\t       \" arg1=%lx arg2=%lx arg3=%lx arg4=%lx\"\n\t\t\t       \" arg5=%lx arg6=%lx arg7=%lx arg8=%lx\"\n\t\t\t       \" arg9=%lx\"\n\t\t\t       \" out1=%lx out2=%lx out3=%lx out4=%lx\"\n\t\t\t       \" out5=%lx out6=%lx out7=%lx out8=%lx\"\n\t\t\t       \" out9=%lx\\n\",\n\t\t\t       opcode, ret,\n\t\t\t       arg1, arg2, arg3, arg4, arg5,\n\t\t\t       arg6, arg7, arg8, arg9,\n\t\t\t       outs[0], outs[1], outs[2], outs[3], outs[4],\n\t\t\t       outs[5], outs[6], outs[7], outs[8]);\n\t\treturn ret;\n\t}\n\n\treturn H_BUSY;\n}\n\nu64 ehea_h_query_ehea_qp(const u64 adapter_handle, const u8 qp_category,\n\t\t\t const u64 qp_handle, const u64 sel_mask, void *cb_addr)\n{\n\treturn ehea_plpar_hcall_norets(H_QUERY_HEA_QP,\n\t\t\t\t       adapter_handle,\t\t \n\t\t\t\t       qp_category,\t\t \n\t\t\t\t       qp_handle,\t\t \n\t\t\t\t       sel_mask,\t\t \n\t\t\t\t       __pa(cb_addr),\t\t \n\t\t\t\t       0, 0);\n}\n\n \n#define H_ALL_RES_QP_EQPO\t  EHEA_BMASK_IBM(9, 11)\n#define H_ALL_RES_QP_QPP\t  EHEA_BMASK_IBM(12, 12)\n#define H_ALL_RES_QP_RQR\t  EHEA_BMASK_IBM(13, 15)\n#define H_ALL_RES_QP_EQEG\t  EHEA_BMASK_IBM(16, 16)\n#define H_ALL_RES_QP_LL_QP\t  EHEA_BMASK_IBM(17, 17)\n#define H_ALL_RES_QP_DMA128\t  EHEA_BMASK_IBM(19, 19)\n#define H_ALL_RES_QP_HSM\t  EHEA_BMASK_IBM(20, 21)\n#define H_ALL_RES_QP_SIGT\t  EHEA_BMASK_IBM(22, 23)\n#define H_ALL_RES_QP_TENURE\t  EHEA_BMASK_IBM(48, 55)\n#define H_ALL_RES_QP_RES_TYP\t  EHEA_BMASK_IBM(56, 63)\n\n \n#define H_ALL_RES_QP_TOKEN\t  EHEA_BMASK_IBM(0, 31)\n#define H_ALL_RES_QP_PD\t\t  EHEA_BMASK_IBM(32, 63)\n\n \n#define H_ALL_RES_QP_MAX_SWQE\t  EHEA_BMASK_IBM(4, 7)\n#define H_ALL_RES_QP_MAX_R1WQE\t  EHEA_BMASK_IBM(12, 15)\n#define H_ALL_RES_QP_MAX_R2WQE\t  EHEA_BMASK_IBM(20, 23)\n#define H_ALL_RES_QP_MAX_R3WQE\t  EHEA_BMASK_IBM(28, 31)\n \n#define H_ALL_RES_QP_MAX_SSGE\t  EHEA_BMASK_IBM(37, 39)\n#define H_ALL_RES_QP_MAX_R1SGE\t  EHEA_BMASK_IBM(45, 47)\n \n#define H_ALL_RES_QP_MAX_R2SGE\t  EHEA_BMASK_IBM(53, 55)\n#define H_ALL_RES_QP_MAX_R3SGE\t  EHEA_BMASK_IBM(61, 63)\n\n \n#define H_ALL_RES_QP_SWQE_IDL\t  EHEA_BMASK_IBM(0, 7)\n \n#define H_ALL_RES_QP_PORT_NUM\t  EHEA_BMASK_IBM(48, 63)\n\n \n#define H_ALL_RES_QP_TH_RQ2\t  EHEA_BMASK_IBM(0, 15)\n \n#define H_ALL_RES_QP_TH_RQ3\t  EHEA_BMASK_IBM(16, 31)\n \n\n \n#define H_ALL_RES_QP_ACT_SWQE\t  EHEA_BMASK_IBM(0, 15)\n#define H_ALL_RES_QP_ACT_R1WQE\t  EHEA_BMASK_IBM(16, 31)\n#define H_ALL_RES_QP_ACT_R2WQE\t  EHEA_BMASK_IBM(32, 47)\n#define H_ALL_RES_QP_ACT_R3WQE\t  EHEA_BMASK_IBM(48, 63)\n\n \n#define H_ALL_RES_QP_ACT_SSGE\t  EHEA_BMASK_IBM(0, 7)\n#define H_ALL_RES_QP_ACT_R1SGE\t  EHEA_BMASK_IBM(8, 15)\n#define H_ALL_RES_QP_ACT_R2SGE\t  EHEA_BMASK_IBM(16, 23)\n#define H_ALL_RES_QP_ACT_R3SGE\t  EHEA_BMASK_IBM(24, 31)\n#define H_ALL_RES_QP_ACT_SWQE_IDL EHEA_BMASK_IBM(32, 39)\n\n \n#define H_ALL_RES_QP_SIZE_SQ\t  EHEA_BMASK_IBM(0, 31)\n#define H_ALL_RES_QP_SIZE_RQ1\t  EHEA_BMASK_IBM(32, 63)\n#define H_ALL_RES_QP_SIZE_RQ2\t  EHEA_BMASK_IBM(0, 31)\n#define H_ALL_RES_QP_SIZE_RQ3\t  EHEA_BMASK_IBM(32, 63)\n\n \n#define H_ALL_RES_QP_LIOBN_SQ\t  EHEA_BMASK_IBM(0, 31)\n#define H_ALL_RES_QP_LIOBN_RQ1\t  EHEA_BMASK_IBM(32, 63)\n#define H_ALL_RES_QP_LIOBN_RQ2\t  EHEA_BMASK_IBM(0, 31)\n#define H_ALL_RES_QP_LIOBN_RQ3\t  EHEA_BMASK_IBM(32, 63)\n\nu64 ehea_h_alloc_resource_qp(const u64 adapter_handle,\n\t\t\t     struct ehea_qp_init_attr *init_attr, const u32 pd,\n\t\t\t     u64 *qp_handle, struct h_epas *h_epas)\n{\n\tu64 hret;\n\tunsigned long outs[PLPAR_HCALL9_BUFSIZE];\n\n\tu64 allocate_controls =\n\t    EHEA_BMASK_SET(H_ALL_RES_QP_EQPO, init_attr->low_lat_rq1 ? 1 : 0)\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_QPP, 0)\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_RQR, 6)\t \n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_EQEG, 0)\t \n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_LL_QP, init_attr->low_lat_rq1)\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_DMA128, 0)\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_HSM, 0)\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_SIGT, init_attr->signalingtype)\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_RES_TYP, H_ALL_RES_TYPE_QP);\n\n\tu64 r9_reg = EHEA_BMASK_SET(H_ALL_RES_QP_PD, pd)\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_TOKEN, init_attr->qp_token);\n\n\tu64 max_r10_reg =\n\t    EHEA_BMASK_SET(H_ALL_RES_QP_MAX_SWQE,\n\t\t\t   get_order_of_qentries(init_attr->max_nr_send_wqes))\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_MAX_R1WQE,\n\t\t\t     get_order_of_qentries(init_attr->max_nr_rwqes_rq1))\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_MAX_R2WQE,\n\t\t\t     get_order_of_qentries(init_attr->max_nr_rwqes_rq2))\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_MAX_R3WQE,\n\t\t\t     get_order_of_qentries(init_attr->max_nr_rwqes_rq3))\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_MAX_SSGE, init_attr->wqe_size_enc_sq)\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_MAX_R1SGE,\n\t\t\t     init_attr->wqe_size_enc_rq1)\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_MAX_R2SGE,\n\t\t\t     init_attr->wqe_size_enc_rq2)\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_MAX_R3SGE,\n\t\t\t     init_attr->wqe_size_enc_rq3);\n\n\tu64 r11_in =\n\t    EHEA_BMASK_SET(H_ALL_RES_QP_SWQE_IDL, init_attr->swqe_imm_data_len)\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_PORT_NUM, init_attr->port_nr);\n\tu64 threshold =\n\t    EHEA_BMASK_SET(H_ALL_RES_QP_TH_RQ2, init_attr->rq2_threshold)\n\t    | EHEA_BMASK_SET(H_ALL_RES_QP_TH_RQ3, init_attr->rq3_threshold);\n\n\thret = ehea_plpar_hcall9(H_ALLOC_HEA_RESOURCE,\n\t\t\t\t outs,\n\t\t\t\t adapter_handle,\t\t \n\t\t\t\t allocate_controls,\t\t \n\t\t\t\t init_attr->send_cq_handle,\t \n\t\t\t\t init_attr->recv_cq_handle,\t \n\t\t\t\t init_attr->aff_eq_handle,\t \n\t\t\t\t r9_reg,\t\t\t \n\t\t\t\t max_r10_reg,\t\t\t \n\t\t\t\t r11_in,\t\t\t \n\t\t\t\t threshold);\t\t\t \n\n\t*qp_handle = outs[0];\n\tinit_attr->qp_nr = (u32)outs[1];\n\n\tinit_attr->act_nr_send_wqes =\n\t    (u16)EHEA_BMASK_GET(H_ALL_RES_QP_ACT_SWQE, outs[2]);\n\tinit_attr->act_nr_rwqes_rq1 =\n\t    (u16)EHEA_BMASK_GET(H_ALL_RES_QP_ACT_R1WQE, outs[2]);\n\tinit_attr->act_nr_rwqes_rq2 =\n\t    (u16)EHEA_BMASK_GET(H_ALL_RES_QP_ACT_R2WQE, outs[2]);\n\tinit_attr->act_nr_rwqes_rq3 =\n\t    (u16)EHEA_BMASK_GET(H_ALL_RES_QP_ACT_R3WQE, outs[2]);\n\n\tinit_attr->act_wqe_size_enc_sq = init_attr->wqe_size_enc_sq;\n\tinit_attr->act_wqe_size_enc_rq1 = init_attr->wqe_size_enc_rq1;\n\tinit_attr->act_wqe_size_enc_rq2 = init_attr->wqe_size_enc_rq2;\n\tinit_attr->act_wqe_size_enc_rq3 = init_attr->wqe_size_enc_rq3;\n\n\tinit_attr->nr_sq_pages =\n\t    (u32)EHEA_BMASK_GET(H_ALL_RES_QP_SIZE_SQ, outs[4]);\n\tinit_attr->nr_rq1_pages =\n\t    (u32)EHEA_BMASK_GET(H_ALL_RES_QP_SIZE_RQ1, outs[4]);\n\tinit_attr->nr_rq2_pages =\n\t    (u32)EHEA_BMASK_GET(H_ALL_RES_QP_SIZE_RQ2, outs[5]);\n\tinit_attr->nr_rq3_pages =\n\t    (u32)EHEA_BMASK_GET(H_ALL_RES_QP_SIZE_RQ3, outs[5]);\n\n\tinit_attr->liobn_sq =\n\t    (u32)EHEA_BMASK_GET(H_ALL_RES_QP_LIOBN_SQ, outs[7]);\n\tinit_attr->liobn_rq1 =\n\t    (u32)EHEA_BMASK_GET(H_ALL_RES_QP_LIOBN_RQ1, outs[7]);\n\tinit_attr->liobn_rq2 =\n\t    (u32)EHEA_BMASK_GET(H_ALL_RES_QP_LIOBN_RQ2, outs[8]);\n\tinit_attr->liobn_rq3 =\n\t    (u32)EHEA_BMASK_GET(H_ALL_RES_QP_LIOBN_RQ3, outs[8]);\n\n\tif (!hret)\n\t\thcp_epas_ctor(h_epas, outs[6], outs[6]);\n\n\treturn hret;\n}\n\nu64 ehea_h_alloc_resource_cq(const u64 adapter_handle,\n\t\t\t     struct ehea_cq_attr *cq_attr,\n\t\t\t     u64 *cq_handle, struct h_epas *epas)\n{\n\tu64 hret;\n\tunsigned long outs[PLPAR_HCALL9_BUFSIZE];\n\n\thret = ehea_plpar_hcall9(H_ALLOC_HEA_RESOURCE,\n\t\t\t\t outs,\n\t\t\t\t adapter_handle,\t\t \n\t\t\t\t H_ALL_RES_TYPE_CQ,\t\t \n\t\t\t\t cq_attr->eq_handle,\t\t \n\t\t\t\t cq_attr->cq_token,\t\t \n\t\t\t\t cq_attr->max_nr_of_cqes,\t \n\t\t\t\t 0, 0, 0, 0);\t\t\t \n\n\t*cq_handle = outs[0];\n\tcq_attr->act_nr_of_cqes = outs[3];\n\tcq_attr->nr_pages = outs[4];\n\n\tif (!hret)\n\t\thcp_epas_ctor(epas, outs[5], outs[6]);\n\n\treturn hret;\n}\n\n \n#define H_ALL_RES_TYPE_QP\t 1\n#define H_ALL_RES_TYPE_CQ\t 2\n#define H_ALL_RES_TYPE_EQ\t 3\n#define H_ALL_RES_TYPE_MR\t 5\n#define H_ALL_RES_TYPE_MW\t 6\n\n \n#define H_ALL_RES_EQ_NEQ\t     EHEA_BMASK_IBM(0, 0)\n#define H_ALL_RES_EQ_NON_NEQ_ISN     EHEA_BMASK_IBM(6, 7)\n#define H_ALL_RES_EQ_INH_EQE_GEN     EHEA_BMASK_IBM(16, 16)\n#define H_ALL_RES_EQ_RES_TYPE\t     EHEA_BMASK_IBM(56, 63)\n \n#define H_ALL_RES_EQ_MAX_EQE\t     EHEA_BMASK_IBM(32, 63)\n\n \n#define H_ALL_RES_EQ_LIOBN\t     EHEA_BMASK_IBM(32, 63)\n\n \n#define H_ALL_RES_EQ_ACT_EQE\t     EHEA_BMASK_IBM(32, 63)\n\n \n#define H_ALL_RES_EQ_ACT_PS\t     EHEA_BMASK_IBM(32, 63)\n\n \n#define H_ALL_RES_EQ_ACT_EQ_IST_C    EHEA_BMASK_IBM(30, 31)\n#define H_ALL_RES_EQ_ACT_EQ_IST_1    EHEA_BMASK_IBM(40, 63)\n\n \n#define H_ALL_RES_EQ_ACT_EQ_IST_2    EHEA_BMASK_IBM(40, 63)\n\n \n#define H_ALL_RES_EQ_ACT_EQ_IST_3    EHEA_BMASK_IBM(40, 63)\n\n \n#define H_ALL_RES_EQ_ACT_EQ_IST_4    EHEA_BMASK_IBM(40, 63)\n\nu64 ehea_h_alloc_resource_eq(const u64 adapter_handle,\n\t\t\t     struct ehea_eq_attr *eq_attr, u64 *eq_handle)\n{\n\tu64 hret, allocate_controls;\n\tunsigned long outs[PLPAR_HCALL9_BUFSIZE];\n\n\t \n\tallocate_controls =\n\t    EHEA_BMASK_SET(H_ALL_RES_EQ_RES_TYPE, H_ALL_RES_TYPE_EQ)\n\t    | EHEA_BMASK_SET(H_ALL_RES_EQ_NEQ, eq_attr->type ? 1 : 0)\n\t    | EHEA_BMASK_SET(H_ALL_RES_EQ_INH_EQE_GEN, !eq_attr->eqe_gen)\n\t    | EHEA_BMASK_SET(H_ALL_RES_EQ_NON_NEQ_ISN, 1);\n\n\thret = ehea_plpar_hcall9(H_ALLOC_HEA_RESOURCE,\n\t\t\t\t outs,\n\t\t\t\t adapter_handle,\t\t \n\t\t\t\t allocate_controls,\t\t \n\t\t\t\t eq_attr->max_nr_of_eqes,\t \n\t\t\t\t 0, 0, 0, 0, 0, 0);\t\t \n\n\t*eq_handle = outs[0];\n\teq_attr->act_nr_of_eqes = outs[3];\n\teq_attr->nr_pages = outs[4];\n\teq_attr->ist1 = outs[5];\n\teq_attr->ist2 = outs[6];\n\teq_attr->ist3 = outs[7];\n\teq_attr->ist4 = outs[8];\n\n\treturn hret;\n}\n\nu64 ehea_h_modify_ehea_qp(const u64 adapter_handle, const u8 cat,\n\t\t\t  const u64 qp_handle, const u64 sel_mask,\n\t\t\t  void *cb_addr, u64 *inv_attr_id, u64 *proc_mask,\n\t\t\t  u16 *out_swr, u16 *out_rwr)\n{\n\tu64 hret;\n\tunsigned long outs[PLPAR_HCALL9_BUFSIZE];\n\n\thret = ehea_plpar_hcall9(H_MODIFY_HEA_QP,\n\t\t\t\t outs,\n\t\t\t\t adapter_handle,\t\t \n\t\t\t\t (u64) cat,\t\t\t \n\t\t\t\t qp_handle,\t\t\t \n\t\t\t\t sel_mask,\t\t\t \n\t\t\t\t __pa(cb_addr),\t\t\t \n\t\t\t\t 0, 0, 0, 0);\t\t\t \n\n\t*inv_attr_id = outs[0];\n\t*out_swr = outs[3];\n\t*out_rwr = outs[4];\n\t*proc_mask = outs[5];\n\n\treturn hret;\n}\n\nu64 ehea_h_register_rpage(const u64 adapter_handle, const u8 pagesize,\n\t\t\t  const u8 queue_type, const u64 resource_handle,\n\t\t\t  const u64 log_pageaddr, u64 count)\n{\n\tu64  reg_control;\n\n\treg_control = EHEA_BMASK_SET(H_REG_RPAGE_PAGE_SIZE, pagesize)\n\t\t    | EHEA_BMASK_SET(H_REG_RPAGE_QT, queue_type);\n\n\treturn ehea_plpar_hcall_norets(H_REGISTER_HEA_RPAGES,\n\t\t\t\t       adapter_handle,\t\t \n\t\t\t\t       reg_control,\t\t \n\t\t\t\t       resource_handle,\t\t \n\t\t\t\t       log_pageaddr,\t\t \n\t\t\t\t       count,\t\t\t \n\t\t\t\t       0, 0);\t\t\t \n}\n\nu64 ehea_h_register_smr(const u64 adapter_handle, const u64 orig_mr_handle,\n\t\t\tconst u64 vaddr_in, const u32 access_ctrl, const u32 pd,\n\t\t\tstruct ehea_mr *mr)\n{\n\tu64 hret;\n\tunsigned long outs[PLPAR_HCALL9_BUFSIZE];\n\n\thret = ehea_plpar_hcall9(H_REGISTER_SMR,\n\t\t\t\t outs,\n\t\t\t\t adapter_handle\t      ,\t\t  \n\t\t\t\t orig_mr_handle,\t\t  \n\t\t\t\t vaddr_in,\t\t\t  \n\t\t\t\t (((u64)access_ctrl) << 32ULL),\t  \n\t\t\t\t pd,\t\t\t\t  \n\t\t\t\t 0, 0, 0, 0);\t\t\t  \n\n\tmr->handle = outs[0];\n\tmr->lkey = (u32)outs[2];\n\n\treturn hret;\n}\n\nu64 ehea_h_disable_and_get_hea(const u64 adapter_handle, const u64 qp_handle)\n{\n\tunsigned long outs[PLPAR_HCALL9_BUFSIZE];\n\n\treturn ehea_plpar_hcall9(H_DISABLE_AND_GET_HEA,\n\t\t\t\t outs,\n\t\t\t\t adapter_handle,\t\t \n\t\t\t\t H_DISABLE_GET_EHEA_WQE_P,\t \n\t\t\t\t qp_handle,\t\t\t \n\t\t\t\t 0, 0, 0, 0, 0, 0);\t\t \n}\n\nu64 ehea_h_free_resource(const u64 adapter_handle, const u64 res_handle,\n\t\t\t u64 force_bit)\n{\n\treturn ehea_plpar_hcall_norets(H_FREE_RESOURCE,\n\t\t\t\t       adapter_handle,\t    \n\t\t\t\t       res_handle,\t    \n\t\t\t\t       force_bit,\n\t\t\t\t       0, 0, 0, 0);\t    \n}\n\nu64 ehea_h_alloc_resource_mr(const u64 adapter_handle, const u64 vaddr,\n\t\t\t     const u64 length, const u32 access_ctrl,\n\t\t\t     const u32 pd, u64 *mr_handle, u32 *lkey)\n{\n\tu64 hret;\n\tunsigned long outs[PLPAR_HCALL9_BUFSIZE];\n\n\thret = ehea_plpar_hcall9(H_ALLOC_HEA_RESOURCE,\n\t\t\t\t outs,\n\t\t\t\t adapter_handle,\t\t    \n\t\t\t\t 5,\t\t\t\t    \n\t\t\t\t vaddr,\t\t\t\t    \n\t\t\t\t length,\t\t\t    \n\t\t\t\t (((u64) access_ctrl) << 32ULL),    \n\t\t\t\t pd,\t\t\t\t    \n\t\t\t\t 0, 0, 0);\t\t\t    \n\n\t*mr_handle = outs[0];\n\t*lkey = (u32)outs[2];\n\treturn hret;\n}\n\nu64 ehea_h_register_rpage_mr(const u64 adapter_handle, const u64 mr_handle,\n\t\t\t     const u8 pagesize, const u8 queue_type,\n\t\t\t     const u64 log_pageaddr, const u64 count)\n{\n\tif ((count > 1) && (log_pageaddr & ~PAGE_MASK)) {\n\t\tpr_err(\"not on pageboundary\\n\");\n\t\treturn H_PARAMETER;\n\t}\n\n\treturn ehea_h_register_rpage(adapter_handle, pagesize,\n\t\t\t\t     queue_type, mr_handle,\n\t\t\t\t     log_pageaddr, count);\n}\n\nu64 ehea_h_query_ehea(const u64 adapter_handle, void *cb_addr)\n{\n\tu64 hret, cb_logaddr;\n\n\tcb_logaddr = __pa(cb_addr);\n\n\thret = ehea_plpar_hcall_norets(H_QUERY_HEA,\n\t\t\t\t       adapter_handle,\t\t \n\t\t\t\t       cb_logaddr,\t\t \n\t\t\t\t       0, 0, 0, 0, 0);\t\t \n#ifdef DEBUG\n\tehea_dump(cb_addr, sizeof(struct hcp_query_ehea), \"hcp_query_ehea\");\n#endif\n\treturn hret;\n}\n\nu64 ehea_h_query_ehea_port(const u64 adapter_handle, const u16 port_num,\n\t\t\t   const u8 cb_cat, const u64 select_mask,\n\t\t\t   void *cb_addr)\n{\n\tu64 port_info;\n\tu64 cb_logaddr = __pa(cb_addr);\n\tu64 arr_index = 0;\n\n\tport_info = EHEA_BMASK_SET(H_MEHEAPORT_CAT, cb_cat)\n\t\t  | EHEA_BMASK_SET(H_MEHEAPORT_PN, port_num);\n\n\treturn ehea_plpar_hcall_norets(H_QUERY_HEA_PORT,\n\t\t\t\t       adapter_handle,\t\t \n\t\t\t\t       port_info,\t\t \n\t\t\t\t       select_mask,\t\t \n\t\t\t\t       arr_index,\t\t \n\t\t\t\t       cb_logaddr,\t\t \n\t\t\t\t       0, 0);\t\t\t \n}\n\nu64 ehea_h_modify_ehea_port(const u64 adapter_handle, const u16 port_num,\n\t\t\t    const u8 cb_cat, const u64 select_mask,\n\t\t\t    void *cb_addr)\n{\n\tunsigned long outs[PLPAR_HCALL9_BUFSIZE];\n\tu64 port_info;\n\tu64 arr_index = 0;\n\tu64 cb_logaddr = __pa(cb_addr);\n\n\tport_info = EHEA_BMASK_SET(H_MEHEAPORT_CAT, cb_cat)\n\t\t  | EHEA_BMASK_SET(H_MEHEAPORT_PN, port_num);\n#ifdef DEBUG\n\tehea_dump(cb_addr, sizeof(struct hcp_ehea_port_cb0), \"Before HCALL\");\n#endif\n\treturn ehea_plpar_hcall9(H_MODIFY_HEA_PORT,\n\t\t\t\t outs,\n\t\t\t\t adapter_handle,\t\t \n\t\t\t\t port_info,\t\t\t \n\t\t\t\t select_mask,\t\t\t \n\t\t\t\t arr_index,\t\t\t \n\t\t\t\t cb_logaddr,\t\t\t \n\t\t\t\t 0, 0, 0, 0);\t\t\t \n}\n\nu64 ehea_h_reg_dereg_bcmc(const u64 adapter_handle, const u16 port_num,\n\t\t\t  const u8 reg_type, const u64 mc_mac_addr,\n\t\t\t  const u16 vlan_id, const u32 hcall_id)\n{\n\tu64 r5_port_num, r6_reg_type, r7_mc_mac_addr, r8_vlan_id;\n\tu64 mac_addr = mc_mac_addr >> 16;\n\n\tr5_port_num = EHEA_BMASK_SET(H_REGBCMC_PN, port_num);\n\tr6_reg_type = EHEA_BMASK_SET(H_REGBCMC_REGTYPE, reg_type);\n\tr7_mc_mac_addr = EHEA_BMASK_SET(H_REGBCMC_MACADDR, mac_addr);\n\tr8_vlan_id = EHEA_BMASK_SET(H_REGBCMC_VLANID, vlan_id);\n\n\treturn ehea_plpar_hcall_norets(hcall_id,\n\t\t\t\t       adapter_handle,\t\t \n\t\t\t\t       r5_port_num,\t\t \n\t\t\t\t       r6_reg_type,\t\t \n\t\t\t\t       r7_mc_mac_addr,\t\t \n\t\t\t\t       r8_vlan_id,\t\t \n\t\t\t\t       0, 0);\t\t\t \n}\n\nu64 ehea_h_reset_events(const u64 adapter_handle, const u64 neq_handle,\n\t\t\tconst u64 event_mask)\n{\n\treturn ehea_plpar_hcall_norets(H_RESET_EVENTS,\n\t\t\t\t       adapter_handle,\t\t \n\t\t\t\t       neq_handle,\t\t \n\t\t\t\t       event_mask,\t\t \n\t\t\t\t       0, 0, 0, 0);\t\t \n}\n\nu64 ehea_h_error_data(const u64 adapter_handle, const u64 ressource_handle,\n\t\t      void *rblock)\n{\n\treturn ehea_plpar_hcall_norets(H_ERROR_DATA,\n\t\t\t\t       adapter_handle,\t\t \n\t\t\t\t       ressource_handle,\t \n\t\t\t\t       __pa(rblock),\t\t \n\t\t\t\t       0, 0, 0, 0);\t\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}