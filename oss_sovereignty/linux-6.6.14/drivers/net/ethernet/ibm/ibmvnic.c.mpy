{
  "module_name": "ibmvnic.c",
  "hash_id": "67dec3b555b75c9c1278f32ad848b40f4080d9119bfcaa9b9348ab49edd0ccde",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ibm/ibmvnic.c",
  "human_readable_source": "\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/completion.h>\n#include <linux/ioport.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n#include <linux/ethtool.h>\n#include <linux/proc_fs.h>\n#include <linux/if_arp.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kthread.h>\n#include <linux/seq_file.h>\n#include <linux/interrupt.h>\n#include <net/net_namespace.h>\n#include <asm/hvcall.h>\n#include <linux/atomic.h>\n#include <asm/vio.h>\n#include <asm/xive.h>\n#include <asm/iommu.h>\n#include <linux/uaccess.h>\n#include <asm/firmware.h>\n#include <linux/workqueue.h>\n#include <linux/if_vlan.h>\n#include <linux/utsname.h>\n#include <linux/cpu.h>\n\n#include \"ibmvnic.h\"\n\nstatic const char ibmvnic_driver_name[] = \"ibmvnic\";\nstatic const char ibmvnic_driver_string[] = \"IBM System i/p Virtual NIC Driver\";\n\nMODULE_AUTHOR(\"Santiago Leon\");\nMODULE_DESCRIPTION(\"IBM System i/p Virtual NIC Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(IBMVNIC_DRIVER_VERSION);\n\nstatic int ibmvnic_version = IBMVNIC_INITIAL_VERSION;\nstatic void release_sub_crqs(struct ibmvnic_adapter *, bool);\nstatic int ibmvnic_reset_crq(struct ibmvnic_adapter *);\nstatic int ibmvnic_send_crq_init(struct ibmvnic_adapter *);\nstatic int ibmvnic_reenable_crq_queue(struct ibmvnic_adapter *);\nstatic int ibmvnic_send_crq(struct ibmvnic_adapter *, union ibmvnic_crq *);\nstatic int send_subcrq_indirect(struct ibmvnic_adapter *, u64, u64, u64);\nstatic irqreturn_t ibmvnic_interrupt_rx(int irq, void *instance);\nstatic int enable_scrq_irq(struct ibmvnic_adapter *,\n\t\t\t   struct ibmvnic_sub_crq_queue *);\nstatic int disable_scrq_irq(struct ibmvnic_adapter *,\n\t\t\t    struct ibmvnic_sub_crq_queue *);\nstatic int pending_scrq(struct ibmvnic_adapter *,\n\t\t\tstruct ibmvnic_sub_crq_queue *);\nstatic union sub_crq *ibmvnic_next_scrq(struct ibmvnic_adapter *,\n\t\t\t\t\tstruct ibmvnic_sub_crq_queue *);\nstatic int ibmvnic_poll(struct napi_struct *napi, int data);\nstatic int reset_sub_crq_queues(struct ibmvnic_adapter *adapter);\nstatic inline void reinit_init_done(struct ibmvnic_adapter *adapter);\nstatic void send_query_map(struct ibmvnic_adapter *adapter);\nstatic int send_request_map(struct ibmvnic_adapter *, dma_addr_t, u32, u8);\nstatic int send_request_unmap(struct ibmvnic_adapter *, u8);\nstatic int send_login(struct ibmvnic_adapter *adapter);\nstatic void send_query_cap(struct ibmvnic_adapter *adapter);\nstatic int init_sub_crqs(struct ibmvnic_adapter *);\nstatic int init_sub_crq_irqs(struct ibmvnic_adapter *adapter);\nstatic int ibmvnic_reset_init(struct ibmvnic_adapter *, bool reset);\nstatic void release_crq_queue(struct ibmvnic_adapter *);\nstatic int __ibmvnic_set_mac(struct net_device *, u8 *);\nstatic int init_crq_queue(struct ibmvnic_adapter *adapter);\nstatic int send_query_phys_parms(struct ibmvnic_adapter *adapter);\nstatic void ibmvnic_tx_scrq_clean_buffer(struct ibmvnic_adapter *adapter,\n\t\t\t\t\t struct ibmvnic_sub_crq_queue *tx_scrq);\nstatic void free_long_term_buff(struct ibmvnic_adapter *adapter,\n\t\t\t\tstruct ibmvnic_long_term_buff *ltb);\nstatic void ibmvnic_disable_irqs(struct ibmvnic_adapter *adapter);\nstatic void flush_reset_queue(struct ibmvnic_adapter *adapter);\n\nstruct ibmvnic_stat {\n\tchar name[ETH_GSTRING_LEN];\n\tint offset;\n};\n\n#define IBMVNIC_STAT_OFF(stat) (offsetof(struct ibmvnic_adapter, stats) + \\\n\t\t\t     offsetof(struct ibmvnic_statistics, stat))\n#define IBMVNIC_GET_STAT(a, off) (*((u64 *)(((unsigned long)(a)) + (off))))\n\nstatic const struct ibmvnic_stat ibmvnic_stats[] = {\n\t{\"rx_packets\", IBMVNIC_STAT_OFF(rx_packets)},\n\t{\"rx_bytes\", IBMVNIC_STAT_OFF(rx_bytes)},\n\t{\"tx_packets\", IBMVNIC_STAT_OFF(tx_packets)},\n\t{\"tx_bytes\", IBMVNIC_STAT_OFF(tx_bytes)},\n\t{\"ucast_tx_packets\", IBMVNIC_STAT_OFF(ucast_tx_packets)},\n\t{\"ucast_rx_packets\", IBMVNIC_STAT_OFF(ucast_rx_packets)},\n\t{\"mcast_tx_packets\", IBMVNIC_STAT_OFF(mcast_tx_packets)},\n\t{\"mcast_rx_packets\", IBMVNIC_STAT_OFF(mcast_rx_packets)},\n\t{\"bcast_tx_packets\", IBMVNIC_STAT_OFF(bcast_tx_packets)},\n\t{\"bcast_rx_packets\", IBMVNIC_STAT_OFF(bcast_rx_packets)},\n\t{\"align_errors\", IBMVNIC_STAT_OFF(align_errors)},\n\t{\"fcs_errors\", IBMVNIC_STAT_OFF(fcs_errors)},\n\t{\"single_collision_frames\", IBMVNIC_STAT_OFF(single_collision_frames)},\n\t{\"multi_collision_frames\", IBMVNIC_STAT_OFF(multi_collision_frames)},\n\t{\"sqe_test_errors\", IBMVNIC_STAT_OFF(sqe_test_errors)},\n\t{\"deferred_tx\", IBMVNIC_STAT_OFF(deferred_tx)},\n\t{\"late_collisions\", IBMVNIC_STAT_OFF(late_collisions)},\n\t{\"excess_collisions\", IBMVNIC_STAT_OFF(excess_collisions)},\n\t{\"internal_mac_tx_errors\", IBMVNIC_STAT_OFF(internal_mac_tx_errors)},\n\t{\"carrier_sense\", IBMVNIC_STAT_OFF(carrier_sense)},\n\t{\"too_long_frames\", IBMVNIC_STAT_OFF(too_long_frames)},\n\t{\"internal_mac_rx_errors\", IBMVNIC_STAT_OFF(internal_mac_rx_errors)},\n};\n\nstatic int send_crq_init_complete(struct ibmvnic_adapter *adapter)\n{\n\tunion ibmvnic_crq crq;\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.generic.first = IBMVNIC_CRQ_INIT_CMD;\n\tcrq.generic.cmd = IBMVNIC_CRQ_INIT_COMPLETE;\n\n\treturn ibmvnic_send_crq(adapter, &crq);\n}\n\nstatic int send_version_xchg(struct ibmvnic_adapter *adapter)\n{\n\tunion ibmvnic_crq crq;\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.version_exchange.first = IBMVNIC_CRQ_CMD;\n\tcrq.version_exchange.cmd = VERSION_EXCHANGE;\n\tcrq.version_exchange.version = cpu_to_be16(ibmvnic_version);\n\n\treturn ibmvnic_send_crq(adapter, &crq);\n}\n\nstatic void ibmvnic_clean_queue_affinity(struct ibmvnic_adapter *adapter,\n\t\t\t\t\t struct ibmvnic_sub_crq_queue *queue)\n{\n\tif (!(queue && queue->irq))\n\t\treturn;\n\n\tcpumask_clear(queue->affinity_mask);\n\n\tif (irq_set_affinity_and_hint(queue->irq, NULL))\n\t\tnetdev_warn(adapter->netdev,\n\t\t\t    \"%s: Clear affinity failed, queue addr = %p, IRQ = %d\\n\",\n\t\t\t    __func__, queue, queue->irq);\n}\n\nstatic void ibmvnic_clean_affinity(struct ibmvnic_adapter *adapter)\n{\n\tstruct ibmvnic_sub_crq_queue **rxqs;\n\tstruct ibmvnic_sub_crq_queue **txqs;\n\tint num_rxqs, num_txqs;\n\tint i;\n\n\trxqs = adapter->rx_scrq;\n\ttxqs = adapter->tx_scrq;\n\tnum_txqs = adapter->num_active_tx_scrqs;\n\tnum_rxqs = adapter->num_active_rx_scrqs;\n\n\tnetdev_dbg(adapter->netdev, \"%s: Cleaning irq affinity hints\", __func__);\n\tif (txqs) {\n\t\tfor (i = 0; i < num_txqs; i++)\n\t\t\tibmvnic_clean_queue_affinity(adapter, txqs[i]);\n\t}\n\tif (rxqs) {\n\t\tfor (i = 0; i < num_rxqs; i++)\n\t\t\tibmvnic_clean_queue_affinity(adapter, rxqs[i]);\n\t}\n}\n\nstatic int ibmvnic_set_queue_affinity(struct ibmvnic_sub_crq_queue *queue,\n\t\t\t\t      unsigned int *cpu, int *stragglers,\n\t\t\t\t      int stride)\n{\n\tcpumask_var_t mask;\n\tint i;\n\tint rc = 0;\n\n\tif (!(queue && queue->irq))\n\t\treturn rc;\n\n\t \n\tif (!zalloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\t \n\tif (*stragglers) {\n\t\tstride++;\n\t\t(*stragglers)--;\n\t}\n\t \n\tfor (i = 0; i < stride; i++) {\n\t\tcpumask_set_cpu(*cpu, mask);\n\t\t*cpu = cpumask_next_wrap(*cpu, cpu_online_mask,\n\t\t\t\t\t nr_cpu_ids, false);\n\t}\n\t \n\tcpumask_copy(queue->affinity_mask, mask);\n\trc = irq_set_affinity_and_hint(queue->irq, queue->affinity_mask);\n\tfree_cpumask_var(mask);\n\n\treturn rc;\n}\n\n \nstatic void ibmvnic_set_affinity(struct ibmvnic_adapter *adapter)\n{\n\tstruct ibmvnic_sub_crq_queue **rxqs = adapter->rx_scrq;\n\tstruct ibmvnic_sub_crq_queue **txqs = adapter->tx_scrq;\n\tstruct ibmvnic_sub_crq_queue *queue;\n\tint num_rxqs = adapter->num_active_rx_scrqs, i_rxqs = 0;\n\tint num_txqs = adapter->num_active_tx_scrqs, i_txqs = 0;\n\tint total_queues, stride, stragglers, i;\n\tunsigned int num_cpu, cpu;\n\tbool is_rx_queue;\n\tint rc = 0;\n\n\tnetdev_dbg(adapter->netdev, \"%s: Setting irq affinity hints\", __func__);\n\tif (!(adapter->rx_scrq && adapter->tx_scrq)) {\n\t\tnetdev_warn(adapter->netdev,\n\t\t\t    \"%s: Set affinity failed, queues not allocated\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\n\ttotal_queues = num_rxqs + num_txqs;\n\tnum_cpu = num_online_cpus();\n\t \n\tstride = max_t(int, num_cpu / total_queues, 1);\n\t \n\tstragglers = num_cpu >= total_queues ? num_cpu % total_queues : 0;\n\t \n\tcpu = cpumask_next(-1, cpu_online_mask);\n\n\tfor (i = 0; i < total_queues; i++) {\n\t\tis_rx_queue = false;\n\t\t \n\t\tif ((i % 2 == 1 && i_rxqs < num_rxqs) || i_txqs == num_txqs) {\n\t\t\tqueue = rxqs[i_rxqs++];\n\t\t\tis_rx_queue = true;\n\t\t} else {\n\t\t\tqueue = txqs[i_txqs++];\n\t\t}\n\n\t\trc = ibmvnic_set_queue_affinity(queue, &cpu, &stragglers,\n\t\t\t\t\t\tstride);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tif (!queue || is_rx_queue)\n\t\t\tcontinue;\n\n\t\trc = __netif_set_xps_queue(adapter->netdev,\n\t\t\t\t\t   cpumask_bits(queue->affinity_mask),\n\t\t\t\t\t   i_txqs - 1, XPS_CPUS);\n\t\tif (rc)\n\t\t\tnetdev_warn(adapter->netdev, \"%s: Set XPS on queue %d failed, rc = %d.\\n\",\n\t\t\t\t    __func__, i_txqs - 1, rc);\n\t}\n\nout:\n\tif (rc) {\n\t\tnetdev_warn(adapter->netdev,\n\t\t\t    \"%s: Set affinity failed, queue addr = %p, IRQ = %d, rc = %d.\\n\",\n\t\t\t    __func__, queue, queue->irq, rc);\n\t\tibmvnic_clean_affinity(adapter);\n\t}\n}\n\nstatic int ibmvnic_cpu_online(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct ibmvnic_adapter *adapter;\n\n\tadapter = hlist_entry_safe(node, struct ibmvnic_adapter, node);\n\tibmvnic_set_affinity(adapter);\n\treturn 0;\n}\n\nstatic int ibmvnic_cpu_dead(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct ibmvnic_adapter *adapter;\n\n\tadapter = hlist_entry_safe(node, struct ibmvnic_adapter, node_dead);\n\tibmvnic_set_affinity(adapter);\n\treturn 0;\n}\n\nstatic int ibmvnic_cpu_down_prep(unsigned int cpu, struct hlist_node *node)\n{\n\tstruct ibmvnic_adapter *adapter;\n\n\tadapter = hlist_entry_safe(node, struct ibmvnic_adapter, node);\n\tibmvnic_clean_affinity(adapter);\n\treturn 0;\n}\n\nstatic enum cpuhp_state ibmvnic_online;\n\nstatic int ibmvnic_cpu_notif_add(struct ibmvnic_adapter *adapter)\n{\n\tint ret;\n\n\tret = cpuhp_state_add_instance_nocalls(ibmvnic_online, &adapter->node);\n\tif (ret)\n\t\treturn ret;\n\tret = cpuhp_state_add_instance_nocalls(CPUHP_IBMVNIC_DEAD,\n\t\t\t\t\t       &adapter->node_dead);\n\tif (!ret)\n\t\treturn ret;\n\tcpuhp_state_remove_instance_nocalls(ibmvnic_online, &adapter->node);\n\treturn ret;\n}\n\nstatic void ibmvnic_cpu_notif_remove(struct ibmvnic_adapter *adapter)\n{\n\tcpuhp_state_remove_instance_nocalls(ibmvnic_online, &adapter->node);\n\tcpuhp_state_remove_instance_nocalls(CPUHP_IBMVNIC_DEAD,\n\t\t\t\t\t    &adapter->node_dead);\n}\n\nstatic long h_reg_sub_crq(unsigned long unit_address, unsigned long token,\n\t\t\t  unsigned long length, unsigned long *number,\n\t\t\t  unsigned long *irq)\n{\n\tunsigned long retbuf[PLPAR_HCALL_BUFSIZE];\n\tlong rc;\n\n\trc = plpar_hcall(H_REG_SUB_CRQ, retbuf, unit_address, token, length);\n\t*number = retbuf[0];\n\t*irq = retbuf[1];\n\n\treturn rc;\n}\n\n \nstatic int ibmvnic_wait_for_completion(struct ibmvnic_adapter *adapter,\n\t\t\t\t       struct completion *comp_done,\n\t\t\t\t       unsigned long timeout)\n{\n\tstruct net_device *netdev;\n\tunsigned long div_timeout;\n\tu8 retry;\n\n\tnetdev = adapter->netdev;\n\tretry = 5;\n\tdiv_timeout = msecs_to_jiffies(timeout / retry);\n\twhile (true) {\n\t\tif (!adapter->crq.active) {\n\t\t\tnetdev_err(netdev, \"Device down!\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (!retry--)\n\t\t\tbreak;\n\t\tif (wait_for_completion_timeout(comp_done, div_timeout))\n\t\t\treturn 0;\n\t}\n\tnetdev_err(netdev, \"Operation timed out.\\n\");\n\treturn -ETIMEDOUT;\n}\n\n \nstatic bool reuse_ltb(struct ibmvnic_long_term_buff *ltb, int size)\n{\n\treturn (ltb->buff && ltb->size == size);\n}\n\n \nstatic int alloc_long_term_buff(struct ibmvnic_adapter *adapter,\n\t\t\t\tstruct ibmvnic_long_term_buff *ltb, int size)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tu64 prev = 0;\n\tint rc;\n\n\tif (!reuse_ltb(ltb, size)) {\n\t\tdev_dbg(dev,\n\t\t\t\"LTB size changed from 0x%llx to 0x%x, reallocating\\n\",\n\t\t\t ltb->size, size);\n\t\tprev = ltb->size;\n\t\tfree_long_term_buff(adapter, ltb);\n\t}\n\n\tif (ltb->buff) {\n\t\tdev_dbg(dev, \"Reusing LTB [map %d, size 0x%llx]\\n\",\n\t\t\tltb->map_id, ltb->size);\n\t} else {\n\t\tltb->buff = dma_alloc_coherent(dev, size, &ltb->addr,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!ltb->buff) {\n\t\t\tdev_err(dev, \"Couldn't alloc long term buffer\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tltb->size = size;\n\n\t\tltb->map_id = find_first_zero_bit(adapter->map_ids,\n\t\t\t\t\t\t  MAX_MAP_ID);\n\t\tbitmap_set(adapter->map_ids, ltb->map_id, 1);\n\n\t\tdev_dbg(dev,\n\t\t\t\"Allocated new LTB [map %d, size 0x%llx was 0x%llx]\\n\",\n\t\t\t ltb->map_id, ltb->size, prev);\n\t}\n\n\t \n\tmemset(ltb->buff, 0, ltb->size);\n\n\tmutex_lock(&adapter->fw_lock);\n\tadapter->fw_done_rc = 0;\n\treinit_completion(&adapter->fw_done);\n\n\trc = send_request_map(adapter, ltb->addr, ltb->size, ltb->map_id);\n\tif (rc) {\n\t\tdev_err(dev, \"send_request_map failed, rc = %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\trc = ibmvnic_wait_for_completion(adapter, &adapter->fw_done, 10000);\n\tif (rc) {\n\t\tdev_err(dev, \"LTB map request aborted or timed out, rc = %d\\n\",\n\t\t\trc);\n\t\tgoto out;\n\t}\n\n\tif (adapter->fw_done_rc) {\n\t\tdev_err(dev, \"Couldn't map LTB, rc = %d\\n\",\n\t\t\tadapter->fw_done_rc);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\t \n\tmutex_unlock(&adapter->fw_lock);\n\treturn rc;\n}\n\nstatic void free_long_term_buff(struct ibmvnic_adapter *adapter,\n\t\t\t\tstruct ibmvnic_long_term_buff *ltb)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\n\tif (!ltb->buff)\n\t\treturn;\n\n\t \n\tif (adapter->reset_reason != VNIC_RESET_FAILOVER &&\n\t    adapter->reset_reason != VNIC_RESET_MOBILITY &&\n\t    adapter->reset_reason != VNIC_RESET_TIMEOUT)\n\t\tsend_request_unmap(adapter, ltb->map_id);\n\n\tdma_free_coherent(dev, ltb->size, ltb->buff, ltb->addr);\n\n\tltb->buff = NULL;\n\t \n\tbitmap_clear(adapter->map_ids, ltb->map_id, 1);\n\tltb->map_id = 0;\n}\n\n \n\nstatic void free_ltb_set(struct ibmvnic_adapter *adapter,\n\t\t\t struct ibmvnic_ltb_set *ltb_set)\n{\n\tint i;\n\n\tfor (i = 0; i < ltb_set->num_ltbs; i++)\n\t\tfree_long_term_buff(adapter, &ltb_set->ltbs[i]);\n\n\tkfree(ltb_set->ltbs);\n\tltb_set->ltbs = NULL;\n\tltb_set->num_ltbs = 0;\n}\n\n \nstatic int alloc_ltb_set(struct ibmvnic_adapter *adapter,\n\t\t\t struct ibmvnic_ltb_set *ltb_set, int num_buffs,\n\t\t\t int buff_size)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tstruct ibmvnic_ltb_set old_set;\n\tstruct ibmvnic_ltb_set new_set;\n\tint rem_size;\n\tint tot_size;\t\t \n\tint ltb_size;\t\t \n\tint nltbs;\n\tint rc;\n\tint n;\n\tint i;\n\n\tdev_dbg(dev, \"%s() num_buffs %d, buff_size %d\\n\", __func__, num_buffs,\n\t\tbuff_size);\n\n\tltb_size = rounddown(IBMVNIC_ONE_LTB_SIZE, buff_size);\n\ttot_size = num_buffs * buff_size;\n\n\tif (ltb_size > tot_size)\n\t\tltb_size = tot_size;\n\n\tnltbs = tot_size / ltb_size;\n\tif (tot_size % ltb_size)\n\t\tnltbs++;\n\n\told_set = *ltb_set;\n\n\tif (old_set.num_ltbs == nltbs) {\n\t\tnew_set = old_set;\n\t} else {\n\t\tint tmp = nltbs * sizeof(struct ibmvnic_long_term_buff);\n\n\t\tnew_set.ltbs = kzalloc(tmp, GFP_KERNEL);\n\t\tif (!new_set.ltbs)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_set.num_ltbs = nltbs;\n\n\t\t \n\t\tfor (i = new_set.num_ltbs; i < old_set.num_ltbs; i++)\n\t\t\tfree_long_term_buff(adapter, &old_set.ltbs[i]);\n\n\t\t \n\t\tn = min(old_set.num_ltbs, new_set.num_ltbs);\n\t\tfor (i = 0; i < n; i++)\n\t\t\tnew_set.ltbs[i] = old_set.ltbs[i];\n\n\t\t \n\n\t\t \n\t\tkfree(old_set.ltbs);\n\t\told_set.ltbs = NULL;\n\t\told_set.num_ltbs = 0;\n\n\t\t \n\t\t*ltb_set = new_set;\n\t}\n\n\ti = 0;\n\trem_size = tot_size;\n\twhile (rem_size) {\n\t\tif (ltb_size > rem_size)\n\t\t\tltb_size = rem_size;\n\n\t\trem_size -= ltb_size;\n\n\t\trc = alloc_long_term_buff(adapter, &new_set.ltbs[i], ltb_size);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\ti++;\n\t}\n\n\tWARN_ON(i != new_set.num_ltbs);\n\n\treturn 0;\nout:\n\t \n\treturn rc;\n}\n\n \nstatic void map_rxpool_buf_to_ltb(struct ibmvnic_rx_pool *rxpool,\n\t\t\t\t  unsigned int bufidx,\n\t\t\t\t  struct ibmvnic_long_term_buff **ltbp,\n\t\t\t\t  unsigned int *offset)\n{\n\tstruct ibmvnic_long_term_buff *ltb;\n\tint nbufs;\t \n\tint i;\n\n\tWARN_ON(bufidx >= rxpool->size);\n\n\tfor (i = 0; i < rxpool->ltb_set.num_ltbs; i++) {\n\t\tltb = &rxpool->ltb_set.ltbs[i];\n\t\tnbufs = ltb->size / rxpool->buff_size;\n\t\tif (bufidx < nbufs)\n\t\t\tbreak;\n\t\tbufidx -= nbufs;\n\t}\n\n\t*ltbp = ltb;\n\t*offset = bufidx * rxpool->buff_size;\n}\n\n \nstatic void map_txpool_buf_to_ltb(struct ibmvnic_tx_pool *txpool,\n\t\t\t\t  unsigned int bufidx,\n\t\t\t\t  struct ibmvnic_long_term_buff **ltbp,\n\t\t\t\t  unsigned int *offset)\n{\n\tstruct ibmvnic_long_term_buff *ltb;\n\tint nbufs;\t \n\tint i;\n\n\tWARN_ON_ONCE(bufidx >= txpool->num_buffers);\n\n\tfor (i = 0; i < txpool->ltb_set.num_ltbs; i++) {\n\t\tltb = &txpool->ltb_set.ltbs[i];\n\t\tnbufs = ltb->size / txpool->buf_size;\n\t\tif (bufidx < nbufs)\n\t\t\tbreak;\n\t\tbufidx -= nbufs;\n\t}\n\n\t*ltbp = ltb;\n\t*offset = bufidx * txpool->buf_size;\n}\n\nstatic void deactivate_rx_pools(struct ibmvnic_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_active_rx_pools; i++)\n\t\tadapter->rx_pool[i].active = 0;\n}\n\nstatic void replenish_rx_pool(struct ibmvnic_adapter *adapter,\n\t\t\t      struct ibmvnic_rx_pool *pool)\n{\n\tint count = pool->size - atomic_read(&pool->available);\n\tu64 handle = adapter->rx_scrq[pool->index]->handle;\n\tstruct device *dev = &adapter->vdev->dev;\n\tstruct ibmvnic_ind_xmit_queue *ind_bufp;\n\tstruct ibmvnic_sub_crq_queue *rx_scrq;\n\tstruct ibmvnic_long_term_buff *ltb;\n\tunion sub_crq *sub_crq;\n\tint buffers_added = 0;\n\tunsigned long lpar_rc;\n\tstruct sk_buff *skb;\n\tunsigned int offset;\n\tdma_addr_t dma_addr;\n\tunsigned char *dst;\n\tint shift = 0;\n\tint bufidx;\n\tint i;\n\n\tif (!pool->active)\n\t\treturn;\n\n\trx_scrq = adapter->rx_scrq[pool->index];\n\tind_bufp = &rx_scrq->ind_buf;\n\n\t \n\tfor (i = ind_bufp->index; i < count; ++i) {\n\t\tbufidx = pool->free_map[pool->next_free];\n\n\t\t \n\t\tskb = pool->rx_buff[bufidx].skb;\n\t\tif (!skb) {\n\t\t\tskb = netdev_alloc_skb(adapter->netdev,\n\t\t\t\t\t       pool->buff_size);\n\t\t\tif (!skb) {\n\t\t\t\tdev_err(dev, \"Couldn't replenish rx buff\\n\");\n\t\t\t\tadapter->replenish_no_mem++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpool->free_map[pool->next_free] = IBMVNIC_INVALID_MAP;\n\t\tpool->next_free = (pool->next_free + 1) % pool->size;\n\n\t\t \n\t\tmap_rxpool_buf_to_ltb(pool, bufidx, &ltb, &offset);\n\t\tdst = ltb->buff + offset;\n\t\tmemset(dst, 0, pool->buff_size);\n\t\tdma_addr = ltb->addr + offset;\n\n\t\t \n\t\tpool->rx_buff[bufidx].data = dst;\n\t\tpool->rx_buff[bufidx].dma = dma_addr;\n\t\tpool->rx_buff[bufidx].skb = skb;\n\t\tpool->rx_buff[bufidx].pool_index = pool->index;\n\t\tpool->rx_buff[bufidx].size = pool->buff_size;\n\n\t\t \n\t\tsub_crq = &ind_bufp->indir_arr[ind_bufp->index++];\n\t\tmemset(sub_crq, 0, sizeof(*sub_crq));\n\t\tsub_crq->rx_add.first = IBMVNIC_CRQ_CMD;\n\t\tsub_crq->rx_add.correlator =\n\t\t    cpu_to_be64((u64)&pool->rx_buff[bufidx]);\n\t\tsub_crq->rx_add.ioba = cpu_to_be32(dma_addr);\n\t\tsub_crq->rx_add.map_id = ltb->map_id;\n\n\t\t \n#ifdef __LITTLE_ENDIAN__\n\t\tshift = 8;\n#endif\n\t\tsub_crq->rx_add.len = cpu_to_be32(pool->buff_size << shift);\n\n\t\t \n\t\tif (ind_bufp->index == IBMVNIC_MAX_IND_DESCS ||\n\t\t    i == count - 1) {\n\t\t\tlpar_rc =\n\t\t\t\tsend_subcrq_indirect(adapter, handle,\n\t\t\t\t\t\t     (u64)ind_bufp->indir_dma,\n\t\t\t\t\t\t     (u64)ind_bufp->index);\n\t\t\tif (lpar_rc != H_SUCCESS)\n\t\t\t\tgoto failure;\n\t\t\tbuffers_added += ind_bufp->index;\n\t\t\tadapter->replenish_add_buff_success += ind_bufp->index;\n\t\t\tind_bufp->index = 0;\n\t\t}\n\t}\n\tatomic_add(buffers_added, &pool->available);\n\treturn;\n\nfailure:\n\tif (lpar_rc != H_PARAMETER && lpar_rc != H_CLOSED)\n\t\tdev_err_ratelimited(dev, \"rx: replenish packet buffer failed\\n\");\n\tfor (i = ind_bufp->index - 1; i >= 0; --i) {\n\t\tstruct ibmvnic_rx_buff *rx_buff;\n\n\t\tpool->next_free = pool->next_free == 0 ?\n\t\t\t\t  pool->size - 1 : pool->next_free - 1;\n\t\tsub_crq = &ind_bufp->indir_arr[i];\n\t\trx_buff = (struct ibmvnic_rx_buff *)\n\t\t\t\tbe64_to_cpu(sub_crq->rx_add.correlator);\n\t\tbufidx = (int)(rx_buff - pool->rx_buff);\n\t\tpool->free_map[pool->next_free] = bufidx;\n\t\tdev_kfree_skb_any(pool->rx_buff[bufidx].skb);\n\t\tpool->rx_buff[bufidx].skb = NULL;\n\t}\n\tadapter->replenish_add_buff_failure += ind_bufp->index;\n\tatomic_add(buffers_added, &pool->available);\n\tind_bufp->index = 0;\n\tif (lpar_rc == H_CLOSED || adapter->failover_pending) {\n\t\t \n\t\tdeactivate_rx_pools(adapter);\n\t\tnetif_carrier_off(adapter->netdev);\n\t}\n}\n\nstatic void replenish_pools(struct ibmvnic_adapter *adapter)\n{\n\tint i;\n\n\tadapter->replenish_task_cycles++;\n\tfor (i = 0; i < adapter->num_active_rx_pools; i++) {\n\t\tif (adapter->rx_pool[i].active)\n\t\t\treplenish_rx_pool(adapter, &adapter->rx_pool[i]);\n\t}\n\n\tnetdev_dbg(adapter->netdev, \"Replenished %d pools\\n\", i);\n}\n\nstatic void release_stats_buffers(struct ibmvnic_adapter *adapter)\n{\n\tkfree(adapter->tx_stats_buffers);\n\tkfree(adapter->rx_stats_buffers);\n\tadapter->tx_stats_buffers = NULL;\n\tadapter->rx_stats_buffers = NULL;\n}\n\nstatic int init_stats_buffers(struct ibmvnic_adapter *adapter)\n{\n\tadapter->tx_stats_buffers =\n\t\t\t\tkcalloc(IBMVNIC_MAX_QUEUES,\n\t\t\t\t\tsizeof(struct ibmvnic_tx_queue_stats),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!adapter->tx_stats_buffers)\n\t\treturn -ENOMEM;\n\n\tadapter->rx_stats_buffers =\n\t\t\t\tkcalloc(IBMVNIC_MAX_QUEUES,\n\t\t\t\t\tsizeof(struct ibmvnic_rx_queue_stats),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!adapter->rx_stats_buffers)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void release_stats_token(struct ibmvnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\n\tif (!adapter->stats_token)\n\t\treturn;\n\n\tdma_unmap_single(dev, adapter->stats_token,\n\t\t\t sizeof(struct ibmvnic_statistics),\n\t\t\t DMA_FROM_DEVICE);\n\tadapter->stats_token = 0;\n}\n\nstatic int init_stats_token(struct ibmvnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tdma_addr_t stok;\n\tint rc;\n\n\tstok = dma_map_single(dev, &adapter->stats,\n\t\t\t      sizeof(struct ibmvnic_statistics),\n\t\t\t      DMA_FROM_DEVICE);\n\trc = dma_mapping_error(dev, stok);\n\tif (rc) {\n\t\tdev_err(dev, \"Couldn't map stats buffer, rc = %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tadapter->stats_token = stok;\n\tnetdev_dbg(adapter->netdev, \"Stats token initialized (%llx)\\n\", stok);\n\treturn 0;\n}\n\n \nstatic void release_rx_pools(struct ibmvnic_adapter *adapter)\n{\n\tstruct ibmvnic_rx_pool *rx_pool;\n\tint i, j;\n\n\tif (!adapter->rx_pool)\n\t\treturn;\n\n\tfor (i = 0; i < adapter->num_active_rx_pools; i++) {\n\t\trx_pool = &adapter->rx_pool[i];\n\n\t\tnetdev_dbg(adapter->netdev, \"Releasing rx_pool[%d]\\n\", i);\n\n\t\tkfree(rx_pool->free_map);\n\n\t\tfree_ltb_set(adapter, &rx_pool->ltb_set);\n\n\t\tif (!rx_pool->rx_buff)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < rx_pool->size; j++) {\n\t\t\tif (rx_pool->rx_buff[j].skb) {\n\t\t\t\tdev_kfree_skb_any(rx_pool->rx_buff[j].skb);\n\t\t\t\trx_pool->rx_buff[j].skb = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(rx_pool->rx_buff);\n\t}\n\n\tkfree(adapter->rx_pool);\n\tadapter->rx_pool = NULL;\n\tadapter->num_active_rx_pools = 0;\n\tadapter->prev_rx_pool_size = 0;\n}\n\n \nstatic bool reuse_rx_pools(struct ibmvnic_adapter *adapter)\n{\n\tu64 old_num_pools, new_num_pools;\n\tu64 old_pool_size, new_pool_size;\n\tu64 old_buff_size, new_buff_size;\n\n\tif (!adapter->rx_pool)\n\t\treturn false;\n\n\told_num_pools = adapter->num_active_rx_pools;\n\tnew_num_pools = adapter->req_rx_queues;\n\n\told_pool_size = adapter->prev_rx_pool_size;\n\tnew_pool_size = adapter->req_rx_add_entries_per_subcrq;\n\n\told_buff_size = adapter->prev_rx_buf_sz;\n\tnew_buff_size = adapter->cur_rx_buf_sz;\n\n\tif (old_buff_size != new_buff_size ||\n\t    old_num_pools != new_num_pools ||\n\t    old_pool_size != new_pool_size)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int init_rx_pools(struct net_device *netdev)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tstruct device *dev = &adapter->vdev->dev;\n\tstruct ibmvnic_rx_pool *rx_pool;\n\tu64 num_pools;\n\tu64 pool_size;\t\t \n\tu64 buff_size;\n\tint i, j, rc;\n\n\tpool_size = adapter->req_rx_add_entries_per_subcrq;\n\tnum_pools = adapter->req_rx_queues;\n\tbuff_size = adapter->cur_rx_buf_sz;\n\n\tif (reuse_rx_pools(adapter)) {\n\t\tdev_dbg(dev, \"Reusing rx pools\\n\");\n\t\tgoto update_ltb;\n\t}\n\n\t \n\trelease_rx_pools(adapter);\n\n\tadapter->rx_pool = kcalloc(num_pools,\n\t\t\t\t   sizeof(struct ibmvnic_rx_pool),\n\t\t\t\t   GFP_KERNEL);\n\tif (!adapter->rx_pool) {\n\t\tdev_err(dev, \"Failed to allocate rx pools\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tadapter->num_active_rx_pools = num_pools;\n\n\tfor (i = 0; i < num_pools; i++) {\n\t\trx_pool = &adapter->rx_pool[i];\n\n\t\tnetdev_dbg(adapter->netdev,\n\t\t\t   \"Initializing rx_pool[%d], %lld buffs, %lld bytes each\\n\",\n\t\t\t   i, pool_size, buff_size);\n\n\t\trx_pool->size = pool_size;\n\t\trx_pool->index = i;\n\t\trx_pool->buff_size = ALIGN(buff_size, L1_CACHE_BYTES);\n\n\t\trx_pool->free_map = kcalloc(rx_pool->size, sizeof(int),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!rx_pool->free_map) {\n\t\t\tdev_err(dev, \"Couldn't alloc free_map %d\\n\", i);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\trx_pool->rx_buff = kcalloc(rx_pool->size,\n\t\t\t\t\t   sizeof(struct ibmvnic_rx_buff),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!rx_pool->rx_buff) {\n\t\t\tdev_err(dev, \"Couldn't alloc rx buffers\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\n\tadapter->prev_rx_pool_size = pool_size;\n\tadapter->prev_rx_buf_sz = adapter->cur_rx_buf_sz;\n\nupdate_ltb:\n\tfor (i = 0; i < num_pools; i++) {\n\t\trx_pool = &adapter->rx_pool[i];\n\t\tdev_dbg(dev, \"Updating LTB for rx pool %d [%d, %d]\\n\",\n\t\t\ti, rx_pool->size, rx_pool->buff_size);\n\n\t\trc = alloc_ltb_set(adapter, &rx_pool->ltb_set,\n\t\t\t\t   rx_pool->size, rx_pool->buff_size);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tfor (j = 0; j < rx_pool->size; ++j) {\n\t\t\tstruct ibmvnic_rx_buff *rx_buff;\n\n\t\t\trx_pool->free_map[j] = j;\n\n\t\t\t \n\t\t\trx_buff = &rx_pool->rx_buff[j];\n\t\t\trx_buff->dma = 0;\n\t\t\trx_buff->data = 0;\n\t\t\trx_buff->size = 0;\n\t\t\trx_buff->pool_index = 0;\n\t\t}\n\n\t\t \n\t\tatomic_set(&rx_pool->available, 0);\n\t\trx_pool->next_alloc = 0;\n\t\trx_pool->next_free = 0;\n\t\t \n\t\trx_pool->active = 1;\n\t}\n\treturn 0;\nout_release:\n\trelease_rx_pools(adapter);\nout:\n\t \n\treturn rc;\n}\n\nstatic void release_vpd_data(struct ibmvnic_adapter *adapter)\n{\n\tif (!adapter->vpd)\n\t\treturn;\n\n\tkfree(adapter->vpd->buff);\n\tkfree(adapter->vpd);\n\n\tadapter->vpd = NULL;\n}\n\nstatic void release_one_tx_pool(struct ibmvnic_adapter *adapter,\n\t\t\t\tstruct ibmvnic_tx_pool *tx_pool)\n{\n\tkfree(tx_pool->tx_buff);\n\tkfree(tx_pool->free_map);\n\tfree_ltb_set(adapter, &tx_pool->ltb_set);\n}\n\n \nstatic void release_tx_pools(struct ibmvnic_adapter *adapter)\n{\n\tint i;\n\n\t \n\tif (!adapter->tx_pool)\n\t\treturn;\n\n\tfor (i = 0; i < adapter->num_active_tx_pools; i++) {\n\t\trelease_one_tx_pool(adapter, &adapter->tx_pool[i]);\n\t\trelease_one_tx_pool(adapter, &adapter->tso_pool[i]);\n\t}\n\n\tkfree(adapter->tx_pool);\n\tadapter->tx_pool = NULL;\n\tkfree(adapter->tso_pool);\n\tadapter->tso_pool = NULL;\n\tadapter->num_active_tx_pools = 0;\n\tadapter->prev_tx_pool_size = 0;\n}\n\nstatic int init_one_tx_pool(struct net_device *netdev,\n\t\t\t    struct ibmvnic_tx_pool *tx_pool,\n\t\t\t    int pool_size, int buf_size)\n{\n\tint i;\n\n\ttx_pool->tx_buff = kcalloc(pool_size,\n\t\t\t\t   sizeof(struct ibmvnic_tx_buff),\n\t\t\t\t   GFP_KERNEL);\n\tif (!tx_pool->tx_buff)\n\t\treturn -ENOMEM;\n\n\ttx_pool->free_map = kcalloc(pool_size, sizeof(int), GFP_KERNEL);\n\tif (!tx_pool->free_map) {\n\t\tkfree(tx_pool->tx_buff);\n\t\ttx_pool->tx_buff = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < pool_size; i++)\n\t\ttx_pool->free_map[i] = i;\n\n\ttx_pool->consumer_index = 0;\n\ttx_pool->producer_index = 0;\n\ttx_pool->num_buffers = pool_size;\n\ttx_pool->buf_size = buf_size;\n\n\treturn 0;\n}\n\n \nstatic bool reuse_tx_pools(struct ibmvnic_adapter *adapter)\n{\n\tu64 old_num_pools, new_num_pools;\n\tu64 old_pool_size, new_pool_size;\n\tu64 old_mtu, new_mtu;\n\n\tif (!adapter->tx_pool)\n\t\treturn false;\n\n\told_num_pools = adapter->num_active_tx_pools;\n\tnew_num_pools = adapter->num_active_tx_scrqs;\n\told_pool_size = adapter->prev_tx_pool_size;\n\tnew_pool_size = adapter->req_tx_entries_per_subcrq;\n\told_mtu = adapter->prev_mtu;\n\tnew_mtu = adapter->req_mtu;\n\n\tif (old_mtu != new_mtu ||\n\t    old_num_pools != new_num_pools ||\n\t    old_pool_size != new_pool_size)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int init_tx_pools(struct net_device *netdev)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tstruct device *dev = &adapter->vdev->dev;\n\tint num_pools;\n\tu64 pool_size;\t\t \n\tu64 buff_size;\n\tint i, j, rc;\n\n\tnum_pools = adapter->req_tx_queues;\n\n\t \n\tif (reuse_tx_pools(adapter)) {\n\t\tnetdev_dbg(netdev, \"Reusing tx pools\\n\");\n\t\tgoto update_ltb;\n\t}\n\n\t \n\trelease_tx_pools(adapter);\n\n\tpool_size = adapter->req_tx_entries_per_subcrq;\n\tnum_pools = adapter->num_active_tx_scrqs;\n\n\tadapter->tx_pool = kcalloc(num_pools,\n\t\t\t\t   sizeof(struct ibmvnic_tx_pool), GFP_KERNEL);\n\tif (!adapter->tx_pool)\n\t\treturn -ENOMEM;\n\n\tadapter->tso_pool = kcalloc(num_pools,\n\t\t\t\t    sizeof(struct ibmvnic_tx_pool), GFP_KERNEL);\n\t \n\tif (!adapter->tso_pool) {\n\t\tkfree(adapter->tx_pool);\n\t\tadapter->tx_pool = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tadapter->num_active_tx_pools = num_pools;\n\n\tbuff_size = adapter->req_mtu + VLAN_HLEN;\n\tbuff_size = ALIGN(buff_size, L1_CACHE_BYTES);\n\n\tfor (i = 0; i < num_pools; i++) {\n\t\tdev_dbg(dev, \"Init tx pool %d [%llu, %llu]\\n\",\n\t\t\ti, adapter->req_tx_entries_per_subcrq, buff_size);\n\n\t\trc = init_one_tx_pool(netdev, &adapter->tx_pool[i],\n\t\t\t\t      pool_size, buff_size);\n\t\tif (rc)\n\t\t\tgoto out_release;\n\n\t\trc = init_one_tx_pool(netdev, &adapter->tso_pool[i],\n\t\t\t\t      IBMVNIC_TSO_BUFS,\n\t\t\t\t      IBMVNIC_TSO_BUF_SZ);\n\t\tif (rc)\n\t\t\tgoto out_release;\n\t}\n\n\tadapter->prev_tx_pool_size = pool_size;\n\tadapter->prev_mtu = adapter->req_mtu;\n\nupdate_ltb:\n\t \n\trc = -1;\n\tfor (i = 0; i < num_pools; i++) {\n\t\tstruct ibmvnic_tx_pool *tso_pool;\n\t\tstruct ibmvnic_tx_pool *tx_pool;\n\n\t\ttx_pool = &adapter->tx_pool[i];\n\n\t\tdev_dbg(dev, \"Updating LTB for tx pool %d [%d, %d]\\n\",\n\t\t\ti, tx_pool->num_buffers, tx_pool->buf_size);\n\n\t\trc = alloc_ltb_set(adapter, &tx_pool->ltb_set,\n\t\t\t\t   tx_pool->num_buffers, tx_pool->buf_size);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\ttx_pool->consumer_index = 0;\n\t\ttx_pool->producer_index = 0;\n\n\t\tfor (j = 0; j < tx_pool->num_buffers; j++)\n\t\t\ttx_pool->free_map[j] = j;\n\n\t\ttso_pool = &adapter->tso_pool[i];\n\n\t\tdev_dbg(dev, \"Updating LTB for tso pool %d [%d, %d]\\n\",\n\t\t\ti, tso_pool->num_buffers, tso_pool->buf_size);\n\n\t\trc = alloc_ltb_set(adapter, &tso_pool->ltb_set,\n\t\t\t\t   tso_pool->num_buffers, tso_pool->buf_size);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\ttso_pool->consumer_index = 0;\n\t\ttso_pool->producer_index = 0;\n\n\t\tfor (j = 0; j < tso_pool->num_buffers; j++)\n\t\t\ttso_pool->free_map[j] = j;\n\t}\n\n\treturn 0;\nout_release:\n\trelease_tx_pools(adapter);\nout:\n\t \n\treturn rc;\n}\n\nstatic void ibmvnic_napi_enable(struct ibmvnic_adapter *adapter)\n{\n\tint i;\n\n\tif (adapter->napi_enabled)\n\t\treturn;\n\n\tfor (i = 0; i < adapter->req_rx_queues; i++)\n\t\tnapi_enable(&adapter->napi[i]);\n\n\tadapter->napi_enabled = true;\n}\n\nstatic void ibmvnic_napi_disable(struct ibmvnic_adapter *adapter)\n{\n\tint i;\n\n\tif (!adapter->napi_enabled)\n\t\treturn;\n\n\tfor (i = 0; i < adapter->req_rx_queues; i++) {\n\t\tnetdev_dbg(adapter->netdev, \"Disabling napi[%d]\\n\", i);\n\t\tnapi_disable(&adapter->napi[i]);\n\t}\n\n\tadapter->napi_enabled = false;\n}\n\nstatic int init_napi(struct ibmvnic_adapter *adapter)\n{\n\tint i;\n\n\tadapter->napi = kcalloc(adapter->req_rx_queues,\n\t\t\t\tsizeof(struct napi_struct), GFP_KERNEL);\n\tif (!adapter->napi)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < adapter->req_rx_queues; i++) {\n\t\tnetdev_dbg(adapter->netdev, \"Adding napi[%d]\\n\", i);\n\t\tnetif_napi_add(adapter->netdev, &adapter->napi[i],\n\t\t\t       ibmvnic_poll);\n\t}\n\n\tadapter->num_active_rx_napi = adapter->req_rx_queues;\n\treturn 0;\n}\n\nstatic void release_napi(struct ibmvnic_adapter *adapter)\n{\n\tint i;\n\n\tif (!adapter->napi)\n\t\treturn;\n\n\tfor (i = 0; i < adapter->num_active_rx_napi; i++) {\n\t\tnetdev_dbg(adapter->netdev, \"Releasing napi[%d]\\n\", i);\n\t\tnetif_napi_del(&adapter->napi[i]);\n\t}\n\n\tkfree(adapter->napi);\n\tadapter->napi = NULL;\n\tadapter->num_active_rx_napi = 0;\n\tadapter->napi_enabled = false;\n}\n\nstatic const char *adapter_state_to_string(enum vnic_state state)\n{\n\tswitch (state) {\n\tcase VNIC_PROBING:\n\t\treturn \"PROBING\";\n\tcase VNIC_PROBED:\n\t\treturn \"PROBED\";\n\tcase VNIC_OPENING:\n\t\treturn \"OPENING\";\n\tcase VNIC_OPEN:\n\t\treturn \"OPEN\";\n\tcase VNIC_CLOSING:\n\t\treturn \"CLOSING\";\n\tcase VNIC_CLOSED:\n\t\treturn \"CLOSED\";\n\tcase VNIC_REMOVING:\n\t\treturn \"REMOVING\";\n\tcase VNIC_REMOVED:\n\t\treturn \"REMOVED\";\n\tcase VNIC_DOWN:\n\t\treturn \"DOWN\";\n\t}\n\treturn \"UNKNOWN\";\n}\n\nstatic int ibmvnic_login(struct net_device *netdev)\n{\n\tunsigned long flags, timeout = msecs_to_jiffies(20000);\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tint retry_count = 0;\n\tint retries = 10;\n\tbool retry;\n\tint rc;\n\n\tdo {\n\t\tretry = false;\n\t\tif (retry_count > retries) {\n\t\t\tnetdev_warn(netdev, \"Login attempts exceeded\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tadapter->init_done_rc = 0;\n\t\treinit_completion(&adapter->init_done);\n\t\trc = send_login(adapter);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tif (!wait_for_completion_timeout(&adapter->init_done,\n\t\t\t\t\t\t timeout)) {\n\t\t\tnetdev_warn(netdev, \"Login timed out\\n\");\n\t\t\tadapter->login_pending = false;\n\t\t\tgoto partial_reset;\n\t\t}\n\n\t\tif (adapter->init_done_rc == ABORTED) {\n\t\t\tnetdev_warn(netdev, \"Login aborted, retrying...\\n\");\n\t\t\tretry = true;\n\t\t\tadapter->init_done_rc = 0;\n\t\t\tretry_count++;\n\t\t\t \n\t\t\tmsleep(500);\n\t\t} else if (adapter->init_done_rc == PARTIALSUCCESS) {\n\t\t\tretry_count++;\n\t\t\trelease_sub_crqs(adapter, 1);\n\n\t\t\tretry = true;\n\t\t\tnetdev_dbg(netdev,\n\t\t\t\t   \"Received partial success, retrying...\\n\");\n\t\t\tadapter->init_done_rc = 0;\n\t\t\treinit_completion(&adapter->init_done);\n\t\t\tsend_query_cap(adapter);\n\t\t\tif (!wait_for_completion_timeout(&adapter->init_done,\n\t\t\t\t\t\t\t timeout)) {\n\t\t\t\tnetdev_warn(netdev,\n\t\t\t\t\t    \"Capabilities query timed out\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\n\t\t\trc = init_sub_crqs(adapter);\n\t\t\tif (rc) {\n\t\t\t\tnetdev_warn(netdev,\n\t\t\t\t\t    \"SCRQ initialization failed\\n\");\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\trc = init_sub_crq_irqs(adapter);\n\t\t\tif (rc) {\n\t\t\t\tnetdev_warn(netdev,\n\t\t\t\t\t    \"SCRQ irq initialization failed\\n\");\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t \n\t\t} else if (adapter->init_done_rc) {\n\t\t\tnetdev_warn(netdev, \"Adapter login failed, init_done_rc = %d\\n\",\n\t\t\t\t    adapter->init_done_rc);\n\npartial_reset:\n\t\t\t \n\t\t\tnetdev_warn(netdev,\n\t\t\t\t    \"Freeing and re-registering CRQs before attempting to login again\\n\");\n\t\t\tretry = true;\n\t\t\tadapter->init_done_rc = 0;\n\t\t\trelease_sub_crqs(adapter, true);\n\t\t\t \n\t\t\tdo {\n\t\t\t\treinit_init_done(adapter);\n\t\t\t\t \n\t\t\t\tadapter->failover_pending = false;\n\t\t\t\trelease_crq_queue(adapter);\n\t\t\t\t \n\t\t\t\tmsleep(1500);\n\t\t\t\t \n\t\t\t\tspin_lock_irqsave(&adapter->rwi_lock, flags);\n\t\t\t\tflush_reset_queue(adapter);\n\t\t\t\tspin_unlock_irqrestore(&adapter->rwi_lock,\n\t\t\t\t\t\t       flags);\n\n\t\t\t\trc = init_crq_queue(adapter);\n\t\t\t\tif (rc) {\n\t\t\t\t\tnetdev_err(netdev, \"login recovery: init CRQ failed %d\\n\",\n\t\t\t\t\t\t   rc);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\n\t\t\t\trc = ibmvnic_reset_init(adapter, false);\n\t\t\t\tif (rc)\n\t\t\t\t\tnetdev_err(netdev, \"login recovery: Reset init failed %d\\n\",\n\t\t\t\t\t\t   rc);\n\t\t\t\t \n\t\t\t} while (rc == -EAGAIN && retry_count++ < retries);\n\t\t}\n\t} while (retry);\n\n\t__ibmvnic_set_mac(netdev, adapter->mac_addr);\n\n\tnetdev_dbg(netdev, \"[S:%s] Login succeeded\\n\", adapter_state_to_string(adapter->state));\n\treturn 0;\n}\n\nstatic void release_login_buffer(struct ibmvnic_adapter *adapter)\n{\n\tif (!adapter->login_buf)\n\t\treturn;\n\n\tdma_unmap_single(&adapter->vdev->dev, adapter->login_buf_token,\n\t\t\t adapter->login_buf_sz, DMA_TO_DEVICE);\n\tkfree(adapter->login_buf);\n\tadapter->login_buf = NULL;\n}\n\nstatic void release_login_rsp_buffer(struct ibmvnic_adapter *adapter)\n{\n\tif (!adapter->login_rsp_buf)\n\t\treturn;\n\n\tdma_unmap_single(&adapter->vdev->dev, adapter->login_rsp_buf_token,\n\t\t\t adapter->login_rsp_buf_sz, DMA_FROM_DEVICE);\n\tkfree(adapter->login_rsp_buf);\n\tadapter->login_rsp_buf = NULL;\n}\n\nstatic void release_resources(struct ibmvnic_adapter *adapter)\n{\n\trelease_vpd_data(adapter);\n\n\trelease_napi(adapter);\n\trelease_login_buffer(adapter);\n\trelease_login_rsp_buffer(adapter);\n}\n\nstatic int set_link_state(struct ibmvnic_adapter *adapter, u8 link_state)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tunsigned long timeout = msecs_to_jiffies(20000);\n\tunion ibmvnic_crq crq;\n\tbool resend;\n\tint rc;\n\n\tnetdev_dbg(netdev, \"setting link state %d\\n\", link_state);\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.logical_link_state.first = IBMVNIC_CRQ_CMD;\n\tcrq.logical_link_state.cmd = LOGICAL_LINK_STATE;\n\tcrq.logical_link_state.link_state = link_state;\n\n\tdo {\n\t\tresend = false;\n\n\t\treinit_completion(&adapter->init_done);\n\t\trc = ibmvnic_send_crq(adapter, &crq);\n\t\tif (rc) {\n\t\t\tnetdev_err(netdev, \"Failed to set link state\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (!wait_for_completion_timeout(&adapter->init_done,\n\t\t\t\t\t\t timeout)) {\n\t\t\tnetdev_err(netdev, \"timeout setting link state\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tif (adapter->init_done_rc == PARTIALSUCCESS) {\n\t\t\t \n\t\t\tmdelay(1000);\n\t\t\tresend = true;\n\t\t} else if (adapter->init_done_rc) {\n\t\t\tnetdev_warn(netdev, \"Unable to set link state, rc=%d\\n\",\n\t\t\t\t    adapter->init_done_rc);\n\t\t\treturn adapter->init_done_rc;\n\t\t}\n\t} while (resend);\n\n\treturn 0;\n}\n\nstatic int set_real_num_queues(struct net_device *netdev)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tint rc;\n\n\tnetdev_dbg(netdev, \"Setting real tx/rx queues (%llx/%llx)\\n\",\n\t\t   adapter->req_tx_queues, adapter->req_rx_queues);\n\n\trc = netif_set_real_num_tx_queues(netdev, adapter->req_tx_queues);\n\tif (rc) {\n\t\tnetdev_err(netdev, \"failed to set the number of tx queues\\n\");\n\t\treturn rc;\n\t}\n\n\trc = netif_set_real_num_rx_queues(netdev, adapter->req_rx_queues);\n\tif (rc)\n\t\tnetdev_err(netdev, \"failed to set the number of rx queues\\n\");\n\n\treturn rc;\n}\n\nstatic int ibmvnic_get_vpd(struct ibmvnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tunion ibmvnic_crq crq;\n\tint len = 0;\n\tint rc;\n\n\tif (adapter->vpd->buff)\n\t\tlen = adapter->vpd->len;\n\n\tmutex_lock(&adapter->fw_lock);\n\tadapter->fw_done_rc = 0;\n\treinit_completion(&adapter->fw_done);\n\n\tcrq.get_vpd_size.first = IBMVNIC_CRQ_CMD;\n\tcrq.get_vpd_size.cmd = GET_VPD_SIZE;\n\trc = ibmvnic_send_crq(adapter, &crq);\n\tif (rc) {\n\t\tmutex_unlock(&adapter->fw_lock);\n\t\treturn rc;\n\t}\n\n\trc = ibmvnic_wait_for_completion(adapter, &adapter->fw_done, 10000);\n\tif (rc) {\n\t\tdev_err(dev, \"Could not retrieve VPD size, rc = %d\\n\", rc);\n\t\tmutex_unlock(&adapter->fw_lock);\n\t\treturn rc;\n\t}\n\tmutex_unlock(&adapter->fw_lock);\n\n\tif (!adapter->vpd->len)\n\t\treturn -ENODATA;\n\n\tif (!adapter->vpd->buff)\n\t\tadapter->vpd->buff = kzalloc(adapter->vpd->len, GFP_KERNEL);\n\telse if (adapter->vpd->len != len)\n\t\tadapter->vpd->buff =\n\t\t\tkrealloc(adapter->vpd->buff,\n\t\t\t\t adapter->vpd->len, GFP_KERNEL);\n\n\tif (!adapter->vpd->buff) {\n\t\tdev_err(dev, \"Could allocate VPD buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tadapter->vpd->dma_addr =\n\t\tdma_map_single(dev, adapter->vpd->buff, adapter->vpd->len,\n\t\t\t       DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, adapter->vpd->dma_addr)) {\n\t\tdev_err(dev, \"Could not map VPD buffer\\n\");\n\t\tkfree(adapter->vpd->buff);\n\t\tadapter->vpd->buff = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&adapter->fw_lock);\n\tadapter->fw_done_rc = 0;\n\treinit_completion(&adapter->fw_done);\n\n\tcrq.get_vpd.first = IBMVNIC_CRQ_CMD;\n\tcrq.get_vpd.cmd = GET_VPD;\n\tcrq.get_vpd.ioba = cpu_to_be32(adapter->vpd->dma_addr);\n\tcrq.get_vpd.len = cpu_to_be32((u32)adapter->vpd->len);\n\trc = ibmvnic_send_crq(adapter, &crq);\n\tif (rc) {\n\t\tkfree(adapter->vpd->buff);\n\t\tadapter->vpd->buff = NULL;\n\t\tmutex_unlock(&adapter->fw_lock);\n\t\treturn rc;\n\t}\n\n\trc = ibmvnic_wait_for_completion(adapter, &adapter->fw_done, 10000);\n\tif (rc) {\n\t\tdev_err(dev, \"Unable to retrieve VPD, rc = %d\\n\", rc);\n\t\tkfree(adapter->vpd->buff);\n\t\tadapter->vpd->buff = NULL;\n\t\tmutex_unlock(&adapter->fw_lock);\n\t\treturn rc;\n\t}\n\n\tmutex_unlock(&adapter->fw_lock);\n\treturn 0;\n}\n\nstatic int init_resources(struct ibmvnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint rc;\n\n\trc = set_real_num_queues(netdev);\n\tif (rc)\n\t\treturn rc;\n\n\tadapter->vpd = kzalloc(sizeof(*adapter->vpd), GFP_KERNEL);\n\tif (!adapter->vpd)\n\t\treturn -ENOMEM;\n\n\t \n\trc = ibmvnic_get_vpd(adapter);\n\tif (rc) {\n\t\tnetdev_err(netdev, \"failed to initialize Vital Product Data (VPD)\\n\");\n\t\treturn rc;\n\t}\n\n\trc = init_napi(adapter);\n\tif (rc)\n\t\treturn rc;\n\n\tsend_query_map(adapter);\n\n\trc = init_rx_pools(netdev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = init_tx_pools(netdev);\n\treturn rc;\n}\n\nstatic int __ibmvnic_open(struct net_device *netdev)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tenum vnic_state prev_state = adapter->state;\n\tint i, rc;\n\n\tadapter->state = VNIC_OPENING;\n\treplenish_pools(adapter);\n\tibmvnic_napi_enable(adapter);\n\n\t \n\tfor (i = 0; i < adapter->req_rx_queues; i++) {\n\t\tnetdev_dbg(netdev, \"Enabling rx_scrq[%d] irq\\n\", i);\n\t\tif (prev_state == VNIC_CLOSED)\n\t\t\tenable_irq(adapter->rx_scrq[i]->irq);\n\t\tenable_scrq_irq(adapter, adapter->rx_scrq[i]);\n\t}\n\n\tfor (i = 0; i < adapter->req_tx_queues; i++) {\n\t\tnetdev_dbg(netdev, \"Enabling tx_scrq[%d] irq\\n\", i);\n\t\tif (prev_state == VNIC_CLOSED)\n\t\t\tenable_irq(adapter->tx_scrq[i]->irq);\n\t\tenable_scrq_irq(adapter, adapter->tx_scrq[i]);\n\t\t \n\t\tif (adapter->reset_reason != VNIC_RESET_NON_FATAL)\n\t\t\tnetdev_tx_reset_queue(netdev_get_tx_queue(netdev, i));\n\t}\n\n\trc = set_link_state(adapter, IBMVNIC_LOGICAL_LNK_UP);\n\tif (rc) {\n\t\tibmvnic_napi_disable(adapter);\n\t\tibmvnic_disable_irqs(adapter);\n\t\treturn rc;\n\t}\n\n\tadapter->tx_queues_active = true;\n\n\t \n\tsynchronize_rcu();\n\n\tnetif_tx_start_all_queues(netdev);\n\n\tif (prev_state == VNIC_CLOSED) {\n\t\tfor (i = 0; i < adapter->req_rx_queues; i++)\n\t\t\tnapi_schedule(&adapter->napi[i]);\n\t}\n\n\tadapter->state = VNIC_OPEN;\n\treturn rc;\n}\n\nstatic int ibmvnic_open(struct net_device *netdev)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tint rc;\n\n\tASSERT_RTNL();\n\n\t \n\tif (adapter->failover_pending || (test_bit(0, &adapter->resetting))) {\n\t\tnetdev_dbg(netdev, \"[S:%s FOP:%d] Resetting, deferring open\\n\",\n\t\t\t   adapter_state_to_string(adapter->state),\n\t\t\t   adapter->failover_pending);\n\t\tadapter->state = VNIC_OPEN;\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (adapter->state != VNIC_CLOSED) {\n\t\trc = ibmvnic_login(netdev);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = init_resources(adapter);\n\t\tif (rc) {\n\t\t\tnetdev_err(netdev, \"failed to initialize resources\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = __ibmvnic_open(netdev);\n\nout:\n\t \n\tif (rc &&\n\t    (adapter->failover_pending || (test_bit(0, &adapter->resetting)))) {\n\t\tadapter->state = VNIC_OPEN;\n\t\trc = 0;\n\t}\n\n\tif (rc) {\n\t\trelease_resources(adapter);\n\t\trelease_rx_pools(adapter);\n\t\trelease_tx_pools(adapter);\n\t}\n\n\treturn rc;\n}\n\nstatic void clean_rx_pools(struct ibmvnic_adapter *adapter)\n{\n\tstruct ibmvnic_rx_pool *rx_pool;\n\tstruct ibmvnic_rx_buff *rx_buff;\n\tu64 rx_entries;\n\tint rx_scrqs;\n\tint i, j;\n\n\tif (!adapter->rx_pool)\n\t\treturn;\n\n\trx_scrqs = adapter->num_active_rx_pools;\n\trx_entries = adapter->req_rx_add_entries_per_subcrq;\n\n\t \n\tfor (i = 0; i < rx_scrqs; i++) {\n\t\trx_pool = &adapter->rx_pool[i];\n\t\tif (!rx_pool || !rx_pool->rx_buff)\n\t\t\tcontinue;\n\n\t\tnetdev_dbg(adapter->netdev, \"Cleaning rx_pool[%d]\\n\", i);\n\t\tfor (j = 0; j < rx_entries; j++) {\n\t\t\trx_buff = &rx_pool->rx_buff[j];\n\t\t\tif (rx_buff && rx_buff->skb) {\n\t\t\t\tdev_kfree_skb_any(rx_buff->skb);\n\t\t\t\trx_buff->skb = NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void clean_one_tx_pool(struct ibmvnic_adapter *adapter,\n\t\t\t      struct ibmvnic_tx_pool *tx_pool)\n{\n\tstruct ibmvnic_tx_buff *tx_buff;\n\tu64 tx_entries;\n\tint i;\n\n\tif (!tx_pool || !tx_pool->tx_buff)\n\t\treturn;\n\n\ttx_entries = tx_pool->num_buffers;\n\n\tfor (i = 0; i < tx_entries; i++) {\n\t\ttx_buff = &tx_pool->tx_buff[i];\n\t\tif (tx_buff && tx_buff->skb) {\n\t\t\tdev_kfree_skb_any(tx_buff->skb);\n\t\t\ttx_buff->skb = NULL;\n\t\t}\n\t}\n}\n\nstatic void clean_tx_pools(struct ibmvnic_adapter *adapter)\n{\n\tint tx_scrqs;\n\tint i;\n\n\tif (!adapter->tx_pool || !adapter->tso_pool)\n\t\treturn;\n\n\ttx_scrqs = adapter->num_active_tx_pools;\n\n\t \n\tfor (i = 0; i < tx_scrqs; i++) {\n\t\tnetdev_dbg(adapter->netdev, \"Cleaning tx_pool[%d]\\n\", i);\n\t\tclean_one_tx_pool(adapter, &adapter->tx_pool[i]);\n\t\tclean_one_tx_pool(adapter, &adapter->tso_pool[i]);\n\t}\n}\n\nstatic void ibmvnic_disable_irqs(struct ibmvnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint i;\n\n\tif (adapter->tx_scrq) {\n\t\tfor (i = 0; i < adapter->req_tx_queues; i++)\n\t\t\tif (adapter->tx_scrq[i]->irq) {\n\t\t\t\tnetdev_dbg(netdev,\n\t\t\t\t\t   \"Disabling tx_scrq[%d] irq\\n\", i);\n\t\t\t\tdisable_scrq_irq(adapter, adapter->tx_scrq[i]);\n\t\t\t\tdisable_irq(adapter->tx_scrq[i]->irq);\n\t\t\t}\n\t}\n\n\tif (adapter->rx_scrq) {\n\t\tfor (i = 0; i < adapter->req_rx_queues; i++) {\n\t\t\tif (adapter->rx_scrq[i]->irq) {\n\t\t\t\tnetdev_dbg(netdev,\n\t\t\t\t\t   \"Disabling rx_scrq[%d] irq\\n\", i);\n\t\t\t\tdisable_scrq_irq(adapter, adapter->rx_scrq[i]);\n\t\t\t\tdisable_irq(adapter->rx_scrq[i]->irq);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void ibmvnic_cleanup(struct net_device *netdev)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\n\t \n\n\tadapter->tx_queues_active = false;\n\n\t \n\tsynchronize_rcu();\n\n\tif (test_bit(0, &adapter->resetting))\n\t\tnetif_tx_disable(netdev);\n\telse\n\t\tnetif_tx_stop_all_queues(netdev);\n\n\tibmvnic_napi_disable(adapter);\n\tibmvnic_disable_irqs(adapter);\n}\n\nstatic int __ibmvnic_close(struct net_device *netdev)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tint rc = 0;\n\n\tadapter->state = VNIC_CLOSING;\n\trc = set_link_state(adapter, IBMVNIC_LOGICAL_LNK_DN);\n\tadapter->state = VNIC_CLOSED;\n\treturn rc;\n}\n\nstatic int ibmvnic_close(struct net_device *netdev)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tint rc;\n\n\tnetdev_dbg(netdev, \"[S:%s FOP:%d FRR:%d] Closing\\n\",\n\t\t   adapter_state_to_string(adapter->state),\n\t\t   adapter->failover_pending,\n\t\t   adapter->force_reset_recovery);\n\n\t \n\tif (adapter->failover_pending) {\n\t\tadapter->state = VNIC_CLOSED;\n\t\treturn 0;\n\t}\n\n\trc = __ibmvnic_close(netdev);\n\tibmvnic_cleanup(netdev);\n\tclean_rx_pools(adapter);\n\tclean_tx_pools(adapter);\n\n\treturn rc;\n}\n\n \nstatic int build_hdr_data(u8 hdr_field, struct sk_buff *skb,\n\t\t\t  int *hdr_len, u8 *hdr_data)\n{\n\tint len = 0;\n\tu8 *hdr;\n\n\tif (skb_vlan_tagged(skb) && !skb_vlan_tag_present(skb))\n\t\thdr_len[0] = sizeof(struct vlan_ethhdr);\n\telse\n\t\thdr_len[0] = sizeof(struct ethhdr);\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\thdr_len[1] = ip_hdr(skb)->ihl * 4;\n\t\tif (ip_hdr(skb)->protocol == IPPROTO_TCP)\n\t\t\thdr_len[2] = tcp_hdrlen(skb);\n\t\telse if (ip_hdr(skb)->protocol == IPPROTO_UDP)\n\t\t\thdr_len[2] = sizeof(struct udphdr);\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\thdr_len[1] = sizeof(struct ipv6hdr);\n\t\tif (ipv6_hdr(skb)->nexthdr == IPPROTO_TCP)\n\t\t\thdr_len[2] = tcp_hdrlen(skb);\n\t\telse if (ipv6_hdr(skb)->nexthdr == IPPROTO_UDP)\n\t\t\thdr_len[2] = sizeof(struct udphdr);\n\t} else if (skb->protocol == htons(ETH_P_ARP)) {\n\t\thdr_len[1] = arp_hdr_len(skb->dev);\n\t\thdr_len[2] = 0;\n\t}\n\n\tmemset(hdr_data, 0, 120);\n\tif ((hdr_field >> 6) & 1) {\n\t\thdr = skb_mac_header(skb);\n\t\tmemcpy(hdr_data, hdr, hdr_len[0]);\n\t\tlen += hdr_len[0];\n\t}\n\n\tif ((hdr_field >> 5) & 1) {\n\t\thdr = skb_network_header(skb);\n\t\tmemcpy(hdr_data + len, hdr, hdr_len[1]);\n\t\tlen += hdr_len[1];\n\t}\n\n\tif ((hdr_field >> 4) & 1) {\n\t\thdr = skb_transport_header(skb);\n\t\tmemcpy(hdr_data + len, hdr, hdr_len[2]);\n\t\tlen += hdr_len[2];\n\t}\n\treturn len;\n}\n\n \n\nstatic int create_hdr_descs(u8 hdr_field, u8 *hdr_data, int len, int *hdr_len,\n\t\t\t    union sub_crq *scrq_arr)\n{\n\tunion sub_crq hdr_desc;\n\tint tmp_len = len;\n\tint num_descs = 0;\n\tu8 *data, *cur;\n\tint tmp;\n\n\twhile (tmp_len > 0) {\n\t\tcur = hdr_data + len - tmp_len;\n\n\t\tmemset(&hdr_desc, 0, sizeof(hdr_desc));\n\t\tif (cur != hdr_data) {\n\t\t\tdata = hdr_desc.hdr_ext.data;\n\t\t\ttmp = tmp_len > 29 ? 29 : tmp_len;\n\t\t\thdr_desc.hdr_ext.first = IBMVNIC_CRQ_CMD;\n\t\t\thdr_desc.hdr_ext.type = IBMVNIC_HDR_EXT_DESC;\n\t\t\thdr_desc.hdr_ext.len = tmp;\n\t\t} else {\n\t\t\tdata = hdr_desc.hdr.data;\n\t\t\ttmp = tmp_len > 24 ? 24 : tmp_len;\n\t\t\thdr_desc.hdr.first = IBMVNIC_CRQ_CMD;\n\t\t\thdr_desc.hdr.type = IBMVNIC_HDR_DESC;\n\t\t\thdr_desc.hdr.len = tmp;\n\t\t\thdr_desc.hdr.l2_len = (u8)hdr_len[0];\n\t\t\thdr_desc.hdr.l3_len = cpu_to_be16((u16)hdr_len[1]);\n\t\t\thdr_desc.hdr.l4_len = (u8)hdr_len[2];\n\t\t\thdr_desc.hdr.flag = hdr_field << 1;\n\t\t}\n\t\tmemcpy(data, cur, tmp);\n\t\ttmp_len -= tmp;\n\t\t*scrq_arr = hdr_desc;\n\t\tscrq_arr++;\n\t\tnum_descs++;\n\t}\n\n\treturn num_descs;\n}\n\n \n\nstatic void build_hdr_descs_arr(struct sk_buff *skb,\n\t\t\t\tunion sub_crq *indir_arr,\n\t\t\t\tint *num_entries, u8 hdr_field)\n{\n\tint hdr_len[3] = {0, 0, 0};\n\tu8 hdr_data[140] = {0};\n\tint tot_len;\n\n\ttot_len = build_hdr_data(hdr_field, skb, hdr_len,\n\t\t\t\t hdr_data);\n\t*num_entries += create_hdr_descs(hdr_field, hdr_data, tot_len, hdr_len,\n\t\t\t\t\t indir_arr + 1);\n}\n\nstatic int ibmvnic_xmit_workarounds(struct sk_buff *skb,\n\t\t\t\t    struct net_device *netdev)\n{\n\t \n\tif (skb->len < netdev->min_mtu)\n\t\treturn skb_put_padto(skb, netdev->min_mtu);\n\n\treturn 0;\n}\n\nstatic void ibmvnic_tx_scrq_clean_buffer(struct ibmvnic_adapter *adapter,\n\t\t\t\t\t struct ibmvnic_sub_crq_queue *tx_scrq)\n{\n\tstruct ibmvnic_ind_xmit_queue *ind_bufp;\n\tstruct ibmvnic_tx_buff *tx_buff;\n\tstruct ibmvnic_tx_pool *tx_pool;\n\tunion sub_crq tx_scrq_entry;\n\tint queue_num;\n\tint entries;\n\tint index;\n\tint i;\n\n\tind_bufp = &tx_scrq->ind_buf;\n\tentries = (u64)ind_bufp->index;\n\tqueue_num = tx_scrq->pool_index;\n\n\tfor (i = entries - 1; i >= 0; --i) {\n\t\ttx_scrq_entry = ind_bufp->indir_arr[i];\n\t\tif (tx_scrq_entry.v1.type != IBMVNIC_TX_DESC)\n\t\t\tcontinue;\n\t\tindex = be32_to_cpu(tx_scrq_entry.v1.correlator);\n\t\tif (index & IBMVNIC_TSO_POOL_MASK) {\n\t\t\ttx_pool = &adapter->tso_pool[queue_num];\n\t\t\tindex &= ~IBMVNIC_TSO_POOL_MASK;\n\t\t} else {\n\t\t\ttx_pool = &adapter->tx_pool[queue_num];\n\t\t}\n\t\ttx_pool->free_map[tx_pool->consumer_index] = index;\n\t\ttx_pool->consumer_index = tx_pool->consumer_index == 0 ?\n\t\t\t\t\t  tx_pool->num_buffers - 1 :\n\t\t\t\t\t  tx_pool->consumer_index - 1;\n\t\ttx_buff = &tx_pool->tx_buff[index];\n\t\tadapter->netdev->stats.tx_packets--;\n\t\tadapter->netdev->stats.tx_bytes -= tx_buff->skb->len;\n\t\tadapter->tx_stats_buffers[queue_num].packets--;\n\t\tadapter->tx_stats_buffers[queue_num].bytes -=\n\t\t\t\t\t\ttx_buff->skb->len;\n\t\tdev_kfree_skb_any(tx_buff->skb);\n\t\ttx_buff->skb = NULL;\n\t\tadapter->netdev->stats.tx_dropped++;\n\t}\n\n\tind_bufp->index = 0;\n\n\tif (atomic_sub_return(entries, &tx_scrq->used) <=\n\t    (adapter->req_tx_entries_per_subcrq / 2) &&\n\t    __netif_subqueue_stopped(adapter->netdev, queue_num)) {\n\t\trcu_read_lock();\n\n\t\tif (adapter->tx_queues_active) {\n\t\t\tnetif_wake_subqueue(adapter->netdev, queue_num);\n\t\t\tnetdev_dbg(adapter->netdev, \"Started queue %d\\n\",\n\t\t\t\t   queue_num);\n\t\t}\n\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic int ibmvnic_tx_scrq_flush(struct ibmvnic_adapter *adapter,\n\t\t\t\t struct ibmvnic_sub_crq_queue *tx_scrq)\n{\n\tstruct ibmvnic_ind_xmit_queue *ind_bufp;\n\tu64 dma_addr;\n\tu64 entries;\n\tu64 handle;\n\tint rc;\n\n\tind_bufp = &tx_scrq->ind_buf;\n\tdma_addr = (u64)ind_bufp->indir_dma;\n\tentries = (u64)ind_bufp->index;\n\thandle = tx_scrq->handle;\n\n\tif (!entries)\n\t\treturn 0;\n\trc = send_subcrq_indirect(adapter, handle, dma_addr, entries);\n\tif (rc)\n\t\tibmvnic_tx_scrq_clean_buffer(adapter, tx_scrq);\n\telse\n\t\tind_bufp->index = 0;\n\treturn 0;\n}\n\nstatic netdev_tx_t ibmvnic_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tint queue_num = skb_get_queue_mapping(skb);\n\tu8 *hdrs = (u8 *)&adapter->tx_rx_desc_req;\n\tstruct device *dev = &adapter->vdev->dev;\n\tstruct ibmvnic_ind_xmit_queue *ind_bufp;\n\tstruct ibmvnic_tx_buff *tx_buff = NULL;\n\tstruct ibmvnic_sub_crq_queue *tx_scrq;\n\tstruct ibmvnic_long_term_buff *ltb;\n\tstruct ibmvnic_tx_pool *tx_pool;\n\tunsigned int tx_send_failed = 0;\n\tnetdev_tx_t ret = NETDEV_TX_OK;\n\tunsigned int tx_map_failed = 0;\n\tunion sub_crq indir_arr[16];\n\tunsigned int tx_dropped = 0;\n\tunsigned int tx_packets = 0;\n\tunsigned int tx_bytes = 0;\n\tdma_addr_t data_dma_addr;\n\tstruct netdev_queue *txq;\n\tunsigned long lpar_rc;\n\tunion sub_crq tx_crq;\n\tunsigned int offset;\n\tint num_entries = 1;\n\tunsigned char *dst;\n\tint bufidx = 0;\n\tu8 proto = 0;\n\n\t \n\trcu_read_lock();\n\tif (!adapter->tx_queues_active) {\n\t\tdev_kfree_skb_any(skb);\n\n\t\ttx_send_failed++;\n\t\ttx_dropped++;\n\t\tret = NETDEV_TX_OK;\n\t\tgoto out;\n\t}\n\n\ttx_scrq = adapter->tx_scrq[queue_num];\n\ttxq = netdev_get_tx_queue(netdev, queue_num);\n\tind_bufp = &tx_scrq->ind_buf;\n\n\tif (ibmvnic_xmit_workarounds(skb, netdev)) {\n\t\ttx_dropped++;\n\t\ttx_send_failed++;\n\t\tret = NETDEV_TX_OK;\n\t\tibmvnic_tx_scrq_flush(adapter, tx_scrq);\n\t\tgoto out;\n\t}\n\n\tif (skb_is_gso(skb))\n\t\ttx_pool = &adapter->tso_pool[queue_num];\n\telse\n\t\ttx_pool = &adapter->tx_pool[queue_num];\n\n\tbufidx = tx_pool->free_map[tx_pool->consumer_index];\n\n\tif (bufidx == IBMVNIC_INVALID_MAP) {\n\t\tdev_kfree_skb_any(skb);\n\t\ttx_send_failed++;\n\t\ttx_dropped++;\n\t\tibmvnic_tx_scrq_flush(adapter, tx_scrq);\n\t\tret = NETDEV_TX_OK;\n\t\tgoto out;\n\t}\n\n\ttx_pool->free_map[tx_pool->consumer_index] = IBMVNIC_INVALID_MAP;\n\n\tmap_txpool_buf_to_ltb(tx_pool, bufidx, &ltb, &offset);\n\n\tdst = ltb->buff + offset;\n\tmemset(dst, 0, tx_pool->buf_size);\n\tdata_dma_addr = ltb->addr + offset;\n\n\tif (skb_shinfo(skb)->nr_frags) {\n\t\tint cur, i;\n\n\t\t \n\t\tskb_copy_from_linear_data(skb, dst, skb_headlen(skb));\n\t\tcur = skb_headlen(skb);\n\n\t\t \n\t\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\t\tmemcpy(dst + cur, skb_frag_address(frag),\n\t\t\t       skb_frag_size(frag));\n\t\t\tcur += skb_frag_size(frag);\n\t\t}\n\t} else {\n\t\tskb_copy_from_linear_data(skb, dst, skb->len);\n\t}\n\n\t \n\tdma_wmb();\n\n\ttx_pool->consumer_index =\n\t    (tx_pool->consumer_index + 1) % tx_pool->num_buffers;\n\n\ttx_buff = &tx_pool->tx_buff[bufidx];\n\ttx_buff->skb = skb;\n\ttx_buff->index = bufidx;\n\ttx_buff->pool_index = queue_num;\n\n\tmemset(&tx_crq, 0, sizeof(tx_crq));\n\ttx_crq.v1.first = IBMVNIC_CRQ_CMD;\n\ttx_crq.v1.type = IBMVNIC_TX_DESC;\n\ttx_crq.v1.n_crq_elem = 1;\n\ttx_crq.v1.n_sge = 1;\n\ttx_crq.v1.flags1 = IBMVNIC_TX_COMP_NEEDED;\n\n\tif (skb_is_gso(skb))\n\t\ttx_crq.v1.correlator =\n\t\t\tcpu_to_be32(bufidx | IBMVNIC_TSO_POOL_MASK);\n\telse\n\t\ttx_crq.v1.correlator = cpu_to_be32(bufidx);\n\ttx_crq.v1.dma_reg = cpu_to_be16(ltb->map_id);\n\ttx_crq.v1.sge_len = cpu_to_be32(skb->len);\n\ttx_crq.v1.ioba = cpu_to_be64(data_dma_addr);\n\n\tif (adapter->vlan_header_insertion && skb_vlan_tag_present(skb)) {\n\t\ttx_crq.v1.flags2 |= IBMVNIC_TX_VLAN_INSERT;\n\t\ttx_crq.v1.vlan_id = cpu_to_be16(skb->vlan_tci);\n\t}\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\ttx_crq.v1.flags1 |= IBMVNIC_TX_PROT_IPV4;\n\t\tproto = ip_hdr(skb)->protocol;\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\ttx_crq.v1.flags1 |= IBMVNIC_TX_PROT_IPV6;\n\t\tproto = ipv6_hdr(skb)->nexthdr;\n\t}\n\n\tif (proto == IPPROTO_TCP)\n\t\ttx_crq.v1.flags1 |= IBMVNIC_TX_PROT_TCP;\n\telse if (proto == IPPROTO_UDP)\n\t\ttx_crq.v1.flags1 |= IBMVNIC_TX_PROT_UDP;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\ttx_crq.v1.flags1 |= IBMVNIC_TX_CHKSUM_OFFLOAD;\n\t\thdrs += 2;\n\t}\n\tif (skb_is_gso(skb)) {\n\t\ttx_crq.v1.flags1 |= IBMVNIC_TX_LSO;\n\t\ttx_crq.v1.mss = cpu_to_be16(skb_shinfo(skb)->gso_size);\n\t\thdrs += 2;\n\t}\n\n\tif ((*hdrs >> 7) & 1)\n\t\tbuild_hdr_descs_arr(skb, indir_arr, &num_entries, *hdrs);\n\n\ttx_crq.v1.n_crq_elem = num_entries;\n\ttx_buff->num_entries = num_entries;\n\t \n\tif (num_entries + ind_bufp->index > IBMVNIC_MAX_IND_DESCS) {\n\t\tlpar_rc = ibmvnic_tx_scrq_flush(adapter, tx_scrq);\n\t\tif (lpar_rc != H_SUCCESS)\n\t\t\tgoto tx_flush_err;\n\t}\n\n\tindir_arr[0] = tx_crq;\n\tmemcpy(&ind_bufp->indir_arr[ind_bufp->index], &indir_arr[0],\n\t       num_entries * sizeof(struct ibmvnic_generic_scrq));\n\tind_bufp->index += num_entries;\n\tif (__netdev_tx_sent_queue(txq, skb->len,\n\t\t\t\t   netdev_xmit_more() &&\n\t\t\t\t   ind_bufp->index < IBMVNIC_MAX_IND_DESCS)) {\n\t\tlpar_rc = ibmvnic_tx_scrq_flush(adapter, tx_scrq);\n\t\tif (lpar_rc != H_SUCCESS)\n\t\t\tgoto tx_err;\n\t}\n\n\tif (atomic_add_return(num_entries, &tx_scrq->used)\n\t\t\t\t\t>= adapter->req_tx_entries_per_subcrq) {\n\t\tnetdev_dbg(netdev, \"Stopping queue %d\\n\", queue_num);\n\t\tnetif_stop_subqueue(netdev, queue_num);\n\t}\n\n\ttx_packets++;\n\ttx_bytes += skb->len;\n\ttxq_trans_cond_update(txq);\n\tret = NETDEV_TX_OK;\n\tgoto out;\n\ntx_flush_err:\n\tdev_kfree_skb_any(skb);\n\ttx_buff->skb = NULL;\n\ttx_pool->consumer_index = tx_pool->consumer_index == 0 ?\n\t\t\t\t  tx_pool->num_buffers - 1 :\n\t\t\t\t  tx_pool->consumer_index - 1;\n\ttx_dropped++;\ntx_err:\n\tif (lpar_rc != H_CLOSED && lpar_rc != H_PARAMETER)\n\t\tdev_err_ratelimited(dev, \"tx: send failed\\n\");\n\n\tif (lpar_rc == H_CLOSED || adapter->failover_pending) {\n\t\t \n\t\tnetif_tx_stop_all_queues(netdev);\n\t\tnetif_carrier_off(netdev);\n\t}\nout:\n\trcu_read_unlock();\n\tnetdev->stats.tx_dropped += tx_dropped;\n\tnetdev->stats.tx_bytes += tx_bytes;\n\tnetdev->stats.tx_packets += tx_packets;\n\tadapter->tx_send_failed += tx_send_failed;\n\tadapter->tx_map_failed += tx_map_failed;\n\tadapter->tx_stats_buffers[queue_num].packets += tx_packets;\n\tadapter->tx_stats_buffers[queue_num].bytes += tx_bytes;\n\tadapter->tx_stats_buffers[queue_num].dropped_packets += tx_dropped;\n\n\treturn ret;\n}\n\nstatic void ibmvnic_set_multi(struct net_device *netdev)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tstruct netdev_hw_addr *ha;\n\tunion ibmvnic_crq crq;\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.request_capability.first = IBMVNIC_CRQ_CMD;\n\tcrq.request_capability.cmd = REQUEST_CAPABILITY;\n\n\tif (netdev->flags & IFF_PROMISC) {\n\t\tif (!adapter->promisc_supported)\n\t\t\treturn;\n\t} else {\n\t\tif (netdev->flags & IFF_ALLMULTI) {\n\t\t\t \n\t\t\tmemset(&crq, 0, sizeof(crq));\n\t\t\tcrq.multicast_ctrl.first = IBMVNIC_CRQ_CMD;\n\t\t\tcrq.multicast_ctrl.cmd = MULTICAST_CTRL;\n\t\t\tcrq.multicast_ctrl.flags = IBMVNIC_ENABLE_ALL;\n\t\t\tibmvnic_send_crq(adapter, &crq);\n\t\t} else if (netdev_mc_empty(netdev)) {\n\t\t\t \n\t\t\tmemset(&crq, 0, sizeof(crq));\n\t\t\tcrq.multicast_ctrl.first = IBMVNIC_CRQ_CMD;\n\t\t\tcrq.multicast_ctrl.cmd = MULTICAST_CTRL;\n\t\t\tcrq.multicast_ctrl.flags = IBMVNIC_DISABLE_ALL;\n\t\t\tibmvnic_send_crq(adapter, &crq);\n\t\t} else {\n\t\t\t \n\t\t\tnetdev_for_each_mc_addr(ha, netdev) {\n\t\t\t\tmemset(&crq, 0, sizeof(crq));\n\t\t\t\tcrq.multicast_ctrl.first = IBMVNIC_CRQ_CMD;\n\t\t\t\tcrq.multicast_ctrl.cmd = MULTICAST_CTRL;\n\t\t\t\tcrq.multicast_ctrl.flags = IBMVNIC_ENABLE_MC;\n\t\t\t\tether_addr_copy(&crq.multicast_ctrl.mac_addr[0],\n\t\t\t\t\t\tha->addr);\n\t\t\t\tibmvnic_send_crq(adapter, &crq);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int __ibmvnic_set_mac(struct net_device *netdev, u8 *dev_addr)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tunion ibmvnic_crq crq;\n\tint rc;\n\n\tif (!is_valid_ether_addr(dev_addr)) {\n\t\trc = -EADDRNOTAVAIL;\n\t\tgoto err;\n\t}\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.change_mac_addr.first = IBMVNIC_CRQ_CMD;\n\tcrq.change_mac_addr.cmd = CHANGE_MAC_ADDR;\n\tether_addr_copy(&crq.change_mac_addr.mac_addr[0], dev_addr);\n\n\tmutex_lock(&adapter->fw_lock);\n\tadapter->fw_done_rc = 0;\n\treinit_completion(&adapter->fw_done);\n\n\trc = ibmvnic_send_crq(adapter, &crq);\n\tif (rc) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&adapter->fw_lock);\n\t\tgoto err;\n\t}\n\n\trc = ibmvnic_wait_for_completion(adapter, &adapter->fw_done, 10000);\n\t \n\tif (rc || adapter->fw_done_rc) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&adapter->fw_lock);\n\t\tgoto err;\n\t}\n\tmutex_unlock(&adapter->fw_lock);\n\treturn 0;\nerr:\n\tether_addr_copy(adapter->mac_addr, netdev->dev_addr);\n\treturn rc;\n}\n\nstatic int ibmvnic_set_mac(struct net_device *netdev, void *p)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tstruct sockaddr *addr = p;\n\tint rc;\n\n\trc = 0;\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tether_addr_copy(adapter->mac_addr, addr->sa_data);\n\tif (adapter->state != VNIC_PROBED)\n\t\trc = __ibmvnic_set_mac(netdev, addr->sa_data);\n\n\treturn rc;\n}\n\nstatic const char *reset_reason_to_string(enum ibmvnic_reset_reason reason)\n{\n\tswitch (reason) {\n\tcase VNIC_RESET_FAILOVER:\n\t\treturn \"FAILOVER\";\n\tcase VNIC_RESET_MOBILITY:\n\t\treturn \"MOBILITY\";\n\tcase VNIC_RESET_FATAL:\n\t\treturn \"FATAL\";\n\tcase VNIC_RESET_NON_FATAL:\n\t\treturn \"NON_FATAL\";\n\tcase VNIC_RESET_TIMEOUT:\n\t\treturn \"TIMEOUT\";\n\tcase VNIC_RESET_CHANGE_PARAM:\n\t\treturn \"CHANGE_PARAM\";\n\tcase VNIC_RESET_PASSIVE_INIT:\n\t\treturn \"PASSIVE_INIT\";\n\t}\n\treturn \"UNKNOWN\";\n}\n\n \nstatic inline void reinit_init_done(struct ibmvnic_adapter *adapter)\n{\n\treinit_completion(&adapter->init_done);\n\tadapter->init_done_rc = 0;\n}\n\n \nstatic int do_reset(struct ibmvnic_adapter *adapter,\n\t\t    struct ibmvnic_rwi *rwi, u32 reset_state)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tu64 old_num_rx_queues, old_num_tx_queues;\n\tu64 old_num_rx_slots, old_num_tx_slots;\n\tint rc;\n\n\tnetdev_dbg(adapter->netdev,\n\t\t   \"[S:%s FOP:%d] Reset reason: %s, reset_state: %s\\n\",\n\t\t   adapter_state_to_string(adapter->state),\n\t\t   adapter->failover_pending,\n\t\t   reset_reason_to_string(rwi->reset_reason),\n\t\t   adapter_state_to_string(reset_state));\n\n\tadapter->reset_reason = rwi->reset_reason;\n\t \n\tif (!(adapter->reset_reason == VNIC_RESET_CHANGE_PARAM))\n\t\trtnl_lock();\n\n\t \n\tif (rwi->reset_reason == VNIC_RESET_FAILOVER)\n\t\tadapter->failover_pending = false;\n\n\t \n\treset_state = adapter->state;\n\n\tif (reset_state == VNIC_REMOVING || reset_state == VNIC_REMOVED) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tnetif_carrier_off(netdev);\n\n\told_num_rx_queues = adapter->req_rx_queues;\n\told_num_tx_queues = adapter->req_tx_queues;\n\told_num_rx_slots = adapter->req_rx_add_entries_per_subcrq;\n\told_num_tx_slots = adapter->req_tx_entries_per_subcrq;\n\n\tibmvnic_cleanup(netdev);\n\n\tif (reset_state == VNIC_OPEN &&\n\t    adapter->reset_reason != VNIC_RESET_MOBILITY &&\n\t    adapter->reset_reason != VNIC_RESET_FAILOVER) {\n\t\tif (adapter->reset_reason == VNIC_RESET_CHANGE_PARAM) {\n\t\t\trc = __ibmvnic_close(netdev);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tadapter->state = VNIC_CLOSING;\n\n\t\t\t \n\t\t\trtnl_unlock();\n\t\t\trc = set_link_state(adapter, IBMVNIC_LOGICAL_LNK_DN);\n\t\t\trtnl_lock();\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\tif (adapter->state == VNIC_OPEN) {\n\t\t\t\t \n\t\t\t\tnetdev_dbg(netdev,\n\t\t\t\t\t   \"Open changed state from %s, updating.\\n\",\n\t\t\t\t\t   adapter_state_to_string(reset_state));\n\t\t\t\treset_state = VNIC_OPEN;\n\t\t\t\tadapter->state = VNIC_CLOSING;\n\t\t\t}\n\n\t\t\tif (adapter->state != VNIC_CLOSING) {\n\t\t\t\t \n\t\t\t\trc = -EAGAIN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tadapter->state = VNIC_CLOSED;\n\t\t}\n\t}\n\n\tif (adapter->reset_reason == VNIC_RESET_CHANGE_PARAM) {\n\t\trelease_resources(adapter);\n\t\trelease_sub_crqs(adapter, 1);\n\t\trelease_crq_queue(adapter);\n\t}\n\n\tif (adapter->reset_reason != VNIC_RESET_NON_FATAL) {\n\t\t \n\t\tadapter->state = VNIC_PROBED;\n\n\t\treinit_init_done(adapter);\n\n\t\tif (adapter->reset_reason == VNIC_RESET_CHANGE_PARAM) {\n\t\t\trc = init_crq_queue(adapter);\n\t\t} else if (adapter->reset_reason == VNIC_RESET_MOBILITY) {\n\t\t\trc = ibmvnic_reenable_crq_queue(adapter);\n\t\t\trelease_sub_crqs(adapter, 1);\n\t\t} else {\n\t\t\trc = ibmvnic_reset_crq(adapter);\n\t\t\tif (rc == H_CLOSED || rc == H_SUCCESS) {\n\t\t\t\trc = vio_enable_interrupts(adapter->vdev);\n\t\t\t\tif (rc)\n\t\t\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t\t\t   \"Reset failed to enable interrupts. rc=%d\\n\",\n\t\t\t\t\t\t   rc);\n\t\t\t}\n\t\t}\n\n\t\tif (rc) {\n\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t   \"Reset couldn't initialize crq. rc=%d\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = ibmvnic_reset_init(adapter, true);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (reset_state == VNIC_PROBED || reset_state == VNIC_DOWN) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = ibmvnic_login(netdev);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tif (adapter->reset_reason == VNIC_RESET_CHANGE_PARAM) {\n\t\t\trc = init_resources(adapter);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t} else if (adapter->req_rx_queues != old_num_rx_queues ||\n\t\t    adapter->req_tx_queues != old_num_tx_queues ||\n\t\t    adapter->req_rx_add_entries_per_subcrq !=\n\t\t    old_num_rx_slots ||\n\t\t    adapter->req_tx_entries_per_subcrq !=\n\t\t    old_num_tx_slots ||\n\t\t    !adapter->rx_pool ||\n\t\t    !adapter->tso_pool ||\n\t\t    !adapter->tx_pool) {\n\t\t\trelease_napi(adapter);\n\t\t\trelease_vpd_data(adapter);\n\n\t\t\trc = init_resources(adapter);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t} else {\n\t\t\trc = init_tx_pools(netdev);\n\t\t\tif (rc) {\n\t\t\t\tnetdev_dbg(netdev,\n\t\t\t\t\t   \"init tx pools failed (%d)\\n\",\n\t\t\t\t\t   rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\trc = init_rx_pools(netdev);\n\t\t\tif (rc) {\n\t\t\t\tnetdev_dbg(netdev,\n\t\t\t\t\t   \"init rx pools failed (%d)\\n\",\n\t\t\t\t\t   rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tibmvnic_disable_irqs(adapter);\n\t}\n\tadapter->state = VNIC_CLOSED;\n\n\tif (reset_state == VNIC_CLOSED) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = __ibmvnic_open(netdev);\n\tif (rc) {\n\t\trc = IBMVNIC_OPEN_FAILED;\n\t\tgoto out;\n\t}\n\n\t \n\tibmvnic_set_multi(netdev);\n\n\tif (adapter->reset_reason == VNIC_RESET_FAILOVER ||\n\t    adapter->reset_reason == VNIC_RESET_MOBILITY)\n\t\t__netdev_notify_peers(netdev);\n\n\trc = 0;\n\nout:\n\t \n\tif (rc)\n\t\tadapter->state = reset_state;\n\t \n\tif (!(adapter->reset_reason == VNIC_RESET_CHANGE_PARAM))\n\t\trtnl_unlock();\n\n\tnetdev_dbg(adapter->netdev, \"[S:%s FOP:%d] Reset done, rc %d\\n\",\n\t\t   adapter_state_to_string(adapter->state),\n\t\t   adapter->failover_pending, rc);\n\treturn rc;\n}\n\nstatic int do_hard_reset(struct ibmvnic_adapter *adapter,\n\t\t\t struct ibmvnic_rwi *rwi, u32 reset_state)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint rc;\n\n\tnetdev_dbg(adapter->netdev, \"Hard resetting driver (%s)\\n\",\n\t\t   reset_reason_to_string(rwi->reset_reason));\n\n\t \n\treset_state = adapter->state;\n\n\tif (reset_state == VNIC_REMOVING || reset_state == VNIC_REMOVED) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tnetif_carrier_off(netdev);\n\tadapter->reset_reason = rwi->reset_reason;\n\n\tibmvnic_cleanup(netdev);\n\trelease_resources(adapter);\n\trelease_sub_crqs(adapter, 0);\n\trelease_crq_queue(adapter);\n\n\t \n\tadapter->state = VNIC_PROBED;\n\n\treinit_init_done(adapter);\n\n\trc = init_crq_queue(adapter);\n\tif (rc) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Couldn't initialize crq. rc=%d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\trc = ibmvnic_reset_init(adapter, false);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\tif (reset_state == VNIC_PROBED || reset_state == VNIC_DOWN)\n\t\tgoto out;\n\n\trc = ibmvnic_login(netdev);\n\tif (rc)\n\t\tgoto out;\n\n\trc = init_resources(adapter);\n\tif (rc)\n\t\tgoto out;\n\n\tibmvnic_disable_irqs(adapter);\n\tadapter->state = VNIC_CLOSED;\n\n\tif (reset_state == VNIC_CLOSED)\n\t\tgoto out;\n\n\trc = __ibmvnic_open(netdev);\n\tif (rc) {\n\t\trc = IBMVNIC_OPEN_FAILED;\n\t\tgoto out;\n\t}\n\n\t__netdev_notify_peers(netdev);\nout:\n\t \n\tif (rc)\n\t\tadapter->state = reset_state;\n\tnetdev_dbg(adapter->netdev, \"[S:%s FOP:%d] Hard reset done, rc %d\\n\",\n\t\t   adapter_state_to_string(adapter->state),\n\t\t   adapter->failover_pending, rc);\n\treturn rc;\n}\n\nstatic struct ibmvnic_rwi *get_next_rwi(struct ibmvnic_adapter *adapter)\n{\n\tstruct ibmvnic_rwi *rwi;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->rwi_lock, flags);\n\n\tif (!list_empty(&adapter->rwi_list)) {\n\t\trwi = list_first_entry(&adapter->rwi_list, struct ibmvnic_rwi,\n\t\t\t\t       list);\n\t\tlist_del(&rwi->list);\n\t} else {\n\t\trwi = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&adapter->rwi_lock, flags);\n\treturn rwi;\n}\n\n \n\nstatic int do_passive_init(struct ibmvnic_adapter *adapter)\n{\n\tunsigned long timeout = msecs_to_jiffies(30000);\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct device *dev = &adapter->vdev->dev;\n\tint rc;\n\n\tnetdev_dbg(netdev, \"Partner device found, probing.\\n\");\n\n\tadapter->state = VNIC_PROBING;\n\treinit_completion(&adapter->init_done);\n\tadapter->init_done_rc = 0;\n\tadapter->crq.active = true;\n\n\trc = send_crq_init_complete(adapter);\n\tif (rc)\n\t\tgoto out;\n\n\trc = send_version_xchg(adapter);\n\tif (rc)\n\t\tnetdev_dbg(adapter->netdev, \"send_version_xchg failed, rc=%d\\n\", rc);\n\n\tif (!wait_for_completion_timeout(&adapter->init_done, timeout)) {\n\t\tdev_err(dev, \"Initialization sequence timed out\\n\");\n\t\trc = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\trc = init_sub_crqs(adapter);\n\tif (rc) {\n\t\tdev_err(dev, \"Initialization of sub crqs failed, rc=%d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\trc = init_sub_crq_irqs(adapter);\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to initialize sub crq irqs\\n, rc=%d\", rc);\n\t\tgoto init_failed;\n\t}\n\n\tnetdev->mtu = adapter->req_mtu - ETH_HLEN;\n\tnetdev->min_mtu = adapter->min_mtu - ETH_HLEN;\n\tnetdev->max_mtu = adapter->max_mtu - ETH_HLEN;\n\n\tadapter->state = VNIC_PROBED;\n\tnetdev_dbg(netdev, \"Probed successfully. Waiting for signal from partner device.\\n\");\n\n\treturn 0;\n\ninit_failed:\n\trelease_sub_crqs(adapter, 1);\nout:\n\tadapter->state = VNIC_DOWN;\n\treturn rc;\n}\n\nstatic void __ibmvnic_reset(struct work_struct *work)\n{\n\tstruct ibmvnic_adapter *adapter;\n\tunsigned int timeout = 5000;\n\tstruct ibmvnic_rwi *tmprwi;\n\tbool saved_state = false;\n\tstruct ibmvnic_rwi *rwi;\n\tunsigned long flags;\n\tstruct device *dev;\n\tbool need_reset;\n\tint num_fails = 0;\n\tu32 reset_state;\n\tint rc = 0;\n\n\tadapter = container_of(work, struct ibmvnic_adapter, ibmvnic_reset);\n\t\tdev = &adapter->vdev->dev;\n\n\t \n\tif (adapter->state == VNIC_PROBING &&\n\t    !wait_for_completion_timeout(&adapter->probe_done, timeout)) {\n\t\tdev_err(dev, \"Reset thread timed out on probe\");\n\t\tqueue_delayed_work(system_long_wq,\n\t\t\t\t   &adapter->ibmvnic_delayed_reset,\n\t\t\t\t   IBMVNIC_RESET_DELAY);\n\t\treturn;\n\t}\n\n\t \n\tif (adapter->state == VNIC_REMOVING)\n\t\treturn;\n\n\t \n\n\t \n\tneed_reset = false;\n\tspin_lock(&adapter->rwi_lock);\n\tif (!list_empty(&adapter->rwi_list)) {\n\t\tif (test_and_set_bit_lock(0, &adapter->resetting)) {\n\t\t\tqueue_delayed_work(system_long_wq,\n\t\t\t\t\t   &adapter->ibmvnic_delayed_reset,\n\t\t\t\t\t   IBMVNIC_RESET_DELAY);\n\t\t} else {\n\t\t\tneed_reset = true;\n\t\t}\n\t}\n\tspin_unlock(&adapter->rwi_lock);\n\n\tif (!need_reset)\n\t\treturn;\n\n\trwi = get_next_rwi(adapter);\n\twhile (rwi) {\n\t\tspin_lock_irqsave(&adapter->state_lock, flags);\n\n\t\tif (adapter->state == VNIC_REMOVING ||\n\t\t    adapter->state == VNIC_REMOVED) {\n\t\t\tspin_unlock_irqrestore(&adapter->state_lock, flags);\n\t\t\tkfree(rwi);\n\t\t\trc = EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!saved_state) {\n\t\t\treset_state = adapter->state;\n\t\t\tsaved_state = true;\n\t\t}\n\t\tspin_unlock_irqrestore(&adapter->state_lock, flags);\n\n\t\tif (rwi->reset_reason == VNIC_RESET_PASSIVE_INIT) {\n\t\t\trtnl_lock();\n\t\t\trc = do_passive_init(adapter);\n\t\t\trtnl_unlock();\n\t\t\tif (!rc)\n\t\t\t\tnetif_carrier_on(adapter->netdev);\n\t\t} else if (adapter->force_reset_recovery) {\n\t\t\t \n\t\t\tadapter->failover_pending = false;\n\n\t\t\t \n\t\t\tif (adapter->wait_for_reset) {\n\t\t\t\t \n\t\t\t\tadapter->force_reset_recovery = false;\n\t\t\t\trc = do_hard_reset(adapter, rwi, reset_state);\n\t\t\t} else {\n\t\t\t\trtnl_lock();\n\t\t\t\tadapter->force_reset_recovery = false;\n\t\t\t\trc = do_hard_reset(adapter, rwi, reset_state);\n\t\t\t\trtnl_unlock();\n\t\t\t}\n\t\t\tif (rc)\n\t\t\t\tnum_fails++;\n\t\t\telse\n\t\t\t\tnum_fails = 0;\n\n\t\t\t \n\t\t\tif (num_fails >= 3) {\n\t\t\t\tnetdev_dbg(adapter->netdev,\n\t\t\t\t\t   \"[S:%s] Hard reset failed %d times, waiting 60 secs\\n\",\n\t\t\t\t\t   adapter_state_to_string(adapter->state),\n\t\t\t\t\t   num_fails);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tschedule_timeout(60 * HZ);\n\t\t\t}\n\t\t} else {\n\t\t\trc = do_reset(adapter, rwi, reset_state);\n\t\t}\n\t\ttmprwi = rwi;\n\t\tadapter->last_reset_time = jiffies;\n\n\t\tif (rc)\n\t\t\tnetdev_dbg(adapter->netdev, \"Reset failed, rc=%d\\n\", rc);\n\n\t\trwi = get_next_rwi(adapter);\n\n\t\t \n\t\tif (!rwi && rc)\n\t\t\trwi = tmprwi;\n\t\telse\n\t\t\tkfree(tmprwi);\n\n\t\tif (rwi && (rwi->reset_reason == VNIC_RESET_FAILOVER ||\n\t\t\t    rwi->reset_reason == VNIC_RESET_MOBILITY || rc))\n\t\t\tadapter->force_reset_recovery = true;\n\t}\n\n\tif (adapter->wait_for_reset) {\n\t\tadapter->reset_done_rc = rc;\n\t\tcomplete(&adapter->reset_done);\n\t}\n\n\tclear_bit_unlock(0, &adapter->resetting);\n\n\tnetdev_dbg(adapter->netdev,\n\t\t   \"[S:%s FRR:%d WFR:%d] Done processing resets\\n\",\n\t\t   adapter_state_to_string(adapter->state),\n\t\t   adapter->force_reset_recovery,\n\t\t   adapter->wait_for_reset);\n}\n\nstatic void __ibmvnic_delayed_reset(struct work_struct *work)\n{\n\tstruct ibmvnic_adapter *adapter;\n\n\tadapter = container_of(work, struct ibmvnic_adapter,\n\t\t\t       ibmvnic_delayed_reset.work);\n\t__ibmvnic_reset(&adapter->ibmvnic_reset);\n}\n\nstatic void flush_reset_queue(struct ibmvnic_adapter *adapter)\n{\n\tstruct list_head *entry, *tmp_entry;\n\n\tif (!list_empty(&adapter->rwi_list)) {\n\t\tlist_for_each_safe(entry, tmp_entry, &adapter->rwi_list) {\n\t\t\tlist_del(entry);\n\t\t\tkfree(list_entry(entry, struct ibmvnic_rwi, list));\n\t\t}\n\t}\n}\n\nstatic int ibmvnic_reset(struct ibmvnic_adapter *adapter,\n\t\t\t enum ibmvnic_reset_reason reason)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct ibmvnic_rwi *rwi, *tmp;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&adapter->rwi_lock, flags);\n\n\t \n\tif (adapter->state == VNIC_REMOVING ||\n\t    adapter->state == VNIC_REMOVED ||\n\t    (adapter->failover_pending && reason != VNIC_RESET_FAILOVER)) {\n\t\tret = EBUSY;\n\t\tnetdev_dbg(netdev, \"Adapter removing or pending failover, skipping reset\\n\");\n\t\tgoto err;\n\t}\n\n\tlist_for_each_entry(tmp, &adapter->rwi_list, list) {\n\t\tif (tmp->reset_reason == reason) {\n\t\t\tnetdev_dbg(netdev, \"Skipping matching reset, reason=%s\\n\",\n\t\t\t\t   reset_reason_to_string(reason));\n\t\t\tret = EBUSY;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\trwi = kzalloc(sizeof(*rwi), GFP_ATOMIC);\n\tif (!rwi) {\n\t\tret = ENOMEM;\n\t\tgoto err;\n\t}\n\t \n\tif (adapter->force_reset_recovery)\n\t\tflush_reset_queue(adapter);\n\n\trwi->reset_reason = reason;\n\tlist_add_tail(&rwi->list, &adapter->rwi_list);\n\tnetdev_dbg(adapter->netdev, \"Scheduling reset (reason %s)\\n\",\n\t\t   reset_reason_to_string(reason));\n\tqueue_work(system_long_wq, &adapter->ibmvnic_reset);\n\n\tret = 0;\nerr:\n\t \n\tspin_unlock_irqrestore(&adapter->rwi_lock, flags);\n\n\tif (ret == ENOMEM)\n\t\tibmvnic_close(netdev);\n\n\treturn -ret;\n}\n\nstatic void ibmvnic_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(dev);\n\n\tif (test_bit(0, &adapter->resetting)) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"Adapter is resetting, skip timeout reset\\n\");\n\t\treturn;\n\t}\n\t \n\tif (time_before(jiffies, (adapter->last_reset_time + dev->watchdog_timeo))) {\n\t\tnetdev_dbg(dev, \"Not yet time to tx timeout.\\n\");\n\t\treturn;\n\t}\n\tibmvnic_reset(adapter, VNIC_RESET_TIMEOUT);\n}\n\nstatic void remove_buff_from_pool(struct ibmvnic_adapter *adapter,\n\t\t\t\t  struct ibmvnic_rx_buff *rx_buff)\n{\n\tstruct ibmvnic_rx_pool *pool = &adapter->rx_pool[rx_buff->pool_index];\n\n\trx_buff->skb = NULL;\n\n\tpool->free_map[pool->next_alloc] = (int)(rx_buff - pool->rx_buff);\n\tpool->next_alloc = (pool->next_alloc + 1) % pool->size;\n\n\tatomic_dec(&pool->available);\n}\n\nstatic int ibmvnic_poll(struct napi_struct *napi, int budget)\n{\n\tstruct ibmvnic_sub_crq_queue *rx_scrq;\n\tstruct ibmvnic_adapter *adapter;\n\tstruct net_device *netdev;\n\tint frames_processed;\n\tint scrq_num;\n\n\tnetdev = napi->dev;\n\tadapter = netdev_priv(netdev);\n\tscrq_num = (int)(napi - adapter->napi);\n\tframes_processed = 0;\n\trx_scrq = adapter->rx_scrq[scrq_num];\n\nrestart_poll:\n\twhile (frames_processed < budget) {\n\t\tstruct sk_buff *skb;\n\t\tstruct ibmvnic_rx_buff *rx_buff;\n\t\tunion sub_crq *next;\n\t\tu32 length;\n\t\tu16 offset;\n\t\tu8 flags = 0;\n\n\t\tif (unlikely(test_bit(0, &adapter->resetting) &&\n\t\t\t     adapter->reset_reason != VNIC_RESET_NON_FATAL)) {\n\t\t\tenable_scrq_irq(adapter, rx_scrq);\n\t\t\tnapi_complete_done(napi, frames_processed);\n\t\t\treturn frames_processed;\n\t\t}\n\n\t\tif (!pending_scrq(adapter, rx_scrq))\n\t\t\tbreak;\n\t\tnext = ibmvnic_next_scrq(adapter, rx_scrq);\n\t\trx_buff = (struct ibmvnic_rx_buff *)\n\t\t\t  be64_to_cpu(next->rx_comp.correlator);\n\t\t \n\t\tif (next->rx_comp.rc) {\n\t\t\tnetdev_dbg(netdev, \"rx buffer returned with rc %x\\n\",\n\t\t\t\t   be16_to_cpu(next->rx_comp.rc));\n\t\t\t \n\t\t\tnext->rx_comp.first = 0;\n\t\t\tdev_kfree_skb_any(rx_buff->skb);\n\t\t\tremove_buff_from_pool(adapter, rx_buff);\n\t\t\tcontinue;\n\t\t} else if (!rx_buff->skb) {\n\t\t\t \n\t\t\tnext->rx_comp.first = 0;\n\t\t\tremove_buff_from_pool(adapter, rx_buff);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlength = be32_to_cpu(next->rx_comp.len);\n\t\toffset = be16_to_cpu(next->rx_comp.off_frame_data);\n\t\tflags = next->rx_comp.flags;\n\t\tskb = rx_buff->skb;\n\t\t \n\t\tdma_rmb();\n\t\tskb_copy_to_linear_data(skb, rx_buff->data + offset,\n\t\t\t\t\tlength);\n\n\t\t \n\t\tif (adapter->rx_vlan_header_insertion &&\n\t\t    (flags & IBMVNIC_VLAN_STRIPPED))\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\n\t\t\t\t\t       ntohs(next->rx_comp.vlan_tci));\n\n\t\t \n\t\tnext->rx_comp.first = 0;\n\t\tremove_buff_from_pool(adapter, rx_buff);\n\n\t\tskb_put(skb, length);\n\t\tskb->protocol = eth_type_trans(skb, netdev);\n\t\tskb_record_rx_queue(skb, scrq_num);\n\n\t\tif (flags & IBMVNIC_IP_CHKSUM_GOOD &&\n\t\t    flags & IBMVNIC_TCP_UDP_CHKSUM_GOOD) {\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t}\n\n\t\tlength = skb->len;\n\t\tnapi_gro_receive(napi, skb);  \n\t\tnetdev->stats.rx_packets++;\n\t\tnetdev->stats.rx_bytes += length;\n\t\tadapter->rx_stats_buffers[scrq_num].packets++;\n\t\tadapter->rx_stats_buffers[scrq_num].bytes += length;\n\t\tframes_processed++;\n\t}\n\n\tif (adapter->state != VNIC_CLOSING &&\n\t    ((atomic_read(&adapter->rx_pool[scrq_num].available) <\n\t      adapter->req_rx_add_entries_per_subcrq / 2) ||\n\t      frames_processed < budget))\n\t\treplenish_rx_pool(adapter, &adapter->rx_pool[scrq_num]);\n\tif (frames_processed < budget) {\n\t\tif (napi_complete_done(napi, frames_processed)) {\n\t\t\tenable_scrq_irq(adapter, rx_scrq);\n\t\t\tif (pending_scrq(adapter, rx_scrq)) {\n\t\t\t\tif (napi_reschedule(napi)) {\n\t\t\t\t\tdisable_scrq_irq(adapter, rx_scrq);\n\t\t\t\t\tgoto restart_poll;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn frames_processed;\n}\n\nstatic int wait_for_reset(struct ibmvnic_adapter *adapter)\n{\n\tint rc, ret;\n\n\tadapter->fallback.mtu = adapter->req_mtu;\n\tadapter->fallback.rx_queues = adapter->req_rx_queues;\n\tadapter->fallback.tx_queues = adapter->req_tx_queues;\n\tadapter->fallback.rx_entries = adapter->req_rx_add_entries_per_subcrq;\n\tadapter->fallback.tx_entries = adapter->req_tx_entries_per_subcrq;\n\n\treinit_completion(&adapter->reset_done);\n\tadapter->wait_for_reset = true;\n\trc = ibmvnic_reset(adapter, VNIC_RESET_CHANGE_PARAM);\n\n\tif (rc) {\n\t\tret = rc;\n\t\tgoto out;\n\t}\n\trc = ibmvnic_wait_for_completion(adapter, &adapter->reset_done, 60000);\n\tif (rc) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tif (adapter->reset_done_rc) {\n\t\tret = -EIO;\n\t\tadapter->desired.mtu = adapter->fallback.mtu;\n\t\tadapter->desired.rx_queues = adapter->fallback.rx_queues;\n\t\tadapter->desired.tx_queues = adapter->fallback.tx_queues;\n\t\tadapter->desired.rx_entries = adapter->fallback.rx_entries;\n\t\tadapter->desired.tx_entries = adapter->fallback.tx_entries;\n\n\t\treinit_completion(&adapter->reset_done);\n\t\tadapter->wait_for_reset = true;\n\t\trc = ibmvnic_reset(adapter, VNIC_RESET_CHANGE_PARAM);\n\t\tif (rc) {\n\t\t\tret = rc;\n\t\t\tgoto out;\n\t\t}\n\t\trc = ibmvnic_wait_for_completion(adapter, &adapter->reset_done,\n\t\t\t\t\t\t 60000);\n\t\tif (rc) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tadapter->wait_for_reset = false;\n\n\treturn ret;\n}\n\nstatic int ibmvnic_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\n\tadapter->desired.mtu = new_mtu + ETH_HLEN;\n\n\treturn wait_for_reset(adapter);\n}\n\nstatic netdev_features_t ibmvnic_features_check(struct sk_buff *skb,\n\t\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\t\tnetdev_features_t features)\n{\n\t \n\tif (skb_is_gso(skb)) {\n\t\tif (skb_shinfo(skb)->gso_size < 224 ||\n\t\t    skb_shinfo(skb)->gso_segs == 1)\n\t\t\tfeatures &= ~NETIF_F_GSO_MASK;\n\t}\n\n\treturn features;\n}\n\nstatic const struct net_device_ops ibmvnic_netdev_ops = {\n\t.ndo_open\t\t= ibmvnic_open,\n\t.ndo_stop\t\t= ibmvnic_close,\n\t.ndo_start_xmit\t\t= ibmvnic_xmit,\n\t.ndo_set_rx_mode\t= ibmvnic_set_multi,\n\t.ndo_set_mac_address\t= ibmvnic_set_mac,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_tx_timeout\t\t= ibmvnic_tx_timeout,\n\t.ndo_change_mtu\t\t= ibmvnic_change_mtu,\n\t.ndo_features_check     = ibmvnic_features_check,\n};\n\n \n\nstatic int ibmvnic_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tint rc;\n\n\trc = send_query_phys_parms(adapter);\n\tif (rc) {\n\t\tadapter->speed = SPEED_UNKNOWN;\n\t\tadapter->duplex = DUPLEX_UNKNOWN;\n\t}\n\tcmd->base.speed = adapter->speed;\n\tcmd->base.duplex = adapter->duplex;\n\tcmd->base.port = PORT_FIBRE;\n\tcmd->base.phy_address = 0;\n\tcmd->base.autoneg = AUTONEG_ENABLE;\n\n\treturn 0;\n}\n\nstatic void ibmvnic_get_drvinfo(struct net_device *netdev,\n\t\t\t\tstruct ethtool_drvinfo *info)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\n\tstrscpy(info->driver, ibmvnic_driver_name, sizeof(info->driver));\n\tstrscpy(info->version, IBMVNIC_DRIVER_VERSION, sizeof(info->version));\n\tstrscpy(info->fw_version, adapter->fw_version,\n\t\tsizeof(info->fw_version));\n}\n\nstatic u32 ibmvnic_get_msglevel(struct net_device *netdev)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\n\treturn adapter->msg_enable;\n}\n\nstatic void ibmvnic_set_msglevel(struct net_device *netdev, u32 data)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\n\tadapter->msg_enable = data;\n}\n\nstatic u32 ibmvnic_get_link(struct net_device *netdev)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\n\t \n\treturn adapter->logical_link_state;\n}\n\nstatic void ibmvnic_get_ringparam(struct net_device *netdev,\n\t\t\t\t  struct ethtool_ringparam *ring,\n\t\t\t\t  struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\n\tring->rx_max_pending = adapter->max_rx_add_entries_per_subcrq;\n\tring->tx_max_pending = adapter->max_tx_entries_per_subcrq;\n\tring->rx_mini_max_pending = 0;\n\tring->rx_jumbo_max_pending = 0;\n\tring->rx_pending = adapter->req_rx_add_entries_per_subcrq;\n\tring->tx_pending = adapter->req_tx_entries_per_subcrq;\n\tring->rx_mini_pending = 0;\n\tring->rx_jumbo_pending = 0;\n}\n\nstatic int ibmvnic_set_ringparam(struct net_device *netdev,\n\t\t\t\t struct ethtool_ringparam *ring,\n\t\t\t\t struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\n\tif (ring->rx_pending > adapter->max_rx_add_entries_per_subcrq  ||\n\t    ring->tx_pending > adapter->max_tx_entries_per_subcrq) {\n\t\tnetdev_err(netdev, \"Invalid request.\\n\");\n\t\tnetdev_err(netdev, \"Max tx buffers = %llu\\n\",\n\t\t\t   adapter->max_rx_add_entries_per_subcrq);\n\t\tnetdev_err(netdev, \"Max rx buffers = %llu\\n\",\n\t\t\t   adapter->max_tx_entries_per_subcrq);\n\t\treturn -EINVAL;\n\t}\n\n\tadapter->desired.rx_entries = ring->rx_pending;\n\tadapter->desired.tx_entries = ring->tx_pending;\n\n\treturn wait_for_reset(adapter);\n}\n\nstatic void ibmvnic_get_channels(struct net_device *netdev,\n\t\t\t\t struct ethtool_channels *channels)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\n\tchannels->max_rx = adapter->max_rx_queues;\n\tchannels->max_tx = adapter->max_tx_queues;\n\tchannels->max_other = 0;\n\tchannels->max_combined = 0;\n\tchannels->rx_count = adapter->req_rx_queues;\n\tchannels->tx_count = adapter->req_tx_queues;\n\tchannels->other_count = 0;\n\tchannels->combined_count = 0;\n}\n\nstatic int ibmvnic_set_channels(struct net_device *netdev,\n\t\t\t\tstruct ethtool_channels *channels)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\n\tadapter->desired.rx_queues = channels->rx_count;\n\tadapter->desired.tx_queues = channels->tx_count;\n\n\treturn wait_for_reset(adapter);\n}\n\nstatic void ibmvnic_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(dev);\n\tint i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(ibmvnic_stats); i++, data += ETH_GSTRING_LEN)\n\t\tmemcpy(data, ibmvnic_stats[i].name, ETH_GSTRING_LEN);\n\n\tfor (i = 0; i < adapter->req_tx_queues; i++) {\n\t\tsnprintf(data, ETH_GSTRING_LEN, \"tx%d_packets\", i);\n\t\tdata += ETH_GSTRING_LEN;\n\n\t\tsnprintf(data, ETH_GSTRING_LEN, \"tx%d_bytes\", i);\n\t\tdata += ETH_GSTRING_LEN;\n\n\t\tsnprintf(data, ETH_GSTRING_LEN, \"tx%d_dropped_packets\", i);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n\n\tfor (i = 0; i < adapter->req_rx_queues; i++) {\n\t\tsnprintf(data, ETH_GSTRING_LEN, \"rx%d_packets\", i);\n\t\tdata += ETH_GSTRING_LEN;\n\n\t\tsnprintf(data, ETH_GSTRING_LEN, \"rx%d_bytes\", i);\n\t\tdata += ETH_GSTRING_LEN;\n\n\t\tsnprintf(data, ETH_GSTRING_LEN, \"rx%d_interrupts\", i);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n}\n\nstatic int ibmvnic_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(dev);\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(ibmvnic_stats) +\n\t\t       adapter->req_tx_queues * NUM_TX_STATS +\n\t\t       adapter->req_rx_queues * NUM_RX_STATS;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void ibmvnic_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t      struct ethtool_stats *stats, u64 *data)\n{\n\tstruct ibmvnic_adapter *adapter = netdev_priv(dev);\n\tunion ibmvnic_crq crq;\n\tint i, j;\n\tint rc;\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.request_statistics.first = IBMVNIC_CRQ_CMD;\n\tcrq.request_statistics.cmd = REQUEST_STATISTICS;\n\tcrq.request_statistics.ioba = cpu_to_be32(adapter->stats_token);\n\tcrq.request_statistics.len =\n\t    cpu_to_be32(sizeof(struct ibmvnic_statistics));\n\n\t \n\treinit_completion(&adapter->stats_done);\n\trc = ibmvnic_send_crq(adapter, &crq);\n\tif (rc)\n\t\treturn;\n\trc = ibmvnic_wait_for_completion(adapter, &adapter->stats_done, 10000);\n\tif (rc)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(ibmvnic_stats); i++)\n\t\tdata[i] = be64_to_cpu(IBMVNIC_GET_STAT\n\t\t\t\t      (adapter, ibmvnic_stats[i].offset));\n\n\tfor (j = 0; j < adapter->req_tx_queues; j++) {\n\t\tdata[i] = adapter->tx_stats_buffers[j].packets;\n\t\ti++;\n\t\tdata[i] = adapter->tx_stats_buffers[j].bytes;\n\t\ti++;\n\t\tdata[i] = adapter->tx_stats_buffers[j].dropped_packets;\n\t\ti++;\n\t}\n\n\tfor (j = 0; j < adapter->req_rx_queues; j++) {\n\t\tdata[i] = adapter->rx_stats_buffers[j].packets;\n\t\ti++;\n\t\tdata[i] = adapter->rx_stats_buffers[j].bytes;\n\t\ti++;\n\t\tdata[i] = adapter->rx_stats_buffers[j].interrupts;\n\t\ti++;\n\t}\n}\n\nstatic const struct ethtool_ops ibmvnic_ethtool_ops = {\n\t.get_drvinfo\t\t= ibmvnic_get_drvinfo,\n\t.get_msglevel\t\t= ibmvnic_get_msglevel,\n\t.set_msglevel\t\t= ibmvnic_set_msglevel,\n\t.get_link\t\t= ibmvnic_get_link,\n\t.get_ringparam\t\t= ibmvnic_get_ringparam,\n\t.set_ringparam\t\t= ibmvnic_set_ringparam,\n\t.get_channels\t\t= ibmvnic_get_channels,\n\t.set_channels\t\t= ibmvnic_set_channels,\n\t.get_strings            = ibmvnic_get_strings,\n\t.get_sset_count         = ibmvnic_get_sset_count,\n\t.get_ethtool_stats\t= ibmvnic_get_ethtool_stats,\n\t.get_link_ksettings\t= ibmvnic_get_link_ksettings,\n};\n\n \n\nstatic int reset_one_sub_crq_queue(struct ibmvnic_adapter *adapter,\n\t\t\t\t   struct ibmvnic_sub_crq_queue *scrq)\n{\n\tint rc;\n\n\tif (!scrq) {\n\t\tnetdev_dbg(adapter->netdev, \"Invalid scrq reset.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (scrq->irq) {\n\t\tfree_irq(scrq->irq, scrq);\n\t\tirq_dispose_mapping(scrq->irq);\n\t\tscrq->irq = 0;\n\t}\n\n\tif (scrq->msgs) {\n\t\tmemset(scrq->msgs, 0, 4 * PAGE_SIZE);\n\t\tatomic_set(&scrq->used, 0);\n\t\tscrq->cur = 0;\n\t\tscrq->ind_buf.index = 0;\n\t} else {\n\t\tnetdev_dbg(adapter->netdev, \"Invalid scrq reset\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = h_reg_sub_crq(adapter->vdev->unit_address, scrq->msg_token,\n\t\t\t   4 * PAGE_SIZE, &scrq->crq_num, &scrq->hw_irq);\n\treturn rc;\n}\n\nstatic int reset_sub_crq_queues(struct ibmvnic_adapter *adapter)\n{\n\tint i, rc;\n\n\tif (!adapter->tx_scrq || !adapter->rx_scrq)\n\t\treturn -EINVAL;\n\n\tibmvnic_clean_affinity(adapter);\n\n\tfor (i = 0; i < adapter->req_tx_queues; i++) {\n\t\tnetdev_dbg(adapter->netdev, \"Re-setting tx_scrq[%d]\\n\", i);\n\t\trc = reset_one_sub_crq_queue(adapter, adapter->tx_scrq[i]);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tfor (i = 0; i < adapter->req_rx_queues; i++) {\n\t\tnetdev_dbg(adapter->netdev, \"Re-setting rx_scrq[%d]\\n\", i);\n\t\trc = reset_one_sub_crq_queue(adapter, adapter->rx_scrq[i]);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn rc;\n}\n\nstatic void release_sub_crq_queue(struct ibmvnic_adapter *adapter,\n\t\t\t\t  struct ibmvnic_sub_crq_queue *scrq,\n\t\t\t\t  bool do_h_free)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tlong rc;\n\n\tnetdev_dbg(adapter->netdev, \"Releasing sub-CRQ\\n\");\n\n\tif (do_h_free) {\n\t\t \n\t\tdo {\n\t\t\trc = plpar_hcall_norets(H_FREE_SUB_CRQ,\n\t\t\t\t\t\tadapter->vdev->unit_address,\n\t\t\t\t\t\tscrq->crq_num);\n\t\t} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\n\n\t\tif (rc) {\n\t\t\tnetdev_err(adapter->netdev,\n\t\t\t\t   \"Failed to release sub-CRQ %16lx, rc = %ld\\n\",\n\t\t\t\t   scrq->crq_num, rc);\n\t\t}\n\t}\n\n\tdma_free_coherent(dev,\n\t\t\t  IBMVNIC_IND_ARR_SZ,\n\t\t\t  scrq->ind_buf.indir_arr,\n\t\t\t  scrq->ind_buf.indir_dma);\n\n\tdma_unmap_single(dev, scrq->msg_token, 4 * PAGE_SIZE,\n\t\t\t DMA_BIDIRECTIONAL);\n\tfree_pages((unsigned long)scrq->msgs, 2);\n\tfree_cpumask_var(scrq->affinity_mask);\n\tkfree(scrq);\n}\n\nstatic struct ibmvnic_sub_crq_queue *init_sub_crq_queue(struct ibmvnic_adapter\n\t\t\t\t\t\t\t*adapter)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tstruct ibmvnic_sub_crq_queue *scrq;\n\tint rc;\n\n\tscrq = kzalloc(sizeof(*scrq), GFP_KERNEL);\n\tif (!scrq)\n\t\treturn NULL;\n\n\tscrq->msgs =\n\t\t(union sub_crq *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 2);\n\tif (!scrq->msgs) {\n\t\tdev_warn(dev, \"Couldn't allocate crq queue messages page\\n\");\n\t\tgoto zero_page_failed;\n\t}\n\tif (!zalloc_cpumask_var(&scrq->affinity_mask, GFP_KERNEL))\n\t\tgoto cpumask_alloc_failed;\n\n\tscrq->msg_token = dma_map_single(dev, scrq->msgs, 4 * PAGE_SIZE,\n\t\t\t\t\t DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(dev, scrq->msg_token)) {\n\t\tdev_warn(dev, \"Couldn't map crq queue messages page\\n\");\n\t\tgoto map_failed;\n\t}\n\n\trc = h_reg_sub_crq(adapter->vdev->unit_address, scrq->msg_token,\n\t\t\t   4 * PAGE_SIZE, &scrq->crq_num, &scrq->hw_irq);\n\n\tif (rc == H_RESOURCE)\n\t\trc = ibmvnic_reset_crq(adapter);\n\n\tif (rc == H_CLOSED) {\n\t\tdev_warn(dev, \"Partner adapter not ready, waiting.\\n\");\n\t} else if (rc) {\n\t\tdev_warn(dev, \"Error %d registering sub-crq\\n\", rc);\n\t\tgoto reg_failed;\n\t}\n\n\tscrq->adapter = adapter;\n\tscrq->size = 4 * PAGE_SIZE / sizeof(*scrq->msgs);\n\tscrq->ind_buf.index = 0;\n\n\tscrq->ind_buf.indir_arr =\n\t\tdma_alloc_coherent(dev,\n\t\t\t\t   IBMVNIC_IND_ARR_SZ,\n\t\t\t\t   &scrq->ind_buf.indir_dma,\n\t\t\t\t   GFP_KERNEL);\n\n\tif (!scrq->ind_buf.indir_arr)\n\t\tgoto indir_failed;\n\n\tspin_lock_init(&scrq->lock);\n\n\tnetdev_dbg(adapter->netdev,\n\t\t   \"sub-crq initialized, num %lx, hw_irq=%lx, irq=%x\\n\",\n\t\t   scrq->crq_num, scrq->hw_irq, scrq->irq);\n\n\treturn scrq;\n\nindir_failed:\n\tdo {\n\t\trc = plpar_hcall_norets(H_FREE_SUB_CRQ,\n\t\t\t\t\tadapter->vdev->unit_address,\n\t\t\t\t\tscrq->crq_num);\n\t} while (rc == H_BUSY || rc == H_IS_LONG_BUSY(rc));\nreg_failed:\n\tdma_unmap_single(dev, scrq->msg_token, 4 * PAGE_SIZE,\n\t\t\t DMA_BIDIRECTIONAL);\nmap_failed:\n\tfree_cpumask_var(scrq->affinity_mask);\ncpumask_alloc_failed:\n\tfree_pages((unsigned long)scrq->msgs, 2);\nzero_page_failed:\n\tkfree(scrq);\n\n\treturn NULL;\n}\n\nstatic void release_sub_crqs(struct ibmvnic_adapter *adapter, bool do_h_free)\n{\n\tint i;\n\n\tibmvnic_clean_affinity(adapter);\n\tif (adapter->tx_scrq) {\n\t\tfor (i = 0; i < adapter->num_active_tx_scrqs; i++) {\n\t\t\tif (!adapter->tx_scrq[i])\n\t\t\t\tcontinue;\n\n\t\t\tnetdev_dbg(adapter->netdev, \"Releasing tx_scrq[%d]\\n\",\n\t\t\t\t   i);\n\t\t\tibmvnic_tx_scrq_clean_buffer(adapter, adapter->tx_scrq[i]);\n\t\t\tif (adapter->tx_scrq[i]->irq) {\n\t\t\t\tfree_irq(adapter->tx_scrq[i]->irq,\n\t\t\t\t\t adapter->tx_scrq[i]);\n\t\t\t\tirq_dispose_mapping(adapter->tx_scrq[i]->irq);\n\t\t\t\tadapter->tx_scrq[i]->irq = 0;\n\t\t\t}\n\n\t\t\trelease_sub_crq_queue(adapter, adapter->tx_scrq[i],\n\t\t\t\t\t      do_h_free);\n\t\t}\n\n\t\tkfree(adapter->tx_scrq);\n\t\tadapter->tx_scrq = NULL;\n\t\tadapter->num_active_tx_scrqs = 0;\n\t}\n\n\tif (adapter->rx_scrq) {\n\t\tfor (i = 0; i < adapter->num_active_rx_scrqs; i++) {\n\t\t\tif (!adapter->rx_scrq[i])\n\t\t\t\tcontinue;\n\n\t\t\tnetdev_dbg(adapter->netdev, \"Releasing rx_scrq[%d]\\n\",\n\t\t\t\t   i);\n\t\t\tif (adapter->rx_scrq[i]->irq) {\n\t\t\t\tfree_irq(adapter->rx_scrq[i]->irq,\n\t\t\t\t\t adapter->rx_scrq[i]);\n\t\t\t\tirq_dispose_mapping(adapter->rx_scrq[i]->irq);\n\t\t\t\tadapter->rx_scrq[i]->irq = 0;\n\t\t\t}\n\n\t\t\trelease_sub_crq_queue(adapter, adapter->rx_scrq[i],\n\t\t\t\t\t      do_h_free);\n\t\t}\n\n\t\tkfree(adapter->rx_scrq);\n\t\tadapter->rx_scrq = NULL;\n\t\tadapter->num_active_rx_scrqs = 0;\n\t}\n}\n\nstatic int disable_scrq_irq(struct ibmvnic_adapter *adapter,\n\t\t\t    struct ibmvnic_sub_crq_queue *scrq)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tunsigned long rc;\n\n\trc = plpar_hcall_norets(H_VIOCTL, adapter->vdev->unit_address,\n\t\t\t\tH_DISABLE_VIO_INTERRUPT, scrq->hw_irq, 0, 0);\n\tif (rc)\n\t\tdev_err(dev, \"Couldn't disable scrq irq 0x%lx. rc=%ld\\n\",\n\t\t\tscrq->hw_irq, rc);\n\treturn rc;\n}\n\n \nstatic void ibmvnic_xics_eoi(struct device *dev, struct ibmvnic_sub_crq_queue *scrq)\n{\n\tu64 val = 0xff000000 | scrq->hw_irq;\n\tunsigned long rc;\n\n\trc = plpar_hcall_norets(H_EOI, val);\n\tif (rc)\n\t\tdev_err(dev, \"H_EOI FAILED irq 0x%llx. rc=%ld\\n\", val, rc);\n}\n\n \nstatic void ibmvnic_clear_pending_interrupt(struct device *dev,\n\t\t\t\t\t    struct ibmvnic_sub_crq_queue *scrq)\n{\n\tif (!xive_enabled())\n\t\tibmvnic_xics_eoi(dev, scrq);\n}\n\nstatic int enable_scrq_irq(struct ibmvnic_adapter *adapter,\n\t\t\t   struct ibmvnic_sub_crq_queue *scrq)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tunsigned long rc;\n\n\tif (scrq->hw_irq > 0x100000000ULL) {\n\t\tdev_err(dev, \"bad hw_irq = %lx\\n\", scrq->hw_irq);\n\t\treturn 1;\n\t}\n\n\tif (test_bit(0, &adapter->resetting) &&\n\t    adapter->reset_reason == VNIC_RESET_MOBILITY) {\n\t\tibmvnic_clear_pending_interrupt(dev, scrq);\n\t}\n\n\trc = plpar_hcall_norets(H_VIOCTL, adapter->vdev->unit_address,\n\t\t\t\tH_ENABLE_VIO_INTERRUPT, scrq->hw_irq, 0, 0);\n\tif (rc)\n\t\tdev_err(dev, \"Couldn't enable scrq irq 0x%lx. rc=%ld\\n\",\n\t\t\tscrq->hw_irq, rc);\n\treturn rc;\n}\n\nstatic int ibmvnic_complete_tx(struct ibmvnic_adapter *adapter,\n\t\t\t       struct ibmvnic_sub_crq_queue *scrq)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tstruct ibmvnic_tx_pool *tx_pool;\n\tstruct ibmvnic_tx_buff *txbuff;\n\tstruct netdev_queue *txq;\n\tunion sub_crq *next;\n\tint index;\n\tint i;\n\nrestart_loop:\n\twhile (pending_scrq(adapter, scrq)) {\n\t\tunsigned int pool = scrq->pool_index;\n\t\tint num_entries = 0;\n\t\tint total_bytes = 0;\n\t\tint num_packets = 0;\n\n\t\tnext = ibmvnic_next_scrq(adapter, scrq);\n\t\tfor (i = 0; i < next->tx_comp.num_comps; i++) {\n\t\t\tindex = be32_to_cpu(next->tx_comp.correlators[i]);\n\t\t\tif (index & IBMVNIC_TSO_POOL_MASK) {\n\t\t\t\ttx_pool = &adapter->tso_pool[pool];\n\t\t\t\tindex &= ~IBMVNIC_TSO_POOL_MASK;\n\t\t\t} else {\n\t\t\t\ttx_pool = &adapter->tx_pool[pool];\n\t\t\t}\n\n\t\t\ttxbuff = &tx_pool->tx_buff[index];\n\t\t\tnum_packets++;\n\t\t\tnum_entries += txbuff->num_entries;\n\t\t\tif (txbuff->skb) {\n\t\t\t\ttotal_bytes += txbuff->skb->len;\n\t\t\t\tif (next->tx_comp.rcs[i]) {\n\t\t\t\t\tdev_err(dev, \"tx error %x\\n\",\n\t\t\t\t\t\tnext->tx_comp.rcs[i]);\n\t\t\t\t\tdev_kfree_skb_irq(txbuff->skb);\n\t\t\t\t} else {\n\t\t\t\t\tdev_consume_skb_irq(txbuff->skb);\n\t\t\t\t}\n\t\t\t\ttxbuff->skb = NULL;\n\t\t\t} else {\n\t\t\t\tnetdev_warn(adapter->netdev,\n\t\t\t\t\t    \"TX completion received with NULL socket buffer\\n\");\n\t\t\t}\n\t\t\ttx_pool->free_map[tx_pool->producer_index] = index;\n\t\t\ttx_pool->producer_index =\n\t\t\t\t(tx_pool->producer_index + 1) %\n\t\t\t\t\ttx_pool->num_buffers;\n\t\t}\n\t\t \n\t\tnext->tx_comp.first = 0;\n\n\t\ttxq = netdev_get_tx_queue(adapter->netdev, scrq->pool_index);\n\t\tnetdev_tx_completed_queue(txq, num_packets, total_bytes);\n\n\t\tif (atomic_sub_return(num_entries, &scrq->used) <=\n\t\t    (adapter->req_tx_entries_per_subcrq / 2) &&\n\t\t    __netif_subqueue_stopped(adapter->netdev,\n\t\t\t\t\t     scrq->pool_index)) {\n\t\t\trcu_read_lock();\n\t\t\tif (adapter->tx_queues_active) {\n\t\t\t\tnetif_wake_subqueue(adapter->netdev,\n\t\t\t\t\t\t    scrq->pool_index);\n\t\t\t\tnetdev_dbg(adapter->netdev,\n\t\t\t\t\t   \"Started queue %d\\n\",\n\t\t\t\t\t   scrq->pool_index);\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t}\n\t}\n\n\tenable_scrq_irq(adapter, scrq);\n\n\tif (pending_scrq(adapter, scrq)) {\n\t\tdisable_scrq_irq(adapter, scrq);\n\t\tgoto restart_loop;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t ibmvnic_interrupt_tx(int irq, void *instance)\n{\n\tstruct ibmvnic_sub_crq_queue *scrq = instance;\n\tstruct ibmvnic_adapter *adapter = scrq->adapter;\n\n\tdisable_scrq_irq(adapter, scrq);\n\tibmvnic_complete_tx(adapter, scrq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ibmvnic_interrupt_rx(int irq, void *instance)\n{\n\tstruct ibmvnic_sub_crq_queue *scrq = instance;\n\tstruct ibmvnic_adapter *adapter = scrq->adapter;\n\n\t \n\tif (unlikely(adapter->state != VNIC_OPEN))\n\t\treturn IRQ_NONE;\n\n\tadapter->rx_stats_buffers[scrq->scrq_num].interrupts++;\n\n\tif (napi_schedule_prep(&adapter->napi[scrq->scrq_num])) {\n\t\tdisable_scrq_irq(adapter, scrq);\n\t\t__napi_schedule(&adapter->napi[scrq->scrq_num]);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int init_sub_crq_irqs(struct ibmvnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tstruct ibmvnic_sub_crq_queue *scrq;\n\tint i = 0, j = 0;\n\tint rc = 0;\n\n\tfor (i = 0; i < adapter->req_tx_queues; i++) {\n\t\tnetdev_dbg(adapter->netdev, \"Initializing tx_scrq[%d] irq\\n\",\n\t\t\t   i);\n\t\tscrq = adapter->tx_scrq[i];\n\t\tscrq->irq = irq_create_mapping(NULL, scrq->hw_irq);\n\n\t\tif (!scrq->irq) {\n\t\t\trc = -EINVAL;\n\t\t\tdev_err(dev, \"Error mapping irq\\n\");\n\t\t\tgoto req_tx_irq_failed;\n\t\t}\n\n\t\tsnprintf(scrq->name, sizeof(scrq->name), \"ibmvnic-%x-tx%d\",\n\t\t\t adapter->vdev->unit_address, i);\n\t\trc = request_irq(scrq->irq, ibmvnic_interrupt_tx,\n\t\t\t\t 0, scrq->name, scrq);\n\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Couldn't register tx irq 0x%x. rc=%d\\n\",\n\t\t\t\tscrq->irq, rc);\n\t\t\tirq_dispose_mapping(scrq->irq);\n\t\t\tgoto req_tx_irq_failed;\n\t\t}\n\t}\n\n\tfor (i = 0; i < adapter->req_rx_queues; i++) {\n\t\tnetdev_dbg(adapter->netdev, \"Initializing rx_scrq[%d] irq\\n\",\n\t\t\t   i);\n\t\tscrq = adapter->rx_scrq[i];\n\t\tscrq->irq = irq_create_mapping(NULL, scrq->hw_irq);\n\t\tif (!scrq->irq) {\n\t\t\trc = -EINVAL;\n\t\t\tdev_err(dev, \"Error mapping irq\\n\");\n\t\t\tgoto req_rx_irq_failed;\n\t\t}\n\t\tsnprintf(scrq->name, sizeof(scrq->name), \"ibmvnic-%x-rx%d\",\n\t\t\t adapter->vdev->unit_address, i);\n\t\trc = request_irq(scrq->irq, ibmvnic_interrupt_rx,\n\t\t\t\t 0, scrq->name, scrq);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Couldn't register rx irq 0x%x. rc=%d\\n\",\n\t\t\t\tscrq->irq, rc);\n\t\t\tirq_dispose_mapping(scrq->irq);\n\t\t\tgoto req_rx_irq_failed;\n\t\t}\n\t}\n\n\tcpus_read_lock();\n\tibmvnic_set_affinity(adapter);\n\tcpus_read_unlock();\n\n\treturn rc;\n\nreq_rx_irq_failed:\n\tfor (j = 0; j < i; j++) {\n\t\tfree_irq(adapter->rx_scrq[j]->irq, adapter->rx_scrq[j]);\n\t\tirq_dispose_mapping(adapter->rx_scrq[j]->irq);\n\t}\n\ti = adapter->req_tx_queues;\nreq_tx_irq_failed:\n\tfor (j = 0; j < i; j++) {\n\t\tfree_irq(adapter->tx_scrq[j]->irq, adapter->tx_scrq[j]);\n\t\tirq_dispose_mapping(adapter->tx_scrq[j]->irq);\n\t}\n\trelease_sub_crqs(adapter, 1);\n\treturn rc;\n}\n\nstatic int init_sub_crqs(struct ibmvnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tstruct ibmvnic_sub_crq_queue **allqueues;\n\tint registered_queues = 0;\n\tint total_queues;\n\tint more = 0;\n\tint i;\n\n\ttotal_queues = adapter->req_tx_queues + adapter->req_rx_queues;\n\n\tallqueues = kcalloc(total_queues, sizeof(*allqueues), GFP_KERNEL);\n\tif (!allqueues)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < total_queues; i++) {\n\t\tallqueues[i] = init_sub_crq_queue(adapter);\n\t\tif (!allqueues[i]) {\n\t\t\tdev_warn(dev, \"Couldn't allocate all sub-crqs\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tregistered_queues++;\n\t}\n\n\t \n\tif (registered_queues <\n\t    adapter->min_tx_queues + adapter->min_rx_queues) {\n\t\tdev_err(dev, \"Fatal: Couldn't init  min number of sub-crqs\\n\");\n\t\tgoto tx_failed;\n\t}\n\n\t \n\tfor (i = 0; i < total_queues - registered_queues + more ; i++) {\n\t\tnetdev_dbg(adapter->netdev, \"Reducing number of queues\\n\");\n\t\tswitch (i % 3) {\n\t\tcase 0:\n\t\t\tif (adapter->req_rx_queues > adapter->min_rx_queues)\n\t\t\t\tadapter->req_rx_queues--;\n\t\t\telse\n\t\t\t\tmore++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (adapter->req_tx_queues > adapter->min_tx_queues)\n\t\t\t\tadapter->req_tx_queues--;\n\t\t\telse\n\t\t\t\tmore++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tadapter->tx_scrq = kcalloc(adapter->req_tx_queues,\n\t\t\t\t   sizeof(*adapter->tx_scrq), GFP_KERNEL);\n\tif (!adapter->tx_scrq)\n\t\tgoto tx_failed;\n\n\tfor (i = 0; i < adapter->req_tx_queues; i++) {\n\t\tadapter->tx_scrq[i] = allqueues[i];\n\t\tadapter->tx_scrq[i]->pool_index = i;\n\t\tadapter->num_active_tx_scrqs++;\n\t}\n\n\tadapter->rx_scrq = kcalloc(adapter->req_rx_queues,\n\t\t\t\t   sizeof(*adapter->rx_scrq), GFP_KERNEL);\n\tif (!adapter->rx_scrq)\n\t\tgoto rx_failed;\n\n\tfor (i = 0; i < adapter->req_rx_queues; i++) {\n\t\tadapter->rx_scrq[i] = allqueues[i + adapter->req_tx_queues];\n\t\tadapter->rx_scrq[i]->scrq_num = i;\n\t\tadapter->num_active_rx_scrqs++;\n\t}\n\n\tkfree(allqueues);\n\treturn 0;\n\nrx_failed:\n\tkfree(adapter->tx_scrq);\n\tadapter->tx_scrq = NULL;\ntx_failed:\n\tfor (i = 0; i < registered_queues; i++)\n\t\trelease_sub_crq_queue(adapter, allqueues[i], 1);\n\tkfree(allqueues);\n\treturn -ENOMEM;\n}\n\nstatic void send_request_cap(struct ibmvnic_adapter *adapter, int retry)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tunion ibmvnic_crq crq;\n\tint max_entries;\n\tint cap_reqs;\n\n\t \n\tif (!(adapter->netdev->flags & IFF_PROMISC) ||\n\t    adapter->promisc_supported)\n\t\tcap_reqs = 7;\n\telse\n\t\tcap_reqs = 6;\n\n\tif (!retry) {\n\t\t \n\t\tint entries_page = 4 * PAGE_SIZE / (sizeof(u64) * 4);\n\n\t\tatomic_set(&adapter->running_cap_crqs, cap_reqs);\n\n\t\tif (adapter->min_tx_entries_per_subcrq > entries_page ||\n\t\t    adapter->min_rx_add_entries_per_subcrq > entries_page) {\n\t\t\tdev_err(dev, \"Fatal, invalid entries per sub-crq\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (adapter->desired.mtu)\n\t\t\tadapter->req_mtu = adapter->desired.mtu;\n\t\telse\n\t\t\tadapter->req_mtu = adapter->netdev->mtu + ETH_HLEN;\n\n\t\tif (!adapter->desired.tx_entries)\n\t\t\tadapter->desired.tx_entries =\n\t\t\t\t\tadapter->max_tx_entries_per_subcrq;\n\t\tif (!adapter->desired.rx_entries)\n\t\t\tadapter->desired.rx_entries =\n\t\t\t\t\tadapter->max_rx_add_entries_per_subcrq;\n\n\t\tmax_entries = IBMVNIC_LTB_SET_SIZE /\n\t\t\t      (adapter->req_mtu + IBMVNIC_BUFFER_HLEN);\n\n\t\tif ((adapter->req_mtu + IBMVNIC_BUFFER_HLEN) *\n\t\t\tadapter->desired.tx_entries > IBMVNIC_LTB_SET_SIZE) {\n\t\t\tadapter->desired.tx_entries = max_entries;\n\t\t}\n\n\t\tif ((adapter->req_mtu + IBMVNIC_BUFFER_HLEN) *\n\t\t\tadapter->desired.rx_entries > IBMVNIC_LTB_SET_SIZE) {\n\t\t\tadapter->desired.rx_entries = max_entries;\n\t\t}\n\n\t\tif (adapter->desired.tx_entries)\n\t\t\tadapter->req_tx_entries_per_subcrq =\n\t\t\t\t\tadapter->desired.tx_entries;\n\t\telse\n\t\t\tadapter->req_tx_entries_per_subcrq =\n\t\t\t\t\tadapter->max_tx_entries_per_subcrq;\n\n\t\tif (adapter->desired.rx_entries)\n\t\t\tadapter->req_rx_add_entries_per_subcrq =\n\t\t\t\t\tadapter->desired.rx_entries;\n\t\telse\n\t\t\tadapter->req_rx_add_entries_per_subcrq =\n\t\t\t\t\tadapter->max_rx_add_entries_per_subcrq;\n\n\t\tif (adapter->desired.tx_queues)\n\t\t\tadapter->req_tx_queues =\n\t\t\t\t\tadapter->desired.tx_queues;\n\t\telse\n\t\t\tadapter->req_tx_queues =\n\t\t\t\t\tadapter->opt_tx_comp_sub_queues;\n\n\t\tif (adapter->desired.rx_queues)\n\t\t\tadapter->req_rx_queues =\n\t\t\t\t\tadapter->desired.rx_queues;\n\t\telse\n\t\t\tadapter->req_rx_queues =\n\t\t\t\t\tadapter->opt_rx_comp_queues;\n\n\t\tadapter->req_rx_add_queues = adapter->max_rx_add_queues;\n\t} else {\n\t\tatomic_add(cap_reqs, &adapter->running_cap_crqs);\n\t}\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.request_capability.first = IBMVNIC_CRQ_CMD;\n\tcrq.request_capability.cmd = REQUEST_CAPABILITY;\n\n\tcrq.request_capability.capability = cpu_to_be16(REQ_TX_QUEUES);\n\tcrq.request_capability.number = cpu_to_be64(adapter->req_tx_queues);\n\tcap_reqs--;\n\tibmvnic_send_crq(adapter, &crq);\n\n\tcrq.request_capability.capability = cpu_to_be16(REQ_RX_QUEUES);\n\tcrq.request_capability.number = cpu_to_be64(adapter->req_rx_queues);\n\tcap_reqs--;\n\tibmvnic_send_crq(adapter, &crq);\n\n\tcrq.request_capability.capability = cpu_to_be16(REQ_RX_ADD_QUEUES);\n\tcrq.request_capability.number = cpu_to_be64(adapter->req_rx_add_queues);\n\tcap_reqs--;\n\tibmvnic_send_crq(adapter, &crq);\n\n\tcrq.request_capability.capability =\n\t    cpu_to_be16(REQ_TX_ENTRIES_PER_SUBCRQ);\n\tcrq.request_capability.number =\n\t    cpu_to_be64(adapter->req_tx_entries_per_subcrq);\n\tcap_reqs--;\n\tibmvnic_send_crq(adapter, &crq);\n\n\tcrq.request_capability.capability =\n\t    cpu_to_be16(REQ_RX_ADD_ENTRIES_PER_SUBCRQ);\n\tcrq.request_capability.number =\n\t    cpu_to_be64(adapter->req_rx_add_entries_per_subcrq);\n\tcap_reqs--;\n\tibmvnic_send_crq(adapter, &crq);\n\n\tcrq.request_capability.capability = cpu_to_be16(REQ_MTU);\n\tcrq.request_capability.number = cpu_to_be64(adapter->req_mtu);\n\tcap_reqs--;\n\tibmvnic_send_crq(adapter, &crq);\n\n\tif (adapter->netdev->flags & IFF_PROMISC) {\n\t\tif (adapter->promisc_supported) {\n\t\t\tcrq.request_capability.capability =\n\t\t\t    cpu_to_be16(PROMISC_REQUESTED);\n\t\t\tcrq.request_capability.number = cpu_to_be64(1);\n\t\t\tcap_reqs--;\n\t\t\tibmvnic_send_crq(adapter, &crq);\n\t\t}\n\t} else {\n\t\tcrq.request_capability.capability =\n\t\t    cpu_to_be16(PROMISC_REQUESTED);\n\t\tcrq.request_capability.number = cpu_to_be64(0);\n\t\tcap_reqs--;\n\t\tibmvnic_send_crq(adapter, &crq);\n\t}\n\n\t \n\tWARN_ON(cap_reqs != 0);\n}\n\nstatic int pending_scrq(struct ibmvnic_adapter *adapter,\n\t\t\tstruct ibmvnic_sub_crq_queue *scrq)\n{\n\tunion sub_crq *entry = &scrq->msgs[scrq->cur];\n\tint rc;\n\n\trc = !!(entry->generic.first & IBMVNIC_CRQ_CMD_RSP);\n\n\t \n\tdma_rmb();\n\n\treturn rc;\n}\n\nstatic union sub_crq *ibmvnic_next_scrq(struct ibmvnic_adapter *adapter,\n\t\t\t\t\tstruct ibmvnic_sub_crq_queue *scrq)\n{\n\tunion sub_crq *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&scrq->lock, flags);\n\tentry = &scrq->msgs[scrq->cur];\n\tif (entry->generic.first & IBMVNIC_CRQ_CMD_RSP) {\n\t\tif (++scrq->cur == scrq->size)\n\t\t\tscrq->cur = 0;\n\t} else {\n\t\tentry = NULL;\n\t}\n\tspin_unlock_irqrestore(&scrq->lock, flags);\n\n\t \n\tdma_rmb();\n\n\treturn entry;\n}\n\nstatic union ibmvnic_crq *ibmvnic_next_crq(struct ibmvnic_adapter *adapter)\n{\n\tstruct ibmvnic_crq_queue *queue = &adapter->crq;\n\tunion ibmvnic_crq *crq;\n\n\tcrq = &queue->msgs[queue->cur];\n\tif (crq->generic.first & IBMVNIC_CRQ_CMD_RSP) {\n\t\tif (++queue->cur == queue->size)\n\t\t\tqueue->cur = 0;\n\t} else {\n\t\tcrq = NULL;\n\t}\n\n\treturn crq;\n}\n\nstatic void print_subcrq_error(struct device *dev, int rc, const char *func)\n{\n\tswitch (rc) {\n\tcase H_PARAMETER:\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\t     \"%s failed: Send request is malformed or adapter failover pending. (rc=%d)\\n\",\n\t\t\t\t     func, rc);\n\t\tbreak;\n\tcase H_CLOSED:\n\t\tdev_warn_ratelimited(dev,\n\t\t\t\t     \"%s failed: Backing queue closed. Adapter is down or failover pending. (rc=%d)\\n\",\n\t\t\t\t     func, rc);\n\t\tbreak;\n\tdefault:\n\t\tdev_err_ratelimited(dev, \"%s failed: (rc=%d)\\n\", func, rc);\n\t\tbreak;\n\t}\n}\n\nstatic int send_subcrq_indirect(struct ibmvnic_adapter *adapter,\n\t\t\t\tu64 remote_handle, u64 ioba, u64 num_entries)\n{\n\tunsigned int ua = adapter->vdev->unit_address;\n\tstruct device *dev = &adapter->vdev->dev;\n\tint rc;\n\n\t \n\tdma_wmb();\n\trc = plpar_hcall_norets(H_SEND_SUB_CRQ_INDIRECT, ua,\n\t\t\t\tcpu_to_be64(remote_handle),\n\t\t\t\tioba, num_entries);\n\n\tif (rc)\n\t\tprint_subcrq_error(dev, rc, __func__);\n\n\treturn rc;\n}\n\nstatic int ibmvnic_send_crq(struct ibmvnic_adapter *adapter,\n\t\t\t    union ibmvnic_crq *crq)\n{\n\tunsigned int ua = adapter->vdev->unit_address;\n\tstruct device *dev = &adapter->vdev->dev;\n\tu64 *u64_crq = (u64 *)crq;\n\tint rc;\n\n\tnetdev_dbg(adapter->netdev, \"Sending CRQ: %016lx %016lx\\n\",\n\t\t   (unsigned long)cpu_to_be64(u64_crq[0]),\n\t\t   (unsigned long)cpu_to_be64(u64_crq[1]));\n\n\tif (!adapter->crq.active &&\n\t    crq->generic.first != IBMVNIC_CRQ_INIT_CMD) {\n\t\tdev_warn(dev, \"Invalid request detected while CRQ is inactive, possible device state change during reset\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdma_wmb();\n\n\trc = plpar_hcall_norets(H_SEND_CRQ, ua,\n\t\t\t\tcpu_to_be64(u64_crq[0]),\n\t\t\t\tcpu_to_be64(u64_crq[1]));\n\n\tif (rc) {\n\t\tif (rc == H_CLOSED) {\n\t\t\tdev_warn(dev, \"CRQ Queue closed\\n\");\n\t\t\t \n\t\t}\n\n\t\tdev_warn(dev, \"Send error (rc=%d)\\n\", rc);\n\t}\n\n\treturn rc;\n}\n\nstatic int ibmvnic_send_crq_init(struct ibmvnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tunion ibmvnic_crq crq;\n\tint retries = 100;\n\tint rc;\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.generic.first = IBMVNIC_CRQ_INIT_CMD;\n\tcrq.generic.cmd = IBMVNIC_CRQ_INIT;\n\tnetdev_dbg(adapter->netdev, \"Sending CRQ init\\n\");\n\n\tdo {\n\t\trc = ibmvnic_send_crq(adapter, &crq);\n\t\tif (rc != H_CLOSED)\n\t\t\tbreak;\n\t\tretries--;\n\t\tmsleep(50);\n\n\t} while (retries > 0);\n\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to send init request, rc = %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstruct vnic_login_client_data {\n\tu8\ttype;\n\t__be16\tlen;\n\tchar\tname[];\n} __packed;\n\nstatic int vnic_client_data_len(struct ibmvnic_adapter *adapter)\n{\n\tint len;\n\n\t \n\tlen = 4 * sizeof(struct vnic_login_client_data);\n\tlen += 6;  \n\tlen += strlen(utsname()->nodename) + 1;\n\tlen += strlen(adapter->netdev->name) + 1;\n\n\treturn len;\n}\n\nstatic void vnic_add_client_data(struct ibmvnic_adapter *adapter,\n\t\t\t\t struct vnic_login_client_data *vlcd)\n{\n\tconst char *os_name = \"Linux\";\n\tint len;\n\n\t \n\tvlcd->type = 1;\n\tlen = strlen(os_name) + 1;\n\tvlcd->len = cpu_to_be16(len);\n\tstrscpy(vlcd->name, os_name, len);\n\tvlcd = (struct vnic_login_client_data *)(vlcd->name + len);\n\n\t \n\tvlcd->type = 2;\n\tlen = strlen(utsname()->nodename) + 1;\n\tvlcd->len = cpu_to_be16(len);\n\tstrscpy(vlcd->name, utsname()->nodename, len);\n\tvlcd = (struct vnic_login_client_data *)(vlcd->name + len);\n\n\t \n\tvlcd->type = 3;\n\tlen = strlen(adapter->netdev->name) + 1;\n\tvlcd->len = cpu_to_be16(len);\n\tstrscpy(vlcd->name, adapter->netdev->name, len);\n}\n\nstatic int send_login(struct ibmvnic_adapter *adapter)\n{\n\tstruct ibmvnic_login_rsp_buffer *login_rsp_buffer;\n\tstruct ibmvnic_login_buffer *login_buffer;\n\tstruct device *dev = &adapter->vdev->dev;\n\tstruct vnic_login_client_data *vlcd;\n\tdma_addr_t rsp_buffer_token;\n\tdma_addr_t buffer_token;\n\tsize_t rsp_buffer_size;\n\tunion ibmvnic_crq crq;\n\tint client_data_len;\n\tsize_t buffer_size;\n\t__be64 *tx_list_p;\n\t__be64 *rx_list_p;\n\tint rc;\n\tint i;\n\n\tif (!adapter->tx_scrq || !adapter->rx_scrq) {\n\t\tnetdev_err(adapter->netdev,\n\t\t\t   \"RX or TX queues are not allocated, device login failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trelease_login_buffer(adapter);\n\trelease_login_rsp_buffer(adapter);\n\n\tclient_data_len = vnic_client_data_len(adapter);\n\n\tbuffer_size =\n\t    sizeof(struct ibmvnic_login_buffer) +\n\t    sizeof(u64) * (adapter->req_tx_queues + adapter->req_rx_queues) +\n\t    client_data_len;\n\n\tlogin_buffer = kzalloc(buffer_size, GFP_ATOMIC);\n\tif (!login_buffer)\n\t\tgoto buf_alloc_failed;\n\n\tbuffer_token = dma_map_single(dev, login_buffer, buffer_size,\n\t\t\t\t      DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, buffer_token)) {\n\t\tdev_err(dev, \"Couldn't map login buffer\\n\");\n\t\tgoto buf_map_failed;\n\t}\n\n\trsp_buffer_size = sizeof(struct ibmvnic_login_rsp_buffer) +\n\t\t\t  sizeof(u64) * adapter->req_tx_queues +\n\t\t\t  sizeof(u64) * adapter->req_rx_queues +\n\t\t\t  sizeof(u64) * adapter->req_rx_queues +\n\t\t\t  sizeof(u8) * IBMVNIC_TX_DESC_VERSIONS;\n\n\tlogin_rsp_buffer = kmalloc(rsp_buffer_size, GFP_ATOMIC);\n\tif (!login_rsp_buffer)\n\t\tgoto buf_rsp_alloc_failed;\n\n\trsp_buffer_token = dma_map_single(dev, login_rsp_buffer,\n\t\t\t\t\t  rsp_buffer_size, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, rsp_buffer_token)) {\n\t\tdev_err(dev, \"Couldn't map login rsp buffer\\n\");\n\t\tgoto buf_rsp_map_failed;\n\t}\n\n\tadapter->login_buf = login_buffer;\n\tadapter->login_buf_token = buffer_token;\n\tadapter->login_buf_sz = buffer_size;\n\tadapter->login_rsp_buf = login_rsp_buffer;\n\tadapter->login_rsp_buf_token = rsp_buffer_token;\n\tadapter->login_rsp_buf_sz = rsp_buffer_size;\n\n\tlogin_buffer->len = cpu_to_be32(buffer_size);\n\tlogin_buffer->version = cpu_to_be32(INITIAL_VERSION_LB);\n\tlogin_buffer->num_txcomp_subcrqs = cpu_to_be32(adapter->req_tx_queues);\n\tlogin_buffer->off_txcomp_subcrqs =\n\t    cpu_to_be32(sizeof(struct ibmvnic_login_buffer));\n\tlogin_buffer->num_rxcomp_subcrqs = cpu_to_be32(adapter->req_rx_queues);\n\tlogin_buffer->off_rxcomp_subcrqs =\n\t    cpu_to_be32(sizeof(struct ibmvnic_login_buffer) +\n\t\t\tsizeof(u64) * adapter->req_tx_queues);\n\tlogin_buffer->login_rsp_ioba = cpu_to_be32(rsp_buffer_token);\n\tlogin_buffer->login_rsp_len = cpu_to_be32(rsp_buffer_size);\n\n\ttx_list_p = (__be64 *)((char *)login_buffer +\n\t\t\t\t      sizeof(struct ibmvnic_login_buffer));\n\trx_list_p = (__be64 *)((char *)login_buffer +\n\t\t\t\t      sizeof(struct ibmvnic_login_buffer) +\n\t\t\t\t      sizeof(u64) * adapter->req_tx_queues);\n\n\tfor (i = 0; i < adapter->req_tx_queues; i++) {\n\t\tif (adapter->tx_scrq[i]) {\n\t\t\ttx_list_p[i] =\n\t\t\t\tcpu_to_be64(adapter->tx_scrq[i]->crq_num);\n\t\t}\n\t}\n\n\tfor (i = 0; i < adapter->req_rx_queues; i++) {\n\t\tif (adapter->rx_scrq[i]) {\n\t\t\trx_list_p[i] =\n\t\t\t\tcpu_to_be64(adapter->rx_scrq[i]->crq_num);\n\t\t}\n\t}\n\n\t \n\tvlcd = (struct vnic_login_client_data *)\n\t\t((char *)rx_list_p + (sizeof(u64) * adapter->req_rx_queues));\n\tlogin_buffer->client_data_offset =\n\t\t\tcpu_to_be32((char *)vlcd - (char *)login_buffer);\n\tlogin_buffer->client_data_len = cpu_to_be32(client_data_len);\n\n\tvnic_add_client_data(adapter, vlcd);\n\n\tnetdev_dbg(adapter->netdev, \"Login Buffer:\\n\");\n\tfor (i = 0; i < (adapter->login_buf_sz - 1) / 8 + 1; i++) {\n\t\tnetdev_dbg(adapter->netdev, \"%016lx\\n\",\n\t\t\t   ((unsigned long *)(adapter->login_buf))[i]);\n\t}\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.login.first = IBMVNIC_CRQ_CMD;\n\tcrq.login.cmd = LOGIN;\n\tcrq.login.ioba = cpu_to_be32(buffer_token);\n\tcrq.login.len = cpu_to_be32(buffer_size);\n\n\tadapter->login_pending = true;\n\trc = ibmvnic_send_crq(adapter, &crq);\n\tif (rc) {\n\t\tadapter->login_pending = false;\n\t\tnetdev_err(adapter->netdev, \"Failed to send login, rc=%d\\n\", rc);\n\t\tgoto buf_send_failed;\n\t}\n\n\treturn 0;\n\nbuf_send_failed:\n\tdma_unmap_single(dev, rsp_buffer_token, rsp_buffer_size,\n\t\t\t DMA_FROM_DEVICE);\nbuf_rsp_map_failed:\n\tkfree(login_rsp_buffer);\n\tadapter->login_rsp_buf = NULL;\nbuf_rsp_alloc_failed:\n\tdma_unmap_single(dev, buffer_token, buffer_size, DMA_TO_DEVICE);\nbuf_map_failed:\n\tkfree(login_buffer);\n\tadapter->login_buf = NULL;\nbuf_alloc_failed:\n\treturn -ENOMEM;\n}\n\nstatic int send_request_map(struct ibmvnic_adapter *adapter, dma_addr_t addr,\n\t\t\t    u32 len, u8 map_id)\n{\n\tunion ibmvnic_crq crq;\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.request_map.first = IBMVNIC_CRQ_CMD;\n\tcrq.request_map.cmd = REQUEST_MAP;\n\tcrq.request_map.map_id = map_id;\n\tcrq.request_map.ioba = cpu_to_be32(addr);\n\tcrq.request_map.len = cpu_to_be32(len);\n\treturn ibmvnic_send_crq(adapter, &crq);\n}\n\nstatic int send_request_unmap(struct ibmvnic_adapter *adapter, u8 map_id)\n{\n\tunion ibmvnic_crq crq;\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.request_unmap.first = IBMVNIC_CRQ_CMD;\n\tcrq.request_unmap.cmd = REQUEST_UNMAP;\n\tcrq.request_unmap.map_id = map_id;\n\treturn ibmvnic_send_crq(adapter, &crq);\n}\n\nstatic void send_query_map(struct ibmvnic_adapter *adapter)\n{\n\tunion ibmvnic_crq crq;\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.query_map.first = IBMVNIC_CRQ_CMD;\n\tcrq.query_map.cmd = QUERY_MAP;\n\tibmvnic_send_crq(adapter, &crq);\n}\n\n \nstatic void send_query_cap(struct ibmvnic_adapter *adapter)\n{\n\tunion ibmvnic_crq crq;\n\tint cap_reqs;\n\n\t \n\tcap_reqs = 25;\n\n\tatomic_set(&adapter->running_cap_crqs, cap_reqs);\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.query_capability.first = IBMVNIC_CRQ_CMD;\n\tcrq.query_capability.cmd = QUERY_CAPABILITY;\n\n\tcrq.query_capability.capability = cpu_to_be16(MIN_TX_QUEUES);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(MIN_RX_QUEUES);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(MIN_RX_ADD_QUEUES);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(MAX_TX_QUEUES);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(MAX_RX_QUEUES);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(MAX_RX_ADD_QUEUES);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability =\n\t    cpu_to_be16(MIN_TX_ENTRIES_PER_SUBCRQ);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability =\n\t    cpu_to_be16(MIN_RX_ADD_ENTRIES_PER_SUBCRQ);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability =\n\t    cpu_to_be16(MAX_TX_ENTRIES_PER_SUBCRQ);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability =\n\t    cpu_to_be16(MAX_RX_ADD_ENTRIES_PER_SUBCRQ);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(TCP_IP_OFFLOAD);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(PROMISC_SUPPORTED);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(MIN_MTU);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(MAX_MTU);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(MAX_MULTICAST_FILTERS);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(VLAN_HEADER_INSERTION);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(RX_VLAN_HEADER_INSERTION);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(MAX_TX_SG_ENTRIES);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(RX_SG_SUPPORTED);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(OPT_TX_COMP_SUB_QUEUES);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(OPT_RX_COMP_QUEUES);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability =\n\t\t\tcpu_to_be16(OPT_RX_BUFADD_Q_PER_RX_COMP_Q);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability =\n\t\t\tcpu_to_be16(OPT_TX_ENTRIES_PER_SUBCRQ);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability =\n\t\t\tcpu_to_be16(OPT_RXBA_ENTRIES_PER_SUBCRQ);\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\tcrq.query_capability.capability = cpu_to_be16(TX_RX_DESC_REQ);\n\n\tibmvnic_send_crq(adapter, &crq);\n\tcap_reqs--;\n\n\t \n\tWARN_ON(cap_reqs != 0);\n}\n\nstatic void send_query_ip_offload(struct ibmvnic_adapter *adapter)\n{\n\tint buf_sz = sizeof(struct ibmvnic_query_ip_offload_buffer);\n\tstruct device *dev = &adapter->vdev->dev;\n\tunion ibmvnic_crq crq;\n\n\tadapter->ip_offload_tok =\n\t\tdma_map_single(dev,\n\t\t\t       &adapter->ip_offload_buf,\n\t\t\t       buf_sz,\n\t\t\t       DMA_FROM_DEVICE);\n\n\tif (dma_mapping_error(dev, adapter->ip_offload_tok)) {\n\t\tif (!firmware_has_feature(FW_FEATURE_CMO))\n\t\t\tdev_err(dev, \"Couldn't map offload buffer\\n\");\n\t\treturn;\n\t}\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.query_ip_offload.first = IBMVNIC_CRQ_CMD;\n\tcrq.query_ip_offload.cmd = QUERY_IP_OFFLOAD;\n\tcrq.query_ip_offload.len = cpu_to_be32(buf_sz);\n\tcrq.query_ip_offload.ioba =\n\t    cpu_to_be32(adapter->ip_offload_tok);\n\n\tibmvnic_send_crq(adapter, &crq);\n}\n\nstatic void send_control_ip_offload(struct ibmvnic_adapter *adapter)\n{\n\tstruct ibmvnic_control_ip_offload_buffer *ctrl_buf = &adapter->ip_offload_ctrl;\n\tstruct ibmvnic_query_ip_offload_buffer *buf = &adapter->ip_offload_buf;\n\tstruct device *dev = &adapter->vdev->dev;\n\tnetdev_features_t old_hw_features = 0;\n\tunion ibmvnic_crq crq;\n\n\tadapter->ip_offload_ctrl_tok =\n\t\tdma_map_single(dev,\n\t\t\t       ctrl_buf,\n\t\t\t       sizeof(adapter->ip_offload_ctrl),\n\t\t\t       DMA_TO_DEVICE);\n\n\tif (dma_mapping_error(dev, adapter->ip_offload_ctrl_tok)) {\n\t\tdev_err(dev, \"Couldn't map ip offload control buffer\\n\");\n\t\treturn;\n\t}\n\n\tctrl_buf->len = cpu_to_be32(sizeof(adapter->ip_offload_ctrl));\n\tctrl_buf->version = cpu_to_be32(INITIAL_VERSION_IOB);\n\tctrl_buf->ipv4_chksum = buf->ipv4_chksum;\n\tctrl_buf->ipv6_chksum = buf->ipv6_chksum;\n\tctrl_buf->tcp_ipv4_chksum = buf->tcp_ipv4_chksum;\n\tctrl_buf->udp_ipv4_chksum = buf->udp_ipv4_chksum;\n\tctrl_buf->tcp_ipv6_chksum = buf->tcp_ipv6_chksum;\n\tctrl_buf->udp_ipv6_chksum = buf->udp_ipv6_chksum;\n\tctrl_buf->large_tx_ipv4 = buf->large_tx_ipv4;\n\tctrl_buf->large_tx_ipv6 = buf->large_tx_ipv6;\n\n\t \n\tctrl_buf->large_rx_ipv4 = 0;\n\tctrl_buf->large_rx_ipv6 = 0;\n\n\tif (adapter->state != VNIC_PROBING) {\n\t\told_hw_features = adapter->netdev->hw_features;\n\t\tadapter->netdev->hw_features = 0;\n\t}\n\n\tadapter->netdev->hw_features = NETIF_F_SG | NETIF_F_GSO | NETIF_F_GRO;\n\n\tif (buf->tcp_ipv4_chksum || buf->udp_ipv4_chksum)\n\t\tadapter->netdev->hw_features |= NETIF_F_IP_CSUM;\n\n\tif (buf->tcp_ipv6_chksum || buf->udp_ipv6_chksum)\n\t\tadapter->netdev->hw_features |= NETIF_F_IPV6_CSUM;\n\n\tif ((adapter->netdev->features &\n\t    (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM)))\n\t\tadapter->netdev->hw_features |= NETIF_F_RXCSUM;\n\n\tif (buf->large_tx_ipv4)\n\t\tadapter->netdev->hw_features |= NETIF_F_TSO;\n\tif (buf->large_tx_ipv6)\n\t\tadapter->netdev->hw_features |= NETIF_F_TSO6;\n\n\tif (adapter->state == VNIC_PROBING) {\n\t\tadapter->netdev->features |= adapter->netdev->hw_features;\n\t} else if (old_hw_features != adapter->netdev->hw_features) {\n\t\tnetdev_features_t tmp = 0;\n\n\t\t \n\t\tadapter->netdev->features &= adapter->netdev->hw_features;\n\t\t \n\t\ttmp = (old_hw_features ^ adapter->netdev->hw_features) &\n\t\t\tadapter->netdev->hw_features;\n\t\tadapter->netdev->features |=\n\t\t\t\ttmp & adapter->netdev->wanted_features;\n\t}\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.control_ip_offload.first = IBMVNIC_CRQ_CMD;\n\tcrq.control_ip_offload.cmd = CONTROL_IP_OFFLOAD;\n\tcrq.control_ip_offload.len =\n\t    cpu_to_be32(sizeof(adapter->ip_offload_ctrl));\n\tcrq.control_ip_offload.ioba = cpu_to_be32(adapter->ip_offload_ctrl_tok);\n\tibmvnic_send_crq(adapter, &crq);\n}\n\nstatic void handle_vpd_size_rsp(union ibmvnic_crq *crq,\n\t\t\t\tstruct ibmvnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\n\tif (crq->get_vpd_size_rsp.rc.code) {\n\t\tdev_err(dev, \"Error retrieving VPD size, rc=%x\\n\",\n\t\t\tcrq->get_vpd_size_rsp.rc.code);\n\t\tcomplete(&adapter->fw_done);\n\t\treturn;\n\t}\n\n\tadapter->vpd->len = be64_to_cpu(crq->get_vpd_size_rsp.len);\n\tcomplete(&adapter->fw_done);\n}\n\nstatic void handle_vpd_rsp(union ibmvnic_crq *crq,\n\t\t\t   struct ibmvnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tunsigned char *substr = NULL;\n\tu8 fw_level_len = 0;\n\n\tmemset(adapter->fw_version, 0, 32);\n\n\tdma_unmap_single(dev, adapter->vpd->dma_addr, adapter->vpd->len,\n\t\t\t DMA_FROM_DEVICE);\n\n\tif (crq->get_vpd_rsp.rc.code) {\n\t\tdev_err(dev, \"Error retrieving VPD from device, rc=%x\\n\",\n\t\t\tcrq->get_vpd_rsp.rc.code);\n\t\tgoto complete;\n\t}\n\n\t \n\tsubstr = strnstr(adapter->vpd->buff, \"RM\", adapter->vpd->len);\n\tif (!substr) {\n\t\tdev_info(dev, \"Warning - No FW level has been provided in the VPD buffer by the VIOS Server\\n\");\n\t\tgoto complete;\n\t}\n\n\t \n\tif ((substr + 2) < (adapter->vpd->buff + adapter->vpd->len)) {\n\t\tfw_level_len = *(substr + 2);\n\t} else {\n\t\tdev_info(dev, \"Length of FW substr extrapolated VDP buff\\n\");\n\t\tgoto complete;\n\t}\n\n\t \n\tif ((substr + 3 + fw_level_len) <\n\t    (adapter->vpd->buff + adapter->vpd->len)) {\n\t\tstrncpy((char *)adapter->fw_version, substr + 3, fw_level_len);\n\t} else {\n\t\tdev_info(dev, \"FW substr extrapolated VPD buff\\n\");\n\t}\n\ncomplete:\n\tif (adapter->fw_version[0] == '\\0')\n\t\tstrscpy((char *)adapter->fw_version, \"N/A\", sizeof(adapter->fw_version));\n\tcomplete(&adapter->fw_done);\n}\n\nstatic void handle_query_ip_offload_rsp(struct ibmvnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tstruct ibmvnic_query_ip_offload_buffer *buf = &adapter->ip_offload_buf;\n\tint i;\n\n\tdma_unmap_single(dev, adapter->ip_offload_tok,\n\t\t\t sizeof(adapter->ip_offload_buf), DMA_FROM_DEVICE);\n\n\tnetdev_dbg(adapter->netdev, \"Query IP Offload Buffer:\\n\");\n\tfor (i = 0; i < (sizeof(adapter->ip_offload_buf) - 1) / 8 + 1; i++)\n\t\tnetdev_dbg(adapter->netdev, \"%016lx\\n\",\n\t\t\t   ((unsigned long *)(buf))[i]);\n\n\tnetdev_dbg(adapter->netdev, \"ipv4_chksum = %d\\n\", buf->ipv4_chksum);\n\tnetdev_dbg(adapter->netdev, \"ipv6_chksum = %d\\n\", buf->ipv6_chksum);\n\tnetdev_dbg(adapter->netdev, \"tcp_ipv4_chksum = %d\\n\",\n\t\t   buf->tcp_ipv4_chksum);\n\tnetdev_dbg(adapter->netdev, \"tcp_ipv6_chksum = %d\\n\",\n\t\t   buf->tcp_ipv6_chksum);\n\tnetdev_dbg(adapter->netdev, \"udp_ipv4_chksum = %d\\n\",\n\t\t   buf->udp_ipv4_chksum);\n\tnetdev_dbg(adapter->netdev, \"udp_ipv6_chksum = %d\\n\",\n\t\t   buf->udp_ipv6_chksum);\n\tnetdev_dbg(adapter->netdev, \"large_tx_ipv4 = %d\\n\",\n\t\t   buf->large_tx_ipv4);\n\tnetdev_dbg(adapter->netdev, \"large_tx_ipv6 = %d\\n\",\n\t\t   buf->large_tx_ipv6);\n\tnetdev_dbg(adapter->netdev, \"large_rx_ipv4 = %d\\n\",\n\t\t   buf->large_rx_ipv4);\n\tnetdev_dbg(adapter->netdev, \"large_rx_ipv6 = %d\\n\",\n\t\t   buf->large_rx_ipv6);\n\tnetdev_dbg(adapter->netdev, \"max_ipv4_hdr_sz = %d\\n\",\n\t\t   buf->max_ipv4_header_size);\n\tnetdev_dbg(adapter->netdev, \"max_ipv6_hdr_sz = %d\\n\",\n\t\t   buf->max_ipv6_header_size);\n\tnetdev_dbg(adapter->netdev, \"max_tcp_hdr_size = %d\\n\",\n\t\t   buf->max_tcp_header_size);\n\tnetdev_dbg(adapter->netdev, \"max_udp_hdr_size = %d\\n\",\n\t\t   buf->max_udp_header_size);\n\tnetdev_dbg(adapter->netdev, \"max_large_tx_size = %d\\n\",\n\t\t   buf->max_large_tx_size);\n\tnetdev_dbg(adapter->netdev, \"max_large_rx_size = %d\\n\",\n\t\t   buf->max_large_rx_size);\n\tnetdev_dbg(adapter->netdev, \"ipv6_ext_hdr = %d\\n\",\n\t\t   buf->ipv6_extension_header);\n\tnetdev_dbg(adapter->netdev, \"tcp_pseudosum_req = %d\\n\",\n\t\t   buf->tcp_pseudosum_req);\n\tnetdev_dbg(adapter->netdev, \"num_ipv6_ext_hd = %d\\n\",\n\t\t   buf->num_ipv6_ext_headers);\n\tnetdev_dbg(adapter->netdev, \"off_ipv6_ext_hd = %d\\n\",\n\t\t   buf->off_ipv6_ext_headers);\n\n\tsend_control_ip_offload(adapter);\n}\n\nstatic const char *ibmvnic_fw_err_cause(u16 cause)\n{\n\tswitch (cause) {\n\tcase ADAPTER_PROBLEM:\n\t\treturn \"adapter problem\";\n\tcase BUS_PROBLEM:\n\t\treturn \"bus problem\";\n\tcase FW_PROBLEM:\n\t\treturn \"firmware problem\";\n\tcase DD_PROBLEM:\n\t\treturn \"device driver problem\";\n\tcase EEH_RECOVERY:\n\t\treturn \"EEH recovery\";\n\tcase FW_UPDATED:\n\t\treturn \"firmware updated\";\n\tcase LOW_MEMORY:\n\t\treturn \"low Memory\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic void handle_error_indication(union ibmvnic_crq *crq,\n\t\t\t\t    struct ibmvnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tu16 cause;\n\n\tcause = be16_to_cpu(crq->error_indication.error_cause);\n\n\tdev_warn_ratelimited(dev,\n\t\t\t     \"Firmware reports %serror, cause: %s. Starting recovery...\\n\",\n\t\t\t     crq->error_indication.flags\n\t\t\t\t& IBMVNIC_FATAL_ERROR ? \"FATAL \" : \"\",\n\t\t\t     ibmvnic_fw_err_cause(cause));\n\n\tif (crq->error_indication.flags & IBMVNIC_FATAL_ERROR)\n\t\tibmvnic_reset(adapter, VNIC_RESET_FATAL);\n\telse\n\t\tibmvnic_reset(adapter, VNIC_RESET_NON_FATAL);\n}\n\nstatic int handle_change_mac_rsp(union ibmvnic_crq *crq,\n\t\t\t\t struct ibmvnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct device *dev = &adapter->vdev->dev;\n\tlong rc;\n\n\trc = crq->change_mac_addr_rsp.rc.code;\n\tif (rc) {\n\t\tdev_err(dev, \"Error %ld in CHANGE_MAC_ADDR_RSP\\n\", rc);\n\t\tgoto out;\n\t}\n\t \n\teth_hw_addr_set(netdev, &crq->change_mac_addr_rsp.mac_addr[0]);\n\tether_addr_copy(adapter->mac_addr,\n\t\t\t&crq->change_mac_addr_rsp.mac_addr[0]);\nout:\n\tcomplete(&adapter->fw_done);\n\treturn rc;\n}\n\nstatic void handle_request_cap_rsp(union ibmvnic_crq *crq,\n\t\t\t\t   struct ibmvnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tu64 *req_value;\n\tchar *name;\n\n\tatomic_dec(&adapter->running_cap_crqs);\n\tnetdev_dbg(adapter->netdev, \"Outstanding request-caps: %d\\n\",\n\t\t   atomic_read(&adapter->running_cap_crqs));\n\tswitch (be16_to_cpu(crq->request_capability_rsp.capability)) {\n\tcase REQ_TX_QUEUES:\n\t\treq_value = &adapter->req_tx_queues;\n\t\tname = \"tx\";\n\t\tbreak;\n\tcase REQ_RX_QUEUES:\n\t\treq_value = &adapter->req_rx_queues;\n\t\tname = \"rx\";\n\t\tbreak;\n\tcase REQ_RX_ADD_QUEUES:\n\t\treq_value = &adapter->req_rx_add_queues;\n\t\tname = \"rx_add\";\n\t\tbreak;\n\tcase REQ_TX_ENTRIES_PER_SUBCRQ:\n\t\treq_value = &adapter->req_tx_entries_per_subcrq;\n\t\tname = \"tx_entries_per_subcrq\";\n\t\tbreak;\n\tcase REQ_RX_ADD_ENTRIES_PER_SUBCRQ:\n\t\treq_value = &adapter->req_rx_add_entries_per_subcrq;\n\t\tname = \"rx_add_entries_per_subcrq\";\n\t\tbreak;\n\tcase REQ_MTU:\n\t\treq_value = &adapter->req_mtu;\n\t\tname = \"mtu\";\n\t\tbreak;\n\tcase PROMISC_REQUESTED:\n\t\treq_value = &adapter->promisc;\n\t\tname = \"promisc\";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Got invalid cap request rsp %d\\n\",\n\t\t\tcrq->request_capability.capability);\n\t\treturn;\n\t}\n\n\tswitch (crq->request_capability_rsp.rc.code) {\n\tcase SUCCESS:\n\t\tbreak;\n\tcase PARTIALSUCCESS:\n\t\tdev_info(dev, \"req=%lld, rsp=%ld in %s queue, retrying.\\n\",\n\t\t\t *req_value,\n\t\t\t (long)be64_to_cpu(crq->request_capability_rsp.number),\n\t\t\t name);\n\n\t\tif (be16_to_cpu(crq->request_capability_rsp.capability) ==\n\t\t    REQ_MTU) {\n\t\t\tpr_err(\"mtu of %llu is not supported. Reverting.\\n\",\n\t\t\t       *req_value);\n\t\t\t*req_value = adapter->fallback.mtu;\n\t\t} else {\n\t\t\t*req_value =\n\t\t\t\tbe64_to_cpu(crq->request_capability_rsp.number);\n\t\t}\n\n\t\tsend_request_cap(adapter, 1);\n\t\treturn;\n\tdefault:\n\t\tdev_err(dev, \"Error %d in request cap rsp\\n\",\n\t\t\tcrq->request_capability_rsp.rc.code);\n\t\treturn;\n\t}\n\n\t \n\tif (atomic_read(&adapter->running_cap_crqs) == 0)\n\t\tsend_query_ip_offload(adapter);\n}\n\nstatic int handle_login_rsp(union ibmvnic_crq *login_rsp_crq,\n\t\t\t    struct ibmvnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct ibmvnic_login_rsp_buffer *login_rsp = adapter->login_rsp_buf;\n\tstruct ibmvnic_login_buffer *login = adapter->login_buf;\n\tu64 *tx_handle_array;\n\tu64 *rx_handle_array;\n\tint num_tx_pools;\n\tint num_rx_pools;\n\tu64 *size_array;\n\tu32 rsp_len;\n\tint i;\n\n\t \n\tif (!adapter->login_pending) {\n\t\tnetdev_warn(netdev, \"Ignoring unexpected login response\\n\");\n\t\treturn 0;\n\t}\n\tadapter->login_pending = false;\n\n\t \n\tif (login_rsp_crq->generic.rc.code) {\n\t\tadapter->init_done_rc = login_rsp_crq->generic.rc.code;\n\t\tcomplete(&adapter->init_done);\n\t\treturn 0;\n\t}\n\n\tif (adapter->failover_pending) {\n\t\tadapter->init_done_rc = -EAGAIN;\n\t\tnetdev_dbg(netdev, \"Failover pending, ignoring login response\\n\");\n\t\tcomplete(&adapter->init_done);\n\t\t \n\t\treturn 0;\n\t}\n\n\tnetdev->mtu = adapter->req_mtu - ETH_HLEN;\n\n\tnetdev_dbg(adapter->netdev, \"Login Response Buffer:\\n\");\n\tfor (i = 0; i < (adapter->login_rsp_buf_sz - 1) / 8 + 1; i++) {\n\t\tnetdev_dbg(adapter->netdev, \"%016lx\\n\",\n\t\t\t   ((unsigned long *)(adapter->login_rsp_buf))[i]);\n\t}\n\n\t \n\tif (login->num_txcomp_subcrqs != login_rsp->num_txsubm_subcrqs ||\n\t    (be32_to_cpu(login->num_rxcomp_subcrqs) *\n\t     adapter->req_rx_add_queues !=\n\t     be32_to_cpu(login_rsp->num_rxadd_subcrqs))) {\n\t\tdev_err(dev, \"FATAL: Inconsistent login and login rsp\\n\");\n\t\tibmvnic_reset(adapter, VNIC_RESET_FATAL);\n\t\treturn -EIO;\n\t}\n\n\trsp_len = be32_to_cpu(login_rsp->len);\n\tif (be32_to_cpu(login->login_rsp_len) < rsp_len ||\n\t    rsp_len <= be32_to_cpu(login_rsp->off_txsubm_subcrqs) ||\n\t    rsp_len <= be32_to_cpu(login_rsp->off_rxadd_subcrqs) ||\n\t    rsp_len <= be32_to_cpu(login_rsp->off_rxadd_buff_size) ||\n\t    rsp_len <= be32_to_cpu(login_rsp->off_supp_tx_desc)) {\n\t\t \n\t\tdev_err(dev, \"FATAL: Login rsp offsets/lengths invalid\\n\");\n\t\tibmvnic_reset(adapter, VNIC_RESET_FATAL);\n\t\treturn -EIO;\n\t}\n\n\tsize_array = (u64 *)((u8 *)(adapter->login_rsp_buf) +\n\t\tbe32_to_cpu(adapter->login_rsp_buf->off_rxadd_buff_size));\n\t \n\tadapter->cur_rx_buf_sz = be64_to_cpu(size_array[0]);\n\n\tnum_tx_pools = be32_to_cpu(adapter->login_rsp_buf->num_txsubm_subcrqs);\n\tnum_rx_pools = be32_to_cpu(adapter->login_rsp_buf->num_rxadd_subcrqs);\n\n\ttx_handle_array = (u64 *)((u8 *)(adapter->login_rsp_buf) +\n\t\t\t\t  be32_to_cpu(adapter->login_rsp_buf->off_txsubm_subcrqs));\n\trx_handle_array = (u64 *)((u8 *)(adapter->login_rsp_buf) +\n\t\t\t\t  be32_to_cpu(adapter->login_rsp_buf->off_rxadd_subcrqs));\n\n\tfor (i = 0; i < num_tx_pools; i++)\n\t\tadapter->tx_scrq[i]->handle = tx_handle_array[i];\n\n\tfor (i = 0; i < num_rx_pools; i++)\n\t\tadapter->rx_scrq[i]->handle = rx_handle_array[i];\n\n\tadapter->num_active_tx_scrqs = num_tx_pools;\n\tadapter->num_active_rx_scrqs = num_rx_pools;\n\trelease_login_rsp_buffer(adapter);\n\trelease_login_buffer(adapter);\n\tcomplete(&adapter->init_done);\n\n\treturn 0;\n}\n\nstatic void handle_request_unmap_rsp(union ibmvnic_crq *crq,\n\t\t\t\t     struct ibmvnic_adapter *adapter)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tlong rc;\n\n\trc = crq->request_unmap_rsp.rc.code;\n\tif (rc)\n\t\tdev_err(dev, \"Error %ld in REQUEST_UNMAP_RSP\\n\", rc);\n}\n\nstatic void handle_query_map_rsp(union ibmvnic_crq *crq,\n\t\t\t\t struct ibmvnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct device *dev = &adapter->vdev->dev;\n\tlong rc;\n\n\trc = crq->query_map_rsp.rc.code;\n\tif (rc) {\n\t\tdev_err(dev, \"Error %ld in QUERY_MAP_RSP\\n\", rc);\n\t\treturn;\n\t}\n\tnetdev_dbg(netdev, \"page_size = %d\\ntot_pages = %u\\nfree_pages = %u\\n\",\n\t\t   crq->query_map_rsp.page_size,\n\t\t   __be32_to_cpu(crq->query_map_rsp.tot_pages),\n\t\t   __be32_to_cpu(crq->query_map_rsp.free_pages));\n}\n\nstatic void handle_query_cap_rsp(union ibmvnic_crq *crq,\n\t\t\t\t struct ibmvnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct device *dev = &adapter->vdev->dev;\n\tlong rc;\n\n\tatomic_dec(&adapter->running_cap_crqs);\n\tnetdev_dbg(netdev, \"Outstanding queries: %d\\n\",\n\t\t   atomic_read(&adapter->running_cap_crqs));\n\trc = crq->query_capability.rc.code;\n\tif (rc) {\n\t\tdev_err(dev, \"Error %ld in QUERY_CAP_RSP\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tswitch (be16_to_cpu(crq->query_capability.capability)) {\n\tcase MIN_TX_QUEUES:\n\t\tadapter->min_tx_queues =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"min_tx_queues = %lld\\n\",\n\t\t\t   adapter->min_tx_queues);\n\t\tbreak;\n\tcase MIN_RX_QUEUES:\n\t\tadapter->min_rx_queues =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"min_rx_queues = %lld\\n\",\n\t\t\t   adapter->min_rx_queues);\n\t\tbreak;\n\tcase MIN_RX_ADD_QUEUES:\n\t\tadapter->min_rx_add_queues =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"min_rx_add_queues = %lld\\n\",\n\t\t\t   adapter->min_rx_add_queues);\n\t\tbreak;\n\tcase MAX_TX_QUEUES:\n\t\tadapter->max_tx_queues =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"max_tx_queues = %lld\\n\",\n\t\t\t   adapter->max_tx_queues);\n\t\tbreak;\n\tcase MAX_RX_QUEUES:\n\t\tadapter->max_rx_queues =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"max_rx_queues = %lld\\n\",\n\t\t\t   adapter->max_rx_queues);\n\t\tbreak;\n\tcase MAX_RX_ADD_QUEUES:\n\t\tadapter->max_rx_add_queues =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"max_rx_add_queues = %lld\\n\",\n\t\t\t   adapter->max_rx_add_queues);\n\t\tbreak;\n\tcase MIN_TX_ENTRIES_PER_SUBCRQ:\n\t\tadapter->min_tx_entries_per_subcrq =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"min_tx_entries_per_subcrq = %lld\\n\",\n\t\t\t   adapter->min_tx_entries_per_subcrq);\n\t\tbreak;\n\tcase MIN_RX_ADD_ENTRIES_PER_SUBCRQ:\n\t\tadapter->min_rx_add_entries_per_subcrq =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"min_rx_add_entrs_per_subcrq = %lld\\n\",\n\t\t\t   adapter->min_rx_add_entries_per_subcrq);\n\t\tbreak;\n\tcase MAX_TX_ENTRIES_PER_SUBCRQ:\n\t\tadapter->max_tx_entries_per_subcrq =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"max_tx_entries_per_subcrq = %lld\\n\",\n\t\t\t   adapter->max_tx_entries_per_subcrq);\n\t\tbreak;\n\tcase MAX_RX_ADD_ENTRIES_PER_SUBCRQ:\n\t\tadapter->max_rx_add_entries_per_subcrq =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"max_rx_add_entrs_per_subcrq = %lld\\n\",\n\t\t\t   adapter->max_rx_add_entries_per_subcrq);\n\t\tbreak;\n\tcase TCP_IP_OFFLOAD:\n\t\tadapter->tcp_ip_offload =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"tcp_ip_offload = %lld\\n\",\n\t\t\t   adapter->tcp_ip_offload);\n\t\tbreak;\n\tcase PROMISC_SUPPORTED:\n\t\tadapter->promisc_supported =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"promisc_supported = %lld\\n\",\n\t\t\t   adapter->promisc_supported);\n\t\tbreak;\n\tcase MIN_MTU:\n\t\tadapter->min_mtu = be64_to_cpu(crq->query_capability.number);\n\t\tnetdev->min_mtu = adapter->min_mtu - ETH_HLEN;\n\t\tnetdev_dbg(netdev, \"min_mtu = %lld\\n\", adapter->min_mtu);\n\t\tbreak;\n\tcase MAX_MTU:\n\t\tadapter->max_mtu = be64_to_cpu(crq->query_capability.number);\n\t\tnetdev->max_mtu = adapter->max_mtu - ETH_HLEN;\n\t\tnetdev_dbg(netdev, \"max_mtu = %lld\\n\", adapter->max_mtu);\n\t\tbreak;\n\tcase MAX_MULTICAST_FILTERS:\n\t\tadapter->max_multicast_filters =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"max_multicast_filters = %lld\\n\",\n\t\t\t   adapter->max_multicast_filters);\n\t\tbreak;\n\tcase VLAN_HEADER_INSERTION:\n\t\tadapter->vlan_header_insertion =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tif (adapter->vlan_header_insertion)\n\t\t\tnetdev->features |= NETIF_F_HW_VLAN_STAG_TX;\n\t\tnetdev_dbg(netdev, \"vlan_header_insertion = %lld\\n\",\n\t\t\t   adapter->vlan_header_insertion);\n\t\tbreak;\n\tcase RX_VLAN_HEADER_INSERTION:\n\t\tadapter->rx_vlan_header_insertion =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"rx_vlan_header_insertion = %lld\\n\",\n\t\t\t   adapter->rx_vlan_header_insertion);\n\t\tbreak;\n\tcase MAX_TX_SG_ENTRIES:\n\t\tadapter->max_tx_sg_entries =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"max_tx_sg_entries = %lld\\n\",\n\t\t\t   adapter->max_tx_sg_entries);\n\t\tbreak;\n\tcase RX_SG_SUPPORTED:\n\t\tadapter->rx_sg_supported =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"rx_sg_supported = %lld\\n\",\n\t\t\t   adapter->rx_sg_supported);\n\t\tbreak;\n\tcase OPT_TX_COMP_SUB_QUEUES:\n\t\tadapter->opt_tx_comp_sub_queues =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"opt_tx_comp_sub_queues = %lld\\n\",\n\t\t\t   adapter->opt_tx_comp_sub_queues);\n\t\tbreak;\n\tcase OPT_RX_COMP_QUEUES:\n\t\tadapter->opt_rx_comp_queues =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"opt_rx_comp_queues = %lld\\n\",\n\t\t\t   adapter->opt_rx_comp_queues);\n\t\tbreak;\n\tcase OPT_RX_BUFADD_Q_PER_RX_COMP_Q:\n\t\tadapter->opt_rx_bufadd_q_per_rx_comp_q =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"opt_rx_bufadd_q_per_rx_comp_q = %lld\\n\",\n\t\t\t   adapter->opt_rx_bufadd_q_per_rx_comp_q);\n\t\tbreak;\n\tcase OPT_TX_ENTRIES_PER_SUBCRQ:\n\t\tadapter->opt_tx_entries_per_subcrq =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"opt_tx_entries_per_subcrq = %lld\\n\",\n\t\t\t   adapter->opt_tx_entries_per_subcrq);\n\t\tbreak;\n\tcase OPT_RXBA_ENTRIES_PER_SUBCRQ:\n\t\tadapter->opt_rxba_entries_per_subcrq =\n\t\t    be64_to_cpu(crq->query_capability.number);\n\t\tnetdev_dbg(netdev, \"opt_rxba_entries_per_subcrq = %lld\\n\",\n\t\t\t   adapter->opt_rxba_entries_per_subcrq);\n\t\tbreak;\n\tcase TX_RX_DESC_REQ:\n\t\tadapter->tx_rx_desc_req = crq->query_capability.number;\n\t\tnetdev_dbg(netdev, \"tx_rx_desc_req = %llx\\n\",\n\t\t\t   adapter->tx_rx_desc_req);\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_err(netdev, \"Got invalid cap rsp %d\\n\",\n\t\t\t   crq->query_capability.capability);\n\t}\n\nout:\n\tif (atomic_read(&adapter->running_cap_crqs) == 0)\n\t\tsend_request_cap(adapter, 0);\n}\n\nstatic int send_query_phys_parms(struct ibmvnic_adapter *adapter)\n{\n\tunion ibmvnic_crq crq;\n\tint rc;\n\n\tmemset(&crq, 0, sizeof(crq));\n\tcrq.query_phys_parms.first = IBMVNIC_CRQ_CMD;\n\tcrq.query_phys_parms.cmd = QUERY_PHYS_PARMS;\n\n\tmutex_lock(&adapter->fw_lock);\n\tadapter->fw_done_rc = 0;\n\treinit_completion(&adapter->fw_done);\n\n\trc = ibmvnic_send_crq(adapter, &crq);\n\tif (rc) {\n\t\tmutex_unlock(&adapter->fw_lock);\n\t\treturn rc;\n\t}\n\n\trc = ibmvnic_wait_for_completion(adapter, &adapter->fw_done, 10000);\n\tif (rc) {\n\t\tmutex_unlock(&adapter->fw_lock);\n\t\treturn rc;\n\t}\n\n\tmutex_unlock(&adapter->fw_lock);\n\treturn adapter->fw_done_rc ? -EIO : 0;\n}\n\nstatic int handle_query_phys_parms_rsp(union ibmvnic_crq *crq,\n\t\t\t\t       struct ibmvnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint rc;\n\t__be32 rspeed = cpu_to_be32(crq->query_phys_parms_rsp.speed);\n\n\trc = crq->query_phys_parms_rsp.rc.code;\n\tif (rc) {\n\t\tnetdev_err(netdev, \"Error %d in QUERY_PHYS_PARMS\\n\", rc);\n\t\treturn rc;\n\t}\n\tswitch (rspeed) {\n\tcase IBMVNIC_10MBPS:\n\t\tadapter->speed = SPEED_10;\n\t\tbreak;\n\tcase IBMVNIC_100MBPS:\n\t\tadapter->speed = SPEED_100;\n\t\tbreak;\n\tcase IBMVNIC_1GBPS:\n\t\tadapter->speed = SPEED_1000;\n\t\tbreak;\n\tcase IBMVNIC_10GBPS:\n\t\tadapter->speed = SPEED_10000;\n\t\tbreak;\n\tcase IBMVNIC_25GBPS:\n\t\tadapter->speed = SPEED_25000;\n\t\tbreak;\n\tcase IBMVNIC_40GBPS:\n\t\tadapter->speed = SPEED_40000;\n\t\tbreak;\n\tcase IBMVNIC_50GBPS:\n\t\tadapter->speed = SPEED_50000;\n\t\tbreak;\n\tcase IBMVNIC_100GBPS:\n\t\tadapter->speed = SPEED_100000;\n\t\tbreak;\n\tcase IBMVNIC_200GBPS:\n\t\tadapter->speed = SPEED_200000;\n\t\tbreak;\n\tdefault:\n\t\tif (netif_carrier_ok(netdev))\n\t\t\tnetdev_warn(netdev, \"Unknown speed 0x%08x\\n\", rspeed);\n\t\tadapter->speed = SPEED_UNKNOWN;\n\t}\n\tif (crq->query_phys_parms_rsp.flags1 & IBMVNIC_FULL_DUPLEX)\n\t\tadapter->duplex = DUPLEX_FULL;\n\telse if (crq->query_phys_parms_rsp.flags1 & IBMVNIC_HALF_DUPLEX)\n\t\tadapter->duplex = DUPLEX_HALF;\n\telse\n\t\tadapter->duplex = DUPLEX_UNKNOWN;\n\n\treturn rc;\n}\n\nstatic void ibmvnic_handle_crq(union ibmvnic_crq *crq,\n\t\t\t       struct ibmvnic_adapter *adapter)\n{\n\tstruct ibmvnic_generic_crq *gen_crq = &crq->generic;\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct device *dev = &adapter->vdev->dev;\n\tu64 *u64_crq = (u64 *)crq;\n\tlong rc;\n\n\tnetdev_dbg(netdev, \"Handling CRQ: %016lx %016lx\\n\",\n\t\t   (unsigned long)cpu_to_be64(u64_crq[0]),\n\t\t   (unsigned long)cpu_to_be64(u64_crq[1]));\n\tswitch (gen_crq->first) {\n\tcase IBMVNIC_CRQ_INIT_RSP:\n\t\tswitch (gen_crq->cmd) {\n\t\tcase IBMVNIC_CRQ_INIT:\n\t\t\tdev_info(dev, \"Partner initialized\\n\");\n\t\t\tadapter->from_passive_init = true;\n\t\t\t \n\t\t\tadapter->login_pending = false;\n\n\t\t\tif (adapter->state == VNIC_DOWN)\n\t\t\t\trc = ibmvnic_reset(adapter, VNIC_RESET_PASSIVE_INIT);\n\t\t\telse\n\t\t\t\trc = ibmvnic_reset(adapter, VNIC_RESET_FAILOVER);\n\n\t\t\tif (rc && rc != -EBUSY) {\n\t\t\t\t \n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"Error %ld scheduling failover reset\\n\",\n\t\t\t\t\t   rc);\n\t\t\t\tadapter->failover_pending = false;\n\t\t\t}\n\n\t\t\tif (!completion_done(&adapter->init_done)) {\n\t\t\t\tif (!adapter->init_done_rc)\n\t\t\t\t\tadapter->init_done_rc = -EAGAIN;\n\t\t\t\tcomplete(&adapter->init_done);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase IBMVNIC_CRQ_INIT_COMPLETE:\n\t\t\tdev_info(dev, \"Partner initialization complete\\n\");\n\t\t\tadapter->crq.active = true;\n\t\t\tsend_version_xchg(adapter);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Unknown crq cmd: %d\\n\", gen_crq->cmd);\n\t\t}\n\t\treturn;\n\tcase IBMVNIC_CRQ_XPORT_EVENT:\n\t\tnetif_carrier_off(netdev);\n\t\tadapter->crq.active = false;\n\t\t \n\t\tif (!completion_done(&adapter->fw_done)) {\n\t\t\tadapter->fw_done_rc = -EIO;\n\t\t\tcomplete(&adapter->fw_done);\n\t\t}\n\n\t\t \n\t\tif (!completion_done(&adapter->init_done)) {\n\t\t\tadapter->init_done_rc = -EAGAIN;\n\t\t\tcomplete(&adapter->init_done);\n\t\t}\n\n\t\tif (!completion_done(&adapter->stats_done))\n\t\t\tcomplete(&adapter->stats_done);\n\t\tif (test_bit(0, &adapter->resetting))\n\t\t\tadapter->force_reset_recovery = true;\n\t\tif (gen_crq->cmd == IBMVNIC_PARTITION_MIGRATED) {\n\t\t\tdev_info(dev, \"Migrated, re-enabling adapter\\n\");\n\t\t\tibmvnic_reset(adapter, VNIC_RESET_MOBILITY);\n\t\t} else if (gen_crq->cmd == IBMVNIC_DEVICE_FAILOVER) {\n\t\t\tdev_info(dev, \"Backing device failover detected\\n\");\n\t\t\tadapter->failover_pending = true;\n\t\t} else {\n\t\t\t \n\t\t\tdev_err(dev, \"Virtual Adapter failed (rc=%d)\\n\",\n\t\t\t\tgen_crq->cmd);\n\t\t\tibmvnic_reset(adapter, VNIC_RESET_FATAL);\n\t\t}\n\t\treturn;\n\tcase IBMVNIC_CRQ_CMD_RSP:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Got an invalid msg type 0x%02x\\n\",\n\t\t\tgen_crq->first);\n\t\treturn;\n\t}\n\n\tswitch (gen_crq->cmd) {\n\tcase VERSION_EXCHANGE_RSP:\n\t\trc = crq->version_exchange_rsp.rc.code;\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Error %ld in VERSION_EXCHG_RSP\\n\", rc);\n\t\t\tbreak;\n\t\t}\n\t\tibmvnic_version =\n\t\t\t    be16_to_cpu(crq->version_exchange_rsp.version);\n\t\tdev_info(dev, \"Partner protocol version is %d\\n\",\n\t\t\t ibmvnic_version);\n\t\tsend_query_cap(adapter);\n\t\tbreak;\n\tcase QUERY_CAPABILITY_RSP:\n\t\thandle_query_cap_rsp(crq, adapter);\n\t\tbreak;\n\tcase QUERY_MAP_RSP:\n\t\thandle_query_map_rsp(crq, adapter);\n\t\tbreak;\n\tcase REQUEST_MAP_RSP:\n\t\tadapter->fw_done_rc = crq->request_map_rsp.rc.code;\n\t\tcomplete(&adapter->fw_done);\n\t\tbreak;\n\tcase REQUEST_UNMAP_RSP:\n\t\thandle_request_unmap_rsp(crq, adapter);\n\t\tbreak;\n\tcase REQUEST_CAPABILITY_RSP:\n\t\thandle_request_cap_rsp(crq, adapter);\n\t\tbreak;\n\tcase LOGIN_RSP:\n\t\tnetdev_dbg(netdev, \"Got Login Response\\n\");\n\t\thandle_login_rsp(crq, adapter);\n\t\tbreak;\n\tcase LOGICAL_LINK_STATE_RSP:\n\t\tnetdev_dbg(netdev,\n\t\t\t   \"Got Logical Link State Response, state: %d rc: %d\\n\",\n\t\t\t   crq->logical_link_state_rsp.link_state,\n\t\t\t   crq->logical_link_state_rsp.rc.code);\n\t\tadapter->logical_link_state =\n\t\t    crq->logical_link_state_rsp.link_state;\n\t\tadapter->init_done_rc = crq->logical_link_state_rsp.rc.code;\n\t\tcomplete(&adapter->init_done);\n\t\tbreak;\n\tcase LINK_STATE_INDICATION:\n\t\tnetdev_dbg(netdev, \"Got Logical Link State Indication\\n\");\n\t\tadapter->phys_link_state =\n\t\t    crq->link_state_indication.phys_link_state;\n\t\tadapter->logical_link_state =\n\t\t    crq->link_state_indication.logical_link_state;\n\t\tif (adapter->phys_link_state && adapter->logical_link_state)\n\t\t\tnetif_carrier_on(netdev);\n\t\telse\n\t\t\tnetif_carrier_off(netdev);\n\t\tbreak;\n\tcase CHANGE_MAC_ADDR_RSP:\n\t\tnetdev_dbg(netdev, \"Got MAC address change Response\\n\");\n\t\tadapter->fw_done_rc = handle_change_mac_rsp(crq, adapter);\n\t\tbreak;\n\tcase ERROR_INDICATION:\n\t\tnetdev_dbg(netdev, \"Got Error Indication\\n\");\n\t\thandle_error_indication(crq, adapter);\n\t\tbreak;\n\tcase REQUEST_STATISTICS_RSP:\n\t\tnetdev_dbg(netdev, \"Got Statistics Response\\n\");\n\t\tcomplete(&adapter->stats_done);\n\t\tbreak;\n\tcase QUERY_IP_OFFLOAD_RSP:\n\t\tnetdev_dbg(netdev, \"Got Query IP offload Response\\n\");\n\t\thandle_query_ip_offload_rsp(adapter);\n\t\tbreak;\n\tcase MULTICAST_CTRL_RSP:\n\t\tnetdev_dbg(netdev, \"Got multicast control Response\\n\");\n\t\tbreak;\n\tcase CONTROL_IP_OFFLOAD_RSP:\n\t\tnetdev_dbg(netdev, \"Got Control IP offload Response\\n\");\n\t\tdma_unmap_single(dev, adapter->ip_offload_ctrl_tok,\n\t\t\t\t sizeof(adapter->ip_offload_ctrl),\n\t\t\t\t DMA_TO_DEVICE);\n\t\tcomplete(&adapter->init_done);\n\t\tbreak;\n\tcase COLLECT_FW_TRACE_RSP:\n\t\tnetdev_dbg(netdev, \"Got Collect firmware trace Response\\n\");\n\t\tcomplete(&adapter->fw_done);\n\t\tbreak;\n\tcase GET_VPD_SIZE_RSP:\n\t\thandle_vpd_size_rsp(crq, adapter);\n\t\tbreak;\n\tcase GET_VPD_RSP:\n\t\thandle_vpd_rsp(crq, adapter);\n\t\tbreak;\n\tcase QUERY_PHYS_PARMS_RSP:\n\t\tadapter->fw_done_rc = handle_query_phys_parms_rsp(crq, adapter);\n\t\tcomplete(&adapter->fw_done);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(netdev, \"Got an invalid cmd type 0x%02x\\n\",\n\t\t\t   gen_crq->cmd);\n\t}\n}\n\nstatic irqreturn_t ibmvnic_interrupt(int irq, void *instance)\n{\n\tstruct ibmvnic_adapter *adapter = instance;\n\n\ttasklet_schedule(&adapter->tasklet);\n\treturn IRQ_HANDLED;\n}\n\nstatic void ibmvnic_tasklet(struct tasklet_struct *t)\n{\n\tstruct ibmvnic_adapter *adapter = from_tasklet(adapter, t, tasklet);\n\tstruct ibmvnic_crq_queue *queue = &adapter->crq;\n\tunion ibmvnic_crq *crq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue->lock, flags);\n\n\t \n\twhile ((crq = ibmvnic_next_crq(adapter)) != NULL) {\n\t\t \n\t\tdma_rmb();\n\t\tibmvnic_handle_crq(crq, adapter);\n\t\tcrq->generic.first = 0;\n\t}\n\n\tspin_unlock_irqrestore(&queue->lock, flags);\n}\n\nstatic int ibmvnic_reenable_crq_queue(struct ibmvnic_adapter *adapter)\n{\n\tstruct vio_dev *vdev = adapter->vdev;\n\tint rc;\n\n\tdo {\n\t\trc = plpar_hcall_norets(H_ENABLE_CRQ, vdev->unit_address);\n\t} while (rc == H_IN_PROGRESS || rc == H_BUSY || H_IS_LONG_BUSY(rc));\n\n\tif (rc)\n\t\tdev_err(&vdev->dev, \"Error enabling adapter (rc=%d)\\n\", rc);\n\n\treturn rc;\n}\n\nstatic int ibmvnic_reset_crq(struct ibmvnic_adapter *adapter)\n{\n\tstruct ibmvnic_crq_queue *crq = &adapter->crq;\n\tstruct device *dev = &adapter->vdev->dev;\n\tstruct vio_dev *vdev = adapter->vdev;\n\tint rc;\n\n\t \n\tdo {\n\t\trc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);\n\t} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\n\n\t \n\tif (!crq->msgs)\n\t\treturn -EINVAL;\n\n\tmemset(crq->msgs, 0, PAGE_SIZE);\n\tcrq->cur = 0;\n\tcrq->active = false;\n\n\t \n\trc = plpar_hcall_norets(H_REG_CRQ, vdev->unit_address,\n\t\t\t\tcrq->msg_token, PAGE_SIZE);\n\n\tif (rc == H_CLOSED)\n\t\t \n\t\tdev_warn(dev, \"Partner adapter not ready\\n\");\n\telse if (rc != 0)\n\t\tdev_warn(dev, \"Couldn't register crq (rc=%d)\\n\", rc);\n\n\treturn rc;\n}\n\nstatic void release_crq_queue(struct ibmvnic_adapter *adapter)\n{\n\tstruct ibmvnic_crq_queue *crq = &adapter->crq;\n\tstruct vio_dev *vdev = adapter->vdev;\n\tlong rc;\n\n\tif (!crq->msgs)\n\t\treturn;\n\n\tnetdev_dbg(adapter->netdev, \"Releasing CRQ\\n\");\n\tfree_irq(vdev->irq, adapter);\n\ttasklet_kill(&adapter->tasklet);\n\tdo {\n\t\trc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);\n\t} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\n\n\tdma_unmap_single(&vdev->dev, crq->msg_token, PAGE_SIZE,\n\t\t\t DMA_BIDIRECTIONAL);\n\tfree_page((unsigned long)crq->msgs);\n\tcrq->msgs = NULL;\n\tcrq->active = false;\n}\n\nstatic int init_crq_queue(struct ibmvnic_adapter *adapter)\n{\n\tstruct ibmvnic_crq_queue *crq = &adapter->crq;\n\tstruct device *dev = &adapter->vdev->dev;\n\tstruct vio_dev *vdev = adapter->vdev;\n\tint rc, retrc = -ENOMEM;\n\n\tif (crq->msgs)\n\t\treturn 0;\n\n\tcrq->msgs = (union ibmvnic_crq *)get_zeroed_page(GFP_KERNEL);\n\t \n\n\tif (!crq->msgs)\n\t\treturn -ENOMEM;\n\n\tcrq->size = PAGE_SIZE / sizeof(*crq->msgs);\n\tcrq->msg_token = dma_map_single(dev, crq->msgs, PAGE_SIZE,\n\t\t\t\t\tDMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(dev, crq->msg_token))\n\t\tgoto map_failed;\n\n\trc = plpar_hcall_norets(H_REG_CRQ, vdev->unit_address,\n\t\t\t\tcrq->msg_token, PAGE_SIZE);\n\n\tif (rc == H_RESOURCE)\n\t\t \n\t\trc = ibmvnic_reset_crq(adapter);\n\tretrc = rc;\n\n\tif (rc == H_CLOSED) {\n\t\tdev_warn(dev, \"Partner adapter not ready\\n\");\n\t} else if (rc) {\n\t\tdev_warn(dev, \"Error %d opening adapter\\n\", rc);\n\t\tgoto reg_crq_failed;\n\t}\n\n\tretrc = 0;\n\n\ttasklet_setup(&adapter->tasklet, (void *)ibmvnic_tasklet);\n\n\tnetdev_dbg(adapter->netdev, \"registering irq 0x%x\\n\", vdev->irq);\n\tsnprintf(crq->name, sizeof(crq->name), \"ibmvnic-%x\",\n\t\t adapter->vdev->unit_address);\n\trc = request_irq(vdev->irq, ibmvnic_interrupt, 0, crq->name, adapter);\n\tif (rc) {\n\t\tdev_err(dev, \"Couldn't register irq 0x%x. rc=%d\\n\",\n\t\t\tvdev->irq, rc);\n\t\tgoto req_irq_failed;\n\t}\n\n\trc = vio_enable_interrupts(vdev);\n\tif (rc) {\n\t\tdev_err(dev, \"Error %d enabling interrupts\\n\", rc);\n\t\tgoto req_irq_failed;\n\t}\n\n\tcrq->cur = 0;\n\tspin_lock_init(&crq->lock);\n\n\t \n\ttasklet_schedule(&adapter->tasklet);\n\n\treturn retrc;\n\nreq_irq_failed:\n\ttasklet_kill(&adapter->tasklet);\n\tdo {\n\t\trc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);\n\t} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\nreg_crq_failed:\n\tdma_unmap_single(dev, crq->msg_token, PAGE_SIZE, DMA_BIDIRECTIONAL);\nmap_failed:\n\tfree_page((unsigned long)crq->msgs);\n\tcrq->msgs = NULL;\n\treturn retrc;\n}\n\nstatic int ibmvnic_reset_init(struct ibmvnic_adapter *adapter, bool reset)\n{\n\tstruct device *dev = &adapter->vdev->dev;\n\tunsigned long timeout = msecs_to_jiffies(20000);\n\tu64 old_num_rx_queues = adapter->req_rx_queues;\n\tu64 old_num_tx_queues = adapter->req_tx_queues;\n\tint rc;\n\n\tadapter->from_passive_init = false;\n\n\trc = ibmvnic_send_crq_init(adapter);\n\tif (rc) {\n\t\tdev_err(dev, \"Send crq init failed with error %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (!wait_for_completion_timeout(&adapter->init_done, timeout)) {\n\t\tdev_err(dev, \"Initialization sequence timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (adapter->init_done_rc) {\n\t\trelease_crq_queue(adapter);\n\t\tdev_err(dev, \"CRQ-init failed, %d\\n\", adapter->init_done_rc);\n\t\treturn adapter->init_done_rc;\n\t}\n\n\tif (adapter->from_passive_init) {\n\t\tadapter->state = VNIC_OPEN;\n\t\tadapter->from_passive_init = false;\n\t\tdev_err(dev, \"CRQ-init failed, passive-init\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reset &&\n\t    test_bit(0, &adapter->resetting) && !adapter->wait_for_reset &&\n\t    adapter->reset_reason != VNIC_RESET_MOBILITY) {\n\t\tif (adapter->req_rx_queues != old_num_rx_queues ||\n\t\t    adapter->req_tx_queues != old_num_tx_queues) {\n\t\t\trelease_sub_crqs(adapter, 0);\n\t\t\trc = init_sub_crqs(adapter);\n\t\t} else {\n\t\t\t \n\t\t\tclean_tx_pools(adapter);\n\n\t\t\trc = reset_sub_crq_queues(adapter);\n\t\t}\n\t} else {\n\t\trc = init_sub_crqs(adapter);\n\t}\n\n\tif (rc) {\n\t\tdev_err(dev, \"Initialization of sub crqs failed\\n\");\n\t\trelease_crq_queue(adapter);\n\t\treturn rc;\n\t}\n\n\trc = init_sub_crq_irqs(adapter);\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to initialize sub crq irqs\\n\");\n\t\trelease_crq_queue(adapter);\n\t}\n\n\treturn rc;\n}\n\nstatic struct device_attribute dev_attr_failover;\n\nstatic int ibmvnic_probe(struct vio_dev *dev, const struct vio_device_id *id)\n{\n\tstruct ibmvnic_adapter *adapter;\n\tstruct net_device *netdev;\n\tunsigned char *mac_addr_p;\n\tunsigned long flags;\n\tbool init_success;\n\tint rc;\n\n\tdev_dbg(&dev->dev, \"entering ibmvnic_probe for UA 0x%x\\n\",\n\t\tdev->unit_address);\n\n\tmac_addr_p = (unsigned char *)vio_get_attribute(dev,\n\t\t\t\t\t\t\tVETH_MAC_ADDR, NULL);\n\tif (!mac_addr_p) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"(%s:%3.3d) ERROR: Can't find MAC_ADDR attribute\\n\",\n\t\t\t__FILE__, __LINE__);\n\t\treturn 0;\n\t}\n\n\tnetdev = alloc_etherdev_mq(sizeof(struct ibmvnic_adapter),\n\t\t\t\t   IBMVNIC_MAX_QUEUES);\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tadapter = netdev_priv(netdev);\n\tadapter->state = VNIC_PROBING;\n\tdev_set_drvdata(&dev->dev, netdev);\n\tadapter->vdev = dev;\n\tadapter->netdev = netdev;\n\tadapter->login_pending = false;\n\tmemset(&adapter->map_ids, 0, sizeof(adapter->map_ids));\n\t \n\tbitmap_set(adapter->map_ids, 0, 1);\n\n\tether_addr_copy(adapter->mac_addr, mac_addr_p);\n\teth_hw_addr_set(netdev, adapter->mac_addr);\n\tnetdev->irq = dev->irq;\n\tnetdev->netdev_ops = &ibmvnic_netdev_ops;\n\tnetdev->ethtool_ops = &ibmvnic_ethtool_ops;\n\tSET_NETDEV_DEV(netdev, &dev->dev);\n\n\tINIT_WORK(&adapter->ibmvnic_reset, __ibmvnic_reset);\n\tINIT_DELAYED_WORK(&adapter->ibmvnic_delayed_reset,\n\t\t\t  __ibmvnic_delayed_reset);\n\tINIT_LIST_HEAD(&adapter->rwi_list);\n\tspin_lock_init(&adapter->rwi_lock);\n\tspin_lock_init(&adapter->state_lock);\n\tmutex_init(&adapter->fw_lock);\n\tinit_completion(&adapter->probe_done);\n\tinit_completion(&adapter->init_done);\n\tinit_completion(&adapter->fw_done);\n\tinit_completion(&adapter->reset_done);\n\tinit_completion(&adapter->stats_done);\n\tclear_bit(0, &adapter->resetting);\n\tadapter->prev_rx_buf_sz = 0;\n\tadapter->prev_mtu = 0;\n\n\tinit_success = false;\n\tdo {\n\t\treinit_init_done(adapter);\n\n\t\t \n\t\tadapter->failover_pending = false;\n\n\t\t \n\t\trelease_crq_queue(adapter);\n\n\t\t \n\t\tspin_lock_irqsave(&adapter->rwi_lock, flags);\n\t\tflush_reset_queue(adapter);\n\t\tspin_unlock_irqrestore(&adapter->rwi_lock, flags);\n\n\t\trc = init_crq_queue(adapter);\n\t\tif (rc) {\n\t\t\tdev_err(&dev->dev, \"Couldn't initialize crq. rc=%d\\n\",\n\t\t\t\trc);\n\t\t\tgoto ibmvnic_init_fail;\n\t\t}\n\n\t\trc = ibmvnic_reset_init(adapter, false);\n\t} while (rc == -EAGAIN);\n\n\t \n\n\tif (!rc)\n\t\tinit_success = true;\n\n\trc = init_stats_buffers(adapter);\n\tif (rc)\n\t\tgoto ibmvnic_init_fail;\n\n\trc = init_stats_token(adapter);\n\tif (rc)\n\t\tgoto ibmvnic_stats_fail;\n\n\trc = device_create_file(&dev->dev, &dev_attr_failover);\n\tif (rc)\n\t\tgoto ibmvnic_dev_file_err;\n\n\tnetif_carrier_off(netdev);\n\n\tif (init_success) {\n\t\tadapter->state = VNIC_PROBED;\n\t\tnetdev->mtu = adapter->req_mtu - ETH_HLEN;\n\t\tnetdev->min_mtu = adapter->min_mtu - ETH_HLEN;\n\t\tnetdev->max_mtu = adapter->max_mtu - ETH_HLEN;\n\t} else {\n\t\tadapter->state = VNIC_DOWN;\n\t}\n\n\tadapter->wait_for_reset = false;\n\tadapter->last_reset_time = jiffies;\n\n\trc = register_netdev(netdev);\n\tif (rc) {\n\t\tdev_err(&dev->dev, \"failed to register netdev rc=%d\\n\", rc);\n\t\tgoto ibmvnic_register_fail;\n\t}\n\tdev_info(&dev->dev, \"ibmvnic registered\\n\");\n\n\trc = ibmvnic_cpu_notif_add(adapter);\n\tif (rc) {\n\t\tnetdev_err(netdev, \"Registering cpu notifier failed\\n\");\n\t\tgoto cpu_notif_add_failed;\n\t}\n\n\tcomplete(&adapter->probe_done);\n\n\treturn 0;\n\ncpu_notif_add_failed:\n\tunregister_netdev(netdev);\n\nibmvnic_register_fail:\n\tdevice_remove_file(&dev->dev, &dev_attr_failover);\n\nibmvnic_dev_file_err:\n\trelease_stats_token(adapter);\n\nibmvnic_stats_fail:\n\trelease_stats_buffers(adapter);\n\nibmvnic_init_fail:\n\trelease_sub_crqs(adapter, 1);\n\trelease_crq_queue(adapter);\n\n\t \n\tadapter->state = VNIC_REMOVING;\n\tcomplete(&adapter->probe_done);\n\tflush_work(&adapter->ibmvnic_reset);\n\tflush_delayed_work(&adapter->ibmvnic_delayed_reset);\n\n\tflush_reset_queue(adapter);\n\n\tmutex_destroy(&adapter->fw_lock);\n\tfree_netdev(netdev);\n\n\treturn rc;\n}\n\nstatic void ibmvnic_remove(struct vio_dev *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(&dev->dev);\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->state_lock, flags);\n\n\t \n\tspin_lock(&adapter->rwi_lock);\n\tadapter->state = VNIC_REMOVING;\n\tspin_unlock(&adapter->rwi_lock);\n\n\tspin_unlock_irqrestore(&adapter->state_lock, flags);\n\n\tibmvnic_cpu_notif_remove(adapter);\n\n\tflush_work(&adapter->ibmvnic_reset);\n\tflush_delayed_work(&adapter->ibmvnic_delayed_reset);\n\n\trtnl_lock();\n\tunregister_netdevice(netdev);\n\n\trelease_resources(adapter);\n\trelease_rx_pools(adapter);\n\trelease_tx_pools(adapter);\n\trelease_sub_crqs(adapter, 1);\n\trelease_crq_queue(adapter);\n\n\trelease_stats_token(adapter);\n\trelease_stats_buffers(adapter);\n\n\tadapter->state = VNIC_REMOVED;\n\n\trtnl_unlock();\n\tmutex_destroy(&adapter->fw_lock);\n\tdevice_remove_file(&dev->dev, &dev_attr_failover);\n\tfree_netdev(netdev);\n\tdev_set_drvdata(&dev->dev, NULL);\n}\n\nstatic ssize_t failover_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\tunsigned long retbuf[PLPAR_HCALL_BUFSIZE];\n\t__be64 session_token;\n\tlong rc;\n\n\tif (!sysfs_streq(buf, \"1\"))\n\t\treturn -EINVAL;\n\n\trc = plpar_hcall(H_VIOCTL, retbuf, adapter->vdev->unit_address,\n\t\t\t H_GET_SESSION_TOKEN, 0, 0, 0);\n\tif (rc) {\n\t\tnetdev_err(netdev, \"Couldn't retrieve session token, rc %ld\\n\",\n\t\t\t   rc);\n\t\tgoto last_resort;\n\t}\n\n\tsession_token = (__be64)retbuf[0];\n\tnetdev_dbg(netdev, \"Initiating client failover, session id %llx\\n\",\n\t\t   be64_to_cpu(session_token));\n\trc = plpar_hcall_norets(H_VIOCTL, adapter->vdev->unit_address,\n\t\t\t\tH_SESSION_ERR_DETECTED, session_token, 0, 0);\n\tif (rc) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"H_VIOCTL initiated failover failed, rc %ld\\n\",\n\t\t\t   rc);\n\t\tgoto last_resort;\n\t}\n\n\treturn count;\n\nlast_resort:\n\tnetdev_dbg(netdev, \"Trying to send CRQ_CMD, the last resort\\n\");\n\tibmvnic_reset(adapter, VNIC_RESET_FAILOVER);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(failover);\n\nstatic unsigned long ibmvnic_get_desired_dma(struct vio_dev *vdev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(&vdev->dev);\n\tstruct ibmvnic_adapter *adapter;\n\tstruct iommu_table *tbl;\n\tunsigned long ret = 0;\n\tint i;\n\n\ttbl = get_iommu_table_base(&vdev->dev);\n\n\t \n\tif (!netdev)\n\t\treturn IOMMU_PAGE_ALIGN(IBMVNIC_IO_ENTITLEMENT_DEFAULT, tbl);\n\n\tadapter = netdev_priv(netdev);\n\n\tret += PAGE_SIZE;  \n\tret += IOMMU_PAGE_ALIGN(sizeof(struct ibmvnic_statistics), tbl);\n\n\tfor (i = 0; i < adapter->req_tx_queues + adapter->req_rx_queues; i++)\n\t\tret += 4 * PAGE_SIZE;  \n\n\tfor (i = 0; i < adapter->num_active_rx_pools; i++)\n\t\tret += adapter->rx_pool[i].size *\n\t\t    IOMMU_PAGE_ALIGN(adapter->rx_pool[i].buff_size, tbl);\n\n\treturn ret;\n}\n\nstatic int ibmvnic_resume(struct device *dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(dev);\n\tstruct ibmvnic_adapter *adapter = netdev_priv(netdev);\n\n\tif (adapter->state != VNIC_OPEN)\n\t\treturn 0;\n\n\ttasklet_schedule(&adapter->tasklet);\n\n\treturn 0;\n}\n\nstatic const struct vio_device_id ibmvnic_device_table[] = {\n\t{\"network\", \"IBM,vnic\"},\n\t{\"\", \"\" }\n};\nMODULE_DEVICE_TABLE(vio, ibmvnic_device_table);\n\nstatic const struct dev_pm_ops ibmvnic_pm_ops = {\n\t.resume = ibmvnic_resume\n};\n\nstatic struct vio_driver ibmvnic_driver = {\n\t.id_table       = ibmvnic_device_table,\n\t.probe          = ibmvnic_probe,\n\t.remove         = ibmvnic_remove,\n\t.get_desired_dma = ibmvnic_get_desired_dma,\n\t.name\t\t= ibmvnic_driver_name,\n\t.pm\t\t= &ibmvnic_pm_ops,\n};\n\n \nstatic int __init ibmvnic_module_init(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, \"net/ibmvnic:online\",\n\t\t\t\t      ibmvnic_cpu_online,\n\t\t\t\t      ibmvnic_cpu_down_prep);\n\tif (ret < 0)\n\t\tgoto out;\n\tibmvnic_online = ret;\n\tret = cpuhp_setup_state_multi(CPUHP_IBMVNIC_DEAD, \"net/ibmvnic:dead\",\n\t\t\t\t      NULL, ibmvnic_cpu_dead);\n\tif (ret)\n\t\tgoto err_dead;\n\n\tret = vio_register_driver(&ibmvnic_driver);\n\tif (ret)\n\t\tgoto err_vio_register;\n\n\tpr_info(\"%s: %s %s\\n\", ibmvnic_driver_name, ibmvnic_driver_string,\n\t\tIBMVNIC_DRIVER_VERSION);\n\n\treturn 0;\nerr_vio_register:\n\tcpuhp_remove_multi_state(CPUHP_IBMVNIC_DEAD);\nerr_dead:\n\tcpuhp_remove_multi_state(ibmvnic_online);\nout:\n\treturn ret;\n}\n\nstatic void __exit ibmvnic_module_exit(void)\n{\n\tvio_unregister_driver(&ibmvnic_driver);\n\tcpuhp_remove_multi_state(CPUHP_IBMVNIC_DEAD);\n\tcpuhp_remove_multi_state(ibmvnic_online);\n}\n\nmodule_init(ibmvnic_module_init);\nmodule_exit(ibmvnic_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}