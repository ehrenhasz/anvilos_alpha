{
  "module_name": "rgmii.c",
  "hash_id": "7af06b830ee2d8c56206edd88fa22faa511a291f9311796862784f4164840e65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ibm/emac/rgmii.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/ethtool.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <asm/io.h>\n\n#include \"emac.h\"\n#include \"debug.h\"\n\n\n\n\n\n\n \n#define RGMII_FER_MASK(idx)\t(0x7 << ((idx) * 4))\n#define RGMII_FER_RTBI(idx)\t(0x4 << ((idx) * 4))\n#define RGMII_FER_RGMII(idx)\t(0x5 << ((idx) * 4))\n#define RGMII_FER_TBI(idx)\t(0x6 << ((idx) * 4))\n#define RGMII_FER_GMII(idx)\t(0x7 << ((idx) * 4))\n#define RGMII_FER_MII(idx)\tRGMII_FER_GMII(idx)\n\n \n#define RGMII_SSR_MASK(idx)\t(0x7 << ((idx) * 8))\n#define RGMII_SSR_10(idx)\t(0x1 << ((idx) * 8))\n#define RGMII_SSR_100(idx)\t(0x2 << ((idx) * 8))\n#define RGMII_SSR_1000(idx)\t(0x4 << ((idx) * 8))\n\n \nstatic inline int rgmii_valid_mode(int phy_mode)\n{\n\treturn  phy_interface_mode_is_rgmii(phy_mode) ||\n\t\tphy_mode == PHY_INTERFACE_MODE_GMII ||\n\t\tphy_mode == PHY_INTERFACE_MODE_MII ||\n\t\tphy_mode == PHY_INTERFACE_MODE_TBI ||\n\t\tphy_mode == PHY_INTERFACE_MODE_RTBI;\n}\n\nstatic inline u32 rgmii_mode_mask(int mode, int input)\n{\n\tswitch (mode) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\treturn RGMII_FER_RGMII(input);\n\tcase PHY_INTERFACE_MODE_TBI:\n\t\treturn RGMII_FER_TBI(input);\n\tcase PHY_INTERFACE_MODE_GMII:\n\t\treturn RGMII_FER_GMII(input);\n\tcase PHY_INTERFACE_MODE_MII:\n\t\treturn RGMII_FER_MII(input);\n\tcase PHY_INTERFACE_MODE_RTBI:\n\t\treturn RGMII_FER_RTBI(input);\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nint rgmii_attach(struct platform_device *ofdev, int input, int mode)\n{\n\tstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\n\tstruct rgmii_regs __iomem *p = dev->base;\n\n\tRGMII_DBG(dev, \"attach(%d)\" NL, input);\n\n\t \n\tif (input < 0 || !rgmii_valid_mode(mode)) {\n\t\tprintk(KERN_ERR \"%pOF: unsupported settings !\\n\",\n\t\t       ofdev->dev.of_node);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&dev->lock);\n\n\t \n\tout_be32(&p->fer, in_be32(&p->fer) | rgmii_mode_mask(mode, input));\n\n\tprintk(KERN_NOTICE \"%pOF: input %d in %s mode\\n\",\n\t       ofdev->dev.of_node, input, phy_modes(mode));\n\n\t++dev->users;\n\n\tmutex_unlock(&dev->lock);\n\n\treturn 0;\n}\n\nvoid rgmii_set_speed(struct platform_device *ofdev, int input, int speed)\n{\n\tstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\n\tstruct rgmii_regs __iomem *p = dev->base;\n\tu32 ssr;\n\n\tmutex_lock(&dev->lock);\n\n\tssr = in_be32(&p->ssr) & ~RGMII_SSR_MASK(input);\n\n\tRGMII_DBG(dev, \"speed(%d, %d)\" NL, input, speed);\n\n\tif (speed == SPEED_1000)\n\t\tssr |= RGMII_SSR_1000(input);\n\telse if (speed == SPEED_100)\n\t\tssr |= RGMII_SSR_100(input);\n\telse if (speed == SPEED_10)\n\t\tssr |= RGMII_SSR_10(input);\n\n\tout_be32(&p->ssr, ssr);\n\n\tmutex_unlock(&dev->lock);\n}\n\nvoid rgmii_get_mdio(struct platform_device *ofdev, int input)\n{\n\tstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\n\tstruct rgmii_regs __iomem *p = dev->base;\n\tu32 fer;\n\n\tRGMII_DBG2(dev, \"get_mdio(%d)\" NL, input);\n\n\tif (!(dev->flags & EMAC_RGMII_FLAG_HAS_MDIO))\n\t\treturn;\n\n\tmutex_lock(&dev->lock);\n\n\tfer = in_be32(&p->fer);\n\tfer |= 0x00080000u >> input;\n\tout_be32(&p->fer, fer);\n\t(void)in_be32(&p->fer);\n\n\tDBG2(dev, \" fer = 0x%08x\\n\", fer);\n}\n\nvoid rgmii_put_mdio(struct platform_device *ofdev, int input)\n{\n\tstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\n\tstruct rgmii_regs __iomem *p = dev->base;\n\tu32 fer;\n\n\tRGMII_DBG2(dev, \"put_mdio(%d)\" NL, input);\n\n\tif (!(dev->flags & EMAC_RGMII_FLAG_HAS_MDIO))\n\t\treturn;\n\n\tfer = in_be32(&p->fer);\n\tfer &= ~(0x00080000u >> input);\n\tout_be32(&p->fer, fer);\n\t(void)in_be32(&p->fer);\n\n\tDBG2(dev, \" fer = 0x%08x\\n\", fer);\n\n\tmutex_unlock(&dev->lock);\n}\n\nvoid rgmii_detach(struct platform_device *ofdev, int input)\n{\n\tstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\n\tstruct rgmii_regs __iomem *p;\n\n\tBUG_ON(!dev || dev->users == 0);\n\tp = dev->base;\n\n\tmutex_lock(&dev->lock);\n\n\tRGMII_DBG(dev, \"detach(%d)\" NL, input);\n\n\t \n\tout_be32(&p->fer, in_be32(&p->fer) & ~RGMII_FER_MASK(input));\n\n\t--dev->users;\n\n\tmutex_unlock(&dev->lock);\n}\n\nint rgmii_get_regs_len(struct platform_device *ofdev)\n{\n\treturn sizeof(struct emac_ethtool_regs_subhdr) +\n\t\tsizeof(struct rgmii_regs);\n}\n\nvoid *rgmii_dump_regs(struct platform_device *ofdev, void *buf)\n{\n\tstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\n\tstruct emac_ethtool_regs_subhdr *hdr = buf;\n\tstruct rgmii_regs *regs = (struct rgmii_regs *)(hdr + 1);\n\n\thdr->version = 0;\n\thdr->index = 0;  \n\tmemcpy_fromio(regs, dev->base, sizeof(struct rgmii_regs));\n\treturn regs + 1;\n}\n\n\nstatic int rgmii_probe(struct platform_device *ofdev)\n{\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct rgmii_instance *dev;\n\tstruct resource regs;\n\tint rc;\n\n\trc = -ENOMEM;\n\tdev = kzalloc(sizeof(struct rgmii_instance), GFP_KERNEL);\n\tif (dev == NULL)\n\t\tgoto err_gone;\n\n\tmutex_init(&dev->lock);\n\tdev->ofdev = ofdev;\n\n\trc = -ENXIO;\n\tif (of_address_to_resource(np, 0, &regs)) {\n\t\tprintk(KERN_ERR \"%pOF: Can't get registers address\\n\", np);\n\t\tgoto err_free;\n\t}\n\n\trc = -ENOMEM;\n\tdev->base = (struct rgmii_regs __iomem *)ioremap(regs.start,\n\t\t\t\t\t\t sizeof(struct rgmii_regs));\n\tif (dev->base == NULL) {\n\t\tprintk(KERN_ERR \"%pOF: Can't map device registers!\\n\", np);\n\t\tgoto err_free;\n\t}\n\n\t \n\tif (of_property_read_bool(ofdev->dev.of_node, \"has-mdio\"))\n\t\tdev->flags |= EMAC_RGMII_FLAG_HAS_MDIO;\n\n\t \n\tif (of_device_is_compatible(ofdev->dev.of_node, \"ibm,rgmii-axon\"))\n\t\tdev->flags |= EMAC_RGMII_FLAG_HAS_MDIO;\n\n\tDBG2(dev, \" Boot FER = 0x%08x, SSR = 0x%08x\\n\",\n\t     in_be32(&dev->base->fer), in_be32(&dev->base->ssr));\n\n\t \n\tout_be32(&dev->base->fer, 0);\n\n\tprintk(KERN_INFO\n\t       \"RGMII %pOF initialized with%s MDIO support\\n\",\n\t       ofdev->dev.of_node,\n\t       (dev->flags & EMAC_RGMII_FLAG_HAS_MDIO) ? \"\" : \"out\");\n\n\twmb();\n\tplatform_set_drvdata(ofdev, dev);\n\n\treturn 0;\n\n err_free:\n\tkfree(dev);\n err_gone:\n\treturn rc;\n}\n\nstatic int rgmii_remove(struct platform_device *ofdev)\n{\n\tstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\n\n\tWARN_ON(dev->users != 0);\n\n\tiounmap(dev->base);\n\tkfree(dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rgmii_match[] =\n{\n\t{\n\t\t.compatible\t= \"ibm,rgmii\",\n\t},\n\t{\n\t\t.type\t\t= \"emac-rgmii\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver rgmii_driver = {\n\t.driver = {\n\t\t.name = \"emac-rgmii\",\n\t\t.of_match_table = rgmii_match,\n\t},\n\t.probe = rgmii_probe,\n\t.remove = rgmii_remove,\n};\n\nint __init rgmii_init(void)\n{\n\treturn platform_driver_register(&rgmii_driver);\n}\n\nvoid rgmii_exit(void)\n{\n\tplatform_driver_unregister(&rgmii_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}