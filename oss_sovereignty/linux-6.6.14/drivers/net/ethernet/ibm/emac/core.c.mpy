{
  "module_name": "core.c",
  "hash_id": "4b037cc5fe057acd3496fc25620957295d393e1a83b1763a6119ef5ecfa9e31b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ibm/emac/core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/crc32.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_net.h>\n#include <linux/of_mdio.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/dma.h>\n#include <linux/uaccess.h>\n#include <asm/dcr.h>\n#include <asm/dcr-regs.h>\n\n#include \"core.h\"\n\n \n\n#define DRV_NAME        \"emac\"\n#define DRV_VERSION     \"3.54\"\n#define DRV_DESC        \"PPC 4xx OCP EMAC driver\"\n\nMODULE_DESCRIPTION(DRV_DESC);\nMODULE_AUTHOR\n    (\"Eugene Surovegin <eugene.surovegin@zultys.com> or <ebs@ebshome.net>\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define EMAC_TX_WAKEUP_THRESH\t\t(NUM_TX_BUFF / 4)\n\n \n#define EMAC_RX_COPY_THRESH\t\tCONFIG_IBM_EMAC_RX_COPY_THRESHOLD\n\n \nstatic u32 busy_phy_map;\nstatic DEFINE_MUTEX(emac_phy_map_lock);\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(emac_probe_wait);\n\n \n\n#define EMAC_BOOT_LIST_SIZE\t4\nstatic struct device_node *emac_boot_list[EMAC_BOOT_LIST_SIZE];\n\n \n#define EMAC_PROBE_DEP_TIMEOUT\t(HZ * 5)\n\n \nstatic inline void emac_report_timeout_error(struct emac_instance *dev,\n\t\t\t\t\t     const char *error)\n{\n\tif (emac_has_feature(dev, EMAC_FTR_440GX_PHY_CLK_FIX |\n\t\t\t\t  EMAC_FTR_460EX_PHY_CLK_FIX |\n\t\t\t\t  EMAC_FTR_440EP_PHY_CLK_FIX))\n\t\tDBG(dev, \"%s\" NL, error);\n\telse if (net_ratelimit())\n\t\tprintk(KERN_ERR \"%pOF: %s\\n\", dev->ofdev->dev.of_node, error);\n}\n\n \nstatic inline void emac_rx_clk_tx(struct emac_instance *dev)\n{\n#ifdef CONFIG_PPC_DCR_NATIVE\n\tif (emac_has_feature(dev, EMAC_FTR_440EP_PHY_CLK_FIX))\n\t\tdcri_clrset(SDR0, SDR0_MFR,\n\t\t\t    0, SDR0_MFR_ECS >> dev->cell_index);\n#endif\n}\n\nstatic inline void emac_rx_clk_default(struct emac_instance *dev)\n{\n#ifdef CONFIG_PPC_DCR_NATIVE\n\tif (emac_has_feature(dev, EMAC_FTR_440EP_PHY_CLK_FIX))\n\t\tdcri_clrset(SDR0, SDR0_MFR,\n\t\t\t    SDR0_MFR_ECS >> dev->cell_index, 0);\n#endif\n}\n\n \n#define PHY_POLL_LINK_ON\tHZ\n#define PHY_POLL_LINK_OFF\t(HZ / 5)\n\n \n#define STOP_TIMEOUT_10\t\t1230\n#define STOP_TIMEOUT_100\t124\n#define STOP_TIMEOUT_1000\t13\n#define STOP_TIMEOUT_1000_JUMBO\t73\n\nstatic unsigned char default_mcast_addr[] = {\n\t0x01, 0x80, 0xC2, 0x00, 0x00, 0x01\n};\n\n \nstatic const char emac_stats_keys[EMAC_ETHTOOL_STATS_COUNT][ETH_GSTRING_LEN] = {\n\t\"rx_packets\", \"rx_bytes\", \"tx_packets\", \"tx_bytes\", \"rx_packets_csum\",\n\t\"tx_packets_csum\", \"tx_undo\", \"rx_dropped_stack\", \"rx_dropped_oom\",\n\t\"rx_dropped_error\", \"rx_dropped_resize\", \"rx_dropped_mtu\",\n\t\"rx_stopped\", \"rx_bd_errors\", \"rx_bd_overrun\", \"rx_bd_bad_packet\",\n\t\"rx_bd_runt_packet\", \"rx_bd_short_event\", \"rx_bd_alignment_error\",\n\t\"rx_bd_bad_fcs\", \"rx_bd_packet_too_long\", \"rx_bd_out_of_range\",\n\t\"rx_bd_in_range\", \"rx_parity\", \"rx_fifo_overrun\", \"rx_overrun\",\n\t\"rx_bad_packet\", \"rx_runt_packet\", \"rx_short_event\",\n\t\"rx_alignment_error\", \"rx_bad_fcs\", \"rx_packet_too_long\",\n\t\"rx_out_of_range\", \"rx_in_range\", \"tx_dropped\", \"tx_bd_errors\",\n\t\"tx_bd_bad_fcs\", \"tx_bd_carrier_loss\", \"tx_bd_excessive_deferral\",\n\t\"tx_bd_excessive_collisions\", \"tx_bd_late_collision\",\n\t\"tx_bd_multple_collisions\", \"tx_bd_single_collision\",\n\t\"tx_bd_underrun\", \"tx_bd_sqe\", \"tx_parity\", \"tx_underrun\", \"tx_sqe\",\n\t\"tx_errors\"\n};\n\nstatic irqreturn_t emac_irq(int irq, void *dev_instance);\nstatic void emac_clean_tx_ring(struct emac_instance *dev);\nstatic void __emac_set_multicast_list(struct emac_instance *dev);\n\nstatic inline int emac_phy_supports_gige(int phy_mode)\n{\n\treturn  phy_interface_mode_is_rgmii(phy_mode) ||\n\t\tphy_mode == PHY_INTERFACE_MODE_GMII ||\n\t\tphy_mode == PHY_INTERFACE_MODE_SGMII ||\n\t\tphy_mode == PHY_INTERFACE_MODE_TBI ||\n\t\tphy_mode == PHY_INTERFACE_MODE_RTBI;\n}\n\nstatic inline int emac_phy_gpcs(int phy_mode)\n{\n\treturn  phy_mode == PHY_INTERFACE_MODE_SGMII ||\n\t\tphy_mode == PHY_INTERFACE_MODE_TBI ||\n\t\tphy_mode == PHY_INTERFACE_MODE_RTBI;\n}\n\nstatic inline void emac_tx_enable(struct emac_instance *dev)\n{\n\tstruct emac_regs __iomem *p = dev->emacp;\n\tu32 r;\n\n\tDBG(dev, \"tx_enable\" NL);\n\n\tr = in_be32(&p->mr0);\n\tif (!(r & EMAC_MR0_TXE))\n\t\tout_be32(&p->mr0, r | EMAC_MR0_TXE);\n}\n\nstatic void emac_tx_disable(struct emac_instance *dev)\n{\n\tstruct emac_regs __iomem *p = dev->emacp;\n\tu32 r;\n\n\tDBG(dev, \"tx_disable\" NL);\n\n\tr = in_be32(&p->mr0);\n\tif (r & EMAC_MR0_TXE) {\n\t\tint n = dev->stop_timeout;\n\t\tout_be32(&p->mr0, r & ~EMAC_MR0_TXE);\n\t\twhile (!(in_be32(&p->mr0) & EMAC_MR0_TXI) && n) {\n\t\t\tudelay(1);\n\t\t\t--n;\n\t\t}\n\t\tif (unlikely(!n))\n\t\t\temac_report_timeout_error(dev, \"TX disable timeout\");\n\t}\n}\n\nstatic void emac_rx_enable(struct emac_instance *dev)\n{\n\tstruct emac_regs __iomem *p = dev->emacp;\n\tu32 r;\n\n\tif (unlikely(test_bit(MAL_COMMAC_RX_STOPPED, &dev->commac.flags)))\n\t\tgoto out;\n\n\tDBG(dev, \"rx_enable\" NL);\n\n\tr = in_be32(&p->mr0);\n\tif (!(r & EMAC_MR0_RXE)) {\n\t\tif (unlikely(!(r & EMAC_MR0_RXI))) {\n\t\t\t \n\t\t\tint n = dev->stop_timeout;\n\t\t\twhile (!(r = in_be32(&p->mr0) & EMAC_MR0_RXI) && n) {\n\t\t\t\tudelay(1);\n\t\t\t\t--n;\n\t\t\t}\n\t\t\tif (unlikely(!n))\n\t\t\t\temac_report_timeout_error(dev,\n\t\t\t\t\t\t\t  \"RX disable timeout\");\n\t\t}\n\t\tout_be32(&p->mr0, r | EMAC_MR0_RXE);\n\t}\n out:\n\t;\n}\n\nstatic void emac_rx_disable(struct emac_instance *dev)\n{\n\tstruct emac_regs __iomem *p = dev->emacp;\n\tu32 r;\n\n\tDBG(dev, \"rx_disable\" NL);\n\n\tr = in_be32(&p->mr0);\n\tif (r & EMAC_MR0_RXE) {\n\t\tint n = dev->stop_timeout;\n\t\tout_be32(&p->mr0, r & ~EMAC_MR0_RXE);\n\t\twhile (!(in_be32(&p->mr0) & EMAC_MR0_RXI) && n) {\n\t\t\tudelay(1);\n\t\t\t--n;\n\t\t}\n\t\tif (unlikely(!n))\n\t\t\temac_report_timeout_error(dev, \"RX disable timeout\");\n\t}\n}\n\nstatic inline void emac_netif_stop(struct emac_instance *dev)\n{\n\tnetif_tx_lock_bh(dev->ndev);\n\tnetif_addr_lock(dev->ndev);\n\tdev->no_mcast = 1;\n\tnetif_addr_unlock(dev->ndev);\n\tnetif_tx_unlock_bh(dev->ndev);\n\tnetif_trans_update(dev->ndev);\t \n\tmal_poll_disable(dev->mal, &dev->commac);\n\tnetif_tx_disable(dev->ndev);\n}\n\nstatic inline void emac_netif_start(struct emac_instance *dev)\n{\n\tnetif_tx_lock_bh(dev->ndev);\n\tnetif_addr_lock(dev->ndev);\n\tdev->no_mcast = 0;\n\tif (dev->mcast_pending && netif_running(dev->ndev))\n\t\t__emac_set_multicast_list(dev);\n\tnetif_addr_unlock(dev->ndev);\n\tnetif_tx_unlock_bh(dev->ndev);\n\n\tnetif_wake_queue(dev->ndev);\n\n\t \n\tmal_poll_enable(dev->mal, &dev->commac);\n}\n\nstatic inline void emac_rx_disable_async(struct emac_instance *dev)\n{\n\tstruct emac_regs __iomem *p = dev->emacp;\n\tu32 r;\n\n\tDBG(dev, \"rx_disable_async\" NL);\n\n\tr = in_be32(&p->mr0);\n\tif (r & EMAC_MR0_RXE)\n\t\tout_be32(&p->mr0, r & ~EMAC_MR0_RXE);\n}\n\nstatic int emac_reset(struct emac_instance *dev)\n{\n\tstruct emac_regs __iomem *p = dev->emacp;\n\tint n = 20;\n\tbool __maybe_unused try_internal_clock = false;\n\n\tDBG(dev, \"reset\" NL);\n\n\tif (!dev->reset_failed) {\n\t\t \n\t\temac_rx_disable(dev);\n\t\temac_tx_disable(dev);\n\t}\n\n#ifdef CONFIG_PPC_DCR_NATIVE\ndo_retry:\n\t \n\tif (emac_has_feature(dev, EMAC_FTR_460EX_PHY_CLK_FIX)) {\n\t\tif (try_internal_clock || (dev->phy_address == 0xffffffff &&\n\t\t\t\t\t   dev->phy_map == 0xffffffff)) {\n\t\t\t \n\t\t\tdcri_clrset(SDR0, SDR0_ETH_CFG,\n\t\t\t\t    0, SDR0_ETH_CFG_ECS << dev->cell_index);\n\t\t} else {\n\t\t\t \n\t\t\tdcri_clrset(SDR0, SDR0_ETH_CFG,\n\t\t\t\t    SDR0_ETH_CFG_ECS << dev->cell_index, 0);\n\t\t}\n\t}\n#endif\n\n\tout_be32(&p->mr0, EMAC_MR0_SRST);\n\twhile ((in_be32(&p->mr0) & EMAC_MR0_SRST) && n)\n\t\t--n;\n\n#ifdef CONFIG_PPC_DCR_NATIVE\n\tif (emac_has_feature(dev, EMAC_FTR_460EX_PHY_CLK_FIX)) {\n\t\tif (!n && !try_internal_clock) {\n\t\t\t \n\t\t\tn = 20;\n\t\t\ttry_internal_clock = true;\n\t\t\tgoto do_retry;\n\t\t}\n\n\t\tif (try_internal_clock || (dev->phy_address == 0xffffffff &&\n\t\t\t\t\t   dev->phy_map == 0xffffffff)) {\n\t\t\t \n\t\t\tdcri_clrset(SDR0, SDR0_ETH_CFG,\n\t\t\t\t    SDR0_ETH_CFG_ECS << dev->cell_index, 0);\n\t\t}\n\t}\n#endif\n\n\tif (n) {\n\t\tdev->reset_failed = 0;\n\t\treturn 0;\n\t} else {\n\t\temac_report_timeout_error(dev, \"reset timeout\");\n\t\tdev->reset_failed = 1;\n\t\treturn -ETIMEDOUT;\n\t}\n}\n\nstatic void emac_hash_mc(struct emac_instance *dev)\n{\n\tconst int regs = EMAC_XAHT_REGS(dev);\n\tu32 *gaht_base = emac_gaht_base(dev);\n\tu32 gaht_temp[EMAC_XAHT_MAX_REGS];\n\tstruct netdev_hw_addr *ha;\n\tint i;\n\n\tDBG(dev, \"hash_mc %d\" NL, netdev_mc_count(dev->ndev));\n\n\tmemset(gaht_temp, 0, sizeof (gaht_temp));\n\n\tnetdev_for_each_mc_addr(ha, dev->ndev) {\n\t\tint slot, reg, mask;\n\t\tDBG2(dev, \"mc %pM\" NL, ha->addr);\n\n\t\tslot = EMAC_XAHT_CRC_TO_SLOT(dev,\n\t\t\t\t\t     ether_crc(ETH_ALEN, ha->addr));\n\t\treg = EMAC_XAHT_SLOT_TO_REG(dev, slot);\n\t\tmask = EMAC_XAHT_SLOT_TO_MASK(dev, slot);\n\n\t\tgaht_temp[reg] |= mask;\n\t}\n\n\tfor (i = 0; i < regs; i++)\n\t\tout_be32(gaht_base + i, gaht_temp[i]);\n}\n\nstatic inline u32 emac_iff2rmr(struct net_device *ndev)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tu32 r;\n\n\tr = EMAC_RMR_SP | EMAC_RMR_SFCS | EMAC_RMR_IAE | EMAC_RMR_BAE;\n\n\tif (emac_has_feature(dev, EMAC_FTR_EMAC4))\n\t    r |= EMAC4_RMR_BASE;\n\telse\n\t    r |= EMAC_RMR_BASE;\n\n\tif (ndev->flags & IFF_PROMISC)\n\t\tr |= EMAC_RMR_PME;\n\telse if (ndev->flags & IFF_ALLMULTI ||\n\t\t\t (netdev_mc_count(ndev) > EMAC_XAHT_SLOTS(dev)))\n\t\tr |= EMAC_RMR_PMME;\n\telse if (!netdev_mc_empty(ndev))\n\t\tr |= EMAC_RMR_MAE;\n\n\tif (emac_has_feature(dev, EMAC_APM821XX_REQ_JUMBO_FRAME_SIZE)) {\n\t\tr &= ~EMAC4_RMR_MJS_MASK;\n\t\tr |= EMAC4_RMR_MJS(ndev->mtu);\n\t}\n\n\treturn r;\n}\n\nstatic u32 __emac_calc_base_mr1(struct emac_instance *dev, int tx_size, int rx_size)\n{\n\tu32 ret = EMAC_MR1_VLE | EMAC_MR1_IST | EMAC_MR1_TR0_MULT;\n\n\tDBG2(dev, \"__emac_calc_base_mr1\" NL);\n\n\tswitch(tx_size) {\n\tcase 2048:\n\t\tret |= EMAC_MR1_TFS_2K;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: Unknown Tx FIFO size %d\\n\",\n\t\t       dev->ndev->name, tx_size);\n\t}\n\n\tswitch(rx_size) {\n\tcase 16384:\n\t\tret |= EMAC_MR1_RFS_16K;\n\t\tbreak;\n\tcase 4096:\n\t\tret |= EMAC_MR1_RFS_4K;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: Unknown Rx FIFO size %d\\n\",\n\t\t       dev->ndev->name, rx_size);\n\t}\n\n\treturn ret;\n}\n\nstatic u32 __emac4_calc_base_mr1(struct emac_instance *dev, int tx_size, int rx_size)\n{\n\tu32 ret = EMAC_MR1_VLE | EMAC_MR1_IST | EMAC4_MR1_TR |\n\t\tEMAC4_MR1_OBCI(dev->opb_bus_freq / 1000000);\n\n\tDBG2(dev, \"__emac4_calc_base_mr1\" NL);\n\n\tswitch(tx_size) {\n\tcase 16384:\n\t\tret |= EMAC4_MR1_TFS_16K;\n\t\tbreak;\n\tcase 8192:\n\t\tret |= EMAC4_MR1_TFS_8K;\n\t\tbreak;\n\tcase 4096:\n\t\tret |= EMAC4_MR1_TFS_4K;\n\t\tbreak;\n\tcase 2048:\n\t\tret |= EMAC4_MR1_TFS_2K;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: Unknown Tx FIFO size %d\\n\",\n\t\t       dev->ndev->name, tx_size);\n\t}\n\n\tswitch(rx_size) {\n\tcase 16384:\n\t\tret |= EMAC4_MR1_RFS_16K;\n\t\tbreak;\n\tcase 8192:\n\t\tret |= EMAC4_MR1_RFS_8K;\n\t\tbreak;\n\tcase 4096:\n\t\tret |= EMAC4_MR1_RFS_4K;\n\t\tbreak;\n\tcase 2048:\n\t\tret |= EMAC4_MR1_RFS_2K;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: Unknown Rx FIFO size %d\\n\",\n\t\t       dev->ndev->name, rx_size);\n\t}\n\n\treturn ret;\n}\n\nstatic u32 emac_calc_base_mr1(struct emac_instance *dev, int tx_size, int rx_size)\n{\n\treturn emac_has_feature(dev, EMAC_FTR_EMAC4) ?\n\t\t__emac4_calc_base_mr1(dev, tx_size, rx_size) :\n\t\t__emac_calc_base_mr1(dev, tx_size, rx_size);\n}\n\nstatic inline u32 emac_calc_trtr(struct emac_instance *dev, unsigned int size)\n{\n\tif (emac_has_feature(dev, EMAC_FTR_EMAC4))\n\t\treturn ((size >> 6) - 1) << EMAC_TRTR_SHIFT_EMAC4;\n\telse\n\t\treturn ((size >> 6) - 1) << EMAC_TRTR_SHIFT;\n}\n\nstatic inline u32 emac_calc_rwmr(struct emac_instance *dev,\n\t\t\t\t unsigned int low, unsigned int high)\n{\n\tif (emac_has_feature(dev, EMAC_FTR_EMAC4))\n\t\treturn (low << 22) | ( (high & 0x3ff) << 6);\n\telse\n\t\treturn (low << 23) | ( (high & 0x1ff) << 7);\n}\n\nstatic int emac_configure(struct emac_instance *dev)\n{\n\tstruct emac_regs __iomem *p = dev->emacp;\n\tstruct net_device *ndev = dev->ndev;\n\tint tx_size, rx_size, link = netif_carrier_ok(dev->ndev);\n\tu32 r, mr1 = 0;\n\n\tDBG(dev, \"configure\" NL);\n\n\tif (!link) {\n\t\tout_be32(&p->mr1, in_be32(&p->mr1)\n\t\t\t | EMAC_MR1_FDE | EMAC_MR1_ILE);\n\t\tudelay(100);\n\t} else if (emac_reset(dev) < 0)\n\t\treturn -ETIMEDOUT;\n\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_TAH))\n\t\ttah_reset(dev->tah_dev);\n\n\tDBG(dev, \" link = %d duplex = %d, pause = %d, asym_pause = %d\\n\",\n\t    link, dev->phy.duplex, dev->phy.pause, dev->phy.asym_pause);\n\n\t \n\ttx_size = dev->tx_fifo_size;\n\trx_size = dev->rx_fifo_size;\n\n\t \n\tif (!link)\n\t\tmr1 = EMAC_MR1_FDE | EMAC_MR1_ILE;\n\n\t \n\telse if (dev->phy.duplex == DUPLEX_FULL)\n\t\tmr1 |= EMAC_MR1_FDE | EMAC_MR1_MWSW_001;\n\n\t \n\tdev->stop_timeout = STOP_TIMEOUT_10;\n\tswitch (dev->phy.speed) {\n\tcase SPEED_1000:\n\t\tif (emac_phy_gpcs(dev->phy.mode)) {\n\t\t\tmr1 |= EMAC_MR1_MF_1000GPCS | EMAC_MR1_MF_IPPA(\n\t\t\t\t(dev->phy.gpcs_address != 0xffffffff) ?\n\t\t\t\t dev->phy.gpcs_address : dev->phy.address);\n\n\t\t\t \n\t\t\tout_be32(&p->u1.emac4.ipcr, 0xdeadbeef);\n\t\t} else\n\t\t\tmr1 |= EMAC_MR1_MF_1000;\n\n\t\t \n\t\ttx_size = dev->tx_fifo_size_gige;\n\t\trx_size = dev->rx_fifo_size_gige;\n\n\t\tif (dev->ndev->mtu > ETH_DATA_LEN) {\n\t\t\tif (emac_has_feature(dev, EMAC_FTR_EMAC4))\n\t\t\t\tmr1 |= EMAC4_MR1_JPSM;\n\t\t\telse\n\t\t\t\tmr1 |= EMAC_MR1_JPSM;\n\t\t\tdev->stop_timeout = STOP_TIMEOUT_1000_JUMBO;\n\t\t} else\n\t\t\tdev->stop_timeout = STOP_TIMEOUT_1000;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tmr1 |= EMAC_MR1_MF_100;\n\t\tdev->stop_timeout = STOP_TIMEOUT_100;\n\t\tbreak;\n\tdefault:  \n\t\tbreak;\n\t}\n\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_RGMII))\n\t\trgmii_set_speed(dev->rgmii_dev, dev->rgmii_port,\n\t\t\t\tdev->phy.speed);\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_ZMII))\n\t\tzmii_set_speed(dev->zmii_dev, dev->zmii_port, dev->phy.speed);\n\n\t \n\tif (!emac_has_feature(dev, EMAC_FTR_NO_FLOW_CONTROL_40x) &&\n\t    dev->phy.duplex == DUPLEX_FULL) {\n\t\tif (dev->phy.pause)\n\t\t\tmr1 |= EMAC_MR1_EIFC | EMAC_MR1_APP;\n\t\telse if (dev->phy.asym_pause)\n\t\t\tmr1 |= EMAC_MR1_APP;\n\t}\n\n\t \n\tmr1 |= emac_calc_base_mr1(dev, tx_size, rx_size);\n\tout_be32(&p->mr1, mr1);\n\n\t \n\tout_be32(&p->iahr, (ndev->dev_addr[0] << 8) | ndev->dev_addr[1]);\n\tout_be32(&p->ialr, (ndev->dev_addr[2] << 24) |\n\t\t (ndev->dev_addr[3] << 16) | (ndev->dev_addr[4] << 8) |\n\t\t ndev->dev_addr[5]);\n\n\t \n\tout_be32(&p->vtpid, 0x8100);\n\n\t \n\tr = emac_iff2rmr(ndev);\n\tif (r & EMAC_RMR_MAE)\n\t\temac_hash_mc(dev);\n\tout_be32(&p->rmr, r);\n\n\t \n\tif (emac_has_feature(dev, EMAC_FTR_EMAC4))\n\t\tr = EMAC4_TMR1((dev->mal_burst_size / dev->fifo_entry_size) + 1,\n\t\t\t       tx_size / 2 / dev->fifo_entry_size);\n\telse\n\t\tr = EMAC_TMR1((dev->mal_burst_size / dev->fifo_entry_size) + 1,\n\t\t\t      tx_size / 2 / dev->fifo_entry_size);\n\tout_be32(&p->tmr1, r);\n\tout_be32(&p->trtr, emac_calc_trtr(dev, tx_size / 2));\n\n\t \n\tr = emac_calc_rwmr(dev, rx_size / 8 / dev->fifo_entry_size,\n\t\t\t   rx_size / 4 / dev->fifo_entry_size);\n\tout_be32(&p->rwmr, r);\n\n\t \n\tout_be32(&p->ptr, 0xffff);\n\n\t \n\tr = EMAC_ISR_OVR | EMAC_ISR_BP | EMAC_ISR_SE |\n\t\tEMAC_ISR_ALE | EMAC_ISR_BFCS | EMAC_ISR_PTLE | EMAC_ISR_ORE |\n\t\tEMAC_ISR_IRE | EMAC_ISR_TE;\n\tif (emac_has_feature(dev, EMAC_FTR_EMAC4))\n\t    r |= EMAC4_ISR_TXPE | EMAC4_ISR_RXPE  ;\n\tout_be32(&p->iser,  r);\n\n\t \n\tif (emac_phy_gpcs(dev->phy.mode)) {\n\t\tif (dev->phy.gpcs_address != 0xffffffff)\n\t\t\temac_mii_reset_gpcs(&dev->phy);\n\t\telse\n\t\t\temac_mii_reset_phy(&dev->phy);\n\t}\n\n\treturn 0;\n}\n\nstatic void emac_reinitialize(struct emac_instance *dev)\n{\n\tDBG(dev, \"reinitialize\" NL);\n\n\temac_netif_stop(dev);\n\tif (!emac_configure(dev)) {\n\t\temac_tx_enable(dev);\n\t\temac_rx_enable(dev);\n\t}\n\temac_netif_start(dev);\n}\n\nstatic void emac_full_tx_reset(struct emac_instance *dev)\n{\n\tDBG(dev, \"full_tx_reset\" NL);\n\n\temac_tx_disable(dev);\n\tmal_disable_tx_channel(dev->mal, dev->mal_tx_chan);\n\temac_clean_tx_ring(dev);\n\tdev->tx_cnt = dev->tx_slot = dev->ack_slot = 0;\n\n\temac_configure(dev);\n\n\tmal_enable_tx_channel(dev->mal, dev->mal_tx_chan);\n\temac_tx_enable(dev);\n\temac_rx_enable(dev);\n}\n\nstatic void emac_reset_work(struct work_struct *work)\n{\n\tstruct emac_instance *dev = container_of(work, struct emac_instance, reset_work);\n\n\tDBG(dev, \"reset_work\" NL);\n\n\tmutex_lock(&dev->link_lock);\n\tif (dev->opened) {\n\t\temac_netif_stop(dev);\n\t\temac_full_tx_reset(dev);\n\t\temac_netif_start(dev);\n\t}\n\tmutex_unlock(&dev->link_lock);\n}\n\nstatic void emac_tx_timeout(struct net_device *ndev, unsigned int txqueue)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\n\tDBG(dev, \"tx_timeout\" NL);\n\n\tschedule_work(&dev->reset_work);\n}\n\n\nstatic inline int emac_phy_done(struct emac_instance *dev, u32 stacr)\n{\n\tint done = !!(stacr & EMAC_STACR_OC);\n\n\tif (emac_has_feature(dev, EMAC_FTR_STACR_OC_INVERT))\n\t\tdone = !done;\n\n\treturn done;\n};\n\nstatic int __emac_mdio_read(struct emac_instance *dev, u8 id, u8 reg)\n{\n\tstruct emac_regs __iomem *p = dev->emacp;\n\tu32 r = 0;\n\tint n, err = -ETIMEDOUT;\n\n\tmutex_lock(&dev->mdio_lock);\n\n\tDBG2(dev, \"mdio_read(%02x,%02x)\" NL, id, reg);\n\n\t \n\tif (emac_has_feature(dev, EMAC_FTR_HAS_ZMII))\n\t\tzmii_get_mdio(dev->zmii_dev, dev->zmii_port);\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_RGMII))\n\t\trgmii_get_mdio(dev->rgmii_dev, dev->rgmii_port);\n\n\t \n\tn = 20;\n\twhile (!emac_phy_done(dev, in_be32(&p->stacr))) {\n\t\tudelay(1);\n\t\tif (!--n) {\n\t\t\tDBG2(dev, \" -> timeout wait idle\\n\");\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n\tif (emac_has_feature(dev, EMAC_FTR_EMAC4))\n\t\tr = EMAC4_STACR_BASE(dev->opb_bus_freq);\n\telse\n\t\tr = EMAC_STACR_BASE(dev->opb_bus_freq);\n\tif (emac_has_feature(dev, EMAC_FTR_STACR_OC_INVERT))\n\t\tr |= EMAC_STACR_OC;\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_NEW_STACR))\n\t\tr |= EMACX_STACR_STAC_READ;\n\telse\n\t\tr |= EMAC_STACR_STAC_READ;\n\tr |= (reg & EMAC_STACR_PRA_MASK)\n\t\t| ((id & EMAC_STACR_PCDA_MASK) << EMAC_STACR_PCDA_SHIFT);\n\tout_be32(&p->stacr, r);\n\n\t \n\tn = 200;\n\twhile (!emac_phy_done(dev, (r = in_be32(&p->stacr)))) {\n\t\tudelay(1);\n\t\tif (!--n) {\n\t\t\tDBG2(dev, \" -> timeout wait complete\\n\");\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (unlikely(r & EMAC_STACR_PHYE)) {\n\t\tDBG(dev, \"mdio_read(%02x, %02x) failed\" NL, id, reg);\n\t\terr = -EREMOTEIO;\n\t\tgoto bail;\n\t}\n\n\tr = ((r >> EMAC_STACR_PHYD_SHIFT) & EMAC_STACR_PHYD_MASK);\n\n\tDBG2(dev, \"mdio_read -> %04x\" NL, r);\n\terr = 0;\n bail:\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_RGMII))\n\t\trgmii_put_mdio(dev->rgmii_dev, dev->rgmii_port);\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_ZMII))\n\t\tzmii_put_mdio(dev->zmii_dev, dev->zmii_port);\n\tmutex_unlock(&dev->mdio_lock);\n\n\treturn err == 0 ? r : err;\n}\n\nstatic void __emac_mdio_write(struct emac_instance *dev, u8 id, u8 reg,\n\t\t\t      u16 val)\n{\n\tstruct emac_regs __iomem *p = dev->emacp;\n\tu32 r = 0;\n\tint n;\n\n\tmutex_lock(&dev->mdio_lock);\n\n\tDBG2(dev, \"mdio_write(%02x,%02x,%04x)\" NL, id, reg, val);\n\n\t \n\tif (emac_has_feature(dev, EMAC_FTR_HAS_ZMII))\n\t\tzmii_get_mdio(dev->zmii_dev, dev->zmii_port);\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_RGMII))\n\t\trgmii_get_mdio(dev->rgmii_dev, dev->rgmii_port);\n\n\t \n\tn = 20;\n\twhile (!emac_phy_done(dev, in_be32(&p->stacr))) {\n\t\tudelay(1);\n\t\tif (!--n) {\n\t\t\tDBG2(dev, \" -> timeout wait idle\\n\");\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t \n\tif (emac_has_feature(dev, EMAC_FTR_EMAC4))\n\t\tr = EMAC4_STACR_BASE(dev->opb_bus_freq);\n\telse\n\t\tr = EMAC_STACR_BASE(dev->opb_bus_freq);\n\tif (emac_has_feature(dev, EMAC_FTR_STACR_OC_INVERT))\n\t\tr |= EMAC_STACR_OC;\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_NEW_STACR))\n\t\tr |= EMACX_STACR_STAC_WRITE;\n\telse\n\t\tr |= EMAC_STACR_STAC_WRITE;\n\tr |= (reg & EMAC_STACR_PRA_MASK) |\n\t\t((id & EMAC_STACR_PCDA_MASK) << EMAC_STACR_PCDA_SHIFT) |\n\t\t(val << EMAC_STACR_PHYD_SHIFT);\n\tout_be32(&p->stacr, r);\n\n\t \n\tn = 200;\n\twhile (!emac_phy_done(dev, in_be32(&p->stacr))) {\n\t\tudelay(1);\n\t\tif (!--n) {\n\t\t\tDBG2(dev, \" -> timeout wait complete\\n\");\n\t\t\tgoto bail;\n\t\t}\n\t}\n bail:\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_RGMII))\n\t\trgmii_put_mdio(dev->rgmii_dev, dev->rgmii_port);\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_ZMII))\n\t\tzmii_put_mdio(dev->zmii_dev, dev->zmii_port);\n\tmutex_unlock(&dev->mdio_lock);\n}\n\nstatic int emac_mdio_read(struct net_device *ndev, int id, int reg)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tint res;\n\n\tres = __emac_mdio_read((dev->mdio_instance &&\n\t\t\t\tdev->phy.gpcs_address != id) ?\n\t\t\t\tdev->mdio_instance : dev,\n\t\t\t       (u8) id, (u8) reg);\n\treturn res;\n}\n\nstatic void emac_mdio_write(struct net_device *ndev, int id, int reg, int val)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\n\t__emac_mdio_write((dev->mdio_instance &&\n\t\t\t   dev->phy.gpcs_address != id) ?\n\t\t\t   dev->mdio_instance : dev,\n\t\t\t  (u8) id, (u8) reg, (u16) val);\n}\n\n \nstatic void __emac_set_multicast_list(struct emac_instance *dev)\n{\n\tstruct emac_regs __iomem *p = dev->emacp;\n\tu32 rmr = emac_iff2rmr(dev->ndev);\n\n\tDBG(dev, \"__multicast %08x\" NL, rmr);\n\n\t \n\tdev->mcast_pending = 0;\n\temac_rx_disable(dev);\n\tif (rmr & EMAC_RMR_MAE)\n\t\temac_hash_mc(dev);\n\tout_be32(&p->rmr, rmr);\n\temac_rx_enable(dev);\n}\n\n \nstatic void emac_set_multicast_list(struct net_device *ndev)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\n\tDBG(dev, \"multicast\" NL);\n\n\tBUG_ON(!netif_running(dev->ndev));\n\n\tif (dev->no_mcast) {\n\t\tdev->mcast_pending = 1;\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev->link_lock);\n\t__emac_set_multicast_list(dev);\n\tmutex_unlock(&dev->link_lock);\n}\n\nstatic int emac_set_mac_address(struct net_device *ndev, void *sa)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tstruct sockaddr *addr = sa;\n\tstruct emac_regs __iomem *p = dev->emacp;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t       return -EADDRNOTAVAIL;\n\n\tmutex_lock(&dev->link_lock);\n\n\teth_hw_addr_set(ndev, addr->sa_data);\n\n\temac_rx_disable(dev);\n\temac_tx_disable(dev);\n\tout_be32(&p->iahr, (ndev->dev_addr[0] << 8) | ndev->dev_addr[1]);\n\tout_be32(&p->ialr, (ndev->dev_addr[2] << 24) |\n\t\t(ndev->dev_addr[3] << 16) | (ndev->dev_addr[4] << 8) |\n\t\tndev->dev_addr[5]);\n\temac_tx_enable(dev);\n\temac_rx_enable(dev);\n\n\tmutex_unlock(&dev->link_lock);\n\n\treturn 0;\n}\n\nstatic int emac_resize_rx_ring(struct emac_instance *dev, int new_mtu)\n{\n\tint rx_sync_size = emac_rx_sync_size(new_mtu);\n\tint rx_skb_size = emac_rx_skb_size(new_mtu);\n\tint i, ret = 0;\n\tint mr1_jumbo_bit_change = 0;\n\n\tmutex_lock(&dev->link_lock);\n\temac_netif_stop(dev);\n\temac_rx_disable(dev);\n\tmal_disable_rx_channel(dev->mal, dev->mal_rx_chan);\n\n\tif (dev->rx_sg_skb) {\n\t\t++dev->estats.rx_dropped_resize;\n\t\tdev_kfree_skb(dev->rx_sg_skb);\n\t\tdev->rx_sg_skb = NULL;\n\t}\n\n\t \n\tfor (i = 0; i < NUM_RX_BUFF; ++i) {\n\t\tif (dev->rx_desc[i].ctrl & MAL_RX_CTRL_FIRST)\n\t\t\t++dev->estats.rx_dropped_resize;\n\n\t\tdev->rx_desc[i].data_len = 0;\n\t\tdev->rx_desc[i].ctrl = MAL_RX_CTRL_EMPTY |\n\t\t    (i == (NUM_RX_BUFF - 1) ? MAL_RX_CTRL_WRAP : 0);\n\t}\n\n\t \n\tif (rx_skb_size <= dev->rx_skb_size)\n\t\tgoto skip;\n\n\t \n\tfor (i = 0; i < NUM_RX_BUFF; ++i) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = netdev_alloc_skb_ip_align(dev->ndev, rx_skb_size);\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto oom;\n\t\t}\n\n\t\tBUG_ON(!dev->rx_skb[i]);\n\t\tdev_kfree_skb(dev->rx_skb[i]);\n\n\t\tdev->rx_desc[i].data_ptr =\n\t\t    dma_map_single(&dev->ofdev->dev, skb->data - NET_IP_ALIGN,\n\t\t\t\t   rx_sync_size, DMA_FROM_DEVICE)\n\t\t\t\t   + NET_IP_ALIGN;\n\t\tdev->rx_skb[i] = skb;\n\t}\n skip:\n\t \n\tif (emac_has_feature(dev, EMAC_APM821XX_REQ_JUMBO_FRAME_SIZE)) {\n\t\tmr1_jumbo_bit_change = (new_mtu > ETH_DATA_LEN) ||\n\t\t\t\t(dev->ndev->mtu > ETH_DATA_LEN);\n\t} else {\n\t\tmr1_jumbo_bit_change = (new_mtu > ETH_DATA_LEN) ^\n\t\t\t\t(dev->ndev->mtu > ETH_DATA_LEN);\n\t}\n\n\tif (mr1_jumbo_bit_change) {\n\t\t \n\t\tset_bit(MAL_COMMAC_RX_STOPPED, &dev->commac.flags);\n\n\t\tdev->ndev->mtu = new_mtu;\n\t\temac_full_tx_reset(dev);\n\t}\n\n\tmal_set_rcbs(dev->mal, dev->mal_rx_chan, emac_rx_size(new_mtu));\n oom:\n\t \n\tclear_bit(MAL_COMMAC_RX_STOPPED, &dev->commac.flags);\n\tdev->rx_slot = 0;\n\tmal_enable_rx_channel(dev->mal, dev->mal_rx_chan);\n\temac_rx_enable(dev);\n\temac_netif_start(dev);\n\tmutex_unlock(&dev->link_lock);\n\n\treturn ret;\n}\n\n \nstatic int emac_change_mtu(struct net_device *ndev, int new_mtu)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tint ret = 0;\n\n\tDBG(dev, \"change_mtu(%d)\" NL, new_mtu);\n\n\tif (netif_running(ndev)) {\n\t\t \n\t\tif (emac_rx_skb_size(ndev->mtu) != emac_rx_skb_size(new_mtu))\n\t\t\tret = emac_resize_rx_ring(dev, new_mtu);\n\t}\n\n\tif (!ret) {\n\t\tndev->mtu = new_mtu;\n\t\tdev->rx_skb_size = emac_rx_skb_size(new_mtu);\n\t\tdev->rx_sync_size = emac_rx_sync_size(new_mtu);\n\t}\n\n\treturn ret;\n}\n\nstatic void emac_clean_tx_ring(struct emac_instance *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_TX_BUFF; ++i) {\n\t\tif (dev->tx_skb[i]) {\n\t\t\tdev_kfree_skb(dev->tx_skb[i]);\n\t\t\tdev->tx_skb[i] = NULL;\n\t\t\tif (dev->tx_desc[i].ctrl & MAL_TX_CTRL_READY)\n\t\t\t\t++dev->estats.tx_dropped;\n\t\t}\n\t\tdev->tx_desc[i].ctrl = 0;\n\t\tdev->tx_desc[i].data_ptr = 0;\n\t}\n}\n\nstatic void emac_clean_rx_ring(struct emac_instance *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_RX_BUFF; ++i)\n\t\tif (dev->rx_skb[i]) {\n\t\t\tdev->rx_desc[i].ctrl = 0;\n\t\t\tdev_kfree_skb(dev->rx_skb[i]);\n\t\t\tdev->rx_skb[i] = NULL;\n\t\t\tdev->rx_desc[i].data_ptr = 0;\n\t\t}\n\n\tif (dev->rx_sg_skb) {\n\t\tdev_kfree_skb(dev->rx_sg_skb);\n\t\tdev->rx_sg_skb = NULL;\n\t}\n}\n\nstatic int\n__emac_prepare_rx_skb(struct sk_buff *skb, struct emac_instance *dev, int slot)\n{\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tdev->rx_skb[slot] = skb;\n\tdev->rx_desc[slot].data_len = 0;\n\n\tdev->rx_desc[slot].data_ptr =\n\t    dma_map_single(&dev->ofdev->dev, skb->data - NET_IP_ALIGN,\n\t\t\t   dev->rx_sync_size, DMA_FROM_DEVICE) + NET_IP_ALIGN;\n\twmb();\n\tdev->rx_desc[slot].ctrl = MAL_RX_CTRL_EMPTY |\n\t    (slot == (NUM_RX_BUFF - 1) ? MAL_RX_CTRL_WRAP : 0);\n\n\treturn 0;\n}\n\nstatic int\nemac_alloc_rx_skb(struct emac_instance *dev, int slot)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __netdev_alloc_skb_ip_align(dev->ndev, dev->rx_skb_size,\n\t\t\t\t\t  GFP_KERNEL);\n\n\treturn __emac_prepare_rx_skb(skb, dev, slot);\n}\n\nstatic int\nemac_alloc_rx_skb_napi(struct emac_instance *dev, int slot)\n{\n\tstruct sk_buff *skb;\n\n\tskb = napi_alloc_skb(&dev->mal->napi, dev->rx_skb_size);\n\n\treturn __emac_prepare_rx_skb(skb, dev, slot);\n}\n\nstatic void emac_print_link_status(struct emac_instance *dev)\n{\n\tif (netif_carrier_ok(dev->ndev))\n\t\tprintk(KERN_INFO \"%s: link is up, %d %s%s\\n\",\n\t\t       dev->ndev->name, dev->phy.speed,\n\t\t       dev->phy.duplex == DUPLEX_FULL ? \"FDX\" : \"HDX\",\n\t\t       dev->phy.pause ? \", pause enabled\" :\n\t\t       dev->phy.asym_pause ? \", asymmetric pause enabled\" : \"\");\n\telse\n\t\tprintk(KERN_INFO \"%s: link is down\\n\", dev->ndev->name);\n}\n\n \nstatic int emac_open(struct net_device *ndev)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tint err, i;\n\n\tDBG(dev, \"open\" NL);\n\n\t \n\terr = request_irq(dev->emac_irq, emac_irq, 0, \"EMAC\", dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: failed to request IRQ %d\\n\",\n\t\t       ndev->name, dev->emac_irq);\n\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < NUM_RX_BUFF; ++i)\n\t\tif (emac_alloc_rx_skb(dev, i)) {\n\t\t\tprintk(KERN_ERR \"%s: failed to allocate RX ring\\n\",\n\t\t\t       ndev->name);\n\t\t\tgoto oom;\n\t\t}\n\n\tdev->tx_cnt = dev->tx_slot = dev->ack_slot = dev->rx_slot = 0;\n\tclear_bit(MAL_COMMAC_RX_STOPPED, &dev->commac.flags);\n\tdev->rx_sg_skb = NULL;\n\n\tmutex_lock(&dev->link_lock);\n\tdev->opened = 1;\n\n\t \n\tif (dev->phy.address >= 0) {\n\t\tint link_poll_interval;\n\t\tif (dev->phy.def->ops->poll_link(&dev->phy)) {\n\t\t\tdev->phy.def->ops->read_link(&dev->phy);\n\t\t\temac_rx_clk_default(dev);\n\t\t\tnetif_carrier_on(dev->ndev);\n\t\t\tlink_poll_interval = PHY_POLL_LINK_ON;\n\t\t} else {\n\t\t\temac_rx_clk_tx(dev);\n\t\t\tnetif_carrier_off(dev->ndev);\n\t\t\tlink_poll_interval = PHY_POLL_LINK_OFF;\n\t\t}\n\t\tdev->link_polling = 1;\n\t\twmb();\n\t\tschedule_delayed_work(&dev->link_work, link_poll_interval);\n\t\temac_print_link_status(dev);\n\t} else\n\t\tnetif_carrier_on(dev->ndev);\n\n\t \n\tdev_mc_add_global(ndev, default_mcast_addr);\n\n\temac_configure(dev);\n\tmal_poll_add(dev->mal, &dev->commac);\n\tmal_enable_tx_channel(dev->mal, dev->mal_tx_chan);\n\tmal_set_rcbs(dev->mal, dev->mal_rx_chan, emac_rx_size(ndev->mtu));\n\tmal_enable_rx_channel(dev->mal, dev->mal_rx_chan);\n\temac_tx_enable(dev);\n\temac_rx_enable(dev);\n\temac_netif_start(dev);\n\n\tmutex_unlock(&dev->link_lock);\n\n\treturn 0;\n oom:\n\temac_clean_rx_ring(dev);\n\tfree_irq(dev->emac_irq, dev);\n\n\treturn -ENOMEM;\n}\n\n \n#if 0\nstatic int emac_link_differs(struct emac_instance *dev)\n{\n\tu32 r = in_be32(&dev->emacp->mr1);\n\n\tint duplex = r & EMAC_MR1_FDE ? DUPLEX_FULL : DUPLEX_HALF;\n\tint speed, pause, asym_pause;\n\n\tif (r & EMAC_MR1_MF_1000)\n\t\tspeed = SPEED_1000;\n\telse if (r & EMAC_MR1_MF_100)\n\t\tspeed = SPEED_100;\n\telse\n\t\tspeed = SPEED_10;\n\n\tswitch (r & (EMAC_MR1_EIFC | EMAC_MR1_APP)) {\n\tcase (EMAC_MR1_EIFC | EMAC_MR1_APP):\n\t\tpause = 1;\n\t\tasym_pause = 0;\n\t\tbreak;\n\tcase EMAC_MR1_APP:\n\t\tpause = 0;\n\t\tasym_pause = 1;\n\t\tbreak;\n\tdefault:\n\t\tpause = asym_pause = 0;\n\t}\n\treturn speed != dev->phy.speed || duplex != dev->phy.duplex ||\n\t    pause != dev->phy.pause || asym_pause != dev->phy.asym_pause;\n}\n#endif\n\nstatic void emac_link_timer(struct work_struct *work)\n{\n\tstruct emac_instance *dev =\n\t\tcontainer_of(to_delayed_work(work),\n\t\t\t     struct emac_instance, link_work);\n\tint link_poll_interval;\n\n\tmutex_lock(&dev->link_lock);\n\tDBG2(dev, \"link timer\" NL);\n\n\tif (!dev->opened)\n\t\tgoto bail;\n\n\tif (dev->phy.def->ops->poll_link(&dev->phy)) {\n\t\tif (!netif_carrier_ok(dev->ndev)) {\n\t\t\temac_rx_clk_default(dev);\n\t\t\t \n\t\t\tdev->phy.def->ops->read_link(&dev->phy);\n\n\t\t\tnetif_carrier_on(dev->ndev);\n\t\t\temac_netif_stop(dev);\n\t\t\temac_full_tx_reset(dev);\n\t\t\temac_netif_start(dev);\n\t\t\temac_print_link_status(dev);\n\t\t}\n\t\tlink_poll_interval = PHY_POLL_LINK_ON;\n\t} else {\n\t\tif (netif_carrier_ok(dev->ndev)) {\n\t\t\temac_rx_clk_tx(dev);\n\t\t\tnetif_carrier_off(dev->ndev);\n\t\t\tnetif_tx_disable(dev->ndev);\n\t\t\temac_reinitialize(dev);\n\t\t\temac_print_link_status(dev);\n\t\t}\n\t\tlink_poll_interval = PHY_POLL_LINK_OFF;\n\t}\n\tschedule_delayed_work(&dev->link_work, link_poll_interval);\n bail:\n\tmutex_unlock(&dev->link_lock);\n}\n\nstatic void emac_force_link_update(struct emac_instance *dev)\n{\n\tnetif_carrier_off(dev->ndev);\n\tsmp_rmb();\n\tif (dev->link_polling) {\n\t\tcancel_delayed_work_sync(&dev->link_work);\n\t\tif (dev->link_polling)\n\t\t\tschedule_delayed_work(&dev->link_work,  PHY_POLL_LINK_OFF);\n\t}\n}\n\n \nstatic int emac_close(struct net_device *ndev)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\n\tDBG(dev, \"close\" NL);\n\n\tif (dev->phy.address >= 0) {\n\t\tdev->link_polling = 0;\n\t\tcancel_delayed_work_sync(&dev->link_work);\n\t}\n\tmutex_lock(&dev->link_lock);\n\temac_netif_stop(dev);\n\tdev->opened = 0;\n\tmutex_unlock(&dev->link_lock);\n\n\temac_rx_disable(dev);\n\temac_tx_disable(dev);\n\tmal_disable_rx_channel(dev->mal, dev->mal_rx_chan);\n\tmal_disable_tx_channel(dev->mal, dev->mal_tx_chan);\n\tmal_poll_del(dev->mal, &dev->commac);\n\n\temac_clean_tx_ring(dev);\n\temac_clean_rx_ring(dev);\n\n\tfree_irq(dev->emac_irq, dev);\n\n\tnetif_carrier_off(ndev);\n\n\treturn 0;\n}\n\nstatic inline u16 emac_tx_csum(struct emac_instance *dev,\n\t\t\t       struct sk_buff *skb)\n{\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_TAH) &&\n\t\t(skb->ip_summed == CHECKSUM_PARTIAL)) {\n\t\t++dev->stats.tx_packets_csum;\n\t\treturn EMAC_TX_CTRL_TAH_CSUM;\n\t}\n\treturn 0;\n}\n\nstatic inline netdev_tx_t emac_xmit_finish(struct emac_instance *dev, int len)\n{\n\tstruct emac_regs __iomem *p = dev->emacp;\n\tstruct net_device *ndev = dev->ndev;\n\n\t \n\tif (emac_has_feature(dev, EMAC_FTR_EMAC4))\n\t\tout_be32(&p->tmr0, EMAC4_TMR0_XMIT);\n\telse\n\t\tout_be32(&p->tmr0, EMAC_TMR0_XMIT);\n\n\tif (unlikely(++dev->tx_cnt == NUM_TX_BUFF)) {\n\t\tnetif_stop_queue(ndev);\n\t\tDBG2(dev, \"stopped TX queue\" NL);\n\t}\n\n\tnetif_trans_update(ndev);\n\t++dev->stats.tx_packets;\n\tdev->stats.tx_bytes += len;\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic netdev_tx_t emac_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tunsigned int len = skb->len;\n\tint slot;\n\n\tu16 ctrl = EMAC_TX_CTRL_GFCS | EMAC_TX_CTRL_GP | MAL_TX_CTRL_READY |\n\t    MAL_TX_CTRL_LAST | emac_tx_csum(dev, skb);\n\n\tslot = dev->tx_slot++;\n\tif (dev->tx_slot == NUM_TX_BUFF) {\n\t\tdev->tx_slot = 0;\n\t\tctrl |= MAL_TX_CTRL_WRAP;\n\t}\n\n\tDBG2(dev, \"xmit(%u) %d\" NL, len, slot);\n\n\tdev->tx_skb[slot] = skb;\n\tdev->tx_desc[slot].data_ptr = dma_map_single(&dev->ofdev->dev,\n\t\t\t\t\t\t     skb->data, len,\n\t\t\t\t\t\t     DMA_TO_DEVICE);\n\tdev->tx_desc[slot].data_len = (u16) len;\n\twmb();\n\tdev->tx_desc[slot].ctrl = ctrl;\n\n\treturn emac_xmit_finish(dev, len);\n}\n\nstatic inline int emac_xmit_split(struct emac_instance *dev, int slot,\n\t\t\t\t  u32 pd, int len, int last, u16 base_ctrl)\n{\n\twhile (1) {\n\t\tu16 ctrl = base_ctrl;\n\t\tint chunk = min(len, MAL_MAX_TX_SIZE);\n\t\tlen -= chunk;\n\n\t\tslot = (slot + 1) % NUM_TX_BUFF;\n\n\t\tif (last && !len)\n\t\t\tctrl |= MAL_TX_CTRL_LAST;\n\t\tif (slot == NUM_TX_BUFF - 1)\n\t\t\tctrl |= MAL_TX_CTRL_WRAP;\n\n\t\tdev->tx_skb[slot] = NULL;\n\t\tdev->tx_desc[slot].data_ptr = pd;\n\t\tdev->tx_desc[slot].data_len = (u16) chunk;\n\t\tdev->tx_desc[slot].ctrl = ctrl;\n\t\t++dev->tx_cnt;\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tpd += chunk;\n\t}\n\treturn slot;\n}\n\n \nstatic netdev_tx_t\nemac_start_xmit_sg(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tint nr_frags = skb_shinfo(skb)->nr_frags;\n\tint len = skb->len, chunk;\n\tint slot, i;\n\tu16 ctrl;\n\tu32 pd;\n\n\t \n\tif (likely(!nr_frags && len <= MAL_MAX_TX_SIZE))\n\t\treturn emac_start_xmit(skb, ndev);\n\n\tlen -= skb->data_len;\n\n\t \n\tif (unlikely(dev->tx_cnt + nr_frags + mal_tx_chunks(len) > NUM_TX_BUFF))\n\t\tgoto stop_queue;\n\n\tctrl = EMAC_TX_CTRL_GFCS | EMAC_TX_CTRL_GP | MAL_TX_CTRL_READY |\n\t    emac_tx_csum(dev, skb);\n\tslot = dev->tx_slot;\n\n\t \n\tdev->tx_skb[slot] = NULL;\n\tchunk = min(len, MAL_MAX_TX_SIZE);\n\tdev->tx_desc[slot].data_ptr = pd =\n\t    dma_map_single(&dev->ofdev->dev, skb->data, len, DMA_TO_DEVICE);\n\tdev->tx_desc[slot].data_len = (u16) chunk;\n\tlen -= chunk;\n\tif (unlikely(len))\n\t\tslot = emac_xmit_split(dev, slot, pd + chunk, len, !nr_frags,\n\t\t\t\t       ctrl);\n\t \n\tfor (i = 0; i < nr_frags; ++i) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tlen = skb_frag_size(frag);\n\n\t\tif (unlikely(dev->tx_cnt + mal_tx_chunks(len) >= NUM_TX_BUFF))\n\t\t\tgoto undo_frame;\n\n\t\tpd = skb_frag_dma_map(&dev->ofdev->dev, frag, 0, len,\n\t\t\t\t      DMA_TO_DEVICE);\n\n\t\tslot = emac_xmit_split(dev, slot, pd, len, i == nr_frags - 1,\n\t\t\t\t       ctrl);\n\t}\n\n\tDBG2(dev, \"xmit_sg(%u) %d - %d\" NL, skb->len, dev->tx_slot, slot);\n\n\t \n\tdev->tx_skb[slot] = skb;\n\n\t \n\tif (dev->tx_slot == NUM_TX_BUFF - 1)\n\t\tctrl |= MAL_TX_CTRL_WRAP;\n\twmb();\n\tdev->tx_desc[dev->tx_slot].ctrl = ctrl;\n\tdev->tx_slot = (slot + 1) % NUM_TX_BUFF;\n\n\treturn emac_xmit_finish(dev, skb->len);\n\n undo_frame:\n\t \n\twhile (slot != dev->tx_slot) {\n\t\tdev->tx_desc[slot].ctrl = 0;\n\t\t--dev->tx_cnt;\n\t\tif (--slot < 0)\n\t\t\tslot = NUM_TX_BUFF - 1;\n\t}\n\t++dev->estats.tx_undo;\n\n stop_queue:\n\tnetif_stop_queue(ndev);\n\tDBG2(dev, \"stopped TX queue\" NL);\n\treturn NETDEV_TX_BUSY;\n}\n\n \nstatic void emac_parse_tx_error(struct emac_instance *dev, u16 ctrl)\n{\n\tstruct emac_error_stats *st = &dev->estats;\n\n\tDBG(dev, \"BD TX error %04x\" NL, ctrl);\n\n\t++st->tx_bd_errors;\n\tif (ctrl & EMAC_TX_ST_BFCS)\n\t\t++st->tx_bd_bad_fcs;\n\tif (ctrl & EMAC_TX_ST_LCS)\n\t\t++st->tx_bd_carrier_loss;\n\tif (ctrl & EMAC_TX_ST_ED)\n\t\t++st->tx_bd_excessive_deferral;\n\tif (ctrl & EMAC_TX_ST_EC)\n\t\t++st->tx_bd_excessive_collisions;\n\tif (ctrl & EMAC_TX_ST_LC)\n\t\t++st->tx_bd_late_collision;\n\tif (ctrl & EMAC_TX_ST_MC)\n\t\t++st->tx_bd_multple_collisions;\n\tif (ctrl & EMAC_TX_ST_SC)\n\t\t++st->tx_bd_single_collision;\n\tif (ctrl & EMAC_TX_ST_UR)\n\t\t++st->tx_bd_underrun;\n\tif (ctrl & EMAC_TX_ST_SQE)\n\t\t++st->tx_bd_sqe;\n}\n\nstatic void emac_poll_tx(void *param)\n{\n\tstruct emac_instance *dev = param;\n\tu32 bad_mask;\n\n\tDBG2(dev, \"poll_tx, %d %d\" NL, dev->tx_cnt, dev->ack_slot);\n\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_TAH))\n\t\tbad_mask = EMAC_IS_BAD_TX_TAH;\n\telse\n\t\tbad_mask = EMAC_IS_BAD_TX;\n\n\tnetif_tx_lock_bh(dev->ndev);\n\tif (dev->tx_cnt) {\n\t\tu16 ctrl;\n\t\tint slot = dev->ack_slot, n = 0;\n\tagain:\n\t\tctrl = dev->tx_desc[slot].ctrl;\n\t\tif (!(ctrl & MAL_TX_CTRL_READY)) {\n\t\t\tstruct sk_buff *skb = dev->tx_skb[slot];\n\t\t\t++n;\n\n\t\t\tif (skb) {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tdev->tx_skb[slot] = NULL;\n\t\t\t}\n\t\t\tslot = (slot + 1) % NUM_TX_BUFF;\n\n\t\t\tif (unlikely(ctrl & bad_mask))\n\t\t\t\temac_parse_tx_error(dev, ctrl);\n\n\t\t\tif (--dev->tx_cnt)\n\t\t\t\tgoto again;\n\t\t}\n\t\tif (n) {\n\t\t\tdev->ack_slot = slot;\n\t\t\tif (netif_queue_stopped(dev->ndev) &&\n\t\t\t    dev->tx_cnt < EMAC_TX_WAKEUP_THRESH)\n\t\t\t\tnetif_wake_queue(dev->ndev);\n\n\t\t\tDBG2(dev, \"tx %d pkts\" NL, n);\n\t\t}\n\t}\n\tnetif_tx_unlock_bh(dev->ndev);\n}\n\nstatic inline void emac_recycle_rx_skb(struct emac_instance *dev, int slot,\n\t\t\t\t       int len)\n{\n\tstruct sk_buff *skb = dev->rx_skb[slot];\n\n\tDBG2(dev, \"recycle %d %d\" NL, slot, len);\n\n\tif (len)\n\t\tdma_map_single(&dev->ofdev->dev, skb->data - NET_IP_ALIGN,\n\t\t\t       SKB_DATA_ALIGN(len + NET_IP_ALIGN),\n\t\t\t       DMA_FROM_DEVICE);\n\n\tdev->rx_desc[slot].data_len = 0;\n\twmb();\n\tdev->rx_desc[slot].ctrl = MAL_RX_CTRL_EMPTY |\n\t    (slot == (NUM_RX_BUFF - 1) ? MAL_RX_CTRL_WRAP : 0);\n}\n\nstatic void emac_parse_rx_error(struct emac_instance *dev, u16 ctrl)\n{\n\tstruct emac_error_stats *st = &dev->estats;\n\n\tDBG(dev, \"BD RX error %04x\" NL, ctrl);\n\n\t++st->rx_bd_errors;\n\tif (ctrl & EMAC_RX_ST_OE)\n\t\t++st->rx_bd_overrun;\n\tif (ctrl & EMAC_RX_ST_BP)\n\t\t++st->rx_bd_bad_packet;\n\tif (ctrl & EMAC_RX_ST_RP)\n\t\t++st->rx_bd_runt_packet;\n\tif (ctrl & EMAC_RX_ST_SE)\n\t\t++st->rx_bd_short_event;\n\tif (ctrl & EMAC_RX_ST_AE)\n\t\t++st->rx_bd_alignment_error;\n\tif (ctrl & EMAC_RX_ST_BFCS)\n\t\t++st->rx_bd_bad_fcs;\n\tif (ctrl & EMAC_RX_ST_PTL)\n\t\t++st->rx_bd_packet_too_long;\n\tif (ctrl & EMAC_RX_ST_ORE)\n\t\t++st->rx_bd_out_of_range;\n\tif (ctrl & EMAC_RX_ST_IRE)\n\t\t++st->rx_bd_in_range;\n}\n\nstatic inline void emac_rx_csum(struct emac_instance *dev,\n\t\t\t\tstruct sk_buff *skb, u16 ctrl)\n{\n#ifdef CONFIG_IBM_EMAC_TAH\n\tif (!ctrl && dev->tah_dev) {\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t++dev->stats.rx_packets_csum;\n\t}\n#endif\n}\n\nstatic inline int emac_rx_sg_append(struct emac_instance *dev, int slot)\n{\n\tif (likely(dev->rx_sg_skb != NULL)) {\n\t\tint len = dev->rx_desc[slot].data_len;\n\t\tint tot_len = dev->rx_sg_skb->len + len;\n\n\t\tif (unlikely(tot_len + NET_IP_ALIGN > dev->rx_skb_size)) {\n\t\t\t++dev->estats.rx_dropped_mtu;\n\t\t\tdev_kfree_skb(dev->rx_sg_skb);\n\t\t\tdev->rx_sg_skb = NULL;\n\t\t} else {\n\t\t\tmemcpy(skb_tail_pointer(dev->rx_sg_skb),\n\t\t\t\t\t dev->rx_skb[slot]->data, len);\n\t\t\tskb_put(dev->rx_sg_skb, len);\n\t\t\temac_recycle_rx_skb(dev, slot, len);\n\t\t\treturn 0;\n\t\t}\n\t}\n\temac_recycle_rx_skb(dev, slot, 0);\n\treturn -1;\n}\n\n \nstatic int emac_poll_rx(void *param, int budget)\n{\n\tstruct emac_instance *dev = param;\n\tint slot = dev->rx_slot, received = 0;\n\n\tDBG2(dev, \"poll_rx(%d)\" NL, budget);\n\n again:\n\twhile (budget > 0) {\n\t\tint len;\n\t\tstruct sk_buff *skb;\n\t\tu16 ctrl = dev->rx_desc[slot].ctrl;\n\n\t\tif (ctrl & MAL_RX_CTRL_EMPTY)\n\t\t\tbreak;\n\n\t\tskb = dev->rx_skb[slot];\n\t\tmb();\n\t\tlen = dev->rx_desc[slot].data_len;\n\n\t\tif (unlikely(!MAL_IS_SINGLE_RX(ctrl)))\n\t\t\tgoto sg;\n\n\t\tctrl &= EMAC_BAD_RX_MASK;\n\t\tif (unlikely(ctrl && ctrl != EMAC_RX_TAH_BAD_CSUM)) {\n\t\t\temac_parse_rx_error(dev, ctrl);\n\t\t\t++dev->estats.rx_dropped_error;\n\t\t\temac_recycle_rx_skb(dev, slot, 0);\n\t\t\tlen = 0;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (len < ETH_HLEN) {\n\t\t\t++dev->estats.rx_dropped_stack;\n\t\t\temac_recycle_rx_skb(dev, slot, len);\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (len && len < EMAC_RX_COPY_THRESH) {\n\t\t\tstruct sk_buff *copy_skb;\n\n\t\t\tcopy_skb = napi_alloc_skb(&dev->mal->napi, len);\n\t\t\tif (unlikely(!copy_skb))\n\t\t\t\tgoto oom;\n\n\t\t\tmemcpy(copy_skb->data - NET_IP_ALIGN,\n\t\t\t       skb->data - NET_IP_ALIGN,\n\t\t\t       len + NET_IP_ALIGN);\n\t\t\temac_recycle_rx_skb(dev, slot, len);\n\t\t\tskb = copy_skb;\n\t\t} else if (unlikely(emac_alloc_rx_skb_napi(dev, slot)))\n\t\t\tgoto oom;\n\n\t\tskb_put(skb, len);\n\tpush_packet:\n\t\tskb->protocol = eth_type_trans(skb, dev->ndev);\n\t\temac_rx_csum(dev, skb, ctrl);\n\n\t\tif (unlikely(netif_receive_skb(skb) == NET_RX_DROP))\n\t\t\t++dev->estats.rx_dropped_stack;\n\tnext:\n\t\t++dev->stats.rx_packets;\n\tskip:\n\t\tdev->stats.rx_bytes += len;\n\t\tslot = (slot + 1) % NUM_RX_BUFF;\n\t\t--budget;\n\t\t++received;\n\t\tcontinue;\n\tsg:\n\t\tif (ctrl & MAL_RX_CTRL_FIRST) {\n\t\t\tBUG_ON(dev->rx_sg_skb);\n\t\t\tif (unlikely(emac_alloc_rx_skb_napi(dev, slot))) {\n\t\t\t\tDBG(dev, \"rx OOM %d\" NL, slot);\n\t\t\t\t++dev->estats.rx_dropped_oom;\n\t\t\t\temac_recycle_rx_skb(dev, slot, 0);\n\t\t\t} else {\n\t\t\t\tdev->rx_sg_skb = skb;\n\t\t\t\tskb_put(skb, len);\n\t\t\t}\n\t\t} else if (!emac_rx_sg_append(dev, slot) &&\n\t\t\t   (ctrl & MAL_RX_CTRL_LAST)) {\n\n\t\t\tskb = dev->rx_sg_skb;\n\t\t\tdev->rx_sg_skb = NULL;\n\n\t\t\tctrl &= EMAC_BAD_RX_MASK;\n\t\t\tif (unlikely(ctrl && ctrl != EMAC_RX_TAH_BAD_CSUM)) {\n\t\t\t\temac_parse_rx_error(dev, ctrl);\n\t\t\t\t++dev->estats.rx_dropped_error;\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tlen = 0;\n\t\t\t} else\n\t\t\t\tgoto push_packet;\n\t\t}\n\t\tgoto skip;\n\toom:\n\t\tDBG(dev, \"rx OOM %d\" NL, slot);\n\t\t \n\t\t++dev->estats.rx_dropped_oom;\n\t\temac_recycle_rx_skb(dev, slot, 0);\n\t\tgoto next;\n\t}\n\n\tif (received) {\n\t\tDBG2(dev, \"rx %d BDs\" NL, received);\n\t\tdev->rx_slot = slot;\n\t}\n\n\tif (unlikely(budget && test_bit(MAL_COMMAC_RX_STOPPED, &dev->commac.flags))) {\n\t\tmb();\n\t\tif (!(dev->rx_desc[slot].ctrl & MAL_RX_CTRL_EMPTY)) {\n\t\t\tDBG2(dev, \"rx restart\" NL);\n\t\t\treceived = 0;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (dev->rx_sg_skb) {\n\t\t\tDBG2(dev, \"dropping partial rx packet\" NL);\n\t\t\t++dev->estats.rx_dropped_error;\n\t\t\tdev_kfree_skb(dev->rx_sg_skb);\n\t\t\tdev->rx_sg_skb = NULL;\n\t\t}\n\n\t\tclear_bit(MAL_COMMAC_RX_STOPPED, &dev->commac.flags);\n\t\tmal_enable_rx_channel(dev->mal, dev->mal_rx_chan);\n\t\temac_rx_enable(dev);\n\t\tdev->rx_slot = 0;\n\t}\n\treturn received;\n}\n\n \nstatic int emac_peek_rx(void *param)\n{\n\tstruct emac_instance *dev = param;\n\n\treturn !(dev->rx_desc[dev->rx_slot].ctrl & MAL_RX_CTRL_EMPTY);\n}\n\n \nstatic int emac_peek_rx_sg(void *param)\n{\n\tstruct emac_instance *dev = param;\n\n\tint slot = dev->rx_slot;\n\twhile (1) {\n\t\tu16 ctrl = dev->rx_desc[slot].ctrl;\n\t\tif (ctrl & MAL_RX_CTRL_EMPTY)\n\t\t\treturn 0;\n\t\telse if (ctrl & MAL_RX_CTRL_LAST)\n\t\t\treturn 1;\n\n\t\tslot = (slot + 1) % NUM_RX_BUFF;\n\n\t\t \n\t\tif (unlikely(slot == dev->rx_slot))\n\t\t\treturn 0;\n\t}\n}\n\n \nstatic void emac_rxde(void *param)\n{\n\tstruct emac_instance *dev = param;\n\n\t++dev->estats.rx_stopped;\n\temac_rx_disable_async(dev);\n}\n\n \nstatic irqreturn_t emac_irq(int irq, void *dev_instance)\n{\n\tstruct emac_instance *dev = dev_instance;\n\tstruct emac_regs __iomem *p = dev->emacp;\n\tstruct emac_error_stats *st = &dev->estats;\n\tu32 isr;\n\n\tspin_lock(&dev->lock);\n\n\tisr = in_be32(&p->isr);\n\tout_be32(&p->isr, isr);\n\n\tDBG(dev, \"isr = %08x\" NL, isr);\n\n\tif (isr & EMAC4_ISR_TXPE)\n\t\t++st->tx_parity;\n\tif (isr & EMAC4_ISR_RXPE)\n\t\t++st->rx_parity;\n\tif (isr & EMAC4_ISR_TXUE)\n\t\t++st->tx_underrun;\n\tif (isr & EMAC4_ISR_RXOE)\n\t\t++st->rx_fifo_overrun;\n\tif (isr & EMAC_ISR_OVR)\n\t\t++st->rx_overrun;\n\tif (isr & EMAC_ISR_BP)\n\t\t++st->rx_bad_packet;\n\tif (isr & EMAC_ISR_RP)\n\t\t++st->rx_runt_packet;\n\tif (isr & EMAC_ISR_SE)\n\t\t++st->rx_short_event;\n\tif (isr & EMAC_ISR_ALE)\n\t\t++st->rx_alignment_error;\n\tif (isr & EMAC_ISR_BFCS)\n\t\t++st->rx_bad_fcs;\n\tif (isr & EMAC_ISR_PTLE)\n\t\t++st->rx_packet_too_long;\n\tif (isr & EMAC_ISR_ORE)\n\t\t++st->rx_out_of_range;\n\tif (isr & EMAC_ISR_IRE)\n\t\t++st->rx_in_range;\n\tif (isr & EMAC_ISR_SQE)\n\t\t++st->tx_sqe;\n\tif (isr & EMAC_ISR_TE)\n\t\t++st->tx_errors;\n\n\tspin_unlock(&dev->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct net_device_stats *emac_stats(struct net_device *ndev)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tstruct emac_stats *st = &dev->stats;\n\tstruct emac_error_stats *est = &dev->estats;\n\tstruct net_device_stats *nst = &ndev->stats;\n\tunsigned long flags;\n\n\tDBG2(dev, \"stats\" NL);\n\n\t \n\tspin_lock_irqsave(&dev->lock, flags);\n\tnst->rx_packets = (unsigned long)st->rx_packets;\n\tnst->rx_bytes = (unsigned long)st->rx_bytes;\n\tnst->tx_packets = (unsigned long)st->tx_packets;\n\tnst->tx_bytes = (unsigned long)st->tx_bytes;\n\tnst->rx_dropped = (unsigned long)(est->rx_dropped_oom +\n\t\t\t\t\t  est->rx_dropped_error +\n\t\t\t\t\t  est->rx_dropped_resize +\n\t\t\t\t\t  est->rx_dropped_mtu);\n\tnst->tx_dropped = (unsigned long)est->tx_dropped;\n\n\tnst->rx_errors = (unsigned long)est->rx_bd_errors;\n\tnst->rx_fifo_errors = (unsigned long)(est->rx_bd_overrun +\n\t\t\t\t\t      est->rx_fifo_overrun +\n\t\t\t\t\t      est->rx_overrun);\n\tnst->rx_frame_errors = (unsigned long)(est->rx_bd_alignment_error +\n\t\t\t\t\t       est->rx_alignment_error);\n\tnst->rx_crc_errors = (unsigned long)(est->rx_bd_bad_fcs +\n\t\t\t\t\t     est->rx_bad_fcs);\n\tnst->rx_length_errors = (unsigned long)(est->rx_bd_runt_packet +\n\t\t\t\t\t\test->rx_bd_short_event +\n\t\t\t\t\t\test->rx_bd_packet_too_long +\n\t\t\t\t\t\test->rx_bd_out_of_range +\n\t\t\t\t\t\test->rx_bd_in_range +\n\t\t\t\t\t\test->rx_runt_packet +\n\t\t\t\t\t\test->rx_short_event +\n\t\t\t\t\t\test->rx_packet_too_long +\n\t\t\t\t\t\test->rx_out_of_range +\n\t\t\t\t\t\test->rx_in_range);\n\n\tnst->tx_errors = (unsigned long)(est->tx_bd_errors + est->tx_errors);\n\tnst->tx_fifo_errors = (unsigned long)(est->tx_bd_underrun +\n\t\t\t\t\t      est->tx_underrun);\n\tnst->tx_carrier_errors = (unsigned long)est->tx_bd_carrier_loss;\n\tnst->collisions = (unsigned long)(est->tx_bd_excessive_deferral +\n\t\t\t\t\t  est->tx_bd_excessive_collisions +\n\t\t\t\t\t  est->tx_bd_late_collision +\n\t\t\t\t\t  est->tx_bd_multple_collisions);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn nst;\n}\n\nstatic struct mal_commac_ops emac_commac_ops = {\n\t.poll_tx = &emac_poll_tx,\n\t.poll_rx = &emac_poll_rx,\n\t.peek_rx = &emac_peek_rx,\n\t.rxde = &emac_rxde,\n};\n\nstatic struct mal_commac_ops emac_commac_sg_ops = {\n\t.poll_tx = &emac_poll_tx,\n\t.poll_rx = &emac_poll_rx,\n\t.peek_rx = &emac_peek_rx_sg,\n\t.rxde = &emac_rxde,\n};\n\n \nstatic int emac_ethtool_get_link_ksettings(struct net_device *ndev,\n\t\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tu32 supported, advertising;\n\n\tsupported = dev->phy.features;\n\tcmd->base.port = PORT_MII;\n\tcmd->base.phy_address = dev->phy.address;\n\n\tmutex_lock(&dev->link_lock);\n\tadvertising = dev->phy.advertising;\n\tcmd->base.autoneg = dev->phy.autoneg;\n\tcmd->base.speed = dev->phy.speed;\n\tcmd->base.duplex = dev->phy.duplex;\n\tmutex_unlock(&dev->link_lock);\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int\nemac_ethtool_set_link_ksettings(struct net_device *ndev,\n\t\t\t\tconst struct ethtool_link_ksettings *cmd)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tu32 f = dev->phy.features;\n\tu32 advertising;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\tDBG(dev, \"set_settings(%d, %d, %d, 0x%08x)\" NL,\n\t    cmd->base.autoneg, cmd->base.speed, cmd->base.duplex, advertising);\n\n\t \n\tif (dev->phy.address < 0)\n\t\treturn -EOPNOTSUPP;\n\tif (cmd->base.autoneg != AUTONEG_ENABLE &&\n\t    cmd->base.autoneg != AUTONEG_DISABLE)\n\t\treturn -EINVAL;\n\tif (cmd->base.autoneg == AUTONEG_ENABLE && advertising == 0)\n\t\treturn -EINVAL;\n\tif (cmd->base.duplex != DUPLEX_HALF && cmd->base.duplex != DUPLEX_FULL)\n\t\treturn -EINVAL;\n\n\tif (cmd->base.autoneg == AUTONEG_DISABLE) {\n\t\tswitch (cmd->base.speed) {\n\t\tcase SPEED_10:\n\t\t\tif (cmd->base.duplex == DUPLEX_HALF &&\n\t\t\t    !(f & SUPPORTED_10baseT_Half))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (cmd->base.duplex == DUPLEX_FULL &&\n\t\t\t    !(f & SUPPORTED_10baseT_Full))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tif (cmd->base.duplex == DUPLEX_HALF &&\n\t\t\t    !(f & SUPPORTED_100baseT_Half))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (cmd->base.duplex == DUPLEX_FULL &&\n\t\t\t    !(f & SUPPORTED_100baseT_Full))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\tif (cmd->base.duplex == DUPLEX_HALF &&\n\t\t\t    !(f & SUPPORTED_1000baseT_Half))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (cmd->base.duplex == DUPLEX_FULL &&\n\t\t\t    !(f & SUPPORTED_1000baseT_Full))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmutex_lock(&dev->link_lock);\n\t\tdev->phy.def->ops->setup_forced(&dev->phy, cmd->base.speed,\n\t\t\t\t\t\tcmd->base.duplex);\n\t\tmutex_unlock(&dev->link_lock);\n\n\t} else {\n\t\tif (!(f & SUPPORTED_Autoneg))\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&dev->link_lock);\n\t\tdev->phy.def->ops->setup_aneg(&dev->phy,\n\t\t\t\t\t      (advertising & f) |\n\t\t\t\t\t      (dev->phy.advertising &\n\t\t\t\t\t       (ADVERTISED_Pause |\n\t\t\t\t\t\tADVERTISED_Asym_Pause)));\n\t\tmutex_unlock(&dev->link_lock);\n\t}\n\temac_force_link_update(dev);\n\n\treturn 0;\n}\n\nstatic void\nemac_ethtool_get_ringparam(struct net_device *ndev,\n\t\t\t   struct ethtool_ringparam *rp,\n\t\t\t   struct kernel_ethtool_ringparam *kernel_rp,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\trp->rx_max_pending = rp->rx_pending = NUM_RX_BUFF;\n\trp->tx_max_pending = rp->tx_pending = NUM_TX_BUFF;\n}\n\nstatic void emac_ethtool_get_pauseparam(struct net_device *ndev,\n\t\t\t\t\tstruct ethtool_pauseparam *pp)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\n\tmutex_lock(&dev->link_lock);\n\tif ((dev->phy.features & SUPPORTED_Autoneg) &&\n\t    (dev->phy.advertising & (ADVERTISED_Pause | ADVERTISED_Asym_Pause)))\n\t\tpp->autoneg = 1;\n\n\tif (dev->phy.duplex == DUPLEX_FULL) {\n\t\tif (dev->phy.pause)\n\t\t\tpp->rx_pause = pp->tx_pause = 1;\n\t\telse if (dev->phy.asym_pause)\n\t\t\tpp->tx_pause = 1;\n\t}\n\tmutex_unlock(&dev->link_lock);\n}\n\nstatic int emac_get_regs_len(struct emac_instance *dev)\n{\n\t\treturn sizeof(struct emac_ethtool_regs_subhdr) +\n\t\t\tsizeof(struct emac_regs);\n}\n\nstatic int emac_ethtool_get_regs_len(struct net_device *ndev)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tint size;\n\n\tsize = sizeof(struct emac_ethtool_regs_hdr) +\n\t\temac_get_regs_len(dev) + mal_get_regs_len(dev->mal);\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_ZMII))\n\t\tsize += zmii_get_regs_len(dev->zmii_dev);\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_RGMII))\n\t\tsize += rgmii_get_regs_len(dev->rgmii_dev);\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_TAH))\n\t\tsize += tah_get_regs_len(dev->tah_dev);\n\n\treturn size;\n}\n\nstatic void *emac_dump_regs(struct emac_instance *dev, void *buf)\n{\n\tstruct emac_ethtool_regs_subhdr *hdr = buf;\n\n\thdr->index = dev->cell_index;\n\tif (emac_has_feature(dev, EMAC_FTR_EMAC4SYNC)) {\n\t\thdr->version = EMAC4SYNC_ETHTOOL_REGS_VER;\n\t} else if (emac_has_feature(dev, EMAC_FTR_EMAC4)) {\n\t\thdr->version = EMAC4_ETHTOOL_REGS_VER;\n\t} else {\n\t\thdr->version = EMAC_ETHTOOL_REGS_VER;\n\t}\n\tmemcpy_fromio(hdr + 1, dev->emacp, sizeof(struct emac_regs));\n\treturn (void *)(hdr + 1) + sizeof(struct emac_regs);\n}\n\nstatic void emac_ethtool_get_regs(struct net_device *ndev,\n\t\t\t\t  struct ethtool_regs *regs, void *buf)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tstruct emac_ethtool_regs_hdr *hdr = buf;\n\n\thdr->components = 0;\n\tbuf = hdr + 1;\n\n\tbuf = mal_dump_regs(dev->mal, buf);\n\tbuf = emac_dump_regs(dev, buf);\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_ZMII)) {\n\t\thdr->components |= EMAC_ETHTOOL_REGS_ZMII;\n\t\tbuf = zmii_dump_regs(dev->zmii_dev, buf);\n\t}\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_RGMII)) {\n\t\thdr->components |= EMAC_ETHTOOL_REGS_RGMII;\n\t\tbuf = rgmii_dump_regs(dev->rgmii_dev, buf);\n\t}\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_TAH)) {\n\t\thdr->components |= EMAC_ETHTOOL_REGS_TAH;\n\t\tbuf = tah_dump_regs(dev->tah_dev, buf);\n\t}\n}\n\nstatic int emac_ethtool_nway_reset(struct net_device *ndev)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tint res = 0;\n\n\tDBG(dev, \"nway_reset\" NL);\n\n\tif (dev->phy.address < 0)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&dev->link_lock);\n\tif (!dev->phy.autoneg) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdev->phy.def->ops->setup_aneg(&dev->phy, dev->phy.advertising);\n out:\n\tmutex_unlock(&dev->link_lock);\n\temac_force_link_update(dev);\n\treturn res;\n}\n\nstatic int emac_ethtool_get_sset_count(struct net_device *ndev, int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn EMAC_ETHTOOL_STATS_COUNT;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic void emac_ethtool_get_strings(struct net_device *ndev, u32 stringset,\n\t\t\t\t     u8 * buf)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\tmemcpy(buf, &emac_stats_keys, sizeof(emac_stats_keys));\n}\n\nstatic void emac_ethtool_get_ethtool_stats(struct net_device *ndev,\n\t\t\t\t\t   struct ethtool_stats *estats,\n\t\t\t\t\t   u64 * tmp_stats)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\n\tmemcpy(tmp_stats, &dev->stats, sizeof(dev->stats));\n\ttmp_stats += sizeof(dev->stats) / sizeof(u64);\n\tmemcpy(tmp_stats, &dev->estats, sizeof(dev->estats));\n}\n\nstatic void emac_ethtool_get_drvinfo(struct net_device *ndev,\n\t\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\n\tstrscpy(info->driver, \"ibm_emac\", sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tsnprintf(info->bus_info, sizeof(info->bus_info), \"PPC 4xx EMAC-%d %pOF\",\n\t\t dev->cell_index, dev->ofdev->dev.of_node);\n}\n\nstatic const struct ethtool_ops emac_ethtool_ops = {\n\t.get_drvinfo = emac_ethtool_get_drvinfo,\n\n\t.get_regs_len = emac_ethtool_get_regs_len,\n\t.get_regs = emac_ethtool_get_regs,\n\n\t.nway_reset = emac_ethtool_nway_reset,\n\n\t.get_ringparam = emac_ethtool_get_ringparam,\n\t.get_pauseparam = emac_ethtool_get_pauseparam,\n\n\t.get_strings = emac_ethtool_get_strings,\n\t.get_sset_count = emac_ethtool_get_sset_count,\n\t.get_ethtool_stats = emac_ethtool_get_ethtool_stats,\n\n\t.get_link = ethtool_op_get_link,\n\t.get_link_ksettings = emac_ethtool_get_link_ksettings,\n\t.set_link_ksettings = emac_ethtool_set_link_ksettings,\n};\n\nstatic int emac_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tstruct mii_ioctl_data *data = if_mii(rq);\n\n\tDBG(dev, \"ioctl %08x\" NL, cmd);\n\n\tif (dev->phy.address < 0)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tdata->phy_id = dev->phy.address;\n\t\tfallthrough;\n\tcase SIOCGMIIREG:\n\t\tdata->val_out = emac_mdio_read(ndev, dev->phy.address,\n\t\t\t\t\t       data->reg_num);\n\t\treturn 0;\n\n\tcase SIOCSMIIREG:\n\t\temac_mdio_write(ndev, dev->phy.address, data->reg_num,\n\t\t\t\tdata->val_in);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstruct emac_depentry {\n\tu32\t\t\tphandle;\n\tstruct device_node\t*node;\n\tstruct platform_device\t*ofdev;\n\tvoid\t\t\t*drvdata;\n};\n\n#define\tEMAC_DEP_MAL_IDX\t0\n#define\tEMAC_DEP_ZMII_IDX\t1\n#define\tEMAC_DEP_RGMII_IDX\t2\n#define\tEMAC_DEP_TAH_IDX\t3\n#define\tEMAC_DEP_MDIO_IDX\t4\n#define\tEMAC_DEP_PREV_IDX\t5\n#define\tEMAC_DEP_COUNT\t\t6\n\nstatic int emac_check_deps(struct emac_instance *dev,\n\t\t\t   struct emac_depentry *deps)\n{\n\tint i, there = 0;\n\tstruct device_node *np;\n\n\tfor (i = 0; i < EMAC_DEP_COUNT; i++) {\n\t\t \n\t\tif (deps[i].phandle == 0) {\n\t\t\tthere++;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (i == EMAC_DEP_PREV_IDX) {\n\t\t\tnp = *(dev->blist - 1);\n\t\t\tif (np == NULL) {\n\t\t\t\tdeps[i].phandle = 0;\n\t\t\t\tthere++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (deps[i].node == NULL)\n\t\t\t\tdeps[i].node = of_node_get(np);\n\t\t}\n\t\tif (deps[i].node == NULL)\n\t\t\tdeps[i].node = of_find_node_by_phandle(deps[i].phandle);\n\t\tif (deps[i].node == NULL)\n\t\t\tcontinue;\n\t\tif (deps[i].ofdev == NULL)\n\t\t\tdeps[i].ofdev = of_find_device_by_node(deps[i].node);\n\t\tif (deps[i].ofdev == NULL)\n\t\t\tcontinue;\n\t\tif (deps[i].drvdata == NULL)\n\t\t\tdeps[i].drvdata = platform_get_drvdata(deps[i].ofdev);\n\t\tif (deps[i].drvdata != NULL)\n\t\t\tthere++;\n\t}\n\treturn there == EMAC_DEP_COUNT;\n}\n\nstatic void emac_put_deps(struct emac_instance *dev)\n{\n\tplatform_device_put(dev->mal_dev);\n\tplatform_device_put(dev->zmii_dev);\n\tplatform_device_put(dev->rgmii_dev);\n\tplatform_device_put(dev->mdio_dev);\n\tplatform_device_put(dev->tah_dev);\n}\n\nstatic int emac_of_bus_notify(struct notifier_block *nb, unsigned long action,\n\t\t\t      void *data)\n{\n\t \n\tif (action == BUS_NOTIFY_BOUND_DRIVER)\n\t\twake_up_all(&emac_probe_wait);\n\treturn 0;\n}\n\nstatic struct notifier_block emac_of_bus_notifier = {\n\t.notifier_call = emac_of_bus_notify\n};\n\nstatic int emac_wait_deps(struct emac_instance *dev)\n{\n\tstruct emac_depentry deps[EMAC_DEP_COUNT];\n\tint i, err;\n\n\tmemset(&deps, 0, sizeof(deps));\n\n\tdeps[EMAC_DEP_MAL_IDX].phandle = dev->mal_ph;\n\tdeps[EMAC_DEP_ZMII_IDX].phandle = dev->zmii_ph;\n\tdeps[EMAC_DEP_RGMII_IDX].phandle = dev->rgmii_ph;\n\tif (dev->tah_ph)\n\t\tdeps[EMAC_DEP_TAH_IDX].phandle = dev->tah_ph;\n\tif (dev->mdio_ph)\n\t\tdeps[EMAC_DEP_MDIO_IDX].phandle = dev->mdio_ph;\n\tif (dev->blist && dev->blist > emac_boot_list)\n\t\tdeps[EMAC_DEP_PREV_IDX].phandle = 0xffffffffu;\n\tbus_register_notifier(&platform_bus_type, &emac_of_bus_notifier);\n\twait_event_timeout(emac_probe_wait,\n\t\t\t   emac_check_deps(dev, deps),\n\t\t\t   EMAC_PROBE_DEP_TIMEOUT);\n\tbus_unregister_notifier(&platform_bus_type, &emac_of_bus_notifier);\n\terr = emac_check_deps(dev, deps) ? 0 : -ENODEV;\n\tfor (i = 0; i < EMAC_DEP_COUNT; i++) {\n\t\tof_node_put(deps[i].node);\n\t\tif (err)\n\t\t\tplatform_device_put(deps[i].ofdev);\n\t}\n\tif (err == 0) {\n\t\tdev->mal_dev = deps[EMAC_DEP_MAL_IDX].ofdev;\n\t\tdev->zmii_dev = deps[EMAC_DEP_ZMII_IDX].ofdev;\n\t\tdev->rgmii_dev = deps[EMAC_DEP_RGMII_IDX].ofdev;\n\t\tdev->tah_dev = deps[EMAC_DEP_TAH_IDX].ofdev;\n\t\tdev->mdio_dev = deps[EMAC_DEP_MDIO_IDX].ofdev;\n\t}\n\tplatform_device_put(deps[EMAC_DEP_PREV_IDX].ofdev);\n\treturn err;\n}\n\nstatic int emac_read_uint_prop(struct device_node *np, const char *name,\n\t\t\t       u32 *val, int fatal)\n{\n\tint len;\n\tconst u32 *prop = of_get_property(np, name, &len);\n\tif (prop == NULL || len < sizeof(u32)) {\n\t\tif (fatal)\n\t\t\tprintk(KERN_ERR \"%pOF: missing %s property\\n\",\n\t\t\t       np, name);\n\t\treturn -ENODEV;\n\t}\n\t*val = *prop;\n\treturn 0;\n}\n\nstatic void emac_adjust_link(struct net_device *ndev)\n{\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tstruct phy_device *phy = dev->phy_dev;\n\n\tdev->phy.autoneg = phy->autoneg;\n\tdev->phy.speed = phy->speed;\n\tdev->phy.duplex = phy->duplex;\n\tdev->phy.pause = phy->pause;\n\tdev->phy.asym_pause = phy->asym_pause;\n\tethtool_convert_link_mode_to_legacy_u32(&dev->phy.advertising,\n\t\t\t\t\t\tphy->advertising);\n}\n\nstatic int emac_mii_bus_read(struct mii_bus *bus, int addr, int regnum)\n{\n\tint ret = emac_mdio_read(bus->priv, addr, regnum);\n\t \n\treturn ret < 0 ? 0xffff : ret;\n}\n\nstatic int emac_mii_bus_write(struct mii_bus *bus, int addr,\n\t\t\t      int regnum, u16 val)\n{\n\temac_mdio_write(bus->priv, addr, regnum, val);\n\treturn 0;\n}\n\nstatic int emac_mii_bus_reset(struct mii_bus *bus)\n{\n\tstruct emac_instance *dev = netdev_priv(bus->priv);\n\n\treturn emac_reset(dev);\n}\n\nstatic int emac_mdio_phy_start_aneg(struct mii_phy *phy,\n\t\t\t\t    struct phy_device *phy_dev)\n{\n\tphy_dev->autoneg = phy->autoneg;\n\tphy_dev->speed = phy->speed;\n\tphy_dev->duplex = phy->duplex;\n\tethtool_convert_legacy_u32_to_link_mode(phy_dev->advertising,\n\t\t\t\t\t\tphy->advertising);\n\treturn phy_start_aneg(phy_dev);\n}\n\nstatic int emac_mdio_setup_aneg(struct mii_phy *phy, u32 advertise)\n{\n\tstruct net_device *ndev = phy->dev;\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\n\tphy->autoneg = AUTONEG_ENABLE;\n\tphy->advertising = advertise;\n\treturn emac_mdio_phy_start_aneg(phy, dev->phy_dev);\n}\n\nstatic int emac_mdio_setup_forced(struct mii_phy *phy, int speed, int fd)\n{\n\tstruct net_device *ndev = phy->dev;\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\n\tphy->autoneg = AUTONEG_DISABLE;\n\tphy->speed = speed;\n\tphy->duplex = fd;\n\treturn emac_mdio_phy_start_aneg(phy, dev->phy_dev);\n}\n\nstatic int emac_mdio_poll_link(struct mii_phy *phy)\n{\n\tstruct net_device *ndev = phy->dev;\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tint res;\n\n\tres = phy_read_status(dev->phy_dev);\n\tif (res) {\n\t\tdev_err(&dev->ofdev->dev, \"link update failed (%d).\", res);\n\t\treturn ethtool_op_get_link(ndev);\n\t}\n\n\treturn dev->phy_dev->link;\n}\n\nstatic int emac_mdio_read_link(struct mii_phy *phy)\n{\n\tstruct net_device *ndev = phy->dev;\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\tstruct phy_device *phy_dev = dev->phy_dev;\n\tint res;\n\n\tres = phy_read_status(phy_dev);\n\tif (res)\n\t\treturn res;\n\n\tphy->speed = phy_dev->speed;\n\tphy->duplex = phy_dev->duplex;\n\tphy->pause = phy_dev->pause;\n\tphy->asym_pause = phy_dev->asym_pause;\n\treturn 0;\n}\n\nstatic int emac_mdio_init_phy(struct mii_phy *phy)\n{\n\tstruct net_device *ndev = phy->dev;\n\tstruct emac_instance *dev = netdev_priv(ndev);\n\n\tphy_start(dev->phy_dev);\n\treturn phy_init_hw(dev->phy_dev);\n}\n\nstatic const struct mii_phy_ops emac_dt_mdio_phy_ops = {\n\t.init\t\t= emac_mdio_init_phy,\n\t.setup_aneg\t= emac_mdio_setup_aneg,\n\t.setup_forced\t= emac_mdio_setup_forced,\n\t.poll_link\t= emac_mdio_poll_link,\n\t.read_link\t= emac_mdio_read_link,\n};\n\nstatic int emac_dt_mdio_probe(struct emac_instance *dev)\n{\n\tstruct device_node *mii_np;\n\tint res;\n\n\tmii_np = of_get_child_by_name(dev->ofdev->dev.of_node, \"mdio\");\n\tif (!mii_np) {\n\t\tdev_err(&dev->ofdev->dev, \"no mdio definition found.\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!of_device_is_available(mii_np)) {\n\t\tres = -ENODEV;\n\t\tgoto put_node;\n\t}\n\n\tdev->mii_bus = devm_mdiobus_alloc(&dev->ofdev->dev);\n\tif (!dev->mii_bus) {\n\t\tres = -ENOMEM;\n\t\tgoto put_node;\n\t}\n\n\tdev->mii_bus->priv = dev->ndev;\n\tdev->mii_bus->parent = dev->ndev->dev.parent;\n\tdev->mii_bus->name = \"emac_mdio\";\n\tdev->mii_bus->read = &emac_mii_bus_read;\n\tdev->mii_bus->write = &emac_mii_bus_write;\n\tdev->mii_bus->reset = &emac_mii_bus_reset;\n\tsnprintf(dev->mii_bus->id, MII_BUS_ID_SIZE, \"%s\", dev->ofdev->name);\n\tres = of_mdiobus_register(dev->mii_bus, mii_np);\n\tif (res) {\n\t\tdev_err(&dev->ofdev->dev, \"cannot register MDIO bus %s (%d)\",\n\t\t\tdev->mii_bus->name, res);\n\t}\n\n put_node:\n\tof_node_put(mii_np);\n\treturn res;\n}\n\nstatic int emac_dt_phy_connect(struct emac_instance *dev,\n\t\t\t       struct device_node *phy_handle)\n{\n\tdev->phy.def = devm_kzalloc(&dev->ofdev->dev, sizeof(*dev->phy.def),\n\t\t\t\t    GFP_KERNEL);\n\tif (!dev->phy.def)\n\t\treturn -ENOMEM;\n\n\tdev->phy_dev = of_phy_connect(dev->ndev, phy_handle, &emac_adjust_link,\n\t\t\t\t      0, dev->phy_mode);\n\tif (!dev->phy_dev) {\n\t\tdev_err(&dev->ofdev->dev, \"failed to connect to PHY.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev->phy.def->phy_id = dev->phy_dev->drv->phy_id;\n\tdev->phy.def->phy_id_mask = dev->phy_dev->drv->phy_id_mask;\n\tdev->phy.def->name = dev->phy_dev->drv->name;\n\tdev->phy.def->ops = &emac_dt_mdio_phy_ops;\n\tethtool_convert_link_mode_to_legacy_u32(&dev->phy.features,\n\t\t\t\t\t\tdev->phy_dev->supported);\n\tdev->phy.address = dev->phy_dev->mdio.addr;\n\tdev->phy.mode = dev->phy_dev->interface;\n\treturn 0;\n}\n\nstatic int emac_dt_phy_probe(struct emac_instance *dev)\n{\n\tstruct device_node *np = dev->ofdev->dev.of_node;\n\tstruct device_node *phy_handle;\n\tint res = 1;\n\n\tphy_handle = of_parse_phandle(np, \"phy-handle\", 0);\n\n\tif (phy_handle) {\n\t\tres = emac_dt_mdio_probe(dev);\n\t\tif (!res) {\n\t\t\tres = emac_dt_phy_connect(dev, phy_handle);\n\t\t\tif (res)\n\t\t\t\tmdiobus_unregister(dev->mii_bus);\n\t\t}\n\t}\n\n\tof_node_put(phy_handle);\n\treturn res;\n}\n\nstatic int emac_init_phy(struct emac_instance *dev)\n{\n\tstruct device_node *np = dev->ofdev->dev.of_node;\n\tstruct net_device *ndev = dev->ndev;\n\tu32 phy_map, adv;\n\tint i;\n\n\tdev->phy.dev = ndev;\n\tdev->phy.mode = dev->phy_mode;\n\n\t \n\tif ((dev->phy_address == 0xffffffff && dev->phy_map == 0xffffffff) ||\n\t    of_phy_is_fixed_link(np)) {\n\t\temac_reset(dev);\n\n\t\t \n\t\tdev->phy.address = -1;\n\t\tdev->phy.features = SUPPORTED_MII;\n\t\tif (emac_phy_supports_gige(dev->phy_mode))\n\t\t\tdev->phy.features |= SUPPORTED_1000baseT_Full;\n\t\telse\n\t\t\tdev->phy.features |= SUPPORTED_100baseT_Full;\n\t\tdev->phy.pause = 1;\n\n\t\tif (of_phy_is_fixed_link(np)) {\n\t\t\tint res = emac_dt_mdio_probe(dev);\n\n\t\t\tif (res)\n\t\t\t\treturn res;\n\n\t\t\tres = of_phy_register_fixed_link(np);\n\t\t\tdev->phy_dev = of_phy_find_device(np);\n\t\t\tif (res || !dev->phy_dev) {\n\t\t\t\tmdiobus_unregister(dev->mii_bus);\n\t\t\t\treturn res ? res : -EINVAL;\n\t\t\t}\n\t\t\temac_adjust_link(dev->ndev);\n\t\t\tput_device(&dev->phy_dev->mdio.dev);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&emac_phy_map_lock);\n\tphy_map = dev->phy_map | busy_phy_map;\n\n\tDBG(dev, \"PHY maps %08x %08x\" NL, dev->phy_map, busy_phy_map);\n\n\tdev->phy.mdio_read = emac_mdio_read;\n\tdev->phy.mdio_write = emac_mdio_write;\n\n\t \n#ifdef CONFIG_PPC_DCR_NATIVE\n\tif (emac_has_feature(dev, EMAC_FTR_440GX_PHY_CLK_FIX))\n\t\tdcri_clrset(SDR0, SDR0_MFR, 0, SDR0_MFR_ECS);\n#endif\n\t \n\temac_rx_clk_tx(dev);\n\n\t \n#ifdef CONFIG_PPC_DCR_NATIVE\n\tif (emac_has_feature(dev, EMAC_FTR_440GX_PHY_CLK_FIX))\n\t\tdcri_clrset(SDR0, SDR0_MFR, 0, SDR0_MFR_ECS);\n#endif\n\t \n\tif (emac_phy_gpcs(dev->phy.mode)) {\n\t\t \n\t\tdev->phy.gpcs_address = dev->gpcs_address;\n\t\tif (dev->phy.gpcs_address == 0xffffffff)\n\t\t\tdev->phy.address = dev->cell_index;\n\t}\n\n\temac_configure(dev);\n\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_RGMII)) {\n\t\tint res = emac_dt_phy_probe(dev);\n\n\t\tswitch (res) {\n\t\tcase 1:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase 0:\n\t\t\tmutex_unlock(&emac_phy_map_lock);\n\t\t\tgoto init_phy;\n\n\t\tdefault:\n\t\t\tmutex_unlock(&emac_phy_map_lock);\n\t\t\tdev_err(&dev->ofdev->dev, \"failed to attach dt phy (%d).\\n\",\n\t\t\t\tres);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tif (dev->phy_address != 0xffffffff)\n\t\tphy_map = ~(1 << dev->phy_address);\n\n\tfor (i = 0; i < 0x20; phy_map >>= 1, ++i)\n\t\tif (!(phy_map & 1)) {\n\t\t\tint r;\n\t\t\tbusy_phy_map |= 1 << i;\n\n\t\t\t \n\t\t\tr = emac_mdio_read(dev->ndev, i, MII_BMCR);\n\t\t\tif (r == 0xffff || r < 0)\n\t\t\t\tcontinue;\n\t\t\tif (!emac_mii_phy_probe(&dev->phy, i))\n\t\t\t\tbreak;\n\t\t}\n\n\t \n#ifdef CONFIG_PPC_DCR_NATIVE\n\tif (emac_has_feature(dev, EMAC_FTR_440GX_PHY_CLK_FIX))\n\t\tdcri_clrset(SDR0, SDR0_MFR, SDR0_MFR_ECS, 0);\n#endif\n\tmutex_unlock(&emac_phy_map_lock);\n\tif (i == 0x20) {\n\t\tprintk(KERN_WARNING \"%pOF: can't find PHY!\\n\", np);\n\t\treturn -ENXIO;\n\t}\n\n init_phy:\n\t \n\tif (dev->phy.def->ops->init)\n\t\tdev->phy.def->ops->init(&dev->phy);\n\n\t \n\tdev->phy.def->features &= ~dev->phy_feat_exc;\n\tdev->phy.features &= ~dev->phy_feat_exc;\n\n\t \n\tif (dev->phy.features & SUPPORTED_Autoneg) {\n\t\tadv = dev->phy.features;\n\t\tif (!emac_has_feature(dev, EMAC_FTR_NO_FLOW_CONTROL_40x))\n\t\t\tadv |= ADVERTISED_Pause | ADVERTISED_Asym_Pause;\n\t\t \n\t\tdev->phy.def->ops->setup_aneg(&dev->phy, adv);\n\t} else {\n\t\tu32 f = dev->phy.def->features;\n\t\tint speed = SPEED_10, fd = DUPLEX_HALF;\n\n\t\t \n\t\tif (f & SUPPORTED_1000baseT_Full) {\n\t\t\tspeed = SPEED_1000;\n\t\t\tfd = DUPLEX_FULL;\n\t\t} else if (f & SUPPORTED_1000baseT_Half)\n\t\t\tspeed = SPEED_1000;\n\t\telse if (f & SUPPORTED_100baseT_Full) {\n\t\t\tspeed = SPEED_100;\n\t\t\tfd = DUPLEX_FULL;\n\t\t} else if (f & SUPPORTED_100baseT_Half)\n\t\t\tspeed = SPEED_100;\n\t\telse if (f & SUPPORTED_10baseT_Full)\n\t\t\tfd = DUPLEX_FULL;\n\n\t\t \n\t\tdev->phy.def->ops->setup_forced(&dev->phy, speed, fd);\n\t}\n\treturn 0;\n}\n\nstatic int emac_init_config(struct emac_instance *dev)\n{\n\tstruct device_node *np = dev->ofdev->dev.of_node;\n\tint err;\n\n\t \n\tif (emac_read_uint_prop(np, \"mal-device\", &dev->mal_ph, 1))\n\t\treturn -ENXIO;\n\tif (emac_read_uint_prop(np, \"mal-tx-channel\", &dev->mal_tx_chan, 1))\n\t\treturn -ENXIO;\n\tif (emac_read_uint_prop(np, \"mal-rx-channel\", &dev->mal_rx_chan, 1))\n\t\treturn -ENXIO;\n\tif (emac_read_uint_prop(np, \"cell-index\", &dev->cell_index, 1))\n\t\treturn -ENXIO;\n\tif (emac_read_uint_prop(np, \"max-frame-size\", &dev->max_mtu, 0))\n\t\tdev->max_mtu = ETH_DATA_LEN;\n\tif (emac_read_uint_prop(np, \"rx-fifo-size\", &dev->rx_fifo_size, 0))\n\t\tdev->rx_fifo_size = 2048;\n\tif (emac_read_uint_prop(np, \"tx-fifo-size\", &dev->tx_fifo_size, 0))\n\t\tdev->tx_fifo_size = 2048;\n\tif (emac_read_uint_prop(np, \"rx-fifo-size-gige\", &dev->rx_fifo_size_gige, 0))\n\t\tdev->rx_fifo_size_gige = dev->rx_fifo_size;\n\tif (emac_read_uint_prop(np, \"tx-fifo-size-gige\", &dev->tx_fifo_size_gige, 0))\n\t\tdev->tx_fifo_size_gige = dev->tx_fifo_size;\n\tif (emac_read_uint_prop(np, \"phy-address\", &dev->phy_address, 0))\n\t\tdev->phy_address = 0xffffffff;\n\tif (emac_read_uint_prop(np, \"phy-map\", &dev->phy_map, 0))\n\t\tdev->phy_map = 0xffffffff;\n\tif (emac_read_uint_prop(np, \"gpcs-address\", &dev->gpcs_address, 0))\n\t\tdev->gpcs_address = 0xffffffff;\n\tif (emac_read_uint_prop(np->parent, \"clock-frequency\", &dev->opb_bus_freq, 1))\n\t\treturn -ENXIO;\n\tif (emac_read_uint_prop(np, \"tah-device\", &dev->tah_ph, 0))\n\t\tdev->tah_ph = 0;\n\tif (emac_read_uint_prop(np, \"tah-channel\", &dev->tah_port, 0))\n\t\tdev->tah_port = 0;\n\tif (emac_read_uint_prop(np, \"mdio-device\", &dev->mdio_ph, 0))\n\t\tdev->mdio_ph = 0;\n\tif (emac_read_uint_prop(np, \"zmii-device\", &dev->zmii_ph, 0))\n\t\tdev->zmii_ph = 0;\n\tif (emac_read_uint_prop(np, \"zmii-channel\", &dev->zmii_port, 0))\n\t\tdev->zmii_port = 0xffffffff;\n\tif (emac_read_uint_prop(np, \"rgmii-device\", &dev->rgmii_ph, 0))\n\t\tdev->rgmii_ph = 0;\n\tif (emac_read_uint_prop(np, \"rgmii-channel\", &dev->rgmii_port, 0))\n\t\tdev->rgmii_port = 0xffffffff;\n\tif (emac_read_uint_prop(np, \"fifo-entry-size\", &dev->fifo_entry_size, 0))\n\t\tdev->fifo_entry_size = 16;\n\tif (emac_read_uint_prop(np, \"mal-burst-size\", &dev->mal_burst_size, 0))\n\t\tdev->mal_burst_size = 256;\n\n\t \n\terr = of_get_phy_mode(np, &dev->phy_mode);\n\tif (err)\n\t\tdev->phy_mode = PHY_INTERFACE_MODE_NA;\n\n\t \n\tif (of_device_is_compatible(np, \"ibm,emac4sync\")) {\n\t\tdev->features |= (EMAC_FTR_EMAC4 | EMAC_FTR_EMAC4SYNC);\n\t\tif (of_device_is_compatible(np, \"ibm,emac-460ex\") ||\n\t\t    of_device_is_compatible(np, \"ibm,emac-460gt\"))\n\t\t\tdev->features |= EMAC_FTR_460EX_PHY_CLK_FIX;\n\t\tif (of_device_is_compatible(np, \"ibm,emac-405ex\") ||\n\t\t    of_device_is_compatible(np, \"ibm,emac-405exr\"))\n\t\t\tdev->features |= EMAC_FTR_440EP_PHY_CLK_FIX;\n\t\tif (of_device_is_compatible(np, \"ibm,emac-apm821xx\")) {\n\t\t\tdev->features |= (EMAC_APM821XX_REQ_JUMBO_FRAME_SIZE |\n\t\t\t\t\t  EMAC_FTR_APM821XX_NO_HALF_DUPLEX |\n\t\t\t\t\t  EMAC_FTR_460EX_PHY_CLK_FIX);\n\t\t}\n\t} else if (of_device_is_compatible(np, \"ibm,emac4\")) {\n\t\tdev->features |= EMAC_FTR_EMAC4;\n\t\tif (of_device_is_compatible(np, \"ibm,emac-440gx\"))\n\t\t\tdev->features |= EMAC_FTR_440GX_PHY_CLK_FIX;\n\t} else {\n\t\tif (of_device_is_compatible(np, \"ibm,emac-440ep\") ||\n\t\t    of_device_is_compatible(np, \"ibm,emac-440gr\"))\n\t\t\tdev->features |= EMAC_FTR_440EP_PHY_CLK_FIX;\n\t\tif (of_device_is_compatible(np, \"ibm,emac-405ez\")) {\n#ifdef CONFIG_IBM_EMAC_NO_FLOW_CTRL\n\t\t\tdev->features |= EMAC_FTR_NO_FLOW_CONTROL_40x;\n#else\n\t\t\tprintk(KERN_ERR \"%pOF: Flow control not disabled!\\n\",\n\t\t\t\t\tnp);\n\t\t\treturn -ENXIO;\n#endif\n\t\t}\n\n\t}\n\n\t \n\tif (of_property_read_bool(np, \"has-inverted-stacr-oc\"))\n\t\tdev->features |= EMAC_FTR_STACR_OC_INVERT;\n\tif (of_property_read_bool(np, \"has-new-stacr-staopc\"))\n\t\tdev->features |= EMAC_FTR_HAS_NEW_STACR;\n\n\t \n\tif (of_device_is_compatible(np, \"ibm,emac-axon\"))\n\t\tdev->features |= EMAC_FTR_HAS_NEW_STACR |\n\t\t\tEMAC_FTR_STACR_OC_INVERT;\n\n\t \n\tif (dev->tah_ph != 0) {\n#ifdef CONFIG_IBM_EMAC_TAH\n\t\tdev->features |= EMAC_FTR_HAS_TAH;\n#else\n\t\tprintk(KERN_ERR \"%pOF: TAH support not enabled !\\n\", np);\n\t\treturn -ENXIO;\n#endif\n\t}\n\n\tif (dev->zmii_ph != 0) {\n#ifdef CONFIG_IBM_EMAC_ZMII\n\t\tdev->features |= EMAC_FTR_HAS_ZMII;\n#else\n\t\tprintk(KERN_ERR \"%pOF: ZMII support not enabled !\\n\", np);\n\t\treturn -ENXIO;\n#endif\n\t}\n\n\tif (dev->rgmii_ph != 0) {\n#ifdef CONFIG_IBM_EMAC_RGMII\n\t\tdev->features |= EMAC_FTR_HAS_RGMII;\n#else\n\t\tprintk(KERN_ERR \"%pOF: RGMII support not enabled !\\n\", np);\n\t\treturn -ENXIO;\n#endif\n\t}\n\n\t \n\terr = of_get_ethdev_address(np, dev->ndev);\n\tif (err)\n\t\treturn dev_err_probe(&dev->ofdev->dev, err,\n\t\t\t\t     \"Can't get valid [local-]mac-address from OF !\\n\");\n\n\t \n\tif (emac_has_feature(dev, EMAC_FTR_EMAC4SYNC)) {\n\t\tdev->xaht_slots_shift = EMAC4SYNC_XAHT_SLOTS_SHIFT;\n\t\tdev->xaht_width_shift = EMAC4SYNC_XAHT_WIDTH_SHIFT;\n\t} else {\n\t\tdev->xaht_slots_shift = EMAC4_XAHT_SLOTS_SHIFT;\n\t\tdev->xaht_width_shift = EMAC4_XAHT_WIDTH_SHIFT;\n\t}\n\n\t \n\tif (WARN_ON(EMAC_XAHT_REGS(dev) > EMAC_XAHT_MAX_REGS))\n\t\treturn -ENXIO;\n\n\tDBG(dev, \"features     : 0x%08x / 0x%08x\\n\", dev->features, EMAC_FTRS_POSSIBLE);\n\tDBG(dev, \"tx_fifo_size : %d (%d gige)\\n\", dev->tx_fifo_size, dev->tx_fifo_size_gige);\n\tDBG(dev, \"rx_fifo_size : %d (%d gige)\\n\", dev->rx_fifo_size, dev->rx_fifo_size_gige);\n\tDBG(dev, \"max_mtu      : %d\\n\", dev->max_mtu);\n\tDBG(dev, \"OPB freq     : %d\\n\", dev->opb_bus_freq);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops emac_netdev_ops = {\n\t.ndo_open\t\t= emac_open,\n\t.ndo_stop\t\t= emac_close,\n\t.ndo_get_stats\t\t= emac_stats,\n\t.ndo_set_rx_mode\t= emac_set_multicast_list,\n\t.ndo_eth_ioctl\t\t= emac_ioctl,\n\t.ndo_tx_timeout\t\t= emac_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= emac_set_mac_address,\n\t.ndo_start_xmit\t\t= emac_start_xmit,\n};\n\nstatic const struct net_device_ops emac_gige_netdev_ops = {\n\t.ndo_open\t\t= emac_open,\n\t.ndo_stop\t\t= emac_close,\n\t.ndo_get_stats\t\t= emac_stats,\n\t.ndo_set_rx_mode\t= emac_set_multicast_list,\n\t.ndo_eth_ioctl\t\t= emac_ioctl,\n\t.ndo_tx_timeout\t\t= emac_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= emac_set_mac_address,\n\t.ndo_start_xmit\t\t= emac_start_xmit_sg,\n\t.ndo_change_mtu\t\t= emac_change_mtu,\n};\n\nstatic int emac_probe(struct platform_device *ofdev)\n{\n\tstruct net_device *ndev;\n\tstruct emac_instance *dev;\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct device_node **blist = NULL;\n\tint err, i;\n\n\t \n\tif (of_property_read_bool(np, \"unused\") || !of_device_is_available(np))\n\t\treturn -ENODEV;\n\n\t \n\tfor (i = 0; i < EMAC_BOOT_LIST_SIZE; i++)\n\t\tif (emac_boot_list[i] == np)\n\t\t\tblist = &emac_boot_list[i];\n\n\t \n\terr = -ENOMEM;\n\tndev = alloc_etherdev(sizeof(struct emac_instance));\n\tif (!ndev)\n\t\tgoto err_gone;\n\n\tdev = netdev_priv(ndev);\n\tdev->ndev = ndev;\n\tdev->ofdev = ofdev;\n\tdev->blist = blist;\n\tSET_NETDEV_DEV(ndev, &ofdev->dev);\n\n\t \n\tmutex_init(&dev->mdio_lock);\n\tmutex_init(&dev->link_lock);\n\tspin_lock_init(&dev->lock);\n\tINIT_WORK(&dev->reset_work, emac_reset_work);\n\n\t \n\terr = emac_init_config(dev);\n\tif (err)\n\t\tgoto err_free;\n\n\t \n\tdev->emac_irq = irq_of_parse_and_map(np, 0);\n\tdev->wol_irq = irq_of_parse_and_map(np, 1);\n\tif (!dev->emac_irq) {\n\t\tprintk(KERN_ERR \"%pOF: Can't map main interrupt\\n\", np);\n\t\terr = -ENODEV;\n\t\tgoto err_free;\n\t}\n\tndev->irq = dev->emac_irq;\n\n\t \n\t \n\tdev->emacp = of_iomap(np, 0);\n\tif (dev->emacp == NULL) {\n\t\tprintk(KERN_ERR \"%pOF: Can't map device registers!\\n\", np);\n\t\terr = -ENOMEM;\n\t\tgoto err_irq_unmap;\n\t}\n\n\t \n\terr = emac_wait_deps(dev);\n\tif (err) {\n\t\tprintk(KERN_ERR\n\t\t       \"%pOF: Timeout waiting for dependent devices\\n\", np);\n\t\t \n\t\tgoto err_reg_unmap;\n\t}\n\tdev->mal = platform_get_drvdata(dev->mal_dev);\n\tif (dev->mdio_dev != NULL)\n\t\tdev->mdio_instance = platform_get_drvdata(dev->mdio_dev);\n\n\t \n\tdev->commac.ops = &emac_commac_ops;\n\tdev->commac.dev = dev;\n\tdev->commac.tx_chan_mask = MAL_CHAN_MASK(dev->mal_tx_chan);\n\tdev->commac.rx_chan_mask = MAL_CHAN_MASK(dev->mal_rx_chan);\n\terr = mal_register_commac(dev->mal, &dev->commac);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%pOF: failed to register with mal %pOF!\\n\",\n\t\t       np, dev->mal_dev->dev.of_node);\n\t\tgoto err_rel_deps;\n\t}\n\tdev->rx_skb_size = emac_rx_skb_size(ndev->mtu);\n\tdev->rx_sync_size = emac_rx_sync_size(ndev->mtu);\n\n\t \n\tdev->tx_desc =\n\t    dev->mal->bd_virt + mal_tx_bd_offset(dev->mal, dev->mal_tx_chan);\n\tdev->rx_desc =\n\t    dev->mal->bd_virt + mal_rx_bd_offset(dev->mal, dev->mal_rx_chan);\n\n\tDBG(dev, \"tx_desc %p\" NL, dev->tx_desc);\n\tDBG(dev, \"rx_desc %p\" NL, dev->rx_desc);\n\n\t \n\tmemset(dev->tx_desc, 0, NUM_TX_BUFF * sizeof(struct mal_descriptor));\n\tmemset(dev->rx_desc, 0, NUM_RX_BUFF * sizeof(struct mal_descriptor));\n\tmemset(dev->tx_skb, 0, NUM_TX_BUFF * sizeof(struct sk_buff *));\n\tmemset(dev->rx_skb, 0, NUM_RX_BUFF * sizeof(struct sk_buff *));\n\n\t \n\tif (emac_has_feature(dev, EMAC_FTR_HAS_ZMII) &&\n\t    (err = zmii_attach(dev->zmii_dev, dev->zmii_port, &dev->phy_mode)) != 0)\n\t\tgoto err_unreg_commac;\n\n\t \n\tif (emac_has_feature(dev, EMAC_FTR_HAS_RGMII) &&\n\t    (err = rgmii_attach(dev->rgmii_dev, dev->rgmii_port, dev->phy_mode)) != 0)\n\t\tgoto err_detach_zmii;\n\n\t \n\tif (emac_has_feature(dev, EMAC_FTR_HAS_TAH) &&\n\t    (err = tah_attach(dev->tah_dev, dev->tah_port)) != 0)\n\t\tgoto err_detach_rgmii;\n\n\t \n\tdev->phy.speed = SPEED_100;\n\tdev->phy.duplex = DUPLEX_FULL;\n\tdev->phy.autoneg = AUTONEG_DISABLE;\n\tdev->phy.pause = dev->phy.asym_pause = 0;\n\tdev->stop_timeout = STOP_TIMEOUT_100;\n\tINIT_DELAYED_WORK(&dev->link_work, emac_link_timer);\n\n\t \n\tif (emac_has_feature(dev, EMAC_FTR_APM821XX_NO_HALF_DUPLEX)) {\n\t\tdev->phy_feat_exc = (SUPPORTED_1000baseT_Half |\n\t\t\t\t     SUPPORTED_100baseT_Half |\n\t\t\t\t     SUPPORTED_10baseT_Half);\n\t}\n\n\t \n\terr = emac_init_phy(dev);\n\tif (err != 0)\n\t\tgoto err_detach_tah;\n\n\tif (dev->tah_dev) {\n\t\tndev->hw_features = NETIF_F_IP_CSUM | NETIF_F_SG;\n\t\tndev->features |= ndev->hw_features | NETIF_F_RXCSUM;\n\t}\n\tndev->watchdog_timeo = 5 * HZ;\n\tif (emac_phy_supports_gige(dev->phy_mode)) {\n\t\tndev->netdev_ops = &emac_gige_netdev_ops;\n\t\tdev->commac.ops = &emac_commac_sg_ops;\n\t} else\n\t\tndev->netdev_ops = &emac_netdev_ops;\n\tndev->ethtool_ops = &emac_ethtool_ops;\n\n\t \n\tndev->min_mtu = EMAC_MIN_MTU;\n\tndev->max_mtu = dev->max_mtu;\n\n\tnetif_carrier_off(ndev);\n\n\terr = register_netdev(ndev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%pOF: failed to register net device (%d)!\\n\",\n\t\t       np, err);\n\t\tgoto err_detach_tah;\n\t}\n\n\t \n\twmb();\n\tplatform_set_drvdata(ofdev, dev);\n\n\t \n\twake_up_all(&emac_probe_wait);\n\n\n\tprintk(KERN_INFO \"%s: EMAC-%d %pOF, MAC %pM\\n\",\n\t       ndev->name, dev->cell_index, np, ndev->dev_addr);\n\n\tif (dev->phy_mode == PHY_INTERFACE_MODE_SGMII)\n\t\tprintk(KERN_NOTICE \"%s: in SGMII mode\\n\", ndev->name);\n\n\tif (dev->phy.address >= 0)\n\t\tprintk(\"%s: found %s PHY (0x%02x)\\n\", ndev->name,\n\t\t       dev->phy.def->name, dev->phy.address);\n\n\t \n\treturn 0;\n\n\t \n\n err_detach_tah:\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_TAH))\n\t\ttah_detach(dev->tah_dev, dev->tah_port);\n err_detach_rgmii:\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_RGMII))\n\t\trgmii_detach(dev->rgmii_dev, dev->rgmii_port);\n err_detach_zmii:\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_ZMII))\n\t\tzmii_detach(dev->zmii_dev, dev->zmii_port);\n err_unreg_commac:\n\tmal_unregister_commac(dev->mal, &dev->commac);\n err_rel_deps:\n\temac_put_deps(dev);\n err_reg_unmap:\n\tiounmap(dev->emacp);\n err_irq_unmap:\n\tif (dev->wol_irq)\n\t\tirq_dispose_mapping(dev->wol_irq);\n\tif (dev->emac_irq)\n\t\tirq_dispose_mapping(dev->emac_irq);\n err_free:\n\tfree_netdev(ndev);\n err_gone:\n\t \n\tif (blist) {\n\t\t*blist = NULL;\n\t\twake_up_all(&emac_probe_wait);\n\t}\n\treturn err;\n}\n\nstatic int emac_remove(struct platform_device *ofdev)\n{\n\tstruct emac_instance *dev = platform_get_drvdata(ofdev);\n\n\tDBG(dev, \"remove\" NL);\n\n\tunregister_netdev(dev->ndev);\n\n\tcancel_work_sync(&dev->reset_work);\n\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_TAH))\n\t\ttah_detach(dev->tah_dev, dev->tah_port);\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_RGMII))\n\t\trgmii_detach(dev->rgmii_dev, dev->rgmii_port);\n\tif (emac_has_feature(dev, EMAC_FTR_HAS_ZMII))\n\t\tzmii_detach(dev->zmii_dev, dev->zmii_port);\n\n\tif (dev->phy_dev)\n\t\tphy_disconnect(dev->phy_dev);\n\n\tif (dev->mii_bus)\n\t\tmdiobus_unregister(dev->mii_bus);\n\n\tbusy_phy_map &= ~(1 << dev->phy.address);\n\tDBG(dev, \"busy_phy_map now %#x\" NL, busy_phy_map);\n\n\tmal_unregister_commac(dev->mal, &dev->commac);\n\temac_put_deps(dev);\n\n\tiounmap(dev->emacp);\n\n\tif (dev->wol_irq)\n\t\tirq_dispose_mapping(dev->wol_irq);\n\tif (dev->emac_irq)\n\t\tirq_dispose_mapping(dev->emac_irq);\n\n\tfree_netdev(dev->ndev);\n\n\treturn 0;\n}\n\n \nstatic const struct of_device_id emac_match[] =\n{\n\t{\n\t\t.type\t\t= \"network\",\n\t\t.compatible\t= \"ibm,emac\",\n\t},\n\t{\n\t\t.type\t\t= \"network\",\n\t\t.compatible\t= \"ibm,emac4\",\n\t},\n\t{\n\t\t.type\t\t= \"network\",\n\t\t.compatible\t= \"ibm,emac4sync\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, emac_match);\n\nstatic struct platform_driver emac_driver = {\n\t.driver = {\n\t\t.name = \"emac\",\n\t\t.of_match_table = emac_match,\n\t},\n\t.probe = emac_probe,\n\t.remove = emac_remove,\n};\n\nstatic void __init emac_make_bootlist(void)\n{\n\tstruct device_node *np = NULL;\n\tint j, max, i = 0;\n\tint cell_indices[EMAC_BOOT_LIST_SIZE];\n\n\t \n\twhile((np = of_find_all_nodes(np)) != NULL) {\n\t\tconst u32 *idx;\n\n\t\tif (of_match_node(emac_match, np) == NULL)\n\t\t\tcontinue;\n\t\tif (of_property_read_bool(np, \"unused\"))\n\t\t\tcontinue;\n\t\tidx = of_get_property(np, \"cell-index\", NULL);\n\t\tif (idx == NULL)\n\t\t\tcontinue;\n\t\tcell_indices[i] = *idx;\n\t\temac_boot_list[i++] = of_node_get(np);\n\t\tif (i >= EMAC_BOOT_LIST_SIZE) {\n\t\t\tof_node_put(np);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmax = i;\n\n\t \n\tfor (i = 0; max > 1 && (i < (max - 1)); i++)\n\t\tfor (j = i; j < max; j++) {\n\t\t\tif (cell_indices[i] > cell_indices[j]) {\n\t\t\t\tswap(emac_boot_list[i], emac_boot_list[j]);\n\t\t\t\tswap(cell_indices[i], cell_indices[j]);\n\t\t\t}\n\t\t}\n}\n\nstatic int __init emac_init(void)\n{\n\tint rc;\n\n\tprintk(KERN_INFO DRV_DESC \", version \" DRV_VERSION \"\\n\");\n\n\t \n\temac_make_bootlist();\n\n\t \n\trc = mal_init();\n\tif (rc)\n\t\tgoto err;\n\trc = zmii_init();\n\tif (rc)\n\t\tgoto err_mal;\n\trc = rgmii_init();\n\tif (rc)\n\t\tgoto err_zmii;\n\trc = tah_init();\n\tif (rc)\n\t\tgoto err_rgmii;\n\trc = platform_driver_register(&emac_driver);\n\tif (rc)\n\t\tgoto err_tah;\n\n\treturn 0;\n\n err_tah:\n\ttah_exit();\n err_rgmii:\n\trgmii_exit();\n err_zmii:\n\tzmii_exit();\n err_mal:\n\tmal_exit();\n err:\n\treturn rc;\n}\n\nstatic void __exit emac_exit(void)\n{\n\tint i;\n\n\tplatform_driver_unregister(&emac_driver);\n\n\ttah_exit();\n\trgmii_exit();\n\tzmii_exit();\n\tmal_exit();\n\n\t \n\tfor (i = 0; i < EMAC_BOOT_LIST_SIZE; i++)\n\t\tof_node_put(emac_boot_list[i]);\n}\n\nmodule_init(emac_init);\nmodule_exit(emac_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}