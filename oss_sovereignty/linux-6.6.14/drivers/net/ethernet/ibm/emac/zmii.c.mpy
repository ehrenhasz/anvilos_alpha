{
  "module_name": "zmii.c",
  "hash_id": "f71a8c66bbfa42d4df12ecf4710b864a2fd01c1b6260dccc4d55fbe5eb68fa2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ibm/emac/zmii.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/ethtool.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <asm/io.h>\n\n#include \"emac.h\"\n#include \"core.h\"\n\n \n#define ZMII_FER_MDI(idx)\t(0x80000000 >> ((idx) * 4))\n#define ZMII_FER_MDI_ALL\t(ZMII_FER_MDI(0) | ZMII_FER_MDI(1) | \\\n\t\t\t\t ZMII_FER_MDI(2) | ZMII_FER_MDI(3))\n\n#define ZMII_FER_SMII(idx)\t(0x40000000 >> ((idx) * 4))\n#define ZMII_FER_RMII(idx)\t(0x20000000 >> ((idx) * 4))\n#define ZMII_FER_MII(idx)\t(0x10000000 >> ((idx) * 4))\n\n \n#define ZMII_SSR_SCI(idx)\t(0x40000000 >> ((idx) * 4))\n#define ZMII_SSR_FSS(idx)\t(0x20000000 >> ((idx) * 4))\n#define ZMII_SSR_SP(idx)\t(0x10000000 >> ((idx) * 4))\n\n \nstatic inline int zmii_valid_mode(int mode)\n{\n\treturn  mode == PHY_INTERFACE_MODE_MII ||\n\t\tmode == PHY_INTERFACE_MODE_RMII ||\n\t\tmode == PHY_INTERFACE_MODE_SMII ||\n\t\tmode == PHY_INTERFACE_MODE_NA;\n}\n\nstatic inline const char *zmii_mode_name(int mode)\n{\n\tswitch (mode) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\treturn \"MII\";\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\treturn \"RMII\";\n\tcase PHY_INTERFACE_MODE_SMII:\n\t\treturn \"SMII\";\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic inline u32 zmii_mode_mask(int mode, int input)\n{\n\tswitch (mode) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\treturn ZMII_FER_MII(input);\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\treturn ZMII_FER_RMII(input);\n\tcase PHY_INTERFACE_MODE_SMII:\n\t\treturn ZMII_FER_SMII(input);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint zmii_attach(struct platform_device *ofdev, int input,\n\t\tphy_interface_t *mode)\n{\n\tstruct zmii_instance *dev = platform_get_drvdata(ofdev);\n\tstruct zmii_regs __iomem *p = dev->base;\n\n\tZMII_DBG(dev, \"init(%d, %d)\" NL, input, *mode);\n\n\tif (!zmii_valid_mode(*mode)) {\n\t\t \n\t\tdev->users++;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&dev->lock);\n\n\t \n\tif (dev->mode == PHY_INTERFACE_MODE_NA) {\n\t\tif (*mode == PHY_INTERFACE_MODE_NA) {\n\t\t\tu32 r = dev->fer_save;\n\n\t\t\tZMII_DBG(dev, \"autodetecting mode, FER = 0x%08x\" NL, r);\n\n\t\t\tif (r & (ZMII_FER_MII(0) | ZMII_FER_MII(1)))\n\t\t\t\tdev->mode = PHY_INTERFACE_MODE_MII;\n\t\t\telse if (r & (ZMII_FER_RMII(0) | ZMII_FER_RMII(1)))\n\t\t\t\tdev->mode = PHY_INTERFACE_MODE_RMII;\n\t\t\telse\n\t\t\t\tdev->mode = PHY_INTERFACE_MODE_SMII;\n\t\t} else {\n\t\t\tdev->mode = *mode;\n\t\t}\n\t\tprintk(KERN_NOTICE \"%pOF: bridge in %s mode\\n\",\n\t\t       ofdev->dev.of_node,\n\t\t       zmii_mode_name(dev->mode));\n\t} else {\n\t\t \n\t\tif (*mode != PHY_INTERFACE_MODE_NA && *mode != dev->mode) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"%pOF: invalid mode %d specified for input %d\\n\",\n\t\t\t       ofdev->dev.of_node, *mode, input);\n\t\t\tmutex_unlock(&dev->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\t*mode = dev->mode;\n\n\t \n\tout_be32(&p->fer, in_be32(&p->fer) | zmii_mode_mask(dev->mode, input));\n\t++dev->users;\n\n\tmutex_unlock(&dev->lock);\n\n\treturn 0;\n}\n\nvoid zmii_get_mdio(struct platform_device *ofdev, int input)\n{\n\tstruct zmii_instance *dev = platform_get_drvdata(ofdev);\n\tu32 fer;\n\n\tZMII_DBG2(dev, \"get_mdio(%d)\" NL, input);\n\n\tmutex_lock(&dev->lock);\n\n\tfer = in_be32(&dev->base->fer) & ~ZMII_FER_MDI_ALL;\n\tout_be32(&dev->base->fer, fer | ZMII_FER_MDI(input));\n}\n\nvoid zmii_put_mdio(struct platform_device *ofdev, int input)\n{\n\tstruct zmii_instance *dev = platform_get_drvdata(ofdev);\n\n\tZMII_DBG2(dev, \"put_mdio(%d)\" NL, input);\n\tmutex_unlock(&dev->lock);\n}\n\n\nvoid zmii_set_speed(struct platform_device *ofdev, int input, int speed)\n{\n\tstruct zmii_instance *dev = platform_get_drvdata(ofdev);\n\tu32 ssr;\n\n\tmutex_lock(&dev->lock);\n\n\tssr = in_be32(&dev->base->ssr);\n\n\tZMII_DBG(dev, \"speed(%d, %d)\" NL, input, speed);\n\n\tif (speed == SPEED_100)\n\t\tssr |= ZMII_SSR_SP(input);\n\telse\n\t\tssr &= ~ZMII_SSR_SP(input);\n\n\tout_be32(&dev->base->ssr, ssr);\n\n\tmutex_unlock(&dev->lock);\n}\n\nvoid zmii_detach(struct platform_device *ofdev, int input)\n{\n\tstruct zmii_instance *dev = platform_get_drvdata(ofdev);\n\n\tBUG_ON(!dev || dev->users == 0);\n\n\tmutex_lock(&dev->lock);\n\n\tZMII_DBG(dev, \"detach(%d)\" NL, input);\n\n\t \n\tout_be32(&dev->base->fer,\n\t\t in_be32(&dev->base->fer) & ~zmii_mode_mask(dev->mode, input));\n\n\t--dev->users;\n\n\tmutex_unlock(&dev->lock);\n}\n\nint zmii_get_regs_len(struct platform_device *ofdev)\n{\n\treturn sizeof(struct emac_ethtool_regs_subhdr) +\n\t\tsizeof(struct zmii_regs);\n}\n\nvoid *zmii_dump_regs(struct platform_device *ofdev, void *buf)\n{\n\tstruct zmii_instance *dev = platform_get_drvdata(ofdev);\n\tstruct emac_ethtool_regs_subhdr *hdr = buf;\n\tstruct zmii_regs *regs = (struct zmii_regs *)(hdr + 1);\n\n\thdr->version = 0;\n\thdr->index = 0;  \n\tmemcpy_fromio(regs, dev->base, sizeof(struct zmii_regs));\n\treturn regs + 1;\n}\n\nstatic int zmii_probe(struct platform_device *ofdev)\n{\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct zmii_instance *dev;\n\tstruct resource regs;\n\tint rc;\n\n\trc = -ENOMEM;\n\tdev = kzalloc(sizeof(struct zmii_instance), GFP_KERNEL);\n\tif (dev == NULL)\n\t\tgoto err_gone;\n\n\tmutex_init(&dev->lock);\n\tdev->ofdev = ofdev;\n\tdev->mode = PHY_INTERFACE_MODE_NA;\n\n\trc = -ENXIO;\n\tif (of_address_to_resource(np, 0, &regs)) {\n\t\tprintk(KERN_ERR \"%pOF: Can't get registers address\\n\", np);\n\t\tgoto err_free;\n\t}\n\n\trc = -ENOMEM;\n\tdev->base = (struct zmii_regs __iomem *)ioremap(regs.start,\n\t\t\t\t\t\tsizeof(struct zmii_regs));\n\tif (dev->base == NULL) {\n\t\tprintk(KERN_ERR \"%pOF: Can't map device registers!\\n\", np);\n\t\tgoto err_free;\n\t}\n\n\t \n\tdev->fer_save = in_be32(&dev->base->fer);\n\n\t \n\tout_be32(&dev->base->fer, 0);\n\n\tprintk(KERN_INFO \"ZMII %pOF initialized\\n\", ofdev->dev.of_node);\n\twmb();\n\tplatform_set_drvdata(ofdev, dev);\n\n\treturn 0;\n\n err_free:\n\tkfree(dev);\n err_gone:\n\treturn rc;\n}\n\nstatic int zmii_remove(struct platform_device *ofdev)\n{\n\tstruct zmii_instance *dev = platform_get_drvdata(ofdev);\n\n\tWARN_ON(dev->users != 0);\n\n\tiounmap(dev->base);\n\tkfree(dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id zmii_match[] =\n{\n\t{\n\t\t.compatible\t= \"ibm,zmii\",\n\t},\n\t \n\t{\n\t\t.type\t\t= \"emac-zmii\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver zmii_driver = {\n\t.driver = {\n\t\t.name = \"emac-zmii\",\n\t\t.of_match_table = zmii_match,\n\t},\n\t.probe = zmii_probe,\n\t.remove = zmii_remove,\n};\n\nint __init zmii_init(void)\n{\n\treturn platform_driver_register(&zmii_driver);\n}\n\nvoid zmii_exit(void)\n{\n\tplatform_driver_unregister(&zmii_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}