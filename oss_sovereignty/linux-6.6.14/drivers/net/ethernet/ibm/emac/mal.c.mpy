{
  "module_name": "mal.c",
  "hash_id": "2763a056cb6f64ec4112ba3894ab9c79b1f7fd46c45023a650bce16c0bff3f41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ibm/emac/mal.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n\n#include \"core.h\"\n#include <asm/dcr-regs.h>\n\nstatic int mal_count;\n\nint mal_register_commac(struct mal_instance *mal, struct mal_commac *commac)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mal->lock, flags);\n\n\tMAL_DBG(mal, \"reg(%08x, %08x)\" NL,\n\t\tcommac->tx_chan_mask, commac->rx_chan_mask);\n\n\t \n\tif ((mal->tx_chan_mask & commac->tx_chan_mask) ||\n\t    (mal->rx_chan_mask & commac->rx_chan_mask)) {\n\t\tspin_unlock_irqrestore(&mal->lock, flags);\n\t\tprintk(KERN_WARNING \"mal%d: COMMAC channels conflict!\\n\",\n\t\t       mal->index);\n\t\treturn -EBUSY;\n\t}\n\n\tif (list_empty(&mal->list))\n\t\tnapi_enable(&mal->napi);\n\tmal->tx_chan_mask |= commac->tx_chan_mask;\n\tmal->rx_chan_mask |= commac->rx_chan_mask;\n\tlist_add(&commac->list, &mal->list);\n\n\tspin_unlock_irqrestore(&mal->lock, flags);\n\n\treturn 0;\n}\n\nvoid mal_unregister_commac(struct mal_instance\t*mal,\n\t\tstruct mal_commac *commac)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mal->lock, flags);\n\n\tMAL_DBG(mal, \"unreg(%08x, %08x)\" NL,\n\t\tcommac->tx_chan_mask, commac->rx_chan_mask);\n\n\tmal->tx_chan_mask &= ~commac->tx_chan_mask;\n\tmal->rx_chan_mask &= ~commac->rx_chan_mask;\n\tlist_del_init(&commac->list);\n\tif (list_empty(&mal->list))\n\t\tnapi_disable(&mal->napi);\n\n\tspin_unlock_irqrestore(&mal->lock, flags);\n}\n\nint mal_set_rcbs(struct mal_instance *mal, int channel, unsigned long size)\n{\n\tBUG_ON(channel < 0 || channel >= mal->num_rx_chans ||\n\t       size > MAL_MAX_RX_SIZE);\n\n\tMAL_DBG(mal, \"set_rbcs(%d, %lu)\" NL, channel, size);\n\n\tif (size & 0xf) {\n\t\tprintk(KERN_WARNING\n\t\t       \"mal%d: incorrect RX size %lu for the channel %d\\n\",\n\t\t       mal->index, size, channel);\n\t\treturn -EINVAL;\n\t}\n\n\tset_mal_dcrn(mal, MAL_RCBS(channel), size >> 4);\n\treturn 0;\n}\n\nint mal_tx_bd_offset(struct mal_instance *mal, int channel)\n{\n\tBUG_ON(channel < 0 || channel >= mal->num_tx_chans);\n\n\treturn channel * NUM_TX_BUFF;\n}\n\nint mal_rx_bd_offset(struct mal_instance *mal, int channel)\n{\n\tBUG_ON(channel < 0 || channel >= mal->num_rx_chans);\n\treturn mal->num_tx_chans * NUM_TX_BUFF + channel * NUM_RX_BUFF;\n}\n\nvoid mal_enable_tx_channel(struct mal_instance *mal, int channel)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mal->lock, flags);\n\n\tMAL_DBG(mal, \"enable_tx(%d)\" NL, channel);\n\n\tset_mal_dcrn(mal, MAL_TXCASR,\n\t\t     get_mal_dcrn(mal, MAL_TXCASR) | MAL_CHAN_MASK(channel));\n\n\tspin_unlock_irqrestore(&mal->lock, flags);\n}\n\nvoid mal_disable_tx_channel(struct mal_instance *mal, int channel)\n{\n\tset_mal_dcrn(mal, MAL_TXCARR, MAL_CHAN_MASK(channel));\n\n\tMAL_DBG(mal, \"disable_tx(%d)\" NL, channel);\n}\n\nvoid mal_enable_rx_channel(struct mal_instance *mal, int channel)\n{\n\tunsigned long flags;\n\n\t \n\tif (!(channel % 8))\n\t\tchannel >>= 3;\n\n\tspin_lock_irqsave(&mal->lock, flags);\n\n\tMAL_DBG(mal, \"enable_rx(%d)\" NL, channel);\n\n\tset_mal_dcrn(mal, MAL_RXCASR,\n\t\t     get_mal_dcrn(mal, MAL_RXCASR) | MAL_CHAN_MASK(channel));\n\n\tspin_unlock_irqrestore(&mal->lock, flags);\n}\n\nvoid mal_disable_rx_channel(struct mal_instance *mal, int channel)\n{\n\t \n\tif (!(channel % 8))\n\t\tchannel >>= 3;\n\n\tset_mal_dcrn(mal, MAL_RXCARR, MAL_CHAN_MASK(channel));\n\n\tMAL_DBG(mal, \"disable_rx(%d)\" NL, channel);\n}\n\nvoid mal_poll_add(struct mal_instance *mal, struct mal_commac *commac)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mal->lock, flags);\n\n\tMAL_DBG(mal, \"poll_add(%p)\" NL, commac);\n\n\t \n\tset_bit(MAL_COMMAC_POLL_DISABLED, &commac->flags);\n\n\tlist_add_tail(&commac->poll_list, &mal->poll_list);\n\n\tspin_unlock_irqrestore(&mal->lock, flags);\n}\n\nvoid mal_poll_del(struct mal_instance *mal, struct mal_commac *commac)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mal->lock, flags);\n\n\tMAL_DBG(mal, \"poll_del(%p)\" NL, commac);\n\n\tlist_del(&commac->poll_list);\n\n\tspin_unlock_irqrestore(&mal->lock, flags);\n}\n\n \nstatic inline void mal_enable_eob_irq(struct mal_instance *mal)\n{\n\tMAL_DBG2(mal, \"enable_irq\" NL);\n\n\t \n\tset_mal_dcrn(mal, MAL_CFG, get_mal_dcrn(mal, MAL_CFG) | MAL_CFG_EOPIE);\n}\n\n \nstatic inline void mal_disable_eob_irq(struct mal_instance *mal)\n{\n\t \n\tset_mal_dcrn(mal, MAL_CFG, get_mal_dcrn(mal, MAL_CFG) & ~MAL_CFG_EOPIE);\n\n\tMAL_DBG2(mal, \"disable_irq\" NL);\n}\n\nstatic irqreturn_t mal_serr(int irq, void *dev_instance)\n{\n\tstruct mal_instance *mal = dev_instance;\n\n\tu32 esr = get_mal_dcrn(mal, MAL_ESR);\n\n\t \n\tset_mal_dcrn(mal, MAL_ESR, esr);\n\n\tMAL_DBG(mal, \"SERR %08x\" NL, esr);\n\n\tif (esr & MAL_ESR_EVB) {\n\t\tif (esr & MAL_ESR_DE) {\n\t\t\t \n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tif (esr & MAL_ESR_PEIN) {\n\t\t\t \n\t\t\tif (net_ratelimit())\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"mal%d: system error, \"\n\t\t\t\t       \"PLB (ESR = 0x%08x)\\n\",\n\t\t\t\t       mal->index, esr);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\t \n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"mal%d: system error, OPB (ESR = 0x%08x)\\n\",\n\t\t\t       mal->index, esr);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic inline void mal_schedule_poll(struct mal_instance *mal)\n{\n\tif (likely(napi_schedule_prep(&mal->napi))) {\n\t\tMAL_DBG2(mal, \"schedule_poll\" NL);\n\t\tspin_lock(&mal->lock);\n\t\tmal_disable_eob_irq(mal);\n\t\tspin_unlock(&mal->lock);\n\t\t__napi_schedule(&mal->napi);\n\t} else\n\t\tMAL_DBG2(mal, \"already in poll\" NL);\n}\n\nstatic irqreturn_t mal_txeob(int irq, void *dev_instance)\n{\n\tstruct mal_instance *mal = dev_instance;\n\n\tu32 r = get_mal_dcrn(mal, MAL_TXEOBISR);\n\n\tMAL_DBG2(mal, \"txeob %08x\" NL, r);\n\n\tmal_schedule_poll(mal);\n\tset_mal_dcrn(mal, MAL_TXEOBISR, r);\n\n#ifdef CONFIG_PPC_DCR_NATIVE\n\tif (mal_has_feature(mal, MAL_FTR_CLEAR_ICINTSTAT))\n\t\tmtdcri(SDR0, DCRN_SDR_ICINTSTAT,\n\t\t\t\t(mfdcri(SDR0, DCRN_SDR_ICINTSTAT) | ICINTSTAT_ICTX));\n#endif\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mal_rxeob(int irq, void *dev_instance)\n{\n\tstruct mal_instance *mal = dev_instance;\n\n\tu32 r = get_mal_dcrn(mal, MAL_RXEOBISR);\n\n\tMAL_DBG2(mal, \"rxeob %08x\" NL, r);\n\n\tmal_schedule_poll(mal);\n\tset_mal_dcrn(mal, MAL_RXEOBISR, r);\n\n#ifdef CONFIG_PPC_DCR_NATIVE\n\tif (mal_has_feature(mal, MAL_FTR_CLEAR_ICINTSTAT))\n\t\tmtdcri(SDR0, DCRN_SDR_ICINTSTAT,\n\t\t\t\t(mfdcri(SDR0, DCRN_SDR_ICINTSTAT) | ICINTSTAT_ICRX));\n#endif\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mal_txde(int irq, void *dev_instance)\n{\n\tstruct mal_instance *mal = dev_instance;\n\n\tu32 deir = get_mal_dcrn(mal, MAL_TXDEIR);\n\tset_mal_dcrn(mal, MAL_TXDEIR, deir);\n\n\tMAL_DBG(mal, \"txde %08x\" NL, deir);\n\n\tif (net_ratelimit())\n\t\tprintk(KERN_ERR\n\t\t       \"mal%d: TX descriptor error (TXDEIR = 0x%08x)\\n\",\n\t\t       mal->index, deir);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mal_rxde(int irq, void *dev_instance)\n{\n\tstruct mal_instance *mal = dev_instance;\n\tstruct list_head *l;\n\n\tu32 deir = get_mal_dcrn(mal, MAL_RXDEIR);\n\n\tMAL_DBG(mal, \"rxde %08x\" NL, deir);\n\n\tlist_for_each(l, &mal->list) {\n\t\tstruct mal_commac *mc = list_entry(l, struct mal_commac, list);\n\t\tif (deir & mc->rx_chan_mask) {\n\t\t\tset_bit(MAL_COMMAC_RX_STOPPED, &mc->flags);\n\t\t\tmc->ops->rxde(mc->dev);\n\t\t}\n\t}\n\n\tmal_schedule_poll(mal);\n\tset_mal_dcrn(mal, MAL_RXDEIR, deir);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mal_int(int irq, void *dev_instance)\n{\n\tstruct mal_instance *mal = dev_instance;\n\tu32 esr = get_mal_dcrn(mal, MAL_ESR);\n\n\tif (esr & MAL_ESR_EVB) {\n\t\t \n\t\tif (esr & MAL_ESR_DE) {\n\t\t\tif (esr & MAL_ESR_CIDT)\n\t\t\t\treturn mal_rxde(irq, dev_instance);\n\t\t\telse\n\t\t\t\treturn mal_txde(irq, dev_instance);\n\t\t} else {  \n\t\t\treturn mal_serr(irq, dev_instance);\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nvoid mal_poll_disable(struct mal_instance *mal, struct mal_commac *commac)\n{\n\t \n\twhile (test_and_set_bit(MAL_COMMAC_POLL_DISABLED, &commac->flags))\n\t\tmsleep(1);\n\n\t \n\tnapi_synchronize(&mal->napi);\n}\n\nvoid mal_poll_enable(struct mal_instance *mal, struct mal_commac *commac)\n{\n\tsmp_wmb();\n\tclear_bit(MAL_COMMAC_POLL_DISABLED, &commac->flags);\n\n\t \n\tnapi_schedule(&mal->napi);\n}\n\nstatic int mal_poll(struct napi_struct *napi, int budget)\n{\n\tstruct mal_instance *mal = container_of(napi, struct mal_instance, napi);\n\tstruct list_head *l;\n\tint received = 0;\n\tunsigned long flags;\n\n\tMAL_DBG2(mal, \"poll(%d)\" NL, budget);\n\n\t \n\tlist_for_each(l, &mal->poll_list) {\n\t\tstruct mal_commac *mc =\n\t\t\tlist_entry(l, struct mal_commac, poll_list);\n\t\tmc->ops->poll_tx(mc->dev);\n\t}\n\n\t \n\tlist_for_each(l, &mal->poll_list) {\n\t\tstruct mal_commac *mc =\n\t\t\tlist_entry(l, struct mal_commac, poll_list);\n\t\tint n;\n\t\tif (unlikely(test_bit(MAL_COMMAC_POLL_DISABLED, &mc->flags)))\n\t\t\tcontinue;\n\t\tn = mc->ops->poll_rx(mc->dev, budget - received);\n\t\tif (n) {\n\t\t\treceived += n;\n\t\t\tif (received >= budget)\n\t\t\t\treturn budget;\n\t\t}\n\t}\n\n\tif (napi_complete_done(napi, received)) {\n\t\t \n\t\tspin_lock_irqsave(&mal->lock, flags);\n\t\tmal_enable_eob_irq(mal);\n\t\tspin_unlock_irqrestore(&mal->lock, flags);\n\t}\n\n\t \n\tlist_for_each(l, &mal->poll_list) {\n\t\tstruct mal_commac *mc =\n\t\t\tlist_entry(l, struct mal_commac, poll_list);\n\t\tif (unlikely(test_bit(MAL_COMMAC_POLL_DISABLED, &mc->flags)))\n\t\t\tcontinue;\n\t\tif (unlikely(mc->ops->peek_rx(mc->dev) ||\n\t\t\t     test_bit(MAL_COMMAC_RX_STOPPED, &mc->flags))) {\n\t\t\tMAL_DBG2(mal, \"rotting packet\" NL);\n\t\t\tif (!napi_reschedule(napi))\n\t\t\t\tgoto more_work;\n\n\t\t\tspin_lock_irqsave(&mal->lock, flags);\n\t\t\tmal_disable_eob_irq(mal);\n\t\t\tspin_unlock_irqrestore(&mal->lock, flags);\n\t\t}\n\t\tmc->ops->poll_tx(mc->dev);\n\t}\n\n more_work:\n\tMAL_DBG2(mal, \"poll() %d <- %d\" NL, budget, received);\n\treturn received;\n}\n\nstatic void mal_reset(struct mal_instance *mal)\n{\n\tint n = 10;\n\n\tMAL_DBG(mal, \"reset\" NL);\n\n\tset_mal_dcrn(mal, MAL_CFG, MAL_CFG_SR);\n\n\t \n\twhile ((get_mal_dcrn(mal, MAL_CFG) & MAL_CFG_SR) && n)\n\t\t--n;\n\n\tif (unlikely(!n))\n\t\tprintk(KERN_ERR \"mal%d: reset timeout\\n\", mal->index);\n}\n\nint mal_get_regs_len(struct mal_instance *mal)\n{\n\treturn sizeof(struct emac_ethtool_regs_subhdr) +\n\t    sizeof(struct mal_regs);\n}\n\nvoid *mal_dump_regs(struct mal_instance *mal, void *buf)\n{\n\tstruct emac_ethtool_regs_subhdr *hdr = buf;\n\tstruct mal_regs *regs = (struct mal_regs *)(hdr + 1);\n\tint i;\n\n\thdr->version = mal->version;\n\thdr->index = mal->index;\n\n\tregs->tx_count = mal->num_tx_chans;\n\tregs->rx_count = mal->num_rx_chans;\n\n\tregs->cfg = get_mal_dcrn(mal, MAL_CFG);\n\tregs->esr = get_mal_dcrn(mal, MAL_ESR);\n\tregs->ier = get_mal_dcrn(mal, MAL_IER);\n\tregs->tx_casr = get_mal_dcrn(mal, MAL_TXCASR);\n\tregs->tx_carr = get_mal_dcrn(mal, MAL_TXCARR);\n\tregs->tx_eobisr = get_mal_dcrn(mal, MAL_TXEOBISR);\n\tregs->tx_deir = get_mal_dcrn(mal, MAL_TXDEIR);\n\tregs->rx_casr = get_mal_dcrn(mal, MAL_RXCASR);\n\tregs->rx_carr = get_mal_dcrn(mal, MAL_RXCARR);\n\tregs->rx_eobisr = get_mal_dcrn(mal, MAL_RXEOBISR);\n\tregs->rx_deir = get_mal_dcrn(mal, MAL_RXDEIR);\n\n\tfor (i = 0; i < regs->tx_count; ++i)\n\t\tregs->tx_ctpr[i] = get_mal_dcrn(mal, MAL_TXCTPR(i));\n\n\tfor (i = 0; i < regs->rx_count; ++i) {\n\t\tregs->rx_ctpr[i] = get_mal_dcrn(mal, MAL_RXCTPR(i));\n\t\tregs->rcbs[i] = get_mal_dcrn(mal, MAL_RCBS(i));\n\t}\n\treturn regs + 1;\n}\n\nstatic int mal_probe(struct platform_device *ofdev)\n{\n\tstruct mal_instance *mal;\n\tint err = 0, i, bd_size;\n\tint index = mal_count++;\n\tunsigned int dcr_base;\n\tconst u32 *prop;\n\tu32 cfg;\n\tunsigned long irqflags;\n\tirq_handler_t hdlr_serr, hdlr_txde, hdlr_rxde;\n\n\tmal = kzalloc(sizeof(struct mal_instance), GFP_KERNEL);\n\tif (!mal)\n\t\treturn -ENOMEM;\n\n\tmal->index = index;\n\tmal->ofdev = ofdev;\n\tmal->version = of_device_is_compatible(ofdev->dev.of_node, \"ibm,mcmal2\") ? 2 : 1;\n\n\tMAL_DBG(mal, \"probe\" NL);\n\n\tprop = of_get_property(ofdev->dev.of_node, \"num-tx-chans\", NULL);\n\tif (prop == NULL) {\n\t\tprintk(KERN_ERR\n\t\t       \"mal%d: can't find MAL num-tx-chans property!\\n\",\n\t\t       index);\n\t\terr = -ENODEV;\n\t\tgoto fail;\n\t}\n\tmal->num_tx_chans = prop[0];\n\n\tprop = of_get_property(ofdev->dev.of_node, \"num-rx-chans\", NULL);\n\tif (prop == NULL) {\n\t\tprintk(KERN_ERR\n\t\t       \"mal%d: can't find MAL num-rx-chans property!\\n\",\n\t\t       index);\n\t\terr = -ENODEV;\n\t\tgoto fail;\n\t}\n\tmal->num_rx_chans = prop[0];\n\n\tdcr_base = dcr_resource_start(ofdev->dev.of_node, 0);\n\tif (dcr_base == 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"mal%d: can't find DCR resource!\\n\", index);\n\t\terr = -ENODEV;\n\t\tgoto fail;\n\t}\n\tmal->dcr_host = dcr_map(ofdev->dev.of_node, dcr_base, 0x100);\n\tif (!DCR_MAP_OK(mal->dcr_host)) {\n\t\tprintk(KERN_ERR\n\t\t       \"mal%d: failed to map DCRs !\\n\", index);\n\t\terr = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tif (of_device_is_compatible(ofdev->dev.of_node, \"ibm,mcmal-405ez\")) {\n#if defined(CONFIG_IBM_EMAC_MAL_CLR_ICINTSTAT) && \\\n\t\tdefined(CONFIG_IBM_EMAC_MAL_COMMON_ERR)\n\t\tmal->features |= (MAL_FTR_CLEAR_ICINTSTAT |\n\t\t\t\tMAL_FTR_COMMON_ERR_INT);\n#else\n\t\tprintk(KERN_ERR \"%pOF: Support for 405EZ not enabled!\\n\",\n\t\t\t\tofdev->dev.of_node);\n\t\terr = -ENODEV;\n\t\tgoto fail;\n#endif\n\t}\n\n\tmal->txeob_irq = irq_of_parse_and_map(ofdev->dev.of_node, 0);\n\tmal->rxeob_irq = irq_of_parse_and_map(ofdev->dev.of_node, 1);\n\tmal->serr_irq = irq_of_parse_and_map(ofdev->dev.of_node, 2);\n\n\tif (mal_has_feature(mal, MAL_FTR_COMMON_ERR_INT)) {\n\t\tmal->txde_irq = mal->rxde_irq = mal->serr_irq;\n\t} else {\n\t\tmal->txde_irq = irq_of_parse_and_map(ofdev->dev.of_node, 3);\n\t\tmal->rxde_irq = irq_of_parse_and_map(ofdev->dev.of_node, 4);\n\t}\n\n\tif (!mal->txeob_irq || !mal->rxeob_irq || !mal->serr_irq ||\n\t    !mal->txde_irq  || !mal->rxde_irq) {\n\t\tprintk(KERN_ERR\n\t\t       \"mal%d: failed to map interrupts !\\n\", index);\n\t\terr = -ENODEV;\n\t\tgoto fail_unmap;\n\t}\n\n\tINIT_LIST_HEAD(&mal->poll_list);\n\tINIT_LIST_HEAD(&mal->list);\n\tspin_lock_init(&mal->lock);\n\n\tinit_dummy_netdev(&mal->dummy_dev);\n\n\tnetif_napi_add_weight(&mal->dummy_dev, &mal->napi, mal_poll,\n\t\t\t      CONFIG_IBM_EMAC_POLL_WEIGHT);\n\n\t \n\tmal_reset(mal);\n\n\t \n\tcfg = (mal->version == 2) ? MAL2_CFG_DEFAULT : MAL1_CFG_DEFAULT;\n\tcfg |= MAL_CFG_PLBB | MAL_CFG_OPBBL | MAL_CFG_LEA;\n\n\t \n\tif (of_device_is_compatible(ofdev->dev.of_node, \"ibm,mcmal-axon\"))\n\t\tcfg &= ~(MAL2_CFG_RPP_10 | MAL2_CFG_WPP_10);\n\n\t \n\tset_mal_dcrn(mal, MAL_CFG, cfg);\n\n\t \n\tBUG_ON(mal->num_tx_chans <= 0 || mal->num_tx_chans > 32);\n\tBUG_ON(mal->num_rx_chans <= 0 || mal->num_rx_chans > 32);\n\n\tbd_size = sizeof(struct mal_descriptor) *\n\t\t(NUM_TX_BUFF * mal->num_tx_chans +\n\t\t NUM_RX_BUFF * mal->num_rx_chans);\n\tmal->bd_virt = dma_alloc_coherent(&ofdev->dev, bd_size, &mal->bd_dma,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (mal->bd_virt == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_unmap;\n\t}\n\n\tfor (i = 0; i < mal->num_tx_chans; ++i)\n\t\tset_mal_dcrn(mal, MAL_TXCTPR(i), mal->bd_dma +\n\t\t\t     sizeof(struct mal_descriptor) *\n\t\t\t     mal_tx_bd_offset(mal, i));\n\n\tfor (i = 0; i < mal->num_rx_chans; ++i)\n\t\tset_mal_dcrn(mal, MAL_RXCTPR(i), mal->bd_dma +\n\t\t\t     sizeof(struct mal_descriptor) *\n\t\t\t     mal_rx_bd_offset(mal, i));\n\n\tif (mal_has_feature(mal, MAL_FTR_COMMON_ERR_INT)) {\n\t\tirqflags = IRQF_SHARED;\n\t\thdlr_serr = hdlr_txde = hdlr_rxde = mal_int;\n\t} else {\n\t\tirqflags = 0;\n\t\thdlr_serr = mal_serr;\n\t\thdlr_txde = mal_txde;\n\t\thdlr_rxde = mal_rxde;\n\t}\n\n\terr = request_irq(mal->serr_irq, hdlr_serr, irqflags, \"MAL SERR\", mal);\n\tif (err)\n\t\tgoto fail2;\n\terr = request_irq(mal->txde_irq, hdlr_txde, irqflags, \"MAL TX DE\", mal);\n\tif (err)\n\t\tgoto fail3;\n\terr = request_irq(mal->txeob_irq, mal_txeob, 0, \"MAL TX EOB\", mal);\n\tif (err)\n\t\tgoto fail4;\n\terr = request_irq(mal->rxde_irq, hdlr_rxde, irqflags, \"MAL RX DE\", mal);\n\tif (err)\n\t\tgoto fail5;\n\terr = request_irq(mal->rxeob_irq, mal_rxeob, 0, \"MAL RX EOB\", mal);\n\tif (err)\n\t\tgoto fail6;\n\n\t \n\tset_mal_dcrn(mal, MAL_IER, MAL_IER_EVENTS);\n\n\t \n\tmal_enable_eob_irq(mal);\n\n\tprintk(KERN_INFO\n\t       \"MAL v%d %pOF, %d TX channels, %d RX channels\\n\",\n\t       mal->version, ofdev->dev.of_node,\n\t       mal->num_tx_chans, mal->num_rx_chans);\n\n\t \n\twmb();\n\tplatform_set_drvdata(ofdev, mal);\n\n\treturn 0;\n\n fail6:\n\tfree_irq(mal->rxde_irq, mal);\n fail5:\n\tfree_irq(mal->txeob_irq, mal);\n fail4:\n\tfree_irq(mal->txde_irq, mal);\n fail3:\n\tfree_irq(mal->serr_irq, mal);\n fail2:\n\tdma_free_coherent(&ofdev->dev, bd_size, mal->bd_virt, mal->bd_dma);\n fail_unmap:\n\tdcr_unmap(mal->dcr_host, 0x100);\n fail:\n\tkfree(mal);\n\n\treturn err;\n}\n\nstatic int mal_remove(struct platform_device *ofdev)\n{\n\tstruct mal_instance *mal = platform_get_drvdata(ofdev);\n\n\tMAL_DBG(mal, \"remove\" NL);\n\n\t \n\tnapi_disable(&mal->napi);\n\n\tif (!list_empty(&mal->list))\n\t\t \n\t\tWARN(1, KERN_EMERG\n\t\t       \"mal%d: commac list is not empty on remove!\\n\",\n\t\t       mal->index);\n\n\tfree_irq(mal->serr_irq, mal);\n\tfree_irq(mal->txde_irq, mal);\n\tfree_irq(mal->txeob_irq, mal);\n\tfree_irq(mal->rxde_irq, mal);\n\tfree_irq(mal->rxeob_irq, mal);\n\n\tmal_reset(mal);\n\n\tdma_free_coherent(&ofdev->dev,\n\t\t\t  sizeof(struct mal_descriptor) *\n\t\t\t  (NUM_TX_BUFF * mal->num_tx_chans +\n\t\t\t   NUM_RX_BUFF * mal->num_rx_chans), mal->bd_virt,\n\t\t\t  mal->bd_dma);\n\tkfree(mal);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mal_platform_match[] =\n{\n\t{\n\t\t.compatible\t= \"ibm,mcmal\",\n\t},\n\t{\n\t\t.compatible\t= \"ibm,mcmal2\",\n\t},\n\t \n\t{\n\t\t.type\t\t= \"mcmal-dma\",\n\t\t.compatible\t= \"ibm,mcmal\",\n\t},\n\t{\n\t\t.type\t\t= \"mcmal-dma\",\n\t\t.compatible\t= \"ibm,mcmal2\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver mal_of_driver = {\n\t.driver = {\n\t\t.name = \"mcmal\",\n\t\t.of_match_table = mal_platform_match,\n\t},\n\t.probe = mal_probe,\n\t.remove = mal_remove,\n};\n\nint __init mal_init(void)\n{\n\treturn platform_driver_register(&mal_of_driver);\n}\n\nvoid mal_exit(void)\n{\n\tplatform_driver_unregister(&mal_of_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}