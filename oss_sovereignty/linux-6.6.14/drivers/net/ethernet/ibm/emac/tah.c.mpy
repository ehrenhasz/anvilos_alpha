{
  "module_name": "tah.c",
  "hash_id": "28fbd5c253ae7001c162e1829b8c87bf3289704f5bd8d9cf00059652f29a657d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ibm/emac/tah.c",
  "human_readable_source": "\n \n#include <linux/mod_devicetable.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <asm/io.h>\n\n#include \"emac.h\"\n#include \"core.h\"\n\nint tah_attach(struct platform_device *ofdev, int channel)\n{\n\tstruct tah_instance *dev = platform_get_drvdata(ofdev);\n\n\tmutex_lock(&dev->lock);\n\t \n\t++dev->users;\n\tmutex_unlock(&dev->lock);\n\n\treturn 0;\n}\n\nvoid tah_detach(struct platform_device *ofdev, int channel)\n{\n\tstruct tah_instance *dev = platform_get_drvdata(ofdev);\n\n\tmutex_lock(&dev->lock);\n\t--dev->users;\n\tmutex_unlock(&dev->lock);\n}\n\nvoid tah_reset(struct platform_device *ofdev)\n{\n\tstruct tah_instance *dev = platform_get_drvdata(ofdev);\n\tstruct tah_regs __iomem *p = dev->base;\n\tint n;\n\n\t \n\tout_be32(&p->mr, TAH_MR_SR);\n\tn = 100;\n\twhile ((in_be32(&p->mr) & TAH_MR_SR) && n)\n\t\t--n;\n\n\tif (unlikely(!n))\n\t\tprintk(KERN_ERR \"%pOF: reset timeout\\n\", ofdev->dev.of_node);\n\n\t \n\tout_be32(&p->mr,\n\t\t TAH_MR_CVR | TAH_MR_ST_768 | TAH_MR_TFS_10KB | TAH_MR_DTFP |\n\t\t TAH_MR_DIG);\n}\n\nint tah_get_regs_len(struct platform_device *ofdev)\n{\n\treturn sizeof(struct emac_ethtool_regs_subhdr) +\n\t\tsizeof(struct tah_regs);\n}\n\nvoid *tah_dump_regs(struct platform_device *ofdev, void *buf)\n{\n\tstruct tah_instance *dev = platform_get_drvdata(ofdev);\n\tstruct emac_ethtool_regs_subhdr *hdr = buf;\n\tstruct tah_regs *regs = (struct tah_regs *)(hdr + 1);\n\n\thdr->version = 0;\n\thdr->index = 0;  \n\tmemcpy_fromio(regs, dev->base, sizeof(struct tah_regs));\n\treturn regs + 1;\n}\n\nstatic int tah_probe(struct platform_device *ofdev)\n{\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct tah_instance *dev;\n\tstruct resource regs;\n\tint rc;\n\n\trc = -ENOMEM;\n\tdev = kzalloc(sizeof(struct tah_instance), GFP_KERNEL);\n\tif (dev == NULL)\n\t\tgoto err_gone;\n\n\tmutex_init(&dev->lock);\n\tdev->ofdev = ofdev;\n\n\trc = -ENXIO;\n\tif (of_address_to_resource(np, 0, &regs)) {\n\t\tprintk(KERN_ERR \"%pOF: Can't get registers address\\n\", np);\n\t\tgoto err_free;\n\t}\n\n\trc = -ENOMEM;\n\tdev->base = (struct tah_regs __iomem *)ioremap(regs.start,\n\t\t\t\t\t       sizeof(struct tah_regs));\n\tif (dev->base == NULL) {\n\t\tprintk(KERN_ERR \"%pOF: Can't map device registers!\\n\", np);\n\t\tgoto err_free;\n\t}\n\n\tplatform_set_drvdata(ofdev, dev);\n\n\t \n\ttah_reset(ofdev);\n\n\tprintk(KERN_INFO \"TAH %pOF initialized\\n\", ofdev->dev.of_node);\n\twmb();\n\n\treturn 0;\n\n err_free:\n\tkfree(dev);\n err_gone:\n\treturn rc;\n}\n\nstatic int tah_remove(struct platform_device *ofdev)\n{\n\tstruct tah_instance *dev = platform_get_drvdata(ofdev);\n\n\tWARN_ON(dev->users != 0);\n\n\tiounmap(dev->base);\n\tkfree(dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tah_match[] =\n{\n\t{\n\t\t.compatible\t= \"ibm,tah\",\n\t},\n\t \n\t{\n\t\t.type\t\t= \"tah\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver tah_driver = {\n\t.driver = {\n\t\t.name = \"emac-tah\",\n\t\t.of_match_table = tah_match,\n\t},\n\t.probe = tah_probe,\n\t.remove = tah_remove,\n};\n\nint __init tah_init(void)\n{\n\treturn platform_driver_register(&tah_driver);\n}\n\nvoid tah_exit(void)\n{\n\tplatform_driver_unregister(&tah_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}