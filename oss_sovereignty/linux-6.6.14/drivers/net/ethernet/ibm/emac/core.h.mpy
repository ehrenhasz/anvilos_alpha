{
  "module_name": "core.h",
  "hash_id": "cec90db4070b98ae5d6ba1b46d7b609e4c55a4dfa0d2c922d0ab07bfc4bb7ba3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ibm/emac/core.h",
  "human_readable_source": " \n \n#ifndef __IBM_NEWEMAC_CORE_H\n#define __IBM_NEWEMAC_CORE_H\n\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/dma-mapping.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\n#include <asm/io.h>\n#include <asm/dcr.h>\n\n#include \"emac.h\"\n#include \"phy.h\"\n#include \"zmii.h\"\n#include \"rgmii.h\"\n#include \"mal.h\"\n#include \"tah.h\"\n#include \"debug.h\"\n\n#define NUM_TX_BUFF\t\t\tCONFIG_IBM_EMAC_TXB\n#define NUM_RX_BUFF\t\t\tCONFIG_IBM_EMAC_RXB\n\n \n#if NUM_TX_BUFF > 256 || NUM_RX_BUFF > 256\n#error Invalid number of buffer descriptors (greater than 256)\n#endif\n\n#define EMAC_MIN_MTU\t\t\t46\n\n \n#define EMAC_MTU_OVERHEAD\t\t(6 * 2 + 2 + 4)\n\n \nstatic inline int emac_rx_size(int mtu)\n{\n\tif (mtu > ETH_DATA_LEN)\n\t\treturn MAL_MAX_RX_SIZE;\n\telse\n\t\treturn mal_rx_size(ETH_DATA_LEN + EMAC_MTU_OVERHEAD);\n}\n\n \nstatic inline int emac_rx_skb_size(int mtu)\n{\n\tint size = max(mtu + EMAC_MTU_OVERHEAD, emac_rx_size(mtu));\n\n\treturn SKB_DATA_ALIGN(size + NET_IP_ALIGN) + NET_SKB_PAD;\n}\n\n \nstatic inline int emac_rx_sync_size(int mtu)\n{\n\treturn SKB_DATA_ALIGN(emac_rx_size(mtu) + NET_IP_ALIGN);\n}\n\n \n\n \nstruct emac_stats {\n\tu64 rx_packets;\n\tu64 rx_bytes;\n\tu64 tx_packets;\n\tu64 tx_bytes;\n\tu64 rx_packets_csum;\n\tu64 tx_packets_csum;\n};\n\n \nstruct emac_error_stats {\n\tu64 tx_undo;\n\n\t \n\tu64 rx_dropped_stack;\n\tu64 rx_dropped_oom;\n\tu64 rx_dropped_error;\n\tu64 rx_dropped_resize;\n\tu64 rx_dropped_mtu;\n\tu64 rx_stopped;\n\t \n\tu64 rx_bd_errors;\n\tu64 rx_bd_overrun;\n\tu64 rx_bd_bad_packet;\n\tu64 rx_bd_runt_packet;\n\tu64 rx_bd_short_event;\n\tu64 rx_bd_alignment_error;\n\tu64 rx_bd_bad_fcs;\n\tu64 rx_bd_packet_too_long;\n\tu64 rx_bd_out_of_range;\n\tu64 rx_bd_in_range;\n\t \n\tu64 rx_parity;\n\tu64 rx_fifo_overrun;\n\tu64 rx_overrun;\n\tu64 rx_bad_packet;\n\tu64 rx_runt_packet;\n\tu64 rx_short_event;\n\tu64 rx_alignment_error;\n\tu64 rx_bad_fcs;\n\tu64 rx_packet_too_long;\n\tu64 rx_out_of_range;\n\tu64 rx_in_range;\n\n\t \n\tu64 tx_dropped;\n\t \n\tu64 tx_bd_errors;\n\tu64 tx_bd_bad_fcs;\n\tu64 tx_bd_carrier_loss;\n\tu64 tx_bd_excessive_deferral;\n\tu64 tx_bd_excessive_collisions;\n\tu64 tx_bd_late_collision;\n\tu64 tx_bd_multple_collisions;\n\tu64 tx_bd_single_collision;\n\tu64 tx_bd_underrun;\n\tu64 tx_bd_sqe;\n\t \n\tu64 tx_parity;\n\tu64 tx_underrun;\n\tu64 tx_sqe;\n\tu64 tx_errors;\n};\n\n#define EMAC_ETHTOOL_STATS_COUNT\t((sizeof(struct emac_stats) + \\\n\t\t\t\t\t  sizeof(struct emac_error_stats)) \\\n\t\t\t\t\t / sizeof(u64))\n\nstruct emac_instance {\n\tstruct net_device\t\t*ndev;\n\tstruct emac_regs\t\t__iomem *emacp;\n\tstruct platform_device\t\t*ofdev;\n\tstruct device_node\t\t**blist;  \n\n\t \n\tu32\t\t\t\tmal_ph;\n\tstruct platform_device\t\t*mal_dev;\n\tu32\t\t\t\tmal_rx_chan;\n\tu32\t\t\t\tmal_tx_chan;\n\tstruct mal_instance\t\t*mal;\n\tstruct mal_commac\t\tcommac;\n\n\t \n\tphy_interface_t\t\t\tphy_mode;\n\tu32\t\t\t\tphy_map;\n\tu32\t\t\t\tphy_address;\n\tu32\t\t\t\tphy_feat_exc;\n\tstruct mii_phy\t\t\tphy;\n\tstruct mutex\t\t\tlink_lock;\n\tstruct delayed_work\t\tlink_work;\n\tint\t\t\t\tlink_polling;\n\n\t \n\tu32\t\t\t\tgpcs_address;\n\n\t \n\tu32\t\t\t\tmdio_ph;\n\tstruct platform_device\t\t*mdio_dev;\n\tstruct emac_instance\t\t*mdio_instance;\n\tstruct mutex\t\t\tmdio_lock;\n\n\t \n\tstruct mii_bus\t\t\t*mii_bus;\n\tstruct phy_device\t\t*phy_dev;\n\n\t \n\tu32\t\t\t\tzmii_ph;\n\tu32\t\t\t\tzmii_port;\n\tstruct platform_device\t\t*zmii_dev;\n\n\t \n\tu32\t\t\t\trgmii_ph;\n\tu32\t\t\t\trgmii_port;\n\tstruct platform_device\t\t*rgmii_dev;\n\n\t \n\tu32\t\t\t\ttah_ph;\n\tu32\t\t\t\ttah_port;\n\tstruct platform_device\t\t*tah_dev;\n\n\t \n\tint\t\t\t\twol_irq;\n\tint\t\t\t\temac_irq;\n\n\t \n\tu32\t\t\t\topb_bus_freq;\n\n\t \n\tu32\t\t\t\tcell_index;\n\n\t \n\tu32\t\t\t\tmax_mtu;\n\n\t \n\tunsigned int\t\t\tfeatures;\n\n\t \n\tu32\t\t\t\ttx_fifo_size;\n\tu32\t\t\t\ttx_fifo_size_gige;\n\tu32\t\t\t\trx_fifo_size;\n\tu32\t\t\t\trx_fifo_size_gige;\n\tu32\t\t\t\tfifo_entry_size;\n\tu32\t\t\t\tmal_burst_size;  \n\n\t \n\tu32\t\t\t\txaht_slots_shift;\n\tu32\t\t\t\txaht_width_shift;\n\n\t \n\tstruct mal_descriptor\t\t*tx_desc;\n\tint\t\t\t\ttx_cnt;\n\tint\t\t\t\ttx_slot;\n\tint\t\t\t\tack_slot;\n\n\tstruct mal_descriptor\t\t*rx_desc;\n\tint\t\t\t\trx_slot;\n\tstruct sk_buff\t\t\t*rx_sg_skb;\t \n\tint \t\t\t\trx_skb_size;\n\tint\t\t\t\trx_sync_size;\n\n\tstruct sk_buff\t\t\t*tx_skb[NUM_TX_BUFF];\n\tstruct sk_buff\t\t\t*rx_skb[NUM_RX_BUFF];\n\n\t \n\tstruct emac_error_stats\t\testats;\n\tstruct emac_stats \t\tstats;\n\n\t \n\tint\t\t\t\treset_failed;\n\tint\t\t\t\tstop_timeout;\t \n\tint\t\t\t\tno_mcast;\n\tint\t\t\t\tmcast_pending;\n\tint\t\t\t\topened;\n\tstruct work_struct\t\treset_work;\n\tspinlock_t\t\t\tlock;\n};\n\n \n\n \n#define EMAC_FTR_NO_FLOW_CONTROL_40x\t0x00000001\n \n#define EMAC_FTR_EMAC4\t\t\t0x00000002\n \n#define EMAC_FTR_STACR_OC_INVERT\t0x00000004\n \n#define EMAC_FTR_HAS_TAH\t\t0x00000008\n \n#define EMAC_FTR_HAS_ZMII\t\t0x00000010\n \n#define EMAC_FTR_HAS_RGMII\t\t0x00000020\n \n#define EMAC_FTR_HAS_NEW_STACR\t\t0x00000040\n \n#define EMAC_FTR_440GX_PHY_CLK_FIX\t0x00000080\n \n#define EMAC_FTR_440EP_PHY_CLK_FIX\t0x00000100\n \n#define EMAC_FTR_EMAC4SYNC\t\t0x00000200\n \n#define EMAC_FTR_460EX_PHY_CLK_FIX\t0x00000400\n \n#define EMAC_APM821XX_REQ_JUMBO_FRAME_SIZE\t0x00000800\n \n#define EMAC_FTR_APM821XX_NO_HALF_DUPLEX\t0x00001000\n\n \nenum {\n\tEMAC_FTRS_ALWAYS\t= 0,\n\n\tEMAC_FTRS_POSSIBLE\t=\n#ifdef CONFIG_IBM_EMAC_EMAC4\n\t    EMAC_FTR_EMAC4\t| EMAC_FTR_EMAC4SYNC\t|\n\t    EMAC_FTR_HAS_NEW_STACR\t|\n\t    EMAC_FTR_STACR_OC_INVERT | EMAC_FTR_440GX_PHY_CLK_FIX |\n#endif\n#ifdef CONFIG_IBM_EMAC_TAH\n\t    EMAC_FTR_HAS_TAH\t|\n#endif\n#ifdef CONFIG_IBM_EMAC_ZMII\n\t    EMAC_FTR_HAS_ZMII\t|\n#endif\n#ifdef CONFIG_IBM_EMAC_RGMII\n\t    EMAC_FTR_HAS_RGMII\t|\n#endif\n#ifdef CONFIG_IBM_EMAC_NO_FLOW_CTRL\n\t    EMAC_FTR_NO_FLOW_CONTROL_40x |\n#endif\n\tEMAC_FTR_460EX_PHY_CLK_FIX |\n\tEMAC_FTR_440EP_PHY_CLK_FIX |\n\tEMAC_APM821XX_REQ_JUMBO_FRAME_SIZE |\n\tEMAC_FTR_APM821XX_NO_HALF_DUPLEX,\n};\n\nstatic inline int emac_has_feature(struct emac_instance *dev,\n\t\t\t\t   unsigned long feature)\n{\n\treturn (EMAC_FTRS_ALWAYS & feature) ||\n\t       (EMAC_FTRS_POSSIBLE & dev->features & feature);\n}\n\n \n\n#define\tEMAC4_XAHT_SLOTS_SHIFT\t\t6\n#define\tEMAC4_XAHT_WIDTH_SHIFT\t\t4\n\n#define\tEMAC4SYNC_XAHT_SLOTS_SHIFT\t8\n#define\tEMAC4SYNC_XAHT_WIDTH_SHIFT\t5\n\n \n#define\tEMAC_XAHT_MAX_REGS\t\t(1 << 3)\n\n#define\tEMAC_XAHT_SLOTS(dev)         \t(1 << (dev)->xaht_slots_shift)\n#define\tEMAC_XAHT_WIDTH(dev)         \t(1 << (dev)->xaht_width_shift)\n#define\tEMAC_XAHT_REGS(dev)          \t(1 << ((dev)->xaht_slots_shift - \\\n\t\t\t\t\t       (dev)->xaht_width_shift))\n\n#define\tEMAC_XAHT_CRC_TO_SLOT(dev, crc)\t\t\t\\\n\t((EMAC_XAHT_SLOTS(dev) - 1) -\t\t\t\\\n\t ((crc) >> ((sizeof (u32) * BITS_PER_BYTE) -\t\\\n\t\t    (dev)->xaht_slots_shift)))\n\n#define\tEMAC_XAHT_SLOT_TO_REG(dev, slot)\t\t\\\n\t((slot) >> (dev)->xaht_width_shift)\n\n#define\tEMAC_XAHT_SLOT_TO_MASK(dev, slot)\t\t\\\n\t((u32)(1 << (EMAC_XAHT_WIDTH(dev) - 1)) >>\t\\\n\t ((slot) & (u32)(EMAC_XAHT_WIDTH(dev) - 1)))\n\nstatic inline u32 *emac_xaht_base(struct emac_instance *dev)\n{\n\tstruct emac_regs __iomem *p = dev->emacp;\n\tint offset;\n\n\t \n\tif (emac_has_feature(dev, EMAC_FTR_EMAC4SYNC))\n\t\toffset = offsetof(struct emac_regs, u1.emac4sync.iaht1);\n\telse\n\t\toffset = offsetof(struct emac_regs, u0.emac4.iaht1);\n\n\treturn (u32 *)((ptrdiff_t)p + offset);\n}\n\nstatic inline u32 *emac_gaht_base(struct emac_instance *dev)\n{\n\t \n\treturn emac_xaht_base(dev) + EMAC_XAHT_REGS(dev);\n}\n\nstatic inline u32 *emac_iaht_base(struct emac_instance *dev)\n{\n\t \n\treturn emac_xaht_base(dev);\n}\n\n \n#define EMAC_ETHTOOL_REGS_ZMII\t\t0x00000001\n#define EMAC_ETHTOOL_REGS_RGMII\t\t0x00000002\n#define EMAC_ETHTOOL_REGS_TAH\t\t0x00000004\n\nstruct emac_ethtool_regs_hdr {\n\tu32 components;\n};\n\nstruct emac_ethtool_regs_subhdr {\n\tu32 version;\n\tu32 index;\n};\n\n#define EMAC_ETHTOOL_REGS_VER\t\t3\n#define EMAC4_ETHTOOL_REGS_VER\t\t4\n#define EMAC4SYNC_ETHTOOL_REGS_VER\t5\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}