{
  "module_name": "phy.c",
  "hash_id": "a18147c5c05ee32f4a489d02aacd6e9c77a1e74056871674b12c4c750a6a1296",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/ibm/emac/phy.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/netdevice.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/delay.h>\n\n#include \"emac.h\"\n#include \"phy.h\"\n\n#define phy_read _phy_read\n#define phy_write _phy_write\n\nstatic inline int _phy_read(struct mii_phy *phy, int reg)\n{\n\treturn phy->mdio_read(phy->dev, phy->address, reg);\n}\n\nstatic inline void _phy_write(struct mii_phy *phy, int reg, int val)\n{\n\tphy->mdio_write(phy->dev, phy->address, reg, val);\n}\n\nstatic inline int gpcs_phy_read(struct mii_phy *phy, int reg)\n{\n\treturn phy->mdio_read(phy->dev, phy->gpcs_address, reg);\n}\n\nstatic inline void gpcs_phy_write(struct mii_phy *phy, int reg, int val)\n{\n\tphy->mdio_write(phy->dev, phy->gpcs_address, reg, val);\n}\n\nint emac_mii_reset_phy(struct mii_phy *phy)\n{\n\tint val;\n\tint limit = 10000;\n\n\tval = phy_read(phy, MII_BMCR);\n\tval &= ~(BMCR_ISOLATE | BMCR_ANENABLE);\n\tval |= BMCR_RESET;\n\tphy_write(phy, MII_BMCR, val);\n\n\tudelay(300);\n\n\twhile (--limit) {\n\t\tval = phy_read(phy, MII_BMCR);\n\t\tif (val >= 0 && (val & BMCR_RESET) == 0)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tif ((val & BMCR_ISOLATE) && limit > 0)\n\t\tphy_write(phy, MII_BMCR, val & ~BMCR_ISOLATE);\n\n\treturn limit <= 0;\n}\n\nint emac_mii_reset_gpcs(struct mii_phy *phy)\n{\n\tint val;\n\tint limit = 10000;\n\n\tval = gpcs_phy_read(phy, MII_BMCR);\n\tval &= ~(BMCR_ISOLATE | BMCR_ANENABLE);\n\tval |= BMCR_RESET;\n\tgpcs_phy_write(phy, MII_BMCR, val);\n\n\tudelay(300);\n\n\twhile (--limit) {\n\t\tval = gpcs_phy_read(phy, MII_BMCR);\n\t\tif (val >= 0 && (val & BMCR_RESET) == 0)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tif ((val & BMCR_ISOLATE) && limit > 0)\n\t\tgpcs_phy_write(phy, MII_BMCR, val & ~BMCR_ISOLATE);\n\n\tif (limit > 0 && phy->mode == PHY_INTERFACE_MODE_SGMII) {\n\t\t \n\t\tgpcs_phy_write(phy, 0x04, 0x8120);  \n\t\tgpcs_phy_write(phy, 0x07, 0x2801);  \n\t\tgpcs_phy_write(phy, 0x00, 0x0140);  \n\t}\n\n\treturn limit <= 0;\n}\n\nstatic int genmii_setup_aneg(struct mii_phy *phy, u32 advertise)\n{\n\tint ctl, adv;\n\n\tphy->autoneg = AUTONEG_ENABLE;\n\tphy->speed = SPEED_10;\n\tphy->duplex = DUPLEX_HALF;\n\tphy->pause = phy->asym_pause = 0;\n\tphy->advertising = advertise;\n\n\tctl = phy_read(phy, MII_BMCR);\n\tif (ctl < 0)\n\t\treturn ctl;\n\tctl &= ~(BMCR_FULLDPLX | BMCR_SPEED100 | BMCR_SPEED1000 | BMCR_ANENABLE);\n\n\t \n\tphy_write(phy, MII_BMCR, ctl);\n\n\t \n\tadv = phy_read(phy, MII_ADVERTISE);\n\tif (adv < 0)\n\t\treturn adv;\n\tadv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4 | ADVERTISE_PAUSE_CAP |\n\t\t ADVERTISE_PAUSE_ASYM);\n\tif (advertise & ADVERTISED_10baseT_Half)\n\t\tadv |= ADVERTISE_10HALF;\n\tif (advertise & ADVERTISED_10baseT_Full)\n\t\tadv |= ADVERTISE_10FULL;\n\tif (advertise & ADVERTISED_100baseT_Half)\n\t\tadv |= ADVERTISE_100HALF;\n\tif (advertise & ADVERTISED_100baseT_Full)\n\t\tadv |= ADVERTISE_100FULL;\n\tif (advertise & ADVERTISED_Pause)\n\t\tadv |= ADVERTISE_PAUSE_CAP;\n\tif (advertise & ADVERTISED_Asym_Pause)\n\t\tadv |= ADVERTISE_PAUSE_ASYM;\n\tphy_write(phy, MII_ADVERTISE, adv);\n\n\tif (phy->features &\n\t    (SUPPORTED_1000baseT_Full | SUPPORTED_1000baseT_Half)) {\n\t\tadv = phy_read(phy, MII_CTRL1000);\n\t\tif (adv < 0)\n\t\t\treturn adv;\n\t\tadv &= ~(ADVERTISE_1000FULL | ADVERTISE_1000HALF);\n\t\tif (advertise & ADVERTISED_1000baseT_Full)\n\t\t\tadv |= ADVERTISE_1000FULL;\n\t\tif (advertise & ADVERTISED_1000baseT_Half)\n\t\t\tadv |= ADVERTISE_1000HALF;\n\t\tphy_write(phy, MII_CTRL1000, adv);\n\t}\n\n\t \n\tctl = phy_read(phy, MII_BMCR);\n\tctl |= (BMCR_ANENABLE | BMCR_ANRESTART);\n\tphy_write(phy, MII_BMCR, ctl);\n\n\treturn 0;\n}\n\nstatic int genmii_setup_forced(struct mii_phy *phy, int speed, int fd)\n{\n\tint ctl;\n\n\tphy->autoneg = AUTONEG_DISABLE;\n\tphy->speed = speed;\n\tphy->duplex = fd;\n\tphy->pause = phy->asym_pause = 0;\n\n\tctl = phy_read(phy, MII_BMCR);\n\tif (ctl < 0)\n\t\treturn ctl;\n\tctl &= ~(BMCR_FULLDPLX | BMCR_SPEED100 | BMCR_SPEED1000 | BMCR_ANENABLE);\n\n\t \n\tphy_write(phy, MII_BMCR, ctl | BMCR_RESET);\n\n\t \n\tswitch (speed) {\n\tcase SPEED_10:\n\t\tbreak;\n\tcase SPEED_100:\n\t\tctl |= BMCR_SPEED100;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tctl |= BMCR_SPEED1000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (fd == DUPLEX_FULL)\n\t\tctl |= BMCR_FULLDPLX;\n\tphy_write(phy, MII_BMCR, ctl);\n\n\treturn 0;\n}\n\nstatic int genmii_poll_link(struct mii_phy *phy)\n{\n\tint status;\n\n\t \n\tphy_read(phy, MII_BMSR);\n\tstatus = phy_read(phy, MII_BMSR);\n\tif (status < 0 || (status & BMSR_LSTATUS) == 0)\n\t\treturn 0;\n\tif (phy->autoneg == AUTONEG_ENABLE && !(status & BMSR_ANEGCOMPLETE))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int genmii_read_link(struct mii_phy *phy)\n{\n\tif (phy->autoneg == AUTONEG_ENABLE) {\n\t\tint glpa = 0;\n\t\tint lpa = phy_read(phy, MII_LPA) & phy_read(phy, MII_ADVERTISE);\n\t\tif (lpa < 0)\n\t\t\treturn lpa;\n\n\t\tif (phy->features &\n\t\t    (SUPPORTED_1000baseT_Full | SUPPORTED_1000baseT_Half)) {\n\t\t\tint adv = phy_read(phy, MII_CTRL1000);\n\t\t\tglpa = phy_read(phy, MII_STAT1000);\n\n\t\t\tif (glpa < 0 || adv < 0)\n\t\t\t\treturn adv;\n\n\t\t\tglpa &= adv << 2;\n\t\t}\n\n\t\tphy->speed = SPEED_10;\n\t\tphy->duplex = DUPLEX_HALF;\n\t\tphy->pause = phy->asym_pause = 0;\n\n\t\tif (glpa & (LPA_1000FULL | LPA_1000HALF)) {\n\t\t\tphy->speed = SPEED_1000;\n\t\t\tif (glpa & LPA_1000FULL)\n\t\t\t\tphy->duplex = DUPLEX_FULL;\n\t\t} else if (lpa & (LPA_100FULL | LPA_100HALF)) {\n\t\t\tphy->speed = SPEED_100;\n\t\t\tif (lpa & LPA_100FULL)\n\t\t\t\tphy->duplex = DUPLEX_FULL;\n\t\t} else if (lpa & LPA_10FULL)\n\t\t\tphy->duplex = DUPLEX_FULL;\n\n\t\tif (phy->duplex == DUPLEX_FULL) {\n\t\t\tphy->pause = lpa & LPA_PAUSE_CAP ? 1 : 0;\n\t\t\tphy->asym_pause = lpa & LPA_PAUSE_ASYM ? 1 : 0;\n\t\t}\n\t} else {\n\t\tint bmcr = phy_read(phy, MII_BMCR);\n\t\tif (bmcr < 0)\n\t\t\treturn bmcr;\n\n\t\tif (bmcr & BMCR_FULLDPLX)\n\t\t\tphy->duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tphy->duplex = DUPLEX_HALF;\n\t\tif (bmcr & BMCR_SPEED1000)\n\t\t\tphy->speed = SPEED_1000;\n\t\telse if (bmcr & BMCR_SPEED100)\n\t\t\tphy->speed = SPEED_100;\n\t\telse\n\t\t\tphy->speed = SPEED_10;\n\n\t\tphy->pause = phy->asym_pause = 0;\n\t}\n\treturn 0;\n}\n\n \nstatic const struct mii_phy_ops generic_phy_ops = {\n\t.setup_aneg\t= genmii_setup_aneg,\n\t.setup_forced\t= genmii_setup_forced,\n\t.poll_link\t= genmii_poll_link,\n\t.read_link\t= genmii_read_link\n};\n\nstatic struct mii_phy_def genmii_phy_def = {\n\t.phy_id\t\t= 0x00000000,\n\t.phy_id_mask\t= 0x00000000,\n\t.name\t\t= \"Generic MII\",\n\t.ops\t\t= &generic_phy_ops\n};\n\n \n#define MII_CIS8201_10BTCSR\t0x16\n#define  TENBTCSR_ECHO_DISABLE\t0x2000\n#define MII_CIS8201_EPCR\t0x17\n#define  EPCR_MODE_MASK\t\t0x3000\n#define  EPCR_GMII_MODE\t\t0x0000\n#define  EPCR_RGMII_MODE\t0x1000\n#define  EPCR_TBI_MODE\t\t0x2000\n#define  EPCR_RTBI_MODE\t\t0x3000\n#define MII_CIS8201_ACSR\t0x1c\n#define  ACSR_PIN_PRIO_SELECT\t0x0004\n\nstatic int cis8201_init(struct mii_phy *phy)\n{\n\tint epcr;\n\n\tepcr = phy_read(phy, MII_CIS8201_EPCR);\n\tif (epcr < 0)\n\t\treturn epcr;\n\n\tepcr &= ~EPCR_MODE_MASK;\n\n\tswitch (phy->mode) {\n\tcase PHY_INTERFACE_MODE_TBI:\n\t\tepcr |= EPCR_TBI_MODE;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RTBI:\n\t\tepcr |= EPCR_RTBI_MODE;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_GMII:\n\t\tepcr |= EPCR_GMII_MODE;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tdefault:\n\t\tepcr |= EPCR_RGMII_MODE;\n\t}\n\n\tphy_write(phy, MII_CIS8201_EPCR, epcr);\n\n\t \n\tphy_write(phy, MII_CIS8201_ACSR,\n\t\t  phy_read(phy, MII_CIS8201_ACSR) | ACSR_PIN_PRIO_SELECT);\n\n\t \n\tphy_write(phy, MII_CIS8201_10BTCSR,\n\t\t  phy_read(phy, MII_CIS8201_10BTCSR) | TENBTCSR_ECHO_DISABLE);\n\n\treturn 0;\n}\n\nstatic const struct mii_phy_ops cis8201_phy_ops = {\n\t.init\t\t= cis8201_init,\n\t.setup_aneg\t= genmii_setup_aneg,\n\t.setup_forced\t= genmii_setup_forced,\n\t.poll_link\t= genmii_poll_link,\n\t.read_link\t= genmii_read_link\n};\n\nstatic struct mii_phy_def cis8201_phy_def = {\n\t.phy_id\t\t= 0x000fc410,\n\t.phy_id_mask\t= 0x000ffff0,\n\t.name\t\t= \"CIS8201 Gigabit Ethernet\",\n\t.ops\t\t= &cis8201_phy_ops\n};\n\nstatic struct mii_phy_def bcm5248_phy_def = {\n\n\t.phy_id\t\t= 0x0143bc00,\n\t.phy_id_mask\t= 0x0ffffff0,\n\t.name\t\t= \"BCM5248 10/100 SMII Ethernet\",\n\t.ops\t\t= &generic_phy_ops\n};\n\nstatic int m88e1111_init(struct mii_phy *phy)\n{\n\tpr_debug(\"%s: Marvell 88E1111 Ethernet\\n\", __func__);\n\tphy_write(phy, 0x14, 0x0ce3);\n\tphy_write(phy, 0x18, 0x4101);\n\tphy_write(phy, 0x09, 0x0e00);\n\tphy_write(phy, 0x04, 0x01e1);\n\tphy_write(phy, 0x00, 0x9140);\n\tphy_write(phy, 0x00, 0x1140);\n\n\treturn  0;\n}\n\nstatic int m88e1112_init(struct mii_phy *phy)\n{\n\t \n\n\tu16 reg_short;\n\n\tpr_debug(\"%s: Marvell 88E1112 Ethernet\\n\", __func__);\n\n\t \n\tphy_write(phy, 0x16, 0x0002);\n\n\tphy_write(phy, 0x00, 0x0040);  \n\treg_short = (u16)(phy_read(phy, 0x1a));\n\treg_short |= 0x8000;  \n\tphy_write(phy, 0x1a, reg_short);\n\temac_mii_reset_phy(phy);  \n\n\t \n\tphy_write(phy, 0x16, 0x0000);\n\n\treturn  0;\n}\n\nstatic int et1011c_init(struct mii_phy *phy)\n{\n\tu16 reg_short;\n\n\treg_short = (u16)(phy_read(phy, 0x16));\n\treg_short &= ~(0x7);\n\treg_short |= 0x6;\t \n\tphy_write(phy, 0x16, reg_short);\n\n\treg_short = (u16)(phy_read(phy, 0x17));\n\treg_short &= ~(0x40);\n\tphy_write(phy, 0x17, reg_short);\n\n\tphy_write(phy, 0x1c, 0x74f0);\n\treturn 0;\n}\n\nstatic const struct mii_phy_ops et1011c_phy_ops = {\n\t.init\t\t= et1011c_init,\n\t.setup_aneg\t= genmii_setup_aneg,\n\t.setup_forced\t= genmii_setup_forced,\n\t.poll_link\t= genmii_poll_link,\n\t.read_link\t= genmii_read_link\n};\n\nstatic struct mii_phy_def et1011c_phy_def = {\n\t.phy_id\t\t= 0x0282f000,\n\t.phy_id_mask\t= 0x0fffff00,\n\t.name\t\t= \"ET1011C Gigabit Ethernet\",\n\t.ops\t\t= &et1011c_phy_ops\n};\n\n\n\n\n\nstatic const struct mii_phy_ops m88e1111_phy_ops = {\n\t.init\t\t= m88e1111_init,\n\t.setup_aneg\t= genmii_setup_aneg,\n\t.setup_forced\t= genmii_setup_forced,\n\t.poll_link\t= genmii_poll_link,\n\t.read_link\t= genmii_read_link\n};\n\nstatic struct mii_phy_def m88e1111_phy_def = {\n\n\t.phy_id\t\t= 0x01410CC0,\n\t.phy_id_mask\t= 0x0ffffff0,\n\t.name\t\t= \"Marvell 88E1111 Ethernet\",\n\t.ops\t\t= &m88e1111_phy_ops,\n};\n\nstatic const struct mii_phy_ops m88e1112_phy_ops = {\n\t.init\t\t= m88e1112_init,\n\t.setup_aneg\t= genmii_setup_aneg,\n\t.setup_forced\t= genmii_setup_forced,\n\t.poll_link\t= genmii_poll_link,\n\t.read_link\t= genmii_read_link\n};\n\nstatic struct mii_phy_def m88e1112_phy_def = {\n\t.phy_id\t\t= 0x01410C90,\n\t.phy_id_mask\t= 0x0ffffff0,\n\t.name\t\t= \"Marvell 88E1112 Ethernet\",\n\t.ops\t\t= &m88e1112_phy_ops,\n};\n\nstatic int ar8035_init(struct mii_phy *phy)\n{\n\tphy_write(phy, 0x1d, 0x5);  \n\tphy_write(phy, 0x1e, 0x2d47);  \n\tphy_write(phy, 0x1d, 0xb);     \n\tphy_write(phy, 0x1e, 0xbc20);  \n\n\treturn 0;\n}\n\nstatic const struct mii_phy_ops ar8035_phy_ops = {\n\t.init\t\t= ar8035_init,\n\t.setup_aneg\t= genmii_setup_aneg,\n\t.setup_forced\t= genmii_setup_forced,\n\t.poll_link\t= genmii_poll_link,\n\t.read_link\t= genmii_read_link,\n};\n\nstatic struct mii_phy_def ar8035_phy_def = {\n\t.phy_id\t\t= 0x004dd070,\n\t.phy_id_mask\t= 0xfffffff0,\n\t.name\t\t= \"Atheros 8035 Gigabit Ethernet\",\n\t.ops\t\t= &ar8035_phy_ops,\n};\n\nstatic struct mii_phy_def *mii_phy_table[] = {\n\t&et1011c_phy_def,\n\t&cis8201_phy_def,\n\t&bcm5248_phy_def,\n\t&m88e1111_phy_def,\n\t&m88e1112_phy_def,\n\t&ar8035_phy_def,\n\t&genmii_phy_def,\n\tNULL\n};\n\nint emac_mii_phy_probe(struct mii_phy *phy, int address)\n{\n\tstruct mii_phy_def *def;\n\tint i;\n\tu32 id;\n\n\tphy->autoneg = AUTONEG_DISABLE;\n\tphy->advertising = 0;\n\tphy->address = address;\n\tphy->speed = SPEED_10;\n\tphy->duplex = DUPLEX_HALF;\n\tphy->pause = phy->asym_pause = 0;\n\n\t \n\tif (emac_mii_reset_phy(phy))\n\t\treturn -ENODEV;\n\n\t \n\tid = (phy_read(phy, MII_PHYSID1) << 16) | phy_read(phy, MII_PHYSID2);\n\tfor (i = 0; (def = mii_phy_table[i]) != NULL; i++)\n\t\tif ((id & def->phy_id_mask) == def->phy_id)\n\t\t\tbreak;\n\t \n\tif (!def)\n\t\treturn -ENODEV;\n\n\tphy->def = def;\n\n\t \n\tphy->features = def->features;\n\tif (!phy->features) {\n\t\tu16 bmsr = phy_read(phy, MII_BMSR);\n\t\tif (bmsr & BMSR_ANEGCAPABLE)\n\t\t\tphy->features |= SUPPORTED_Autoneg;\n\t\tif (bmsr & BMSR_10HALF)\n\t\t\tphy->features |= SUPPORTED_10baseT_Half;\n\t\tif (bmsr & BMSR_10FULL)\n\t\t\tphy->features |= SUPPORTED_10baseT_Full;\n\t\tif (bmsr & BMSR_100HALF)\n\t\t\tphy->features |= SUPPORTED_100baseT_Half;\n\t\tif (bmsr & BMSR_100FULL)\n\t\t\tphy->features |= SUPPORTED_100baseT_Full;\n\t\tif (bmsr & BMSR_ESTATEN) {\n\t\t\tu16 esr = phy_read(phy, MII_ESTATUS);\n\t\t\tif (esr & ESTATUS_1000_TFULL)\n\t\t\t\tphy->features |= SUPPORTED_1000baseT_Full;\n\t\t\tif (esr & ESTATUS_1000_THALF)\n\t\t\t\tphy->features |= SUPPORTED_1000baseT_Half;\n\t\t}\n\t\tphy->features |= SUPPORTED_MII;\n\t}\n\n\t \n\tphy->advertising = phy->features;\n\n\treturn 0;\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}