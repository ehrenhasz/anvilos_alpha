{
  "module_name": "korina.c",
  "hash_id": "3653659d735248fd73398047f587429976b2466572deaf474126bd516d275c38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/korina.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/iopoll.h>\n#include <linux/in.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n#include <linux/platform_device.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/crc32.h>\n#include <linux/pgtable.h>\n#include <linux/clk.h>\n\n#define DRV_NAME\t\"korina\"\n#define DRV_VERSION\t\"0.20\"\n#define DRV_RELDATE\t\"15Sep2017\"\n\nstruct eth_regs {\n\tu32 ethintfc;\n\tu32 ethfifott;\n\tu32 etharc;\n\tu32 ethhash0;\n\tu32 ethhash1;\n\tu32 ethu0[4];\t\t \n\tu32 ethpfs;\n\tu32 ethmcp;\n\tu32 eth_u1[10];\t\t \n\tu32 ethspare;\n\tu32 eth_u2[42];\t\t \n\tu32 ethsal0;\n\tu32 ethsah0;\n\tu32 ethsal1;\n\tu32 ethsah1;\n\tu32 ethsal2;\n\tu32 ethsah2;\n\tu32 ethsal3;\n\tu32 ethsah3;\n\tu32 ethrbc;\n\tu32 ethrpc;\n\tu32 ethrupc;\n\tu32 ethrfc;\n\tu32 ethtbc;\n\tu32 ethgpf;\n\tu32 eth_u9[50];\t\t \n\tu32 ethmac1;\n\tu32 ethmac2;\n\tu32 ethipgt;\n\tu32 ethipgr;\n\tu32 ethclrt;\n\tu32 ethmaxf;\n\tu32 eth_u10;\t\t \n\tu32 ethmtest;\n\tu32 miimcfg;\n\tu32 miimcmd;\n\tu32 miimaddr;\n\tu32 miimwtd;\n\tu32 miimrdd;\n\tu32 miimind;\n\tu32 eth_u11;\t\t \n\tu32 eth_u12;\t\t \n\tu32 ethcfsa0;\n\tu32 ethcfsa1;\n\tu32 ethcfsa2;\n};\n\n \n#define ETH_INT_FC_EN\t\tBIT(0)\n#define ETH_INT_FC_ITS\t\tBIT(1)\n#define ETH_INT_FC_RIP\t\tBIT(2)\n#define ETH_INT_FC_JAM\t\tBIT(3)\n#define ETH_INT_FC_OVR\t\tBIT(4)\n#define ETH_INT_FC_UND\t\tBIT(5)\n#define ETH_INT_FC_IOC\t\t0x000000c0\n\n \n#define ETH_FIFI_TT_TTH_BIT\t0\n#define ETH_FIFO_TT_TTH\t\t0x0000007f\n\n \n#define ETH_ARC_PRO\t\tBIT(0)\n#define ETH_ARC_AM\t\tBIT(1)\n#define ETH_ARC_AFM\t\tBIT(2)\n#define ETH_ARC_AB\t\tBIT(3)\n\n \n#define ETH_SAL_BYTE_5\t\t0x000000ff\n#define ETH_SAL_BYTE_4\t\t0x0000ff00\n#define ETH_SAL_BYTE_3\t\t0x00ff0000\n#define ETH_SAL_BYTE_2\t\t0xff000000\n\n \n#define ETH_SAH_BYTE1\t\t0x000000ff\n#define ETH_SAH_BYTE0\t\t0x0000ff00\n\n \n#define ETH_GPF_PTV\t\t0x0000ffff\n\n \n#define ETH_PFS_PFD\t\tBIT(0)\n\n \n#define ETH_CFSA0_CFSA4\t\t0x000000ff\n#define ETH_CFSA0_CFSA5\t\t0x0000ff00\n#define ETH_CFSA1_CFSA2\t\t0x000000ff\n#define ETH_CFSA1_CFSA3\t\t0x0000ff00\n#define ETH_CFSA1_CFSA0\t\t0x000000ff\n#define ETH_CFSA1_CFSA1\t\t0x0000ff00\n\n \n#define ETH_MAC1_RE\t\tBIT(0)\n#define ETH_MAC1_PAF\t\tBIT(1)\n#define ETH_MAC1_RFC\t\tBIT(2)\n#define ETH_MAC1_TFC\t\tBIT(3)\n#define ETH_MAC1_LB\t\tBIT(4)\n#define ETH_MAC1_MR\t\tBIT(31)\n\n \n#define ETH_MAC2_FD\t\tBIT(0)\n#define ETH_MAC2_FLC\t\tBIT(1)\n#define ETH_MAC2_HFE\t\tBIT(2)\n#define ETH_MAC2_DC\t\tBIT(3)\n#define ETH_MAC2_CEN\t\tBIT(4)\n#define ETH_MAC2_PE\t\tBIT(5)\n#define ETH_MAC2_VPE\t\tBIT(6)\n#define ETH_MAC2_APE\t\tBIT(7)\n#define ETH_MAC2_PPE\t\tBIT(8)\n#define ETH_MAC2_LPE\t\tBIT(9)\n#define ETH_MAC2_NB\t\tBIT(12)\n#define ETH_MAC2_BP\t\tBIT(13)\n#define ETH_MAC2_ED\t\tBIT(14)\n\n \n#define ETH_IPGT\t\t0x0000007f\n\n \n#define ETH_IPGR_IPGR2\t\t0x0000007f\n#define ETH_IPGR_IPGR1\t\t0x00007f00\n\n \n#define ETH_CLRT_MAX_RET\t0x0000000f\n#define ETH_CLRT_COL_WIN\t0x00003f00\n\n \n#define ETH_MAXF\t\t0x0000ffff\n\n \n#define ETH_TEST_REG\t\tBIT(2)\n#define ETH_MCP_DIV\t\t0x000000ff\n\n \n#define ETH_MII_CFG_RSVD\t0x0000000c\n#define ETH_MII_CMD_RD\t\tBIT(0)\n#define ETH_MII_CMD_SCN\t\tBIT(1)\n#define ETH_MII_REG_ADDR\t0x0000001f\n#define ETH_MII_PHY_ADDR\t0x00001f00\n#define ETH_MII_WTD_DATA\t0x0000ffff\n#define ETH_MII_RDD_DATA\t0x0000ffff\n#define ETH_MII_IND_BSY\t\tBIT(0)\n#define ETH_MII_IND_SCN\t\tBIT(1)\n#define ETH_MII_IND_NV\t\tBIT(2)\n\n \n#define ETH_RX_FD\t\tBIT(0)\n#define ETH_RX_LD\t\tBIT(1)\n#define ETH_RX_ROK\t\tBIT(2)\n#define ETH_RX_FM\t\tBIT(3)\n#define ETH_RX_MP\t\tBIT(4)\n#define ETH_RX_BP\t\tBIT(5)\n#define ETH_RX_VLT\t\tBIT(6)\n#define ETH_RX_CF\t\tBIT(7)\n#define ETH_RX_OVR\t\tBIT(8)\n#define ETH_RX_CRC\t\tBIT(9)\n#define ETH_RX_CV\t\tBIT(10)\n#define ETH_RX_DB\t\tBIT(11)\n#define ETH_RX_LE\t\tBIT(12)\n#define ETH_RX_LOR\t\tBIT(13)\n#define ETH_RX_CES\t\tBIT(14)\n#define ETH_RX_LEN_BIT\t\t16\n#define ETH_RX_LEN\t\t0xffff0000\n\n#define ETH_TX_FD\t\tBIT(0)\n#define ETH_TX_LD\t\tBIT(1)\n#define ETH_TX_OEN\t\tBIT(2)\n#define ETH_TX_PEN\t\tBIT(3)\n#define ETH_TX_CEN\t\tBIT(4)\n#define ETH_TX_HEN\t\tBIT(5)\n#define ETH_TX_TOK\t\tBIT(6)\n#define ETH_TX_MP\t\tBIT(7)\n#define ETH_TX_BP\t\tBIT(8)\n#define ETH_TX_UND\t\tBIT(9)\n#define ETH_TX_OF\t\tBIT(10)\n#define ETH_TX_ED\t\tBIT(11)\n#define ETH_TX_EC\t\tBIT(12)\n#define ETH_TX_LC\t\tBIT(13)\n#define ETH_TX_TD\t\tBIT(14)\n#define ETH_TX_CRC\t\tBIT(15)\n#define ETH_TX_LE\t\tBIT(16)\n#define ETH_TX_CC\t\t0x001E0000\n\n \nstruct dma_desc {\n\tu32 control;\t\t\t \n\tu32 ca;\t\t\t\t \n\tu32 devcs;\t\t\t \n\tu32 link;\t\t\t \n};\n\n#define DMA_DESC_COUNT_BIT\t\t0\n#define DMA_DESC_COUNT_MSK\t\t0x0003ffff\n#define DMA_DESC_DS_BIT\t\t\t20\n#define DMA_DESC_DS_MSK\t\t\t0x00300000\n\n#define DMA_DESC_DEV_CMD_BIT\t\t22\n#define DMA_DESC_DEV_CMD_MSK\t\t0x01c00000\n\n \n#define DMA_DESC_COF\t\t\tBIT(25)  \n#define DMA_DESC_COD\t\t\tBIT(26)  \n#define DMA_DESC_IOF\t\t\tBIT(27)  \n#define DMA_DESC_IOD\t\t\tBIT(28)  \n#define DMA_DESC_TERM\t\t\tBIT(29)  \n#define DMA_DESC_DONE\t\t\tBIT(30)  \n#define DMA_DESC_FINI\t\t\tBIT(31)  \n\n \nstruct dma_reg {\n\tu32 dmac;\t\t \n\tu32 dmas;\t\t \n\tu32 dmasm;\t\t \n\tu32 dmadptr;\t\t \n\tu32 dmandptr;\t\t \n};\n\n \n#define DMA_CHAN_RUN_BIT\t\tBIT(0)\n#define DMA_CHAN_DONE_BIT\t\tBIT(1)\n#define DMA_CHAN_MODE_BIT\t\tBIT(2)\n#define DMA_CHAN_MODE_MSK\t\t0x0000000c\n#define\t DMA_CHAN_MODE_AUTO\t\t0\n#define\t DMA_CHAN_MODE_BURST\t\t1\n#define\t DMA_CHAN_MODE_XFRT\t\t2\n#define\t DMA_CHAN_MODE_RSVD\t\t3\n#define DMA_CHAN_ACT_BIT\t\tBIT(4)\n\n \n#define DMA_STAT_FINI\t\t\tBIT(0)\n#define DMA_STAT_DONE\t\t\tBIT(1)\n#define DMA_STAT_CHAIN\t\t\tBIT(2)\n#define DMA_STAT_ERR\t\t\tBIT(3)\n#define DMA_STAT_HALT\t\t\tBIT(4)\n\n#define STATION_ADDRESS_HIGH(dev) (((dev)->dev_addr[0] << 8) | \\\n\t\t\t\t   ((dev)->dev_addr[1]))\n#define STATION_ADDRESS_LOW(dev)  (((dev)->dev_addr[2] << 24) | \\\n\t\t\t\t   ((dev)->dev_addr[3] << 16) | \\\n\t\t\t\t   ((dev)->dev_addr[4] << 8)  | \\\n\t\t\t\t   ((dev)->dev_addr[5]))\n\n#define MII_CLOCK\t1250000  \n\n \n#define KORINA_NUM_RDS\t64   \n#define KORINA_NUM_TDS\t64   \n\n \n#define KORINA_RBSIZE\t1536  \n#define KORINA_RDS_MASK\t(KORINA_NUM_RDS - 1)\n#define KORINA_TDS_MASK\t(KORINA_NUM_TDS - 1)\n#define RD_RING_SIZE\t(KORINA_NUM_RDS * sizeof(struct dma_desc))\n#define TD_RING_SIZE\t(KORINA_NUM_TDS * sizeof(struct dma_desc))\n\n#define TX_TIMEOUT\t(6000 * HZ / 1000)\n\nenum chain_status {\n\tdesc_filled,\n\tdesc_is_empty\n};\n\n#define DMA_COUNT(count)\t((count) & DMA_DESC_COUNT_MSK)\n#define IS_DMA_FINISHED(X)\t(((X) & (DMA_DESC_FINI)) != 0)\n#define IS_DMA_DONE(X)\t\t(((X) & (DMA_DESC_DONE)) != 0)\n#define RCVPKT_LENGTH(X)\t(((X) & ETH_RX_LEN) >> ETH_RX_LEN_BIT)\n\n \nstruct korina_private {\n\tstruct eth_regs __iomem *eth_regs;\n\tstruct dma_reg __iomem *rx_dma_regs;\n\tstruct dma_reg __iomem *tx_dma_regs;\n\tstruct dma_desc *td_ring;  \n\tstruct dma_desc *rd_ring;  \n\tdma_addr_t td_dma;\n\tdma_addr_t rd_dma;\n\n\tstruct sk_buff *tx_skb[KORINA_NUM_TDS];\n\tstruct sk_buff *rx_skb[KORINA_NUM_RDS];\n\n\tdma_addr_t rx_skb_dma[KORINA_NUM_RDS];\n\tdma_addr_t tx_skb_dma[KORINA_NUM_TDS];\n\n\tint rx_next_done;\n\tint rx_chain_head;\n\tint rx_chain_tail;\n\tenum chain_status rx_chain_status;\n\n\tint tx_next_done;\n\tint tx_chain_head;\n\tint tx_chain_tail;\n\tenum chain_status tx_chain_status;\n\tint tx_count;\n\tint tx_full;\n\n\tint rx_irq;\n\tint tx_irq;\n\n\tspinlock_t lock;\t \n\n\tint dma_halt_cnt;\n\tint dma_run_cnt;\n\tstruct napi_struct napi;\n\tstruct timer_list media_check_timer;\n\tstruct mii_if_info mii_if;\n\tstruct work_struct restart_task;\n\tstruct net_device *dev;\n\tstruct device *dmadev;\n\tint mii_clock_freq;\n};\n\nstatic dma_addr_t korina_tx_dma(struct korina_private *lp, int idx)\n{\n\treturn lp->td_dma + (idx * sizeof(struct dma_desc));\n}\n\nstatic dma_addr_t korina_rx_dma(struct korina_private *lp, int idx)\n{\n\treturn lp->rd_dma + (idx * sizeof(struct dma_desc));\n}\n\nstatic inline void korina_abort_dma(struct net_device *dev,\n\t\t\t\t\tstruct dma_reg *ch)\n{\n\tif (readl(&ch->dmac) & DMA_CHAN_RUN_BIT) {\n\t\twritel(0x10, &ch->dmac);\n\n\t\twhile (!(readl(&ch->dmas) & DMA_STAT_HALT))\n\t\t\tnetif_trans_update(dev);\n\n\t\twritel(0, &ch->dmas);\n\t}\n\n\twritel(0, &ch->dmadptr);\n\twritel(0, &ch->dmandptr);\n}\n\nstatic void korina_abort_tx(struct net_device *dev)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\n\tkorina_abort_dma(dev, lp->tx_dma_regs);\n}\n\nstatic void korina_abort_rx(struct net_device *dev)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\n\tkorina_abort_dma(dev, lp->rx_dma_regs);\n}\n\n \nstatic netdev_tx_t korina_send_packet(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\tu32 chain_prev, chain_next;\n\tunsigned long flags;\n\tstruct dma_desc *td;\n\tdma_addr_t ca;\n\tu32 length;\n\tint idx;\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\tidx = lp->tx_chain_tail;\n\ttd = &lp->td_ring[idx];\n\n\t \n\tif (lp->tx_count >= (KORINA_NUM_TDS - 2)) {\n\t\tlp->tx_full = 1;\n\n\t\tif (lp->tx_count == (KORINA_NUM_TDS - 2))\n\t\t\tnetif_stop_queue(dev);\n\t\telse\n\t\t\tgoto drop_packet;\n\t}\n\n\tlp->tx_count++;\n\n\tlp->tx_skb[idx] = skb;\n\n\tlength = skb->len;\n\n\t \n\tca = dma_map_single(lp->dmadev, skb->data, length, DMA_TO_DEVICE);\n\tif (dma_mapping_error(lp->dmadev, ca))\n\t\tgoto drop_packet;\n\n\tlp->tx_skb_dma[idx] = ca;\n\ttd->ca = ca;\n\n\tchain_prev = (idx - 1) & KORINA_TDS_MASK;\n\tchain_next = (idx + 1) & KORINA_TDS_MASK;\n\n\tif (readl(&(lp->tx_dma_regs->dmandptr)) == 0) {\n\t\tif (lp->tx_chain_status == desc_is_empty) {\n\t\t\t \n\t\t\ttd->control = DMA_COUNT(length) |\n\t\t\t\t\tDMA_DESC_COF | DMA_DESC_IOF;\n\t\t\t \n\t\t\tlp->tx_chain_tail = chain_next;\n\t\t\t \n\t\t\twritel(korina_tx_dma(lp, lp->tx_chain_head),\n\t\t\t       &lp->tx_dma_regs->dmandptr);\n\t\t\t \n\t\t\tlp->tx_chain_head = lp->tx_chain_tail;\n\t\t} else {\n\t\t\t \n\t\t\ttd->control = DMA_COUNT(length) |\n\t\t\t\t\tDMA_DESC_COF | DMA_DESC_IOF;\n\t\t\t \n\t\t\tlp->td_ring[chain_prev].control &=\n\t\t\t\t\t~DMA_DESC_COF;\n\t\t\t \n\t\t\tlp->td_ring[chain_prev].link = korina_tx_dma(lp, idx);\n\t\t\t \n\t\t\tlp->tx_chain_tail = chain_next;\n\t\t\t \n\t\t\twritel(korina_tx_dma(lp, lp->tx_chain_head),\n\t\t\t       &lp->tx_dma_regs->dmandptr);\n\t\t\t \n\t\t\tlp->tx_chain_head = lp->tx_chain_tail;\n\t\t\tlp->tx_chain_status = desc_is_empty;\n\t\t}\n\t} else {\n\t\tif (lp->tx_chain_status == desc_is_empty) {\n\t\t\t \n\t\t\ttd->control = DMA_COUNT(length) |\n\t\t\t\t\tDMA_DESC_COF | DMA_DESC_IOF;\n\t\t\t \n\t\t\tlp->tx_chain_tail = chain_next;\n\t\t\tlp->tx_chain_status = desc_filled;\n\t\t} else {\n\t\t\t \n\t\t\ttd->control = DMA_COUNT(length) |\n\t\t\t\t\tDMA_DESC_COF | DMA_DESC_IOF;\n\t\t\tlp->td_ring[chain_prev].control &=\n\t\t\t\t\t~DMA_DESC_COF;\n\t\t\tlp->td_ring[chain_prev].link = korina_tx_dma(lp, idx);\n\t\t\tlp->tx_chain_tail = chain_next;\n\t\t}\n\t}\n\n\tnetif_trans_update(dev);\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\treturn NETDEV_TX_OK;\n\ndrop_packet:\n\tdev->stats.tx_dropped++;\n\tdev_kfree_skb_any(skb);\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int korina_mdio_wait(struct korina_private *lp)\n{\n\tu32 value;\n\n\treturn readl_poll_timeout_atomic(&lp->eth_regs->miimind,\n\t\t\t\t\t value, value & ETH_MII_IND_BSY,\n\t\t\t\t\t 1, 1000);\n}\n\nstatic int korina_mdio_read(struct net_device *dev, int phy, int reg)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\tint ret;\n\n\tret = korina_mdio_wait(lp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel(phy << 8 | reg, &lp->eth_regs->miimaddr);\n\twritel(1, &lp->eth_regs->miimcmd);\n\n\tret = korina_mdio_wait(lp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (readl(&lp->eth_regs->miimind) & ETH_MII_IND_NV)\n\t\treturn -EINVAL;\n\n\tret = readl(&lp->eth_regs->miimrdd);\n\twritel(0, &lp->eth_regs->miimcmd);\n\treturn ret;\n}\n\nstatic void korina_mdio_write(struct net_device *dev, int phy, int reg, int val)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\n\tif (korina_mdio_wait(lp))\n\t\treturn;\n\n\twritel(0, &lp->eth_regs->miimcmd);\n\twritel(phy << 8 | reg, &lp->eth_regs->miimaddr);\n\twritel(val, &lp->eth_regs->miimwtd);\n}\n\n \nstatic irqreturn_t korina_rx_dma_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct korina_private *lp = netdev_priv(dev);\n\tu32 dmas, dmasm;\n\tirqreturn_t retval;\n\n\tdmas = readl(&lp->rx_dma_regs->dmas);\n\tif (dmas & (DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR)) {\n\t\tdmasm = readl(&lp->rx_dma_regs->dmasm);\n\t\twritel(dmasm | (DMA_STAT_DONE |\n\t\t\t\tDMA_STAT_HALT | DMA_STAT_ERR),\n\t\t\t\t&lp->rx_dma_regs->dmasm);\n\n\t\tnapi_schedule(&lp->napi);\n\n\t\tif (dmas & DMA_STAT_ERR)\n\t\t\tprintk(KERN_ERR \"%s: DMA error\\n\", dev->name);\n\n\t\tretval = IRQ_HANDLED;\n\t} else\n\t\tretval = IRQ_NONE;\n\n\treturn retval;\n}\n\nstatic int korina_rx(struct net_device *dev, int limit)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\tstruct dma_desc *rd = &lp->rd_ring[lp->rx_next_done];\n\tstruct sk_buff *skb, *skb_new;\n\tu32 devcs, pkt_len, dmas;\n\tdma_addr_t ca;\n\tint count;\n\n\tfor (count = 0; count < limit; count++) {\n\t\tskb = lp->rx_skb[lp->rx_next_done];\n\t\tskb_new = NULL;\n\n\t\tdevcs = rd->devcs;\n\n\t\tif ((KORINA_RBSIZE - (u32)DMA_COUNT(rd->control)) == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!(devcs & ETH_RX_LD))\n\t\t\tgoto next;\n\n\t\tif (!(devcs & ETH_RX_ROK)) {\n\t\t\t \n\t\t\tdev->stats.rx_errors++;\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tif (devcs & ETH_RX_CRC)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (devcs & ETH_RX_LE)\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\tif (devcs & ETH_RX_OVR)\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\tif (devcs & ETH_RX_CV)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\tif (devcs & ETH_RX_CES)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\n\t\t\tgoto next;\n\t\t}\n\n\t\t \n\t\tskb_new = netdev_alloc_skb_ip_align(dev, KORINA_RBSIZE);\n\t\tif (!skb_new)\n\t\t\tbreak;\n\n\t\tca = dma_map_single(lp->dmadev, skb_new->data, KORINA_RBSIZE,\n\t\t\t\t    DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(lp->dmadev, ca)) {\n\t\t\tdev_kfree_skb_any(skb_new);\n\t\t\tbreak;\n\t\t}\n\n\t\tpkt_len = RCVPKT_LENGTH(devcs);\n\t\tdma_unmap_single(lp->dmadev, lp->rx_skb_dma[lp->rx_next_done],\n\t\t\t\t pkt_len, DMA_FROM_DEVICE);\n\n\t\t \n\t\tskb_put(skb, pkt_len - 4);\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\n\t\t \n\t\tnapi_gro_receive(&lp->napi, skb);\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += pkt_len;\n\n\t\t \n\t\tif (devcs & ETH_RX_MP)\n\t\t\tdev->stats.multicast++;\n\n\t\tlp->rx_skb[lp->rx_next_done] = skb_new;\n\t\tlp->rx_skb_dma[lp->rx_next_done] = ca;\n\nnext:\n\t\trd->devcs = 0;\n\n\t\t \n\t\trd->ca = lp->rx_skb_dma[lp->rx_next_done];\n\n\t\trd->control = DMA_COUNT(KORINA_RBSIZE) |\n\t\t\tDMA_DESC_COD | DMA_DESC_IOD;\n\t\tlp->rd_ring[(lp->rx_next_done - 1) &\n\t\t\tKORINA_RDS_MASK].control &=\n\t\t\t~DMA_DESC_COD;\n\n\t\tlp->rx_next_done = (lp->rx_next_done + 1) & KORINA_RDS_MASK;\n\t\trd = &lp->rd_ring[lp->rx_next_done];\n\t\twritel((u32)~DMA_STAT_DONE, &lp->rx_dma_regs->dmas);\n\t}\n\n\tdmas = readl(&lp->rx_dma_regs->dmas);\n\n\tif (dmas & DMA_STAT_HALT) {\n\t\twritel((u32)~(DMA_STAT_HALT | DMA_STAT_ERR),\n\t\t       &lp->rx_dma_regs->dmas);\n\n\t\tlp->dma_halt_cnt++;\n\t\trd->devcs = 0;\n\t\trd->ca = lp->rx_skb_dma[lp->rx_next_done];\n\t\twritel(korina_rx_dma(lp, rd - lp->rd_ring),\n\t\t       &lp->rx_dma_regs->dmandptr);\n\t}\n\n\treturn count;\n}\n\nstatic int korina_poll(struct napi_struct *napi, int budget)\n{\n\tstruct korina_private *lp =\n\t\tcontainer_of(napi, struct korina_private, napi);\n\tstruct net_device *dev = lp->dev;\n\tint work_done;\n\n\twork_done = korina_rx(dev, budget);\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\n\t\twritel(readl(&lp->rx_dma_regs->dmasm) &\n\t\t\t~(DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR),\n\t\t\t&lp->rx_dma_regs->dmasm);\n\t}\n\treturn work_done;\n}\n\n \nstatic void korina_multicast_list(struct net_device *dev)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\tunsigned long flags;\n\tstruct netdev_hw_addr *ha;\n\tu32 recognise = ETH_ARC_AB;\t \n\n\t \n\tif (dev->flags & IFF_PROMISC)\n\t\trecognise |= ETH_ARC_PRO;\n\n\telse if ((dev->flags & IFF_ALLMULTI) || (netdev_mc_count(dev) > 4))\n\t\t \n\t\trecognise |= ETH_ARC_AM;\n\n\t \n\tif (netdev_mc_count(dev) > 4) {\n\t\tu16 hash_table[4] = { 0 };\n\t\tu32 crc;\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tcrc = ether_crc_le(6, ha->addr);\n\t\t\tcrc >>= 26;\n\t\t\thash_table[crc >> 4] |= 1 << (15 - (crc & 0xf));\n\t\t}\n\t\t \n\t\trecognise |= ETH_ARC_AFM;\n\n\t\t \n\t\twritel((u32)(hash_table[1] << 16 | hash_table[0]),\n\t\t\t\t\t&lp->eth_regs->ethhash0);\n\t\twritel((u32)(hash_table[3] << 16 | hash_table[2]),\n\t\t\t\t\t&lp->eth_regs->ethhash1);\n\t}\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\twritel(recognise, &lp->eth_regs->etharc);\n\tspin_unlock_irqrestore(&lp->lock, flags);\n}\n\nstatic void korina_tx(struct net_device *dev)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\tstruct dma_desc *td = &lp->td_ring[lp->tx_next_done];\n\tu32 devcs;\n\tu32 dmas;\n\n\tspin_lock(&lp->lock);\n\n\t \n\twhile (IS_DMA_FINISHED(td->control)) {\n\t\tif (lp->tx_full == 1) {\n\t\t\tnetif_wake_queue(dev);\n\t\t\tlp->tx_full = 0;\n\t\t}\n\n\t\tdevcs = lp->td_ring[lp->tx_next_done].devcs;\n\t\tif ((devcs & (ETH_TX_FD | ETH_TX_LD)) !=\n\t\t\t\t(ETH_TX_FD | ETH_TX_LD)) {\n\t\t\tdev->stats.tx_errors++;\n\t\t\tdev->stats.tx_dropped++;\n\n\t\t\t \n\t\t\tprintk(KERN_ERR \"%s: split tx ignored\\n\",\n\t\t\t\t\t\t\tdev->name);\n\t\t} else if (devcs & ETH_TX_TOK) {\n\t\t\tdev->stats.tx_packets++;\n\t\t\tdev->stats.tx_bytes +=\n\t\t\t\t\tlp->tx_skb[lp->tx_next_done]->len;\n\t\t} else {\n\t\t\tdev->stats.tx_errors++;\n\t\t\tdev->stats.tx_dropped++;\n\n\t\t\t \n\t\t\tif (devcs & ETH_TX_UND)\n\t\t\t\tdev->stats.tx_fifo_errors++;\n\n\t\t\t \n\t\t\tif (devcs & ETH_TX_OF)\n\t\t\t\tdev->stats.tx_aborted_errors++;\n\n\t\t\t \n\t\t\tif (devcs & ETH_TX_ED)\n\t\t\t\tdev->stats.tx_carrier_errors++;\n\n\t\t\t \n\t\t\tif (devcs & ETH_TX_EC)\n\t\t\t\tdev->stats.collisions++;\n\n\t\t\t \n\t\t\tif (devcs & ETH_TX_LC)\n\t\t\t\tdev->stats.tx_window_errors++;\n\t\t}\n\n\t\t \n\t\tif (lp->tx_skb[lp->tx_next_done]) {\n\t\t\tdma_unmap_single(lp->dmadev,\n\t\t\t\t\t lp->tx_skb_dma[lp->tx_next_done],\n\t\t\t\t\t lp->tx_skb[lp->tx_next_done]->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(lp->tx_skb[lp->tx_next_done]);\n\t\t\tlp->tx_skb[lp->tx_next_done] = NULL;\n\t\t}\n\n\t\tlp->td_ring[lp->tx_next_done].control = DMA_DESC_IOF;\n\t\tlp->td_ring[lp->tx_next_done].devcs = ETH_TX_FD | ETH_TX_LD;\n\t\tlp->td_ring[lp->tx_next_done].link = 0;\n\t\tlp->td_ring[lp->tx_next_done].ca = 0;\n\t\tlp->tx_count--;\n\n\t\t \n\t\tlp->tx_next_done = (lp->tx_next_done + 1) & KORINA_TDS_MASK;\n\t\ttd = &lp->td_ring[lp->tx_next_done];\n\n\t}\n\n\t \n\tdmas = readl(&lp->tx_dma_regs->dmas);\n\twritel(~dmas, &lp->tx_dma_regs->dmas);\n\n\twritel(readl(&lp->tx_dma_regs->dmasm) &\n\t\t\t~(DMA_STAT_FINI | DMA_STAT_ERR),\n\t\t\t&lp->tx_dma_regs->dmasm);\n\n\tspin_unlock(&lp->lock);\n}\n\nstatic irqreturn_t\nkorina_tx_dma_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct korina_private *lp = netdev_priv(dev);\n\tu32 dmas, dmasm;\n\tirqreturn_t retval;\n\n\tdmas = readl(&lp->tx_dma_regs->dmas);\n\n\tif (dmas & (DMA_STAT_FINI | DMA_STAT_ERR)) {\n\t\tdmasm = readl(&lp->tx_dma_regs->dmasm);\n\t\twritel(dmasm | (DMA_STAT_FINI | DMA_STAT_ERR),\n\t\t\t\t&lp->tx_dma_regs->dmasm);\n\n\t\tkorina_tx(dev);\n\n\t\tif (lp->tx_chain_status == desc_filled &&\n\t\t\t(readl(&(lp->tx_dma_regs->dmandptr)) == 0)) {\n\t\t\twritel(korina_tx_dma(lp, lp->tx_chain_head),\n\t\t\t       &lp->tx_dma_regs->dmandptr);\n\t\t\tlp->tx_chain_status = desc_is_empty;\n\t\t\tlp->tx_chain_head = lp->tx_chain_tail;\n\t\t\tnetif_trans_update(dev);\n\t\t}\n\t\tif (dmas & DMA_STAT_ERR)\n\t\t\tprintk(KERN_ERR \"%s: DMA error\\n\", dev->name);\n\n\t\tretval = IRQ_HANDLED;\n\t} else\n\t\tretval = IRQ_NONE;\n\n\treturn retval;\n}\n\n\nstatic void korina_check_media(struct net_device *dev, unsigned int init_media)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\n\tmii_check_media(&lp->mii_if, 1, init_media);\n\n\tif (lp->mii_if.full_duplex)\n\t\twritel(readl(&lp->eth_regs->ethmac2) | ETH_MAC2_FD,\n\t\t\t\t\t\t&lp->eth_regs->ethmac2);\n\telse\n\t\twritel(readl(&lp->eth_regs->ethmac2) & ~ETH_MAC2_FD,\n\t\t\t\t\t\t&lp->eth_regs->ethmac2);\n}\n\nstatic void korina_poll_media(struct timer_list *t)\n{\n\tstruct korina_private *lp = from_timer(lp, t, media_check_timer);\n\tstruct net_device *dev = lp->dev;\n\n\tkorina_check_media(dev, 0);\n\tmod_timer(&lp->media_check_timer, jiffies + HZ);\n}\n\nstatic void korina_set_carrier(struct mii_if_info *mii)\n{\n\tif (mii->force_media) {\n\t\t \n\t\tif (!netif_carrier_ok(mii->dev))\n\t\t\tnetif_carrier_on(mii->dev);\n\t} else   \n\t\tkorina_check_media(mii->dev, 0);\n}\n\nstatic int korina_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\tstruct mii_ioctl_data *data = if_mii(rq);\n\tint rc;\n\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&lp->lock);\n\trc = generic_mii_ioctl(&lp->mii_if, data, cmd, NULL);\n\tspin_unlock_irq(&lp->lock);\n\tkorina_set_carrier(&lp->mii_if);\n\n\treturn rc;\n}\n\n \nstatic void netdev_get_drvinfo(struct net_device *dev,\n\t\t\t\tstruct ethtool_drvinfo *info)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, lp->dev->name, sizeof(info->bus_info));\n}\n\nstatic int netdev_get_link_ksettings(struct net_device *dev,\n\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\n\tspin_lock_irq(&lp->lock);\n\tmii_ethtool_get_link_ksettings(&lp->mii_if, cmd);\n\tspin_unlock_irq(&lp->lock);\n\n\treturn 0;\n}\n\nstatic int netdev_set_link_ksettings(struct net_device *dev,\n\t\t\t\t     const struct ethtool_link_ksettings *cmd)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\tint rc;\n\n\tspin_lock_irq(&lp->lock);\n\trc = mii_ethtool_set_link_ksettings(&lp->mii_if, cmd);\n\tspin_unlock_irq(&lp->lock);\n\tkorina_set_carrier(&lp->mii_if);\n\n\treturn rc;\n}\n\nstatic u32 netdev_get_link(struct net_device *dev)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\n\treturn mii_link_ok(&lp->mii_if);\n}\n\nstatic const struct ethtool_ops netdev_ethtool_ops = {\n\t.get_drvinfo\t\t= netdev_get_drvinfo,\n\t.get_link\t\t= netdev_get_link,\n\t.get_link_ksettings\t= netdev_get_link_ksettings,\n\t.set_link_ksettings\t= netdev_set_link_ksettings,\n};\n\nstatic int korina_alloc_ring(struct net_device *dev)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tdma_addr_t ca;\n\tint i;\n\n\t \n\tfor (i = 0; i < KORINA_NUM_TDS; i++) {\n\t\tlp->td_ring[i].control = DMA_DESC_IOF;\n\t\tlp->td_ring[i].devcs = ETH_TX_FD | ETH_TX_LD;\n\t\tlp->td_ring[i].ca = 0;\n\t\tlp->td_ring[i].link = 0;\n\t}\n\tlp->tx_next_done = lp->tx_chain_head = lp->tx_chain_tail =\n\t\t\tlp->tx_full = lp->tx_count = 0;\n\tlp->tx_chain_status = desc_is_empty;\n\n\t \n\tfor (i = 0; i < KORINA_NUM_RDS; i++) {\n\t\tskb = netdev_alloc_skb_ip_align(dev, KORINA_RBSIZE);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\t\tlp->rx_skb[i] = skb;\n\t\tlp->rd_ring[i].control = DMA_DESC_IOD |\n\t\t\t\tDMA_COUNT(KORINA_RBSIZE);\n\t\tlp->rd_ring[i].devcs = 0;\n\t\tca = dma_map_single(lp->dmadev, skb->data, KORINA_RBSIZE,\n\t\t\t\t    DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(lp->dmadev, ca))\n\t\t\treturn -ENOMEM;\n\t\tlp->rd_ring[i].ca = ca;\n\t\tlp->rx_skb_dma[i] = ca;\n\t\tlp->rd_ring[i].link = korina_rx_dma(lp, i + 1);\n\t}\n\n\t \n\tlp->rd_ring[i - 1].link = lp->rd_dma;\n\tlp->rd_ring[i - 1].control |= DMA_DESC_COD;\n\n\tlp->rx_next_done  = 0;\n\tlp->rx_chain_head = 0;\n\tlp->rx_chain_tail = 0;\n\tlp->rx_chain_status = desc_is_empty;\n\n\treturn 0;\n}\n\nstatic void korina_free_ring(struct net_device *dev)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\tint i;\n\n\tfor (i = 0; i < KORINA_NUM_RDS; i++) {\n\t\tlp->rd_ring[i].control = 0;\n\t\tif (lp->rx_skb[i]) {\n\t\t\tdma_unmap_single(lp->dmadev, lp->rx_skb_dma[i],\n\t\t\t\t\t KORINA_RBSIZE, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb_any(lp->rx_skb[i]);\n\t\t\tlp->rx_skb[i] = NULL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < KORINA_NUM_TDS; i++) {\n\t\tlp->td_ring[i].control = 0;\n\t\tif (lp->tx_skb[i]) {\n\t\t\tdma_unmap_single(lp->dmadev, lp->tx_skb_dma[i],\n\t\t\t\t\t lp->tx_skb[i]->len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(lp->tx_skb[i]);\n\t\t\tlp->tx_skb[i] = NULL;\n\t\t}\n\t}\n}\n\n \nstatic int korina_init(struct net_device *dev)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\n\t \n\tkorina_abort_tx(dev);\n\tkorina_abort_rx(dev);\n\n\t \n\twritel(0, &lp->eth_regs->ethintfc);\n\twhile ((readl(&lp->eth_regs->ethintfc) & ETH_INT_FC_RIP))\n\t\tnetif_trans_update(dev);\n\n\t \n\twritel(ETH_INT_FC_EN, &lp->eth_regs->ethintfc);\n\n\t \n\tif (korina_alloc_ring(dev)) {\n\t\tprintk(KERN_ERR \"%s: descriptor allocation failed\\n\", dev->name);\n\t\tkorina_free_ring(dev);\n\t\treturn -ENOMEM;\n\t}\n\n\twritel(0, &lp->rx_dma_regs->dmas);\n\t \n\twritel(0, &lp->rx_dma_regs->dmandptr);\n\twritel(korina_rx_dma(lp, 0), &lp->rx_dma_regs->dmadptr);\n\n\twritel(readl(&lp->tx_dma_regs->dmasm) &\n\t\t\t~(DMA_STAT_FINI | DMA_STAT_ERR),\n\t\t\t&lp->tx_dma_regs->dmasm);\n\twritel(readl(&lp->rx_dma_regs->dmasm) &\n\t\t\t~(DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR),\n\t\t\t&lp->rx_dma_regs->dmasm);\n\n\t \n\twritel(ETH_ARC_AB, &lp->eth_regs->etharc);\n\n\t \n\twritel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal0);\n\twritel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah0);\n\n\twritel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal1);\n\twritel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah1);\n\n\twritel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal2);\n\twritel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah2);\n\n\twritel(STATION_ADDRESS_LOW(dev), &lp->eth_regs->ethsal3);\n\twritel(STATION_ADDRESS_HIGH(dev), &lp->eth_regs->ethsah3);\n\n\n\t \n\twritel(ETH_MAC2_PE | ETH_MAC2_CEN | ETH_MAC2_FD,\n\t\t\t&lp->eth_regs->ethmac2);\n\n\t \n\twritel(0x15, &lp->eth_regs->ethipgt);\n\t \n\twritel(0x12, &lp->eth_regs->ethipgr);\n\n\t \n\twritel(((lp->mii_clock_freq) / MII_CLOCK + 1) & ~1,\n\t       &lp->eth_regs->ethmcp);\n\twritel(0, &lp->eth_regs->miimcfg);\n\n\t \n\twritel(48, &lp->eth_regs->ethfifott);\n\n\twritel(ETH_MAC1_RE, &lp->eth_regs->ethmac1);\n\n\tkorina_check_media(dev, 1);\n\n\tnapi_enable(&lp->napi);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\n \nstatic void korina_restart_task(struct work_struct *work)\n{\n\tstruct korina_private *lp = container_of(work,\n\t\t\tstruct korina_private, restart_task);\n\tstruct net_device *dev = lp->dev;\n\n\t \n\tdisable_irq(lp->rx_irq);\n\tdisable_irq(lp->tx_irq);\n\n\twritel(readl(&lp->tx_dma_regs->dmasm) |\n\t\t\t\tDMA_STAT_FINI | DMA_STAT_ERR,\n\t\t\t\t&lp->tx_dma_regs->dmasm);\n\twritel(readl(&lp->rx_dma_regs->dmasm) |\n\t\t\t\tDMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR,\n\t\t\t\t&lp->rx_dma_regs->dmasm);\n\n\tnapi_disable(&lp->napi);\n\n\tkorina_free_ring(dev);\n\n\tif (korina_init(dev) < 0) {\n\t\tprintk(KERN_ERR \"%s: cannot restart device\\n\", dev->name);\n\t\treturn;\n\t}\n\tkorina_multicast_list(dev);\n\n\tenable_irq(lp->tx_irq);\n\tenable_irq(lp->rx_irq);\n}\n\nstatic void korina_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\n\tschedule_work(&lp->restart_task);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void korina_poll_controller(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\tkorina_tx_dma_interrupt(dev->irq, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n\nstatic int korina_open(struct net_device *dev)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\tint ret;\n\n\t \n\tret = korina_init(dev);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"%s: cannot open device\\n\", dev->name);\n\t\tgoto out;\n\t}\n\n\t \n\tret = request_irq(lp->rx_irq, korina_rx_dma_interrupt,\n\t\t\t0, \"Korina ethernet Rx\", dev);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"%s: unable to get Rx DMA IRQ %d\\n\",\n\t\t\tdev->name, lp->rx_irq);\n\t\tgoto err_release;\n\t}\n\tret = request_irq(lp->tx_irq, korina_tx_dma_interrupt,\n\t\t\t0, \"Korina ethernet Tx\", dev);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"%s: unable to get Tx DMA IRQ %d\\n\",\n\t\t\tdev->name, lp->tx_irq);\n\t\tgoto err_free_rx_irq;\n\t}\n\n\tmod_timer(&lp->media_check_timer, jiffies + 1);\nout:\n\treturn ret;\n\nerr_free_rx_irq:\n\tfree_irq(lp->rx_irq, dev);\nerr_release:\n\tkorina_free_ring(dev);\n\tgoto out;\n}\n\nstatic int korina_close(struct net_device *dev)\n{\n\tstruct korina_private *lp = netdev_priv(dev);\n\tu32 tmp;\n\n\tdel_timer(&lp->media_check_timer);\n\n\t \n\tdisable_irq(lp->rx_irq);\n\tdisable_irq(lp->tx_irq);\n\n\tkorina_abort_tx(dev);\n\ttmp = readl(&lp->tx_dma_regs->dmasm);\n\ttmp = tmp | DMA_STAT_FINI | DMA_STAT_ERR;\n\twritel(tmp, &lp->tx_dma_regs->dmasm);\n\n\tkorina_abort_rx(dev);\n\ttmp = readl(&lp->rx_dma_regs->dmasm);\n\ttmp = tmp | DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR;\n\twritel(tmp, &lp->rx_dma_regs->dmasm);\n\n\tnapi_disable(&lp->napi);\n\n\tcancel_work_sync(&lp->restart_task);\n\n\tkorina_free_ring(dev);\n\n\tfree_irq(lp->rx_irq, dev);\n\tfree_irq(lp->tx_irq, dev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops korina_netdev_ops = {\n\t.ndo_open\t\t= korina_open,\n\t.ndo_stop\t\t= korina_close,\n\t.ndo_start_xmit\t\t= korina_send_packet,\n\t.ndo_set_rx_mode\t= korina_multicast_list,\n\t.ndo_tx_timeout\t\t= korina_tx_timeout,\n\t.ndo_eth_ioctl\t\t= korina_ioctl,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= korina_poll_controller,\n#endif\n};\n\nstatic int korina_probe(struct platform_device *pdev)\n{\n\tu8 *mac_addr = dev_get_platdata(&pdev->dev);\n\tstruct korina_private *lp;\n\tstruct net_device *dev;\n\tstruct clk *clk;\n\tvoid __iomem *p;\n\tint rc;\n\n\tdev = devm_alloc_etherdev(&pdev->dev, sizeof(struct korina_private));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tlp = netdev_priv(dev);\n\n\tif (mac_addr)\n\t\teth_hw_addr_set(dev, mac_addr);\n\telse if (of_get_ethdev_address(pdev->dev.of_node, dev) < 0)\n\t\teth_hw_addr_random(dev);\n\n\tclk = devm_clk_get_optional_enabled(&pdev->dev, \"mdioclk\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\tif (clk) {\n\t\tlp->mii_clock_freq = clk_get_rate(clk);\n\t} else {\n\t\tlp->mii_clock_freq = 200000000;  \n\t}\n\n\tlp->rx_irq = platform_get_irq_byname(pdev, \"rx\");\n\tlp->tx_irq = platform_get_irq_byname(pdev, \"tx\");\n\n\tp = devm_platform_ioremap_resource_byname(pdev, \"emac\");\n\tif (IS_ERR(p)) {\n\t\tprintk(KERN_ERR DRV_NAME \": cannot remap registers\\n\");\n\t\treturn PTR_ERR(p);\n\t}\n\tlp->eth_regs = p;\n\n\tp = devm_platform_ioremap_resource_byname(pdev, \"dma_rx\");\n\tif (IS_ERR(p)) {\n\t\tprintk(KERN_ERR DRV_NAME \": cannot remap Rx DMA registers\\n\");\n\t\treturn PTR_ERR(p);\n\t}\n\tlp->rx_dma_regs = p;\n\n\tp = devm_platform_ioremap_resource_byname(pdev, \"dma_tx\");\n\tif (IS_ERR(p)) {\n\t\tprintk(KERN_ERR DRV_NAME \": cannot remap Tx DMA registers\\n\");\n\t\treturn PTR_ERR(p);\n\t}\n\tlp->tx_dma_regs = p;\n\n\tlp->td_ring = dmam_alloc_coherent(&pdev->dev, TD_RING_SIZE,\n\t\t\t\t\t  &lp->td_dma, GFP_KERNEL);\n\tif (!lp->td_ring)\n\t\treturn -ENOMEM;\n\n\tlp->rd_ring = dmam_alloc_coherent(&pdev->dev, RD_RING_SIZE,\n\t\t\t\t\t  &lp->rd_dma, GFP_KERNEL);\n\tif (!lp->rd_ring)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&lp->lock);\n\t \n\tdev->irq = lp->rx_irq;\n\tlp->dev = dev;\n\tlp->dmadev = &pdev->dev;\n\n\tdev->netdev_ops = &korina_netdev_ops;\n\tdev->ethtool_ops = &netdev_ethtool_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tnetif_napi_add(dev, &lp->napi, korina_poll);\n\n\tlp->mii_if.dev = dev;\n\tlp->mii_if.mdio_read = korina_mdio_read;\n\tlp->mii_if.mdio_write = korina_mdio_write;\n\tlp->mii_if.phy_id = 1;\n\tlp->mii_if.phy_id_mask = 0x1f;\n\tlp->mii_if.reg_num_mask = 0x1f;\n\n\tplatform_set_drvdata(pdev, dev);\n\n\trc = register_netdev(dev);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t\": cannot register net device: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\ttimer_setup(&lp->media_check_timer, korina_poll_media, 0);\n\n\tINIT_WORK(&lp->restart_task, korina_restart_task);\n\n\tprintk(KERN_INFO \"%s: \" DRV_NAME \"-\" DRV_VERSION \" \" DRV_RELDATE \"\\n\",\n\t\t\tdev->name);\n\treturn rc;\n}\n\nstatic int korina_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\n\tunregister_netdev(dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id korina_match[] = {\n\t{\n\t\t.compatible = \"idt,3243x-emac\",\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, korina_match);\n#endif\n\nstatic struct platform_driver korina_driver = {\n\t.driver = {\n\t\t.name = \"korina\",\n\t\t.of_match_table = of_match_ptr(korina_match),\n\t},\n\t.probe = korina_probe,\n\t.remove = korina_remove,\n};\n\nmodule_platform_driver(korina_driver);\n\nMODULE_AUTHOR(\"Philip Rischel <rischelp@idt.com>\");\nMODULE_AUTHOR(\"Felix Fietkau <nbd@openwrt.org>\");\nMODULE_AUTHOR(\"Florian Fainelli <florian@openwrt.org>\");\nMODULE_AUTHOR(\"Roman Yeryomin <roman@advem.lv>\");\nMODULE_DESCRIPTION(\"IDT RC32434 (Korina) Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}