{
  "module_name": "bfa_cee.c",
  "hash_id": "67188abb38f3a73757423abfb2500650c5bbac7bada7336865c38eb836231af9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/brocade/bna/bfa_cee.c",
  "human_readable_source": "\n \n \n\n#include \"bfa_cee.h\"\n#include \"bfi_cna.h\"\n#include \"bfa_ioc.h\"\n\nstatic void bfa_cee_format_lldp_cfg(struct bfa_cee_lldp_cfg *lldp_cfg);\nstatic void bfa_cee_format_cee_cfg(void *buffer);\n\nstatic void\nbfa_cee_format_cee_cfg(void *buffer)\n{\n\tstruct bfa_cee_attr *cee_cfg = buffer;\n\tbfa_cee_format_lldp_cfg(&cee_cfg->lldp_remote);\n}\n\nstatic void\nbfa_cee_stats_swap(struct bfa_cee_stats *stats)\n{\n\tu32 *buffer = (u32 *)stats;\n\tint i;\n\n\tfor (i = 0; i < (sizeof(struct bfa_cee_stats) / sizeof(u32));\n\t\ti++) {\n\t\tbuffer[i] = ntohl(buffer[i]);\n\t}\n}\n\nstatic void\nbfa_cee_format_lldp_cfg(struct bfa_cee_lldp_cfg *lldp_cfg)\n{\n\tlldp_cfg->time_to_live =\n\t\t\tntohs(lldp_cfg->time_to_live);\n\tlldp_cfg->enabled_system_cap =\n\t\t\tntohs(lldp_cfg->enabled_system_cap);\n}\n\n \nstatic u32\nbfa_cee_attr_meminfo(void)\n{\n\treturn roundup(sizeof(struct bfa_cee_attr), BFA_DMA_ALIGN_SZ);\n}\n \nstatic u32\nbfa_cee_stats_meminfo(void)\n{\n\treturn roundup(sizeof(struct bfa_cee_stats), BFA_DMA_ALIGN_SZ);\n}\n\n \nstatic void\nbfa_cee_get_attr_isr(struct bfa_cee *cee, enum bfa_status status)\n{\n\tcee->get_attr_status = status;\n\tif (status == BFA_STATUS_OK) {\n\t\tmemcpy(cee->attr, cee->attr_dma.kva,\n\t\t    sizeof(struct bfa_cee_attr));\n\t\tbfa_cee_format_cee_cfg(cee->attr);\n\t}\n\tcee->get_attr_pending = false;\n\tif (cee->cbfn.get_attr_cbfn)\n\t\tcee->cbfn.get_attr_cbfn(cee->cbfn.get_attr_cbarg, status);\n}\n\n \nstatic void\nbfa_cee_get_stats_isr(struct bfa_cee *cee, enum bfa_status status)\n{\n\tcee->get_stats_status = status;\n\tif (status == BFA_STATUS_OK) {\n\t\tmemcpy(cee->stats, cee->stats_dma.kva,\n\t\t\tsizeof(struct bfa_cee_stats));\n\t\tbfa_cee_stats_swap(cee->stats);\n\t}\n\tcee->get_stats_pending = false;\n\tif (cee->cbfn.get_stats_cbfn)\n\t\tcee->cbfn.get_stats_cbfn(cee->cbfn.get_stats_cbarg, status);\n}\n\n \nstatic void\nbfa_cee_reset_stats_isr(struct bfa_cee *cee, enum bfa_status status)\n{\n\tcee->reset_stats_status = status;\n\tcee->reset_stats_pending = false;\n\tif (cee->cbfn.reset_stats_cbfn)\n\t\tcee->cbfn.reset_stats_cbfn(cee->cbfn.reset_stats_cbarg, status);\n}\n \nu32\nbfa_nw_cee_meminfo(void)\n{\n\treturn bfa_cee_attr_meminfo() + bfa_cee_stats_meminfo();\n}\n\n \nvoid\nbfa_nw_cee_mem_claim(struct bfa_cee *cee, u8 *dma_kva, u64 dma_pa)\n{\n\tcee->attr_dma.kva = dma_kva;\n\tcee->attr_dma.pa = dma_pa;\n\tcee->stats_dma.kva = dma_kva + bfa_cee_attr_meminfo();\n\tcee->stats_dma.pa = dma_pa + bfa_cee_attr_meminfo();\n\tcee->attr = (struct bfa_cee_attr *) dma_kva;\n\tcee->stats = (struct bfa_cee_stats *)\n\t\t(dma_kva + bfa_cee_attr_meminfo());\n}\n\n \nenum bfa_status\nbfa_nw_cee_get_attr(struct bfa_cee *cee, struct bfa_cee_attr *attr,\n\t\t    bfa_cee_get_attr_cbfn_t cbfn, void *cbarg)\n{\n\tstruct bfi_cee_get_req *cmd;\n\n\tBUG_ON(!((cee != NULL) && (cee->ioc != NULL)));\n\tif (!bfa_nw_ioc_is_operational(cee->ioc))\n\t\treturn BFA_STATUS_IOC_FAILURE;\n\n\tif (cee->get_attr_pending)\n\t\treturn  BFA_STATUS_DEVBUSY;\n\n\tcee->get_attr_pending = true;\n\tcmd = (struct bfi_cee_get_req *) cee->get_cfg_mb.msg;\n\tcee->attr = attr;\n\tcee->cbfn.get_attr_cbfn = cbfn;\n\tcee->cbfn.get_attr_cbarg = cbarg;\n\tbfi_h2i_set(cmd->mh, BFI_MC_CEE, BFI_CEE_H2I_GET_CFG_REQ,\n\t\t    bfa_ioc_portid(cee->ioc));\n\tbfa_dma_be_addr_set(cmd->dma_addr, cee->attr_dma.pa);\n\tbfa_nw_ioc_mbox_queue(cee->ioc, &cee->get_cfg_mb, NULL, NULL);\n\n\treturn BFA_STATUS_OK;\n}\n\n \n\nstatic void\nbfa_cee_isr(void *cbarg, struct bfi_mbmsg *m)\n{\n\tunion bfi_cee_i2h_msg_u *msg;\n\tstruct bfi_cee_get_rsp *get_rsp;\n\tstruct bfa_cee *cee = (struct bfa_cee *) cbarg;\n\tmsg = (union bfi_cee_i2h_msg_u *) m;\n\tget_rsp = (struct bfi_cee_get_rsp *) m;\n\tswitch (msg->mh.msg_id) {\n\tcase BFI_CEE_I2H_GET_CFG_RSP:\n\t\tbfa_cee_get_attr_isr(cee, get_rsp->cmd_status);\n\t\tbreak;\n\tcase BFI_CEE_I2H_GET_STATS_RSP:\n\t\tbfa_cee_get_stats_isr(cee, get_rsp->cmd_status);\n\t\tbreak;\n\tcase BFI_CEE_I2H_RESET_STATS_RSP:\n\t\tbfa_cee_reset_stats_isr(cee, get_rsp->cmd_status);\n\t\tbreak;\n\tdefault:\n\t\tBUG_ON(1);\n\t}\n}\n\n \n\nstatic void\nbfa_cee_notify(void *arg, enum bfa_ioc_event event)\n{\n\tstruct bfa_cee *cee;\n\tcee = (struct bfa_cee *) arg;\n\n\tswitch (event) {\n\tcase BFA_IOC_E_DISABLED:\n\tcase BFA_IOC_E_FAILED:\n\t\tif (cee->get_attr_pending) {\n\t\t\tcee->get_attr_status = BFA_STATUS_FAILED;\n\t\t\tcee->get_attr_pending  = false;\n\t\t\tif (cee->cbfn.get_attr_cbfn) {\n\t\t\t\tcee->cbfn.get_attr_cbfn(\n\t\t\t\t\tcee->cbfn.get_attr_cbarg,\n\t\t\t\t\tBFA_STATUS_FAILED);\n\t\t\t}\n\t\t}\n\t\tif (cee->get_stats_pending) {\n\t\t\tcee->get_stats_status = BFA_STATUS_FAILED;\n\t\t\tcee->get_stats_pending  = false;\n\t\t\tif (cee->cbfn.get_stats_cbfn) {\n\t\t\t\tcee->cbfn.get_stats_cbfn(\n\t\t\t\t\tcee->cbfn.get_stats_cbarg,\n\t\t\t\t\tBFA_STATUS_FAILED);\n\t\t\t}\n\t\t}\n\t\tif (cee->reset_stats_pending) {\n\t\t\tcee->reset_stats_status = BFA_STATUS_FAILED;\n\t\t\tcee->reset_stats_pending  = false;\n\t\t\tif (cee->cbfn.reset_stats_cbfn) {\n\t\t\t\tcee->cbfn.reset_stats_cbfn(\n\t\t\t\t\tcee->cbfn.reset_stats_cbarg,\n\t\t\t\t\tBFA_STATUS_FAILED);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nvoid\nbfa_nw_cee_attach(struct bfa_cee *cee, struct bfa_ioc *ioc,\n\t\tvoid *dev)\n{\n\tBUG_ON(!(cee != NULL));\n\tcee->dev = dev;\n\tcee->ioc = ioc;\n\n\tbfa_nw_ioc_mbox_regisr(cee->ioc, BFI_MC_CEE, bfa_cee_isr, cee);\n\tbfa_ioc_notify_init(&cee->ioc_notify, bfa_cee_notify, cee);\n\tbfa_nw_ioc_notify_register(cee->ioc, &cee->ioc_notify);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}