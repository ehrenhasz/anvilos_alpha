{
  "module_name": "bnad_debugfs.c",
  "hash_id": "e45f5e4c3ecd69e0bdfaec9ebbf3b1b9d7cd93d131dc2e78d6d622370457d75b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/brocade/bna/bnad_debugfs.c",
  "human_readable_source": "\n \n \n\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include \"bnad.h\"\n\n \n\nstruct bnad_debug_info {\n\tchar *debug_buffer;\n\tvoid *i_private;\n\tint buffer_len;\n};\n\nstatic int\nbnad_debugfs_open_fwtrc(struct inode *inode, struct file *file)\n{\n\tstruct bnad *bnad = inode->i_private;\n\tstruct bnad_debug_info *fw_debug;\n\tunsigned long flags;\n\tint rc;\n\n\tfw_debug = kzalloc(sizeof(struct bnad_debug_info), GFP_KERNEL);\n\tif (!fw_debug)\n\t\treturn -ENOMEM;\n\n\tfw_debug->buffer_len = BNA_DBG_FWTRC_LEN;\n\n\tfw_debug->debug_buffer = kzalloc(fw_debug->buffer_len, GFP_KERNEL);\n\tif (!fw_debug->debug_buffer) {\n\t\tkfree(fw_debug);\n\t\tfw_debug = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\trc = bfa_nw_ioc_debug_fwtrc(&bnad->bna.ioceth.ioc,\n\t\t\tfw_debug->debug_buffer,\n\t\t\t&fw_debug->buffer_len);\n\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\tif (rc != BFA_STATUS_OK) {\n\t\tkfree(fw_debug->debug_buffer);\n\t\tfw_debug->debug_buffer = NULL;\n\t\tkfree(fw_debug);\n\t\tfw_debug = NULL;\n\t\tnetdev_warn(bnad->netdev, \"failed to collect fwtrc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfile->private_data = fw_debug;\n\n\treturn 0;\n}\n\nstatic int\nbnad_debugfs_open_fwsave(struct inode *inode, struct file *file)\n{\n\tstruct bnad *bnad = inode->i_private;\n\tstruct bnad_debug_info *fw_debug;\n\tunsigned long flags;\n\tint rc;\n\n\tfw_debug = kzalloc(sizeof(struct bnad_debug_info), GFP_KERNEL);\n\tif (!fw_debug)\n\t\treturn -ENOMEM;\n\n\tfw_debug->buffer_len = BNA_DBG_FWTRC_LEN;\n\n\tfw_debug->debug_buffer = kzalloc(fw_debug->buffer_len, GFP_KERNEL);\n\tif (!fw_debug->debug_buffer) {\n\t\tkfree(fw_debug);\n\t\tfw_debug = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\trc = bfa_nw_ioc_debug_fwsave(&bnad->bna.ioceth.ioc,\n\t\t\tfw_debug->debug_buffer,\n\t\t\t&fw_debug->buffer_len);\n\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\tif (rc != BFA_STATUS_OK && rc != BFA_STATUS_ENOFSAVE) {\n\t\tkfree(fw_debug->debug_buffer);\n\t\tfw_debug->debug_buffer = NULL;\n\t\tkfree(fw_debug);\n\t\tfw_debug = NULL;\n\t\tnetdev_warn(bnad->netdev, \"failed to collect fwsave\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfile->private_data = fw_debug;\n\n\treturn 0;\n}\n\nstatic int\nbnad_debugfs_open_reg(struct inode *inode, struct file *file)\n{\n\tstruct bnad_debug_info *reg_debug;\n\n\treg_debug = kzalloc(sizeof(struct bnad_debug_info), GFP_KERNEL);\n\tif (!reg_debug)\n\t\treturn -ENOMEM;\n\n\treg_debug->i_private = inode->i_private;\n\n\tfile->private_data = reg_debug;\n\n\treturn 0;\n}\n\nstatic int\nbnad_get_debug_drvinfo(struct bnad *bnad, void *buffer, u32 len)\n{\n\tstruct bnad_drvinfo *drvinfo = (struct bnad_drvinfo *) buffer;\n\tstruct bnad_iocmd_comp fcomp;\n\tunsigned long flags = 0;\n\tint ret = BFA_STATUS_FAILED;\n\n\t \n\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\tbfa_nw_ioc_get_attr(&bnad->bna.ioceth.ioc, &drvinfo->ioc_attr);\n\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\n\t \n\tfcomp.bnad = bnad;\n\tfcomp.comp_status = 0;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\tret = bfa_nw_cee_get_attr(&bnad->bna.cee, &drvinfo->cee_attr,\n\t\t\t\tbnad_cb_completion, &fcomp);\n\tif (ret != BFA_STATUS_OK) {\n\t\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\t\tgoto out;\n\t}\n\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\twait_for_completion(&fcomp.comp);\n\tdrvinfo->cee_status = fcomp.comp_status;\n\n\t \n\tfcomp.comp_status = 0;\n\treinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\tret = bfa_nw_flash_get_attr(&bnad->bna.flash, &drvinfo->flash_attr,\n\t\t\t\tbnad_cb_completion, &fcomp);\n\tif (ret != BFA_STATUS_OK) {\n\t\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\t\tgoto out;\n\t}\n\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\twait_for_completion(&fcomp.comp);\n\tdrvinfo->flash_status = fcomp.comp_status;\nout:\n\treturn ret;\n}\n\nstatic int\nbnad_debugfs_open_drvinfo(struct inode *inode, struct file *file)\n{\n\tstruct bnad *bnad = inode->i_private;\n\tstruct bnad_debug_info *drv_info;\n\tint rc;\n\n\tdrv_info = kzalloc(sizeof(struct bnad_debug_info), GFP_KERNEL);\n\tif (!drv_info)\n\t\treturn -ENOMEM;\n\n\tdrv_info->buffer_len = sizeof(struct bnad_drvinfo);\n\n\tdrv_info->debug_buffer = kzalloc(drv_info->buffer_len, GFP_KERNEL);\n\tif (!drv_info->debug_buffer) {\n\t\tkfree(drv_info);\n\t\tdrv_info = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&bnad->conf_mutex);\n\trc = bnad_get_debug_drvinfo(bnad, drv_info->debug_buffer,\n\t\t\t\tdrv_info->buffer_len);\n\tmutex_unlock(&bnad->conf_mutex);\n\tif (rc != BFA_STATUS_OK) {\n\t\tkfree(drv_info->debug_buffer);\n\t\tdrv_info->debug_buffer = NULL;\n\t\tkfree(drv_info);\n\t\tdrv_info = NULL;\n\t\tnetdev_warn(bnad->netdev, \"failed to collect drvinfo\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfile->private_data = drv_info;\n\n\treturn 0;\n}\n\n \nstatic loff_t\nbnad_debugfs_lseek(struct file *file, loff_t offset, int orig)\n{\n\tstruct bnad_debug_info *debug = file->private_data;\n\n\tif (!debug)\n\t\treturn -EINVAL;\n\n\treturn fixed_size_llseek(file, offset, orig, debug->buffer_len);\n}\n\nstatic ssize_t\nbnad_debugfs_read(struct file *file, char __user *buf,\n\t\t  size_t nbytes, loff_t *pos)\n{\n\tstruct bnad_debug_info *debug = file->private_data;\n\n\tif (!debug || !debug->debug_buffer)\n\t\treturn 0;\n\n\treturn simple_read_from_buffer(buf, nbytes, pos,\n\t\t\t\tdebug->debug_buffer, debug->buffer_len);\n}\n\n#define BFA_REG_CT_ADDRSZ\t(0x40000)\n#define BFA_REG_CB_ADDRSZ\t(0x20000)\n#define BFA_REG_ADDRSZ(__ioc)\t\\\n\t((u32)(bfa_asic_id_ctc(bfa_ioc_devid(__ioc)) ?  \\\n\t BFA_REG_CT_ADDRSZ : BFA_REG_CB_ADDRSZ))\n#define BFA_REG_ADDRMSK(__ioc)\t(BFA_REG_ADDRSZ(__ioc) - 1)\n\n \nstatic int\nbna_reg_offset_check(struct bfa_ioc *ioc, u32 offset, u32 len)\n{\n\tu8 area;\n\n\t \n\tarea = (offset >> 15) & 0x7;\n\tif (area == 0) {\n\t\t \n\t\tif (offset + (len << 2) > 0x8000)\t \n\t\t\treturn BFA_STATUS_EINVAL;\n\t} else if (area == 0x1) {\n\t\t \n\t\tif (offset + (len << 2) > 0x10000)\t \n\t\t\treturn BFA_STATUS_EINVAL;\n\t} else {\n\t\t \n\t\tif (offset + (len << 2) > BFA_REG_ADDRMSK(ioc))\n\t\t\treturn BFA_STATUS_EINVAL;\n\t}\n\treturn BFA_STATUS_OK;\n}\n\nstatic ssize_t\nbnad_debugfs_read_regrd(struct file *file, char __user *buf,\n\t\t\tsize_t nbytes, loff_t *pos)\n{\n\tstruct bnad_debug_info *regrd_debug = file->private_data;\n\tstruct bnad *bnad = (struct bnad *)regrd_debug->i_private;\n\tssize_t rc;\n\n\tif (!bnad->regdata)\n\t\treturn 0;\n\n\trc = simple_read_from_buffer(buf, nbytes, pos,\n\t\t\tbnad->regdata, bnad->reglen);\n\n\tif ((*pos + nbytes) >= bnad->reglen) {\n\t\tkfree(bnad->regdata);\n\t\tbnad->regdata = NULL;\n\t\tbnad->reglen = 0;\n\t}\n\n\treturn rc;\n}\n\nstatic ssize_t\nbnad_debugfs_write_regrd(struct file *file, const char __user *buf,\n\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct bnad_debug_info *regrd_debug = file->private_data;\n\tstruct bnad *bnad = (struct bnad *)regrd_debug->i_private;\n\tstruct bfa_ioc *ioc = &bnad->bna.ioceth.ioc;\n\tint rc, i;\n\tu32 addr, len;\n\tu32 *regbuf;\n\tvoid __iomem *rb, *reg_addr;\n\tunsigned long flags;\n\tvoid *kern_buf;\n\n\t \n\tkern_buf = memdup_user(buf, nbytes);\n\tif (IS_ERR(kern_buf))\n\t\treturn PTR_ERR(kern_buf);\n\n\trc = sscanf(kern_buf, \"%x:%x\", &addr, &len);\n\tif (rc < 2 || len > UINT_MAX >> 2) {\n\t\tnetdev_warn(bnad->netdev, \"failed to read user buffer\\n\");\n\t\tkfree(kern_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tkfree(kern_buf);\n\tkfree(bnad->regdata);\n\tbnad->reglen = 0;\n\n\tbnad->regdata = kzalloc(len << 2, GFP_KERNEL);\n\tif (!bnad->regdata)\n\t\treturn -ENOMEM;\n\n\tbnad->reglen = len << 2;\n\trb = bfa_ioc_bar0(ioc);\n\taddr &= BFA_REG_ADDRMSK(ioc);\n\n\t \n\trc = bna_reg_offset_check(ioc, addr, len);\n\tif (rc) {\n\t\tnetdev_warn(bnad->netdev, \"failed reg offset check\\n\");\n\t\tkfree(bnad->regdata);\n\t\tbnad->regdata = NULL;\n\t\tbnad->reglen = 0;\n\t\treturn -EINVAL;\n\t}\n\n\treg_addr = rb + addr;\n\tregbuf =  (u32 *)bnad->regdata;\n\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\tfor (i = 0; i < len; i++) {\n\t\t*regbuf = readl(reg_addr);\n\t\tregbuf++;\n\t\treg_addr += sizeof(u32);\n\t}\n\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\n\treturn nbytes;\n}\n\nstatic ssize_t\nbnad_debugfs_write_regwr(struct file *file, const char __user *buf,\n\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct bnad_debug_info *debug = file->private_data;\n\tstruct bnad *bnad = (struct bnad *)debug->i_private;\n\tstruct bfa_ioc *ioc = &bnad->bna.ioceth.ioc;\n\tint rc;\n\tu32 addr, val;\n\tvoid __iomem *reg_addr;\n\tunsigned long flags;\n\tvoid *kern_buf;\n\n\t \n\tkern_buf = memdup_user(buf, nbytes);\n\tif (IS_ERR(kern_buf))\n\t\treturn PTR_ERR(kern_buf);\n\n\trc = sscanf(kern_buf, \"%x:%x\", &addr, &val);\n\tif (rc < 2) {\n\t\tnetdev_warn(bnad->netdev, \"failed to read user buffer\\n\");\n\t\tkfree(kern_buf);\n\t\treturn -EINVAL;\n\t}\n\tkfree(kern_buf);\n\n\taddr &= BFA_REG_ADDRMSK(ioc);  \n\n\t \n\trc = bna_reg_offset_check(ioc, addr, 1);\n\tif (rc) {\n\t\tnetdev_warn(bnad->netdev, \"failed reg offset check\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg_addr = (bfa_ioc_bar0(ioc)) + addr;\n\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\twritel(val, reg_addr);\n\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\n\treturn nbytes;\n}\n\nstatic int\nbnad_debugfs_release(struct inode *inode, struct file *file)\n{\n\tstruct bnad_debug_info *debug = file->private_data;\n\n\tif (!debug)\n\t\treturn 0;\n\n\tfile->private_data = NULL;\n\tkfree(debug);\n\treturn 0;\n}\n\nstatic int\nbnad_debugfs_buffer_release(struct inode *inode, struct file *file)\n{\n\tstruct bnad_debug_info *debug = file->private_data;\n\n\tif (!debug)\n\t\treturn 0;\n\n\tkfree(debug->debug_buffer);\n\n\tfile->private_data = NULL;\n\tkfree(debug);\n\tdebug = NULL;\n\treturn 0;\n}\n\nstatic const struct file_operations bnad_debugfs_op_fwtrc = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.open\t\t=\tbnad_debugfs_open_fwtrc,\n\t.llseek\t\t=\tbnad_debugfs_lseek,\n\t.read\t\t=\tbnad_debugfs_read,\n\t.release\t=\tbnad_debugfs_buffer_release,\n};\n\nstatic const struct file_operations bnad_debugfs_op_fwsave = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.open\t\t=\tbnad_debugfs_open_fwsave,\n\t.llseek\t\t=\tbnad_debugfs_lseek,\n\t.read\t\t=\tbnad_debugfs_read,\n\t.release\t=\tbnad_debugfs_buffer_release,\n};\n\nstatic const struct file_operations bnad_debugfs_op_regrd = {\n\t.owner\t\t=       THIS_MODULE,\n\t.open\t\t=\tbnad_debugfs_open_reg,\n\t.llseek\t\t=\tbnad_debugfs_lseek,\n\t.read\t\t=\tbnad_debugfs_read_regrd,\n\t.write\t\t=\tbnad_debugfs_write_regrd,\n\t.release\t=\tbnad_debugfs_release,\n};\n\nstatic const struct file_operations bnad_debugfs_op_regwr = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.open\t\t=\tbnad_debugfs_open_reg,\n\t.llseek\t\t=\tbnad_debugfs_lseek,\n\t.write\t\t=\tbnad_debugfs_write_regwr,\n\t.release\t=\tbnad_debugfs_release,\n};\n\nstatic const struct file_operations bnad_debugfs_op_drvinfo = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.open\t\t=\tbnad_debugfs_open_drvinfo,\n\t.llseek\t\t=\tbnad_debugfs_lseek,\n\t.read\t\t=\tbnad_debugfs_read,\n\t.release\t=\tbnad_debugfs_buffer_release,\n};\n\nstruct bnad_debugfs_entry {\n\tconst char *name;\n\tumode_t  mode;\n\tconst struct file_operations *fops;\n};\n\nstatic const struct bnad_debugfs_entry bnad_debugfs_files[] = {\n\t{ \"fwtrc\",  S_IFREG | 0444, &bnad_debugfs_op_fwtrc, },\n\t{ \"fwsave\", S_IFREG | 0444, &bnad_debugfs_op_fwsave, },\n\t{ \"regrd\",  S_IFREG | 0644, &bnad_debugfs_op_regrd, },\n\t{ \"regwr\",  S_IFREG | 0200, &bnad_debugfs_op_regwr, },\n\t{ \"drvinfo\", S_IFREG | 0444, &bnad_debugfs_op_drvinfo, },\n};\n\nstatic struct dentry *bna_debugfs_root;\nstatic atomic_t bna_debugfs_port_count;\n\n \nvoid\nbnad_debugfs_init(struct bnad *bnad)\n{\n\tconst struct bnad_debugfs_entry *file;\n\tchar name[64];\n\tint i;\n\n\t \n\tif (!bna_debugfs_root) {\n\t\tbna_debugfs_root = debugfs_create_dir(\"bna\", NULL);\n\t\tatomic_set(&bna_debugfs_port_count, 0);\n\t\tif (!bna_debugfs_root) {\n\t\t\tnetdev_warn(bnad->netdev,\n\t\t\t\t    \"debugfs root dir creation failed\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), \"pci_dev:%s\", pci_name(bnad->pcidev));\n\tif (!bnad->port_debugfs_root) {\n\t\tbnad->port_debugfs_root =\n\t\t\tdebugfs_create_dir(name, bna_debugfs_root);\n\n\t\tatomic_inc(&bna_debugfs_port_count);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(bnad_debugfs_files); i++) {\n\t\t\tfile = &bnad_debugfs_files[i];\n\t\t\tbnad->bnad_dentry_files[i] =\n\t\t\t\t\tdebugfs_create_file(file->name,\n\t\t\t\t\t\t\tfile->mode,\n\t\t\t\t\t\t\tbnad->port_debugfs_root,\n\t\t\t\t\t\t\tbnad,\n\t\t\t\t\t\t\tfile->fops);\n\t\t\tif (!bnad->bnad_dentry_files[i]) {\n\t\t\t\tnetdev_warn(bnad->netdev,\n\t\t\t\t\t    \"create %s entry failed\\n\",\n\t\t\t\t\t    file->name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid\nbnad_debugfs_uninit(struct bnad *bnad)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bnad_debugfs_files); i++) {\n\t\tif (bnad->bnad_dentry_files[i]) {\n\t\t\tdebugfs_remove(bnad->bnad_dentry_files[i]);\n\t\t\tbnad->bnad_dentry_files[i] = NULL;\n\t\t}\n\t}\n\n\t \n\tif (bnad->port_debugfs_root) {\n\t\tdebugfs_remove(bnad->port_debugfs_root);\n\t\tbnad->port_debugfs_root = NULL;\n\t\tatomic_dec(&bna_debugfs_port_count);\n\t}\n\n\t \n\tif (atomic_read(&bna_debugfs_port_count) == 0) {\n\t\tdebugfs_remove(bna_debugfs_root);\n\t\tbna_debugfs_root = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}