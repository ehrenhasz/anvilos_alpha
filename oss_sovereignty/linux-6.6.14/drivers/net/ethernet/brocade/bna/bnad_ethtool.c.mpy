{
  "module_name": "bnad_ethtool.c",
  "hash_id": "5ad9d358fcaeda0f7c99881b18ffac6e27e863089627ce02110d8d7c6e545c1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/brocade/bna/bnad_ethtool.c",
  "human_readable_source": "\n \n \n\n#include \"cna.h\"\n\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/ethtool.h>\n#include <linux/rtnetlink.h>\n\n#include \"bna.h\"\n\n#include \"bnad.h\"\n\n#define BNAD_NUM_TXF_COUNTERS 12\n#define BNAD_NUM_RXF_COUNTERS 10\n#define BNAD_NUM_CQ_COUNTERS (3 + 5)\n#define BNAD_NUM_RXQ_COUNTERS 7\n#define BNAD_NUM_TXQ_COUNTERS 5\n\nstatic const char *bnad_net_stats_strings[] = {\n\t\"rx_packets\",\n\t\"tx_packets\",\n\t\"rx_bytes\",\n\t\"tx_bytes\",\n\t\"rx_errors\",\n\t\"tx_errors\",\n\t\"rx_dropped\",\n\t\"tx_dropped\",\n\t\"multicast\",\n\t\"collisions\",\n\t\"rx_length_errors\",\n\t\"rx_crc_errors\",\n\t\"rx_frame_errors\",\n\t\"tx_fifo_errors\",\n\n\t\"netif_queue_stop\",\n\t\"netif_queue_wakeup\",\n\t\"netif_queue_stopped\",\n\t\"tso4\",\n\t\"tso6\",\n\t\"tso_err\",\n\t\"tcpcsum_offload\",\n\t\"udpcsum_offload\",\n\t\"csum_help\",\n\t\"tx_skb_too_short\",\n\t\"tx_skb_stopping\",\n\t\"tx_skb_max_vectors\",\n\t\"tx_skb_mss_too_long\",\n\t\"tx_skb_tso_too_short\",\n\t\"tx_skb_tso_prepare\",\n\t\"tx_skb_non_tso_too_long\",\n\t\"tx_skb_tcp_hdr\",\n\t\"tx_skb_udp_hdr\",\n\t\"tx_skb_csum_err\",\n\t\"tx_skb_headlen_too_long\",\n\t\"tx_skb_headlen_zero\",\n\t\"tx_skb_frag_zero\",\n\t\"tx_skb_len_mismatch\",\n\t\"tx_skb_map_failed\",\n\t\"hw_stats_updates\",\n\t\"netif_rx_dropped\",\n\n\t\"link_toggle\",\n\t\"cee_toggle\",\n\n\t\"rxp_info_alloc_failed\",\n\t\"mbox_intr_disabled\",\n\t\"mbox_intr_enabled\",\n\t\"tx_unmap_q_alloc_failed\",\n\t\"rx_unmap_q_alloc_failed\",\n\t\"rxbuf_alloc_failed\",\n\t\"rxbuf_map_failed\",\n\n\t\"mac_stats_clr_cnt\",\n\t\"mac_frame_64\",\n\t\"mac_frame_65_127\",\n\t\"mac_frame_128_255\",\n\t\"mac_frame_256_511\",\n\t\"mac_frame_512_1023\",\n\t\"mac_frame_1024_1518\",\n\t\"mac_frame_1518_1522\",\n\t\"mac_rx_bytes\",\n\t\"mac_rx_packets\",\n\t\"mac_rx_fcs_error\",\n\t\"mac_rx_multicast\",\n\t\"mac_rx_broadcast\",\n\t\"mac_rx_control_frames\",\n\t\"mac_rx_pause\",\n\t\"mac_rx_unknown_opcode\",\n\t\"mac_rx_alignment_error\",\n\t\"mac_rx_frame_length_error\",\n\t\"mac_rx_code_error\",\n\t\"mac_rx_carrier_sense_error\",\n\t\"mac_rx_undersize\",\n\t\"mac_rx_oversize\",\n\t\"mac_rx_fragments\",\n\t\"mac_rx_jabber\",\n\t\"mac_rx_drop\",\n\n\t\"mac_tx_bytes\",\n\t\"mac_tx_packets\",\n\t\"mac_tx_multicast\",\n\t\"mac_tx_broadcast\",\n\t\"mac_tx_pause\",\n\t\"mac_tx_deferral\",\n\t\"mac_tx_excessive_deferral\",\n\t\"mac_tx_single_collision\",\n\t\"mac_tx_multiple_collision\",\n\t\"mac_tx_late_collision\",\n\t\"mac_tx_excessive_collision\",\n\t\"mac_tx_total_collision\",\n\t\"mac_tx_pause_honored\",\n\t\"mac_tx_drop\",\n\t\"mac_tx_jabber\",\n\t\"mac_tx_fcs_error\",\n\t\"mac_tx_control_frame\",\n\t\"mac_tx_oversize\",\n\t\"mac_tx_undersize\",\n\t\"mac_tx_fragments\",\n\n\t\"bpc_tx_pause_0\",\n\t\"bpc_tx_pause_1\",\n\t\"bpc_tx_pause_2\",\n\t\"bpc_tx_pause_3\",\n\t\"bpc_tx_pause_4\",\n\t\"bpc_tx_pause_5\",\n\t\"bpc_tx_pause_6\",\n\t\"bpc_tx_pause_7\",\n\t\"bpc_tx_zero_pause_0\",\n\t\"bpc_tx_zero_pause_1\",\n\t\"bpc_tx_zero_pause_2\",\n\t\"bpc_tx_zero_pause_3\",\n\t\"bpc_tx_zero_pause_4\",\n\t\"bpc_tx_zero_pause_5\",\n\t\"bpc_tx_zero_pause_6\",\n\t\"bpc_tx_zero_pause_7\",\n\t\"bpc_tx_first_pause_0\",\n\t\"bpc_tx_first_pause_1\",\n\t\"bpc_tx_first_pause_2\",\n\t\"bpc_tx_first_pause_3\",\n\t\"bpc_tx_first_pause_4\",\n\t\"bpc_tx_first_pause_5\",\n\t\"bpc_tx_first_pause_6\",\n\t\"bpc_tx_first_pause_7\",\n\n\t\"bpc_rx_pause_0\",\n\t\"bpc_rx_pause_1\",\n\t\"bpc_rx_pause_2\",\n\t\"bpc_rx_pause_3\",\n\t\"bpc_rx_pause_4\",\n\t\"bpc_rx_pause_5\",\n\t\"bpc_rx_pause_6\",\n\t\"bpc_rx_pause_7\",\n\t\"bpc_rx_zero_pause_0\",\n\t\"bpc_rx_zero_pause_1\",\n\t\"bpc_rx_zero_pause_2\",\n\t\"bpc_rx_zero_pause_3\",\n\t\"bpc_rx_zero_pause_4\",\n\t\"bpc_rx_zero_pause_5\",\n\t\"bpc_rx_zero_pause_6\",\n\t\"bpc_rx_zero_pause_7\",\n\t\"bpc_rx_first_pause_0\",\n\t\"bpc_rx_first_pause_1\",\n\t\"bpc_rx_first_pause_2\",\n\t\"bpc_rx_first_pause_3\",\n\t\"bpc_rx_first_pause_4\",\n\t\"bpc_rx_first_pause_5\",\n\t\"bpc_rx_first_pause_6\",\n\t\"bpc_rx_first_pause_7\",\n\n\t\"rad_rx_frames\",\n\t\"rad_rx_octets\",\n\t\"rad_rx_vlan_frames\",\n\t\"rad_rx_ucast\",\n\t\"rad_rx_ucast_octets\",\n\t\"rad_rx_ucast_vlan\",\n\t\"rad_rx_mcast\",\n\t\"rad_rx_mcast_octets\",\n\t\"rad_rx_mcast_vlan\",\n\t\"rad_rx_bcast\",\n\t\"rad_rx_bcast_octets\",\n\t\"rad_rx_bcast_vlan\",\n\t\"rad_rx_drops\",\n\n\t\"rlb_rad_rx_frames\",\n\t\"rlb_rad_rx_octets\",\n\t\"rlb_rad_rx_vlan_frames\",\n\t\"rlb_rad_rx_ucast\",\n\t\"rlb_rad_rx_ucast_octets\",\n\t\"rlb_rad_rx_ucast_vlan\",\n\t\"rlb_rad_rx_mcast\",\n\t\"rlb_rad_rx_mcast_octets\",\n\t\"rlb_rad_rx_mcast_vlan\",\n\t\"rlb_rad_rx_bcast\",\n\t\"rlb_rad_rx_bcast_octets\",\n\t\"rlb_rad_rx_bcast_vlan\",\n\t\"rlb_rad_rx_drops\",\n\n\t\"fc_rx_ucast_octets\",\n\t\"fc_rx_ucast\",\n\t\"fc_rx_ucast_vlan\",\n\t\"fc_rx_mcast_octets\",\n\t\"fc_rx_mcast\",\n\t\"fc_rx_mcast_vlan\",\n\t\"fc_rx_bcast_octets\",\n\t\"fc_rx_bcast\",\n\t\"fc_rx_bcast_vlan\",\n\n\t\"fc_tx_ucast_octets\",\n\t\"fc_tx_ucast\",\n\t\"fc_tx_ucast_vlan\",\n\t\"fc_tx_mcast_octets\",\n\t\"fc_tx_mcast\",\n\t\"fc_tx_mcast_vlan\",\n\t\"fc_tx_bcast_octets\",\n\t\"fc_tx_bcast\",\n\t\"fc_tx_bcast_vlan\",\n\t\"fc_tx_parity_errors\",\n\t\"fc_tx_timeout\",\n\t\"fc_tx_fid_parity_errors\",\n};\n\n#define BNAD_ETHTOOL_STATS_NUM\tARRAY_SIZE(bnad_net_stats_strings)\n\nstatic int\nbnad_get_link_ksettings(struct net_device *netdev,\n\t\t\tstruct ethtool_link_ksettings *cmd)\n{\n\tethtool_link_ksettings_zero_link_mode(cmd, supported);\n\tethtool_link_ksettings_zero_link_mode(cmd, advertising);\n\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 10000baseCR_Full);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 10000baseSR_Full);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 10000baseLR_Full);\n\tethtool_link_ksettings_add_link_mode(cmd, advertising, 10000baseCR_Full);\n\tethtool_link_ksettings_add_link_mode(cmd, advertising, 10000baseSR_Full);\n\tethtool_link_ksettings_add_link_mode(cmd, advertising, 10000baseLR_Full);\n\tcmd->base.autoneg = AUTONEG_DISABLE;\n\tethtool_link_ksettings_add_link_mode(cmd, supported, FIBRE);\n\tethtool_link_ksettings_add_link_mode(cmd, advertising, FIBRE);\n\tcmd->base.port = PORT_FIBRE;\n\tcmd->base.phy_address = 0;\n\n\tif (netif_carrier_ok(netdev)) {\n\t\tcmd->base.speed = SPEED_10000;\n\t\tcmd->base.duplex = DUPLEX_FULL;\n\t} else {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbnad_set_link_ksettings(struct net_device *netdev,\n\t\t\tconst struct ethtool_link_ksettings *cmd)\n{\n\t \n\tif (cmd->base.autoneg == AUTONEG_ENABLE)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((cmd->base.speed == SPEED_10000) &&\n\t    (cmd->base.duplex == DUPLEX_FULL))\n\t\treturn 0;\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void\nbnad_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *drvinfo)\n{\n\tstruct bnad *bnad = netdev_priv(netdev);\n\tstruct bfa_ioc_attr *ioc_attr;\n\tunsigned long flags;\n\n\tstrscpy(drvinfo->driver, BNAD_NAME, sizeof(drvinfo->driver));\n\n\tioc_attr = kzalloc(sizeof(*ioc_attr), GFP_KERNEL);\n\tif (ioc_attr) {\n\t\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\t\tbfa_nw_ioc_get_attr(&bnad->bna.ioceth.ioc, ioc_attr);\n\t\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\n\t\tstrscpy(drvinfo->fw_version, ioc_attr->adapter_attr.fw_ver,\n\t\t\tsizeof(drvinfo->fw_version));\n\t\tkfree(ioc_attr);\n\t}\n\n\tstrscpy(drvinfo->bus_info, pci_name(bnad->pcidev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic void\nbnad_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wolinfo)\n{\n\twolinfo->supported = 0;\n\twolinfo->wolopts = 0;\n}\n\nstatic int bnad_get_coalesce(struct net_device *netdev,\n\t\t\t     struct ethtool_coalesce *coalesce,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct bnad *bnad = netdev_priv(netdev);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\tcoalesce->use_adaptive_rx_coalesce =\n\t\t(bnad->cfg_flags & BNAD_CF_DIM_ENABLED) ? true : false;\n\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\n\tcoalesce->rx_coalesce_usecs = bnad->rx_coalescing_timeo *\n\t\t\t\t\tBFI_COALESCING_TIMER_UNIT;\n\tcoalesce->tx_coalesce_usecs = bnad->tx_coalescing_timeo *\n\t\t\t\t\tBFI_COALESCING_TIMER_UNIT;\n\tcoalesce->tx_max_coalesced_frames = BFI_TX_INTERPKT_COUNT;\n\n\treturn 0;\n}\n\nstatic int bnad_set_coalesce(struct net_device *netdev,\n\t\t\t     struct ethtool_coalesce *coalesce,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct bnad *bnad = netdev_priv(netdev);\n\tunsigned long flags;\n\tint to_del = 0;\n\n\tif (coalesce->rx_coalesce_usecs == 0 ||\n\t    coalesce->rx_coalesce_usecs >\n\t    BFI_MAX_COALESCING_TIMEO * BFI_COALESCING_TIMER_UNIT)\n\t\treturn -EINVAL;\n\n\tif (coalesce->tx_coalesce_usecs == 0 ||\n\t    coalesce->tx_coalesce_usecs >\n\t    BFI_MAX_COALESCING_TIMEO * BFI_COALESCING_TIMER_UNIT)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&bnad->conf_mutex);\n\t \n\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\tif (coalesce->use_adaptive_rx_coalesce) {\n\t\tif (!(bnad->cfg_flags & BNAD_CF_DIM_ENABLED)) {\n\t\t\tbnad->cfg_flags |= BNAD_CF_DIM_ENABLED;\n\t\t\tbnad_dim_timer_start(bnad);\n\t\t}\n\t} else {\n\t\tif (bnad->cfg_flags & BNAD_CF_DIM_ENABLED) {\n\t\t\tbnad->cfg_flags &= ~BNAD_CF_DIM_ENABLED;\n\t\t\tif (bnad->cfg_flags & BNAD_CF_DIM_ENABLED &&\n\t\t\t    test_bit(BNAD_RF_DIM_TIMER_RUNNING,\n\t\t\t    &bnad->run_flags)) {\n\t\t\t\tclear_bit(BNAD_RF_DIM_TIMER_RUNNING,\n\t\t\t\t\t\t\t&bnad->run_flags);\n\t\t\t\tto_del = 1;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\t\t\tif (to_del)\n\t\t\t\tdel_timer_sync(&bnad->dim_timer);\n\t\t\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\t\t\tbnad_rx_coalescing_timeo_set(bnad);\n\t\t}\n\t}\n\tif (bnad->tx_coalescing_timeo != coalesce->tx_coalesce_usecs /\n\t\t\t\t\tBFI_COALESCING_TIMER_UNIT) {\n\t\tbnad->tx_coalescing_timeo = coalesce->tx_coalesce_usecs /\n\t\t\t\t\t\tBFI_COALESCING_TIMER_UNIT;\n\t\tbnad_tx_coalescing_timeo_set(bnad);\n\t}\n\n\tif (bnad->rx_coalescing_timeo != coalesce->rx_coalesce_usecs /\n\t\t\t\t\tBFI_COALESCING_TIMER_UNIT) {\n\t\tbnad->rx_coalescing_timeo = coalesce->rx_coalesce_usecs /\n\t\t\t\t\t\tBFI_COALESCING_TIMER_UNIT;\n\n\t\tif (!(bnad->cfg_flags & BNAD_CF_DIM_ENABLED))\n\t\t\tbnad_rx_coalescing_timeo_set(bnad);\n\n\t}\n\n\t \n\n\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\n\tmutex_unlock(&bnad->conf_mutex);\n\treturn 0;\n}\n\nstatic void\nbnad_get_ringparam(struct net_device *netdev,\n\t\t   struct ethtool_ringparam *ringparam,\n\t\t   struct kernel_ethtool_ringparam *kernel_ringparam,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct bnad *bnad = netdev_priv(netdev);\n\n\tringparam->rx_max_pending = BNAD_MAX_RXQ_DEPTH;\n\tringparam->tx_max_pending = BNAD_MAX_TXQ_DEPTH;\n\n\tringparam->rx_pending = bnad->rxq_depth;\n\tringparam->tx_pending = bnad->txq_depth;\n}\n\nstatic int\nbnad_set_ringparam(struct net_device *netdev,\n\t\t   struct ethtool_ringparam *ringparam,\n\t\t   struct kernel_ethtool_ringparam *kernel_ringparam,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tint i, current_err, err = 0;\n\tstruct bnad *bnad = netdev_priv(netdev);\n\tunsigned long flags;\n\n\tmutex_lock(&bnad->conf_mutex);\n\tif (ringparam->rx_pending == bnad->rxq_depth &&\n\t    ringparam->tx_pending == bnad->txq_depth) {\n\t\tmutex_unlock(&bnad->conf_mutex);\n\t\treturn 0;\n\t}\n\n\tif (ringparam->rx_pending < BNAD_MIN_Q_DEPTH ||\n\t    ringparam->rx_pending > BNAD_MAX_RXQ_DEPTH ||\n\t    !is_power_of_2(ringparam->rx_pending)) {\n\t\tmutex_unlock(&bnad->conf_mutex);\n\t\treturn -EINVAL;\n\t}\n\tif (ringparam->tx_pending < BNAD_MIN_Q_DEPTH ||\n\t    ringparam->tx_pending > BNAD_MAX_TXQ_DEPTH ||\n\t    !is_power_of_2(ringparam->tx_pending)) {\n\t\tmutex_unlock(&bnad->conf_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ringparam->rx_pending != bnad->rxq_depth) {\n\t\tbnad->rxq_depth = ringparam->rx_pending;\n\t\tif (!netif_running(netdev)) {\n\t\t\tmutex_unlock(&bnad->conf_mutex);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (i = 0; i < bnad->num_rx; i++) {\n\t\t\tif (!bnad->rx_info[i].rx)\n\t\t\t\tcontinue;\n\t\t\tbnad_destroy_rx(bnad, i);\n\t\t\tcurrent_err = bnad_setup_rx(bnad, i);\n\t\t\tif (current_err && !err)\n\t\t\t\terr = current_err;\n\t\t}\n\n\t\tif (!err && bnad->rx_info[0].rx) {\n\t\t\t \n\t\t\tbnad_restore_vlans(bnad, 0);\n\t\t\tbnad_enable_default_bcast(bnad);\n\t\t\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\t\t\tbnad_mac_addr_set_locked(bnad, netdev->dev_addr);\n\t\t\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\t\t\tbnad->cfg_flags &= ~(BNAD_CF_ALLMULTI |\n\t\t\t\t\t     BNAD_CF_PROMISC);\n\t\t\tbnad_set_rx_mode(netdev);\n\t\t}\n\t}\n\tif (ringparam->tx_pending != bnad->txq_depth) {\n\t\tbnad->txq_depth = ringparam->tx_pending;\n\t\tif (!netif_running(netdev)) {\n\t\t\tmutex_unlock(&bnad->conf_mutex);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (i = 0; i < bnad->num_tx; i++) {\n\t\t\tif (!bnad->tx_info[i].tx)\n\t\t\t\tcontinue;\n\t\t\tbnad_destroy_tx(bnad, i);\n\t\t\tcurrent_err = bnad_setup_tx(bnad, i);\n\t\t\tif (current_err && !err)\n\t\t\t\terr = current_err;\n\t\t}\n\t}\n\n\tmutex_unlock(&bnad->conf_mutex);\n\treturn err;\n}\n\nstatic void\nbnad_get_pauseparam(struct net_device *netdev,\n\t\t    struct ethtool_pauseparam *pauseparam)\n{\n\tstruct bnad *bnad = netdev_priv(netdev);\n\n\tpauseparam->autoneg = 0;\n\tpauseparam->rx_pause = bnad->bna.enet.pause_config.rx_pause;\n\tpauseparam->tx_pause = bnad->bna.enet.pause_config.tx_pause;\n}\n\nstatic int\nbnad_set_pauseparam(struct net_device *netdev,\n\t\t    struct ethtool_pauseparam *pauseparam)\n{\n\tstruct bnad *bnad = netdev_priv(netdev);\n\tstruct bna_pause_config pause_config;\n\tunsigned long flags;\n\n\tif (pauseparam->autoneg == AUTONEG_ENABLE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&bnad->conf_mutex);\n\tif (pauseparam->rx_pause != bnad->bna.enet.pause_config.rx_pause ||\n\t    pauseparam->tx_pause != bnad->bna.enet.pause_config.tx_pause) {\n\t\tpause_config.rx_pause = pauseparam->rx_pause;\n\t\tpause_config.tx_pause = pauseparam->tx_pause;\n\t\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\t\tbna_enet_pause_config(&bnad->bna.enet, &pause_config);\n\t\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\t}\n\tmutex_unlock(&bnad->conf_mutex);\n\treturn 0;\n}\n\nstatic void bnad_get_txf_strings(u8 **string, int f_num)\n{\n\tethtool_sprintf(string, \"txf%d_ucast_octets\", f_num);\n\tethtool_sprintf(string, \"txf%d_ucast\", f_num);\n\tethtool_sprintf(string, \"txf%d_ucast_vlan\", f_num);\n\tethtool_sprintf(string, \"txf%d_mcast_octets\", f_num);\n\tethtool_sprintf(string, \"txf%d_mcast\", f_num);\n\tethtool_sprintf(string, \"txf%d_mcast_vlan\", f_num);\n\tethtool_sprintf(string, \"txf%d_bcast_octets\", f_num);\n\tethtool_sprintf(string, \"txf%d_bcast\", f_num);\n\tethtool_sprintf(string, \"txf%d_bcast_vlan\", f_num);\n\tethtool_sprintf(string, \"txf%d_errors\", f_num);\n\tethtool_sprintf(string, \"txf%d_filter_vlan\", f_num);\n\tethtool_sprintf(string, \"txf%d_filter_mac_sa\", f_num);\n}\n\nstatic void bnad_get_rxf_strings(u8 **string, int f_num)\n{\n\tethtool_sprintf(string, \"rxf%d_ucast_octets\", f_num);\n\tethtool_sprintf(string, \"rxf%d_ucast\", f_num);\n\tethtool_sprintf(string, \"rxf%d_ucast_vlan\", f_num);\n\tethtool_sprintf(string, \"rxf%d_mcast_octets\", f_num);\n\tethtool_sprintf(string, \"rxf%d_mcast\", f_num);\n\tethtool_sprintf(string, \"rxf%d_mcast_vlan\", f_num);\n\tethtool_sprintf(string, \"rxf%d_bcast_octets\", f_num);\n\tethtool_sprintf(string, \"rxf%d_bcast\", f_num);\n\tethtool_sprintf(string, \"rxf%d_bcast_vlan\", f_num);\n\tethtool_sprintf(string, \"rxf%d_frame_drops\", f_num);\n}\n\nstatic void bnad_get_cq_strings(u8 **string, int q_num)\n{\n\tethtool_sprintf(string, \"cq%d_producer_index\", q_num);\n\tethtool_sprintf(string, \"cq%d_consumer_index\", q_num);\n\tethtool_sprintf(string, \"cq%d_hw_producer_index\", q_num);\n\tethtool_sprintf(string, \"cq%d_intr\", q_num);\n\tethtool_sprintf(string, \"cq%d_poll\", q_num);\n\tethtool_sprintf(string, \"cq%d_schedule\", q_num);\n\tethtool_sprintf(string, \"cq%d_keep_poll\", q_num);\n\tethtool_sprintf(string, \"cq%d_complete\", q_num);\n}\n\nstatic void bnad_get_rxq_strings(u8 **string, int q_num)\n{\n\tethtool_sprintf(string, \"rxq%d_packets\", q_num);\n\tethtool_sprintf(string, \"rxq%d_bytes\", q_num);\n\tethtool_sprintf(string, \"rxq%d_packets_with_error\", q_num);\n\tethtool_sprintf(string, \"rxq%d_allocbuf_failed\", q_num);\n\tethtool_sprintf(string, \"rxq%d_mapbuf_failed\", q_num);\n\tethtool_sprintf(string, \"rxq%d_producer_index\", q_num);\n\tethtool_sprintf(string, \"rxq%d_consumer_index\", q_num);\n}\n\nstatic void bnad_get_txq_strings(u8 **string, int q_num)\n{\n\tethtool_sprintf(string, \"txq%d_packets\", q_num);\n\tethtool_sprintf(string, \"txq%d_bytes\", q_num);\n\tethtool_sprintf(string, \"txq%d_producer_index\", q_num);\n\tethtool_sprintf(string, \"txq%d_consumer_index\", q_num);\n\tethtool_sprintf(string, \"txq%d_hw_consumer_index\", q_num);\n}\n\nstatic void\nbnad_get_strings(struct net_device *netdev, u32 stringset, u8 *string)\n{\n\tstruct bnad *bnad = netdev_priv(netdev);\n\tint i, j, q_num;\n\tu32 bmap;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tmutex_lock(&bnad->conf_mutex);\n\n\tfor (i = 0; i < BNAD_ETHTOOL_STATS_NUM; i++) {\n\t\tBUG_ON(!(strlen(bnad_net_stats_strings[i]) < ETH_GSTRING_LEN));\n\t\tethtool_sprintf(&string, bnad_net_stats_strings[i]);\n\t}\n\n\tbmap = bna_tx_rid_mask(&bnad->bna);\n\tfor (i = 0; bmap; i++) {\n\t\tif (bmap & 1)\n\t\t\tbnad_get_txf_strings(&string, i);\n\t\tbmap >>= 1;\n\t}\n\n\tbmap = bna_rx_rid_mask(&bnad->bna);\n\tfor (i = 0; bmap; i++, bmap >>= 1) {\n\t\tif (bmap & 1)\n\t\t\tbnad_get_rxf_strings(&string, i);\n\t\tbmap >>= 1;\n\t}\n\n\tq_num = 0;\n\tfor (i = 0; i < bnad->num_rx; i++) {\n\t\tif (!bnad->rx_info[i].rx)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < bnad->num_rxp_per_rx; j++)\n\t\t\tbnad_get_cq_strings(&string, q_num++);\n\t}\n\n\tq_num = 0;\n\tfor (i = 0; i < bnad->num_rx; i++) {\n\t\tif (!bnad->rx_info[i].rx)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < bnad->num_rxp_per_rx; j++) {\n\t\t\tbnad_get_rxq_strings(&string, q_num++);\n\t\t\tif (bnad->rx_info[i].rx_ctrl[j].ccb &&\n\t\t\t    bnad->rx_info[i].rx_ctrl[j].ccb->rcb[1] &&\n\t\t\t    bnad->rx_info[i].rx_ctrl[j].ccb->rcb[1]->rxq)\n\t\t\t\tbnad_get_rxq_strings(&string, q_num++);\n\t\t}\n\t}\n\n\tq_num = 0;\n\tfor (i = 0; i < bnad->num_tx; i++) {\n\t\tif (!bnad->tx_info[i].tx)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < bnad->num_txq_per_tx; j++)\n\t\t\tbnad_get_txq_strings(&string, q_num++);\n\t}\n\n\tmutex_unlock(&bnad->conf_mutex);\n}\n\nstatic int\nbnad_get_stats_count_locked(struct net_device *netdev)\n{\n\tstruct bnad *bnad = netdev_priv(netdev);\n\tint i, j, count = 0, rxf_active_num = 0, txf_active_num = 0;\n\tu32 bmap;\n\n\tbmap = bna_tx_rid_mask(&bnad->bna);\n\tfor (i = 0; bmap; i++) {\n\t\tif (bmap & 1)\n\t\t\ttxf_active_num++;\n\t\tbmap >>= 1;\n\t}\n\tbmap = bna_rx_rid_mask(&bnad->bna);\n\tfor (i = 0; bmap; i++) {\n\t\tif (bmap & 1)\n\t\t\trxf_active_num++;\n\t\tbmap >>= 1;\n\t}\n\tcount = BNAD_ETHTOOL_STATS_NUM +\n\t\ttxf_active_num * BNAD_NUM_TXF_COUNTERS +\n\t\trxf_active_num * BNAD_NUM_RXF_COUNTERS;\n\n\tfor (i = 0; i < bnad->num_rx; i++) {\n\t\tif (!bnad->rx_info[i].rx)\n\t\t\tcontinue;\n\t\tcount += bnad->num_rxp_per_rx * BNAD_NUM_CQ_COUNTERS;\n\t\tcount += bnad->num_rxp_per_rx * BNAD_NUM_RXQ_COUNTERS;\n\t\tfor (j = 0; j < bnad->num_rxp_per_rx; j++)\n\t\t\tif (bnad->rx_info[i].rx_ctrl[j].ccb &&\n\t\t\t\tbnad->rx_info[i].rx_ctrl[j].ccb->rcb[1] &&\n\t\t\t\tbnad->rx_info[i].rx_ctrl[j].ccb->rcb[1]->rxq)\n\t\t\t\tcount +=  BNAD_NUM_RXQ_COUNTERS;\n\t}\n\n\tfor (i = 0; i < bnad->num_tx; i++) {\n\t\tif (!bnad->tx_info[i].tx)\n\t\t\tcontinue;\n\t\tcount += bnad->num_txq_per_tx * BNAD_NUM_TXQ_COUNTERS;\n\t}\n\treturn count;\n}\n\nstatic int\nbnad_per_q_stats_fill(struct bnad *bnad, u64 *buf, int bi)\n{\n\tint i, j;\n\tstruct bna_rcb *rcb = NULL;\n\tstruct bna_tcb *tcb = NULL;\n\n\tfor (i = 0; i < bnad->num_rx; i++) {\n\t\tif (!bnad->rx_info[i].rx)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < bnad->num_rxp_per_rx; j++)\n\t\t\tif (bnad->rx_info[i].rx_ctrl[j].ccb &&\n\t\t\t\tbnad->rx_info[i].rx_ctrl[j].ccb->rcb[0] &&\n\t\t\t\tbnad->rx_info[i].rx_ctrl[j].ccb->rcb[0]->rxq) {\n\t\t\t\tbuf[bi++] = bnad->rx_info[i].rx_ctrl[j].\n\t\t\t\t\t\tccb->producer_index;\n\t\t\t\tbuf[bi++] = 0;  \n\t\t\t\tbuf[bi++] = *(bnad->rx_info[i].rx_ctrl[j].\n\t\t\t\t\t\tccb->hw_producer_index);\n\n\t\t\t\tbuf[bi++] = bnad->rx_info[i].\n\t\t\t\t\t\trx_ctrl[j].rx_intr_ctr;\n\t\t\t\tbuf[bi++] = bnad->rx_info[i].\n\t\t\t\t\t\trx_ctrl[j].rx_poll_ctr;\n\t\t\t\tbuf[bi++] = bnad->rx_info[i].\n\t\t\t\t\t\trx_ctrl[j].rx_schedule;\n\t\t\t\tbuf[bi++] = bnad->rx_info[i].\n\t\t\t\t\t\trx_ctrl[j].rx_keep_poll;\n\t\t\t\tbuf[bi++] = bnad->rx_info[i].\n\t\t\t\t\t\trx_ctrl[j].rx_complete;\n\t\t\t}\n\t}\n\tfor (i = 0; i < bnad->num_rx; i++) {\n\t\tif (!bnad->rx_info[i].rx)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < bnad->num_rxp_per_rx; j++)\n\t\t\tif (bnad->rx_info[i].rx_ctrl[j].ccb) {\n\t\t\t\tif (bnad->rx_info[i].rx_ctrl[j].ccb->rcb[0] &&\n\t\t\t\t\tbnad->rx_info[i].rx_ctrl[j].ccb->\n\t\t\t\t\trcb[0]->rxq) {\n\t\t\t\t\trcb = bnad->rx_info[i].rx_ctrl[j].\n\t\t\t\t\t\t\tccb->rcb[0];\n\t\t\t\t\tbuf[bi++] = rcb->rxq->rx_packets;\n\t\t\t\t\tbuf[bi++] = rcb->rxq->rx_bytes;\n\t\t\t\t\tbuf[bi++] = rcb->rxq->\n\t\t\t\t\t\t\trx_packets_with_error;\n\t\t\t\t\tbuf[bi++] = rcb->rxq->\n\t\t\t\t\t\t\trxbuf_alloc_failed;\n\t\t\t\t\tbuf[bi++] = rcb->rxq->rxbuf_map_failed;\n\t\t\t\t\tbuf[bi++] = rcb->producer_index;\n\t\t\t\t\tbuf[bi++] = rcb->consumer_index;\n\t\t\t\t}\n\t\t\t\tif (bnad->rx_info[i].rx_ctrl[j].ccb->rcb[1] &&\n\t\t\t\t\tbnad->rx_info[i].rx_ctrl[j].ccb->\n\t\t\t\t\trcb[1]->rxq) {\n\t\t\t\t\trcb = bnad->rx_info[i].rx_ctrl[j].\n\t\t\t\t\t\t\t\tccb->rcb[1];\n\t\t\t\t\tbuf[bi++] = rcb->rxq->rx_packets;\n\t\t\t\t\tbuf[bi++] = rcb->rxq->rx_bytes;\n\t\t\t\t\tbuf[bi++] = rcb->rxq->\n\t\t\t\t\t\t\trx_packets_with_error;\n\t\t\t\t\tbuf[bi++] = rcb->rxq->\n\t\t\t\t\t\t\trxbuf_alloc_failed;\n\t\t\t\t\tbuf[bi++] = rcb->rxq->rxbuf_map_failed;\n\t\t\t\t\tbuf[bi++] = rcb->producer_index;\n\t\t\t\t\tbuf[bi++] = rcb->consumer_index;\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tfor (i = 0; i < bnad->num_tx; i++) {\n\t\tif (!bnad->tx_info[i].tx)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < bnad->num_txq_per_tx; j++)\n\t\t\tif (bnad->tx_info[i].tcb[j] &&\n\t\t\t\tbnad->tx_info[i].tcb[j]->txq) {\n\t\t\t\ttcb = bnad->tx_info[i].tcb[j];\n\t\t\t\tbuf[bi++] = tcb->txq->tx_packets;\n\t\t\t\tbuf[bi++] = tcb->txq->tx_bytes;\n\t\t\t\tbuf[bi++] = tcb->producer_index;\n\t\t\t\tbuf[bi++] = tcb->consumer_index;\n\t\t\t\tbuf[bi++] = *(tcb->hw_consumer_index);\n\t\t\t}\n\t}\n\n\treturn bi;\n}\n\nstatic void\nbnad_get_ethtool_stats(struct net_device *netdev, struct ethtool_stats *stats,\n\t\t       u64 *buf)\n{\n\tstruct bnad *bnad = netdev_priv(netdev);\n\tint i, j, bi = 0;\n\tunsigned long flags;\n\tstruct rtnl_link_stats64 net_stats64;\n\tu64 *stats64;\n\tu32 bmap;\n\n\tmutex_lock(&bnad->conf_mutex);\n\tif (bnad_get_stats_count_locked(netdev) != stats->n_stats) {\n\t\tmutex_unlock(&bnad->conf_mutex);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\n\tmemset(&net_stats64, 0, sizeof(net_stats64));\n\tbnad_netdev_qstats_fill(bnad, &net_stats64);\n\tbnad_netdev_hwstats_fill(bnad, &net_stats64);\n\n\tbuf[bi++] = net_stats64.rx_packets;\n\tbuf[bi++] = net_stats64.tx_packets;\n\tbuf[bi++] = net_stats64.rx_bytes;\n\tbuf[bi++] = net_stats64.tx_bytes;\n\tbuf[bi++] = net_stats64.rx_errors;\n\tbuf[bi++] = net_stats64.tx_errors;\n\tbuf[bi++] = net_stats64.rx_dropped;\n\tbuf[bi++] = net_stats64.tx_dropped;\n\tbuf[bi++] = net_stats64.multicast;\n\tbuf[bi++] = net_stats64.collisions;\n\tbuf[bi++] = net_stats64.rx_length_errors;\n\tbuf[bi++] = net_stats64.rx_crc_errors;\n\tbuf[bi++] = net_stats64.rx_frame_errors;\n\tbuf[bi++] = net_stats64.tx_fifo_errors;\n\n\t \n\tbnad->stats.drv_stats.netif_queue_stopped = netif_queue_stopped(netdev);\n\n\t \n\tstats64 = (u64 *)&bnad->stats.drv_stats;\n\tfor (i = 0; i < sizeof(struct bnad_drv_stats) / sizeof(u64); i++)\n\t\tbuf[bi++] = stats64[i];\n\n\t \n\tstats64 = (u64 *) &bnad->stats.bna_stats->hw_stats;\n\tfor (i = 0;\n\t     i < offsetof(struct bfi_enet_stats, rxf_stats[0]) /\n\t\tsizeof(u64);\n\t     i++)\n\t\tbuf[bi++] = stats64[i];\n\n\t \n\tbmap = bna_tx_rid_mask(&bnad->bna);\n\tfor (i = 0; bmap; i++) {\n\t\tif (bmap & 1) {\n\t\t\tstats64 = (u64 *)&bnad->stats.bna_stats->\n\t\t\t\t\t\thw_stats.txf_stats[i];\n\t\t\tfor (j = 0; j < sizeof(struct bfi_enet_stats_txf) /\n\t\t\t\t\tsizeof(u64); j++)\n\t\t\t\tbuf[bi++] = stats64[j];\n\t\t}\n\t\tbmap >>= 1;\n\t}\n\n\t \n\tbmap = bna_rx_rid_mask(&bnad->bna);\n\tfor (i = 0; bmap; i++) {\n\t\tif (bmap & 1) {\n\t\t\tstats64 = (u64 *)&bnad->stats.bna_stats->\n\t\t\t\t\t\thw_stats.rxf_stats[i];\n\t\t\tfor (j = 0; j < sizeof(struct bfi_enet_stats_rxf) /\n\t\t\t\t\tsizeof(u64); j++)\n\t\t\t\tbuf[bi++] = stats64[j];\n\t\t}\n\t\tbmap >>= 1;\n\t}\n\n\t \n\tbi = bnad_per_q_stats_fill(bnad, buf, bi);\n\n\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\n\tmutex_unlock(&bnad->conf_mutex);\n}\n\nstatic int\nbnad_get_sset_count(struct net_device *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn bnad_get_stats_count_locked(netdev);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic u32\nbnad_get_flash_partition_by_offset(struct bnad *bnad, u32 offset,\n\t\t\t\tu32 *base_offset)\n{\n\tstruct bfa_flash_attr *flash_attr;\n\tstruct bnad_iocmd_comp fcomp;\n\tu32 i, flash_part = 0, ret;\n\tunsigned long flags = 0;\n\n\tflash_attr = kzalloc(sizeof(struct bfa_flash_attr), GFP_KERNEL);\n\tif (!flash_attr)\n\t\treturn 0;\n\n\tfcomp.bnad = bnad;\n\tfcomp.comp_status = 0;\n\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\tret = bfa_nw_flash_get_attr(&bnad->bna.flash, flash_attr,\n\t\t\t\tbnad_cb_completion, &fcomp);\n\tif (ret != BFA_STATUS_OK) {\n\t\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\t\tkfree(flash_attr);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\twait_for_completion(&fcomp.comp);\n\tret = fcomp.comp_status;\n\n\t \n\tif (ret == BFA_STATUS_OK) {\n\t\tfor (i = 0; i < flash_attr->npart; i++) {\n\t\t\tif (offset >= flash_attr->part[i].part_off &&\n\t\t\t    offset < (flash_attr->part[i].part_off +\n\t\t\t\t      flash_attr->part[i].part_size)) {\n\t\t\t\tflash_part = flash_attr->part[i].part_type;\n\t\t\t\t*base_offset = flash_attr->part[i].part_off;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tkfree(flash_attr);\n\treturn flash_part;\n}\n\nstatic int\nbnad_get_eeprom_len(struct net_device *netdev)\n{\n\treturn BFA_TOTAL_FLASH_SIZE;\n}\n\nstatic int\nbnad_get_eeprom(struct net_device *netdev, struct ethtool_eeprom *eeprom,\n\t\tu8 *bytes)\n{\n\tstruct bnad *bnad = netdev_priv(netdev);\n\tstruct bnad_iocmd_comp fcomp;\n\tu32 flash_part = 0, base_offset = 0;\n\tunsigned long flags = 0;\n\tint ret = 0;\n\n\t \n\teeprom->magic = bnad->pcidev->vendor | (bnad->pcidev->device << 16);\n\n\t \n\tflash_part = bnad_get_flash_partition_by_offset(bnad,\n\t\t\t\teeprom->offset, &base_offset);\n\tif (flash_part == 0)\n\t\treturn -EFAULT;\n\n\tfcomp.bnad = bnad;\n\tfcomp.comp_status = 0;\n\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\tret = bfa_nw_flash_read_part(&bnad->bna.flash, flash_part,\n\t\t\t\tbnad->id, bytes, eeprom->len,\n\t\t\t\teeprom->offset - base_offset,\n\t\t\t\tbnad_cb_completion, &fcomp);\n\tif (ret != BFA_STATUS_OK) {\n\t\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\t\tgoto done;\n\t}\n\n\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\twait_for_completion(&fcomp.comp);\n\tret = fcomp.comp_status;\ndone:\n\treturn ret;\n}\n\nstatic int\nbnad_set_eeprom(struct net_device *netdev, struct ethtool_eeprom *eeprom,\n\t\tu8 *bytes)\n{\n\tstruct bnad *bnad = netdev_priv(netdev);\n\tstruct bnad_iocmd_comp fcomp;\n\tu32 flash_part = 0, base_offset = 0;\n\tunsigned long flags = 0;\n\tint ret = 0;\n\n\t \n\tif (eeprom->magic != (bnad->pcidev->vendor |\n\t\t\t     (bnad->pcidev->device << 16)))\n\t\treturn -EINVAL;\n\n\t \n\tflash_part = bnad_get_flash_partition_by_offset(bnad,\n\t\t\t\teeprom->offset, &base_offset);\n\tif (flash_part == 0)\n\t\treturn -EFAULT;\n\n\tfcomp.bnad = bnad;\n\tfcomp.comp_status = 0;\n\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bnad->bna_lock, flags);\n\tret = bfa_nw_flash_update_part(&bnad->bna.flash, flash_part,\n\t\t\t\tbnad->id, bytes, eeprom->len,\n\t\t\t\teeprom->offset - base_offset,\n\t\t\t\tbnad_cb_completion, &fcomp);\n\tif (ret != BFA_STATUS_OK) {\n\t\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\t\tgoto done;\n\t}\n\n\tspin_unlock_irqrestore(&bnad->bna_lock, flags);\n\twait_for_completion(&fcomp.comp);\n\tret = fcomp.comp_status;\ndone:\n\treturn ret;\n}\n\nstatic int\nbnad_flash_device(struct net_device *netdev, struct ethtool_flash *eflash)\n{\n\tstruct bnad *bnad = netdev_priv(netdev);\n\tstruct bnad_iocmd_comp fcomp;\n\tconst struct firmware *fw;\n\tint ret = 0;\n\n\tret = request_firmware(&fw, eflash->data, &bnad->pcidev->dev);\n\tif (ret) {\n\t\tnetdev_err(netdev, \"can't load firmware %s\\n\", eflash->data);\n\t\tgoto out;\n\t}\n\n\tfcomp.bnad = bnad;\n\tfcomp.comp_status = 0;\n\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irq(&bnad->bna_lock);\n\tret = bfa_nw_flash_update_part(&bnad->bna.flash, BFA_FLASH_PART_FWIMG,\n\t\t\t\tbnad->id, (u8 *)fw->data, fw->size, 0,\n\t\t\t\tbnad_cb_completion, &fcomp);\n\tif (ret != BFA_STATUS_OK) {\n\t\tnetdev_warn(netdev, \"flash update failed with err=%d\\n\", ret);\n\t\tret = -EIO;\n\t\tspin_unlock_irq(&bnad->bna_lock);\n\t\tgoto out;\n\t}\n\n\tspin_unlock_irq(&bnad->bna_lock);\n\twait_for_completion(&fcomp.comp);\n\tif (fcomp.comp_status != BFA_STATUS_OK) {\n\t\tret = -EIO;\n\t\tnetdev_warn(netdev,\n\t\t\t    \"firmware image update failed with err=%d\\n\",\n\t\t\t    fcomp.comp_status);\n\t}\nout:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic const struct ethtool_ops bnad_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_TX_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE_RX,\n\t.get_drvinfo = bnad_get_drvinfo,\n\t.get_wol = bnad_get_wol,\n\t.get_link = ethtool_op_get_link,\n\t.get_coalesce = bnad_get_coalesce,\n\t.set_coalesce = bnad_set_coalesce,\n\t.get_ringparam = bnad_get_ringparam,\n\t.set_ringparam = bnad_set_ringparam,\n\t.get_pauseparam = bnad_get_pauseparam,\n\t.set_pauseparam = bnad_set_pauseparam,\n\t.get_strings = bnad_get_strings,\n\t.get_ethtool_stats = bnad_get_ethtool_stats,\n\t.get_sset_count = bnad_get_sset_count,\n\t.get_eeprom_len = bnad_get_eeprom_len,\n\t.get_eeprom = bnad_get_eeprom,\n\t.set_eeprom = bnad_set_eeprom,\n\t.flash_device = bnad_flash_device,\n\t.get_ts_info = ethtool_op_get_ts_info,\n\t.get_link_ksettings = bnad_get_link_ksettings,\n\t.set_link_ksettings = bnad_set_link_ksettings,\n};\n\nvoid\nbnad_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &bnad_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}