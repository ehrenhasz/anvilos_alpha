{
  "module_name": "bna_tx_rx.c",
  "hash_id": "3367cdec49b9993cb0eba3969df7e753277a252efd24db02d5a869de22d0c737",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/brocade/bna/bna_tx_rx.c",
  "human_readable_source": "\n \n \n#include \"bna.h\"\n#include \"bfi.h\"\n\n \nstatic void\nbna_ib_coalescing_timeo_set(struct bna_ib *ib, u8 coalescing_timeo)\n{\n\tib->coalescing_timeo = coalescing_timeo;\n\tib->door_bell.doorbell_ack = BNA_DOORBELL_IB_INT_ACK(\n\t\t\t\t(u32)ib->coalescing_timeo, 0);\n}\n\n \n\n#define bna_rxf_vlan_cfg_soft_reset(rxf)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t(rxf)->vlan_pending_bitmask = (u8)BFI_VLAN_BMASK_ALL;\t\t\\\n\t(rxf)->vlan_strip_pending = true;\t\t\t\t\\\n} while (0)\n\n#define bna_rxf_rss_cfg_soft_reset(rxf)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif ((rxf)->rss_status == BNA_STATUS_T_ENABLED)\t\t\t\\\n\t\t(rxf)->rss_pending = (BNA_RSS_F_RIT_PENDING |\t\t\\\n\t\t\t\tBNA_RSS_F_CFG_PENDING |\t\t\t\\\n\t\t\t\tBNA_RSS_F_STATUS_PENDING);\t\t\\\n} while (0)\n\nstatic int bna_rxf_cfg_apply(struct bna_rxf *rxf);\nstatic void bna_rxf_cfg_reset(struct bna_rxf *rxf);\nstatic int bna_rxf_ucast_cfg_apply(struct bna_rxf *rxf);\nstatic int bna_rxf_promisc_cfg_apply(struct bna_rxf *rxf);\nstatic int bna_rxf_allmulti_cfg_apply(struct bna_rxf *rxf);\nstatic int bna_rxf_vlan_strip_cfg_apply(struct bna_rxf *rxf);\nstatic int bna_rxf_ucast_cfg_reset(struct bna_rxf *rxf,\n\t\t\t\t\tenum bna_cleanup_type cleanup);\nstatic int bna_rxf_promisc_cfg_reset(struct bna_rxf *rxf,\n\t\t\t\t\tenum bna_cleanup_type cleanup);\nstatic int bna_rxf_allmulti_cfg_reset(struct bna_rxf *rxf,\n\t\t\t\t\tenum bna_cleanup_type cleanup);\n\nbfa_fsm_state_decl(bna_rxf, stopped, struct bna_rxf,\n\t\t\tenum bna_rxf_event);\nbfa_fsm_state_decl(bna_rxf, cfg_wait, struct bna_rxf,\n\t\t\tenum bna_rxf_event);\nbfa_fsm_state_decl(bna_rxf, started, struct bna_rxf,\n\t\t\tenum bna_rxf_event);\nbfa_fsm_state_decl(bna_rxf, last_resp_wait, struct bna_rxf,\n\t\t\tenum bna_rxf_event);\n\nstatic void\nbna_rxf_sm_stopped_entry(struct bna_rxf *rxf)\n{\n\tcall_rxf_stop_cbfn(rxf);\n}\n\nstatic void\nbna_rxf_sm_stopped(struct bna_rxf *rxf, enum bna_rxf_event event)\n{\n\tswitch (event) {\n\tcase RXF_E_START:\n\t\tbfa_fsm_set_state(rxf, bna_rxf_sm_cfg_wait);\n\t\tbreak;\n\n\tcase RXF_E_STOP:\n\t\tcall_rxf_stop_cbfn(rxf);\n\t\tbreak;\n\n\tcase RXF_E_FAIL:\n\t\t \n\t\tbreak;\n\n\tcase RXF_E_CONFIG:\n\t\tcall_rxf_cam_fltr_cbfn(rxf);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbna_rxf_sm_cfg_wait_entry(struct bna_rxf *rxf)\n{\n\tif (!bna_rxf_cfg_apply(rxf)) {\n\t\t \n\t\tbfa_fsm_set_state(rxf, bna_rxf_sm_started);\n\t}\n}\n\nstatic void\nbna_rxf_sm_cfg_wait(struct bna_rxf *rxf, enum bna_rxf_event event)\n{\n\tswitch (event) {\n\tcase RXF_E_STOP:\n\t\tbfa_fsm_set_state(rxf, bna_rxf_sm_last_resp_wait);\n\t\tbreak;\n\n\tcase RXF_E_FAIL:\n\t\tbna_rxf_cfg_reset(rxf);\n\t\tcall_rxf_start_cbfn(rxf);\n\t\tcall_rxf_cam_fltr_cbfn(rxf);\n\t\tbfa_fsm_set_state(rxf, bna_rxf_sm_stopped);\n\t\tbreak;\n\n\tcase RXF_E_CONFIG:\n\t\t \n\t\tbreak;\n\n\tcase RXF_E_FW_RESP:\n\t\tif (!bna_rxf_cfg_apply(rxf)) {\n\t\t\t \n\t\t\tbfa_fsm_set_state(rxf, bna_rxf_sm_started);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbna_rxf_sm_started_entry(struct bna_rxf *rxf)\n{\n\tcall_rxf_start_cbfn(rxf);\n\tcall_rxf_cam_fltr_cbfn(rxf);\n}\n\nstatic void\nbna_rxf_sm_started(struct bna_rxf *rxf, enum bna_rxf_event event)\n{\n\tswitch (event) {\n\tcase RXF_E_STOP:\n\tcase RXF_E_FAIL:\n\t\tbna_rxf_cfg_reset(rxf);\n\t\tbfa_fsm_set_state(rxf, bna_rxf_sm_stopped);\n\t\tbreak;\n\n\tcase RXF_E_CONFIG:\n\t\tbfa_fsm_set_state(rxf, bna_rxf_sm_cfg_wait);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbna_rxf_sm_last_resp_wait_entry(struct bna_rxf *rxf)\n{\n}\n\nstatic void\nbna_rxf_sm_last_resp_wait(struct bna_rxf *rxf, enum bna_rxf_event event)\n{\n\tswitch (event) {\n\tcase RXF_E_FAIL:\n\tcase RXF_E_FW_RESP:\n\t\tbna_rxf_cfg_reset(rxf);\n\t\tbfa_fsm_set_state(rxf, bna_rxf_sm_stopped);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbna_bfi_ucast_req(struct bna_rxf *rxf, struct bna_mac *mac,\n\t\tenum bfi_enet_h2i_msgs req_type)\n{\n\tstruct bfi_enet_ucast_req *req = &rxf->bfi_enet_cmd.ucast_req;\n\n\tbfi_msgq_mhdr_set(req->mh, BFI_MC_ENET, req_type, 0, rxf->rx->rid);\n\treq->mh.num_entries = htons(\n\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_ucast_req)));\n\tether_addr_copy(req->mac_addr, mac->addr);\n\tbfa_msgq_cmd_set(&rxf->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_ucast_req), &req->mh);\n\tbfa_msgq_cmd_post(&rxf->rx->bna->msgq, &rxf->msgq_cmd);\n}\n\nstatic void\nbna_bfi_mcast_add_req(struct bna_rxf *rxf, struct bna_mac *mac)\n{\n\tstruct bfi_enet_mcast_add_req *req =\n\t\t&rxf->bfi_enet_cmd.mcast_add_req;\n\n\tbfi_msgq_mhdr_set(req->mh, BFI_MC_ENET, BFI_ENET_H2I_MAC_MCAST_ADD_REQ,\n\t\t0, rxf->rx->rid);\n\treq->mh.num_entries = htons(\n\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_mcast_add_req)));\n\tether_addr_copy(req->mac_addr, mac->addr);\n\tbfa_msgq_cmd_set(&rxf->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_mcast_add_req), &req->mh);\n\tbfa_msgq_cmd_post(&rxf->rx->bna->msgq, &rxf->msgq_cmd);\n}\n\nstatic void\nbna_bfi_mcast_del_req(struct bna_rxf *rxf, u16 handle)\n{\n\tstruct bfi_enet_mcast_del_req *req =\n\t\t&rxf->bfi_enet_cmd.mcast_del_req;\n\n\tbfi_msgq_mhdr_set(req->mh, BFI_MC_ENET, BFI_ENET_H2I_MAC_MCAST_DEL_REQ,\n\t\t0, rxf->rx->rid);\n\treq->mh.num_entries = htons(\n\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_mcast_del_req)));\n\treq->handle = htons(handle);\n\tbfa_msgq_cmd_set(&rxf->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_mcast_del_req), &req->mh);\n\tbfa_msgq_cmd_post(&rxf->rx->bna->msgq, &rxf->msgq_cmd);\n}\n\nstatic void\nbna_bfi_mcast_filter_req(struct bna_rxf *rxf, enum bna_status status)\n{\n\tstruct bfi_enet_enable_req *req = &rxf->bfi_enet_cmd.req;\n\n\tbfi_msgq_mhdr_set(req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_MAC_MCAST_FILTER_REQ, 0, rxf->rx->rid);\n\treq->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_enable_req)));\n\treq->enable = status;\n\tbfa_msgq_cmd_set(&rxf->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_enable_req), &req->mh);\n\tbfa_msgq_cmd_post(&rxf->rx->bna->msgq, &rxf->msgq_cmd);\n}\n\nstatic void\nbna_bfi_rx_promisc_req(struct bna_rxf *rxf, enum bna_status status)\n{\n\tstruct bfi_enet_enable_req *req = &rxf->bfi_enet_cmd.req;\n\n\tbfi_msgq_mhdr_set(req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_RX_PROMISCUOUS_REQ, 0, rxf->rx->rid);\n\treq->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_enable_req)));\n\treq->enable = status;\n\tbfa_msgq_cmd_set(&rxf->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_enable_req), &req->mh);\n\tbfa_msgq_cmd_post(&rxf->rx->bna->msgq, &rxf->msgq_cmd);\n}\n\nstatic void\nbna_bfi_rx_vlan_filter_set(struct bna_rxf *rxf, u8 block_idx)\n{\n\tstruct bfi_enet_rx_vlan_req *req = &rxf->bfi_enet_cmd.vlan_req;\n\tint i;\n\tint j;\n\n\tbfi_msgq_mhdr_set(req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_RX_VLAN_SET_REQ, 0, rxf->rx->rid);\n\treq->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_rx_vlan_req)));\n\treq->block_idx = block_idx;\n\tfor (i = 0; i < (BFI_ENET_VLAN_BLOCK_SIZE / 32); i++) {\n\t\tj = (block_idx * (BFI_ENET_VLAN_BLOCK_SIZE / 32)) + i;\n\t\tif (rxf->vlan_filter_status == BNA_STATUS_T_ENABLED)\n\t\t\treq->bit_mask[i] =\n\t\t\t\thtonl(rxf->vlan_filter_table[j]);\n\t\telse\n\t\t\treq->bit_mask[i] = 0xFFFFFFFF;\n\t}\n\tbfa_msgq_cmd_set(&rxf->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_rx_vlan_req), &req->mh);\n\tbfa_msgq_cmd_post(&rxf->rx->bna->msgq, &rxf->msgq_cmd);\n}\n\nstatic void\nbna_bfi_vlan_strip_enable(struct bna_rxf *rxf)\n{\n\tstruct bfi_enet_enable_req *req = &rxf->bfi_enet_cmd.req;\n\n\tbfi_msgq_mhdr_set(req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_RX_VLAN_STRIP_ENABLE_REQ, 0, rxf->rx->rid);\n\treq->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_enable_req)));\n\treq->enable = rxf->vlan_strip_status;\n\tbfa_msgq_cmd_set(&rxf->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_enable_req), &req->mh);\n\tbfa_msgq_cmd_post(&rxf->rx->bna->msgq, &rxf->msgq_cmd);\n}\n\nstatic void\nbna_bfi_rit_cfg(struct bna_rxf *rxf)\n{\n\tstruct bfi_enet_rit_req *req = &rxf->bfi_enet_cmd.rit_req;\n\n\tbfi_msgq_mhdr_set(req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_RIT_CFG_REQ, 0, rxf->rx->rid);\n\treq->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_rit_req)));\n\treq->size = htons(rxf->rit_size);\n\tmemcpy(&req->table[0], rxf->rit, rxf->rit_size);\n\tbfa_msgq_cmd_set(&rxf->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_rit_req), &req->mh);\n\tbfa_msgq_cmd_post(&rxf->rx->bna->msgq, &rxf->msgq_cmd);\n}\n\nstatic void\nbna_bfi_rss_cfg(struct bna_rxf *rxf)\n{\n\tstruct bfi_enet_rss_cfg_req *req = &rxf->bfi_enet_cmd.rss_req;\n\tint i;\n\n\tbfi_msgq_mhdr_set(req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_RSS_CFG_REQ, 0, rxf->rx->rid);\n\treq->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_rss_cfg_req)));\n\treq->cfg.type = rxf->rss_cfg.hash_type;\n\treq->cfg.mask = rxf->rss_cfg.hash_mask;\n\tfor (i = 0; i < BFI_ENET_RSS_KEY_LEN; i++)\n\t\treq->cfg.key[i] =\n\t\t\thtonl(rxf->rss_cfg.toeplitz_hash_key[i]);\n\tbfa_msgq_cmd_set(&rxf->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_rss_cfg_req), &req->mh);\n\tbfa_msgq_cmd_post(&rxf->rx->bna->msgq, &rxf->msgq_cmd);\n}\n\nstatic void\nbna_bfi_rss_enable(struct bna_rxf *rxf)\n{\n\tstruct bfi_enet_enable_req *req = &rxf->bfi_enet_cmd.req;\n\n\tbfi_msgq_mhdr_set(req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_RSS_ENABLE_REQ, 0, rxf->rx->rid);\n\treq->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_enable_req)));\n\treq->enable = rxf->rss_status;\n\tbfa_msgq_cmd_set(&rxf->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_enable_req), &req->mh);\n\tbfa_msgq_cmd_post(&rxf->rx->bna->msgq, &rxf->msgq_cmd);\n}\n\n \nstatic struct bna_mac *\nbna_rxf_mcmac_get(struct bna_rxf *rxf, const u8 *mac_addr)\n{\n\tstruct bna_mac *mac;\n\n\tlist_for_each_entry(mac, &rxf->mcast_active_q, qe)\n\t\tif (ether_addr_equal(mac->addr, mac_addr))\n\t\t\treturn mac;\n\n\tlist_for_each_entry(mac, &rxf->mcast_pending_del_q, qe)\n\t\tif (ether_addr_equal(mac->addr, mac_addr))\n\t\t\treturn mac;\n\n\treturn NULL;\n}\n\nstatic struct bna_mcam_handle *\nbna_rxf_mchandle_get(struct bna_rxf *rxf, int handle)\n{\n\tstruct bna_mcam_handle *mchandle;\n\n\tlist_for_each_entry(mchandle, &rxf->mcast_handle_q, qe)\n\t\tif (mchandle->handle == handle)\n\t\t\treturn mchandle;\n\n\treturn NULL;\n}\n\nstatic void\nbna_rxf_mchandle_attach(struct bna_rxf *rxf, u8 *mac_addr, int handle)\n{\n\tstruct bna_mac *mcmac;\n\tstruct bna_mcam_handle *mchandle;\n\n\tmcmac = bna_rxf_mcmac_get(rxf, mac_addr);\n\tmchandle = bna_rxf_mchandle_get(rxf, handle);\n\tif (mchandle == NULL) {\n\t\tmchandle = bna_mcam_mod_handle_get(&rxf->rx->bna->mcam_mod);\n\t\tmchandle->handle = handle;\n\t\tmchandle->refcnt = 0;\n\t\tlist_add_tail(&mchandle->qe, &rxf->mcast_handle_q);\n\t}\n\tmchandle->refcnt++;\n\tmcmac->handle = mchandle;\n}\n\nstatic int\nbna_rxf_mcast_del(struct bna_rxf *rxf, struct bna_mac *mac,\n\t\tenum bna_cleanup_type cleanup)\n{\n\tstruct bna_mcam_handle *mchandle;\n\tint ret = 0;\n\n\tmchandle = mac->handle;\n\tif (mchandle == NULL)\n\t\treturn ret;\n\n\tmchandle->refcnt--;\n\tif (mchandle->refcnt == 0) {\n\t\tif (cleanup == BNA_HARD_CLEANUP) {\n\t\t\tbna_bfi_mcast_del_req(rxf, mchandle->handle);\n\t\t\tret = 1;\n\t\t}\n\t\tlist_del(&mchandle->qe);\n\t\tbna_mcam_mod_handle_put(&rxf->rx->bna->mcam_mod, mchandle);\n\t}\n\tmac->handle = NULL;\n\n\treturn ret;\n}\n\nstatic int\nbna_rxf_mcast_cfg_apply(struct bna_rxf *rxf)\n{\n\tstruct bna_mac *mac = NULL;\n\tint ret;\n\n\t \n\twhile (!list_empty(&rxf->mcast_pending_del_q)) {\n\t\tmac = list_first_entry(&rxf->mcast_pending_del_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tret = bna_rxf_mcast_del(rxf, mac, BNA_HARD_CLEANUP);\n\t\tlist_move_tail(&mac->qe, bna_mcam_mod_del_q(rxf->rx->bna));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (!list_empty(&rxf->mcast_pending_add_q)) {\n\t\tmac = list_first_entry(&rxf->mcast_pending_add_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tlist_move_tail(&mac->qe, &rxf->mcast_active_q);\n\t\tbna_bfi_mcast_add_req(rxf, mac);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbna_rxf_vlan_cfg_apply(struct bna_rxf *rxf)\n{\n\tu8 vlan_pending_bitmask;\n\tint block_idx = 0;\n\n\tif (rxf->vlan_pending_bitmask) {\n\t\tvlan_pending_bitmask = rxf->vlan_pending_bitmask;\n\t\twhile (!(vlan_pending_bitmask & 0x1)) {\n\t\t\tblock_idx++;\n\t\t\tvlan_pending_bitmask >>= 1;\n\t\t}\n\t\trxf->vlan_pending_bitmask &= ~BIT(block_idx);\n\t\tbna_bfi_rx_vlan_filter_set(rxf, block_idx);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbna_rxf_mcast_cfg_reset(struct bna_rxf *rxf, enum bna_cleanup_type cleanup)\n{\n\tstruct bna_mac *mac;\n\tint ret;\n\n\t \n\twhile (!list_empty(&rxf->mcast_pending_del_q)) {\n\t\tmac = list_first_entry(&rxf->mcast_pending_del_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tret = bna_rxf_mcast_del(rxf, mac, cleanup);\n\t\tlist_move_tail(&mac->qe, bna_mcam_mod_del_q(rxf->rx->bna));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\twhile (!list_empty(&rxf->mcast_active_q)) {\n\t\tmac = list_first_entry(&rxf->mcast_active_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tlist_move_tail(&mac->qe, &rxf->mcast_pending_add_q);\n\t\tif (bna_rxf_mcast_del(rxf, mac, cleanup))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbna_rxf_rss_cfg_apply(struct bna_rxf *rxf)\n{\n\tif (rxf->rss_pending) {\n\t\tif (rxf->rss_pending & BNA_RSS_F_RIT_PENDING) {\n\t\t\trxf->rss_pending &= ~BNA_RSS_F_RIT_PENDING;\n\t\t\tbna_bfi_rit_cfg(rxf);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (rxf->rss_pending & BNA_RSS_F_CFG_PENDING) {\n\t\t\trxf->rss_pending &= ~BNA_RSS_F_CFG_PENDING;\n\t\t\tbna_bfi_rss_cfg(rxf);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (rxf->rss_pending & BNA_RSS_F_STATUS_PENDING) {\n\t\t\trxf->rss_pending &= ~BNA_RSS_F_STATUS_PENDING;\n\t\t\tbna_bfi_rss_enable(rxf);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbna_rxf_cfg_apply(struct bna_rxf *rxf)\n{\n\tif (bna_rxf_ucast_cfg_apply(rxf))\n\t\treturn 1;\n\n\tif (bna_rxf_mcast_cfg_apply(rxf))\n\t\treturn 1;\n\n\tif (bna_rxf_promisc_cfg_apply(rxf))\n\t\treturn 1;\n\n\tif (bna_rxf_allmulti_cfg_apply(rxf))\n\t\treturn 1;\n\n\tif (bna_rxf_vlan_cfg_apply(rxf))\n\t\treturn 1;\n\n\tif (bna_rxf_vlan_strip_cfg_apply(rxf))\n\t\treturn 1;\n\n\tif (bna_rxf_rss_cfg_apply(rxf))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void\nbna_rxf_cfg_reset(struct bna_rxf *rxf)\n{\n\tbna_rxf_ucast_cfg_reset(rxf, BNA_SOFT_CLEANUP);\n\tbna_rxf_mcast_cfg_reset(rxf, BNA_SOFT_CLEANUP);\n\tbna_rxf_promisc_cfg_reset(rxf, BNA_SOFT_CLEANUP);\n\tbna_rxf_allmulti_cfg_reset(rxf, BNA_SOFT_CLEANUP);\n\tbna_rxf_vlan_cfg_soft_reset(rxf);\n\tbna_rxf_rss_cfg_soft_reset(rxf);\n}\n\nstatic void\nbna_rit_init(struct bna_rxf *rxf, int rit_size)\n{\n\tstruct bna_rx *rx = rxf->rx;\n\tstruct bna_rxp *rxp;\n\tint offset = 0;\n\n\trxf->rit_size = rit_size;\n\tlist_for_each_entry(rxp, &rx->rxp_q, qe) {\n\t\trxf->rit[offset] = rxp->cq.ccb->id;\n\t\toffset++;\n\t}\n}\n\nvoid\nbna_bfi_rxf_cfg_rsp(struct bna_rxf *rxf, struct bfi_msgq_mhdr *msghdr)\n{\n\tbfa_fsm_send_event(rxf, RXF_E_FW_RESP);\n}\n\nvoid\nbna_bfi_rxf_ucast_set_rsp(struct bna_rxf *rxf,\n\t\t\tstruct bfi_msgq_mhdr *msghdr)\n{\n\tstruct bfi_enet_rsp *rsp =\n\t\tcontainer_of(msghdr, struct bfi_enet_rsp, mh);\n\n\tif (rsp->error) {\n\t\t \n\t\trxf->ucast_active_set = 0;\n\t}\n\n\tbfa_fsm_send_event(rxf, RXF_E_FW_RESP);\n}\n\nvoid\nbna_bfi_rxf_mcast_add_rsp(struct bna_rxf *rxf,\n\t\t\tstruct bfi_msgq_mhdr *msghdr)\n{\n\tstruct bfi_enet_mcast_add_req *req =\n\t\t&rxf->bfi_enet_cmd.mcast_add_req;\n\tstruct bfi_enet_mcast_add_rsp *rsp =\n\t\tcontainer_of(msghdr, struct bfi_enet_mcast_add_rsp, mh);\n\n\tbna_rxf_mchandle_attach(rxf, (u8 *)&req->mac_addr,\n\t\tntohs(rsp->handle));\n\tbfa_fsm_send_event(rxf, RXF_E_FW_RESP);\n}\n\nstatic void\nbna_rxf_init(struct bna_rxf *rxf,\n\t\tstruct bna_rx *rx,\n\t\tstruct bna_rx_config *q_config,\n\t\tstruct bna_res_info *res_info)\n{\n\trxf->rx = rx;\n\n\tINIT_LIST_HEAD(&rxf->ucast_pending_add_q);\n\tINIT_LIST_HEAD(&rxf->ucast_pending_del_q);\n\trxf->ucast_pending_set = 0;\n\trxf->ucast_active_set = 0;\n\tINIT_LIST_HEAD(&rxf->ucast_active_q);\n\trxf->ucast_pending_mac = NULL;\n\n\tINIT_LIST_HEAD(&rxf->mcast_pending_add_q);\n\tINIT_LIST_HEAD(&rxf->mcast_pending_del_q);\n\tINIT_LIST_HEAD(&rxf->mcast_active_q);\n\tINIT_LIST_HEAD(&rxf->mcast_handle_q);\n\n\trxf->rit = (u8 *)\n\t\tres_info[BNA_RX_RES_MEM_T_RIT].res_u.mem_info.mdl[0].kva;\n\tbna_rit_init(rxf, q_config->num_paths);\n\n\trxf->rss_status = q_config->rss_status;\n\tif (rxf->rss_status == BNA_STATUS_T_ENABLED) {\n\t\trxf->rss_cfg = q_config->rss_config;\n\t\trxf->rss_pending |= BNA_RSS_F_CFG_PENDING;\n\t\trxf->rss_pending |= BNA_RSS_F_RIT_PENDING;\n\t\trxf->rss_pending |= BNA_RSS_F_STATUS_PENDING;\n\t}\n\n\trxf->vlan_filter_status = BNA_STATUS_T_DISABLED;\n\tmemset(rxf->vlan_filter_table, 0,\n\t\t\t(sizeof(u32) * (BFI_ENET_VLAN_ID_MAX / 32)));\n\trxf->vlan_filter_table[0] |= 1;  \n\trxf->vlan_pending_bitmask = (u8)BFI_VLAN_BMASK_ALL;\n\n\trxf->vlan_strip_status = q_config->vlan_strip_status;\n\n\tbfa_fsm_set_state(rxf, bna_rxf_sm_stopped);\n}\n\nstatic void\nbna_rxf_uninit(struct bna_rxf *rxf)\n{\n\tstruct bna_mac *mac;\n\n\trxf->ucast_pending_set = 0;\n\trxf->ucast_active_set = 0;\n\n\twhile (!list_empty(&rxf->ucast_pending_add_q)) {\n\t\tmac = list_first_entry(&rxf->ucast_pending_add_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tlist_move_tail(&mac->qe, bna_ucam_mod_free_q(rxf->rx->bna));\n\t}\n\n\tif (rxf->ucast_pending_mac) {\n\t\tlist_add_tail(&rxf->ucast_pending_mac->qe,\n\t\t\t      bna_ucam_mod_free_q(rxf->rx->bna));\n\t\trxf->ucast_pending_mac = NULL;\n\t}\n\n\twhile (!list_empty(&rxf->mcast_pending_add_q)) {\n\t\tmac = list_first_entry(&rxf->mcast_pending_add_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tlist_move_tail(&mac->qe, bna_mcam_mod_free_q(rxf->rx->bna));\n\t}\n\n\trxf->rxmode_pending = 0;\n\trxf->rxmode_pending_bitmask = 0;\n\tif (rxf->rx->bna->promisc_rid == rxf->rx->rid)\n\t\trxf->rx->bna->promisc_rid = BFI_INVALID_RID;\n\tif (rxf->rx->bna->default_mode_rid == rxf->rx->rid)\n\t\trxf->rx->bna->default_mode_rid = BFI_INVALID_RID;\n\n\trxf->rss_pending = 0;\n\trxf->vlan_strip_pending = false;\n\n\trxf->rx = NULL;\n}\n\nstatic void\nbna_rx_cb_rxf_started(struct bna_rx *rx)\n{\n\tbfa_fsm_send_event(rx, RX_E_RXF_STARTED);\n}\n\nstatic void\nbna_rxf_start(struct bna_rxf *rxf)\n{\n\trxf->start_cbfn = bna_rx_cb_rxf_started;\n\trxf->start_cbarg = rxf->rx;\n\tbfa_fsm_send_event(rxf, RXF_E_START);\n}\n\nstatic void\nbna_rx_cb_rxf_stopped(struct bna_rx *rx)\n{\n\tbfa_fsm_send_event(rx, RX_E_RXF_STOPPED);\n}\n\nstatic void\nbna_rxf_stop(struct bna_rxf *rxf)\n{\n\trxf->stop_cbfn = bna_rx_cb_rxf_stopped;\n\trxf->stop_cbarg = rxf->rx;\n\tbfa_fsm_send_event(rxf, RXF_E_STOP);\n}\n\nstatic void\nbna_rxf_fail(struct bna_rxf *rxf)\n{\n\tbfa_fsm_send_event(rxf, RXF_E_FAIL);\n}\n\nenum bna_cb_status\nbna_rx_ucast_set(struct bna_rx *rx, const u8 *ucmac)\n{\n\tstruct bna_rxf *rxf = &rx->rxf;\n\n\tif (rxf->ucast_pending_mac == NULL) {\n\t\trxf->ucast_pending_mac =\n\t\t\tbna_cam_mod_mac_get(bna_ucam_mod_free_q(rxf->rx->bna));\n\t\tif (rxf->ucast_pending_mac == NULL)\n\t\t\treturn BNA_CB_UCAST_CAM_FULL;\n\t}\n\n\tether_addr_copy(rxf->ucast_pending_mac->addr, ucmac);\n\trxf->ucast_pending_set = 1;\n\trxf->cam_fltr_cbfn = NULL;\n\trxf->cam_fltr_cbarg = rx->bna->bnad;\n\n\tbfa_fsm_send_event(rxf, RXF_E_CONFIG);\n\n\treturn BNA_CB_SUCCESS;\n}\n\nenum bna_cb_status\nbna_rx_mcast_add(struct bna_rx *rx, const u8 *addr,\n\t\t void (*cbfn)(struct bnad *, struct bna_rx *))\n{\n\tstruct bna_rxf *rxf = &rx->rxf;\n\tstruct bna_mac *mac;\n\n\t \n\tif (bna_mac_find(&rxf->mcast_active_q, addr) ||\n\t\tbna_mac_find(&rxf->mcast_pending_add_q, addr)) {\n\t\tif (cbfn)\n\t\t\tcbfn(rx->bna->bnad, rx);\n\t\treturn BNA_CB_SUCCESS;\n\t}\n\n\tmac = bna_cam_mod_mac_get(bna_mcam_mod_free_q(rxf->rx->bna));\n\tif (mac == NULL)\n\t\treturn BNA_CB_MCAST_LIST_FULL;\n\tether_addr_copy(mac->addr, addr);\n\tlist_add_tail(&mac->qe, &rxf->mcast_pending_add_q);\n\n\trxf->cam_fltr_cbfn = cbfn;\n\trxf->cam_fltr_cbarg = rx->bna->bnad;\n\n\tbfa_fsm_send_event(rxf, RXF_E_CONFIG);\n\n\treturn BNA_CB_SUCCESS;\n}\n\nenum bna_cb_status\nbna_rx_ucast_listset(struct bna_rx *rx, int count, const u8 *uclist)\n{\n\tstruct bna_ucam_mod *ucam_mod = &rx->bna->ucam_mod;\n\tstruct bna_rxf *rxf = &rx->rxf;\n\tstruct list_head list_head;\n\tconst u8 *mcaddr;\n\tstruct bna_mac *mac, *del_mac;\n\tint i;\n\n\t \n\twhile (!list_empty(&rxf->ucast_pending_add_q)) {\n\t\tmac = list_first_entry(&rxf->ucast_pending_add_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tlist_move_tail(&mac->qe, &ucam_mod->free_q);\n\t}\n\n\t \n\twhile (!list_empty(&rxf->ucast_active_q)) {\n\t\tmac = list_first_entry(&rxf->ucast_active_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tdel_mac = bna_cam_mod_mac_get(&ucam_mod->del_q);\n\t\tether_addr_copy(del_mac->addr, mac->addr);\n\t\tdel_mac->handle = mac->handle;\n\t\tlist_add_tail(&del_mac->qe, &rxf->ucast_pending_del_q);\n\t\tlist_move_tail(&mac->qe, &ucam_mod->free_q);\n\t}\n\n\t \n\tINIT_LIST_HEAD(&list_head);\n\tfor (i = 0, mcaddr = uclist; i < count; i++) {\n\t\tmac = bna_cam_mod_mac_get(&ucam_mod->free_q);\n\t\tif (mac == NULL)\n\t\t\tgoto err_return;\n\t\tether_addr_copy(mac->addr, mcaddr);\n\t\tlist_add_tail(&mac->qe, &list_head);\n\t\tmcaddr += ETH_ALEN;\n\t}\n\n\t \n\twhile (!list_empty(&list_head)) {\n\t\tmac = list_first_entry(&list_head, struct bna_mac, qe);\n\t\tlist_move_tail(&mac->qe, &rxf->ucast_pending_add_q);\n\t}\n\n\tbfa_fsm_send_event(rxf, RXF_E_CONFIG);\n\n\treturn BNA_CB_SUCCESS;\n\nerr_return:\n\twhile (!list_empty(&list_head)) {\n\t\tmac = list_first_entry(&list_head, struct bna_mac, qe);\n\t\tlist_move_tail(&mac->qe, &ucam_mod->free_q);\n\t}\n\n\treturn BNA_CB_UCAST_CAM_FULL;\n}\n\nenum bna_cb_status\nbna_rx_mcast_listset(struct bna_rx *rx, int count, const u8 *mclist)\n{\n\tstruct bna_mcam_mod *mcam_mod = &rx->bna->mcam_mod;\n\tstruct bna_rxf *rxf = &rx->rxf;\n\tstruct list_head list_head;\n\tconst u8 *mcaddr;\n\tstruct bna_mac *mac, *del_mac;\n\tint i;\n\n\t \n\twhile (!list_empty(&rxf->mcast_pending_add_q)) {\n\t\tmac = list_first_entry(&rxf->mcast_pending_add_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tlist_move_tail(&mac->qe, &mcam_mod->free_q);\n\t}\n\n\t \n\twhile (!list_empty(&rxf->mcast_active_q)) {\n\t\tmac = list_first_entry(&rxf->mcast_active_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tdel_mac = bna_cam_mod_mac_get(&mcam_mod->del_q);\n\t\tether_addr_copy(del_mac->addr, mac->addr);\n\t\tdel_mac->handle = mac->handle;\n\t\tlist_add_tail(&del_mac->qe, &rxf->mcast_pending_del_q);\n\t\tmac->handle = NULL;\n\t\tlist_move_tail(&mac->qe, &mcam_mod->free_q);\n\t}\n\n\t \n\tINIT_LIST_HEAD(&list_head);\n\tfor (i = 0, mcaddr = mclist; i < count; i++) {\n\t\tmac = bna_cam_mod_mac_get(&mcam_mod->free_q);\n\t\tif (mac == NULL)\n\t\t\tgoto err_return;\n\t\tether_addr_copy(mac->addr, mcaddr);\n\t\tlist_add_tail(&mac->qe, &list_head);\n\n\t\tmcaddr += ETH_ALEN;\n\t}\n\n\t \n\twhile (!list_empty(&list_head)) {\n\t\tmac = list_first_entry(&list_head, struct bna_mac, qe);\n\t\tlist_move_tail(&mac->qe, &rxf->mcast_pending_add_q);\n\t}\n\n\tbfa_fsm_send_event(rxf, RXF_E_CONFIG);\n\n\treturn BNA_CB_SUCCESS;\n\nerr_return:\n\twhile (!list_empty(&list_head)) {\n\t\tmac = list_first_entry(&list_head, struct bna_mac, qe);\n\t\tlist_move_tail(&mac->qe, &mcam_mod->free_q);\n\t}\n\n\treturn BNA_CB_MCAST_LIST_FULL;\n}\n\nvoid\nbna_rx_mcast_delall(struct bna_rx *rx)\n{\n\tstruct bna_rxf *rxf = &rx->rxf;\n\tstruct bna_mac *mac, *del_mac;\n\tint need_hw_config = 0;\n\n\t \n\twhile (!list_empty(&rxf->mcast_pending_add_q)) {\n\t\tmac = list_first_entry(&rxf->mcast_pending_add_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tlist_move_tail(&mac->qe, bna_mcam_mod_free_q(rxf->rx->bna));\n\t}\n\n\t \n\twhile (!list_empty(&rxf->mcast_active_q)) {\n\t\tmac = list_first_entry(&rxf->mcast_active_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tlist_del(&mac->qe);\n\t\tdel_mac = bna_cam_mod_mac_get(bna_mcam_mod_del_q(rxf->rx->bna));\n\t\tmemcpy(del_mac, mac, sizeof(*del_mac));\n\t\tlist_add_tail(&del_mac->qe, &rxf->mcast_pending_del_q);\n\t\tmac->handle = NULL;\n\t\tlist_add_tail(&mac->qe, bna_mcam_mod_free_q(rxf->rx->bna));\n\t\tneed_hw_config = 1;\n\t}\n\n\tif (need_hw_config)\n\t\tbfa_fsm_send_event(rxf, RXF_E_CONFIG);\n}\n\nvoid\nbna_rx_vlan_add(struct bna_rx *rx, int vlan_id)\n{\n\tstruct bna_rxf *rxf = &rx->rxf;\n\tint index = (vlan_id >> BFI_VLAN_WORD_SHIFT);\n\tint bit = BIT(vlan_id & BFI_VLAN_WORD_MASK);\n\tint group_id = (vlan_id >> BFI_VLAN_BLOCK_SHIFT);\n\n\trxf->vlan_filter_table[index] |= bit;\n\tif (rxf->vlan_filter_status == BNA_STATUS_T_ENABLED) {\n\t\trxf->vlan_pending_bitmask |= BIT(group_id);\n\t\tbfa_fsm_send_event(rxf, RXF_E_CONFIG);\n\t}\n}\n\nvoid\nbna_rx_vlan_del(struct bna_rx *rx, int vlan_id)\n{\n\tstruct bna_rxf *rxf = &rx->rxf;\n\tint index = (vlan_id >> BFI_VLAN_WORD_SHIFT);\n\tint bit = BIT(vlan_id & BFI_VLAN_WORD_MASK);\n\tint group_id = (vlan_id >> BFI_VLAN_BLOCK_SHIFT);\n\n\trxf->vlan_filter_table[index] &= ~bit;\n\tif (rxf->vlan_filter_status == BNA_STATUS_T_ENABLED) {\n\t\trxf->vlan_pending_bitmask |= BIT(group_id);\n\t\tbfa_fsm_send_event(rxf, RXF_E_CONFIG);\n\t}\n}\n\nstatic int\nbna_rxf_ucast_cfg_apply(struct bna_rxf *rxf)\n{\n\tstruct bna_mac *mac = NULL;\n\n\t \n\tif (!list_empty(&rxf->ucast_pending_del_q)) {\n\t\tmac = list_first_entry(&rxf->ucast_pending_del_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tbna_bfi_ucast_req(rxf, mac, BFI_ENET_H2I_MAC_UCAST_DEL_REQ);\n\t\tlist_move_tail(&mac->qe, bna_ucam_mod_del_q(rxf->rx->bna));\n\t\treturn 1;\n\t}\n\n\t \n\tif (rxf->ucast_pending_set) {\n\t\trxf->ucast_pending_set = 0;\n\t\tether_addr_copy(rxf->ucast_active_mac.addr,\n\t\t\t\trxf->ucast_pending_mac->addr);\n\t\trxf->ucast_active_set = 1;\n\t\tbna_bfi_ucast_req(rxf, &rxf->ucast_active_mac,\n\t\t\tBFI_ENET_H2I_MAC_UCAST_SET_REQ);\n\t\treturn 1;\n\t}\n\n\t \n\tif (!list_empty(&rxf->ucast_pending_add_q)) {\n\t\tmac = list_first_entry(&rxf->ucast_pending_add_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tlist_move_tail(&mac->qe, &rxf->ucast_active_q);\n\t\tbna_bfi_ucast_req(rxf, mac, BFI_ENET_H2I_MAC_UCAST_ADD_REQ);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbna_rxf_ucast_cfg_reset(struct bna_rxf *rxf, enum bna_cleanup_type cleanup)\n{\n\tstruct bna_mac *mac;\n\n\t \n\twhile (!list_empty(&rxf->ucast_pending_del_q)) {\n\t\tmac = list_first_entry(&rxf->ucast_pending_del_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tif (cleanup == BNA_SOFT_CLEANUP)\n\t\t\tlist_move_tail(&mac->qe,\n\t\t\t\t       bna_ucam_mod_del_q(rxf->rx->bna));\n\t\telse {\n\t\t\tbna_bfi_ucast_req(rxf, mac,\n\t\t\t\t\t  BFI_ENET_H2I_MAC_UCAST_DEL_REQ);\n\t\t\tlist_move_tail(&mac->qe,\n\t\t\t\t       bna_ucam_mod_del_q(rxf->rx->bna));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\twhile (!list_empty(&rxf->ucast_active_q)) {\n\t\tmac = list_first_entry(&rxf->ucast_active_q,\n\t\t\t\t       struct bna_mac, qe);\n\t\tlist_move_tail(&mac->qe, &rxf->ucast_pending_add_q);\n\t\tif (cleanup == BNA_HARD_CLEANUP) {\n\t\t\tbna_bfi_ucast_req(rxf, mac,\n\t\t\t\tBFI_ENET_H2I_MAC_UCAST_DEL_REQ);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (rxf->ucast_active_set) {\n\t\trxf->ucast_pending_set = 1;\n\t\trxf->ucast_active_set = 0;\n\t\tif (cleanup == BNA_HARD_CLEANUP) {\n\t\t\tbna_bfi_ucast_req(rxf, &rxf->ucast_active_mac,\n\t\t\t\tBFI_ENET_H2I_MAC_UCAST_CLR_REQ);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbna_rxf_promisc_cfg_apply(struct bna_rxf *rxf)\n{\n\tstruct bna *bna = rxf->rx->bna;\n\n\t \n\tif (is_promisc_enable(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask)) {\n\t\t \n\t\tpromisc_inactive(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask);\n\t\trxf->rxmode_active |= BNA_RXMODE_PROMISC;\n\t\tbna_bfi_rx_promisc_req(rxf, BNA_STATUS_T_ENABLED);\n\t\treturn 1;\n\t} else if (is_promisc_disable(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask)) {\n\t\t \n\t\tpromisc_inactive(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask);\n\t\trxf->rxmode_active &= ~BNA_RXMODE_PROMISC;\n\t\tbna->promisc_rid = BFI_INVALID_RID;\n\t\tbna_bfi_rx_promisc_req(rxf, BNA_STATUS_T_DISABLED);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbna_rxf_promisc_cfg_reset(struct bna_rxf *rxf, enum bna_cleanup_type cleanup)\n{\n\tstruct bna *bna = rxf->rx->bna;\n\n\t \n\tif (is_promisc_disable(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask)) {\n\t\tpromisc_inactive(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask);\n\t\trxf->rxmode_active &= ~BNA_RXMODE_PROMISC;\n\t\tbna->promisc_rid = BFI_INVALID_RID;\n\t\tif (cleanup == BNA_HARD_CLEANUP) {\n\t\t\tbna_bfi_rx_promisc_req(rxf, BNA_STATUS_T_DISABLED);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tif (rxf->rxmode_active & BNA_RXMODE_PROMISC) {\n\t\tpromisc_enable(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask);\n\t\trxf->rxmode_active &= ~BNA_RXMODE_PROMISC;\n\t\tif (cleanup == BNA_HARD_CLEANUP) {\n\t\t\tbna_bfi_rx_promisc_req(rxf, BNA_STATUS_T_DISABLED);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbna_rxf_allmulti_cfg_apply(struct bna_rxf *rxf)\n{\n\t \n\tif (is_allmulti_enable(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask)) {\n\t\t \n\t\tallmulti_inactive(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask);\n\t\trxf->rxmode_active |= BNA_RXMODE_ALLMULTI;\n\t\tbna_bfi_mcast_filter_req(rxf, BNA_STATUS_T_DISABLED);\n\t\treturn 1;\n\t} else if (is_allmulti_disable(rxf->rxmode_pending,\n\t\t\t\t\trxf->rxmode_pending_bitmask)) {\n\t\t \n\t\tallmulti_inactive(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask);\n\t\trxf->rxmode_active &= ~BNA_RXMODE_ALLMULTI;\n\t\tbna_bfi_mcast_filter_req(rxf, BNA_STATUS_T_ENABLED);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbna_rxf_allmulti_cfg_reset(struct bna_rxf *rxf, enum bna_cleanup_type cleanup)\n{\n\t \n\tif (is_allmulti_disable(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask)) {\n\t\tallmulti_inactive(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask);\n\t\trxf->rxmode_active &= ~BNA_RXMODE_ALLMULTI;\n\t\tif (cleanup == BNA_HARD_CLEANUP) {\n\t\t\tbna_bfi_mcast_filter_req(rxf, BNA_STATUS_T_ENABLED);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tif (rxf->rxmode_active & BNA_RXMODE_ALLMULTI) {\n\t\tallmulti_enable(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask);\n\t\trxf->rxmode_active &= ~BNA_RXMODE_ALLMULTI;\n\t\tif (cleanup == BNA_HARD_CLEANUP) {\n\t\t\tbna_bfi_mcast_filter_req(rxf, BNA_STATUS_T_ENABLED);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nbna_rxf_promisc_enable(struct bna_rxf *rxf)\n{\n\tstruct bna *bna = rxf->rx->bna;\n\tint ret = 0;\n\n\tif (is_promisc_enable(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask) ||\n\t\t(rxf->rxmode_active & BNA_RXMODE_PROMISC)) {\n\t\t \n\t} else if (is_promisc_disable(rxf->rxmode_pending,\n\t\t\t\t\trxf->rxmode_pending_bitmask)) {\n\t\t \n\t\tpromisc_inactive(rxf->rxmode_pending,\n\t\t\trxf->rxmode_pending_bitmask);\n\t} else {\n\t\t \n\t\tpromisc_enable(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask);\n\t\tbna->promisc_rid = rxf->rx->rid;\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nbna_rxf_promisc_disable(struct bna_rxf *rxf)\n{\n\tstruct bna *bna = rxf->rx->bna;\n\tint ret = 0;\n\n\tif (is_promisc_disable(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask) ||\n\t\t(!(rxf->rxmode_active & BNA_RXMODE_PROMISC))) {\n\t\t \n\t} else if (is_promisc_enable(rxf->rxmode_pending,\n\t\t\t\t\trxf->rxmode_pending_bitmask)) {\n\t\t \n\t\tpromisc_inactive(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask);\n\t\tbna->promisc_rid = BFI_INVALID_RID;\n\t} else if (rxf->rxmode_active & BNA_RXMODE_PROMISC) {\n\t\t \n\t\tpromisc_disable(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nbna_rxf_allmulti_enable(struct bna_rxf *rxf)\n{\n\tint ret = 0;\n\n\tif (is_allmulti_enable(rxf->rxmode_pending,\n\t\t\trxf->rxmode_pending_bitmask) ||\n\t\t\t(rxf->rxmode_active & BNA_RXMODE_ALLMULTI)) {\n\t\t \n\t} else if (is_allmulti_disable(rxf->rxmode_pending,\n\t\t\t\t\trxf->rxmode_pending_bitmask)) {\n\t\t \n\t\tallmulti_inactive(rxf->rxmode_pending,\n\t\t\trxf->rxmode_pending_bitmask);\n\t} else {\n\t\t \n\t\tallmulti_enable(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nbna_rxf_allmulti_disable(struct bna_rxf *rxf)\n{\n\tint ret = 0;\n\n\tif (is_allmulti_disable(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask) ||\n\t\t(!(rxf->rxmode_active & BNA_RXMODE_ALLMULTI))) {\n\t\t \n\t} else if (is_allmulti_enable(rxf->rxmode_pending,\n\t\t\t\t\trxf->rxmode_pending_bitmask)) {\n\t\t \n\t\tallmulti_inactive(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask);\n\t} else if (rxf->rxmode_active & BNA_RXMODE_ALLMULTI) {\n\t\t \n\t\tallmulti_disable(rxf->rxmode_pending,\n\t\t\t\trxf->rxmode_pending_bitmask);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nbna_rxf_vlan_strip_cfg_apply(struct bna_rxf *rxf)\n{\n\tif (rxf->vlan_strip_pending) {\n\t\t\trxf->vlan_strip_pending = false;\n\t\t\tbna_bfi_vlan_strip_enable(rxf);\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \n\n#define\tBNA_GET_RXQS(qcfg)\t(((qcfg)->rxp_type == BNA_RXP_SINGLE) ?\t\\\n\t(qcfg)->num_paths : ((qcfg)->num_paths * 2))\n\n#define\tSIZE_TO_PAGES(size)\t(((size) >> PAGE_SHIFT) + ((((size) &\\\n\t(PAGE_SIZE - 1)) + (PAGE_SIZE - 1)) >> PAGE_SHIFT))\n\n#define\tcall_rx_stop_cbfn(rx)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t    \\\n\tif ((rx)->stop_cbfn) {\t\t\t\t\t\t\\\n\t\tvoid (*cbfn)(void *, struct bna_rx *);\t  \\\n\t\tvoid *cbarg;\t\t\t\t\t    \\\n\t\tcbfn = (rx)->stop_cbfn;\t\t\t\t \\\n\t\tcbarg = (rx)->stop_cbarg;\t\t\t       \\\n\t\t(rx)->stop_cbfn = NULL;\t\t\t\t\t\\\n\t\t(rx)->stop_cbarg = NULL;\t\t\t\t\\\n\t\tcbfn(cbarg, rx);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t       \\\n} while (0)\n\n#define call_rx_stall_cbfn(rx)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif ((rx)->rx_stall_cbfn)\t\t\t\t\t\\\n\t\t(rx)->rx_stall_cbfn((rx)->bna->bnad, (rx));\t\t\\\n} while (0)\n\n#define bfi_enet_datapath_q_init(bfi_q, bna_qpt)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstruct bna_dma_addr cur_q_addr =\t\t\t\t\\\n\t\t*((struct bna_dma_addr *)((bna_qpt)->kv_qpt_ptr));\t\\\n\t(bfi_q)->pg_tbl.a32.addr_lo = (bna_qpt)->hw_qpt_ptr.lsb;\t\\\n\t(bfi_q)->pg_tbl.a32.addr_hi = (bna_qpt)->hw_qpt_ptr.msb;\t\\\n\t(bfi_q)->first_entry.a32.addr_lo = cur_q_addr.lsb;\t\t\\\n\t(bfi_q)->first_entry.a32.addr_hi = cur_q_addr.msb;\t\t\\\n\t(bfi_q)->pages = htons((u16)(bna_qpt)->page_count);\t\\\n\t(bfi_q)->page_sz = htons((u16)(bna_qpt)->page_size);\\\n} while (0)\n\nstatic void bna_bfi_rx_enet_start(struct bna_rx *rx);\nstatic void bna_rx_enet_stop(struct bna_rx *rx);\nstatic void bna_rx_mod_cb_rx_stopped(void *arg, struct bna_rx *rx);\n\nbfa_fsm_state_decl(bna_rx, stopped,\n\tstruct bna_rx, enum bna_rx_event);\nbfa_fsm_state_decl(bna_rx, start_wait,\n\tstruct bna_rx, enum bna_rx_event);\nbfa_fsm_state_decl(bna_rx, start_stop_wait,\n\tstruct bna_rx, enum bna_rx_event);\nbfa_fsm_state_decl(bna_rx, rxf_start_wait,\n\tstruct bna_rx, enum bna_rx_event);\nbfa_fsm_state_decl(bna_rx, started,\n\tstruct bna_rx, enum bna_rx_event);\nbfa_fsm_state_decl(bna_rx, rxf_stop_wait,\n\tstruct bna_rx, enum bna_rx_event);\nbfa_fsm_state_decl(bna_rx, stop_wait,\n\tstruct bna_rx, enum bna_rx_event);\nbfa_fsm_state_decl(bna_rx, cleanup_wait,\n\tstruct bna_rx, enum bna_rx_event);\nbfa_fsm_state_decl(bna_rx, failed,\n\tstruct bna_rx, enum bna_rx_event);\nbfa_fsm_state_decl(bna_rx, quiesce_wait,\n\tstruct bna_rx, enum bna_rx_event);\n\nstatic void bna_rx_sm_stopped_entry(struct bna_rx *rx)\n{\n\tcall_rx_stop_cbfn(rx);\n}\n\nstatic void bna_rx_sm_stopped(struct bna_rx *rx,\n\t\t\t\tenum bna_rx_event event)\n{\n\tswitch (event) {\n\tcase RX_E_START:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_start_wait);\n\t\tbreak;\n\n\tcase RX_E_STOP:\n\t\tcall_rx_stop_cbfn(rx);\n\t\tbreak;\n\n\tcase RX_E_FAIL:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t\tbreak;\n\t}\n}\n\nstatic void bna_rx_sm_start_wait_entry(struct bna_rx *rx)\n{\n\tbna_bfi_rx_enet_start(rx);\n}\n\nstatic void\nbna_rx_sm_stop_wait_entry(struct bna_rx *rx)\n{\n}\n\nstatic void\nbna_rx_sm_stop_wait(struct bna_rx *rx, enum bna_rx_event event)\n{\n\tswitch (event) {\n\tcase RX_E_FAIL:\n\tcase RX_E_STOPPED:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_cleanup_wait);\n\t\trx->rx_cleanup_cbfn(rx->bna->bnad, rx);\n\t\tbreak;\n\n\tcase RX_E_STARTED:\n\t\tbna_rx_enet_stop(rx);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t\tbreak;\n\t}\n}\n\nstatic void bna_rx_sm_start_wait(struct bna_rx *rx,\n\t\t\t\tenum bna_rx_event event)\n{\n\tswitch (event) {\n\tcase RX_E_STOP:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_start_stop_wait);\n\t\tbreak;\n\n\tcase RX_E_FAIL:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_stopped);\n\t\tbreak;\n\n\tcase RX_E_STARTED:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_rxf_start_wait);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t\tbreak;\n\t}\n}\n\nstatic void bna_rx_sm_rxf_start_wait_entry(struct bna_rx *rx)\n{\n\trx->rx_post_cbfn(rx->bna->bnad, rx);\n\tbna_rxf_start(&rx->rxf);\n}\n\nstatic void\nbna_rx_sm_rxf_stop_wait_entry(struct bna_rx *rx)\n{\n}\n\nstatic void\nbna_rx_sm_rxf_stop_wait(struct bna_rx *rx, enum bna_rx_event event)\n{\n\tswitch (event) {\n\tcase RX_E_FAIL:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_cleanup_wait);\n\t\tbna_rxf_fail(&rx->rxf);\n\t\tcall_rx_stall_cbfn(rx);\n\t\trx->rx_cleanup_cbfn(rx->bna->bnad, rx);\n\t\tbreak;\n\n\tcase RX_E_RXF_STARTED:\n\t\tbna_rxf_stop(&rx->rxf);\n\t\tbreak;\n\n\tcase RX_E_RXF_STOPPED:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_stop_wait);\n\t\tcall_rx_stall_cbfn(rx);\n\t\tbna_rx_enet_stop(rx);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t\tbreak;\n\t}\n\n}\n\nstatic void\nbna_rx_sm_start_stop_wait_entry(struct bna_rx *rx)\n{\n}\n\nstatic void\nbna_rx_sm_start_stop_wait(struct bna_rx *rx, enum bna_rx_event event)\n{\n\tswitch (event) {\n\tcase RX_E_FAIL:\n\tcase RX_E_STOPPED:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_stopped);\n\t\tbreak;\n\n\tcase RX_E_STARTED:\n\t\tbna_rx_enet_stop(rx);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbna_rx_sm_started_entry(struct bna_rx *rx)\n{\n\tstruct bna_rxp *rxp;\n\tint is_regular = (rx->type == BNA_RX_T_REGULAR);\n\n\t \n\tlist_for_each_entry(rxp, &rx->rxp_q, qe)\n\t\tbna_ib_start(rx->bna, &rxp->cq.ib, is_regular);\n\n\tbna_ethport_cb_rx_started(&rx->bna->ethport);\n}\n\nstatic void\nbna_rx_sm_started(struct bna_rx *rx, enum bna_rx_event event)\n{\n\tswitch (event) {\n\tcase RX_E_STOP:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_rxf_stop_wait);\n\t\tbna_ethport_cb_rx_stopped(&rx->bna->ethport);\n\t\tbna_rxf_stop(&rx->rxf);\n\t\tbreak;\n\n\tcase RX_E_FAIL:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_failed);\n\t\tbna_ethport_cb_rx_stopped(&rx->bna->ethport);\n\t\tbna_rxf_fail(&rx->rxf);\n\t\tcall_rx_stall_cbfn(rx);\n\t\trx->rx_cleanup_cbfn(rx->bna->bnad, rx);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t\tbreak;\n\t}\n}\n\nstatic void bna_rx_sm_rxf_start_wait(struct bna_rx *rx,\n\t\t\t\tenum bna_rx_event event)\n{\n\tswitch (event) {\n\tcase RX_E_STOP:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_rxf_stop_wait);\n\t\tbreak;\n\n\tcase RX_E_FAIL:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_failed);\n\t\tbna_rxf_fail(&rx->rxf);\n\t\tcall_rx_stall_cbfn(rx);\n\t\trx->rx_cleanup_cbfn(rx->bna->bnad, rx);\n\t\tbreak;\n\n\tcase RX_E_RXF_STARTED:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_started);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t\tbreak;\n\t}\n}\n\nstatic void\nbna_rx_sm_cleanup_wait_entry(struct bna_rx *rx)\n{\n}\n\nstatic void\nbna_rx_sm_cleanup_wait(struct bna_rx *rx, enum bna_rx_event event)\n{\n\tswitch (event) {\n\tcase RX_E_FAIL:\n\tcase RX_E_RXF_STOPPED:\n\t\t \n\t\tbreak;\n\n\tcase RX_E_CLEANUP_DONE:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_stopped);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t\tbreak;\n\t}\n}\n\nstatic void\nbna_rx_sm_failed_entry(struct bna_rx *rx)\n{\n}\n\nstatic void\nbna_rx_sm_failed(struct bna_rx *rx, enum bna_rx_event event)\n{\n\tswitch (event) {\n\tcase RX_E_START:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_quiesce_wait);\n\t\tbreak;\n\n\tcase RX_E_STOP:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_cleanup_wait);\n\t\tbreak;\n\n\tcase RX_E_FAIL:\n\tcase RX_E_RXF_STARTED:\n\tcase RX_E_RXF_STOPPED:\n\t\t \n\t\tbreak;\n\n\tcase RX_E_CLEANUP_DONE:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_stopped);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t\tbreak;\n}\t}\n\nstatic void\nbna_rx_sm_quiesce_wait_entry(struct bna_rx *rx)\n{\n}\n\nstatic void\nbna_rx_sm_quiesce_wait(struct bna_rx *rx, enum bna_rx_event event)\n{\n\tswitch (event) {\n\tcase RX_E_STOP:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_cleanup_wait);\n\t\tbreak;\n\n\tcase RX_E_FAIL:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_failed);\n\t\tbreak;\n\n\tcase RX_E_CLEANUP_DONE:\n\t\tbfa_fsm_set_state(rx, bna_rx_sm_start_wait);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t\tbreak;\n\t}\n}\n\nstatic void\nbna_bfi_rx_enet_start(struct bna_rx *rx)\n{\n\tstruct bfi_enet_rx_cfg_req *cfg_req = &rx->bfi_enet_cmd.cfg_req;\n\tstruct bna_rxp *rxp = NULL;\n\tstruct bna_rxq *q0 = NULL, *q1 = NULL;\n\tint i;\n\n\tbfi_msgq_mhdr_set(cfg_req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_RX_CFG_SET_REQ, 0, rx->rid);\n\tcfg_req->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_rx_cfg_req)));\n\n\tcfg_req->rx_cfg.frame_size = bna_enet_mtu_get(&rx->bna->enet);\n\tcfg_req->num_queue_sets = rx->num_paths;\n\tfor (i = 0; i < rx->num_paths; i++) {\n\t\trxp = rxp ? list_next_entry(rxp, qe)\n\t\t\t: list_first_entry(&rx->rxp_q, struct bna_rxp, qe);\n\t\tGET_RXQS(rxp, q0, q1);\n\t\tswitch (rxp->type) {\n\t\tcase BNA_RXP_SLR:\n\t\tcase BNA_RXP_HDS:\n\t\t\t \n\t\t\tbfi_enet_datapath_q_init(&cfg_req->q_cfg[i].qs.q,\n\t\t\t\t\t\t&q1->qpt);\n\t\t\tcfg_req->q_cfg[i].qs.rx_buffer_size =\n\t\t\t\thtons((u16)q1->buffer_size);\n\t\t\tfallthrough;\n\n\t\tcase BNA_RXP_SINGLE:\n\t\t\t \n\t\t\tbfi_enet_datapath_q_init(&cfg_req->q_cfg[i].ql.q,\n\t\t\t\t\t\t&q0->qpt);\n\t\t\tif (q0->multi_buffer)\n\t\t\t\t \n\t\t\t\tcfg_req->rx_cfg.multi_buffer =\n\t\t\t\t\tBNA_STATUS_T_ENABLED;\n\t\t\telse\n\t\t\t\tq0->buffer_size =\n\t\t\t\t\tbna_enet_mtu_get(&rx->bna->enet);\n\t\t\tcfg_req->q_cfg[i].ql.rx_buffer_size =\n\t\t\t\thtons((u16)q0->buffer_size);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG_ON(1);\n\t\t}\n\n\t\tbfi_enet_datapath_q_init(&cfg_req->q_cfg[i].cq.q,\n\t\t\t\t\t&rxp->cq.qpt);\n\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_lo =\n\t\t\trxp->cq.ib.ib_seg_host_addr.lsb;\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_hi =\n\t\t\trxp->cq.ib.ib_seg_host_addr.msb;\n\t\tcfg_req->q_cfg[i].ib.intr.msix_index =\n\t\t\thtons((u16)rxp->cq.ib.intr_vector);\n\t}\n\n\tcfg_req->ib_cfg.int_pkt_dma = BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.int_enabled = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.int_pkt_enabled = BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.continuous_coalescing = BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.msix = (rxp->cq.ib.intr_type == BNA_INTR_T_MSIX)\n\t\t\t\t? BNA_STATUS_T_ENABLED :\n\t\t\t\tBNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.coalescing_timeout =\n\t\t\thtonl((u32)rxp->cq.ib.coalescing_timeo);\n\tcfg_req->ib_cfg.inter_pkt_timeout =\n\t\t\thtonl((u32)rxp->cq.ib.interpkt_timeo);\n\tcfg_req->ib_cfg.inter_pkt_count = (u8)rxp->cq.ib.interpkt_count;\n\n\tswitch (rxp->type) {\n\tcase BNA_RXP_SLR:\n\t\tcfg_req->rx_cfg.rxq_type = BFI_ENET_RXQ_LARGE_SMALL;\n\t\tbreak;\n\n\tcase BNA_RXP_HDS:\n\t\tcfg_req->rx_cfg.rxq_type = BFI_ENET_RXQ_HDS;\n\t\tcfg_req->rx_cfg.hds.type = rx->hds_cfg.hdr_type;\n\t\tcfg_req->rx_cfg.hds.force_offset = rx->hds_cfg.forced_offset;\n\t\tcfg_req->rx_cfg.hds.max_header_size = rx->hds_cfg.forced_offset;\n\t\tbreak;\n\n\tcase BNA_RXP_SINGLE:\n\t\tcfg_req->rx_cfg.rxq_type = BFI_ENET_RXQ_SINGLE;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG_ON(1);\n\t}\n\tcfg_req->rx_cfg.strip_vlan = rx->rxf.vlan_strip_status;\n\n\tbfa_msgq_cmd_set(&rx->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_rx_cfg_req), &cfg_req->mh);\n\tbfa_msgq_cmd_post(&rx->bna->msgq, &rx->msgq_cmd);\n}\n\nstatic void\nbna_bfi_rx_enet_stop(struct bna_rx *rx)\n{\n\tstruct bfi_enet_req *req = &rx->bfi_enet_cmd.req;\n\n\tbfi_msgq_mhdr_set(req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_RX_CFG_CLR_REQ, 0, rx->rid);\n\treq->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_req)));\n\tbfa_msgq_cmd_set(&rx->msgq_cmd, NULL, NULL, sizeof(struct bfi_enet_req),\n\t\t&req->mh);\n\tbfa_msgq_cmd_post(&rx->bna->msgq, &rx->msgq_cmd);\n}\n\nstatic void\nbna_rx_enet_stop(struct bna_rx *rx)\n{\n\tstruct bna_rxp *rxp;\n\n\t \n\tlist_for_each_entry(rxp, &rx->rxp_q, qe)\n\t\tbna_ib_stop(rx->bna, &rxp->cq.ib);\n\n\tbna_bfi_rx_enet_stop(rx);\n}\n\nstatic int\nbna_rx_res_check(struct bna_rx_mod *rx_mod, struct bna_rx_config *rx_cfg)\n{\n\tif ((rx_mod->rx_free_count == 0) ||\n\t\t(rx_mod->rxp_free_count == 0) ||\n\t\t(rx_mod->rxq_free_count == 0))\n\t\treturn 0;\n\n\tif (rx_cfg->rxp_type == BNA_RXP_SINGLE) {\n\t\tif ((rx_mod->rxp_free_count < rx_cfg->num_paths) ||\n\t\t\t(rx_mod->rxq_free_count < rx_cfg->num_paths))\n\t\t\t\treturn 0;\n\t} else {\n\t\tif ((rx_mod->rxp_free_count < rx_cfg->num_paths) ||\n\t\t\t(rx_mod->rxq_free_count < (2 * rx_cfg->num_paths)))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic struct bna_rxq *\nbna_rxq_get(struct bna_rx_mod *rx_mod)\n{\n\tstruct bna_rxq *rxq = NULL;\n\n\trxq = list_first_entry(&rx_mod->rxq_free_q, struct bna_rxq, qe);\n\tlist_del(&rxq->qe);\n\trx_mod->rxq_free_count--;\n\n\treturn rxq;\n}\n\nstatic void\nbna_rxq_put(struct bna_rx_mod *rx_mod, struct bna_rxq *rxq)\n{\n\tlist_add_tail(&rxq->qe, &rx_mod->rxq_free_q);\n\trx_mod->rxq_free_count++;\n}\n\nstatic struct bna_rxp *\nbna_rxp_get(struct bna_rx_mod *rx_mod)\n{\n\tstruct bna_rxp *rxp = NULL;\n\n\trxp = list_first_entry(&rx_mod->rxp_free_q, struct bna_rxp, qe);\n\tlist_del(&rxp->qe);\n\trx_mod->rxp_free_count--;\n\n\treturn rxp;\n}\n\nstatic void\nbna_rxp_put(struct bna_rx_mod *rx_mod, struct bna_rxp *rxp)\n{\n\tlist_add_tail(&rxp->qe, &rx_mod->rxp_free_q);\n\trx_mod->rxp_free_count++;\n}\n\nstatic struct bna_rx *\nbna_rx_get(struct bna_rx_mod *rx_mod, enum bna_rx_type type)\n{\n\tstruct bna_rx *rx = NULL;\n\n\tBUG_ON(list_empty(&rx_mod->rx_free_q));\n\tif (type == BNA_RX_T_REGULAR)\n\t\trx = list_first_entry(&rx_mod->rx_free_q, struct bna_rx, qe);\n\telse\n\t\trx = list_last_entry(&rx_mod->rx_free_q, struct bna_rx, qe);\n\n\trx_mod->rx_free_count--;\n\tlist_move_tail(&rx->qe, &rx_mod->rx_active_q);\n\trx->type = type;\n\n\treturn rx;\n}\n\nstatic void\nbna_rx_put(struct bna_rx_mod *rx_mod, struct bna_rx *rx)\n{\n\tstruct list_head *qe;\n\n\tlist_for_each_prev(qe, &rx_mod->rx_free_q)\n\t\tif (((struct bna_rx *)qe)->rid < rx->rid)\n\t\t\tbreak;\n\n\tlist_add(&rx->qe, qe);\n\trx_mod->rx_free_count++;\n}\n\nstatic void\nbna_rxp_add_rxqs(struct bna_rxp *rxp, struct bna_rxq *q0,\n\t\tstruct bna_rxq *q1)\n{\n\tswitch (rxp->type) {\n\tcase BNA_RXP_SINGLE:\n\t\trxp->rxq.single.only = q0;\n\t\trxp->rxq.single.reserved = NULL;\n\t\tbreak;\n\tcase BNA_RXP_SLR:\n\t\trxp->rxq.slr.large = q0;\n\t\trxp->rxq.slr.small = q1;\n\t\tbreak;\n\tcase BNA_RXP_HDS:\n\t\trxp->rxq.hds.data = q0;\n\t\trxp->rxq.hds.hdr = q1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nbna_rxq_qpt_setup(struct bna_rxq *rxq,\n\t\tstruct bna_rxp *rxp,\n\t\tu32 page_count,\n\t\tu32 page_size,\n\t\tstruct bna_mem_descr *qpt_mem,\n\t\tstruct bna_mem_descr *swqpt_mem,\n\t\tstruct bna_mem_descr *page_mem)\n{\n\tu8 *kva;\n\tu64 dma;\n\tstruct bna_dma_addr bna_dma;\n\tint\ti;\n\n\trxq->qpt.hw_qpt_ptr.lsb = qpt_mem->dma.lsb;\n\trxq->qpt.hw_qpt_ptr.msb = qpt_mem->dma.msb;\n\trxq->qpt.kv_qpt_ptr = qpt_mem->kva;\n\trxq->qpt.page_count = page_count;\n\trxq->qpt.page_size = page_size;\n\n\trxq->rcb->sw_qpt = (void **) swqpt_mem->kva;\n\trxq->rcb->sw_q = page_mem->kva;\n\n\tkva = page_mem->kva;\n\tBNA_GET_DMA_ADDR(&page_mem->dma, dma);\n\n\tfor (i = 0; i < rxq->qpt.page_count; i++) {\n\t\trxq->rcb->sw_qpt[i] = kva;\n\t\tkva += PAGE_SIZE;\n\n\t\tBNA_SET_DMA_ADDR(dma, &bna_dma);\n\t\t((struct bna_dma_addr *)rxq->qpt.kv_qpt_ptr)[i].lsb =\n\t\t\tbna_dma.lsb;\n\t\t((struct bna_dma_addr *)rxq->qpt.kv_qpt_ptr)[i].msb =\n\t\t\tbna_dma.msb;\n\t\tdma += PAGE_SIZE;\n\t}\n}\n\nstatic void\nbna_rxp_cqpt_setup(struct bna_rxp *rxp,\n\t\tu32 page_count,\n\t\tu32 page_size,\n\t\tstruct bna_mem_descr *qpt_mem,\n\t\tstruct bna_mem_descr *swqpt_mem,\n\t\tstruct bna_mem_descr *page_mem)\n{\n\tu8 *kva;\n\tu64 dma;\n\tstruct bna_dma_addr bna_dma;\n\tint\ti;\n\n\trxp->cq.qpt.hw_qpt_ptr.lsb = qpt_mem->dma.lsb;\n\trxp->cq.qpt.hw_qpt_ptr.msb = qpt_mem->dma.msb;\n\trxp->cq.qpt.kv_qpt_ptr = qpt_mem->kva;\n\trxp->cq.qpt.page_count = page_count;\n\trxp->cq.qpt.page_size = page_size;\n\n\trxp->cq.ccb->sw_qpt = (void **) swqpt_mem->kva;\n\trxp->cq.ccb->sw_q = page_mem->kva;\n\n\tkva = page_mem->kva;\n\tBNA_GET_DMA_ADDR(&page_mem->dma, dma);\n\n\tfor (i = 0; i < rxp->cq.qpt.page_count; i++) {\n\t\trxp->cq.ccb->sw_qpt[i] = kva;\n\t\tkva += PAGE_SIZE;\n\n\t\tBNA_SET_DMA_ADDR(dma, &bna_dma);\n\t\t((struct bna_dma_addr *)rxp->cq.qpt.kv_qpt_ptr)[i].lsb =\n\t\t\tbna_dma.lsb;\n\t\t((struct bna_dma_addr *)rxp->cq.qpt.kv_qpt_ptr)[i].msb =\n\t\t\tbna_dma.msb;\n\t\tdma += PAGE_SIZE;\n\t}\n}\n\nstatic void\nbna_rx_mod_cb_rx_stopped(void *arg, struct bna_rx *rx)\n{\n\tstruct bna_rx_mod *rx_mod = (struct bna_rx_mod *)arg;\n\n\tbfa_wc_down(&rx_mod->rx_stop_wc);\n}\n\nstatic void\nbna_rx_mod_cb_rx_stopped_all(void *arg)\n{\n\tstruct bna_rx_mod *rx_mod = (struct bna_rx_mod *)arg;\n\n\tif (rx_mod->stop_cbfn)\n\t\trx_mod->stop_cbfn(&rx_mod->bna->enet);\n\trx_mod->stop_cbfn = NULL;\n}\n\nstatic void\nbna_rx_start(struct bna_rx *rx)\n{\n\trx->rx_flags |= BNA_RX_F_ENET_STARTED;\n\tif (rx->rx_flags & BNA_RX_F_ENABLED)\n\t\tbfa_fsm_send_event(rx, RX_E_START);\n}\n\nstatic void\nbna_rx_stop(struct bna_rx *rx)\n{\n\trx->rx_flags &= ~BNA_RX_F_ENET_STARTED;\n\tif (rx->fsm == bna_rx_sm_stopped)\n\t\tbna_rx_mod_cb_rx_stopped(&rx->bna->rx_mod, rx);\n\telse {\n\t\trx->stop_cbfn = bna_rx_mod_cb_rx_stopped;\n\t\trx->stop_cbarg = &rx->bna->rx_mod;\n\t\tbfa_fsm_send_event(rx, RX_E_STOP);\n\t}\n}\n\nstatic void\nbna_rx_fail(struct bna_rx *rx)\n{\n\t \n\trx->rx_flags &= ~BNA_RX_F_ENET_STARTED;\n\tbfa_fsm_send_event(rx, RX_E_FAIL);\n}\n\nvoid\nbna_rx_mod_start(struct bna_rx_mod *rx_mod, enum bna_rx_type type)\n{\n\tstruct bna_rx *rx;\n\n\trx_mod->flags |= BNA_RX_MOD_F_ENET_STARTED;\n\tif (type == BNA_RX_T_LOOPBACK)\n\t\trx_mod->flags |= BNA_RX_MOD_F_ENET_LOOPBACK;\n\n\tlist_for_each_entry(rx, &rx_mod->rx_active_q, qe)\n\t\tif (rx->type == type)\n\t\t\tbna_rx_start(rx);\n}\n\nvoid\nbna_rx_mod_stop(struct bna_rx_mod *rx_mod, enum bna_rx_type type)\n{\n\tstruct bna_rx *rx;\n\n\trx_mod->flags &= ~BNA_RX_MOD_F_ENET_STARTED;\n\trx_mod->flags &= ~BNA_RX_MOD_F_ENET_LOOPBACK;\n\n\trx_mod->stop_cbfn = bna_enet_cb_rx_stopped;\n\n\tbfa_wc_init(&rx_mod->rx_stop_wc, bna_rx_mod_cb_rx_stopped_all, rx_mod);\n\n\tlist_for_each_entry(rx, &rx_mod->rx_active_q, qe)\n\t\tif (rx->type == type) {\n\t\t\tbfa_wc_up(&rx_mod->rx_stop_wc);\n\t\t\tbna_rx_stop(rx);\n\t\t}\n\n\tbfa_wc_wait(&rx_mod->rx_stop_wc);\n}\n\nvoid\nbna_rx_mod_fail(struct bna_rx_mod *rx_mod)\n{\n\tstruct bna_rx *rx;\n\n\trx_mod->flags &= ~BNA_RX_MOD_F_ENET_STARTED;\n\trx_mod->flags &= ~BNA_RX_MOD_F_ENET_LOOPBACK;\n\n\tlist_for_each_entry(rx, &rx_mod->rx_active_q, qe)\n\t\tbna_rx_fail(rx);\n}\n\nvoid bna_rx_mod_init(struct bna_rx_mod *rx_mod, struct bna *bna,\n\t\t\tstruct bna_res_info *res_info)\n{\n\tint\tindex;\n\tstruct bna_rx *rx_ptr;\n\tstruct bna_rxp *rxp_ptr;\n\tstruct bna_rxq *rxq_ptr;\n\n\trx_mod->bna = bna;\n\trx_mod->flags = 0;\n\n\trx_mod->rx = (struct bna_rx *)\n\t\tres_info[BNA_MOD_RES_MEM_T_RX_ARRAY].res_u.mem_info.mdl[0].kva;\n\trx_mod->rxp = (struct bna_rxp *)\n\t\tres_info[BNA_MOD_RES_MEM_T_RXP_ARRAY].res_u.mem_info.mdl[0].kva;\n\trx_mod->rxq = (struct bna_rxq *)\n\t\tres_info[BNA_MOD_RES_MEM_T_RXQ_ARRAY].res_u.mem_info.mdl[0].kva;\n\n\t \n\tINIT_LIST_HEAD(&rx_mod->rx_free_q);\n\trx_mod->rx_free_count = 0;\n\tINIT_LIST_HEAD(&rx_mod->rxq_free_q);\n\trx_mod->rxq_free_count = 0;\n\tINIT_LIST_HEAD(&rx_mod->rxp_free_q);\n\trx_mod->rxp_free_count = 0;\n\tINIT_LIST_HEAD(&rx_mod->rx_active_q);\n\n\t \n\tfor (index = 0; index < bna->ioceth.attr.num_rxp; index++) {\n\t\trx_ptr = &rx_mod->rx[index];\n\n\t\tINIT_LIST_HEAD(&rx_ptr->rxp_q);\n\t\trx_ptr->bna = NULL;\n\t\trx_ptr->rid = index;\n\t\trx_ptr->stop_cbfn = NULL;\n\t\trx_ptr->stop_cbarg = NULL;\n\n\t\tlist_add_tail(&rx_ptr->qe, &rx_mod->rx_free_q);\n\t\trx_mod->rx_free_count++;\n\t}\n\n\t \n\tfor (index = 0; index < bna->ioceth.attr.num_rxp; index++) {\n\t\trxp_ptr = &rx_mod->rxp[index];\n\t\tlist_add_tail(&rxp_ptr->qe, &rx_mod->rxp_free_q);\n\t\trx_mod->rxp_free_count++;\n\t}\n\n\t \n\tfor (index = 0; index < (bna->ioceth.attr.num_rxp * 2); index++) {\n\t\trxq_ptr = &rx_mod->rxq[index];\n\t\tlist_add_tail(&rxq_ptr->qe, &rx_mod->rxq_free_q);\n\t\trx_mod->rxq_free_count++;\n\t}\n}\n\nvoid\nbna_rx_mod_uninit(struct bna_rx_mod *rx_mod)\n{\n\trx_mod->bna = NULL;\n}\n\nvoid\nbna_bfi_rx_enet_start_rsp(struct bna_rx *rx, struct bfi_msgq_mhdr *msghdr)\n{\n\tstruct bfi_enet_rx_cfg_rsp *cfg_rsp = &rx->bfi_enet_cmd.cfg_rsp;\n\tstruct bna_rxp *rxp = NULL;\n\tstruct bna_rxq *q0 = NULL, *q1 = NULL;\n\tint i;\n\n\tbfa_msgq_rsp_copy(&rx->bna->msgq, (u8 *)cfg_rsp,\n\t\tsizeof(struct bfi_enet_rx_cfg_rsp));\n\n\trx->hw_id = cfg_rsp->hw_id;\n\n\tfor (i = 0, rxp = list_first_entry(&rx->rxp_q, struct bna_rxp, qe);\n\t     i < rx->num_paths; i++, rxp = list_next_entry(rxp, qe)) {\n\t\tGET_RXQS(rxp, q0, q1);\n\n\t\t \n\t\trxp->cq.ccb->i_dbell->doorbell_addr =\n\t\t\trx->bna->pcidev.pci_bar_kva\n\t\t\t+ ntohl(cfg_rsp->q_handles[i].i_dbell);\n\t\trxp->hw_id = cfg_rsp->q_handles[i].hw_cqid;\n\t\tq0->rcb->q_dbell =\n\t\t\trx->bna->pcidev.pci_bar_kva\n\t\t\t+ ntohl(cfg_rsp->q_handles[i].ql_dbell);\n\t\tq0->hw_id = cfg_rsp->q_handles[i].hw_lqid;\n\t\tif (q1) {\n\t\t\tq1->rcb->q_dbell =\n\t\t\trx->bna->pcidev.pci_bar_kva\n\t\t\t+ ntohl(cfg_rsp->q_handles[i].qs_dbell);\n\t\t\tq1->hw_id = cfg_rsp->q_handles[i].hw_sqid;\n\t\t}\n\n\t\t \n\t\t(*rxp->cq.ccb->hw_producer_index) = 0;\n\t\trxp->cq.ccb->producer_index = 0;\n\t\tq0->rcb->producer_index = q0->rcb->consumer_index = 0;\n\t\tif (q1)\n\t\t\tq1->rcb->producer_index = q1->rcb->consumer_index = 0;\n\t}\n\n\tbfa_fsm_send_event(rx, RX_E_STARTED);\n}\n\nvoid\nbna_bfi_rx_enet_stop_rsp(struct bna_rx *rx, struct bfi_msgq_mhdr *msghdr)\n{\n\tbfa_fsm_send_event(rx, RX_E_STOPPED);\n}\n\nvoid\nbna_rx_res_req(struct bna_rx_config *q_cfg, struct bna_res_info *res_info)\n{\n\tu32 cq_size, hq_size, dq_size;\n\tu32 cpage_count, hpage_count, dpage_count;\n\tstruct bna_mem_info *mem_info;\n\tu32 cq_depth;\n\tu32 hq_depth;\n\tu32 dq_depth;\n\n\tdq_depth = q_cfg->q0_depth;\n\thq_depth = ((q_cfg->rxp_type == BNA_RXP_SINGLE) ? 0 : q_cfg->q1_depth);\n\tcq_depth = roundup_pow_of_two(dq_depth + hq_depth);\n\n\tcq_size = cq_depth * BFI_CQ_WI_SIZE;\n\tcq_size = ALIGN(cq_size, PAGE_SIZE);\n\tcpage_count = SIZE_TO_PAGES(cq_size);\n\n\tdq_depth = roundup_pow_of_two(dq_depth);\n\tdq_size = dq_depth * BFI_RXQ_WI_SIZE;\n\tdq_size = ALIGN(dq_size, PAGE_SIZE);\n\tdpage_count = SIZE_TO_PAGES(dq_size);\n\n\tif (BNA_RXP_SINGLE != q_cfg->rxp_type) {\n\t\thq_depth = roundup_pow_of_two(hq_depth);\n\t\thq_size = hq_depth * BFI_RXQ_WI_SIZE;\n\t\thq_size = ALIGN(hq_size, PAGE_SIZE);\n\t\thpage_count = SIZE_TO_PAGES(hq_size);\n\t} else\n\t\thpage_count = 0;\n\n\tres_info[BNA_RX_RES_MEM_T_CCB].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_RX_RES_MEM_T_CCB].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_KVA;\n\tmem_info->len = sizeof(struct bna_ccb);\n\tmem_info->num = q_cfg->num_paths;\n\n\tres_info[BNA_RX_RES_MEM_T_RCB].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_RX_RES_MEM_T_RCB].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_KVA;\n\tmem_info->len = sizeof(struct bna_rcb);\n\tmem_info->num = BNA_GET_RXQS(q_cfg);\n\n\tres_info[BNA_RX_RES_MEM_T_CQPT].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_RX_RES_MEM_T_CQPT].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_DMA;\n\tmem_info->len = cpage_count * sizeof(struct bna_dma_addr);\n\tmem_info->num = q_cfg->num_paths;\n\n\tres_info[BNA_RX_RES_MEM_T_CSWQPT].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_RX_RES_MEM_T_CSWQPT].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_KVA;\n\tmem_info->len = cpage_count * sizeof(void *);\n\tmem_info->num = q_cfg->num_paths;\n\n\tres_info[BNA_RX_RES_MEM_T_CQPT_PAGE].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_RX_RES_MEM_T_CQPT_PAGE].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_DMA;\n\tmem_info->len = PAGE_SIZE * cpage_count;\n\tmem_info->num = q_cfg->num_paths;\n\n\tres_info[BNA_RX_RES_MEM_T_DQPT].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_RX_RES_MEM_T_DQPT].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_DMA;\n\tmem_info->len = dpage_count * sizeof(struct bna_dma_addr);\n\tmem_info->num = q_cfg->num_paths;\n\n\tres_info[BNA_RX_RES_MEM_T_DSWQPT].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_RX_RES_MEM_T_DSWQPT].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_KVA;\n\tmem_info->len = dpage_count * sizeof(void *);\n\tmem_info->num = q_cfg->num_paths;\n\n\tres_info[BNA_RX_RES_MEM_T_DPAGE].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_RX_RES_MEM_T_DPAGE].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_DMA;\n\tmem_info->len = PAGE_SIZE * dpage_count;\n\tmem_info->num = q_cfg->num_paths;\n\n\tres_info[BNA_RX_RES_MEM_T_HQPT].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_RX_RES_MEM_T_HQPT].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_DMA;\n\tmem_info->len = hpage_count * sizeof(struct bna_dma_addr);\n\tmem_info->num = (hpage_count ? q_cfg->num_paths : 0);\n\n\tres_info[BNA_RX_RES_MEM_T_HSWQPT].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_RX_RES_MEM_T_HSWQPT].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_KVA;\n\tmem_info->len = hpage_count * sizeof(void *);\n\tmem_info->num = (hpage_count ? q_cfg->num_paths : 0);\n\n\tres_info[BNA_RX_RES_MEM_T_HPAGE].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_RX_RES_MEM_T_HPAGE].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_DMA;\n\tmem_info->len = PAGE_SIZE * hpage_count;\n\tmem_info->num = (hpage_count ? q_cfg->num_paths : 0);\n\n\tres_info[BNA_RX_RES_MEM_T_IBIDX].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_RX_RES_MEM_T_IBIDX].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_DMA;\n\tmem_info->len = BFI_IBIDX_SIZE;\n\tmem_info->num = q_cfg->num_paths;\n\n\tres_info[BNA_RX_RES_MEM_T_RIT].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_RX_RES_MEM_T_RIT].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_KVA;\n\tmem_info->len = BFI_ENET_RSS_RIT_MAX;\n\tmem_info->num = 1;\n\n\tres_info[BNA_RX_RES_T_INTR].res_type = BNA_RES_T_INTR;\n\tres_info[BNA_RX_RES_T_INTR].res_u.intr_info.intr_type = BNA_INTR_T_MSIX;\n\tres_info[BNA_RX_RES_T_INTR].res_u.intr_info.num = q_cfg->num_paths;\n}\n\nstruct bna_rx *\nbna_rx_create(struct bna *bna, struct bnad *bnad,\n\t\tstruct bna_rx_config *rx_cfg,\n\t\tconst struct bna_rx_event_cbfn *rx_cbfn,\n\t\tstruct bna_res_info *res_info,\n\t\tvoid *priv)\n{\n\tstruct bna_rx_mod *rx_mod = &bna->rx_mod;\n\tstruct bna_rx *rx;\n\tstruct bna_rxp *rxp;\n\tstruct bna_rxq *q0;\n\tstruct bna_rxq *q1;\n\tstruct bna_intr_info *intr_info;\n\tstruct bna_mem_descr *hqunmap_mem;\n\tstruct bna_mem_descr *dqunmap_mem;\n\tstruct bna_mem_descr *ccb_mem;\n\tstruct bna_mem_descr *rcb_mem;\n\tstruct bna_mem_descr *cqpt_mem;\n\tstruct bna_mem_descr *cswqpt_mem;\n\tstruct bna_mem_descr *cpage_mem;\n\tstruct bna_mem_descr *hqpt_mem;\n\tstruct bna_mem_descr *dqpt_mem;\n\tstruct bna_mem_descr *hsqpt_mem;\n\tstruct bna_mem_descr *dsqpt_mem;\n\tstruct bna_mem_descr *hpage_mem;\n\tstruct bna_mem_descr *dpage_mem;\n\tu32 dpage_count, hpage_count;\n\tu32 hq_idx, dq_idx, rcb_idx;\n\tu32 cq_depth, i;\n\tu32 page_count;\n\n\tif (!bna_rx_res_check(rx_mod, rx_cfg))\n\t\treturn NULL;\n\n\tintr_info = &res_info[BNA_RX_RES_T_INTR].res_u.intr_info;\n\tccb_mem = &res_info[BNA_RX_RES_MEM_T_CCB].res_u.mem_info.mdl[0];\n\trcb_mem = &res_info[BNA_RX_RES_MEM_T_RCB].res_u.mem_info.mdl[0];\n\tdqunmap_mem = &res_info[BNA_RX_RES_MEM_T_UNMAPDQ].res_u.mem_info.mdl[0];\n\thqunmap_mem = &res_info[BNA_RX_RES_MEM_T_UNMAPHQ].res_u.mem_info.mdl[0];\n\tcqpt_mem = &res_info[BNA_RX_RES_MEM_T_CQPT].res_u.mem_info.mdl[0];\n\tcswqpt_mem = &res_info[BNA_RX_RES_MEM_T_CSWQPT].res_u.mem_info.mdl[0];\n\tcpage_mem = &res_info[BNA_RX_RES_MEM_T_CQPT_PAGE].res_u.mem_info.mdl[0];\n\thqpt_mem = &res_info[BNA_RX_RES_MEM_T_HQPT].res_u.mem_info.mdl[0];\n\tdqpt_mem = &res_info[BNA_RX_RES_MEM_T_DQPT].res_u.mem_info.mdl[0];\n\thsqpt_mem = &res_info[BNA_RX_RES_MEM_T_HSWQPT].res_u.mem_info.mdl[0];\n\tdsqpt_mem = &res_info[BNA_RX_RES_MEM_T_DSWQPT].res_u.mem_info.mdl[0];\n\thpage_mem = &res_info[BNA_RX_RES_MEM_T_HPAGE].res_u.mem_info.mdl[0];\n\tdpage_mem = &res_info[BNA_RX_RES_MEM_T_DPAGE].res_u.mem_info.mdl[0];\n\n\tpage_count = res_info[BNA_RX_RES_MEM_T_CQPT_PAGE].res_u.mem_info.len /\n\t\t\tPAGE_SIZE;\n\n\tdpage_count = res_info[BNA_RX_RES_MEM_T_DPAGE].res_u.mem_info.len /\n\t\t\tPAGE_SIZE;\n\n\thpage_count = res_info[BNA_RX_RES_MEM_T_HPAGE].res_u.mem_info.len /\n\t\t\tPAGE_SIZE;\n\n\trx = bna_rx_get(rx_mod, rx_cfg->rx_type);\n\trx->bna = bna;\n\trx->rx_flags = 0;\n\tINIT_LIST_HEAD(&rx->rxp_q);\n\trx->stop_cbfn = NULL;\n\trx->stop_cbarg = NULL;\n\trx->priv = priv;\n\n\trx->rcb_setup_cbfn = rx_cbfn->rcb_setup_cbfn;\n\trx->rcb_destroy_cbfn = rx_cbfn->rcb_destroy_cbfn;\n\trx->ccb_setup_cbfn = rx_cbfn->ccb_setup_cbfn;\n\trx->ccb_destroy_cbfn = rx_cbfn->ccb_destroy_cbfn;\n\trx->rx_stall_cbfn = rx_cbfn->rx_stall_cbfn;\n\t \n\trx->rx_cleanup_cbfn = rx_cbfn->rx_cleanup_cbfn;\n\trx->rx_post_cbfn = rx_cbfn->rx_post_cbfn;\n\n\tif (rx->bna->rx_mod.flags & BNA_RX_MOD_F_ENET_STARTED) {\n\t\tswitch (rx->type) {\n\t\tcase BNA_RX_T_REGULAR:\n\t\t\tif (!(rx->bna->rx_mod.flags &\n\t\t\t\tBNA_RX_MOD_F_ENET_LOOPBACK))\n\t\t\t\trx->rx_flags |= BNA_RX_F_ENET_STARTED;\n\t\t\tbreak;\n\t\tcase BNA_RX_T_LOOPBACK:\n\t\t\tif (rx->bna->rx_mod.flags & BNA_RX_MOD_F_ENET_LOOPBACK)\n\t\t\t\trx->rx_flags |= BNA_RX_F_ENET_STARTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trx->num_paths = rx_cfg->num_paths;\n\tfor (i = 0, hq_idx = 0, dq_idx = 0, rcb_idx = 0;\n\t\t\ti < rx->num_paths; i++) {\n\t\trxp = bna_rxp_get(rx_mod);\n\t\tlist_add_tail(&rxp->qe, &rx->rxp_q);\n\t\trxp->type = rx_cfg->rxp_type;\n\t\trxp->rx = rx;\n\t\trxp->cq.rx = rx;\n\n\t\tq0 = bna_rxq_get(rx_mod);\n\t\tif (BNA_RXP_SINGLE == rx_cfg->rxp_type)\n\t\t\tq1 = NULL;\n\t\telse\n\t\t\tq1 = bna_rxq_get(rx_mod);\n\n\t\tif (1 == intr_info->num)\n\t\t\trxp->vector = intr_info->idl[0].vector;\n\t\telse\n\t\t\trxp->vector = intr_info->idl[i].vector;\n\n\t\t \n\n\t\trxp->cq.ib.ib_seg_host_addr.lsb =\n\t\tres_info[BNA_RX_RES_MEM_T_IBIDX].res_u.mem_info.mdl[i].dma.lsb;\n\t\trxp->cq.ib.ib_seg_host_addr.msb =\n\t\tres_info[BNA_RX_RES_MEM_T_IBIDX].res_u.mem_info.mdl[i].dma.msb;\n\t\trxp->cq.ib.ib_seg_host_addr_kva =\n\t\tres_info[BNA_RX_RES_MEM_T_IBIDX].res_u.mem_info.mdl[i].kva;\n\t\trxp->cq.ib.intr_type = intr_info->intr_type;\n\t\tif (intr_info->intr_type == BNA_INTR_T_MSIX)\n\t\t\trxp->cq.ib.intr_vector = rxp->vector;\n\t\telse\n\t\t\trxp->cq.ib.intr_vector = BIT(rxp->vector);\n\t\trxp->cq.ib.coalescing_timeo = rx_cfg->coalescing_timeo;\n\t\trxp->cq.ib.interpkt_count = BFI_RX_INTERPKT_COUNT;\n\t\trxp->cq.ib.interpkt_timeo = BFI_RX_INTERPKT_TIMEO;\n\n\t\tbna_rxp_add_rxqs(rxp, q0, q1);\n\n\t\t \n\n\t\tq0->rx = rx;\n\t\tq0->rxp = rxp;\n\n\t\tq0->rcb = (struct bna_rcb *) rcb_mem[rcb_idx].kva;\n\t\tq0->rcb->unmap_q = (void *)dqunmap_mem[dq_idx].kva;\n\t\trcb_idx++; dq_idx++;\n\t\tq0->rcb->q_depth = rx_cfg->q0_depth;\n\t\tq0->q_depth = rx_cfg->q0_depth;\n\t\tq0->multi_buffer = rx_cfg->q0_multi_buf;\n\t\tq0->buffer_size = rx_cfg->q0_buf_size;\n\t\tq0->num_vecs = rx_cfg->q0_num_vecs;\n\t\tq0->rcb->rxq = q0;\n\t\tq0->rcb->bnad = bna->bnad;\n\t\tq0->rcb->id = 0;\n\t\tq0->rx_packets = q0->rx_bytes = 0;\n\t\tq0->rx_packets_with_error = q0->rxbuf_alloc_failed = 0;\n\t\tq0->rxbuf_map_failed = 0;\n\n\t\tbna_rxq_qpt_setup(q0, rxp, dpage_count, PAGE_SIZE,\n\t\t\t&dqpt_mem[i], &dsqpt_mem[i], &dpage_mem[i]);\n\n\t\tif (rx->rcb_setup_cbfn)\n\t\t\trx->rcb_setup_cbfn(bnad, q0->rcb);\n\n\t\t \n\n\t\tif (q1) {\n\t\t\tq1->rx = rx;\n\t\t\tq1->rxp = rxp;\n\n\t\t\tq1->rcb = (struct bna_rcb *) rcb_mem[rcb_idx].kva;\n\t\t\tq1->rcb->unmap_q = (void *)hqunmap_mem[hq_idx].kva;\n\t\t\trcb_idx++; hq_idx++;\n\t\t\tq1->rcb->q_depth = rx_cfg->q1_depth;\n\t\t\tq1->q_depth = rx_cfg->q1_depth;\n\t\t\tq1->multi_buffer = BNA_STATUS_T_DISABLED;\n\t\t\tq1->num_vecs = 1;\n\t\t\tq1->rcb->rxq = q1;\n\t\t\tq1->rcb->bnad = bna->bnad;\n\t\t\tq1->rcb->id = 1;\n\t\t\tq1->buffer_size = (rx_cfg->rxp_type == BNA_RXP_HDS) ?\n\t\t\t\t\trx_cfg->hds_config.forced_offset\n\t\t\t\t\t: rx_cfg->q1_buf_size;\n\t\t\tq1->rx_packets = q1->rx_bytes = 0;\n\t\t\tq1->rx_packets_with_error = q1->rxbuf_alloc_failed = 0;\n\t\t\tq1->rxbuf_map_failed = 0;\n\n\t\t\tbna_rxq_qpt_setup(q1, rxp, hpage_count, PAGE_SIZE,\n\t\t\t\t&hqpt_mem[i], &hsqpt_mem[i],\n\t\t\t\t&hpage_mem[i]);\n\n\t\t\tif (rx->rcb_setup_cbfn)\n\t\t\t\trx->rcb_setup_cbfn(bnad, q1->rcb);\n\t\t}\n\n\t\t \n\n\t\trxp->cq.ccb = (struct bna_ccb *) ccb_mem[i].kva;\n\t\tcq_depth = rx_cfg->q0_depth +\n\t\t\t((rx_cfg->rxp_type == BNA_RXP_SINGLE) ?\n\t\t\t 0 : rx_cfg->q1_depth);\n\t\t \n\t\tcq_depth = roundup_pow_of_two(cq_depth);\n\t\trxp->cq.ccb->q_depth = cq_depth;\n\t\trxp->cq.ccb->cq = &rxp->cq;\n\t\trxp->cq.ccb->rcb[0] = q0->rcb;\n\t\tq0->rcb->ccb = rxp->cq.ccb;\n\t\tif (q1) {\n\t\t\trxp->cq.ccb->rcb[1] = q1->rcb;\n\t\t\tq1->rcb->ccb = rxp->cq.ccb;\n\t\t}\n\t\trxp->cq.ccb->hw_producer_index =\n\t\t\t(u32 *)rxp->cq.ib.ib_seg_host_addr_kva;\n\t\trxp->cq.ccb->i_dbell = &rxp->cq.ib.door_bell;\n\t\trxp->cq.ccb->intr_type = rxp->cq.ib.intr_type;\n\t\trxp->cq.ccb->intr_vector = rxp->cq.ib.intr_vector;\n\t\trxp->cq.ccb->rx_coalescing_timeo =\n\t\t\trxp->cq.ib.coalescing_timeo;\n\t\trxp->cq.ccb->pkt_rate.small_pkt_cnt = 0;\n\t\trxp->cq.ccb->pkt_rate.large_pkt_cnt = 0;\n\t\trxp->cq.ccb->bnad = bna->bnad;\n\t\trxp->cq.ccb->id = i;\n\n\t\tbna_rxp_cqpt_setup(rxp, page_count, PAGE_SIZE,\n\t\t\t&cqpt_mem[i], &cswqpt_mem[i], &cpage_mem[i]);\n\n\t\tif (rx->ccb_setup_cbfn)\n\t\t\trx->ccb_setup_cbfn(bnad, rxp->cq.ccb);\n\t}\n\n\trx->hds_cfg = rx_cfg->hds_config;\n\n\tbna_rxf_init(&rx->rxf, rx, rx_cfg, res_info);\n\n\tbfa_fsm_set_state(rx, bna_rx_sm_stopped);\n\n\trx_mod->rid_mask |= BIT(rx->rid);\n\n\treturn rx;\n}\n\nvoid\nbna_rx_destroy(struct bna_rx *rx)\n{\n\tstruct bna_rx_mod *rx_mod = &rx->bna->rx_mod;\n\tstruct bna_rxq *q0 = NULL;\n\tstruct bna_rxq *q1 = NULL;\n\tstruct bna_rxp *rxp;\n\tstruct list_head *qe;\n\n\tbna_rxf_uninit(&rx->rxf);\n\n\twhile (!list_empty(&rx->rxp_q)) {\n\t\trxp = list_first_entry(&rx->rxp_q, struct bna_rxp, qe);\n\t\tlist_del(&rxp->qe);\n\t\tGET_RXQS(rxp, q0, q1);\n\t\tif (rx->rcb_destroy_cbfn)\n\t\t\trx->rcb_destroy_cbfn(rx->bna->bnad, q0->rcb);\n\t\tq0->rcb = NULL;\n\t\tq0->rxp = NULL;\n\t\tq0->rx = NULL;\n\t\tbna_rxq_put(rx_mod, q0);\n\n\t\tif (q1) {\n\t\t\tif (rx->rcb_destroy_cbfn)\n\t\t\t\trx->rcb_destroy_cbfn(rx->bna->bnad, q1->rcb);\n\t\t\tq1->rcb = NULL;\n\t\t\tq1->rxp = NULL;\n\t\t\tq1->rx = NULL;\n\t\t\tbna_rxq_put(rx_mod, q1);\n\t\t}\n\t\trxp->rxq.slr.large = NULL;\n\t\trxp->rxq.slr.small = NULL;\n\n\t\tif (rx->ccb_destroy_cbfn)\n\t\t\trx->ccb_destroy_cbfn(rx->bna->bnad, rxp->cq.ccb);\n\t\trxp->cq.ccb = NULL;\n\t\trxp->rx = NULL;\n\t\tbna_rxp_put(rx_mod, rxp);\n\t}\n\n\tlist_for_each(qe, &rx_mod->rx_active_q)\n\t\tif (qe == &rx->qe) {\n\t\t\tlist_del(&rx->qe);\n\t\t\tbreak;\n\t\t}\n\n\trx_mod->rid_mask &= ~BIT(rx->rid);\n\n\trx->bna = NULL;\n\trx->priv = NULL;\n\tbna_rx_put(rx_mod, rx);\n}\n\nvoid\nbna_rx_enable(struct bna_rx *rx)\n{\n\tif (rx->fsm != bna_rx_sm_stopped)\n\t\treturn;\n\n\trx->rx_flags |= BNA_RX_F_ENABLED;\n\tif (rx->rx_flags & BNA_RX_F_ENET_STARTED)\n\t\tbfa_fsm_send_event(rx, RX_E_START);\n}\n\nvoid\nbna_rx_disable(struct bna_rx *rx, enum bna_cleanup_type type,\n\t\tvoid (*cbfn)(void *, struct bna_rx *))\n{\n\tif (type == BNA_SOFT_CLEANUP) {\n\t\t \n\t\t(*cbfn)(rx->bna->bnad, rx);\n\t} else {\n\t\trx->stop_cbfn = cbfn;\n\t\trx->stop_cbarg = rx->bna->bnad;\n\n\t\trx->rx_flags &= ~BNA_RX_F_ENABLED;\n\n\t\tbfa_fsm_send_event(rx, RX_E_STOP);\n\t}\n}\n\nvoid\nbna_rx_cleanup_complete(struct bna_rx *rx)\n{\n\tbfa_fsm_send_event(rx, RX_E_CLEANUP_DONE);\n}\n\nvoid\nbna_rx_vlan_strip_enable(struct bna_rx *rx)\n{\n\tstruct bna_rxf *rxf = &rx->rxf;\n\n\tif (rxf->vlan_strip_status == BNA_STATUS_T_DISABLED) {\n\t\trxf->vlan_strip_status = BNA_STATUS_T_ENABLED;\n\t\trxf->vlan_strip_pending = true;\n\t\tbfa_fsm_send_event(rxf, RXF_E_CONFIG);\n\t}\n}\n\nvoid\nbna_rx_vlan_strip_disable(struct bna_rx *rx)\n{\n\tstruct bna_rxf *rxf = &rx->rxf;\n\n\tif (rxf->vlan_strip_status != BNA_STATUS_T_DISABLED) {\n\t\trxf->vlan_strip_status = BNA_STATUS_T_DISABLED;\n\t\trxf->vlan_strip_pending = true;\n\t\tbfa_fsm_send_event(rxf, RXF_E_CONFIG);\n\t}\n}\n\nenum bna_cb_status\nbna_rx_mode_set(struct bna_rx *rx, enum bna_rxmode new_mode,\n\t\tenum bna_rxmode bitmask)\n{\n\tstruct bna_rxf *rxf = &rx->rxf;\n\tint need_hw_config = 0;\n\n\t \n\n\tif (is_promisc_enable(new_mode, bitmask)) {\n\t\t \n\t\tif ((rx->bna->promisc_rid != BFI_INVALID_RID) &&\n\t\t\t(rx->bna->promisc_rid != rxf->rx->rid))\n\t\t\tgoto err_return;\n\n\t\t \n\t\tif (rx->bna->default_mode_rid != BFI_INVALID_RID)\n\t\t\tgoto err_return;\n\n\t\t \n\t\tif (is_default_enable(new_mode, bitmask))\n\t\t\tgoto err_return;\n\t}\n\n\tif (is_default_enable(new_mode, bitmask)) {\n\t\t \n\t\tif ((rx->bna->default_mode_rid != BFI_INVALID_RID) &&\n\t\t\t(rx->bna->default_mode_rid != rxf->rx->rid)) {\n\t\t\t\tgoto err_return;\n\t\t}\n\n\t\t \n\t\tif (rx->bna->promisc_rid != BFI_INVALID_RID)\n\t\t\tgoto err_return;\n\t}\n\n\t \n\n\tif (is_promisc_enable(new_mode, bitmask)) {\n\t\tif (bna_rxf_promisc_enable(rxf))\n\t\t\tneed_hw_config = 1;\n\t} else if (is_promisc_disable(new_mode, bitmask)) {\n\t\tif (bna_rxf_promisc_disable(rxf))\n\t\t\tneed_hw_config = 1;\n\t}\n\n\tif (is_allmulti_enable(new_mode, bitmask)) {\n\t\tif (bna_rxf_allmulti_enable(rxf))\n\t\t\tneed_hw_config = 1;\n\t} else if (is_allmulti_disable(new_mode, bitmask)) {\n\t\tif (bna_rxf_allmulti_disable(rxf))\n\t\t\tneed_hw_config = 1;\n\t}\n\n\t \n\n\tif (need_hw_config) {\n\t\trxf->cam_fltr_cbfn = NULL;\n\t\trxf->cam_fltr_cbarg = rx->bna->bnad;\n\t\tbfa_fsm_send_event(rxf, RXF_E_CONFIG);\n\t}\n\n\treturn BNA_CB_SUCCESS;\n\nerr_return:\n\treturn BNA_CB_FAIL;\n}\n\nvoid\nbna_rx_vlanfilter_enable(struct bna_rx *rx)\n{\n\tstruct bna_rxf *rxf = &rx->rxf;\n\n\tif (rxf->vlan_filter_status == BNA_STATUS_T_DISABLED) {\n\t\trxf->vlan_filter_status = BNA_STATUS_T_ENABLED;\n\t\trxf->vlan_pending_bitmask = (u8)BFI_VLAN_BMASK_ALL;\n\t\tbfa_fsm_send_event(rxf, RXF_E_CONFIG);\n\t}\n}\n\nvoid\nbna_rx_coalescing_timeo_set(struct bna_rx *rx, int coalescing_timeo)\n{\n\tstruct bna_rxp *rxp;\n\n\tlist_for_each_entry(rxp, &rx->rxp_q, qe) {\n\t\trxp->cq.ccb->rx_coalescing_timeo = coalescing_timeo;\n\t\tbna_ib_coalescing_timeo_set(&rxp->cq.ib, coalescing_timeo);\n\t}\n}\n\nvoid\nbna_rx_dim_reconfig(struct bna *bna, const u32 vector[][BNA_BIAS_T_MAX])\n{\n\tint i, j;\n\n\tfor (i = 0; i < BNA_LOAD_T_MAX; i++)\n\t\tfor (j = 0; j < BNA_BIAS_T_MAX; j++)\n\t\t\tbna->rx_mod.dim_vector[i][j] = vector[i][j];\n}\n\nvoid\nbna_rx_dim_update(struct bna_ccb *ccb)\n{\n\tstruct bna *bna = ccb->cq->rx->bna;\n\tu32 load, bias;\n\tu32 pkt_rt, small_rt, large_rt;\n\tu8 coalescing_timeo;\n\n\tif ((ccb->pkt_rate.small_pkt_cnt == 0) &&\n\t\t(ccb->pkt_rate.large_pkt_cnt == 0))\n\t\treturn;\n\n\t \n\n\tsmall_rt = ccb->pkt_rate.small_pkt_cnt;\n\tlarge_rt = ccb->pkt_rate.large_pkt_cnt;\n\n\tpkt_rt = small_rt + large_rt;\n\n\tif (pkt_rt < BNA_PKT_RATE_10K)\n\t\tload = BNA_LOAD_T_LOW_4;\n\telse if (pkt_rt < BNA_PKT_RATE_20K)\n\t\tload = BNA_LOAD_T_LOW_3;\n\telse if (pkt_rt < BNA_PKT_RATE_30K)\n\t\tload = BNA_LOAD_T_LOW_2;\n\telse if (pkt_rt < BNA_PKT_RATE_40K)\n\t\tload = BNA_LOAD_T_LOW_1;\n\telse if (pkt_rt < BNA_PKT_RATE_50K)\n\t\tload = BNA_LOAD_T_HIGH_1;\n\telse if (pkt_rt < BNA_PKT_RATE_60K)\n\t\tload = BNA_LOAD_T_HIGH_2;\n\telse if (pkt_rt < BNA_PKT_RATE_80K)\n\t\tload = BNA_LOAD_T_HIGH_3;\n\telse\n\t\tload = BNA_LOAD_T_HIGH_4;\n\n\tif (small_rt > (large_rt << 1))\n\t\tbias = 0;\n\telse\n\t\tbias = 1;\n\n\tccb->pkt_rate.small_pkt_cnt = 0;\n\tccb->pkt_rate.large_pkt_cnt = 0;\n\n\tcoalescing_timeo = bna->rx_mod.dim_vector[load][bias];\n\tccb->rx_coalescing_timeo = coalescing_timeo;\n\n\t \n\tbna_ib_coalescing_timeo_set(&ccb->cq->ib, coalescing_timeo);\n}\n\nconst u32 bna_napi_dim_vector[BNA_LOAD_T_MAX][BNA_BIAS_T_MAX] = {\n\t{12, 12},\n\t{6, 10},\n\t{5, 10},\n\t{4, 8},\n\t{3, 6},\n\t{3, 6},\n\t{2, 4},\n\t{1, 2},\n};\n\n \n\n#define call_tx_stop_cbfn(tx)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif ((tx)->stop_cbfn) {\t\t\t\t\t\t\\\n\t\tvoid (*cbfn)(void *, struct bna_tx *);\t\t\\\n\t\tvoid *cbarg;\t\t\t\t\t\t\\\n\t\tcbfn = (tx)->stop_cbfn;\t\t\t\t\t\\\n\t\tcbarg = (tx)->stop_cbarg;\t\t\t\t\\\n\t\t(tx)->stop_cbfn = NULL;\t\t\t\t\t\\\n\t\t(tx)->stop_cbarg = NULL;\t\t\t\t\\\n\t\tcbfn(cbarg, (tx));\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\nstatic void bna_tx_mod_cb_tx_stopped(void *tx_mod, struct bna_tx *tx);\nstatic void bna_bfi_tx_enet_start(struct bna_tx *tx);\nstatic void bna_tx_enet_stop(struct bna_tx *tx);\n\nenum bna_tx_event {\n\tTX_E_START\t\t\t= 1,\n\tTX_E_STOP\t\t\t= 2,\n\tTX_E_FAIL\t\t\t= 3,\n\tTX_E_STARTED\t\t\t= 4,\n\tTX_E_STOPPED\t\t\t= 5,\n\tTX_E_CLEANUP_DONE\t\t= 7,\n\tTX_E_BW_UPDATE\t\t\t= 8,\n};\n\nbfa_fsm_state_decl(bna_tx, stopped, struct bna_tx, enum bna_tx_event);\nbfa_fsm_state_decl(bna_tx, start_wait, struct bna_tx, enum bna_tx_event);\nbfa_fsm_state_decl(bna_tx, started, struct bna_tx, enum bna_tx_event);\nbfa_fsm_state_decl(bna_tx, stop_wait, struct bna_tx, enum bna_tx_event);\nbfa_fsm_state_decl(bna_tx, cleanup_wait, struct bna_tx,\n\t\t\tenum bna_tx_event);\nbfa_fsm_state_decl(bna_tx, prio_stop_wait, struct bna_tx,\n\t\t\tenum bna_tx_event);\nbfa_fsm_state_decl(bna_tx, prio_cleanup_wait, struct bna_tx,\n\t\t\tenum bna_tx_event);\nbfa_fsm_state_decl(bna_tx, failed, struct bna_tx, enum bna_tx_event);\nbfa_fsm_state_decl(bna_tx, quiesce_wait, struct bna_tx,\n\t\t\tenum bna_tx_event);\n\nstatic void\nbna_tx_sm_stopped_entry(struct bna_tx *tx)\n{\n\tcall_tx_stop_cbfn(tx);\n}\n\nstatic void\nbna_tx_sm_stopped(struct bna_tx *tx, enum bna_tx_event event)\n{\n\tswitch (event) {\n\tcase TX_E_START:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_start_wait);\n\t\tbreak;\n\n\tcase TX_E_STOP:\n\t\tcall_tx_stop_cbfn(tx);\n\t\tbreak;\n\n\tcase TX_E_FAIL:\n\t\t \n\t\tbreak;\n\n\tcase TX_E_BW_UPDATE:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbna_tx_sm_start_wait_entry(struct bna_tx *tx)\n{\n\tbna_bfi_tx_enet_start(tx);\n}\n\nstatic void\nbna_tx_sm_start_wait(struct bna_tx *tx, enum bna_tx_event event)\n{\n\tswitch (event) {\n\tcase TX_E_STOP:\n\t\ttx->flags &= ~BNA_TX_F_BW_UPDATED;\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_stop_wait);\n\t\tbreak;\n\n\tcase TX_E_FAIL:\n\t\ttx->flags &= ~BNA_TX_F_BW_UPDATED;\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_stopped);\n\t\tbreak;\n\n\tcase TX_E_STARTED:\n\t\tif (tx->flags & BNA_TX_F_BW_UPDATED) {\n\t\t\ttx->flags &= ~BNA_TX_F_BW_UPDATED;\n\t\t\tbfa_fsm_set_state(tx, bna_tx_sm_prio_stop_wait);\n\t\t} else\n\t\t\tbfa_fsm_set_state(tx, bna_tx_sm_started);\n\t\tbreak;\n\n\tcase TX_E_BW_UPDATE:\n\t\ttx->flags |= BNA_TX_F_BW_UPDATED;\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbna_tx_sm_started_entry(struct bna_tx *tx)\n{\n\tstruct bna_txq *txq;\n\tint is_regular = (tx->type == BNA_TX_T_REGULAR);\n\n\tlist_for_each_entry(txq, &tx->txq_q, qe) {\n\t\ttxq->tcb->priority = txq->priority;\n\t\t \n\t\tbna_ib_start(tx->bna, &txq->ib, is_regular);\n\t}\n\ttx->tx_resume_cbfn(tx->bna->bnad, tx);\n}\n\nstatic void\nbna_tx_sm_started(struct bna_tx *tx, enum bna_tx_event event)\n{\n\tswitch (event) {\n\tcase TX_E_STOP:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_stop_wait);\n\t\ttx->tx_stall_cbfn(tx->bna->bnad, tx);\n\t\tbna_tx_enet_stop(tx);\n\t\tbreak;\n\n\tcase TX_E_FAIL:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_failed);\n\t\ttx->tx_stall_cbfn(tx->bna->bnad, tx);\n\t\ttx->tx_cleanup_cbfn(tx->bna->bnad, tx);\n\t\tbreak;\n\n\tcase TX_E_BW_UPDATE:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_prio_stop_wait);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbna_tx_sm_stop_wait_entry(struct bna_tx *tx)\n{\n}\n\nstatic void\nbna_tx_sm_stop_wait(struct bna_tx *tx, enum bna_tx_event event)\n{\n\tswitch (event) {\n\tcase TX_E_FAIL:\n\tcase TX_E_STOPPED:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_cleanup_wait);\n\t\ttx->tx_cleanup_cbfn(tx->bna->bnad, tx);\n\t\tbreak;\n\n\tcase TX_E_STARTED:\n\t\t \n\t\tbna_tx_enet_stop(tx);\n\t\tbreak;\n\n\tcase TX_E_BW_UPDATE:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbna_tx_sm_cleanup_wait_entry(struct bna_tx *tx)\n{\n}\n\nstatic void\nbna_tx_sm_cleanup_wait(struct bna_tx *tx, enum bna_tx_event event)\n{\n\tswitch (event) {\n\tcase TX_E_FAIL:\n\tcase TX_E_BW_UPDATE:\n\t\t \n\t\tbreak;\n\n\tcase TX_E_CLEANUP_DONE:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_stopped);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbna_tx_sm_prio_stop_wait_entry(struct bna_tx *tx)\n{\n\ttx->tx_stall_cbfn(tx->bna->bnad, tx);\n\tbna_tx_enet_stop(tx);\n}\n\nstatic void\nbna_tx_sm_prio_stop_wait(struct bna_tx *tx, enum bna_tx_event event)\n{\n\tswitch (event) {\n\tcase TX_E_STOP:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_stop_wait);\n\t\tbreak;\n\n\tcase TX_E_FAIL:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_failed);\n\t\ttx->tx_cleanup_cbfn(tx->bna->bnad, tx);\n\t\tbreak;\n\n\tcase TX_E_STOPPED:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_prio_cleanup_wait);\n\t\tbreak;\n\n\tcase TX_E_BW_UPDATE:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbna_tx_sm_prio_cleanup_wait_entry(struct bna_tx *tx)\n{\n\ttx->tx_cleanup_cbfn(tx->bna->bnad, tx);\n}\n\nstatic void\nbna_tx_sm_prio_cleanup_wait(struct bna_tx *tx, enum bna_tx_event event)\n{\n\tswitch (event) {\n\tcase TX_E_STOP:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_cleanup_wait);\n\t\tbreak;\n\n\tcase TX_E_FAIL:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_failed);\n\t\tbreak;\n\n\tcase TX_E_BW_UPDATE:\n\t\t \n\t\tbreak;\n\n\tcase TX_E_CLEANUP_DONE:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_start_wait);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbna_tx_sm_failed_entry(struct bna_tx *tx)\n{\n}\n\nstatic void\nbna_tx_sm_failed(struct bna_tx *tx, enum bna_tx_event event)\n{\n\tswitch (event) {\n\tcase TX_E_START:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_quiesce_wait);\n\t\tbreak;\n\n\tcase TX_E_STOP:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_cleanup_wait);\n\t\tbreak;\n\n\tcase TX_E_FAIL:\n\t\t \n\t\tbreak;\n\n\tcase TX_E_CLEANUP_DONE:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_stopped);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbna_tx_sm_quiesce_wait_entry(struct bna_tx *tx)\n{\n}\n\nstatic void\nbna_tx_sm_quiesce_wait(struct bna_tx *tx, enum bna_tx_event event)\n{\n\tswitch (event) {\n\tcase TX_E_STOP:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_cleanup_wait);\n\t\tbreak;\n\n\tcase TX_E_FAIL:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_failed);\n\t\tbreak;\n\n\tcase TX_E_CLEANUP_DONE:\n\t\tbfa_fsm_set_state(tx, bna_tx_sm_start_wait);\n\t\tbreak;\n\n\tcase TX_E_BW_UPDATE:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbna_bfi_tx_enet_start(struct bna_tx *tx)\n{\n\tstruct bfi_enet_tx_cfg_req *cfg_req = &tx->bfi_enet_cmd.cfg_req;\n\tstruct bna_txq *txq = NULL;\n\tint i;\n\n\tbfi_msgq_mhdr_set(cfg_req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_TX_CFG_SET_REQ, 0, tx->rid);\n\tcfg_req->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_tx_cfg_req)));\n\n\tcfg_req->num_queues = tx->num_txq;\n\tfor (i = 0; i < tx->num_txq; i++) {\n\t\ttxq = txq ? list_next_entry(txq, qe)\n\t\t\t: list_first_entry(&tx->txq_q, struct bna_txq, qe);\n\t\tbfi_enet_datapath_q_init(&cfg_req->q_cfg[i].q.q, &txq->qpt);\n\t\tcfg_req->q_cfg[i].q.priority = txq->priority;\n\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_lo =\n\t\t\ttxq->ib.ib_seg_host_addr.lsb;\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_hi =\n\t\t\ttxq->ib.ib_seg_host_addr.msb;\n\t\tcfg_req->q_cfg[i].ib.intr.msix_index =\n\t\t\thtons((u16)txq->ib.intr_vector);\n\t}\n\n\tcfg_req->ib_cfg.int_pkt_dma = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.int_enabled = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.int_pkt_enabled = BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.continuous_coalescing = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.msix = (txq->ib.intr_type == BNA_INTR_T_MSIX)\n\t\t\t\t? BNA_STATUS_T_ENABLED : BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.coalescing_timeout =\n\t\t\thtonl((u32)txq->ib.coalescing_timeo);\n\tcfg_req->ib_cfg.inter_pkt_timeout =\n\t\t\thtonl((u32)txq->ib.interpkt_timeo);\n\tcfg_req->ib_cfg.inter_pkt_count = (u8)txq->ib.interpkt_count;\n\n\tcfg_req->tx_cfg.vlan_mode = BFI_ENET_TX_VLAN_WI;\n\tcfg_req->tx_cfg.vlan_id = htons((u16)tx->txf_vlan_id);\n\tcfg_req->tx_cfg.admit_tagged_frame = BNA_STATUS_T_ENABLED;\n\tcfg_req->tx_cfg.apply_vlan_filter = BNA_STATUS_T_DISABLED;\n\n\tbfa_msgq_cmd_set(&tx->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_tx_cfg_req), &cfg_req->mh);\n\tbfa_msgq_cmd_post(&tx->bna->msgq, &tx->msgq_cmd);\n}\n\nstatic void\nbna_bfi_tx_enet_stop(struct bna_tx *tx)\n{\n\tstruct bfi_enet_req *req = &tx->bfi_enet_cmd.req;\n\n\tbfi_msgq_mhdr_set(req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_TX_CFG_CLR_REQ, 0, tx->rid);\n\treq->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_req)));\n\tbfa_msgq_cmd_set(&tx->msgq_cmd, NULL, NULL, sizeof(struct bfi_enet_req),\n\t\t&req->mh);\n\tbfa_msgq_cmd_post(&tx->bna->msgq, &tx->msgq_cmd);\n}\n\nstatic void\nbna_tx_enet_stop(struct bna_tx *tx)\n{\n\tstruct bna_txq *txq;\n\n\t \n\tlist_for_each_entry(txq, &tx->txq_q, qe)\n\t\tbna_ib_stop(tx->bna, &txq->ib);\n\n\tbna_bfi_tx_enet_stop(tx);\n}\n\nstatic void\nbna_txq_qpt_setup(struct bna_txq *txq, int page_count, int page_size,\n\t\tstruct bna_mem_descr *qpt_mem,\n\t\tstruct bna_mem_descr *swqpt_mem,\n\t\tstruct bna_mem_descr *page_mem)\n{\n\tu8 *kva;\n\tu64 dma;\n\tstruct bna_dma_addr bna_dma;\n\tint i;\n\n\ttxq->qpt.hw_qpt_ptr.lsb = qpt_mem->dma.lsb;\n\ttxq->qpt.hw_qpt_ptr.msb = qpt_mem->dma.msb;\n\ttxq->qpt.kv_qpt_ptr = qpt_mem->kva;\n\ttxq->qpt.page_count = page_count;\n\ttxq->qpt.page_size = page_size;\n\n\ttxq->tcb->sw_qpt = (void **) swqpt_mem->kva;\n\ttxq->tcb->sw_q = page_mem->kva;\n\n\tkva = page_mem->kva;\n\tBNA_GET_DMA_ADDR(&page_mem->dma, dma);\n\n\tfor (i = 0; i < page_count; i++) {\n\t\ttxq->tcb->sw_qpt[i] = kva;\n\t\tkva += PAGE_SIZE;\n\n\t\tBNA_SET_DMA_ADDR(dma, &bna_dma);\n\t\t((struct bna_dma_addr *)txq->qpt.kv_qpt_ptr)[i].lsb =\n\t\t\tbna_dma.lsb;\n\t\t((struct bna_dma_addr *)txq->qpt.kv_qpt_ptr)[i].msb =\n\t\t\tbna_dma.msb;\n\t\tdma += PAGE_SIZE;\n\t}\n}\n\nstatic struct bna_tx *\nbna_tx_get(struct bna_tx_mod *tx_mod, enum bna_tx_type type)\n{\n\tstruct bna_tx *tx = NULL;\n\n\tif (list_empty(&tx_mod->tx_free_q))\n\t\treturn NULL;\n\tif (type == BNA_TX_T_REGULAR)\n\t\ttx = list_first_entry(&tx_mod->tx_free_q, struct bna_tx, qe);\n\telse\n\t\ttx = list_last_entry(&tx_mod->tx_free_q, struct bna_tx, qe);\n\tlist_del(&tx->qe);\n\ttx->type = type;\n\n\treturn tx;\n}\n\nstatic void\nbna_tx_free(struct bna_tx *tx)\n{\n\tstruct bna_tx_mod *tx_mod = &tx->bna->tx_mod;\n\tstruct bna_txq *txq;\n\tstruct list_head *qe;\n\n\twhile (!list_empty(&tx->txq_q)) {\n\t\ttxq = list_first_entry(&tx->txq_q, struct bna_txq, qe);\n\t\ttxq->tcb = NULL;\n\t\ttxq->tx = NULL;\n\t\tlist_move_tail(&txq->qe, &tx_mod->txq_free_q);\n\t}\n\n\tlist_for_each(qe, &tx_mod->tx_active_q) {\n\t\tif (qe == &tx->qe) {\n\t\t\tlist_del(&tx->qe);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttx->bna = NULL;\n\ttx->priv = NULL;\n\n\tlist_for_each_prev(qe, &tx_mod->tx_free_q)\n\t\tif (((struct bna_tx *)qe)->rid < tx->rid)\n\t\t\tbreak;\n\n\tlist_add(&tx->qe, qe);\n}\n\nstatic void\nbna_tx_start(struct bna_tx *tx)\n{\n\ttx->flags |= BNA_TX_F_ENET_STARTED;\n\tif (tx->flags & BNA_TX_F_ENABLED)\n\t\tbfa_fsm_send_event(tx, TX_E_START);\n}\n\nstatic void\nbna_tx_stop(struct bna_tx *tx)\n{\n\ttx->stop_cbfn = bna_tx_mod_cb_tx_stopped;\n\ttx->stop_cbarg = &tx->bna->tx_mod;\n\n\ttx->flags &= ~BNA_TX_F_ENET_STARTED;\n\tbfa_fsm_send_event(tx, TX_E_STOP);\n}\n\nstatic void\nbna_tx_fail(struct bna_tx *tx)\n{\n\ttx->flags &= ~BNA_TX_F_ENET_STARTED;\n\tbfa_fsm_send_event(tx, TX_E_FAIL);\n}\n\nvoid\nbna_bfi_tx_enet_start_rsp(struct bna_tx *tx, struct bfi_msgq_mhdr *msghdr)\n{\n\tstruct bfi_enet_tx_cfg_rsp *cfg_rsp = &tx->bfi_enet_cmd.cfg_rsp;\n\tstruct bna_txq *txq = NULL;\n\tint i;\n\n\tbfa_msgq_rsp_copy(&tx->bna->msgq, (u8 *)cfg_rsp,\n\t\tsizeof(struct bfi_enet_tx_cfg_rsp));\n\n\ttx->hw_id = cfg_rsp->hw_id;\n\n\tfor (i = 0, txq = list_first_entry(&tx->txq_q, struct bna_txq, qe);\n\t     i < tx->num_txq; i++, txq = list_next_entry(txq, qe)) {\n\t\t \n\t\ttxq->tcb->i_dbell->doorbell_addr =\n\t\t\ttx->bna->pcidev.pci_bar_kva\n\t\t\t+ ntohl(cfg_rsp->q_handles[i].i_dbell);\n\t\ttxq->tcb->q_dbell =\n\t\t\ttx->bna->pcidev.pci_bar_kva\n\t\t\t+ ntohl(cfg_rsp->q_handles[i].q_dbell);\n\t\ttxq->hw_id = cfg_rsp->q_handles[i].hw_qid;\n\n\t\t \n\t\t(*txq->tcb->hw_consumer_index) = 0;\n\t\ttxq->tcb->producer_index = txq->tcb->consumer_index = 0;\n\t}\n\n\tbfa_fsm_send_event(tx, TX_E_STARTED);\n}\n\nvoid\nbna_bfi_tx_enet_stop_rsp(struct bna_tx *tx, struct bfi_msgq_mhdr *msghdr)\n{\n\tbfa_fsm_send_event(tx, TX_E_STOPPED);\n}\n\nvoid\nbna_bfi_bw_update_aen(struct bna_tx_mod *tx_mod)\n{\n\tstruct bna_tx *tx;\n\n\tlist_for_each_entry(tx, &tx_mod->tx_active_q, qe)\n\t\tbfa_fsm_send_event(tx, TX_E_BW_UPDATE);\n}\n\nvoid\nbna_tx_res_req(int num_txq, int txq_depth, struct bna_res_info *res_info)\n{\n\tu32 q_size;\n\tu32 page_count;\n\tstruct bna_mem_info *mem_info;\n\n\tres_info[BNA_TX_RES_MEM_T_TCB].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_TX_RES_MEM_T_TCB].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_KVA;\n\tmem_info->len = sizeof(struct bna_tcb);\n\tmem_info->num = num_txq;\n\n\tq_size = txq_depth * BFI_TXQ_WI_SIZE;\n\tq_size = ALIGN(q_size, PAGE_SIZE);\n\tpage_count = q_size >> PAGE_SHIFT;\n\n\tres_info[BNA_TX_RES_MEM_T_QPT].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_TX_RES_MEM_T_QPT].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_DMA;\n\tmem_info->len = page_count * sizeof(struct bna_dma_addr);\n\tmem_info->num = num_txq;\n\n\tres_info[BNA_TX_RES_MEM_T_SWQPT].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_TX_RES_MEM_T_SWQPT].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_KVA;\n\tmem_info->len = page_count * sizeof(void *);\n\tmem_info->num = num_txq;\n\n\tres_info[BNA_TX_RES_MEM_T_PAGE].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_TX_RES_MEM_T_PAGE].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_DMA;\n\tmem_info->len = PAGE_SIZE * page_count;\n\tmem_info->num = num_txq;\n\n\tres_info[BNA_TX_RES_MEM_T_IBIDX].res_type = BNA_RES_T_MEM;\n\tmem_info = &res_info[BNA_TX_RES_MEM_T_IBIDX].res_u.mem_info;\n\tmem_info->mem_type = BNA_MEM_T_DMA;\n\tmem_info->len = BFI_IBIDX_SIZE;\n\tmem_info->num = num_txq;\n\n\tres_info[BNA_TX_RES_INTR_T_TXCMPL].res_type = BNA_RES_T_INTR;\n\tres_info[BNA_TX_RES_INTR_T_TXCMPL].res_u.intr_info.intr_type =\n\t\t\tBNA_INTR_T_MSIX;\n\tres_info[BNA_TX_RES_INTR_T_TXCMPL].res_u.intr_info.num = num_txq;\n}\n\nstruct bna_tx *\nbna_tx_create(struct bna *bna, struct bnad *bnad,\n\t\tstruct bna_tx_config *tx_cfg,\n\t\tconst struct bna_tx_event_cbfn *tx_cbfn,\n\t\tstruct bna_res_info *res_info, void *priv)\n{\n\tstruct bna_intr_info *intr_info;\n\tstruct bna_tx_mod *tx_mod = &bna->tx_mod;\n\tstruct bna_tx *tx;\n\tstruct bna_txq *txq;\n\tint page_count;\n\tint i;\n\n\tintr_info = &res_info[BNA_TX_RES_INTR_T_TXCMPL].res_u.intr_info;\n\tpage_count = (res_info[BNA_TX_RES_MEM_T_PAGE].res_u.mem_info.len) /\n\t\t\t\t\tPAGE_SIZE;\n\n\t \n\n\tif ((intr_info->num != 1) && (intr_info->num != tx_cfg->num_txq))\n\t\treturn NULL;\n\n\t \n\n\ttx = bna_tx_get(tx_mod, tx_cfg->tx_type);\n\tif (!tx)\n\t\treturn NULL;\n\ttx->bna = bna;\n\ttx->priv = priv;\n\n\t \n\n\tINIT_LIST_HEAD(&tx->txq_q);\n\tfor (i = 0; i < tx_cfg->num_txq; i++) {\n\t\tif (list_empty(&tx_mod->txq_free_q))\n\t\t\tgoto err_return;\n\n\t\ttxq = list_first_entry(&tx_mod->txq_free_q, struct bna_txq, qe);\n\t\tlist_move_tail(&txq->qe, &tx->txq_q);\n\t\ttxq->tx = tx;\n\t}\n\n\t \n\n\t \n\n\ttx->tcb_setup_cbfn = tx_cbfn->tcb_setup_cbfn;\n\ttx->tcb_destroy_cbfn = tx_cbfn->tcb_destroy_cbfn;\n\t \n\ttx->tx_stall_cbfn = tx_cbfn->tx_stall_cbfn;\n\ttx->tx_resume_cbfn = tx_cbfn->tx_resume_cbfn;\n\ttx->tx_cleanup_cbfn = tx_cbfn->tx_cleanup_cbfn;\n\n\tlist_add_tail(&tx->qe, &tx_mod->tx_active_q);\n\n\ttx->num_txq = tx_cfg->num_txq;\n\n\ttx->flags = 0;\n\tif (tx->bna->tx_mod.flags & BNA_TX_MOD_F_ENET_STARTED) {\n\t\tswitch (tx->type) {\n\t\tcase BNA_TX_T_REGULAR:\n\t\t\tif (!(tx->bna->tx_mod.flags &\n\t\t\t\tBNA_TX_MOD_F_ENET_LOOPBACK))\n\t\t\t\ttx->flags |= BNA_TX_F_ENET_STARTED;\n\t\t\tbreak;\n\t\tcase BNA_TX_T_LOOPBACK:\n\t\t\tif (tx->bna->tx_mod.flags & BNA_TX_MOD_F_ENET_LOOPBACK)\n\t\t\t\ttx->flags |= BNA_TX_F_ENET_STARTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\n\ti = 0;\n\tlist_for_each_entry(txq, &tx->txq_q, qe) {\n\t\ttxq->tcb = (struct bna_tcb *)\n\t\tres_info[BNA_TX_RES_MEM_T_TCB].res_u.mem_info.mdl[i].kva;\n\t\ttxq->tx_packets = 0;\n\t\ttxq->tx_bytes = 0;\n\n\t\t \n\t\ttxq->ib.ib_seg_host_addr.lsb =\n\t\tres_info[BNA_TX_RES_MEM_T_IBIDX].res_u.mem_info.mdl[i].dma.lsb;\n\t\ttxq->ib.ib_seg_host_addr.msb =\n\t\tres_info[BNA_TX_RES_MEM_T_IBIDX].res_u.mem_info.mdl[i].dma.msb;\n\t\ttxq->ib.ib_seg_host_addr_kva =\n\t\tres_info[BNA_TX_RES_MEM_T_IBIDX].res_u.mem_info.mdl[i].kva;\n\t\ttxq->ib.intr_type = intr_info->intr_type;\n\t\ttxq->ib.intr_vector = (intr_info->num == 1) ?\n\t\t\t\t\tintr_info->idl[0].vector :\n\t\t\t\t\tintr_info->idl[i].vector;\n\t\tif (intr_info->intr_type == BNA_INTR_T_INTX)\n\t\t\ttxq->ib.intr_vector = BIT(txq->ib.intr_vector);\n\t\ttxq->ib.coalescing_timeo = tx_cfg->coalescing_timeo;\n\t\ttxq->ib.interpkt_timeo = BFI_TX_INTERPKT_TIMEO;\n\t\ttxq->ib.interpkt_count = BFI_TX_INTERPKT_COUNT;\n\n\t\t \n\n\t\ttxq->tcb->q_depth = tx_cfg->txq_depth;\n\t\ttxq->tcb->unmap_q = (void *)\n\t\tres_info[BNA_TX_RES_MEM_T_UNMAPQ].res_u.mem_info.mdl[i].kva;\n\t\ttxq->tcb->hw_consumer_index =\n\t\t\t(u32 *)txq->ib.ib_seg_host_addr_kva;\n\t\ttxq->tcb->i_dbell = &txq->ib.door_bell;\n\t\ttxq->tcb->intr_type = txq->ib.intr_type;\n\t\ttxq->tcb->intr_vector = txq->ib.intr_vector;\n\t\ttxq->tcb->txq = txq;\n\t\ttxq->tcb->bnad = bnad;\n\t\ttxq->tcb->id = i;\n\n\t\t \n\t\tbna_txq_qpt_setup(txq, page_count, PAGE_SIZE,\n\t\t\t&res_info[BNA_TX_RES_MEM_T_QPT].res_u.mem_info.mdl[i],\n\t\t\t&res_info[BNA_TX_RES_MEM_T_SWQPT].res_u.mem_info.mdl[i],\n\t\t\t&res_info[BNA_TX_RES_MEM_T_PAGE].\n\t\t\t\t  res_u.mem_info.mdl[i]);\n\n\t\t \n\t\tif (tx->tcb_setup_cbfn)\n\t\t\t(tx->tcb_setup_cbfn)(bna->bnad, txq->tcb);\n\n\t\tif (tx_cfg->num_txq == BFI_TX_MAX_PRIO)\n\t\t\ttxq->priority = txq->tcb->id;\n\t\telse\n\t\t\ttxq->priority = tx_mod->default_prio;\n\n\t\ti++;\n\t}\n\n\ttx->txf_vlan_id = 0;\n\n\tbfa_fsm_set_state(tx, bna_tx_sm_stopped);\n\n\ttx_mod->rid_mask |= BIT(tx->rid);\n\n\treturn tx;\n\nerr_return:\n\tbna_tx_free(tx);\n\treturn NULL;\n}\n\nvoid\nbna_tx_destroy(struct bna_tx *tx)\n{\n\tstruct bna_txq *txq;\n\n\tlist_for_each_entry(txq, &tx->txq_q, qe)\n\t\tif (tx->tcb_destroy_cbfn)\n\t\t\t(tx->tcb_destroy_cbfn)(tx->bna->bnad, txq->tcb);\n\n\ttx->bna->tx_mod.rid_mask &= ~BIT(tx->rid);\n\tbna_tx_free(tx);\n}\n\nvoid\nbna_tx_enable(struct bna_tx *tx)\n{\n\tif (tx->fsm != bna_tx_sm_stopped)\n\t\treturn;\n\n\ttx->flags |= BNA_TX_F_ENABLED;\n\n\tif (tx->flags & BNA_TX_F_ENET_STARTED)\n\t\tbfa_fsm_send_event(tx, TX_E_START);\n}\n\nvoid\nbna_tx_disable(struct bna_tx *tx, enum bna_cleanup_type type,\n\t\tvoid (*cbfn)(void *, struct bna_tx *))\n{\n\tif (type == BNA_SOFT_CLEANUP) {\n\t\t(*cbfn)(tx->bna->bnad, tx);\n\t\treturn;\n\t}\n\n\ttx->stop_cbfn = cbfn;\n\ttx->stop_cbarg = tx->bna->bnad;\n\n\ttx->flags &= ~BNA_TX_F_ENABLED;\n\n\tbfa_fsm_send_event(tx, TX_E_STOP);\n}\n\nvoid\nbna_tx_cleanup_complete(struct bna_tx *tx)\n{\n\tbfa_fsm_send_event(tx, TX_E_CLEANUP_DONE);\n}\n\nstatic void\nbna_tx_mod_cb_tx_stopped(void *arg, struct bna_tx *tx)\n{\n\tstruct bna_tx_mod *tx_mod = (struct bna_tx_mod *)arg;\n\n\tbfa_wc_down(&tx_mod->tx_stop_wc);\n}\n\nstatic void\nbna_tx_mod_cb_tx_stopped_all(void *arg)\n{\n\tstruct bna_tx_mod *tx_mod = (struct bna_tx_mod *)arg;\n\n\tif (tx_mod->stop_cbfn)\n\t\ttx_mod->stop_cbfn(&tx_mod->bna->enet);\n\ttx_mod->stop_cbfn = NULL;\n}\n\nvoid\nbna_tx_mod_init(struct bna_tx_mod *tx_mod, struct bna *bna,\n\t\tstruct bna_res_info *res_info)\n{\n\tint i;\n\n\ttx_mod->bna = bna;\n\ttx_mod->flags = 0;\n\n\ttx_mod->tx = (struct bna_tx *)\n\t\tres_info[BNA_MOD_RES_MEM_T_TX_ARRAY].res_u.mem_info.mdl[0].kva;\n\ttx_mod->txq = (struct bna_txq *)\n\t\tres_info[BNA_MOD_RES_MEM_T_TXQ_ARRAY].res_u.mem_info.mdl[0].kva;\n\n\tINIT_LIST_HEAD(&tx_mod->tx_free_q);\n\tINIT_LIST_HEAD(&tx_mod->tx_active_q);\n\n\tINIT_LIST_HEAD(&tx_mod->txq_free_q);\n\n\tfor (i = 0; i < bna->ioceth.attr.num_txq; i++) {\n\t\ttx_mod->tx[i].rid = i;\n\t\tlist_add_tail(&tx_mod->tx[i].qe, &tx_mod->tx_free_q);\n\t\tlist_add_tail(&tx_mod->txq[i].qe, &tx_mod->txq_free_q);\n\t}\n\n\ttx_mod->prio_map = BFI_TX_PRIO_MAP_ALL;\n\ttx_mod->default_prio = 0;\n\ttx_mod->iscsi_over_cee = BNA_STATUS_T_DISABLED;\n\ttx_mod->iscsi_prio = -1;\n}\n\nvoid\nbna_tx_mod_uninit(struct bna_tx_mod *tx_mod)\n{\n\ttx_mod->bna = NULL;\n}\n\nvoid\nbna_tx_mod_start(struct bna_tx_mod *tx_mod, enum bna_tx_type type)\n{\n\tstruct bna_tx *tx;\n\n\ttx_mod->flags |= BNA_TX_MOD_F_ENET_STARTED;\n\tif (type == BNA_TX_T_LOOPBACK)\n\t\ttx_mod->flags |= BNA_TX_MOD_F_ENET_LOOPBACK;\n\n\tlist_for_each_entry(tx, &tx_mod->tx_active_q, qe)\n\t\tif (tx->type == type)\n\t\t\tbna_tx_start(tx);\n}\n\nvoid\nbna_tx_mod_stop(struct bna_tx_mod *tx_mod, enum bna_tx_type type)\n{\n\tstruct bna_tx *tx;\n\n\ttx_mod->flags &= ~BNA_TX_MOD_F_ENET_STARTED;\n\ttx_mod->flags &= ~BNA_TX_MOD_F_ENET_LOOPBACK;\n\n\ttx_mod->stop_cbfn = bna_enet_cb_tx_stopped;\n\n\tbfa_wc_init(&tx_mod->tx_stop_wc, bna_tx_mod_cb_tx_stopped_all, tx_mod);\n\n\tlist_for_each_entry(tx, &tx_mod->tx_active_q, qe)\n\t\tif (tx->type == type) {\n\t\t\tbfa_wc_up(&tx_mod->tx_stop_wc);\n\t\t\tbna_tx_stop(tx);\n\t\t}\n\n\tbfa_wc_wait(&tx_mod->tx_stop_wc);\n}\n\nvoid\nbna_tx_mod_fail(struct bna_tx_mod *tx_mod)\n{\n\tstruct bna_tx *tx;\n\n\ttx_mod->flags &= ~BNA_TX_MOD_F_ENET_STARTED;\n\ttx_mod->flags &= ~BNA_TX_MOD_F_ENET_LOOPBACK;\n\n\tlist_for_each_entry(tx, &tx_mod->tx_active_q, qe)\n\t\tbna_tx_fail(tx);\n}\n\nvoid\nbna_tx_coalescing_timeo_set(struct bna_tx *tx, int coalescing_timeo)\n{\n\tstruct bna_txq *txq;\n\n\tlist_for_each_entry(txq, &tx->txq_q, qe)\n\t\tbna_ib_coalescing_timeo_set(&txq->ib, coalescing_timeo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}