{
  "module_name": "bfa_ioc.c",
  "hash_id": "101c409850772e1fa76cd34f1a4377a6f9f6bddf5e08da750cd643a727fbf39e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/brocade/bna/bfa_ioc.c",
  "human_readable_source": "\n \n \n\n#include \"bfa_ioc.h\"\n#include \"bfi_reg.h\"\n#include \"bfa_defs.h\"\n\n \n\n \n\n#define bfa_ioc_firmware_lock(__ioc)\t\t\t\\\n\t\t\t((__ioc)->ioc_hwif->ioc_firmware_lock(__ioc))\n#define bfa_ioc_firmware_unlock(__ioc)\t\t\t\\\n\t\t\t((__ioc)->ioc_hwif->ioc_firmware_unlock(__ioc))\n#define bfa_ioc_reg_init(__ioc) ((__ioc)->ioc_hwif->ioc_reg_init(__ioc))\n#define bfa_ioc_map_port(__ioc) ((__ioc)->ioc_hwif->ioc_map_port(__ioc))\n#define bfa_ioc_notify_fail(__ioc)\t\t\t\\\n\t\t\t((__ioc)->ioc_hwif->ioc_notify_fail(__ioc))\n#define bfa_ioc_sync_start(__ioc)               \\\n\t\t\t((__ioc)->ioc_hwif->ioc_sync_start(__ioc))\n#define bfa_ioc_sync_join(__ioc)\t\t\t\\\n\t\t\t((__ioc)->ioc_hwif->ioc_sync_join(__ioc))\n#define bfa_ioc_sync_leave(__ioc)\t\t\t\\\n\t\t\t((__ioc)->ioc_hwif->ioc_sync_leave(__ioc))\n#define bfa_ioc_sync_ack(__ioc)\t\t\t\t\\\n\t\t\t((__ioc)->ioc_hwif->ioc_sync_ack(__ioc))\n#define bfa_ioc_sync_complete(__ioc)\t\t\t\\\n\t\t\t((__ioc)->ioc_hwif->ioc_sync_complete(__ioc))\n#define bfa_ioc_set_cur_ioc_fwstate(__ioc, __fwstate)\t\t\\\n\t\t\t((__ioc)->ioc_hwif->ioc_set_fwstate(__ioc, __fwstate))\n#define bfa_ioc_get_cur_ioc_fwstate(__ioc)\t\t\\\n\t\t\t((__ioc)->ioc_hwif->ioc_get_fwstate(__ioc))\n#define bfa_ioc_set_alt_ioc_fwstate(__ioc, __fwstate)\t\t\\\n\t\t((__ioc)->ioc_hwif->ioc_set_alt_fwstate(__ioc, __fwstate))\n\nstatic bool bfa_nw_auto_recover = true;\n\n \nstatic void bfa_ioc_hw_sem_init(struct bfa_ioc *ioc);\nstatic void bfa_ioc_hw_sem_get(struct bfa_ioc *ioc);\nstatic void bfa_ioc_hw_sem_get_cancel(struct bfa_ioc *ioc);\nstatic void bfa_ioc_hwinit(struct bfa_ioc *ioc, bool force);\nstatic void bfa_ioc_poll_fwinit(struct bfa_ioc *ioc);\nstatic void bfa_ioc_send_enable(struct bfa_ioc *ioc);\nstatic void bfa_ioc_send_disable(struct bfa_ioc *ioc);\nstatic void bfa_ioc_send_getattr(struct bfa_ioc *ioc);\nstatic void bfa_ioc_hb_monitor(struct bfa_ioc *ioc);\nstatic void bfa_ioc_hb_stop(struct bfa_ioc *ioc);\nstatic void bfa_ioc_reset(struct bfa_ioc *ioc, bool force);\nstatic void bfa_ioc_mbox_poll(struct bfa_ioc *ioc);\nstatic void bfa_ioc_mbox_flush(struct bfa_ioc *ioc);\nstatic void bfa_ioc_recover(struct bfa_ioc *ioc);\nstatic void bfa_ioc_event_notify(struct bfa_ioc *, enum bfa_ioc_event);\nstatic void bfa_ioc_disable_comp(struct bfa_ioc *ioc);\nstatic void bfa_ioc_lpu_stop(struct bfa_ioc *ioc);\nstatic void bfa_nw_ioc_debug_save_ftrc(struct bfa_ioc *ioc);\nstatic void bfa_ioc_fail_notify(struct bfa_ioc *ioc);\nstatic void bfa_ioc_pf_enabled(struct bfa_ioc *ioc);\nstatic void bfa_ioc_pf_disabled(struct bfa_ioc *ioc);\nstatic void bfa_ioc_pf_failed(struct bfa_ioc *ioc);\nstatic void bfa_ioc_pf_hwfailed(struct bfa_ioc *ioc);\nstatic void bfa_ioc_pf_fwmismatch(struct bfa_ioc *ioc);\nstatic enum bfa_status bfa_ioc_boot(struct bfa_ioc *ioc,\n\t\t\tenum bfi_fwboot_type boot_type, u32 boot_param);\nstatic u32 bfa_ioc_smem_pgnum(struct bfa_ioc *ioc, u32 fmaddr);\nstatic void bfa_ioc_get_adapter_serial_num(struct bfa_ioc *ioc,\n\t\t\t\t\t\tchar *serial_num);\nstatic void bfa_ioc_get_adapter_fw_ver(struct bfa_ioc *ioc,\n\t\t\t\t\t\tchar *fw_ver);\nstatic void bfa_ioc_get_pci_chip_rev(struct bfa_ioc *ioc,\n\t\t\t\t\t\tchar *chip_rev);\nstatic void bfa_ioc_get_adapter_optrom_ver(struct bfa_ioc *ioc,\n\t\t\t\t\t\tchar *optrom_ver);\nstatic void bfa_ioc_get_adapter_manufacturer(struct bfa_ioc *ioc,\n\t\t\t\t\t\tchar *manufacturer);\nstatic void bfa_ioc_get_adapter_model(struct bfa_ioc *ioc, char *model);\nstatic u64 bfa_ioc_get_pwwn(struct bfa_ioc *ioc);\n\n \nenum ioc_event {\n\tIOC_E_RESET\t\t= 1,\t \n\tIOC_E_ENABLE\t\t= 2,\t \n\tIOC_E_DISABLE\t\t= 3,\t \n\tIOC_E_DETACH\t\t= 4,\t \n\tIOC_E_ENABLED\t\t= 5,\t \n\tIOC_E_FWRSP_GETATTR\t= 6,\t \n\tIOC_E_DISABLED\t\t= 7,\t \n\tIOC_E_PFFAILED\t\t= 8,\t \n\tIOC_E_HBFAIL\t\t= 9,\t \n\tIOC_E_HWERROR\t\t= 10,\t \n\tIOC_E_TIMEOUT\t\t= 11,\t \n\tIOC_E_HWFAILED\t\t= 12,\t \n};\n\nbfa_fsm_state_decl(bfa_ioc, uninit, struct bfa_ioc, enum ioc_event);\nbfa_fsm_state_decl(bfa_ioc, reset, struct bfa_ioc, enum ioc_event);\nbfa_fsm_state_decl(bfa_ioc, enabling, struct bfa_ioc, enum ioc_event);\nbfa_fsm_state_decl(bfa_ioc, getattr, struct bfa_ioc, enum ioc_event);\nbfa_fsm_state_decl(bfa_ioc, op, struct bfa_ioc, enum ioc_event);\nbfa_fsm_state_decl(bfa_ioc, fail_retry, struct bfa_ioc, enum ioc_event);\nbfa_fsm_state_decl(bfa_ioc, fail, struct bfa_ioc, enum ioc_event);\nbfa_fsm_state_decl(bfa_ioc, disabling, struct bfa_ioc, enum ioc_event);\nbfa_fsm_state_decl(bfa_ioc, disabled, struct bfa_ioc, enum ioc_event);\nbfa_fsm_state_decl(bfa_ioc, hwfail, struct bfa_ioc, enum ioc_event);\n\nstatic struct ioc_sm_table_s ioc_sm_table[] = {\n\t{BFA_SM(bfa_ioc_sm_uninit), BFA_IOC_UNINIT},\n\t{BFA_SM(bfa_ioc_sm_reset), BFA_IOC_RESET},\n\t{BFA_SM(bfa_ioc_sm_enabling), BFA_IOC_ENABLING},\n\t{BFA_SM(bfa_ioc_sm_getattr), BFA_IOC_GETATTR},\n\t{BFA_SM(bfa_ioc_sm_op), BFA_IOC_OPERATIONAL},\n\t{BFA_SM(bfa_ioc_sm_fail_retry), BFA_IOC_INITFAIL},\n\t{BFA_SM(bfa_ioc_sm_fail), BFA_IOC_FAIL},\n\t{BFA_SM(bfa_ioc_sm_disabling), BFA_IOC_DISABLING},\n\t{BFA_SM(bfa_ioc_sm_disabled), BFA_IOC_DISABLED},\n\t{BFA_SM(bfa_ioc_sm_hwfail), BFA_IOC_HWFAIL},\n};\n\n \nstatic void bfa_iocpf_enable(struct bfa_ioc *ioc);\nstatic void bfa_iocpf_disable(struct bfa_ioc *ioc);\nstatic void bfa_iocpf_fail(struct bfa_ioc *ioc);\nstatic void bfa_iocpf_initfail(struct bfa_ioc *ioc);\nstatic void bfa_iocpf_getattrfail(struct bfa_ioc *ioc);\nstatic void bfa_iocpf_stop(struct bfa_ioc *ioc);\n\n \nenum iocpf_event {\n\tIOCPF_E_ENABLE\t\t= 1,\t \n\tIOCPF_E_DISABLE\t\t= 2,\t \n\tIOCPF_E_STOP\t\t= 3,\t \n\tIOCPF_E_FWREADY\t\t= 4,\t \n\tIOCPF_E_FWRSP_ENABLE\t= 5,\t \n\tIOCPF_E_FWRSP_DISABLE\t= 6,\t \n\tIOCPF_E_FAIL\t\t= 7,\t \n\tIOCPF_E_INITFAIL\t= 8,\t \n\tIOCPF_E_GETATTRFAIL\t= 9,\t \n\tIOCPF_E_SEMLOCKED\t= 10,    \n\tIOCPF_E_TIMEOUT\t\t= 11,    \n\tIOCPF_E_SEM_ERROR\t= 12,    \n};\n\n \nenum bfa_iocpf_state {\n\tBFA_IOCPF_RESET\t\t= 1,\t \n\tBFA_IOCPF_SEMWAIT\t= 2,\t \n\tBFA_IOCPF_HWINIT\t= 3,\t \n\tBFA_IOCPF_READY\t\t= 4,\t \n\tBFA_IOCPF_INITFAIL\t= 5,\t \n\tBFA_IOCPF_FAIL\t\t= 6,\t \n\tBFA_IOCPF_DISABLING\t= 7,\t \n\tBFA_IOCPF_DISABLED\t= 8,\t \n\tBFA_IOCPF_FWMISMATCH\t= 9,\t \n};\n\nbfa_fsm_state_decl(bfa_iocpf, reset, struct bfa_iocpf, enum iocpf_event);\nbfa_fsm_state_decl(bfa_iocpf, fwcheck, struct bfa_iocpf, enum iocpf_event);\nbfa_fsm_state_decl(bfa_iocpf, mismatch, struct bfa_iocpf, enum iocpf_event);\nbfa_fsm_state_decl(bfa_iocpf, semwait, struct bfa_iocpf, enum iocpf_event);\nbfa_fsm_state_decl(bfa_iocpf, hwinit, struct bfa_iocpf, enum iocpf_event);\nbfa_fsm_state_decl(bfa_iocpf, enabling, struct bfa_iocpf, enum iocpf_event);\nbfa_fsm_state_decl(bfa_iocpf, ready, struct bfa_iocpf, enum iocpf_event);\nbfa_fsm_state_decl(bfa_iocpf, initfail_sync, struct bfa_iocpf,\n\t\t\t\t\t\tenum iocpf_event);\nbfa_fsm_state_decl(bfa_iocpf, initfail, struct bfa_iocpf, enum iocpf_event);\nbfa_fsm_state_decl(bfa_iocpf, fail_sync, struct bfa_iocpf, enum iocpf_event);\nbfa_fsm_state_decl(bfa_iocpf, fail, struct bfa_iocpf, enum iocpf_event);\nbfa_fsm_state_decl(bfa_iocpf, disabling, struct bfa_iocpf, enum iocpf_event);\nbfa_fsm_state_decl(bfa_iocpf, disabling_sync, struct bfa_iocpf,\n\t\t\t\t\t\tenum iocpf_event);\nbfa_fsm_state_decl(bfa_iocpf, disabled, struct bfa_iocpf, enum iocpf_event);\n\nstatic struct iocpf_sm_table_s iocpf_sm_table[] = {\n\t{BFA_SM(bfa_iocpf_sm_reset), BFA_IOCPF_RESET},\n\t{BFA_SM(bfa_iocpf_sm_fwcheck), BFA_IOCPF_FWMISMATCH},\n\t{BFA_SM(bfa_iocpf_sm_mismatch), BFA_IOCPF_FWMISMATCH},\n\t{BFA_SM(bfa_iocpf_sm_semwait), BFA_IOCPF_SEMWAIT},\n\t{BFA_SM(bfa_iocpf_sm_hwinit), BFA_IOCPF_HWINIT},\n\t{BFA_SM(bfa_iocpf_sm_enabling), BFA_IOCPF_HWINIT},\n\t{BFA_SM(bfa_iocpf_sm_ready), BFA_IOCPF_READY},\n\t{BFA_SM(bfa_iocpf_sm_initfail_sync), BFA_IOCPF_INITFAIL},\n\t{BFA_SM(bfa_iocpf_sm_initfail), BFA_IOCPF_INITFAIL},\n\t{BFA_SM(bfa_iocpf_sm_fail_sync), BFA_IOCPF_FAIL},\n\t{BFA_SM(bfa_iocpf_sm_fail), BFA_IOCPF_FAIL},\n\t{BFA_SM(bfa_iocpf_sm_disabling), BFA_IOCPF_DISABLING},\n\t{BFA_SM(bfa_iocpf_sm_disabling_sync), BFA_IOCPF_DISABLING},\n\t{BFA_SM(bfa_iocpf_sm_disabled), BFA_IOCPF_DISABLED},\n};\n\n \n\n \nstatic void\nbfa_ioc_sm_uninit_entry(struct bfa_ioc *ioc)\n{\n}\n\n \nstatic void\nbfa_ioc_sm_uninit(struct bfa_ioc *ioc, enum ioc_event event)\n{\n\tswitch (event) {\n\tcase IOC_E_RESET:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_reset);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\n \nstatic void\nbfa_ioc_sm_reset_entry(struct bfa_ioc *ioc)\n{\n\tbfa_fsm_set_state(&ioc->iocpf, bfa_iocpf_sm_reset);\n}\n\n \nstatic void\nbfa_ioc_sm_reset(struct bfa_ioc *ioc, enum ioc_event event)\n{\n\tswitch (event) {\n\tcase IOC_E_ENABLE:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_enabling);\n\t\tbreak;\n\n\tcase IOC_E_DISABLE:\n\t\tbfa_ioc_disable_comp(ioc);\n\t\tbreak;\n\n\tcase IOC_E_DETACH:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_uninit);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_ioc_sm_enabling_entry(struct bfa_ioc *ioc)\n{\n\tbfa_iocpf_enable(ioc);\n}\n\n \nstatic void\nbfa_ioc_sm_enabling(struct bfa_ioc *ioc, enum ioc_event event)\n{\n\tswitch (event) {\n\tcase IOC_E_ENABLED:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_getattr);\n\t\tbreak;\n\n\tcase IOC_E_PFFAILED:\n\t\tfallthrough;\n\tcase IOC_E_HWERROR:\n\t\tioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_fail);\n\t\tif (event != IOC_E_PFFAILED)\n\t\t\tbfa_iocpf_initfail(ioc);\n\t\tbreak;\n\n\tcase IOC_E_HWFAILED:\n\t\tioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_hwfail);\n\t\tbreak;\n\n\tcase IOC_E_DISABLE:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_disabling);\n\t\tbreak;\n\n\tcase IOC_E_DETACH:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_uninit);\n\t\tbfa_iocpf_stop(ioc);\n\t\tbreak;\n\n\tcase IOC_E_ENABLE:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\n \nstatic void\nbfa_ioc_sm_getattr_entry(struct bfa_ioc *ioc)\n{\n\tmod_timer(&ioc->ioc_timer, jiffies +\n\t\tmsecs_to_jiffies(BFA_IOC_TOV));\n\tbfa_ioc_send_getattr(ioc);\n}\n\n \nstatic void\nbfa_ioc_sm_getattr(struct bfa_ioc *ioc, enum ioc_event event)\n{\n\tswitch (event) {\n\tcase IOC_E_FWRSP_GETATTR:\n\t\tdel_timer(&ioc->ioc_timer);\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_op);\n\t\tbreak;\n\n\tcase IOC_E_PFFAILED:\n\tcase IOC_E_HWERROR:\n\t\tdel_timer(&ioc->ioc_timer);\n\t\tfallthrough;\n\tcase IOC_E_TIMEOUT:\n\t\tioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_fail);\n\t\tif (event != IOC_E_PFFAILED)\n\t\t\tbfa_iocpf_getattrfail(ioc);\n\t\tbreak;\n\n\tcase IOC_E_DISABLE:\n\t\tdel_timer(&ioc->ioc_timer);\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_disabling);\n\t\tbreak;\n\n\tcase IOC_E_ENABLE:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_ioc_sm_op_entry(struct bfa_ioc *ioc)\n{\n\tioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_OK);\n\tbfa_ioc_event_notify(ioc, BFA_IOC_E_ENABLED);\n\tbfa_ioc_hb_monitor(ioc);\n}\n\nstatic void\nbfa_ioc_sm_op(struct bfa_ioc *ioc, enum ioc_event event)\n{\n\tswitch (event) {\n\tcase IOC_E_ENABLE:\n\t\tbreak;\n\n\tcase IOC_E_DISABLE:\n\t\tbfa_ioc_hb_stop(ioc);\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_disabling);\n\t\tbreak;\n\n\tcase IOC_E_PFFAILED:\n\tcase IOC_E_HWERROR:\n\t\tbfa_ioc_hb_stop(ioc);\n\t\tfallthrough;\n\n\tcase IOC_E_HBFAIL:\n\t\tif (ioc->iocpf.auto_recover)\n\t\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_fail_retry);\n\t\telse\n\t\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_fail);\n\n\t\tbfa_ioc_fail_notify(ioc);\n\n\t\tif (event != IOC_E_PFFAILED)\n\t\t\tbfa_iocpf_fail(ioc);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_ioc_sm_disabling_entry(struct bfa_ioc *ioc)\n{\n\tbfa_iocpf_disable(ioc);\n}\n\n \nstatic void\nbfa_ioc_sm_disabling(struct bfa_ioc *ioc, enum ioc_event event)\n{\n\tswitch (event) {\n\tcase IOC_E_DISABLED:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_disabled);\n\t\tbreak;\n\n\tcase IOC_E_HWERROR:\n\t\t \n\t\tbfa_iocpf_fail(ioc);\n\t\tbreak;\n\n\tcase IOC_E_HWFAILED:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_hwfail);\n\t\tbfa_ioc_disable_comp(ioc);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\n \nstatic void\nbfa_ioc_sm_disabled_entry(struct bfa_ioc *ioc)\n{\n\tbfa_ioc_disable_comp(ioc);\n}\n\nstatic void\nbfa_ioc_sm_disabled(struct bfa_ioc *ioc, enum ioc_event event)\n{\n\tswitch (event) {\n\tcase IOC_E_ENABLE:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_enabling);\n\t\tbreak;\n\n\tcase IOC_E_DISABLE:\n\t\tioc->cbfn->disable_cbfn(ioc->bfa);\n\t\tbreak;\n\n\tcase IOC_E_DETACH:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_uninit);\n\t\tbfa_iocpf_stop(ioc);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_ioc_sm_fail_retry_entry(struct bfa_ioc *ioc)\n{\n}\n\n \nstatic void\nbfa_ioc_sm_fail_retry(struct bfa_ioc *ioc, enum ioc_event event)\n{\n\tswitch (event) {\n\tcase IOC_E_ENABLED:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_getattr);\n\t\tbreak;\n\n\tcase IOC_E_PFFAILED:\n\tcase IOC_E_HWERROR:\n\t\t \n\t\tioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_fail);\n\t\tif (event != IOC_E_PFFAILED)\n\t\t\tbfa_iocpf_initfail(ioc);\n\t\tbreak;\n\n\tcase IOC_E_HWFAILED:\n\t\tioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_hwfail);\n\t\tbreak;\n\n\tcase IOC_E_ENABLE:\n\t\tbreak;\n\n\tcase IOC_E_DISABLE:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_disabling);\n\t\tbreak;\n\n\tcase IOC_E_DETACH:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_uninit);\n\t\tbfa_iocpf_stop(ioc);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_ioc_sm_fail_entry(struct bfa_ioc *ioc)\n{\n}\n\n \nstatic void\nbfa_ioc_sm_fail(struct bfa_ioc *ioc, enum ioc_event event)\n{\n\tswitch (event) {\n\tcase IOC_E_ENABLE:\n\t\tioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\n\t\tbreak;\n\n\tcase IOC_E_DISABLE:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_disabling);\n\t\tbreak;\n\n\tcase IOC_E_DETACH:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_uninit);\n\t\tbfa_iocpf_stop(ioc);\n\t\tbreak;\n\n\tcase IOC_E_HWERROR:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_ioc_sm_hwfail_entry(struct bfa_ioc *ioc)\n{\n}\n\n \nstatic void\nbfa_ioc_sm_hwfail(struct bfa_ioc *ioc, enum ioc_event event)\n{\n\tswitch (event) {\n\n\tcase IOC_E_ENABLE:\n\t\tioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\n\t\tbreak;\n\n\tcase IOC_E_DISABLE:\n\t\tioc->cbfn->disable_cbfn(ioc->bfa);\n\t\tbreak;\n\n\tcase IOC_E_DETACH:\n\t\tbfa_fsm_set_state(ioc, bfa_ioc_sm_uninit);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\n \n\n \nstatic void\nbfa_iocpf_sm_reset_entry(struct bfa_iocpf *iocpf)\n{\n\tiocpf->fw_mismatch_notified = false;\n\tiocpf->auto_recover = bfa_nw_auto_recover;\n}\n\n \nstatic void\nbfa_iocpf_sm_reset(struct bfa_iocpf *iocpf, enum iocpf_event event)\n{\n\tswitch (event) {\n\tcase IOCPF_E_ENABLE:\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fwcheck);\n\t\tbreak;\n\n\tcase IOCPF_E_STOP:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\n \nstatic void\nbfa_iocpf_sm_fwcheck_entry(struct bfa_iocpf *iocpf)\n{\n\tbfa_ioc_hw_sem_init(iocpf->ioc);\n\tbfa_ioc_hw_sem_get(iocpf->ioc);\n}\n\n \nstatic void\nbfa_iocpf_sm_fwcheck(struct bfa_iocpf *iocpf, enum iocpf_event event)\n{\n\tstruct bfa_ioc *ioc = iocpf->ioc;\n\n\tswitch (event) {\n\tcase IOCPF_E_SEMLOCKED:\n\t\tif (bfa_ioc_firmware_lock(ioc)) {\n\t\t\tif (bfa_ioc_sync_start(ioc)) {\n\t\t\t\tbfa_ioc_sync_join(ioc);\n\t\t\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_hwinit);\n\t\t\t} else {\n\t\t\t\tbfa_ioc_firmware_unlock(ioc);\n\t\t\t\tbfa_nw_ioc_hw_sem_release(ioc);\n\t\t\t\tmod_timer(&ioc->sem_timer, jiffies +\n\t\t\t\t\tmsecs_to_jiffies(BFA_IOC_HWSEM_TOV));\n\t\t\t}\n\t\t} else {\n\t\t\tbfa_nw_ioc_hw_sem_release(ioc);\n\t\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_mismatch);\n\t\t}\n\t\tbreak;\n\n\tcase IOCPF_E_SEM_ERROR:\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fail);\n\t\tbfa_ioc_pf_hwfailed(ioc);\n\t\tbreak;\n\n\tcase IOCPF_E_DISABLE:\n\t\tbfa_ioc_hw_sem_get_cancel(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_reset);\n\t\tbfa_ioc_pf_disabled(ioc);\n\t\tbreak;\n\n\tcase IOCPF_E_STOP:\n\t\tbfa_ioc_hw_sem_get_cancel(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_reset);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\n \nstatic void\nbfa_iocpf_sm_mismatch_entry(struct bfa_iocpf *iocpf)\n{\n\t \n\tif (!iocpf->fw_mismatch_notified)\n\t\tbfa_ioc_pf_fwmismatch(iocpf->ioc);\n\n\tiocpf->fw_mismatch_notified = true;\n\tmod_timer(&(iocpf->ioc)->iocpf_timer, jiffies +\n\t\tmsecs_to_jiffies(BFA_IOC_TOV));\n}\n\n \nstatic void\nbfa_iocpf_sm_mismatch(struct bfa_iocpf *iocpf, enum iocpf_event event)\n{\n\tstruct bfa_ioc *ioc = iocpf->ioc;\n\n\tswitch (event) {\n\tcase IOCPF_E_TIMEOUT:\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fwcheck);\n\t\tbreak;\n\n\tcase IOCPF_E_DISABLE:\n\t\tdel_timer(&ioc->iocpf_timer);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_reset);\n\t\tbfa_ioc_pf_disabled(ioc);\n\t\tbreak;\n\n\tcase IOCPF_E_STOP:\n\t\tdel_timer(&ioc->iocpf_timer);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_reset);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\n \nstatic void\nbfa_iocpf_sm_semwait_entry(struct bfa_iocpf *iocpf)\n{\n\tbfa_ioc_hw_sem_get(iocpf->ioc);\n}\n\n \nstatic void\nbfa_iocpf_sm_semwait(struct bfa_iocpf *iocpf, enum iocpf_event event)\n{\n\tstruct bfa_ioc *ioc = iocpf->ioc;\n\n\tswitch (event) {\n\tcase IOCPF_E_SEMLOCKED:\n\t\tif (bfa_ioc_sync_complete(ioc)) {\n\t\t\tbfa_ioc_sync_join(ioc);\n\t\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_hwinit);\n\t\t} else {\n\t\t\tbfa_nw_ioc_hw_sem_release(ioc);\n\t\t\tmod_timer(&ioc->sem_timer, jiffies +\n\t\t\t\tmsecs_to_jiffies(BFA_IOC_HWSEM_TOV));\n\t\t}\n\t\tbreak;\n\n\tcase IOCPF_E_SEM_ERROR:\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fail);\n\t\tbfa_ioc_pf_hwfailed(ioc);\n\t\tbreak;\n\n\tcase IOCPF_E_DISABLE:\n\t\tbfa_ioc_hw_sem_get_cancel(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabling_sync);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_iocpf_sm_hwinit_entry(struct bfa_iocpf *iocpf)\n{\n\tiocpf->poll_time = 0;\n\tbfa_ioc_reset(iocpf->ioc, false);\n}\n\n \nstatic void\nbfa_iocpf_sm_hwinit(struct bfa_iocpf *iocpf, enum iocpf_event event)\n{\n\tstruct bfa_ioc *ioc = iocpf->ioc;\n\n\tswitch (event) {\n\tcase IOCPF_E_FWREADY:\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_enabling);\n\t\tbreak;\n\n\tcase IOCPF_E_TIMEOUT:\n\t\tbfa_nw_ioc_hw_sem_release(ioc);\n\t\tbfa_ioc_pf_failed(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_initfail_sync);\n\t\tbreak;\n\n\tcase IOCPF_E_DISABLE:\n\t\tdel_timer(&ioc->iocpf_timer);\n\t\tbfa_ioc_sync_leave(ioc);\n\t\tbfa_nw_ioc_hw_sem_release(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabled);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_iocpf_sm_enabling_entry(struct bfa_iocpf *iocpf)\n{\n\tmod_timer(&(iocpf->ioc)->iocpf_timer, jiffies +\n\t\tmsecs_to_jiffies(BFA_IOC_TOV));\n\t \n\tiocpf->ioc->cbfn->reset_cbfn(iocpf->ioc->bfa);\n\tbfa_ioc_send_enable(iocpf->ioc);\n}\n\n \nstatic void\nbfa_iocpf_sm_enabling(struct bfa_iocpf *iocpf, enum iocpf_event event)\n{\n\tstruct bfa_ioc *ioc = iocpf->ioc;\n\n\tswitch (event) {\n\tcase IOCPF_E_FWRSP_ENABLE:\n\t\tdel_timer(&ioc->iocpf_timer);\n\t\tbfa_nw_ioc_hw_sem_release(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_ready);\n\t\tbreak;\n\n\tcase IOCPF_E_INITFAIL:\n\t\tdel_timer(&ioc->iocpf_timer);\n\t\tfallthrough;\n\n\tcase IOCPF_E_TIMEOUT:\n\t\tbfa_nw_ioc_hw_sem_release(ioc);\n\t\tif (event == IOCPF_E_TIMEOUT)\n\t\t\tbfa_ioc_pf_failed(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_initfail_sync);\n\t\tbreak;\n\n\tcase IOCPF_E_DISABLE:\n\t\tdel_timer(&ioc->iocpf_timer);\n\t\tbfa_nw_ioc_hw_sem_release(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabling);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_iocpf_sm_ready_entry(struct bfa_iocpf *iocpf)\n{\n\tbfa_ioc_pf_enabled(iocpf->ioc);\n}\n\nstatic void\nbfa_iocpf_sm_ready(struct bfa_iocpf *iocpf, enum iocpf_event event)\n{\n\tswitch (event) {\n\tcase IOCPF_E_DISABLE:\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabling);\n\t\tbreak;\n\n\tcase IOCPF_E_GETATTRFAIL:\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_initfail_sync);\n\t\tbreak;\n\n\tcase IOCPF_E_FAIL:\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fail_sync);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_iocpf_sm_disabling_entry(struct bfa_iocpf *iocpf)\n{\n\tmod_timer(&(iocpf->ioc)->iocpf_timer, jiffies +\n\t\tmsecs_to_jiffies(BFA_IOC_TOV));\n\tbfa_ioc_send_disable(iocpf->ioc);\n}\n\n \nstatic void\nbfa_iocpf_sm_disabling(struct bfa_iocpf *iocpf, enum iocpf_event event)\n{\n\tstruct bfa_ioc *ioc = iocpf->ioc;\n\n\tswitch (event) {\n\tcase IOCPF_E_FWRSP_DISABLE:\n\t\tdel_timer(&ioc->iocpf_timer);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabling_sync);\n\t\tbreak;\n\n\tcase IOCPF_E_FAIL:\n\t\tdel_timer(&ioc->iocpf_timer);\n\t\tfallthrough;\n\n\tcase IOCPF_E_TIMEOUT:\n\t\tbfa_ioc_set_cur_ioc_fwstate(ioc, BFI_IOC_FAIL);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabling_sync);\n\t\tbreak;\n\n\tcase IOCPF_E_FWRSP_ENABLE:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_iocpf_sm_disabling_sync_entry(struct bfa_iocpf *iocpf)\n{\n\tbfa_ioc_hw_sem_get(iocpf->ioc);\n}\n\n \nstatic void\nbfa_iocpf_sm_disabling_sync(struct bfa_iocpf *iocpf, enum iocpf_event event)\n{\n\tstruct bfa_ioc *ioc = iocpf->ioc;\n\n\tswitch (event) {\n\tcase IOCPF_E_SEMLOCKED:\n\t\tbfa_ioc_sync_leave(ioc);\n\t\tbfa_nw_ioc_hw_sem_release(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabled);\n\t\tbreak;\n\n\tcase IOCPF_E_SEM_ERROR:\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fail);\n\t\tbfa_ioc_pf_hwfailed(ioc);\n\t\tbreak;\n\n\tcase IOCPF_E_FAIL:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\n \nstatic void\nbfa_iocpf_sm_disabled_entry(struct bfa_iocpf *iocpf)\n{\n\tbfa_ioc_mbox_flush(iocpf->ioc);\n\tbfa_ioc_pf_disabled(iocpf->ioc);\n}\n\nstatic void\nbfa_iocpf_sm_disabled(struct bfa_iocpf *iocpf, enum iocpf_event event)\n{\n\tstruct bfa_ioc *ioc = iocpf->ioc;\n\n\tswitch (event) {\n\tcase IOCPF_E_ENABLE:\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_semwait);\n\t\tbreak;\n\n\tcase IOCPF_E_STOP:\n\t\tbfa_ioc_firmware_unlock(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_reset);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_iocpf_sm_initfail_sync_entry(struct bfa_iocpf *iocpf)\n{\n\tbfa_nw_ioc_debug_save_ftrc(iocpf->ioc);\n\tbfa_ioc_hw_sem_get(iocpf->ioc);\n}\n\n \nstatic void\nbfa_iocpf_sm_initfail_sync(struct bfa_iocpf *iocpf, enum iocpf_event event)\n{\n\tstruct bfa_ioc *ioc = iocpf->ioc;\n\n\tswitch (event) {\n\tcase IOCPF_E_SEMLOCKED:\n\t\tbfa_ioc_notify_fail(ioc);\n\t\tbfa_ioc_sync_leave(ioc);\n\t\tbfa_ioc_set_cur_ioc_fwstate(ioc, BFI_IOC_FAIL);\n\t\tbfa_nw_ioc_hw_sem_release(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_initfail);\n\t\tbreak;\n\n\tcase IOCPF_E_SEM_ERROR:\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fail);\n\t\tbfa_ioc_pf_hwfailed(ioc);\n\t\tbreak;\n\n\tcase IOCPF_E_DISABLE:\n\t\tbfa_ioc_hw_sem_get_cancel(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabling_sync);\n\t\tbreak;\n\n\tcase IOCPF_E_STOP:\n\t\tbfa_ioc_hw_sem_get_cancel(ioc);\n\t\tbfa_ioc_firmware_unlock(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_reset);\n\t\tbreak;\n\n\tcase IOCPF_E_FAIL:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_iocpf_sm_initfail_entry(struct bfa_iocpf *iocpf)\n{\n}\n\n \nstatic void\nbfa_iocpf_sm_initfail(struct bfa_iocpf *iocpf, enum iocpf_event event)\n{\n\tstruct bfa_ioc *ioc = iocpf->ioc;\n\n\tswitch (event) {\n\tcase IOCPF_E_DISABLE:\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabled);\n\t\tbreak;\n\n\tcase IOCPF_E_STOP:\n\t\tbfa_ioc_firmware_unlock(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_reset);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_iocpf_sm_fail_sync_entry(struct bfa_iocpf *iocpf)\n{\n\t \n\tbfa_ioc_lpu_stop(iocpf->ioc);\n\n\t \n\tbfa_ioc_mbox_flush(iocpf->ioc);\n\tbfa_ioc_hw_sem_get(iocpf->ioc);\n}\n\n \nstatic void\nbfa_iocpf_sm_fail_sync(struct bfa_iocpf *iocpf, enum iocpf_event event)\n{\n\tstruct bfa_ioc *ioc = iocpf->ioc;\n\n\tswitch (event) {\n\tcase IOCPF_E_SEMLOCKED:\n\t\tbfa_ioc_sync_ack(ioc);\n\t\tbfa_ioc_notify_fail(ioc);\n\t\tif (!iocpf->auto_recover) {\n\t\t\tbfa_ioc_sync_leave(ioc);\n\t\t\tbfa_ioc_set_cur_ioc_fwstate(ioc, BFI_IOC_FAIL);\n\t\t\tbfa_nw_ioc_hw_sem_release(ioc);\n\t\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fail);\n\t\t} else {\n\t\t\tif (bfa_ioc_sync_complete(ioc))\n\t\t\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_hwinit);\n\t\t\telse {\n\t\t\t\tbfa_nw_ioc_hw_sem_release(ioc);\n\t\t\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_semwait);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IOCPF_E_SEM_ERROR:\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_fail);\n\t\tbfa_ioc_pf_hwfailed(ioc);\n\t\tbreak;\n\n\tcase IOCPF_E_DISABLE:\n\t\tbfa_ioc_hw_sem_get_cancel(ioc);\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabling_sync);\n\t\tbreak;\n\n\tcase IOCPF_E_FAIL:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\nstatic void\nbfa_iocpf_sm_fail_entry(struct bfa_iocpf *iocpf)\n{\n}\n\n \nstatic void\nbfa_iocpf_sm_fail(struct bfa_iocpf *iocpf, enum iocpf_event event)\n{\n\tswitch (event) {\n\tcase IOCPF_E_DISABLE:\n\t\tbfa_fsm_set_state(iocpf, bfa_iocpf_sm_disabled);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(event);\n\t}\n}\n\n \n\n \nstatic void\nbfa_ioc_event_notify(struct bfa_ioc *ioc, enum bfa_ioc_event event)\n{\n\tstruct bfa_ioc_notify *notify;\n\n\tlist_for_each_entry(notify, &ioc->notify_q, qe)\n\t\tnotify->cbfn(notify->cbarg, event);\n}\n\nstatic void\nbfa_ioc_disable_comp(struct bfa_ioc *ioc)\n{\n\tioc->cbfn->disable_cbfn(ioc->bfa);\n\tbfa_ioc_event_notify(ioc, BFA_IOC_E_DISABLED);\n}\n\nbool\nbfa_nw_ioc_sem_get(void __iomem *sem_reg)\n{\n\tu32 r32;\n\tint cnt = 0;\n#define BFA_SEM_SPINCNT\t3000\n\n\tr32 = readl(sem_reg);\n\n\twhile ((r32 & 1) && (cnt < BFA_SEM_SPINCNT)) {\n\t\tcnt++;\n\t\tudelay(2);\n\t\tr32 = readl(sem_reg);\n\t}\n\n\tif (!(r32 & 1))\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid\nbfa_nw_ioc_sem_release(void __iomem *sem_reg)\n{\n\treadl(sem_reg);\n\twritel(1, sem_reg);\n}\n\n \nstatic void\nbfa_ioc_fwver_clear(struct bfa_ioc *ioc)\n{\n\tu32 pgnum, loff = 0;\n\tint i;\n\n\tpgnum = PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, loff);\n\twritel(pgnum, ioc->ioc_regs.host_page_num_fn);\n\n\tfor (i = 0; i < (sizeof(struct bfi_ioc_image_hdr) / sizeof(u32)); i++) {\n\t\twritel(0, ioc->ioc_regs.smem_page_start + loff);\n\t\tloff += sizeof(u32);\n\t}\n}\n\n\nstatic void\nbfa_ioc_hw_sem_init(struct bfa_ioc *ioc)\n{\n\tstruct bfi_ioc_image_hdr fwhdr;\n\tu32 fwstate, r32;\n\n\t \n\tr32 = readl(ioc->ioc_regs.ioc_init_sem_reg);\n\twhile (r32 & 0x1) {\n\t\tudelay(20);\n\t\tr32 = readl(ioc->ioc_regs.ioc_init_sem_reg);\n\t}\n\n\tfwstate = bfa_ioc_get_cur_ioc_fwstate(ioc);\n\tif (fwstate == BFI_IOC_UNINIT) {\n\t\twritel(1, ioc->ioc_regs.ioc_init_sem_reg);\n\t\treturn;\n\t}\n\n\tbfa_nw_ioc_fwver_get(ioc, &fwhdr);\n\n\tif (swab32(fwhdr.exec) == BFI_FWBOOT_TYPE_NORMAL) {\n\t\twritel(1, ioc->ioc_regs.ioc_init_sem_reg);\n\t\treturn;\n\t}\n\n\tbfa_ioc_fwver_clear(ioc);\n\tbfa_ioc_set_cur_ioc_fwstate(ioc, BFI_IOC_UNINIT);\n\tbfa_ioc_set_alt_ioc_fwstate(ioc, BFI_IOC_UNINIT);\n\n\t \n\treadl(ioc->ioc_regs.ioc_sem_reg);\n\twritel(1, ioc->ioc_regs.ioc_sem_reg);\n\n\t \n\twritel(1, ioc->ioc_regs.ioc_init_sem_reg);\n}\n\nstatic void\nbfa_ioc_hw_sem_get(struct bfa_ioc *ioc)\n{\n\tu32\tr32;\n\n\t \n\tr32 = readl(ioc->ioc_regs.ioc_sem_reg);\n\tif (r32 == ~0) {\n\t\tbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_SEM_ERROR);\n\t\treturn;\n\t}\n\tif (!(r32 & 1)) {\n\t\tbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_SEMLOCKED);\n\t\treturn;\n\t}\n\n\tmod_timer(&ioc->sem_timer, jiffies +\n\t\tmsecs_to_jiffies(BFA_IOC_HWSEM_TOV));\n}\n\nvoid\nbfa_nw_ioc_hw_sem_release(struct bfa_ioc *ioc)\n{\n\twritel(1, ioc->ioc_regs.ioc_sem_reg);\n}\n\nstatic void\nbfa_ioc_hw_sem_get_cancel(struct bfa_ioc *ioc)\n{\n\tdel_timer(&ioc->sem_timer);\n}\n\n \nstatic void\nbfa_ioc_lmem_init(struct bfa_ioc *ioc)\n{\n\tu32\tpss_ctl;\n\tint\t\ti;\n#define PSS_LMEM_INIT_TIME  10000\n\n\tpss_ctl = readl(ioc->ioc_regs.pss_ctl_reg);\n\tpss_ctl &= ~__PSS_LMEM_RESET;\n\tpss_ctl |= __PSS_LMEM_INIT_EN;\n\n\t \n\tpss_ctl |= __PSS_I2C_CLK_DIV(3UL);\n\twritel(pss_ctl, ioc->ioc_regs.pss_ctl_reg);\n\n\t \n\ti = 0;\n\tdo {\n\t\tpss_ctl = readl(ioc->ioc_regs.pss_ctl_reg);\n\t\ti++;\n\t} while (!(pss_ctl & __PSS_LMEM_INIT_DONE) && (i < PSS_LMEM_INIT_TIME));\n\n\t \n\tBUG_ON(!(pss_ctl & __PSS_LMEM_INIT_DONE));\n\n\tpss_ctl &= ~(__PSS_LMEM_INIT_DONE | __PSS_LMEM_INIT_EN);\n\twritel(pss_ctl, ioc->ioc_regs.pss_ctl_reg);\n}\n\nstatic void\nbfa_ioc_lpu_start(struct bfa_ioc *ioc)\n{\n\tu32\tpss_ctl;\n\n\t \n\tpss_ctl = readl(ioc->ioc_regs.pss_ctl_reg);\n\tpss_ctl &= ~__PSS_LPU0_RESET;\n\n\twritel(pss_ctl, ioc->ioc_regs.pss_ctl_reg);\n}\n\nstatic void\nbfa_ioc_lpu_stop(struct bfa_ioc *ioc)\n{\n\tu32\tpss_ctl;\n\n\t \n\tpss_ctl = readl(ioc->ioc_regs.pss_ctl_reg);\n\tpss_ctl |= (__PSS_LPU0_RESET | __PSS_LPU1_RESET);\n\n\twritel(pss_ctl, ioc->ioc_regs.pss_ctl_reg);\n}\n\n \nvoid\nbfa_nw_ioc_fwver_get(struct bfa_ioc *ioc, struct bfi_ioc_image_hdr *fwhdr)\n{\n\tu32\tpgnum;\n\tu32\tloff = 0;\n\tint\t\ti;\n\tu32\t*fwsig = (u32 *) fwhdr;\n\n\tpgnum = bfa_ioc_smem_pgnum(ioc, loff);\n\twritel(pgnum, ioc->ioc_regs.host_page_num_fn);\n\n\tfor (i = 0; i < (sizeof(struct bfi_ioc_image_hdr) / sizeof(u32));\n\t     i++) {\n\t\tfwsig[i] =\n\t\t\tswab32(readl(loff + ioc->ioc_regs.smem_page_start));\n\t\tloff += sizeof(u32);\n\t}\n}\n\nstatic bool\nbfa_ioc_fwver_md5_check(struct bfi_ioc_image_hdr *fwhdr_1,\n\t\t\tstruct bfi_ioc_image_hdr *fwhdr_2)\n{\n\tint i;\n\n\tfor (i = 0; i < BFI_IOC_MD5SUM_SZ; i++) {\n\t\tif (fwhdr_1->md5sum[i] != fwhdr_2->md5sum[i])\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool\nbfa_ioc_fw_ver_compatible(struct bfi_ioc_image_hdr *drv_fwhdr,\n\t\t\t  struct bfi_ioc_image_hdr *fwhdr_to_cmp)\n{\n\tif (drv_fwhdr->signature != fwhdr_to_cmp->signature)\n\t\treturn false;\n\tif (drv_fwhdr->fwver.major != fwhdr_to_cmp->fwver.major)\n\t\treturn false;\n\tif (drv_fwhdr->fwver.minor != fwhdr_to_cmp->fwver.minor)\n\t\treturn false;\n\tif (drv_fwhdr->fwver.maint != fwhdr_to_cmp->fwver.maint)\n\t\treturn false;\n\tif (drv_fwhdr->fwver.patch == fwhdr_to_cmp->fwver.patch &&\n\t    drv_fwhdr->fwver.phase == fwhdr_to_cmp->fwver.phase &&\n\t    drv_fwhdr->fwver.build == fwhdr_to_cmp->fwver.build)\n\t\treturn bfa_ioc_fwver_md5_check(drv_fwhdr, fwhdr_to_cmp);\n\n\treturn true;\n}\n\nstatic bool\nbfa_ioc_flash_fwver_valid(struct bfi_ioc_image_hdr *flash_fwhdr)\n{\n\tif (flash_fwhdr->fwver.major == 0 || flash_fwhdr->fwver.major == 0xFF)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nfwhdr_is_ga(struct bfi_ioc_image_hdr *fwhdr)\n{\n\tif (fwhdr->fwver.phase == 0 &&\n\t    fwhdr->fwver.build == 0)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic enum bfi_ioc_img_ver_cmp\nbfa_ioc_fw_ver_patch_cmp(struct bfi_ioc_image_hdr *base_fwhdr,\n\t\t\t struct bfi_ioc_image_hdr *fwhdr_to_cmp)\n{\n\tif (!bfa_ioc_fw_ver_compatible(base_fwhdr, fwhdr_to_cmp))\n\t\treturn BFI_IOC_IMG_VER_INCOMP;\n\n\tif (fwhdr_to_cmp->fwver.patch > base_fwhdr->fwver.patch)\n\t\treturn BFI_IOC_IMG_VER_BETTER;\n\telse if (fwhdr_to_cmp->fwver.patch < base_fwhdr->fwver.patch)\n\t\treturn BFI_IOC_IMG_VER_OLD;\n\n\t \n\tif (fwhdr_is_ga(base_fwhdr))\n\t\tif (fwhdr_is_ga(fwhdr_to_cmp))\n\t\t\treturn BFI_IOC_IMG_VER_SAME;\n\t\telse\n\t\t\treturn BFI_IOC_IMG_VER_OLD;\n\telse\n\t\tif (fwhdr_is_ga(fwhdr_to_cmp))\n\t\t\treturn BFI_IOC_IMG_VER_BETTER;\n\n\tif (fwhdr_to_cmp->fwver.phase > base_fwhdr->fwver.phase)\n\t\treturn BFI_IOC_IMG_VER_BETTER;\n\telse if (fwhdr_to_cmp->fwver.phase < base_fwhdr->fwver.phase)\n\t\treturn BFI_IOC_IMG_VER_OLD;\n\n\tif (fwhdr_to_cmp->fwver.build > base_fwhdr->fwver.build)\n\t\treturn BFI_IOC_IMG_VER_BETTER;\n\telse if (fwhdr_to_cmp->fwver.build < base_fwhdr->fwver.build)\n\t\treturn BFI_IOC_IMG_VER_OLD;\n\n\t \n\treturn BFI_IOC_IMG_VER_SAME;\n}\n\n \n#define FLI_CMD_REG\t\t\t0x0001d000\n#define FLI_WRDATA_REG\t\t\t0x0001d00c\n#define FLI_RDDATA_REG\t\t\t0x0001d010\n#define FLI_ADDR_REG\t\t\t0x0001d004\n#define FLI_DEV_STATUS_REG\t\t0x0001d014\n\n#define BFA_FLASH_FIFO_SIZE\t\t128\t \n#define BFA_FLASH_CHECK_MAX\t\t10000\t \n#define BFA_FLASH_BLOCKING_OP_MAX\t1000000\t \n#define BFA_FLASH_WIP_MASK\t\t0x01\t \n\n#define NFC_STATE_RUNNING\t\t0x20000001\n#define NFC_STATE_PAUSED\t\t0x00004560\n#define NFC_VER_VALID\t\t\t0x147\n\nenum bfa_flash_cmd {\n\tBFA_FLASH_FAST_READ\t= 0x0b,\t \n\tBFA_FLASH_WRITE_ENABLE\t= 0x06,\t \n\tBFA_FLASH_SECTOR_ERASE\t= 0xd8,\t \n\tBFA_FLASH_WRITE\t\t= 0x02,\t \n\tBFA_FLASH_READ_STATUS\t= 0x05,\t \n};\n\n \nenum bfa_flash_err {\n\tBFA_FLASH_NOT_PRESENT\t= -1,\t \n\tBFA_FLASH_UNINIT\t= -2,\t \n\tBFA_FLASH_BAD\t\t= -3,\t \n\tBFA_FLASH_BUSY\t\t= -4,\t \n\tBFA_FLASH_ERR_CMD_ACT\t= -5,\t \n\tBFA_FLASH_ERR_FIFO_CNT\t= -6,\t \n\tBFA_FLASH_ERR_WIP\t= -7,\t \n\tBFA_FLASH_ERR_TIMEOUT\t= -8,\t \n\tBFA_FLASH_ERR_LEN\t= -9,\t \n};\n\n \nunion bfa_flash_cmd_reg {\n\tstruct {\n#ifdef __BIG_ENDIAN\n\t\tu32\tact:1;\n\t\tu32\trsv:1;\n\t\tu32\twrite_cnt:9;\n\t\tu32\tread_cnt:9;\n\t\tu32\taddr_cnt:4;\n\t\tu32\tcmd:8;\n#else\n\t\tu32\tcmd:8;\n\t\tu32\taddr_cnt:4;\n\t\tu32\tread_cnt:9;\n\t\tu32\twrite_cnt:9;\n\t\tu32\trsv:1;\n\t\tu32\tact:1;\n#endif\n\t} r;\n\tu32\ti;\n};\n\n \nunion bfa_flash_dev_status_reg {\n\tstruct {\n#ifdef __BIG_ENDIAN\n\t\tu32\trsv:21;\n\t\tu32\tfifo_cnt:6;\n\t\tu32\tbusy:1;\n\t\tu32\tinit_status:1;\n\t\tu32\tpresent:1;\n\t\tu32\tbad:1;\n\t\tu32\tgood:1;\n#else\n\t\tu32\tgood:1;\n\t\tu32\tbad:1;\n\t\tu32\tpresent:1;\n\t\tu32\tinit_status:1;\n\t\tu32\tbusy:1;\n\t\tu32\tfifo_cnt:6;\n\t\tu32\trsv:21;\n#endif\n\t} r;\n\tu32\ti;\n};\n\n \nunion bfa_flash_addr_reg {\n\tstruct {\n#ifdef __BIG_ENDIAN\n\t\tu32\taddr:24;\n\t\tu32\tdummy:8;\n#else\n\t\tu32\tdummy:8;\n\t\tu32\taddr:24;\n#endif\n\t} r;\n\tu32\ti;\n};\n\n \nstatic void\nbfa_flash_set_cmd(void __iomem *pci_bar, u8 wr_cnt,\n\t\t  u8 rd_cnt, u8 ad_cnt, u8 op)\n{\n\tunion bfa_flash_cmd_reg cmd;\n\n\tcmd.i = 0;\n\tcmd.r.act = 1;\n\tcmd.r.write_cnt = wr_cnt;\n\tcmd.r.read_cnt = rd_cnt;\n\tcmd.r.addr_cnt = ad_cnt;\n\tcmd.r.cmd = op;\n\twritel(cmd.i, (pci_bar + FLI_CMD_REG));\n}\n\nstatic void\nbfa_flash_set_addr(void __iomem *pci_bar, u32 address)\n{\n\tunion bfa_flash_addr_reg addr;\n\n\taddr.r.addr = address & 0x00ffffff;\n\taddr.r.dummy = 0;\n\twritel(addr.i, (pci_bar + FLI_ADDR_REG));\n}\n\nstatic int\nbfa_flash_cmd_act_check(void __iomem *pci_bar)\n{\n\tunion bfa_flash_cmd_reg cmd;\n\n\tcmd.i = readl(pci_bar + FLI_CMD_REG);\n\n\tif (cmd.r.act)\n\t\treturn BFA_FLASH_ERR_CMD_ACT;\n\n\treturn 0;\n}\n\n \nstatic int\nbfa_flash_fifo_flush(void __iomem *pci_bar)\n{\n\tu32 i;\n\tunion bfa_flash_dev_status_reg dev_status;\n\n\tdev_status.i = readl(pci_bar + FLI_DEV_STATUS_REG);\n\n\tif (!dev_status.r.fifo_cnt)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < dev_status.r.fifo_cnt; i++)\n\t\treadl(pci_bar + FLI_RDDATA_REG);\n\n\t \n\tfor (i = 0; i < BFA_FLASH_CHECK_MAX; i++) {\n\t\tdev_status.i = readl(pci_bar + FLI_DEV_STATUS_REG);\n\t\tif (!dev_status.r.fifo_cnt)\n\t\t\tbreak;\n\t}\n\n\tif (dev_status.r.fifo_cnt)\n\t\treturn BFA_FLASH_ERR_FIFO_CNT;\n\n\treturn 0;\n}\n\n \nstatic int\nbfa_flash_status_read(void __iomem *pci_bar)\n{\n\tunion bfa_flash_dev_status_reg\tdev_status;\n\tint\t\t\t\tstatus;\n\tu32\t\t\tret_status;\n\tint\t\t\t\ti;\n\n\tstatus = bfa_flash_fifo_flush(pci_bar);\n\tif (status < 0)\n\t\treturn status;\n\n\tbfa_flash_set_cmd(pci_bar, 0, 4, 0, BFA_FLASH_READ_STATUS);\n\n\tfor (i = 0; i < BFA_FLASH_CHECK_MAX; i++) {\n\t\tstatus = bfa_flash_cmd_act_check(pci_bar);\n\t\tif (!status)\n\t\t\tbreak;\n\t}\n\n\tif (status)\n\t\treturn status;\n\n\tdev_status.i = readl(pci_bar + FLI_DEV_STATUS_REG);\n\tif (!dev_status.r.fifo_cnt)\n\t\treturn BFA_FLASH_BUSY;\n\n\tret_status = readl(pci_bar + FLI_RDDATA_REG);\n\tret_status >>= 24;\n\n\tstatus = bfa_flash_fifo_flush(pci_bar);\n\tif (status < 0)\n\t\treturn status;\n\n\treturn ret_status;\n}\n\n \nstatic int\nbfa_flash_read_start(void __iomem *pci_bar, u32 offset, u32 len,\n\t\t     char *buf)\n{\n\tint status;\n\n\t \n\tif (len == 0 || len > BFA_FLASH_FIFO_SIZE || (len & 0x03) != 0)\n\t\treturn BFA_FLASH_ERR_LEN;\n\n\t \n\tstatus = bfa_flash_status_read(pci_bar);\n\tif (status == BFA_FLASH_BUSY)\n\t\tstatus = bfa_flash_status_read(pci_bar);\n\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tif (status & BFA_FLASH_WIP_MASK)\n\t\treturn BFA_FLASH_ERR_WIP;\n\n\tbfa_flash_set_addr(pci_bar, offset);\n\n\tbfa_flash_set_cmd(pci_bar, 0, (u8)len, 4, BFA_FLASH_FAST_READ);\n\n\treturn 0;\n}\n\n \nstatic u32\nbfa_flash_read_check(void __iomem *pci_bar)\n{\n\tif (bfa_flash_cmd_act_check(pci_bar))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic void\nbfa_flash_read_end(void __iomem *pci_bar, u32 len, char *buf)\n{\n\tu32 i;\n\n\t \n\tfor (i = 0; i < len; i += 4) {\n\t\tu32 w = readl(pci_bar + FLI_RDDATA_REG);\n\t\t*((u32 *)(buf + i)) = swab32(w);\n\t}\n\n\tbfa_flash_fifo_flush(pci_bar);\n}\n\n \n\n#define FLASH_BLOCKING_OP_MAX   500\n#define FLASH_SEM_LOCK_REG\t0x18820\n\nstatic int\nbfa_raw_sem_get(void __iomem *bar)\n{\n\tint\tlocked;\n\n\tlocked = readl(bar + FLASH_SEM_LOCK_REG);\n\n\treturn !locked;\n}\n\nstatic enum bfa_status\nbfa_flash_sem_get(void __iomem *bar)\n{\n\tu32 n = FLASH_BLOCKING_OP_MAX;\n\n\twhile (!bfa_raw_sem_get(bar)) {\n\t\tif (--n <= 0)\n\t\t\treturn BFA_STATUS_BADFLASH;\n\t\tmdelay(10);\n\t}\n\treturn BFA_STATUS_OK;\n}\n\nstatic void\nbfa_flash_sem_put(void __iomem *bar)\n{\n\twritel(0, (bar + FLASH_SEM_LOCK_REG));\n}\n\nstatic enum bfa_status\nbfa_flash_raw_read(void __iomem *pci_bar, u32 offset, char *buf,\n\t\t   u32 len)\n{\n\tu32 n;\n\tint status;\n\tu32 off, l, s, residue, fifo_sz;\n\n\tresidue = len;\n\toff = 0;\n\tfifo_sz = BFA_FLASH_FIFO_SIZE;\n\tstatus = bfa_flash_sem_get(pci_bar);\n\tif (status != BFA_STATUS_OK)\n\t\treturn status;\n\n\twhile (residue) {\n\t\ts = offset + off;\n\t\tn = s / fifo_sz;\n\t\tl = (n + 1) * fifo_sz - s;\n\t\tif (l > residue)\n\t\t\tl = residue;\n\n\t\tstatus = bfa_flash_read_start(pci_bar, offset + off, l,\n\t\t\t\t\t\t\t\t&buf[off]);\n\t\tif (status < 0) {\n\t\t\tbfa_flash_sem_put(pci_bar);\n\t\t\treturn BFA_STATUS_FAILED;\n\t\t}\n\n\t\tn = BFA_FLASH_BLOCKING_OP_MAX;\n\t\twhile (bfa_flash_read_check(pci_bar)) {\n\t\t\tif (--n <= 0) {\n\t\t\t\tbfa_flash_sem_put(pci_bar);\n\t\t\t\treturn BFA_STATUS_FAILED;\n\t\t\t}\n\t\t}\n\n\t\tbfa_flash_read_end(pci_bar, l, &buf[off]);\n\n\t\tresidue -= l;\n\t\toff += l;\n\t}\n\tbfa_flash_sem_put(pci_bar);\n\n\treturn BFA_STATUS_OK;\n}\n\n#define BFA_FLASH_PART_FWIMG_ADDR\t0x100000  \n\nstatic enum bfa_status\nbfa_nw_ioc_flash_img_get_chnk(struct bfa_ioc *ioc, u32 off,\n\t\t\t      u32 *fwimg)\n{\n\treturn bfa_flash_raw_read(ioc->pcidev.pci_bar_kva,\n\t\t\tBFA_FLASH_PART_FWIMG_ADDR + (off * sizeof(u32)),\n\t\t\t(char *)fwimg, BFI_FLASH_CHUNK_SZ);\n}\n\nstatic enum bfi_ioc_img_ver_cmp\nbfa_ioc_flash_fwver_cmp(struct bfa_ioc *ioc,\n\t\t\tstruct bfi_ioc_image_hdr *base_fwhdr)\n{\n\tstruct bfi_ioc_image_hdr *flash_fwhdr;\n\tenum bfa_status status;\n\tu32 fwimg[BFI_FLASH_CHUNK_SZ_WORDS];\n\n\tstatus = bfa_nw_ioc_flash_img_get_chnk(ioc, 0, fwimg);\n\tif (status != BFA_STATUS_OK)\n\t\treturn BFI_IOC_IMG_VER_INCOMP;\n\n\tflash_fwhdr = (struct bfi_ioc_image_hdr *)fwimg;\n\tif (bfa_ioc_flash_fwver_valid(flash_fwhdr))\n\t\treturn bfa_ioc_fw_ver_patch_cmp(base_fwhdr, flash_fwhdr);\n\telse\n\t\treturn BFI_IOC_IMG_VER_INCOMP;\n}\n\n \nbool\nbfa_nw_ioc_fwver_cmp(struct bfa_ioc *ioc, struct bfi_ioc_image_hdr *fwhdr)\n{\n\tstruct bfi_ioc_image_hdr *drv_fwhdr;\n\tenum bfi_ioc_img_ver_cmp smem_flash_cmp, drv_smem_cmp;\n\n\tdrv_fwhdr = (struct bfi_ioc_image_hdr *)\n\t\tbfa_cb_image_get_chunk(bfa_ioc_asic_gen(ioc), 0);\n\n\t \n\tdrv_smem_cmp = bfa_ioc_fw_ver_patch_cmp(drv_fwhdr, fwhdr);\n\tif (drv_smem_cmp == BFI_IOC_IMG_VER_INCOMP ||\n\t    drv_smem_cmp == BFI_IOC_IMG_VER_OLD) {\n\t\treturn false;\n\t}\n\n\t \n\tsmem_flash_cmp = bfa_ioc_flash_fwver_cmp(ioc, fwhdr);\n\n\tif (smem_flash_cmp == BFI_IOC_IMG_VER_BETTER)\n\t\treturn false;\n\telse if (smem_flash_cmp == BFI_IOC_IMG_VER_SAME)\n\t\treturn true;\n\telse\n\t\treturn (drv_smem_cmp == BFI_IOC_IMG_VER_SAME) ?\n\t\t\ttrue : false;\n}\n\n \nstatic bool\nbfa_ioc_fwver_valid(struct bfa_ioc *ioc, u32 boot_env)\n{\n\tstruct bfi_ioc_image_hdr fwhdr;\n\n\tbfa_nw_ioc_fwver_get(ioc, &fwhdr);\n\tif (swab32(fwhdr.bootenv) != boot_env)\n\t\treturn false;\n\n\treturn bfa_nw_ioc_fwver_cmp(ioc, &fwhdr);\n}\n\n \nstatic void\nbfa_ioc_msgflush(struct bfa_ioc *ioc)\n{\n\tu32\tr32;\n\n\tr32 = readl(ioc->ioc_regs.lpu_mbox_cmd);\n\tif (r32)\n\t\twritel(1, ioc->ioc_regs.lpu_mbox_cmd);\n}\n\nstatic void\nbfa_ioc_hwinit(struct bfa_ioc *ioc, bool force)\n{\n\tenum bfi_ioc_state ioc_fwstate;\n\tbool fwvalid;\n\tu32 boot_env;\n\n\tioc_fwstate = bfa_ioc_get_cur_ioc_fwstate(ioc);\n\n\tif (force)\n\t\tioc_fwstate = BFI_IOC_UNINIT;\n\n\tboot_env = BFI_FWBOOT_ENV_OS;\n\n\t \n\tfwvalid = (ioc_fwstate == BFI_IOC_UNINIT) ?\n\t\tfalse : bfa_ioc_fwver_valid(ioc, boot_env);\n\n\tif (!fwvalid) {\n\t\tif (bfa_ioc_boot(ioc, BFI_FWBOOT_TYPE_NORMAL, boot_env) ==\n\t\t\t\t\t\t\t\tBFA_STATUS_OK)\n\t\t\tbfa_ioc_poll_fwinit(ioc);\n\n\t\treturn;\n\t}\n\n\t \n\tif (ioc_fwstate == BFI_IOC_INITING) {\n\t\tbfa_ioc_poll_fwinit(ioc);\n\t\treturn;\n\t}\n\n\t \n\tif (ioc_fwstate == BFI_IOC_DISABLED || ioc_fwstate == BFI_IOC_OP) {\n\t\t \n\t\tbfa_ioc_msgflush(ioc);\n\t\tbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_FWREADY);\n\t\treturn;\n\t}\n\n\t \n\tif (bfa_ioc_boot(ioc, BFI_FWBOOT_TYPE_NORMAL, boot_env) ==\n\t\t\t\t\t\t\tBFA_STATUS_OK)\n\t\tbfa_ioc_poll_fwinit(ioc);\n}\n\nvoid\nbfa_nw_ioc_timeout(struct bfa_ioc *ioc)\n{\n\tbfa_fsm_send_event(ioc, IOC_E_TIMEOUT);\n}\n\nstatic void\nbfa_ioc_mbox_send(struct bfa_ioc *ioc, void *ioc_msg, int len)\n{\n\tu32 *msgp = (u32 *) ioc_msg;\n\tu32 i;\n\n\tBUG_ON(!(len <= BFI_IOC_MSGLEN_MAX));\n\n\t \n\tfor (i = 0; i < len / sizeof(u32); i++)\n\t\twritel(cpu_to_le32(msgp[i]),\n\t\t\t      ioc->ioc_regs.hfn_mbox + i * sizeof(u32));\n\n\tfor (; i < BFI_IOC_MSGLEN_MAX / sizeof(u32); i++)\n\t\twritel(0, ioc->ioc_regs.hfn_mbox + i * sizeof(u32));\n\n\t \n\twritel(1, ioc->ioc_regs.hfn_mbox_cmd);\n\t(void) readl(ioc->ioc_regs.hfn_mbox_cmd);\n}\n\nstatic void\nbfa_ioc_send_enable(struct bfa_ioc *ioc)\n{\n\tstruct bfi_ioc_ctrl_req enable_req;\n\n\tbfi_h2i_set(enable_req.mh, BFI_MC_IOC, BFI_IOC_H2I_ENABLE_REQ,\n\t\t    bfa_ioc_portid(ioc));\n\tenable_req.clscode = htons(ioc->clscode);\n\tenable_req.rsvd = htons(0);\n\t \n\tenable_req.tv_sec = ntohl(ktime_get_real_seconds());\n\tbfa_ioc_mbox_send(ioc, &enable_req, sizeof(struct bfi_ioc_ctrl_req));\n}\n\nstatic void\nbfa_ioc_send_disable(struct bfa_ioc *ioc)\n{\n\tstruct bfi_ioc_ctrl_req disable_req;\n\n\tbfi_h2i_set(disable_req.mh, BFI_MC_IOC, BFI_IOC_H2I_DISABLE_REQ,\n\t\t    bfa_ioc_portid(ioc));\n\tdisable_req.clscode = htons(ioc->clscode);\n\tdisable_req.rsvd = htons(0);\n\t \n\tdisable_req.tv_sec = ntohl(ktime_get_real_seconds());\n\tbfa_ioc_mbox_send(ioc, &disable_req, sizeof(struct bfi_ioc_ctrl_req));\n}\n\nstatic void\nbfa_ioc_send_getattr(struct bfa_ioc *ioc)\n{\n\tstruct bfi_ioc_getattr_req attr_req;\n\n\tbfi_h2i_set(attr_req.mh, BFI_MC_IOC, BFI_IOC_H2I_GETATTR_REQ,\n\t\t    bfa_ioc_portid(ioc));\n\tbfa_dma_be_addr_set(attr_req.attr_addr, ioc->attr_dma.pa);\n\tbfa_ioc_mbox_send(ioc, &attr_req, sizeof(attr_req));\n}\n\nvoid\nbfa_nw_ioc_hb_check(struct bfa_ioc *ioc)\n{\n\tu32 hb_count;\n\n\thb_count = readl(ioc->ioc_regs.heartbeat);\n\tif (ioc->hb_count == hb_count) {\n\t\tbfa_ioc_recover(ioc);\n\t\treturn;\n\t} else {\n\t\tioc->hb_count = hb_count;\n\t}\n\n\tbfa_ioc_mbox_poll(ioc);\n\tmod_timer(&ioc->hb_timer, jiffies +\n\t\tmsecs_to_jiffies(BFA_IOC_HB_TOV));\n}\n\nstatic void\nbfa_ioc_hb_monitor(struct bfa_ioc *ioc)\n{\n\tioc->hb_count = readl(ioc->ioc_regs.heartbeat);\n\tmod_timer(&ioc->hb_timer, jiffies +\n\t\tmsecs_to_jiffies(BFA_IOC_HB_TOV));\n}\n\nstatic void\nbfa_ioc_hb_stop(struct bfa_ioc *ioc)\n{\n\tdel_timer(&ioc->hb_timer);\n}\n\n \nstatic enum bfa_status\nbfa_ioc_download_fw(struct bfa_ioc *ioc, u32 boot_type,\n\t\t    u32 boot_env)\n{\n\tu32 *fwimg;\n\tu32 pgnum;\n\tu32 loff = 0;\n\tu32 chunkno = 0;\n\tu32 i;\n\tu32 asicmode;\n\tu32 fwimg_size;\n\tu32 fwimg_buf[BFI_FLASH_CHUNK_SZ_WORDS];\n\tenum bfa_status status;\n\n\tif (boot_env == BFI_FWBOOT_ENV_OS &&\n\t    boot_type == BFI_FWBOOT_TYPE_FLASH) {\n\t\tfwimg_size = BFI_FLASH_IMAGE_SZ/sizeof(u32);\n\n\t\tstatus = bfa_nw_ioc_flash_img_get_chnk(ioc,\n\t\t\tBFA_IOC_FLASH_CHUNK_ADDR(chunkno), fwimg_buf);\n\t\tif (status != BFA_STATUS_OK)\n\t\t\treturn status;\n\n\t\tfwimg = fwimg_buf;\n\t} else {\n\t\tfwimg_size = bfa_cb_image_get_size(bfa_ioc_asic_gen(ioc));\n\t\tfwimg = bfa_cb_image_get_chunk(bfa_ioc_asic_gen(ioc),\n\t\t\t\t\tBFA_IOC_FLASH_CHUNK_ADDR(chunkno));\n\t}\n\n\tpgnum = bfa_ioc_smem_pgnum(ioc, loff);\n\n\twritel(pgnum, ioc->ioc_regs.host_page_num_fn);\n\n\tfor (i = 0; i < fwimg_size; i++) {\n\t\tif (BFA_IOC_FLASH_CHUNK_NO(i) != chunkno) {\n\t\t\tchunkno = BFA_IOC_FLASH_CHUNK_NO(i);\n\t\t\tif (boot_env == BFI_FWBOOT_ENV_OS &&\n\t\t\t    boot_type == BFI_FWBOOT_TYPE_FLASH) {\n\t\t\t\tstatus = bfa_nw_ioc_flash_img_get_chnk(ioc,\n\t\t\t\t\tBFA_IOC_FLASH_CHUNK_ADDR(chunkno),\n\t\t\t\t\tfwimg_buf);\n\t\t\t\tif (status != BFA_STATUS_OK)\n\t\t\t\t\treturn status;\n\n\t\t\t\tfwimg = fwimg_buf;\n\t\t\t} else {\n\t\t\t\tfwimg = bfa_cb_image_get_chunk(\n\t\t\t\t\tbfa_ioc_asic_gen(ioc),\n\t\t\t\t\tBFA_IOC_FLASH_CHUNK_ADDR(chunkno));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twritel(swab32(fwimg[BFA_IOC_FLASH_OFFSET_IN_CHUNK(i)]),\n\t\t       ioc->ioc_regs.smem_page_start + loff);\n\n\t\tloff += sizeof(u32);\n\n\t\t \n\t\tloff = PSS_SMEM_PGOFF(loff);\n\t\tif (loff == 0) {\n\t\t\tpgnum++;\n\t\t\twritel(pgnum,\n\t\t\t\t      ioc->ioc_regs.host_page_num_fn);\n\t\t}\n\t}\n\n\twritel(bfa_ioc_smem_pgnum(ioc, 0),\n\t\t      ioc->ioc_regs.host_page_num_fn);\n\n\t \n\tif (boot_env == BFI_FWBOOT_ENV_OS &&\n\t    boot_type == BFI_FWBOOT_TYPE_FLASH) {\n\t\tboot_type = BFI_FWBOOT_TYPE_NORMAL;\n\t}\n\tasicmode = BFI_FWBOOT_DEVMODE(ioc->asic_gen, ioc->asic_mode,\n\t\t\t\t\tioc->port0_mode, ioc->port1_mode);\n\twritel(asicmode, ((ioc->ioc_regs.smem_page_start)\n\t\t\t+ BFI_FWBOOT_DEVMODE_OFF));\n\twritel(boot_type, ((ioc->ioc_regs.smem_page_start)\n\t\t\t+ (BFI_FWBOOT_TYPE_OFF)));\n\twritel(boot_env, ((ioc->ioc_regs.smem_page_start)\n\t\t\t+ (BFI_FWBOOT_ENV_OFF)));\n\treturn BFA_STATUS_OK;\n}\n\nstatic void\nbfa_ioc_reset(struct bfa_ioc *ioc, bool force)\n{\n\tbfa_ioc_hwinit(ioc, force);\n}\n\n \nstatic void\nbfa_ioc_enable_reply(struct bfa_ioc *ioc, enum bfa_mode port_mode,\n\t\t\tu8 cap_bm)\n{\n\tstruct bfa_iocpf *iocpf = &ioc->iocpf;\n\n\tioc->port_mode = ioc->port_mode_cfg = port_mode;\n\tioc->ad_cap_bm = cap_bm;\n\tbfa_fsm_send_event(iocpf, IOCPF_E_FWRSP_ENABLE);\n}\n\n \nstatic void\nbfa_ioc_getattr_reply(struct bfa_ioc *ioc)\n{\n\tstruct bfi_ioc_attr *attr = ioc->attr;\n\n\tattr->adapter_prop  = ntohl(attr->adapter_prop);\n\tattr->card_type     = ntohl(attr->card_type);\n\tattr->maxfrsize\t    = ntohs(attr->maxfrsize);\n\n\tbfa_fsm_send_event(ioc, IOC_E_FWRSP_GETATTR);\n}\n\n \nstatic void\nbfa_ioc_mbox_attach(struct bfa_ioc *ioc)\n{\n\tstruct bfa_ioc_mbox_mod *mod = &ioc->mbox_mod;\n\tint\tmc;\n\n\tINIT_LIST_HEAD(&mod->cmd_q);\n\tfor (mc = 0; mc < BFI_MC_MAX; mc++) {\n\t\tmod->mbhdlr[mc].cbfn = NULL;\n\t\tmod->mbhdlr[mc].cbarg = ioc->bfa;\n\t}\n}\n\n \nstatic void\nbfa_ioc_mbox_poll(struct bfa_ioc *ioc)\n{\n\tstruct bfa_ioc_mbox_mod *mod = &ioc->mbox_mod;\n\tstruct bfa_mbox_cmd *cmd;\n\tbfa_mbox_cmd_cbfn_t cbfn;\n\tvoid *cbarg;\n\tu32 stat;\n\n\t \n\tif (list_empty(&mod->cmd_q))\n\t\treturn;\n\n\t \n\tstat = readl(ioc->ioc_regs.hfn_mbox_cmd);\n\tif (stat)\n\t\treturn;\n\n\t \n\tcmd = list_first_entry(&mod->cmd_q, struct bfa_mbox_cmd, qe);\n\tlist_del(&cmd->qe);\n\tbfa_ioc_mbox_send(ioc, cmd->msg, sizeof(cmd->msg));\n\n\t \n\tif (cmd->cbfn) {\n\t\tcbfn = cmd->cbfn;\n\t\tcbarg = cmd->cbarg;\n\t\tcmd->cbfn = NULL;\n\t\tcbfn(cbarg);\n\t}\n}\n\n \nstatic void\nbfa_ioc_mbox_flush(struct bfa_ioc *ioc)\n{\n\tstruct bfa_ioc_mbox_mod *mod = &ioc->mbox_mod;\n\tstruct bfa_mbox_cmd *cmd;\n\n\twhile (!list_empty(&mod->cmd_q)) {\n\t\tcmd = list_first_entry(&mod->cmd_q, struct bfa_mbox_cmd, qe);\n\t\tlist_del(&cmd->qe);\n\t}\n}\n\n \nstatic int\nbfa_nw_ioc_smem_read(struct bfa_ioc *ioc, void *tbuf, u32 soff, u32 sz)\n{\n\tu32 pgnum, loff, r32;\n\tint i, len;\n\tu32 *buf = tbuf;\n\n\tpgnum = PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, soff);\n\tloff = PSS_SMEM_PGOFF(soff);\n\n\t \n\tif (!bfa_nw_ioc_sem_get(ioc->ioc_regs.ioc_init_sem_reg))\n\t\treturn 1;\n\n\twritel(pgnum, ioc->ioc_regs.host_page_num_fn);\n\n\tlen = sz/sizeof(u32);\n\tfor (i = 0; i < len; i++) {\n\t\tr32 = swab32(readl(loff + ioc->ioc_regs.smem_page_start));\n\t\tbuf[i] = be32_to_cpu(r32);\n\t\tloff += sizeof(u32);\n\n\t\t \n\t\tloff = PSS_SMEM_PGOFF(loff);\n\t\tif (loff == 0) {\n\t\t\tpgnum++;\n\t\t\twritel(pgnum, ioc->ioc_regs.host_page_num_fn);\n\t\t}\n\t}\n\n\twritel(PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, 0),\n\t       ioc->ioc_regs.host_page_num_fn);\n\n\t \n\treadl(ioc->ioc_regs.ioc_init_sem_reg);\n\twritel(1, ioc->ioc_regs.ioc_init_sem_reg);\n\treturn 0;\n}\n\n \nint\nbfa_nw_ioc_debug_fwtrc(struct bfa_ioc *ioc, void *trcdata, int *trclen)\n{\n\tu32 loff = BFI_IOC_TRC_OFF + BNA_DBG_FWTRC_LEN * ioc->port_id;\n\tint tlen, status = 0;\n\n\ttlen = *trclen;\n\tif (tlen > BNA_DBG_FWTRC_LEN)\n\t\ttlen = BNA_DBG_FWTRC_LEN;\n\n\tstatus = bfa_nw_ioc_smem_read(ioc, trcdata, loff, tlen);\n\t*trclen = tlen;\n\treturn status;\n}\n\n \nstatic void\nbfa_nw_ioc_debug_save_ftrc(struct bfa_ioc *ioc)\n{\n\tint tlen;\n\n\tif (ioc->dbg_fwsave_once) {\n\t\tioc->dbg_fwsave_once = false;\n\t\tif (ioc->dbg_fwsave_len) {\n\t\t\ttlen = ioc->dbg_fwsave_len;\n\t\t\tbfa_nw_ioc_debug_fwtrc(ioc, ioc->dbg_fwsave, &tlen);\n\t\t}\n\t}\n}\n\n \nint\nbfa_nw_ioc_debug_fwsave(struct bfa_ioc *ioc, void *trcdata, int *trclen)\n{\n\tint tlen;\n\n\tif (ioc->dbg_fwsave_len == 0)\n\t\treturn BFA_STATUS_ENOFSAVE;\n\n\ttlen = *trclen;\n\tif (tlen > ioc->dbg_fwsave_len)\n\t\ttlen = ioc->dbg_fwsave_len;\n\n\tmemcpy(trcdata, ioc->dbg_fwsave, tlen);\n\t*trclen = tlen;\n\treturn BFA_STATUS_OK;\n}\n\nstatic void\nbfa_ioc_fail_notify(struct bfa_ioc *ioc)\n{\n\t \n\tioc->cbfn->hbfail_cbfn(ioc->bfa);\n\tbfa_ioc_event_notify(ioc, BFA_IOC_E_FAILED);\n\tbfa_nw_ioc_debug_save_ftrc(ioc);\n}\n\n \nstatic void\nbfa_ioc_pf_enabled(struct bfa_ioc *ioc)\n{\n\tbfa_fsm_send_event(ioc, IOC_E_ENABLED);\n}\n\nstatic void\nbfa_ioc_pf_disabled(struct bfa_ioc *ioc)\n{\n\tbfa_fsm_send_event(ioc, IOC_E_DISABLED);\n}\n\nstatic void\nbfa_ioc_pf_failed(struct bfa_ioc *ioc)\n{\n\tbfa_fsm_send_event(ioc, IOC_E_PFFAILED);\n}\n\nstatic void\nbfa_ioc_pf_hwfailed(struct bfa_ioc *ioc)\n{\n\tbfa_fsm_send_event(ioc, IOC_E_HWFAILED);\n}\n\nstatic void\nbfa_ioc_pf_fwmismatch(struct bfa_ioc *ioc)\n{\n\t \n\tioc->cbfn->enable_cbfn(ioc->bfa, BFA_STATUS_IOC_FAILURE);\n}\n\n \nstatic enum bfa_status\nbfa_ioc_pll_init(struct bfa_ioc *ioc)\n{\n\t \n\tbfa_nw_ioc_sem_get(ioc->ioc_regs.ioc_init_sem_reg);\n\n\tbfa_ioc_pll_init_asic(ioc);\n\n\tioc->pllinit = true;\n\n\t \n\tbfa_ioc_lmem_init(ioc);\n\n\t \n\tbfa_nw_ioc_sem_release(ioc->ioc_regs.ioc_init_sem_reg);\n\n\treturn BFA_STATUS_OK;\n}\n\n \nstatic enum bfa_status\nbfa_ioc_boot(struct bfa_ioc *ioc, enum bfi_fwboot_type boot_type,\n\t\tu32 boot_env)\n{\n\tstruct bfi_ioc_image_hdr *drv_fwhdr;\n\tenum bfa_status status;\n\tbfa_ioc_stats(ioc, ioc_boots);\n\n\tif (bfa_ioc_pll_init(ioc) != BFA_STATUS_OK)\n\t\treturn BFA_STATUS_FAILED;\n\tif (boot_env == BFI_FWBOOT_ENV_OS &&\n\t    boot_type == BFI_FWBOOT_TYPE_NORMAL) {\n\t\tdrv_fwhdr = (struct bfi_ioc_image_hdr *)\n\t\t\tbfa_cb_image_get_chunk(bfa_ioc_asic_gen(ioc), 0);\n\t\t \n\t\tif (bfa_ioc_flash_fwver_cmp(ioc, drv_fwhdr) ==\n\t\t\tBFI_IOC_IMG_VER_BETTER)\n\t\t\tboot_type = BFI_FWBOOT_TYPE_FLASH;\n\t}\n\n\t \n\tif (boot_type == BFI_FWBOOT_TYPE_MEMTEST) {\n\t\tbfa_ioc_set_cur_ioc_fwstate(ioc, BFI_IOC_MEMTEST);\n\t\tbfa_ioc_set_alt_ioc_fwstate(ioc, BFI_IOC_MEMTEST);\n\t} else {\n\t\tbfa_ioc_set_cur_ioc_fwstate(ioc, BFI_IOC_INITING);\n\t\tbfa_ioc_set_alt_ioc_fwstate(ioc, BFI_IOC_INITING);\n\t}\n\n\tbfa_ioc_msgflush(ioc);\n\tstatus = bfa_ioc_download_fw(ioc, boot_type, boot_env);\n\tif (status == BFA_STATUS_OK)\n\t\tbfa_ioc_lpu_start(ioc);\n\telse\n\t\tbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_TIMEOUT);\n\n\treturn status;\n}\n\n \nvoid\nbfa_nw_ioc_auto_recover(bool auto_recover)\n{\n\tbfa_nw_auto_recover = auto_recover;\n}\n\nstatic bool\nbfa_ioc_msgget(struct bfa_ioc *ioc, void *mbmsg)\n{\n\tu32\t*msgp = mbmsg;\n\tu32\tr32;\n\tint\t\ti;\n\n\tr32 = readl(ioc->ioc_regs.lpu_mbox_cmd);\n\tif ((r32 & 1) == 0)\n\t\treturn false;\n\n\t \n\tfor (i = 0; i < (sizeof(union bfi_ioc_i2h_msg_u) / sizeof(u32));\n\t     i++) {\n\t\tr32 = readl(ioc->ioc_regs.lpu_mbox +\n\t\t\t\t   i * sizeof(u32));\n\t\tmsgp[i] = htonl(r32);\n\t}\n\n\t \n\twritel(1, ioc->ioc_regs.lpu_mbox_cmd);\n\treadl(ioc->ioc_regs.lpu_mbox_cmd);\n\n\treturn true;\n}\n\nstatic void\nbfa_ioc_isr(struct bfa_ioc *ioc, struct bfi_mbmsg *m)\n{\n\tunion bfi_ioc_i2h_msg_u\t*msg;\n\tstruct bfa_iocpf *iocpf = &ioc->iocpf;\n\n\tmsg = (union bfi_ioc_i2h_msg_u *) m;\n\n\tbfa_ioc_stats(ioc, ioc_isrs);\n\n\tswitch (msg->mh.msg_id) {\n\tcase BFI_IOC_I2H_HBEAT:\n\t\tbreak;\n\n\tcase BFI_IOC_I2H_ENABLE_REPLY:\n\t\tbfa_ioc_enable_reply(ioc,\n\t\t\t(enum bfa_mode)msg->fw_event.port_mode,\n\t\t\tmsg->fw_event.cap_bm);\n\t\tbreak;\n\n\tcase BFI_IOC_I2H_DISABLE_REPLY:\n\t\tbfa_fsm_send_event(iocpf, IOCPF_E_FWRSP_DISABLE);\n\t\tbreak;\n\n\tcase BFI_IOC_I2H_GETATTR_REPLY:\n\t\tbfa_ioc_getattr_reply(ioc);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG_ON(1);\n\t}\n}\n\n \nvoid\nbfa_nw_ioc_attach(struct bfa_ioc *ioc, void *bfa, struct bfa_ioc_cbfn *cbfn)\n{\n\tioc->bfa\t= bfa;\n\tioc->cbfn\t= cbfn;\n\tioc->fcmode\t= false;\n\tioc->pllinit\t= false;\n\tioc->dbg_fwsave_once = true;\n\tioc->iocpf.ioc  = ioc;\n\n\tbfa_ioc_mbox_attach(ioc);\n\tINIT_LIST_HEAD(&ioc->notify_q);\n\n\tbfa_fsm_set_state(ioc, bfa_ioc_sm_uninit);\n\tbfa_fsm_send_event(ioc, IOC_E_RESET);\n}\n\n \nvoid\nbfa_nw_ioc_detach(struct bfa_ioc *ioc)\n{\n\tbfa_fsm_send_event(ioc, IOC_E_DETACH);\n\n\t \n\tINIT_LIST_HEAD(&ioc->notify_q);\n}\n\n \nvoid\nbfa_nw_ioc_pci_init(struct bfa_ioc *ioc, struct bfa_pcidev *pcidev,\n\t\t enum bfi_pcifn_class clscode)\n{\n\tioc->clscode\t= clscode;\n\tioc->pcidev\t= *pcidev;\n\n\t \n\tioc->port0_mode = ioc->port1_mode = BFI_PORT_MODE_FC;\n\tioc->asic_mode  = BFI_ASIC_MODE_FC;\n\n\tswitch (pcidev->device_id) {\n\tcase PCI_DEVICE_ID_BROCADE_CT:\n\t\tioc->asic_gen = BFI_ASIC_GEN_CT;\n\t\tioc->port0_mode = ioc->port1_mode = BFI_PORT_MODE_ETH;\n\t\tioc->asic_mode  = BFI_ASIC_MODE_ETH;\n\t\tioc->port_mode = ioc->port_mode_cfg = BFA_MODE_CNA;\n\t\tioc->ad_cap_bm = BFA_CM_CNA;\n\t\tbreak;\n\n\tcase BFA_PCI_DEVICE_ID_CT2:\n\t\tioc->asic_gen = BFI_ASIC_GEN_CT2;\n\t\tif (clscode == BFI_PCIFN_CLASS_FC &&\n\t\t\tpcidev->ssid == BFA_PCI_CT2_SSID_FC) {\n\t\t\tioc->asic_mode  = BFI_ASIC_MODE_FC16;\n\t\t\tioc->fcmode = true;\n\t\t\tioc->port_mode = ioc->port_mode_cfg = BFA_MODE_HBA;\n\t\t\tioc->ad_cap_bm = BFA_CM_HBA;\n\t\t} else {\n\t\t\tioc->port0_mode = ioc->port1_mode = BFI_PORT_MODE_ETH;\n\t\t\tioc->asic_mode  = BFI_ASIC_MODE_ETH;\n\t\t\tif (pcidev->ssid == BFA_PCI_CT2_SSID_FCoE) {\n\t\t\t\tioc->port_mode =\n\t\t\t\tioc->port_mode_cfg = BFA_MODE_CNA;\n\t\t\t\tioc->ad_cap_bm = BFA_CM_CNA;\n\t\t\t} else {\n\t\t\t\tioc->port_mode =\n\t\t\t\tioc->port_mode_cfg = BFA_MODE_NIC;\n\t\t\t\tioc->ad_cap_bm = BFA_CM_NIC;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tBUG_ON(1);\n\t}\n\n\t \n\tif (ioc->asic_gen == BFI_ASIC_GEN_CT)\n\t\tbfa_nw_ioc_set_ct_hwif(ioc);\n\telse {\n\t\tWARN_ON(ioc->asic_gen != BFI_ASIC_GEN_CT2);\n\t\tbfa_nw_ioc_set_ct2_hwif(ioc);\n\t\tbfa_nw_ioc_ct2_poweron(ioc);\n\t}\n\n\tbfa_ioc_map_port(ioc);\n\tbfa_ioc_reg_init(ioc);\n}\n\n \nvoid\nbfa_nw_ioc_mem_claim(struct bfa_ioc *ioc,  u8 *dm_kva, u64 dm_pa)\n{\n\t \n\tioc->attr_dma.kva = dm_kva;\n\tioc->attr_dma.pa = dm_pa;\n\tioc->attr = (struct bfi_ioc_attr *) dm_kva;\n}\n\n \nu32\nbfa_nw_ioc_meminfo(void)\n{\n\treturn roundup(sizeof(struct bfi_ioc_attr), BFA_DMA_ALIGN_SZ);\n}\n\nvoid\nbfa_nw_ioc_enable(struct bfa_ioc *ioc)\n{\n\tbfa_ioc_stats(ioc, ioc_enables);\n\tioc->dbg_fwsave_once = true;\n\n\tbfa_fsm_send_event(ioc, IOC_E_ENABLE);\n}\n\nvoid\nbfa_nw_ioc_disable(struct bfa_ioc *ioc)\n{\n\tbfa_ioc_stats(ioc, ioc_disables);\n\tbfa_fsm_send_event(ioc, IOC_E_DISABLE);\n}\n\n \nvoid\nbfa_nw_ioc_debug_memclaim(struct bfa_ioc *ioc, void *dbg_fwsave)\n{\n\tioc->dbg_fwsave = dbg_fwsave;\n\tioc->dbg_fwsave_len = ioc->iocpf.auto_recover ? BNA_DBG_FWTRC_LEN : 0;\n}\n\nstatic u32\nbfa_ioc_smem_pgnum(struct bfa_ioc *ioc, u32 fmaddr)\n{\n\treturn PSS_SMEM_PGNUM(ioc->ioc_regs.smem_pg0, fmaddr);\n}\n\n \nvoid\nbfa_nw_ioc_mbox_regisr(struct bfa_ioc *ioc, enum bfi_mclass mc,\n\t\t    bfa_ioc_mbox_mcfunc_t cbfn, void *cbarg)\n{\n\tstruct bfa_ioc_mbox_mod *mod = &ioc->mbox_mod;\n\n\tmod->mbhdlr[mc].cbfn\t= cbfn;\n\tmod->mbhdlr[mc].cbarg = cbarg;\n}\n\n \nbool\nbfa_nw_ioc_mbox_queue(struct bfa_ioc *ioc, struct bfa_mbox_cmd *cmd,\n\t\t\tbfa_mbox_cmd_cbfn_t cbfn, void *cbarg)\n{\n\tstruct bfa_ioc_mbox_mod *mod = &ioc->mbox_mod;\n\tu32\t\t\tstat;\n\n\tcmd->cbfn = cbfn;\n\tcmd->cbarg = cbarg;\n\n\t \n\tif (!list_empty(&mod->cmd_q)) {\n\t\tlist_add_tail(&cmd->qe, &mod->cmd_q);\n\t\treturn true;\n\t}\n\n\t \n\tstat = readl(ioc->ioc_regs.hfn_mbox_cmd);\n\tif (stat) {\n\t\tlist_add_tail(&cmd->qe, &mod->cmd_q);\n\t\treturn true;\n\t}\n\n\t \n\tbfa_ioc_mbox_send(ioc, cmd->msg, sizeof(cmd->msg));\n\n\treturn false;\n}\n\n \nvoid\nbfa_nw_ioc_mbox_isr(struct bfa_ioc *ioc)\n{\n\tstruct bfa_ioc_mbox_mod *mod = &ioc->mbox_mod;\n\tstruct bfi_mbmsg m;\n\tint\t\t\t\tmc;\n\n\tif (bfa_ioc_msgget(ioc, &m)) {\n\t\t \n\t\tmc = m.mh.msg_class;\n\t\tif (mc == BFI_MC_IOC) {\n\t\t\tbfa_ioc_isr(ioc, &m);\n\t\t\treturn;\n\t\t}\n\n\t\tif ((mc >= BFI_MC_MAX) || (mod->mbhdlr[mc].cbfn == NULL))\n\t\t\treturn;\n\n\t\tmod->mbhdlr[mc].cbfn(mod->mbhdlr[mc].cbarg, &m);\n\t}\n\n\tbfa_ioc_lpu_read_stat(ioc);\n\n\t \n\tbfa_ioc_mbox_poll(ioc);\n}\n\nvoid\nbfa_nw_ioc_error_isr(struct bfa_ioc *ioc)\n{\n\tbfa_ioc_stats(ioc, ioc_hbfails);\n\tbfa_ioc_stats_hb_count(ioc, ioc->hb_count);\n\tbfa_fsm_send_event(ioc, IOC_E_HWERROR);\n}\n\n \nbool\nbfa_nw_ioc_is_disabled(struct bfa_ioc *ioc)\n{\n\treturn bfa_fsm_cmp_state(ioc, bfa_ioc_sm_disabling) ||\n\t\tbfa_fsm_cmp_state(ioc, bfa_ioc_sm_disabled);\n}\n\n \nbool\nbfa_nw_ioc_is_operational(struct bfa_ioc *ioc)\n{\n\treturn bfa_fsm_cmp_state(ioc, bfa_ioc_sm_op);\n}\n\n \nvoid\nbfa_nw_ioc_notify_register(struct bfa_ioc *ioc,\n\t\t\tstruct bfa_ioc_notify *notify)\n{\n\tlist_add_tail(&notify->qe, &ioc->notify_q);\n}\n\n#define BFA_MFG_NAME \"QLogic\"\nstatic void\nbfa_ioc_get_adapter_attr(struct bfa_ioc *ioc,\n\t\t\t struct bfa_adapter_attr *ad_attr)\n{\n\tstruct bfi_ioc_attr *ioc_attr;\n\n\tioc_attr = ioc->attr;\n\n\tbfa_ioc_get_adapter_serial_num(ioc, ad_attr->serial_num);\n\tbfa_ioc_get_adapter_fw_ver(ioc, ad_attr->fw_ver);\n\tbfa_ioc_get_adapter_optrom_ver(ioc, ad_attr->optrom_ver);\n\tbfa_ioc_get_adapter_manufacturer(ioc, ad_attr->manufacturer);\n\tmemcpy(&ad_attr->vpd, &ioc_attr->vpd,\n\t\t      sizeof(struct bfa_mfg_vpd));\n\n\tad_attr->nports = bfa_ioc_get_nports(ioc);\n\tad_attr->max_speed = bfa_ioc_speed_sup(ioc);\n\n\tbfa_ioc_get_adapter_model(ioc, ad_attr->model);\n\t \n\tbfa_ioc_get_adapter_model(ioc, ad_attr->model_descr);\n\n\tad_attr->card_type = ioc_attr->card_type;\n\tad_attr->is_mezz = bfa_mfg_is_mezz(ioc_attr->card_type);\n\n\tif (BFI_ADAPTER_IS_SPECIAL(ioc_attr->adapter_prop))\n\t\tad_attr->prototype = 1;\n\telse\n\t\tad_attr->prototype = 0;\n\n\tad_attr->pwwn = bfa_ioc_get_pwwn(ioc);\n\tbfa_nw_ioc_get_mac(ioc, ad_attr->mac);\n\n\tad_attr->pcie_gen = ioc_attr->pcie_gen;\n\tad_attr->pcie_lanes = ioc_attr->pcie_lanes;\n\tad_attr->pcie_lanes_orig = ioc_attr->pcie_lanes_orig;\n\tad_attr->asic_rev = ioc_attr->asic_rev;\n\n\tbfa_ioc_get_pci_chip_rev(ioc, ad_attr->hw_ver);\n}\n\nstatic enum bfa_ioc_type\nbfa_ioc_get_type(struct bfa_ioc *ioc)\n{\n\tif (ioc->clscode == BFI_PCIFN_CLASS_ETH)\n\t\treturn BFA_IOC_TYPE_LL;\n\n\tBUG_ON(!(ioc->clscode == BFI_PCIFN_CLASS_FC));\n\n\treturn (ioc->attr->port_mode == BFI_PORT_MODE_FC)\n\t\t? BFA_IOC_TYPE_FC : BFA_IOC_TYPE_FCoE;\n}\n\nstatic void\nbfa_ioc_get_adapter_serial_num(struct bfa_ioc *ioc, char *serial_num)\n{\n\tmemcpy(serial_num,\n\t\t\t(void *)ioc->attr->brcd_serialnum,\n\t\t\tBFA_ADAPTER_SERIAL_NUM_LEN);\n}\n\nstatic void\nbfa_ioc_get_adapter_fw_ver(struct bfa_ioc *ioc, char *fw_ver)\n{\n\tmemcpy(fw_ver, ioc->attr->fw_version, BFA_VERSION_LEN);\n}\n\nstatic void\nbfa_ioc_get_pci_chip_rev(struct bfa_ioc *ioc, char *chip_rev)\n{\n\tBUG_ON(!(chip_rev));\n\n\tmemset(chip_rev, 0, BFA_IOC_CHIP_REV_LEN);\n\n\tchip_rev[0] = 'R';\n\tchip_rev[1] = 'e';\n\tchip_rev[2] = 'v';\n\tchip_rev[3] = '-';\n\tchip_rev[4] = ioc->attr->asic_rev;\n\tchip_rev[5] = '\\0';\n}\n\nstatic void\nbfa_ioc_get_adapter_optrom_ver(struct bfa_ioc *ioc, char *optrom_ver)\n{\n\tmemcpy(optrom_ver, ioc->attr->optrom_version,\n\t\t      BFA_VERSION_LEN);\n}\n\nstatic void\nbfa_ioc_get_adapter_manufacturer(struct bfa_ioc *ioc, char *manufacturer)\n{\n\tstrncpy(manufacturer, BFA_MFG_NAME, BFA_ADAPTER_MFG_NAME_LEN);\n}\n\nstatic void\nbfa_ioc_get_adapter_model(struct bfa_ioc *ioc, char *model)\n{\n\tstruct bfi_ioc_attr *ioc_attr;\n\n\tBUG_ON(!(model));\n\tmemset(model, 0, BFA_ADAPTER_MODEL_NAME_LEN);\n\n\tioc_attr = ioc->attr;\n\n\tsnprintf(model, BFA_ADAPTER_MODEL_NAME_LEN, \"%s-%u\",\n\t\tBFA_MFG_NAME, ioc_attr->card_type);\n}\n\nstatic enum bfa_ioc_state\nbfa_ioc_get_state(struct bfa_ioc *ioc)\n{\n\tenum bfa_iocpf_state iocpf_st;\n\tenum bfa_ioc_state ioc_st = ioc_sm_to_state(ioc_sm_table, ioc->fsm);\n\n\tif (ioc_st == BFA_IOC_ENABLING ||\n\t\tioc_st == BFA_IOC_FAIL || ioc_st == BFA_IOC_INITFAIL) {\n\n\t\tiocpf_st = iocpf_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);\n\n\t\tswitch (iocpf_st) {\n\t\tcase BFA_IOCPF_SEMWAIT:\n\t\t\tioc_st = BFA_IOC_SEMWAIT;\n\t\t\tbreak;\n\n\t\tcase BFA_IOCPF_HWINIT:\n\t\t\tioc_st = BFA_IOC_HWINIT;\n\t\t\tbreak;\n\n\t\tcase BFA_IOCPF_FWMISMATCH:\n\t\t\tioc_st = BFA_IOC_FWMISMATCH;\n\t\t\tbreak;\n\n\t\tcase BFA_IOCPF_FAIL:\n\t\t\tioc_st = BFA_IOC_FAIL;\n\t\t\tbreak;\n\n\t\tcase BFA_IOCPF_INITFAIL:\n\t\t\tioc_st = BFA_IOC_INITFAIL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ioc_st;\n}\n\nvoid\nbfa_nw_ioc_get_attr(struct bfa_ioc *ioc, struct bfa_ioc_attr *ioc_attr)\n{\n\tmemset((void *)ioc_attr, 0, sizeof(struct bfa_ioc_attr));\n\n\tioc_attr->state = bfa_ioc_get_state(ioc);\n\tioc_attr->port_id = bfa_ioc_portid(ioc);\n\tioc_attr->port_mode = ioc->port_mode;\n\n\tioc_attr->port_mode_cfg = ioc->port_mode_cfg;\n\tioc_attr->cap_bm = ioc->ad_cap_bm;\n\n\tioc_attr->ioc_type = bfa_ioc_get_type(ioc);\n\n\tbfa_ioc_get_adapter_attr(ioc, &ioc_attr->adapter_attr);\n\n\tioc_attr->pci_attr.device_id = bfa_ioc_devid(ioc);\n\tioc_attr->pci_attr.pcifn = bfa_ioc_pcifn(ioc);\n\tioc_attr->def_fn = bfa_ioc_is_default(ioc);\n\tbfa_ioc_get_pci_chip_rev(ioc, ioc_attr->pci_attr.chip_rev);\n}\n\n \nstatic u64\nbfa_ioc_get_pwwn(struct bfa_ioc *ioc)\n{\n\treturn ioc->attr->pwwn;\n}\n\nvoid\nbfa_nw_ioc_get_mac(struct bfa_ioc *ioc, u8 *mac)\n{\n\tether_addr_copy(mac, ioc->attr->mac);\n}\n\n \nstatic void\nbfa_ioc_recover(struct bfa_ioc *ioc)\n{\n\tpr_crit(\"Heart Beat of IOC has failed\\n\");\n\tbfa_ioc_stats(ioc, ioc_hbfails);\n\tbfa_ioc_stats_hb_count(ioc, ioc->hb_count);\n\tbfa_fsm_send_event(ioc, IOC_E_HBFAIL);\n}\n\n \n\nstatic void\nbfa_iocpf_enable(struct bfa_ioc *ioc)\n{\n\tbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_ENABLE);\n}\n\nstatic void\nbfa_iocpf_disable(struct bfa_ioc *ioc)\n{\n\tbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_DISABLE);\n}\n\nstatic void\nbfa_iocpf_fail(struct bfa_ioc *ioc)\n{\n\tbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_FAIL);\n}\n\nstatic void\nbfa_iocpf_initfail(struct bfa_ioc *ioc)\n{\n\tbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_INITFAIL);\n}\n\nstatic void\nbfa_iocpf_getattrfail(struct bfa_ioc *ioc)\n{\n\tbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_GETATTRFAIL);\n}\n\nstatic void\nbfa_iocpf_stop(struct bfa_ioc *ioc)\n{\n\tbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_STOP);\n}\n\nvoid\nbfa_nw_iocpf_timeout(struct bfa_ioc *ioc)\n{\n\tenum bfa_iocpf_state iocpf_st;\n\n\tiocpf_st = iocpf_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);\n\n\tif (iocpf_st == BFA_IOCPF_HWINIT)\n\t\tbfa_ioc_poll_fwinit(ioc);\n\telse\n\t\tbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_TIMEOUT);\n}\n\nvoid\nbfa_nw_iocpf_sem_timeout(struct bfa_ioc *ioc)\n{\n\tbfa_ioc_hw_sem_get(ioc);\n}\n\nstatic void\nbfa_ioc_poll_fwinit(struct bfa_ioc *ioc)\n{\n\tu32 fwstate = bfa_ioc_get_cur_ioc_fwstate(ioc);\n\n\tif (fwstate == BFI_IOC_DISABLED) {\n\t\tbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_FWREADY);\n\t\treturn;\n\t}\n\n\tif (ioc->iocpf.poll_time >= BFA_IOC_TOV) {\n\t\tbfa_fsm_send_event(&ioc->iocpf, IOCPF_E_TIMEOUT);\n\t} else {\n\t\tioc->iocpf.poll_time += BFA_IOC_POLL_TOV;\n\t\tmod_timer(&ioc->iocpf_timer, jiffies +\n\t\t\tmsecs_to_jiffies(BFA_IOC_POLL_TOV));\n\t}\n}\n\n \n\n \n#define BFA_FLASH_SEG_SZ\t2048\n#define BFA_FLASH_DMA_BUF_SZ\t\\\n\troundup(0x010000 + sizeof(struct bfa_mfg_block), BFA_FLASH_SEG_SZ)\n\nstatic void\nbfa_flash_cb(struct bfa_flash *flash)\n{\n\tflash->op_busy = 0;\n\tif (flash->cbfn)\n\t\tflash->cbfn(flash->cbarg, flash->status);\n}\n\nstatic void\nbfa_flash_notify(void *cbarg, enum bfa_ioc_event event)\n{\n\tstruct bfa_flash *flash = cbarg;\n\n\tswitch (event) {\n\tcase BFA_IOC_E_DISABLED:\n\tcase BFA_IOC_E_FAILED:\n\t\tif (flash->op_busy) {\n\t\t\tflash->status = BFA_STATUS_IOC_FAILURE;\n\t\t\tflash->cbfn(flash->cbarg, flash->status);\n\t\t\tflash->op_busy = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nbfa_flash_write_send(struct bfa_flash *flash)\n{\n\tstruct bfi_flash_write_req *msg =\n\t\t\t(struct bfi_flash_write_req *) flash->mb.msg;\n\tu32\tlen;\n\n\tmsg->type = be32_to_cpu(flash->type);\n\tmsg->instance = flash->instance;\n\tmsg->offset = be32_to_cpu(flash->addr_off + flash->offset);\n\tlen = (flash->residue < BFA_FLASH_DMA_BUF_SZ) ?\n\t       flash->residue : BFA_FLASH_DMA_BUF_SZ;\n\tmsg->length = be32_to_cpu(len);\n\n\t \n\tmsg->last = (len == flash->residue) ? 1 : 0;\n\n\tbfi_h2i_set(msg->mh, BFI_MC_FLASH, BFI_FLASH_H2I_WRITE_REQ,\n\t\t    bfa_ioc_portid(flash->ioc));\n\tbfa_alen_set(&msg->alen, len, flash->dbuf_pa);\n\tmemcpy(flash->dbuf_kva, flash->ubuf + flash->offset, len);\n\tbfa_nw_ioc_mbox_queue(flash->ioc, &flash->mb, NULL, NULL);\n\n\tflash->residue -= len;\n\tflash->offset += len;\n}\n\n \nstatic void\nbfa_flash_read_send(void *cbarg)\n{\n\tstruct bfa_flash *flash = cbarg;\n\tstruct bfi_flash_read_req *msg =\n\t\t\t(struct bfi_flash_read_req *) flash->mb.msg;\n\tu32\tlen;\n\n\tmsg->type = be32_to_cpu(flash->type);\n\tmsg->instance = flash->instance;\n\tmsg->offset = be32_to_cpu(flash->addr_off + flash->offset);\n\tlen = (flash->residue < BFA_FLASH_DMA_BUF_SZ) ?\n\t       flash->residue : BFA_FLASH_DMA_BUF_SZ;\n\tmsg->length = be32_to_cpu(len);\n\tbfi_h2i_set(msg->mh, BFI_MC_FLASH, BFI_FLASH_H2I_READ_REQ,\n\t\t    bfa_ioc_portid(flash->ioc));\n\tbfa_alen_set(&msg->alen, len, flash->dbuf_pa);\n\tbfa_nw_ioc_mbox_queue(flash->ioc, &flash->mb, NULL, NULL);\n}\n\n \nstatic void\nbfa_flash_intr(void *flasharg, struct bfi_mbmsg *msg)\n{\n\tstruct bfa_flash *flash = flasharg;\n\tu32\tstatus;\n\n\tunion {\n\t\tstruct bfi_flash_query_rsp *query;\n\t\tstruct bfi_flash_write_rsp *write;\n\t\tstruct bfi_flash_read_rsp *read;\n\t\tstruct bfi_mbmsg   *msg;\n\t} m;\n\n\tm.msg = msg;\n\n\t \n\tif (!flash->op_busy && msg->mh.msg_id != BFI_FLASH_I2H_EVENT)\n\t\treturn;\n\n\tswitch (msg->mh.msg_id) {\n\tcase BFI_FLASH_I2H_QUERY_RSP:\n\t\tstatus = be32_to_cpu(m.query->status);\n\t\tif (status == BFA_STATUS_OK) {\n\t\t\tu32\ti;\n\t\t\tstruct bfa_flash_attr *attr, *f;\n\n\t\t\tattr = (struct bfa_flash_attr *) flash->ubuf;\n\t\t\tf = (struct bfa_flash_attr *) flash->dbuf_kva;\n\t\t\tattr->status = be32_to_cpu(f->status);\n\t\t\tattr->npart = be32_to_cpu(f->npart);\n\t\t\tfor (i = 0; i < attr->npart; i++) {\n\t\t\t\tattr->part[i].part_type =\n\t\t\t\t\tbe32_to_cpu(f->part[i].part_type);\n\t\t\t\tattr->part[i].part_instance =\n\t\t\t\t\tbe32_to_cpu(f->part[i].part_instance);\n\t\t\t\tattr->part[i].part_off =\n\t\t\t\t\tbe32_to_cpu(f->part[i].part_off);\n\t\t\t\tattr->part[i].part_size =\n\t\t\t\t\tbe32_to_cpu(f->part[i].part_size);\n\t\t\t\tattr->part[i].part_len =\n\t\t\t\t\tbe32_to_cpu(f->part[i].part_len);\n\t\t\t\tattr->part[i].part_status =\n\t\t\t\t\tbe32_to_cpu(f->part[i].part_status);\n\t\t\t}\n\t\t}\n\t\tflash->status = status;\n\t\tbfa_flash_cb(flash);\n\t\tbreak;\n\tcase BFI_FLASH_I2H_WRITE_RSP:\n\t\tstatus = be32_to_cpu(m.write->status);\n\t\tif (status != BFA_STATUS_OK || flash->residue == 0) {\n\t\t\tflash->status = status;\n\t\t\tbfa_flash_cb(flash);\n\t\t} else\n\t\t\tbfa_flash_write_send(flash);\n\t\tbreak;\n\tcase BFI_FLASH_I2H_READ_RSP:\n\t\tstatus = be32_to_cpu(m.read->status);\n\t\tif (status != BFA_STATUS_OK) {\n\t\t\tflash->status = status;\n\t\t\tbfa_flash_cb(flash);\n\t\t} else {\n\t\t\tu32 len = be32_to_cpu(m.read->length);\n\t\t\tmemcpy(flash->ubuf + flash->offset,\n\t\t\t       flash->dbuf_kva, len);\n\t\t\tflash->residue -= len;\n\t\t\tflash->offset += len;\n\t\t\tif (flash->residue == 0) {\n\t\t\t\tflash->status = status;\n\t\t\t\tbfa_flash_cb(flash);\n\t\t\t} else\n\t\t\t\tbfa_flash_read_send(flash);\n\t\t}\n\t\tbreak;\n\tcase BFI_FLASH_I2H_BOOT_VER_RSP:\n\tcase BFI_FLASH_I2H_EVENT:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n\n \nu32\nbfa_nw_flash_meminfo(void)\n{\n\treturn roundup(BFA_FLASH_DMA_BUF_SZ, BFA_DMA_ALIGN_SZ);\n}\n\n \nvoid\nbfa_nw_flash_attach(struct bfa_flash *flash, struct bfa_ioc *ioc, void *dev)\n{\n\tflash->ioc = ioc;\n\tflash->cbfn = NULL;\n\tflash->cbarg = NULL;\n\tflash->op_busy = 0;\n\n\tbfa_nw_ioc_mbox_regisr(flash->ioc, BFI_MC_FLASH, bfa_flash_intr, flash);\n\tbfa_ioc_notify_init(&flash->ioc_notify, bfa_flash_notify, flash);\n\tlist_add_tail(&flash->ioc_notify.qe, &flash->ioc->notify_q);\n}\n\n \nvoid\nbfa_nw_flash_memclaim(struct bfa_flash *flash, u8 *dm_kva, u64 dm_pa)\n{\n\tflash->dbuf_kva = dm_kva;\n\tflash->dbuf_pa = dm_pa;\n\tmemset(flash->dbuf_kva, 0, BFA_FLASH_DMA_BUF_SZ);\n\tdm_kva += roundup(BFA_FLASH_DMA_BUF_SZ, BFA_DMA_ALIGN_SZ);\n\tdm_pa += roundup(BFA_FLASH_DMA_BUF_SZ, BFA_DMA_ALIGN_SZ);\n}\n\n \nenum bfa_status\nbfa_nw_flash_get_attr(struct bfa_flash *flash, struct bfa_flash_attr *attr,\n\t\t      bfa_cb_flash cbfn, void *cbarg)\n{\n\tstruct bfi_flash_query_req *msg =\n\t\t\t(struct bfi_flash_query_req *) flash->mb.msg;\n\n\tif (!bfa_nw_ioc_is_operational(flash->ioc))\n\t\treturn BFA_STATUS_IOC_NON_OP;\n\n\tif (flash->op_busy)\n\t\treturn BFA_STATUS_DEVBUSY;\n\n\tflash->op_busy = 1;\n\tflash->cbfn = cbfn;\n\tflash->cbarg = cbarg;\n\tflash->ubuf = (u8 *) attr;\n\n\tbfi_h2i_set(msg->mh, BFI_MC_FLASH, BFI_FLASH_H2I_QUERY_REQ,\n\t\t    bfa_ioc_portid(flash->ioc));\n\tbfa_alen_set(&msg->alen, sizeof(struct bfa_flash_attr), flash->dbuf_pa);\n\tbfa_nw_ioc_mbox_queue(flash->ioc, &flash->mb, NULL, NULL);\n\n\treturn BFA_STATUS_OK;\n}\n\n \nenum bfa_status\nbfa_nw_flash_update_part(struct bfa_flash *flash, u32 type, u8 instance,\n\t\t\t void *buf, u32 len, u32 offset,\n\t\t\t bfa_cb_flash cbfn, void *cbarg)\n{\n\tif (!bfa_nw_ioc_is_operational(flash->ioc))\n\t\treturn BFA_STATUS_IOC_NON_OP;\n\n\t \n\tif (!len || (len & 0x03))\n\t\treturn BFA_STATUS_FLASH_BAD_LEN;\n\n\tif (type == BFA_FLASH_PART_MFG)\n\t\treturn BFA_STATUS_EINVAL;\n\n\tif (flash->op_busy)\n\t\treturn BFA_STATUS_DEVBUSY;\n\n\tflash->op_busy = 1;\n\tflash->cbfn = cbfn;\n\tflash->cbarg = cbarg;\n\tflash->type = type;\n\tflash->instance = instance;\n\tflash->residue = len;\n\tflash->offset = 0;\n\tflash->addr_off = offset;\n\tflash->ubuf = buf;\n\n\tbfa_flash_write_send(flash);\n\n\treturn BFA_STATUS_OK;\n}\n\n \nenum bfa_status\nbfa_nw_flash_read_part(struct bfa_flash *flash, u32 type, u8 instance,\n\t\t       void *buf, u32 len, u32 offset,\n\t\t       bfa_cb_flash cbfn, void *cbarg)\n{\n\tif (!bfa_nw_ioc_is_operational(flash->ioc))\n\t\treturn BFA_STATUS_IOC_NON_OP;\n\n\t \n\tif (!len || (len & 0x03))\n\t\treturn BFA_STATUS_FLASH_BAD_LEN;\n\n\tif (flash->op_busy)\n\t\treturn BFA_STATUS_DEVBUSY;\n\n\tflash->op_busy = 1;\n\tflash->cbfn = cbfn;\n\tflash->cbarg = cbarg;\n\tflash->type = type;\n\tflash->instance = instance;\n\tflash->residue = len;\n\tflash->offset = 0;\n\tflash->addr_off = offset;\n\tflash->ubuf = buf;\n\n\tbfa_flash_read_send(flash);\n\n\treturn BFA_STATUS_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}