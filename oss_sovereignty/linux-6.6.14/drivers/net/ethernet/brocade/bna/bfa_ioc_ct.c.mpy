{
  "module_name": "bfa_ioc_ct.c",
  "hash_id": "314ca388b40558a499ded63ac7be0af067ab44309ebae3ee89b0d53f3b07501d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/brocade/bna/bfa_ioc_ct.c",
  "human_readable_source": "\n \n \n\n#include \"bfa_ioc.h\"\n#include \"cna.h\"\n#include \"bfi.h\"\n#include \"bfi_reg.h\"\n#include \"bfa_defs.h\"\n\n#define bfa_ioc_ct_sync_pos(__ioc)\tBIT(bfa_ioc_pcifn(__ioc))\n#define BFA_IOC_SYNC_REQD_SH\t\t16\n#define bfa_ioc_ct_get_sync_ackd(__val) (__val & 0x0000ffff)\n#define bfa_ioc_ct_clear_sync_ackd(__val) (__val & 0xffff0000)\n#define bfa_ioc_ct_get_sync_reqd(__val) (__val >> BFA_IOC_SYNC_REQD_SH)\n#define bfa_ioc_ct_sync_reqd_pos(__ioc) \\\n\t\t(bfa_ioc_ct_sync_pos(__ioc) << BFA_IOC_SYNC_REQD_SH)\n\n \nstatic bool bfa_ioc_ct_firmware_lock(struct bfa_ioc *ioc);\nstatic void bfa_ioc_ct_firmware_unlock(struct bfa_ioc *ioc);\nstatic void bfa_ioc_ct_reg_init(struct bfa_ioc *ioc);\nstatic void bfa_ioc_ct2_reg_init(struct bfa_ioc *ioc);\nstatic void bfa_ioc_ct_map_port(struct bfa_ioc *ioc);\nstatic void bfa_ioc_ct2_map_port(struct bfa_ioc *ioc);\nstatic void bfa_ioc_ct_isr_mode_set(struct bfa_ioc *ioc, bool msix);\nstatic void bfa_ioc_ct_notify_fail(struct bfa_ioc *ioc);\nstatic void bfa_ioc_ct_ownership_reset(struct bfa_ioc *ioc);\nstatic bool bfa_ioc_ct_sync_start(struct bfa_ioc *ioc);\nstatic void bfa_ioc_ct_sync_join(struct bfa_ioc *ioc);\nstatic void bfa_ioc_ct_sync_leave(struct bfa_ioc *ioc);\nstatic void bfa_ioc_ct_sync_ack(struct bfa_ioc *ioc);\nstatic bool bfa_ioc_ct_sync_complete(struct bfa_ioc *ioc);\nstatic void bfa_ioc_ct_set_cur_ioc_fwstate(\n\t\t\tstruct bfa_ioc *ioc, enum bfi_ioc_state fwstate);\nstatic enum bfi_ioc_state bfa_ioc_ct_get_cur_ioc_fwstate(struct bfa_ioc *ioc);\nstatic void bfa_ioc_ct_set_alt_ioc_fwstate(\n\t\t\tstruct bfa_ioc *ioc, enum bfi_ioc_state fwstate);\nstatic enum bfi_ioc_state bfa_ioc_ct_get_alt_ioc_fwstate(struct bfa_ioc *ioc);\nstatic enum bfa_status bfa_ioc_ct_pll_init(void __iomem *rb,\n\t\t\t\tenum bfi_asic_mode asic_mode);\nstatic enum bfa_status bfa_ioc_ct2_pll_init(void __iomem *rb,\n\t\t\t\tenum bfi_asic_mode asic_mode);\nstatic bool bfa_ioc_ct2_lpu_read_stat(struct bfa_ioc *ioc);\n\nstatic const struct bfa_ioc_hwif nw_hwif_ct = {\n\t.ioc_pll_init\t     = bfa_ioc_ct_pll_init,\n\t.ioc_firmware_lock   = bfa_ioc_ct_firmware_lock,\n\t.ioc_firmware_unlock = bfa_ioc_ct_firmware_unlock,\n\t.ioc_reg_init\t     = bfa_ioc_ct_reg_init,\n\t.ioc_map_port\t     = bfa_ioc_ct_map_port,\n\t.ioc_isr_mode_set    = bfa_ioc_ct_isr_mode_set,\n\t.ioc_notify_fail     = bfa_ioc_ct_notify_fail,\n\t.ioc_ownership_reset = bfa_ioc_ct_ownership_reset,\n\t.ioc_sync_start      = bfa_ioc_ct_sync_start,\n\t.ioc_sync_join       = bfa_ioc_ct_sync_join,\n\t.ioc_sync_leave\t     = bfa_ioc_ct_sync_leave,\n\t.ioc_sync_ack\t     = bfa_ioc_ct_sync_ack,\n\t.ioc_sync_complete   = bfa_ioc_ct_sync_complete,\n\t.ioc_set_fwstate     = bfa_ioc_ct_set_cur_ioc_fwstate,\n\t.ioc_get_fwstate     = bfa_ioc_ct_get_cur_ioc_fwstate,\n\t.ioc_set_alt_fwstate     = bfa_ioc_ct_set_alt_ioc_fwstate,\n\t.ioc_get_alt_fwstate     = bfa_ioc_ct_get_alt_ioc_fwstate,\n};\n\nstatic const struct bfa_ioc_hwif nw_hwif_ct2 = {\n\t.ioc_pll_init\t     = bfa_ioc_ct2_pll_init,\n\t.ioc_firmware_lock   = bfa_ioc_ct_firmware_lock,\n\t.ioc_firmware_unlock = bfa_ioc_ct_firmware_unlock,\n\t.ioc_reg_init\t     = bfa_ioc_ct2_reg_init,\n\t.ioc_map_port\t     = bfa_ioc_ct2_map_port,\n\t.ioc_lpu_read_stat   = bfa_ioc_ct2_lpu_read_stat,\n\t.ioc_isr_mode_set    = NULL,\n\t.ioc_notify_fail     = bfa_ioc_ct_notify_fail,\n\t.ioc_ownership_reset = bfa_ioc_ct_ownership_reset,\n\t.ioc_sync_start      = bfa_ioc_ct_sync_start,\n\t.ioc_sync_join       = bfa_ioc_ct_sync_join,\n\t.ioc_sync_leave\t     = bfa_ioc_ct_sync_leave,\n\t.ioc_sync_ack\t     = bfa_ioc_ct_sync_ack,\n\t.ioc_sync_complete   = bfa_ioc_ct_sync_complete,\n\t.ioc_set_fwstate     = bfa_ioc_ct_set_cur_ioc_fwstate,\n\t.ioc_get_fwstate     = bfa_ioc_ct_get_cur_ioc_fwstate,\n\t.ioc_set_alt_fwstate     = bfa_ioc_ct_set_alt_ioc_fwstate,\n\t.ioc_get_alt_fwstate     = bfa_ioc_ct_get_alt_ioc_fwstate,\n};\n\n \nvoid\nbfa_nw_ioc_set_ct_hwif(struct bfa_ioc *ioc)\n{\n\tioc->ioc_hwif = &nw_hwif_ct;\n}\n\nvoid\nbfa_nw_ioc_set_ct2_hwif(struct bfa_ioc *ioc)\n{\n\tioc->ioc_hwif = &nw_hwif_ct2;\n}\n\n \nstatic bool\nbfa_ioc_ct_firmware_lock(struct bfa_ioc *ioc)\n{\n\tenum bfi_ioc_state ioc_fwstate;\n\tu32 usecnt;\n\tstruct bfi_ioc_image_hdr fwhdr;\n\n\t \n\tif (bfa_cb_image_get_size(bfa_ioc_asic_gen(ioc)) <\n\t\t\t\t\t\tBFA_IOC_FWIMG_MINSZ)\n\t\treturn true;\n\n\tbfa_nw_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);\n\tusecnt = readl(ioc->ioc_regs.ioc_usage_reg);\n\n\t \n\tif (usecnt == 0) {\n\t\twritel(1, ioc->ioc_regs.ioc_usage_reg);\n\t\tbfa_nw_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);\n\t\twritel(0, ioc->ioc_regs.ioc_fail_sync);\n\t\treturn true;\n\t}\n\n\tioc_fwstate = readl(ioc->ioc_regs.ioc_fwstate);\n\n\t \n\tBUG_ON(!(ioc_fwstate != BFI_IOC_UNINIT));\n\n\t \n\tbfa_nw_ioc_fwver_get(ioc, &fwhdr);\n\tif (!bfa_nw_ioc_fwver_cmp(ioc, &fwhdr)) {\n\t\tbfa_nw_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);\n\t\treturn false;\n\t}\n\n\t \n\tusecnt++;\n\twritel(usecnt, ioc->ioc_regs.ioc_usage_reg);\n\tbfa_nw_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);\n\treturn true;\n}\n\nstatic void\nbfa_ioc_ct_firmware_unlock(struct bfa_ioc *ioc)\n{\n\tu32 usecnt;\n\n\t \n\tif (bfa_cb_image_get_size(bfa_ioc_asic_gen(ioc)) <\n\t\t\t\t\t\tBFA_IOC_FWIMG_MINSZ)\n\t\treturn;\n\n\t \n\tbfa_nw_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);\n\tusecnt = readl(ioc->ioc_regs.ioc_usage_reg);\n\tBUG_ON(!(usecnt > 0));\n\n\tusecnt--;\n\twritel(usecnt, ioc->ioc_regs.ioc_usage_reg);\n\n\tbfa_nw_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);\n}\n\n \nstatic void\nbfa_ioc_ct_notify_fail(struct bfa_ioc *ioc)\n{\n\twritel(__FW_INIT_HALT_P, ioc->ioc_regs.ll_halt);\n\twritel(__FW_INIT_HALT_P, ioc->ioc_regs.alt_ll_halt);\n\t \n\treadl(ioc->ioc_regs.ll_halt);\n\treadl(ioc->ioc_regs.alt_ll_halt);\n}\n\n \nstatic const struct {\n\tu32\thfn_mbox;\n\tu32\tlpu_mbox;\n\tu32\thfn_pgn;\n} ct_fnreg[] = {\n\t{ HOSTFN0_LPU_MBOX0_0, LPU_HOSTFN0_MBOX0_0, HOST_PAGE_NUM_FN0 },\n\t{ HOSTFN1_LPU_MBOX0_8, LPU_HOSTFN1_MBOX0_8, HOST_PAGE_NUM_FN1 },\n\t{ HOSTFN2_LPU_MBOX0_0, LPU_HOSTFN2_MBOX0_0, HOST_PAGE_NUM_FN2 },\n\t{ HOSTFN3_LPU_MBOX0_8, LPU_HOSTFN3_MBOX0_8, HOST_PAGE_NUM_FN3 }\n};\n\n \nstatic const struct {\n\tu32\thfn;\n\tu32\tlpu;\n} ct_p0reg[] = {\n\t{ HOSTFN0_LPU0_CMD_STAT, LPU0_HOSTFN0_CMD_STAT },\n\t{ HOSTFN1_LPU0_CMD_STAT, LPU0_HOSTFN1_CMD_STAT },\n\t{ HOSTFN2_LPU0_CMD_STAT, LPU0_HOSTFN2_CMD_STAT },\n\t{ HOSTFN3_LPU0_CMD_STAT, LPU0_HOSTFN3_CMD_STAT }\n};\n\n \nstatic const struct {\n\tu32\thfn;\n\tu32\tlpu;\n} ct_p1reg[] = {\n\t{ HOSTFN0_LPU1_CMD_STAT, LPU1_HOSTFN0_CMD_STAT },\n\t{ HOSTFN1_LPU1_CMD_STAT, LPU1_HOSTFN1_CMD_STAT },\n\t{ HOSTFN2_LPU1_CMD_STAT, LPU1_HOSTFN2_CMD_STAT },\n\t{ HOSTFN3_LPU1_CMD_STAT, LPU1_HOSTFN3_CMD_STAT }\n};\n\nstatic const struct {\n\tu32\thfn_mbox;\n\tu32\tlpu_mbox;\n\tu32\thfn_pgn;\n\tu32\thfn;\n\tu32\tlpu;\n\tu32\tlpu_read;\n} ct2_reg[] = {\n\t{ CT2_HOSTFN_LPU0_MBOX0, CT2_LPU0_HOSTFN_MBOX0, CT2_HOSTFN_PAGE_NUM,\n\t  CT2_HOSTFN_LPU0_CMD_STAT, CT2_LPU0_HOSTFN_CMD_STAT,\n\t  CT2_HOSTFN_LPU0_READ_STAT},\n\t{ CT2_HOSTFN_LPU1_MBOX0, CT2_LPU1_HOSTFN_MBOX0, CT2_HOSTFN_PAGE_NUM,\n\t  CT2_HOSTFN_LPU1_CMD_STAT, CT2_LPU1_HOSTFN_CMD_STAT,\n\t  CT2_HOSTFN_LPU1_READ_STAT},\n};\n\nstatic void\nbfa_ioc_ct_reg_init(struct bfa_ioc *ioc)\n{\n\tvoid __iomem *rb;\n\tint\t\tpcifn = bfa_ioc_pcifn(ioc);\n\n\trb = bfa_ioc_bar0(ioc);\n\n\tioc->ioc_regs.hfn_mbox = rb + ct_fnreg[pcifn].hfn_mbox;\n\tioc->ioc_regs.lpu_mbox = rb + ct_fnreg[pcifn].lpu_mbox;\n\tioc->ioc_regs.host_page_num_fn = rb + ct_fnreg[pcifn].hfn_pgn;\n\n\tif (ioc->port_id == 0) {\n\t\tioc->ioc_regs.heartbeat = rb + BFA_IOC0_HBEAT_REG;\n\t\tioc->ioc_regs.ioc_fwstate = rb + BFA_IOC0_STATE_REG;\n\t\tioc->ioc_regs.alt_ioc_fwstate = rb + BFA_IOC1_STATE_REG;\n\t\tioc->ioc_regs.hfn_mbox_cmd = rb + ct_p0reg[pcifn].hfn;\n\t\tioc->ioc_regs.lpu_mbox_cmd = rb + ct_p0reg[pcifn].lpu;\n\t\tioc->ioc_regs.ll_halt = rb + FW_INIT_HALT_P0;\n\t\tioc->ioc_regs.alt_ll_halt = rb + FW_INIT_HALT_P1;\n\t} else {\n\t\tioc->ioc_regs.heartbeat = rb + BFA_IOC1_HBEAT_REG;\n\t\tioc->ioc_regs.ioc_fwstate = rb + BFA_IOC1_STATE_REG;\n\t\tioc->ioc_regs.alt_ioc_fwstate = rb + BFA_IOC0_STATE_REG;\n\t\tioc->ioc_regs.hfn_mbox_cmd = rb + ct_p1reg[pcifn].hfn;\n\t\tioc->ioc_regs.lpu_mbox_cmd = rb + ct_p1reg[pcifn].lpu;\n\t\tioc->ioc_regs.ll_halt = rb + FW_INIT_HALT_P1;\n\t\tioc->ioc_regs.alt_ll_halt = rb + FW_INIT_HALT_P0;\n\t}\n\n\t \n\tioc->ioc_regs.pss_ctl_reg = rb + PSS_CTL_REG;\n\tioc->ioc_regs.pss_err_status_reg = rb + PSS_ERR_STATUS_REG;\n\tioc->ioc_regs.app_pll_fast_ctl_reg = rb + APP_PLL_LCLK_CTL_REG;\n\tioc->ioc_regs.app_pll_slow_ctl_reg = rb + APP_PLL_SCLK_CTL_REG;\n\n\t \n\tioc->ioc_regs.ioc_sem_reg = rb + HOST_SEM0_REG;\n\tioc->ioc_regs.ioc_usage_sem_reg = rb + HOST_SEM1_REG;\n\tioc->ioc_regs.ioc_init_sem_reg = rb + HOST_SEM2_REG;\n\tioc->ioc_regs.ioc_usage_reg = rb + BFA_FW_USE_COUNT;\n\tioc->ioc_regs.ioc_fail_sync = rb + BFA_IOC_FAIL_SYNC;\n\n\t \n\tioc->ioc_regs.smem_page_start = rb + PSS_SMEM_PAGE_START;\n\tioc->ioc_regs.smem_pg0 = BFI_IOC_SMEM_PG0_CT;\n\n\t \n\tioc->ioc_regs.err_set = (rb + ERR_SET_REG);\n}\n\nstatic void\nbfa_ioc_ct2_reg_init(struct bfa_ioc *ioc)\n{\n\tvoid __iomem *rb;\n\tint\t\tport = bfa_ioc_portid(ioc);\n\n\trb = bfa_ioc_bar0(ioc);\n\n\tioc->ioc_regs.hfn_mbox = rb + ct2_reg[port].hfn_mbox;\n\tioc->ioc_regs.lpu_mbox = rb + ct2_reg[port].lpu_mbox;\n\tioc->ioc_regs.host_page_num_fn = rb + ct2_reg[port].hfn_pgn;\n\tioc->ioc_regs.hfn_mbox_cmd = rb + ct2_reg[port].hfn;\n\tioc->ioc_regs.lpu_mbox_cmd = rb + ct2_reg[port].lpu;\n\tioc->ioc_regs.lpu_read_stat = rb + ct2_reg[port].lpu_read;\n\n\tif (port == 0) {\n\t\tioc->ioc_regs.heartbeat = rb + CT2_BFA_IOC0_HBEAT_REG;\n\t\tioc->ioc_regs.ioc_fwstate = rb + CT2_BFA_IOC0_STATE_REG;\n\t\tioc->ioc_regs.alt_ioc_fwstate = rb + CT2_BFA_IOC1_STATE_REG;\n\t\tioc->ioc_regs.ll_halt = rb + FW_INIT_HALT_P0;\n\t\tioc->ioc_regs.alt_ll_halt = rb + FW_INIT_HALT_P1;\n\t} else {\n\t\tioc->ioc_regs.heartbeat = rb + CT2_BFA_IOC1_HBEAT_REG;\n\t\tioc->ioc_regs.ioc_fwstate = rb + CT2_BFA_IOC1_STATE_REG;\n\t\tioc->ioc_regs.alt_ioc_fwstate = rb + CT2_BFA_IOC0_STATE_REG;\n\t\tioc->ioc_regs.ll_halt = rb + FW_INIT_HALT_P1;\n\t\tioc->ioc_regs.alt_ll_halt = rb + FW_INIT_HALT_P0;\n\t}\n\n\t \n\tioc->ioc_regs.pss_ctl_reg = rb + PSS_CTL_REG;\n\tioc->ioc_regs.pss_err_status_reg = rb + PSS_ERR_STATUS_REG;\n\tioc->ioc_regs.app_pll_fast_ctl_reg = rb + CT2_APP_PLL_LCLK_CTL_REG;\n\tioc->ioc_regs.app_pll_slow_ctl_reg = rb + CT2_APP_PLL_SCLK_CTL_REG;\n\n\t \n\tioc->ioc_regs.ioc_sem_reg = rb + CT2_HOST_SEM0_REG;\n\tioc->ioc_regs.ioc_usage_sem_reg = rb + CT2_HOST_SEM1_REG;\n\tioc->ioc_regs.ioc_init_sem_reg = rb + CT2_HOST_SEM2_REG;\n\tioc->ioc_regs.ioc_usage_reg = rb + CT2_BFA_FW_USE_COUNT;\n\tioc->ioc_regs.ioc_fail_sync = rb + CT2_BFA_IOC_FAIL_SYNC;\n\n\t \n\tioc->ioc_regs.smem_page_start = rb + PSS_SMEM_PAGE_START;\n\tioc->ioc_regs.smem_pg0 = BFI_IOC_SMEM_PG0_CT;\n\n\t \n\tioc->ioc_regs.err_set = rb + ERR_SET_REG;\n}\n\n \n\n#define FNC_PERS_FN_SHIFT(__fn)\t((__fn) * 8)\nstatic void\nbfa_ioc_ct_map_port(struct bfa_ioc *ioc)\n{\n\tvoid __iomem *rb = ioc->pcidev.pci_bar_kva;\n\tu32\tr32;\n\n\t \n\tr32 = readl(rb + FNC_PERS_REG);\n\tr32 >>= FNC_PERS_FN_SHIFT(bfa_ioc_pcifn(ioc));\n\tioc->port_id = (r32 & __F0_PORT_MAP_MK) >> __F0_PORT_MAP_SH;\n\n}\n\nstatic void\nbfa_ioc_ct2_map_port(struct bfa_ioc *ioc)\n{\n\tvoid __iomem *rb = ioc->pcidev.pci_bar_kva;\n\tu32\tr32;\n\n\tr32 = readl(rb + CT2_HOSTFN_PERSONALITY0);\n\tioc->port_id = ((r32 & __FC_LL_PORT_MAP__MK) >> __FC_LL_PORT_MAP__SH);\n}\n\n \nstatic void\nbfa_ioc_ct_isr_mode_set(struct bfa_ioc *ioc, bool msix)\n{\n\tvoid __iomem *rb = ioc->pcidev.pci_bar_kva;\n\tu32\tr32, mode;\n\n\tr32 = readl(rb + FNC_PERS_REG);\n\n\tmode = (r32 >> FNC_PERS_FN_SHIFT(bfa_ioc_pcifn(ioc))) &\n\t\t__F0_INTX_STATUS;\n\n\t \n\tif ((!msix && mode) || (msix && !mode))\n\t\treturn;\n\n\tif (msix)\n\t\tmode = __F0_INTX_STATUS_MSIX;\n\telse\n\t\tmode = __F0_INTX_STATUS_INTA;\n\n\tr32 &= ~(__F0_INTX_STATUS << FNC_PERS_FN_SHIFT(bfa_ioc_pcifn(ioc)));\n\tr32 |= (mode << FNC_PERS_FN_SHIFT(bfa_ioc_pcifn(ioc)));\n\n\twritel(r32, rb + FNC_PERS_REG);\n}\n\nstatic bool\nbfa_ioc_ct2_lpu_read_stat(struct bfa_ioc *ioc)\n{\n\tu32 r32;\n\n\tr32 = readl(ioc->ioc_regs.lpu_read_stat);\n\tif (r32) {\n\t\twritel(1, ioc->ioc_regs.lpu_read_stat);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \n#define HOSTFN_MSIX_DEFAULT\t\t64\n#define HOSTFN_MSIX_VT_INDEX_MBOX_ERR\t0x30138\n#define HOSTFN_MSIX_VT_OFST_NUMVT\t0x3013c\n#define __MSIX_VT_NUMVT__MK\t\t0x003ff800\n#define __MSIX_VT_NUMVT__SH\t\t11\n#define __MSIX_VT_NUMVT_(_v)\t\t((_v) << __MSIX_VT_NUMVT__SH)\n#define __MSIX_VT_OFST_\t\t\t0x000007ff\nvoid\nbfa_nw_ioc_ct2_poweron(struct bfa_ioc *ioc)\n{\n\tvoid __iomem *rb = ioc->pcidev.pci_bar_kva;\n\tu32 r32;\n\n\tr32 = readl(rb + HOSTFN_MSIX_VT_OFST_NUMVT);\n\tif (r32 & __MSIX_VT_NUMVT__MK) {\n\t\twritel(r32 & __MSIX_VT_OFST_,\n\t\t\trb + HOSTFN_MSIX_VT_INDEX_MBOX_ERR);\n\t\treturn;\n\t}\n\n\twritel(__MSIX_VT_NUMVT_(HOSTFN_MSIX_DEFAULT - 1) |\n\t\t\tHOSTFN_MSIX_DEFAULT * bfa_ioc_pcifn(ioc),\n\t\t\trb + HOSTFN_MSIX_VT_OFST_NUMVT);\n\twritel(HOSTFN_MSIX_DEFAULT * bfa_ioc_pcifn(ioc),\n\t\t\trb + HOSTFN_MSIX_VT_INDEX_MBOX_ERR);\n}\n\n \nstatic void\nbfa_ioc_ct_ownership_reset(struct bfa_ioc *ioc)\n{\n\tbfa_nw_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);\n\twritel(0, ioc->ioc_regs.ioc_usage_reg);\n\tbfa_nw_ioc_sem_release(ioc->ioc_regs.ioc_usage_sem_reg);\n\n\t \n\treadl(ioc->ioc_regs.ioc_sem_reg);\n\tbfa_nw_ioc_hw_sem_release(ioc);\n}\n\n \nstatic bool\nbfa_ioc_ct_sync_start(struct bfa_ioc *ioc)\n{\n\tu32 r32 = readl(ioc->ioc_regs.ioc_fail_sync);\n\tu32 sync_reqd = bfa_ioc_ct_get_sync_reqd(r32);\n\n\t \n\n\tif (sync_reqd & bfa_ioc_ct_sync_pos(ioc)) {\n\t\twritel(0, ioc->ioc_regs.ioc_fail_sync);\n\t\twritel(1, ioc->ioc_regs.ioc_usage_reg);\n\t\twritel(BFI_IOC_UNINIT, ioc->ioc_regs.ioc_fwstate);\n\t\twritel(BFI_IOC_UNINIT, ioc->ioc_regs.alt_ioc_fwstate);\n\t\treturn true;\n\t}\n\n\treturn bfa_ioc_ct_sync_complete(ioc);\n}\n \nstatic void\nbfa_ioc_ct_sync_join(struct bfa_ioc *ioc)\n{\n\tu32 r32 = readl(ioc->ioc_regs.ioc_fail_sync);\n\tu32 sync_pos = bfa_ioc_ct_sync_reqd_pos(ioc);\n\n\twritel((r32 | sync_pos), ioc->ioc_regs.ioc_fail_sync);\n}\n\nstatic void\nbfa_ioc_ct_sync_leave(struct bfa_ioc *ioc)\n{\n\tu32 r32 = readl(ioc->ioc_regs.ioc_fail_sync);\n\tu32 sync_msk = bfa_ioc_ct_sync_reqd_pos(ioc) |\n\t\t\t\t\tbfa_ioc_ct_sync_pos(ioc);\n\n\twritel((r32 & ~sync_msk), ioc->ioc_regs.ioc_fail_sync);\n}\n\nstatic void\nbfa_ioc_ct_sync_ack(struct bfa_ioc *ioc)\n{\n\tu32 r32 = readl(ioc->ioc_regs.ioc_fail_sync);\n\n\twritel(r32 | bfa_ioc_ct_sync_pos(ioc), ioc->ioc_regs.ioc_fail_sync);\n}\n\nstatic bool\nbfa_ioc_ct_sync_complete(struct bfa_ioc *ioc)\n{\n\tu32 r32 = readl(ioc->ioc_regs.ioc_fail_sync);\n\tu32 sync_reqd = bfa_ioc_ct_get_sync_reqd(r32);\n\tu32 sync_ackd = bfa_ioc_ct_get_sync_ackd(r32);\n\tu32 tmp_ackd;\n\n\tif (sync_ackd == 0)\n\t\treturn true;\n\n\t \n\ttmp_ackd = sync_ackd;\n\tif ((sync_reqd &  bfa_ioc_ct_sync_pos(ioc)) &&\n\t\t\t!(sync_ackd & bfa_ioc_ct_sync_pos(ioc)))\n\t\tsync_ackd |= bfa_ioc_ct_sync_pos(ioc);\n\n\tif (sync_reqd == sync_ackd) {\n\t\twritel(bfa_ioc_ct_clear_sync_ackd(r32),\n\t\t\t\tioc->ioc_regs.ioc_fail_sync);\n\t\twritel(BFI_IOC_FAIL, ioc->ioc_regs.ioc_fwstate);\n\t\twritel(BFI_IOC_FAIL, ioc->ioc_regs.alt_ioc_fwstate);\n\t\treturn true;\n\t}\n\n\t \n\tif (tmp_ackd != sync_ackd)\n\t\twritel((r32 | sync_ackd), ioc->ioc_regs.ioc_fail_sync);\n\n\treturn false;\n}\n\nstatic void\nbfa_ioc_ct_set_cur_ioc_fwstate(struct bfa_ioc *ioc,\n\t\t\t       enum bfi_ioc_state fwstate)\n{\n\twritel(fwstate, ioc->ioc_regs.ioc_fwstate);\n}\n\nstatic enum bfi_ioc_state\nbfa_ioc_ct_get_cur_ioc_fwstate(struct bfa_ioc *ioc)\n{\n\treturn (enum bfi_ioc_state)readl(ioc->ioc_regs.ioc_fwstate);\n}\n\nstatic void\nbfa_ioc_ct_set_alt_ioc_fwstate(struct bfa_ioc *ioc,\n\t\t\t       enum bfi_ioc_state fwstate)\n{\n\twritel(fwstate, ioc->ioc_regs.alt_ioc_fwstate);\n}\n\nstatic enum bfi_ioc_state\nbfa_ioc_ct_get_alt_ioc_fwstate(struct bfa_ioc *ioc)\n{\n\treturn (enum bfi_ioc_state)readl(ioc->ioc_regs.alt_ioc_fwstate);\n}\n\nstatic enum bfa_status\nbfa_ioc_ct_pll_init(void __iomem *rb, enum bfi_asic_mode asic_mode)\n{\n\tu32\tpll_sclk, pll_fclk, r32;\n\tbool fcmode = (asic_mode == BFI_ASIC_MODE_FC);\n\n\tpll_sclk = __APP_PLL_SCLK_LRESETN | __APP_PLL_SCLK_ENARST |\n\t\t__APP_PLL_SCLK_RSEL200500 | __APP_PLL_SCLK_P0_1(3U) |\n\t\t__APP_PLL_SCLK_JITLMT0_1(3U) |\n\t\t__APP_PLL_SCLK_CNTLMT0_1(1U);\n\tpll_fclk = __APP_PLL_LCLK_LRESETN | __APP_PLL_LCLK_ENARST |\n\t\t__APP_PLL_LCLK_RSEL200500 | __APP_PLL_LCLK_P0_1(3U) |\n\t\t__APP_PLL_LCLK_JITLMT0_1(3U) |\n\t\t__APP_PLL_LCLK_CNTLMT0_1(1U);\n\n\tif (fcmode) {\n\t\twritel(0, (rb + OP_MODE));\n\t\twritel(__APP_EMS_CMLCKSEL |\n\t\t\t\t__APP_EMS_REFCKBUFEN2 |\n\t\t\t\t__APP_EMS_CHANNEL_SEL,\n\t\t\t\t(rb + ETH_MAC_SER_REG));\n\t} else {\n\t\twritel(__GLOBAL_FCOE_MODE, (rb + OP_MODE));\n\t\twritel(__APP_EMS_REFCKBUFEN1,\n\t\t\t\t(rb + ETH_MAC_SER_REG));\n\t}\n\twritel(BFI_IOC_UNINIT, (rb + BFA_IOC0_STATE_REG));\n\twritel(BFI_IOC_UNINIT, (rb + BFA_IOC1_STATE_REG));\n\twritel(0xffffffffU, (rb + HOSTFN0_INT_MSK));\n\twritel(0xffffffffU, (rb + HOSTFN1_INT_MSK));\n\twritel(0xffffffffU, (rb + HOSTFN0_INT_STATUS));\n\twritel(0xffffffffU, (rb + HOSTFN1_INT_STATUS));\n\twritel(0xffffffffU, (rb + HOSTFN0_INT_MSK));\n\twritel(0xffffffffU, (rb + HOSTFN1_INT_MSK));\n\twritel(pll_sclk |\n\t\t__APP_PLL_SCLK_LOGIC_SOFT_RESET,\n\t\trb + APP_PLL_SCLK_CTL_REG);\n\twritel(pll_fclk |\n\t\t__APP_PLL_LCLK_LOGIC_SOFT_RESET,\n\t\trb + APP_PLL_LCLK_CTL_REG);\n\twritel(pll_sclk |\n\t\t__APP_PLL_SCLK_LOGIC_SOFT_RESET | __APP_PLL_SCLK_ENABLE,\n\t\trb + APP_PLL_SCLK_CTL_REG);\n\twritel(pll_fclk |\n\t\t__APP_PLL_LCLK_LOGIC_SOFT_RESET | __APP_PLL_LCLK_ENABLE,\n\t\trb + APP_PLL_LCLK_CTL_REG);\n\treadl(rb + HOSTFN0_INT_MSK);\n\tudelay(2000);\n\twritel(0xffffffffU, (rb + HOSTFN0_INT_STATUS));\n\twritel(0xffffffffU, (rb + HOSTFN1_INT_STATUS));\n\twritel(pll_sclk |\n\t\t__APP_PLL_SCLK_ENABLE,\n\t\trb + APP_PLL_SCLK_CTL_REG);\n\twritel(pll_fclk |\n\t\t__APP_PLL_LCLK_ENABLE,\n\t\trb + APP_PLL_LCLK_CTL_REG);\n\n\tif (!fcmode) {\n\t\twritel(__PMM_1T_RESET_P, (rb + PMM_1T_RESET_REG_P0));\n\t\twritel(__PMM_1T_RESET_P, (rb + PMM_1T_RESET_REG_P1));\n\t}\n\tr32 = readl(rb + PSS_CTL_REG);\n\tr32 &= ~__PSS_LMEM_RESET;\n\twritel(r32, (rb + PSS_CTL_REG));\n\tudelay(1000);\n\tif (!fcmode) {\n\t\twritel(0, (rb + PMM_1T_RESET_REG_P0));\n\t\twritel(0, (rb + PMM_1T_RESET_REG_P1));\n\t}\n\n\twritel(__EDRAM_BISTR_START, (rb + MBIST_CTL_REG));\n\tudelay(1000);\n\tr32 = readl(rb + MBIST_STAT_REG);\n\twritel(0, (rb + MBIST_CTL_REG));\n\treturn BFA_STATUS_OK;\n}\n\nstatic void\nbfa_ioc_ct2_sclk_init(void __iomem *rb)\n{\n\tu32 r32;\n\n\t \n\tr32 = readl(rb + CT2_APP_PLL_SCLK_CTL_REG);\n\tr32 &= ~(__APP_PLL_SCLK_ENABLE | __APP_PLL_SCLK_LRESETN);\n\tr32 |= (__APP_PLL_SCLK_ENARST | __APP_PLL_SCLK_BYPASS |\n\t\t__APP_PLL_SCLK_LOGIC_SOFT_RESET);\n\twritel(r32, (rb + CT2_APP_PLL_SCLK_CTL_REG));\n\n\t \n\tr32 = readl(rb + CT2_APP_PLL_SCLK_CTL_REG);\n\tr32 &= ~(__APP_PLL_SCLK_REFCLK_SEL | __APP_PLL_SCLK_CLK_DIV2);\n\twritel(r32, (rb + CT2_APP_PLL_SCLK_CTL_REG));\n\n\t \n\tr32 = readl(rb + CT2_CHIP_MISC_PRG);\n\twritel(r32 | __ETH_CLK_ENABLE_PORT0,\n\t       rb + CT2_CHIP_MISC_PRG);\n\n\tr32 = readl(rb + CT2_PCIE_MISC_REG);\n\twritel(r32 | __ETH_CLK_ENABLE_PORT1,\n\t       rb + CT2_PCIE_MISC_REG);\n\n\t \n\tr32 = readl(rb + CT2_APP_PLL_SCLK_CTL_REG);\n\tr32 &= (__P_SCLK_PLL_LOCK | __APP_PLL_SCLK_REFCLK_SEL |\n\t\t__APP_PLL_SCLK_CLK_DIV2);\n\twritel(r32 | 0x1061731b, rb + CT2_APP_PLL_SCLK_CTL_REG);\n\n\t \n\tudelay(1000);\n\n\t \n}\n\nstatic void\nbfa_ioc_ct2_lclk_init(void __iomem *rb)\n{\n\tu32 r32;\n\n\t \n\tr32 = readl(rb + CT2_APP_PLL_LCLK_CTL_REG);\n\tr32 &= ~(__APP_PLL_LCLK_ENABLE | __APP_PLL_LCLK_LRESETN);\n\tr32 |= (__APP_PLL_LCLK_ENARST | __APP_PLL_LCLK_BYPASS |\n\t\t__APP_PLL_LCLK_LOGIC_SOFT_RESET);\n\twritel(r32, rb + CT2_APP_PLL_LCLK_CTL_REG);\n\n\t \n\tr32 = readl(rb + CT2_CHIP_MISC_PRG);\n\twritel(r32, (rb + CT2_CHIP_MISC_PRG));\n\n\t \n\tr32 = readl(rb + CT2_APP_PLL_LCLK_CTL_REG);\n\twritel(r32, rb + CT2_APP_PLL_LCLK_CTL_REG);\n\n\t \n\tr32 = readl(rb + CT2_APP_PLL_LCLK_CTL_REG);\n\tr32 &= (__P_LCLK_PLL_LOCK | __APP_LPUCLK_HALFSPEED);\n\tr32 |= 0x20c1731b;\n\twritel(r32, (rb + CT2_APP_PLL_LCLK_CTL_REG));\n\n\t \n\tudelay(1000);\n}\n\nstatic void\nbfa_ioc_ct2_mem_init(void __iomem *rb)\n{\n\tu32 r32;\n\n\tr32 = readl(rb + PSS_CTL_REG);\n\tr32 &= ~__PSS_LMEM_RESET;\n\twritel(r32, rb + PSS_CTL_REG);\n\tudelay(1000);\n\n\twritel(__EDRAM_BISTR_START, rb + CT2_MBIST_CTL_REG);\n\tudelay(1000);\n\twritel(0, rb + CT2_MBIST_CTL_REG);\n}\n\nstatic void\nbfa_ioc_ct2_mac_reset(void __iomem *rb)\n{\n\tvolatile u32 r32;\n\n\tbfa_ioc_ct2_sclk_init(rb);\n\tbfa_ioc_ct2_lclk_init(rb);\n\n\t \n\tr32 = readl(rb + CT2_APP_PLL_SCLK_CTL_REG);\n\twritel(r32 & ~__APP_PLL_SCLK_LOGIC_SOFT_RESET,\n\t       rb + CT2_APP_PLL_SCLK_CTL_REG);\n\n\t \n\tr32 = readl(rb + CT2_APP_PLL_LCLK_CTL_REG);\n\twritel(r32 & ~__APP_PLL_LCLK_LOGIC_SOFT_RESET,\n\t       rb + CT2_APP_PLL_LCLK_CTL_REG);\n\n\t \n\twritel(__CSI_MAC_RESET | __CSI_MAC_AHB_RESET,\n\t       rb + CT2_CSI_MAC_CONTROL_REG(0));\n\twritel(__CSI_MAC_RESET | __CSI_MAC_AHB_RESET,\n\t       rb + CT2_CSI_MAC_CONTROL_REG(1));\n}\n\n#define CT2_NFC_MAX_DELAY       1000\n#define CT2_NFC_VER_VALID       0x143\n#define BFA_IOC_PLL_POLL        1000000\n\nstatic bool\nbfa_ioc_ct2_nfc_halted(void __iomem *rb)\n{\n\tvolatile u32 r32;\n\n\tr32 = readl(rb + CT2_NFC_CSR_SET_REG);\n\tif (r32 & __NFC_CONTROLLER_HALTED)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void\nbfa_ioc_ct2_nfc_resume(void __iomem *rb)\n{\n\tvolatile u32 r32;\n\tint i;\n\n\twritel(__HALT_NFC_CONTROLLER, rb + CT2_NFC_CSR_CLR_REG);\n\tfor (i = 0; i < CT2_NFC_MAX_DELAY; i++) {\n\t\tr32 = readl(rb + CT2_NFC_CSR_SET_REG);\n\t\tif (!(r32 & __NFC_CONTROLLER_HALTED))\n\t\t\treturn;\n\t\tudelay(1000);\n\t}\n\tBUG_ON(1);\n}\n\nstatic enum bfa_status\nbfa_ioc_ct2_pll_init(void __iomem *rb, enum bfi_asic_mode asic_mode)\n{\n\tvolatile u32 wgn, r32;\n\tu32 nfc_ver, i;\n\n\twgn = readl(rb + CT2_WGN_STATUS);\n\n\tnfc_ver = readl(rb + CT2_RSC_GPR15_REG);\n\n\tif (wgn == (__A2T_AHB_LOAD | __WGN_READY) &&\n\t    nfc_ver >= CT2_NFC_VER_VALID) {\n\t\tif (bfa_ioc_ct2_nfc_halted(rb))\n\t\t\tbfa_ioc_ct2_nfc_resume(rb);\n\t\twritel(__RESET_AND_START_SCLK_LCLK_PLLS,\n\t\t\t\trb + CT2_CSI_FW_CTL_SET_REG);\n\n\t\tfor (i = 0; i < BFA_IOC_PLL_POLL; i++) {\n\t\t\tr32 = readl(rb + CT2_APP_PLL_LCLK_CTL_REG);\n\t\t\tif (r32 & __RESET_AND_START_SCLK_LCLK_PLLS)\n\t\t\t\tbreak;\n\t\t}\n\t\tBUG_ON(!(r32 & __RESET_AND_START_SCLK_LCLK_PLLS));\n\n\t\tfor (i = 0; i < BFA_IOC_PLL_POLL; i++) {\n\t\t\tr32 = readl(rb + CT2_APP_PLL_LCLK_CTL_REG);\n\t\t\tif (!(r32 & __RESET_AND_START_SCLK_LCLK_PLLS))\n\t\t\t\tbreak;\n\t\t}\n\t\tBUG_ON(r32 & __RESET_AND_START_SCLK_LCLK_PLLS);\n\t\tudelay(1000);\n\n\t\tr32 = readl(rb + CT2_CSI_FW_CTL_REG);\n\t\tBUG_ON(r32 & __RESET_AND_START_SCLK_LCLK_PLLS);\n\t} else {\n\t\twritel(__HALT_NFC_CONTROLLER, (rb + CT2_NFC_CSR_SET_REG));\n\t\tfor (i = 0; i < CT2_NFC_MAX_DELAY; i++) {\n\t\t\tr32 = readl(rb + CT2_NFC_CSR_SET_REG);\n\t\t\tif (r32 & __NFC_CONTROLLER_HALTED)\n\t\t\t\tbreak;\n\t\t\tudelay(1000);\n\t\t}\n\n\t\tbfa_ioc_ct2_mac_reset(rb);\n\t\tbfa_ioc_ct2_sclk_init(rb);\n\t\tbfa_ioc_ct2_lclk_init(rb);\n\n\t\t \n\t\tr32 = readl(rb + CT2_APP_PLL_SCLK_CTL_REG);\n\t\twritel(r32 & ~__APP_PLL_SCLK_LOGIC_SOFT_RESET,\n\t\t\t\trb + CT2_APP_PLL_SCLK_CTL_REG);\n\t\tr32 = readl(rb + CT2_APP_PLL_LCLK_CTL_REG);\n\t\twritel(r32 & ~__APP_PLL_LCLK_LOGIC_SOFT_RESET,\n\t\t\t\trb + CT2_APP_PLL_LCLK_CTL_REG);\n\t}\n\n\t \n\tif (wgn == (__WGN_READY | __GLBL_PF_VF_CFG_RDY)) {\n\t\tr32 = readl(rb + PSS_GPIO_OUT_REG);\n\t\twritel(r32 & ~1, rb + PSS_GPIO_OUT_REG);\n\t\tr32 = readl(rb + PSS_GPIO_OE_REG);\n\t\twritel(r32 | 1, rb + PSS_GPIO_OE_REG);\n\t}\n\n\t \n\twritel(1, rb + CT2_LPU0_HOSTFN_MBOX0_MSK);\n\twritel(1, rb + CT2_LPU1_HOSTFN_MBOX0_MSK);\n\n\t \n\tr32 = readl(rb + HOST_SEM5_REG);\n\tif (r32 & 0x1) {\n\t\tr32 = readl(rb + CT2_LPU0_HOSTFN_CMD_STAT);\n\t\tif (r32 == 1) {\n\t\t\twritel(1, rb + CT2_LPU0_HOSTFN_CMD_STAT);\n\t\t\treadl(rb + CT2_LPU0_HOSTFN_CMD_STAT);\n\t\t}\n\t\tr32 = readl(rb + CT2_LPU1_HOSTFN_CMD_STAT);\n\t\tif (r32 == 1) {\n\t\t\twritel(1, rb + CT2_LPU1_HOSTFN_CMD_STAT);\n\t\t\treadl(rb + CT2_LPU1_HOSTFN_CMD_STAT);\n\t\t}\n\t}\n\n\tbfa_ioc_ct2_mem_init(rb);\n\n\twritel(BFI_IOC_UNINIT, rb + CT2_BFA_IOC0_STATE_REG);\n\twritel(BFI_IOC_UNINIT, rb + CT2_BFA_IOC1_STATE_REG);\n\treturn BFA_STATUS_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}