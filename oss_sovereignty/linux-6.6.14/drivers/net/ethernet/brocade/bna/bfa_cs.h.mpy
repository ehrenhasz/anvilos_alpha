{
  "module_name": "bfa_cs.h",
  "hash_id": "8bf819517cd0bf2ecb09837b874ed2470c16f9ce14f64c5eb63fb94a3f10c125",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/brocade/bna/bfa_cs.h",
  "human_readable_source": " \n \n \n\n \n\n#ifndef __BFA_CS_H__\n#define __BFA_CS_H__\n\n#include \"cna.h\"\n\n \n\n \n#define BFA_SM_TABLE(n, s, e, t)\t\t\t\t\\\nstruct s;\t\t\t\t\t\t\t\\\nenum e;\t\t\t\t\t\t\t\t\\\ntypedef void (*t)(struct s *, enum e);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\nstruct n ## _sm_table_s {\t\t\t\t\t\\\n\tt\t\tsm;\t \t\\\n\tint\t\tstate;\t \t\\\n\tchar\t\t*name;\t \t\\\n};\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\nstatic inline int\t\t\t\t\t\t\\\nn ## _sm_to_state(struct n ## _sm_table_s *smt, t sm)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tint\ti = 0;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\twhile (smt[i].sm && smt[i].sm != sm)\t\t\t\\\n\t\ti++;\t\t\t\t\t\t\\\n\treturn smt[i].state;\t\t\t\t\t\\\n}\n\nBFA_SM_TABLE(iocpf,\tbfa_iocpf,\tiocpf_event,\tbfa_fsm_iocpf_t)\nBFA_SM_TABLE(ioc,\tbfa_ioc,\tioc_event,\tbfa_fsm_ioc_t)\nBFA_SM_TABLE(cmdq,\tbfa_msgq_cmdq,\tcmdq_event,\tbfa_fsm_msgq_cmdq_t)\nBFA_SM_TABLE(rspq,\tbfa_msgq_rspq,\trspq_event,\tbfa_fsm_msgq_rspq_t)\n\nBFA_SM_TABLE(ioceth,\tbna_ioceth,\tbna_ioceth_event, bna_fsm_ioceth_t)\nBFA_SM_TABLE(enet,\tbna_enet,\tbna_enet_event, bna_fsm_enet_t)\nBFA_SM_TABLE(ethport,\tbna_ethport,\tbna_ethport_event, bna_fsm_ethport_t)\nBFA_SM_TABLE(tx,\tbna_tx,\t\tbna_tx_event,\tbna_fsm_tx_t)\nBFA_SM_TABLE(rxf,\tbna_rxf,\tbna_rxf_event, bna_fsm_rxf_t)\nBFA_SM_TABLE(rx,\tbna_rx,\t\tbna_rx_event,\tbna_fsm_rx_t)\n\n#undef BFA_SM_TABLE\n\n#define BFA_SM(_sm)\t(_sm)\n\n \ntypedef void (*bfa_fsm_t)(void *fsm, int event);\n\n \n#define bfa_fsm_state_decl(oc, st, otype, etype)\t\t\t\\\n\tstatic void oc ## _sm_ ## st(otype * fsm, etype event);\t\t\\\n\tstatic void oc ## _sm_ ## st ## _entry(otype * fsm)\n\n#define bfa_fsm_set_state(_fsm, _state) do {\t\t\t\t\\\n\t(_fsm)->fsm = (_state);\t\t\t\t\t\t\\\n\t_state ## _entry(_fsm);\t\t\t\t\t\t\\\n} while (0)\n\n#define bfa_fsm_send_event(_fsm, _event)\t((_fsm)->fsm((_fsm), (_event)))\n#define bfa_fsm_cmp_state(_fsm, _state)\t\t((_fsm)->fsm == (_state))\n \n\ntypedef void (*bfa_wc_resume_t) (void *cbarg);\n\nstruct bfa_wc {\n\tbfa_wc_resume_t wc_resume;\n\tvoid\t\t*wc_cbarg;\n\tint\t\twc_count;\n};\n\nstatic inline void\nbfa_wc_up(struct bfa_wc *wc)\n{\n\twc->wc_count++;\n}\n\nstatic inline void\nbfa_wc_down(struct bfa_wc *wc)\n{\n\twc->wc_count--;\n\tif (wc->wc_count == 0)\n\t\twc->wc_resume(wc->wc_cbarg);\n}\n\n \nstatic inline void\nbfa_wc_init(struct bfa_wc *wc, bfa_wc_resume_t wc_resume, void *wc_cbarg)\n{\n\twc->wc_resume = wc_resume;\n\twc->wc_cbarg = wc_cbarg;\n\twc->wc_count = 0;\n\tbfa_wc_up(wc);\n}\n\n \nstatic inline void\nbfa_wc_wait(struct bfa_wc *wc)\n{\n\tbfa_wc_down(wc);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}