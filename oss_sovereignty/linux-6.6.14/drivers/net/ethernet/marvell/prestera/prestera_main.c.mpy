{
  "module_name": "prestera_main.c",
  "hash_id": "05d168d13c6d58b675e6ed924ceca3545f200565a44c561247b2103813add1e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/prestera/prestera_main.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/jiffies.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/netdev_features.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/if_vlan.h>\n#include <linux/phylink.h>\n\n#include \"prestera.h\"\n#include \"prestera_hw.h\"\n#include \"prestera_acl.h\"\n#include \"prestera_flow.h\"\n#include \"prestera_span.h\"\n#include \"prestera_rxtx.h\"\n#include \"prestera_devlink.h\"\n#include \"prestera_ethtool.h\"\n#include \"prestera_counter.h\"\n#include \"prestera_switchdev.h\"\n\n#define PRESTERA_MTU_DEFAULT\t1536\n\n#define PRESTERA_STATS_DELAY_MS\t1000\n\n#define PRESTERA_MAC_ADDR_NUM_MAX\t255\n\nstatic struct workqueue_struct *prestera_wq;\nstatic struct workqueue_struct *prestera_owq;\n\nvoid prestera_queue_work(struct work_struct *work)\n{\n\tqueue_work(prestera_owq, work);\n}\n\nvoid prestera_queue_delayed_work(struct delayed_work *work, unsigned long delay)\n{\n\tqueue_delayed_work(prestera_wq, work, delay);\n}\n\nvoid prestera_queue_drain(void)\n{\n\tdrain_workqueue(prestera_wq);\n\tdrain_workqueue(prestera_owq);\n}\n\nint prestera_port_learning_set(struct prestera_port *port, bool learn)\n{\n\treturn prestera_hw_port_learning_set(port, learn);\n}\n\nint prestera_port_uc_flood_set(struct prestera_port *port, bool flood)\n{\n\treturn prestera_hw_port_uc_flood_set(port, flood);\n}\n\nint prestera_port_mc_flood_set(struct prestera_port *port, bool flood)\n{\n\treturn prestera_hw_port_mc_flood_set(port, flood);\n}\n\nint prestera_port_br_locked_set(struct prestera_port *port, bool br_locked)\n{\n\treturn prestera_hw_port_br_locked_set(port, br_locked);\n}\n\nint prestera_port_pvid_set(struct prestera_port *port, u16 vid)\n{\n\tenum prestera_accept_frm_type frm_type;\n\tint err;\n\n\tfrm_type = PRESTERA_ACCEPT_FRAME_TYPE_TAGGED;\n\n\tif (vid) {\n\t\terr = prestera_hw_vlan_port_vid_set(port, vid);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfrm_type = PRESTERA_ACCEPT_FRAME_TYPE_ALL;\n\t}\n\n\terr = prestera_hw_port_accept_frm_type(port, frm_type);\n\tif (err && frm_type == PRESTERA_ACCEPT_FRAME_TYPE_ALL)\n\t\tprestera_hw_vlan_port_vid_set(port, port->pvid);\n\n\tport->pvid = vid;\n\treturn 0;\n}\n\nstruct prestera_port *prestera_port_find_by_hwid(struct prestera_switch *sw,\n\t\t\t\t\t\t u32 dev_id, u32 hw_id)\n{\n\tstruct prestera_port *port = NULL, *tmp;\n\n\tread_lock(&sw->port_list_lock);\n\tlist_for_each_entry(tmp, &sw->port_list, list) {\n\t\tif (tmp->dev_id == dev_id && tmp->hw_id == hw_id) {\n\t\t\tport = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&sw->port_list_lock);\n\n\treturn port;\n}\n\nstruct prestera_port *prestera_find_port(struct prestera_switch *sw, u32 id)\n{\n\tstruct prestera_port *port = NULL, *tmp;\n\n\tread_lock(&sw->port_list_lock);\n\tlist_for_each_entry(tmp, &sw->port_list, list) {\n\t\tif (tmp->id == id) {\n\t\t\tport = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&sw->port_list_lock);\n\n\treturn port;\n}\n\nstruct prestera_switch *prestera_switch_get(struct net_device *dev)\n{\n\tstruct prestera_port *port;\n\n\tport = prestera_port_dev_lower_find(dev);\n\treturn port ? port->sw : NULL;\n}\n\nint prestera_port_cfg_mac_read(struct prestera_port *port,\n\t\t\t       struct prestera_port_mac_config *cfg)\n{\n\t*cfg = port->cfg_mac;\n\treturn 0;\n}\n\nint prestera_port_cfg_mac_write(struct prestera_port *port,\n\t\t\t\tstruct prestera_port_mac_config *cfg)\n{\n\tint err;\n\n\terr = prestera_hw_port_mac_mode_set(port, cfg->admin,\n\t\t\t\t\t    cfg->mode, cfg->inband, cfg->speed,\n\t\t\t\t\t    cfg->duplex, cfg->fec);\n\tif (err)\n\t\treturn err;\n\n\tport->cfg_mac = *cfg;\n\treturn 0;\n}\n\nstatic int prestera_port_open(struct net_device *dev)\n{\n\tstruct prestera_port *port = netdev_priv(dev);\n\tstruct prestera_port_mac_config cfg_mac;\n\tint err = 0;\n\n\tif (port->phy_link) {\n\t\tphylink_start(port->phy_link);\n\t} else {\n\t\tif (port->caps.transceiver == PRESTERA_PORT_TCVR_SFP) {\n\t\t\terr = prestera_port_cfg_mac_read(port, &cfg_mac);\n\t\t\tif (!err) {\n\t\t\t\tcfg_mac.admin = true;\n\t\t\t\terr = prestera_port_cfg_mac_write(port,\n\t\t\t\t\t\t\t\t  &cfg_mac);\n\t\t\t}\n\t\t} else {\n\t\t\tport->cfg_phy.admin = true;\n\t\t\terr = prestera_hw_port_phy_mode_set(port, true,\n\t\t\t\t\t\t\t    port->autoneg,\n\t\t\t\t\t\t\t    port->cfg_phy.mode,\n\t\t\t\t\t\t\t    port->adver_link_modes,\n\t\t\t\t\t\t\t    port->cfg_phy.mdix);\n\t\t}\n\t}\n\n\tnetif_start_queue(dev);\n\n\treturn err;\n}\n\nstatic int prestera_port_close(struct net_device *dev)\n{\n\tstruct prestera_port *port = netdev_priv(dev);\n\tstruct prestera_port_mac_config cfg_mac;\n\tint err = 0;\n\n\tnetif_stop_queue(dev);\n\n\tif (port->phy_link) {\n\t\tphylink_stop(port->phy_link);\n\t\tphylink_disconnect_phy(port->phy_link);\n\t\terr = prestera_port_cfg_mac_read(port, &cfg_mac);\n\t\tif (!err) {\n\t\t\tcfg_mac.admin = false;\n\t\t\tprestera_port_cfg_mac_write(port, &cfg_mac);\n\t\t}\n\t} else {\n\t\tif (port->caps.transceiver == PRESTERA_PORT_TCVR_SFP) {\n\t\t\terr = prestera_port_cfg_mac_read(port, &cfg_mac);\n\t\t\tif (!err) {\n\t\t\t\tcfg_mac.admin = false;\n\t\t\t\tprestera_port_cfg_mac_write(port, &cfg_mac);\n\t\t\t}\n\t\t} else {\n\t\t\tport->cfg_phy.admin = false;\n\t\t\terr = prestera_hw_port_phy_mode_set(port, false, port->autoneg,\n\t\t\t\t\t\t\t    port->cfg_phy.mode,\n\t\t\t\t\t\t\t    port->adver_link_modes,\n\t\t\t\t\t\t\t    port->cfg_phy.mdix);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic void\nprestera_port_mac_state_cache_read(struct prestera_port *port,\n\t\t\t\t   struct prestera_port_mac_state *state)\n{\n\tspin_lock(&port->state_mac_lock);\n\t*state = port->state_mac;\n\tspin_unlock(&port->state_mac_lock);\n}\n\nstatic void\nprestera_port_mac_state_cache_write(struct prestera_port *port,\n\t\t\t\t    struct prestera_port_mac_state *state)\n{\n\tspin_lock(&port->state_mac_lock);\n\tport->state_mac = *state;\n\tspin_unlock(&port->state_mac_lock);\n}\n\nstatic struct prestera_port *prestera_pcs_to_port(struct phylink_pcs *pcs)\n{\n\treturn container_of(pcs, struct prestera_port, phylink_pcs);\n}\n\nstatic void prestera_mac_config(struct phylink_config *config,\n\t\t\t\tunsigned int an_mode,\n\t\t\t\tconst struct phylink_link_state *state)\n{\n}\n\nstatic void prestera_mac_link_down(struct phylink_config *config,\n\t\t\t\t   unsigned int mode, phy_interface_t interface)\n{\n\tstruct net_device *ndev = to_net_dev(config->dev);\n\tstruct prestera_port *port = netdev_priv(ndev);\n\tstruct prestera_port_mac_state state_mac;\n\n\t \n\tmemset(&state_mac, 0, sizeof(state_mac));\n\tstate_mac.valid = false;\n\tprestera_port_mac_state_cache_write(port, &state_mac);\n}\n\nstatic void prestera_mac_link_up(struct phylink_config *config,\n\t\t\t\t struct phy_device *phy,\n\t\t\t\t unsigned int mode, phy_interface_t interface,\n\t\t\t\t int speed, int duplex,\n\t\t\t\t bool tx_pause, bool rx_pause)\n{\n}\n\nstatic struct phylink_pcs *\nprestera_mac_select_pcs(struct phylink_config *config,\n\t\t\tphy_interface_t interface)\n{\n\tstruct net_device *dev = to_net_dev(config->dev);\n\tstruct prestera_port *port = netdev_priv(dev);\n\n\treturn &port->phylink_pcs;\n}\n\nstatic void prestera_pcs_get_state(struct phylink_pcs *pcs,\n\t\t\t\t   struct phylink_link_state *state)\n{\n\tstruct prestera_port *port = container_of(pcs, struct prestera_port,\n\t\t\t\t\t\t  phylink_pcs);\n\tstruct prestera_port_mac_state smac;\n\n\tprestera_port_mac_state_cache_read(port, &smac);\n\n\tif (smac.valid) {\n\t\tstate->link = smac.oper ? 1 : 0;\n\t\t \n\t\tstate->an_complete = (smac.oper && port->autoneg) ? 1 : 0;\n\t\tstate->speed = smac.speed;\n\t\tstate->duplex = smac.duplex;\n\t} else {\n\t\tstate->link = 0;\n\t\tstate->an_complete = 0;\n\t}\n}\n\nstatic int prestera_pcs_config(struct phylink_pcs *pcs, unsigned int neg_mode,\n\t\t\t       phy_interface_t interface,\n\t\t\t       const unsigned long *advertising,\n\t\t\t       bool permit_pause_to_mac)\n{\n\tstruct prestera_port *port = prestera_pcs_to_port(pcs);\n\tstruct prestera_port_mac_config cfg_mac;\n\tint err;\n\n\terr = prestera_port_cfg_mac_read(port, &cfg_mac);\n\tif (err)\n\t\treturn err;\n\n\tcfg_mac.admin = true;\n\tcfg_mac.fec = PRESTERA_PORT_FEC_OFF;\n\tcfg_mac.inband = neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED;\n\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\tcfg_mac.speed = SPEED_10000;\n\t\tcfg_mac.mode = PRESTERA_MAC_MODE_SR_LR;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\tcfg_mac.speed = SPEED_2500;\n\t\tcfg_mac.duplex = DUPLEX_FULL;\n\t\tcfg_mac.mode = PRESTERA_MAC_MODE_SGMII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tcfg_mac.mode = PRESTERA_MAC_MODE_SGMII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tdefault:\n\t\tcfg_mac.speed = SPEED_1000;\n\t\tcfg_mac.duplex = DUPLEX_FULL;\n\t\tcfg_mac.mode = PRESTERA_MAC_MODE_1000BASE_X;\n\t\tbreak;\n\t}\n\n\terr = prestera_port_cfg_mac_write(port, &cfg_mac);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void prestera_pcs_an_restart(struct phylink_pcs *pcs)\n{\n\t \n}\n\nstatic const struct phylink_mac_ops prestera_mac_ops = {\n\t.mac_select_pcs = prestera_mac_select_pcs,\n\t.mac_config = prestera_mac_config,\n\t.mac_link_down = prestera_mac_link_down,\n\t.mac_link_up = prestera_mac_link_up,\n};\n\nstatic const struct phylink_pcs_ops prestera_pcs_ops = {\n\t.pcs_get_state = prestera_pcs_get_state,\n\t.pcs_config = prestera_pcs_config,\n\t.pcs_an_restart = prestera_pcs_an_restart,\n};\n\nstatic int prestera_port_sfp_bind(struct prestera_port *port)\n{\n\tstruct prestera_switch *sw = port->sw;\n\tstruct device_node *ports, *node;\n\tstruct fwnode_handle *fwnode;\n\tstruct phylink *phy_link;\n\tint err;\n\n\tif (!sw->np)\n\t\treturn 0;\n\n\tof_node_get(sw->np);\n\tports = of_find_node_by_name(sw->np, \"ports\");\n\n\tfor_each_child_of_node(ports, node) {\n\t\tint num;\n\n\t\terr = of_property_read_u32(node, \"prestera,port-num\", &num);\n\t\tif (err) {\n\t\t\tdev_err(sw->dev->dev,\n\t\t\t\t\"device node %pOF has no valid reg property: %d\\n\",\n\t\t\t\tnode, err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (port->fp_id != num)\n\t\t\tcontinue;\n\n\t\tport->phylink_pcs.ops = &prestera_pcs_ops;\n\t\tport->phylink_pcs.neg_mode = true;\n\n\t\tport->phy_config.dev = &port->dev->dev;\n\t\tport->phy_config.type = PHYLINK_NETDEV;\n\n\t\tfwnode = of_fwnode_handle(node);\n\n\t\t__set_bit(PHY_INTERFACE_MODE_10GBASER,\n\t\t\t  port->phy_config.supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_2500BASEX,\n\t\t\t  port->phy_config.supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_SGMII,\n\t\t\t  port->phy_config.supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX,\n\t\t\t  port->phy_config.supported_interfaces);\n\n\t\tport->phy_config.mac_capabilities =\n\t\t\tMAC_1000 | MAC_2500FD | MAC_10000FD;\n\n\t\tphy_link = phylink_create(&port->phy_config, fwnode,\n\t\t\t\t\t  PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t\t\t  &prestera_mac_ops);\n\t\tif (IS_ERR(phy_link)) {\n\t\t\tnetdev_err(port->dev, \"failed to create phylink\\n\");\n\t\t\terr = PTR_ERR(phy_link);\n\t\t\tgoto out;\n\t\t}\n\n\t\tport->phy_link = phy_link;\n\t\tbreak;\n\t}\n\nout:\n\tof_node_put(node);\n\tof_node_put(ports);\n\treturn err;\n}\n\nstatic int prestera_port_sfp_unbind(struct prestera_port *port)\n{\n\tif (port->phy_link)\n\t\tphylink_destroy(port->phy_link);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t prestera_port_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\treturn prestera_rxtx_xmit(netdev_priv(dev), skb);\n}\n\nint prestera_is_valid_mac_addr(struct prestera_port *port, const u8 *addr)\n{\n\tif (!is_valid_ether_addr(addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\t \n\tif (memcmp(port->sw->base_mac, addr, ETH_ALEN - 1))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int prestera_port_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct prestera_port *port = netdev_priv(dev);\n\tstruct sockaddr *addr = p;\n\tint err;\n\n\terr = prestera_is_valid_mac_addr(port, addr->sa_data);\n\tif (err)\n\t\treturn err;\n\n\terr = prestera_hw_port_mac_set(port, addr->sa_data);\n\tif (err)\n\t\treturn err;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\treturn 0;\n}\n\nstatic int prestera_port_change_mtu(struct net_device *dev, int mtu)\n{\n\tstruct prestera_port *port = netdev_priv(dev);\n\tint err;\n\n\terr = prestera_hw_port_mtu_set(port, mtu);\n\tif (err)\n\t\treturn err;\n\n\tdev->mtu = mtu;\n\n\treturn 0;\n}\n\nstatic void prestera_port_get_stats64(struct net_device *dev,\n\t\t\t\t      struct rtnl_link_stats64 *stats)\n{\n\tstruct prestera_port *port = netdev_priv(dev);\n\tstruct prestera_port_stats *port_stats = &port->cached_hw_stats.stats;\n\n\tstats->rx_packets = port_stats->broadcast_frames_received +\n\t\t\t\tport_stats->multicast_frames_received +\n\t\t\t\tport_stats->unicast_frames_received;\n\n\tstats->tx_packets = port_stats->broadcast_frames_sent +\n\t\t\t\tport_stats->multicast_frames_sent +\n\t\t\t\tport_stats->unicast_frames_sent;\n\n\tstats->rx_bytes = port_stats->good_octets_received;\n\n\tstats->tx_bytes = port_stats->good_octets_sent;\n\n\tstats->rx_errors = port_stats->rx_error_frame_received;\n\tstats->tx_errors = port_stats->mac_trans_error;\n\n\tstats->rx_dropped = port_stats->buffer_overrun;\n\tstats->tx_dropped = 0;\n\n\tstats->multicast = port_stats->multicast_frames_received;\n\tstats->collisions = port_stats->excessive_collision;\n\n\tstats->rx_crc_errors = port_stats->bad_crc;\n}\n\nstatic void prestera_port_get_hw_stats(struct prestera_port *port)\n{\n\tprestera_hw_port_stats_get(port, &port->cached_hw_stats.stats);\n}\n\nstatic void prestera_port_stats_update(struct work_struct *work)\n{\n\tstruct prestera_port *port =\n\t\tcontainer_of(work, struct prestera_port,\n\t\t\t     cached_hw_stats.caching_dw.work);\n\n\tprestera_port_get_hw_stats(port);\n\n\tqueue_delayed_work(prestera_wq, &port->cached_hw_stats.caching_dw,\n\t\t\t   msecs_to_jiffies(PRESTERA_STATS_DELAY_MS));\n}\n\nstatic int prestera_port_setup_tc(struct net_device *dev,\n\t\t\t\t  enum tc_setup_type type,\n\t\t\t\t  void *type_data)\n{\n\tstruct prestera_port *port = netdev_priv(dev);\n\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK:\n\t\treturn prestera_flow_block_setup(port, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct net_device_ops prestera_netdev_ops = {\n\t.ndo_open = prestera_port_open,\n\t.ndo_stop = prestera_port_close,\n\t.ndo_start_xmit = prestera_port_xmit,\n\t.ndo_setup_tc = prestera_port_setup_tc,\n\t.ndo_change_mtu = prestera_port_change_mtu,\n\t.ndo_get_stats64 = prestera_port_get_stats64,\n\t.ndo_set_mac_address = prestera_port_set_mac_address,\n};\n\nint prestera_port_autoneg_set(struct prestera_port *port, u64 link_modes)\n{\n\tint err;\n\n\tif (port->autoneg && port->adver_link_modes == link_modes)\n\t\treturn 0;\n\n\terr = prestera_hw_port_phy_mode_set(port, port->cfg_phy.admin,\n\t\t\t\t\t    true, 0, link_modes,\n\t\t\t\t\t    port->cfg_phy.mdix);\n\tif (err)\n\t\treturn err;\n\n\tport->adver_fec = BIT(PRESTERA_PORT_FEC_OFF);\n\tport->adver_link_modes = link_modes;\n\tport->cfg_phy.mode = 0;\n\tport->autoneg = true;\n\n\treturn 0;\n}\n\nstatic void prestera_port_list_add(struct prestera_port *port)\n{\n\twrite_lock(&port->sw->port_list_lock);\n\tlist_add(&port->list, &port->sw->port_list);\n\twrite_unlock(&port->sw->port_list_lock);\n}\n\nstatic void prestera_port_list_del(struct prestera_port *port)\n{\n\twrite_lock(&port->sw->port_list_lock);\n\tlist_del(&port->list);\n\twrite_unlock(&port->sw->port_list_lock);\n}\n\nstatic int prestera_port_create(struct prestera_switch *sw, u32 id)\n{\n\tstruct prestera_port_mac_config cfg_mac;\n\tstruct prestera_port *port;\n\tstruct net_device *dev;\n\tint err;\n\n\tdev = alloc_etherdev(sizeof(*port));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tport = netdev_priv(dev);\n\n\tINIT_LIST_HEAD(&port->vlans_list);\n\tport->pvid = PRESTERA_DEFAULT_VID;\n\tport->lag = NULL;\n\tport->dev = dev;\n\tport->id = id;\n\tport->sw = sw;\n\n\tspin_lock_init(&port->state_mac_lock);\n\n\terr = prestera_hw_port_info_get(port, &port->dev_id, &port->hw_id,\n\t\t\t\t\t&port->fp_id);\n\tif (err) {\n\t\tdev_err(prestera_dev(sw), \"Failed to get port(%u) info\\n\", id);\n\t\tgoto err_port_info_get;\n\t}\n\n\terr = prestera_devlink_port_register(port);\n\tif (err)\n\t\tgoto err_dl_port_register;\n\n\tdev->features |= NETIF_F_NETNS_LOCAL | NETIF_F_HW_TC;\n\tdev->netdev_ops = &prestera_netdev_ops;\n\tdev->ethtool_ops = &prestera_ethtool_ops;\n\tSET_NETDEV_DEV(dev, sw->dev->dev);\n\tSET_NETDEV_DEVLINK_PORT(dev, &port->dl_port);\n\n\tif (port->caps.transceiver != PRESTERA_PORT_TCVR_SFP)\n\t\tnetif_carrier_off(dev);\n\n\tdev->mtu = min_t(unsigned int, sw->mtu_max, PRESTERA_MTU_DEFAULT);\n\tdev->min_mtu = sw->mtu_min;\n\tdev->max_mtu = sw->mtu_max;\n\n\terr = prestera_hw_port_mtu_set(port, dev->mtu);\n\tif (err) {\n\t\tdev_err(prestera_dev(sw), \"Failed to set port(%u) mtu(%d)\\n\",\n\t\t\tid, dev->mtu);\n\t\tgoto err_port_init;\n\t}\n\n\tif (port->fp_id >= PRESTERA_MAC_ADDR_NUM_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto err_port_init;\n\t}\n\n\teth_hw_addr_gen(dev, sw->base_mac, port->fp_id);\n\t \n\tif (memcmp(dev->dev_addr, sw->base_mac, ETH_ALEN - 1)) {\n\t\tdev_warn(prestera_dev(sw), \"Port MAC address wraps for port(%u)\\n\", id);\n\t\tdev_addr_mod(dev, 0, sw->base_mac, ETH_ALEN - 1);\n\t}\n\n\terr = prestera_hw_port_mac_set(port, dev->dev_addr);\n\tif (err) {\n\t\tdev_err(prestera_dev(sw), \"Failed to set port(%u) mac addr\\n\", id);\n\t\tgoto err_port_init;\n\t}\n\n\terr = prestera_hw_port_cap_get(port, &port->caps);\n\tif (err) {\n\t\tdev_err(prestera_dev(sw), \"Failed to get port(%u) caps\\n\", id);\n\t\tgoto err_port_init;\n\t}\n\n\tport->adver_link_modes = port->caps.supp_link_modes;\n\tport->adver_fec = 0;\n\tport->autoneg = true;\n\n\t \n\tif (port->caps.transceiver != PRESTERA_PORT_TCVR_SFP) {\n\t\tcfg_mac.admin = true;\n\t\tcfg_mac.mode = PRESTERA_MAC_MODE_INTERNAL;\n\t} else {\n\t\tcfg_mac.admin = false;\n\t\tcfg_mac.mode = PRESTERA_MAC_MODE_MAX;\n\t}\n\tcfg_mac.inband = 0;\n\tcfg_mac.speed = 0;\n\tcfg_mac.duplex = DUPLEX_UNKNOWN;\n\tcfg_mac.fec = PRESTERA_PORT_FEC_OFF;\n\n\terr = prestera_port_cfg_mac_write(port, &cfg_mac);\n\tif (err) {\n\t\tdev_err(prestera_dev(sw),\n\t\t\t\"Failed to set port(%u) mac mode\\n\", id);\n\t\tgoto err_port_init;\n\t}\n\n\t \n\tif (port->caps.transceiver != PRESTERA_PORT_TCVR_SFP) {\n\t\tport->cfg_phy.mdix = ETH_TP_MDI_AUTO;\n\t\tport->cfg_phy.admin = false;\n\t\terr = prestera_hw_port_phy_mode_set(port,\n\t\t\t\t\t\t    port->cfg_phy.admin,\n\t\t\t\t\t\t    false, 0, 0,\n\t\t\t\t\t\t    port->cfg_phy.mdix);\n\t\tif (err) {\n\t\t\tdev_err(prestera_dev(sw),\n\t\t\t\t\"Failed to set port(%u) phy mode\\n\", id);\n\t\t\tgoto err_port_init;\n\t\t}\n\t}\n\n\terr = prestera_rxtx_port_init(port);\n\tif (err)\n\t\tgoto err_port_init;\n\n\tINIT_DELAYED_WORK(&port->cached_hw_stats.caching_dw,\n\t\t\t  &prestera_port_stats_update);\n\n\tprestera_port_list_add(port);\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto err_register_netdev;\n\n\terr = prestera_port_sfp_bind(port);\n\tif (err)\n\t\tgoto err_sfp_bind;\n\n\treturn 0;\n\nerr_sfp_bind:\n\tunregister_netdev(dev);\nerr_register_netdev:\n\tprestera_port_list_del(port);\nerr_port_init:\n\tprestera_devlink_port_unregister(port);\nerr_dl_port_register:\nerr_port_info_get:\n\tfree_netdev(dev);\n\treturn err;\n}\n\nstatic void prestera_port_destroy(struct prestera_port *port)\n{\n\tstruct net_device *dev = port->dev;\n\n\tcancel_delayed_work_sync(&port->cached_hw_stats.caching_dw);\n\tunregister_netdev(dev);\n\tprestera_port_list_del(port);\n\tprestera_devlink_port_unregister(port);\n\tfree_netdev(dev);\n}\n\nstatic void prestera_destroy_ports(struct prestera_switch *sw)\n{\n\tstruct prestera_port *port, *tmp;\n\n\tlist_for_each_entry_safe(port, tmp, &sw->port_list, list)\n\t\tprestera_port_destroy(port);\n}\n\nstatic int prestera_create_ports(struct prestera_switch *sw)\n{\n\tstruct prestera_port *port, *tmp;\n\tu32 port_idx;\n\tint err;\n\n\tfor (port_idx = 0; port_idx < sw->port_count; port_idx++) {\n\t\terr = prestera_port_create(sw, port_idx);\n\t\tif (err)\n\t\t\tgoto err_port_create;\n\t}\n\n\treturn 0;\n\nerr_port_create:\n\tlist_for_each_entry_safe(port, tmp, &sw->port_list, list) {\n\t\tprestera_port_sfp_unbind(port);\n\t\tprestera_port_destroy(port);\n\t}\n\n\treturn err;\n}\n\nstatic void prestera_port_handle_event(struct prestera_switch *sw,\n\t\t\t\t       struct prestera_event *evt, void *arg)\n{\n\tstruct prestera_port_mac_state smac;\n\tstruct prestera_port_event *pevt;\n\tstruct delayed_work *caching_dw;\n\tstruct prestera_port *port;\n\n\tif (evt->id == PRESTERA_PORT_EVENT_MAC_STATE_CHANGED) {\n\t\tpevt = &evt->port_evt;\n\t\tport = prestera_find_port(sw, pevt->port_id);\n\t\tif (!port || !port->dev)\n\t\t\treturn;\n\n\t\tcaching_dw = &port->cached_hw_stats.caching_dw;\n\n\t\tmemset(&smac, 0, sizeof(smac));\n\t\tsmac.valid = true;\n\t\tsmac.oper = pevt->data.mac.oper;\n\t\tif (smac.oper) {\n\t\t\tsmac.mode = pevt->data.mac.mode;\n\t\t\tsmac.speed = pevt->data.mac.speed;\n\t\t\tsmac.duplex = pevt->data.mac.duplex;\n\t\t\tsmac.fc = pevt->data.mac.fc;\n\t\t\tsmac.fec = pevt->data.mac.fec;\n\t\t}\n\t\tprestera_port_mac_state_cache_write(port, &smac);\n\n\t\tif (port->state_mac.oper) {\n\t\t\tif (port->phy_link)\n\t\t\t\tphylink_mac_change(port->phy_link, true);\n\t\t\telse\n\t\t\t\tnetif_carrier_on(port->dev);\n\n\t\t\tif (!delayed_work_pending(caching_dw))\n\t\t\t\tqueue_delayed_work(prestera_wq, caching_dw, 0);\n\t\t} else {\n\t\t\tif (port->phy_link)\n\t\t\t\tphylink_mac_change(port->phy_link, false);\n\t\t\telse if (netif_running(port->dev) && netif_carrier_ok(port->dev))\n\t\t\t\tnetif_carrier_off(port->dev);\n\n\t\t\tif (delayed_work_pending(caching_dw))\n\t\t\t\tcancel_delayed_work(caching_dw);\n\t\t}\n\t}\n}\n\nstatic int prestera_event_handlers_register(struct prestera_switch *sw)\n{\n\treturn prestera_hw_event_handler_register(sw, PRESTERA_EVENT_TYPE_PORT,\n\t\t\t\t\t\t  prestera_port_handle_event,\n\t\t\t\t\t\t  NULL);\n}\n\nstatic void prestera_event_handlers_unregister(struct prestera_switch *sw)\n{\n\tprestera_hw_event_handler_unregister(sw, PRESTERA_EVENT_TYPE_PORT,\n\t\t\t\t\t     prestera_port_handle_event);\n}\n\nstatic int prestera_switch_set_base_mac_addr(struct prestera_switch *sw)\n{\n\tint ret;\n\n\tif (sw->np)\n\t\tret = of_get_mac_address(sw->np, sw->base_mac);\n\tif (!is_valid_ether_addr(sw->base_mac) || ret) {\n\t\teth_random_addr(sw->base_mac);\n\t\tdev_info(prestera_dev(sw), \"using random base mac address\\n\");\n\t}\n\n\treturn prestera_hw_switch_mac_set(sw, sw->base_mac);\n}\n\nstruct prestera_lag *prestera_lag_by_id(struct prestera_switch *sw, u16 id)\n{\n\treturn id < sw->lag_max ? &sw->lags[id] : NULL;\n}\n\nstatic struct prestera_lag *prestera_lag_by_dev(struct prestera_switch *sw,\n\t\t\t\t\t\tstruct net_device *dev)\n{\n\tstruct prestera_lag *lag;\n\tu16 id;\n\n\tfor (id = 0; id < sw->lag_max; id++) {\n\t\tlag = &sw->lags[id];\n\t\tif (lag->dev == dev)\n\t\t\treturn lag;\n\t}\n\n\treturn NULL;\n}\n\nint prestera_lag_id(struct prestera_switch *sw,\n\t\t    struct net_device *lag_dev, u16 *lag_id)\n{\n\tstruct prestera_lag *lag;\n\tint free_id = -1;\n\tint id;\n\n\tfor (id = 0; id < sw->lag_max; id++) {\n\t\tlag = prestera_lag_by_id(sw, id);\n\t\tif (lag->member_count) {\n\t\t\tif (lag->dev == lag_dev) {\n\t\t\t\t*lag_id = id;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (free_id < 0) {\n\t\t\tfree_id = id;\n\t\t}\n\t}\n\tif (free_id < 0)\n\t\treturn -ENOSPC;\n\t*lag_id = free_id;\n\treturn 0;\n}\n\nstatic struct prestera_lag *prestera_lag_create(struct prestera_switch *sw,\n\t\t\t\t\t\tstruct net_device *lag_dev)\n{\n\tstruct prestera_lag *lag = NULL;\n\tu16 id;\n\n\tfor (id = 0; id < sw->lag_max; id++) {\n\t\tlag = &sw->lags[id];\n\t\tif (!lag->dev)\n\t\t\tbreak;\n\t}\n\tif (lag) {\n\t\tINIT_LIST_HEAD(&lag->members);\n\t\tlag->dev = lag_dev;\n\t}\n\n\treturn lag;\n}\n\nstatic void prestera_lag_destroy(struct prestera_switch *sw,\n\t\t\t\t struct prestera_lag *lag)\n{\n\tWARN_ON(!list_empty(&lag->members));\n\tlag->member_count = 0;\n\tlag->dev = NULL;\n}\n\nstatic int prestera_lag_port_add(struct prestera_port *port,\n\t\t\t\t struct net_device *lag_dev)\n{\n\tstruct prestera_switch *sw = port->sw;\n\tstruct prestera_lag *lag;\n\tint err;\n\n\tlag = prestera_lag_by_dev(sw, lag_dev);\n\tif (!lag) {\n\t\tlag = prestera_lag_create(sw, lag_dev);\n\t\tif (!lag)\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (lag->member_count >= sw->lag_member_max)\n\t\treturn -ENOSPC;\n\n\terr = prestera_hw_lag_member_add(port, lag->lag_id);\n\tif (err) {\n\t\tif (!lag->member_count)\n\t\t\tprestera_lag_destroy(sw, lag);\n\t\treturn err;\n\t}\n\n\tlist_add(&port->lag_member, &lag->members);\n\tlag->member_count++;\n\tport->lag = lag;\n\n\treturn 0;\n}\n\nstatic int prestera_lag_port_del(struct prestera_port *port)\n{\n\tstruct prestera_switch *sw = port->sw;\n\tstruct prestera_lag *lag = port->lag;\n\tint err;\n\n\tif (!lag || !lag->member_count)\n\t\treturn -EINVAL;\n\n\terr = prestera_hw_lag_member_del(port, lag->lag_id);\n\tif (err)\n\t\treturn err;\n\n\tlist_del(&port->lag_member);\n\tlag->member_count--;\n\tport->lag = NULL;\n\n\tif (netif_is_bridge_port(lag->dev)) {\n\t\tstruct net_device *br_dev;\n\n\t\tbr_dev = netdev_master_upper_dev_get(lag->dev);\n\n\t\tprestera_bridge_port_leave(br_dev, port);\n\t}\n\n\tif (!lag->member_count)\n\t\tprestera_lag_destroy(sw, lag);\n\n\treturn 0;\n}\n\nbool prestera_port_is_lag_member(const struct prestera_port *port)\n{\n\treturn !!port->lag;\n}\n\nu16 prestera_port_lag_id(const struct prestera_port *port)\n{\n\treturn port->lag->lag_id;\n}\n\nstatic int prestera_lag_init(struct prestera_switch *sw)\n{\n\tu16 id;\n\n\tsw->lags = kcalloc(sw->lag_max, sizeof(*sw->lags), GFP_KERNEL);\n\tif (!sw->lags)\n\t\treturn -ENOMEM;\n\n\tfor (id = 0; id < sw->lag_max; id++)\n\t\tsw->lags[id].lag_id = id;\n\n\treturn 0;\n}\n\nstatic void prestera_lag_fini(struct prestera_switch *sw)\n{\n\tu8 idx;\n\n\tfor (idx = 0; idx < sw->lag_max; idx++)\n\t\tWARN_ON(sw->lags[idx].member_count);\n\n\tkfree(sw->lags);\n}\n\nbool prestera_netdev_check(const struct net_device *dev)\n{\n\treturn dev->netdev_ops == &prestera_netdev_ops;\n}\n\nstatic int prestera_lower_dev_walk(struct net_device *dev,\n\t\t\t\t   struct netdev_nested_priv *priv)\n{\n\tstruct prestera_port **pport = (struct prestera_port **)priv->data;\n\n\tif (prestera_netdev_check(dev)) {\n\t\t*pport = netdev_priv(dev);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstruct prestera_port *prestera_port_dev_lower_find(struct net_device *dev)\n{\n\tstruct prestera_port *port = NULL;\n\tstruct netdev_nested_priv priv = {\n\t\t.data = (void *)&port,\n\t};\n\n\tif (prestera_netdev_check(dev))\n\t\treturn netdev_priv(dev);\n\n\tnetdev_walk_all_lower_dev(dev, prestera_lower_dev_walk, &priv);\n\n\treturn port;\n}\n\nstatic int prestera_netdev_port_lower_event(struct net_device *dev,\n\t\t\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct netdev_notifier_changelowerstate_info *info = ptr;\n\tstruct netdev_lag_lower_state_info *lower_state_info;\n\tstruct prestera_port *port = netdev_priv(dev);\n\tbool enabled;\n\n\tif (!netif_is_lag_port(dev))\n\t\treturn 0;\n\tif (!prestera_port_is_lag_member(port))\n\t\treturn 0;\n\n\tlower_state_info = info->lower_state_info;\n\tenabled = lower_state_info->link_up && lower_state_info->tx_enabled;\n\n\treturn prestera_hw_lag_member_enable(port, port->lag->lag_id, enabled);\n}\n\nstatic bool prestera_lag_master_check(struct net_device *lag_dev,\n\t\t\t\t      struct netdev_lag_upper_info *info,\n\t\t\t\t      struct netlink_ext_ack *ext_ack)\n{\n\tif (info->tx_type != NETDEV_LAG_TX_TYPE_HASH) {\n\t\tNL_SET_ERR_MSG_MOD(ext_ack, \"Unsupported LAG Tx type\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int prestera_netdev_port_event(struct net_device *lower,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      unsigned long event, void *ptr)\n{\n\tstruct netdev_notifier_info *info = ptr;\n\tstruct netdev_notifier_changeupper_info *cu_info;\n\tstruct prestera_port *port = netdev_priv(dev);\n\tstruct netlink_ext_ack *extack;\n\tstruct net_device *upper;\n\n\textack = netdev_notifier_info_to_extack(info);\n\tcu_info = container_of(info,\n\t\t\t       struct netdev_notifier_changeupper_info,\n\t\t\t       info);\n\n\tswitch (event) {\n\tcase NETDEV_PRECHANGEUPPER:\n\t\tupper = cu_info->upper_dev;\n\t\tif (!netif_is_bridge_master(upper) &&\n\t\t    !netif_is_lag_master(upper)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unknown upper device type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!cu_info->linking)\n\t\t\tbreak;\n\n\t\tif (netdev_has_any_upper_dev(upper)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Upper device is already enslaved\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (netif_is_lag_master(upper) &&\n\t\t    !prestera_lag_master_check(upper, cu_info->upper_info, extack))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (netif_is_lag_master(upper) && vlan_uses_dev(dev)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Master device is a LAG master and port has a VLAN\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (netif_is_lag_port(dev) && is_vlan_dev(upper) &&\n\t\t    !netif_is_lag_master(vlan_dev_real_dev(upper))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Can not put a VLAN on a LAG port\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_CHANGEUPPER:\n\t\tupper = cu_info->upper_dev;\n\t\tif (netif_is_bridge_master(upper)) {\n\t\t\tif (cu_info->linking)\n\t\t\t\treturn prestera_bridge_port_join(upper, port,\n\t\t\t\t\t\t\t\t extack);\n\t\t\telse\n\t\t\t\tprestera_bridge_port_leave(upper, port);\n\t\t} else if (netif_is_lag_master(upper)) {\n\t\t\tif (cu_info->linking)\n\t\t\t\treturn prestera_lag_port_add(port, upper);\n\t\t\telse\n\t\t\t\tprestera_lag_port_del(port);\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_CHANGELOWERSTATE:\n\t\treturn prestera_netdev_port_lower_event(dev, event, ptr);\n\t}\n\n\treturn 0;\n}\n\nstatic int prestera_netdevice_lag_event(struct net_device *lag_dev,\n\t\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *dev;\n\tstruct list_head *iter;\n\tint err;\n\n\tnetdev_for_each_lower_dev(lag_dev, dev, iter) {\n\t\tif (prestera_netdev_check(dev)) {\n\t\t\terr = prestera_netdev_port_event(lag_dev, dev, event,\n\t\t\t\t\t\t\t ptr);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int prestera_netdev_event_handler(struct notifier_block *nb,\n\t\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tint err = 0;\n\n\tif (prestera_netdev_check(dev))\n\t\terr = prestera_netdev_port_event(dev, dev, event, ptr);\n\telse if (netif_is_lag_master(dev))\n\t\terr = prestera_netdevice_lag_event(dev, event, ptr);\n\n\treturn notifier_from_errno(err);\n}\n\nstruct prestera_mdb_entry *\nprestera_mdb_entry_create(struct prestera_switch *sw,\n\t\t\t  const unsigned char *addr, u16 vid)\n{\n\tstruct prestera_flood_domain *flood_domain;\n\tstruct prestera_mdb_entry *mdb_entry;\n\n\tmdb_entry = kzalloc(sizeof(*mdb_entry), GFP_KERNEL);\n\tif (!mdb_entry)\n\t\tgoto err_mdb_alloc;\n\n\tflood_domain = prestera_flood_domain_create(sw);\n\tif (!flood_domain)\n\t\tgoto err_flood_domain_create;\n\n\tmdb_entry->sw = sw;\n\tmdb_entry->vid = vid;\n\tmdb_entry->flood_domain = flood_domain;\n\tether_addr_copy(mdb_entry->addr, addr);\n\n\tif (prestera_hw_mdb_create(mdb_entry))\n\t\tgoto err_mdb_hw_create;\n\n\treturn mdb_entry;\n\nerr_mdb_hw_create:\n\tprestera_flood_domain_destroy(flood_domain);\nerr_flood_domain_create:\n\tkfree(mdb_entry);\nerr_mdb_alloc:\n\treturn NULL;\n}\n\nvoid prestera_mdb_entry_destroy(struct prestera_mdb_entry *mdb_entry)\n{\n\tprestera_hw_mdb_destroy(mdb_entry);\n\tprestera_flood_domain_destroy(mdb_entry->flood_domain);\n\tkfree(mdb_entry);\n}\n\nstruct prestera_flood_domain *\nprestera_flood_domain_create(struct prestera_switch *sw)\n{\n\tstruct prestera_flood_domain *domain;\n\n\tdomain = kzalloc(sizeof(*domain), GFP_KERNEL);\n\tif (!domain)\n\t\treturn NULL;\n\n\tdomain->sw = sw;\n\n\tif (prestera_hw_flood_domain_create(domain)) {\n\t\tkfree(domain);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&domain->flood_domain_port_list);\n\n\treturn domain;\n}\n\nvoid prestera_flood_domain_destroy(struct prestera_flood_domain *flood_domain)\n{\n\tWARN_ON(!list_empty(&flood_domain->flood_domain_port_list));\n\tWARN_ON_ONCE(prestera_hw_flood_domain_destroy(flood_domain));\n\tkfree(flood_domain);\n}\n\nint\nprestera_flood_domain_port_create(struct prestera_flood_domain *flood_domain,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  u16 vid)\n{\n\tstruct prestera_flood_domain_port *flood_domain_port;\n\tbool is_first_port_in_list = false;\n\tint err;\n\n\tflood_domain_port = kzalloc(sizeof(*flood_domain_port), GFP_KERNEL);\n\tif (!flood_domain_port) {\n\t\terr = -ENOMEM;\n\t\tgoto err_port_alloc;\n\t}\n\n\tflood_domain_port->vid = vid;\n\n\tif (list_empty(&flood_domain->flood_domain_port_list))\n\t\tis_first_port_in_list = true;\n\n\tlist_add(&flood_domain_port->flood_domain_port_node,\n\t\t &flood_domain->flood_domain_port_list);\n\n\tflood_domain_port->flood_domain = flood_domain;\n\tflood_domain_port->dev = dev;\n\n\tif (!is_first_port_in_list) {\n\t\terr = prestera_hw_flood_domain_ports_reset(flood_domain);\n\t\tif (err)\n\t\t\tgoto err_prestera_mdb_port_create_hw;\n\t}\n\n\terr = prestera_hw_flood_domain_ports_set(flood_domain);\n\tif (err)\n\t\tgoto err_prestera_mdb_port_create_hw;\n\n\treturn 0;\n\nerr_prestera_mdb_port_create_hw:\n\tlist_del(&flood_domain_port->flood_domain_port_node);\n\tkfree(flood_domain_port);\nerr_port_alloc:\n\treturn err;\n}\n\nvoid\nprestera_flood_domain_port_destroy(struct prestera_flood_domain_port *port)\n{\n\tstruct prestera_flood_domain *flood_domain = port->flood_domain;\n\n\tlist_del(&port->flood_domain_port_node);\n\n\tWARN_ON_ONCE(prestera_hw_flood_domain_ports_reset(flood_domain));\n\n\tif (!list_empty(&flood_domain->flood_domain_port_list))\n\t\tWARN_ON_ONCE(prestera_hw_flood_domain_ports_set(flood_domain));\n\n\tkfree(port);\n}\n\nstruct prestera_flood_domain_port *\nprestera_flood_domain_port_find(struct prestera_flood_domain *flood_domain,\n\t\t\t\tstruct net_device *dev, u16 vid)\n{\n\tstruct prestera_flood_domain_port *flood_domain_port;\n\n\tlist_for_each_entry(flood_domain_port,\n\t\t\t    &flood_domain->flood_domain_port_list,\n\t\t\t    flood_domain_port_node)\n\t\tif (flood_domain_port->dev == dev &&\n\t\t    vid == flood_domain_port->vid)\n\t\t\treturn flood_domain_port;\n\n\treturn NULL;\n}\n\nstatic int prestera_netdev_event_handler_register(struct prestera_switch *sw)\n{\n\tsw->netdev_nb.notifier_call = prestera_netdev_event_handler;\n\n\treturn register_netdevice_notifier(&sw->netdev_nb);\n}\n\nstatic void prestera_netdev_event_handler_unregister(struct prestera_switch *sw)\n{\n\tunregister_netdevice_notifier(&sw->netdev_nb);\n}\n\nstatic int prestera_switch_init(struct prestera_switch *sw)\n{\n\tint err;\n\n\tsw->np = sw->dev->dev->of_node;\n\n\terr = prestera_hw_switch_init(sw);\n\tif (err) {\n\t\tdev_err(prestera_dev(sw), \"Failed to init Switch device\\n\");\n\t\treturn err;\n\t}\n\n\trwlock_init(&sw->port_list_lock);\n\tINIT_LIST_HEAD(&sw->port_list);\n\n\terr = prestera_switch_set_base_mac_addr(sw);\n\tif (err)\n\t\treturn err;\n\n\terr = prestera_netdev_event_handler_register(sw);\n\tif (err)\n\t\treturn err;\n\n\terr = prestera_router_init(sw);\n\tif (err)\n\t\tgoto err_router_init;\n\n\terr = prestera_switchdev_init(sw);\n\tif (err)\n\t\tgoto err_swdev_register;\n\n\terr = prestera_rxtx_switch_init(sw);\n\tif (err)\n\t\tgoto err_rxtx_register;\n\n\terr = prestera_event_handlers_register(sw);\n\tif (err)\n\t\tgoto err_handlers_register;\n\n\terr = prestera_counter_init(sw);\n\tif (err)\n\t\tgoto err_counter_init;\n\n\terr = prestera_acl_init(sw);\n\tif (err)\n\t\tgoto err_acl_init;\n\n\terr = prestera_span_init(sw);\n\tif (err)\n\t\tgoto err_span_init;\n\n\terr = prestera_devlink_traps_register(sw);\n\tif (err)\n\t\tgoto err_dl_register;\n\n\terr = prestera_lag_init(sw);\n\tif (err)\n\t\tgoto err_lag_init;\n\n\terr = prestera_create_ports(sw);\n\tif (err)\n\t\tgoto err_ports_create;\n\n\tprestera_devlink_register(sw);\n\treturn 0;\n\nerr_ports_create:\n\tprestera_lag_fini(sw);\nerr_lag_init:\n\tprestera_devlink_traps_unregister(sw);\nerr_dl_register:\n\tprestera_span_fini(sw);\nerr_span_init:\n\tprestera_acl_fini(sw);\nerr_acl_init:\n\tprestera_counter_fini(sw);\nerr_counter_init:\n\tprestera_event_handlers_unregister(sw);\nerr_handlers_register:\n\tprestera_rxtx_switch_fini(sw);\nerr_rxtx_register:\n\tprestera_switchdev_fini(sw);\nerr_swdev_register:\n\tprestera_router_fini(sw);\nerr_router_init:\n\tprestera_netdev_event_handler_unregister(sw);\n\tprestera_hw_switch_fini(sw);\n\n\treturn err;\n}\n\nstatic void prestera_switch_fini(struct prestera_switch *sw)\n{\n\tprestera_devlink_unregister(sw);\n\tprestera_destroy_ports(sw);\n\tprestera_lag_fini(sw);\n\tprestera_devlink_traps_unregister(sw);\n\tprestera_span_fini(sw);\n\tprestera_acl_fini(sw);\n\tprestera_counter_fini(sw);\n\tprestera_event_handlers_unregister(sw);\n\tprestera_rxtx_switch_fini(sw);\n\tprestera_switchdev_fini(sw);\n\tprestera_router_fini(sw);\n\tprestera_netdev_event_handler_unregister(sw);\n\tprestera_hw_switch_fini(sw);\n\tof_node_put(sw->np);\n}\n\nint prestera_device_register(struct prestera_device *dev)\n{\n\tstruct prestera_switch *sw;\n\tint err;\n\n\tsw = prestera_devlink_alloc(dev);\n\tif (!sw)\n\t\treturn -ENOMEM;\n\n\tdev->priv = sw;\n\tsw->dev = dev;\n\n\terr = prestera_switch_init(sw);\n\tif (err) {\n\t\tprestera_devlink_free(sw);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(prestera_device_register);\n\nvoid prestera_device_unregister(struct prestera_device *dev)\n{\n\tstruct prestera_switch *sw = dev->priv;\n\n\tprestera_switch_fini(sw);\n\tprestera_devlink_free(sw);\n}\nEXPORT_SYMBOL(prestera_device_unregister);\n\nstatic int __init prestera_module_init(void)\n{\n\tprestera_wq = alloc_workqueue(\"prestera\", 0, 0);\n\tif (!prestera_wq)\n\t\treturn -ENOMEM;\n\n\tprestera_owq = alloc_ordered_workqueue(\"prestera_ordered\", 0);\n\tif (!prestera_owq) {\n\t\tdestroy_workqueue(prestera_wq);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit prestera_module_exit(void)\n{\n\tdestroy_workqueue(prestera_wq);\n\tdestroy_workqueue(prestera_owq);\n}\n\nmodule_init(prestera_module_init);\nmodule_exit(prestera_module_exit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"Marvell Prestera switch driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}