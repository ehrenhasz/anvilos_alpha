{
  "module_name": "prestera_router.c",
  "hash_id": "4206626db7fc18bf27a3aaebe8896d0cee155ed97870693e3d472d0b2c6040ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/prestera/prestera_router.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/inetdevice.h>\n#include <net/inet_dscp.h>\n#include <net/switchdev.h>\n#include <linux/rhashtable.h>\n#include <net/nexthop.h>\n#include <net/arp.h>\n#include <linux/if_vlan.h>\n#include <linux/if_macvlan.h>\n#include <net/netevent.h>\n\n#include \"prestera.h\"\n#include \"prestera_router_hw.h\"\n\n#define PRESTERA_IMPLICITY_RESOLVE_DEAD_NEIGH\n#define PRESTERA_NH_PROBE_INTERVAL 5000  \n\nstruct prestera_kern_neigh_cache_key {\n\tstruct prestera_ip_addr addr;\n\tstruct net_device *dev;\n};\n\nstruct prestera_kern_neigh_cache {\n\tstruct prestera_kern_neigh_cache_key key;\n\tstruct rhash_head ht_node;\n\tstruct list_head kern_fib_cache_list;\n\t \n\tstruct prestera_neigh_info nh_neigh_info;\n\t \n\tbool reachable;\n\t \n\tbool in_kernel;\n};\n\nstruct prestera_kern_fib_cache_key {\n\tstruct prestera_ip_addr addr;\n\tu32 prefix_len;\n\tu32 kern_tb_id;  \n};\n\n \nstruct prestera_kern_fib_cache {\n\tstruct prestera_kern_fib_cache_key key;\n\tstruct {\n\t\tstruct prestera_fib_key fib_key;\n\t\tenum prestera_fib_type fib_type;\n\t\tstruct prestera_nexthop_group_key nh_grp_key;\n\t} lpm_info;  \n\t \n\tstruct rhash_head ht_node;  \n\tstruct prestera_kern_neigh_cache_head {\n\t\tstruct prestera_kern_fib_cache *this;\n\t\tstruct list_head head;\n\t\tstruct prestera_kern_neigh_cache *n_cache;\n\t} kern_neigh_cache_head[PRESTERA_NHGR_SIZE_MAX];\n\tunion {\n\t\tstruct fib_notifier_info info;  \n\t\tstruct fib_entry_notifier_info fen4_info;\n\t};\n\tbool reachable;\n};\n\nstatic const struct rhashtable_params __prestera_kern_neigh_cache_ht_params = {\n\t.key_offset  = offsetof(struct prestera_kern_neigh_cache, key),\n\t.head_offset = offsetof(struct prestera_kern_neigh_cache, ht_node),\n\t.key_len     = sizeof(struct prestera_kern_neigh_cache_key),\n\t.automatic_shrinking = true,\n};\n\nstatic const struct rhashtable_params __prestera_kern_fib_cache_ht_params = {\n\t.key_offset  = offsetof(struct prestera_kern_fib_cache, key),\n\t.head_offset = offsetof(struct prestera_kern_fib_cache, ht_node),\n\t.key_len     = sizeof(struct prestera_kern_fib_cache_key),\n\t.automatic_shrinking = true,\n};\n\n \nstatic u32 prestera_fix_tb_id(u32 tb_id)\n{\n\tif (tb_id == RT_TABLE_UNSPEC ||\n\t    tb_id == RT_TABLE_LOCAL ||\n\t    tb_id == RT_TABLE_DEFAULT)\n\t\ttb_id = RT_TABLE_MAIN;\n\n\treturn tb_id;\n}\n\nstatic void\nprestera_util_fen_info2fib_cache_key(struct fib_notifier_info *info,\n\t\t\t\t     struct prestera_kern_fib_cache_key *key)\n{\n\tstruct fib_entry_notifier_info *fen_info =\n\t\tcontainer_of(info, struct fib_entry_notifier_info, info);\n\n\tmemset(key, 0, sizeof(*key));\n\tkey->addr.v = PRESTERA_IPV4;\n\tkey->addr.u.ipv4 = cpu_to_be32(fen_info->dst);\n\tkey->prefix_len = fen_info->dst_len;\n\tkey->kern_tb_id = fen_info->tb_id;\n}\n\nstatic int prestera_util_nhc2nc_key(struct prestera_switch *sw,\n\t\t\t\t    struct fib_nh_common *nhc,\n\t\t\t\t    struct prestera_kern_neigh_cache_key *nk)\n{\n\tmemset(nk, 0, sizeof(*nk));\n\tif (nhc->nhc_gw_family == AF_INET) {\n\t\tnk->addr.v = PRESTERA_IPV4;\n\t\tnk->addr.u.ipv4 = nhc->nhc_gw.ipv4;\n\t} else {\n\t\tnk->addr.v = PRESTERA_IPV6;\n\t\tnk->addr.u.ipv6 = nhc->nhc_gw.ipv6;\n\t}\n\n\tnk->dev = nhc->nhc_dev;\n\treturn 0;\n}\n\nstatic void\nprestera_util_nc_key2nh_key(struct prestera_kern_neigh_cache_key *ck,\n\t\t\t    struct prestera_nh_neigh_key *nk)\n{\n\tmemset(nk, 0, sizeof(*nk));\n\tnk->addr = ck->addr;\n\tnk->rif = (void *)ck->dev;\n}\n\nstatic bool\nprestera_util_nhc_eq_n_cache_key(struct prestera_switch *sw,\n\t\t\t\t struct fib_nh_common *nhc,\n\t\t\t\t struct prestera_kern_neigh_cache_key *nk)\n{\n\tstruct prestera_kern_neigh_cache_key tk;\n\tint err;\n\n\terr = prestera_util_nhc2nc_key(sw, nhc, &tk);\n\tif (err)\n\t\treturn false;\n\n\tif (memcmp(&tk, nk, sizeof(tk)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int\nprestera_util_neigh2nc_key(struct prestera_switch *sw, struct neighbour *n,\n\t\t\t   struct prestera_kern_neigh_cache_key *key)\n{\n\tmemset(key, 0, sizeof(*key));\n\tif (n->tbl->family == AF_INET) {\n\t\tkey->addr.v = PRESTERA_IPV4;\n\t\tkey->addr.u.ipv4 = *(__be32 *)n->primary_key;\n\t} else {\n\t\treturn -ENOENT;\n\t}\n\n\tkey->dev = n->dev;\n\n\treturn 0;\n}\n\nstatic bool __prestera_fi_is_direct(struct fib_info *fi)\n{\n\tstruct fib_nh_common *fib_nhc;\n\n\tif (fib_info_num_path(fi) == 1) {\n\t\tfib_nhc = fib_info_nhc(fi, 0);\n\t\tif (fib_nhc->nhc_gw_family == AF_UNSPEC)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool prestera_fi_is_direct(struct fib_info *fi)\n{\n\tif (fi->fib_type != RTN_UNICAST)\n\t\treturn false;\n\n\treturn __prestera_fi_is_direct(fi);\n}\n\nstatic bool prestera_fi_is_nh(struct fib_info *fi)\n{\n\tif (fi->fib_type != RTN_UNICAST)\n\t\treturn false;\n\n\treturn !__prestera_fi_is_direct(fi);\n}\n\nstatic bool __prestera_fi6_is_direct(struct fib6_info *fi)\n{\n\tif (!fi->fib6_nh->nh_common.nhc_gw_family)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool prestera_fi6_is_direct(struct fib6_info *fi)\n{\n\tif (fi->fib6_type != RTN_UNICAST)\n\t\treturn false;\n\n\treturn __prestera_fi6_is_direct(fi);\n}\n\nstatic bool prestera_fi6_is_nh(struct fib6_info *fi)\n{\n\tif (fi->fib6_type != RTN_UNICAST)\n\t\treturn false;\n\n\treturn !__prestera_fi6_is_direct(fi);\n}\n\nstatic bool prestera_fib_info_is_direct(struct fib_notifier_info *info)\n{\n\tstruct fib6_entry_notifier_info *fen6_info =\n\t\tcontainer_of(info, struct fib6_entry_notifier_info, info);\n\tstruct fib_entry_notifier_info *fen_info =\n\t\tcontainer_of(info, struct fib_entry_notifier_info, info);\n\n\tif (info->family == AF_INET)\n\t\treturn prestera_fi_is_direct(fen_info->fi);\n\telse\n\t\treturn prestera_fi6_is_direct(fen6_info->rt);\n}\n\nstatic bool prestera_fib_info_is_nh(struct fib_notifier_info *info)\n{\n\tstruct fib6_entry_notifier_info *fen6_info =\n\t\tcontainer_of(info, struct fib6_entry_notifier_info, info);\n\tstruct fib_entry_notifier_info *fen_info =\n\t\tcontainer_of(info, struct fib_entry_notifier_info, info);\n\n\tif (info->family == AF_INET)\n\t\treturn prestera_fi_is_nh(fen_info->fi);\n\telse\n\t\treturn prestera_fi6_is_nh(fen6_info->rt);\n}\n\n \nstatic int prestera_util_kern_get_route(struct fib_result *res, u32 tb_id,\n\t\t\t\t\t__be32 *addr)\n{\n\tstruct flowi4 fl4;\n\n\t \n\tmemset(&fl4, 0, sizeof(fl4));\n\tfl4.daddr = *addr;\n\treturn fib_lookup(&init_net, &fl4, res, 0  );\n}\n\nstatic bool\n__prestera_util_kern_n_is_reachable_v4(u32 tb_id, __be32 *addr,\n\t\t\t\t       struct net_device *dev)\n{\n\tstruct fib_nh_common *fib_nhc;\n\tstruct fib_result res;\n\tbool reachable;\n\n\treachable = false;\n\n\tif (!prestera_util_kern_get_route(&res, tb_id, addr))\n\t\tif (prestera_fi_is_direct(res.fi)) {\n\t\t\tfib_nhc = fib_info_nhc(res.fi, 0);\n\t\t\tif (dev == fib_nhc->nhc_dev)\n\t\t\t\treachable = true;\n\t\t}\n\n\treturn reachable;\n}\n\n \nstatic bool\nprestera_util_kern_n_is_reachable(u32 tb_id,\n\t\t\t\t  struct prestera_ip_addr *addr,\n\t\t\t\t  struct net_device *dev)\n{\n\tif (addr->v == PRESTERA_IPV4)\n\t\treturn __prestera_util_kern_n_is_reachable_v4(tb_id,\n\t\t\t\t\t\t\t      &addr->u.ipv4,\n\t\t\t\t\t\t\t      dev);\n\telse\n\t\treturn false;\n}\n\nstatic void prestera_util_kern_set_neigh_offload(struct neighbour *n,\n\t\t\t\t\t\t bool offloaded)\n{\n\tif (offloaded)\n\t\tn->flags |= NTF_OFFLOADED;\n\telse\n\t\tn->flags &= ~NTF_OFFLOADED;\n}\n\nstatic void\nprestera_util_kern_set_nh_offload(struct fib_nh_common *nhc, bool offloaded, bool trap)\n{\n\t\tif (offloaded)\n\t\t\tnhc->nhc_flags |= RTNH_F_OFFLOAD;\n\t\telse\n\t\t\tnhc->nhc_flags &= ~RTNH_F_OFFLOAD;\n\n\t\tif (trap)\n\t\t\tnhc->nhc_flags |= RTNH_F_TRAP;\n\t\telse\n\t\t\tnhc->nhc_flags &= ~RTNH_F_TRAP;\n}\n\nstatic struct fib_nh_common *\nprestera_kern_fib_info_nhc(struct fib_notifier_info *info, int n)\n{\n\tstruct fib6_entry_notifier_info *fen6_info;\n\tstruct fib_entry_notifier_info *fen4_info;\n\tstruct fib6_info *iter;\n\n\tif (info->family == AF_INET) {\n\t\tfen4_info = container_of(info, struct fib_entry_notifier_info,\n\t\t\t\t\t info);\n\t\treturn fib_info_nhc(fen4_info->fi, n);\n\t} else if (info->family == AF_INET6) {\n\t\tfen6_info = container_of(info, struct fib6_entry_notifier_info,\n\t\t\t\t\t info);\n\t\tif (!n)\n\t\t\treturn &fen6_info->rt->fib6_nh->nh_common;\n\n\t\tlist_for_each_entry(iter, &fen6_info->rt->fib6_siblings,\n\t\t\t\t    fib6_siblings) {\n\t\t\tif (!--n)\n\t\t\t\treturn &iter->fib6_nh->nh_common;\n\t\t}\n\t}\n\n\t \n\t \n\tWARN(1, \"Invalid parameters passed to %s n=%d i=%p\",\n\t     __func__, n, info);\n\treturn NULL;\n}\n\nstatic int prestera_kern_fib_info_nhs(struct fib_notifier_info *info)\n{\n\tstruct fib6_entry_notifier_info *fen6_info;\n\tstruct fib_entry_notifier_info *fen4_info;\n\n\tif (info->family == AF_INET) {\n\t\tfen4_info = container_of(info, struct fib_entry_notifier_info,\n\t\t\t\t\t info);\n\t\treturn fib_info_num_path(fen4_info->fi);\n\t} else if (info->family == AF_INET6) {\n\t\tfen6_info = container_of(info, struct fib6_entry_notifier_info,\n\t\t\t\t\t info);\n\t\treturn fen6_info->rt->fib6_nsiblings + 1;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned char\nprestera_kern_fib_info_type(struct fib_notifier_info *info)\n{\n\tstruct fib6_entry_notifier_info *fen6_info;\n\tstruct fib_entry_notifier_info *fen4_info;\n\n\tif (info->family == AF_INET) {\n\t\tfen4_info = container_of(info, struct fib_entry_notifier_info,\n\t\t\t\t\t info);\n\t\treturn fen4_info->fi->fib_type;\n\t} else if (info->family == AF_INET6) {\n\t\tfen6_info = container_of(info, struct fib6_entry_notifier_info,\n\t\t\t\t\t info);\n\t\t \n\t\treturn fen6_info->rt->fib6_type;\n\t}\n\n\treturn RTN_UNSPEC;\n}\n\n \nstatic bool\nprestera_fib_node_util_is_neighbour(struct prestera_fib_node *fib_node)\n{\n\tif (fib_node->info.type != PRESTERA_FIB_TYPE_UC_NH)\n\t\treturn false;\n\n\tif (fib_node->info.nh_grp->nh_neigh_head[1].neigh)\n\t\treturn false;\n\n\tif (!fib_node->info.nh_grp->nh_neigh_head[0].neigh)\n\t\treturn false;\n\n\tif (memcmp(&fib_node->info.nh_grp->nh_neigh_head[0].neigh->key.addr,\n\t\t   &fib_node->key.addr, sizeof(struct prestera_ip_addr)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int prestera_dev_if_type(const struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan;\n\n\tif (is_vlan_dev(dev) &&\n\t    netif_is_bridge_master(vlan_dev_real_dev(dev))) {\n\t\treturn PRESTERA_IF_VID_E;\n\t} else if (netif_is_bridge_master(dev)) {\n\t\treturn PRESTERA_IF_VID_E;\n\t} else if (netif_is_lag_master(dev)) {\n\t\treturn PRESTERA_IF_LAG_E;\n\t} else if (netif_is_macvlan(dev)) {\n\t\tvlan = netdev_priv(dev);\n\t\treturn prestera_dev_if_type(vlan->lowerdev);\n\t} else {\n\t\treturn PRESTERA_IF_PORT_E;\n\t}\n}\n\nstatic int\nprestera_neigh_iface_init(struct prestera_switch *sw,\n\t\t\t  struct prestera_iface *iface,\n\t\t\t  struct neighbour *n)\n{\n\tstruct prestera_port *port;\n\n\tiface->vlan_id = 0;  \n\tiface->type = prestera_dev_if_type(n->dev);\n\tif (iface->type != PRESTERA_IF_PORT_E)\n\t\treturn -EINVAL;\n\n\tif (!prestera_netdev_check(n->dev))\n\t\treturn -EINVAL;\n\n\tport = netdev_priv(n->dev);\n\tiface->dev_port.hw_dev_num = port->dev_id;\n\tiface->dev_port.port_num = port->hw_id;\n\n\treturn 0;\n}\n\nstatic struct prestera_kern_neigh_cache *\nprestera_kern_neigh_cache_find(struct prestera_switch *sw,\n\t\t\t       struct prestera_kern_neigh_cache_key *key)\n{\n\tstruct prestera_kern_neigh_cache *n_cache;\n\n\tn_cache =\n\t rhashtable_lookup_fast(&sw->router->kern_neigh_cache_ht, key,\n\t\t\t\t__prestera_kern_neigh_cache_ht_params);\n\treturn n_cache;\n}\n\nstatic void\n__prestera_kern_neigh_cache_destruct(struct prestera_switch *sw,\n\t\t\t\t     struct prestera_kern_neigh_cache *n_cache)\n{\n\tdev_put(n_cache->key.dev);\n}\n\nstatic void\n__prestera_kern_neigh_cache_destroy(struct prestera_switch *sw,\n\t\t\t\t    struct prestera_kern_neigh_cache *n_cache)\n{\n\trhashtable_remove_fast(&sw->router->kern_neigh_cache_ht,\n\t\t\t       &n_cache->ht_node,\n\t\t\t       __prestera_kern_neigh_cache_ht_params);\n\t__prestera_kern_neigh_cache_destruct(sw, n_cache);\n\tkfree(n_cache);\n}\n\nstatic struct prestera_kern_neigh_cache *\n__prestera_kern_neigh_cache_create(struct prestera_switch *sw,\n\t\t\t\t   struct prestera_kern_neigh_cache_key *key)\n{\n\tstruct prestera_kern_neigh_cache *n_cache;\n\tint err;\n\n\tn_cache = kzalloc(sizeof(*n_cache), GFP_KERNEL);\n\tif (!n_cache)\n\t\tgoto err_kzalloc;\n\n\tmemcpy(&n_cache->key, key, sizeof(*key));\n\tdev_hold(n_cache->key.dev);\n\n\tINIT_LIST_HEAD(&n_cache->kern_fib_cache_list);\n\terr = rhashtable_insert_fast(&sw->router->kern_neigh_cache_ht,\n\t\t\t\t     &n_cache->ht_node,\n\t\t\t\t     __prestera_kern_neigh_cache_ht_params);\n\tif (err)\n\t\tgoto err_ht_insert;\n\n\treturn n_cache;\n\nerr_ht_insert:\n\tdev_put(n_cache->key.dev);\n\tkfree(n_cache);\nerr_kzalloc:\n\treturn NULL;\n}\n\nstatic struct prestera_kern_neigh_cache *\nprestera_kern_neigh_cache_get(struct prestera_switch *sw,\n\t\t\t      struct prestera_kern_neigh_cache_key *key)\n{\n\tstruct prestera_kern_neigh_cache *n_cache;\n\n\tn_cache = prestera_kern_neigh_cache_find(sw, key);\n\tif (!n_cache)\n\t\tn_cache = __prestera_kern_neigh_cache_create(sw, key);\n\n\treturn n_cache;\n}\n\nstatic struct prestera_kern_neigh_cache *\nprestera_kern_neigh_cache_put(struct prestera_switch *sw,\n\t\t\t      struct prestera_kern_neigh_cache *n_cache)\n{\n\tif (!n_cache->in_kernel &&\n\t    list_empty(&n_cache->kern_fib_cache_list)) {\n\t\t__prestera_kern_neigh_cache_destroy(sw, n_cache);\n\t\treturn NULL;\n\t}\n\n\treturn n_cache;\n}\n\nstatic struct prestera_kern_fib_cache *\nprestera_kern_fib_cache_find(struct prestera_switch *sw,\n\t\t\t     struct prestera_kern_fib_cache_key *key)\n{\n\tstruct prestera_kern_fib_cache *fib_cache;\n\n\tfib_cache =\n\t rhashtable_lookup_fast(&sw->router->kern_fib_cache_ht, key,\n\t\t\t\t__prestera_kern_fib_cache_ht_params);\n\treturn fib_cache;\n}\n\nstatic void\n__prestera_kern_fib_cache_destruct(struct prestera_switch *sw,\n\t\t\t\t   struct prestera_kern_fib_cache *fib_cache)\n{\n\tstruct prestera_kern_neigh_cache *n_cache;\n\tint i;\n\n\tfor (i = 0; i < PRESTERA_NHGR_SIZE_MAX; i++) {\n\t\tn_cache = fib_cache->kern_neigh_cache_head[i].n_cache;\n\t\tif (n_cache) {\n\t\t\tlist_del(&fib_cache->kern_neigh_cache_head[i].head);\n\t\t\tprestera_kern_neigh_cache_put(sw, n_cache);\n\t\t}\n\t}\n\n\tfib_info_put(fib_cache->fen4_info.fi);\n}\n\nstatic void\nprestera_kern_fib_cache_destroy(struct prestera_switch *sw,\n\t\t\t\tstruct prestera_kern_fib_cache *fib_cache)\n{\n\trhashtable_remove_fast(&sw->router->kern_fib_cache_ht,\n\t\t\t       &fib_cache->ht_node,\n\t\t\t       __prestera_kern_fib_cache_ht_params);\n\t__prestera_kern_fib_cache_destruct(sw, fib_cache);\n\tkfree(fib_cache);\n}\n\nstatic int\n__prestera_kern_fib_cache_create_nhs(struct prestera_switch *sw,\n\t\t\t\t     struct prestera_kern_fib_cache *fc)\n{\n\tstruct prestera_kern_neigh_cache_key nc_key;\n\tstruct prestera_kern_neigh_cache *n_cache;\n\tstruct fib_nh_common *nhc;\n\tint i, nhs, err;\n\n\tif (!prestera_fib_info_is_nh(&fc->info))\n\t\treturn 0;\n\n\tnhs = prestera_kern_fib_info_nhs(&fc->info);\n\tif (nhs > PRESTERA_NHGR_SIZE_MAX)\n\t\treturn 0;\n\n\tfor (i = 0; i < nhs; i++) {\n\t\tnhc = prestera_kern_fib_info_nhc(&fc->fen4_info.info, i);\n\t\terr = prestera_util_nhc2nc_key(sw, nhc, &nc_key);\n\t\tif (err)\n\t\t\treturn 0;\n\n\t\tn_cache = prestera_kern_neigh_cache_get(sw, &nc_key);\n\t\tif (!n_cache)\n\t\t\treturn 0;\n\n\t\tfc->kern_neigh_cache_head[i].this = fc;\n\t\tfc->kern_neigh_cache_head[i].n_cache = n_cache;\n\t\tlist_add(&fc->kern_neigh_cache_head[i].head,\n\t\t\t &n_cache->kern_fib_cache_list);\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct prestera_kern_fib_cache *\nprestera_kern_fib_cache_create(struct prestera_switch *sw,\n\t\t\t       struct prestera_kern_fib_cache_key *key,\n\t\t\t       struct fib_notifier_info *info)\n{\n\tstruct fib_entry_notifier_info *fen_info =\n\t\tcontainer_of(info, struct fib_entry_notifier_info, info);\n\tstruct prestera_kern_fib_cache *fib_cache;\n\tint err;\n\n\tfib_cache = kzalloc(sizeof(*fib_cache), GFP_KERNEL);\n\tif (!fib_cache)\n\t\tgoto err_kzalloc;\n\n\tmemcpy(&fib_cache->key, key, sizeof(*key));\n\tfib_info_hold(fen_info->fi);\n\tmemcpy(&fib_cache->fen4_info, fen_info, sizeof(*fen_info));\n\n\terr = rhashtable_insert_fast(&sw->router->kern_fib_cache_ht,\n\t\t\t\t     &fib_cache->ht_node,\n\t\t\t\t     __prestera_kern_fib_cache_ht_params);\n\tif (err)\n\t\tgoto err_ht_insert;\n\n\t \n\terr = __prestera_kern_fib_cache_create_nhs(sw, fib_cache);\n\tif (err)\n\t\tgoto out;  \n\nout:\n\treturn fib_cache;\n\nerr_ht_insert:\n\tfib_info_put(fen_info->fi);\n\tkfree(fib_cache);\nerr_kzalloc:\n\treturn NULL;\n}\n\nstatic void\n__prestera_k_arb_fib_nh_offload_set(struct prestera_switch *sw,\n\t\t\t\t    struct prestera_kern_fib_cache *fibc,\n\t\t\t\t    struct prestera_kern_neigh_cache *nc,\n\t\t\t\t    bool offloaded, bool trap)\n{\n\tstruct fib_nh_common *nhc;\n\tint i, nhs;\n\n\tnhs = prestera_kern_fib_info_nhs(&fibc->info);\n\tfor (i = 0; i < nhs; i++) {\n\t\tnhc = prestera_kern_fib_info_nhc(&fibc->info, i);\n\t\tif (!nc) {\n\t\t\tprestera_util_kern_set_nh_offload(nhc, offloaded, trap);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (prestera_util_nhc_eq_n_cache_key(sw, nhc, &nc->key)) {\n\t\t\tprestera_util_kern_set_nh_offload(nhc, offloaded, trap);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void\n__prestera_k_arb_n_offload_set(struct prestera_switch *sw,\n\t\t\t       struct prestera_kern_neigh_cache *nc,\n\t\t\t       bool offloaded)\n{\n\tstruct neighbour *n;\n\n\tn = neigh_lookup(&arp_tbl, &nc->key.addr.u.ipv4,\n\t\t\t nc->key.dev);\n\tif (!n)\n\t\treturn;\n\n\tprestera_util_kern_set_neigh_offload(n, offloaded);\n\tneigh_release(n);\n}\n\nstatic void\n__prestera_k_arb_fib_lpm_offload_set(struct prestera_switch *sw,\n\t\t\t\t     struct prestera_kern_fib_cache *fc,\n\t\t\t\t     bool fail, bool offload, bool trap)\n{\n\tstruct fib_rt_info fri;\n\n\tswitch (fc->key.addr.v) {\n\tcase PRESTERA_IPV4:\n\t\tfri.fi = fc->fen4_info.fi;\n\t\tfri.tb_id = fc->key.kern_tb_id;\n\t\tfri.dst = fc->key.addr.u.ipv4;\n\t\tfri.dst_len = fc->key.prefix_len;\n\t\tfri.dscp = fc->fen4_info.dscp;\n\t\tfri.type = fc->fen4_info.type;\n\t\t \n\t\tfri.offload = offload;\n\t\tfri.trap = trap;\n\t\tfri.offload_failed = fail;\n\t\t \n\t\tfib_alias_hw_flags_set(&init_net, &fri);\n\t\treturn;\n\tcase PRESTERA_IPV6:\n\t\t \n\t\treturn;\n\t}\n}\n\nstatic void\n__prestera_k_arb_n_lpm_set(struct prestera_switch *sw,\n\t\t\t   struct prestera_kern_neigh_cache *n_cache,\n\t\t\t   bool enabled)\n{\n\tstruct prestera_nexthop_group_key nh_grp_key;\n\tstruct prestera_kern_fib_cache_key fc_key;\n\tstruct prestera_kern_fib_cache *fib_cache;\n\tstruct prestera_fib_node *fib_node;\n\tstruct prestera_fib_key fib_key;\n\n\t \n\tmemset(&fc_key, 0, sizeof(fc_key));\n\tfc_key.addr = n_cache->key.addr;\n\tfc_key.prefix_len = PRESTERA_IP_ADDR_PLEN(n_cache->key.addr.v);\n\t \n\t \n\tfc_key.kern_tb_id = l3mdev_fib_table(n_cache->key.dev);\n\tfib_cache = prestera_kern_fib_cache_find(sw, &fc_key);\n\tmemset(&fib_key, 0, sizeof(fib_key));\n\tfib_key.addr = n_cache->key.addr;\n\tfib_key.prefix_len = PRESTERA_IP_ADDR_PLEN(n_cache->key.addr.v);\n\tfib_key.tb_id = prestera_fix_tb_id(fc_key.kern_tb_id);\n\tfib_node = prestera_fib_node_find(sw, &fib_key);\n\tif (!fib_cache || !fib_cache->reachable) {\n\t\tif (!enabled && fib_node) {\n\t\t\tif (prestera_fib_node_util_is_neighbour(fib_node))\n\t\t\t\tprestera_fib_node_destroy(sw, fib_node);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (enabled && !fib_node) {\n\t\tmemset(&nh_grp_key, 0, sizeof(nh_grp_key));\n\t\tprestera_util_nc_key2nh_key(&n_cache->key,\n\t\t\t\t\t    &nh_grp_key.neigh[0]);\n\t\tfib_node = prestera_fib_node_create(sw, &fib_key,\n\t\t\t\t\t\t    PRESTERA_FIB_TYPE_UC_NH,\n\t\t\t\t\t\t    &nh_grp_key);\n\t\tif (!fib_node)\n\t\t\tpr_err(\"%s failed ip=%pI4n\", \"prestera_fib_node_create\",\n\t\t\t       &fib_key.addr.u.ipv4);\n\t\treturn;\n\t}\n}\n\nstatic void\n__prestera_k_arb_nc_kern_fib_fetch(struct prestera_switch *sw,\n\t\t\t\t   struct prestera_kern_neigh_cache *nc)\n{\n\tif (prestera_util_kern_n_is_reachable(l3mdev_fib_table(nc->key.dev),\n\t\t\t\t\t      &nc->key.addr, nc->key.dev))\n\t\tnc->reachable = true;\n\telse\n\t\tnc->reachable = false;\n}\n\n \nstatic void\n__prestera_k_arb_nc_kern_n_fetch(struct prestera_switch *sw,\n\t\t\t\t struct prestera_kern_neigh_cache *nc)\n{\n\tstruct neighbour *n;\n\tint err;\n\n\tmemset(&nc->nh_neigh_info, 0, sizeof(nc->nh_neigh_info));\n\tn = neigh_lookup(&arp_tbl, &nc->key.addr.u.ipv4, nc->key.dev);\n\tif (!n)\n\t\tgoto out;\n\n\tread_lock_bh(&n->lock);\n\tif (n->nud_state & NUD_VALID && !n->dead) {\n\t\terr = prestera_neigh_iface_init(sw, &nc->nh_neigh_info.iface,\n\t\t\t\t\t\tn);\n\t\tif (err)\n\t\t\tgoto n_read_out;\n\n\t\tmemcpy(&nc->nh_neigh_info.ha[0], &n->ha[0], ETH_ALEN);\n\t\tnc->nh_neigh_info.connected = true;\n\t}\nn_read_out:\n\tread_unlock_bh(&n->lock);\nout:\n\tnc->in_kernel = nc->nh_neigh_info.connected;\n\tif (n)\n\t\tneigh_release(n);\n}\n\n \nstatic void\n__prestera_k_arb_nc_apply(struct prestera_switch *sw,\n\t\t\t  struct prestera_kern_neigh_cache *nc)\n{\n\tstruct prestera_kern_neigh_cache_head *nhead;\n\tstruct prestera_nh_neigh_key nh_key;\n\tstruct prestera_nh_neigh *nh_neigh;\n\tint err;\n\n\t__prestera_k_arb_n_lpm_set(sw, nc, nc->reachable && nc->in_kernel);\n\t__prestera_k_arb_n_offload_set(sw, nc, nc->reachable && nc->in_kernel);\n\n\tprestera_util_nc_key2nh_key(&nc->key, &nh_key);\n\tnh_neigh = prestera_nh_neigh_find(sw, &nh_key);\n\tif (!nh_neigh)\n\t\tgoto out;\n\n\t \n\tif (memcmp(&nc->nh_neigh_info, &nh_neigh->info,\n\t\t   sizeof(nh_neigh->info))) {\n\t\tmemcpy(&nh_neigh->info, &nc->nh_neigh_info,\n\t\t       sizeof(nh_neigh->info));\n\t\terr = prestera_nh_neigh_set(sw, nh_neigh);\n\t\tif (err) {\n\t\t\tpr_err(\"%s failed with err=%d ip=%pI4n mac=%pM\",\n\t\t\t       \"prestera_nh_neigh_set\", err,\n\t\t\t       &nh_neigh->key.addr.u.ipv4,\n\t\t\t       &nh_neigh->info.ha[0]);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tlist_for_each_entry(nhead, &nc->kern_fib_cache_list, head) {\n\t\t__prestera_k_arb_fib_nh_offload_set(sw, nhead->this, nc,\n\t\t\t\t\t\t    nc->in_kernel,\n\t\t\t\t\t\t    !nc->in_kernel);\n\t}\n}\n\nstatic int\n__prestera_pr_k_arb_fc_lpm_info_calc(struct prestera_switch *sw,\n\t\t\t\t     struct prestera_kern_fib_cache *fc)\n{\n\tstruct fib_nh_common *nhc;\n\tint nh_cnt;\n\n\tmemset(&fc->lpm_info, 0, sizeof(fc->lpm_info));\n\n\tswitch (prestera_kern_fib_info_type(&fc->info)) {\n\tcase RTN_UNICAST:\n\t\tif (prestera_fib_info_is_direct(&fc->info) &&\n\t\t    fc->key.prefix_len ==\n\t\t\tPRESTERA_IP_ADDR_PLEN(fc->key.addr.v)) {\n\t\t\t \n\t\t\tnhc = prestera_kern_fib_info_nhc(&fc->info, 0);\n\t\t\tfc->lpm_info.fib_type = PRESTERA_FIB_TYPE_UC_NH;\n\t\t\tfc->lpm_info.nh_grp_key.neigh[0].addr =\n\t\t\t\tfc->key.addr;\n\t\t\tfc->lpm_info.nh_grp_key.neigh[0].rif =\n\t\t\t\tnhc->nhc_dev;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfor (nh_cnt = 0; nh_cnt < PRESTERA_NHGR_SIZE_MAX; nh_cnt++) {\n\t\t\tif (!fc->kern_neigh_cache_head[nh_cnt].n_cache)\n\t\t\t\tbreak;\n\n\t\t\tfc->lpm_info.nh_grp_key.neigh[nh_cnt].addr =\n\t\t\t\tfc->kern_neigh_cache_head[nh_cnt].n_cache->key.addr;\n\t\t\tfc->lpm_info.nh_grp_key.neigh[nh_cnt].rif =\n\t\t\t\tfc->kern_neigh_cache_head[nh_cnt].n_cache->key.dev;\n\t\t}\n\n\t\tfc->lpm_info.fib_type = nh_cnt ?\n\t\t\t\t\tPRESTERA_FIB_TYPE_UC_NH :\n\t\t\t\t\tPRESTERA_FIB_TYPE_TRAP;\n\t\tbreak;\n\t \n\tcase RTN_BROADCAST:\n\tcase RTN_MULTICAST:\n\t \n\tcase RTN_LOCAL:\n\tcase RTN_UNREACHABLE:\n\tcase RTN_PROHIBIT:\n\t\tfc->lpm_info.fib_type = PRESTERA_FIB_TYPE_TRAP;\n\t\tbreak;\n\tcase RTN_BLACKHOLE:\n\t\tfc->lpm_info.fib_type = PRESTERA_FIB_TYPE_DROP;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sw->dev->dev, \"Unsupported fib_type\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfc->lpm_info.fib_key.addr = fc->key.addr;\n\tfc->lpm_info.fib_key.prefix_len = fc->key.prefix_len;\n\tfc->lpm_info.fib_key.tb_id = prestera_fix_tb_id(fc->key.kern_tb_id);\n\n\treturn 0;\n}\n\nstatic int __prestera_k_arb_f_lpm_set(struct prestera_switch *sw,\n\t\t\t\t      struct prestera_kern_fib_cache *fc,\n\t\t\t\t      bool enabled)\n{\n\tstruct prestera_fib_node *fib_node;\n\n\tfib_node = prestera_fib_node_find(sw, &fc->lpm_info.fib_key);\n\tif (fib_node)\n\t\tprestera_fib_node_destroy(sw, fib_node);\n\n\tif (!enabled)\n\t\treturn 0;\n\n\tfib_node = prestera_fib_node_create(sw, &fc->lpm_info.fib_key,\n\t\t\t\t\t    fc->lpm_info.fib_type,\n\t\t\t\t\t    &fc->lpm_info.nh_grp_key);\n\n\tif (!fib_node) {\n\t\tdev_err(sw->dev->dev, \"fib_node=NULL %pI4n/%d kern_tb_id = %d\",\n\t\t\t&fc->key.addr.u.ipv4, fc->key.prefix_len,\n\t\t\tfc->key.kern_tb_id);\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\nstatic int __prestera_k_arb_fc_apply(struct prestera_switch *sw,\n\t\t\t\t     struct prestera_kern_fib_cache *fc)\n{\n\tint err;\n\n\terr = __prestera_pr_k_arb_fc_lpm_info_calc(sw, fc);\n\tif (err)\n\t\treturn err;\n\n\terr = __prestera_k_arb_f_lpm_set(sw, fc, fc->reachable);\n\tif (err) {\n\t\t__prestera_k_arb_fib_lpm_offload_set(sw, fc,\n\t\t\t\t\t\t     true, false, false);\n\t\treturn err;\n\t}\n\n\tswitch (fc->lpm_info.fib_type) {\n\tcase PRESTERA_FIB_TYPE_UC_NH:\n\t\t__prestera_k_arb_fib_lpm_offload_set(sw, fc, false,\n\t\t\t\t\t\t     fc->reachable, false);\n\t\tbreak;\n\tcase PRESTERA_FIB_TYPE_TRAP:\n\t\t__prestera_k_arb_fib_lpm_offload_set(sw, fc, false,\n\t\t\t\t\t\t     false, fc->reachable);\n\t\tbreak;\n\tcase PRESTERA_FIB_TYPE_DROP:\n\t\t__prestera_k_arb_fib_lpm_offload_set(sw, fc, false, true,\n\t\t\t\t\t\t     fc->reachable);\n\t\tbreak;\n\tcase PRESTERA_FIB_TYPE_INVALID:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct prestera_kern_fib_cache *\n__prestera_k_arb_util_fib_overlaps(struct prestera_switch *sw,\n\t\t\t\t   struct prestera_kern_fib_cache *fc)\n{\n\tstruct prestera_kern_fib_cache_key fc_key;\n\tstruct prestera_kern_fib_cache *rfc;\n\n\t \n\trfc = NULL;\n\tif (fc->key.kern_tb_id == RT_TABLE_LOCAL) {\n\t\tmemcpy(&fc_key, &fc->key, sizeof(fc_key));\n\t\tfc_key.kern_tb_id = RT_TABLE_MAIN;\n\t\trfc = prestera_kern_fib_cache_find(sw, &fc_key);\n\t}\n\n\treturn rfc;\n}\n\nstatic struct prestera_kern_fib_cache *\n__prestera_k_arb_util_fib_overlapped(struct prestera_switch *sw,\n\t\t\t\t     struct prestera_kern_fib_cache *fc)\n{\n\tstruct prestera_kern_fib_cache_key fc_key;\n\tstruct prestera_kern_fib_cache *rfc;\n\n\t \n\trfc = NULL;\n\tif (fc->key.kern_tb_id == RT_TABLE_MAIN) {\n\t\tmemcpy(&fc_key, &fc->key, sizeof(fc_key));\n\t\tfc_key.kern_tb_id = RT_TABLE_LOCAL;\n\t\trfc = prestera_kern_fib_cache_find(sw, &fc_key);\n\t}\n\n\treturn rfc;\n}\n\nstatic void __prestera_k_arb_hw_state_upd(struct prestera_switch *sw,\n\t\t\t\t\t  struct prestera_kern_neigh_cache *nc)\n{\n\tstruct prestera_nh_neigh_key nh_key;\n\tstruct prestera_nh_neigh *nh_neigh;\n\tstruct neighbour *n;\n\tbool hw_active;\n\n\tprestera_util_nc_key2nh_key(&nc->key, &nh_key);\n\tnh_neigh = prestera_nh_neigh_find(sw, &nh_key);\n\tif (!nh_neigh) {\n\t\tpr_err(\"Cannot find nh_neigh for cached %pI4n\",\n\t\t       &nc->key.addr.u.ipv4);\n\t\treturn;\n\t}\n\n\thw_active = prestera_nh_neigh_util_hw_state(sw, nh_neigh);\n\n#ifdef PRESTERA_IMPLICITY_RESOLVE_DEAD_NEIGH\n\tif (!hw_active && nc->in_kernel)\n\t\tgoto out;\n#else  \n\tif (!hw_active)\n\t\tgoto out;\n#endif  \n\n\tif (nc->key.addr.v == PRESTERA_IPV4) {\n\t\tn = neigh_lookup(&arp_tbl, &nc->key.addr.u.ipv4,\n\t\t\t\t nc->key.dev);\n\t\tif (!n)\n\t\t\tn = neigh_create(&arp_tbl, &nc->key.addr.u.ipv4,\n\t\t\t\t\t nc->key.dev);\n\t} else {\n\t\tn = NULL;\n\t}\n\n\tif (!IS_ERR(n) && n) {\n\t\tneigh_event_send(n, NULL);\n\t\tneigh_release(n);\n\t} else {\n\t\tpr_err(\"Cannot create neighbour %pI4n\", &nc->key.addr.u.ipv4);\n\t}\n\nout:\n\treturn;\n}\n\n \nstatic void prestera_k_arb_hw_evt(struct prestera_switch *sw)\n{\n\tstruct prestera_kern_neigh_cache *n_cache;\n\tstruct rhashtable_iter iter;\n\n\trhashtable_walk_enter(&sw->router->kern_neigh_cache_ht, &iter);\n\trhashtable_walk_start(&iter);\n\twhile (1) {\n\t\tn_cache = rhashtable_walk_next(&iter);\n\n\t\tif (!n_cache)\n\t\t\tbreak;\n\n\t\tif (IS_ERR(n_cache))\n\t\t\tcontinue;\n\n\t\trhashtable_walk_stop(&iter);\n\t\t__prestera_k_arb_hw_state_upd(sw, n_cache);\n\t\trhashtable_walk_start(&iter);\n\t}\n\trhashtable_walk_stop(&iter);\n\trhashtable_walk_exit(&iter);\n}\n\n \nstatic void prestera_k_arb_n_evt(struct prestera_switch *sw,\n\t\t\t\t struct neighbour *n)\n{\n\tstruct prestera_kern_neigh_cache_key n_key;\n\tstruct prestera_kern_neigh_cache *n_cache;\n\tint err;\n\n\terr = prestera_util_neigh2nc_key(sw, n, &n_key);\n\tif (err)\n\t\treturn;\n\n\tn_cache = prestera_kern_neigh_cache_find(sw, &n_key);\n\tif (!n_cache) {\n\t\tn_cache = prestera_kern_neigh_cache_get(sw, &n_key);\n\t\tif (!n_cache)\n\t\t\treturn;\n\t\t__prestera_k_arb_nc_kern_fib_fetch(sw, n_cache);\n\t}\n\n\t__prestera_k_arb_nc_kern_n_fetch(sw, n_cache);\n\t__prestera_k_arb_nc_apply(sw, n_cache);\n\n\tprestera_kern_neigh_cache_put(sw, n_cache);\n}\n\nstatic void __prestera_k_arb_fib_evt2nc(struct prestera_switch *sw)\n{\n\tstruct prestera_kern_neigh_cache *n_cache;\n\tstruct rhashtable_iter iter;\n\n\trhashtable_walk_enter(&sw->router->kern_neigh_cache_ht, &iter);\n\trhashtable_walk_start(&iter);\n\twhile (1) {\n\t\tn_cache = rhashtable_walk_next(&iter);\n\n\t\tif (!n_cache)\n\t\t\tbreak;\n\n\t\tif (IS_ERR(n_cache))\n\t\t\tcontinue;\n\n\t\trhashtable_walk_stop(&iter);\n\t\t__prestera_k_arb_nc_kern_fib_fetch(sw, n_cache);\n\t\t__prestera_k_arb_nc_apply(sw, n_cache);\n\t\trhashtable_walk_start(&iter);\n\t}\n\trhashtable_walk_stop(&iter);\n\trhashtable_walk_exit(&iter);\n}\n\nstatic int\nprestera_k_arb_fib_evt(struct prestera_switch *sw,\n\t\t       bool replace,  \n\t\t       struct fib_notifier_info *info)\n{\n\tstruct prestera_kern_fib_cache *tfib_cache, *bfib_cache;  \n\tstruct prestera_kern_fib_cache_key fc_key;\n\tstruct prestera_kern_fib_cache *fib_cache;\n\tint err;\n\n\tprestera_util_fen_info2fib_cache_key(info, &fc_key);\n\tfib_cache = prestera_kern_fib_cache_find(sw, &fc_key);\n\tif (fib_cache) {\n\t\tfib_cache->reachable = false;\n\t\terr = __prestera_k_arb_fc_apply(sw, fib_cache);\n\t\tif (err)\n\t\t\tdev_err(sw->dev->dev,\n\t\t\t\t\"Applying destroyed fib_cache failed\");\n\n\t\tbfib_cache = __prestera_k_arb_util_fib_overlaps(sw, fib_cache);\n\t\ttfib_cache = __prestera_k_arb_util_fib_overlapped(sw, fib_cache);\n\t\tif (!tfib_cache && bfib_cache) {\n\t\t\tbfib_cache->reachable = true;\n\t\t\terr = __prestera_k_arb_fc_apply(sw, bfib_cache);\n\t\t\tif (err)\n\t\t\t\tdev_err(sw->dev->dev,\n\t\t\t\t\t\"Applying fib_cache btm failed\");\n\t\t}\n\n\t\tprestera_kern_fib_cache_destroy(sw, fib_cache);\n\t}\n\n\tif (replace) {\n\t\tfib_cache = prestera_kern_fib_cache_create(sw, &fc_key, info);\n\t\tif (!fib_cache) {\n\t\t\tdev_err(sw->dev->dev, \"fib_cache == NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tbfib_cache = __prestera_k_arb_util_fib_overlaps(sw, fib_cache);\n\t\ttfib_cache = __prestera_k_arb_util_fib_overlapped(sw, fib_cache);\n\t\tif (!tfib_cache)\n\t\t\tfib_cache->reachable = true;\n\n\t\tif (bfib_cache) {\n\t\t\tbfib_cache->reachable = false;\n\t\t\terr = __prestera_k_arb_fc_apply(sw, bfib_cache);\n\t\t\tif (err)\n\t\t\t\tdev_err(sw->dev->dev,\n\t\t\t\t\t\"Applying fib_cache btm failed\");\n\t\t}\n\n\t\terr = __prestera_k_arb_fc_apply(sw, fib_cache);\n\t\tif (err)\n\t\t\tdev_err(sw->dev->dev, \"Applying fib_cache failed\");\n\t}\n\n\t \n\t__prestera_k_arb_fib_evt2nc(sw);\n\n\treturn 0;\n}\n\nstatic void __prestera_k_arb_abort_neigh_ht_cb(void *ptr, void *arg)\n{\n\tstruct prestera_kern_neigh_cache *n_cache = ptr;\n\tstruct prestera_switch *sw = arg;\n\n\tif (!list_empty(&n_cache->kern_fib_cache_list)) {\n\t\tWARN_ON(1);  \n\t\treturn;\n\t}\n\t__prestera_k_arb_n_offload_set(sw, n_cache, false);\n\tn_cache->in_kernel = false;\n\t \n\t__prestera_kern_neigh_cache_destruct(sw, n_cache);\n\tkfree(n_cache);\n}\n\nstatic void __prestera_k_arb_abort_fib_ht_cb(void *ptr, void *arg)\n{\n\tstruct prestera_kern_fib_cache *fib_cache = ptr;\n\tstruct prestera_switch *sw = arg;\n\n\t__prestera_k_arb_fib_lpm_offload_set(sw, fib_cache,\n\t\t\t\t\t     false, false,\n\t\t\t\t\t     false);\n\t__prestera_k_arb_fib_nh_offload_set(sw, fib_cache, NULL,\n\t\t\t\t\t    false, false);\n\t \n\t__prestera_kern_fib_cache_destruct(sw, fib_cache);\n\tkfree(fib_cache);\n}\n\nstatic void prestera_k_arb_abort(struct prestera_switch *sw)\n{\n\t \n\t \n\trhashtable_free_and_destroy(&sw->router->kern_fib_cache_ht,\n\t\t\t\t    __prestera_k_arb_abort_fib_ht_cb,\n\t\t\t\t    sw);\n\trhashtable_free_and_destroy(&sw->router->kern_neigh_cache_ht,\n\t\t\t\t    __prestera_k_arb_abort_neigh_ht_cb,\n\t\t\t\t    sw);\n}\n\nstatic int __prestera_inetaddr_port_event(struct net_device *port_dev,\n\t\t\t\t\t  unsigned long event,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct prestera_port *port = netdev_priv(port_dev);\n\tstruct prestera_rif_entry_key re_key = {};\n\tstruct prestera_rif_entry *re;\n\tu32 kern_tb_id;\n\tint err;\n\n\terr = prestera_is_valid_mac_addr(port, port_dev->dev_addr);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"RIF MAC must have the same prefix\");\n\t\treturn err;\n\t}\n\n\tkern_tb_id = l3mdev_fib_table(port_dev);\n\tre_key.iface.type = PRESTERA_IF_PORT_E;\n\tre_key.iface.dev_port.hw_dev_num  = port->dev_id;\n\tre_key.iface.dev_port.port_num  = port->hw_id;\n\tre = prestera_rif_entry_find(port->sw, &re_key);\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tif (re) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"RIF already exist\");\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tre = prestera_rif_entry_create(port->sw, &re_key,\n\t\t\t\t\t       prestera_fix_tb_id(kern_tb_id),\n\t\t\t\t\t       port_dev->dev_addr);\n\t\tif (!re) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't create RIF\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdev_hold(port_dev);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tif (!re) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Can't find RIF\");\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tprestera_rif_entry_destroy(port->sw, re);\n\t\tdev_put(port_dev);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int __prestera_inetaddr_event(struct prestera_switch *sw,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     unsigned long event,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tif (!prestera_netdev_check(dev) || netif_is_any_bridge_port(dev) ||\n\t    netif_is_lag_port(dev))\n\t\treturn 0;\n\n\treturn __prestera_inetaddr_port_event(dev, event, extack);\n}\n\nstatic int __prestera_inetaddr_cb(struct notifier_block *nb,\n\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\n\tstruct net_device *dev = ifa->ifa_dev->dev;\n\tstruct prestera_router *router = container_of(nb,\n\t\t\t\t\t\t      struct prestera_router,\n\t\t\t\t\t\t      inetaddr_nb);\n\tstruct in_device *idev;\n\tint err = 0;\n\n\tif (event != NETDEV_DOWN)\n\t\tgoto out;\n\n\t \n\tidev = __in_dev_get_rtnl(dev);\n\tif (idev && idev->ifa_list)\n\t\tgoto out;\n\n\terr = __prestera_inetaddr_event(router->sw, dev, event, NULL);\nout:\n\treturn notifier_from_errno(err);\n}\n\nstatic int __prestera_inetaddr_valid_cb(struct notifier_block *nb,\n\t\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct in_validator_info *ivi = (struct in_validator_info *)ptr;\n\tstruct net_device *dev = ivi->ivi_dev->dev;\n\tstruct prestera_router *router = container_of(nb,\n\t\t\t\t\t\t      struct prestera_router,\n\t\t\t\t\t\t      inetaddr_valid_nb);\n\tstruct in_device *idev;\n\tint err = 0;\n\n\tif (event != NETDEV_UP)\n\t\tgoto out;\n\n\t \n\tidev = __in_dev_get_rtnl(dev);\n\tif (idev && idev->ifa_list)\n\t\tgoto out;\n\n\tif (ipv4_is_multicast(ivi->ivi_addr)) {\n\t\tNL_SET_ERR_MSG_MOD(ivi->extack,\n\t\t\t\t   \"Multicast addr on RIF is not supported\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = __prestera_inetaddr_event(router->sw, dev, event, ivi->extack);\nout:\n\treturn notifier_from_errno(err);\n}\n\nstruct prestera_fib_event_work {\n\tstruct work_struct work;\n\tstruct prestera_switch *sw;\n\tstruct fib_entry_notifier_info fen_info;\n\tunsigned long event;\n};\n\nstatic void __prestera_router_fib_event_work(struct work_struct *work)\n{\n\tstruct prestera_fib_event_work *fib_work =\n\t\t\tcontainer_of(work, struct prestera_fib_event_work, work);\n\tstruct prestera_switch *sw = fib_work->sw;\n\tint err;\n\n\trtnl_lock();\n\n\tswitch (fib_work->event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\t\terr = prestera_k_arb_fib_evt(sw, true,\n\t\t\t\t\t     &fib_work->fen_info.info);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\tbreak;\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\terr = prestera_k_arb_fib_evt(sw, false,\n\t\t\t\t\t     &fib_work->fen_info.info);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\tbreak;\n\t}\n\n\tgoto out;\n\nerr_out:\n\tdev_err(sw->dev->dev, \"Error when processing %pI4h/%d\",\n\t\t&fib_work->fen_info.dst,\n\t\tfib_work->fen_info.dst_len);\nout:\n\tfib_info_put(fib_work->fen_info.fi);\n\trtnl_unlock();\n\tkfree(fib_work);\n}\n\n \nstatic int __prestera_router_fib_event(struct notifier_block *nb,\n\t\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct prestera_fib_event_work *fib_work;\n\tstruct fib_entry_notifier_info *fen_info;\n\tstruct fib_notifier_info *info = ptr;\n\tstruct prestera_router *router;\n\n\tif (info->family != AF_INET)\n\t\treturn NOTIFY_DONE;\n\n\trouter = container_of(nb, struct prestera_router, fib_nb);\n\n\tswitch (event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\tfen_info = container_of(info, struct fib_entry_notifier_info,\n\t\t\t\t\tinfo);\n\t\tif (!fen_info->fi)\n\t\t\treturn NOTIFY_DONE;\n\n\t\tfib_work = kzalloc(sizeof(*fib_work), GFP_ATOMIC);\n\t\tif (WARN_ON(!fib_work))\n\t\t\treturn NOTIFY_BAD;\n\n\t\tfib_info_hold(fen_info->fi);\n\t\tfib_work->fen_info = *fen_info;\n\t\tfib_work->event = event;\n\t\tfib_work->sw = router->sw;\n\t\tINIT_WORK(&fib_work->work, __prestera_router_fib_event_work);\n\t\tprestera_queue_work(&fib_work->work);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstruct prestera_netevent_work {\n\tstruct work_struct work;\n\tstruct prestera_switch *sw;\n\tstruct neighbour *n;\n};\n\nstatic void prestera_router_neigh_event_work(struct work_struct *work)\n{\n\tstruct prestera_netevent_work *net_work =\n\t\tcontainer_of(work, struct prestera_netevent_work, work);\n\tstruct prestera_switch *sw = net_work->sw;\n\tstruct neighbour *n = net_work->n;\n\n\t \n\trtnl_lock();\n\n\tprestera_k_arb_n_evt(sw, n);\n\n\tneigh_release(n);\n\trtnl_unlock();\n\tkfree(net_work);\n}\n\nstatic int prestera_router_netevent_event(struct notifier_block *nb,\n\t\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct prestera_netevent_work *net_work;\n\tstruct prestera_router *router;\n\tstruct neighbour *n = ptr;\n\n\trouter = container_of(nb, struct prestera_router, netevent_nb);\n\n\tswitch (event) {\n\tcase NETEVENT_NEIGH_UPDATE:\n\t\tif (n->tbl->family != AF_INET)\n\t\t\treturn NOTIFY_DONE;\n\n\t\tnet_work = kzalloc(sizeof(*net_work), GFP_ATOMIC);\n\t\tif (WARN_ON(!net_work))\n\t\t\treturn NOTIFY_BAD;\n\n\t\tneigh_clone(n);\n\t\tnet_work->n = n;\n\t\tnet_work->sw = router->sw;\n\t\tINIT_WORK(&net_work->work, prestera_router_neigh_event_work);\n\t\tprestera_queue_work(&net_work->work);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void prestera_router_update_neighs_work(struct work_struct *work)\n{\n\tstruct prestera_router *router;\n\n\trouter = container_of(work, struct prestera_router,\n\t\t\t      neighs_update.dw.work);\n\trtnl_lock();\n\n\tprestera_k_arb_hw_evt(router->sw);\n\n\trtnl_unlock();\n\tprestera_queue_delayed_work(&router->neighs_update.dw,\n\t\t\t\t    msecs_to_jiffies(PRESTERA_NH_PROBE_INTERVAL));\n}\n\nstatic int prestera_neigh_work_init(struct prestera_switch *sw)\n{\n\tINIT_DELAYED_WORK(&sw->router->neighs_update.dw,\n\t\t\t  prestera_router_update_neighs_work);\n\tprestera_queue_delayed_work(&sw->router->neighs_update.dw, 0);\n\treturn 0;\n}\n\nstatic void prestera_neigh_work_fini(struct prestera_switch *sw)\n{\n\tcancel_delayed_work_sync(&sw->router->neighs_update.dw);\n}\n\nint prestera_router_init(struct prestera_switch *sw)\n{\n\tstruct prestera_router *router;\n\tint err, nhgrp_cache_bytes;\n\n\trouter = kzalloc(sizeof(*sw->router), GFP_KERNEL);\n\tif (!router)\n\t\treturn -ENOMEM;\n\n\tsw->router = router;\n\trouter->sw = sw;\n\n\terr = prestera_router_hw_init(sw);\n\tif (err)\n\t\tgoto err_router_lib_init;\n\n\terr = rhashtable_init(&router->kern_fib_cache_ht,\n\t\t\t      &__prestera_kern_fib_cache_ht_params);\n\tif (err)\n\t\tgoto err_kern_fib_cache_ht_init;\n\n\terr = rhashtable_init(&router->kern_neigh_cache_ht,\n\t\t\t      &__prestera_kern_neigh_cache_ht_params);\n\tif (err)\n\t\tgoto err_kern_neigh_cache_ht_init;\n\n\tnhgrp_cache_bytes = sw->size_tbl_router_nexthop / 8 + 1;\n\trouter->nhgrp_hw_state_cache = kzalloc(nhgrp_cache_bytes, GFP_KERNEL);\n\tif (!router->nhgrp_hw_state_cache) {\n\t\terr = -ENOMEM;\n\t\tgoto err_nh_state_cache_alloc;\n\t}\n\n\terr = prestera_neigh_work_init(sw);\n\tif (err)\n\t\tgoto err_neigh_work_init;\n\n\trouter->inetaddr_valid_nb.notifier_call = __prestera_inetaddr_valid_cb;\n\terr = register_inetaddr_validator_notifier(&router->inetaddr_valid_nb);\n\tif (err)\n\t\tgoto err_register_inetaddr_validator_notifier;\n\n\trouter->inetaddr_nb.notifier_call = __prestera_inetaddr_cb;\n\terr = register_inetaddr_notifier(&router->inetaddr_nb);\n\tif (err)\n\t\tgoto err_register_inetaddr_notifier;\n\n\trouter->netevent_nb.notifier_call = prestera_router_netevent_event;\n\terr = register_netevent_notifier(&router->netevent_nb);\n\tif (err)\n\t\tgoto err_register_netevent_notifier;\n\n\trouter->fib_nb.notifier_call = __prestera_router_fib_event;\n\terr = register_fib_notifier(&init_net, &router->fib_nb,\n\t\t\t\t      NULL, NULL);\n\tif (err)\n\t\tgoto err_register_fib_notifier;\n\n\treturn 0;\n\nerr_register_fib_notifier:\n\tunregister_netevent_notifier(&router->netevent_nb);\nerr_register_netevent_notifier:\n\tunregister_inetaddr_notifier(&router->inetaddr_nb);\nerr_register_inetaddr_notifier:\n\tunregister_inetaddr_validator_notifier(&router->inetaddr_valid_nb);\nerr_register_inetaddr_validator_notifier:\n\tprestera_neigh_work_fini(sw);\nerr_neigh_work_init:\n\tkfree(router->nhgrp_hw_state_cache);\nerr_nh_state_cache_alloc:\n\trhashtable_destroy(&router->kern_neigh_cache_ht);\nerr_kern_neigh_cache_ht_init:\n\trhashtable_destroy(&router->kern_fib_cache_ht);\nerr_kern_fib_cache_ht_init:\n\tprestera_router_hw_fini(sw);\nerr_router_lib_init:\n\tkfree(sw->router);\n\treturn err;\n}\n\nvoid prestera_router_fini(struct prestera_switch *sw)\n{\n\tunregister_fib_notifier(&init_net, &sw->router->fib_nb);\n\tunregister_netevent_notifier(&sw->router->netevent_nb);\n\tunregister_inetaddr_notifier(&sw->router->inetaddr_nb);\n\tunregister_inetaddr_validator_notifier(&sw->router->inetaddr_valid_nb);\n\tprestera_neigh_work_fini(sw);\n\tprestera_queue_drain();\n\n\tprestera_k_arb_abort(sw);\n\n\tkfree(sw->router->nhgrp_hw_state_cache);\n\trhashtable_destroy(&sw->router->kern_fib_cache_ht);\n\tprestera_router_hw_fini(sw);\n\tkfree(sw->router);\n\tsw->router = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}