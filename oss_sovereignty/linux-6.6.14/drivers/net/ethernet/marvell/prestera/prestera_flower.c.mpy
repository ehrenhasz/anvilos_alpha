{
  "module_name": "prestera_flower.c",
  "hash_id": "666391d0d2e7027ee4dbb8a480924d8558f2cb1ea20f8d80e0ee5b621a2af2ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/prestera/prestera_flower.c",
  "human_readable_source": "\n \n\n#include \"prestera.h\"\n#include \"prestera_acl.h\"\n#include \"prestera_flow.h\"\n#include \"prestera_flower.h\"\n#include \"prestera_matchall.h\"\n\nstruct prestera_flower_template {\n\tstruct prestera_acl_ruleset *ruleset;\n\tstruct list_head list;\n\tu32 chain_index;\n};\n\nstatic void\nprestera_flower_template_free(struct prestera_flower_template *template)\n{\n\tprestera_acl_ruleset_put(template->ruleset);\n\tlist_del(&template->list);\n\tkfree(template);\n}\n\nvoid prestera_flower_template_cleanup(struct prestera_flow_block *block)\n{\n\tstruct prestera_flower_template *template, *tmp;\n\n\t \n\tlist_for_each_entry_safe(template, tmp, &block->template_list, list)\n\t\tprestera_flower_template_free(template);\n}\n\nstatic int\nprestera_flower_parse_goto_action(struct prestera_flow_block *block,\n\t\t\t\t  struct prestera_acl_rule *rule,\n\t\t\t\t  u32 chain_index,\n\t\t\t\t  const struct flow_action_entry *act)\n{\n\tstruct prestera_acl_ruleset *ruleset;\n\n\tif (act->chain_index <= chain_index)\n\t\t \n\t\treturn -EINVAL;\n\n\tif (rule->re_arg.jump.valid)\n\t\treturn -EEXIST;\n\n\truleset = prestera_acl_ruleset_get(block->sw->acl, block,\n\t\t\t\t\t   act->chain_index);\n\tif (IS_ERR(ruleset))\n\t\treturn PTR_ERR(ruleset);\n\n\trule->re_arg.jump.valid = 1;\n\trule->re_arg.jump.i.index = prestera_acl_ruleset_index_get(ruleset);\n\n\trule->jump_ruleset = ruleset;\n\n\treturn 0;\n}\n\nstatic int prestera_flower_parse_actions(struct prestera_flow_block *block,\n\t\t\t\t\t struct prestera_acl_rule *rule,\n\t\t\t\t\t struct flow_action *flow_action,\n\t\t\t\t\t u32 chain_index,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tconst struct flow_action_entry *act;\n\tint err, i;\n\n\t \n\tif (!flow_action_has_entries(flow_action))\n\t\treturn 0;\n\n\tif (!flow_action_mixed_hw_stats_check(flow_action, extack))\n\t\treturn -EOPNOTSUPP;\n\n\tact = flow_action_first_entry_get(flow_action);\n\tif (act->hw_stats & FLOW_ACTION_HW_STATS_DISABLED) {\n\t\t \n\t} else if (act->hw_stats & FLOW_ACTION_HW_STATS_DELAYED) {\n\t\t \n\t\trule->re_arg.count.valid = true;\n\t\terr = prestera_acl_chain_to_client(chain_index, block->ingress,\n\t\t\t\t\t\t   &rule->re_arg.count.client);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported action HW stats type\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tflow_action_for_each(i, act, flow_action) {\n\t\tswitch (act->id) {\n\t\tcase FLOW_ACTION_ACCEPT:\n\t\t\tif (rule->re_arg.accept.valid)\n\t\t\t\treturn -EEXIST;\n\n\t\t\trule->re_arg.accept.valid = 1;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_DROP:\n\t\t\tif (rule->re_arg.drop.valid)\n\t\t\t\treturn -EEXIST;\n\n\t\t\trule->re_arg.drop.valid = 1;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_TRAP:\n\t\t\tif (rule->re_arg.trap.valid)\n\t\t\t\treturn -EEXIST;\n\n\t\t\trule->re_arg.trap.valid = 1;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_POLICE:\n\t\t\tif (rule->re_arg.police.valid)\n\t\t\t\treturn -EEXIST;\n\n\t\t\trule->re_arg.police.valid = 1;\n\t\t\trule->re_arg.police.rate =\n\t\t\t\tact->police.rate_bytes_ps;\n\t\t\trule->re_arg.police.burst = act->police.burst;\n\t\t\trule->re_arg.police.ingress = block->ingress;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_GOTO:\n\t\t\terr = prestera_flower_parse_goto_action(block, rule,\n\t\t\t\t\t\t\t\tchain_index,\n\t\t\t\t\t\t\t\tact);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported action\");\n\t\t\tpr_err(\"Unsupported action\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int prestera_flower_parse_meta(struct prestera_acl_rule *rule,\n\t\t\t\t      struct flow_cls_offload *f,\n\t\t\t\t      struct prestera_flow_block *block)\n{\n\tstruct flow_rule *f_rule = flow_cls_offload_flow_rule(f);\n\tstruct prestera_acl_match *r_match = &rule->re_key.match;\n\tstruct prestera_port *port;\n\tstruct net_device *ingress_dev;\n\tstruct flow_match_meta match;\n\t__be16 key, mask;\n\n\tflow_rule_match_meta(f_rule, &match);\n\n\tif (match.mask->l2_miss) {\n\t\tNL_SET_ERR_MSG_MOD(f->common.extack, \"Can't match on \\\"l2_miss\\\"\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (match.mask->ingress_ifindex != 0xFFFFFFFF) {\n\t\tNL_SET_ERR_MSG_MOD(f->common.extack,\n\t\t\t\t   \"Unsupported ingress ifindex mask\");\n\t\treturn -EINVAL;\n\t}\n\n\tingress_dev = __dev_get_by_index(block->net,\n\t\t\t\t\t match.key->ingress_ifindex);\n\tif (!ingress_dev) {\n\t\tNL_SET_ERR_MSG_MOD(f->common.extack,\n\t\t\t\t   \"Can't find specified ingress port to match on\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!prestera_netdev_check(ingress_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(f->common.extack,\n\t\t\t\t   \"Can't match on switchdev ingress port\");\n\t\treturn -EINVAL;\n\t}\n\tport = netdev_priv(ingress_dev);\n\n\tmask = htons(0x1FFF << 3);\n\tkey = htons(port->hw_id << 3);\n\trule_match_set(r_match->key, SYS_PORT, key);\n\trule_match_set(r_match->mask, SYS_PORT, mask);\n\n\tmask = htons(0x3FF);\n\tkey = htons(port->dev_id);\n\trule_match_set(r_match->key, SYS_DEV, key);\n\trule_match_set(r_match->mask, SYS_DEV, mask);\n\n\treturn 0;\n}\n\nstatic int prestera_flower_parse(struct prestera_flow_block *block,\n\t\t\t\t struct prestera_acl_rule *rule,\n\t\t\t\t struct flow_cls_offload *f)\n{\n\tstruct flow_rule *f_rule = flow_cls_offload_flow_rule(f);\n\tstruct flow_dissector *dissector = f_rule->match.dissector;\n\tstruct prestera_acl_match *r_match = &rule->re_key.match;\n\t__be16 n_proto_mask = 0;\n\t__be16 n_proto_key = 0;\n\tu16 addr_type = 0;\n\tu8 ip_proto = 0;\n\tint err;\n\n\tif (dissector->used_keys &\n\t    ~(BIT_ULL(FLOW_DISSECTOR_KEY_META) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV4_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV6_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ICMP) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_PORTS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_PORTS_RANGE) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_VLAN))) {\n\t\tNL_SET_ERR_MSG_MOD(f->common.extack, \"Unsupported key\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tprestera_acl_rule_priority_set(rule, f->common.prio);\n\n\tif (flow_rule_match_key(f_rule, FLOW_DISSECTOR_KEY_META)) {\n\t\terr = prestera_flower_parse_meta(rule, f, block);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (flow_rule_match_key(f_rule, FLOW_DISSECTOR_KEY_CONTROL)) {\n\t\tstruct flow_match_control match;\n\n\t\tflow_rule_match_control(f_rule, &match);\n\t\taddr_type = match.key->addr_type;\n\t}\n\n\tif (flow_rule_match_key(f_rule, FLOW_DISSECTOR_KEY_BASIC)) {\n\t\tstruct flow_match_basic match;\n\n\t\tflow_rule_match_basic(f_rule, &match);\n\t\tn_proto_key = match.key->n_proto;\n\t\tn_proto_mask = match.mask->n_proto;\n\n\t\tif (ntohs(match.key->n_proto) == ETH_P_ALL) {\n\t\t\tn_proto_key = 0;\n\t\t\tn_proto_mask = 0;\n\t\t}\n\n\t\trule_match_set(r_match->key, ETH_TYPE, n_proto_key);\n\t\trule_match_set(r_match->mask, ETH_TYPE, n_proto_mask);\n\n\t\trule_match_set(r_match->key, IP_PROTO, match.key->ip_proto);\n\t\trule_match_set(r_match->mask, IP_PROTO, match.mask->ip_proto);\n\t\tip_proto = match.key->ip_proto;\n\t}\n\n\tif (flow_rule_match_key(f_rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct flow_match_eth_addrs match;\n\n\t\tflow_rule_match_eth_addrs(f_rule, &match);\n\n\t\t \n\t\trule_match_set_n(r_match->key,\n\t\t\t\t ETH_DMAC_0, &match.key->dst[0], 4);\n\t\trule_match_set_n(r_match->key,\n\t\t\t\t ETH_DMAC_1, &match.key->dst[4], 2);\n\n\t\trule_match_set_n(r_match->mask,\n\t\t\t\t ETH_DMAC_0, &match.mask->dst[0], 4);\n\t\trule_match_set_n(r_match->mask,\n\t\t\t\t ETH_DMAC_1, &match.mask->dst[4], 2);\n\n\t\t \n\t\trule_match_set_n(r_match->key,\n\t\t\t\t ETH_SMAC_0, &match.key->src[0], 4);\n\t\trule_match_set_n(r_match->key,\n\t\t\t\t ETH_SMAC_1, &match.key->src[4], 2);\n\n\t\trule_match_set_n(r_match->mask,\n\t\t\t\t ETH_SMAC_0, &match.mask->src[0], 4);\n\t\trule_match_set_n(r_match->mask,\n\t\t\t\t ETH_SMAC_1, &match.mask->src[4], 2);\n\t}\n\n\tif (addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {\n\t\tstruct flow_match_ipv4_addrs match;\n\n\t\tflow_rule_match_ipv4_addrs(f_rule, &match);\n\n\t\trule_match_set(r_match->key, IP_SRC, match.key->src);\n\t\trule_match_set(r_match->mask, IP_SRC, match.mask->src);\n\n\t\trule_match_set(r_match->key, IP_DST, match.key->dst);\n\t\trule_match_set(r_match->mask, IP_DST, match.mask->dst);\n\t}\n\n\tif (flow_rule_match_key(f_rule, FLOW_DISSECTOR_KEY_PORTS)) {\n\t\tstruct flow_match_ports match;\n\n\t\tif (ip_proto != IPPROTO_TCP && ip_proto != IPPROTO_UDP) {\n\t\t\tNL_SET_ERR_MSG_MOD\n\t\t\t    (f->common.extack,\n\t\t\t     \"Only UDP and TCP keys are supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tflow_rule_match_ports(f_rule, &match);\n\n\t\trule_match_set(r_match->key, L4_PORT_SRC, match.key->src);\n\t\trule_match_set(r_match->mask, L4_PORT_SRC, match.mask->src);\n\n\t\trule_match_set(r_match->key, L4_PORT_DST, match.key->dst);\n\t\trule_match_set(r_match->mask, L4_PORT_DST, match.mask->dst);\n\t}\n\n\tif (flow_rule_match_key(f_rule, FLOW_DISSECTOR_KEY_PORTS_RANGE)) {\n\t\tstruct flow_match_ports_range match;\n\t\t__be32 tp_key, tp_mask;\n\n\t\tflow_rule_match_ports_range(f_rule, &match);\n\n\t\t \n\t\ttp_key = htonl(ntohs(match.key->tp_min.src) |\n\t\t\t       (ntohs(match.key->tp_max.src) << 16));\n\t\ttp_mask = htonl(ntohs(match.mask->tp_min.src) |\n\t\t\t\t(ntohs(match.mask->tp_max.src) << 16));\n\t\trule_match_set(r_match->key, L4_PORT_RANGE_SRC, tp_key);\n\t\trule_match_set(r_match->mask, L4_PORT_RANGE_SRC, tp_mask);\n\n\t\t \n\t\ttp_key = htonl(ntohs(match.key->tp_min.dst) |\n\t\t\t       (ntohs(match.key->tp_max.dst) << 16));\n\t\ttp_mask = htonl(ntohs(match.mask->tp_min.dst) |\n\t\t\t\t(ntohs(match.mask->tp_max.dst) << 16));\n\t\trule_match_set(r_match->key, L4_PORT_RANGE_DST, tp_key);\n\t\trule_match_set(r_match->mask, L4_PORT_RANGE_DST, tp_mask);\n\t}\n\n\tif (flow_rule_match_key(f_rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tstruct flow_match_vlan match;\n\n\t\tflow_rule_match_vlan(f_rule, &match);\n\n\t\tif (match.mask->vlan_id != 0) {\n\t\t\t__be16 key = cpu_to_be16(match.key->vlan_id);\n\t\t\t__be16 mask = cpu_to_be16(match.mask->vlan_id);\n\n\t\t\trule_match_set(r_match->key, VLAN_ID, key);\n\t\t\trule_match_set(r_match->mask, VLAN_ID, mask);\n\t\t}\n\n\t\trule_match_set(r_match->key, VLAN_TPID, match.key->vlan_tpid);\n\t\trule_match_set(r_match->mask, VLAN_TPID, match.mask->vlan_tpid);\n\t}\n\n\tif (flow_rule_match_key(f_rule, FLOW_DISSECTOR_KEY_ICMP)) {\n\t\tstruct flow_match_icmp match;\n\n\t\tflow_rule_match_icmp(f_rule, &match);\n\n\t\trule_match_set(r_match->key, ICMP_TYPE, match.key->type);\n\t\trule_match_set(r_match->mask, ICMP_TYPE, match.mask->type);\n\n\t\trule_match_set(r_match->key, ICMP_CODE, match.key->code);\n\t\trule_match_set(r_match->mask, ICMP_CODE, match.mask->code);\n\t}\n\n\treturn prestera_flower_parse_actions(block, rule, &f->rule->action,\n\t\t\t\t\t     f->common.chain_index,\n\t\t\t\t\t     f->common.extack);\n}\n\nstatic int prestera_flower_prio_check(struct prestera_flow_block *block,\n\t\t\t\t      struct flow_cls_offload *f)\n{\n\tu32 mall_prio_min;\n\tu32 mall_prio_max;\n\tint err;\n\n\terr = prestera_mall_prio_get(block, &mall_prio_min, &mall_prio_max);\n\tif (err == -ENOENT)\n\t\t \n\t\treturn 0;\n\n\tif (err) {\n\t\tNL_SET_ERR_MSG(f->common.extack, \"Failed to get matchall priorities\");\n\t\treturn err;\n\t}\n\n\tif (f->common.prio <= mall_prio_max && block->ingress) {\n\t\tNL_SET_ERR_MSG(f->common.extack,\n\t\t\t       \"Failed to add in front of existing matchall rules\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (f->common.prio >= mall_prio_min && !block->ingress) {\n\t\tNL_SET_ERR_MSG(f->common.extack, \"Failed to add behind of existing matchall rules\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint prestera_flower_prio_get(struct prestera_flow_block *block, u32 chain_index,\n\t\t\t     u32 *prio_min, u32 *prio_max)\n{\n\tstruct prestera_acl_ruleset *ruleset;\n\n\truleset = prestera_acl_ruleset_lookup(block->sw->acl, block, chain_index);\n\tif (IS_ERR(ruleset))\n\t\treturn PTR_ERR(ruleset);\n\n\tprestera_acl_ruleset_prio_get(ruleset, prio_min, prio_max);\n\treturn 0;\n}\n\nint prestera_flower_replace(struct prestera_flow_block *block,\n\t\t\t    struct flow_cls_offload *f)\n{\n\tstruct prestera_acl_ruleset *ruleset;\n\tstruct prestera_acl *acl = block->sw->acl;\n\tstruct prestera_acl_rule *rule;\n\tint err;\n\n\terr = prestera_flower_prio_check(block, f);\n\tif (err)\n\t\treturn err;\n\n\truleset = prestera_acl_ruleset_get(acl, block, f->common.chain_index);\n\tif (IS_ERR(ruleset))\n\t\treturn PTR_ERR(ruleset);\n\n\t \n\trule = prestera_acl_rule_create(ruleset, f->cookie,\n\t\t\t\t\tf->common.chain_index);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tgoto err_rule_create;\n\t}\n\n\terr = prestera_flower_parse(block, rule, f);\n\tif (err)\n\t\tgoto err_rule_add;\n\n\tif (!prestera_acl_ruleset_is_offload(ruleset)) {\n\t\terr = prestera_acl_ruleset_offload(ruleset);\n\t\tif (err)\n\t\t\tgoto err_ruleset_offload;\n\t}\n\n\terr = prestera_acl_rule_add(block->sw, rule);\n\tif (err)\n\t\tgoto err_rule_add;\n\n\tprestera_acl_ruleset_put(ruleset);\n\treturn 0;\n\nerr_ruleset_offload:\nerr_rule_add:\n\tprestera_acl_rule_destroy(rule);\nerr_rule_create:\n\tprestera_acl_ruleset_put(ruleset);\n\treturn err;\n}\n\nvoid prestera_flower_destroy(struct prestera_flow_block *block,\n\t\t\t     struct flow_cls_offload *f)\n{\n\tstruct prestera_acl_ruleset *ruleset;\n\tstruct prestera_acl_rule *rule;\n\n\truleset = prestera_acl_ruleset_lookup(block->sw->acl, block,\n\t\t\t\t\t      f->common.chain_index);\n\tif (IS_ERR(ruleset))\n\t\treturn;\n\n\trule = prestera_acl_rule_lookup(ruleset, f->cookie);\n\tif (rule) {\n\t\tprestera_acl_rule_del(block->sw, rule);\n\t\tprestera_acl_rule_destroy(rule);\n\t}\n\tprestera_acl_ruleset_put(ruleset);\n}\n\nint prestera_flower_tmplt_create(struct prestera_flow_block *block,\n\t\t\t\t struct flow_cls_offload *f)\n{\n\tstruct prestera_flower_template *template;\n\tstruct prestera_acl_ruleset *ruleset;\n\tstruct prestera_acl_rule rule;\n\tint err;\n\n\tmemset(&rule, 0, sizeof(rule));\n\terr = prestera_flower_parse(block, &rule, f);\n\tif (err)\n\t\treturn err;\n\n\ttemplate = kmalloc(sizeof(*template), GFP_KERNEL);\n\tif (!template) {\n\t\terr = -ENOMEM;\n\t\tgoto err_malloc;\n\t}\n\n\tprestera_acl_rule_keymask_pcl_id_set(&rule, 0);\n\truleset = prestera_acl_ruleset_get(block->sw->acl, block,\n\t\t\t\t\t   f->common.chain_index);\n\tif (IS_ERR_OR_NULL(ruleset)) {\n\t\terr = -EINVAL;\n\t\tgoto err_ruleset_get;\n\t}\n\n\t \n\terr = prestera_acl_ruleset_keymask_set(ruleset, rule.re_key.match.mask);\n\tif (err)\n\t\tgoto err_ruleset_keymask_set;\n\n\t \n\tprestera_acl_ruleset_offload(ruleset);\n\n\t \n\ttemplate->ruleset = ruleset;\n\ttemplate->chain_index = f->common.chain_index;\n\tlist_add_rcu(&template->list, &block->template_list);\n\treturn 0;\n\nerr_ruleset_keymask_set:\n\tprestera_acl_ruleset_put(ruleset);\nerr_ruleset_get:\n\tkfree(template);\nerr_malloc:\n\tNL_SET_ERR_MSG_MOD(f->common.extack, \"Create chain template failed\");\n\treturn err;\n}\n\nvoid prestera_flower_tmplt_destroy(struct prestera_flow_block *block,\n\t\t\t\t   struct flow_cls_offload *f)\n{\n\tstruct prestera_flower_template *template, *tmp;\n\n\tlist_for_each_entry_safe(template, tmp, &block->template_list, list)\n\t\tif (template->chain_index == f->common.chain_index) {\n\t\t\t \n\t\t\tprestera_flower_template_free(template);\n\t\t\treturn;\n\t\t}\n}\n\nint prestera_flower_stats(struct prestera_flow_block *block,\n\t\t\t  struct flow_cls_offload *f)\n{\n\tstruct prestera_acl_ruleset *ruleset;\n\tstruct prestera_acl_rule *rule;\n\tu64 packets;\n\tu64 lastuse;\n\tu64 bytes;\n\tint err;\n\n\truleset = prestera_acl_ruleset_lookup(block->sw->acl, block,\n\t\t\t\t\t      f->common.chain_index);\n\tif (IS_ERR(ruleset))\n\t\treturn PTR_ERR(ruleset);\n\n\trule = prestera_acl_rule_lookup(ruleset, f->cookie);\n\tif (!rule) {\n\t\terr = -EINVAL;\n\t\tgoto err_rule_get_stats;\n\t}\n\n\terr = prestera_acl_rule_get_stats(block->sw->acl, rule, &packets,\n\t\t\t\t\t  &bytes, &lastuse);\n\tif (err)\n\t\tgoto err_rule_get_stats;\n\n\tflow_stats_update(&f->stats, bytes, packets, 0, lastuse,\n\t\t\t  FLOW_ACTION_HW_STATS_DELAYED);\n\nerr_rule_get_stats:\n\tprestera_acl_ruleset_put(ruleset);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}