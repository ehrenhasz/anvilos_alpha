{
  "module_name": "prestera_acl.c",
  "hash_id": "262c179786d1142f66be973c0dd816ad520c48f24f6b54997361e5855e5c97ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/prestera/prestera_acl.c",
  "human_readable_source": "\n \n\n#include <linux/rhashtable.h>\n\n#include \"prestera_acl.h\"\n#include \"prestera_flow.h\"\n#include \"prestera_hw.h\"\n#include \"prestera.h\"\n\n#define ACL_KEYMASK_SIZE\t\\\n\t(sizeof(__be32) * __PRESTERA_ACL_RULE_MATCH_TYPE_MAX)\n\nstruct prestera_acl {\n\tstruct prestera_switch *sw;\n\tstruct list_head vtcam_list;\n\tstruct list_head rules;\n\tstruct rhashtable ruleset_ht;\n\tstruct rhashtable acl_rule_entry_ht;\n\tstruct idr uid;\n};\n\nstruct prestera_acl_ruleset_ht_key {\n\tstruct prestera_flow_block *block;\n\tu32 chain_index;\n};\n\nstruct prestera_acl_rule_entry {\n\tstruct rhash_head ht_node;\n\tstruct prestera_acl_rule_entry_key key;\n\tu32 hw_id;\n\tu32 vtcam_id;\n\tstruct {\n\t\tstruct {\n\t\t\tu8 valid:1;\n\t\t} accept, drop, trap;\n\t\tstruct {\n\t\t\tu8 valid:1;\n\t\t\tstruct prestera_acl_action_police i;\n\t\t} police;\n\t\tstruct {\n\t\t\tstruct prestera_acl_action_jump i;\n\t\t\tu8 valid:1;\n\t\t} jump;\n\t\tstruct {\n\t\t\tu32 id;\n\t\t\tstruct prestera_counter_block *block;\n\t\t} counter;\n\t};\n};\n\nstruct prestera_acl_ruleset {\n\tstruct rhash_head ht_node;  \n\tstruct prestera_acl_ruleset_ht_key ht_key;\n\tstruct rhashtable rule_ht;\n\tstruct prestera_acl *acl;\n\tstruct {\n\t\tu32 min;\n\t\tu32 max;\n\t} prio;\n\tunsigned long rule_count;\n\trefcount_t refcount;\n\tvoid *keymask;\n\tu32 vtcam_id;\n\tu32 index;\n\tu16 pcl_id;\n\tbool offload;\n\tbool ingress;\n};\n\nstruct prestera_acl_vtcam {\n\tstruct list_head list;\n\t__be32 keymask[__PRESTERA_ACL_RULE_MATCH_TYPE_MAX];\n\trefcount_t refcount;\n\tu32 id;\n\tbool is_keymask_set;\n\tu8 lookup;\n\tu8 direction;\n};\n\nstatic const struct rhashtable_params prestera_acl_ruleset_ht_params = {\n\t.key_len = sizeof(struct prestera_acl_ruleset_ht_key),\n\t.key_offset = offsetof(struct prestera_acl_ruleset, ht_key),\n\t.head_offset = offsetof(struct prestera_acl_ruleset, ht_node),\n\t.automatic_shrinking = true,\n};\n\nstatic const struct rhashtable_params prestera_acl_rule_ht_params = {\n\t.key_len = sizeof(unsigned long),\n\t.key_offset = offsetof(struct prestera_acl_rule, cookie),\n\t.head_offset = offsetof(struct prestera_acl_rule, ht_node),\n\t.automatic_shrinking = true,\n};\n\nstatic const struct rhashtable_params __prestera_acl_rule_entry_ht_params = {\n\t.key_offset  = offsetof(struct prestera_acl_rule_entry, key),\n\t.head_offset = offsetof(struct prestera_acl_rule_entry, ht_node),\n\t.key_len     = sizeof(struct prestera_acl_rule_entry_key),\n\t.automatic_shrinking = true,\n};\n\nint prestera_acl_chain_to_client(u32 chain_index, bool ingress, u32 *client)\n{\n\tstatic const u32 ingress_client_map[] = {\n\t\tPRESTERA_HW_COUNTER_CLIENT_INGRESS_LOOKUP_0,\n\t\tPRESTERA_HW_COUNTER_CLIENT_INGRESS_LOOKUP_1,\n\t\tPRESTERA_HW_COUNTER_CLIENT_INGRESS_LOOKUP_2\n\t};\n\n\tif (!ingress) {\n\t\t \n\t\tif (chain_index > 0)\n\t\t\treturn -EINVAL;\n\n\t\t*client = PRESTERA_HW_COUNTER_CLIENT_EGRESS_LOOKUP;\n\t\treturn 0;\n\t}\n\n\tif (chain_index >= ARRAY_SIZE(ingress_client_map))\n\t\treturn -EINVAL;\n\n\t*client = ingress_client_map[chain_index];\n\treturn 0;\n}\n\nstatic bool prestera_acl_chain_is_supported(u32 chain_index, bool ingress)\n{\n\tif (!ingress)\n\t\t \n\t\treturn chain_index == 0;\n\n\treturn (chain_index & ~PRESTERA_ACL_CHAIN_MASK) == 0;\n}\n\nstatic struct prestera_acl_ruleset *\nprestera_acl_ruleset_create(struct prestera_acl *acl,\n\t\t\t    struct prestera_flow_block *block,\n\t\t\t    u32 chain_index)\n{\n\tstruct prestera_acl_ruleset *ruleset;\n\tu32 uid = 0;\n\tint err;\n\n\tif (!prestera_acl_chain_is_supported(chain_index, block->ingress))\n\t\treturn ERR_PTR(-EINVAL);\n\n\truleset = kzalloc(sizeof(*ruleset), GFP_KERNEL);\n\tif (!ruleset)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\truleset->acl = acl;\n\truleset->ingress = block->ingress;\n\truleset->ht_key.block = block;\n\truleset->ht_key.chain_index = chain_index;\n\trefcount_set(&ruleset->refcount, 1);\n\n\terr = rhashtable_init(&ruleset->rule_ht, &prestera_acl_rule_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_init;\n\n\terr = idr_alloc_u32(&acl->uid, NULL, &uid, U8_MAX, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_ruleset_create;\n\n\t \n\truleset->pcl_id = PRESTERA_ACL_PCL_ID_MAKE((u8)uid, chain_index);\n\truleset->index = uid;\n\n\truleset->prio.min = UINT_MAX;\n\truleset->prio.max = 0;\n\n\terr = rhashtable_insert_fast(&acl->ruleset_ht, &ruleset->ht_node,\n\t\t\t\t     prestera_acl_ruleset_ht_params);\n\tif (err)\n\t\tgoto err_ruleset_ht_insert;\n\n\treturn ruleset;\n\nerr_ruleset_ht_insert:\n\tidr_remove(&acl->uid, uid);\nerr_ruleset_create:\n\trhashtable_destroy(&ruleset->rule_ht);\nerr_rhashtable_init:\n\tkfree(ruleset);\n\treturn ERR_PTR(err);\n}\n\nint prestera_acl_ruleset_keymask_set(struct prestera_acl_ruleset *ruleset,\n\t\t\t\t     void *keymask)\n{\n\truleset->keymask = kmemdup(keymask, ACL_KEYMASK_SIZE, GFP_KERNEL);\n\tif (!ruleset->keymask)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint prestera_acl_ruleset_offload(struct prestera_acl_ruleset *ruleset)\n{\n\tstruct prestera_acl_iface iface;\n\tu32 vtcam_id;\n\tint dir;\n\tint err;\n\n\tdir = ruleset->ingress ?\n\t\tPRESTERA_HW_VTCAM_DIR_INGRESS : PRESTERA_HW_VTCAM_DIR_EGRESS;\n\n\tif (ruleset->offload)\n\t\treturn -EEXIST;\n\n\terr = prestera_acl_vtcam_id_get(ruleset->acl,\n\t\t\t\t\truleset->ht_key.chain_index,\n\t\t\t\t\tdir,\n\t\t\t\t\truleset->keymask, &vtcam_id);\n\tif (err)\n\t\tgoto err_vtcam_create;\n\n\tif (ruleset->ht_key.chain_index) {\n\t\t \n\t\tiface.index = ruleset->index;\n\t\tiface.type = PRESTERA_ACL_IFACE_TYPE_INDEX;\n\t\terr = prestera_hw_vtcam_iface_bind(ruleset->acl->sw, &iface,\n\t\t\t\t\t\t   vtcam_id, ruleset->pcl_id);\n\t\tif (err)\n\t\t\tgoto err_ruleset_bind;\n\t}\n\n\truleset->vtcam_id = vtcam_id;\n\truleset->offload = true;\n\treturn 0;\n\nerr_ruleset_bind:\n\tprestera_acl_vtcam_id_put(ruleset->acl, ruleset->vtcam_id);\nerr_vtcam_create:\n\treturn err;\n}\n\nstatic void prestera_acl_ruleset_destroy(struct prestera_acl_ruleset *ruleset)\n{\n\tstruct prestera_acl *acl = ruleset->acl;\n\tu8 uid = ruleset->pcl_id & PRESTERA_ACL_KEYMASK_PCL_ID_USER;\n\tint err;\n\n\trhashtable_remove_fast(&acl->ruleset_ht, &ruleset->ht_node,\n\t\t\t       prestera_acl_ruleset_ht_params);\n\n\tif (ruleset->offload) {\n\t\tif (ruleset->ht_key.chain_index) {\n\t\t\tstruct prestera_acl_iface iface = {\n\t\t\t\t.type = PRESTERA_ACL_IFACE_TYPE_INDEX,\n\t\t\t\t.index = ruleset->index\n\t\t\t};\n\t\t\terr = prestera_hw_vtcam_iface_unbind(acl->sw, &iface,\n\t\t\t\t\t\t\t     ruleset->vtcam_id);\n\t\t\tWARN_ON(err);\n\t\t}\n\t\tWARN_ON(prestera_acl_vtcam_id_put(acl, ruleset->vtcam_id));\n\t}\n\n\tidr_remove(&acl->uid, uid);\n\trhashtable_destroy(&ruleset->rule_ht);\n\tkfree(ruleset->keymask);\n\tkfree(ruleset);\n}\n\nstatic struct prestera_acl_ruleset *\n__prestera_acl_ruleset_lookup(struct prestera_acl *acl,\n\t\t\t      struct prestera_flow_block *block,\n\t\t\t      u32 chain_index)\n{\n\tstruct prestera_acl_ruleset_ht_key ht_key;\n\n\tmemset(&ht_key, 0, sizeof(ht_key));\n\tht_key.block = block;\n\tht_key.chain_index = chain_index;\n\treturn rhashtable_lookup_fast(&acl->ruleset_ht, &ht_key,\n\t\t\t\t      prestera_acl_ruleset_ht_params);\n}\n\nstruct prestera_acl_ruleset *\nprestera_acl_ruleset_lookup(struct prestera_acl *acl,\n\t\t\t    struct prestera_flow_block *block,\n\t\t\t    u32 chain_index)\n{\n\tstruct prestera_acl_ruleset *ruleset;\n\n\truleset = __prestera_acl_ruleset_lookup(acl, block, chain_index);\n\tif (!ruleset)\n\t\treturn ERR_PTR(-ENOENT);\n\n\trefcount_inc(&ruleset->refcount);\n\treturn ruleset;\n}\n\nstruct prestera_acl_ruleset *\nprestera_acl_ruleset_get(struct prestera_acl *acl,\n\t\t\t struct prestera_flow_block *block,\n\t\t\t u32 chain_index)\n{\n\tstruct prestera_acl_ruleset *ruleset;\n\n\truleset = __prestera_acl_ruleset_lookup(acl, block, chain_index);\n\tif (ruleset) {\n\t\trefcount_inc(&ruleset->refcount);\n\t\treturn ruleset;\n\t}\n\n\treturn prestera_acl_ruleset_create(acl, block, chain_index);\n}\n\nvoid prestera_acl_ruleset_put(struct prestera_acl_ruleset *ruleset)\n{\n\tif (!refcount_dec_and_test(&ruleset->refcount))\n\t\treturn;\n\n\tprestera_acl_ruleset_destroy(ruleset);\n}\n\nint prestera_acl_ruleset_bind(struct prestera_acl_ruleset *ruleset,\n\t\t\t      struct prestera_port *port)\n{\n\tstruct prestera_acl_iface iface = {\n\t\t.type = PRESTERA_ACL_IFACE_TYPE_PORT,\n\t\t.port = port\n\t};\n\n\treturn prestera_hw_vtcam_iface_bind(port->sw, &iface, ruleset->vtcam_id,\n\t\t\t\t\t    ruleset->pcl_id);\n}\n\nint prestera_acl_ruleset_unbind(struct prestera_acl_ruleset *ruleset,\n\t\t\t\tstruct prestera_port *port)\n{\n\tstruct prestera_acl_iface iface = {\n\t\t.type = PRESTERA_ACL_IFACE_TYPE_PORT,\n\t\t.port = port\n\t};\n\n\treturn prestera_hw_vtcam_iface_unbind(port->sw, &iface,\n\t\t\t\t\t      ruleset->vtcam_id);\n}\n\nstatic int prestera_acl_ruleset_block_bind(struct prestera_acl_ruleset *ruleset,\n\t\t\t\t\t   struct prestera_flow_block *block)\n{\n\tstruct prestera_flow_block_binding *binding;\n\tint err;\n\n\tblock->ruleset_zero = ruleset;\n\tlist_for_each_entry(binding, &block->binding_list, list) {\n\t\terr = prestera_acl_ruleset_bind(ruleset, binding->port);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\treturn 0;\n\nrollback:\n\tlist_for_each_entry_continue_reverse(binding, &block->binding_list,\n\t\t\t\t\t     list)\n\t\terr = prestera_acl_ruleset_unbind(ruleset, binding->port);\n\tblock->ruleset_zero = NULL;\n\n\treturn err;\n}\n\nstatic void\nprestera_acl_ruleset_block_unbind(struct prestera_acl_ruleset *ruleset,\n\t\t\t\t  struct prestera_flow_block *block)\n{\n\tstruct prestera_flow_block_binding *binding;\n\n\tlist_for_each_entry(binding, &block->binding_list, list)\n\t\tprestera_acl_ruleset_unbind(ruleset, binding->port);\n\tblock->ruleset_zero = NULL;\n}\n\nstatic void\nprestera_acl_ruleset_prio_refresh(struct prestera_acl *acl,\n\t\t\t\t  struct prestera_acl_ruleset *ruleset)\n{\n\tstruct prestera_acl_rule *rule;\n\n\truleset->prio.min = UINT_MAX;\n\truleset->prio.max = 0;\n\n\tlist_for_each_entry(rule, &acl->rules, list) {\n\t\tif (ruleset->ingress != rule->ruleset->ingress)\n\t\t\tcontinue;\n\t\tif (ruleset->ht_key.chain_index != rule->chain_index)\n\t\t\tcontinue;\n\n\t\truleset->prio.min = min(ruleset->prio.min, rule->priority);\n\t\truleset->prio.max = max(ruleset->prio.max, rule->priority);\n\t}\n}\n\nvoid\nprestera_acl_rule_keymask_pcl_id_set(struct prestera_acl_rule *rule, u16 pcl_id)\n{\n\tstruct prestera_acl_match *r_match = &rule->re_key.match;\n\t__be16 pcl_id_mask = htons(PRESTERA_ACL_KEYMASK_PCL_ID);\n\t__be16 pcl_id_key = htons(pcl_id);\n\n\trule_match_set(r_match->key, PCL_ID, pcl_id_key);\n\trule_match_set(r_match->mask, PCL_ID, pcl_id_mask);\n}\n\nstruct prestera_acl_rule *\nprestera_acl_rule_lookup(struct prestera_acl_ruleset *ruleset,\n\t\t\t unsigned long cookie)\n{\n\treturn rhashtable_lookup_fast(&ruleset->rule_ht, &cookie,\n\t\t\t\t      prestera_acl_rule_ht_params);\n}\n\nu32 prestera_acl_ruleset_index_get(const struct prestera_acl_ruleset *ruleset)\n{\n\treturn ruleset->index;\n}\n\nvoid prestera_acl_ruleset_prio_get(struct prestera_acl_ruleset *ruleset,\n\t\t\t\t   u32 *prio_min, u32 *prio_max)\n{\n\t*prio_min = ruleset->prio.min;\n\t*prio_max = ruleset->prio.max;\n}\n\nbool prestera_acl_ruleset_is_offload(struct prestera_acl_ruleset *ruleset)\n{\n\treturn ruleset->offload;\n}\n\nstruct prestera_acl_rule *\nprestera_acl_rule_create(struct prestera_acl_ruleset *ruleset,\n\t\t\t unsigned long cookie, u32 chain_index)\n{\n\tstruct prestera_acl_rule *rule;\n\n\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\tif (!rule)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trule->ruleset = ruleset;\n\trule->cookie = cookie;\n\trule->chain_index = chain_index;\n\n\trefcount_inc(&ruleset->refcount);\n\n\treturn rule;\n}\n\nvoid prestera_acl_rule_priority_set(struct prestera_acl_rule *rule,\n\t\t\t\t    u32 priority)\n{\n\trule->priority = priority;\n}\n\nvoid prestera_acl_rule_destroy(struct prestera_acl_rule *rule)\n{\n\tif (rule->jump_ruleset)\n\t\t \n\t\tprestera_acl_ruleset_put(rule->jump_ruleset);\n\n\tprestera_acl_ruleset_put(rule->ruleset);\n\tkfree(rule);\n}\n\nstatic void prestera_acl_ruleset_prio_update(struct prestera_acl_ruleset *ruleset,\n\t\t\t\t\t     u32 prio)\n{\n\truleset->prio.min = min(ruleset->prio.min, prio);\n\truleset->prio.max = max(ruleset->prio.max, prio);\n}\n\nint prestera_acl_rule_add(struct prestera_switch *sw,\n\t\t\t  struct prestera_acl_rule *rule)\n{\n\tint err;\n\tstruct prestera_acl_ruleset *ruleset = rule->ruleset;\n\tstruct prestera_flow_block *block = ruleset->ht_key.block;\n\n\t \n\terr = rhashtable_insert_fast(&ruleset->rule_ht, &rule->ht_node,\n\t\t\t\t     prestera_acl_rule_ht_params);\n\tif (err)\n\t\tgoto err_ht_insert;\n\n\tprestera_acl_rule_keymask_pcl_id_set(rule, ruleset->pcl_id);\n\trule->re_arg.vtcam_id = ruleset->vtcam_id;\n\trule->re_key.prio = rule->priority;\n\n\trule->re = prestera_acl_rule_entry_find(sw->acl, &rule->re_key);\n\terr = WARN_ON(rule->re) ? -EEXIST : 0;\n\tif (err)\n\t\tgoto err_rule_add;\n\n\trule->re = prestera_acl_rule_entry_create(sw->acl, &rule->re_key,\n\t\t\t\t\t\t  &rule->re_arg);\n\terr = !rule->re ? -EINVAL : 0;\n\tif (err)\n\t\tgoto err_rule_add;\n\n\t \n\tif (!ruleset->ht_key.chain_index && !ruleset->rule_count) {\n\t\terr = prestera_acl_ruleset_block_bind(ruleset, block);\n\t\tif (err)\n\t\t\tgoto err_acl_block_bind;\n\t}\n\n\tlist_add_tail(&rule->list, &sw->acl->rules);\n\truleset->rule_count++;\n\tprestera_acl_ruleset_prio_update(ruleset, rule->priority);\n\treturn 0;\n\nerr_acl_block_bind:\n\tprestera_acl_rule_entry_destroy(sw->acl, rule->re);\nerr_rule_add:\n\trule->re = NULL;\n\trhashtable_remove_fast(&ruleset->rule_ht, &rule->ht_node,\n\t\t\t       prestera_acl_rule_ht_params);\nerr_ht_insert:\n\treturn err;\n}\n\nvoid prestera_acl_rule_del(struct prestera_switch *sw,\n\t\t\t   struct prestera_acl_rule *rule)\n{\n\tstruct prestera_acl_ruleset *ruleset = rule->ruleset;\n\tstruct prestera_flow_block *block = ruleset->ht_key.block;\n\n\trhashtable_remove_fast(&ruleset->rule_ht, &rule->ht_node,\n\t\t\t       prestera_acl_rule_ht_params);\n\truleset->rule_count--;\n\tlist_del(&rule->list);\n\n\tprestera_acl_rule_entry_destroy(sw->acl, rule->re);\n\tprestera_acl_ruleset_prio_refresh(sw->acl, ruleset);\n\n\t \n\tif (!ruleset->ht_key.chain_index && !ruleset->rule_count)\n\t\tprestera_acl_ruleset_block_unbind(ruleset, block);\n}\n\nint prestera_acl_rule_get_stats(struct prestera_acl *acl,\n\t\t\t\tstruct prestera_acl_rule *rule,\n\t\t\t\tu64 *packets, u64 *bytes, u64 *last_use)\n{\n\tu64 current_packets;\n\tu64 current_bytes;\n\tint err;\n\n\terr = prestera_counter_stats_get(acl->sw->counter,\n\t\t\t\t\t rule->re->counter.block,\n\t\t\t\t\t rule->re->counter.id,\n\t\t\t\t\t &current_packets, &current_bytes);\n\tif (err)\n\t\treturn err;\n\n\t*packets = current_packets;\n\t*bytes = current_bytes;\n\t*last_use = jiffies;\n\n\treturn 0;\n}\n\nstruct prestera_acl_rule_entry *\nprestera_acl_rule_entry_find(struct prestera_acl *acl,\n\t\t\t     struct prestera_acl_rule_entry_key *key)\n{\n\treturn rhashtable_lookup_fast(&acl->acl_rule_entry_ht, key,\n\t\t\t\t      __prestera_acl_rule_entry_ht_params);\n}\n\nstatic int __prestera_acl_rule_entry2hw_del(struct prestera_switch *sw,\n\t\t\t\t\t    struct prestera_acl_rule_entry *e)\n{\n\treturn prestera_hw_vtcam_rule_del(sw, e->vtcam_id, e->hw_id);\n}\n\nstatic int __prestera_acl_rule_entry2hw_add(struct prestera_switch *sw,\n\t\t\t\t\t    struct prestera_acl_rule_entry *e)\n{\n\tstruct prestera_acl_hw_action_info act_hw[PRESTERA_ACL_RULE_ACTION_MAX];\n\tint act_num;\n\n\tmemset(&act_hw, 0, sizeof(act_hw));\n\tact_num = 0;\n\n\t \n\tif (e->accept.valid) {\n\t\tact_hw[act_num].id = PRESTERA_ACL_RULE_ACTION_ACCEPT;\n\t\tact_num++;\n\t}\n\t \n\tif (e->drop.valid) {\n\t\tact_hw[act_num].id = PRESTERA_ACL_RULE_ACTION_DROP;\n\t\tact_num++;\n\t}\n\t \n\tif (e->trap.valid) {\n\t\tact_hw[act_num].id = PRESTERA_ACL_RULE_ACTION_TRAP;\n\t\tact_num++;\n\t}\n\t \n\tif (e->police.valid) {\n\t\tact_hw[act_num].id = PRESTERA_ACL_RULE_ACTION_POLICE;\n\t\tact_hw[act_num].police = e->police.i;\n\t\tact_num++;\n\t}\n\t \n\tif (e->jump.valid) {\n\t\tact_hw[act_num].id = PRESTERA_ACL_RULE_ACTION_JUMP;\n\t\tact_hw[act_num].jump = e->jump.i;\n\t\tact_num++;\n\t}\n\t \n\tif (e->counter.block) {\n\t\tact_hw[act_num].id = PRESTERA_ACL_RULE_ACTION_COUNT;\n\t\tact_hw[act_num].count.id = e->counter.id;\n\t\tact_num++;\n\t}\n\n\treturn prestera_hw_vtcam_rule_add(sw, e->vtcam_id, e->key.prio,\n\t\t\t\t\t  e->key.match.key, e->key.match.mask,\n\t\t\t\t\t  act_hw, act_num, &e->hw_id);\n}\n\nstatic void\n__prestera_acl_rule_entry_act_destruct(struct prestera_switch *sw,\n\t\t\t\t       struct prestera_acl_rule_entry *e)\n{\n\t \n\tprestera_counter_put(sw->counter, e->counter.block, e->counter.id);\n\t \n\tif (e->police.valid)\n\t\tprestera_hw_policer_release(sw, e->police.i.id);\n}\n\nvoid prestera_acl_rule_entry_destroy(struct prestera_acl *acl,\n\t\t\t\t     struct prestera_acl_rule_entry *e)\n{\n\tint ret;\n\n\trhashtable_remove_fast(&acl->acl_rule_entry_ht, &e->ht_node,\n\t\t\t       __prestera_acl_rule_entry_ht_params);\n\n\tret = __prestera_acl_rule_entry2hw_del(acl->sw, e);\n\tWARN_ON(ret && ret != -ENODEV);\n\n\t__prestera_acl_rule_entry_act_destruct(acl->sw, e);\n\tkfree(e);\n}\n\nstatic int\n__prestera_acl_rule_entry_act_construct(struct prestera_switch *sw,\n\t\t\t\t\tstruct prestera_acl_rule_entry *e,\n\t\t\t\t\tstruct prestera_acl_rule_entry_arg *arg)\n{\n\tint err;\n\n\t \n\te->accept.valid = arg->accept.valid;\n\t \n\te->drop.valid = arg->drop.valid;\n\t \n\te->trap.valid = arg->trap.valid;\n\t \n\te->jump.valid = arg->jump.valid;\n\te->jump.i = arg->jump.i;\n\t \n\tif (arg->police.valid) {\n\t\tu8 type = arg->police.ingress ? PRESTERA_POLICER_TYPE_INGRESS :\n\t\t\t\t\t\tPRESTERA_POLICER_TYPE_EGRESS;\n\n\t\terr = prestera_hw_policer_create(sw, type, &e->police.i.id);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\terr = prestera_hw_policer_sr_tcm_set(sw, e->police.i.id,\n\t\t\t\t\t\t     arg->police.rate,\n\t\t\t\t\t\t     arg->police.burst);\n\t\tif (err) {\n\t\t\tprestera_hw_policer_release(sw, e->police.i.id);\n\t\t\tgoto err_out;\n\t\t}\n\t\te->police.valid = arg->police.valid;\n\t}\n\t \n\tif (arg->count.valid) {\n\t\terr = prestera_counter_get(sw->counter, arg->count.client,\n\t\t\t\t\t   &e->counter.block,\n\t\t\t\t\t   &e->counter.id);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\t__prestera_acl_rule_entry_act_destruct(sw, e);\n\treturn -EINVAL;\n}\n\nstruct prestera_acl_rule_entry *\nprestera_acl_rule_entry_create(struct prestera_acl *acl,\n\t\t\t       struct prestera_acl_rule_entry_key *key,\n\t\t\t       struct prestera_acl_rule_entry_arg *arg)\n{\n\tstruct prestera_acl_rule_entry *e;\n\tint err;\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e)\n\t\tgoto err_kzalloc;\n\n\tmemcpy(&e->key, key, sizeof(*key));\n\te->vtcam_id = arg->vtcam_id;\n\terr = __prestera_acl_rule_entry_act_construct(acl->sw, e, arg);\n\tif (err)\n\t\tgoto err_act_construct;\n\n\terr = __prestera_acl_rule_entry2hw_add(acl->sw, e);\n\tif (err)\n\t\tgoto err_hw_add;\n\n\terr = rhashtable_insert_fast(&acl->acl_rule_entry_ht, &e->ht_node,\n\t\t\t\t     __prestera_acl_rule_entry_ht_params);\n\tif (err)\n\t\tgoto err_ht_insert;\n\n\treturn e;\n\nerr_ht_insert:\n\tWARN_ON(__prestera_acl_rule_entry2hw_del(acl->sw, e));\nerr_hw_add:\n\t__prestera_acl_rule_entry_act_destruct(acl->sw, e);\nerr_act_construct:\n\tkfree(e);\nerr_kzalloc:\n\treturn NULL;\n}\n\nstatic int __prestera_acl_vtcam_id_try_fit(struct prestera_acl *acl, u8 lookup,\n\t\t\t\t\t   void *keymask, u32 *vtcam_id)\n{\n\tstruct prestera_acl_vtcam *vtcam;\n\tint i;\n\n\tlist_for_each_entry(vtcam, &acl->vtcam_list, list) {\n\t\tif (lookup != vtcam->lookup)\n\t\t\tcontinue;\n\n\t\tif (!keymask && !vtcam->is_keymask_set)\n\t\t\tgoto vtcam_found;\n\n\t\tif (!(keymask && vtcam->is_keymask_set))\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (i = 0; i < __PRESTERA_ACL_RULE_MATCH_TYPE_MAX; i++) {\n\t\t\t__be32 __keymask = ((__be32 *)keymask)[i];\n\n\t\t\tif (!__keymask)\n\t\t\t\t \n\t\t\t\tcontinue;\n\n\t\t\tif (__keymask & ~vtcam->keymask[i])\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == __PRESTERA_ACL_RULE_MATCH_TYPE_MAX)\n\t\t\t \n\t\t\tgoto vtcam_found;\n\t}\n\n\t \n\treturn -ENOENT;\n\nvtcam_found:\n\trefcount_inc(&vtcam->refcount);\n\t*vtcam_id = vtcam->id;\n\treturn 0;\n}\n\nint prestera_acl_vtcam_id_get(struct prestera_acl *acl, u8 lookup, u8 dir,\n\t\t\t      void *keymask, u32 *vtcam_id)\n{\n\tstruct prestera_acl_vtcam *vtcam;\n\tu32 new_vtcam_id;\n\tint err;\n\n\t \n\tlist_for_each_entry(vtcam, &acl->vtcam_list, list) {\n\t\tif (lookup != vtcam->lookup ||\n\t\t    dir != vtcam->direction)\n\t\t\tcontinue;\n\n\t\tif (!keymask && !vtcam->is_keymask_set) {\n\t\t\trefcount_inc(&vtcam->refcount);\n\t\t\tgoto vtcam_found;\n\t\t}\n\n\t\tif (keymask && vtcam->is_keymask_set &&\n\t\t    !memcmp(keymask, vtcam->keymask, sizeof(vtcam->keymask))) {\n\t\t\trefcount_inc(&vtcam->refcount);\n\t\t\tgoto vtcam_found;\n\t\t}\n\t}\n\n\t \n\tvtcam = kzalloc(sizeof(*vtcam), GFP_KERNEL);\n\tif (!vtcam)\n\t\treturn -ENOMEM;\n\n\terr = prestera_hw_vtcam_create(acl->sw, lookup, keymask, &new_vtcam_id,\n\t\t\t\t       dir);\n\tif (err) {\n\t\tkfree(vtcam);\n\n\t\t \n\t\tif (__prestera_acl_vtcam_id_try_fit(acl, lookup,\n\t\t\t\t\t\t    keymask, &new_vtcam_id))\n\t\t\treturn err;\n\n\t\t*vtcam_id = new_vtcam_id;\n\t\treturn 0;\n\t}\n\n\tvtcam->direction = dir;\n\tvtcam->id = new_vtcam_id;\n\tvtcam->lookup = lookup;\n\tif (keymask) {\n\t\tmemcpy(vtcam->keymask, keymask, sizeof(vtcam->keymask));\n\t\tvtcam->is_keymask_set = true;\n\t}\n\trefcount_set(&vtcam->refcount, 1);\n\tlist_add_rcu(&vtcam->list, &acl->vtcam_list);\n\nvtcam_found:\n\t*vtcam_id = vtcam->id;\n\treturn 0;\n}\n\nint prestera_acl_vtcam_id_put(struct prestera_acl *acl, u32 vtcam_id)\n{\n\tstruct prestera_acl_vtcam *vtcam;\n\tint err;\n\n\tlist_for_each_entry(vtcam, &acl->vtcam_list, list) {\n\t\tif (vtcam_id != vtcam->id)\n\t\t\tcontinue;\n\n\t\tif (!refcount_dec_and_test(&vtcam->refcount))\n\t\t\treturn 0;\n\n\t\terr = prestera_hw_vtcam_destroy(acl->sw, vtcam->id);\n\t\tif (err && err != -ENODEV) {\n\t\t\trefcount_set(&vtcam->refcount, 1);\n\t\t\treturn err;\n\t\t}\n\n\t\tlist_del(&vtcam->list);\n\t\tkfree(vtcam);\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nint prestera_acl_init(struct prestera_switch *sw)\n{\n\tstruct prestera_acl *acl;\n\tint err;\n\n\tacl = kzalloc(sizeof(*acl), GFP_KERNEL);\n\tif (!acl)\n\t\treturn -ENOMEM;\n\n\tacl->sw = sw;\n\tINIT_LIST_HEAD(&acl->rules);\n\tINIT_LIST_HEAD(&acl->vtcam_list);\n\tidr_init(&acl->uid);\n\n\terr = rhashtable_init(&acl->acl_rule_entry_ht,\n\t\t\t      &__prestera_acl_rule_entry_ht_params);\n\tif (err)\n\t\tgoto err_acl_rule_entry_ht_init;\n\n\terr = rhashtable_init(&acl->ruleset_ht,\n\t\t\t      &prestera_acl_ruleset_ht_params);\n\tif (err)\n\t\tgoto err_ruleset_ht_init;\n\n\tsw->acl = acl;\n\n\treturn 0;\n\nerr_ruleset_ht_init:\n\trhashtable_destroy(&acl->acl_rule_entry_ht);\nerr_acl_rule_entry_ht_init:\n\tkfree(acl);\n\treturn err;\n}\n\nvoid prestera_acl_fini(struct prestera_switch *sw)\n{\n\tstruct prestera_acl *acl = sw->acl;\n\n\tWARN_ON(!idr_is_empty(&acl->uid));\n\tidr_destroy(&acl->uid);\n\n\tWARN_ON(!list_empty(&acl->vtcam_list));\n\tWARN_ON(!list_empty(&acl->rules));\n\n\trhashtable_destroy(&acl->ruleset_ht);\n\trhashtable_destroy(&acl->acl_rule_entry_ht);\n\n\tkfree(acl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}