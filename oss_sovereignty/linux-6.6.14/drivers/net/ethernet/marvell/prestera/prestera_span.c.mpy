{
  "module_name": "prestera_span.c",
  "hash_id": "223d6250eab0657ca54bec0616e4ecdb1314e0b840bb8c04fae17163530ba91f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/prestera/prestera_span.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/list.h>\n\n#include \"prestera.h\"\n#include \"prestera_hw.h\"\n#include \"prestera_acl.h\"\n#include \"prestera_flow.h\"\n#include \"prestera_span.h\"\n\nstruct prestera_span_entry {\n\tstruct list_head list;\n\tstruct prestera_port *port;\n\trefcount_t ref_count;\n\tu8 id;\n};\n\nstruct prestera_span {\n\tstruct prestera_switch *sw;\n\tstruct list_head entries;\n};\n\nstatic struct prestera_span_entry *\nprestera_span_entry_create(struct prestera_port *port, u8 span_id)\n{\n\tstruct prestera_span_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trefcount_set(&entry->ref_count, 1);\n\tentry->port = port;\n\tentry->id = span_id;\n\tlist_add_tail(&entry->list, &port->sw->span->entries);\n\n\treturn entry;\n}\n\nstatic void prestera_span_entry_del(struct prestera_span_entry *entry)\n{\n\tlist_del(&entry->list);\n\tkfree(entry);\n}\n\nstatic struct prestera_span_entry *\nprestera_span_entry_find_by_id(struct prestera_span *span, u8 span_id)\n{\n\tstruct prestera_span_entry *entry;\n\n\tlist_for_each_entry(entry, &span->entries, list) {\n\t\tif (entry->id == span_id)\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct prestera_span_entry *\nprestera_span_entry_find_by_port(struct prestera_span *span,\n\t\t\t\t struct prestera_port *port)\n{\n\tstruct prestera_span_entry *entry;\n\n\tlist_for_each_entry(entry, &span->entries, list) {\n\t\tif (entry->port == port)\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\nstatic int prestera_span_get(struct prestera_port *port, u8 *span_id)\n{\n\tu8 new_span_id;\n\tstruct prestera_switch *sw = port->sw;\n\tstruct prestera_span_entry *entry;\n\tint err;\n\n\tentry = prestera_span_entry_find_by_port(sw->span, port);\n\tif (entry) {\n\t\trefcount_inc(&entry->ref_count);\n\t\t*span_id = entry->id;\n\t\treturn 0;\n\t}\n\n\terr = prestera_hw_span_get(port, &new_span_id);\n\tif (err)\n\t\treturn err;\n\n\tentry = prestera_span_entry_create(port, new_span_id);\n\tif (IS_ERR(entry)) {\n\t\tprestera_hw_span_release(sw, new_span_id);\n\t\treturn PTR_ERR(entry);\n\t}\n\n\t*span_id = new_span_id;\n\treturn 0;\n}\n\nstatic int prestera_span_put(struct prestera_switch *sw, u8 span_id)\n{\n\tstruct prestera_span_entry *entry;\n\tint err;\n\n\tentry = prestera_span_entry_find_by_id(sw->span, span_id);\n\tif (!entry)\n\t\treturn -ENOENT;\n\n\tif (!refcount_dec_and_test(&entry->ref_count))\n\t\treturn 0;\n\n\terr = prestera_hw_span_release(sw, span_id);\n\tif (err)\n\t\treturn err;\n\n\tprestera_span_entry_del(entry);\n\treturn 0;\n}\n\nint prestera_span_rule_add(struct prestera_flow_block_binding *binding,\n\t\t\t   struct prestera_port *to_port,\n\t\t\t   bool ingress)\n{\n\tstruct prestera_switch *sw = binding->port->sw;\n\tu8 span_id;\n\tint err;\n\n\tif (binding->span_id != PRESTERA_SPAN_INVALID_ID)\n\t\t \n\t\treturn -EEXIST;\n\n\terr = prestera_span_get(to_port, &span_id);\n\tif (err)\n\t\treturn err;\n\n\terr = prestera_hw_span_bind(binding->port, span_id, ingress);\n\tif (err) {\n\t\tprestera_span_put(sw, span_id);\n\t\treturn err;\n\t}\n\n\tbinding->span_id = span_id;\n\treturn 0;\n}\n\nint prestera_span_rule_del(struct prestera_flow_block_binding *binding,\n\t\t\t   bool ingress)\n{\n\tint err;\n\n\tif (binding->span_id == PRESTERA_SPAN_INVALID_ID)\n\t\treturn -ENOENT;\n\n\terr = prestera_hw_span_unbind(binding->port, ingress);\n\tif (err)\n\t\treturn err;\n\n\terr = prestera_span_put(binding->port->sw, binding->span_id);\n\tif (err)\n\t\treturn err;\n\n\tbinding->span_id = PRESTERA_SPAN_INVALID_ID;\n\treturn 0;\n}\n\nint prestera_span_init(struct prestera_switch *sw)\n{\n\tstruct prestera_span *span;\n\n\tspan = kzalloc(sizeof(*span), GFP_KERNEL);\n\tif (!span)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&span->entries);\n\n\tsw->span = span;\n\tspan->sw = sw;\n\n\treturn 0;\n}\n\nvoid prestera_span_fini(struct prestera_switch *sw)\n{\n\tstruct prestera_span *span = sw->span;\n\n\tWARN_ON(!list_empty(&span->entries));\n\tkfree(span);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}