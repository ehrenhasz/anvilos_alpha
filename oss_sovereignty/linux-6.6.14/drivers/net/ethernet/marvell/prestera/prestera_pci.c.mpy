{
  "module_name": "prestera_pci.c",
  "hash_id": "e20c9ed20c98426c557efc4b4441e93a3483b99f3e06b2ccb57d0018bb144f52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/prestera/prestera_pci.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/circ_buf.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"prestera.h\"\n\n#define PRESTERA_MSG_MAX_SIZE 1500\n\n#define PRESTERA_SUPP_FW_MAJ_VER\t4\n#define PRESTERA_SUPP_FW_MIN_VER\t1\n\n#define PRESTERA_PREV_FW_MAJ_VER\t4\n#define PRESTERA_PREV_FW_MIN_VER\t0\n\n#define PRESTERA_FW_PATH_FMT\t\"mrvl/prestera/mvsw_prestera_fw-v%u.%u.img\"\n#define PRESTERA_FW_ARM64_PATH_FMT \"mrvl/prestera/mvsw_prestera_fw_arm64-v%u.%u.img\"\n\n#define PRESTERA_FW_HDR_MAGIC\t\t0x351D9D06\n#define PRESTERA_FW_DL_TIMEOUT_MS\t50000\n#define PRESTERA_FW_BLK_SZ\t\t1024\n\n#define PRESTERA_FW_VER_MAJ_MUL 1000000\n#define PRESTERA_FW_VER_MIN_MUL 1000\n\n#define PRESTERA_FW_VER_MAJ(v)\t((v) / PRESTERA_FW_VER_MAJ_MUL)\n\n#define PRESTERA_FW_VER_MIN(v) \\\n\t(((v) - (PRESTERA_FW_VER_MAJ(v) * PRESTERA_FW_VER_MAJ_MUL)) / \\\n\t\t\tPRESTERA_FW_VER_MIN_MUL)\n\n#define PRESTERA_FW_VER_PATCH(v) \\\n\t((v) - (PRESTERA_FW_VER_MAJ(v) * PRESTERA_FW_VER_MAJ_MUL) - \\\n\t\t\t(PRESTERA_FW_VER_MIN(v) * PRESTERA_FW_VER_MIN_MUL))\n\nenum prestera_pci_bar_t {\n\tPRESTERA_PCI_BAR_FW = 2,\n\tPRESTERA_PCI_BAR_PP = 4,\n};\n\nstruct prestera_fw_header {\n\t__be32 magic_number;\n\t__be32 version_value;\n\tu8 reserved[8];\n};\n\nstruct prestera_ldr_regs {\n\tu32 ldr_ready;\n\tu32 pad1;\n\n\tu32 ldr_img_size;\n\tu32 ldr_ctl_flags;\n\n\tu32 ldr_buf_offs;\n\tu32 ldr_buf_size;\n\n\tu32 ldr_buf_rd;\n\tu32 pad2;\n\tu32 ldr_buf_wr;\n\n\tu32 ldr_status;\n};\n\n#define PRESTERA_LDR_REG_OFFSET(f)\toffsetof(struct prestera_ldr_regs, f)\n\n#define PRESTERA_LDR_READY_MAGIC\t0xf00dfeed\n\n#define PRESTERA_LDR_STATUS_IMG_DL\tBIT(0)\n#define PRESTERA_LDR_STATUS_START_FW\tBIT(1)\n#define PRESTERA_LDR_STATUS_INVALID_IMG\tBIT(2)\n#define PRESTERA_LDR_STATUS_NOMEM\tBIT(3)\n\n#define PRESTERA_LDR_REG_BASE(fw)\t((fw)->ldr_regs)\n#define PRESTERA_LDR_REG_ADDR(fw, reg)\t(PRESTERA_LDR_REG_BASE(fw) + (reg))\n\n \n#define PRESTERA_LDR_READY_REG\t\tPRESTERA_LDR_REG_OFFSET(ldr_ready)\n#define PRESTERA_LDR_IMG_SIZE_REG\tPRESTERA_LDR_REG_OFFSET(ldr_img_size)\n#define PRESTERA_LDR_CTL_REG\t\tPRESTERA_LDR_REG_OFFSET(ldr_ctl_flags)\n#define PRESTERA_LDR_BUF_SIZE_REG\tPRESTERA_LDR_REG_OFFSET(ldr_buf_size)\n#define PRESTERA_LDR_BUF_OFFS_REG\tPRESTERA_LDR_REG_OFFSET(ldr_buf_offs)\n#define PRESTERA_LDR_BUF_RD_REG\t\tPRESTERA_LDR_REG_OFFSET(ldr_buf_rd)\n#define PRESTERA_LDR_BUF_WR_REG\t\tPRESTERA_LDR_REG_OFFSET(ldr_buf_wr)\n#define PRESTERA_LDR_STATUS_REG\t\tPRESTERA_LDR_REG_OFFSET(ldr_status)\n\n#define PRESTERA_LDR_CTL_DL_START\tBIT(0)\n\n#define PRESTERA_EVT_QNUM_MAX\t4\n\nstruct prestera_fw_evtq_regs {\n\tu32 rd_idx;\n\tu32 pad1;\n\tu32 wr_idx;\n\tu32 pad2;\n\tu32 offs;\n\tu32 len;\n};\n\n#define PRESTERA_CMD_QNUM_MAX\t4\n\nstruct prestera_fw_cmdq_regs {\n\tu32 req_ctl;\n\tu32 req_len;\n\tu32 rcv_ctl;\n\tu32 rcv_len;\n\tu32 offs;\n\tu32 len;\n};\n\nstruct prestera_fw_regs {\n\tu32 fw_ready;\n\tu32 cmd_offs;\n\tu32 cmd_len;\n\tu32 cmd_qnum;\n\tu32 evt_offs;\n\tu32 evt_qnum;\n\n\tu32 fw_status;\n\tu32 rx_status;\n\n\tstruct prestera_fw_cmdq_regs cmdq_list[PRESTERA_EVT_QNUM_MAX];\n\tstruct prestera_fw_evtq_regs evtq_list[PRESTERA_CMD_QNUM_MAX];\n};\n\n#define PRESTERA_FW_REG_OFFSET(f)\toffsetof(struct prestera_fw_regs, f)\n\n#define PRESTERA_FW_READY_MAGIC\t\t0xcafebabe\n\n \n#define PRESTERA_FW_READY_REG\t\tPRESTERA_FW_REG_OFFSET(fw_ready)\n\n#define PRESTERA_CMD_BUF_OFFS_REG\tPRESTERA_FW_REG_OFFSET(cmd_offs)\n#define PRESTERA_CMD_BUF_LEN_REG\tPRESTERA_FW_REG_OFFSET(cmd_len)\n#define PRESTERA_CMD_QNUM_REG\t\tPRESTERA_FW_REG_OFFSET(cmd_qnum)\n#define PRESTERA_EVT_BUF_OFFS_REG\tPRESTERA_FW_REG_OFFSET(evt_offs)\n#define PRESTERA_EVT_QNUM_REG\t\tPRESTERA_FW_REG_OFFSET(evt_qnum)\n\n#define PRESTERA_CMDQ_REG_OFFSET(q, f)\t\t\t\\\n\t(PRESTERA_FW_REG_OFFSET(cmdq_list) +\t\t\\\n\t (q) * sizeof(struct prestera_fw_cmdq_regs) +\t\\\n\t offsetof(struct prestera_fw_cmdq_regs, f))\n\n#define PRESTERA_CMDQ_REQ_CTL_REG(q)\tPRESTERA_CMDQ_REG_OFFSET(q, req_ctl)\n#define PRESTERA_CMDQ_REQ_LEN_REG(q)\tPRESTERA_CMDQ_REG_OFFSET(q, req_len)\n#define PRESTERA_CMDQ_RCV_CTL_REG(q)\tPRESTERA_CMDQ_REG_OFFSET(q, rcv_ctl)\n#define PRESTERA_CMDQ_RCV_LEN_REG(q)\tPRESTERA_CMDQ_REG_OFFSET(q, rcv_len)\n#define PRESTERA_CMDQ_OFFS_REG(q)\tPRESTERA_CMDQ_REG_OFFSET(q, offs)\n#define PRESTERA_CMDQ_LEN_REG(q)\tPRESTERA_CMDQ_REG_OFFSET(q, len)\n\n#define PRESTERA_FW_STATUS_REG\t\tPRESTERA_FW_REG_OFFSET(fw_status)\n#define PRESTERA_RX_STATUS_REG\t\tPRESTERA_FW_REG_OFFSET(rx_status)\n\n \n#define PRESTERA_CMD_F_REQ_SENT\t\tBIT(0)\n#define PRESTERA_CMD_F_REPL_RCVD\tBIT(1)\n\n \n#define PRESTERA_CMD_F_REPL_SENT\tBIT(0)\n\n#define PRESTERA_FW_EVT_CTL_STATUS_MASK\tGENMASK(1, 0)\n\n#define PRESTERA_FW_EVT_CTL_STATUS_ON\t0\n#define PRESTERA_FW_EVT_CTL_STATUS_OFF\t1\n\n#define PRESTERA_EVTQ_REG_OFFSET(q, f)\t\t\t\\\n\t(PRESTERA_FW_REG_OFFSET(evtq_list) +\t\t\\\n\t (q) * sizeof(struct prestera_fw_evtq_regs) +\t\\\n\t offsetof(struct prestera_fw_evtq_regs, f))\n\n#define PRESTERA_EVTQ_RD_IDX_REG(q)\tPRESTERA_EVTQ_REG_OFFSET(q, rd_idx)\n#define PRESTERA_EVTQ_WR_IDX_REG(q)\tPRESTERA_EVTQ_REG_OFFSET(q, wr_idx)\n#define PRESTERA_EVTQ_OFFS_REG(q)\tPRESTERA_EVTQ_REG_OFFSET(q, offs)\n#define PRESTERA_EVTQ_LEN_REG(q)\tPRESTERA_EVTQ_REG_OFFSET(q, len)\n\n#define PRESTERA_FW_REG_BASE(fw)\t((fw)->dev.ctl_regs)\n#define PRESTERA_FW_REG_ADDR(fw, reg)\tPRESTERA_FW_REG_BASE((fw)) + (reg)\n\n#define PRESTERA_FW_CMD_DEFAULT_WAIT_MS\t30000\n#define PRESTERA_FW_READY_WAIT_MS\t20000\n\n#define PRESTERA_DEV_ID_AC3X_98DX_55\t0xC804\n#define PRESTERA_DEV_ID_AC3X_98DX_65\t0xC80C\n#define PRESTERA_DEV_ID_ALDRIN2\t\t0xCC1E\n#define PRESTERA_DEV_ID_98DX7312M\t0x981F\n#define PRESTERA_DEV_ID_98DX3500\t0x9820\n#define PRESTERA_DEV_ID_98DX3501\t0x9826\n#define PRESTERA_DEV_ID_98DX3510\t0x9821\n#define PRESTERA_DEV_ID_98DX3520\t0x9822\n\nstruct prestera_fw_evtq {\n\tu8 __iomem *addr;\n\tsize_t len;\n};\n\nstruct prestera_fw_cmdq {\n\t \n\tstruct mutex cmd_mtx;\n\tu8 __iomem *addr;\n\tsize_t len;\n};\n\nstruct prestera_fw {\n\tstruct prestera_fw_rev rev_supp;\n\tconst struct firmware *bin;\n\tstruct workqueue_struct *wq;\n\tstruct prestera_device dev;\n\tstruct pci_dev *pci_dev;\n\tu8 __iomem *ldr_regs;\n\tu8 __iomem *ldr_ring_buf;\n\tu32 ldr_buf_len;\n\tu32 ldr_wr_idx;\n\tsize_t cmd_mbox_len;\n\tu8 __iomem *cmd_mbox;\n\tstruct prestera_fw_cmdq cmd_queue[PRESTERA_CMD_QNUM_MAX];\n\tu8 cmd_qnum;\n\tstruct prestera_fw_evtq evt_queue[PRESTERA_EVT_QNUM_MAX];\n\tu8 evt_qnum;\n\tstruct work_struct evt_work;\n\tu8 __iomem *evt_buf;\n\tu8 *evt_msg;\n};\n\nstatic int prestera_fw_load(struct prestera_fw *fw);\n\nstatic void prestera_fw_write(struct prestera_fw *fw, u32 reg, u32 val)\n{\n\twritel(val, PRESTERA_FW_REG_ADDR(fw, reg));\n}\n\nstatic u32 prestera_fw_read(struct prestera_fw *fw, u32 reg)\n{\n\treturn readl(PRESTERA_FW_REG_ADDR(fw, reg));\n}\n\nstatic u32 prestera_fw_evtq_len(struct prestera_fw *fw, u8 qid)\n{\n\treturn fw->evt_queue[qid].len;\n}\n\nstatic u32 prestera_fw_evtq_avail(struct prestera_fw *fw, u8 qid)\n{\n\tu32 wr_idx = prestera_fw_read(fw, PRESTERA_EVTQ_WR_IDX_REG(qid));\n\tu32 rd_idx = prestera_fw_read(fw, PRESTERA_EVTQ_RD_IDX_REG(qid));\n\n\treturn CIRC_CNT(wr_idx, rd_idx, prestera_fw_evtq_len(fw, qid));\n}\n\nstatic void prestera_fw_evtq_rd_set(struct prestera_fw *fw,\n\t\t\t\t    u8 qid, u32 idx)\n{\n\tu32 rd_idx = idx & (prestera_fw_evtq_len(fw, qid) - 1);\n\n\tprestera_fw_write(fw, PRESTERA_EVTQ_RD_IDX_REG(qid), rd_idx);\n}\n\nstatic u8 __iomem *prestera_fw_evtq_buf(struct prestera_fw *fw, u8 qid)\n{\n\treturn fw->evt_queue[qid].addr;\n}\n\nstatic u32 prestera_fw_evtq_read32(struct prestera_fw *fw, u8 qid)\n{\n\tu32 rd_idx = prestera_fw_read(fw, PRESTERA_EVTQ_RD_IDX_REG(qid));\n\tu32 val;\n\n\tval = readl(prestera_fw_evtq_buf(fw, qid) + rd_idx);\n\tprestera_fw_evtq_rd_set(fw, qid, rd_idx + 4);\n\treturn val;\n}\n\nstatic ssize_t prestera_fw_evtq_read_buf(struct prestera_fw *fw,\n\t\t\t\t\t u8 qid, void *buf, size_t len)\n{\n\tu32 idx = prestera_fw_read(fw, PRESTERA_EVTQ_RD_IDX_REG(qid));\n\tu8 __iomem *evtq_addr = prestera_fw_evtq_buf(fw, qid);\n\tu32 *buf32 = buf;\n\tint i;\n\n\tfor (i = 0; i < len / 4; buf32++, i++) {\n\t\t*buf32 = readl_relaxed(evtq_addr + idx);\n\t\tidx = (idx + 4) & (prestera_fw_evtq_len(fw, qid) - 1);\n\t}\n\n\tprestera_fw_evtq_rd_set(fw, qid, idx);\n\n\treturn i;\n}\n\nstatic u8 prestera_fw_evtq_pick(struct prestera_fw *fw)\n{\n\tint qid;\n\n\tfor (qid = 0; qid < fw->evt_qnum; qid++) {\n\t\tif (prestera_fw_evtq_avail(fw, qid) >= 4)\n\t\t\treturn qid;\n\t}\n\n\treturn PRESTERA_EVT_QNUM_MAX;\n}\n\nstatic void prestera_fw_evt_ctl_status_set(struct prestera_fw *fw, u32 val)\n{\n\tu32 status = prestera_fw_read(fw, PRESTERA_FW_STATUS_REG);\n\n\tu32p_replace_bits(&status, val, PRESTERA_FW_EVT_CTL_STATUS_MASK);\n\n\tprestera_fw_write(fw, PRESTERA_FW_STATUS_REG, status);\n}\n\nstatic void prestera_fw_evt_work_fn(struct work_struct *work)\n{\n\tstruct prestera_fw *fw;\n\tvoid *msg;\n\tu8 qid;\n\n\tfw = container_of(work, struct prestera_fw, evt_work);\n\tmsg = fw->evt_msg;\n\n\tprestera_fw_evt_ctl_status_set(fw, PRESTERA_FW_EVT_CTL_STATUS_OFF);\n\n\twhile ((qid = prestera_fw_evtq_pick(fw)) < PRESTERA_EVT_QNUM_MAX) {\n\t\tu32 idx;\n\t\tu32 len;\n\n\t\tlen = prestera_fw_evtq_read32(fw, qid);\n\t\tidx = prestera_fw_read(fw, PRESTERA_EVTQ_RD_IDX_REG(qid));\n\n\t\tWARN_ON(prestera_fw_evtq_avail(fw, qid) < len);\n\n\t\tif (WARN_ON(len > PRESTERA_MSG_MAX_SIZE)) {\n\t\t\tprestera_fw_evtq_rd_set(fw, qid, idx + len);\n\t\t\tcontinue;\n\t\t}\n\n\t\tprestera_fw_evtq_read_buf(fw, qid, msg, len);\n\n\t\tif (fw->dev.recv_msg)\n\t\t\tfw->dev.recv_msg(&fw->dev, msg, len);\n\t}\n\n\tprestera_fw_evt_ctl_status_set(fw, PRESTERA_FW_EVT_CTL_STATUS_ON);\n}\n\nstatic int prestera_fw_wait_reg32(struct prestera_fw *fw, u32 reg, u32 cmp,\n\t\t\t\t  unsigned int waitms)\n{\n\tu8 __iomem *addr = PRESTERA_FW_REG_ADDR(fw, reg);\n\tu32 val;\n\n\treturn readl_poll_timeout(addr, val, cmp == val,\n\t\t\t\t  1 * USEC_PER_MSEC, waitms * USEC_PER_MSEC);\n}\n\nstatic void prestera_fw_cmdq_lock(struct prestera_fw *fw, u8 qid)\n{\n\tmutex_lock(&fw->cmd_queue[qid].cmd_mtx);\n}\n\nstatic void prestera_fw_cmdq_unlock(struct prestera_fw *fw, u8 qid)\n{\n\tmutex_unlock(&fw->cmd_queue[qid].cmd_mtx);\n}\n\nstatic u32 prestera_fw_cmdq_len(struct prestera_fw *fw, u8 qid)\n{\n\treturn fw->cmd_queue[qid].len;\n}\n\nstatic u8 __iomem *prestera_fw_cmdq_buf(struct prestera_fw *fw, u8 qid)\n{\n\treturn fw->cmd_queue[qid].addr;\n}\n\nstatic int prestera_fw_cmd_send(struct prestera_fw *fw, int qid,\n\t\t\t\tvoid *in_msg, size_t in_size,\n\t\t\t\tvoid *out_msg, size_t out_size,\n\t\t\t\tunsigned int waitms)\n{\n\tu32 ret_size;\n\tint err;\n\n\tif (!waitms)\n\t\twaitms = PRESTERA_FW_CMD_DEFAULT_WAIT_MS;\n\n\tif (ALIGN(in_size, 4) > prestera_fw_cmdq_len(fw, qid))\n\t\treturn -EMSGSIZE;\n\n\t \n\terr = prestera_fw_wait_reg32(fw, PRESTERA_CMDQ_RCV_CTL_REG(qid), 0, 30);\n\tif (err) {\n\t\tdev_err(fw->dev.dev, \"finish reply from FW is timed out\\n\");\n\t\treturn err;\n\t}\n\n\tprestera_fw_write(fw, PRESTERA_CMDQ_REQ_LEN_REG(qid), in_size);\n\n\tmemcpy_toio(prestera_fw_cmdq_buf(fw, qid), in_msg, in_size);\n\n\tprestera_fw_write(fw, PRESTERA_CMDQ_REQ_CTL_REG(qid),\n\t\t\t  PRESTERA_CMD_F_REQ_SENT);\n\n\t \n\terr = prestera_fw_wait_reg32(fw, PRESTERA_CMDQ_RCV_CTL_REG(qid),\n\t\t\t\t     PRESTERA_CMD_F_REPL_SENT, waitms);\n\tif (err) {\n\t\tdev_err(fw->dev.dev, \"reply from FW is timed out\\n\");\n\t\tgoto cmd_exit;\n\t}\n\n\tret_size = prestera_fw_read(fw, PRESTERA_CMDQ_RCV_LEN_REG(qid));\n\tif (ret_size > out_size) {\n\t\tdev_err(fw->dev.dev, \"ret_size (%u) > out_len(%zu)\\n\",\n\t\t\tret_size, out_size);\n\t\terr = -EMSGSIZE;\n\t\tgoto cmd_exit;\n\t}\n\n\tmemcpy_fromio(out_msg,\n\t\t      prestera_fw_cmdq_buf(fw, qid) + in_size, ret_size);\n\ncmd_exit:\n\tprestera_fw_write(fw, PRESTERA_CMDQ_REQ_CTL_REG(qid),\n\t\t\t  PRESTERA_CMD_F_REPL_RCVD);\n\treturn err;\n}\n\nstatic int prestera_fw_send_req(struct prestera_device *dev, int qid,\n\t\t\t\tvoid *in_msg, size_t in_size, void *out_msg,\n\t\t\t\tsize_t out_size, unsigned int waitms)\n{\n\tstruct prestera_fw *fw;\n\tssize_t ret;\n\n\tfw = container_of(dev, struct prestera_fw, dev);\n\n\tprestera_fw_cmdq_lock(fw, qid);\n\tret = prestera_fw_cmd_send(fw, qid, in_msg, in_size, out_msg, out_size,\n\t\t\t\t   waitms);\n\tprestera_fw_cmdq_unlock(fw, qid);\n\n\treturn ret;\n}\n\nstatic int prestera_fw_init(struct prestera_fw *fw)\n{\n\tu8 __iomem *base;\n\tint err;\n\tu8 qid;\n\n\tfw->dev.send_req = prestera_fw_send_req;\n\tfw->ldr_regs = fw->dev.ctl_regs;\n\n\terr = prestera_fw_load(fw);\n\tif (err)\n\t\treturn err;\n\n\terr = prestera_fw_wait_reg32(fw, PRESTERA_FW_READY_REG,\n\t\t\t\t     PRESTERA_FW_READY_MAGIC,\n\t\t\t\t     PRESTERA_FW_READY_WAIT_MS);\n\tif (err) {\n\t\tdev_err(fw->dev.dev, \"FW failed to start\\n\");\n\t\treturn err;\n\t}\n\n\tbase = fw->dev.ctl_regs;\n\n\tfw->cmd_mbox = base + prestera_fw_read(fw, PRESTERA_CMD_BUF_OFFS_REG);\n\tfw->cmd_mbox_len = prestera_fw_read(fw, PRESTERA_CMD_BUF_LEN_REG);\n\tfw->cmd_qnum = prestera_fw_read(fw, PRESTERA_CMD_QNUM_REG);\n\n\tfor (qid = 0; qid < fw->cmd_qnum; qid++) {\n\t\tu32 offs = prestera_fw_read(fw, PRESTERA_CMDQ_OFFS_REG(qid));\n\t\tstruct prestera_fw_cmdq *cmdq = &fw->cmd_queue[qid];\n\n\t\tcmdq->len = prestera_fw_read(fw, PRESTERA_CMDQ_LEN_REG(qid));\n\t\tcmdq->addr = fw->cmd_mbox + offs;\n\t\tmutex_init(&cmdq->cmd_mtx);\n\t}\n\n\tfw->evt_buf = base + prestera_fw_read(fw, PRESTERA_EVT_BUF_OFFS_REG);\n\tfw->evt_qnum = prestera_fw_read(fw, PRESTERA_EVT_QNUM_REG);\n\tfw->evt_msg = kmalloc(PRESTERA_MSG_MAX_SIZE, GFP_KERNEL);\n\tif (!fw->evt_msg)\n\t\treturn -ENOMEM;\n\n\tfor (qid = 0; qid < fw->evt_qnum; qid++) {\n\t\tu32 offs = prestera_fw_read(fw, PRESTERA_EVTQ_OFFS_REG(qid));\n\t\tstruct prestera_fw_evtq *evtq = &fw->evt_queue[qid];\n\n\t\tevtq->len = prestera_fw_read(fw, PRESTERA_EVTQ_LEN_REG(qid));\n\t\tevtq->addr = fw->evt_buf + offs;\n\t}\n\n\treturn 0;\n}\n\nstatic void prestera_fw_uninit(struct prestera_fw *fw)\n{\n\tkfree(fw->evt_msg);\n}\n\nstatic irqreturn_t prestera_pci_irq_handler(int irq, void *dev_id)\n{\n\tstruct prestera_fw *fw = dev_id;\n\n\tif (prestera_fw_read(fw, PRESTERA_RX_STATUS_REG)) {\n\t\tprestera_fw_write(fw, PRESTERA_RX_STATUS_REG, 0);\n\n\t\tif (fw->dev.recv_pkt)\n\t\t\tfw->dev.recv_pkt(&fw->dev);\n\t}\n\n\tqueue_work(fw->wq, &fw->evt_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void prestera_ldr_write(struct prestera_fw *fw, u32 reg, u32 val)\n{\n\twritel(val, PRESTERA_LDR_REG_ADDR(fw, reg));\n}\n\nstatic u32 prestera_ldr_read(struct prestera_fw *fw, u32 reg)\n{\n\treturn readl(PRESTERA_LDR_REG_ADDR(fw, reg));\n}\n\nstatic int prestera_ldr_wait_reg32(struct prestera_fw *fw,\n\t\t\t\t   u32 reg, u32 cmp, unsigned int waitms)\n{\n\tu8 __iomem *addr = PRESTERA_LDR_REG_ADDR(fw, reg);\n\tu32 val;\n\n\treturn readl_poll_timeout(addr, val, cmp == val,\n\t\t\t\t  10 * USEC_PER_MSEC, waitms * USEC_PER_MSEC);\n}\n\nstatic u32 prestera_ldr_wait_buf(struct prestera_fw *fw, size_t len)\n{\n\tu8 __iomem *addr = PRESTERA_LDR_REG_ADDR(fw, PRESTERA_LDR_BUF_RD_REG);\n\tu32 buf_len = fw->ldr_buf_len;\n\tu32 wr_idx = fw->ldr_wr_idx;\n\tu32 rd_idx;\n\n\treturn readl_poll_timeout(addr, rd_idx,\n\t\t\t\t CIRC_SPACE(wr_idx, rd_idx, buf_len) >= len,\n\t\t\t\t 1 * USEC_PER_MSEC, 100 * USEC_PER_MSEC);\n}\n\nstatic int prestera_ldr_wait_dl_finish(struct prestera_fw *fw)\n{\n\tu8 __iomem *addr = PRESTERA_LDR_REG_ADDR(fw, PRESTERA_LDR_STATUS_REG);\n\tunsigned long mask = ~(PRESTERA_LDR_STATUS_IMG_DL);\n\tu32 val;\n\tint err;\n\n\terr = readl_poll_timeout(addr, val, val & mask, 10 * USEC_PER_MSEC,\n\t\t\t\t PRESTERA_FW_DL_TIMEOUT_MS * USEC_PER_MSEC);\n\tif (err) {\n\t\tdev_err(fw->dev.dev, \"Timeout to load FW img [state=%d]\",\n\t\t\tprestera_ldr_read(fw, PRESTERA_LDR_STATUS_REG));\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void prestera_ldr_wr_idx_move(struct prestera_fw *fw, unsigned int n)\n{\n\tfw->ldr_wr_idx = (fw->ldr_wr_idx + (n)) & (fw->ldr_buf_len - 1);\n}\n\nstatic void prestera_ldr_wr_idx_commit(struct prestera_fw *fw)\n{\n\tprestera_ldr_write(fw, PRESTERA_LDR_BUF_WR_REG, fw->ldr_wr_idx);\n}\n\nstatic u8 __iomem *prestera_ldr_wr_ptr(struct prestera_fw *fw)\n{\n\treturn fw->ldr_ring_buf + fw->ldr_wr_idx;\n}\n\nstatic int prestera_ldr_send(struct prestera_fw *fw, const u8 *buf, size_t len)\n{\n\tint err;\n\tint i;\n\n\terr = prestera_ldr_wait_buf(fw, len);\n\tif (err) {\n\t\tdev_err(fw->dev.dev, \"failed wait for sending firmware\\n\");\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < len; i += 4) {\n\t\twritel_relaxed(*(u32 *)(buf + i), prestera_ldr_wr_ptr(fw));\n\t\tprestera_ldr_wr_idx_move(fw, 4);\n\t}\n\n\tprestera_ldr_wr_idx_commit(fw);\n\treturn 0;\n}\n\nstatic int prestera_ldr_fw_send(struct prestera_fw *fw,\n\t\t\t\tconst char *img, u32 fw_size)\n{\n\tu32 status;\n\tu32 pos;\n\tint err;\n\n\terr = prestera_ldr_wait_reg32(fw, PRESTERA_LDR_STATUS_REG,\n\t\t\t\t      PRESTERA_LDR_STATUS_IMG_DL,\n\t\t\t\t      5 * MSEC_PER_SEC);\n\tif (err) {\n\t\tdev_err(fw->dev.dev, \"Loader is not ready to load image\\n\");\n\t\treturn err;\n\t}\n\n\tfor (pos = 0; pos < fw_size; pos += PRESTERA_FW_BLK_SZ) {\n\t\tif (pos + PRESTERA_FW_BLK_SZ > fw_size)\n\t\t\tbreak;\n\n\t\terr = prestera_ldr_send(fw, img + pos, PRESTERA_FW_BLK_SZ);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (pos < fw_size) {\n\t\terr = prestera_ldr_send(fw, img + pos, fw_size - pos);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = prestera_ldr_wait_dl_finish(fw);\n\tif (err)\n\t\treturn err;\n\n\tstatus = prestera_ldr_read(fw, PRESTERA_LDR_STATUS_REG);\n\n\tswitch (status) {\n\tcase PRESTERA_LDR_STATUS_INVALID_IMG:\n\t\tdev_err(fw->dev.dev, \"FW img has bad CRC\\n\");\n\t\treturn -EINVAL;\n\tcase PRESTERA_LDR_STATUS_NOMEM:\n\t\tdev_err(fw->dev.dev, \"Loader has no enough mem\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void prestera_fw_rev_parse(const struct prestera_fw_header *hdr,\n\t\t\t\t  struct prestera_fw_rev *rev)\n{\n\tu32 version = be32_to_cpu(hdr->version_value);\n\n\trev->maj = PRESTERA_FW_VER_MAJ(version);\n\trev->min = PRESTERA_FW_VER_MIN(version);\n\trev->sub = PRESTERA_FW_VER_PATCH(version);\n}\n\nstatic int prestera_fw_rev_check(struct prestera_fw *fw)\n{\n\tstruct prestera_fw_rev *rev = &fw->dev.fw_rev;\n\n\tif (rev->maj == fw->rev_supp.maj && rev->min >= fw->rev_supp.min)\n\t\treturn 0;\n\n\tdev_err(fw->dev.dev, \"Driver supports FW version only '%u.%u.x'\",\n\t\tfw->rev_supp.maj, fw->rev_supp.min);\n\n\treturn -EINVAL;\n}\n\nstatic int prestera_fw_hdr_parse(struct prestera_fw *fw)\n{\n\tstruct prestera_fw_rev *rev = &fw->dev.fw_rev;\n\tstruct prestera_fw_header *hdr;\n\tu32 magic;\n\n\thdr = (struct prestera_fw_header *)fw->bin->data;\n\n\tmagic = be32_to_cpu(hdr->magic_number);\n\tif (magic != PRESTERA_FW_HDR_MAGIC) {\n\t\tdev_err(fw->dev.dev, \"FW img hdr magic is invalid\");\n\t\treturn -EINVAL;\n\t}\n\n\tprestera_fw_rev_parse(hdr, rev);\n\n\tdev_info(fw->dev.dev, \"FW version '%u.%u.%u'\\n\",\n\t\t rev->maj, rev->min, rev->sub);\n\n\treturn prestera_fw_rev_check(fw);\n}\n\nstatic const char *prestera_fw_path_fmt_get(struct prestera_fw *fw)\n{\n\tswitch (fw->pci_dev->device) {\n\tcase PRESTERA_DEV_ID_98DX3500:\n\tcase PRESTERA_DEV_ID_98DX3501:\n\tcase PRESTERA_DEV_ID_98DX3510:\n\tcase PRESTERA_DEV_ID_98DX3520:\n\t\treturn PRESTERA_FW_ARM64_PATH_FMT;\n\n\tdefault:\n\t\treturn PRESTERA_FW_PATH_FMT;\n\t}\n}\n\nstatic int prestera_fw_get(struct prestera_fw *fw)\n{\n\tint ver_maj = PRESTERA_SUPP_FW_MAJ_VER;\n\tint ver_min = PRESTERA_SUPP_FW_MIN_VER;\n\tchar fw_path[128];\n\tint err;\n\npick_fw_ver:\n\tsnprintf(fw_path, sizeof(fw_path), prestera_fw_path_fmt_get(fw),\n\t\t ver_maj, ver_min);\n\n\terr = request_firmware_direct(&fw->bin, fw_path, fw->dev.dev);\n\tif (err) {\n\t\tif (ver_maj != PRESTERA_PREV_FW_MAJ_VER ||\n\t\t    ver_min != PRESTERA_PREV_FW_MIN_VER) {\n\t\t\tver_maj = PRESTERA_PREV_FW_MAJ_VER;\n\t\t\tver_min = PRESTERA_PREV_FW_MIN_VER;\n\n\t\t\tdev_warn(fw->dev.dev,\n\t\t\t\t \"missing latest %s firmware, fall-back to previous %u.%u version\\n\",\n\t\t\t\t fw_path, ver_maj, ver_min);\n\n\t\t\tgoto pick_fw_ver;\n\t\t} else {\n\t\t\tdev_err(fw->dev.dev, \"failed to request previous firmware: %s\\n\",\n\t\t\t\tfw_path);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdev_info(fw->dev.dev, \"Loading %s ...\", fw_path);\n\n\tfw->rev_supp.maj = ver_maj;\n\tfw->rev_supp.min = ver_min;\n\tfw->rev_supp.sub = 0;\n\n\treturn 0;\n}\n\nstatic void prestera_fw_put(struct prestera_fw *fw)\n{\n\trelease_firmware(fw->bin);\n}\n\nstatic int prestera_fw_load(struct prestera_fw *fw)\n{\n\tsize_t hlen = sizeof(struct prestera_fw_header);\n\tint err;\n\n\terr = prestera_ldr_wait_reg32(fw, PRESTERA_LDR_READY_REG,\n\t\t\t\t      PRESTERA_LDR_READY_MAGIC,\n\t\t\t\t      5 * MSEC_PER_SEC);\n\tif (err) {\n\t\tdev_err(fw->dev.dev, \"waiting for FW loader is timed out\");\n\t\treturn err;\n\t}\n\n\tfw->ldr_ring_buf = fw->ldr_regs +\n\t\tprestera_ldr_read(fw, PRESTERA_LDR_BUF_OFFS_REG);\n\n\tfw->ldr_buf_len =\n\t\tprestera_ldr_read(fw, PRESTERA_LDR_BUF_SIZE_REG);\n\n\tfw->ldr_wr_idx = 0;\n\n\terr = prestera_fw_get(fw);\n\tif (err)\n\t\treturn err;\n\n\terr = prestera_fw_hdr_parse(fw);\n\tif (err) {\n\t\tdev_err(fw->dev.dev, \"FW image header is invalid\\n\");\n\t\tgoto out_release;\n\t}\n\n\tprestera_ldr_write(fw, PRESTERA_LDR_IMG_SIZE_REG, fw->bin->size - hlen);\n\tprestera_ldr_write(fw, PRESTERA_LDR_CTL_REG, PRESTERA_LDR_CTL_DL_START);\n\n\terr = prestera_ldr_fw_send(fw, fw->bin->data + hlen,\n\t\t\t\t   fw->bin->size - hlen);\n\nout_release:\n\tprestera_fw_put(fw);\n\treturn err;\n}\n\nstatic bool prestera_pci_pp_use_bar2(struct pci_dev *pdev)\n{\n\tswitch (pdev->device) {\n\tcase PRESTERA_DEV_ID_98DX7312M:\n\tcase PRESTERA_DEV_ID_98DX3500:\n\tcase PRESTERA_DEV_ID_98DX3501:\n\tcase PRESTERA_DEV_ID_98DX3510:\n\tcase PRESTERA_DEV_ID_98DX3520:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic u32 prestera_pci_pp_bar2_offs(struct pci_dev *pdev)\n{\n\tif (pci_resource_len(pdev, 2) == 0x1000000)\n\t\treturn 0x0;\n\telse\n\t\treturn (pci_resource_len(pdev, 2) / 2);\n}\n\nstatic u32 prestera_pci_fw_bar2_offs(struct pci_dev *pdev)\n{\n\tif (pci_resource_len(pdev, 2) == 0x1000000)\n\t\treturn 0x400000;\n\telse\n\t\treturn 0x0;\n}\n\nstatic int prestera_pci_probe(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *id)\n{\n\tconst char *driver_name = dev_driver_string(&pdev->dev);\n\tu8 __iomem *mem_addr, *pp_addr = NULL;\n\tstruct prestera_fw *fw;\n\tint err;\n\n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"pci_enable_device failed\\n\");\n\t\tgoto err_pci_enable_device;\n\t}\n\n\terr = pci_request_regions(pdev, driver_name);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"pci_request_regions failed\\n\");\n\t\tgoto err_pci_request_regions;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(30));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"fail to set DMA mask\\n\");\n\t\tgoto err_dma_mask;\n\t}\n\n\tmem_addr = pcim_iomap(pdev, 2, 0);\n\tif (!mem_addr) {\n\t\tdev_err(&pdev->dev, \"pci mem ioremap failed\\n\");\n\t\terr = -EIO;\n\t\tgoto err_mem_ioremap;\n\t}\n\n\t \n\tif (prestera_pci_pp_use_bar2(pdev)) {\n\t\tpp_addr = mem_addr + prestera_pci_pp_bar2_offs(pdev);\n\t\tmem_addr = mem_addr + prestera_pci_fw_bar2_offs(pdev);\n\t} else {\n\t\tpp_addr = pcim_iomap(pdev, 4, 0);\n\t\tif (!pp_addr) {\n\t\t\tdev_err(&pdev->dev, \"pp regs ioremap failed\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto err_pp_ioremap;\n\t\t}\n\t}\n\n\tpci_set_master(pdev);\n\n\tfw = devm_kzalloc(&pdev->dev, sizeof(*fw), GFP_KERNEL);\n\tif (!fw) {\n\t\terr = -ENOMEM;\n\t\tgoto err_pci_dev_alloc;\n\t}\n\n\tfw->pci_dev = pdev;\n\tfw->dev.ctl_regs = mem_addr;\n\tfw->dev.pp_regs = pp_addr;\n\tfw->dev.dev = &pdev->dev;\n\n\tpci_set_drvdata(pdev, fw);\n\n\terr = prestera_fw_init(fw);\n\tif (err)\n\t\tgoto err_prestera_fw_init;\n\n\tdev_info(fw->dev.dev, \"Prestera FW is ready\\n\");\n\n\tfw->wq = alloc_workqueue(\"prestera_fw_wq\", WQ_HIGHPRI, 1);\n\tif (!fw->wq) {\n\t\terr = -ENOMEM;\n\t\tgoto err_wq_alloc;\n\t}\n\n\tINIT_WORK(&fw->evt_work, prestera_fw_evt_work_fn);\n\n\terr = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"MSI IRQ init failed\\n\");\n\t\tgoto err_irq_alloc;\n\t}\n\n\terr = request_irq(pci_irq_vector(pdev, 0), prestera_pci_irq_handler,\n\t\t\t  0, driver_name, fw);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"fail to request IRQ\\n\");\n\t\tgoto err_request_irq;\n\t}\n\n\terr = prestera_device_register(&fw->dev);\n\tif (err)\n\t\tgoto err_prestera_dev_register;\n\n\treturn 0;\n\nerr_prestera_dev_register:\n\tfree_irq(pci_irq_vector(pdev, 0), fw);\nerr_request_irq:\n\tpci_free_irq_vectors(pdev);\nerr_irq_alloc:\n\tdestroy_workqueue(fw->wq);\nerr_wq_alloc:\n\tprestera_fw_uninit(fw);\nerr_prestera_fw_init:\nerr_pci_dev_alloc:\nerr_pp_ioremap:\nerr_mem_ioremap:\nerr_dma_mask:\n\tpci_release_regions(pdev);\nerr_pci_request_regions:\nerr_pci_enable_device:\n\treturn err;\n}\n\nstatic void prestera_pci_remove(struct pci_dev *pdev)\n{\n\tstruct prestera_fw *fw = pci_get_drvdata(pdev);\n\n\tprestera_device_unregister(&fw->dev);\n\tfree_irq(pci_irq_vector(pdev, 0), fw);\n\tpci_free_irq_vectors(pdev);\n\tdestroy_workqueue(fw->wq);\n\tprestera_fw_uninit(fw);\n\tpci_release_regions(pdev);\n}\n\nstatic const struct pci_device_id prestera_pci_devices[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, PRESTERA_DEV_ID_AC3X_98DX_55) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, PRESTERA_DEV_ID_AC3X_98DX_65) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, PRESTERA_DEV_ID_ALDRIN2) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, PRESTERA_DEV_ID_98DX7312M) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, PRESTERA_DEV_ID_98DX3500) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, PRESTERA_DEV_ID_98DX3501) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, PRESTERA_DEV_ID_98DX3510) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, PRESTERA_DEV_ID_98DX3520) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, prestera_pci_devices);\n\nstatic struct pci_driver prestera_pci_driver = {\n\t.name     = \"Prestera DX\",\n\t.id_table = prestera_pci_devices,\n\t.probe    = prestera_pci_probe,\n\t.remove   = prestera_pci_remove,\n};\nmodule_pci_driver(prestera_pci_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"Marvell Prestera switch PCI interface\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}