{
  "module_name": "prestera_counter.c",
  "hash_id": "e1ae1362696aac8a376cf7a76b9f1a73407563828f2673b1d44508285950e482",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/prestera/prestera_counter.c",
  "human_readable_source": "\n \n\n#include \"prestera.h\"\n#include \"prestera_hw.h\"\n#include \"prestera_acl.h\"\n#include \"prestera_counter.h\"\n\n#define COUNTER_POLL_TIME\t(msecs_to_jiffies(1000))\n#define COUNTER_RESCHED_TIME\t(msecs_to_jiffies(50))\n#define COUNTER_BULK_SIZE\t(256)\n\nstruct prestera_counter {\n\tstruct prestera_switch *sw;\n\tstruct delayed_work stats_dw;\n\tstruct mutex mtx;   \n\tstruct prestera_counter_block **block_list;\n\tu32 total_read;\n\tu32 block_list_len;\n\tu32 curr_idx;\n\tbool is_fetching;\n};\n\nstruct prestera_counter_block {\n\tstruct list_head list;\n\tu32 id;\n\tu32 offset;\n\tu32 num_counters;\n\tu32 client;\n\tstruct idr counter_idr;\n\trefcount_t refcnt;\n\tstruct mutex mtx;   \n\tstruct prestera_counter_stats *stats;\n\tu8 *counter_flag;\n\tbool is_updating;\n\tbool full;\n};\n\nenum {\n\tCOUNTER_FLAG_READY = 0,\n\tCOUNTER_FLAG_INVALID = 1\n};\n\nstatic bool\nprestera_counter_is_ready(struct prestera_counter_block *block, u32 id)\n{\n\treturn block->counter_flag[id - block->offset] == COUNTER_FLAG_READY;\n}\n\nstatic void prestera_counter_lock(struct prestera_counter *counter)\n{\n\tmutex_lock(&counter->mtx);\n}\n\nstatic void prestera_counter_unlock(struct prestera_counter *counter)\n{\n\tmutex_unlock(&counter->mtx);\n}\n\nstatic void prestera_counter_block_lock(struct prestera_counter_block *block)\n{\n\tmutex_lock(&block->mtx);\n}\n\nstatic void prestera_counter_block_unlock(struct prestera_counter_block *block)\n{\n\tmutex_unlock(&block->mtx);\n}\n\nstatic bool prestera_counter_block_incref(struct prestera_counter_block *block)\n{\n\treturn refcount_inc_not_zero(&block->refcnt);\n}\n\nstatic bool prestera_counter_block_decref(struct prestera_counter_block *block)\n{\n\treturn refcount_dec_and_test(&block->refcnt);\n}\n\n \nstatic void prestera_counter_stats_clear(struct prestera_counter_block *block,\n\t\t\t\t\t u32 counter_id)\n{\n\tmemset(&block->stats[counter_id - block->offset], 0,\n\t       sizeof(*block->stats));\n}\n\nstatic struct prestera_counter_block *\nprestera_counter_block_lookup_not_full(struct prestera_counter *counter,\n\t\t\t\t       u32 client)\n{\n\tu32 i;\n\n\tprestera_counter_lock(counter);\n\tfor (i = 0; i < counter->block_list_len; i++) {\n\t\tif (counter->block_list[i] &&\n\t\t    counter->block_list[i]->client == client &&\n\t\t    !counter->block_list[i]->full &&\n\t\t    prestera_counter_block_incref(counter->block_list[i])) {\n\t\t\tprestera_counter_unlock(counter);\n\t\t\treturn counter->block_list[i];\n\t\t}\n\t}\n\tprestera_counter_unlock(counter);\n\n\treturn NULL;\n}\n\nstatic int prestera_counter_block_list_add(struct prestera_counter *counter,\n\t\t\t\t\t   struct prestera_counter_block *block)\n{\n\tstruct prestera_counter_block **arr;\n\tu32 i;\n\n\tprestera_counter_lock(counter);\n\n\tfor (i = 0; i < counter->block_list_len; i++) {\n\t\tif (counter->block_list[i])\n\t\t\tcontinue;\n\n\t\tcounter->block_list[i] = block;\n\t\tprestera_counter_unlock(counter);\n\t\treturn 0;\n\t}\n\n\tarr = krealloc(counter->block_list, (counter->block_list_len + 1) *\n\t\t       sizeof(*counter->block_list), GFP_KERNEL);\n\tif (!arr) {\n\t\tprestera_counter_unlock(counter);\n\t\treturn -ENOMEM;\n\t}\n\n\tcounter->block_list = arr;\n\tcounter->block_list[counter->block_list_len] = block;\n\tcounter->block_list_len++;\n\tprestera_counter_unlock(counter);\n\treturn 0;\n}\n\nstatic struct prestera_counter_block *\nprestera_counter_block_get(struct prestera_counter *counter, u32 client)\n{\n\tstruct prestera_counter_block *block;\n\tint err;\n\n\tblock = prestera_counter_block_lookup_not_full(counter, client);\n\tif (block)\n\t\treturn block;\n\n\tblock = kzalloc(sizeof(*block), GFP_KERNEL);\n\tif (!block)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = prestera_hw_counter_block_get(counter->sw, client,\n\t\t\t\t\t    &block->id, &block->offset,\n\t\t\t\t\t    &block->num_counters);\n\tif (err)\n\t\tgoto err_block;\n\n\tblock->stats = kcalloc(block->num_counters,\n\t\t\t       sizeof(*block->stats), GFP_KERNEL);\n\tif (!block->stats) {\n\t\terr = -ENOMEM;\n\t\tgoto err_stats;\n\t}\n\n\tblock->counter_flag = kcalloc(block->num_counters,\n\t\t\t\t      sizeof(*block->counter_flag),\n\t\t\t\t      GFP_KERNEL);\n\tif (!block->counter_flag) {\n\t\terr = -ENOMEM;\n\t\tgoto err_flag;\n\t}\n\n\tblock->client = client;\n\tmutex_init(&block->mtx);\n\trefcount_set(&block->refcnt, 1);\n\tidr_init_base(&block->counter_idr, block->offset);\n\n\terr = prestera_counter_block_list_add(counter, block);\n\tif (err)\n\t\tgoto err_list_add;\n\n\treturn block;\n\nerr_list_add:\n\tidr_destroy(&block->counter_idr);\n\tmutex_destroy(&block->mtx);\n\tkfree(block->counter_flag);\nerr_flag:\n\tkfree(block->stats);\nerr_stats:\n\tprestera_hw_counter_block_release(counter->sw, block->id);\nerr_block:\n\tkfree(block);\n\treturn ERR_PTR(err);\n}\n\nstatic void prestera_counter_block_put(struct prestera_counter *counter,\n\t\t\t\t       struct prestera_counter_block *block)\n{\n\tu32 i;\n\n\tif (!prestera_counter_block_decref(block))\n\t\treturn;\n\n\tprestera_counter_lock(counter);\n\tfor (i = 0; i < counter->block_list_len; i++) {\n\t\tif (counter->block_list[i] &&\n\t\t    counter->block_list[i]->id == block->id) {\n\t\t\tcounter->block_list[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprestera_counter_unlock(counter);\n\n\tWARN_ON(!idr_is_empty(&block->counter_idr));\n\n\tprestera_hw_counter_block_release(counter->sw, block->id);\n\tidr_destroy(&block->counter_idr);\n\tmutex_destroy(&block->mtx);\n\tkfree(block->stats);\n\tkfree(block);\n}\n\nstatic int prestera_counter_get_vacant(struct prestera_counter_block *block,\n\t\t\t\t       u32 *id)\n{\n\tint free_id;\n\n\tif (block->full)\n\t\treturn -ENOSPC;\n\n\tprestera_counter_block_lock(block);\n\tfree_id = idr_alloc_cyclic(&block->counter_idr, NULL, block->offset,\n\t\t\t\t   block->offset + block->num_counters,\n\t\t\t\t   GFP_KERNEL);\n\tif (free_id < 0) {\n\t\tif (free_id == -ENOSPC)\n\t\t\tblock->full = true;\n\n\t\tprestera_counter_block_unlock(block);\n\t\treturn free_id;\n\t}\n\t*id = free_id;\n\tprestera_counter_block_unlock(block);\n\n\treturn 0;\n}\n\nint prestera_counter_get(struct prestera_counter *counter, u32 client,\n\t\t\t struct prestera_counter_block **bl, u32 *counter_id)\n{\n\tstruct prestera_counter_block *block;\n\tint err;\n\tu32 id;\n\nget_next_block:\n\tblock = prestera_counter_block_get(counter, client);\n\tif (IS_ERR(block))\n\t\treturn PTR_ERR(block);\n\n\terr = prestera_counter_get_vacant(block, &id);\n\tif (err) {\n\t\tprestera_counter_block_put(counter, block);\n\n\t\tif (err == -ENOSPC)\n\t\t\tgoto get_next_block;\n\n\t\treturn err;\n\t}\n\n\tprestera_counter_block_lock(block);\n\tif (block->is_updating)\n\t\tblock->counter_flag[id - block->offset] = COUNTER_FLAG_INVALID;\n\tprestera_counter_block_unlock(block);\n\n\t*counter_id = id;\n\t*bl = block;\n\n\treturn 0;\n}\n\nvoid prestera_counter_put(struct prestera_counter *counter,\n\t\t\t  struct prestera_counter_block *block, u32 counter_id)\n{\n\tif (!block)\n\t\treturn;\n\n\tprestera_counter_block_lock(block);\n\tidr_remove(&block->counter_idr, counter_id);\n\tblock->full = false;\n\tprestera_counter_stats_clear(block, counter_id);\n\tprestera_counter_block_unlock(block);\n\n\tprestera_hw_counter_clear(counter->sw, block->id, counter_id);\n\tprestera_counter_block_put(counter, block);\n}\n\nstatic u32 prestera_counter_block_idx_next(struct prestera_counter *counter,\n\t\t\t\t\t   u32 curr_idx)\n{\n\tu32 idx, i, start = curr_idx + 1;\n\n\tprestera_counter_lock(counter);\n\tfor (i = 0; i < counter->block_list_len; i++) {\n\t\tidx = (start + i) % counter->block_list_len;\n\t\tif (!counter->block_list[idx])\n\t\t\tcontinue;\n\n\t\tprestera_counter_unlock(counter);\n\t\treturn idx;\n\t}\n\tprestera_counter_unlock(counter);\n\n\treturn 0;\n}\n\nstatic struct prestera_counter_block *\nprestera_counter_block_get_by_idx(struct prestera_counter *counter, u32 idx)\n{\n\tif (idx >= counter->block_list_len)\n\t\treturn NULL;\n\n\tprestera_counter_lock(counter);\n\n\tif (!counter->block_list[idx] ||\n\t    !prestera_counter_block_incref(counter->block_list[idx])) {\n\t\tprestera_counter_unlock(counter);\n\t\treturn NULL;\n\t}\n\n\tprestera_counter_unlock(counter);\n\treturn counter->block_list[idx];\n}\n\nstatic void prestera_counter_stats_work(struct work_struct *work)\n{\n\tstruct delayed_work *dl_work =\n\t\tcontainer_of(work, struct delayed_work, work);\n\tstruct prestera_counter *counter =\n\t\tcontainer_of(dl_work, struct prestera_counter, stats_dw);\n\tstruct prestera_counter_block *block;\n\tu32 resched_time = COUNTER_POLL_TIME;\n\tu32 count = COUNTER_BULK_SIZE;\n\tbool done = false;\n\tint err;\n\tu32 i;\n\n\tblock = prestera_counter_block_get_by_idx(counter, counter->curr_idx);\n\tif (!block) {\n\t\tif (counter->is_fetching)\n\t\t\tgoto abort;\n\n\t\tgoto next;\n\t}\n\n\tif (!counter->is_fetching) {\n\t\terr = prestera_hw_counter_trigger(counter->sw, block->id);\n\t\tif (err)\n\t\t\tgoto abort;\n\n\t\tprestera_counter_block_lock(block);\n\t\tblock->is_updating = true;\n\t\tprestera_counter_block_unlock(block);\n\n\t\tcounter->is_fetching = true;\n\t\tcounter->total_read = 0;\n\t\tresched_time = COUNTER_RESCHED_TIME;\n\t\tgoto resched;\n\t}\n\n\tprestera_counter_block_lock(block);\n\terr = prestera_hw_counters_get(counter->sw, counter->total_read,\n\t\t\t\t       &count, &done,\n\t\t\t\t       &block->stats[counter->total_read]);\n\tprestera_counter_block_unlock(block);\n\tif (err)\n\t\tgoto abort;\n\n\tcounter->total_read += count;\n\tif (!done || counter->total_read < block->num_counters) {\n\t\tresched_time = COUNTER_RESCHED_TIME;\n\t\tgoto resched;\n\t}\n\n\tfor (i = 0; i < block->num_counters; i++) {\n\t\tif (block->counter_flag[i] == COUNTER_FLAG_INVALID) {\n\t\t\tprestera_counter_block_lock(block);\n\t\t\tblock->counter_flag[i] = COUNTER_FLAG_READY;\n\t\t\tmemset(&block->stats[i], 0, sizeof(*block->stats));\n\t\t\tprestera_counter_block_unlock(block);\n\t\t}\n\t}\n\n\tprestera_counter_block_lock(block);\n\tblock->is_updating = false;\n\tprestera_counter_block_unlock(block);\n\n\tgoto next;\nabort:\n\tprestera_hw_counter_abort(counter->sw);\nnext:\n\tcounter->is_fetching = false;\n\tcounter->curr_idx =\n\t\tprestera_counter_block_idx_next(counter, counter->curr_idx);\nresched:\n\tif (block)\n\t\tprestera_counter_block_put(counter, block);\n\n\tschedule_delayed_work(&counter->stats_dw, resched_time);\n}\n\n \nint prestera_counter_stats_get(struct prestera_counter *counter,\n\t\t\t       struct prestera_counter_block *block,\n\t\t\t       u32 counter_id, u64 *packets, u64 *bytes)\n{\n\tif (!block || !prestera_counter_is_ready(block, counter_id)) {\n\t\t*packets = 0;\n\t\t*bytes = 0;\n\t\treturn 0;\n\t}\n\n\tprestera_counter_block_lock(block);\n\t*packets = block->stats[counter_id - block->offset].packets;\n\t*bytes = block->stats[counter_id - block->offset].bytes;\n\n\tprestera_counter_stats_clear(block, counter_id);\n\tprestera_counter_block_unlock(block);\n\n\treturn 0;\n}\n\nint prestera_counter_init(struct prestera_switch *sw)\n{\n\tstruct prestera_counter *counter;\n\n\tcounter = kzalloc(sizeof(*counter), GFP_KERNEL);\n\tif (!counter)\n\t\treturn -ENOMEM;\n\n\tcounter->block_list = kzalloc(sizeof(*counter->block_list), GFP_KERNEL);\n\tif (!counter->block_list) {\n\t\tkfree(counter);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&counter->mtx);\n\tcounter->block_list_len = 1;\n\tcounter->sw = sw;\n\tsw->counter = counter;\n\n\tINIT_DELAYED_WORK(&counter->stats_dw, prestera_counter_stats_work);\n\tschedule_delayed_work(&counter->stats_dw, COUNTER_POLL_TIME);\n\n\treturn 0;\n}\n\nvoid prestera_counter_fini(struct prestera_switch *sw)\n{\n\tstruct prestera_counter *counter = sw->counter;\n\tu32 i;\n\n\tcancel_delayed_work_sync(&counter->stats_dw);\n\n\tfor (i = 0; i < counter->block_list_len; i++)\n\t\tWARN_ON(counter->block_list[i]);\n\n\tmutex_destroy(&counter->mtx);\n\tkfree(counter->block_list);\n\tkfree(counter);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}