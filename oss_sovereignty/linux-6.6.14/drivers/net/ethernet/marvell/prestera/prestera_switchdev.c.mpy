{
  "module_name": "prestera_switchdev.c",
  "hash_id": "5a865b7c27d2f6a477acefd2408d8a3a8ab6353a8db6a9a715476c72874a09f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/prestera/prestera_switchdev.c",
  "human_readable_source": "\n \n\n#include <linux/if_bridge.h>\n#include <linux/if_vlan.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <net/netevent.h>\n#include <net/switchdev.h>\n\n#include \"prestera.h\"\n#include \"prestera_hw.h\"\n#include \"prestera_switchdev.h\"\n\n#define PRESTERA_VID_ALL (0xffff)\n\n#define PRESTERA_DEFAULT_AGEING_TIME_MS 300000\n#define PRESTERA_MAX_AGEING_TIME_MS 1000000000\n#define PRESTERA_MIN_AGEING_TIME_MS 32000\n\nstruct prestera_fdb_event_work {\n\tstruct work_struct work;\n\tstruct switchdev_notifier_fdb_info fdb_info;\n\tstruct net_device *dev;\n\tunsigned long event;\n};\n\nstruct prestera_switchdev {\n\tstruct prestera_switch *sw;\n\tstruct list_head bridge_list;\n\tbool bridge_8021q_exists;\n\tstruct notifier_block swdev_nb_blk;\n\tstruct notifier_block swdev_nb;\n};\n\nstruct prestera_bridge {\n\tstruct list_head head;\n\tstruct net_device *dev;\n\tstruct prestera_switchdev *swdev;\n\tstruct list_head port_list;\n\tstruct list_head br_mdb_entry_list;\n\tbool mrouter_exist;\n\tbool vlan_enabled;\n\tbool multicast_enabled;\n\tu16 bridge_id;\n};\n\nstruct prestera_bridge_port {\n\tstruct list_head head;\n\tstruct net_device *dev;\n\tstruct prestera_bridge *bridge;\n\tstruct list_head vlan_list;\n\tstruct list_head br_mdb_port_list;\n\trefcount_t ref_count;\n\tunsigned long flags;\n\tbool mrouter;\n\tu8 stp_state;\n};\n\nstruct prestera_bridge_vlan {\n\tstruct list_head head;\n\tstruct list_head port_vlan_list;\n\tu16 vid;\n};\n\nstruct prestera_port_vlan {\n\tstruct list_head br_vlan_head;\n\tstruct list_head port_head;\n\tstruct prestera_port *port;\n\tstruct prestera_bridge_port *br_port;\n\tu16 vid;\n};\n\nstruct prestera_br_mdb_port {\n\tstruct prestera_bridge_port *br_port;\n\tstruct list_head br_mdb_port_node;\n};\n\n \nstruct prestera_br_mdb_entry {\n\tstruct prestera_bridge *bridge;\n\tstruct prestera_mdb_entry *mdb;\n\tstruct list_head br_mdb_port_list;\n\tstruct list_head br_mdb_entry_node;\n\tbool enabled;\n};\n\nstatic struct workqueue_struct *swdev_wq;\n\nstatic void prestera_bridge_port_put(struct prestera_bridge_port *br_port);\n\nstatic int prestera_port_vid_stp_set(struct prestera_port *port, u16 vid,\n\t\t\t\t     u8 state);\n\nstatic struct prestera_bridge *\nprestera_bridge_find(const struct prestera_switch *sw,\n\t\t     const struct net_device *br_dev)\n{\n\tstruct prestera_bridge *bridge;\n\n\tlist_for_each_entry(bridge, &sw->swdev->bridge_list, head)\n\t\tif (bridge->dev == br_dev)\n\t\t\treturn bridge;\n\n\treturn NULL;\n}\n\nstatic struct prestera_bridge_port *\n__prestera_bridge_port_find(const struct prestera_bridge *bridge,\n\t\t\t    const struct net_device *brport_dev)\n{\n\tstruct prestera_bridge_port *br_port;\n\n\tlist_for_each_entry(br_port, &bridge->port_list, head)\n\t\tif (br_port->dev == brport_dev)\n\t\t\treturn br_port;\n\n\treturn NULL;\n}\n\nstatic struct prestera_bridge_port *\nprestera_bridge_port_find(struct prestera_switch *sw,\n\t\t\t  struct net_device *brport_dev)\n{\n\tstruct net_device *br_dev = netdev_master_upper_dev_get(brport_dev);\n\tstruct prestera_bridge *bridge;\n\n\tif (!br_dev)\n\t\treturn NULL;\n\n\tbridge = prestera_bridge_find(sw, br_dev);\n\tif (!bridge)\n\t\treturn NULL;\n\n\treturn __prestera_bridge_port_find(bridge, brport_dev);\n}\n\nstatic void\nprestera_br_port_flags_reset(struct prestera_bridge_port *br_port,\n\t\t\t     struct prestera_port *port)\n{\n\tprestera_port_uc_flood_set(port, false);\n\tprestera_port_mc_flood_set(port, false);\n\tprestera_port_learning_set(port, false);\n\tprestera_port_br_locked_set(port, false);\n}\n\nstatic int prestera_br_port_flags_set(struct prestera_bridge_port *br_port,\n\t\t\t\t      struct prestera_port *port)\n{\n\tint err;\n\n\terr = prestera_port_uc_flood_set(port, br_port->flags & BR_FLOOD);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = prestera_port_mc_flood_set(port, br_port->flags & BR_MCAST_FLOOD);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = prestera_port_learning_set(port, br_port->flags & BR_LEARNING);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = prestera_port_br_locked_set(port,\n\t\t\t\t\t  br_port->flags & BR_PORT_LOCKED);\n\tif (err)\n\t\tgoto err_out;\n\n\treturn 0;\n\nerr_out:\n\tprestera_br_port_flags_reset(br_port, port);\n\treturn err;\n}\n\nstatic struct prestera_bridge_vlan *\nprestera_bridge_vlan_create(struct prestera_bridge_port *br_port, u16 vid)\n{\n\tstruct prestera_bridge_vlan *br_vlan;\n\n\tbr_vlan = kzalloc(sizeof(*br_vlan), GFP_KERNEL);\n\tif (!br_vlan)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&br_vlan->port_vlan_list);\n\tbr_vlan->vid = vid;\n\tlist_add(&br_vlan->head, &br_port->vlan_list);\n\n\treturn br_vlan;\n}\n\nstatic void prestera_bridge_vlan_destroy(struct prestera_bridge_vlan *br_vlan)\n{\n\tlist_del(&br_vlan->head);\n\tWARN_ON(!list_empty(&br_vlan->port_vlan_list));\n\tkfree(br_vlan);\n}\n\nstatic struct prestera_bridge_vlan *\nprestera_bridge_vlan_by_vid(struct prestera_bridge_port *br_port, u16 vid)\n{\n\tstruct prestera_bridge_vlan *br_vlan;\n\n\tlist_for_each_entry(br_vlan, &br_port->vlan_list, head) {\n\t\tif (br_vlan->vid == vid)\n\t\t\treturn br_vlan;\n\t}\n\n\treturn NULL;\n}\n\nstatic int prestera_bridge_vlan_port_count(struct prestera_bridge *bridge,\n\t\t\t\t\t   u16 vid)\n{\n\tstruct prestera_bridge_port *br_port;\n\tstruct prestera_bridge_vlan *br_vlan;\n\tint count = 0;\n\n\tlist_for_each_entry(br_port, &bridge->port_list, head) {\n\t\tlist_for_each_entry(br_vlan, &br_port->vlan_list, head) {\n\t\t\tif (br_vlan->vid == vid) {\n\t\t\t\tcount += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic void prestera_bridge_vlan_put(struct prestera_bridge_vlan *br_vlan)\n{\n\tif (list_empty(&br_vlan->port_vlan_list))\n\t\tprestera_bridge_vlan_destroy(br_vlan);\n}\n\nstatic struct prestera_port_vlan *\nprestera_port_vlan_by_vid(struct prestera_port *port, u16 vid)\n{\n\tstruct prestera_port_vlan *port_vlan;\n\n\tlist_for_each_entry(port_vlan, &port->vlans_list, port_head) {\n\t\tif (port_vlan->vid == vid)\n\t\t\treturn port_vlan;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct prestera_port_vlan *\nprestera_port_vlan_create(struct prestera_port *port, u16 vid, bool untagged)\n{\n\tstruct prestera_port_vlan *port_vlan;\n\tint err;\n\n\tport_vlan = prestera_port_vlan_by_vid(port, vid);\n\tif (port_vlan)\n\t\treturn ERR_PTR(-EEXIST);\n\n\terr = prestera_hw_vlan_port_set(port, vid, true, untagged);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tport_vlan = kzalloc(sizeof(*port_vlan), GFP_KERNEL);\n\tif (!port_vlan) {\n\t\terr = -ENOMEM;\n\t\tgoto err_port_vlan_alloc;\n\t}\n\n\tport_vlan->port = port;\n\tport_vlan->vid = vid;\n\n\tlist_add(&port_vlan->port_head, &port->vlans_list);\n\n\treturn port_vlan;\n\nerr_port_vlan_alloc:\n\tprestera_hw_vlan_port_set(port, vid, false, false);\n\treturn ERR_PTR(err);\n}\n\nstatic int prestera_fdb_add(struct prestera_port *port,\n\t\t\t    const unsigned char *mac, u16 vid, bool dynamic)\n{\n\tif (prestera_port_is_lag_member(port))\n\t\treturn prestera_hw_lag_fdb_add(port->sw, prestera_port_lag_id(port),\n\t\t\t\t\t      mac, vid, dynamic);\n\n\treturn prestera_hw_fdb_add(port, mac, vid, dynamic);\n}\n\nstatic int prestera_fdb_del(struct prestera_port *port,\n\t\t\t    const unsigned char *mac, u16 vid)\n{\n\tif (prestera_port_is_lag_member(port))\n\t\treturn prestera_hw_lag_fdb_del(port->sw, prestera_port_lag_id(port),\n\t\t\t\t\t      mac, vid);\n\telse\n\t\treturn prestera_hw_fdb_del(port, mac, vid);\n}\n\nstatic int prestera_fdb_flush_port_vlan(struct prestera_port *port, u16 vid,\n\t\t\t\t\tu32 mode)\n{\n\tif (prestera_port_is_lag_member(port))\n\t\treturn prestera_hw_fdb_flush_lag_vlan(port->sw, prestera_port_lag_id(port),\n\t\t\t\t\t\t      vid, mode);\n\telse\n\t\treturn prestera_hw_fdb_flush_port_vlan(port, vid, mode);\n}\n\nstatic int prestera_fdb_flush_port(struct prestera_port *port, u32 mode)\n{\n\tif (prestera_port_is_lag_member(port))\n\t\treturn prestera_hw_fdb_flush_lag(port->sw, prestera_port_lag_id(port),\n\t\t\t\t\t\t mode);\n\telse\n\t\treturn prestera_hw_fdb_flush_port(port, mode);\n}\n\nstatic void\nprestera_mdb_port_del(struct prestera_mdb_entry *mdb,\n\t\t      struct net_device *orig_dev)\n{\n\tstruct prestera_flood_domain *fl_domain = mdb->flood_domain;\n\tstruct prestera_flood_domain_port *flood_domain_port;\n\n\tflood_domain_port = prestera_flood_domain_port_find(fl_domain,\n\t\t\t\t\t\t\t    orig_dev,\n\t\t\t\t\t\t\t    mdb->vid);\n\tif (flood_domain_port)\n\t\tprestera_flood_domain_port_destroy(flood_domain_port);\n}\n\nstatic void\nprestera_br_mdb_entry_put(struct prestera_br_mdb_entry *br_mdb)\n{\n\tstruct prestera_bridge_port *br_port;\n\n\tif (list_empty(&br_mdb->br_mdb_port_list)) {\n\t\tlist_for_each_entry(br_port, &br_mdb->bridge->port_list, head)\n\t\t\tprestera_mdb_port_del(br_mdb->mdb, br_port->dev);\n\n\t\tprestera_mdb_entry_destroy(br_mdb->mdb);\n\t\tlist_del(&br_mdb->br_mdb_entry_node);\n\t\tkfree(br_mdb);\n\t}\n}\n\nstatic void\nprestera_br_mdb_port_del(struct prestera_br_mdb_entry *br_mdb,\n\t\t\t struct prestera_bridge_port *br_port)\n{\n\tstruct prestera_br_mdb_port *br_mdb_port, *tmp;\n\n\tlist_for_each_entry_safe(br_mdb_port, tmp, &br_mdb->br_mdb_port_list,\n\t\t\t\t br_mdb_port_node) {\n\t\tif (br_mdb_port->br_port == br_port) {\n\t\t\tlist_del(&br_mdb_port->br_mdb_port_node);\n\t\t\tkfree(br_mdb_port);\n\t\t}\n\t}\n}\n\nstatic void\nprestera_mdb_flush_bridge_port(struct prestera_bridge_port *br_port)\n{\n\tstruct prestera_br_mdb_port *br_mdb_port, *tmp_port;\n\tstruct prestera_br_mdb_entry *br_mdb, *br_mdb_tmp;\n\tstruct prestera_bridge *br_dev = br_port->bridge;\n\n\tlist_for_each_entry_safe(br_mdb, br_mdb_tmp, &br_dev->br_mdb_entry_list,\n\t\t\t\t br_mdb_entry_node) {\n\t\tlist_for_each_entry_safe(br_mdb_port, tmp_port,\n\t\t\t\t\t &br_mdb->br_mdb_port_list,\n\t\t\t\t\t br_mdb_port_node) {\n\t\t\tprestera_mdb_port_del(br_mdb->mdb,\n\t\t\t\t\t      br_mdb_port->br_port->dev);\n\t\t\tprestera_br_mdb_port_del(br_mdb,  br_mdb_port->br_port);\n\t\t}\n\t\tprestera_br_mdb_entry_put(br_mdb);\n\t}\n}\n\nstatic void\nprestera_port_vlan_bridge_leave(struct prestera_port_vlan *port_vlan)\n{\n\tu32 fdb_flush_mode = PRESTERA_FDB_FLUSH_MODE_DYNAMIC;\n\tstruct prestera_port *port = port_vlan->port;\n\tstruct prestera_bridge_vlan *br_vlan;\n\tstruct prestera_bridge_port *br_port;\n\tbool last_port, last_vlan;\n\tu16 vid = port_vlan->vid;\n\tint port_count;\n\n\tbr_port = port_vlan->br_port;\n\tport_count = prestera_bridge_vlan_port_count(br_port->bridge, vid);\n\tbr_vlan = prestera_bridge_vlan_by_vid(br_port, vid);\n\n\tlast_vlan = list_is_singular(&br_port->vlan_list);\n\tlast_port = port_count == 1;\n\n\tif (last_vlan)\n\t\tprestera_fdb_flush_port(port, fdb_flush_mode);\n\telse if (last_port)\n\t\tprestera_hw_fdb_flush_vlan(port->sw, vid, fdb_flush_mode);\n\telse\n\t\tprestera_fdb_flush_port_vlan(port, vid, fdb_flush_mode);\n\n\tprestera_mdb_flush_bridge_port(br_port);\n\n\tlist_del(&port_vlan->br_vlan_head);\n\tprestera_bridge_vlan_put(br_vlan);\n\tprestera_bridge_port_put(br_port);\n\tport_vlan->br_port = NULL;\n}\n\nstatic void prestera_port_vlan_destroy(struct prestera_port_vlan *port_vlan)\n{\n\tstruct prestera_port *port = port_vlan->port;\n\tu16 vid = port_vlan->vid;\n\n\tif (port_vlan->br_port)\n\t\tprestera_port_vlan_bridge_leave(port_vlan);\n\n\tprestera_hw_vlan_port_set(port, vid, false, false);\n\tlist_del(&port_vlan->port_head);\n\tkfree(port_vlan);\n}\n\nstatic struct prestera_bridge *\nprestera_bridge_create(struct prestera_switchdev *swdev, struct net_device *dev)\n{\n\tbool vlan_enabled = br_vlan_enabled(dev);\n\tstruct prestera_bridge *bridge;\n\tu16 bridge_id;\n\tint err;\n\n\tif (vlan_enabled && swdev->bridge_8021q_exists) {\n\t\tnetdev_err(dev, \"Only one VLAN-aware bridge is supported\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbridge = kzalloc(sizeof(*bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (vlan_enabled) {\n\t\tswdev->bridge_8021q_exists = true;\n\t} else {\n\t\terr = prestera_hw_bridge_create(swdev->sw, &bridge_id);\n\t\tif (err) {\n\t\t\tkfree(bridge);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tbridge->bridge_id = bridge_id;\n\t}\n\n\tbridge->vlan_enabled = vlan_enabled;\n\tbridge->swdev = swdev;\n\tbridge->dev = dev;\n\tbridge->multicast_enabled = br_multicast_enabled(dev);\n\n\tINIT_LIST_HEAD(&bridge->port_list);\n\tINIT_LIST_HEAD(&bridge->br_mdb_entry_list);\n\n\tlist_add(&bridge->head, &swdev->bridge_list);\n\n\treturn bridge;\n}\n\nstatic void prestera_bridge_destroy(struct prestera_bridge *bridge)\n{\n\tstruct prestera_switchdev *swdev = bridge->swdev;\n\n\tlist_del(&bridge->head);\n\n\tif (bridge->vlan_enabled)\n\t\tswdev->bridge_8021q_exists = false;\n\telse\n\t\tprestera_hw_bridge_delete(swdev->sw, bridge->bridge_id);\n\n\tWARN_ON(!list_empty(&bridge->br_mdb_entry_list));\n\tWARN_ON(!list_empty(&bridge->port_list));\n\tkfree(bridge);\n}\n\nstatic void prestera_bridge_put(struct prestera_bridge *bridge)\n{\n\tif (list_empty(&bridge->port_list))\n\t\tprestera_bridge_destroy(bridge);\n}\n\nstatic\nstruct prestera_bridge *prestera_bridge_by_dev(struct prestera_switchdev *swdev,\n\t\t\t\t\t       const struct net_device *dev)\n{\n\tstruct prestera_bridge *bridge;\n\n\tlist_for_each_entry(bridge, &swdev->bridge_list, head)\n\t\tif (bridge->dev == dev)\n\t\t\treturn bridge;\n\n\treturn NULL;\n}\n\nstatic struct prestera_bridge_port *\n__prestera_bridge_port_by_dev(struct prestera_bridge *bridge,\n\t\t\t      struct net_device *dev)\n{\n\tstruct prestera_bridge_port *br_port;\n\n\tlist_for_each_entry(br_port, &bridge->port_list, head) {\n\t\tif (br_port->dev == dev)\n\t\t\treturn br_port;\n\t}\n\n\treturn NULL;\n}\n\nstatic int prestera_match_upper_bridge_dev(struct net_device *dev,\n\t\t\t\t\t   struct netdev_nested_priv *priv)\n{\n\tif (netif_is_bridge_master(dev))\n\t\tpriv->data = dev;\n\n\treturn 0;\n}\n\nstatic struct net_device *prestera_get_upper_bridge_dev(struct net_device *dev)\n{\n\tstruct netdev_nested_priv priv = { };\n\n\tnetdev_walk_all_upper_dev_rcu(dev, prestera_match_upper_bridge_dev,\n\t\t\t\t      &priv);\n\treturn priv.data;\n}\n\nstatic struct prestera_bridge_port *\nprestera_bridge_port_by_dev(struct prestera_switchdev *swdev,\n\t\t\t    struct net_device *dev)\n{\n\tstruct net_device *br_dev = prestera_get_upper_bridge_dev(dev);\n\tstruct prestera_bridge *bridge;\n\n\tif (!br_dev)\n\t\treturn NULL;\n\n\tbridge = prestera_bridge_by_dev(swdev, br_dev);\n\tif (!bridge)\n\t\treturn NULL;\n\n\treturn __prestera_bridge_port_by_dev(bridge, dev);\n}\n\nstatic struct prestera_bridge_port *\nprestera_bridge_port_create(struct prestera_bridge *bridge,\n\t\t\t    struct net_device *dev)\n{\n\tstruct prestera_bridge_port *br_port;\n\n\tbr_port = kzalloc(sizeof(*br_port), GFP_KERNEL);\n\tif (!br_port)\n\t\treturn NULL;\n\n\tbr_port->flags = BR_LEARNING | BR_FLOOD | BR_LEARNING_SYNC |\n\t\t\t\tBR_MCAST_FLOOD;\n\tbr_port->stp_state = BR_STATE_DISABLED;\n\trefcount_set(&br_port->ref_count, 1);\n\tbr_port->bridge = bridge;\n\tbr_port->dev = dev;\n\n\tINIT_LIST_HEAD(&br_port->vlan_list);\n\tlist_add(&br_port->head, &bridge->port_list);\n\tINIT_LIST_HEAD(&br_port->br_mdb_port_list);\n\n\treturn br_port;\n}\n\nstatic void\nprestera_bridge_port_destroy(struct prestera_bridge_port *br_port)\n{\n\tlist_del(&br_port->head);\n\tWARN_ON(!list_empty(&br_port->vlan_list));\n\tWARN_ON(!list_empty(&br_port->br_mdb_port_list));\n\tkfree(br_port);\n}\n\nstatic void prestera_bridge_port_get(struct prestera_bridge_port *br_port)\n{\n\trefcount_inc(&br_port->ref_count);\n}\n\nstatic void prestera_bridge_port_put(struct prestera_bridge_port *br_port)\n{\n\tstruct prestera_bridge *bridge = br_port->bridge;\n\n\tif (refcount_dec_and_test(&br_port->ref_count)) {\n\t\tprestera_bridge_port_destroy(br_port);\n\t\tprestera_bridge_put(bridge);\n\t}\n}\n\nstatic struct prestera_bridge_port *\nprestera_bridge_port_add(struct prestera_bridge *bridge, struct net_device *dev)\n{\n\tstruct prestera_bridge_port *br_port;\n\n\tbr_port = __prestera_bridge_port_by_dev(bridge, dev);\n\tif (br_port) {\n\t\tprestera_bridge_port_get(br_port);\n\t\treturn br_port;\n\t}\n\n\tbr_port = prestera_bridge_port_create(bridge, dev);\n\tif (!br_port)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn br_port;\n}\n\nstatic int\nprestera_bridge_1d_port_join(struct prestera_bridge_port *br_port)\n{\n\tstruct prestera_port *port = netdev_priv(br_port->dev);\n\tstruct prestera_bridge *bridge = br_port->bridge;\n\tint err;\n\n\terr = prestera_hw_bridge_port_add(port, bridge->bridge_id);\n\tif (err)\n\t\treturn err;\n\n\terr = prestera_br_port_flags_set(br_port, port);\n\tif (err)\n\t\tgoto err_flags2port_set;\n\n\treturn 0;\n\nerr_flags2port_set:\n\tprestera_hw_bridge_port_delete(port, bridge->bridge_id);\n\n\treturn err;\n}\n\nint prestera_bridge_port_join(struct net_device *br_dev,\n\t\t\t      struct prestera_port *port,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct prestera_switchdev *swdev = port->sw->swdev;\n\tstruct prestera_bridge_port *br_port;\n\tstruct prestera_bridge *bridge;\n\tint err;\n\n\tbridge = prestera_bridge_by_dev(swdev, br_dev);\n\tif (!bridge) {\n\t\tbridge = prestera_bridge_create(swdev, br_dev);\n\t\tif (IS_ERR(bridge))\n\t\t\treturn PTR_ERR(bridge);\n\t}\n\n\tbr_port = prestera_bridge_port_add(bridge, port->dev);\n\tif (IS_ERR(br_port)) {\n\t\tprestera_bridge_put(bridge);\n\t\treturn PTR_ERR(br_port);\n\t}\n\n\terr = switchdev_bridge_port_offload(br_port->dev, port->dev, NULL,\n\t\t\t\t\t    NULL, NULL, false, extack);\n\tif (err)\n\t\tgoto err_switchdev_offload;\n\n\tif (bridge->vlan_enabled)\n\t\treturn 0;\n\n\terr = prestera_bridge_1d_port_join(br_port);\n\tif (err)\n\t\tgoto err_port_join;\n\n\treturn 0;\n\nerr_port_join:\n\tswitchdev_bridge_port_unoffload(br_port->dev, NULL, NULL, NULL);\nerr_switchdev_offload:\n\tprestera_bridge_port_put(br_port);\n\treturn err;\n}\n\nstatic void prestera_bridge_1q_port_leave(struct prestera_bridge_port *br_port)\n{\n\tstruct prestera_port *port = netdev_priv(br_port->dev);\n\n\tprestera_hw_fdb_flush_port(port, PRESTERA_FDB_FLUSH_MODE_ALL);\n\tprestera_port_pvid_set(port, PRESTERA_DEFAULT_VID);\n}\n\nstatic void prestera_bridge_1d_port_leave(struct prestera_bridge_port *br_port)\n{\n\tstruct prestera_port *port = netdev_priv(br_port->dev);\n\n\tprestera_hw_fdb_flush_port(port, PRESTERA_FDB_FLUSH_MODE_ALL);\n\tprestera_hw_bridge_port_delete(port, br_port->bridge->bridge_id);\n}\n\nstatic int prestera_port_vid_stp_set(struct prestera_port *port, u16 vid,\n\t\t\t\t     u8 state)\n{\n\tu8 hw_state = state;\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\t\thw_state = PRESTERA_STP_DISABLED;\n\t\tbreak;\n\n\tcase BR_STATE_BLOCKING:\n\tcase BR_STATE_LISTENING:\n\t\thw_state = PRESTERA_STP_BLOCK_LISTEN;\n\t\tbreak;\n\n\tcase BR_STATE_LEARNING:\n\t\thw_state = PRESTERA_STP_LEARN;\n\t\tbreak;\n\n\tcase BR_STATE_FORWARDING:\n\t\thw_state = PRESTERA_STP_FORWARD;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn prestera_hw_vlan_port_stp_set(port, vid, hw_state);\n}\n\nvoid prestera_bridge_port_leave(struct net_device *br_dev,\n\t\t\t\tstruct prestera_port *port)\n{\n\tstruct prestera_switchdev *swdev = port->sw->swdev;\n\tstruct prestera_bridge_port *br_port;\n\tstruct prestera_bridge *bridge;\n\n\tbridge = prestera_bridge_by_dev(swdev, br_dev);\n\tif (!bridge)\n\t\treturn;\n\n\tbr_port = __prestera_bridge_port_by_dev(bridge, port->dev);\n\tif (!br_port)\n\t\treturn;\n\n\tbridge = br_port->bridge;\n\n\tif (bridge->vlan_enabled)\n\t\tprestera_bridge_1q_port_leave(br_port);\n\telse\n\t\tprestera_bridge_1d_port_leave(br_port);\n\n\tswitchdev_bridge_port_unoffload(br_port->dev, NULL, NULL, NULL);\n\n\tprestera_mdb_flush_bridge_port(br_port);\n\n\tprestera_br_port_flags_reset(br_port, port);\n\tprestera_port_vid_stp_set(port, PRESTERA_VID_ALL, BR_STATE_FORWARDING);\n\tprestera_bridge_port_put(br_port);\n}\n\nstatic int prestera_port_attr_br_flags_set(struct prestera_port *port,\n\t\t\t\t\t   struct net_device *dev,\n\t\t\t\t\t   struct switchdev_brport_flags flags)\n{\n\tstruct prestera_bridge_port *br_port;\n\n\tbr_port = prestera_bridge_port_by_dev(port->sw->swdev, dev);\n\tif (!br_port)\n\t\treturn 0;\n\n\tbr_port->flags &= ~flags.mask;\n\tbr_port->flags |= flags.val & flags.mask;\n\treturn prestera_br_port_flags_set(br_port, port);\n}\n\nstatic int prestera_port_attr_br_ageing_set(struct prestera_port *port,\n\t\t\t\t\t    unsigned long ageing_clock_t)\n{\n\tunsigned long ageing_jiffies = clock_t_to_jiffies(ageing_clock_t);\n\tu32 ageing_time_ms = jiffies_to_msecs(ageing_jiffies);\n\tstruct prestera_switch *sw = port->sw;\n\n\tif (ageing_time_ms < PRESTERA_MIN_AGEING_TIME_MS ||\n\t    ageing_time_ms > PRESTERA_MAX_AGEING_TIME_MS)\n\t\treturn -ERANGE;\n\n\treturn prestera_hw_switch_ageing_set(sw, ageing_time_ms);\n}\n\nstatic int prestera_port_attr_br_vlan_set(struct prestera_port *port,\n\t\t\t\t\t  struct net_device *dev,\n\t\t\t\t\t  bool vlan_enabled)\n{\n\tstruct prestera_switch *sw = port->sw;\n\tstruct prestera_bridge *bridge;\n\n\tbridge = prestera_bridge_by_dev(sw->swdev, dev);\n\tif (WARN_ON(!bridge))\n\t\treturn -EINVAL;\n\n\tif (bridge->vlan_enabled == vlan_enabled)\n\t\treturn 0;\n\n\tnetdev_err(bridge->dev, \"VLAN filtering can't be changed for existing bridge\\n\");\n\n\treturn -EINVAL;\n}\n\nstatic int prestera_port_bridge_vlan_stp_set(struct prestera_port *port,\n\t\t\t\t\t     struct prestera_bridge_vlan *br_vlan,\n\t\t\t\t\t     u8 state)\n{\n\tstruct prestera_port_vlan *port_vlan;\n\n\tlist_for_each_entry(port_vlan, &br_vlan->port_vlan_list, br_vlan_head) {\n\t\tif (port_vlan->port != port)\n\t\t\tcontinue;\n\n\t\treturn prestera_port_vid_stp_set(port, br_vlan->vid, state);\n\t}\n\n\treturn 0;\n}\n\nstatic int prestera_port_attr_stp_state_set(struct prestera_port *port,\n\t\t\t\t\t    struct net_device *dev,\n\t\t\t\t\t    u8 state)\n{\n\tstruct prestera_bridge_port *br_port;\n\tstruct prestera_bridge_vlan *br_vlan;\n\tint err;\n\tu16 vid;\n\n\tbr_port = prestera_bridge_port_by_dev(port->sw->swdev, dev);\n\tif (!br_port)\n\t\treturn 0;\n\n\tif (!br_port->bridge->vlan_enabled) {\n\t\tvid = br_port->bridge->bridge_id;\n\t\terr = prestera_port_vid_stp_set(port, vid, state);\n\t\tif (err)\n\t\t\tgoto err_port_stp_set;\n\t} else {\n\t\tlist_for_each_entry(br_vlan, &br_port->vlan_list, head) {\n\t\t\terr = prestera_port_bridge_vlan_stp_set(port, br_vlan,\n\t\t\t\t\t\t\t\tstate);\n\t\t\tif (err)\n\t\t\t\tgoto err_port_vlan_stp_set;\n\t\t}\n\t}\n\n\tbr_port->stp_state = state;\n\n\treturn 0;\n\nerr_port_vlan_stp_set:\n\tlist_for_each_entry_continue_reverse(br_vlan, &br_port->vlan_list, head)\n\t\tprestera_port_bridge_vlan_stp_set(port, br_vlan, br_port->stp_state);\n\treturn err;\n\nerr_port_stp_set:\n\tprestera_port_vid_stp_set(port, vid, br_port->stp_state);\n\n\treturn err;\n}\n\nstatic int\nprestera_br_port_lag_mdb_mc_enable_sync(struct prestera_bridge_port *br_port,\n\t\t\t\t\tbool enabled)\n{\n\tstruct prestera_port *pr_port;\n\tstruct prestera_switch *sw;\n\tu16 lag_id;\n\tint err;\n\n\tpr_port = prestera_port_dev_lower_find(br_port->dev);\n\tif (!pr_port)\n\t\treturn 0;\n\n\tsw = pr_port->sw;\n\terr = prestera_lag_id(sw, br_port->dev, &lag_id);\n\tif (err)\n\t\treturn err;\n\n\tlist_for_each_entry(pr_port, &sw->port_list, list) {\n\t\tif (pr_port->lag->lag_id == lag_id) {\n\t\t\terr = prestera_port_mc_flood_set(pr_port, enabled);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int prestera_br_mdb_mc_enable_sync(struct prestera_bridge *br_dev)\n{\n\tstruct prestera_bridge_port *br_port;\n\tstruct prestera_port *port;\n\tbool enabled;\n\tint err;\n\n\t \n\tlist_for_each_entry(br_port, &br_dev->port_list, head) {\n\t\tif (br_dev->multicast_enabled && br_dev->mrouter_exist)\n\t\t\tenabled = br_port->mrouter;\n\t\telse\n\t\t\tenabled = br_port->flags & BR_MCAST_FLOOD;\n\n\t\tif (netif_is_lag_master(br_port->dev)) {\n\t\t\terr = prestera_br_port_lag_mdb_mc_enable_sync(br_port,\n\t\t\t\t\t\t\t\t      enabled);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tcontinue;\n\t\t}\n\n\t\tport = prestera_port_dev_lower_find(br_port->dev);\n\t\tif (!port)\n\t\t\tcontinue;\n\n\t\terr = prestera_port_mc_flood_set(port, enabled);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nprestera_br_mdb_port_is_member(struct prestera_br_mdb_entry *br_mdb,\n\t\t\t       struct net_device *orig_dev)\n{\n\tstruct prestera_br_mdb_port *tmp_port;\n\n\tlist_for_each_entry(tmp_port, &br_mdb->br_mdb_port_list,\n\t\t\t    br_mdb_port_node)\n\t\tif (tmp_port->br_port->dev == orig_dev)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int\nprestera_mdb_port_add(struct prestera_mdb_entry *mdb,\n\t\t      struct net_device *orig_dev,\n\t\t      const unsigned char addr[ETH_ALEN], u16 vid)\n{\n\tstruct prestera_flood_domain *flood_domain = mdb->flood_domain;\n\tint err;\n\n\tif (!prestera_flood_domain_port_find(flood_domain,\n\t\t\t\t\t     orig_dev, vid)) {\n\t\terr = prestera_flood_domain_port_create(flood_domain, orig_dev,\n\t\t\t\t\t\t\tvid);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int prestera_br_mdb_sync(struct prestera_bridge *br_dev)\n{\n\tstruct prestera_br_mdb_port *br_mdb_port;\n\tstruct prestera_bridge_port *br_port;\n\tstruct prestera_br_mdb_entry *br_mdb;\n\tstruct prestera_mdb_entry *mdb;\n\tstruct prestera_port *pr_port;\n\tint err = 0;\n\n\tif (!br_dev->multicast_enabled)\n\t\treturn 0;\n\n\tlist_for_each_entry(br_mdb, &br_dev->br_mdb_entry_list,\n\t\t\t    br_mdb_entry_node) {\n\t\tmdb = br_mdb->mdb;\n\t\t \n\t\tlist_for_each_entry(br_mdb_port, &br_mdb->br_mdb_port_list,\n\t\t\t\t    br_mdb_port_node) {\n\t\t\tbr_port = br_mdb_port->br_port;\n\t\t\tpr_port = prestera_port_dev_lower_find(br_port->dev);\n\n\t\t\t \n\t\t\tif (br_dev->vlan_enabled &&\n\t\t\t    !prestera_port_vlan_by_vid(pr_port,\n\t\t\t\t\t\t       mdb->vid))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (prestera_br_mdb_port_is_member(br_mdb,\n\t\t\t\t\t\t\t   br_mdb_port->br_port->dev) &&\n\t\t\t\t\t\t\t   br_dev->mrouter_exist)\n\t\t\t\terr = prestera_mdb_port_add(mdb, br_port->dev,\n\t\t\t\t\t\t\t    mdb->addr,\n\t\t\t\t\t\t\t    mdb->vid);\n\t\t\telse\n\t\t\t\tprestera_mdb_port_del(mdb, br_port->dev);\n\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry(br_port, &br_dev->port_list, head) {\n\t\t\tpr_port = prestera_port_dev_lower_find(br_port->dev);\n\n\t\t\t \n\t\t\tif (br_dev->vlan_enabled &&\n\t\t\t    !prestera_port_vlan_by_vid(pr_port,\n\t\t\t\t\t\t       mdb->vid))\n\t\t\t\tcontinue;\n\n\t\t\tif (br_port->mrouter) {\n\t\t\t\terr = prestera_mdb_port_add(mdb, br_port->dev,\n\t\t\t\t\t\t\t    mdb->addr,\n\t\t\t\t\t\t\t    mdb->vid);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else if (!br_port->mrouter &&\n\t\t\t\t   !prestera_br_mdb_port_is_member\n\t\t\t\t   (br_mdb, br_port->dev)) {\n\t\t\t\tprestera_mdb_port_del(mdb, br_port->dev);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nprestera_mdb_enable_set(struct prestera_br_mdb_entry *br_mdb, bool enable)\n{\n\tint err;\n\n\tif (enable != br_mdb->enabled) {\n\t\tif (enable)\n\t\t\terr = prestera_hw_mdb_create(br_mdb->mdb);\n\t\telse\n\t\t\terr = prestera_hw_mdb_destroy(br_mdb->mdb);\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tbr_mdb->enabled = enable;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nprestera_br_mdb_enable_set(struct prestera_bridge *br_dev, bool enable)\n{\n\tstruct prestera_br_mdb_entry *br_mdb;\n\tint err;\n\n\tlist_for_each_entry(br_mdb, &br_dev->br_mdb_entry_list,\n\t\t\t    br_mdb_entry_node) {\n\t\terr = prestera_mdb_enable_set(br_mdb, enable);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int prestera_port_attr_br_mc_disabled_set(struct prestera_port *port,\n\t\t\t\t\t\t struct net_device *orig_dev,\n\t\t\t\t\t\t bool mc_disabled)\n{\n\tstruct prestera_switch *sw = port->sw;\n\tstruct prestera_bridge *br_dev;\n\n\tbr_dev = prestera_bridge_find(sw, orig_dev);\n\tif (!br_dev)\n\t\treturn 0;\n\n\tbr_dev->multicast_enabled = !mc_disabled;\n\n\t \n\tWARN_ON(prestera_br_mdb_enable_set(br_dev, br_dev->multicast_enabled &&\n\t\t\t\t\t   br_dev->mrouter_exist));\n\n\tWARN_ON(prestera_br_mdb_sync(br_dev));\n\n\tWARN_ON(prestera_br_mdb_mc_enable_sync(br_dev));\n\n\treturn 0;\n}\n\nstatic bool\nprestera_bridge_mdb_mc_mrouter_exists(struct prestera_bridge *br_dev)\n{\n\tstruct prestera_bridge_port *br_port;\n\n\tlist_for_each_entry(br_port, &br_dev->port_list, head)\n\t\tif (br_port->mrouter)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int\nprestera_port_attr_mrouter_set(struct prestera_port *port,\n\t\t\t       struct net_device *orig_dev,\n\t\t\t       bool is_port_mrouter)\n{\n\tstruct prestera_bridge_port *br_port;\n\tstruct prestera_bridge *br_dev;\n\n\tbr_port = prestera_bridge_port_find(port->sw, orig_dev);\n\tif (!br_port)\n\t\treturn 0;\n\n\tbr_dev = br_port->bridge;\n\tbr_port->mrouter = is_port_mrouter;\n\n\tbr_dev->mrouter_exist = prestera_bridge_mdb_mc_mrouter_exists(br_dev);\n\n\t \n\tWARN_ON(prestera_br_mdb_enable_set(br_dev, br_dev->multicast_enabled &&\n\t\t\t\t\t   br_dev->mrouter_exist));\n\n\tWARN_ON(prestera_br_mdb_sync(br_dev));\n\n\tWARN_ON(prestera_br_mdb_mc_enable_sync(br_dev));\n\n\treturn 0;\n}\n\nstatic int prestera_port_obj_attr_set(struct net_device *dev, const void *ctx,\n\t\t\t\t      const struct switchdev_attr *attr,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct prestera_port *port = netdev_priv(dev);\n\tint err = 0;\n\n\tswitch (attr->id) {\n\tcase SWITCHDEV_ATTR_ID_PORT_STP_STATE:\n\t\terr = prestera_port_attr_stp_state_set(port, attr->orig_dev,\n\t\t\t\t\t\t       attr->u.stp_state);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS:\n\t\tif (attr->u.brport_flags.mask &\n\t\t    ~(BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD | BR_PORT_LOCKED))\n\t\t\terr = -EINVAL;\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:\n\t\terr = prestera_port_attr_br_flags_set(port, attr->orig_dev,\n\t\t\t\t\t\t      attr->u.brport_flags);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME:\n\t\terr = prestera_port_attr_br_ageing_set(port,\n\t\t\t\t\t\t       attr->u.ageing_time);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING:\n\t\terr = prestera_port_attr_br_vlan_set(port, attr->orig_dev,\n\t\t\t\t\t\t     attr->u.vlan_filtering);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_MROUTER:\n\t\terr = prestera_port_attr_mrouter_set(port, attr->orig_dev,\n\t\t\t\t\t\t     attr->u.mrouter);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED:\n\t\terr = prestera_port_attr_br_mc_disabled_set(port, attr->orig_dev,\n\t\t\t\t\t\t\t    attr->u.mc_disabled);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic void\nprestera_fdb_offload_notify(struct prestera_port *port,\n\t\t\t    struct switchdev_notifier_fdb_info *info)\n{\n\tstruct switchdev_notifier_fdb_info send_info = {};\n\n\tsend_info.addr = info->addr;\n\tsend_info.vid = info->vid;\n\tsend_info.offloaded = true;\n\n\tcall_switchdev_notifiers(SWITCHDEV_FDB_OFFLOADED, port->dev,\n\t\t\t\t &send_info.info, NULL);\n}\n\nstatic int prestera_port_fdb_set(struct prestera_port *port,\n\t\t\t\t struct switchdev_notifier_fdb_info *fdb_info,\n\t\t\t\t bool adding)\n{\n\tstruct prestera_switch *sw = port->sw;\n\tstruct prestera_bridge_port *br_port;\n\tstruct prestera_bridge *bridge;\n\tint err;\n\tu16 vid;\n\n\tbr_port = prestera_bridge_port_by_dev(sw->swdev, port->dev);\n\tif (!br_port)\n\t\treturn -EINVAL;\n\n\tbridge = br_port->bridge;\n\n\tif (bridge->vlan_enabled)\n\t\tvid = fdb_info->vid;\n\telse\n\t\tvid = bridge->bridge_id;\n\n\tif (adding)\n\t\terr = prestera_fdb_add(port, fdb_info->addr, vid, false);\n\telse\n\t\terr = prestera_fdb_del(port, fdb_info->addr, vid);\n\n\treturn err;\n}\n\nstatic void prestera_fdb_event_work(struct work_struct *work)\n{\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tstruct prestera_fdb_event_work *swdev_work;\n\tstruct prestera_port *port;\n\tstruct net_device *dev;\n\tint err;\n\n\tswdev_work = container_of(work, struct prestera_fdb_event_work, work);\n\tdev = swdev_work->dev;\n\n\trtnl_lock();\n\n\tport = prestera_port_dev_lower_find(dev);\n\tif (!port)\n\t\tgoto out_unlock;\n\n\tswitch (swdev_work->event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\tfdb_info = &swdev_work->fdb_info;\n\t\tif (!fdb_info->added_by_user || fdb_info->is_local)\n\t\t\tbreak;\n\n\t\terr = prestera_port_fdb_set(port, fdb_info, true);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tprestera_fdb_offload_notify(port, fdb_info);\n\t\tbreak;\n\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tfdb_info = &swdev_work->fdb_info;\n\t\tprestera_port_fdb_set(port, fdb_info, false);\n\t\tbreak;\n\t}\n\nout_unlock:\n\trtnl_unlock();\n\n\tkfree(swdev_work->fdb_info.addr);\n\tkfree(swdev_work);\n\tdev_put(dev);\n}\n\nstatic int prestera_switchdev_event(struct notifier_block *unused,\n\t\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tstruct switchdev_notifier_info *info = ptr;\n\tstruct prestera_fdb_event_work *swdev_work;\n\tstruct net_device *upper;\n\tint err;\n\n\tif (event == SWITCHDEV_PORT_ATTR_SET) {\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     prestera_netdev_check,\n\t\t\t\t\t\t     prestera_port_obj_attr_set);\n\t\treturn notifier_from_errno(err);\n\t}\n\n\tif (!prestera_netdev_check(dev))\n\t\treturn NOTIFY_DONE;\n\n\tupper = netdev_master_upper_dev_get_rcu(dev);\n\tif (!upper)\n\t\treturn NOTIFY_DONE;\n\n\tif (!netif_is_bridge_master(upper))\n\t\treturn NOTIFY_DONE;\n\n\tswdev_work = kzalloc(sizeof(*swdev_work), GFP_ATOMIC);\n\tif (!swdev_work)\n\t\treturn NOTIFY_BAD;\n\n\tswdev_work->event = event;\n\tswdev_work->dev = dev;\n\n\tswitch (event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tfdb_info = container_of(info,\n\t\t\t\t\tstruct switchdev_notifier_fdb_info,\n\t\t\t\t\tinfo);\n\n\t\tINIT_WORK(&swdev_work->work, prestera_fdb_event_work);\n\t\tmemcpy(&swdev_work->fdb_info, ptr,\n\t\t       sizeof(swdev_work->fdb_info));\n\n\t\tswdev_work->fdb_info.addr = kzalloc(ETH_ALEN, GFP_ATOMIC);\n\t\tif (!swdev_work->fdb_info.addr)\n\t\t\tgoto out_bad;\n\n\t\tether_addr_copy((u8 *)swdev_work->fdb_info.addr,\n\t\t\t\tfdb_info->addr);\n\t\tdev_hold(dev);\n\t\tbreak;\n\n\tdefault:\n\t\tkfree(swdev_work);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tqueue_work(swdev_wq, &swdev_work->work);\n\treturn NOTIFY_DONE;\n\nout_bad:\n\tkfree(swdev_work);\n\treturn NOTIFY_BAD;\n}\n\nstatic int\nprestera_port_vlan_bridge_join(struct prestera_port_vlan *port_vlan,\n\t\t\t       struct prestera_bridge_port *br_port)\n{\n\tstruct prestera_port *port = port_vlan->port;\n\tstruct prestera_bridge_vlan *br_vlan;\n\tu16 vid = port_vlan->vid;\n\tint err;\n\n\tif (port_vlan->br_port)\n\t\treturn 0;\n\n\terr = prestera_br_port_flags_set(br_port, port);\n\tif (err)\n\t\tgoto err_flags2port_set;\n\n\terr = prestera_port_vid_stp_set(port, vid, br_port->stp_state);\n\tif (err)\n\t\tgoto err_port_vid_stp_set;\n\n\tbr_vlan = prestera_bridge_vlan_by_vid(br_port, vid);\n\tif (!br_vlan) {\n\t\tbr_vlan = prestera_bridge_vlan_create(br_port, vid);\n\t\tif (!br_vlan) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_bridge_vlan_get;\n\t\t}\n\t}\n\n\tlist_add(&port_vlan->br_vlan_head, &br_vlan->port_vlan_list);\n\n\tprestera_bridge_port_get(br_port);\n\tport_vlan->br_port = br_port;\n\n\treturn 0;\n\nerr_bridge_vlan_get:\n\tprestera_port_vid_stp_set(port, vid, BR_STATE_FORWARDING);\nerr_port_vid_stp_set:\n\tprestera_br_port_flags_reset(br_port, port);\nerr_flags2port_set:\n\treturn err;\n}\n\nstatic int\nprestera_bridge_port_vlan_add(struct prestera_port *port,\n\t\t\t      struct prestera_bridge_port *br_port,\n\t\t\t      u16 vid, bool is_untagged, bool is_pvid,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct prestera_port_vlan *port_vlan;\n\tu16 old_pvid = port->pvid;\n\tu16 pvid;\n\tint err;\n\n\tif (is_pvid)\n\t\tpvid = vid;\n\telse\n\t\tpvid = port->pvid == vid ? 0 : port->pvid;\n\n\tport_vlan = prestera_port_vlan_by_vid(port, vid);\n\tif (port_vlan && port_vlan->br_port != br_port)\n\t\treturn -EEXIST;\n\n\tif (!port_vlan) {\n\t\tport_vlan = prestera_port_vlan_create(port, vid, is_untagged);\n\t\tif (IS_ERR(port_vlan))\n\t\t\treturn PTR_ERR(port_vlan);\n\t} else {\n\t\terr = prestera_hw_vlan_port_set(port, vid, true, is_untagged);\n\t\tif (err)\n\t\t\tgoto err_port_vlan_set;\n\t}\n\n\terr = prestera_port_pvid_set(port, pvid);\n\tif (err)\n\t\tgoto err_port_pvid_set;\n\n\terr = prestera_port_vlan_bridge_join(port_vlan, br_port);\n\tif (err)\n\t\tgoto err_port_vlan_bridge_join;\n\n\treturn 0;\n\nerr_port_vlan_bridge_join:\n\tprestera_port_pvid_set(port, old_pvid);\nerr_port_pvid_set:\n\tprestera_hw_vlan_port_set(port, vid, false, false);\nerr_port_vlan_set:\n\tprestera_port_vlan_destroy(port_vlan);\n\n\treturn err;\n}\n\nstatic void\nprestera_bridge_port_vlan_del(struct prestera_port *port,\n\t\t\t      struct prestera_bridge_port *br_port, u16 vid)\n{\n\tu16 pvid = port->pvid == vid ? 0 : port->pvid;\n\tstruct prestera_port_vlan *port_vlan;\n\n\tport_vlan = prestera_port_vlan_by_vid(port, vid);\n\tif (WARN_ON(!port_vlan))\n\t\treturn;\n\n\tprestera_port_vlan_bridge_leave(port_vlan);\n\tprestera_port_pvid_set(port, pvid);\n\tprestera_port_vlan_destroy(port_vlan);\n}\n\nstatic int prestera_port_vlans_add(struct prestera_port *port,\n\t\t\t\t   const struct switchdev_obj_port_vlan *vlan,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tbool flag_untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tbool flag_pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\tstruct net_device *orig_dev = vlan->obj.orig_dev;\n\tstruct prestera_bridge_port *br_port;\n\tstruct prestera_switch *sw = port->sw;\n\tstruct prestera_bridge *bridge;\n\n\tif (netif_is_bridge_master(orig_dev))\n\t\treturn 0;\n\n\tbr_port = prestera_bridge_port_by_dev(sw->swdev, port->dev);\n\tif (WARN_ON(!br_port))\n\t\treturn -EINVAL;\n\n\tbridge = br_port->bridge;\n\tif (!bridge->vlan_enabled)\n\t\treturn 0;\n\n\treturn prestera_bridge_port_vlan_add(port, br_port,\n\t\t\t\t\t     vlan->vid, flag_untagged,\n\t\t\t\t\t     flag_pvid, extack);\n}\n\nstatic struct prestera_br_mdb_entry *\nprestera_br_mdb_entry_create(struct prestera_switch *sw,\n\t\t\t     struct prestera_bridge *br_dev,\n\t\t\t     const unsigned char *addr, u16 vid)\n{\n\tstruct prestera_br_mdb_entry *br_mdb_entry;\n\tstruct prestera_mdb_entry *mdb_entry;\n\n\tbr_mdb_entry = kzalloc(sizeof(*br_mdb_entry), GFP_KERNEL);\n\tif (!br_mdb_entry)\n\t\treturn NULL;\n\n\tmdb_entry = prestera_mdb_entry_create(sw, addr, vid);\n\tif (!mdb_entry)\n\t\tgoto err_mdb_alloc;\n\n\tbr_mdb_entry->mdb = mdb_entry;\n\tbr_mdb_entry->bridge = br_dev;\n\tbr_mdb_entry->enabled = true;\n\tINIT_LIST_HEAD(&br_mdb_entry->br_mdb_port_list);\n\n\tlist_add(&br_mdb_entry->br_mdb_entry_node, &br_dev->br_mdb_entry_list);\n\n\treturn br_mdb_entry;\n\nerr_mdb_alloc:\n\tkfree(br_mdb_entry);\n\treturn NULL;\n}\n\nstatic int prestera_br_mdb_port_add(struct prestera_br_mdb_entry *br_mdb,\n\t\t\t\t    struct prestera_bridge_port *br_port)\n{\n\tstruct prestera_br_mdb_port *br_mdb_port;\n\n\tlist_for_each_entry(br_mdb_port, &br_mdb->br_mdb_port_list,\n\t\t\t    br_mdb_port_node)\n\t\tif (br_mdb_port->br_port == br_port)\n\t\t\treturn 0;\n\n\tbr_mdb_port = kzalloc(sizeof(*br_mdb_port), GFP_KERNEL);\n\tif (!br_mdb_port)\n\t\treturn -ENOMEM;\n\n\tbr_mdb_port->br_port = br_port;\n\tlist_add(&br_mdb_port->br_mdb_port_node,\n\t\t &br_mdb->br_mdb_port_list);\n\n\treturn 0;\n}\n\nstatic struct prestera_br_mdb_entry *\nprestera_br_mdb_entry_find(struct prestera_bridge *br_dev,\n\t\t\t   const unsigned char *addr, u16 vid)\n{\n\tstruct prestera_br_mdb_entry *br_mdb;\n\n\tlist_for_each_entry(br_mdb, &br_dev->br_mdb_entry_list,\n\t\t\t    br_mdb_entry_node)\n\t\tif (ether_addr_equal(&br_mdb->mdb->addr[0], addr) &&\n\t\t    vid == br_mdb->mdb->vid)\n\t\t\treturn br_mdb;\n\n\treturn NULL;\n}\n\nstatic struct prestera_br_mdb_entry *\nprestera_br_mdb_entry_get(struct prestera_switch *sw,\n\t\t\t  struct prestera_bridge *br_dev,\n\t\t\t  const unsigned char *addr, u16 vid)\n{\n\tstruct prestera_br_mdb_entry *br_mdb;\n\n\tbr_mdb = prestera_br_mdb_entry_find(br_dev, addr, vid);\n\tif (br_mdb)\n\t\treturn br_mdb;\n\n\treturn prestera_br_mdb_entry_create(sw, br_dev, addr, vid);\n}\n\nstatic int\nprestera_mdb_port_addr_obj_add(const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct prestera_br_mdb_entry *br_mdb;\n\tstruct prestera_bridge_port *br_port;\n\tstruct prestera_bridge *br_dev;\n\tstruct prestera_switch *sw;\n\tstruct prestera_port *port;\n\tint err;\n\n\tsw = prestera_switch_get(mdb->obj.orig_dev);\n\tport = prestera_port_dev_lower_find(mdb->obj.orig_dev);\n\n\tbr_port = prestera_bridge_port_find(sw, mdb->obj.orig_dev);\n\tif (!br_port)\n\t\treturn 0;\n\n\tbr_dev = br_port->bridge;\n\n\tif (mdb->vid && !prestera_port_vlan_by_vid(port, mdb->vid))\n\t\treturn 0;\n\n\tif (mdb->vid)\n\t\tbr_mdb = prestera_br_mdb_entry_get(sw, br_dev, &mdb->addr[0],\n\t\t\t\t\t\t   mdb->vid);\n\telse\n\t\tbr_mdb = prestera_br_mdb_entry_get(sw, br_dev, &mdb->addr[0],\n\t\t\t\t\t\t   br_dev->bridge_id);\n\n\tif (!br_mdb)\n\t\treturn -ENOMEM;\n\n\t \n\tWARN_ON(prestera_mdb_enable_set(br_mdb, br_dev->multicast_enabled &&\n\t\t\t\t\tbr_dev->mrouter_exist));\n\n\terr = prestera_br_mdb_port_add(br_mdb, br_port);\n\tif (err) {\n\t\tprestera_br_mdb_entry_put(br_mdb);\n\t\treturn err;\n\t}\n\n\terr = prestera_br_mdb_sync(br_dev);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int prestera_port_obj_add(struct net_device *dev, const void *ctx,\n\t\t\t\t const struct switchdev_obj *obj,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct prestera_port *port = netdev_priv(dev);\n\tconst struct switchdev_obj_port_vlan *vlan;\n\tconst struct switchdev_obj_port_mdb *mdb;\n\tint err = 0;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\tvlan = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\t\treturn prestera_port_vlans_add(port, vlan, extack);\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\t\tmdb = SWITCHDEV_OBJ_PORT_MDB(obj);\n\t\terr = prestera_mdb_port_addr_obj_add(mdb);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_HOST_MDB:\n\t\tfallthrough;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int prestera_port_vlans_del(struct prestera_port *port,\n\t\t\t\t   const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct net_device *orig_dev = vlan->obj.orig_dev;\n\tstruct prestera_bridge_port *br_port;\n\tstruct prestera_switch *sw = port->sw;\n\n\tif (netif_is_bridge_master(orig_dev))\n\t\treturn -EOPNOTSUPP;\n\n\tbr_port = prestera_bridge_port_by_dev(sw->swdev, port->dev);\n\tif (WARN_ON(!br_port))\n\t\treturn -EINVAL;\n\n\tif (!br_port->bridge->vlan_enabled)\n\t\treturn 0;\n\n\tprestera_bridge_port_vlan_del(port, br_port, vlan->vid);\n\n\treturn 0;\n}\n\nstatic int\nprestera_mdb_port_addr_obj_del(struct prestera_port *port,\n\t\t\t       const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct prestera_br_mdb_entry *br_mdb;\n\tstruct prestera_bridge_port *br_port;\n\tstruct prestera_bridge *br_dev;\n\tint err;\n\n\t \n\tbr_port = prestera_bridge_port_find(port->sw, mdb->obj.orig_dev);\n\tif (!br_port)\n\t\treturn 0;\n\n\t \n\tif (mdb->vid && !prestera_port_vlan_by_vid(port, mdb->vid))\n\t\treturn 0;\n\n\tbr_dev = br_port->bridge;\n\n\tif (br_port->bridge->vlan_enabled)\n\t\tbr_mdb = prestera_br_mdb_entry_find(br_dev, &mdb->addr[0],\n\t\t\t\t\t\t    mdb->vid);\n\telse\n\t\tbr_mdb = prestera_br_mdb_entry_find(br_dev, &mdb->addr[0],\n\t\t\t\t\t\t    br_port->bridge->bridge_id);\n\n\tif (!br_mdb)\n\t\treturn 0;\n\n\t \n\tprestera_br_mdb_port_del(br_mdb, br_port);\n\n\tprestera_br_mdb_entry_put(br_mdb);\n\n\terr = prestera_br_mdb_sync(br_dev);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int prestera_port_obj_del(struct net_device *dev, const void *ctx,\n\t\t\t\t const struct switchdev_obj *obj)\n{\n\tstruct prestera_port *port = netdev_priv(dev);\n\tconst struct switchdev_obj_port_mdb *mdb;\n\tint err = 0;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\treturn prestera_port_vlans_del(port, SWITCHDEV_OBJ_PORT_VLAN(obj));\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\t\tmdb = SWITCHDEV_OBJ_PORT_MDB(obj);\n\t\terr = prestera_mdb_port_addr_obj_del(port, mdb);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int prestera_switchdev_blk_event(struct notifier_block *unused,\n\t\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tint err;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_OBJ_ADD:\n\t\terr = switchdev_handle_port_obj_add(dev, ptr,\n\t\t\t\t\t\t    prestera_netdev_check,\n\t\t\t\t\t\t    prestera_port_obj_add);\n\t\tbreak;\n\tcase SWITCHDEV_PORT_OBJ_DEL:\n\t\terr = switchdev_handle_port_obj_del(dev, ptr,\n\t\t\t\t\t\t    prestera_netdev_check,\n\t\t\t\t\t\t    prestera_port_obj_del);\n\t\tbreak;\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     prestera_netdev_check,\n\t\t\t\t\t\t     prestera_port_obj_attr_set);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn notifier_from_errno(err);\n}\n\nstatic void prestera_fdb_event(struct prestera_switch *sw,\n\t\t\t       struct prestera_event *evt, void *arg)\n{\n\tstruct switchdev_notifier_fdb_info info = {};\n\tstruct net_device *dev = NULL;\n\tstruct prestera_port *port;\n\tstruct prestera_lag *lag;\n\n\tswitch (evt->fdb_evt.type) {\n\tcase PRESTERA_FDB_ENTRY_TYPE_REG_PORT:\n\t\tport = prestera_find_port(sw, evt->fdb_evt.dest.port_id);\n\t\tif (port)\n\t\t\tdev = port->dev;\n\t\tbreak;\n\tcase PRESTERA_FDB_ENTRY_TYPE_LAG:\n\t\tlag = prestera_lag_by_id(sw, evt->fdb_evt.dest.lag_id);\n\t\tif (lag)\n\t\t\tdev = lag->dev;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (!dev)\n\t\treturn;\n\n\tinfo.addr = evt->fdb_evt.data.mac;\n\tinfo.vid = evt->fdb_evt.vid;\n\tinfo.offloaded = true;\n\n\trtnl_lock();\n\n\tswitch (evt->id) {\n\tcase PRESTERA_FDB_EVENT_LEARNED:\n\t\tcall_switchdev_notifiers(SWITCHDEV_FDB_ADD_TO_BRIDGE,\n\t\t\t\t\t dev, &info.info, NULL);\n\t\tbreak;\n\tcase PRESTERA_FDB_EVENT_AGED:\n\t\tcall_switchdev_notifiers(SWITCHDEV_FDB_DEL_TO_BRIDGE,\n\t\t\t\t\t dev, &info.info, NULL);\n\t\tbreak;\n\t}\n\n\trtnl_unlock();\n}\n\nstatic int prestera_fdb_init(struct prestera_switch *sw)\n{\n\tint err;\n\n\terr = prestera_hw_event_handler_register(sw, PRESTERA_EVENT_TYPE_FDB,\n\t\t\t\t\t\t prestera_fdb_event, NULL);\n\tif (err)\n\t\treturn err;\n\n\terr = prestera_hw_switch_ageing_set(sw, PRESTERA_DEFAULT_AGEING_TIME_MS);\n\tif (err)\n\t\tgoto err_ageing_set;\n\n\treturn 0;\n\nerr_ageing_set:\n\tprestera_hw_event_handler_unregister(sw, PRESTERA_EVENT_TYPE_FDB,\n\t\t\t\t\t     prestera_fdb_event);\n\treturn err;\n}\n\nstatic void prestera_fdb_fini(struct prestera_switch *sw)\n{\n\tprestera_hw_event_handler_unregister(sw, PRESTERA_EVENT_TYPE_FDB,\n\t\t\t\t\t     prestera_fdb_event);\n}\n\nstatic int prestera_switchdev_handler_init(struct prestera_switchdev *swdev)\n{\n\tint err;\n\n\tswdev->swdev_nb.notifier_call = prestera_switchdev_event;\n\terr = register_switchdev_notifier(&swdev->swdev_nb);\n\tif (err)\n\t\tgoto err_register_swdev_notifier;\n\n\tswdev->swdev_nb_blk.notifier_call = prestera_switchdev_blk_event;\n\terr = register_switchdev_blocking_notifier(&swdev->swdev_nb_blk);\n\tif (err)\n\t\tgoto err_register_blk_swdev_notifier;\n\n\treturn 0;\n\nerr_register_blk_swdev_notifier:\n\tunregister_switchdev_notifier(&swdev->swdev_nb);\nerr_register_swdev_notifier:\n\tdestroy_workqueue(swdev_wq);\n\treturn err;\n}\n\nstatic void prestera_switchdev_handler_fini(struct prestera_switchdev *swdev)\n{\n\tunregister_switchdev_blocking_notifier(&swdev->swdev_nb_blk);\n\tunregister_switchdev_notifier(&swdev->swdev_nb);\n}\n\nint prestera_switchdev_init(struct prestera_switch *sw)\n{\n\tstruct prestera_switchdev *swdev;\n\tint err;\n\n\tswdev = kzalloc(sizeof(*swdev), GFP_KERNEL);\n\tif (!swdev)\n\t\treturn -ENOMEM;\n\n\tsw->swdev = swdev;\n\tswdev->sw = sw;\n\n\tINIT_LIST_HEAD(&swdev->bridge_list);\n\n\tswdev_wq = alloc_ordered_workqueue(\"%s_ordered\", 0, \"prestera_br\");\n\tif (!swdev_wq) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_wq;\n\t}\n\n\terr = prestera_switchdev_handler_init(swdev);\n\tif (err)\n\t\tgoto err_swdev_init;\n\n\terr = prestera_fdb_init(sw);\n\tif (err)\n\t\tgoto err_fdb_init;\n\n\treturn 0;\n\nerr_fdb_init:\nerr_swdev_init:\n\tdestroy_workqueue(swdev_wq);\nerr_alloc_wq:\n\tkfree(swdev);\n\n\treturn err;\n}\n\nvoid prestera_switchdev_fini(struct prestera_switch *sw)\n{\n\tstruct prestera_switchdev *swdev = sw->swdev;\n\n\tprestera_fdb_fini(sw);\n\tprestera_switchdev_handler_fini(swdev);\n\tdestroy_workqueue(swdev_wq);\n\tkfree(swdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}