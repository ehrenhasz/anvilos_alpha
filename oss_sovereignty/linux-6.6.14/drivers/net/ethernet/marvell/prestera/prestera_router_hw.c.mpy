{
  "module_name": "prestera_router_hw.c",
  "hash_id": "7692e98ad3d8c253847c8e85388854adde4a34d52d61cd902d47674d08e779ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/prestera/prestera_router_hw.c",
  "human_readable_source": "\n \n\n#include <linux/rhashtable.h>\n\n#include \"prestera.h\"\n#include \"prestera_hw.h\"\n#include \"prestera_router_hw.h\"\n#include \"prestera_acl.h\"\n\n \n\n#define PRESTERA_NHGR_UNUSED (0)\n#define PRESTERA_NHGR_DROP (0xFFFFFFFF)\n \n#define PRESTERA_NH_ACTIVE_JIFFER_FILTER 3000  \n\nstatic const struct rhashtable_params __prestera_fib_ht_params = {\n\t.key_offset  = offsetof(struct prestera_fib_node, key),\n\t.head_offset = offsetof(struct prestera_fib_node, ht_node),\n\t.key_len     = sizeof(struct prestera_fib_key),\n\t.automatic_shrinking = true,\n};\n\nstatic const struct rhashtable_params __prestera_nh_neigh_ht_params = {\n\t.key_offset  = offsetof(struct prestera_nh_neigh, key),\n\t.key_len     = sizeof(struct prestera_nh_neigh_key),\n\t.head_offset = offsetof(struct prestera_nh_neigh, ht_node),\n};\n\nstatic const struct rhashtable_params __prestera_nexthop_group_ht_params = {\n\t.key_offset  = offsetof(struct prestera_nexthop_group, key),\n\t.key_len     = sizeof(struct prestera_nexthop_group_key),\n\t.head_offset = offsetof(struct prestera_nexthop_group, ht_node),\n};\n\nstatic int prestera_nexthop_group_set(struct prestera_switch *sw,\n\t\t\t\t      struct prestera_nexthop_group *nh_grp);\nstatic bool\nprestera_nexthop_group_util_hw_state(struct prestera_switch *sw,\n\t\t\t\t     struct prestera_nexthop_group *nh_grp);\nstatic void prestera_fib_node_destroy_ht_cb(void *ptr, void *arg);\n\n \nstatic bool prestera_nh_neigh_key_is_valid(struct prestera_nh_neigh_key *key)\n{\n\treturn memchr_inv(key, 0, sizeof(*key)) ? true : false;\n}\n\nint prestera_router_hw_init(struct prestera_switch *sw)\n{\n\tint err;\n\n\terr = rhashtable_init(&sw->router->nh_neigh_ht,\n\t\t\t      &__prestera_nh_neigh_ht_params);\n\tif (err)\n\t\tgoto err_nh_neigh_ht_init;\n\n\terr = rhashtable_init(&sw->router->nexthop_group_ht,\n\t\t\t      &__prestera_nexthop_group_ht_params);\n\tif (err)\n\t\tgoto err_nexthop_grp_ht_init;\n\n\terr = rhashtable_init(&sw->router->fib_ht,\n\t\t\t      &__prestera_fib_ht_params);\n\tif (err)\n\t\tgoto err_fib_ht_init;\n\n\tINIT_LIST_HEAD(&sw->router->vr_list);\n\tINIT_LIST_HEAD(&sw->router->rif_entry_list);\n\n\treturn 0;\n\nerr_fib_ht_init:\n\trhashtable_destroy(&sw->router->nexthop_group_ht);\nerr_nexthop_grp_ht_init:\n\trhashtable_destroy(&sw->router->nh_neigh_ht);\nerr_nh_neigh_ht_init:\n\treturn 0;\n}\n\nvoid prestera_router_hw_fini(struct prestera_switch *sw)\n{\n\trhashtable_free_and_destroy(&sw->router->fib_ht,\n\t\t\t\t    prestera_fib_node_destroy_ht_cb, sw);\n\tWARN_ON(!list_empty(&sw->router->vr_list));\n\tWARN_ON(!list_empty(&sw->router->rif_entry_list));\n\trhashtable_destroy(&sw->router->fib_ht);\n\trhashtable_destroy(&sw->router->nexthop_group_ht);\n\trhashtable_destroy(&sw->router->nh_neigh_ht);\n}\n\nstatic struct prestera_vr *__prestera_vr_find(struct prestera_switch *sw,\n\t\t\t\t\t      u32 tb_id)\n{\n\tstruct prestera_vr *vr;\n\n\tlist_for_each_entry(vr, &sw->router->vr_list, router_node) {\n\t\tif (vr->tb_id == tb_id)\n\t\t\treturn vr;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct prestera_vr *__prestera_vr_create(struct prestera_switch *sw,\n\t\t\t\t\t\tu32 tb_id,\n\t\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct prestera_vr *vr;\n\tint err;\n\n\tvr = kzalloc(sizeof(*vr), GFP_KERNEL);\n\tif (!vr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_vr;\n\t}\n\n\tvr->tb_id = tb_id;\n\n\terr = prestera_hw_vr_create(sw, &vr->hw_vr_id);\n\tif (err)\n\t\tgoto err_hw_create;\n\n\tlist_add(&vr->router_node, &sw->router->vr_list);\n\n\treturn vr;\n\nerr_hw_create:\n\tkfree(vr);\nerr_alloc_vr:\n\treturn ERR_PTR(err);\n}\n\nstatic void __prestera_vr_destroy(struct prestera_switch *sw,\n\t\t\t\t  struct prestera_vr *vr)\n{\n\tlist_del(&vr->router_node);\n\tprestera_hw_vr_delete(sw, vr->hw_vr_id);\n\tkfree(vr);\n}\n\nstatic struct prestera_vr *prestera_vr_get(struct prestera_switch *sw, u32 tb_id,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct prestera_vr *vr;\n\n\tvr = __prestera_vr_find(sw, tb_id);\n\tif (vr) {\n\t\trefcount_inc(&vr->refcount);\n\t} else {\n\t\tvr = __prestera_vr_create(sw, tb_id, extack);\n\t\tif (IS_ERR(vr))\n\t\t\treturn ERR_CAST(vr);\n\n\t\trefcount_set(&vr->refcount, 1);\n\t}\n\n\treturn vr;\n}\n\nstatic void prestera_vr_put(struct prestera_switch *sw, struct prestera_vr *vr)\n{\n\tif (refcount_dec_and_test(&vr->refcount))\n\t\t__prestera_vr_destroy(sw, vr);\n}\n\n \nstatic int\n__prestera_rif_entry_key_copy(const struct prestera_rif_entry_key *in,\n\t\t\t      struct prestera_rif_entry_key *out)\n{\n\tmemset(out, 0, sizeof(*out));\n\n\tswitch (in->iface.type) {\n\tcase PRESTERA_IF_PORT_E:\n\t\tout->iface.dev_port.hw_dev_num = in->iface.dev_port.hw_dev_num;\n\t\tout->iface.dev_port.port_num = in->iface.dev_port.port_num;\n\t\tbreak;\n\tcase PRESTERA_IF_LAG_E:\n\t\tout->iface.lag_id = in->iface.lag_id;\n\t\tbreak;\n\tcase PRESTERA_IF_VID_E:\n\t\tout->iface.vlan_id = in->iface.vlan_id;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unsupported iface type\");\n\t\treturn -EINVAL;\n\t}\n\n\tout->iface.type = in->iface.type;\n\treturn 0;\n}\n\nstruct prestera_rif_entry *\nprestera_rif_entry_find(const struct prestera_switch *sw,\n\t\t\tconst struct prestera_rif_entry_key *k)\n{\n\tstruct prestera_rif_entry *rif_entry;\n\tstruct prestera_rif_entry_key lk;  \n\n\tif (__prestera_rif_entry_key_copy(k, &lk))\n\t\treturn NULL;\n\n\tlist_for_each_entry(rif_entry, &sw->router->rif_entry_list,\n\t\t\t    router_node) {\n\t\tif (!memcmp(k, &rif_entry->key, sizeof(*k)))\n\t\t\treturn rif_entry;\n\t}\n\n\treturn NULL;\n}\n\nvoid prestera_rif_entry_destroy(struct prestera_switch *sw,\n\t\t\t\tstruct prestera_rif_entry *e)\n{\n\tstruct prestera_iface iface;\n\n\tlist_del(&e->router_node);\n\n\tmemcpy(&iface, &e->key.iface, sizeof(iface));\n\tiface.vr_id = e->vr->hw_vr_id;\n\tprestera_hw_rif_delete(sw, e->hw_id, &iface);\n\n\tprestera_vr_put(sw, e->vr);\n\tkfree(e);\n}\n\nstruct prestera_rif_entry *\nprestera_rif_entry_create(struct prestera_switch *sw,\n\t\t\t  struct prestera_rif_entry_key *k,\n\t\t\t  u32 tb_id, const unsigned char *addr)\n{\n\tint err;\n\tstruct prestera_rif_entry *e;\n\tstruct prestera_iface iface;\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e)\n\t\tgoto err_kzalloc;\n\n\tif (__prestera_rif_entry_key_copy(k, &e->key))\n\t\tgoto err_key_copy;\n\n\te->vr = prestera_vr_get(sw, tb_id, NULL);\n\tif (IS_ERR(e->vr))\n\t\tgoto err_vr_get;\n\n\tmemcpy(&e->addr, addr, sizeof(e->addr));\n\n\t \n\tmemcpy(&iface, &e->key.iface, sizeof(iface));\n\tiface.vr_id = e->vr->hw_vr_id;\n\terr = prestera_hw_rif_create(sw, &iface, e->addr, &e->hw_id);\n\tif (err)\n\t\tgoto err_hw_create;\n\n\tlist_add(&e->router_node, &sw->router->rif_entry_list);\n\n\treturn e;\n\nerr_hw_create:\n\tprestera_vr_put(sw, e->vr);\nerr_vr_get:\nerr_key_copy:\n\tkfree(e);\nerr_kzalloc:\n\treturn NULL;\n}\n\nstatic void __prestera_nh_neigh_destroy(struct prestera_switch *sw,\n\t\t\t\t\tstruct prestera_nh_neigh *neigh)\n{\n\trhashtable_remove_fast(&sw->router->nh_neigh_ht,\n\t\t\t       &neigh->ht_node,\n\t\t\t       __prestera_nh_neigh_ht_params);\n\tkfree(neigh);\n}\n\nstatic struct prestera_nh_neigh *\n__prestera_nh_neigh_create(struct prestera_switch *sw,\n\t\t\t   struct prestera_nh_neigh_key *key)\n{\n\tstruct prestera_nh_neigh *neigh;\n\tint err;\n\n\tneigh = kzalloc(sizeof(*neigh), GFP_KERNEL);\n\tif (!neigh)\n\t\tgoto err_kzalloc;\n\n\tmemcpy(&neigh->key, key, sizeof(*key));\n\tneigh->info.connected = false;\n\tINIT_LIST_HEAD(&neigh->nexthop_group_list);\n\terr = rhashtable_insert_fast(&sw->router->nh_neigh_ht,\n\t\t\t\t     &neigh->ht_node,\n\t\t\t\t     __prestera_nh_neigh_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_insert;\n\n\treturn neigh;\n\nerr_rhashtable_insert:\n\tkfree(neigh);\nerr_kzalloc:\n\treturn NULL;\n}\n\nstruct prestera_nh_neigh *\nprestera_nh_neigh_find(struct prestera_switch *sw,\n\t\t       struct prestera_nh_neigh_key *key)\n{\n\tstruct prestera_nh_neigh *nh_neigh;\n\n\tnh_neigh = rhashtable_lookup_fast(&sw->router->nh_neigh_ht,\n\t\t\t\t\t  key, __prestera_nh_neigh_ht_params);\n\treturn nh_neigh;\n}\n\nstruct prestera_nh_neigh *\nprestera_nh_neigh_get(struct prestera_switch *sw,\n\t\t      struct prestera_nh_neigh_key *key)\n{\n\tstruct prestera_nh_neigh *neigh;\n\n\tneigh = prestera_nh_neigh_find(sw, key);\n\tif (!neigh)\n\t\treturn __prestera_nh_neigh_create(sw, key);\n\n\treturn neigh;\n}\n\nvoid prestera_nh_neigh_put(struct prestera_switch *sw,\n\t\t\t   struct prestera_nh_neigh *neigh)\n{\n\tif (list_empty(&neigh->nexthop_group_list))\n\t\t__prestera_nh_neigh_destroy(sw, neigh);\n}\n\n \nint prestera_nh_neigh_set(struct prestera_switch *sw,\n\t\t\t  struct prestera_nh_neigh *neigh)\n{\n\tstruct prestera_nh_neigh_head *nh_head;\n\tstruct prestera_nexthop_group *nh_grp;\n\tint err;\n\n\tlist_for_each_entry(nh_head, &neigh->nexthop_group_list, head) {\n\t\tnh_grp = nh_head->this;\n\t\terr = prestera_nexthop_group_set(sw, nh_grp);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nbool prestera_nh_neigh_util_hw_state(struct prestera_switch *sw,\n\t\t\t\t     struct prestera_nh_neigh *nh_neigh)\n{\n\tbool state;\n\tstruct prestera_nh_neigh_head *nh_head, *tmp;\n\n\tstate = false;\n\tlist_for_each_entry_safe(nh_head, tmp,\n\t\t\t\t &nh_neigh->nexthop_group_list, head) {\n\t\tstate = prestera_nexthop_group_util_hw_state(sw, nh_head->this);\n\t\tif (state)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn state;\n}\n\nstatic struct prestera_nexthop_group *\n__prestera_nexthop_group_create(struct prestera_switch *sw,\n\t\t\t\tstruct prestera_nexthop_group_key *key)\n{\n\tstruct prestera_nexthop_group *nh_grp;\n\tstruct prestera_nh_neigh *nh_neigh;\n\tint nh_cnt, err, gid;\n\n\tnh_grp = kzalloc(sizeof(*nh_grp), GFP_KERNEL);\n\tif (!nh_grp)\n\t\tgoto err_kzalloc;\n\n\tmemcpy(&nh_grp->key, key, sizeof(*key));\n\tfor (nh_cnt = 0; nh_cnt < PRESTERA_NHGR_SIZE_MAX; nh_cnt++) {\n\t\tif (!prestera_nh_neigh_key_is_valid(&nh_grp->key.neigh[nh_cnt]))\n\t\t\tbreak;\n\n\t\tnh_neigh = prestera_nh_neigh_get(sw,\n\t\t\t\t\t\t &nh_grp->key.neigh[nh_cnt]);\n\t\tif (!nh_neigh)\n\t\t\tgoto err_nh_neigh_get;\n\n\t\tnh_grp->nh_neigh_head[nh_cnt].neigh = nh_neigh;\n\t\tnh_grp->nh_neigh_head[nh_cnt].this = nh_grp;\n\t\tlist_add(&nh_grp->nh_neigh_head[nh_cnt].head,\n\t\t\t &nh_neigh->nexthop_group_list);\n\t}\n\n\terr = prestera_hw_nh_group_create(sw, nh_cnt, &nh_grp->grp_id);\n\tif (err)\n\t\tgoto err_nh_group_create;\n\n\terr = prestera_nexthop_group_set(sw, nh_grp);\n\tif (err)\n\t\tgoto err_nexthop_group_set;\n\n\terr = rhashtable_insert_fast(&sw->router->nexthop_group_ht,\n\t\t\t\t     &nh_grp->ht_node,\n\t\t\t\t     __prestera_nexthop_group_ht_params);\n\tif (err)\n\t\tgoto err_ht_insert;\n\n\t \n\tgid = nh_grp->grp_id;\n\tsw->router->nhgrp_hw_state_cache[gid / 8] &= ~BIT(gid % 8);\n\n\treturn nh_grp;\n\nerr_ht_insert:\nerr_nexthop_group_set:\n\tprestera_hw_nh_group_delete(sw, nh_cnt, nh_grp->grp_id);\nerr_nh_group_create:\nerr_nh_neigh_get:\n\tfor (nh_cnt--; nh_cnt >= 0; nh_cnt--) {\n\t\tlist_del(&nh_grp->nh_neigh_head[nh_cnt].head);\n\t\tprestera_nh_neigh_put(sw, nh_grp->nh_neigh_head[nh_cnt].neigh);\n\t}\n\n\tkfree(nh_grp);\nerr_kzalloc:\n\treturn NULL;\n}\n\nstatic void\n__prestera_nexthop_group_destroy(struct prestera_switch *sw,\n\t\t\t\t struct prestera_nexthop_group *nh_grp)\n{\n\tstruct prestera_nh_neigh *nh_neigh;\n\tint nh_cnt;\n\n\trhashtable_remove_fast(&sw->router->nexthop_group_ht,\n\t\t\t       &nh_grp->ht_node,\n\t\t\t       __prestera_nexthop_group_ht_params);\n\n\tfor (nh_cnt = 0; nh_cnt < PRESTERA_NHGR_SIZE_MAX; nh_cnt++) {\n\t\tnh_neigh = nh_grp->nh_neigh_head[nh_cnt].neigh;\n\t\tif (!nh_neigh)\n\t\t\tbreak;\n\n\t\tlist_del(&nh_grp->nh_neigh_head[nh_cnt].head);\n\t\tprestera_nh_neigh_put(sw, nh_neigh);\n\t}\n\n\tprestera_hw_nh_group_delete(sw, nh_cnt, nh_grp->grp_id);\n\tkfree(nh_grp);\n}\n\nstatic struct prestera_nexthop_group *\n__prestera_nexthop_group_find(struct prestera_switch *sw,\n\t\t\t      struct prestera_nexthop_group_key *key)\n{\n\tstruct prestera_nexthop_group *nh_grp;\n\n\tnh_grp = rhashtable_lookup_fast(&sw->router->nexthop_group_ht,\n\t\t\t\t\tkey, __prestera_nexthop_group_ht_params);\n\treturn nh_grp;\n}\n\nstatic struct prestera_nexthop_group *\nprestera_nexthop_group_get(struct prestera_switch *sw,\n\t\t\t   struct prestera_nexthop_group_key *key)\n{\n\tstruct prestera_nexthop_group *nh_grp;\n\n\tnh_grp = __prestera_nexthop_group_find(sw, key);\n\tif (nh_grp) {\n\t\trefcount_inc(&nh_grp->refcount);\n\t} else {\n\t\tnh_grp = __prestera_nexthop_group_create(sw, key);\n\t\tif (!nh_grp)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\trefcount_set(&nh_grp->refcount, 1);\n\t}\n\n\treturn nh_grp;\n}\n\nstatic void prestera_nexthop_group_put(struct prestera_switch *sw,\n\t\t\t\t       struct prestera_nexthop_group *nh_grp)\n{\n\tif (refcount_dec_and_test(&nh_grp->refcount))\n\t\t__prestera_nexthop_group_destroy(sw, nh_grp);\n}\n\n \nstatic int prestera_nexthop_group_set(struct prestera_switch *sw,\n\t\t\t\t      struct prestera_nexthop_group *nh_grp)\n{\n\tstruct prestera_neigh_info info[PRESTERA_NHGR_SIZE_MAX];\n\tstruct prestera_nh_neigh *neigh;\n\tint nh_cnt;\n\n\tmemset(&info[0], 0, sizeof(info));\n\tfor (nh_cnt = 0; nh_cnt < PRESTERA_NHGR_SIZE_MAX; nh_cnt++) {\n\t\tneigh = nh_grp->nh_neigh_head[nh_cnt].neigh;\n\t\tif (!neigh)\n\t\t\tbreak;\n\n\t\tmemcpy(&info[nh_cnt], &neigh->info, sizeof(neigh->info));\n\t}\n\n\treturn prestera_hw_nh_entries_set(sw, nh_cnt, &info[0], nh_grp->grp_id);\n}\n\nstatic bool\nprestera_nexthop_group_util_hw_state(struct prestera_switch *sw,\n\t\t\t\t     struct prestera_nexthop_group *nh_grp)\n{\n\tint err;\n\tu32 buf_size = sw->size_tbl_router_nexthop / 8 + 1;\n\tu32 gid = nh_grp->grp_id;\n\tu8 *cache = sw->router->nhgrp_hw_state_cache;\n\n\t \n\tif (!time_before(jiffies, sw->router->nhgrp_hw_cache_kick +\n\t\t\tmsecs_to_jiffies(PRESTERA_NH_ACTIVE_JIFFER_FILTER))) {\n\t\terr = prestera_hw_nhgrp_blk_get(sw, cache, buf_size);\n\t\tif (err) {\n\t\t\tpr_err(\"Failed to get hw state nh_grp's\");\n\t\t\treturn false;\n\t\t}\n\n\t\tsw->router->nhgrp_hw_cache_kick = jiffies;\n\t}\n\n\tif (cache[gid / 8] & BIT(gid % 8))\n\t\treturn true;\n\n\treturn false;\n}\n\nstruct prestera_fib_node *\nprestera_fib_node_find(struct prestera_switch *sw, struct prestera_fib_key *key)\n{\n\tstruct prestera_fib_node *fib_node;\n\n\tfib_node = rhashtable_lookup_fast(&sw->router->fib_ht, key,\n\t\t\t\t\t  __prestera_fib_ht_params);\n\treturn fib_node;\n}\n\nstatic void __prestera_fib_node_destruct(struct prestera_switch *sw,\n\t\t\t\t\t struct prestera_fib_node *fib_node)\n{\n\tstruct prestera_vr *vr;\n\n\tvr = fib_node->info.vr;\n\tprestera_hw_lpm_del(sw, vr->hw_vr_id, fib_node->key.addr.u.ipv4,\n\t\t\t    fib_node->key.prefix_len);\n\tswitch (fib_node->info.type) {\n\tcase PRESTERA_FIB_TYPE_UC_NH:\n\t\tprestera_nexthop_group_put(sw, fib_node->info.nh_grp);\n\t\tbreak;\n\tcase PRESTERA_FIB_TYPE_TRAP:\n\t\tbreak;\n\tcase PRESTERA_FIB_TYPE_DROP:\n\t\tbreak;\n\tdefault:\n\t      pr_err(\"Unknown fib_node->info.type = %d\",\n\t\t     fib_node->info.type);\n\t}\n\n\tprestera_vr_put(sw, vr);\n}\n\nvoid prestera_fib_node_destroy(struct prestera_switch *sw,\n\t\t\t       struct prestera_fib_node *fib_node)\n{\n\t__prestera_fib_node_destruct(sw, fib_node);\n\trhashtable_remove_fast(&sw->router->fib_ht, &fib_node->ht_node,\n\t\t\t       __prestera_fib_ht_params);\n\tkfree(fib_node);\n}\n\nstatic void prestera_fib_node_destroy_ht_cb(void *ptr, void *arg)\n{\n\tstruct prestera_fib_node *node = ptr;\n\tstruct prestera_switch *sw = arg;\n\n\t__prestera_fib_node_destruct(sw, node);\n\tkfree(node);\n}\n\nstruct prestera_fib_node *\nprestera_fib_node_create(struct prestera_switch *sw,\n\t\t\t struct prestera_fib_key *key,\n\t\t\t enum prestera_fib_type fib_type,\n\t\t\t struct prestera_nexthop_group_key *nh_grp_key)\n{\n\tstruct prestera_fib_node *fib_node;\n\tu32 grp_id;\n\tstruct prestera_vr *vr;\n\tint err;\n\n\tfib_node = kzalloc(sizeof(*fib_node), GFP_KERNEL);\n\tif (!fib_node)\n\t\tgoto err_kzalloc;\n\n\tmemcpy(&fib_node->key, key, sizeof(*key));\n\tfib_node->info.type = fib_type;\n\n\tvr = prestera_vr_get(sw, key->tb_id, NULL);\n\tif (IS_ERR(vr))\n\t\tgoto err_vr_get;\n\n\tfib_node->info.vr = vr;\n\n\tswitch (fib_type) {\n\tcase PRESTERA_FIB_TYPE_TRAP:\n\t\tgrp_id = PRESTERA_NHGR_UNUSED;\n\t\tbreak;\n\tcase PRESTERA_FIB_TYPE_DROP:\n\t\tgrp_id = PRESTERA_NHGR_DROP;\n\t\tbreak;\n\tcase PRESTERA_FIB_TYPE_UC_NH:\n\t\tfib_node->info.nh_grp = prestera_nexthop_group_get(sw,\n\t\t\t\t\t\t\t\t   nh_grp_key);\n\t\tif (IS_ERR(fib_node->info.nh_grp))\n\t\t\tgoto err_nh_grp_get;\n\n\t\tgrp_id = fib_node->info.nh_grp->grp_id;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unsupported fib_type %d\", fib_type);\n\t\tgoto err_nh_grp_get;\n\t}\n\n\terr = prestera_hw_lpm_add(sw, vr->hw_vr_id, key->addr.u.ipv4,\n\t\t\t\t  key->prefix_len, grp_id);\n\tif (err)\n\t\tgoto err_lpm_add;\n\n\terr = rhashtable_insert_fast(&sw->router->fib_ht, &fib_node->ht_node,\n\t\t\t\t     __prestera_fib_ht_params);\n\tif (err)\n\t\tgoto err_ht_insert;\n\n\treturn fib_node;\n\nerr_ht_insert:\n\tprestera_hw_lpm_del(sw, vr->hw_vr_id, key->addr.u.ipv4,\n\t\t\t    key->prefix_len);\nerr_lpm_add:\n\tif (fib_type == PRESTERA_FIB_TYPE_UC_NH)\n\t\tprestera_nexthop_group_put(sw, fib_node->info.nh_grp);\nerr_nh_grp_get:\n\tprestera_vr_put(sw, vr);\nerr_vr_get:\n\tkfree(fib_node);\nerr_kzalloc:\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}