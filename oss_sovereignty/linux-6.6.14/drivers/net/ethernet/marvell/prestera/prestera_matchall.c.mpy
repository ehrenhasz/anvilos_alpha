{
  "module_name": "prestera_matchall.c",
  "hash_id": "34c0dd2e758483bcf9f81f382b8411be8626fc9f0f67d0184eeb4159ff40fa98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/prestera/prestera_matchall.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/list.h>\n\n#include \"prestera.h\"\n#include \"prestera_hw.h\"\n#include \"prestera_flow.h\"\n#include \"prestera_flower.h\"\n#include \"prestera_matchall.h\"\n#include \"prestera_span.h\"\n\nstatic int prestera_mall_prio_check(struct prestera_flow_block *block,\n\t\t\t\t    struct tc_cls_matchall_offload *f)\n{\n\tu32 flower_prio_min;\n\tu32 flower_prio_max;\n\tint err;\n\n\terr = prestera_flower_prio_get(block, f->common.chain_index,\n\t\t\t\t       &flower_prio_min, &flower_prio_max);\n\tif (err == -ENOENT)\n\t\t \n\t\treturn 0;\n\n\tif (err) {\n\t\tNL_SET_ERR_MSG(f->common.extack, \"Failed to get flower priorities\");\n\t\treturn err;\n\t}\n\n\tif (f->common.prio <= flower_prio_max && !block->ingress) {\n\t\tNL_SET_ERR_MSG(f->common.extack, \"Failed to add in front of existing flower rules\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (f->common.prio >= flower_prio_min && block->ingress) {\n\t\tNL_SET_ERR_MSG(f->common.extack, \"Failed to add behind of existing flower rules\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint prestera_mall_prio_get(struct prestera_flow_block *block,\n\t\t\t   u32 *prio_min, u32 *prio_max)\n{\n\tif (!block->mall.bound)\n\t\treturn -ENOENT;\n\n\t*prio_min = block->mall.prio_min;\n\t*prio_max = block->mall.prio_max;\n\treturn 0;\n}\n\nstatic void prestera_mall_prio_update(struct prestera_flow_block *block,\n\t\t\t\t      struct tc_cls_matchall_offload *f)\n{\n\tblock->mall.prio_min = min(block->mall.prio_min, f->common.prio);\n\tblock->mall.prio_max = max(block->mall.prio_max, f->common.prio);\n}\n\nint prestera_mall_replace(struct prestera_flow_block *block,\n\t\t\t  struct tc_cls_matchall_offload *f)\n{\n\tstruct prestera_flow_block_binding *binding;\n\t__be16 protocol = f->common.protocol;\n\tstruct flow_action_entry *act;\n\tstruct prestera_port *port;\n\tint err;\n\n\tif (!flow_offload_has_one_action(&f->rule->action)) {\n\t\tNL_SET_ERR_MSG(f->common.extack,\n\t\t\t       \"Only singular actions are supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tact = &f->rule->action.entries[0];\n\n\tif (!prestera_netdev_check(act->dev)) {\n\t\tNL_SET_ERR_MSG(f->common.extack,\n\t\t\t       \"Only Marvell Prestera port is supported\");\n\t\treturn -EINVAL;\n\t}\n\tif (!tc_cls_can_offload_and_chain0(act->dev, &f->common))\n\t\treturn -EOPNOTSUPP;\n\tif (act->id != FLOW_ACTION_MIRRED)\n\t\treturn -EOPNOTSUPP;\n\tif (protocol != htons(ETH_P_ALL))\n\t\treturn -EOPNOTSUPP;\n\n\terr = prestera_mall_prio_check(block, f);\n\tif (err)\n\t\treturn err;\n\n\tport = netdev_priv(act->dev);\n\n\tlist_for_each_entry(binding, &block->binding_list, list) {\n\t\terr = prestera_span_rule_add(binding, port, block->ingress);\n\t\tif (err == -EEXIST)\n\t\t\treturn err;\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\n\tprestera_mall_prio_update(block, f);\n\n\tblock->mall.bound = true;\n\treturn 0;\n\nrollback:\n\tlist_for_each_entry_continue_reverse(binding,\n\t\t\t\t\t     &block->binding_list, list)\n\t\tprestera_span_rule_del(binding, block->ingress);\n\treturn err;\n}\n\nvoid prestera_mall_destroy(struct prestera_flow_block *block)\n{\n\tstruct prestera_flow_block_binding *binding;\n\n\tlist_for_each_entry(binding, &block->binding_list, list)\n\t\tprestera_span_rule_del(binding, block->ingress);\n\n\tblock->mall.prio_min = UINT_MAX;\n\tblock->mall.prio_max = 0;\n\tblock->mall.bound = false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}