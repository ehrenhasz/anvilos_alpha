{
  "module_name": "prestera_flow.c",
  "hash_id": "f834ba9fa6225c596a192184855e43d86de15136a9294411fc7051f9dac5c2fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/prestera/prestera_flow.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/list.h>\n\n#include \"prestera.h\"\n#include \"prestera_acl.h\"\n#include \"prestera_flow.h\"\n#include \"prestera_flower.h\"\n#include \"prestera_matchall.h\"\n#include \"prestera_span.h\"\n\nstatic LIST_HEAD(prestera_block_cb_list);\n\nstatic int prestera_flow_block_mall_cb(struct prestera_flow_block *block,\n\t\t\t\t       struct tc_cls_matchall_offload *f)\n{\n\tswitch (f->command) {\n\tcase TC_CLSMATCHALL_REPLACE:\n\t\treturn prestera_mall_replace(block, f);\n\tcase TC_CLSMATCHALL_DESTROY:\n\t\tprestera_mall_destroy(block);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int prestera_flow_block_flower_cb(struct prestera_flow_block *block,\n\t\t\t\t\t struct flow_cls_offload *f)\n{\n\tswitch (f->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn prestera_flower_replace(block, f);\n\tcase FLOW_CLS_DESTROY:\n\t\tprestera_flower_destroy(block, f);\n\t\treturn 0;\n\tcase FLOW_CLS_STATS:\n\t\treturn prestera_flower_stats(block, f);\n\tcase FLOW_CLS_TMPLT_CREATE:\n\t\treturn prestera_flower_tmplt_create(block, f);\n\tcase FLOW_CLS_TMPLT_DESTROY:\n\t\tprestera_flower_tmplt_destroy(block, f);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int prestera_flow_block_cb(enum tc_setup_type type,\n\t\t\t\t  void *type_data, void *cb_priv)\n{\n\tstruct prestera_flow_block *block = cb_priv;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn prestera_flow_block_flower_cb(block, type_data);\n\tcase TC_SETUP_CLSMATCHALL:\n\t\treturn prestera_flow_block_mall_cb(block, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void prestera_flow_block_destroy(void *cb_priv)\n{\n\tstruct prestera_flow_block *block = cb_priv;\n\n\tprestera_flower_template_cleanup(block);\n\n\tWARN_ON(!list_empty(&block->template_list));\n\tWARN_ON(!list_empty(&block->binding_list));\n\n\tkfree(block);\n}\n\nstatic struct prestera_flow_block *\nprestera_flow_block_create(struct prestera_switch *sw,\n\t\t\t   struct net *net,\n\t\t\t   bool ingress)\n{\n\tstruct prestera_flow_block *block;\n\n\tblock = kzalloc(sizeof(*block), GFP_KERNEL);\n\tif (!block)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&block->binding_list);\n\tINIT_LIST_HEAD(&block->template_list);\n\tblock->net = net;\n\tblock->sw = sw;\n\tblock->mall.prio_min = UINT_MAX;\n\tblock->mall.prio_max = 0;\n\tblock->mall.bound = false;\n\tblock->ingress = ingress;\n\n\treturn block;\n}\n\nstatic void prestera_flow_block_release(void *cb_priv)\n{\n\tstruct prestera_flow_block *block = cb_priv;\n\n\tprestera_flow_block_destroy(block);\n}\n\nstatic bool\nprestera_flow_block_is_bound(const struct prestera_flow_block *block)\n{\n\treturn block->ruleset_zero;\n}\n\nstatic struct prestera_flow_block_binding *\nprestera_flow_block_lookup(struct prestera_flow_block *block,\n\t\t\t   struct prestera_port *port)\n{\n\tstruct prestera_flow_block_binding *binding;\n\n\tlist_for_each_entry(binding, &block->binding_list, list)\n\t\tif (binding->port == port)\n\t\t\treturn binding;\n\n\treturn NULL;\n}\n\nstatic int prestera_flow_block_bind(struct prestera_flow_block *block,\n\t\t\t\t    struct prestera_port *port)\n{\n\tstruct prestera_flow_block_binding *binding;\n\tint err;\n\n\tbinding = kzalloc(sizeof(*binding), GFP_KERNEL);\n\tif (!binding)\n\t\treturn -ENOMEM;\n\n\tbinding->span_id = PRESTERA_SPAN_INVALID_ID;\n\tbinding->port = port;\n\n\tif (prestera_flow_block_is_bound(block)) {\n\t\terr = prestera_acl_ruleset_bind(block->ruleset_zero, port);\n\t\tif (err)\n\t\t\tgoto err_ruleset_bind;\n\t}\n\n\tlist_add(&binding->list, &block->binding_list);\n\treturn 0;\n\nerr_ruleset_bind:\n\tkfree(binding);\n\treturn err;\n}\n\nstatic int prestera_flow_block_unbind(struct prestera_flow_block *block,\n\t\t\t\t      struct prestera_port *port)\n{\n\tstruct prestera_flow_block_binding *binding;\n\n\tbinding = prestera_flow_block_lookup(block, port);\n\tif (!binding)\n\t\treturn -ENOENT;\n\n\tlist_del(&binding->list);\n\n\tif (prestera_flow_block_is_bound(block))\n\t\tprestera_acl_ruleset_unbind(block->ruleset_zero, port);\n\n\tkfree(binding);\n\treturn 0;\n}\n\nstatic struct prestera_flow_block *\nprestera_flow_block_get(struct prestera_switch *sw,\n\t\t\tstruct flow_block_offload *f,\n\t\t\tbool *register_block,\n\t\t\tbool ingress)\n{\n\tstruct prestera_flow_block *block;\n\tstruct flow_block_cb *block_cb;\n\n\tblock_cb = flow_block_cb_lookup(f->block,\n\t\t\t\t\tprestera_flow_block_cb, sw);\n\tif (!block_cb) {\n\t\tblock = prestera_flow_block_create(sw, f->net, ingress);\n\t\tif (!block)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tblock_cb = flow_block_cb_alloc(prestera_flow_block_cb,\n\t\t\t\t\t       sw, block,\n\t\t\t\t\t       prestera_flow_block_release);\n\t\tif (IS_ERR(block_cb)) {\n\t\t\tprestera_flow_block_destroy(block);\n\t\t\treturn ERR_CAST(block_cb);\n\t\t}\n\n\t\tblock->block_cb = block_cb;\n\t\t*register_block = true;\n\t} else {\n\t\tblock = flow_block_cb_priv(block_cb);\n\t\t*register_block = false;\n\t}\n\n\tflow_block_cb_incref(block_cb);\n\n\treturn block;\n}\n\nstatic void prestera_flow_block_put(struct prestera_flow_block *block)\n{\n\tstruct flow_block_cb *block_cb = block->block_cb;\n\n\tif (flow_block_cb_decref(block_cb))\n\t\treturn;\n\n\tflow_block_cb_free(block_cb);\n\tprestera_flow_block_destroy(block);\n}\n\nstatic int prestera_setup_flow_block_bind(struct prestera_port *port,\n\t\t\t\t\t  struct flow_block_offload *f, bool ingress)\n{\n\tstruct prestera_switch *sw = port->sw;\n\tstruct prestera_flow_block *block;\n\tstruct flow_block_cb *block_cb;\n\tbool register_block;\n\tint err;\n\n\tblock = prestera_flow_block_get(sw, f, &register_block, ingress);\n\tif (IS_ERR(block))\n\t\treturn PTR_ERR(block);\n\n\tblock_cb = block->block_cb;\n\n\terr = prestera_flow_block_bind(block, port);\n\tif (err)\n\t\tgoto err_block_bind;\n\n\tif (register_block) {\n\t\tflow_block_cb_add(block_cb, f);\n\t\tlist_add_tail(&block_cb->driver_list, &prestera_block_cb_list);\n\t}\n\n\tif (ingress)\n\t\tport->ingress_flow_block = block;\n\telse\n\t\tport->egress_flow_block = block;\n\n\treturn 0;\n\nerr_block_bind:\n\tprestera_flow_block_put(block);\n\n\treturn err;\n}\n\nstatic void prestera_setup_flow_block_unbind(struct prestera_port *port,\n\t\t\t\t\t     struct flow_block_offload *f, bool ingress)\n{\n\tstruct prestera_switch *sw = port->sw;\n\tstruct prestera_flow_block *block;\n\tstruct flow_block_cb *block_cb;\n\tint err;\n\n\tblock_cb = flow_block_cb_lookup(f->block, prestera_flow_block_cb, sw);\n\tif (!block_cb)\n\t\treturn;\n\n\tblock = flow_block_cb_priv(block_cb);\n\n\tprestera_mall_destroy(block);\n\n\terr = prestera_flow_block_unbind(block, port);\n\tif (err)\n\t\tgoto error;\n\n\tif (!flow_block_cb_decref(block_cb)) {\n\t\tflow_block_cb_remove(block_cb, f);\n\t\tlist_del(&block_cb->driver_list);\n\t}\nerror:\n\tif (ingress)\n\t\tport->ingress_flow_block = NULL;\n\telse\n\t\tport->egress_flow_block = NULL;\n}\n\nstatic int prestera_setup_flow_block_clsact(struct prestera_port *port,\n\t\t\t\t\t    struct flow_block_offload *f,\n\t\t\t\t\t    bool ingress)\n{\n\tf->driver_block_list = &prestera_block_cb_list;\n\n\tswitch (f->command) {\n\tcase FLOW_BLOCK_BIND:\n\t\treturn prestera_setup_flow_block_bind(port, f, ingress);\n\tcase FLOW_BLOCK_UNBIND:\n\t\tprestera_setup_flow_block_unbind(port, f, ingress);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint prestera_flow_block_setup(struct prestera_port *port,\n\t\t\t      struct flow_block_offload *f)\n{\n\tswitch (f->binder_type) {\n\tcase FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS:\n\t\treturn prestera_setup_flow_block_clsact(port, f, true);\n\tcase FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS:\n\t\treturn prestera_setup_flow_block_clsact(port, f, false);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}