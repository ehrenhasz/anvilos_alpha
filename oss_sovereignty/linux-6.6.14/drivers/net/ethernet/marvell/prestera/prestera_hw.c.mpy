{
  "module_name": "prestera_hw.c",
  "hash_id": "5062e7b7762226b4a3a816d940c12393af8087455286dcf60ffb12dd99995046",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/prestera/prestera_hw.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/ethtool.h>\n#include <linux/list.h>\n\n#include \"prestera.h\"\n#include \"prestera_hw.h\"\n#include \"prestera_acl.h\"\n#include \"prestera_counter.h\"\n#include \"prestera_router_hw.h\"\n\n#define PRESTERA_SWITCH_INIT_TIMEOUT_MS (30 * 1000)\n\n#define PRESTERA_MIN_MTU 64\n\n#define PRESTERA_MSG_CHUNK_SIZE 1024\n\nenum prestera_cmd_type_t {\n\tPRESTERA_CMD_TYPE_SWITCH_INIT = 0x1,\n\tPRESTERA_CMD_TYPE_SWITCH_ATTR_SET = 0x2,\n\n\tPRESTERA_CMD_TYPE_PORT_ATTR_SET = 0x100,\n\tPRESTERA_CMD_TYPE_PORT_ATTR_GET = 0x101,\n\tPRESTERA_CMD_TYPE_PORT_INFO_GET = 0x110,\n\n\tPRESTERA_CMD_TYPE_VLAN_CREATE = 0x200,\n\tPRESTERA_CMD_TYPE_VLAN_DELETE = 0x201,\n\tPRESTERA_CMD_TYPE_VLAN_PORT_SET = 0x202,\n\tPRESTERA_CMD_TYPE_VLAN_PVID_SET = 0x203,\n\n\tPRESTERA_CMD_TYPE_FDB_ADD = 0x300,\n\tPRESTERA_CMD_TYPE_FDB_DELETE = 0x301,\n\tPRESTERA_CMD_TYPE_FDB_FLUSH_PORT = 0x310,\n\tPRESTERA_CMD_TYPE_FDB_FLUSH_VLAN = 0x311,\n\tPRESTERA_CMD_TYPE_FDB_FLUSH_PORT_VLAN = 0x312,\n\n\tPRESTERA_CMD_TYPE_BRIDGE_CREATE = 0x400,\n\tPRESTERA_CMD_TYPE_BRIDGE_DELETE = 0x401,\n\tPRESTERA_CMD_TYPE_BRIDGE_PORT_ADD = 0x402,\n\tPRESTERA_CMD_TYPE_BRIDGE_PORT_DELETE = 0x403,\n\n\tPRESTERA_CMD_TYPE_COUNTER_GET = 0x510,\n\tPRESTERA_CMD_TYPE_COUNTER_ABORT = 0x511,\n\tPRESTERA_CMD_TYPE_COUNTER_TRIGGER = 0x512,\n\tPRESTERA_CMD_TYPE_COUNTER_BLOCK_GET = 0x513,\n\tPRESTERA_CMD_TYPE_COUNTER_BLOCK_RELEASE = 0x514,\n\tPRESTERA_CMD_TYPE_COUNTER_CLEAR = 0x515,\n\n\tPRESTERA_CMD_TYPE_VTCAM_CREATE = 0x540,\n\tPRESTERA_CMD_TYPE_VTCAM_DESTROY = 0x541,\n\tPRESTERA_CMD_TYPE_VTCAM_RULE_ADD = 0x550,\n\tPRESTERA_CMD_TYPE_VTCAM_RULE_DELETE = 0x551,\n\tPRESTERA_CMD_TYPE_VTCAM_IFACE_BIND = 0x560,\n\tPRESTERA_CMD_TYPE_VTCAM_IFACE_UNBIND = 0x561,\n\n\tPRESTERA_CMD_TYPE_ROUTER_RIF_CREATE = 0x600,\n\tPRESTERA_CMD_TYPE_ROUTER_RIF_DELETE = 0x601,\n\tPRESTERA_CMD_TYPE_ROUTER_LPM_ADD = 0x610,\n\tPRESTERA_CMD_TYPE_ROUTER_LPM_DELETE = 0x611,\n\tPRESTERA_CMD_TYPE_ROUTER_NH_GRP_SET = 0x622,\n\tPRESTERA_CMD_TYPE_ROUTER_NH_GRP_BLK_GET = 0x645,\n\tPRESTERA_CMD_TYPE_ROUTER_NH_GRP_ADD = 0x623,\n\tPRESTERA_CMD_TYPE_ROUTER_NH_GRP_DELETE = 0x624,\n\tPRESTERA_CMD_TYPE_ROUTER_VR_CREATE = 0x630,\n\tPRESTERA_CMD_TYPE_ROUTER_VR_DELETE = 0x631,\n\n\tPRESTERA_CMD_TYPE_FLOOD_DOMAIN_CREATE = 0x700,\n\tPRESTERA_CMD_TYPE_FLOOD_DOMAIN_DESTROY = 0x701,\n\tPRESTERA_CMD_TYPE_FLOOD_DOMAIN_PORTS_SET = 0x702,\n\tPRESTERA_CMD_TYPE_FLOOD_DOMAIN_PORTS_RESET = 0x703,\n\n\tPRESTERA_CMD_TYPE_MDB_CREATE = 0x704,\n\tPRESTERA_CMD_TYPE_MDB_DESTROY = 0x705,\n\n\tPRESTERA_CMD_TYPE_RXTX_INIT = 0x800,\n\n\tPRESTERA_CMD_TYPE_LAG_MEMBER_ADD = 0x900,\n\tPRESTERA_CMD_TYPE_LAG_MEMBER_DELETE = 0x901,\n\tPRESTERA_CMD_TYPE_LAG_MEMBER_ENABLE = 0x902,\n\tPRESTERA_CMD_TYPE_LAG_MEMBER_DISABLE = 0x903,\n\n\tPRESTERA_CMD_TYPE_STP_PORT_SET = 0x1000,\n\n\tPRESTERA_CMD_TYPE_SPAN_GET = 0x1100,\n\tPRESTERA_CMD_TYPE_SPAN_INGRESS_BIND = 0x1101,\n\tPRESTERA_CMD_TYPE_SPAN_INGRESS_UNBIND = 0x1102,\n\tPRESTERA_CMD_TYPE_SPAN_RELEASE = 0x1103,\n\tPRESTERA_CMD_TYPE_SPAN_EGRESS_BIND = 0x1104,\n\tPRESTERA_CMD_TYPE_SPAN_EGRESS_UNBIND = 0x1105,\n\n\tPRESTERA_CMD_TYPE_POLICER_CREATE = 0x1500,\n\tPRESTERA_CMD_TYPE_POLICER_RELEASE = 0x1501,\n\tPRESTERA_CMD_TYPE_POLICER_SET = 0x1502,\n\n\tPRESTERA_CMD_TYPE_CPU_CODE_COUNTERS_GET = 0x2000,\n\n\tPRESTERA_CMD_TYPE_ACK = 0x10000,\n\tPRESTERA_CMD_TYPE_MAX\n};\n\nenum {\n\tPRESTERA_CMD_PORT_ATTR_ADMIN_STATE = 1,\n\tPRESTERA_CMD_PORT_ATTR_MTU = 3,\n\tPRESTERA_CMD_PORT_ATTR_MAC = 4,\n\tPRESTERA_CMD_PORT_ATTR_SPEED = 5,\n\tPRESTERA_CMD_PORT_ATTR_ACCEPT_FRAME_TYPE = 6,\n\tPRESTERA_CMD_PORT_ATTR_LEARNING = 7,\n\tPRESTERA_CMD_PORT_ATTR_FLOOD = 8,\n\tPRESTERA_CMD_PORT_ATTR_CAPABILITY = 9,\n\tPRESTERA_CMD_PORT_ATTR_LOCKED = 10,\n\tPRESTERA_CMD_PORT_ATTR_PHY_MODE = 12,\n\tPRESTERA_CMD_PORT_ATTR_TYPE = 13,\n\tPRESTERA_CMD_PORT_ATTR_STATS = 17,\n\tPRESTERA_CMD_PORT_ATTR_MAC_AUTONEG_RESTART = 18,\n\tPRESTERA_CMD_PORT_ATTR_PHY_AUTONEG_RESTART = 19,\n\tPRESTERA_CMD_PORT_ATTR_MAC_MODE = 22,\n};\n\nenum {\n\tPRESTERA_CMD_SWITCH_ATTR_MAC = 1,\n\tPRESTERA_CMD_SWITCH_ATTR_AGEING = 2,\n};\n\nenum {\n\tPRESTERA_CMD_ACK_OK,\n\tPRESTERA_CMD_ACK_FAILED,\n\n\tPRESTERA_CMD_ACK_MAX\n};\n\nenum {\n\tPRESTERA_PORT_TP_NA,\n\tPRESTERA_PORT_TP_MDI,\n\tPRESTERA_PORT_TP_MDIX,\n\tPRESTERA_PORT_TP_AUTO,\n};\n\nenum {\n\tPRESTERA_PORT_FLOOD_TYPE_UC = 0,\n\tPRESTERA_PORT_FLOOD_TYPE_MC = 1,\n};\n\nenum {\n\tPRESTERA_PORT_GOOD_OCTETS_RCV_CNT,\n\tPRESTERA_PORT_BAD_OCTETS_RCV_CNT,\n\tPRESTERA_PORT_MAC_TRANSMIT_ERR_CNT,\n\tPRESTERA_PORT_BRDC_PKTS_RCV_CNT,\n\tPRESTERA_PORT_MC_PKTS_RCV_CNT,\n\tPRESTERA_PORT_PKTS_64L_CNT,\n\tPRESTERA_PORT_PKTS_65TO127L_CNT,\n\tPRESTERA_PORT_PKTS_128TO255L_CNT,\n\tPRESTERA_PORT_PKTS_256TO511L_CNT,\n\tPRESTERA_PORT_PKTS_512TO1023L_CNT,\n\tPRESTERA_PORT_PKTS_1024TOMAXL_CNT,\n\tPRESTERA_PORT_EXCESSIVE_COLLISIONS_CNT,\n\tPRESTERA_PORT_MC_PKTS_SENT_CNT,\n\tPRESTERA_PORT_BRDC_PKTS_SENT_CNT,\n\tPRESTERA_PORT_FC_SENT_CNT,\n\tPRESTERA_PORT_GOOD_FC_RCV_CNT,\n\tPRESTERA_PORT_DROP_EVENTS_CNT,\n\tPRESTERA_PORT_UNDERSIZE_PKTS_CNT,\n\tPRESTERA_PORT_FRAGMENTS_PKTS_CNT,\n\tPRESTERA_PORT_OVERSIZE_PKTS_CNT,\n\tPRESTERA_PORT_JABBER_PKTS_CNT,\n\tPRESTERA_PORT_MAC_RCV_ERROR_CNT,\n\tPRESTERA_PORT_BAD_CRC_CNT,\n\tPRESTERA_PORT_COLLISIONS_CNT,\n\tPRESTERA_PORT_LATE_COLLISIONS_CNT,\n\tPRESTERA_PORT_GOOD_UC_PKTS_RCV_CNT,\n\tPRESTERA_PORT_GOOD_UC_PKTS_SENT_CNT,\n\tPRESTERA_PORT_MULTIPLE_PKTS_SENT_CNT,\n\tPRESTERA_PORT_DEFERRED_PKTS_SENT_CNT,\n\tPRESTERA_PORT_GOOD_OCTETS_SENT_CNT,\n\n\tPRESTERA_PORT_CNT_MAX\n};\n\nenum {\n\tPRESTERA_FC_NONE,\n\tPRESTERA_FC_SYMMETRIC,\n\tPRESTERA_FC_ASYMMETRIC,\n\tPRESTERA_FC_SYMM_ASYMM,\n};\n\nenum {\n\tPRESTERA_POLICER_MODE_SR_TCM\n};\n\nenum {\n\tPRESTERA_HW_FDB_ENTRY_TYPE_REG_PORT = 0,\n\tPRESTERA_HW_FDB_ENTRY_TYPE_LAG = 1,\n\tPRESTERA_HW_FDB_ENTRY_TYPE_MAX = 2,\n};\n\nstruct prestera_fw_event_handler {\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n\tenum prestera_event_type type;\n\tprestera_event_cb_t func;\n\tvoid *arg;\n};\n\nenum {\n\tPRESTERA_HW_FLOOD_DOMAIN_PORT_TYPE_REG_PORT = 0,\n\tPRESTERA_HW_FLOOD_DOMAIN_PORT_TYPE_LAG = 1,\n\tPRESTERA_HW_FLOOD_DOMAIN_PORT_TYPE_MAX = 2,\n};\n\nstruct prestera_msg_cmd {\n\t__le32 type;\n};\n\nstruct prestera_msg_ret {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 status;\n};\n\nstruct prestera_msg_common_req {\n\tstruct prestera_msg_cmd cmd;\n};\n\nstruct prestera_msg_common_resp {\n\tstruct prestera_msg_ret ret;\n};\n\nstruct prestera_msg_switch_attr_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 attr;\n\tunion {\n\t\t__le32 ageing_timeout_ms;\n\t\tstruct {\n\t\t\tu8 mac[ETH_ALEN];\n\t\t\tu8 __pad[2];\n\t\t};\n\t} param;\n};\n\nstruct prestera_msg_switch_init_resp {\n\tstruct prestera_msg_ret ret;\n\t__le32 port_count;\n\t__le32 mtu_max;\n\t__le32 size_tbl_router_nexthop;\n\tu8 switch_id;\n\tu8 lag_max;\n\tu8 lag_member_max;\n};\n\nstruct prestera_msg_event_port_param {\n\tunion {\n\t\tstruct {\n\t\t\t__le32 mode;\n\t\t\t__le32 speed;\n\t\t\tu8 oper;\n\t\t\tu8 duplex;\n\t\t\tu8 fc;\n\t\t\tu8 fec;\n\t\t} mac;\n\t\tstruct {\n\t\t\t__le64 lmode_bmap;\n\t\t\tu8 mdix;\n\t\t\tu8 fc;\n\t\t\tu8 __pad[2];\n\t\t} __packed phy;  \n\t};\n};\n\nstruct prestera_msg_port_cap_param {\n\t__le64 link_mode;\n\tu8 type;\n\tu8 fec;\n\tu8 fc;\n\tu8 transceiver;\n};\n\nstruct prestera_msg_port_flood_param {\n\tu8 type;\n\tu8 enable;\n\tu8 __pad[2];\n};\n\nunion prestera_msg_port_param {\n\t__le32 mtu;\n\t__le32 speed;\n\t__le32 link_mode;\n\tu8 admin_state;\n\tu8 oper_state;\n\tu8 mac[ETH_ALEN];\n\tu8 accept_frm_type;\n\tu8 learning;\n\tu8 flood;\n\tu8 type;\n\tu8 duplex;\n\tu8 fec;\n\tu8 fc;\n\tu8 br_locked;\n\tunion {\n\t\tstruct {\n\t\t\tu8 admin;\n\t\t\tu8 fc;\n\t\t\tu8 ap_enable;\n\t\t\tu8 __reserved[5];\n\t\t\tunion {\n\t\t\t\tstruct {\n\t\t\t\t\t__le32 mode;\n\t\t\t\t\t__le32 speed;\n\t\t\t\t\tu8 inband;\n\t\t\t\t\tu8 duplex;\n\t\t\t\t\tu8 fec;\n\t\t\t\t\tu8 fec_supp;\n\t\t\t\t} reg_mode;\n\t\t\t\tstruct {\n\t\t\t\t\t__le32 mode;\n\t\t\t\t\t__le32 speed;\n\t\t\t\t\tu8 fec;\n\t\t\t\t\tu8 fec_supp;\n\t\t\t\t\tu8 __pad[2];\n\t\t\t\t} ap_modes[PRESTERA_AP_PORT_MAX];\n\t\t\t};\n\t\t} mac;\n\t\tstruct {\n\t\t\t__le64 modes;\n\t\t\t__le32 mode;\n\t\t\tu8 admin;\n\t\t\tu8 adv_enable;\n\t\t\tu8 mdix;\n\t\t\tu8 __pad;\n\t\t} phy;\n\t} link;\n\n\tstruct prestera_msg_port_cap_param cap;\n\tstruct prestera_msg_port_flood_param flood_ext;\n\tstruct prestera_msg_event_port_param link_evt;\n};\n\nstruct prestera_msg_port_attr_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 attr;\n\t__le32 port;\n\t__le32 dev;\n\tunion prestera_msg_port_param param;\n};\n\nstruct prestera_msg_port_attr_resp {\n\tstruct prestera_msg_ret ret;\n\tunion prestera_msg_port_param param;\n};\n\nstruct prestera_msg_port_stats_resp {\n\tstruct prestera_msg_ret ret;\n\t__le64 stats[PRESTERA_PORT_CNT_MAX];\n};\n\nstruct prestera_msg_port_info_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 port;\n};\n\nstruct prestera_msg_port_info_resp {\n\tstruct prestera_msg_ret ret;\n\t__le32 hw_id;\n\t__le32 dev_id;\n\t__le16 fp_id;\n\tu8 pad[2];\n};\n\nstruct prestera_msg_vlan_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 port;\n\t__le32 dev;\n\t__le16 vid;\n\tu8 is_member;\n\tu8 is_tagged;\n};\n\nstruct prestera_msg_fdb_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 flush_mode;\n\tunion {\n\t\tstruct {\n\t\t\t__le32 port;\n\t\t\t__le32 dev;\n\t\t};\n\t\t__le16 lag_id;\n\t} dest;\n\t__le16 vid;\n\tu8 dest_type;\n\tu8 dynamic;\n\tu8 mac[ETH_ALEN];\n\tu8 __pad[2];\n};\n\nstruct prestera_msg_bridge_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 port;\n\t__le32 dev;\n\t__le16 bridge;\n\tu8 pad[2];\n};\n\nstruct prestera_msg_bridge_resp {\n\tstruct prestera_msg_ret ret;\n\t__le16 bridge;\n\tu8 pad[2];\n};\n\nstruct prestera_msg_vtcam_create_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 keymask[__PRESTERA_ACL_RULE_MATCH_TYPE_MAX];\n\tu8 direction;\n\tu8 lookup;\n\tu8 pad[2];\n};\n\nstruct prestera_msg_vtcam_destroy_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 vtcam_id;\n};\n\nstruct prestera_msg_vtcam_rule_add_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 key[__PRESTERA_ACL_RULE_MATCH_TYPE_MAX];\n\t__le32 keymask[__PRESTERA_ACL_RULE_MATCH_TYPE_MAX];\n\t__le32 vtcam_id;\n\t__le32 prio;\n\t__le32 n_act;\n};\n\nstruct prestera_msg_vtcam_rule_del_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 vtcam_id;\n\t__le32 id;\n};\n\nstruct prestera_msg_vtcam_bind_req {\n\tstruct prestera_msg_cmd cmd;\n\tunion {\n\t\tstruct {\n\t\t\t__le32 hw_id;\n\t\t\t__le32 dev_id;\n\t\t} port;\n\t\t__le32 index;\n\t};\n\t__le32 vtcam_id;\n\t__le16 pcl_id;\n\t__le16 type;\n};\n\nstruct prestera_msg_vtcam_resp {\n\tstruct prestera_msg_ret ret;\n\t__le32 vtcam_id;\n\t__le32 rule_id;\n};\n\nstruct prestera_msg_acl_action {\n\t__le32 id;\n\t__le32 __reserved;\n\tunion {\n\t\tstruct {\n\t\t\t__le32 index;\n\t\t} jump;\n\t\tstruct {\n\t\t\t__le32 id;\n\t\t} police;\n\t\tstruct {\n\t\t\t__le32 id;\n\t\t} count;\n\t\t__le32 reserved[6];\n\t};\n};\n\nstruct prestera_msg_counter_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 client;\n\t__le32 block_id;\n\t__le32 num_counters;\n};\n\nstruct prestera_msg_counter_stats {\n\t__le64 packets;\n\t__le64 bytes;\n};\n\nstruct prestera_msg_counter_resp {\n\tstruct prestera_msg_ret ret;\n\t__le32 block_id;\n\t__le32 offset;\n\t__le32 num_counters;\n\t__le32 done;\n\tstruct prestera_msg_counter_stats stats[];\n};\n\nstruct prestera_msg_span_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 port;\n\t__le32 dev;\n\tu8 id;\n\tu8 pad[3];\n};\n\nstruct prestera_msg_span_resp {\n\tstruct prestera_msg_ret ret;\n\tu8 id;\n\tu8 pad[3];\n};\n\nstruct prestera_msg_stp_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 port;\n\t__le32 dev;\n\t__le16 vid;\n\tu8 state;\n\tu8 __pad;\n};\n\nstruct prestera_msg_rxtx_req {\n\tstruct prestera_msg_cmd cmd;\n\tu8 use_sdma;\n\tu8 pad[3];\n};\n\nstruct prestera_msg_rxtx_resp {\n\tstruct prestera_msg_ret ret;\n\t__le32 map_addr;\n};\n\nstruct prestera_msg_iface {\n\tunion {\n\t\tstruct {\n\t\t\t__le32 dev;\n\t\t\t__le32 port;\n\t\t};\n\t\t__le16 lag_id;\n\t};\n\t__le16 vr_id;\n\t__le16 vid;\n\tu8 type;\n\tu8 __pad[3];\n};\n\nstruct prestera_msg_ip_addr {\n\tunion {\n\t\t__be32 ipv4;\n\t\t__be32 ipv6[4];\n\t} u;\n\tu8 v;  \n\tu8 __pad[3];\n};\n\nstruct prestera_msg_nh {\n\tstruct prestera_msg_iface oif;\n\t__le32 hw_id;\n\tu8 mac[ETH_ALEN];\n\tu8 is_active;\n\tu8 pad;\n};\n\nstruct prestera_msg_rif_req {\n\tstruct prestera_msg_cmd cmd;\n\tstruct prestera_msg_iface iif;\n\t__le32 mtu;\n\t__le16 rif_id;\n\t__le16 __reserved;\n\tu8 mac[ETH_ALEN];\n\tu8 __pad[2];\n};\n\nstruct prestera_msg_rif_resp {\n\tstruct prestera_msg_ret ret;\n\t__le16 rif_id;\n\tu8 __pad[2];\n};\n\nstruct prestera_msg_lpm_req {\n\tstruct prestera_msg_cmd cmd;\n\tstruct prestera_msg_ip_addr dst;\n\t__le32 grp_id;\n\t__le32 dst_len;\n\t__le16 vr_id;\n\tu8 __pad[2];\n};\n\nstruct prestera_msg_nh_req {\n\tstruct prestera_msg_cmd cmd;\n\tstruct prestera_msg_nh nh[PRESTERA_NHGR_SIZE_MAX];\n\t__le32 size;\n\t__le32 grp_id;\n};\n\nstruct prestera_msg_nh_chunk_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 offset;\n};\n\nstruct prestera_msg_nh_chunk_resp {\n\tstruct prestera_msg_ret ret;\n\tu8 hw_state[PRESTERA_MSG_CHUNK_SIZE];\n};\n\nstruct prestera_msg_nh_grp_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 grp_id;\n\t__le32 size;\n};\n\nstruct prestera_msg_nh_grp_resp {\n\tstruct prestera_msg_ret ret;\n\t__le32 grp_id;\n};\n\nstruct prestera_msg_vr_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le16 vr_id;\n\tu8 __pad[2];\n};\n\nstruct prestera_msg_vr_resp {\n\tstruct prestera_msg_ret ret;\n\t__le16 vr_id;\n\tu8 __pad[2];\n};\n\nstruct prestera_msg_lag_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 port;\n\t__le32 dev;\n\t__le16 lag_id;\n\tu8 pad[2];\n};\n\nstruct prestera_msg_cpu_code_counter_req {\n\tstruct prestera_msg_cmd cmd;\n\tu8 counter_type;\n\tu8 code;\n\tu8 pad[2];\n};\n\nstruct mvsw_msg_cpu_code_counter_ret {\n\tstruct prestera_msg_ret ret;\n\t__le64 packet_count;\n};\n\nstruct prestera_msg_policer_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 id;\n\tunion {\n\t\tstruct {\n\t\t\t__le64 cir;\n\t\t\t__le32 cbs;\n\t\t} __packed sr_tcm;  \n\t\t__le32 reserved[6];\n\t};\n\tu8 mode;\n\tu8 type;\n\tu8 pad[2];\n};\n\nstruct prestera_msg_policer_resp {\n\tstruct prestera_msg_ret ret;\n\t__le32 id;\n};\n\nstruct prestera_msg_event {\n\t__le16 type;\n\t__le16 id;\n};\n\nstruct prestera_msg_event_port {\n\tstruct prestera_msg_event id;\n\t__le32 port_id;\n\tstruct prestera_msg_event_port_param param;\n};\n\nunion prestera_msg_event_fdb_param {\n\tu8 mac[ETH_ALEN];\n};\n\nstruct prestera_msg_event_fdb {\n\tstruct prestera_msg_event id;\n\t__le32 vid;\n\tunion {\n\t\t__le32 port_id;\n\t\t__le16 lag_id;\n\t} dest;\n\tunion prestera_msg_event_fdb_param param;\n\tu8 dest_type;\n};\n\nstruct prestera_msg_flood_domain_create_req {\n\tstruct prestera_msg_cmd cmd;\n};\n\nstruct prestera_msg_flood_domain_create_resp {\n\tstruct prestera_msg_ret ret;\n\t__le32 flood_domain_idx;\n};\n\nstruct prestera_msg_flood_domain_destroy_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 flood_domain_idx;\n};\n\nstruct prestera_msg_flood_domain_ports_set_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 flood_domain_idx;\n\t__le32 ports_num;\n};\n\nstruct prestera_msg_flood_domain_ports_reset_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 flood_domain_idx;\n};\n\nstruct prestera_msg_flood_domain_port {\n\tunion {\n\t\tstruct {\n\t\t\t__le32 port_num;\n\t\t\t__le32 dev_num;\n\t\t};\n\t\t__le16 lag_id;\n\t};\n\t__le16 vid;\n\t__le16 port_type;\n};\n\nstruct prestera_msg_mdb_create_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 flood_domain_idx;\n\t__le16 vid;\n\tu8 mac[ETH_ALEN];\n};\n\nstruct prestera_msg_mdb_destroy_req {\n\tstruct prestera_msg_cmd cmd;\n\t__le32 flood_domain_idx;\n\t__le16 vid;\n\tu8 mac[ETH_ALEN];\n};\n\nstatic void prestera_hw_build_tests(void)\n{\n\t \n\tBUILD_BUG_ON(sizeof(struct prestera_msg_common_req) != 4);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_switch_attr_req) != 16);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_port_attr_req) != 144);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_port_info_req) != 8);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_vlan_req) != 16);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_fdb_req) != 28);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_bridge_req) != 16);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_span_req) != 16);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_stp_req) != 16);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_rxtx_req) != 8);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_lag_req) != 16);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_cpu_code_counter_req) != 8);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_create_req) != 84);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_destroy_req) != 8);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_rule_add_req) != 168);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_rule_del_req) != 12);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_bind_req) != 20);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_acl_action) != 32);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_counter_req) != 16);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_counter_stats) != 16);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_rif_req) != 36);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_vr_req) != 8);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_lpm_req) != 36);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_policer_req) != 36);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_flood_domain_create_req) != 4);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_flood_domain_destroy_req) != 8);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_flood_domain_ports_set_req) != 12);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_flood_domain_ports_reset_req) != 8);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_mdb_create_req) != 16);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_mdb_destroy_req) != 16);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_nh_req) != 124);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_nh_chunk_req) != 8);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_nh_grp_req) != 12);\n\n\t \n\tBUILD_BUG_ON(sizeof(struct prestera_msg_iface) != 16);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_ip_addr) != 20);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_flood_domain_port) != 12);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_nh) != 28);\n\n\t \n\tBUILD_BUG_ON(sizeof(struct prestera_msg_common_resp) != 8);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_switch_init_resp) != 24);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_port_attr_resp) != 136);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_port_stats_resp) != 248);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_port_info_resp) != 20);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_bridge_resp) != 12);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_span_resp) != 12);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_rxtx_resp) != 12);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_vtcam_resp) != 16);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_counter_resp) != 24);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_rif_resp) != 12);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_vr_resp) != 12);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_policer_resp) != 12);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_flood_domain_create_resp) != 12);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_nh_chunk_resp) != 1032);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_nh_grp_resp) != 12);\n\n\t \n\tBUILD_BUG_ON(sizeof(struct prestera_msg_event_port) != 20);\n\tBUILD_BUG_ON(sizeof(struct prestera_msg_event_fdb) != 20);\n}\n\nstatic u8 prestera_hw_mdix_to_eth(u8 mode);\nstatic void prestera_hw_remote_fc_to_eth(u8 fc, bool *pause, bool *asym_pause);\n\nstatic int __prestera_cmd_ret(struct prestera_switch *sw,\n\t\t\t      enum prestera_cmd_type_t type,\n\t\t\t      struct prestera_msg_cmd *cmd, size_t clen,\n\t\t\t      struct prestera_msg_ret *ret, size_t rlen,\n\t\t\t      int waitms)\n{\n\tstruct prestera_device *dev = sw->dev;\n\tint err;\n\n\tcmd->type = __cpu_to_le32(type);\n\n\terr = dev->send_req(dev, 0, cmd, clen, ret, rlen, waitms);\n\tif (err)\n\t\treturn err;\n\n\tif (ret->cmd.type != __cpu_to_le32(PRESTERA_CMD_TYPE_ACK))\n\t\treturn -EBADE;\n\tif (ret->status != __cpu_to_le32(PRESTERA_CMD_ACK_OK))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int prestera_cmd_ret(struct prestera_switch *sw,\n\t\t\t    enum prestera_cmd_type_t type,\n\t\t\t    struct prestera_msg_cmd *cmd, size_t clen,\n\t\t\t    struct prestera_msg_ret *ret, size_t rlen)\n{\n\treturn __prestera_cmd_ret(sw, type, cmd, clen, ret, rlen, 0);\n}\n\nstatic int prestera_cmd_ret_wait(struct prestera_switch *sw,\n\t\t\t\t enum prestera_cmd_type_t type,\n\t\t\t\t struct prestera_msg_cmd *cmd, size_t clen,\n\t\t\t\t struct prestera_msg_ret *ret, size_t rlen,\n\t\t\t\t int waitms)\n{\n\treturn __prestera_cmd_ret(sw, type, cmd, clen, ret, rlen, waitms);\n}\n\nstatic int prestera_cmd(struct prestera_switch *sw,\n\t\t\tenum prestera_cmd_type_t type,\n\t\t\tstruct prestera_msg_cmd *cmd, size_t clen)\n{\n\tstruct prestera_msg_common_resp resp;\n\n\treturn prestera_cmd_ret(sw, type, cmd, clen, &resp.ret, sizeof(resp));\n}\n\nstatic int prestera_fw_parse_port_evt(void *msg, struct prestera_event *evt)\n{\n\tstruct prestera_msg_event_port *hw_evt;\n\n\thw_evt = (struct prestera_msg_event_port *)msg;\n\n\tevt->port_evt.port_id = __le32_to_cpu(hw_evt->port_id);\n\n\tif (evt->id == PRESTERA_PORT_EVENT_MAC_STATE_CHANGED) {\n\t\tevt->port_evt.data.mac.oper = hw_evt->param.mac.oper;\n\t\tevt->port_evt.data.mac.mode =\n\t\t\t__le32_to_cpu(hw_evt->param.mac.mode);\n\t\tevt->port_evt.data.mac.speed =\n\t\t\t__le32_to_cpu(hw_evt->param.mac.speed);\n\t\tevt->port_evt.data.mac.duplex = hw_evt->param.mac.duplex;\n\t\tevt->port_evt.data.mac.fc = hw_evt->param.mac.fc;\n\t\tevt->port_evt.data.mac.fec = hw_evt->param.mac.fec;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int prestera_fw_parse_fdb_evt(void *msg, struct prestera_event *evt)\n{\n\tstruct prestera_msg_event_fdb *hw_evt = msg;\n\n\tswitch (hw_evt->dest_type) {\n\tcase PRESTERA_HW_FDB_ENTRY_TYPE_REG_PORT:\n\t\tevt->fdb_evt.type = PRESTERA_FDB_ENTRY_TYPE_REG_PORT;\n\t\tevt->fdb_evt.dest.port_id = __le32_to_cpu(hw_evt->dest.port_id);\n\t\tbreak;\n\tcase PRESTERA_HW_FDB_ENTRY_TYPE_LAG:\n\t\tevt->fdb_evt.type = PRESTERA_FDB_ENTRY_TYPE_LAG;\n\t\tevt->fdb_evt.dest.lag_id = __le16_to_cpu(hw_evt->dest.lag_id);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tevt->fdb_evt.vid = __le32_to_cpu(hw_evt->vid);\n\n\tether_addr_copy(evt->fdb_evt.data.mac, hw_evt->param.mac);\n\n\treturn 0;\n}\n\nstatic struct prestera_fw_evt_parser {\n\tint (*func)(void *msg, struct prestera_event *evt);\n} fw_event_parsers[PRESTERA_EVENT_TYPE_MAX] = {\n\t[PRESTERA_EVENT_TYPE_PORT] = { .func = prestera_fw_parse_port_evt },\n\t[PRESTERA_EVENT_TYPE_FDB] = { .func = prestera_fw_parse_fdb_evt },\n};\n\nstatic struct prestera_fw_event_handler *\n__find_event_handler(const struct prestera_switch *sw,\n\t\t     enum prestera_event_type type)\n{\n\tstruct prestera_fw_event_handler *eh;\n\n\tlist_for_each_entry_rcu(eh, &sw->event_handlers, list) {\n\t\tif (eh->type == type)\n\t\t\treturn eh;\n\t}\n\n\treturn NULL;\n}\n\nstatic int prestera_find_event_handler(const struct prestera_switch *sw,\n\t\t\t\t       enum prestera_event_type type,\n\t\t\t\t       struct prestera_fw_event_handler *eh)\n{\n\tstruct prestera_fw_event_handler *tmp;\n\tint err = 0;\n\n\trcu_read_lock();\n\ttmp = __find_event_handler(sw, type);\n\tif (tmp)\n\t\t*eh = *tmp;\n\telse\n\t\terr = -ENOENT;\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic int prestera_evt_recv(struct prestera_device *dev, void *buf, size_t size)\n{\n\tstruct prestera_switch *sw = dev->priv;\n\tstruct prestera_msg_event *msg = buf;\n\tstruct prestera_fw_event_handler eh;\n\tstruct prestera_event evt;\n\tu16 msg_type;\n\tint err;\n\n\tmsg_type = __le16_to_cpu(msg->type);\n\tif (msg_type >= PRESTERA_EVENT_TYPE_MAX)\n\t\treturn -EINVAL;\n\tif (!fw_event_parsers[msg_type].func)\n\t\treturn -ENOENT;\n\n\terr = prestera_find_event_handler(sw, msg_type, &eh);\n\tif (err)\n\t\treturn err;\n\n\tevt.id = __le16_to_cpu(msg->id);\n\n\terr = fw_event_parsers[msg_type].func(buf, &evt);\n\tif (err)\n\t\treturn err;\n\n\teh.func(sw, &evt, eh.arg);\n\n\treturn 0;\n}\n\nstatic void prestera_pkt_recv(struct prestera_device *dev)\n{\n\tstruct prestera_switch *sw = dev->priv;\n\tstruct prestera_fw_event_handler eh;\n\tstruct prestera_event ev;\n\tint err;\n\n\tev.id = PRESTERA_RXTX_EVENT_RCV_PKT;\n\n\terr = prestera_find_event_handler(sw, PRESTERA_EVENT_TYPE_RXTX, &eh);\n\tif (err)\n\t\treturn;\n\n\teh.func(sw, &ev, eh.arg);\n}\n\nstatic u8 prestera_hw_mdix_to_eth(u8 mode)\n{\n\tswitch (mode) {\n\tcase PRESTERA_PORT_TP_MDI:\n\t\treturn ETH_TP_MDI;\n\tcase PRESTERA_PORT_TP_MDIX:\n\t\treturn ETH_TP_MDI_X;\n\tcase PRESTERA_PORT_TP_AUTO:\n\t\treturn ETH_TP_MDI_AUTO;\n\tdefault:\n\t\treturn ETH_TP_MDI_INVALID;\n\t}\n}\n\nstatic u8 prestera_hw_mdix_from_eth(u8 mode)\n{\n\tswitch (mode) {\n\tcase ETH_TP_MDI:\n\t\treturn PRESTERA_PORT_TP_MDI;\n\tcase ETH_TP_MDI_X:\n\t\treturn PRESTERA_PORT_TP_MDIX;\n\tcase ETH_TP_MDI_AUTO:\n\t\treturn PRESTERA_PORT_TP_AUTO;\n\tdefault:\n\t\treturn PRESTERA_PORT_TP_NA;\n\t}\n}\n\nint prestera_hw_port_info_get(const struct prestera_port *port,\n\t\t\t      u32 *dev_id, u32 *hw_id, u16 *fp_id)\n{\n\tstruct prestera_msg_port_info_req req = {\n\t\t.port = __cpu_to_le32(port->id),\n\t};\n\tstruct prestera_msg_port_info_resp resp;\n\tint err;\n\n\terr = prestera_cmd_ret(port->sw, PRESTERA_CMD_TYPE_PORT_INFO_GET,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\t*dev_id = __le32_to_cpu(resp.dev_id);\n\t*hw_id = __le32_to_cpu(resp.hw_id);\n\t*fp_id = __le16_to_cpu(resp.fp_id);\n\n\treturn 0;\n}\n\nint prestera_hw_switch_mac_set(struct prestera_switch *sw, const char *mac)\n{\n\tstruct prestera_msg_switch_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_SWITCH_ATTR_MAC),\n\t};\n\n\tether_addr_copy(req.param.mac, mac);\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_SWITCH_ATTR_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_switch_init(struct prestera_switch *sw)\n{\n\tstruct prestera_msg_switch_init_resp resp;\n\tstruct prestera_msg_common_req req;\n\tint err;\n\n\tINIT_LIST_HEAD(&sw->event_handlers);\n\n\tprestera_hw_build_tests();\n\n\terr = prestera_cmd_ret_wait(sw, PRESTERA_CMD_TYPE_SWITCH_INIT,\n\t\t\t\t    &req.cmd, sizeof(req),\n\t\t\t\t    &resp.ret, sizeof(resp),\n\t\t\t\t    PRESTERA_SWITCH_INIT_TIMEOUT_MS);\n\tif (err)\n\t\treturn err;\n\n\tsw->dev->recv_msg = prestera_evt_recv;\n\tsw->dev->recv_pkt = prestera_pkt_recv;\n\tsw->port_count = __le32_to_cpu(resp.port_count);\n\tsw->mtu_min = PRESTERA_MIN_MTU;\n\tsw->mtu_max = __le32_to_cpu(resp.mtu_max);\n\tsw->id = resp.switch_id;\n\tsw->lag_member_max = resp.lag_member_max;\n\tsw->lag_max = resp.lag_max;\n\tsw->size_tbl_router_nexthop =\n\t\t__le32_to_cpu(resp.size_tbl_router_nexthop);\n\n\treturn 0;\n}\n\nvoid prestera_hw_switch_fini(struct prestera_switch *sw)\n{\n\tWARN_ON(!list_empty(&sw->event_handlers));\n}\n\nint prestera_hw_switch_ageing_set(struct prestera_switch *sw, u32 ageing_ms)\n{\n\tstruct prestera_msg_switch_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_SWITCH_ATTR_AGEING),\n\t\t.param = {\n\t\t\t.ageing_timeout_ms = __cpu_to_le32(ageing_ms),\n\t\t},\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_SWITCH_ATTR_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_port_mac_mode_get(const struct prestera_port *port,\n\t\t\t\t  u32 *mode, u32 *speed, u8 *duplex, u8 *fec)\n{\n\tstruct prestera_msg_port_attr_resp resp;\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_MAC_MODE),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id)\n\t};\n\tint err;\n\n\terr = prestera_cmd_ret(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_GET,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\tif (mode)\n\t\t*mode = __le32_to_cpu(resp.param.link_evt.mac.mode);\n\n\tif (speed)\n\t\t*speed = __le32_to_cpu(resp.param.link_evt.mac.speed);\n\n\tif (duplex)\n\t\t*duplex = resp.param.link_evt.mac.duplex;\n\n\tif (fec)\n\t\t*fec = resp.param.link_evt.mac.fec;\n\n\treturn err;\n}\n\nint prestera_hw_port_mac_mode_set(const struct prestera_port *port,\n\t\t\t\t  bool admin, u32 mode, u8 inband,\n\t\t\t\t  u32 speed, u8 duplex, u8 fec)\n{\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_MAC_MODE),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.param = {\n\t\t\t.link = {\n\t\t\t\t.mac = {\n\t\t\t\t\t.admin = admin,\n\t\t\t\t\t.reg_mode.mode = __cpu_to_le32(mode),\n\t\t\t\t\t.reg_mode.inband = inband,\n\t\t\t\t\t.reg_mode.speed = __cpu_to_le32(speed),\n\t\t\t\t\t.reg_mode.duplex = duplex,\n\t\t\t\t\t.reg_mode.fec = fec\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_port_phy_mode_get(const struct prestera_port *port,\n\t\t\t\t  u8 *mdix, u64 *lmode_bmap,\n\t\t\t\t  bool *fc_pause, bool *fc_asym)\n{\n\tstruct prestera_msg_port_attr_resp resp;\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_PHY_MODE),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id)\n\t};\n\tint err;\n\n\terr = prestera_cmd_ret(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_GET,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\tif (mdix)\n\t\t*mdix = prestera_hw_mdix_to_eth(resp.param.link_evt.phy.mdix);\n\n\tif (lmode_bmap)\n\t\t*lmode_bmap = __le64_to_cpu(resp.param.link_evt.phy.lmode_bmap);\n\n\tif (fc_pause && fc_asym)\n\t\tprestera_hw_remote_fc_to_eth(resp.param.link_evt.phy.fc,\n\t\t\t\t\t     fc_pause, fc_asym);\n\n\treturn err;\n}\n\nint prestera_hw_port_phy_mode_set(const struct prestera_port *port,\n\t\t\t\t  bool admin, bool adv, u32 mode, u64 modes,\n\t\t\t\t  u8 mdix)\n{\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_PHY_MODE),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.param = {\n\t\t\t.link = {\n\t\t\t\t.phy = {\n\t\t\t\t\t.admin = admin,\n\t\t\t\t\t.adv_enable = adv ? 1 : 0,\n\t\t\t\t\t.mode = __cpu_to_le32(mode),\n\t\t\t\t\t.modes = __cpu_to_le64(modes),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\treq.param.link.phy.mdix = prestera_hw_mdix_from_eth(mdix);\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_port_mtu_set(const struct prestera_port *port, u32 mtu)\n{\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_MTU),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.param = {\n\t\t\t.mtu = __cpu_to_le32(mtu),\n\t\t}\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_port_mac_set(const struct prestera_port *port, const char *mac)\n{\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_MAC),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t};\n\n\tether_addr_copy(req.param.mac, mac);\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_port_accept_frm_type(struct prestera_port *port,\n\t\t\t\t     enum prestera_accept_frm_type type)\n{\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_ACCEPT_FRAME_TYPE),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.param = {\n\t\t\t.accept_frm_type = type,\n\t\t}\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_port_cap_get(const struct prestera_port *port,\n\t\t\t     struct prestera_port_caps *caps)\n{\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_CAPABILITY),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t};\n\tstruct prestera_msg_port_attr_resp resp;\n\tint err;\n\n\terr = prestera_cmd_ret(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_GET,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\tcaps->supp_link_modes = __le64_to_cpu(resp.param.cap.link_mode);\n\tcaps->transceiver = resp.param.cap.transceiver;\n\tcaps->supp_fec = resp.param.cap.fec;\n\tcaps->type = resp.param.cap.type;\n\n\treturn err;\n}\n\nstatic void prestera_hw_remote_fc_to_eth(u8 fc, bool *pause, bool *asym_pause)\n{\n\tswitch (fc) {\n\tcase PRESTERA_FC_SYMMETRIC:\n\t\t*pause = true;\n\t\t*asym_pause = false;\n\t\tbreak;\n\tcase PRESTERA_FC_ASYMMETRIC:\n\t\t*pause = false;\n\t\t*asym_pause = true;\n\t\tbreak;\n\tcase PRESTERA_FC_SYMM_ASYMM:\n\t\t*pause = true;\n\t\t*asym_pause = true;\n\t\tbreak;\n\tdefault:\n\t\t*pause = false;\n\t\t*asym_pause = false;\n\t}\n}\n\nint prestera_hw_vtcam_create(struct prestera_switch *sw,\n\t\t\t     u8 lookup, const u32 *keymask, u32 *vtcam_id,\n\t\t\t     enum prestera_hw_vtcam_direction_t dir)\n{\n\tint err;\n\tstruct prestera_msg_vtcam_resp resp;\n\tstruct prestera_msg_vtcam_create_req req = {\n\t\t.lookup = lookup,\n\t\t.direction = dir,\n\t};\n\n\tif (keymask)\n\t\tmemcpy(req.keymask, keymask, sizeof(req.keymask));\n\telse\n\t\tmemset(req.keymask, 0, sizeof(req.keymask));\n\n\terr = prestera_cmd_ret(sw, PRESTERA_CMD_TYPE_VTCAM_CREATE,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\t*vtcam_id = __le32_to_cpu(resp.vtcam_id);\n\treturn 0;\n}\n\nint prestera_hw_vtcam_destroy(struct prestera_switch *sw, u32 vtcam_id)\n{\n\tstruct prestera_msg_vtcam_destroy_req req = {\n\t\t.vtcam_id = __cpu_to_le32(vtcam_id),\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_VTCAM_DESTROY,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nstatic int\nprestera_acl_rule_add_put_action(struct prestera_msg_acl_action *action,\n\t\t\t\t struct prestera_acl_hw_action_info *info)\n{\n\taction->id = __cpu_to_le32(info->id);\n\n\tswitch (info->id) {\n\tcase PRESTERA_ACL_RULE_ACTION_ACCEPT:\n\tcase PRESTERA_ACL_RULE_ACTION_DROP:\n\tcase PRESTERA_ACL_RULE_ACTION_TRAP:\n\t\t \n\t\tbreak;\n\tcase PRESTERA_ACL_RULE_ACTION_JUMP:\n\t\taction->jump.index = __cpu_to_le32(info->jump.index);\n\t\tbreak;\n\tcase PRESTERA_ACL_RULE_ACTION_POLICE:\n\t\taction->police.id = __cpu_to_le32(info->police.id);\n\t\tbreak;\n\tcase PRESTERA_ACL_RULE_ACTION_COUNT:\n\t\taction->count.id = __cpu_to_le32(info->count.id);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint prestera_hw_vtcam_rule_add(struct prestera_switch *sw,\n\t\t\t       u32 vtcam_id, u32 prio, void *key, void *keymask,\n\t\t\t       struct prestera_acl_hw_action_info *act,\n\t\t\t       u8 n_act, u32 *rule_id)\n{\n\tstruct prestera_msg_acl_action *actions_msg;\n\tstruct prestera_msg_vtcam_rule_add_req *req;\n\tstruct prestera_msg_vtcam_resp resp;\n\tvoid *buff;\n\tu32 size;\n\tint err;\n\tu8 i;\n\n\tsize = sizeof(*req) + sizeof(*actions_msg) * n_act;\n\n\tbuff = kzalloc(size, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\treq = buff;\n\treq->n_act = __cpu_to_le32(n_act);\n\tactions_msg = buff + sizeof(*req);\n\n\t \n\tmemcpy(req->key, key, sizeof(req->key));\n\tmemcpy(req->keymask, keymask, sizeof(req->keymask));\n\n\t \n\tfor (i = 0; i < n_act; i++) {\n\t\terr = prestera_acl_rule_add_put_action(&actions_msg[i],\n\t\t\t\t\t\t       &act[i]);\n\t\tif (err)\n\t\t\tgoto free_buff;\n\t}\n\n\treq->vtcam_id = __cpu_to_le32(vtcam_id);\n\treq->prio = __cpu_to_le32(prio);\n\n\terr = prestera_cmd_ret(sw, PRESTERA_CMD_TYPE_VTCAM_RULE_ADD,\n\t\t\t       &req->cmd, size, &resp.ret, sizeof(resp));\n\tif (err)\n\t\tgoto free_buff;\n\n\t*rule_id = __le32_to_cpu(resp.rule_id);\nfree_buff:\n\tkfree(buff);\n\treturn err;\n}\n\nint prestera_hw_vtcam_rule_del(struct prestera_switch *sw,\n\t\t\t       u32 vtcam_id, u32 rule_id)\n{\n\tstruct prestera_msg_vtcam_rule_del_req req = {\n\t\t.vtcam_id = __cpu_to_le32(vtcam_id),\n\t\t.id = __cpu_to_le32(rule_id)\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_VTCAM_RULE_DELETE,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_vtcam_iface_bind(struct prestera_switch *sw,\n\t\t\t\t struct prestera_acl_iface *iface,\n\t\t\t\t u32 vtcam_id, u16 pcl_id)\n{\n\tstruct prestera_msg_vtcam_bind_req req = {\n\t\t.vtcam_id = __cpu_to_le32(vtcam_id),\n\t\t.type = __cpu_to_le16(iface->type),\n\t\t.pcl_id = __cpu_to_le16(pcl_id)\n\t};\n\n\tif (iface->type == PRESTERA_ACL_IFACE_TYPE_PORT) {\n\t\treq.port.dev_id = __cpu_to_le32(iface->port->dev_id);\n\t\treq.port.hw_id = __cpu_to_le32(iface->port->hw_id);\n\t} else {\n\t\treq.index = __cpu_to_le32(iface->index);\n\t}\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_VTCAM_IFACE_BIND,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_vtcam_iface_unbind(struct prestera_switch *sw,\n\t\t\t\t   struct prestera_acl_iface *iface,\n\t\t\t\t   u32 vtcam_id)\n{\n\tstruct prestera_msg_vtcam_bind_req req = {\n\t\t.vtcam_id = __cpu_to_le32(vtcam_id),\n\t\t.type = __cpu_to_le16(iface->type)\n\t};\n\n\tif (iface->type == PRESTERA_ACL_IFACE_TYPE_PORT) {\n\t\treq.port.dev_id = __cpu_to_le32(iface->port->dev_id);\n\t\treq.port.hw_id = __cpu_to_le32(iface->port->hw_id);\n\t} else {\n\t\treq.index = __cpu_to_le32(iface->index);\n\t}\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_VTCAM_IFACE_UNBIND,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_span_get(const struct prestera_port *port, u8 *span_id)\n{\n\tstruct prestera_msg_span_resp resp;\n\tstruct prestera_msg_span_req req = {\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t};\n\tint err;\n\n\terr = prestera_cmd_ret(port->sw, PRESTERA_CMD_TYPE_SPAN_GET,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\t*span_id = resp.id;\n\n\treturn 0;\n}\n\nint prestera_hw_span_bind(const struct prestera_port *port, u8 span_id,\n\t\t\t  bool ingress)\n{\n\tstruct prestera_msg_span_req req = {\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.id = span_id,\n\t};\n\tenum prestera_cmd_type_t cmd_type;\n\n\tif (ingress)\n\t\tcmd_type = PRESTERA_CMD_TYPE_SPAN_INGRESS_BIND;\n\telse\n\t\tcmd_type = PRESTERA_CMD_TYPE_SPAN_EGRESS_BIND;\n\n\treturn prestera_cmd(port->sw, cmd_type, &req.cmd, sizeof(req));\n\n}\n\nint prestera_hw_span_unbind(const struct prestera_port *port, bool ingress)\n{\n\tstruct prestera_msg_span_req req = {\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t};\n\tenum prestera_cmd_type_t cmd_type;\n\n\tif (ingress)\n\t\tcmd_type = PRESTERA_CMD_TYPE_SPAN_INGRESS_UNBIND;\n\telse\n\t\tcmd_type = PRESTERA_CMD_TYPE_SPAN_EGRESS_UNBIND;\n\n\treturn prestera_cmd(port->sw, cmd_type, &req.cmd, sizeof(req));\n}\n\nint prestera_hw_span_release(struct prestera_switch *sw, u8 span_id)\n{\n\tstruct prestera_msg_span_req req = {\n\t\t.id = span_id\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_SPAN_RELEASE,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_port_type_get(const struct prestera_port *port, u8 *type)\n{\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_TYPE),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t};\n\tstruct prestera_msg_port_attr_resp resp;\n\tint err;\n\n\terr = prestera_cmd_ret(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_GET,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\t*type = resp.param.type;\n\n\treturn 0;\n}\n\nint prestera_hw_port_speed_get(const struct prestera_port *port, u32 *speed)\n{\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_SPEED),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t};\n\tstruct prestera_msg_port_attr_resp resp;\n\tint err;\n\n\terr = prestera_cmd_ret(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_GET,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\t*speed = __le32_to_cpu(resp.param.speed);\n\n\treturn 0;\n}\n\nint prestera_hw_port_autoneg_restart(struct prestera_port *port)\n{\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr =\n\t\t    __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_PHY_AUTONEG_RESTART),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_port_stats_get(const struct prestera_port *port,\n\t\t\t       struct prestera_port_stats *st)\n{\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_STATS),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t};\n\tstruct prestera_msg_port_stats_resp resp;\n\t__le64 *hw = resp.stats;\n\tint err;\n\n\terr = prestera_cmd_ret(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_GET,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\tst->good_octets_received =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_GOOD_OCTETS_RCV_CNT]);\n\tst->bad_octets_received =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_BAD_OCTETS_RCV_CNT]);\n\tst->mac_trans_error =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_MAC_TRANSMIT_ERR_CNT]);\n\tst->broadcast_frames_received =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_BRDC_PKTS_RCV_CNT]);\n\tst->multicast_frames_received =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_MC_PKTS_RCV_CNT]);\n\tst->frames_64_octets = __le64_to_cpu(hw[PRESTERA_PORT_PKTS_64L_CNT]);\n\tst->frames_65_to_127_octets =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_PKTS_65TO127L_CNT]);\n\tst->frames_128_to_255_octets =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_PKTS_128TO255L_CNT]);\n\tst->frames_256_to_511_octets =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_PKTS_256TO511L_CNT]);\n\tst->frames_512_to_1023_octets =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_PKTS_512TO1023L_CNT]);\n\tst->frames_1024_to_max_octets =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_PKTS_1024TOMAXL_CNT]);\n\tst->excessive_collision =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_EXCESSIVE_COLLISIONS_CNT]);\n\tst->multicast_frames_sent =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_MC_PKTS_SENT_CNT]);\n\tst->broadcast_frames_sent =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_BRDC_PKTS_SENT_CNT]);\n\tst->fc_sent = __le64_to_cpu(hw[PRESTERA_PORT_FC_SENT_CNT]);\n\tst->fc_received = __le64_to_cpu(hw[PRESTERA_PORT_GOOD_FC_RCV_CNT]);\n\tst->buffer_overrun = __le64_to_cpu(hw[PRESTERA_PORT_DROP_EVENTS_CNT]);\n\tst->undersize = __le64_to_cpu(hw[PRESTERA_PORT_UNDERSIZE_PKTS_CNT]);\n\tst->fragments = __le64_to_cpu(hw[PRESTERA_PORT_FRAGMENTS_PKTS_CNT]);\n\tst->oversize = __le64_to_cpu(hw[PRESTERA_PORT_OVERSIZE_PKTS_CNT]);\n\tst->jabber = __le64_to_cpu(hw[PRESTERA_PORT_JABBER_PKTS_CNT]);\n\tst->rx_error_frame_received =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_MAC_RCV_ERROR_CNT]);\n\tst->bad_crc = __le64_to_cpu(hw[PRESTERA_PORT_BAD_CRC_CNT]);\n\tst->collisions = __le64_to_cpu(hw[PRESTERA_PORT_COLLISIONS_CNT]);\n\tst->late_collision =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_LATE_COLLISIONS_CNT]);\n\tst->unicast_frames_received =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_GOOD_UC_PKTS_RCV_CNT]);\n\tst->unicast_frames_sent =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_GOOD_UC_PKTS_SENT_CNT]);\n\tst->sent_multiple =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_MULTIPLE_PKTS_SENT_CNT]);\n\tst->sent_deferred =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_DEFERRED_PKTS_SENT_CNT]);\n\tst->good_octets_sent =\n\t\t__le64_to_cpu(hw[PRESTERA_PORT_GOOD_OCTETS_SENT_CNT]);\n\n\treturn 0;\n}\n\nint prestera_hw_port_learning_set(struct prestera_port *port, bool enable)\n{\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_LEARNING),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.param = {\n\t\t\t.learning = enable,\n\t\t}\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_port_uc_flood_set(const struct prestera_port *port, bool flood)\n{\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_FLOOD),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.param = {\n\t\t\t.flood_ext = {\n\t\t\t\t.type = PRESTERA_PORT_FLOOD_TYPE_UC,\n\t\t\t\t.enable = flood,\n\t\t\t}\n\t\t}\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_port_mc_flood_set(const struct prestera_port *port, bool flood)\n{\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_FLOOD),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.param = {\n\t\t\t.flood_ext = {\n\t\t\t\t.type = PRESTERA_PORT_FLOOD_TYPE_MC,\n\t\t\t\t.enable = flood,\n\t\t\t}\n\t\t}\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_port_br_locked_set(const struct prestera_port *port,\n\t\t\t\t   bool br_locked)\n{\n\tstruct prestera_msg_port_attr_req req = {\n\t\t.attr = __cpu_to_le32(PRESTERA_CMD_PORT_ATTR_LOCKED),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.param = {\n\t\t\t.br_locked = br_locked,\n\t\t}\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_PORT_ATTR_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_vlan_create(struct prestera_switch *sw, u16 vid)\n{\n\tstruct prestera_msg_vlan_req req = {\n\t\t.vid = __cpu_to_le16(vid),\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_VLAN_CREATE,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_vlan_delete(struct prestera_switch *sw, u16 vid)\n{\n\tstruct prestera_msg_vlan_req req = {\n\t\t.vid = __cpu_to_le16(vid),\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_VLAN_DELETE,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_vlan_port_set(struct prestera_port *port, u16 vid,\n\t\t\t      bool is_member, bool untagged)\n{\n\tstruct prestera_msg_vlan_req req = {\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.vid = __cpu_to_le16(vid),\n\t\t.is_member = is_member,\n\t\t.is_tagged = !untagged,\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_VLAN_PORT_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_vlan_port_vid_set(struct prestera_port *port, u16 vid)\n{\n\tstruct prestera_msg_vlan_req req = {\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.vid = __cpu_to_le16(vid),\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_VLAN_PVID_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_vlan_port_stp_set(struct prestera_port *port, u16 vid, u8 state)\n{\n\tstruct prestera_msg_stp_req req = {\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.vid = __cpu_to_le16(vid),\n\t\t.state = state,\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_STP_PORT_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_fdb_add(struct prestera_port *port, const unsigned char *mac,\n\t\t\tu16 vid, bool dynamic)\n{\n\tstruct prestera_msg_fdb_req req = {\n\t\t.dest = {\n\t\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t},\n\t\t.vid = __cpu_to_le16(vid),\n\t\t.dynamic = dynamic,\n\t};\n\n\tether_addr_copy(req.mac, mac);\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_FDB_ADD,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_fdb_del(struct prestera_port *port, const unsigned char *mac,\n\t\t\tu16 vid)\n{\n\tstruct prestera_msg_fdb_req req = {\n\t\t.dest = {\n\t\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t},\n\t\t.vid = __cpu_to_le16(vid),\n\t};\n\n\tether_addr_copy(req.mac, mac);\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_FDB_DELETE,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_lag_fdb_add(struct prestera_switch *sw, u16 lag_id,\n\t\t\t    const unsigned char *mac, u16 vid, bool dynamic)\n{\n\tstruct prestera_msg_fdb_req req = {\n\t\t.dest_type = PRESTERA_HW_FDB_ENTRY_TYPE_LAG,\n\t\t.dest = {\n\t\t\t.lag_id = __cpu_to_le16(lag_id),\n\t\t},\n\t\t.vid = __cpu_to_le16(vid),\n\t\t.dynamic = dynamic,\n\t};\n\n\tether_addr_copy(req.mac, mac);\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_FDB_ADD,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_lag_fdb_del(struct prestera_switch *sw, u16 lag_id,\n\t\t\t    const unsigned char *mac, u16 vid)\n{\n\tstruct prestera_msg_fdb_req req = {\n\t\t.dest_type = PRESTERA_HW_FDB_ENTRY_TYPE_LAG,\n\t\t.dest = {\n\t\t\t.lag_id = __cpu_to_le16(lag_id),\n\t\t},\n\t\t.vid = __cpu_to_le16(vid),\n\t};\n\n\tether_addr_copy(req.mac, mac);\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_FDB_DELETE,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_fdb_flush_port(struct prestera_port *port, u32 mode)\n{\n\tstruct prestera_msg_fdb_req req = {\n\t\t.dest = {\n\t\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t},\n\t\t.flush_mode = __cpu_to_le32(mode),\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_FDB_FLUSH_PORT,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_fdb_flush_vlan(struct prestera_switch *sw, u16 vid, u32 mode)\n{\n\tstruct prestera_msg_fdb_req req = {\n\t\t.vid = __cpu_to_le16(vid),\n\t\t.flush_mode = __cpu_to_le32(mode),\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_FDB_FLUSH_VLAN,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_fdb_flush_port_vlan(struct prestera_port *port, u16 vid,\n\t\t\t\t    u32 mode)\n{\n\tstruct prestera_msg_fdb_req req = {\n\t\t.dest = {\n\t\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t},\n\t\t.vid = __cpu_to_le16(vid),\n\t\t.flush_mode = __cpu_to_le32(mode),\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_FDB_FLUSH_PORT_VLAN,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_fdb_flush_lag(struct prestera_switch *sw, u16 lag_id,\n\t\t\t      u32 mode)\n{\n\tstruct prestera_msg_fdb_req req = {\n\t\t.dest_type = PRESTERA_HW_FDB_ENTRY_TYPE_LAG,\n\t\t.dest = {\n\t\t\t.lag_id = __cpu_to_le16(lag_id),\n\t\t},\n\t\t.flush_mode = __cpu_to_le32(mode),\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_FDB_FLUSH_PORT,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_fdb_flush_lag_vlan(struct prestera_switch *sw,\n\t\t\t\t   u16 lag_id, u16 vid, u32 mode)\n{\n\tstruct prestera_msg_fdb_req req = {\n\t\t.dest_type = PRESTERA_HW_FDB_ENTRY_TYPE_LAG,\n\t\t.dest = {\n\t\t\t.lag_id = __cpu_to_le16(lag_id),\n\t\t},\n\t\t.vid = __cpu_to_le16(vid),\n\t\t.flush_mode = __cpu_to_le32(mode),\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_FDB_FLUSH_PORT_VLAN,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_bridge_create(struct prestera_switch *sw, u16 *bridge_id)\n{\n\tstruct prestera_msg_bridge_resp resp;\n\tstruct prestera_msg_bridge_req req;\n\tint err;\n\n\terr = prestera_cmd_ret(sw, PRESTERA_CMD_TYPE_BRIDGE_CREATE,\n\t\t\t       &req.cmd, sizeof(req),\n\t\t\t       &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\t*bridge_id = __le16_to_cpu(resp.bridge);\n\n\treturn 0;\n}\n\nint prestera_hw_bridge_delete(struct prestera_switch *sw, u16 bridge_id)\n{\n\tstruct prestera_msg_bridge_req req = {\n\t\t.bridge = __cpu_to_le16(bridge_id),\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_BRIDGE_DELETE,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_bridge_port_add(struct prestera_port *port, u16 bridge_id)\n{\n\tstruct prestera_msg_bridge_req req = {\n\t\t.bridge = __cpu_to_le16(bridge_id),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_BRIDGE_PORT_ADD,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_bridge_port_delete(struct prestera_port *port, u16 bridge_id)\n{\n\tstruct prestera_msg_bridge_req req = {\n\t\t.bridge = __cpu_to_le16(bridge_id),\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_BRIDGE_PORT_DELETE,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nstatic int prestera_iface_to_msg(struct prestera_iface *iface,\n\t\t\t\t struct prestera_msg_iface *msg_if)\n{\n\tswitch (iface->type) {\n\tcase PRESTERA_IF_PORT_E:\n\tcase PRESTERA_IF_VID_E:\n\t\tmsg_if->port = __cpu_to_le32(iface->dev_port.port_num);\n\t\tmsg_if->dev = __cpu_to_le32(iface->dev_port.hw_dev_num);\n\t\tbreak;\n\tcase PRESTERA_IF_LAG_E:\n\t\tmsg_if->lag_id = __cpu_to_le16(iface->lag_id);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmsg_if->vr_id = __cpu_to_le16(iface->vr_id);\n\tmsg_if->vid = __cpu_to_le16(iface->vlan_id);\n\tmsg_if->type = iface->type;\n\treturn 0;\n}\n\nint prestera_hw_rif_create(struct prestera_switch *sw,\n\t\t\t   struct prestera_iface *iif, u8 *mac, u16 *rif_id)\n{\n\tstruct prestera_msg_rif_resp resp;\n\tstruct prestera_msg_rif_req req;\n\tint err;\n\n\tmemcpy(req.mac, mac, ETH_ALEN);\n\n\terr = prestera_iface_to_msg(iif, &req.iif);\n\tif (err)\n\t\treturn err;\n\n\terr = prestera_cmd_ret(sw, PRESTERA_CMD_TYPE_ROUTER_RIF_CREATE,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\t*rif_id = __le16_to_cpu(resp.rif_id);\n\treturn err;\n}\n\nint prestera_hw_rif_delete(struct prestera_switch *sw, u16 rif_id,\n\t\t\t   struct prestera_iface *iif)\n{\n\tstruct prestera_msg_rif_req req = {\n\t\t.rif_id = __cpu_to_le16(rif_id),\n\t};\n\tint err;\n\n\terr = prestera_iface_to_msg(iif, &req.iif);\n\tif (err)\n\t\treturn err;\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_ROUTER_RIF_DELETE, &req.cmd,\n\t\t\t    sizeof(req));\n}\n\nint prestera_hw_vr_create(struct prestera_switch *sw, u16 *vr_id)\n{\n\tstruct prestera_msg_vr_resp resp;\n\tstruct prestera_msg_vr_req req;\n\tint err;\n\n\terr = prestera_cmd_ret(sw, PRESTERA_CMD_TYPE_ROUTER_VR_CREATE,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\t*vr_id = __le16_to_cpu(resp.vr_id);\n\treturn err;\n}\n\nint prestera_hw_vr_delete(struct prestera_switch *sw, u16 vr_id)\n{\n\tstruct prestera_msg_vr_req req = {\n\t\t.vr_id = __cpu_to_le16(vr_id),\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_ROUTER_VR_DELETE, &req.cmd,\n\t\t\t    sizeof(req));\n}\n\nint prestera_hw_lpm_add(struct prestera_switch *sw, u16 vr_id,\n\t\t\t__be32 dst, u32 dst_len, u32 grp_id)\n{\n\tstruct prestera_msg_lpm_req req = {\n\t\t.dst_len = __cpu_to_le32(dst_len),\n\t\t.vr_id = __cpu_to_le16(vr_id),\n\t\t.grp_id = __cpu_to_le32(grp_id),\n\t\t.dst.u.ipv4 = dst\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_ROUTER_LPM_ADD, &req.cmd,\n\t\t\t    sizeof(req));\n}\n\nint prestera_hw_lpm_del(struct prestera_switch *sw, u16 vr_id,\n\t\t\t__be32 dst, u32 dst_len)\n{\n\tstruct prestera_msg_lpm_req req = {\n\t\t.dst_len = __cpu_to_le32(dst_len),\n\t\t.vr_id = __cpu_to_le16(vr_id),\n\t\t.dst.u.ipv4 = dst\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_ROUTER_LPM_DELETE, &req.cmd,\n\t\t\t    sizeof(req));\n}\n\nint prestera_hw_nh_entries_set(struct prestera_switch *sw, int count,\n\t\t\t       struct prestera_neigh_info *nhs, u32 grp_id)\n{\n\tstruct prestera_msg_nh_req req = { .size = __cpu_to_le32((u32)count),\n\t\t\t.grp_id = __cpu_to_le32(grp_id) };\n\tint i, err;\n\n\tfor (i = 0; i < count; i++) {\n\t\treq.nh[i].is_active = nhs[i].connected;\n\t\tmemcpy(&req.nh[i].mac, nhs[i].ha, ETH_ALEN);\n\t\terr = prestera_iface_to_msg(&nhs[i].iface, &req.nh[i].oif);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_ROUTER_NH_GRP_SET, &req.cmd,\n\t\t\t    sizeof(req));\n}\n\nint prestera_hw_nhgrp_blk_get(struct prestera_switch *sw,\n\t\t\t      u8 *hw_state, u32 buf_size  )\n{\n\tstatic struct prestera_msg_nh_chunk_resp resp;\n\tstruct prestera_msg_nh_chunk_req req;\n\tu32 buf_offset;\n\tint err;\n\n\tmemset(&hw_state[0], 0, buf_size);\n\tbuf_offset = 0;\n\twhile (1) {\n\t\tif (buf_offset >= buf_size)\n\t\t\tbreak;\n\n\t\tmemset(&req, 0, sizeof(req));\n\t\treq.offset = __cpu_to_le32(buf_offset * 8);  \n\t\terr = prestera_cmd_ret(sw,\n\t\t\t\t       PRESTERA_CMD_TYPE_ROUTER_NH_GRP_BLK_GET,\n\t\t\t\t       &req.cmd, sizeof(req), &resp.ret,\n\t\t\t\t       sizeof(resp));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmemcpy(&hw_state[buf_offset], &resp.hw_state[0],\n\t\t       buf_offset + PRESTERA_MSG_CHUNK_SIZE > buf_size ?\n\t\t\tbuf_size - buf_offset : PRESTERA_MSG_CHUNK_SIZE);\n\t\tbuf_offset += PRESTERA_MSG_CHUNK_SIZE;\n\t}\n\n\treturn 0;\n}\n\nint prestera_hw_nh_group_create(struct prestera_switch *sw, u16 nh_count,\n\t\t\t\tu32 *grp_id)\n{\n\tstruct prestera_msg_nh_grp_req req = { .size = __cpu_to_le32((u32)nh_count) };\n\tstruct prestera_msg_nh_grp_resp resp;\n\tint err;\n\n\terr = prestera_cmd_ret(sw, PRESTERA_CMD_TYPE_ROUTER_NH_GRP_ADD,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\t*grp_id = __le32_to_cpu(resp.grp_id);\n\treturn err;\n}\n\nint prestera_hw_nh_group_delete(struct prestera_switch *sw, u16 nh_count,\n\t\t\t\tu32 grp_id)\n{\n\tstruct prestera_msg_nh_grp_req req = {\n\t    .grp_id = __cpu_to_le32(grp_id),\n\t    .size = __cpu_to_le32(nh_count)\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_ROUTER_NH_GRP_DELETE,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_rxtx_init(struct prestera_switch *sw,\n\t\t\t  struct prestera_rxtx_params *params)\n{\n\tstruct prestera_msg_rxtx_resp resp;\n\tstruct prestera_msg_rxtx_req req;\n\tint err;\n\n\treq.use_sdma = params->use_sdma;\n\n\terr = prestera_cmd_ret(sw, PRESTERA_CMD_TYPE_RXTX_INIT,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\tparams->map_addr = __le32_to_cpu(resp.map_addr);\n\n\treturn 0;\n}\n\nint prestera_hw_lag_member_add(struct prestera_port *port, u16 lag_id)\n{\n\tstruct prestera_msg_lag_req req = {\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.lag_id = __cpu_to_le16(lag_id),\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_LAG_MEMBER_ADD,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_lag_member_del(struct prestera_port *port, u16 lag_id)\n{\n\tstruct prestera_msg_lag_req req = {\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.lag_id = __cpu_to_le16(lag_id),\n\t};\n\n\treturn prestera_cmd(port->sw, PRESTERA_CMD_TYPE_LAG_MEMBER_DELETE,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_lag_member_enable(struct prestera_port *port, u16 lag_id,\n\t\t\t\t  bool enable)\n{\n\tstruct prestera_msg_lag_req req = {\n\t\t.port = __cpu_to_le32(port->hw_id),\n\t\t.dev = __cpu_to_le32(port->dev_id),\n\t\t.lag_id = __cpu_to_le16(lag_id),\n\t};\n\tu32 cmd;\n\n\tcmd = enable ? PRESTERA_CMD_TYPE_LAG_MEMBER_ENABLE :\n\t\t\tPRESTERA_CMD_TYPE_LAG_MEMBER_DISABLE;\n\n\treturn prestera_cmd(port->sw, cmd, &req.cmd, sizeof(req));\n}\n\nint\nprestera_hw_cpu_code_counters_get(struct prestera_switch *sw, u8 code,\n\t\t\t\t  enum prestera_hw_cpu_code_cnt_t counter_type,\n\t\t\t\t  u64 *packet_count)\n{\n\tstruct prestera_msg_cpu_code_counter_req req = {\n\t\t.counter_type = counter_type,\n\t\t.code = code,\n\t};\n\tstruct mvsw_msg_cpu_code_counter_ret resp;\n\tint err;\n\n\terr = prestera_cmd_ret(sw, PRESTERA_CMD_TYPE_CPU_CODE_COUNTERS_GET,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\t*packet_count = __le64_to_cpu(resp.packet_count);\n\n\treturn 0;\n}\n\nint prestera_hw_event_handler_register(struct prestera_switch *sw,\n\t\t\t\t       enum prestera_event_type type,\n\t\t\t\t       prestera_event_cb_t fn,\n\t\t\t\t       void *arg)\n{\n\tstruct prestera_fw_event_handler *eh;\n\n\teh = __find_event_handler(sw, type);\n\tif (eh)\n\t\treturn -EEXIST;\n\n\teh = kmalloc(sizeof(*eh), GFP_KERNEL);\n\tif (!eh)\n\t\treturn -ENOMEM;\n\n\teh->type = type;\n\teh->func = fn;\n\teh->arg = arg;\n\n\tINIT_LIST_HEAD(&eh->list);\n\n\tlist_add_rcu(&eh->list, &sw->event_handlers);\n\n\treturn 0;\n}\n\nvoid prestera_hw_event_handler_unregister(struct prestera_switch *sw,\n\t\t\t\t\t  enum prestera_event_type type,\n\t\t\t\t\t  prestera_event_cb_t fn)\n{\n\tstruct prestera_fw_event_handler *eh;\n\n\teh = __find_event_handler(sw, type);\n\tif (!eh)\n\t\treturn;\n\n\tlist_del_rcu(&eh->list);\n\tkfree_rcu(eh, rcu);\n}\n\nint prestera_hw_counter_trigger(struct prestera_switch *sw, u32 block_id)\n{\n\tstruct prestera_msg_counter_req req = {\n\t\t.block_id = __cpu_to_le32(block_id)\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_COUNTER_TRIGGER,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_counter_abort(struct prestera_switch *sw)\n{\n\tstruct prestera_msg_counter_req req;\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_COUNTER_ABORT,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_counters_get(struct prestera_switch *sw, u32 idx,\n\t\t\t     u32 *len, bool *done,\n\t\t\t     struct prestera_counter_stats *stats)\n{\n\tstruct prestera_msg_counter_resp *resp;\n\tstruct prestera_msg_counter_req req = {\n\t\t.block_id = __cpu_to_le32(idx),\n\t\t.num_counters = __cpu_to_le32(*len),\n\t};\n\tsize_t size = struct_size(resp, stats, *len);\n\tint err, i;\n\n\tresp = kmalloc(size, GFP_KERNEL);\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\terr = prestera_cmd_ret(sw, PRESTERA_CMD_TYPE_COUNTER_GET,\n\t\t\t       &req.cmd, sizeof(req), &resp->ret, size);\n\tif (err)\n\t\tgoto free_buff;\n\n\tfor (i = 0; i < __le32_to_cpu(resp->num_counters); i++) {\n\t\tstats[i].packets += __le64_to_cpu(resp->stats[i].packets);\n\t\tstats[i].bytes += __le64_to_cpu(resp->stats[i].bytes);\n\t}\n\n\t*len = __le32_to_cpu(resp->num_counters);\n\t*done = __le32_to_cpu(resp->done);\n\nfree_buff:\n\tkfree(resp);\n\treturn err;\n}\n\nint prestera_hw_counter_block_get(struct prestera_switch *sw,\n\t\t\t\t  u32 client, u32 *block_id, u32 *offset,\n\t\t\t\t  u32 *num_counters)\n{\n\tstruct prestera_msg_counter_resp resp;\n\tstruct prestera_msg_counter_req req = {\n\t\t.client = __cpu_to_le32(client)\n\t};\n\tint err;\n\n\terr = prestera_cmd_ret(sw, PRESTERA_CMD_TYPE_COUNTER_BLOCK_GET,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\t*block_id = __le32_to_cpu(resp.block_id);\n\t*offset = __le32_to_cpu(resp.offset);\n\t*num_counters = __le32_to_cpu(resp.num_counters);\n\n\treturn 0;\n}\n\nint prestera_hw_counter_block_release(struct prestera_switch *sw,\n\t\t\t\t      u32 block_id)\n{\n\tstruct prestera_msg_counter_req req = {\n\t\t.block_id = __cpu_to_le32(block_id)\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_COUNTER_BLOCK_RELEASE,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_counter_clear(struct prestera_switch *sw, u32 block_id,\n\t\t\t      u32 counter_id)\n{\n\tstruct prestera_msg_counter_req req = {\n\t\t.block_id = __cpu_to_le32(block_id),\n\t\t.num_counters = __cpu_to_le32(counter_id)\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_COUNTER_CLEAR,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_policer_create(struct prestera_switch *sw, u8 type,\n\t\t\t       u32 *policer_id)\n{\n\tstruct prestera_msg_policer_resp resp;\n\tstruct prestera_msg_policer_req req = {\n\t\t.type = type\n\t};\n\tint err;\n\n\terr = prestera_cmd_ret(sw, PRESTERA_CMD_TYPE_POLICER_CREATE,\n\t\t\t       &req.cmd, sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\t*policer_id = __le32_to_cpu(resp.id);\n\treturn 0;\n}\n\nint prestera_hw_policer_release(struct prestera_switch *sw,\n\t\t\t\tu32 policer_id)\n{\n\tstruct prestera_msg_policer_req req = {\n\t\t.id = __cpu_to_le32(policer_id)\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_POLICER_RELEASE,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_policer_sr_tcm_set(struct prestera_switch *sw,\n\t\t\t\t   u32 policer_id, u64 cir, u32 cbs)\n{\n\tstruct prestera_msg_policer_req req = {\n\t\t.mode = PRESTERA_POLICER_MODE_SR_TCM,\n\t\t.id = __cpu_to_le32(policer_id),\n\t\t.sr_tcm = {\n\t\t\t.cir = __cpu_to_le64(cir),\n\t\t\t.cbs = __cpu_to_le32(cbs)\n\t\t}\n\t};\n\n\treturn prestera_cmd(sw, PRESTERA_CMD_TYPE_POLICER_SET,\n\t\t\t    &req.cmd, sizeof(req));\n}\n\nint prestera_hw_flood_domain_create(struct prestera_flood_domain *domain)\n{\n\tstruct prestera_msg_flood_domain_create_resp resp;\n\tstruct prestera_msg_flood_domain_create_req req;\n\tint err;\n\n\terr = prestera_cmd_ret(domain->sw,\n\t\t\t       PRESTERA_CMD_TYPE_FLOOD_DOMAIN_CREATE, &req.cmd,\n\t\t\t       sizeof(req), &resp.ret, sizeof(resp));\n\tif (err)\n\t\treturn err;\n\n\tdomain->idx = __le32_to_cpu(resp.flood_domain_idx);\n\n\treturn 0;\n}\n\nint prestera_hw_flood_domain_destroy(struct prestera_flood_domain *domain)\n{\n\tstruct prestera_msg_flood_domain_destroy_req req = {\n\t\t.flood_domain_idx = __cpu_to_le32(domain->idx),\n\t};\n\n\treturn prestera_cmd(domain->sw, PRESTERA_CMD_TYPE_FLOOD_DOMAIN_DESTROY,\n\t\t\t   &req.cmd, sizeof(req));\n}\n\nint prestera_hw_flood_domain_ports_set(struct prestera_flood_domain *domain)\n{\n\tstruct prestera_flood_domain_port *flood_domain_port;\n\tstruct prestera_msg_flood_domain_ports_set_req *req;\n\tstruct prestera_msg_flood_domain_port *ports;\n\tstruct prestera_switch *sw = domain->sw;\n\tstruct prestera_port *port;\n\tu32 ports_num = 0;\n\tint buf_size;\n\tvoid *buff;\n\tu16 lag_id;\n\tint err;\n\n\tlist_for_each_entry(flood_domain_port, &domain->flood_domain_port_list,\n\t\t\t    flood_domain_port_node)\n\t\tports_num++;\n\n\tif (!ports_num)\n\t\treturn -EINVAL;\n\n\tbuf_size = sizeof(*req) + sizeof(*ports) * ports_num;\n\n\tbuff = kmalloc(buf_size, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\treq = buff;\n\tports = buff + sizeof(*req);\n\n\treq->flood_domain_idx = __cpu_to_le32(domain->idx);\n\treq->ports_num = __cpu_to_le32(ports_num);\n\n\tlist_for_each_entry(flood_domain_port, &domain->flood_domain_port_list,\n\t\t\t    flood_domain_port_node) {\n\t\tif (netif_is_lag_master(flood_domain_port->dev)) {\n\t\t\tif (prestera_lag_id(sw, flood_domain_port->dev,\n\t\t\t\t\t    &lag_id)) {\n\t\t\t\tkfree(buff);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tports->port_type =\n\t\t\t\t__cpu_to_le16(PRESTERA_HW_FLOOD_DOMAIN_PORT_TYPE_LAG);\n\t\t\tports->lag_id = __cpu_to_le16(lag_id);\n\t\t} else {\n\t\t\tport = prestera_port_dev_lower_find(flood_domain_port->dev);\n\n\t\t\tports->port_type =\n\t\t\t\t__cpu_to_le16(PRESTERA_HW_FDB_ENTRY_TYPE_REG_PORT);\n\t\t\tports->dev_num = __cpu_to_le32(port->dev_id);\n\t\t\tports->port_num = __cpu_to_le32(port->hw_id);\n\t\t}\n\n\t\tports->vid = __cpu_to_le16(flood_domain_port->vid);\n\n\t\tports++;\n\t}\n\n\terr = prestera_cmd(sw, PRESTERA_CMD_TYPE_FLOOD_DOMAIN_PORTS_SET,\n\t\t\t   &req->cmd, buf_size);\n\n\tkfree(buff);\n\n\treturn err;\n}\n\nint prestera_hw_flood_domain_ports_reset(struct prestera_flood_domain *domain)\n{\n\tstruct prestera_msg_flood_domain_ports_reset_req req = {\n\t\t.flood_domain_idx = __cpu_to_le32(domain->idx),\n\t};\n\n\treturn prestera_cmd(domain->sw,\n\t\t\t   PRESTERA_CMD_TYPE_FLOOD_DOMAIN_PORTS_RESET, &req.cmd,\n\t\t\t   sizeof(req));\n}\n\nint prestera_hw_mdb_create(struct prestera_mdb_entry *mdb)\n{\n\tstruct prestera_msg_mdb_create_req req = {\n\t\t.flood_domain_idx = __cpu_to_le32(mdb->flood_domain->idx),\n\t\t.vid = __cpu_to_le16(mdb->vid),\n\t};\n\n\tmemcpy(req.mac, mdb->addr, ETH_ALEN);\n\n\treturn prestera_cmd(mdb->sw, PRESTERA_CMD_TYPE_MDB_CREATE, &req.cmd,\n\t\t\t    sizeof(req));\n}\n\nint prestera_hw_mdb_destroy(struct prestera_mdb_entry *mdb)\n{\n\tstruct prestera_msg_mdb_destroy_req req = {\n\t\t.flood_domain_idx = __cpu_to_le32(mdb->flood_domain->idx),\n\t\t.vid = __cpu_to_le16(mdb->vid),\n\t};\n\n\tmemcpy(req.mac, mdb->addr, ETH_ALEN);\n\n\treturn prestera_cmd(mdb->sw, PRESTERA_CMD_TYPE_MDB_DESTROY, &req.cmd,\n\t\t\t    sizeof(req));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}