{
  "module_name": "mvmdio.c",
  "hash_id": "d408857690483f867b604df8cb9650119c8e5258def8cb4cb58da25b4d5a22db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/mvmdio.c",
  "human_readable_source": " \n\n#include <linux/acpi.h>\n#include <linux/acpi_mdio.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n\n#define MVMDIO_SMI_DATA_SHIFT\t\t0\n#define MVMDIO_SMI_PHY_ADDR_SHIFT\t16\n#define MVMDIO_SMI_PHY_REG_SHIFT\t21\n#define MVMDIO_SMI_READ_OPERATION\tBIT(26)\n#define MVMDIO_SMI_WRITE_OPERATION\t0\n#define MVMDIO_SMI_READ_VALID\t\tBIT(27)\n#define MVMDIO_SMI_BUSY\t\t\tBIT(28)\n#define MVMDIO_ERR_INT_CAUSE\t\t0x007C\n#define  MVMDIO_ERR_INT_SMI_DONE\t0x00000010\n#define MVMDIO_ERR_INT_MASK\t\t0x0080\n\n#define MVMDIO_XSMI_MGNT_REG\t\t0x0\n#define  MVMDIO_XSMI_PHYADDR_SHIFT\t16\n#define  MVMDIO_XSMI_DEVADDR_SHIFT\t21\n#define  MVMDIO_XSMI_WRITE_OPERATION\t(0x5 << 26)\n#define  MVMDIO_XSMI_READ_OPERATION\t(0x7 << 26)\n#define  MVMDIO_XSMI_READ_VALID\t\tBIT(29)\n#define  MVMDIO_XSMI_BUSY\t\tBIT(30)\n#define MVMDIO_XSMI_ADDR_REG\t\t0x8\n\n \n#define MVMDIO_SMI_TIMEOUT\t\t1000  \n#define MVMDIO_SMI_POLL_INTERVAL_MIN\t45\n#define MVMDIO_SMI_POLL_INTERVAL_MAX\t55\n\n#define MVMDIO_XSMI_POLL_INTERVAL_MIN\t150\n#define MVMDIO_XSMI_POLL_INTERVAL_MAX\t160\n\nstruct orion_mdio_dev {\n\tvoid __iomem *regs;\n\tstruct clk *clk[4];\n\t \n\tint err_interrupt;\n\twait_queue_head_t smi_busy_wait;\n};\n\nenum orion_mdio_bus_type {\n\tBUS_TYPE_SMI,\n\tBUS_TYPE_XSMI\n};\n\nstruct orion_mdio_ops {\n\tint (*is_done)(struct orion_mdio_dev *);\n\tunsigned int poll_interval_min;\n\tunsigned int poll_interval_max;\n};\n\n \nstatic int orion_mdio_wait_ready(const struct orion_mdio_ops *ops,\n\t\t\t\t struct mii_bus *bus)\n{\n\tstruct orion_mdio_dev *dev = bus->priv;\n\tunsigned long timeout = usecs_to_jiffies(MVMDIO_SMI_TIMEOUT);\n\tunsigned long end = jiffies + timeout;\n\tint timedout = 0;\n\n\twhile (1) {\n\t        if (ops->is_done(dev))\n\t\t\treturn 0;\n\t        else if (timedout)\n\t\t\tbreak;\n\n\t        if (dev->err_interrupt <= 0) {\n\t\t\tusleep_range(ops->poll_interval_min,\n\t\t\t\t     ops->poll_interval_max);\n\n\t\t\tif (time_is_before_jiffies(end))\n\t\t\t\t++timedout;\n\t        } else {\n\t\t\t \n\t\t\tif (timeout < 2)\n\t\t\t\ttimeout = 2;\n\t\t\twait_event_timeout(dev->smi_busy_wait,\n\t\t\t\t           ops->is_done(dev), timeout);\n\n\t\t\t++timedout;\n\t        }\n\t}\n\n\tdev_err(bus->parent, \"Timeout: SMI busy for too long\\n\");\n\treturn  -ETIMEDOUT;\n}\n\nstatic int orion_mdio_smi_is_done(struct orion_mdio_dev *dev)\n{\n\treturn !(readl(dev->regs) & MVMDIO_SMI_BUSY);\n}\n\nstatic const struct orion_mdio_ops orion_mdio_smi_ops = {\n\t.is_done = orion_mdio_smi_is_done,\n\t.poll_interval_min = MVMDIO_SMI_POLL_INTERVAL_MIN,\n\t.poll_interval_max = MVMDIO_SMI_POLL_INTERVAL_MAX,\n};\n\nstatic int orion_mdio_smi_read(struct mii_bus *bus, int mii_id,\n\t\t\t       int regnum)\n{\n\tstruct orion_mdio_dev *dev = bus->priv;\n\tu32 val;\n\tint ret;\n\n\tret = orion_mdio_wait_ready(&orion_mdio_smi_ops, bus);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel(((mii_id << MVMDIO_SMI_PHY_ADDR_SHIFT) |\n\t\t(regnum << MVMDIO_SMI_PHY_REG_SHIFT)  |\n\t\tMVMDIO_SMI_READ_OPERATION),\n\t       dev->regs);\n\n\tret = orion_mdio_wait_ready(&orion_mdio_smi_ops, bus);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = readl(dev->regs);\n\tif (!(val & MVMDIO_SMI_READ_VALID)) {\n\t\tdev_err(bus->parent, \"SMI bus read not valid\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn val & GENMASK(15, 0);\n}\n\nstatic int orion_mdio_smi_write(struct mii_bus *bus, int mii_id,\n\t\t\t\tint regnum, u16 value)\n{\n\tstruct orion_mdio_dev *dev = bus->priv;\n\tint ret;\n\n\tret = orion_mdio_wait_ready(&orion_mdio_smi_ops, bus);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel(((mii_id << MVMDIO_SMI_PHY_ADDR_SHIFT) |\n\t\t(regnum << MVMDIO_SMI_PHY_REG_SHIFT)  |\n\t\tMVMDIO_SMI_WRITE_OPERATION            |\n\t\t(value << MVMDIO_SMI_DATA_SHIFT)),\n\t       dev->regs);\n\n\treturn 0;\n}\n\nstatic int orion_mdio_xsmi_is_done(struct orion_mdio_dev *dev)\n{\n\treturn !(readl(dev->regs + MVMDIO_XSMI_MGNT_REG) & MVMDIO_XSMI_BUSY);\n}\n\nstatic const struct orion_mdio_ops orion_mdio_xsmi_ops = {\n\t.is_done = orion_mdio_xsmi_is_done,\n\t.poll_interval_min = MVMDIO_XSMI_POLL_INTERVAL_MIN,\n\t.poll_interval_max = MVMDIO_XSMI_POLL_INTERVAL_MAX,\n};\n\nstatic int orion_mdio_xsmi_read_c45(struct mii_bus *bus, int mii_id,\n\t\t\t\t    int dev_addr, int regnum)\n{\n\tstruct orion_mdio_dev *dev = bus->priv;\n\tint ret;\n\n\tret = orion_mdio_wait_ready(&orion_mdio_xsmi_ops, bus);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel(regnum, dev->regs + MVMDIO_XSMI_ADDR_REG);\n\twritel((mii_id << MVMDIO_XSMI_PHYADDR_SHIFT) |\n\t       (dev_addr << MVMDIO_XSMI_DEVADDR_SHIFT) |\n\t       MVMDIO_XSMI_READ_OPERATION,\n\t       dev->regs + MVMDIO_XSMI_MGNT_REG);\n\n\tret = orion_mdio_wait_ready(&orion_mdio_xsmi_ops, bus);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(readl(dev->regs + MVMDIO_XSMI_MGNT_REG) &\n\t      MVMDIO_XSMI_READ_VALID)) {\n\t\tdev_err(bus->parent, \"XSMI bus read not valid\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn readl(dev->regs + MVMDIO_XSMI_MGNT_REG) & GENMASK(15, 0);\n}\n\nstatic int orion_mdio_xsmi_write_c45(struct mii_bus *bus, int mii_id,\n\t\t\t\t     int dev_addr, int regnum, u16 value)\n{\n\tstruct orion_mdio_dev *dev = bus->priv;\n\tint ret;\n\n\tret = orion_mdio_wait_ready(&orion_mdio_xsmi_ops, bus);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel(regnum, dev->regs + MVMDIO_XSMI_ADDR_REG);\n\twritel((mii_id << MVMDIO_XSMI_PHYADDR_SHIFT) |\n\t       (dev_addr << MVMDIO_XSMI_DEVADDR_SHIFT) |\n\t       MVMDIO_XSMI_WRITE_OPERATION | value,\n\t       dev->regs + MVMDIO_XSMI_MGNT_REG);\n\n\treturn 0;\n}\n\nstatic irqreturn_t orion_mdio_err_irq(int irq, void *dev_id)\n{\n\tstruct orion_mdio_dev *dev = dev_id;\n\n\tif (readl(dev->regs + MVMDIO_ERR_INT_CAUSE) &\n\t\t\tMVMDIO_ERR_INT_SMI_DONE) {\n\t\twritel(~MVMDIO_ERR_INT_SMI_DONE,\n\t\t\t\tdev->regs + MVMDIO_ERR_INT_CAUSE);\n\t\twake_up(&dev->smi_busy_wait);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int orion_mdio_probe(struct platform_device *pdev)\n{\n\tenum orion_mdio_bus_type type;\n\tstruct resource *r;\n\tstruct mii_bus *bus;\n\tstruct orion_mdio_dev *dev;\n\tint i, ret;\n\n\ttype = (uintptr_t)device_get_match_data(&pdev->dev);\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"No SMI register address given\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbus = devm_mdiobus_alloc_size(&pdev->dev,\n\t\t\t\t      sizeof(struct orion_mdio_dev));\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tswitch (type) {\n\tcase BUS_TYPE_SMI:\n\t\tbus->read = orion_mdio_smi_read;\n\t\tbus->write = orion_mdio_smi_write;\n\t\tbreak;\n\tcase BUS_TYPE_XSMI:\n\t\tbus->read_c45 = orion_mdio_xsmi_read_c45;\n\t\tbus->write_c45 = orion_mdio_xsmi_write_c45;\n\t\tbreak;\n\t}\n\n\tbus->name = \"orion_mdio_bus\";\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-mii\",\n\t\t dev_name(&pdev->dev));\n\tbus->parent = &pdev->dev;\n\n\tdev = bus->priv;\n\tdev->regs = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!dev->regs) {\n\t\tdev_err(&pdev->dev, \"Unable to remap SMI register\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tinit_waitqueue_head(&dev->smi_busy_wait);\n\n\tif (pdev->dev.of_node) {\n\t\tfor (i = 0; i < ARRAY_SIZE(dev->clk); i++) {\n\t\t\tdev->clk[i] = of_clk_get(pdev->dev.of_node, i);\n\t\t\tif (PTR_ERR(dev->clk[i]) == -EPROBE_DEFER) {\n\t\t\t\tret = -EPROBE_DEFER;\n\t\t\t\tgoto out_clk;\n\t\t\t}\n\t\t\tif (IS_ERR(dev->clk[i]))\n\t\t\t\tbreak;\n\t\t\tclk_prepare_enable(dev->clk[i]);\n\t\t}\n\n\t\tif (!IS_ERR(of_clk_get(pdev->dev.of_node,\n\t\t\t\t       ARRAY_SIZE(dev->clk))))\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"unsupported number of clocks, limiting to the first \"\n\t\t\t\t __stringify(ARRAY_SIZE(dev->clk)) \"\\n\");\n\t} else {\n\t\tdev->clk[0] = clk_get(&pdev->dev, NULL);\n\t\tif (PTR_ERR(dev->clk[0]) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto out_clk;\n\t\t}\n\t\tif (!IS_ERR(dev->clk[0]))\n\t\t\tclk_prepare_enable(dev->clk[0]);\n\t}\n\n\n\tdev->err_interrupt = platform_get_irq_optional(pdev, 0);\n\tif (dev->err_interrupt > 0 &&\n\t    resource_size(r) < MVMDIO_ERR_INT_MASK + 4) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"disabling interrupt, resource size is too small\\n\");\n\t\tdev->err_interrupt = 0;\n\t}\n\tif (dev->err_interrupt > 0) {\n\t\tret = devm_request_irq(&pdev->dev, dev->err_interrupt,\n\t\t\t\t\torion_mdio_err_irq,\n\t\t\t\t\tIRQF_SHARED, pdev->name, dev);\n\t\tif (ret)\n\t\t\tgoto out_mdio;\n\n\t\twritel(MVMDIO_ERR_INT_SMI_DONE,\n\t\t\tdev->regs + MVMDIO_ERR_INT_MASK);\n\n\t} else if (dev->err_interrupt == -EPROBE_DEFER) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto out_mdio;\n\t}\n\n\t \n\tif (is_acpi_node(pdev->dev.fwnode))\n\t\tret = acpi_mdiobus_register(bus, pdev->dev.fwnode);\n\telse\n\t\tret = of_mdiobus_register(bus, pdev->dev.of_node);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Cannot register MDIO bus (%d)\\n\", ret);\n\t\tgoto out_mdio;\n\t}\n\n\tplatform_set_drvdata(pdev, bus);\n\n\treturn 0;\n\nout_mdio:\n\tif (dev->err_interrupt > 0)\n\t\twritel(0, dev->regs + MVMDIO_ERR_INT_MASK);\n\nout_clk:\n\tfor (i = 0; i < ARRAY_SIZE(dev->clk); i++) {\n\t\tif (IS_ERR(dev->clk[i]))\n\t\t\tbreak;\n\t\tclk_disable_unprepare(dev->clk[i]);\n\t\tclk_put(dev->clk[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic int orion_mdio_remove(struct platform_device *pdev)\n{\n\tstruct mii_bus *bus = platform_get_drvdata(pdev);\n\tstruct orion_mdio_dev *dev = bus->priv;\n\tint i;\n\n\tif (dev->err_interrupt > 0)\n\t\twritel(0, dev->regs + MVMDIO_ERR_INT_MASK);\n\tmdiobus_unregister(bus);\n\n\tfor (i = 0; i < ARRAY_SIZE(dev->clk); i++) {\n\t\tif (IS_ERR(dev->clk[i]))\n\t\t\tbreak;\n\t\tclk_disable_unprepare(dev->clk[i]);\n\t\tclk_put(dev->clk[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id orion_mdio_match[] = {\n\t{ .compatible = \"marvell,orion-mdio\", .data = (void *)BUS_TYPE_SMI },\n\t{ .compatible = \"marvell,xmdio\", .data = (void *)BUS_TYPE_XSMI },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, orion_mdio_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id orion_mdio_acpi_match[] = {\n\t{ \"MRVL0100\", BUS_TYPE_SMI },\n\t{ \"MRVL0101\", BUS_TYPE_XSMI },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, orion_mdio_acpi_match);\n#endif\n\nstatic struct platform_driver orion_mdio_driver = {\n\t.probe = orion_mdio_probe,\n\t.remove = orion_mdio_remove,\n\t.driver = {\n\t\t.name = \"orion-mdio\",\n\t\t.of_match_table = orion_mdio_match,\n\t\t.acpi_match_table = ACPI_PTR(orion_mdio_acpi_match),\n\t},\n};\n\nmodule_platform_driver(orion_mdio_driver);\n\nMODULE_DESCRIPTION(\"Marvell MDIO interface driver\");\nMODULE_AUTHOR(\"Thomas Petazzoni <thomas.petazzoni@free-electrons.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:orion-mdio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}