{
  "module_name": "sky2.c",
  "hash_id": "76ce465a20cea04392451f3609caa029cb4837ca282ac28b5a1b77ec55be07b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/sky2.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/crc32.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/dma-mapping.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <net/ip.h>\n#include <linux/tcp.h>\n#include <linux/in.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <linux/if_vlan.h>\n#include <linux/prefetch.h>\n#include <linux/debugfs.h>\n#include <linux/mii.h>\n#include <linux/of_net.h>\n#include <linux/dmi.h>\n\n#include <asm/irq.h>\n\n#include \"sky2.h\"\n\n#define DRV_NAME\t\t\"sky2\"\n#define DRV_VERSION\t\t\"1.30\"\n\n \n\n#define RX_LE_SIZE\t    \t1024\n#define RX_LE_BYTES\t\t(RX_LE_SIZE*sizeof(struct sky2_rx_le))\n#define RX_MAX_PENDING\t\t(RX_LE_SIZE/6 - 2)\n#define RX_DEF_PENDING\t\tRX_MAX_PENDING\n\n \n#define MAX_SKB_TX_LE\t(2 + (sizeof(dma_addr_t)/sizeof(u32))*(MAX_SKB_FRAGS+1))\n#define TX_MIN_PENDING\t\t(MAX_SKB_TX_LE+1)\n#define TX_MAX_PENDING\t\t1024\n#define TX_DEF_PENDING\t\t63\n\n#define TX_WATCHDOG\t\t(5 * HZ)\n#define PHY_RETRIES\t\t1000\n\n#define SKY2_EEPROM_MAGIC\t0x9955aabb\n\n#define RING_NEXT(x, s)\t(((x)+1) & ((s)-1))\n\nstatic const u32 default_msg =\n    NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK\n    | NETIF_MSG_TIMER | NETIF_MSG_TX_ERR | NETIF_MSG_RX_ERR\n    | NETIF_MSG_IFUP | NETIF_MSG_IFDOWN;\n\nstatic int debug = -1;\t\t \nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0=none,...,16=all)\");\n\nstatic int copybreak __read_mostly = 128;\nmodule_param(copybreak, int, 0);\nMODULE_PARM_DESC(copybreak, \"Receive copy threshold\");\n\nstatic int disable_msi = -1;\nmodule_param(disable_msi, int, 0);\nMODULE_PARM_DESC(disable_msi, \"Disable Message Signaled Interrupt (MSI)\");\n\nstatic int legacy_pme = 0;\nmodule_param(legacy_pme, int, 0);\nMODULE_PARM_DESC(legacy_pme, \"Legacy power management\");\n\nstatic const struct pci_device_id sky2_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SYSKONNECT, 0x9000) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_SYSKONNECT, 0x9E00) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_SYSKONNECT, 0x9E01) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_DLINK, 0x4b00) },\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_DLINK, 0x4001) }, \t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_DLINK, 0x4B02) },\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_DLINK, 0x4B03) },\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4340) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4341) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4342) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4343) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4344) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4345) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4346) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4347) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4350) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4351) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4352) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4353) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4354) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4355) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4356) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4357) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x435A) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4360) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4361) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4362) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4363) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4364) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4365) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4366) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4367) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4368) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4369) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x436A) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x436B) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x436C) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x436D) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4370) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4380) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4381) },  \n\t{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4382) },  \n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(pci, sky2_id_table);\n\n \nstatic const unsigned txqaddr[] = { Q_XA1, Q_XA2 };\nstatic const unsigned rxqaddr[] = { Q_R1, Q_R2 };\nstatic const u32 portirq_msk[] = { Y2_IS_PORT_1, Y2_IS_PORT_2 };\n\nstatic void sky2_set_multicast(struct net_device *dev);\nstatic irqreturn_t sky2_intr(int irq, void *dev_id);\n\n \nstatic int gm_phy_write(struct sky2_hw *hw, unsigned port, u16 reg, u16 val)\n{\n\tint i;\n\n\tgma_write16(hw, port, GM_SMI_DATA, val);\n\tgma_write16(hw, port, GM_SMI_CTRL,\n\t\t    GM_SMI_CT_PHY_AD(PHY_ADDR_MARV) | GM_SMI_CT_REG_AD(reg));\n\n\tfor (i = 0; i < PHY_RETRIES; i++) {\n\t\tu16 ctrl = gma_read16(hw, port, GM_SMI_CTRL);\n\t\tif (ctrl == 0xffff)\n\t\t\tgoto io_error;\n\n\t\tif (!(ctrl & GM_SMI_CT_BUSY))\n\t\t\treturn 0;\n\n\t\tudelay(10);\n\t}\n\n\tdev_warn(&hw->pdev->dev, \"%s: phy write timeout\\n\", hw->dev[port]->name);\n\treturn -ETIMEDOUT;\n\nio_error:\n\tdev_err(&hw->pdev->dev, \"%s: phy I/O error\\n\", hw->dev[port]->name);\n\treturn -EIO;\n}\n\nstatic int __gm_phy_read(struct sky2_hw *hw, unsigned port, u16 reg, u16 *val)\n{\n\tint i;\n\n\tgma_write16(hw, port, GM_SMI_CTRL, GM_SMI_CT_PHY_AD(PHY_ADDR_MARV)\n\t\t    | GM_SMI_CT_REG_AD(reg) | GM_SMI_CT_OP_RD);\n\n\tfor (i = 0; i < PHY_RETRIES; i++) {\n\t\tu16 ctrl = gma_read16(hw, port, GM_SMI_CTRL);\n\t\tif (ctrl == 0xffff)\n\t\t\tgoto io_error;\n\n\t\tif (ctrl & GM_SMI_CT_RD_VAL) {\n\t\t\t*val = gma_read16(hw, port, GM_SMI_DATA);\n\t\t\treturn 0;\n\t\t}\n\n\t\tudelay(10);\n\t}\n\n\tdev_warn(&hw->pdev->dev, \"%s: phy read timeout\\n\", hw->dev[port]->name);\n\treturn -ETIMEDOUT;\nio_error:\n\tdev_err(&hw->pdev->dev, \"%s: phy I/O error\\n\", hw->dev[port]->name);\n\treturn -EIO;\n}\n\nstatic inline u16 gm_phy_read(struct sky2_hw *hw, unsigned port, u16 reg)\n{\n\tu16 v = 0;\n\t__gm_phy_read(hw, port, reg, &v);\n\treturn v;\n}\n\n\nstatic void sky2_power_on(struct sky2_hw *hw)\n{\n\t \n\tsky2_write8(hw, B0_POWER_CTRL,\n\t\t    PC_VAUX_ENA | PC_VCC_ENA | PC_VAUX_OFF | PC_VCC_ON);\n\n\t \n\tsky2_write32(hw, B2_Y2_CLK_CTRL, Y2_CLK_DIV_DIS);\n\n\tif (hw->chip_id == CHIP_ID_YUKON_XL && hw->chip_rev > CHIP_REV_YU_XL_A1)\n\t\t \n\t\tsky2_write8(hw, B2_Y2_CLK_GATE,\n\t\t\t    Y2_PCI_CLK_LNK1_DIS | Y2_COR_CLK_LNK1_DIS |\n\t\t\t    Y2_CLK_GAT_LNK1_DIS | Y2_PCI_CLK_LNK2_DIS |\n\t\t\t    Y2_COR_CLK_LNK2_DIS | Y2_CLK_GAT_LNK2_DIS);\n\telse\n\t\tsky2_write8(hw, B2_Y2_CLK_GATE, 0);\n\n\tif (hw->flags & SKY2_HW_ADV_POWER_CTL) {\n\t\tu32 reg;\n\n\t\tsky2_pci_write32(hw, PCI_DEV_REG3, 0);\n\n\t\treg = sky2_pci_read32(hw, PCI_DEV_REG4);\n\t\t \n\t\treg &= P_ASPM_CONTROL_MSK;\n\t\tsky2_pci_write32(hw, PCI_DEV_REG4, reg);\n\n\t\treg = sky2_pci_read32(hw, PCI_DEV_REG5);\n\t\t \n\t\treg &= P_CTL_TIM_VMAIN_AV_MSK;\n\t\tsky2_pci_write32(hw, PCI_DEV_REG5, reg);\n\n\t\tsky2_pci_write32(hw, PCI_CFG_REG_1, 0);\n\n\t\tsky2_write16(hw, B0_CTST, Y2_HW_WOL_ON);\n\n\t\t \n\t\treg = sky2_read32(hw, B2_GP_IO);\n\t\treg |= GLB_GPIO_STAT_RACE_DIS;\n\t\tsky2_write32(hw, B2_GP_IO, reg);\n\n\t\tsky2_read32(hw, B2_GP_IO);\n\t}\n\n\t \n\tsky2_write16(hw, B0_CTST, Y2_LED_STAT_ON);\n}\n\nstatic void sky2_power_aux(struct sky2_hw *hw)\n{\n\tif (hw->chip_id == CHIP_ID_YUKON_XL && hw->chip_rev > CHIP_REV_YU_XL_A1)\n\t\tsky2_write8(hw, B2_Y2_CLK_GATE, 0);\n\telse\n\t\t \n\t\tsky2_write8(hw, B2_Y2_CLK_GATE,\n\t\t\t    Y2_PCI_CLK_LNK1_DIS | Y2_COR_CLK_LNK1_DIS |\n\t\t\t    Y2_CLK_GAT_LNK1_DIS | Y2_PCI_CLK_LNK2_DIS |\n\t\t\t    Y2_COR_CLK_LNK2_DIS | Y2_CLK_GAT_LNK2_DIS);\n\n\t \n\tif ( (sky2_read32(hw, B0_CTST) & Y2_VAUX_AVAIL) &&\n\t     pci_pme_capable(hw->pdev, PCI_D3cold))\n\t\tsky2_write8(hw, B0_POWER_CTRL,\n\t\t\t    (PC_VAUX_ENA | PC_VCC_ENA |\n\t\t\t     PC_VAUX_ON | PC_VCC_OFF));\n\n\t \n\tsky2_write16(hw, B0_CTST, Y2_LED_STAT_OFF);\n}\n\nstatic void sky2_gmac_reset(struct sky2_hw *hw, unsigned port)\n{\n\tu16 reg;\n\n\t \n\tsky2_write8(hw, SK_REG(port, GMAC_IRQ_MSK), 0);\n\n\tgma_write16(hw, port, GM_MC_ADDR_H1, 0);\t \n\tgma_write16(hw, port, GM_MC_ADDR_H2, 0);\n\tgma_write16(hw, port, GM_MC_ADDR_H3, 0);\n\tgma_write16(hw, port, GM_MC_ADDR_H4, 0);\n\n\treg = gma_read16(hw, port, GM_RX_CTRL);\n\treg |= GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA;\n\tgma_write16(hw, port, GM_RX_CTRL, reg);\n}\n\n \nstatic const u16 copper_fc_adv[] = {\n\t[FC_NONE]\t= 0,\n\t[FC_TX]\t\t= PHY_M_AN_ASP,\n\t[FC_RX]\t\t= PHY_M_AN_PC,\n\t[FC_BOTH]\t= PHY_M_AN_PC | PHY_M_AN_ASP,\n};\n\n \nstatic const u16 fiber_fc_adv[] = {\n\t[FC_NONE] = PHY_M_P_NO_PAUSE_X,\n\t[FC_TX]   = PHY_M_P_ASYM_MD_X,\n\t[FC_RX]\t  = PHY_M_P_SYM_MD_X,\n\t[FC_BOTH] = PHY_M_P_BOTH_MD_X,\n};\n\n \nstatic const u16 gm_fc_disable[] = {\n\t[FC_NONE] = GM_GPCR_FC_RX_DIS | GM_GPCR_FC_TX_DIS,\n\t[FC_TX]\t  = GM_GPCR_FC_RX_DIS,\n\t[FC_RX]\t  = GM_GPCR_FC_TX_DIS,\n\t[FC_BOTH] = 0,\n};\n\n\nstatic void sky2_phy_init(struct sky2_hw *hw, unsigned port)\n{\n\tstruct sky2_port *sky2 = netdev_priv(hw->dev[port]);\n\tu16 ctrl, ct1000, adv, pg, ledctrl, ledover, reg;\n\n\tif ( (sky2->flags & SKY2_FLAG_AUTO_SPEED) &&\n\t    !(hw->flags & SKY2_HW_NEWER_PHY)) {\n\t\tu16 ectrl = gm_phy_read(hw, port, PHY_MARV_EXT_CTRL);\n\n\t\tectrl &= ~(PHY_M_EC_M_DSC_MSK | PHY_M_EC_S_DSC_MSK |\n\t\t\t   PHY_M_EC_MAC_S_MSK);\n\t\tectrl |= PHY_M_EC_MAC_S(MAC_TX_CLK_25_MHZ);\n\n\t\t \n\t\tif (hw->chip_id == CHIP_ID_YUKON_EC)\n\t\t\t \n\t\t\tectrl |= PHY_M_EC_DSC_2(2) | PHY_M_EC_DOWN_S_ENA;\n\t\telse\n\t\t\t \n\t\t\tectrl |= PHY_M_EC_M_DSC(0) | PHY_M_EC_S_DSC(1);\n\n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_CTRL, ectrl);\n\t}\n\n\tctrl = gm_phy_read(hw, port, PHY_MARV_PHY_CTRL);\n\tif (sky2_is_copper(hw)) {\n\t\tif (!(hw->flags & SKY2_HW_GIGABIT)) {\n\t\t\t \n\t\t\tctrl |= PHY_M_PC_MDI_XMODE(PHY_M_PC_ENA_AUTO) >> 1;\n\n\t\t\tif (hw->chip_id == CHIP_ID_YUKON_FE_P &&\n\t\t\t    hw->chip_rev == CHIP_REV_YU_FE2_A0) {\n\t\t\t\tu16 spec;\n\n\t\t\t\t \n\t\t\t\tspec = gm_phy_read(hw, port, PHY_MARV_FE_SPEC_2);\n\t\t\t\tspec |= PHY_M_FESC_SEL_CL_A;\n\t\t\t\tgm_phy_write(hw, port, PHY_MARV_FE_SPEC_2, spec);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tctrl &= ~PHY_M_PC_EN_DET_MSK;\n\n\t\t\t \n\t\t\tctrl |= PHY_M_PC_MDI_XMODE(PHY_M_PC_ENA_AUTO);\n\n\t\t\t \n\t\t\tif ( (sky2->flags & SKY2_FLAG_AUTO_SPEED) &&\n\t\t\t     (hw->flags & SKY2_HW_NEWER_PHY)) {\n\t\t\t\t \n\t\t\t\tctrl &= ~PHY_M_PC_DSC_MSK;\n\t\t\t\tctrl |= PHY_M_PC_DSC(2) | PHY_M_PC_DOWN_S_ENA;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\t \n\n\t\tctrl &= ~PHY_M_PC_MDIX_MSK;\n\t}\n\n\tgm_phy_write(hw, port, PHY_MARV_PHY_CTRL, ctrl);\n\n\t \n\tif (hw->chip_id == CHIP_ID_YUKON_XL && (hw->flags & SKY2_HW_FIBRE_PHY)) {\n\t\tpg = gm_phy_read(hw, port, PHY_MARV_EXT_ADR);\n\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 2);\n\t\tctrl = gm_phy_read(hw, port, PHY_MARV_PHY_CTRL);\n\t\tctrl &= ~PHY_M_MAC_MD_MSK;\n\t\tctrl |= PHY_M_MAC_MODE_SEL(PHY_M_MAC_MD_1000BX);\n\t\tgm_phy_write(hw, port, PHY_MARV_PHY_CTRL, ctrl);\n\n\t\tif (hw->pmd_type  == 'P') {\n\t\t\t \n\t\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 1);\n\n\t\t\t \n\t\t\tctrl = gm_phy_read(hw, port, PHY_MARV_PHY_CTRL);\n\t\t\tctrl |= PHY_M_FIB_SIGD_POL;\n\t\t\tgm_phy_write(hw, port, PHY_MARV_PHY_CTRL, ctrl);\n\t\t}\n\n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, pg);\n\t}\n\n\tctrl = PHY_CT_RESET;\n\tct1000 = 0;\n\tadv = PHY_AN_CSMA;\n\treg = 0;\n\n\tif (sky2->flags & SKY2_FLAG_AUTO_SPEED) {\n\t\tif (sky2_is_copper(hw)) {\n\t\t\tif (sky2->advertising & ADVERTISED_1000baseT_Full)\n\t\t\t\tct1000 |= PHY_M_1000C_AFD;\n\t\t\tif (sky2->advertising & ADVERTISED_1000baseT_Half)\n\t\t\t\tct1000 |= PHY_M_1000C_AHD;\n\t\t\tif (sky2->advertising & ADVERTISED_100baseT_Full)\n\t\t\t\tadv |= PHY_M_AN_100_FD;\n\t\t\tif (sky2->advertising & ADVERTISED_100baseT_Half)\n\t\t\t\tadv |= PHY_M_AN_100_HD;\n\t\t\tif (sky2->advertising & ADVERTISED_10baseT_Full)\n\t\t\t\tadv |= PHY_M_AN_10_FD;\n\t\t\tif (sky2->advertising & ADVERTISED_10baseT_Half)\n\t\t\t\tadv |= PHY_M_AN_10_HD;\n\n\t\t} else {\t \n\t\t\tif (sky2->advertising & ADVERTISED_1000baseT_Full)\n\t\t\t\tadv |= PHY_M_AN_1000X_AFD;\n\t\t\tif (sky2->advertising & ADVERTISED_1000baseT_Half)\n\t\t\t\tadv |= PHY_M_AN_1000X_AHD;\n\t\t}\n\n\t\t \n\t\tctrl |= PHY_CT_ANE | PHY_CT_RE_CFG;\n\t} else {\n\t\t \n\t\tct1000 = PHY_M_1000C_MSE;\n\n\t\t \n\t\treg |= GM_GPCR_AU_DUP_DIS | GM_GPCR_AU_SPD_DIS;\n\n\t\tswitch (sky2->speed) {\n\t\tcase SPEED_1000:\n\t\t\tctrl |= PHY_CT_SP1000;\n\t\t\treg |= GM_GPCR_SPEED_1000;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tctrl |= PHY_CT_SP100;\n\t\t\treg |= GM_GPCR_SPEED_100;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sky2->duplex == DUPLEX_FULL) {\n\t\t\treg |= GM_GPCR_DUP_FULL;\n\t\t\tctrl |= PHY_CT_DUP_MD;\n\t\t} else if (sky2->speed < SPEED_1000)\n\t\t\tsky2->flow_mode = FC_NONE;\n\t}\n\n\tif (sky2->flags & SKY2_FLAG_AUTO_PAUSE) {\n\t\tif (sky2_is_copper(hw))\n\t\t\tadv |= copper_fc_adv[sky2->flow_mode];\n\t\telse\n\t\t\tadv |= fiber_fc_adv[sky2->flow_mode];\n\t} else {\n\t\treg |= GM_GPCR_AU_FCT_DIS;\n\t\treg |= gm_fc_disable[sky2->flow_mode];\n\n\t\t \n\t\tif (sky2->flow_mode & FC_RX)\n\t\t\tsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_PAUSE_ON);\n\t\telse\n\t\t\tsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_PAUSE_OFF);\n\t}\n\n\tgma_write16(hw, port, GM_GP_CTRL, reg);\n\n\tif (hw->flags & SKY2_HW_GIGABIT)\n\t\tgm_phy_write(hw, port, PHY_MARV_1000T_CTRL, ct1000);\n\n\tgm_phy_write(hw, port, PHY_MARV_AUNE_ADV, adv);\n\tgm_phy_write(hw, port, PHY_MARV_CTRL, ctrl);\n\n\t \n\tledctrl = PHY_M_LED_PULS_DUR(PULS_170MS);\n\tledover = 0;\n\n\tswitch (hw->chip_id) {\n\tcase CHIP_ID_YUKON_FE:\n\t\t \n\t\tledctrl |= PHY_M_LED_BLINK_RT(BLINK_84MS) << 1;\n\n\t\tctrl = gm_phy_read(hw, port, PHY_MARV_FE_LED_PAR);\n\n\t\t \n\t\tctrl &= ~PHY_M_FELP_LED1_MSK;\n\t\t \n\t\tctrl |= PHY_M_FELP_LED1_CTRL(LED_PAR_CTRL_ACT_BL);\n\t\tgm_phy_write(hw, port, PHY_MARV_FE_LED_PAR, ctrl);\n\t\tbreak;\n\n\tcase CHIP_ID_YUKON_FE_P:\n\t\t \n\t\tctrl = gm_phy_read(hw, port, PHY_MARV_PHY_CTRL);\n\t\tctrl |= PHY_M_PC_ENA_LIP_NP;\n\n\t\t \n\t\tctrl &= ~(PHY_M_PC_ENA_ENE_DT | PHY_M_PC_DIS_SCRAMB);\n\t\tgm_phy_write(hw, port, PHY_MARV_PHY_CTRL, ctrl);\n\n\t\t \n\t\tctrl = PHY_M_FELP_LED2_CTRL(LED_PAR_CTRL_ACT_BL) |\n\t\t\tPHY_M_FELP_LED1_CTRL(LED_PAR_CTRL_LINK) |\n\t\t\tPHY_M_FELP_LED0_CTRL(LED_PAR_CTRL_SPEED);\n\n\t\tgm_phy_write(hw, port, PHY_MARV_FE_LED_PAR, ctrl);\n\t\tbreak;\n\n\tcase CHIP_ID_YUKON_XL:\n\t\tpg = gm_phy_read(hw, port, PHY_MARV_EXT_ADR);\n\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 3);\n\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_PHY_CTRL,\n\t\t\t     (PHY_M_LEDC_LOS_CTRL(1) |\t \n\t\t\t      PHY_M_LEDC_INIT_CTRL(7) |\t \n\t\t\t      PHY_M_LEDC_STA1_CTRL(7) |\t \n\t\t\t      PHY_M_LEDC_STA0_CTRL(7)));\t \n\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_PHY_STAT,\n\t\t\t     (PHY_M_POLC_LS1_P_MIX(4) |\n\t\t\t      PHY_M_POLC_IS0_P_MIX(4) |\n\t\t\t      PHY_M_POLC_LOS_CTRL(2) |\n\t\t\t      PHY_M_POLC_INIT_CTRL(2) |\n\t\t\t      PHY_M_POLC_STA1_CTRL(2) |\n\t\t\t      PHY_M_POLC_STA0_CTRL(2)));\n\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, pg);\n\t\tbreak;\n\n\tcase CHIP_ID_YUKON_EC_U:\n\tcase CHIP_ID_YUKON_EX:\n\tcase CHIP_ID_YUKON_SUPR:\n\t\tpg = gm_phy_read(hw, port, PHY_MARV_EXT_ADR);\n\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 3);\n\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_PHY_CTRL,\n\t\t\t     (PHY_M_LEDC_LOS_CTRL(1) |\t \n\t\t\t      PHY_M_LEDC_INIT_CTRL(8) |\t \n\t\t\t      PHY_M_LEDC_STA1_CTRL(7) |\t \n\t\t\t      PHY_M_LEDC_STA0_CTRL(7))); \n\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_INT_MASK,\n\t\t\t     ledctrl | PHY_M_LED_BLINK_RT(BLINK_84MS));\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, pg);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tledctrl |= PHY_M_LED_BLINK_RT(BLINK_84MS) | PHY_M_LEDC_TX_CTRL;\n\n\t\t \n\t\tledover |= PHY_M_LED_MO_RX(MO_LED_OFF);\n\t}\n\n\tif (hw->chip_id == CHIP_ID_YUKON_EC_U || hw->chip_id == CHIP_ID_YUKON_UL_2) {\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 255);\n\n\t\t \n\t\tgm_phy_write(hw, port, 0x18, 0xaa99);\n\t\tgm_phy_write(hw, port, 0x17, 0x2011);\n\n\t\tif (hw->chip_id == CHIP_ID_YUKON_EC_U) {\n\t\t\t \n\t\t\tgm_phy_write(hw, port, 0x18, 0xa204);\n\t\t\tgm_phy_write(hw, port, 0x17, 0x2002);\n\t\t}\n\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0);\n\t} else if (hw->chip_id == CHIP_ID_YUKON_FE_P &&\n\t\t   hw->chip_rev == CHIP_REV_YU_FE2_A0) {\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_PAGE_ADDR, 17);\n\t\tgm_phy_write(hw, port, PHY_MARV_PAGE_DATA, 0x3f60);\n\t} else if (hw->chip_id == CHIP_ID_YUKON_OPT && hw->chip_rev == 0) {\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0x00ff);\n\n\t\t \n\t\tgm_phy_write(hw, port, 24, 0x2800);\n\t\tgm_phy_write(hw, port, 23, 0x2001);\n\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0);\n\t} else if (hw->chip_id != CHIP_ID_YUKON_EX &&\n\t\t   hw->chip_id < CHIP_ID_YUKON_SUPR) {\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_LED_CTRL, ledctrl);\n\n\t\tif (!(sky2->flags & SKY2_FLAG_AUTO_SPEED) ||\n\t\t    sky2->speed == SPEED_100) {\n\t\t\t \n\t\t\tledover |= PHY_M_LED_MO_100(MO_LED_ON);\n\t\t}\n\n\t\tif (ledover)\n\t\t\tgm_phy_write(hw, port, PHY_MARV_LED_OVER, ledover);\n\n\t} else if (hw->chip_id == CHIP_ID_YUKON_PRM &&\n\t\t   (sky2_read8(hw, B2_MAC_CFG) & 0xf) == 0x7) {\n\t\tint i;\n\t\t \n\t\tstatic const struct {\n\t\t\tu16 reg, val;\n\t\t} eee_afe[] = {\n\t\t\t{ 0x156, 0x58ce },\n\t\t\t{ 0x153, 0x99eb },\n\t\t\t{ 0x141, 0x8064 },\n\t\t\t \n\t\t\t{ 0x000, 0x0000 },\n\t\t\t{ 0x151, 0x8433 },\n\t\t\t{ 0x14b, 0x8c44 },\n\t\t\t{ 0x14c, 0x0f90 },\n\t\t\t{ 0x14f, 0x39aa },\n\t\t\t \n\t\t\t{ 0x14d, 0xba33 },\n\t\t\t{ 0x144, 0x0048 },\n\t\t\t{ 0x152, 0x2010 },\n\t\t\t \n\t\t\t{ 0x140, 0x4444 },\n\t\t\t{ 0x154, 0x2f3b },\n\t\t\t{ 0x158, 0xb203 },\n\t\t\t{ 0x157, 0x2029 },\n\t\t};\n\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0x00fb);\n\n\t\tgm_phy_write(hw, port,  1, 0x4099);\n\t\tgm_phy_write(hw, port,  3, 0x1120);\n\t\tgm_phy_write(hw, port, 11, 0x113c);\n\t\tgm_phy_write(hw, port, 14, 0x8100);\n\t\tgm_phy_write(hw, port, 15, 0x112a);\n\t\tgm_phy_write(hw, port, 17, 0x1008);\n\n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0x00fc);\n\t\tgm_phy_write(hw, port,  1, 0x20b0);\n\n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0x00ff);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(eee_afe); i++) {\n\t\t\t \n\t\t\tgm_phy_write(hw, port, 17, eee_afe[i].val);\n\t\t\tgm_phy_write(hw, port, 16, eee_afe[i].reg | 1u<<13);\n\t\t}\n\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0);\n\n\t\t \n\t\tif (hw->chip_id >= CHIP_ID_YUKON_PRM) {\n\t\t\treg = gm_phy_read(hw, port, PHY_MARV_EXT_CTRL);\n\t\t\tgm_phy_write(hw, port, PHY_MARV_EXT_CTRL,\n\t\t\t\t     reg | PHY_M_10B_TE_ENABLE);\n\t\t}\n\t}\n\n\t \n\tif (sky2->flags & SKY2_FLAG_AUTO_SPEED)\n\t\tgm_phy_write(hw, port, PHY_MARV_INT_MASK, PHY_M_IS_AN_COMPL);\n\telse\n\t\tgm_phy_write(hw, port, PHY_MARV_INT_MASK, PHY_M_DEF_MSK);\n}\n\nstatic const u32 phy_power[] = { PCI_Y2_PHY1_POWD, PCI_Y2_PHY2_POWD };\nstatic const u32 coma_mode[] = { PCI_Y2_PHY1_COMA, PCI_Y2_PHY2_COMA };\n\nstatic void sky2_phy_power_up(struct sky2_hw *hw, unsigned port)\n{\n\tu32 reg1;\n\n\tsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);\n\treg1 = sky2_pci_read32(hw, PCI_DEV_REG1);\n\treg1 &= ~phy_power[port];\n\n\tif (hw->chip_id == CHIP_ID_YUKON_XL && hw->chip_rev > CHIP_REV_YU_XL_A1)\n\t\treg1 |= coma_mode[port];\n\n\tsky2_pci_write32(hw, PCI_DEV_REG1, reg1);\n\tsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);\n\tsky2_pci_read32(hw, PCI_DEV_REG1);\n\n\tif (hw->chip_id == CHIP_ID_YUKON_FE)\n\t\tgm_phy_write(hw, port, PHY_MARV_CTRL, PHY_CT_ANE);\n\telse if (hw->flags & SKY2_HW_ADV_POWER_CTL)\n\t\tsky2_write8(hw, SK_REG(port, GPHY_CTRL), GPC_RST_CLR);\n}\n\nstatic void sky2_phy_power_down(struct sky2_hw *hw, unsigned port)\n{\n\tu32 reg1;\n\tu16 ctrl;\n\n\t \n\tsky2_write8(hw, SK_REG(port, GPHY_CTRL), GPC_RST_CLR);\n\n\t \n\tsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_RST_CLR);\n\n\tif (hw->flags & SKY2_HW_NEWER_PHY) {\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 2);\n\n\t\tctrl = gm_phy_read(hw, port, PHY_MARV_PHY_CTRL);\n\t\t \n\t\tctrl &= ~PHY_M_MAC_GMIF_PUP;\n\t\tgm_phy_write(hw, port, PHY_MARV_PHY_CTRL, ctrl);\n\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0);\n\t}\n\n\t \n\tgma_write16(hw, port, GM_GP_CTRL,\n\t\t    GM_GPCR_FL_PASS | GM_GPCR_SPEED_100 |\n\t\t    GM_GPCR_AU_DUP_DIS | GM_GPCR_AU_FCT_DIS |\n\t\t    GM_GPCR_AU_SPD_DIS);\n\n\tif (hw->chip_id != CHIP_ID_YUKON_EC) {\n\t\tif (hw->chip_id == CHIP_ID_YUKON_EC_U) {\n\t\t\t \n\t\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 2);\n\n\t\t\tctrl = gm_phy_read(hw, port, PHY_MARV_PHY_CTRL);\n\t\t\t \n\t\t\tctrl |= PHY_M_PC_POW_D_ENA;\n\t\t\tgm_phy_write(hw, port, PHY_MARV_PHY_CTRL, ctrl);\n\n\t\t\t \n\t\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 0);\n\t\t}\n\n\t\t \n\t\tgm_phy_write(hw, port, PHY_MARV_CTRL, PHY_CT_PDOWN);\n\t}\n\n\tsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);\n\treg1 = sky2_pci_read32(hw, PCI_DEV_REG1);\n\treg1 |= phy_power[port];\t\t \n\tsky2_pci_write32(hw, PCI_DEV_REG1, reg1);\n\tsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);\n}\n\n \nstatic void sky2_set_ipg(struct sky2_port *sky2)\n{\n\tu16 reg;\n\n\treg = gma_read16(sky2->hw, sky2->port, GM_SERIAL_MODE);\n\treg &= ~GM_SMOD_IPG_MSK;\n\tif (sky2->speed > SPEED_100)\n\t\treg |= IPG_DATA_VAL(IPG_DATA_DEF_1000);\n\telse\n\t\treg |= IPG_DATA_VAL(IPG_DATA_DEF_10_100);\n\tgma_write16(sky2->hw, sky2->port, GM_SERIAL_MODE, reg);\n}\n\n \nstatic void sky2_enable_rx_tx(struct sky2_port *sky2)\n{\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tu16 reg;\n\n\treg = gma_read16(hw, port, GM_GP_CTRL);\n\treg |= GM_GPCR_RX_ENA | GM_GPCR_TX_ENA;\n\tgma_write16(hw, port, GM_GP_CTRL, reg);\n}\n\n \nstatic void sky2_phy_reinit(struct sky2_port *sky2)\n{\n\tspin_lock_bh(&sky2->phy_lock);\n\tsky2_phy_init(sky2->hw, sky2->port);\n\tsky2_enable_rx_tx(sky2);\n\tspin_unlock_bh(&sky2->phy_lock);\n}\n\n \nstatic void sky2_wol_init(struct sky2_port *sky2)\n{\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tenum flow_control save_mode;\n\tu16 ctrl;\n\n\t \n\tsky2_write16(hw, B0_CTST, CS_RST_CLR);\n\tsky2_write16(hw, SK_REG(port, GMAC_LINK_CTRL), GMLC_RST_CLR);\n\n\tsky2_write8(hw, SK_REG(port, GPHY_CTRL), GPC_RST_CLR);\n\tsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_RST_CLR);\n\n\t \n\tsave_mode = sky2->flow_mode;\n\tctrl = sky2->advertising;\n\n\tsky2->advertising &= ~(ADVERTISED_1000baseT_Half|ADVERTISED_1000baseT_Full);\n\tsky2->flow_mode = FC_NONE;\n\n\tspin_lock_bh(&sky2->phy_lock);\n\tsky2_phy_power_up(hw, port);\n\tsky2_phy_init(hw, port);\n\tspin_unlock_bh(&sky2->phy_lock);\n\n\tsky2->flow_mode = save_mode;\n\tsky2->advertising = ctrl;\n\n\t \n\tgma_write16(hw, port, GM_GP_CTRL,\n\t\t    GM_GPCR_FC_TX_DIS|GM_GPCR_TX_ENA|GM_GPCR_RX_ENA|\n\t\t    GM_GPCR_DUP_FULL|GM_GPCR_FC_RX_DIS|GM_GPCR_AU_FCT_DIS);\n\n\t \n\tmemcpy_toio(hw->regs + WOL_REGS(port, WOL_MAC_ADDR),\n\t\t    sky2->netdev->dev_addr, ETH_ALEN);\n\n\t \n\tsky2_write16(hw, WOL_REGS(port, WOL_CTRL_STAT), WOL_CTL_CLEAR_RESULT);\n\tctrl = 0;\n\tif (sky2->wol & WAKE_PHY)\n\t\tctrl |= WOL_CTL_ENA_PME_ON_LINK_CHG|WOL_CTL_ENA_LINK_CHG_UNIT;\n\telse\n\t\tctrl |= WOL_CTL_DIS_PME_ON_LINK_CHG|WOL_CTL_DIS_LINK_CHG_UNIT;\n\n\tif (sky2->wol & WAKE_MAGIC)\n\t\tctrl |= WOL_CTL_ENA_PME_ON_MAGIC_PKT|WOL_CTL_ENA_MAGIC_PKT_UNIT;\n\telse\n\t\tctrl |= WOL_CTL_DIS_PME_ON_MAGIC_PKT|WOL_CTL_DIS_MAGIC_PKT_UNIT;\n\n\tctrl |= WOL_CTL_DIS_PME_ON_PATTERN|WOL_CTL_DIS_PATTERN_UNIT;\n\tsky2_write16(hw, WOL_REGS(port, WOL_CTRL_STAT), ctrl);\n\n\t \n\tsky2_write16(hw, B0_CTST, Y2_HW_WOL_OFF);\n\n\t \n\tif (legacy_pme) {\n\t\tu32 reg1 = sky2_pci_read32(hw, PCI_DEV_REG1);\n\t\treg1 |= PCI_Y2_PME_LEGACY;\n\t\tsky2_pci_write32(hw, PCI_DEV_REG1, reg1);\n\t}\n\n\t \n\tsky2_write8(hw, SK_REG(port, RX_GMF_CTRL_T), GMF_RST_SET);\n\tsky2_read32(hw, B0_CTST);\n}\n\nstatic void sky2_set_tx_stfwd(struct sky2_hw *hw, unsigned port)\n{\n\tstruct net_device *dev = hw->dev[port];\n\n\tif ( (hw->chip_id == CHIP_ID_YUKON_EX &&\n\t      hw->chip_rev != CHIP_REV_YU_EX_A0) ||\n\t     hw->chip_id >= CHIP_ID_YUKON_FE_P) {\n\t\t \n\t\tsky2_write32(hw, SK_REG(port, TX_GMF_CTRL_T), TX_STFW_ENA);\n\t} else if (dev->mtu > ETH_DATA_LEN) {\n\t\t \n\t\tsky2_write32(hw, SK_REG(port, TX_GMF_AE_THR),\n\t\t\t     (ECU_JUMBO_WM << 16) | ECU_AE_THR);\n\n\t\tsky2_write32(hw, SK_REG(port, TX_GMF_CTRL_T), TX_STFW_DIS);\n\t} else\n\t\tsky2_write32(hw, SK_REG(port, TX_GMF_CTRL_T), TX_STFW_ENA);\n}\n\nstatic void sky2_mac_init(struct sky2_hw *hw, unsigned port)\n{\n\tstruct sky2_port *sky2 = netdev_priv(hw->dev[port]);\n\tu16 reg;\n\tu32 rx_reg;\n\tint i;\n\tconst u8 *addr = hw->dev[port]->dev_addr;\n\n\tsky2_write8(hw, SK_REG(port, GPHY_CTRL), GPC_RST_SET);\n\tsky2_write8(hw, SK_REG(port, GPHY_CTRL), GPC_RST_CLR);\n\n\tsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_RST_CLR);\n\n\tif (hw->chip_id == CHIP_ID_YUKON_XL &&\n\t    hw->chip_rev == CHIP_REV_YU_XL_A0 &&\n\t    port == 1) {\n\t\t \n\t\t \n\t\tsky2_write8(hw, SK_REG(0, GMAC_CTRL), GMC_RST_CLR);\n\t\tdo {\n\t\t\tsky2_write8(hw, SK_REG(1, GMAC_CTRL), GMC_RST_SET);\n\t\t\tsky2_write8(hw, SK_REG(1, GMAC_CTRL), GMC_RST_CLR);\n\t\t} while (gm_phy_read(hw, 1, PHY_MARV_ID0) != PHY_MARV_ID0_VAL ||\n\t\t\t gm_phy_read(hw, 1, PHY_MARV_ID1) != PHY_MARV_ID1_Y2 ||\n\t\t\t gm_phy_read(hw, 1, PHY_MARV_INT_MASK) != 0);\n\t}\n\n\tsky2_read16(hw, SK_REG(port, GMAC_IRQ_SRC));\n\n\t \n\tsky2_write8(hw, SK_REG(port, GMAC_IRQ_MSK), GMAC_DEF_MSK);\n\n\tspin_lock_bh(&sky2->phy_lock);\n\tsky2_phy_power_up(hw, port);\n\tsky2_phy_init(hw, port);\n\tspin_unlock_bh(&sky2->phy_lock);\n\n\t \n\treg = gma_read16(hw, port, GM_PHY_ADDR);\n\tgma_write16(hw, port, GM_PHY_ADDR, reg | GM_PAR_MIB_CLR);\n\n\tfor (i = GM_MIB_CNT_BASE; i <= GM_MIB_CNT_END; i += 4)\n\t\tgma_read16(hw, port, i);\n\tgma_write16(hw, port, GM_PHY_ADDR, reg);\n\n\t \n\tgma_write16(hw, port, GM_TX_CTRL, TX_COL_THR(TX_COL_DEF));\n\n\t \n\tgma_write16(hw, port, GM_RX_CTRL,\n\t\t    GM_RXCR_UCF_ENA | GM_RXCR_CRC_DIS | GM_RXCR_MCF_ENA);\n\n\t \n\tgma_write16(hw, port, GM_TX_FLOW_CTRL, 0xffff);\n\n\t \n\tgma_write16(hw, port, GM_TX_PARAM,\n\t\t    TX_JAM_LEN_VAL(TX_JAM_LEN_DEF) |\n\t\t    TX_JAM_IPG_VAL(TX_JAM_IPG_DEF) |\n\t\t    TX_IPG_JAM_DATA(TX_IPG_JAM_DEF) |\n\t\t    TX_BACK_OFF_LIM(TX_BOF_LIM_DEF));\n\n\t \n\treg = DATA_BLIND_VAL(DATA_BLIND_DEF) |\n\t\tGM_SMOD_VLAN_ENA | IPG_DATA_VAL(IPG_DATA_DEF_1000);\n\n\tif (hw->dev[port]->mtu > ETH_DATA_LEN)\n\t\treg |= GM_SMOD_JUMBO_ENA;\n\n\tif (hw->chip_id == CHIP_ID_YUKON_EC_U &&\n\t    hw->chip_rev == CHIP_REV_YU_EC_U_B1)\n\t\treg |= GM_NEW_FLOW_CTRL;\n\n\tgma_write16(hw, port, GM_SERIAL_MODE, reg);\n\n\t \n\tgma_set_addr(hw, port, GM_SRC_ADDR_2L, addr);\n\n\t \n\tgma_set_addr(hw, port, GM_SRC_ADDR_1L, addr);\n\n\t \n\tgma_write16(hw, port, GM_TX_IRQ_MSK, 0);\n\tgma_write16(hw, port, GM_RX_IRQ_MSK, 0);\n\tgma_write16(hw, port, GM_TR_IRQ_MSK, 0);\n\n\t \n\tsky2_write8(hw, SK_REG(port, RX_GMF_CTRL_T), GMF_RST_CLR);\n\trx_reg = GMF_OPER_ON | GMF_RX_F_FL_ON;\n\tif (hw->chip_id == CHIP_ID_YUKON_EX ||\n\t    hw->chip_id == CHIP_ID_YUKON_FE_P)\n\t\trx_reg |= GMF_RX_OVER_ON;\n\n\tsky2_write32(hw, SK_REG(port, RX_GMF_CTRL_T), rx_reg);\n\n\tif (hw->chip_id == CHIP_ID_YUKON_XL) {\n\t\t \n\t\tsky2_write16(hw, SK_REG(port, RX_GMF_FL_MSK), 0);\n\t} else {\n\t\t \n\t\tsky2_write16(hw, SK_REG(port, RX_GMF_FL_MSK), GMR_FS_ANY_ERR);\n\t}\n\n\t \n\treg = RX_GMF_FL_THR_DEF + 1;\n\t \n\tif (hw->chip_id == CHIP_ID_YUKON_FE_P &&\n\t    hw->chip_rev == CHIP_REV_YU_FE2_A0)\n\t\treg = 0x178;\n\tsky2_write16(hw, SK_REG(port, RX_GMF_FL_THR), reg);\n\n\t \n\tsky2_write8(hw, SK_REG(port, TX_GMF_CTRL_T), GMF_RST_CLR);\n\tsky2_write16(hw, SK_REG(port, TX_GMF_CTRL_T), GMF_OPER_ON);\n\n\t \n\tif (!(hw->flags & SKY2_HW_RAM_BUFFER)) {\n\t\t \n\t\tif (hw->chip_id == CHIP_ID_YUKON_FE_P &&\n\t\t    hw->chip_rev == CHIP_REV_YU_FE2_A0)\n\t\t\treg = 1568 / 8;\n\t\telse\n\t\t\treg = 1024 / 8;\n\t\tsky2_write16(hw, SK_REG(port, RX_GMF_UP_THR), reg);\n\t\tsky2_write16(hw, SK_REG(port, RX_GMF_LP_THR), 768 / 8);\n\n\t\tsky2_set_tx_stfwd(hw, port);\n\t}\n\n\tif (hw->chip_id == CHIP_ID_YUKON_FE_P &&\n\t    hw->chip_rev == CHIP_REV_YU_FE2_A0) {\n\t\t \n\t\treg = sky2_read16(hw, SK_REG(port, TX_GMF_EA));\n\t\treg &= ~TX_DYN_WM_ENA;\n\t\tsky2_write16(hw, SK_REG(port, TX_GMF_EA), reg);\n\t}\n}\n\n \nstatic void sky2_ramset(struct sky2_hw *hw, u16 q, u32 start, u32 space)\n{\n\tu32 end;\n\n\t \n\tstart *= 1024/8;\n\tspace *= 1024/8;\n\tend = start + space - 1;\n\n\tsky2_write8(hw, RB_ADDR(q, RB_CTRL), RB_RST_CLR);\n\tsky2_write32(hw, RB_ADDR(q, RB_START), start);\n\tsky2_write32(hw, RB_ADDR(q, RB_END), end);\n\tsky2_write32(hw, RB_ADDR(q, RB_WP), start);\n\tsky2_write32(hw, RB_ADDR(q, RB_RP), start);\n\n\tif (q == Q_R1 || q == Q_R2) {\n\t\tu32 tp = space - space/4;\n\n\t\t \n\t\tsky2_write32(hw, RB_ADDR(q, RB_RX_UTHP), tp);\n\t\tsky2_write32(hw, RB_ADDR(q, RB_RX_LTHP), space/2);\n\n\t\ttp = space - 8192/8;\n\t\tsky2_write32(hw, RB_ADDR(q, RB_RX_UTPP), tp);\n\t\tsky2_write32(hw, RB_ADDR(q, RB_RX_LTPP), space/4);\n\t} else {\n\t\t \n\t\tsky2_write8(hw, RB_ADDR(q, RB_CTRL), RB_ENA_STFWD);\n\t}\n\n\tsky2_write8(hw, RB_ADDR(q, RB_CTRL), RB_ENA_OP_MD);\n\tsky2_read8(hw, RB_ADDR(q, RB_CTRL));\n}\n\n \nstatic void sky2_qset(struct sky2_hw *hw, u16 q)\n{\n\tsky2_write32(hw, Q_ADDR(q, Q_CSR), BMU_CLR_RESET);\n\tsky2_write32(hw, Q_ADDR(q, Q_CSR), BMU_OPER_INIT);\n\tsky2_write32(hw, Q_ADDR(q, Q_CSR), BMU_FIFO_OP_ON);\n\tsky2_write32(hw, Q_ADDR(q, Q_WM),  BMU_WM_DEFAULT);\n}\n\n \nstatic void sky2_prefetch_init(struct sky2_hw *hw, u32 qaddr,\n\t\t\t       dma_addr_t addr, u32 last)\n{\n\tsky2_write32(hw, Y2_QADDR(qaddr, PREF_UNIT_CTRL), PREF_UNIT_RST_SET);\n\tsky2_write32(hw, Y2_QADDR(qaddr, PREF_UNIT_CTRL), PREF_UNIT_RST_CLR);\n\tsky2_write32(hw, Y2_QADDR(qaddr, PREF_UNIT_ADDR_HI), upper_32_bits(addr));\n\tsky2_write32(hw, Y2_QADDR(qaddr, PREF_UNIT_ADDR_LO), lower_32_bits(addr));\n\tsky2_write16(hw, Y2_QADDR(qaddr, PREF_UNIT_LAST_IDX), last);\n\tsky2_write32(hw, Y2_QADDR(qaddr, PREF_UNIT_CTRL), PREF_UNIT_OP_ON);\n\n\tsky2_read32(hw, Y2_QADDR(qaddr, PREF_UNIT_CTRL));\n}\n\nstatic inline struct sky2_tx_le *get_tx_le(struct sky2_port *sky2, u16 *slot)\n{\n\tstruct sky2_tx_le *le = sky2->tx_le + *slot;\n\n\t*slot = RING_NEXT(*slot, sky2->tx_ring_size);\n\tle->ctrl = 0;\n\treturn le;\n}\n\nstatic void tx_init(struct sky2_port *sky2)\n{\n\tstruct sky2_tx_le *le;\n\n\tsky2->tx_prod = sky2->tx_cons = 0;\n\tsky2->tx_tcpsum = 0;\n\tsky2->tx_last_mss = 0;\n\tnetdev_reset_queue(sky2->netdev);\n\n\tle = get_tx_le(sky2, &sky2->tx_prod);\n\tle->addr = 0;\n\tle->opcode = OP_ADDR64 | HW_OWNER;\n\tsky2->tx_last_upper = 0;\n}\n\n \nstatic inline void sky2_put_idx(struct sky2_hw *hw, unsigned q, u16 idx)\n{\n\t \n\twmb();\n\tsky2_write16(hw, Y2_QADDR(q, PREF_UNIT_PUT_IDX), idx);\n}\n\n\nstatic inline struct sky2_rx_le *sky2_next_rx(struct sky2_port *sky2)\n{\n\tstruct sky2_rx_le *le = sky2->rx_le + sky2->rx_put;\n\tsky2->rx_put = RING_NEXT(sky2->rx_put, RX_LE_SIZE);\n\tle->ctrl = 0;\n\treturn le;\n}\n\nstatic unsigned sky2_get_rx_threshold(struct sky2_port *sky2)\n{\n\tunsigned size;\n\n\t \n\tsize = roundup(sky2->netdev->mtu + ETH_HLEN + VLAN_HLEN, 8);\n\n\t \n\treturn (size - 8) / sizeof(u32);\n}\n\nstatic unsigned sky2_get_rx_data_size(struct sky2_port *sky2)\n{\n\tstruct rx_ring_info *re;\n\tunsigned size;\n\n\t \n\tsize = roundup(sky2->netdev->mtu + ETH_HLEN + VLAN_HLEN, 8);\n\n\tsky2->rx_nfrags = size >> PAGE_SHIFT;\n\tBUG_ON(sky2->rx_nfrags > ARRAY_SIZE(re->frag_addr));\n\n\t \n\tsize -= sky2->rx_nfrags << PAGE_SHIFT;\n\n\t \n\tif (size < copybreak)\n\t\tsize = copybreak;\n\tif (size < ETH_HLEN)\n\t\tsize = ETH_HLEN;\n\n\treturn size;\n}\n\n \nstatic void sky2_rx_add(struct sky2_port *sky2, u8 op,\n\t\t\tdma_addr_t map, unsigned len)\n{\n\tstruct sky2_rx_le *le;\n\n\tif (sizeof(dma_addr_t) > sizeof(u32)) {\n\t\tle = sky2_next_rx(sky2);\n\t\tle->addr = cpu_to_le32(upper_32_bits(map));\n\t\tle->opcode = OP_ADDR64 | HW_OWNER;\n\t}\n\n\tle = sky2_next_rx(sky2);\n\tle->addr = cpu_to_le32(lower_32_bits(map));\n\tle->length = cpu_to_le16(len);\n\tle->opcode = op | HW_OWNER;\n}\n\n \nstatic void sky2_rx_submit(struct sky2_port *sky2,\n\t\t\t   const struct rx_ring_info *re)\n{\n\tint i;\n\n\tsky2_rx_add(sky2, OP_PACKET, re->data_addr, sky2->rx_data_size);\n\n\tfor (i = 0; i < skb_shinfo(re->skb)->nr_frags; i++)\n\t\tsky2_rx_add(sky2, OP_BUFFER, re->frag_addr[i], PAGE_SIZE);\n}\n\n\nstatic int sky2_rx_map_skb(struct pci_dev *pdev, struct rx_ring_info *re,\n\t\t\t    unsigned size)\n{\n\tstruct sk_buff *skb = re->skb;\n\tint i;\n\n\tre->data_addr = dma_map_single(&pdev->dev, skb->data, size,\n\t\t\t\t       DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&pdev->dev, re->data_addr))\n\t\tgoto mapping_error;\n\n\tdma_unmap_len_set(re, data_size, size);\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tre->frag_addr[i] = skb_frag_dma_map(&pdev->dev, frag, 0,\n\t\t\t\t\t\t    skb_frag_size(frag),\n\t\t\t\t\t\t    DMA_FROM_DEVICE);\n\n\t\tif (dma_mapping_error(&pdev->dev, re->frag_addr[i]))\n\t\t\tgoto map_page_error;\n\t}\n\treturn 0;\n\nmap_page_error:\n\twhile (--i >= 0) {\n\t\tdma_unmap_page(&pdev->dev, re->frag_addr[i],\n\t\t\t       skb_frag_size(&skb_shinfo(skb)->frags[i]),\n\t\t\t       DMA_FROM_DEVICE);\n\t}\n\n\tdma_unmap_single(&pdev->dev, re->data_addr,\n\t\t\t dma_unmap_len(re, data_size), DMA_FROM_DEVICE);\n\nmapping_error:\n\tif (net_ratelimit())\n\t\tdev_warn(&pdev->dev, \"%s: rx mapping error\\n\",\n\t\t\t skb->dev->name);\n\treturn -EIO;\n}\n\nstatic void sky2_rx_unmap_skb(struct pci_dev *pdev, struct rx_ring_info *re)\n{\n\tstruct sk_buff *skb = re->skb;\n\tint i;\n\n\tdma_unmap_single(&pdev->dev, re->data_addr,\n\t\t\t dma_unmap_len(re, data_size), DMA_FROM_DEVICE);\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++)\n\t\tdma_unmap_page(&pdev->dev, re->frag_addr[i],\n\t\t\t       skb_frag_size(&skb_shinfo(skb)->frags[i]),\n\t\t\t       DMA_FROM_DEVICE);\n}\n\n \nstatic void rx_set_checksum(struct sky2_port *sky2)\n{\n\tstruct sky2_rx_le *le = sky2_next_rx(sky2);\n\n\tle->addr = cpu_to_le32((ETH_HLEN << 16) | ETH_HLEN);\n\tle->ctrl = 0;\n\tle->opcode = OP_TCPSTART | HW_OWNER;\n\n\tsky2_write32(sky2->hw,\n\t\t     Q_ADDR(rxqaddr[sky2->port], Q_CSR),\n\t\t     (sky2->netdev->features & NETIF_F_RXCSUM)\n\t\t     ? BMU_ENA_RX_CHKSUM : BMU_DIS_RX_CHKSUM);\n}\n\n \nstatic void rx_set_rss(struct net_device *dev, netdev_features_t features)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tint i, nkeys = 4;\n\n\t \n\tif (hw->flags & SKY2_HW_NEW_LE) {\n\t\tnkeys = 10;\n\t\tsky2_write32(hw, SK_REG(sky2->port, RSS_CFG), HASH_ALL);\n\t}\n\n\t \n\tif (features & NETIF_F_RXHASH) {\n\t\tu32 rss_key[10];\n\n\t\tnetdev_rss_key_fill(rss_key, sizeof(rss_key));\n\t\tfor (i = 0; i < nkeys; i++)\n\t\t\tsky2_write32(hw, SK_REG(sky2->port, RSS_KEY + i * 4),\n\t\t\t\t     rss_key[i]);\n\n\t\t \n\t\tsky2_write32(hw, SK_REG(sky2->port, RX_GMF_CTRL_T),\n\t\t\t     RX_STFW_ENA);\n\n\t\tsky2_write32(hw, Q_ADDR(rxqaddr[sky2->port], Q_CSR),\n\t\t\t     BMU_ENA_RX_RSS_HASH);\n\t} else\n\t\tsky2_write32(hw, Q_ADDR(rxqaddr[sky2->port], Q_CSR),\n\t\t\t     BMU_DIS_RX_RSS_HASH);\n}\n\n \nstatic void sky2_rx_stop(struct sky2_port *sky2)\n{\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned rxq = rxqaddr[sky2->port];\n\tint i;\n\n\t \n\tsky2_write8(hw, RB_ADDR(rxq, RB_CTRL), RB_DIS_OP_MD);\n\n\tfor (i = 0; i < 0xffff; i++)\n\t\tif (sky2_read8(hw, RB_ADDR(rxq, Q_RSL))\n\t\t    == sky2_read8(hw, RB_ADDR(rxq, Q_RL)))\n\t\t\tgoto stopped;\n\n\tnetdev_warn(sky2->netdev, \"receiver stop failed\\n\");\nstopped:\n\tsky2_write32(hw, Q_ADDR(rxq, Q_CSR), BMU_RST_SET | BMU_FIFO_RST);\n\n\t \n\tsky2_write32(hw, Y2_QADDR(rxq, PREF_UNIT_CTRL), PREF_UNIT_RST_SET);\n}\n\n \nstatic void sky2_rx_clean(struct sky2_port *sky2)\n{\n\tunsigned i;\n\n\tif (sky2->rx_le)\n\t\tmemset(sky2->rx_le, 0, RX_LE_BYTES);\n\n\tfor (i = 0; i < sky2->rx_pending; i++) {\n\t\tstruct rx_ring_info *re = sky2->rx_ring + i;\n\n\t\tif (re->skb) {\n\t\t\tsky2_rx_unmap_skb(sky2->hw->pdev, re);\n\t\t\tkfree_skb(re->skb);\n\t\t\tre->skb = NULL;\n\t\t}\n\t}\n}\n\n \nstatic int sky2_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tint err = -EOPNOTSUPP;\n\n\tif (!netif_running(dev))\n\t\treturn -ENODEV;\t \n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tdata->phy_id = PHY_ADDR_MARV;\n\n\t\tfallthrough;\n\tcase SIOCGMIIREG: {\n\t\tu16 val = 0;\n\n\t\tspin_lock_bh(&sky2->phy_lock);\n\t\terr = __gm_phy_read(hw, sky2->port, data->reg_num & 0x1f, &val);\n\t\tspin_unlock_bh(&sky2->phy_lock);\n\n\t\tdata->val_out = val;\n\t\tbreak;\n\t}\n\n\tcase SIOCSMIIREG:\n\t\tspin_lock_bh(&sky2->phy_lock);\n\t\terr = gm_phy_write(hw, sky2->port, data->reg_num & 0x1f,\n\t\t\t\t   data->val_in);\n\t\tspin_unlock_bh(&sky2->phy_lock);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\n#define SKY2_VLAN_OFFLOADS (NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_TSO)\n\nstatic void sky2_vlan_mode(struct net_device *dev, netdev_features_t features)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tu16 port = sky2->port;\n\n\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tsky2_write32(hw, SK_REG(port, RX_GMF_CTRL_T),\n\t\t\t     RX_VLAN_STRIP_ON);\n\telse\n\t\tsky2_write32(hw, SK_REG(port, RX_GMF_CTRL_T),\n\t\t\t     RX_VLAN_STRIP_OFF);\n\n\tif (features & NETIF_F_HW_VLAN_CTAG_TX) {\n\t\tsky2_write32(hw, SK_REG(port, TX_GMF_CTRL_T),\n\t\t\t     TX_VLAN_TAG_ON);\n\n\t\tdev->vlan_features |= SKY2_VLAN_OFFLOADS;\n\t} else {\n\t\tsky2_write32(hw, SK_REG(port, TX_GMF_CTRL_T),\n\t\t\t     TX_VLAN_TAG_OFF);\n\n\t\t \n\t\tdev->vlan_features &= ~SKY2_VLAN_OFFLOADS;\n\t}\n}\n\n \nstatic inline unsigned sky2_rx_pad(const struct sky2_hw *hw)\n{\n\treturn (hw->flags & SKY2_HW_RAM_BUFFER) ? 8 : 2;\n}\n\n \nstatic struct sk_buff *sky2_rx_alloc(struct sky2_port *sky2, gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tint i;\n\n\tskb = __netdev_alloc_skb(sky2->netdev,\n\t\t\t\t sky2->rx_data_size + sky2_rx_pad(sky2->hw),\n\t\t\t\t gfp);\n\tif (!skb)\n\t\tgoto nomem;\n\n\tif (sky2->hw->flags & SKY2_HW_RAM_BUFFER) {\n\t\tunsigned char *start;\n\t\t \n\t\tstart = PTR_ALIGN(skb->data, 8);\n\t\tskb_reserve(skb, start - skb->data);\n\t} else\n\t\tskb_reserve(skb, NET_IP_ALIGN);\n\n\tfor (i = 0; i < sky2->rx_nfrags; i++) {\n\t\tstruct page *page = alloc_page(gfp);\n\n\t\tif (!page)\n\t\t\tgoto free_partial;\n\t\tskb_fill_page_desc(skb, i, page, 0, PAGE_SIZE);\n\t}\n\n\treturn skb;\nfree_partial:\n\tkfree_skb(skb);\nnomem:\n\treturn NULL;\n}\n\nstatic inline void sky2_rx_update(struct sky2_port *sky2, unsigned rxq)\n{\n\tsky2_put_idx(sky2->hw, rxq, sky2->rx_put);\n}\n\nstatic int sky2_alloc_rx_skbs(struct sky2_port *sky2)\n{\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned i;\n\n\tsky2->rx_data_size = sky2_get_rx_data_size(sky2);\n\n\t \n\tfor (i = 0; i < sky2->rx_pending; i++) {\n\t\tstruct rx_ring_info *re = sky2->rx_ring + i;\n\n\t\tre->skb = sky2_rx_alloc(sky2, GFP_KERNEL);\n\t\tif (!re->skb)\n\t\t\treturn -ENOMEM;\n\n\t\tif (sky2_rx_map_skb(hw->pdev, re, sky2->rx_data_size)) {\n\t\t\tdev_kfree_skb(re->skb);\n\t\t\tre->skb = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void sky2_rx_start(struct sky2_port *sky2)\n{\n\tstruct sky2_hw *hw = sky2->hw;\n\tstruct rx_ring_info *re;\n\tunsigned rxq = rxqaddr[sky2->port];\n\tunsigned i, thresh;\n\n\tsky2->rx_put = sky2->rx_next = 0;\n\tsky2_qset(hw, rxq);\n\n\t \n\tif (pci_is_pcie(hw->pdev))\n\t\tsky2_write32(hw, Q_ADDR(rxq, Q_WM), BMU_WM_PEX);\n\n\t \n\tif (hw->chip_id == CHIP_ID_YUKON_EC_U &&\n\t    hw->chip_rev > CHIP_REV_YU_EC_U_A0)\n\t\tsky2_write32(hw, Q_ADDR(rxq, Q_TEST), F_M_RX_RAM_DIS);\n\n\tsky2_prefetch_init(hw, rxq, sky2->rx_le_map, RX_LE_SIZE - 1);\n\n\tif (!(hw->flags & SKY2_HW_NEW_LE))\n\t\trx_set_checksum(sky2);\n\n\tif (!(hw->flags & SKY2_HW_RSS_BROKEN))\n\t\trx_set_rss(sky2->netdev, sky2->netdev->features);\n\n\t \n\tfor (i = 0; i < sky2->rx_pending; i++) {\n\t\tre = sky2->rx_ring + i;\n\t\tsky2_rx_submit(sky2, re);\n\t}\n\n\t \n\tthresh = sky2_get_rx_threshold(sky2);\n\tif (thresh > 0x1ff)\n\t\tsky2_write32(hw, SK_REG(sky2->port, RX_GMF_CTRL_T), RX_TRUNC_OFF);\n\telse {\n\t\tsky2_write16(hw, SK_REG(sky2->port, RX_GMF_TR_THR), thresh);\n\t\tsky2_write32(hw, SK_REG(sky2->port, RX_GMF_CTRL_T), RX_TRUNC_ON);\n\t}\n\n\t \n\tsky2_rx_update(sky2, rxq);\n\n\tif (hw->chip_id == CHIP_ID_YUKON_EX ||\n\t    hw->chip_id == CHIP_ID_YUKON_SUPR) {\n\t\t \n\t\tsky2_write32(hw, SK_REG(sky2->port, RX_GMF_CTRL_T), RX_MACSEC_FLUSH_OFF);\n\t}\n\n\tif (hw->chip_id >= CHIP_ID_YUKON_SUPR) {\n\t\t \n\t\tsky2_write16(hw, SK_REG(sky2->port, RX_GMF_FL_CTRL),\n\t\t\t     RX_IPV6_SA_MOB_ENA | RX_IPV6_DA_MOB_ENA);\n\n\t\t \n\t\tsky2_write32(hw, Q_ADDR(txqaddr[sky2->port], Q_TEST),\n\t\t\t     TBMU_TEST_HOME_ADD_FIX_EN | TBMU_TEST_ROUTING_ADD_FIX_EN);\n\t}\n}\n\nstatic int sky2_alloc_buffers(struct sky2_port *sky2)\n{\n\tstruct sky2_hw *hw = sky2->hw;\n\n\t \n\tsky2->tx_le = dma_alloc_coherent(&hw->pdev->dev,\n\t\t\t\t\t sky2->tx_ring_size * sizeof(struct sky2_tx_le),\n\t\t\t\t\t &sky2->tx_le_map, GFP_KERNEL);\n\tif (!sky2->tx_le)\n\t\tgoto nomem;\n\n\tsky2->tx_ring = kcalloc(sky2->tx_ring_size, sizeof(struct tx_ring_info),\n\t\t\t\tGFP_KERNEL);\n\tif (!sky2->tx_ring)\n\t\tgoto nomem;\n\n\tsky2->rx_le = dma_alloc_coherent(&hw->pdev->dev, RX_LE_BYTES,\n\t\t\t\t\t &sky2->rx_le_map, GFP_KERNEL);\n\tif (!sky2->rx_le)\n\t\tgoto nomem;\n\n\tsky2->rx_ring = kcalloc(sky2->rx_pending, sizeof(struct rx_ring_info),\n\t\t\t\tGFP_KERNEL);\n\tif (!sky2->rx_ring)\n\t\tgoto nomem;\n\n\treturn sky2_alloc_rx_skbs(sky2);\nnomem:\n\treturn -ENOMEM;\n}\n\nstatic void sky2_free_buffers(struct sky2_port *sky2)\n{\n\tstruct sky2_hw *hw = sky2->hw;\n\n\tsky2_rx_clean(sky2);\n\n\tif (sky2->rx_le) {\n\t\tdma_free_coherent(&hw->pdev->dev, RX_LE_BYTES, sky2->rx_le,\n\t\t\t\t  sky2->rx_le_map);\n\t\tsky2->rx_le = NULL;\n\t}\n\tif (sky2->tx_le) {\n\t\tdma_free_coherent(&hw->pdev->dev,\n\t\t\t\t  sky2->tx_ring_size * sizeof(struct sky2_tx_le),\n\t\t\t\t  sky2->tx_le, sky2->tx_le_map);\n\t\tsky2->tx_le = NULL;\n\t}\n\tkfree(sky2->tx_ring);\n\tkfree(sky2->rx_ring);\n\n\tsky2->tx_ring = NULL;\n\tsky2->rx_ring = NULL;\n}\n\nstatic void sky2_hw_up(struct sky2_port *sky2)\n{\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tu32 ramsize;\n\tint cap;\n\tstruct net_device *otherdev = hw->dev[sky2->port^1];\n\n\ttx_init(sky2);\n\n\t \n\tif (otherdev && netif_running(otherdev) &&\n\t    (cap = pci_find_capability(hw->pdev, PCI_CAP_ID_PCIX))) {\n\t\tu16 cmd;\n\n\t\tcmd = sky2_pci_read16(hw, cap + PCI_X_CMD);\n\t\tcmd &= ~PCI_X_CMD_MAX_SPLIT;\n\t\tsky2_pci_write16(hw, cap + PCI_X_CMD, cmd);\n\t}\n\n\tsky2_mac_init(hw, port);\n\n\t \n\tramsize = sky2_read8(hw, B2_E_0) * 4;\n\tif (ramsize > 0) {\n\t\tu32 rxspace;\n\n\t\tnetdev_dbg(sky2->netdev, \"ram buffer %dK\\n\", ramsize);\n\t\tif (ramsize < 16)\n\t\t\trxspace = ramsize / 2;\n\t\telse\n\t\t\trxspace = 8 + (2*(ramsize - 16))/3;\n\n\t\tsky2_ramset(hw, rxqaddr[port], 0, rxspace);\n\t\tsky2_ramset(hw, txqaddr[port], rxspace, ramsize - rxspace);\n\n\t\t \n\t\tsky2_write8(hw, RB_ADDR(port == 0 ? Q_XS1 : Q_XS2, RB_CTRL),\n\t\t\t    RB_RST_SET);\n\t}\n\n\tsky2_qset(hw, txqaddr[port]);\n\n\t \n\tif (hw->chip_id == CHIP_ID_YUKON_EX && hw->chip_rev == CHIP_REV_YU_EX_B0)\n\t\tsky2_write32(hw, Q_ADDR(txqaddr[port], Q_TEST), F_TX_CHK_AUTO_OFF);\n\n\t \n\tif (hw->chip_id == CHIP_ID_YUKON_EC_U &&\n\t    hw->chip_rev == CHIP_REV_YU_EC_U_A0)\n\t\tsky2_write16(hw, Q_ADDR(txqaddr[port], Q_AL), ECU_TXFF_LEV);\n\n\tsky2_prefetch_init(hw, txqaddr[port], sky2->tx_le_map,\n\t\t\t   sky2->tx_ring_size - 1);\n\n\tsky2_vlan_mode(sky2->netdev, sky2->netdev->features);\n\tnetdev_update_features(sky2->netdev);\n\n\tsky2_rx_start(sky2);\n}\n\n \nstatic int sky2_setup_irq(struct sky2_hw *hw, const char *name)\n{\n\tstruct pci_dev *pdev = hw->pdev;\n\tint err;\n\n\terr = request_irq(pdev->irq, sky2_intr,\n\t\t\t  (hw->flags & SKY2_HW_USE_MSI) ? 0 : IRQF_SHARED,\n\t\t\t  name, hw);\n\tif (err)\n\t\tdev_err(&pdev->dev, \"cannot assign irq %d\\n\", pdev->irq);\n\telse {\n\t\thw->flags |= SKY2_HW_IRQ_SETUP;\n\n\t\tnapi_enable(&hw->napi);\n\t\tsky2_write32(hw, B0_IMSK, Y2_IS_BASE);\n\t\tsky2_read32(hw, B0_IMSK);\n\t}\n\n\treturn err;\n}\n\n\n \nstatic int sky2_open(struct net_device *dev)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tu32 imask;\n\tint err;\n\n\tnetif_carrier_off(dev);\n\n\terr = sky2_alloc_buffers(sky2);\n\tif (err)\n\t\tgoto err_out;\n\n\t \n\tif (hw->ports == 1 && (err = sky2_setup_irq(hw, dev->name)))\n\t\tgoto err_out;\n\n\tsky2_hw_up(sky2);\n\n\t \n\timask = sky2_read32(hw, B0_IMSK);\n\n\tif (hw->chip_id == CHIP_ID_YUKON_OPT ||\n\t    hw->chip_id == CHIP_ID_YUKON_PRM ||\n\t    hw->chip_id == CHIP_ID_YUKON_OP_2)\n\t\timask |= Y2_IS_PHY_QLNK;\t \n\n\timask |= portirq_msk[port];\n\tsky2_write32(hw, B0_IMSK, imask);\n\tsky2_read32(hw, B0_IMSK);\n\n\tnetif_info(sky2, ifup, dev, \"enabling interface\\n\");\n\n\treturn 0;\n\nerr_out:\n\tsky2_free_buffers(sky2);\n\treturn err;\n}\n\n \nstatic inline int tx_inuse(const struct sky2_port *sky2)\n{\n\treturn (sky2->tx_prod - sky2->tx_cons) & (sky2->tx_ring_size - 1);\n}\n\n \nstatic inline int tx_avail(const struct sky2_port *sky2)\n{\n\treturn sky2->tx_pending - tx_inuse(sky2);\n}\n\n \nstatic unsigned tx_le_req(const struct sk_buff *skb)\n{\n\tunsigned count;\n\n\tcount = (skb_shinfo(skb)->nr_frags + 1)\n\t\t* (sizeof(dma_addr_t) / sizeof(u32));\n\n\tif (skb_is_gso(skb))\n\t\t++count;\n\telse if (sizeof(dma_addr_t) == sizeof(u32))\n\t\t++count;\t \n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t++count;\n\n\treturn count;\n}\n\nstatic void sky2_tx_unmap(struct pci_dev *pdev, struct tx_ring_info *re)\n{\n\tif (re->flags & TX_MAP_SINGLE)\n\t\tdma_unmap_single(&pdev->dev, dma_unmap_addr(re, mapaddr),\n\t\t\t\t dma_unmap_len(re, maplen), DMA_TO_DEVICE);\n\telse if (re->flags & TX_MAP_PAGE)\n\t\tdma_unmap_page(&pdev->dev, dma_unmap_addr(re, mapaddr),\n\t\t\t       dma_unmap_len(re, maplen), DMA_TO_DEVICE);\n\tre->flags = 0;\n}\n\n \nstatic netdev_tx_t sky2_xmit_frame(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tstruct sky2_tx_le *le = NULL;\n\tstruct tx_ring_info *re;\n\tunsigned i, len;\n\tdma_addr_t mapping;\n\tu32 upper;\n\tu16 slot;\n\tu16 mss;\n\tu8 ctrl;\n\n\tif (unlikely(tx_avail(sky2) < tx_le_req(skb)))\n\t\treturn NETDEV_TX_BUSY;\n\n\tlen = skb_headlen(skb);\n\tmapping = dma_map_single(&hw->pdev->dev, skb->data, len,\n\t\t\t\t DMA_TO_DEVICE);\n\n\tif (dma_mapping_error(&hw->pdev->dev, mapping))\n\t\tgoto mapping_error;\n\n\tslot = sky2->tx_prod;\n\tnetif_printk(sky2, tx_queued, KERN_DEBUG, dev,\n\t\t     \"tx queued, slot %u, len %d\\n\", slot, skb->len);\n\n\t \n\tupper = upper_32_bits(mapping);\n\tif (upper != sky2->tx_last_upper) {\n\t\tle = get_tx_le(sky2, &slot);\n\t\tle->addr = cpu_to_le32(upper);\n\t\tsky2->tx_last_upper = upper;\n\t\tle->opcode = OP_ADDR64 | HW_OWNER;\n\t}\n\n\t \n\tmss = skb_shinfo(skb)->gso_size;\n\tif (mss != 0) {\n\n\t\tif (!(hw->flags & SKY2_HW_NEW_LE))\n\t\t\tmss += skb_tcp_all_headers(skb);\n\n\t\tif (mss != sky2->tx_last_mss) {\n\t\t\tle = get_tx_le(sky2, &slot);\n\t\t\tle->addr = cpu_to_le32(mss);\n\n\t\t\tif (hw->flags & SKY2_HW_NEW_LE)\n\t\t\t\tle->opcode = OP_MSS | HW_OWNER;\n\t\t\telse\n\t\t\t\tle->opcode = OP_LRGLEN | HW_OWNER;\n\t\t\tsky2->tx_last_mss = mss;\n\t\t}\n\t}\n\n\tctrl = 0;\n\n\t \n\tif (skb_vlan_tag_present(skb)) {\n\t\tif (!le) {\n\t\t\tle = get_tx_le(sky2, &slot);\n\t\t\tle->addr = 0;\n\t\t\tle->opcode = OP_VLAN|HW_OWNER;\n\t\t} else\n\t\t\tle->opcode |= OP_VLAN;\n\t\tle->length = cpu_to_be16(skb_vlan_tag_get(skb));\n\t\tctrl |= INS_VLAN;\n\t}\n\n\t \n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t \n\t\tif (hw->flags & SKY2_HW_AUTO_TX_SUM)\n\t\t\tctrl |= CALSUM;\t \n\t\telse {\n\t\t\tconst unsigned offset = skb_transport_offset(skb);\n\t\t\tu32 tcpsum;\n\n\t\t\ttcpsum = offset << 16;\t\t\t \n\t\t\ttcpsum |= offset + skb->csum_offset;\t \n\n\t\t\tctrl |= CALSUM | WR_SUM | INIT_SUM | LOCK_SUM;\n\t\t\tif (ip_hdr(skb)->protocol == IPPROTO_UDP)\n\t\t\t\tctrl |= UDPTCP;\n\n\t\t\tif (tcpsum != sky2->tx_tcpsum) {\n\t\t\t\tsky2->tx_tcpsum = tcpsum;\n\n\t\t\t\tle = get_tx_le(sky2, &slot);\n\t\t\t\tle->addr = cpu_to_le32(tcpsum);\n\t\t\t\tle->length = 0;\t \n\t\t\t\tle->ctrl = 1;\t \n\t\t\t\tle->opcode = OP_TCPLISW | HW_OWNER;\n\t\t\t}\n\t\t}\n\t}\n\n\tre = sky2->tx_ring + slot;\n\tre->flags = TX_MAP_SINGLE;\n\tdma_unmap_addr_set(re, mapaddr, mapping);\n\tdma_unmap_len_set(re, maplen, len);\n\n\tle = get_tx_le(sky2, &slot);\n\tle->addr = cpu_to_le32(lower_32_bits(mapping));\n\tle->length = cpu_to_le16(len);\n\tle->ctrl = ctrl;\n\tle->opcode = mss ? (OP_LARGESEND | HW_OWNER) : (OP_PACKET | HW_OWNER);\n\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tmapping = skb_frag_dma_map(&hw->pdev->dev, frag, 0,\n\t\t\t\t\t   skb_frag_size(frag), DMA_TO_DEVICE);\n\n\t\tif (dma_mapping_error(&hw->pdev->dev, mapping))\n\t\t\tgoto mapping_unwind;\n\n\t\tupper = upper_32_bits(mapping);\n\t\tif (upper != sky2->tx_last_upper) {\n\t\t\tle = get_tx_le(sky2, &slot);\n\t\t\tle->addr = cpu_to_le32(upper);\n\t\t\tsky2->tx_last_upper = upper;\n\t\t\tle->opcode = OP_ADDR64 | HW_OWNER;\n\t\t}\n\n\t\tre = sky2->tx_ring + slot;\n\t\tre->flags = TX_MAP_PAGE;\n\t\tdma_unmap_addr_set(re, mapaddr, mapping);\n\t\tdma_unmap_len_set(re, maplen, skb_frag_size(frag));\n\n\t\tle = get_tx_le(sky2, &slot);\n\t\tle->addr = cpu_to_le32(lower_32_bits(mapping));\n\t\tle->length = cpu_to_le16(skb_frag_size(frag));\n\t\tle->ctrl = ctrl;\n\t\tle->opcode = OP_BUFFER | HW_OWNER;\n\t}\n\n\tre->skb = skb;\n\tle->ctrl |= EOP;\n\n\tsky2->tx_prod = slot;\n\n\tif (tx_avail(sky2) <= MAX_SKB_TX_LE)\n\t\tnetif_stop_queue(dev);\n\n\tnetdev_sent_queue(dev, skb->len);\n\tsky2_put_idx(hw, txqaddr[sky2->port], sky2->tx_prod);\n\n\treturn NETDEV_TX_OK;\n\nmapping_unwind:\n\tfor (i = sky2->tx_prod; i != slot; i = RING_NEXT(i, sky2->tx_ring_size)) {\n\t\tre = sky2->tx_ring + i;\n\n\t\tsky2_tx_unmap(hw->pdev, re);\n\t}\n\nmapping_error:\n\tif (net_ratelimit())\n\t\tdev_warn(&hw->pdev->dev, \"%s: tx mapping error\\n\", dev->name);\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void sky2_tx_complete(struct sky2_port *sky2, u16 done)\n{\n\tstruct net_device *dev = sky2->netdev;\n\tu16 idx;\n\tunsigned int bytes_compl = 0, pkts_compl = 0;\n\n\tBUG_ON(done >= sky2->tx_ring_size);\n\n\tfor (idx = sky2->tx_cons; idx != done;\n\t     idx = RING_NEXT(idx, sky2->tx_ring_size)) {\n\t\tstruct tx_ring_info *re = sky2->tx_ring + idx;\n\t\tstruct sk_buff *skb = re->skb;\n\n\t\tsky2_tx_unmap(sky2->hw->pdev, re);\n\n\t\tif (skb) {\n\t\t\tnetif_printk(sky2, tx_done, KERN_DEBUG, dev,\n\t\t\t\t     \"tx done %u\\n\", idx);\n\n\t\t\tpkts_compl++;\n\t\t\tbytes_compl += skb->len;\n\n\t\t\tre->skb = NULL;\n\t\t\tdev_kfree_skb_any(skb);\n\n\t\t\tsky2->tx_next = RING_NEXT(idx, sky2->tx_ring_size);\n\t\t}\n\t}\n\n\tsky2->tx_cons = idx;\n\tsmp_mb();\n\n\tnetdev_completed_queue(dev, pkts_compl, bytes_compl);\n\n\tu64_stats_update_begin(&sky2->tx_stats.syncp);\n\tsky2->tx_stats.packets += pkts_compl;\n\tsky2->tx_stats.bytes += bytes_compl;\n\tu64_stats_update_end(&sky2->tx_stats.syncp);\n}\n\nstatic void sky2_tx_reset(struct sky2_hw *hw, unsigned port)\n{\n\t \n\tsky2_write8(hw, SK_REG(port, TXA_CTRL),\n\t\t    TXA_DIS_FSYNC | TXA_DIS_ALLOC | TXA_STOP_RC);\n\n\t \n\tsky2_write32(hw, SK_REG(port, TXA_ITI_INI), 0L);\n\tsky2_write32(hw, SK_REG(port, TXA_LIM_INI), 0L);\n\n\t \n\tsky2_write32(hw, Q_ADDR(txqaddr[port], Q_CSR),\n\t\t     BMU_RST_SET | BMU_FIFO_RST);\n\n\t \n\tsky2_write32(hw, Y2_QADDR(txqaddr[port], PREF_UNIT_CTRL),\n\t\t     PREF_UNIT_RST_SET);\n\n\tsky2_write32(hw, RB_ADDR(txqaddr[port], RB_CTRL), RB_RST_SET);\n\tsky2_write8(hw, SK_REG(port, TX_GMF_CTRL_T), GMF_RST_SET);\n\n\tsky2_read32(hw, B0_CTST);\n}\n\nstatic void sky2_hw_down(struct sky2_port *sky2)\n{\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tu16 ctrl;\n\n\t \n\tsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_PAUSE_OFF);\n\n\t \n\tsky2_write32(hw, Q_ADDR(txqaddr[port], Q_CSR), BMU_STOP);\n\tsky2_read32(hw, Q_ADDR(txqaddr[port], Q_CSR));\n\n\tsky2_write32(hw, RB_ADDR(txqaddr[port], RB_CTRL),\n\t\t     RB_RST_SET | RB_DIS_OP_MD);\n\n\tctrl = gma_read16(hw, port, GM_GP_CTRL);\n\tctrl &= ~(GM_GPCR_TX_ENA | GM_GPCR_RX_ENA);\n\tgma_write16(hw, port, GM_GP_CTRL, ctrl);\n\n\tsky2_write8(hw, SK_REG(port, GPHY_CTRL), GPC_RST_SET);\n\n\t \n\tif (!(hw->chip_id == CHIP_ID_YUKON_XL && hw->chip_rev == 0 &&\n\t      port == 0 && hw->dev[1] && netif_running(hw->dev[1])))\n\t\tsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_RST_SET);\n\n\tsky2_write8(hw, SK_REG(port, RX_GMF_CTRL_T), GMF_RST_SET);\n\n\t \n\tsky2_write32(hw, STAT_LEV_TIMER_CNT, 0);\n\tsky2_write32(hw, STAT_TX_TIMER_CNT, 0);\n\tsky2_write32(hw, STAT_ISR_TIMER_CNT, 0);\n\tsky2_read8(hw, STAT_ISR_TIMER_CTRL);\n\n\tsky2_rx_stop(sky2);\n\n\tspin_lock_bh(&sky2->phy_lock);\n\tsky2_phy_power_down(hw, port);\n\tspin_unlock_bh(&sky2->phy_lock);\n\n\tsky2_tx_reset(hw, port);\n\n\t \n\tsky2_tx_complete(sky2, sky2->tx_prod);\n}\n\n \nstatic int sky2_close(struct net_device *dev)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\n\t \n\tif (!sky2->tx_le)\n\t\treturn 0;\n\n\tnetif_info(sky2, ifdown, dev, \"disabling interface\\n\");\n\n\tif (hw->ports == 1) {\n\t\tsky2_write32(hw, B0_IMSK, 0);\n\t\tsky2_read32(hw, B0_IMSK);\n\n\t\tnapi_disable(&hw->napi);\n\t\tfree_irq(hw->pdev->irq, hw);\n\t\thw->flags &= ~SKY2_HW_IRQ_SETUP;\n\t} else {\n\t\tu32 imask;\n\n\t\t \n\t\timask  = sky2_read32(hw, B0_IMSK);\n\t\timask &= ~portirq_msk[sky2->port];\n\t\tsky2_write32(hw, B0_IMSK, imask);\n\t\tsky2_read32(hw, B0_IMSK);\n\n\t\tsynchronize_irq(hw->pdev->irq);\n\t\tnapi_synchronize(&hw->napi);\n\t}\n\n\tsky2_hw_down(sky2);\n\n\tsky2_free_buffers(sky2);\n\n\treturn 0;\n}\n\nstatic u16 sky2_phy_speed(const struct sky2_hw *hw, u16 aux)\n{\n\tif (hw->flags & SKY2_HW_FIBRE_PHY)\n\t\treturn SPEED_1000;\n\n\tif (!(hw->flags & SKY2_HW_GIGABIT)) {\n\t\tif (aux & PHY_M_PS_SPEED_100)\n\t\t\treturn SPEED_100;\n\t\telse\n\t\t\treturn SPEED_10;\n\t}\n\n\tswitch (aux & PHY_M_PS_SPEED_MSK) {\n\tcase PHY_M_PS_SPEED_1000:\n\t\treturn SPEED_1000;\n\tcase PHY_M_PS_SPEED_100:\n\t\treturn SPEED_100;\n\tdefault:\n\t\treturn SPEED_10;\n\t}\n}\n\nstatic void sky2_link_up(struct sky2_port *sky2)\n{\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tstatic const char *fc_name[] = {\n\t\t[FC_NONE]\t= \"none\",\n\t\t[FC_TX]\t\t= \"tx\",\n\t\t[FC_RX]\t\t= \"rx\",\n\t\t[FC_BOTH]\t= \"both\",\n\t};\n\n\tsky2_set_ipg(sky2);\n\n\tsky2_enable_rx_tx(sky2);\n\n\tgm_phy_write(hw, port, PHY_MARV_INT_MASK, PHY_M_DEF_MSK);\n\n\tnetif_carrier_on(sky2->netdev);\n\n\tmod_timer(&hw->watchdog_timer, jiffies + 1);\n\n\t \n\tsky2_write8(hw, SK_REG(port, LNK_LED_REG),\n\t\t    LINKLED_ON | LINKLED_BLINK_OFF | LINKLED_LINKSYNC_OFF);\n\n\tnetif_info(sky2, link, sky2->netdev,\n\t\t   \"Link is up at %d Mbps, %s duplex, flow control %s\\n\",\n\t\t   sky2->speed,\n\t\t   sky2->duplex == DUPLEX_FULL ? \"full\" : \"half\",\n\t\t   fc_name[sky2->flow_status]);\n}\n\nstatic void sky2_link_down(struct sky2_port *sky2)\n{\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tu16 reg;\n\n\tgm_phy_write(hw, port, PHY_MARV_INT_MASK, 0);\n\n\treg = gma_read16(hw, port, GM_GP_CTRL);\n\treg &= ~(GM_GPCR_RX_ENA | GM_GPCR_TX_ENA);\n\tgma_write16(hw, port, GM_GP_CTRL, reg);\n\n\tnetif_carrier_off(sky2->netdev);\n\n\t \n\tsky2_write8(hw, SK_REG(port, LNK_LED_REG), LINKLED_OFF);\n\n\tnetif_info(sky2, link, sky2->netdev, \"Link is down\\n\");\n\n\tsky2_phy_init(hw, port);\n}\n\nstatic enum flow_control sky2_flow(int rx, int tx)\n{\n\tif (rx)\n\t\treturn tx ? FC_BOTH : FC_RX;\n\telse\n\t\treturn tx ? FC_TX : FC_NONE;\n}\n\nstatic int sky2_autoneg_done(struct sky2_port *sky2, u16 aux)\n{\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tu16 advert, lpa;\n\n\tadvert = gm_phy_read(hw, port, PHY_MARV_AUNE_ADV);\n\tlpa = gm_phy_read(hw, port, PHY_MARV_AUNE_LP);\n\tif (lpa & PHY_M_AN_RF) {\n\t\tnetdev_err(sky2->netdev, \"remote fault\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!(aux & PHY_M_PS_SPDUP_RES)) {\n\t\tnetdev_err(sky2->netdev, \"speed/duplex mismatch\\n\");\n\t\treturn -1;\n\t}\n\n\tsky2->speed = sky2_phy_speed(hw, aux);\n\tsky2->duplex = (aux & PHY_M_PS_FULL_DUP) ? DUPLEX_FULL : DUPLEX_HALF;\n\n\t \n\tif (hw->flags & SKY2_HW_FIBRE_PHY) {\n\t\t \n\t\tadvert &= ~(ADVERTISE_PAUSE_CAP|ADVERTISE_PAUSE_ASYM);\n\t\tlpa &= ~(LPA_PAUSE_CAP|LPA_PAUSE_ASYM);\n\n\t\tif (advert & ADVERTISE_1000XPAUSE)\n\t\t\tadvert |= ADVERTISE_PAUSE_CAP;\n\t\tif (advert & ADVERTISE_1000XPSE_ASYM)\n\t\t\tadvert |= ADVERTISE_PAUSE_ASYM;\n\t\tif (lpa & LPA_1000XPAUSE)\n\t\t\tlpa |= LPA_PAUSE_CAP;\n\t\tif (lpa & LPA_1000XPAUSE_ASYM)\n\t\t\tlpa |= LPA_PAUSE_ASYM;\n\t}\n\n\tsky2->flow_status = FC_NONE;\n\tif (advert & ADVERTISE_PAUSE_CAP) {\n\t\tif (lpa & LPA_PAUSE_CAP)\n\t\t\tsky2->flow_status = FC_BOTH;\n\t\telse if (advert & ADVERTISE_PAUSE_ASYM)\n\t\t\tsky2->flow_status = FC_RX;\n\t} else if (advert & ADVERTISE_PAUSE_ASYM) {\n\t\tif ((lpa & LPA_PAUSE_CAP) && (lpa & LPA_PAUSE_ASYM))\n\t\t\tsky2->flow_status = FC_TX;\n\t}\n\n\tif (sky2->duplex == DUPLEX_HALF && sky2->speed < SPEED_1000 &&\n\t    !(hw->chip_id == CHIP_ID_YUKON_EC_U || hw->chip_id == CHIP_ID_YUKON_EX))\n\t\tsky2->flow_status = FC_NONE;\n\n\tif (sky2->flow_status & FC_TX)\n\t\tsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_PAUSE_ON);\n\telse\n\t\tsky2_write8(hw, SK_REG(port, GMAC_CTRL), GMC_PAUSE_OFF);\n\n\treturn 0;\n}\n\n \nstatic void sky2_phy_intr(struct sky2_hw *hw, unsigned port)\n{\n\tstruct net_device *dev = hw->dev[port];\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tu16 istatus, phystat;\n\n\tif (!netif_running(dev))\n\t\treturn;\n\n\tspin_lock(&sky2->phy_lock);\n\tistatus = gm_phy_read(hw, port, PHY_MARV_INT_STAT);\n\tphystat = gm_phy_read(hw, port, PHY_MARV_PHY_STAT);\n\n\tnetif_info(sky2, intr, sky2->netdev, \"phy interrupt status 0x%x 0x%x\\n\",\n\t\t   istatus, phystat);\n\n\tif (istatus & PHY_M_IS_AN_COMPL) {\n\t\tif (sky2_autoneg_done(sky2, phystat) == 0 &&\n\t\t    !netif_carrier_ok(dev))\n\t\t\tsky2_link_up(sky2);\n\t\tgoto out;\n\t}\n\n\tif (istatus & PHY_M_IS_LSP_CHANGE)\n\t\tsky2->speed = sky2_phy_speed(hw, phystat);\n\n\tif (istatus & PHY_M_IS_DUP_CHANGE)\n\t\tsky2->duplex =\n\t\t    (phystat & PHY_M_PS_FULL_DUP) ? DUPLEX_FULL : DUPLEX_HALF;\n\n\tif (istatus & PHY_M_IS_LST_CHANGE) {\n\t\tif (phystat & PHY_M_PS_LINK_UP)\n\t\t\tsky2_link_up(sky2);\n\t\telse\n\t\t\tsky2_link_down(sky2);\n\t}\nout:\n\tspin_unlock(&sky2->phy_lock);\n}\n\n \nstatic void sky2_qlink_intr(struct sky2_hw *hw)\n{\n\tstruct sky2_port *sky2 = netdev_priv(hw->dev[0]);\n\tu32 imask;\n\tu16 phy;\n\n\t \n\timask = sky2_read32(hw, B0_IMSK);\n\timask &= ~Y2_IS_PHY_QLNK;\n\tsky2_write32(hw, B0_IMSK, imask);\n\n\t \n\tphy = sky2_pci_read16(hw, PSM_CONFIG_REG4);\n\tsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);\n\tsky2_pci_write16(hw, PSM_CONFIG_REG4, phy | 1);\n\tsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);\n\n\tsky2_link_up(sky2);\n}\n\n \nstatic void sky2_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\n\tnetif_err(sky2, timer, dev, \"tx timeout\\n\");\n\n\tnetdev_printk(KERN_DEBUG, dev, \"transmit ring %u .. %u report=%u done=%u\\n\",\n\t\t      sky2->tx_cons, sky2->tx_prod,\n\t\t      sky2_read16(hw, sky2->port == 0 ? STAT_TXA1_RIDX : STAT_TXA2_RIDX),\n\t\t      sky2_read16(hw, Q_ADDR(txqaddr[sky2->port], Q_DONE)));\n\n\t \n\tschedule_work(&hw->restart_work);\n}\n\nstatic int sky2_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tint err;\n\tu16 ctl, mode;\n\tu32 imask;\n\n\tif (!netif_running(dev)) {\n\t\tdev->mtu = new_mtu;\n\t\tnetdev_update_features(dev);\n\t\treturn 0;\n\t}\n\n\timask = sky2_read32(hw, B0_IMSK);\n\tsky2_write32(hw, B0_IMSK, 0);\n\tsky2_read32(hw, B0_IMSK);\n\n\tnetif_trans_update(dev);\t \n\tnapi_disable(&hw->napi);\n\tnetif_tx_disable(dev);\n\n\tsynchronize_irq(hw->pdev->irq);\n\n\tif (!(hw->flags & SKY2_HW_RAM_BUFFER))\n\t\tsky2_set_tx_stfwd(hw, port);\n\n\tctl = gma_read16(hw, port, GM_GP_CTRL);\n\tgma_write16(hw, port, GM_GP_CTRL, ctl & ~GM_GPCR_RX_ENA);\n\tsky2_rx_stop(sky2);\n\tsky2_rx_clean(sky2);\n\n\tdev->mtu = new_mtu;\n\tnetdev_update_features(dev);\n\n\tmode = DATA_BLIND_VAL(DATA_BLIND_DEF) |\tGM_SMOD_VLAN_ENA;\n\tif (sky2->speed > SPEED_100)\n\t\tmode |= IPG_DATA_VAL(IPG_DATA_DEF_1000);\n\telse\n\t\tmode |= IPG_DATA_VAL(IPG_DATA_DEF_10_100);\n\n\tif (dev->mtu > ETH_DATA_LEN)\n\t\tmode |= GM_SMOD_JUMBO_ENA;\n\n\tgma_write16(hw, port, GM_SERIAL_MODE, mode);\n\n\tsky2_write8(hw, RB_ADDR(rxqaddr[port], RB_CTRL), RB_ENA_OP_MD);\n\n\terr = sky2_alloc_rx_skbs(sky2);\n\tif (!err)\n\t\tsky2_rx_start(sky2);\n\telse\n\t\tsky2_rx_clean(sky2);\n\tsky2_write32(hw, B0_IMSK, imask);\n\n\tsky2_read32(hw, B0_Y2_SP_LISR);\n\tnapi_enable(&hw->napi);\n\n\tif (err)\n\t\tdev_close(dev);\n\telse {\n\t\tgma_write16(hw, port, GM_GP_CTRL, ctl);\n\n\t\tnetif_wake_queue(dev);\n\t}\n\n\treturn err;\n}\n\nstatic inline bool needs_copy(const struct rx_ring_info *re,\n\t\t\t      unsigned length)\n{\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\t \n\tif (!IS_ALIGNED(re->data_addr + ETH_HLEN, sizeof(u32)))\n\t\treturn true;\n#endif\n\treturn length < copybreak;\n}\n\n \nstatic struct sk_buff *receive_copy(struct sky2_port *sky2,\n\t\t\t\t    const struct rx_ring_info *re,\n\t\t\t\t    unsigned length)\n{\n\tstruct sk_buff *skb;\n\n\tskb = netdev_alloc_skb_ip_align(sky2->netdev, length);\n\tif (likely(skb)) {\n\t\tdma_sync_single_for_cpu(&sky2->hw->pdev->dev, re->data_addr,\n\t\t\t\t\tlength, DMA_FROM_DEVICE);\n\t\tskb_copy_from_linear_data(re->skb, skb->data, length);\n\t\tskb->ip_summed = re->skb->ip_summed;\n\t\tskb->csum = re->skb->csum;\n\t\tskb_copy_hash(skb, re->skb);\n\t\t__vlan_hwaccel_copy_tag(skb, re->skb);\n\n\t\tdma_sync_single_for_device(&sky2->hw->pdev->dev,\n\t\t\t\t\t   re->data_addr, length,\n\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t__vlan_hwaccel_clear_tag(re->skb);\n\t\tskb_clear_hash(re->skb);\n\t\tre->skb->ip_summed = CHECKSUM_NONE;\n\t\tskb_put(skb, length);\n\t}\n\treturn skb;\n}\n\n \nstatic void skb_put_frags(struct sk_buff *skb, unsigned int hdr_space,\n\t\t\t  unsigned int length)\n{\n\tint i, num_frags;\n\tunsigned int size;\n\n\t \n\tsize = min(length, hdr_space);\n\tskb->tail += size;\n\tskb->len += size;\n\tlength -= size;\n\n\tnum_frags = skb_shinfo(skb)->nr_frags;\n\tfor (i = 0; i < num_frags; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tif (length == 0) {\n\t\t\t \n\t\t\t__skb_frag_unref(frag, false);\n\t\t\t--skb_shinfo(skb)->nr_frags;\n\t\t} else {\n\t\t\tsize = min(length, (unsigned) PAGE_SIZE);\n\n\t\t\tskb_frag_size_set(frag, size);\n\t\t\tskb->data_len += size;\n\t\t\tskb->truesize += PAGE_SIZE;\n\t\t\tskb->len += size;\n\t\t\tlength -= size;\n\t\t}\n\t}\n}\n\n \nstatic struct sk_buff *receive_new(struct sky2_port *sky2,\n\t\t\t\t   struct rx_ring_info *re,\n\t\t\t\t   unsigned int length)\n{\n\tstruct sk_buff *skb;\n\tstruct rx_ring_info nre;\n\tunsigned hdr_space = sky2->rx_data_size;\n\n\tnre.skb = sky2_rx_alloc(sky2, GFP_ATOMIC);\n\tif (unlikely(!nre.skb))\n\t\tgoto nobuf;\n\n\tif (sky2_rx_map_skb(sky2->hw->pdev, &nre, hdr_space))\n\t\tgoto nomap;\n\n\tskb = re->skb;\n\tsky2_rx_unmap_skb(sky2->hw->pdev, re);\n\tprefetch(skb->data);\n\t*re = nre;\n\n\tif (skb_shinfo(skb)->nr_frags)\n\t\tskb_put_frags(skb, hdr_space, length);\n\telse\n\t\tskb_put(skb, length);\n\treturn skb;\n\nnomap:\n\tdev_kfree_skb(nre.skb);\nnobuf:\n\treturn NULL;\n}\n\n \nstatic struct sk_buff *sky2_receive(struct net_device *dev,\n\t\t\t\t    u16 length, u32 status)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct rx_ring_info *re = sky2->rx_ring + sky2->rx_next;\n\tstruct sk_buff *skb = NULL;\n\tu16 count = (status & GMR_FS_LEN) >> 16;\n\n\tnetif_printk(sky2, rx_status, KERN_DEBUG, dev,\n\t\t     \"rx slot %u status 0x%x len %d\\n\",\n\t\t     sky2->rx_next, status, length);\n\n\tsky2->rx_next = (sky2->rx_next + 1) % sky2->rx_pending;\n\tprefetch(sky2->rx_ring + sky2->rx_next);\n\n\tif (skb_vlan_tag_present(re->skb))\n\t\tcount -= VLAN_HLEN;\t \n\n\t \n\tif (sky2->hw->chip_id == CHIP_ID_YUKON_FE_P &&\n\t    sky2->hw->chip_rev == CHIP_REV_YU_FE2_A0 &&\n\t    length != count)\n\t\tgoto okay;\n\n\tif (status & GMR_FS_ANY_ERR)\n\t\tgoto error;\n\n\tif (!(status & GMR_FS_RX_OK))\n\t\tgoto resubmit;\n\n\t \n\tif (length != count)\n\t\tgoto error;\n\nokay:\n\tif (needs_copy(re, length))\n\t\tskb = receive_copy(sky2, re, length);\n\telse\n\t\tskb = receive_new(sky2, re, length);\n\n\tdev->stats.rx_dropped += (skb == NULL);\n\nresubmit:\n\tsky2_rx_submit(sky2, re);\n\n\treturn skb;\n\nerror:\n\t++dev->stats.rx_errors;\n\n\tif (net_ratelimit())\n\t\tnetif_info(sky2, rx_err, dev,\n\t\t\t   \"rx error, status 0x%x length %d\\n\", status, length);\n\n\tgoto resubmit;\n}\n\n \nstatic inline void sky2_tx_done(struct net_device *dev, u16 last)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\tif (netif_running(dev)) {\n\t\tsky2_tx_complete(sky2, last);\n\n\t\t \n\t\tif (tx_avail(sky2) > MAX_SKB_TX_LE + 4)\n\t\t\tnetif_wake_queue(dev);\n\t}\n}\n\nstatic inline void sky2_skb_rx(const struct sky2_port *sky2,\n\t\t\t       struct sk_buff *skb)\n{\n\tif (skb->ip_summed == CHECKSUM_NONE)\n\t\tnetif_receive_skb(skb);\n\telse\n\t\tnapi_gro_receive(&sky2->hw->napi, skb);\n}\n\nstatic inline void sky2_rx_done(struct sky2_hw *hw, unsigned port,\n\t\t\t\tunsigned packets, unsigned bytes)\n{\n\tstruct net_device *dev = hw->dev[port];\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\tif (packets == 0)\n\t\treturn;\n\n\tu64_stats_update_begin(&sky2->rx_stats.syncp);\n\tsky2->rx_stats.packets += packets;\n\tsky2->rx_stats.bytes += bytes;\n\tu64_stats_update_end(&sky2->rx_stats.syncp);\n\n\tsky2->last_rx = jiffies;\n\tsky2_rx_update(netdev_priv(dev), rxqaddr[port]);\n}\n\nstatic void sky2_rx_checksum(struct sky2_port *sky2, u32 status)\n{\n\t \n\tBUG_ON(sky2->hw->flags & SKY2_HW_NEW_LE);\n\n\t \n\tif (likely((u16)(status >> 16) == (u16)status)) {\n\t\tstruct sk_buff *skb = sky2->rx_ring[sky2->rx_next].skb;\n\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\t\tskb->csum = le16_to_cpu(status);\n\t} else {\n\t\tdev_notice(&sky2->hw->pdev->dev,\n\t\t\t   \"%s: receive checksum problem (status = %#x)\\n\",\n\t\t\t   sky2->netdev->name, status);\n\n\t\t \n\t\tsky2->netdev->features &= ~NETIF_F_RXCSUM;\n\t\tsky2_write32(sky2->hw, Q_ADDR(rxqaddr[sky2->port], Q_CSR),\n\t\t\t     BMU_DIS_RX_CHKSUM);\n\t}\n}\n\nstatic void sky2_rx_tag(struct sky2_port *sky2, u16 length)\n{\n\tstruct sk_buff *skb;\n\n\tskb = sky2->rx_ring[sky2->rx_next].skb;\n\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), be16_to_cpu(length));\n}\n\nstatic void sky2_rx_hash(struct sky2_port *sky2, u32 status)\n{\n\tstruct sk_buff *skb;\n\n\tskb = sky2->rx_ring[sky2->rx_next].skb;\n\tskb_set_hash(skb, le32_to_cpu(status), PKT_HASH_TYPE_L3);\n}\n\n \nstatic int sky2_status_intr(struct sky2_hw *hw, int to_do, u16 idx)\n{\n\tint work_done = 0;\n\tunsigned int total_bytes[2] = { 0 };\n\tunsigned int total_packets[2] = { 0 };\n\n\tif (to_do <= 0)\n\t\treturn work_done;\n\n\trmb();\n\tdo {\n\t\tstruct sky2_port *sky2;\n\t\tstruct sky2_status_le *le  = hw->st_le + hw->st_idx;\n\t\tunsigned port;\n\t\tstruct net_device *dev;\n\t\tstruct sk_buff *skb;\n\t\tu32 status;\n\t\tu16 length;\n\t\tu8 opcode = le->opcode;\n\n\t\tif (!(opcode & HW_OWNER))\n\t\t\tbreak;\n\n\t\thw->st_idx = RING_NEXT(hw->st_idx, hw->st_size);\n\n\t\tport = le->css & CSS_LINK_BIT;\n\t\tdev = hw->dev[port];\n\t\tsky2 = netdev_priv(dev);\n\t\tlength = le16_to_cpu(le->length);\n\t\tstatus = le32_to_cpu(le->status);\n\n\t\tle->opcode = 0;\n\t\tswitch (opcode & ~HW_OWNER) {\n\t\tcase OP_RXSTAT:\n\t\t\ttotal_packets[port]++;\n\t\t\ttotal_bytes[port] += length;\n\n\t\t\tskb = sky2_receive(dev, length, status);\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (hw->flags & SKY2_HW_NEW_LE) {\n\t\t\t\tif ((dev->features & NETIF_F_RXCSUM) &&\n\t\t\t\t    (le->css & (CSS_ISIPV4 | CSS_ISIPV6)) &&\n\t\t\t\t    (le->css & CSS_TCPUDPCSOK))\n\t\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t\telse\n\t\t\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\t}\n\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tsky2_skb_rx(sky2, skb);\n\n\t\t\t \n\t\t\tif (++work_done >= to_do)\n\t\t\t\tgoto exit_loop;\n\t\t\tbreak;\n\n\t\tcase OP_RXVLAN:\n\t\t\tsky2_rx_tag(sky2, length);\n\t\t\tbreak;\n\n\t\tcase OP_RXCHKSVLAN:\n\t\t\tsky2_rx_tag(sky2, length);\n\t\t\tfallthrough;\n\t\tcase OP_RXCHKS:\n\t\t\tif (likely(dev->features & NETIF_F_RXCSUM))\n\t\t\t\tsky2_rx_checksum(sky2, status);\n\t\t\tbreak;\n\n\t\tcase OP_RSS_HASH:\n\t\t\tsky2_rx_hash(sky2, status);\n\t\t\tbreak;\n\n\t\tcase OP_TXINDEXLE:\n\t\t\t \n\t\t\tsky2_tx_done(hw->dev[0], status & 0xfff);\n\t\t\tif (hw->dev[1])\n\t\t\t\tsky2_tx_done(hw->dev[1],\n\t\t\t\t     ((status >> 24) & 0xff)\n\t\t\t\t\t     | (u16)(length & 0xf) << 8);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (net_ratelimit())\n\t\t\t\tpr_warn(\"unknown status opcode 0x%x\\n\", opcode);\n\t\t}\n\t} while (hw->st_idx != idx);\n\n\t \n\tsky2_write32(hw, STAT_CTRL, SC_STAT_CLR_IRQ);\n\nexit_loop:\n\tsky2_rx_done(hw, 0, total_packets[0], total_bytes[0]);\n\tsky2_rx_done(hw, 1, total_packets[1], total_bytes[1]);\n\n\treturn work_done;\n}\n\nstatic void sky2_hw_error(struct sky2_hw *hw, unsigned port, u32 status)\n{\n\tstruct net_device *dev = hw->dev[port];\n\n\tif (net_ratelimit())\n\t\tnetdev_info(dev, \"hw error interrupt status 0x%x\\n\", status);\n\n\tif (status & Y2_IS_PAR_RD1) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(dev, \"ram data read parity error\\n\");\n\t\t \n\t\tsky2_write16(hw, RAM_BUFFER(port, B3_RI_CTRL), RI_CLR_RD_PERR);\n\t}\n\n\tif (status & Y2_IS_PAR_WR1) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(dev, \"ram data write parity error\\n\");\n\n\t\tsky2_write16(hw, RAM_BUFFER(port, B3_RI_CTRL), RI_CLR_WR_PERR);\n\t}\n\n\tif (status & Y2_IS_PAR_MAC1) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(dev, \"MAC parity error\\n\");\n\t\tsky2_write8(hw, SK_REG(port, TX_GMF_CTRL_T), GMF_CLI_TX_PE);\n\t}\n\n\tif (status & Y2_IS_PAR_RX1) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(dev, \"RX parity error\\n\");\n\t\tsky2_write32(hw, Q_ADDR(rxqaddr[port], Q_CSR), BMU_CLR_IRQ_PAR);\n\t}\n\n\tif (status & Y2_IS_TCP_TXA1) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(dev, \"TCP segmentation error\\n\");\n\t\tsky2_write32(hw, Q_ADDR(txqaddr[port], Q_CSR), BMU_CLR_IRQ_TCP);\n\t}\n}\n\nstatic void sky2_hw_intr(struct sky2_hw *hw)\n{\n\tstruct pci_dev *pdev = hw->pdev;\n\tu32 status = sky2_read32(hw, B0_HWE_ISRC);\n\tu32 hwmsk = sky2_read32(hw, B0_HWE_IMSK);\n\n\tstatus &= hwmsk;\n\n\tif (status & Y2_IS_TIST_OV)\n\t\tsky2_write8(hw, GMAC_TI_ST_CTRL, GMT_ST_CLR_IRQ);\n\n\tif (status & (Y2_IS_MST_ERR | Y2_IS_IRQ_STAT)) {\n\t\tu16 pci_err;\n\n\t\tsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);\n\t\tpci_err = sky2_pci_read16(hw, PCI_STATUS);\n\t\tif (net_ratelimit())\n\t\t\tdev_err(&pdev->dev, \"PCI hardware error (0x%x)\\n\",\n\t\t\t        pci_err);\n\n\t\tsky2_pci_write16(hw, PCI_STATUS,\n\t\t\t\t      pci_err | PCI_STATUS_ERROR_BITS);\n\t\tsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);\n\t}\n\n\tif (status & Y2_IS_PCI_EXP) {\n\t\t \n\t\tu32 err;\n\n\t\tsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);\n\t\terr = sky2_read32(hw, Y2_CFG_AER + PCI_ERR_UNCOR_STATUS);\n\t\tsky2_write32(hw, Y2_CFG_AER + PCI_ERR_UNCOR_STATUS,\n\t\t\t     0xfffffffful);\n\t\tif (net_ratelimit())\n\t\t\tdev_err(&pdev->dev, \"PCI Express error (0x%x)\\n\", err);\n\n\t\tsky2_read32(hw, Y2_CFG_AER + PCI_ERR_UNCOR_STATUS);\n\t\tsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);\n\t}\n\n\tif (status & Y2_HWE_L1_MASK)\n\t\tsky2_hw_error(hw, 0, status);\n\tstatus >>= 8;\n\tif (status & Y2_HWE_L1_MASK)\n\t\tsky2_hw_error(hw, 1, status);\n}\n\nstatic void sky2_mac_intr(struct sky2_hw *hw, unsigned port)\n{\n\tstruct net_device *dev = hw->dev[port];\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tu8 status = sky2_read8(hw, SK_REG(port, GMAC_IRQ_SRC));\n\n\tnetif_info(sky2, intr, dev, \"mac interrupt status 0x%x\\n\", status);\n\n\tif (status & GM_IS_RX_CO_OV)\n\t\tgma_read16(hw, port, GM_RX_IRQ_SRC);\n\n\tif (status & GM_IS_TX_CO_OV)\n\t\tgma_read16(hw, port, GM_TX_IRQ_SRC);\n\n\tif (status & GM_IS_RX_FF_OR) {\n\t\t++dev->stats.rx_fifo_errors;\n\t\tsky2_write8(hw, SK_REG(port, RX_GMF_CTRL_T), GMF_CLI_RX_FO);\n\t}\n\n\tif (status & GM_IS_TX_FF_UR) {\n\t\t++dev->stats.tx_fifo_errors;\n\t\tsky2_write8(hw, SK_REG(port, TX_GMF_CTRL_T), GMF_CLI_TX_FU);\n\t}\n}\n\n \nstatic void sky2_le_error(struct sky2_hw *hw, unsigned port, u16 q)\n{\n\tstruct net_device *dev = hw->dev[port];\n\tu16 idx = sky2_read16(hw, Y2_QADDR(q, PREF_UNIT_GET_IDX));\n\n\tdev_err(&hw->pdev->dev, \"%s: descriptor error q=%#x get=%u put=%u\\n\",\n\t\tdev->name, (unsigned) q, (unsigned) idx,\n\t\t(unsigned) sky2_read16(hw, Y2_QADDR(q, PREF_UNIT_PUT_IDX)));\n\n\tsky2_write32(hw, Q_ADDR(q, Q_CSR), BMU_CLR_IRQ_CHK);\n}\n\nstatic int sky2_rx_hung(struct net_device *dev)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tunsigned rxq = rxqaddr[port];\n\tu32 mac_rp = sky2_read32(hw, SK_REG(port, RX_GMF_RP));\n\tu8 mac_lev = sky2_read8(hw, SK_REG(port, RX_GMF_RLEV));\n\tu8 fifo_rp = sky2_read8(hw, Q_ADDR(rxq, Q_RP));\n\tu8 fifo_lev = sky2_read8(hw, Q_ADDR(rxq, Q_RL));\n\n\t \n\tif (sky2->check.last == sky2->last_rx &&\n\t    ((mac_rp == sky2->check.mac_rp &&\n\t      mac_lev != 0 && mac_lev >= sky2->check.mac_lev) ||\n\t      \n\t     (fifo_rp == sky2->check.fifo_rp &&\n\t      fifo_lev != 0 && fifo_lev >= sky2->check.fifo_lev))) {\n\t\tnetdev_printk(KERN_DEBUG, dev,\n\t\t\t      \"hung mac %d:%d fifo %d (%d:%d)\\n\",\n\t\t\t      mac_lev, mac_rp, fifo_lev,\n\t\t\t      fifo_rp, sky2_read8(hw, Q_ADDR(rxq, Q_WP)));\n\t\treturn 1;\n\t} else {\n\t\tsky2->check.last = sky2->last_rx;\n\t\tsky2->check.mac_rp = mac_rp;\n\t\tsky2->check.mac_lev = mac_lev;\n\t\tsky2->check.fifo_rp = fifo_rp;\n\t\tsky2->check.fifo_lev = fifo_lev;\n\t\treturn 0;\n\t}\n}\n\nstatic void sky2_watchdog(struct timer_list *t)\n{\n\tstruct sky2_hw *hw = from_timer(hw, t, watchdog_timer);\n\n\t \n\tif (sky2_read32(hw, B0_ISRC)) {\n\t\tnapi_schedule(&hw->napi);\n\t} else {\n\t\tint i, active = 0;\n\n\t\tfor (i = 0; i < hw->ports; i++) {\n\t\t\tstruct net_device *dev = hw->dev[i];\n\t\t\tif (!netif_running(dev))\n\t\t\t\tcontinue;\n\t\t\t++active;\n\n\t\t\t \n\t\t\tif ((hw->flags & SKY2_HW_RAM_BUFFER) &&\n\t\t\t     sky2_rx_hung(dev)) {\n\t\t\t\tnetdev_info(dev, \"receiver hang detected\\n\");\n\t\t\t\tschedule_work(&hw->restart_work);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (active == 0)\n\t\t\treturn;\n\t}\n\n\tmod_timer(&hw->watchdog_timer, round_jiffies(jiffies + HZ));\n}\n\n \nstatic void sky2_err_intr(struct sky2_hw *hw, u32 status)\n{\n\tif (net_ratelimit())\n\t\tdev_warn(&hw->pdev->dev, \"error interrupt status=%#x\\n\", status);\n\n\tif (status & Y2_IS_HW_ERR)\n\t\tsky2_hw_intr(hw);\n\n\tif (status & Y2_IS_IRQ_MAC1)\n\t\tsky2_mac_intr(hw, 0);\n\n\tif (status & Y2_IS_IRQ_MAC2)\n\t\tsky2_mac_intr(hw, 1);\n\n\tif (status & Y2_IS_CHK_RX1)\n\t\tsky2_le_error(hw, 0, Q_R1);\n\n\tif (status & Y2_IS_CHK_RX2)\n\t\tsky2_le_error(hw, 1, Q_R2);\n\n\tif (status & Y2_IS_CHK_TXA1)\n\t\tsky2_le_error(hw, 0, Q_XA1);\n\n\tif (status & Y2_IS_CHK_TXA2)\n\t\tsky2_le_error(hw, 1, Q_XA2);\n}\n\nstatic int sky2_poll(struct napi_struct *napi, int work_limit)\n{\n\tstruct sky2_hw *hw = container_of(napi, struct sky2_hw, napi);\n\tu32 status = sky2_read32(hw, B0_Y2_SP_EISR);\n\tint work_done = 0;\n\tu16 idx;\n\n\tif (unlikely(status & Y2_IS_ERROR))\n\t\tsky2_err_intr(hw, status);\n\n\tif (status & Y2_IS_IRQ_PHY1)\n\t\tsky2_phy_intr(hw, 0);\n\n\tif (status & Y2_IS_IRQ_PHY2)\n\t\tsky2_phy_intr(hw, 1);\n\n\tif (status & Y2_IS_PHY_QLNK)\n\t\tsky2_qlink_intr(hw);\n\n\twhile ((idx = sky2_read16(hw, STAT_PUT_IDX)) != hw->st_idx) {\n\t\twork_done += sky2_status_intr(hw, work_limit - work_done, idx);\n\n\t\tif (work_done >= work_limit)\n\t\t\tgoto done;\n\t}\n\n\tnapi_complete_done(napi, work_done);\n\tsky2_read32(hw, B0_Y2_SP_LISR);\ndone:\n\n\treturn work_done;\n}\n\nstatic irqreturn_t sky2_intr(int irq, void *dev_id)\n{\n\tstruct sky2_hw *hw = dev_id;\n\tu32 status;\n\n\t \n\tstatus = sky2_read32(hw, B0_Y2_SP_ISRC2);\n\tif (status == 0 || status == ~0) {\n\t\tsky2_write32(hw, B0_Y2_SP_ICR, 2);\n\t\treturn IRQ_NONE;\n\t}\n\n\tprefetch(&hw->st_le[hw->st_idx]);\n\n\tnapi_schedule(&hw->napi);\n\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void sky2_netpoll(struct net_device *dev)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\tnapi_schedule(&sky2->hw->napi);\n}\n#endif\n\n \nstatic u32 sky2_mhz(const struct sky2_hw *hw)\n{\n\tswitch (hw->chip_id) {\n\tcase CHIP_ID_YUKON_EC:\n\tcase CHIP_ID_YUKON_EC_U:\n\tcase CHIP_ID_YUKON_EX:\n\tcase CHIP_ID_YUKON_SUPR:\n\tcase CHIP_ID_YUKON_UL_2:\n\tcase CHIP_ID_YUKON_OPT:\n\tcase CHIP_ID_YUKON_PRM:\n\tcase CHIP_ID_YUKON_OP_2:\n\t\treturn 125;\n\n\tcase CHIP_ID_YUKON_FE:\n\t\treturn 100;\n\n\tcase CHIP_ID_YUKON_FE_P:\n\t\treturn 50;\n\n\tcase CHIP_ID_YUKON_XL:\n\t\treturn 156;\n\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic inline u32 sky2_us2clk(const struct sky2_hw *hw, u32 us)\n{\n\treturn sky2_mhz(hw) * us;\n}\n\nstatic inline u32 sky2_clk2us(const struct sky2_hw *hw, u32 clk)\n{\n\treturn clk / sky2_mhz(hw);\n}\n\n\nstatic int sky2_init(struct sky2_hw *hw)\n{\n\tu8 t8;\n\n\t \n\tsky2_pci_write32(hw, PCI_DEV_REG3, 0);\n\n\tsky2_write8(hw, B0_CTST, CS_RST_CLR);\n\n\thw->chip_id = sky2_read8(hw, B2_CHIP_ID);\n\thw->chip_rev = (sky2_read8(hw, B2_MAC_CFG) & CFG_CHIP_R_MSK) >> 4;\n\n\tswitch (hw->chip_id) {\n\tcase CHIP_ID_YUKON_XL:\n\t\thw->flags = SKY2_HW_GIGABIT | SKY2_HW_NEWER_PHY;\n\t\tif (hw->chip_rev < CHIP_REV_YU_XL_A2)\n\t\t\thw->flags |= SKY2_HW_RSS_BROKEN;\n\t\tbreak;\n\n\tcase CHIP_ID_YUKON_EC_U:\n\t\thw->flags = SKY2_HW_GIGABIT\n\t\t\t| SKY2_HW_NEWER_PHY\n\t\t\t| SKY2_HW_ADV_POWER_CTL;\n\t\tbreak;\n\n\tcase CHIP_ID_YUKON_EX:\n\t\thw->flags = SKY2_HW_GIGABIT\n\t\t\t| SKY2_HW_NEWER_PHY\n\t\t\t| SKY2_HW_NEW_LE\n\t\t\t| SKY2_HW_ADV_POWER_CTL\n\t\t\t| SKY2_HW_RSS_CHKSUM;\n\n\t\t \n\t\tif (hw->chip_rev != CHIP_REV_YU_EX_B0)\n\t\t\thw->flags |= SKY2_HW_AUTO_TX_SUM;\n\t\tbreak;\n\n\tcase CHIP_ID_YUKON_EC:\n\t\t \n\t\tif (hw->chip_rev == CHIP_REV_YU_EC_A1) {\n\t\t\tdev_err(&hw->pdev->dev, \"unsupported revision Yukon-EC rev A1\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\thw->flags = SKY2_HW_GIGABIT | SKY2_HW_RSS_BROKEN;\n\t\tbreak;\n\n\tcase CHIP_ID_YUKON_FE:\n\t\thw->flags = SKY2_HW_RSS_BROKEN;\n\t\tbreak;\n\n\tcase CHIP_ID_YUKON_FE_P:\n\t\thw->flags = SKY2_HW_NEWER_PHY\n\t\t\t| SKY2_HW_NEW_LE\n\t\t\t| SKY2_HW_AUTO_TX_SUM\n\t\t\t| SKY2_HW_ADV_POWER_CTL;\n\n\t\t \n\t\tif (hw->chip_rev == CHIP_REV_YU_FE2_A0)\n\t\t\thw->flags |= SKY2_HW_VLAN_BROKEN | SKY2_HW_RSS_CHKSUM;\n\t\tbreak;\n\n\tcase CHIP_ID_YUKON_SUPR:\n\t\thw->flags = SKY2_HW_GIGABIT\n\t\t\t| SKY2_HW_NEWER_PHY\n\t\t\t| SKY2_HW_NEW_LE\n\t\t\t| SKY2_HW_AUTO_TX_SUM\n\t\t\t| SKY2_HW_ADV_POWER_CTL;\n\n\t\tif (hw->chip_rev == CHIP_REV_YU_SU_A0)\n\t\t\thw->flags |= SKY2_HW_RSS_CHKSUM;\n\t\tbreak;\n\n\tcase CHIP_ID_YUKON_UL_2:\n\t\thw->flags = SKY2_HW_GIGABIT\n\t\t\t| SKY2_HW_ADV_POWER_CTL;\n\t\tbreak;\n\n\tcase CHIP_ID_YUKON_OPT:\n\tcase CHIP_ID_YUKON_PRM:\n\tcase CHIP_ID_YUKON_OP_2:\n\t\thw->flags = SKY2_HW_GIGABIT\n\t\t\t| SKY2_HW_NEW_LE\n\t\t\t| SKY2_HW_ADV_POWER_CTL;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&hw->pdev->dev, \"unsupported chip type 0x%x\\n\",\n\t\t\thw->chip_id);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\thw->pmd_type = sky2_read8(hw, B2_PMD_TYP);\n\tif (hw->pmd_type == 'L' || hw->pmd_type == 'S' || hw->pmd_type == 'P')\n\t\thw->flags |= SKY2_HW_FIBRE_PHY;\n\n\thw->ports = 1;\n\tt8 = sky2_read8(hw, B2_Y2_HW_RES);\n\tif ((t8 & CFG_DUAL_MAC_MSK) == CFG_DUAL_MAC_MSK) {\n\t\tif (!(sky2_read8(hw, B2_Y2_CLK_GATE) & Y2_STATUS_LNK2_INAC))\n\t\t\t++hw->ports;\n\t}\n\n\tif (sky2_read8(hw, B2_E_0))\n\t\thw->flags |= SKY2_HW_RAM_BUFFER;\n\n\treturn 0;\n}\n\nstatic void sky2_reset(struct sky2_hw *hw)\n{\n\tstruct pci_dev *pdev = hw->pdev;\n\tu16 status;\n\tint i;\n\tu32 hwe_mask = Y2_HWE_ALL_MASK;\n\n\t \n\tif (hw->chip_id == CHIP_ID_YUKON_EX\n\t    || hw->chip_id == CHIP_ID_YUKON_SUPR) {\n\t\tsky2_write32(hw, CPU_WDOG, 0);\n\t\tstatus = sky2_read16(hw, HCU_CCSR);\n\t\tstatus &= ~(HCU_CCSR_AHB_RST | HCU_CCSR_CPU_RST_MODE |\n\t\t\t    HCU_CCSR_UC_STATE_MSK);\n\t\t \n\t\tstatus &= ~HCU_CCSR_CPU_CLK_DIVIDE_MSK;\n\t\tsky2_write16(hw, HCU_CCSR, status);\n\t\tsky2_write32(hw, CPU_WDOG, 0);\n\t} else\n\t\tsky2_write8(hw, B28_Y2_ASF_STAT_CMD, Y2_ASF_RESET);\n\tsky2_write16(hw, B0_CTST, Y2_ASF_DISABLE);\n\n\t \n\tsky2_write8(hw, B0_CTST, CS_RST_SET);\n\tsky2_write8(hw, B0_CTST, CS_RST_CLR);\n\n\t \n\tsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);\n\n\t \n\tstatus = sky2_pci_read16(hw, PCI_STATUS);\n\tstatus |= PCI_STATUS_ERROR_BITS;\n\tsky2_pci_write16(hw, PCI_STATUS, status);\n\n\tsky2_write8(hw, B0_CTST, CS_MRST_CLR);\n\n\tif (pci_is_pcie(pdev)) {\n\t\tsky2_write32(hw, Y2_CFG_AER + PCI_ERR_UNCOR_STATUS,\n\t\t\t     0xfffffffful);\n\n\t\t \n\t\tif (sky2_read32(hw, B0_HWE_ISRC) & Y2_IS_PCI_EXP)\n\t\t\tdev_info(&pdev->dev, \"ignoring stuck error report bit\\n\");\n\t\telse\n\t\t\thwe_mask |= Y2_IS_PCI_EXP;\n\t}\n\n\tsky2_power_on(hw);\n\tsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);\n\n\tfor (i = 0; i < hw->ports; i++) {\n\t\tsky2_write8(hw, SK_REG(i, GMAC_LINK_CTRL), GMLC_RST_SET);\n\t\tsky2_write8(hw, SK_REG(i, GMAC_LINK_CTRL), GMLC_RST_CLR);\n\n\t\tif (hw->chip_id == CHIP_ID_YUKON_EX ||\n\t\t    hw->chip_id == CHIP_ID_YUKON_SUPR)\n\t\t\tsky2_write16(hw, SK_REG(i, GMAC_CTRL),\n\t\t\t\t     GMC_BYP_MACSECRX_ON | GMC_BYP_MACSECTX_ON\n\t\t\t\t     | GMC_BYP_RETR_ON);\n\n\t}\n\n\tif (hw->chip_id == CHIP_ID_YUKON_SUPR && hw->chip_rev > CHIP_REV_YU_SU_B0) {\n\t\t \n\t\tsky2_pci_write32(hw, PCI_DEV_REG3, P_CLK_MACSEC_DIS);\n\t}\n\n\tif (hw->chip_id == CHIP_ID_YUKON_OPT ||\n\t    hw->chip_id == CHIP_ID_YUKON_PRM ||\n\t    hw->chip_id == CHIP_ID_YUKON_OP_2) {\n\t\tu16 reg;\n\n\t\tif (hw->chip_id == CHIP_ID_YUKON_OPT && hw->chip_rev == 0) {\n\t\t\t \n\t\t\tsky2_write32(hw, Y2_PEX_PHY_DATA, (0x80UL << 16) | (1 << 7));\n\n\t\t\t \n\t\t\treg = 10;\n\n\t\t\t \n\t\t\tsky2_write32(hw, Y2_PEX_PHY_DATA, PEX_DB_ACCESS | (0x08UL << 16));\n\t\t} else {\n\t\t\t \n\t\t\treg = 3;\n\t\t}\n\n\t\treg <<= PSM_CONFIG_REG4_TIMER_PHY_LINK_DETECT_BASE;\n\t\treg |= PSM_CONFIG_REG4_RST_PHY_LINK_DETECT;\n\n\t\t \n\t\tsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_ON);\n\t\tsky2_pci_write16(hw, PSM_CONFIG_REG4, reg);\n\n\t\t \n\t\treg = sky2_pci_read16(hw, PSM_CONFIG_REG3);\n\t\tif (reg & PCI_EXP_LNKCTL_ASPMC)\n\t\t\t \n\t\t\tsky2_pci_write16(hw, pdev->pcie_cap + PCI_EXP_LNKCTL,\n\t\t\t\t\t reg);\n\n\t\tif (hw->chip_id == CHIP_ID_YUKON_PRM &&\n\t\t\thw->chip_rev == CHIP_REV_YU_PRM_A0) {\n\t\t\t \n\t\t\treg = sky2_read16(hw, GPHY_CTRL);\n\t\t\tsky2_write16(hw, GPHY_CTRL, reg | GPC_INTPOL);\n\n\t\t\t \n\t\t\treg = sky2_read16(hw, Y2_CFG_SPC + PCI_LDO_CTRL);\n\t\t\tsky2_write16(hw, Y2_CFG_SPC + PCI_LDO_CTRL, reg | PHY_M_UNDOC1);\n\t\t}\n\n\t\tsky2_write8(hw, B2_TST_CTRL1, TST_CFG_WRITE_OFF);\n\n\t\t \n\t\tsky2_write32(hw, Y2_PEX_PHY_DATA, PEX_DB_ACCESS | (0x08UL << 16));\n\t}\n\n\t \n\tsky2_write32(hw, B2_I2C_IRQ, 1);\n\n\t \n\tsky2_write8(hw, B2_TI_CTRL, TIM_STOP);\n\tsky2_write8(hw, B2_TI_CTRL, TIM_CLR_IRQ);\n\n\t \n\tsky2_write32(hw, B28_DPT_CTRL, DPT_STOP);\n\n\t \n\tsky2_write8(hw, GMAC_TI_ST_CTRL, GMT_ST_STOP);\n\tsky2_write8(hw, GMAC_TI_ST_CTRL, GMT_ST_CLR_IRQ);\n\n\t \n\tfor (i = 0; i < hw->ports; i++)\n\t\tsky2_write8(hw, SK_REG(i, TXA_CTRL), TXA_ENA_ARB);\n\n\t \n\tfor (i = 0; i < hw->ports; i++) {\n\t\tsky2_write8(hw, RAM_BUFFER(i, B3_RI_CTRL), RI_RST_CLR);\n\n\t\tsky2_write8(hw, RAM_BUFFER(i, B3_RI_WTO_R1), SK_RI_TO_53);\n\t\tsky2_write8(hw, RAM_BUFFER(i, B3_RI_WTO_XA1), SK_RI_TO_53);\n\t\tsky2_write8(hw, RAM_BUFFER(i, B3_RI_WTO_XS1), SK_RI_TO_53);\n\t\tsky2_write8(hw, RAM_BUFFER(i, B3_RI_RTO_R1), SK_RI_TO_53);\n\t\tsky2_write8(hw, RAM_BUFFER(i, B3_RI_RTO_XA1), SK_RI_TO_53);\n\t\tsky2_write8(hw, RAM_BUFFER(i, B3_RI_RTO_XS1), SK_RI_TO_53);\n\t\tsky2_write8(hw, RAM_BUFFER(i, B3_RI_WTO_R2), SK_RI_TO_53);\n\t\tsky2_write8(hw, RAM_BUFFER(i, B3_RI_WTO_XA2), SK_RI_TO_53);\n\t\tsky2_write8(hw, RAM_BUFFER(i, B3_RI_WTO_XS2), SK_RI_TO_53);\n\t\tsky2_write8(hw, RAM_BUFFER(i, B3_RI_RTO_R2), SK_RI_TO_53);\n\t\tsky2_write8(hw, RAM_BUFFER(i, B3_RI_RTO_XA2), SK_RI_TO_53);\n\t\tsky2_write8(hw, RAM_BUFFER(i, B3_RI_RTO_XS2), SK_RI_TO_53);\n\t}\n\n\tsky2_write32(hw, B0_HWE_IMSK, hwe_mask);\n\n\tfor (i = 0; i < hw->ports; i++)\n\t\tsky2_gmac_reset(hw, i);\n\n\tmemset(hw->st_le, 0, hw->st_size * sizeof(struct sky2_status_le));\n\thw->st_idx = 0;\n\n\tsky2_write32(hw, STAT_CTRL, SC_STAT_RST_SET);\n\tsky2_write32(hw, STAT_CTRL, SC_STAT_RST_CLR);\n\n\tsky2_write32(hw, STAT_LIST_ADDR_LO, hw->st_dma);\n\tsky2_write32(hw, STAT_LIST_ADDR_HI, (u64) hw->st_dma >> 32);\n\n\t \n\tsky2_write16(hw, STAT_LAST_IDX, hw->st_size - 1);\n\n\tsky2_write16(hw, STAT_TX_IDX_TH, 10);\n\tsky2_write8(hw, STAT_FIFO_WM, 16);\n\n\t \n\tif (hw->chip_id == CHIP_ID_YUKON_XL && hw->chip_rev == 0)\n\t\tsky2_write8(hw, STAT_FIFO_ISR_WM, 4);\n\telse\n\t\tsky2_write8(hw, STAT_FIFO_ISR_WM, 16);\n\n\tsky2_write32(hw, STAT_TX_TIMER_INI, sky2_us2clk(hw, 1000));\n\tsky2_write32(hw, STAT_ISR_TIMER_INI, sky2_us2clk(hw, 20));\n\tsky2_write32(hw, STAT_LEV_TIMER_INI, sky2_us2clk(hw, 100));\n\n\t \n\tsky2_write32(hw, STAT_CTRL, SC_STAT_OP_ON);\n\n\tsky2_write8(hw, STAT_TX_TIMER_CTRL, TIM_START);\n\tsky2_write8(hw, STAT_LEV_TIMER_CTRL, TIM_START);\n\tsky2_write8(hw, STAT_ISR_TIMER_CTRL, TIM_START);\n}\n\n \nstatic void sky2_detach(struct net_device *dev)\n{\n\tif (netif_running(dev)) {\n\t\tnetif_tx_lock(dev);\n\t\tnetif_device_detach(dev);\t \n\t\tnetif_tx_unlock(dev);\n\t\tsky2_close(dev);\n\t}\n}\n\n \nstatic int sky2_reattach(struct net_device *dev)\n{\n\tint err = 0;\n\n\tif (netif_running(dev)) {\n\t\terr = sky2_open(dev);\n\t\tif (err) {\n\t\t\tnetdev_info(dev, \"could not restart %d\\n\", err);\n\t\t\tdev_close(dev);\n\t\t} else {\n\t\t\tnetif_device_attach(dev);\n\t\t\tsky2_set_multicast(dev);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic void sky2_all_down(struct sky2_hw *hw)\n{\n\tint i;\n\n\tif (hw->flags & SKY2_HW_IRQ_SETUP) {\n\t\tsky2_write32(hw, B0_IMSK, 0);\n\t\tsky2_read32(hw, B0_IMSK);\n\n\t\tsynchronize_irq(hw->pdev->irq);\n\t\tnapi_disable(&hw->napi);\n\t}\n\n\tfor (i = 0; i < hw->ports; i++) {\n\t\tstruct net_device *dev = hw->dev[i];\n\t\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\t\tif (!netif_running(dev))\n\t\t\tcontinue;\n\n\t\tnetif_carrier_off(dev);\n\t\tnetif_tx_disable(dev);\n\t\tsky2_hw_down(sky2);\n\t}\n}\n\nstatic void sky2_all_up(struct sky2_hw *hw)\n{\n\tu32 imask = Y2_IS_BASE;\n\tint i;\n\n\tfor (i = 0; i < hw->ports; i++) {\n\t\tstruct net_device *dev = hw->dev[i];\n\t\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\t\tif (!netif_running(dev))\n\t\t\tcontinue;\n\n\t\tsky2_hw_up(sky2);\n\t\tsky2_set_multicast(dev);\n\t\timask |= portirq_msk[i];\n\t\tnetif_wake_queue(dev);\n\t}\n\n\tif (hw->flags & SKY2_HW_IRQ_SETUP) {\n\t\tsky2_write32(hw, B0_IMSK, imask);\n\t\tsky2_read32(hw, B0_IMSK);\n\t\tsky2_read32(hw, B0_Y2_SP_LISR);\n\t\tnapi_enable(&hw->napi);\n\t}\n}\n\nstatic void sky2_restart(struct work_struct *work)\n{\n\tstruct sky2_hw *hw = container_of(work, struct sky2_hw, restart_work);\n\n\trtnl_lock();\n\n\tsky2_all_down(hw);\n\tsky2_reset(hw);\n\tsky2_all_up(hw);\n\n\trtnl_unlock();\n}\n\nstatic inline u8 sky2_wol_supported(const struct sky2_hw *hw)\n{\n\treturn sky2_is_copper(hw) ? (WAKE_PHY | WAKE_MAGIC) : 0;\n}\n\nstatic void sky2_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tconst struct sky2_port *sky2 = netdev_priv(dev);\n\n\twol->supported = sky2_wol_supported(sky2->hw);\n\twol->wolopts = sky2->wol;\n}\n\nstatic int sky2_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tbool enable_wakeup = false;\n\tint i;\n\n\tif ((wol->wolopts & ~sky2_wol_supported(sky2->hw)) ||\n\t    !device_can_wakeup(&hw->pdev->dev))\n\t\treturn -EOPNOTSUPP;\n\n\tsky2->wol = wol->wolopts;\n\n\tfor (i = 0; i < hw->ports; i++) {\n\t\tstruct net_device *dev = hw->dev[i];\n\t\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\t\tif (sky2->wol)\n\t\t\tenable_wakeup = true;\n\t}\n\tdevice_set_wakeup_enable(&hw->pdev->dev, enable_wakeup);\n\n\treturn 0;\n}\n\nstatic u32 sky2_supported_modes(const struct sky2_hw *hw)\n{\n\tif (sky2_is_copper(hw)) {\n\t\tu32 modes = SUPPORTED_10baseT_Half\n\t\t\t| SUPPORTED_10baseT_Full\n\t\t\t| SUPPORTED_100baseT_Half\n\t\t\t| SUPPORTED_100baseT_Full;\n\n\t\tif (hw->flags & SKY2_HW_GIGABIT)\n\t\t\tmodes |= SUPPORTED_1000baseT_Half\n\t\t\t\t| SUPPORTED_1000baseT_Full;\n\t\treturn modes;\n\t} else\n\t\treturn SUPPORTED_1000baseT_Half\n\t\t\t| SUPPORTED_1000baseT_Full;\n}\n\nstatic int sky2_get_link_ksettings(struct net_device *dev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tu32 supported, advertising;\n\n\tsupported = sky2_supported_modes(hw);\n\tcmd->base.phy_address = PHY_ADDR_MARV;\n\tif (sky2_is_copper(hw)) {\n\t\tcmd->base.port = PORT_TP;\n\t\tcmd->base.speed = sky2->speed;\n\t\tsupported |=  SUPPORTED_Autoneg | SUPPORTED_TP;\n\t} else {\n\t\tcmd->base.speed = SPEED_1000;\n\t\tcmd->base.port = PORT_FIBRE;\n\t\tsupported |=  SUPPORTED_Autoneg | SUPPORTED_FIBRE;\n\t}\n\n\tadvertising = sky2->advertising;\n\tcmd->base.autoneg = (sky2->flags & SKY2_FLAG_AUTO_SPEED)\n\t\t? AUTONEG_ENABLE : AUTONEG_DISABLE;\n\tcmd->base.duplex = sky2->duplex;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic int sky2_set_link_ksettings(struct net_device *dev,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tconst struct sky2_hw *hw = sky2->hw;\n\tu32 supported = sky2_supported_modes(hw);\n\tu32 new_advertising;\n\n\tethtool_convert_link_mode_to_legacy_u32(&new_advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tif (new_advertising & ~supported)\n\t\t\treturn -EINVAL;\n\n\t\tif (sky2_is_copper(hw))\n\t\t\tsky2->advertising = new_advertising |\n\t\t\t\t\t    ADVERTISED_TP |\n\t\t\t\t\t    ADVERTISED_Autoneg;\n\t\telse\n\t\t\tsky2->advertising = new_advertising |\n\t\t\t\t\t    ADVERTISED_FIBRE |\n\t\t\t\t\t    ADVERTISED_Autoneg;\n\n\t\tsky2->flags |= SKY2_FLAG_AUTO_SPEED;\n\t\tsky2->duplex = -1;\n\t\tsky2->speed = -1;\n\t} else {\n\t\tu32 setting;\n\t\tu32 speed = cmd->base.speed;\n\n\t\tswitch (speed) {\n\t\tcase SPEED_1000:\n\t\t\tif (cmd->base.duplex == DUPLEX_FULL)\n\t\t\t\tsetting = SUPPORTED_1000baseT_Full;\n\t\t\telse if (cmd->base.duplex == DUPLEX_HALF)\n\t\t\t\tsetting = SUPPORTED_1000baseT_Half;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tif (cmd->base.duplex == DUPLEX_FULL)\n\t\t\t\tsetting = SUPPORTED_100baseT_Full;\n\t\t\telse if (cmd->base.duplex == DUPLEX_HALF)\n\t\t\t\tsetting = SUPPORTED_100baseT_Half;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase SPEED_10:\n\t\t\tif (cmd->base.duplex == DUPLEX_FULL)\n\t\t\t\tsetting = SUPPORTED_10baseT_Full;\n\t\t\telse if (cmd->base.duplex == DUPLEX_HALF)\n\t\t\t\tsetting = SUPPORTED_10baseT_Half;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((setting & supported) == 0)\n\t\t\treturn -EINVAL;\n\n\t\tsky2->speed = speed;\n\t\tsky2->duplex = cmd->base.duplex;\n\t\tsky2->flags &= ~SKY2_FLAG_AUTO_SPEED;\n\t}\n\n\tif (netif_running(dev)) {\n\t\tsky2_phy_reinit(sky2);\n\t\tsky2_set_multicast(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void sky2_get_drvinfo(struct net_device *dev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(sky2->hw->pdev),\n\t\tsizeof(info->bus_info));\n}\n\nstatic const struct sky2_stat {\n\tchar name[ETH_GSTRING_LEN];\n\tu16 offset;\n} sky2_stats[] = {\n\t{ \"tx_bytes\",\t   GM_TXO_OK_HI },\n\t{ \"rx_bytes\",\t   GM_RXO_OK_HI },\n\t{ \"tx_broadcast\",  GM_TXF_BC_OK },\n\t{ \"rx_broadcast\",  GM_RXF_BC_OK },\n\t{ \"tx_multicast\",  GM_TXF_MC_OK },\n\t{ \"rx_multicast\",  GM_RXF_MC_OK },\n\t{ \"tx_unicast\",    GM_TXF_UC_OK },\n\t{ \"rx_unicast\",    GM_RXF_UC_OK },\n\t{ \"tx_mac_pause\",  GM_TXF_MPAUSE },\n\t{ \"rx_mac_pause\",  GM_RXF_MPAUSE },\n\t{ \"collisions\",    GM_TXF_COL },\n\t{ \"late_collision\",GM_TXF_LAT_COL },\n\t{ \"aborted\", \t   GM_TXF_ABO_COL },\n\t{ \"single_collisions\", GM_TXF_SNG_COL },\n\t{ \"multi_collisions\", GM_TXF_MUL_COL },\n\n\t{ \"rx_short\",      GM_RXF_SHT },\n\t{ \"rx_runt\", \t   GM_RXE_FRAG },\n\t{ \"rx_64_byte_packets\", GM_RXF_64B },\n\t{ \"rx_65_to_127_byte_packets\", GM_RXF_127B },\n\t{ \"rx_128_to_255_byte_packets\", GM_RXF_255B },\n\t{ \"rx_256_to_511_byte_packets\", GM_RXF_511B },\n\t{ \"rx_512_to_1023_byte_packets\", GM_RXF_1023B },\n\t{ \"rx_1024_to_1518_byte_packets\", GM_RXF_1518B },\n\t{ \"rx_1518_to_max_byte_packets\", GM_RXF_MAX_SZ },\n\t{ \"rx_too_long\",   GM_RXF_LNG_ERR },\n\t{ \"rx_fifo_overflow\", GM_RXE_FIFO_OV },\n\t{ \"rx_jabber\",     GM_RXF_JAB_PKT },\n\t{ \"rx_fcs_error\",   GM_RXF_FCS_ERR },\n\n\t{ \"tx_64_byte_packets\", GM_TXF_64B },\n\t{ \"tx_65_to_127_byte_packets\", GM_TXF_127B },\n\t{ \"tx_128_to_255_byte_packets\", GM_TXF_255B },\n\t{ \"tx_256_to_511_byte_packets\", GM_TXF_511B },\n\t{ \"tx_512_to_1023_byte_packets\", GM_TXF_1023B },\n\t{ \"tx_1024_to_1518_byte_packets\", GM_TXF_1518B },\n\t{ \"tx_1519_to_max_byte_packets\", GM_TXF_MAX_SZ },\n\t{ \"tx_fifo_underrun\", GM_TXE_FIFO_UR },\n};\n\nstatic u32 sky2_get_msglevel(struct net_device *netdev)\n{\n\tstruct sky2_port *sky2 = netdev_priv(netdev);\n\treturn sky2->msg_enable;\n}\n\nstatic int sky2_nway_reset(struct net_device *dev)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\tif (!netif_running(dev) || !(sky2->flags & SKY2_FLAG_AUTO_SPEED))\n\t\treturn -EINVAL;\n\n\tsky2_phy_reinit(sky2);\n\tsky2_set_multicast(dev);\n\n\treturn 0;\n}\n\nstatic void sky2_phy_stats(struct sky2_port *sky2, u64 * data, unsigned count)\n{\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tint i;\n\n\tdata[0] = get_stats64(hw, port, GM_TXO_OK_LO);\n\tdata[1] = get_stats64(hw, port, GM_RXO_OK_LO);\n\n\tfor (i = 2; i < count; i++)\n\t\tdata[i] = get_stats32(hw, port, sky2_stats[i].offset);\n}\n\nstatic void sky2_set_msglevel(struct net_device *netdev, u32 value)\n{\n\tstruct sky2_port *sky2 = netdev_priv(netdev);\n\tsky2->msg_enable = value;\n}\n\nstatic int sky2_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(sky2_stats);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void sky2_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t   struct ethtool_stats *stats, u64 * data)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\tsky2_phy_stats(sky2, data, ARRAY_SIZE(sky2_stats));\n}\n\nstatic void sky2_get_strings(struct net_device *dev, u32 stringset, u8 * data)\n{\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < ARRAY_SIZE(sky2_stats); i++)\n\t\t\tmemcpy(data + i * ETH_GSTRING_LEN,\n\t\t\t       sky2_stats[i].name, ETH_GSTRING_LEN);\n\t\tbreak;\n\t}\n}\n\nstatic int sky2_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tconst struct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\tmemcpy_toio(hw->regs + B2_MAC_1 + port * 8,\n\t\t    dev->dev_addr, ETH_ALEN);\n\tmemcpy_toio(hw->regs + B2_MAC_2 + port * 8,\n\t\t    dev->dev_addr, ETH_ALEN);\n\n\t \n\tgma_set_addr(hw, port, GM_SRC_ADDR_2L, dev->dev_addr);\n\n\t \n\tgma_set_addr(hw, port, GM_SRC_ADDR_1L, dev->dev_addr);\n\n\treturn 0;\n}\n\nstatic inline void sky2_add_filter(u8 filter[8], const u8 *addr)\n{\n\tu32 bit;\n\n\tbit = ether_crc(ETH_ALEN, addr) & 63;\n\tfilter[bit >> 3] |= 1 << (bit & 7);\n}\n\nstatic void sky2_set_multicast(struct net_device *dev)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tstruct netdev_hw_addr *ha;\n\tu16 reg;\n\tu8 filter[8];\n\tint rx_pause;\n\tstatic const u8 pause_mc_addr[ETH_ALEN] = { 0x1, 0x80, 0xc2, 0x0, 0x0, 0x1 };\n\n\trx_pause = (sky2->flow_status == FC_RX || sky2->flow_status == FC_BOTH);\n\tmemset(filter, 0, sizeof(filter));\n\n\treg = gma_read16(hw, port, GM_RX_CTRL);\n\treg |= GM_RXCR_UCF_ENA;\n\n\tif (dev->flags & IFF_PROMISC)\t \n\t\treg &= ~(GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA);\n\telse if (dev->flags & IFF_ALLMULTI)\n\t\tmemset(filter, 0xff, sizeof(filter));\n\telse if (netdev_mc_empty(dev) && !rx_pause)\n\t\treg &= ~GM_RXCR_MCF_ENA;\n\telse {\n\t\treg |= GM_RXCR_MCF_ENA;\n\n\t\tif (rx_pause)\n\t\t\tsky2_add_filter(filter, pause_mc_addr);\n\n\t\tnetdev_for_each_mc_addr(ha, dev)\n\t\t\tsky2_add_filter(filter, ha->addr);\n\t}\n\n\tgma_write16(hw, port, GM_MC_ADDR_H1,\n\t\t    (u16) filter[0] | ((u16) filter[1] << 8));\n\tgma_write16(hw, port, GM_MC_ADDR_H2,\n\t\t    (u16) filter[2] | ((u16) filter[3] << 8));\n\tgma_write16(hw, port, GM_MC_ADDR_H3,\n\t\t    (u16) filter[4] | ((u16) filter[5] << 8));\n\tgma_write16(hw, port, GM_MC_ADDR_H4,\n\t\t    (u16) filter[6] | ((u16) filter[7] << 8));\n\n\tgma_write16(hw, port, GM_RX_CTRL, reg);\n}\n\nstatic void sky2_get_stats(struct net_device *dev,\n\t\t\t   struct rtnl_link_stats64 *stats)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tunsigned int start;\n\tu64 _bytes, _packets;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&sky2->rx_stats.syncp);\n\t\t_bytes = sky2->rx_stats.bytes;\n\t\t_packets = sky2->rx_stats.packets;\n\t} while (u64_stats_fetch_retry(&sky2->rx_stats.syncp, start));\n\n\tstats->rx_packets = _packets;\n\tstats->rx_bytes = _bytes;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&sky2->tx_stats.syncp);\n\t\t_bytes = sky2->tx_stats.bytes;\n\t\t_packets = sky2->tx_stats.packets;\n\t} while (u64_stats_fetch_retry(&sky2->tx_stats.syncp, start));\n\n\tstats->tx_packets = _packets;\n\tstats->tx_bytes = _bytes;\n\n\tstats->multicast = get_stats32(hw, port, GM_RXF_MC_OK)\n\t\t+ get_stats32(hw, port, GM_RXF_BC_OK);\n\n\tstats->collisions = get_stats32(hw, port, GM_TXF_COL);\n\n\tstats->rx_length_errors = get_stats32(hw, port, GM_RXF_LNG_ERR);\n\tstats->rx_crc_errors = get_stats32(hw, port, GM_RXF_FCS_ERR);\n\tstats->rx_frame_errors = get_stats32(hw, port, GM_RXF_SHT)\n\t\t+ get_stats32(hw, port, GM_RXE_FRAG);\n\tstats->rx_over_errors = get_stats32(hw, port, GM_RXE_FIFO_OV);\n\n\tstats->rx_dropped = dev->stats.rx_dropped;\n\tstats->rx_fifo_errors = dev->stats.rx_fifo_errors;\n\tstats->tx_fifo_errors = dev->stats.tx_fifo_errors;\n}\n\n \nstatic void sky2_led(struct sky2_port *sky2, enum led_mode mode)\n{\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\n\tspin_lock_bh(&sky2->phy_lock);\n\tif (hw->chip_id == CHIP_ID_YUKON_EC_U ||\n\t    hw->chip_id == CHIP_ID_YUKON_EX ||\n\t    hw->chip_id == CHIP_ID_YUKON_SUPR) {\n\t\tu16 pg;\n\t\tpg = gm_phy_read(hw, port, PHY_MARV_EXT_ADR);\n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, 3);\n\n\t\tswitch (mode) {\n\t\tcase MO_LED_OFF:\n\t\t\tgm_phy_write(hw, port, PHY_MARV_PHY_CTRL,\n\t\t\t\t     PHY_M_LEDC_LOS_CTRL(8) |\n\t\t\t\t     PHY_M_LEDC_INIT_CTRL(8) |\n\t\t\t\t     PHY_M_LEDC_STA1_CTRL(8) |\n\t\t\t\t     PHY_M_LEDC_STA0_CTRL(8));\n\t\t\tbreak;\n\t\tcase MO_LED_ON:\n\t\t\tgm_phy_write(hw, port, PHY_MARV_PHY_CTRL,\n\t\t\t\t     PHY_M_LEDC_LOS_CTRL(9) |\n\t\t\t\t     PHY_M_LEDC_INIT_CTRL(9) |\n\t\t\t\t     PHY_M_LEDC_STA1_CTRL(9) |\n\t\t\t\t     PHY_M_LEDC_STA0_CTRL(9));\n\t\t\tbreak;\n\t\tcase MO_LED_BLINK:\n\t\t\tgm_phy_write(hw, port, PHY_MARV_PHY_CTRL,\n\t\t\t\t     PHY_M_LEDC_LOS_CTRL(0xa) |\n\t\t\t\t     PHY_M_LEDC_INIT_CTRL(0xa) |\n\t\t\t\t     PHY_M_LEDC_STA1_CTRL(0xa) |\n\t\t\t\t     PHY_M_LEDC_STA0_CTRL(0xa));\n\t\t\tbreak;\n\t\tcase MO_LED_NORM:\n\t\t\tgm_phy_write(hw, port, PHY_MARV_PHY_CTRL,\n\t\t\t\t     PHY_M_LEDC_LOS_CTRL(1) |\n\t\t\t\t     PHY_M_LEDC_INIT_CTRL(8) |\n\t\t\t\t     PHY_M_LEDC_STA1_CTRL(7) |\n\t\t\t\t     PHY_M_LEDC_STA0_CTRL(7));\n\t\t}\n\n\t\tgm_phy_write(hw, port, PHY_MARV_EXT_ADR, pg);\n\t} else\n\t\tgm_phy_write(hw, port, PHY_MARV_LED_OVER,\n\t\t\t\t     PHY_M_LED_MO_DUP(mode) |\n\t\t\t\t     PHY_M_LED_MO_10(mode) |\n\t\t\t\t     PHY_M_LED_MO_100(mode) |\n\t\t\t\t     PHY_M_LED_MO_1000(mode) |\n\t\t\t\t     PHY_M_LED_MO_RX(mode) |\n\t\t\t\t     PHY_M_LED_MO_TX(mode));\n\n\tspin_unlock_bh(&sky2->phy_lock);\n}\n\n \nstatic int sky2_set_phys_id(struct net_device *dev,\n\t\t\t    enum ethtool_phys_id_state state)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\treturn 1;\t \n\tcase ETHTOOL_ID_INACTIVE:\n\t\tsky2_led(sky2, MO_LED_NORM);\n\t\tbreak;\n\tcase ETHTOOL_ID_ON:\n\t\tsky2_led(sky2, MO_LED_ON);\n\t\tbreak;\n\tcase ETHTOOL_ID_OFF:\n\t\tsky2_led(sky2, MO_LED_OFF);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void sky2_get_pauseparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_pauseparam *ecmd)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\tswitch (sky2->flow_mode) {\n\tcase FC_NONE:\n\t\tecmd->tx_pause = ecmd->rx_pause = 0;\n\t\tbreak;\n\tcase FC_TX:\n\t\tecmd->tx_pause = 1, ecmd->rx_pause = 0;\n\t\tbreak;\n\tcase FC_RX:\n\t\tecmd->tx_pause = 0, ecmd->rx_pause = 1;\n\t\tbreak;\n\tcase FC_BOTH:\n\t\tecmd->tx_pause = ecmd->rx_pause = 1;\n\t}\n\n\tecmd->autoneg = (sky2->flags & SKY2_FLAG_AUTO_PAUSE)\n\t\t? AUTONEG_ENABLE : AUTONEG_DISABLE;\n}\n\nstatic int sky2_set_pauseparam(struct net_device *dev,\n\t\t\t       struct ethtool_pauseparam *ecmd)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\tif (ecmd->autoneg == AUTONEG_ENABLE)\n\t\tsky2->flags |= SKY2_FLAG_AUTO_PAUSE;\n\telse\n\t\tsky2->flags &= ~SKY2_FLAG_AUTO_PAUSE;\n\n\tsky2->flow_mode = sky2_flow(ecmd->rx_pause, ecmd->tx_pause);\n\n\tif (netif_running(dev))\n\t\tsky2_phy_reinit(sky2);\n\n\treturn 0;\n}\n\nstatic int sky2_get_coalesce(struct net_device *dev,\n\t\t\t     struct ethtool_coalesce *ecmd,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\n\tif (sky2_read8(hw, STAT_TX_TIMER_CTRL) == TIM_STOP)\n\t\tecmd->tx_coalesce_usecs = 0;\n\telse {\n\t\tu32 clks = sky2_read32(hw, STAT_TX_TIMER_INI);\n\t\tecmd->tx_coalesce_usecs = sky2_clk2us(hw, clks);\n\t}\n\tecmd->tx_max_coalesced_frames = sky2_read16(hw, STAT_TX_IDX_TH);\n\n\tif (sky2_read8(hw, STAT_LEV_TIMER_CTRL) == TIM_STOP)\n\t\tecmd->rx_coalesce_usecs = 0;\n\telse {\n\t\tu32 clks = sky2_read32(hw, STAT_LEV_TIMER_INI);\n\t\tecmd->rx_coalesce_usecs = sky2_clk2us(hw, clks);\n\t}\n\tecmd->rx_max_coalesced_frames = sky2_read8(hw, STAT_FIFO_WM);\n\n\tif (sky2_read8(hw, STAT_ISR_TIMER_CTRL) == TIM_STOP)\n\t\tecmd->rx_coalesce_usecs_irq = 0;\n\telse {\n\t\tu32 clks = sky2_read32(hw, STAT_ISR_TIMER_INI);\n\t\tecmd->rx_coalesce_usecs_irq = sky2_clk2us(hw, clks);\n\t}\n\n\tecmd->rx_max_coalesced_frames_irq = sky2_read8(hw, STAT_FIFO_ISR_WM);\n\n\treturn 0;\n}\n\n \nstatic int sky2_set_coalesce(struct net_device *dev,\n\t\t\t     struct ethtool_coalesce *ecmd,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tconst u32 tmax = sky2_clk2us(hw, 0x0ffffff);\n\n\tif (ecmd->tx_coalesce_usecs > tmax ||\n\t    ecmd->rx_coalesce_usecs > tmax ||\n\t    ecmd->rx_coalesce_usecs_irq > tmax)\n\t\treturn -EINVAL;\n\n\tif (ecmd->tx_max_coalesced_frames >= sky2->tx_ring_size-1)\n\t\treturn -EINVAL;\n\tif (ecmd->rx_max_coalesced_frames > RX_MAX_PENDING)\n\t\treturn -EINVAL;\n\tif (ecmd->rx_max_coalesced_frames_irq > RX_MAX_PENDING)\n\t\treturn -EINVAL;\n\n\tif (ecmd->tx_coalesce_usecs == 0)\n\t\tsky2_write8(hw, STAT_TX_TIMER_CTRL, TIM_STOP);\n\telse {\n\t\tsky2_write32(hw, STAT_TX_TIMER_INI,\n\t\t\t     sky2_us2clk(hw, ecmd->tx_coalesce_usecs));\n\t\tsky2_write8(hw, STAT_TX_TIMER_CTRL, TIM_START);\n\t}\n\tsky2_write16(hw, STAT_TX_IDX_TH, ecmd->tx_max_coalesced_frames);\n\n\tif (ecmd->rx_coalesce_usecs == 0)\n\t\tsky2_write8(hw, STAT_LEV_TIMER_CTRL, TIM_STOP);\n\telse {\n\t\tsky2_write32(hw, STAT_LEV_TIMER_INI,\n\t\t\t     sky2_us2clk(hw, ecmd->rx_coalesce_usecs));\n\t\tsky2_write8(hw, STAT_LEV_TIMER_CTRL, TIM_START);\n\t}\n\tsky2_write8(hw, STAT_FIFO_WM, ecmd->rx_max_coalesced_frames);\n\n\tif (ecmd->rx_coalesce_usecs_irq == 0)\n\t\tsky2_write8(hw, STAT_ISR_TIMER_CTRL, TIM_STOP);\n\telse {\n\t\tsky2_write32(hw, STAT_ISR_TIMER_INI,\n\t\t\t     sky2_us2clk(hw, ecmd->rx_coalesce_usecs_irq));\n\t\tsky2_write8(hw, STAT_ISR_TIMER_CTRL, TIM_START);\n\t}\n\tsky2_write8(hw, STAT_FIFO_ISR_WM, ecmd->rx_max_coalesced_frames_irq);\n\treturn 0;\n}\n\n \nstatic unsigned long roundup_ring_size(unsigned long pending)\n{\n\treturn max(128ul, roundup_pow_of_two(pending+1));\n}\n\nstatic void sky2_get_ringparam(struct net_device *dev,\n\t\t\t       struct ethtool_ringparam *ering,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\tering->rx_max_pending = RX_MAX_PENDING;\n\tering->tx_max_pending = TX_MAX_PENDING;\n\n\tering->rx_pending = sky2->rx_pending;\n\tering->tx_pending = sky2->tx_pending;\n}\n\nstatic int sky2_set_ringparam(struct net_device *dev,\n\t\t\t      struct ethtool_ringparam *ering,\n\t\t\t      struct kernel_ethtool_ringparam *kernel_ering,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\tif (ering->rx_pending > RX_MAX_PENDING ||\n\t    ering->rx_pending < 8 ||\n\t    ering->tx_pending < TX_MIN_PENDING ||\n\t    ering->tx_pending > TX_MAX_PENDING)\n\t\treturn -EINVAL;\n\n\tsky2_detach(dev);\n\n\tsky2->rx_pending = ering->rx_pending;\n\tsky2->tx_pending = ering->tx_pending;\n\tsky2->tx_ring_size = roundup_ring_size(sky2->tx_pending);\n\n\treturn sky2_reattach(dev);\n}\n\nstatic int sky2_get_regs_len(struct net_device *dev)\n{\n\treturn 0x4000;\n}\n\nstatic int sky2_reg_access_ok(struct sky2_hw *hw, unsigned int b)\n{\n\t \n\tswitch (b) {\n\t \n\tcase 5:\t\t \n\tcase 9:\t\t \n\tcase 14 ... 15:\t \n\tcase 17: case 19:  \n\tcase 22 ... 23:  \n\tcase 25:\t \n\tcase 27:\t \n\tcase 31:\t \n\tcase 40 ... 47:  \n\tcase 52: case 54:  \n\tcase 112 ... 116:  \n\t\treturn hw->ports > 1;\n\n\tcase 0:\t\t \n\tcase 2:\t\t \n\tcase 4:\t\t \n\tcase 7:\t\t \n\tcase 8:\t\t \n\tcase 12 ... 13:  \n\tcase 16: case 18: \n\tcase 20 ... 21:  \n\tcase 24:\t \n\tcase 26:\t \n\tcase 28 ... 29:  \n\tcase 30:\t \n\tcase 32 ... 39:  \n\tcase 48: case 50:  \n\tcase 56 ... 60:\t \n\tcase 80 ... 84:\t \n\t\treturn 1;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic void sky2_get_regs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t\t  void *p)\n{\n\tconst struct sky2_port *sky2 = netdev_priv(dev);\n\tconst void __iomem *io = sky2->hw->regs;\n\tunsigned int b;\n\n\tregs->version = 1;\n\n\tfor (b = 0; b < 128; b++) {\n\t\t \n\t\tif (b == 3)\n\t\t\tmemcpy_fromio(p + 0x10, io + 0x10, 128 - 0x10);\n\t\telse if (sky2_reg_access_ok(sky2->hw, b))\n\t\t\tmemcpy_fromio(p, io, 128);\n\t\telse\n\t\t\tmemset(p, 0, 128);\n\n\t\tp += 128;\n\t\tio += 128;\n\t}\n}\n\nstatic int sky2_get_eeprom_len(struct net_device *dev)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tu16 reg2;\n\n\treg2 = sky2_pci_read16(hw, PCI_DEV_REG2);\n\treturn 1 << ( ((reg2 & PCI_VPD_ROM_SZ) >> 14) + 8);\n}\n\nstatic int sky2_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\n\t\t\t   u8 *data)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tint rc;\n\n\teeprom->magic = SKY2_EEPROM_MAGIC;\n\trc = pci_read_vpd_any(sky2->hw->pdev, eeprom->offset, eeprom->len,\n\t\t\t      data);\n\tif (rc < 0)\n\t\treturn rc;\n\n\teeprom->len = rc;\n\n\treturn 0;\n}\n\nstatic int sky2_set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,\n\t\t\t   u8 *data)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tint rc;\n\n\tif (eeprom->magic != SKY2_EEPROM_MAGIC)\n\t\treturn -EINVAL;\n\n\trc = pci_write_vpd_any(sky2->hw->pdev, eeprom->offset, eeprom->len,\n\t\t\t       data);\n\n\treturn rc < 0 ? rc : 0;\n}\n\nstatic netdev_features_t sky2_fix_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\tconst struct sky2_port *sky2 = netdev_priv(dev);\n\tconst struct sky2_hw *hw = sky2->hw;\n\n\t \n\tif (dev->mtu > ETH_DATA_LEN && hw->chip_id == CHIP_ID_YUKON_EC_U) {\n\t\tnetdev_info(dev, \"checksum offload not possible with jumbo frames\\n\");\n\t\tfeatures &= ~(NETIF_F_TSO | NETIF_F_SG | NETIF_F_CSUM_MASK);\n\t}\n\n\t \n\tif ( (features & NETIF_F_RXHASH) &&\n\t     !(features & NETIF_F_RXCSUM) &&\n\t     (sky2->hw->flags & SKY2_HW_RSS_CHKSUM)) {\n\t\tnetdev_info(dev, \"receive hashing forces receive checksum\\n\");\n\t\tfeatures |= NETIF_F_RXCSUM;\n\t}\n\n\treturn features;\n}\n\nstatic int sky2_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\tnetdev_features_t changed = dev->features ^ features;\n\n\tif ((changed & NETIF_F_RXCSUM) &&\n\t    !(sky2->hw->flags & SKY2_HW_NEW_LE)) {\n\t\tsky2_write32(sky2->hw,\n\t\t\t     Q_ADDR(rxqaddr[sky2->port], Q_CSR),\n\t\t\t     (features & NETIF_F_RXCSUM)\n\t\t\t     ? BMU_ENA_RX_CHKSUM : BMU_DIS_RX_CHKSUM);\n\t}\n\n\tif (changed & NETIF_F_RXHASH)\n\t\trx_set_rss(dev, features);\n\n\tif (changed & (NETIF_F_HW_VLAN_CTAG_TX|NETIF_F_HW_VLAN_CTAG_RX))\n\t\tsky2_vlan_mode(dev, features);\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops sky2_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_RX_USECS_IRQ |\n\t\t\t\t     ETHTOOL_COALESCE_RX_MAX_FRAMES_IRQ,\n\t.get_drvinfo\t= sky2_get_drvinfo,\n\t.get_wol\t= sky2_get_wol,\n\t.set_wol\t= sky2_set_wol,\n\t.get_msglevel\t= sky2_get_msglevel,\n\t.set_msglevel\t= sky2_set_msglevel,\n\t.nway_reset\t= sky2_nway_reset,\n\t.get_regs_len\t= sky2_get_regs_len,\n\t.get_regs\t= sky2_get_regs,\n\t.get_link\t= ethtool_op_get_link,\n\t.get_eeprom_len\t= sky2_get_eeprom_len,\n\t.get_eeprom\t= sky2_get_eeprom,\n\t.set_eeprom\t= sky2_set_eeprom,\n\t.get_strings\t= sky2_get_strings,\n\t.get_coalesce\t= sky2_get_coalesce,\n\t.set_coalesce\t= sky2_set_coalesce,\n\t.get_ringparam\t= sky2_get_ringparam,\n\t.set_ringparam\t= sky2_set_ringparam,\n\t.get_pauseparam = sky2_get_pauseparam,\n\t.set_pauseparam = sky2_set_pauseparam,\n\t.set_phys_id\t= sky2_set_phys_id,\n\t.get_sset_count = sky2_get_sset_count,\n\t.get_ethtool_stats = sky2_get_ethtool_stats,\n\t.get_link_ksettings = sky2_get_link_ksettings,\n\t.set_link_ksettings = sky2_set_link_ksettings,\n};\n\n#ifdef CONFIG_SKY2_DEBUG\n\nstatic struct dentry *sky2_debug;\n\nstatic int sky2_debug_show(struct seq_file *seq, void *v)\n{\n\tstruct net_device *dev = seq->private;\n\tconst struct sky2_port *sky2 = netdev_priv(dev);\n\tstruct sky2_hw *hw = sky2->hw;\n\tunsigned port = sky2->port;\n\tunsigned idx, last;\n\tint sop;\n\n\tseq_printf(seq, \"IRQ src=%x mask=%x control=%x\\n\",\n\t\t   sky2_read32(hw, B0_ISRC),\n\t\t   sky2_read32(hw, B0_IMSK),\n\t\t   sky2_read32(hw, B0_Y2_SP_ICR));\n\n\tif (!netif_running(dev)) {\n\t\tseq_puts(seq, \"network not running\\n\");\n\t\treturn 0;\n\t}\n\n\tnapi_disable(&hw->napi);\n\tlast = sky2_read16(hw, STAT_PUT_IDX);\n\n\tseq_printf(seq, \"Status ring %u\\n\", hw->st_size);\n\tif (hw->st_idx == last)\n\t\tseq_puts(seq, \"Status ring (empty)\\n\");\n\telse {\n\t\tseq_puts(seq, \"Status ring\\n\");\n\t\tfor (idx = hw->st_idx; idx != last && idx < hw->st_size;\n\t\t     idx = RING_NEXT(idx, hw->st_size)) {\n\t\t\tconst struct sky2_status_le *le = hw->st_le + idx;\n\t\t\tseq_printf(seq, \"[%d] %#x %d %#x\\n\",\n\t\t\t\t   idx, le->opcode, le->length, le->status);\n\t\t}\n\t\tseq_puts(seq, \"\\n\");\n\t}\n\n\tseq_printf(seq, \"Tx ring pending=%u...%u report=%d done=%d\\n\",\n\t\t   sky2->tx_cons, sky2->tx_prod,\n\t\t   sky2_read16(hw, port == 0 ? STAT_TXA1_RIDX : STAT_TXA2_RIDX),\n\t\t   sky2_read16(hw, Q_ADDR(txqaddr[port], Q_DONE)));\n\n\t \n\tsop = 1;\n\tfor (idx = sky2->tx_next; idx != sky2->tx_prod && idx < sky2->tx_ring_size;\n\t     idx = RING_NEXT(idx, sky2->tx_ring_size)) {\n\t\tconst struct sky2_tx_le *le = sky2->tx_le + idx;\n\t\tu32 a = le32_to_cpu(le->addr);\n\n\t\tif (sop)\n\t\t\tseq_printf(seq, \"%u:\", idx);\n\t\tsop = 0;\n\n\t\tswitch (le->opcode & ~HW_OWNER) {\n\t\tcase OP_ADDR64:\n\t\t\tseq_printf(seq, \" %#x:\", a);\n\t\t\tbreak;\n\t\tcase OP_LRGLEN:\n\t\t\tseq_printf(seq, \" mtu=%d\", a);\n\t\t\tbreak;\n\t\tcase OP_VLAN:\n\t\t\tseq_printf(seq, \" vlan=%d\", be16_to_cpu(le->length));\n\t\t\tbreak;\n\t\tcase OP_TCPLISW:\n\t\t\tseq_printf(seq, \" csum=%#x\", a);\n\t\t\tbreak;\n\t\tcase OP_LARGESEND:\n\t\t\tseq_printf(seq, \" tso=%#x(%d)\", a, le16_to_cpu(le->length));\n\t\t\tbreak;\n\t\tcase OP_PACKET:\n\t\t\tseq_printf(seq, \" %#x(%d)\", a, le16_to_cpu(le->length));\n\t\t\tbreak;\n\t\tcase OP_BUFFER:\n\t\t\tseq_printf(seq, \" frag=%#x(%d)\", a, le16_to_cpu(le->length));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(seq, \" op=%#x,%#x(%d)\", le->opcode,\n\t\t\t\t   a, le16_to_cpu(le->length));\n\t\t}\n\n\t\tif (le->ctrl & EOP) {\n\t\t\tseq_putc(seq, '\\n');\n\t\t\tsop = 1;\n\t\t}\n\t}\n\n\tseq_printf(seq, \"\\nRx ring hw get=%d put=%d last=%d\\n\",\n\t\t   sky2_read16(hw, Y2_QADDR(rxqaddr[port], PREF_UNIT_GET_IDX)),\n\t\t   sky2_read16(hw, Y2_QADDR(rxqaddr[port], PREF_UNIT_PUT_IDX)),\n\t\t   sky2_read16(hw, Y2_QADDR(rxqaddr[port], PREF_UNIT_LAST_IDX)));\n\n\tsky2_read32(hw, B0_Y2_SP_LISR);\n\tnapi_enable(&hw->napi);\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(sky2_debug);\n\n \nstatic int sky2_device_event(struct notifier_block *unused,\n\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\tif (dev->netdev_ops->ndo_open != sky2_open || !sky2_debug)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGENAME:\n\t\tif (sky2->debugfs) {\n\t\t\tsky2->debugfs = debugfs_rename(sky2_debug, sky2->debugfs,\n\t\t\t\t\t\t       sky2_debug, dev->name);\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_GOING_DOWN:\n\t\tif (sky2->debugfs) {\n\t\t\tnetdev_printk(KERN_DEBUG, dev, \"remove debugfs\\n\");\n\t\t\tdebugfs_remove(sky2->debugfs);\n\t\t\tsky2->debugfs = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_UP:\n\t\tsky2->debugfs = debugfs_create_file(dev->name, 0444,\n\t\t\t\t\t\t    sky2_debug, dev,\n\t\t\t\t\t\t    &sky2_debug_fops);\n\t\tif (IS_ERR(sky2->debugfs))\n\t\t\tsky2->debugfs = NULL;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block sky2_notifier = {\n\t.notifier_call = sky2_device_event,\n};\n\n\nstatic __init void sky2_debug_init(void)\n{\n\tstruct dentry *ent;\n\n\tent = debugfs_create_dir(\"sky2\", NULL);\n\tif (IS_ERR(ent))\n\t\treturn;\n\n\tsky2_debug = ent;\n\tregister_netdevice_notifier(&sky2_notifier);\n}\n\nstatic __exit void sky2_debug_cleanup(void)\n{\n\tif (sky2_debug) {\n\t\tunregister_netdevice_notifier(&sky2_notifier);\n\t\tdebugfs_remove(sky2_debug);\n\t\tsky2_debug = NULL;\n\t}\n}\n\n#else\n#define sky2_debug_init()\n#define sky2_debug_cleanup()\n#endif\n\n \nstatic const struct net_device_ops sky2_netdev_ops[2] = {\n  {\n\t.ndo_open\t\t= sky2_open,\n\t.ndo_stop\t\t= sky2_close,\n\t.ndo_start_xmit\t\t= sky2_xmit_frame,\n\t.ndo_eth_ioctl\t\t= sky2_ioctl,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= sky2_set_mac_address,\n\t.ndo_set_rx_mode\t= sky2_set_multicast,\n\t.ndo_change_mtu\t\t= sky2_change_mtu,\n\t.ndo_fix_features\t= sky2_fix_features,\n\t.ndo_set_features\t= sky2_set_features,\n\t.ndo_tx_timeout\t\t= sky2_tx_timeout,\n\t.ndo_get_stats64\t= sky2_get_stats,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= sky2_netpoll,\n#endif\n  },\n  {\n\t.ndo_open\t\t= sky2_open,\n\t.ndo_stop\t\t= sky2_close,\n\t.ndo_start_xmit\t\t= sky2_xmit_frame,\n\t.ndo_eth_ioctl\t\t= sky2_ioctl,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= sky2_set_mac_address,\n\t.ndo_set_rx_mode\t= sky2_set_multicast,\n\t.ndo_change_mtu\t\t= sky2_change_mtu,\n\t.ndo_fix_features\t= sky2_fix_features,\n\t.ndo_set_features\t= sky2_set_features,\n\t.ndo_tx_timeout\t\t= sky2_tx_timeout,\n\t.ndo_get_stats64\t= sky2_get_stats,\n  },\n};\n\n \nstatic struct net_device *sky2_init_netdev(struct sky2_hw *hw, unsigned port,\n\t\t\t\t\t   int highmem, int wol)\n{\n\tstruct sky2_port *sky2;\n\tstruct net_device *dev = alloc_etherdev(sizeof(*sky2));\n\tint ret;\n\n\tif (!dev)\n\t\treturn NULL;\n\n\tSET_NETDEV_DEV(dev, &hw->pdev->dev);\n\tdev->irq = hw->pdev->irq;\n\tdev->ethtool_ops = &sky2_ethtool_ops;\n\tdev->watchdog_timeo = TX_WATCHDOG;\n\tdev->netdev_ops = &sky2_netdev_ops[port];\n\n\tsky2 = netdev_priv(dev);\n\tsky2->netdev = dev;\n\tsky2->hw = hw;\n\tsky2->msg_enable = netif_msg_init(debug, default_msg);\n\n\tu64_stats_init(&sky2->tx_stats.syncp);\n\tu64_stats_init(&sky2->rx_stats.syncp);\n\n\t \n\tsky2->flags = SKY2_FLAG_AUTO_SPEED | SKY2_FLAG_AUTO_PAUSE;\n\tif (hw->chip_id != CHIP_ID_YUKON_XL)\n\t\tdev->hw_features |= NETIF_F_RXCSUM;\n\n\tsky2->flow_mode = FC_BOTH;\n\n\tsky2->duplex = -1;\n\tsky2->speed = -1;\n\tsky2->advertising = sky2_supported_modes(hw);\n\tsky2->wol = wol;\n\n\tspin_lock_init(&sky2->phy_lock);\n\n\tsky2->tx_pending = TX_DEF_PENDING;\n\tsky2->tx_ring_size = roundup_ring_size(TX_DEF_PENDING);\n\tsky2->rx_pending = RX_DEF_PENDING;\n\n\thw->dev[port] = dev;\n\n\tsky2->port = port;\n\n\tdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_TSO;\n\n\tif (highmem)\n\t\tdev->features |= NETIF_F_HIGHDMA;\n\n\t \n\tif (!(hw->flags & SKY2_HW_RSS_BROKEN))\n\t\tdev->hw_features |= NETIF_F_RXHASH;\n\n\tif (!(hw->flags & SKY2_HW_VLAN_BROKEN)) {\n\t\tdev->hw_features |= NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t    NETIF_F_HW_VLAN_CTAG_RX;\n\t\tdev->vlan_features |= SKY2_VLAN_OFFLOADS;\n\t}\n\n\tdev->features |= dev->hw_features;\n\n\t \n\tdev->min_mtu = ETH_ZLEN;\n\tif (hw->chip_id == CHIP_ID_YUKON_FE ||\n\t    hw->chip_id == CHIP_ID_YUKON_FE_P)\n\t\tdev->max_mtu = ETH_DATA_LEN;\n\telse\n\t\tdev->max_mtu = ETH_JUMBO_MTU;\n\n\t \n\tret = of_get_ethdev_address(hw->pdev->dev.of_node, dev);\n\tif (ret) {\n\t\tu8 addr[ETH_ALEN];\n\n\t\tmemcpy_fromio(addr, hw->regs + B2_MAC_1 + port * 8, ETH_ALEN);\n\t\teth_hw_addr_set(dev, addr);\n\t}\n\n\t \n\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\tstruct sockaddr sa = { AF_UNSPEC };\n\n\t\tdev_warn(&hw->pdev->dev, \"Invalid MAC address, defaulting to random\\n\");\n\t\teth_hw_addr_random(dev);\n\t\tmemcpy(sa.sa_data, dev->dev_addr, ETH_ALEN);\n\t\tif (sky2_set_mac_address(dev, &sa))\n\t\t\tdev_warn(&hw->pdev->dev, \"Failed to set MAC address.\\n\");\n\t}\n\n\treturn dev;\n}\n\nstatic void sky2_show_addr(struct net_device *dev)\n{\n\tconst struct sky2_port *sky2 = netdev_priv(dev);\n\n\tnetif_info(sky2, probe, dev, \"addr %pM\\n\", dev->dev_addr);\n}\n\n \nstatic irqreturn_t sky2_test_intr(int irq, void *dev_id)\n{\n\tstruct sky2_hw *hw = dev_id;\n\tu32 status = sky2_read32(hw, B0_Y2_SP_ISRC2);\n\n\tif (status == 0)\n\t\treturn IRQ_NONE;\n\n\tif (status & Y2_IS_IRQ_SW) {\n\t\thw->flags |= SKY2_HW_USE_MSI;\n\t\twake_up(&hw->msi_wait);\n\t\tsky2_write8(hw, B0_CTST, CS_CL_SW_IRQ);\n\t}\n\tsky2_write32(hw, B0_Y2_SP_ICR, 2);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int sky2_test_msi(struct sky2_hw *hw)\n{\n\tstruct pci_dev *pdev = hw->pdev;\n\tint err;\n\n\tinit_waitqueue_head(&hw->msi_wait);\n\n\terr = request_irq(pdev->irq, sky2_test_intr, 0, DRV_NAME, hw);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot assign irq %d\\n\", pdev->irq);\n\t\treturn err;\n\t}\n\n\tsky2_write32(hw, B0_IMSK, Y2_IS_IRQ_SW);\n\n\tsky2_write8(hw, B0_CTST, CS_ST_SW_IRQ);\n\tsky2_read8(hw, B0_CTST);\n\n\twait_event_timeout(hw->msi_wait, (hw->flags & SKY2_HW_USE_MSI), HZ/10);\n\n\tif (!(hw->flags & SKY2_HW_USE_MSI)) {\n\t\t \n\t\tdev_info(&pdev->dev, \"No interrupt generated using MSI, \"\n\t\t\t \"switching to INTx mode.\\n\");\n\n\t\terr = -EOPNOTSUPP;\n\t\tsky2_write8(hw, B0_CTST, CS_CL_SW_IRQ);\n\t}\n\n\tsky2_write32(hw, B0_IMSK, 0);\n\tsky2_read32(hw, B0_IMSK);\n\n\tfree_irq(pdev->irq, hw);\n\n\treturn err;\n}\n\n \nstatic const char *sky2_name(u8 chipid, char *buf, int sz)\n{\n\tstatic const char *const name[] = {\n\t\t\"XL\",\t\t \n\t\t\"EC Ultra\", \t \n\t\t\"Extreme\",\t \n\t\t\"EC\",\t\t \n\t\t\"FE\",\t\t \n\t\t\"FE+\",\t\t \n\t\t\"Supreme\",\t \n\t\t\"UL 2\",\t\t \n\t\t\"Unknown\",\t \n\t\t\"Optima\",\t \n\t\t\"OptimaEEE\",     \n\t\t\"Optima 2\",\t \n\t};\n\n\tif (chipid >= CHIP_ID_YUKON_XL && chipid <= CHIP_ID_YUKON_OP_2)\n\t\tsnprintf(buf, sz, \"%s\", name[chipid - CHIP_ID_YUKON_XL]);\n\telse\n\t\tsnprintf(buf, sz, \"(chip %#x)\", chipid);\n\treturn buf;\n}\n\nstatic const struct dmi_system_id msi_blacklist[] = {\n\t{\n\t\t.ident = \"Dell Inspiron 1545\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 1545\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Gateway P-79\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Gateway\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"P-79\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"ASUS P5W DH Deluxe\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTEK COMPUTER INC\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"P5W DH Deluxe\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"ASUS P6T\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"P6T\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"ASUS P6X\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"P6X\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic int sky2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *dev, *dev1;\n\tstruct sky2_hw *hw;\n\tint err, using_dac = 0, wol_default;\n\tu32 reg;\n\tchar buf1[16];\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot enable PCI device\\n\");\n\t\tgoto err_out;\n\t}\n\n\t \n\terr = pci_read_config_dword(pdev, PCI_DEV_REG2, &reg);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"PCI read config failed\\n\");\n\t\tgoto err_out_disable;\n\t}\n\n\tif (~reg == 0) {\n\t\tdev_err(&pdev->dev, \"PCI configuration read error\\n\");\n\t\terr = -EIO;\n\t\tgoto err_out_disable;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot obtain PCI resources\\n\");\n\t\tgoto err_out_disable;\n\t}\n\n\tpci_set_master(pdev);\n\n\tif (sizeof(dma_addr_t) > sizeof(u32) &&\n\t    !dma_set_mask(&pdev->dev, DMA_BIT_MASK(64))) {\n\t\tusing_dac = 1;\n\t\terr = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev, \"unable to obtain 64 bit DMA \"\n\t\t\t\t\"for consistent allocations\\n\");\n\t\t\tgoto err_out_free_regions;\n\t\t}\n\t} else {\n\t\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"no usable DMA configuration\\n\");\n\t\t\tgoto err_out_free_regions;\n\t\t}\n\t}\n\n\n#ifdef __BIG_ENDIAN\n\t \n\treg &= ~PCI_REV_DESC;\n\terr = pci_write_config_dword(pdev, PCI_DEV_REG2, reg);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"PCI write config failed\\n\");\n\t\tgoto err_out_free_regions;\n\t}\n#endif\n\n\twol_default = device_may_wakeup(&pdev->dev) ? WAKE_MAGIC : 0;\n\n\terr = -ENOMEM;\n\n\thw = kzalloc(sizeof(*hw) + strlen(DRV_NAME \"@pci:\")\n\t\t     + strlen(pci_name(pdev)) + 1, GFP_KERNEL);\n\tif (!hw)\n\t\tgoto err_out_free_regions;\n\n\thw->pdev = pdev;\n\tsprintf(hw->irq_name, DRV_NAME \"@pci:%s\", pci_name(pdev));\n\n\thw->regs = ioremap(pci_resource_start(pdev, 0), 0x4000);\n\tif (!hw->regs) {\n\t\tdev_err(&pdev->dev, \"cannot map device registers\\n\");\n\t\tgoto err_out_free_hw;\n\t}\n\n\terr = sky2_init(hw);\n\tif (err)\n\t\tgoto err_out_iounmap;\n\n\t \n\thw->st_size = hw->ports * roundup_pow_of_two(3*RX_MAX_PENDING + TX_MAX_PENDING);\n\thw->st_le = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t       hw->st_size * sizeof(struct sky2_status_le),\n\t\t\t\t       &hw->st_dma, GFP_KERNEL);\n\tif (!hw->st_le) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_reset;\n\t}\n\n\tdev_info(&pdev->dev, \"Yukon-2 %s chip revision %d\\n\",\n\t\t sky2_name(hw->chip_id, buf1, sizeof(buf1)), hw->chip_rev);\n\n\tsky2_reset(hw);\n\n\tdev = sky2_init_netdev(hw, 0, using_dac, wol_default);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_pci;\n\t}\n\n\tif (disable_msi == -1)\n\t\tdisable_msi = !!dmi_check_system(msi_blacklist);\n\n\tif (!disable_msi && pci_enable_msi(pdev) == 0) {\n\t\terr = sky2_test_msi(hw);\n\t\tif (err) {\n\t\t\tpci_disable_msi(pdev);\n\t\t\tif (err != -EOPNOTSUPP)\n\t\t\t\tgoto err_out_free_netdev;\n\t\t}\n\t}\n\n\tnetif_napi_add(dev, &hw->napi, sky2_poll);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot register net device\\n\");\n\t\tgoto err_out_free_netdev;\n\t}\n\n\tnetif_carrier_off(dev);\n\n\tsky2_show_addr(dev);\n\n\tif (hw->ports > 1) {\n\t\tdev1 = sky2_init_netdev(hw, 1, using_dac, wol_default);\n\t\tif (!dev1) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out_unregister;\n\t\t}\n\n\t\terr = register_netdev(dev1);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"cannot register second net device\\n\");\n\t\t\tgoto err_out_free_dev1;\n\t\t}\n\n\t\terr = sky2_setup_irq(hw, hw->irq_name);\n\t\tif (err)\n\t\t\tgoto err_out_unregister_dev1;\n\n\t\tsky2_show_addr(dev1);\n\t}\n\n\ttimer_setup(&hw->watchdog_timer, sky2_watchdog, 0);\n\tINIT_WORK(&hw->restart_work, sky2_restart);\n\n\tpci_set_drvdata(pdev, hw);\n\tpdev->d3hot_delay = 300;\n\n\treturn 0;\n\nerr_out_unregister_dev1:\n\tunregister_netdev(dev1);\nerr_out_free_dev1:\n\tfree_netdev(dev1);\nerr_out_unregister:\n\tunregister_netdev(dev);\nerr_out_free_netdev:\n\tif (hw->flags & SKY2_HW_USE_MSI)\n\t\tpci_disable_msi(pdev);\n\tfree_netdev(dev);\nerr_out_free_pci:\n\tdma_free_coherent(&pdev->dev,\n\t\t\t  hw->st_size * sizeof(struct sky2_status_le),\n\t\t\t  hw->st_le, hw->st_dma);\nerr_out_reset:\n\tsky2_write8(hw, B0_CTST, CS_RST_SET);\nerr_out_iounmap:\n\tiounmap(hw->regs);\nerr_out_free_hw:\n\tkfree(hw);\nerr_out_free_regions:\n\tpci_release_regions(pdev);\nerr_out_disable:\n\tpci_disable_device(pdev);\nerr_out:\n\treturn err;\n}\n\nstatic void sky2_remove(struct pci_dev *pdev)\n{\n\tstruct sky2_hw *hw = pci_get_drvdata(pdev);\n\tint i;\n\n\tif (!hw)\n\t\treturn;\n\n\ttimer_shutdown_sync(&hw->watchdog_timer);\n\tcancel_work_sync(&hw->restart_work);\n\n\tfor (i = hw->ports-1; i >= 0; --i)\n\t\tunregister_netdev(hw->dev[i]);\n\n\tsky2_write32(hw, B0_IMSK, 0);\n\tsky2_read32(hw, B0_IMSK);\n\n\tsky2_power_aux(hw);\n\n\tsky2_write8(hw, B0_CTST, CS_RST_SET);\n\tsky2_read8(hw, B0_CTST);\n\n\tif (hw->ports > 1) {\n\t\tnapi_disable(&hw->napi);\n\t\tfree_irq(pdev->irq, hw);\n\t}\n\n\tif (hw->flags & SKY2_HW_USE_MSI)\n\t\tpci_disable_msi(pdev);\n\tdma_free_coherent(&pdev->dev,\n\t\t\t  hw->st_size * sizeof(struct sky2_status_le),\n\t\t\t  hw->st_le, hw->st_dma);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\n\tfor (i = hw->ports-1; i >= 0; --i)\n\t\tfree_netdev(hw->dev[i]);\n\n\tiounmap(hw->regs);\n\tkfree(hw);\n}\n\nstatic int sky2_suspend(struct device *dev)\n{\n\tstruct sky2_hw *hw = dev_get_drvdata(dev);\n\tint i;\n\n\tif (!hw)\n\t\treturn 0;\n\n\tdel_timer_sync(&hw->watchdog_timer);\n\tcancel_work_sync(&hw->restart_work);\n\n\trtnl_lock();\n\n\tsky2_all_down(hw);\n\tfor (i = 0; i < hw->ports; i++) {\n\t\tstruct net_device *dev = hw->dev[i];\n\t\tstruct sky2_port *sky2 = netdev_priv(dev);\n\n\t\tif (sky2->wol)\n\t\t\tsky2_wol_init(sky2);\n\t}\n\n\tsky2_power_aux(hw);\n\trtnl_unlock();\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sky2_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct sky2_hw *hw = pci_get_drvdata(pdev);\n\tint err;\n\n\tif (!hw)\n\t\treturn 0;\n\n\t \n\terr = pci_write_config_dword(pdev, PCI_DEV_REG3, 0);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"PCI write config failed\\n\");\n\t\tgoto out;\n\t}\n\n\trtnl_lock();\n\tsky2_reset(hw);\n\tsky2_all_up(hw);\n\trtnl_unlock();\n\n\treturn 0;\nout:\n\n\tdev_err(&pdev->dev, \"resume failed (%d)\\n\", err);\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\nstatic SIMPLE_DEV_PM_OPS(sky2_pm_ops, sky2_suspend, sky2_resume);\n#define SKY2_PM_OPS (&sky2_pm_ops)\n\n#else\n\n#define SKY2_PM_OPS NULL\n#endif\n\nstatic void sky2_shutdown(struct pci_dev *pdev)\n{\n\tstruct sky2_hw *hw = pci_get_drvdata(pdev);\n\tint port;\n\n\tfor (port = 0; port < hw->ports; port++) {\n\t\tstruct net_device *ndev = hw->dev[port];\n\n\t\trtnl_lock();\n\t\tif (netif_running(ndev)) {\n\t\t\tdev_close(ndev);\n\t\t\tnetif_device_detach(ndev);\n\t\t}\n\t\trtnl_unlock();\n\t}\n\tsky2_suspend(&pdev->dev);\n\tpci_wake_from_d3(pdev, device_may_wakeup(&pdev->dev));\n\tpci_set_power_state(pdev, PCI_D3hot);\n}\n\nstatic struct pci_driver sky2_driver = {\n\t.name = DRV_NAME,\n\t.id_table = sky2_id_table,\n\t.probe = sky2_probe,\n\t.remove = sky2_remove,\n\t.shutdown = sky2_shutdown,\n\t.driver.pm = SKY2_PM_OPS,\n};\n\nstatic int __init sky2_init_module(void)\n{\n\tpr_info(\"driver version \" DRV_VERSION \"\\n\");\n\n\tsky2_debug_init();\n\treturn pci_register_driver(&sky2_driver);\n}\n\nstatic void __exit sky2_cleanup_module(void)\n{\n\tpci_unregister_driver(&sky2_driver);\n\tsky2_debug_cleanup();\n}\n\nmodule_init(sky2_init_module);\nmodule_exit(sky2_cleanup_module);\n\nMODULE_DESCRIPTION(\"Marvell Yukon 2 Gigabit Ethernet driver\");\nMODULE_AUTHOR(\"Stephen Hemminger <shemminger@linux-foundation.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}