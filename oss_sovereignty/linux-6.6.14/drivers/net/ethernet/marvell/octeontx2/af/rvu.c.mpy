{
  "module_name": "rvu.c",
  "hash_id": "874ec8559b66fb267dddcf562669de7ea6e4e772b8ec93e5aaa16e5d87725b95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/af/rvu.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/pci.h>\n#include <linux/sysfs.h>\n\n#include \"cgx.h\"\n#include \"rvu.h\"\n#include \"rvu_reg.h\"\n#include \"ptp.h\"\n#include \"mcs.h\"\n\n#include \"rvu_trace.h\"\n#include \"rvu_npc_hash.h\"\n\n#define DRV_NAME\t\"rvu_af\"\n#define DRV_STRING      \"Marvell OcteonTX2 RVU Admin Function Driver\"\n\nstatic void rvu_set_msix_offset(struct rvu *rvu, struct rvu_pfvf *pfvf,\n\t\t\t\tstruct rvu_block *block, int lf);\nstatic void rvu_clear_msix_offset(struct rvu *rvu, struct rvu_pfvf *pfvf,\n\t\t\t\t  struct rvu_block *block, int lf);\nstatic void __rvu_flr_handler(struct rvu *rvu, u16 pcifunc);\n\nstatic int rvu_mbox_init(struct rvu *rvu, struct mbox_wq_info *mw,\n\t\t\t int type, int num,\n\t\t\t void (mbox_handler)(struct work_struct *),\n\t\t\t void (mbox_up_handler)(struct work_struct *));\nenum {\n\tTYPE_AFVF,\n\tTYPE_AFPF,\n};\n\n \nstatic const struct pci_device_id rvu_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_OCTEONTX2_RVU_AF) },\n\t{ 0, }   \n};\n\nMODULE_AUTHOR(\"Sunil Goutham <sgoutham@marvell.com>\");\nMODULE_DESCRIPTION(DRV_STRING);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(pci, rvu_id_table);\n\nstatic char *mkex_profile;  \nmodule_param(mkex_profile, charp, 0000);\nMODULE_PARM_DESC(mkex_profile, \"MKEX profile name string\");\n\nstatic char *kpu_profile;  \nmodule_param(kpu_profile, charp, 0000);\nMODULE_PARM_DESC(kpu_profile, \"KPU profile name string\");\n\nstatic void rvu_setup_hw_capabilities(struct rvu *rvu)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\n\thw->cap.nix_tx_aggr_lvl = NIX_TXSCH_LVL_TL1;\n\thw->cap.nix_fixed_txschq_mapping = false;\n\thw->cap.nix_shaping = true;\n\thw->cap.nix_tx_link_bp = true;\n\thw->cap.nix_rx_multicast = true;\n\thw->cap.nix_shaper_toggle_wait = false;\n\thw->cap.npc_hash_extract = false;\n\thw->cap.npc_exact_match_enabled = false;\n\thw->rvu = rvu;\n\n\tif (is_rvu_pre_96xx_C0(rvu)) {\n\t\thw->cap.nix_fixed_txschq_mapping = true;\n\t\thw->cap.nix_txsch_per_cgx_lmac = 4;\n\t\thw->cap.nix_txsch_per_lbk_lmac = 132;\n\t\thw->cap.nix_txsch_per_sdp_lmac = 76;\n\t\thw->cap.nix_shaping = false;\n\t\thw->cap.nix_tx_link_bp = false;\n\t\tif (is_rvu_96xx_A0(rvu) || is_rvu_95xx_A0(rvu))\n\t\t\thw->cap.nix_rx_multicast = false;\n\t}\n\tif (!is_rvu_pre_96xx_C0(rvu))\n\t\thw->cap.nix_shaper_toggle_wait = true;\n\n\tif (!is_rvu_otx2(rvu))\n\t\thw->cap.per_pf_mbox_regs = true;\n\n\tif (is_rvu_npc_hash_extract_en(rvu))\n\t\thw->cap.npc_hash_extract = true;\n}\n\n \nint rvu_poll_reg(struct rvu *rvu, u64 block, u64 offset, u64 mask, bool zero)\n{\n\tunsigned long timeout = jiffies + usecs_to_jiffies(20000);\n\tbool twice = false;\n\tvoid __iomem *reg;\n\tu64 reg_val;\n\n\treg = rvu->afreg_base + ((block << 28) | offset);\nagain:\n\treg_val = readq(reg);\n\tif (zero && !(reg_val & mask))\n\t\treturn 0;\n\tif (!zero && (reg_val & mask))\n\t\treturn 0;\n\tif (time_before(jiffies, timeout)) {\n\t\tusleep_range(1, 5);\n\t\tgoto again;\n\t}\n\t \n\tif (!twice) {\n\t\ttwice = true;\n\t\tgoto again;\n\t}\n\treturn -EBUSY;\n}\n\nint rvu_alloc_rsrc(struct rsrc_bmap *rsrc)\n{\n\tint id;\n\n\tif (!rsrc->bmap)\n\t\treturn -EINVAL;\n\n\tid = find_first_zero_bit(rsrc->bmap, rsrc->max);\n\tif (id >= rsrc->max)\n\t\treturn -ENOSPC;\n\n\t__set_bit(id, rsrc->bmap);\n\n\treturn id;\n}\n\nint rvu_alloc_rsrc_contig(struct rsrc_bmap *rsrc, int nrsrc)\n{\n\tint start;\n\n\tif (!rsrc->bmap)\n\t\treturn -EINVAL;\n\n\tstart = bitmap_find_next_zero_area(rsrc->bmap, rsrc->max, 0, nrsrc, 0);\n\tif (start >= rsrc->max)\n\t\treturn -ENOSPC;\n\n\tbitmap_set(rsrc->bmap, start, nrsrc);\n\treturn start;\n}\n\nstatic void rvu_free_rsrc_contig(struct rsrc_bmap *rsrc, int nrsrc, int start)\n{\n\tif (!rsrc->bmap)\n\t\treturn;\n\tif (start >= rsrc->max)\n\t\treturn;\n\n\tbitmap_clear(rsrc->bmap, start, nrsrc);\n}\n\nbool rvu_rsrc_check_contig(struct rsrc_bmap *rsrc, int nrsrc)\n{\n\tint start;\n\n\tif (!rsrc->bmap)\n\t\treturn false;\n\n\tstart = bitmap_find_next_zero_area(rsrc->bmap, rsrc->max, 0, nrsrc, 0);\n\tif (start >= rsrc->max)\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid rvu_free_rsrc(struct rsrc_bmap *rsrc, int id)\n{\n\tif (!rsrc->bmap)\n\t\treturn;\n\n\t__clear_bit(id, rsrc->bmap);\n}\n\nint rvu_rsrc_free_count(struct rsrc_bmap *rsrc)\n{\n\tint used;\n\n\tif (!rsrc->bmap)\n\t\treturn 0;\n\n\tused = bitmap_weight(rsrc->bmap, rsrc->max);\n\treturn (rsrc->max - used);\n}\n\nbool is_rsrc_free(struct rsrc_bmap *rsrc, int id)\n{\n\tif (!rsrc->bmap)\n\t\treturn false;\n\n\treturn !test_bit(id, rsrc->bmap);\n}\n\nint rvu_alloc_bitmap(struct rsrc_bmap *rsrc)\n{\n\trsrc->bmap = kcalloc(BITS_TO_LONGS(rsrc->max),\n\t\t\t     sizeof(long), GFP_KERNEL);\n\tif (!rsrc->bmap)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid rvu_free_bitmap(struct rsrc_bmap *rsrc)\n{\n\tkfree(rsrc->bmap);\n}\n\n \nint rvu_get_lf(struct rvu *rvu, struct rvu_block *block, u16 pcifunc, u16 slot)\n{\n\tu16 match = 0;\n\tint lf;\n\n\tmutex_lock(&rvu->rsrc_lock);\n\tfor (lf = 0; lf < block->lf.max; lf++) {\n\t\tif (block->fn_map[lf] == pcifunc) {\n\t\t\tif (slot == match) {\n\t\t\t\tmutex_unlock(&rvu->rsrc_lock);\n\t\t\t\treturn lf;\n\t\t\t}\n\t\t\tmatch++;\n\t\t}\n\t}\n\tmutex_unlock(&rvu->rsrc_lock);\n\treturn -ENODEV;\n}\n\n \nint rvu_get_blkaddr(struct rvu *rvu, int blktype, u16 pcifunc)\n{\n\tint devnum, blkaddr = -ENODEV;\n\tu64 cfg, reg;\n\tbool is_pf;\n\n\tswitch (blktype) {\n\tcase BLKTYPE_NPC:\n\t\tblkaddr = BLKADDR_NPC;\n\t\tgoto exit;\n\tcase BLKTYPE_NPA:\n\t\tblkaddr = BLKADDR_NPA;\n\t\tgoto exit;\n\tcase BLKTYPE_NIX:\n\t\t \n\t\tif (!pcifunc) {\n\t\t\tblkaddr = BLKADDR_NIX0;\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\tcase BLKTYPE_SSO:\n\t\tblkaddr = BLKADDR_SSO;\n\t\tgoto exit;\n\tcase BLKTYPE_SSOW:\n\t\tblkaddr = BLKADDR_SSOW;\n\t\tgoto exit;\n\tcase BLKTYPE_TIM:\n\t\tblkaddr = BLKADDR_TIM;\n\t\tgoto exit;\n\tcase BLKTYPE_CPT:\n\t\t \n\t\tif (!pcifunc) {\n\t\t\tblkaddr = BLKADDR_CPT0;\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tif (pcifunc & RVU_PFVF_FUNC_MASK) {\n\t\tis_pf = false;\n\t\tdevnum = rvu_get_hwvf(rvu, pcifunc);\n\t} else {\n\t\tis_pf = true;\n\t\tdevnum = rvu_get_pf(pcifunc);\n\t}\n\n\t \n\tif (blktype == BLKTYPE_NIX) {\n\t\treg = is_pf ? RVU_PRIV_PFX_NIXX_CFG(0) :\n\t\t\tRVU_PRIV_HWVFX_NIXX_CFG(0);\n\t\tcfg = rvu_read64(rvu, BLKADDR_RVUM, reg | (devnum << 16));\n\t\tif (cfg) {\n\t\t\tblkaddr = BLKADDR_NIX0;\n\t\t\tgoto exit;\n\t\t}\n\n\t\treg = is_pf ? RVU_PRIV_PFX_NIXX_CFG(1) :\n\t\t\tRVU_PRIV_HWVFX_NIXX_CFG(1);\n\t\tcfg = rvu_read64(rvu, BLKADDR_RVUM, reg | (devnum << 16));\n\t\tif (cfg)\n\t\t\tblkaddr = BLKADDR_NIX1;\n\t}\n\n\tif (blktype == BLKTYPE_CPT) {\n\t\treg = is_pf ? RVU_PRIV_PFX_CPTX_CFG(0) :\n\t\t\tRVU_PRIV_HWVFX_CPTX_CFG(0);\n\t\tcfg = rvu_read64(rvu, BLKADDR_RVUM, reg | (devnum << 16));\n\t\tif (cfg) {\n\t\t\tblkaddr = BLKADDR_CPT0;\n\t\t\tgoto exit;\n\t\t}\n\n\t\treg = is_pf ? RVU_PRIV_PFX_CPTX_CFG(1) :\n\t\t\tRVU_PRIV_HWVFX_CPTX_CFG(1);\n\t\tcfg = rvu_read64(rvu, BLKADDR_RVUM, reg | (devnum << 16));\n\t\tif (cfg)\n\t\t\tblkaddr = BLKADDR_CPT1;\n\t}\n\nexit:\n\tif (is_block_implemented(rvu->hw, blkaddr))\n\t\treturn blkaddr;\n\treturn -ENODEV;\n}\n\nstatic void rvu_update_rsrc_map(struct rvu *rvu, struct rvu_pfvf *pfvf,\n\t\t\t\tstruct rvu_block *block, u16 pcifunc,\n\t\t\t\tu16 lf, bool attach)\n{\n\tint devnum, num_lfs = 0;\n\tbool is_pf;\n\tu64 reg;\n\n\tif (lf >= block->lf.max) {\n\t\tdev_err(&rvu->pdev->dev,\n\t\t\t\"%s: FATAL: LF %d is >= %s's max lfs i.e %d\\n\",\n\t\t\t__func__, lf, block->name, block->lf.max);\n\t\treturn;\n\t}\n\n\t \n\tif (pcifunc & RVU_PFVF_FUNC_MASK) {\n\t\tis_pf = false;\n\t\tdevnum = rvu_get_hwvf(rvu, pcifunc);\n\t} else {\n\t\tis_pf = true;\n\t\tdevnum = rvu_get_pf(pcifunc);\n\t}\n\n\tblock->fn_map[lf] = attach ? pcifunc : 0;\n\n\tswitch (block->addr) {\n\tcase BLKADDR_NPA:\n\t\tpfvf->npalf = attach ? true : false;\n\t\tnum_lfs = pfvf->npalf;\n\t\tbreak;\n\tcase BLKADDR_NIX0:\n\tcase BLKADDR_NIX1:\n\t\tpfvf->nixlf = attach ? true : false;\n\t\tnum_lfs = pfvf->nixlf;\n\t\tbreak;\n\tcase BLKADDR_SSO:\n\t\tattach ? pfvf->sso++ : pfvf->sso--;\n\t\tnum_lfs = pfvf->sso;\n\t\tbreak;\n\tcase BLKADDR_SSOW:\n\t\tattach ? pfvf->ssow++ : pfvf->ssow--;\n\t\tnum_lfs = pfvf->ssow;\n\t\tbreak;\n\tcase BLKADDR_TIM:\n\t\tattach ? pfvf->timlfs++ : pfvf->timlfs--;\n\t\tnum_lfs = pfvf->timlfs;\n\t\tbreak;\n\tcase BLKADDR_CPT0:\n\t\tattach ? pfvf->cptlfs++ : pfvf->cptlfs--;\n\t\tnum_lfs = pfvf->cptlfs;\n\t\tbreak;\n\tcase BLKADDR_CPT1:\n\t\tattach ? pfvf->cpt1_lfs++ : pfvf->cpt1_lfs--;\n\t\tnum_lfs = pfvf->cpt1_lfs;\n\t\tbreak;\n\t}\n\n\treg = is_pf ? block->pf_lfcnt_reg : block->vf_lfcnt_reg;\n\trvu_write64(rvu, BLKADDR_RVUM, reg | (devnum << 16), num_lfs);\n}\n\ninline int rvu_get_pf(u16 pcifunc)\n{\n\treturn (pcifunc >> RVU_PFVF_PF_SHIFT) & RVU_PFVF_PF_MASK;\n}\n\nvoid rvu_get_pf_numvfs(struct rvu *rvu, int pf, int *numvfs, int *hwvf)\n{\n\tu64 cfg;\n\n\t \n\tcfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_PFX_CFG(pf));\n\tif (numvfs)\n\t\t*numvfs = (cfg >> 12) & 0xFF;\n\tif (hwvf)\n\t\t*hwvf = cfg & 0xFFF;\n}\n\nint rvu_get_hwvf(struct rvu *rvu, int pcifunc)\n{\n\tint pf, func;\n\tu64 cfg;\n\n\tpf = rvu_get_pf(pcifunc);\n\tfunc = pcifunc & RVU_PFVF_FUNC_MASK;\n\n\t \n\tcfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_PFX_CFG(pf));\n\n\treturn ((cfg & 0xFFF) + func - 1);\n}\n\nstruct rvu_pfvf *rvu_get_pfvf(struct rvu *rvu, int pcifunc)\n{\n\t \n\tif (pcifunc & RVU_PFVF_FUNC_MASK)\n\t\treturn &rvu->hwvf[rvu_get_hwvf(rvu, pcifunc)];\n\telse\n\t\treturn &rvu->pf[rvu_get_pf(pcifunc)];\n}\n\nstatic bool is_pf_func_valid(struct rvu *rvu, u16 pcifunc)\n{\n\tint pf, vf, nvfs;\n\tu64 cfg;\n\n\tpf = rvu_get_pf(pcifunc);\n\tif (pf >= rvu->hw->total_pfs)\n\t\treturn false;\n\n\tif (!(pcifunc & RVU_PFVF_FUNC_MASK))\n\t\treturn true;\n\n\t \n\tvf = (pcifunc & RVU_PFVF_FUNC_MASK) - 1;\n\tcfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_PFX_CFG(pf));\n\tnvfs = (cfg >> 12) & 0xFF;\n\tif (vf >= nvfs)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool is_block_implemented(struct rvu_hwinfo *hw, int blkaddr)\n{\n\tstruct rvu_block *block;\n\n\tif (blkaddr < BLKADDR_RVUM || blkaddr >= BLK_COUNT)\n\t\treturn false;\n\n\tblock = &hw->block[blkaddr];\n\treturn block->implemented;\n}\n\nstatic void rvu_check_block_implemented(struct rvu *rvu)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tstruct rvu_block *block;\n\tint blkid;\n\tu64 cfg;\n\n\t \n\tfor (blkid = 0; blkid < BLK_COUNT; blkid++) {\n\t\tblock = &hw->block[blkid];\n\t\tcfg = rvupf_read64(rvu, RVU_PF_BLOCK_ADDRX_DISC(blkid));\n\t\tif (cfg & BIT_ULL(11))\n\t\t\tblock->implemented = true;\n\t}\n}\n\nstatic void rvu_setup_rvum_blk_revid(struct rvu *rvu)\n{\n\trvu_write64(rvu, BLKADDR_RVUM,\n\t\t    RVU_PRIV_BLOCK_TYPEX_REV(BLKTYPE_RVUM),\n\t\t    RVU_BLK_RVUM_REVID);\n}\n\nstatic void rvu_clear_rvum_blk_revid(struct rvu *rvu)\n{\n\trvu_write64(rvu, BLKADDR_RVUM,\n\t\t    RVU_PRIV_BLOCK_TYPEX_REV(BLKTYPE_RVUM), 0x00);\n}\n\nint rvu_lf_reset(struct rvu *rvu, struct rvu_block *block, int lf)\n{\n\tint err;\n\n\tif (!block->implemented)\n\t\treturn 0;\n\n\trvu_write64(rvu, block->addr, block->lfreset_reg, lf | BIT_ULL(12));\n\terr = rvu_poll_reg(rvu, block->addr, block->lfreset_reg, BIT_ULL(12),\n\t\t\t   true);\n\treturn err;\n}\n\nstatic void rvu_block_reset(struct rvu *rvu, int blkaddr, u64 rst_reg)\n{\n\tstruct rvu_block *block = &rvu->hw->block[blkaddr];\n\tint err;\n\n\tif (!block->implemented)\n\t\treturn;\n\n\trvu_write64(rvu, blkaddr, rst_reg, BIT_ULL(0));\n\terr = rvu_poll_reg(rvu, blkaddr, rst_reg, BIT_ULL(63), true);\n\tif (err) {\n\t\tdev_err(rvu->dev, \"HW block:%d reset timeout retrying again\\n\", blkaddr);\n\t\twhile (rvu_poll_reg(rvu, blkaddr, rst_reg, BIT_ULL(63), true) == -EBUSY)\n\t\t\t;\n\t}\n}\n\nstatic void rvu_reset_all_blocks(struct rvu *rvu)\n{\n\t \n\trvu_block_reset(rvu, BLKADDR_NPA, NPA_AF_BLK_RST);\n\trvu_block_reset(rvu, BLKADDR_NIX0, NIX_AF_BLK_RST);\n\trvu_block_reset(rvu, BLKADDR_NIX1, NIX_AF_BLK_RST);\n\trvu_block_reset(rvu, BLKADDR_NPC, NPC_AF_BLK_RST);\n\trvu_block_reset(rvu, BLKADDR_SSO, SSO_AF_BLK_RST);\n\trvu_block_reset(rvu, BLKADDR_TIM, TIM_AF_BLK_RST);\n\trvu_block_reset(rvu, BLKADDR_CPT0, CPT_AF_BLK_RST);\n\trvu_block_reset(rvu, BLKADDR_CPT1, CPT_AF_BLK_RST);\n\trvu_block_reset(rvu, BLKADDR_NDC_NIX0_RX, NDC_AF_BLK_RST);\n\trvu_block_reset(rvu, BLKADDR_NDC_NIX0_TX, NDC_AF_BLK_RST);\n\trvu_block_reset(rvu, BLKADDR_NDC_NIX1_RX, NDC_AF_BLK_RST);\n\trvu_block_reset(rvu, BLKADDR_NDC_NIX1_TX, NDC_AF_BLK_RST);\n\trvu_block_reset(rvu, BLKADDR_NDC_NPA0, NDC_AF_BLK_RST);\n}\n\nstatic void rvu_scan_block(struct rvu *rvu, struct rvu_block *block)\n{\n\tstruct rvu_pfvf *pfvf;\n\tu64 cfg;\n\tint lf;\n\n\tfor (lf = 0; lf < block->lf.max; lf++) {\n\t\tcfg = rvu_read64(rvu, block->addr,\n\t\t\t\t block->lfcfg_reg | (lf << block->lfshift));\n\t\tif (!(cfg & BIT_ULL(63)))\n\t\t\tcontinue;\n\n\t\t \n\t\t__set_bit(lf, block->lf.bmap);\n\n\t\t \n\t\tpfvf = rvu_get_pfvf(rvu, (cfg >> 8) & 0xFFFF);\n\t\trvu_update_rsrc_map(rvu, pfvf, block,\n\t\t\t\t    (cfg >> 8) & 0xFFFF, lf, true);\n\n\t\t \n\t\trvu_set_msix_offset(rvu, pfvf, block, lf);\n\t}\n}\n\nstatic void rvu_check_min_msix_vec(struct rvu *rvu, int nvecs, int pf, int vf)\n{\n\tint min_vecs;\n\n\tif (!vf)\n\t\tgoto check_pf;\n\n\tif (!nvecs) {\n\t\tdev_warn(rvu->dev,\n\t\t\t \"PF%d:VF%d is configured with zero msix vectors, %d\\n\",\n\t\t\t pf, vf - 1, nvecs);\n\t}\n\treturn;\n\ncheck_pf:\n\tif (pf == 0)\n\t\tmin_vecs = RVU_AF_INT_VEC_CNT + RVU_PF_INT_VEC_CNT;\n\telse\n\t\tmin_vecs = RVU_PF_INT_VEC_CNT;\n\n\tif (!(nvecs < min_vecs))\n\t\treturn;\n\tdev_warn(rvu->dev,\n\t\t \"PF%d is configured with too few vectors, %d, min is %d\\n\",\n\t\t pf, nvecs, min_vecs);\n}\n\nstatic int rvu_setup_msix_resources(struct rvu *rvu)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tint pf, vf, numvfs, hwvf, err;\n\tint nvecs, offset, max_msix;\n\tstruct rvu_pfvf *pfvf;\n\tu64 cfg, phy_addr;\n\tdma_addr_t iova;\n\n\tfor (pf = 0; pf < hw->total_pfs; pf++) {\n\t\tcfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_PFX_CFG(pf));\n\t\t \n\t\tif (!((cfg >> 20) & 0x01))\n\t\t\tcontinue;\n\n\t\trvu_get_pf_numvfs(rvu, pf, &numvfs, &hwvf);\n\n\t\tpfvf = &rvu->pf[pf];\n\t\t \n\t\tcfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_PFX_MSIX_CFG(pf));\n\t\tpfvf->msix.max = ((cfg >> 32) & 0xFFF) + 1;\n\t\trvu_check_min_msix_vec(rvu, pfvf->msix.max, pf, 0);\n\n\t\t \n\t\terr = rvu_alloc_bitmap(&pfvf->msix);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tpfvf->msix_lfmap = devm_kcalloc(rvu->dev, pfvf->msix.max,\n\t\t\t\t\t\tsizeof(u16), GFP_KERNEL);\n\t\tif (!pfvf->msix_lfmap)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tif (!pf)\n\t\t\tgoto setup_vfmsix;\n\n\t\t \n\t\tcfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_PFX_INT_CFG(pf));\n\t\tnvecs = (cfg >> 12) & 0xFF;\n\t\tcfg &= ~0x7FFULL;\n\t\toffset = rvu_alloc_rsrc_contig(&pfvf->msix, nvecs);\n\t\trvu_write64(rvu, BLKADDR_RVUM,\n\t\t\t    RVU_PRIV_PFX_INT_CFG(pf), cfg | offset);\nsetup_vfmsix:\n\t\t \n\t\tfor (vf = 0; vf < numvfs; vf++) {\n\t\t\tpfvf =  &rvu->hwvf[hwvf + vf];\n\t\t\t \n\t\t\tcfg = rvu_read64(rvu, BLKADDR_RVUM,\n\t\t\t\t\t RVU_PRIV_PFX_MSIX_CFG(pf));\n\t\t\tpfvf->msix.max = (cfg & 0xFFF) + 1;\n\t\t\trvu_check_min_msix_vec(rvu, pfvf->msix.max, pf, vf + 1);\n\n\t\t\t \n\t\t\terr = rvu_alloc_bitmap(&pfvf->msix);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tpfvf->msix_lfmap =\n\t\t\t\tdevm_kcalloc(rvu->dev, pfvf->msix.max,\n\t\t\t\t\t     sizeof(u16), GFP_KERNEL);\n\t\t\tif (!pfvf->msix_lfmap)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t \n\t\t\tcfg = rvu_read64(rvu, BLKADDR_RVUM,\n\t\t\t\t\t RVU_PRIV_HWVFX_INT_CFG(hwvf + vf));\n\t\t\tnvecs = (cfg >> 12) & 0xFF;\n\t\t\tcfg &= ~0x7FFULL;\n\t\t\toffset = rvu_alloc_rsrc_contig(&pfvf->msix, nvecs);\n\t\t\trvu_write64(rvu, BLKADDR_RVUM,\n\t\t\t\t    RVU_PRIV_HWVFX_INT_CFG(hwvf + vf),\n\t\t\t\t    cfg | offset);\n\t\t}\n\t}\n\n\t \n\tcfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_CONST);\n\tmax_msix = cfg & 0xFFFFF;\n\tif (rvu->fwdata && rvu->fwdata->msixtr_base)\n\t\tphy_addr = rvu->fwdata->msixtr_base;\n\telse\n\t\tphy_addr = rvu_read64(rvu, BLKADDR_RVUM, RVU_AF_MSIXTR_BASE);\n\n\tiova = dma_map_resource(rvu->dev, phy_addr,\n\t\t\t\tmax_msix * PCI_MSIX_ENTRY_SIZE,\n\t\t\t\tDMA_BIDIRECTIONAL, 0);\n\n\tif (dma_mapping_error(rvu->dev, iova))\n\t\treturn -ENOMEM;\n\n\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_MSIXTR_BASE, (u64)iova);\n\trvu->msix_base_iova = iova;\n\trvu->msixtr_base_phy = phy_addr;\n\n\treturn 0;\n}\n\nstatic void rvu_reset_msix(struct rvu *rvu)\n{\n\t \n\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_MSIXTR_BASE,\n\t\t    rvu->msixtr_base_phy);\n}\n\nstatic void rvu_free_hw_resources(struct rvu *rvu)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tstruct rvu_block *block;\n\tstruct rvu_pfvf  *pfvf;\n\tint id, max_msix;\n\tu64 cfg;\n\n\trvu_npa_freemem(rvu);\n\trvu_npc_freemem(rvu);\n\trvu_nix_freemem(rvu);\n\n\t \n\tfor (id = 0; id < BLK_COUNT; id++) {\n\t\tblock = &hw->block[id];\n\t\tkfree(block->lf.bmap);\n\t}\n\n\t \n\tfor (id = 0; id < hw->total_pfs; id++) {\n\t\tpfvf = &rvu->pf[id];\n\t\tkfree(pfvf->msix.bmap);\n\t}\n\n\tfor (id = 0; id < hw->total_vfs; id++) {\n\t\tpfvf = &rvu->hwvf[id];\n\t\tkfree(pfvf->msix.bmap);\n\t}\n\n\t \n\tif (!rvu->msix_base_iova)\n\t\treturn;\n\tcfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_CONST);\n\tmax_msix = cfg & 0xFFFFF;\n\tdma_unmap_resource(rvu->dev, rvu->msix_base_iova,\n\t\t\t   max_msix * PCI_MSIX_ENTRY_SIZE,\n\t\t\t   DMA_BIDIRECTIONAL, 0);\n\n\trvu_reset_msix(rvu);\n\tmutex_destroy(&rvu->rsrc_lock);\n}\n\nstatic void rvu_setup_pfvf_macaddress(struct rvu *rvu)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tint pf, vf, numvfs, hwvf;\n\tstruct rvu_pfvf *pfvf;\n\tu64 *mac;\n\n\tfor (pf = 0; pf < hw->total_pfs; pf++) {\n\t\t \n\t\tif (!pf)\n\t\t\tgoto lbkvf;\n\n\t\tif (!is_pf_cgxmapped(rvu, pf))\n\t\t\tcontinue;\n\t\t \n\t\tpfvf = &rvu->pf[pf];\n\t\tif (rvu->fwdata && pf < PF_MACNUM_MAX) {\n\t\t\tmac = &rvu->fwdata->pf_macs[pf];\n\t\t\tif (*mac)\n\t\t\t\tu64_to_ether_addr(*mac, pfvf->mac_addr);\n\t\t\telse\n\t\t\t\teth_random_addr(pfvf->mac_addr);\n\t\t} else {\n\t\t\teth_random_addr(pfvf->mac_addr);\n\t\t}\n\t\tether_addr_copy(pfvf->default_mac, pfvf->mac_addr);\n\nlbkvf:\n\t\t \n\t\trvu_get_pf_numvfs(rvu, pf, &numvfs, &hwvf);\n\t\tfor (vf = 0; vf < numvfs; vf++, hwvf++) {\n\t\t\tpfvf = &rvu->hwvf[hwvf];\n\t\t\tif (rvu->fwdata && hwvf < VF_MACNUM_MAX) {\n\t\t\t\tmac = &rvu->fwdata->vf_macs[hwvf];\n\t\t\t\tif (*mac)\n\t\t\t\t\tu64_to_ether_addr(*mac, pfvf->mac_addr);\n\t\t\t\telse\n\t\t\t\t\teth_random_addr(pfvf->mac_addr);\n\t\t\t} else {\n\t\t\t\teth_random_addr(pfvf->mac_addr);\n\t\t\t}\n\t\t\tether_addr_copy(pfvf->default_mac, pfvf->mac_addr);\n\t\t}\n\t}\n}\n\nstatic int rvu_fwdata_init(struct rvu *rvu)\n{\n\tu64 fwdbase;\n\tint err;\n\n\t \n\terr = cgx_get_fwdata_base(&fwdbase);\n\tif (err)\n\t\tgoto fail;\n\trvu->fwdata = ioremap_wc(fwdbase, sizeof(struct rvu_fwdata));\n\tif (!rvu->fwdata)\n\t\tgoto fail;\n\tif (!is_rvu_fwdata_valid(rvu)) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"Mismatch in 'fwdata' struct btw kernel and firmware\\n\");\n\t\tiounmap(rvu->fwdata);\n\t\trvu->fwdata = NULL;\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\nfail:\n\tdev_info(rvu->dev, \"Unable to fetch 'fwdata' from firmware\\n\");\n\treturn -EIO;\n}\n\nstatic void rvu_fwdata_exit(struct rvu *rvu)\n{\n\tif (rvu->fwdata)\n\t\tiounmap(rvu->fwdata);\n}\n\nstatic int rvu_setup_nix_hw_resource(struct rvu *rvu, int blkaddr)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tstruct rvu_block *block;\n\tint blkid;\n\tu64 cfg;\n\n\t \n\tblock = &hw->block[blkaddr];\n\tif (!block->implemented)\n\t\treturn 0;\n\tblkid = (blkaddr == BLKADDR_NIX0) ? 0 : 1;\n\tcfg = rvu_read64(rvu, blkaddr, NIX_AF_CONST2);\n\tblock->lf.max = cfg & 0xFFF;\n\tblock->addr = blkaddr;\n\tblock->type = BLKTYPE_NIX;\n\tblock->lfshift = 8;\n\tblock->lookup_reg = NIX_AF_RVU_LF_CFG_DEBUG;\n\tblock->pf_lfcnt_reg = RVU_PRIV_PFX_NIXX_CFG(blkid);\n\tblock->vf_lfcnt_reg = RVU_PRIV_HWVFX_NIXX_CFG(blkid);\n\tblock->lfcfg_reg = NIX_PRIV_LFX_CFG;\n\tblock->msixcfg_reg = NIX_PRIV_LFX_INT_CFG;\n\tblock->lfreset_reg = NIX_AF_LF_RST;\n\tblock->rvu = rvu;\n\tsprintf(block->name, \"NIX%d\", blkid);\n\trvu->nix_blkaddr[blkid] = blkaddr;\n\treturn rvu_alloc_bitmap(&block->lf);\n}\n\nstatic int rvu_setup_cpt_hw_resource(struct rvu *rvu, int blkaddr)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tstruct rvu_block *block;\n\tint blkid;\n\tu64 cfg;\n\n\t \n\tblock = &hw->block[blkaddr];\n\tif (!block->implemented)\n\t\treturn 0;\n\tblkid = (blkaddr == BLKADDR_CPT0) ? 0 : 1;\n\tcfg = rvu_read64(rvu, blkaddr, CPT_AF_CONSTANTS0);\n\tblock->lf.max = cfg & 0xFF;\n\tblock->addr = blkaddr;\n\tblock->type = BLKTYPE_CPT;\n\tblock->multislot = true;\n\tblock->lfshift = 3;\n\tblock->lookup_reg = CPT_AF_RVU_LF_CFG_DEBUG;\n\tblock->pf_lfcnt_reg = RVU_PRIV_PFX_CPTX_CFG(blkid);\n\tblock->vf_lfcnt_reg = RVU_PRIV_HWVFX_CPTX_CFG(blkid);\n\tblock->lfcfg_reg = CPT_PRIV_LFX_CFG;\n\tblock->msixcfg_reg = CPT_PRIV_LFX_INT_CFG;\n\tblock->lfreset_reg = CPT_AF_LF_RST;\n\tblock->rvu = rvu;\n\tsprintf(block->name, \"CPT%d\", blkid);\n\treturn rvu_alloc_bitmap(&block->lf);\n}\n\nstatic void rvu_get_lbk_bufsize(struct rvu *rvu)\n{\n\tstruct pci_dev *pdev = NULL;\n\tvoid __iomem *base;\n\tu64 lbk_const;\n\n\tpdev = pci_get_device(PCI_VENDOR_ID_CAVIUM,\n\t\t\t      PCI_DEVID_OCTEONTX2_LBK, pdev);\n\tif (!pdev)\n\t\treturn;\n\n\tbase = pci_ioremap_bar(pdev, 0);\n\tif (!base)\n\t\tgoto err_put;\n\n\tlbk_const = readq(base + LBK_CONST);\n\n\t \n\trvu->hw->lbk_bufsize = FIELD_GET(LBK_CONST_BUF_SIZE, lbk_const);\n\n\tiounmap(base);\nerr_put:\n\tpci_dev_put(pdev);\n}\n\nstatic int rvu_setup_hw_resources(struct rvu *rvu)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tstruct rvu_block *block;\n\tint blkid, err;\n\tu64 cfg;\n\n\t \n\tcfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_CONST);\n\thw->total_pfs = (cfg >> 32) & 0xFF;\n\thw->total_vfs = (cfg >> 20) & 0xFFF;\n\thw->max_vfs_per_pf = (cfg >> 40) & 0xFF;\n\n\t \n\tblock = &hw->block[BLKADDR_NPA];\n\tif (!block->implemented)\n\t\tgoto nix;\n\tcfg = rvu_read64(rvu, BLKADDR_NPA, NPA_AF_CONST);\n\tblock->lf.max = (cfg >> 16) & 0xFFF;\n\tblock->addr = BLKADDR_NPA;\n\tblock->type = BLKTYPE_NPA;\n\tblock->lfshift = 8;\n\tblock->lookup_reg = NPA_AF_RVU_LF_CFG_DEBUG;\n\tblock->pf_lfcnt_reg = RVU_PRIV_PFX_NPA_CFG;\n\tblock->vf_lfcnt_reg = RVU_PRIV_HWVFX_NPA_CFG;\n\tblock->lfcfg_reg = NPA_PRIV_LFX_CFG;\n\tblock->msixcfg_reg = NPA_PRIV_LFX_INT_CFG;\n\tblock->lfreset_reg = NPA_AF_LF_RST;\n\tblock->rvu = rvu;\n\tsprintf(block->name, \"NPA\");\n\terr = rvu_alloc_bitmap(&block->lf);\n\tif (err) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"%s: Failed to allocate NPA LF bitmap\\n\", __func__);\n\t\treturn err;\n\t}\n\nnix:\n\terr = rvu_setup_nix_hw_resource(rvu, BLKADDR_NIX0);\n\tif (err) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"%s: Failed to allocate NIX0 LFs bitmap\\n\", __func__);\n\t\treturn err;\n\t}\n\n\terr = rvu_setup_nix_hw_resource(rvu, BLKADDR_NIX1);\n\tif (err) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"%s: Failed to allocate NIX1 LFs bitmap\\n\", __func__);\n\t\treturn err;\n\t}\n\n\t \n\tblock = &hw->block[BLKADDR_SSO];\n\tif (!block->implemented)\n\t\tgoto ssow;\n\tcfg = rvu_read64(rvu, BLKADDR_SSO, SSO_AF_CONST);\n\tblock->lf.max = cfg & 0xFFFF;\n\tblock->addr = BLKADDR_SSO;\n\tblock->type = BLKTYPE_SSO;\n\tblock->multislot = true;\n\tblock->lfshift = 3;\n\tblock->lookup_reg = SSO_AF_RVU_LF_CFG_DEBUG;\n\tblock->pf_lfcnt_reg = RVU_PRIV_PFX_SSO_CFG;\n\tblock->vf_lfcnt_reg = RVU_PRIV_HWVFX_SSO_CFG;\n\tblock->lfcfg_reg = SSO_PRIV_LFX_HWGRP_CFG;\n\tblock->msixcfg_reg = SSO_PRIV_LFX_HWGRP_INT_CFG;\n\tblock->lfreset_reg = SSO_AF_LF_HWGRP_RST;\n\tblock->rvu = rvu;\n\tsprintf(block->name, \"SSO GROUP\");\n\terr = rvu_alloc_bitmap(&block->lf);\n\tif (err) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"%s: Failed to allocate SSO LF bitmap\\n\", __func__);\n\t\treturn err;\n\t}\n\nssow:\n\t \n\tblock = &hw->block[BLKADDR_SSOW];\n\tif (!block->implemented)\n\t\tgoto tim;\n\tblock->lf.max = (cfg >> 56) & 0xFF;\n\tblock->addr = BLKADDR_SSOW;\n\tblock->type = BLKTYPE_SSOW;\n\tblock->multislot = true;\n\tblock->lfshift = 3;\n\tblock->lookup_reg = SSOW_AF_RVU_LF_HWS_CFG_DEBUG;\n\tblock->pf_lfcnt_reg = RVU_PRIV_PFX_SSOW_CFG;\n\tblock->vf_lfcnt_reg = RVU_PRIV_HWVFX_SSOW_CFG;\n\tblock->lfcfg_reg = SSOW_PRIV_LFX_HWS_CFG;\n\tblock->msixcfg_reg = SSOW_PRIV_LFX_HWS_INT_CFG;\n\tblock->lfreset_reg = SSOW_AF_LF_HWS_RST;\n\tblock->rvu = rvu;\n\tsprintf(block->name, \"SSOWS\");\n\terr = rvu_alloc_bitmap(&block->lf);\n\tif (err) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"%s: Failed to allocate SSOW LF bitmap\\n\", __func__);\n\t\treturn err;\n\t}\n\ntim:\n\t \n\tblock = &hw->block[BLKADDR_TIM];\n\tif (!block->implemented)\n\t\tgoto cpt;\n\tcfg = rvu_read64(rvu, BLKADDR_TIM, TIM_AF_CONST);\n\tblock->lf.max = cfg & 0xFFFF;\n\tblock->addr = BLKADDR_TIM;\n\tblock->type = BLKTYPE_TIM;\n\tblock->multislot = true;\n\tblock->lfshift = 3;\n\tblock->lookup_reg = TIM_AF_RVU_LF_CFG_DEBUG;\n\tblock->pf_lfcnt_reg = RVU_PRIV_PFX_TIM_CFG;\n\tblock->vf_lfcnt_reg = RVU_PRIV_HWVFX_TIM_CFG;\n\tblock->lfcfg_reg = TIM_PRIV_LFX_CFG;\n\tblock->msixcfg_reg = TIM_PRIV_LFX_INT_CFG;\n\tblock->lfreset_reg = TIM_AF_LF_RST;\n\tblock->rvu = rvu;\n\tsprintf(block->name, \"TIM\");\n\terr = rvu_alloc_bitmap(&block->lf);\n\tif (err) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"%s: Failed to allocate TIM LF bitmap\\n\", __func__);\n\t\treturn err;\n\t}\n\ncpt:\n\terr = rvu_setup_cpt_hw_resource(rvu, BLKADDR_CPT0);\n\tif (err) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"%s: Failed to allocate CPT0 LF bitmap\\n\", __func__);\n\t\treturn err;\n\t}\n\terr = rvu_setup_cpt_hw_resource(rvu, BLKADDR_CPT1);\n\tif (err) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"%s: Failed to allocate CPT1 LF bitmap\\n\", __func__);\n\t\treturn err;\n\t}\n\n\t \n\trvu->pf = devm_kcalloc(rvu->dev, hw->total_pfs,\n\t\t\t       sizeof(struct rvu_pfvf), GFP_KERNEL);\n\tif (!rvu->pf) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"%s: Failed to allocate memory for PF's rvu_pfvf struct\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\trvu->hwvf = devm_kcalloc(rvu->dev, hw->total_vfs,\n\t\t\t\t sizeof(struct rvu_pfvf), GFP_KERNEL);\n\tif (!rvu->hwvf) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"%s: Failed to allocate memory for VF's rvu_pfvf struct\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&rvu->rsrc_lock);\n\n\trvu_fwdata_init(rvu);\n\n\terr = rvu_setup_msix_resources(rvu);\n\tif (err) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"%s: Failed to setup MSIX resources\\n\", __func__);\n\t\treturn err;\n\t}\n\n\tfor (blkid = 0; blkid < BLK_COUNT; blkid++) {\n\t\tblock = &hw->block[blkid];\n\t\tif (!block->lf.bmap)\n\t\t\tcontinue;\n\n\t\t \n\t\tblock->fn_map = devm_kcalloc(rvu->dev, block->lf.max,\n\t\t\t\t\t     sizeof(u16), GFP_KERNEL);\n\t\tif (!block->fn_map) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto msix_err;\n\t\t}\n\n\t\t \n\t\trvu_scan_block(rvu, block);\n\t}\n\n\terr = rvu_set_channels_base(rvu);\n\tif (err)\n\t\tgoto msix_err;\n\n\terr = rvu_npc_init(rvu);\n\tif (err) {\n\t\tdev_err(rvu->dev, \"%s: Failed to initialize npc\\n\", __func__);\n\t\tgoto npc_err;\n\t}\n\n\terr = rvu_cgx_init(rvu);\n\tif (err) {\n\t\tdev_err(rvu->dev, \"%s: Failed to initialize cgx\\n\", __func__);\n\t\tgoto cgx_err;\n\t}\n\n\terr = rvu_npc_exact_init(rvu);\n\tif (err) {\n\t\tdev_err(rvu->dev, \"failed to initialize exact match table\\n\");\n\t\treturn err;\n\t}\n\n\t \n\trvu_setup_pfvf_macaddress(rvu);\n\n\terr = rvu_npa_init(rvu);\n\tif (err) {\n\t\tdev_err(rvu->dev, \"%s: Failed to initialize npa\\n\", __func__);\n\t\tgoto npa_err;\n\t}\n\n\trvu_get_lbk_bufsize(rvu);\n\n\terr = rvu_nix_init(rvu);\n\tif (err) {\n\t\tdev_err(rvu->dev, \"%s: Failed to initialize nix\\n\", __func__);\n\t\tgoto nix_err;\n\t}\n\n\terr = rvu_sdp_init(rvu);\n\tif (err) {\n\t\tdev_err(rvu->dev, \"%s: Failed to initialize sdp\\n\", __func__);\n\t\tgoto nix_err;\n\t}\n\n\trvu_program_channels(rvu);\n\n\terr = rvu_mcs_init(rvu);\n\tif (err) {\n\t\tdev_err(rvu->dev, \"%s: Failed to initialize mcs\\n\", __func__);\n\t\tgoto nix_err;\n\t}\n\n\terr = rvu_cpt_init(rvu);\n\tif (err) {\n\t\tdev_err(rvu->dev, \"%s: Failed to initialize cpt\\n\", __func__);\n\t\tgoto mcs_err;\n\t}\n\n\treturn 0;\n\nmcs_err:\n\trvu_mcs_exit(rvu);\nnix_err:\n\trvu_nix_freemem(rvu);\nnpa_err:\n\trvu_npa_freemem(rvu);\ncgx_err:\n\trvu_cgx_exit(rvu);\nnpc_err:\n\trvu_npc_freemem(rvu);\n\trvu_fwdata_exit(rvu);\nmsix_err:\n\trvu_reset_msix(rvu);\n\treturn err;\n}\n\n \nvoid rvu_aq_free(struct rvu *rvu, struct admin_queue *aq)\n{\n\tif (!aq)\n\t\treturn;\n\n\tqmem_free(rvu->dev, aq->inst);\n\tqmem_free(rvu->dev, aq->res);\n\tdevm_kfree(rvu->dev, aq);\n}\n\nint rvu_aq_alloc(struct rvu *rvu, struct admin_queue **ad_queue,\n\t\t int qsize, int inst_size, int res_size)\n{\n\tstruct admin_queue *aq;\n\tint err;\n\n\t*ad_queue = devm_kzalloc(rvu->dev, sizeof(*aq), GFP_KERNEL);\n\tif (!*ad_queue)\n\t\treturn -ENOMEM;\n\taq = *ad_queue;\n\n\t \n\terr = qmem_alloc(rvu->dev, &aq->inst, qsize, inst_size);\n\tif (err) {\n\t\tdevm_kfree(rvu->dev, aq);\n\t\treturn err;\n\t}\n\n\t \n\terr = qmem_alloc(rvu->dev, &aq->res, qsize, res_size);\n\tif (err) {\n\t\trvu_aq_free(rvu, aq);\n\t\treturn err;\n\t}\n\n\tspin_lock_init(&aq->lock);\n\treturn 0;\n}\n\nint rvu_mbox_handler_ready(struct rvu *rvu, struct msg_req *req,\n\t\t\t   struct ready_msg_rsp *rsp)\n{\n\tif (rvu->fwdata) {\n\t\trsp->rclk_freq = rvu->fwdata->rclk;\n\t\trsp->sclk_freq = rvu->fwdata->sclk;\n\t}\n\treturn 0;\n}\n\n \nu16 rvu_get_rsrc_mapcount(struct rvu_pfvf *pfvf, int blkaddr)\n{\n\tswitch (blkaddr) {\n\tcase BLKADDR_NPA:\n\t\treturn pfvf->npalf ? 1 : 0;\n\tcase BLKADDR_NIX0:\n\tcase BLKADDR_NIX1:\n\t\treturn pfvf->nixlf ? 1 : 0;\n\tcase BLKADDR_SSO:\n\t\treturn pfvf->sso;\n\tcase BLKADDR_SSOW:\n\t\treturn pfvf->ssow;\n\tcase BLKADDR_TIM:\n\t\treturn pfvf->timlfs;\n\tcase BLKADDR_CPT0:\n\t\treturn pfvf->cptlfs;\n\tcase BLKADDR_CPT1:\n\t\treturn pfvf->cpt1_lfs;\n\t}\n\treturn 0;\n}\n\n \nstatic bool is_blktype_attached(struct rvu_pfvf *pfvf, int blktype)\n{\n\tswitch (blktype) {\n\tcase BLKTYPE_NPA:\n\t\treturn pfvf->npalf ? 1 : 0;\n\tcase BLKTYPE_NIX:\n\t\treturn pfvf->nixlf ? 1 : 0;\n\tcase BLKTYPE_SSO:\n\t\treturn !!pfvf->sso;\n\tcase BLKTYPE_SSOW:\n\t\treturn !!pfvf->ssow;\n\tcase BLKTYPE_TIM:\n\t\treturn !!pfvf->timlfs;\n\tcase BLKTYPE_CPT:\n\t\treturn pfvf->cptlfs || pfvf->cpt1_lfs;\n\t}\n\n\treturn false;\n}\n\nbool is_pffunc_map_valid(struct rvu *rvu, u16 pcifunc, int blktype)\n{\n\tstruct rvu_pfvf *pfvf;\n\n\tif (!is_pf_func_valid(rvu, pcifunc))\n\t\treturn false;\n\n\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\n\t \n\tif (!is_blktype_attached(pfvf, blktype))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int rvu_lookup_rsrc(struct rvu *rvu, struct rvu_block *block,\n\t\t\t   int pcifunc, int slot)\n{\n\tu64 val;\n\n\tval = ((u64)pcifunc << 24) | (slot << 16) | (1ULL << 13);\n\trvu_write64(rvu, block->addr, block->lookup_reg, val);\n\t \n\t \n\twhile (rvu_read64(rvu, block->addr, block->lookup_reg) & (1ULL << 13))\n\t\t;\n\n\tval = rvu_read64(rvu, block->addr, block->lookup_reg);\n\n\t \n\tif (!(val & (1ULL << 12)))\n\t\treturn -1;\n\n\treturn (val & 0xFFF);\n}\n\nint rvu_get_blkaddr_from_slot(struct rvu *rvu, int blktype, u16 pcifunc,\n\t\t\t      u16 global_slot, u16 *slot_in_block)\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, pcifunc);\n\tint numlfs, total_lfs = 0, nr_blocks = 0;\n\tint i, num_blkaddr[BLK_COUNT] = { 0 };\n\tstruct rvu_block *block;\n\tint blkaddr;\n\tu16 start_slot;\n\n\tif (!is_blktype_attached(pfvf, blktype))\n\t\treturn -ENODEV;\n\n\t \n\tfor (blkaddr = BLKADDR_RVUM; blkaddr < BLK_COUNT; blkaddr++) {\n\t\tblock = &rvu->hw->block[blkaddr];\n\t\tif (block->type != blktype)\n\t\t\tcontinue;\n\t\tif (!is_block_implemented(rvu->hw, blkaddr))\n\t\t\tcontinue;\n\n\t\tnumlfs = rvu_get_rsrc_mapcount(pfvf, blkaddr);\n\t\tif (numlfs) {\n\t\t\ttotal_lfs += numlfs;\n\t\t\tnum_blkaddr[nr_blocks] = blkaddr;\n\t\t\tnr_blocks++;\n\t\t}\n\t}\n\n\tif (global_slot >= total_lfs)\n\t\treturn -ENODEV;\n\n\t \n\ttotal_lfs = 0;\n\tblkaddr = -ENODEV;\n\tfor (i = 0; i < nr_blocks; i++) {\n\t\tnumlfs = rvu_get_rsrc_mapcount(pfvf, num_blkaddr[i]);\n\t\ttotal_lfs += numlfs;\n\t\tif (global_slot < total_lfs) {\n\t\t\tblkaddr = num_blkaddr[i];\n\t\t\tstart_slot = total_lfs - numlfs;\n\t\t\t*slot_in_block = global_slot - start_slot;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn blkaddr;\n}\n\nstatic void rvu_detach_block(struct rvu *rvu, int pcifunc, int blktype)\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, pcifunc);\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tstruct rvu_block *block;\n\tint slot, lf, num_lfs;\n\tint blkaddr;\n\n\tblkaddr = rvu_get_blkaddr(rvu, blktype, pcifunc);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\tif (blktype == BLKTYPE_NIX)\n\t\trvu_nix_reset_mac(pfvf, pcifunc);\n\n\tblock = &hw->block[blkaddr];\n\n\tnum_lfs = rvu_get_rsrc_mapcount(pfvf, block->addr);\n\tif (!num_lfs)\n\t\treturn;\n\n\tfor (slot = 0; slot < num_lfs; slot++) {\n\t\tlf = rvu_lookup_rsrc(rvu, block, pcifunc, slot);\n\t\tif (lf < 0)  \n\t\t\tcontinue;\n\n\t\t \n\t\trvu_write64(rvu, blkaddr, block->lfcfg_reg |\n\t\t\t    (lf << block->lfshift), 0x00ULL);\n\n\t\t \n\t\trvu_update_rsrc_map(rvu, pfvf, block,\n\t\t\t\t    pcifunc, lf, false);\n\n\t\t \n\t\trvu_free_rsrc(&block->lf, lf);\n\n\t\t \n\t\trvu_clear_msix_offset(rvu, pfvf, block, lf);\n\t}\n}\n\nstatic int rvu_detach_rsrcs(struct rvu *rvu, struct rsrc_detach *detach,\n\t\t\t    u16 pcifunc)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tbool detach_all = true;\n\tstruct rvu_block *block;\n\tint blkid;\n\n\tmutex_lock(&rvu->rsrc_lock);\n\n\t \n\tif (detach && detach->partial)\n\t\tdetach_all = false;\n\n\t \n\tfor (blkid = 0; blkid < BLK_COUNT; blkid++) {\n\t\tblock = &hw->block[blkid];\n\t\tif (!block->lf.bmap)\n\t\t\tcontinue;\n\t\tif (!detach_all && detach) {\n\t\t\tif (blkid == BLKADDR_NPA && !detach->npalf)\n\t\t\t\tcontinue;\n\t\t\telse if ((blkid == BLKADDR_NIX0) && !detach->nixlf)\n\t\t\t\tcontinue;\n\t\t\telse if ((blkid == BLKADDR_NIX1) && !detach->nixlf)\n\t\t\t\tcontinue;\n\t\t\telse if ((blkid == BLKADDR_SSO) && !detach->sso)\n\t\t\t\tcontinue;\n\t\t\telse if ((blkid == BLKADDR_SSOW) && !detach->ssow)\n\t\t\t\tcontinue;\n\t\t\telse if ((blkid == BLKADDR_TIM) && !detach->timlfs)\n\t\t\t\tcontinue;\n\t\t\telse if ((blkid == BLKADDR_CPT0) && !detach->cptlfs)\n\t\t\t\tcontinue;\n\t\t\telse if ((blkid == BLKADDR_CPT1) && !detach->cptlfs)\n\t\t\t\tcontinue;\n\t\t}\n\t\trvu_detach_block(rvu, pcifunc, block->type);\n\t}\n\n\tmutex_unlock(&rvu->rsrc_lock);\n\treturn 0;\n}\n\nint rvu_mbox_handler_detach_resources(struct rvu *rvu,\n\t\t\t\t      struct rsrc_detach *detach,\n\t\t\t\t      struct msg_rsp *rsp)\n{\n\treturn rvu_detach_rsrcs(rvu, detach, detach->hdr.pcifunc);\n}\n\nint rvu_get_nix_blkaddr(struct rvu *rvu, u16 pcifunc)\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, pcifunc);\n\tint blkaddr = BLKADDR_NIX0, vf;\n\tstruct rvu_pfvf *pf;\n\n\tpf = rvu_get_pfvf(rvu, pcifunc & ~RVU_PFVF_FUNC_MASK);\n\n\t \n\tif (is_pf_cgxmapped(rvu, rvu_get_pf(pcifunc))) {\n\t\tblkaddr = pf->nix_blkaddr;\n\t} else if (is_afvf(pcifunc)) {\n\t\tvf = pcifunc - 1;\n\t\t \n\t\tblkaddr = (vf & 1) ? BLKADDR_NIX1 : BLKADDR_NIX0;\n\t\t \n\t\tif (!is_block_implemented(rvu->hw, BLKADDR_NIX1))\n\t\t\tblkaddr = BLKADDR_NIX0;\n\t}\n\n\t \n\tif (is_sdp_pfvf(pcifunc) && pf->sdp_info->node_id == 1)\n\t\tblkaddr = BLKADDR_NIX1;\n\n\tswitch (blkaddr) {\n\tcase BLKADDR_NIX1:\n\t\tpfvf->nix_blkaddr = BLKADDR_NIX1;\n\t\tpfvf->nix_rx_intf = NIX_INTFX_RX(1);\n\t\tpfvf->nix_tx_intf = NIX_INTFX_TX(1);\n\t\tbreak;\n\tcase BLKADDR_NIX0:\n\tdefault:\n\t\tpfvf->nix_blkaddr = BLKADDR_NIX0;\n\t\tpfvf->nix_rx_intf = NIX_INTFX_RX(0);\n\t\tpfvf->nix_tx_intf = NIX_INTFX_TX(0);\n\t\tbreak;\n\t}\n\n\treturn pfvf->nix_blkaddr;\n}\n\nstatic int rvu_get_attach_blkaddr(struct rvu *rvu, int blktype,\n\t\t\t\t  u16 pcifunc, struct rsrc_attach *attach)\n{\n\tint blkaddr;\n\n\tswitch (blktype) {\n\tcase BLKTYPE_NIX:\n\t\tblkaddr = rvu_get_nix_blkaddr(rvu, pcifunc);\n\t\tbreak;\n\tcase BLKTYPE_CPT:\n\t\tif (attach->hdr.ver < RVU_MULTI_BLK_VER)\n\t\t\treturn rvu_get_blkaddr(rvu, blktype, 0);\n\t\tblkaddr = attach->cpt_blkaddr ? attach->cpt_blkaddr :\n\t\t\t  BLKADDR_CPT0;\n\t\tif (blkaddr != BLKADDR_CPT0 && blkaddr != BLKADDR_CPT1)\n\t\t\treturn -ENODEV;\n\t\tbreak;\n\tdefault:\n\t\treturn rvu_get_blkaddr(rvu, blktype, 0);\n\t}\n\n\tif (is_block_implemented(rvu->hw, blkaddr))\n\t\treturn blkaddr;\n\n\treturn -ENODEV;\n}\n\nstatic void rvu_attach_block(struct rvu *rvu, int pcifunc, int blktype,\n\t\t\t     int num_lfs, struct rsrc_attach *attach)\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, pcifunc);\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tstruct rvu_block *block;\n\tint slot, lf;\n\tint blkaddr;\n\tu64 cfg;\n\n\tif (!num_lfs)\n\t\treturn;\n\n\tblkaddr = rvu_get_attach_blkaddr(rvu, blktype, pcifunc, attach);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\tblock = &hw->block[blkaddr];\n\tif (!block->lf.bmap)\n\t\treturn;\n\n\tfor (slot = 0; slot < num_lfs; slot++) {\n\t\t \n\t\tlf = rvu_alloc_rsrc(&block->lf);\n\t\tif (lf < 0)\n\t\t\treturn;\n\n\t\tcfg = (1ULL << 63) | (pcifunc << 8) | slot;\n\t\trvu_write64(rvu, blkaddr, block->lfcfg_reg |\n\t\t\t    (lf << block->lfshift), cfg);\n\t\trvu_update_rsrc_map(rvu, pfvf, block,\n\t\t\t\t    pcifunc, lf, true);\n\n\t\t \n\t\trvu_set_msix_offset(rvu, pfvf, block, lf);\n\t}\n}\n\nstatic int rvu_check_rsrc_availability(struct rvu *rvu,\n\t\t\t\t       struct rsrc_attach *req, u16 pcifunc)\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, pcifunc);\n\tint free_lfs, mappedlfs, blkaddr;\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tstruct rvu_block *block;\n\n\t \n\tif (req->npalf && !is_blktype_attached(pfvf, BLKTYPE_NPA)) {\n\t\tblock = &hw->block[BLKADDR_NPA];\n\t\tfree_lfs = rvu_rsrc_free_count(&block->lf);\n\t\tif (!free_lfs)\n\t\t\tgoto fail;\n\t} else if (req->npalf) {\n\t\tdev_err(&rvu->pdev->dev,\n\t\t\t\"Func 0x%x: Invalid req, already has NPA\\n\",\n\t\t\t pcifunc);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (req->nixlf && !is_blktype_attached(pfvf, BLKTYPE_NIX)) {\n\t\tblkaddr = rvu_get_attach_blkaddr(rvu, BLKTYPE_NIX,\n\t\t\t\t\t\t pcifunc, req);\n\t\tif (blkaddr < 0)\n\t\t\treturn blkaddr;\n\t\tblock = &hw->block[blkaddr];\n\t\tfree_lfs = rvu_rsrc_free_count(&block->lf);\n\t\tif (!free_lfs)\n\t\t\tgoto fail;\n\t} else if (req->nixlf) {\n\t\tdev_err(&rvu->pdev->dev,\n\t\t\t\"Func 0x%x: Invalid req, already has NIX\\n\",\n\t\t\tpcifunc);\n\t\treturn -EINVAL;\n\t}\n\n\tif (req->sso) {\n\t\tblock = &hw->block[BLKADDR_SSO];\n\t\t \n\t\tif (req->sso > block->lf.max) {\n\t\t\tdev_err(&rvu->pdev->dev,\n\t\t\t\t\"Func 0x%x: Invalid SSO req, %d > max %d\\n\",\n\t\t\t\t pcifunc, req->sso, block->lf.max);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmappedlfs = rvu_get_rsrc_mapcount(pfvf, block->addr);\n\t\tfree_lfs = rvu_rsrc_free_count(&block->lf);\n\t\t \n\t\tif (req->sso > mappedlfs &&\n\t\t    ((req->sso - mappedlfs) > free_lfs))\n\t\t\tgoto fail;\n\t}\n\n\tif (req->ssow) {\n\t\tblock = &hw->block[BLKADDR_SSOW];\n\t\tif (req->ssow > block->lf.max) {\n\t\t\tdev_err(&rvu->pdev->dev,\n\t\t\t\t\"Func 0x%x: Invalid SSOW req, %d > max %d\\n\",\n\t\t\t\t pcifunc, req->sso, block->lf.max);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmappedlfs = rvu_get_rsrc_mapcount(pfvf, block->addr);\n\t\tfree_lfs = rvu_rsrc_free_count(&block->lf);\n\t\tif (req->ssow > mappedlfs &&\n\t\t    ((req->ssow - mappedlfs) > free_lfs))\n\t\t\tgoto fail;\n\t}\n\n\tif (req->timlfs) {\n\t\tblock = &hw->block[BLKADDR_TIM];\n\t\tif (req->timlfs > block->lf.max) {\n\t\t\tdev_err(&rvu->pdev->dev,\n\t\t\t\t\"Func 0x%x: Invalid TIMLF req, %d > max %d\\n\",\n\t\t\t\t pcifunc, req->timlfs, block->lf.max);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmappedlfs = rvu_get_rsrc_mapcount(pfvf, block->addr);\n\t\tfree_lfs = rvu_rsrc_free_count(&block->lf);\n\t\tif (req->timlfs > mappedlfs &&\n\t\t    ((req->timlfs - mappedlfs) > free_lfs))\n\t\t\tgoto fail;\n\t}\n\n\tif (req->cptlfs) {\n\t\tblkaddr = rvu_get_attach_blkaddr(rvu, BLKTYPE_CPT,\n\t\t\t\t\t\t pcifunc, req);\n\t\tif (blkaddr < 0)\n\t\t\treturn blkaddr;\n\t\tblock = &hw->block[blkaddr];\n\t\tif (req->cptlfs > block->lf.max) {\n\t\t\tdev_err(&rvu->pdev->dev,\n\t\t\t\t\"Func 0x%x: Invalid CPTLF req, %d > max %d\\n\",\n\t\t\t\t pcifunc, req->cptlfs, block->lf.max);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmappedlfs = rvu_get_rsrc_mapcount(pfvf, block->addr);\n\t\tfree_lfs = rvu_rsrc_free_count(&block->lf);\n\t\tif (req->cptlfs > mappedlfs &&\n\t\t    ((req->cptlfs - mappedlfs) > free_lfs))\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdev_info(rvu->dev, \"Request for %s failed\\n\", block->name);\n\treturn -ENOSPC;\n}\n\nstatic bool rvu_attach_from_same_block(struct rvu *rvu, int blktype,\n\t\t\t\t       struct rsrc_attach *attach)\n{\n\tint blkaddr, num_lfs;\n\n\tblkaddr = rvu_get_attach_blkaddr(rvu, blktype,\n\t\t\t\t\t attach->hdr.pcifunc, attach);\n\tif (blkaddr < 0)\n\t\treturn false;\n\n\tnum_lfs = rvu_get_rsrc_mapcount(rvu_get_pfvf(rvu, attach->hdr.pcifunc),\n\t\t\t\t\tblkaddr);\n\t \n\treturn !!num_lfs;\n}\n\nint rvu_mbox_handler_attach_resources(struct rvu *rvu,\n\t\t\t\t      struct rsrc_attach *attach,\n\t\t\t\t      struct msg_rsp *rsp)\n{\n\tu16 pcifunc = attach->hdr.pcifunc;\n\tint err;\n\n\t \n\tif (!attach->modify)\n\t\trvu_detach_rsrcs(rvu, NULL, pcifunc);\n\n\tmutex_lock(&rvu->rsrc_lock);\n\n\t \n\terr = rvu_check_rsrc_availability(rvu, attach, pcifunc);\n\tif (err)\n\t\tgoto exit;\n\n\t \n\tif (attach->npalf)\n\t\trvu_attach_block(rvu, pcifunc, BLKTYPE_NPA, 1, attach);\n\n\tif (attach->nixlf)\n\t\trvu_attach_block(rvu, pcifunc, BLKTYPE_NIX, 1, attach);\n\n\tif (attach->sso) {\n\t\t \n\t\tif (attach->modify)\n\t\t\trvu_detach_block(rvu, pcifunc, BLKTYPE_SSO);\n\t\trvu_attach_block(rvu, pcifunc, BLKTYPE_SSO,\n\t\t\t\t attach->sso, attach);\n\t}\n\n\tif (attach->ssow) {\n\t\tif (attach->modify)\n\t\t\trvu_detach_block(rvu, pcifunc, BLKTYPE_SSOW);\n\t\trvu_attach_block(rvu, pcifunc, BLKTYPE_SSOW,\n\t\t\t\t attach->ssow, attach);\n\t}\n\n\tif (attach->timlfs) {\n\t\tif (attach->modify)\n\t\t\trvu_detach_block(rvu, pcifunc, BLKTYPE_TIM);\n\t\trvu_attach_block(rvu, pcifunc, BLKTYPE_TIM,\n\t\t\t\t attach->timlfs, attach);\n\t}\n\n\tif (attach->cptlfs) {\n\t\tif (attach->modify &&\n\t\t    rvu_attach_from_same_block(rvu, BLKTYPE_CPT, attach))\n\t\t\trvu_detach_block(rvu, pcifunc, BLKTYPE_CPT);\n\t\trvu_attach_block(rvu, pcifunc, BLKTYPE_CPT,\n\t\t\t\t attach->cptlfs, attach);\n\t}\n\nexit:\n\tmutex_unlock(&rvu->rsrc_lock);\n\treturn err;\n}\n\nstatic u16 rvu_get_msix_offset(struct rvu *rvu, struct rvu_pfvf *pfvf,\n\t\t\t       int blkaddr, int lf)\n{\n\tu16 vec;\n\n\tif (lf < 0)\n\t\treturn MSIX_VECTOR_INVALID;\n\n\tfor (vec = 0; vec < pfvf->msix.max; vec++) {\n\t\tif (pfvf->msix_lfmap[vec] == MSIX_BLKLF(blkaddr, lf))\n\t\t\treturn vec;\n\t}\n\treturn MSIX_VECTOR_INVALID;\n}\n\nstatic void rvu_set_msix_offset(struct rvu *rvu, struct rvu_pfvf *pfvf,\n\t\t\t\tstruct rvu_block *block, int lf)\n{\n\tu16 nvecs, vec, offset;\n\tu64 cfg;\n\n\tcfg = rvu_read64(rvu, block->addr, block->msixcfg_reg |\n\t\t\t (lf << block->lfshift));\n\tnvecs = (cfg >> 12) & 0xFF;\n\n\t \n\tif (!rvu_rsrc_check_contig(&pfvf->msix, nvecs))\n\t\treturn;\n\n\toffset = rvu_alloc_rsrc_contig(&pfvf->msix, nvecs);\n\n\t \n\trvu_write64(rvu, block->addr, block->msixcfg_reg |\n\t\t    (lf << block->lfshift), (cfg & ~0x7FFULL) | offset);\n\n\t \n\tfor (vec = 0; vec < nvecs; vec++)\n\t\tpfvf->msix_lfmap[offset + vec] = MSIX_BLKLF(block->addr, lf);\n}\n\nstatic void rvu_clear_msix_offset(struct rvu *rvu, struct rvu_pfvf *pfvf,\n\t\t\t\t  struct rvu_block *block, int lf)\n{\n\tu16 nvecs, vec, offset;\n\tu64 cfg;\n\n\tcfg = rvu_read64(rvu, block->addr, block->msixcfg_reg |\n\t\t\t (lf << block->lfshift));\n\tnvecs = (cfg >> 12) & 0xFF;\n\n\t \n\trvu_write64(rvu, block->addr, block->msixcfg_reg |\n\t\t    (lf << block->lfshift), cfg & ~0x7FFULL);\n\n\toffset = rvu_get_msix_offset(rvu, pfvf, block->addr, lf);\n\n\t \n\tfor (vec = 0; vec < nvecs; vec++)\n\t\tpfvf->msix_lfmap[offset + vec] = 0;\n\n\t \n\trvu_free_rsrc_contig(&pfvf->msix, nvecs, offset);\n}\n\nint rvu_mbox_handler_msix_offset(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t struct msix_offset_rsp *rsp)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tu16 pcifunc = req->hdr.pcifunc;\n\tstruct rvu_pfvf *pfvf;\n\tint lf, slot, blkaddr;\n\n\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\tif (!pfvf->msix.bmap)\n\t\treturn 0;\n\n\t \n\tlf = rvu_get_lf(rvu, &hw->block[BLKADDR_NPA], pcifunc, 0);\n\trsp->npa_msixoff = rvu_get_msix_offset(rvu, pfvf, BLKADDR_NPA, lf);\n\n\t \n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NIX, pcifunc);\n\tif (blkaddr < 0) {\n\t\trsp->nix_msixoff = MSIX_VECTOR_INVALID;\n\t} else {\n\t\tlf = rvu_get_lf(rvu, &hw->block[blkaddr], pcifunc, 0);\n\t\trsp->nix_msixoff = rvu_get_msix_offset(rvu, pfvf, blkaddr, lf);\n\t}\n\n\trsp->sso = pfvf->sso;\n\tfor (slot = 0; slot < rsp->sso; slot++) {\n\t\tlf = rvu_get_lf(rvu, &hw->block[BLKADDR_SSO], pcifunc, slot);\n\t\trsp->sso_msixoff[slot] =\n\t\t\trvu_get_msix_offset(rvu, pfvf, BLKADDR_SSO, lf);\n\t}\n\n\trsp->ssow = pfvf->ssow;\n\tfor (slot = 0; slot < rsp->ssow; slot++) {\n\t\tlf = rvu_get_lf(rvu, &hw->block[BLKADDR_SSOW], pcifunc, slot);\n\t\trsp->ssow_msixoff[slot] =\n\t\t\trvu_get_msix_offset(rvu, pfvf, BLKADDR_SSOW, lf);\n\t}\n\n\trsp->timlfs = pfvf->timlfs;\n\tfor (slot = 0; slot < rsp->timlfs; slot++) {\n\t\tlf = rvu_get_lf(rvu, &hw->block[BLKADDR_TIM], pcifunc, slot);\n\t\trsp->timlf_msixoff[slot] =\n\t\t\trvu_get_msix_offset(rvu, pfvf, BLKADDR_TIM, lf);\n\t}\n\n\trsp->cptlfs = pfvf->cptlfs;\n\tfor (slot = 0; slot < rsp->cptlfs; slot++) {\n\t\tlf = rvu_get_lf(rvu, &hw->block[BLKADDR_CPT0], pcifunc, slot);\n\t\trsp->cptlf_msixoff[slot] =\n\t\t\trvu_get_msix_offset(rvu, pfvf, BLKADDR_CPT0, lf);\n\t}\n\n\trsp->cpt1_lfs = pfvf->cpt1_lfs;\n\tfor (slot = 0; slot < rsp->cpt1_lfs; slot++) {\n\t\tlf = rvu_get_lf(rvu, &hw->block[BLKADDR_CPT1], pcifunc, slot);\n\t\trsp->cpt1_lf_msixoff[slot] =\n\t\t\trvu_get_msix_offset(rvu, pfvf, BLKADDR_CPT1, lf);\n\t}\n\n\treturn 0;\n}\n\nint rvu_mbox_handler_free_rsrc_cnt(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t   struct free_rsrcs_rsp *rsp)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tstruct rvu_block *block;\n\tstruct nix_txsch *txsch;\n\tstruct nix_hw *nix_hw;\n\n\tmutex_lock(&rvu->rsrc_lock);\n\n\tblock = &hw->block[BLKADDR_NPA];\n\trsp->npa = rvu_rsrc_free_count(&block->lf);\n\n\tblock = &hw->block[BLKADDR_NIX0];\n\trsp->nix = rvu_rsrc_free_count(&block->lf);\n\n\tblock = &hw->block[BLKADDR_NIX1];\n\trsp->nix1 = rvu_rsrc_free_count(&block->lf);\n\n\tblock = &hw->block[BLKADDR_SSO];\n\trsp->sso = rvu_rsrc_free_count(&block->lf);\n\n\tblock = &hw->block[BLKADDR_SSOW];\n\trsp->ssow = rvu_rsrc_free_count(&block->lf);\n\n\tblock = &hw->block[BLKADDR_TIM];\n\trsp->tim = rvu_rsrc_free_count(&block->lf);\n\n\tblock = &hw->block[BLKADDR_CPT0];\n\trsp->cpt = rvu_rsrc_free_count(&block->lf);\n\n\tblock = &hw->block[BLKADDR_CPT1];\n\trsp->cpt1 = rvu_rsrc_free_count(&block->lf);\n\n\tif (rvu->hw->cap.nix_fixed_txschq_mapping) {\n\t\trsp->schq[NIX_TXSCH_LVL_SMQ] = 1;\n\t\trsp->schq[NIX_TXSCH_LVL_TL4] = 1;\n\t\trsp->schq[NIX_TXSCH_LVL_TL3] = 1;\n\t\trsp->schq[NIX_TXSCH_LVL_TL2] = 1;\n\t\t \n\t\tif (!is_block_implemented(rvu->hw, BLKADDR_NIX1))\n\t\t\tgoto out;\n\t\trsp->schq_nix1[NIX_TXSCH_LVL_SMQ] = 1;\n\t\trsp->schq_nix1[NIX_TXSCH_LVL_TL4] = 1;\n\t\trsp->schq_nix1[NIX_TXSCH_LVL_TL3] = 1;\n\t\trsp->schq_nix1[NIX_TXSCH_LVL_TL2] = 1;\n\t} else {\n\t\tnix_hw = get_nix_hw(hw, BLKADDR_NIX0);\n\t\ttxsch = &nix_hw->txsch[NIX_TXSCH_LVL_SMQ];\n\t\trsp->schq[NIX_TXSCH_LVL_SMQ] =\n\t\t\t\trvu_rsrc_free_count(&txsch->schq);\n\n\t\ttxsch = &nix_hw->txsch[NIX_TXSCH_LVL_TL4];\n\t\trsp->schq[NIX_TXSCH_LVL_TL4] =\n\t\t\t\trvu_rsrc_free_count(&txsch->schq);\n\n\t\ttxsch = &nix_hw->txsch[NIX_TXSCH_LVL_TL3];\n\t\trsp->schq[NIX_TXSCH_LVL_TL3] =\n\t\t\t\trvu_rsrc_free_count(&txsch->schq);\n\n\t\ttxsch = &nix_hw->txsch[NIX_TXSCH_LVL_TL2];\n\t\trsp->schq[NIX_TXSCH_LVL_TL2] =\n\t\t\t\trvu_rsrc_free_count(&txsch->schq);\n\n\t\tif (!is_block_implemented(rvu->hw, BLKADDR_NIX1))\n\t\t\tgoto out;\n\n\t\tnix_hw = get_nix_hw(hw, BLKADDR_NIX1);\n\t\ttxsch = &nix_hw->txsch[NIX_TXSCH_LVL_SMQ];\n\t\trsp->schq_nix1[NIX_TXSCH_LVL_SMQ] =\n\t\t\t\trvu_rsrc_free_count(&txsch->schq);\n\n\t\ttxsch = &nix_hw->txsch[NIX_TXSCH_LVL_TL4];\n\t\trsp->schq_nix1[NIX_TXSCH_LVL_TL4] =\n\t\t\t\trvu_rsrc_free_count(&txsch->schq);\n\n\t\ttxsch = &nix_hw->txsch[NIX_TXSCH_LVL_TL3];\n\t\trsp->schq_nix1[NIX_TXSCH_LVL_TL3] =\n\t\t\t\trvu_rsrc_free_count(&txsch->schq);\n\n\t\ttxsch = &nix_hw->txsch[NIX_TXSCH_LVL_TL2];\n\t\trsp->schq_nix1[NIX_TXSCH_LVL_TL2] =\n\t\t\t\trvu_rsrc_free_count(&txsch->schq);\n\t}\n\n\trsp->schq_nix1[NIX_TXSCH_LVL_TL1] = 1;\nout:\n\trsp->schq[NIX_TXSCH_LVL_TL1] = 1;\n\tmutex_unlock(&rvu->rsrc_lock);\n\n\treturn 0;\n}\n\nint rvu_mbox_handler_vf_flr(struct rvu *rvu, struct msg_req *req,\n\t\t\t    struct msg_rsp *rsp)\n{\n\tu16 pcifunc = req->hdr.pcifunc;\n\tu16 vf, numvfs;\n\tu64 cfg;\n\n\tvf = pcifunc & RVU_PFVF_FUNC_MASK;\n\tcfg = rvu_read64(rvu, BLKADDR_RVUM,\n\t\t\t RVU_PRIV_PFX_CFG(rvu_get_pf(pcifunc)));\n\tnumvfs = (cfg >> 12) & 0xFF;\n\n\tif (vf && vf <= numvfs)\n\t\t__rvu_flr_handler(rvu, pcifunc);\n\telse\n\t\treturn RVU_INVALID_VF_ID;\n\n\treturn 0;\n}\n\nint rvu_mbox_handler_get_hw_cap(struct rvu *rvu, struct msg_req *req,\n\t\t\t\tstruct get_hw_cap_rsp *rsp)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\n\trsp->nix_fixed_txschq_mapping = hw->cap.nix_fixed_txschq_mapping;\n\trsp->nix_shaping = hw->cap.nix_shaping;\n\trsp->npc_hash_extract = hw->cap.npc_hash_extract;\n\n\treturn 0;\n}\n\nint rvu_mbox_handler_set_vf_perm(struct rvu *rvu, struct set_vf_perm *req,\n\t\t\t\t struct msg_rsp *rsp)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tu16 pcifunc = req->hdr.pcifunc;\n\tstruct rvu_pfvf *pfvf;\n\tint blkaddr, nixlf;\n\tu16 target;\n\n\t \n\tif ((pcifunc & RVU_PFVF_FUNC_MASK) || is_afvf(pcifunc))\n\t\treturn -EOPNOTSUPP;\n\n\ttarget = (pcifunc & ~RVU_PFVF_FUNC_MASK) | (req->vf + 1);\n\tpfvf = rvu_get_pfvf(rvu, target);\n\n\tif (req->flags & RESET_VF_PERM) {\n\t\tpfvf->flags &= RVU_CLEAR_VF_PERM;\n\t} else if (test_bit(PF_SET_VF_TRUSTED, &pfvf->flags) ^\n\t\t (req->flags & VF_TRUSTED)) {\n\t\tchange_bit(PF_SET_VF_TRUSTED, &pfvf->flags);\n\t\t \n\t\tif (!test_bit(PF_SET_VF_TRUSTED, &pfvf->flags)) {\n\t\t\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NIX, target);\n\t\t\tif (blkaddr < 0)\n\t\t\t\treturn 0;\n\t\t\tnixlf = rvu_get_lf(rvu, &hw->block[blkaddr],\n\t\t\t\t\t   target, 0);\n\t\t\tif (nixlf < 0)\n\t\t\t\treturn 0;\n\t\t\tnpc_enadis_default_mce_entry(rvu, target, nixlf,\n\t\t\t\t\t\t     NIXLF_ALLMULTI_ENTRY,\n\t\t\t\t\t\t     false);\n\t\t\tnpc_enadis_default_mce_entry(rvu, target, nixlf,\n\t\t\t\t\t\t     NIXLF_PROMISC_ENTRY,\n\t\t\t\t\t\t     false);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rvu_process_mbox_msg(struct otx2_mbox *mbox, int devid,\n\t\t\t\tstruct mbox_msghdr *req)\n{\n\tstruct rvu *rvu = pci_get_drvdata(mbox->pdev);\n\n\t \n\tif (req->sig != OTX2_MBOX_REQ_SIG)\n\t\tgoto bad_message;\n\n\tswitch (req->id) {\n#define M(_name, _id, _fn_name, _req_type, _rsp_type)\t\t\t\\\n\tcase _id: {\t\t\t\t\t\t\t\\\n\t\tstruct _rsp_type *rsp;\t\t\t\t\t\\\n\t\tint err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\trsp = (struct _rsp_type *)otx2_mbox_alloc_msg(\t\t\\\n\t\t\tmbox, devid,\t\t\t\t\t\\\n\t\t\tsizeof(struct _rsp_type));\t\t\t\\\n\t\t \t\\\n\t\t \t\t\t\t\\\n\t\tif (!rsp &&\t\t\t\t\t\t\\\n\t\t    _id != MBOX_MSG_DETACH_RESOURCES &&\t\t\t\\\n\t\t    _id != MBOX_MSG_NIX_TXSCH_FREE &&\t\t\t\\\n\t\t    _id != MBOX_MSG_VF_FLR)\t\t\t\t\\\n\t\t\treturn -ENOMEM;\t\t\t\t\t\\\n\t\tif (rsp) {\t\t\t\t\t\t\\\n\t\t\trsp->hdr.id = _id;\t\t\t\t\\\n\t\t\trsp->hdr.sig = OTX2_MBOX_RSP_SIG;\t\t\\\n\t\t\trsp->hdr.pcifunc = req->pcifunc;\t\t\\\n\t\t\trsp->hdr.rc = 0;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\terr = rvu_mbox_handler_ ## _fn_name(rvu,\t\t\\\n\t\t\t\t\t\t    (struct _req_type *)req, \\\n\t\t\t\t\t\t    rsp);\t\t\\\n\t\tif (rsp && err)\t\t\t\t\t\t\\\n\t\t\trsp->hdr.rc = err;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\ttrace_otx2_msg_process(mbox->pdev, _id, err);\t\t\\\n\t\treturn rsp ? err : -ENOMEM;\t\t\t\t\\\n\t}\nMBOX_MESSAGES\n#undef M\n\nbad_message:\n\tdefault:\n\t\totx2_reply_invalid_msg(mbox, devid, req->pcifunc, req->id);\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic void __rvu_mbox_handler(struct rvu_work *mwork, int type)\n{\n\tstruct rvu *rvu = mwork->rvu;\n\tint offset, err, id, devid;\n\tstruct otx2_mbox_dev *mdev;\n\tstruct mbox_hdr *req_hdr;\n\tstruct mbox_msghdr *msg;\n\tstruct mbox_wq_info *mw;\n\tstruct otx2_mbox *mbox;\n\n\tswitch (type) {\n\tcase TYPE_AFPF:\n\t\tmw = &rvu->afpf_wq_info;\n\t\tbreak;\n\tcase TYPE_AFVF:\n\t\tmw = &rvu->afvf_wq_info;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tdevid = mwork - mw->mbox_wrk;\n\tmbox = &mw->mbox;\n\tmdev = &mbox->dev[devid];\n\n\t \n\treq_hdr = mdev->mbase + mbox->rx_start;\n\tif (mw->mbox_wrk[devid].num_msgs == 0)\n\t\treturn;\n\n\toffset = mbox->rx_start + ALIGN(sizeof(*req_hdr), MBOX_MSG_ALIGN);\n\n\tfor (id = 0; id < mw->mbox_wrk[devid].num_msgs; id++) {\n\t\tmsg = mdev->mbase + offset;\n\n\t\t \n\t\tswitch (type) {\n\t\tcase TYPE_AFPF:\n\t\t\tmsg->pcifunc &=\n\t\t\t\t~(RVU_PFVF_PF_MASK << RVU_PFVF_PF_SHIFT);\n\t\t\tmsg->pcifunc |= (devid << RVU_PFVF_PF_SHIFT);\n\t\t\tbreak;\n\t\tcase TYPE_AFVF:\n\t\t\tmsg->pcifunc &=\n\t\t\t\t~(RVU_PFVF_FUNC_MASK << RVU_PFVF_FUNC_SHIFT);\n\t\t\tmsg->pcifunc |= (devid << RVU_PFVF_FUNC_SHIFT) + 1;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = rvu_process_mbox_msg(mbox, devid, msg);\n\t\tif (!err) {\n\t\t\toffset = mbox->rx_start + msg->next_msgoff;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (msg->pcifunc & RVU_PFVF_FUNC_MASK)\n\t\t\tdev_warn(rvu->dev, \"Error %d when processing message %s (0x%x) from PF%d:VF%d\\n\",\n\t\t\t\t err, otx2_mbox_id2name(msg->id),\n\t\t\t\t msg->id, rvu_get_pf(msg->pcifunc),\n\t\t\t\t (msg->pcifunc & RVU_PFVF_FUNC_MASK) - 1);\n\t\telse\n\t\t\tdev_warn(rvu->dev, \"Error %d when processing message %s (0x%x) from PF%d\\n\",\n\t\t\t\t err, otx2_mbox_id2name(msg->id),\n\t\t\t\t msg->id, devid);\n\t}\n\tmw->mbox_wrk[devid].num_msgs = 0;\n\n\t \n\totx2_mbox_msg_send(mbox, devid);\n}\n\nstatic inline void rvu_afpf_mbox_handler(struct work_struct *work)\n{\n\tstruct rvu_work *mwork = container_of(work, struct rvu_work, work);\n\n\t__rvu_mbox_handler(mwork, TYPE_AFPF);\n}\n\nstatic inline void rvu_afvf_mbox_handler(struct work_struct *work)\n{\n\tstruct rvu_work *mwork = container_of(work, struct rvu_work, work);\n\n\t__rvu_mbox_handler(mwork, TYPE_AFVF);\n}\n\nstatic void __rvu_mbox_up_handler(struct rvu_work *mwork, int type)\n{\n\tstruct rvu *rvu = mwork->rvu;\n\tstruct otx2_mbox_dev *mdev;\n\tstruct mbox_hdr *rsp_hdr;\n\tstruct mbox_msghdr *msg;\n\tstruct mbox_wq_info *mw;\n\tstruct otx2_mbox *mbox;\n\tint offset, id, devid;\n\n\tswitch (type) {\n\tcase TYPE_AFPF:\n\t\tmw = &rvu->afpf_wq_info;\n\t\tbreak;\n\tcase TYPE_AFVF:\n\t\tmw = &rvu->afvf_wq_info;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tdevid = mwork - mw->mbox_wrk_up;\n\tmbox = &mw->mbox_up;\n\tmdev = &mbox->dev[devid];\n\n\trsp_hdr = mdev->mbase + mbox->rx_start;\n\tif (mw->mbox_wrk_up[devid].up_num_msgs == 0) {\n\t\tdev_warn(rvu->dev, \"mbox up handler: num_msgs = 0\\n\");\n\t\treturn;\n\t}\n\n\toffset = mbox->rx_start + ALIGN(sizeof(*rsp_hdr), MBOX_MSG_ALIGN);\n\n\tfor (id = 0; id < mw->mbox_wrk_up[devid].up_num_msgs; id++) {\n\t\tmsg = mdev->mbase + offset;\n\n\t\tif (msg->id >= MBOX_MSG_MAX) {\n\t\t\tdev_err(rvu->dev,\n\t\t\t\t\"Mbox msg with unknown ID 0x%x\\n\", msg->id);\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (msg->sig != OTX2_MBOX_RSP_SIG) {\n\t\t\tdev_err(rvu->dev,\n\t\t\t\t\"Mbox msg with wrong signature %x, ID 0x%x\\n\",\n\t\t\t\tmsg->sig, msg->id);\n\t\t\tgoto end;\n\t\t}\n\n\t\tswitch (msg->id) {\n\t\tcase MBOX_MSG_CGX_LINK_EVENT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (msg->rc)\n\t\t\t\tdev_err(rvu->dev,\n\t\t\t\t\t\"Mbox msg response has err %d, ID 0x%x\\n\",\n\t\t\t\t\tmsg->rc, msg->id);\n\t\t\tbreak;\n\t\t}\nend:\n\t\toffset = mbox->rx_start + msg->next_msgoff;\n\t\tmdev->msgs_acked++;\n\t}\n\tmw->mbox_wrk_up[devid].up_num_msgs = 0;\n\n\totx2_mbox_reset(mbox, devid);\n}\n\nstatic inline void rvu_afpf_mbox_up_handler(struct work_struct *work)\n{\n\tstruct rvu_work *mwork = container_of(work, struct rvu_work, work);\n\n\t__rvu_mbox_up_handler(mwork, TYPE_AFPF);\n}\n\nstatic inline void rvu_afvf_mbox_up_handler(struct work_struct *work)\n{\n\tstruct rvu_work *mwork = container_of(work, struct rvu_work, work);\n\n\t__rvu_mbox_up_handler(mwork, TYPE_AFVF);\n}\n\nstatic int rvu_get_mbox_regions(struct rvu *rvu, void **mbox_addr,\n\t\t\t\tint num, int type, unsigned long *pf_bmap)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tint region;\n\tu64 bar4;\n\n\t \n\tif (type == TYPE_AFVF) {\n\t\tfor (region = 0; region < num; region++) {\n\t\t\tif (!test_bit(region, pf_bmap))\n\t\t\t\tcontinue;\n\n\t\t\tif (hw->cap.per_pf_mbox_regs) {\n\t\t\t\tbar4 = rvu_read64(rvu, BLKADDR_RVUM,\n\t\t\t\t\t\t  RVU_AF_PFX_BAR4_ADDR(0)) +\n\t\t\t\t\t\t  MBOX_SIZE;\n\t\t\t\tbar4 += region * MBOX_SIZE;\n\t\t\t} else {\n\t\t\t\tbar4 = rvupf_read64(rvu, RVU_PF_VF_BAR4_ADDR);\n\t\t\t\tbar4 += region * MBOX_SIZE;\n\t\t\t}\n\t\t\tmbox_addr[region] = (void *)ioremap_wc(bar4, MBOX_SIZE);\n\t\t\tif (!mbox_addr[region])\n\t\t\t\tgoto error;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tfor (region = 0; region < num; region++) {\n\t\tif (!test_bit(region, pf_bmap))\n\t\t\tcontinue;\n\n\t\tif (hw->cap.per_pf_mbox_regs) {\n\t\t\tbar4 = rvu_read64(rvu, BLKADDR_RVUM,\n\t\t\t\t\t  RVU_AF_PFX_BAR4_ADDR(region));\n\t\t} else {\n\t\t\tbar4 = rvu_read64(rvu, BLKADDR_RVUM,\n\t\t\t\t\t  RVU_AF_PF_BAR4_ADDR);\n\t\t\tbar4 += region * MBOX_SIZE;\n\t\t}\n\t\tmbox_addr[region] = (void *)ioremap_wc(bar4, MBOX_SIZE);\n\t\tif (!mbox_addr[region])\n\t\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\twhile (region--)\n\t\tiounmap((void __iomem *)mbox_addr[region]);\n\treturn -ENOMEM;\n}\n\nstatic int rvu_mbox_init(struct rvu *rvu, struct mbox_wq_info *mw,\n\t\t\t int type, int num,\n\t\t\t void (mbox_handler)(struct work_struct *),\n\t\t\t void (mbox_up_handler)(struct work_struct *))\n{\n\tint err = -EINVAL, i, dir, dir_up;\n\tvoid __iomem *reg_base;\n\tstruct rvu_work *mwork;\n\tunsigned long *pf_bmap;\n\tvoid **mbox_regions;\n\tconst char *name;\n\tu64 cfg;\n\n\tpf_bmap = bitmap_zalloc(num, GFP_KERNEL);\n\tif (!pf_bmap)\n\t\treturn -ENOMEM;\n\n\t \n\tif (type == TYPE_AFVF)\n\t\tbitmap_set(pf_bmap, 0, num);\n\n\tif (type == TYPE_AFPF) {\n\t\t \n\t\tfor (i = 0; i < num; i++) {\n\t\t\tcfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_PFX_CFG(i));\n\t\t\tif (cfg & BIT_ULL(20))\n\t\t\t\tset_bit(i, pf_bmap);\n\t\t}\n\t}\n\n\tmbox_regions = kcalloc(num, sizeof(void *), GFP_KERNEL);\n\tif (!mbox_regions) {\n\t\terr = -ENOMEM;\n\t\tgoto free_bitmap;\n\t}\n\n\tswitch (type) {\n\tcase TYPE_AFPF:\n\t\tname = \"rvu_afpf_mailbox\";\n\t\tdir = MBOX_DIR_AFPF;\n\t\tdir_up = MBOX_DIR_AFPF_UP;\n\t\treg_base = rvu->afreg_base;\n\t\terr = rvu_get_mbox_regions(rvu, mbox_regions, num, TYPE_AFPF, pf_bmap);\n\t\tif (err)\n\t\t\tgoto free_regions;\n\t\tbreak;\n\tcase TYPE_AFVF:\n\t\tname = \"rvu_afvf_mailbox\";\n\t\tdir = MBOX_DIR_PFVF;\n\t\tdir_up = MBOX_DIR_PFVF_UP;\n\t\treg_base = rvu->pfreg_base;\n\t\terr = rvu_get_mbox_regions(rvu, mbox_regions, num, TYPE_AFVF, pf_bmap);\n\t\tif (err)\n\t\t\tgoto free_regions;\n\t\tbreak;\n\tdefault:\n\t\tgoto free_regions;\n\t}\n\n\tmw->mbox_wq = alloc_workqueue(name,\n\t\t\t\t      WQ_UNBOUND | WQ_HIGHPRI | WQ_MEM_RECLAIM,\n\t\t\t\t      num);\n\tif (!mw->mbox_wq) {\n\t\terr = -ENOMEM;\n\t\tgoto unmap_regions;\n\t}\n\n\tmw->mbox_wrk = devm_kcalloc(rvu->dev, num,\n\t\t\t\t    sizeof(struct rvu_work), GFP_KERNEL);\n\tif (!mw->mbox_wrk) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tmw->mbox_wrk_up = devm_kcalloc(rvu->dev, num,\n\t\t\t\t       sizeof(struct rvu_work), GFP_KERNEL);\n\tif (!mw->mbox_wrk_up) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\terr = otx2_mbox_regions_init(&mw->mbox, mbox_regions, rvu->pdev,\n\t\t\t\t     reg_base, dir, num, pf_bmap);\n\tif (err)\n\t\tgoto exit;\n\n\terr = otx2_mbox_regions_init(&mw->mbox_up, mbox_regions, rvu->pdev,\n\t\t\t\t     reg_base, dir_up, num, pf_bmap);\n\tif (err)\n\t\tgoto exit;\n\n\tfor (i = 0; i < num; i++) {\n\t\tif (!test_bit(i, pf_bmap))\n\t\t\tcontinue;\n\n\t\tmwork = &mw->mbox_wrk[i];\n\t\tmwork->rvu = rvu;\n\t\tINIT_WORK(&mwork->work, mbox_handler);\n\n\t\tmwork = &mw->mbox_wrk_up[i];\n\t\tmwork->rvu = rvu;\n\t\tINIT_WORK(&mwork->work, mbox_up_handler);\n\t}\n\tgoto free_regions;\n\nexit:\n\tdestroy_workqueue(mw->mbox_wq);\nunmap_regions:\n\twhile (num--)\n\t\tiounmap((void __iomem *)mbox_regions[num]);\nfree_regions:\n\tkfree(mbox_regions);\nfree_bitmap:\n\tbitmap_free(pf_bmap);\n\treturn err;\n}\n\nstatic void rvu_mbox_destroy(struct mbox_wq_info *mw)\n{\n\tstruct otx2_mbox *mbox = &mw->mbox;\n\tstruct otx2_mbox_dev *mdev;\n\tint devid;\n\n\tif (mw->mbox_wq) {\n\t\tdestroy_workqueue(mw->mbox_wq);\n\t\tmw->mbox_wq = NULL;\n\t}\n\n\tfor (devid = 0; devid < mbox->ndevs; devid++) {\n\t\tmdev = &mbox->dev[devid];\n\t\tif (mdev->hwbase)\n\t\t\tiounmap((void __iomem *)mdev->hwbase);\n\t}\n\n\totx2_mbox_destroy(&mw->mbox);\n\totx2_mbox_destroy(&mw->mbox_up);\n}\n\nstatic void rvu_queue_work(struct mbox_wq_info *mw, int first,\n\t\t\t   int mdevs, u64 intr)\n{\n\tstruct otx2_mbox_dev *mdev;\n\tstruct otx2_mbox *mbox;\n\tstruct mbox_hdr *hdr;\n\tint i;\n\n\tfor (i = first; i < mdevs; i++) {\n\t\t \n\t\tif (!(intr & BIT_ULL(i - first)))\n\t\t\tcontinue;\n\n\t\tmbox = &mw->mbox;\n\t\tmdev = &mbox->dev[i];\n\t\thdr = mdev->mbase + mbox->rx_start;\n\n\t\t \n\n\t\tif (hdr->num_msgs) {\n\t\t\tmw->mbox_wrk[i].num_msgs = hdr->num_msgs;\n\t\t\thdr->num_msgs = 0;\n\t\t\tqueue_work(mw->mbox_wq, &mw->mbox_wrk[i].work);\n\t\t}\n\t\tmbox = &mw->mbox_up;\n\t\tmdev = &mbox->dev[i];\n\t\thdr = mdev->mbase + mbox->rx_start;\n\t\tif (hdr->num_msgs) {\n\t\t\tmw->mbox_wrk_up[i].up_num_msgs = hdr->num_msgs;\n\t\t\thdr->num_msgs = 0;\n\t\t\tqueue_work(mw->mbox_wq, &mw->mbox_wrk_up[i].work);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t rvu_mbox_intr_handler(int irq, void *rvu_irq)\n{\n\tstruct rvu *rvu = (struct rvu *)rvu_irq;\n\tint vfs = rvu->vfs;\n\tu64 intr;\n\n\tintr = rvu_read64(rvu, BLKADDR_RVUM, RVU_AF_PFAF_MBOX_INT);\n\t \n\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_PFAF_MBOX_INT, intr);\n\tif (intr)\n\t\ttrace_otx2_msg_interrupt(rvu->pdev, \"PF(s) to AF\", intr);\n\n\t \n\trmb();\n\n\trvu_queue_work(&rvu->afpf_wq_info, 0, rvu->hw->total_pfs, intr);\n\n\t \n\tif (vfs > 64) {\n\t\tintr = rvupf_read64(rvu, RVU_PF_VFPF_MBOX_INTX(1));\n\t\trvupf_write64(rvu, RVU_PF_VFPF_MBOX_INTX(1), intr);\n\n\t\trvu_queue_work(&rvu->afvf_wq_info, 64, vfs, intr);\n\t\tvfs -= 64;\n\t}\n\n\tintr = rvupf_read64(rvu, RVU_PF_VFPF_MBOX_INTX(0));\n\trvupf_write64(rvu, RVU_PF_VFPF_MBOX_INTX(0), intr);\n\tif (intr)\n\t\ttrace_otx2_msg_interrupt(rvu->pdev, \"VF(s) to AF\", intr);\n\n\trvu_queue_work(&rvu->afvf_wq_info, 0, vfs, intr);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rvu_enable_mbox_intr(struct rvu *rvu)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\n\t \n\trvu_write64(rvu, BLKADDR_RVUM,\n\t\t    RVU_AF_PFAF_MBOX_INT, INTR_MASK(hw->total_pfs));\n\n\t \n\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_PFAF_MBOX_INT_ENA_W1S,\n\t\t    INTR_MASK(hw->total_pfs) & ~1ULL);\n}\n\nstatic void rvu_blklf_teardown(struct rvu *rvu, u16 pcifunc, u8 blkaddr)\n{\n\tstruct rvu_block *block;\n\tint slot, lf, num_lfs;\n\tint err;\n\n\tblock = &rvu->hw->block[blkaddr];\n\tnum_lfs = rvu_get_rsrc_mapcount(rvu_get_pfvf(rvu, pcifunc),\n\t\t\t\t\tblock->addr);\n\tif (!num_lfs)\n\t\treturn;\n\tfor (slot = 0; slot < num_lfs; slot++) {\n\t\tlf = rvu_get_lf(rvu, block, pcifunc, slot);\n\t\tif (lf < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (block->addr == BLKADDR_NIX0 || block->addr == BLKADDR_NIX1)\n\t\t\trvu_nix_lf_teardown(rvu, pcifunc, block->addr, lf);\n\t\telse if (block->addr == BLKADDR_NPA)\n\t\t\trvu_npa_lf_teardown(rvu, pcifunc, lf);\n\t\telse if ((block->addr == BLKADDR_CPT0) ||\n\t\t\t (block->addr == BLKADDR_CPT1))\n\t\t\trvu_cpt_lf_teardown(rvu, pcifunc, block->addr, lf,\n\t\t\t\t\t    slot);\n\n\t\terr = rvu_lf_reset(rvu, block, lf);\n\t\tif (err) {\n\t\t\tdev_err(rvu->dev, \"Failed to reset blkaddr %d LF%d\\n\",\n\t\t\t\tblock->addr, lf);\n\t\t}\n\t}\n}\n\nstatic void __rvu_flr_handler(struct rvu *rvu, u16 pcifunc)\n{\n\tif (rvu_npc_exact_has_match_table(rvu))\n\t\trvu_npc_exact_reset(rvu, pcifunc);\n\n\tmutex_lock(&rvu->flr_lock);\n\t \n\trvu_blklf_teardown(rvu, pcifunc, BLKADDR_NIX0);\n\trvu_blklf_teardown(rvu, pcifunc, BLKADDR_NIX1);\n\trvu_blklf_teardown(rvu, pcifunc, BLKADDR_CPT0);\n\trvu_blklf_teardown(rvu, pcifunc, BLKADDR_CPT1);\n\trvu_blklf_teardown(rvu, pcifunc, BLKADDR_TIM);\n\trvu_blklf_teardown(rvu, pcifunc, BLKADDR_SSOW);\n\trvu_blklf_teardown(rvu, pcifunc, BLKADDR_SSO);\n\trvu_blklf_teardown(rvu, pcifunc, BLKADDR_NPA);\n\trvu_reset_lmt_map_tbl(rvu, pcifunc);\n\trvu_detach_rsrcs(rvu, NULL, pcifunc);\n\t \n\trvu_npc_free_mcam_entries(rvu, pcifunc, -1);\n\trvu_mac_reset(rvu, pcifunc);\n\n\tif (rvu->mcs_blk_cnt)\n\t\trvu_mcs_flr_handler(rvu, pcifunc);\n\n\tmutex_unlock(&rvu->flr_lock);\n}\n\nstatic void rvu_afvf_flr_handler(struct rvu *rvu, int vf)\n{\n\tint reg = 0;\n\n\t \n\t__rvu_flr_handler(rvu, vf + 1);\n\n\tif (vf >= 64) {\n\t\treg = 1;\n\t\tvf = vf - 64;\n\t}\n\n\t \n\trvupf_write64(rvu, RVU_PF_VFTRPENDX(reg), BIT_ULL(vf));\n\trvupf_write64(rvu, RVU_PF_VFFLR_INT_ENA_W1SX(reg), BIT_ULL(vf));\n}\n\nstatic void rvu_flr_handler(struct work_struct *work)\n{\n\tstruct rvu_work *flrwork = container_of(work, struct rvu_work, work);\n\tstruct rvu *rvu = flrwork->rvu;\n\tu16 pcifunc, numvfs, vf;\n\tu64 cfg;\n\tint pf;\n\n\tpf = flrwork - rvu->flr_wrk;\n\tif (pf >= rvu->hw->total_pfs) {\n\t\trvu_afvf_flr_handler(rvu, pf - rvu->hw->total_pfs);\n\t\treturn;\n\t}\n\n\tcfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_PFX_CFG(pf));\n\tnumvfs = (cfg >> 12) & 0xFF;\n\tpcifunc  = pf << RVU_PFVF_PF_SHIFT;\n\n\tfor (vf = 0; vf < numvfs; vf++)\n\t\t__rvu_flr_handler(rvu, (pcifunc | (vf + 1)));\n\n\t__rvu_flr_handler(rvu, pcifunc);\n\n\t \n\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_PFTRPEND, BIT_ULL(pf));\n\n\t \n\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_PFFLR_INT_ENA_W1S,  BIT_ULL(pf));\n}\n\nstatic void rvu_afvf_queue_flr_work(struct rvu *rvu, int start_vf, int numvfs)\n{\n\tint dev, vf, reg = 0;\n\tu64 intr;\n\n\tif (start_vf >= 64)\n\t\treg = 1;\n\n\tintr = rvupf_read64(rvu, RVU_PF_VFFLR_INTX(reg));\n\tif (!intr)\n\t\treturn;\n\n\tfor (vf = 0; vf < numvfs; vf++) {\n\t\tif (!(intr & BIT_ULL(vf)))\n\t\t\tcontinue;\n\t\t \n\t\trvupf_write64(rvu, RVU_PF_VFFLR_INTX(reg), BIT_ULL(vf));\n\t\trvupf_write64(rvu, RVU_PF_VFFLR_INT_ENA_W1CX(reg), BIT_ULL(vf));\n\n\t\tdev = vf + start_vf + rvu->hw->total_pfs;\n\t\tqueue_work(rvu->flr_wq, &rvu->flr_wrk[dev].work);\n\t}\n}\n\nstatic irqreturn_t rvu_flr_intr_handler(int irq, void *rvu_irq)\n{\n\tstruct rvu *rvu = (struct rvu *)rvu_irq;\n\tu64 intr;\n\tu8  pf;\n\n\tintr = rvu_read64(rvu, BLKADDR_RVUM, RVU_AF_PFFLR_INT);\n\tif (!intr)\n\t\tgoto afvf_flr;\n\n\tfor (pf = 0; pf < rvu->hw->total_pfs; pf++) {\n\t\tif (intr & (1ULL << pf)) {\n\t\t\t \n\t\t\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_PFFLR_INT,\n\t\t\t\t    BIT_ULL(pf));\n\t\t\t \n\t\t\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_PFFLR_INT_ENA_W1C,\n\t\t\t\t    BIT_ULL(pf));\n\t\t\t \n\t\t\tqueue_work(rvu->flr_wq, &rvu->flr_wrk[pf].work);\n\t\t}\n\t}\n\nafvf_flr:\n\trvu_afvf_queue_flr_work(rvu, 0, 64);\n\tif (rvu->vfs > 64)\n\t\trvu_afvf_queue_flr_work(rvu, 64, rvu->vfs - 64);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rvu_me_handle_vfset(struct rvu *rvu, int idx, u64 intr)\n{\n\tint vf;\n\n\t \n\tfor (vf = 0; vf < 64; vf++) {\n\t\tif (intr & (1ULL << vf)) {\n\t\t\t \n\t\t\trvupf_write64(rvu, RVU_PF_VFTRPENDX(idx), BIT_ULL(vf));\n\t\t\t \n\t\t\trvupf_write64(rvu, RVU_PF_VFME_INTX(idx), BIT_ULL(vf));\n\t\t}\n\t}\n}\n\n \nstatic irqreturn_t rvu_me_vf_intr_handler(int irq, void *rvu_irq)\n{\n\tstruct rvu *rvu = (struct rvu *)rvu_irq;\n\tint vfset;\n\tu64 intr;\n\n\tintr = rvu_read64(rvu, BLKADDR_RVUM, RVU_AF_PFME_INT);\n\n\tfor (vfset = 0; vfset <= 1; vfset++) {\n\t\tintr = rvupf_read64(rvu, RVU_PF_VFME_INTX(vfset));\n\t\tif (intr)\n\t\t\trvu_me_handle_vfset(rvu, vfset, intr);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t rvu_me_pf_intr_handler(int irq, void *rvu_irq)\n{\n\tstruct rvu *rvu = (struct rvu *)rvu_irq;\n\tu64 intr;\n\tu8  pf;\n\n\tintr = rvu_read64(rvu, BLKADDR_RVUM, RVU_AF_PFME_INT);\n\n\t \n\tfor (pf = 0; pf < rvu->hw->total_pfs; pf++) {\n\t\tif (intr & (1ULL << pf)) {\n\t\t\t \n\t\t\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_PFTRPEND,\n\t\t\t\t    BIT_ULL(pf));\n\t\t\t \n\t\t\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_PFME_INT,\n\t\t\t\t    BIT_ULL(pf));\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rvu_unregister_interrupts(struct rvu *rvu)\n{\n\tint irq;\n\n\trvu_cpt_unregister_interrupts(rvu);\n\n\t \n\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_PFAF_MBOX_INT_ENA_W1C,\n\t\t    INTR_MASK(rvu->hw->total_pfs) & ~1ULL);\n\n\t \n\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_PFFLR_INT_ENA_W1C,\n\t\t    INTR_MASK(rvu->hw->total_pfs) & ~1ULL);\n\n\t \n\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_PFME_INT_ENA_W1C,\n\t\t    INTR_MASK(rvu->hw->total_pfs) & ~1ULL);\n\n\tfor (irq = 0; irq < rvu->num_vec; irq++) {\n\t\tif (rvu->irq_allocated[irq]) {\n\t\t\tfree_irq(pci_irq_vector(rvu->pdev, irq), rvu);\n\t\t\trvu->irq_allocated[irq] = false;\n\t\t}\n\t}\n\n\tpci_free_irq_vectors(rvu->pdev);\n\trvu->num_vec = 0;\n}\n\nstatic int rvu_afvf_msix_vectors_num_ok(struct rvu *rvu)\n{\n\tstruct rvu_pfvf *pfvf = &rvu->pf[0];\n\tint offset;\n\n\tpfvf = &rvu->pf[0];\n\toffset = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_PFX_INT_CFG(0)) & 0x3ff;\n\n\t \n\treturn (pfvf->msix.max >= RVU_AF_INT_VEC_CNT + RVU_PF_INT_VEC_CNT) &&\n\t       offset;\n}\n\nstatic int rvu_register_interrupts(struct rvu *rvu)\n{\n\tint ret, offset, pf_vec_start;\n\n\trvu->num_vec = pci_msix_vec_count(rvu->pdev);\n\n\trvu->irq_name = devm_kmalloc_array(rvu->dev, rvu->num_vec,\n\t\t\t\t\t   NAME_SIZE, GFP_KERNEL);\n\tif (!rvu->irq_name)\n\t\treturn -ENOMEM;\n\n\trvu->irq_allocated = devm_kcalloc(rvu->dev, rvu->num_vec,\n\t\t\t\t\t  sizeof(bool), GFP_KERNEL);\n\tif (!rvu->irq_allocated)\n\t\treturn -ENOMEM;\n\n\t \n\tret = pci_alloc_irq_vectors(rvu->pdev, rvu->num_vec,\n\t\t\t\t    rvu->num_vec, PCI_IRQ_MSIX);\n\tif (ret < 0) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"RVUAF: Request for %d msix vectors failed, ret %d\\n\",\n\t\t\trvu->num_vec, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tsprintf(&rvu->irq_name[RVU_AF_INT_VEC_MBOX * NAME_SIZE], \"RVUAF Mbox\");\n\tret = request_irq(pci_irq_vector(rvu->pdev, RVU_AF_INT_VEC_MBOX),\n\t\t\t  rvu_mbox_intr_handler, 0,\n\t\t\t  &rvu->irq_name[RVU_AF_INT_VEC_MBOX * NAME_SIZE], rvu);\n\tif (ret) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"RVUAF: IRQ registration failed for mbox irq\\n\");\n\t\tgoto fail;\n\t}\n\n\trvu->irq_allocated[RVU_AF_INT_VEC_MBOX] = true;\n\n\t \n\trvu_enable_mbox_intr(rvu);\n\n\t \n\tsprintf(&rvu->irq_name[RVU_AF_INT_VEC_PFFLR * NAME_SIZE],\n\t\t\"RVUAF FLR\");\n\tret = request_irq(pci_irq_vector(rvu->pdev, RVU_AF_INT_VEC_PFFLR),\n\t\t\t  rvu_flr_intr_handler, 0,\n\t\t\t  &rvu->irq_name[RVU_AF_INT_VEC_PFFLR * NAME_SIZE],\n\t\t\t  rvu);\n\tif (ret) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"RVUAF: IRQ registration failed for FLR\\n\");\n\t\tgoto fail;\n\t}\n\trvu->irq_allocated[RVU_AF_INT_VEC_PFFLR] = true;\n\n\t \n\trvu_write64(rvu, BLKADDR_RVUM,\n\t\t    RVU_AF_PFFLR_INT, INTR_MASK(rvu->hw->total_pfs));\n\n\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_PFFLR_INT_ENA_W1S,\n\t\t    INTR_MASK(rvu->hw->total_pfs) & ~1ULL);\n\n\t \n\tsprintf(&rvu->irq_name[RVU_AF_INT_VEC_PFME * NAME_SIZE],\n\t\t\"RVUAF ME\");\n\tret = request_irq(pci_irq_vector(rvu->pdev, RVU_AF_INT_VEC_PFME),\n\t\t\t  rvu_me_pf_intr_handler, 0,\n\t\t\t  &rvu->irq_name[RVU_AF_INT_VEC_PFME * NAME_SIZE],\n\t\t\t  rvu);\n\tif (ret) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"RVUAF: IRQ registration failed for ME\\n\");\n\t}\n\trvu->irq_allocated[RVU_AF_INT_VEC_PFME] = true;\n\n\t \n\trvu_write64(rvu, BLKADDR_RVUM,\n\t\t    RVU_AF_PFTRPEND, INTR_MASK(rvu->hw->total_pfs));\n\t \n\trvu_write64(rvu, BLKADDR_RVUM,\n\t\t    RVU_AF_PFME_INT, INTR_MASK(rvu->hw->total_pfs));\n\n\trvu_write64(rvu, BLKADDR_RVUM, RVU_AF_PFME_INT_ENA_W1S,\n\t\t    INTR_MASK(rvu->hw->total_pfs) & ~1ULL);\n\n\tif (!rvu_afvf_msix_vectors_num_ok(rvu))\n\t\treturn 0;\n\n\t \n\tpf_vec_start = rvu_read64(rvu, BLKADDR_RVUM,\n\t\t\t\t  RVU_PRIV_PFX_INT_CFG(0)) & 0x3ff;\n\n\t \n\toffset = pf_vec_start + RVU_PF_INT_VEC_VFPF_MBOX0;\n\tsprintf(&rvu->irq_name[offset * NAME_SIZE], \"RVUAFVF Mbox0\");\n\tret = request_irq(pci_irq_vector(rvu->pdev, offset),\n\t\t\t  rvu_mbox_intr_handler, 0,\n\t\t\t  &rvu->irq_name[offset * NAME_SIZE],\n\t\t\t  rvu);\n\tif (ret)\n\t\tdev_err(rvu->dev,\n\t\t\t\"RVUAF: IRQ registration failed for Mbox0\\n\");\n\n\trvu->irq_allocated[offset] = true;\n\n\t \n\toffset = pf_vec_start + RVU_PF_INT_VEC_VFPF_MBOX1;\n\tsprintf(&rvu->irq_name[offset * NAME_SIZE], \"RVUAFVF Mbox1\");\n\tret = request_irq(pci_irq_vector(rvu->pdev, offset),\n\t\t\t  rvu_mbox_intr_handler, 0,\n\t\t\t  &rvu->irq_name[offset * NAME_SIZE],\n\t\t\t  rvu);\n\tif (ret)\n\t\tdev_err(rvu->dev,\n\t\t\t\"RVUAF: IRQ registration failed for Mbox1\\n\");\n\n\trvu->irq_allocated[offset] = true;\n\n\t \n\toffset = pf_vec_start + RVU_PF_INT_VEC_VFFLR0;\n\tsprintf(&rvu->irq_name[offset * NAME_SIZE], \"RVUAFVF FLR0\");\n\tret = request_irq(pci_irq_vector(rvu->pdev, offset),\n\t\t\t  rvu_flr_intr_handler, 0,\n\t\t\t  &rvu->irq_name[offset * NAME_SIZE], rvu);\n\tif (ret) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"RVUAF: IRQ registration failed for RVUAFVF FLR0\\n\");\n\t\tgoto fail;\n\t}\n\trvu->irq_allocated[offset] = true;\n\n\toffset = pf_vec_start + RVU_PF_INT_VEC_VFFLR1;\n\tsprintf(&rvu->irq_name[offset * NAME_SIZE], \"RVUAFVF FLR1\");\n\tret = request_irq(pci_irq_vector(rvu->pdev, offset),\n\t\t\t  rvu_flr_intr_handler, 0,\n\t\t\t  &rvu->irq_name[offset * NAME_SIZE], rvu);\n\tif (ret) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"RVUAF: IRQ registration failed for RVUAFVF FLR1\\n\");\n\t\tgoto fail;\n\t}\n\trvu->irq_allocated[offset] = true;\n\n\t \n\toffset = pf_vec_start + RVU_PF_INT_VEC_VFME0;\n\tsprintf(&rvu->irq_name[offset * NAME_SIZE], \"RVUAFVF ME0\");\n\tret = request_irq(pci_irq_vector(rvu->pdev, offset),\n\t\t\t  rvu_me_vf_intr_handler, 0,\n\t\t\t  &rvu->irq_name[offset * NAME_SIZE], rvu);\n\tif (ret) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"RVUAF: IRQ registration failed for RVUAFVF ME0\\n\");\n\t\tgoto fail;\n\t}\n\trvu->irq_allocated[offset] = true;\n\n\toffset = pf_vec_start + RVU_PF_INT_VEC_VFME1;\n\tsprintf(&rvu->irq_name[offset * NAME_SIZE], \"RVUAFVF ME1\");\n\tret = request_irq(pci_irq_vector(rvu->pdev, offset),\n\t\t\t  rvu_me_vf_intr_handler, 0,\n\t\t\t  &rvu->irq_name[offset * NAME_SIZE], rvu);\n\tif (ret) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"RVUAF: IRQ registration failed for RVUAFVF ME1\\n\");\n\t\tgoto fail;\n\t}\n\trvu->irq_allocated[offset] = true;\n\n\tret = rvu_cpt_register_interrupts(rvu);\n\tif (ret)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\trvu_unregister_interrupts(rvu);\n\treturn ret;\n}\n\nstatic void rvu_flr_wq_destroy(struct rvu *rvu)\n{\n\tif (rvu->flr_wq) {\n\t\tdestroy_workqueue(rvu->flr_wq);\n\t\trvu->flr_wq = NULL;\n\t}\n}\n\nstatic int rvu_flr_init(struct rvu *rvu)\n{\n\tint dev, num_devs;\n\tu64 cfg;\n\tint pf;\n\n\t \n\tfor (pf = 0; pf < rvu->hw->total_pfs; pf++) {\n\t\tcfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_PFX_CFG(pf));\n\t\trvu_write64(rvu, BLKADDR_RVUM, RVU_PRIV_PFX_CFG(pf),\n\t\t\t    cfg | BIT_ULL(22));\n\t}\n\n\trvu->flr_wq = alloc_ordered_workqueue(\"rvu_afpf_flr\",\n\t\t\t\t\t      WQ_HIGHPRI | WQ_MEM_RECLAIM);\n\tif (!rvu->flr_wq)\n\t\treturn -ENOMEM;\n\n\tnum_devs = rvu->hw->total_pfs + pci_sriov_get_totalvfs(rvu->pdev);\n\trvu->flr_wrk = devm_kcalloc(rvu->dev, num_devs,\n\t\t\t\t    sizeof(struct rvu_work), GFP_KERNEL);\n\tif (!rvu->flr_wrk) {\n\t\tdestroy_workqueue(rvu->flr_wq);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (dev = 0; dev < num_devs; dev++) {\n\t\trvu->flr_wrk[dev].rvu = rvu;\n\t\tINIT_WORK(&rvu->flr_wrk[dev].work, rvu_flr_handler);\n\t}\n\n\tmutex_init(&rvu->flr_lock);\n\n\treturn 0;\n}\n\nstatic void rvu_disable_afvf_intr(struct rvu *rvu)\n{\n\tint vfs = rvu->vfs;\n\n\trvupf_write64(rvu, RVU_PF_VFPF_MBOX_INT_ENA_W1CX(0), INTR_MASK(vfs));\n\trvupf_write64(rvu, RVU_PF_VFFLR_INT_ENA_W1CX(0), INTR_MASK(vfs));\n\trvupf_write64(rvu, RVU_PF_VFME_INT_ENA_W1CX(0), INTR_MASK(vfs));\n\tif (vfs <= 64)\n\t\treturn;\n\n\trvupf_write64(rvu, RVU_PF_VFPF_MBOX_INT_ENA_W1CX(1),\n\t\t      INTR_MASK(vfs - 64));\n\trvupf_write64(rvu, RVU_PF_VFFLR_INT_ENA_W1CX(1), INTR_MASK(vfs - 64));\n\trvupf_write64(rvu, RVU_PF_VFME_INT_ENA_W1CX(1), INTR_MASK(vfs - 64));\n}\n\nstatic void rvu_enable_afvf_intr(struct rvu *rvu)\n{\n\tint vfs = rvu->vfs;\n\n\t \n\t \n\trvupf_write64(rvu, RVU_PF_VFPF_MBOX_INTX(0), INTR_MASK(vfs));\n\trvupf_write64(rvu, RVU_PF_VFPF_MBOX_INT_ENA_W1SX(0), INTR_MASK(vfs));\n\n\t \n\trvupf_write64(rvu, RVU_PF_VFFLR_INTX(0), INTR_MASK(vfs));\n\trvupf_write64(rvu, RVU_PF_VFFLR_INT_ENA_W1SX(0), INTR_MASK(vfs));\n\trvupf_write64(rvu, RVU_PF_VFME_INT_ENA_W1SX(0), INTR_MASK(vfs));\n\n\t \n\tif (vfs <= 64)\n\t\treturn;\n\n\trvupf_write64(rvu, RVU_PF_VFPF_MBOX_INTX(1), INTR_MASK(vfs - 64));\n\trvupf_write64(rvu, RVU_PF_VFPF_MBOX_INT_ENA_W1SX(1),\n\t\t      INTR_MASK(vfs - 64));\n\n\trvupf_write64(rvu, RVU_PF_VFFLR_INTX(1), INTR_MASK(vfs - 64));\n\trvupf_write64(rvu, RVU_PF_VFFLR_INT_ENA_W1SX(1), INTR_MASK(vfs - 64));\n\trvupf_write64(rvu, RVU_PF_VFME_INT_ENA_W1SX(1), INTR_MASK(vfs - 64));\n}\n\nint rvu_get_num_lbk_chans(void)\n{\n\tstruct pci_dev *pdev;\n\tvoid __iomem *base;\n\tint ret = -EIO;\n\n\tpdev = pci_get_device(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_OCTEONTX2_LBK,\n\t\t\t      NULL);\n\tif (!pdev)\n\t\tgoto err;\n\n\tbase = pci_ioremap_bar(pdev, 0);\n\tif (!base)\n\t\tgoto err_put;\n\n\t \n\tret = (readq(base + 0x10) >> 32) & 0xffff;\n\tiounmap(base);\nerr_put:\n\tpci_dev_put(pdev);\nerr:\n\treturn ret;\n}\n\nstatic int rvu_enable_sriov(struct rvu *rvu)\n{\n\tstruct pci_dev *pdev = rvu->pdev;\n\tint err, chans, vfs;\n\n\tif (!rvu_afvf_msix_vectors_num_ok(rvu)) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Skipping SRIOV enablement since not enough IRQs are available\\n\");\n\t\treturn 0;\n\t}\n\n\tchans = rvu_get_num_lbk_chans();\n\tif (chans < 0)\n\t\treturn chans;\n\n\tvfs = pci_sriov_get_totalvfs(pdev);\n\n\t \n\tif (vfs > chans)\n\t\tvfs = chans;\n\n\tif (!vfs)\n\t\treturn 0;\n\n\t \n\tif (vfs > 62)\n\t\tvfs = 62;\n\n\t \n\trvu->vfs = vfs;\n\n\terr = rvu_mbox_init(rvu, &rvu->afvf_wq_info, TYPE_AFVF, vfs,\n\t\t\t    rvu_afvf_mbox_handler, rvu_afvf_mbox_up_handler);\n\tif (err)\n\t\treturn err;\n\n\trvu_enable_afvf_intr(rvu);\n\t \n\tmb();\n\n\terr = pci_enable_sriov(pdev, vfs);\n\tif (err) {\n\t\trvu_disable_afvf_intr(rvu);\n\t\trvu_mbox_destroy(&rvu->afvf_wq_info);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void rvu_disable_sriov(struct rvu *rvu)\n{\n\trvu_disable_afvf_intr(rvu);\n\trvu_mbox_destroy(&rvu->afvf_wq_info);\n\tpci_disable_sriov(rvu->pdev);\n}\n\nstatic void rvu_update_module_params(struct rvu *rvu)\n{\n\tconst char *default_pfl_name = \"default\";\n\n\tstrscpy(rvu->mkex_pfl_name,\n\t\tmkex_profile ? mkex_profile : default_pfl_name, MKEX_NAME_LEN);\n\tstrscpy(rvu->kpu_pfl_name,\n\t\tkpu_profile ? kpu_profile : default_pfl_name, KPU_NAME_LEN);\n}\n\nstatic int rvu_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rvu *rvu;\n\tint    err;\n\n\trvu = devm_kzalloc(dev, sizeof(*rvu), GFP_KERNEL);\n\tif (!rvu)\n\t\treturn -ENOMEM;\n\n\trvu->hw = devm_kzalloc(dev, sizeof(struct rvu_hwinfo), GFP_KERNEL);\n\tif (!rvu->hw) {\n\t\tdevm_kfree(dev, rvu);\n\t\treturn -ENOMEM;\n\t}\n\n\tpci_set_drvdata(pdev, rvu);\n\trvu->pdev = pdev;\n\trvu->dev = &pdev->dev;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to enable PCI device\\n\");\n\t\tgoto err_freemem;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err) {\n\t\tdev_err(dev, \"PCI request regions failed 0x%x\\n\", err);\n\t\tgoto err_disable_device;\n\t}\n\n\terr = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(48));\n\tif (err) {\n\t\tdev_err(dev, \"DMA mask config failed, abort\\n\");\n\t\tgoto err_release_regions;\n\t}\n\n\tpci_set_master(pdev);\n\n\trvu->ptp = ptp_get();\n\tif (IS_ERR(rvu->ptp)) {\n\t\terr = PTR_ERR(rvu->ptp);\n\t\tif (err)\n\t\t\tgoto err_release_regions;\n\t\trvu->ptp = NULL;\n\t}\n\n\t \n\trvu->afreg_base = pcim_iomap(pdev, PCI_AF_REG_BAR_NUM, 0);\n\trvu->pfreg_base = pcim_iomap(pdev, PCI_PF_REG_BAR_NUM, 0);\n\tif (!rvu->afreg_base || !rvu->pfreg_base) {\n\t\tdev_err(dev, \"Unable to map admin function CSRs, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_put_ptp;\n\t}\n\n\t \n\trvu_update_module_params(rvu);\n\n\t \n\trvu_check_block_implemented(rvu);\n\n\trvu_reset_all_blocks(rvu);\n\n\trvu_setup_hw_capabilities(rvu);\n\n\terr = rvu_setup_hw_resources(rvu);\n\tif (err)\n\t\tgoto err_put_ptp;\n\n\t \n\terr = rvu_mbox_init(rvu, &rvu->afpf_wq_info, TYPE_AFPF,\n\t\t\t    rvu->hw->total_pfs, rvu_afpf_mbox_handler,\n\t\t\t    rvu_afpf_mbox_up_handler);\n\tif (err) {\n\t\tdev_err(dev, \"%s: Failed to initialize mbox\\n\", __func__);\n\t\tgoto err_hwsetup;\n\t}\n\n\terr = rvu_flr_init(rvu);\n\tif (err) {\n\t\tdev_err(dev, \"%s: Failed to initialize flr\\n\", __func__);\n\t\tgoto err_mbox;\n\t}\n\n\terr = rvu_register_interrupts(rvu);\n\tif (err) {\n\t\tdev_err(dev, \"%s: Failed to register interrupts\\n\", __func__);\n\t\tgoto err_flr;\n\t}\n\n\terr = rvu_register_dl(rvu);\n\tif (err) {\n\t\tdev_err(dev, \"%s: Failed to register devlink\\n\", __func__);\n\t\tgoto err_irq;\n\t}\n\n\trvu_setup_rvum_blk_revid(rvu);\n\n\t \n\terr = rvu_enable_sriov(rvu);\n\tif (err) {\n\t\tdev_err(dev, \"%s: Failed to enable sriov\\n\", __func__);\n\t\tgoto err_dl;\n\t}\n\n\t \n\trvu_dbg_init(rvu);\n\n\tmutex_init(&rvu->rswitch.switch_lock);\n\n\tif (rvu->fwdata)\n\t\tptp_start(rvu, rvu->fwdata->sclk, rvu->fwdata->ptp_ext_clk_rate,\n\t\t\t  rvu->fwdata->ptp_ext_tstamp);\n\n\treturn 0;\nerr_dl:\n\trvu_unregister_dl(rvu);\nerr_irq:\n\trvu_unregister_interrupts(rvu);\nerr_flr:\n\trvu_flr_wq_destroy(rvu);\nerr_mbox:\n\trvu_mbox_destroy(&rvu->afpf_wq_info);\nerr_hwsetup:\n\trvu_cgx_exit(rvu);\n\trvu_fwdata_exit(rvu);\n\trvu_mcs_exit(rvu);\n\trvu_reset_all_blocks(rvu);\n\trvu_free_hw_resources(rvu);\n\trvu_clear_rvum_blk_revid(rvu);\nerr_put_ptp:\n\tptp_put(rvu->ptp);\nerr_release_regions:\n\tpci_release_regions(pdev);\nerr_disable_device:\n\tpci_disable_device(pdev);\nerr_freemem:\n\tpci_set_drvdata(pdev, NULL);\n\tdevm_kfree(&pdev->dev, rvu->hw);\n\tdevm_kfree(dev, rvu);\n\treturn err;\n}\n\nstatic void rvu_remove(struct pci_dev *pdev)\n{\n\tstruct rvu *rvu = pci_get_drvdata(pdev);\n\n\trvu_dbg_exit(rvu);\n\trvu_unregister_dl(rvu);\n\trvu_unregister_interrupts(rvu);\n\trvu_flr_wq_destroy(rvu);\n\trvu_cgx_exit(rvu);\n\trvu_fwdata_exit(rvu);\n\trvu_mcs_exit(rvu);\n\trvu_mbox_destroy(&rvu->afpf_wq_info);\n\trvu_disable_sriov(rvu);\n\trvu_reset_all_blocks(rvu);\n\trvu_free_hw_resources(rvu);\n\trvu_clear_rvum_blk_revid(rvu);\n\tptp_put(rvu->ptp);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_drvdata(pdev, NULL);\n\n\tdevm_kfree(&pdev->dev, rvu->hw);\n\tdevm_kfree(&pdev->dev, rvu);\n}\n\nstatic struct pci_driver rvu_driver = {\n\t.name = DRV_NAME,\n\t.id_table = rvu_id_table,\n\t.probe = rvu_probe,\n\t.remove = rvu_remove,\n};\n\nstatic int __init rvu_init_module(void)\n{\n\tint err;\n\n\tpr_info(\"%s: %s\\n\", DRV_NAME, DRV_STRING);\n\n\terr = pci_register_driver(&cgx_driver);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = pci_register_driver(&ptp_driver);\n\tif (err < 0)\n\t\tgoto ptp_err;\n\n\terr = pci_register_driver(&mcs_driver);\n\tif (err < 0)\n\t\tgoto mcs_err;\n\n\terr =  pci_register_driver(&rvu_driver);\n\tif (err < 0)\n\t\tgoto rvu_err;\n\n\treturn 0;\nrvu_err:\n\tpci_unregister_driver(&mcs_driver);\nmcs_err:\n\tpci_unregister_driver(&ptp_driver);\nptp_err:\n\tpci_unregister_driver(&cgx_driver);\n\n\treturn err;\n}\n\nstatic void __exit rvu_cleanup_module(void)\n{\n\tpci_unregister_driver(&rvu_driver);\n\tpci_unregister_driver(&mcs_driver);\n\tpci_unregister_driver(&ptp_driver);\n\tpci_unregister_driver(&cgx_driver);\n}\n\nmodule_init(rvu_init_module);\nmodule_exit(rvu_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}