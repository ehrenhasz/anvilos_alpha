{
  "module_name": "rvu_switch.c",
  "hash_id": "fb13a1f4084c3082f7b8f2e00e0d8f44c8eb19896c7f68ef1394307f1a87ce28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/af/rvu_switch.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include \"rvu.h\"\n\nstatic void rvu_switch_enable_lbk_link(struct rvu *rvu, u16 pcifunc, bool enable)\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, pcifunc);\n\tstruct nix_hw *nix_hw;\n\n\tnix_hw = get_nix_hw(rvu->hw, pfvf->nix_blkaddr);\n\t \n\trvu_nix_tx_tl2_cfg(rvu, pfvf->nix_blkaddr, pcifunc,\n\t\t\t   &nix_hw->txsch[NIX_TXSCH_LVL_TL2], enable);\n}\n\nstatic int rvu_switch_install_rx_rule(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t      u16 chan_mask)\n{\n\tstruct npc_install_flow_req req = { 0 };\n\tstruct npc_install_flow_rsp rsp = { 0 };\n\tstruct rvu_pfvf *pfvf;\n\n\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\t \n\tif (!test_bit(NIXLF_INITIALIZED, &pfvf->flags))\n\t\treturn 0;\n\n\tether_addr_copy(req.packet.dmac, pfvf->mac_addr);\n\teth_broadcast_addr((u8 *)&req.mask.dmac);\n\treq.hdr.pcifunc = 0;  \n\treq.vf = pcifunc;\n\treq.features = BIT_ULL(NPC_DMAC);\n\treq.channel = pfvf->rx_chan_base;\n\treq.chan_mask = chan_mask;\n\treq.intf = pfvf->nix_rx_intf;\n\treq.op = NIX_RX_ACTION_DEFAULT;\n\treq.default_rule = 1;\n\n\treturn rvu_mbox_handler_npc_install_flow(rvu, &req, &rsp);\n}\n\nstatic int rvu_switch_install_tx_rule(struct rvu *rvu, u16 pcifunc, u16 entry)\n{\n\tstruct npc_install_flow_req req = { 0 };\n\tstruct npc_install_flow_rsp rsp = { 0 };\n\tstruct rvu_pfvf *pfvf;\n\tu8 lbkid;\n\n\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\t \n\tif (!test_bit(NIXLF_INITIALIZED, &pfvf->flags))\n\t\treturn 0;\n\n\trvu_switch_enable_lbk_link(rvu, pcifunc, true);\n\n\tlbkid = pfvf->nix_blkaddr == BLKADDR_NIX0 ? 0 : 1;\n\tether_addr_copy(req.packet.dmac, pfvf->mac_addr);\n\teth_broadcast_addr((u8 *)&req.mask.dmac);\n\treq.hdr.pcifunc = 0;  \n\treq.vf = pcifunc;\n\treq.entry = entry;\n\treq.features = BIT_ULL(NPC_DMAC);\n\treq.intf = pfvf->nix_tx_intf;\n\treq.op = NIX_TX_ACTIONOP_UCAST_CHAN;\n\treq.index = (lbkid << 8) | RVU_SWITCH_LBK_CHAN;\n\treq.set_cntr = 1;\n\n\treturn rvu_mbox_handler_npc_install_flow(rvu, &req, &rsp);\n}\n\nstatic int rvu_switch_install_rules(struct rvu *rvu)\n{\n\tstruct rvu_switch *rswitch = &rvu->rswitch;\n\tu16 start = rswitch->start_entry;\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tu16 pcifunc, entry = 0;\n\tint pf, vf, numvfs;\n\tint err;\n\n\tfor (pf = 1; pf < hw->total_pfs; pf++) {\n\t\tif (!is_pf_cgxmapped(rvu, pf))\n\t\t\tcontinue;\n\n\t\tpcifunc = pf << 10;\n\t\t \n\t\trvu_get_nix_blkaddr(rvu, pcifunc);\n\n\t\t \n\t\terr = rvu_switch_install_rx_rule(rvu, pcifunc, 0x0);\n\t\tif (err) {\n\t\t\tdev_err(rvu->dev, \"RX rule for PF%d failed(%d)\\n\",\n\t\t\t\tpf, err);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = rvu_switch_install_tx_rule(rvu, pcifunc, start + entry);\n\t\tif (err) {\n\t\t\tdev_err(rvu->dev, \"TX rule for PF%d failed(%d)\\n\",\n\t\t\t\tpf, err);\n\t\t\treturn err;\n\t\t}\n\n\t\trswitch->entry2pcifunc[entry++] = pcifunc;\n\n\t\trvu_get_pf_numvfs(rvu, pf, &numvfs, NULL);\n\t\tfor (vf = 0; vf < numvfs; vf++) {\n\t\t\tpcifunc = pf << 10 | ((vf + 1) & 0x3FF);\n\t\t\trvu_get_nix_blkaddr(rvu, pcifunc);\n\n\t\t\terr = rvu_switch_install_rx_rule(rvu, pcifunc, 0x0);\n\t\t\tif (err) {\n\t\t\t\tdev_err(rvu->dev,\n\t\t\t\t\t\"RX rule for PF%dVF%d failed(%d)\\n\",\n\t\t\t\t\tpf, vf, err);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\terr = rvu_switch_install_tx_rule(rvu, pcifunc,\n\t\t\t\t\t\t\t start + entry);\n\t\t\tif (err) {\n\t\t\t\tdev_err(rvu->dev,\n\t\t\t\t\t\"TX rule for PF%dVF%d failed(%d)\\n\",\n\t\t\t\t\tpf, vf, err);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\trswitch->entry2pcifunc[entry++] = pcifunc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid rvu_switch_enable(struct rvu *rvu)\n{\n\tstruct npc_mcam_alloc_entry_req alloc_req = { 0 };\n\tstruct npc_mcam_alloc_entry_rsp alloc_rsp = { 0 };\n\tstruct npc_delete_flow_req uninstall_req = { 0 };\n\tstruct npc_delete_flow_rsp uninstall_rsp = { 0 };\n\tstruct npc_mcam_free_entry_req free_req = { 0 };\n\tstruct rvu_switch *rswitch = &rvu->rswitch;\n\tstruct msg_rsp rsp;\n\tint ret;\n\n\talloc_req.contig = true;\n\talloc_req.count = rvu->cgx_mapped_pfs + rvu->cgx_mapped_vfs;\n\tret = rvu_mbox_handler_npc_mcam_alloc_entry(rvu, &alloc_req,\n\t\t\t\t\t\t    &alloc_rsp);\n\tif (ret) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"Unable to allocate MCAM entries\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (alloc_rsp.count != alloc_req.count) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"Unable to allocate %d MCAM entries, got %d\\n\",\n\t\t\talloc_req.count, alloc_rsp.count);\n\t\tgoto free_entries;\n\t}\n\n\trswitch->entry2pcifunc = kcalloc(alloc_req.count, sizeof(u16),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!rswitch->entry2pcifunc)\n\t\tgoto free_entries;\n\n\trswitch->used_entries = alloc_rsp.count;\n\trswitch->start_entry = alloc_rsp.entry;\n\n\tret = rvu_switch_install_rules(rvu);\n\tif (ret)\n\t\tgoto uninstall_rules;\n\n\treturn;\n\nuninstall_rules:\n\tuninstall_req.start = rswitch->start_entry;\n\tuninstall_req.end =  rswitch->start_entry + rswitch->used_entries - 1;\n\trvu_mbox_handler_npc_delete_flow(rvu, &uninstall_req, &uninstall_rsp);\n\tkfree(rswitch->entry2pcifunc);\nfree_entries:\n\tfree_req.all = 1;\n\trvu_mbox_handler_npc_mcam_free_entry(rvu, &free_req, &rsp);\nexit:\n\treturn;\n}\n\nvoid rvu_switch_disable(struct rvu *rvu)\n{\n\tstruct npc_delete_flow_req uninstall_req = { 0 };\n\tstruct npc_delete_flow_rsp uninstall_rsp = { 0 };\n\tstruct npc_mcam_free_entry_req free_req = { 0 };\n\tstruct rvu_switch *rswitch = &rvu->rswitch;\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tint pf, vf, numvfs;\n\tstruct msg_rsp rsp;\n\tu16 pcifunc;\n\tint err;\n\n\tif (!rswitch->used_entries)\n\t\treturn;\n\n\tfor (pf = 1; pf < hw->total_pfs; pf++) {\n\t\tif (!is_pf_cgxmapped(rvu, pf))\n\t\t\tcontinue;\n\n\t\tpcifunc = pf << 10;\n\t\terr = rvu_switch_install_rx_rule(rvu, pcifunc, 0xFFF);\n\t\tif (err)\n\t\t\tdev_err(rvu->dev,\n\t\t\t\t\"Reverting RX rule for PF%d failed(%d)\\n\",\n\t\t\t\tpf, err);\n\n\t\t \n\t\trvu_switch_enable_lbk_link(rvu, pcifunc, false);\n\n\t\trvu_get_pf_numvfs(rvu, pf, &numvfs, NULL);\n\t\tfor (vf = 0; vf < numvfs; vf++) {\n\t\t\tpcifunc = pf << 10 | ((vf + 1) & 0x3FF);\n\t\t\terr = rvu_switch_install_rx_rule(rvu, pcifunc, 0xFFF);\n\t\t\tif (err)\n\t\t\t\tdev_err(rvu->dev,\n\t\t\t\t\t\"Reverting RX rule for PF%dVF%d failed(%d)\\n\",\n\t\t\t\t\tpf, vf, err);\n\n\t\t\trvu_switch_enable_lbk_link(rvu, pcifunc, false);\n\t\t}\n\t}\n\n\tuninstall_req.start = rswitch->start_entry;\n\tuninstall_req.end =  rswitch->start_entry + rswitch->used_entries - 1;\n\tfree_req.all = 1;\n\trvu_mbox_handler_npc_delete_flow(rvu, &uninstall_req, &uninstall_rsp);\n\trvu_mbox_handler_npc_mcam_free_entry(rvu, &free_req, &rsp);\n\trswitch->used_entries = 0;\n\tkfree(rswitch->entry2pcifunc);\n}\n\nvoid rvu_switch_update_rules(struct rvu *rvu, u16 pcifunc)\n{\n\tstruct rvu_switch *rswitch = &rvu->rswitch;\n\tu32 max = rswitch->used_entries;\n\tu16 entry;\n\n\tif (!rswitch->used_entries)\n\t\treturn;\n\n\tfor (entry = 0; entry < max; entry++) {\n\t\tif (rswitch->entry2pcifunc[entry] == pcifunc)\n\t\t\tbreak;\n\t}\n\n\tif (entry >= max)\n\t\treturn;\n\n\trvu_switch_install_tx_rule(rvu, pcifunc, rswitch->start_entry + entry);\n\trvu_switch_install_rx_rule(rvu, pcifunc, 0x0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}