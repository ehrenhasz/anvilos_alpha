{
  "module_name": "rvu_npc_hash.c",
  "hash_id": "f6bbb25aa415331ff4bf52a7e434af7eabf163992bcfbca5ac0f2b0a4ac0cb24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_hash.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/firmware.h>\n#include <linux/stddef.h>\n#include <linux/debugfs.h>\n\n#include \"rvu_struct.h\"\n#include \"rvu_reg.h\"\n#include \"rvu.h\"\n#include \"npc.h\"\n#include \"cgx.h\"\n#include \"rvu_npc_fs.h\"\n#include \"rvu_npc_hash.h\"\n\nstatic u64 rvu_npc_wide_extract(const u64 input[], size_t start_bit,\n\t\t\t\tsize_t width_bits)\n{\n\tconst u64 mask = ~(u64)((~(__uint128_t)0) << width_bits);\n\tconst size_t msb = start_bit + width_bits - 1;\n\tconst size_t lword = start_bit >> 6;\n\tconst size_t uword = msb >> 6;\n\tsize_t lbits;\n\tu64 hi, lo;\n\n\tif (lword == uword)\n\t\treturn (input[lword] >> (start_bit & 63)) & mask;\n\n\tlbits = 64 - (start_bit & 63);\n\thi = input[uword];\n\tlo = (input[lword] >> (start_bit & 63));\n\treturn ((hi << lbits) | lo) & mask;\n}\n\nstatic void rvu_npc_lshift_key(u64 *key, size_t key_bit_len)\n{\n\tu64 prev_orig_word = 0;\n\tu64 cur_orig_word = 0;\n\tsize_t extra = key_bit_len % 64;\n\tsize_t max_idx = key_bit_len / 64;\n\tsize_t i;\n\n\tif (extra)\n\t\tmax_idx++;\n\n\tfor (i = 0; i < max_idx; i++) {\n\t\tcur_orig_word = key[i];\n\t\tkey[i] = key[i] << 1;\n\t\tkey[i] |= ((prev_orig_word >> 63) & 0x1);\n\t\tprev_orig_word = cur_orig_word;\n\t}\n}\n\nstatic u32 rvu_npc_toeplitz_hash(const u64 *data, u64 *key, size_t data_bit_len,\n\t\t\t\t size_t key_bit_len)\n{\n\tu32 hash_out = 0;\n\tu64 temp_data = 0;\n\tint i;\n\n\tfor (i = data_bit_len - 1; i >= 0; i--) {\n\t\ttemp_data = (data[i / 64]);\n\t\ttemp_data = temp_data >> (i % 64);\n\t\ttemp_data &= 0x1;\n\t\tif (temp_data)\n\t\t\thash_out ^= (u32)(rvu_npc_wide_extract(key, key_bit_len - 32, 32));\n\n\t\trvu_npc_lshift_key(key, key_bit_len);\n\t}\n\n\treturn hash_out;\n}\n\nu32 npc_field_hash_calc(u64 *ldata, struct npc_get_field_hash_info_rsp rsp,\n\t\t\tu8 intf, u8 hash_idx)\n{\n\tu64 hash_key[3];\n\tu64 data_padded[2];\n\tu32 field_hash;\n\n\thash_key[0] = rsp.secret_key[1] << 31;\n\thash_key[0] |= rsp.secret_key[2];\n\thash_key[1] = rsp.secret_key[1] >> 33;\n\thash_key[1] |= rsp.secret_key[0] << 31;\n\thash_key[2] = rsp.secret_key[0] >> 33;\n\n\tdata_padded[0] = rsp.hash_mask[intf][hash_idx][0] & ldata[0];\n\tdata_padded[1] = rsp.hash_mask[intf][hash_idx][1] & ldata[1];\n\tfield_hash = rvu_npc_toeplitz_hash(data_padded, hash_key, 128, 159);\n\n\tfield_hash &= FIELD_GET(GENMASK(63, 32), rsp.hash_ctrl[intf][hash_idx]);\n\tfield_hash += FIELD_GET(GENMASK(31, 0), rsp.hash_ctrl[intf][hash_idx]);\n\treturn field_hash;\n}\n\nstatic u64 npc_update_use_hash(struct rvu *rvu, int blkaddr,\n\t\t\t       u8 intf, int lid, int lt, int ld)\n{\n\tu8 hdr, key;\n\tu64 cfg;\n\n\tcfg = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_LIDX_LTX_LDX_CFG(intf, lid, lt, ld));\n\thdr = FIELD_GET(NPC_HDR_OFFSET, cfg);\n\tkey = FIELD_GET(NPC_KEY_OFFSET, cfg);\n\n\t \n\tcfg = KEX_LD_CFG_USE_HASH(0x1, 0x03,\n\t\t\t\t  hdr, 0x1, 0x0, key);\n\n\treturn cfg;\n}\n\nstatic void npc_program_mkex_hash_rx(struct rvu *rvu, int blkaddr,\n\t\t\t\t     u8 intf)\n{\n\tstruct npc_mcam_kex_hash *mkex_hash = rvu->kpu.mkex_hash;\n\tint lid, lt, ld, hash_cnt = 0;\n\n\tif (is_npc_intf_tx(intf))\n\t\treturn;\n\n\t \n\tfor (lid = 0; lid < NPC_MAX_LID; lid++) {\n\t\tfor (lt = 0; lt < NPC_MAX_LT; lt++) {\n\t\t\tfor (ld = 0; ld < NPC_MAX_LD; ld++) {\n\t\t\t\tif (mkex_hash->lid_lt_ld_hash_en[intf][lid][lt][ld]) {\n\t\t\t\t\tu64 cfg;\n\n\t\t\t\t\tif (hash_cnt == NPC_MAX_HASH)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tcfg = npc_update_use_hash(rvu, blkaddr,\n\t\t\t\t\t\t\t\t  intf, lid, lt, ld);\n\t\t\t\t\t \n\t\t\t\t\tSET_KEX_LD(intf, lid, lt, ld, cfg);\n\t\t\t\t\t \n\t\t\t\t\tSET_KEX_LD_HASH(intf, ld,\n\t\t\t\t\t\t\tmkex_hash->hash[intf][ld]);\n\t\t\t\t\tSET_KEX_LD_HASH_MASK(intf, ld, 0,\n\t\t\t\t\t\t\t     mkex_hash->hash_mask[intf][ld][0]);\n\t\t\t\t\tSET_KEX_LD_HASH_MASK(intf, ld, 1,\n\t\t\t\t\t\t\t     mkex_hash->hash_mask[intf][ld][1]);\n\t\t\t\t\tSET_KEX_LD_HASH_CTRL(intf, ld,\n\t\t\t\t\t\t\t     mkex_hash->hash_ctrl[intf][ld]);\n\n\t\t\t\t\thash_cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void npc_program_mkex_hash_tx(struct rvu *rvu, int blkaddr,\n\t\t\t\t     u8 intf)\n{\n\tstruct npc_mcam_kex_hash *mkex_hash = rvu->kpu.mkex_hash;\n\tint lid, lt, ld, hash_cnt = 0;\n\n\tif (is_npc_intf_rx(intf))\n\t\treturn;\n\n\t \n\tfor (lid = 0; lid < NPC_MAX_LID; lid++) {\n\t\tfor (lt = 0; lt < NPC_MAX_LT; lt++) {\n\t\t\tfor (ld = 0; ld < NPC_MAX_LD; ld++)\n\t\t\t\tif (mkex_hash->lid_lt_ld_hash_en[intf][lid][lt][ld]) {\n\t\t\t\t\tu64 cfg;\n\n\t\t\t\t\tif (hash_cnt == NPC_MAX_HASH)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tcfg = npc_update_use_hash(rvu, blkaddr,\n\t\t\t\t\t\t\t\t  intf, lid, lt, ld);\n\t\t\t\t\t \n\t\t\t\t\tSET_KEX_LD(intf, lid, lt, ld, cfg);\n\t\t\t\t\t \n\t\t\t\t\tSET_KEX_LD_HASH(intf, ld,\n\t\t\t\t\t\t\tmkex_hash->hash[intf][ld]);\n\t\t\t\t\tSET_KEX_LD_HASH_MASK(intf, ld, 0,\n\t\t\t\t\t\t\t     mkex_hash->hash_mask[intf][ld][0]);\n\t\t\t\t\tSET_KEX_LD_HASH_MASK(intf, ld, 1,\n\t\t\t\t\t\t\t     mkex_hash->hash_mask[intf][ld][1]);\n\t\t\t\t\tSET_KEX_LD_HASH_CTRL(intf, ld,\n\t\t\t\t\t\t\t     mkex_hash->hash_ctrl[intf][ld]);\n\t\t\t\t\thash_cnt++;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nvoid npc_config_secret_key(struct rvu *rvu, int blkaddr)\n{\n\tstruct hw_cap *hwcap = &rvu->hw->cap;\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tu8 intf;\n\n\tif (!hwcap->npc_hash_extract)\n\t\treturn;\n\n\tfor (intf = 0; intf < hw->npc_intfs; intf++) {\n\t\trvu_write64(rvu, blkaddr, NPC_AF_INTFX_SECRET_KEY0(intf),\n\t\t\t    RVU_NPC_HASH_SECRET_KEY0);\n\t\trvu_write64(rvu, blkaddr, NPC_AF_INTFX_SECRET_KEY1(intf),\n\t\t\t    RVU_NPC_HASH_SECRET_KEY1);\n\t\trvu_write64(rvu, blkaddr, NPC_AF_INTFX_SECRET_KEY2(intf),\n\t\t\t    RVU_NPC_HASH_SECRET_KEY2);\n\t}\n}\n\nvoid npc_program_mkex_hash(struct rvu *rvu, int blkaddr)\n{\n\tstruct npc_mcam_kex_hash *mh = rvu->kpu.mkex_hash;\n\tstruct hw_cap *hwcap = &rvu->hw->cap;\n\tu8 intf, ld, hdr_offset, byte_len;\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tu64 cfg;\n\n\t \n\tif (!hwcap->npc_hash_extract)\n\t\treturn;\n\n\t \n\tfor (intf = 0; intf < hw->npc_intfs; intf++) {\n\t\tfor (ld = 0; ld < NPC_MAX_LD; ld++) {\n\t\t\tcfg = rvu_read64(rvu, blkaddr,\n\t\t\t\t\t NPC_AF_INTFX_LIDX_LTX_LDX_CFG(intf,\n\t\t\t\t\t\t\t\t       NPC_LID_LC,\n\t\t\t\t\t\t\t\t       NPC_LT_LC_IP6,\n\t\t\t\t\t\t\t\t       ld));\n\t\t\thdr_offset = FIELD_GET(NPC_HDR_OFFSET, cfg);\n\t\t\tbyte_len = FIELD_GET(NPC_BYTESM, cfg);\n\t\t\t \n\t\t\tif ((hdr_offset == 8 || hdr_offset == 24) && byte_len == 3)\n\t\t\t\tmh->lid_lt_ld_hash_en[intf][NPC_LID_LC][NPC_LT_LC_IP6][ld] = true;\n\t\t}\n\t}\n\n\t \n\tfor (intf = 0; intf < hw->npc_intfs; intf++) {\n\t\tnpc_program_mkex_hash_rx(rvu, blkaddr, intf);\n\t\tnpc_program_mkex_hash_tx(rvu, blkaddr, intf);\n\t}\n}\n\nvoid npc_update_field_hash(struct rvu *rvu, u8 intf,\n\t\t\t   struct mcam_entry *entry,\n\t\t\t   int blkaddr,\n\t\t\t   u64 features,\n\t\t\t   struct flow_msg *pkt,\n\t\t\t   struct flow_msg *mask,\n\t\t\t   struct flow_msg *opkt,\n\t\t\t   struct flow_msg *omask)\n{\n\tstruct npc_mcam_kex_hash *mkex_hash = rvu->kpu.mkex_hash;\n\tstruct npc_get_field_hash_info_req req;\n\tstruct npc_get_field_hash_info_rsp rsp;\n\tu64 ldata[2], cfg;\n\tu32 field_hash;\n\tu8 hash_idx;\n\n\tif (!rvu->hw->cap.npc_hash_extract) {\n\t\tdev_dbg(rvu->dev, \"%s: Field hash extract feature is not supported\\n\", __func__);\n\t\treturn;\n\t}\n\n\treq.intf = intf;\n\trvu_mbox_handler_npc_get_field_hash_info(rvu, &req, &rsp);\n\n\tfor (hash_idx = 0; hash_idx < NPC_MAX_HASH; hash_idx++) {\n\t\tcfg = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_HASHX_CFG(intf, hash_idx));\n\t\tif ((cfg & BIT_ULL(11)) && (cfg & BIT_ULL(12))) {\n\t\t\tu8 lid = (cfg & GENMASK_ULL(10, 8)) >> 8;\n\t\t\tu8 ltype = (cfg & GENMASK_ULL(7, 4)) >> 4;\n\t\t\tu8 ltype_mask = cfg & GENMASK_ULL(3, 0);\n\n\t\t\tif (mkex_hash->lid_lt_ld_hash_en[intf][lid][ltype][hash_idx]) {\n\t\t\t\tswitch (ltype & ltype_mask) {\n\t\t\t\t \n\t\t\t\tcase NPC_LT_LC_IP6:\n\t\t\t\t\t \n\t\t\t\t\tif ((features & BIT_ULL(NPC_SIP_IPV6)) && !hash_idx) {\n\t\t\t\t\t\tu32 src_ip[IPV6_WORDS];\n\n\t\t\t\t\t\tbe32_to_cpu_array(src_ip, pkt->ip6src, IPV6_WORDS);\n\t\t\t\t\t\tldata[1] = (u64)src_ip[0] << 32 | src_ip[1];\n\t\t\t\t\t\tldata[0] = (u64)src_ip[2] << 32 | src_ip[3];\n\t\t\t\t\t\tfield_hash = npc_field_hash_calc(ldata,\n\t\t\t\t\t\t\t\t\t\t rsp,\n\t\t\t\t\t\t\t\t\t\t intf,\n\t\t\t\t\t\t\t\t\t\t hash_idx);\n\t\t\t\t\t\tnpc_update_entry(rvu, NPC_SIP_IPV6, entry,\n\t\t\t\t\t\t\t\t field_hash, 0,\n\t\t\t\t\t\t\t\t GENMASK(31, 0), 0, intf);\n\t\t\t\t\t\tmemcpy(&opkt->ip6src, &pkt->ip6src,\n\t\t\t\t\t\t       sizeof(pkt->ip6src));\n\t\t\t\t\t\tmemcpy(&omask->ip6src, &mask->ip6src,\n\t\t\t\t\t\t       sizeof(mask->ip6src));\n\t\t\t\t\t} else if ((features & BIT_ULL(NPC_DIP_IPV6)) && hash_idx) {\n\t\t\t\t\t\tu32 dst_ip[IPV6_WORDS];\n\n\t\t\t\t\t\tbe32_to_cpu_array(dst_ip, pkt->ip6dst, IPV6_WORDS);\n\t\t\t\t\t\tldata[1] = (u64)dst_ip[0] << 32 | dst_ip[1];\n\t\t\t\t\t\tldata[0] = (u64)dst_ip[2] << 32 | dst_ip[3];\n\t\t\t\t\t\tfield_hash = npc_field_hash_calc(ldata,\n\t\t\t\t\t\t\t\t\t\t rsp,\n\t\t\t\t\t\t\t\t\t\t intf,\n\t\t\t\t\t\t\t\t\t\t hash_idx);\n\t\t\t\t\t\tnpc_update_entry(rvu, NPC_DIP_IPV6, entry,\n\t\t\t\t\t\t\t\t field_hash, 0,\n\t\t\t\t\t\t\t\t GENMASK(31, 0), 0, intf);\n\t\t\t\t\t\tmemcpy(&opkt->ip6dst, &pkt->ip6dst,\n\t\t\t\t\t\t       sizeof(pkt->ip6dst));\n\t\t\t\t\t\tmemcpy(&omask->ip6dst, &mask->ip6dst,\n\t\t\t\t\t\t       sizeof(mask->ip6dst));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint rvu_mbox_handler_npc_get_field_hash_info(struct rvu *rvu,\n\t\t\t\t\t     struct npc_get_field_hash_info_req *req,\n\t\t\t\t\t     struct npc_get_field_hash_info_rsp *rsp)\n{\n\tu64 *secret_key = rsp->secret_key;\n\tu8 intf = req->intf;\n\tint i, j, blkaddr;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0) {\n\t\tdev_err(rvu->dev, \"%s: NPC block not implemented\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tsecret_key[0] = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_SECRET_KEY0(intf));\n\tsecret_key[1] = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_SECRET_KEY1(intf));\n\tsecret_key[2] = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_SECRET_KEY2(intf));\n\n\tfor (i = 0; i < NPC_MAX_HASH; i++) {\n\t\tfor (j = 0; j < NPC_MAX_HASH_MASK; j++) {\n\t\t\trsp->hash_mask[NIX_INTF_RX][i][j] =\n\t\t\t\tGET_KEX_LD_HASH_MASK(NIX_INTF_RX, i, j);\n\t\t\trsp->hash_mask[NIX_INTF_TX][i][j] =\n\t\t\t\tGET_KEX_LD_HASH_MASK(NIX_INTF_TX, i, j);\n\t\t}\n\t}\n\n\tfor (i = 0; i < NPC_MAX_INTF; i++)\n\t\tfor (j = 0; j < NPC_MAX_HASH; j++)\n\t\t\trsp->hash_ctrl[i][j] = GET_KEX_LD_HASH_CTRL(i, j);\n\n\treturn 0;\n}\n\n \nstatic u64 rvu_exact_prepare_mdata(u8 *mac, u16 chan, u16 ctype, u64 mask)\n{\n\tu64 ldata = ether_addr_to_u64(mac);\n\n\t \n\tldata |= ((u64)chan << 48);\n\tldata |= ((u64)ctype  << 60);\n\tldata &= mask;\n\tldata = ldata << 2;\n\n\treturn ldata;\n}\n\n \nstatic u32 rvu_exact_calculate_hash(struct rvu *rvu, u16 chan, u16 ctype, u8 *mac,\n\t\t\t\t    u64 mask, u32 table_depth)\n{\n\tstruct npc_exact_table *table = rvu->hw->table;\n\tu64 hash_key[2];\n\tu64 key_in[2];\n\tu64 ldata;\n\tu32 hash;\n\n\tkey_in[0] = RVU_NPC_HASH_SECRET_KEY0;\n\tkey_in[1] = RVU_NPC_HASH_SECRET_KEY2;\n\n\thash_key[0] = key_in[0] << 31;\n\thash_key[0] |= key_in[1];\n\thash_key[1] = key_in[0] >> 33;\n\n\tldata = rvu_exact_prepare_mdata(mac, chan, ctype, mask);\n\n\tdev_dbg(rvu->dev, \"%s: ldata=0x%llx hash_key0=0x%llx hash_key2=0x%llx\\n\", __func__,\n\t\tldata, hash_key[1], hash_key[0]);\n\thash = rvu_npc_toeplitz_hash(&ldata, (u64 *)hash_key, 64, 95);\n\n\thash &= table->mem_table.hash_mask;\n\thash += table->mem_table.hash_offset;\n\tdev_dbg(rvu->dev, \"%s: hash=%x\\n\", __func__,  hash);\n\n\treturn hash;\n}\n\n \nstatic int rvu_npc_exact_alloc_mem_table_entry(struct rvu *rvu, u8 *way,\n\t\t\t\t\t       u32 *index, unsigned int hash)\n{\n\tstruct npc_exact_table *table;\n\tint depth, i;\n\n\ttable = rvu->hw->table;\n\tdepth = table->mem_table.depth;\n\n\t \n\tmutex_lock(&table->lock);\n\tfor (i = 0; i <  table->mem_table.ways; i++) {\n\t\tif (test_bit(hash + i * depth, table->mem_table.bmap))\n\t\t\tcontinue;\n\n\t\tset_bit(hash + i * depth, table->mem_table.bmap);\n\t\tmutex_unlock(&table->lock);\n\n\t\tdev_dbg(rvu->dev, \"%s: mem table entry alloc success (way=%d index=%d)\\n\",\n\t\t\t__func__, i, hash);\n\n\t\t*way = i;\n\t\t*index = hash;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&table->lock);\n\n\tdev_dbg(rvu->dev, \"%s: No space in 4 way exact way, weight=%u\\n\", __func__,\n\t\tbitmap_weight(table->mem_table.bmap, table->mem_table.depth));\n\treturn -ENOSPC;\n}\n\n \nstatic void rvu_npc_exact_free_id(struct rvu *rvu, u32 seq_id)\n{\n\tstruct npc_exact_table *table;\n\n\ttable = rvu->hw->table;\n\tmutex_lock(&table->lock);\n\tclear_bit(seq_id, table->id_bmap);\n\tmutex_unlock(&table->lock);\n\tdev_dbg(rvu->dev, \"%s: freed id %d\\n\", __func__, seq_id);\n}\n\n \nstatic bool rvu_npc_exact_alloc_id(struct rvu *rvu, u32 *seq_id)\n{\n\tstruct npc_exact_table *table;\n\tu32 idx;\n\n\ttable = rvu->hw->table;\n\n\tmutex_lock(&table->lock);\n\tidx = find_first_zero_bit(table->id_bmap, table->tot_ids);\n\tif (idx == table->tot_ids) {\n\t\tmutex_unlock(&table->lock);\n\t\tdev_err(rvu->dev, \"%s: No space in id bitmap (%d)\\n\",\n\t\t\t__func__, table->tot_ids);\n\n\t\treturn false;\n\t}\n\n\t \n\tset_bit(idx, table->id_bmap);\n\tmutex_unlock(&table->lock);\n\n\t*seq_id = idx;\n\tdev_dbg(rvu->dev, \"%s: Allocated id (%d)\\n\", __func__, *seq_id);\n\n\treturn true;\n}\n\n \nstatic int rvu_npc_exact_alloc_cam_table_entry(struct rvu *rvu, int *index)\n{\n\tstruct npc_exact_table *table;\n\tu32 idx;\n\n\ttable = rvu->hw->table;\n\n\tmutex_lock(&table->lock);\n\tidx = find_first_zero_bit(table->cam_table.bmap, table->cam_table.depth);\n\tif (idx == table->cam_table.depth) {\n\t\tmutex_unlock(&table->lock);\n\t\tdev_info(rvu->dev, \"%s: No space in exact cam table, weight=%u\\n\", __func__,\n\t\t\t bitmap_weight(table->cam_table.bmap, table->cam_table.depth));\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\tset_bit(idx, table->cam_table.bmap);\n\tmutex_unlock(&table->lock);\n\n\t*index = idx;\n\tdev_dbg(rvu->dev, \"%s: cam table entry alloc success (index=%d)\\n\",\n\t\t__func__, idx);\n\treturn 0;\n}\n\n \nstatic u64 rvu_exact_prepare_table_entry(struct rvu *rvu, bool enable,\n\t\t\t\t\t u8 ctype, u16 chan, u8 *mac_addr)\n\n{\n\tu64 ldata = ether_addr_to_u64(mac_addr);\n\n\t \n\tu64 mdata = FIELD_PREP(GENMASK_ULL(63, 63), enable ? 1 : 0);\n\n\t \n\tmdata |= FIELD_PREP(GENMASK_ULL(61, 60), ctype);\n\n\t \n\tmdata |= FIELD_PREP(GENMASK_ULL(59, 48), chan);\n\n\t \n\tmdata |= FIELD_PREP(GENMASK_ULL(47, 0), ldata);\n\n\treturn mdata;\n}\n\n \nstatic void rvu_exact_config_secret_key(struct rvu *rvu)\n{\n\tint blkaddr;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\trvu_write64(rvu, blkaddr, NPC_AF_INTFX_EXACT_SECRET0(NIX_INTF_RX),\n\t\t    RVU_NPC_HASH_SECRET_KEY0);\n\n\trvu_write64(rvu, blkaddr, NPC_AF_INTFX_EXACT_SECRET1(NIX_INTF_RX),\n\t\t    RVU_NPC_HASH_SECRET_KEY1);\n\n\trvu_write64(rvu, blkaddr, NPC_AF_INTFX_EXACT_SECRET2(NIX_INTF_RX),\n\t\t    RVU_NPC_HASH_SECRET_KEY2);\n}\n\n \nstatic void rvu_exact_config_search_key(struct rvu *rvu)\n{\n\tint blkaddr;\n\tu64 reg_val;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\n\t \n\treg_val = FIELD_PREP(GENMASK_ULL(39, 32), 0);\n\n\t \n\treg_val |= FIELD_PREP(GENMASK_ULL(18, 16), ETH_ALEN - 1);\n\n\t \n\treg_val |= FIELD_PREP(GENMASK_ULL(11, 11), 1);\n\treg_val |= FIELD_PREP(GENMASK_ULL(10, 8),  NPC_LID_LA);\n\n\t \n\n\t \n\treg_val |= FIELD_PREP(GENMASK_ULL(12, 12), 0);\n\n\t \n\treg_val |= FIELD_PREP(GENMASK_ULL(7, 4), 0);\n\n\t \n\treg_val |= FIELD_PREP(GENMASK_ULL(3, 0), 0);\n\n\trvu_write64(rvu, blkaddr, NPC_AF_INTFX_EXACT_CFG(NIX_INTF_RX), reg_val);\n}\n\n \nstatic void rvu_exact_config_result_ctrl(struct rvu *rvu, uint32_t depth)\n{\n\tint blkaddr;\n\tu64 reg = 0;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\n\t \n\trvu->hw->table->mem_table.hash_mask = (depth - 1);\n\treg |= FIELD_PREP(GENMASK_ULL(42, 32), (depth - 1));\n\n\t \n\trvu->hw->table->mem_table.hash_offset = 0;\n\treg |= FIELD_PREP(GENMASK_ULL(10, 0), 0);\n\n\t \n\trvu_write64(rvu, blkaddr, NPC_AF_INTFX_EXACT_RESULT_CTL(NIX_INTF_RX), reg);\n\t \n}\n\n \nstatic void rvu_exact_config_table_mask(struct rvu *rvu)\n{\n\tint blkaddr;\n\tu64 mask = 0;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\n\t \n\tmask |= FIELD_PREP(GENMASK_ULL(61, 60), 0);\n\n\t \n\tmask |= GENMASK_ULL(59, 48);\n\n\t \n\tmask |= GENMASK_ULL(47, 0);\n\n\t \n\trvu->hw->table->mem_table.mask = mask;\n\n\t \n\trvu_write64(rvu, blkaddr, NPC_AF_INTFX_EXACT_MASK(NIX_INTF_RX), mask);\n}\n\n \nu32 rvu_npc_exact_get_max_entries(struct rvu *rvu)\n{\n\tstruct npc_exact_table *table;\n\n\ttable = rvu->hw->table;\n\treturn table->tot_ids;\n}\n\n \nbool rvu_npc_exact_has_match_table(struct rvu *rvu)\n{\n\treturn  rvu->hw->cap.npc_exact_match_enabled;\n}\n\n \nstatic struct npc_exact_table_entry *\n__rvu_npc_exact_find_entry_by_seq_id(struct rvu *rvu, u32 seq_id)\n{\n\tstruct npc_exact_table *table = rvu->hw->table;\n\tstruct npc_exact_table_entry *entry = NULL;\n\tstruct list_head *lhead;\n\n\tlhead = &table->lhead_gbl;\n\n\t \n\tlist_for_each_entry(entry, lhead, glist) {\n\t\tif (entry->seq_id != seq_id)\n\t\t\tcontinue;\n\n\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int rvu_npc_exact_add_to_list(struct rvu *rvu, enum npc_exact_opc_type opc_type, u8 ways,\n\t\t\t\t     u32 index, u8 cgx_id, u8 lmac_id, u8 *mac_addr, u16 chan,\n\t\t\t\t     u8 ctype, u32 *seq_id, bool cmd, u32 mcam_idx, u16 pcifunc)\n{\n\tstruct npc_exact_table_entry *entry, *tmp, *iter;\n\tstruct npc_exact_table *table = rvu->hw->table;\n\tstruct list_head *lhead, *pprev;\n\n\tWARN_ON(ways >= NPC_EXACT_TBL_MAX_WAYS);\n\n\tif (!rvu_npc_exact_alloc_id(rvu, seq_id)) {\n\t\tdev_err(rvu->dev, \"%s: Generate seq id failed\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\trvu_npc_exact_free_id(rvu, *seq_id);\n\t\tdev_err(rvu->dev, \"%s: Memory allocation failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&table->lock);\n\tswitch (opc_type) {\n\tcase NPC_EXACT_OPC_CAM:\n\t\tlhead = &table->lhead_cam_tbl_entry;\n\t\ttable->cam_tbl_entry_cnt++;\n\t\tbreak;\n\n\tcase NPC_EXACT_OPC_MEM:\n\t\tlhead = &table->lhead_mem_tbl_entry[ways];\n\t\ttable->mem_tbl_entry_cnt++;\n\t\tbreak;\n\n\tdefault:\n\t\tmutex_unlock(&table->lock);\n\t\tkfree(entry);\n\t\trvu_npc_exact_free_id(rvu, *seq_id);\n\n\t\tdev_err(rvu->dev, \"%s: Unknown opc type%d\\n\", __func__, opc_type);\n\t\treturn  -EINVAL;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&entry->glist);\n\tlist_add_tail(&entry->glist, &table->lhead_gbl);\n\tINIT_LIST_HEAD(&entry->list);\n\tentry->index = index;\n\tentry->ways = ways;\n\tentry->opc_type = opc_type;\n\n\tentry->pcifunc = pcifunc;\n\n\tether_addr_copy(entry->mac, mac_addr);\n\tentry->chan = chan;\n\tentry->ctype = ctype;\n\tentry->cgx_id = cgx_id;\n\tentry->lmac_id = lmac_id;\n\n\tentry->seq_id = *seq_id;\n\n\tentry->mcam_idx = mcam_idx;\n\tentry->cmd = cmd;\n\n\tpprev = lhead;\n\n\t \n\tlist_for_each_entry_safe(iter, tmp, lhead, list) {\n\t\tif (index < iter->index)\n\t\t\tbreak;\n\n\t\tpprev = &iter->list;\n\t}\n\n\t \n\tlist_add(&entry->list, pprev);\n\tmutex_unlock(&table->lock);\n\treturn 0;\n}\n\n \nstatic void rvu_npc_exact_mem_table_write(struct rvu *rvu, int blkaddr, u8 ways,\n\t\t\t\t\t  u32 index, u64 mdata)\n{\n\trvu_write64(rvu, blkaddr, NPC_AF_EXACT_MEM_ENTRY(ways, index), mdata);\n}\n\n \nstatic void rvu_npc_exact_cam_table_write(struct rvu *rvu, int blkaddr,\n\t\t\t\t\t  u32 index, u64 mdata)\n{\n\trvu_write64(rvu, blkaddr, NPC_AF_EXACT_CAM_ENTRY(index), mdata);\n}\n\n \nstatic int rvu_npc_exact_dealloc_table_entry(struct rvu *rvu, enum npc_exact_opc_type opc_type,\n\t\t\t\t\t     u8 ways, u32 index)\n{\n\tint blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tstruct npc_exact_table *table;\n\tu8 null_dmac[6] = { 0 };\n\tint depth;\n\n\t \n\tu64 null_mdata = rvu_exact_prepare_table_entry(rvu, false, 0, 0, null_dmac);\n\n\ttable = rvu->hw->table;\n\tdepth = table->mem_table.depth;\n\n\tmutex_lock(&table->lock);\n\n\tswitch (opc_type) {\n\tcase NPC_EXACT_OPC_CAM:\n\n\t\t \n\t\tif (!test_bit(index, table->cam_table.bmap)) {\n\t\t\tmutex_unlock(&table->lock);\n\t\t\tdev_err(rvu->dev, \"%s: Trying to free an unused entry ways=%d index=%d\\n\",\n\t\t\t\t__func__, ways, index);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trvu_npc_exact_cam_table_write(rvu, blkaddr, index, null_mdata);\n\t\tclear_bit(index, table->cam_table.bmap);\n\t\tbreak;\n\n\tcase NPC_EXACT_OPC_MEM:\n\n\t\t \n\t\tif (!test_bit(index + ways * depth, table->mem_table.bmap)) {\n\t\t\tmutex_unlock(&table->lock);\n\t\t\tdev_err(rvu->dev, \"%s: Trying to free an unused entry index=%d\\n\",\n\t\t\t\t__func__, index);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trvu_npc_exact_mem_table_write(rvu, blkaddr, ways, index, null_mdata);\n\t\tclear_bit(index + ways * depth, table->mem_table.bmap);\n\t\tbreak;\n\n\tdefault:\n\t\tmutex_unlock(&table->lock);\n\t\tdev_err(rvu->dev, \"%s: invalid opc type %d\", __func__, opc_type);\n\t\treturn -ENOSPC;\n\t}\n\n\tmutex_unlock(&table->lock);\n\n\tdev_dbg(rvu->dev, \"%s: Successfully deleted entry (index=%d, ways=%d opc_type=%d\\n\",\n\t\t__func__, index,  ways, opc_type);\n\n\treturn 0;\n}\n\n \nstatic int rvu_npc_exact_alloc_table_entry(struct rvu *rvu,  char *mac, u16 chan, u8 ctype,\n\t\t\t\t\t   u32 *index, u8 *ways, enum npc_exact_opc_type *opc_type)\n{\n\tstruct npc_exact_table *table;\n\tunsigned int hash;\n\tint err;\n\n\ttable = rvu->hw->table;\n\n\t \n\thash =  rvu_exact_calculate_hash(rvu, chan, ctype, mac, table->mem_table.mask,\n\t\t\t\t\t table->mem_table.depth);\n\terr = rvu_npc_exact_alloc_mem_table_entry(rvu, ways, index, hash);\n\tif (!err) {\n\t\t*opc_type = NPC_EXACT_OPC_MEM;\n\t\tdev_dbg(rvu->dev, \"%s: inserted in 4 ways hash table ways=%d, index=%d\\n\",\n\t\t\t__func__, *ways, *index);\n\t\treturn 0;\n\t}\n\n\tdev_dbg(rvu->dev, \"%s: failed to insert in 4 ways hash table\\n\", __func__);\n\n\t \n\t*ways = 0;\n\terr = rvu_npc_exact_alloc_cam_table_entry(rvu, index);\n\tif (!err) {\n\t\t*opc_type = NPC_EXACT_OPC_CAM;\n\t\tdev_dbg(rvu->dev, \"%s: inserted in fully associative hash table index=%u\\n\",\n\t\t\t__func__, *index);\n\t\treturn 0;\n\t}\n\n\tdev_err(rvu->dev, \"%s: failed to insert in fully associative hash table\\n\", __func__);\n\treturn -ENOSPC;\n}\n\n \nstatic bool rvu_npc_exact_save_drop_rule_chan_and_mask(struct rvu *rvu, int drop_mcam_idx,\n\t\t\t\t\t\t       u64 chan_val, u64 chan_mask, u16 pcifunc)\n{\n\tstruct npc_exact_table *table;\n\tint i;\n\n\ttable = rvu->hw->table;\n\n\tfor (i = 0; i < NPC_MCAM_DROP_RULE_MAX; i++) {\n\t\tif (!table->drop_rule_map[i].valid)\n\t\t\tbreak;\n\n\t\tif (table->drop_rule_map[i].chan_val != (u16)chan_val)\n\t\t\tcontinue;\n\n\t\tif (table->drop_rule_map[i].chan_mask != (u16)chan_mask)\n\t\t\tcontinue;\n\n\t\treturn false;\n\t}\n\n\tif (i == NPC_MCAM_DROP_RULE_MAX)\n\t\treturn false;\n\n\ttable->drop_rule_map[i].drop_rule_idx = drop_mcam_idx;\n\ttable->drop_rule_map[i].chan_val = (u16)chan_val;\n\ttable->drop_rule_map[i].chan_mask = (u16)chan_mask;\n\ttable->drop_rule_map[i].pcifunc = pcifunc;\n\ttable->drop_rule_map[i].valid = true;\n\treturn true;\n}\n\n \nstatic bool rvu_npc_exact_calc_drop_rule_chan_and_mask(struct rvu *rvu, u8 intf_type,\n\t\t\t\t\t\t       u8 cgx_id, u8 lmac_id,\n\t\t\t\t\t\t       u64 *val, u64 *mask)\n{\n\tu16 chan_val, chan_mask;\n\n\t \n\tif (intf_type != NIX_INTF_TYPE_CGX)\n\t\treturn false;\n\n\tchan_val = rvu_nix_chan_cgx(rvu, cgx_id, lmac_id, 0);\n\tchan_mask = 0xfff;\n\n\tif (val)\n\t\t*val = chan_val;\n\n\tif (mask)\n\t\t*mask = chan_mask;\n\n\treturn true;\n}\n\n \nu16 rvu_npc_exact_drop_rule_to_pcifunc(struct rvu *rvu, u32 drop_rule_idx)\n{\n\tstruct npc_exact_table *table;\n\tint i;\n\n\ttable = rvu->hw->table;\n\n\tfor (i = 0; i < NPC_MCAM_DROP_RULE_MAX; i++) {\n\t\tif (!table->drop_rule_map[i].valid)\n\t\t\tbreak;\n\n\t\tif (table->drop_rule_map[i].drop_rule_idx != drop_rule_idx)\n\t\t\tcontinue;\n\n\t\treturn table->drop_rule_map[i].pcifunc;\n\t}\n\n\tdev_err(rvu->dev, \"%s: drop mcam rule index (%d) >= NPC_MCAM_DROP_RULE_MAX\\n\",\n\t\t__func__, drop_rule_idx);\n\treturn -1;\n}\n\n \nstatic bool rvu_npc_exact_get_drop_rule_info(struct rvu *rvu, u8 intf_type, u8 cgx_id,\n\t\t\t\t\t     u8 lmac_id, u32 *drop_mcam_idx, u64 *val,\n\t\t\t\t\t     u64 *mask, u16 *pcifunc)\n{\n\tstruct npc_exact_table *table;\n\tu64 chan_val, chan_mask;\n\tbool rc;\n\tint i;\n\n\ttable = rvu->hw->table;\n\n\tif (intf_type != NIX_INTF_TYPE_CGX) {\n\t\tdev_err(rvu->dev, \"%s: No drop rule for LBK/SDP mode\\n\", __func__);\n\t\treturn false;\n\t}\n\n\trc = rvu_npc_exact_calc_drop_rule_chan_and_mask(rvu, intf_type, cgx_id,\n\t\t\t\t\t\t\tlmac_id, &chan_val, &chan_mask);\n\tif (!rc)\n\t\treturn false;\n\n\tfor (i = 0; i < NPC_MCAM_DROP_RULE_MAX; i++) {\n\t\tif (!table->drop_rule_map[i].valid)\n\t\t\tbreak;\n\n\t\tif (table->drop_rule_map[i].chan_val != (u16)chan_val)\n\t\t\tcontinue;\n\n\t\tif (val)\n\t\t\t*val = table->drop_rule_map[i].chan_val;\n\t\tif (mask)\n\t\t\t*mask = table->drop_rule_map[i].chan_mask;\n\t\tif (pcifunc)\n\t\t\t*pcifunc = table->drop_rule_map[i].pcifunc;\n\n\t\t*drop_mcam_idx = i;\n\t\treturn true;\n\t}\n\n\tif (i == NPC_MCAM_DROP_RULE_MAX) {\n\t\tdev_err(rvu->dev, \"%s: drop mcam rule index (%d) >= NPC_MCAM_DROP_RULE_MAX\\n\",\n\t\t\t__func__, *drop_mcam_idx);\n\t\treturn false;\n\t}\n\n\tdev_err(rvu->dev, \"%s: Could not retrieve for cgx=%d, lmac=%d\\n\",\n\t\t__func__, cgx_id, lmac_id);\n\treturn false;\n}\n\n \nstatic u16 __rvu_npc_exact_cmd_rules_cnt_update(struct rvu *rvu, int drop_mcam_idx,\n\t\t\t\t\t\tint val, bool *enable_or_disable_cam)\n{\n\tstruct npc_exact_table *table;\n\tu16 *cnt, old_cnt;\n\tbool promisc;\n\n\ttable = rvu->hw->table;\n\tpromisc = table->promisc_mode[drop_mcam_idx];\n\n\tcnt = &table->cnt_cmd_rules[drop_mcam_idx];\n\told_cnt = *cnt;\n\n\t*cnt += val;\n\n\tif (!enable_or_disable_cam)\n\t\tgoto done;\n\n\t*enable_or_disable_cam = false;\n\n\tif (promisc)\n\t\tgoto done;\n\n\t \n\tif (!*cnt && val < 0) {\n\t\t*enable_or_disable_cam = true;\n\t\tgoto done;\n\t}\n\n\t \n\tif (!old_cnt && val > 0) {\n\t\t*enable_or_disable_cam = true;\n\t\tgoto done;\n\t}\n\ndone:\n\treturn *cnt;\n}\n\n \nstatic int rvu_npc_exact_del_table_entry_by_id(struct rvu *rvu, u32 seq_id)\n{\n\tstruct npc_exact_table_entry *entry = NULL;\n\tstruct npc_exact_table *table;\n\tbool disable_cam = false;\n\tu32 drop_mcam_idx = -1;\n\tint *cnt;\n\tbool rc;\n\n\ttable = rvu->hw->table;\n\n\tmutex_lock(&table->lock);\n\n\t \n\tentry = __rvu_npc_exact_find_entry_by_seq_id(rvu, seq_id);\n\tif (!entry) {\n\t\tdev_dbg(rvu->dev, \"%s: failed to find entry for id=%d\\n\", __func__, seq_id);\n\t\tmutex_unlock(&table->lock);\n\t\treturn -ENODATA;\n\t}\n\n\tcnt = (entry->opc_type == NPC_EXACT_OPC_CAM) ? &table->cam_tbl_entry_cnt :\n\t\t\t\t&table->mem_tbl_entry_cnt;\n\n\t \n\tlist_del_init(&entry->list);\n\tlist_del_init(&entry->glist);\n\n\t(*cnt)--;\n\n\trc = rvu_npc_exact_get_drop_rule_info(rvu, NIX_INTF_TYPE_CGX, entry->cgx_id,\n\t\t\t\t\t      entry->lmac_id, &drop_mcam_idx, NULL, NULL, NULL);\n\tif (!rc) {\n\t\tdev_dbg(rvu->dev, \"%s: failed to retrieve drop info for id=0x%x\\n\",\n\t\t\t__func__, seq_id);\n\t\tmutex_unlock(&table->lock);\n\t\treturn -ENODATA;\n\t}\n\n\tif (entry->cmd)\n\t\t__rvu_npc_exact_cmd_rules_cnt_update(rvu, drop_mcam_idx, -1, &disable_cam);\n\n\t \n\tif (disable_cam) {\n\t\trvu_npc_enable_mcam_by_entry_index(rvu, drop_mcam_idx, NIX_INTF_RX, false);\n\t\tdev_dbg(rvu->dev, \"%s: Disabling mcam idx %d\\n\",\n\t\t\t__func__, drop_mcam_idx);\n\t}\n\n\tmutex_unlock(&table->lock);\n\n\trvu_npc_exact_dealloc_table_entry(rvu, entry->opc_type, entry->ways, entry->index);\n\n\trvu_npc_exact_free_id(rvu, seq_id);\n\n\tdev_dbg(rvu->dev, \"%s: delete entry success for id=0x%x, mca=%pM\\n\",\n\t\t__func__, seq_id, entry->mac);\n\tkfree(entry);\n\n\treturn 0;\n}\n\n \nstatic int rvu_npc_exact_add_table_entry(struct rvu *rvu, u8 cgx_id, u8 lmac_id, u8 *mac,\n\t\t\t\t\t u16 chan, u8 ctype, u32 *seq_id, bool cmd,\n\t\t\t\t\t u32 mcam_idx, u16 pcifunc)\n{\n\tint blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tenum npc_exact_opc_type opc_type;\n\tbool enable_cam = false;\n\tu32 drop_mcam_idx;\n\tu32 index;\n\tu64 mdata;\n\tbool rc;\n\tint err;\n\tu8 ways;\n\n\tctype = 0;\n\n\terr = rvu_npc_exact_alloc_table_entry(rvu, mac, chan, ctype, &index, &ways, &opc_type);\n\tif (err) {\n\t\tdev_err(rvu->dev, \"%s: Could not alloc in exact match table\\n\", __func__);\n\t\treturn err;\n\t}\n\n\t \n\tmdata = rvu_exact_prepare_table_entry(rvu, true, ctype, chan, mac);\n\n\tif (opc_type == NPC_EXACT_OPC_CAM)\n\t\trvu_npc_exact_cam_table_write(rvu, blkaddr, index, mdata);\n\telse\n\t\trvu_npc_exact_mem_table_write(rvu, blkaddr, ways, index,  mdata);\n\n\t \n\terr = rvu_npc_exact_add_to_list(rvu, opc_type, ways, index, cgx_id, lmac_id,\n\t\t\t\t\tmac, chan, ctype, seq_id, cmd, mcam_idx, pcifunc);\n\tif (err) {\n\t\trvu_npc_exact_dealloc_table_entry(rvu, opc_type, ways, index);\n\t\tdev_err(rvu->dev, \"%s: could not add to exact match table\\n\", __func__);\n\t\treturn err;\n\t}\n\n\trc = rvu_npc_exact_get_drop_rule_info(rvu, NIX_INTF_TYPE_CGX, cgx_id, lmac_id,\n\t\t\t\t\t      &drop_mcam_idx, NULL, NULL, NULL);\n\tif (!rc) {\n\t\trvu_npc_exact_dealloc_table_entry(rvu, opc_type, ways, index);\n\t\tdev_dbg(rvu->dev, \"%s: failed to get drop rule info cgx=%d lmac=%d\\n\",\n\t\t\t__func__, cgx_id, lmac_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd)\n\t\t__rvu_npc_exact_cmd_rules_cnt_update(rvu, drop_mcam_idx, 1, &enable_cam);\n\n\t \n\tif (enable_cam) {\n\t\trvu_npc_enable_mcam_by_entry_index(rvu, drop_mcam_idx, NIX_INTF_RX, true);\n\t\tdev_dbg(rvu->dev, \"%s: Enabling mcam idx %d\\n\",\n\t\t\t__func__, drop_mcam_idx);\n\t}\n\n\tdev_dbg(rvu->dev,\n\t\t\"%s: Successfully added entry (index=%d, dmac=%pM, ways=%d opc_type=%d\\n\",\n\t\t__func__, index, mac, ways, opc_type);\n\n\treturn 0;\n}\n\n \nstatic int rvu_npc_exact_update_table_entry(struct rvu *rvu, u8 cgx_id, u8 lmac_id,\n\t\t\t\t\t    u8 *old_mac, u8 *new_mac, u32 *seq_id)\n{\n\tint blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tstruct npc_exact_table_entry *entry;\n\tstruct npc_exact_table *table;\n\tu32 hash_index;\n\tu64 mdata;\n\n\ttable = rvu->hw->table;\n\n\tmutex_lock(&table->lock);\n\n\t \n\tentry = __rvu_npc_exact_find_entry_by_seq_id(rvu, *seq_id);\n\tif (!entry) {\n\t\tmutex_unlock(&table->lock);\n\t\tdev_dbg(rvu->dev,\n\t\t\t\"%s: failed to find entry for cgx_id=%d lmac_id=%d old_mac=%pM\\n\",\n\t\t\t__func__, cgx_id, lmac_id, old_mac);\n\t\treturn -ENODATA;\n\t}\n\n\t \n\tif (entry->opc_type == NPC_EXACT_OPC_MEM) {\n\t\thash_index =  rvu_exact_calculate_hash(rvu, entry->chan, entry->ctype,\n\t\t\t\t\t\t       new_mac, table->mem_table.mask,\n\t\t\t\t\t\t       table->mem_table.depth);\n\t\tif (hash_index != entry->index) {\n\t\t\tdev_dbg(rvu->dev,\n\t\t\t\t\"%s: Update failed due to index mismatch(new=0x%x, old=%x)\\n\",\n\t\t\t\t__func__, hash_index, entry->index);\n\t\t\tmutex_unlock(&table->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmdata = rvu_exact_prepare_table_entry(rvu, true, entry->ctype, entry->chan, new_mac);\n\n\tif (entry->opc_type == NPC_EXACT_OPC_MEM)\n\t\trvu_npc_exact_mem_table_write(rvu, blkaddr, entry->ways, entry->index, mdata);\n\telse\n\t\trvu_npc_exact_cam_table_write(rvu, blkaddr, entry->index, mdata);\n\n\t \n\tether_addr_copy(entry->mac, new_mac);\n\t*seq_id = entry->seq_id;\n\n\tdev_dbg(rvu->dev,\n\t\t\"%s: Successfully updated entry (index=%d, dmac=%pM, ways=%d opc_type=%d\\n\",\n\t\t__func__, entry->index, entry->mac, entry->ways, entry->opc_type);\n\n\tdev_dbg(rvu->dev, \"%s: Successfully updated entry (old mac=%pM new_mac=%pM\\n\",\n\t\t__func__, old_mac, new_mac);\n\n\tmutex_unlock(&table->lock);\n\treturn 0;\n}\n\n \n\nint rvu_npc_exact_promisc_disable(struct rvu *rvu, u16 pcifunc)\n{\n\tstruct npc_exact_table *table;\n\tint pf = rvu_get_pf(pcifunc);\n\tu8 cgx_id, lmac_id;\n\tu32 drop_mcam_idx;\n\tbool *promisc;\n\tbool rc;\n\n\ttable = rvu->hw->table;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\trc = rvu_npc_exact_get_drop_rule_info(rvu, NIX_INTF_TYPE_CGX, cgx_id, lmac_id,\n\t\t\t\t\t      &drop_mcam_idx, NULL, NULL, NULL);\n\tif (!rc) {\n\t\tdev_dbg(rvu->dev, \"%s: failed to get drop rule info cgx=%d lmac=%d\\n\",\n\t\t\t__func__, cgx_id, lmac_id);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&table->lock);\n\tpromisc = &table->promisc_mode[drop_mcam_idx];\n\n\tif (!*promisc) {\n\t\tmutex_unlock(&table->lock);\n\t\tdev_dbg(rvu->dev, \"%s: Err Already promisc mode disabled (cgx=%d lmac=%d)\\n\",\n\t\t\t__func__, cgx_id, lmac_id);\n\t\treturn LMAC_AF_ERR_INVALID_PARAM;\n\t}\n\t*promisc = false;\n\tmutex_unlock(&table->lock);\n\n\t \n\trvu_npc_enable_mcam_by_entry_index(rvu, drop_mcam_idx, NIX_INTF_RX,\n\t\t\t\t\t   true);\n\n\tdev_dbg(rvu->dev, \"%s: disabled  promisc mode (cgx=%d lmac=%d)\\n\",\n\t\t__func__, cgx_id, lmac_id);\n\treturn 0;\n}\n\n \nint rvu_npc_exact_promisc_enable(struct rvu *rvu, u16 pcifunc)\n{\n\tstruct npc_exact_table *table;\n\tint pf = rvu_get_pf(pcifunc);\n\tu8 cgx_id, lmac_id;\n\tu32 drop_mcam_idx;\n\tbool *promisc;\n\tbool rc;\n\n\ttable = rvu->hw->table;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\trc = rvu_npc_exact_get_drop_rule_info(rvu, NIX_INTF_TYPE_CGX, cgx_id, lmac_id,\n\t\t\t\t\t      &drop_mcam_idx, NULL, NULL, NULL);\n\tif (!rc) {\n\t\tdev_dbg(rvu->dev, \"%s: failed to get drop rule info cgx=%d lmac=%d\\n\",\n\t\t\t__func__, cgx_id, lmac_id);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&table->lock);\n\tpromisc = &table->promisc_mode[drop_mcam_idx];\n\n\tif (*promisc) {\n\t\tmutex_unlock(&table->lock);\n\t\tdev_dbg(rvu->dev, \"%s: Already in promisc mode (cgx=%d lmac=%d)\\n\",\n\t\t\t__func__, cgx_id, lmac_id);\n\t\treturn LMAC_AF_ERR_INVALID_PARAM;\n\t}\n\t*promisc = true;\n\tmutex_unlock(&table->lock);\n\n\t \n\trvu_npc_enable_mcam_by_entry_index(rvu, drop_mcam_idx, NIX_INTF_RX,\n\t\t\t\t\t   false);\n\n\tdev_dbg(rvu->dev, \"%s: Enabled promisc mode (cgx=%d lmac=%d)\\n\",\n\t\t__func__, cgx_id, lmac_id);\n\treturn 0;\n}\n\n \nint rvu_npc_exact_mac_addr_reset(struct rvu *rvu, struct cgx_mac_addr_reset_req *req,\n\t\t\t\t struct msg_rsp *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu32 seq_id = req->index;\n\tstruct rvu_pfvf *pfvf;\n\tu8 cgx_id, lmac_id;\n\tint rc;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\n\tpfvf = rvu_get_pfvf(rvu, req->hdr.pcifunc);\n\n\trc = rvu_npc_exact_del_table_entry_by_id(rvu, seq_id);\n\tif (rc) {\n\t\t \n\t\tdev_err(rvu->dev, \"%s MAC (%pM) del PF=%d failed\\n\", __func__, pfvf->mac_addr, pf);\n\t\treturn 0;\n\t}\n\n\tdev_dbg(rvu->dev, \"%s MAC (%pM) del PF=%d success (seq_id=%u)\\n\",\n\t\t__func__, pfvf->mac_addr, pf, seq_id);\n\treturn 0;\n}\n\n \nint rvu_npc_exact_mac_addr_update(struct rvu *rvu,\n\t\t\t\t  struct cgx_mac_addr_update_req *req,\n\t\t\t\t  struct cgx_mac_addr_update_rsp *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tstruct npc_exact_table_entry *entry;\n\tstruct npc_exact_table *table;\n\tstruct rvu_pfvf *pfvf;\n\tu32 seq_id, mcam_idx;\n\tu8 old_mac[ETH_ALEN];\n\tu8 cgx_id, lmac_id;\n\tint rc;\n\n\tif (!is_cgx_config_permitted(rvu, req->hdr.pcifunc))\n\t\treturn LMAC_AF_ERR_PERM_DENIED;\n\n\tdev_dbg(rvu->dev, \"%s: Update request for seq_id=%d, mac=%pM\\n\",\n\t\t__func__, req->index, req->mac_addr);\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\n\tpfvf = rvu_get_pfvf(rvu, req->hdr.pcifunc);\n\n\ttable = rvu->hw->table;\n\n\tmutex_lock(&table->lock);\n\n\t \n\tentry = __rvu_npc_exact_find_entry_by_seq_id(rvu, req->index);\n\tif (!entry) {\n\t\tdev_err(rvu->dev, \"%s: failed to find entry for id=0x%x\\n\", __func__, req->index);\n\t\tmutex_unlock(&table->lock);\n\t\treturn LMAC_AF_ERR_EXACT_MATCH_TBL_LOOK_UP_FAILED;\n\t}\n\tether_addr_copy(old_mac, entry->mac);\n\tseq_id = entry->seq_id;\n\tmcam_idx = entry->mcam_idx;\n\tmutex_unlock(&table->lock);\n\n\trc = rvu_npc_exact_update_table_entry(rvu, cgx_id, lmac_id,  old_mac,\n\t\t\t\t\t      req->mac_addr, &seq_id);\n\tif (!rc) {\n\t\trsp->index = seq_id;\n\t\tdev_dbg(rvu->dev, \"%s  mac:%pM (pfvf:%pM default:%pM) update to PF=%d success\\n\",\n\t\t\t__func__, req->mac_addr, pfvf->mac_addr, pfvf->default_mac, pf);\n\t\tether_addr_copy(pfvf->mac_addr, req->mac_addr);\n\t\treturn 0;\n\t}\n\n\t \n\trc = rvu_npc_exact_del_table_entry_by_id(rvu, req->index);\n\tif (rc) {\n\t\t \n\t\tdev_dbg(rvu->dev, \"%s MAC (%pM) del PF=%d failed\\n\", __func__,\n\t\t\tpfvf->mac_addr, pf);\n\t}\n\n\trc = rvu_npc_exact_add_table_entry(rvu, cgx_id, lmac_id, req->mac_addr,\n\t\t\t\t\t   pfvf->rx_chan_base, 0, &seq_id, true,\n\t\t\t\t\t   mcam_idx, req->hdr.pcifunc);\n\tif (rc) {\n\t\tdev_err(rvu->dev, \"%s MAC (%pM) add PF=%d failed\\n\", __func__,\n\t\t\treq->mac_addr, pf);\n\t\treturn LMAC_AF_ERR_EXACT_MATCH_TBL_ADD_FAILED;\n\t}\n\n\trsp->index = seq_id;\n\tdev_dbg(rvu->dev,\n\t\t\"%s MAC (new:%pM, old=%pM default:%pM) del and add to PF=%d success (seq_id=%u)\\n\",\n\t\t__func__, req->mac_addr, pfvf->mac_addr, pfvf->default_mac, pf, seq_id);\n\n\tether_addr_copy(pfvf->mac_addr, req->mac_addr);\n\treturn 0;\n}\n\n \nint rvu_npc_exact_mac_addr_add(struct rvu *rvu,\n\t\t\t       struct cgx_mac_addr_add_req *req,\n\t\t\t       struct cgx_mac_addr_add_rsp *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tstruct rvu_pfvf *pfvf;\n\tu8 cgx_id, lmac_id;\n\tint rc = 0;\n\tu32 seq_id;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\tpfvf = rvu_get_pfvf(rvu, req->hdr.pcifunc);\n\n\trc = rvu_npc_exact_add_table_entry(rvu, cgx_id, lmac_id, req->mac_addr,\n\t\t\t\t\t   pfvf->rx_chan_base, 0, &seq_id,\n\t\t\t\t\t   true, -1, req->hdr.pcifunc);\n\n\tif (!rc) {\n\t\trsp->index = seq_id;\n\t\tdev_dbg(rvu->dev, \"%s MAC (%pM) add to PF=%d success (seq_id=%u)\\n\",\n\t\t\t__func__, req->mac_addr, pf, seq_id);\n\t\treturn 0;\n\t}\n\n\tdev_err(rvu->dev, \"%s MAC (%pM) add to PF=%d failed\\n\", __func__,\n\t\treq->mac_addr, pf);\n\treturn LMAC_AF_ERR_EXACT_MATCH_TBL_ADD_FAILED;\n}\n\n \nint rvu_npc_exact_mac_addr_del(struct rvu *rvu,\n\t\t\t       struct cgx_mac_addr_del_req *req,\n\t\t\t       struct msg_rsp *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tint rc;\n\n\trc = rvu_npc_exact_del_table_entry_by_id(rvu, req->index);\n\tif (!rc) {\n\t\tdev_dbg(rvu->dev, \"%s del to PF=%d success (seq_id=%u)\\n\",\n\t\t\t__func__, pf, req->index);\n\t\treturn 0;\n\t}\n\n\tdev_err(rvu->dev, \"%s del to PF=%d failed (seq_id=%u)\\n\",\n\t\t__func__,  pf, req->index);\n\treturn LMAC_AF_ERR_EXACT_MATCH_TBL_DEL_FAILED;\n}\n\n \nint rvu_npc_exact_mac_addr_set(struct rvu *rvu, struct cgx_mac_addr_set_or_get *req,\n\t\t\t       struct cgx_mac_addr_set_or_get *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu32 seq_id = req->index;\n\tstruct rvu_pfvf *pfvf;\n\tu8 cgx_id, lmac_id;\n\tu32 mcam_idx = -1;\n\tint rc, nixlf;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\n\tpfvf = &rvu->pf[pf];\n\n\t \n\trc = rvu_npc_exact_update_table_entry(rvu, cgx_id, lmac_id, pfvf->mac_addr,\n\t\t\t\t\t      req->mac_addr, &seq_id);\n\tif (!rc) {\n\t\trsp->index = seq_id;\n\t\tether_addr_copy(pfvf->mac_addr, req->mac_addr);\n\t\tether_addr_copy(rsp->mac_addr, req->mac_addr);\n\t\tdev_dbg(rvu->dev, \"%s MAC (%pM) update to PF=%d success\\n\",\n\t\t\t__func__, req->mac_addr, pf);\n\t\treturn 0;\n\t}\n\n\t \n\trc = rvu_npc_exact_del_table_entry_by_id(rvu, req->index);\n\tif (rc) {\n\t\tdev_dbg(rvu->dev, \"%s MAC (%pM) del PF=%d failed\\n\",\n\t\t\t__func__, pfvf->mac_addr, pf);\n\t}\n\n\t \n\trc = nix_get_nixlf(rvu, req->hdr.pcifunc, &nixlf, NULL);\n\tif (!rc) {\n\t\tmcam_idx = npc_get_nixlf_mcam_index(&rvu->hw->mcam, req->hdr.pcifunc,\n\t\t\t\t\t\t    nixlf, NIXLF_UCAST_ENTRY);\n\t}\n\n\trc = rvu_npc_exact_add_table_entry(rvu, cgx_id, lmac_id, req->mac_addr,\n\t\t\t\t\t   pfvf->rx_chan_base, 0, &seq_id,\n\t\t\t\t\t   true, mcam_idx, req->hdr.pcifunc);\n\tif (rc) {\n\t\tdev_err(rvu->dev, \"%s MAC (%pM) add PF=%d failed\\n\",\n\t\t\t__func__, req->mac_addr, pf);\n\t\treturn LMAC_AF_ERR_EXACT_MATCH_TBL_ADD_FAILED;\n\t}\n\n\trsp->index = seq_id;\n\tether_addr_copy(rsp->mac_addr, req->mac_addr);\n\tether_addr_copy(pfvf->mac_addr, req->mac_addr);\n\tdev_dbg(rvu->dev,\n\t\t\"%s MAC (%pM) del and add to PF=%d success (seq_id=%u)\\n\",\n\t\t__func__, req->mac_addr, pf, seq_id);\n\treturn 0;\n}\n\n \nbool rvu_npc_exact_can_disable_feature(struct rvu *rvu)\n{\n\tstruct npc_exact_table *table = rvu->hw->table;\n\tbool empty;\n\n\tif (!rvu->hw->cap.npc_exact_match_enabled)\n\t\treturn false;\n\n\tmutex_lock(&table->lock);\n\tempty = list_empty(&table->lhead_gbl);\n\tmutex_unlock(&table->lock);\n\n\treturn empty;\n}\n\n \nvoid rvu_npc_exact_disable_feature(struct rvu *rvu)\n{\n\trvu->hw->cap.npc_exact_match_enabled = false;\n}\n\n \nvoid rvu_npc_exact_reset(struct rvu *rvu, u16 pcifunc)\n{\n\tstruct npc_exact_table *table = rvu->hw->table;\n\tstruct npc_exact_table_entry *tmp, *iter;\n\tu32 seq_id;\n\n\tmutex_lock(&table->lock);\n\tlist_for_each_entry_safe(iter, tmp, &table->lhead_gbl, glist) {\n\t\tif (pcifunc != iter->pcifunc)\n\t\t\tcontinue;\n\n\t\tseq_id = iter->seq_id;\n\t\tdev_dbg(rvu->dev, \"%s: resetting pcifun=%d seq_id=%u\\n\", __func__,\n\t\t\tpcifunc, seq_id);\n\n\t\tmutex_unlock(&table->lock);\n\t\trvu_npc_exact_del_table_entry_by_id(rvu, seq_id);\n\t\tmutex_lock(&table->lock);\n\t}\n\tmutex_unlock(&table->lock);\n}\n\n \nint rvu_npc_exact_init(struct rvu *rvu)\n{\n\tu64 bcast_mcast_val, bcast_mcast_mask;\n\tstruct npc_exact_table *table;\n\tu64 exact_val, exact_mask;\n\tu64 chan_val, chan_mask;\n\tu8 cgx_id, lmac_id;\n\tu32 *drop_mcam_idx;\n\tu16 max_lmac_cnt;\n\tu64 npc_const3;\n\tint table_size;\n\tint blkaddr;\n\tu16 pcifunc;\n\tint err, i;\n\tu64 cfg;\n\tbool rc;\n\n\t \n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0) {\n\t\tdev_err(rvu->dev, \"%s: NPC block not implemented\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnpc_const3 = rvu_read64(rvu, blkaddr, NPC_AF_CONST3);\n\tif (!(npc_const3 & BIT_ULL(62)))\n\t\treturn 0;\n\n\t \n\tcfg = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_RX));\n\tif (!(cfg & NPC_EXACT_NIBBLE_HIT))\n\t\treturn 0;\n\n\t \n\trvu->hw->cap.npc_exact_match_enabled = true;\n\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(rvu->dev, \"%s: Memory allocation for table success\\n\", __func__);\n\trvu->hw->table = table;\n\n\t \n\ttable->mem_table.ways = FIELD_GET(GENMASK_ULL(19, 16), npc_const3);\n\ttable->mem_table.depth = FIELD_GET(GENMASK_ULL(15, 0), npc_const3);\n\ttable->cam_table.depth = FIELD_GET(GENMASK_ULL(31, 24), npc_const3);\n\n\tdev_dbg(rvu->dev, \"%s: NPC exact match 4way_2k table(ways=%d, depth=%d)\\n\",\n\t\t__func__,  table->mem_table.ways, table->cam_table.depth);\n\n\t \n\tif ((table->mem_table.depth & (table->mem_table.depth - 1)) != 0) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"%s: NPC exact match 4way_2k table depth(%d) is not square of 2\\n\",\n\t\t\t__func__,  table->mem_table.depth);\n\t\treturn -EINVAL;\n\t}\n\n\ttable_size = table->mem_table.depth * table->mem_table.ways;\n\n\t \n\ttable->mem_table.bmap = devm_bitmap_zalloc(rvu->dev, table_size,\n\t\t\t\t\t\t   GFP_KERNEL);\n\tif (!table->mem_table.bmap)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(rvu->dev, \"%s: Allocated bitmap for 4way 2K entry table\\n\", __func__);\n\n\t \n\ttable->cam_table.bmap = devm_bitmap_zalloc(rvu->dev, 32, GFP_KERNEL);\n\n\tif (!table->cam_table.bmap)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(rvu->dev, \"%s: Allocated bitmap for 32 entry cam\\n\", __func__);\n\n\ttable->tot_ids = table_size + table->cam_table.depth;\n\ttable->id_bmap = devm_bitmap_zalloc(rvu->dev, table->tot_ids,\n\t\t\t\t\t    GFP_KERNEL);\n\n\tif (!table->id_bmap)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(rvu->dev, \"%s: Allocated bitmap for id map (total=%d)\\n\",\n\t\t__func__, table->tot_ids);\n\n\t \n\tfor (i = 0; i < NPC_EXACT_TBL_MAX_WAYS; i++)\n\t\tINIT_LIST_HEAD(&table->lhead_mem_tbl_entry[i]);\n\n\tINIT_LIST_HEAD(&table->lhead_cam_tbl_entry);\n\tINIT_LIST_HEAD(&table->lhead_gbl);\n\n\tmutex_init(&table->lock);\n\n\trvu_exact_config_secret_key(rvu);\n\trvu_exact_config_search_key(rvu);\n\n\trvu_exact_config_table_mask(rvu);\n\trvu_exact_config_result_ctrl(rvu, table->mem_table.depth);\n\n\t \n\texact_val = !NPC_EXACT_RESULT_HIT;\n\texact_mask = NPC_EXACT_RESULT_HIT;\n\n\t \n\tbcast_mcast_val = 0b0000;\n\tbcast_mcast_mask = 0b0011;\n\n\t \n\tdrop_mcam_idx = &table->num_drop_rules;\n\n\tmax_lmac_cnt = rvu->cgx_cnt_max * rvu->hw->lmac_per_cgx +\n\t\t       PF_CGXMAP_BASE;\n\n\tfor (i = PF_CGXMAP_BASE; i < max_lmac_cnt; i++) {\n\t\tif (rvu->pf2cgxlmac_map[i] == 0xFF)\n\t\t\tcontinue;\n\n\t\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[i], &cgx_id, &lmac_id);\n\n\t\trc = rvu_npc_exact_calc_drop_rule_chan_and_mask(rvu, NIX_INTF_TYPE_CGX, cgx_id,\n\t\t\t\t\t\t\t\tlmac_id, &chan_val, &chan_mask);\n\t\tif (!rc) {\n\t\t\tdev_err(rvu->dev,\n\t\t\t\t\"%s: failed, info chan_val=0x%llx chan_mask=0x%llx rule_id=%d\\n\",\n\t\t\t\t__func__, chan_val, chan_mask, *drop_mcam_idx);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tpcifunc = RVU_PFFUNC(i, 0);\n\n\t\tdev_dbg(rvu->dev,\n\t\t\t\"%s:Drop rule cgx=%d lmac=%d chan(val=0x%llx, mask=0x%llx\\n\",\n\t\t\t__func__, cgx_id, lmac_id, chan_val, chan_mask);\n\n\t\trc = rvu_npc_exact_save_drop_rule_chan_and_mask(rvu, table->num_drop_rules,\n\t\t\t\t\t\t\t\tchan_val, chan_mask, pcifunc);\n\t\tif (!rc) {\n\t\t\tdev_err(rvu->dev,\n\t\t\t\t\"%s: failed to set drop info for cgx=%d, lmac=%d, chan=%llx\\n\",\n\t\t\t\t__func__, cgx_id, lmac_id, chan_val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = npc_install_mcam_drop_rule(rvu, *drop_mcam_idx,\n\t\t\t\t\t\t &table->counter_idx[*drop_mcam_idx],\n\t\t\t\t\t\t chan_val, chan_mask,\n\t\t\t\t\t\t exact_val, exact_mask,\n\t\t\t\t\t\t bcast_mcast_val, bcast_mcast_mask);\n\t\tif (err) {\n\t\t\tdev_err(rvu->dev,\n\t\t\t\t\"failed to configure drop rule (cgx=%d lmac=%d)\\n\",\n\t\t\t\tcgx_id, lmac_id);\n\t\t\treturn err;\n\t\t}\n\n\t\t(*drop_mcam_idx)++;\n\t}\n\n\tdev_info(rvu->dev, \"initialized exact match table successfully\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}