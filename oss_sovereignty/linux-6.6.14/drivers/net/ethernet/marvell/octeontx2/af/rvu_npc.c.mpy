{
  "module_name": "rvu_npc.c",
  "hash_id": "c8f6206e174949d2b37194185345ea08a82d05c1445fd6f305c9fc788c1c4c2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"rvu_struct.h\"\n#include \"rvu_reg.h\"\n#include \"rvu.h\"\n#include \"npc.h\"\n#include \"cgx.h\"\n#include \"npc_profile.h\"\n#include \"rvu_npc_hash.h\"\n\n#define RSVD_MCAM_ENTRIES_PER_PF\t3  \n#define RSVD_MCAM_ENTRIES_PER_NIXLF\t1  \n\n#define NPC_PARSE_RESULT_DMAC_OFFSET\t8\n#define NPC_HW_TSTAMP_OFFSET\t\t8ULL\n#define NPC_KEX_CHAN_MASK\t\t0xFFFULL\n#define NPC_KEX_PF_FUNC_MASK\t\t0xFFFFULL\n\n#define ALIGN_8B_CEIL(__a)\t(((__a) + 7) & (-8))\n\nstatic const char def_pfl_name[] = \"default\";\n\nstatic void npc_mcam_free_all_entries(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t\t      int blkaddr, u16 pcifunc);\nstatic void npc_mcam_free_all_counters(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t\t       u16 pcifunc);\n\nbool is_npc_intf_tx(u8 intf)\n{\n\treturn !!(intf & 0x1);\n}\n\nbool is_npc_intf_rx(u8 intf)\n{\n\treturn !(intf & 0x1);\n}\n\nbool is_npc_interface_valid(struct rvu *rvu, u8 intf)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\n\treturn intf < hw->npc_intfs;\n}\n\nint rvu_npc_get_tx_nibble_cfg(struct rvu *rvu, u64 nibble_ena)\n{\n\t \n\tif (is_rvu_96xx_B0(rvu))\n\t\treturn nibble_ena;\n\treturn 0;\n}\n\nstatic int npc_mcam_verify_pf_func(struct rvu *rvu,\n\t\t\t\t   struct mcam_entry *entry_data, u8 intf,\n\t\t\t\t   u16 pcifunc)\n{\n\tu16 pf_func, pf_func_mask;\n\n\tif (is_npc_intf_rx(intf))\n\t\treturn 0;\n\n\tpf_func_mask = (entry_data->kw_mask[0] >> 32) &\n\t\tNPC_KEX_PF_FUNC_MASK;\n\tpf_func = (entry_data->kw[0] >> 32) & NPC_KEX_PF_FUNC_MASK;\n\n\tpf_func = be16_to_cpu((__force __be16)pf_func);\n\tif (pf_func_mask != NPC_KEX_PF_FUNC_MASK ||\n\t    ((pf_func & ~RVU_PFVF_FUNC_MASK) !=\n\t     (pcifunc & ~RVU_PFVF_FUNC_MASK)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nvoid rvu_npc_set_pkind(struct rvu *rvu, int pkind, struct rvu_pfvf *pfvf)\n{\n\tint blkaddr;\n\tu64 val = 0;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\t \n\tval = pkind | 1ULL << 62;\n\trvu_write64(rvu, blkaddr, NPC_AF_PKINDX_CPI_DEFX(pkind, 0), val);\n}\n\nint rvu_npc_get_pkind(struct rvu *rvu, u16 pf)\n{\n\tstruct npc_pkind *pkind = &rvu->hw->pkind;\n\tu32 map;\n\tint i;\n\n\tfor (i = 0; i < pkind->rsrc.max; i++) {\n\t\tmap = pkind->pfchan_map[i];\n\t\tif (((map >> 16) & 0x3F) == pf)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n#define NPC_AF_ACTION0_PTR_ADVANCE\tGENMASK_ULL(27, 20)\n\nint npc_config_ts_kpuaction(struct rvu *rvu, int pf, u16 pcifunc, bool enable)\n{\n\tint pkind, blkaddr;\n\tu64 val;\n\n\tpkind = rvu_npc_get_pkind(rvu, pf);\n\tif (pkind < 0) {\n\t\tdev_err(rvu->dev, \"%s: pkind not mapped\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, pcifunc);\n\tif (blkaddr < 0) {\n\t\tdev_err(rvu->dev, \"%s: NPC block not implemented\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tval = rvu_read64(rvu, blkaddr, NPC_AF_PKINDX_ACTION0(pkind));\n\tval &= ~NPC_AF_ACTION0_PTR_ADVANCE;\n\t \n\tif (enable)\n\t\tval |= FIELD_PREP(NPC_AF_ACTION0_PTR_ADVANCE,\n\t\t\t\t  NPC_HW_TSTAMP_OFFSET);\n\trvu_write64(rvu, blkaddr, NPC_AF_PKINDX_ACTION0(pkind), val);\n\n\treturn 0;\n}\n\nstatic int npc_get_ucast_mcam_index(struct npc_mcam *mcam, u16 pcifunc,\n\t\t\t\t    int nixlf)\n{\n\tstruct rvu_hwinfo *hw = container_of(mcam, struct rvu_hwinfo, mcam);\n\tstruct rvu *rvu = hw->rvu;\n\tint blkaddr = 0, max = 0;\n\tstruct rvu_block *block;\n\tstruct rvu_pfvf *pfvf;\n\n\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\t \n\tblkaddr = rvu_get_next_nix_blkaddr(rvu, blkaddr);\n\twhile (blkaddr) {\n\t\tif (pfvf->nix_blkaddr == blkaddr)\n\t\t\tbreak;\n\t\tblock = &rvu->hw->block[blkaddr];\n\t\tmax += block->lf.max;\n\t\tblkaddr = rvu_get_next_nix_blkaddr(rvu, blkaddr);\n\t}\n\n\treturn mcam->nixlf_offset + (max + nixlf) * RSVD_MCAM_ENTRIES_PER_NIXLF;\n}\n\nint npc_get_nixlf_mcam_index(struct npc_mcam *mcam,\n\t\t\t     u16 pcifunc, int nixlf, int type)\n{\n\tint pf = rvu_get_pf(pcifunc);\n\tint index;\n\n\t \n\tif (pf && !(pcifunc & RVU_PFVF_FUNC_MASK)) {\n\t\t \n\t\tpf--;\n\t\tindex = mcam->pf_offset + (pf * RSVD_MCAM_ENTRIES_PER_PF);\n\t\t \n\t\tif (type == NIXLF_BCAST_ENTRY)\n\t\t\treturn index;\n\t\telse if (type == NIXLF_ALLMULTI_ENTRY)\n\t\t\treturn index + 1;\n\t\telse if (type == NIXLF_PROMISC_ENTRY)\n\t\t\treturn index + 2;\n\t}\n\n\treturn npc_get_ucast_mcam_index(mcam, pcifunc, nixlf);\n}\n\nint npc_get_bank(struct npc_mcam *mcam, int index)\n{\n\tint bank = index / mcam->banksize;\n\n\t \n\tif (mcam->keysize == NPC_MCAM_KEY_X2)\n\t\treturn bank ? 2 : 0;\n\n\treturn bank;\n}\n\nbool is_mcam_entry_enabled(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t   int blkaddr, int index)\n{\n\tint bank = npc_get_bank(mcam, index);\n\tu64 cfg;\n\n\tindex &= (mcam->banksize - 1);\n\tcfg = rvu_read64(rvu, blkaddr, NPC_AF_MCAMEX_BANKX_CFG(index, bank));\n\treturn (cfg & 1);\n}\n\nvoid npc_enable_mcam_entry(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t   int blkaddr, int index, bool enable)\n{\n\tint bank = npc_get_bank(mcam, index);\n\tint actbank = bank;\n\n\tindex &= (mcam->banksize - 1);\n\tfor (; bank < (actbank + mcam->banks_per_entry); bank++) {\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_MCAMEX_BANKX_CFG(index, bank),\n\t\t\t    enable ? 1 : 0);\n\t}\n}\n\nstatic void npc_clear_mcam_entry(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t\t int blkaddr, int index)\n{\n\tint bank = npc_get_bank(mcam, index);\n\tint actbank = bank;\n\n\tindex &= (mcam->banksize - 1);\n\tfor (; bank < (actbank + mcam->banks_per_entry); bank++) {\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_MCAMEX_BANKX_CAMX_INTF(index, bank, 1), 0);\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_MCAMEX_BANKX_CAMX_INTF(index, bank, 0), 0);\n\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_MCAMEX_BANKX_CAMX_W0(index, bank, 1), 0);\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_MCAMEX_BANKX_CAMX_W0(index, bank, 0), 0);\n\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_MCAMEX_BANKX_CAMX_W1(index, bank, 1), 0);\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_MCAMEX_BANKX_CAMX_W1(index, bank, 0), 0);\n\t}\n}\n\nstatic void npc_get_keyword(struct mcam_entry *entry, int idx,\n\t\t\t    u64 *cam0, u64 *cam1)\n{\n\tu64 kw_mask = 0x00;\n\n#define CAM_MASK(n)\t(BIT_ULL(n) - 1)\n\n\t \n\tswitch (idx) {\n\tcase 0:\n\t\t \n\t\t*cam1 = entry->kw[0];\n\t\tkw_mask = entry->kw_mask[0];\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\t*cam1 = entry->kw[1] & CAM_MASK(48);\n\t\tkw_mask = entry->kw_mask[1] & CAM_MASK(48);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\t*cam1 = (entry->kw[1] >> 48) & CAM_MASK(16);\n\t\t*cam1 |= ((entry->kw[2] & CAM_MASK(48)) << 16);\n\t\tkw_mask = (entry->kw_mask[1] >> 48) & CAM_MASK(16);\n\t\tkw_mask |= ((entry->kw_mask[2] & CAM_MASK(48)) << 16);\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\t*cam1 = (entry->kw[2] >> 48) & CAM_MASK(16);\n\t\t*cam1 |= ((entry->kw[3] & CAM_MASK(32)) << 16);\n\t\tkw_mask = (entry->kw_mask[2] >> 48) & CAM_MASK(16);\n\t\tkw_mask |= ((entry->kw_mask[3] & CAM_MASK(32)) << 16);\n\t\tbreak;\n\tcase 4:\n\t\t \n\t\t*cam1 = (entry->kw[3] >> 32) & CAM_MASK(32);\n\t\t*cam1 |= ((entry->kw[4] & CAM_MASK(32)) << 32);\n\t\tkw_mask = (entry->kw_mask[3] >> 32) & CAM_MASK(32);\n\t\tkw_mask |= ((entry->kw_mask[4] & CAM_MASK(32)) << 32);\n\t\tbreak;\n\tcase 5:\n\t\t \n\t\t*cam1 = (entry->kw[4] >> 32) & CAM_MASK(32);\n\t\t*cam1 |= ((entry->kw[5] & CAM_MASK(16)) << 32);\n\t\tkw_mask = (entry->kw_mask[4] >> 32) & CAM_MASK(32);\n\t\tkw_mask |= ((entry->kw_mask[5] & CAM_MASK(16)) << 32);\n\t\tbreak;\n\tcase 6:\n\t\t \n\t\t*cam1 = (entry->kw[5] >> 16) & CAM_MASK(48);\n\t\t*cam1 |= ((entry->kw[6] & CAM_MASK(16)) << 48);\n\t\tkw_mask = (entry->kw_mask[5] >> 16) & CAM_MASK(48);\n\t\tkw_mask |= ((entry->kw_mask[6] & CAM_MASK(16)) << 48);\n\t\tbreak;\n\tcase 7:\n\t\t \n\t\t*cam1 = (entry->kw[6] >> 16) & CAM_MASK(48);\n\t\tkw_mask = (entry->kw_mask[6] >> 16) & CAM_MASK(48);\n\t\tbreak;\n\t}\n\n\t*cam1 &= kw_mask;\n\t*cam0 = ~*cam1 & kw_mask;\n}\n\nstatic void npc_fill_entryword(struct mcam_entry *entry, int idx,\n\t\t\t       u64 cam0, u64 cam1)\n{\n\t \n\tswitch (idx) {\n\tcase 0:\n\t\tentry->kw[0] = cam1;\n\t\tentry->kw_mask[0] = cam1 ^ cam0;\n\t\tbreak;\n\tcase 1:\n\t\tentry->kw[1] = cam1;\n\t\tentry->kw_mask[1] = cam1 ^ cam0;\n\t\tbreak;\n\tcase 2:\n\t\tentry->kw[1] |= (cam1 & CAM_MASK(16)) << 48;\n\t\tentry->kw[2] = (cam1 >> 16) & CAM_MASK(48);\n\t\tentry->kw_mask[1] |= ((cam1 ^ cam0) & CAM_MASK(16)) << 48;\n\t\tentry->kw_mask[2] = ((cam1 ^ cam0) >> 16) & CAM_MASK(48);\n\t\tbreak;\n\tcase 3:\n\t\tentry->kw[2] |= (cam1 & CAM_MASK(16)) << 48;\n\t\tentry->kw[3] = (cam1 >> 16) & CAM_MASK(32);\n\t\tentry->kw_mask[2] |= ((cam1 ^ cam0) & CAM_MASK(16)) << 48;\n\t\tentry->kw_mask[3] = ((cam1 ^ cam0) >> 16) & CAM_MASK(32);\n\t\tbreak;\n\tcase 4:\n\t\tentry->kw[3] |= (cam1 & CAM_MASK(32)) << 32;\n\t\tentry->kw[4] = (cam1 >> 32) & CAM_MASK(32);\n\t\tentry->kw_mask[3] |= ((cam1 ^ cam0) & CAM_MASK(32)) << 32;\n\t\tentry->kw_mask[4] = ((cam1 ^ cam0) >> 32) & CAM_MASK(32);\n\t\tbreak;\n\tcase 5:\n\t\tentry->kw[4] |= (cam1 & CAM_MASK(32)) << 32;\n\t\tentry->kw[5] = (cam1 >> 32) & CAM_MASK(16);\n\t\tentry->kw_mask[4] |= ((cam1 ^ cam0) & CAM_MASK(32)) << 32;\n\t\tentry->kw_mask[5] = ((cam1 ^ cam0) >> 32) & CAM_MASK(16);\n\t\tbreak;\n\tcase 6:\n\t\tentry->kw[5] |= (cam1 & CAM_MASK(48)) << 16;\n\t\tentry->kw[6] = (cam1 >> 48) & CAM_MASK(16);\n\t\tentry->kw_mask[5] |= ((cam1 ^ cam0) & CAM_MASK(48)) << 16;\n\t\tentry->kw_mask[6] = ((cam1 ^ cam0) >> 48) & CAM_MASK(16);\n\t\tbreak;\n\tcase 7:\n\t\tentry->kw[6] |= (cam1 & CAM_MASK(48)) << 16;\n\t\tentry->kw_mask[6] |= ((cam1 ^ cam0) & CAM_MASK(48)) << 16;\n\t\tbreak;\n\t}\n}\n\nstatic u64 npc_get_default_entry_action(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t\t\tint blkaddr, u16 pf_func)\n{\n\tint bank, nixlf, index;\n\n\t \n\tif (nix_get_nixlf(rvu, pf_func, &nixlf, NULL)) {\n\t\tdev_err(rvu->dev, \"%s: nixlf not attached to pcifunc:0x%x\\n\",\n\t\t\t__func__, pf_func);\n\t\t \n\t\treturn 0;\n\t}\n\n\tindex = npc_get_nixlf_mcam_index(mcam, pf_func, nixlf,\n\t\t\t\t\t NIXLF_UCAST_ENTRY);\n\tbank = npc_get_bank(mcam, index);\n\tindex &= (mcam->banksize - 1);\n\n\treturn rvu_read64(rvu, blkaddr,\n\t\t\t  NPC_AF_MCAMEX_BANKX_ACTION(index, bank));\n}\n\nstatic void npc_fixup_vf_rule(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t      int blkaddr, int index, struct mcam_entry *entry,\n\t\t\t      bool *enable)\n{\n\tstruct rvu_npc_mcam_rule *rule;\n\tu16 owner, target_func;\n\tstruct rvu_pfvf *pfvf;\n\tu64 rx_action;\n\n\towner = mcam->entry2pfvf_map[index];\n\ttarget_func = (entry->action >> 4) & 0xffff;\n\t \n\tif (is_pffunc_af(owner) || is_afvf(target_func) ||\n\t    (owner & RVU_PFVF_FUNC_MASK) ||\n\t    !(target_func & RVU_PFVF_FUNC_MASK))\n\t\treturn;\n\n\t \n\tpfvf = rvu_get_pfvf(rvu, target_func);\n\tmcam->entry2target_pffunc[index] = target_func;\n\n\t \n\tif (!(is_nixlf_attached(rvu, target_func) &&\n\t      test_bit(NIXLF_INITIALIZED, &pfvf->flags)))\n\t\t*enable = false;\n\n\t \n\tlist_for_each_entry(rule, &mcam->mcam_rules, list) {\n\t\tif (rule->entry == index)\n\t\t\treturn;\n\t}\n\n\t \n\trx_action = npc_get_default_entry_action(rvu, mcam, blkaddr,\n\t\t\t\t\t\t target_func);\n\tif (rx_action)\n\t\tentry->action = rx_action;\n}\n\nstatic void npc_config_mcam_entry(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t\t  int blkaddr, int index, u8 intf,\n\t\t\t\t  struct mcam_entry *entry, bool enable)\n{\n\tint bank = npc_get_bank(mcam, index);\n\tint kw = 0, actbank, actindex;\n\tu8 tx_intf_mask = ~intf & 0x3;\n\tu8 tx_intf = intf;\n\tu64 cam0, cam1;\n\n\tactbank = bank;  \n\tactindex = index;\n\tindex &= (mcam->banksize - 1);\n\n\t \n\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, actindex, false);\n\n\t \n\tnpc_clear_mcam_entry(rvu, mcam, blkaddr, actindex);\n\n\t \n\tfor (; bank < (actbank + mcam->banks_per_entry); bank++, kw = kw + 2) {\n\t\t \n\t\tif (is_npc_intf_tx(intf)) {\n\t\t\t \n\t\t\ttx_intf_mask = 0x1;\n\t\t\ttx_intf = intf & tx_intf_mask;\n\t\t\ttx_intf_mask = ~tx_intf & tx_intf_mask;\n\t\t}\n\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_MCAMEX_BANKX_CAMX_INTF(index, bank, 1),\n\t\t\t    tx_intf);\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_MCAMEX_BANKX_CAMX_INTF(index, bank, 0),\n\t\t\t    tx_intf_mask);\n\n\t\t \n\t\tnpc_get_keyword(entry, kw, &cam0, &cam1);\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_MCAMEX_BANKX_CAMX_W0(index, bank, 1), cam1);\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_MCAMEX_BANKX_CAMX_W0(index, bank, 0), cam0);\n\n\t\tnpc_get_keyword(entry, kw + 1, &cam0, &cam1);\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_MCAMEX_BANKX_CAMX_W1(index, bank, 1), cam1);\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_MCAMEX_BANKX_CAMX_W1(index, bank, 0), cam0);\n\t}\n\n\t \n\tif (is_npc_intf_rx(intf) && actindex < mcam->bmap_entries)\n\t\tnpc_fixup_vf_rule(rvu, mcam, blkaddr, actindex, entry, &enable);\n\n\t \n\trvu_write64(rvu, blkaddr,\n\t\t    NPC_AF_MCAMEX_BANKX_ACTION(index, actbank), entry->action);\n\n\t \n\trvu_write64(rvu, blkaddr, NPC_AF_MCAMEX_BANKX_TAG_ACT(index, actbank),\n\t\t    entry->vtag_action);\n\n\t \n\tif (enable)\n\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, actindex, true);\n}\n\nvoid npc_read_mcam_entry(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t int blkaddr, u16 src,\n\t\t\t struct mcam_entry *entry, u8 *intf, u8 *ena)\n{\n\tint sbank = npc_get_bank(mcam, src);\n\tint bank, kw = 0;\n\tu64 cam0, cam1;\n\n\tsrc &= (mcam->banksize - 1);\n\tbank = sbank;\n\n\tfor (; bank < (sbank + mcam->banks_per_entry); bank++, kw = kw + 2) {\n\t\tcam1 = rvu_read64(rvu, blkaddr,\n\t\t\t\t  NPC_AF_MCAMEX_BANKX_CAMX_W0(src, bank, 1));\n\t\tcam0 = rvu_read64(rvu, blkaddr,\n\t\t\t\t  NPC_AF_MCAMEX_BANKX_CAMX_W0(src, bank, 0));\n\t\tnpc_fill_entryword(entry, kw, cam0, cam1);\n\n\t\tcam1 = rvu_read64(rvu, blkaddr,\n\t\t\t\t  NPC_AF_MCAMEX_BANKX_CAMX_W1(src, bank, 1));\n\t\tcam0 = rvu_read64(rvu, blkaddr,\n\t\t\t\t  NPC_AF_MCAMEX_BANKX_CAMX_W1(src, bank, 0));\n\t\tnpc_fill_entryword(entry, kw + 1, cam0, cam1);\n\t}\n\n\tentry->action = rvu_read64(rvu, blkaddr,\n\t\t\t\t   NPC_AF_MCAMEX_BANKX_ACTION(src, sbank));\n\tentry->vtag_action =\n\t\trvu_read64(rvu, blkaddr,\n\t\t\t   NPC_AF_MCAMEX_BANKX_TAG_ACT(src, sbank));\n\t*intf = rvu_read64(rvu, blkaddr,\n\t\t\t   NPC_AF_MCAMEX_BANKX_CAMX_INTF(src, sbank, 1)) & 3;\n\t*ena = rvu_read64(rvu, blkaddr,\n\t\t\t  NPC_AF_MCAMEX_BANKX_CFG(src, sbank)) & 1;\n}\n\nstatic void npc_copy_mcam_entry(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t\tint blkaddr, u16 src, u16 dest)\n{\n\tint dbank = npc_get_bank(mcam, dest);\n\tint sbank = npc_get_bank(mcam, src);\n\tu64 cfg, sreg, dreg;\n\tint bank, i;\n\n\tsrc &= (mcam->banksize - 1);\n\tdest &= (mcam->banksize - 1);\n\n\t \n\tfor (bank = 0; bank < mcam->banks_per_entry; bank++) {\n\t\tsreg = NPC_AF_MCAMEX_BANKX_CAMX_INTF(src, sbank + bank, 0);\n\t\tdreg = NPC_AF_MCAMEX_BANKX_CAMX_INTF(dest, dbank + bank, 0);\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tcfg = rvu_read64(rvu, blkaddr, sreg + (i * 8));\n\t\t\trvu_write64(rvu, blkaddr, dreg + (i * 8), cfg);\n\t\t}\n\t}\n\n\t \n\tcfg = rvu_read64(rvu, blkaddr,\n\t\t\t NPC_AF_MCAMEX_BANKX_ACTION(src, sbank));\n\trvu_write64(rvu, blkaddr,\n\t\t    NPC_AF_MCAMEX_BANKX_ACTION(dest, dbank), cfg);\n\n\t \n\tcfg = rvu_read64(rvu, blkaddr,\n\t\t\t NPC_AF_MCAMEX_BANKX_TAG_ACT(src, sbank));\n\trvu_write64(rvu, blkaddr,\n\t\t    NPC_AF_MCAMEX_BANKX_TAG_ACT(dest, dbank), cfg);\n\n\t \n\tcfg = rvu_read64(rvu, blkaddr,\n\t\t\t NPC_AF_MCAMEX_BANKX_CFG(src, sbank));\n\trvu_write64(rvu, blkaddr,\n\t\t    NPC_AF_MCAMEX_BANKX_CFG(dest, dbank), cfg);\n}\n\nstatic u64 npc_get_mcam_action(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t       int blkaddr, int index)\n{\n\tint bank = npc_get_bank(mcam, index);\n\n\tindex &= (mcam->banksize - 1);\n\treturn rvu_read64(rvu, blkaddr,\n\t\t\t  NPC_AF_MCAMEX_BANKX_ACTION(index, bank));\n}\n\nvoid rvu_npc_install_ucast_entry(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t int nixlf, u64 chan, u8 *mac_addr)\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, pcifunc);\n\tstruct npc_install_flow_req req = { 0 };\n\tstruct npc_install_flow_rsp rsp = { 0 };\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct nix_rx_action action = { 0 };\n\tint blkaddr, index;\n\n\t \n\tif (is_afvf(pcifunc) || is_sdp_vf(pcifunc))\n\t\treturn;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\t \n\tif (!npc_is_feature_supported(rvu, BIT_ULL(NPC_DMAC), pfvf->nix_rx_intf))\n\t\treturn;\n\n\tindex = npc_get_nixlf_mcam_index(mcam, pcifunc,\n\t\t\t\t\t nixlf, NIXLF_UCAST_ENTRY);\n\n\t \n\tif (is_mcam_entry_enabled(rvu, mcam, blkaddr, index)) {\n\t\t*(u64 *)&action = npc_get_mcam_action(rvu, mcam,\n\t\t\t\t\t\t      blkaddr, index);\n\t} else {\n\t\taction.op = NIX_RX_ACTIONOP_UCAST;\n\t\taction.pf_func = pcifunc;\n\t}\n\n\treq.default_rule = 1;\n\tether_addr_copy(req.packet.dmac, mac_addr);\n\teth_broadcast_addr((u8 *)&req.mask.dmac);\n\treq.features = BIT_ULL(NPC_DMAC);\n\treq.channel = chan;\n\treq.chan_mask = 0xFFFU;\n\treq.intf = pfvf->nix_rx_intf;\n\treq.op = action.op;\n\treq.hdr.pcifunc = 0;  \n\treq.vf = action.pf_func;\n\treq.index = action.index;\n\treq.match_id = action.match_id;\n\treq.flow_key_alg = action.flow_key_alg;\n\n\trvu_mbox_handler_npc_install_flow(rvu, &req, &rsp);\n}\n\nvoid rvu_npc_install_promisc_entry(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t   int nixlf, u64 chan, u8 chan_cnt)\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, pcifunc);\n\tstruct npc_install_flow_req req = { 0 };\n\tstruct npc_install_flow_rsp rsp = { 0 };\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tint blkaddr, ucast_idx, index;\n\tstruct nix_rx_action action = { 0 };\n\tu64 relaxed_mask;\n\tu8 flow_key_alg;\n\n\tif (!hw->cap.nix_rx_multicast && is_cgx_vf(rvu, pcifunc))\n\t\treturn;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\tindex = npc_get_nixlf_mcam_index(mcam, pcifunc,\n\t\t\t\t\t nixlf, NIXLF_PROMISC_ENTRY);\n\n\tif (is_cgx_vf(rvu, pcifunc))\n\t\tindex = npc_get_nixlf_mcam_index(mcam,\n\t\t\t\t\t\t pcifunc & ~RVU_PFVF_FUNC_MASK,\n\t\t\t\t\t\t nixlf, NIXLF_PROMISC_ENTRY);\n\n\t \n\tucast_idx = npc_get_nixlf_mcam_index(mcam, pcifunc,\n\t\t\t\t\t     nixlf, NIXLF_UCAST_ENTRY);\n\tif (is_mcam_entry_enabled(rvu, mcam, blkaddr, ucast_idx))\n\t\t*(u64 *)&action = npc_get_mcam_action(rvu, mcam,\n\t\t\t\t\t\t      blkaddr, ucast_idx);\n\n\tif (action.op != NIX_RX_ACTIONOP_RSS) {\n\t\t*(u64 *)&action = 0;\n\t\taction.op = NIX_RX_ACTIONOP_UCAST;\n\t}\n\n\tflow_key_alg = action.flow_key_alg;\n\n\t \n\tif (hw->cap.nix_rx_multicast && pfvf->use_mce_list &&\n\t    is_pf_cgxmapped(rvu, rvu_get_pf(pcifunc))) {\n\t\t*(u64 *)&action = 0;\n\t\taction.op = NIX_RX_ACTIONOP_MCAST;\n\t\tpfvf = rvu_get_pfvf(rvu, pcifunc & ~RVU_PFVF_FUNC_MASK);\n\t\taction.index = pfvf->promisc_mce_idx;\n\t}\n\n\t \n\tif (!is_rvu_otx2(rvu)) {\n\t\treq.chan_mask = NIX_CHAN_CPT_X2P_MASK;\n\t} else {\n\t\treq.chan_mask = 0xFFFU;\n\t}\n\n\tif (chan_cnt > 1) {\n\t\tif (!is_power_of_2(chan_cnt)) {\n\t\t\tdev_err(rvu->dev,\n\t\t\t\t\"%s: channel count more than 1, must be power of 2\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\trelaxed_mask = GENMASK_ULL(BITS_PER_LONG_LONG - 1,\n\t\t\t\t\t   ilog2(chan_cnt));\n\t\treq.chan_mask &= relaxed_mask;\n\t}\n\n\treq.channel = chan;\n\treq.intf = pfvf->nix_rx_intf;\n\treq.entry = index;\n\treq.op = action.op;\n\treq.hdr.pcifunc = 0;  \n\treq.vf = pcifunc;\n\treq.index = action.index;\n\treq.match_id = action.match_id;\n\treq.flow_key_alg = flow_key_alg;\n\n\trvu_mbox_handler_npc_install_flow(rvu, &req, &rsp);\n}\n\nvoid rvu_npc_enable_promisc_entry(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t  int nixlf, bool enable)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tint blkaddr, index;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\t \n\tpcifunc = pcifunc & ~RVU_PFVF_FUNC_MASK;\n\n\tindex = npc_get_nixlf_mcam_index(mcam, pcifunc,\n\t\t\t\t\t nixlf, NIXLF_PROMISC_ENTRY);\n\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, index, enable);\n}\n\nvoid rvu_npc_install_bcast_match_entry(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t       int nixlf, u64 chan)\n{\n\tstruct rvu_pfvf *pfvf;\n\tstruct npc_install_flow_req req = { 0 };\n\tstruct npc_install_flow_rsp rsp = { 0 };\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tint blkaddr, index;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\t \n\tif (is_afvf(pcifunc))\n\t\treturn;\n\n\t \n\tif (!hw->cap.nix_rx_multicast && is_vf(pcifunc))\n\t\treturn;\n\n\t \n\tpcifunc = pcifunc & ~RVU_PFVF_FUNC_MASK;\n\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\n\t \n\tif (!npc_is_feature_supported(rvu, BIT_ULL(NPC_DMAC), pfvf->nix_rx_intf) &&\n\t    !npc_is_feature_supported(rvu, BIT_ULL(NPC_LXMB), pfvf->nix_rx_intf))\n\t\treturn;\n\n\tindex = npc_get_nixlf_mcam_index(mcam, pcifunc,\n\t\t\t\t\t nixlf, NIXLF_BCAST_ENTRY);\n\n\tif (!hw->cap.nix_rx_multicast) {\n\t\t \n\t\treq.op = NIX_RX_ACTIONOP_UCAST;\n\t} else {\n\t\treq.op = NIX_RX_ACTIONOP_MCAST;\n\t\treq.index = pfvf->bcast_mce_idx;\n\t}\n\n\teth_broadcast_addr((u8 *)&req.packet.dmac);\n\teth_broadcast_addr((u8 *)&req.mask.dmac);\n\treq.features = BIT_ULL(NPC_DMAC);\n\treq.channel = chan;\n\treq.chan_mask = 0xFFFU;\n\treq.intf = pfvf->nix_rx_intf;\n\treq.entry = index;\n\treq.hdr.pcifunc = 0;  \n\treq.vf = pcifunc;\n\n\trvu_mbox_handler_npc_install_flow(rvu, &req, &rsp);\n}\n\nvoid rvu_npc_enable_bcast_entry(struct rvu *rvu, u16 pcifunc, int nixlf,\n\t\t\t\tbool enable)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tint blkaddr, index;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\t \n\tpcifunc = pcifunc & ~RVU_PFVF_FUNC_MASK;\n\n\tindex = npc_get_nixlf_mcam_index(mcam, pcifunc, nixlf,\n\t\t\t\t\t NIXLF_BCAST_ENTRY);\n\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, index, enable);\n}\n\nvoid rvu_npc_install_allmulti_entry(struct rvu *rvu, u16 pcifunc, int nixlf,\n\t\t\t\t    u64 chan)\n{\n\tstruct npc_install_flow_req req = { 0 };\n\tstruct npc_install_flow_rsp rsp = { 0 };\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tint blkaddr, ucast_idx, index;\n\tu8 mac_addr[ETH_ALEN] = { 0 };\n\tstruct nix_rx_action action = { 0 };\n\tstruct rvu_pfvf *pfvf;\n\tu8 flow_key_alg;\n\tu16 vf_func;\n\n\t \n\tif (is_afvf(pcifunc) && is_sdp_vf(pcifunc))\n\t\treturn;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\t \n\tvf_func = pcifunc & RVU_PFVF_FUNC_MASK;\n\tpcifunc = pcifunc & ~RVU_PFVF_FUNC_MASK;\n\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\n\t \n\tif (!npc_is_feature_supported(rvu, BIT_ULL(NPC_DMAC), pfvf->nix_rx_intf) &&\n\t    !npc_is_feature_supported(rvu, BIT_ULL(NPC_LXMB), pfvf->nix_rx_intf))\n\t\treturn;\n\n\tindex = npc_get_nixlf_mcam_index(mcam, pcifunc,\n\t\t\t\t\t nixlf, NIXLF_ALLMULTI_ENTRY);\n\n\t \n\tucast_idx = npc_get_nixlf_mcam_index(mcam, pcifunc,\n\t\t\t\t\t     nixlf, NIXLF_UCAST_ENTRY);\n\tif (is_mcam_entry_enabled(rvu, mcam, blkaddr, ucast_idx))\n\t\t*(u64 *)&action = npc_get_mcam_action(rvu, mcam,\n\t\t\t\t\t\t\tblkaddr, ucast_idx);\n\n\tflow_key_alg = action.flow_key_alg;\n\tif (action.op != NIX_RX_ACTIONOP_RSS) {\n\t\t*(u64 *)&action = 0;\n\t\taction.op = NIX_RX_ACTIONOP_UCAST;\n\t\taction.pf_func = pcifunc;\n\t}\n\n\t \n\tif (hw->cap.nix_rx_multicast && pfvf->use_mce_list) {\n\t\t*(u64 *)&action = 0;\n\t\taction.op = NIX_RX_ACTIONOP_MCAST;\n\t\taction.index = pfvf->mcast_mce_idx;\n\t}\n\n\tmac_addr[0] = 0x01;\t \n\tether_addr_copy(req.packet.dmac, mac_addr);\n\tether_addr_copy(req.mask.dmac, mac_addr);\n\treq.features = BIT_ULL(NPC_DMAC);\n\n\t \n\tif (!is_rvu_otx2(rvu))\n\t\treq.chan_mask = NIX_CHAN_CPT_X2P_MASK;\n\telse\n\t\treq.chan_mask = 0xFFFU;\n\n\treq.channel = chan;\n\treq.intf = pfvf->nix_rx_intf;\n\treq.entry = index;\n\treq.op = action.op;\n\treq.hdr.pcifunc = 0;  \n\treq.vf = pcifunc | vf_func;\n\treq.index = action.index;\n\treq.match_id = action.match_id;\n\treq.flow_key_alg = flow_key_alg;\n\n\trvu_mbox_handler_npc_install_flow(rvu, &req, &rsp);\n}\n\nvoid rvu_npc_enable_allmulti_entry(struct rvu *rvu, u16 pcifunc, int nixlf,\n\t\t\t\t   bool enable)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tint blkaddr, index;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\t \n\tpcifunc = pcifunc & ~RVU_PFVF_FUNC_MASK;\n\n\tindex = npc_get_nixlf_mcam_index(mcam, pcifunc, nixlf,\n\t\t\t\t\t NIXLF_ALLMULTI_ENTRY);\n\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, index, enable);\n}\n\nstatic void npc_update_vf_flow_entry(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t\t     int blkaddr, u16 pcifunc, u64 rx_action)\n{\n\tint actindex, index, bank, entry;\n\tstruct rvu_npc_mcam_rule *rule;\n\tbool enable, update;\n\n\tif (!(pcifunc & RVU_PFVF_FUNC_MASK))\n\t\treturn;\n\n\tmutex_lock(&mcam->lock);\n\tfor (index = 0; index < mcam->bmap_entries; index++) {\n\t\tif (mcam->entry2target_pffunc[index] == pcifunc) {\n\t\t\tupdate = true;\n\t\t\t \n\t\t\tlist_for_each_entry(rule, &mcam->mcam_rules, list) {\n\t\t\t\tif (rule->entry == index)\n\t\t\t\t\tupdate = false;\n\t\t\t}\n\t\t\tif (!update)\n\t\t\t\tcontinue;\n\t\t\tbank = npc_get_bank(mcam, index);\n\t\t\tactindex = index;\n\t\t\tentry = index & (mcam->banksize - 1);\n\n\t\t\t \n\t\t\tenable = is_mcam_entry_enabled(rvu, mcam, blkaddr,\n\t\t\t\t\t\t       actindex);\n\t\t\t \n\t\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, actindex,\n\t\t\t\t\t      false);\n\t\t\t \n\t\t\trvu_write64(rvu, blkaddr,\n\t\t\t\t    NPC_AF_MCAMEX_BANKX_ACTION(entry, bank),\n\t\t\t\t    rx_action);\n\t\t\tif (enable)\n\t\t\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr,\n\t\t\t\t\t\t      actindex, true);\n\t\t}\n\t}\n\tmutex_unlock(&mcam->lock);\n}\n\nstatic void npc_update_rx_action_with_alg_idx(struct rvu *rvu, struct nix_rx_action action,\n\t\t\t\t\t      struct rvu_pfvf *pfvf, int mcam_index, int blkaddr,\n\t\t\t\t\t      int alg_idx)\n\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tint bank, op_rss;\n\n\tif (!is_mcam_entry_enabled(rvu, mcam, blkaddr, mcam_index))\n\t\treturn;\n\n\top_rss = (!hw->cap.nix_rx_multicast || !pfvf->use_mce_list);\n\n\tbank = npc_get_bank(mcam, mcam_index);\n\tmcam_index &= (mcam->banksize - 1);\n\n\t \n\tif (!op_rss) {\n\t\t*(u64 *)&action = rvu_read64(rvu, blkaddr,\n\t\t\t\tNPC_AF_MCAMEX_BANKX_ACTION(mcam_index, bank));\n\n\t\taction.flow_key_alg = alg_idx;\n\t}\n\trvu_write64(rvu, blkaddr,\n\t\t    NPC_AF_MCAMEX_BANKX_ACTION(mcam_index, bank), *(u64 *)&action);\n}\n\nvoid rvu_npc_update_flowkey_alg_idx(struct rvu *rvu, u16 pcifunc, int nixlf,\n\t\t\t\t    int group, int alg_idx, int mcam_index)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct nix_rx_action action;\n\tint blkaddr, index, bank;\n\tstruct rvu_pfvf *pfvf;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\t \n\tif (mcam_index < 0) {\n\t\tif (group != DEFAULT_RSS_CONTEXT_GROUP)\n\t\t\treturn;\n\t\tindex = npc_get_nixlf_mcam_index(mcam, pcifunc,\n\t\t\t\t\t\t nixlf, NIXLF_UCAST_ENTRY);\n\t} else {\n\t\t \n\t\tindex = mcam_index;\n\t}\n\n\tif (index >= mcam->total_entries)\n\t\treturn;\n\n\tbank = npc_get_bank(mcam, index);\n\tindex &= (mcam->banksize - 1);\n\n\t*(u64 *)&action = rvu_read64(rvu, blkaddr,\n\t\t\t\t     NPC_AF_MCAMEX_BANKX_ACTION(index, bank));\n\t \n\tif (!*(u64 *)&action)\n\t\treturn;\n\n\taction.op = NIX_RX_ACTIONOP_RSS;\n\taction.pf_func = pcifunc;\n\taction.index = group;\n\taction.flow_key_alg = alg_idx;\n\n\trvu_write64(rvu, blkaddr,\n\t\t    NPC_AF_MCAMEX_BANKX_ACTION(index, bank), *(u64 *)&action);\n\n\t \n\tif (mcam_index < 0)\n\t\tnpc_update_vf_flow_entry(rvu, mcam, blkaddr, pcifunc,\n\t\t\t\t\t *(u64 *)&action);\n\n\t \n\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\tif (pfvf->def_ucast_rule)\n\t\tpfvf->def_ucast_rule->rx_action = action;\n\n\tindex = npc_get_nixlf_mcam_index(mcam, pcifunc,\n\t\t\t\t\t nixlf, NIXLF_PROMISC_ENTRY);\n\n\t \n\tnpc_update_rx_action_with_alg_idx(rvu, action, pfvf, index, blkaddr,\n\t\t\t\t\t  alg_idx);\n\n\tindex = npc_get_nixlf_mcam_index(mcam, pcifunc,\n\t\t\t\t\t nixlf, NIXLF_ALLMULTI_ENTRY);\n\t \n\tnpc_update_rx_action_with_alg_idx(rvu, action, pfvf, index, blkaddr,\n\t\t\t\t\t  alg_idx);\n}\n\nvoid npc_enadis_default_mce_entry(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t  int nixlf, int type, bool enable)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tstruct nix_mce_list *mce_list;\n\tint index, blkaddr, mce_idx;\n\tstruct rvu_pfvf *pfvf;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\tindex = npc_get_nixlf_mcam_index(mcam, pcifunc & ~RVU_PFVF_FUNC_MASK,\n\t\t\t\t\t nixlf, type);\n\n\t \n\tif (!hw->cap.nix_rx_multicast && !is_vf(pcifunc)) {\n\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, index, enable);\n\t\treturn;\n\t}\n\n\t \n\tpfvf = rvu_get_pfvf(rvu, pcifunc & ~RVU_PFVF_FUNC_MASK);\n\tif (hw->cap.nix_rx_multicast && is_vf(pcifunc) &&\n\t    type != NIXLF_BCAST_ENTRY && !pfvf->use_mce_list)\n\t\treturn;\n\n\tnix_get_mce_list(rvu, pcifunc, type, &mce_list, &mce_idx);\n\n\tnix_update_mce_list(rvu, pcifunc, mce_list,\n\t\t\t    mce_idx, index, enable);\n\tif (enable)\n\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, index, enable);\n}\n\nstatic void npc_enadis_default_entries(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t       int nixlf, bool enable)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tint index, blkaddr;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\t \n\tindex = npc_get_nixlf_mcam_index(mcam, pcifunc,\n\t\t\t\t\t nixlf, NIXLF_UCAST_ENTRY);\n\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, index, enable);\n\n\t \n\tif ((pcifunc & RVU_PFVF_FUNC_MASK) && !rvu->hw->cap.nix_rx_multicast)\n\t\treturn;\n\n\t \n\tnpc_enadis_default_mce_entry(rvu, pcifunc, nixlf,\n\t\t\t\t     NIXLF_BCAST_ENTRY, enable);\n}\n\nvoid rvu_npc_disable_default_entries(struct rvu *rvu, u16 pcifunc, int nixlf)\n{\n\tif (nixlf < 0)\n\t\treturn;\n\n\tnpc_enadis_default_entries(rvu, pcifunc, nixlf, false);\n\n\t \n\tnpc_enadis_default_mce_entry(rvu, pcifunc, nixlf,\n\t\t\t\t     NIXLF_ALLMULTI_ENTRY, false);\n\tnpc_enadis_default_mce_entry(rvu, pcifunc, nixlf,\n\t\t\t\t     NIXLF_PROMISC_ENTRY, false);\n}\n\nbool rvu_npc_enable_mcam_by_entry_index(struct rvu *rvu, int entry, int intf, bool enable)\n{\n\tint blkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct rvu_npc_mcam_rule *rule, *tmp;\n\n\tmutex_lock(&mcam->lock);\n\n\tlist_for_each_entry_safe(rule, tmp, &mcam->mcam_rules, list) {\n\t\tif (rule->intf != intf)\n\t\t\tcontinue;\n\n\t\tif (rule->entry != entry)\n\t\t\tcontinue;\n\n\t\trule->enable = enable;\n\t\tmutex_unlock(&mcam->lock);\n\n\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr,\n\t\t\t\t      entry, enable);\n\n\t\treturn true;\n\t}\n\n\tmutex_unlock(&mcam->lock);\n\treturn false;\n}\n\nvoid rvu_npc_enable_default_entries(struct rvu *rvu, u16 pcifunc, int nixlf)\n{\n\tif (nixlf < 0)\n\t\treturn;\n\n\t \n\tnpc_enadis_default_entries(rvu, pcifunc, nixlf, true);\n}\n\nvoid rvu_npc_disable_mcam_entries(struct rvu *rvu, u16 pcifunc, int nixlf)\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, pcifunc);\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct rvu_npc_mcam_rule *rule, *tmp;\n\tint blkaddr;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\tmutex_lock(&mcam->lock);\n\n\t \n\tlist_for_each_entry_safe(rule, tmp, &mcam->mcam_rules, list) {\n\t\tif (is_npc_intf_rx(rule->intf) &&\n\t\t    rule->rx_action.pf_func == pcifunc &&\n\t\t    rule->rx_action.op != NIX_RX_ACTIONOP_MCAST) {\n\t\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr,\n\t\t\t\t\t      rule->entry, false);\n\t\t\trule->enable = false;\n\t\t\t \n\t\t\tif (rule->default_rule) {\n\t\t\t\tpfvf->def_ucast_rule = NULL;\n\t\t\t\tlist_del(&rule->list);\n\t\t\t\tkfree(rule);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&mcam->lock);\n\n\tnpc_mcam_disable_flows(rvu, pcifunc);\n\n\trvu_npc_disable_default_entries(rvu, pcifunc, nixlf);\n}\n\nvoid rvu_npc_free_mcam_entries(struct rvu *rvu, u16 pcifunc, int nixlf)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct rvu_npc_mcam_rule *rule, *tmp;\n\tint blkaddr;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\tmutex_lock(&mcam->lock);\n\n\t \n\tnpc_mcam_free_all_entries(rvu, mcam, blkaddr, pcifunc);\n\n\t \n\tnpc_mcam_free_all_counters(rvu, mcam, pcifunc);\n\n\t \n\tlist_for_each_entry_safe(rule, tmp, &mcam->mcam_rules, list) {\n\t\tif (rule->owner == pcifunc && !rule->default_rule) {\n\t\t\tlist_del(&rule->list);\n\t\t\tkfree(rule);\n\t\t}\n\t}\n\n\tmutex_unlock(&mcam->lock);\n\n\trvu_npc_disable_default_entries(rvu, pcifunc, nixlf);\n}\n\nstatic void npc_program_mkex_rx(struct rvu *rvu, int blkaddr,\n\t\t\t\tstruct npc_mcam_kex *mkex, u8 intf)\n{\n\tint lid, lt, ld, fl;\n\n\tif (is_npc_intf_tx(intf))\n\t\treturn;\n\n\trvu_write64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(intf),\n\t\t    mkex->keyx_cfg[NIX_INTF_RX]);\n\n\t \n\tfor (lid = 0; lid < NPC_MAX_LID; lid++) {\n\t\tfor (lt = 0; lt < NPC_MAX_LT; lt++) {\n\t\t\tfor (ld = 0; ld < NPC_MAX_LD; ld++)\n\t\t\t\tSET_KEX_LD(intf, lid, lt, ld,\n\t\t\t\t\t   mkex->intf_lid_lt_ld[NIX_INTF_RX]\n\t\t\t\t\t   [lid][lt][ld]);\n\t\t}\n\t}\n\t \n\tfor (ld = 0; ld < NPC_MAX_LD; ld++) {\n\t\tfor (fl = 0; fl < NPC_MAX_LFL; fl++)\n\t\t\tSET_KEX_LDFLAGS(intf, ld, fl,\n\t\t\t\t\tmkex->intf_ld_flags[NIX_INTF_RX]\n\t\t\t\t\t[ld][fl]);\n\t}\n}\n\nstatic void npc_program_mkex_tx(struct rvu *rvu, int blkaddr,\n\t\t\t\tstruct npc_mcam_kex *mkex, u8 intf)\n{\n\tint lid, lt, ld, fl;\n\n\tif (is_npc_intf_rx(intf))\n\t\treturn;\n\n\trvu_write64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(intf),\n\t\t    mkex->keyx_cfg[NIX_INTF_TX]);\n\n\t \n\tfor (lid = 0; lid < NPC_MAX_LID; lid++) {\n\t\tfor (lt = 0; lt < NPC_MAX_LT; lt++) {\n\t\t\tfor (ld = 0; ld < NPC_MAX_LD; ld++)\n\t\t\t\tSET_KEX_LD(intf, lid, lt, ld,\n\t\t\t\t\t   mkex->intf_lid_lt_ld[NIX_INTF_TX]\n\t\t\t\t\t   [lid][lt][ld]);\n\t\t}\n\t}\n\t \n\tfor (ld = 0; ld < NPC_MAX_LD; ld++) {\n\t\tfor (fl = 0; fl < NPC_MAX_LFL; fl++)\n\t\t\tSET_KEX_LDFLAGS(intf, ld, fl,\n\t\t\t\t\tmkex->intf_ld_flags[NIX_INTF_TX]\n\t\t\t\t\t[ld][fl]);\n\t}\n}\n\nstatic void npc_program_mkex_profile(struct rvu *rvu, int blkaddr,\n\t\t\t\t     struct npc_mcam_kex *mkex)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tu8 intf;\n\tint ld;\n\n\tfor (ld = 0; ld < NPC_MAX_LD; ld++)\n\t\trvu_write64(rvu, blkaddr, NPC_AF_KEX_LDATAX_FLAGS_CFG(ld),\n\t\t\t    mkex->kex_ld_flags[ld]);\n\n\tfor (intf = 0; intf < hw->npc_intfs; intf++) {\n\t\tnpc_program_mkex_rx(rvu, blkaddr, mkex, intf);\n\t\tnpc_program_mkex_tx(rvu, blkaddr, mkex, intf);\n\t}\n\n\t \n\tnpc_program_mkex_hash(rvu, blkaddr);\n}\n\nstatic int npc_fwdb_prfl_img_map(struct rvu *rvu, void __iomem **prfl_img_addr,\n\t\t\t\t u64 *size)\n{\n\tu64 prfl_addr, prfl_sz;\n\n\tif (!rvu->fwdata)\n\t\treturn -EINVAL;\n\n\tprfl_addr = rvu->fwdata->mcam_addr;\n\tprfl_sz = rvu->fwdata->mcam_sz;\n\n\tif (!prfl_addr || !prfl_sz)\n\t\treturn -EINVAL;\n\n\t*prfl_img_addr = ioremap_wc(prfl_addr, prfl_sz);\n\tif (!(*prfl_img_addr))\n\t\treturn -ENOMEM;\n\n\t*size = prfl_sz;\n\n\treturn 0;\n}\n\n \n#define MKEX_END_SIGN  0xdeadbeef\n\nstatic void npc_load_mkex_profile(struct rvu *rvu, int blkaddr,\n\t\t\t\t  const char *mkex_profile)\n{\n\tstruct device *dev = &rvu->pdev->dev;\n\tstruct npc_mcam_kex *mcam_kex;\n\tvoid __iomem *mkex_prfl_addr = NULL;\n\tu64 prfl_sz;\n\tint ret;\n\n\t \n\tif (rvu->kpu_fwdata_sz ||\n\t    !strncmp(mkex_profile, def_pfl_name, MKEX_NAME_LEN))\n\t\tgoto program_mkex;\n\n\t \n\tret = npc_fwdb_prfl_img_map(rvu, &mkex_prfl_addr, &prfl_sz);\n\tif (ret < 0)\n\t\tgoto program_mkex;\n\n\tmcam_kex = (struct npc_mcam_kex __force *)mkex_prfl_addr;\n\n\twhile (((s64)prfl_sz > 0) && (mcam_kex->mkex_sign != MKEX_END_SIGN)) {\n\t\t \n\t\tif (mcam_kex->mkex_sign == MKEX_SIGN &&\n\t\t    !strncmp(mcam_kex->name, mkex_profile, MKEX_NAME_LEN)) {\n\t\t\t \n\t\t\tif (!is_rvu_96xx_B0(rvu) ||\n\t\t\t    mcam_kex->keyx_cfg[NIX_INTF_RX] == mcam_kex->keyx_cfg[NIX_INTF_TX])\n\t\t\t\trvu->kpu.mkex = mcam_kex;\n\t\t\tgoto program_mkex;\n\t\t}\n\n\t\tmcam_kex++;\n\t\tprfl_sz -= sizeof(struct npc_mcam_kex);\n\t}\n\tdev_warn(dev, \"Failed to load requested profile: %s\\n\", mkex_profile);\n\nprogram_mkex:\n\tdev_info(rvu->dev, \"Using %s mkex profile\\n\", rvu->kpu.mkex->name);\n\t \n\tnpc_program_mkex_profile(rvu, blkaddr, rvu->kpu.mkex);\n\tif (mkex_prfl_addr)\n\t\tiounmap(mkex_prfl_addr);\n}\n\nstatic void npc_config_kpuaction(struct rvu *rvu, int blkaddr,\n\t\t\t\t const struct npc_kpu_profile_action *kpuaction,\n\t\t\t\t int kpu, int entry, bool pkind)\n{\n\tstruct npc_kpu_action0 action0 = {0};\n\tstruct npc_kpu_action1 action1 = {0};\n\tu64 reg;\n\n\taction1.errlev = kpuaction->errlev;\n\taction1.errcode = kpuaction->errcode;\n\taction1.dp0_offset = kpuaction->dp0_offset;\n\taction1.dp1_offset = kpuaction->dp1_offset;\n\taction1.dp2_offset = kpuaction->dp2_offset;\n\n\tif (pkind)\n\t\treg = NPC_AF_PKINDX_ACTION1(entry);\n\telse\n\t\treg = NPC_AF_KPUX_ENTRYX_ACTION1(kpu, entry);\n\n\trvu_write64(rvu, blkaddr, reg, *(u64 *)&action1);\n\n\taction0.byp_count = kpuaction->bypass_count;\n\taction0.capture_ena = kpuaction->cap_ena;\n\taction0.parse_done = kpuaction->parse_done;\n\taction0.next_state = kpuaction->next_state;\n\taction0.capture_lid = kpuaction->lid;\n\taction0.capture_ltype = kpuaction->ltype;\n\taction0.capture_flags = kpuaction->flags;\n\taction0.ptr_advance = kpuaction->ptr_advance;\n\taction0.var_len_offset = kpuaction->offset;\n\taction0.var_len_mask = kpuaction->mask;\n\taction0.var_len_right = kpuaction->right;\n\taction0.var_len_shift = kpuaction->shift;\n\n\tif (pkind)\n\t\treg = NPC_AF_PKINDX_ACTION0(entry);\n\telse\n\t\treg = NPC_AF_KPUX_ENTRYX_ACTION0(kpu, entry);\n\n\trvu_write64(rvu, blkaddr, reg, *(u64 *)&action0);\n}\n\nstatic void npc_config_kpucam(struct rvu *rvu, int blkaddr,\n\t\t\t      const struct npc_kpu_profile_cam *kpucam,\n\t\t\t      int kpu, int entry)\n{\n\tstruct npc_kpu_cam cam0 = {0};\n\tstruct npc_kpu_cam cam1 = {0};\n\n\tcam1.state = kpucam->state & kpucam->state_mask;\n\tcam1.dp0_data = kpucam->dp0 & kpucam->dp0_mask;\n\tcam1.dp1_data = kpucam->dp1 & kpucam->dp1_mask;\n\tcam1.dp2_data = kpucam->dp2 & kpucam->dp2_mask;\n\n\tcam0.state = ~kpucam->state & kpucam->state_mask;\n\tcam0.dp0_data = ~kpucam->dp0 & kpucam->dp0_mask;\n\tcam0.dp1_data = ~kpucam->dp1 & kpucam->dp1_mask;\n\tcam0.dp2_data = ~kpucam->dp2 & kpucam->dp2_mask;\n\n\trvu_write64(rvu, blkaddr,\n\t\t    NPC_AF_KPUX_ENTRYX_CAMX(kpu, entry, 0), *(u64 *)&cam0);\n\trvu_write64(rvu, blkaddr,\n\t\t    NPC_AF_KPUX_ENTRYX_CAMX(kpu, entry, 1), *(u64 *)&cam1);\n}\n\nstatic inline u64 enable_mask(int count)\n{\n\treturn (((count) < 64) ? ~(BIT_ULL(count) - 1) : (0x00ULL));\n}\n\nstatic void npc_program_kpu_profile(struct rvu *rvu, int blkaddr, int kpu,\n\t\t\t\t    const struct npc_kpu_profile *profile)\n{\n\tint entry, num_entries, max_entries;\n\tu64 entry_mask;\n\n\tif (profile->cam_entries != profile->action_entries) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"KPU%d: CAM and action entries [%d != %d] not equal\\n\",\n\t\t\tkpu, profile->cam_entries, profile->action_entries);\n\t}\n\n\tmax_entries = rvu->hw->npc_kpu_entries;\n\n\t \n\tnum_entries = min_t(int, profile->cam_entries, max_entries);\n\tfor (entry = 0; entry < num_entries; entry++)\n\t\tnpc_config_kpucam(rvu, blkaddr,\n\t\t\t\t  &profile->cam[entry], kpu, entry);\n\n\t \n\tnum_entries = min_t(int, profile->action_entries, max_entries);\n\tfor (entry = 0; entry < num_entries; entry++)\n\t\tnpc_config_kpuaction(rvu, blkaddr, &profile->action[entry],\n\t\t\t\t     kpu, entry, false);\n\n\t \n\tnum_entries = min_t(int, profile->action_entries, profile->cam_entries);\n\tentry_mask = enable_mask(num_entries);\n\t \n\tif (!rvu->kpu.custom)\n\t\tentry_mask |= GENMASK_ULL(KPU_MAX_CST_ENT - 1, 0);\n\trvu_write64(rvu, blkaddr,\n\t\t    NPC_AF_KPUX_ENTRY_DISX(kpu, 0), entry_mask);\n\tif (num_entries > 64) {\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_KPUX_ENTRY_DISX(kpu, 1),\n\t\t\t    enable_mask(num_entries - 64));\n\t}\n\n\t \n\trvu_write64(rvu, blkaddr, NPC_AF_KPUX_CFG(kpu), 0x01);\n}\n\nstatic int npc_prepare_default_kpu(struct npc_kpu_profile_adapter *profile)\n{\n\tprofile->custom = 0;\n\tprofile->name = def_pfl_name;\n\tprofile->version = NPC_KPU_PROFILE_VER;\n\tprofile->ikpu = ikpu_action_entries;\n\tprofile->pkinds = ARRAY_SIZE(ikpu_action_entries);\n\tprofile->kpu = npc_kpu_profiles;\n\tprofile->kpus = ARRAY_SIZE(npc_kpu_profiles);\n\tprofile->lt_def = &npc_lt_defaults;\n\tprofile->mkex = &npc_mkex_default;\n\tprofile->mkex_hash = &npc_mkex_hash_default;\n\n\treturn 0;\n}\n\nstatic int npc_apply_custom_kpu(struct rvu *rvu,\n\t\t\t\tstruct npc_kpu_profile_adapter *profile)\n{\n\tsize_t hdr_sz = sizeof(struct npc_kpu_profile_fwdata), offset = 0;\n\tstruct npc_kpu_profile_fwdata *fw = rvu->kpu_fwdata;\n\tstruct npc_kpu_profile_action *action;\n\tstruct npc_kpu_profile_cam *cam;\n\tstruct npc_kpu_fwdata *fw_kpu;\n\tint entries;\n\tu16 kpu, entry;\n\n\tif (rvu->kpu_fwdata_sz < hdr_sz) {\n\t\tdev_warn(rvu->dev, \"Invalid KPU profile size\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (le64_to_cpu(fw->signature) != KPU_SIGN) {\n\t\tdev_warn(rvu->dev, \"Invalid KPU profile signature %llx\\n\",\n\t\t\t fw->signature);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (NPC_KPU_VER_MAJ(profile->version) >\n\t    NPC_KPU_VER_MAJ(NPC_KPU_PROFILE_VER)) {\n\t\tdev_warn(rvu->dev, \"Not supported Major version: %d > %d\\n\",\n\t\t\t NPC_KPU_VER_MAJ(profile->version),\n\t\t\t NPC_KPU_VER_MAJ(NPC_KPU_PROFILE_VER));\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (NPC_KPU_VER_MIN(profile->version) <\n\t    NPC_KPU_VER_MIN(NPC_KPU_PROFILE_VER)) {\n\t\tdev_warn(rvu->dev,\n\t\t\t \"Invalid KPU profile version: %d.%d.%d expected version <= %d.%d.%d\\n\",\n\t\t\t NPC_KPU_VER_MAJ(profile->version),\n\t\t\t NPC_KPU_VER_MIN(profile->version),\n\t\t\t NPC_KPU_VER_PATCH(profile->version),\n\t\t\t NPC_KPU_VER_MAJ(NPC_KPU_PROFILE_VER),\n\t\t\t NPC_KPU_VER_MIN(NPC_KPU_PROFILE_VER),\n\t\t\t NPC_KPU_VER_PATCH(NPC_KPU_PROFILE_VER));\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (fw->kpus > profile->kpus) {\n\t\tdev_warn(rvu->dev, \"Not enough KPUs: %d > %ld\\n\", fw->kpus,\n\t\t\t profile->kpus);\n\t\treturn -EINVAL;\n\t}\n\n\tprofile->custom = 1;\n\tprofile->name = fw->name;\n\tprofile->version = le64_to_cpu(fw->version);\n\tprofile->mkex = &fw->mkex;\n\tprofile->lt_def = &fw->lt_def;\n\n\tfor (kpu = 0; kpu < fw->kpus; kpu++) {\n\t\tfw_kpu = (struct npc_kpu_fwdata *)(fw->data + offset);\n\t\tif (fw_kpu->entries > KPU_MAX_CST_ENT)\n\t\t\tdev_warn(rvu->dev,\n\t\t\t\t \"Too many custom entries on KPU%d: %d > %d\\n\",\n\t\t\t\t kpu, fw_kpu->entries, KPU_MAX_CST_ENT);\n\t\tentries = min(fw_kpu->entries, KPU_MAX_CST_ENT);\n\t\tcam = (struct npc_kpu_profile_cam *)fw_kpu->data;\n\t\toffset += sizeof(*fw_kpu) + fw_kpu->entries * sizeof(*cam);\n\t\taction = (struct npc_kpu_profile_action *)(fw->data + offset);\n\t\toffset += fw_kpu->entries * sizeof(*action);\n\t\tif (rvu->kpu_fwdata_sz < hdr_sz + offset) {\n\t\t\tdev_warn(rvu->dev,\n\t\t\t\t \"Profile size mismatch on KPU%i parsing.\\n\",\n\t\t\t\t kpu + 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (entry = 0; entry < entries; entry++) {\n\t\t\tprofile->kpu[kpu].cam[entry] = cam[entry];\n\t\t\tprofile->kpu[kpu].action[entry] = action[entry];\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int npc_load_kpu_prfl_img(struct rvu *rvu, void __iomem *prfl_addr,\n\t\t\t\t u64 prfl_sz, const char *kpu_profile)\n{\n\tstruct npc_kpu_profile_fwdata *kpu_data = NULL;\n\tint rc = -EINVAL;\n\n\tkpu_data = (struct npc_kpu_profile_fwdata __force *)prfl_addr;\n\tif (le64_to_cpu(kpu_data->signature) == KPU_SIGN &&\n\t    !strncmp(kpu_data->name, kpu_profile, KPU_NAME_LEN)) {\n\t\tdev_info(rvu->dev, \"Loading KPU profile from firmware db: %s\\n\",\n\t\t\t kpu_profile);\n\t\trvu->kpu_fwdata = kpu_data;\n\t\trvu->kpu_fwdata_sz = prfl_sz;\n\t\trvu->kpu_prfl_addr = prfl_addr;\n\t\trc = 0;\n\t}\n\n\treturn rc;\n}\n\nstatic int npc_fwdb_detect_load_prfl_img(struct rvu *rvu, uint64_t prfl_sz,\n\t\t\t\t\t const char *kpu_profile)\n{\n\tstruct npc_coalesced_kpu_prfl *img_data = NULL;\n\tint i = 0, rc = -EINVAL;\n\tvoid __iomem *kpu_prfl_addr;\n\tu16 offset;\n\n\timg_data = (struct npc_coalesced_kpu_prfl __force *)rvu->kpu_prfl_addr;\n\tif (le64_to_cpu(img_data->signature) == KPU_SIGN &&\n\t    !strncmp(img_data->name, kpu_profile, KPU_NAME_LEN)) {\n\t\t \n\t\trc = npc_load_kpu_prfl_img(rvu, rvu->kpu_prfl_addr,\n\t\t\t\t\t   prfl_sz, kpu_profile);\n\t\tgoto done;\n\t}\n\n\t \n\toffset = offsetof(struct npc_coalesced_kpu_prfl, prfl_sz) +\n\t\t(img_data->num_prfl * sizeof(uint16_t));\n\t \n\twhile (i < img_data->num_prfl) {\n\t\t \n\t\toffset = ALIGN_8B_CEIL(offset);\n\t\tkpu_prfl_addr = (void __iomem *)((uintptr_t)rvu->kpu_prfl_addr +\n\t\t\t\t\t offset);\n\t\trc = npc_load_kpu_prfl_img(rvu, kpu_prfl_addr,\n\t\t\t\t\t   img_data->prfl_sz[i], kpu_profile);\n\t\tif (!rc)\n\t\t\tbreak;\n\t\t \n\t\toffset += img_data->prfl_sz[i];\n\t\ti++;\n\t}\ndone:\n\treturn rc;\n}\n\nstatic int npc_load_kpu_profile_fwdb(struct rvu *rvu, const char *kpu_profile)\n{\n\tint ret = -EINVAL;\n\tu64 prfl_sz;\n\n\t \n\tret = npc_fwdb_prfl_img_map(rvu, &rvu->kpu_prfl_addr, &prfl_sz);\n\tif (ret < 0)\n\t\tgoto done;\n\n\t \n\tret = npc_fwdb_detect_load_prfl_img(rvu, prfl_sz, kpu_profile);\n\tif (ret == 0)\n\t\tgoto done;\n\n\t \n\tif (rvu->kpu_prfl_addr) {\n\t\tiounmap(rvu->kpu_prfl_addr);\n\t\trvu->kpu_prfl_addr = NULL;\n\t\trvu->kpu_fwdata_sz = 0;\n\t\trvu->kpu_fwdata = NULL;\n\t}\n\ndone:\n\treturn ret;\n}\n\nstatic void npc_load_kpu_profile(struct rvu *rvu)\n{\n\tstruct npc_kpu_profile_adapter *profile = &rvu->kpu;\n\tconst char *kpu_profile = rvu->kpu_pfl_name;\n\tconst struct firmware *fw = NULL;\n\tbool retry_fwdb = false;\n\n\t \n\tif (!strncmp(kpu_profile, def_pfl_name, KPU_NAME_LEN))\n\t\tgoto revert_to_default;\n\t \n\tnpc_prepare_default_kpu(profile);\n\n\t \n\tif (!request_firmware_direct(&fw, kpu_profile, rvu->dev)) {\n\t\tdev_info(rvu->dev, \"Loading KPU profile from firmware: %s\\n\",\n\t\t\t kpu_profile);\n\t\trvu->kpu_fwdata = kzalloc(fw->size, GFP_KERNEL);\n\t\tif (rvu->kpu_fwdata) {\n\t\t\tmemcpy(rvu->kpu_fwdata, fw->data, fw->size);\n\t\t\trvu->kpu_fwdata_sz = fw->size;\n\t\t}\n\t\trelease_firmware(fw);\n\t\tretry_fwdb = true;\n\t\tgoto program_kpu;\n\t}\n\nload_image_fwdb:\n\t \n\tif (npc_load_kpu_profile_fwdb(rvu, kpu_profile))\n\t\tgoto revert_to_default;\n\nprogram_kpu:\n\t \n\tif (!rvu->kpu_fwdata_sz || npc_apply_custom_kpu(rvu, profile)) {\n\t\t \n\t\tif (rvu->kpu_fwdata || rvu->kpu_fwdata_sz) {\n\t\t\t \n\t\t\tif (rvu->kpu_prfl_addr) {\n\t\t\t\tiounmap(rvu->kpu_prfl_addr);\n\t\t\t\trvu->kpu_prfl_addr = NULL;\n\t\t\t} else {\n\t\t\t\tkfree(rvu->kpu_fwdata);\n\t\t\t}\n\t\t\trvu->kpu_fwdata = NULL;\n\t\t\trvu->kpu_fwdata_sz = 0;\n\t\t\tif (retry_fwdb) {\n\t\t\t\tretry_fwdb = false;\n\t\t\t\tgoto load_image_fwdb;\n\t\t\t}\n\t\t}\n\n\t\tdev_warn(rvu->dev,\n\t\t\t \"Can't load KPU profile %s. Using default.\\n\",\n\t\t\t kpu_profile);\n\t\tkfree(rvu->kpu_fwdata);\n\t\trvu->kpu_fwdata = NULL;\n\t\tgoto revert_to_default;\n\t}\n\n\tdev_info(rvu->dev, \"Using custom profile '%s', version %d.%d.%d\\n\",\n\t\t profile->name, NPC_KPU_VER_MAJ(profile->version),\n\t\t NPC_KPU_VER_MIN(profile->version),\n\t\t NPC_KPU_VER_PATCH(profile->version));\n\n\treturn;\n\nrevert_to_default:\n\tnpc_prepare_default_kpu(profile);\n}\n\nstatic void npc_parser_profile_init(struct rvu *rvu, int blkaddr)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tint num_pkinds, num_kpus, idx;\n\n\t \n\tfor (idx = 0; idx < hw->npc_kpus; idx++) {\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_KPUX_ENTRY_DISX(idx, 0), ~0ULL);\n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_KPUX_ENTRY_DISX(idx, 1), ~0ULL);\n\t\trvu_write64(rvu, blkaddr, NPC_AF_KPUX_CFG(idx), 0x00);\n\t}\n\n\t \n\tnpc_load_kpu_profile(rvu);\n\n\t \n\tnum_pkinds = rvu->kpu.pkinds;\n\tnum_pkinds = min_t(int, hw->npc_pkinds, num_pkinds);\n\n\tfor (idx = 0; idx < num_pkinds; idx++)\n\t\tnpc_config_kpuaction(rvu, blkaddr, &rvu->kpu.ikpu[idx], 0, idx, true);\n\n\t \n\tnum_kpus = rvu->kpu.kpus;\n\tnum_kpus = min_t(int, hw->npc_kpus, num_kpus);\n\n\tfor (idx = 0; idx < num_kpus; idx++)\n\t\tnpc_program_kpu_profile(rvu, blkaddr, idx, &rvu->kpu.kpu[idx]);\n}\n\nstatic int npc_mcam_rsrcs_init(struct rvu *rvu, int blkaddr)\n{\n\tint nixlf_count = rvu_get_nixlf_count(rvu);\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tint rsvd, err;\n\tu16 index;\n\tint cntr;\n\tu64 cfg;\n\n\t \n\tcfg = (rvu_read64(rvu, blkaddr,\n\t\t\t  NPC_AF_INTFX_KEX_CFG(0)) >> 32) & 0x07;\n\tmcam->total_entries = (mcam->banks / BIT_ULL(cfg)) * mcam->banksize;\n\tmcam->keysize = cfg;\n\n\t \n\tif (cfg == NPC_MCAM_KEY_X4)\n\t\tmcam->banks_per_entry = 4;\n\telse if (cfg == NPC_MCAM_KEY_X2)\n\t\tmcam->banks_per_entry = 2;\n\telse\n\t\tmcam->banks_per_entry = 1;\n\n\t \n\trsvd = (nixlf_count * RSVD_MCAM_ENTRIES_PER_NIXLF) +\n\t\t((rvu->hw->total_pfs - 1) * RSVD_MCAM_ENTRIES_PER_PF);\n\tif (mcam->total_entries <= rsvd) {\n\t\tdev_warn(rvu->dev,\n\t\t\t \"Insufficient NPC MCAM size %d for pkt I/O, exiting\\n\",\n\t\t\t mcam->total_entries);\n\t\treturn -ENOMEM;\n\t}\n\n\tmcam->bmap_entries = mcam->total_entries - rsvd;\n\tmcam->nixlf_offset = mcam->bmap_entries;\n\tmcam->pf_offset = mcam->nixlf_offset + nixlf_count;\n\n\t \n\tmcam->bmap = devm_kcalloc(rvu->dev, BITS_TO_LONGS(mcam->bmap_entries),\n\t\t\t\t  sizeof(long), GFP_KERNEL);\n\tif (!mcam->bmap)\n\t\treturn -ENOMEM;\n\n\tmcam->bmap_reverse = devm_kcalloc(rvu->dev,\n\t\t\t\t\t  BITS_TO_LONGS(mcam->bmap_entries),\n\t\t\t\t\t  sizeof(long), GFP_KERNEL);\n\tif (!mcam->bmap_reverse)\n\t\treturn -ENOMEM;\n\n\tmcam->bmap_fcnt = mcam->bmap_entries;\n\n\t \n\tmcam->entry2pfvf_map = devm_kcalloc(rvu->dev, mcam->bmap_entries,\n\t\t\t\t\t    sizeof(u16), GFP_KERNEL);\n\tif (!mcam->entry2pfvf_map)\n\t\treturn -ENOMEM;\n\n\t \n\tmcam->lprio_count = mcam->bmap_entries / 8;\n\tif (mcam->lprio_count > BITS_PER_LONG)\n\t\tmcam->lprio_count = round_down(mcam->lprio_count,\n\t\t\t\t\t       BITS_PER_LONG);\n\tmcam->lprio_start = mcam->bmap_entries - mcam->lprio_count;\n\tmcam->hprio_count = mcam->lprio_count;\n\tmcam->hprio_end = mcam->hprio_count;\n\n\t \n\terr = rvu_alloc_bitmap(&mcam->counters);\n\tif (err)\n\t\treturn err;\n\n\tmcam->cntr2pfvf_map = devm_kcalloc(rvu->dev, mcam->counters.max,\n\t\t\t\t\t   sizeof(u16), GFP_KERNEL);\n\tif (!mcam->cntr2pfvf_map)\n\t\tgoto free_mem;\n\n\t \n\tmcam->entry2cntr_map = devm_kcalloc(rvu->dev, mcam->bmap_entries,\n\t\t\t\t\t    sizeof(u16), GFP_KERNEL);\n\tif (!mcam->entry2cntr_map)\n\t\tgoto free_mem;\n\n\tmcam->cntr_refcnt = devm_kcalloc(rvu->dev, mcam->counters.max,\n\t\t\t\t\t sizeof(u16), GFP_KERNEL);\n\tif (!mcam->cntr_refcnt)\n\t\tgoto free_mem;\n\n\t \n\tmcam->entry2target_pffunc = devm_kcalloc(rvu->dev, mcam->total_entries,\n\t\t\t\t\t\t sizeof(u16), GFP_KERNEL);\n\tif (!mcam->entry2target_pffunc)\n\t\tgoto free_mem;\n\n\tfor (index = 0; index < mcam->bmap_entries; index++) {\n\t\tmcam->entry2pfvf_map[index] = NPC_MCAM_INVALID_MAP;\n\t\tmcam->entry2cntr_map[index] = NPC_MCAM_INVALID_MAP;\n\t}\n\n\tfor (cntr = 0; cntr < mcam->counters.max; cntr++)\n\t\tmcam->cntr2pfvf_map[cntr] = NPC_MCAM_INVALID_MAP;\n\n\tmutex_init(&mcam->lock);\n\n\treturn 0;\n\nfree_mem:\n\tkfree(mcam->counters.bmap);\n\treturn -ENOMEM;\n}\n\nstatic void rvu_npc_hw_init(struct rvu *rvu, int blkaddr)\n{\n\tstruct npc_pkind *pkind = &rvu->hw->pkind;\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tu64 npc_const, npc_const1;\n\tu64 npc_const2 = 0;\n\n\tnpc_const = rvu_read64(rvu, blkaddr, NPC_AF_CONST);\n\tnpc_const1 = rvu_read64(rvu, blkaddr, NPC_AF_CONST1);\n\tif (npc_const1 & BIT_ULL(63))\n\t\tnpc_const2 = rvu_read64(rvu, blkaddr, NPC_AF_CONST2);\n\n\tpkind->rsrc.max = NPC_UNRESERVED_PKIND_COUNT;\n\thw->npc_pkinds = (npc_const1 >> 12) & 0xFFULL;\n\thw->npc_kpu_entries = npc_const1 & 0xFFFULL;\n\thw->npc_kpus = (npc_const >> 8) & 0x1FULL;\n\thw->npc_intfs = npc_const & 0xFULL;\n\thw->npc_counters = (npc_const >> 48) & 0xFFFFULL;\n\n\tmcam->banks = (npc_const >> 44) & 0xFULL;\n\tmcam->banksize = (npc_const >> 28) & 0xFFFFULL;\n\thw->npc_stat_ena = BIT_ULL(9);\n\t \n\tif (npc_const2) {\n\t\thw->npc_ext_set = true;\n\t\t \n\t\tif (!hw->npc_counters)\n\t\t\thw->npc_stat_ena = BIT_ULL(63);\n\t\thw->npc_counters = (npc_const2 >> 16) & 0xFFFFULL;\n\t\tmcam->banksize = npc_const2 & 0xFFFFULL;\n\t}\n\n\tmcam->counters.max = hw->npc_counters;\n}\n\nstatic void rvu_npc_setup_interfaces(struct rvu *rvu, int blkaddr)\n{\n\tstruct npc_mcam_kex *mkex = rvu->kpu.mkex;\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tu64 nibble_ena, rx_kex, tx_kex;\n\tu8 intf;\n\n\t \n\tmcam->counters.max--;\n\tmcam->rx_miss_act_cntr = mcam->counters.max;\n\n\trx_kex = mkex->keyx_cfg[NIX_INTF_RX];\n\ttx_kex = mkex->keyx_cfg[NIX_INTF_TX];\n\tnibble_ena = FIELD_GET(NPC_PARSE_NIBBLE, rx_kex);\n\n\tnibble_ena = rvu_npc_get_tx_nibble_cfg(rvu, nibble_ena);\n\tif (nibble_ena) {\n\t\ttx_kex &= ~NPC_PARSE_NIBBLE;\n\t\ttx_kex |= FIELD_PREP(NPC_PARSE_NIBBLE, nibble_ena);\n\t\tmkex->keyx_cfg[NIX_INTF_TX] = tx_kex;\n\t}\n\n\t \n\tfor (intf = 0; intf < hw->npc_intfs; intf++) {\n\t\tif (is_npc_intf_tx(intf))\n\t\t\tcontinue;\n\n\t\t \n\t\trvu_write64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(intf),\n\t\t\t    rx_kex);\n\n\t\t \n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_INTFX_MISS_ACT(intf), NIX_RX_ACTIONOP_DROP);\n\n\t\t \n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_INTFX_MISS_STAT_ACT(intf),\n\t\t\t    ((mcam->rx_miss_act_cntr >> 9) << 12) |\n\t\t\t    hw->npc_stat_ena | mcam->rx_miss_act_cntr);\n\t}\n\n\t \n\tfor (intf = 0; intf < hw->npc_intfs; intf++) {\n\t\tif (is_npc_intf_rx(intf))\n\t\t\tcontinue;\n\n\t\t \n\t\trvu_write64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(intf),\n\t\t\t    tx_kex);\n\n\t\t \n\t\trvu_write64(rvu, blkaddr,\n\t\t\t    NPC_AF_INTFX_MISS_ACT(intf),\n\t\t\t    NIX_TX_ACTIONOP_UCAST_DEFAULT);\n\t}\n}\n\nint rvu_npc_init(struct rvu *rvu)\n{\n\tstruct npc_kpu_profile_adapter *kpu = &rvu->kpu;\n\tstruct npc_pkind *pkind = &rvu->hw->pkind;\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tint blkaddr, entry, bank, err;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0) {\n\t\tdev_err(rvu->dev, \"%s: NPC block not implemented\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\trvu_npc_hw_init(rvu, blkaddr);\n\n\t \n\tfor (bank = 0; bank < mcam->banks; bank++) {\n\t\tfor (entry = 0; entry < mcam->banksize; entry++)\n\t\t\trvu_write64(rvu, blkaddr,\n\t\t\t\t    NPC_AF_MCAMEX_BANKX_CFG(entry, bank), 0);\n\t}\n\n\terr = rvu_alloc_bitmap(&pkind->rsrc);\n\tif (err)\n\t\treturn err;\n\t \n\trvu_alloc_rsrc(&pkind->rsrc);\n\n\t \n\tpkind->pfchan_map = devm_kcalloc(rvu->dev, pkind->rsrc.max,\n\t\t\t\t\t sizeof(u32), GFP_KERNEL);\n\tif (!pkind->pfchan_map)\n\t\treturn -ENOMEM;\n\n\t \n\tnpc_parser_profile_init(rvu, blkaddr);\n\n\t \n\trvu_write64(rvu, blkaddr, NPC_AF_PCK_DEF_OL2,\n\t\t    (kpu->lt_def->pck_ol2.lid << 8) | (kpu->lt_def->pck_ol2.ltype_match << 4) |\n\t\t    kpu->lt_def->pck_ol2.ltype_mask);\n\trvu_write64(rvu, blkaddr, NPC_AF_PCK_DEF_OIP4,\n\t\t    (kpu->lt_def->pck_oip4.lid << 8) | (kpu->lt_def->pck_oip4.ltype_match << 4) |\n\t\t    kpu->lt_def->pck_oip4.ltype_mask);\n\n\t \n\trvu_write64(rvu, blkaddr, NPC_AF_PCK_DEF_IIP4,\n\t\t    (kpu->lt_def->pck_iip4.lid << 8) | (kpu->lt_def->pck_iip4.ltype_match << 4) |\n\t\t    kpu->lt_def->pck_iip4.ltype_mask);\n\n\t \n\trvu_write64(rvu, blkaddr, NPC_AF_PCK_CFG,\n\t\t    rvu_read64(rvu, blkaddr, NPC_AF_PCK_CFG) |\n\t\t    ((u64)NPC_EC_OIP4_CSUM << 32) | (NPC_EC_IIP4_CSUM << 24) |\n\t\t    BIT_ULL(7) | BIT_ULL(6) | BIT_ULL(2) | BIT_ULL(1));\n\n\trvu_npc_setup_interfaces(rvu, blkaddr);\n\n\tnpc_config_secret_key(rvu, blkaddr);\n\t \n\tnpc_load_mkex_profile(rvu, blkaddr, rvu->mkex_pfl_name);\n\n\terr = npc_mcam_rsrcs_init(rvu, blkaddr);\n\tif (err)\n\t\treturn err;\n\n\terr = npc_flow_steering_init(rvu, blkaddr);\n\tif (err) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"Incorrect mkex profile loaded using default mkex\\n\");\n\t\tnpc_load_mkex_profile(rvu, blkaddr, def_pfl_name);\n\t}\n\n\treturn 0;\n}\n\nvoid rvu_npc_freemem(struct rvu *rvu)\n{\n\tstruct npc_pkind *pkind = &rvu->hw->pkind;\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\n\tkfree(pkind->rsrc.bmap);\n\tkfree(mcam->counters.bmap);\n\tif (rvu->kpu_prfl_addr)\n\t\tiounmap(rvu->kpu_prfl_addr);\n\telse\n\t\tkfree(rvu->kpu_fwdata);\n\tmutex_destroy(&mcam->lock);\n}\n\nvoid rvu_npc_get_mcam_entry_alloc_info(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t       int blkaddr, int *alloc_cnt,\n\t\t\t\t       int *enable_cnt)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tint entry;\n\n\t*alloc_cnt = 0;\n\t*enable_cnt = 0;\n\n\tfor (entry = 0; entry < mcam->bmap_entries; entry++) {\n\t\tif (mcam->entry2pfvf_map[entry] == pcifunc) {\n\t\t\t(*alloc_cnt)++;\n\t\t\tif (is_mcam_entry_enabled(rvu, mcam, blkaddr, entry))\n\t\t\t\t(*enable_cnt)++;\n\t\t}\n\t}\n}\n\nvoid rvu_npc_get_mcam_counter_alloc_info(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t\t int blkaddr, int *alloc_cnt,\n\t\t\t\t\t int *enable_cnt)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tint cntr;\n\n\t*alloc_cnt = 0;\n\t*enable_cnt = 0;\n\n\tfor (cntr = 0; cntr < mcam->counters.max; cntr++) {\n\t\tif (mcam->cntr2pfvf_map[cntr] == pcifunc) {\n\t\t\t(*alloc_cnt)++;\n\t\t\tif (mcam->cntr_refcnt[cntr])\n\t\t\t\t(*enable_cnt)++;\n\t\t}\n\t}\n}\n\nstatic int npc_mcam_verify_entry(struct npc_mcam *mcam,\n\t\t\t\t u16 pcifunc, int entry)\n{\n\t \n\tif (is_pffunc_af(pcifunc))\n\t\treturn 0;\n\t \n\tif (entry >= mcam->bmap_entries)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tif (pcifunc != mcam->entry2pfvf_map[entry])\n\t\treturn NPC_MCAM_PERM_DENIED;\n\n\treturn 0;\n}\n\nstatic int npc_mcam_verify_counter(struct npc_mcam *mcam,\n\t\t\t\t   u16 pcifunc, int cntr)\n{\n\t \n\tif (cntr >= mcam->counters.max)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tif (pcifunc != mcam->cntr2pfvf_map[cntr])\n\t\treturn NPC_MCAM_PERM_DENIED;\n\n\treturn 0;\n}\n\nstatic void npc_map_mcam_entry_and_cntr(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t\t\tint blkaddr, u16 entry, u16 cntr)\n{\n\tu16 index = entry & (mcam->banksize - 1);\n\tu32 bank = npc_get_bank(mcam, entry);\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\n\t \n\tmcam->entry2cntr_map[entry] = cntr;\n\tmcam->cntr_refcnt[cntr]++;\n\t \n\trvu_write64(rvu, blkaddr,\n\t\t    NPC_AF_MCAMEX_BANKX_STAT_ACT(index, bank),\n\t\t    ((cntr >> 9) << 12) | hw->npc_stat_ena | cntr);\n}\n\nstatic void npc_unmap_mcam_entry_and_cntr(struct rvu *rvu,\n\t\t\t\t\t  struct npc_mcam *mcam,\n\t\t\t\t\t  int blkaddr, u16 entry, u16 cntr)\n{\n\tu16 index = entry & (mcam->banksize - 1);\n\tu32 bank = npc_get_bank(mcam, entry);\n\n\t \n\tmcam->entry2cntr_map[entry] = NPC_MCAM_INVALID_MAP;\n\tmcam->cntr_refcnt[cntr]--;\n\t \n\trvu_write64(rvu, blkaddr,\n\t\t    NPC_AF_MCAMEX_BANKX_STAT_ACT(index, bank), 0x00);\n}\n\n \nstatic void npc_mcam_set_bit(struct npc_mcam *mcam, u16 index)\n{\n\tu16 entry, rentry;\n\n\tentry = index;\n\trentry = mcam->bmap_entries - index - 1;\n\n\t__set_bit(entry, mcam->bmap);\n\t__set_bit(rentry, mcam->bmap_reverse);\n\tmcam->bmap_fcnt--;\n}\n\n \nstatic void npc_mcam_clear_bit(struct npc_mcam *mcam, u16 index)\n{\n\tu16 entry, rentry;\n\n\tentry = index;\n\trentry = mcam->bmap_entries - index - 1;\n\n\t__clear_bit(entry, mcam->bmap);\n\t__clear_bit(rentry, mcam->bmap_reverse);\n\tmcam->bmap_fcnt++;\n}\n\nstatic void npc_mcam_free_all_entries(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t\t      int blkaddr, u16 pcifunc)\n{\n\tu16 index, cntr;\n\n\t \n\tfor (index = 0; index < mcam->bmap_entries; index++) {\n\t\tif (mcam->entry2pfvf_map[index] == pcifunc) {\n\t\t\tmcam->entry2pfvf_map[index] = NPC_MCAM_INVALID_MAP;\n\t\t\t \n\t\t\tnpc_mcam_clear_bit(mcam, index);\n\t\t\t \n\t\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, index, false);\n\n\t\t\t \n\t\t\tcntr = mcam->entry2cntr_map[index];\n\t\t\tif (cntr != NPC_MCAM_INVALID_MAP)\n\t\t\t\tnpc_unmap_mcam_entry_and_cntr(rvu, mcam,\n\t\t\t\t\t\t\t      blkaddr, index,\n\t\t\t\t\t\t\t      cntr);\n\t\t\tmcam->entry2target_pffunc[index] = 0x0;\n\t\t}\n\t}\n}\n\nstatic void npc_mcam_free_all_counters(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t\t       u16 pcifunc)\n{\n\tu16 cntr;\n\n\t \n\tfor (cntr = 0; cntr < mcam->counters.max; cntr++) {\n\t\tif (mcam->cntr2pfvf_map[cntr] == pcifunc) {\n\t\t\tmcam->cntr2pfvf_map[cntr] = NPC_MCAM_INVALID_MAP;\n\t\t\tmcam->cntr_refcnt[cntr] = 0;\n\t\t\trvu_free_rsrc(&mcam->counters, cntr);\n\t\t\t \n\t\t}\n\t}\n}\n\n \nstatic u16 npc_mcam_find_zero_area(unsigned long *map, u16 size, u16 start,\n\t\t\t\t   u16 nr, u16 *max_area)\n{\n\tu16 max_area_start = 0;\n\tu16 index, next, end;\n\n\t*max_area = 0;\n\nagain:\n\tindex = find_next_zero_bit(map, size, start);\n\tif (index >= size)\n\t\treturn max_area_start;\n\n\tend = ((index + nr) >= size) ? size : index + nr;\n\tnext = find_next_bit(map, end, index);\n\tif (*max_area < (next - index)) {\n\t\t*max_area = next - index;\n\t\tmax_area_start = index;\n\t}\n\n\tif (next < end) {\n\t\tstart = next + 1;\n\t\tgoto again;\n\t}\n\n\treturn max_area_start;\n}\n\n \nstatic u16 npc_mcam_get_free_count(unsigned long *map, u16 start, u16 end)\n{\n\tu16 index, next;\n\tu16 fcnt = 0;\n\nagain:\n\tif (start >= end)\n\t\treturn fcnt;\n\n\tindex = find_next_zero_bit(map, end, start);\n\tif (index >= end)\n\t\treturn fcnt;\n\n\tnext = find_next_bit(map, end, index);\n\tif (next <= end) {\n\t\tfcnt += next - index;\n\t\tstart = next + 1;\n\t\tgoto again;\n\t}\n\n\tfcnt += end - index;\n\treturn fcnt;\n}\n\nstatic void\nnpc_get_mcam_search_range_priority(struct npc_mcam *mcam,\n\t\t\t\t   struct npc_mcam_alloc_entry_req *req,\n\t\t\t\t   u16 *start, u16 *end, bool *reverse)\n{\n\tu16 fcnt;\n\n\tif (req->priority == NPC_MCAM_HIGHER_PRIO)\n\t\tgoto hprio;\n\n\t \n\n\t*reverse = false;\n\t*start = req->ref_entry + 1;\n\t*end = mcam->bmap_entries;\n\n\tif (req->ref_entry >= mcam->hprio_end)\n\t\treturn;\n\n\tfcnt = npc_mcam_get_free_count(mcam->bmap,\n\t\t\t\t       mcam->hprio_end, mcam->bmap_entries);\n\tif (fcnt > req->count)\n\t\t*start = mcam->hprio_end;\n\telse\n\t\t*reverse = true;\n\treturn;\n\nhprio:\n\t \n\n\t*reverse = true;\n\t*start = 0;\n\t*end = req->ref_entry;\n\n\tif (req->ref_entry <= mcam->lprio_start)\n\t\treturn;\n\n\tfcnt = npc_mcam_get_free_count(mcam->bmap,\n\t\t\t\t       mcam->hprio_end, mcam->lprio_start);\n\tif (fcnt < req->count)\n\t\treturn;\n\t*start = mcam->hprio_end;\n\t*end = mcam->lprio_start;\n}\n\nstatic int npc_mcam_alloc_entries(struct npc_mcam *mcam, u16 pcifunc,\n\t\t\t\t  struct npc_mcam_alloc_entry_req *req,\n\t\t\t\t  struct npc_mcam_alloc_entry_rsp *rsp)\n{\n\tu16 entry_list[NPC_MAX_NONCONTIG_ENTRIES];\n\tu16 fcnt, hp_fcnt, lp_fcnt;\n\tu16 start, end, index;\n\tint entry, next_start;\n\tbool reverse = false;\n\tunsigned long *bmap;\n\tu16 max_contig;\n\n\tmutex_lock(&mcam->lock);\n\n\t \n\tif (!mcam->bmap_fcnt) {\n\t\tmutex_unlock(&mcam->lock);\n\t\treturn NPC_MCAM_ALLOC_FAILED;\n\t}\n\n\t \n\n\t \n\tif (req->priority) {\n\t\tnpc_get_mcam_search_range_priority(mcam, req,\n\t\t\t\t\t\t   &start, &end, &reverse);\n\t\tgoto alloc;\n\t}\n\n\t \n\tif (!(pcifunc & RVU_PFVF_FUNC_MASK))\n\t\tgoto lprio_alloc;\n\n\t \n\tlp_fcnt = npc_mcam_get_free_count(mcam->bmap,\n\t\t\t\t\t  mcam->lprio_start,\n\t\t\t\t\t  mcam->bmap_entries);\n\thp_fcnt = npc_mcam_get_free_count(mcam->bmap, 0, mcam->hprio_end);\n\tfcnt = mcam->bmap_fcnt - lp_fcnt - hp_fcnt;\n\n\t \n\tif (fcnt > req->count) {\n\t\tstart = mcam->hprio_end;\n\t\tend = mcam->lprio_start;\n\t} else if ((fcnt + (hp_fcnt / 2) + (lp_fcnt / 2)) > req->count) {\n\t\t \n\t\tstart = mcam->hprio_end / 2;\n\t\tend = mcam->bmap_entries - (mcam->lprio_count / 2);\n\t\treverse = true;\n\t} else {\n\t\t \nlprio_alloc:\n\t\treverse = true;\n\t\tstart = 0;\n\t\tend = mcam->bmap_entries;\n\t}\n\nalloc:\n\tif (reverse) {\n\t\tbmap = mcam->bmap_reverse;\n\t\tstart = mcam->bmap_entries - start;\n\t\tend = mcam->bmap_entries - end;\n\t\tswap(start, end);\n\t} else {\n\t\tbmap = mcam->bmap;\n\t}\n\n\tif (req->contig) {\n\t\t \n\t\tindex = npc_mcam_find_zero_area(bmap, end, start,\n\t\t\t\t\t\treq->count, &max_contig);\n\t\trsp->count = max_contig;\n\t\tif (reverse)\n\t\t\trsp->entry = mcam->bmap_entries - index - max_contig;\n\t\telse\n\t\t\trsp->entry = index;\n\t} else {\n\t\t \n\t\trsp->count = 0;\n\t\tnext_start = start;\n\t\tfor (entry = 0; entry < req->count; entry++) {\n\t\t\tindex = find_next_zero_bit(bmap, end, next_start);\n\t\t\tif (index >= end)\n\t\t\t\tbreak;\n\n\t\t\tnext_start = start + (index - start) + 1;\n\n\t\t\t \n\t\t\tif (reverse)\n\t\t\t\tindex = mcam->bmap_entries - index - 1;\n\t\t\tentry_list[entry] = index;\n\t\t\trsp->count++;\n\t\t}\n\t}\n\n\t \n\tif (!req->priority && (rsp->count < req->count) &&\n\t    ((end - start) != mcam->bmap_entries)) {\n\t\treverse = true;\n\t\tstart = 0;\n\t\tend = mcam->bmap_entries;\n\t\tgoto alloc;\n\t}\n\n\t \n\tif (req->priority && rsp->count < req->count) {\n\t\tif (req->priority == NPC_MCAM_LOWER_PRIO &&\n\t\t    (start != (req->ref_entry + 1))) {\n\t\t\tstart = req->ref_entry + 1;\n\t\t\tend = mcam->bmap_entries;\n\t\t\treverse = false;\n\t\t\tgoto alloc;\n\t\t} else if ((req->priority == NPC_MCAM_HIGHER_PRIO) &&\n\t\t\t   ((end - start) != req->ref_entry)) {\n\t\t\tstart = 0;\n\t\t\tend = req->ref_entry;\n\t\t\treverse = true;\n\t\t\tgoto alloc;\n\t\t}\n\t}\n\n\t \n\tif (!req->contig && rsp->count) {\n\t\tindex = 0;\n\t\tfor (entry = rsp->count - 1; entry >= 0; entry--) {\n\t\t\tif (reverse)\n\t\t\t\trsp->entry_list[index++] = entry_list[entry];\n\t\t\telse\n\t\t\t\trsp->entry_list[entry] = entry_list[entry];\n\t\t}\n\t}\n\n\t \n\tfor (entry = 0; entry < rsp->count; entry++) {\n\t\tindex = req->contig ?\n\t\t\t(rsp->entry + entry) : rsp->entry_list[entry];\n\t\tnpc_mcam_set_bit(mcam, index);\n\t\tmcam->entry2pfvf_map[index] = pcifunc;\n\t\tmcam->entry2cntr_map[index] = NPC_MCAM_INVALID_MAP;\n\t}\n\n\t \n\trsp->free_count = mcam->bmap_fcnt;\n\n\tmutex_unlock(&mcam->lock);\n\treturn 0;\n}\n\n \nvoid npc_mcam_rsrcs_reserve(struct rvu *rvu, int blkaddr, int entry_idx)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\n\tnpc_mcam_set_bit(mcam, entry_idx);\n}\n\nint rvu_mbox_handler_npc_mcam_alloc_entry(struct rvu *rvu,\n\t\t\t\t\t  struct npc_mcam_alloc_entry_req *req,\n\t\t\t\t\t  struct npc_mcam_alloc_entry_rsp *rsp)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu16 pcifunc = req->hdr.pcifunc;\n\tint blkaddr;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\trsp->entry = NPC_MCAM_ENTRY_INVALID;\n\trsp->free_count = 0;\n\n\t \n\tif (req->priority && req->ref_entry >= mcam->bmap_entries) {\n\t\tdev_err(rvu->dev, \"%s: reference entry %d is out of range\\n\",\n\t\t\t__func__, req->ref_entry);\n\t\treturn NPC_MCAM_INVALID_REQ;\n\t}\n\n\t \n\tif ((!req->ref_entry && req->priority == NPC_MCAM_HIGHER_PRIO) ||\n\t    ((req->ref_entry == (mcam->bmap_entries - 1)) &&\n\t     req->priority == NPC_MCAM_LOWER_PRIO))\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\t \n\tif (!req->contig && req->count > NPC_MAX_NONCONTIG_ENTRIES) {\n\t\tdev_err(rvu->dev,\n\t\t\t\"%s: %d Non-contiguous MCAM entries requested is more than max (%d) allowed\\n\",\n\t\t\t__func__, req->count, NPC_MAX_NONCONTIG_ENTRIES);\n\t\treturn NPC_MCAM_INVALID_REQ;\n\t}\n\n\t \n\tif (!is_pffunc_af(pcifunc) && !is_nixlf_attached(rvu, pcifunc))\n\t\treturn NPC_MCAM_ALLOC_DENIED;\n\n\treturn npc_mcam_alloc_entries(mcam, pcifunc, req, rsp);\n}\n\nint rvu_mbox_handler_npc_mcam_free_entry(struct rvu *rvu,\n\t\t\t\t\t struct npc_mcam_free_entry_req *req,\n\t\t\t\t\t struct msg_rsp *rsp)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu16 pcifunc = req->hdr.pcifunc;\n\tint blkaddr, rc = 0;\n\tu16 cntr;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\t \n\tif (!is_pffunc_af(pcifunc) && !is_nixlf_attached(rvu, pcifunc))\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tmutex_lock(&mcam->lock);\n\n\tif (req->all)\n\t\tgoto free_all;\n\n\trc = npc_mcam_verify_entry(mcam, pcifunc, req->entry);\n\tif (rc)\n\t\tgoto exit;\n\n\tmcam->entry2pfvf_map[req->entry] = NPC_MCAM_INVALID_MAP;\n\tmcam->entry2target_pffunc[req->entry] = 0x0;\n\tnpc_mcam_clear_bit(mcam, req->entry);\n\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, req->entry, false);\n\n\t \n\tcntr = mcam->entry2cntr_map[req->entry];\n\tif (cntr != NPC_MCAM_INVALID_MAP)\n\t\tnpc_unmap_mcam_entry_and_cntr(rvu, mcam, blkaddr,\n\t\t\t\t\t      req->entry, cntr);\n\n\tgoto exit;\n\nfree_all:\n\t \n\tnpc_mcam_free_all_entries(rvu, mcam, blkaddr, pcifunc);\nexit:\n\tmutex_unlock(&mcam->lock);\n\treturn rc;\n}\n\nint rvu_mbox_handler_npc_mcam_read_entry(struct rvu *rvu,\n\t\t\t\t\t struct npc_mcam_read_entry_req *req,\n\t\t\t\t\t struct npc_mcam_read_entry_rsp *rsp)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu16 pcifunc = req->hdr.pcifunc;\n\tint blkaddr, rc;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tmutex_lock(&mcam->lock);\n\trc = npc_mcam_verify_entry(mcam, pcifunc, req->entry);\n\tif (!rc) {\n\t\tnpc_read_mcam_entry(rvu, mcam, blkaddr, req->entry,\n\t\t\t\t    &rsp->entry_data,\n\t\t\t\t    &rsp->intf, &rsp->enable);\n\t}\n\n\tmutex_unlock(&mcam->lock);\n\treturn rc;\n}\n\nint rvu_mbox_handler_npc_mcam_write_entry(struct rvu *rvu,\n\t\t\t\t\t  struct npc_mcam_write_entry_req *req,\n\t\t\t\t\t  struct msg_rsp *rsp)\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, req->hdr.pcifunc);\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu16 pcifunc = req->hdr.pcifunc;\n\tint blkaddr, rc;\n\tu8 nix_intf;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tmutex_lock(&mcam->lock);\n\trc = npc_mcam_verify_entry(mcam, pcifunc, req->entry);\n\tif (rc)\n\t\tgoto exit;\n\n\tif (req->set_cntr &&\n\t    npc_mcam_verify_counter(mcam, pcifunc, req->cntr)) {\n\t\trc = NPC_MCAM_INVALID_REQ;\n\t\tgoto exit;\n\t}\n\n\tif (!is_npc_interface_valid(rvu, req->intf)) {\n\t\trc = NPC_MCAM_INVALID_REQ;\n\t\tgoto exit;\n\t}\n\n\tif (is_npc_intf_tx(req->intf))\n\t\tnix_intf = pfvf->nix_tx_intf;\n\telse\n\t\tnix_intf = pfvf->nix_rx_intf;\n\n\tif (!is_pffunc_af(pcifunc) &&\n\t    npc_mcam_verify_pf_func(rvu, &req->entry_data, req->intf, pcifunc)) {\n\t\trc = NPC_MCAM_INVALID_REQ;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (is_pffunc_af(req->hdr.pcifunc))\n\t\tnix_intf = req->intf;\n\n\tnpc_config_mcam_entry(rvu, mcam, blkaddr, req->entry, nix_intf,\n\t\t\t      &req->entry_data, req->enable_entry);\n\n\tif (req->set_cntr)\n\t\tnpc_map_mcam_entry_and_cntr(rvu, mcam, blkaddr,\n\t\t\t\t\t    req->entry, req->cntr);\n\n\trc = 0;\nexit:\n\tmutex_unlock(&mcam->lock);\n\treturn rc;\n}\n\nint rvu_mbox_handler_npc_mcam_ena_entry(struct rvu *rvu,\n\t\t\t\t\tstruct npc_mcam_ena_dis_entry_req *req,\n\t\t\t\t\tstruct msg_rsp *rsp)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu16 pcifunc = req->hdr.pcifunc;\n\tint blkaddr, rc;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tmutex_lock(&mcam->lock);\n\trc = npc_mcam_verify_entry(mcam, pcifunc, req->entry);\n\tmutex_unlock(&mcam->lock);\n\tif (rc)\n\t\treturn rc;\n\n\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, req->entry, true);\n\n\treturn 0;\n}\n\nint rvu_mbox_handler_npc_mcam_dis_entry(struct rvu *rvu,\n\t\t\t\t\tstruct npc_mcam_ena_dis_entry_req *req,\n\t\t\t\t\tstruct msg_rsp *rsp)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu16 pcifunc = req->hdr.pcifunc;\n\tint blkaddr, rc;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tmutex_lock(&mcam->lock);\n\trc = npc_mcam_verify_entry(mcam, pcifunc, req->entry);\n\tmutex_unlock(&mcam->lock);\n\tif (rc)\n\t\treturn rc;\n\n\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, req->entry, false);\n\n\treturn 0;\n}\n\nint rvu_mbox_handler_npc_mcam_shift_entry(struct rvu *rvu,\n\t\t\t\t\t  struct npc_mcam_shift_entry_req *req,\n\t\t\t\t\t  struct npc_mcam_shift_entry_rsp *rsp)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu16 pcifunc = req->hdr.pcifunc;\n\tu16 old_entry, new_entry;\n\tint blkaddr, rc = 0;\n\tu16 index, cntr;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tif (req->shift_count > NPC_MCAM_MAX_SHIFTS)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tmutex_lock(&mcam->lock);\n\tfor (index = 0; index < req->shift_count; index++) {\n\t\told_entry = req->curr_entry[index];\n\t\tnew_entry = req->new_entry[index];\n\n\t\t \n\t\trc = npc_mcam_verify_entry(mcam, pcifunc, old_entry);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\trc = npc_mcam_verify_entry(mcam, pcifunc, new_entry);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\t \n\t\tif (mcam->entry2cntr_map[new_entry] != NPC_MCAM_INVALID_MAP) {\n\t\t\trc = NPC_MCAM_PERM_DENIED;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, new_entry, false);\n\n\t\t \n\t\tnpc_copy_mcam_entry(rvu, mcam, blkaddr, old_entry, new_entry);\n\n\t\t \n\t\tcntr = mcam->entry2cntr_map[old_entry];\n\t\tif (cntr != NPC_MCAM_INVALID_MAP) {\n\t\t\tnpc_unmap_mcam_entry_and_cntr(rvu, mcam, blkaddr,\n\t\t\t\t\t\t      old_entry, cntr);\n\t\t\tnpc_map_mcam_entry_and_cntr(rvu, mcam, blkaddr,\n\t\t\t\t\t\t    new_entry, cntr);\n\t\t}\n\n\t\t \n\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, new_entry, true);\n\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, old_entry, false);\n\t}\n\n\t \n\tif (index != req->shift_count) {\n\t\trc = NPC_MCAM_PERM_DENIED;\n\t\trsp->failed_entry_idx = index;\n\t}\n\n\tmutex_unlock(&mcam->lock);\n\treturn rc;\n}\n\nint rvu_mbox_handler_npc_mcam_alloc_counter(struct rvu *rvu,\n\t\t\tstruct npc_mcam_alloc_counter_req *req,\n\t\t\tstruct npc_mcam_alloc_counter_rsp *rsp)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu16 pcifunc = req->hdr.pcifunc;\n\tu16 max_contig, cntr;\n\tint blkaddr, index;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\t \n\tif (!is_pffunc_af(pcifunc) && !is_nixlf_attached(rvu, pcifunc))\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\t \n\tif (!req->contig && req->count > NPC_MAX_NONCONTIG_COUNTERS)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tmutex_lock(&mcam->lock);\n\n\t \n\tif (!rvu_rsrc_free_count(&mcam->counters)) {\n\t\tmutex_unlock(&mcam->lock);\n\t\treturn NPC_MCAM_ALLOC_FAILED;\n\t}\n\n\trsp->count = 0;\n\n\tif (req->contig) {\n\t\t \n\t\tindex = npc_mcam_find_zero_area(mcam->counters.bmap,\n\t\t\t\t\t\tmcam->counters.max, 0,\n\t\t\t\t\t\treq->count, &max_contig);\n\t\trsp->count = max_contig;\n\t\trsp->cntr = index;\n\t\tfor (cntr = index; cntr < (index + max_contig); cntr++) {\n\t\t\t__set_bit(cntr, mcam->counters.bmap);\n\t\t\tmcam->cntr2pfvf_map[cntr] = pcifunc;\n\t\t}\n\t} else {\n\t\t \n\t\tfor (cntr = 0; cntr < req->count; cntr++) {\n\t\t\tindex = rvu_alloc_rsrc(&mcam->counters);\n\t\t\tif (index < 0)\n\t\t\t\tbreak;\n\t\t\trsp->cntr_list[cntr] = index;\n\t\t\trsp->count++;\n\t\t\tmcam->cntr2pfvf_map[index] = pcifunc;\n\t\t}\n\t}\n\n\tmutex_unlock(&mcam->lock);\n\treturn 0;\n}\n\nint rvu_mbox_handler_npc_mcam_free_counter(struct rvu *rvu,\n\t\tstruct npc_mcam_oper_counter_req *req, struct msg_rsp *rsp)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu16 index, entry = 0;\n\tint blkaddr, err;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tmutex_lock(&mcam->lock);\n\terr = npc_mcam_verify_counter(mcam, req->hdr.pcifunc, req->cntr);\n\tif (err) {\n\t\tmutex_unlock(&mcam->lock);\n\t\treturn err;\n\t}\n\n\t \n\tmcam->cntr2pfvf_map[req->cntr] = NPC_MCAM_INVALID_MAP;\n\trvu_free_rsrc(&mcam->counters, req->cntr);\n\n\t \n\twhile (entry < mcam->bmap_entries) {\n\t\tif (!mcam->cntr_refcnt[req->cntr])\n\t\t\tbreak;\n\n\t\tindex = find_next_bit(mcam->bmap, mcam->bmap_entries, entry);\n\t\tif (index >= mcam->bmap_entries)\n\t\t\tbreak;\n\t\tentry = index + 1;\n\t\tif (mcam->entry2cntr_map[index] != req->cntr)\n\t\t\tcontinue;\n\n\t\tnpc_unmap_mcam_entry_and_cntr(rvu, mcam, blkaddr,\n\t\t\t\t\t      index, req->cntr);\n\t}\n\n\tmutex_unlock(&mcam->lock);\n\treturn 0;\n}\n\nint rvu_mbox_handler_npc_mcam_unmap_counter(struct rvu *rvu,\n\t\tstruct npc_mcam_unmap_counter_req *req, struct msg_rsp *rsp)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu16 index, entry = 0;\n\tint blkaddr, rc;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tmutex_lock(&mcam->lock);\n\trc = npc_mcam_verify_counter(mcam, req->hdr.pcifunc, req->cntr);\n\tif (rc)\n\t\tgoto exit;\n\n\t \n\tif (!req->all) {\n\t\trc = npc_mcam_verify_entry(mcam, req->hdr.pcifunc, req->entry);\n\t\tif (rc)\n\t\t\tgoto exit;\n\t\tnpc_unmap_mcam_entry_and_cntr(rvu, mcam, blkaddr,\n\t\t\t\t\t      req->entry, req->cntr);\n\t\tgoto exit;\n\t}\n\n\t \n\twhile (entry < mcam->bmap_entries) {\n\t\tif (!mcam->cntr_refcnt[req->cntr])\n\t\t\tbreak;\n\n\t\tindex = find_next_bit(mcam->bmap, mcam->bmap_entries, entry);\n\t\tif (index >= mcam->bmap_entries)\n\t\t\tbreak;\n\t\tentry = index + 1;\n\n\t\tif (mcam->entry2cntr_map[index] != req->cntr)\n\t\t\tcontinue;\n\n\t\tnpc_unmap_mcam_entry_and_cntr(rvu, mcam, blkaddr,\n\t\t\t\t\t      index, req->cntr);\n\t}\nexit:\n\tmutex_unlock(&mcam->lock);\n\treturn rc;\n}\n\nint rvu_mbox_handler_npc_mcam_clear_counter(struct rvu *rvu,\n\t\tstruct npc_mcam_oper_counter_req *req, struct msg_rsp *rsp)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tint blkaddr, err;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tmutex_lock(&mcam->lock);\n\terr = npc_mcam_verify_counter(mcam, req->hdr.pcifunc, req->cntr);\n\tmutex_unlock(&mcam->lock);\n\tif (err)\n\t\treturn err;\n\n\trvu_write64(rvu, blkaddr, NPC_AF_MATCH_STATX(req->cntr), 0x00);\n\n\treturn 0;\n}\n\nint rvu_mbox_handler_npc_mcam_counter_stats(struct rvu *rvu,\n\t\t\tstruct npc_mcam_oper_counter_req *req,\n\t\t\tstruct npc_mcam_oper_counter_rsp *rsp)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tint blkaddr, err;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tmutex_lock(&mcam->lock);\n\terr = npc_mcam_verify_counter(mcam, req->hdr.pcifunc, req->cntr);\n\tmutex_unlock(&mcam->lock);\n\tif (err)\n\t\treturn err;\n\n\trsp->stat = rvu_read64(rvu, blkaddr, NPC_AF_MATCH_STATX(req->cntr));\n\trsp->stat &= BIT_ULL(48) - 1;\n\n\treturn 0;\n}\n\nint rvu_mbox_handler_npc_mcam_alloc_and_write_entry(struct rvu *rvu,\n\t\t\t  struct npc_mcam_alloc_and_write_entry_req *req,\n\t\t\t  struct npc_mcam_alloc_and_write_entry_rsp *rsp)\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, req->hdr.pcifunc);\n\tstruct npc_mcam_alloc_counter_req cntr_req;\n\tstruct npc_mcam_alloc_counter_rsp cntr_rsp;\n\tstruct npc_mcam_alloc_entry_req entry_req;\n\tstruct npc_mcam_alloc_entry_rsp entry_rsp;\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu16 entry = NPC_MCAM_ENTRY_INVALID;\n\tu16 cntr = NPC_MCAM_ENTRY_INVALID;\n\tint blkaddr, rc;\n\tu8 nix_intf;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tif (!is_npc_interface_valid(rvu, req->intf))\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tif (npc_mcam_verify_pf_func(rvu, &req->entry_data, req->intf,\n\t\t\t\t    req->hdr.pcifunc))\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\t \n\tentry_req.hdr.pcifunc = req->hdr.pcifunc;\n\tentry_req.contig = true;\n\tentry_req.priority = req->priority;\n\tentry_req.ref_entry = req->ref_entry;\n\tentry_req.count = 1;\n\n\trc = rvu_mbox_handler_npc_mcam_alloc_entry(rvu,\n\t\t\t\t\t\t   &entry_req, &entry_rsp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!entry_rsp.count)\n\t\treturn NPC_MCAM_ALLOC_FAILED;\n\n\tentry = entry_rsp.entry;\n\n\tif (!req->alloc_cntr)\n\t\tgoto write_entry;\n\n\t \n\tcntr_req.hdr.pcifunc = req->hdr.pcifunc;\n\tcntr_req.contig = true;\n\tcntr_req.count = 1;\n\n\trc = rvu_mbox_handler_npc_mcam_alloc_counter(rvu, &cntr_req, &cntr_rsp);\n\tif (rc) {\n\t\t \n\t\tmutex_lock(&mcam->lock);\n\t\tmcam->entry2pfvf_map[entry] = NPC_MCAM_INVALID_MAP;\n\t\tnpc_mcam_clear_bit(mcam, entry);\n\t\tmutex_unlock(&mcam->lock);\n\t\treturn rc;\n\t}\n\n\tcntr = cntr_rsp.cntr;\n\nwrite_entry:\n\tmutex_lock(&mcam->lock);\n\n\tif (is_npc_intf_tx(req->intf))\n\t\tnix_intf = pfvf->nix_tx_intf;\n\telse\n\t\tnix_intf = pfvf->nix_rx_intf;\n\n\tnpc_config_mcam_entry(rvu, mcam, blkaddr, entry, nix_intf,\n\t\t\t      &req->entry_data, req->enable_entry);\n\n\tif (req->alloc_cntr)\n\t\tnpc_map_mcam_entry_and_cntr(rvu, mcam, blkaddr, entry, cntr);\n\tmutex_unlock(&mcam->lock);\n\n\trsp->entry = entry;\n\trsp->cntr = cntr;\n\n\treturn 0;\n}\n\n#define GET_KEX_CFG(intf) \\\n\trvu_read64(rvu, BLKADDR_NPC, NPC_AF_INTFX_KEX_CFG(intf))\n\n#define GET_KEX_FLAGS(ld) \\\n\trvu_read64(rvu, BLKADDR_NPC, NPC_AF_KEX_LDATAX_FLAGS_CFG(ld))\n\n#define GET_KEX_LD(intf, lid, lt, ld)\t\\\n\trvu_read64(rvu, BLKADDR_NPC,\t\\\n\t\tNPC_AF_INTFX_LIDX_LTX_LDX_CFG(intf, lid, lt, ld))\n\n#define GET_KEX_LDFLAGS(intf, ld, fl)\t\\\n\trvu_read64(rvu, BLKADDR_NPC,\t\\\n\t\tNPC_AF_INTFX_LDATAX_FLAGSX_CFG(intf, ld, fl))\n\nint rvu_mbox_handler_npc_get_kex_cfg(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t     struct npc_get_kex_cfg_rsp *rsp)\n{\n\tint lid, lt, ld, fl;\n\n\trsp->rx_keyx_cfg = GET_KEX_CFG(NIX_INTF_RX);\n\trsp->tx_keyx_cfg = GET_KEX_CFG(NIX_INTF_TX);\n\tfor (lid = 0; lid < NPC_MAX_LID; lid++) {\n\t\tfor (lt = 0; lt < NPC_MAX_LT; lt++) {\n\t\t\tfor (ld = 0; ld < NPC_MAX_LD; ld++) {\n\t\t\t\trsp->intf_lid_lt_ld[NIX_INTF_RX][lid][lt][ld] =\n\t\t\t\t\tGET_KEX_LD(NIX_INTF_RX, lid, lt, ld);\n\t\t\t\trsp->intf_lid_lt_ld[NIX_INTF_TX][lid][lt][ld] =\n\t\t\t\t\tGET_KEX_LD(NIX_INTF_TX, lid, lt, ld);\n\t\t\t}\n\t\t}\n\t}\n\tfor (ld = 0; ld < NPC_MAX_LD; ld++)\n\t\trsp->kex_ld_flags[ld] = GET_KEX_FLAGS(ld);\n\n\tfor (ld = 0; ld < NPC_MAX_LD; ld++) {\n\t\tfor (fl = 0; fl < NPC_MAX_LFL; fl++) {\n\t\t\trsp->intf_ld_flags[NIX_INTF_RX][ld][fl] =\n\t\t\t\t\tGET_KEX_LDFLAGS(NIX_INTF_RX, ld, fl);\n\t\t\trsp->intf_ld_flags[NIX_INTF_TX][ld][fl] =\n\t\t\t\t\tGET_KEX_LDFLAGS(NIX_INTF_TX, ld, fl);\n\t\t}\n\t}\n\tmemcpy(rsp->mkex_pfl_name, rvu->mkex_pfl_name, MKEX_NAME_LEN);\n\treturn 0;\n}\n\nstatic int\nnpc_set_var_len_offset_pkind(struct rvu *rvu, u16 pcifunc, u64 pkind,\n\t\t\t     u8 var_len_off, u8 var_len_off_mask, u8 shift_dir)\n{\n\tstruct npc_kpu_action0 *act0;\n\tu8 shift_count = 0;\n\tint blkaddr;\n\tu64 val;\n\n\tif (!var_len_off_mask)\n\t\treturn -EINVAL;\n\n\tif (var_len_off_mask != 0xff) {\n\t\tif (shift_dir)\n\t\t\tshift_count = __ffs(var_len_off_mask);\n\t\telse\n\t\t\tshift_count = (8 - __fls(var_len_off_mask));\n\t}\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, pcifunc);\n\tif (blkaddr < 0) {\n\t\tdev_err(rvu->dev, \"%s: NPC block not implemented\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tval = rvu_read64(rvu, blkaddr, NPC_AF_PKINDX_ACTION0(pkind));\n\tact0 = (struct npc_kpu_action0 *)&val;\n\tact0->var_len_shift = shift_count;\n\tact0->var_len_right = shift_dir;\n\tact0->var_len_mask = var_len_off_mask;\n\tact0->var_len_offset = var_len_off;\n\trvu_write64(rvu, blkaddr, NPC_AF_PKINDX_ACTION0(pkind), val);\n\treturn 0;\n}\n\nint rvu_npc_set_parse_mode(struct rvu *rvu, u16 pcifunc, u64 mode, u8 dir,\n\t\t\t   u64 pkind, u8 var_len_off, u8 var_len_off_mask,\n\t\t\t   u8 shift_dir)\n\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, pcifunc);\n\tint blkaddr, nixlf, rc, intf_mode;\n\tint pf = rvu_get_pf(pcifunc);\n\tu64 rxpkind, txpkind;\n\tu8 cgx_id, lmac_id;\n\n\t \n\trxpkind = rvu_npc_get_pkind(rvu, pf);\n\ttxpkind = NPC_TX_DEF_PKIND;\n\tintf_mode = NPC_INTF_MODE_DEF;\n\n\tif (mode & OTX2_PRIV_FLAGS_CUSTOM) {\n\t\tif (pkind == NPC_RX_CUSTOM_PRE_L2_PKIND) {\n\t\t\trc = npc_set_var_len_offset_pkind(rvu, pcifunc, pkind,\n\t\t\t\t\t\t\t  var_len_off,\n\t\t\t\t\t\t\t  var_len_off_mask,\n\t\t\t\t\t\t\t  shift_dir);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t\trxpkind = pkind;\n\t\ttxpkind = pkind;\n\t}\n\n\tif (dir & PKIND_RX) {\n\t\t \n\t\tif (!is_cgx_config_permitted(rvu, pcifunc))\n\t\t\treturn 0;\n\t\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\n\t\trc = cgx_set_pkind(rvu_cgx_pdata(cgx_id, rvu), lmac_id,\n\t\t\t\t   rxpkind);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (dir & PKIND_TX) {\n\t\t \n\t\trc = nix_get_nixlf(rvu, pcifunc, &nixlf, &blkaddr);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trvu_write64(rvu, blkaddr, NIX_AF_LFX_TX_PARSE_CFG(nixlf),\n\t\t\t    txpkind);\n\t}\n\n\tpfvf->intf_mode = intf_mode;\n\treturn 0;\n}\n\nint rvu_mbox_handler_npc_set_pkind(struct rvu *rvu, struct npc_set_pkind *req,\n\t\t\t\t   struct msg_rsp *rsp)\n{\n\treturn rvu_npc_set_parse_mode(rvu, req->hdr.pcifunc, req->mode,\n\t\t\t\t      req->dir, req->pkind, req->var_len_off,\n\t\t\t\t      req->var_len_off_mask, req->shift_dir);\n}\n\nint rvu_mbox_handler_npc_read_base_steer_rule(struct rvu *rvu,\n\t\t\t\t\t      struct msg_req *req,\n\t\t\t\t\t      struct npc_mcam_read_base_rule_rsp *rsp)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tint index, blkaddr, nixlf, rc = 0;\n\tu16 pcifunc = req->hdr.pcifunc;\n\tstruct rvu_pfvf *pfvf;\n\tu8 intf, enable;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\t \n\tif (!(pcifunc & RVU_PFVF_FUNC_MASK)) {\n\t\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\t\trsp->entry.kw[0] = pfvf->rx_chan_base;\n\t\trsp->entry.kw_mask[0] = 0xFFFULL;\n\t\tgoto out;\n\t}\n\n\t \n\tmutex_lock(&mcam->lock);\n\tfor (index = 0; index < mcam->bmap_entries; index++) {\n\t\tif (mcam->entry2target_pffunc[index] == pcifunc)\n\t\t\tgoto read_entry;\n\t}\n\n\trc = nix_get_nixlf(rvu, pcifunc, &nixlf, NULL);\n\tif (rc < 0) {\n\t\tmutex_unlock(&mcam->lock);\n\t\tgoto out;\n\t}\n\t \n\tindex = npc_get_nixlf_mcam_index(mcam, pcifunc, nixlf,\n\t\t\t\t\t NIXLF_UCAST_ENTRY);\nread_entry:\n\t \n\tnpc_read_mcam_entry(rvu, mcam, blkaddr, index, &rsp->entry, &intf,\n\t\t\t    &enable);\n\tmutex_unlock(&mcam->lock);\nout:\n\treturn rc;\n}\n\nint rvu_mbox_handler_npc_mcam_entry_stats(struct rvu *rvu,\n\t\t\t\t\t  struct npc_mcam_get_stats_req *req,\n\t\t\t\t\t  struct npc_mcam_get_stats_rsp *rsp)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu16 index, cntr;\n\tint blkaddr;\n\tu64 regval;\n\tu32 bank;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tmutex_lock(&mcam->lock);\n\n\tindex = req->entry & (mcam->banksize - 1);\n\tbank = npc_get_bank(mcam, req->entry);\n\n\t \n\tregval = rvu_read64(rvu, blkaddr, NPC_AF_MCAMEX_BANKX_STAT_ACT(index, bank));\n\n\tif (!(regval & rvu->hw->npc_stat_ena)) {\n\t\trsp->stat_ena = 0;\n\t\tmutex_unlock(&mcam->lock);\n\t\treturn 0;\n\t}\n\n\tcntr = regval & 0x1FF;\n\n\trsp->stat_ena = 1;\n\trsp->stat = rvu_read64(rvu, blkaddr, NPC_AF_MATCH_STATX(cntr));\n\trsp->stat &= BIT_ULL(48) - 1;\n\n\tmutex_unlock(&mcam->lock);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}