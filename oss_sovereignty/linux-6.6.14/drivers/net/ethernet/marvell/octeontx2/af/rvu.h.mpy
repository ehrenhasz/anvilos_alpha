{
  "module_name": "rvu.h",
  "hash_id": "ee9aa4aad22578786377152cf96258e86f8f63113daedb01523dde540fd45625",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/af/rvu.h",
  "human_readable_source": " \n \n\n#ifndef RVU_H\n#define RVU_H\n\n#include <linux/pci.h>\n#include <net/devlink.h>\n\n#include \"rvu_struct.h\"\n#include \"rvu_devlink.h\"\n#include \"common.h\"\n#include \"mbox.h\"\n#include \"npc.h\"\n#include \"rvu_reg.h\"\n#include \"ptp.h\"\n\n \n#define\tPCI_DEVID_OCTEONTX2_RVU_AF\t\t0xA065\n#define\tPCI_DEVID_OCTEONTX2_LBK\t\t\t0xA061\n\n \n#define PCI_SUBSYS_DEVID_98XX                  0xB100\n#define PCI_SUBSYS_DEVID_96XX                  0xB200\n#define PCI_SUBSYS_DEVID_CN10K_A\t       0xB900\n#define PCI_SUBSYS_DEVID_CNF10K_A\t       0xBA00\n#define PCI_SUBSYS_DEVID_CNF10K_B              0xBC00\n#define PCI_SUBSYS_DEVID_CN10K_B               0xBD00\n\n \n#define\tPCI_AF_REG_BAR_NUM\t\t\t0\n#define\tPCI_PF_REG_BAR_NUM\t\t\t2\n#define\tPCI_MBOX_BAR_NUM\t\t\t4\n\n#define NAME_SIZE\t\t\t\t32\n#define MAX_NIX_BLKS\t\t\t\t2\n#define MAX_CPT_BLKS\t\t\t\t2\n\n \n#define RVU_PFVF_PF_SHIFT\t10\n#define RVU_PFVF_PF_MASK\t0x3F\n#define RVU_PFVF_FUNC_SHIFT\t0\n#define RVU_PFVF_FUNC_MASK\t0x3FF\n\n#ifdef CONFIG_DEBUG_FS\nstruct dump_ctx {\n\tint\tlf;\n\tint\tid;\n\tbool\tall;\n};\n\nstruct cpt_ctx {\n\tint blkaddr;\n\tstruct rvu *rvu;\n};\n\nstruct rvu_debugfs {\n\tstruct dentry *root;\n\tstruct dentry *cgx_root;\n\tstruct dentry *cgx;\n\tstruct dentry *lmac;\n\tstruct dentry *npa;\n\tstruct dentry *nix;\n\tstruct dentry *npc;\n\tstruct dentry *cpt;\n\tstruct dentry *mcs_root;\n\tstruct dentry *mcs;\n\tstruct dentry *mcs_rx;\n\tstruct dentry *mcs_tx;\n\tstruct dump_ctx npa_aura_ctx;\n\tstruct dump_ctx npa_pool_ctx;\n\tstruct dump_ctx nix_cq_ctx;\n\tstruct dump_ctx nix_rq_ctx;\n\tstruct dump_ctx nix_sq_ctx;\n\tstruct cpt_ctx cpt_ctx[MAX_CPT_BLKS];\n\tint npa_qsize_id;\n\tint nix_qsize_id;\n};\n#endif\n\nstruct rvu_work {\n\tstruct\twork_struct work;\n\tstruct\trvu *rvu;\n\tint num_msgs;\n\tint up_num_msgs;\n};\n\nstruct rsrc_bmap {\n\tunsigned long *bmap;\t \n\tu16  max;\t\t \n};\n\nstruct rvu_block {\n\tstruct rsrc_bmap\tlf;\n\tstruct admin_queue\t*aq;  \n\tu16  *fn_map;  \n\tbool multislot;\n\tbool implemented;\n\tu8   addr;   \n\tu8   type;   \n\tu8   lfshift;\n\tu64  lookup_reg;\n\tu64  pf_lfcnt_reg;\n\tu64  vf_lfcnt_reg;\n\tu64  lfcfg_reg;\n\tu64  msixcfg_reg;\n\tu64  lfreset_reg;\n\tunsigned char name[NAME_SIZE];\n\tstruct rvu *rvu;\n\tu64 cpt_flt_eng_map[3];\n\tu64 cpt_rcvrd_eng_map[3];\n};\n\nstruct nix_mcast {\n\tstruct qmem\t*mce_ctx;\n\tstruct qmem\t*mcast_buf;\n\tint\t\treplay_pkind;\n\tint\t\tnext_free_mce;\n\tstruct mutex\tmce_lock;  \n};\n\nstruct nix_mce_list {\n\tstruct hlist_head\thead;\n\tint\t\t\tcount;\n\tint\t\t\tmax;\n};\n\n \nstruct npc_layer_mdata {\n\tu8 lid;\n\tu8 ltype;\n\tu8 hdr;\n\tu8 key;\n\tu8 len;\n};\n\n \nstruct npc_key_field {\n\t \n\tu64 kw_mask[NPC_MAX_KWS_IN_KEY];\n\t \n\tint nr_kws;\n\t \n\tstruct npc_layer_mdata layer_mdata;\n};\n\nstruct npc_mcam {\n\tstruct rsrc_bmap counters;\n\tstruct mutex\tlock;\t \n\tunsigned long\t*bmap;\t\t \n\tunsigned long\t*bmap_reverse;\t \n\tu16\tbmap_entries;\t \n\tu16\tbmap_fcnt;\t \n\tu16\t*entry2pfvf_map;\n\tu16\t*entry2cntr_map;\n\tu16\t*cntr2pfvf_map;\n\tu16\t*cntr_refcnt;\n\tu16\t*entry2target_pffunc;\n\tu8\tkeysize;\t \n\tu8\tbanks;\t\t \n\tu8\tbanks_per_entry; \n\tu16\tbanksize;\t \n\tu16\ttotal_entries;\t \n\tu16\tnixlf_offset;\t \n\tu16\tpf_offset;\t \n\tu16\tlprio_count;\n\tu16\tlprio_start;\n\tu16\thprio_count;\n\tu16\thprio_end;\n\tu16     rx_miss_act_cntr;  \n\t \n\tstruct npc_key_field\ttx_key_fields[NPC_KEY_FIELDS_MAX];\n\tstruct npc_key_field\trx_key_fields[NPC_KEY_FIELDS_MAX];\n\tu64\ttx_features;\n\tu64\trx_features;\n\tstruct list_head mcam_rules;\n};\n\n \nstruct rvu_pfvf {\n\tbool\t\tnpalf;  \n\tbool\t\tnixlf;  \n\tu16\t\tsso;\n\tu16\t\tssow;\n\tu16\t\tcptlfs;\n\tu16\t\ttimlfs;\n\tu16\t\tcpt1_lfs;\n\tu8\t\tcgx_lmac;\n\n\t \n\tstruct rsrc_bmap msix;       \n#define MSIX_BLKLF(blkaddr, lf) (((blkaddr) << 8) | ((lf) & 0xFF))\n\tu16\t\t *msix_lfmap;  \n\n\t \n\tstruct qmem\t*aura_ctx;\n\tstruct qmem\t*pool_ctx;\n\tstruct qmem\t*npa_qints_ctx;\n\tunsigned long\t*aura_bmap;\n\tunsigned long\t*pool_bmap;\n\n\t \n\tstruct qmem\t*rq_ctx;\n\tstruct qmem\t*sq_ctx;\n\tstruct qmem\t*cq_ctx;\n\tstruct qmem\t*rss_ctx;\n\tstruct qmem\t*cq_ints_ctx;\n\tstruct qmem\t*nix_qints_ctx;\n\tunsigned long\t*sq_bmap;\n\tunsigned long\t*rq_bmap;\n\tunsigned long\t*cq_bmap;\n\n\tu16\t\trx_chan_base;\n\tu16\t\ttx_chan_base;\n\tu8              rx_chan_cnt;  \n\tu8              tx_chan_cnt;  \n\tu16\t\tmaxlen;\n\tu16\t\tminlen;\n\n\tbool\t\thw_rx_tstamp_en;  \n\tu8\t\tmac_addr[ETH_ALEN];  \n\tu8\t\tdefault_mac[ETH_ALEN];  \n\n\t \n\tu16\t\t\tbcast_mce_idx;\n\tu16\t\t\tmcast_mce_idx;\n\tu16\t\t\tpromisc_mce_idx;\n\tstruct nix_mce_list\tbcast_mce_list;\n\tstruct nix_mce_list\tmcast_mce_list;\n\tstruct nix_mce_list\tpromisc_mce_list;\n\tbool\t\t\tuse_mce_list;\n\n\tstruct rvu_npc_mcam_rule *def_ucast_rule;\n\n\tbool\tcgx_in_use;  \n\tint\tcgx_users;   \n\n\tint     intf_mode;\n\tu8\tnix_blkaddr;  \n\tu8\tnix_rx_intf;  \n\tu8\tnix_tx_intf;  \n\tu8\tlbkid;\t      \n\tu64     lmt_base_addr;  \n\tu64     lmt_map_ent_w1;  \n\tunsigned long flags;\n\tstruct  sdp_node_info *sdp_info;\n};\n\nenum rvu_pfvf_flags {\n\tNIXLF_INITIALIZED = 0,\n\tPF_SET_VF_MAC,\n\tPF_SET_VF_CFG,\n\tPF_SET_VF_TRUSTED,\n};\n\n#define RVU_CLEAR_VF_PERM  ~GENMASK(PF_SET_VF_TRUSTED, PF_SET_VF_MAC)\n\nstruct nix_txsch {\n\tstruct rsrc_bmap schq;\n\tu8   lvl;\n#define NIX_TXSCHQ_FREE\t\t      BIT_ULL(1)\n#define NIX_TXSCHQ_CFG_DONE\t      BIT_ULL(0)\n#define TXSCH_MAP_FUNC(__pfvf_map)    ((__pfvf_map) & 0xFFFF)\n#define TXSCH_MAP_FLAGS(__pfvf_map)   ((__pfvf_map) >> 16)\n#define TXSCH_MAP(__func, __flags)    (((__func) & 0xFFFF) | ((__flags) << 16))\n#define TXSCH_SET_FLAG(__pfvf_map, flag)    ((__pfvf_map) | ((flag) << 16))\n\tu32  *pfvf_map;\n};\n\nstruct nix_mark_format {\n\tu8 total;\n\tu8 in_use;\n\tu32 *cfg;\n};\n\n \nstruct nix_smq_tree_ctx {\n\tu64 cir_off;\n\tu64 cir_val;\n\tu64 pir_off;\n\tu64 pir_val;\n};\n\n \nstruct nix_smq_flush_ctx {\n\tint smq;\n\tu16 tl1_schq;\n\tu16 tl2_schq;\n\tstruct nix_smq_tree_ctx smq_tree_ctx[NIX_TXSCH_LVL_CNT];\n};\n\nstruct npc_pkind {\n\tstruct rsrc_bmap rsrc;\n\tu32\t*pfchan_map;\n};\n\nstruct nix_flowkey {\n#define NIX_FLOW_KEY_ALG_MAX 32\n\tu32 flowkey[NIX_FLOW_KEY_ALG_MAX];\n\tint in_use;\n};\n\nstruct nix_lso {\n\tu8 total;\n\tu8 in_use;\n};\n\nstruct nix_txvlan {\n#define NIX_TX_VTAG_DEF_MAX 0x400\n\tstruct rsrc_bmap rsrc;\n\tu16 *entry2pfvf_map;\n\tstruct mutex rsrc_lock;  \n};\n\nstruct nix_ipolicer {\n\tstruct rsrc_bmap band_prof;\n\tu16 *pfvf_map;\n\tu16 *match_id;\n\tu16 *ref_count;\n};\n\nstruct nix_hw {\n\tint blkaddr;\n\tstruct rvu *rvu;\n\tstruct nix_txsch txsch[NIX_TXSCH_LVL_CNT];  \n\tstruct nix_mcast mcast;\n\tstruct nix_flowkey flowkey;\n\tstruct nix_mark_format mark_format;\n\tstruct nix_lso lso;\n\tstruct nix_txvlan txvlan;\n\tstruct nix_ipolicer *ipolicer;\n\tu64    *tx_credits;\n\tu8\tcc_mcs_cnt;\n};\n\n \nstruct hw_cap {\n\t \n\tu8\tnix_tx_aggr_lvl;  \n\tu16\tnix_txsch_per_cgx_lmac;  \n\tu16\tnix_txsch_per_lbk_lmac;  \n\tu16\tnix_txsch_per_sdp_lmac;  \n\tbool\tnix_fixed_txschq_mapping;  \n\tbool\tnix_shaping;\t\t  \n\tbool    nix_shaper_toggle_wait;  \n\tbool\tnix_tx_link_bp;\t\t  \n\tbool\tnix_rx_multicast;\t  \n\tbool\tnix_common_dwrr_mtu;\t  \n\tbool\tper_pf_mbox_regs;  \n\tbool\tprogrammable_chans;  \n\tbool\tipolicer;\n\tbool\tnix_multiple_dwrr_mtu;    \n\tbool\tnpc_hash_extract;  \n\tbool\tnpc_exact_match_enabled;  \n};\n\nstruct rvu_hwinfo {\n\tu8\ttotal_pfs;    \n\tu16\ttotal_vfs;    \n\tu16\tmax_vfs_per_pf;  \n\tu8\tcgx;\n\tu8\tlmac_per_cgx;\n\tu16\tcgx_chan_base;\t \n\tu16\tlbk_chan_base;\t \n\tu16\tsdp_chan_base;\t \n\tu16\tcpt_chan_base;\t \n\tu8\tcgx_links;\n\tu8\tlbk_links;\n\tu8\tsdp_links;\n\tu8\tcpt_links;\t \n\tu8\tnpc_kpus;           \n\tu8\tnpc_pkinds;         \n\tu8\tnpc_intfs;          \n\tu8\tnpc_kpu_entries;    \n\tu16\tnpc_counters;\t    \n\tu32\tlbk_bufsize;\t    \n\tbool\tnpc_ext_set;\t    \n\tu64     npc_stat_ena;       \n\n\tstruct hw_cap    cap;\n\tstruct rvu_block block[BLK_COUNT];  \n\tstruct nix_hw    *nix;\n\tstruct rvu\t *rvu;\n\tstruct npc_pkind pkind;\n\tstruct npc_mcam  mcam;\n\tstruct npc_exact_table *table;\n};\n\nstruct mbox_wq_info {\n\tstruct otx2_mbox mbox;\n\tstruct rvu_work *mbox_wrk;\n\n\tstruct otx2_mbox mbox_up;\n\tstruct rvu_work *mbox_wrk_up;\n\n\tstruct workqueue_struct *mbox_wq;\n};\n\nstruct rvu_fwdata {\n#define RVU_FWDATA_HEADER_MAGIC\t0xCFDA\t \n#define RVU_FWDATA_VERSION\t0x0001\n\tu32 header_magic;\n\tu32 version;\t\t \n\n\t \n#define PF_MACNUM_MAX\t32\n#define VF_MACNUM_MAX\t256\n\tu64 pf_macs[PF_MACNUM_MAX];\n\tu64 vf_macs[VF_MACNUM_MAX];\n\tu64 sclk;\n\tu64 rclk;\n\tu64 mcam_addr;\n\tu64 mcam_sz;\n\tu64 msixtr_base;\n\tu32 ptp_ext_clk_rate;\n\tu32 ptp_ext_tstamp;\n#define FWDATA_RESERVED_MEM 1022\n\tu64 reserved[FWDATA_RESERVED_MEM];\n#define CGX_MAX         9\n#define CGX_LMACS_MAX   4\n#define CGX_LMACS_USX   8\n\tunion {\n\t\tstruct cgx_lmac_fwdata_s\n\t\t\tcgx_fw_data[CGX_MAX][CGX_LMACS_MAX];\n\t\tstruct cgx_lmac_fwdata_s\n\t\t\tcgx_fw_data_usx[CGX_MAX][CGX_LMACS_USX];\n\t};\n\t \n};\n\nstruct ptp;\n\n \nstruct npc_kpu_profile_adapter {\n\tconst char\t\t\t*name;\n\tu64\t\t\t\tversion;\n\tconst struct npc_lt_def_cfg\t*lt_def;\n\tconst struct npc_kpu_profile_action\t*ikpu;  \n\tconst struct npc_kpu_profile\t*kpu;  \n\tstruct npc_mcam_kex\t\t*mkex;\n\tstruct npc_mcam_kex_hash\t*mkex_hash;\n\tbool\t\t\t\tcustom;\n\tsize_t\t\t\t\tpkinds;\n\tsize_t\t\t\t\tkpus;\n};\n\n#define RVU_SWITCH_LBK_CHAN\t63\n\nstruct rvu_switch {\n\tstruct mutex switch_lock;  \n\tu32 used_entries;\n\tu16 *entry2pcifunc;\n\tu16 mode;\n\tu16 start_entry;\n};\n\nstruct rvu {\n\tvoid __iomem\t\t*afreg_base;\n\tvoid __iomem\t\t*pfreg_base;\n\tstruct pci_dev\t\t*pdev;\n\tstruct device\t\t*dev;\n\tstruct rvu_hwinfo       *hw;\n\tstruct rvu_pfvf\t\t*pf;\n\tstruct rvu_pfvf\t\t*hwvf;\n\tstruct mutex\t\trsrc_lock;  \n\tstruct mutex\t\talias_lock;  \n\tint\t\t\tvfs;  \n\tint\t\t\tnix_blkaddr[MAX_NIX_BLKS];\n\n\t \n\tstruct mbox_wq_info\tafpf_wq_info;\n\tstruct mbox_wq_info\tafvf_wq_info;\n\n\t \n\tstruct rvu_work\t\t*flr_wrk;\n\tstruct workqueue_struct *flr_wq;\n\tstruct mutex\t\tflr_lock;  \n\n\t \n\tu16\t\t\tnum_vec;\n\tchar\t\t\t*irq_name;\n\tbool\t\t\t*irq_allocated;\n\tdma_addr_t\t\tmsix_base_iova;\n\tu64\t\t\tmsixtr_base_phy;  \n\n\t \n#define PF_CGXMAP_BASE\t\t1  \n\tu16\t\t\tcgx_mapped_vfs;  \n\tu8\t\t\tcgx_mapped_pfs;\n\tu8\t\t\tcgx_cnt_max;\t  \n\tu8\t\t\t*pf2cgxlmac_map;  \n\tu64\t\t\t*cgxlmac2pf_map;  \n\tunsigned long\t\tpf_notify_bmap;  \n\tvoid\t\t\t**cgx_idmap;  \n\tstruct\t\t\twork_struct cgx_evh_work;\n\tstruct\t\t\tworkqueue_struct *cgx_evh_wq;\n\tspinlock_t\t\tcgx_evq_lock;  \n\tstruct list_head\tcgx_evq_head;  \n\tstruct mutex\t\tcgx_cfg_lock;  \n\n\tchar mkex_pfl_name[MKEX_NAME_LEN];  \n\tchar kpu_pfl_name[KPU_NAME_LEN];  \n\n\t \n\tstruct rvu_fwdata\t*fwdata;\n\tvoid\t\t\t*kpu_fwdata;\n\tsize_t\t\t\tkpu_fwdata_sz;\n\tvoid __iomem\t\t*kpu_prfl_addr;\n\n\t \n\tstruct npc_kpu_profile_adapter kpu;\n\n\tstruct ptp\t\t*ptp;\n\n\tint\t\t\tmcs_blk_cnt;\n\tint\t\t\tcpt_pf_num;\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct rvu_debugfs\trvu_dbg;\n#endif\n\tstruct rvu_devlink\t*rvu_dl;\n\n\t \n\tstruct rvu_switch\trswitch;\n\n\tstruct\t\t\twork_struct mcs_intr_work;\n\tstruct\t\t\tworkqueue_struct *mcs_intr_wq;\n\tstruct list_head\tmcs_intrq_head;\n\t \n\tspinlock_t\t\tmcs_intrq_lock;\n\t \n\tspinlock_t\t\tcpt_intr_lock;\n};\n\nstatic inline void rvu_write64(struct rvu *rvu, u64 block, u64 offset, u64 val)\n{\n\twriteq(val, rvu->afreg_base + ((block << 28) | offset));\n}\n\nstatic inline u64 rvu_read64(struct rvu *rvu, u64 block, u64 offset)\n{\n\treturn readq(rvu->afreg_base + ((block << 28) | offset));\n}\n\nstatic inline void rvupf_write64(struct rvu *rvu, u64 offset, u64 val)\n{\n\twriteq(val, rvu->pfreg_base + offset);\n}\n\nstatic inline u64 rvupf_read64(struct rvu *rvu, u64 offset)\n{\n\treturn readq(rvu->pfreg_base + offset);\n}\n\nstatic inline void rvu_bar2_sel_write64(struct rvu *rvu, u64 block, u64 offset, u64 val)\n{\n\t \n\trvu_write64(rvu, block, offset, val);\n\trvu_read64(rvu, block, offset);\n\t \n\tmb();\n}\n\n \nstatic inline bool is_rvu_pre_96xx_C0(struct rvu *rvu)\n{\n\tstruct pci_dev *pdev = rvu->pdev;\n\t \n\treturn ((pdev->revision == 0x00) || (pdev->revision == 0x01) ||\n\t\t(pdev->revision == 0x10) || (pdev->revision == 0x11) ||\n\t\t(pdev->revision == 0x14));\n}\n\nstatic inline bool is_rvu_96xx_A0(struct rvu *rvu)\n{\n\tstruct pci_dev *pdev = rvu->pdev;\n\n\treturn (pdev->revision == 0x00);\n}\n\nstatic inline bool is_rvu_96xx_B0(struct rvu *rvu)\n{\n\tstruct pci_dev *pdev = rvu->pdev;\n\n\treturn (pdev->revision == 0x00) || (pdev->revision == 0x01);\n}\n\nstatic inline bool is_rvu_95xx_A0(struct rvu *rvu)\n{\n\tstruct pci_dev *pdev = rvu->pdev;\n\n\treturn (pdev->revision == 0x10) || (pdev->revision == 0x11);\n}\n\n \n#define PCI_REVISION_ID_96XX\t\t0x00\n#define PCI_REVISION_ID_95XX\t\t0x10\n#define PCI_REVISION_ID_95XXN\t\t0x20\n#define PCI_REVISION_ID_98XX\t\t0x30\n#define PCI_REVISION_ID_95XXMM\t\t0x40\n#define PCI_REVISION_ID_95XXO\t\t0xE0\n\nstatic inline bool is_rvu_otx2(struct rvu *rvu)\n{\n\tstruct pci_dev *pdev = rvu->pdev;\n\n\tu8 midr = pdev->revision & 0xF0;\n\n\treturn (midr == PCI_REVISION_ID_96XX || midr == PCI_REVISION_ID_95XX ||\n\t\tmidr == PCI_REVISION_ID_95XXN || midr == PCI_REVISION_ID_98XX ||\n\t\tmidr == PCI_REVISION_ID_95XXMM || midr == PCI_REVISION_ID_95XXO);\n}\n\nstatic inline bool is_cnf10ka_a0(struct rvu *rvu)\n{\n\tstruct pci_dev *pdev = rvu->pdev;\n\n\tif (pdev->subsystem_device == PCI_SUBSYS_DEVID_CNF10K_A &&\n\t    (pdev->revision & 0x0F) == 0x0)\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool is_rvu_npc_hash_extract_en(struct rvu *rvu)\n{\n\tu64 npc_const3;\n\n\tnpc_const3 = rvu_read64(rvu, BLKADDR_NPC, NPC_AF_CONST3);\n\tif (!(npc_const3 & BIT_ULL(62)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline u16 rvu_nix_chan_cgx(struct rvu *rvu, u8 cgxid,\n\t\t\t\t   u8 lmacid, u8 chan)\n{\n\tu64 nix_const = rvu_read64(rvu, BLKADDR_NIX0, NIX_AF_CONST);\n\tu16 cgx_chans = nix_const & 0xFFULL;\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\n\tif (!hw->cap.programmable_chans)\n\t\treturn NIX_CHAN_CGX_LMAC_CHX(cgxid, lmacid, chan);\n\n\treturn rvu->hw->cgx_chan_base +\n\t\t(cgxid * hw->lmac_per_cgx + lmacid) * cgx_chans + chan;\n}\n\nstatic inline u16 rvu_nix_chan_lbk(struct rvu *rvu, u8 lbkid,\n\t\t\t\t   u8 chan)\n{\n\tu64 nix_const = rvu_read64(rvu, BLKADDR_NIX0, NIX_AF_CONST);\n\tu16 lbk_chans = (nix_const >> 16) & 0xFFULL;\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\n\tif (!hw->cap.programmable_chans)\n\t\treturn NIX_CHAN_LBK_CHX(lbkid, chan);\n\n\treturn rvu->hw->lbk_chan_base + lbkid * lbk_chans + chan;\n}\n\nstatic inline u16 rvu_nix_chan_sdp(struct rvu *rvu, u8 chan)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\n\tif (!hw->cap.programmable_chans)\n\t\treturn NIX_CHAN_SDP_CHX(chan);\n\n\treturn hw->sdp_chan_base + chan;\n}\n\nstatic inline u16 rvu_nix_chan_cpt(struct rvu *rvu, u8 chan)\n{\n\treturn rvu->hw->cpt_chan_base + chan;\n}\n\nstatic inline bool is_rvu_supports_nix1(struct rvu *rvu)\n{\n\tstruct pci_dev *pdev = rvu->pdev;\n\n\tif (pdev->subsystem_device == PCI_SUBSYS_DEVID_98XX)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic inline bool is_afvf(u16 pcifunc)\n{\n\treturn !(pcifunc & ~RVU_PFVF_FUNC_MASK);\n}\n\nstatic inline bool is_vf(u16 pcifunc)\n{\n\treturn !!(pcifunc & RVU_PFVF_FUNC_MASK);\n}\n\n \nstatic inline bool is_pffunc_af(u16 pcifunc)\n{\n\treturn !pcifunc;\n}\n\nstatic inline bool is_rvu_fwdata_valid(struct rvu *rvu)\n{\n\treturn (rvu->fwdata->header_magic == RVU_FWDATA_HEADER_MAGIC) &&\n\t\t(rvu->fwdata->version == RVU_FWDATA_VERSION);\n}\n\nint rvu_alloc_bitmap(struct rsrc_bmap *rsrc);\nvoid rvu_free_bitmap(struct rsrc_bmap *rsrc);\nint rvu_alloc_rsrc(struct rsrc_bmap *rsrc);\nvoid rvu_free_rsrc(struct rsrc_bmap *rsrc, int id);\nbool is_rsrc_free(struct rsrc_bmap *rsrc, int id);\nint rvu_rsrc_free_count(struct rsrc_bmap *rsrc);\nint rvu_alloc_rsrc_contig(struct rsrc_bmap *rsrc, int nrsrc);\nbool rvu_rsrc_check_contig(struct rsrc_bmap *rsrc, int nrsrc);\nu16 rvu_get_rsrc_mapcount(struct rvu_pfvf *pfvf, int blkaddr);\nint rvu_get_pf(u16 pcifunc);\nstruct rvu_pfvf *rvu_get_pfvf(struct rvu *rvu, int pcifunc);\nvoid rvu_get_pf_numvfs(struct rvu *rvu, int pf, int *numvfs, int *hwvf);\nbool is_block_implemented(struct rvu_hwinfo *hw, int blkaddr);\nbool is_pffunc_map_valid(struct rvu *rvu, u16 pcifunc, int blktype);\nint rvu_get_lf(struct rvu *rvu, struct rvu_block *block, u16 pcifunc, u16 slot);\nint rvu_lf_reset(struct rvu *rvu, struct rvu_block *block, int lf);\nint rvu_get_blkaddr(struct rvu *rvu, int blktype, u16 pcifunc);\nint rvu_poll_reg(struct rvu *rvu, u64 block, u64 offset, u64 mask, bool zero);\nint rvu_get_num_lbk_chans(void);\nint rvu_get_blkaddr_from_slot(struct rvu *rvu, int blktype, u16 pcifunc,\n\t\t\t      u16 global_slot, u16 *slot_in_block);\n\n \nenum regmap_block {\n\tTXSCHQ_HWREGMAP = 0,\n\tMAX_HWREGMAP,\n};\n\nbool rvu_check_valid_reg(int regmap, int regblk, u64 reg);\n\n \nint rvu_aq_alloc(struct rvu *rvu, struct admin_queue **ad_queue,\n\t\t int qsize, int inst_size, int res_size);\nvoid rvu_aq_free(struct rvu *rvu, struct admin_queue *aq);\n\n \nint rvu_sdp_init(struct rvu *rvu);\nbool is_sdp_pfvf(u16 pcifunc);\nbool is_sdp_pf(u16 pcifunc);\nbool is_sdp_vf(u16 pcifunc);\n\n \nstatic inline bool is_pf_cgxmapped(struct rvu *rvu, u8 pf)\n{\n\treturn (pf >= PF_CGXMAP_BASE && pf <= rvu->cgx_mapped_pfs) &&\n\t\t!is_sdp_pf(pf << RVU_PFVF_PF_SHIFT);\n}\n\nstatic inline void rvu_get_cgx_lmac_id(u8 map, u8 *cgx_id, u8 *lmac_id)\n{\n\t*cgx_id = (map >> 4) & 0xF;\n\t*lmac_id = (map & 0xF);\n}\n\nstatic inline bool is_cgx_vf(struct rvu *rvu, u16 pcifunc)\n{\n\treturn ((pcifunc & RVU_PFVF_FUNC_MASK) &&\n\t\tis_pf_cgxmapped(rvu, rvu_get_pf(pcifunc)));\n}\n\n#define M(_name, _id, fn_name, req, rsp)\t\t\t\t\\\nint rvu_mbox_handler_ ## fn_name(struct rvu *, struct req *, struct rsp *);\nMBOX_MESSAGES\n#undef M\n\nint rvu_cgx_init(struct rvu *rvu);\nint rvu_cgx_exit(struct rvu *rvu);\nvoid *rvu_cgx_pdata(u8 cgx_id, struct rvu *rvu);\nint rvu_cgx_config_rxtx(struct rvu *rvu, u16 pcifunc, bool start);\nvoid rvu_cgx_enadis_rx_bp(struct rvu *rvu, int pf, bool enable);\nint rvu_cgx_start_stop_io(struct rvu *rvu, u16 pcifunc, bool start);\nint rvu_cgx_nix_cuml_stats(struct rvu *rvu, void *cgxd, int lmac_id, int index,\n\t\t\t   int rxtxflag, u64 *stat);\nvoid rvu_cgx_disable_dmac_entries(struct rvu *rvu, u16 pcifunc);\n\n \nint rvu_npa_init(struct rvu *rvu);\nvoid rvu_npa_freemem(struct rvu *rvu);\nvoid rvu_npa_lf_teardown(struct rvu *rvu, u16 pcifunc, int npalf);\nint rvu_npa_aq_enq_inst(struct rvu *rvu, struct npa_aq_enq_req *req,\n\t\t\tstruct npa_aq_enq_rsp *rsp);\n\n \nbool is_nixlf_attached(struct rvu *rvu, u16 pcifunc);\nint rvu_nix_init(struct rvu *rvu);\nint rvu_nix_reserve_mark_format(struct rvu *rvu, struct nix_hw *nix_hw,\n\t\t\t\tint blkaddr, u32 cfg);\nvoid rvu_nix_freemem(struct rvu *rvu);\nint rvu_get_nixlf_count(struct rvu *rvu);\nvoid rvu_nix_lf_teardown(struct rvu *rvu, u16 pcifunc, int blkaddr, int npalf);\nint nix_get_nixlf(struct rvu *rvu, u16 pcifunc, int *nixlf, int *nix_blkaddr);\nint nix_update_mce_list(struct rvu *rvu, u16 pcifunc,\n\t\t\tstruct nix_mce_list *mce_list,\n\t\t\tint mce_idx, int mcam_index, bool add);\nvoid nix_get_mce_list(struct rvu *rvu, u16 pcifunc, int type,\n\t\t      struct nix_mce_list **mce_list, int *mce_idx);\nstruct nix_hw *get_nix_hw(struct rvu_hwinfo *hw, int blkaddr);\nint rvu_get_next_nix_blkaddr(struct rvu *rvu, int blkaddr);\nvoid rvu_nix_reset_mac(struct rvu_pfvf *pfvf, int pcifunc);\nint nix_get_struct_ptrs(struct rvu *rvu, u16 pcifunc,\n\t\t\tstruct nix_hw **nix_hw, int *blkaddr);\nint rvu_nix_setup_ratelimit_aggr(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t u16 rq_idx, u16 match_id);\nint nix_aq_context_read(struct rvu *rvu, struct nix_hw *nix_hw,\n\t\t\tstruct nix_cn10k_aq_enq_req *aq_req,\n\t\t\tstruct nix_cn10k_aq_enq_rsp *aq_rsp,\n\t\t\tu16 pcifunc, u8 ctype, u32 qidx);\nint rvu_get_nix_blkaddr(struct rvu *rvu, u16 pcifunc);\nint nix_get_dwrr_mtu_reg(struct rvu_hwinfo *hw, int smq_link_type);\nu32 convert_dwrr_mtu_to_bytes(u8 dwrr_mtu);\nu32 convert_bytes_to_dwrr_mtu(u32 bytes);\nvoid rvu_nix_tx_tl2_cfg(struct rvu *rvu, int blkaddr, u16 pcifunc,\n\t\t\tstruct nix_txsch *txsch, bool enable);\n\n \nvoid rvu_npc_freemem(struct rvu *rvu);\nint rvu_npc_get_pkind(struct rvu *rvu, u16 pf);\nvoid rvu_npc_set_pkind(struct rvu *rvu, int pkind, struct rvu_pfvf *pfvf);\nint npc_config_ts_kpuaction(struct rvu *rvu, int pf, u16 pcifunc, bool en);\nvoid rvu_npc_install_ucast_entry(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t int nixlf, u64 chan, u8 *mac_addr);\nvoid rvu_npc_install_promisc_entry(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t   int nixlf, u64 chan, u8 chan_cnt);\nvoid rvu_npc_enable_promisc_entry(struct rvu *rvu, u16 pcifunc, int nixlf,\n\t\t\t\t  bool enable);\nvoid rvu_npc_install_bcast_match_entry(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t       int nixlf, u64 chan);\nvoid rvu_npc_enable_bcast_entry(struct rvu *rvu, u16 pcifunc, int nixlf,\n\t\t\t\tbool enable);\nvoid rvu_npc_install_allmulti_entry(struct rvu *rvu, u16 pcifunc, int nixlf,\n\t\t\t\t    u64 chan);\nvoid rvu_npc_enable_allmulti_entry(struct rvu *rvu, u16 pcifunc, int nixlf,\n\t\t\t\t   bool enable);\n\nvoid npc_enadis_default_mce_entry(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t  int nixlf, int type, bool enable);\nvoid rvu_npc_disable_mcam_entries(struct rvu *rvu, u16 pcifunc, int nixlf);\nbool rvu_npc_enable_mcam_by_entry_index(struct rvu *rvu, int entry, int intf, bool enable);\nvoid rvu_npc_free_mcam_entries(struct rvu *rvu, u16 pcifunc, int nixlf);\nvoid rvu_npc_disable_default_entries(struct rvu *rvu, u16 pcifunc, int nixlf);\nvoid rvu_npc_enable_default_entries(struct rvu *rvu, u16 pcifunc, int nixlf);\nvoid rvu_npc_update_flowkey_alg_idx(struct rvu *rvu, u16 pcifunc, int nixlf,\n\t\t\t\t    int group, int alg_idx, int mcam_index);\n\nvoid rvu_npc_get_mcam_entry_alloc_info(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t       int blkaddr, int *alloc_cnt,\n\t\t\t\t       int *enable_cnt);\nvoid rvu_npc_get_mcam_counter_alloc_info(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t\t int blkaddr, int *alloc_cnt,\n\t\t\t\t\t int *enable_cnt);\nbool is_npc_intf_tx(u8 intf);\nbool is_npc_intf_rx(u8 intf);\nbool is_npc_interface_valid(struct rvu *rvu, u8 intf);\nint rvu_npc_get_tx_nibble_cfg(struct rvu *rvu, u64 nibble_ena);\nint npc_flow_steering_init(struct rvu *rvu, int blkaddr);\nconst char *npc_get_field_name(u8 hdr);\nint npc_get_bank(struct npc_mcam *mcam, int index);\nvoid npc_mcam_enable_flows(struct rvu *rvu, u16 target);\nvoid npc_mcam_disable_flows(struct rvu *rvu, u16 target);\nvoid npc_enable_mcam_entry(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t   int blkaddr, int index, bool enable);\nvoid npc_read_mcam_entry(struct rvu *rvu, struct npc_mcam *mcam,\n\t\t\t int blkaddr, u16 src, struct mcam_entry *entry,\n\t\t\t u8 *intf, u8 *ena);\nbool is_cgx_config_permitted(struct rvu *rvu, u16 pcifunc);\nbool is_mac_feature_supported(struct rvu *rvu, int pf, int feature);\nu32  rvu_cgx_get_fifolen(struct rvu *rvu);\nvoid *rvu_first_cgx_pdata(struct rvu *rvu);\nint cgxlmac_to_pf(struct rvu *rvu, int cgx_id, int lmac_id);\nint rvu_cgx_config_tx(void *cgxd, int lmac_id, bool enable);\nint rvu_cgx_tx_enable(struct rvu *rvu, u16 pcifunc, bool enable);\nint rvu_cgx_prio_flow_ctrl_cfg(struct rvu *rvu, u16 pcifunc, u8 tx_pause, u8 rx_pause,\n\t\t\t       u16 pfc_en);\nint rvu_cgx_cfg_pause_frm(struct rvu *rvu, u16 pcifunc, u8 tx_pause, u8 rx_pause);\nvoid rvu_mac_reset(struct rvu *rvu, u16 pcifunc);\nu32 rvu_cgx_get_lmac_fifolen(struct rvu *rvu, int cgx, int lmac);\nint npc_get_nixlf_mcam_index(struct npc_mcam *mcam, u16 pcifunc, int nixlf,\n\t\t\t     int type);\nbool is_mcam_entry_enabled(struct rvu *rvu, struct npc_mcam *mcam, int blkaddr,\n\t\t\t   int index);\nint rvu_npc_init(struct rvu *rvu);\nint npc_install_mcam_drop_rule(struct rvu *rvu, int mcam_idx, u16 *counter_idx,\n\t\t\t       u64 chan_val, u64 chan_mask, u64 exact_val, u64 exact_mask,\n\t\t\t       u64 bcast_mcast_val, u64 bcast_mcast_mask);\nvoid npc_mcam_rsrcs_reserve(struct rvu *rvu, int blkaddr, int entry_idx);\nbool npc_is_feature_supported(struct rvu *rvu, u64 features, u8 intf);\n\n \nint rvu_cpt_register_interrupts(struct rvu *rvu);\nvoid rvu_cpt_unregister_interrupts(struct rvu *rvu);\nint rvu_cpt_lf_teardown(struct rvu *rvu, u16 pcifunc, int blkaddr, int lf,\n\t\t\tint slot);\nint rvu_cpt_ctx_flush(struct rvu *rvu, u16 pcifunc);\nint rvu_cpt_init(struct rvu *rvu);\n\n#define NDC_AF_BANK_MASK       GENMASK_ULL(7, 0)\n#define NDC_AF_BANK_LINE_MASK  GENMASK_ULL(31, 16)\n\n \nint rvu_set_channels_base(struct rvu *rvu);\nvoid rvu_program_channels(struct rvu *rvu);\n\n \nvoid rvu_nix_block_cn10k_init(struct rvu *rvu, struct nix_hw *nix_hw);\n\n \nvoid rvu_reset_lmt_map_tbl(struct rvu *rvu, u16 pcifunc);\n\n#ifdef CONFIG_DEBUG_FS\nvoid rvu_dbg_init(struct rvu *rvu);\nvoid rvu_dbg_exit(struct rvu *rvu);\n#else\nstatic inline void rvu_dbg_init(struct rvu *rvu) {}\nstatic inline void rvu_dbg_exit(struct rvu *rvu) {}\n#endif\n\nint rvu_ndc_fix_locked_cacheline(struct rvu *rvu, int blkaddr);\n\n \nvoid rvu_switch_enable(struct rvu *rvu);\nvoid rvu_switch_disable(struct rvu *rvu);\nvoid rvu_switch_update_rules(struct rvu *rvu, u16 pcifunc);\n\nint rvu_npc_set_parse_mode(struct rvu *rvu, u16 pcifunc, u64 mode, u8 dir,\n\t\t\t   u64 pkind, u8 var_len_off, u8 var_len_off_mask,\n\t\t\t   u8 shift_dir);\nint rvu_get_hwvf(struct rvu *rvu, int pcifunc);\n\n \nint rvu_mcs_init(struct rvu *rvu);\nint rvu_mcs_flr_handler(struct rvu *rvu, u16 pcifunc);\nvoid rvu_mcs_ptp_cfg(struct rvu *rvu, u8 rpm_id, u8 lmac_id, bool ena);\nvoid rvu_mcs_exit(struct rvu *rvu);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}