{
  "module_name": "rvu_debugfs.c",
  "hash_id": "0dfc1a304b9a0d0353e9451c3f6b50960e3d315b9357016c5733de43ba143afb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/af/rvu_debugfs.c",
  "human_readable_source": "\n \n\n#ifdef CONFIG_DEBUG_FS\n\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"rvu_struct.h\"\n#include \"rvu_reg.h\"\n#include \"rvu.h\"\n#include \"cgx.h\"\n#include \"lmac_common.h\"\n#include \"npc.h\"\n#include \"rvu_npc_hash.h\"\n#include \"mcs.h\"\n\n#define DEBUGFS_DIR_NAME \"octeontx2\"\n\nenum {\n\tCGX_STAT0,\n\tCGX_STAT1,\n\tCGX_STAT2,\n\tCGX_STAT3,\n\tCGX_STAT4,\n\tCGX_STAT5,\n\tCGX_STAT6,\n\tCGX_STAT7,\n\tCGX_STAT8,\n\tCGX_STAT9,\n\tCGX_STAT10,\n\tCGX_STAT11,\n\tCGX_STAT12,\n\tCGX_STAT13,\n\tCGX_STAT14,\n\tCGX_STAT15,\n\tCGX_STAT16,\n\tCGX_STAT17,\n\tCGX_STAT18,\n};\n\n \nenum nix_stat_lf_tx {\n\tTX_UCAST\t= 0x0,\n\tTX_BCAST\t= 0x1,\n\tTX_MCAST\t= 0x2,\n\tTX_DROP\t\t= 0x3,\n\tTX_OCTS\t\t= 0x4,\n\tTX_STATS_ENUM_LAST,\n};\n\n \nenum nix_stat_lf_rx {\n\tRX_OCTS\t\t= 0x0,\n\tRX_UCAST\t= 0x1,\n\tRX_BCAST\t= 0x2,\n\tRX_MCAST\t= 0x3,\n\tRX_DROP\t\t= 0x4,\n\tRX_DROP_OCTS\t= 0x5,\n\tRX_FCS\t\t= 0x6,\n\tRX_ERR\t\t= 0x7,\n\tRX_DRP_BCAST\t= 0x8,\n\tRX_DRP_MCAST\t= 0x9,\n\tRX_DRP_L3BCAST\t= 0xa,\n\tRX_DRP_L3MCAST\t= 0xb,\n\tRX_STATS_ENUM_LAST,\n};\n\nstatic char *cgx_rx_stats_fields[] = {\n\t[CGX_STAT0]\t= \"Received packets\",\n\t[CGX_STAT1]\t= \"Octets of received packets\",\n\t[CGX_STAT2]\t= \"Received PAUSE packets\",\n\t[CGX_STAT3]\t= \"Received PAUSE and control packets\",\n\t[CGX_STAT4]\t= \"Filtered DMAC0 (NIX-bound) packets\",\n\t[CGX_STAT5]\t= \"Filtered DMAC0 (NIX-bound) octets\",\n\t[CGX_STAT6]\t= \"Packets dropped due to RX FIFO full\",\n\t[CGX_STAT7]\t= \"Octets dropped due to RX FIFO full\",\n\t[CGX_STAT8]\t= \"Error packets\",\n\t[CGX_STAT9]\t= \"Filtered DMAC1 (NCSI-bound) packets\",\n\t[CGX_STAT10]\t= \"Filtered DMAC1 (NCSI-bound) octets\",\n\t[CGX_STAT11]\t= \"NCSI-bound packets dropped\",\n\t[CGX_STAT12]\t= \"NCSI-bound octets dropped\",\n};\n\nstatic char *cgx_tx_stats_fields[] = {\n\t[CGX_STAT0]\t= \"Packets dropped due to excessive collisions\",\n\t[CGX_STAT1]\t= \"Packets dropped due to excessive deferral\",\n\t[CGX_STAT2]\t= \"Multiple collisions before successful transmission\",\n\t[CGX_STAT3]\t= \"Single collisions before successful transmission\",\n\t[CGX_STAT4]\t= \"Total octets sent on the interface\",\n\t[CGX_STAT5]\t= \"Total frames sent on the interface\",\n\t[CGX_STAT6]\t= \"Packets sent with an octet count < 64\",\n\t[CGX_STAT7]\t= \"Packets sent with an octet count == 64\",\n\t[CGX_STAT8]\t= \"Packets sent with an octet count of 65-127\",\n\t[CGX_STAT9]\t= \"Packets sent with an octet count of 128-255\",\n\t[CGX_STAT10]\t= \"Packets sent with an octet count of 256-511\",\n\t[CGX_STAT11]\t= \"Packets sent with an octet count of 512-1023\",\n\t[CGX_STAT12]\t= \"Packets sent with an octet count of 1024-1518\",\n\t[CGX_STAT13]\t= \"Packets sent with an octet count of > 1518\",\n\t[CGX_STAT14]\t= \"Packets sent to a broadcast DMAC\",\n\t[CGX_STAT15]\t= \"Packets sent to the multicast DMAC\",\n\t[CGX_STAT16]\t= \"Transmit underflow and were truncated\",\n\t[CGX_STAT17]\t= \"Control/PAUSE packets sent\",\n};\n\nstatic char *rpm_rx_stats_fields[] = {\n\t\"Octets of received packets\",\n\t\"Octets of received packets with out error\",\n\t\"Received packets with alignment errors\",\n\t\"Control/PAUSE packets received\",\n\t\"Packets received with Frame too long Errors\",\n\t\"Packets received with a1nrange length Errors\",\n\t\"Received packets\",\n\t\"Packets received with FrameCheckSequenceErrors\",\n\t\"Packets received with VLAN header\",\n\t\"Error packets\",\n\t\"Packets received with unicast DMAC\",\n\t\"Packets received with multicast DMAC\",\n\t\"Packets received with broadcast DMAC\",\n\t\"Dropped packets\",\n\t\"Total frames received on interface\",\n\t\"Packets received with an octet count < 64\",\n\t\"Packets received with an octet count == 64\",\n\t\"Packets received with an octet count of 65-127\",\n\t\"Packets received with an octet count of 128-255\",\n\t\"Packets received with an octet count of 256-511\",\n\t\"Packets received with an octet count of 512-1023\",\n\t\"Packets received with an octet count of 1024-1518\",\n\t\"Packets received with an octet count of > 1518\",\n\t\"Oversized Packets\",\n\t\"Jabber Packets\",\n\t\"Fragmented Packets\",\n\t\"CBFC(class based flow control) pause frames received for class 0\",\n\t\"CBFC pause frames received for class 1\",\n\t\"CBFC pause frames received for class 2\",\n\t\"CBFC pause frames received for class 3\",\n\t\"CBFC pause frames received for class 4\",\n\t\"CBFC pause frames received for class 5\",\n\t\"CBFC pause frames received for class 6\",\n\t\"CBFC pause frames received for class 7\",\n\t\"CBFC pause frames received for class 8\",\n\t\"CBFC pause frames received for class 9\",\n\t\"CBFC pause frames received for class 10\",\n\t\"CBFC pause frames received for class 11\",\n\t\"CBFC pause frames received for class 12\",\n\t\"CBFC pause frames received for class 13\",\n\t\"CBFC pause frames received for class 14\",\n\t\"CBFC pause frames received for class 15\",\n\t\"MAC control packets received\",\n};\n\nstatic char *rpm_tx_stats_fields[] = {\n\t\"Total octets sent on the interface\",\n\t\"Total octets transmitted OK\",\n\t\"Control/Pause frames sent\",\n\t\"Total frames transmitted OK\",\n\t\"Total frames sent with VLAN header\",\n\t\"Error Packets\",\n\t\"Packets sent to unicast DMAC\",\n\t\"Packets sent to the multicast DMAC\",\n\t\"Packets sent to a broadcast DMAC\",\n\t\"Packets sent with an octet count == 64\",\n\t\"Packets sent with an octet count of 65-127\",\n\t\"Packets sent with an octet count of 128-255\",\n\t\"Packets sent with an octet count of 256-511\",\n\t\"Packets sent with an octet count of 512-1023\",\n\t\"Packets sent with an octet count of 1024-1518\",\n\t\"Packets sent with an octet count of > 1518\",\n\t\"CBFC(class based flow control) pause frames transmitted for class 0\",\n\t\"CBFC pause frames transmitted for class 1\",\n\t\"CBFC pause frames transmitted for class 2\",\n\t\"CBFC pause frames transmitted for class 3\",\n\t\"CBFC pause frames transmitted for class 4\",\n\t\"CBFC pause frames transmitted for class 5\",\n\t\"CBFC pause frames transmitted for class 6\",\n\t\"CBFC pause frames transmitted for class 7\",\n\t\"CBFC pause frames transmitted for class 8\",\n\t\"CBFC pause frames transmitted for class 9\",\n\t\"CBFC pause frames transmitted for class 10\",\n\t\"CBFC pause frames transmitted for class 11\",\n\t\"CBFC pause frames transmitted for class 12\",\n\t\"CBFC pause frames transmitted for class 13\",\n\t\"CBFC pause frames transmitted for class 14\",\n\t\"CBFC pause frames transmitted for class 15\",\n\t\"MAC control packets sent\",\n\t\"Total frames sent on the interface\"\n};\n\nenum cpt_eng_type {\n\tCPT_AE_TYPE = 1,\n\tCPT_SE_TYPE = 2,\n\tCPT_IE_TYPE = 3,\n};\n\n#define rvu_dbg_NULL NULL\n#define rvu_dbg_open_NULL NULL\n\n#define RVU_DEBUG_SEQ_FOPS(name, read_op, write_op)\t\\\nstatic int rvu_dbg_open_##name(struct inode *inode, struct file *file) \\\n{ \\\n\treturn single_open(file, rvu_dbg_##read_op, inode->i_private); \\\n} \\\nstatic const struct file_operations rvu_dbg_##name##_fops = { \\\n\t.owner\t\t= THIS_MODULE, \\\n\t.open\t\t= rvu_dbg_open_##name, \\\n\t.read\t\t= seq_read, \\\n\t.write\t\t= rvu_dbg_##write_op, \\\n\t.llseek\t\t= seq_lseek, \\\n\t.release\t= single_release, \\\n}\n\n#define RVU_DEBUG_FOPS(name, read_op, write_op) \\\nstatic const struct file_operations rvu_dbg_##name##_fops = { \\\n\t.owner = THIS_MODULE, \\\n\t.open = simple_open, \\\n\t.read = rvu_dbg_##read_op, \\\n\t.write = rvu_dbg_##write_op \\\n}\n\nstatic void print_nix_qsize(struct seq_file *filp, struct rvu_pfvf *pfvf);\n\nstatic int rvu_dbg_mcs_port_stats_display(struct seq_file *filp, void *unused, int dir)\n{\n\tstruct mcs *mcs = filp->private;\n\tstruct mcs_port_stats stats;\n\tint lmac;\n\n\tseq_puts(filp, \"\\n port stats\\n\");\n\tmutex_lock(&mcs->stats_lock);\n\tfor_each_set_bit(lmac, &mcs->hw->lmac_bmap, mcs->hw->lmac_cnt) {\n\t\tmcs_get_port_stats(mcs, &stats, lmac, dir);\n\t\tseq_printf(filp, \"port%d: Tcam Miss: %lld\\n\", lmac, stats.tcam_miss_cnt);\n\t\tseq_printf(filp, \"port%d: Parser errors: %lld\\n\", lmac, stats.parser_err_cnt);\n\n\t\tif (dir == MCS_RX && mcs->hw->mcs_blks > 1)\n\t\t\tseq_printf(filp, \"port%d: Preempt error: %lld\\n\", lmac,\n\t\t\t\t   stats.preempt_err_cnt);\n\t\tif (dir == MCS_TX)\n\t\t\tseq_printf(filp, \"port%d: Sectag insert error: %lld\\n\", lmac,\n\t\t\t\t   stats.sectag_insert_err_cnt);\n\t}\n\tmutex_unlock(&mcs->stats_lock);\n\treturn 0;\n}\n\nstatic int rvu_dbg_mcs_rx_port_stats_display(struct seq_file *filp, void *unused)\n{\n\treturn rvu_dbg_mcs_port_stats_display(filp, unused, MCS_RX);\n}\n\nRVU_DEBUG_SEQ_FOPS(mcs_rx_port_stats, mcs_rx_port_stats_display, NULL);\n\nstatic int rvu_dbg_mcs_tx_port_stats_display(struct seq_file *filp, void *unused)\n{\n\treturn rvu_dbg_mcs_port_stats_display(filp, unused, MCS_TX);\n}\n\nRVU_DEBUG_SEQ_FOPS(mcs_tx_port_stats, mcs_tx_port_stats_display, NULL);\n\nstatic int rvu_dbg_mcs_sa_stats_display(struct seq_file *filp, void *unused, int dir)\n{\n\tstruct mcs *mcs = filp->private;\n\tstruct mcs_sa_stats stats;\n\tstruct rsrc_bmap *map;\n\tint sa_id;\n\n\tif (dir == MCS_TX) {\n\t\tmap = &mcs->tx.sa;\n\t\tmutex_lock(&mcs->stats_lock);\n\t\tfor_each_set_bit(sa_id, map->bmap, mcs->hw->sa_entries) {\n\t\t\tseq_puts(filp, \"\\n TX SA stats\\n\");\n\t\t\tmcs_get_sa_stats(mcs, &stats, sa_id, MCS_TX);\n\t\t\tseq_printf(filp, \"sa%d: Pkts encrypted: %lld\\n\", sa_id,\n\t\t\t\t   stats.pkt_encrypt_cnt);\n\n\t\t\tseq_printf(filp, \"sa%d: Pkts protected: %lld\\n\", sa_id,\n\t\t\t\t   stats.pkt_protected_cnt);\n\t\t}\n\t\tmutex_unlock(&mcs->stats_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tmap = &mcs->rx.sa;\n\tmutex_lock(&mcs->stats_lock);\n\tfor_each_set_bit(sa_id, map->bmap, mcs->hw->sa_entries) {\n\t\tseq_puts(filp, \"\\n RX SA stats\\n\");\n\t\tmcs_get_sa_stats(mcs, &stats, sa_id, MCS_RX);\n\t\tseq_printf(filp, \"sa%d: Invalid pkts: %lld\\n\", sa_id, stats.pkt_invalid_cnt);\n\t\tseq_printf(filp, \"sa%d: Pkts no sa error: %lld\\n\", sa_id, stats.pkt_nosaerror_cnt);\n\t\tseq_printf(filp, \"sa%d: Pkts not valid: %lld\\n\", sa_id, stats.pkt_notvalid_cnt);\n\t\tseq_printf(filp, \"sa%d: Pkts ok: %lld\\n\", sa_id, stats.pkt_ok_cnt);\n\t\tseq_printf(filp, \"sa%d: Pkts no sa: %lld\\n\", sa_id, stats.pkt_nosa_cnt);\n\t}\n\tmutex_unlock(&mcs->stats_lock);\n\treturn 0;\n}\n\nstatic int rvu_dbg_mcs_rx_sa_stats_display(struct seq_file *filp, void *unused)\n{\n\treturn rvu_dbg_mcs_sa_stats_display(filp, unused, MCS_RX);\n}\n\nRVU_DEBUG_SEQ_FOPS(mcs_rx_sa_stats, mcs_rx_sa_stats_display, NULL);\n\nstatic int rvu_dbg_mcs_tx_sa_stats_display(struct seq_file *filp, void *unused)\n{\n\treturn rvu_dbg_mcs_sa_stats_display(filp, unused, MCS_TX);\n}\n\nRVU_DEBUG_SEQ_FOPS(mcs_tx_sa_stats, mcs_tx_sa_stats_display, NULL);\n\nstatic int rvu_dbg_mcs_tx_sc_stats_display(struct seq_file *filp, void *unused)\n{\n\tstruct mcs *mcs = filp->private;\n\tstruct mcs_sc_stats stats;\n\tstruct rsrc_bmap *map;\n\tint sc_id;\n\n\tmap = &mcs->tx.sc;\n\tseq_puts(filp, \"\\n SC stats\\n\");\n\n\tmutex_lock(&mcs->stats_lock);\n\tfor_each_set_bit(sc_id, map->bmap, mcs->hw->sc_entries) {\n\t\tmcs_get_sc_stats(mcs, &stats, sc_id, MCS_TX);\n\t\tseq_printf(filp, \"\\n=======sc%d======\\n\\n\", sc_id);\n\t\tseq_printf(filp, \"sc%d: Pkts encrypted: %lld\\n\", sc_id, stats.pkt_encrypt_cnt);\n\t\tseq_printf(filp, \"sc%d: Pkts protected: %lld\\n\", sc_id, stats.pkt_protected_cnt);\n\n\t\tif (mcs->hw->mcs_blks == 1) {\n\t\t\tseq_printf(filp, \"sc%d: Octets encrypted: %lld\\n\", sc_id,\n\t\t\t\t   stats.octet_encrypt_cnt);\n\t\t\tseq_printf(filp, \"sc%d: Octets protected: %lld\\n\", sc_id,\n\t\t\t\t   stats.octet_protected_cnt);\n\t\t}\n\t}\n\tmutex_unlock(&mcs->stats_lock);\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(mcs_tx_sc_stats, mcs_tx_sc_stats_display, NULL);\n\nstatic int rvu_dbg_mcs_rx_sc_stats_display(struct seq_file *filp, void *unused)\n{\n\tstruct mcs *mcs = filp->private;\n\tstruct mcs_sc_stats stats;\n\tstruct rsrc_bmap *map;\n\tint sc_id;\n\n\tmap = &mcs->rx.sc;\n\tseq_puts(filp, \"\\n SC stats\\n\");\n\n\tmutex_lock(&mcs->stats_lock);\n\tfor_each_set_bit(sc_id, map->bmap, mcs->hw->sc_entries) {\n\t\tmcs_get_sc_stats(mcs, &stats, sc_id, MCS_RX);\n\t\tseq_printf(filp, \"\\n=======sc%d======\\n\\n\", sc_id);\n\t\tseq_printf(filp, \"sc%d: Cam hits: %lld\\n\", sc_id, stats.hit_cnt);\n\t\tseq_printf(filp, \"sc%d: Invalid pkts: %lld\\n\", sc_id, stats.pkt_invalid_cnt);\n\t\tseq_printf(filp, \"sc%d: Late pkts: %lld\\n\", sc_id, stats.pkt_late_cnt);\n\t\tseq_printf(filp, \"sc%d: Notvalid pkts: %lld\\n\", sc_id, stats.pkt_notvalid_cnt);\n\t\tseq_printf(filp, \"sc%d: Unchecked pkts: %lld\\n\", sc_id, stats.pkt_unchecked_cnt);\n\n\t\tif (mcs->hw->mcs_blks > 1) {\n\t\t\tseq_printf(filp, \"sc%d: Delay pkts: %lld\\n\", sc_id, stats.pkt_delay_cnt);\n\t\t\tseq_printf(filp, \"sc%d: Pkts ok: %lld\\n\", sc_id, stats.pkt_ok_cnt);\n\t\t}\n\t\tif (mcs->hw->mcs_blks == 1) {\n\t\t\tseq_printf(filp, \"sc%d: Octets decrypted: %lld\\n\", sc_id,\n\t\t\t\t   stats.octet_decrypt_cnt);\n\t\t\tseq_printf(filp, \"sc%d: Octets validated: %lld\\n\", sc_id,\n\t\t\t\t   stats.octet_validate_cnt);\n\t\t}\n\t}\n\tmutex_unlock(&mcs->stats_lock);\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(mcs_rx_sc_stats, mcs_rx_sc_stats_display, NULL);\n\nstatic int rvu_dbg_mcs_flowid_stats_display(struct seq_file *filp, void *unused, int dir)\n{\n\tstruct mcs *mcs = filp->private;\n\tstruct mcs_flowid_stats stats;\n\tstruct rsrc_bmap *map;\n\tint flow_id;\n\n\tseq_puts(filp, \"\\n Flowid stats\\n\");\n\n\tif (dir == MCS_RX)\n\t\tmap = &mcs->rx.flow_ids;\n\telse\n\t\tmap = &mcs->tx.flow_ids;\n\n\tmutex_lock(&mcs->stats_lock);\n\tfor_each_set_bit(flow_id, map->bmap, mcs->hw->tcam_entries) {\n\t\tmcs_get_flowid_stats(mcs, &stats, flow_id, dir);\n\t\tseq_printf(filp, \"Flowid%d: Hit:%lld\\n\", flow_id, stats.tcam_hit_cnt);\n\t}\n\tmutex_unlock(&mcs->stats_lock);\n\treturn 0;\n}\n\nstatic int rvu_dbg_mcs_tx_flowid_stats_display(struct seq_file *filp, void *unused)\n{\n\treturn rvu_dbg_mcs_flowid_stats_display(filp, unused, MCS_TX);\n}\n\nRVU_DEBUG_SEQ_FOPS(mcs_tx_flowid_stats, mcs_tx_flowid_stats_display, NULL);\n\nstatic int rvu_dbg_mcs_rx_flowid_stats_display(struct seq_file *filp, void *unused)\n{\n\treturn rvu_dbg_mcs_flowid_stats_display(filp, unused, MCS_RX);\n}\n\nRVU_DEBUG_SEQ_FOPS(mcs_rx_flowid_stats, mcs_rx_flowid_stats_display, NULL);\n\nstatic int rvu_dbg_mcs_tx_secy_stats_display(struct seq_file *filp, void *unused)\n{\n\tstruct mcs *mcs = filp->private;\n\tstruct mcs_secy_stats stats;\n\tstruct rsrc_bmap *map;\n\tint secy_id;\n\n\tmap = &mcs->tx.secy;\n\tseq_puts(filp, \"\\n MCS TX secy stats\\n\");\n\n\tmutex_lock(&mcs->stats_lock);\n\tfor_each_set_bit(secy_id, map->bmap, mcs->hw->secy_entries) {\n\t\tmcs_get_tx_secy_stats(mcs, &stats, secy_id);\n\t\tseq_printf(filp, \"\\n=======Secy%d======\\n\\n\", secy_id);\n\t\tseq_printf(filp, \"secy%d: Ctrl bcast pkts: %lld\\n\", secy_id,\n\t\t\t   stats.ctl_pkt_bcast_cnt);\n\t\tseq_printf(filp, \"secy%d: Ctrl Mcast pkts: %lld\\n\", secy_id,\n\t\t\t   stats.ctl_pkt_mcast_cnt);\n\t\tseq_printf(filp, \"secy%d: Ctrl ucast pkts: %lld\\n\", secy_id,\n\t\t\t   stats.ctl_pkt_ucast_cnt);\n\t\tseq_printf(filp, \"secy%d: Ctrl octets: %lld\\n\", secy_id, stats.ctl_octet_cnt);\n\t\tseq_printf(filp, \"secy%d: Unctrl bcast cnt: %lld\\n\", secy_id,\n\t\t\t   stats.unctl_pkt_bcast_cnt);\n\t\tseq_printf(filp, \"secy%d: Unctrl mcast pkts: %lld\\n\", secy_id,\n\t\t\t   stats.unctl_pkt_mcast_cnt);\n\t\tseq_printf(filp, \"secy%d: Unctrl ucast pkts: %lld\\n\", secy_id,\n\t\t\t   stats.unctl_pkt_ucast_cnt);\n\t\tseq_printf(filp, \"secy%d: Unctrl octets: %lld\\n\", secy_id, stats.unctl_octet_cnt);\n\t\tseq_printf(filp, \"secy%d: Octet encrypted: %lld\\n\", secy_id,\n\t\t\t   stats.octet_encrypted_cnt);\n\t\tseq_printf(filp, \"secy%d: octet protected: %lld\\n\", secy_id,\n\t\t\t   stats.octet_protected_cnt);\n\t\tseq_printf(filp, \"secy%d: Pkts on active sa: %lld\\n\", secy_id,\n\t\t\t   stats.pkt_noactivesa_cnt);\n\t\tseq_printf(filp, \"secy%d: Pkts too long: %lld\\n\", secy_id, stats.pkt_toolong_cnt);\n\t\tseq_printf(filp, \"secy%d: Pkts untagged: %lld\\n\", secy_id, stats.pkt_untagged_cnt);\n\t}\n\tmutex_unlock(&mcs->stats_lock);\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(mcs_tx_secy_stats, mcs_tx_secy_stats_display, NULL);\n\nstatic int rvu_dbg_mcs_rx_secy_stats_display(struct seq_file *filp, void *unused)\n{\n\tstruct mcs *mcs = filp->private;\n\tstruct mcs_secy_stats stats;\n\tstruct rsrc_bmap *map;\n\tint secy_id;\n\n\tmap = &mcs->rx.secy;\n\tseq_puts(filp, \"\\n MCS secy stats\\n\");\n\n\tmutex_lock(&mcs->stats_lock);\n\tfor_each_set_bit(secy_id, map->bmap, mcs->hw->secy_entries) {\n\t\tmcs_get_rx_secy_stats(mcs, &stats, secy_id);\n\t\tseq_printf(filp, \"\\n=======Secy%d======\\n\\n\", secy_id);\n\t\tseq_printf(filp, \"secy%d: Ctrl bcast pkts: %lld\\n\", secy_id,\n\t\t\t   stats.ctl_pkt_bcast_cnt);\n\t\tseq_printf(filp, \"secy%d: Ctrl Mcast pkts: %lld\\n\", secy_id,\n\t\t\t   stats.ctl_pkt_mcast_cnt);\n\t\tseq_printf(filp, \"secy%d: Ctrl ucast pkts: %lld\\n\", secy_id,\n\t\t\t   stats.ctl_pkt_ucast_cnt);\n\t\tseq_printf(filp, \"secy%d: Ctrl octets: %lld\\n\", secy_id, stats.ctl_octet_cnt);\n\t\tseq_printf(filp, \"secy%d: Unctrl bcast cnt: %lld\\n\", secy_id,\n\t\t\t   stats.unctl_pkt_bcast_cnt);\n\t\tseq_printf(filp, \"secy%d: Unctrl mcast pkts: %lld\\n\", secy_id,\n\t\t\t   stats.unctl_pkt_mcast_cnt);\n\t\tseq_printf(filp, \"secy%d: Unctrl ucast pkts: %lld\\n\", secy_id,\n\t\t\t   stats.unctl_pkt_ucast_cnt);\n\t\tseq_printf(filp, \"secy%d: Unctrl octets: %lld\\n\", secy_id, stats.unctl_octet_cnt);\n\t\tseq_printf(filp, \"secy%d: Octet decrypted: %lld\\n\", secy_id,\n\t\t\t   stats.octet_decrypted_cnt);\n\t\tseq_printf(filp, \"secy%d: octet validated: %lld\\n\", secy_id,\n\t\t\t   stats.octet_validated_cnt);\n\t\tseq_printf(filp, \"secy%d: Pkts on disable port: %lld\\n\", secy_id,\n\t\t\t   stats.pkt_port_disabled_cnt);\n\t\tseq_printf(filp, \"secy%d: Pkts with badtag: %lld\\n\", secy_id, stats.pkt_badtag_cnt);\n\t\tseq_printf(filp, \"secy%d: Pkts with no SA(sectag.tci.c=0): %lld\\n\", secy_id,\n\t\t\t   stats.pkt_nosa_cnt);\n\t\tseq_printf(filp, \"secy%d: Pkts with nosaerror: %lld\\n\", secy_id,\n\t\t\t   stats.pkt_nosaerror_cnt);\n\t\tseq_printf(filp, \"secy%d: Tagged ctrl pkts: %lld\\n\", secy_id,\n\t\t\t   stats.pkt_tagged_ctl_cnt);\n\t\tseq_printf(filp, \"secy%d: Untaged pkts: %lld\\n\", secy_id, stats.pkt_untaged_cnt);\n\t\tseq_printf(filp, \"secy%d: Ctrl pkts: %lld\\n\", secy_id, stats.pkt_ctl_cnt);\n\t\tif (mcs->hw->mcs_blks > 1)\n\t\t\tseq_printf(filp, \"secy%d: pkts notag: %lld\\n\", secy_id,\n\t\t\t\t   stats.pkt_notag_cnt);\n\t}\n\tmutex_unlock(&mcs->stats_lock);\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(mcs_rx_secy_stats, mcs_rx_secy_stats_display, NULL);\n\nstatic void rvu_dbg_mcs_init(struct rvu *rvu)\n{\n\tstruct mcs *mcs;\n\tchar dname[10];\n\tint i;\n\n\tif (!rvu->mcs_blk_cnt)\n\t\treturn;\n\n\trvu->rvu_dbg.mcs_root = debugfs_create_dir(\"mcs\", rvu->rvu_dbg.root);\n\n\tfor (i = 0; i < rvu->mcs_blk_cnt; i++) {\n\t\tmcs = mcs_get_pdata(i);\n\n\t\tsprintf(dname, \"mcs%d\", i);\n\t\trvu->rvu_dbg.mcs = debugfs_create_dir(dname,\n\t\t\t\t\t\t      rvu->rvu_dbg.mcs_root);\n\n\t\trvu->rvu_dbg.mcs_rx = debugfs_create_dir(\"rx_stats\", rvu->rvu_dbg.mcs);\n\n\t\tdebugfs_create_file(\"flowid\", 0600, rvu->rvu_dbg.mcs_rx, mcs,\n\t\t\t\t    &rvu_dbg_mcs_rx_flowid_stats_fops);\n\n\t\tdebugfs_create_file(\"secy\", 0600, rvu->rvu_dbg.mcs_rx, mcs,\n\t\t\t\t    &rvu_dbg_mcs_rx_secy_stats_fops);\n\n\t\tdebugfs_create_file(\"sc\", 0600, rvu->rvu_dbg.mcs_rx, mcs,\n\t\t\t\t    &rvu_dbg_mcs_rx_sc_stats_fops);\n\n\t\tdebugfs_create_file(\"sa\", 0600, rvu->rvu_dbg.mcs_rx, mcs,\n\t\t\t\t    &rvu_dbg_mcs_rx_sa_stats_fops);\n\n\t\tdebugfs_create_file(\"port\", 0600, rvu->rvu_dbg.mcs_rx, mcs,\n\t\t\t\t    &rvu_dbg_mcs_rx_port_stats_fops);\n\n\t\trvu->rvu_dbg.mcs_tx = debugfs_create_dir(\"tx_stats\", rvu->rvu_dbg.mcs);\n\n\t\tdebugfs_create_file(\"flowid\", 0600, rvu->rvu_dbg.mcs_tx, mcs,\n\t\t\t\t    &rvu_dbg_mcs_tx_flowid_stats_fops);\n\n\t\tdebugfs_create_file(\"secy\", 0600, rvu->rvu_dbg.mcs_tx, mcs,\n\t\t\t\t    &rvu_dbg_mcs_tx_secy_stats_fops);\n\n\t\tdebugfs_create_file(\"sc\", 0600, rvu->rvu_dbg.mcs_tx, mcs,\n\t\t\t\t    &rvu_dbg_mcs_tx_sc_stats_fops);\n\n\t\tdebugfs_create_file(\"sa\", 0600, rvu->rvu_dbg.mcs_tx, mcs,\n\t\t\t\t    &rvu_dbg_mcs_tx_sa_stats_fops);\n\n\t\tdebugfs_create_file(\"port\", 0600, rvu->rvu_dbg.mcs_tx, mcs,\n\t\t\t\t    &rvu_dbg_mcs_tx_port_stats_fops);\n\t}\n}\n\n#define LMT_MAPTBL_ENTRY_SIZE 16\n \nstatic ssize_t rvu_dbg_lmtst_map_table_display(struct file *filp,\n\t\t\t\t\t       char __user *buffer,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct rvu *rvu = filp->private_data;\n\tu64 lmt_addr, val, tbl_base;\n\tint pf, vf, num_vfs, hw_vfs;\n\tvoid __iomem *lmt_map_base;\n\tint buf_size = 10240;\n\tsize_t off = 0;\n\tint index = 0;\n\tchar *buf;\n\tint ret;\n\n\t \n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tbuf = kzalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\ttbl_base = rvu_read64(rvu, BLKADDR_APR, APR_AF_LMT_MAP_BASE);\n\n\tlmt_map_base = ioremap_wc(tbl_base, 128 * 1024);\n\tif (!lmt_map_base) {\n\t\tdev_err(rvu->dev, \"Failed to setup lmt map table mapping!!\\n\");\n\t\tkfree(buf);\n\t\treturn false;\n\t}\n\n\toff +=\tscnprintf(&buf[off], buf_size - 1 - off,\n\t\t\t  \"\\n\\t\\t\\t\\t\\tLmtst Map Table Entries\");\n\toff +=\tscnprintf(&buf[off], buf_size - 1 - off,\n\t\t\t  \"\\n\\t\\t\\t\\t\\t=======================\");\n\toff +=\tscnprintf(&buf[off], buf_size - 1 - off, \"\\nPcifunc\\t\\t\\t\");\n\toff +=\tscnprintf(&buf[off], buf_size - 1 - off, \"Table Index\\t\\t\");\n\toff +=\tscnprintf(&buf[off], buf_size - 1 - off,\n\t\t\t  \"Lmtline Base (word 0)\\t\\t\");\n\toff +=\tscnprintf(&buf[off], buf_size - 1 - off,\n\t\t\t  \"Lmt Map Entry (word 1)\");\n\toff += scnprintf(&buf[off], buf_size - 1 - off, \"\\n\");\n\tfor (pf = 0; pf < rvu->hw->total_pfs; pf++) {\n\t\toff += scnprintf(&buf[off], buf_size - 1 - off, \"PF%d  \\t\\t\\t\",\n\t\t\t\t    pf);\n\n\t\tindex = pf * rvu->hw->total_vfs * LMT_MAPTBL_ENTRY_SIZE;\n\t\toff += scnprintf(&buf[off], buf_size - 1 - off, \" 0x%llx\\t\\t\",\n\t\t\t\t (tbl_base + index));\n\t\tlmt_addr = readq(lmt_map_base + index);\n\t\toff += scnprintf(&buf[off], buf_size - 1 - off,\n\t\t\t\t \" 0x%016llx\\t\\t\", lmt_addr);\n\t\tindex += 8;\n\t\tval = readq(lmt_map_base + index);\n\t\toff += scnprintf(&buf[off], buf_size - 1 - off, \" 0x%016llx\\n\",\n\t\t\t\t val);\n\t\t \n\t\trvu_get_pf_numvfs(rvu, pf, &num_vfs, &hw_vfs);\n\t\tfor (vf = 0; vf < num_vfs; vf++) {\n\t\t\tindex = (pf * rvu->hw->total_vfs * 16) +\n\t\t\t\t((vf + 1)  * LMT_MAPTBL_ENTRY_SIZE);\n\t\t\toff += scnprintf(&buf[off], buf_size - 1 - off,\n\t\t\t\t\t    \"PF%d:VF%d  \\t\\t\", pf, vf);\n\t\t\toff += scnprintf(&buf[off], buf_size - 1 - off,\n\t\t\t\t\t \" 0x%llx\\t\\t\", (tbl_base + index));\n\t\t\tlmt_addr = readq(lmt_map_base + index);\n\t\t\toff += scnprintf(&buf[off], buf_size - 1 - off,\n\t\t\t\t\t \" 0x%016llx\\t\\t\", lmt_addr);\n\t\t\tindex += 8;\n\t\t\tval = readq(lmt_map_base + index);\n\t\t\toff += scnprintf(&buf[off], buf_size - 1 - off,\n\t\t\t\t\t \" 0x%016llx\\n\", val);\n\t\t}\n\t}\n\toff +=\tscnprintf(&buf[off], buf_size - 1 - off, \"\\n\");\n\n\tret = min(off, count);\n\tif (copy_to_user(buffer, buf, ret))\n\t\tret = -EFAULT;\n\tkfree(buf);\n\n\tiounmap(lmt_map_base);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos = ret;\n\treturn ret;\n}\n\nRVU_DEBUG_FOPS(lmtst_map_table, lmtst_map_table_display, NULL);\n\nstatic void get_lf_str_list(struct rvu_block block, int pcifunc,\n\t\t\t    char *lfs)\n{\n\tint lf = 0, seq = 0, len = 0, prev_lf = block.lf.max;\n\n\tfor_each_set_bit(lf, block.lf.bmap, block.lf.max) {\n\t\tif (lf >= block.lf.max)\n\t\t\tbreak;\n\n\t\tif (block.fn_map[lf] != pcifunc)\n\t\t\tcontinue;\n\n\t\tif (lf == prev_lf + 1) {\n\t\t\tprev_lf = lf;\n\t\t\tseq = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (seq)\n\t\t\tlen += sprintf(lfs + len, \"-%d,%d\", prev_lf, lf);\n\t\telse\n\t\t\tlen += (len ? sprintf(lfs + len, \",%d\", lf) :\n\t\t\t\t      sprintf(lfs + len, \"%d\", lf));\n\n\t\tprev_lf = lf;\n\t\tseq = 0;\n\t}\n\n\tif (seq)\n\t\tlen += sprintf(lfs + len, \"-%d\", prev_lf);\n\n\tlfs[len] = '\\0';\n}\n\nstatic int get_max_column_width(struct rvu *rvu)\n{\n\tint index, pf, vf, lf_str_size = 12, buf_size = 256;\n\tstruct rvu_block block;\n\tu16 pcifunc;\n\tchar *buf;\n\n\tbuf = kzalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor (pf = 0; pf < rvu->hw->total_pfs; pf++) {\n\t\tfor (vf = 0; vf <= rvu->hw->total_vfs; vf++) {\n\t\t\tpcifunc = pf << 10 | vf;\n\t\t\tif (!pcifunc)\n\t\t\t\tcontinue;\n\n\t\t\tfor (index = 0; index < BLK_COUNT; index++) {\n\t\t\t\tblock = rvu->hw->block[index];\n\t\t\t\tif (!strlen(block.name))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tget_lf_str_list(block, pcifunc, buf);\n\t\t\t\tif (lf_str_size <= strlen(buf))\n\t\t\t\t\tlf_str_size = strlen(buf) + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tkfree(buf);\n\treturn lf_str_size;\n}\n\n \nstatic ssize_t rvu_dbg_rsrc_attach_status(struct file *filp,\n\t\t\t\t\t  char __user *buffer,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tint index, off = 0, flag = 0, len = 0, i = 0;\n\tstruct rvu *rvu = filp->private_data;\n\tint bytes_not_copied = 0;\n\tstruct rvu_block block;\n\tint pf, vf, pcifunc;\n\tint buf_size = 2048;\n\tint lf_str_size;\n\tchar *lfs;\n\tchar *buf;\n\n\t \n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tbuf = kzalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tlf_str_size = get_max_column_width(rvu);\n\n\tlfs = kzalloc(lf_str_size, GFP_KERNEL);\n\tif (!lfs) {\n\t\tkfree(buf);\n\t\treturn -ENOMEM;\n\t}\n\toff +=\tscnprintf(&buf[off], buf_size - 1 - off, \"%-*s\", lf_str_size,\n\t\t\t  \"pcifunc\");\n\tfor (index = 0; index < BLK_COUNT; index++)\n\t\tif (strlen(rvu->hw->block[index].name)) {\n\t\t\toff += scnprintf(&buf[off], buf_size - 1 - off,\n\t\t\t\t\t \"%-*s\", lf_str_size,\n\t\t\t\t\t rvu->hw->block[index].name);\n\t\t}\n\n\toff += scnprintf(&buf[off], buf_size - 1 - off, \"\\n\");\n\tbytes_not_copied = copy_to_user(buffer + (i * off), buf, off);\n\tif (bytes_not_copied)\n\t\tgoto out;\n\n\ti++;\n\t*ppos += off;\n\tfor (pf = 0; pf < rvu->hw->total_pfs; pf++) {\n\t\tfor (vf = 0; vf <= rvu->hw->total_vfs; vf++) {\n\t\t\toff = 0;\n\t\t\tflag = 0;\n\t\t\tpcifunc = pf << 10 | vf;\n\t\t\tif (!pcifunc)\n\t\t\t\tcontinue;\n\n\t\t\tif (vf) {\n\t\t\t\tsprintf(lfs, \"PF%d:VF%d\", pf, vf - 1);\n\t\t\t\toff = scnprintf(&buf[off],\n\t\t\t\t\t\tbuf_size - 1 - off,\n\t\t\t\t\t\t\"%-*s\", lf_str_size, lfs);\n\t\t\t} else {\n\t\t\t\tsprintf(lfs, \"PF%d\", pf);\n\t\t\t\toff = scnprintf(&buf[off],\n\t\t\t\t\t\tbuf_size - 1 - off,\n\t\t\t\t\t\t\"%-*s\", lf_str_size, lfs);\n\t\t\t}\n\n\t\t\tfor (index = 0; index < BLK_COUNT; index++) {\n\t\t\t\tblock = rvu->hw->block[index];\n\t\t\t\tif (!strlen(block.name))\n\t\t\t\t\tcontinue;\n\t\t\t\tlen = 0;\n\t\t\t\tlfs[len] = '\\0';\n\t\t\t\tget_lf_str_list(block, pcifunc, lfs);\n\t\t\t\tif (strlen(lfs))\n\t\t\t\t\tflag = 1;\n\n\t\t\t\toff += scnprintf(&buf[off], buf_size - 1 - off,\n\t\t\t\t\t\t \"%-*s\", lf_str_size, lfs);\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\toff +=\tscnprintf(&buf[off],\n\t\t\t\t\t\t  buf_size - 1 - off, \"\\n\");\n\t\t\t\tbytes_not_copied = copy_to_user(buffer +\n\t\t\t\t\t\t\t\t(i * off),\n\t\t\t\t\t\t\t\tbuf, off);\n\t\t\t\tif (bytes_not_copied)\n\t\t\t\t\tgoto out;\n\n\t\t\t\ti++;\n\t\t\t\t*ppos += off;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tkfree(lfs);\n\tkfree(buf);\n\tif (bytes_not_copied)\n\t\treturn -EFAULT;\n\n\treturn *ppos;\n}\n\nRVU_DEBUG_FOPS(rsrc_status, rsrc_attach_status, NULL);\n\nstatic int rvu_dbg_rvu_pf_cgx_map_display(struct seq_file *filp, void *unused)\n{\n\tstruct rvu *rvu = filp->private;\n\tstruct pci_dev *pdev = NULL;\n\tstruct mac_ops *mac_ops;\n\tchar cgx[10], lmac[10];\n\tstruct rvu_pfvf *pfvf;\n\tint pf, domain, blkid;\n\tu8 cgx_id, lmac_id;\n\tu16 pcifunc;\n\n\tdomain = 2;\n\tmac_ops = get_mac_ops(rvu_first_cgx_pdata(rvu));\n\t \n\tif (!mac_ops)\n\t\treturn 0;\n\tseq_printf(filp, \"PCI dev\\t\\tRVU PF Func\\tNIX block\\t%s\\tLMAC\\n\",\n\t\t   mac_ops->name);\n\tfor (pf = 0; pf < rvu->hw->total_pfs; pf++) {\n\t\tif (!is_pf_cgxmapped(rvu, pf))\n\t\t\tcontinue;\n\n\t\tpdev =  pci_get_domain_bus_and_slot(domain, pf + 1, 0);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tcgx[0] = 0;\n\t\tlmac[0] = 0;\n\t\tpcifunc = pf << 10;\n\t\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\n\t\tif (pfvf->nix_blkaddr == BLKADDR_NIX0)\n\t\t\tblkid = 0;\n\t\telse\n\t\t\tblkid = 1;\n\n\t\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id,\n\t\t\t\t    &lmac_id);\n\t\tsprintf(cgx, \"%s%d\", mac_ops->name, cgx_id);\n\t\tsprintf(lmac, \"LMAC%d\", lmac_id);\n\t\tseq_printf(filp, \"%s\\t0x%x\\t\\tNIX%d\\t\\t%s\\t%s\\n\",\n\t\t\t   dev_name(&pdev->dev), pcifunc, blkid, cgx, lmac);\n\n\t\tpci_dev_put(pdev);\n\t}\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(rvu_pf_cgx_map, rvu_pf_cgx_map_display, NULL);\n\nstatic bool rvu_dbg_is_valid_lf(struct rvu *rvu, int blkaddr, int lf,\n\t\t\t\tu16 *pcifunc)\n{\n\tstruct rvu_block *block;\n\tstruct rvu_hwinfo *hw;\n\n\thw = rvu->hw;\n\tblock = &hw->block[blkaddr];\n\n\tif (lf < 0 || lf >= block->lf.max) {\n\t\tdev_warn(rvu->dev, \"Invalid LF: valid range: 0-%d\\n\",\n\t\t\t block->lf.max - 1);\n\t\treturn false;\n\t}\n\n\t*pcifunc = block->fn_map[lf];\n\tif (!*pcifunc) {\n\t\tdev_warn(rvu->dev,\n\t\t\t \"This LF is not attached to any RVU PFFUNC\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void print_npa_qsize(struct seq_file *m, struct rvu_pfvf *pfvf)\n{\n\tchar *buf;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tif (!pfvf->aura_ctx) {\n\t\tseq_puts(m, \"Aura context is not initialized\\n\");\n\t} else {\n\t\tbitmap_print_to_pagebuf(false, buf, pfvf->aura_bmap,\n\t\t\t\t\tpfvf->aura_ctx->qsize);\n\t\tseq_printf(m, \"Aura count : %d\\n\", pfvf->aura_ctx->qsize);\n\t\tseq_printf(m, \"Aura context ena/dis bitmap : %s\\n\", buf);\n\t}\n\n\tif (!pfvf->pool_ctx) {\n\t\tseq_puts(m, \"Pool context is not initialized\\n\");\n\t} else {\n\t\tbitmap_print_to_pagebuf(false, buf, pfvf->pool_bmap,\n\t\t\t\t\tpfvf->pool_ctx->qsize);\n\t\tseq_printf(m, \"Pool count : %d\\n\", pfvf->pool_ctx->qsize);\n\t\tseq_printf(m, \"Pool context ena/dis bitmap : %s\\n\", buf);\n\t}\n\tkfree(buf);\n}\n\n \nstatic int rvu_dbg_qsize_display(struct seq_file *filp, void *unsused,\n\t\t\t\t int blktype)\n{\n\tvoid (*print_qsize)(struct seq_file *filp,\n\t\t\t    struct rvu_pfvf *pfvf) = NULL;\n\tstruct dentry *current_dir;\n\tstruct rvu_pfvf *pfvf;\n\tstruct rvu *rvu;\n\tint qsize_id;\n\tu16 pcifunc;\n\tint blkaddr;\n\n\trvu = filp->private;\n\tswitch (blktype) {\n\tcase BLKTYPE_NPA:\n\t\tqsize_id = rvu->rvu_dbg.npa_qsize_id;\n\t\tprint_qsize = print_npa_qsize;\n\t\tbreak;\n\n\tcase BLKTYPE_NIX:\n\t\tqsize_id = rvu->rvu_dbg.nix_qsize_id;\n\t\tprint_qsize = print_nix_qsize;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (blktype == BLKTYPE_NPA) {\n\t\tblkaddr = BLKADDR_NPA;\n\t} else {\n\t\tcurrent_dir = filp->file->f_path.dentry->d_parent;\n\t\tblkaddr = (!strcmp(current_dir->d_name.name, \"nix1\") ?\n\t\t\t\t   BLKADDR_NIX1 : BLKADDR_NIX0);\n\t}\n\n\tif (!rvu_dbg_is_valid_lf(rvu, blkaddr, qsize_id, &pcifunc))\n\t\treturn -EINVAL;\n\n\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\tprint_qsize(filp, pfvf);\n\n\treturn 0;\n}\n\nstatic ssize_t rvu_dbg_qsize_write(struct file *filp,\n\t\t\t\t   const char __user *buffer, size_t count,\n\t\t\t\t   loff_t *ppos, int blktype)\n{\n\tchar *blk_string = (blktype == BLKTYPE_NPA) ? \"npa\" : \"nix\";\n\tstruct seq_file *seqfile = filp->private_data;\n\tchar *cmd_buf, *cmd_buf_tmp, *subtoken;\n\tstruct rvu *rvu = seqfile->private;\n\tstruct dentry *current_dir;\n\tint blkaddr;\n\tu16 pcifunc;\n\tint ret, lf;\n\n\tcmd_buf = memdup_user(buffer, count + 1);\n\tif (IS_ERR(cmd_buf))\n\t\treturn -ENOMEM;\n\n\tcmd_buf[count] = '\\0';\n\n\tcmd_buf_tmp = strchr(cmd_buf, '\\n');\n\tif (cmd_buf_tmp) {\n\t\t*cmd_buf_tmp = '\\0';\n\t\tcount = cmd_buf_tmp - cmd_buf + 1;\n\t}\n\n\tcmd_buf_tmp = cmd_buf;\n\tsubtoken = strsep(&cmd_buf, \" \");\n\tret = subtoken ? kstrtoint(subtoken, 10, &lf) : -EINVAL;\n\tif (cmd_buf)\n\t\tret = -EINVAL;\n\n\tif (ret < 0 || !strncmp(subtoken, \"help\", 4)) {\n\t\tdev_info(rvu->dev, \"Use echo <%s-lf > qsize\\n\", blk_string);\n\t\tgoto qsize_write_done;\n\t}\n\n\tif (blktype == BLKTYPE_NPA) {\n\t\tblkaddr = BLKADDR_NPA;\n\t} else {\n\t\tcurrent_dir = filp->f_path.dentry->d_parent;\n\t\tblkaddr = (!strcmp(current_dir->d_name.name, \"nix1\") ?\n\t\t\t\t   BLKADDR_NIX1 : BLKADDR_NIX0);\n\t}\n\n\tif (!rvu_dbg_is_valid_lf(rvu, blkaddr, lf, &pcifunc)) {\n\t\tret = -EINVAL;\n\t\tgoto qsize_write_done;\n\t}\n\tif (blktype  == BLKTYPE_NPA)\n\t\trvu->rvu_dbg.npa_qsize_id = lf;\n\telse\n\t\trvu->rvu_dbg.nix_qsize_id = lf;\n\nqsize_write_done:\n\tkfree(cmd_buf_tmp);\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t rvu_dbg_npa_qsize_write(struct file *filp,\n\t\t\t\t       const char __user *buffer,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\treturn rvu_dbg_qsize_write(filp, buffer, count, ppos,\n\t\t\t\t\t    BLKTYPE_NPA);\n}\n\nstatic int rvu_dbg_npa_qsize_display(struct seq_file *filp, void *unused)\n{\n\treturn rvu_dbg_qsize_display(filp, unused, BLKTYPE_NPA);\n}\n\nRVU_DEBUG_SEQ_FOPS(npa_qsize, npa_qsize_display, npa_qsize_write);\n\n \nstatic void print_npa_aura_ctx(struct seq_file *m, struct npa_aq_enq_rsp *rsp)\n{\n\tstruct npa_aura_s *aura = &rsp->aura;\n\tstruct rvu *rvu = m->private;\n\n\tseq_printf(m, \"W0: Pool addr\\t\\t%llx\\n\", aura->pool_addr);\n\n\tseq_printf(m, \"W1: ena\\t\\t\\t%d\\nW1: pool caching\\t%d\\n\",\n\t\t   aura->ena, aura->pool_caching);\n\tseq_printf(m, \"W1: pool way mask\\t%d\\nW1: avg con\\t\\t%d\\n\",\n\t\t   aura->pool_way_mask, aura->avg_con);\n\tseq_printf(m, \"W1: pool drop ena\\t%d\\nW1: aura drop ena\\t%d\\n\",\n\t\t   aura->pool_drop_ena, aura->aura_drop_ena);\n\tseq_printf(m, \"W1: bp_ena\\t\\t%d\\nW1: aura drop\\t\\t%d\\n\",\n\t\t   aura->bp_ena, aura->aura_drop);\n\tseq_printf(m, \"W1: aura shift\\t\\t%d\\nW1: avg_level\\t\\t%d\\n\",\n\t\t   aura->shift, aura->avg_level);\n\n\tseq_printf(m, \"W2: count\\t\\t%llu\\nW2: nix0_bpid\\t\\t%d\\nW2: nix1_bpid\\t\\t%d\\n\",\n\t\t   (u64)aura->count, aura->nix0_bpid, aura->nix1_bpid);\n\n\tseq_printf(m, \"W3: limit\\t\\t%llu\\nW3: bp\\t\\t\\t%d\\nW3: fc_ena\\t\\t%d\\n\",\n\t\t   (u64)aura->limit, aura->bp, aura->fc_ena);\n\n\tif (!is_rvu_otx2(rvu))\n\t\tseq_printf(m, \"W3: fc_be\\t\\t%d\\n\", aura->fc_be);\n\tseq_printf(m, \"W3: fc_up_crossing\\t%d\\nW3: fc_stype\\t\\t%d\\n\",\n\t\t   aura->fc_up_crossing, aura->fc_stype);\n\tseq_printf(m, \"W3: fc_hyst_bits\\t%d\\n\", aura->fc_hyst_bits);\n\n\tseq_printf(m, \"W4: fc_addr\\t\\t%llx\\n\", aura->fc_addr);\n\n\tseq_printf(m, \"W5: pool_drop\\t\\t%d\\nW5: update_time\\t\\t%d\\n\",\n\t\t   aura->pool_drop, aura->update_time);\n\tseq_printf(m, \"W5: err_int \\t\\t%d\\nW5: err_int_ena\\t\\t%d\\n\",\n\t\t   aura->err_int, aura->err_int_ena);\n\tseq_printf(m, \"W5: thresh_int\\t\\t%d\\nW5: thresh_int_ena \\t%d\\n\",\n\t\t   aura->thresh_int, aura->thresh_int_ena);\n\tseq_printf(m, \"W5: thresh_up\\t\\t%d\\nW5: thresh_qint_idx\\t%d\\n\",\n\t\t   aura->thresh_up, aura->thresh_qint_idx);\n\tseq_printf(m, \"W5: err_qint_idx \\t%d\\n\", aura->err_qint_idx);\n\n\tseq_printf(m, \"W6: thresh\\t\\t%llu\\n\", (u64)aura->thresh);\n\tif (!is_rvu_otx2(rvu))\n\t\tseq_printf(m, \"W6: fc_msh_dst\\t\\t%d\\n\", aura->fc_msh_dst);\n}\n\n \nstatic void print_npa_pool_ctx(struct seq_file *m, struct npa_aq_enq_rsp *rsp)\n{\n\tstruct npa_pool_s *pool = &rsp->pool;\n\tstruct rvu *rvu = m->private;\n\n\tseq_printf(m, \"W0: Stack base\\t\\t%llx\\n\", pool->stack_base);\n\n\tseq_printf(m, \"W1: ena \\t\\t%d\\nW1: nat_align \\t\\t%d\\n\",\n\t\t   pool->ena, pool->nat_align);\n\tseq_printf(m, \"W1: stack_caching\\t%d\\nW1: stack_way_mask\\t%d\\n\",\n\t\t   pool->stack_caching, pool->stack_way_mask);\n\tseq_printf(m, \"W1: buf_offset\\t\\t%d\\nW1: buf_size\\t\\t%d\\n\",\n\t\t   pool->buf_offset, pool->buf_size);\n\n\tseq_printf(m, \"W2: stack_max_pages \\t%d\\nW2: stack_pages\\t\\t%d\\n\",\n\t\t   pool->stack_max_pages, pool->stack_pages);\n\n\tseq_printf(m, \"W3: op_pc \\t\\t%llu\\n\", (u64)pool->op_pc);\n\n\tseq_printf(m, \"W4: stack_offset\\t%d\\nW4: shift\\t\\t%d\\nW4: avg_level\\t\\t%d\\n\",\n\t\t   pool->stack_offset, pool->shift, pool->avg_level);\n\tseq_printf(m, \"W4: avg_con \\t\\t%d\\nW4: fc_ena\\t\\t%d\\nW4: fc_stype\\t\\t%d\\n\",\n\t\t   pool->avg_con, pool->fc_ena, pool->fc_stype);\n\tseq_printf(m, \"W4: fc_hyst_bits\\t%d\\nW4: fc_up_crossing\\t%d\\n\",\n\t\t   pool->fc_hyst_bits, pool->fc_up_crossing);\n\tif (!is_rvu_otx2(rvu))\n\t\tseq_printf(m, \"W4: fc_be\\t\\t%d\\n\", pool->fc_be);\n\tseq_printf(m, \"W4: update_time\\t\\t%d\\n\", pool->update_time);\n\n\tseq_printf(m, \"W5: fc_addr\\t\\t%llx\\n\", pool->fc_addr);\n\n\tseq_printf(m, \"W6: ptr_start\\t\\t%llx\\n\", pool->ptr_start);\n\n\tseq_printf(m, \"W7: ptr_end\\t\\t%llx\\n\", pool->ptr_end);\n\n\tseq_printf(m, \"W8: err_int\\t\\t%d\\nW8: err_int_ena\\t\\t%d\\n\",\n\t\t   pool->err_int, pool->err_int_ena);\n\tseq_printf(m, \"W8: thresh_int\\t\\t%d\\n\", pool->thresh_int);\n\tseq_printf(m, \"W8: thresh_int_ena\\t%d\\nW8: thresh_up\\t\\t%d\\n\",\n\t\t   pool->thresh_int_ena, pool->thresh_up);\n\tseq_printf(m, \"W8: thresh_qint_idx\\t%d\\nW8: err_qint_idx\\t%d\\n\",\n\t\t   pool->thresh_qint_idx, pool->err_qint_idx);\n\tif (!is_rvu_otx2(rvu))\n\t\tseq_printf(m, \"W8: fc_msh_dst\\t\\t%d\\n\", pool->fc_msh_dst);\n}\n\n \nstatic int rvu_dbg_npa_ctx_display(struct seq_file *m, void *unused, int ctype)\n{\n\tvoid (*print_npa_ctx)(struct seq_file *m, struct npa_aq_enq_rsp *rsp);\n\tstruct npa_aq_enq_req aq_req;\n\tstruct npa_aq_enq_rsp rsp;\n\tstruct rvu_pfvf *pfvf;\n\tint aura, rc, max_id;\n\tint npalf, id, all;\n\tstruct rvu *rvu;\n\tu16 pcifunc;\n\n\trvu = m->private;\n\n\tswitch (ctype) {\n\tcase NPA_AQ_CTYPE_AURA:\n\t\tnpalf = rvu->rvu_dbg.npa_aura_ctx.lf;\n\t\tid = rvu->rvu_dbg.npa_aura_ctx.id;\n\t\tall = rvu->rvu_dbg.npa_aura_ctx.all;\n\t\tbreak;\n\n\tcase NPA_AQ_CTYPE_POOL:\n\t\tnpalf = rvu->rvu_dbg.npa_pool_ctx.lf;\n\t\tid = rvu->rvu_dbg.npa_pool_ctx.id;\n\t\tall = rvu->rvu_dbg.npa_pool_ctx.all;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rvu_dbg_is_valid_lf(rvu, BLKADDR_NPA, npalf, &pcifunc))\n\t\treturn -EINVAL;\n\n\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\tif (ctype == NPA_AQ_CTYPE_AURA && !pfvf->aura_ctx) {\n\t\tseq_puts(m, \"Aura context is not initialized\\n\");\n\t\treturn -EINVAL;\n\t} else if (ctype == NPA_AQ_CTYPE_POOL && !pfvf->pool_ctx) {\n\t\tseq_puts(m, \"Pool context is not initialized\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&aq_req, 0, sizeof(struct npa_aq_enq_req));\n\taq_req.hdr.pcifunc = pcifunc;\n\taq_req.ctype = ctype;\n\taq_req.op = NPA_AQ_INSTOP_READ;\n\tif (ctype == NPA_AQ_CTYPE_AURA) {\n\t\tmax_id = pfvf->aura_ctx->qsize;\n\t\tprint_npa_ctx = print_npa_aura_ctx;\n\t} else {\n\t\tmax_id = pfvf->pool_ctx->qsize;\n\t\tprint_npa_ctx = print_npa_pool_ctx;\n\t}\n\n\tif (id < 0 || id >= max_id) {\n\t\tseq_printf(m, \"Invalid %s, valid range is 0-%d\\n\",\n\t\t\t   (ctype == NPA_AQ_CTYPE_AURA) ? \"aura\" : \"pool\",\n\t\t\tmax_id - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (all)\n\t\tid = 0;\n\telse\n\t\tmax_id = id + 1;\n\n\tfor (aura = id; aura < max_id; aura++) {\n\t\taq_req.aura_id = aura;\n\n\t\t \n\t\tif (ctype == NPA_AQ_CTYPE_POOL && !test_bit(aura, pfvf->pool_bmap))\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"======%s : %d=======\\n\",\n\t\t\t   (ctype == NPA_AQ_CTYPE_AURA) ? \"AURA\" : \"POOL\",\n\t\t\taq_req.aura_id);\n\t\trc = rvu_npa_aq_enq_inst(rvu, &aq_req, &rsp);\n\t\tif (rc) {\n\t\t\tseq_puts(m, \"Failed to read context\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tprint_npa_ctx(m, &rsp);\n\t}\n\treturn 0;\n}\n\nstatic int write_npa_ctx(struct rvu *rvu, bool all,\n\t\t\t int npalf, int id, int ctype)\n{\n\tstruct rvu_pfvf *pfvf;\n\tint max_id = 0;\n\tu16 pcifunc;\n\n\tif (!rvu_dbg_is_valid_lf(rvu, BLKADDR_NPA, npalf, &pcifunc))\n\t\treturn -EINVAL;\n\n\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\n\tif (ctype == NPA_AQ_CTYPE_AURA) {\n\t\tif (!pfvf->aura_ctx) {\n\t\t\tdev_warn(rvu->dev, \"Aura context is not initialized\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmax_id = pfvf->aura_ctx->qsize;\n\t} else if (ctype == NPA_AQ_CTYPE_POOL) {\n\t\tif (!pfvf->pool_ctx) {\n\t\t\tdev_warn(rvu->dev, \"Pool context is not initialized\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmax_id = pfvf->pool_ctx->qsize;\n\t}\n\n\tif (id < 0 || id >= max_id) {\n\t\tdev_warn(rvu->dev, \"Invalid %s, valid range is 0-%d\\n\",\n\t\t\t (ctype == NPA_AQ_CTYPE_AURA) ? \"aura\" : \"pool\",\n\t\t\tmax_id - 1);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (ctype) {\n\tcase NPA_AQ_CTYPE_AURA:\n\t\trvu->rvu_dbg.npa_aura_ctx.lf = npalf;\n\t\trvu->rvu_dbg.npa_aura_ctx.id = id;\n\t\trvu->rvu_dbg.npa_aura_ctx.all = all;\n\t\tbreak;\n\n\tcase NPA_AQ_CTYPE_POOL:\n\t\trvu->rvu_dbg.npa_pool_ctx.lf = npalf;\n\t\trvu->rvu_dbg.npa_pool_ctx.id = id;\n\t\trvu->rvu_dbg.npa_pool_ctx.all = all;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int parse_cmd_buffer_ctx(char *cmd_buf, size_t *count,\n\t\t\t\tconst char __user *buffer, int *npalf,\n\t\t\t\tint *id, bool *all)\n{\n\tint bytes_not_copied;\n\tchar *cmd_buf_tmp;\n\tchar *subtoken;\n\tint ret;\n\n\tbytes_not_copied = copy_from_user(cmd_buf, buffer, *count);\n\tif (bytes_not_copied)\n\t\treturn -EFAULT;\n\n\tcmd_buf[*count] = '\\0';\n\tcmd_buf_tmp = strchr(cmd_buf, '\\n');\n\n\tif (cmd_buf_tmp) {\n\t\t*cmd_buf_tmp = '\\0';\n\t\t*count = cmd_buf_tmp - cmd_buf + 1;\n\t}\n\n\tsubtoken = strsep(&cmd_buf, \" \");\n\tret = subtoken ? kstrtoint(subtoken, 10, npalf) : -EINVAL;\n\tif (ret < 0)\n\t\treturn ret;\n\tsubtoken = strsep(&cmd_buf, \" \");\n\tif (subtoken && strcmp(subtoken, \"all\") == 0) {\n\t\t*all = true;\n\t} else {\n\t\tret = subtoken ? kstrtoint(subtoken, 10, id) : -EINVAL;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tif (cmd_buf)\n\t\treturn -EINVAL;\n\treturn ret;\n}\n\nstatic ssize_t rvu_dbg_npa_ctx_write(struct file *filp,\n\t\t\t\t     const char __user *buffer,\n\t\t\t\t     size_t count, loff_t *ppos, int ctype)\n{\n\tchar *cmd_buf, *ctype_string = (ctype == NPA_AQ_CTYPE_AURA) ?\n\t\t\t\t\t\"aura\" : \"pool\";\n\tstruct seq_file *seqfp = filp->private_data;\n\tstruct rvu *rvu = seqfp->private;\n\tint npalf, id = 0, ret;\n\tbool all = false;\n\n\tif ((*ppos != 0) || !count)\n\t\treturn -EINVAL;\n\n\tcmd_buf = kzalloc(count + 1, GFP_KERNEL);\n\tif (!cmd_buf)\n\t\treturn count;\n\tret = parse_cmd_buffer_ctx(cmd_buf, &count, buffer,\n\t\t\t\t   &npalf, &id, &all);\n\tif (ret < 0) {\n\t\tdev_info(rvu->dev,\n\t\t\t \"Usage: echo <npalf> [%s number/all] > %s_ctx\\n\",\n\t\t\t ctype_string, ctype_string);\n\t\tgoto done;\n\t} else {\n\t\tret = write_npa_ctx(rvu, all, npalf, id, ctype);\n\t}\ndone:\n\tkfree(cmd_buf);\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t rvu_dbg_npa_aura_ctx_write(struct file *filp,\n\t\t\t\t\t  const char __user *buffer,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn rvu_dbg_npa_ctx_write(filp, buffer, count, ppos,\n\t\t\t\t     NPA_AQ_CTYPE_AURA);\n}\n\nstatic int rvu_dbg_npa_aura_ctx_display(struct seq_file *filp, void *unused)\n{\n\treturn rvu_dbg_npa_ctx_display(filp, unused, NPA_AQ_CTYPE_AURA);\n}\n\nRVU_DEBUG_SEQ_FOPS(npa_aura_ctx, npa_aura_ctx_display, npa_aura_ctx_write);\n\nstatic ssize_t rvu_dbg_npa_pool_ctx_write(struct file *filp,\n\t\t\t\t\t  const char __user *buffer,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn rvu_dbg_npa_ctx_write(filp, buffer, count, ppos,\n\t\t\t\t     NPA_AQ_CTYPE_POOL);\n}\n\nstatic int rvu_dbg_npa_pool_ctx_display(struct seq_file *filp, void *unused)\n{\n\treturn rvu_dbg_npa_ctx_display(filp, unused, NPA_AQ_CTYPE_POOL);\n}\n\nRVU_DEBUG_SEQ_FOPS(npa_pool_ctx, npa_pool_ctx_display, npa_pool_ctx_write);\n\nstatic void ndc_cache_stats(struct seq_file *s, int blk_addr,\n\t\t\t    int ctype, int transaction)\n{\n\tu64 req, out_req, lat, cant_alloc;\n\tstruct nix_hw *nix_hw;\n\tstruct rvu *rvu;\n\tint port;\n\n\tif (blk_addr == BLKADDR_NDC_NPA0) {\n\t\trvu = s->private;\n\t} else {\n\t\tnix_hw = s->private;\n\t\trvu = nix_hw->rvu;\n\t}\n\n\tfor (port = 0; port < NDC_MAX_PORT; port++) {\n\t\treq = rvu_read64(rvu, blk_addr, NDC_AF_PORTX_RTX_RWX_REQ_PC\n\t\t\t\t\t\t(port, ctype, transaction));\n\t\tlat = rvu_read64(rvu, blk_addr, NDC_AF_PORTX_RTX_RWX_LAT_PC\n\t\t\t\t\t\t(port, ctype, transaction));\n\t\tout_req = rvu_read64(rvu, blk_addr,\n\t\t\t\t     NDC_AF_PORTX_RTX_RWX_OSTDN_PC\n\t\t\t\t     (port, ctype, transaction));\n\t\tcant_alloc = rvu_read64(rvu, blk_addr,\n\t\t\t\t\tNDC_AF_PORTX_RTX_CANT_ALLOC_PC\n\t\t\t\t\t(port, transaction));\n\t\tseq_printf(s, \"\\nPort:%d\\n\", port);\n\t\tseq_printf(s, \"\\tTotal Requests:\\t\\t%lld\\n\", req);\n\t\tseq_printf(s, \"\\tTotal Time Taken:\\t%lld cycles\\n\", lat);\n\t\tseq_printf(s, \"\\tAvg Latency:\\t\\t%lld cycles\\n\", lat / req);\n\t\tseq_printf(s, \"\\tOutstanding Requests:\\t%lld\\n\", out_req);\n\t\tseq_printf(s, \"\\tCant Alloc Requests:\\t%lld\\n\", cant_alloc);\n\t}\n}\n\nstatic int ndc_blk_cache_stats(struct seq_file *s, int idx, int blk_addr)\n{\n\tseq_puts(s, \"\\n***** CACHE mode read stats *****\\n\");\n\tndc_cache_stats(s, blk_addr, CACHING, NDC_READ_TRANS);\n\tseq_puts(s, \"\\n***** CACHE mode write stats *****\\n\");\n\tndc_cache_stats(s, blk_addr, CACHING, NDC_WRITE_TRANS);\n\tseq_puts(s, \"\\n***** BY-PASS mode read stats *****\\n\");\n\tndc_cache_stats(s, blk_addr, BYPASS, NDC_READ_TRANS);\n\tseq_puts(s, \"\\n***** BY-PASS mode write stats *****\\n\");\n\tndc_cache_stats(s, blk_addr, BYPASS, NDC_WRITE_TRANS);\n\treturn 0;\n}\n\nstatic int rvu_dbg_npa_ndc_cache_display(struct seq_file *filp, void *unused)\n{\n\treturn ndc_blk_cache_stats(filp, NPA0_U, BLKADDR_NDC_NPA0);\n}\n\nRVU_DEBUG_SEQ_FOPS(npa_ndc_cache, npa_ndc_cache_display, NULL);\n\nstatic int ndc_blk_hits_miss_stats(struct seq_file *s, int idx, int blk_addr)\n{\n\tstruct nix_hw *nix_hw;\n\tstruct rvu *rvu;\n\tint bank, max_bank;\n\tu64 ndc_af_const;\n\n\tif (blk_addr == BLKADDR_NDC_NPA0) {\n\t\trvu = s->private;\n\t} else {\n\t\tnix_hw = s->private;\n\t\trvu = nix_hw->rvu;\n\t}\n\n\tndc_af_const = rvu_read64(rvu, blk_addr, NDC_AF_CONST);\n\tmax_bank = FIELD_GET(NDC_AF_BANK_MASK, ndc_af_const);\n\tfor (bank = 0; bank < max_bank; bank++) {\n\t\tseq_printf(s, \"BANK:%d\\n\", bank);\n\t\tseq_printf(s, \"\\tHits:\\t%lld\\n\",\n\t\t\t   (u64)rvu_read64(rvu, blk_addr,\n\t\t\t   NDC_AF_BANKX_HIT_PC(bank)));\n\t\tseq_printf(s, \"\\tMiss:\\t%lld\\n\",\n\t\t\t   (u64)rvu_read64(rvu, blk_addr,\n\t\t\t    NDC_AF_BANKX_MISS_PC(bank)));\n\t}\n\treturn 0;\n}\n\nstatic int rvu_dbg_nix_ndc_rx_cache_display(struct seq_file *filp, void *unused)\n{\n\tstruct nix_hw *nix_hw = filp->private;\n\tint blkaddr = 0;\n\tint ndc_idx = 0;\n\n\tblkaddr = (nix_hw->blkaddr == BLKADDR_NIX1 ?\n\t\t   BLKADDR_NDC_NIX1_RX : BLKADDR_NDC_NIX0_RX);\n\tndc_idx = (nix_hw->blkaddr == BLKADDR_NIX1 ? NIX1_RX : NIX0_RX);\n\n\treturn ndc_blk_cache_stats(filp, ndc_idx, blkaddr);\n}\n\nRVU_DEBUG_SEQ_FOPS(nix_ndc_rx_cache, nix_ndc_rx_cache_display, NULL);\n\nstatic int rvu_dbg_nix_ndc_tx_cache_display(struct seq_file *filp, void *unused)\n{\n\tstruct nix_hw *nix_hw = filp->private;\n\tint blkaddr = 0;\n\tint ndc_idx = 0;\n\n\tblkaddr = (nix_hw->blkaddr == BLKADDR_NIX1 ?\n\t\t   BLKADDR_NDC_NIX1_TX : BLKADDR_NDC_NIX0_TX);\n\tndc_idx = (nix_hw->blkaddr == BLKADDR_NIX1 ? NIX1_TX : NIX0_TX);\n\n\treturn ndc_blk_cache_stats(filp, ndc_idx, blkaddr);\n}\n\nRVU_DEBUG_SEQ_FOPS(nix_ndc_tx_cache, nix_ndc_tx_cache_display, NULL);\n\nstatic int rvu_dbg_npa_ndc_hits_miss_display(struct seq_file *filp,\n\t\t\t\t\t     void *unused)\n{\n\treturn ndc_blk_hits_miss_stats(filp, NPA0_U, BLKADDR_NDC_NPA0);\n}\n\nRVU_DEBUG_SEQ_FOPS(npa_ndc_hits_miss, npa_ndc_hits_miss_display, NULL);\n\nstatic int rvu_dbg_nix_ndc_rx_hits_miss_display(struct seq_file *filp,\n\t\t\t\t\t\tvoid *unused)\n{\n\tstruct nix_hw *nix_hw = filp->private;\n\tint ndc_idx = NPA0_U;\n\tint blkaddr = 0;\n\n\tblkaddr = (nix_hw->blkaddr == BLKADDR_NIX1 ?\n\t\t   BLKADDR_NDC_NIX1_RX : BLKADDR_NDC_NIX0_RX);\n\n\treturn ndc_blk_hits_miss_stats(filp, ndc_idx, blkaddr);\n}\n\nRVU_DEBUG_SEQ_FOPS(nix_ndc_rx_hits_miss, nix_ndc_rx_hits_miss_display, NULL);\n\nstatic int rvu_dbg_nix_ndc_tx_hits_miss_display(struct seq_file *filp,\n\t\t\t\t\t\tvoid *unused)\n{\n\tstruct nix_hw *nix_hw = filp->private;\n\tint ndc_idx = NPA0_U;\n\tint blkaddr = 0;\n\n\tblkaddr = (nix_hw->blkaddr == BLKADDR_NIX1 ?\n\t\t   BLKADDR_NDC_NIX1_TX : BLKADDR_NDC_NIX0_TX);\n\n\treturn ndc_blk_hits_miss_stats(filp, ndc_idx, blkaddr);\n}\n\nRVU_DEBUG_SEQ_FOPS(nix_ndc_tx_hits_miss, nix_ndc_tx_hits_miss_display, NULL);\n\nstatic void print_nix_cn10k_sq_ctx(struct seq_file *m,\n\t\t\t\t   struct nix_cn10k_sq_ctx_s *sq_ctx)\n{\n\tseq_printf(m, \"W0: ena \\t\\t\\t%d\\nW0: qint_idx \\t\\t\\t%d\\n\",\n\t\t   sq_ctx->ena, sq_ctx->qint_idx);\n\tseq_printf(m, \"W0: substream \\t\\t\\t0x%03x\\nW0: sdp_mcast \\t\\t\\t%d\\n\",\n\t\t   sq_ctx->substream, sq_ctx->sdp_mcast);\n\tseq_printf(m, \"W0: cq \\t\\t\\t\\t%d\\nW0: sqe_way_mask \\t\\t%d\\n\\n\",\n\t\t   sq_ctx->cq, sq_ctx->sqe_way_mask);\n\n\tseq_printf(m, \"W1: smq \\t\\t\\t%d\\nW1: cq_ena \\t\\t\\t%d\\nW1: xoff\\t\\t\\t%d\\n\",\n\t\t   sq_ctx->smq, sq_ctx->cq_ena, sq_ctx->xoff);\n\tseq_printf(m, \"W1: sso_ena \\t\\t\\t%d\\nW1: smq_rr_weight\\t\\t%d\\n\",\n\t\t   sq_ctx->sso_ena, sq_ctx->smq_rr_weight);\n\tseq_printf(m, \"W1: default_chan\\t\\t%d\\nW1: sqb_count\\t\\t\\t%d\\n\\n\",\n\t\t   sq_ctx->default_chan, sq_ctx->sqb_count);\n\n\tseq_printf(m, \"W2: smq_rr_count_lb \\t\\t%d\\n\", sq_ctx->smq_rr_count_lb);\n\tseq_printf(m, \"W2: smq_rr_count_ub \\t\\t%d\\n\", sq_ctx->smq_rr_count_ub);\n\tseq_printf(m, \"W2: sqb_aura \\t\\t\\t%d\\nW2: sq_int \\t\\t\\t%d\\n\",\n\t\t   sq_ctx->sqb_aura, sq_ctx->sq_int);\n\tseq_printf(m, \"W2: sq_int_ena \\t\\t\\t%d\\nW2: sqe_stype \\t\\t\\t%d\\n\",\n\t\t   sq_ctx->sq_int_ena, sq_ctx->sqe_stype);\n\n\tseq_printf(m, \"W3: max_sqe_size\\t\\t%d\\nW3: cq_limit\\t\\t\\t%d\\n\",\n\t\t   sq_ctx->max_sqe_size, sq_ctx->cq_limit);\n\tseq_printf(m, \"W3: lmt_dis \\t\\t\\t%d\\nW3: mnq_dis \\t\\t\\t%d\\n\",\n\t\t   sq_ctx->mnq_dis, sq_ctx->lmt_dis);\n\tseq_printf(m, \"W3: smq_next_sq\\t\\t\\t%d\\nW3: smq_lso_segnum\\t\\t%d\\n\",\n\t\t   sq_ctx->smq_next_sq, sq_ctx->smq_lso_segnum);\n\tseq_printf(m, \"W3: tail_offset \\t\\t%d\\nW3: smenq_offset\\t\\t%d\\n\",\n\t\t   sq_ctx->tail_offset, sq_ctx->smenq_offset);\n\tseq_printf(m, \"W3: head_offset\\t\\t\\t%d\\nW3: smenq_next_sqb_vld\\t\\t%d\\n\\n\",\n\t\t   sq_ctx->head_offset, sq_ctx->smenq_next_sqb_vld);\n\n\tseq_printf(m, \"W3: smq_next_sq_vld\\t\\t%d\\nW3: smq_pend\\t\\t\\t%d\\n\",\n\t\t   sq_ctx->smq_next_sq_vld, sq_ctx->smq_pend);\n\tseq_printf(m, \"W4: next_sqb \\t\\t\\t%llx\\n\\n\", sq_ctx->next_sqb);\n\tseq_printf(m, \"W5: tail_sqb \\t\\t\\t%llx\\n\\n\", sq_ctx->tail_sqb);\n\tseq_printf(m, \"W6: smenq_sqb \\t\\t\\t%llx\\n\\n\", sq_ctx->smenq_sqb);\n\tseq_printf(m, \"W7: smenq_next_sqb \\t\\t%llx\\n\\n\",\n\t\t   sq_ctx->smenq_next_sqb);\n\n\tseq_printf(m, \"W8: head_sqb\\t\\t\\t%llx\\n\\n\", sq_ctx->head_sqb);\n\n\tseq_printf(m, \"W9: vfi_lso_total\\t\\t%d\\n\", sq_ctx->vfi_lso_total);\n\tseq_printf(m, \"W9: vfi_lso_sizem1\\t\\t%d\\nW9: vfi_lso_sb\\t\\t\\t%d\\n\",\n\t\t   sq_ctx->vfi_lso_sizem1, sq_ctx->vfi_lso_sb);\n\tseq_printf(m, \"W9: vfi_lso_mps\\t\\t\\t%d\\nW9: vfi_lso_vlan0_ins_ena\\t%d\\n\",\n\t\t   sq_ctx->vfi_lso_mps, sq_ctx->vfi_lso_vlan0_ins_ena);\n\tseq_printf(m, \"W9: vfi_lso_vlan1_ins_ena\\t%d\\nW9: vfi_lso_vld \\t\\t%d\\n\\n\",\n\t\t   sq_ctx->vfi_lso_vld, sq_ctx->vfi_lso_vlan1_ins_ena);\n\n\tseq_printf(m, \"W10: scm_lso_rem \\t\\t%llu\\n\\n\",\n\t\t   (u64)sq_ctx->scm_lso_rem);\n\tseq_printf(m, \"W11: octs \\t\\t\\t%llu\\n\\n\", (u64)sq_ctx->octs);\n\tseq_printf(m, \"W12: pkts \\t\\t\\t%llu\\n\\n\", (u64)sq_ctx->pkts);\n\tseq_printf(m, \"W14: dropped_octs \\t\\t%llu\\n\\n\",\n\t\t   (u64)sq_ctx->dropped_octs);\n\tseq_printf(m, \"W15: dropped_pkts \\t\\t%llu\\n\\n\",\n\t\t   (u64)sq_ctx->dropped_pkts);\n}\n\n \nstatic void print_nix_sq_ctx(struct seq_file *m, struct nix_aq_enq_rsp *rsp)\n{\n\tstruct nix_sq_ctx_s *sq_ctx = &rsp->sq;\n\tstruct nix_hw *nix_hw = m->private;\n\tstruct rvu *rvu = nix_hw->rvu;\n\n\tif (!is_rvu_otx2(rvu)) {\n\t\tprint_nix_cn10k_sq_ctx(m, (struct nix_cn10k_sq_ctx_s *)sq_ctx);\n\t\treturn;\n\t}\n\tseq_printf(m, \"W0: sqe_way_mask \\t\\t%d\\nW0: cq \\t\\t\\t\\t%d\\n\",\n\t\t   sq_ctx->sqe_way_mask, sq_ctx->cq);\n\tseq_printf(m, \"W0: sdp_mcast \\t\\t\\t%d\\nW0: substream \\t\\t\\t0x%03x\\n\",\n\t\t   sq_ctx->sdp_mcast, sq_ctx->substream);\n\tseq_printf(m, \"W0: qint_idx \\t\\t\\t%d\\nW0: ena \\t\\t\\t%d\\n\\n\",\n\t\t   sq_ctx->qint_idx, sq_ctx->ena);\n\n\tseq_printf(m, \"W1: sqb_count \\t\\t\\t%d\\nW1: default_chan \\t\\t%d\\n\",\n\t\t   sq_ctx->sqb_count, sq_ctx->default_chan);\n\tseq_printf(m, \"W1: smq_rr_quantum \\t\\t%d\\nW1: sso_ena \\t\\t\\t%d\\n\",\n\t\t   sq_ctx->smq_rr_quantum, sq_ctx->sso_ena);\n\tseq_printf(m, \"W1: xoff \\t\\t\\t%d\\nW1: cq_ena \\t\\t\\t%d\\nW1: smq\\t\\t\\t\\t%d\\n\\n\",\n\t\t   sq_ctx->xoff, sq_ctx->cq_ena, sq_ctx->smq);\n\n\tseq_printf(m, \"W2: sqe_stype \\t\\t\\t%d\\nW2: sq_int_ena \\t\\t\\t%d\\n\",\n\t\t   sq_ctx->sqe_stype, sq_ctx->sq_int_ena);\n\tseq_printf(m, \"W2: sq_int \\t\\t\\t%d\\nW2: sqb_aura \\t\\t\\t%d\\n\",\n\t\t   sq_ctx->sq_int, sq_ctx->sqb_aura);\n\tseq_printf(m, \"W2: smq_rr_count \\t\\t%d\\n\\n\", sq_ctx->smq_rr_count);\n\n\tseq_printf(m, \"W3: smq_next_sq_vld\\t\\t%d\\nW3: smq_pend\\t\\t\\t%d\\n\",\n\t\t   sq_ctx->smq_next_sq_vld, sq_ctx->smq_pend);\n\tseq_printf(m, \"W3: smenq_next_sqb_vld \\t\\t%d\\nW3: head_offset\\t\\t\\t%d\\n\",\n\t\t   sq_ctx->smenq_next_sqb_vld, sq_ctx->head_offset);\n\tseq_printf(m, \"W3: smenq_offset\\t\\t%d\\nW3: tail_offset\\t\\t\\t%d\\n\",\n\t\t   sq_ctx->smenq_offset, sq_ctx->tail_offset);\n\tseq_printf(m, \"W3: smq_lso_segnum \\t\\t%d\\nW3: smq_next_sq\\t\\t\\t%d\\n\",\n\t\t   sq_ctx->smq_lso_segnum, sq_ctx->smq_next_sq);\n\tseq_printf(m, \"W3: mnq_dis \\t\\t\\t%d\\nW3: lmt_dis \\t\\t\\t%d\\n\",\n\t\t   sq_ctx->mnq_dis, sq_ctx->lmt_dis);\n\tseq_printf(m, \"W3: cq_limit\\t\\t\\t%d\\nW3: max_sqe_size\\t\\t%d\\n\\n\",\n\t\t   sq_ctx->cq_limit, sq_ctx->max_sqe_size);\n\n\tseq_printf(m, \"W4: next_sqb \\t\\t\\t%llx\\n\\n\", sq_ctx->next_sqb);\n\tseq_printf(m, \"W5: tail_sqb \\t\\t\\t%llx\\n\\n\", sq_ctx->tail_sqb);\n\tseq_printf(m, \"W6: smenq_sqb \\t\\t\\t%llx\\n\\n\", sq_ctx->smenq_sqb);\n\tseq_printf(m, \"W7: smenq_next_sqb \\t\\t%llx\\n\\n\",\n\t\t   sq_ctx->smenq_next_sqb);\n\n\tseq_printf(m, \"W8: head_sqb\\t\\t\\t%llx\\n\\n\", sq_ctx->head_sqb);\n\n\tseq_printf(m, \"W9: vfi_lso_vld\\t\\t\\t%d\\nW9: vfi_lso_vlan1_ins_ena\\t%d\\n\",\n\t\t   sq_ctx->vfi_lso_vld, sq_ctx->vfi_lso_vlan1_ins_ena);\n\tseq_printf(m, \"W9: vfi_lso_vlan0_ins_ena\\t%d\\nW9: vfi_lso_mps\\t\\t\\t%d\\n\",\n\t\t   sq_ctx->vfi_lso_vlan0_ins_ena, sq_ctx->vfi_lso_mps);\n\tseq_printf(m, \"W9: vfi_lso_sb\\t\\t\\t%d\\nW9: vfi_lso_sizem1\\t\\t%d\\n\",\n\t\t   sq_ctx->vfi_lso_sb, sq_ctx->vfi_lso_sizem1);\n\tseq_printf(m, \"W9: vfi_lso_total\\t\\t%d\\n\\n\", sq_ctx->vfi_lso_total);\n\n\tseq_printf(m, \"W10: scm_lso_rem \\t\\t%llu\\n\\n\",\n\t\t   (u64)sq_ctx->scm_lso_rem);\n\tseq_printf(m, \"W11: octs \\t\\t\\t%llu\\n\\n\", (u64)sq_ctx->octs);\n\tseq_printf(m, \"W12: pkts \\t\\t\\t%llu\\n\\n\", (u64)sq_ctx->pkts);\n\tseq_printf(m, \"W14: dropped_octs \\t\\t%llu\\n\\n\",\n\t\t   (u64)sq_ctx->dropped_octs);\n\tseq_printf(m, \"W15: dropped_pkts \\t\\t%llu\\n\\n\",\n\t\t   (u64)sq_ctx->dropped_pkts);\n}\n\nstatic void print_nix_cn10k_rq_ctx(struct seq_file *m,\n\t\t\t\t   struct nix_cn10k_rq_ctx_s *rq_ctx)\n{\n\tseq_printf(m, \"W0: ena \\t\\t\\t%d\\nW0: sso_ena \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->ena, rq_ctx->sso_ena);\n\tseq_printf(m, \"W0: ipsech_ena \\t\\t\\t%d\\nW0: ena_wqwd \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->ipsech_ena, rq_ctx->ena_wqwd);\n\tseq_printf(m, \"W0: cq \\t\\t\\t\\t%d\\nW0: lenerr_dis \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->cq, rq_ctx->lenerr_dis);\n\tseq_printf(m, \"W0: csum_il4_dis \\t\\t%d\\nW0: csum_ol4_dis \\t\\t%d\\n\",\n\t\t   rq_ctx->csum_il4_dis, rq_ctx->csum_ol4_dis);\n\tseq_printf(m, \"W0: len_il4_dis \\t\\t%d\\nW0: len_il3_dis \\t\\t%d\\n\",\n\t\t   rq_ctx->len_il4_dis, rq_ctx->len_il3_dis);\n\tseq_printf(m, \"W0: len_ol4_dis \\t\\t%d\\nW0: len_ol3_dis \\t\\t%d\\n\",\n\t\t   rq_ctx->len_ol4_dis, rq_ctx->len_ol3_dis);\n\tseq_printf(m, \"W0: wqe_aura \\t\\t\\t%d\\n\\n\", rq_ctx->wqe_aura);\n\n\tseq_printf(m, \"W1: spb_aura \\t\\t\\t%d\\nW1: lpb_aura \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->spb_aura, rq_ctx->lpb_aura);\n\tseq_printf(m, \"W1: spb_aura \\t\\t\\t%d\\n\", rq_ctx->spb_aura);\n\tseq_printf(m, \"W1: sso_grp \\t\\t\\t%d\\nW1: sso_tt \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->sso_grp, rq_ctx->sso_tt);\n\tseq_printf(m, \"W1: pb_caching \\t\\t\\t%d\\nW1: wqe_caching \\t\\t%d\\n\",\n\t\t   rq_ctx->pb_caching, rq_ctx->wqe_caching);\n\tseq_printf(m, \"W1: xqe_drop_ena \\t\\t%d\\nW1: spb_drop_ena \\t\\t%d\\n\",\n\t\t   rq_ctx->xqe_drop_ena, rq_ctx->spb_drop_ena);\n\tseq_printf(m, \"W1: lpb_drop_ena \\t\\t%d\\nW1: pb_stashing \\t\\t%d\\n\",\n\t\t   rq_ctx->lpb_drop_ena, rq_ctx->pb_stashing);\n\tseq_printf(m, \"W1: ipsecd_drop_ena \\t\\t%d\\nW1: chi_ena \\t\\t\\t%d\\n\\n\",\n\t\t   rq_ctx->ipsecd_drop_ena, rq_ctx->chi_ena);\n\n\tseq_printf(m, \"W2: band_prof_id \\t\\t%d\\n\", rq_ctx->band_prof_id);\n\tseq_printf(m, \"W2: policer_ena \\t\\t%d\\n\", rq_ctx->policer_ena);\n\tseq_printf(m, \"W2: spb_sizem1 \\t\\t\\t%d\\n\", rq_ctx->spb_sizem1);\n\tseq_printf(m, \"W2: wqe_skip \\t\\t\\t%d\\nW2: sqb_ena \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->wqe_skip, rq_ctx->spb_ena);\n\tseq_printf(m, \"W2: lpb_size1 \\t\\t\\t%d\\nW2: first_skip \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->lpb_sizem1, rq_ctx->first_skip);\n\tseq_printf(m, \"W2: later_skip\\t\\t\\t%d\\nW2: xqe_imm_size\\t\\t%d\\n\",\n\t\t   rq_ctx->later_skip, rq_ctx->xqe_imm_size);\n\tseq_printf(m, \"W2: xqe_imm_copy \\t\\t%d\\nW2: xqe_hdr_split \\t\\t%d\\n\\n\",\n\t\t   rq_ctx->xqe_imm_copy, rq_ctx->xqe_hdr_split);\n\n\tseq_printf(m, \"W3: xqe_drop \\t\\t\\t%d\\nW3: xqe_pass \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->xqe_drop, rq_ctx->xqe_pass);\n\tseq_printf(m, \"W3: wqe_pool_drop \\t\\t%d\\nW3: wqe_pool_pass \\t\\t%d\\n\",\n\t\t   rq_ctx->wqe_pool_drop, rq_ctx->wqe_pool_pass);\n\tseq_printf(m, \"W3: spb_pool_drop \\t\\t%d\\nW3: spb_pool_pass \\t\\t%d\\n\",\n\t\t   rq_ctx->spb_pool_drop, rq_ctx->spb_pool_pass);\n\tseq_printf(m, \"W3: spb_aura_drop \\t\\t%d\\nW3: spb_aura_pass \\t\\t%d\\n\\n\",\n\t\t   rq_ctx->spb_aura_pass, rq_ctx->spb_aura_drop);\n\n\tseq_printf(m, \"W4: lpb_aura_drop \\t\\t%d\\nW3: lpb_aura_pass \\t\\t%d\\n\",\n\t\t   rq_ctx->lpb_aura_pass, rq_ctx->lpb_aura_drop);\n\tseq_printf(m, \"W4: lpb_pool_drop \\t\\t%d\\nW3: lpb_pool_pass \\t\\t%d\\n\",\n\t\t   rq_ctx->lpb_pool_drop, rq_ctx->lpb_pool_pass);\n\tseq_printf(m, \"W4: rq_int \\t\\t\\t%d\\nW4: rq_int_ena\\t\\t\\t%d\\n\",\n\t\t   rq_ctx->rq_int, rq_ctx->rq_int_ena);\n\tseq_printf(m, \"W4: qint_idx \\t\\t\\t%d\\n\\n\", rq_ctx->qint_idx);\n\n\tseq_printf(m, \"W5: ltag \\t\\t\\t%d\\nW5: good_utag \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->ltag, rq_ctx->good_utag);\n\tseq_printf(m, \"W5: bad_utag \\t\\t\\t%d\\nW5: flow_tagw \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->bad_utag, rq_ctx->flow_tagw);\n\tseq_printf(m, \"W5: ipsec_vwqe \\t\\t\\t%d\\nW5: vwqe_ena \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->ipsec_vwqe, rq_ctx->vwqe_ena);\n\tseq_printf(m, \"W5: vwqe_wait \\t\\t\\t%d\\nW5: max_vsize_exp\\t\\t%d\\n\",\n\t\t   rq_ctx->vwqe_wait, rq_ctx->max_vsize_exp);\n\tseq_printf(m, \"W5: vwqe_skip \\t\\t\\t%d\\n\\n\", rq_ctx->vwqe_skip);\n\n\tseq_printf(m, \"W6: octs \\t\\t\\t%llu\\n\\n\", (u64)rq_ctx->octs);\n\tseq_printf(m, \"W7: pkts \\t\\t\\t%llu\\n\\n\", (u64)rq_ctx->pkts);\n\tseq_printf(m, \"W8: drop_octs \\t\\t\\t%llu\\n\\n\", (u64)rq_ctx->drop_octs);\n\tseq_printf(m, \"W9: drop_pkts \\t\\t\\t%llu\\n\\n\", (u64)rq_ctx->drop_pkts);\n\tseq_printf(m, \"W10: re_pkts \\t\\t\\t%llu\\n\", (u64)rq_ctx->re_pkts);\n}\n\n \nstatic void print_nix_rq_ctx(struct seq_file *m, struct nix_aq_enq_rsp *rsp)\n{\n\tstruct nix_rq_ctx_s *rq_ctx = &rsp->rq;\n\tstruct nix_hw *nix_hw = m->private;\n\tstruct rvu *rvu = nix_hw->rvu;\n\n\tif (!is_rvu_otx2(rvu)) {\n\t\tprint_nix_cn10k_rq_ctx(m, (struct nix_cn10k_rq_ctx_s *)rq_ctx);\n\t\treturn;\n\t}\n\n\tseq_printf(m, \"W0: wqe_aura \\t\\t\\t%d\\nW0: substream \\t\\t\\t0x%03x\\n\",\n\t\t   rq_ctx->wqe_aura, rq_ctx->substream);\n\tseq_printf(m, \"W0: cq \\t\\t\\t\\t%d\\nW0: ena_wqwd \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->cq, rq_ctx->ena_wqwd);\n\tseq_printf(m, \"W0: ipsech_ena \\t\\t\\t%d\\nW0: sso_ena \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->ipsech_ena, rq_ctx->sso_ena);\n\tseq_printf(m, \"W0: ena \\t\\t\\t%d\\n\\n\", rq_ctx->ena);\n\n\tseq_printf(m, \"W1: lpb_drop_ena \\t\\t%d\\nW1: spb_drop_ena \\t\\t%d\\n\",\n\t\t   rq_ctx->lpb_drop_ena, rq_ctx->spb_drop_ena);\n\tseq_printf(m, \"W1: xqe_drop_ena \\t\\t%d\\nW1: wqe_caching \\t\\t%d\\n\",\n\t\t   rq_ctx->xqe_drop_ena, rq_ctx->wqe_caching);\n\tseq_printf(m, \"W1: pb_caching \\t\\t\\t%d\\nW1: sso_tt \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->pb_caching, rq_ctx->sso_tt);\n\tseq_printf(m, \"W1: sso_grp \\t\\t\\t%d\\nW1: lpb_aura \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->sso_grp, rq_ctx->lpb_aura);\n\tseq_printf(m, \"W1: spb_aura \\t\\t\\t%d\\n\\n\", rq_ctx->spb_aura);\n\n\tseq_printf(m, \"W2: xqe_hdr_split \\t\\t%d\\nW2: xqe_imm_copy \\t\\t%d\\n\",\n\t\t   rq_ctx->xqe_hdr_split, rq_ctx->xqe_imm_copy);\n\tseq_printf(m, \"W2: xqe_imm_size \\t\\t%d\\nW2: later_skip \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->xqe_imm_size, rq_ctx->later_skip);\n\tseq_printf(m, \"W2: first_skip \\t\\t\\t%d\\nW2: lpb_sizem1 \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->first_skip, rq_ctx->lpb_sizem1);\n\tseq_printf(m, \"W2: spb_ena \\t\\t\\t%d\\nW2: wqe_skip \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->spb_ena, rq_ctx->wqe_skip);\n\tseq_printf(m, \"W2: spb_sizem1 \\t\\t\\t%d\\n\\n\", rq_ctx->spb_sizem1);\n\n\tseq_printf(m, \"W3: spb_pool_pass \\t\\t%d\\nW3: spb_pool_drop \\t\\t%d\\n\",\n\t\t   rq_ctx->spb_pool_pass, rq_ctx->spb_pool_drop);\n\tseq_printf(m, \"W3: spb_aura_pass \\t\\t%d\\nW3: spb_aura_drop \\t\\t%d\\n\",\n\t\t   rq_ctx->spb_aura_pass, rq_ctx->spb_aura_drop);\n\tseq_printf(m, \"W3: wqe_pool_pass \\t\\t%d\\nW3: wqe_pool_drop \\t\\t%d\\n\",\n\t\t   rq_ctx->wqe_pool_pass, rq_ctx->wqe_pool_drop);\n\tseq_printf(m, \"W3: xqe_pass \\t\\t\\t%d\\nW3: xqe_drop \\t\\t\\t%d\\n\\n\",\n\t\t   rq_ctx->xqe_pass, rq_ctx->xqe_drop);\n\n\tseq_printf(m, \"W4: qint_idx \\t\\t\\t%d\\nW4: rq_int_ena \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->qint_idx, rq_ctx->rq_int_ena);\n\tseq_printf(m, \"W4: rq_int \\t\\t\\t%d\\nW4: lpb_pool_pass \\t\\t%d\\n\",\n\t\t   rq_ctx->rq_int, rq_ctx->lpb_pool_pass);\n\tseq_printf(m, \"W4: lpb_pool_drop \\t\\t%d\\nW4: lpb_aura_pass \\t\\t%d\\n\",\n\t\t   rq_ctx->lpb_pool_drop, rq_ctx->lpb_aura_pass);\n\tseq_printf(m, \"W4: lpb_aura_drop \\t\\t%d\\n\\n\", rq_ctx->lpb_aura_drop);\n\n\tseq_printf(m, \"W5: flow_tagw \\t\\t\\t%d\\nW5: bad_utag \\t\\t\\t%d\\n\",\n\t\t   rq_ctx->flow_tagw, rq_ctx->bad_utag);\n\tseq_printf(m, \"W5: good_utag \\t\\t\\t%d\\nW5: ltag \\t\\t\\t%d\\n\\n\",\n\t\t   rq_ctx->good_utag, rq_ctx->ltag);\n\n\tseq_printf(m, \"W6: octs \\t\\t\\t%llu\\n\\n\", (u64)rq_ctx->octs);\n\tseq_printf(m, \"W7: pkts \\t\\t\\t%llu\\n\\n\", (u64)rq_ctx->pkts);\n\tseq_printf(m, \"W8: drop_octs \\t\\t\\t%llu\\n\\n\", (u64)rq_ctx->drop_octs);\n\tseq_printf(m, \"W9: drop_pkts \\t\\t\\t%llu\\n\\n\", (u64)rq_ctx->drop_pkts);\n\tseq_printf(m, \"W10: re_pkts \\t\\t\\t%llu\\n\", (u64)rq_ctx->re_pkts);\n}\n\n \nstatic void print_nix_cq_ctx(struct seq_file *m, struct nix_aq_enq_rsp *rsp)\n{\n\tstruct nix_cq_ctx_s *cq_ctx = &rsp->cq;\n\n\tseq_printf(m, \"W0: base \\t\\t\\t%llx\\n\\n\", cq_ctx->base);\n\n\tseq_printf(m, \"W1: wrptr \\t\\t\\t%llx\\n\", (u64)cq_ctx->wrptr);\n\tseq_printf(m, \"W1: avg_con \\t\\t\\t%d\\nW1: cint_idx \\t\\t\\t%d\\n\",\n\t\t   cq_ctx->avg_con, cq_ctx->cint_idx);\n\tseq_printf(m, \"W1: cq_err \\t\\t\\t%d\\nW1: qint_idx \\t\\t\\t%d\\n\",\n\t\t   cq_ctx->cq_err, cq_ctx->qint_idx);\n\tseq_printf(m, \"W1: bpid \\t\\t\\t%d\\nW1: bp_ena \\t\\t\\t%d\\n\\n\",\n\t\t   cq_ctx->bpid, cq_ctx->bp_ena);\n\n\tseq_printf(m, \"W2: update_time \\t\\t%d\\nW2:avg_level \\t\\t\\t%d\\n\",\n\t\t   cq_ctx->update_time, cq_ctx->avg_level);\n\tseq_printf(m, \"W2: head \\t\\t\\t%d\\nW2:tail \\t\\t\\t%d\\n\\n\",\n\t\t   cq_ctx->head, cq_ctx->tail);\n\n\tseq_printf(m, \"W3: cq_err_int_ena \\t\\t%d\\nW3:cq_err_int \\t\\t\\t%d\\n\",\n\t\t   cq_ctx->cq_err_int_ena, cq_ctx->cq_err_int);\n\tseq_printf(m, \"W3: qsize \\t\\t\\t%d\\nW3:caching \\t\\t\\t%d\\n\",\n\t\t   cq_ctx->qsize, cq_ctx->caching);\n\tseq_printf(m, \"W3: substream \\t\\t\\t0x%03x\\nW3: ena \\t\\t\\t%d\\n\",\n\t\t   cq_ctx->substream, cq_ctx->ena);\n\tseq_printf(m, \"W3: drop_ena \\t\\t\\t%d\\nW3: drop \\t\\t\\t%d\\n\",\n\t\t   cq_ctx->drop_ena, cq_ctx->drop);\n\tseq_printf(m, \"W3: bp \\t\\t\\t\\t%d\\n\\n\", cq_ctx->bp);\n}\n\nstatic int rvu_dbg_nix_queue_ctx_display(struct seq_file *filp,\n\t\t\t\t\t void *unused, int ctype)\n{\n\tvoid (*print_nix_ctx)(struct seq_file *filp,\n\t\t\t      struct nix_aq_enq_rsp *rsp) = NULL;\n\tstruct nix_hw *nix_hw = filp->private;\n\tstruct rvu *rvu = nix_hw->rvu;\n\tstruct nix_aq_enq_req aq_req;\n\tstruct nix_aq_enq_rsp rsp;\n\tchar *ctype_string = NULL;\n\tint qidx, rc, max_id = 0;\n\tstruct rvu_pfvf *pfvf;\n\tint nixlf, id, all;\n\tu16 pcifunc;\n\n\tswitch (ctype) {\n\tcase NIX_AQ_CTYPE_CQ:\n\t\tnixlf = rvu->rvu_dbg.nix_cq_ctx.lf;\n\t\tid = rvu->rvu_dbg.nix_cq_ctx.id;\n\t\tall = rvu->rvu_dbg.nix_cq_ctx.all;\n\t\tbreak;\n\n\tcase NIX_AQ_CTYPE_SQ:\n\t\tnixlf = rvu->rvu_dbg.nix_sq_ctx.lf;\n\t\tid = rvu->rvu_dbg.nix_sq_ctx.id;\n\t\tall = rvu->rvu_dbg.nix_sq_ctx.all;\n\t\tbreak;\n\n\tcase NIX_AQ_CTYPE_RQ:\n\t\tnixlf = rvu->rvu_dbg.nix_rq_ctx.lf;\n\t\tid = rvu->rvu_dbg.nix_rq_ctx.id;\n\t\tall = rvu->rvu_dbg.nix_rq_ctx.all;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rvu_dbg_is_valid_lf(rvu, nix_hw->blkaddr, nixlf, &pcifunc))\n\t\treturn -EINVAL;\n\n\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\tif (ctype == NIX_AQ_CTYPE_SQ && !pfvf->sq_ctx) {\n\t\tseq_puts(filp, \"SQ context is not initialized\\n\");\n\t\treturn -EINVAL;\n\t} else if (ctype == NIX_AQ_CTYPE_RQ && !pfvf->rq_ctx) {\n\t\tseq_puts(filp, \"RQ context is not initialized\\n\");\n\t\treturn -EINVAL;\n\t} else if (ctype == NIX_AQ_CTYPE_CQ && !pfvf->cq_ctx) {\n\t\tseq_puts(filp, \"CQ context is not initialized\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctype == NIX_AQ_CTYPE_SQ) {\n\t\tmax_id = pfvf->sq_ctx->qsize;\n\t\tctype_string = \"sq\";\n\t\tprint_nix_ctx = print_nix_sq_ctx;\n\t} else if (ctype == NIX_AQ_CTYPE_RQ) {\n\t\tmax_id = pfvf->rq_ctx->qsize;\n\t\tctype_string = \"rq\";\n\t\tprint_nix_ctx = print_nix_rq_ctx;\n\t} else if (ctype == NIX_AQ_CTYPE_CQ) {\n\t\tmax_id = pfvf->cq_ctx->qsize;\n\t\tctype_string = \"cq\";\n\t\tprint_nix_ctx = print_nix_cq_ctx;\n\t}\n\n\tmemset(&aq_req, 0, sizeof(struct nix_aq_enq_req));\n\taq_req.hdr.pcifunc = pcifunc;\n\taq_req.ctype = ctype;\n\taq_req.op = NIX_AQ_INSTOP_READ;\n\tif (all)\n\t\tid = 0;\n\telse\n\t\tmax_id = id + 1;\n\tfor (qidx = id; qidx < max_id; qidx++) {\n\t\taq_req.qidx = qidx;\n\t\tseq_printf(filp, \"=====%s_ctx for nixlf:%d and qidx:%d is=====\\n\",\n\t\t\t   ctype_string, nixlf, aq_req.qidx);\n\t\trc = rvu_mbox_handler_nix_aq_enq(rvu, &aq_req, &rsp);\n\t\tif (rc) {\n\t\t\tseq_puts(filp, \"Failed to read the context\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tprint_nix_ctx(filp, &rsp);\n\t}\n\treturn 0;\n}\n\nstatic int write_nix_queue_ctx(struct rvu *rvu, bool all, int nixlf,\n\t\t\t       int id, int ctype, char *ctype_string,\n\t\t\t       struct seq_file *m)\n{\n\tstruct nix_hw *nix_hw = m->private;\n\tstruct rvu_pfvf *pfvf;\n\tint max_id = 0;\n\tu16 pcifunc;\n\n\tif (!rvu_dbg_is_valid_lf(rvu, nix_hw->blkaddr, nixlf, &pcifunc))\n\t\treturn -EINVAL;\n\n\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\n\tif (ctype == NIX_AQ_CTYPE_SQ) {\n\t\tif (!pfvf->sq_ctx) {\n\t\t\tdev_warn(rvu->dev, \"SQ context is not initialized\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmax_id = pfvf->sq_ctx->qsize;\n\t} else if (ctype == NIX_AQ_CTYPE_RQ) {\n\t\tif (!pfvf->rq_ctx) {\n\t\t\tdev_warn(rvu->dev, \"RQ context is not initialized\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmax_id = pfvf->rq_ctx->qsize;\n\t} else if (ctype == NIX_AQ_CTYPE_CQ) {\n\t\tif (!pfvf->cq_ctx) {\n\t\t\tdev_warn(rvu->dev, \"CQ context is not initialized\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmax_id = pfvf->cq_ctx->qsize;\n\t}\n\n\tif (id < 0 || id >= max_id) {\n\t\tdev_warn(rvu->dev, \"Invalid %s_ctx valid range 0-%d\\n\",\n\t\t\t ctype_string, max_id - 1);\n\t\treturn -EINVAL;\n\t}\n\tswitch (ctype) {\n\tcase NIX_AQ_CTYPE_CQ:\n\t\trvu->rvu_dbg.nix_cq_ctx.lf = nixlf;\n\t\trvu->rvu_dbg.nix_cq_ctx.id = id;\n\t\trvu->rvu_dbg.nix_cq_ctx.all = all;\n\t\tbreak;\n\n\tcase NIX_AQ_CTYPE_SQ:\n\t\trvu->rvu_dbg.nix_sq_ctx.lf = nixlf;\n\t\trvu->rvu_dbg.nix_sq_ctx.id = id;\n\t\trvu->rvu_dbg.nix_sq_ctx.all = all;\n\t\tbreak;\n\n\tcase NIX_AQ_CTYPE_RQ:\n\t\trvu->rvu_dbg.nix_rq_ctx.lf = nixlf;\n\t\trvu->rvu_dbg.nix_rq_ctx.id = id;\n\t\trvu->rvu_dbg.nix_rq_ctx.all = all;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t rvu_dbg_nix_queue_ctx_write(struct file *filp,\n\t\t\t\t\t   const char __user *buffer,\n\t\t\t\t\t   size_t count, loff_t *ppos,\n\t\t\t\t\t   int ctype)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct nix_hw *nix_hw = m->private;\n\tstruct rvu *rvu = nix_hw->rvu;\n\tchar *cmd_buf, *ctype_string;\n\tint nixlf, id = 0, ret;\n\tbool all = false;\n\n\tif ((*ppos != 0) || !count)\n\t\treturn -EINVAL;\n\n\tswitch (ctype) {\n\tcase NIX_AQ_CTYPE_SQ:\n\t\tctype_string = \"sq\";\n\t\tbreak;\n\tcase NIX_AQ_CTYPE_RQ:\n\t\tctype_string = \"rq\";\n\t\tbreak;\n\tcase NIX_AQ_CTYPE_CQ:\n\t\tctype_string = \"cq\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcmd_buf = kzalloc(count + 1, GFP_KERNEL);\n\n\tif (!cmd_buf)\n\t\treturn count;\n\n\tret = parse_cmd_buffer_ctx(cmd_buf, &count, buffer,\n\t\t\t\t   &nixlf, &id, &all);\n\tif (ret < 0) {\n\t\tdev_info(rvu->dev,\n\t\t\t \"Usage: echo <nixlf> [%s number/all] > %s_ctx\\n\",\n\t\t\t ctype_string, ctype_string);\n\t\tgoto done;\n\t} else {\n\t\tret = write_nix_queue_ctx(rvu, all, nixlf, id, ctype,\n\t\t\t\t\t  ctype_string, m);\n\t}\ndone:\n\tkfree(cmd_buf);\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t rvu_dbg_nix_sq_ctx_write(struct file *filp,\n\t\t\t\t\tconst char __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn rvu_dbg_nix_queue_ctx_write(filp, buffer, count, ppos,\n\t\t\t\t\t    NIX_AQ_CTYPE_SQ);\n}\n\nstatic int rvu_dbg_nix_sq_ctx_display(struct seq_file *filp, void *unused)\n{\n\treturn rvu_dbg_nix_queue_ctx_display(filp, unused, NIX_AQ_CTYPE_SQ);\n}\n\nRVU_DEBUG_SEQ_FOPS(nix_sq_ctx, nix_sq_ctx_display, nix_sq_ctx_write);\n\nstatic ssize_t rvu_dbg_nix_rq_ctx_write(struct file *filp,\n\t\t\t\t\tconst char __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn rvu_dbg_nix_queue_ctx_write(filp, buffer, count, ppos,\n\t\t\t\t\t    NIX_AQ_CTYPE_RQ);\n}\n\nstatic int rvu_dbg_nix_rq_ctx_display(struct seq_file *filp, void  *unused)\n{\n\treturn rvu_dbg_nix_queue_ctx_display(filp, unused,  NIX_AQ_CTYPE_RQ);\n}\n\nRVU_DEBUG_SEQ_FOPS(nix_rq_ctx, nix_rq_ctx_display, nix_rq_ctx_write);\n\nstatic ssize_t rvu_dbg_nix_cq_ctx_write(struct file *filp,\n\t\t\t\t\tconst char __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn rvu_dbg_nix_queue_ctx_write(filp, buffer, count, ppos,\n\t\t\t\t\t    NIX_AQ_CTYPE_CQ);\n}\n\nstatic int rvu_dbg_nix_cq_ctx_display(struct seq_file *filp, void *unused)\n{\n\treturn rvu_dbg_nix_queue_ctx_display(filp, unused, NIX_AQ_CTYPE_CQ);\n}\n\nRVU_DEBUG_SEQ_FOPS(nix_cq_ctx, nix_cq_ctx_display, nix_cq_ctx_write);\n\nstatic void print_nix_qctx_qsize(struct seq_file *filp, int qsize,\n\t\t\t\t unsigned long *bmap, char *qtype)\n{\n\tchar *buf;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tbitmap_print_to_pagebuf(false, buf, bmap, qsize);\n\tseq_printf(filp, \"%s context count : %d\\n\", qtype, qsize);\n\tseq_printf(filp, \"%s context ena/dis bitmap : %s\\n\",\n\t\t   qtype, buf);\n\tkfree(buf);\n}\n\nstatic void print_nix_qsize(struct seq_file *filp, struct rvu_pfvf *pfvf)\n{\n\tif (!pfvf->cq_ctx)\n\t\tseq_puts(filp, \"cq context is not initialized\\n\");\n\telse\n\t\tprint_nix_qctx_qsize(filp, pfvf->cq_ctx->qsize, pfvf->cq_bmap,\n\t\t\t\t     \"cq\");\n\n\tif (!pfvf->rq_ctx)\n\t\tseq_puts(filp, \"rq context is not initialized\\n\");\n\telse\n\t\tprint_nix_qctx_qsize(filp, pfvf->rq_ctx->qsize, pfvf->rq_bmap,\n\t\t\t\t     \"rq\");\n\n\tif (!pfvf->sq_ctx)\n\t\tseq_puts(filp, \"sq context is not initialized\\n\");\n\telse\n\t\tprint_nix_qctx_qsize(filp, pfvf->sq_ctx->qsize, pfvf->sq_bmap,\n\t\t\t\t     \"sq\");\n}\n\nstatic ssize_t rvu_dbg_nix_qsize_write(struct file *filp,\n\t\t\t\t       const char __user *buffer,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\treturn rvu_dbg_qsize_write(filp, buffer, count, ppos,\n\t\t\t\t   BLKTYPE_NIX);\n}\n\nstatic int rvu_dbg_nix_qsize_display(struct seq_file *filp, void *unused)\n{\n\treturn rvu_dbg_qsize_display(filp, unused, BLKTYPE_NIX);\n}\n\nRVU_DEBUG_SEQ_FOPS(nix_qsize, nix_qsize_display, nix_qsize_write);\n\nstatic void print_band_prof_ctx(struct seq_file *m,\n\t\t\t\tstruct nix_bandprof_s *prof)\n{\n\tchar *str;\n\n\tswitch (prof->pc_mode) {\n\tcase NIX_RX_PC_MODE_VLAN:\n\t\tstr = \"VLAN\";\n\t\tbreak;\n\tcase NIX_RX_PC_MODE_DSCP:\n\t\tstr = \"DSCP\";\n\t\tbreak;\n\tcase NIX_RX_PC_MODE_GEN:\n\t\tstr = \"Generic\";\n\t\tbreak;\n\tcase NIX_RX_PC_MODE_RSVD:\n\t\tstr = \"Reserved\";\n\t\tbreak;\n\t}\n\tseq_printf(m, \"W0: pc_mode\\t\\t%s\\n\", str);\n\tstr = (prof->icolor == 3) ? \"Color blind\" :\n\t\t(prof->icolor == 0) ? \"Green\" :\n\t\t(prof->icolor == 1) ? \"Yellow\" : \"Red\";\n\tseq_printf(m, \"W0: icolor\\t\\t%s\\n\", str);\n\tseq_printf(m, \"W0: tnl_ena\\t\\t%d\\n\", prof->tnl_ena);\n\tseq_printf(m, \"W0: peir_exponent\\t%d\\n\", prof->peir_exponent);\n\tseq_printf(m, \"W0: pebs_exponent\\t%d\\n\", prof->pebs_exponent);\n\tseq_printf(m, \"W0: cir_exponent\\t%d\\n\", prof->cir_exponent);\n\tseq_printf(m, \"W0: cbs_exponent\\t%d\\n\", prof->cbs_exponent);\n\tseq_printf(m, \"W0: peir_mantissa\\t%d\\n\", prof->peir_mantissa);\n\tseq_printf(m, \"W0: pebs_mantissa\\t%d\\n\", prof->pebs_mantissa);\n\tseq_printf(m, \"W0: cir_mantissa\\t%d\\n\", prof->cir_mantissa);\n\n\tseq_printf(m, \"W1: cbs_mantissa\\t%d\\n\", prof->cbs_mantissa);\n\tstr = (prof->lmode == 0) ? \"byte\" : \"packet\";\n\tseq_printf(m, \"W1: lmode\\t\\t%s\\n\", str);\n\tseq_printf(m, \"W1: l_select\\t\\t%d\\n\", prof->l_sellect);\n\tseq_printf(m, \"W1: rdiv\\t\\t%d\\n\", prof->rdiv);\n\tseq_printf(m, \"W1: adjust_exponent\\t%d\\n\", prof->adjust_exponent);\n\tseq_printf(m, \"W1: adjust_mantissa\\t%d\\n\", prof->adjust_mantissa);\n\tstr = (prof->gc_action == 0) ? \"PASS\" :\n\t\t(prof->gc_action == 1) ? \"DROP\" : \"RED\";\n\tseq_printf(m, \"W1: gc_action\\t\\t%s\\n\", str);\n\tstr = (prof->yc_action == 0) ? \"PASS\" :\n\t\t(prof->yc_action == 1) ? \"DROP\" : \"RED\";\n\tseq_printf(m, \"W1: yc_action\\t\\t%s\\n\", str);\n\tstr = (prof->rc_action == 0) ? \"PASS\" :\n\t\t(prof->rc_action == 1) ? \"DROP\" : \"RED\";\n\tseq_printf(m, \"W1: rc_action\\t\\t%s\\n\", str);\n\tseq_printf(m, \"W1: meter_algo\\t\\t%d\\n\", prof->meter_algo);\n\tseq_printf(m, \"W1: band_prof_id\\t%d\\n\", prof->band_prof_id);\n\tseq_printf(m, \"W1: hl_en\\t\\t%d\\n\", prof->hl_en);\n\n\tseq_printf(m, \"W2: ts\\t\\t\\t%lld\\n\", (u64)prof->ts);\n\tseq_printf(m, \"W3: pe_accum\\t\\t%d\\n\", prof->pe_accum);\n\tseq_printf(m, \"W3: c_accum\\t\\t%d\\n\", prof->c_accum);\n\tseq_printf(m, \"W4: green_pkt_pass\\t%lld\\n\",\n\t\t   (u64)prof->green_pkt_pass);\n\tseq_printf(m, \"W5: yellow_pkt_pass\\t%lld\\n\",\n\t\t   (u64)prof->yellow_pkt_pass);\n\tseq_printf(m, \"W6: red_pkt_pass\\t%lld\\n\", (u64)prof->red_pkt_pass);\n\tseq_printf(m, \"W7: green_octs_pass\\t%lld\\n\",\n\t\t   (u64)prof->green_octs_pass);\n\tseq_printf(m, \"W8: yellow_octs_pass\\t%lld\\n\",\n\t\t   (u64)prof->yellow_octs_pass);\n\tseq_printf(m, \"W9: red_octs_pass\\t%lld\\n\", (u64)prof->red_octs_pass);\n\tseq_printf(m, \"W10: green_pkt_drop\\t%lld\\n\",\n\t\t   (u64)prof->green_pkt_drop);\n\tseq_printf(m, \"W11: yellow_pkt_drop\\t%lld\\n\",\n\t\t   (u64)prof->yellow_pkt_drop);\n\tseq_printf(m, \"W12: red_pkt_drop\\t%lld\\n\", (u64)prof->red_pkt_drop);\n\tseq_printf(m, \"W13: green_octs_drop\\t%lld\\n\",\n\t\t   (u64)prof->green_octs_drop);\n\tseq_printf(m, \"W14: yellow_octs_drop\\t%lld\\n\",\n\t\t   (u64)prof->yellow_octs_drop);\n\tseq_printf(m, \"W15: red_octs_drop\\t%lld\\n\", (u64)prof->red_octs_drop);\n\tseq_puts(m, \"==============================\\n\");\n}\n\nstatic int rvu_dbg_nix_band_prof_ctx_display(struct seq_file *m, void *unused)\n{\n\tstruct nix_hw *nix_hw = m->private;\n\tstruct nix_cn10k_aq_enq_req aq_req;\n\tstruct nix_cn10k_aq_enq_rsp aq_rsp;\n\tstruct rvu *rvu = nix_hw->rvu;\n\tstruct nix_ipolicer *ipolicer;\n\tint layer, prof_idx, idx, rc;\n\tu16 pcifunc;\n\tchar *str;\n\n\t \n\tif (!nix_hw->ipolicer)\n\t\treturn 0;\n\n\tfor (layer = 0; layer < BAND_PROF_NUM_LAYERS; layer++) {\n\t\tif (layer == BAND_PROF_INVAL_LAYER)\n\t\t\tcontinue;\n\t\tstr = (layer == BAND_PROF_LEAF_LAYER) ? \"Leaf\" :\n\t\t\t(layer == BAND_PROF_MID_LAYER) ? \"Mid\" : \"Top\";\n\n\t\tseq_printf(m, \"\\n%s bandwidth profiles\\n\", str);\n\t\tseq_puts(m, \"=======================\\n\");\n\n\t\tipolicer = &nix_hw->ipolicer[layer];\n\n\t\tfor (idx = 0; idx < ipolicer->band_prof.max; idx++) {\n\t\t\tif (is_rsrc_free(&ipolicer->band_prof, idx))\n\t\t\t\tcontinue;\n\n\t\t\tprof_idx = (idx & 0x3FFF) | (layer << 14);\n\t\t\trc = nix_aq_context_read(rvu, nix_hw, &aq_req, &aq_rsp,\n\t\t\t\t\t\t 0x00, NIX_AQ_CTYPE_BANDPROF,\n\t\t\t\t\t\t prof_idx);\n\t\t\tif (rc) {\n\t\t\t\tdev_err(rvu->dev,\n\t\t\t\t\t\"%s: Failed to fetch context of %s profile %d, err %d\\n\",\n\t\t\t\t\t__func__, str, idx, rc);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tseq_printf(m, \"\\n%s bandwidth profile:: %d\\n\", str, idx);\n\t\t\tpcifunc = ipolicer->pfvf_map[idx];\n\t\t\tif (!(pcifunc & RVU_PFVF_FUNC_MASK))\n\t\t\t\tseq_printf(m, \"Allocated to :: PF %d\\n\",\n\t\t\t\t\t   rvu_get_pf(pcifunc));\n\t\t\telse\n\t\t\t\tseq_printf(m, \"Allocated to :: PF %d VF %d\\n\",\n\t\t\t\t\t   rvu_get_pf(pcifunc),\n\t\t\t\t\t   (pcifunc & RVU_PFVF_FUNC_MASK) - 1);\n\t\t\tprint_band_prof_ctx(m, &aq_rsp.prof);\n\t\t}\n\t}\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(nix_band_prof_ctx, nix_band_prof_ctx_display, NULL);\n\nstatic int rvu_dbg_nix_band_prof_rsrc_display(struct seq_file *m, void *unused)\n{\n\tstruct nix_hw *nix_hw = m->private;\n\tstruct nix_ipolicer *ipolicer;\n\tint layer;\n\tchar *str;\n\n\t \n\tif (!nix_hw->ipolicer)\n\t\treturn 0;\n\n\tseq_puts(m, \"\\nBandwidth profile resource free count\\n\");\n\tseq_puts(m, \"=====================================\\n\");\n\tfor (layer = 0; layer < BAND_PROF_NUM_LAYERS; layer++) {\n\t\tif (layer == BAND_PROF_INVAL_LAYER)\n\t\t\tcontinue;\n\t\tstr = (layer == BAND_PROF_LEAF_LAYER) ? \"Leaf\" :\n\t\t\t(layer == BAND_PROF_MID_LAYER) ? \"Mid \" : \"Top \";\n\n\t\tipolicer = &nix_hw->ipolicer[layer];\n\t\tseq_printf(m, \"%s :: Max: %4d  Free: %4d\\n\", str,\n\t\t\t   ipolicer->band_prof.max,\n\t\t\t   rvu_rsrc_free_count(&ipolicer->band_prof));\n\t}\n\tseq_puts(m, \"=====================================\\n\");\n\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(nix_band_prof_rsrc, nix_band_prof_rsrc_display, NULL);\n\nstatic void rvu_dbg_nix_init(struct rvu *rvu, int blkaddr)\n{\n\tstruct nix_hw *nix_hw;\n\n\tif (!is_block_implemented(rvu->hw, blkaddr))\n\t\treturn;\n\n\tif (blkaddr == BLKADDR_NIX0) {\n\t\trvu->rvu_dbg.nix = debugfs_create_dir(\"nix\", rvu->rvu_dbg.root);\n\t\tnix_hw = &rvu->hw->nix[0];\n\t} else {\n\t\trvu->rvu_dbg.nix = debugfs_create_dir(\"nix1\",\n\t\t\t\t\t\t      rvu->rvu_dbg.root);\n\t\tnix_hw = &rvu->hw->nix[1];\n\t}\n\n\tdebugfs_create_file(\"sq_ctx\", 0600, rvu->rvu_dbg.nix, nix_hw,\n\t\t\t    &rvu_dbg_nix_sq_ctx_fops);\n\tdebugfs_create_file(\"rq_ctx\", 0600, rvu->rvu_dbg.nix, nix_hw,\n\t\t\t    &rvu_dbg_nix_rq_ctx_fops);\n\tdebugfs_create_file(\"cq_ctx\", 0600, rvu->rvu_dbg.nix, nix_hw,\n\t\t\t    &rvu_dbg_nix_cq_ctx_fops);\n\tdebugfs_create_file(\"ndc_tx_cache\", 0600, rvu->rvu_dbg.nix, nix_hw,\n\t\t\t    &rvu_dbg_nix_ndc_tx_cache_fops);\n\tdebugfs_create_file(\"ndc_rx_cache\", 0600, rvu->rvu_dbg.nix, nix_hw,\n\t\t\t    &rvu_dbg_nix_ndc_rx_cache_fops);\n\tdebugfs_create_file(\"ndc_tx_hits_miss\", 0600, rvu->rvu_dbg.nix, nix_hw,\n\t\t\t    &rvu_dbg_nix_ndc_tx_hits_miss_fops);\n\tdebugfs_create_file(\"ndc_rx_hits_miss\", 0600, rvu->rvu_dbg.nix, nix_hw,\n\t\t\t    &rvu_dbg_nix_ndc_rx_hits_miss_fops);\n\tdebugfs_create_file(\"qsize\", 0600, rvu->rvu_dbg.nix, rvu,\n\t\t\t    &rvu_dbg_nix_qsize_fops);\n\tdebugfs_create_file(\"ingress_policer_ctx\", 0600, rvu->rvu_dbg.nix, nix_hw,\n\t\t\t    &rvu_dbg_nix_band_prof_ctx_fops);\n\tdebugfs_create_file(\"ingress_policer_rsrc\", 0600, rvu->rvu_dbg.nix, nix_hw,\n\t\t\t    &rvu_dbg_nix_band_prof_rsrc_fops);\n}\n\nstatic void rvu_dbg_npa_init(struct rvu *rvu)\n{\n\trvu->rvu_dbg.npa = debugfs_create_dir(\"npa\", rvu->rvu_dbg.root);\n\n\tdebugfs_create_file(\"qsize\", 0600, rvu->rvu_dbg.npa, rvu,\n\t\t\t    &rvu_dbg_npa_qsize_fops);\n\tdebugfs_create_file(\"aura_ctx\", 0600, rvu->rvu_dbg.npa, rvu,\n\t\t\t    &rvu_dbg_npa_aura_ctx_fops);\n\tdebugfs_create_file(\"pool_ctx\", 0600, rvu->rvu_dbg.npa, rvu,\n\t\t\t    &rvu_dbg_npa_pool_ctx_fops);\n\tdebugfs_create_file(\"ndc_cache\", 0600, rvu->rvu_dbg.npa, rvu,\n\t\t\t    &rvu_dbg_npa_ndc_cache_fops);\n\tdebugfs_create_file(\"ndc_hits_miss\", 0600, rvu->rvu_dbg.npa, rvu,\n\t\t\t    &rvu_dbg_npa_ndc_hits_miss_fops);\n}\n\n#define PRINT_CGX_CUML_NIXRX_STATUS(idx, name)\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tu64 cnt;\t\t\t\t\t\t\\\n\t\terr = rvu_cgx_nix_cuml_stats(rvu, cgxd, lmac_id, (idx),\t\\\n\t\t\t\t\t     NIX_STATS_RX, &(cnt));\t\\\n\t\tif (!err)\t\t\t\t\t\t\\\n\t\t\tseq_printf(s, \"%s: %llu\\n\", name, cnt);\t\t\\\n\t\tcnt;\t\t\t\t\t\t\t\\\n\t})\n\n#define PRINT_CGX_CUML_NIXTX_STATUS(idx, name)\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tu64 cnt;\t\t\t\t\t\t\\\n\t\terr = rvu_cgx_nix_cuml_stats(rvu, cgxd, lmac_id, (idx),\t\\\n\t\t\t\t\t  NIX_STATS_TX, &(cnt));\t\\\n\t\tif (!err)\t\t\t\t\t\t\\\n\t\t\tseq_printf(s, \"%s: %llu\\n\", name, cnt);\t\t\\\n\t\tcnt;\t\t\t\t\t\t\t\\\n\t})\n\nstatic int cgx_print_stats(struct seq_file *s, int lmac_id)\n{\n\tstruct cgx_link_user_info linfo;\n\tstruct mac_ops *mac_ops;\n\tvoid *cgxd = s->private;\n\tu64 ucast, mcast, bcast;\n\tint stat = 0, err = 0;\n\tu64 tx_stat, rx_stat;\n\tstruct rvu *rvu;\n\n\trvu = pci_get_drvdata(pci_get_device(PCI_VENDOR_ID_CAVIUM,\n\t\t\t\t\t     PCI_DEVID_OCTEONTX2_RVU_AF, NULL));\n\tif (!rvu)\n\t\treturn -ENODEV;\n\n\tmac_ops = get_mac_ops(cgxd);\n\t \n\tif (!mac_ops)\n\t\treturn 0;\n\n\t \n\tseq_puts(s, \"\\n=======Link Status======\\n\\n\");\n\terr = cgx_get_link_info(cgxd, lmac_id, &linfo);\n\tif (err)\n\t\tseq_puts(s, \"Failed to read link status\\n\");\n\tseq_printf(s, \"\\nLink is %s %d Mbps\\n\\n\",\n\t\t   linfo.link_up ? \"UP\" : \"DOWN\", linfo.speed);\n\n\t \n\tseq_printf(s, \"\\n=======NIX RX_STATS(%s port level)======\\n\\n\",\n\t\t   mac_ops->name);\n\tucast = PRINT_CGX_CUML_NIXRX_STATUS(RX_UCAST, \"rx_ucast_frames\");\n\tif (err)\n\t\treturn err;\n\tmcast = PRINT_CGX_CUML_NIXRX_STATUS(RX_MCAST, \"rx_mcast_frames\");\n\tif (err)\n\t\treturn err;\n\tbcast = PRINT_CGX_CUML_NIXRX_STATUS(RX_BCAST, \"rx_bcast_frames\");\n\tif (err)\n\t\treturn err;\n\tseq_printf(s, \"rx_frames: %llu\\n\", ucast + mcast + bcast);\n\tPRINT_CGX_CUML_NIXRX_STATUS(RX_OCTS, \"rx_bytes\");\n\tif (err)\n\t\treturn err;\n\tPRINT_CGX_CUML_NIXRX_STATUS(RX_DROP, \"rx_drops\");\n\tif (err)\n\t\treturn err;\n\tPRINT_CGX_CUML_NIXRX_STATUS(RX_ERR, \"rx_errors\");\n\tif (err)\n\t\treturn err;\n\n\t \n\tseq_printf(s, \"\\n=======NIX TX_STATS(%s port level)======\\n\\n\",\n\t\t   mac_ops->name);\n\tucast = PRINT_CGX_CUML_NIXTX_STATUS(TX_UCAST, \"tx_ucast_frames\");\n\tif (err)\n\t\treturn err;\n\tmcast = PRINT_CGX_CUML_NIXTX_STATUS(TX_MCAST, \"tx_mcast_frames\");\n\tif (err)\n\t\treturn err;\n\tbcast = PRINT_CGX_CUML_NIXTX_STATUS(TX_BCAST, \"tx_bcast_frames\");\n\tif (err)\n\t\treturn err;\n\tseq_printf(s, \"tx_frames: %llu\\n\", ucast + mcast + bcast);\n\tPRINT_CGX_CUML_NIXTX_STATUS(TX_OCTS, \"tx_bytes\");\n\tif (err)\n\t\treturn err;\n\tPRINT_CGX_CUML_NIXTX_STATUS(TX_DROP, \"tx_drops\");\n\tif (err)\n\t\treturn err;\n\n\t \n\tseq_printf(s, \"\\n=======%s RX_STATS======\\n\\n\", mac_ops->name);\n\twhile (stat < mac_ops->rx_stats_cnt) {\n\t\terr = mac_ops->mac_get_rx_stats(cgxd, lmac_id, stat, &rx_stat);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (is_rvu_otx2(rvu))\n\t\t\tseq_printf(s, \"%s: %llu\\n\", cgx_rx_stats_fields[stat],\n\t\t\t\t   rx_stat);\n\t\telse\n\t\t\tseq_printf(s, \"%s: %llu\\n\", rpm_rx_stats_fields[stat],\n\t\t\t\t   rx_stat);\n\t\tstat++;\n\t}\n\n\t \n\tstat = 0;\n\tseq_printf(s, \"\\n=======%s TX_STATS======\\n\\n\", mac_ops->name);\n\twhile (stat < mac_ops->tx_stats_cnt) {\n\t\terr = mac_ops->mac_get_tx_stats(cgxd, lmac_id, stat, &tx_stat);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_rvu_otx2(rvu))\n\t\t\tseq_printf(s, \"%s: %llu\\n\", cgx_tx_stats_fields[stat],\n\t\t\t\t   tx_stat);\n\t\telse\n\t\t\tseq_printf(s, \"%s: %llu\\n\", rpm_tx_stats_fields[stat],\n\t\t\t\t   tx_stat);\n\t\tstat++;\n\t}\n\n\treturn err;\n}\n\nstatic int rvu_dbg_derive_lmacid(struct seq_file *filp, int *lmac_id)\n{\n\tstruct dentry *current_dir;\n\tchar *buf;\n\n\tcurrent_dir = filp->file->f_path.dentry->d_parent;\n\tbuf = strrchr(current_dir->d_name.name, 'c');\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\treturn kstrtoint(buf + 1, 10, lmac_id);\n}\n\nstatic int rvu_dbg_cgx_stat_display(struct seq_file *filp, void *unused)\n{\n\tint lmac_id, err;\n\n\terr = rvu_dbg_derive_lmacid(filp, &lmac_id);\n\tif (!err)\n\t\treturn cgx_print_stats(filp, lmac_id);\n\n\treturn err;\n}\n\nRVU_DEBUG_SEQ_FOPS(cgx_stat, cgx_stat_display, NULL);\n\nstatic int cgx_print_dmac_flt(struct seq_file *s, int lmac_id)\n{\n\tstruct pci_dev *pdev = NULL;\n\tvoid *cgxd = s->private;\n\tchar *bcast, *mcast;\n\tu16 index, domain;\n\tu8 dmac[ETH_ALEN];\n\tstruct rvu *rvu;\n\tu64 cfg, mac;\n\tint pf;\n\n\trvu = pci_get_drvdata(pci_get_device(PCI_VENDOR_ID_CAVIUM,\n\t\t\t\t\t     PCI_DEVID_OCTEONTX2_RVU_AF, NULL));\n\tif (!rvu)\n\t\treturn -ENODEV;\n\n\tpf = cgxlmac_to_pf(rvu, cgx_get_cgxid(cgxd), lmac_id);\n\tdomain = 2;\n\n\tpdev = pci_get_domain_bus_and_slot(domain, pf + 1, 0);\n\tif (!pdev)\n\t\treturn 0;\n\n\tcfg = cgx_read_dmac_ctrl(cgxd, lmac_id);\n\tbcast = cfg & CGX_DMAC_BCAST_MODE ? \"ACCEPT\" : \"REJECT\";\n\tmcast = cfg & CGX_DMAC_MCAST_MODE ? \"ACCEPT\" : \"REJECT\";\n\n\tseq_puts(s,\n\t\t \"PCI dev       RVUPF   BROADCAST  MULTICAST  FILTER-MODE\\n\");\n\tseq_printf(s, \"%s  PF%d  %9s  %9s\",\n\t\t   dev_name(&pdev->dev), pf, bcast, mcast);\n\tif (cfg & CGX_DMAC_CAM_ACCEPT)\n\t\tseq_printf(s, \"%12s\\n\\n\", \"UNICAST\");\n\telse\n\t\tseq_printf(s, \"%16s\\n\\n\", \"PROMISCUOUS\");\n\n\tseq_puts(s, \"\\nDMAC-INDEX  ADDRESS\\n\");\n\n\tfor (index = 0 ; index < 32 ; index++) {\n\t\tcfg = cgx_read_dmac_entry(cgxd, index);\n\t\t \n\t\tif (lmac_id == FIELD_GET(CGX_DMAC_CAM_ENTRY_LMACID, cfg) &&\n\t\t    FIELD_GET(CGX_DMAC_CAM_ADDR_ENABLE, cfg)) {\n\t\t\tmac = FIELD_GET(CGX_RX_DMAC_ADR_MASK, cfg);\n\t\t\tu64_to_ether_addr(mac, dmac);\n\t\t\tseq_printf(s, \"%7d     %pM\\n\", index, dmac);\n\t\t}\n\t}\n\n\tpci_dev_put(pdev);\n\treturn 0;\n}\n\nstatic int rvu_dbg_cgx_dmac_flt_display(struct seq_file *filp, void *unused)\n{\n\tint err, lmac_id;\n\n\terr = rvu_dbg_derive_lmacid(filp, &lmac_id);\n\tif (!err)\n\t\treturn cgx_print_dmac_flt(filp, lmac_id);\n\n\treturn err;\n}\n\nRVU_DEBUG_SEQ_FOPS(cgx_dmac_flt, cgx_dmac_flt_display, NULL);\n\nstatic void rvu_dbg_cgx_init(struct rvu *rvu)\n{\n\tstruct mac_ops *mac_ops;\n\tunsigned long lmac_bmap;\n\tint i, lmac_id;\n\tchar dname[20];\n\tvoid *cgx;\n\n\tif (!cgx_get_cgxcnt_max())\n\t\treturn;\n\n\tmac_ops = get_mac_ops(rvu_first_cgx_pdata(rvu));\n\tif (!mac_ops)\n\t\treturn;\n\n\trvu->rvu_dbg.cgx_root = debugfs_create_dir(mac_ops->name,\n\t\t\t\t\t\t   rvu->rvu_dbg.root);\n\n\tfor (i = 0; i < cgx_get_cgxcnt_max(); i++) {\n\t\tcgx = rvu_cgx_pdata(i, rvu);\n\t\tif (!cgx)\n\t\t\tcontinue;\n\t\tlmac_bmap = cgx_get_lmac_bmap(cgx);\n\t\t \n\t\tsprintf(dname, \"%s%d\", mac_ops->name, i);\n\t\trvu->rvu_dbg.cgx = debugfs_create_dir(dname,\n\t\t\t\t\t\t      rvu->rvu_dbg.cgx_root);\n\n\t\tfor_each_set_bit(lmac_id, &lmac_bmap, rvu->hw->lmac_per_cgx) {\n\t\t\t \n\t\t\tsprintf(dname, \"lmac%d\", lmac_id);\n\t\t\trvu->rvu_dbg.lmac =\n\t\t\t\tdebugfs_create_dir(dname, rvu->rvu_dbg.cgx);\n\n\t\t\tdebugfs_create_file(\"stats\", 0600, rvu->rvu_dbg.lmac,\n\t\t\t\t\t    cgx, &rvu_dbg_cgx_stat_fops);\n\t\t\tdebugfs_create_file(\"mac_filter\", 0600,\n\t\t\t\t\t    rvu->rvu_dbg.lmac, cgx,\n\t\t\t\t\t    &rvu_dbg_cgx_dmac_flt_fops);\n\t\t}\n\t}\n}\n\n \nstatic void rvu_print_npc_mcam_info(struct seq_file *s,\n\t\t\t\t    u16 pcifunc, int blkaddr)\n{\n\tstruct rvu *rvu = s->private;\n\tint entry_acnt, entry_ecnt;\n\tint cntr_acnt, cntr_ecnt;\n\n\trvu_npc_get_mcam_entry_alloc_info(rvu, pcifunc, blkaddr,\n\t\t\t\t\t  &entry_acnt, &entry_ecnt);\n\trvu_npc_get_mcam_counter_alloc_info(rvu, pcifunc, blkaddr,\n\t\t\t\t\t    &cntr_acnt, &cntr_ecnt);\n\tif (!entry_acnt && !cntr_acnt)\n\t\treturn;\n\n\tif (!(pcifunc & RVU_PFVF_FUNC_MASK))\n\t\tseq_printf(s, \"\\n\\t\\t Device \\t\\t: PF%d\\n\",\n\t\t\t   rvu_get_pf(pcifunc));\n\telse\n\t\tseq_printf(s, \"\\n\\t\\t Device \\t\\t: PF%d VF%d\\n\",\n\t\t\t   rvu_get_pf(pcifunc),\n\t\t\t   (pcifunc & RVU_PFVF_FUNC_MASK) - 1);\n\n\tif (entry_acnt) {\n\t\tseq_printf(s, \"\\t\\t Entries allocated \\t: %d\\n\", entry_acnt);\n\t\tseq_printf(s, \"\\t\\t Entries enabled \\t: %d\\n\", entry_ecnt);\n\t}\n\tif (cntr_acnt) {\n\t\tseq_printf(s, \"\\t\\t Counters allocated \\t: %d\\n\", cntr_acnt);\n\t\tseq_printf(s, \"\\t\\t Counters enabled \\t: %d\\n\", cntr_ecnt);\n\t}\n}\n\nstatic int rvu_dbg_npc_mcam_info_display(struct seq_file *filp, void *unsued)\n{\n\tstruct rvu *rvu = filp->private;\n\tint pf, vf, numvfs, blkaddr;\n\tstruct npc_mcam *mcam;\n\tu16 pcifunc, counters;\n\tu64 cfg;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn -ENODEV;\n\n\tmcam = &rvu->hw->mcam;\n\tcounters = rvu->hw->npc_counters;\n\n\tseq_puts(filp, \"\\nNPC MCAM info:\\n\");\n\t \n\tcfg = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_RX));\n\tcfg = (cfg >> 32) & 0x07;\n\tseq_printf(filp, \"\\t\\t RX keywidth \\t: %s\\n\", (cfg == NPC_MCAM_KEY_X1) ?\n\t\t   \"112bits\" : ((cfg == NPC_MCAM_KEY_X2) ?\n\t\t   \"224bits\" : \"448bits\"));\n\tcfg = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(NIX_INTF_TX));\n\tcfg = (cfg >> 32) & 0x07;\n\tseq_printf(filp, \"\\t\\t TX keywidth \\t: %s\\n\", (cfg == NPC_MCAM_KEY_X1) ?\n\t\t   \"112bits\" : ((cfg == NPC_MCAM_KEY_X2) ?\n\t\t   \"224bits\" : \"448bits\"));\n\n\tmutex_lock(&mcam->lock);\n\t \n\tseq_printf(filp, \"\\n\\t\\t MCAM entries \\t: %d\\n\", mcam->total_entries);\n\tseq_printf(filp, \"\\t\\t Reserved \\t: %d\\n\",\n\t\t   mcam->total_entries - mcam->bmap_entries);\n\tseq_printf(filp, \"\\t\\t Available \\t: %d\\n\", mcam->bmap_fcnt);\n\n\t \n\tseq_printf(filp, \"\\n\\t\\t MCAM counters \\t: %d\\n\", counters);\n\tseq_printf(filp, \"\\t\\t Reserved \\t: %d\\n\",\n\t\t   counters - mcam->counters.max);\n\tseq_printf(filp, \"\\t\\t Available \\t: %d\\n\",\n\t\t   rvu_rsrc_free_count(&mcam->counters));\n\n\tif (mcam->bmap_entries == mcam->bmap_fcnt) {\n\t\tmutex_unlock(&mcam->lock);\n\t\treturn 0;\n\t}\n\n\tseq_puts(filp, \"\\n\\t\\t Current allocation\\n\");\n\tseq_puts(filp, \"\\t\\t====================\\n\");\n\tfor (pf = 0; pf < rvu->hw->total_pfs; pf++) {\n\t\tpcifunc = (pf << RVU_PFVF_PF_SHIFT);\n\t\trvu_print_npc_mcam_info(filp, pcifunc, blkaddr);\n\n\t\tcfg = rvu_read64(rvu, BLKADDR_RVUM, RVU_PRIV_PFX_CFG(pf));\n\t\tnumvfs = (cfg >> 12) & 0xFF;\n\t\tfor (vf = 0; vf < numvfs; vf++) {\n\t\t\tpcifunc = (pf << RVU_PFVF_PF_SHIFT) | (vf + 1);\n\t\t\trvu_print_npc_mcam_info(filp, pcifunc, blkaddr);\n\t\t}\n\t}\n\n\tmutex_unlock(&mcam->lock);\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(npc_mcam_info, npc_mcam_info_display, NULL);\n\nstatic int rvu_dbg_npc_rx_miss_stats_display(struct seq_file *filp,\n\t\t\t\t\t     void *unused)\n{\n\tstruct rvu *rvu = filp->private;\n\tstruct npc_mcam *mcam;\n\tint blkaddr;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn -ENODEV;\n\n\tmcam = &rvu->hw->mcam;\n\n\tseq_puts(filp, \"\\nNPC MCAM RX miss action stats\\n\");\n\tseq_printf(filp, \"\\t\\tStat %d: \\t%lld\\n\", mcam->rx_miss_act_cntr,\n\t\t   rvu_read64(rvu, blkaddr,\n\t\t\t      NPC_AF_MATCH_STATX(mcam->rx_miss_act_cntr)));\n\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(npc_rx_miss_act, npc_rx_miss_stats_display, NULL);\n\nstatic void rvu_dbg_npc_mcam_show_flows(struct seq_file *s,\n\t\t\t\t\tstruct rvu_npc_mcam_rule *rule)\n{\n\tu8 bit;\n\n\tfor_each_set_bit(bit, (unsigned long *)&rule->features, 64) {\n\t\tseq_printf(s, \"\\t%s  \", npc_get_field_name(bit));\n\t\tswitch (bit) {\n\t\tcase NPC_LXMB:\n\t\t\tif (rule->lxmb == 1)\n\t\t\t\tseq_puts(s, \"\\tL2M nibble is set\\n\");\n\t\t\telse\n\t\t\t\tseq_puts(s, \"\\tL2B nibble is set\\n\");\n\t\t\tbreak;\n\t\tcase NPC_DMAC:\n\t\t\tseq_printf(s, \"%pM \", rule->packet.dmac);\n\t\t\tseq_printf(s, \"mask %pM\\n\", rule->mask.dmac);\n\t\t\tbreak;\n\t\tcase NPC_SMAC:\n\t\t\tseq_printf(s, \"%pM \", rule->packet.smac);\n\t\t\tseq_printf(s, \"mask %pM\\n\", rule->mask.smac);\n\t\t\tbreak;\n\t\tcase NPC_ETYPE:\n\t\t\tseq_printf(s, \"0x%x \", ntohs(rule->packet.etype));\n\t\t\tseq_printf(s, \"mask 0x%x\\n\", ntohs(rule->mask.etype));\n\t\t\tbreak;\n\t\tcase NPC_OUTER_VID:\n\t\t\tseq_printf(s, \"0x%x \", ntohs(rule->packet.vlan_tci));\n\t\t\tseq_printf(s, \"mask 0x%x\\n\",\n\t\t\t\t   ntohs(rule->mask.vlan_tci));\n\t\t\tbreak;\n\t\tcase NPC_INNER_VID:\n\t\t\tseq_printf(s, \"0x%x \", ntohs(rule->packet.vlan_itci));\n\t\t\tseq_printf(s, \"mask 0x%x\\n\",\n\t\t\t\t   ntohs(rule->mask.vlan_itci));\n\t\t\tbreak;\n\t\tcase NPC_TOS:\n\t\t\tseq_printf(s, \"%d \", rule->packet.tos);\n\t\t\tseq_printf(s, \"mask 0x%x\\n\", rule->mask.tos);\n\t\t\tbreak;\n\t\tcase NPC_SIP_IPV4:\n\t\t\tseq_printf(s, \"%pI4 \", &rule->packet.ip4src);\n\t\t\tseq_printf(s, \"mask %pI4\\n\", &rule->mask.ip4src);\n\t\t\tbreak;\n\t\tcase NPC_DIP_IPV4:\n\t\t\tseq_printf(s, \"%pI4 \", &rule->packet.ip4dst);\n\t\t\tseq_printf(s, \"mask %pI4\\n\", &rule->mask.ip4dst);\n\t\t\tbreak;\n\t\tcase NPC_SIP_IPV6:\n\t\t\tseq_printf(s, \"%pI6 \", rule->packet.ip6src);\n\t\t\tseq_printf(s, \"mask %pI6\\n\", rule->mask.ip6src);\n\t\t\tbreak;\n\t\tcase NPC_DIP_IPV6:\n\t\t\tseq_printf(s, \"%pI6 \", rule->packet.ip6dst);\n\t\t\tseq_printf(s, \"mask %pI6\\n\", rule->mask.ip6dst);\n\t\t\tbreak;\n\t\tcase NPC_IPFRAG_IPV6:\n\t\t\tseq_printf(s, \"0x%x \", rule->packet.next_header);\n\t\t\tseq_printf(s, \"mask 0x%x\\n\", rule->mask.next_header);\n\t\t\tbreak;\n\t\tcase NPC_IPFRAG_IPV4:\n\t\t\tseq_printf(s, \"0x%x \", rule->packet.ip_flag);\n\t\t\tseq_printf(s, \"mask 0x%x\\n\", rule->mask.ip_flag);\n\t\t\tbreak;\n\t\tcase NPC_SPORT_TCP:\n\t\tcase NPC_SPORT_UDP:\n\t\tcase NPC_SPORT_SCTP:\n\t\t\tseq_printf(s, \"%d \", ntohs(rule->packet.sport));\n\t\t\tseq_printf(s, \"mask 0x%x\\n\", ntohs(rule->mask.sport));\n\t\t\tbreak;\n\t\tcase NPC_DPORT_TCP:\n\t\tcase NPC_DPORT_UDP:\n\t\tcase NPC_DPORT_SCTP:\n\t\t\tseq_printf(s, \"%d \", ntohs(rule->packet.dport));\n\t\t\tseq_printf(s, \"mask 0x%x\\n\", ntohs(rule->mask.dport));\n\t\t\tbreak;\n\t\tcase NPC_IPSEC_SPI:\n\t\t\tseq_printf(s, \"0x%x \", ntohl(rule->packet.spi));\n\t\t\tseq_printf(s, \"mask 0x%x\\n\", ntohl(rule->mask.spi));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_puts(s, \"\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void rvu_dbg_npc_mcam_show_action(struct seq_file *s,\n\t\t\t\t\t struct rvu_npc_mcam_rule *rule)\n{\n\tif (is_npc_intf_tx(rule->intf)) {\n\t\tswitch (rule->tx_action.op) {\n\t\tcase NIX_TX_ACTIONOP_DROP:\n\t\t\tseq_puts(s, \"\\taction: Drop\\n\");\n\t\t\tbreak;\n\t\tcase NIX_TX_ACTIONOP_UCAST_DEFAULT:\n\t\t\tseq_puts(s, \"\\taction: Unicast to default channel\\n\");\n\t\t\tbreak;\n\t\tcase NIX_TX_ACTIONOP_UCAST_CHAN:\n\t\t\tseq_printf(s, \"\\taction: Unicast to channel %d\\n\",\n\t\t\t\t   rule->tx_action.index);\n\t\t\tbreak;\n\t\tcase NIX_TX_ACTIONOP_MCAST:\n\t\t\tseq_puts(s, \"\\taction: Multicast\\n\");\n\t\t\tbreak;\n\t\tcase NIX_TX_ACTIONOP_DROP_VIOL:\n\t\t\tseq_puts(s, \"\\taction: Lockdown Violation Drop\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (rule->rx_action.op) {\n\t\tcase NIX_RX_ACTIONOP_DROP:\n\t\t\tseq_puts(s, \"\\taction: Drop\\n\");\n\t\t\tbreak;\n\t\tcase NIX_RX_ACTIONOP_UCAST:\n\t\t\tseq_printf(s, \"\\taction: Direct to queue %d\\n\",\n\t\t\t\t   rule->rx_action.index);\n\t\t\tbreak;\n\t\tcase NIX_RX_ACTIONOP_RSS:\n\t\t\tseq_puts(s, \"\\taction: RSS\\n\");\n\t\t\tbreak;\n\t\tcase NIX_RX_ACTIONOP_UCAST_IPSEC:\n\t\t\tseq_puts(s, \"\\taction: Unicast ipsec\\n\");\n\t\t\tbreak;\n\t\tcase NIX_RX_ACTIONOP_MCAST:\n\t\t\tseq_puts(s, \"\\taction: Multicast\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic const char *rvu_dbg_get_intf_name(int intf)\n{\n\tswitch (intf) {\n\tcase NIX_INTFX_RX(0):\n\t\treturn \"NIX0_RX\";\n\tcase NIX_INTFX_RX(1):\n\t\treturn \"NIX1_RX\";\n\tcase NIX_INTFX_TX(0):\n\t\treturn \"NIX0_TX\";\n\tcase NIX_INTFX_TX(1):\n\t\treturn \"NIX1_TX\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"unknown\";\n}\n\nstatic int rvu_dbg_npc_mcam_show_rules(struct seq_file *s, void *unused)\n{\n\tstruct rvu_npc_mcam_rule *iter;\n\tstruct rvu *rvu = s->private;\n\tstruct npc_mcam *mcam;\n\tint pf, vf = -1;\n\tbool enabled;\n\tint blkaddr;\n\tu16 target;\n\tu64 hits;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn 0;\n\n\tmcam = &rvu->hw->mcam;\n\n\tmutex_lock(&mcam->lock);\n\tlist_for_each_entry(iter, &mcam->mcam_rules, list) {\n\t\tpf = (iter->owner >> RVU_PFVF_PF_SHIFT) & RVU_PFVF_PF_MASK;\n\t\tseq_printf(s, \"\\n\\tInstalled by: PF%d \", pf);\n\n\t\tif (iter->owner & RVU_PFVF_FUNC_MASK) {\n\t\t\tvf = (iter->owner & RVU_PFVF_FUNC_MASK) - 1;\n\t\t\tseq_printf(s, \"VF%d\", vf);\n\t\t}\n\t\tseq_puts(s, \"\\n\");\n\n\t\tseq_printf(s, \"\\tdirection: %s\\n\", is_npc_intf_rx(iter->intf) ?\n\t\t\t\t\t\t    \"RX\" : \"TX\");\n\t\tseq_printf(s, \"\\tinterface: %s\\n\",\n\t\t\t   rvu_dbg_get_intf_name(iter->intf));\n\t\tseq_printf(s, \"\\tmcam entry: %d\\n\", iter->entry);\n\n\t\trvu_dbg_npc_mcam_show_flows(s, iter);\n\t\tif (is_npc_intf_rx(iter->intf)) {\n\t\t\ttarget = iter->rx_action.pf_func;\n\t\t\tpf = (target >> RVU_PFVF_PF_SHIFT) & RVU_PFVF_PF_MASK;\n\t\t\tseq_printf(s, \"\\tForward to: PF%d \", pf);\n\n\t\t\tif (target & RVU_PFVF_FUNC_MASK) {\n\t\t\t\tvf = (target & RVU_PFVF_FUNC_MASK) - 1;\n\t\t\t\tseq_printf(s, \"VF%d\", vf);\n\t\t\t}\n\t\t\tseq_puts(s, \"\\n\");\n\t\t\tseq_printf(s, \"\\tchannel: 0x%x\\n\", iter->chan);\n\t\t\tseq_printf(s, \"\\tchannel_mask: 0x%x\\n\", iter->chan_mask);\n\t\t}\n\n\t\trvu_dbg_npc_mcam_show_action(s, iter);\n\n\t\tenabled = is_mcam_entry_enabled(rvu, mcam, blkaddr, iter->entry);\n\t\tseq_printf(s, \"\\tenabled: %s\\n\", enabled ? \"yes\" : \"no\");\n\n\t\tif (!iter->has_cntr)\n\t\t\tcontinue;\n\t\tseq_printf(s, \"\\tcounter: %d\\n\", iter->cntr);\n\n\t\thits = rvu_read64(rvu, blkaddr, NPC_AF_MATCH_STATX(iter->cntr));\n\t\tseq_printf(s, \"\\thits: %lld\\n\", hits);\n\t}\n\tmutex_unlock(&mcam->lock);\n\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(npc_mcam_rules, npc_mcam_show_rules, NULL);\n\nstatic int rvu_dbg_npc_exact_show_entries(struct seq_file *s, void *unused)\n{\n\tstruct npc_exact_table_entry *mem_entry[NPC_EXACT_TBL_MAX_WAYS] = { 0 };\n\tstruct npc_exact_table_entry *cam_entry;\n\tstruct npc_exact_table *table;\n\tstruct rvu *rvu = s->private;\n\tint i, j;\n\n\tu8 bitmap = 0;\n\n\ttable = rvu->hw->table;\n\n\tmutex_lock(&table->lock);\n\n\t \n\tif (!table->mem_tbl_entry_cnt)\n\t\tgoto dump_cam_table;\n\n\t \n\tseq_puts(s, \"\\n\\tExact Match MEM Table\\n\");\n\tseq_puts(s, \"Index\\t\");\n\n\tfor (i = 0; i < table->mem_table.ways; i++) {\n\t\tmem_entry[i] = list_first_entry_or_null(&table->lhead_mem_tbl_entry[i],\n\t\t\t\t\t\t\tstruct npc_exact_table_entry, list);\n\n\t\tseq_printf(s, \"Way-%d\\t\\t\\t\\t\\t\", i);\n\t}\n\n\tseq_puts(s, \"\\n\");\n\tfor (i = 0; i < table->mem_table.ways; i++)\n\t\tseq_puts(s, \"\\tChan  MAC                     \\t\");\n\n\tseq_puts(s, \"\\n\\n\");\n\n\t \n\tfor (i = 0; i < table->mem_table.depth; i++) {\n\t\tbitmap = 0;\n\t\tfor (j = 0; j < table->mem_table.ways; j++) {\n\t\t\tif (!mem_entry[j])\n\t\t\t\tcontinue;\n\n\t\t\tif (mem_entry[j]->index != i)\n\t\t\t\tcontinue;\n\n\t\t\tbitmap |= BIT(j);\n\t\t}\n\n\t\t \n\t\tif (!bitmap)\n\t\t\tcontinue;\n\n\t\tseq_printf(s, \"%d\\t\", i);\n\t\tfor (j = 0; j < table->mem_table.ways; j++) {\n\t\t\tif (!(bitmap & BIT(j))) {\n\t\t\t\tseq_puts(s, \"nil\\t\\t\\t\\t\\t\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tseq_printf(s, \"0x%x %pM\\t\\t\\t\", mem_entry[j]->chan,\n\t\t\t\t   mem_entry[j]->mac);\n\t\t\tmem_entry[j] = list_next_entry(mem_entry[j], list);\n\t\t}\n\t\tseq_puts(s, \"\\n\");\n\t}\n\ndump_cam_table:\n\n\tif (!table->cam_tbl_entry_cnt)\n\t\tgoto done;\n\n\tseq_puts(s, \"\\n\\tExact Match CAM Table\\n\");\n\tseq_puts(s, \"index\\tchan\\tMAC\\n\");\n\n\t \n\tlist_for_each_entry(cam_entry, &table->lhead_cam_tbl_entry, list) {\n\t\tseq_printf(s, \"%d\\t0x%x\\t%pM\\n\", cam_entry->index, cam_entry->chan,\n\t\t\t   cam_entry->mac);\n\t}\n\ndone:\n\tmutex_unlock(&table->lock);\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(npc_exact_entries, npc_exact_show_entries, NULL);\n\nstatic int rvu_dbg_npc_exact_show_info(struct seq_file *s, void *unused)\n{\n\tstruct npc_exact_table *table;\n\tstruct rvu *rvu = s->private;\n\tint i;\n\n\ttable = rvu->hw->table;\n\n\tseq_puts(s, \"\\n\\tExact Table Info\\n\");\n\tseq_printf(s, \"Exact Match Feature : %s\\n\",\n\t\t   rvu->hw->cap.npc_exact_match_enabled ? \"enabled\" : \"disable\");\n\tif (!rvu->hw->cap.npc_exact_match_enabled)\n\t\treturn 0;\n\n\tseq_puts(s, \"\\nMCAM Index\\tMAC Filter Rules Count\\n\");\n\tfor (i = 0; i < table->num_drop_rules; i++)\n\t\tseq_printf(s, \"%d\\t\\t%d\\n\", i, table->cnt_cmd_rules[i]);\n\n\tseq_puts(s, \"\\nMcam Index\\tPromisc Mode Status\\n\");\n\tfor (i = 0; i < table->num_drop_rules; i++)\n\t\tseq_printf(s, \"%d\\t\\t%s\\n\", i, table->promisc_mode[i] ? \"on\" : \"off\");\n\n\tseq_puts(s, \"\\n\\tMEM Table Info\\n\");\n\tseq_printf(s, \"Ways : %d\\n\", table->mem_table.ways);\n\tseq_printf(s, \"Depth : %d\\n\", table->mem_table.depth);\n\tseq_printf(s, \"Mask : 0x%llx\\n\", table->mem_table.mask);\n\tseq_printf(s, \"Hash Mask : 0x%x\\n\", table->mem_table.hash_mask);\n\tseq_printf(s, \"Hash Offset : 0x%x\\n\", table->mem_table.hash_offset);\n\n\tseq_puts(s, \"\\n\\tCAM Table Info\\n\");\n\tseq_printf(s, \"Depth : %d\\n\", table->cam_table.depth);\n\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(npc_exact_info, npc_exact_show_info, NULL);\n\nstatic int rvu_dbg_npc_exact_drop_cnt(struct seq_file *s, void *unused)\n{\n\tstruct npc_exact_table *table;\n\tstruct rvu *rvu = s->private;\n\tstruct npc_key_field *field;\n\tu16 chan, pcifunc;\n\tint blkaddr, i;\n\tu64 cfg, cam1;\n\tchar *str;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\ttable = rvu->hw->table;\n\n\tfield = &rvu->hw->mcam.rx_key_fields[NPC_CHAN];\n\n\tseq_puts(s, \"\\n\\t Exact Hit on drop status\\n\");\n\tseq_puts(s, \"\\npcifunc\\tmcam_idx\\tHits\\tchan\\tstatus\\n\");\n\n\tfor (i = 0; i < table->num_drop_rules; i++) {\n\t\tpcifunc = rvu_npc_exact_drop_rule_to_pcifunc(rvu, i);\n\t\tcfg = rvu_read64(rvu, blkaddr, NPC_AF_MCAMEX_BANKX_CFG(i, 0));\n\n\t\t \n\t\tcam1 = rvu_read64(rvu, blkaddr,\n\t\t\t\t  NPC_AF_MCAMEX_BANKX_CAMX_W0(i, 0, 1));\n\t\tchan = field->kw_mask[0] & cam1;\n\n\t\tstr = (cfg & 1) ? \"enabled\" : \"disabled\";\n\n\t\tseq_printf(s, \"0x%x\\t%d\\t\\t%llu\\t0x%x\\t%s\\n\", pcifunc, i,\n\t\t\t   rvu_read64(rvu, blkaddr,\n\t\t\t\t      NPC_AF_MATCH_STATX(table->counter_idx[i])),\n\t\t\t   chan, str);\n\t}\n\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(npc_exact_drop_cnt, npc_exact_drop_cnt, NULL);\n\nstatic void rvu_dbg_npc_init(struct rvu *rvu)\n{\n\trvu->rvu_dbg.npc = debugfs_create_dir(\"npc\", rvu->rvu_dbg.root);\n\n\tdebugfs_create_file(\"mcam_info\", 0444, rvu->rvu_dbg.npc, rvu,\n\t\t\t    &rvu_dbg_npc_mcam_info_fops);\n\tdebugfs_create_file(\"mcam_rules\", 0444, rvu->rvu_dbg.npc, rvu,\n\t\t\t    &rvu_dbg_npc_mcam_rules_fops);\n\n\tdebugfs_create_file(\"rx_miss_act_stats\", 0444, rvu->rvu_dbg.npc, rvu,\n\t\t\t    &rvu_dbg_npc_rx_miss_act_fops);\n\n\tif (!rvu->hw->cap.npc_exact_match_enabled)\n\t\treturn;\n\n\tdebugfs_create_file(\"exact_entries\", 0444, rvu->rvu_dbg.npc, rvu,\n\t\t\t    &rvu_dbg_npc_exact_entries_fops);\n\n\tdebugfs_create_file(\"exact_info\", 0444, rvu->rvu_dbg.npc, rvu,\n\t\t\t    &rvu_dbg_npc_exact_info_fops);\n\n\tdebugfs_create_file(\"exact_drop_cnt\", 0444, rvu->rvu_dbg.npc, rvu,\n\t\t\t    &rvu_dbg_npc_exact_drop_cnt_fops);\n\n}\n\nstatic int cpt_eng_sts_display(struct seq_file *filp, u8 eng_type)\n{\n\tstruct cpt_ctx *ctx = filp->private;\n\tu64 busy_sts = 0, free_sts = 0;\n\tu32 e_min = 0, e_max = 0, e, i;\n\tu16 max_ses, max_ies, max_aes;\n\tstruct rvu *rvu = ctx->rvu;\n\tint blkaddr = ctx->blkaddr;\n\tu64 reg;\n\n\treg = rvu_read64(rvu, blkaddr, CPT_AF_CONSTANTS1);\n\tmax_ses = reg & 0xffff;\n\tmax_ies = (reg >> 16) & 0xffff;\n\tmax_aes = (reg >> 32) & 0xffff;\n\n\tswitch (eng_type) {\n\tcase CPT_AE_TYPE:\n\t\te_min = max_ses + max_ies;\n\t\te_max = max_ses + max_ies + max_aes;\n\t\tbreak;\n\tcase CPT_SE_TYPE:\n\t\te_min = 0;\n\t\te_max = max_ses;\n\t\tbreak;\n\tcase CPT_IE_TYPE:\n\t\te_min = max_ses;\n\t\te_max = max_ses + max_ies;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (e = e_min, i = 0; e < e_max; e++, i++) {\n\t\treg = rvu_read64(rvu, blkaddr, CPT_AF_EXEX_STS(e));\n\t\tif (reg & 0x1)\n\t\t\tbusy_sts |= 1ULL << i;\n\n\t\tif (reg & 0x2)\n\t\t\tfree_sts |= 1ULL << i;\n\t}\n\tseq_printf(filp, \"FREE STS : 0x%016llx\\n\", free_sts);\n\tseq_printf(filp, \"BUSY STS : 0x%016llx\\n\", busy_sts);\n\n\treturn 0;\n}\n\nstatic int rvu_dbg_cpt_ae_sts_display(struct seq_file *filp, void *unused)\n{\n\treturn cpt_eng_sts_display(filp, CPT_AE_TYPE);\n}\n\nRVU_DEBUG_SEQ_FOPS(cpt_ae_sts, cpt_ae_sts_display, NULL);\n\nstatic int rvu_dbg_cpt_se_sts_display(struct seq_file *filp, void *unused)\n{\n\treturn cpt_eng_sts_display(filp, CPT_SE_TYPE);\n}\n\nRVU_DEBUG_SEQ_FOPS(cpt_se_sts, cpt_se_sts_display, NULL);\n\nstatic int rvu_dbg_cpt_ie_sts_display(struct seq_file *filp, void *unused)\n{\n\treturn cpt_eng_sts_display(filp, CPT_IE_TYPE);\n}\n\nRVU_DEBUG_SEQ_FOPS(cpt_ie_sts, cpt_ie_sts_display, NULL);\n\nstatic int rvu_dbg_cpt_engines_info_display(struct seq_file *filp, void *unused)\n{\n\tstruct cpt_ctx *ctx = filp->private;\n\tu16 max_ses, max_ies, max_aes;\n\tstruct rvu *rvu = ctx->rvu;\n\tint blkaddr = ctx->blkaddr;\n\tu32 e_max, e;\n\tu64 reg;\n\n\treg = rvu_read64(rvu, blkaddr, CPT_AF_CONSTANTS1);\n\tmax_ses = reg & 0xffff;\n\tmax_ies = (reg >> 16) & 0xffff;\n\tmax_aes = (reg >> 32) & 0xffff;\n\n\te_max = max_ses + max_ies + max_aes;\n\n\tseq_puts(filp, \"===========================================\\n\");\n\tfor (e = 0; e < e_max; e++) {\n\t\treg = rvu_read64(rvu, blkaddr, CPT_AF_EXEX_CTL2(e));\n\t\tseq_printf(filp, \"CPT Engine[%u] Group Enable   0x%02llx\\n\", e,\n\t\t\t   reg & 0xff);\n\t\treg = rvu_read64(rvu, blkaddr, CPT_AF_EXEX_ACTIVE(e));\n\t\tseq_printf(filp, \"CPT Engine[%u] Active Info    0x%llx\\n\", e,\n\t\t\t   reg);\n\t\treg = rvu_read64(rvu, blkaddr, CPT_AF_EXEX_CTL(e));\n\t\tseq_printf(filp, \"CPT Engine[%u] Control        0x%llx\\n\", e,\n\t\t\t   reg);\n\t\tseq_puts(filp, \"===========================================\\n\");\n\t}\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(cpt_engines_info, cpt_engines_info_display, NULL);\n\nstatic int rvu_dbg_cpt_lfs_info_display(struct seq_file *filp, void *unused)\n{\n\tstruct cpt_ctx *ctx = filp->private;\n\tint blkaddr = ctx->blkaddr;\n\tstruct rvu *rvu = ctx->rvu;\n\tstruct rvu_block *block;\n\tstruct rvu_hwinfo *hw;\n\tu64 reg;\n\tu32 lf;\n\n\thw = rvu->hw;\n\tblock = &hw->block[blkaddr];\n\tif (!block->lf.bmap)\n\t\treturn -ENODEV;\n\n\tseq_puts(filp, \"===========================================\\n\");\n\tfor (lf = 0; lf < block->lf.max; lf++) {\n\t\treg = rvu_read64(rvu, blkaddr, CPT_AF_LFX_CTL(lf));\n\t\tseq_printf(filp, \"CPT Lf[%u] CTL          0x%llx\\n\", lf, reg);\n\t\treg = rvu_read64(rvu, blkaddr, CPT_AF_LFX_CTL2(lf));\n\t\tseq_printf(filp, \"CPT Lf[%u] CTL2         0x%llx\\n\", lf, reg);\n\t\treg = rvu_read64(rvu, blkaddr, CPT_AF_LFX_PTR_CTL(lf));\n\t\tseq_printf(filp, \"CPT Lf[%u] PTR_CTL      0x%llx\\n\", lf, reg);\n\t\treg = rvu_read64(rvu, blkaddr, block->lfcfg_reg |\n\t\t\t\t(lf << block->lfshift));\n\t\tseq_printf(filp, \"CPT Lf[%u] CFG          0x%llx\\n\", lf, reg);\n\t\tseq_puts(filp, \"===========================================\\n\");\n\t}\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(cpt_lfs_info, cpt_lfs_info_display, NULL);\n\nstatic int rvu_dbg_cpt_err_info_display(struct seq_file *filp, void *unused)\n{\n\tstruct cpt_ctx *ctx = filp->private;\n\tstruct rvu *rvu = ctx->rvu;\n\tint blkaddr = ctx->blkaddr;\n\tu64 reg0, reg1;\n\n\treg0 = rvu_read64(rvu, blkaddr, CPT_AF_FLTX_INT(0));\n\treg1 = rvu_read64(rvu, blkaddr, CPT_AF_FLTX_INT(1));\n\tseq_printf(filp, \"CPT_AF_FLTX_INT:       0x%llx 0x%llx\\n\", reg0, reg1);\n\treg0 = rvu_read64(rvu, blkaddr, CPT_AF_PSNX_EXE(0));\n\treg1 = rvu_read64(rvu, blkaddr, CPT_AF_PSNX_EXE(1));\n\tseq_printf(filp, \"CPT_AF_PSNX_EXE:       0x%llx 0x%llx\\n\", reg0, reg1);\n\treg0 = rvu_read64(rvu, blkaddr, CPT_AF_PSNX_LF(0));\n\tseq_printf(filp, \"CPT_AF_PSNX_LF:        0x%llx\\n\", reg0);\n\treg0 = rvu_read64(rvu, blkaddr, CPT_AF_RVU_INT);\n\tseq_printf(filp, \"CPT_AF_RVU_INT:        0x%llx\\n\", reg0);\n\treg0 = rvu_read64(rvu, blkaddr, CPT_AF_RAS_INT);\n\tseq_printf(filp, \"CPT_AF_RAS_INT:        0x%llx\\n\", reg0);\n\treg0 = rvu_read64(rvu, blkaddr, CPT_AF_EXE_ERR_INFO);\n\tseq_printf(filp, \"CPT_AF_EXE_ERR_INFO:   0x%llx\\n\", reg0);\n\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(cpt_err_info, cpt_err_info_display, NULL);\n\nstatic int rvu_dbg_cpt_pc_display(struct seq_file *filp, void *unused)\n{\n\tstruct cpt_ctx *ctx = filp->private;\n\tstruct rvu *rvu = ctx->rvu;\n\tint blkaddr = ctx->blkaddr;\n\tu64 reg;\n\n\treg = rvu_read64(rvu, blkaddr, CPT_AF_INST_REQ_PC);\n\tseq_printf(filp, \"CPT instruction requests   %llu\\n\", reg);\n\treg = rvu_read64(rvu, blkaddr, CPT_AF_INST_LATENCY_PC);\n\tseq_printf(filp, \"CPT instruction latency    %llu\\n\", reg);\n\treg = rvu_read64(rvu, blkaddr, CPT_AF_RD_REQ_PC);\n\tseq_printf(filp, \"CPT NCB read requests      %llu\\n\", reg);\n\treg = rvu_read64(rvu, blkaddr, CPT_AF_RD_LATENCY_PC);\n\tseq_printf(filp, \"CPT NCB read latency       %llu\\n\", reg);\n\treg = rvu_read64(rvu, blkaddr, CPT_AF_RD_UC_PC);\n\tseq_printf(filp, \"CPT read requests caused by UC fills   %llu\\n\", reg);\n\treg = rvu_read64(rvu, blkaddr, CPT_AF_ACTIVE_CYCLES_PC);\n\tseq_printf(filp, \"CPT active cycles pc       %llu\\n\", reg);\n\treg = rvu_read64(rvu, blkaddr, CPT_AF_CPTCLK_CNT);\n\tseq_printf(filp, \"CPT clock count pc         %llu\\n\", reg);\n\n\treturn 0;\n}\n\nRVU_DEBUG_SEQ_FOPS(cpt_pc, cpt_pc_display, NULL);\n\nstatic void rvu_dbg_cpt_init(struct rvu *rvu, int blkaddr)\n{\n\tstruct cpt_ctx *ctx;\n\n\tif (!is_block_implemented(rvu->hw, blkaddr))\n\t\treturn;\n\n\tif (blkaddr == BLKADDR_CPT0) {\n\t\trvu->rvu_dbg.cpt = debugfs_create_dir(\"cpt\", rvu->rvu_dbg.root);\n\t\tctx = &rvu->rvu_dbg.cpt_ctx[0];\n\t\tctx->blkaddr = BLKADDR_CPT0;\n\t\tctx->rvu = rvu;\n\t} else {\n\t\trvu->rvu_dbg.cpt = debugfs_create_dir(\"cpt1\",\n\t\t\t\t\t\t      rvu->rvu_dbg.root);\n\t\tctx = &rvu->rvu_dbg.cpt_ctx[1];\n\t\tctx->blkaddr = BLKADDR_CPT1;\n\t\tctx->rvu = rvu;\n\t}\n\n\tdebugfs_create_file(\"cpt_pc\", 0600, rvu->rvu_dbg.cpt, ctx,\n\t\t\t    &rvu_dbg_cpt_pc_fops);\n\tdebugfs_create_file(\"cpt_ae_sts\", 0600, rvu->rvu_dbg.cpt, ctx,\n\t\t\t    &rvu_dbg_cpt_ae_sts_fops);\n\tdebugfs_create_file(\"cpt_se_sts\", 0600, rvu->rvu_dbg.cpt, ctx,\n\t\t\t    &rvu_dbg_cpt_se_sts_fops);\n\tdebugfs_create_file(\"cpt_ie_sts\", 0600, rvu->rvu_dbg.cpt, ctx,\n\t\t\t    &rvu_dbg_cpt_ie_sts_fops);\n\tdebugfs_create_file(\"cpt_engines_info\", 0600, rvu->rvu_dbg.cpt, ctx,\n\t\t\t    &rvu_dbg_cpt_engines_info_fops);\n\tdebugfs_create_file(\"cpt_lfs_info\", 0600, rvu->rvu_dbg.cpt, ctx,\n\t\t\t    &rvu_dbg_cpt_lfs_info_fops);\n\tdebugfs_create_file(\"cpt_err_info\", 0600, rvu->rvu_dbg.cpt, ctx,\n\t\t\t    &rvu_dbg_cpt_err_info_fops);\n}\n\nstatic const char *rvu_get_dbg_dir_name(struct rvu *rvu)\n{\n\tif (!is_rvu_otx2(rvu))\n\t\treturn \"cn10k\";\n\telse\n\t\treturn \"octeontx2\";\n}\n\nvoid rvu_dbg_init(struct rvu *rvu)\n{\n\trvu->rvu_dbg.root = debugfs_create_dir(rvu_get_dbg_dir_name(rvu), NULL);\n\n\tdebugfs_create_file(\"rsrc_alloc\", 0444, rvu->rvu_dbg.root, rvu,\n\t\t\t    &rvu_dbg_rsrc_status_fops);\n\n\tif (!is_rvu_otx2(rvu))\n\t\tdebugfs_create_file(\"lmtst_map_table\", 0444, rvu->rvu_dbg.root,\n\t\t\t\t    rvu, &rvu_dbg_lmtst_map_table_fops);\n\n\tif (!cgx_get_cgxcnt_max())\n\t\tgoto create;\n\n\tif (is_rvu_otx2(rvu))\n\t\tdebugfs_create_file(\"rvu_pf_cgx_map\", 0444, rvu->rvu_dbg.root,\n\t\t\t\t    rvu, &rvu_dbg_rvu_pf_cgx_map_fops);\n\telse\n\t\tdebugfs_create_file(\"rvu_pf_rpm_map\", 0444, rvu->rvu_dbg.root,\n\t\t\t\t    rvu, &rvu_dbg_rvu_pf_cgx_map_fops);\n\ncreate:\n\trvu_dbg_npa_init(rvu);\n\trvu_dbg_nix_init(rvu, BLKADDR_NIX0);\n\n\trvu_dbg_nix_init(rvu, BLKADDR_NIX1);\n\trvu_dbg_cgx_init(rvu);\n\trvu_dbg_npc_init(rvu);\n\trvu_dbg_cpt_init(rvu, BLKADDR_CPT0);\n\trvu_dbg_cpt_init(rvu, BLKADDR_CPT1);\n\trvu_dbg_mcs_init(rvu);\n}\n\nvoid rvu_dbg_exit(struct rvu *rvu)\n{\n\tdebugfs_remove_recursive(rvu->rvu_dbg.root);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}