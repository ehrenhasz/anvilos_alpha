{
  "module_name": "rvu_sdp.c",
  "hash_id": "3973ea7e83505b9121201cd6439c7c12e31ad7d775099a85ad8a84b2c62ecf0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/af/rvu_sdp.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include \"rvu.h\"\n\n \n#define PCI_DEVID_OTX2_SDP_PF   0xA0F6\n\n \n#define MAX_SDP\t\t2\n\n \nstatic int sdp_pf_num[MAX_SDP] = {-1, -1};\n\nbool is_sdp_pfvf(u16 pcifunc)\n{\n\tu16 pf = rvu_get_pf(pcifunc);\n\tu32 found = 0, i = 0;\n\n\twhile (i < MAX_SDP) {\n\t\tif (pf == sdp_pf_num[i])\n\t\t\tfound = 1;\n\t\ti++;\n\t}\n\n\tif (!found)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool is_sdp_pf(u16 pcifunc)\n{\n\treturn (is_sdp_pfvf(pcifunc) &&\n\t\t!(pcifunc & RVU_PFVF_FUNC_MASK));\n}\n\nbool is_sdp_vf(u16 pcifunc)\n{\n\treturn (is_sdp_pfvf(pcifunc) &&\n\t\t!!(pcifunc & RVU_PFVF_FUNC_MASK));\n}\n\nint rvu_sdp_init(struct rvu *rvu)\n{\n\tstruct pci_dev *pdev = NULL;\n\tstruct rvu_pfvf *pfvf;\n\tu32 i = 0;\n\n\twhile ((i < MAX_SDP) && (pdev = pci_get_device(PCI_VENDOR_ID_CAVIUM,\n\t\t\t\t\t\t       PCI_DEVID_OTX2_SDP_PF,\n\t\t\t\t\t\t       pdev)) != NULL) {\n\t\t \n\t\tsdp_pf_num[i] = pdev->bus->number - 1;\n\t\tpfvf = &rvu->pf[sdp_pf_num[i]];\n\n\t\tpfvf->sdp_info = devm_kzalloc(rvu->dev,\n\t\t\t\t\t      sizeof(struct sdp_node_info),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!pfvf->sdp_info) {\n\t\t\tpci_dev_put(pdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdev_info(rvu->dev, \"SDP PF number:%d\\n\", sdp_pf_num[i]);\n\n\t\ti++;\n\t}\n\n\tpci_dev_put(pdev);\n\n\treturn 0;\n}\n\nint\nrvu_mbox_handler_set_sdp_chan_info(struct rvu *rvu,\n\t\t\t\t   struct sdp_chan_info_msg *req,\n\t\t\t\t   struct msg_rsp *rsp)\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, req->hdr.pcifunc);\n\n\tmemcpy(pfvf->sdp_info, &req->info, sizeof(struct sdp_node_info));\n\tdev_info(rvu->dev, \"AF: SDP%d max_vfs %d num_pf_rings %d pf_srn %d\\n\",\n\t\t req->info.node_id, req->info.max_vfs, req->info.num_pf_rings,\n\t\t req->info.pf_srn);\n\treturn 0;\n}\n\nint\nrvu_mbox_handler_get_sdp_chan_info(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t   struct sdp_get_chan_info_msg *rsp)\n{\n\tstruct rvu_hwinfo *hw = rvu->hw;\n\tint blkaddr;\n\n\tif (!hw->cap.programmable_chans) {\n\t\trsp->chan_base = NIX_CHAN_SDP_CH_START;\n\t\trsp->num_chan = NIX_CHAN_SDP_NUM_CHANS;\n\t} else {\n\t\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NIX, 0);\n\t\trsp->chan_base = hw->sdp_chan_base;\n\t\trsp->num_chan = rvu_read64(rvu, blkaddr, NIX_AF_CONST1) & 0xFFFUL;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}