{
  "module_name": "common.h",
  "hash_id": "f9c4ada328c7ed51d0b70ba37033e5541b7a8e676fbe069a3a73c08b6ec2b4d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/af/common.h",
  "human_readable_source": " \n \n\n#ifndef COMMON_H\n#define COMMON_H\n\n#include \"rvu_struct.h\"\n\n#define OTX2_ALIGN\t\t\t128   \n\n#define Q_SIZE_16\t\t0ULL  \n#define Q_SIZE_64\t\t1ULL  \n#define Q_SIZE_256\t\t2ULL\n#define Q_SIZE_1K\t\t3ULL\n#define Q_SIZE_4K\t\t4ULL\n#define Q_SIZE_16K\t\t5ULL\n#define Q_SIZE_64K\t\t6ULL\n#define Q_SIZE_256K\t\t7ULL\n#define Q_SIZE_1M\t\t8ULL  \n#define Q_SIZE_MIN\t\tQ_SIZE_16\n#define Q_SIZE_MAX\t\tQ_SIZE_1M\n\n#define Q_COUNT(x)\t\t(16ULL << (2 * x))\n#define Q_SIZE(x, n)\t\t((ilog2(x) - (n)) / 2)\n\n \n\n \n#define AQ_SIZE\t\t\tQ_SIZE_16\n \n#define AQ_PTR_MASK\t\t0xFFFFF\n\nstruct qmem {\n\tvoid            *base;\n\tdma_addr_t\tiova;\n\tint\t\talloc_sz;\n\tu16\t\tentry_sz;\n\tu8\t\talign;\n\tu32\t\tqsize;\n};\n\nstatic inline int qmem_alloc(struct device *dev, struct qmem **q,\n\t\t\t     int qsize, int entry_sz)\n{\n\tstruct qmem *qmem;\n\tint aligned_addr;\n\n\tif (!qsize)\n\t\treturn -EINVAL;\n\n\t*q = devm_kzalloc(dev, sizeof(*qmem), GFP_KERNEL);\n\tif (!*q)\n\t\treturn -ENOMEM;\n\tqmem = *q;\n\n\tqmem->entry_sz = entry_sz;\n\tqmem->alloc_sz = (qsize * entry_sz) + OTX2_ALIGN;\n\tqmem->base = dma_alloc_attrs(dev, qmem->alloc_sz, &qmem->iova,\n\t\t\t\t     GFP_KERNEL, DMA_ATTR_FORCE_CONTIGUOUS);\n\tif (!qmem->base)\n\t\treturn -ENOMEM;\n\n\tqmem->qsize = qsize;\n\n\taligned_addr = ALIGN((u64)qmem->iova, OTX2_ALIGN);\n\tqmem->align = (aligned_addr - qmem->iova);\n\tqmem->base += qmem->align;\n\tqmem->iova += qmem->align;\n\treturn 0;\n}\n\nstatic inline void qmem_free(struct device *dev, struct qmem *qmem)\n{\n\tif (!qmem)\n\t\treturn;\n\n\tif (qmem->base)\n\t\tdma_free_attrs(dev, qmem->alloc_sz,\n\t\t\t       qmem->base - qmem->align,\n\t\t\t       qmem->iova - qmem->align,\n\t\t\t       DMA_ATTR_FORCE_CONTIGUOUS);\n\tdevm_kfree(dev, qmem);\n}\n\nstruct admin_queue {\n\tstruct qmem\t*inst;\n\tstruct qmem\t*res;\n\tspinlock_t\tlock;  \n};\n\n \nenum npa_aura_sz {\n\tNPA_AURA_SZ_0,\n\tNPA_AURA_SZ_128,\n\tNPA_AURA_SZ_256,\n\tNPA_AURA_SZ_512,\n\tNPA_AURA_SZ_1K,\n\tNPA_AURA_SZ_2K,\n\tNPA_AURA_SZ_4K,\n\tNPA_AURA_SZ_8K,\n\tNPA_AURA_SZ_16K,\n\tNPA_AURA_SZ_32K,\n\tNPA_AURA_SZ_64K,\n\tNPA_AURA_SZ_128K,\n\tNPA_AURA_SZ_256K,\n\tNPA_AURA_SZ_512K,\n\tNPA_AURA_SZ_1M,\n\tNPA_AURA_SZ_MAX,\n};\n\n#define NPA_AURA_COUNT(x)\t(1ULL << ((x) + 6))\n\n \nstruct npa_aq_aura_res {\n\tstruct\tnpa_aq_res_s\tres;\n\tstruct\tnpa_aura_s\taura_ctx;\n\tstruct\tnpa_aura_s\tctx_mask;\n};\n\n \nstruct npa_aq_pool_res {\n\tstruct\tnpa_aq_res_s\tres;\n\tstruct\tnpa_pool_s\tpool_ctx;\n\tstruct\tnpa_pool_s\tctx_mask;\n};\n\n \nenum nix_scheduler {\n\tNIX_TXSCH_LVL_SMQ = 0x0,\n\tNIX_TXSCH_LVL_MDQ = 0x0,\n\tNIX_TXSCH_LVL_TL4 = 0x1,\n\tNIX_TXSCH_LVL_TL3 = 0x2,\n\tNIX_TXSCH_LVL_TL2 = 0x3,\n\tNIX_TXSCH_LVL_TL1 = 0x4,\n\tNIX_TXSCH_LVL_CNT = 0x5,\n};\n\n#define TXSCH_RR_QTM_MAX\t\t((1 << 24) - 1)\n#define TXSCH_TL1_DFLT_RR_QTM\t\tTXSCH_RR_QTM_MAX\n#define TXSCH_TL1_DFLT_RR_PRIO\t\t(0x7ull)\n#define CN10K_MAX_DWRR_WEIGHT          16384  \n\n \n#define SMQ_LINK_TYPE_RPM\t\t0\n#define SMQ_LINK_TYPE_SDP\t\t1\n#define SMQ_LINK_TYPE_LBK\t\t2\n\n \n#define\tNIC_HW_MIN_FRS\t\t\t40\n#define\tNIC_HW_MAX_FRS\t\t\t9212\n#define\tSDP_HW_MAX_FRS\t\t\t65535\n#define CN10K_LMAC_LINK_MAX_FRS\t\t16380  \n#define CN10K_LBK_LINK_MAX_FRS\t\t65535  \n\n \n#define NIX_RX_ACTIONOP_DROP\t\t(0x0ull)\n#define NIX_RX_ACTIONOP_UCAST\t\t(0x1ull)\n#define NIX_RX_ACTIONOP_UCAST_IPSEC\t(0x2ull)\n#define NIX_RX_ACTIONOP_MCAST\t\t(0x3ull)\n#define NIX_RX_ACTIONOP_RSS\t\t(0x4ull)\n \n#define NIX_RX_ACTION_DEFAULT\t\t(0xfull)\n\n \n#define NIX_TX_ACTIONOP_DROP\t\t(0x0ull)\n#define NIX_TX_ACTIONOP_UCAST_DEFAULT\t(0x1ull)\n#define NIX_TX_ACTIONOP_UCAST_CHAN\t(0x2ull)\n#define NIX_TX_ACTIONOP_MCAST\t\t(0x3ull)\n#define NIX_TX_ACTIONOP_DROP_VIOL\t(0x5ull)\n\n#define NPC_MCAM_KEY_X1\t\t\t0\n#define NPC_MCAM_KEY_X2\t\t\t1\n#define NPC_MCAM_KEY_X4\t\t\t2\n\n#define NIX_INTFX_RX(a)\t\t\t(0x0ull | (a) << 1)\n#define NIX_INTFX_TX(a)\t\t\t(0x1ull | (a) << 1)\n\n \n#define NIX_INTF_RX\t\t\tNIX_INTFX_RX(0)\n#define NIX_INTF_TX\t\t\tNIX_INTFX_TX(0)\n\n#define NIX_INTF_TYPE_CGX\t\t0\n#define NIX_INTF_TYPE_LBK\t\t1\n#define NIX_INTF_TYPE_SDP\t\t2\n\n#define MAX_LMAC_PKIND\t\t\t12\n#define NIX_LINK_CGX_LMAC(a, b)\t\t(0 + 4 * (a) + (b))\n#define NIX_LINK_LBK(a)\t\t\t(12 + (a))\n#define NIX_CHAN_CGX_LMAC_CHX(a, b, c)\t(0x800 + 0x100 * (a) + 0x10 * (b) + (c))\n#define NIX_CHAN_LBK_CHX(a, b)\t\t(0 + 0x100 * (a) + (b))\n#define NIX_CHAN_SDP_CH_START          (0x700ull)\n#define NIX_CHAN_SDP_CHX(a)            (NIX_CHAN_SDP_CH_START + (a))\n#define NIX_CHAN_SDP_NUM_CHANS\t\t256\n#define NIX_CHAN_CPT_CH_START          (0x800ull)\n\n \n#define NIX_CHAN_CPT_X2P_MASK          (0x3ffull)\n\n \n#define NIX_LSO_FORMAT_IDX_TSOV4\t0\n#define NIX_LSO_FORMAT_IDX_TSOV6\t1\n\n \n#define MAX_RSS_GROUPS\t\t\t8\n \n#define DEFAULT_RSS_CONTEXT_GROUP\t0\n#define MAX_RSS_INDIR_TBL_SIZE\t\t256  \n\n \nenum ndc_idx_e {\n\tNIX0_RX = 0x0,\n\tNIX0_TX = 0x1,\n\tNPA0_U  = 0x2,\n\tNIX1_RX = 0x4,\n\tNIX1_TX = 0x5,\n};\n\nenum ndc_ctype_e {\n\tCACHING = 0x0,\n\tBYPASS = 0x1,\n};\n\n#define NDC_MAX_PORT 6\n#define NDC_READ_TRANS 0\n#define NDC_WRITE_TRANS 1\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}