{
  "module_name": "rvu_cgx.c",
  "hash_id": "66d6d2092c58fc6723152713d7d807270349c83df36b59cdd6c13205c581a603",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/af/rvu_cgx.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"rvu.h\"\n#include \"cgx.h\"\n#include \"lmac_common.h\"\n#include \"rvu_reg.h\"\n#include \"rvu_trace.h\"\n#include \"rvu_npc_hash.h\"\n\nstruct cgx_evq_entry {\n\tstruct list_head evq_node;\n\tstruct cgx_link_event link_event;\n};\n\n#define M(_name, _id, _fn_name, _req_type, _rsp_type)\t\t\t\\\nstatic struct _req_type __maybe_unused\t\t\t\t\t\\\n*otx2_mbox_alloc_msg_ ## _fn_name(struct rvu *rvu, int devid)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct _req_type *req;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treq = (struct _req_type *)otx2_mbox_alloc_msg_rsp(\t\t\\\n\t\t&rvu->afpf_wq_info.mbox_up, devid, sizeof(struct _req_type), \\\n\t\tsizeof(struct _rsp_type));\t\t\t\t\\\n\tif (!req)\t\t\t\t\t\t\t\\\n\t\treturn NULL;\t\t\t\t\t\t\\\n\treq->hdr.sig = OTX2_MBOX_REQ_SIG;\t\t\t\t\\\n\treq->hdr.id = _id;\t\t\t\t\t\t\\\n\ttrace_otx2_msg_alloc(rvu->pdev, _id, sizeof(*req));\t\t\\\n\treturn req;\t\t\t\t\t\t\t\\\n}\n\nMBOX_UP_CGX_MESSAGES\n#undef M\n\nbool is_mac_feature_supported(struct rvu *rvu, int pf, int feature)\n{\n\tu8 cgx_id, lmac_id;\n\tvoid *cgxd;\n\n\tif (!is_pf_cgxmapped(rvu, pf))\n\t\treturn 0;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\tcgxd = rvu_cgx_pdata(cgx_id, rvu);\n\n\treturn  (cgx_features_get(cgxd) & feature);\n}\n\n#define CGX_OFFSET(x)\t\t\t((x) * rvu->hw->lmac_per_cgx)\n \nstatic u64 cgxlmac_to_pfmap(struct rvu *rvu, u8 cgx_id, u8 lmac_id)\n{\n\treturn rvu->cgxlmac2pf_map[CGX_OFFSET(cgx_id) + lmac_id];\n}\n\nint cgxlmac_to_pf(struct rvu *rvu, int cgx_id, int lmac_id)\n{\n\tunsigned long pfmap;\n\n\tpfmap = cgxlmac_to_pfmap(rvu, cgx_id, lmac_id);\n\n\t \n\tif (!pfmap)\n\t\treturn -ENODEV;\n\telse\n\t\treturn find_first_bit(&pfmap,\n\t\t\t\t      rvu->cgx_cnt_max * rvu->hw->lmac_per_cgx);\n}\n\nstatic u8 cgxlmac_id_to_bmap(u8 cgx_id, u8 lmac_id)\n{\n\treturn ((cgx_id & 0xF) << 4) | (lmac_id & 0xF);\n}\n\nvoid *rvu_cgx_pdata(u8 cgx_id, struct rvu *rvu)\n{\n\tif (cgx_id >= rvu->cgx_cnt_max)\n\t\treturn NULL;\n\n\treturn rvu->cgx_idmap[cgx_id];\n}\n\n \nvoid *rvu_first_cgx_pdata(struct rvu *rvu)\n{\n\tint first_enabled_cgx = 0;\n\tvoid *cgxd = NULL;\n\n\tfor (; first_enabled_cgx < rvu->cgx_cnt_max; first_enabled_cgx++) {\n\t\tcgxd = rvu_cgx_pdata(first_enabled_cgx, rvu);\n\t\tif (cgxd)\n\t\t\tbreak;\n\t}\n\n\treturn cgxd;\n}\n\n \nstatic void rvu_map_cgx_nix_block(struct rvu *rvu, int pf,\n\t\t\t\t  int cgx_id, int lmac_id)\n{\n\tstruct rvu_pfvf *pfvf = &rvu->pf[pf];\n\tu8 p2x;\n\n\tp2x = cgx_lmac_get_p2x(cgx_id, lmac_id);\n\t \n\tpfvf->nix_blkaddr = BLKADDR_NIX0;\n\tif (is_rvu_supports_nix1(rvu) && p2x == CMR_P2X_SEL_NIX1)\n\t\tpfvf->nix_blkaddr = BLKADDR_NIX1;\n}\n\nstatic int rvu_map_cgx_lmac_pf(struct rvu *rvu)\n{\n\tstruct npc_pkind *pkind = &rvu->hw->pkind;\n\tint cgx_cnt_max = rvu->cgx_cnt_max;\n\tint pf = PF_CGXMAP_BASE;\n\tunsigned long lmac_bmap;\n\tint size, free_pkind;\n\tint cgx, lmac, iter;\n\tint numvfs, hwvfs;\n\n\tif (!cgx_cnt_max)\n\t\treturn 0;\n\n\tif (cgx_cnt_max > 0xF || rvu->hw->lmac_per_cgx > 0xF)\n\t\treturn -EINVAL;\n\n\t \n\tsize = (cgx_cnt_max * rvu->hw->lmac_per_cgx + 1) * sizeof(u8);\n\trvu->pf2cgxlmac_map = devm_kmalloc(rvu->dev, size, GFP_KERNEL);\n\tif (!rvu->pf2cgxlmac_map)\n\t\treturn -ENOMEM;\n\n\t \n\tmemset(rvu->pf2cgxlmac_map, 0xFF, size);\n\n\t \n\trvu->cgxlmac2pf_map =\n\t\tdevm_kzalloc(rvu->dev,\n\t\t\t     cgx_cnt_max * rvu->hw->lmac_per_cgx * sizeof(u64),\n\t\t\t     GFP_KERNEL);\n\tif (!rvu->cgxlmac2pf_map)\n\t\treturn -ENOMEM;\n\n\trvu->cgx_mapped_pfs = 0;\n\tfor (cgx = 0; cgx < cgx_cnt_max; cgx++) {\n\t\tif (!rvu_cgx_pdata(cgx, rvu))\n\t\t\tcontinue;\n\t\tlmac_bmap = cgx_get_lmac_bmap(rvu_cgx_pdata(cgx, rvu));\n\t\tfor_each_set_bit(iter, &lmac_bmap, rvu->hw->lmac_per_cgx) {\n\t\t\tlmac = cgx_get_lmacid(rvu_cgx_pdata(cgx, rvu),\n\t\t\t\t\t      iter);\n\t\t\trvu->pf2cgxlmac_map[pf] = cgxlmac_id_to_bmap(cgx, lmac);\n\t\t\trvu->cgxlmac2pf_map[CGX_OFFSET(cgx) + lmac] = 1 << pf;\n\t\t\tfree_pkind = rvu_alloc_rsrc(&pkind->rsrc);\n\t\t\tpkind->pfchan_map[free_pkind] = ((pf) & 0x3F) << 16;\n\t\t\trvu_map_cgx_nix_block(rvu, pf, cgx, lmac);\n\t\t\trvu->cgx_mapped_pfs++;\n\t\t\trvu_get_pf_numvfs(rvu, pf, &numvfs, &hwvfs);\n\t\t\trvu->cgx_mapped_vfs += numvfs;\n\t\t\tpf++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int rvu_cgx_send_link_info(int cgx_id, int lmac_id, struct rvu *rvu)\n{\n\tstruct cgx_evq_entry *qentry;\n\tunsigned long flags;\n\tint err;\n\n\tqentry = kmalloc(sizeof(*qentry), GFP_KERNEL);\n\tif (!qentry)\n\t\treturn -ENOMEM;\n\n\t \n\tspin_lock_irqsave(&rvu->cgx_evq_lock, flags);\n\terr = cgx_get_link_info(rvu_cgx_pdata(cgx_id, rvu), lmac_id,\n\t\t\t\t&qentry->link_event.link_uinfo);\n\tqentry->link_event.cgx_id = cgx_id;\n\tqentry->link_event.lmac_id = lmac_id;\n\tif (err) {\n\t\tkfree(qentry);\n\t\tgoto skip_add;\n\t}\n\tlist_add_tail(&qentry->evq_node, &rvu->cgx_evq_head);\nskip_add:\n\tspin_unlock_irqrestore(&rvu->cgx_evq_lock, flags);\n\n\t \n\tqueue_work(rvu->cgx_evh_wq, &rvu->cgx_evh_work);\n\n\treturn 0;\n}\n\n \nstatic int cgx_lmac_postevent(struct cgx_link_event *event, void *data)\n{\n\tstruct cgx_evq_entry *qentry;\n\tstruct rvu *rvu = data;\n\n\t \n\tqentry = kmalloc(sizeof(*qentry), GFP_ATOMIC);\n\tif (!qentry)\n\t\treturn -ENOMEM;\n\tqentry->link_event = *event;\n\tspin_lock(&rvu->cgx_evq_lock);\n\tlist_add_tail(&qentry->evq_node, &rvu->cgx_evq_head);\n\tspin_unlock(&rvu->cgx_evq_lock);\n\n\t \n\tqueue_work(rvu->cgx_evh_wq, &rvu->cgx_evh_work);\n\n\treturn 0;\n}\n\nstatic void cgx_notify_pfs(struct cgx_link_event *event, struct rvu *rvu)\n{\n\tstruct cgx_link_user_info *linfo;\n\tstruct cgx_link_info_msg *msg;\n\tunsigned long pfmap;\n\tint err, pfid;\n\n\tlinfo = &event->link_uinfo;\n\tpfmap = cgxlmac_to_pfmap(rvu, event->cgx_id, event->lmac_id);\n\tif (!pfmap) {\n\t\tdev_err(rvu->dev, \"CGX port%d:%d not mapped with PF\\n\",\n\t\t\tevent->cgx_id, event->lmac_id);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tpfid = find_first_bit(&pfmap,\n\t\t\t\t      rvu->cgx_cnt_max * rvu->hw->lmac_per_cgx);\n\t\tclear_bit(pfid, &pfmap);\n\n\t\t \n\t\tif (!test_bit(pfid, &rvu->pf_notify_bmap)) {\n\t\t\tdev_info(rvu->dev, \"cgx %d: lmac %d Link status %s\\n\",\n\t\t\t\t event->cgx_id, event->lmac_id,\n\t\t\t\t linfo->link_up ? \"UP\" : \"DOWN\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmsg = otx2_mbox_alloc_msg_cgx_link_event(rvu, pfid);\n\t\tif (!msg)\n\t\t\tcontinue;\n\t\tmsg->link_info = *linfo;\n\t\totx2_mbox_msg_send(&rvu->afpf_wq_info.mbox_up, pfid);\n\t\terr = otx2_mbox_wait_for_rsp(&rvu->afpf_wq_info.mbox_up, pfid);\n\t\tif (err)\n\t\t\tdev_warn(rvu->dev, \"notification to pf %d failed\\n\",\n\t\t\t\t pfid);\n\t} while (pfmap);\n}\n\nstatic void cgx_evhandler_task(struct work_struct *work)\n{\n\tstruct rvu *rvu = container_of(work, struct rvu, cgx_evh_work);\n\tstruct cgx_evq_entry *qentry;\n\tstruct cgx_link_event *event;\n\tunsigned long flags;\n\n\tdo {\n\t\t \n\t\tspin_lock_irqsave(&rvu->cgx_evq_lock, flags);\n\t\tqentry = list_first_entry_or_null(&rvu->cgx_evq_head,\n\t\t\t\t\t\t  struct cgx_evq_entry,\n\t\t\t\t\t\t  evq_node);\n\t\tif (qentry)\n\t\t\tlist_del(&qentry->evq_node);\n\t\tspin_unlock_irqrestore(&rvu->cgx_evq_lock, flags);\n\t\tif (!qentry)\n\t\t\tbreak;  \n\n\t\tevent = &qentry->link_event;\n\n\t\t \n\t\tcgx_notify_pfs(event, rvu);\n\t\tkfree(qentry);\n\t} while (1);\n}\n\nstatic int cgx_lmac_event_handler_init(struct rvu *rvu)\n{\n\tunsigned long lmac_bmap;\n\tstruct cgx_event_cb cb;\n\tint cgx, lmac, err;\n\tvoid *cgxd;\n\n\tspin_lock_init(&rvu->cgx_evq_lock);\n\tINIT_LIST_HEAD(&rvu->cgx_evq_head);\n\tINIT_WORK(&rvu->cgx_evh_work, cgx_evhandler_task);\n\trvu->cgx_evh_wq = alloc_workqueue(\"rvu_evh_wq\", 0, 0);\n\tif (!rvu->cgx_evh_wq) {\n\t\tdev_err(rvu->dev, \"alloc workqueue failed\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcb.notify_link_chg = cgx_lmac_postevent;  \n\tcb.data = rvu;\n\n\tfor (cgx = 0; cgx <= rvu->cgx_cnt_max; cgx++) {\n\t\tcgxd = rvu_cgx_pdata(cgx, rvu);\n\t\tif (!cgxd)\n\t\t\tcontinue;\n\t\tlmac_bmap = cgx_get_lmac_bmap(cgxd);\n\t\tfor_each_set_bit(lmac, &lmac_bmap, rvu->hw->lmac_per_cgx) {\n\t\t\terr = cgx_lmac_evh_register(&cb, cgxd, lmac);\n\t\t\tif (err)\n\t\t\t\tdev_err(rvu->dev,\n\t\t\t\t\t\"%d:%d handler register failed\\n\",\n\t\t\t\t\tcgx, lmac);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void rvu_cgx_wq_destroy(struct rvu *rvu)\n{\n\tif (rvu->cgx_evh_wq) {\n\t\tdestroy_workqueue(rvu->cgx_evh_wq);\n\t\trvu->cgx_evh_wq = NULL;\n\t}\n}\n\nint rvu_cgx_init(struct rvu *rvu)\n{\n\tint cgx, err;\n\tvoid *cgxd;\n\n\t \n\trvu->cgx_cnt_max = cgx_get_cgxcnt_max();\n\tif (!rvu->cgx_cnt_max) {\n\t\tdev_info(rvu->dev, \"No CGX devices found!\\n\");\n\t\treturn 0;\n\t}\n\n\trvu->cgx_idmap = devm_kzalloc(rvu->dev, rvu->cgx_cnt_max *\n\t\t\t\t      sizeof(void *), GFP_KERNEL);\n\tif (!rvu->cgx_idmap)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (cgx = 0; cgx < rvu->cgx_cnt_max; cgx++)\n\t\trvu->cgx_idmap[cgx] = cgx_get_pdata(cgx);\n\n\t \n\terr = rvu_map_cgx_lmac_pf(rvu);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = cgx_lmac_event_handler_init(rvu);\n\tif (err)\n\t\treturn err;\n\n\tmutex_init(&rvu->cgx_cfg_lock);\n\n\t \n\tmb();\n\n\t \n\tfor (cgx = 0; cgx <= rvu->cgx_cnt_max; cgx++) {\n\t\tcgxd = rvu_cgx_pdata(cgx, rvu);\n\t\tif (!cgxd)\n\t\t\tcontinue;\n\t\terr = cgx_lmac_linkup_start(cgxd);\n\t\tif (err)\n\t\t\tdev_err(rvu->dev,\n\t\t\t\t\"Link up process failed to start on cgx %d\\n\",\n\t\t\t\tcgx);\n\t}\n\n\treturn 0;\n}\n\nint rvu_cgx_exit(struct rvu *rvu)\n{\n\tunsigned long lmac_bmap;\n\tint cgx, lmac;\n\tvoid *cgxd;\n\n\tfor (cgx = 0; cgx <= rvu->cgx_cnt_max; cgx++) {\n\t\tcgxd = rvu_cgx_pdata(cgx, rvu);\n\t\tif (!cgxd)\n\t\t\tcontinue;\n\t\tlmac_bmap = cgx_get_lmac_bmap(cgxd);\n\t\tfor_each_set_bit(lmac, &lmac_bmap, rvu->hw->lmac_per_cgx)\n\t\t\tcgx_lmac_evh_unregister(cgxd, lmac);\n\t}\n\n\t \n\tmb();\n\n\trvu_cgx_wq_destroy(rvu);\n\treturn 0;\n}\n\n \ninline bool is_cgx_config_permitted(struct rvu *rvu, u16 pcifunc)\n{\n\tif ((pcifunc & RVU_PFVF_FUNC_MASK) ||\n\t    !is_pf_cgxmapped(rvu, rvu_get_pf(pcifunc)))\n\t\treturn false;\n\treturn true;\n}\n\nvoid rvu_cgx_enadis_rx_bp(struct rvu *rvu, int pf, bool enable)\n{\n\tstruct mac_ops *mac_ops;\n\tu8 cgx_id, lmac_id;\n\tvoid *cgxd;\n\n\tif (!is_pf_cgxmapped(rvu, pf))\n\t\treturn;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\tcgxd = rvu_cgx_pdata(cgx_id, rvu);\n\n\tmac_ops = get_mac_ops(cgxd);\n\t \n\tif (enable)\n\t\tmac_ops->mac_enadis_rx_pause_fwding(cgxd, lmac_id, true);\n\telse\n\t\tmac_ops->mac_enadis_rx_pause_fwding(cgxd, lmac_id, false);\n}\n\nint rvu_cgx_config_rxtx(struct rvu *rvu, u16 pcifunc, bool start)\n{\n\tint pf = rvu_get_pf(pcifunc);\n\tstruct mac_ops *mac_ops;\n\tu8 cgx_id, lmac_id;\n\tvoid *cgxd;\n\n\tif (!is_cgx_config_permitted(rvu, pcifunc))\n\t\treturn LMAC_AF_ERR_PERM_DENIED;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\tcgxd = rvu_cgx_pdata(cgx_id, rvu);\n\tmac_ops = get_mac_ops(cgxd);\n\n\treturn mac_ops->mac_rx_tx_enable(cgxd, lmac_id, start);\n}\n\nint rvu_cgx_tx_enable(struct rvu *rvu, u16 pcifunc, bool enable)\n{\n\tint pf = rvu_get_pf(pcifunc);\n\tstruct mac_ops *mac_ops;\n\tu8 cgx_id, lmac_id;\n\tvoid *cgxd;\n\n\tif (!is_cgx_config_permitted(rvu, pcifunc))\n\t\treturn LMAC_AF_ERR_PERM_DENIED;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\tcgxd = rvu_cgx_pdata(cgx_id, rvu);\n\tmac_ops = get_mac_ops(cgxd);\n\n\treturn mac_ops->mac_tx_enable(cgxd, lmac_id, enable);\n}\n\nint rvu_cgx_config_tx(void *cgxd, int lmac_id, bool enable)\n{\n\tstruct mac_ops *mac_ops;\n\n\tmac_ops = get_mac_ops(cgxd);\n\treturn mac_ops->mac_tx_enable(cgxd, lmac_id, enable);\n}\n\nvoid rvu_cgx_disable_dmac_entries(struct rvu *rvu, u16 pcifunc)\n{\n\tint pf = rvu_get_pf(pcifunc);\n\tint i = 0, lmac_count = 0;\n\tstruct mac_ops *mac_ops;\n\tu8 max_dmac_filters;\n\tu8 cgx_id, lmac_id;\n\tvoid *cgx_dev;\n\n\tif (!is_cgx_config_permitted(rvu, pcifunc))\n\t\treturn;\n\n\tif (rvu_npc_exact_has_match_table(rvu)) {\n\t\trvu_npc_exact_reset(rvu, pcifunc);\n\t\treturn;\n\t}\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\tcgx_dev = cgx_get_pdata(cgx_id);\n\tlmac_count = cgx_get_lmac_cnt(cgx_dev);\n\n\tmac_ops = get_mac_ops(cgx_dev);\n\tif (!mac_ops)\n\t\treturn;\n\n\tmax_dmac_filters = mac_ops->dmac_filter_count / lmac_count;\n\n\tfor (i = 0; i < max_dmac_filters; i++)\n\t\tcgx_lmac_addr_del(cgx_id, lmac_id, i);\n\n\t \n\tcgx_lmac_addr_reset(cgx_id, lmac_id);\n}\n\nint rvu_mbox_handler_cgx_start_rxtx(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t    struct msg_rsp *rsp)\n{\n\trvu_cgx_config_rxtx(rvu, req->hdr.pcifunc, true);\n\treturn 0;\n}\n\nint rvu_mbox_handler_cgx_stop_rxtx(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t   struct msg_rsp *rsp)\n{\n\trvu_cgx_config_rxtx(rvu, req->hdr.pcifunc, false);\n\treturn 0;\n}\n\nstatic int rvu_lmac_get_stats(struct rvu *rvu, struct msg_req *req,\n\t\t\t      void *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tstruct mac_ops *mac_ops;\n\tint stat = 0, err = 0;\n\tu64 tx_stat, rx_stat;\n\tu8 cgx_idx, lmac;\n\tvoid *cgxd;\n\n\tif (!is_cgx_config_permitted(rvu, req->hdr.pcifunc))\n\t\treturn LMAC_AF_ERR_PERM_DENIED;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_idx, &lmac);\n\tcgxd = rvu_cgx_pdata(cgx_idx, rvu);\n\tmac_ops = get_mac_ops(cgxd);\n\n\t \n\twhile (stat < mac_ops->rx_stats_cnt) {\n\t\terr = mac_ops->mac_get_rx_stats(cgxd, lmac, stat, &rx_stat);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (mac_ops->rx_stats_cnt == RPM_RX_STATS_COUNT)\n\t\t\t((struct rpm_stats_rsp *)rsp)->rx_stats[stat] = rx_stat;\n\t\telse\n\t\t\t((struct cgx_stats_rsp *)rsp)->rx_stats[stat] = rx_stat;\n\t\tstat++;\n\t}\n\n\t \n\tstat = 0;\n\twhile (stat < mac_ops->tx_stats_cnt) {\n\t\terr = mac_ops->mac_get_tx_stats(cgxd, lmac, stat, &tx_stat);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (mac_ops->tx_stats_cnt == RPM_TX_STATS_COUNT)\n\t\t\t((struct rpm_stats_rsp *)rsp)->tx_stats[stat] = tx_stat;\n\t\telse\n\t\t\t((struct cgx_stats_rsp *)rsp)->tx_stats[stat] = tx_stat;\n\t\tstat++;\n\t}\n\treturn 0;\n}\n\nint rvu_mbox_handler_cgx_stats(struct rvu *rvu, struct msg_req *req,\n\t\t\t       struct cgx_stats_rsp *rsp)\n{\n\treturn rvu_lmac_get_stats(rvu, req, (void *)rsp);\n}\n\nint rvu_mbox_handler_rpm_stats(struct rvu *rvu, struct msg_req *req,\n\t\t\t       struct rpm_stats_rsp *rsp)\n{\n\treturn rvu_lmac_get_stats(rvu, req, (void *)rsp);\n}\n\nint rvu_mbox_handler_cgx_fec_stats(struct rvu *rvu,\n\t\t\t\t   struct msg_req *req,\n\t\t\t\t   struct cgx_fec_stats_rsp *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tstruct mac_ops *mac_ops;\n\tu8 cgx_idx, lmac;\n\tvoid *cgxd;\n\n\tif (!is_cgx_config_permitted(rvu, req->hdr.pcifunc))\n\t\treturn LMAC_AF_ERR_PERM_DENIED;\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_idx, &lmac);\n\n\tcgxd = rvu_cgx_pdata(cgx_idx, rvu);\n\tmac_ops = get_mac_ops(cgxd);\n\treturn  mac_ops->get_fec_stats(cgxd, lmac, rsp);\n}\n\nint rvu_mbox_handler_cgx_mac_addr_set(struct rvu *rvu,\n\t\t\t\t      struct cgx_mac_addr_set_or_get *req,\n\t\t\t\t      struct cgx_mac_addr_set_or_get *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu8 cgx_id, lmac_id;\n\n\tif (!is_cgx_config_permitted(rvu, req->hdr.pcifunc))\n\t\treturn -EPERM;\n\n\tif (rvu_npc_exact_has_match_table(rvu))\n\t\treturn rvu_npc_exact_mac_addr_set(rvu, req, rsp);\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\n\tcgx_lmac_addr_set(cgx_id, lmac_id, req->mac_addr);\n\n\treturn 0;\n}\n\nint rvu_mbox_handler_cgx_mac_addr_add(struct rvu *rvu,\n\t\t\t\t      struct cgx_mac_addr_add_req *req,\n\t\t\t\t      struct cgx_mac_addr_add_rsp *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu8 cgx_id, lmac_id;\n\tint rc = 0;\n\n\tif (!is_cgx_config_permitted(rvu, req->hdr.pcifunc))\n\t\treturn -EPERM;\n\n\tif (rvu_npc_exact_has_match_table(rvu))\n\t\treturn rvu_npc_exact_mac_addr_add(rvu, req, rsp);\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\trc = cgx_lmac_addr_add(cgx_id, lmac_id, req->mac_addr);\n\tif (rc >= 0) {\n\t\trsp->index = rc;\n\t\treturn 0;\n\t}\n\n\treturn rc;\n}\n\nint rvu_mbox_handler_cgx_mac_addr_del(struct rvu *rvu,\n\t\t\t\t      struct cgx_mac_addr_del_req *req,\n\t\t\t\t      struct msg_rsp *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu8 cgx_id, lmac_id;\n\n\tif (!is_cgx_config_permitted(rvu, req->hdr.pcifunc))\n\t\treturn -EPERM;\n\n\tif (rvu_npc_exact_has_match_table(rvu))\n\t\treturn rvu_npc_exact_mac_addr_del(rvu, req, rsp);\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\treturn cgx_lmac_addr_del(cgx_id, lmac_id, req->index);\n}\n\nint rvu_mbox_handler_cgx_mac_max_entries_get(struct rvu *rvu,\n\t\t\t\t\t     struct msg_req *req,\n\t\t\t\t\t     struct cgx_max_dmac_entries_get_rsp\n\t\t\t\t\t     *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu8 cgx_id, lmac_id;\n\n\t \n\tif (!is_cgx_config_permitted(rvu, req->hdr.pcifunc)) {\n\t\trsp->max_dmac_filters = 0;\n\t\treturn 0;\n\t}\n\n\tif (rvu_npc_exact_has_match_table(rvu)) {\n\t\trsp->max_dmac_filters = rvu_npc_exact_get_max_entries(rvu);\n\t\treturn 0;\n\t}\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\trsp->max_dmac_filters = cgx_lmac_addr_max_entries_get(cgx_id, lmac_id);\n\treturn 0;\n}\n\nint rvu_mbox_handler_cgx_mac_addr_get(struct rvu *rvu,\n\t\t\t\t      struct cgx_mac_addr_set_or_get *req,\n\t\t\t\t      struct cgx_mac_addr_set_or_get *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu8 cgx_id, lmac_id;\n\tint rc = 0;\n\tu64 cfg;\n\n\tif (!is_cgx_config_permitted(rvu, req->hdr.pcifunc))\n\t\treturn -EPERM;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\n\trsp->hdr.rc = rc;\n\tcfg = cgx_lmac_addr_get(cgx_id, lmac_id);\n\t \n\tu64_to_ether_addr(cfg, rsp->mac_addr);\n\treturn 0;\n}\n\nint rvu_mbox_handler_cgx_promisc_enable(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t\tstruct msg_rsp *rsp)\n{\n\tu16 pcifunc = req->hdr.pcifunc;\n\tint pf = rvu_get_pf(pcifunc);\n\tu8 cgx_id, lmac_id;\n\n\tif (!is_cgx_config_permitted(rvu, req->hdr.pcifunc))\n\t\treturn -EPERM;\n\n\t \n\tif (rvu_npc_exact_has_match_table(rvu))\n\t\treturn rvu_npc_exact_promisc_enable(rvu, req->hdr.pcifunc);\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\n\tcgx_lmac_promisc_config(cgx_id, lmac_id, true);\n\treturn 0;\n}\n\nint rvu_mbox_handler_cgx_promisc_disable(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t\t struct msg_rsp *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu8 cgx_id, lmac_id;\n\n\tif (!is_cgx_config_permitted(rvu, req->hdr.pcifunc))\n\t\treturn -EPERM;\n\n\t \n\tif (rvu_npc_exact_has_match_table(rvu))\n\t\treturn rvu_npc_exact_promisc_disable(rvu, req->hdr.pcifunc);\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\n\tcgx_lmac_promisc_config(cgx_id, lmac_id, false);\n\treturn 0;\n}\n\nstatic int rvu_cgx_ptp_rx_cfg(struct rvu *rvu, u16 pcifunc, bool enable)\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, pcifunc);\n\tint pf = rvu_get_pf(pcifunc);\n\tstruct mac_ops *mac_ops;\n\tu8 cgx_id, lmac_id;\n\tvoid *cgxd;\n\n\tif (!is_mac_feature_supported(rvu, pf, RVU_LMAC_FEAT_PTP))\n\t\treturn 0;\n\n\t \n\tif ((pcifunc & RVU_PFVF_FUNC_MASK) ||\n\t    !is_pf_cgxmapped(rvu, pf))\n\t\treturn -ENODEV;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\tcgxd = rvu_cgx_pdata(cgx_id, rvu);\n\n\tmac_ops = get_mac_ops(cgxd);\n\tmac_ops->mac_enadis_ptp_config(cgxd, lmac_id, enable);\n\t \n\tif (npc_config_ts_kpuaction(rvu, pf, pcifunc, enable))\n\t\treturn -EINVAL;\n\t \n\tpfvf->hw_rx_tstamp_en = enable;\n\n\t \n\trvu_mcs_ptp_cfg(rvu, cgx_id, lmac_id, enable);\n\treturn 0;\n}\n\nint rvu_mbox_handler_cgx_ptp_rx_enable(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t       struct msg_rsp *rsp)\n{\n\tif (!is_pf_cgxmapped(rvu, rvu_get_pf(req->hdr.pcifunc)))\n\t\treturn -EPERM;\n\n\treturn rvu_cgx_ptp_rx_cfg(rvu, req->hdr.pcifunc, true);\n}\n\nint rvu_mbox_handler_cgx_ptp_rx_disable(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t\tstruct msg_rsp *rsp)\n{\n\treturn rvu_cgx_ptp_rx_cfg(rvu, req->hdr.pcifunc, false);\n}\n\nstatic int rvu_cgx_config_linkevents(struct rvu *rvu, u16 pcifunc, bool en)\n{\n\tint pf = rvu_get_pf(pcifunc);\n\tu8 cgx_id, lmac_id;\n\n\tif (!is_cgx_config_permitted(rvu, pcifunc))\n\t\treturn -EPERM;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\n\tif (en) {\n\t\tset_bit(pf, &rvu->pf_notify_bmap);\n\t\t \n\t\trvu_cgx_send_link_info(cgx_id, lmac_id, rvu);\n\t} else {\n\t\tclear_bit(pf, &rvu->pf_notify_bmap);\n\t}\n\n\treturn 0;\n}\n\nint rvu_mbox_handler_cgx_start_linkevents(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t\t  struct msg_rsp *rsp)\n{\n\trvu_cgx_config_linkevents(rvu, req->hdr.pcifunc, true);\n\treturn 0;\n}\n\nint rvu_mbox_handler_cgx_stop_linkevents(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t\t struct msg_rsp *rsp)\n{\n\trvu_cgx_config_linkevents(rvu, req->hdr.pcifunc, false);\n\treturn 0;\n}\n\nint rvu_mbox_handler_cgx_get_linkinfo(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t      struct cgx_link_info_msg *rsp)\n{\n\tu8 cgx_id, lmac_id;\n\tint pf, err;\n\n\tpf = rvu_get_pf(req->hdr.pcifunc);\n\n\tif (!is_pf_cgxmapped(rvu, pf))\n\t\treturn -ENODEV;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\n\terr = cgx_get_link_info(rvu_cgx_pdata(cgx_id, rvu), lmac_id,\n\t\t\t\t&rsp->link_info);\n\treturn err;\n}\n\nint rvu_mbox_handler_cgx_features_get(struct rvu *rvu,\n\t\t\t\t      struct msg_req *req,\n\t\t\t\t      struct cgx_features_info_msg *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu8 cgx_idx, lmac;\n\tvoid *cgxd;\n\n\tif (!is_pf_cgxmapped(rvu, pf))\n\t\treturn 0;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_idx, &lmac);\n\tcgxd = rvu_cgx_pdata(cgx_idx, rvu);\n\trsp->lmac_features = cgx_features_get(cgxd);\n\n\treturn 0;\n}\n\nu32 rvu_cgx_get_fifolen(struct rvu *rvu)\n{\n\tstruct mac_ops *mac_ops;\n\tu32 fifo_len;\n\n\tmac_ops = get_mac_ops(rvu_first_cgx_pdata(rvu));\n\tfifo_len = mac_ops ? mac_ops->fifo_len : 0;\n\n\treturn fifo_len;\n}\n\nu32 rvu_cgx_get_lmac_fifolen(struct rvu *rvu, int cgx, int lmac)\n{\n\tstruct mac_ops *mac_ops;\n\tvoid *cgxd;\n\n\tcgxd = rvu_cgx_pdata(cgx, rvu);\n\tif (!cgxd)\n\t\treturn 0;\n\n\tmac_ops = get_mac_ops(cgxd);\n\tif (!mac_ops->lmac_fifo_len)\n\t\treturn 0;\n\n\treturn mac_ops->lmac_fifo_len(cgxd, lmac);\n}\n\nstatic int rvu_cgx_config_intlbk(struct rvu *rvu, u16 pcifunc, bool en)\n{\n\tint pf = rvu_get_pf(pcifunc);\n\tstruct mac_ops *mac_ops;\n\tu8 cgx_id, lmac_id;\n\n\tif (!is_cgx_config_permitted(rvu, pcifunc))\n\t\treturn -EPERM;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\tmac_ops = get_mac_ops(rvu_cgx_pdata(cgx_id, rvu));\n\n\treturn mac_ops->mac_lmac_intl_lbk(rvu_cgx_pdata(cgx_id, rvu),\n\t\t\t\t\t  lmac_id, en);\n}\n\nint rvu_mbox_handler_cgx_intlbk_enable(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t       struct msg_rsp *rsp)\n{\n\trvu_cgx_config_intlbk(rvu, req->hdr.pcifunc, true);\n\treturn 0;\n}\n\nint rvu_mbox_handler_cgx_intlbk_disable(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t\tstruct msg_rsp *rsp)\n{\n\trvu_cgx_config_intlbk(rvu, req->hdr.pcifunc, false);\n\treturn 0;\n}\n\nint rvu_cgx_cfg_pause_frm(struct rvu *rvu, u16 pcifunc, u8 tx_pause, u8 rx_pause)\n{\n\tint pf = rvu_get_pf(pcifunc);\n\tu8 rx_pfc = 0, tx_pfc = 0;\n\tstruct mac_ops *mac_ops;\n\tu8 cgx_id, lmac_id;\n\tvoid *cgxd;\n\n\tif (!is_mac_feature_supported(rvu, pf, RVU_LMAC_FEAT_FC))\n\t\treturn 0;\n\n\t \n\tif (!is_pf_cgxmapped(rvu, pf))\n\t\treturn LMAC_AF_ERR_PF_NOT_MAPPED;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\tcgxd = rvu_cgx_pdata(cgx_id, rvu);\n\tmac_ops = get_mac_ops(cgxd);\n\n\tmac_ops->mac_get_pfc_frm_cfg(cgxd, lmac_id, &tx_pfc, &rx_pfc);\n\tif (tx_pfc || rx_pfc) {\n\t\tdev_warn(rvu->dev,\n\t\t\t \"Can not configure 802.3X flow control as PFC frames are enabled\");\n\t\treturn LMAC_AF_ERR_8023PAUSE_ENADIS_PERM_DENIED;\n\t}\n\n\tmutex_lock(&rvu->rsrc_lock);\n\tif (verify_lmac_fc_cfg(cgxd, lmac_id, tx_pause, rx_pause,\n\t\t\t       pcifunc & RVU_PFVF_FUNC_MASK)) {\n\t\tmutex_unlock(&rvu->rsrc_lock);\n\t\treturn LMAC_AF_ERR_PERM_DENIED;\n\t}\n\tmutex_unlock(&rvu->rsrc_lock);\n\n\treturn mac_ops->mac_enadis_pause_frm(cgxd, lmac_id, tx_pause, rx_pause);\n}\n\nint rvu_mbox_handler_cgx_cfg_pause_frm(struct rvu *rvu,\n\t\t\t\t       struct cgx_pause_frm_cfg *req,\n\t\t\t\t       struct cgx_pause_frm_cfg *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tstruct mac_ops *mac_ops;\n\tu8 cgx_id, lmac_id;\n\tint err = 0;\n\tvoid *cgxd;\n\n\t \n\tif (!is_pf_cgxmapped(rvu, pf))\n\t\treturn -ENODEV;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\tcgxd = rvu_cgx_pdata(cgx_id, rvu);\n\tmac_ops = get_mac_ops(cgxd);\n\n\tif (req->set)\n\t\terr = rvu_cgx_cfg_pause_frm(rvu, req->hdr.pcifunc, req->tx_pause, req->rx_pause);\n\telse\n\t\tmac_ops->mac_get_pause_frm_status(cgxd, lmac_id, &rsp->tx_pause, &rsp->rx_pause);\n\n\treturn err;\n}\n\nint rvu_mbox_handler_cgx_get_phy_fec_stats(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t\t   struct msg_rsp *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu8 cgx_id, lmac_id;\n\n\tif (!is_pf_cgxmapped(rvu, pf))\n\t\treturn LMAC_AF_ERR_PF_NOT_MAPPED;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\treturn cgx_get_phy_fec_stats(rvu_cgx_pdata(cgx_id, rvu), lmac_id);\n}\n\n \nint rvu_cgx_nix_cuml_stats(struct rvu *rvu, void *cgxd, int lmac_id,\n\t\t\t   int index, int rxtxflag, u64 *stat)\n{\n\tstruct rvu_block *block;\n\tint blkaddr;\n\tu16 pcifunc;\n\tint pf, lf;\n\n\t*stat = 0;\n\n\tif (!cgxd || !rvu)\n\t\treturn -EINVAL;\n\n\tpf = cgxlmac_to_pf(rvu, cgx_get_cgxid(cgxd), lmac_id);\n\tif (pf < 0)\n\t\treturn pf;\n\n\t \n\tpcifunc = pf << RVU_PFVF_PF_SHIFT;\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NIX, pcifunc);\n\tif (blkaddr < 0)\n\t\treturn 0;\n\tblock = &rvu->hw->block[blkaddr];\n\n\tfor (lf = 0; lf < block->lf.max; lf++) {\n\t\t \n\t\tif (!((block->fn_map[lf] & ~RVU_PFVF_FUNC_MASK) == (pcifunc &\n\t\t\t ~RVU_PFVF_FUNC_MASK)))\n\t\t\tcontinue;\n\t\tif (rxtxflag == NIX_STATS_RX)\n\t\t\t*stat += rvu_read64(rvu, blkaddr,\n\t\t\t\t\t    NIX_AF_LFX_RX_STATX(lf, index));\n\t\telse\n\t\t\t*stat += rvu_read64(rvu, blkaddr,\n\t\t\t\t\t    NIX_AF_LFX_TX_STATX(lf, index));\n\t}\n\n\treturn 0;\n}\n\nint rvu_cgx_start_stop_io(struct rvu *rvu, u16 pcifunc, bool start)\n{\n\tstruct rvu_pfvf *parent_pf, *pfvf;\n\tint cgx_users, err = 0;\n\n\tif (!is_pf_cgxmapped(rvu, rvu_get_pf(pcifunc)))\n\t\treturn 0;\n\n\tparent_pf = &rvu->pf[rvu_get_pf(pcifunc)];\n\tpfvf = rvu_get_pfvf(rvu, pcifunc);\n\n\tmutex_lock(&rvu->cgx_cfg_lock);\n\n\tif (start && pfvf->cgx_in_use)\n\t\tgoto exit;   \n\tif (!start && !pfvf->cgx_in_use)\n\t\tgoto exit;  \n\n\tif (start) {\n\t\tcgx_users = parent_pf->cgx_users;\n\t\tparent_pf->cgx_users++;\n\t} else {\n\t\tparent_pf->cgx_users--;\n\t\tcgx_users = parent_pf->cgx_users;\n\t}\n\n\t \n\tif (!cgx_users) {\n\t\terr = rvu_cgx_config_rxtx(rvu, pcifunc & ~RVU_PFVF_FUNC_MASK,\n\t\t\t\t\t  start);\n\t\tif (err) {\n\t\t\tdev_err(rvu->dev, \"Unable to %s CGX\\n\",\n\t\t\t\tstart ? \"start\" : \"stop\");\n\t\t\t \n\t\t\tparent_pf->cgx_users = start ? parent_pf->cgx_users  - 1\n\t\t\t\t\t       : parent_pf->cgx_users  + 1;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tpfvf->cgx_in_use = start;\nexit:\n\tmutex_unlock(&rvu->cgx_cfg_lock);\n\treturn err;\n}\n\nint rvu_mbox_handler_cgx_set_fec_param(struct rvu *rvu,\n\t\t\t\t       struct fec_mode *req,\n\t\t\t\t       struct fec_mode *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu8 cgx_id, lmac_id;\n\n\tif (!is_pf_cgxmapped(rvu, pf))\n\t\treturn -EPERM;\n\n\tif (req->fec == OTX2_FEC_OFF)\n\t\treq->fec = OTX2_FEC_NONE;\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\trsp->fec = cgx_set_fec(req->fec, cgx_id, lmac_id);\n\treturn 0;\n}\n\nint rvu_mbox_handler_cgx_get_aux_link_info(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t\t   struct cgx_fw_data *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu8 cgx_id, lmac_id;\n\n\tif (!rvu->fwdata)\n\t\treturn LMAC_AF_ERR_FIRMWARE_DATA_NOT_MAPPED;\n\n\tif (!is_pf_cgxmapped(rvu, pf))\n\t\treturn -EPERM;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\n\tif (rvu->hw->lmac_per_cgx == CGX_LMACS_USX)\n\t\tmemcpy(&rsp->fwdata,\n\t\t       &rvu->fwdata->cgx_fw_data_usx[cgx_id][lmac_id],\n\t\t       sizeof(struct cgx_lmac_fwdata_s));\n\telse\n\t\tmemcpy(&rsp->fwdata,\n\t\t       &rvu->fwdata->cgx_fw_data[cgx_id][lmac_id],\n\t\t       sizeof(struct cgx_lmac_fwdata_s));\n\n\treturn 0;\n}\n\nint rvu_mbox_handler_cgx_set_link_mode(struct rvu *rvu,\n\t\t\t\t       struct cgx_set_link_mode_req *req,\n\t\t\t\t       struct cgx_set_link_mode_rsp *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu8 cgx_idx, lmac;\n\tvoid *cgxd;\n\n\tif (!is_cgx_config_permitted(rvu, req->hdr.pcifunc))\n\t\treturn -EPERM;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_idx, &lmac);\n\tcgxd = rvu_cgx_pdata(cgx_idx, rvu);\n\trsp->status = cgx_set_link_mode(cgxd, req->args, cgx_idx, lmac);\n\treturn 0;\n}\n\nint rvu_mbox_handler_cgx_mac_addr_reset(struct rvu *rvu, struct cgx_mac_addr_reset_req *req,\n\t\t\t\t\tstruct msg_rsp *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu8 cgx_id, lmac_id;\n\n\tif (!is_cgx_config_permitted(rvu, req->hdr.pcifunc))\n\t\treturn LMAC_AF_ERR_PERM_DENIED;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\n\tif (rvu_npc_exact_has_match_table(rvu))\n\t\treturn rvu_npc_exact_mac_addr_reset(rvu, req, rsp);\n\n\treturn cgx_lmac_addr_reset(cgx_id, lmac_id);\n}\n\nint rvu_mbox_handler_cgx_mac_addr_update(struct rvu *rvu,\n\t\t\t\t\t struct cgx_mac_addr_update_req *req,\n\t\t\t\t\t struct cgx_mac_addr_update_rsp *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tu8 cgx_id, lmac_id;\n\n\tif (!is_cgx_config_permitted(rvu, req->hdr.pcifunc))\n\t\treturn LMAC_AF_ERR_PERM_DENIED;\n\n\tif (rvu_npc_exact_has_match_table(rvu))\n\t\treturn rvu_npc_exact_mac_addr_update(rvu, req, rsp);\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\treturn cgx_lmac_addr_update(cgx_id, lmac_id, req->mac_addr, req->index);\n}\n\nint rvu_cgx_prio_flow_ctrl_cfg(struct rvu *rvu, u16 pcifunc, u8 tx_pause,\n\t\t\t       u8 rx_pause, u16 pfc_en)\n{\n\tint pf = rvu_get_pf(pcifunc);\n\tu8 rx_8023 = 0, tx_8023 = 0;\n\tstruct mac_ops *mac_ops;\n\tu8 cgx_id, lmac_id;\n\tvoid *cgxd;\n\n\t \n\tif (!is_pf_cgxmapped(rvu, pf))\n\t\treturn -ENODEV;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\tcgxd = rvu_cgx_pdata(cgx_id, rvu);\n\tmac_ops = get_mac_ops(cgxd);\n\n\tmac_ops->mac_get_pause_frm_status(cgxd, lmac_id, &tx_8023, &rx_8023);\n\tif (tx_8023 || rx_8023) {\n\t\tdev_warn(rvu->dev,\n\t\t\t \"Can not configure PFC as 802.3X pause frames are enabled\");\n\t\treturn LMAC_AF_ERR_PFC_ENADIS_PERM_DENIED;\n\t}\n\n\tmutex_lock(&rvu->rsrc_lock);\n\tif (verify_lmac_fc_cfg(cgxd, lmac_id, tx_pause, rx_pause,\n\t\t\t       pcifunc & RVU_PFVF_FUNC_MASK)) {\n\t\tmutex_unlock(&rvu->rsrc_lock);\n\t\treturn LMAC_AF_ERR_PERM_DENIED;\n\t}\n\tmutex_unlock(&rvu->rsrc_lock);\n\n\treturn mac_ops->pfc_config(cgxd, lmac_id, tx_pause, rx_pause, pfc_en);\n}\n\nint rvu_mbox_handler_cgx_prio_flow_ctrl_cfg(struct rvu *rvu,\n\t\t\t\t\t    struct cgx_pfc_cfg *req,\n\t\t\t\t\t    struct cgx_pfc_rsp *rsp)\n{\n\tint pf = rvu_get_pf(req->hdr.pcifunc);\n\tstruct mac_ops *mac_ops;\n\tu8 cgx_id, lmac_id;\n\tvoid *cgxd;\n\tint err;\n\n\t \n\tif (!is_pf_cgxmapped(rvu, pf))\n\t\treturn -ENODEV;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx_id, &lmac_id);\n\tcgxd = rvu_cgx_pdata(cgx_id, rvu);\n\tmac_ops = get_mac_ops(cgxd);\n\n\terr = rvu_cgx_prio_flow_ctrl_cfg(rvu, req->hdr.pcifunc, req->tx_pause,\n\t\t\t\t\t req->rx_pause, req->pfc_en);\n\n\tmac_ops->mac_get_pfc_frm_cfg(cgxd, lmac_id, &rsp->tx_pause, &rsp->rx_pause);\n\treturn err;\n}\n\nvoid rvu_mac_reset(struct rvu *rvu, u16 pcifunc)\n{\n\tint pf = rvu_get_pf(pcifunc);\n\tstruct mac_ops *mac_ops;\n\tstruct cgx *cgxd;\n\tu8 cgx, lmac;\n\n\tif (!is_pf_cgxmapped(rvu, pf))\n\t\treturn;\n\n\trvu_get_cgx_lmac_id(rvu->pf2cgxlmac_map[pf], &cgx, &lmac);\n\tcgxd = rvu_cgx_pdata(cgx, rvu);\n\tmac_ops = get_mac_ops(cgxd);\n\n\tif (mac_ops->mac_reset(cgxd, lmac, !is_vf(pcifunc)))\n\t\tdev_err(rvu->dev, \"Failed to reset MAC\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}