{
  "module_name": "rvu_npc_fs.c",
  "hash_id": "9928d05e1b00bb5395e91ee542454977e85e3b7cf5613d9caae59f2bc6578235",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc_fs.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n\n#include \"rvu_struct.h\"\n#include \"rvu_reg.h\"\n#include \"rvu.h\"\n#include \"npc.h\"\n#include \"rvu_npc_fs.h\"\n#include \"rvu_npc_hash.h\"\n\nstatic const char * const npc_flow_names[] = {\n\t[NPC_DMAC]\t= \"dmac\",\n\t[NPC_SMAC]\t= \"smac\",\n\t[NPC_ETYPE]\t= \"ether type\",\n\t[NPC_VLAN_ETYPE_CTAG] = \"vlan ether type ctag\",\n\t[NPC_VLAN_ETYPE_STAG] = \"vlan ether type stag\",\n\t[NPC_OUTER_VID]\t= \"outer vlan id\",\n\t[NPC_INNER_VID]\t= \"inner vlan id\",\n\t[NPC_TOS]\t= \"tos\",\n\t[NPC_IPFRAG_IPV4] = \"fragmented IPv4 header \",\n\t[NPC_SIP_IPV4]\t= \"ipv4 source ip\",\n\t[NPC_DIP_IPV4]\t= \"ipv4 destination ip\",\n\t[NPC_IPFRAG_IPV6] = \"fragmented IPv6 header \",\n\t[NPC_SIP_IPV6]\t= \"ipv6 source ip\",\n\t[NPC_DIP_IPV6]\t= \"ipv6 destination ip\",\n\t[NPC_IPPROTO_TCP] = \"ip proto tcp\",\n\t[NPC_IPPROTO_UDP] = \"ip proto udp\",\n\t[NPC_IPPROTO_SCTP] = \"ip proto sctp\",\n\t[NPC_IPPROTO_ICMP] = \"ip proto icmp\",\n\t[NPC_IPPROTO_ICMP6] = \"ip proto icmp6\",\n\t[NPC_IPPROTO_AH] = \"ip proto AH\",\n\t[NPC_IPPROTO_ESP] = \"ip proto ESP\",\n\t[NPC_SPORT_TCP]\t= \"tcp source port\",\n\t[NPC_DPORT_TCP]\t= \"tcp destination port\",\n\t[NPC_SPORT_UDP]\t= \"udp source port\",\n\t[NPC_DPORT_UDP]\t= \"udp destination port\",\n\t[NPC_SPORT_SCTP] = \"sctp source port\",\n\t[NPC_DPORT_SCTP] = \"sctp destination port\",\n\t[NPC_LXMB]\t= \"Mcast/Bcast header \",\n\t[NPC_IPSEC_SPI] = \"SPI \",\n\t[NPC_UNKNOWN]\t= \"unknown\",\n};\n\nbool npc_is_feature_supported(struct rvu *rvu, u64 features, u8 intf)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu64 mcam_features;\n\tu64 unsupported;\n\n\tmcam_features = is_npc_intf_tx(intf) ? mcam->tx_features : mcam->rx_features;\n\tunsupported = (mcam_features ^ features) & ~mcam_features;\n\n\t \n\treturn !unsupported;\n}\n\nconst char *npc_get_field_name(u8 hdr)\n{\n\tif (hdr >= ARRAY_SIZE(npc_flow_names))\n\t\treturn npc_flow_names[NPC_UNKNOWN];\n\n\treturn npc_flow_names[hdr];\n}\n\n \nstatic void npc_set_kw_masks(struct npc_mcam *mcam, u8 type,\n\t\t\t     u8 nr_bits, int start_kwi, int offset, u8 intf)\n{\n\tstruct npc_key_field *field = &mcam->rx_key_fields[type];\n\tu8 bits_in_kw;\n\tint max_kwi;\n\n\tif (mcam->banks_per_entry == 1)\n\t\tmax_kwi = 1;  \n\telse if (mcam->banks_per_entry == 2)\n\t\tmax_kwi = 3;  \n\telse\n\t\tmax_kwi = 6;  \n\n\tif (is_npc_intf_tx(intf))\n\t\tfield = &mcam->tx_key_fields[type];\n\n\tif (offset + nr_bits <= 64) {\n\t\t \n\t\tif (start_kwi > max_kwi)\n\t\t\treturn;\n\t\tfield->kw_mask[start_kwi] |= GENMASK_ULL(nr_bits - 1, 0)\n\t\t\t\t\t     << offset;\n\t\tfield->nr_kws = 1;\n\t} else if (offset + nr_bits > 64 &&\n\t\t   offset + nr_bits <= 128) {\n\t\t \n\t\tif (start_kwi + 1 > max_kwi)\n\t\t\treturn;\n\t\t \n\t\tbits_in_kw = 64 - offset;\n\t\tfield->kw_mask[start_kwi] |= GENMASK_ULL(bits_in_kw - 1, 0)\n\t\t\t\t\t     << offset;\n\t\t \n\t\tbits_in_kw = nr_bits + offset - 64;\n\t\tfield->kw_mask[start_kwi + 1] |= GENMASK_ULL(bits_in_kw - 1, 0);\n\t\tfield->nr_kws = 2;\n\t} else {\n\t\t \n\t\tif (start_kwi + 2 > max_kwi)\n\t\t\treturn;\n\t\t \n\t\tbits_in_kw = 64 - offset;\n\t\tfield->kw_mask[start_kwi] |= GENMASK_ULL(bits_in_kw - 1, 0)\n\t\t\t\t\t     << offset;\n\t\t \n\t\tfield->kw_mask[start_kwi + 1] = ~0ULL;\n\t\t \n\t\tbits_in_kw = nr_bits + offset - 128;\n\t\tfield->kw_mask[start_kwi + 2] |= GENMASK_ULL(bits_in_kw - 1, 0);\n\t\tfield->nr_kws = 3;\n\t}\n}\n\n \nstatic bool npc_is_field_present(struct rvu *rvu, enum key_fields type, u8 intf)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct npc_key_field *input;\n\n\tinput  = &mcam->rx_key_fields[type];\n\tif (is_npc_intf_tx(intf))\n\t\tinput  = &mcam->tx_key_fields[type];\n\n\treturn input->nr_kws > 0;\n}\n\nstatic bool npc_is_same(struct npc_key_field *input,\n\t\t\tstruct npc_key_field *field)\n{\n\treturn memcmp(&input->layer_mdata, &field->layer_mdata,\n\t\t     sizeof(struct npc_layer_mdata)) == 0;\n}\n\nstatic void npc_set_layer_mdata(struct npc_mcam *mcam, enum key_fields type,\n\t\t\t\tu64 cfg, u8 lid, u8 lt, u8 intf)\n{\n\tstruct npc_key_field *input = &mcam->rx_key_fields[type];\n\n\tif (is_npc_intf_tx(intf))\n\t\tinput = &mcam->tx_key_fields[type];\n\n\tinput->layer_mdata.hdr = FIELD_GET(NPC_HDR_OFFSET, cfg);\n\tinput->layer_mdata.key = FIELD_GET(NPC_KEY_OFFSET, cfg);\n\tinput->layer_mdata.len = FIELD_GET(NPC_BYTESM, cfg) + 1;\n\tinput->layer_mdata.ltype = lt;\n\tinput->layer_mdata.lid = lid;\n}\n\nstatic bool npc_check_overlap_fields(struct npc_key_field *input1,\n\t\t\t\t     struct npc_key_field *input2)\n{\n\tint kwi;\n\n\t \n\tif (input1->layer_mdata.lid == input2->layer_mdata.lid &&\n\t    input1->layer_mdata.ltype != input2->layer_mdata.ltype)\n\t\treturn false;\n\n\tfor (kwi = 0; kwi < NPC_MAX_KWS_IN_KEY; kwi++) {\n\t\tif (input1->kw_mask[kwi] & input2->kw_mask[kwi])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic bool npc_check_overlap(struct rvu *rvu, int blkaddr,\n\t\t\t      enum key_fields type, u8 start_lid, u8 intf)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct npc_key_field *dummy, *input;\n\tint start_kwi, offset;\n\tu8 nr_bits, lid, lt, ld;\n\tu64 cfg;\n\n\tdummy = &mcam->rx_key_fields[NPC_UNKNOWN];\n\tinput = &mcam->rx_key_fields[type];\n\n\tif (is_npc_intf_tx(intf)) {\n\t\tdummy = &mcam->tx_key_fields[NPC_UNKNOWN];\n\t\tinput = &mcam->tx_key_fields[type];\n\t}\n\n\tfor (lid = start_lid; lid < NPC_MAX_LID; lid++) {\n\t\tfor (lt = 0; lt < NPC_MAX_LT; lt++) {\n\t\t\tfor (ld = 0; ld < NPC_MAX_LD; ld++) {\n\t\t\t\tcfg = rvu_read64(rvu, blkaddr,\n\t\t\t\t\t\t NPC_AF_INTFX_LIDX_LTX_LDX_CFG\n\t\t\t\t\t\t (intf, lid, lt, ld));\n\t\t\t\tif (!FIELD_GET(NPC_LDATA_EN, cfg))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemset(dummy, 0, sizeof(struct npc_key_field));\n\t\t\t\tnpc_set_layer_mdata(mcam, NPC_UNKNOWN, cfg,\n\t\t\t\t\t\t    lid, lt, intf);\n\t\t\t\t \n\t\t\t\tif (npc_is_same(input, dummy))\n\t\t\t\t\tcontinue;\n\t\t\t\tstart_kwi = dummy->layer_mdata.key / 8;\n\t\t\t\toffset = (dummy->layer_mdata.key * 8) % 64;\n\t\t\t\tnr_bits = dummy->layer_mdata.len * 8;\n\t\t\t\t \n\t\t\t\tnpc_set_kw_masks(mcam, NPC_UNKNOWN, nr_bits,\n\t\t\t\t\t\t start_kwi, offset, intf);\n\t\t\t\t \n\t\t\t\tif (npc_check_overlap_fields(dummy, input))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool npc_check_field(struct rvu *rvu, int blkaddr, enum key_fields type,\n\t\t\t    u8 intf)\n{\n\tif (!npc_is_field_present(rvu, type, intf) ||\n\t    npc_check_overlap(rvu, blkaddr, type, 0, intf))\n\t\treturn false;\n\treturn true;\n}\n\nstatic void npc_scan_exact_result(struct npc_mcam *mcam, u8 bit_number,\n\t\t\t\t  u8 key_nibble, u8 intf)\n{\n\tu8 offset = (key_nibble * 4) % 64;  \n\tu8 kwi = (key_nibble * 4) / 64;  \n\tu8 nr_bits = 4;  \n\tu8 type;\n\n\tswitch (bit_number) {\n\tcase 40 ... 43:\n\t\ttype = NPC_EXACT_RESULT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\tnpc_set_kw_masks(mcam, type, nr_bits, kwi, offset, intf);\n}\n\nstatic void npc_scan_parse_result(struct npc_mcam *mcam, u8 bit_number,\n\t\t\t\t  u8 key_nibble, u8 intf)\n{\n\tu8 offset = (key_nibble * 4) % 64;  \n\tu8 kwi = (key_nibble * 4) / 64;  \n\tu8 nr_bits = 4;  \n\tu8 type;\n\n\tswitch (bit_number) {\n\tcase 0 ... 2:\n\t\ttype = NPC_CHAN;\n\t\tbreak;\n\tcase 3:\n\t\ttype = NPC_ERRLEV;\n\t\tbreak;\n\tcase 4 ... 5:\n\t\ttype = NPC_ERRCODE;\n\t\tbreak;\n\tcase 6:\n\t\ttype = NPC_LXMB;\n\t\tbreak;\n\t \n\tcase 9:\n\t\ttype = NPC_LA;\n\t\tbreak;\n\tcase 12:\n\t\ttype = NPC_LB;\n\t\tbreak;\n\tcase 15:\n\t\ttype = NPC_LC;\n\t\tbreak;\n\tcase 18:\n\t\ttype = NPC_LD;\n\t\tbreak;\n\tcase 21:\n\t\ttype = NPC_LE;\n\t\tbreak;\n\tcase 24:\n\t\ttype = NPC_LF;\n\t\tbreak;\n\tcase 27:\n\t\ttype = NPC_LG;\n\t\tbreak;\n\tcase 30:\n\t\ttype = NPC_LH;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tnpc_set_kw_masks(mcam, type, nr_bits, kwi, offset, intf);\n}\n\nstatic void npc_handle_multi_layer_fields(struct rvu *rvu, int blkaddr, u8 intf)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct npc_key_field *key_fields;\n\t \n\tstruct npc_key_field *etype_ether;\n\tstruct npc_key_field *etype_tag1;\n\tstruct npc_key_field *etype_tag2;\n\t \n\tstruct npc_key_field *vlan_tag1;\n\tstruct npc_key_field *vlan_tag2;\n\t \n\tstruct npc_key_field *vlan_tag3;\n\tu64 *features;\n\tu8 start_lid;\n\tint i;\n\n\tkey_fields = mcam->rx_key_fields;\n\tfeatures = &mcam->rx_features;\n\n\tif (is_npc_intf_tx(intf)) {\n\t\tkey_fields = mcam->tx_key_fields;\n\t\tfeatures = &mcam->tx_features;\n\t}\n\n\t \n\tetype_ether = &key_fields[NPC_ETYPE_ETHER];\n\tetype_tag1 = &key_fields[NPC_ETYPE_TAG1];\n\tetype_tag2 = &key_fields[NPC_ETYPE_TAG2];\n\tvlan_tag1 = &key_fields[NPC_VLAN_TAG1];\n\tvlan_tag2 = &key_fields[NPC_VLAN_TAG2];\n\tvlan_tag3 = &key_fields[NPC_VLAN_TAG3];\n\n\t \n\tif (!etype_ether->nr_kws && !etype_tag1->nr_kws && !etype_tag2->nr_kws) {\n\t\tdev_err(rvu->dev, \"mkex: Ethertype is not extracted.\\n\");\n\t\tgoto vlan_tci;\n\t}\n\n\t \n\tif (etype_ether->nr_kws && !etype_tag1->nr_kws && !etype_tag2->nr_kws)\n\t\tkey_fields[NPC_ETYPE] = *etype_ether;\n\tif (!etype_ether->nr_kws && etype_tag1->nr_kws && !etype_tag2->nr_kws)\n\t\tkey_fields[NPC_ETYPE] = *etype_tag1;\n\tif (!etype_ether->nr_kws && !etype_tag1->nr_kws && etype_tag2->nr_kws)\n\t\tkey_fields[NPC_ETYPE] = *etype_tag2;\n\n\t \n\tif (etype_ether->nr_kws && etype_tag1->nr_kws) {\n\t\tfor (i = 0; i < NPC_MAX_KWS_IN_KEY; i++) {\n\t\t\tif (etype_ether->kw_mask[i] != etype_tag1->kw_mask[i]) {\n\t\t\t\tdev_err(rvu->dev, \"mkex: Etype pos is different for untagged and tagged pkts.\\n\");\n\t\t\t\tgoto vlan_tci;\n\t\t\t}\n\t\t}\n\t\tkey_fields[NPC_ETYPE] = *etype_tag1;\n\t}\n\tif (etype_ether->nr_kws && etype_tag2->nr_kws) {\n\t\tfor (i = 0; i < NPC_MAX_KWS_IN_KEY; i++) {\n\t\t\tif (etype_ether->kw_mask[i] != etype_tag2->kw_mask[i]) {\n\t\t\t\tdev_err(rvu->dev, \"mkex: Etype pos is different for untagged and double tagged pkts.\\n\");\n\t\t\t\tgoto vlan_tci;\n\t\t\t}\n\t\t}\n\t\tkey_fields[NPC_ETYPE] = *etype_tag2;\n\t}\n\tif (etype_tag1->nr_kws && etype_tag2->nr_kws) {\n\t\tfor (i = 0; i < NPC_MAX_KWS_IN_KEY; i++) {\n\t\t\tif (etype_tag1->kw_mask[i] != etype_tag2->kw_mask[i]) {\n\t\t\t\tdev_err(rvu->dev, \"mkex: Etype pos is different for tagged and double tagged pkts.\\n\");\n\t\t\t\tgoto vlan_tci;\n\t\t\t}\n\t\t}\n\t\tkey_fields[NPC_ETYPE] = *etype_tag2;\n\t}\n\n\t \n\tstart_lid = key_fields[NPC_ETYPE].layer_mdata.lid + 1;\n\tif (npc_check_overlap(rvu, blkaddr, NPC_ETYPE, start_lid, intf)) {\n\t\tdev_err(rvu->dev, \"mkex: Ethertype is overwritten by higher layers.\\n\");\n\t\tgoto vlan_tci;\n\t}\n\t*features |= BIT_ULL(NPC_ETYPE);\nvlan_tci:\n\t \n\tif (!vlan_tag1->nr_kws && !vlan_tag2->nr_kws) {\n\t\tdev_err(rvu->dev, \"mkex: Outer vlan tci is not extracted.\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tif (vlan_tag1->nr_kws && !vlan_tag2->nr_kws)\n\t\tkey_fields[NPC_OUTER_VID] = *vlan_tag1;\n\tif (!vlan_tag1->nr_kws && vlan_tag2->nr_kws)\n\t\tkey_fields[NPC_OUTER_VID] = *vlan_tag2;\n\n\t \n\tif (vlan_tag1->nr_kws && vlan_tag2->nr_kws) {\n\t\tfor (i = 0; i < NPC_MAX_KWS_IN_KEY; i++) {\n\t\t\tif (vlan_tag1->kw_mask[i] != vlan_tag2->kw_mask[i]) {\n\t\t\t\tdev_err(rvu->dev, \"mkex: Out vlan tci pos is different for tagged and double tagged pkts.\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tkey_fields[NPC_OUTER_VID] = *vlan_tag2;\n\t}\n\t \n\tstart_lid = key_fields[NPC_OUTER_VID].layer_mdata.lid + 1;\n\tif (npc_check_overlap(rvu, blkaddr, NPC_OUTER_VID, start_lid, intf)) {\n\t\tdev_err(rvu->dev, \"mkex: Outer vlan tci is overwritten by higher layers.\\n\");\n\t\tgoto done;\n\t}\n\t*features |= BIT_ULL(NPC_OUTER_VID);\n\n\t \n\tif (vlan_tag3->nr_kws) {\n\t\tkey_fields[NPC_INNER_VID] = *vlan_tag3;\n\t\t*features |= BIT_ULL(NPC_INNER_VID);\n\t}\ndone:\n\treturn;\n}\n\nstatic void npc_scan_ldata(struct rvu *rvu, int blkaddr, u8 lid,\n\t\t\t   u8 lt, u64 cfg, u8 intf)\n{\n\tstruct npc_mcam_kex_hash *mkex_hash = rvu->kpu.mkex_hash;\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu8 hdr, key, nr_bytes, bit_offset;\n\tu8 la_ltype, la_start;\n\t \n\tint start_kwi, offset;\n\n\tnr_bytes = FIELD_GET(NPC_BYTESM, cfg) + 1;\n\thdr = FIELD_GET(NPC_HDR_OFFSET, cfg);\n\tkey = FIELD_GET(NPC_KEY_OFFSET, cfg);\n\n\t \n\tif (is_npc_intf_tx(intf)) {\n\t\tla_ltype = NPC_LT_LA_IH_NIX_ETHER;\n\t\tla_start = 8;\n\t} else {\n\t\tla_ltype = NPC_LT_LA_ETHER;\n\t\tla_start = 0;\n\t}\n\n#define NPC_SCAN_HDR(name, hlid, hlt, hstart, hlen)\t\t\t       \\\ndo {\t\t\t\t\t\t\t\t\t       \\\n\tstart_kwi = key / 8;\t\t\t\t\t\t       \\\n\toffset = (key * 8) % 64;\t\t\t\t\t       \\\n\tif (lid == (hlid) && lt == (hlt)) {\t\t\t\t       \\\n\t\tif ((hstart) >= hdr &&\t\t\t\t\t       \\\n\t\t    ((hstart) + (hlen)) <= (hdr + nr_bytes)) {\t               \\\n\t\t\tbit_offset = (hdr + nr_bytes - (hstart) - (hlen)) * 8; \\\n\t\t\tnpc_set_layer_mdata(mcam, (name), cfg, lid, lt, intf); \\\n\t\t\toffset += bit_offset;\t\t\t\t       \\\n\t\t\tstart_kwi += offset / 64;\t\t\t       \\\n\t\t\toffset %= 64;\t\t\t\t\t       \\\n\t\t\tnpc_set_kw_masks(mcam, (name), (hlen) * 8,\t       \\\n\t\t\t\t\t start_kwi, offset, intf);\t       \\\n\t\t}\t\t\t\t\t\t\t       \\\n\t}\t\t\t\t\t\t\t\t       \\\n} while (0)\n\n\t \n\tNPC_SCAN_HDR(NPC_TOS, NPC_LID_LC, NPC_LT_LC_IP, 1, 1);\n\tNPC_SCAN_HDR(NPC_IPFRAG_IPV4, NPC_LID_LC, NPC_LT_LC_IP, 6, 1);\n\tNPC_SCAN_HDR(NPC_SIP_IPV4, NPC_LID_LC, NPC_LT_LC_IP, 12, 4);\n\tNPC_SCAN_HDR(NPC_DIP_IPV4, NPC_LID_LC, NPC_LT_LC_IP, 16, 4);\n\tNPC_SCAN_HDR(NPC_IPFRAG_IPV6, NPC_LID_LC, NPC_LT_LC_IP6_EXT, 6, 1);\n\tif (rvu->hw->cap.npc_hash_extract) {\n\t\tif (mkex_hash->lid_lt_ld_hash_en[intf][lid][lt][0])\n\t\t\tNPC_SCAN_HDR(NPC_SIP_IPV6, NPC_LID_LC, NPC_LT_LC_IP6, 8, 4);\n\t\telse\n\t\t\tNPC_SCAN_HDR(NPC_SIP_IPV6, NPC_LID_LC, NPC_LT_LC_IP6, 8, 16);\n\n\t\tif (mkex_hash->lid_lt_ld_hash_en[intf][lid][lt][1])\n\t\t\tNPC_SCAN_HDR(NPC_DIP_IPV6, NPC_LID_LC, NPC_LT_LC_IP6, 24, 4);\n\t\telse\n\t\t\tNPC_SCAN_HDR(NPC_DIP_IPV6, NPC_LID_LC, NPC_LT_LC_IP6, 24, 16);\n\t} else {\n\t\tNPC_SCAN_HDR(NPC_SIP_IPV6, NPC_LID_LC, NPC_LT_LC_IP6, 8, 16);\n\t\tNPC_SCAN_HDR(NPC_DIP_IPV6, NPC_LID_LC, NPC_LT_LC_IP6, 24, 16);\n\t}\n\n\tNPC_SCAN_HDR(NPC_SPORT_UDP, NPC_LID_LD, NPC_LT_LD_UDP, 0, 2);\n\tNPC_SCAN_HDR(NPC_DPORT_UDP, NPC_LID_LD, NPC_LT_LD_UDP, 2, 2);\n\tNPC_SCAN_HDR(NPC_SPORT_TCP, NPC_LID_LD, NPC_LT_LD_TCP, 0, 2);\n\tNPC_SCAN_HDR(NPC_DPORT_TCP, NPC_LID_LD, NPC_LT_LD_TCP, 2, 2);\n\tNPC_SCAN_HDR(NPC_SPORT_SCTP, NPC_LID_LD, NPC_LT_LD_SCTP, 0, 2);\n\tNPC_SCAN_HDR(NPC_DPORT_SCTP, NPC_LID_LD, NPC_LT_LD_SCTP, 2, 2);\n\tNPC_SCAN_HDR(NPC_ETYPE_ETHER, NPC_LID_LA, NPC_LT_LA_ETHER, 12, 2);\n\tNPC_SCAN_HDR(NPC_ETYPE_TAG1, NPC_LID_LB, NPC_LT_LB_CTAG, 4, 2);\n\tNPC_SCAN_HDR(NPC_ETYPE_TAG2, NPC_LID_LB, NPC_LT_LB_STAG_QINQ, 8, 2);\n\tNPC_SCAN_HDR(NPC_VLAN_TAG1, NPC_LID_LB, NPC_LT_LB_CTAG, 2, 2);\n\tNPC_SCAN_HDR(NPC_VLAN_TAG2, NPC_LID_LB, NPC_LT_LB_STAG_QINQ, 2, 2);\n\tNPC_SCAN_HDR(NPC_VLAN_TAG3, NPC_LID_LB, NPC_LT_LB_STAG_QINQ, 6, 2);\n\tNPC_SCAN_HDR(NPC_DMAC, NPC_LID_LA, la_ltype, la_start, 6);\n\n\tNPC_SCAN_HDR(NPC_IPSEC_SPI, NPC_LID_LD, NPC_LT_LD_AH, 4, 4);\n\tNPC_SCAN_HDR(NPC_IPSEC_SPI, NPC_LID_LE, NPC_LT_LE_ESP, 0, 4);\n\n\t \n\tNPC_SCAN_HDR(NPC_SMAC, NPC_LID_LA, la_ltype, la_start + 6, 6);\n\t \n\tNPC_SCAN_HDR(NPC_PF_FUNC, NPC_LID_LA, NPC_LT_LA_IH_NIX_ETHER, 0, 2);\n}\n\nstatic void npc_set_features(struct rvu *rvu, int blkaddr, u8 intf)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu64 *features = &mcam->rx_features;\n\tu64 tcp_udp_sctp;\n\tint hdr;\n\n\tif (is_npc_intf_tx(intf))\n\t\tfeatures = &mcam->tx_features;\n\n\tfor (hdr = NPC_DMAC; hdr < NPC_HEADER_FIELDS_MAX; hdr++) {\n\t\tif (npc_check_field(rvu, blkaddr, hdr, intf))\n\t\t\t*features |= BIT_ULL(hdr);\n\t}\n\n\ttcp_udp_sctp = BIT_ULL(NPC_SPORT_TCP) | BIT_ULL(NPC_SPORT_UDP) |\n\t\t       BIT_ULL(NPC_DPORT_TCP) | BIT_ULL(NPC_DPORT_UDP) |\n\t\t       BIT_ULL(NPC_SPORT_SCTP) | BIT_ULL(NPC_DPORT_SCTP);\n\n\t \n\tif (*features & tcp_udp_sctp) {\n\t\tif (!npc_check_field(rvu, blkaddr, NPC_LD, intf))\n\t\t\t*features &= ~tcp_udp_sctp;\n\t\telse\n\t\t\t*features |= BIT_ULL(NPC_IPPROTO_TCP) |\n\t\t\t\t     BIT_ULL(NPC_IPPROTO_UDP) |\n\t\t\t\t     BIT_ULL(NPC_IPPROTO_SCTP);\n\t}\n\n\t \n\tif (npc_check_field(rvu, blkaddr, NPC_LD, intf)) {\n\t\t*features |= BIT_ULL(NPC_IPPROTO_AH);\n\t\t*features |= BIT_ULL(NPC_IPPROTO_ICMP);\n\t\t*features |= BIT_ULL(NPC_IPPROTO_ICMP6);\n\t}\n\n\t \n\tif (npc_check_field(rvu, blkaddr, NPC_LE, intf))\n\t\t*features |= BIT_ULL(NPC_IPPROTO_ESP);\n\n\t \n\tif (*features & BIT_ULL(NPC_OUTER_VID))\n\t\tif (!npc_check_field(rvu, blkaddr, NPC_LB, intf))\n\t\t\t*features &= ~BIT_ULL(NPC_OUTER_VID);\n\n\t \n\tif (npc_check_field(rvu, blkaddr, NPC_IPSEC_SPI, intf) &&\n\t    (*features & (BIT_ULL(NPC_IPPROTO_ESP) | BIT_ULL(NPC_IPPROTO_AH))))\n\t\t*features |= BIT_ULL(NPC_IPSEC_SPI);\n\n\t \n\tif (npc_check_field(rvu, blkaddr, NPC_LB, intf))\n\t\t*features |= BIT_ULL(NPC_VLAN_ETYPE_CTAG) |\n\t\t\t     BIT_ULL(NPC_VLAN_ETYPE_STAG);\n\n\t \n\tif (npc_check_field(rvu, blkaddr, NPC_LXMB, intf))\n\t\t*features |= BIT_ULL(NPC_LXMB);\n}\n\n \nstatic int npc_scan_kex(struct rvu *rvu, int blkaddr, u8 intf)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu8 lid, lt, ld, bitnr;\n\tu64 cfg, masked_cfg;\n\tu8 key_nibble = 0;\n\n\t \n\tcfg = rvu_read64(rvu, blkaddr, NPC_AF_INTFX_KEX_CFG(intf));\n\tmasked_cfg = cfg & NPC_PARSE_NIBBLE;\n\tfor_each_set_bit(bitnr, (unsigned long *)&masked_cfg, 31) {\n\t\tnpc_scan_parse_result(mcam, bitnr, key_nibble, intf);\n\t\tkey_nibble++;\n\t}\n\n\t \n\tmasked_cfg = cfg & NPC_EXACT_NIBBLE;\n\tbitnr = NPC_EXACT_NIBBLE_START;\n\tfor_each_set_bit_from(bitnr, (unsigned long *)&masked_cfg, NPC_EXACT_NIBBLE_END + 1) {\n\t\tnpc_scan_exact_result(mcam, bitnr, key_nibble, intf);\n\t\tkey_nibble++;\n\t}\n\n\t \n\tfor (lid = 0; lid < NPC_MAX_LID; lid++) {\n\t\tfor (lt = 0; lt < NPC_MAX_LT; lt++) {\n\t\t\tfor (ld = 0; ld < NPC_MAX_LD; ld++) {\n\t\t\t\tcfg = rvu_read64(rvu, blkaddr,\n\t\t\t\t\t\t NPC_AF_INTFX_LIDX_LTX_LDX_CFG\n\t\t\t\t\t\t (intf, lid, lt, ld));\n\t\t\t\tif (!FIELD_GET(NPC_LDATA_EN, cfg))\n\t\t\t\t\tcontinue;\n\t\t\t\tnpc_scan_ldata(rvu, blkaddr, lid, lt, cfg,\n\t\t\t\t\t       intf);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int npc_scan_verify_kex(struct rvu *rvu, int blkaddr)\n{\n\tint err;\n\n\terr = npc_scan_kex(rvu, blkaddr, NIX_INTF_RX);\n\tif (err)\n\t\treturn err;\n\n\terr = npc_scan_kex(rvu, blkaddr, NIX_INTF_TX);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!npc_is_field_present(rvu, NPC_CHAN, NIX_INTF_RX)) {\n\t\tdev_err(rvu->dev, \"Channel not present in Key\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (npc_check_overlap(rvu, blkaddr, NPC_CHAN, 0, NIX_INTF_RX)) {\n\t\tdev_err(rvu->dev, \"Channel cannot be overwritten\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnpc_set_features(rvu, blkaddr, NIX_INTF_TX);\n\tnpc_set_features(rvu, blkaddr, NIX_INTF_RX);\n\tnpc_handle_multi_layer_fields(rvu, blkaddr, NIX_INTF_TX);\n\tnpc_handle_multi_layer_fields(rvu, blkaddr, NIX_INTF_RX);\n\n\treturn 0;\n}\n\nint npc_flow_steering_init(struct rvu *rvu, int blkaddr)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\n\tINIT_LIST_HEAD(&mcam->mcam_rules);\n\n\treturn npc_scan_verify_kex(rvu, blkaddr);\n}\n\nstatic int npc_check_unsupported_flows(struct rvu *rvu, u64 features, u8 intf)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tu64 *mcam_features = &mcam->rx_features;\n\tu64 unsupported;\n\tu8 bit;\n\n\tif (is_npc_intf_tx(intf))\n\t\tmcam_features = &mcam->tx_features;\n\n\tunsupported = (*mcam_features ^ features) & ~(*mcam_features);\n\tif (unsupported) {\n\t\tdev_warn(rvu->dev, \"Unsupported flow(s):\\n\");\n\t\tfor_each_set_bit(bit, (unsigned long *)&unsupported, 64)\n\t\t\tdev_warn(rvu->dev, \"%s \", npc_get_field_name(bit));\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nvoid npc_update_entry(struct rvu *rvu, enum key_fields type,\n\t\t      struct mcam_entry *entry, u64 val_lo,\n\t\t      u64 val_hi, u64 mask_lo, u64 mask_hi, u8 intf)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct mcam_entry dummy = { {0} };\n\tstruct npc_key_field *field;\n\tu64 kw1, kw2, kw3;\n\tu8 shift;\n\tint i;\n\n\tfield = &mcam->rx_key_fields[type];\n\tif (is_npc_intf_tx(intf))\n\t\tfield = &mcam->tx_key_fields[type];\n\n\tif (!field->nr_kws)\n\t\treturn;\n\n\tfor (i = 0; i < NPC_MAX_KWS_IN_KEY; i++) {\n\t\tif (!field->kw_mask[i])\n\t\t\tcontinue;\n\t\t \n\t\tshift = __ffs64(field->kw_mask[i]);\n\t\t \n\t\tkw1 = (val_lo << shift) & field->kw_mask[i];\n\t\tdummy.kw[i] = kw1;\n\t\t \n\t\tkw1 = (mask_lo << shift) & field->kw_mask[i];\n\t\tdummy.kw_mask[i] = kw1;\n\n\t\tif (field->nr_kws == 1)\n\t\t\tbreak;\n\t\t \n\t\tif (field->nr_kws == 2) {\n\t\t\t \n\t\t\tkw2 = shift ? val_lo >> (64 - shift) : 0;\n\t\t\tkw2 |= (val_hi << shift);\n\t\t\tkw2 &= field->kw_mask[i + 1];\n\t\t\tdummy.kw[i + 1] = kw2;\n\t\t\t \n\t\t\tkw2 = shift ? mask_lo >> (64 - shift) : 0;\n\t\t\tkw2 |= (mask_hi << shift);\n\t\t\tkw2 &= field->kw_mask[i + 1];\n\t\t\tdummy.kw_mask[i + 1] = kw2;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (field->nr_kws == 3) {\n\t\t\t \n\t\t\tkw2 = shift ? val_lo >> (64 - shift) : 0;\n\t\t\tkw2 |= (val_hi << shift);\n\t\t\tkw2 &= field->kw_mask[i + 1];\n\t\t\tkw3 = shift ? val_hi >> (64 - shift) : 0;\n\t\t\tkw3 &= field->kw_mask[i + 2];\n\t\t\tdummy.kw[i + 1] = kw2;\n\t\t\tdummy.kw[i + 2] = kw3;\n\t\t\t \n\t\t\tkw2 = shift ? mask_lo >> (64 - shift) : 0;\n\t\t\tkw2 |= (mask_hi << shift);\n\t\t\tkw2 &= field->kw_mask[i + 1];\n\t\t\tkw3 = shift ? mask_hi >> (64 - shift) : 0;\n\t\t\tkw3 &= field->kw_mask[i + 2];\n\t\t\tdummy.kw_mask[i + 1] = kw2;\n\t\t\tdummy.kw_mask[i + 2] = kw3;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tfor (i = 0; i < NPC_MAX_KWS_IN_KEY; i++) {\n\t\tif (!field->kw_mask[i])\n\t\t\tcontinue;\n\t\tentry->kw[i] &= ~field->kw_mask[i];\n\t\tentry->kw_mask[i] &= ~field->kw_mask[i];\n\n\t\tentry->kw[i] |= dummy.kw[i];\n\t\tentry->kw_mask[i] |= dummy.kw_mask[i];\n\t}\n}\n\nstatic void npc_update_ipv6_flow(struct rvu *rvu, struct mcam_entry *entry,\n\t\t\t\t u64 features, struct flow_msg *pkt,\n\t\t\t\t struct flow_msg *mask,\n\t\t\t\t struct rvu_npc_mcam_rule *output, u8 intf)\n{\n\tu32 src_ip[IPV6_WORDS], src_ip_mask[IPV6_WORDS];\n\tu32 dst_ip[IPV6_WORDS], dst_ip_mask[IPV6_WORDS];\n\tstruct flow_msg *opkt = &output->packet;\n\tstruct flow_msg *omask = &output->mask;\n\tu64 mask_lo, mask_hi;\n\tu64 val_lo, val_hi;\n\n\t \n\tif (features & BIT_ULL(NPC_SIP_IPV6)) {\n\t\tbe32_to_cpu_array(src_ip_mask, mask->ip6src, IPV6_WORDS);\n\t\tbe32_to_cpu_array(src_ip, pkt->ip6src, IPV6_WORDS);\n\n\t\tmask_hi = (u64)src_ip_mask[0] << 32 | src_ip_mask[1];\n\t\tmask_lo = (u64)src_ip_mask[2] << 32 | src_ip_mask[3];\n\t\tval_hi = (u64)src_ip[0] << 32 | src_ip[1];\n\t\tval_lo = (u64)src_ip[2] << 32 | src_ip[3];\n\n\t\tnpc_update_entry(rvu, NPC_SIP_IPV6, entry, val_lo, val_hi,\n\t\t\t\t mask_lo, mask_hi, intf);\n\t\tmemcpy(opkt->ip6src, pkt->ip6src, sizeof(opkt->ip6src));\n\t\tmemcpy(omask->ip6src, mask->ip6src, sizeof(omask->ip6src));\n\t}\n\tif (features & BIT_ULL(NPC_DIP_IPV6)) {\n\t\tbe32_to_cpu_array(dst_ip_mask, mask->ip6dst, IPV6_WORDS);\n\t\tbe32_to_cpu_array(dst_ip, pkt->ip6dst, IPV6_WORDS);\n\n\t\tmask_hi = (u64)dst_ip_mask[0] << 32 | dst_ip_mask[1];\n\t\tmask_lo = (u64)dst_ip_mask[2] << 32 | dst_ip_mask[3];\n\t\tval_hi = (u64)dst_ip[0] << 32 | dst_ip[1];\n\t\tval_lo = (u64)dst_ip[2] << 32 | dst_ip[3];\n\n\t\tnpc_update_entry(rvu, NPC_DIP_IPV6, entry, val_lo, val_hi,\n\t\t\t\t mask_lo, mask_hi, intf);\n\t\tmemcpy(opkt->ip6dst, pkt->ip6dst, sizeof(opkt->ip6dst));\n\t\tmemcpy(omask->ip6dst, mask->ip6dst, sizeof(omask->ip6dst));\n\t}\n}\n\nstatic void npc_update_vlan_features(struct rvu *rvu, struct mcam_entry *entry,\n\t\t\t\t     u64 features, u8 intf)\n{\n\tbool ctag = !!(features & BIT_ULL(NPC_VLAN_ETYPE_CTAG));\n\tbool stag = !!(features & BIT_ULL(NPC_VLAN_ETYPE_STAG));\n\tbool vid = !!(features & BIT_ULL(NPC_OUTER_VID));\n\n\t \n\tif (vid && !ctag && !stag) {\n\t\tnpc_update_entry(rvu, NPC_LB, entry,\n\t\t\t\t NPC_LT_LB_STAG_QINQ | NPC_LT_LB_CTAG, 0,\n\t\t\t\t NPC_LT_LB_STAG_QINQ & NPC_LT_LB_CTAG, 0, intf);\n\t\treturn;\n\t}\n\tif (ctag)\n\t\tnpc_update_entry(rvu, NPC_LB, entry, NPC_LT_LB_CTAG, 0,\n\t\t\t\t ~0ULL, 0, intf);\n\tif (stag)\n\t\tnpc_update_entry(rvu, NPC_LB, entry, NPC_LT_LB_STAG_QINQ, 0,\n\t\t\t\t ~0ULL, 0, intf);\n}\n\nstatic void npc_update_flow(struct rvu *rvu, struct mcam_entry *entry,\n\t\t\t    u64 features, struct flow_msg *pkt,\n\t\t\t    struct flow_msg *mask,\n\t\t\t    struct rvu_npc_mcam_rule *output, u8 intf,\n\t\t\t    int blkaddr)\n{\n\tu64 dmac_mask = ether_addr_to_u64(mask->dmac);\n\tu64 smac_mask = ether_addr_to_u64(mask->smac);\n\tu64 dmac_val = ether_addr_to_u64(pkt->dmac);\n\tu64 smac_val = ether_addr_to_u64(pkt->smac);\n\tstruct flow_msg *opkt = &output->packet;\n\tstruct flow_msg *omask = &output->mask;\n\n\tif (!features)\n\t\treturn;\n\n\t \n\tif (features & BIT_ULL(NPC_IPPROTO_TCP))\n\t\tnpc_update_entry(rvu, NPC_LD, entry, NPC_LT_LD_TCP,\n\t\t\t\t 0, ~0ULL, 0, intf);\n\tif (features & BIT_ULL(NPC_IPPROTO_UDP))\n\t\tnpc_update_entry(rvu, NPC_LD, entry, NPC_LT_LD_UDP,\n\t\t\t\t 0, ~0ULL, 0, intf);\n\tif (features & BIT_ULL(NPC_IPPROTO_SCTP))\n\t\tnpc_update_entry(rvu, NPC_LD, entry, NPC_LT_LD_SCTP,\n\t\t\t\t 0, ~0ULL, 0, intf);\n\tif (features & BIT_ULL(NPC_IPPROTO_ICMP))\n\t\tnpc_update_entry(rvu, NPC_LD, entry, NPC_LT_LD_ICMP,\n\t\t\t\t 0, ~0ULL, 0, intf);\n\tif (features & BIT_ULL(NPC_IPPROTO_ICMP6))\n\t\tnpc_update_entry(rvu, NPC_LD, entry, NPC_LT_LD_ICMP6,\n\t\t\t\t 0, ~0ULL, 0, intf);\n\n\t \n\tif (features & BIT_ULL(NPC_IPPROTO_AH))\n\t\tnpc_update_entry(rvu, NPC_LD, entry, NPC_LT_LD_AH,\n\t\t\t\t 0, ~0ULL, 0, intf);\n\t \n\tif (features & BIT_ULL(NPC_IPPROTO_ESP))\n\t\tnpc_update_entry(rvu, NPC_LE, entry, NPC_LT_LE_ESP,\n\t\t\t\t 0, ~0ULL, 0, intf);\n\n\tif (features & BIT_ULL(NPC_LXMB)) {\n\t\toutput->lxmb = is_broadcast_ether_addr(pkt->dmac) ? 2 : 1;\n\t\tnpc_update_entry(rvu, NPC_LXMB, entry, output->lxmb, 0,\n\t\t\t\t output->lxmb, 0, intf);\n\t}\n#define NPC_WRITE_FLOW(field, member, val_lo, val_hi, mask_lo, mask_hi)\t      \\\ndo {\t\t\t\t\t\t\t\t\t      \\\n\tif (features & BIT_ULL((field))) {\t\t\t\t      \\\n\t\tnpc_update_entry(rvu, (field), entry, (val_lo), (val_hi),     \\\n\t\t\t\t (mask_lo), (mask_hi), intf);\t\t      \\\n\t\tmemcpy(&opkt->member, &pkt->member, sizeof(pkt->member));     \\\n\t\tmemcpy(&omask->member, &mask->member, sizeof(mask->member));  \\\n\t}\t\t\t\t\t\t\t\t      \\\n} while (0)\n\n\tNPC_WRITE_FLOW(NPC_DMAC, dmac, dmac_val, 0, dmac_mask, 0);\n\n\tNPC_WRITE_FLOW(NPC_SMAC, smac, smac_val, 0, smac_mask, 0);\n\tNPC_WRITE_FLOW(NPC_ETYPE, etype, ntohs(pkt->etype), 0,\n\t\t       ntohs(mask->etype), 0);\n\tNPC_WRITE_FLOW(NPC_TOS, tos, pkt->tos, 0, mask->tos, 0);\n\tNPC_WRITE_FLOW(NPC_IPFRAG_IPV4, ip_flag, pkt->ip_flag, 0,\n\t\t       mask->ip_flag, 0);\n\tNPC_WRITE_FLOW(NPC_SIP_IPV4, ip4src, ntohl(pkt->ip4src), 0,\n\t\t       ntohl(mask->ip4src), 0);\n\tNPC_WRITE_FLOW(NPC_DIP_IPV4, ip4dst, ntohl(pkt->ip4dst), 0,\n\t\t       ntohl(mask->ip4dst), 0);\n\tNPC_WRITE_FLOW(NPC_SPORT_TCP, sport, ntohs(pkt->sport), 0,\n\t\t       ntohs(mask->sport), 0);\n\tNPC_WRITE_FLOW(NPC_SPORT_UDP, sport, ntohs(pkt->sport), 0,\n\t\t       ntohs(mask->sport), 0);\n\tNPC_WRITE_FLOW(NPC_DPORT_TCP, dport, ntohs(pkt->dport), 0,\n\t\t       ntohs(mask->dport), 0);\n\tNPC_WRITE_FLOW(NPC_DPORT_UDP, dport, ntohs(pkt->dport), 0,\n\t\t       ntohs(mask->dport), 0);\n\tNPC_WRITE_FLOW(NPC_SPORT_SCTP, sport, ntohs(pkt->sport), 0,\n\t\t       ntohs(mask->sport), 0);\n\tNPC_WRITE_FLOW(NPC_DPORT_SCTP, dport, ntohs(pkt->dport), 0,\n\t\t       ntohs(mask->dport), 0);\n\n\tNPC_WRITE_FLOW(NPC_IPSEC_SPI, spi, ntohl(pkt->spi), 0,\n\t\t       ntohl(mask->spi), 0);\n\n\tNPC_WRITE_FLOW(NPC_OUTER_VID, vlan_tci, ntohs(pkt->vlan_tci), 0,\n\t\t       ntohs(mask->vlan_tci), 0);\n\tNPC_WRITE_FLOW(NPC_INNER_VID, vlan_itci, ntohs(pkt->vlan_itci), 0,\n\t\t       ntohs(mask->vlan_itci), 0);\n\n\tNPC_WRITE_FLOW(NPC_IPFRAG_IPV6, next_header, pkt->next_header, 0,\n\t\t       mask->next_header, 0);\n\tnpc_update_ipv6_flow(rvu, entry, features, pkt, mask, output, intf);\n\tnpc_update_vlan_features(rvu, entry, features, intf);\n\n\tnpc_update_field_hash(rvu, intf, entry, blkaddr, features,\n\t\t\t      pkt, mask, opkt, omask);\n}\n\nstatic struct rvu_npc_mcam_rule *rvu_mcam_find_rule(struct npc_mcam *mcam, u16 entry)\n{\n\tstruct rvu_npc_mcam_rule *iter;\n\n\tmutex_lock(&mcam->lock);\n\tlist_for_each_entry(iter, &mcam->mcam_rules, list) {\n\t\tif (iter->entry == entry) {\n\t\t\tmutex_unlock(&mcam->lock);\n\t\t\treturn iter;\n\t\t}\n\t}\n\tmutex_unlock(&mcam->lock);\n\n\treturn NULL;\n}\n\nstatic void rvu_mcam_add_rule(struct npc_mcam *mcam,\n\t\t\t      struct rvu_npc_mcam_rule *rule)\n{\n\tstruct list_head *head = &mcam->mcam_rules;\n\tstruct rvu_npc_mcam_rule *iter;\n\n\tmutex_lock(&mcam->lock);\n\tlist_for_each_entry(iter, &mcam->mcam_rules, list) {\n\t\tif (iter->entry > rule->entry)\n\t\t\tbreak;\n\t\thead = &iter->list;\n\t}\n\n\tlist_add(&rule->list, head);\n\tmutex_unlock(&mcam->lock);\n}\n\nstatic void rvu_mcam_remove_counter_from_rule(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t\t      struct rvu_npc_mcam_rule *rule)\n{\n\tstruct npc_mcam_oper_counter_req free_req = { 0 };\n\tstruct msg_rsp free_rsp;\n\n\tif (!rule->has_cntr)\n\t\treturn;\n\n\tfree_req.hdr.pcifunc = pcifunc;\n\tfree_req.cntr = rule->cntr;\n\n\trvu_mbox_handler_npc_mcam_free_counter(rvu, &free_req, &free_rsp);\n\trule->has_cntr = false;\n}\n\nstatic void rvu_mcam_add_counter_to_rule(struct rvu *rvu, u16 pcifunc,\n\t\t\t\t\t struct rvu_npc_mcam_rule *rule,\n\t\t\t\t\t struct npc_install_flow_rsp *rsp)\n{\n\tstruct npc_mcam_alloc_counter_req cntr_req = { 0 };\n\tstruct npc_mcam_alloc_counter_rsp cntr_rsp = { 0 };\n\tint err;\n\n\tcntr_req.hdr.pcifunc = pcifunc;\n\tcntr_req.contig = true;\n\tcntr_req.count = 1;\n\n\t \n\terr = rvu_mbox_handler_npc_mcam_alloc_counter(rvu, &cntr_req,\n\t\t\t\t\t\t      &cntr_rsp);\n\tif (!err && cntr_rsp.count) {\n\t\trule->cntr = cntr_rsp.cntr;\n\t\trule->has_cntr = true;\n\t\trsp->counter = rule->cntr;\n\t} else {\n\t\trsp->counter = err;\n\t}\n}\n\nstatic void npc_update_rx_entry(struct rvu *rvu, struct rvu_pfvf *pfvf,\n\t\t\t\tstruct mcam_entry *entry,\n\t\t\t\tstruct npc_install_flow_req *req,\n\t\t\t\tu16 target, bool pf_set_vfs_mac)\n{\n\tstruct rvu_switch *rswitch = &rvu->rswitch;\n\tstruct nix_rx_action action;\n\n\tif (rswitch->mode == DEVLINK_ESWITCH_MODE_SWITCHDEV && pf_set_vfs_mac)\n\t\treq->chan_mask = 0x0;  \n\n\tnpc_update_entry(rvu, NPC_CHAN, entry, req->channel, 0, req->chan_mask,\n\t\t\t 0, NIX_INTF_RX);\n\n\t*(u64 *)&action = 0x00;\n\taction.pf_func = target;\n\taction.op = req->op;\n\taction.index = req->index;\n\taction.match_id = req->match_id;\n\taction.flow_key_alg = req->flow_key_alg;\n\n\tif (req->op == NIX_RX_ACTION_DEFAULT) {\n\t\tif (pfvf->def_ucast_rule) {\n\t\t\taction = pfvf->def_ucast_rule->rx_action;\n\t\t} else {\n\t\t\t \n\t\t\t*(u64 *)&action = 0;\n\t\t\taction.pf_func = target;\n\t\t\taction.op = NIX_RX_ACTIONOP_UCAST;\n\t\t}\n\t}\n\n\tentry->action = *(u64 *)&action;\n\n\t \n\tentry->vtag_action = FIELD_PREP(RX_VTAG0_VALID_BIT, req->vtag0_valid) |\n\t\t\t     FIELD_PREP(RX_VTAG0_TYPE_MASK, req->vtag0_type) |\n\t\t\t     FIELD_PREP(RX_VTAG0_LID_MASK, NPC_LID_LB) |\n\t\t\t     FIELD_PREP(RX_VTAG0_RELPTR_MASK, 0) |\n\t\t\t     FIELD_PREP(RX_VTAG1_VALID_BIT, req->vtag1_valid) |\n\t\t\t     FIELD_PREP(RX_VTAG1_TYPE_MASK, req->vtag1_type) |\n\t\t\t     FIELD_PREP(RX_VTAG1_LID_MASK, NPC_LID_LB) |\n\t\t\t     FIELD_PREP(RX_VTAG1_RELPTR_MASK, 4);\n}\n\nstatic void npc_update_tx_entry(struct rvu *rvu, struct rvu_pfvf *pfvf,\n\t\t\t\tstruct mcam_entry *entry,\n\t\t\t\tstruct npc_install_flow_req *req, u16 target)\n{\n\tstruct nix_tx_action action;\n\tu64 mask = ~0ULL;\n\n\t \n\tif (is_pffunc_af(req->hdr.pcifunc))\n\t\tmask = 0;\n\n\tnpc_update_entry(rvu, NPC_PF_FUNC, entry, (__force u16)htons(target),\n\t\t\t 0, mask, 0, NIX_INTF_TX);\n\n\t*(u64 *)&action = 0x00;\n\taction.op = req->op;\n\taction.index = req->index;\n\taction.match_id = req->match_id;\n\n\tentry->action = *(u64 *)&action;\n\n\t \n\tentry->vtag_action = FIELD_PREP(TX_VTAG0_DEF_MASK, req->vtag0_def) |\n\t\t\t     FIELD_PREP(TX_VTAG0_OP_MASK, req->vtag0_op) |\n\t\t\t     FIELD_PREP(TX_VTAG0_LID_MASK, NPC_LID_LA) |\n\t\t\t     FIELD_PREP(TX_VTAG0_RELPTR_MASK, 20) |\n\t\t\t     FIELD_PREP(TX_VTAG1_DEF_MASK, req->vtag1_def) |\n\t\t\t     FIELD_PREP(TX_VTAG1_OP_MASK, req->vtag1_op) |\n\t\t\t     FIELD_PREP(TX_VTAG1_LID_MASK, NPC_LID_LA) |\n\t\t\t     FIELD_PREP(TX_VTAG1_RELPTR_MASK, 24);\n}\n\nstatic int npc_install_flow(struct rvu *rvu, int blkaddr, u16 target,\n\t\t\t    int nixlf, struct rvu_pfvf *pfvf,\n\t\t\t    struct npc_install_flow_req *req,\n\t\t\t    struct npc_install_flow_rsp *rsp, bool enable,\n\t\t\t    bool pf_set_vfs_mac)\n{\n\tstruct rvu_npc_mcam_rule *def_ucast_rule = pfvf->def_ucast_rule;\n\tu64 features, installed_features, missing_features = 0;\n\tstruct npc_mcam_write_entry_req write_req = { 0 };\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct rvu_npc_mcam_rule dummy = { 0 };\n\tstruct rvu_npc_mcam_rule *rule;\n\tu16 owner = req->hdr.pcifunc;\n\tstruct msg_rsp write_rsp;\n\tstruct mcam_entry *entry;\n\tbool new = false;\n\tu16 entry_index;\n\tint err;\n\n\tinstalled_features = req->features;\n\tfeatures = req->features;\n\tentry = &write_req.entry_data;\n\tentry_index = req->entry;\n\n\tnpc_update_flow(rvu, entry, features, &req->packet, &req->mask, &dummy,\n\t\t\treq->intf, blkaddr);\n\n\tif (is_npc_intf_rx(req->intf))\n\t\tnpc_update_rx_entry(rvu, pfvf, entry, req, target, pf_set_vfs_mac);\n\telse\n\t\tnpc_update_tx_entry(rvu, pfvf, entry, req, target);\n\n\t \n\tif (is_npc_intf_tx(req->intf))\n\t\tgoto find_rule;\n\n\tif (req->default_rule) {\n\t\tentry_index = npc_get_nixlf_mcam_index(mcam, target, nixlf,\n\t\t\t\t\t\t       NIXLF_UCAST_ENTRY);\n\t\tenable = is_mcam_entry_enabled(rvu, mcam, blkaddr, entry_index);\n\t}\n\n\t \n\tif (def_ucast_rule && (req->default_rule && req->append)) {\n\t\tmissing_features = (def_ucast_rule->features ^ features) &\n\t\t\t\t\tdef_ucast_rule->features;\n\t\tif (missing_features)\n\t\t\tnpc_update_flow(rvu, entry, missing_features,\n\t\t\t\t\t&def_ucast_rule->packet,\n\t\t\t\t\t&def_ucast_rule->mask,\n\t\t\t\t\t&dummy, req->intf,\n\t\t\t\t\tblkaddr);\n\t\tinstalled_features = req->features | missing_features;\n\t}\n\nfind_rule:\n\trule = rvu_mcam_find_rule(mcam, entry_index);\n\tif (!rule) {\n\t\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\t\tif (!rule)\n\t\t\treturn -ENOMEM;\n\t\tnew = true;\n\t}\n\n\t \n\tif (!req->default_rule && req->set_cntr && !rule->has_cntr)\n\t\trvu_mcam_add_counter_to_rule(rvu, owner, rule, rsp);\n\n\t \n\tif (!req->set_cntr && rule->has_cntr)\n\t\trvu_mcam_remove_counter_from_rule(rvu, owner, rule);\n\n\twrite_req.hdr.pcifunc = owner;\n\n\t \n\tif (req->default_rule)\n\t\twrite_req.hdr.pcifunc = 0;\n\n\twrite_req.entry = entry_index;\n\twrite_req.intf = req->intf;\n\twrite_req.enable_entry = (u8)enable;\n\t \n\tif (req->set_cntr && rule->has_cntr) {\n\t\trvu_write64(rvu, blkaddr, NPC_AF_MATCH_STATX(rule->cntr), req->cntr_val);\n\t\twrite_req.set_cntr = 1;\n\t\twrite_req.cntr = rule->cntr;\n\t}\n\n\t \n\tmemcpy(&rule->packet, &dummy.packet, sizeof(rule->packet));\n\tmemcpy(&rule->mask, &dummy.mask, sizeof(rule->mask));\n\trule->entry = entry_index;\n\tmemcpy(&rule->rx_action, &entry->action, sizeof(struct nix_rx_action));\n\tif (is_npc_intf_tx(req->intf))\n\t\tmemcpy(&rule->tx_action, &entry->action,\n\t\t       sizeof(struct nix_tx_action));\n\trule->vtag_action = entry->vtag_action;\n\trule->features = installed_features;\n\trule->default_rule = req->default_rule;\n\trule->owner = owner;\n\trule->enable = enable;\n\trule->chan_mask = write_req.entry_data.kw_mask[0] & NPC_KEX_CHAN_MASK;\n\trule->chan = write_req.entry_data.kw[0] & NPC_KEX_CHAN_MASK;\n\trule->chan &= rule->chan_mask;\n\trule->lxmb = dummy.lxmb;\n\tif (is_npc_intf_tx(req->intf))\n\t\trule->intf = pfvf->nix_tx_intf;\n\telse\n\t\trule->intf = pfvf->nix_rx_intf;\n\n\tif (new)\n\t\trvu_mcam_add_rule(mcam, rule);\n\tif (req->default_rule)\n\t\tpfvf->def_ucast_rule = rule;\n\n\t \n\terr = rvu_mbox_handler_npc_mcam_write_entry(rvu, &write_req,\n\t\t\t\t\t\t    &write_rsp);\n\tif (err) {\n\t\trvu_mcam_remove_counter_from_rule(rvu, owner, rule);\n\t\tif (new) {\n\t\t\tlist_del(&rule->list);\n\t\t\tkfree(rule);\n\t\t}\n\t\treturn err;\n\t}\n\n\t \n\tif (pf_set_vfs_mac) {\n\t\tether_addr_copy(pfvf->default_mac, req->packet.dmac);\n\t\tether_addr_copy(pfvf->mac_addr, req->packet.dmac);\n\t\tset_bit(PF_SET_VF_MAC, &pfvf->flags);\n\t}\n\n\tif (test_bit(PF_SET_VF_CFG, &pfvf->flags) &&\n\t    req->vtag0_type == NIX_AF_LFX_RX_VTAG_TYPE7)\n\t\trule->vfvlan_cfg = true;\n\n\tif (is_npc_intf_rx(req->intf) && req->match_id &&\n\t    (req->op == NIX_RX_ACTIONOP_UCAST || req->op == NIX_RX_ACTIONOP_RSS))\n\t\treturn rvu_nix_setup_ratelimit_aggr(rvu, req->hdr.pcifunc,\n\t\t\t\t\t     req->index, req->match_id);\n\n\treturn 0;\n}\n\nint rvu_mbox_handler_npc_install_flow(struct rvu *rvu,\n\t\t\t\t      struct npc_install_flow_req *req,\n\t\t\t\t      struct npc_install_flow_rsp *rsp)\n{\n\tbool from_vf = !!(req->hdr.pcifunc & RVU_PFVF_FUNC_MASK);\n\tstruct rvu_switch *rswitch = &rvu->rswitch;\n\tint blkaddr, nixlf, err;\n\tstruct rvu_pfvf *pfvf;\n\tbool pf_set_vfs_mac = false;\n\tbool enable = true;\n\tu16 target;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0) {\n\t\tdev_err(rvu->dev, \"%s: NPC block not implemented\\n\", __func__);\n\t\treturn NPC_MCAM_INVALID_REQ;\n\t}\n\n\tif (!is_npc_interface_valid(rvu, req->intf))\n\t\treturn NPC_FLOW_INTF_INVALID;\n\n\t \n\tif (npc_check_field(rvu, blkaddr, NPC_DMAC, req->intf))\n\t\tgoto process_flow;\n\n\tif (is_pffunc_af(req->hdr.pcifunc) &&\n\t    req->features & BIT_ULL(NPC_DMAC)) {\n\t\tif (is_unicast_ether_addr(req->packet.dmac)) {\n\t\t\tdev_warn(rvu->dev,\n\t\t\t\t \"%s: mkex profile does not support ucast flow\\n\",\n\t\t\t\t __func__);\n\t\t\treturn NPC_FLOW_NOT_SUPPORTED;\n\t\t}\n\n\t\tif (!npc_is_field_present(rvu, NPC_LXMB, req->intf)) {\n\t\t\tdev_warn(rvu->dev,\n\t\t\t\t \"%s: mkex profile does not support bcast/mcast flow\",\n\t\t\t\t __func__);\n\t\t\treturn NPC_FLOW_NOT_SUPPORTED;\n\t\t}\n\n\t\t \n\t\treq->features &= ~BIT_ULL(NPC_DMAC);\n\t\treq->features |= BIT_ULL(NPC_LXMB);\n\t}\n\nprocess_flow:\n\tif (from_vf && req->default_rule)\n\t\treturn NPC_FLOW_VF_PERM_DENIED;\n\n\t \n\n\t \n\tif (!req->hdr.pcifunc)\n\t\ttarget = req->vf;\n\t \n\telse if (!from_vf && req->vf) {\n\t\ttarget = (req->hdr.pcifunc & ~RVU_PFVF_FUNC_MASK) | req->vf;\n\t\tpf_set_vfs_mac = req->default_rule &&\n\t\t\t\t(req->features & BIT_ULL(NPC_DMAC));\n\t}\n\t \n\telse\n\t\ttarget = req->hdr.pcifunc;\n\n\t \n\tif (!is_pffunc_af(req->hdr.pcifunc))\n\t\treq->chan_mask = 0xFFF;\n\n\terr = npc_check_unsupported_flows(rvu, req->features, req->intf);\n\tif (err)\n\t\treturn NPC_FLOW_NOT_SUPPORTED;\n\n\tpfvf = rvu_get_pfvf(rvu, target);\n\n\t \n\tif (req->hdr.pcifunc && !from_vf && req->vf)\n\t\tset_bit(PF_SET_VF_CFG, &pfvf->flags);\n\n\t \n\tif ((req->features & BIT_ULL(NPC_DMAC)) && is_npc_intf_rx(req->intf) &&\n\t    is_zero_ether_addr(req->packet.dmac)) {\n\t\tether_addr_copy(req->packet.dmac, pfvf->mac_addr);\n\t\teth_broadcast_addr((u8 *)&req->mask.dmac);\n\t}\n\n\t \n\terr = nix_get_nixlf(rvu, target, &nixlf, NULL);\n\tif (err && is_npc_intf_rx(req->intf) && !pf_set_vfs_mac)\n\t\treturn NPC_FLOW_NO_NIXLF;\n\n\t \n\tif (!(is_nixlf_attached(rvu, target) &&\n\t      test_bit(NIXLF_INITIALIZED, &pfvf->flags)))\n\t\tenable = false;\n\n\t \n\tif (is_npc_intf_tx(req->intf))\n\t\tenable = true;\n\n\t \n\tif (from_vf && !enable)\n\t\treturn NPC_FLOW_VF_NOT_INIT;\n\n\t \n\tif (pf_set_vfs_mac && !enable) {\n\t\tether_addr_copy(pfvf->default_mac, req->packet.dmac);\n\t\tether_addr_copy(pfvf->mac_addr, req->packet.dmac);\n\t\tset_bit(PF_SET_VF_MAC, &pfvf->flags);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&rswitch->switch_lock);\n\terr = npc_install_flow(rvu, blkaddr, target, nixlf, pfvf,\n\t\t\t       req, rsp, enable, pf_set_vfs_mac);\n\tmutex_unlock(&rswitch->switch_lock);\n\n\treturn err;\n}\n\nstatic int npc_delete_flow(struct rvu *rvu, struct rvu_npc_mcam_rule *rule,\n\t\t\t   u16 pcifunc)\n{\n\tstruct npc_mcam_ena_dis_entry_req dis_req = { 0 };\n\tstruct msg_rsp dis_rsp;\n\n\tif (rule->default_rule)\n\t\treturn 0;\n\n\tif (rule->has_cntr)\n\t\trvu_mcam_remove_counter_from_rule(rvu, pcifunc, rule);\n\n\tdis_req.hdr.pcifunc = pcifunc;\n\tdis_req.entry = rule->entry;\n\n\tlist_del(&rule->list);\n\tkfree(rule);\n\n\treturn rvu_mbox_handler_npc_mcam_dis_entry(rvu, &dis_req, &dis_rsp);\n}\n\nint rvu_mbox_handler_npc_delete_flow(struct rvu *rvu,\n\t\t\t\t     struct npc_delete_flow_req *req,\n\t\t\t\t     struct npc_delete_flow_rsp *rsp)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct rvu_npc_mcam_rule *iter, *tmp;\n\tu16 pcifunc = req->hdr.pcifunc;\n\tstruct list_head del_list;\n\tint blkaddr;\n\n\tINIT_LIST_HEAD(&del_list);\n\n\tmutex_lock(&mcam->lock);\n\tlist_for_each_entry_safe(iter, tmp, &mcam->mcam_rules, list) {\n\t\tif (iter->owner == pcifunc) {\n\t\t\t \n\t\t\tif (req->all) {\n\t\t\t\tlist_move_tail(&iter->list, &del_list);\n\t\t\t \n\t\t\t} else if (req->end && iter->entry >= req->start &&\n\t\t\t\t   iter->entry <= req->end) {\n\t\t\t\tlist_move_tail(&iter->list, &del_list);\n\t\t\t \n\t\t\t} else if (req->entry == iter->entry) {\n\t\t\t\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\t\t\t\tif (blkaddr)\n\t\t\t\t\trsp->cntr_val = rvu_read64(rvu, blkaddr,\n\t\t\t\t\t\t\t\t   NPC_AF_MATCH_STATX(iter->cntr));\n\t\t\t\tlist_move_tail(&iter->list, &del_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&mcam->lock);\n\n\tlist_for_each_entry_safe(iter, tmp, &del_list, list) {\n\t\tu16 entry = iter->entry;\n\n\t\t \n\t\tmcam->entry2target_pffunc[entry] = 0x0;\n\t\tif (npc_delete_flow(rvu, iter, pcifunc))\n\t\t\tdev_err(rvu->dev, \"rule deletion failed for entry:%u\",\n\t\t\t\tentry);\n\t}\n\n\treturn 0;\n}\n\nstatic int npc_update_dmac_value(struct rvu *rvu, int npcblkaddr,\n\t\t\t\t struct rvu_npc_mcam_rule *rule,\n\t\t\t\t struct rvu_pfvf *pfvf)\n{\n\tstruct npc_mcam_write_entry_req write_req = { 0 };\n\tstruct mcam_entry *entry = &write_req.entry_data;\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct msg_rsp rsp;\n\tu8 intf, enable;\n\tint err;\n\n\tether_addr_copy(rule->packet.dmac, pfvf->mac_addr);\n\n\tnpc_read_mcam_entry(rvu, mcam, npcblkaddr, rule->entry,\n\t\t\t    entry, &intf,  &enable);\n\n\tnpc_update_entry(rvu, NPC_DMAC, entry,\n\t\t\t ether_addr_to_u64(pfvf->mac_addr), 0,\n\t\t\t 0xffffffffffffull, 0, intf);\n\n\twrite_req.hdr.pcifunc = rule->owner;\n\twrite_req.entry = rule->entry;\n\twrite_req.intf = pfvf->nix_rx_intf;\n\n\tmutex_unlock(&mcam->lock);\n\terr = rvu_mbox_handler_npc_mcam_write_entry(rvu, &write_req, &rsp);\n\tmutex_lock(&mcam->lock);\n\n\treturn err;\n}\n\nvoid npc_mcam_enable_flows(struct rvu *rvu, u16 target)\n{\n\tstruct rvu_pfvf *pfvf = rvu_get_pfvf(rvu, target);\n\tstruct rvu_npc_mcam_rule *def_ucast_rule;\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct rvu_npc_mcam_rule *rule;\n\tint blkaddr, bank, index;\n\tu64 def_action;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\tdef_ucast_rule = pfvf->def_ucast_rule;\n\n\tmutex_lock(&mcam->lock);\n\tlist_for_each_entry(rule, &mcam->mcam_rules, list) {\n\t\tif (is_npc_intf_rx(rule->intf) &&\n\t\t    rule->rx_action.pf_func == target && !rule->enable) {\n\t\t\tif (rule->default_rule) {\n\t\t\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr,\n\t\t\t\t\t\t      rule->entry, true);\n\t\t\t\trule->enable = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rule->vfvlan_cfg)\n\t\t\t\tnpc_update_dmac_value(rvu, blkaddr, rule, pfvf);\n\n\t\t\tif (rule->rx_action.op == NIX_RX_ACTION_DEFAULT) {\n\t\t\t\tif (!def_ucast_rule)\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\trule->rx_action = def_ucast_rule->rx_action;\n\t\t\t\tdef_action = *(u64 *)&def_ucast_rule->rx_action;\n\t\t\t\tbank = npc_get_bank(mcam, rule->entry);\n\t\t\t\trvu_write64(rvu, blkaddr,\n\t\t\t\t\t    NPC_AF_MCAMEX_BANKX_ACTION\n\t\t\t\t\t    (rule->entry, bank), def_action);\n\t\t\t}\n\n\t\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr,\n\t\t\t\t\t      rule->entry, true);\n\t\t\trule->enable = true;\n\t\t}\n\t}\n\n\t \n\tfor (index = 0; index < mcam->bmap_entries; index++) {\n\t\tif (mcam->entry2target_pffunc[index] == target)\n\t\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr,\n\t\t\t\t\t      index, true);\n\t}\n\tmutex_unlock(&mcam->lock);\n}\n\nvoid npc_mcam_disable_flows(struct rvu *rvu, u16 target)\n{\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tint blkaddr, index;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn;\n\n\tmutex_lock(&mcam->lock);\n\t \n\tfor (index = 0; index < mcam->bmap_entries; index++) {\n\t\tif (mcam->entry2target_pffunc[index] == target)\n\t\t\tnpc_enable_mcam_entry(rvu, mcam, blkaddr,\n\t\t\t\t\t      index, false);\n\t}\n\tmutex_unlock(&mcam->lock);\n}\n\n \nint npc_install_mcam_drop_rule(struct rvu *rvu, int mcam_idx, u16 *counter_idx,\n\t\t\t       u64 chan_val, u64 chan_mask, u64 exact_val, u64 exact_mask,\n\t\t\t       u64 bcast_mcast_val, u64 bcast_mcast_mask)\n{\n\tstruct npc_mcam_alloc_counter_req cntr_req = { 0 };\n\tstruct npc_mcam_alloc_counter_rsp cntr_rsp = { 0 };\n\tstruct npc_mcam_write_entry_req req = { 0 };\n\tstruct npc_mcam *mcam = &rvu->hw->mcam;\n\tstruct rvu_npc_mcam_rule *rule;\n\tstruct msg_rsp rsp;\n\tbool enabled;\n\tint blkaddr;\n\tint err;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0) {\n\t\tdev_err(rvu->dev, \"%s: NPC block not implemented\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (!rvu_npc_exact_has_match_table(rvu)) {\n\t\tdev_info(rvu->dev, \"%s: No support for exact match feature\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tenabled = is_mcam_entry_enabled(rvu, mcam, blkaddr, mcam_idx);\n\tif (enabled) {\n\t\tdev_err(rvu->dev, \"%s: failed to add single drop on non hit rule at %d th index\\n\",\n\t\t\t__func__, mcam_idx);\n\t\treturn\t-EINVAL;\n\t}\n\n\t \n\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\tif (!rule)\n\t\treturn -ENOMEM;\n\n\t \n\trule->enable = false;\n\trule->chan = chan_val;\n\trule->chan_mask = chan_mask;\n\trule->entry = mcam_idx;\n\trvu_mcam_add_rule(mcam, rule);\n\n\t \n\tnpc_mcam_rsrcs_reserve(rvu, blkaddr, mcam_idx);\n\n\t \n\tcntr_req.hdr.pcifunc = 0;  \n\tcntr_req.contig = true;\n\tcntr_req.count = 1;\n\terr = rvu_mbox_handler_npc_mcam_alloc_counter(rvu, &cntr_req, &cntr_rsp);\n\tif (err) {\n\t\tdev_err(rvu->dev, \"%s: Err to allocate cntr for drop rule (err=%d)\\n\",\n\t\t\t__func__, err);\n\t\treturn\t-EFAULT;\n\t}\n\t*counter_idx = cntr_rsp.cntr;\n\n\t \n\tnpc_update_entry(rvu, NPC_EXACT_RESULT, &req.entry_data, exact_val, 0,\n\t\t\t exact_mask, 0, NIX_INTF_RX);\n\tnpc_update_entry(rvu, NPC_CHAN, &req.entry_data, chan_val, 0,\n\t\t\t chan_mask, 0, NIX_INTF_RX);\n\tnpc_update_entry(rvu, NPC_LXMB, &req.entry_data, bcast_mcast_val, 0,\n\t\t\t bcast_mcast_mask, 0, NIX_INTF_RX);\n\n\treq.intf = NIX_INTF_RX;\n\treq.set_cntr = true;\n\treq.cntr = cntr_rsp.cntr;\n\treq.entry = mcam_idx;\n\n\terr = rvu_mbox_handler_npc_mcam_write_entry(rvu, &req, &rsp);\n\tif (err) {\n\t\tdev_err(rvu->dev, \"%s: Installation of single drop on non hit rule at %d failed\\n\",\n\t\t\t__func__, mcam_idx);\n\t\treturn err;\n\t}\n\n\tdev_err(rvu->dev, \"%s: Installed single drop on non hit rule at %d, cntr=%d\\n\",\n\t\t__func__, mcam_idx, req.cntr);\n\n\t \n\tnpc_enable_mcam_entry(rvu, mcam, blkaddr, mcam_idx, false);\n\n\treturn 0;\n}\n\nint rvu_mbox_handler_npc_get_field_status(struct rvu *rvu,\n\t\t\t\t\t  struct npc_get_field_status_req *req,\n\t\t\t\t\t  struct npc_get_field_status_rsp *rsp)\n{\n\tint blkaddr;\n\n\tblkaddr = rvu_get_blkaddr(rvu, BLKTYPE_NPC, 0);\n\tif (blkaddr < 0)\n\t\treturn NPC_MCAM_INVALID_REQ;\n\n\tif (!is_npc_interface_valid(rvu, req->intf))\n\t\treturn NPC_FLOW_INTF_INVALID;\n\n\tif (npc_check_field(rvu, blkaddr, req->field, req->intf))\n\t\trsp->enable = 1;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}