{
  "module_name": "mcs_cnf10kb.c",
  "hash_id": "d1f06b32a5c1c1c6bed02c9237b2e6f8222cad7190d84b4b5eb30e43aa996f9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/af/mcs_cnf10kb.c",
  "human_readable_source": "\n \n\n#include \"mcs.h\"\n#include \"mcs_reg.h\"\n\nstatic struct mcs_ops cnf10kb_mcs_ops   = {\n\t.mcs_set_hw_capabilities\t= cnf10kb_mcs_set_hw_capabilities,\n\t.mcs_parser_cfg\t\t\t= cnf10kb_mcs_parser_cfg,\n\t.mcs_tx_sa_mem_map_write\t= cnf10kb_mcs_tx_sa_mem_map_write,\n\t.mcs_rx_sa_mem_map_write\t= cnf10kb_mcs_rx_sa_mem_map_write,\n\t.mcs_flowid_secy_map\t\t= cnf10kb_mcs_flowid_secy_map,\n\t.mcs_bbe_intr_handler\t\t= cnf10kb_mcs_bbe_intr_handler,\n\t.mcs_pab_intr_handler\t\t= cnf10kb_mcs_pab_intr_handler,\n};\n\nstruct mcs_ops *cnf10kb_get_mac_ops(void)\n{\n\treturn &cnf10kb_mcs_ops;\n}\n\nvoid cnf10kb_mcs_set_hw_capabilities(struct mcs *mcs)\n{\n\tstruct hwinfo *hw = mcs->hw;\n\n\thw->tcam_entries = 64;\t\t \n\thw->secy_entries  = 64;\t\t \n\thw->sc_entries = 64;\t\t \n\thw->sa_entries = 128;\t\t \n\thw->lmac_cnt = 4;\t\t \n\thw->mcs_x2p_intf = 1;\t\t \n\thw->mcs_blks = 7;\t\t \n\thw->ip_vec = MCS_CNF10KB_INT_VEC_IP;  \n}\n\nvoid cnf10kb_mcs_parser_cfg(struct mcs *mcs)\n{\n\tu64 reg, val;\n\n\t \n\tval = (0x8100ull & 0xFFFF) | BIT_ULL(20) | BIT_ULL(22);\n\n\treg = MCSX_PEX_RX_SLAVE_CUSTOM_TAGX(0);\n\tmcs_reg_write(mcs, reg, val);\n\n\treg = MCSX_PEX_TX_SLAVE_CUSTOM_TAGX(0);\n\tmcs_reg_write(mcs, reg, val);\n\n\t \n\tval = (0x88a8ull & 0xFFFF) | BIT_ULL(20) | BIT_ULL(23);\n\n\t \n\treg = MCSX_PEX_RX_SLAVE_CUSTOM_TAGX(1);\n\tmcs_reg_write(mcs, reg, val);\n\n\t \n\treg = MCSX_PEX_TX_SLAVE_CUSTOM_TAGX(1);\n\tmcs_reg_write(mcs, reg, val);\n\n\t \n\tval = BIT_ULL(0) | BIT_ULL(1) | BIT_ULL(12);\n\n\treg = MCSX_PEX_RX_SLAVE_ETYPE_ENABLE;\n\tmcs_reg_write(mcs, reg, val);\n\n\treg = MCSX_PEX_TX_SLAVE_ETYPE_ENABLE;\n\tmcs_reg_write(mcs, reg, val);\n}\n\nvoid cnf10kb_mcs_flowid_secy_map(struct mcs *mcs, struct secy_mem_map *map, int dir)\n{\n\tu64 reg, val;\n\n\tval = (map->secy & 0x3F) | (map->ctrl_pkt & 0x1) << 6;\n\tif (dir == MCS_RX) {\n\t\treg = MCSX_CPM_RX_SLAVE_SECY_MAP_MEMX(map->flow_id);\n\t} else {\n\t\treg = MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_0X(map->flow_id);\n\t\tmcs_reg_write(mcs, reg, map->sci);\n\t\tval |= (map->sc & 0x3F) << 7;\n\t\treg = MCSX_CPM_TX_SLAVE_SECY_MAP_MEM_1X(map->flow_id);\n\t}\n\n\tmcs_reg_write(mcs, reg, val);\n}\n\nvoid cnf10kb_mcs_tx_sa_mem_map_write(struct mcs *mcs, struct mcs_tx_sc_sa_map *map)\n{\n\tu64 reg, val;\n\n\tval = (map->sa_index0 & 0x7F) | (map->sa_index1 & 0x7F) << 7;\n\n\treg = MCSX_CPM_TX_SLAVE_SA_MAP_MEM_0X(map->sc_id);\n\tmcs_reg_write(mcs, reg, val);\n\n\treg = MCSX_CPM_TX_SLAVE_AUTO_REKEY_ENABLE_0;\n\tval = mcs_reg_read(mcs, reg);\n\n\tif (map->rekey_ena)\n\t\tval |= BIT_ULL(map->sc_id);\n\telse\n\t\tval &= ~BIT_ULL(map->sc_id);\n\n\tmcs_reg_write(mcs, reg, val);\n\n\tmcs_reg_write(mcs, MCSX_CPM_TX_SLAVE_SA_INDEX0_VLDX(map->sc_id), map->sa_index0_vld);\n\tmcs_reg_write(mcs, MCSX_CPM_TX_SLAVE_SA_INDEX1_VLDX(map->sc_id), map->sa_index1_vld);\n\n\tmcs_reg_write(mcs, MCSX_CPM_TX_SLAVE_TX_SA_ACTIVEX(map->sc_id), map->tx_sa_active);\n}\n\nvoid cnf10kb_mcs_rx_sa_mem_map_write(struct mcs *mcs, struct mcs_rx_sc_sa_map *map)\n{\n\tu64 val, reg;\n\n\tval = (map->sa_index & 0x7F) | (map->sa_in_use << 7);\n\n\treg = MCSX_CPM_RX_SLAVE_SA_MAP_MEMX((4 * map->sc_id) + map->an);\n\tmcs_reg_write(mcs, reg, val);\n}\n\nint mcs_set_force_clk_en(struct mcs *mcs, bool set)\n{\n\tunsigned long timeout = jiffies + usecs_to_jiffies(2000);\n\tu64 val;\n\n\tval = mcs_reg_read(mcs, MCSX_MIL_GLOBAL);\n\n\tif (set) {\n\t\tval |= BIT_ULL(4);\n\t\tmcs_reg_write(mcs, MCSX_MIL_GLOBAL, val);\n\n\t\t \n\t\twhile (!(mcs_reg_read(mcs, MCSX_MIL_IP_GBL_STATUS) & BIT_ULL(0))) {\n\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\tdev_err(mcs->dev, \"MCS set force clk enable failed\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tval &= ~BIT_ULL(4);\n\t\tmcs_reg_write(mcs, MCSX_MIL_GLOBAL, val);\n\t}\n\n\treturn 0;\n}\n\n \nvoid cnf10kb_mcs_tx_pn_thresh_reached_handler(struct mcs *mcs)\n{\n\tstruct mcs_intr_event event;\n\tstruct rsrc_bmap *sc_bmap;\n\tunsigned long rekey_ena;\n\tu64 val, sa_status;\n\tint sc;\n\n\tsc_bmap = &mcs->tx.sc;\n\n\tevent.mcs_id = mcs->mcs_id;\n\tevent.intr_mask = MCS_CPM_TX_PN_THRESH_REACHED_INT;\n\n\trekey_ena = mcs_reg_read(mcs, MCSX_CPM_TX_SLAVE_AUTO_REKEY_ENABLE_0);\n\n\tfor_each_set_bit(sc, sc_bmap->bmap, mcs->hw->sc_entries) {\n\t\t \n\t\tif (!test_bit(sc, &rekey_ena))\n\t\t\tcontinue;\n\t\tsa_status = mcs_reg_read(mcs, MCSX_CPM_TX_SLAVE_TX_SA_ACTIVEX(sc));\n\t\t \n\t\tif (sa_status == mcs->tx_sa_active[sc])\n\t\t\tcontinue;\n\n\t\t \n\t\tval = mcs_reg_read(mcs, MCSX_CPM_TX_SLAVE_SA_MAP_MEM_0X(sc));\n\t\tif (sa_status)\n\t\t\tevent.sa_id = val & 0x7F;\n\t\telse\n\t\t\tevent.sa_id = (val >> 7) & 0x7F;\n\n\t\tevent.pcifunc = mcs->tx.sa2pf_map[event.sa_id];\n\t\tmcs_add_intr_wq_entry(mcs, &event);\n\t}\n}\n\nvoid cnf10kb_mcs_tx_pn_wrapped_handler(struct mcs *mcs)\n{\n\tstruct mcs_intr_event event = { 0 };\n\tstruct rsrc_bmap *sc_bmap;\n\tu64 val;\n\tint sc;\n\n\tsc_bmap = &mcs->tx.sc;\n\n\tevent.mcs_id = mcs->mcs_id;\n\tevent.intr_mask = MCS_CPM_TX_PACKET_XPN_EQ0_INT;\n\n\tfor_each_set_bit(sc, sc_bmap->bmap, mcs->hw->sc_entries) {\n\t\tval = mcs_reg_read(mcs, MCSX_CPM_TX_SLAVE_SA_MAP_MEM_0X(sc));\n\n\t\tif (mcs->tx_sa_active[sc])\n\t\t\t \n\t\t\tevent.sa_id = (val >> 7) & 0x7F;\n\t\telse\n\t\t\t \n\t\t\tevent.sa_id = val & 0x7F;\n\n\t\tevent.pcifunc = mcs->tx.sa2pf_map[event.sa_id];\n\t\tmcs_add_intr_wq_entry(mcs, &event);\n\t}\n}\n\nvoid cnf10kb_mcs_bbe_intr_handler(struct mcs *mcs, u64 intr,\n\t\t\t\t  enum mcs_direction dir)\n{\n\tstruct mcs_intr_event event = { 0 };\n\tint i;\n\n\tif (!(intr & MCS_BBE_INT_MASK))\n\t\treturn;\n\n\tevent.mcs_id = mcs->mcs_id;\n\tevent.pcifunc = mcs->pf_map[0];\n\n\tfor (i = 0; i < MCS_MAX_BBE_INT; i++) {\n\t\tif (!(intr & BIT_ULL(i)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (intr & 0xFULL)\n\t\t\tevent.intr_mask = (dir == MCS_RX) ?\n\t\t\t\t\t  MCS_BBE_RX_DFIFO_OVERFLOW_INT :\n\t\t\t\t\t  MCS_BBE_TX_DFIFO_OVERFLOW_INT;\n\t\telse\n\t\t\tevent.intr_mask = (dir == MCS_RX) ?\n\t\t\t\t\t  MCS_BBE_RX_PLFIFO_OVERFLOW_INT :\n\t\t\t\t\t  MCS_BBE_TX_PLFIFO_OVERFLOW_INT;\n\n\t\t \n\t\tevent.lmac_id = i & 0x3ULL;\n\t\tmcs_add_intr_wq_entry(mcs, &event);\n\t}\n}\n\nvoid cnf10kb_mcs_pab_intr_handler(struct mcs *mcs, u64 intr,\n\t\t\t\t  enum mcs_direction dir)\n{\n\tstruct mcs_intr_event event = { 0 };\n\tint i;\n\n\tif (!(intr & MCS_PAB_INT_MASK))\n\t\treturn;\n\n\tevent.mcs_id = mcs->mcs_id;\n\tevent.pcifunc = mcs->pf_map[0];\n\n\tfor (i = 0; i < MCS_MAX_PAB_INT; i++) {\n\t\tif (!(intr & BIT_ULL(i)))\n\t\t\tcontinue;\n\n\t\tevent.intr_mask = (dir == MCS_RX) ?\n\t\t\t\t  MCS_PAB_RX_CHAN_OVERFLOW_INT :\n\t\t\t\t  MCS_PAB_TX_CHAN_OVERFLOW_INT;\n\n\t\t \n\t\tevent.lmac_id = i;\n\t\tmcs_add_intr_wq_entry(mcs, &event);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}