{
  "module_name": "mbox.c",
  "hash_id": "6152825a9354624330e19ed893196488c1e5c87e88e6c5e8369cf225e7b029bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/af/mbox.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n\n#include \"rvu_reg.h\"\n#include \"mbox.h\"\n#include \"rvu_trace.h\"\n\nstatic const u16 msgs_offset = ALIGN(sizeof(struct mbox_hdr), MBOX_MSG_ALIGN);\n\nvoid __otx2_mbox_reset(struct otx2_mbox *mbox, int devid)\n{\n\tstruct otx2_mbox_dev *mdev = &mbox->dev[devid];\n\tstruct mbox_hdr *tx_hdr, *rx_hdr;\n\tvoid *hw_mbase = mdev->hwbase;\n\n\ttx_hdr = hw_mbase + mbox->tx_start;\n\trx_hdr = hw_mbase + mbox->rx_start;\n\n\tmdev->msg_size = 0;\n\tmdev->rsp_size = 0;\n\ttx_hdr->num_msgs = 0;\n\ttx_hdr->msg_size = 0;\n\trx_hdr->num_msgs = 0;\n\trx_hdr->msg_size = 0;\n}\nEXPORT_SYMBOL(__otx2_mbox_reset);\n\nvoid otx2_mbox_reset(struct otx2_mbox *mbox, int devid)\n{\n\tstruct otx2_mbox_dev *mdev = &mbox->dev[devid];\n\n\tspin_lock(&mdev->mbox_lock);\n\t__otx2_mbox_reset(mbox, devid);\n\tspin_unlock(&mdev->mbox_lock);\n}\nEXPORT_SYMBOL(otx2_mbox_reset);\n\nvoid otx2_mbox_destroy(struct otx2_mbox *mbox)\n{\n\tmbox->reg_base = NULL;\n\tmbox->hwbase = NULL;\n\n\tkfree(mbox->dev);\n\tmbox->dev = NULL;\n}\nEXPORT_SYMBOL(otx2_mbox_destroy);\n\nstatic int otx2_mbox_setup(struct otx2_mbox *mbox, struct pci_dev *pdev,\n\t\t\t   void *reg_base, int direction, int ndevs)\n{\n\tswitch (direction) {\n\tcase MBOX_DIR_AFPF:\n\tcase MBOX_DIR_PFVF:\n\t\tmbox->tx_start = MBOX_DOWN_TX_START;\n\t\tmbox->rx_start = MBOX_DOWN_RX_START;\n\t\tmbox->tx_size  = MBOX_DOWN_TX_SIZE;\n\t\tmbox->rx_size  = MBOX_DOWN_RX_SIZE;\n\t\tbreak;\n\tcase MBOX_DIR_PFAF:\n\tcase MBOX_DIR_VFPF:\n\t\tmbox->tx_start = MBOX_DOWN_RX_START;\n\t\tmbox->rx_start = MBOX_DOWN_TX_START;\n\t\tmbox->tx_size  = MBOX_DOWN_RX_SIZE;\n\t\tmbox->rx_size  = MBOX_DOWN_TX_SIZE;\n\t\tbreak;\n\tcase MBOX_DIR_AFPF_UP:\n\tcase MBOX_DIR_PFVF_UP:\n\t\tmbox->tx_start = MBOX_UP_TX_START;\n\t\tmbox->rx_start = MBOX_UP_RX_START;\n\t\tmbox->tx_size  = MBOX_UP_TX_SIZE;\n\t\tmbox->rx_size  = MBOX_UP_RX_SIZE;\n\t\tbreak;\n\tcase MBOX_DIR_PFAF_UP:\n\tcase MBOX_DIR_VFPF_UP:\n\t\tmbox->tx_start = MBOX_UP_RX_START;\n\t\tmbox->rx_start = MBOX_UP_TX_START;\n\t\tmbox->tx_size  = MBOX_UP_RX_SIZE;\n\t\tmbox->rx_size  = MBOX_UP_TX_SIZE;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (direction) {\n\tcase MBOX_DIR_AFPF:\n\tcase MBOX_DIR_AFPF_UP:\n\t\tmbox->trigger = RVU_AF_AFPF_MBOX0;\n\t\tmbox->tr_shift = 4;\n\t\tbreak;\n\tcase MBOX_DIR_PFAF:\n\tcase MBOX_DIR_PFAF_UP:\n\t\tmbox->trigger = RVU_PF_PFAF_MBOX1;\n\t\tmbox->tr_shift = 0;\n\t\tbreak;\n\tcase MBOX_DIR_PFVF:\n\tcase MBOX_DIR_PFVF_UP:\n\t\tmbox->trigger = RVU_PF_VFX_PFVF_MBOX0;\n\t\tmbox->tr_shift = 12;\n\t\tbreak;\n\tcase MBOX_DIR_VFPF:\n\tcase MBOX_DIR_VFPF_UP:\n\t\tmbox->trigger = RVU_VF_VFPF_MBOX1;\n\t\tmbox->tr_shift = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tmbox->reg_base = reg_base;\n\tmbox->pdev = pdev;\n\n\tmbox->dev = kcalloc(ndevs, sizeof(struct otx2_mbox_dev), GFP_KERNEL);\n\tif (!mbox->dev) {\n\t\totx2_mbox_destroy(mbox);\n\t\treturn -ENOMEM;\n\t}\n\tmbox->ndevs = ndevs;\n\n\treturn 0;\n}\n\nint otx2_mbox_init(struct otx2_mbox *mbox, void *hwbase, struct pci_dev *pdev,\n\t\t   void *reg_base, int direction, int ndevs)\n{\n\tstruct otx2_mbox_dev *mdev;\n\tint devid, err;\n\n\terr = otx2_mbox_setup(mbox, pdev, reg_base, direction, ndevs);\n\tif (err)\n\t\treturn err;\n\n\tmbox->hwbase = hwbase;\n\n\tfor (devid = 0; devid < ndevs; devid++) {\n\t\tmdev = &mbox->dev[devid];\n\t\tmdev->mbase = mbox->hwbase + (devid * MBOX_SIZE);\n\t\tmdev->hwbase = mdev->mbase;\n\t\tspin_lock_init(&mdev->mbox_lock);\n\t\t \n\t\totx2_mbox_reset(mbox, devid);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(otx2_mbox_init);\n\n \nint otx2_mbox_regions_init(struct otx2_mbox *mbox, void **hwbase,\n\t\t\t   struct pci_dev *pdev, void *reg_base,\n\t\t\t   int direction, int ndevs, unsigned long *pf_bmap)\n{\n\tstruct otx2_mbox_dev *mdev;\n\tint devid, err;\n\n\terr = otx2_mbox_setup(mbox, pdev, reg_base, direction, ndevs);\n\tif (err)\n\t\treturn err;\n\n\tmbox->hwbase = hwbase[0];\n\n\tfor (devid = 0; devid < ndevs; devid++) {\n\t\tif (!test_bit(devid, pf_bmap))\n\t\t\tcontinue;\n\n\t\tmdev = &mbox->dev[devid];\n\t\tmdev->mbase = hwbase[devid];\n\t\tmdev->hwbase = hwbase[devid];\n\t\tspin_lock_init(&mdev->mbox_lock);\n\t\t \n\t\totx2_mbox_reset(mbox, devid);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(otx2_mbox_regions_init);\n\nint otx2_mbox_wait_for_rsp(struct otx2_mbox *mbox, int devid)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(MBOX_RSP_TIMEOUT);\n\tstruct otx2_mbox_dev *mdev = &mbox->dev[devid];\n\tstruct device *sender = &mbox->pdev->dev;\n\n\twhile (!time_after(jiffies, timeout)) {\n\t\tif (mdev->num_msgs == mdev->msgs_acked)\n\t\t\treturn 0;\n\t\tusleep_range(800, 1000);\n\t}\n\tdev_dbg(sender, \"timed out while waiting for rsp\\n\");\n\treturn -EIO;\n}\nEXPORT_SYMBOL(otx2_mbox_wait_for_rsp);\n\nint otx2_mbox_busy_poll_for_rsp(struct otx2_mbox *mbox, int devid)\n{\n\tstruct otx2_mbox_dev *mdev = &mbox->dev[devid];\n\tunsigned long timeout = jiffies + 1 * HZ;\n\n\twhile (!time_after(jiffies, timeout)) {\n\t\tif (mdev->num_msgs == mdev->msgs_acked)\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t}\n\treturn -EIO;\n}\nEXPORT_SYMBOL(otx2_mbox_busy_poll_for_rsp);\n\nvoid otx2_mbox_msg_send(struct otx2_mbox *mbox, int devid)\n{\n\tstruct otx2_mbox_dev *mdev = &mbox->dev[devid];\n\tstruct mbox_hdr *tx_hdr, *rx_hdr;\n\tvoid *hw_mbase = mdev->hwbase;\n\n\ttx_hdr = hw_mbase + mbox->tx_start;\n\trx_hdr = hw_mbase + mbox->rx_start;\n\n\t \n\tif (mdev->mbase != hw_mbase)\n\t\tmemcpy(hw_mbase + mbox->tx_start + msgs_offset,\n\t\t       mdev->mbase + mbox->tx_start + msgs_offset,\n\t\t       mdev->msg_size);\n\n\tspin_lock(&mdev->mbox_lock);\n\n\ttx_hdr->msg_size = mdev->msg_size;\n\n\t \n\tmdev->msg_size = 0;\n\tmdev->rsp_size = 0;\n\tmdev->msgs_acked = 0;\n\n\t \n\tsmp_wmb();\n\n\t \n\ttx_hdr->num_msgs = mdev->num_msgs;\n\trx_hdr->num_msgs = 0;\n\n\ttrace_otx2_msg_send(mbox->pdev, tx_hdr->num_msgs, tx_hdr->msg_size);\n\n\tspin_unlock(&mdev->mbox_lock);\n\n\t \n\twriteq(1, (void __iomem *)mbox->reg_base +\n\t       (mbox->trigger | (devid << mbox->tr_shift)));\n}\nEXPORT_SYMBOL(otx2_mbox_msg_send);\n\nstruct mbox_msghdr *otx2_mbox_alloc_msg_rsp(struct otx2_mbox *mbox, int devid,\n\t\t\t\t\t    int size, int size_rsp)\n{\n\tstruct otx2_mbox_dev *mdev = &mbox->dev[devid];\n\tstruct mbox_msghdr *msghdr = NULL;\n\n\tspin_lock(&mdev->mbox_lock);\n\tsize = ALIGN(size, MBOX_MSG_ALIGN);\n\tsize_rsp = ALIGN(size_rsp, MBOX_MSG_ALIGN);\n\t \n\tif ((mdev->msg_size + size) > mbox->tx_size - msgs_offset)\n\t\tgoto exit;\n\tif ((mdev->rsp_size + size_rsp) > mbox->rx_size - msgs_offset)\n\t\tgoto exit;\n\n\tif (mdev->msg_size == 0)\n\t\tmdev->num_msgs = 0;\n\tmdev->num_msgs++;\n\n\tmsghdr = mdev->mbase + mbox->tx_start + msgs_offset + mdev->msg_size;\n\n\t \n\tmemset(msghdr, 0, size);\n\t \n\tmsghdr->ver = OTX2_MBOX_VERSION;\n\tmdev->msg_size += size;\n\tmdev->rsp_size += size_rsp;\n\tmsghdr->next_msgoff = mdev->msg_size + msgs_offset;\nexit:\n\tspin_unlock(&mdev->mbox_lock);\n\n\treturn msghdr;\n}\nEXPORT_SYMBOL(otx2_mbox_alloc_msg_rsp);\n\nstruct mbox_msghdr *otx2_mbox_get_rsp(struct otx2_mbox *mbox, int devid,\n\t\t\t\t      struct mbox_msghdr *msg)\n{\n\tunsigned long imsg = mbox->tx_start + msgs_offset;\n\tunsigned long irsp = mbox->rx_start + msgs_offset;\n\tstruct otx2_mbox_dev *mdev = &mbox->dev[devid];\n\tu16 msgs;\n\n\tspin_lock(&mdev->mbox_lock);\n\n\tif (mdev->num_msgs != mdev->msgs_acked)\n\t\tgoto error;\n\n\tfor (msgs = 0; msgs < mdev->msgs_acked; msgs++) {\n\t\tstruct mbox_msghdr *pmsg = mdev->mbase + imsg;\n\t\tstruct mbox_msghdr *prsp = mdev->mbase + irsp;\n\n\t\tif (msg == pmsg) {\n\t\t\tif (pmsg->id != prsp->id)\n\t\t\t\tgoto error;\n\t\t\tspin_unlock(&mdev->mbox_lock);\n\t\t\treturn prsp;\n\t\t}\n\n\t\timsg = mbox->tx_start + pmsg->next_msgoff;\n\t\tirsp = mbox->rx_start + prsp->next_msgoff;\n\t}\n\nerror:\n\tspin_unlock(&mdev->mbox_lock);\n\treturn ERR_PTR(-ENODEV);\n}\nEXPORT_SYMBOL(otx2_mbox_get_rsp);\n\nint otx2_mbox_check_rsp_msgs(struct otx2_mbox *mbox, int devid)\n{\n\tunsigned long ireq = mbox->tx_start + msgs_offset;\n\tunsigned long irsp = mbox->rx_start + msgs_offset;\n\tstruct otx2_mbox_dev *mdev = &mbox->dev[devid];\n\tint rc = -ENODEV;\n\tu16 msgs;\n\n\tspin_lock(&mdev->mbox_lock);\n\n\tif (mdev->num_msgs != mdev->msgs_acked)\n\t\tgoto exit;\n\n\tfor (msgs = 0; msgs < mdev->msgs_acked; msgs++) {\n\t\tstruct mbox_msghdr *preq = mdev->mbase + ireq;\n\t\tstruct mbox_msghdr *prsp = mdev->mbase + irsp;\n\n\t\tif (preq->id != prsp->id) {\n\t\t\ttrace_otx2_msg_check(mbox->pdev, preq->id,\n\t\t\t\t\t     prsp->id, prsp->rc);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (prsp->rc) {\n\t\t\trc = prsp->rc;\n\t\t\ttrace_otx2_msg_check(mbox->pdev, preq->id,\n\t\t\t\t\t     prsp->id, prsp->rc);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tireq = mbox->tx_start + preq->next_msgoff;\n\t\tirsp = mbox->rx_start + prsp->next_msgoff;\n\t}\n\trc = 0;\nexit:\n\tspin_unlock(&mdev->mbox_lock);\n\treturn rc;\n}\nEXPORT_SYMBOL(otx2_mbox_check_rsp_msgs);\n\nint\notx2_reply_invalid_msg(struct otx2_mbox *mbox, int devid, u16 pcifunc, u16 id)\n{\n\tstruct msg_rsp *rsp;\n\n\trsp = (struct msg_rsp *)\n\t       otx2_mbox_alloc_msg(mbox, devid, sizeof(*rsp));\n\tif (!rsp)\n\t\treturn -ENOMEM;\n\trsp->hdr.id = id;\n\trsp->hdr.sig = OTX2_MBOX_RSP_SIG;\n\trsp->hdr.rc = MBOX_MSG_INVALID;\n\trsp->hdr.pcifunc = pcifunc;\n\treturn 0;\n}\nEXPORT_SYMBOL(otx2_reply_invalid_msg);\n\nbool otx2_mbox_nonempty(struct otx2_mbox *mbox, int devid)\n{\n\tstruct otx2_mbox_dev *mdev = &mbox->dev[devid];\n\tbool ret;\n\n\tspin_lock(&mdev->mbox_lock);\n\tret = mdev->num_msgs != 0;\n\tspin_unlock(&mdev->mbox_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(otx2_mbox_nonempty);\n\nconst char *otx2_mbox_id2name(u16 id)\n{\n\tswitch (id) {\n#define M(_name, _id, _1, _2, _3) case _id: return # _name;\n\tMBOX_MESSAGES\n#undef M\n\tdefault:\n\t\treturn \"INVALID ID\";\n\t}\n}\nEXPORT_SYMBOL(otx2_mbox_id2name);\n\nMODULE_AUTHOR(\"Marvell.\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}