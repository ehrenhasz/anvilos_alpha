{
  "module_name": "ptp.c",
  "hash_id": "4f12af6d37dcaca429b7c79aa23148c922e16b99ad9f746a787fd96d93514585",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/af/ptp.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/hrtimer.h>\n#include <linux/ktime.h>\n\n#include \"mbox.h\"\n#include \"ptp.h\"\n#include \"rvu.h\"\n\n#define DRV_NAME\t\t\t\t\"Marvell PTP Driver\"\n\n#define PCI_DEVID_OCTEONTX2_PTP\t\t\t0xA00C\n#define PCI_SUBSYS_DEVID_OCTX2_98xx_PTP\t\t0xB100\n#define PCI_SUBSYS_DEVID_OCTX2_96XX_PTP\t\t0xB200\n#define PCI_SUBSYS_DEVID_OCTX2_95XX_PTP\t\t0xB300\n#define PCI_SUBSYS_DEVID_OCTX2_95XXN_PTP\t0xB400\n#define PCI_SUBSYS_DEVID_OCTX2_95MM_PTP\t\t0xB500\n#define PCI_SUBSYS_DEVID_OCTX2_95XXO_PTP\t0xB600\n#define PCI_DEVID_OCTEONTX2_RST\t\t\t0xA085\n#define PCI_DEVID_CN10K_PTP\t\t\t0xA09E\n#define PCI_SUBSYS_DEVID_CN10K_A_PTP\t\t0xB900\n#define PCI_SUBSYS_DEVID_CNF10K_A_PTP\t\t0xBA00\n#define PCI_SUBSYS_DEVID_CNF10K_B_PTP\t\t0xBC00\n\n#define PCI_PTP_BAR_NO\t\t\t\t0\n\n#define PTP_CLOCK_CFG\t\t\t\t0xF00ULL\n#define PTP_CLOCK_CFG_PTP_EN\t\t\tBIT_ULL(0)\n#define PTP_CLOCK_CFG_EXT_CLK_EN\t\tBIT_ULL(1)\n#define PTP_CLOCK_CFG_EXT_CLK_IN_MASK\t\tGENMASK_ULL(7, 2)\n#define PTP_CLOCK_CFG_TSTMP_EDGE\t\tBIT_ULL(9)\n#define PTP_CLOCK_CFG_TSTMP_EN\t\t\tBIT_ULL(8)\n#define PTP_CLOCK_CFG_TSTMP_IN_MASK\t\tGENMASK_ULL(15, 10)\n#define PTP_CLOCK_CFG_ATOMIC_OP_MASK\t\tGENMASK_ULL(28, 26)\n#define PTP_CLOCK_CFG_PPS_EN\t\t\tBIT_ULL(30)\n#define PTP_CLOCK_CFG_PPS_INV\t\t\tBIT_ULL(31)\n\n#define PTP_PPS_HI_INCR\t\t\t\t0xF60ULL\n#define PTP_PPS_LO_INCR\t\t\t\t0xF68ULL\n#define PTP_PPS_THRESH_HI\t\t\t0xF58ULL\n\n#define PTP_CLOCK_LO\t\t\t\t0xF08ULL\n#define PTP_CLOCK_HI\t\t\t\t0xF10ULL\n#define PTP_CLOCK_COMP\t\t\t\t0xF18ULL\n#define PTP_TIMESTAMP\t\t\t\t0xF20ULL\n#define PTP_CLOCK_SEC\t\t\t\t0xFD0ULL\n#define PTP_SEC_ROLLOVER\t\t\t0xFD8ULL\n \n#define PTP_FRNS_TIMESTAMP\t\t\t0xFE0ULL\n#define PTP_NXT_ROLLOVER_SET\t\t\t0xFE8ULL\n#define PTP_CURR_ROLLOVER_SET\t\t\t0xFF0ULL\n#define PTP_NANO_TIMESTAMP\t\t\t0xFF8ULL\n#define PTP_SEC_TIMESTAMP\t\t\t0x1000ULL\n\n#define CYCLE_MULT\t\t\t\t1000\n\n#define is_rev_A0(ptp) (((ptp)->pdev->revision & 0x0F) == 0x0)\n#define is_rev_A1(ptp) (((ptp)->pdev->revision & 0x0F) == 0x1)\n\n \nenum atomic_opcode {\n\tATOMIC_SET = 1,\n\tATOMIC_INC = 3,\n\tATOMIC_DEC = 4\n};\n\nstatic struct ptp *first_ptp_block;\nstatic const struct pci_device_id ptp_id_table[];\n\nstatic bool is_ptp_dev_cnf10ka(struct ptp *ptp)\n{\n\treturn ptp->pdev->subsystem_device == PCI_SUBSYS_DEVID_CNF10K_A_PTP;\n}\n\nstatic bool is_ptp_dev_cn10ka(struct ptp *ptp)\n{\n\treturn ptp->pdev->subsystem_device == PCI_SUBSYS_DEVID_CN10K_A_PTP;\n}\n\nstatic bool cn10k_ptp_errata(struct ptp *ptp)\n{\n\tif ((is_ptp_dev_cn10ka(ptp) || is_ptp_dev_cnf10ka(ptp)) &&\n\t    (is_rev_A0(ptp) || is_rev_A1(ptp)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool is_tstmp_atomic_update_supported(struct rvu *rvu)\n{\n\tstruct ptp *ptp = rvu->ptp;\n\n\tif (is_rvu_otx2(rvu))\n\t\treturn false;\n\n\t \n\tif ((is_ptp_dev_cn10ka(ptp) || is_ptp_dev_cnf10ka(ptp)) &&\n\t    (is_rev_A0(ptp) || is_rev_A1(ptp)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic enum hrtimer_restart ptp_reset_thresh(struct hrtimer *hrtimer)\n{\n\tstruct ptp *ptp = container_of(hrtimer, struct ptp, hrtimer);\n\tktime_t curr_ts = ktime_get();\n\tktime_t delta_ns, period_ns;\n\tu64 ptp_clock_hi;\n\n\t \n\tdelta_ns = ktime_to_ns(ktime_sub(curr_ts, ptp->last_ts));\n\n\t \n\tptp_clock_hi = readq(ptp->reg_base + PTP_CLOCK_HI);\n\tif (ptp_clock_hi > 500000000) {\n\t\tperiod_ns = ktime_set(0, (NSEC_PER_SEC + 100 - ptp_clock_hi));\n\t} else {\n\t\twriteq(500000000, ptp->reg_base + PTP_PPS_THRESH_HI);\n\t\tperiod_ns = ktime_set(0, (NSEC_PER_SEC + 100 - delta_ns));\n\t}\n\n\thrtimer_forward_now(hrtimer, period_ns);\n\tptp->last_ts = curr_ts;\n\n\treturn HRTIMER_RESTART;\n}\n\nstatic void ptp_hrtimer_start(struct ptp *ptp, ktime_t start_ns)\n{\n\tktime_t period_ns;\n\n\tperiod_ns = ktime_set(0, (NSEC_PER_SEC + 100 - start_ns));\n\thrtimer_start(&ptp->hrtimer, period_ns, HRTIMER_MODE_REL);\n\tptp->last_ts = ktime_get();\n}\n\nstatic u64 read_ptp_tstmp_sec_nsec(struct ptp *ptp)\n{\n\tu64 sec, sec1, nsec;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ptp->ptp_lock, flags);\n\tsec = readq(ptp->reg_base + PTP_CLOCK_SEC) & 0xFFFFFFFFUL;\n\tnsec = readq(ptp->reg_base + PTP_CLOCK_HI);\n\tsec1 = readq(ptp->reg_base + PTP_CLOCK_SEC) & 0xFFFFFFFFUL;\n\t \n\tif (sec1 > sec) {\n\t\tnsec = readq(ptp->reg_base + PTP_CLOCK_HI);\n\t\tsec = sec1;\n\t}\n\tspin_unlock_irqrestore(&ptp->ptp_lock, flags);\n\n\treturn sec * NSEC_PER_SEC + nsec;\n}\n\nstatic u64 read_ptp_tstmp_nsec(struct ptp *ptp)\n{\n\treturn readq(ptp->reg_base + PTP_CLOCK_HI);\n}\n\nstatic u64 ptp_calc_adjusted_comp(u64 ptp_clock_freq)\n{\n\tu64 comp, adj = 0, cycles_per_sec, ns_drift = 0;\n\tu32 ptp_clock_nsec, cycle_time;\n\tint cycle;\n\n\t \n\n\t \n\tcomp = ((u64)1000000000ULL << 32) / ptp_clock_freq;\n\t \n\tcycle_time = NSEC_PER_SEC * CYCLE_MULT / ptp_clock_freq;\n\t \n\tcycles_per_sec = ptp_clock_freq;\n\n\t \n\tcycle = cycles_per_sec - 1;\n\tptp_clock_nsec = (cycle * comp) >> 32;\n\twhile (ptp_clock_nsec < NSEC_PER_SEC) {\n\t\tif (ptp_clock_nsec == 0x3B9AC9FF)\n\t\t\tgoto calc_adj_comp;\n\t\tcycle++;\n\t\tptp_clock_nsec = (cycle * comp) >> 32;\n\t}\n\t \n\tns_drift = ptp_clock_nsec - NSEC_PER_SEC;\n\t \n\tif (ns_drift > 0) {\n\t\tadj = comp * ns_drift;\n\t\tadj = adj / 1000000000ULL;\n\t}\n\t \n\tcomp += adj;\n\treturn comp;\n\ncalc_adj_comp:\n\t \n\tadj = comp * cycle_time;\n\tadj = adj / 1000000000ULL;\n\tadj = adj / CYCLE_MULT;\n\tcomp -= adj;\n\n\treturn comp;\n}\n\nstruct ptp *ptp_get(void)\n{\n\tstruct ptp *ptp = first_ptp_block;\n\n\t \n\tif (!pci_dev_present(ptp_id_table))\n\t\treturn ERR_PTR(-ENODEV);\n\t \n\tif (!ptp)\n\t\tptp = ERR_PTR(-EPROBE_DEFER);\n\telse if (!IS_ERR(ptp))\n\t\tpci_dev_get(ptp->pdev);\n\n\treturn ptp;\n}\n\nvoid ptp_put(struct ptp *ptp)\n{\n\tif (!ptp)\n\t\treturn;\n\n\tpci_dev_put(ptp->pdev);\n}\n\nstatic void ptp_atomic_update(struct ptp *ptp, u64 timestamp)\n{\n\tu64 regval, curr_rollover_set, nxt_rollover_set;\n\n\t \n\twriteq(timestamp, ptp->reg_base + PTP_NANO_TIMESTAMP);\n\twriteq(0, ptp->reg_base + PTP_FRNS_TIMESTAMP);\n\twriteq(timestamp / NSEC_PER_SEC,\n\t       ptp->reg_base + PTP_SEC_TIMESTAMP);\n\n\tnxt_rollover_set = roundup(timestamp, NSEC_PER_SEC);\n\tcurr_rollover_set = nxt_rollover_set - NSEC_PER_SEC;\n\twriteq(nxt_rollover_set, ptp->reg_base + PTP_NXT_ROLLOVER_SET);\n\twriteq(curr_rollover_set, ptp->reg_base + PTP_CURR_ROLLOVER_SET);\n\n\t \n\tregval = readq(ptp->reg_base + PTP_CLOCK_CFG);\n\tregval &= ~PTP_CLOCK_CFG_ATOMIC_OP_MASK;\n\tregval |= (ATOMIC_SET << 26);\n\twriteq(regval, ptp->reg_base + PTP_CLOCK_CFG);\n}\n\nstatic void ptp_atomic_adjtime(struct ptp *ptp, s64 delta)\n{\n\tbool neg_adj = false, atomic_inc_dec = false;\n\tu64 regval, ptp_clock_hi;\n\n\tif (delta < 0) {\n\t\tdelta = -delta;\n\t\tneg_adj = true;\n\t}\n\n\t \n\tif (delta < NSEC_PER_SEC)\n\t\tatomic_inc_dec = true;\n\n\tif (!atomic_inc_dec) {\n\t\tptp_clock_hi = readq(ptp->reg_base + PTP_CLOCK_HI);\n\t\tif (neg_adj) {\n\t\t\tif (ptp_clock_hi > delta)\n\t\t\t\tptp_clock_hi -= delta;\n\t\t\telse\n\t\t\t\tptp_clock_hi = delta - ptp_clock_hi;\n\t\t} else {\n\t\t\tptp_clock_hi += delta;\n\t\t}\n\t\tptp_atomic_update(ptp, ptp_clock_hi);\n\t} else {\n\t\twriteq(delta, ptp->reg_base + PTP_NANO_TIMESTAMP);\n\t\twriteq(0, ptp->reg_base + PTP_FRNS_TIMESTAMP);\n\n\t\t \n\t\tregval = readq(ptp->reg_base + PTP_CLOCK_CFG);\n\t\tregval &= ~PTP_CLOCK_CFG_ATOMIC_OP_MASK;\n\t\tregval |= neg_adj ? (ATOMIC_DEC << 26) : (ATOMIC_INC << 26);\n\t\twriteq(regval, ptp->reg_base + PTP_CLOCK_CFG);\n\t}\n}\n\nstatic int ptp_adjfine(struct ptp *ptp, long scaled_ppm)\n{\n\tbool neg_adj = false;\n\tu32 freq, freq_adj;\n\tu64 comp, adj;\n\ts64 ppb;\n\n\tif (scaled_ppm < 0) {\n\t\tneg_adj = true;\n\t\tscaled_ppm = -scaled_ppm;\n\t}\n\n\t \n\t \n\tppb = 1 + scaled_ppm;\n\tppb *= 125;\n\tppb >>= 13;\n\n\tif (cn10k_ptp_errata(ptp)) {\n\t\t \n\t\tfreq_adj = (ptp->clock_rate * ppb) / 1000000000ULL;\n\t\tfreq = neg_adj ? ptp->clock_rate + freq_adj : ptp->clock_rate - freq_adj;\n\t\tcomp = ptp_calc_adjusted_comp(freq);\n\t} else {\n\t\tcomp = ((u64)1000000000ull << 32) / ptp->clock_rate;\n\t\tadj = comp * ppb;\n\t\tadj = div_u64(adj, 1000000000ull);\n\t\tcomp = neg_adj ? comp - adj : comp + adj;\n\t}\n\twriteq(comp, ptp->reg_base + PTP_CLOCK_COMP);\n\n\treturn 0;\n}\n\nstatic int ptp_get_clock(struct ptp *ptp, u64 *clk)\n{\n\t \n\t*clk = ptp->read_ptp_tstmp(ptp);\n\n\treturn 0;\n}\n\nvoid ptp_start(struct rvu *rvu, u64 sclk, u32 ext_clk_freq, u32 extts)\n{\n\tstruct ptp *ptp = rvu->ptp;\n\tstruct pci_dev *pdev;\n\tu64 clock_comp;\n\tu64 clock_cfg;\n\n\tif (!ptp)\n\t\treturn;\n\n\tpdev = ptp->pdev;\n\n\tif (!sclk) {\n\t\tdev_err(&pdev->dev, \"PTP input clock cannot be zero\\n\");\n\t\treturn;\n\t}\n\n\t \n\tptp->clock_rate = sclk * 1000000;\n\n\t \n\tif (is_tstmp_atomic_update_supported(rvu)) {\n\t\twriteq(0, ptp->reg_base + PTP_NANO_TIMESTAMP);\n\t\twriteq(0, ptp->reg_base + PTP_FRNS_TIMESTAMP);\n\t\twriteq(0, ptp->reg_base + PTP_SEC_TIMESTAMP);\n\t\twriteq(0, ptp->reg_base + PTP_CURR_ROLLOVER_SET);\n\t\twriteq(0x3b9aca00, ptp->reg_base + PTP_NXT_ROLLOVER_SET);\n\t\twriteq(0x3b9aca00, ptp->reg_base + PTP_SEC_ROLLOVER);\n\t}\n\n\t \n\tclock_cfg = readq(ptp->reg_base + PTP_CLOCK_CFG);\n\n\tif (ext_clk_freq) {\n\t\tptp->clock_rate = ext_clk_freq;\n\t\t \n\t\tclock_cfg &= ~PTP_CLOCK_CFG_EXT_CLK_IN_MASK;\n\t\tclock_cfg |= PTP_CLOCK_CFG_EXT_CLK_EN;\n\t}\n\n\tif (extts) {\n\t\tclock_cfg |= PTP_CLOCK_CFG_TSTMP_EDGE;\n\t\t \n\t\tclock_cfg &= ~PTP_CLOCK_CFG_TSTMP_IN_MASK;\n\t\tclock_cfg |= PTP_CLOCK_CFG_TSTMP_EN;\n\t}\n\n\tclock_cfg |= PTP_CLOCK_CFG_PTP_EN;\n\tclock_cfg |= PTP_CLOCK_CFG_PPS_EN | PTP_CLOCK_CFG_PPS_INV;\n\twriteq(clock_cfg, ptp->reg_base + PTP_CLOCK_CFG);\n\tclock_cfg = readq(ptp->reg_base + PTP_CLOCK_CFG);\n\tclock_cfg &= ~PTP_CLOCK_CFG_ATOMIC_OP_MASK;\n\tclock_cfg |= (ATOMIC_SET << 26);\n\twriteq(clock_cfg, ptp->reg_base + PTP_CLOCK_CFG);\n\n\t \n\twriteq(0x1dcd650000000000, ptp->reg_base + PTP_PPS_HI_INCR);\n\twriteq(0x1dcd650000000000, ptp->reg_base + PTP_PPS_LO_INCR);\n\tif (cn10k_ptp_errata(ptp)) {\n\t\t \n\t\tptp->clock_period = NSEC_PER_SEC / ptp->clock_rate;\n\t\twriteq((0x1dcd6500ULL - ptp->clock_period) << 32,\n\t\t       ptp->reg_base + PTP_PPS_LO_INCR);\n\t}\n\n\tif (cn10k_ptp_errata(ptp))\n\t\tclock_comp = ptp_calc_adjusted_comp(ptp->clock_rate);\n\telse\n\t\tclock_comp = ((u64)1000000000ull << 32) / ptp->clock_rate;\n\n\t \n\twriteq(clock_comp, ptp->reg_base + PTP_CLOCK_COMP);\n}\n\nstatic int ptp_get_tstmp(struct ptp *ptp, u64 *clk)\n{\n\tu64 timestamp;\n\n\tif (is_ptp_dev_cn10ka(ptp) || is_ptp_dev_cnf10ka(ptp)) {\n\t\ttimestamp = readq(ptp->reg_base + PTP_TIMESTAMP);\n\t\t*clk = (timestamp >> 32) * NSEC_PER_SEC + (timestamp & 0xFFFFFFFF);\n\t} else {\n\t\t*clk = readq(ptp->reg_base + PTP_TIMESTAMP);\n\t}\n\n\treturn 0;\n}\n\nstatic int ptp_set_thresh(struct ptp *ptp, u64 thresh)\n{\n\tif (!cn10k_ptp_errata(ptp))\n\t\twriteq(thresh, ptp->reg_base + PTP_PPS_THRESH_HI);\n\n\treturn 0;\n}\n\nstatic int ptp_extts_on(struct ptp *ptp, int on)\n{\n\tu64 ptp_clock_hi;\n\n\tif (cn10k_ptp_errata(ptp)) {\n\t\tif (on) {\n\t\t\tptp_clock_hi = readq(ptp->reg_base + PTP_CLOCK_HI);\n\t\t\tptp_hrtimer_start(ptp, (ktime_t)ptp_clock_hi);\n\t\t} else {\n\t\t\tif (hrtimer_active(&ptp->hrtimer))\n\t\t\t\thrtimer_cancel(&ptp->hrtimer);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ptp_probe(struct pci_dev *pdev,\n\t\t     const struct pci_device_id *ent)\n{\n\tstruct ptp *ptp;\n\tint err;\n\n\tptp = kzalloc(sizeof(*ptp), GFP_KERNEL);\n\tif (!ptp) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tptp->pdev = pdev;\n\n\terr = pcim_enable_device(pdev);\n\tif (err)\n\t\tgoto error_free;\n\n\terr = pcim_iomap_regions(pdev, 1 << PCI_PTP_BAR_NO, pci_name(pdev));\n\tif (err)\n\t\tgoto error_free;\n\n\tptp->reg_base = pcim_iomap_table(pdev)[PCI_PTP_BAR_NO];\n\n\tpci_set_drvdata(pdev, ptp);\n\tif (!first_ptp_block)\n\t\tfirst_ptp_block = ptp;\n\n\tspin_lock_init(&ptp->ptp_lock);\n\tif (cn10k_ptp_errata(ptp)) {\n\t\tptp->read_ptp_tstmp = &read_ptp_tstmp_sec_nsec;\n\t\thrtimer_init(&ptp->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\t\tptp->hrtimer.function = ptp_reset_thresh;\n\t} else {\n\t\tptp->read_ptp_tstmp = &read_ptp_tstmp_nsec;\n\t}\n\n\treturn 0;\n\nerror_free:\n\tkfree(ptp);\n\nerror:\n\t \n\tpci_set_drvdata(pdev, ERR_PTR(err));\n\tif (!first_ptp_block)\n\t\tfirst_ptp_block = ERR_PTR(err);\n\n\treturn err;\n}\n\nstatic void ptp_remove(struct pci_dev *pdev)\n{\n\tstruct ptp *ptp = pci_get_drvdata(pdev);\n\tu64 clock_cfg;\n\n\tif (IS_ERR_OR_NULL(ptp))\n\t\treturn;\n\n\tif (cn10k_ptp_errata(ptp) && hrtimer_active(&ptp->hrtimer))\n\t\thrtimer_cancel(&ptp->hrtimer);\n\n\t \n\tclock_cfg = readq(ptp->reg_base + PTP_CLOCK_CFG);\n\tclock_cfg &= ~PTP_CLOCK_CFG_PTP_EN;\n\twriteq(clock_cfg, ptp->reg_base + PTP_CLOCK_CFG);\n\tkfree(ptp);\n}\n\nstatic const struct pci_device_id ptp_id_table[] = {\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_OCTEONTX2_PTP,\n\t\t\t PCI_VENDOR_ID_CAVIUM,\n\t\t\t PCI_SUBSYS_DEVID_OCTX2_98xx_PTP) },\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_OCTEONTX2_PTP,\n\t\t\t PCI_VENDOR_ID_CAVIUM,\n\t\t\t PCI_SUBSYS_DEVID_OCTX2_96XX_PTP) },\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_OCTEONTX2_PTP,\n\t\t\t PCI_VENDOR_ID_CAVIUM,\n\t\t\t PCI_SUBSYS_DEVID_OCTX2_95XX_PTP) },\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_OCTEONTX2_PTP,\n\t\t\t PCI_VENDOR_ID_CAVIUM,\n\t\t\t PCI_SUBSYS_DEVID_OCTX2_95XXN_PTP) },\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_OCTEONTX2_PTP,\n\t\t\t PCI_VENDOR_ID_CAVIUM,\n\t\t\t PCI_SUBSYS_DEVID_OCTX2_95MM_PTP) },\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_OCTEONTX2_PTP,\n\t\t\t PCI_VENDOR_ID_CAVIUM,\n\t\t\t PCI_SUBSYS_DEVID_OCTX2_95XXO_PTP) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_CN10K_PTP) },\n\t{ 0, }\n};\n\nstruct pci_driver ptp_driver = {\n\t.name = DRV_NAME,\n\t.id_table = ptp_id_table,\n\t.probe = ptp_probe,\n\t.remove = ptp_remove,\n};\n\nint rvu_mbox_handler_ptp_op(struct rvu *rvu, struct ptp_req *req,\n\t\t\t    struct ptp_rsp *rsp)\n{\n\tint err = 0;\n\n\t \n\tif (!rvu->ptp)\n\t\treturn -ENODEV;\n\n\tswitch (req->op) {\n\tcase PTP_OP_ADJFINE:\n\t\terr = ptp_adjfine(rvu->ptp, req->scaled_ppm);\n\t\tbreak;\n\tcase PTP_OP_GET_CLOCK:\n\t\terr = ptp_get_clock(rvu->ptp, &rsp->clk);\n\t\tbreak;\n\tcase PTP_OP_GET_TSTMP:\n\t\terr = ptp_get_tstmp(rvu->ptp, &rsp->clk);\n\t\tbreak;\n\tcase PTP_OP_SET_THRESH:\n\t\terr = ptp_set_thresh(rvu->ptp, req->thresh);\n\t\tbreak;\n\tcase PTP_OP_EXTTS_ON:\n\t\terr = ptp_extts_on(rvu->ptp, req->extts_on);\n\t\tbreak;\n\tcase PTP_OP_ADJTIME:\n\t\tptp_atomic_adjtime(rvu->ptp, req->delta);\n\t\tbreak;\n\tcase PTP_OP_SET_CLOCK:\n\t\tptp_atomic_update(rvu->ptp, (u64)req->clk);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint rvu_mbox_handler_ptp_get_cap(struct rvu *rvu, struct msg_req *req,\n\t\t\t\t struct ptp_get_cap_rsp *rsp)\n{\n\tif (!rvu->ptp)\n\t\treturn -ENODEV;\n\n\tif (is_tstmp_atomic_update_supported(rvu))\n\t\trsp->cap |= PTP_CAP_HW_ATOMIC_UPDATE;\n\telse\n\t\trsp->cap &= ~BIT_ULL_MASK(0);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}