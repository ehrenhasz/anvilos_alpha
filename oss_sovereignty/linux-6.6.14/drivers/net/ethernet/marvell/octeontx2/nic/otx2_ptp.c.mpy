{
  "module_name": "otx2_ptp.c",
  "hash_id": "d89bc8c514d88c82e915406624fb2cb3ba31006909c347c729cd583ad2a3e2d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ptp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include \"otx2_common.h\"\n#include \"otx2_ptp.h\"\n\nstatic bool is_tstmp_atomic_update_supported(struct otx2_ptp *ptp)\n{\n\tstruct ptp_get_cap_rsp *rsp;\n\tstruct msg_req *req;\n\tint err;\n\n\tif (!ptp->nic)\n\t\treturn false;\n\n\tmutex_lock(&ptp->nic->mbox.lock);\n\treq = otx2_mbox_alloc_msg_ptp_get_cap(&ptp->nic->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&ptp->nic->mbox.lock);\n\t\treturn false;\n\t}\n\n\terr = otx2_sync_mbox_msg(&ptp->nic->mbox);\n\tif (err) {\n\t\tmutex_unlock(&ptp->nic->mbox.lock);\n\t\treturn false;\n\t}\n\trsp = (struct ptp_get_cap_rsp *)otx2_mbox_get_rsp(&ptp->nic->mbox.mbox, 0,\n\t\t\t\t\t\t\t  &req->hdr);\n\tmutex_unlock(&ptp->nic->mbox.lock);\n\n\tif (IS_ERR(rsp))\n\t\treturn false;\n\n\tif (rsp->cap & PTP_CAP_HW_ATOMIC_UPDATE)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int otx2_ptp_hw_adjtime(struct ptp_clock_info *ptp_info, s64 delta)\n{\n\tstruct otx2_ptp *ptp = container_of(ptp_info, struct otx2_ptp,\n\t\t\t\t\t    ptp_info);\n\tstruct otx2_nic *pfvf = ptp->nic;\n\tstruct ptp_req *req;\n\tint rc;\n\n\tif (!ptp->nic)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_ptp_op(&ptp->nic->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\treq->op = PTP_OP_ADJTIME;\n\treq->delta = delta;\n\trc = otx2_sync_mbox_msg(&ptp->nic->mbox);\n\tmutex_unlock(&pfvf->mbox.lock);\n\n\treturn rc;\n}\n\nstatic u64 otx2_ptp_get_clock(struct otx2_ptp *ptp)\n{\n\tstruct ptp_req *req;\n\tstruct ptp_rsp *rsp;\n\tint err;\n\n\tif (!ptp->nic)\n\t\treturn 0;\n\n\treq = otx2_mbox_alloc_msg_ptp_op(&ptp->nic->mbox);\n\tif (!req)\n\t\treturn 0;\n\n\treq->op = PTP_OP_GET_CLOCK;\n\n\terr = otx2_sync_mbox_msg(&ptp->nic->mbox);\n\tif (err)\n\t\treturn 0;\n\n\trsp = (struct ptp_rsp *)otx2_mbox_get_rsp(&ptp->nic->mbox.mbox, 0,\n\t\t\t\t\t\t  &req->hdr);\n\tif (IS_ERR(rsp))\n\t\treturn 0;\n\n\treturn rsp->clk;\n}\n\nstatic int otx2_ptp_hw_gettime(struct ptp_clock_info *ptp_info,\n\t\t\t       struct timespec64 *ts)\n{\n\tstruct otx2_ptp *ptp = container_of(ptp_info, struct otx2_ptp,\n\t\t\t\t\t    ptp_info);\n\tu64 tstamp;\n\n\ttstamp = otx2_ptp_get_clock(ptp);\n\n\t*ts = ns_to_timespec64(tstamp);\n\treturn 0;\n}\n\nstatic int otx2_ptp_hw_settime(struct ptp_clock_info *ptp_info,\n\t\t\t       const struct timespec64 *ts)\n{\n\tstruct otx2_ptp *ptp = container_of(ptp_info, struct otx2_ptp,\n\t\t\t\t\t    ptp_info);\n\tstruct otx2_nic *pfvf = ptp->nic;\n\tstruct ptp_req *req;\n\tu64 nsec;\n\tint rc;\n\n\tif (!ptp->nic)\n\t\treturn -ENODEV;\n\n\tnsec = timespec64_to_ns(ts);\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_ptp_op(&ptp->nic->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->op = PTP_OP_SET_CLOCK;\n\treq->clk = nsec;\n\trc = otx2_sync_mbox_msg(&ptp->nic->mbox);\n\tmutex_unlock(&pfvf->mbox.lock);\n\n\treturn rc;\n}\n\nstatic int otx2_ptp_adjfine(struct ptp_clock_info *ptp_info, long scaled_ppm)\n{\n\tstruct otx2_ptp *ptp = container_of(ptp_info, struct otx2_ptp,\n\t\t\t\t\t    ptp_info);\n\tstruct ptp_req *req;\n\n\tif (!ptp->nic)\n\t\treturn -ENODEV;\n\n\treq = otx2_mbox_alloc_msg_ptp_op(&ptp->nic->mbox);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->op = PTP_OP_ADJFINE;\n\treq->scaled_ppm = scaled_ppm;\n\n\treturn otx2_sync_mbox_msg(&ptp->nic->mbox);\n}\n\nstatic int ptp_set_thresh(struct otx2_ptp *ptp, u64 thresh)\n{\n\tstruct ptp_req *req;\n\n\tif (!ptp->nic)\n\t\treturn -ENODEV;\n\n\treq = otx2_mbox_alloc_msg_ptp_op(&ptp->nic->mbox);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->op = PTP_OP_SET_THRESH;\n\treq->thresh = thresh;\n\n\treturn otx2_sync_mbox_msg(&ptp->nic->mbox);\n}\n\nstatic int ptp_extts_on(struct otx2_ptp *ptp, int on)\n{\n\tstruct ptp_req *req;\n\n\tif (!ptp->nic)\n\t\treturn -ENODEV;\n\n\treq = otx2_mbox_alloc_msg_ptp_op(&ptp->nic->mbox);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->op = PTP_OP_EXTTS_ON;\n\treq->extts_on = on;\n\n\treturn otx2_sync_mbox_msg(&ptp->nic->mbox);\n}\n\nstatic u64 ptp_cc_read(const struct cyclecounter *cc)\n{\n\tstruct otx2_ptp *ptp = container_of(cc, struct otx2_ptp, cycle_counter);\n\n\treturn otx2_ptp_get_clock(ptp);\n}\n\nstatic u64 ptp_tstmp_read(struct otx2_ptp *ptp)\n{\n\tstruct ptp_req *req;\n\tstruct ptp_rsp *rsp;\n\tint err;\n\n\tif (!ptp->nic)\n\t\treturn 0;\n\n\treq = otx2_mbox_alloc_msg_ptp_op(&ptp->nic->mbox);\n\tif (!req)\n\t\treturn 0;\n\n\treq->op = PTP_OP_GET_TSTMP;\n\n\terr = otx2_sync_mbox_msg(&ptp->nic->mbox);\n\tif (err)\n\t\treturn 0;\n\n\trsp = (struct ptp_rsp *)otx2_mbox_get_rsp(&ptp->nic->mbox.mbox, 0,\n\t\t\t\t\t\t  &req->hdr);\n\tif (IS_ERR(rsp))\n\t\treturn 0;\n\n\treturn rsp->clk;\n}\n\nstatic int otx2_ptp_tc_adjtime(struct ptp_clock_info *ptp_info, s64 delta)\n{\n\tstruct otx2_ptp *ptp = container_of(ptp_info, struct otx2_ptp,\n\t\t\t\t\t    ptp_info);\n\tstruct otx2_nic *pfvf = ptp->nic;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\ttimecounter_adjtime(&ptp->time_counter, delta);\n\tmutex_unlock(&pfvf->mbox.lock);\n\n\treturn 0;\n}\n\nstatic int otx2_ptp_tc_gettime(struct ptp_clock_info *ptp_info,\n\t\t\t       struct timespec64 *ts)\n{\n\tstruct otx2_ptp *ptp = container_of(ptp_info, struct otx2_ptp,\n\t\t\t\t\t    ptp_info);\n\tu64 tstamp;\n\n\tmutex_lock(&ptp->nic->mbox.lock);\n\ttstamp = timecounter_read(&ptp->time_counter);\n\tmutex_unlock(&ptp->nic->mbox.lock);\n\t*ts = ns_to_timespec64(tstamp);\n\n\treturn 0;\n}\n\nstatic int otx2_ptp_tc_settime(struct ptp_clock_info *ptp_info,\n\t\t\t       const struct timespec64 *ts)\n{\n\tstruct otx2_ptp *ptp = container_of(ptp_info, struct otx2_ptp,\n\t\t\t\t\t    ptp_info);\n\tu64 nsec;\n\n\tnsec = timespec64_to_ns(ts);\n\n\tmutex_lock(&ptp->nic->mbox.lock);\n\ttimecounter_init(&ptp->time_counter, &ptp->cycle_counter, nsec);\n\tmutex_unlock(&ptp->nic->mbox.lock);\n\n\treturn 0;\n}\n\nstatic int otx2_ptp_verify_pin(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t       enum ptp_pin_function func, unsigned int chan)\n{\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_EXTTS:\n\t\tbreak;\n\tcase PTP_PF_PEROUT:\n\tcase PTP_PF_PHYSYNC:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic u64 otx2_ptp_hw_tstamp2time(const struct timecounter *time_counter, u64 tstamp)\n{\n\t \n\treturn tstamp;\n}\n\nstatic void otx2_ptp_extts_check(struct work_struct *work)\n{\n\tstruct otx2_ptp *ptp = container_of(work, struct otx2_ptp,\n\t\t\t\t\t    extts_work.work);\n\tstruct ptp_clock_event event;\n\tu64 tstmp, new_thresh;\n\n\tmutex_lock(&ptp->nic->mbox.lock);\n\ttstmp = ptp_tstmp_read(ptp);\n\tmutex_unlock(&ptp->nic->mbox.lock);\n\n\tif (tstmp != ptp->last_extts) {\n\t\tevent.type = PTP_CLOCK_EXTTS;\n\t\tevent.index = 0;\n\t\tevent.timestamp = ptp->ptp_tstamp2nsec(&ptp->time_counter, tstmp);\n\t\tptp_clock_event(ptp->ptp_clock, &event);\n\t\tnew_thresh = tstmp % 500000000;\n\t\tif (ptp->thresh != new_thresh) {\n\t\t\tmutex_lock(&ptp->nic->mbox.lock);\n\t\t\tptp_set_thresh(ptp, new_thresh);\n\t\t\tmutex_unlock(&ptp->nic->mbox.lock);\n\t\t\tptp->thresh = new_thresh;\n\t\t}\n\t\tptp->last_extts = tstmp;\n\t}\n\tschedule_delayed_work(&ptp->extts_work, msecs_to_jiffies(200));\n}\n\nstatic void otx2_sync_tstamp(struct work_struct *work)\n{\n\tstruct otx2_ptp *ptp = container_of(work, struct otx2_ptp,\n\t\t\t\t\t    synctstamp_work.work);\n\tstruct otx2_nic *pfvf = ptp->nic;\n\tu64 tstamp;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\ttstamp = otx2_ptp_get_clock(ptp);\n\tmutex_unlock(&pfvf->mbox.lock);\n\n\tptp->tstamp = ptp->ptp_tstamp2nsec(&ptp->time_counter, tstamp);\n\tptp->base_ns = tstamp % NSEC_PER_SEC;\n\n\tschedule_delayed_work(&ptp->synctstamp_work, msecs_to_jiffies(250));\n}\n\nstatic int otx2_ptp_enable(struct ptp_clock_info *ptp_info,\n\t\t\t   struct ptp_clock_request *rq, int on)\n{\n\tstruct otx2_ptp *ptp = container_of(ptp_info, struct otx2_ptp,\n\t\t\t\t\t    ptp_info);\n\tint pin;\n\n\tif (!ptp->nic)\n\t\treturn -ENODEV;\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\tpin = ptp_find_pin(ptp->ptp_clock, PTP_PF_EXTTS,\n\t\t\t\t   rq->extts.index);\n\t\tif (pin < 0)\n\t\t\treturn -EBUSY;\n\t\tif (on) {\n\t\t\tptp_extts_on(ptp, on);\n\t\t\tschedule_delayed_work(&ptp->extts_work, msecs_to_jiffies(200));\n\t\t} else {\n\t\t\tptp_extts_on(ptp, on);\n\t\t\tcancel_delayed_work_sync(&ptp->extts_work);\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nint otx2_ptp_init(struct otx2_nic *pfvf)\n{\n\tstruct otx2_ptp *ptp_ptr;\n\tstruct cyclecounter *cc;\n\tstruct ptp_req *req;\n\tint err;\n\n\tif (is_otx2_lbkvf(pfvf->pdev)) {\n\t\tpfvf->ptp = NULL;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&pfvf->mbox.lock);\n\t \n\treq = otx2_mbox_alloc_msg_ptp_op(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->op = PTP_OP_GET_CLOCK;\n\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (err) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn err;\n\t}\n\tmutex_unlock(&pfvf->mbox.lock);\n\n\tptp_ptr = kzalloc(sizeof(*ptp_ptr), GFP_KERNEL);\n\tif (!ptp_ptr) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tptp_ptr->nic = pfvf;\n\n\tsnprintf(ptp_ptr->extts_config.name, sizeof(ptp_ptr->extts_config.name), \"TSTAMP\");\n\tptp_ptr->extts_config.index = 0;\n\tptp_ptr->extts_config.func = PTP_PF_NONE;\n\n\tptp_ptr->ptp_info = (struct ptp_clock_info) {\n\t\t.owner          = THIS_MODULE,\n\t\t.name           = \"OcteonTX2 PTP\",\n\t\t.max_adj        = 1000000000ull,\n\t\t.n_ext_ts       = 1,\n\t\t.n_pins         = 1,\n\t\t.pps            = 0,\n\t\t.pin_config     = &ptp_ptr->extts_config,\n\t\t.adjfine        = otx2_ptp_adjfine,\n\t\t.enable         = otx2_ptp_enable,\n\t\t.verify         = otx2_ptp_verify_pin,\n\t};\n\n\t \n\tif (is_tstmp_atomic_update_supported(ptp_ptr)) {\n\t\tptp_ptr->ptp_info.adjtime = otx2_ptp_hw_adjtime;\n\t\tptp_ptr->ptp_info.gettime64 = otx2_ptp_hw_gettime;\n\t\tptp_ptr->ptp_info.settime64 = otx2_ptp_hw_settime;\n\n\t\tptp_ptr->ptp_tstamp2nsec = otx2_ptp_hw_tstamp2time;\n\t} else {\n\t\tptp_ptr->ptp_info.adjtime = otx2_ptp_tc_adjtime;\n\t\tptp_ptr->ptp_info.gettime64 = otx2_ptp_tc_gettime;\n\t\tptp_ptr->ptp_info.settime64 = otx2_ptp_tc_settime;\n\n\t\tcc = &ptp_ptr->cycle_counter;\n\t\tcc->read = ptp_cc_read;\n\t\tcc->mask = CYCLECOUNTER_MASK(64);\n\t\tcc->mult = 1;\n\t\tcc->shift = 0;\n\t\tptp_ptr->ptp_tstamp2nsec = timecounter_cyc2time;\n\n\t\ttimecounter_init(&ptp_ptr->time_counter, &ptp_ptr->cycle_counter,\n\t\t\t\t ktime_to_ns(ktime_get_real()));\n\t}\n\n\tINIT_DELAYED_WORK(&ptp_ptr->extts_work, otx2_ptp_extts_check);\n\n\tptp_ptr->ptp_clock = ptp_clock_register(&ptp_ptr->ptp_info, pfvf->dev);\n\tif (IS_ERR_OR_NULL(ptp_ptr->ptp_clock)) {\n\t\terr = ptp_ptr->ptp_clock ?\n\t\t      PTR_ERR(ptp_ptr->ptp_clock) : -ENODEV;\n\t\tkfree(ptp_ptr);\n\t\tgoto error;\n\t}\n\n\tif (is_dev_otx2(pfvf->pdev)) {\n\t\tptp_ptr->convert_rx_ptp_tstmp = &otx2_ptp_convert_rx_timestamp;\n\t\tptp_ptr->convert_tx_ptp_tstmp = &otx2_ptp_convert_tx_timestamp;\n\t} else {\n\t\tptp_ptr->convert_rx_ptp_tstmp = &cn10k_ptp_convert_timestamp;\n\t\tptp_ptr->convert_tx_ptp_tstmp = &cn10k_ptp_convert_timestamp;\n\t}\n\n\tINIT_DELAYED_WORK(&ptp_ptr->synctstamp_work, otx2_sync_tstamp);\n\n\tpfvf->ptp = ptp_ptr;\n\nerror:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(otx2_ptp_init);\n\nvoid otx2_ptp_destroy(struct otx2_nic *pfvf)\n{\n\tstruct otx2_ptp *ptp = pfvf->ptp;\n\n\tif (!ptp)\n\t\treturn;\n\n\tcancel_delayed_work(&pfvf->ptp->synctstamp_work);\n\n\tptp_clock_unregister(ptp->ptp_clock);\n\tkfree(ptp);\n\tpfvf->ptp = NULL;\n}\nEXPORT_SYMBOL_GPL(otx2_ptp_destroy);\n\nint otx2_ptp_clock_index(struct otx2_nic *pfvf)\n{\n\tif (!pfvf->ptp)\n\t\treturn -ENODEV;\n\n\treturn ptp_clock_index(pfvf->ptp->ptp_clock);\n}\nEXPORT_SYMBOL_GPL(otx2_ptp_clock_index);\n\nint otx2_ptp_tstamp2time(struct otx2_nic *pfvf, u64 tstamp, u64 *tsns)\n{\n\tif (!pfvf->ptp)\n\t\treturn -ENODEV;\n\n\t*tsns = pfvf->ptp->ptp_tstamp2nsec(&pfvf->ptp->time_counter, tstamp);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(otx2_ptp_tstamp2time);\n\nMODULE_AUTHOR(\"Sunil Goutham <sgoutham@marvell.com>\");\nMODULE_DESCRIPTION(\"Marvell RVU NIC PTP Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}