{
  "module_name": "otx2_flows.c",
  "hash_id": "3a541a13c169e76fab6250a3b166ccc39e210702b4c8c89410b81c6ad7d8eedd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/nic/otx2_flows.c",
  "human_readable_source": "\n \n\n#include <net/ipv6.h>\n#include <linux/sort.h>\n\n#include \"otx2_common.h\"\n\n#define OTX2_DEFAULT_ACTION\t0x1\n\nstatic int otx2_mcam_entry_init(struct otx2_nic *pfvf);\n\nstruct otx2_flow {\n\tstruct ethtool_rx_flow_spec flow_spec;\n\tstruct list_head list;\n\tu32 location;\n\tu32 entry;\n\tbool is_vf;\n\tu8 rss_ctx_id;\n#define DMAC_FILTER_RULE\t\tBIT(0)\n#define PFC_FLOWCTRL_RULE\t\tBIT(1)\n\tu16 rule_type;\n\tint vf;\n};\n\nenum dmac_req {\n\tDMAC_ADDR_UPDATE,\n\tDMAC_ADDR_DEL\n};\n\nstatic void otx2_clear_ntuple_flow_info(struct otx2_nic *pfvf, struct otx2_flow_config *flow_cfg)\n{\n\tdevm_kfree(pfvf->dev, flow_cfg->flow_ent);\n\tflow_cfg->flow_ent = NULL;\n\tflow_cfg->max_flows = 0;\n}\n\nstatic int otx2_free_ntuple_mcam_entries(struct otx2_nic *pfvf)\n{\n\tstruct otx2_flow_config *flow_cfg = pfvf->flow_cfg;\n\tstruct npc_mcam_free_entry_req *req;\n\tint ent, err;\n\n\tif (!flow_cfg->max_flows)\n\t\treturn 0;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\tfor (ent = 0; ent < flow_cfg->max_flows; ent++) {\n\t\treq = otx2_mbox_alloc_msg_npc_mcam_free_entry(&pfvf->mbox);\n\t\tif (!req)\n\t\t\tbreak;\n\n\t\treq->entry = flow_cfg->flow_ent[ent];\n\n\t\t \n\t\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&pfvf->mbox.lock);\n\totx2_clear_ntuple_flow_info(pfvf, flow_cfg);\n\treturn 0;\n}\n\nstatic int mcam_entry_cmp(const void *a, const void *b)\n{\n\treturn *(u16 *)a - *(u16 *)b;\n}\n\nint otx2_alloc_mcam_entries(struct otx2_nic *pfvf, u16 count)\n{\n\tstruct otx2_flow_config *flow_cfg = pfvf->flow_cfg;\n\tstruct npc_mcam_alloc_entry_req *req;\n\tstruct npc_mcam_alloc_entry_rsp *rsp;\n\tint ent, allocated = 0;\n\n\t \n\totx2_free_ntuple_mcam_entries(pfvf);\n\n\tif (!count)\n\t\treturn 0;\n\n\tflow_cfg->flow_ent = devm_kmalloc_array(pfvf->dev, count,\n\t\t\t\t\t\tsizeof(u16), GFP_KERNEL);\n\tif (!flow_cfg->flow_ent) {\n\t\tnetdev_err(pfvf->netdev,\n\t\t\t   \"%s: Unable to allocate memory for flow entries\\n\",\n\t\t\t    __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&pfvf->mbox.lock);\n\n\t \n\twhile (allocated < count) {\n\t\treq = otx2_mbox_alloc_msg_npc_mcam_alloc_entry(&pfvf->mbox);\n\t\tif (!req)\n\t\t\tgoto exit;\n\n\t\treq->contig = false;\n\t\treq->count = (count - allocated) > NPC_MAX_NONCONTIG_ENTRIES ?\n\t\t\t\tNPC_MAX_NONCONTIG_ENTRIES : count - allocated;\n\n\t\t \n\t\tif (!is_otx2_vf(pfvf->pcifunc)) {\n\t\t\treq->priority = NPC_MCAM_HIGHER_PRIO;\n\t\t\treq->ref_entry = flow_cfg->def_ent[0];\n\t\t}\n\n\t\t \n\t\tif (otx2_sync_mbox_msg(&pfvf->mbox))\n\t\t\tgoto exit;\n\n\t\trsp = (struct npc_mcam_alloc_entry_rsp *)otx2_mbox_get_rsp\n\t\t\t(&pfvf->mbox.mbox, 0, &req->hdr);\n\n\t\tfor (ent = 0; ent < rsp->count; ent++)\n\t\t\tflow_cfg->flow_ent[ent + allocated] = rsp->entry_list[ent];\n\n\t\tallocated += rsp->count;\n\n\t\t \n\t\tif (rsp->count != req->count)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (allocated)\n\t\tsort(&flow_cfg->flow_ent[0], allocated,\n\t\t     sizeof(flow_cfg->flow_ent[0]), mcam_entry_cmp, NULL);\n\nexit:\n\tmutex_unlock(&pfvf->mbox.lock);\n\n\tflow_cfg->max_flows = allocated;\n\n\tif (allocated) {\n\t\tpfvf->flags |= OTX2_FLAG_MCAM_ENTRIES_ALLOC;\n\t\tpfvf->flags |= OTX2_FLAG_NTUPLE_SUPPORT;\n\t}\n\n\tif (allocated != count)\n\t\tnetdev_info(pfvf->netdev,\n\t\t\t    \"Unable to allocate %d MCAM entries, got only %d\\n\",\n\t\t\t    count, allocated);\n\treturn allocated;\n}\nEXPORT_SYMBOL(otx2_alloc_mcam_entries);\n\nstatic int otx2_mcam_entry_init(struct otx2_nic *pfvf)\n{\n\tstruct otx2_flow_config *flow_cfg = pfvf->flow_cfg;\n\tstruct npc_get_field_status_req *freq;\n\tstruct npc_get_field_status_rsp *frsp;\n\tstruct npc_mcam_alloc_entry_req *req;\n\tstruct npc_mcam_alloc_entry_rsp *rsp;\n\tint vf_vlan_max_flows;\n\tint ent, count;\n\n\tvf_vlan_max_flows = pfvf->total_vfs * OTX2_PER_VF_VLAN_FLOWS;\n\tcount = OTX2_MAX_UNICAST_FLOWS +\n\t\t\tOTX2_MAX_VLAN_FLOWS + vf_vlan_max_flows;\n\n\tflow_cfg->def_ent = devm_kmalloc_array(pfvf->dev, count,\n\t\t\t\t\t       sizeof(u16), GFP_KERNEL);\n\tif (!flow_cfg->def_ent)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\n\treq = otx2_mbox_alloc_msg_npc_mcam_alloc_entry(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->contig = false;\n\treq->count = count;\n\n\t \n\tif (otx2_sync_mbox_msg(&pfvf->mbox)) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -EINVAL;\n\t}\n\n\trsp = (struct npc_mcam_alloc_entry_rsp *)otx2_mbox_get_rsp\n\t       (&pfvf->mbox.mbox, 0, &req->hdr);\n\n\tif (rsp->count != req->count) {\n\t\tnetdev_info(pfvf->netdev,\n\t\t\t    \"Unable to allocate MCAM entries for ucast, vlan and vf_vlan\\n\");\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\tdevm_kfree(pfvf->dev, flow_cfg->def_ent);\n\t\treturn 0;\n\t}\n\n\tfor (ent = 0; ent < rsp->count; ent++)\n\t\tflow_cfg->def_ent[ent] = rsp->entry_list[ent];\n\n\tflow_cfg->vf_vlan_offset = 0;\n\tflow_cfg->unicast_offset = vf_vlan_max_flows;\n\tflow_cfg->rx_vlan_offset = flow_cfg->unicast_offset +\n\t\t\t\t\tOTX2_MAX_UNICAST_FLOWS;\n\tpfvf->flags |= OTX2_FLAG_UCAST_FLTR_SUPPORT;\n\n\t \n\tfreq = otx2_mbox_alloc_msg_npc_get_field_status(&pfvf->mbox);\n\tif (!freq) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tfreq->field = NPC_DMAC;\n\tif (otx2_sync_mbox_msg(&pfvf->mbox)) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -EINVAL;\n\t}\n\n\tfrsp = (struct npc_get_field_status_rsp *)otx2_mbox_get_rsp\n\t       (&pfvf->mbox.mbox, 0, &freq->hdr);\n\n\tif (frsp->enable) {\n\t\tpfvf->flags |= OTX2_FLAG_RX_VLAN_SUPPORT;\n\t\tpfvf->flags |= OTX2_FLAG_VF_VLAN_SUPPORT;\n\t}\n\n\tpfvf->flags |= OTX2_FLAG_MCAM_ENTRIES_ALLOC;\n\tmutex_unlock(&pfvf->mbox.lock);\n\n\t \n\tcount = otx2_alloc_mcam_entries(pfvf, OTX2_DEFAULT_FLOWCOUNT);\n\tif (count <= 0) {\n\t\totx2_clear_ntuple_flow_info(pfvf, flow_cfg);\n\t\treturn 0;\n\t}\n\n\tpfvf->flags |= OTX2_FLAG_TC_FLOWER_SUPPORT;\n\n\treturn 0;\n}\n\n \n#define OTX2_DMAC_FLTR_BITMAP_SZ (4 * 2048 + 32)\n\nint otx2vf_mcam_flow_init(struct otx2_nic *pfvf)\n{\n\tstruct otx2_flow_config *flow_cfg;\n\n\tpfvf->flow_cfg = devm_kzalloc(pfvf->dev,\n\t\t\t\t      sizeof(struct otx2_flow_config),\n\t\t\t\t      GFP_KERNEL);\n\tif (!pfvf->flow_cfg)\n\t\treturn -ENOMEM;\n\n\tpfvf->flow_cfg->dmacflt_bmap = devm_kcalloc(pfvf->dev,\n\t\t\t\t\t\t    BITS_TO_LONGS(OTX2_DMAC_FLTR_BITMAP_SZ),\n\t\t\t\t\t\t    sizeof(long), GFP_KERNEL);\n\tif (!pfvf->flow_cfg->dmacflt_bmap)\n\t\treturn -ENOMEM;\n\n\tflow_cfg = pfvf->flow_cfg;\n\tINIT_LIST_HEAD(&flow_cfg->flow_list);\n\tINIT_LIST_HEAD(&flow_cfg->flow_list_tc);\n\tflow_cfg->max_flows = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(otx2vf_mcam_flow_init);\n\nint otx2_mcam_flow_init(struct otx2_nic *pf)\n{\n\tint err;\n\n\tpf->flow_cfg = devm_kzalloc(pf->dev, sizeof(struct otx2_flow_config),\n\t\t\t\t    GFP_KERNEL);\n\tif (!pf->flow_cfg)\n\t\treturn -ENOMEM;\n\n\tpf->flow_cfg->dmacflt_bmap = devm_kcalloc(pf->dev,\n\t\t\t\t\t\t  BITS_TO_LONGS(OTX2_DMAC_FLTR_BITMAP_SZ),\n\t\t\t\t\t\t  sizeof(long), GFP_KERNEL);\n\tif (!pf->flow_cfg->dmacflt_bmap)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&pf->flow_cfg->flow_list);\n\tINIT_LIST_HEAD(&pf->flow_cfg->flow_list_tc);\n\n\t \n\terr = otx2_mcam_entry_init(pf);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!(pf->flags & OTX2_FLAG_UCAST_FLTR_SUPPORT))\n\t\treturn 0;\n\n\tpf->mac_table = devm_kzalloc(pf->dev, sizeof(struct otx2_mac_table)\n\t\t\t\t\t* OTX2_MAX_UNICAST_FLOWS, GFP_KERNEL);\n\tif (!pf->mac_table)\n\t\treturn -ENOMEM;\n\n\totx2_dmacflt_get_max_cnt(pf);\n\n\t \n\tif (!pf->flow_cfg->dmacflt_max_flows)\n\t\treturn 0;\n\n\tpf->flow_cfg->bmap_to_dmacindex =\n\t\t\tdevm_kzalloc(pf->dev, sizeof(u32) *\n\t\t\t\t     pf->flow_cfg->dmacflt_max_flows,\n\t\t\t\t     GFP_KERNEL);\n\n\tif (!pf->flow_cfg->bmap_to_dmacindex)\n\t\treturn -ENOMEM;\n\n\tpf->flags |= OTX2_FLAG_DMACFLTR_SUPPORT;\n\n\treturn 0;\n}\n\nvoid otx2_mcam_flow_del(struct otx2_nic *pf)\n{\n\totx2_destroy_mcam_flows(pf);\n}\nEXPORT_SYMBOL(otx2_mcam_flow_del);\n\n \nstatic int otx2_do_add_macfilter(struct otx2_nic *pf, const u8 *mac)\n{\n\tstruct otx2_flow_config *flow_cfg = pf->flow_cfg;\n\tstruct npc_install_flow_req *req;\n\tint err, i;\n\n\tif (!(pf->flags & OTX2_FLAG_UCAST_FLTR_SUPPORT))\n\t\treturn -ENOMEM;\n\n\t \n\tif (netdev_uc_count(pf->netdev) > OTX2_MAX_UNICAST_FLOWS)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&pf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_npc_install_flow(&pf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i <  OTX2_MAX_UNICAST_FLOWS; i++) {\n\t\tif (pf->mac_table[i].inuse)\n\t\t\tcontinue;\n\t\tether_addr_copy(pf->mac_table[i].addr, mac);\n\t\tpf->mac_table[i].inuse = true;\n\t\tpf->mac_table[i].mcam_entry =\n\t\t\tflow_cfg->def_ent[i + flow_cfg->unicast_offset];\n\t\treq->entry =  pf->mac_table[i].mcam_entry;\n\t\tbreak;\n\t}\n\n\tether_addr_copy(req->packet.dmac, mac);\n\teth_broadcast_addr((u8 *)&req->mask.dmac);\n\treq->features = BIT_ULL(NPC_DMAC);\n\treq->channel = pf->hw.rx_chan_base;\n\treq->intf = NIX_INTF_RX;\n\treq->op = NIX_RX_ACTION_DEFAULT;\n\treq->set_cntr = 1;\n\n\terr = otx2_sync_mbox_msg(&pf->mbox);\n\tmutex_unlock(&pf->mbox.lock);\n\n\treturn err;\n}\n\nint otx2_add_macfilter(struct net_device *netdev, const u8 *mac)\n{\n\tstruct otx2_nic *pf = netdev_priv(netdev);\n\n\tif (!bitmap_empty(pf->flow_cfg->dmacflt_bmap,\n\t\t\t  pf->flow_cfg->dmacflt_max_flows))\n\t\tnetdev_warn(netdev,\n\t\t\t    \"Add %pM to CGX/RPM DMAC filters list as well\\n\",\n\t\t\t    mac);\n\n\treturn otx2_do_add_macfilter(pf, mac);\n}\n\nstatic bool otx2_get_mcamentry_for_mac(struct otx2_nic *pf, const u8 *mac,\n\t\t\t\t       int *mcam_entry)\n{\n\tint i;\n\n\tfor (i = 0; i < OTX2_MAX_UNICAST_FLOWS; i++) {\n\t\tif (!pf->mac_table[i].inuse)\n\t\t\tcontinue;\n\n\t\tif (ether_addr_equal(pf->mac_table[i].addr, mac)) {\n\t\t\t*mcam_entry = pf->mac_table[i].mcam_entry;\n\t\t\tpf->mac_table[i].inuse = false;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint otx2_del_macfilter(struct net_device *netdev, const u8 *mac)\n{\n\tstruct otx2_nic *pf = netdev_priv(netdev);\n\tstruct npc_delete_flow_req *req;\n\tint err, mcam_entry;\n\n\t \n\tif (!otx2_get_mcamentry_for_mac(pf, mac, &mcam_entry))\n\t\treturn 0;\n\n\tmutex_lock(&pf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_npc_delete_flow(&pf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\treq->entry = mcam_entry;\n\t \n\terr = otx2_sync_mbox_msg(&pf->mbox);\n\tmutex_unlock(&pf->mbox.lock);\n\n\treturn err;\n}\n\nstatic struct otx2_flow *otx2_find_flow(struct otx2_nic *pfvf, u32 location)\n{\n\tstruct otx2_flow *iter;\n\n\tlist_for_each_entry(iter, &pfvf->flow_cfg->flow_list, list) {\n\t\tif (iter->location == location)\n\t\t\treturn iter;\n\t}\n\n\treturn NULL;\n}\n\nstatic void otx2_add_flow_to_list(struct otx2_nic *pfvf, struct otx2_flow *flow)\n{\n\tstruct list_head *head = &pfvf->flow_cfg->flow_list;\n\tstruct otx2_flow *iter;\n\n\tlist_for_each_entry(iter, &pfvf->flow_cfg->flow_list, list) {\n\t\tif (iter->location > flow->location)\n\t\t\tbreak;\n\t\thead = &iter->list;\n\t}\n\n\tlist_add(&flow->list, head);\n}\n\nint otx2_get_maxflows(struct otx2_flow_config *flow_cfg)\n{\n\tif (!flow_cfg)\n\t\treturn 0;\n\n\tif (flow_cfg->nr_flows == flow_cfg->max_flows ||\n\t    !bitmap_empty(flow_cfg->dmacflt_bmap,\n\t\t\t  flow_cfg->dmacflt_max_flows))\n\t\treturn flow_cfg->max_flows + flow_cfg->dmacflt_max_flows;\n\telse\n\t\treturn flow_cfg->max_flows;\n}\nEXPORT_SYMBOL(otx2_get_maxflows);\n\nint otx2_get_flow(struct otx2_nic *pfvf, struct ethtool_rxnfc *nfc,\n\t\t  u32 location)\n{\n\tstruct otx2_flow *iter;\n\n\tif (location >= otx2_get_maxflows(pfvf->flow_cfg))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(iter, &pfvf->flow_cfg->flow_list, list) {\n\t\tif (iter->location == location) {\n\t\t\tnfc->fs = iter->flow_spec;\n\t\t\tnfc->rss_context = iter->rss_ctx_id;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nint otx2_get_all_flows(struct otx2_nic *pfvf, struct ethtool_rxnfc *nfc,\n\t\t       u32 *rule_locs)\n{\n\tu32 rule_cnt = nfc->rule_cnt;\n\tu32 location = 0;\n\tint idx = 0;\n\tint err = 0;\n\n\tnfc->data = otx2_get_maxflows(pfvf->flow_cfg);\n\twhile ((!err || err == -ENOENT) && idx < rule_cnt) {\n\t\terr = otx2_get_flow(pfvf, nfc, location);\n\t\tif (!err)\n\t\t\trule_locs[idx++] = location;\n\t\tlocation++;\n\t}\n\tnfc->rule_cnt = rule_cnt;\n\n\treturn err;\n}\n\nstatic int otx2_prepare_ipv4_flow(struct ethtool_rx_flow_spec *fsp,\n\t\t\t\t  struct npc_install_flow_req *req,\n\t\t\t\t  u32 flow_type)\n{\n\tstruct ethtool_usrip4_spec *ipv4_usr_mask = &fsp->m_u.usr_ip4_spec;\n\tstruct ethtool_usrip4_spec *ipv4_usr_hdr = &fsp->h_u.usr_ip4_spec;\n\tstruct ethtool_tcpip4_spec *ipv4_l4_mask = &fsp->m_u.tcp_ip4_spec;\n\tstruct ethtool_tcpip4_spec *ipv4_l4_hdr = &fsp->h_u.tcp_ip4_spec;\n\tstruct ethtool_ah_espip4_spec *ah_esp_hdr = &fsp->h_u.ah_ip4_spec;\n\tstruct ethtool_ah_espip4_spec *ah_esp_mask = &fsp->m_u.ah_ip4_spec;\n\tstruct flow_msg *pmask = &req->mask;\n\tstruct flow_msg *pkt = &req->packet;\n\n\tswitch (flow_type) {\n\tcase IP_USER_FLOW:\n\t\tif (ipv4_usr_mask->ip4src) {\n\t\t\tmemcpy(&pkt->ip4src, &ipv4_usr_hdr->ip4src,\n\t\t\t       sizeof(pkt->ip4src));\n\t\t\tmemcpy(&pmask->ip4src, &ipv4_usr_mask->ip4src,\n\t\t\t       sizeof(pmask->ip4src));\n\t\t\treq->features |= BIT_ULL(NPC_SIP_IPV4);\n\t\t}\n\t\tif (ipv4_usr_mask->ip4dst) {\n\t\t\tmemcpy(&pkt->ip4dst, &ipv4_usr_hdr->ip4dst,\n\t\t\t       sizeof(pkt->ip4dst));\n\t\t\tmemcpy(&pmask->ip4dst, &ipv4_usr_mask->ip4dst,\n\t\t\t       sizeof(pmask->ip4dst));\n\t\t\treq->features |= BIT_ULL(NPC_DIP_IPV4);\n\t\t}\n\t\tif (ipv4_usr_mask->tos) {\n\t\t\tpkt->tos = ipv4_usr_hdr->tos;\n\t\t\tpmask->tos = ipv4_usr_mask->tos;\n\t\t\treq->features |= BIT_ULL(NPC_TOS);\n\t\t}\n\t\tif (ipv4_usr_mask->proto) {\n\t\t\tswitch (ipv4_usr_hdr->proto) {\n\t\t\tcase IPPROTO_ICMP:\n\t\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_ICMP);\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_TCP:\n\t\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_TCP);\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_UDP:\n\t\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_UDP);\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_SCTP:\n\t\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_SCTP);\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_AH:\n\t\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_AH);\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_ESP:\n\t\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_ESP);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t\tpkt->etype = cpu_to_be16(ETH_P_IP);\n\t\tpmask->etype = cpu_to_be16(0xFFFF);\n\t\treq->features |= BIT_ULL(NPC_ETYPE);\n\t\tbreak;\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\t\tpkt->etype = cpu_to_be16(ETH_P_IP);\n\t\tpmask->etype = cpu_to_be16(0xFFFF);\n\t\treq->features |= BIT_ULL(NPC_ETYPE);\n\t\tif (ipv4_l4_mask->ip4src) {\n\t\t\tmemcpy(&pkt->ip4src, &ipv4_l4_hdr->ip4src,\n\t\t\t       sizeof(pkt->ip4src));\n\t\t\tmemcpy(&pmask->ip4src, &ipv4_l4_mask->ip4src,\n\t\t\t       sizeof(pmask->ip4src));\n\t\t\treq->features |= BIT_ULL(NPC_SIP_IPV4);\n\t\t}\n\t\tif (ipv4_l4_mask->ip4dst) {\n\t\t\tmemcpy(&pkt->ip4dst, &ipv4_l4_hdr->ip4dst,\n\t\t\t       sizeof(pkt->ip4dst));\n\t\t\tmemcpy(&pmask->ip4dst, &ipv4_l4_mask->ip4dst,\n\t\t\t       sizeof(pmask->ip4dst));\n\t\t\treq->features |= BIT_ULL(NPC_DIP_IPV4);\n\t\t}\n\t\tif (ipv4_l4_mask->tos) {\n\t\t\tpkt->tos = ipv4_l4_hdr->tos;\n\t\t\tpmask->tos = ipv4_l4_mask->tos;\n\t\t\treq->features |= BIT_ULL(NPC_TOS);\n\t\t}\n\t\tif (ipv4_l4_mask->psrc) {\n\t\t\tmemcpy(&pkt->sport, &ipv4_l4_hdr->psrc,\n\t\t\t       sizeof(pkt->sport));\n\t\t\tmemcpy(&pmask->sport, &ipv4_l4_mask->psrc,\n\t\t\t       sizeof(pmask->sport));\n\t\t\tif (flow_type == UDP_V4_FLOW)\n\t\t\t\treq->features |= BIT_ULL(NPC_SPORT_UDP);\n\t\t\telse if (flow_type == TCP_V4_FLOW)\n\t\t\t\treq->features |= BIT_ULL(NPC_SPORT_TCP);\n\t\t\telse\n\t\t\t\treq->features |= BIT_ULL(NPC_SPORT_SCTP);\n\t\t}\n\t\tif (ipv4_l4_mask->pdst) {\n\t\t\tmemcpy(&pkt->dport, &ipv4_l4_hdr->pdst,\n\t\t\t       sizeof(pkt->dport));\n\t\t\tmemcpy(&pmask->dport, &ipv4_l4_mask->pdst,\n\t\t\t       sizeof(pmask->dport));\n\t\t\tif (flow_type == UDP_V4_FLOW)\n\t\t\t\treq->features |= BIT_ULL(NPC_DPORT_UDP);\n\t\t\telse if (flow_type == TCP_V4_FLOW)\n\t\t\t\treq->features |= BIT_ULL(NPC_DPORT_TCP);\n\t\t\telse\n\t\t\t\treq->features |= BIT_ULL(NPC_DPORT_SCTP);\n\t\t}\n\t\tif (flow_type == UDP_V4_FLOW)\n\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_UDP);\n\t\telse if (flow_type == TCP_V4_FLOW)\n\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_TCP);\n\t\telse\n\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_SCTP);\n\t\tbreak;\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\t\tpkt->etype = cpu_to_be16(ETH_P_IP);\n\t\tpmask->etype = cpu_to_be16(0xFFFF);\n\t\treq->features |= BIT_ULL(NPC_ETYPE);\n\t\tif (ah_esp_mask->ip4src) {\n\t\t\tmemcpy(&pkt->ip4src, &ah_esp_hdr->ip4src,\n\t\t\t       sizeof(pkt->ip4src));\n\t\t\tmemcpy(&pmask->ip4src, &ah_esp_mask->ip4src,\n\t\t\t       sizeof(pmask->ip4src));\n\t\t\treq->features |= BIT_ULL(NPC_SIP_IPV4);\n\t\t}\n\t\tif (ah_esp_mask->ip4dst) {\n\t\t\tmemcpy(&pkt->ip4dst, &ah_esp_hdr->ip4dst,\n\t\t\t       sizeof(pkt->ip4dst));\n\t\t\tmemcpy(&pmask->ip4dst, &ah_esp_mask->ip4dst,\n\t\t\t       sizeof(pmask->ip4dst));\n\t\t\treq->features |= BIT_ULL(NPC_DIP_IPV4);\n\t\t}\n\t\tif (ah_esp_mask->tos) {\n\t\t\tpkt->tos = ah_esp_hdr->tos;\n\t\t\tpmask->tos = ah_esp_mask->tos;\n\t\t\treq->features |= BIT_ULL(NPC_TOS);\n\t\t}\n\n\t\t \n\t\tif (ah_esp_mask->spi & ah_esp_hdr->spi)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (flow_type == AH_V4_FLOW)\n\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_AH);\n\t\telse\n\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_ESP);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int otx2_prepare_ipv6_flow(struct ethtool_rx_flow_spec *fsp,\n\t\t\t\t  struct npc_install_flow_req *req,\n\t\t\t\t  u32 flow_type)\n{\n\tstruct ethtool_usrip6_spec *ipv6_usr_mask = &fsp->m_u.usr_ip6_spec;\n\tstruct ethtool_usrip6_spec *ipv6_usr_hdr = &fsp->h_u.usr_ip6_spec;\n\tstruct ethtool_tcpip6_spec *ipv6_l4_mask = &fsp->m_u.tcp_ip6_spec;\n\tstruct ethtool_tcpip6_spec *ipv6_l4_hdr = &fsp->h_u.tcp_ip6_spec;\n\tstruct ethtool_ah_espip6_spec *ah_esp_hdr = &fsp->h_u.ah_ip6_spec;\n\tstruct ethtool_ah_espip6_spec *ah_esp_mask = &fsp->m_u.ah_ip6_spec;\n\tstruct flow_msg *pmask = &req->mask;\n\tstruct flow_msg *pkt = &req->packet;\n\n\tswitch (flow_type) {\n\tcase IPV6_USER_FLOW:\n\t\tif (!ipv6_addr_any((struct in6_addr *)ipv6_usr_mask->ip6src)) {\n\t\t\tmemcpy(&pkt->ip6src, &ipv6_usr_hdr->ip6src,\n\t\t\t       sizeof(pkt->ip6src));\n\t\t\tmemcpy(&pmask->ip6src, &ipv6_usr_mask->ip6src,\n\t\t\t       sizeof(pmask->ip6src));\n\t\t\treq->features |= BIT_ULL(NPC_SIP_IPV6);\n\t\t}\n\t\tif (!ipv6_addr_any((struct in6_addr *)ipv6_usr_mask->ip6dst)) {\n\t\t\tmemcpy(&pkt->ip6dst, &ipv6_usr_hdr->ip6dst,\n\t\t\t       sizeof(pkt->ip6dst));\n\t\t\tmemcpy(&pmask->ip6dst, &ipv6_usr_mask->ip6dst,\n\t\t\t       sizeof(pmask->ip6dst));\n\t\t\treq->features |= BIT_ULL(NPC_DIP_IPV6);\n\t\t}\n\t\tif (ipv6_usr_hdr->l4_proto == IPPROTO_FRAGMENT) {\n\t\t\tpkt->next_header = ipv6_usr_hdr->l4_proto;\n\t\t\tpmask->next_header = ipv6_usr_mask->l4_proto;\n\t\t\treq->features |= BIT_ULL(NPC_IPFRAG_IPV6);\n\t\t}\n\t\tpkt->etype = cpu_to_be16(ETH_P_IPV6);\n\t\tpmask->etype = cpu_to_be16(0xFFFF);\n\t\treq->features |= BIT_ULL(NPC_ETYPE);\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\tpkt->etype = cpu_to_be16(ETH_P_IPV6);\n\t\tpmask->etype = cpu_to_be16(0xFFFF);\n\t\treq->features |= BIT_ULL(NPC_ETYPE);\n\t\tif (!ipv6_addr_any((struct in6_addr *)ipv6_l4_mask->ip6src)) {\n\t\t\tmemcpy(&pkt->ip6src, &ipv6_l4_hdr->ip6src,\n\t\t\t       sizeof(pkt->ip6src));\n\t\t\tmemcpy(&pmask->ip6src, &ipv6_l4_mask->ip6src,\n\t\t\t       sizeof(pmask->ip6src));\n\t\t\treq->features |= BIT_ULL(NPC_SIP_IPV6);\n\t\t}\n\t\tif (!ipv6_addr_any((struct in6_addr *)ipv6_l4_mask->ip6dst)) {\n\t\t\tmemcpy(&pkt->ip6dst, &ipv6_l4_hdr->ip6dst,\n\t\t\t       sizeof(pkt->ip6dst));\n\t\t\tmemcpy(&pmask->ip6dst, &ipv6_l4_mask->ip6dst,\n\t\t\t       sizeof(pmask->ip6dst));\n\t\t\treq->features |= BIT_ULL(NPC_DIP_IPV6);\n\t\t}\n\t\tif (ipv6_l4_mask->psrc) {\n\t\t\tmemcpy(&pkt->sport, &ipv6_l4_hdr->psrc,\n\t\t\t       sizeof(pkt->sport));\n\t\t\tmemcpy(&pmask->sport, &ipv6_l4_mask->psrc,\n\t\t\t       sizeof(pmask->sport));\n\t\t\tif (flow_type == UDP_V6_FLOW)\n\t\t\t\treq->features |= BIT_ULL(NPC_SPORT_UDP);\n\t\t\telse if (flow_type == TCP_V6_FLOW)\n\t\t\t\treq->features |= BIT_ULL(NPC_SPORT_TCP);\n\t\t\telse\n\t\t\t\treq->features |= BIT_ULL(NPC_SPORT_SCTP);\n\t\t}\n\t\tif (ipv6_l4_mask->pdst) {\n\t\t\tmemcpy(&pkt->dport, &ipv6_l4_hdr->pdst,\n\t\t\t       sizeof(pkt->dport));\n\t\t\tmemcpy(&pmask->dport, &ipv6_l4_mask->pdst,\n\t\t\t       sizeof(pmask->dport));\n\t\t\tif (flow_type == UDP_V6_FLOW)\n\t\t\t\treq->features |= BIT_ULL(NPC_DPORT_UDP);\n\t\t\telse if (flow_type == TCP_V6_FLOW)\n\t\t\t\treq->features |= BIT_ULL(NPC_DPORT_TCP);\n\t\t\telse\n\t\t\t\treq->features |= BIT_ULL(NPC_DPORT_SCTP);\n\t\t}\n\t\tif (flow_type == UDP_V6_FLOW)\n\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_UDP);\n\t\telse if (flow_type == TCP_V6_FLOW)\n\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_TCP);\n\t\telse\n\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_SCTP);\n\t\tbreak;\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\t\tpkt->etype = cpu_to_be16(ETH_P_IPV6);\n\t\tpmask->etype = cpu_to_be16(0xFFFF);\n\t\treq->features |= BIT_ULL(NPC_ETYPE);\n\t\tif (!ipv6_addr_any((struct in6_addr *)ah_esp_hdr->ip6src)) {\n\t\t\tmemcpy(&pkt->ip6src, &ah_esp_hdr->ip6src,\n\t\t\t       sizeof(pkt->ip6src));\n\t\t\tmemcpy(&pmask->ip6src, &ah_esp_mask->ip6src,\n\t\t\t       sizeof(pmask->ip6src));\n\t\t\treq->features |= BIT_ULL(NPC_SIP_IPV6);\n\t\t}\n\t\tif (!ipv6_addr_any((struct in6_addr *)ah_esp_hdr->ip6dst)) {\n\t\t\tmemcpy(&pkt->ip6dst, &ah_esp_hdr->ip6dst,\n\t\t\t       sizeof(pkt->ip6dst));\n\t\t\tmemcpy(&pmask->ip6dst, &ah_esp_mask->ip6dst,\n\t\t\t       sizeof(pmask->ip6dst));\n\t\t\treq->features |= BIT_ULL(NPC_DIP_IPV6);\n\t\t}\n\n\t\t \n\t\tif ((ah_esp_mask->spi & ah_esp_hdr->spi) ||\n\t\t    (ah_esp_mask->tclass & ah_esp_hdr->tclass))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (flow_type == AH_V6_FLOW)\n\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_AH);\n\t\telse\n\t\t\treq->features |= BIT_ULL(NPC_IPPROTO_ESP);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int otx2_prepare_flow_request(struct ethtool_rx_flow_spec *fsp,\n\t\t\t      struct npc_install_flow_req *req)\n{\n\tstruct ethhdr *eth_mask = &fsp->m_u.ether_spec;\n\tstruct ethhdr *eth_hdr = &fsp->h_u.ether_spec;\n\tstruct flow_msg *pmask = &req->mask;\n\tstruct flow_msg *pkt = &req->packet;\n\tu32 flow_type;\n\tint ret;\n\n\tflow_type = fsp->flow_type & ~(FLOW_EXT | FLOW_MAC_EXT | FLOW_RSS);\n\tswitch (flow_type) {\n\t \n\tcase ETHER_FLOW:\n\t\tif (!is_zero_ether_addr(eth_mask->h_source)) {\n\t\t\tether_addr_copy(pkt->smac, eth_hdr->h_source);\n\t\t\tether_addr_copy(pmask->smac, eth_mask->h_source);\n\t\t\treq->features |= BIT_ULL(NPC_SMAC);\n\t\t}\n\t\tif (!is_zero_ether_addr(eth_mask->h_dest)) {\n\t\t\tether_addr_copy(pkt->dmac, eth_hdr->h_dest);\n\t\t\tether_addr_copy(pmask->dmac, eth_mask->h_dest);\n\t\t\treq->features |= BIT_ULL(NPC_DMAC);\n\t\t}\n\t\tif (eth_hdr->h_proto) {\n\t\t\tmemcpy(&pkt->etype, &eth_hdr->h_proto,\n\t\t\t       sizeof(pkt->etype));\n\t\t\tmemcpy(&pmask->etype, &eth_mask->h_proto,\n\t\t\t       sizeof(pmask->etype));\n\t\t\treq->features |= BIT_ULL(NPC_ETYPE);\n\t\t}\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\t\tret = otx2_prepare_ipv4_flow(fsp, req, flow_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase IPV6_USER_FLOW:\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\t\tret = otx2_prepare_ipv6_flow(fsp, req, flow_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (fsp->flow_type & FLOW_EXT) {\n\t\tu16 vlan_etype;\n\n\t\tif (fsp->m_ext.vlan_etype) {\n\t\t\t \n\t\t\tif (be16_to_cpu(fsp->m_ext.vlan_etype) != 0xFFFF)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tvlan_etype = be16_to_cpu(fsp->h_ext.vlan_etype);\n\n\t\t\t \n\t\t\tif (vlan_etype == ETH_P_8021Q && !fsp->m_ext.vlan_tci &&\n\t\t\t    fsp->ring_cookie == RX_CLS_FLOW_DISC)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tif (vlan_etype != ETH_P_8021Q &&\n\t\t\t    vlan_etype != ETH_P_8021AD)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tmemcpy(&pkt->vlan_etype, &fsp->h_ext.vlan_etype,\n\t\t\t       sizeof(pkt->vlan_etype));\n\t\t\tmemcpy(&pmask->vlan_etype, &fsp->m_ext.vlan_etype,\n\t\t\t       sizeof(pmask->vlan_etype));\n\n\t\t\tif (vlan_etype == ETH_P_8021Q)\n\t\t\t\treq->features |= BIT_ULL(NPC_VLAN_ETYPE_CTAG);\n\t\t\telse\n\t\t\t\treq->features |= BIT_ULL(NPC_VLAN_ETYPE_STAG);\n\t\t}\n\n\t\tif (fsp->m_ext.vlan_tci) {\n\t\t\tmemcpy(&pkt->vlan_tci, &fsp->h_ext.vlan_tci,\n\t\t\t       sizeof(pkt->vlan_tci));\n\t\t\tmemcpy(&pmask->vlan_tci, &fsp->m_ext.vlan_tci,\n\t\t\t       sizeof(pmask->vlan_tci));\n\t\t\treq->features |= BIT_ULL(NPC_OUTER_VID);\n\t\t}\n\n\t\tif (fsp->m_ext.data[1]) {\n\t\t\tif (flow_type == IP_USER_FLOW) {\n\t\t\t\tif (be32_to_cpu(fsp->h_ext.data[1]) != IPV4_FLAG_MORE)\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tpkt->ip_flag = be32_to_cpu(fsp->h_ext.data[1]);\n\t\t\t\tpmask->ip_flag = be32_to_cpu(fsp->m_ext.data[1]);\n\t\t\t\treq->features |= BIT_ULL(NPC_IPFRAG_IPV4);\n\t\t\t} else if (fsp->h_ext.data[1] ==\n\t\t\t\t\tcpu_to_be32(OTX2_DEFAULT_ACTION)) {\n\t\t\t\t \n\t\t\t\treq->op = NIX_RX_ACTION_DEFAULT;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fsp->flow_type & FLOW_MAC_EXT &&\n\t    !is_zero_ether_addr(fsp->m_ext.h_dest)) {\n\t\tether_addr_copy(pkt->dmac, fsp->h_ext.h_dest);\n\t\tether_addr_copy(pmask->dmac, fsp->m_ext.h_dest);\n\t\treq->features |= BIT_ULL(NPC_DMAC);\n\t}\n\n\tif (!req->features)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int otx2_is_flow_rule_dmacfilter(struct otx2_nic *pfvf,\n\t\t\t\t\tstruct ethtool_rx_flow_spec *fsp)\n{\n\tstruct ethhdr *eth_mask = &fsp->m_u.ether_spec;\n\tstruct ethhdr *eth_hdr = &fsp->h_u.ether_spec;\n\tu64 ring_cookie = fsp->ring_cookie;\n\tu32 flow_type;\n\n\tif (!(pfvf->flags & OTX2_FLAG_DMACFLTR_SUPPORT))\n\t\treturn false;\n\n\tflow_type = fsp->flow_type & ~(FLOW_EXT | FLOW_MAC_EXT | FLOW_RSS);\n\n\t \n\tif (flow_type == ETHER_FLOW && ring_cookie != RX_CLS_FLOW_DISC &&\n\t    !ethtool_get_flow_spec_ring_vf(ring_cookie)) {\n\t\tif (is_zero_ether_addr(eth_mask->h_dest) &&\n\t\t    is_valid_ether_addr(eth_hdr->h_dest))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int otx2_add_flow_msg(struct otx2_nic *pfvf, struct otx2_flow *flow)\n{\n\tu64 ring_cookie = flow->flow_spec.ring_cookie;\n#ifdef CONFIG_DCB\n\tint vlan_prio, qidx, pfc_rule = 0;\n#endif\n\tstruct npc_install_flow_req *req;\n\tint err, vf = 0;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_npc_install_flow(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = otx2_prepare_flow_request(&flow->flow_spec, req);\n\tif (err) {\n\t\t \n\t\totx2_mbox_reset(&pfvf->mbox.mbox, 0);\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn err;\n\t}\n\n\treq->entry = flow->entry;\n\treq->intf = NIX_INTF_RX;\n\treq->set_cntr = 1;\n\treq->channel = pfvf->hw.rx_chan_base;\n\tif (ring_cookie == RX_CLS_FLOW_DISC) {\n\t\treq->op = NIX_RX_ACTIONOP_DROP;\n\t} else {\n\t\t \n\t\tif (flow->flow_spec.flow_type & FLOW_RSS) {\n\t\t\treq->op = NIX_RX_ACTIONOP_RSS;\n\t\t\treq->index = flow->rss_ctx_id;\n\t\t\treq->flow_key_alg = pfvf->hw.flowkey_alg_idx;\n\t\t} else {\n\t\t\treq->op = NIX_RX_ACTIONOP_UCAST;\n\t\t\treq->index = ethtool_get_flow_spec_ring(ring_cookie);\n\t\t}\n\t\tvf = ethtool_get_flow_spec_ring_vf(ring_cookie);\n\t\tif (vf > pci_num_vf(pfvf->pdev)) {\n\t\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n#ifdef CONFIG_DCB\n\t\t \n\t\tif (!vf && (req->features & BIT_ULL(NPC_OUTER_VID)) &&\n\t\t    pfvf->pfc_en && req->op != NIX_RX_ACTIONOP_RSS) {\n\t\t\tvlan_prio = ntohs(req->packet.vlan_tci) &\n\t\t\t\t    ntohs(req->mask.vlan_tci);\n\n\t\t\t \n\t\t\tvlan_prio >>= 13;\n\t\t\tflow->rule_type |= PFC_FLOWCTRL_RULE;\n\t\t\t \n\t\t\tif (pfvf->pfc_en & BIT(vlan_prio)) {\n\t\t\t\tpfc_rule = true;\n\t\t\t\tqidx = req->index;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t \n\tif (vf) {\n\t\treq->vf = vf;\n\t\tflow->is_vf = true;\n\t\tflow->vf = vf;\n\t}\n\n\t \n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\n#ifdef CONFIG_DCB\n\tif (!err && pfc_rule)\n\t\totx2_update_bpid_in_rqctx(pfvf, vlan_prio, qidx, true);\n#endif\n\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn err;\n}\n\nstatic int otx2_add_flow_with_pfmac(struct otx2_nic *pfvf,\n\t\t\t\t    struct otx2_flow *flow)\n{\n\tstruct otx2_flow *pf_mac;\n\tstruct ethhdr *eth_hdr;\n\n\tpf_mac = kzalloc(sizeof(*pf_mac), GFP_KERNEL);\n\tif (!pf_mac)\n\t\treturn -ENOMEM;\n\n\tpf_mac->entry = 0;\n\tpf_mac->rule_type |= DMAC_FILTER_RULE;\n\tpf_mac->location = pfvf->flow_cfg->max_flows;\n\tmemcpy(&pf_mac->flow_spec, &flow->flow_spec,\n\t       sizeof(struct ethtool_rx_flow_spec));\n\tpf_mac->flow_spec.location = pf_mac->location;\n\n\t \n\teth_hdr = &pf_mac->flow_spec.h_u.ether_spec;\n\tether_addr_copy(eth_hdr->h_dest, pfvf->netdev->dev_addr);\n\n\t \n\totx2_dmacflt_add(pfvf, eth_hdr->h_dest, 0);\n\n\totx2_add_flow_to_list(pfvf, pf_mac);\n\tpfvf->flow_cfg->nr_flows++;\n\tset_bit(0, pfvf->flow_cfg->dmacflt_bmap);\n\n\treturn 0;\n}\n\nint otx2_add_flow(struct otx2_nic *pfvf, struct ethtool_rxnfc *nfc)\n{\n\tstruct otx2_flow_config *flow_cfg = pfvf->flow_cfg;\n\tstruct ethtool_rx_flow_spec *fsp = &nfc->fs;\n\tstruct otx2_flow *flow;\n\tstruct ethhdr *eth_hdr;\n\tbool new = false;\n\tint err = 0;\n\tu64 vf_num;\n\tu32 ring;\n\n\tif (!flow_cfg->max_flows) {\n\t\tnetdev_err(pfvf->netdev,\n\t\t\t   \"Ntuple rule count is 0, allocate and retry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tring = ethtool_get_flow_spec_ring(fsp->ring_cookie);\n\tif (!(pfvf->flags & OTX2_FLAG_NTUPLE_SUPPORT))\n\t\treturn -ENOMEM;\n\n\t \n\tvf_num = ethtool_get_flow_spec_ring_vf(fsp->ring_cookie);\n\tif (!is_otx2_vf(pfvf->pcifunc) && !vf_num &&\n\t    ring >= pfvf->hw.rx_queues && fsp->ring_cookie != RX_CLS_FLOW_DISC)\n\t\treturn -EINVAL;\n\n\tif (fsp->location >= otx2_get_maxflows(flow_cfg))\n\t\treturn -EINVAL;\n\n\tflow = otx2_find_flow(pfvf, fsp->location);\n\tif (!flow) {\n\t\tflow = kzalloc(sizeof(*flow), GFP_KERNEL);\n\t\tif (!flow)\n\t\t\treturn -ENOMEM;\n\t\tflow->location = fsp->location;\n\t\tflow->entry = flow_cfg->flow_ent[flow->location];\n\t\tnew = true;\n\t}\n\t \n\tflow->flow_spec = *fsp;\n\n\tif (fsp->flow_type & FLOW_RSS)\n\t\tflow->rss_ctx_id = nfc->rss_context;\n\n\tif (otx2_is_flow_rule_dmacfilter(pfvf, &flow->flow_spec)) {\n\t\teth_hdr = &flow->flow_spec.h_u.ether_spec;\n\n\t\t \n\t\tif (flow->rule_type & DMAC_FILTER_RULE)\n\t\t\treturn otx2_dmacflt_update(pfvf, eth_hdr->h_dest,\n\t\t\t\t\t\t   flow->entry);\n\n\t\tif (bitmap_full(flow_cfg->dmacflt_bmap,\n\t\t\t\tflow_cfg->dmacflt_max_flows)) {\n\t\t\tnetdev_warn(pfvf->netdev,\n\t\t\t\t    \"Can't insert the rule %d as max allowed dmac filters are %d\\n\",\n\t\t\t\t    flow->location +\n\t\t\t\t    flow_cfg->dmacflt_max_flows,\n\t\t\t\t    flow_cfg->dmacflt_max_flows);\n\t\t\terr = -EINVAL;\n\t\t\tif (new)\n\t\t\t\tkfree(flow);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tif (!test_bit(0, flow_cfg->dmacflt_bmap))\n\t\t\totx2_add_flow_with_pfmac(pfvf, flow);\n\n\t\tflow->rule_type |= DMAC_FILTER_RULE;\n\t\tflow->entry = find_first_zero_bit(flow_cfg->dmacflt_bmap,\n\t\t\t\t\t\t  flow_cfg->dmacflt_max_flows);\n\t\tfsp->location = flow_cfg->max_flows + flow->entry;\n\t\tflow->flow_spec.location = fsp->location;\n\t\tflow->location = fsp->location;\n\n\t\tset_bit(flow->entry, flow_cfg->dmacflt_bmap);\n\t\totx2_dmacflt_add(pfvf, eth_hdr->h_dest, flow->entry);\n\n\t} else {\n\t\tif (flow->location >= pfvf->flow_cfg->max_flows) {\n\t\t\tnetdev_warn(pfvf->netdev,\n\t\t\t\t    \"Can't insert non dmac ntuple rule at %d, allowed range %d-0\\n\",\n\t\t\t\t    flow->location,\n\t\t\t\t    flow_cfg->max_flows - 1);\n\t\t\terr = -EINVAL;\n\t\t} else {\n\t\t\terr = otx2_add_flow_msg(pfvf, flow);\n\t\t}\n\t}\n\n\tif (err) {\n\t\tif (err == MBOX_MSG_INVALID)\n\t\t\terr = -EINVAL;\n\t\tif (new)\n\t\t\tkfree(flow);\n\t\treturn err;\n\t}\n\n\t \n\tif (new) {\n\t\totx2_add_flow_to_list(pfvf, flow);\n\t\tflow_cfg->nr_flows++;\n\t}\n\n\tif (flow->is_vf)\n\t\tnetdev_info(pfvf->netdev,\n\t\t\t    \"Make sure that VF's queue number is within its queue limit\\n\");\n\treturn 0;\n}\n\nstatic int otx2_remove_flow_msg(struct otx2_nic *pfvf, u16 entry, bool all)\n{\n\tstruct npc_delete_flow_req *req;\n\tint err;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_npc_delete_flow(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->entry = entry;\n\tif (all)\n\t\treq->all = 1;\n\n\t \n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn err;\n}\n\nstatic void otx2_update_rem_pfmac(struct otx2_nic *pfvf, int req)\n{\n\tstruct otx2_flow *iter;\n\tstruct ethhdr *eth_hdr;\n\tbool found = false;\n\n\tlist_for_each_entry(iter, &pfvf->flow_cfg->flow_list, list) {\n\t\tif ((iter->rule_type & DMAC_FILTER_RULE) && iter->entry == 0) {\n\t\t\teth_hdr = &iter->flow_spec.h_u.ether_spec;\n\t\t\tif (req == DMAC_ADDR_DEL) {\n\t\t\t\totx2_dmacflt_remove(pfvf, eth_hdr->h_dest,\n\t\t\t\t\t\t    0);\n\t\t\t\tclear_bit(0, pfvf->flow_cfg->dmacflt_bmap);\n\t\t\t\tfound = true;\n\t\t\t} else {\n\t\t\t\tether_addr_copy(eth_hdr->h_dest,\n\t\t\t\t\t\tpfvf->netdev->dev_addr);\n\n\t\t\t\totx2_dmacflt_update(pfvf, eth_hdr->h_dest, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tlist_del(&iter->list);\n\t\tkfree(iter);\n\t\tpfvf->flow_cfg->nr_flows--;\n\t}\n}\n\nint otx2_remove_flow(struct otx2_nic *pfvf, u32 location)\n{\n\tstruct otx2_flow_config *flow_cfg = pfvf->flow_cfg;\n\tstruct otx2_flow *flow;\n\tint err;\n\n\tif (location >= otx2_get_maxflows(flow_cfg))\n\t\treturn -EINVAL;\n\n\tflow = otx2_find_flow(pfvf, location);\n\tif (!flow)\n\t\treturn -ENOENT;\n\n\tif (flow->rule_type & DMAC_FILTER_RULE) {\n\t\tstruct ethhdr *eth_hdr = &flow->flow_spec.h_u.ether_spec;\n\n\t\t \n\t\tif (ether_addr_equal(pfvf->netdev->dev_addr, eth_hdr->h_dest))\n\t\t\treturn -EPERM;\n\n\t\terr = otx2_dmacflt_remove(pfvf, eth_hdr->h_dest,\n\t\t\t\t\t  flow->entry);\n\t\tclear_bit(flow->entry, flow_cfg->dmacflt_bmap);\n\t\t \n\t\tif (bitmap_weight(flow_cfg->dmacflt_bmap,\n\t\t\t\t  flow_cfg->dmacflt_max_flows) == 1)\n\t\t\totx2_update_rem_pfmac(pfvf, DMAC_ADDR_DEL);\n\t} else {\n#ifdef CONFIG_DCB\n\t\tif (flow->rule_type & PFC_FLOWCTRL_RULE)\n\t\t\totx2_update_bpid_in_rqctx(pfvf, 0,\n\t\t\t\t\t\t  flow->flow_spec.ring_cookie,\n\t\t\t\t\t\t  false);\n#endif\n\n\t\terr = otx2_remove_flow_msg(pfvf, flow->entry, false);\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\tlist_del(&flow->list);\n\tkfree(flow);\n\tflow_cfg->nr_flows--;\n\n\treturn 0;\n}\n\nvoid otx2_rss_ctx_flow_del(struct otx2_nic *pfvf, int ctx_id)\n{\n\tstruct otx2_flow *flow, *tmp;\n\tint err;\n\n\tlist_for_each_entry_safe(flow, tmp, &pfvf->flow_cfg->flow_list, list) {\n\t\tif (flow->rss_ctx_id != ctx_id)\n\t\t\tcontinue;\n\t\terr = otx2_remove_flow(pfvf, flow->location);\n\t\tif (err)\n\t\t\tnetdev_warn(pfvf->netdev,\n\t\t\t\t    \"Can't delete the rule %d associated with this rss group err:%d\",\n\t\t\t\t    flow->location, err);\n\t}\n}\n\nint otx2_destroy_ntuple_flows(struct otx2_nic *pfvf)\n{\n\tstruct otx2_flow_config *flow_cfg = pfvf->flow_cfg;\n\tstruct npc_delete_flow_req *req;\n\tstruct otx2_flow *iter, *tmp;\n\tint err;\n\n\tif (!(pfvf->flags & OTX2_FLAG_NTUPLE_SUPPORT))\n\t\treturn 0;\n\n\tif (!flow_cfg->max_flows)\n\t\treturn 0;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_npc_delete_flow(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->start = flow_cfg->flow_ent[0];\n\treq->end   = flow_cfg->flow_ent[flow_cfg->max_flows - 1];\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tmutex_unlock(&pfvf->mbox.lock);\n\n\tlist_for_each_entry_safe(iter, tmp, &flow_cfg->flow_list, list) {\n\t\tlist_del(&iter->list);\n\t\tkfree(iter);\n\t\tflow_cfg->nr_flows--;\n\t}\n\treturn err;\n}\n\nint otx2_destroy_mcam_flows(struct otx2_nic *pfvf)\n{\n\tstruct otx2_flow_config *flow_cfg = pfvf->flow_cfg;\n\tstruct npc_mcam_free_entry_req *req;\n\tstruct otx2_flow *iter, *tmp;\n\tint err;\n\n\tif (!(pfvf->flags & OTX2_FLAG_MCAM_ENTRIES_ALLOC))\n\t\treturn 0;\n\n\t \n\terr = otx2_remove_flow_msg(pfvf, 0, true);\n\tif (err)\n\t\treturn err;\n\n\tlist_for_each_entry_safe(iter, tmp, &flow_cfg->flow_list, list) {\n\t\tlist_del(&iter->list);\n\t\tkfree(iter);\n\t\tflow_cfg->nr_flows--;\n\t}\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_npc_mcam_free_entry(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->all = 1;\n\t \n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (err) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn err;\n\t}\n\n\tpfvf->flags &= ~OTX2_FLAG_MCAM_ENTRIES_ALLOC;\n\tmutex_unlock(&pfvf->mbox.lock);\n\n\treturn 0;\n}\n\nint otx2_install_rxvlan_offload_flow(struct otx2_nic *pfvf)\n{\n\tstruct otx2_flow_config *flow_cfg = pfvf->flow_cfg;\n\tstruct npc_install_flow_req *req;\n\tint err;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_npc_install_flow(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->entry = flow_cfg->def_ent[flow_cfg->rx_vlan_offset];\n\treq->intf = NIX_INTF_RX;\n\tether_addr_copy(req->packet.dmac, pfvf->netdev->dev_addr);\n\teth_broadcast_addr((u8 *)&req->mask.dmac);\n\treq->channel = pfvf->hw.rx_chan_base;\n\treq->op = NIX_RX_ACTION_DEFAULT;\n\treq->features = BIT_ULL(NPC_OUTER_VID) | BIT_ULL(NPC_DMAC);\n\treq->vtag0_valid = true;\n\treq->vtag0_type = NIX_AF_LFX_RX_VTAG_TYPE0;\n\n\t \n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn err;\n}\n\nstatic int otx2_delete_rxvlan_offload_flow(struct otx2_nic *pfvf)\n{\n\tstruct otx2_flow_config *flow_cfg = pfvf->flow_cfg;\n\tstruct npc_delete_flow_req *req;\n\tint err;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_npc_delete_flow(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->entry = flow_cfg->def_ent[flow_cfg->rx_vlan_offset];\n\t \n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn err;\n}\n\nint otx2_enable_rxvlan(struct otx2_nic *pf, bool enable)\n{\n\tstruct nix_vtag_config *req;\n\tstruct mbox_msghdr *rsp_hdr;\n\tint err;\n\n\t \n\tif (!(pf->flags & OTX2_FLAG_RX_VLAN_SUPPORT))\n\t\treturn -ENOMEM;\n\n\tif (enable) {\n\t\terr = otx2_install_rxvlan_offload_flow(pf);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\terr = otx2_delete_rxvlan_offload_flow(pf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmutex_lock(&pf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_nix_vtag_cfg(&pf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\treq->vtag_size = VTAGSIZE_T4;\n\treq->cfg_type = 1;  \n\treq->rx.vtag_type = NIX_AF_LFX_RX_VTAG_TYPE0;\n\treq->rx.strip_vtag = enable;\n\treq->rx.capture_vtag = enable;\n\n\terr = otx2_sync_mbox_msg(&pf->mbox);\n\tif (err) {\n\t\tmutex_unlock(&pf->mbox.lock);\n\t\treturn err;\n\t}\n\n\trsp_hdr = otx2_mbox_get_rsp(&pf->mbox.mbox, 0, &req->hdr);\n\tif (IS_ERR(rsp_hdr)) {\n\t\tmutex_unlock(&pf->mbox.lock);\n\t\treturn PTR_ERR(rsp_hdr);\n\t}\n\n\tmutex_unlock(&pf->mbox.lock);\n\treturn rsp_hdr->rc;\n}\n\nvoid otx2_dmacflt_reinstall_flows(struct otx2_nic *pf)\n{\n\tstruct otx2_flow *iter;\n\tstruct ethhdr *eth_hdr;\n\n\tlist_for_each_entry(iter, &pf->flow_cfg->flow_list, list) {\n\t\tif (iter->rule_type & DMAC_FILTER_RULE) {\n\t\t\teth_hdr = &iter->flow_spec.h_u.ether_spec;\n\t\t\totx2_dmacflt_add(pf, eth_hdr->h_dest,\n\t\t\t\t\t iter->entry);\n\t\t}\n\t}\n}\n\nvoid otx2_dmacflt_update_pfmac_flow(struct otx2_nic *pfvf)\n{\n\totx2_update_rem_pfmac(pfvf, DMAC_ADDR_UPDATE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}