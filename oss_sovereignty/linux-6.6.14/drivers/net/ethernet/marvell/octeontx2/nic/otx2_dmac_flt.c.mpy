{
  "module_name": "otx2_dmac_flt.c",
  "hash_id": "36e70efd948507713208410bc829503eab7db0d2723730c1f7b43778089dfe73",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/nic/otx2_dmac_flt.c",
  "human_readable_source": "\n \n\n#include \"otx2_common.h\"\n\nstatic int otx2_dmacflt_do_add(struct otx2_nic *pf, const u8 *mac,\n\t\t\t       u32 *dmac_index)\n{\n\tstruct cgx_mac_addr_add_req *req;\n\tstruct cgx_mac_addr_add_rsp *rsp;\n\tint err;\n\n\tmutex_lock(&pf->mbox.lock);\n\n\treq = otx2_mbox_alloc_msg_cgx_mac_addr_add(&pf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tether_addr_copy(req->mac_addr, mac);\n\terr = otx2_sync_mbox_msg(&pf->mbox);\n\n\tif (!err) {\n\t\trsp = (struct cgx_mac_addr_add_rsp *)\n\t\t\t otx2_mbox_get_rsp(&pf->mbox.mbox, 0, &req->hdr);\n\t\t*dmac_index = rsp->index;\n\t}\n\n\tmutex_unlock(&pf->mbox.lock);\n\treturn err;\n}\n\nstatic int otx2_dmacflt_add_pfmac(struct otx2_nic *pf, u32 *dmac_index)\n{\n\tstruct cgx_mac_addr_set_or_get *req;\n\tstruct cgx_mac_addr_set_or_get *rsp;\n\tint err;\n\n\tmutex_lock(&pf->mbox.lock);\n\n\treq = otx2_mbox_alloc_msg_cgx_mac_addr_set(&pf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->index = *dmac_index;\n\n\tether_addr_copy(req->mac_addr, pf->netdev->dev_addr);\n\terr = otx2_sync_mbox_msg(&pf->mbox);\n\n\tif (err)\n\t\tgoto out;\n\n\trsp = (struct cgx_mac_addr_set_or_get *)\n\t\totx2_mbox_get_rsp(&pf->mbox.mbox, 0, &req->hdr);\n\n\tif (IS_ERR_OR_NULL(rsp)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*dmac_index = rsp->index;\nout:\n\tmutex_unlock(&pf->mbox.lock);\n\treturn err;\n}\n\nint otx2_dmacflt_add(struct otx2_nic *pf, const u8 *mac, u32 bit_pos)\n{\n\tu32 *dmacindex;\n\n\t \n\tdmacindex = &pf->flow_cfg->bmap_to_dmacindex[bit_pos];\n\n\tif (ether_addr_equal(mac, pf->netdev->dev_addr))\n\t\treturn otx2_dmacflt_add_pfmac(pf, dmacindex);\n\telse\n\t\treturn otx2_dmacflt_do_add(pf, mac, dmacindex);\n}\n\nstatic int otx2_dmacflt_do_remove(struct otx2_nic *pfvf, const u8 *mac,\n\t\t\t\t  u32 dmac_index)\n{\n\tstruct cgx_mac_addr_del_req *req;\n\tint err;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_cgx_mac_addr_del(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->index = dmac_index;\n\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tmutex_unlock(&pfvf->mbox.lock);\n\n\treturn err;\n}\n\nstatic int otx2_dmacflt_remove_pfmac(struct otx2_nic *pf, u32 dmac_index)\n{\n\tstruct cgx_mac_addr_reset_req *req;\n\tint err;\n\n\tmutex_lock(&pf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_cgx_mac_addr_reset(&pf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\treq->index = dmac_index;\n\n\terr = otx2_sync_mbox_msg(&pf->mbox);\n\n\tmutex_unlock(&pf->mbox.lock);\n\treturn err;\n}\n\nint otx2_dmacflt_remove(struct otx2_nic *pf, const u8 *mac,\n\t\t\tu32 bit_pos)\n{\n\tu32 dmacindex = pf->flow_cfg->bmap_to_dmacindex[bit_pos];\n\n\tif (ether_addr_equal(mac, pf->netdev->dev_addr))\n\t\treturn otx2_dmacflt_remove_pfmac(pf, dmacindex);\n\telse\n\t\treturn otx2_dmacflt_do_remove(pf, mac, dmacindex);\n}\n\n \nint otx2_dmacflt_get_max_cnt(struct otx2_nic *pf)\n{\n\tstruct cgx_max_dmac_entries_get_rsp *rsp;\n\tstruct msg_req *msg;\n\tint err;\n\n\tmutex_lock(&pf->mbox.lock);\n\tmsg = otx2_mbox_alloc_msg_cgx_mac_max_entries_get(&pf->mbox);\n\n\tif (!msg) {\n\t\tmutex_unlock(&pf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = otx2_sync_mbox_msg(&pf->mbox);\n\tif (err)\n\t\tgoto out;\n\n\trsp = (struct cgx_max_dmac_entries_get_rsp *)\n\t\t     otx2_mbox_get_rsp(&pf->mbox.mbox, 0, &msg->hdr);\n\n\tif (IS_ERR_OR_NULL(rsp)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpf->flow_cfg->dmacflt_max_flows = rsp->max_dmac_filters;\n\nout:\n\tmutex_unlock(&pf->mbox.lock);\n\treturn err;\n}\n\nint otx2_dmacflt_update(struct otx2_nic *pf, u8 *mac, u32 bit_pos)\n{\n\tstruct cgx_mac_addr_update_req *req;\n\tstruct cgx_mac_addr_update_rsp *rsp;\n\tint rc;\n\n\tmutex_lock(&pf->mbox.lock);\n\n\treq = otx2_mbox_alloc_msg_cgx_mac_addr_update(&pf->mbox);\n\n\tif (!req) {\n\t\tmutex_unlock(&pf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tether_addr_copy(req->mac_addr, mac);\n\treq->index = pf->flow_cfg->bmap_to_dmacindex[bit_pos];\n\n\t \n\n\trc = otx2_sync_mbox_msg(&pf->mbox);\n\tif (rc)\n\t\tgoto out;\n\n\trsp = (struct cgx_mac_addr_update_rsp *)\n\t\totx2_mbox_get_rsp(&pf->mbox.mbox, 0, &req->hdr);\n\n\tpf->flow_cfg->bmap_to_dmacindex[bit_pos] = rsp->index;\n\nout:\n\tmutex_unlock(&pf->mbox.lock);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}