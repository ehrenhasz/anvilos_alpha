{
  "module_name": "cn10k.c",
  "hash_id": "4d241a1628f8c93bc316bc67e3ca88e183270510ba32f29cec06d2347c4a22ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/nic/cn10k.c",
  "human_readable_source": "\n \n\n#include \"cn10k.h\"\n#include \"otx2_reg.h\"\n#include \"otx2_struct.h\"\n\nstatic struct dev_hw_ops\totx2_hw_ops = {\n\t.sq_aq_init = otx2_sq_aq_init,\n\t.sqe_flush = otx2_sqe_flush,\n\t.aura_freeptr = otx2_aura_freeptr,\n\t.refill_pool_ptrs = otx2_refill_pool_ptrs,\n};\n\nstatic struct dev_hw_ops cn10k_hw_ops = {\n\t.sq_aq_init = cn10k_sq_aq_init,\n\t.sqe_flush = cn10k_sqe_flush,\n\t.aura_freeptr = cn10k_aura_freeptr,\n\t.refill_pool_ptrs = cn10k_refill_pool_ptrs,\n};\n\nint cn10k_lmtst_init(struct otx2_nic *pfvf)\n{\n\n\tstruct lmtst_tbl_setup_req *req;\n\tstruct otx2_lmt_info *lmt_info;\n\tint err, cpu;\n\n\tif (!test_bit(CN10K_LMTST, &pfvf->hw.cap_flag)) {\n\t\tpfvf->hw_ops = &otx2_hw_ops;\n\t\treturn 0;\n\t}\n\n\tpfvf->hw_ops = &cn10k_hw_ops;\n\t \n\tpfvf->tot_lmt_lines = (num_online_cpus() * LMT_BURST_SIZE);\n\tpfvf->hw.lmt_info = alloc_percpu(struct otx2_lmt_info);\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_lmtst_tbl_setup(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->use_local_lmt_region = true;\n\n\terr = qmem_alloc(pfvf->dev, &pfvf->dync_lmt, pfvf->tot_lmt_lines,\n\t\t\t LMT_LINE_SIZE);\n\tif (err) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn err;\n\t}\n\tpfvf->hw.lmt_base = (u64 *)pfvf->dync_lmt->base;\n\treq->lmt_iova = (u64)pfvf->dync_lmt->iova;\n\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tmutex_unlock(&pfvf->mbox.lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tlmt_info = per_cpu_ptr(pfvf->hw.lmt_info, cpu);\n\t\tlmt_info->lmt_addr = ((u64)pfvf->hw.lmt_base +\n\t\t\t\t      (cpu * LMT_BURST_SIZE * LMT_LINE_SIZE));\n\t\tlmt_info->lmt_id = cpu * LMT_BURST_SIZE;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cn10k_lmtst_init);\n\nint cn10k_sq_aq_init(void *dev, u16 qidx, u16 sqb_aura)\n{\n\tstruct nix_cn10k_aq_enq_req *aq;\n\tstruct otx2_nic *pfvf = dev;\n\n\t \n\taq = otx2_mbox_alloc_msg_nix_cn10k_aq_enq(&pfvf->mbox);\n\tif (!aq)\n\t\treturn -ENOMEM;\n\n\taq->sq.cq = pfvf->hw.rx_queues + qidx;\n\taq->sq.max_sqe_size = NIX_MAXSQESZ_W16;  \n\taq->sq.cq_ena = 1;\n\taq->sq.ena = 1;\n\taq->sq.smq = otx2_get_smq_idx(pfvf, qidx);\n\taq->sq.smq_rr_weight = mtu_to_dwrr_weight(pfvf, pfvf->tx_max_pktlen);\n\taq->sq.default_chan = pfvf->hw.tx_chan_base;\n\taq->sq.sqe_stype = NIX_STYPE_STF;  \n\taq->sq.sqb_aura = sqb_aura;\n\taq->sq.sq_int_ena = NIX_SQINT_BITS;\n\taq->sq.qint_idx = 0;\n\t \n\taq->sq.cq_limit = ((SEND_CQ_SKID * 256) / (pfvf->qset.sqe_cnt));\n\n\t \n\taq->qidx = qidx;\n\taq->ctype = NIX_AQ_CTYPE_SQ;\n\taq->op = NIX_AQ_INSTOP_INIT;\n\n\treturn otx2_sync_mbox_msg(&pfvf->mbox);\n}\n\n#define NPA_MAX_BURST 16\nint cn10k_refill_pool_ptrs(void *dev, struct otx2_cq_queue *cq)\n{\n\tstruct otx2_nic *pfvf = dev;\n\tint cnt = cq->pool_ptrs;\n\tu64 ptrs[NPA_MAX_BURST];\n\tdma_addr_t bufptr;\n\tint num_ptrs = 1;\n\n\t \n\twhile (cq->pool_ptrs) {\n\t\tif (otx2_alloc_buffer(pfvf, cq, &bufptr)) {\n\t\t\tif (num_ptrs--)\n\t\t\t\t__cn10k_aura_freeptr(pfvf, cq->cq_idx, ptrs,\n\t\t\t\t\t\t     num_ptrs);\n\t\t\tbreak;\n\t\t}\n\t\tcq->pool_ptrs--;\n\t\tptrs[num_ptrs] = (u64)bufptr + OTX2_HEAD_ROOM;\n\t\tnum_ptrs++;\n\t\tif (num_ptrs == NPA_MAX_BURST || cq->pool_ptrs == 0) {\n\t\t\t__cn10k_aura_freeptr(pfvf, cq->cq_idx, ptrs,\n\t\t\t\t\t     num_ptrs);\n\t\t\tnum_ptrs = 1;\n\t\t}\n\t}\n\treturn cnt - cq->pool_ptrs;\n}\n\nvoid cn10k_sqe_flush(void *dev, struct otx2_snd_queue *sq, int size, int qidx)\n{\n\tstruct otx2_lmt_info *lmt_info;\n\tstruct otx2_nic *pfvf = dev;\n\tu64 val = 0, tar_addr = 0;\n\n\tlmt_info = per_cpu_ptr(pfvf->hw.lmt_info, smp_processor_id());\n\t \n\tval = (lmt_info->lmt_id & 0x7FF);\n\t \n\ttar_addr |= sq->io_addr | (((size / 16) - 1) & 0x7) << 4;\n\tdma_wmb();\n\tmemcpy((u64 *)lmt_info->lmt_addr, sq->sqe_base, size);\n\tcn10k_lmt_flush(val, tar_addr);\n\n\tsq->head++;\n\tsq->head &= (sq->sqe_cnt - 1);\n}\n\nint cn10k_free_all_ipolicers(struct otx2_nic *pfvf)\n{\n\tstruct nix_bandprof_free_req *req;\n\tint rc;\n\n\tif (is_dev_otx2(pfvf->pdev))\n\t\treturn 0;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\n\treq = otx2_mbox_alloc_msg_nix_bandprof_free(&pfvf->mbox);\n\tif (!req) {\n\t\trc =  -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\treq->free_all = true;\n\n\trc = otx2_sync_mbox_msg(&pfvf->mbox);\nout:\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn rc;\n}\n\nint cn10k_alloc_leaf_profile(struct otx2_nic *pfvf, u16 *leaf)\n{\n\tstruct nix_bandprof_alloc_req *req;\n\tstruct nix_bandprof_alloc_rsp *rsp;\n\tint rc;\n\n\treq = otx2_mbox_alloc_msg_nix_bandprof_alloc(&pfvf->mbox);\n\tif (!req)\n\t\treturn  -ENOMEM;\n\n\treq->prof_count[BAND_PROF_LEAF_LAYER] = 1;\n\n\trc = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (rc)\n\t\tgoto out;\n\n\trsp = (struct  nix_bandprof_alloc_rsp *)\n\t       otx2_mbox_get_rsp(&pfvf->mbox.mbox, 0, &req->hdr);\n\tif (!rsp->prof_count[BAND_PROF_LEAF_LAYER]) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t*leaf = rsp->prof_idx[BAND_PROF_LEAF_LAYER][0];\nout:\n\tif (rc) {\n\t\tdev_warn(pfvf->dev,\n\t\t\t \"Failed to allocate ingress bandwidth policer\\n\");\n\t}\n\n\treturn rc;\n}\n\nint cn10k_alloc_matchall_ipolicer(struct otx2_nic *pfvf)\n{\n\tstruct otx2_hw *hw = &pfvf->hw;\n\tint ret;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\n\tret = cn10k_alloc_leaf_profile(pfvf, &hw->matchall_ipolicer);\n\n\tmutex_unlock(&pfvf->mbox.lock);\n\n\treturn ret;\n}\n\n#define POLICER_TIMESTAMP\t  1   \n#define MAX_RATE_EXP\t\t  22  \n\nstatic void cn10k_get_ingress_burst_cfg(u32 burst, u32 *burst_exp,\n\t\t\t\t\tu32 *burst_mantissa)\n{\n\tint tmp;\n\n\t \n\t*burst_exp = ilog2(burst);\n\tif (burst < 256) {\n\t\t \n\t\t*burst_mantissa = 0;\n\t\treturn;\n\t}\n\n\tif (*burst_exp > MAX_RATE_EXP)\n\t\t*burst_exp = MAX_RATE_EXP;\n\n\t \n\ttmp = burst - rounddown_pow_of_two(burst);\n\t*burst_mantissa = tmp / (1UL << (*burst_exp - 8));\n}\n\nstatic void cn10k_get_ingress_rate_cfg(u64 rate, u32 *rate_exp,\n\t\t\t\t       u32 *rate_mantissa, u32 *rdiv)\n{\n\tu32 div = 0;\n\tu32 exp = 0;\n\tu64 tmp;\n\n\t \n\ttmp = rate * 32 * 2;\n\tif (tmp < 256000000) {\n\t\twhile (tmp < 256000000) {\n\t\t\ttmp = tmp * 2;\n\t\t\tdiv++;\n\t\t}\n\t} else {\n\t\tfor (exp = 0; tmp >= 512000000 && exp <= MAX_RATE_EXP; exp++)\n\t\t\ttmp = tmp / 2;\n\n\t\tif (exp > MAX_RATE_EXP)\n\t\t\texp = MAX_RATE_EXP;\n\t}\n\n\t*rate_mantissa = (tmp - 256000000) / 1000000;\n\t*rate_exp = exp;\n\t*rdiv = div;\n}\n\nint cn10k_map_unmap_rq_policer(struct otx2_nic *pfvf, int rq_idx,\n\t\t\t       u16 policer, bool map)\n{\n\tstruct nix_cn10k_aq_enq_req *aq;\n\n\taq = otx2_mbox_alloc_msg_nix_cn10k_aq_enq(&pfvf->mbox);\n\tif (!aq)\n\t\treturn -ENOMEM;\n\n\t \n\tif (map)\n\t\taq->rq.policer_ena = 1;\n\telse\n\t\taq->rq.policer_ena = 0;\n\taq->rq_mask.policer_ena = 1;\n\n\taq->rq.band_prof_id = policer;\n\taq->rq_mask.band_prof_id = GENMASK(9, 0);\n\n\t \n\taq->qidx = rq_idx;\n\taq->ctype = NIX_AQ_CTYPE_RQ;\n\taq->op = NIX_AQ_INSTOP_WRITE;\n\n\treturn otx2_sync_mbox_msg(&pfvf->mbox);\n}\n\nint cn10k_free_leaf_profile(struct otx2_nic *pfvf, u16 leaf)\n{\n\tstruct nix_bandprof_free_req *req;\n\n\treq = otx2_mbox_alloc_msg_nix_bandprof_free(&pfvf->mbox);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->prof_count[BAND_PROF_LEAF_LAYER] = 1;\n\treq->prof_idx[BAND_PROF_LEAF_LAYER][0] = leaf;\n\n\treturn otx2_sync_mbox_msg(&pfvf->mbox);\n}\n\nint cn10k_free_matchall_ipolicer(struct otx2_nic *pfvf)\n{\n\tstruct otx2_hw *hw = &pfvf->hw;\n\tint qidx, rc;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\n\t \n\tfor (qidx = 0; qidx < hw->rx_queues; qidx++)\n\t\tcn10k_map_unmap_rq_policer(pfvf, qidx,\n\t\t\t\t\t   hw->matchall_ipolicer, false);\n\n\trc = cn10k_free_leaf_profile(pfvf, hw->matchall_ipolicer);\n\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn rc;\n}\n\nint cn10k_set_ipolicer_rate(struct otx2_nic *pfvf, u16 profile,\n\t\t\t    u32 burst, u64 rate, bool pps)\n{\n\tstruct nix_cn10k_aq_enq_req *aq;\n\tu32 burst_exp, burst_mantissa;\n\tu32 rate_exp, rate_mantissa;\n\tu32 rdiv;\n\n\t \n\tcn10k_get_ingress_burst_cfg(burst, &burst_exp, &burst_mantissa);\n\tcn10k_get_ingress_rate_cfg(rate, &rate_exp, &rate_mantissa, &rdiv);\n\n\t \n\taq = otx2_mbox_alloc_msg_nix_cn10k_aq_enq(&pfvf->mbox);\n\tif (!aq)\n\t\treturn -ENOMEM;\n\n\t \n\taq->prof.icolor = 0x03;\n\taq->prof_mask.icolor = 0x03;\n\n\t \n\taq->prof.cir_exponent = rate_exp;\n\taq->prof_mask.cir_exponent = 0x1F;\n\n\taq->prof.cir_mantissa = rate_mantissa;\n\taq->prof_mask.cir_mantissa = 0xFF;\n\n\taq->prof.cbs_exponent = burst_exp;\n\taq->prof_mask.cbs_exponent = 0x1F;\n\n\taq->prof.cbs_mantissa = burst_mantissa;\n\taq->prof_mask.cbs_mantissa = 0xFF;\n\n\taq->prof.rdiv = rdiv;\n\taq->prof_mask.rdiv = 0xF;\n\n\tif (pps) {\n\t\t \n\t\taq->prof.adjust_exponent = 1;\n\t\taq->prof_mask.adjust_exponent = 0x1F;\n\n\t\taq->prof.adjust_mantissa = 384;\n\t\taq->prof_mask.adjust_mantissa = 0x1FF;\n\n\t\taq->prof.lmode = 0x1;\n\t\taq->prof_mask.lmode = 0x1;\n\t}\n\n\t \n\taq->prof.meter_algo = 2;\n\taq->prof_mask.meter_algo = 0x3;\n\n\taq->prof.rc_action = NIX_RX_BAND_PROF_ACTIONRESULT_DROP;\n\taq->prof_mask.rc_action = 0x3;\n\n\taq->prof.yc_action = NIX_RX_BAND_PROF_ACTIONRESULT_PASS;\n\taq->prof_mask.yc_action = 0x3;\n\n\taq->prof.gc_action = NIX_RX_BAND_PROF_ACTIONRESULT_PASS;\n\taq->prof_mask.gc_action = 0x3;\n\n\t \n\taq->prof.peir_exponent = 24;\n\taq->prof_mask.peir_exponent = 0x1F;\n\n\taq->prof.peir_mantissa = 0;\n\taq->prof_mask.peir_mantissa = 0xFF;\n\n\taq->prof.pebs_exponent = 24;\n\taq->prof_mask.pebs_exponent = 0x1F;\n\n\taq->prof.pebs_mantissa = 0;\n\taq->prof_mask.pebs_mantissa = 0xFF;\n\n\taq->prof.hl_en = 0;\n\taq->prof_mask.hl_en = 1;\n\n\t \n\taq->qidx = profile;\n\taq->ctype = NIX_AQ_CTYPE_BANDPROF;\n\taq->op = NIX_AQ_INSTOP_WRITE;\n\n\treturn otx2_sync_mbox_msg(&pfvf->mbox);\n}\n\nint cn10k_set_matchall_ipolicer_rate(struct otx2_nic *pfvf,\n\t\t\t\t     u32 burst, u64 rate)\n{\n\tstruct otx2_hw *hw = &pfvf->hw;\n\tint qidx, rc;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\n\trc = cn10k_set_ipolicer_rate(pfvf, hw->matchall_ipolicer, burst,\n\t\t\t\t     rate, false);\n\tif (rc)\n\t\tgoto out;\n\n\tfor (qidx = 0; qidx < hw->rx_queues; qidx++) {\n\t\trc = cn10k_map_unmap_rq_policer(pfvf, qidx,\n\t\t\t\t\t\thw->matchall_ipolicer, true);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}