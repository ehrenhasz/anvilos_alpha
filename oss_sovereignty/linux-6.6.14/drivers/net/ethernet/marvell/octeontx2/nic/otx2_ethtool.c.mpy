{
  "module_name": "otx2_ethtool.c",
  "hash_id": "eff16fd6be70f0f0dac33e311012081c9255f47d4b6cb9fc76affd4c3f12d60f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/nic/otx2_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/ethtool.h>\n#include <linux/stddef.h>\n#include <linux/etherdevice.h>\n#include <linux/log2.h>\n#include <linux/net_tstamp.h>\n#include <linux/linkmode.h>\n\n#include \"otx2_common.h\"\n#include \"otx2_ptp.h\"\n\n#define DRV_NAME\t\"rvu-nicpf\"\n#define DRV_VF_NAME\t\"rvu-nicvf\"\n\nstruct otx2_stat {\n\tchar name[ETH_GSTRING_LEN];\n\tunsigned int index;\n};\n\n \n#define OTX2_DEV_STAT(stat) { \\\n\t.name = #stat, \\\n\t.index = offsetof(struct otx2_dev_stats, stat) / sizeof(u64), \\\n}\n\nenum link_mode {\n\tOTX2_MODE_SUPPORTED,\n\tOTX2_MODE_ADVERTISED\n};\n\nstatic const struct otx2_stat otx2_dev_stats[] = {\n\tOTX2_DEV_STAT(rx_ucast_frames),\n\tOTX2_DEV_STAT(rx_bcast_frames),\n\tOTX2_DEV_STAT(rx_mcast_frames),\n\n\tOTX2_DEV_STAT(tx_ucast_frames),\n\tOTX2_DEV_STAT(tx_bcast_frames),\n\tOTX2_DEV_STAT(tx_mcast_frames),\n};\n\n \n#define OTX2_DRV_STAT(stat) { \\\n\t.name = #stat, \\\n\t.index = offsetof(struct otx2_drv_stats, stat) / sizeof(atomic_t), \\\n}\n\nstatic const struct otx2_stat otx2_drv_stats[] = {\n\tOTX2_DRV_STAT(rx_fcs_errs),\n\tOTX2_DRV_STAT(rx_oversize_errs),\n\tOTX2_DRV_STAT(rx_undersize_errs),\n\tOTX2_DRV_STAT(rx_csum_errs),\n\tOTX2_DRV_STAT(rx_len_errs),\n\tOTX2_DRV_STAT(rx_other_errs),\n};\n\nstatic const struct otx2_stat otx2_queue_stats[] = {\n\t{ \"bytes\", 0 },\n\t{ \"frames\", 1 },\n};\n\nstatic const unsigned int otx2_n_dev_stats = ARRAY_SIZE(otx2_dev_stats);\nstatic const unsigned int otx2_n_drv_stats = ARRAY_SIZE(otx2_drv_stats);\nstatic const unsigned int otx2_n_queue_stats = ARRAY_SIZE(otx2_queue_stats);\n\nstatic struct cgx_fw_data *otx2_get_fwdata(struct otx2_nic *pfvf);\n\nstatic void otx2_get_drvinfo(struct net_device *netdev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(pfvf->pdev), sizeof(info->bus_info));\n}\n\nstatic void otx2_get_qset_strings(struct otx2_nic *pfvf, u8 **data, int qset)\n{\n\tint start_qidx = qset * pfvf->hw.rx_queues;\n\tint qidx, stats;\n\n\tfor (qidx = 0; qidx < pfvf->hw.rx_queues; qidx++) {\n\t\tfor (stats = 0; stats < otx2_n_queue_stats; stats++) {\n\t\t\tsprintf(*data, \"rxq%d: %s\", qidx + start_qidx,\n\t\t\t\totx2_queue_stats[stats].name);\n\t\t\t*data += ETH_GSTRING_LEN;\n\t\t}\n\t}\n\n\tfor (qidx = 0; qidx < otx2_get_total_tx_queues(pfvf); qidx++) {\n\t\tfor (stats = 0; stats < otx2_n_queue_stats; stats++) {\n\t\t\tif (qidx >= pfvf->hw.non_qos_queues)\n\t\t\t\tsprintf(*data, \"txq_qos%d: %s\",\n\t\t\t\t\tqidx + start_qidx - pfvf->hw.non_qos_queues,\n\t\t\t\t\totx2_queue_stats[stats].name);\n\t\t\telse\n\t\t\t\tsprintf(*data, \"txq%d: %s\", qidx + start_qidx,\n\t\t\t\t\totx2_queue_stats[stats].name);\n\t\t\t*data += ETH_GSTRING_LEN;\n\t\t}\n\t}\n}\n\nstatic void otx2_get_strings(struct net_device *netdev, u32 sset, u8 *data)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tint stats;\n\n\tif (sset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (stats = 0; stats < otx2_n_dev_stats; stats++) {\n\t\tmemcpy(data, otx2_dev_stats[stats].name, ETH_GSTRING_LEN);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n\n\tfor (stats = 0; stats < otx2_n_drv_stats; stats++) {\n\t\tmemcpy(data, otx2_drv_stats[stats].name, ETH_GSTRING_LEN);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n\n\totx2_get_qset_strings(pfvf, &data, 0);\n\n\tif (!test_bit(CN10K_RPM, &pfvf->hw.cap_flag)) {\n\t\tfor (stats = 0; stats < CGX_RX_STATS_COUNT; stats++) {\n\t\t\tsprintf(data, \"cgx_rxstat%d: \", stats);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\n\t\tfor (stats = 0; stats < CGX_TX_STATS_COUNT; stats++) {\n\t\t\tsprintf(data, \"cgx_txstat%d: \", stats);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t}\n\n\tstrcpy(data, \"reset_count\");\n\tdata += ETH_GSTRING_LEN;\n\tsprintf(data, \"Fec Corrected Errors: \");\n\tdata += ETH_GSTRING_LEN;\n\tsprintf(data, \"Fec Uncorrected Errors: \");\n\tdata += ETH_GSTRING_LEN;\n}\n\nstatic void otx2_get_qset_stats(struct otx2_nic *pfvf,\n\t\t\t\tstruct ethtool_stats *stats, u64 **data)\n{\n\tint stat, qidx;\n\n\tif (!pfvf)\n\t\treturn;\n\tfor (qidx = 0; qidx < pfvf->hw.rx_queues; qidx++) {\n\t\tif (!otx2_update_rq_stats(pfvf, qidx)) {\n\t\t\tfor (stat = 0; stat < otx2_n_queue_stats; stat++)\n\t\t\t\t*((*data)++) = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (stat = 0; stat < otx2_n_queue_stats; stat++)\n\t\t\t*((*data)++) = ((u64 *)&pfvf->qset.rq[qidx].stats)\n\t\t\t\t[otx2_queue_stats[stat].index];\n\t}\n\n\tfor (qidx = 0; qidx < otx2_get_total_tx_queues(pfvf); qidx++) {\n\t\tif (!otx2_update_sq_stats(pfvf, qidx)) {\n\t\t\tfor (stat = 0; stat < otx2_n_queue_stats; stat++)\n\t\t\t\t*((*data)++) = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (stat = 0; stat < otx2_n_queue_stats; stat++)\n\t\t\t*((*data)++) = ((u64 *)&pfvf->qset.sq[qidx].stats)\n\t\t\t\t[otx2_queue_stats[stat].index];\n\t}\n}\n\nstatic int otx2_get_phy_fec_stats(struct otx2_nic *pfvf)\n{\n\tstruct msg_req *req;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_cgx_get_phy_fec_stats(&pfvf->mbox);\n\tif (!req)\n\t\tgoto end;\n\n\tif (!otx2_sync_mbox_msg(&pfvf->mbox))\n\t\trc = 0;\nend:\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn rc;\n}\n\n \nstatic void otx2_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t   struct ethtool_stats *stats, u64 *data)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tu64 fec_corr_blks, fec_uncorr_blks;\n\tstruct cgx_fw_data *rsp;\n\tint stat;\n\n\totx2_get_dev_stats(pfvf);\n\tfor (stat = 0; stat < otx2_n_dev_stats; stat++)\n\t\t*(data++) = ((u64 *)&pfvf->hw.dev_stats)\n\t\t\t\t[otx2_dev_stats[stat].index];\n\n\tfor (stat = 0; stat < otx2_n_drv_stats; stat++)\n\t\t*(data++) = atomic_read(&((atomic_t *)&pfvf->hw.drv_stats)\n\t\t\t\t\t\t[otx2_drv_stats[stat].index]);\n\n\totx2_get_qset_stats(pfvf, stats, &data);\n\n\tif (!test_bit(CN10K_RPM, &pfvf->hw.cap_flag)) {\n\t\totx2_update_lmac_stats(pfvf);\n\t\tfor (stat = 0; stat < CGX_RX_STATS_COUNT; stat++)\n\t\t\t*(data++) = pfvf->hw.cgx_rx_stats[stat];\n\t\tfor (stat = 0; stat < CGX_TX_STATS_COUNT; stat++)\n\t\t\t*(data++) = pfvf->hw.cgx_tx_stats[stat];\n\t}\n\n\t*(data++) = pfvf->reset_count;\n\n\tfec_corr_blks = pfvf->hw.cgx_fec_corr_blks;\n\tfec_uncorr_blks = pfvf->hw.cgx_fec_uncorr_blks;\n\n\trsp = otx2_get_fwdata(pfvf);\n\tif (!IS_ERR(rsp) && rsp->fwdata.phy.misc.has_fec_stats &&\n\t    !otx2_get_phy_fec_stats(pfvf)) {\n\t\t \n\t\trsp = otx2_get_fwdata(pfvf);\n\t\tif (!IS_ERR(rsp)) {\n\t\t\tstruct fec_stats_s *p = &rsp->fwdata.phy.fec_stats;\n\n\t\t\tif (pfvf->linfo.fec == OTX2_FEC_BASER) {\n\t\t\t\tfec_corr_blks   = p->brfec_corr_blks;\n\t\t\t\tfec_uncorr_blks = p->brfec_uncorr_blks;\n\t\t\t} else {\n\t\t\t\tfec_corr_blks   = p->rsfec_corr_cws;\n\t\t\t\tfec_uncorr_blks = p->rsfec_uncorr_cws;\n\t\t\t}\n\t\t}\n\t}\n\n\t*(data++) = fec_corr_blks;\n\t*(data++) = fec_uncorr_blks;\n}\n\nstatic int otx2_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tint qstats_count, mac_stats = 0;\n\n\tif (sset != ETH_SS_STATS)\n\t\treturn -EINVAL;\n\n\tqstats_count = otx2_n_queue_stats *\n\t\t       (pfvf->hw.rx_queues + otx2_get_total_tx_queues(pfvf));\n\tif (!test_bit(CN10K_RPM, &pfvf->hw.cap_flag))\n\t\tmac_stats = CGX_RX_STATS_COUNT + CGX_TX_STATS_COUNT;\n\totx2_update_lmac_fec_stats(pfvf);\n\n\treturn otx2_n_dev_stats + otx2_n_drv_stats + qstats_count +\n\t       mac_stats + OTX2_FEC_STATS_CNT + 1;\n}\n\n \nstatic void otx2_get_channels(struct net_device *dev,\n\t\t\t      struct ethtool_channels *channel)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(dev);\n\n\tchannel->max_rx = pfvf->hw.max_queues;\n\tchannel->max_tx = pfvf->hw.max_queues;\n\n\tchannel->rx_count = pfvf->hw.rx_queues;\n\tchannel->tx_count = pfvf->hw.tx_queues;\n}\n\n \nstatic int otx2_set_channels(struct net_device *dev,\n\t\t\t     struct ethtool_channels *channel)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(dev);\n\tbool if_up = netif_running(dev);\n\tint err, qos_txqs;\n\n\tif (!channel->rx_count || !channel->tx_count)\n\t\treturn -EINVAL;\n\n\tif (bitmap_weight(&pfvf->rq_bmap, pfvf->hw.rx_queues) > 1) {\n\t\tnetdev_err(dev,\n\t\t\t   \"Receive queues are in use by TC police action\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (if_up)\n\t\tdev->netdev_ops->ndo_stop(dev);\n\n\tqos_txqs = bitmap_weight(pfvf->qos.qos_sq_bmap,\n\t\t\t\t OTX2_QOS_MAX_LEAF_NODES);\n\n\terr = otx2_set_real_num_queues(dev, channel->tx_count + qos_txqs,\n\t\t\t\t       channel->rx_count);\n\tif (err)\n\t\treturn err;\n\n\tpfvf->hw.rx_queues = channel->rx_count;\n\tpfvf->hw.tx_queues = channel->tx_count;\n\tif (pfvf->xdp_prog)\n\t\tpfvf->hw.xdp_queues = channel->rx_count;\n\tpfvf->hw.non_qos_queues =  pfvf->hw.tx_queues + pfvf->hw.xdp_queues;\n\n\tif (if_up)\n\t\terr = dev->netdev_ops->ndo_open(dev);\n\n\tnetdev_info(dev, \"Setting num Tx rings to %d, Rx rings to %d success\\n\",\n\t\t    pfvf->hw.tx_queues, pfvf->hw.rx_queues);\n\n\treturn err;\n}\n\nstatic void otx2_get_pauseparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tstruct cgx_pause_frm_cfg *req, *rsp;\n\n\tif (is_otx2_lbkvf(pfvf->pdev))\n\t\treturn;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_cgx_cfg_pause_frm(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn;\n\t}\n\n\tif (!otx2_sync_mbox_msg(&pfvf->mbox)) {\n\t\trsp = (struct cgx_pause_frm_cfg *)\n\t\t       otx2_mbox_get_rsp(&pfvf->mbox.mbox, 0, &req->hdr);\n\t\tpause->rx_pause = rsp->rx_pause;\n\t\tpause->tx_pause = rsp->tx_pause;\n\t}\n\tmutex_unlock(&pfvf->mbox.lock);\n}\n\nstatic int otx2_set_pauseparam(struct net_device *netdev,\n\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\n\tif (pause->autoneg)\n\t\treturn -EOPNOTSUPP;\n\n\tif (is_otx2_lbkvf(pfvf->pdev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (pause->rx_pause)\n\t\tpfvf->flags |= OTX2_FLAG_RX_PAUSE_ENABLED;\n\telse\n\t\tpfvf->flags &= ~OTX2_FLAG_RX_PAUSE_ENABLED;\n\n\tif (pause->tx_pause)\n\t\tpfvf->flags |= OTX2_FLAG_TX_PAUSE_ENABLED;\n\telse\n\t\tpfvf->flags &= ~OTX2_FLAG_TX_PAUSE_ENABLED;\n\n\treturn otx2_config_pause_frm(pfvf);\n}\n\nstatic void otx2_get_ringparam(struct net_device *netdev,\n\t\t\t       struct ethtool_ringparam *ring,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tstruct otx2_qset *qs = &pfvf->qset;\n\n\tring->rx_max_pending = Q_COUNT(Q_SIZE_MAX);\n\tring->rx_pending = qs->rqe_cnt ? qs->rqe_cnt : Q_COUNT(Q_SIZE_256);\n\tring->tx_max_pending = Q_COUNT(Q_SIZE_MAX);\n\tring->tx_pending = qs->sqe_cnt ? qs->sqe_cnt : Q_COUNT(Q_SIZE_4K);\n\tkernel_ring->rx_buf_len = pfvf->hw.rbuf_len;\n\tkernel_ring->cqe_size = pfvf->hw.xqe_size;\n}\n\nstatic int otx2_set_ringparam(struct net_device *netdev,\n\t\t\t      struct ethtool_ringparam *ring,\n\t\t\t      struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tu32 rx_buf_len = kernel_ring->rx_buf_len;\n\tu32 old_rx_buf_len = pfvf->hw.rbuf_len;\n\tu32 xqe_size = kernel_ring->cqe_size;\n\tbool if_up = netif_running(netdev);\n\tstruct otx2_qset *qs = &pfvf->qset;\n\tu32 rx_count, tx_count;\n\n\tif (ring->rx_mini_pending || ring->rx_jumbo_pending)\n\t\treturn -EINVAL;\n\n\t \n\tif (rx_buf_len && (rx_buf_len < 1536 || rx_buf_len > 32768)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Receive buffer range is 1536 - 32768\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xqe_size != 128 && xqe_size != 512) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Completion event size must be 128 or 512\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trx_count = ring->rx_pending;\n\t \n\tif (rx_count < pfvf->hw.rq_skid)\n\t\trx_count =  pfvf->hw.rq_skid;\n\trx_count = Q_COUNT(Q_SIZE(rx_count, 3));\n\n\t \n\ttx_count = clamp_t(u32, ring->tx_pending,\n\t\t\t   Q_COUNT(Q_SIZE_4K), Q_COUNT(Q_SIZE_MAX));\n\ttx_count = Q_COUNT(Q_SIZE(tx_count, 3));\n\n\tif (tx_count == qs->sqe_cnt && rx_count == qs->rqe_cnt &&\n\t    rx_buf_len == old_rx_buf_len && xqe_size == pfvf->hw.xqe_size)\n\t\treturn 0;\n\n\tif (if_up)\n\t\tnetdev->netdev_ops->ndo_stop(netdev);\n\n\t \n\tqs->sqe_cnt = tx_count;\n\tqs->rqe_cnt = rx_count;\n\n\tpfvf->hw.rbuf_len = rx_buf_len;\n\tpfvf->hw.xqe_size = xqe_size;\n\n\tif (if_up)\n\t\treturn netdev->netdev_ops->ndo_open(netdev);\n\n\treturn 0;\n}\n\nstatic int otx2_get_coalesce(struct net_device *netdev,\n\t\t\t     struct ethtool_coalesce *cmd,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tstruct otx2_hw *hw = &pfvf->hw;\n\n\tcmd->rx_coalesce_usecs = hw->cq_time_wait;\n\tcmd->rx_max_coalesced_frames = hw->cq_ecount_wait;\n\tcmd->tx_coalesce_usecs = hw->cq_time_wait;\n\tcmd->tx_max_coalesced_frames = hw->cq_ecount_wait;\n\tif ((pfvf->flags & OTX2_FLAG_ADPTV_INT_COAL_ENABLED) ==\n\t\t\tOTX2_FLAG_ADPTV_INT_COAL_ENABLED) {\n\t\tcmd->use_adaptive_rx_coalesce = 1;\n\t\tcmd->use_adaptive_tx_coalesce = 1;\n\t} else {\n\t\tcmd->use_adaptive_rx_coalesce = 0;\n\t\tcmd->use_adaptive_tx_coalesce = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int otx2_set_coalesce(struct net_device *netdev,\n\t\t\t     struct ethtool_coalesce *ec,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tstruct otx2_hw *hw = &pfvf->hw;\n\tu8 priv_coalesce_status;\n\tint qidx;\n\n\tif (!ec->rx_max_coalesced_frames || !ec->tx_max_coalesced_frames)\n\t\treturn 0;\n\n\tif (ec->use_adaptive_rx_coalesce != ec->use_adaptive_tx_coalesce) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"adaptive-rx should be same as adaptive-tx\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((pfvf->flags & OTX2_FLAG_ADPTV_INT_COAL_ENABLED) ==\n\t\t\tOTX2_FLAG_ADPTV_INT_COAL_ENABLED) {\n\t\tpriv_coalesce_status = 1;\n\t\tif (!ec->use_adaptive_rx_coalesce)\n\t\t\tpfvf->flags &= ~OTX2_FLAG_ADPTV_INT_COAL_ENABLED;\n\t} else {\n\t\tpriv_coalesce_status = 0;\n\t\tif (ec->use_adaptive_rx_coalesce)\n\t\t\tpfvf->flags |= OTX2_FLAG_ADPTV_INT_COAL_ENABLED;\n\t}\n\n\t \n\tec->rx_coalesce_usecs = clamp_t(u32, ec->rx_coalesce_usecs,\n\t\t\t\t\t1, CQ_TIMER_THRESH_MAX);\n\tec->tx_coalesce_usecs = clamp_t(u32, ec->tx_coalesce_usecs,\n\t\t\t\t\t1, CQ_TIMER_THRESH_MAX);\n\n\t \n\tif (hw->cq_time_wait == ec->rx_coalesce_usecs)\n\t\thw->cq_time_wait = ec->tx_coalesce_usecs;\n\telse if (hw->cq_time_wait == ec->tx_coalesce_usecs)\n\t\thw->cq_time_wait = ec->rx_coalesce_usecs;\n\telse\n\t\thw->cq_time_wait = min_t(u8, ec->rx_coalesce_usecs,\n\t\t\t\t\t ec->tx_coalesce_usecs);\n\n\t \n\tec->rx_max_coalesced_frames = clamp_t(u32, ec->rx_max_coalesced_frames,\n\t\t\t\t\t      1, NAPI_POLL_WEIGHT);\n\tec->tx_max_coalesced_frames = clamp_t(u32, ec->tx_max_coalesced_frames,\n\t\t\t\t\t      1, NAPI_POLL_WEIGHT);\n\n\t \n\tif (hw->cq_ecount_wait == ec->rx_max_coalesced_frames)\n\t\thw->cq_ecount_wait = ec->tx_max_coalesced_frames;\n\telse if (hw->cq_ecount_wait == ec->tx_max_coalesced_frames)\n\t\thw->cq_ecount_wait = ec->rx_max_coalesced_frames;\n\telse\n\t\thw->cq_ecount_wait = min_t(u16, ec->rx_max_coalesced_frames,\n\t\t\t\t\t   ec->tx_max_coalesced_frames);\n\n\t \n\tif (priv_coalesce_status &&\n\t    ((pfvf->flags & OTX2_FLAG_ADPTV_INT_COAL_ENABLED) !=\n\t     OTX2_FLAG_ADPTV_INT_COAL_ENABLED)) {\n\t\thw->cq_time_wait = CQ_TIMER_THRESH_DEFAULT;\n\t\thw->cq_ecount_wait = CQ_CQE_THRESH_DEFAULT;\n\t}\n\n\tif (netif_running(netdev)) {\n\t\tfor (qidx = 0; qidx < pfvf->hw.cint_cnt; qidx++)\n\t\t\totx2_config_irq_coalescing(pfvf, qidx);\n\t}\n\n\treturn 0;\n}\n\nstatic int otx2_get_rss_hash_opts(struct otx2_nic *pfvf,\n\t\t\t\t  struct ethtool_rxnfc *nfc)\n{\n\tstruct otx2_rss_info *rss = &pfvf->hw.rss_info;\n\n\tif (!(rss->flowkey_cfg &\n\t    (NIX_FLOW_KEY_TYPE_IPV4 | NIX_FLOW_KEY_TYPE_IPV6)))\n\t\treturn 0;\n\n\t \n\tnfc->data = RXH_IP_SRC | RXH_IP_DST;\n\tif (rss->flowkey_cfg & NIX_FLOW_KEY_TYPE_VLAN)\n\t\tnfc->data |= RXH_VLAN;\n\n\tswitch (nfc->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\tif (rss->flowkey_cfg & NIX_FLOW_KEY_TYPE_TCP)\n\t\t\tnfc->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\tcase UDP_V6_FLOW:\n\t\tif (rss->flowkey_cfg & NIX_FLOW_KEY_TYPE_UDP)\n\t\t\tnfc->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\tif (rss->flowkey_cfg & NIX_FLOW_KEY_TYPE_SCTP)\n\t\t\tnfc->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\t\tif (rss->flowkey_cfg & NIX_FLOW_KEY_TYPE_ESP)\n\t\t\tnfc->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase IPV4_FLOW:\n\t\tbreak;\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase IPV6_FLOW:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int otx2_set_rss_hash_opts(struct otx2_nic *pfvf,\n\t\t\t\t  struct ethtool_rxnfc *nfc)\n{\n\tstruct otx2_rss_info *rss = &pfvf->hw.rss_info;\n\tu32 rxh_l4 = RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\tu32 rss_cfg = rss->flowkey_cfg;\n\n\tif (!rss->enable) {\n\t\tnetdev_err(pfvf->netdev,\n\t\t\t   \"RSS is disabled, cannot change settings\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (!(nfc->data & RXH_IP_SRC) || !(nfc->data & RXH_IP_DST))\n\t\treturn -EINVAL;\n\n\tif (nfc->data & RXH_VLAN)\n\t\trss_cfg |=  NIX_FLOW_KEY_TYPE_VLAN;\n\telse\n\t\trss_cfg &= ~NIX_FLOW_KEY_TYPE_VLAN;\n\n\tswitch (nfc->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\t \n\t\tswitch (nfc->data & rxh_l4) {\n\t\tcase 0:\n\t\t\trss_cfg &= ~NIX_FLOW_KEY_TYPE_TCP;\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\trss_cfg |= NIX_FLOW_KEY_TYPE_TCP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\tcase UDP_V6_FLOW:\n\t\tswitch (nfc->data & rxh_l4) {\n\t\tcase 0:\n\t\t\trss_cfg &= ~NIX_FLOW_KEY_TYPE_UDP;\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\trss_cfg |= NIX_FLOW_KEY_TYPE_UDP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\tswitch (nfc->data & rxh_l4) {\n\t\tcase 0:\n\t\t\trss_cfg &= ~NIX_FLOW_KEY_TYPE_SCTP;\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\trss_cfg |= NIX_FLOW_KEY_TYPE_SCTP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\t\tswitch (nfc->data & rxh_l4) {\n\t\tcase 0:\n\t\t\trss_cfg &= ~(NIX_FLOW_KEY_TYPE_ESP |\n\t\t\t\t     NIX_FLOW_KEY_TYPE_AH);\n\t\t\trss_cfg |= NIX_FLOW_KEY_TYPE_VLAN |\n\t\t\t\t   NIX_FLOW_KEY_TYPE_IPV4_PROTO;\n\t\t\tbreak;\n\t\tcase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\n\t\t\t \n\t\t\tif (rss_cfg & NIX_FLOW_KEY_TYPE_VLAN) {\n\t\t\t\tnetdev_err(pfvf->netdev,\n\t\t\t\t\t   \"RSS hash of ESP or AH with VLAN is not supported\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\trss_cfg |= NIX_FLOW_KEY_TYPE_ESP | NIX_FLOW_KEY_TYPE_AH;\n\t\t\t \n\t\t\trss_cfg &= ~NIX_FLOW_KEY_TYPE_IPV4_PROTO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IPV4_FLOW:\n\tcase IPV6_FLOW:\n\t\trss_cfg = NIX_FLOW_KEY_TYPE_IPV4 | NIX_FLOW_KEY_TYPE_IPV6;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trss->flowkey_cfg = rss_cfg;\n\totx2_set_flowkey_cfg(pfvf);\n\treturn 0;\n}\n\nstatic int otx2_get_rxnfc(struct net_device *dev,\n\t\t\t  struct ethtool_rxnfc *nfc, u32 *rules)\n{\n\tbool ntuple = !!(dev->features & NETIF_F_NTUPLE);\n\tstruct otx2_nic *pfvf = netdev_priv(dev);\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (nfc->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tnfc->data = pfvf->hw.rx_queues;\n\t\tret = 0;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tif (netif_running(dev) && ntuple) {\n\t\t\tnfc->rule_cnt = pfvf->flow_cfg->nr_flows;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tif (netif_running(dev) && ntuple)\n\t\t\tret = otx2_get_flow(pfvf, nfc,  nfc->fs.location);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tif (netif_running(dev) && ntuple)\n\t\t\tret = otx2_get_all_flows(pfvf, nfc, rules);\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\t\treturn otx2_get_rss_hash_opts(pfvf, nfc);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int otx2_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *nfc)\n{\n\tbool ntuple = !!(dev->features & NETIF_F_NTUPLE);\n\tstruct otx2_nic *pfvf = netdev_priv(dev);\n\tint ret = -EOPNOTSUPP;\n\n\tpfvf->flow_cfg->ntuple = ntuple;\n\tswitch (nfc->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\tret = otx2_set_rss_hash_opts(pfvf, nfc);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tif (netif_running(dev) && ntuple)\n\t\t\tret = otx2_add_flow(pfvf, nfc);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tif (netif_running(dev) && ntuple)\n\t\t\tret = otx2_remove_flow(pfvf, nfc->fs.location);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic u32 otx2_get_rxfh_key_size(struct net_device *netdev)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tstruct otx2_rss_info *rss;\n\n\trss = &pfvf->hw.rss_info;\n\n\treturn sizeof(rss->key);\n}\n\nstatic u32 otx2_get_rxfh_indir_size(struct net_device *dev)\n{\n\treturn  MAX_RSS_INDIR_TBL_SIZE;\n}\n\nstatic int otx2_rss_ctx_delete(struct otx2_nic *pfvf, int ctx_id)\n{\n\tstruct otx2_rss_info *rss = &pfvf->hw.rss_info;\n\n\totx2_rss_ctx_flow_del(pfvf, ctx_id);\n\tkfree(rss->rss_ctx[ctx_id]);\n\trss->rss_ctx[ctx_id] = NULL;\n\n\treturn 0;\n}\n\nstatic int otx2_rss_ctx_create(struct otx2_nic *pfvf,\n\t\t\t       u32 *rss_context)\n{\n\tstruct otx2_rss_info *rss = &pfvf->hw.rss_info;\n\tu8 ctx;\n\n\tfor (ctx = 0; ctx < MAX_RSS_GROUPS; ctx++) {\n\t\tif (!rss->rss_ctx[ctx])\n\t\t\tbreak;\n\t}\n\tif (ctx == MAX_RSS_GROUPS)\n\t\treturn -EINVAL;\n\n\trss->rss_ctx[ctx] = kzalloc(sizeof(*rss->rss_ctx[ctx]), GFP_KERNEL);\n\tif (!rss->rss_ctx[ctx])\n\t\treturn -ENOMEM;\n\t*rss_context = ctx;\n\n\treturn 0;\n}\n\n \nstatic int otx2_set_rxfh_context(struct net_device *dev, const u32 *indir,\n\t\t\t\t const u8 *hkey, const u8 hfunc,\n\t\t\t\t u32 *rss_context, bool delete)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(dev);\n\tstruct otx2_rss_ctx *rss_ctx;\n\tstruct otx2_rss_info *rss;\n\tint ret, idx;\n\n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (*rss_context != ETH_RXFH_CONTEXT_ALLOC &&\n\t    *rss_context >= MAX_RSS_GROUPS)\n\t\treturn -EINVAL;\n\n\trss = &pfvf->hw.rss_info;\n\n\tif (!rss->enable) {\n\t\tnetdev_err(dev, \"RSS is disabled, cannot change settings\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (hkey) {\n\t\tmemcpy(rss->key, hkey, sizeof(rss->key));\n\t\totx2_set_rss_key(pfvf);\n\t}\n\tif (delete)\n\t\treturn otx2_rss_ctx_delete(pfvf, *rss_context);\n\n\tif (*rss_context == ETH_RXFH_CONTEXT_ALLOC) {\n\t\tret = otx2_rss_ctx_create(pfvf, rss_context);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (indir) {\n\t\trss_ctx = rss->rss_ctx[*rss_context];\n\t\tfor (idx = 0; idx < rss->rss_size; idx++)\n\t\t\trss_ctx->ind_tbl[idx] = indir[idx];\n\t}\n\totx2_set_rss_table(pfvf, *rss_context);\n\n\treturn 0;\n}\n\nstatic int otx2_get_rxfh_context(struct net_device *dev, u32 *indir,\n\t\t\t\t u8 *hkey, u8 *hfunc, u32 rss_context)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(dev);\n\tstruct otx2_rss_ctx *rss_ctx;\n\tstruct otx2_rss_info *rss;\n\tint idx, rx_queues;\n\n\trss = &pfvf->hw.rss_info;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\tif (!indir)\n\t\treturn 0;\n\n\tif (!rss->enable && rss_context == DEFAULT_RSS_CONTEXT_GROUP) {\n\t\trx_queues = pfvf->hw.rx_queues;\n\t\tfor (idx = 0; idx < MAX_RSS_INDIR_TBL_SIZE; idx++)\n\t\t\tindir[idx] = ethtool_rxfh_indir_default(idx, rx_queues);\n\t\treturn 0;\n\t}\n\tif (rss_context >= MAX_RSS_GROUPS)\n\t\treturn -ENOENT;\n\n\trss_ctx = rss->rss_ctx[rss_context];\n\tif (!rss_ctx)\n\t\treturn -ENOENT;\n\n\tif (indir) {\n\t\tfor (idx = 0; idx < rss->rss_size; idx++)\n\t\t\tindir[idx] = rss_ctx->ind_tbl[idx];\n\t}\n\tif (hkey)\n\t\tmemcpy(hkey, rss->key, sizeof(rss->key));\n\n\treturn 0;\n}\n\n \nstatic int otx2_get_rxfh(struct net_device *dev, u32 *indir,\n\t\t\t u8 *hkey, u8 *hfunc)\n{\n\treturn otx2_get_rxfh_context(dev, indir, hkey, hfunc,\n\t\t\t\t     DEFAULT_RSS_CONTEXT_GROUP);\n}\n\n \nstatic int otx2_set_rxfh(struct net_device *dev, const u32 *indir,\n\t\t\t const u8 *hkey, const u8 hfunc)\n{\n\n\tu32 rss_context = DEFAULT_RSS_CONTEXT_GROUP;\n\n\treturn otx2_set_rxfh_context(dev, indir, hkey, hfunc, &rss_context, 0);\n}\n\nstatic u32 otx2_get_msglevel(struct net_device *netdev)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\n\treturn pfvf->msg_enable;\n}\n\nstatic void otx2_set_msglevel(struct net_device *netdev, u32 val)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\n\tpfvf->msg_enable = val;\n}\n\nstatic u32 otx2_get_link(struct net_device *netdev)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\n\t \n\tif (is_otx2_lbkvf(pfvf->pdev))\n\t\treturn 1;\n\treturn pfvf->linfo.link_up;\n}\n\nstatic int otx2_get_ts_info(struct net_device *netdev,\n\t\t\t    struct ethtool_ts_info *info)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\n\tif (!pfvf->ptp)\n\t\treturn ethtool_op_get_ts_info(netdev, info);\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tinfo->phc_index = otx2_ptp_clock_index(pfvf);\n\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF) | BIT(HWTSTAMP_TX_ON);\n\tif (test_bit(CN10K_PTP_ONESTEP, &pfvf->hw.cap_flag))\n\t\tinfo->tx_types |= BIT(HWTSTAMP_TX_ONESTEP_SYNC);\n\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |\n\t\t\t   BIT(HWTSTAMP_FILTER_ALL);\n\n\treturn 0;\n}\n\nstatic struct cgx_fw_data *otx2_get_fwdata(struct otx2_nic *pfvf)\n{\n\tstruct cgx_fw_data *rsp = NULL;\n\tstruct msg_req *req;\n\tint err = 0;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_cgx_get_aux_link_info(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (!err) {\n\t\trsp = (struct cgx_fw_data *)\n\t\t\totx2_mbox_get_rsp(&pfvf->mbox.mbox, 0, &req->hdr);\n\t} else {\n\t\trsp = ERR_PTR(err);\n\t}\n\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn rsp;\n}\n\nstatic int otx2_get_fecparam(struct net_device *netdev,\n\t\t\t     struct ethtool_fecparam *fecparam)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tstruct cgx_fw_data *rsp;\n\tconst int fec[] = {\n\t\tETHTOOL_FEC_OFF,\n\t\tETHTOOL_FEC_BASER,\n\t\tETHTOOL_FEC_RS,\n\t\tETHTOOL_FEC_BASER | ETHTOOL_FEC_RS};\n#define FEC_MAX_INDEX 4\n\tif (pfvf->linfo.fec < FEC_MAX_INDEX)\n\t\tfecparam->active_fec = fec[pfvf->linfo.fec];\n\n\trsp = otx2_get_fwdata(pfvf);\n\tif (IS_ERR(rsp))\n\t\treturn PTR_ERR(rsp);\n\n\tif (rsp->fwdata.supported_fec < FEC_MAX_INDEX) {\n\t\tif (!rsp->fwdata.supported_fec)\n\t\t\tfecparam->fec = ETHTOOL_FEC_NONE;\n\t\telse\n\t\t\tfecparam->fec = fec[rsp->fwdata.supported_fec];\n\t}\n\treturn 0;\n}\n\nstatic int otx2_set_fecparam(struct net_device *netdev,\n\t\t\t     struct ethtool_fecparam *fecparam)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tstruct mbox *mbox = &pfvf->mbox;\n\tstruct fec_mode *req, *rsp;\n\tint err = 0, fec = 0;\n\n\tswitch (fecparam->fec) {\n\t \n\tcase ETHTOOL_FEC_OFF:\n\tcase ETHTOOL_FEC_AUTO:\n\t\tfec = OTX2_FEC_OFF;\n\t\tbreak;\n\tcase ETHTOOL_FEC_RS:\n\t\tfec = OTX2_FEC_RS;\n\t\tbreak;\n\tcase ETHTOOL_FEC_BASER:\n\t\tfec = OTX2_FEC_BASER;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(pfvf->netdev, \"Unsupported FEC mode: %d\",\n\t\t\t    fecparam->fec);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fec == pfvf->linfo.fec)\n\t\treturn 0;\n\n\tmutex_lock(&mbox->lock);\n\treq = otx2_mbox_alloc_msg_cgx_set_fec_param(&pfvf->mbox);\n\tif (!req) {\n\t\terr = -ENOMEM;\n\t\tgoto end;\n\t}\n\treq->fec = fec;\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (err)\n\t\tgoto end;\n\n\trsp = (struct fec_mode *)otx2_mbox_get_rsp(&pfvf->mbox.mbox,\n\t\t\t\t\t\t   0, &req->hdr);\n\tif (rsp->fec >= 0)\n\t\tpfvf->linfo.fec = rsp->fec;\n\telse\n\t\terr = rsp->fec;\nend:\n\tmutex_unlock(&mbox->lock);\n\treturn err;\n}\n\nstatic void otx2_get_fec_info(u64 index, int req_mode,\n\t\t\t      struct ethtool_link_ksettings *link_ksettings)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(otx2_fec_modes) = { 0, };\n\n\tswitch (index) {\n\tcase OTX2_FEC_NONE:\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_NONE_BIT,\n\t\t\t\t otx2_fec_modes);\n\t\tbreak;\n\tcase OTX2_FEC_BASER:\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_BASER_BIT,\n\t\t\t\t otx2_fec_modes);\n\t\tbreak;\n\tcase OTX2_FEC_RS:\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_RS_BIT,\n\t\t\t\t otx2_fec_modes);\n\t\tbreak;\n\tcase OTX2_FEC_BASER | OTX2_FEC_RS:\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_BASER_BIT,\n\t\t\t\t otx2_fec_modes);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FEC_RS_BIT,\n\t\t\t\t otx2_fec_modes);\n\t\tbreak;\n\t}\n\n\t \n\tif (req_mode == OTX2_MODE_ADVERTISED)\n\t\tlinkmode_or(link_ksettings->link_modes.advertising,\n\t\t\t    link_ksettings->link_modes.advertising,\n\t\t\t    otx2_fec_modes);\n\telse\n\t\tlinkmode_or(link_ksettings->link_modes.supported,\n\t\t\t    link_ksettings->link_modes.supported,\n\t\t\t    otx2_fec_modes);\n}\n\nstatic void otx2_get_link_mode_info(u64 link_mode_bmap,\n\t\t\t\t    bool req_mode,\n\t\t\t\t    struct ethtool_link_ksettings\n\t\t\t\t    *link_ksettings)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(otx2_link_modes) = { 0, };\n\tconst int otx2_sgmii_features[6] = {\n\t\tETHTOOL_LINK_MODE_10baseT_Half_BIT,\n\t\tETHTOOL_LINK_MODE_10baseT_Full_BIT,\n\t\tETHTOOL_LINK_MODE_100baseT_Half_BIT,\n\t\tETHTOOL_LINK_MODE_100baseT_Full_BIT,\n\t\tETHTOOL_LINK_MODE_1000baseT_Half_BIT,\n\t\tETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t};\n\t \n\tconst int cgx_link_mode[27] = {\n\t\t0,  \n\t\tETHTOOL_LINK_MODE_1000baseX_Full_BIT,\n\t\tETHTOOL_LINK_MODE_10000baseT_Full_BIT,\n\t\tETHTOOL_LINK_MODE_10000baseSR_Full_BIT,\n\t\tETHTOOL_LINK_MODE_10000baseLR_Full_BIT,\n\t\tETHTOOL_LINK_MODE_10000baseKR_Full_BIT,\n\t\t0,\n\t\tETHTOOL_LINK_MODE_25000baseSR_Full_BIT,\n\t\t0,\n\t\t0,\n\t\tETHTOOL_LINK_MODE_25000baseCR_Full_BIT,\n\t\tETHTOOL_LINK_MODE_25000baseKR_Full_BIT,\n\t\tETHTOOL_LINK_MODE_40000baseSR4_Full_BIT,\n\t\tETHTOOL_LINK_MODE_40000baseLR4_Full_BIT,\n\t\tETHTOOL_LINK_MODE_40000baseCR4_Full_BIT,\n\t\tETHTOOL_LINK_MODE_40000baseKR4_Full_BIT,\n\t\t0,\n\t\tETHTOOL_LINK_MODE_50000baseSR_Full_BIT,\n\t\t0,\n\t\tETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT,\n\t\tETHTOOL_LINK_MODE_50000baseCR_Full_BIT,\n\t\tETHTOOL_LINK_MODE_50000baseKR_Full_BIT,\n\t\t0,\n\t\tETHTOOL_LINK_MODE_100000baseSR4_Full_BIT,\n\t\tETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT,\n\t\tETHTOOL_LINK_MODE_100000baseCR4_Full_BIT,\n\t\tETHTOOL_LINK_MODE_100000baseKR4_Full_BIT\n\t};\n\tu8 bit;\n\n\tfor_each_set_bit(bit, (unsigned long *)&link_mode_bmap, 27) {\n\t\t \n\t\tif (bit == 0)\n\t\t\tlinkmode_set_bit_array(otx2_sgmii_features,\n\t\t\t\t\t       ARRAY_SIZE(otx2_sgmii_features),\n\t\t\t\t\t       otx2_link_modes);\n\t\telse\n\t\t\tlinkmode_set_bit(cgx_link_mode[bit], otx2_link_modes);\n\t}\n\n\tif (req_mode == OTX2_MODE_ADVERTISED)\n\t\tlinkmode_copy(link_ksettings->link_modes.advertising,\n\t\t\t      otx2_link_modes);\n\telse\n\t\tlinkmode_copy(link_ksettings->link_modes.supported,\n\t\t\t      otx2_link_modes);\n}\n\nstatic int otx2_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tstruct cgx_fw_data *rsp = NULL;\n\n\tcmd->base.duplex  = pfvf->linfo.full_duplex;\n\tcmd->base.speed   = pfvf->linfo.speed;\n\tcmd->base.autoneg = pfvf->linfo.an;\n\n\trsp = otx2_get_fwdata(pfvf);\n\tif (IS_ERR(rsp))\n\t\treturn PTR_ERR(rsp);\n\n\tif (rsp->fwdata.supported_an)\n\t\tethtool_link_ksettings_add_link_mode(cmd,\n\t\t\t\t\t\t     supported,\n\t\t\t\t\t\t     Autoneg);\n\n\totx2_get_link_mode_info(rsp->fwdata.advertised_link_modes,\n\t\t\t\tOTX2_MODE_ADVERTISED, cmd);\n\totx2_get_fec_info(rsp->fwdata.advertised_fec,\n\t\t\t  OTX2_MODE_ADVERTISED, cmd);\n\totx2_get_link_mode_info(rsp->fwdata.supported_link_modes,\n\t\t\t\tOTX2_MODE_SUPPORTED, cmd);\n\totx2_get_fec_info(rsp->fwdata.supported_fec,\n\t\t\t  OTX2_MODE_SUPPORTED, cmd);\n\treturn 0;\n}\n\nstatic void otx2_get_advertised_mode(const struct ethtool_link_ksettings *cmd,\n\t\t\t\t     u64 *mode)\n{\n\tu32 bit_pos;\n\n\t \n\tbit_pos = find_first_bit(cmd->link_modes.advertising,\n\t\t\t\t __ETHTOOL_LINK_MODE_MASK_NBITS);\n\tif (bit_pos != __ETHTOOL_LINK_MODE_MASK_NBITS)\n\t\t*mode = bit_pos;\n}\n\nstatic int otx2_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tstruct otx2_nic *pf = netdev_priv(netdev);\n\tstruct ethtool_link_ksettings cur_ks;\n\tstruct cgx_set_link_mode_req *req;\n\tstruct mbox *mbox = &pf->mbox;\n\tint err = 0;\n\n\tmemset(&cur_ks, 0, sizeof(struct ethtool_link_ksettings));\n\n\tif (!ethtool_validate_speed(cmd->base.speed) ||\n\t    !ethtool_validate_duplex(cmd->base.duplex))\n\t\treturn -EINVAL;\n\n\tif (cmd->base.autoneg != AUTONEG_ENABLE &&\n\t    cmd->base.autoneg != AUTONEG_DISABLE)\n\t\treturn -EINVAL;\n\n\totx2_get_link_ksettings(netdev, &cur_ks);\n\n\t \n\tif (!linkmode_subset(cmd->link_modes.advertising,\n\t\t\t     cur_ks.link_modes.supported))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mbox->lock);\n\treq = otx2_mbox_alloc_msg_cgx_set_link_mode(&pf->mbox);\n\tif (!req) {\n\t\terr = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\treq->args.speed = cmd->base.speed;\n\t \n\treq->args.duplex = cmd->base.duplex ^ 0x1;\n\treq->args.an = cmd->base.autoneg;\n\totx2_get_advertised_mode(cmd, &req->args.mode);\n\n\terr = otx2_sync_mbox_msg(&pf->mbox);\nend:\n\tmutex_unlock(&mbox->lock);\n\treturn err;\n}\n\nstatic void otx2_get_fec_stats(struct net_device *netdev,\n\t\t\t       struct ethtool_fec_stats *fec_stats)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tstruct cgx_fw_data *rsp;\n\n\totx2_update_lmac_fec_stats(pfvf);\n\n\t \n\tfec_stats->corrected_blocks.total     = pfvf->hw.cgx_fec_corr_blks;\n\tfec_stats->uncorrectable_blocks.total = pfvf->hw.cgx_fec_uncorr_blks;\n\n\trsp = otx2_get_fwdata(pfvf);\n\tif (!IS_ERR(rsp) && rsp->fwdata.phy.misc.has_fec_stats &&\n\t    !otx2_get_phy_fec_stats(pfvf)) {\n\t\t \n\t\trsp = otx2_get_fwdata(pfvf);\n\t\tif (!IS_ERR(rsp)) {\n\t\t\tstruct fec_stats_s *p = &rsp->fwdata.phy.fec_stats;\n\n\t\t\tif (pfvf->linfo.fec == OTX2_FEC_BASER) {\n\t\t\t\tfec_stats->corrected_blocks.total = p->brfec_corr_blks;\n\t\t\t\tfec_stats->uncorrectable_blocks.total = p->brfec_uncorr_blks;\n\t\t\t} else {\n\t\t\t\tfec_stats->corrected_blocks.total = p->rsfec_corr_cws;\n\t\t\t\tfec_stats->uncorrectable_blocks.total = p->rsfec_uncorr_cws;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const struct ethtool_ops otx2_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE,\n\t.supported_ring_params  = ETHTOOL_RING_USE_RX_BUF_LEN |\n\t\t\t\t  ETHTOOL_RING_USE_CQE_SIZE,\n\t.get_link\t\t= otx2_get_link,\n\t.get_drvinfo\t\t= otx2_get_drvinfo,\n\t.get_strings\t\t= otx2_get_strings,\n\t.get_ethtool_stats\t= otx2_get_ethtool_stats,\n\t.get_sset_count\t\t= otx2_get_sset_count,\n\t.set_channels\t\t= otx2_set_channels,\n\t.get_channels\t\t= otx2_get_channels,\n\t.get_ringparam\t\t= otx2_get_ringparam,\n\t.set_ringparam\t\t= otx2_set_ringparam,\n\t.get_coalesce\t\t= otx2_get_coalesce,\n\t.set_coalesce\t\t= otx2_set_coalesce,\n\t.get_rxnfc\t\t= otx2_get_rxnfc,\n\t.set_rxnfc              = otx2_set_rxnfc,\n\t.get_rxfh_key_size\t= otx2_get_rxfh_key_size,\n\t.get_rxfh_indir_size\t= otx2_get_rxfh_indir_size,\n\t.get_rxfh\t\t= otx2_get_rxfh,\n\t.set_rxfh\t\t= otx2_set_rxfh,\n\t.get_rxfh_context\t= otx2_get_rxfh_context,\n\t.set_rxfh_context\t= otx2_set_rxfh_context,\n\t.get_msglevel\t\t= otx2_get_msglevel,\n\t.set_msglevel\t\t= otx2_set_msglevel,\n\t.get_pauseparam\t\t= otx2_get_pauseparam,\n\t.set_pauseparam\t\t= otx2_set_pauseparam,\n\t.get_ts_info\t\t= otx2_get_ts_info,\n\t.get_fec_stats\t\t= otx2_get_fec_stats,\n\t.get_fecparam\t\t= otx2_get_fecparam,\n\t.set_fecparam\t\t= otx2_set_fecparam,\n\t.get_link_ksettings     = otx2_get_link_ksettings,\n\t.set_link_ksettings     = otx2_set_link_ksettings,\n};\n\nvoid otx2_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &otx2_ethtool_ops;\n}\n\n \nstatic void otx2vf_get_drvinfo(struct net_device *netdev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstruct otx2_nic *vf = netdev_priv(netdev);\n\n\tstrscpy(info->driver, DRV_VF_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(vf->pdev), sizeof(info->bus_info));\n}\n\nstatic void otx2vf_get_strings(struct net_device *netdev, u32 sset, u8 *data)\n{\n\tstruct otx2_nic *vf = netdev_priv(netdev);\n\tint stats;\n\n\tif (sset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (stats = 0; stats < otx2_n_dev_stats; stats++) {\n\t\tmemcpy(data, otx2_dev_stats[stats].name, ETH_GSTRING_LEN);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n\n\tfor (stats = 0; stats < otx2_n_drv_stats; stats++) {\n\t\tmemcpy(data, otx2_drv_stats[stats].name, ETH_GSTRING_LEN);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n\n\totx2_get_qset_strings(vf, &data, 0);\n\n\tstrcpy(data, \"reset_count\");\n\tdata += ETH_GSTRING_LEN;\n}\n\nstatic void otx2vf_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t     struct ethtool_stats *stats, u64 *data)\n{\n\tstruct otx2_nic *vf = netdev_priv(netdev);\n\tint stat;\n\n\totx2_get_dev_stats(vf);\n\tfor (stat = 0; stat < otx2_n_dev_stats; stat++)\n\t\t*(data++) = ((u64 *)&vf->hw.dev_stats)\n\t\t\t\t[otx2_dev_stats[stat].index];\n\n\tfor (stat = 0; stat < otx2_n_drv_stats; stat++)\n\t\t*(data++) = atomic_read(&((atomic_t *)&vf->hw.drv_stats)\n\t\t\t\t\t\t[otx2_drv_stats[stat].index]);\n\n\totx2_get_qset_stats(vf, stats, &data);\n\t*(data++) = vf->reset_count;\n}\n\nstatic int otx2vf_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct otx2_nic *vf = netdev_priv(netdev);\n\tint qstats_count;\n\n\tif (sset != ETH_SS_STATS)\n\t\treturn -EINVAL;\n\n\tqstats_count = otx2_n_queue_stats *\n\t\t       (vf->hw.rx_queues + otx2_get_total_tx_queues(vf));\n\n\treturn otx2_n_dev_stats + otx2_n_drv_stats + qstats_count + 1;\n}\n\nstatic int otx2vf_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\n\tif (is_otx2_lbkvf(pfvf->pdev)) {\n\t\tcmd->base.duplex = DUPLEX_FULL;\n\t\tcmd->base.speed = SPEED_100000;\n\t} else {\n\t\treturn otx2_get_link_ksettings(netdev, cmd);\n\t}\n\treturn 0;\n}\n\nstatic const struct ethtool_ops otx2vf_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE,\n\t.supported_ring_params  = ETHTOOL_RING_USE_RX_BUF_LEN |\n\t\t\t\t  ETHTOOL_RING_USE_CQE_SIZE,\n\t.get_link\t\t= otx2_get_link,\n\t.get_drvinfo\t\t= otx2vf_get_drvinfo,\n\t.get_strings\t\t= otx2vf_get_strings,\n\t.get_ethtool_stats\t= otx2vf_get_ethtool_stats,\n\t.get_sset_count\t\t= otx2vf_get_sset_count,\n\t.set_channels\t\t= otx2_set_channels,\n\t.get_channels\t\t= otx2_get_channels,\n\t.get_rxnfc\t\t= otx2_get_rxnfc,\n\t.set_rxnfc              = otx2_set_rxnfc,\n\t.get_rxfh_key_size\t= otx2_get_rxfh_key_size,\n\t.get_rxfh_indir_size\t= otx2_get_rxfh_indir_size,\n\t.get_rxfh\t\t= otx2_get_rxfh,\n\t.set_rxfh\t\t= otx2_set_rxfh,\n\t.get_rxfh_context\t= otx2_get_rxfh_context,\n\t.set_rxfh_context\t= otx2_set_rxfh_context,\n\t.get_ringparam\t\t= otx2_get_ringparam,\n\t.set_ringparam\t\t= otx2_set_ringparam,\n\t.get_coalesce\t\t= otx2_get_coalesce,\n\t.set_coalesce\t\t= otx2_set_coalesce,\n\t.get_msglevel\t\t= otx2_get_msglevel,\n\t.set_msglevel\t\t= otx2_set_msglevel,\n\t.get_pauseparam\t\t= otx2_get_pauseparam,\n\t.set_pauseparam\t\t= otx2_set_pauseparam,\n\t.get_link_ksettings     = otx2vf_get_link_ksettings,\n\t.get_ts_info\t\t= otx2_get_ts_info,\n};\n\nvoid otx2vf_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &otx2vf_ethtool_ops;\n}\nEXPORT_SYMBOL(otx2vf_set_ethtool_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}