{
  "module_name": "qos.c",
  "hash_id": "3064c6ff992443b07278e37df2451e25705c12132e3d8e2ba47a41cf193925c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/nic/qos.c",
  "human_readable_source": "\n \n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/bitfield.h>\n\n#include \"otx2_common.h\"\n#include \"cn10k.h\"\n#include \"qos.h\"\n\n#define OTX2_QOS_QID_INNER\t\t0xFFFFU\n#define OTX2_QOS_QID_NONE\t\t0xFFFEU\n#define OTX2_QOS_ROOT_CLASSID\t\t0xFFFFFFFF\n#define OTX2_QOS_CLASS_NONE\t\t0\n#define OTX2_QOS_DEFAULT_PRIO\t\t0xF\n#define OTX2_QOS_INVALID_SQ\t\t0xFFFF\n#define OTX2_QOS_INVALID_TXSCHQ_IDX\t0xFFFF\n#define CN10K_MAX_RR_WEIGHT\t\tGENMASK_ULL(13, 0)\n#define OTX2_MAX_RR_QUANTUM\t\tGENMASK_ULL(23, 0)\n\nstatic void otx2_qos_update_tx_netdev_queues(struct otx2_nic *pfvf)\n{\n\tstruct otx2_hw *hw = &pfvf->hw;\n\tint tx_queues, qos_txqs, err;\n\n\tqos_txqs = bitmap_weight(pfvf->qos.qos_sq_bmap,\n\t\t\t\t OTX2_QOS_MAX_LEAF_NODES);\n\n\ttx_queues = hw->tx_queues + qos_txqs;\n\n\terr = netif_set_real_num_tx_queues(pfvf->netdev, tx_queues);\n\tif (err) {\n\t\tnetdev_err(pfvf->netdev,\n\t\t\t   \"Failed to set no of Tx queues: %d\\n\", tx_queues);\n\t\treturn;\n\t}\n}\n\nstatic void otx2_qos_get_regaddr(struct otx2_qos_node *node,\n\t\t\t\t struct nix_txschq_config *cfg,\n\t\t\t\t int index)\n{\n\tif (node->level == NIX_TXSCH_LVL_SMQ) {\n\t\tcfg->reg[index++] = NIX_AF_MDQX_PARENT(node->schq);\n\t\tcfg->reg[index++] = NIX_AF_MDQX_SCHEDULE(node->schq);\n\t\tcfg->reg[index++] = NIX_AF_MDQX_PIR(node->schq);\n\t\tcfg->reg[index]   = NIX_AF_MDQX_CIR(node->schq);\n\t} else if (node->level == NIX_TXSCH_LVL_TL4) {\n\t\tcfg->reg[index++] = NIX_AF_TL4X_PARENT(node->schq);\n\t\tcfg->reg[index++] = NIX_AF_TL4X_SCHEDULE(node->schq);\n\t\tcfg->reg[index++] = NIX_AF_TL4X_PIR(node->schq);\n\t\tcfg->reg[index]   = NIX_AF_TL4X_CIR(node->schq);\n\t} else if (node->level == NIX_TXSCH_LVL_TL3) {\n\t\tcfg->reg[index++] = NIX_AF_TL3X_PARENT(node->schq);\n\t\tcfg->reg[index++] = NIX_AF_TL3X_SCHEDULE(node->schq);\n\t\tcfg->reg[index++] = NIX_AF_TL3X_PIR(node->schq);\n\t\tcfg->reg[index]   = NIX_AF_TL3X_CIR(node->schq);\n\t} else if (node->level == NIX_TXSCH_LVL_TL2) {\n\t\tcfg->reg[index++] = NIX_AF_TL2X_PARENT(node->schq);\n\t\tcfg->reg[index++] = NIX_AF_TL2X_SCHEDULE(node->schq);\n\t\tcfg->reg[index++] = NIX_AF_TL2X_PIR(node->schq);\n\t\tcfg->reg[index]   = NIX_AF_TL2X_CIR(node->schq);\n\t}\n}\n\nstatic int otx2_qos_quantum_to_dwrr_weight(struct otx2_nic *pfvf, u32 quantum)\n{\n\tu32 weight;\n\n\tweight = quantum / pfvf->hw.dwrr_mtu;\n\tif (quantum % pfvf->hw.dwrr_mtu)\n\t\tweight += 1;\n\n\treturn weight;\n}\n\nstatic void otx2_config_sched_shaping(struct otx2_nic *pfvf,\n\t\t\t\t      struct otx2_qos_node *node,\n\t\t\t\t      struct nix_txschq_config *cfg,\n\t\t\t\t      int *num_regs)\n{\n\tu32 rr_weight;\n\tu32 quantum;\n\tu64 maxrate;\n\n\totx2_qos_get_regaddr(node, cfg, *num_regs);\n\n\t \n\tcfg->regval[*num_regs] = node->parent->schq << 16;\n\t(*num_regs)++;\n\n\t \n\tif (node->qid == OTX2_QOS_QID_NONE) {\n\t\tcfg->regval[*num_regs] =  node->prio << 24 |\n\t\t\t\t\t  mtu_to_dwrr_weight(pfvf, pfvf->tx_max_pktlen);\n\t\t(*num_regs)++;\n\t\treturn;\n\t}\n\n\t \n\tif (node->is_static) {\n\t\tcfg->regval[*num_regs] =\n\t\t\t(node->schq - node->parent->prio_anchor) << 24;\n\t} else {\n\t\tquantum = node->quantum ?\n\t\t\t  node->quantum : pfvf->tx_max_pktlen;\n\t\trr_weight = otx2_qos_quantum_to_dwrr_weight(pfvf, quantum);\n\t\tcfg->regval[*num_regs] = node->parent->child_dwrr_prio << 24 |\n\t\t\t\t\t rr_weight;\n\t}\n\t(*num_regs)++;\n\n\t \n\tmaxrate = (node->rate > node->ceil) ? node->rate : node->ceil;\n\n\tcfg->regval[*num_regs] =\n\t\totx2_get_txschq_rate_regval(pfvf, maxrate, 65536);\n\t(*num_regs)++;\n\n\t \n\tif (!test_bit(QOS_CIR_PIR_SUPPORT, &pfvf->hw.cap_flag))\n\t\treturn;\n\n\tcfg->regval[*num_regs] =\n\t\totx2_get_txschq_rate_regval(pfvf, node->rate, 65536);\n\t(*num_regs)++;\n}\n\nstatic void __otx2_qos_txschq_cfg(struct otx2_nic *pfvf,\n\t\t\t\t  struct otx2_qos_node *node,\n\t\t\t\t  struct nix_txschq_config *cfg)\n{\n\tstruct otx2_hw *hw = &pfvf->hw;\n\tint num_regs = 0;\n\tu8 level;\n\n\tlevel = node->level;\n\n\t \n\tif (level == NIX_TXSCH_LVL_SMQ) {\n\t\tcfg->reg[num_regs] = NIX_AF_SMQX_CFG(node->schq);\n\t\tcfg->regval[num_regs] = ((u64)pfvf->tx_max_pktlen << 8) |\n\t\t\t\t\tOTX2_MIN_MTU;\n\t\tcfg->regval[num_regs] |= (0x20ULL << 51) | (0x80ULL << 39) |\n\t\t\t\t\t (0x2ULL << 36);\n\t\tnum_regs++;\n\n\t\totx2_config_sched_shaping(pfvf, node, cfg, &num_regs);\n\n\t} else if (level == NIX_TXSCH_LVL_TL4) {\n\t\totx2_config_sched_shaping(pfvf, node, cfg, &num_regs);\n\t} else if (level == NIX_TXSCH_LVL_TL3) {\n\t\t \n\t\tif (level == pfvf->qos.link_cfg_lvl) {\n\t\t\tcfg->reg[num_regs] = NIX_AF_TL3_TL2X_LINKX_CFG(node->schq, hw->tx_link);\n\t\t\tcfg->regval[num_regs] = BIT_ULL(13) | BIT_ULL(12);\n\t\t\tnum_regs++;\n\t\t}\n\n\t\totx2_config_sched_shaping(pfvf, node, cfg, &num_regs);\n\t} else if (level == NIX_TXSCH_LVL_TL2) {\n\t\t \n\t\tif (level == pfvf->qos.link_cfg_lvl) {\n\t\t\tcfg->reg[num_regs] = NIX_AF_TL3_TL2X_LINKX_CFG(node->schq, hw->tx_link);\n\t\t\tcfg->regval[num_regs] = BIT_ULL(13) | BIT_ULL(12);\n\t\t\tnum_regs++;\n\t\t}\n\n\t\t \n\t\tif (node->qid == OTX2_QOS_QID_INNER && !node->parent) {\n\t\t\tcfg->reg[num_regs] = NIX_AF_TL2X_SCHEDULE(node->schq);\n\t\t\tcfg->regval[num_regs] =  TXSCH_TL1_DFLT_RR_PRIO << 24 |\n\t\t\t\t\t\t mtu_to_dwrr_weight(pfvf,\n\t\t\t\t\t\t\t\t    pfvf->tx_max_pktlen);\n\t\t\tnum_regs++;\n\t\t\tgoto txschq_cfg_out;\n\t\t}\n\n\t\totx2_config_sched_shaping(pfvf, node, cfg, &num_regs);\n\t}\n\ntxschq_cfg_out:\n\tcfg->num_regs = num_regs;\n}\n\nstatic int otx2_qos_txschq_set_parent_topology(struct otx2_nic *pfvf,\n\t\t\t\t\t       struct otx2_qos_node *parent)\n{\n\tstruct mbox *mbox = &pfvf->mbox;\n\tstruct nix_txschq_config *cfg;\n\tint rc;\n\n\tif (parent->level == NIX_TXSCH_LVL_MDQ)\n\t\treturn 0;\n\n\tmutex_lock(&mbox->lock);\n\n\tcfg = otx2_mbox_alloc_msg_nix_txschq_cfg(&pfvf->mbox);\n\tif (!cfg) {\n\t\tmutex_unlock(&mbox->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tcfg->lvl = parent->level;\n\n\tif (parent->level == NIX_TXSCH_LVL_TL4)\n\t\tcfg->reg[0] = NIX_AF_TL4X_TOPOLOGY(parent->schq);\n\telse if (parent->level == NIX_TXSCH_LVL_TL3)\n\t\tcfg->reg[0] = NIX_AF_TL3X_TOPOLOGY(parent->schq);\n\telse if (parent->level == NIX_TXSCH_LVL_TL2)\n\t\tcfg->reg[0] = NIX_AF_TL2X_TOPOLOGY(parent->schq);\n\telse if (parent->level == NIX_TXSCH_LVL_TL1)\n\t\tcfg->reg[0] = NIX_AF_TL1X_TOPOLOGY(parent->schq);\n\n\tcfg->regval[0] = (u64)parent->prio_anchor << 32;\n\tcfg->regval[0] |= ((parent->child_dwrr_prio != OTX2_QOS_DEFAULT_PRIO) ?\n\t\t\t    parent->child_dwrr_prio : 0)  << 1;\n\tcfg->num_regs++;\n\n\trc = otx2_sync_mbox_msg(&pfvf->mbox);\n\n\tmutex_unlock(&mbox->lock);\n\n\treturn rc;\n}\n\nstatic void otx2_qos_free_hw_node_schq(struct otx2_nic *pfvf,\n\t\t\t\t       struct otx2_qos_node *parent)\n{\n\tstruct otx2_qos_node *node;\n\n\tlist_for_each_entry_reverse(node, &parent->child_schq_list, list)\n\t\totx2_txschq_free_one(pfvf, node->level, node->schq);\n}\n\nstatic void otx2_qos_free_hw_node(struct otx2_nic *pfvf,\n\t\t\t\t  struct otx2_qos_node *parent)\n{\n\tstruct otx2_qos_node *node, *tmp;\n\n\tlist_for_each_entry_safe(node, tmp, &parent->child_list, list) {\n\t\totx2_qos_free_hw_node(pfvf, node);\n\t\totx2_qos_free_hw_node_schq(pfvf, node);\n\t\totx2_txschq_free_one(pfvf, node->level, node->schq);\n\t}\n}\n\nstatic void otx2_qos_free_hw_cfg(struct otx2_nic *pfvf,\n\t\t\t\t struct otx2_qos_node *node)\n{\n\tmutex_lock(&pfvf->qos.qos_lock);\n\n\t \n\totx2_qos_free_hw_node(pfvf, node);\n\totx2_qos_free_hw_node_schq(pfvf, node);\n\n\t \n\totx2_txschq_free_one(pfvf, node->level, node->schq);\n\n\tmutex_unlock(&pfvf->qos.qos_lock);\n}\n\nstatic void otx2_qos_sw_node_delete(struct otx2_nic *pfvf,\n\t\t\t\t    struct otx2_qos_node *node)\n{\n\thash_del_rcu(&node->hlist);\n\n\tif (node->qid != OTX2_QOS_QID_INNER && node->qid != OTX2_QOS_QID_NONE) {\n\t\t__clear_bit(node->qid, pfvf->qos.qos_sq_bmap);\n\t\totx2_qos_update_tx_netdev_queues(pfvf);\n\t}\n\n\tlist_del(&node->list);\n\tkfree(node);\n}\n\nstatic void otx2_qos_free_sw_node_schq(struct otx2_nic *pfvf,\n\t\t\t\t       struct otx2_qos_node *parent)\n{\n\tstruct otx2_qos_node *node, *tmp;\n\n\tlist_for_each_entry_safe(node, tmp, &parent->child_schq_list, list) {\n\t\tlist_del(&node->list);\n\t\tkfree(node);\n\t}\n}\n\nstatic void __otx2_qos_free_sw_node(struct otx2_nic *pfvf,\n\t\t\t\t    struct otx2_qos_node *parent)\n{\n\tstruct otx2_qos_node *node, *tmp;\n\n\tlist_for_each_entry_safe(node, tmp, &parent->child_list, list) {\n\t\t__otx2_qos_free_sw_node(pfvf, node);\n\t\totx2_qos_free_sw_node_schq(pfvf, node);\n\t\totx2_qos_sw_node_delete(pfvf, node);\n\t}\n}\n\nstatic void otx2_qos_free_sw_node(struct otx2_nic *pfvf,\n\t\t\t\t  struct otx2_qos_node *node)\n{\n\tmutex_lock(&pfvf->qos.qos_lock);\n\n\t__otx2_qos_free_sw_node(pfvf, node);\n\totx2_qos_free_sw_node_schq(pfvf, node);\n\totx2_qos_sw_node_delete(pfvf, node);\n\n\tmutex_unlock(&pfvf->qos.qos_lock);\n}\n\nstatic void otx2_qos_destroy_node(struct otx2_nic *pfvf,\n\t\t\t\t  struct otx2_qos_node *node)\n{\n\totx2_qos_free_hw_cfg(pfvf, node);\n\totx2_qos_free_sw_node(pfvf, node);\n}\n\nstatic void otx2_qos_fill_cfg_schq(struct otx2_qos_node *parent,\n\t\t\t\t   struct otx2_qos_cfg *cfg)\n{\n\tstruct otx2_qos_node *node;\n\n\tlist_for_each_entry(node, &parent->child_schq_list, list)\n\t\tcfg->schq[node->level]++;\n}\n\nstatic void otx2_qos_fill_cfg_tl(struct otx2_qos_node *parent,\n\t\t\t\t struct otx2_qos_cfg *cfg)\n{\n\tstruct otx2_qos_node *node;\n\n\tlist_for_each_entry(node, &parent->child_list, list) {\n\t\totx2_qos_fill_cfg_tl(node, cfg);\n\t\totx2_qos_fill_cfg_schq(node, cfg);\n\t}\n\n\t \n\tcfg->schq_contig[parent->level - 1] += parent->child_dwrr_cnt +\n\t\t\t\t\t       parent->max_static_prio + 1;\n}\n\nstatic void otx2_qos_prepare_txschq_cfg(struct otx2_nic *pfvf,\n\t\t\t\t\tstruct otx2_qos_node *parent,\n\t\t\t\t\tstruct otx2_qos_cfg *cfg)\n{\n\tmutex_lock(&pfvf->qos.qos_lock);\n\totx2_qos_fill_cfg_tl(parent, cfg);\n\tmutex_unlock(&pfvf->qos.qos_lock);\n}\n\nstatic void otx2_qos_read_txschq_cfg_schq(struct otx2_qos_node *parent,\n\t\t\t\t\t  struct otx2_qos_cfg *cfg)\n{\n\tstruct otx2_qos_node *node;\n\tint cnt;\n\n\tlist_for_each_entry(node, &parent->child_schq_list, list) {\n\t\tcnt = cfg->dwrr_node_pos[node->level];\n\t\tcfg->schq_list[node->level][cnt] = node->schq;\n\t\tcfg->schq[node->level]++;\n\t\tcfg->dwrr_node_pos[node->level]++;\n\t}\n}\n\nstatic void otx2_qos_read_txschq_cfg_tl(struct otx2_qos_node *parent,\n\t\t\t\t\tstruct otx2_qos_cfg *cfg)\n{\n\tstruct otx2_qos_node *node;\n\tint cnt;\n\n\tlist_for_each_entry(node, &parent->child_list, list) {\n\t\totx2_qos_read_txschq_cfg_tl(node, cfg);\n\t\tcnt = cfg->static_node_pos[node->level];\n\t\tcfg->schq_contig_list[node->level][cnt] = node->schq;\n\t\tcfg->schq_contig[node->level]++;\n\t\tcfg->static_node_pos[node->level]++;\n\t\totx2_qos_read_txschq_cfg_schq(node, cfg);\n\t}\n}\n\nstatic void otx2_qos_read_txschq_cfg(struct otx2_nic *pfvf,\n\t\t\t\t     struct otx2_qos_node *node,\n\t\t\t\t     struct otx2_qos_cfg *cfg)\n{\n\tmutex_lock(&pfvf->qos.qos_lock);\n\totx2_qos_read_txschq_cfg_tl(node, cfg);\n\tmutex_unlock(&pfvf->qos.qos_lock);\n}\n\nstatic struct otx2_qos_node *\notx2_qos_alloc_root(struct otx2_nic *pfvf)\n{\n\tstruct otx2_qos_node *node;\n\n\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnode->parent = NULL;\n\tif (!is_otx2_vf(pfvf->pcifunc)) {\n\t\tnode->level = NIX_TXSCH_LVL_TL1;\n\t} else {\n\t\tnode->level = NIX_TXSCH_LVL_TL2;\n\t\tnode->child_dwrr_prio = OTX2_QOS_DEFAULT_PRIO;\n\t}\n\n\tWRITE_ONCE(node->qid, OTX2_QOS_QID_INNER);\n\tnode->classid = OTX2_QOS_ROOT_CLASSID;\n\n\thash_add_rcu(pfvf->qos.qos_hlist, &node->hlist, node->classid);\n\tlist_add_tail(&node->list, &pfvf->qos.qos_tree);\n\tINIT_LIST_HEAD(&node->child_list);\n\tINIT_LIST_HEAD(&node->child_schq_list);\n\n\treturn node;\n}\n\nstatic int otx2_qos_add_child_node(struct otx2_qos_node *parent,\n\t\t\t\t   struct otx2_qos_node *node)\n{\n\tstruct list_head *head = &parent->child_list;\n\tstruct otx2_qos_node *tmp_node;\n\tstruct list_head *tmp;\n\n\tif (node->prio > parent->max_static_prio)\n\t\tparent->max_static_prio = node->prio;\n\n\tfor (tmp = head->next; tmp != head; tmp = tmp->next) {\n\t\ttmp_node = list_entry(tmp, struct otx2_qos_node, list);\n\t\tif (tmp_node->prio == node->prio &&\n\t\t    tmp_node->is_static)\n\t\t\treturn -EEXIST;\n\t\tif (tmp_node->prio > node->prio) {\n\t\t\tlist_add_tail(&node->list, tmp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tlist_add_tail(&node->list, head);\n\treturn 0;\n}\n\nstatic int otx2_qos_alloc_txschq_node(struct otx2_nic *pfvf,\n\t\t\t\t      struct otx2_qos_node *node)\n{\n\tstruct otx2_qos_node *txschq_node, *parent, *tmp;\n\tint lvl;\n\n\tparent = node;\n\tfor (lvl = node->level - 1; lvl >= NIX_TXSCH_LVL_MDQ; lvl--) {\n\t\ttxschq_node = kzalloc(sizeof(*txschq_node), GFP_KERNEL);\n\t\tif (!txschq_node)\n\t\t\tgoto err_out;\n\n\t\ttxschq_node->parent = parent;\n\t\ttxschq_node->level = lvl;\n\t\ttxschq_node->classid = OTX2_QOS_CLASS_NONE;\n\t\tWRITE_ONCE(txschq_node->qid, OTX2_QOS_QID_NONE);\n\t\ttxschq_node->rate = 0;\n\t\ttxschq_node->ceil = 0;\n\t\ttxschq_node->prio = 0;\n\t\ttxschq_node->quantum = 0;\n\t\ttxschq_node->is_static = true;\n\t\ttxschq_node->child_dwrr_prio = OTX2_QOS_DEFAULT_PRIO;\n\t\ttxschq_node->txschq_idx = OTX2_QOS_INVALID_TXSCHQ_IDX;\n\n\t\tmutex_lock(&pfvf->qos.qos_lock);\n\t\tlist_add_tail(&txschq_node->list, &node->child_schq_list);\n\t\tmutex_unlock(&pfvf->qos.qos_lock);\n\n\t\tINIT_LIST_HEAD(&txschq_node->child_list);\n\t\tINIT_LIST_HEAD(&txschq_node->child_schq_list);\n\t\tparent = txschq_node;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tlist_for_each_entry_safe(txschq_node, tmp, &node->child_schq_list,\n\t\t\t\t list) {\n\t\tlist_del(&txschq_node->list);\n\t\tkfree(txschq_node);\n\t}\n\treturn -ENOMEM;\n}\n\nstatic struct otx2_qos_node *\notx2_qos_sw_create_leaf_node(struct otx2_nic *pfvf,\n\t\t\t     struct otx2_qos_node *parent,\n\t\t\t     u16 classid, u32 prio, u64 rate, u64 ceil,\n\t\t\t     u32 quantum, u16 qid, bool static_cfg)\n{\n\tstruct otx2_qos_node *node;\n\tint err;\n\n\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnode->parent = parent;\n\tnode->level = parent->level - 1;\n\tnode->classid = classid;\n\tWRITE_ONCE(node->qid, qid);\n\n\tnode->rate = otx2_convert_rate(rate);\n\tnode->ceil = otx2_convert_rate(ceil);\n\tnode->prio = prio;\n\tnode->quantum = quantum;\n\tnode->is_static = static_cfg;\n\tnode->child_dwrr_prio = OTX2_QOS_DEFAULT_PRIO;\n\tnode->txschq_idx = OTX2_QOS_INVALID_TXSCHQ_IDX;\n\n\t__set_bit(qid, pfvf->qos.qos_sq_bmap);\n\n\thash_add_rcu(pfvf->qos.qos_hlist, &node->hlist, classid);\n\n\tmutex_lock(&pfvf->qos.qos_lock);\n\terr = otx2_qos_add_child_node(parent, node);\n\tif (err) {\n\t\tmutex_unlock(&pfvf->qos.qos_lock);\n\t\treturn ERR_PTR(err);\n\t}\n\tmutex_unlock(&pfvf->qos.qos_lock);\n\n\tINIT_LIST_HEAD(&node->child_list);\n\tINIT_LIST_HEAD(&node->child_schq_list);\n\n\terr = otx2_qos_alloc_txschq_node(pfvf, node);\n\tif (err) {\n\t\totx2_qos_sw_node_delete(pfvf, node);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn node;\n}\n\nstatic struct otx2_qos_node *\notx2_sw_node_find(struct otx2_nic *pfvf, u32 classid)\n{\n\tstruct otx2_qos_node *node = NULL;\n\n\thash_for_each_possible(pfvf->qos.qos_hlist, node, hlist, classid) {\n\t\tif (node->classid == classid)\n\t\t\tbreak;\n\t}\n\n\treturn node;\n}\n\nstatic struct otx2_qos_node *\notx2_sw_node_find_rcu(struct otx2_nic *pfvf, u32 classid)\n{\n\tstruct otx2_qos_node *node = NULL;\n\n\thash_for_each_possible_rcu(pfvf->qos.qos_hlist, node, hlist, classid) {\n\t\tif (node->classid == classid)\n\t\t\tbreak;\n\t}\n\n\treturn node;\n}\n\nint otx2_get_txq_by_classid(struct otx2_nic *pfvf, u16 classid)\n{\n\tstruct otx2_qos_node *node;\n\tu16 qid;\n\tint res;\n\n\tnode = otx2_sw_node_find_rcu(pfvf, classid);\n\tif (!node) {\n\t\tres = -ENOENT;\n\t\tgoto out;\n\t}\n\tqid = READ_ONCE(node->qid);\n\tif (qid == OTX2_QOS_QID_INNER) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tres = pfvf->hw.tx_queues + qid;\nout:\n\treturn res;\n}\n\nstatic int\notx2_qos_txschq_config(struct otx2_nic *pfvf, struct otx2_qos_node *node)\n{\n\tstruct mbox *mbox = &pfvf->mbox;\n\tstruct nix_txschq_config *req;\n\tint rc;\n\n\tmutex_lock(&mbox->lock);\n\n\treq = otx2_mbox_alloc_msg_nix_txschq_cfg(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&mbox->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->lvl = node->level;\n\t__otx2_qos_txschq_cfg(pfvf, node, req);\n\n\trc = otx2_sync_mbox_msg(&pfvf->mbox);\n\n\tmutex_unlock(&mbox->lock);\n\n\treturn rc;\n}\n\nstatic int otx2_qos_txschq_alloc(struct otx2_nic *pfvf,\n\t\t\t\t struct otx2_qos_cfg *cfg)\n{\n\tstruct nix_txsch_alloc_req *req;\n\tstruct nix_txsch_alloc_rsp *rsp;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tint lvl, rc, schq;\n\n\tmutex_lock(&mbox->lock);\n\treq = otx2_mbox_alloc_msg_nix_txsch_alloc(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&mbox->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (lvl = 0; lvl < NIX_TXSCH_LVL_CNT; lvl++) {\n\t\treq->schq[lvl] = cfg->schq[lvl];\n\t\treq->schq_contig[lvl] = cfg->schq_contig[lvl];\n\t}\n\n\trc = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (rc) {\n\t\tmutex_unlock(&mbox->lock);\n\t\treturn rc;\n\t}\n\n\trsp = (struct nix_txsch_alloc_rsp *)\n\t      otx2_mbox_get_rsp(&pfvf->mbox.mbox, 0, &req->hdr);\n\n\tif (IS_ERR(rsp)) {\n\t\trc = PTR_ERR(rsp);\n\t\tgoto out;\n\t}\n\n\tfor (lvl = 0; lvl < NIX_TXSCH_LVL_CNT; lvl++) {\n\t\tfor (schq = 0; schq < rsp->schq_contig[lvl]; schq++) {\n\t\t\tcfg->schq_contig_list[lvl][schq] =\n\t\t\t\trsp->schq_contig_list[lvl][schq];\n\t\t}\n\t}\n\n\tfor (lvl = 0; lvl < NIX_TXSCH_LVL_CNT; lvl++) {\n\t\tfor (schq = 0; schq < rsp->schq[lvl]; schq++) {\n\t\t\tcfg->schq_list[lvl][schq] =\n\t\t\t\trsp->schq_list[lvl][schq];\n\t\t}\n\t}\n\n\tpfvf->qos.link_cfg_lvl = rsp->link_cfg_lvl;\n\tpfvf->hw.txschq_aggr_lvl_rr_prio = rsp->aggr_lvl_rr_prio;\n\nout:\n\tmutex_unlock(&mbox->lock);\n\treturn rc;\n}\n\nstatic void otx2_qos_free_unused_txschq(struct otx2_nic *pfvf,\n\t\t\t\t\tstruct otx2_qos_cfg *cfg)\n{\n\tint lvl, idx, schq;\n\n\tfor (lvl = 0; lvl < NIX_TXSCH_LVL_CNT; lvl++) {\n\t\tfor (idx = 0; idx < cfg->schq_contig[lvl]; idx++) {\n\t\t\tif (!cfg->schq_index_used[lvl][idx]) {\n\t\t\t\tschq = cfg->schq_contig_list[lvl][idx];\n\t\t\t\totx2_txschq_free_one(pfvf, lvl, schq);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void otx2_qos_txschq_fill_cfg_schq(struct otx2_nic *pfvf,\n\t\t\t\t\t  struct otx2_qos_node *node,\n\t\t\t\t\t  struct otx2_qos_cfg *cfg)\n{\n\tstruct otx2_qos_node *tmp;\n\tint cnt;\n\n\tlist_for_each_entry(tmp, &node->child_schq_list, list) {\n\t\tcnt = cfg->dwrr_node_pos[tmp->level];\n\t\ttmp->schq = cfg->schq_list[tmp->level][cnt];\n\t\tcfg->dwrr_node_pos[tmp->level]++;\n\t}\n}\n\nstatic void otx2_qos_txschq_fill_cfg_tl(struct otx2_nic *pfvf,\n\t\t\t\t\tstruct otx2_qos_node *node,\n\t\t\t\t\tstruct otx2_qos_cfg *cfg)\n{\n\tstruct otx2_qos_node *tmp;\n\tint cnt;\n\n\tlist_for_each_entry(tmp, &node->child_list, list) {\n\t\totx2_qos_txschq_fill_cfg_tl(pfvf, tmp, cfg);\n\t\tcnt = cfg->static_node_pos[tmp->level];\n\t\ttmp->schq = cfg->schq_contig_list[tmp->level][tmp->txschq_idx];\n\t\tcfg->schq_index_used[tmp->level][tmp->txschq_idx] = true;\n\t\tif (cnt == 0)\n\t\t\tnode->prio_anchor =\n\t\t\t\tcfg->schq_contig_list[tmp->level][0];\n\t\tcfg->static_node_pos[tmp->level]++;\n\t\totx2_qos_txschq_fill_cfg_schq(pfvf, tmp, cfg);\n\t}\n}\n\nstatic void otx2_qos_txschq_fill_cfg(struct otx2_nic *pfvf,\n\t\t\t\t     struct otx2_qos_node *node,\n\t\t\t\t     struct otx2_qos_cfg *cfg)\n{\n\tmutex_lock(&pfvf->qos.qos_lock);\n\totx2_qos_txschq_fill_cfg_tl(pfvf, node, cfg);\n\totx2_qos_txschq_fill_cfg_schq(pfvf, node, cfg);\n\totx2_qos_free_unused_txschq(pfvf, cfg);\n\tmutex_unlock(&pfvf->qos.qos_lock);\n}\n\nstatic void __otx2_qos_assign_base_idx_tl(struct otx2_nic *pfvf,\n\t\t\t\t\t  struct otx2_qos_node *tmp,\n\t\t\t\t\t  unsigned long *child_idx_bmap,\n\t\t\t\t\t  int child_cnt)\n{\n\tint idx;\n\n\tif (tmp->txschq_idx != OTX2_QOS_INVALID_TXSCHQ_IDX)\n\t\treturn;\n\n\t \n\tfor (idx = 0; idx < child_cnt; idx++) {\n\t\tif (tmp->is_static && tmp->prio == idx &&\n\t\t    !test_bit(idx, child_idx_bmap)) {\n\t\t\ttmp->txschq_idx = idx;\n\t\t\tset_bit(idx, child_idx_bmap);\n\t\t\treturn;\n\t\t} else if (!tmp->is_static && idx >= tmp->prio &&\n\t\t\t   !test_bit(idx, child_idx_bmap)) {\n\t\t\ttmp->txschq_idx = idx;\n\t\t\tset_bit(idx, child_idx_bmap);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int otx2_qos_assign_base_idx_tl(struct otx2_nic *pfvf,\n\t\t\t\t       struct otx2_qos_node *node)\n{\n\tunsigned long *child_idx_bmap;\n\tstruct otx2_qos_node *tmp;\n\tint child_cnt;\n\n\tlist_for_each_entry(tmp, &node->child_list, list)\n\t\ttmp->txschq_idx = OTX2_QOS_INVALID_TXSCHQ_IDX;\n\n\t \n\tchild_cnt = node->child_dwrr_cnt + node->max_static_prio + 1;\n\tchild_idx_bmap = kcalloc(BITS_TO_LONGS(child_cnt),\n\t\t\t\t sizeof(unsigned long),\n\t\t\t\t GFP_KERNEL);\n\tif (!child_idx_bmap)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(tmp, &node->child_list, list)\n\t\totx2_qos_assign_base_idx_tl(pfvf, tmp);\n\n\t \n\tlist_for_each_entry(tmp, &node->child_list, list) {\n\t\tif (!tmp->is_static)\n\t\t\tcontinue;\n\t\t__otx2_qos_assign_base_idx_tl(pfvf, tmp, child_idx_bmap,\n\t\t\t\t\t      child_cnt);\n\t}\n\n\t \n\tlist_for_each_entry(tmp, &node->child_list, list)\n\t\t__otx2_qos_assign_base_idx_tl(pfvf, tmp, child_idx_bmap,\n\t\t\t\t\t      child_cnt);\n\n\tkfree(child_idx_bmap);\n\n\treturn 0;\n}\n\nstatic int otx2_qos_assign_base_idx(struct otx2_nic *pfvf,\n\t\t\t\t    struct otx2_qos_node *node)\n{\n\tint ret = 0;\n\n\tmutex_lock(&pfvf->qos.qos_lock);\n\tret = otx2_qos_assign_base_idx_tl(pfvf, node);\n\tmutex_unlock(&pfvf->qos.qos_lock);\n\n\treturn ret;\n}\n\nstatic int otx2_qos_txschq_push_cfg_schq(struct otx2_nic *pfvf,\n\t\t\t\t\t struct otx2_qos_node *node,\n\t\t\t\t\t struct otx2_qos_cfg *cfg)\n{\n\tstruct otx2_qos_node *tmp;\n\tint ret;\n\n\tlist_for_each_entry(tmp, &node->child_schq_list, list) {\n\t\tret = otx2_qos_txschq_config(pfvf, tmp);\n\t\tif (ret)\n\t\t\treturn -EIO;\n\t\tret = otx2_qos_txschq_set_parent_topology(pfvf, tmp->parent);\n\t\tif (ret)\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int otx2_qos_txschq_push_cfg_tl(struct otx2_nic *pfvf,\n\t\t\t\t       struct otx2_qos_node *node,\n\t\t\t\t       struct otx2_qos_cfg *cfg)\n{\n\tstruct otx2_qos_node *tmp;\n\tint ret;\n\n\tlist_for_each_entry(tmp, &node->child_list, list) {\n\t\tret = otx2_qos_txschq_push_cfg_tl(pfvf, tmp, cfg);\n\t\tif (ret)\n\t\t\treturn -EIO;\n\t\tret = otx2_qos_txschq_config(pfvf, tmp);\n\t\tif (ret)\n\t\t\treturn -EIO;\n\t\tret = otx2_qos_txschq_push_cfg_schq(pfvf, tmp, cfg);\n\t\tif (ret)\n\t\t\treturn -EIO;\n\t}\n\n\tret = otx2_qos_txschq_set_parent_topology(pfvf, node);\n\tif (ret)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int otx2_qos_txschq_push_cfg(struct otx2_nic *pfvf,\n\t\t\t\t    struct otx2_qos_node *node,\n\t\t\t\t    struct otx2_qos_cfg *cfg)\n{\n\tint ret;\n\n\tmutex_lock(&pfvf->qos.qos_lock);\n\tret = otx2_qos_txschq_push_cfg_tl(pfvf, node, cfg);\n\tif (ret)\n\t\tgoto out;\n\tret = otx2_qos_txschq_push_cfg_schq(pfvf, node, cfg);\nout:\n\tmutex_unlock(&pfvf->qos.qos_lock);\n\treturn ret;\n}\n\nstatic int otx2_qos_txschq_update_config(struct otx2_nic *pfvf,\n\t\t\t\t\t struct otx2_qos_node *node,\n\t\t\t\t\t struct otx2_qos_cfg *cfg)\n{\n\totx2_qos_txschq_fill_cfg(pfvf, node, cfg);\n\n\treturn otx2_qos_txschq_push_cfg(pfvf, node, cfg);\n}\n\nstatic int otx2_qos_txschq_update_root_cfg(struct otx2_nic *pfvf,\n\t\t\t\t\t   struct otx2_qos_node *root,\n\t\t\t\t\t   struct otx2_qos_cfg *cfg)\n{\n\troot->schq = cfg->schq_list[root->level][0];\n\treturn otx2_qos_txschq_config(pfvf, root);\n}\n\nstatic void otx2_qos_free_cfg(struct otx2_nic *pfvf, struct otx2_qos_cfg *cfg)\n{\n\tint lvl, idx, schq;\n\n\tfor (lvl = 0; lvl < NIX_TXSCH_LVL_CNT; lvl++) {\n\t\tfor (idx = 0; idx < cfg->schq[lvl]; idx++) {\n\t\t\tschq = cfg->schq_list[lvl][idx];\n\t\t\totx2_txschq_free_one(pfvf, lvl, schq);\n\t\t}\n\t}\n\n\tfor (lvl = 0; lvl < NIX_TXSCH_LVL_CNT; lvl++) {\n\t\tfor (idx = 0; idx < cfg->schq_contig[lvl]; idx++) {\n\t\t\tif (cfg->schq_index_used[lvl][idx]) {\n\t\t\t\tschq = cfg->schq_contig_list[lvl][idx];\n\t\t\t\totx2_txschq_free_one(pfvf, lvl, schq);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void otx2_qos_enadis_sq(struct otx2_nic *pfvf,\n\t\t\t       struct otx2_qos_node *node,\n\t\t\t       u16 qid)\n{\n\tif (pfvf->qos.qid_to_sqmap[qid] != OTX2_QOS_INVALID_SQ)\n\t\totx2_qos_disable_sq(pfvf, qid);\n\n\tpfvf->qos.qid_to_sqmap[qid] = node->schq;\n\totx2_qos_enable_sq(pfvf, qid);\n}\n\nstatic void otx2_qos_update_smq_schq(struct otx2_nic *pfvf,\n\t\t\t\t     struct otx2_qos_node *node,\n\t\t\t\t     bool action)\n{\n\tstruct otx2_qos_node *tmp;\n\n\tif (node->qid == OTX2_QOS_QID_INNER)\n\t\treturn;\n\n\tlist_for_each_entry(tmp, &node->child_schq_list, list) {\n\t\tif (tmp->level == NIX_TXSCH_LVL_MDQ) {\n\t\t\tif (action == QOS_SMQ_FLUSH)\n\t\t\t\totx2_smq_flush(pfvf, tmp->schq);\n\t\t\telse\n\t\t\t\totx2_qos_enadis_sq(pfvf, tmp, node->qid);\n\t\t}\n\t}\n}\n\nstatic void __otx2_qos_update_smq(struct otx2_nic *pfvf,\n\t\t\t\t  struct otx2_qos_node *node,\n\t\t\t\t  bool action)\n{\n\tstruct otx2_qos_node *tmp;\n\n\tlist_for_each_entry(tmp, &node->child_list, list) {\n\t\t__otx2_qos_update_smq(pfvf, tmp, action);\n\t\tif (tmp->qid == OTX2_QOS_QID_INNER)\n\t\t\tcontinue;\n\t\tif (tmp->level == NIX_TXSCH_LVL_MDQ) {\n\t\t\tif (action == QOS_SMQ_FLUSH)\n\t\t\t\totx2_smq_flush(pfvf, tmp->schq);\n\t\t\telse\n\t\t\t\totx2_qos_enadis_sq(pfvf, tmp, tmp->qid);\n\t\t} else {\n\t\t\totx2_qos_update_smq_schq(pfvf, tmp, action);\n\t\t}\n\t}\n}\n\nstatic void otx2_qos_update_smq(struct otx2_nic *pfvf,\n\t\t\t\tstruct otx2_qos_node *node,\n\t\t\t\tbool action)\n{\n\tmutex_lock(&pfvf->qos.qos_lock);\n\t__otx2_qos_update_smq(pfvf, node, action);\n\totx2_qos_update_smq_schq(pfvf, node, action);\n\tmutex_unlock(&pfvf->qos.qos_lock);\n}\n\nstatic int otx2_qos_push_txschq_cfg(struct otx2_nic *pfvf,\n\t\t\t\t    struct otx2_qos_node *node,\n\t\t\t\t    struct otx2_qos_cfg *cfg)\n{\n\tint ret;\n\n\tret = otx2_qos_txschq_alloc(pfvf, cfg);\n\tif (ret)\n\t\treturn -ENOSPC;\n\n\tret = otx2_qos_assign_base_idx(pfvf, node);\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\tif (!(pfvf->netdev->flags & IFF_UP)) {\n\t\totx2_qos_txschq_fill_cfg(pfvf, node, cfg);\n\t\treturn 0;\n\t}\n\n\tret = otx2_qos_txschq_update_config(pfvf, node, cfg);\n\tif (ret) {\n\t\totx2_qos_free_cfg(pfvf, cfg);\n\t\treturn -EIO;\n\t}\n\n\totx2_qos_update_smq(pfvf, node, QOS_CFG_SQ);\n\n\treturn 0;\n}\n\nstatic int otx2_qos_update_tree(struct otx2_nic *pfvf,\n\t\t\t\tstruct otx2_qos_node *node,\n\t\t\t\tstruct otx2_qos_cfg *cfg)\n{\n\totx2_qos_prepare_txschq_cfg(pfvf, node->parent, cfg);\n\treturn otx2_qos_push_txschq_cfg(pfvf, node->parent, cfg);\n}\n\nstatic int otx2_qos_root_add(struct otx2_nic *pfvf, u16 htb_maj_id, u16 htb_defcls,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct otx2_qos_cfg *new_cfg;\n\tstruct otx2_qos_node *root;\n\tint err;\n\n\tnetdev_dbg(pfvf->netdev,\n\t\t   \"TC_HTB_CREATE: handle=0x%x defcls=0x%x\\n\",\n\t\t   htb_maj_id, htb_defcls);\n\n\troot = otx2_qos_alloc_root(pfvf);\n\tif (IS_ERR(root)) {\n\t\terr = PTR_ERR(root);\n\t\treturn err;\n\t}\n\n\t \n\tnew_cfg = kzalloc(sizeof(*new_cfg), GFP_KERNEL);\n\tif (!new_cfg) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Memory allocation error\");\n\t\terr = -ENOMEM;\n\t\tgoto free_root_node;\n\t}\n\t \n\tnew_cfg->schq[root->level] = 1;\n\terr = otx2_qos_txschq_alloc(pfvf, new_cfg);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Error allocating txschq\");\n\t\tgoto free_root_node;\n\t}\n\n\t \n\tif (root->level == NIX_TXSCH_LVL_TL1) {\n\t\troot->child_dwrr_prio = pfvf->hw.txschq_aggr_lvl_rr_prio;\n\t\tnetdev_dbg(pfvf->netdev,\n\t\t\t   \"TL1 DWRR Priority %d\\n\", root->child_dwrr_prio);\n\t}\n\n\tif (!(pfvf->netdev->flags & IFF_UP) ||\n\t    root->level == NIX_TXSCH_LVL_TL1) {\n\t\troot->schq = new_cfg->schq_list[root->level][0];\n\t\tgoto out;\n\t}\n\n\t \n\terr = otx2_qos_txschq_update_root_cfg(pfvf, root, new_cfg);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Error updating txschq configuration\");\n\t\tgoto txschq_free;\n\t}\n\nout:\n\tWRITE_ONCE(pfvf->qos.defcls, htb_defcls);\n\t \n\tsmp_store_release(&pfvf->qos.maj_id, htb_maj_id);\n\tkfree(new_cfg);\n\treturn 0;\n\ntxschq_free:\n\totx2_qos_free_cfg(pfvf, new_cfg);\nfree_root_node:\n\tkfree(new_cfg);\n\totx2_qos_sw_node_delete(pfvf, root);\n\treturn err;\n}\n\nstatic int otx2_qos_root_destroy(struct otx2_nic *pfvf)\n{\n\tstruct otx2_qos_node *root;\n\n\tnetdev_dbg(pfvf->netdev, \"TC_HTB_DESTROY\\n\");\n\n\t \n\troot = otx2_sw_node_find(pfvf, OTX2_QOS_ROOT_CLASSID);\n\tif (!root)\n\t\treturn -ENOENT;\n\n\t \n\totx2_qos_destroy_node(pfvf, root);\n\n\treturn 0;\n}\n\nstatic int otx2_qos_validate_quantum(struct otx2_nic *pfvf, u32 quantum)\n{\n\tu32 rr_weight = otx2_qos_quantum_to_dwrr_weight(pfvf, quantum);\n\tint err = 0;\n\n\t \n\tif (is_dev_otx2(pfvf->pdev))\n\t\terr = (rr_weight > OTX2_MAX_RR_QUANTUM) ? -EINVAL : 0;\n\telse if\t(rr_weight > CN10K_MAX_RR_WEIGHT)\n\t\terr = -EINVAL;\n\n\treturn err;\n}\n\nstatic int otx2_qos_validate_dwrr_cfg(struct otx2_qos_node *parent,\n\t\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t\t      struct otx2_nic *pfvf,\n\t\t\t\t      u64 prio, u64 quantum)\n{\n\tint err;\n\n\terr = otx2_qos_validate_quantum(pfvf, quantum);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported quantum value\");\n\t\treturn err;\n\t}\n\n\tif (parent->child_dwrr_prio == OTX2_QOS_DEFAULT_PRIO) {\n\t\tparent->child_dwrr_prio = prio;\n\t} else if (prio != parent->child_dwrr_prio) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Only one DWRR group is allowed\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int otx2_qos_validate_configuration(struct otx2_qos_node *parent,\n\t\t\t\t\t   struct netlink_ext_ack *extack,\n\t\t\t\t\t   struct otx2_nic *pfvf,\n\t\t\t\t\t   u64 prio, bool static_cfg)\n{\n\tif (prio == parent->child_dwrr_prio && static_cfg) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"DWRR child group with same priority exists\");\n\t\treturn -EEXIST;\n\t}\n\n\tif (static_cfg && test_bit(prio, parent->prio_bmap)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Static priority child with same priority exists\");\n\t\treturn -EEXIST;\n\t}\n\n\treturn 0;\n}\n\nstatic void otx2_reset_dwrr_prio(struct otx2_qos_node *parent, u64 prio)\n{\n\t \n\tif (parent->level == NIX_TXSCH_LVL_TL1)\n\t\treturn;\n\n\tif (parent->child_dwrr_prio != OTX2_QOS_DEFAULT_PRIO) {\n\t\tparent->child_dwrr_prio = OTX2_QOS_DEFAULT_PRIO;\n\t\tclear_bit(prio, parent->prio_bmap);\n\t}\n}\n\nstatic bool is_qos_node_dwrr(struct otx2_qos_node *parent,\n\t\t\t     struct otx2_nic *pfvf,\n\t\t\t     u64 prio)\n{\n\tstruct otx2_qos_node *node;\n\tbool ret = false;\n\n\tif (parent->child_dwrr_prio == prio)\n\t\treturn true;\n\n\tmutex_lock(&pfvf->qos.qos_lock);\n\tlist_for_each_entry(node, &parent->child_list, list) {\n\t\tif (prio == node->prio) {\n\t\t\tif (parent->child_dwrr_prio != OTX2_QOS_DEFAULT_PRIO &&\n\t\t\t    parent->child_dwrr_prio != prio)\n\t\t\t\tcontinue;\n\n\t\t\tif (otx2_qos_validate_quantum(pfvf, node->quantum)) {\n\t\t\t\tnetdev_err(pfvf->netdev,\n\t\t\t\t\t   \"Unsupported quantum value for existing classid=0x%x quantum=%d prio=%d\",\n\t\t\t\t\t    node->classid, node->quantum,\n\t\t\t\t\t    node->prio);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tnode->is_static = false;\n\t\t\tparent->child_dwrr_cnt++;\n\t\t\tparent->child_static_cnt--;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&pfvf->qos.qos_lock);\n\n\treturn ret;\n}\n\nstatic int otx2_qos_leaf_alloc_queue(struct otx2_nic *pfvf, u16 classid,\n\t\t\t\t     u32 parent_classid, u64 rate, u64 ceil,\n\t\t\t\t     u64 prio, u32 quantum,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct otx2_qos_cfg *old_cfg, *new_cfg;\n\tstruct otx2_qos_node *node, *parent;\n\tint qid, ret, err;\n\tbool static_cfg;\n\n\tnetdev_dbg(pfvf->netdev,\n\t\t   \"TC_HTB_LEAF_ALLOC_QUEUE: classid=0x%x parent_classid=0x%x rate=%lld ceil=%lld prio=%lld quantum=%d\\n\",\n\t\t   classid, parent_classid, rate, ceil, prio, quantum);\n\n\tif (prio > OTX2_QOS_MAX_PRIO) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Valid priority range 0 to 7\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (!quantum || quantum > INT_MAX) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid quantum, range 1 - 2147483647 bytes\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tparent = otx2_sw_node_find(pfvf, parent_classid);\n\tif (!parent) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"parent node not found\");\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tif (parent->level == NIX_TXSCH_LVL_MDQ) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"HTB qos max levels reached\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tstatic_cfg = !is_qos_node_dwrr(parent, pfvf, prio);\n\tret = otx2_qos_validate_configuration(parent, extack, pfvf, prio,\n\t\t\t\t\t      static_cfg);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!static_cfg) {\n\t\tret = otx2_qos_validate_dwrr_cfg(parent, extack, pfvf, prio,\n\t\t\t\t\t\t quantum);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (static_cfg)\n\t\tparent->child_static_cnt++;\n\telse\n\t\tparent->child_dwrr_cnt++;\n\n\tset_bit(prio, parent->prio_bmap);\n\n\t \n\told_cfg = kzalloc(sizeof(*old_cfg), GFP_KERNEL);\n\tif (!old_cfg) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Memory allocation error\");\n\t\tret = -ENOMEM;\n\t\tgoto reset_prio;\n\t}\n\totx2_qos_read_txschq_cfg(pfvf, parent, old_cfg);\n\n\t \n\tqid = otx2_qos_get_qid(pfvf);\n\tif (qid < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Reached max supported QOS SQ's\");\n\t\tret = -ENOMEM;\n\t\tgoto free_old_cfg;\n\t}\n\n\t \n\tpfvf->qos.qid_to_sqmap[qid] = OTX2_QOS_INVALID_SQ;\n\n\t \n\tnode = otx2_qos_sw_create_leaf_node(pfvf, parent, classid, prio, rate,\n\t\t\t\t\t    ceil, quantum, qid, static_cfg);\n\tif (IS_ERR(node)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unable to allocate leaf node\");\n\t\tret = PTR_ERR(node);\n\t\tgoto free_old_cfg;\n\t}\n\n\t \n\tnew_cfg = kzalloc(sizeof(*new_cfg), GFP_KERNEL);\n\tif (!new_cfg) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Memory allocation error\");\n\t\tret = -ENOMEM;\n\t\tgoto free_node;\n\t}\n\tret = otx2_qos_update_tree(pfvf, node, new_cfg);\n\tif (ret) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"HTB HW configuration error\");\n\t\tkfree(new_cfg);\n\t\totx2_qos_sw_node_delete(pfvf, node);\n\t\t \n\t\terr = otx2_qos_txschq_update_config(pfvf, parent, old_cfg);\n\t\tif (err) {\n\t\t\tnetdev_err(pfvf->netdev,\n\t\t\t\t   \"Failed to restore txcshq configuration\");\n\t\t\tgoto free_old_cfg;\n\t\t}\n\n\t\totx2_qos_update_smq(pfvf, parent, QOS_CFG_SQ);\n\t\tgoto free_old_cfg;\n\t}\n\n\t \n\totx2_qos_update_tx_netdev_queues(pfvf);\n\n\t \n\tkfree(new_cfg);\n\n\t \n\totx2_qos_free_cfg(pfvf, old_cfg);\n\tkfree(old_cfg);\n\n\treturn pfvf->hw.tx_queues + qid;\n\nfree_node:\n\totx2_qos_sw_node_delete(pfvf, node);\nfree_old_cfg:\n\tkfree(old_cfg);\nreset_prio:\n\tif (static_cfg)\n\t\tparent->child_static_cnt--;\n\telse\n\t\tparent->child_dwrr_cnt--;\n\n\tclear_bit(prio, parent->prio_bmap);\nout:\n\treturn ret;\n}\n\nstatic int otx2_qos_leaf_to_inner(struct otx2_nic *pfvf, u16 classid,\n\t\t\t\t  u16 child_classid, u64 rate, u64 ceil, u64 prio,\n\t\t\t\t  u32 quantum, struct netlink_ext_ack *extack)\n{\n\tstruct otx2_qos_cfg *old_cfg, *new_cfg;\n\tstruct otx2_qos_node *node, *child;\n\tbool static_cfg;\n\tint ret, err;\n\tu16 qid;\n\n\tnetdev_dbg(pfvf->netdev,\n\t\t   \"TC_HTB_LEAF_TO_INNER classid %04x, child %04x, rate %llu, ceil %llu\\n\",\n\t\t   classid, child_classid, rate, ceil);\n\n\tif (prio > OTX2_QOS_MAX_PRIO) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Valid priority range 0 to 7\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (!quantum || quantum > INT_MAX) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid quantum, range 1 - 2147483647 bytes\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tnode = otx2_sw_node_find(pfvf, classid);\n\tif (!node) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"HTB node not found\");\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t \n\tif (node->level == NIX_TXSCH_LVL_MDQ) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"HTB qos level not supported\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tstatic_cfg = !is_qos_node_dwrr(node, pfvf, prio);\n\tif (!static_cfg) {\n\t\tret = otx2_qos_validate_dwrr_cfg(node, extack, pfvf, prio,\n\t\t\t\t\t\t quantum);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (static_cfg)\n\t\tnode->child_static_cnt++;\n\telse\n\t\tnode->child_dwrr_cnt++;\n\n\tset_bit(prio, node->prio_bmap);\n\n\t \n\tqid = node->qid;\n\n\t \n\told_cfg = kzalloc(sizeof(*old_cfg), GFP_KERNEL);\n\tif (!old_cfg) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Memory allocation error\");\n\t\tret = -ENOMEM;\n\t\tgoto reset_prio;\n\t}\n\totx2_qos_read_txschq_cfg(pfvf, node, old_cfg);\n\n\t \n\totx2_qos_free_sw_node_schq(pfvf, node);\n\n\t \n\tWRITE_ONCE(node->qid, OTX2_QOS_QID_INNER);\n\n\t \n\tchild = otx2_qos_sw_create_leaf_node(pfvf, node, child_classid,\n\t\t\t\t\t     prio, rate, ceil, quantum,\n\t\t\t\t\t     qid, static_cfg);\n\tif (IS_ERR(child)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unable to allocate leaf node\");\n\t\tret = PTR_ERR(child);\n\t\tgoto free_old_cfg;\n\t}\n\n\t \n\tnew_cfg = kzalloc(sizeof(*new_cfg), GFP_KERNEL);\n\tif (!new_cfg) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Memory allocation error\");\n\t\tret = -ENOMEM;\n\t\tgoto free_node;\n\t}\n\tret = otx2_qos_update_tree(pfvf, child, new_cfg);\n\tif (ret) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"HTB HW configuration error\");\n\t\tkfree(new_cfg);\n\t\totx2_qos_sw_node_delete(pfvf, child);\n\t\t \n\t\tWRITE_ONCE(node->qid, qid);\n\t\terr = otx2_qos_alloc_txschq_node(pfvf, node);\n\t\tif (err) {\n\t\t\tnetdev_err(pfvf->netdev,\n\t\t\t\t   \"Failed to restore old leaf node\");\n\t\t\tgoto free_old_cfg;\n\t\t}\n\t\terr = otx2_qos_txschq_update_config(pfvf, node, old_cfg);\n\t\tif (err) {\n\t\t\tnetdev_err(pfvf->netdev,\n\t\t\t\t   \"Failed to restore txcshq configuration\");\n\t\t\tgoto free_old_cfg;\n\t\t}\n\t\totx2_qos_update_smq(pfvf, node, QOS_CFG_SQ);\n\t\tgoto free_old_cfg;\n\t}\n\n\t \n\tkfree(new_cfg);\n\n\t \n\totx2_qos_free_cfg(pfvf, old_cfg);\n\tkfree(old_cfg);\n\n\treturn 0;\n\nfree_node:\n\totx2_qos_sw_node_delete(pfvf, child);\nfree_old_cfg:\n\tkfree(old_cfg);\nreset_prio:\n\tif (static_cfg)\n\t\tnode->child_static_cnt--;\n\telse\n\t\tnode->child_dwrr_cnt--;\n\tclear_bit(prio, node->prio_bmap);\nout:\n\treturn ret;\n}\n\nstatic int otx2_qos_leaf_del(struct otx2_nic *pfvf, u16 *classid,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct otx2_qos_node *node, *parent;\n\tint dwrr_del_node = false;\n\tu64 prio;\n\tu16 qid;\n\n\tnetdev_dbg(pfvf->netdev, \"TC_HTB_LEAF_DEL classid %04x\\n\", *classid);\n\n\t \n\tnode = otx2_sw_node_find(pfvf, *classid);\n\tif (!node) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"HTB node not found\");\n\t\treturn -ENOENT;\n\t}\n\tparent = node->parent;\n\tprio   = node->prio;\n\tqid    = node->qid;\n\n\tif (!node->is_static)\n\t\tdwrr_del_node = true;\n\n\totx2_qos_disable_sq(pfvf, node->qid);\n\n\totx2_qos_destroy_node(pfvf, node);\n\tpfvf->qos.qid_to_sqmap[qid] = OTX2_QOS_INVALID_SQ;\n\n\tif (dwrr_del_node) {\n\t\tparent->child_dwrr_cnt--;\n\t} else {\n\t\tparent->child_static_cnt--;\n\t\tclear_bit(prio, parent->prio_bmap);\n\t}\n\n\t \n\tif (!parent->child_dwrr_cnt)\n\t\totx2_reset_dwrr_prio(parent, prio);\n\n\tif (!parent->child_static_cnt)\n\t\tparent->max_static_prio = 0;\n\n\treturn 0;\n}\n\nstatic int otx2_qos_leaf_del_last(struct otx2_nic *pfvf, u16 classid, bool force,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct otx2_qos_node *node, *parent;\n\tstruct otx2_qos_cfg *new_cfg;\n\tint dwrr_del_node = false;\n\tu64 prio;\n\tint err;\n\tu16 qid;\n\n\tnetdev_dbg(pfvf->netdev,\n\t\t   \"TC_HTB_LEAF_DEL_LAST classid %04x\\n\", classid);\n\n\t \n\tnode = otx2_sw_node_find(pfvf, classid);\n\tif (!node) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"HTB node not found\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tqid = node->qid;\n\tprio = node->prio;\n\n\tparent = otx2_sw_node_find(pfvf, node->parent->classid);\n\tif (!parent) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"parent node not found\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (!node->is_static)\n\t\tdwrr_del_node = true;\n\n\t \n\totx2_qos_destroy_node(pfvf, node);\n\tpfvf->qos.qid_to_sqmap[qid] = OTX2_QOS_INVALID_SQ;\n\n\tif (dwrr_del_node) {\n\t\tparent->child_dwrr_cnt--;\n\t} else {\n\t\tparent->child_static_cnt--;\n\t\tclear_bit(prio, parent->prio_bmap);\n\t}\n\n\t \n\tif (!parent->child_dwrr_cnt)\n\t\totx2_reset_dwrr_prio(parent, prio);\n\n\tif (!parent->child_static_cnt)\n\t\tparent->max_static_prio = 0;\n\n\t \n\terr = otx2_qos_alloc_txschq_node(pfvf, parent);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"HTB failed to create txsch configuration\");\n\t\treturn err;\n\t}\n\tWRITE_ONCE(parent->qid, qid);\n\t__set_bit(qid, pfvf->qos.qos_sq_bmap);\n\n\t \n\tnew_cfg = kzalloc(sizeof(*new_cfg), GFP_KERNEL);\n\tif (!new_cfg) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Memory allocation error\");\n\t\treturn -ENOMEM;\n\t}\n\t \n\totx2_qos_fill_cfg_schq(parent, new_cfg);\n\terr = otx2_qos_push_txschq_cfg(pfvf, parent, new_cfg);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"HTB HW configuration error\");\n\t\tkfree(new_cfg);\n\t\treturn err;\n\t}\n\tkfree(new_cfg);\n\n\t \n\totx2_qos_update_tx_netdev_queues(pfvf);\n\n\treturn 0;\n}\n\nvoid otx2_clean_qos_queues(struct otx2_nic *pfvf)\n{\n\tstruct otx2_qos_node *root;\n\n\troot = otx2_sw_node_find(pfvf, OTX2_QOS_ROOT_CLASSID);\n\tif (!root)\n\t\treturn;\n\n\totx2_qos_update_smq(pfvf, root, QOS_SMQ_FLUSH);\n}\n\nvoid otx2_qos_config_txschq(struct otx2_nic *pfvf)\n{\n\tstruct otx2_qos_node *root;\n\tint err;\n\n\troot = otx2_sw_node_find(pfvf, OTX2_QOS_ROOT_CLASSID);\n\tif (!root)\n\t\treturn;\n\n\tif (root->level != NIX_TXSCH_LVL_TL1) {\n\t\terr = otx2_qos_txschq_config(pfvf, root);\n\t\tif (err) {\n\t\t\tnetdev_err(pfvf->netdev, \"Error update txschq configuration\\n\");\n\t\t\tgoto root_destroy;\n\t\t}\n\t}\n\n\terr = otx2_qos_txschq_push_cfg_tl(pfvf, root, NULL);\n\tif (err) {\n\t\tnetdev_err(pfvf->netdev, \"Error update txschq configuration\\n\");\n\t\tgoto root_destroy;\n\t}\n\n\totx2_qos_update_smq(pfvf, root, QOS_CFG_SQ);\n\treturn;\n\nroot_destroy:\n\tnetdev_err(pfvf->netdev, \"Failed to update Scheduler/Shaping config in Hardware\\n\");\n\t \n\totx2_qos_root_destroy(pfvf);\n}\n\nint otx2_setup_tc_htb(struct net_device *ndev, struct tc_htb_qopt_offload *htb)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(ndev);\n\tint res;\n\n\tswitch (htb->command) {\n\tcase TC_HTB_CREATE:\n\t\treturn otx2_qos_root_add(pfvf, htb->parent_classid,\n\t\t\t\t\t htb->classid, htb->extack);\n\tcase TC_HTB_DESTROY:\n\t\treturn otx2_qos_root_destroy(pfvf);\n\tcase TC_HTB_LEAF_ALLOC_QUEUE:\n\t\tres = otx2_qos_leaf_alloc_queue(pfvf, htb->classid,\n\t\t\t\t\t\thtb->parent_classid,\n\t\t\t\t\t\thtb->rate, htb->ceil,\n\t\t\t\t\t\thtb->prio, htb->quantum,\n\t\t\t\t\t\thtb->extack);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\thtb->qid = res;\n\t\treturn 0;\n\tcase TC_HTB_LEAF_TO_INNER:\n\t\treturn otx2_qos_leaf_to_inner(pfvf, htb->parent_classid,\n\t\t\t\t\t      htb->classid, htb->rate,\n\t\t\t\t\t      htb->ceil, htb->prio,\n\t\t\t\t\t      htb->quantum, htb->extack);\n\tcase TC_HTB_LEAF_DEL:\n\t\treturn otx2_qos_leaf_del(pfvf, &htb->classid, htb->extack);\n\tcase TC_HTB_LEAF_DEL_LAST:\n\tcase TC_HTB_LEAF_DEL_LAST_FORCE:\n\t\treturn otx2_qos_leaf_del_last(pfvf, htb->classid,\n\t\t\t\thtb->command == TC_HTB_LEAF_DEL_LAST_FORCE,\n\t\t\t\t\t      htb->extack);\n\tcase TC_HTB_LEAF_QUERY_QUEUE:\n\t\tres = otx2_get_txq_by_classid(pfvf, htb->classid);\n\t\thtb->qid = res;\n\t\treturn 0;\n\tcase TC_HTB_NODE_MODIFY:\n\t\tfallthrough;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}