{
  "module_name": "cn10k_macsec.c",
  "hash_id": "6b8baa594864b9a997acda8f9ae1f551c82167ec32785886a92485e85dc7167e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/nic/cn10k_macsec.c",
  "human_readable_source": "\n \n\n#include <crypto/skcipher.h>\n#include <linux/rtnetlink.h>\n#include <linux/bitfield.h>\n#include \"otx2_common.h\"\n\n#define MCS_TCAM0_MAC_DA_MASK\t\tGENMASK_ULL(47, 0)\n#define MCS_TCAM0_MAC_SA_MASK\t\tGENMASK_ULL(63, 48)\n#define MCS_TCAM1_MAC_SA_MASK\t\tGENMASK_ULL(31, 0)\n#define MCS_TCAM1_ETYPE_MASK\t\tGENMASK_ULL(47, 32)\n\n#define MCS_SA_MAP_MEM_SA_USE\t\tBIT_ULL(9)\n\n#define MCS_RX_SECY_PLCY_RW_MASK\tGENMASK_ULL(49, 18)\n#define MCS_RX_SECY_PLCY_RP\t\tBIT_ULL(17)\n#define MCS_RX_SECY_PLCY_AUTH_ENA\tBIT_ULL(16)\n#define MCS_RX_SECY_PLCY_CIP\t\tGENMASK_ULL(8, 5)\n#define MCS_RX_SECY_PLCY_VAL\t\tGENMASK_ULL(2, 1)\n#define MCS_RX_SECY_PLCY_ENA\t\tBIT_ULL(0)\n\n#define MCS_TX_SECY_PLCY_MTU\t\tGENMASK_ULL(43, 28)\n#define MCS_TX_SECY_PLCY_ST_TCI\t\tGENMASK_ULL(27, 22)\n#define MCS_TX_SECY_PLCY_ST_OFFSET\tGENMASK_ULL(21, 15)\n#define MCS_TX_SECY_PLCY_INS_MODE\tBIT_ULL(14)\n#define MCS_TX_SECY_PLCY_AUTH_ENA\tBIT_ULL(13)\n#define MCS_TX_SECY_PLCY_CIP\t\tGENMASK_ULL(5, 2)\n#define MCS_TX_SECY_PLCY_PROTECT\tBIT_ULL(1)\n#define MCS_TX_SECY_PLCY_ENA\t\tBIT_ULL(0)\n\n#define MCS_GCM_AES_128\t\t\t0\n#define MCS_GCM_AES_256\t\t\t1\n#define MCS_GCM_AES_XPN_128\t\t2\n#define MCS_GCM_AES_XPN_256\t\t3\n\n#define MCS_TCI_ES\t\t\t0x40  \n#define MCS_TCI_SC\t\t\t0x20  \n#define MCS_TCI_SCB\t\t\t0x10  \n#define MCS_TCI_E\t\t\t0x08  \n#define MCS_TCI_C\t\t\t0x04  \n\n#define CN10K_MAX_HASH_LEN\t\t16\n#define CN10K_MAX_SAK_LEN\t\t32\n\nstatic int cn10k_ecb_aes_encrypt(struct otx2_nic *pfvf, u8 *sak,\n\t\t\t\t u16 sak_len, u8 *hash)\n{\n\tu8 data[CN10K_MAX_HASH_LEN] = { 0 };\n\tstruct skcipher_request *req = NULL;\n\tstruct scatterlist sg_src, sg_dst;\n\tstruct crypto_skcipher *tfm;\n\tDECLARE_CRYPTO_WAIT(wait);\n\tint err;\n\n\ttfm = crypto_alloc_skcipher(\"ecb(aes)\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tdev_err(pfvf->dev, \"failed to allocate transform for ecb-aes\\n\");\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\treq = skcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tdev_err(pfvf->dev, \"failed to allocate request for skcipher\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto free_tfm;\n\t}\n\n\terr = crypto_skcipher_setkey(tfm, sak, sak_len);\n\tif (err) {\n\t\tdev_err(pfvf->dev, \"failed to set key for skcipher\\n\");\n\t\tgoto free_req;\n\t}\n\n\t \n\tsg_init_one(&sg_src, data, CN10K_MAX_HASH_LEN);\n\tsg_init_one(&sg_dst, hash, CN10K_MAX_HASH_LEN);\n\n\tskcipher_request_set_callback(req, 0, crypto_req_done, &wait);\n\tskcipher_request_set_crypt(req, &sg_src, &sg_dst,\n\t\t\t\t   CN10K_MAX_HASH_LEN, NULL);\n\n\terr = crypto_skcipher_encrypt(req);\n\terr = crypto_wait_req(err, &wait);\n\nfree_req:\n\tskcipher_request_free(req);\nfree_tfm:\n\tcrypto_free_skcipher(tfm);\n\treturn err;\n}\n\nstatic struct cn10k_mcs_txsc *cn10k_mcs_get_txsc(struct cn10k_mcs_cfg *cfg,\n\t\t\t\t\t\t struct macsec_secy *secy)\n{\n\tstruct cn10k_mcs_txsc *txsc;\n\n\tlist_for_each_entry(txsc, &cfg->txsc_list, entry) {\n\t\tif (txsc->sw_secy == secy)\n\t\t\treturn txsc;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct cn10k_mcs_rxsc *cn10k_mcs_get_rxsc(struct cn10k_mcs_cfg *cfg,\n\t\t\t\t\t\t struct macsec_secy *secy,\n\t\t\t\t\t\t struct macsec_rx_sc *rx_sc)\n{\n\tstruct cn10k_mcs_rxsc *rxsc;\n\n\tlist_for_each_entry(rxsc, &cfg->rxsc_list, entry) {\n\t\tif (rxsc->sw_rxsc == rx_sc && rxsc->sw_secy == secy)\n\t\t\treturn rxsc;\n\t}\n\n\treturn NULL;\n}\n\nstatic const char *rsrc_name(enum mcs_rsrc_type rsrc_type)\n{\n\tswitch (rsrc_type) {\n\tcase MCS_RSRC_TYPE_FLOWID:\n\t\treturn \"FLOW\";\n\tcase MCS_RSRC_TYPE_SC:\n\t\treturn \"SC\";\n\tcase MCS_RSRC_TYPE_SECY:\n\t\treturn \"SECY\";\n\tcase MCS_RSRC_TYPE_SA:\n\t\treturn \"SA\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t};\n\n\treturn \"Unknown\";\n}\n\nstatic int cn10k_mcs_alloc_rsrc(struct otx2_nic *pfvf, enum mcs_direction dir,\n\t\t\t\tenum mcs_rsrc_type type, u16 *rsrc_id)\n{\n\tstruct mbox *mbox = &pfvf->mbox;\n\tstruct mcs_alloc_rsrc_req *req;\n\tstruct mcs_alloc_rsrc_rsp *rsp;\n\tint ret = -ENOMEM;\n\n\tmutex_lock(&mbox->lock);\n\n\treq = otx2_mbox_alloc_msg_mcs_alloc_resources(mbox);\n\tif (!req)\n\t\tgoto fail;\n\n\treq->rsrc_type = type;\n\treq->rsrc_cnt  = 1;\n\treq->dir = dir;\n\n\tret = otx2_sync_mbox_msg(mbox);\n\tif (ret)\n\t\tgoto fail;\n\n\trsp = (struct mcs_alloc_rsrc_rsp *)otx2_mbox_get_rsp(&pfvf->mbox.mbox,\n\t\t\t\t\t\t\t     0, &req->hdr);\n\tif (IS_ERR(rsp) || req->rsrc_cnt != rsp->rsrc_cnt ||\n\t    req->rsrc_type != rsp->rsrc_type || req->dir != rsp->dir) {\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tswitch (rsp->rsrc_type) {\n\tcase MCS_RSRC_TYPE_FLOWID:\n\t\t*rsrc_id = rsp->flow_ids[0];\n\t\tbreak;\n\tcase MCS_RSRC_TYPE_SC:\n\t\t*rsrc_id = rsp->sc_ids[0];\n\t\tbreak;\n\tcase MCS_RSRC_TYPE_SECY:\n\t\t*rsrc_id = rsp->secy_ids[0];\n\t\tbreak;\n\tcase MCS_RSRC_TYPE_SA:\n\t\t*rsrc_id = rsp->sa_ids[0];\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tmutex_unlock(&mbox->lock);\n\n\treturn 0;\nfail:\n\tdev_err(pfvf->dev, \"Failed to allocate %s %s resource\\n\",\n\t\tdir == MCS_TX ? \"TX\" : \"RX\", rsrc_name(type));\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic void cn10k_mcs_free_rsrc(struct otx2_nic *pfvf, enum mcs_direction dir,\n\t\t\t\tenum mcs_rsrc_type type, u16 hw_rsrc_id,\n\t\t\t\tbool all)\n{\n\tstruct mcs_clear_stats *clear_req;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tstruct mcs_free_rsrc_req *req;\n\n\tmutex_lock(&mbox->lock);\n\n\tclear_req = otx2_mbox_alloc_msg_mcs_clear_stats(mbox);\n\tif (!clear_req)\n\t\tgoto fail;\n\n\tclear_req->id = hw_rsrc_id;\n\tclear_req->type = type;\n\tclear_req->dir = dir;\n\n\treq = otx2_mbox_alloc_msg_mcs_free_resources(mbox);\n\tif (!req)\n\t\tgoto fail;\n\n\treq->rsrc_id = hw_rsrc_id;\n\treq->rsrc_type = type;\n\treq->dir = dir;\n\tif (all)\n\t\treq->all = 1;\n\n\tif (otx2_sync_mbox_msg(&pfvf->mbox))\n\t\tgoto fail;\n\n\tmutex_unlock(&mbox->lock);\n\n\treturn;\nfail:\n\tdev_err(pfvf->dev, \"Failed to free %s %s resource\\n\",\n\t\tdir == MCS_TX ? \"TX\" : \"RX\", rsrc_name(type));\n\tmutex_unlock(&mbox->lock);\n}\n\nstatic int cn10k_mcs_alloc_txsa(struct otx2_nic *pfvf, u16 *hw_sa_id)\n{\n\treturn cn10k_mcs_alloc_rsrc(pfvf, MCS_TX, MCS_RSRC_TYPE_SA, hw_sa_id);\n}\n\nstatic int cn10k_mcs_alloc_rxsa(struct otx2_nic *pfvf, u16 *hw_sa_id)\n{\n\treturn cn10k_mcs_alloc_rsrc(pfvf, MCS_RX, MCS_RSRC_TYPE_SA, hw_sa_id);\n}\n\nstatic void cn10k_mcs_free_txsa(struct otx2_nic *pfvf, u16 hw_sa_id)\n{\n\tcn10k_mcs_free_rsrc(pfvf, MCS_TX, MCS_RSRC_TYPE_SA, hw_sa_id, false);\n}\n\nstatic void cn10k_mcs_free_rxsa(struct otx2_nic *pfvf, u16 hw_sa_id)\n{\n\tcn10k_mcs_free_rsrc(pfvf, MCS_RX, MCS_RSRC_TYPE_SA, hw_sa_id, false);\n}\n\nstatic int cn10k_mcs_write_rx_secy(struct otx2_nic *pfvf,\n\t\t\t\t   struct macsec_secy *secy, u8 hw_secy_id)\n{\n\tstruct mcs_secy_plcy_write_req *req;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tu64 policy;\n\tu8 cipher;\n\tint ret;\n\n\tmutex_lock(&mbox->lock);\n\n\treq = otx2_mbox_alloc_msg_mcs_secy_plcy_write(mbox);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tpolicy = FIELD_PREP(MCS_RX_SECY_PLCY_RW_MASK, secy->replay_window);\n\tif (secy->replay_protect)\n\t\tpolicy |= MCS_RX_SECY_PLCY_RP;\n\n\tpolicy |= MCS_RX_SECY_PLCY_AUTH_ENA;\n\n\tswitch (secy->key_len) {\n\tcase 16:\n\t\tcipher = secy->xpn ? MCS_GCM_AES_XPN_128 : MCS_GCM_AES_128;\n\t\tbreak;\n\tcase 32:\n\t\tcipher = secy->xpn ? MCS_GCM_AES_XPN_256 : MCS_GCM_AES_256;\n\t\tbreak;\n\tdefault:\n\t\tcipher = MCS_GCM_AES_128;\n\t\tdev_warn(pfvf->dev, \"Unsupported key length\\n\");\n\t\tbreak;\n\t}\n\n\tpolicy |= FIELD_PREP(MCS_RX_SECY_PLCY_CIP, cipher);\n\tpolicy |= FIELD_PREP(MCS_RX_SECY_PLCY_VAL, secy->validate_frames);\n\n\tpolicy |= MCS_RX_SECY_PLCY_ENA;\n\n\treq->plcy = policy;\n\treq->secy_id = hw_secy_id;\n\treq->dir = MCS_RX;\n\n\tret = otx2_sync_mbox_msg(mbox);\n\nfail:\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic int cn10k_mcs_write_rx_flowid(struct otx2_nic *pfvf,\n\t\t\t\t     struct cn10k_mcs_rxsc *rxsc, u8 hw_secy_id)\n{\n\tstruct macsec_rx_sc *sw_rx_sc = rxsc->sw_rxsc;\n\tstruct macsec_secy *secy = rxsc->sw_secy;\n\tstruct mcs_flowid_entry_write_req *req;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tu64 mac_da;\n\tint ret;\n\n\tmutex_lock(&mbox->lock);\n\n\treq = otx2_mbox_alloc_msg_mcs_flowid_entry_write(mbox);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tmac_da = ether_addr_to_u64(secy->netdev->dev_addr);\n\n\treq->data[0] = FIELD_PREP(MCS_TCAM0_MAC_DA_MASK, mac_da);\n\treq->mask[0] = ~0ULL;\n\treq->mask[0] = ~MCS_TCAM0_MAC_DA_MASK;\n\n\treq->data[1] = FIELD_PREP(MCS_TCAM1_ETYPE_MASK, ETH_P_MACSEC);\n\treq->mask[1] = ~0ULL;\n\treq->mask[1] &= ~MCS_TCAM1_ETYPE_MASK;\n\n\treq->mask[2] = ~0ULL;\n\treq->mask[3] = ~0ULL;\n\n\treq->flow_id = rxsc->hw_flow_id;\n\treq->secy_id = hw_secy_id;\n\treq->sc_id = rxsc->hw_sc_id;\n\treq->dir = MCS_RX;\n\n\tif (sw_rx_sc->active)\n\t\treq->ena = 1;\n\n\tret = otx2_sync_mbox_msg(mbox);\n\nfail:\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic int cn10k_mcs_write_sc_cam(struct otx2_nic *pfvf,\n\t\t\t\t  struct cn10k_mcs_rxsc *rxsc, u8 hw_secy_id)\n{\n\tstruct macsec_rx_sc *sw_rx_sc = rxsc->sw_rxsc;\n\tstruct mcs_rx_sc_cam_write_req *sc_req;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tint ret;\n\n\tmutex_lock(&mbox->lock);\n\n\tsc_req = otx2_mbox_alloc_msg_mcs_rx_sc_cam_write(mbox);\n\tif (!sc_req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tsc_req->sci = (__force u64)cpu_to_be64((__force u64)sw_rx_sc->sci);\n\tsc_req->sc_id = rxsc->hw_sc_id;\n\tsc_req->secy_id = hw_secy_id;\n\n\tret = otx2_sync_mbox_msg(mbox);\n\nfail:\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic int cn10k_mcs_write_keys(struct otx2_nic *pfvf,\n\t\t\t\tstruct macsec_secy *secy,\n\t\t\t\tstruct mcs_sa_plcy_write_req *req,\n\t\t\t\tu8 *sak, u8 *salt, ssci_t ssci)\n{\n\tu8 hash_rev[CN10K_MAX_HASH_LEN];\n\tu8 sak_rev[CN10K_MAX_SAK_LEN];\n\tu8 salt_rev[MACSEC_SALT_LEN];\n\tu8 hash[CN10K_MAX_HASH_LEN];\n\tu32 ssci_63_32;\n\tint err, i;\n\n\terr = cn10k_ecb_aes_encrypt(pfvf, sak, secy->key_len, hash);\n\tif (err) {\n\t\tdev_err(pfvf->dev, \"Generating hash using ECB(AES) failed\\n\");\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < secy->key_len; i++)\n\t\tsak_rev[i] = sak[secy->key_len - 1 - i];\n\n\tfor (i = 0; i < CN10K_MAX_HASH_LEN; i++)\n\t\thash_rev[i] = hash[CN10K_MAX_HASH_LEN - 1 - i];\n\n\tfor (i = 0; i < MACSEC_SALT_LEN; i++)\n\t\tsalt_rev[i] = salt[MACSEC_SALT_LEN - 1 - i];\n\n\tssci_63_32 = (__force u32)cpu_to_be32((__force u32)ssci);\n\n\tmemcpy(&req->plcy[0][0], sak_rev, secy->key_len);\n\tmemcpy(&req->plcy[0][4], hash_rev, CN10K_MAX_HASH_LEN);\n\tmemcpy(&req->plcy[0][6], salt_rev, MACSEC_SALT_LEN);\n\treq->plcy[0][7] |= (u64)ssci_63_32 << 32;\n\n\treturn 0;\n}\n\nstatic int cn10k_mcs_write_rx_sa_plcy(struct otx2_nic *pfvf,\n\t\t\t\t      struct macsec_secy *secy,\n\t\t\t\t      struct cn10k_mcs_rxsc *rxsc,\n\t\t\t\t      u8 assoc_num, bool sa_in_use)\n{\n\tstruct mcs_sa_plcy_write_req *plcy_req;\n\tu8 *sak = rxsc->sa_key[assoc_num];\n\tu8 *salt = rxsc->salt[assoc_num];\n\tstruct mcs_rx_sc_sa_map *map_req;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tint ret;\n\n\tmutex_lock(&mbox->lock);\n\n\tplcy_req = otx2_mbox_alloc_msg_mcs_sa_plcy_write(mbox);\n\tif (!plcy_req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tmap_req = otx2_mbox_alloc_msg_mcs_rx_sc_sa_map_write(mbox);\n\tif (!map_req) {\n\t\totx2_mbox_reset(&mbox->mbox, 0);\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tret = cn10k_mcs_write_keys(pfvf, secy, plcy_req, sak,\n\t\t\t\t   salt, rxsc->ssci[assoc_num]);\n\tif (ret)\n\t\tgoto fail;\n\n\tplcy_req->sa_index[0] = rxsc->hw_sa_id[assoc_num];\n\tplcy_req->sa_cnt = 1;\n\tplcy_req->dir = MCS_RX;\n\n\tmap_req->sa_index = rxsc->hw_sa_id[assoc_num];\n\tmap_req->sa_in_use = sa_in_use;\n\tmap_req->sc_id = rxsc->hw_sc_id;\n\tmap_req->an = assoc_num;\n\n\t \n\tret = otx2_sync_mbox_msg(mbox);\n\nfail:\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic int cn10k_mcs_write_rx_sa_pn(struct otx2_nic *pfvf,\n\t\t\t\t    struct cn10k_mcs_rxsc *rxsc,\n\t\t\t\t    u8 assoc_num, u64 next_pn)\n{\n\tstruct mcs_pn_table_write_req *req;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tint ret;\n\n\tmutex_lock(&mbox->lock);\n\n\treq = otx2_mbox_alloc_msg_mcs_pn_table_write(mbox);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\treq->pn_id = rxsc->hw_sa_id[assoc_num];\n\treq->next_pn = next_pn;\n\treq->dir = MCS_RX;\n\n\tret = otx2_sync_mbox_msg(mbox);\n\nfail:\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic int cn10k_mcs_write_tx_secy(struct otx2_nic *pfvf,\n\t\t\t\t   struct macsec_secy *secy,\n\t\t\t\t   struct cn10k_mcs_txsc *txsc)\n{\n\tstruct mcs_secy_plcy_write_req *req;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tstruct macsec_tx_sc *sw_tx_sc;\n\tu8 sectag_tci = 0;\n\tu8 tag_offset;\n\tu64 policy;\n\tu8 cipher;\n\tint ret;\n\n\t \n\ttag_offset = txsc->vlan_dev ? 16 : 12;\n\tsw_tx_sc = &secy->tx_sc;\n\n\tmutex_lock(&mbox->lock);\n\n\treq = otx2_mbox_alloc_msg_mcs_secy_plcy_write(mbox);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tif (sw_tx_sc->send_sci) {\n\t\tsectag_tci |= MCS_TCI_SC;\n\t} else {\n\t\tif (sw_tx_sc->end_station)\n\t\t\tsectag_tci |= MCS_TCI_ES;\n\t\tif (sw_tx_sc->scb)\n\t\t\tsectag_tci |= MCS_TCI_SCB;\n\t}\n\n\tif (sw_tx_sc->encrypt)\n\t\tsectag_tci |= (MCS_TCI_E | MCS_TCI_C);\n\n\tpolicy = FIELD_PREP(MCS_TX_SECY_PLCY_MTU, secy->netdev->mtu);\n\t \n\tpolicy |= FIELD_PREP(MCS_TX_SECY_PLCY_ST_TCI, sectag_tci >> 2);\n\tpolicy |= FIELD_PREP(MCS_TX_SECY_PLCY_ST_OFFSET, tag_offset);\n\tpolicy |= MCS_TX_SECY_PLCY_INS_MODE;\n\tpolicy |= MCS_TX_SECY_PLCY_AUTH_ENA;\n\n\tswitch (secy->key_len) {\n\tcase 16:\n\t\tcipher = secy->xpn ? MCS_GCM_AES_XPN_128 : MCS_GCM_AES_128;\n\t\tbreak;\n\tcase 32:\n\t\tcipher = secy->xpn ? MCS_GCM_AES_XPN_256 : MCS_GCM_AES_256;\n\t\tbreak;\n\tdefault:\n\t\tcipher = MCS_GCM_AES_128;\n\t\tdev_warn(pfvf->dev, \"Unsupported key length\\n\");\n\t\tbreak;\n\t}\n\n\tpolicy |= FIELD_PREP(MCS_TX_SECY_PLCY_CIP, cipher);\n\n\tif (secy->protect_frames)\n\t\tpolicy |= MCS_TX_SECY_PLCY_PROTECT;\n\n\t \n\tif (!secy->protect_frames || secy->operational)\n\t\tpolicy |= MCS_TX_SECY_PLCY_ENA;\n\n\treq->plcy = policy;\n\treq->secy_id = txsc->hw_secy_id_tx;\n\treq->dir = MCS_TX;\n\n\tret = otx2_sync_mbox_msg(mbox);\n\nfail:\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic int cn10k_mcs_write_tx_flowid(struct otx2_nic *pfvf,\n\t\t\t\t     struct macsec_secy *secy,\n\t\t\t\t     struct cn10k_mcs_txsc *txsc)\n{\n\tstruct mcs_flowid_entry_write_req *req;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tu64 mac_sa;\n\tint ret;\n\n\tmutex_lock(&mbox->lock);\n\n\treq = otx2_mbox_alloc_msg_mcs_flowid_entry_write(mbox);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tmac_sa = ether_addr_to_u64(secy->netdev->dev_addr);\n\n\treq->data[0] = FIELD_PREP(MCS_TCAM0_MAC_SA_MASK, mac_sa);\n\treq->data[1] = FIELD_PREP(MCS_TCAM1_MAC_SA_MASK, mac_sa >> 16);\n\n\treq->mask[0] = ~0ULL;\n\treq->mask[0] &= ~MCS_TCAM0_MAC_SA_MASK;\n\n\treq->mask[1] = ~0ULL;\n\treq->mask[1] &= ~MCS_TCAM1_MAC_SA_MASK;\n\n\treq->mask[2] = ~0ULL;\n\treq->mask[3] = ~0ULL;\n\n\treq->flow_id = txsc->hw_flow_id;\n\treq->secy_id = txsc->hw_secy_id_tx;\n\treq->sc_id = txsc->hw_sc_id;\n\treq->sci = (__force u64)cpu_to_be64((__force u64)secy->sci);\n\treq->dir = MCS_TX;\n\t \n\treq->ena = 1;\n\n\tret = otx2_sync_mbox_msg(mbox);\n\nfail:\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic int cn10k_mcs_link_tx_sa2sc(struct otx2_nic *pfvf,\n\t\t\t\t   struct macsec_secy *secy,\n\t\t\t\t   struct cn10k_mcs_txsc *txsc,\n\t\t\t\t   u8 sa_num, bool sa_active)\n{\n\tstruct mcs_tx_sc_sa_map *map_req;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tint ret;\n\n\t \n\tif (txsc->encoding_sa != sa_num)\n\t\treturn 0;\n\n\tmutex_lock(&mbox->lock);\n\n\tmap_req = otx2_mbox_alloc_msg_mcs_tx_sc_sa_map_write(mbox);\n\tif (!map_req) {\n\t\totx2_mbox_reset(&mbox->mbox, 0);\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tmap_req->sa_index0 = txsc->hw_sa_id[sa_num];\n\tmap_req->sa_index0_vld = sa_active;\n\tmap_req->sectag_sci = (__force u64)cpu_to_be64((__force u64)secy->sci);\n\tmap_req->sc_id = txsc->hw_sc_id;\n\n\tret = otx2_sync_mbox_msg(mbox);\n\nfail:\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic int cn10k_mcs_write_tx_sa_plcy(struct otx2_nic *pfvf,\n\t\t\t\t      struct macsec_secy *secy,\n\t\t\t\t      struct cn10k_mcs_txsc *txsc,\n\t\t\t\t      u8 assoc_num)\n{\n\tstruct mcs_sa_plcy_write_req *plcy_req;\n\tu8 *sak = txsc->sa_key[assoc_num];\n\tu8 *salt = txsc->salt[assoc_num];\n\tstruct mbox *mbox = &pfvf->mbox;\n\tint ret;\n\n\tmutex_lock(&mbox->lock);\n\n\tplcy_req = otx2_mbox_alloc_msg_mcs_sa_plcy_write(mbox);\n\tif (!plcy_req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tret = cn10k_mcs_write_keys(pfvf, secy, plcy_req, sak,\n\t\t\t\t   salt, txsc->ssci[assoc_num]);\n\tif (ret)\n\t\tgoto fail;\n\n\tplcy_req->plcy[0][8] = assoc_num;\n\tplcy_req->sa_index[0] = txsc->hw_sa_id[assoc_num];\n\tplcy_req->sa_cnt = 1;\n\tplcy_req->dir = MCS_TX;\n\n\tret = otx2_sync_mbox_msg(mbox);\n\nfail:\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic int cn10k_write_tx_sa_pn(struct otx2_nic *pfvf,\n\t\t\t\tstruct cn10k_mcs_txsc *txsc,\n\t\t\t\tu8 assoc_num, u64 next_pn)\n{\n\tstruct mcs_pn_table_write_req *req;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tint ret;\n\n\tmutex_lock(&mbox->lock);\n\n\treq = otx2_mbox_alloc_msg_mcs_pn_table_write(mbox);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\treq->pn_id = txsc->hw_sa_id[assoc_num];\n\treq->next_pn = next_pn;\n\treq->dir = MCS_TX;\n\n\tret = otx2_sync_mbox_msg(mbox);\n\nfail:\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic int cn10k_mcs_ena_dis_flowid(struct otx2_nic *pfvf, u16 hw_flow_id,\n\t\t\t\t    bool enable, enum mcs_direction dir)\n{\n\tstruct mcs_flowid_ena_dis_entry *req;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tint ret;\n\n\tmutex_lock(&mbox->lock);\n\n\treq = otx2_mbox_alloc_msg_mcs_flowid_ena_entry(mbox);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\treq->flow_id = hw_flow_id;\n\treq->ena = enable;\n\treq->dir = dir;\n\n\tret = otx2_sync_mbox_msg(mbox);\n\nfail:\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic int cn10k_mcs_sa_stats(struct otx2_nic *pfvf, u8 hw_sa_id,\n\t\t\t      struct mcs_sa_stats *rsp_p,\n\t\t\t      enum mcs_direction dir, bool clear)\n{\n\tstruct mcs_clear_stats *clear_req;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tstruct mcs_stats_req *req;\n\tstruct mcs_sa_stats *rsp;\n\tint ret;\n\n\tmutex_lock(&mbox->lock);\n\n\treq = otx2_mbox_alloc_msg_mcs_get_sa_stats(mbox);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\treq->id = hw_sa_id;\n\treq->dir = dir;\n\n\tif (!clear)\n\t\tgoto send_msg;\n\n\tclear_req = otx2_mbox_alloc_msg_mcs_clear_stats(mbox);\n\tif (!clear_req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tclear_req->id = hw_sa_id;\n\tclear_req->dir = dir;\n\tclear_req->type = MCS_RSRC_TYPE_SA;\n\nsend_msg:\n\tret = otx2_sync_mbox_msg(mbox);\n\tif (ret)\n\t\tgoto fail;\n\n\trsp = (struct mcs_sa_stats *)otx2_mbox_get_rsp(&pfvf->mbox.mbox,\n\t\t\t\t\t\t       0, &req->hdr);\n\tif (IS_ERR(rsp)) {\n\t\tret = PTR_ERR(rsp);\n\t\tgoto fail;\n\t}\n\n\tmemcpy(rsp_p, rsp, sizeof(*rsp_p));\n\n\tmutex_unlock(&mbox->lock);\n\n\treturn 0;\nfail:\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic int cn10k_mcs_sc_stats(struct otx2_nic *pfvf, u8 hw_sc_id,\n\t\t\t      struct mcs_sc_stats *rsp_p,\n\t\t\t      enum mcs_direction dir, bool clear)\n{\n\tstruct mcs_clear_stats *clear_req;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tstruct mcs_stats_req *req;\n\tstruct mcs_sc_stats *rsp;\n\tint ret;\n\n\tmutex_lock(&mbox->lock);\n\n\treq = otx2_mbox_alloc_msg_mcs_get_sc_stats(mbox);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\treq->id = hw_sc_id;\n\treq->dir = dir;\n\n\tif (!clear)\n\t\tgoto send_msg;\n\n\tclear_req = otx2_mbox_alloc_msg_mcs_clear_stats(mbox);\n\tif (!clear_req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tclear_req->id = hw_sc_id;\n\tclear_req->dir = dir;\n\tclear_req->type = MCS_RSRC_TYPE_SC;\n\nsend_msg:\n\tret = otx2_sync_mbox_msg(mbox);\n\tif (ret)\n\t\tgoto fail;\n\n\trsp = (struct mcs_sc_stats *)otx2_mbox_get_rsp(&pfvf->mbox.mbox,\n\t\t\t\t\t\t       0, &req->hdr);\n\tif (IS_ERR(rsp)) {\n\t\tret = PTR_ERR(rsp);\n\t\tgoto fail;\n\t}\n\n\tmemcpy(rsp_p, rsp, sizeof(*rsp_p));\n\n\tmutex_unlock(&mbox->lock);\n\n\treturn 0;\nfail:\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic int cn10k_mcs_secy_stats(struct otx2_nic *pfvf, u8 hw_secy_id,\n\t\t\t\tstruct mcs_secy_stats *rsp_p,\n\t\t\t\tenum mcs_direction dir, bool clear)\n{\n\tstruct mcs_clear_stats *clear_req;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tstruct mcs_secy_stats *rsp;\n\tstruct mcs_stats_req *req;\n\tint ret;\n\n\tmutex_lock(&mbox->lock);\n\n\treq = otx2_mbox_alloc_msg_mcs_get_secy_stats(mbox);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\treq->id = hw_secy_id;\n\treq->dir = dir;\n\n\tif (!clear)\n\t\tgoto send_msg;\n\n\tclear_req = otx2_mbox_alloc_msg_mcs_clear_stats(mbox);\n\tif (!clear_req) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tclear_req->id = hw_secy_id;\n\tclear_req->dir = dir;\n\tclear_req->type = MCS_RSRC_TYPE_SECY;\n\nsend_msg:\n\tret = otx2_sync_mbox_msg(mbox);\n\tif (ret)\n\t\tgoto fail;\n\n\trsp = (struct mcs_secy_stats *)otx2_mbox_get_rsp(&pfvf->mbox.mbox,\n\t\t\t\t\t\t\t 0, &req->hdr);\n\tif (IS_ERR(rsp)) {\n\t\tret = PTR_ERR(rsp);\n\t\tgoto fail;\n\t}\n\n\tmemcpy(rsp_p, rsp, sizeof(*rsp_p));\n\n\tmutex_unlock(&mbox->lock);\n\n\treturn 0;\nfail:\n\tmutex_unlock(&mbox->lock);\n\treturn ret;\n}\n\nstatic struct cn10k_mcs_txsc *cn10k_mcs_create_txsc(struct otx2_nic *pfvf)\n{\n\tstruct cn10k_mcs_txsc *txsc;\n\tint ret;\n\n\ttxsc = kzalloc(sizeof(*txsc), GFP_KERNEL);\n\tif (!txsc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = cn10k_mcs_alloc_rsrc(pfvf, MCS_TX, MCS_RSRC_TYPE_FLOWID,\n\t\t\t\t   &txsc->hw_flow_id);\n\tif (ret)\n\t\tgoto fail;\n\n\t \n\tret = cn10k_mcs_alloc_rsrc(pfvf, MCS_TX, MCS_RSRC_TYPE_SECY,\n\t\t\t\t   &txsc->hw_secy_id_tx);\n\tif (ret)\n\t\tgoto free_flowid;\n\n\tret = cn10k_mcs_alloc_rsrc(pfvf, MCS_RX, MCS_RSRC_TYPE_SECY,\n\t\t\t\t   &txsc->hw_secy_id_rx);\n\tif (ret)\n\t\tgoto free_tx_secy;\n\n\tret = cn10k_mcs_alloc_rsrc(pfvf, MCS_TX, MCS_RSRC_TYPE_SC,\n\t\t\t\t   &txsc->hw_sc_id);\n\tif (ret)\n\t\tgoto free_rx_secy;\n\n\treturn txsc;\nfree_rx_secy:\n\tcn10k_mcs_free_rsrc(pfvf, MCS_RX, MCS_RSRC_TYPE_SECY,\n\t\t\t    txsc->hw_secy_id_rx, false);\nfree_tx_secy:\n\tcn10k_mcs_free_rsrc(pfvf, MCS_TX, MCS_RSRC_TYPE_SECY,\n\t\t\t    txsc->hw_secy_id_tx, false);\nfree_flowid:\n\tcn10k_mcs_free_rsrc(pfvf, MCS_TX, MCS_RSRC_TYPE_FLOWID,\n\t\t\t    txsc->hw_flow_id, false);\nfail:\n\tkfree(txsc);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic void cn10k_mcs_delete_txsc(struct otx2_nic *pfvf,\n\t\t\t\t  struct cn10k_mcs_txsc *txsc)\n{\n\tu8 sa_bmap = txsc->sa_bmap;\n\tu8 sa_num = 0;\n\n\twhile (sa_bmap) {\n\t\tif (sa_bmap & 1) {\n\t\t\tcn10k_mcs_write_tx_sa_plcy(pfvf, txsc->sw_secy,\n\t\t\t\t\t\t   txsc, sa_num);\n\t\t\tcn10k_mcs_free_txsa(pfvf, txsc->hw_sa_id[sa_num]);\n\t\t}\n\t\tsa_num++;\n\t\tsa_bmap >>= 1;\n\t}\n\n\tcn10k_mcs_free_rsrc(pfvf, MCS_TX, MCS_RSRC_TYPE_SC,\n\t\t\t    txsc->hw_sc_id, false);\n\tcn10k_mcs_free_rsrc(pfvf, MCS_RX, MCS_RSRC_TYPE_SECY,\n\t\t\t    txsc->hw_secy_id_rx, false);\n\tcn10k_mcs_free_rsrc(pfvf, MCS_TX, MCS_RSRC_TYPE_SECY,\n\t\t\t    txsc->hw_secy_id_tx, false);\n\tcn10k_mcs_free_rsrc(pfvf, MCS_TX, MCS_RSRC_TYPE_FLOWID,\n\t\t\t    txsc->hw_flow_id, false);\n}\n\nstatic struct cn10k_mcs_rxsc *cn10k_mcs_create_rxsc(struct otx2_nic *pfvf)\n{\n\tstruct cn10k_mcs_rxsc *rxsc;\n\tint ret;\n\n\trxsc = kzalloc(sizeof(*rxsc), GFP_KERNEL);\n\tif (!rxsc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = cn10k_mcs_alloc_rsrc(pfvf, MCS_RX, MCS_RSRC_TYPE_FLOWID,\n\t\t\t\t   &rxsc->hw_flow_id);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = cn10k_mcs_alloc_rsrc(pfvf, MCS_RX, MCS_RSRC_TYPE_SC,\n\t\t\t\t   &rxsc->hw_sc_id);\n\tif (ret)\n\t\tgoto free_flowid;\n\n\treturn rxsc;\nfree_flowid:\n\tcn10k_mcs_free_rsrc(pfvf, MCS_RX, MCS_RSRC_TYPE_FLOWID,\n\t\t\t    rxsc->hw_flow_id, false);\nfail:\n\tkfree(rxsc);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic void cn10k_mcs_delete_rxsc(struct otx2_nic *pfvf,\n\t\t\t\t  struct cn10k_mcs_rxsc *rxsc)\n{\n\tu8 sa_bmap = rxsc->sa_bmap;\n\tu8 sa_num = 0;\n\n\twhile (sa_bmap) {\n\t\tif (sa_bmap & 1) {\n\t\t\tcn10k_mcs_write_rx_sa_plcy(pfvf, rxsc->sw_secy, rxsc,\n\t\t\t\t\t\t   sa_num, false);\n\t\t\tcn10k_mcs_free_rxsa(pfvf, rxsc->hw_sa_id[sa_num]);\n\t\t}\n\t\tsa_num++;\n\t\tsa_bmap >>= 1;\n\t}\n\n\tcn10k_mcs_free_rsrc(pfvf, MCS_RX, MCS_RSRC_TYPE_SC,\n\t\t\t    rxsc->hw_sc_id, false);\n\tcn10k_mcs_free_rsrc(pfvf, MCS_RX, MCS_RSRC_TYPE_FLOWID,\n\t\t\t    rxsc->hw_flow_id, false);\n}\n\nstatic int cn10k_mcs_secy_tx_cfg(struct otx2_nic *pfvf, struct macsec_secy *secy,\n\t\t\t\t struct cn10k_mcs_txsc *txsc,\n\t\t\t\t struct macsec_tx_sa *sw_tx_sa, u8 sa_num)\n{\n\tif (sw_tx_sa) {\n\t\tcn10k_mcs_write_tx_sa_plcy(pfvf, secy, txsc, sa_num);\n\t\tcn10k_write_tx_sa_pn(pfvf, txsc, sa_num, sw_tx_sa->next_pn);\n\t\tcn10k_mcs_link_tx_sa2sc(pfvf, secy, txsc, sa_num,\n\t\t\t\t\tsw_tx_sa->active);\n\t}\n\n\tcn10k_mcs_write_tx_secy(pfvf, secy, txsc);\n\tcn10k_mcs_write_tx_flowid(pfvf, secy, txsc);\n\t \n\tcn10k_mcs_write_rx_secy(pfvf, secy, txsc->hw_secy_id_rx);\n\n\treturn 0;\n}\n\nstatic int cn10k_mcs_secy_rx_cfg(struct otx2_nic *pfvf,\n\t\t\t\t struct macsec_secy *secy, u8 hw_secy_id)\n{\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct cn10k_mcs_rxsc *mcs_rx_sc;\n\tstruct macsec_rx_sc *sw_rx_sc;\n\tstruct macsec_rx_sa *sw_rx_sa;\n\tu8 sa_num;\n\n\tfor (sw_rx_sc = rcu_dereference_bh(secy->rx_sc); sw_rx_sc && sw_rx_sc->active;\n\t     sw_rx_sc = rcu_dereference_bh(sw_rx_sc->next)) {\n\t\tmcs_rx_sc = cn10k_mcs_get_rxsc(cfg, secy, sw_rx_sc);\n\t\tif (unlikely(!mcs_rx_sc))\n\t\t\tcontinue;\n\n\t\tfor (sa_num = 0; sa_num < CN10K_MCS_SA_PER_SC; sa_num++) {\n\t\t\tsw_rx_sa = rcu_dereference_bh(sw_rx_sc->sa[sa_num]);\n\t\t\tif (!sw_rx_sa)\n\t\t\t\tcontinue;\n\n\t\t\tcn10k_mcs_write_rx_sa_plcy(pfvf, secy, mcs_rx_sc,\n\t\t\t\t\t\t   sa_num, sw_rx_sa->active);\n\t\t\tcn10k_mcs_write_rx_sa_pn(pfvf, mcs_rx_sc, sa_num,\n\t\t\t\t\t\t sw_rx_sa->next_pn);\n\t\t}\n\n\t\tcn10k_mcs_write_rx_flowid(pfvf, mcs_rx_sc, hw_secy_id);\n\t\tcn10k_mcs_write_sc_cam(pfvf, mcs_rx_sc, hw_secy_id);\n\t}\n\n\treturn 0;\n}\n\nstatic int cn10k_mcs_disable_rxscs(struct otx2_nic *pfvf,\n\t\t\t\t   struct macsec_secy *secy,\n\t\t\t\t   bool delete)\n{\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct cn10k_mcs_rxsc *mcs_rx_sc;\n\tstruct macsec_rx_sc *sw_rx_sc;\n\tint ret;\n\n\tfor (sw_rx_sc = rcu_dereference_bh(secy->rx_sc); sw_rx_sc && sw_rx_sc->active;\n\t     sw_rx_sc = rcu_dereference_bh(sw_rx_sc->next)) {\n\t\tmcs_rx_sc = cn10k_mcs_get_rxsc(cfg, secy, sw_rx_sc);\n\t\tif (unlikely(!mcs_rx_sc))\n\t\t\tcontinue;\n\n\t\tret = cn10k_mcs_ena_dis_flowid(pfvf, mcs_rx_sc->hw_flow_id,\n\t\t\t\t\t       false, MCS_RX);\n\t\tif (ret)\n\t\t\tdev_err(pfvf->dev, \"Failed to disable TCAM for SC %d\\n\",\n\t\t\t\tmcs_rx_sc->hw_sc_id);\n\t\tif (delete) {\n\t\t\tcn10k_mcs_delete_rxsc(pfvf, mcs_rx_sc);\n\t\t\tlist_del(&mcs_rx_sc->entry);\n\t\t\tkfree(mcs_rx_sc);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void cn10k_mcs_sync_stats(struct otx2_nic *pfvf, struct macsec_secy *secy,\n\t\t\t\t struct cn10k_mcs_txsc *txsc)\n{\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct mcs_secy_stats rx_rsp = { 0 };\n\tstruct mcs_sc_stats sc_rsp = { 0 };\n\tstruct cn10k_mcs_rxsc *rxsc;\n\n\t \n\n\t \n\tif (secy->validate_frames == txsc->last_validate_frames &&\n\t    secy->replay_protect == txsc->last_replay_protect)\n\t\treturn;\n\n\tcn10k_mcs_secy_stats(pfvf, txsc->hw_secy_id_rx, &rx_rsp, MCS_RX, true);\n\n\ttxsc->stats.InPktsBadTag += rx_rsp.pkt_badtag_cnt;\n\ttxsc->stats.InPktsUnknownSCI += rx_rsp.pkt_nosa_cnt;\n\ttxsc->stats.InPktsNoSCI += rx_rsp.pkt_nosaerror_cnt;\n\tif (txsc->last_validate_frames == MACSEC_VALIDATE_STRICT)\n\t\ttxsc->stats.InPktsNoTag += rx_rsp.pkt_untaged_cnt;\n\telse\n\t\ttxsc->stats.InPktsUntagged += rx_rsp.pkt_untaged_cnt;\n\n\tlist_for_each_entry(rxsc, &cfg->rxsc_list, entry) {\n\t\tcn10k_mcs_sc_stats(pfvf, rxsc->hw_sc_id, &sc_rsp, MCS_RX, true);\n\n\t\trxsc->stats.InOctetsValidated += sc_rsp.octet_validate_cnt;\n\t\trxsc->stats.InOctetsDecrypted += sc_rsp.octet_decrypt_cnt;\n\n\t\trxsc->stats.InPktsInvalid += sc_rsp.pkt_invalid_cnt;\n\t\trxsc->stats.InPktsNotValid += sc_rsp.pkt_notvalid_cnt;\n\n\t\tif (txsc->last_replay_protect)\n\t\t\trxsc->stats.InPktsLate += sc_rsp.pkt_late_cnt;\n\t\telse\n\t\t\trxsc->stats.InPktsDelayed += sc_rsp.pkt_late_cnt;\n\n\t\tif (txsc->last_validate_frames == MACSEC_VALIDATE_DISABLED)\n\t\t\trxsc->stats.InPktsUnchecked += sc_rsp.pkt_unchecked_cnt;\n\t\telse\n\t\t\trxsc->stats.InPktsOK += sc_rsp.pkt_unchecked_cnt;\n\t}\n\n\ttxsc->last_validate_frames = secy->validate_frames;\n\ttxsc->last_replay_protect = secy->replay_protect;\n}\n\nstatic int cn10k_mdo_open(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct macsec_secy *secy = ctx->secy;\n\tstruct macsec_tx_sa *sw_tx_sa;\n\tstruct cn10k_mcs_txsc *txsc;\n\tu8 sa_num;\n\tint err;\n\n\ttxsc = cn10k_mcs_get_txsc(cfg, ctx->secy);\n\tif (!txsc)\n\t\treturn -ENOENT;\n\n\tsa_num = txsc->encoding_sa;\n\tsw_tx_sa = rcu_dereference_bh(secy->tx_sc.sa[sa_num]);\n\n\terr = cn10k_mcs_secy_tx_cfg(pfvf, secy, txsc, sw_tx_sa, sa_num);\n\tif (err)\n\t\treturn err;\n\n\treturn cn10k_mcs_secy_rx_cfg(pfvf, secy, txsc->hw_secy_id_rx);\n}\n\nstatic int cn10k_mdo_stop(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct cn10k_mcs_txsc *txsc;\n\tint err;\n\n\ttxsc = cn10k_mcs_get_txsc(cfg, ctx->secy);\n\tif (!txsc)\n\t\treturn -ENOENT;\n\n\terr = cn10k_mcs_ena_dis_flowid(pfvf, txsc->hw_flow_id, false, MCS_TX);\n\tif (err)\n\t\treturn err;\n\n\treturn cn10k_mcs_disable_rxscs(pfvf, ctx->secy, false);\n}\n\nstatic int cn10k_mdo_add_secy(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct macsec_secy *secy = ctx->secy;\n\tstruct cn10k_mcs_txsc *txsc;\n\n\tif (secy->icv_len != MACSEC_DEFAULT_ICV_LEN)\n\t\treturn -EOPNOTSUPP;\n\n\ttxsc = cn10k_mcs_create_txsc(pfvf);\n\tif (IS_ERR(txsc))\n\t\treturn -ENOSPC;\n\n\ttxsc->sw_secy = secy;\n\ttxsc->encoding_sa = secy->tx_sc.encoding_sa;\n\ttxsc->last_validate_frames = secy->validate_frames;\n\ttxsc->last_replay_protect = secy->replay_protect;\n\ttxsc->vlan_dev = is_vlan_dev(ctx->netdev);\n\n\tlist_add(&txsc->entry, &cfg->txsc_list);\n\n\tif (netif_running(secy->netdev))\n\t\treturn cn10k_mcs_secy_tx_cfg(pfvf, secy, txsc, NULL, 0);\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_upd_secy(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct macsec_secy *secy = ctx->secy;\n\tstruct macsec_tx_sa *sw_tx_sa;\n\tstruct cn10k_mcs_txsc *txsc;\n\tbool active;\n\tu8 sa_num;\n\tint err;\n\n\ttxsc = cn10k_mcs_get_txsc(cfg, secy);\n\tif (!txsc)\n\t\treturn -ENOENT;\n\n\t \n\tif (txsc->encoding_sa != secy->tx_sc.encoding_sa) {\n\t\ttxsc->encoding_sa = secy->tx_sc.encoding_sa;\n\t\tsa_num = txsc->encoding_sa;\n\t\tsw_tx_sa = rcu_dereference_bh(secy->tx_sc.sa[sa_num]);\n\t\tactive = sw_tx_sa ? sw_tx_sa->active : false;\n\t\tcn10k_mcs_link_tx_sa2sc(pfvf, secy, txsc, sa_num, active);\n\t}\n\n\tif (netif_running(secy->netdev)) {\n\t\tcn10k_mcs_sync_stats(pfvf, secy, txsc);\n\n\t\terr = cn10k_mcs_secy_tx_cfg(pfvf, secy, txsc, NULL, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_del_secy(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct cn10k_mcs_txsc *txsc;\n\n\ttxsc = cn10k_mcs_get_txsc(cfg, ctx->secy);\n\tif (!txsc)\n\t\treturn -ENOENT;\n\n\tcn10k_mcs_ena_dis_flowid(pfvf, txsc->hw_flow_id, false, MCS_TX);\n\tcn10k_mcs_disable_rxscs(pfvf, ctx->secy, true);\n\tcn10k_mcs_delete_txsc(pfvf, txsc);\n\tlist_del(&txsc->entry);\n\tkfree(txsc);\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_add_txsa(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct macsec_tx_sa *sw_tx_sa = ctx->sa.tx_sa;\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct macsec_secy *secy = ctx->secy;\n\tu8 sa_num = ctx->sa.assoc_num;\n\tstruct cn10k_mcs_txsc *txsc;\n\tint err;\n\n\ttxsc = cn10k_mcs_get_txsc(cfg, secy);\n\tif (!txsc)\n\t\treturn -ENOENT;\n\n\tif (sa_num >= CN10K_MCS_SA_PER_SC)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cn10k_mcs_alloc_txsa(pfvf, &txsc->hw_sa_id[sa_num]))\n\t\treturn -ENOSPC;\n\n\tmemcpy(&txsc->sa_key[sa_num], ctx->sa.key, secy->key_len);\n\tmemcpy(&txsc->salt[sa_num], sw_tx_sa->key.salt.bytes, MACSEC_SALT_LEN);\n\ttxsc->ssci[sa_num] = sw_tx_sa->ssci;\n\n\ttxsc->sa_bmap |= 1 << sa_num;\n\n\tif (netif_running(secy->netdev)) {\n\t\terr = cn10k_mcs_write_tx_sa_plcy(pfvf, secy, txsc, sa_num);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = cn10k_write_tx_sa_pn(pfvf, txsc, sa_num,\n\t\t\t\t\t   sw_tx_sa->next_pn);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = cn10k_mcs_link_tx_sa2sc(pfvf, secy, txsc,\n\t\t\t\t\t      sa_num, sw_tx_sa->active);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_upd_txsa(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct macsec_tx_sa *sw_tx_sa = ctx->sa.tx_sa;\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct macsec_secy *secy = ctx->secy;\n\tu8 sa_num = ctx->sa.assoc_num;\n\tstruct cn10k_mcs_txsc *txsc;\n\tint err;\n\n\ttxsc = cn10k_mcs_get_txsc(cfg, secy);\n\tif (!txsc)\n\t\treturn -ENOENT;\n\n\tif (sa_num >= CN10K_MCS_SA_PER_SC)\n\t\treturn -EOPNOTSUPP;\n\n\tif (netif_running(secy->netdev)) {\n\t\t \n\t\tif (ctx->sa.update_pn) {\n\t\t\terr = cn10k_write_tx_sa_pn(pfvf, txsc, sa_num,\n\t\t\t\t\t\t   sw_tx_sa->next_pn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\terr = cn10k_mcs_link_tx_sa2sc(pfvf, secy, txsc,\n\t\t\t\t\t      sa_num, sw_tx_sa->active);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_del_txsa(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tu8 sa_num = ctx->sa.assoc_num;\n\tstruct cn10k_mcs_txsc *txsc;\n\n\ttxsc = cn10k_mcs_get_txsc(cfg, ctx->secy);\n\tif (!txsc)\n\t\treturn -ENOENT;\n\n\tif (sa_num >= CN10K_MCS_SA_PER_SC)\n\t\treturn -EOPNOTSUPP;\n\n\tcn10k_mcs_free_txsa(pfvf, txsc->hw_sa_id[sa_num]);\n\ttxsc->sa_bmap &= ~(1 << sa_num);\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_add_rxsc(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct macsec_secy *secy = ctx->secy;\n\tstruct cn10k_mcs_rxsc *rxsc;\n\tstruct cn10k_mcs_txsc *txsc;\n\tint err;\n\n\ttxsc = cn10k_mcs_get_txsc(cfg, secy);\n\tif (!txsc)\n\t\treturn -ENOENT;\n\n\trxsc = cn10k_mcs_create_rxsc(pfvf);\n\tif (IS_ERR(rxsc))\n\t\treturn -ENOSPC;\n\n\trxsc->sw_secy = ctx->secy;\n\trxsc->sw_rxsc = ctx->rx_sc;\n\tlist_add(&rxsc->entry, &cfg->rxsc_list);\n\n\tif (netif_running(secy->netdev)) {\n\t\terr = cn10k_mcs_write_rx_flowid(pfvf, rxsc, txsc->hw_secy_id_rx);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = cn10k_mcs_write_sc_cam(pfvf, rxsc, txsc->hw_secy_id_rx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_upd_rxsc(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct macsec_secy *secy = ctx->secy;\n\tbool enable = ctx->rx_sc->active;\n\tstruct cn10k_mcs_rxsc *rxsc;\n\n\trxsc = cn10k_mcs_get_rxsc(cfg, secy, ctx->rx_sc);\n\tif (!rxsc)\n\t\treturn -ENOENT;\n\n\tif (netif_running(secy->netdev))\n\t\treturn cn10k_mcs_ena_dis_flowid(pfvf, rxsc->hw_flow_id,\n\t\t\t\t\t\tenable, MCS_RX);\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_del_rxsc(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct cn10k_mcs_rxsc *rxsc;\n\n\trxsc = cn10k_mcs_get_rxsc(cfg, ctx->secy, ctx->rx_sc);\n\tif (!rxsc)\n\t\treturn -ENOENT;\n\n\tcn10k_mcs_ena_dis_flowid(pfvf, rxsc->hw_flow_id, false, MCS_RX);\n\tcn10k_mcs_delete_rxsc(pfvf, rxsc);\n\tlist_del(&rxsc->entry);\n\tkfree(rxsc);\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_add_rxsa(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct macsec_rx_sc *sw_rx_sc = ctx->sa.rx_sa->sc;\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct macsec_rx_sa *rx_sa = ctx->sa.rx_sa;\n\tstruct macsec_secy *secy = ctx->secy;\n\tbool sa_in_use = rx_sa->active;\n\tu8 sa_num = ctx->sa.assoc_num;\n\tstruct cn10k_mcs_rxsc *rxsc;\n\tint err;\n\n\trxsc = cn10k_mcs_get_rxsc(cfg, secy, sw_rx_sc);\n\tif (!rxsc)\n\t\treturn -ENOENT;\n\n\tif (sa_num >= CN10K_MCS_SA_PER_SC)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cn10k_mcs_alloc_rxsa(pfvf, &rxsc->hw_sa_id[sa_num]))\n\t\treturn -ENOSPC;\n\n\tmemcpy(&rxsc->sa_key[sa_num], ctx->sa.key, ctx->secy->key_len);\n\tmemcpy(&rxsc->salt[sa_num], rx_sa->key.salt.bytes, MACSEC_SALT_LEN);\n\trxsc->ssci[sa_num] = rx_sa->ssci;\n\n\trxsc->sa_bmap |= 1 << sa_num;\n\n\tif (netif_running(secy->netdev)) {\n\t\terr = cn10k_mcs_write_rx_sa_plcy(pfvf, secy, rxsc,\n\t\t\t\t\t\t sa_num, sa_in_use);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = cn10k_mcs_write_rx_sa_pn(pfvf, rxsc, sa_num,\n\t\t\t\t\t       rx_sa->next_pn);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_upd_rxsa(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct macsec_rx_sc *sw_rx_sc = ctx->sa.rx_sa->sc;\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct macsec_rx_sa *rx_sa = ctx->sa.rx_sa;\n\tstruct macsec_secy *secy = ctx->secy;\n\tbool sa_in_use = rx_sa->active;\n\tu8 sa_num = ctx->sa.assoc_num;\n\tstruct cn10k_mcs_rxsc *rxsc;\n\tint err;\n\n\trxsc = cn10k_mcs_get_rxsc(cfg, secy, sw_rx_sc);\n\tif (!rxsc)\n\t\treturn -ENOENT;\n\n\tif (sa_num >= CN10K_MCS_SA_PER_SC)\n\t\treturn -EOPNOTSUPP;\n\n\tif (netif_running(secy->netdev)) {\n\t\terr = cn10k_mcs_write_rx_sa_plcy(pfvf, secy, rxsc, sa_num, sa_in_use);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!ctx->sa.update_pn)\n\t\t\treturn 0;\n\n\t\terr = cn10k_mcs_write_rx_sa_pn(pfvf, rxsc, sa_num,\n\t\t\t\t\t       rx_sa->next_pn);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_del_rxsa(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct macsec_rx_sc *sw_rx_sc = ctx->sa.rx_sa->sc;\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tu8 sa_num = ctx->sa.assoc_num;\n\tstruct cn10k_mcs_rxsc *rxsc;\n\n\trxsc = cn10k_mcs_get_rxsc(cfg, ctx->secy, sw_rx_sc);\n\tif (!rxsc)\n\t\treturn -ENOENT;\n\n\tif (sa_num >= CN10K_MCS_SA_PER_SC)\n\t\treturn -EOPNOTSUPP;\n\n\tcn10k_mcs_write_rx_sa_plcy(pfvf, ctx->secy, rxsc, sa_num, false);\n\tcn10k_mcs_free_rxsa(pfvf, rxsc->hw_sa_id[sa_num]);\n\n\trxsc->sa_bmap &= ~(1 << sa_num);\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_get_dev_stats(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct mcs_secy_stats tx_rsp = { 0 }, rx_rsp = { 0 };\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct macsec_secy *secy = ctx->secy;\n\tstruct cn10k_mcs_txsc *txsc;\n\n\ttxsc = cn10k_mcs_get_txsc(cfg, ctx->secy);\n\tif (!txsc)\n\t\treturn -ENOENT;\n\n\tcn10k_mcs_secy_stats(pfvf, txsc->hw_secy_id_tx, &tx_rsp, MCS_TX, false);\n\tctx->stats.dev_stats->OutPktsUntagged = tx_rsp.pkt_untagged_cnt;\n\tctx->stats.dev_stats->OutPktsTooLong = tx_rsp.pkt_toolong_cnt;\n\n\tcn10k_mcs_secy_stats(pfvf, txsc->hw_secy_id_rx, &rx_rsp, MCS_RX, true);\n\ttxsc->stats.InPktsBadTag += rx_rsp.pkt_badtag_cnt;\n\ttxsc->stats.InPktsUnknownSCI += rx_rsp.pkt_nosa_cnt;\n\ttxsc->stats.InPktsNoSCI += rx_rsp.pkt_nosaerror_cnt;\n\tif (secy->validate_frames == MACSEC_VALIDATE_STRICT)\n\t\ttxsc->stats.InPktsNoTag += rx_rsp.pkt_untaged_cnt;\n\telse\n\t\ttxsc->stats.InPktsUntagged += rx_rsp.pkt_untaged_cnt;\n\ttxsc->stats.InPktsOverrun = 0;\n\n\tctx->stats.dev_stats->InPktsNoTag = txsc->stats.InPktsNoTag;\n\tctx->stats.dev_stats->InPktsUntagged = txsc->stats.InPktsUntagged;\n\tctx->stats.dev_stats->InPktsBadTag = txsc->stats.InPktsBadTag;\n\tctx->stats.dev_stats->InPktsUnknownSCI = txsc->stats.InPktsUnknownSCI;\n\tctx->stats.dev_stats->InPktsNoSCI = txsc->stats.InPktsNoSCI;\n\tctx->stats.dev_stats->InPktsOverrun = txsc->stats.InPktsOverrun;\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_get_tx_sc_stats(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct mcs_sc_stats rsp = { 0 };\n\tstruct cn10k_mcs_txsc *txsc;\n\n\ttxsc = cn10k_mcs_get_txsc(cfg, ctx->secy);\n\tif (!txsc)\n\t\treturn -ENOENT;\n\n\tcn10k_mcs_sc_stats(pfvf, txsc->hw_sc_id, &rsp, MCS_TX, false);\n\n\tctx->stats.tx_sc_stats->OutPktsProtected = rsp.pkt_protected_cnt;\n\tctx->stats.tx_sc_stats->OutPktsEncrypted = rsp.pkt_encrypt_cnt;\n\tctx->stats.tx_sc_stats->OutOctetsProtected = rsp.octet_protected_cnt;\n\tctx->stats.tx_sc_stats->OutOctetsEncrypted = rsp.octet_encrypt_cnt;\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_get_tx_sa_stats(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct mcs_sa_stats rsp = { 0 };\n\tu8 sa_num = ctx->sa.assoc_num;\n\tstruct cn10k_mcs_txsc *txsc;\n\n\ttxsc = cn10k_mcs_get_txsc(cfg, ctx->secy);\n\tif (!txsc)\n\t\treturn -ENOENT;\n\n\tif (sa_num >= CN10K_MCS_SA_PER_SC)\n\t\treturn -EOPNOTSUPP;\n\n\tcn10k_mcs_sa_stats(pfvf, txsc->hw_sa_id[sa_num], &rsp, MCS_TX, false);\n\n\tctx->stats.tx_sa_stats->OutPktsProtected = rsp.pkt_protected_cnt;\n\tctx->stats.tx_sa_stats->OutPktsEncrypted = rsp.pkt_encrypt_cnt;\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_get_rx_sc_stats(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct macsec_secy *secy = ctx->secy;\n\tstruct mcs_sc_stats rsp = { 0 };\n\tstruct cn10k_mcs_rxsc *rxsc;\n\n\trxsc = cn10k_mcs_get_rxsc(cfg, secy, ctx->rx_sc);\n\tif (!rxsc)\n\t\treturn -ENOENT;\n\n\tcn10k_mcs_sc_stats(pfvf, rxsc->hw_sc_id, &rsp, MCS_RX, true);\n\n\trxsc->stats.InOctetsValidated += rsp.octet_validate_cnt;\n\trxsc->stats.InOctetsDecrypted += rsp.octet_decrypt_cnt;\n\n\trxsc->stats.InPktsInvalid += rsp.pkt_invalid_cnt;\n\trxsc->stats.InPktsNotValid += rsp.pkt_notvalid_cnt;\n\n\tif (secy->replay_protect)\n\t\trxsc->stats.InPktsLate += rsp.pkt_late_cnt;\n\telse\n\t\trxsc->stats.InPktsDelayed += rsp.pkt_late_cnt;\n\n\tif (secy->validate_frames == MACSEC_VALIDATE_DISABLED)\n\t\trxsc->stats.InPktsUnchecked += rsp.pkt_unchecked_cnt;\n\telse\n\t\trxsc->stats.InPktsOK += rsp.pkt_unchecked_cnt;\n\n\tctx->stats.rx_sc_stats->InOctetsValidated = rxsc->stats.InOctetsValidated;\n\tctx->stats.rx_sc_stats->InOctetsDecrypted = rxsc->stats.InOctetsDecrypted;\n\tctx->stats.rx_sc_stats->InPktsInvalid = rxsc->stats.InPktsInvalid;\n\tctx->stats.rx_sc_stats->InPktsNotValid = rxsc->stats.InPktsNotValid;\n\tctx->stats.rx_sc_stats->InPktsLate = rxsc->stats.InPktsLate;\n\tctx->stats.rx_sc_stats->InPktsDelayed = rxsc->stats.InPktsDelayed;\n\tctx->stats.rx_sc_stats->InPktsUnchecked = rxsc->stats.InPktsUnchecked;\n\tctx->stats.rx_sc_stats->InPktsOK = rxsc->stats.InPktsOK;\n\n\treturn 0;\n}\n\nstatic int cn10k_mdo_get_rx_sa_stats(struct macsec_context *ctx)\n{\n\tstruct otx2_nic *pfvf = macsec_netdev_priv(ctx->netdev);\n\tstruct macsec_rx_sc *sw_rx_sc = ctx->sa.rx_sa->sc;\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct mcs_sa_stats rsp = { 0 };\n\tu8 sa_num = ctx->sa.assoc_num;\n\tstruct cn10k_mcs_rxsc *rxsc;\n\n\trxsc = cn10k_mcs_get_rxsc(cfg, ctx->secy, sw_rx_sc);\n\tif (!rxsc)\n\t\treturn -ENOENT;\n\n\tif (sa_num >= CN10K_MCS_SA_PER_SC)\n\t\treturn -EOPNOTSUPP;\n\n\tcn10k_mcs_sa_stats(pfvf, rxsc->hw_sa_id[sa_num], &rsp, MCS_RX, false);\n\n\tctx->stats.rx_sa_stats->InPktsOK = rsp.pkt_ok_cnt;\n\tctx->stats.rx_sa_stats->InPktsInvalid = rsp.pkt_invalid_cnt;\n\tctx->stats.rx_sa_stats->InPktsNotValid = rsp.pkt_notvalid_cnt;\n\tctx->stats.rx_sa_stats->InPktsNotUsingSA = rsp.pkt_nosaerror_cnt;\n\tctx->stats.rx_sa_stats->InPktsUnusedSA = rsp.pkt_nosa_cnt;\n\n\treturn 0;\n}\n\nstatic const struct macsec_ops cn10k_mcs_ops = {\n\t.mdo_dev_open = cn10k_mdo_open,\n\t.mdo_dev_stop = cn10k_mdo_stop,\n\t.mdo_add_secy = cn10k_mdo_add_secy,\n\t.mdo_upd_secy = cn10k_mdo_upd_secy,\n\t.mdo_del_secy = cn10k_mdo_del_secy,\n\t.mdo_add_rxsc = cn10k_mdo_add_rxsc,\n\t.mdo_upd_rxsc = cn10k_mdo_upd_rxsc,\n\t.mdo_del_rxsc = cn10k_mdo_del_rxsc,\n\t.mdo_add_rxsa = cn10k_mdo_add_rxsa,\n\t.mdo_upd_rxsa = cn10k_mdo_upd_rxsa,\n\t.mdo_del_rxsa = cn10k_mdo_del_rxsa,\n\t.mdo_add_txsa = cn10k_mdo_add_txsa,\n\t.mdo_upd_txsa = cn10k_mdo_upd_txsa,\n\t.mdo_del_txsa = cn10k_mdo_del_txsa,\n\t.mdo_get_dev_stats = cn10k_mdo_get_dev_stats,\n\t.mdo_get_tx_sc_stats = cn10k_mdo_get_tx_sc_stats,\n\t.mdo_get_tx_sa_stats = cn10k_mdo_get_tx_sa_stats,\n\t.mdo_get_rx_sc_stats = cn10k_mdo_get_rx_sc_stats,\n\t.mdo_get_rx_sa_stats = cn10k_mdo_get_rx_sa_stats,\n};\n\nvoid cn10k_handle_mcs_event(struct otx2_nic *pfvf, struct mcs_intr_info *event)\n{\n\tstruct cn10k_mcs_cfg *cfg = pfvf->macsec_cfg;\n\tstruct macsec_tx_sa *sw_tx_sa = NULL;\n\tstruct macsec_secy *secy = NULL;\n\tstruct cn10k_mcs_txsc *txsc;\n\tu8 an;\n\n\tif (!test_bit(CN10K_HW_MACSEC, &pfvf->hw.cap_flag))\n\t\treturn;\n\n\tif (!(event->intr_mask & MCS_CPM_TX_PACKET_XPN_EQ0_INT))\n\t\treturn;\n\n\t \n\tlist_for_each_entry(txsc, &cfg->txsc_list, entry) {\n\t\tfor (an = 0; an < CN10K_MCS_SA_PER_SC; an++)\n\t\t\tif (txsc->hw_sa_id[an] == event->sa_id) {\n\t\t\t\tsecy = txsc->sw_secy;\n\t\t\t\tsw_tx_sa = rcu_dereference_bh(secy->tx_sc.sa[an]);\n\t\t\t}\n\t}\n\n\tif (secy && sw_tx_sa)\n\t\tmacsec_pn_wrapped(secy, sw_tx_sa);\n}\n\nint cn10k_mcs_init(struct otx2_nic *pfvf)\n{\n\tstruct mbox *mbox = &pfvf->mbox;\n\tstruct cn10k_mcs_cfg *cfg;\n\tstruct mcs_intr_cfg *req;\n\n\tif (!test_bit(CN10K_HW_MACSEC, &pfvf->hw.cap_flag))\n\t\treturn 0;\n\n\tcfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&cfg->txsc_list);\n\tINIT_LIST_HEAD(&cfg->rxsc_list);\n\tpfvf->macsec_cfg = cfg;\n\n\tpfvf->netdev->features |= NETIF_F_HW_MACSEC;\n\tpfvf->netdev->macsec_ops = &cn10k_mcs_ops;\n\n\tmutex_lock(&mbox->lock);\n\n\treq = otx2_mbox_alloc_msg_mcs_intr_cfg(mbox);\n\tif (!req)\n\t\tgoto fail;\n\n\treq->intr_mask = MCS_CPM_TX_PACKET_XPN_EQ0_INT;\n\n\tif (otx2_sync_mbox_msg(mbox))\n\t\tgoto fail;\n\n\tmutex_unlock(&mbox->lock);\n\n\treturn 0;\nfail:\n\tdev_err(pfvf->dev, \"Cannot notify PN wrapped event\\n\");\n\tmutex_unlock(&mbox->lock);\n\treturn 0;\n}\n\nvoid cn10k_mcs_free(struct otx2_nic *pfvf)\n{\n\tif (!test_bit(CN10K_HW_MACSEC, &pfvf->hw.cap_flag))\n\t\treturn;\n\n\tcn10k_mcs_free_rsrc(pfvf, MCS_TX, MCS_RSRC_TYPE_SECY, 0, true);\n\tcn10k_mcs_free_rsrc(pfvf, MCS_RX, MCS_RSRC_TYPE_SECY, 0, true);\n\tkfree(pfvf->macsec_cfg);\n\tpfvf->macsec_cfg = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}