{
  "module_name": "otx2_common.c",
  "hash_id": "40867b425ff9cf56cc3ba4b595a8e6fb5a2f685206cf6abe9e46b98afa5f3403",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <net/page_pool/helpers.h>\n#include <net/tso.h>\n#include <linux/bitfield.h>\n\n#include \"otx2_reg.h\"\n#include \"otx2_common.h\"\n#include \"otx2_struct.h\"\n#include \"cn10k.h\"\n\nstatic void otx2_nix_rq_op_stats(struct queue_stats *stats,\n\t\t\t\t struct otx2_nic *pfvf, int qidx)\n{\n\tu64 incr = (u64)qidx << 32;\n\tu64 *ptr;\n\n\tptr = (u64 *)otx2_get_regaddr(pfvf, NIX_LF_RQ_OP_OCTS);\n\tstats->bytes = otx2_atomic64_add(incr, ptr);\n\n\tptr = (u64 *)otx2_get_regaddr(pfvf, NIX_LF_RQ_OP_PKTS);\n\tstats->pkts = otx2_atomic64_add(incr, ptr);\n}\n\nstatic void otx2_nix_sq_op_stats(struct queue_stats *stats,\n\t\t\t\t struct otx2_nic *pfvf, int qidx)\n{\n\tu64 incr = (u64)qidx << 32;\n\tu64 *ptr;\n\n\tptr = (u64 *)otx2_get_regaddr(pfvf, NIX_LF_SQ_OP_OCTS);\n\tstats->bytes = otx2_atomic64_add(incr, ptr);\n\n\tptr = (u64 *)otx2_get_regaddr(pfvf, NIX_LF_SQ_OP_PKTS);\n\tstats->pkts = otx2_atomic64_add(incr, ptr);\n}\n\nvoid otx2_update_lmac_stats(struct otx2_nic *pfvf)\n{\n\tstruct msg_req *req;\n\n\tif (!netif_running(pfvf->netdev))\n\t\treturn;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_cgx_stats(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn;\n\t}\n\n\totx2_sync_mbox_msg(&pfvf->mbox);\n\tmutex_unlock(&pfvf->mbox.lock);\n}\n\nvoid otx2_update_lmac_fec_stats(struct otx2_nic *pfvf)\n{\n\tstruct msg_req *req;\n\n\tif (!netif_running(pfvf->netdev))\n\t\treturn;\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_cgx_fec_stats(&pfvf->mbox);\n\tif (req)\n\t\totx2_sync_mbox_msg(&pfvf->mbox);\n\tmutex_unlock(&pfvf->mbox.lock);\n}\n\nint otx2_update_rq_stats(struct otx2_nic *pfvf, int qidx)\n{\n\tstruct otx2_rcv_queue *rq = &pfvf->qset.rq[qidx];\n\n\tif (!pfvf->qset.rq)\n\t\treturn 0;\n\n\totx2_nix_rq_op_stats(&rq->stats, pfvf, qidx);\n\treturn 1;\n}\n\nint otx2_update_sq_stats(struct otx2_nic *pfvf, int qidx)\n{\n\tstruct otx2_snd_queue *sq = &pfvf->qset.sq[qidx];\n\n\tif (!pfvf->qset.sq)\n\t\treturn 0;\n\n\tif (qidx >= pfvf->hw.non_qos_queues) {\n\t\tif (!test_bit(qidx - pfvf->hw.non_qos_queues, pfvf->qos.qos_sq_bmap))\n\t\t\treturn 0;\n\t}\n\n\totx2_nix_sq_op_stats(&sq->stats, pfvf, qidx);\n\treturn 1;\n}\n\nvoid otx2_get_dev_stats(struct otx2_nic *pfvf)\n{\n\tstruct otx2_dev_stats *dev_stats = &pfvf->hw.dev_stats;\n\n\tdev_stats->rx_bytes = OTX2_GET_RX_STATS(RX_OCTS);\n\tdev_stats->rx_drops = OTX2_GET_RX_STATS(RX_DROP);\n\tdev_stats->rx_bcast_frames = OTX2_GET_RX_STATS(RX_BCAST);\n\tdev_stats->rx_mcast_frames = OTX2_GET_RX_STATS(RX_MCAST);\n\tdev_stats->rx_ucast_frames = OTX2_GET_RX_STATS(RX_UCAST);\n\tdev_stats->rx_frames = dev_stats->rx_bcast_frames +\n\t\t\t       dev_stats->rx_mcast_frames +\n\t\t\t       dev_stats->rx_ucast_frames;\n\n\tdev_stats->tx_bytes = OTX2_GET_TX_STATS(TX_OCTS);\n\tdev_stats->tx_drops = OTX2_GET_TX_STATS(TX_DROP);\n\tdev_stats->tx_bcast_frames = OTX2_GET_TX_STATS(TX_BCAST);\n\tdev_stats->tx_mcast_frames = OTX2_GET_TX_STATS(TX_MCAST);\n\tdev_stats->tx_ucast_frames = OTX2_GET_TX_STATS(TX_UCAST);\n\tdev_stats->tx_frames = dev_stats->tx_bcast_frames +\n\t\t\t       dev_stats->tx_mcast_frames +\n\t\t\t       dev_stats->tx_ucast_frames;\n}\n\nvoid otx2_get_stats64(struct net_device *netdev,\n\t\t      struct rtnl_link_stats64 *stats)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tstruct otx2_dev_stats *dev_stats;\n\n\totx2_get_dev_stats(pfvf);\n\n\tdev_stats = &pfvf->hw.dev_stats;\n\tstats->rx_bytes = dev_stats->rx_bytes;\n\tstats->rx_packets = dev_stats->rx_frames;\n\tstats->rx_dropped = dev_stats->rx_drops;\n\tstats->multicast = dev_stats->rx_mcast_frames;\n\n\tstats->tx_bytes = dev_stats->tx_bytes;\n\tstats->tx_packets = dev_stats->tx_frames;\n\tstats->tx_dropped = dev_stats->tx_drops;\n}\nEXPORT_SYMBOL(otx2_get_stats64);\n\n \nstatic int otx2_hw_set_mac_addr(struct otx2_nic *pfvf, u8 *mac)\n{\n\tstruct nix_set_mac_addr *req;\n\tint err;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_nix_set_mac_addr(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tether_addr_copy(req->mac_addr, mac);\n\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn err;\n}\n\nstatic int otx2_hw_get_mac_addr(struct otx2_nic *pfvf,\n\t\t\t\tstruct net_device *netdev)\n{\n\tstruct nix_get_mac_addr_rsp *rsp;\n\tstruct mbox_msghdr *msghdr;\n\tstruct msg_req *req;\n\tint err;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_nix_get_mac_addr(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (err) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn err;\n\t}\n\n\tmsghdr = otx2_mbox_get_rsp(&pfvf->mbox.mbox, 0, &req->hdr);\n\tif (IS_ERR(msghdr)) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn PTR_ERR(msghdr);\n\t}\n\trsp = (struct nix_get_mac_addr_rsp *)msghdr;\n\teth_hw_addr_set(netdev, rsp->mac_addr);\n\tmutex_unlock(&pfvf->mbox.lock);\n\n\treturn 0;\n}\n\nint otx2_set_mac_address(struct net_device *netdev, void *p)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!otx2_hw_set_mac_addr(pfvf, addr->sa_data)) {\n\t\teth_hw_addr_set(netdev, addr->sa_data);\n\t\t \n\t\tif (netif_running(netdev) &&\n\t\t    pfvf->flags & OTX2_FLAG_RX_VLAN_SUPPORT)\n\t\t\totx2_install_rxvlan_offload_flow(pfvf);\n\t\t \n\t\tif (pfvf->flags & OTX2_FLAG_DMACFLTR_SUPPORT)\n\t\t\totx2_dmacflt_update_pfmac_flow(pfvf);\n\t} else {\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(otx2_set_mac_address);\n\nint otx2_hw_set_mtu(struct otx2_nic *pfvf, int mtu)\n{\n\tstruct nix_frs_cfg *req;\n\tu16 maxlen;\n\tint err;\n\n\tmaxlen = otx2_get_max_mtu(pfvf) + OTX2_ETH_HLEN + OTX2_HW_TIMESTAMP_LEN;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_nix_set_hw_frs(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->maxlen = pfvf->netdev->mtu + OTX2_ETH_HLEN + OTX2_HW_TIMESTAMP_LEN;\n\n\t \n\tif (is_otx2_lbkvf(pfvf->pdev))\n\t\treq->maxlen = maxlen;\n\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn err;\n}\n\nint otx2_config_pause_frm(struct otx2_nic *pfvf)\n{\n\tstruct cgx_pause_frm_cfg *req;\n\tint err;\n\n\tif (is_otx2_lbkvf(pfvf->pdev))\n\t\treturn 0;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_cgx_cfg_pause_frm(&pfvf->mbox);\n\tif (!req) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\treq->rx_pause = !!(pfvf->flags & OTX2_FLAG_RX_PAUSE_ENABLED);\n\treq->tx_pause = !!(pfvf->flags & OTX2_FLAG_TX_PAUSE_ENABLED);\n\treq->set = 1;\n\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\nunlock:\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn err;\n}\nEXPORT_SYMBOL(otx2_config_pause_frm);\n\nint otx2_set_flowkey_cfg(struct otx2_nic *pfvf)\n{\n\tstruct otx2_rss_info *rss = &pfvf->hw.rss_info;\n\tstruct nix_rss_flowkey_cfg_rsp *rsp;\n\tstruct nix_rss_flowkey_cfg *req;\n\tint err;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\treq = otx2_mbox_alloc_msg_nix_rss_flowkey_cfg(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\treq->mcam_index = -1;  \n\treq->flowkey_cfg = rss->flowkey_cfg;\n\treq->group = DEFAULT_RSS_CONTEXT_GROUP;\n\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (err)\n\t\tgoto fail;\n\n\trsp = (struct nix_rss_flowkey_cfg_rsp *)\n\t\t\totx2_mbox_get_rsp(&pfvf->mbox.mbox, 0, &req->hdr);\n\tif (IS_ERR(rsp)) {\n\t\terr = PTR_ERR(rsp);\n\t\tgoto fail;\n\t}\n\n\tpfvf->hw.flowkey_alg_idx = rsp->alg_idx;\nfail:\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn err;\n}\n\nint otx2_set_rss_table(struct otx2_nic *pfvf, int ctx_id)\n{\n\tstruct otx2_rss_info *rss = &pfvf->hw.rss_info;\n\tconst int index = rss->rss_size * ctx_id;\n\tstruct mbox *mbox = &pfvf->mbox;\n\tstruct otx2_rss_ctx *rss_ctx;\n\tstruct nix_aq_enq_req *aq;\n\tint idx, err;\n\n\tmutex_lock(&mbox->lock);\n\trss_ctx = rss->rss_ctx[ctx_id];\n\t \n\tfor (idx = 0; idx < rss->rss_size; idx++) {\n\t\taq = otx2_mbox_alloc_msg_nix_aq_enq(mbox);\n\t\tif (!aq) {\n\t\t\t \n\t\t\terr = otx2_sync_mbox_msg(mbox);\n\t\t\tif (err) {\n\t\t\t\tmutex_unlock(&mbox->lock);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\taq = otx2_mbox_alloc_msg_nix_aq_enq(mbox);\n\t\t\tif (!aq) {\n\t\t\t\tmutex_unlock(&mbox->lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\taq->rss.rq = rss_ctx->ind_tbl[idx];\n\n\t\t \n\t\taq->qidx = index + idx;\n\t\taq->ctype = NIX_AQ_CTYPE_RSS;\n\t\taq->op = NIX_AQ_INSTOP_INIT;\n\t}\n\terr = otx2_sync_mbox_msg(mbox);\n\tmutex_unlock(&mbox->lock);\n\treturn err;\n}\n\nvoid otx2_set_rss_key(struct otx2_nic *pfvf)\n{\n\tstruct otx2_rss_info *rss = &pfvf->hw.rss_info;\n\tu64 *key = (u64 *)&rss->key[4];\n\tint idx;\n\n\t \n\totx2_write64(pfvf, NIX_LF_RX_SECRETX(5),\n\t\t     (u64)(*((u32 *)&rss->key)) << 32);\n\tidx = sizeof(rss->key) / sizeof(u64);\n\twhile (idx > 0) {\n\t\tidx--;\n\t\totx2_write64(pfvf, NIX_LF_RX_SECRETX(idx), *key++);\n\t}\n}\n\nint otx2_rss_init(struct otx2_nic *pfvf)\n{\n\tstruct otx2_rss_info *rss = &pfvf->hw.rss_info;\n\tstruct otx2_rss_ctx *rss_ctx;\n\tint idx, ret = 0;\n\n\trss->rss_size = sizeof(*rss->rss_ctx[DEFAULT_RSS_CONTEXT_GROUP]);\n\n\t \n\tif (!rss->enable)\n\t\tnetdev_rss_key_fill(rss->key, sizeof(rss->key));\n\totx2_set_rss_key(pfvf);\n\n\tif (!netif_is_rxfh_configured(pfvf->netdev)) {\n\t\t \n\t\trss->rss_ctx[DEFAULT_RSS_CONTEXT_GROUP] = kzalloc(rss->rss_size,\n\t\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!rss->rss_ctx[DEFAULT_RSS_CONTEXT_GROUP])\n\t\t\treturn -ENOMEM;\n\n\t\trss_ctx = rss->rss_ctx[DEFAULT_RSS_CONTEXT_GROUP];\n\t\tfor (idx = 0; idx < rss->rss_size; idx++)\n\t\t\trss_ctx->ind_tbl[idx] =\n\t\t\t\tethtool_rxfh_indir_default(idx,\n\t\t\t\t\t\t\t   pfvf->hw.rx_queues);\n\t}\n\tret = otx2_set_rss_table(pfvf, DEFAULT_RSS_CONTEXT_GROUP);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trss->flowkey_cfg = rss->enable ? rss->flowkey_cfg :\n\t\t\t   NIX_FLOW_KEY_TYPE_IPV4 | NIX_FLOW_KEY_TYPE_IPV6 |\n\t\t\t   NIX_FLOW_KEY_TYPE_TCP | NIX_FLOW_KEY_TYPE_UDP |\n\t\t\t   NIX_FLOW_KEY_TYPE_SCTP | NIX_FLOW_KEY_TYPE_VLAN |\n\t\t\t   NIX_FLOW_KEY_TYPE_IPV4_PROTO;\n\n\tret = otx2_set_flowkey_cfg(pfvf);\n\tif (ret)\n\t\treturn ret;\n\n\trss->enable = true;\n\treturn 0;\n}\n\n \nstatic void otx2_setup_udp_segmentation(struct nix_lso_format_cfg *lso, bool v4)\n{\n\tstruct nix_lso_format *field;\n\n\tfield = (struct nix_lso_format *)&lso->fields[0];\n\tlso->field_mask = GENMASK(18, 0);\n\n\t \n\tfield->layer = NIX_TXLAYER_OL3;\n\t \n\tfield->offset = v4 ? 2 : 4;\n\tfield->sizem1 = 1;  \n\tfield->alg = NIX_LSOALG_ADD_PAYLEN;\n\tfield++;\n\n\t \n\tif (v4) {\n\t\t \n\t\tfield->layer = NIX_TXLAYER_OL3;\n\t\tfield->offset = 4;\n\t\tfield->sizem1 = 1;  \n\t\tfield->alg = NIX_LSOALG_ADD_SEGNUM;\n\t\tfield++;\n\t}\n\n\t \n\tfield->layer = NIX_TXLAYER_OL4;\n\tfield->offset = 4;\n\tfield->sizem1 = 1;\n\tfield->alg = NIX_LSOALG_ADD_PAYLEN;\n}\n\n \nvoid otx2_setup_segmentation(struct otx2_nic *pfvf)\n{\n\tstruct nix_lso_format_cfg_rsp *rsp;\n\tstruct nix_lso_format_cfg *lso;\n\tstruct otx2_hw *hw = &pfvf->hw;\n\tint err;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\n\t \n\tlso = otx2_mbox_alloc_msg_nix_lso_format_cfg(&pfvf->mbox);\n\tif (!lso)\n\t\tgoto fail;\n\n\t \n\totx2_setup_udp_segmentation(lso, true);\n\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (err)\n\t\tgoto fail;\n\n\trsp = (struct nix_lso_format_cfg_rsp *)\n\t\t\totx2_mbox_get_rsp(&pfvf->mbox.mbox, 0, &lso->hdr);\n\tif (IS_ERR(rsp))\n\t\tgoto fail;\n\n\thw->lso_udpv4_idx = rsp->lso_format_idx;\n\n\t \n\tlso = otx2_mbox_alloc_msg_nix_lso_format_cfg(&pfvf->mbox);\n\tif (!lso)\n\t\tgoto fail;\n\n\t \n\totx2_setup_udp_segmentation(lso, false);\n\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (err)\n\t\tgoto fail;\n\n\trsp = (struct nix_lso_format_cfg_rsp *)\n\t\t\totx2_mbox_get_rsp(&pfvf->mbox.mbox, 0, &lso->hdr);\n\tif (IS_ERR(rsp))\n\t\tgoto fail;\n\n\thw->lso_udpv6_idx = rsp->lso_format_idx;\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn;\nfail:\n\tmutex_unlock(&pfvf->mbox.lock);\n\tnetdev_info(pfvf->netdev,\n\t\t    \"Failed to get LSO index for UDP GSO offload, disabling\\n\");\n\tpfvf->netdev->hw_features &= ~NETIF_F_GSO_UDP_L4;\n}\n\nvoid otx2_config_irq_coalescing(struct otx2_nic *pfvf, int qidx)\n{\n\t \n\totx2_write64(pfvf, NIX_LF_CINTX_WAIT(qidx),\n\t\t     ((u64)(pfvf->hw.cq_time_wait * 10) << 48) |\n\t\t     ((u64)pfvf->hw.cq_qcount_wait << 32) |\n\t\t     (pfvf->hw.cq_ecount_wait - 1));\n}\n\nstatic int otx2_alloc_pool_buf(struct otx2_nic *pfvf, struct otx2_pool *pool,\n\t\t\t       dma_addr_t *dma)\n{\n\tunsigned int offset = 0;\n\tstruct page *page;\n\tsize_t sz;\n\n\tsz = SKB_DATA_ALIGN(pool->rbsize);\n\tsz = ALIGN(sz, OTX2_ALIGN);\n\n\tpage = page_pool_alloc_frag(pool->page_pool, &offset, sz, GFP_ATOMIC);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\t*dma = page_pool_get_dma_addr(page) + offset;\n\treturn 0;\n}\n\nstatic int __otx2_alloc_rbuf(struct otx2_nic *pfvf, struct otx2_pool *pool,\n\t\t\t     dma_addr_t *dma)\n{\n\tu8 *buf;\n\n\tif (pool->page_pool)\n\t\treturn otx2_alloc_pool_buf(pfvf, pool, dma);\n\n\tbuf = napi_alloc_frag_align(pool->rbsize, OTX2_ALIGN);\n\tif (unlikely(!buf))\n\t\treturn -ENOMEM;\n\n\t*dma = dma_map_single_attrs(pfvf->dev, buf, pool->rbsize,\n\t\t\t\t    DMA_FROM_DEVICE, DMA_ATTR_SKIP_CPU_SYNC);\n\tif (unlikely(dma_mapping_error(pfvf->dev, *dma))) {\n\t\tpage_frag_free(buf);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nint otx2_alloc_rbuf(struct otx2_nic *pfvf, struct otx2_pool *pool,\n\t\t    dma_addr_t *dma)\n{\n\tint ret;\n\n\tlocal_bh_disable();\n\tret = __otx2_alloc_rbuf(pfvf, pool, dma);\n\tlocal_bh_enable();\n\treturn ret;\n}\n\nint otx2_alloc_buffer(struct otx2_nic *pfvf, struct otx2_cq_queue *cq,\n\t\t      dma_addr_t *dma)\n{\n\tif (unlikely(__otx2_alloc_rbuf(pfvf, cq->rbpool, dma)))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid otx2_tx_timeout(struct net_device *netdev, unsigned int txq)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\n\tschedule_work(&pfvf->reset_task);\n}\nEXPORT_SYMBOL(otx2_tx_timeout);\n\nvoid otx2_get_mac_from_af(struct net_device *netdev)\n{\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tint err;\n\n\terr = otx2_hw_get_mac_addr(pfvf, netdev);\n\tif (err)\n\t\tdev_warn(pfvf->dev, \"Failed to read mac from hardware\\n\");\n\n\t \n\tif (!is_valid_ether_addr(netdev->dev_addr))\n\t\teth_hw_addr_random(netdev);\n}\nEXPORT_SYMBOL(otx2_get_mac_from_af);\n\nint otx2_txschq_config(struct otx2_nic *pfvf, int lvl, int prio, bool txschq_for_pfc)\n{\n\tu16 (*schq_list)[MAX_TXSCHQ_PER_FUNC];\n\tstruct otx2_hw *hw = &pfvf->hw;\n\tstruct nix_txschq_config *req;\n\tu64 schq, parent;\n\tu64 dwrr_val;\n\n\tdwrr_val = mtu_to_dwrr_weight(pfvf, pfvf->tx_max_pktlen);\n\n\treq = otx2_mbox_alloc_msg_nix_txschq_cfg(&pfvf->mbox);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->lvl = lvl;\n\treq->num_regs = 1;\n\n\tschq_list = hw->txschq_list;\n#ifdef CONFIG_DCB\n\tif (txschq_for_pfc)\n\t\tschq_list = pfvf->pfc_schq_list;\n#endif\n\n\tschq = schq_list[lvl][prio];\n\t \n\tif (lvl == NIX_TXSCH_LVL_SMQ) {\n\t\treq->reg[0] = NIX_AF_SMQX_CFG(schq);\n\t\treq->regval[0] = ((u64)pfvf->tx_max_pktlen << 8) | OTX2_MIN_MTU;\n\t\treq->regval[0] |= (0x20ULL << 51) | (0x80ULL << 39) |\n\t\t\t\t  (0x2ULL << 36);\n\t\t \n\t\tif (!is_dev_otx2(pfvf->pdev))\n\t\t\treq->regval[0] |= FIELD_PREP(GENMASK_ULL(58, 57),\n\t\t\t\t\t\t(u64)hw->smq_link_type);\n\t\treq->num_regs++;\n\t\t \n\t\tparent = schq_list[NIX_TXSCH_LVL_TL4][prio];\n\t\treq->reg[1] = NIX_AF_MDQX_PARENT(schq);\n\t\treq->regval[1] = parent << 16;\n\t\treq->num_regs++;\n\t\t \n\t\treq->reg[2] = NIX_AF_MDQX_SCHEDULE(schq);\n\t\treq->regval[2] =  dwrr_val;\n\t} else if (lvl == NIX_TXSCH_LVL_TL4) {\n\t\tparent = schq_list[NIX_TXSCH_LVL_TL3][prio];\n\t\treq->reg[0] = NIX_AF_TL4X_PARENT(schq);\n\t\treq->regval[0] = parent << 16;\n\t\treq->num_regs++;\n\t\treq->reg[1] = NIX_AF_TL4X_SCHEDULE(schq);\n\t\treq->regval[1] = dwrr_val;\n\t} else if (lvl == NIX_TXSCH_LVL_TL3) {\n\t\tparent = schq_list[NIX_TXSCH_LVL_TL2][prio];\n\t\treq->reg[0] = NIX_AF_TL3X_PARENT(schq);\n\t\treq->regval[0] = parent << 16;\n\t\treq->num_regs++;\n\t\treq->reg[1] = NIX_AF_TL3X_SCHEDULE(schq);\n\t\treq->regval[1] = dwrr_val;\n\t\tif (lvl == hw->txschq_link_cfg_lvl) {\n\t\t\treq->num_regs++;\n\t\t\treq->reg[2] = NIX_AF_TL3_TL2X_LINKX_CFG(schq, hw->tx_link);\n\t\t\t \n\t\t\treq->regval[2] = BIT_ULL(13) | BIT_ULL(12) | prio;\n\t\t}\n\t} else if (lvl == NIX_TXSCH_LVL_TL2) {\n\t\tparent = schq_list[NIX_TXSCH_LVL_TL1][prio];\n\t\treq->reg[0] = NIX_AF_TL2X_PARENT(schq);\n\t\treq->regval[0] = parent << 16;\n\n\t\treq->num_regs++;\n\t\treq->reg[1] = NIX_AF_TL2X_SCHEDULE(schq);\n\t\treq->regval[1] = TXSCH_TL1_DFLT_RR_PRIO << 24 | dwrr_val;\n\n\t\tif (lvl == hw->txschq_link_cfg_lvl) {\n\t\t\treq->num_regs++;\n\t\t\treq->reg[2] = NIX_AF_TL3_TL2X_LINKX_CFG(schq, hw->tx_link);\n\t\t\t \n\t\t\treq->regval[2] = BIT_ULL(13) | BIT_ULL(12) | prio;\n\t\t}\n\t} else if (lvl == NIX_TXSCH_LVL_TL1) {\n\t\t \n\n\t\t \n\t\treq->reg[0] = NIX_AF_TL1X_SCHEDULE(schq);\n\t\treq->regval[0] = TXSCH_TL1_DFLT_RR_QTM;\n\n\t\treq->num_regs++;\n\t\treq->reg[1] = NIX_AF_TL1X_TOPOLOGY(schq);\n\t\treq->regval[1] = (TXSCH_TL1_DFLT_RR_PRIO << 1);\n\n\t\treq->num_regs++;\n\t\treq->reg[2] = NIX_AF_TL1X_CIR(schq);\n\t\treq->regval[2] = 0;\n\t}\n\n\treturn otx2_sync_mbox_msg(&pfvf->mbox);\n}\nEXPORT_SYMBOL(otx2_txschq_config);\n\nint otx2_smq_flush(struct otx2_nic *pfvf, int smq)\n{\n\tstruct nix_txschq_config *req;\n\tint rc;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\n\treq = otx2_mbox_alloc_msg_nix_txschq_cfg(&pfvf->mbox);\n\tif (!req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->lvl = NIX_TXSCH_LVL_SMQ;\n\treq->reg[0] = NIX_AF_SMQX_CFG(smq);\n\treq->regval[0] |= BIT_ULL(49);\n\treq->num_regs++;\n\n\trc = otx2_sync_mbox_msg(&pfvf->mbox);\n\tmutex_unlock(&pfvf->mbox.lock);\n\treturn rc;\n}\nEXPORT_SYMBOL(otx2_smq_flush);\n\nint otx2_txsch_alloc(struct otx2_nic *pfvf)\n{\n\tstruct nix_txsch_alloc_req *req;\n\tstruct nix_txsch_alloc_rsp *rsp;\n\tint lvl, schq, rc;\n\n\t \n\treq = otx2_mbox_alloc_msg_nix_txsch_alloc(&pfvf->mbox);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (lvl = 0; lvl < NIX_TXSCH_LVL_CNT; lvl++)\n\t\treq->schq[lvl] = 1;\n\trc = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (rc)\n\t\treturn rc;\n\n\trsp = (struct nix_txsch_alloc_rsp *)\n\t      otx2_mbox_get_rsp(&pfvf->mbox.mbox, 0, &req->hdr);\n\tif (IS_ERR(rsp))\n\t\treturn PTR_ERR(rsp);\n\n\t \n\tfor (lvl = 0; lvl < NIX_TXSCH_LVL_CNT; lvl++)\n\t\tfor (schq = 0; schq < rsp->schq[lvl]; schq++)\n\t\t\tpfvf->hw.txschq_list[lvl][schq] =\n\t\t\t\trsp->schq_list[lvl][schq];\n\n\tpfvf->hw.txschq_link_cfg_lvl = rsp->link_cfg_lvl;\n\tpfvf->hw.txschq_aggr_lvl_rr_prio = rsp->aggr_lvl_rr_prio;\n\n\treturn 0;\n}\n\nvoid otx2_txschq_free_one(struct otx2_nic *pfvf, u16 lvl, u16 schq)\n{\n\tstruct nix_txsch_free_req *free_req;\n\tint err;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\n\tfree_req = otx2_mbox_alloc_msg_nix_txsch_free(&pfvf->mbox);\n\tif (!free_req) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\tnetdev_err(pfvf->netdev,\n\t\t\t   \"Failed alloc txschq free req\\n\");\n\t\treturn;\n\t}\n\n\tfree_req->schq_lvl = lvl;\n\tfree_req->schq = schq;\n\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (err) {\n\t\tnetdev_err(pfvf->netdev,\n\t\t\t   \"Failed stop txschq %d at level %d\\n\", schq, lvl);\n\t}\n\n\tmutex_unlock(&pfvf->mbox.lock);\n}\nEXPORT_SYMBOL(otx2_txschq_free_one);\n\nvoid otx2_txschq_stop(struct otx2_nic *pfvf)\n{\n\tint lvl, schq;\n\n\t \n\tfor (lvl = 0; lvl < NIX_TXSCH_LVL_CNT; lvl++)\n\t\totx2_txschq_free_one(pfvf, lvl,\n\t\t\t\t     pfvf->hw.txschq_list[lvl][0]);\n\n\t \n\tfor (lvl = 0; lvl < NIX_TXSCH_LVL_CNT; lvl++) {\n\t\tfor (schq = 0; schq < MAX_TXSCHQ_PER_FUNC; schq++)\n\t\t\tpfvf->hw.txschq_list[lvl][schq] = 0;\n\t}\n\n}\n\nvoid otx2_sqb_flush(struct otx2_nic *pfvf)\n{\n\tint qidx, sqe_tail, sqe_head;\n\tstruct otx2_snd_queue *sq;\n\tu64 incr, *ptr, val;\n\n\tptr = (u64 *)otx2_get_regaddr(pfvf, NIX_LF_SQ_OP_STATUS);\n\tfor (qidx = 0; qidx < otx2_get_total_tx_queues(pfvf); qidx++) {\n\t\tsq = &pfvf->qset.sq[qidx];\n\t\tif (!sq->sqb_ptrs)\n\t\t\tcontinue;\n\n\t\tincr = (u64)qidx << 32;\n\t\tval = otx2_atomic64_add(incr, ptr);\n\t\tsqe_head = (val >> 20) & 0x3F;\n\t\tsqe_tail = (val >> 28) & 0x3F;\n\t\tif (sqe_head != sqe_tail)\n\t\t\tusleep_range(50, 60);\n\t}\n}\n\n \n#define RQ_PASS_LVL_CQ(skid, qsize)\t((((skid) + 16) * 256) / (qsize))\n#define RQ_DROP_LVL_CQ(skid, qsize)\t(((skid) * 256) / (qsize))\n\n \n#define RQ_BP_LVL_AURA   (255 - ((85 * 256) / 100))  \n#define RQ_PASS_LVL_AURA (255 - ((95 * 256) / 100))  \n#define RQ_DROP_LVL_AURA (255 - ((99 * 256) / 100))  \n\nstatic int otx2_rq_init(struct otx2_nic *pfvf, u16 qidx, u16 lpb_aura)\n{\n\tstruct otx2_qset *qset = &pfvf->qset;\n\tstruct nix_aq_enq_req *aq;\n\n\t \n\taq = otx2_mbox_alloc_msg_nix_aq_enq(&pfvf->mbox);\n\tif (!aq)\n\t\treturn -ENOMEM;\n\n\taq->rq.cq = qidx;\n\taq->rq.ena = 1;\n\taq->rq.pb_caching = 1;\n\taq->rq.lpb_aura = lpb_aura;  \n\taq->rq.lpb_sizem1 = (DMA_BUFFER_LEN(pfvf->rbsize) / 8) - 1;\n\taq->rq.xqe_imm_size = 0;  \n\taq->rq.flow_tagw = 32;  \n\taq->rq.qint_idx = 0;\n\taq->rq.lpb_drop_ena = 1;  \n\taq->rq.xqe_drop_ena = 1;  \n\taq->rq.xqe_pass = RQ_PASS_LVL_CQ(pfvf->hw.rq_skid, qset->rqe_cnt);\n\taq->rq.xqe_drop = RQ_DROP_LVL_CQ(pfvf->hw.rq_skid, qset->rqe_cnt);\n\taq->rq.lpb_aura_pass = RQ_PASS_LVL_AURA;\n\taq->rq.lpb_aura_drop = RQ_DROP_LVL_AURA;\n\n\t \n\taq->qidx = qidx;\n\taq->ctype = NIX_AQ_CTYPE_RQ;\n\taq->op = NIX_AQ_INSTOP_INIT;\n\n\treturn otx2_sync_mbox_msg(&pfvf->mbox);\n}\n\nint otx2_sq_aq_init(void *dev, u16 qidx, u16 sqb_aura)\n{\n\tstruct otx2_nic *pfvf = dev;\n\tstruct otx2_snd_queue *sq;\n\tstruct nix_aq_enq_req *aq;\n\n\tsq = &pfvf->qset.sq[qidx];\n\tsq->lmt_addr = (__force u64 *)(pfvf->reg_base + LMT_LF_LMTLINEX(qidx));\n\t \n\taq = otx2_mbox_alloc_msg_nix_aq_enq(&pfvf->mbox);\n\tif (!aq)\n\t\treturn -ENOMEM;\n\n\taq->sq.cq = pfvf->hw.rx_queues + qidx;\n\taq->sq.max_sqe_size = NIX_MAXSQESZ_W16;  \n\taq->sq.cq_ena = 1;\n\taq->sq.ena = 1;\n\taq->sq.smq = otx2_get_smq_idx(pfvf, qidx);\n\taq->sq.smq_rr_quantum = mtu_to_dwrr_weight(pfvf, pfvf->tx_max_pktlen);\n\taq->sq.default_chan = pfvf->hw.tx_chan_base;\n\taq->sq.sqe_stype = NIX_STYPE_STF;  \n\taq->sq.sqb_aura = sqb_aura;\n\taq->sq.sq_int_ena = NIX_SQINT_BITS;\n\taq->sq.qint_idx = 0;\n\t \n\taq->sq.cq_limit = ((SEND_CQ_SKID * 256) / (pfvf->qset.sqe_cnt));\n\n\t \n\taq->qidx = qidx;\n\taq->ctype = NIX_AQ_CTYPE_SQ;\n\taq->op = NIX_AQ_INSTOP_INIT;\n\n\treturn otx2_sync_mbox_msg(&pfvf->mbox);\n}\n\nint otx2_sq_init(struct otx2_nic *pfvf, u16 qidx, u16 sqb_aura)\n{\n\tstruct otx2_qset *qset = &pfvf->qset;\n\tstruct otx2_snd_queue *sq;\n\tstruct otx2_pool *pool;\n\tint err;\n\n\tpool = &pfvf->qset.pool[sqb_aura];\n\tsq = &qset->sq[qidx];\n\tsq->sqe_size = NIX_SQESZ_W16 ? 64 : 128;\n\tsq->sqe_cnt = qset->sqe_cnt;\n\n\terr = qmem_alloc(pfvf->dev, &sq->sqe, 1, sq->sqe_size);\n\tif (err)\n\t\treturn err;\n\n\tif (qidx < pfvf->hw.tx_queues) {\n\t\terr = qmem_alloc(pfvf->dev, &sq->tso_hdrs, qset->sqe_cnt,\n\t\t\t\t TSO_HEADER_SIZE);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsq->sqe_base = sq->sqe->base;\n\tsq->sg = kcalloc(qset->sqe_cnt, sizeof(struct sg_list), GFP_KERNEL);\n\tif (!sq->sg)\n\t\treturn -ENOMEM;\n\n\tif (pfvf->ptp && qidx < pfvf->hw.tx_queues) {\n\t\terr = qmem_alloc(pfvf->dev, &sq->timestamps, qset->sqe_cnt,\n\t\t\t\t sizeof(*sq->timestamps));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsq->head = 0;\n\tsq->cons_head = 0;\n\tsq->sqe_per_sqb = (pfvf->hw.sqb_size / sq->sqe_size) - 1;\n\tsq->num_sqbs = (qset->sqe_cnt + sq->sqe_per_sqb) / sq->sqe_per_sqb;\n\t \n\tsq->sqe_thresh = ((sq->num_sqbs * sq->sqe_per_sqb) * 10) / 100;\n\tsq->aura_id = sqb_aura;\n\tsq->aura_fc_addr = pool->fc_addr->base;\n\tsq->io_addr = (__force u64)otx2_get_regaddr(pfvf, NIX_LF_OP_SENDX(0));\n\n\tsq->stats.bytes = 0;\n\tsq->stats.pkts = 0;\n\n\treturn pfvf->hw_ops->sq_aq_init(pfvf, qidx, sqb_aura);\n\n}\n\nstatic int otx2_cq_init(struct otx2_nic *pfvf, u16 qidx)\n{\n\tstruct otx2_qset *qset = &pfvf->qset;\n\tint err, pool_id, non_xdp_queues;\n\tstruct nix_aq_enq_req *aq;\n\tstruct otx2_cq_queue *cq;\n\n\tcq = &qset->cq[qidx];\n\tcq->cq_idx = qidx;\n\tnon_xdp_queues = pfvf->hw.rx_queues + pfvf->hw.tx_queues;\n\tif (qidx < pfvf->hw.rx_queues) {\n\t\tcq->cq_type = CQ_RX;\n\t\tcq->cint_idx = qidx;\n\t\tcq->cqe_cnt = qset->rqe_cnt;\n\t\tif (pfvf->xdp_prog)\n\t\t\txdp_rxq_info_reg(&cq->xdp_rxq, pfvf->netdev, qidx, 0);\n\t} else if (qidx < non_xdp_queues) {\n\t\tcq->cq_type = CQ_TX;\n\t\tcq->cint_idx = qidx - pfvf->hw.rx_queues;\n\t\tcq->cqe_cnt = qset->sqe_cnt;\n\t} else {\n\t\tif (pfvf->hw.xdp_queues &&\n\t\t    qidx < non_xdp_queues + pfvf->hw.xdp_queues) {\n\t\t\tcq->cq_type = CQ_XDP;\n\t\t\tcq->cint_idx = qidx - non_xdp_queues;\n\t\t\tcq->cqe_cnt = qset->sqe_cnt;\n\t\t} else {\n\t\t\tcq->cq_type = CQ_QOS;\n\t\t\tcq->cint_idx = qidx - non_xdp_queues -\n\t\t\t\t       pfvf->hw.xdp_queues;\n\t\t\tcq->cqe_cnt = qset->sqe_cnt;\n\t\t}\n\t}\n\tcq->cqe_size = pfvf->qset.xqe_size;\n\n\t \n\terr = qmem_alloc(pfvf->dev, &cq->cqe, cq->cqe_cnt, cq->cqe_size);\n\tif (err)\n\t\treturn err;\n\n\t \n\tcq->cqe_base = cq->cqe->base;\n\t \n\tpool_id = ((cq->cq_type == CQ_RX) &&\n\t\t   (pfvf->hw.rqpool_cnt != pfvf->hw.rx_queues)) ? 0 : qidx;\n\tcq->rbpool = &qset->pool[pool_id];\n\tcq->refill_task_sched = false;\n\n\t \n\taq = otx2_mbox_alloc_msg_nix_aq_enq(&pfvf->mbox);\n\tif (!aq)\n\t\treturn -ENOMEM;\n\n\taq->cq.ena = 1;\n\taq->cq.qsize = Q_SIZE(cq->cqe_cnt, 4);\n\taq->cq.caching = 1;\n\taq->cq.base = cq->cqe->iova;\n\taq->cq.cint_idx = cq->cint_idx;\n\taq->cq.cq_err_int_ena = NIX_CQERRINT_BITS;\n\taq->cq.qint_idx = 0;\n\taq->cq.avg_level = 255;\n\n\tif (qidx < pfvf->hw.rx_queues) {\n\t\taq->cq.drop = RQ_DROP_LVL_CQ(pfvf->hw.rq_skid, cq->cqe_cnt);\n\t\taq->cq.drop_ena = 1;\n\n\t\tif (!is_otx2_lbkvf(pfvf->pdev)) {\n\t\t\t \n\t\t\taq->cq.bp_ena = 1;\n#ifdef CONFIG_DCB\n\t\t\taq->cq.bpid = pfvf->bpid[pfvf->queue_to_pfc_map[qidx]];\n#else\n\t\t\taq->cq.bpid = pfvf->bpid[0];\n#endif\n\n\t\t\t \n\t\t\taq->cq.bp = RQ_PASS_LVL_CQ(pfvf->hw.rq_skid, qset->rqe_cnt);\n\t\t}\n\t}\n\n\t \n\taq->qidx = qidx;\n\taq->ctype = NIX_AQ_CTYPE_CQ;\n\taq->op = NIX_AQ_INSTOP_INIT;\n\n\treturn otx2_sync_mbox_msg(&pfvf->mbox);\n}\n\nstatic void otx2_pool_refill_task(struct work_struct *work)\n{\n\tstruct otx2_cq_queue *cq;\n\tstruct refill_work *wrk;\n\tstruct otx2_nic *pfvf;\n\tint qidx;\n\n\twrk = container_of(work, struct refill_work, pool_refill_work.work);\n\tpfvf = wrk->pf;\n\tqidx = wrk - pfvf->refill_wrk;\n\tcq = &pfvf->qset.cq[qidx];\n\n\tcq->refill_task_sched = false;\n\n\tlocal_bh_disable();\n\tnapi_schedule(wrk->napi);\n\tlocal_bh_enable();\n}\n\nint otx2_config_nix_queues(struct otx2_nic *pfvf)\n{\n\tint qidx, err;\n\n\t \n\tfor (qidx = 0; qidx < pfvf->hw.rx_queues; qidx++) {\n\t\tu16 lpb_aura = otx2_get_pool_idx(pfvf, AURA_NIX_RQ, qidx);\n\n\t\terr = otx2_rq_init(pfvf, qidx, lpb_aura);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (qidx = 0; qidx < pfvf->hw.non_qos_queues; qidx++) {\n\t\tu16 sqb_aura = otx2_get_pool_idx(pfvf, AURA_NIX_SQ, qidx);\n\n\t\terr = otx2_sq_init(pfvf, qidx, sqb_aura);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (qidx = 0; qidx < pfvf->qset.cq_cnt; qidx++) {\n\t\terr = otx2_cq_init(pfvf, qidx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tpfvf->cq_op_addr = (__force u64 *)otx2_get_regaddr(pfvf,\n\t\t\t\t\t\t\t   NIX_LF_CQ_OP_STATUS);\n\n\t \n\tpfvf->refill_wrk = devm_kcalloc(pfvf->dev, pfvf->qset.cq_cnt,\n\t\t\t\t\tsizeof(struct refill_work), GFP_KERNEL);\n\tif (!pfvf->refill_wrk)\n\t\treturn -ENOMEM;\n\n\tfor (qidx = 0; qidx < pfvf->qset.cq_cnt; qidx++) {\n\t\tpfvf->refill_wrk[qidx].pf = pfvf;\n\t\tINIT_DELAYED_WORK(&pfvf->refill_wrk[qidx].pool_refill_work,\n\t\t\t\t  otx2_pool_refill_task);\n\t}\n\treturn 0;\n}\n\nint otx2_config_nix(struct otx2_nic *pfvf)\n{\n\tstruct nix_lf_alloc_req  *nixlf;\n\tstruct nix_lf_alloc_rsp *rsp;\n\tint err;\n\n\tpfvf->qset.xqe_size = pfvf->hw.xqe_size;\n\n\t \n\tnixlf = otx2_mbox_alloc_msg_nix_lf_alloc(&pfvf->mbox);\n\tif (!nixlf)\n\t\treturn -ENOMEM;\n\n\t \n\tnixlf->rq_cnt = pfvf->hw.rx_queues;\n\tnixlf->sq_cnt = otx2_get_total_tx_queues(pfvf);\n\tnixlf->cq_cnt = pfvf->qset.cq_cnt;\n\tnixlf->rss_sz = MAX_RSS_INDIR_TBL_SIZE;\n\tnixlf->rss_grps = MAX_RSS_GROUPS;\n\tnixlf->xqe_sz = pfvf->hw.xqe_size == 128 ? NIX_XQESZ_W16 : NIX_XQESZ_W64;\n\t \n\tnixlf->npa_func = RVU_DEFAULT_PF_FUNC;\n\t \n\tnixlf->rx_cfg = BIT_ULL(33) | BIT_ULL(35) | BIT_ULL(37);\n\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (err)\n\t\treturn err;\n\n\trsp = (struct nix_lf_alloc_rsp *)otx2_mbox_get_rsp(&pfvf->mbox.mbox, 0,\n\t\t\t\t\t\t\t   &nixlf->hdr);\n\tif (IS_ERR(rsp))\n\t\treturn PTR_ERR(rsp);\n\n\tif (rsp->qints < 1)\n\t\treturn -ENXIO;\n\n\treturn rsp->hdr.rc;\n}\n\nvoid otx2_sq_free_sqbs(struct otx2_nic *pfvf)\n{\n\tstruct otx2_qset *qset = &pfvf->qset;\n\tstruct otx2_hw *hw = &pfvf->hw;\n\tstruct otx2_snd_queue *sq;\n\tint sqb, qidx;\n\tu64 iova, pa;\n\n\tfor (qidx = 0; qidx < otx2_get_total_tx_queues(pfvf); qidx++) {\n\t\tsq = &qset->sq[qidx];\n\t\tif (!sq->sqb_ptrs)\n\t\t\tcontinue;\n\t\tfor (sqb = 0; sqb < sq->sqb_count; sqb++) {\n\t\t\tif (!sq->sqb_ptrs[sqb])\n\t\t\t\tcontinue;\n\t\t\tiova = sq->sqb_ptrs[sqb];\n\t\t\tpa = otx2_iova_to_phys(pfvf->iommu_domain, iova);\n\t\t\tdma_unmap_page_attrs(pfvf->dev, iova, hw->sqb_size,\n\t\t\t\t\t     DMA_FROM_DEVICE,\n\t\t\t\t\t     DMA_ATTR_SKIP_CPU_SYNC);\n\t\t\tput_page(virt_to_page(phys_to_virt(pa)));\n\t\t}\n\t\tsq->sqb_count = 0;\n\t}\n}\n\nvoid otx2_free_bufs(struct otx2_nic *pfvf, struct otx2_pool *pool,\n\t\t    u64 iova, int size)\n{\n\tstruct page *page;\n\tu64 pa;\n\n\tpa = otx2_iova_to_phys(pfvf->iommu_domain, iova);\n\tpage = virt_to_head_page(phys_to_virt(pa));\n\n\tif (pool->page_pool) {\n\t\tpage_pool_put_full_page(pool->page_pool, page, true);\n\t} else {\n\t\tdma_unmap_page_attrs(pfvf->dev, iova, size,\n\t\t\t\t     DMA_FROM_DEVICE,\n\t\t\t\t     DMA_ATTR_SKIP_CPU_SYNC);\n\n\t\tput_page(page);\n\t}\n}\n\nvoid otx2_free_aura_ptr(struct otx2_nic *pfvf, int type)\n{\n\tint pool_id, pool_start = 0, pool_end = 0, size = 0;\n\tstruct otx2_pool *pool;\n\tu64 iova;\n\n\tif (type == AURA_NIX_SQ) {\n\t\tpool_start = otx2_get_pool_idx(pfvf, type, 0);\n\t\tpool_end =  pool_start + pfvf->hw.sqpool_cnt;\n\t\tsize = pfvf->hw.sqb_size;\n\t}\n\tif (type == AURA_NIX_RQ) {\n\t\tpool_start = otx2_get_pool_idx(pfvf, type, 0);\n\t\tpool_end = pfvf->hw.rqpool_cnt;\n\t\tsize = pfvf->rbsize;\n\t}\n\n\t \n\tfor (pool_id = pool_start; pool_id < pool_end; pool_id++) {\n\t\tiova = otx2_aura_allocptr(pfvf, pool_id);\n\t\tpool = &pfvf->qset.pool[pool_id];\n\t\twhile (iova) {\n\t\t\tif (type == AURA_NIX_RQ)\n\t\t\t\tiova -= OTX2_HEAD_ROOM;\n\n\t\t\totx2_free_bufs(pfvf, pool, iova, size);\n\n\t\t\tiova = otx2_aura_allocptr(pfvf, pool_id);\n\t\t}\n\t}\n}\n\nvoid otx2_aura_pool_free(struct otx2_nic *pfvf)\n{\n\tstruct otx2_pool *pool;\n\tint pool_id;\n\n\tif (!pfvf->qset.pool)\n\t\treturn;\n\n\tfor (pool_id = 0; pool_id < pfvf->hw.pool_cnt; pool_id++) {\n\t\tpool = &pfvf->qset.pool[pool_id];\n\t\tqmem_free(pfvf->dev, pool->stack);\n\t\tqmem_free(pfvf->dev, pool->fc_addr);\n\t\tpage_pool_destroy(pool->page_pool);\n\t\tpool->page_pool = NULL;\n\t}\n\tdevm_kfree(pfvf->dev, pfvf->qset.pool);\n\tpfvf->qset.pool = NULL;\n}\n\nint otx2_aura_init(struct otx2_nic *pfvf, int aura_id,\n\t\t   int pool_id, int numptrs)\n{\n\tstruct npa_aq_enq_req *aq;\n\tstruct otx2_pool *pool;\n\tint err;\n\n\tpool = &pfvf->qset.pool[pool_id];\n\n\t \n\tif (!pool->fc_addr) {\n\t\terr = qmem_alloc(pfvf->dev, &pool->fc_addr, 1, OTX2_ALIGN);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\taq = otx2_mbox_alloc_msg_npa_aq_enq(&pfvf->mbox);\n\tif (!aq) {\n\t\t \n\t\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\t\tif (err)\n\t\t\treturn err;\n\t\taq = otx2_mbox_alloc_msg_npa_aq_enq(&pfvf->mbox);\n\t\tif (!aq)\n\t\t\treturn -ENOMEM;\n\t}\n\n\taq->aura_id = aura_id;\n\t \n\taq->aura.pool_addr = pool_id;\n\taq->aura.pool_caching = 1;\n\taq->aura.shift = ilog2(numptrs) - 8;\n\taq->aura.count = numptrs;\n\taq->aura.limit = numptrs;\n\taq->aura.avg_level = 255;\n\taq->aura.ena = 1;\n\taq->aura.fc_ena = 1;\n\taq->aura.fc_addr = pool->fc_addr->iova;\n\taq->aura.fc_hyst_bits = 0;  \n\n\t \n\tif (aura_id < pfvf->hw.rqpool_cnt && !is_otx2_lbkvf(pfvf->pdev)) {\n\t\taq->aura.bp_ena = 0;\n\t\t \n\t\tif (pfvf->nix_blkaddr == BLKADDR_NIX1)\n\t\t\taq->aura.bp_ena = 1;\n#ifdef CONFIG_DCB\n\t\taq->aura.nix0_bpid = pfvf->bpid[pfvf->queue_to_pfc_map[aura_id]];\n#else\n\t\taq->aura.nix0_bpid = pfvf->bpid[0];\n#endif\n\n\t\t \n\t\taq->aura.bp = RQ_BP_LVL_AURA;\n\t}\n\n\t \n\taq->ctype = NPA_AQ_CTYPE_AURA;\n\taq->op = NPA_AQ_INSTOP_INIT;\n\n\treturn 0;\n}\n\nint otx2_pool_init(struct otx2_nic *pfvf, u16 pool_id,\n\t\t   int stack_pages, int numptrs, int buf_size, int type)\n{\n\tstruct page_pool_params pp_params = { 0 };\n\tstruct npa_aq_enq_req *aq;\n\tstruct otx2_pool *pool;\n\tint err;\n\n\tpool = &pfvf->qset.pool[pool_id];\n\t \n\terr = qmem_alloc(pfvf->dev, &pool->stack,\n\t\t\t stack_pages, pfvf->hw.stack_pg_bytes);\n\tif (err)\n\t\treturn err;\n\n\tpool->rbsize = buf_size;\n\n\t \n\taq = otx2_mbox_alloc_msg_npa_aq_enq(&pfvf->mbox);\n\tif (!aq) {\n\t\t \n\t\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\t\tif (err) {\n\t\t\tqmem_free(pfvf->dev, pool->stack);\n\t\t\treturn err;\n\t\t}\n\t\taq = otx2_mbox_alloc_msg_npa_aq_enq(&pfvf->mbox);\n\t\tif (!aq) {\n\t\t\tqmem_free(pfvf->dev, pool->stack);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\taq->aura_id = pool_id;\n\taq->pool.stack_base = pool->stack->iova;\n\taq->pool.stack_caching = 1;\n\taq->pool.ena = 1;\n\taq->pool.buf_size = buf_size / 128;\n\taq->pool.stack_max_pages = stack_pages;\n\taq->pool.shift = ilog2(numptrs) - 8;\n\taq->pool.ptr_start = 0;\n\taq->pool.ptr_end = ~0ULL;\n\n\t \n\taq->ctype = NPA_AQ_CTYPE_POOL;\n\taq->op = NPA_AQ_INSTOP_INIT;\n\n\tif (type != AURA_NIX_RQ) {\n\t\tpool->page_pool = NULL;\n\t\treturn 0;\n\t}\n\n\tpp_params.order = get_order(buf_size);\n\tpp_params.flags = PP_FLAG_PAGE_FRAG | PP_FLAG_DMA_MAP;\n\tpp_params.pool_size = min(OTX2_PAGE_POOL_SZ, numptrs);\n\tpp_params.nid = NUMA_NO_NODE;\n\tpp_params.dev = pfvf->dev;\n\tpp_params.dma_dir = DMA_FROM_DEVICE;\n\tpool->page_pool = page_pool_create(&pp_params);\n\tif (IS_ERR(pool->page_pool)) {\n\t\tnetdev_err(pfvf->netdev, \"Creation of page pool failed\\n\");\n\t\treturn PTR_ERR(pool->page_pool);\n\t}\n\n\treturn 0;\n}\n\nint otx2_sq_aura_pool_init(struct otx2_nic *pfvf)\n{\n\tint qidx, pool_id, stack_pages, num_sqbs;\n\tstruct otx2_qset *qset = &pfvf->qset;\n\tstruct otx2_hw *hw = &pfvf->hw;\n\tstruct otx2_snd_queue *sq;\n\tstruct otx2_pool *pool;\n\tdma_addr_t bufptr;\n\tint err, ptr;\n\n\t \n\tnum_sqbs = (hw->sqb_size / 128) - 1;\n\tnum_sqbs = (qset->sqe_cnt + num_sqbs) / num_sqbs;\n\n\t \n\tstack_pages =\n\t\t(num_sqbs + hw->stack_pg_ptrs - 1) / hw->stack_pg_ptrs;\n\n\tfor (qidx = 0; qidx < hw->non_qos_queues; qidx++) {\n\t\tpool_id = otx2_get_pool_idx(pfvf, AURA_NIX_SQ, qidx);\n\t\t \n\t\terr = otx2_aura_init(pfvf, pool_id, pool_id, num_sqbs);\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\t \n\t\terr = otx2_pool_init(pfvf, pool_id, stack_pages,\n\t\t\t\t     num_sqbs, hw->sqb_size, AURA_NIX_SQ);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\t \n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (err)\n\t\tgoto fail;\n\n\t \n\tfor (qidx = 0; qidx < hw->non_qos_queues; qidx++) {\n\t\tpool_id = otx2_get_pool_idx(pfvf, AURA_NIX_SQ, qidx);\n\t\tpool = &pfvf->qset.pool[pool_id];\n\n\t\tsq = &qset->sq[qidx];\n\t\tsq->sqb_count = 0;\n\t\tsq->sqb_ptrs = kcalloc(num_sqbs, sizeof(*sq->sqb_ptrs), GFP_KERNEL);\n\t\tif (!sq->sqb_ptrs) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_mem;\n\t\t}\n\n\t\tfor (ptr = 0; ptr < num_sqbs; ptr++) {\n\t\t\terr = otx2_alloc_rbuf(pfvf, pool, &bufptr);\n\t\t\tif (err)\n\t\t\t\tgoto err_mem;\n\t\t\tpfvf->hw_ops->aura_freeptr(pfvf, pool_id, bufptr);\n\t\t\tsq->sqb_ptrs[sq->sqb_count++] = (u64)bufptr;\n\t\t}\n\t}\n\nerr_mem:\n\treturn err ? -ENOMEM : 0;\n\nfail:\n\totx2_mbox_reset(&pfvf->mbox.mbox, 0);\n\totx2_aura_pool_free(pfvf);\n\treturn err;\n}\n\nint otx2_rq_aura_pool_init(struct otx2_nic *pfvf)\n{\n\tstruct otx2_hw *hw = &pfvf->hw;\n\tint stack_pages, pool_id, rq;\n\tstruct otx2_pool *pool;\n\tint err, ptr, num_ptrs;\n\tdma_addr_t bufptr;\n\n\tnum_ptrs = pfvf->qset.rqe_cnt;\n\n\tstack_pages =\n\t\t(num_ptrs + hw->stack_pg_ptrs - 1) / hw->stack_pg_ptrs;\n\n\tfor (rq = 0; rq < hw->rx_queues; rq++) {\n\t\tpool_id = otx2_get_pool_idx(pfvf, AURA_NIX_RQ, rq);\n\t\t \n\t\terr = otx2_aura_init(pfvf, pool_id, pool_id, num_ptrs);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\tfor (pool_id = 0; pool_id < hw->rqpool_cnt; pool_id++) {\n\t\terr = otx2_pool_init(pfvf, pool_id, stack_pages,\n\t\t\t\t     num_ptrs, pfvf->rbsize, AURA_NIX_RQ);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\t \n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (err)\n\t\tgoto fail;\n\n\t \n\tfor (pool_id = 0; pool_id < hw->rqpool_cnt; pool_id++) {\n\t\tpool = &pfvf->qset.pool[pool_id];\n\t\tfor (ptr = 0; ptr < num_ptrs; ptr++) {\n\t\t\terr = otx2_alloc_rbuf(pfvf, pool, &bufptr);\n\t\t\tif (err)\n\t\t\t\treturn -ENOMEM;\n\t\t\tpfvf->hw_ops->aura_freeptr(pfvf, pool_id,\n\t\t\t\t\t\t   bufptr + OTX2_HEAD_ROOM);\n\t\t}\n\t}\n\treturn 0;\nfail:\n\totx2_mbox_reset(&pfvf->mbox.mbox, 0);\n\totx2_aura_pool_free(pfvf);\n\treturn err;\n}\n\nint otx2_config_npa(struct otx2_nic *pfvf)\n{\n\tstruct otx2_qset *qset = &pfvf->qset;\n\tstruct npa_lf_alloc_req  *npalf;\n\tstruct otx2_hw *hw = &pfvf->hw;\n\tint aura_cnt;\n\n\t \n\n\tif (!hw->pool_cnt)\n\t\treturn -EINVAL;\n\n\tqset->pool = devm_kcalloc(pfvf->dev, hw->pool_cnt,\n\t\t\t\t  sizeof(struct otx2_pool), GFP_KERNEL);\n\tif (!qset->pool)\n\t\treturn -ENOMEM;\n\n\t \n\tnpalf = otx2_mbox_alloc_msg_npa_lf_alloc(&pfvf->mbox);\n\tif (!npalf)\n\t\treturn -ENOMEM;\n\n\t \n\tnpalf->nr_pools = hw->pool_cnt;\n\taura_cnt = ilog2(roundup_pow_of_two(hw->pool_cnt));\n\tnpalf->aura_sz = (aura_cnt >= ilog2(128)) ? (aura_cnt - 6) : 1;\n\n\treturn otx2_sync_mbox_msg(&pfvf->mbox);\n}\n\nint otx2_detach_resources(struct mbox *mbox)\n{\n\tstruct rsrc_detach *detach;\n\n\tmutex_lock(&mbox->lock);\n\tdetach = otx2_mbox_alloc_msg_detach_resources(mbox);\n\tif (!detach) {\n\t\tmutex_unlock(&mbox->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdetach->partial = false;\n\n\t \n\totx2_mbox_msg_send(&mbox->mbox, 0);\n\tmutex_unlock(&mbox->lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(otx2_detach_resources);\n\nint otx2_attach_npa_nix(struct otx2_nic *pfvf)\n{\n\tstruct rsrc_attach *attach;\n\tstruct msg_req *msix;\n\tint err;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\t \n\tattach = otx2_mbox_alloc_msg_attach_resources(&pfvf->mbox);\n\tif (!attach) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tattach->npalf = true;\n\tattach->nixlf = true;\n\n\t \n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (err) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn err;\n\t}\n\n\tpfvf->nix_blkaddr = BLKADDR_NIX0;\n\n\t \n\tif (otx2_read64(pfvf, RVU_PF_BLOCK_ADDRX_DISC(BLKADDR_NIX1)) & 0x1FFULL)\n\t\tpfvf->nix_blkaddr = BLKADDR_NIX1;\n\n\t \n\tmsix = otx2_mbox_alloc_msg_msix_offset(&pfvf->mbox);\n\tif (!msix) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (err) {\n\t\tmutex_unlock(&pfvf->mbox.lock);\n\t\treturn err;\n\t}\n\tmutex_unlock(&pfvf->mbox.lock);\n\n\tif (pfvf->hw.npa_msixoff == MSIX_VECTOR_INVALID ||\n\t    pfvf->hw.nix_msixoff == MSIX_VECTOR_INVALID) {\n\t\tdev_err(pfvf->dev,\n\t\t\t\"RVUPF: Invalid MSIX vector offset for NPA/NIX\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(otx2_attach_npa_nix);\n\nvoid otx2_ctx_disable(struct mbox *mbox, int type, bool npa)\n{\n\tstruct hwctx_disable_req *req;\n\n\tmutex_lock(&mbox->lock);\n\t \n\tif (npa)\n\t\treq = otx2_mbox_alloc_msg_npa_hwctx_disable(mbox);\n\telse\n\t\treq = otx2_mbox_alloc_msg_nix_hwctx_disable(mbox);\n\n\tif (!req) {\n\t\tmutex_unlock(&mbox->lock);\n\t\treturn;\n\t}\n\n\treq->ctype = type;\n\n\tif (otx2_sync_mbox_msg(mbox))\n\t\tdev_err(mbox->pfvf->dev, \"%s failed to disable context\\n\",\n\t\t\t__func__);\n\n\tmutex_unlock(&mbox->lock);\n}\n\nint otx2_nix_config_bp(struct otx2_nic *pfvf, bool enable)\n{\n\tstruct nix_bp_cfg_req *req;\n\n\tif (enable)\n\t\treq = otx2_mbox_alloc_msg_nix_bp_enable(&pfvf->mbox);\n\telse\n\t\treq = otx2_mbox_alloc_msg_nix_bp_disable(&pfvf->mbox);\n\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->chan_base = 0;\n#ifdef CONFIG_DCB\n\treq->chan_cnt = pfvf->pfc_en ? IEEE_8021QAZ_MAX_TCS : 1;\n\treq->bpid_per_chan = pfvf->pfc_en ? 1 : 0;\n#else\n\treq->chan_cnt =  1;\n\treq->bpid_per_chan = 0;\n#endif\n\n\treturn otx2_sync_mbox_msg(&pfvf->mbox);\n}\nEXPORT_SYMBOL(otx2_nix_config_bp);\n\n \nvoid mbox_handler_cgx_stats(struct otx2_nic *pfvf,\n\t\t\t    struct cgx_stats_rsp *rsp)\n{\n\tint id;\n\n\tfor (id = 0; id < CGX_RX_STATS_COUNT; id++)\n\t\tpfvf->hw.cgx_rx_stats[id] = rsp->rx_stats[id];\n\tfor (id = 0; id < CGX_TX_STATS_COUNT; id++)\n\t\tpfvf->hw.cgx_tx_stats[id] = rsp->tx_stats[id];\n}\n\nvoid mbox_handler_cgx_fec_stats(struct otx2_nic *pfvf,\n\t\t\t\tstruct cgx_fec_stats_rsp *rsp)\n{\n\tpfvf->hw.cgx_fec_corr_blks += rsp->fec_corr_blks;\n\tpfvf->hw.cgx_fec_uncorr_blks += rsp->fec_uncorr_blks;\n}\n\nvoid mbox_handler_npa_lf_alloc(struct otx2_nic *pfvf,\n\t\t\t       struct npa_lf_alloc_rsp *rsp)\n{\n\tpfvf->hw.stack_pg_ptrs = rsp->stack_pg_ptrs;\n\tpfvf->hw.stack_pg_bytes = rsp->stack_pg_bytes;\n}\nEXPORT_SYMBOL(mbox_handler_npa_lf_alloc);\n\nvoid mbox_handler_nix_lf_alloc(struct otx2_nic *pfvf,\n\t\t\t       struct nix_lf_alloc_rsp *rsp)\n{\n\tpfvf->hw.sqb_size = rsp->sqb_size;\n\tpfvf->hw.rx_chan_base = rsp->rx_chan_base;\n\tpfvf->hw.tx_chan_base = rsp->tx_chan_base;\n\tpfvf->hw.lso_tsov4_idx = rsp->lso_tsov4_idx;\n\tpfvf->hw.lso_tsov6_idx = rsp->lso_tsov6_idx;\n\tpfvf->hw.cgx_links = rsp->cgx_links;\n\tpfvf->hw.lbk_links = rsp->lbk_links;\n\tpfvf->hw.tx_link = rsp->tx_link;\n}\nEXPORT_SYMBOL(mbox_handler_nix_lf_alloc);\n\nvoid mbox_handler_msix_offset(struct otx2_nic *pfvf,\n\t\t\t      struct msix_offset_rsp *rsp)\n{\n\tpfvf->hw.npa_msixoff = rsp->npa_msixoff;\n\tpfvf->hw.nix_msixoff = rsp->nix_msixoff;\n}\nEXPORT_SYMBOL(mbox_handler_msix_offset);\n\nvoid mbox_handler_nix_bp_enable(struct otx2_nic *pfvf,\n\t\t\t\tstruct nix_bp_cfg_rsp *rsp)\n{\n\tint chan, chan_id;\n\n\tfor (chan = 0; chan < rsp->chan_cnt; chan++) {\n\t\tchan_id = ((rsp->chan_bpid[chan] >> 10) & 0x7F);\n\t\tpfvf->bpid[chan_id] = rsp->chan_bpid[chan] & 0x3FF;\n\t}\n}\nEXPORT_SYMBOL(mbox_handler_nix_bp_enable);\n\nvoid otx2_free_cints(struct otx2_nic *pfvf, int n)\n{\n\tstruct otx2_qset *qset = &pfvf->qset;\n\tstruct otx2_hw *hw = &pfvf->hw;\n\tint irq, qidx;\n\n\tfor (qidx = 0, irq = hw->nix_msixoff + NIX_LF_CINT_VEC_START;\n\t     qidx < n;\n\t     qidx++, irq++) {\n\t\tint vector = pci_irq_vector(pfvf->pdev, irq);\n\n\t\tirq_set_affinity_hint(vector, NULL);\n\t\tfree_cpumask_var(hw->affinity_mask[irq]);\n\t\tfree_irq(vector, &qset->napi[qidx]);\n\t}\n}\n\nvoid otx2_set_cints_affinity(struct otx2_nic *pfvf)\n{\n\tstruct otx2_hw *hw = &pfvf->hw;\n\tint vec, cpu, irq, cint;\n\n\tvec = hw->nix_msixoff + NIX_LF_CINT_VEC_START;\n\tcpu = cpumask_first(cpu_online_mask);\n\n\t \n\tfor (cint = 0; cint < pfvf->hw.cint_cnt; cint++, vec++) {\n\t\tif (!alloc_cpumask_var(&hw->affinity_mask[vec], GFP_KERNEL))\n\t\t\treturn;\n\n\t\tcpumask_set_cpu(cpu, hw->affinity_mask[vec]);\n\n\t\tirq = pci_irq_vector(pfvf->pdev, vec);\n\t\tirq_set_affinity_hint(irq, hw->affinity_mask[vec]);\n\n\t\tcpu = cpumask_next(cpu, cpu_online_mask);\n\t\tif (unlikely(cpu >= nr_cpu_ids))\n\t\t\tcpu = 0;\n\t}\n}\n\nstatic u32 get_dwrr_mtu(struct otx2_nic *pfvf, struct nix_hw_info *hw)\n{\n\tif (is_otx2_lbkvf(pfvf->pdev)) {\n\t\tpfvf->hw.smq_link_type = SMQ_LINK_TYPE_LBK;\n\t\treturn hw->lbk_dwrr_mtu;\n\t}\n\n\tpfvf->hw.smq_link_type = SMQ_LINK_TYPE_RPM;\n\treturn hw->rpm_dwrr_mtu;\n}\n\nu16 otx2_get_max_mtu(struct otx2_nic *pfvf)\n{\n\tstruct nix_hw_info *rsp;\n\tstruct msg_req *req;\n\tu16 max_mtu;\n\tint rc;\n\n\tmutex_lock(&pfvf->mbox.lock);\n\n\treq = otx2_mbox_alloc_msg_nix_get_hw_info(&pfvf->mbox);\n\tif (!req) {\n\t\trc =  -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = otx2_sync_mbox_msg(&pfvf->mbox);\n\tif (!rc) {\n\t\trsp = (struct nix_hw_info *)\n\t\t       otx2_mbox_get_rsp(&pfvf->mbox.mbox, 0, &req->hdr);\n\n\t\t \n\t\tmax_mtu = rsp->max_mtu - 8 - OTX2_ETH_HLEN;\n\n\t\t \n\t\tpfvf->hw.dwrr_mtu = get_dwrr_mtu(pfvf, rsp);\n\t\tif (!pfvf->hw.dwrr_mtu)\n\t\t\tpfvf->hw.dwrr_mtu = 1;\n\t}\n\nout:\n\tmutex_unlock(&pfvf->mbox.lock);\n\tif (rc) {\n\t\tdev_warn(pfvf->dev,\n\t\t\t \"Failed to get MTU from hardware setting default value(1500)\\n\");\n\t\tmax_mtu = 1500;\n\t}\n\treturn max_mtu;\n}\nEXPORT_SYMBOL(otx2_get_max_mtu);\n\nint otx2_handle_ntuple_tc_features(struct net_device *netdev, netdev_features_t features)\n{\n\tnetdev_features_t changed = features ^ netdev->features;\n\tstruct otx2_nic *pfvf = netdev_priv(netdev);\n\tbool ntuple = !!(features & NETIF_F_NTUPLE);\n\tbool tc = !!(features & NETIF_F_HW_TC);\n\n\tif ((changed & NETIF_F_NTUPLE) && !ntuple)\n\t\totx2_destroy_ntuple_flows(pfvf);\n\n\tif ((changed & NETIF_F_NTUPLE) && ntuple) {\n\t\tif (!pfvf->flow_cfg->max_flows) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Can't enable NTUPLE, MCAM entries not allocated\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif ((changed & NETIF_F_HW_TC) && !tc &&\n\t    otx2_tc_flower_rule_cnt(pfvf)) {\n\t\tnetdev_err(netdev, \"Can't disable TC hardware offload while flows are active\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif ((changed & NETIF_F_NTUPLE) && ntuple &&\n\t    otx2_tc_flower_rule_cnt(pfvf) && !(changed & NETIF_F_HW_TC)) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Can't enable NTUPLE when TC flower offload is active, disable TC rules and retry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(otx2_handle_ntuple_tc_features);\n\n#define M(_name, _id, _fn_name, _req_type, _rsp_type)\t\t\t\\\nint __weak\t\t\t\t\t\t\t\t\\\notx2_mbox_up_handler_ ## _fn_name(struct otx2_nic *pfvf,\t\t\\\n\t\t\t\tstruct _req_type *req,\t\t\t\\\n\t\t\t\tstruct _rsp_type *rsp)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(otx2_mbox_up_handler_ ## _fn_name);\nMBOX_UP_CGX_MESSAGES\nMBOX_UP_MCS_MESSAGES\n#undef M\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}