{
  "module_name": "mvneta_bm.c",
  "hash_id": "227d35d440112b20562b9cf4693554978b0727e5b03c6009832e599791e3379d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/mvneta_bm.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/genalloc.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mbus.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/skbuff.h>\n#include <net/hwbm.h>\n#include \"mvneta_bm.h\"\n\n#define MVNETA_BM_DRIVER_NAME \"mvneta_bm\"\n#define MVNETA_BM_DRIVER_VERSION \"1.0\"\n\nstatic void mvneta_bm_write(struct mvneta_bm *priv, u32 offset, u32 data)\n{\n\twritel(data, priv->reg_base + offset);\n}\n\nstatic u32 mvneta_bm_read(struct mvneta_bm *priv, u32 offset)\n{\n\treturn readl(priv->reg_base + offset);\n}\n\nstatic void mvneta_bm_pool_enable(struct mvneta_bm *priv, int pool_id)\n{\n\tu32 val;\n\n\tval = mvneta_bm_read(priv, MVNETA_BM_POOL_BASE_REG(pool_id));\n\tval |= MVNETA_BM_POOL_ENABLE_MASK;\n\tmvneta_bm_write(priv, MVNETA_BM_POOL_BASE_REG(pool_id), val);\n\n\t \n\tmvneta_bm_write(priv, MVNETA_BM_INTR_CAUSE_REG, 0);\n}\n\nstatic void mvneta_bm_pool_disable(struct mvneta_bm *priv, int pool_id)\n{\n\tu32 val;\n\n\tval = mvneta_bm_read(priv, MVNETA_BM_POOL_BASE_REG(pool_id));\n\tval &= ~MVNETA_BM_POOL_ENABLE_MASK;\n\tmvneta_bm_write(priv, MVNETA_BM_POOL_BASE_REG(pool_id), val);\n}\n\nstatic inline void mvneta_bm_config_set(struct mvneta_bm *priv, u32 mask)\n{\n\tu32 val;\n\n\tval = mvneta_bm_read(priv, MVNETA_BM_CONFIG_REG);\n\tval |= mask;\n\tmvneta_bm_write(priv, MVNETA_BM_CONFIG_REG, val);\n}\n\nstatic inline void mvneta_bm_config_clear(struct mvneta_bm *priv, u32 mask)\n{\n\tu32 val;\n\n\tval = mvneta_bm_read(priv, MVNETA_BM_CONFIG_REG);\n\tval &= ~mask;\n\tmvneta_bm_write(priv, MVNETA_BM_CONFIG_REG, val);\n}\n\nstatic void mvneta_bm_pool_target_set(struct mvneta_bm *priv, int pool_id,\n\t\t\t\t      u8 target_id, u8 attr)\n{\n\tu32 val;\n\n\tval = mvneta_bm_read(priv, MVNETA_BM_XBAR_POOL_REG(pool_id));\n\tval &= ~MVNETA_BM_TARGET_ID_MASK(pool_id);\n\tval &= ~MVNETA_BM_XBAR_ATTR_MASK(pool_id);\n\tval |= MVNETA_BM_TARGET_ID_VAL(pool_id, target_id);\n\tval |= MVNETA_BM_XBAR_ATTR_VAL(pool_id, attr);\n\n\tmvneta_bm_write(priv, MVNETA_BM_XBAR_POOL_REG(pool_id), val);\n}\n\nint mvneta_bm_construct(struct hwbm_pool *hwbm_pool, void *buf)\n{\n\tstruct mvneta_bm_pool *bm_pool =\n\t\t(struct mvneta_bm_pool *)hwbm_pool->priv;\n\tstruct mvneta_bm *priv = bm_pool->priv;\n\tdma_addr_t phys_addr;\n\n\t \n\t*(u32 *)buf = (u32)buf;\n\tphys_addr = dma_map_single(&priv->pdev->dev, buf, bm_pool->buf_size,\n\t\t\t\t   DMA_FROM_DEVICE);\n\tif (unlikely(dma_mapping_error(&priv->pdev->dev, phys_addr)))\n\t\treturn -ENOMEM;\n\n\tmvneta_bm_pool_put_bp(priv, bm_pool, phys_addr);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mvneta_bm_construct);\n\n \nstatic int mvneta_bm_pool_create(struct mvneta_bm *priv,\n\t\t\t\t struct mvneta_bm_pool *bm_pool)\n{\n\tstruct platform_device *pdev = priv->pdev;\n\tu8 target_id, attr;\n\tint size_bytes, err;\n\tsize_bytes = sizeof(u32) * bm_pool->hwbm_pool.size;\n\tbm_pool->virt_addr = dma_alloc_coherent(&pdev->dev, size_bytes,\n\t\t\t\t\t\t&bm_pool->phys_addr,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!bm_pool->virt_addr)\n\t\treturn -ENOMEM;\n\n\tif (!IS_ALIGNED((u32)bm_pool->virt_addr, MVNETA_BM_POOL_PTR_ALIGN)) {\n\t\tdma_free_coherent(&pdev->dev, size_bytes, bm_pool->virt_addr,\n\t\t\t\t  bm_pool->phys_addr);\n\t\tdev_err(&pdev->dev, \"BM pool %d is not %d bytes aligned\\n\",\n\t\t\tbm_pool->id, MVNETA_BM_POOL_PTR_ALIGN);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = mvebu_mbus_get_dram_win_info(bm_pool->phys_addr, &target_id,\n\t\t\t\t\t   &attr);\n\tif (err < 0) {\n\t\tdma_free_coherent(&pdev->dev, size_bytes, bm_pool->virt_addr,\n\t\t\t\t  bm_pool->phys_addr);\n\t\treturn err;\n\t}\n\n\t \n\tmvneta_bm_write(priv, MVNETA_BM_POOL_BASE_REG(bm_pool->id),\n\t\t\tbm_pool->phys_addr);\n\n\tmvneta_bm_pool_target_set(priv, bm_pool->id, target_id,  attr);\n\tmvneta_bm_pool_enable(priv, bm_pool->id);\n\n\treturn 0;\n}\n\n \nstruct mvneta_bm_pool *mvneta_bm_pool_use(struct mvneta_bm *priv, u8 pool_id,\n\t\t\t\t\t  enum mvneta_bm_type type, u8 port_id,\n\t\t\t\t\t  int pkt_size)\n{\n\tstruct mvneta_bm_pool *new_pool = &priv->bm_pools[pool_id];\n\tint num, err;\n\n\tif (new_pool->type == MVNETA_BM_LONG &&\n\t    new_pool->port_map != 1 << port_id) {\n\t\tdev_err(&priv->pdev->dev,\n\t\t\t\"long pool cannot be shared by the ports\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (new_pool->type == MVNETA_BM_SHORT && new_pool->type != type) {\n\t\tdev_err(&priv->pdev->dev,\n\t\t\t\"mixing pools' types between the ports is forbidden\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (new_pool->pkt_size == 0 || type != MVNETA_BM_SHORT)\n\t\tnew_pool->pkt_size = pkt_size;\n\n\t \n\tif (new_pool->type == MVNETA_BM_FREE) {\n\t\tstruct hwbm_pool *hwbm_pool = &new_pool->hwbm_pool;\n\n\t\tnew_pool->priv = priv;\n\t\tnew_pool->type = type;\n\t\tnew_pool->buf_size = MVNETA_RX_BUF_SIZE(new_pool->pkt_size);\n\t\thwbm_pool->frag_size =\n\t\t\tSKB_DATA_ALIGN(MVNETA_RX_BUF_SIZE(new_pool->pkt_size)) +\n\t\t\tSKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\t\thwbm_pool->construct = mvneta_bm_construct;\n\t\thwbm_pool->priv = new_pool;\n\t\tmutex_init(&hwbm_pool->buf_lock);\n\n\t\t \n\t\terr = mvneta_bm_pool_create(priv, new_pool);\n\t\tif (err) {\n\t\t\tdev_err(&priv->pdev->dev, \"fail to create pool %d\\n\",\n\t\t\t\tnew_pool->id);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tnum = hwbm_pool_add(hwbm_pool, hwbm_pool->size);\n\t\tif (num != hwbm_pool->size) {\n\t\t\tWARN(1, \"pool %d: %d of %d allocated\\n\",\n\t\t\t     new_pool->id, num, hwbm_pool->size);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn new_pool;\n}\nEXPORT_SYMBOL_GPL(mvneta_bm_pool_use);\n\n \nvoid mvneta_bm_bufs_free(struct mvneta_bm *priv, struct mvneta_bm_pool *bm_pool,\n\t\t\t u8 port_map)\n{\n\tint i;\n\n\tbm_pool->port_map &= ~port_map;\n\tif (bm_pool->port_map)\n\t\treturn;\n\n\tmvneta_bm_config_set(priv, MVNETA_BM_EMPTY_LIMIT_MASK);\n\n\tfor (i = 0; i < bm_pool->hwbm_pool.buf_num; i++) {\n\t\tdma_addr_t buf_phys_addr;\n\t\tu32 *vaddr;\n\n\t\t \n\t\tbuf_phys_addr = mvneta_bm_pool_get_bp(priv, bm_pool);\n\n\t\t \n\t\tif (buf_phys_addr == 0)\n\t\t\tcontinue;\n\n\t\tvaddr = phys_to_virt(buf_phys_addr);\n\t\tif (!vaddr)\n\t\t\tbreak;\n\n\t\tdma_unmap_single(&priv->pdev->dev, buf_phys_addr,\n\t\t\t\t bm_pool->buf_size, DMA_FROM_DEVICE);\n\t\thwbm_buf_free(&bm_pool->hwbm_pool, vaddr);\n\t}\n\n\tmvneta_bm_config_clear(priv, MVNETA_BM_EMPTY_LIMIT_MASK);\n\n\t \n\tbm_pool->hwbm_pool.buf_num -= i;\n}\nEXPORT_SYMBOL_GPL(mvneta_bm_bufs_free);\n\n \nvoid mvneta_bm_pool_destroy(struct mvneta_bm *priv,\n\t\t\t    struct mvneta_bm_pool *bm_pool, u8 port_map)\n{\n\tstruct hwbm_pool *hwbm_pool = &bm_pool->hwbm_pool;\n\tbm_pool->port_map &= ~port_map;\n\tif (bm_pool->port_map)\n\t\treturn;\n\n\tbm_pool->type = MVNETA_BM_FREE;\n\n\tmvneta_bm_bufs_free(priv, bm_pool, port_map);\n\tif (hwbm_pool->buf_num)\n\t\tWARN(1, \"cannot free all buffers in pool %d\\n\", bm_pool->id);\n\n\tif (bm_pool->virt_addr) {\n\t\tdma_free_coherent(&priv->pdev->dev,\n\t\t\t\t  sizeof(u32) * hwbm_pool->size,\n\t\t\t\t  bm_pool->virt_addr, bm_pool->phys_addr);\n\t\tbm_pool->virt_addr = NULL;\n\t}\n\n\tmvneta_bm_pool_disable(priv, bm_pool->id);\n}\nEXPORT_SYMBOL_GPL(mvneta_bm_pool_destroy);\n\nstatic void mvneta_bm_pools_init(struct mvneta_bm *priv)\n{\n\tstruct device_node *dn = priv->pdev->dev.of_node;\n\tstruct mvneta_bm_pool *bm_pool;\n\tchar prop[15];\n\tu32 size;\n\tint i;\n\n\t \n\tmvneta_bm_write(priv, MVNETA_BM_COMMAND_REG, MVNETA_BM_START_MASK);\n\n\t \n\tfor (i = 0; i < MVNETA_BM_POOLS_NUM; i++) {\n\t\tbm_pool = &priv->bm_pools[i];\n\t\tbm_pool->id = i;\n\t\tbm_pool->type = MVNETA_BM_FREE;\n\n\t\t \n\t\tmvneta_bm_write(priv, MVNETA_BM_POOL_READ_PTR_REG(i), 0);\n\n\t\t \n\t\tmvneta_bm_write(priv, MVNETA_BM_POOL_WRITE_PTR_REG(i), 0);\n\n\t\t \n\t\tsprintf(prop, \"pool%d,capacity\", i);\n\t\tif (of_property_read_u32(dn, prop, &size)) {\n\t\t\tsize = MVNETA_BM_POOL_CAP_DEF;\n\t\t} else if (size > MVNETA_BM_POOL_CAP_MAX) {\n\t\t\tdev_warn(&priv->pdev->dev,\n\t\t\t\t \"Illegal pool %d capacity %d, set to %d\\n\",\n\t\t\t\t i, size, MVNETA_BM_POOL_CAP_MAX);\n\t\t\tsize = MVNETA_BM_POOL_CAP_MAX;\n\t\t} else if (size < MVNETA_BM_POOL_CAP_MIN) {\n\t\t\tdev_warn(&priv->pdev->dev,\n\t\t\t\t \"Illegal pool %d capacity %d, set to %d\\n\",\n\t\t\t\t i, size, MVNETA_BM_POOL_CAP_MIN);\n\t\t\tsize = MVNETA_BM_POOL_CAP_MIN;\n\t\t} else if (!IS_ALIGNED(size, MVNETA_BM_POOL_CAP_ALIGN)) {\n\t\t\tdev_warn(&priv->pdev->dev,\n\t\t\t\t \"Illegal pool %d capacity %d, round to %d\\n\",\n\t\t\t\t i, size, ALIGN(size,\n\t\t\t\t MVNETA_BM_POOL_CAP_ALIGN));\n\t\t\tsize = ALIGN(size, MVNETA_BM_POOL_CAP_ALIGN);\n\t\t}\n\t\tbm_pool->hwbm_pool.size = size;\n\n\t\tmvneta_bm_write(priv, MVNETA_BM_POOL_SIZE_REG(i),\n\t\t\t\tbm_pool->hwbm_pool.size);\n\n\t\t \n\t\tsprintf(prop, \"pool%d,pkt-size\", i);\n\t\tif (of_property_read_u32(dn, prop, &bm_pool->pkt_size))\n\t\t\tbm_pool->pkt_size = 0;\n\t}\n}\n\nstatic void mvneta_bm_default_set(struct mvneta_bm *priv)\n{\n\tu32 val;\n\n\t \n\tmvneta_bm_write(priv, MVNETA_BM_INTR_MASK_REG, 0);\n\n\t \n\tmvneta_bm_write(priv, MVNETA_BM_INTR_CAUSE_REG, 0);\n\n\t \n\tval = mvneta_bm_read(priv, MVNETA_BM_CONFIG_REG);\n\n\t \n\tval &= ~MVNETA_BM_MAX_IN_BURST_SIZE_MASK;\n\tval |= MVNETA_BM_MAX_IN_BURST_SIZE_16BP;\n\tmvneta_bm_write(priv, MVNETA_BM_CONFIG_REG, val);\n}\n\nstatic int mvneta_bm_init(struct mvneta_bm *priv)\n{\n\tmvneta_bm_default_set(priv);\n\n\t \n\tpriv->bm_pools = devm_kcalloc(&priv->pdev->dev, MVNETA_BM_POOLS_NUM,\n\t\t\t\t      sizeof(struct mvneta_bm_pool),\n\t\t\t\t      GFP_KERNEL);\n\tif (!priv->bm_pools)\n\t\treturn -ENOMEM;\n\n\tmvneta_bm_pools_init(priv);\n\n\treturn 0;\n}\n\nstatic int mvneta_bm_get_sram(struct device_node *dn,\n\t\t\t      struct mvneta_bm *priv)\n{\n\tpriv->bppi_pool = of_gen_pool_get(dn, \"internal-mem\", 0);\n\tif (!priv->bppi_pool)\n\t\treturn -ENOMEM;\n\n\tpriv->bppi_virt_addr = gen_pool_dma_alloc(priv->bppi_pool,\n\t\t\t\t\t\t  MVNETA_BM_BPPI_SIZE,\n\t\t\t\t\t\t  &priv->bppi_phys_addr);\n\tif (!priv->bppi_virt_addr)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void mvneta_bm_put_sram(struct mvneta_bm *priv)\n{\n\tgen_pool_free(priv->bppi_pool, priv->bppi_phys_addr,\n\t\t      MVNETA_BM_BPPI_SIZE);\n}\n\nstruct mvneta_bm *mvneta_bm_get(struct device_node *node)\n{\n\tstruct platform_device *pdev = of_find_device_by_node(node);\n\n\treturn pdev ? platform_get_drvdata(pdev) : NULL;\n}\nEXPORT_SYMBOL_GPL(mvneta_bm_get);\n\nvoid mvneta_bm_put(struct mvneta_bm *priv)\n{\n\tplatform_device_put(priv->pdev);\n}\nEXPORT_SYMBOL_GPL(mvneta_bm_put);\n\nstatic int mvneta_bm_probe(struct platform_device *pdev)\n{\n\tstruct device_node *dn = pdev->dev.of_node;\n\tstruct mvneta_bm *priv;\n\tint err;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct mvneta_bm), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->reg_base))\n\t\treturn PTR_ERR(priv->reg_base);\n\n\tpriv->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\terr = clk_prepare_enable(priv->clk);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = mvneta_bm_get_sram(dn, priv);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to allocate internal memory\\n\");\n\t\tgoto err_clk;\n\t}\n\n\tpriv->pdev = pdev;\n\n\t \n\terr = mvneta_bm_init(priv);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to initialize controller\\n\");\n\t\tgoto err_sram;\n\t}\n\n\tdn->data = priv;\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Buffer Manager for network controller enabled\\n\");\n\n\treturn 0;\n\nerr_sram:\n\tmvneta_bm_put_sram(priv);\nerr_clk:\n\tclk_disable_unprepare(priv->clk);\n\treturn err;\n}\n\nstatic int mvneta_bm_remove(struct platform_device *pdev)\n{\n\tstruct mvneta_bm *priv = platform_get_drvdata(pdev);\n\tu8 all_ports_map = 0xff;\n\tint i = 0;\n\n\tfor (i = 0; i < MVNETA_BM_POOLS_NUM; i++) {\n\t\tstruct mvneta_bm_pool *bm_pool = &priv->bm_pools[i];\n\n\t\tmvneta_bm_pool_destroy(priv, bm_pool, all_ports_map);\n\t}\n\n\tmvneta_bm_put_sram(priv);\n\n\t \n\tmvneta_bm_write(priv, MVNETA_BM_COMMAND_REG, MVNETA_BM_STOP_MASK);\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mvneta_bm_match[] = {\n\t{ .compatible = \"marvell,armada-380-neta-bm\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mvneta_bm_match);\n\nstatic struct platform_driver mvneta_bm_driver = {\n\t.probe = mvneta_bm_probe,\n\t.remove = mvneta_bm_remove,\n\t.driver = {\n\t\t.name = MVNETA_BM_DRIVER_NAME,\n\t\t.of_match_table = mvneta_bm_match,\n\t},\n};\n\nmodule_platform_driver(mvneta_bm_driver);\n\nMODULE_DESCRIPTION(\"Marvell NETA Buffer Manager Driver - www.marvell.com\");\nMODULE_AUTHOR(\"Marcin Wojtas <mw@semihalf.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}