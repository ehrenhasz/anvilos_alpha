{
  "module_name": "octep_ctrl_mbox.c",
  "hash_id": "7a6542182998337f46e315ef0c7e31fa6b83ba7c7f27bf1fca35c251caab1497",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeon_ep/octep_ctrl_mbox.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/sched/signal.h>\n#include <linux/io.h>\n#include <linux/pci.h>\n#include <linux/etherdevice.h>\n\n#include \"octep_ctrl_mbox.h\"\n#include \"octep_config.h\"\n#include \"octep_main.h\"\n\n \n#define OCTEP_CTRL_MBOX_MSG_TIMEOUT_MS\t\t\t100\n \n#define OCTEP_CTRL_MBOX_MSG_WAIT_MS\t\t\t10\n\n \n#define OCTEP_CTRL_MBOX_INFO_SZ\t\t\t\t256\n \n#define OCTEP_CTRL_MBOX_H2FQ_INFO_SZ\t\t\t16\n \n#define OCTEP_CTRL_MBOX_F2HQ_INFO_SZ\t\t\t16\n\n#define OCTEP_CTRL_MBOX_TOTAL_INFO_SZ\t(OCTEP_CTRL_MBOX_INFO_SZ + \\\n\t\t\t\t\t OCTEP_CTRL_MBOX_H2FQ_INFO_SZ + \\\n\t\t\t\t\t OCTEP_CTRL_MBOX_F2HQ_INFO_SZ)\n\n#define OCTEP_CTRL_MBOX_INFO_MAGIC_NUM(m)\t(m)\n#define OCTEP_CTRL_MBOX_INFO_BARMEM_SZ(m)\t((m) + 8)\n#define OCTEP_CTRL_MBOX_INFO_HOST_VERSION(m)   ((m) + 16)\n#define OCTEP_CTRL_MBOX_INFO_HOST_STATUS(m)\t((m) + 24)\n#define OCTEP_CTRL_MBOX_INFO_FW_VERSION(m)     ((m) + 136)\n#define OCTEP_CTRL_MBOX_INFO_FW_STATUS(m)\t((m) + 144)\n\n#define OCTEP_CTRL_MBOX_H2FQ_INFO(m)\t((m) + OCTEP_CTRL_MBOX_INFO_SZ)\n#define OCTEP_CTRL_MBOX_H2FQ_PROD(m)\t(OCTEP_CTRL_MBOX_H2FQ_INFO(m))\n#define OCTEP_CTRL_MBOX_H2FQ_CONS(m)\t((OCTEP_CTRL_MBOX_H2FQ_INFO(m)) + 4)\n#define OCTEP_CTRL_MBOX_H2FQ_SZ(m)\t((OCTEP_CTRL_MBOX_H2FQ_INFO(m)) + 8)\n\n#define OCTEP_CTRL_MBOX_F2HQ_INFO(m)\t((m) + \\\n\t\t\t\t\t OCTEP_CTRL_MBOX_INFO_SZ + \\\n\t\t\t\t\t OCTEP_CTRL_MBOX_H2FQ_INFO_SZ)\n#define OCTEP_CTRL_MBOX_F2HQ_PROD(m)\t(OCTEP_CTRL_MBOX_F2HQ_INFO(m))\n#define OCTEP_CTRL_MBOX_F2HQ_CONS(m)\t((OCTEP_CTRL_MBOX_F2HQ_INFO(m)) + 4)\n#define OCTEP_CTRL_MBOX_F2HQ_SZ(m)\t((OCTEP_CTRL_MBOX_F2HQ_INFO(m)) + 8)\n\nstatic const u32 mbox_hdr_sz = sizeof(union octep_ctrl_mbox_msg_hdr);\n\nstatic u32 octep_ctrl_mbox_circq_inc(u32 index, u32 inc, u32 sz)\n{\n\treturn (index + inc) % sz;\n}\n\nstatic u32 octep_ctrl_mbox_circq_space(u32 pi, u32 ci, u32 sz)\n{\n\treturn sz - (abs(pi - ci) % sz);\n}\n\nstatic u32 octep_ctrl_mbox_circq_depth(u32 pi, u32 ci, u32 sz)\n{\n\treturn (abs(pi - ci) % sz);\n}\n\nint octep_ctrl_mbox_init(struct octep_ctrl_mbox *mbox)\n{\n\tu64 magic_num, status, fw_versions;\n\n\tif (!mbox)\n\t\treturn -EINVAL;\n\n\tif (!mbox->barmem) {\n\t\tpr_info(\"octep_ctrl_mbox : Invalid barmem %p\\n\", mbox->barmem);\n\t\treturn -EINVAL;\n\t}\n\n\tmagic_num = readq(OCTEP_CTRL_MBOX_INFO_MAGIC_NUM(mbox->barmem));\n\tif (magic_num != OCTEP_CTRL_MBOX_MAGIC_NUMBER) {\n\t\tpr_info(\"octep_ctrl_mbox : Invalid magic number %llx\\n\", magic_num);\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = readq(OCTEP_CTRL_MBOX_INFO_FW_STATUS(mbox->barmem));\n\tif (status != OCTEP_CTRL_MBOX_STATUS_READY) {\n\t\tpr_info(\"octep_ctrl_mbox : Firmware is not ready.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfw_versions = readq(OCTEP_CTRL_MBOX_INFO_FW_VERSION(mbox->barmem));\n\tmbox->min_fw_version = ((fw_versions & 0xffffffff00000000ull) >> 32);\n\tmbox->max_fw_version = (fw_versions & 0xffffffff);\n\tmbox->barmem_sz = readl(OCTEP_CTRL_MBOX_INFO_BARMEM_SZ(mbox->barmem));\n\n\twriteq(OCTEP_CTRL_MBOX_STATUS_INIT,\n\t       OCTEP_CTRL_MBOX_INFO_HOST_STATUS(mbox->barmem));\n\n\tmutex_init(&mbox->h2fq_lock);\n\tmutex_init(&mbox->f2hq_lock);\n\n\tmbox->h2fq.sz = readl(OCTEP_CTRL_MBOX_H2FQ_SZ(mbox->barmem));\n\tmbox->h2fq.hw_prod = OCTEP_CTRL_MBOX_H2FQ_PROD(mbox->barmem);\n\tmbox->h2fq.hw_cons = OCTEP_CTRL_MBOX_H2FQ_CONS(mbox->barmem);\n\tmbox->h2fq.hw_q = mbox->barmem + OCTEP_CTRL_MBOX_TOTAL_INFO_SZ;\n\n\tmbox->f2hq.sz = readl(OCTEP_CTRL_MBOX_F2HQ_SZ(mbox->barmem));\n\tmbox->f2hq.hw_prod = OCTEP_CTRL_MBOX_F2HQ_PROD(mbox->barmem);\n\tmbox->f2hq.hw_cons = OCTEP_CTRL_MBOX_F2HQ_CONS(mbox->barmem);\n\tmbox->f2hq.hw_q = mbox->barmem +\n\t\t\t  OCTEP_CTRL_MBOX_TOTAL_INFO_SZ +\n\t\t\t  mbox->h2fq.sz;\n\n\twriteq(mbox->version, OCTEP_CTRL_MBOX_INFO_HOST_VERSION(mbox->barmem));\n\t \n\twmb();\n\twriteq(OCTEP_CTRL_MBOX_STATUS_READY,\n\t       OCTEP_CTRL_MBOX_INFO_HOST_STATUS(mbox->barmem));\n\n\tpr_info(\"Octep ctrl mbox : Init successful.\\n\");\n\n\treturn 0;\n}\n\nstatic void\noctep_write_mbox_data(struct octep_ctrl_mbox_q *q, u32 *pi, u32 ci, void *buf, u32 w_sz)\n{\n\tu8 __iomem *qbuf;\n\tu32 cp_sz;\n\n\t \n\tqbuf = (q->hw_q + *pi);\n\tif (*pi < ci) {\n\t\t \n\t\tmemcpy_toio(qbuf, buf, w_sz);\n\t\t*pi = octep_ctrl_mbox_circq_inc(*pi, w_sz, q->sz);\n\t} else {\n\t\t \n\t\tcp_sz = min((q->sz - *pi), w_sz);\n\t\tmemcpy_toio(qbuf, buf, cp_sz);\n\t\tw_sz -= cp_sz;\n\t\t*pi = octep_ctrl_mbox_circq_inc(*pi, cp_sz, q->sz);\n\t\tif (w_sz) {\n\t\t\t \n\t\t\tbuf += cp_sz;\n\t\t\tqbuf = (q->hw_q + *pi);\n\t\t\tmemcpy_toio(qbuf, buf, w_sz);\n\t\t\t*pi = octep_ctrl_mbox_circq_inc(*pi, w_sz, q->sz);\n\t\t}\n\t}\n}\n\nint octep_ctrl_mbox_send(struct octep_ctrl_mbox *mbox, struct octep_ctrl_mbox_msg *msg)\n{\n\tstruct octep_ctrl_mbox_msg_buf *sg;\n\tstruct octep_ctrl_mbox_q *q;\n\tu32 pi, ci, buf_sz, w_sz;\n\tint s;\n\n\tif (!mbox || !msg)\n\t\treturn -EINVAL;\n\n\tif (readq(OCTEP_CTRL_MBOX_INFO_FW_STATUS(mbox->barmem)) != OCTEP_CTRL_MBOX_STATUS_READY)\n\t\treturn -EIO;\n\n\tmutex_lock(&mbox->h2fq_lock);\n\tq = &mbox->h2fq;\n\tpi = readl(q->hw_prod);\n\tci = readl(q->hw_cons);\n\n\tif (octep_ctrl_mbox_circq_space(pi, ci, q->sz) < (msg->hdr.s.sz + mbox_hdr_sz)) {\n\t\tmutex_unlock(&mbox->h2fq_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\toctep_write_mbox_data(q, &pi, ci, (void *)&msg->hdr, mbox_hdr_sz);\n\tbuf_sz = msg->hdr.s.sz;\n\tfor (s = 0; ((s < msg->sg_num) && (buf_sz > 0)); s++) {\n\t\tsg = &msg->sg_list[s];\n\t\tw_sz = (sg->sz <= buf_sz) ? sg->sz : buf_sz;\n\t\toctep_write_mbox_data(q, &pi, ci, sg->msg, w_sz);\n\t\tbuf_sz -= w_sz;\n\t}\n\twritel(pi, q->hw_prod);\n\tmutex_unlock(&mbox->h2fq_lock);\n\n\treturn 0;\n}\n\nstatic void\noctep_read_mbox_data(struct octep_ctrl_mbox_q *q, u32 pi, u32 *ci, void *buf, u32 r_sz)\n{\n\tu8 __iomem *qbuf;\n\tu32 cp_sz;\n\n\t \n\tqbuf = (q->hw_q + *ci);\n\tif (*ci < pi) {\n\t\t \n\t\tmemcpy_fromio(buf, qbuf, r_sz);\n\t\t*ci = octep_ctrl_mbox_circq_inc(*ci, r_sz, q->sz);\n\t} else {\n\t\t \n\t\tcp_sz = min((q->sz - *ci), r_sz);\n\t\tmemcpy_fromio(buf, qbuf, cp_sz);\n\t\tr_sz -= cp_sz;\n\t\t*ci = octep_ctrl_mbox_circq_inc(*ci, cp_sz, q->sz);\n\t\tif (r_sz) {\n\t\t\t \n\t\t\tbuf += cp_sz;\n\t\t\tqbuf = (q->hw_q + *ci);\n\t\t\tmemcpy_fromio(buf, qbuf, r_sz);\n\t\t\t*ci = octep_ctrl_mbox_circq_inc(*ci, r_sz, q->sz);\n\t\t}\n\t}\n}\n\nint octep_ctrl_mbox_recv(struct octep_ctrl_mbox *mbox, struct octep_ctrl_mbox_msg *msg)\n{\n\tstruct octep_ctrl_mbox_msg_buf *sg;\n\tu32 pi, ci, r_sz, buf_sz, q_depth;\n\tstruct octep_ctrl_mbox_q *q;\n\tint s;\n\n\tif (readq(OCTEP_CTRL_MBOX_INFO_FW_STATUS(mbox->barmem)) != OCTEP_CTRL_MBOX_STATUS_READY)\n\t\treturn -EIO;\n\n\tmutex_lock(&mbox->f2hq_lock);\n\tq = &mbox->f2hq;\n\tpi = readl(q->hw_prod);\n\tci = readl(q->hw_cons);\n\n\tq_depth = octep_ctrl_mbox_circq_depth(pi, ci, q->sz);\n\tif (q_depth < mbox_hdr_sz) {\n\t\tmutex_unlock(&mbox->f2hq_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\toctep_read_mbox_data(q, pi, &ci, (void *)&msg->hdr, mbox_hdr_sz);\n\tbuf_sz = msg->hdr.s.sz;\n\tfor (s = 0; ((s < msg->sg_num) && (buf_sz > 0)); s++) {\n\t\tsg = &msg->sg_list[s];\n\t\tr_sz = (sg->sz <= buf_sz) ? sg->sz : buf_sz;\n\t\toctep_read_mbox_data(q, pi, &ci, sg->msg, r_sz);\n\t\tbuf_sz -= r_sz;\n\t}\n\twritel(ci, q->hw_cons);\n\tmutex_unlock(&mbox->f2hq_lock);\n\n\treturn 0;\n}\n\nint octep_ctrl_mbox_uninit(struct octep_ctrl_mbox *mbox)\n{\n\tif (!mbox)\n\t\treturn -EINVAL;\n\tif (!mbox->barmem)\n\t\treturn -EINVAL;\n\n\twriteq(0, OCTEP_CTRL_MBOX_INFO_HOST_VERSION(mbox->barmem));\n\twriteq(OCTEP_CTRL_MBOX_STATUS_INVALID,\n\t       OCTEP_CTRL_MBOX_INFO_HOST_STATUS(mbox->barmem));\n\t \n\twmb();\n\n\tmutex_destroy(&mbox->h2fq_lock);\n\tmutex_destroy(&mbox->f2hq_lock);\n\n\tpr_info(\"Octep ctrl mbox : Uninit successful.\\n\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}