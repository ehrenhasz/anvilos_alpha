{
  "module_name": "octep_ctrl_net.c",
  "hash_id": "e5640597d38db7c9c798ac57636fe9e74fddcfb6a0f458f45cfd52a6d4ed8f76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeon_ep/octep_ctrl_net.c",
  "human_readable_source": "\n \n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/etherdevice.h>\n#include <linux/pci.h>\n#include <linux/wait.h>\n\n#include \"octep_config.h\"\n#include \"octep_main.h\"\n#include \"octep_ctrl_net.h\"\n\n \n#define OCTEP_CP_VERSION_CURRENT\tOCTEP_CP_VERSION(1, 0, 0)\n\nstatic const u32 req_hdr_sz = sizeof(union octep_ctrl_net_req_hdr);\nstatic const u32 mtu_sz = sizeof(struct octep_ctrl_net_h2f_req_cmd_mtu);\nstatic const u32 mac_sz = sizeof(struct octep_ctrl_net_h2f_req_cmd_mac);\nstatic const u32 state_sz = sizeof(struct octep_ctrl_net_h2f_req_cmd_state);\nstatic const u32 link_info_sz = sizeof(struct octep_ctrl_net_link_info);\nstatic atomic_t ctrl_net_msg_id;\n\n \nstatic const u32 octep_ctrl_net_h2f_cmd_versions[OCTEP_CTRL_NET_H2F_CMD_MAX] = {\n\t[OCTEP_CTRL_NET_H2F_CMD_INVALID ... OCTEP_CTRL_NET_H2F_CMD_LINK_INFO] =\n\t OCTEP_CP_VERSION(1, 0, 0)\n};\n\n \nstatic const u32 octep_ctrl_net_f2h_cmd_versions[OCTEP_CTRL_NET_F2H_CMD_MAX] = {\n\t[OCTEP_CTRL_NET_F2H_CMD_INVALID ... OCTEP_CTRL_NET_F2H_CMD_LINK_STATUS] =\n\t OCTEP_CP_VERSION(1, 0, 0)\n};\n\nstatic void init_send_req(struct octep_ctrl_mbox_msg *msg, void *buf,\n\t\t\t  u16 sz, int vfid)\n{\n\tmsg->hdr.s.flags = OCTEP_CTRL_MBOX_MSG_HDR_FLAG_REQ;\n\tmsg->hdr.s.msg_id = atomic_inc_return(&ctrl_net_msg_id) &\n\t\t\t    GENMASK(sizeof(msg->hdr.s.msg_id) * BITS_PER_BYTE, 0);\n\tmsg->hdr.s.sz = req_hdr_sz + sz;\n\tmsg->sg_num = 1;\n\tmsg->sg_list[0].msg = buf;\n\tmsg->sg_list[0].sz = msg->hdr.s.sz;\n\tif (vfid != OCTEP_CTRL_NET_INVALID_VFID) {\n\t\tmsg->hdr.s.is_vf = 1;\n\t\tmsg->hdr.s.vf_idx = vfid;\n\t}\n}\n\nstatic int octep_send_mbox_req(struct octep_device *oct,\n\t\t\t       struct octep_ctrl_net_wait_data *d,\n\t\t\t       bool wait_for_response)\n{\n\tint err, ret, cmd;\n\n\t \n\tcmd = d->data.req.hdr.s.cmd;\n\tif (octep_ctrl_net_h2f_cmd_versions[cmd] > oct->ctrl_mbox.max_fw_version ||\n\t    octep_ctrl_net_h2f_cmd_versions[cmd] < oct->ctrl_mbox.min_fw_version)\n\t\treturn -EOPNOTSUPP;\n\n\terr = octep_ctrl_mbox_send(&oct->ctrl_mbox, &d->msg);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!wait_for_response)\n\t\treturn 0;\n\n\td->done = 0;\n\tINIT_LIST_HEAD(&d->list);\n\tlist_add_tail(&d->list, &oct->ctrl_req_wait_list);\n\tret = wait_event_interruptible_timeout(oct->ctrl_req_wait_q,\n\t\t\t\t\t       (d->done != 0),\n\t\t\t\t\t       msecs_to_jiffies(500));\n\tlist_del(&d->list);\n\tif (ret == 0 || ret == 1)\n\t\treturn -EAGAIN;\n\n\t \n\n\tif (d->data.resp.hdr.s.reply != OCTEP_CTRL_NET_REPLY_OK)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nint octep_ctrl_net_init(struct octep_device *oct)\n{\n\tstruct octep_ctrl_mbox *ctrl_mbox;\n\tstruct pci_dev *pdev = oct->pdev;\n\tint ret;\n\n\tinit_waitqueue_head(&oct->ctrl_req_wait_q);\n\tINIT_LIST_HEAD(&oct->ctrl_req_wait_list);\n\n\t \n\tctrl_mbox = &oct->ctrl_mbox;\n\tctrl_mbox->version = OCTEP_CP_VERSION_CURRENT;\n\tctrl_mbox->barmem = CFG_GET_CTRL_MBOX_MEM_ADDR(oct->conf);\n\tret = octep_ctrl_mbox_init(ctrl_mbox);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize control mbox\\n\");\n\t\treturn ret;\n\t}\n\tdev_info(&pdev->dev, \"Control plane versions host: %llx, firmware: %x:%x\\n\",\n\t\t ctrl_mbox->version, ctrl_mbox->min_fw_version,\n\t\t ctrl_mbox->max_fw_version);\n\toct->ctrl_mbox_ifstats_offset = ctrl_mbox->barmem_sz;\n\n\treturn 0;\n}\n\nint octep_ctrl_net_get_link_status(struct octep_device *oct, int vfid)\n{\n\tstruct octep_ctrl_net_wait_data d = {0};\n\tstruct octep_ctrl_net_h2f_req *req = &d.data.req;\n\tint err;\n\n\tinit_send_req(&d.msg, (void *)req, state_sz, vfid);\n\treq->hdr.s.cmd = OCTEP_CTRL_NET_H2F_CMD_LINK_STATUS;\n\treq->link.cmd = OCTEP_CTRL_NET_CMD_GET;\n\terr = octep_send_mbox_req(oct, &d, true);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn d.data.resp.link.state;\n}\n\nint octep_ctrl_net_set_link_status(struct octep_device *oct, int vfid, bool up,\n\t\t\t\t   bool wait_for_response)\n{\n\tstruct octep_ctrl_net_wait_data d = {0};\n\tstruct octep_ctrl_net_h2f_req *req = &d.data.req;\n\n\tinit_send_req(&d.msg, req, state_sz, vfid);\n\treq->hdr.s.cmd = OCTEP_CTRL_NET_H2F_CMD_LINK_STATUS;\n\treq->link.cmd = OCTEP_CTRL_NET_CMD_SET;\n\treq->link.state = (up) ? OCTEP_CTRL_NET_STATE_UP :\n\t\t\t\tOCTEP_CTRL_NET_STATE_DOWN;\n\n\treturn octep_send_mbox_req(oct, &d, wait_for_response);\n}\n\nint octep_ctrl_net_set_rx_state(struct octep_device *oct, int vfid, bool up,\n\t\t\t\tbool wait_for_response)\n{\n\tstruct octep_ctrl_net_wait_data d = {0};\n\tstruct octep_ctrl_net_h2f_req *req = &d.data.req;\n\n\tinit_send_req(&d.msg, req, state_sz, vfid);\n\treq->hdr.s.cmd = OCTEP_CTRL_NET_H2F_CMD_RX_STATE;\n\treq->link.cmd = OCTEP_CTRL_NET_CMD_SET;\n\treq->link.state = (up) ? OCTEP_CTRL_NET_STATE_UP :\n\t\t\t\tOCTEP_CTRL_NET_STATE_DOWN;\n\n\treturn octep_send_mbox_req(oct, &d, wait_for_response);\n}\n\nint octep_ctrl_net_get_mac_addr(struct octep_device *oct, int vfid, u8 *addr)\n{\n\tstruct octep_ctrl_net_wait_data d = {0};\n\tstruct octep_ctrl_net_h2f_req *req = &d.data.req;\n\tint err;\n\n\tinit_send_req(&d.msg, req, mac_sz, vfid);\n\treq->hdr.s.cmd = OCTEP_CTRL_NET_H2F_CMD_MAC;\n\treq->link.cmd = OCTEP_CTRL_NET_CMD_GET;\n\terr = octep_send_mbox_req(oct, &d, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tmemcpy(addr, d.data.resp.mac.addr, ETH_ALEN);\n\n\treturn 0;\n}\n\nint octep_ctrl_net_set_mac_addr(struct octep_device *oct, int vfid, u8 *addr,\n\t\t\t\tbool wait_for_response)\n{\n\tstruct octep_ctrl_net_wait_data d = {0};\n\tstruct octep_ctrl_net_h2f_req *req = &d.data.req;\n\n\tinit_send_req(&d.msg, req, mac_sz, vfid);\n\treq->hdr.s.cmd = OCTEP_CTRL_NET_H2F_CMD_MAC;\n\treq->mac.cmd = OCTEP_CTRL_NET_CMD_SET;\n\tmemcpy(&req->mac.addr, addr, ETH_ALEN);\n\n\treturn octep_send_mbox_req(oct, &d, wait_for_response);\n}\n\nint octep_ctrl_net_set_mtu(struct octep_device *oct, int vfid, int mtu,\n\t\t\t   bool wait_for_response)\n{\n\tstruct octep_ctrl_net_wait_data d = {0};\n\tstruct octep_ctrl_net_h2f_req *req = &d.data.req;\n\n\tinit_send_req(&d.msg, req, mtu_sz, vfid);\n\treq->hdr.s.cmd = OCTEP_CTRL_NET_H2F_CMD_MTU;\n\treq->mtu.cmd = OCTEP_CTRL_NET_CMD_SET;\n\treq->mtu.val = mtu;\n\n\treturn octep_send_mbox_req(oct, &d, wait_for_response);\n}\n\nint octep_ctrl_net_get_if_stats(struct octep_device *oct, int vfid,\n\t\t\t\tstruct octep_iface_rx_stats *rx_stats,\n\t\t\t\tstruct octep_iface_tx_stats *tx_stats)\n{\n\tstruct octep_ctrl_net_wait_data d = {0};\n\tstruct octep_ctrl_net_h2f_req *req = &d.data.req;\n\tstruct octep_ctrl_net_h2f_resp *resp;\n\tint err;\n\n\tinit_send_req(&d.msg, req, 0, vfid);\n\treq->hdr.s.cmd = OCTEP_CTRL_NET_H2F_CMD_GET_IF_STATS;\n\terr = octep_send_mbox_req(oct, &d, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tresp = &d.data.resp;\n\tmemcpy(rx_stats, &resp->if_stats.rx_stats, sizeof(struct octep_iface_rx_stats));\n\tmemcpy(tx_stats, &resp->if_stats.tx_stats, sizeof(struct octep_iface_tx_stats));\n\treturn 0;\n}\n\nint octep_ctrl_net_get_link_info(struct octep_device *oct, int vfid,\n\t\t\t\t struct octep_iface_link_info *link_info)\n{\n\tstruct octep_ctrl_net_wait_data d = {0};\n\tstruct octep_ctrl_net_h2f_req *req = &d.data.req;\n\tstruct octep_ctrl_net_h2f_resp *resp;\n\tint err;\n\n\tinit_send_req(&d.msg, req, link_info_sz, vfid);\n\treq->hdr.s.cmd = OCTEP_CTRL_NET_H2F_CMD_LINK_INFO;\n\treq->link_info.cmd = OCTEP_CTRL_NET_CMD_GET;\n\terr = octep_send_mbox_req(oct, &d, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tresp = &d.data.resp;\n\tlink_info->supported_modes = resp->link_info.supported_modes;\n\tlink_info->advertised_modes = resp->link_info.advertised_modes;\n\tlink_info->autoneg = resp->link_info.autoneg;\n\tlink_info->pause = resp->link_info.pause;\n\tlink_info->speed = resp->link_info.speed;\n\n\treturn 0;\n}\n\nint octep_ctrl_net_set_link_info(struct octep_device *oct, int vfid,\n\t\t\t\t struct octep_iface_link_info *link_info,\n\t\t\t\t bool wait_for_response)\n{\n\tstruct octep_ctrl_net_wait_data d = {0};\n\tstruct octep_ctrl_net_h2f_req *req = &d.data.req;\n\n\tinit_send_req(&d.msg, req, link_info_sz, vfid);\n\treq->hdr.s.cmd = OCTEP_CTRL_NET_H2F_CMD_LINK_INFO;\n\treq->link_info.cmd = OCTEP_CTRL_NET_CMD_SET;\n\treq->link_info.info.advertised_modes = link_info->advertised_modes;\n\treq->link_info.info.autoneg = link_info->autoneg;\n\treq->link_info.info.pause = link_info->pause;\n\treq->link_info.info.speed = link_info->speed;\n\n\treturn octep_send_mbox_req(oct, &d, wait_for_response);\n}\n\nstatic void process_mbox_resp(struct octep_device *oct,\n\t\t\t      struct octep_ctrl_mbox_msg *msg)\n{\n\tstruct octep_ctrl_net_wait_data *pos, *n;\n\n\tlist_for_each_entry_safe(pos, n, &oct->ctrl_req_wait_list, list) {\n\t\tif (pos->msg.hdr.s.msg_id == msg->hdr.s.msg_id) {\n\t\t\tmemcpy(&pos->data.resp,\n\t\t\t       msg->sg_list[0].msg,\n\t\t\t       msg->hdr.s.sz);\n\t\t\tpos->done = 1;\n\t\t\twake_up_interruptible_all(&oct->ctrl_req_wait_q);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int process_mbox_notify(struct octep_device *oct,\n\t\t\t       struct octep_ctrl_mbox_msg *msg)\n{\n\tstruct net_device *netdev = oct->netdev;\n\tstruct octep_ctrl_net_f2h_req *req;\n\tint cmd;\n\n\treq = (struct octep_ctrl_net_f2h_req *)msg->sg_list[0].msg;\n\tcmd = req->hdr.s.cmd;\n\n\t \n\tif (octep_ctrl_net_f2h_cmd_versions[cmd] > OCTEP_CP_VERSION_CURRENT ||\n\t    octep_ctrl_net_f2h_cmd_versions[cmd] < OCTEP_CP_VERSION_CURRENT)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (cmd) {\n\tcase OCTEP_CTRL_NET_F2H_CMD_LINK_STATUS:\n\t\tif (netif_running(netdev)) {\n\t\t\tif (req->link.state) {\n\t\t\t\tdev_info(&oct->pdev->dev, \"netif_carrier_on\\n\");\n\t\t\t\tnetif_carrier_on(netdev);\n\t\t\t} else {\n\t\t\t\tdev_info(&oct->pdev->dev, \"netif_carrier_off\\n\");\n\t\t\t\tnetif_carrier_off(netdev);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"Unknown mbox req : %u\\n\", req->hdr.s.cmd);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nvoid octep_ctrl_net_recv_fw_messages(struct octep_device *oct)\n{\n\tstatic u16 msg_sz = sizeof(union octep_ctrl_net_max_data);\n\tunion octep_ctrl_net_max_data data = {0};\n\tstruct octep_ctrl_mbox_msg msg = {0};\n\tint ret;\n\n\tmsg.hdr.s.sz = msg_sz;\n\tmsg.sg_num = 1;\n\tmsg.sg_list[0].sz = msg_sz;\n\tmsg.sg_list[0].msg = &data;\n\twhile (true) {\n\t\t \n\t\tmsg.hdr.s.sz = msg_sz;\n\t\tret = octep_ctrl_mbox_recv(&oct->ctrl_mbox, (struct octep_ctrl_mbox_msg *)&msg);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (msg.hdr.s.flags & OCTEP_CTRL_MBOX_MSG_HDR_FLAG_RESP)\n\t\t\tprocess_mbox_resp(oct, &msg);\n\t\telse if (msg.hdr.s.flags & OCTEP_CTRL_MBOX_MSG_HDR_FLAG_NOTIFY)\n\t\t\tprocess_mbox_notify(oct, &msg);\n\t}\n}\n\nint octep_ctrl_net_uninit(struct octep_device *oct)\n{\n\tstruct octep_ctrl_net_wait_data *pos, *n;\n\n\tlist_for_each_entry_safe(pos, n, &oct->ctrl_req_wait_list, list)\n\t\tpos->done = 1;\n\n\twake_up_interruptible_all(&oct->ctrl_req_wait_q);\n\n\toctep_ctrl_mbox_uninit(&oct->ctrl_mbox);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}