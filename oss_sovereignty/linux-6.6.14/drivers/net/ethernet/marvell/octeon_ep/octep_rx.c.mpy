{
  "module_name": "octep_rx.c",
  "hash_id": "35e418def3c99d0e8f6c420e12e7f785226ebc7ea73c5c4e83b5f25c36dc7d3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/octeon_ep/octep_rx.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/etherdevice.h>\n#include <linux/vmalloc.h>\n\n#include \"octep_config.h\"\n#include \"octep_main.h\"\n\nstatic void octep_oq_reset_indices(struct octep_oq *oq)\n{\n\toq->host_read_idx = 0;\n\toq->host_refill_idx = 0;\n\toq->refill_count = 0;\n\toq->last_pkt_count = 0;\n\toq->pkts_pending = 0;\n}\n\n \nstatic int octep_oq_fill_ring_buffers(struct octep_oq *oq)\n{\n\tstruct octep_oq_desc_hw *desc_ring = oq->desc_ring;\n\tstruct page *page;\n\tu32 i;\n\n\tfor (i = 0; i < oq->max_count; i++) {\n\t\tpage = dev_alloc_page();\n\t\tif (unlikely(!page)) {\n\t\t\tdev_err(oq->dev, \"Rx buffer alloc failed\\n\");\n\t\t\tgoto rx_buf_alloc_err;\n\t\t}\n\t\tdesc_ring[i].buffer_ptr = dma_map_page(oq->dev, page, 0,\n\t\t\t\t\t\t       PAGE_SIZE,\n\t\t\t\t\t\t       DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(oq->dev, desc_ring[i].buffer_ptr)) {\n\t\t\tdev_err(oq->dev,\n\t\t\t\t\"OQ-%d buffer alloc: DMA mapping error!\\n\",\n\t\t\t\toq->q_no);\n\t\t\tput_page(page);\n\t\t\tgoto dma_map_err;\n\t\t}\n\t\toq->buff_info[i].page = page;\n\t}\n\n\treturn 0;\n\ndma_map_err:\nrx_buf_alloc_err:\n\twhile (i) {\n\t\ti--;\n\t\tdma_unmap_page(oq->dev, desc_ring[i].buffer_ptr, PAGE_SIZE, DMA_FROM_DEVICE);\n\t\tput_page(oq->buff_info[i].page);\n\t\toq->buff_info[i].page = NULL;\n\t}\n\n\treturn -1;\n}\n\n \nstatic int octep_oq_refill(struct octep_device *oct, struct octep_oq *oq)\n{\n\tstruct octep_oq_desc_hw *desc_ring = oq->desc_ring;\n\tstruct page *page;\n\tu32 refill_idx, i;\n\n\trefill_idx = oq->host_refill_idx;\n\tfor (i = 0; i < oq->refill_count; i++) {\n\t\tpage = dev_alloc_page();\n\t\tif (unlikely(!page)) {\n\t\t\tdev_err(oq->dev, \"refill: rx buffer alloc failed\\n\");\n\t\t\toq->stats.alloc_failures++;\n\t\t\tbreak;\n\t\t}\n\n\t\tdesc_ring[refill_idx].buffer_ptr = dma_map_page(oq->dev, page, 0,\n\t\t\t\t\t\t\t\tPAGE_SIZE, DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(oq->dev, desc_ring[refill_idx].buffer_ptr)) {\n\t\t\tdev_err(oq->dev,\n\t\t\t\t\"OQ-%d buffer refill: DMA mapping error!\\n\",\n\t\t\t\toq->q_no);\n\t\t\tput_page(page);\n\t\t\toq->stats.alloc_failures++;\n\t\t\tbreak;\n\t\t}\n\t\toq->buff_info[refill_idx].page = page;\n\t\trefill_idx++;\n\t\tif (refill_idx == oq->max_count)\n\t\t\trefill_idx = 0;\n\t}\n\toq->host_refill_idx = refill_idx;\n\toq->refill_count -= i;\n\n\treturn i;\n}\n\n \nstatic int octep_setup_oq(struct octep_device *oct, int q_no)\n{\n\tstruct octep_oq *oq;\n\tu32 desc_ring_size;\n\n\toq = vzalloc(sizeof(*oq));\n\tif (!oq)\n\t\tgoto create_oq_fail;\n\toct->oq[q_no] = oq;\n\n\toq->octep_dev = oct;\n\toq->netdev = oct->netdev;\n\toq->dev = &oct->pdev->dev;\n\toq->q_no = q_no;\n\toq->max_count = CFG_GET_OQ_NUM_DESC(oct->conf);\n\toq->ring_size_mask = oq->max_count - 1;\n\toq->buffer_size = CFG_GET_OQ_BUF_SIZE(oct->conf);\n\toq->max_single_buffer_size = oq->buffer_size - OCTEP_OQ_RESP_HW_SIZE;\n\n\t \n\tif (oct->caps_enabled)\n\t\toq->max_single_buffer_size -= OCTEP_OQ_RESP_HW_EXT_SIZE;\n\n\toq->refill_threshold = CFG_GET_OQ_REFILL_THRESHOLD(oct->conf);\n\n\tdesc_ring_size = oq->max_count * OCTEP_OQ_DESC_SIZE;\n\toq->desc_ring = dma_alloc_coherent(oq->dev, desc_ring_size,\n\t\t\t\t\t   &oq->desc_ring_dma, GFP_KERNEL);\n\n\tif (unlikely(!oq->desc_ring)) {\n\t\tdev_err(oq->dev,\n\t\t\t\"Failed to allocate DMA memory for OQ-%d !!\\n\", q_no);\n\t\tgoto desc_dma_alloc_err;\n\t}\n\n\toq->buff_info = vcalloc(oq->max_count, OCTEP_OQ_RECVBUF_SIZE);\n\tif (unlikely(!oq->buff_info)) {\n\t\tdev_err(&oct->pdev->dev,\n\t\t\t\"Failed to allocate buffer info for OQ-%d\\n\", q_no);\n\t\tgoto buf_list_err;\n\t}\n\n\tif (octep_oq_fill_ring_buffers(oq))\n\t\tgoto oq_fill_buff_err;\n\n\toctep_oq_reset_indices(oq);\n\toct->hw_ops.setup_oq_regs(oct, q_no);\n\toct->num_oqs++;\n\n\treturn 0;\n\noq_fill_buff_err:\n\tvfree(oq->buff_info);\n\toq->buff_info = NULL;\nbuf_list_err:\n\tdma_free_coherent(oq->dev, desc_ring_size,\n\t\t\t  oq->desc_ring, oq->desc_ring_dma);\n\toq->desc_ring = NULL;\ndesc_dma_alloc_err:\n\tvfree(oq);\n\toct->oq[q_no] = NULL;\ncreate_oq_fail:\n\treturn -1;\n}\n\n \nstatic void octep_oq_free_ring_buffers(struct octep_oq *oq)\n{\n\tstruct octep_oq_desc_hw *desc_ring = oq->desc_ring;\n\tint  i;\n\n\tif (!oq->desc_ring || !oq->buff_info)\n\t\treturn;\n\n\tfor (i = 0; i < oq->max_count; i++)  {\n\t\tif (oq->buff_info[i].page) {\n\t\t\tdma_unmap_page(oq->dev, desc_ring[i].buffer_ptr,\n\t\t\t\t       PAGE_SIZE, DMA_FROM_DEVICE);\n\t\t\tput_page(oq->buff_info[i].page);\n\t\t\toq->buff_info[i].page = NULL;\n\t\t\tdesc_ring[i].buffer_ptr = 0;\n\t\t}\n\t}\n\toctep_oq_reset_indices(oq);\n}\n\n \nstatic int octep_free_oq(struct octep_oq *oq)\n{\n\tstruct octep_device *oct = oq->octep_dev;\n\tint q_no = oq->q_no;\n\n\toctep_oq_free_ring_buffers(oq);\n\n\tvfree(oq->buff_info);\n\n\tif (oq->desc_ring)\n\t\tdma_free_coherent(oq->dev,\n\t\t\t\t  oq->max_count * OCTEP_OQ_DESC_SIZE,\n\t\t\t\t  oq->desc_ring, oq->desc_ring_dma);\n\n\tvfree(oq);\n\toct->oq[q_no] = NULL;\n\toct->num_oqs--;\n\treturn 0;\n}\n\n \nint octep_setup_oqs(struct octep_device *oct)\n{\n\tint i, retval = 0;\n\n\toct->num_oqs = 0;\n\tfor (i = 0; i < CFG_GET_PORTS_ACTIVE_IO_RINGS(oct->conf); i++) {\n\t\tretval = octep_setup_oq(oct, i);\n\t\tif (retval) {\n\t\t\tdev_err(&oct->pdev->dev,\n\t\t\t\t\"Failed to setup OQ(RxQ)-%d.\\n\", i);\n\t\t\tgoto oq_setup_err;\n\t\t}\n\t\tdev_dbg(&oct->pdev->dev, \"Successfully setup OQ(RxQ)-%d.\\n\", i);\n\t}\n\n\treturn 0;\n\noq_setup_err:\n\twhile (i) {\n\t\ti--;\n\t\toctep_free_oq(oct->oq[i]);\n\t}\n\treturn -1;\n}\n\n \nvoid octep_oq_dbell_init(struct octep_device *oct)\n{\n\tint i;\n\n\tfor (i = 0; i < oct->num_oqs; i++)\n\t\twritel(oct->oq[i]->max_count, oct->oq[i]->pkts_credit_reg);\n}\n\n \nvoid octep_free_oqs(struct octep_device *oct)\n{\n\tint i;\n\n\tfor (i = 0; i < CFG_GET_PORTS_ACTIVE_IO_RINGS(oct->conf); i++) {\n\t\tif (!oct->oq[i])\n\t\t\tcontinue;\n\t\toctep_free_oq(oct->oq[i]);\n\t\tdev_dbg(&oct->pdev->dev,\n\t\t\t\"Successfully freed OQ(RxQ)-%d.\\n\", i);\n\t}\n}\n\n \nstatic int octep_oq_check_hw_for_pkts(struct octep_device *oct,\n\t\t\t\t      struct octep_oq *oq)\n{\n\tu32 pkt_count, new_pkts;\n\n\tpkt_count = readl(oq->pkts_sent_reg);\n\tnew_pkts = pkt_count - oq->last_pkt_count;\n\n\t \n\tif (unlikely(pkt_count > 0xF0000000U)) {\n\t\twritel(pkt_count, oq->pkts_sent_reg);\n\t\tpkt_count = readl(oq->pkts_sent_reg);\n\t\tnew_pkts += pkt_count;\n\t}\n\toq->last_pkt_count = pkt_count;\n\toq->pkts_pending += new_pkts;\n\treturn new_pkts;\n}\n\n \nstatic int __octep_oq_process_rx(struct octep_device *oct,\n\t\t\t\t struct octep_oq *oq, u16 pkts_to_process)\n{\n\tstruct octep_oq_resp_hw_ext *resp_hw_ext = NULL;\n\tstruct octep_rx_buffer *buff_info;\n\tstruct octep_oq_resp_hw *resp_hw;\n\tu32 pkt, rx_bytes, desc_used;\n\tstruct sk_buff *skb;\n\tu16 data_offset;\n\tu32 read_idx;\n\n\tread_idx = oq->host_read_idx;\n\trx_bytes = 0;\n\tdesc_used = 0;\n\tfor (pkt = 0; pkt < pkts_to_process; pkt++) {\n\t\tbuff_info = (struct octep_rx_buffer *)&oq->buff_info[read_idx];\n\t\tdma_unmap_page(oq->dev, oq->desc_ring[read_idx].buffer_ptr,\n\t\t\t       PAGE_SIZE, DMA_FROM_DEVICE);\n\t\tresp_hw = page_address(buff_info->page);\n\t\tbuff_info->page = NULL;\n\n\t\t \n\t\tbuff_info->len = be64_to_cpu(resp_hw->length);\n\t\tif (oct->caps_enabled & OCTEP_CAP_RX_CHECKSUM) {\n\t\t\t \n\t\t\tresp_hw_ext = (struct octep_oq_resp_hw_ext *)\n\t\t\t\t      (resp_hw + 1);\n\t\t\tbuff_info->len -= OCTEP_OQ_RESP_HW_EXT_SIZE;\n\t\t\t \n\t\t\tdata_offset = OCTEP_OQ_RESP_HW_SIZE +\n\t\t\t\t      OCTEP_OQ_RESP_HW_EXT_SIZE;\n\t\t} else {\n\t\t\t \n\t\t\tdata_offset = OCTEP_OQ_RESP_HW_SIZE;\n\t\t}\n\t\trx_bytes += buff_info->len;\n\n\t\tif (buff_info->len <= oq->max_single_buffer_size) {\n\t\t\tskb = build_skb((void *)resp_hw, PAGE_SIZE);\n\t\t\tskb_reserve(skb, data_offset);\n\t\t\tskb_put(skb, buff_info->len);\n\t\t\tread_idx++;\n\t\t\tdesc_used++;\n\t\t\tif (read_idx == oq->max_count)\n\t\t\t\tread_idx = 0;\n\t\t} else {\n\t\t\tstruct skb_shared_info *shinfo;\n\t\t\tu16 data_len;\n\n\t\t\tskb = build_skb((void *)resp_hw, PAGE_SIZE);\n\t\t\tskb_reserve(skb, data_offset);\n\t\t\t \n\t\t\tskb_put(skb, oq->max_single_buffer_size);\n\t\t\tread_idx++;\n\t\t\tdesc_used++;\n\t\t\tif (read_idx == oq->max_count)\n\t\t\t\tread_idx = 0;\n\n\t\t\tshinfo = skb_shinfo(skb);\n\t\t\tdata_len = buff_info->len - oq->max_single_buffer_size;\n\t\t\twhile (data_len) {\n\t\t\t\tdma_unmap_page(oq->dev, oq->desc_ring[read_idx].buffer_ptr,\n\t\t\t\t\t       PAGE_SIZE, DMA_FROM_DEVICE);\n\t\t\t\tbuff_info = (struct octep_rx_buffer *)\n\t\t\t\t\t    &oq->buff_info[read_idx];\n\t\t\t\tif (data_len < oq->buffer_size) {\n\t\t\t\t\tbuff_info->len = data_len;\n\t\t\t\t\tdata_len = 0;\n\t\t\t\t} else {\n\t\t\t\t\tbuff_info->len = oq->buffer_size;\n\t\t\t\t\tdata_len -= oq->buffer_size;\n\t\t\t\t}\n\n\t\t\t\tskb_add_rx_frag(skb, shinfo->nr_frags,\n\t\t\t\t\t\tbuff_info->page, 0,\n\t\t\t\t\t\tbuff_info->len,\n\t\t\t\t\t\tbuff_info->len);\n\t\t\t\tbuff_info->page = NULL;\n\t\t\t\tread_idx++;\n\t\t\t\tdesc_used++;\n\t\t\t\tif (read_idx == oq->max_count)\n\t\t\t\t\tread_idx = 0;\n\t\t\t}\n\t\t}\n\n\t\tskb->dev = oq->netdev;\n\t\tskb->protocol =  eth_type_trans(skb, skb->dev);\n\t\tif (resp_hw_ext &&\n\t\t    resp_hw_ext->csum_verified == OCTEP_CSUM_VERIFIED)\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\telse\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tnapi_gro_receive(oq->napi, skb);\n\t}\n\n\toq->host_read_idx = read_idx;\n\toq->refill_count += desc_used;\n\toq->stats.packets += pkt;\n\toq->stats.bytes += rx_bytes;\n\n\treturn pkt;\n}\n\n \nint octep_oq_process_rx(struct octep_oq *oq, int budget)\n{\n\tu32 pkts_available, pkts_processed, total_pkts_processed;\n\tstruct octep_device *oct = oq->octep_dev;\n\n\tpkts_available = 0;\n\tpkts_processed = 0;\n\ttotal_pkts_processed = 0;\n\twhile (total_pkts_processed < budget) {\n\t\t  \n\t\tif (oq->pkts_pending == 0)\n\t\t\toctep_oq_check_hw_for_pkts(oct, oq);\n\t\tpkts_available = min(budget - total_pkts_processed,\n\t\t\t\t     oq->pkts_pending);\n\t\tif (!pkts_available)\n\t\t\tbreak;\n\n\t\tpkts_processed = __octep_oq_process_rx(oct, oq,\n\t\t\t\t\t\t       pkts_available);\n\t\toq->pkts_pending -= pkts_processed;\n\t\ttotal_pkts_processed += pkts_processed;\n\t}\n\n\tif (oq->refill_count >= oq->refill_threshold) {\n\t\tu32 desc_refilled = octep_oq_refill(oct, oq);\n\n\t\t \n\t\twmb();\n\t\twritel(desc_refilled, oq->pkts_credit_reg);\n\t}\n\n\treturn total_pkts_processed;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}