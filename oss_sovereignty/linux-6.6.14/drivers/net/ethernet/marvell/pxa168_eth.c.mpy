{
  "module_name": "pxa168_eth.c",
  "hash_id": "0a944c20a3846337323540ac65e0b6eb9e4765c9b3578f86deba64e9515b4fae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/pxa168_eth.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/in.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pxa168_eth.h>\n#include <linux/tcp.h>\n#include <linux/types.h>\n#include <linux/udp.h>\n#include <linux/workqueue.h>\n#include <linux/pgtable.h>\n\n#include <asm/cacheflush.h>\n\n#define DRIVER_NAME\t\"pxa168-eth\"\n#define DRIVER_VERSION\t\"0.3\"\n\n \n\n#define PHY_ADDRESS\t\t0x0000\n#define SMI\t\t\t0x0010\n#define PORT_CONFIG\t\t0x0400\n#define PORT_CONFIG_EXT\t\t0x0408\n#define PORT_COMMAND\t\t0x0410\n#define PORT_STATUS\t\t0x0418\n#define HTPR\t\t\t0x0428\n#define MAC_ADDR_LOW\t\t0x0430\n#define MAC_ADDR_HIGH\t\t0x0438\n#define SDMA_CONFIG\t\t0x0440\n#define SDMA_CMD\t\t0x0448\n#define INT_CAUSE\t\t0x0450\n#define INT_W_CLEAR\t\t0x0454\n#define INT_MASK\t\t0x0458\n#define ETH_F_RX_DESC_0\t\t0x0480\n#define ETH_C_RX_DESC_0\t\t0x04A0\n#define ETH_C_TX_DESC_1\t\t0x04E4\n\n \n#define SMI_BUSY\t\t(1 << 28)\t \n#define SMI_R_VALID\t\t(1 << 27)\t \n#define SMI_OP_W\t\t(0 << 26)\t \n#define SMI_OP_R\t\t(1 << 26)\t \n\n#define PHY_WAIT_ITERATIONS\t10\n\n#define PXA168_ETH_PHY_ADDR_DEFAULT\t0\n \n#define BUF_OWNED_BY_DMA\t(1 << 31)\n\n \n#define RX_EN_INT\t\t(1 << 23)\n#define RX_FIRST_DESC\t\t(1 << 17)\n#define RX_LAST_DESC\t\t(1 << 16)\n#define RX_ERROR\t\t(1 << 15)\n\n \n#define TX_EN_INT\t\t(1 << 23)\n#define TX_GEN_CRC\t\t(1 << 22)\n#define TX_ZERO_PADDING\t\t(1 << 18)\n#define TX_FIRST_DESC\t\t(1 << 17)\n#define TX_LAST_DESC\t\t(1 << 16)\n#define TX_ERROR\t\t(1 << 15)\n\n \n#define SDMA_CMD_AT\t\t(1 << 31)\n#define SDMA_CMD_TXDL\t\t(1 << 24)\n#define SDMA_CMD_TXDH\t\t(1 << 23)\n#define SDMA_CMD_AR\t\t(1 << 15)\n#define SDMA_CMD_ERD\t\t(1 << 7)\n\n \n#define PCR_DUPLEX_FULL\t\t(1 << 15)\n#define PCR_HS\t\t\t(1 << 12)\n#define PCR_EN\t\t\t(1 << 7)\n#define PCR_PM\t\t\t(1 << 0)\n\n \n#define PCXR_2BSM\t\t(1 << 28)\n#define PCXR_DSCP_EN\t\t(1 << 21)\n#define PCXR_RMII_EN\t\t(1 << 20)\n#define PCXR_AN_SPEED_DIS\t(1 << 19)\n#define PCXR_SPEED_100\t\t(1 << 18)\n#define PCXR_MFL_1518\t\t(0 << 14)\n#define PCXR_MFL_1536\t\t(1 << 14)\n#define PCXR_MFL_2048\t\t(2 << 14)\n#define PCXR_MFL_64K\t\t(3 << 14)\n#define PCXR_FLOWCTL_DIS\t(1 << 12)\n#define PCXR_FLP\t\t(1 << 11)\n#define PCXR_AN_FLOWCTL_DIS\t(1 << 10)\n#define PCXR_AN_DUPLEX_DIS\t(1 << 9)\n#define PCXR_PRIO_TX_OFF\t3\n#define PCXR_TX_HIGH_PRI\t(7 << PCXR_PRIO_TX_OFF)\n\n \n#define SDCR_BSZ_OFF\t\t12\n#define SDCR_BSZ8\t\t(3 << SDCR_BSZ_OFF)\n#define SDCR_BSZ4\t\t(2 << SDCR_BSZ_OFF)\n#define SDCR_BSZ2\t\t(1 << SDCR_BSZ_OFF)\n#define SDCR_BSZ1\t\t(0 << SDCR_BSZ_OFF)\n#define SDCR_BLMR\t\t(1 << 6)\n#define SDCR_BLMT\t\t(1 << 7)\n#define SDCR_RIFB\t\t(1 << 9)\n#define SDCR_RC_OFF\t\t2\n#define SDCR_RC_MAX_RETRANS\t(0xf << SDCR_RC_OFF)\n\n \n#define ICR_RXBUF\t\t(1 << 0)\n#define ICR_TXBUF_H\t\t(1 << 2)\n#define ICR_TXBUF_L\t\t(1 << 3)\n#define ICR_TXEND_H\t\t(1 << 6)\n#define ICR_TXEND_L\t\t(1 << 7)\n#define ICR_RXERR\t\t(1 << 8)\n#define ICR_TXERR_H\t\t(1 << 10)\n#define ICR_TXERR_L\t\t(1 << 11)\n#define ICR_TX_UDR\t\t(1 << 13)\n#define ICR_MII_CH\t\t(1 << 28)\n\n#define ALL_INTS (ICR_TXBUF_H  | ICR_TXBUF_L  | ICR_TX_UDR |\\\n\t\t\t\tICR_TXERR_H  | ICR_TXERR_L |\\\n\t\t\t\tICR_TXEND_H  | ICR_TXEND_L |\\\n\t\t\t\tICR_RXBUF | ICR_RXERR  | ICR_MII_CH)\n\n#define ETH_HW_IP_ALIGN\t\t2\t \n\n#define NUM_RX_DESCS\t\t64\n#define NUM_TX_DESCS\t\t64\n\n#define HASH_ADD\t\t0\n#define HASH_DELETE\t\t1\n#define HASH_ADDR_TABLE_SIZE\t0x4000\t \n#define HOP_NUMBER\t\t12\n\n \n#define PORT_SPEED_100\t\t(1 << 0)\n#define FULL_DUPLEX\t\t(1 << 1)\n#define FLOW_CONTROL_DISABLED\t(1 << 2)\n#define LINK_UP\t\t\t(1 << 3)\n\n \n#define WORK_TX_DONE\t\t(1 << 1)\n\n \n#define SKB_DMA_REALIGN\t\t((PAGE_SIZE - NET_SKB_PAD) % SMP_CACHE_BYTES)\n\nstruct rx_desc {\n\tu32 cmd_sts;\t\t \n\tu16 byte_cnt;\t\t \n\tu16 buf_size;\t\t \n\tu32 buf_ptr;\t\t \n\tu32 next_desc_ptr;\t \n};\n\nstruct tx_desc {\n\tu32 cmd_sts;\t\t \n\tu16 reserved;\n\tu16 byte_cnt;\t\t \n\tu32 buf_ptr;\t\t \n\tu32 next_desc_ptr;\t \n};\n\nstruct pxa168_eth_private {\n\tstruct platform_device *pdev;\n\tint port_num;\t\t \n\tint phy_addr;\n\tint phy_speed;\n\tint phy_duplex;\n\tphy_interface_t phy_intf;\n\n\tint rx_resource_err;\t \n\n\t \n\tint rx_curr_desc_q, rx_used_desc_q;\n\n\t \n\tint tx_curr_desc_q, tx_used_desc_q;\n\n\tstruct rx_desc *p_rx_desc_area;\n\tdma_addr_t rx_desc_dma;\n\tint rx_desc_area_size;\n\tstruct sk_buff **rx_skb;\n\n\tstruct tx_desc *p_tx_desc_area;\n\tdma_addr_t tx_desc_dma;\n\tint tx_desc_area_size;\n\tstruct sk_buff **tx_skb;\n\n\tstruct work_struct tx_timeout_task;\n\n\tstruct net_device *dev;\n\tstruct napi_struct napi;\n\tu8 work_todo;\n\tint skb_size;\n\n\t \n\tint tx_ring_size;\n\t \n\tint tx_desc_count;\n\t \n\tint rx_ring_size;\n\t \n\tint rx_desc_count;\n\n\t \n\tstruct timer_list timeout;\n\tstruct mii_bus *smi_bus;\n\n\t \n\tstruct clk *clk;\n\tstruct pxa168_eth_platform_data *pd;\n\t \n\tvoid __iomem *base;\n\n\t \n\tvoid *htpr;\n\tdma_addr_t htpr_dma;\n};\n\nstruct addr_table_entry {\n\t__le32 lo;\n\t__le32 hi;\n};\n\n \nenum hash_table_entry {\n\tHASH_ENTRY_VALID = 1,\n\tSKIP = 2,\n\tHASH_ENTRY_RECEIVE_DISCARD = 4,\n\tHASH_ENTRY_RECEIVE_DISCARD_BIT = 2\n};\n\nstatic int pxa168_init_hw(struct pxa168_eth_private *pep);\nstatic int pxa168_init_phy(struct net_device *dev);\nstatic void eth_port_reset(struct net_device *dev);\nstatic void eth_port_start(struct net_device *dev);\nstatic int pxa168_eth_open(struct net_device *dev);\nstatic int pxa168_eth_stop(struct net_device *dev);\n\nstatic inline u32 rdl(struct pxa168_eth_private *pep, int offset)\n{\n\treturn readl_relaxed(pep->base + offset);\n}\n\nstatic inline void wrl(struct pxa168_eth_private *pep, int offset, u32 data)\n{\n\twritel_relaxed(data, pep->base + offset);\n}\n\nstatic void abort_dma(struct pxa168_eth_private *pep)\n{\n\tint delay;\n\tint max_retries = 40;\n\n\tdo {\n\t\twrl(pep, SDMA_CMD, SDMA_CMD_AR | SDMA_CMD_AT);\n\t\tudelay(100);\n\n\t\tdelay = 10;\n\t\twhile ((rdl(pep, SDMA_CMD) & (SDMA_CMD_AR | SDMA_CMD_AT))\n\t\t       && delay-- > 0) {\n\t\t\tudelay(10);\n\t\t}\n\t} while (max_retries-- > 0 && delay <= 0);\n\n\tif (max_retries <= 0)\n\t\tnetdev_err(pep->dev, \"%s : DMA Stuck\\n\", __func__);\n}\n\nstatic void rxq_refill(struct net_device *dev)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tstruct rx_desc *p_used_rx_desc;\n\tint used_rx_desc;\n\n\twhile (pep->rx_desc_count < pep->rx_ring_size) {\n\t\tint size;\n\n\t\tskb = netdev_alloc_skb(dev, pep->skb_size);\n\t\tif (!skb)\n\t\t\tbreak;\n\t\tif (SKB_DMA_REALIGN)\n\t\t\tskb_reserve(skb, SKB_DMA_REALIGN);\n\t\tpep->rx_desc_count++;\n\t\t \n\t\tused_rx_desc = pep->rx_used_desc_q;\n\t\tp_used_rx_desc = &pep->p_rx_desc_area[used_rx_desc];\n\t\tsize = skb_end_pointer(skb) - skb->data;\n\t\tp_used_rx_desc->buf_ptr = dma_map_single(&pep->pdev->dev,\n\t\t\t\t\t\t\t skb->data,\n\t\t\t\t\t\t\t size,\n\t\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\tp_used_rx_desc->buf_size = size;\n\t\tpep->rx_skb[used_rx_desc] = skb;\n\n\t\t \n\t\tdma_wmb();\n\t\tp_used_rx_desc->cmd_sts = BUF_OWNED_BY_DMA | RX_EN_INT;\n\t\tdma_wmb();\n\n\t\t \n\t\tpep->rx_used_desc_q = (used_rx_desc + 1) % pep->rx_ring_size;\n\n\t\t \n\t\tpep->rx_resource_err = 0;\n\n\t\tskb_reserve(skb, ETH_HW_IP_ALIGN);\n\t}\n\n\t \n\tif (pep->rx_desc_count == 0) {\n\t\tpep->timeout.expires = jiffies + (HZ / 10);\n\t\tadd_timer(&pep->timeout);\n\t}\n}\n\nstatic inline void rxq_refill_timer_wrapper(struct timer_list *t)\n{\n\tstruct pxa168_eth_private *pep = from_timer(pep, t, timeout);\n\tnapi_schedule(&pep->napi);\n}\n\nstatic inline u8 flip_8_bits(u8 x)\n{\n\treturn (((x) & 0x01) << 3) | (((x) & 0x02) << 1)\n\t    | (((x) & 0x04) >> 1) | (((x) & 0x08) >> 3)\n\t    | (((x) & 0x10) << 3) | (((x) & 0x20) << 1)\n\t    | (((x) & 0x40) >> 1) | (((x) & 0x80) >> 3);\n}\n\nstatic void nibble_swap_every_byte(unsigned char *mac_addr)\n{\n\tint i;\n\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\tmac_addr[i] = ((mac_addr[i] & 0x0f) << 4) |\n\t\t\t\t((mac_addr[i] & 0xf0) >> 4);\n\t}\n}\n\nstatic void inverse_every_nibble(unsigned char *mac_addr)\n{\n\tint i;\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tmac_addr[i] = flip_8_bits(mac_addr[i]);\n}\n\n \nstatic u32 hash_function(const unsigned char *mac_addr_orig)\n{\n\tu32 hash_result;\n\tu32 addr0;\n\tu32 addr1;\n\tu32 addr2;\n\tu32 addr3;\n\tunsigned char mac_addr[ETH_ALEN];\n\n\t \n\tmemcpy(mac_addr, mac_addr_orig, ETH_ALEN);\n\n\tnibble_swap_every_byte(mac_addr);\n\tinverse_every_nibble(mac_addr);\n\n\taddr0 = (mac_addr[5] >> 2) & 0x3f;\n\taddr1 = (mac_addr[5] & 0x03) | (((mac_addr[4] & 0x7f)) << 2);\n\taddr2 = ((mac_addr[4] & 0x80) >> 7) | mac_addr[3] << 1;\n\taddr3 = (mac_addr[2] & 0xff) | ((mac_addr[1] & 1) << 8);\n\n\thash_result = (addr0 << 9) | (addr1 ^ addr2 ^ addr3);\n\thash_result = hash_result & 0x07ff;\n\treturn hash_result;\n}\n\n \nstatic int add_del_hash_entry(struct pxa168_eth_private *pep,\n\t\t\t      const unsigned char *mac_addr,\n\t\t\t      u32 rd, u32 skip, int del)\n{\n\tstruct addr_table_entry *entry, *start;\n\tu32 new_high;\n\tu32 new_low;\n\tu32 i;\n\n\tnew_low = (((mac_addr[1] >> 4) & 0xf) << 15)\n\t    | (((mac_addr[1] >> 0) & 0xf) << 11)\n\t    | (((mac_addr[0] >> 4) & 0xf) << 7)\n\t    | (((mac_addr[0] >> 0) & 0xf) << 3)\n\t    | (((mac_addr[3] >> 4) & 0x1) << 31)\n\t    | (((mac_addr[3] >> 0) & 0xf) << 27)\n\t    | (((mac_addr[2] >> 4) & 0xf) << 23)\n\t    | (((mac_addr[2] >> 0) & 0xf) << 19)\n\t    | (skip << SKIP) | (rd << HASH_ENTRY_RECEIVE_DISCARD_BIT)\n\t    | HASH_ENTRY_VALID;\n\n\tnew_high = (((mac_addr[5] >> 4) & 0xf) << 15)\n\t    | (((mac_addr[5] >> 0) & 0xf) << 11)\n\t    | (((mac_addr[4] >> 4) & 0xf) << 7)\n\t    | (((mac_addr[4] >> 0) & 0xf) << 3)\n\t    | (((mac_addr[3] >> 5) & 0x7) << 0);\n\n\t \n\tstart = pep->htpr;\n\tentry = start + hash_function(mac_addr);\n\tfor (i = 0; i < HOP_NUMBER; i++) {\n\t\tif (!(le32_to_cpu(entry->lo) & HASH_ENTRY_VALID)) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tif (((le32_to_cpu(entry->lo) & 0xfffffff8) ==\n\t\t\t\t(new_low & 0xfffffff8)) &&\n\t\t\t\t(le32_to_cpu(entry->hi) == new_high)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (entry == start + 0x7ff)\n\t\t\tentry = start;\n\t\telse\n\t\t\tentry++;\n\t}\n\n\tif (((le32_to_cpu(entry->lo) & 0xfffffff8) != (new_low & 0xfffffff8)) &&\n\t    (le32_to_cpu(entry->hi) != new_high) && del)\n\t\treturn 0;\n\n\tif (i == HOP_NUMBER) {\n\t\tif (!del) {\n\t\t\tnetdev_info(pep->dev,\n\t\t\t\t    \"%s: table section is full, need to \"\n\t\t\t\t    \"move to 16kB implementation?\\n\",\n\t\t\t\t    __FILE__);\n\t\t\treturn -ENOSPC;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (del) {\n\t\tentry->hi = 0;\n\t\tentry->lo = 0;\n\t} else {\n\t\tentry->hi = cpu_to_le32(new_high);\n\t\tentry->lo = cpu_to_le32(new_low);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void update_hash_table_mac_address(struct pxa168_eth_private *pep,\n\t\t\t\t\t  unsigned char *oaddr,\n\t\t\t\t\t  const unsigned char *addr)\n{\n\t \n\tif (oaddr)\n\t\tadd_del_hash_entry(pep, oaddr, 1, 0, HASH_DELETE);\n\t \n\tadd_del_hash_entry(pep, addr, 1, 0, HASH_ADD);\n}\n\nstatic int init_hash_table(struct pxa168_eth_private *pep)\n{\n\t \n\t \n\tif (!pep->htpr) {\n\t\tpep->htpr = dma_alloc_coherent(pep->dev->dev.parent,\n\t\t\t\t\t       HASH_ADDR_TABLE_SIZE,\n\t\t\t\t\t       &pep->htpr_dma, GFP_KERNEL);\n\t\tif (!pep->htpr)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tmemset(pep->htpr, 0, HASH_ADDR_TABLE_SIZE);\n\t}\n\twrl(pep, HTPR, pep->htpr_dma);\n\treturn 0;\n}\n\nstatic void pxa168_eth_set_rx_mode(struct net_device *dev)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tstruct netdev_hw_addr *ha;\n\tu32 val;\n\n\tval = rdl(pep, PORT_CONFIG);\n\tif (dev->flags & IFF_PROMISC)\n\t\tval |= PCR_PM;\n\telse\n\t\tval &= ~PCR_PM;\n\twrl(pep, PORT_CONFIG, val);\n\n\t \n\tmemset(pep->htpr, 0, HASH_ADDR_TABLE_SIZE);\n\tupdate_hash_table_mac_address(pep, NULL, dev->dev_addr);\n\n\tnetdev_for_each_mc_addr(ha, dev)\n\t\tupdate_hash_table_mac_address(pep, NULL, ha->addr);\n}\n\nstatic void pxa168_eth_get_mac_address(struct net_device *dev,\n\t\t\t\t       unsigned char *addr)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tunsigned int mac_h = rdl(pep, MAC_ADDR_HIGH);\n\tunsigned int mac_l = rdl(pep, MAC_ADDR_LOW);\n\n\taddr[0] = (mac_h >> 24) & 0xff;\n\taddr[1] = (mac_h >> 16) & 0xff;\n\taddr[2] = (mac_h >> 8) & 0xff;\n\taddr[3] = mac_h & 0xff;\n\taddr[4] = (mac_l >> 8) & 0xff;\n\taddr[5] = mac_l & 0xff;\n}\n\nstatic int pxa168_eth_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *sa = addr;\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tunsigned char oldMac[ETH_ALEN];\n\tu32 mac_h, mac_l;\n\n\tif (!is_valid_ether_addr(sa->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\tmemcpy(oldMac, dev->dev_addr, ETH_ALEN);\n\teth_hw_addr_set(dev, sa->sa_data);\n\n\tmac_h = dev->dev_addr[0] << 24;\n\tmac_h |= dev->dev_addr[1] << 16;\n\tmac_h |= dev->dev_addr[2] << 8;\n\tmac_h |= dev->dev_addr[3];\n\tmac_l = dev->dev_addr[4] << 8;\n\tmac_l |= dev->dev_addr[5];\n\twrl(pep, MAC_ADDR_HIGH, mac_h);\n\twrl(pep, MAC_ADDR_LOW, mac_l);\n\n\tnetif_addr_lock_bh(dev);\n\tupdate_hash_table_mac_address(pep, oldMac, dev->dev_addr);\n\tnetif_addr_unlock_bh(dev);\n\treturn 0;\n}\n\nstatic void eth_port_start(struct net_device *dev)\n{\n\tunsigned int val = 0;\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tint tx_curr_desc, rx_curr_desc;\n\n\tphy_start(dev->phydev);\n\n\t \n\ttx_curr_desc = pep->tx_curr_desc_q;\n\twrl(pep, ETH_C_TX_DESC_1,\n\t    (u32) (pep->tx_desc_dma + tx_curr_desc * sizeof(struct tx_desc)));\n\n\t \n\trx_curr_desc = pep->rx_curr_desc_q;\n\twrl(pep, ETH_C_RX_DESC_0,\n\t    (u32) (pep->rx_desc_dma + rx_curr_desc * sizeof(struct rx_desc)));\n\n\twrl(pep, ETH_F_RX_DESC_0,\n\t    (u32) (pep->rx_desc_dma + rx_curr_desc * sizeof(struct rx_desc)));\n\n\t \n\twrl(pep, INT_CAUSE, 0);\n\n\t \n\twrl(pep, INT_MASK, ALL_INTS);\n\n\tval = rdl(pep, PORT_CONFIG);\n\tval |= PCR_EN;\n\twrl(pep, PORT_CONFIG, val);\n\n\t \n\tval = rdl(pep, SDMA_CMD);\n\tval |= SDMA_CMD_ERD;\n\twrl(pep, SDMA_CMD, val);\n}\n\nstatic void eth_port_reset(struct net_device *dev)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tunsigned int val = 0;\n\n\t \n\twrl(pep, INT_MASK, 0);\n\n\t \n\twrl(pep, INT_CAUSE, 0);\n\n\t \n\tval = rdl(pep, SDMA_CMD);\n\tval &= ~SDMA_CMD_ERD;\t \n\n\t \n\tabort_dma(pep);\n\n\t \n\tval = rdl(pep, PORT_CONFIG);\n\tval &= ~PCR_EN;\n\twrl(pep, PORT_CONFIG, val);\n\n\tphy_stop(dev->phydev);\n}\n\n \nstatic int txq_reclaim(struct net_device *dev, int force)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tstruct tx_desc *desc;\n\tu32 cmd_sts;\n\tstruct sk_buff *skb;\n\tint tx_index;\n\tdma_addr_t addr;\n\tint count;\n\tint released = 0;\n\n\tnetif_tx_lock(dev);\n\n\tpep->work_todo &= ~WORK_TX_DONE;\n\twhile (pep->tx_desc_count > 0) {\n\t\ttx_index = pep->tx_used_desc_q;\n\t\tdesc = &pep->p_tx_desc_area[tx_index];\n\t\tcmd_sts = desc->cmd_sts;\n\t\tif (!force && (cmd_sts & BUF_OWNED_BY_DMA)) {\n\t\t\tif (released > 0) {\n\t\t\t\tgoto txq_reclaim_end;\n\t\t\t} else {\n\t\t\t\treleased = -1;\n\t\t\t\tgoto txq_reclaim_end;\n\t\t\t}\n\t\t}\n\t\tpep->tx_used_desc_q = (tx_index + 1) % pep->tx_ring_size;\n\t\tpep->tx_desc_count--;\n\t\taddr = desc->buf_ptr;\n\t\tcount = desc->byte_cnt;\n\t\tskb = pep->tx_skb[tx_index];\n\t\tif (skb)\n\t\t\tpep->tx_skb[tx_index] = NULL;\n\n\t\tif (cmd_sts & TX_ERROR) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_err(dev, \"Error in TX\\n\");\n\t\t\tdev->stats.tx_errors++;\n\t\t}\n\t\tdma_unmap_single(&pep->pdev->dev, addr, count, DMA_TO_DEVICE);\n\t\tif (skb)\n\t\t\tdev_kfree_skb_irq(skb);\n\t\treleased++;\n\t}\ntxq_reclaim_end:\n\tnetif_tx_unlock(dev);\n\treturn released;\n}\n\nstatic void pxa168_eth_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\n\tnetdev_info(dev, \"TX timeout  desc_count %d\\n\", pep->tx_desc_count);\n\n\tschedule_work(&pep->tx_timeout_task);\n}\n\nstatic void pxa168_eth_tx_timeout_task(struct work_struct *work)\n{\n\tstruct pxa168_eth_private *pep = container_of(work,\n\t\t\t\t\t\t struct pxa168_eth_private,\n\t\t\t\t\t\t tx_timeout_task);\n\tstruct net_device *dev = pep->dev;\n\tpxa168_eth_stop(dev);\n\tpxa168_eth_open(dev);\n}\n\nstatic int rxq_process(struct net_device *dev, int budget)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tunsigned int received_packets = 0;\n\tstruct sk_buff *skb;\n\n\twhile (budget-- > 0) {\n\t\tint rx_next_curr_desc, rx_curr_desc, rx_used_desc;\n\t\tstruct rx_desc *rx_desc;\n\t\tunsigned int cmd_sts;\n\n\t\t \n\t\tif (pep->rx_resource_err)\n\t\t\tbreak;\n\t\trx_curr_desc = pep->rx_curr_desc_q;\n\t\trx_used_desc = pep->rx_used_desc_q;\n\t\trx_desc = &pep->p_rx_desc_area[rx_curr_desc];\n\t\tcmd_sts = rx_desc->cmd_sts;\n\t\tdma_rmb();\n\t\tif (cmd_sts & (BUF_OWNED_BY_DMA))\n\t\t\tbreak;\n\t\tskb = pep->rx_skb[rx_curr_desc];\n\t\tpep->rx_skb[rx_curr_desc] = NULL;\n\n\t\trx_next_curr_desc = (rx_curr_desc + 1) % pep->rx_ring_size;\n\t\tpep->rx_curr_desc_q = rx_next_curr_desc;\n\n\t\t \n\t\t \n\t\tif (rx_next_curr_desc == rx_used_desc)\n\t\t\tpep->rx_resource_err = 1;\n\t\tpep->rx_desc_count--;\n\t\tdma_unmap_single(&pep->pdev->dev, rx_desc->buf_ptr,\n\t\t\t\t rx_desc->buf_size,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\treceived_packets++;\n\t\t \n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += rx_desc->byte_cnt;\n\t\t \n\t\tif (((cmd_sts & (RX_FIRST_DESC | RX_LAST_DESC)) !=\n\t\t     (RX_FIRST_DESC | RX_LAST_DESC))\n\t\t    || (cmd_sts & RX_ERROR)) {\n\n\t\t\tstats->rx_dropped++;\n\t\t\tif ((cmd_sts & (RX_FIRST_DESC | RX_LAST_DESC)) !=\n\t\t\t    (RX_FIRST_DESC | RX_LAST_DESC)) {\n\t\t\t\tif (net_ratelimit())\n\t\t\t\t\tnetdev_err(dev,\n\t\t\t\t\t\t   \"Rx pkt on multiple desc\\n\");\n\t\t\t}\n\t\t\tif (cmd_sts & RX_ERROR)\n\t\t\t\tstats->rx_errors++;\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t} else {\n\t\t\t \n\t\t\tskb_put(skb, rx_desc->byte_cnt - 4);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_receive_skb(skb);\n\t\t}\n\t}\n\t \n\trxq_refill(dev);\n\treturn received_packets;\n}\n\nstatic int pxa168_eth_collect_events(struct pxa168_eth_private *pep,\n\t\t\t\t     struct net_device *dev)\n{\n\tu32 icr;\n\tint ret = 0;\n\n\ticr = rdl(pep, INT_CAUSE);\n\tif (icr == 0)\n\t\treturn IRQ_NONE;\n\n\twrl(pep, INT_CAUSE, ~icr);\n\tif (icr & (ICR_TXBUF_H | ICR_TXBUF_L)) {\n\t\tpep->work_todo |= WORK_TX_DONE;\n\t\tret = 1;\n\t}\n\tif (icr & ICR_RXBUF)\n\t\tret = 1;\n\treturn ret;\n}\n\nstatic irqreturn_t pxa168_eth_int_handler(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\n\tif (unlikely(!pxa168_eth_collect_events(pep, dev)))\n\t\treturn IRQ_NONE;\n\t \n\twrl(pep, INT_MASK, 0);\n\tnapi_schedule(&pep->napi);\n\treturn IRQ_HANDLED;\n}\n\nstatic void pxa168_eth_recalc_skb_size(struct pxa168_eth_private *pep)\n{\n\tint skb_size;\n\n\t \n\tskb_size = pep->dev->mtu + 36;\n\n\t \n\tpep->skb_size = (skb_size + 7) & ~7;\n\n\t \n\tpep->skb_size += SKB_DMA_REALIGN;\n\n}\n\nstatic int set_port_config_ext(struct pxa168_eth_private *pep)\n{\n\tint skb_size;\n\n\tpxa168_eth_recalc_skb_size(pep);\n\tif  (pep->skb_size <= 1518)\n\t\tskb_size = PCXR_MFL_1518;\n\telse if (pep->skb_size <= 1536)\n\t\tskb_size = PCXR_MFL_1536;\n\telse if (pep->skb_size <= 2048)\n\t\tskb_size = PCXR_MFL_2048;\n\telse\n\t\tskb_size = PCXR_MFL_64K;\n\n\t \n\twrl(pep, PORT_CONFIG_EXT,\n\t    PCXR_AN_SPEED_DIS |\t\t  \n\t    PCXR_AN_DUPLEX_DIS |\n\t    PCXR_AN_FLOWCTL_DIS |\n\t    PCXR_2BSM |\t\t\t  \n\t    PCXR_DSCP_EN |\t\t  \n\t    skb_size | PCXR_FLP |\t  \n\t    PCXR_TX_HIGH_PRI);\t\t  \n\n\treturn 0;\n}\n\nstatic void pxa168_eth_adjust_link(struct net_device *dev)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tstruct phy_device *phy = dev->phydev;\n\tu32 cfg, cfg_o = rdl(pep, PORT_CONFIG);\n\tu32 cfgext, cfgext_o = rdl(pep, PORT_CONFIG_EXT);\n\n\tcfg = cfg_o & ~PCR_DUPLEX_FULL;\n\tcfgext = cfgext_o & ~(PCXR_SPEED_100 | PCXR_FLOWCTL_DIS | PCXR_RMII_EN);\n\n\tif (phy->interface == PHY_INTERFACE_MODE_RMII)\n\t\tcfgext |= PCXR_RMII_EN;\n\tif (phy->speed == SPEED_100)\n\t\tcfgext |= PCXR_SPEED_100;\n\tif (phy->duplex)\n\t\tcfg |= PCR_DUPLEX_FULL;\n\tif (!phy->pause)\n\t\tcfgext |= PCXR_FLOWCTL_DIS;\n\n\t \n\tif (cfg == cfg_o && cfgext == cfgext_o)\n\t\treturn;\n\n\twrl(pep, PORT_CONFIG, cfg);\n\twrl(pep, PORT_CONFIG_EXT, cfgext);\n\n\tphy_print_status(phy);\n}\n\nstatic int pxa168_init_phy(struct net_device *dev)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tstruct ethtool_link_ksettings cmd;\n\tstruct phy_device *phy = NULL;\n\tint err;\n\n\tif (dev->phydev)\n\t\treturn 0;\n\n\tphy = mdiobus_scan_c22(pep->smi_bus, pep->phy_addr);\n\tif (IS_ERR(phy))\n\t\treturn PTR_ERR(phy);\n\n\terr = phy_connect_direct(dev, phy, pxa168_eth_adjust_link,\n\t\t\t\t pep->phy_intf);\n\tif (err)\n\t\treturn err;\n\n\tcmd.base.phy_address = pep->phy_addr;\n\tcmd.base.speed = pep->phy_speed;\n\tcmd.base.duplex = pep->phy_duplex;\n\tlinkmode_copy(cmd.link_modes.advertising, PHY_BASIC_FEATURES);\n\tcmd.base.autoneg = AUTONEG_ENABLE;\n\n\tif (cmd.base.speed != 0)\n\t\tcmd.base.autoneg = AUTONEG_DISABLE;\n\n\treturn phy_ethtool_set_link_ksettings(dev, &cmd);\n}\n\nstatic int pxa168_init_hw(struct pxa168_eth_private *pep)\n{\n\tint err = 0;\n\n\t \n\twrl(pep, INT_MASK, 0);\n\twrl(pep, INT_CAUSE, 0);\n\t \n\twrl(pep, INT_W_CLEAR, 0);\n\t \n\tabort_dma(pep);\n\t \n\terr = init_hash_table(pep);\n\tif (err)\n\t\treturn err;\n\t \n\twrl(pep, SDMA_CONFIG, SDCR_BSZ8 |\t \n\t    SDCR_RIFB |\t\t\t\t \n\t    SDCR_BLMT |\t\t\t\t \n\t    SDCR_BLMR |\t\t\t\t \n\t    SDCR_RC_MAX_RETRANS);\t\t \n\t \n\twrl(pep, PORT_CONFIG, PCR_HS);\t\t \n\tset_port_config_ext(pep);\n\n\treturn err;\n}\n\nstatic int rxq_init(struct net_device *dev)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tstruct rx_desc *p_rx_desc;\n\tint size = 0, i = 0;\n\tint rx_desc_num = pep->rx_ring_size;\n\n\t \n\tpep->rx_skb = kcalloc(rx_desc_num, sizeof(*pep->rx_skb), GFP_KERNEL);\n\tif (!pep->rx_skb)\n\t\treturn -ENOMEM;\n\n\t \n\tpep->rx_desc_count = 0;\n\tsize = pep->rx_ring_size * sizeof(struct rx_desc);\n\tpep->rx_desc_area_size = size;\n\tpep->p_rx_desc_area = dma_alloc_coherent(pep->dev->dev.parent, size,\n\t\t\t\t\t\t &pep->rx_desc_dma,\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!pep->p_rx_desc_area)\n\t\tgoto out;\n\n\t \n\tp_rx_desc = pep->p_rx_desc_area;\n\tfor (i = 0; i < rx_desc_num; i++) {\n\t\tp_rx_desc[i].next_desc_ptr = pep->rx_desc_dma +\n\t\t    ((i + 1) % rx_desc_num) * sizeof(struct rx_desc);\n\t}\n\t \n\tpep->rx_curr_desc_q = 0;\n\tpep->rx_used_desc_q = 0;\n\tpep->rx_desc_area_size = rx_desc_num * sizeof(struct rx_desc);\n\treturn 0;\nout:\n\tkfree(pep->rx_skb);\n\treturn -ENOMEM;\n}\n\nstatic void rxq_deinit(struct net_device *dev)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tint curr;\n\n\t \n\tfor (curr = 0; pep->rx_desc_count && curr < pep->rx_ring_size; curr++) {\n\t\tif (pep->rx_skb[curr]) {\n\t\t\tdev_kfree_skb(pep->rx_skb[curr]);\n\t\t\tpep->rx_desc_count--;\n\t\t}\n\t}\n\tif (pep->rx_desc_count)\n\t\tnetdev_err(dev, \"Error in freeing Rx Ring. %d skb's still\\n\",\n\t\t\t   pep->rx_desc_count);\n\t \n\tif (pep->p_rx_desc_area)\n\t\tdma_free_coherent(pep->dev->dev.parent, pep->rx_desc_area_size,\n\t\t\t\t  pep->p_rx_desc_area, pep->rx_desc_dma);\n\tkfree(pep->rx_skb);\n}\n\nstatic int txq_init(struct net_device *dev)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tstruct tx_desc *p_tx_desc;\n\tint size = 0, i = 0;\n\tint tx_desc_num = pep->tx_ring_size;\n\n\tpep->tx_skb = kcalloc(tx_desc_num, sizeof(*pep->tx_skb), GFP_KERNEL);\n\tif (!pep->tx_skb)\n\t\treturn -ENOMEM;\n\n\t \n\tpep->tx_desc_count = 0;\n\tsize = pep->tx_ring_size * sizeof(struct tx_desc);\n\tpep->tx_desc_area_size = size;\n\tpep->p_tx_desc_area = dma_alloc_coherent(pep->dev->dev.parent, size,\n\t\t\t\t\t\t &pep->tx_desc_dma,\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!pep->p_tx_desc_area)\n\t\tgoto out;\n\t \n\tp_tx_desc = pep->p_tx_desc_area;\n\tfor (i = 0; i < tx_desc_num; i++) {\n\t\tp_tx_desc[i].next_desc_ptr = pep->tx_desc_dma +\n\t\t    ((i + 1) % tx_desc_num) * sizeof(struct tx_desc);\n\t}\n\tpep->tx_curr_desc_q = 0;\n\tpep->tx_used_desc_q = 0;\n\tpep->tx_desc_area_size = tx_desc_num * sizeof(struct tx_desc);\n\treturn 0;\nout:\n\tkfree(pep->tx_skb);\n\treturn -ENOMEM;\n}\n\nstatic void txq_deinit(struct net_device *dev)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\n\t \n\ttxq_reclaim(dev, 1);\n\tBUG_ON(pep->tx_used_desc_q != pep->tx_curr_desc_q);\n\t \n\tif (pep->p_tx_desc_area)\n\t\tdma_free_coherent(pep->dev->dev.parent, pep->tx_desc_area_size,\n\t\t\t\t  pep->p_tx_desc_area, pep->tx_desc_dma);\n\tkfree(pep->tx_skb);\n}\n\nstatic int pxa168_eth_open(struct net_device *dev)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tint err;\n\n\terr = pxa168_init_phy(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = request_irq(dev->irq, pxa168_eth_int_handler, 0, dev->name, dev);\n\tif (err) {\n\t\tdev_err(&dev->dev, \"can't assign irq\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tpep->rx_resource_err = 0;\n\terr = rxq_init(dev);\n\tif (err != 0)\n\t\tgoto out_free_irq;\n\terr = txq_init(dev);\n\tif (err != 0)\n\t\tgoto out_free_rx_skb;\n\tpep->rx_used_desc_q = 0;\n\tpep->rx_curr_desc_q = 0;\n\n\t \n\trxq_refill(dev);\n\tpep->rx_used_desc_q = 0;\n\tpep->rx_curr_desc_q = 0;\n\tnetif_carrier_off(dev);\n\tnapi_enable(&pep->napi);\n\teth_port_start(dev);\n\treturn 0;\nout_free_rx_skb:\n\trxq_deinit(dev);\nout_free_irq:\n\tfree_irq(dev->irq, dev);\n\treturn err;\n}\n\nstatic int pxa168_eth_stop(struct net_device *dev)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\teth_port_reset(dev);\n\n\t \n\twrl(pep, INT_MASK, 0);\n\twrl(pep, INT_CAUSE, 0);\n\t \n\twrl(pep, INT_W_CLEAR, 0);\n\tnapi_disable(&pep->napi);\n\tdel_timer_sync(&pep->timeout);\n\tnetif_carrier_off(dev);\n\tfree_irq(dev->irq, dev);\n\trxq_deinit(dev);\n\ttxq_deinit(dev);\n\n\treturn 0;\n}\n\nstatic int pxa168_eth_change_mtu(struct net_device *dev, int mtu)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\n\tdev->mtu = mtu;\n\tset_port_config_ext(pep);\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\t \n\tpxa168_eth_stop(dev);\n\tif (pxa168_eth_open(dev)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"fatal error on re-opening device after MTU change\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int eth_alloc_tx_desc_index(struct pxa168_eth_private *pep)\n{\n\tint tx_desc_curr;\n\n\ttx_desc_curr = pep->tx_curr_desc_q;\n\tpep->tx_curr_desc_q = (tx_desc_curr + 1) % pep->tx_ring_size;\n\tBUG_ON(pep->tx_curr_desc_q == pep->tx_used_desc_q);\n\tpep->tx_desc_count++;\n\n\treturn tx_desc_curr;\n}\n\nstatic int pxa168_rx_poll(struct napi_struct *napi, int budget)\n{\n\tstruct pxa168_eth_private *pep =\n\t    container_of(napi, struct pxa168_eth_private, napi);\n\tstruct net_device *dev = pep->dev;\n\tint work_done = 0;\n\n\t \n\ttxq_reclaim(dev, 0);\n\tif (netif_queue_stopped(dev)\n\t    && pep->tx_ring_size - pep->tx_desc_count > 1) {\n\t\tnetif_wake_queue(dev);\n\t}\n\twork_done = rxq_process(dev, budget);\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\twrl(pep, INT_MASK, ALL_INTS);\n\t}\n\n\treturn work_done;\n}\n\nstatic netdev_tx_t\npxa168_eth_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct tx_desc *desc;\n\tint tx_index;\n\tint length;\n\n\ttx_index = eth_alloc_tx_desc_index(pep);\n\tdesc = &pep->p_tx_desc_area[tx_index];\n\tlength = skb->len;\n\tpep->tx_skb[tx_index] = skb;\n\tdesc->byte_cnt = length;\n\tdesc->buf_ptr = dma_map_single(&pep->pdev->dev, skb->data, length,\n\t\t\t\t\tDMA_TO_DEVICE);\n\n\tskb_tx_timestamp(skb);\n\n\tdma_wmb();\n\tdesc->cmd_sts = BUF_OWNED_BY_DMA | TX_GEN_CRC | TX_FIRST_DESC |\n\t\t\tTX_ZERO_PADDING | TX_LAST_DESC | TX_EN_INT;\n\twmb();\n\twrl(pep, SDMA_CMD, SDMA_CMD_TXDH | SDMA_CMD_ERD);\n\n\tstats->tx_bytes += length;\n\tstats->tx_packets++;\n\tnetif_trans_update(dev);\n\tif (pep->tx_ring_size - pep->tx_desc_count <= 1) {\n\t\t \n\t\tnetif_stop_queue(dev);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int smi_wait_ready(struct pxa168_eth_private *pep)\n{\n\tint i = 0;\n\n\t \n\tfor (i = 0; rdl(pep, SMI) & SMI_BUSY; i++) {\n\t\tif (i == PHY_WAIT_ITERATIONS)\n\t\t\treturn -ETIMEDOUT;\n\t\tmsleep(10);\n\t}\n\n\treturn 0;\n}\n\nstatic int pxa168_smi_read(struct mii_bus *bus, int phy_addr, int regnum)\n{\n\tstruct pxa168_eth_private *pep = bus->priv;\n\tint i = 0;\n\tint val;\n\n\tif (smi_wait_ready(pep)) {\n\t\tnetdev_warn(pep->dev, \"pxa168_eth: SMI bus busy timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\twrl(pep, SMI, (phy_addr << 16) | (regnum << 21) | SMI_OP_R);\n\t \n\tfor (i = 0; !((val = rdl(pep, SMI)) & SMI_R_VALID); i++) {\n\t\tif (i == PHY_WAIT_ITERATIONS) {\n\t\t\tnetdev_warn(pep->dev,\n\t\t\t\t    \"pxa168_eth: SMI bus read not valid\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tmsleep(10);\n\t}\n\n\treturn val & 0xffff;\n}\n\nstatic int pxa168_smi_write(struct mii_bus *bus, int phy_addr, int regnum,\n\t\t\t    u16 value)\n{\n\tstruct pxa168_eth_private *pep = bus->priv;\n\n\tif (smi_wait_ready(pep)) {\n\t\tnetdev_warn(pep->dev, \"pxa168_eth: SMI bus busy timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\twrl(pep, SMI, (phy_addr << 16) | (regnum << 21) |\n\t    SMI_OP_W | (value & 0xffff));\n\n\tif (smi_wait_ready(pep)) {\n\t\tnetdev_err(pep->dev, \"pxa168_eth: SMI bus busy timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void pxa168_eth_netpoll(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\tpxa168_eth_int_handler(dev->irq, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n\nstatic void pxa168_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRIVER_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRIVER_VERSION, sizeof(info->version));\n\tstrscpy(info->fw_version, \"N/A\", sizeof(info->fw_version));\n\tstrscpy(info->bus_info, \"N/A\", sizeof(info->bus_info));\n}\n\nstatic const struct ethtool_ops pxa168_ethtool_ops = {\n\t.get_drvinfo\t= pxa168_get_drvinfo,\n\t.nway_reset\t= phy_ethtool_nway_reset,\n\t.get_link\t= ethtool_op_get_link,\n\t.get_ts_info\t= ethtool_op_get_ts_info,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\nstatic const struct net_device_ops pxa168_eth_netdev_ops = {\n\t.ndo_open\t\t= pxa168_eth_open,\n\t.ndo_stop\t\t= pxa168_eth_stop,\n\t.ndo_start_xmit\t\t= pxa168_eth_start_xmit,\n\t.ndo_set_rx_mode\t= pxa168_eth_set_rx_mode,\n\t.ndo_set_mac_address\t= pxa168_eth_set_mac_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl,\n\t.ndo_change_mtu\t\t= pxa168_eth_change_mtu,\n\t.ndo_tx_timeout\t\t= pxa168_eth_tx_timeout,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller    = pxa168_eth_netpoll,\n#endif\n};\n\nstatic int pxa168_eth_probe(struct platform_device *pdev)\n{\n\tstruct pxa168_eth_private *pep = NULL;\n\tstruct net_device *dev = NULL;\n\tstruct clk *clk;\n\tstruct device_node *np;\n\tint err;\n\n\tprintk(KERN_NOTICE \"PXA168 10/100 Ethernet Driver\\n\");\n\n\tclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"Fast Ethernet failed to get clock\\n\");\n\t\treturn -ENODEV;\n\t}\n\tclk_prepare_enable(clk);\n\n\tdev = alloc_etherdev(sizeof(struct pxa168_eth_private));\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_clk;\n\t}\n\n\tplatform_set_drvdata(pdev, dev);\n\tpep = netdev_priv(dev);\n\tpep->dev = dev;\n\tpep->clk = clk;\n\n\tpep->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pep->base)) {\n\t\terr = PTR_ERR(pep->base);\n\t\tgoto err_netdev;\n\t}\n\n\terr = platform_get_irq(pdev, 0);\n\tif (err == -EPROBE_DEFER)\n\t\tgoto err_netdev;\n\tBUG_ON(dev->irq < 0);\n\tdev->irq = err;\n\tdev->netdev_ops = &pxa168_eth_netdev_ops;\n\tdev->watchdog_timeo = 2 * HZ;\n\tdev->base_addr = 0;\n\tdev->ethtool_ops = &pxa168_ethtool_ops;\n\n\t \n\tdev->min_mtu = ETH_MIN_MTU;\n\tdev->max_mtu = 9500;\n\n\tINIT_WORK(&pep->tx_timeout_task, pxa168_eth_tx_timeout_task);\n\n\terr = of_get_ethdev_address(pdev->dev.of_node, dev);\n\tif (err) {\n\t\tu8 addr[ETH_ALEN];\n\n\t\t \n\t\tpxa168_eth_get_mac_address(dev, addr);\n\t\tif (is_valid_ether_addr(addr)) {\n\t\t\teth_hw_addr_set(dev, addr);\n\t\t} else {\n\t\t\tdev_info(&pdev->dev, \"Using random mac address\\n\");\n\t\t\teth_hw_addr_random(dev);\n\t\t}\n\t}\n\n\tpep->rx_ring_size = NUM_RX_DESCS;\n\tpep->tx_ring_size = NUM_TX_DESCS;\n\n\tpep->pd = dev_get_platdata(&pdev->dev);\n\tif (pep->pd) {\n\t\tif (pep->pd->rx_queue_size)\n\t\t\tpep->rx_ring_size = pep->pd->rx_queue_size;\n\n\t\tif (pep->pd->tx_queue_size)\n\t\t\tpep->tx_ring_size = pep->pd->tx_queue_size;\n\n\t\tpep->port_num = pep->pd->port_number;\n\t\tpep->phy_addr = pep->pd->phy_addr;\n\t\tpep->phy_speed = pep->pd->speed;\n\t\tpep->phy_duplex = pep->pd->duplex;\n\t\tpep->phy_intf = pep->pd->intf;\n\n\t\tif (pep->pd->init)\n\t\t\tpep->pd->init();\n\t} else if (pdev->dev.of_node) {\n\t\tof_property_read_u32(pdev->dev.of_node, \"port-id\",\n\t\t\t\t     &pep->port_num);\n\n\t\tnp = of_parse_phandle(pdev->dev.of_node, \"phy-handle\", 0);\n\t\tif (!np) {\n\t\t\tdev_err(&pdev->dev, \"missing phy-handle\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_netdev;\n\t\t}\n\t\tof_property_read_u32(np, \"reg\", &pep->phy_addr);\n\t\tof_node_put(np);\n\t\terr = of_get_phy_mode(pdev->dev.of_node, &pep->phy_intf);\n\t\tif (err && err != -ENODEV)\n\t\t\tgoto err_netdev;\n\t}\n\n\t \n\tBUG_ON(pep->port_num > 2);\n\tnetif_napi_add_weight(dev, &pep->napi, pxa168_rx_poll,\n\t\t\t      pep->rx_ring_size);\n\n\tmemset(&pep->timeout, 0, sizeof(struct timer_list));\n\ttimer_setup(&pep->timeout, rxq_refill_timer_wrapper, 0);\n\n\tpep->smi_bus = mdiobus_alloc();\n\tif (!pep->smi_bus) {\n\t\terr = -ENOMEM;\n\t\tgoto err_netdev;\n\t}\n\tpep->smi_bus->priv = pep;\n\tpep->smi_bus->name = \"pxa168_eth smi\";\n\tpep->smi_bus->read = pxa168_smi_read;\n\tpep->smi_bus->write = pxa168_smi_write;\n\tsnprintf(pep->smi_bus->id, MII_BUS_ID_SIZE, \"%s-%d\",\n\t\tpdev->name, pdev->id);\n\tpep->smi_bus->parent = &pdev->dev;\n\tpep->smi_bus->phy_mask = 0xffffffff;\n\terr = mdiobus_register(pep->smi_bus);\n\tif (err)\n\t\tgoto err_free_mdio;\n\n\tpep->pdev = pdev;\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tpxa168_init_hw(pep);\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto err_mdiobus;\n\treturn 0;\n\nerr_mdiobus:\n\tmdiobus_unregister(pep->smi_bus);\nerr_free_mdio:\n\tmdiobus_free(pep->smi_bus);\nerr_netdev:\n\tfree_netdev(dev);\nerr_clk:\n\tclk_disable_unprepare(clk);\n\treturn err;\n}\n\nstatic int pxa168_eth_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct pxa168_eth_private *pep = netdev_priv(dev);\n\n\tcancel_work_sync(&pep->tx_timeout_task);\n\tif (pep->htpr) {\n\t\tdma_free_coherent(pep->dev->dev.parent, HASH_ADDR_TABLE_SIZE,\n\t\t\t\t  pep->htpr, pep->htpr_dma);\n\t\tpep->htpr = NULL;\n\t}\n\tif (dev->phydev)\n\t\tphy_disconnect(dev->phydev);\n\n\tclk_disable_unprepare(pep->clk);\n\tmdiobus_unregister(pep->smi_bus);\n\tmdiobus_free(pep->smi_bus);\n\tunregister_netdev(dev);\n\tfree_netdev(dev);\n\treturn 0;\n}\n\nstatic void pxa168_eth_shutdown(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\teth_port_reset(dev);\n}\n\n#ifdef CONFIG_PM\nstatic int pxa168_eth_resume(struct platform_device *pdev)\n{\n\treturn -ENOSYS;\n}\n\nstatic int pxa168_eth_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\treturn -ENOSYS;\n}\n\n#else\n#define pxa168_eth_resume NULL\n#define pxa168_eth_suspend NULL\n#endif\n\nstatic const struct of_device_id pxa168_eth_of_match[] = {\n\t{ .compatible = \"marvell,pxa168-eth\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pxa168_eth_of_match);\n\nstatic struct platform_driver pxa168_eth_driver = {\n\t.probe = pxa168_eth_probe,\n\t.remove = pxa168_eth_remove,\n\t.shutdown = pxa168_eth_shutdown,\n\t.resume = pxa168_eth_resume,\n\t.suspend = pxa168_eth_suspend,\n\t.driver = {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table\t= pxa168_eth_of_match,\n\t},\n};\n\nmodule_platform_driver(pxa168_eth_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Ethernet driver for Marvell PXA168\");\nMODULE_ALIAS(\"platform:pxa168_eth\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}