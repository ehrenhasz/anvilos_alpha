{
  "module_name": "mvpp2_tai.c",
  "hash_id": "9835e2cf4cadb8067d68758a8627600463e0f63b009bd3471b8824751e1015a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/marvell/mvpp2/mvpp2_tai.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/slab.h>\n\n#include \"mvpp2.h\"\n\n#define CR0_SW_NRESET\t\t\tBIT(0)\n\n#define TCFCR0_PHASE_UPDATE_ENABLE\tBIT(8)\n#define TCFCR0_TCF_MASK\t\t\t(7 << 2)\n#define TCFCR0_TCF_UPDATE\t\t(0 << 2)\n#define TCFCR0_TCF_FREQUPDATE\t\t(1 << 2)\n#define TCFCR0_TCF_INCREMENT\t\t(2 << 2)\n#define TCFCR0_TCF_DECREMENT\t\t(3 << 2)\n#define TCFCR0_TCF_CAPTURE\t\t(4 << 2)\n#define TCFCR0_TCF_NOP\t\t\t(7 << 2)\n#define TCFCR0_TCF_TRIGGER\t\tBIT(0)\n\n#define TCSR_CAPTURE_1_VALID\t\tBIT(1)\n#define TCSR_CAPTURE_0_VALID\t\tBIT(0)\n\nstruct mvpp2_tai {\n\tstruct ptp_clock_info caps;\n\tstruct ptp_clock *ptp_clock;\n\tvoid __iomem *base;\n\tspinlock_t lock;\n\tu64 period;\t\t \n\t \n\tstruct timespec64 stamp;\n};\n\nstatic void mvpp2_tai_modify(void __iomem *reg, u32 mask, u32 set)\n{\n\tu32 val;\n\n\tval = readl_relaxed(reg) & ~mask;\n\tval |= set & mask;\n\twritel(val, reg);\n}\n\nstatic void mvpp2_tai_write(u32 val, void __iomem *reg)\n{\n\twritel_relaxed(val & 0xffff, reg);\n}\n\nstatic u32 mvpp2_tai_read(void __iomem *reg)\n{\n\treturn readl_relaxed(reg) & 0xffff;\n}\n\nstatic struct mvpp2_tai *ptp_to_tai(struct ptp_clock_info *ptp)\n{\n\treturn container_of(ptp, struct mvpp2_tai, caps);\n}\n\nstatic void mvpp22_tai_read_ts(struct timespec64 *ts, void __iomem *base)\n{\n\tts->tv_sec = (u64)mvpp2_tai_read(base + 0) << 32 |\n\t\t     mvpp2_tai_read(base + 4) << 16 |\n\t\t     mvpp2_tai_read(base + 8);\n\n\tts->tv_nsec = mvpp2_tai_read(base + 12) << 16 |\n\t\t      mvpp2_tai_read(base + 16);\n\n\t \n\treadl_relaxed(base + 20);\n\treadl_relaxed(base + 24);\n}\n\nstatic void mvpp2_tai_write_tlv(const struct timespec64 *ts, u32 frac,\n\t\t\t        void __iomem *base)\n{\n\tmvpp2_tai_write(ts->tv_sec >> 32, base + MVPP22_TAI_TLV_SEC_HIGH);\n\tmvpp2_tai_write(ts->tv_sec >> 16, base + MVPP22_TAI_TLV_SEC_MED);\n\tmvpp2_tai_write(ts->tv_sec, base + MVPP22_TAI_TLV_SEC_LOW);\n\tmvpp2_tai_write(ts->tv_nsec >> 16, base + MVPP22_TAI_TLV_NANO_HIGH);\n\tmvpp2_tai_write(ts->tv_nsec, base + MVPP22_TAI_TLV_NANO_LOW);\n\tmvpp2_tai_write(frac >> 16, base + MVPP22_TAI_TLV_FRAC_HIGH);\n\tmvpp2_tai_write(frac, base + MVPP22_TAI_TLV_FRAC_LOW);\n}\n\nstatic void mvpp2_tai_op(u32 op, void __iomem *base)\n{\n\t \n\tmvpp2_tai_modify(base + MVPP22_TAI_TCFCR0,\n\t\t\t TCFCR0_TCF_MASK | TCFCR0_TCF_TRIGGER,\n\t\t\t op | TCFCR0_TCF_TRIGGER);\n\tmvpp2_tai_modify(base + MVPP22_TAI_TCFCR0, TCFCR0_TCF_MASK,\n\t\t\t TCFCR0_TCF_NOP);\n}\n\n \nstatic u64 mvpp22_calc_frac_ppm(struct mvpp2_tai *tai, long abs_scaled_ppm)\n{\n\tu64 val = tai->period * abs_scaled_ppm >> 4;\n\n\treturn div_u64(val, (1000000 << 12) + (abs_scaled_ppm >> 4));\n}\n\nstatic s32 mvpp22_calc_max_adj(struct mvpp2_tai *tai)\n{\n\treturn 1000000;\n}\n\nstatic int mvpp22_tai_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct mvpp2_tai *tai = ptp_to_tai(ptp);\n\tunsigned long flags;\n\tvoid __iomem *base;\n\tbool neg_adj;\n\ts32 frac;\n\tu64 val;\n\n\tneg_adj = scaled_ppm < 0;\n\tif (neg_adj)\n\t\tscaled_ppm = -scaled_ppm;\n\n\tval = mvpp22_calc_frac_ppm(tai, scaled_ppm);\n\n\t \n\tif (neg_adj) {\n\t\t \n\t\tif (val > 0x80000000)\n\t\t\treturn -ERANGE;\n\n\t\tfrac = -val;\n\t} else {\n\t\tif (val > S32_MAX)\n\t\t\treturn -ERANGE;\n\n\t\tfrac = val;\n\t}\n\n\tbase = tai->base;\n\tspin_lock_irqsave(&tai->lock, flags);\n\tmvpp2_tai_write(frac >> 16, base + MVPP22_TAI_TLV_FRAC_HIGH);\n\tmvpp2_tai_write(frac, base + MVPP22_TAI_TLV_FRAC_LOW);\n\tmvpp2_tai_op(TCFCR0_TCF_FREQUPDATE, base);\n\tspin_unlock_irqrestore(&tai->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mvpp22_tai_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct mvpp2_tai *tai = ptp_to_tai(ptp);\n\tstruct timespec64 ts;\n\tunsigned long flags;\n\tvoid __iomem *base;\n\tu32 tcf;\n\n\t \n\tif (delta == S64_MIN)\n\t\treturn -ERANGE;\n\n\tif (delta < 0) {\n\t\tdelta = -delta;\n\t\ttcf = TCFCR0_TCF_DECREMENT;\n\t} else {\n\t\ttcf = TCFCR0_TCF_INCREMENT;\n\t}\n\n\tts = ns_to_timespec64(delta);\n\n\tbase = tai->base;\n\tspin_lock_irqsave(&tai->lock, flags);\n\tmvpp2_tai_write_tlv(&ts, 0, base);\n\tmvpp2_tai_op(tcf, base);\n\tspin_unlock_irqrestore(&tai->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mvpp22_tai_gettimex64(struct ptp_clock_info *ptp,\n\t\t\t\t struct timespec64 *ts,\n\t\t\t\t struct ptp_system_timestamp *sts)\n{\n\tstruct mvpp2_tai *tai = ptp_to_tai(ptp);\n\tunsigned long flags;\n\tvoid __iomem *base;\n\tu32 tcsr;\n\tint ret;\n\n\tbase = tai->base;\n\tspin_lock_irqsave(&tai->lock, flags);\n\t \n\tptp_read_system_prets(sts);\n\tmvpp2_tai_modify(base + MVPP22_TAI_TCFCR0,\n\t\t\t TCFCR0_TCF_MASK | TCFCR0_TCF_TRIGGER,\n\t\t\t TCFCR0_TCF_CAPTURE | TCFCR0_TCF_TRIGGER);\n\tptp_read_system_postts(sts);\n\tmvpp2_tai_modify(base + MVPP22_TAI_TCFCR0, TCFCR0_TCF_MASK,\n\t\t\t TCFCR0_TCF_NOP);\n\n\ttcsr = readl(base + MVPP22_TAI_TCSR);\n\tif (tcsr & TCSR_CAPTURE_1_VALID) {\n\t\tmvpp22_tai_read_ts(ts, base + MVPP22_TAI_TCV1_SEC_HIGH);\n\t\tret = 0;\n\t} else if (tcsr & TCSR_CAPTURE_0_VALID) {\n\t\tmvpp22_tai_read_ts(ts, base + MVPP22_TAI_TCV0_SEC_HIGH);\n\t\tret = 0;\n\t} else {\n\t\t \n\t\tret = -EBUSY;\n\t}\n\tspin_unlock_irqrestore(&tai->lock, flags);\n\n\treturn ret;\n}\n\nstatic int mvpp22_tai_settime64(struct ptp_clock_info *ptp,\n\t\t\t\tconst struct timespec64 *ts)\n{\n\tstruct mvpp2_tai *tai = ptp_to_tai(ptp);\n\tunsigned long flags;\n\tvoid __iomem *base;\n\n\tbase = tai->base;\n\tspin_lock_irqsave(&tai->lock, flags);\n\tmvpp2_tai_write_tlv(ts, 0, base);\n\n\t \n\tmvpp2_tai_modify(base + MVPP22_TAI_TCFCR0,\n\t\t\t TCFCR0_PHASE_UPDATE_ENABLE |\n\t\t\t TCFCR0_TCF_MASK | TCFCR0_TCF_TRIGGER,\n\t\t\t TCFCR0_TCF_UPDATE | TCFCR0_TCF_TRIGGER);\n\tmvpp2_tai_modify(base + MVPP22_TAI_TCFCR0, TCFCR0_TCF_MASK,\n\t\t\t TCFCR0_TCF_NOP);\n\tspin_unlock_irqrestore(&tai->lock, flags);\n\n\treturn 0;\n}\n\nstatic long mvpp22_tai_aux_work(struct ptp_clock_info *ptp)\n{\n\tstruct mvpp2_tai *tai = ptp_to_tai(ptp);\n\n\tmvpp22_tai_gettimex64(ptp, &tai->stamp, NULL);\n\n\treturn msecs_to_jiffies(2000);\n}\n\nstatic void mvpp22_tai_set_step(struct mvpp2_tai *tai)\n{\n\tvoid __iomem *base = tai->base;\n\tu32 nano, frac;\n\n\tnano = upper_32_bits(tai->period);\n\tfrac = lower_32_bits(tai->period);\n\n\t \n\tif (frac >= 0x80000000)\n\t\tnano += 1;\n\n\tmvpp2_tai_write(nano, base + MVPP22_TAI_TOD_STEP_NANO_CR);\n\tmvpp2_tai_write(frac >> 16, base + MVPP22_TAI_TOD_STEP_FRAC_HIGH);\n\tmvpp2_tai_write(frac, base + MVPP22_TAI_TOD_STEP_FRAC_LOW);\n}\n\nstatic void mvpp22_tai_init(struct mvpp2_tai *tai)\n{\n\tvoid __iomem *base = tai->base;\n\n\tmvpp22_tai_set_step(tai);\n\n\t \n\tmvpp2_tai_modify(base + MVPP22_TAI_CR0, CR0_SW_NRESET, CR0_SW_NRESET);\n}\n\nint mvpp22_tai_ptp_clock_index(struct mvpp2_tai *tai)\n{\n\treturn ptp_clock_index(tai->ptp_clock);\n}\n\nvoid mvpp22_tai_tstamp(struct mvpp2_tai *tai, u32 tstamp,\n\t\t       struct skb_shared_hwtstamps *hwtstamp)\n{\n\tstruct timespec64 ts;\n\tint delta;\n\n\t \n\tts.tv_sec = READ_ONCE(tai->stamp.tv_sec);\n\tts.tv_nsec = tstamp & 0x3fffffff;\n\n\t \n\tdelta = ((tstamp >> 30) - (ts.tv_sec & 3)) & 3;\n\tif (delta == 3)\n\t\tdelta -= 4;\n\tts.tv_sec += delta;\n\n\tmemset(hwtstamp, 0, sizeof(*hwtstamp));\n\thwtstamp->hwtstamp = timespec64_to_ktime(ts);\n}\n\nvoid mvpp22_tai_start(struct mvpp2_tai *tai)\n{\n\tlong delay;\n\n\tdelay = mvpp22_tai_aux_work(&tai->caps);\n\n\tptp_schedule_worker(tai->ptp_clock, delay);\n}\n\nvoid mvpp22_tai_stop(struct mvpp2_tai *tai)\n{\n\tptp_cancel_worker_sync(tai->ptp_clock);\n}\n\nstatic void mvpp22_tai_remove(void *priv)\n{\n\tstruct mvpp2_tai *tai = priv;\n\n\tif (!IS_ERR(tai->ptp_clock))\n\t\tptp_clock_unregister(tai->ptp_clock);\n}\n\nint mvpp22_tai_probe(struct device *dev, struct mvpp2 *priv)\n{\n\tstruct mvpp2_tai *tai;\n\tint ret;\n\n\ttai = devm_kzalloc(dev, sizeof(*tai), GFP_KERNEL);\n\tif (!tai)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&tai->lock);\n\n\ttai->base = priv->iface_base;\n\n\t \n\ttai->period = 3ULL << 32;\n\n\tmvpp22_tai_init(tai);\n\n\ttai->caps.owner = THIS_MODULE;\n\tstrscpy(tai->caps.name, \"Marvell PP2.2\", sizeof(tai->caps.name));\n\ttai->caps.max_adj = mvpp22_calc_max_adj(tai);\n\ttai->caps.adjfine = mvpp22_tai_adjfine;\n\ttai->caps.adjtime = mvpp22_tai_adjtime;\n\ttai->caps.gettimex64 = mvpp22_tai_gettimex64;\n\ttai->caps.settime64 = mvpp22_tai_settime64;\n\ttai->caps.do_aux_work = mvpp22_tai_aux_work;\n\n\tret = devm_add_action(dev, mvpp22_tai_remove, tai);\n\tif (ret)\n\t\treturn ret;\n\n\ttai->ptp_clock = ptp_clock_register(&tai->caps, dev);\n\tif (IS_ERR(tai->ptp_clock))\n\t\treturn PTR_ERR(tai->ptp_clock);\n\n\tpriv->tai = tai;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}