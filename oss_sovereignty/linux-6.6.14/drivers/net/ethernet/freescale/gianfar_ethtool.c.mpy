{
  "module_name": "gianfar_ethtool.c",
  "hash_id": "8f9845d3a6e1b703a9e324fec0957c455a62e2ee7b3172d83a2dc639b4e04838",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/gianfar_ethtool.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/net_tstamp.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/crc32.h>\n#include <asm/types.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/phy.h>\n#include <linux/sort.h>\n#include <linux/if_vlan.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/fsl/ptp_qoriq.h>\n\n#include \"gianfar.h\"\n\n#define GFAR_MAX_COAL_USECS 0xffff\n#define GFAR_MAX_COAL_FRAMES 0xff\n\nstatic const char stat_gstrings[][ETH_GSTRING_LEN] = {\n\t \n\t\"rx-allocation-errors\",\n\t\"rx-large-frame-errors\",\n\t\"rx-short-frame-errors\",\n\t\"rx-non-octet-errors\",\n\t\"rx-crc-errors\",\n\t\"rx-overrun-errors\",\n\t\"rx-busy-errors\",\n\t\"rx-babbling-errors\",\n\t\"rx-truncated-frames\",\n\t\"ethernet-bus-error\",\n\t\"tx-babbling-errors\",\n\t\"tx-underrun-errors\",\n\t\"tx-timeout-errors\",\n\t \n\t\"tx-rx-64-frames\",\n\t\"tx-rx-65-127-frames\",\n\t\"tx-rx-128-255-frames\",\n\t\"tx-rx-256-511-frames\",\n\t\"tx-rx-512-1023-frames\",\n\t\"tx-rx-1024-1518-frames\",\n\t\"tx-rx-1519-1522-good-vlan\",\n\t\"rx-bytes\",\n\t\"rx-packets\",\n\t\"rx-fcs-errors\",\n\t\"receive-multicast-packet\",\n\t\"receive-broadcast-packet\",\n\t\"rx-control-frame-packets\",\n\t\"rx-pause-frame-packets\",\n\t\"rx-unknown-op-code\",\n\t\"rx-alignment-error\",\n\t\"rx-frame-length-error\",\n\t\"rx-code-error\",\n\t\"rx-carrier-sense-error\",\n\t\"rx-undersize-packets\",\n\t\"rx-oversize-packets\",\n\t\"rx-fragmented-frames\",\n\t\"rx-jabber-frames\",\n\t\"rx-dropped-frames\",\n\t\"tx-byte-counter\",\n\t\"tx-packets\",\n\t\"tx-multicast-packets\",\n\t\"tx-broadcast-packets\",\n\t\"tx-pause-control-frames\",\n\t\"tx-deferral-packets\",\n\t\"tx-excessive-deferral-packets\",\n\t\"tx-single-collision-packets\",\n\t\"tx-multiple-collision-packets\",\n\t\"tx-late-collision-packets\",\n\t\"tx-excessive-collision-packets\",\n\t\"tx-total-collision\",\n\t\"reserved\",\n\t\"tx-dropped-frames\",\n\t\"tx-jabber-frames\",\n\t\"tx-fcs-errors\",\n\t\"tx-control-frames\",\n\t\"tx-oversize-frames\",\n\t\"tx-undersize-frames\",\n\t\"tx-fragmented-frames\",\n};\n\n \nstatic void gfar_gstrings(struct net_device *dev, u32 stringset, u8 * buf)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\n\tif (priv->device_flags & FSL_GIANFAR_DEV_HAS_RMON)\n\t\tmemcpy(buf, stat_gstrings, GFAR_STATS_LEN * ETH_GSTRING_LEN);\n\telse\n\t\tmemcpy(buf, stat_gstrings,\n\t\t       GFAR_EXTRA_STATS_LEN * ETH_GSTRING_LEN);\n}\n\n \nstatic void gfar_fill_stats(struct net_device *dev, struct ethtool_stats *dummy,\n\t\t\t    u64 *buf)\n{\n\tint i;\n\tstruct gfar_private *priv = netdev_priv(dev);\n\tstruct gfar __iomem *regs = priv->gfargrp[0].regs;\n\tatomic64_t *extra = (atomic64_t *)&priv->extra_stats;\n\n\tfor (i = 0; i < GFAR_EXTRA_STATS_LEN; i++)\n\t\tbuf[i] = atomic64_read(&extra[i]);\n\n\tif (priv->device_flags & FSL_GIANFAR_DEV_HAS_RMON) {\n\t\tu32 __iomem *rmon = (u32 __iomem *) &regs->rmon;\n\n\t\tfor (; i < GFAR_STATS_LEN; i++, rmon++)\n\t\t\tbuf[i] = (u64) gfar_read(rmon);\n\t}\n}\n\nstatic int gfar_sset_count(struct net_device *dev, int sset)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\tif (priv->device_flags & FSL_GIANFAR_DEV_HAS_RMON)\n\t\t\treturn GFAR_STATS_LEN;\n\t\telse\n\t\t\treturn GFAR_EXTRA_STATS_LEN;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic void gfar_gdrvinfo(struct net_device *dev,\n\t\t\t  struct ethtool_drvinfo *drvinfo)\n{\n\tstrscpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\n}\n\n \nstatic int gfar_reglen(struct net_device *dev)\n{\n\treturn sizeof (struct gfar);\n}\n\n \nstatic void gfar_get_regs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t\t  void *regbuf)\n{\n\tint i;\n\tstruct gfar_private *priv = netdev_priv(dev);\n\tu32 __iomem *theregs = (u32 __iomem *) priv->gfargrp[0].regs;\n\tu32 *buf = (u32 *) regbuf;\n\n\tfor (i = 0; i < sizeof (struct gfar) / sizeof (u32); i++)\n\t\tbuf[i] = gfar_read(&theregs[i]);\n}\n\n \nstatic unsigned int gfar_usecs2ticks(struct gfar_private *priv,\n\t\t\t\t     unsigned int usecs)\n{\n\tstruct net_device *ndev = priv->ndev;\n\tstruct phy_device *phydev = ndev->phydev;\n\tunsigned int count;\n\n\t \n\tswitch (phydev->speed) {\n\tcase SPEED_1000:\n\t\tcount = GFAR_GBIT_TIME;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tcount = GFAR_100_TIME;\n\t\tbreak;\n\tcase SPEED_10:\n\tdefault:\n\t\tcount = GFAR_10_TIME;\n\t\tbreak;\n\t}\n\n\t \n\treturn DIV_ROUND_UP(usecs * 1000, count);\n}\n\n \nstatic unsigned int gfar_ticks2usecs(struct gfar_private *priv,\n\t\t\t\t     unsigned int ticks)\n{\n\tstruct net_device *ndev = priv->ndev;\n\tstruct phy_device *phydev = ndev->phydev;\n\tunsigned int count;\n\n\t \n\tswitch (phydev->speed) {\n\tcase SPEED_1000:\n\t\tcount = GFAR_GBIT_TIME;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tcount = GFAR_100_TIME;\n\t\tbreak;\n\tcase SPEED_10:\n\tdefault:\n\t\tcount = GFAR_10_TIME;\n\t\tbreak;\n\t}\n\n\t \n\t \n\treturn (ticks * count) / 1000;\n}\n\n \nstatic int gfar_gcoalesce(struct net_device *dev,\n\t\t\t  struct ethtool_coalesce *cvals,\n\t\t\t  struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\tstruct gfar_priv_rx_q *rx_queue = NULL;\n\tstruct gfar_priv_tx_q *tx_queue = NULL;\n\tunsigned long rxtime;\n\tunsigned long rxcount;\n\tunsigned long txtime;\n\tunsigned long txcount;\n\n\tif (!(priv->device_flags & FSL_GIANFAR_DEV_HAS_COALESCE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!dev->phydev)\n\t\treturn -ENODEV;\n\n\trx_queue = priv->rx_queue[0];\n\ttx_queue = priv->tx_queue[0];\n\n\trxtime  = get_ictt_value(rx_queue->rxic);\n\trxcount = get_icft_value(rx_queue->rxic);\n\ttxtime  = get_ictt_value(tx_queue->txic);\n\ttxcount = get_icft_value(tx_queue->txic);\n\tcvals->rx_coalesce_usecs = gfar_ticks2usecs(priv, rxtime);\n\tcvals->rx_max_coalesced_frames = rxcount;\n\n\tcvals->tx_coalesce_usecs = gfar_ticks2usecs(priv, txtime);\n\tcvals->tx_max_coalesced_frames = txcount;\n\n\treturn 0;\n}\n\n \nstatic int gfar_scoalesce(struct net_device *dev,\n\t\t\t  struct ethtool_coalesce *cvals,\n\t\t\t  struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\tint i, err = 0;\n\n\tif (!(priv->device_flags & FSL_GIANFAR_DEV_HAS_COALESCE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!dev->phydev)\n\t\treturn -ENODEV;\n\n\t \n\tif (cvals->rx_coalesce_usecs > GFAR_MAX_COAL_USECS) {\n\t\tnetdev_info(dev, \"Coalescing is limited to %d microseconds\\n\",\n\t\t\t    GFAR_MAX_COAL_USECS);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cvals->rx_max_coalesced_frames > GFAR_MAX_COAL_FRAMES) {\n\t\tnetdev_info(dev, \"Coalescing is limited to %d frames\\n\",\n\t\t\t    GFAR_MAX_COAL_FRAMES);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (cvals->tx_coalesce_usecs > GFAR_MAX_COAL_USECS) {\n\t\tnetdev_info(dev, \"Coalescing is limited to %d microseconds\\n\",\n\t\t\t    GFAR_MAX_COAL_USECS);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cvals->tx_max_coalesced_frames > GFAR_MAX_COAL_FRAMES) {\n\t\tnetdev_info(dev, \"Coalescing is limited to %d frames\\n\",\n\t\t\t    GFAR_MAX_COAL_FRAMES);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (test_and_set_bit_lock(GFAR_RESETTING, &priv->state))\n\t\tcpu_relax();\n\n\t \n\tif ((cvals->rx_coalesce_usecs == 0) ||\n\t    (cvals->rx_max_coalesced_frames == 0)) {\n\t\tfor (i = 0; i < priv->num_rx_queues; i++)\n\t\t\tpriv->rx_queue[i]->rxcoalescing = 0;\n\t} else {\n\t\tfor (i = 0; i < priv->num_rx_queues; i++)\n\t\t\tpriv->rx_queue[i]->rxcoalescing = 1;\n\t}\n\n\tfor (i = 0; i < priv->num_rx_queues; i++) {\n\t\tpriv->rx_queue[i]->rxic = mk_ic_value(\n\t\t\tcvals->rx_max_coalesced_frames,\n\t\t\tgfar_usecs2ticks(priv, cvals->rx_coalesce_usecs));\n\t}\n\n\t \n\tif ((cvals->tx_coalesce_usecs == 0) ||\n\t    (cvals->tx_max_coalesced_frames == 0)) {\n\t\tfor (i = 0; i < priv->num_tx_queues; i++)\n\t\t\tpriv->tx_queue[i]->txcoalescing = 0;\n\t} else {\n\t\tfor (i = 0; i < priv->num_tx_queues; i++)\n\t\t\tpriv->tx_queue[i]->txcoalescing = 1;\n\t}\n\n\tfor (i = 0; i < priv->num_tx_queues; i++) {\n\t\tpriv->tx_queue[i]->txic = mk_ic_value(\n\t\t\tcvals->tx_max_coalesced_frames,\n\t\t\tgfar_usecs2ticks(priv, cvals->tx_coalesce_usecs));\n\t}\n\n\tif (dev->flags & IFF_UP) {\n\t\tstop_gfar(dev);\n\t\terr = startup_gfar(dev);\n\t} else {\n\t\tgfar_mac_reset(priv);\n\t}\n\n\tclear_bit_unlock(GFAR_RESETTING, &priv->state);\n\n\treturn err;\n}\n\n \nstatic void gfar_gringparam(struct net_device *dev,\n\t\t\t    struct ethtool_ringparam *rvals,\n\t\t\t    struct kernel_ethtool_ringparam *kernel_rvals,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\tstruct gfar_priv_tx_q *tx_queue = NULL;\n\tstruct gfar_priv_rx_q *rx_queue = NULL;\n\n\ttx_queue = priv->tx_queue[0];\n\trx_queue = priv->rx_queue[0];\n\n\trvals->rx_max_pending = GFAR_RX_MAX_RING_SIZE;\n\trvals->rx_mini_max_pending = GFAR_RX_MAX_RING_SIZE;\n\trvals->rx_jumbo_max_pending = GFAR_RX_MAX_RING_SIZE;\n\trvals->tx_max_pending = GFAR_TX_MAX_RING_SIZE;\n\n\t \n\trvals->rx_pending = rx_queue->rx_ring_size;\n\trvals->rx_mini_pending = rx_queue->rx_ring_size;\n\trvals->rx_jumbo_pending = rx_queue->rx_ring_size;\n\trvals->tx_pending = tx_queue->tx_ring_size;\n}\n\n \nstatic int gfar_sringparam(struct net_device *dev,\n\t\t\t   struct ethtool_ringparam *rvals,\n\t\t\t   struct kernel_ethtool_ringparam *kernel_rvals,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\tint err = 0, i;\n\n\tif (rvals->rx_pending > GFAR_RX_MAX_RING_SIZE)\n\t\treturn -EINVAL;\n\n\tif (!is_power_of_2(rvals->rx_pending)) {\n\t\tnetdev_err(dev, \"Ring sizes must be a power of 2\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rvals->tx_pending > GFAR_TX_MAX_RING_SIZE)\n\t\treturn -EINVAL;\n\n\tif (!is_power_of_2(rvals->tx_pending)) {\n\t\tnetdev_err(dev, \"Ring sizes must be a power of 2\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twhile (test_and_set_bit_lock(GFAR_RESETTING, &priv->state))\n\t\tcpu_relax();\n\n\tif (dev->flags & IFF_UP)\n\t\tstop_gfar(dev);\n\n\t \n\tfor (i = 0; i < priv->num_rx_queues; i++)\n\t\tpriv->rx_queue[i]->rx_ring_size = rvals->rx_pending;\n\n\tfor (i = 0; i < priv->num_tx_queues; i++)\n\t\tpriv->tx_queue[i]->tx_ring_size = rvals->tx_pending;\n\n\t \n\tif (dev->flags & IFF_UP)\n\t\terr = startup_gfar(dev);\n\n\tclear_bit_unlock(GFAR_RESETTING, &priv->state);\n\n\treturn err;\n}\n\nstatic void gfar_gpauseparam(struct net_device *dev,\n\t\t\t     struct ethtool_pauseparam *epause)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\n\tepause->autoneg = !!priv->pause_aneg_en;\n\tepause->rx_pause = !!priv->rx_pause_en;\n\tepause->tx_pause = !!priv->tx_pause_en;\n}\n\nstatic int gfar_spauseparam(struct net_device *dev,\n\t\t\t    struct ethtool_pauseparam *epause)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tstruct gfar __iomem *regs = priv->gfargrp[0].regs;\n\n\tif (!phydev)\n\t\treturn -ENODEV;\n\n\tif (!phy_validate_pause(phydev, epause))\n\t\treturn -EINVAL;\n\n\tpriv->rx_pause_en = priv->tx_pause_en = 0;\n\tphy_set_asym_pause(phydev, epause->rx_pause, epause->tx_pause);\n\tif (epause->rx_pause) {\n\t\tpriv->rx_pause_en = 1;\n\n\t\tif (epause->tx_pause) {\n\t\t\tpriv->tx_pause_en = 1;\n\t\t}\n\t} else if (epause->tx_pause) {\n\t\tpriv->tx_pause_en = 1;\n\t}\n\n\tif (epause->autoneg)\n\t\tpriv->pause_aneg_en = 1;\n\telse\n\t\tpriv->pause_aneg_en = 0;\n\n\tif (!epause->autoneg) {\n\t\tu32 tempval = gfar_read(&regs->maccfg1);\n\n\t\ttempval &= ~(MACCFG1_TX_FLOW | MACCFG1_RX_FLOW);\n\n\t\tpriv->tx_actual_en = 0;\n\t\tif (priv->tx_pause_en) {\n\t\t\tpriv->tx_actual_en = 1;\n\t\t\ttempval |= MACCFG1_TX_FLOW;\n\t\t}\n\n\t\tif (priv->rx_pause_en)\n\t\t\ttempval |= MACCFG1_RX_FLOW;\n\t\tgfar_write(&regs->maccfg1, tempval);\n\t}\n\n\treturn 0;\n}\n\nint gfar_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tnetdev_features_t changed = dev->features ^ features;\n\tstruct gfar_private *priv = netdev_priv(dev);\n\tint err = 0;\n\n\tif (!(changed & (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t NETIF_F_RXCSUM)))\n\t\treturn 0;\n\n\twhile (test_and_set_bit_lock(GFAR_RESETTING, &priv->state))\n\t\tcpu_relax();\n\n\tdev->features = features;\n\n\tif (dev->flags & IFF_UP) {\n\t\t \n\t\tstop_gfar(dev);\n\t\terr = startup_gfar(dev);\n\t} else {\n\t\tgfar_mac_reset(priv);\n\t}\n\n\tclear_bit_unlock(GFAR_RESETTING, &priv->state);\n\n\treturn err;\n}\n\nstatic uint32_t gfar_get_msglevel(struct net_device *dev)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\n\treturn priv->msg_enable;\n}\n\nstatic void gfar_set_msglevel(struct net_device *dev, uint32_t data)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\n\tpriv->msg_enable = data;\n}\n\n#ifdef CONFIG_PM\nstatic void gfar_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\n\twol->supported = 0;\n\twol->wolopts = 0;\n\n\tif (priv->wol_supported & GFAR_WOL_MAGIC)\n\t\twol->supported |= WAKE_MAGIC;\n\n\tif (priv->wol_supported & GFAR_WOL_FILER_UCAST)\n\t\twol->supported |= WAKE_UCAST;\n\n\tif (priv->wol_opts & GFAR_WOL_MAGIC)\n\t\twol->wolopts |= WAKE_MAGIC;\n\n\tif (priv->wol_opts & GFAR_WOL_FILER_UCAST)\n\t\twol->wolopts |= WAKE_UCAST;\n}\n\nstatic int gfar_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\tu16 wol_opts = 0;\n\tint err;\n\n\tif (!priv->wol_supported && wol->wolopts)\n\t\treturn -EINVAL;\n\n\tif (wol->wolopts & ~(WAKE_MAGIC | WAKE_UCAST))\n\t\treturn -EINVAL;\n\n\tif (wol->wolopts & WAKE_MAGIC) {\n\t\twol_opts |= GFAR_WOL_MAGIC;\n\t} else {\n\t\tif (wol->wolopts & WAKE_UCAST)\n\t\t\twol_opts |= GFAR_WOL_FILER_UCAST;\n\t}\n\n\twol_opts &= priv->wol_supported;\n\tpriv->wol_opts = 0;\n\n\terr = device_set_wakeup_enable(priv->dev, wol_opts);\n\tif (err)\n\t\treturn err;\n\n\tpriv->wol_opts = wol_opts;\n\n\treturn 0;\n}\n#endif\n\nstatic void ethflow_to_filer_rules (struct gfar_private *priv, u64 ethflow)\n{\n\tu32 fcr = 0x0, fpr = FPR_FILER_MASK;\n\n\tif (ethflow & RXH_L2DA) {\n\t\tfcr = RQFCR_PID_DAH | RQFCR_CMP_NOMATCH |\n\t\t      RQFCR_HASH | RQFCR_AND | RQFCR_HASHTBL_0;\n\t\tpriv->ftp_rqfpr[priv->cur_filer_idx] = fpr;\n\t\tpriv->ftp_rqfcr[priv->cur_filer_idx] = fcr;\n\t\tgfar_write_filer(priv, priv->cur_filer_idx, fcr, fpr);\n\t\tpriv->cur_filer_idx = priv->cur_filer_idx - 1;\n\n\t\tfcr = RQFCR_PID_DAL | RQFCR_CMP_NOMATCH |\n\t\t      RQFCR_HASH | RQFCR_AND | RQFCR_HASHTBL_0;\n\t\tpriv->ftp_rqfpr[priv->cur_filer_idx] = fpr;\n\t\tpriv->ftp_rqfcr[priv->cur_filer_idx] = fcr;\n\t\tgfar_write_filer(priv, priv->cur_filer_idx, fcr, fpr);\n\t\tpriv->cur_filer_idx = priv->cur_filer_idx - 1;\n\t}\n\n\tif (ethflow & RXH_VLAN) {\n\t\tfcr = RQFCR_PID_VID | RQFCR_CMP_NOMATCH | RQFCR_HASH |\n\t\t      RQFCR_AND | RQFCR_HASHTBL_0;\n\t\tgfar_write_filer(priv, priv->cur_filer_idx, fcr, fpr);\n\t\tpriv->ftp_rqfpr[priv->cur_filer_idx] = fpr;\n\t\tpriv->ftp_rqfcr[priv->cur_filer_idx] = fcr;\n\t\tpriv->cur_filer_idx = priv->cur_filer_idx - 1;\n\t}\n\n\tif (ethflow & RXH_IP_SRC) {\n\t\tfcr = RQFCR_PID_SIA | RQFCR_CMP_NOMATCH | RQFCR_HASH |\n\t\t      RQFCR_AND | RQFCR_HASHTBL_0;\n\t\tpriv->ftp_rqfpr[priv->cur_filer_idx] = fpr;\n\t\tpriv->ftp_rqfcr[priv->cur_filer_idx] = fcr;\n\t\tgfar_write_filer(priv, priv->cur_filer_idx, fcr, fpr);\n\t\tpriv->cur_filer_idx = priv->cur_filer_idx - 1;\n\t}\n\n\tif (ethflow & (RXH_IP_DST)) {\n\t\tfcr = RQFCR_PID_DIA | RQFCR_CMP_NOMATCH | RQFCR_HASH |\n\t\t      RQFCR_AND | RQFCR_HASHTBL_0;\n\t\tpriv->ftp_rqfpr[priv->cur_filer_idx] = fpr;\n\t\tpriv->ftp_rqfcr[priv->cur_filer_idx] = fcr;\n\t\tgfar_write_filer(priv, priv->cur_filer_idx, fcr, fpr);\n\t\tpriv->cur_filer_idx = priv->cur_filer_idx - 1;\n\t}\n\n\tif (ethflow & RXH_L3_PROTO) {\n\t\tfcr = RQFCR_PID_L4P | RQFCR_CMP_NOMATCH | RQFCR_HASH |\n\t\t      RQFCR_AND | RQFCR_HASHTBL_0;\n\t\tpriv->ftp_rqfpr[priv->cur_filer_idx] = fpr;\n\t\tpriv->ftp_rqfcr[priv->cur_filer_idx] = fcr;\n\t\tgfar_write_filer(priv, priv->cur_filer_idx, fcr, fpr);\n\t\tpriv->cur_filer_idx = priv->cur_filer_idx - 1;\n\t}\n\n\tif (ethflow & RXH_L4_B_0_1) {\n\t\tfcr = RQFCR_PID_SPT | RQFCR_CMP_NOMATCH | RQFCR_HASH |\n\t\t      RQFCR_AND | RQFCR_HASHTBL_0;\n\t\tpriv->ftp_rqfpr[priv->cur_filer_idx] = fpr;\n\t\tpriv->ftp_rqfcr[priv->cur_filer_idx] = fcr;\n\t\tgfar_write_filer(priv, priv->cur_filer_idx, fcr, fpr);\n\t\tpriv->cur_filer_idx = priv->cur_filer_idx - 1;\n\t}\n\n\tif (ethflow & RXH_L4_B_2_3) {\n\t\tfcr = RQFCR_PID_DPT | RQFCR_CMP_NOMATCH | RQFCR_HASH |\n\t\t      RQFCR_AND | RQFCR_HASHTBL_0;\n\t\tpriv->ftp_rqfpr[priv->cur_filer_idx] = fpr;\n\t\tpriv->ftp_rqfcr[priv->cur_filer_idx] = fcr;\n\t\tgfar_write_filer(priv, priv->cur_filer_idx, fcr, fpr);\n\t\tpriv->cur_filer_idx = priv->cur_filer_idx - 1;\n\t}\n}\n\nstatic int gfar_ethflow_to_filer_table(struct gfar_private *priv, u64 ethflow,\n\t\t\t\t       u64 class)\n{\n\tunsigned int cmp_rqfpr;\n\tunsigned int *local_rqfpr;\n\tunsigned int *local_rqfcr;\n\tint i = 0x0, k = 0x0;\n\tint j = MAX_FILER_IDX, l = 0x0;\n\tint ret = 1;\n\n\tlocal_rqfpr = kmalloc_array(MAX_FILER_IDX + 1, sizeof(unsigned int),\n\t\t\t\t    GFP_KERNEL);\n\tlocal_rqfcr = kmalloc_array(MAX_FILER_IDX + 1, sizeof(unsigned int),\n\t\t\t\t    GFP_KERNEL);\n\tif (!local_rqfpr || !local_rqfcr) {\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\n\tswitch (class) {\n\tcase TCP_V4_FLOW:\n\t\tcmp_rqfpr = RQFPR_IPV4 |RQFPR_TCP;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tcmp_rqfpr = RQFPR_IPV4 |RQFPR_UDP;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tcmp_rqfpr = RQFPR_IPV6 |RQFPR_TCP;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tcmp_rqfpr = RQFPR_IPV6 |RQFPR_UDP;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"Right now this class is not supported\\n\");\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < MAX_FILER_IDX + 1; i++) {\n\t\tlocal_rqfpr[j] = priv->ftp_rqfpr[i];\n\t\tlocal_rqfcr[j] = priv->ftp_rqfcr[i];\n\t\tj--;\n\t\tif ((priv->ftp_rqfcr[i] ==\n\t\t     (RQFCR_PID_PARSE | RQFCR_CLE | RQFCR_AND)) &&\n\t\t    (priv->ftp_rqfpr[i] == cmp_rqfpr))\n\t\t\tbreak;\n\t}\n\n\tif (i == MAX_FILER_IDX + 1) {\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"No parse rule found, can't create hash rules\\n\");\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\n\t \n\tfor (l = i+1; l < MAX_FILER_IDX; l++) {\n\t\tif ((priv->ftp_rqfcr[l] & RQFCR_CLE) &&\n\t\t    !(priv->ftp_rqfcr[l] & RQFCR_AND)) {\n\t\t\tpriv->ftp_rqfcr[l] = RQFCR_CLE | RQFCR_CMP_EXACT |\n\t\t\t\t\t     RQFCR_HASHTBL_0 | RQFCR_PID_MASK;\n\t\t\tpriv->ftp_rqfpr[l] = FPR_FILER_MASK;\n\t\t\tgfar_write_filer(priv, l, priv->ftp_rqfcr[l],\n\t\t\t\t\t priv->ftp_rqfpr[l]);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(priv->ftp_rqfcr[l] & RQFCR_CLE) &&\n\t\t\t(priv->ftp_rqfcr[l] & RQFCR_AND))\n\t\t\tcontinue;\n\t\telse {\n\t\t\tlocal_rqfpr[j] = priv->ftp_rqfpr[l];\n\t\t\tlocal_rqfcr[j] = priv->ftp_rqfcr[l];\n\t\t\tj--;\n\t\t}\n\t}\n\n\tpriv->cur_filer_idx = l - 1;\n\n\t \n\tethflow_to_filer_rules(priv, ethflow);\n\n\t \n\tfor (k = j+1; k < MAX_FILER_IDX; k++) {\n\t\tpriv->ftp_rqfpr[priv->cur_filer_idx] = local_rqfpr[k];\n\t\tpriv->ftp_rqfcr[priv->cur_filer_idx] = local_rqfcr[k];\n\t\tgfar_write_filer(priv, priv->cur_filer_idx,\n\t\t\t\t local_rqfcr[k], local_rqfpr[k]);\n\t\tif (!priv->cur_filer_idx)\n\t\t\tbreak;\n\t\tpriv->cur_filer_idx = priv->cur_filer_idx - 1;\n\t}\n\nerr:\n\tkfree(local_rqfcr);\n\tkfree(local_rqfpr);\n\treturn ret;\n}\n\nstatic int gfar_set_hash_opts(struct gfar_private *priv,\n\t\t\t      struct ethtool_rxnfc *cmd)\n{\n\t \n\tif (!gfar_ethflow_to_filer_table(priv, cmd->data, cmd->flow_type))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int gfar_check_filer_hardware(struct gfar_private *priv)\n{\n\tstruct gfar __iomem *regs = priv->gfargrp[0].regs;\n\tu32 i;\n\n\t \n\ti = gfar_read(&regs->ecntrl);\n\ti &= ECNTRL_FIFM;\n\tif (i == ECNTRL_FIFM) {\n\t\tnetdev_notice(priv->ndev, \"Interface in FIFO mode\\n\");\n\t\ti = gfar_read(&regs->rctrl);\n\t\ti &= RCTRL_PRSDEP_MASK | RCTRL_PRSFM;\n\t\tif (i == (RCTRL_PRSDEP_MASK | RCTRL_PRSFM)) {\n\t\t\tnetdev_info(priv->ndev,\n\t\t\t\t    \"Receive Queue Filtering enabled\\n\");\n\t\t} else {\n\t\t\tnetdev_warn(priv->ndev,\n\t\t\t\t    \"Receive Queue Filtering disabled\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\t \n\telse {\n\t\ti = gfar_read(&regs->rctrl);\n\t\ti &= RCTRL_PRSDEP_MASK;\n\t\tif (i == RCTRL_PRSDEP_MASK) {\n\t\t\tnetdev_info(priv->ndev,\n\t\t\t\t    \"Receive Queue Filtering enabled\\n\");\n\t\t} else {\n\t\t\tnetdev_warn(priv->ndev,\n\t\t\t\t    \"Receive Queue Filtering disabled\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\t \n\tgfar_write(&regs->rbifx, 0xC0C1C2C3);\n\treturn 0;\n}\n\n \nstatic void gfar_set_mask(u32 mask, struct filer_table *tab)\n{\n\ttab->fe[tab->index].ctrl = RQFCR_AND | RQFCR_PID_MASK | RQFCR_CMP_EXACT;\n\ttab->fe[tab->index].prop = mask;\n\ttab->index++;\n}\n\n \nstatic void gfar_set_parse_bits(u32 value, u32 mask, struct filer_table *tab)\n{\n\tgfar_set_mask(mask, tab);\n\ttab->fe[tab->index].ctrl = RQFCR_CMP_EXACT | RQFCR_PID_PARSE |\n\t\t\t\t   RQFCR_AND;\n\ttab->fe[tab->index].prop = value;\n\ttab->index++;\n}\n\nstatic void gfar_set_general_attribute(u32 value, u32 mask, u32 flag,\n\t\t\t\t       struct filer_table *tab)\n{\n\tgfar_set_mask(mask, tab);\n\ttab->fe[tab->index].ctrl = RQFCR_CMP_EXACT | RQFCR_AND | flag;\n\ttab->fe[tab->index].prop = value;\n\ttab->index++;\n}\n\n \nstatic void gfar_set_attribute(u32 value, u32 mask, u32 flag,\n\t\t\t       struct filer_table *tab)\n{\n\tswitch (flag) {\n\t\t \n\tcase RQFCR_PID_PRI:\n\t\tif (!(value | mask))\n\t\t\treturn;\n\t\tmask |= RQFCR_PID_PRI_MASK;\n\t\tbreak;\n\t\t \n\tcase RQFCR_PID_L4P:\n\tcase RQFCR_PID_TOS:\n\t\tif (!~(mask | RQFCR_PID_L4P_MASK))\n\t\t\treturn;\n\t\tif (!mask)\n\t\t\tmask = ~0;\n\t\telse\n\t\t\tmask |= RQFCR_PID_L4P_MASK;\n\t\tbreak;\n\t\t \n\tcase RQFCR_PID_VID:\n\t\tif (!(value | mask))\n\t\t\treturn;\n\t\tmask |= RQFCR_PID_VID_MASK;\n\t\tbreak;\n\t\t \n\tcase RQFCR_PID_DPT:\n\tcase RQFCR_PID_SPT:\n\tcase RQFCR_PID_ETY:\n\t\tif (!~(mask | RQFCR_PID_PORT_MASK))\n\t\t\treturn;\n\t\tif (!mask)\n\t\t\tmask = ~0;\n\t\telse\n\t\t\tmask |= RQFCR_PID_PORT_MASK;\n\t\tbreak;\n\t\t \n\tcase RQFCR_PID_DAH:\n\tcase RQFCR_PID_DAL:\n\tcase RQFCR_PID_SAH:\n\tcase RQFCR_PID_SAL:\n\t\tif (!(value | mask))\n\t\t\treturn;\n\t\tmask |= RQFCR_PID_MAC_MASK;\n\t\tbreak;\n\t\t \n\tdefault:\n\t\tif (!~mask)\n\t\t\treturn;\n\t\tif (!mask)\n\t\t\tmask = ~0;\n\t\tbreak;\n\t}\n\tgfar_set_general_attribute(value, mask, flag, tab);\n}\n\n \nstatic void gfar_set_basic_ip(struct ethtool_tcpip4_spec *value,\n\t\t\t      struct ethtool_tcpip4_spec *mask,\n\t\t\t      struct filer_table *tab)\n{\n\tgfar_set_attribute(be32_to_cpu(value->ip4src),\n\t\t\t   be32_to_cpu(mask->ip4src),\n\t\t\t   RQFCR_PID_SIA, tab);\n\tgfar_set_attribute(be32_to_cpu(value->ip4dst),\n\t\t\t   be32_to_cpu(mask->ip4dst),\n\t\t\t   RQFCR_PID_DIA, tab);\n\tgfar_set_attribute(be16_to_cpu(value->pdst),\n\t\t\t   be16_to_cpu(mask->pdst),\n\t\t\t   RQFCR_PID_DPT, tab);\n\tgfar_set_attribute(be16_to_cpu(value->psrc),\n\t\t\t   be16_to_cpu(mask->psrc),\n\t\t\t   RQFCR_PID_SPT, tab);\n\tgfar_set_attribute(value->tos, mask->tos, RQFCR_PID_TOS, tab);\n}\n\n \nstatic void gfar_set_user_ip(struct ethtool_usrip4_spec *value,\n\t\t\t     struct ethtool_usrip4_spec *mask,\n\t\t\t     struct filer_table *tab)\n{\n\tgfar_set_attribute(be32_to_cpu(value->ip4src),\n\t\t\t   be32_to_cpu(mask->ip4src),\n\t\t\t   RQFCR_PID_SIA, tab);\n\tgfar_set_attribute(be32_to_cpu(value->ip4dst),\n\t\t\t   be32_to_cpu(mask->ip4dst),\n\t\t\t   RQFCR_PID_DIA, tab);\n\tgfar_set_attribute(value->tos, mask->tos, RQFCR_PID_TOS, tab);\n\tgfar_set_attribute(value->proto, mask->proto, RQFCR_PID_L4P, tab);\n\tgfar_set_attribute(be32_to_cpu(value->l4_4_bytes),\n\t\t\t   be32_to_cpu(mask->l4_4_bytes),\n\t\t\t   RQFCR_PID_ARB, tab);\n\n}\n\n \nstatic void gfar_set_ether(struct ethhdr *value, struct ethhdr *mask,\n\t\t\t   struct filer_table *tab)\n{\n\tu32 upper_temp_mask = 0;\n\tu32 lower_temp_mask = 0;\n\n\t \n\tif (!is_broadcast_ether_addr(mask->h_source)) {\n\t\tif (is_zero_ether_addr(mask->h_source)) {\n\t\t\tupper_temp_mask = 0xFFFFFFFF;\n\t\t\tlower_temp_mask = 0xFFFFFFFF;\n\t\t} else {\n\t\t\tupper_temp_mask = mask->h_source[0] << 16 |\n\t\t\t\t\t  mask->h_source[1] << 8  |\n\t\t\t\t\t  mask->h_source[2];\n\t\t\tlower_temp_mask = mask->h_source[3] << 16 |\n\t\t\t\t\t  mask->h_source[4] << 8  |\n\t\t\t\t\t  mask->h_source[5];\n\t\t}\n\t\t \n\t\tgfar_set_attribute(value->h_source[0] << 16 |\n\t\t\t\t   value->h_source[1] << 8  |\n\t\t\t\t   value->h_source[2],\n\t\t\t\t   upper_temp_mask, RQFCR_PID_SAH, tab);\n\t\t \n\t\tgfar_set_attribute(value->h_source[3] << 16 |\n\t\t\t\t   value->h_source[4] << 8  |\n\t\t\t\t   value->h_source[5],\n\t\t\t\t   lower_temp_mask, RQFCR_PID_SAL, tab);\n\t}\n\t \n\tif (!is_broadcast_ether_addr(mask->h_dest)) {\n\t\t \n\t\tif ((is_broadcast_ether_addr(value->h_dest) &&\n\t\t    is_zero_ether_addr(mask->h_dest))) {\n\t\t\tgfar_set_parse_bits(RQFPR_EBC, RQFPR_EBC, tab);\n\t\t} else {\n\t\t\tif (is_zero_ether_addr(mask->h_dest)) {\n\t\t\t\tupper_temp_mask = 0xFFFFFFFF;\n\t\t\t\tlower_temp_mask = 0xFFFFFFFF;\n\t\t\t} else {\n\t\t\t\tupper_temp_mask = mask->h_dest[0] << 16 |\n\t\t\t\t\t\t  mask->h_dest[1] << 8  |\n\t\t\t\t\t\t  mask->h_dest[2];\n\t\t\t\tlower_temp_mask = mask->h_dest[3] << 16 |\n\t\t\t\t\t\t  mask->h_dest[4] << 8  |\n\t\t\t\t\t\t  mask->h_dest[5];\n\t\t\t}\n\n\t\t\t \n\t\t\tgfar_set_attribute(value->h_dest[0] << 16 |\n\t\t\t\t\t   value->h_dest[1] << 8  |\n\t\t\t\t\t   value->h_dest[2],\n\t\t\t\t\t   upper_temp_mask, RQFCR_PID_DAH, tab);\n\t\t\t \n\t\t\tgfar_set_attribute(value->h_dest[3] << 16 |\n\t\t\t\t\t   value->h_dest[4] << 8  |\n\t\t\t\t\t   value->h_dest[5],\n\t\t\t\t\t   lower_temp_mask, RQFCR_PID_DAL, tab);\n\t\t}\n\t}\n\n\tgfar_set_attribute(be16_to_cpu(value->h_proto),\n\t\t\t   be16_to_cpu(mask->h_proto),\n\t\t\t   RQFCR_PID_ETY, tab);\n}\n\nstatic inline u32 vlan_tci_vid(struct ethtool_rx_flow_spec *rule)\n{\n\treturn be16_to_cpu(rule->h_ext.vlan_tci) & VLAN_VID_MASK;\n}\n\nstatic inline u32 vlan_tci_vidm(struct ethtool_rx_flow_spec *rule)\n{\n\treturn be16_to_cpu(rule->m_ext.vlan_tci) & VLAN_VID_MASK;\n}\n\nstatic inline u32 vlan_tci_cfi(struct ethtool_rx_flow_spec *rule)\n{\n\treturn be16_to_cpu(rule->h_ext.vlan_tci) & VLAN_CFI_MASK;\n}\n\nstatic inline u32 vlan_tci_cfim(struct ethtool_rx_flow_spec *rule)\n{\n\treturn be16_to_cpu(rule->m_ext.vlan_tci) & VLAN_CFI_MASK;\n}\n\nstatic inline u32 vlan_tci_prio(struct ethtool_rx_flow_spec *rule)\n{\n\treturn (be16_to_cpu(rule->h_ext.vlan_tci) & VLAN_PRIO_MASK) >>\n\t\tVLAN_PRIO_SHIFT;\n}\n\nstatic inline u32 vlan_tci_priom(struct ethtool_rx_flow_spec *rule)\n{\n\treturn (be16_to_cpu(rule->m_ext.vlan_tci) & VLAN_PRIO_MASK) >>\n\t\tVLAN_PRIO_SHIFT;\n}\n\n \nstatic int gfar_convert_to_filer(struct ethtool_rx_flow_spec *rule,\n\t\t\t\t struct filer_table *tab)\n{\n\tu32 vlan = 0, vlan_mask = 0;\n\tu32 id = 0, id_mask = 0;\n\tu32 cfi = 0, cfi_mask = 0;\n\tu32 prio = 0, prio_mask = 0;\n\tu32 old_index = tab->index;\n\n\t \n\tif ((rule->flow_type & FLOW_EXT) &&\n\t    (rule->m_ext.vlan_tci != cpu_to_be16(0xFFFF))) {\n\t\tif (!rule->m_ext.vlan_tci)\n\t\t\trule->m_ext.vlan_tci = cpu_to_be16(0xFFFF);\n\n\t\tvlan = RQFPR_VLN;\n\t\tvlan_mask = RQFPR_VLN;\n\n\t\t \n\t\tid = vlan_tci_vid(rule);\n\t\tid_mask = vlan_tci_vidm(rule);\n\t\tcfi = vlan_tci_cfi(rule);\n\t\tcfi_mask = vlan_tci_cfim(rule);\n\t\tprio = vlan_tci_prio(rule);\n\t\tprio_mask = vlan_tci_priom(rule);\n\n\t\tif (cfi_mask) {\n\t\t\tif (cfi)\n\t\t\t\tvlan |= RQFPR_CFI;\n\t\t\tvlan_mask |= RQFPR_CFI;\n\t\t}\n\t}\n\n\tswitch (rule->flow_type & ~FLOW_EXT) {\n\tcase TCP_V4_FLOW:\n\t\tgfar_set_parse_bits(RQFPR_IPV4 | RQFPR_TCP | vlan,\n\t\t\t\t    RQFPR_IPV4 | RQFPR_TCP | vlan_mask, tab);\n\t\tgfar_set_basic_ip(&rule->h_u.tcp_ip4_spec,\n\t\t\t\t  &rule->m_u.tcp_ip4_spec, tab);\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tgfar_set_parse_bits(RQFPR_IPV4 | RQFPR_UDP | vlan,\n\t\t\t\t    RQFPR_IPV4 | RQFPR_UDP | vlan_mask, tab);\n\t\tgfar_set_basic_ip(&rule->h_u.udp_ip4_spec,\n\t\t\t\t  &rule->m_u.udp_ip4_spec, tab);\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\t\tgfar_set_parse_bits(RQFPR_IPV4 | vlan, RQFPR_IPV4 | vlan_mask,\n\t\t\t\t    tab);\n\t\tgfar_set_attribute(132, 0, RQFCR_PID_L4P, tab);\n\t\tgfar_set_basic_ip((struct ethtool_tcpip4_spec *)&rule->h_u,\n\t\t\t\t  (struct ethtool_tcpip4_spec *)&rule->m_u,\n\t\t\t\t  tab);\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tgfar_set_parse_bits(RQFPR_IPV4 | vlan, RQFPR_IPV4 | vlan_mask,\n\t\t\t\t    tab);\n\t\tgfar_set_user_ip((struct ethtool_usrip4_spec *) &rule->h_u,\n\t\t\t\t (struct ethtool_usrip4_spec *) &rule->m_u,\n\t\t\t\t tab);\n\t\tbreak;\n\tcase ETHER_FLOW:\n\t\tif (vlan)\n\t\t\tgfar_set_parse_bits(vlan, vlan_mask, tab);\n\t\tgfar_set_ether((struct ethhdr *) &rule->h_u,\n\t\t\t       (struct ethhdr *) &rule->m_u, tab);\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\t \n\tif (vlan) {\n\t\tgfar_set_attribute(id, id_mask, RQFCR_PID_VID, tab);\n\t\tgfar_set_attribute(prio, prio_mask, RQFCR_PID_PRI, tab);\n\t}\n\n\t \n\tif (tab->index == old_index) {\n\t\tgfar_set_mask(0xFFFFFFFF, tab);\n\t\ttab->fe[tab->index].ctrl = 0x20;\n\t\ttab->fe[tab->index].prop = 0x0;\n\t\ttab->index++;\n\t}\n\n\t \n\ttab->fe[tab->index - 1].ctrl &= (~RQFCR_AND);\n\n\t \n\tif (rule->ring_cookie == RX_CLS_FLOW_DISC)\n\t\ttab->fe[tab->index - 1].ctrl |= RQFCR_RJE;\n\telse\n\t\ttab->fe[tab->index - 1].ctrl |= (rule->ring_cookie << 10);\n\n\t \n\tif (tab->index > (old_index + 2)) {\n\t\ttab->fe[old_index + 1].ctrl |= RQFCR_CLE;\n\t\ttab->fe[tab->index - 1].ctrl |= RQFCR_CLE;\n\t}\n\n\t \n\tif (tab->index > MAX_FILER_CACHE_IDX - 1)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n \nstatic int gfar_write_filer_table(struct gfar_private *priv,\n\t\t\t\t  struct filer_table *tab)\n{\n\tu32 i = 0;\n\tif (tab->index > MAX_FILER_IDX - 1)\n\t\treturn -EBUSY;\n\n\t \n\tfor (; i < MAX_FILER_IDX && (tab->fe[i].ctrl | tab->fe[i].prop); i++)\n\t\tgfar_write_filer(priv, i, tab->fe[i].ctrl, tab->fe[i].prop);\n\t \n\tfor (; i < MAX_FILER_IDX; i++)\n\t\tgfar_write_filer(priv, i, 0x60, 0xFFFFFFFF);\n\t \n\tgfar_write_filer(priv, i, 0x20, 0x0);\n\n\treturn 0;\n}\n\nstatic int gfar_check_capability(struct ethtool_rx_flow_spec *flow,\n\t\t\t\t struct gfar_private *priv)\n{\n\n\tif (flow->flow_type & FLOW_EXT)\t{\n\t\tif (~flow->m_ext.data[0] || ~flow->m_ext.data[1])\n\t\t\tnetdev_warn(priv->ndev,\n\t\t\t\t    \"User-specific data not supported!\\n\");\n\t\tif (~flow->m_ext.vlan_etype)\n\t\t\tnetdev_warn(priv->ndev,\n\t\t\t\t    \"VLAN-etype not supported!\\n\");\n\t}\n\tif (flow->flow_type == IP_USER_FLOW)\n\t\tif (flow->h_u.usr_ip4_spec.ip_ver != ETH_RX_NFC_IP4)\n\t\t\tnetdev_warn(priv->ndev,\n\t\t\t\t    \"IP-Version differing from IPv4 not supported!\\n\");\n\n\treturn 0;\n}\n\nstatic int gfar_process_filer_changes(struct gfar_private *priv)\n{\n\tstruct ethtool_flow_spec_container *j;\n\tstruct filer_table *tab;\n\ts32 ret = 0;\n\n\t \n\ttab = kzalloc(sizeof(*tab), GFP_KERNEL);\n\tif (tab == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tlist_for_each_entry(j, &priv->rx_list.list, list) {\n\t\tret = gfar_convert_to_filer(&j->fs, tab);\n\t\tif (ret == -EBUSY) {\n\t\t\tnetdev_err(priv->ndev,\n\t\t\t\t   \"Rule not added: No free space!\\n\");\n\t\t\tgoto end;\n\t\t}\n\t\tif (ret == -1) {\n\t\t\tnetdev_err(priv->ndev,\n\t\t\t\t   \"Rule not added: Unsupported Flow-type!\\n\");\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t \n\tret = gfar_write_filer_table(priv, tab);\n\tif (ret == -EBUSY) {\n\t\tnetdev_err(priv->ndev, \"Rule not added: No free space!\\n\");\n\t\tgoto end;\n\t}\n\nend:\n\tkfree(tab);\n\treturn ret;\n}\n\nstatic void gfar_invert_masks(struct ethtool_rx_flow_spec *flow)\n{\n\tu32 i = 0;\n\n\tfor (i = 0; i < sizeof(flow->m_u); i++)\n\t\tflow->m_u.hdata[i] ^= 0xFF;\n\n\tflow->m_ext.vlan_etype ^= cpu_to_be16(0xFFFF);\n\tflow->m_ext.vlan_tci ^= cpu_to_be16(0xFFFF);\n\tflow->m_ext.data[0] ^= cpu_to_be32(~0);\n\tflow->m_ext.data[1] ^= cpu_to_be32(~0);\n}\n\nstatic int gfar_add_cls(struct gfar_private *priv,\n\t\t\tstruct ethtool_rx_flow_spec *flow)\n{\n\tstruct ethtool_flow_spec_container *temp, *comp;\n\tint ret = 0;\n\n\ttemp = kmalloc(sizeof(*temp), GFP_KERNEL);\n\tif (temp == NULL)\n\t\treturn -ENOMEM;\n\tmemcpy(&temp->fs, flow, sizeof(temp->fs));\n\n\tgfar_invert_masks(&temp->fs);\n\tret = gfar_check_capability(&temp->fs, priv);\n\tif (ret)\n\t\tgoto clean_mem;\n\t \n\tif (list_empty(&priv->rx_list.list)) {\n\t\tret = gfar_check_filer_hardware(priv);\n\t\tif (ret != 0)\n\t\t\tgoto clean_mem;\n\t\tlist_add(&temp->list, &priv->rx_list.list);\n\t\tgoto process;\n\t} else {\n\t\tlist_for_each_entry(comp, &priv->rx_list.list, list) {\n\t\t\tif (comp->fs.location > flow->location) {\n\t\t\t\tlist_add_tail(&temp->list, &comp->list);\n\t\t\t\tgoto process;\n\t\t\t}\n\t\t\tif (comp->fs.location == flow->location) {\n\t\t\t\tnetdev_err(priv->ndev,\n\t\t\t\t\t   \"Rule not added: ID %d not free!\\n\",\n\t\t\t\t\t   flow->location);\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto clean_mem;\n\t\t\t}\n\t\t}\n\t\tlist_add_tail(&temp->list, &priv->rx_list.list);\n\t}\n\nprocess:\n\tpriv->rx_list.count++;\n\tret = gfar_process_filer_changes(priv);\n\tif (ret)\n\t\tgoto clean_list;\n\treturn ret;\n\nclean_list:\n\tpriv->rx_list.count--;\n\tlist_del(&temp->list);\nclean_mem:\n\tkfree(temp);\n\treturn ret;\n}\n\nstatic int gfar_del_cls(struct gfar_private *priv, u32 loc)\n{\n\tstruct ethtool_flow_spec_container *comp;\n\tu32 ret = -EINVAL;\n\n\tif (list_empty(&priv->rx_list.list))\n\t\treturn ret;\n\n\tlist_for_each_entry(comp, &priv->rx_list.list, list) {\n\t\tif (comp->fs.location == loc) {\n\t\t\tlist_del(&comp->list);\n\t\t\tkfree(comp);\n\t\t\tpriv->rx_list.count--;\n\t\t\tgfar_process_filer_changes(priv);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int gfar_get_cls(struct gfar_private *priv, struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_flow_spec_container *comp;\n\tu32 ret = -EINVAL;\n\n\tlist_for_each_entry(comp, &priv->rx_list.list, list) {\n\t\tif (comp->fs.location == cmd->fs.location) {\n\t\t\tmemcpy(&cmd->fs, &comp->fs, sizeof(cmd->fs));\n\t\t\tgfar_invert_masks(&cmd->fs);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int gfar_get_cls_all(struct gfar_private *priv,\n\t\t\t    struct ethtool_rxnfc *cmd, u32 *rule_locs)\n{\n\tstruct ethtool_flow_spec_container *comp;\n\tu32 i = 0;\n\n\tlist_for_each_entry(comp, &priv->rx_list.list, list) {\n\t\tif (i == cmd->rule_cnt)\n\t\t\treturn -EMSGSIZE;\n\t\trule_locs[i] = comp->fs.location;\n\t\ti++;\n\t}\n\n\tcmd->data = MAX_FILER_IDX;\n\tcmd->rule_cnt = i;\n\n\treturn 0;\n}\n\nstatic int gfar_set_nfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\tint ret = 0;\n\n\tif (test_bit(GFAR_RESETTING, &priv->state))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&priv->rx_queue_access);\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\tret = gfar_set_hash_opts(priv, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tif ((cmd->fs.ring_cookie != RX_CLS_FLOW_DISC &&\n\t\t     cmd->fs.ring_cookie >= priv->num_rx_queues) ||\n\t\t    cmd->fs.location >= MAX_FILER_IDX) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = gfar_add_cls(priv, &cmd->fs);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tret = gfar_del_cls(priv, cmd->fs.location);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&priv->rx_queue_access);\n\n\treturn ret;\n}\n\nstatic int gfar_get_nfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\n\t\t\tu32 *rule_locs)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\tint ret = 0;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = priv->num_rx_queues;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tcmd->rule_cnt = priv->rx_list.count;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tret = gfar_get_cls(priv, cmd);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tret = gfar_get_cls_all(priv, cmd, rule_locs);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int gfar_get_ts_info(struct net_device *dev,\n\t\t\t    struct ethtool_ts_info *info)\n{\n\tstruct gfar_private *priv = netdev_priv(dev);\n\tstruct platform_device *ptp_dev;\n\tstruct device_node *ptp_node;\n\tstruct ptp_qoriq *ptp = NULL;\n\n\tinfo->phc_index = -1;\n\n\tif (!(priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER)) {\n\t\tinfo->so_timestamping = SOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_SOFTWARE;\n\t\treturn 0;\n\t}\n\n\tptp_node = of_find_compatible_node(NULL, NULL, \"fsl,etsec-ptp\");\n\tif (ptp_node) {\n\t\tptp_dev = of_find_device_by_node(ptp_node);\n\t\tof_node_put(ptp_node);\n\t\tif (ptp_dev)\n\t\t\tptp = platform_get_drvdata(ptp_dev);\n\t}\n\n\tif (ptp)\n\t\tinfo->phc_index = ptp->phc_index;\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE;\n\tinfo->tx_types = (1 << HWTSTAMP_TX_OFF) |\n\t\t\t (1 << HWTSTAMP_TX_ON);\n\tinfo->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t   (1 << HWTSTAMP_FILTER_ALL);\n\treturn 0;\n}\n\nconst struct ethtool_ops gfar_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES,\n\t.get_drvinfo = gfar_gdrvinfo,\n\t.get_regs_len = gfar_reglen,\n\t.get_regs = gfar_get_regs,\n\t.get_link = ethtool_op_get_link,\n\t.get_coalesce = gfar_gcoalesce,\n\t.set_coalesce = gfar_scoalesce,\n\t.get_ringparam = gfar_gringparam,\n\t.set_ringparam = gfar_sringparam,\n\t.get_pauseparam = gfar_gpauseparam,\n\t.set_pauseparam = gfar_spauseparam,\n\t.get_strings = gfar_gstrings,\n\t.get_sset_count = gfar_sset_count,\n\t.get_ethtool_stats = gfar_fill_stats,\n\t.get_msglevel = gfar_get_msglevel,\n\t.set_msglevel = gfar_set_msglevel,\n#ifdef CONFIG_PM\n\t.get_wol = gfar_get_wol,\n\t.set_wol = gfar_set_wol,\n#endif\n\t.set_rxnfc = gfar_set_nfc,\n\t.get_rxnfc = gfar_get_nfc,\n\t.get_ts_info = gfar_get_ts_info,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}