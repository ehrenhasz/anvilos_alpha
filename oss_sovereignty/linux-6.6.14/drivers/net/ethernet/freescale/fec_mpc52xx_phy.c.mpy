{
  "module_name": "fec_mpc52xx_phy.c",
  "hash_id": "84b83d7288cd4d74577a7c3f8328689062e033870533c1316c96852bc1f8d416",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fec_mpc52xx_phy.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/phy.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_mdio.h>\n#include <linux/platform_device.h>\n#include <asm/io.h>\n#include <asm/mpc52xx.h>\n#include \"fec_mpc52xx.h\"\n\nstruct mpc52xx_fec_mdio_priv {\n\tstruct mpc52xx_fec __iomem *regs;\n};\n\nstatic int mpc52xx_fec_mdio_transfer(struct mii_bus *bus, int phy_id,\n\t\tint reg, u32 value)\n{\n\tstruct mpc52xx_fec_mdio_priv *priv = bus->priv;\n\tstruct mpc52xx_fec __iomem *fec = priv->regs;\n\tint tries = 3;\n\n\tvalue |= (phy_id << FEC_MII_DATA_PA_SHIFT) & FEC_MII_DATA_PA_MSK;\n\tvalue |= (reg << FEC_MII_DATA_RA_SHIFT) & FEC_MII_DATA_RA_MSK;\n\n\tout_be32(&fec->ievent, FEC_IEVENT_MII);\n\tout_be32(&fec->mii_data, value);\n\n\t \n\twhile (!(in_be32(&fec->ievent) & FEC_IEVENT_MII) && --tries)\n\t\tmsleep(1);\n\n\tif (!tries)\n\t\treturn -ETIMEDOUT;\n\n\treturn value & FEC_MII_DATA_OP_RD ?\n\t\tin_be32(&fec->mii_data) & FEC_MII_DATA_DATAMSK : 0;\n}\n\nstatic int mpc52xx_fec_mdio_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\treturn mpc52xx_fec_mdio_transfer(bus, phy_id, reg, FEC_MII_READ_FRAME);\n}\n\nstatic int mpc52xx_fec_mdio_write(struct mii_bus *bus, int phy_id, int reg,\n\t\tu16 data)\n{\n\treturn mpc52xx_fec_mdio_transfer(bus, phy_id, reg,\n\t\tdata | FEC_MII_WRITE_FRAME);\n}\n\nstatic int mpc52xx_fec_mdio_probe(struct platform_device *of)\n{\n\tstruct device *dev = &of->dev;\n\tstruct device_node *np = of->dev.of_node;\n\tstruct mii_bus *bus;\n\tstruct mpc52xx_fec_mdio_priv *priv;\n\tstruct resource res;\n\tint err;\n\n\tbus = mdiobus_alloc();\n\tif (bus == NULL)\n\t\treturn -ENOMEM;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tbus->name = \"mpc52xx MII bus\";\n\tbus->read = mpc52xx_fec_mdio_read;\n\tbus->write = mpc52xx_fec_mdio_write;\n\n\t \n\terr = of_address_to_resource(np, 0, &res);\n\tif (err)\n\t\tgoto out_free;\n\tpriv->regs = ioremap(res.start, resource_size(&res));\n\tif (priv->regs == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%x\", res.start);\n\tbus->priv = priv;\n\n\tbus->parent = dev;\n\tdev_set_drvdata(dev, bus);\n\n\t \n\tout_be32(&priv->regs->mii_speed, ((mpc5xxx_get_bus_frequency(dev) >> 20) / 5) << 1);\n\n\terr = of_mdiobus_register(bus, np);\n\tif (err)\n\t\tgoto out_unmap;\n\n\treturn 0;\n\n out_unmap:\n\tiounmap(priv->regs);\n out_free:\n\tkfree(priv);\n\tmdiobus_free(bus);\n\n\treturn err;\n}\n\nstatic void mpc52xx_fec_mdio_remove(struct platform_device *of)\n{\n\tstruct mii_bus *bus = platform_get_drvdata(of);\n\tstruct mpc52xx_fec_mdio_priv *priv = bus->priv;\n\n\tmdiobus_unregister(bus);\n\tiounmap(priv->regs);\n\tkfree(priv);\n\tmdiobus_free(bus);\n}\n\nstatic const struct of_device_id mpc52xx_fec_mdio_match[] = {\n\t{ .compatible = \"fsl,mpc5200b-mdio\", },\n\t{ .compatible = \"fsl,mpc5200-mdio\", },\n\t{ .compatible = \"mpc5200b-fec-phy\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mpc52xx_fec_mdio_match);\n\nstruct platform_driver mpc52xx_fec_mdio_driver = {\n\t.driver = {\n\t\t.name = \"mpc5200b-fec-phy\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = mpc52xx_fec_mdio_match,\n\t},\n\t.probe = mpc52xx_fec_mdio_probe,\n\t.remove_new = mpc52xx_fec_mdio_remove,\n};\n\n \nEXPORT_SYMBOL_GPL(mpc52xx_fec_mdio_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}