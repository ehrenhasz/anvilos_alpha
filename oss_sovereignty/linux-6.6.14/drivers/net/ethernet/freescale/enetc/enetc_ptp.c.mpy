{
  "module_name": "enetc_ptp.c",
  "hash_id": "7636fce778ced38b7d095600ceea62470ff166da9a5e482cbe14596ce863ecaa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/enetc/enetc_ptp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/fsl/ptp_qoriq.h>\n\n#include \"enetc.h\"\n\nint enetc_phc_index = -1;\nEXPORT_SYMBOL_GPL(enetc_phc_index);\n\nstatic struct ptp_clock_info enetc_ptp_caps = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ENETC PTP clock\",\n\t.max_adj\t= 512000,\n\t.n_alarm\t= 0,\n\t.n_ext_ts\t= 2,\n\t.n_per_out\t= 0,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 1,\n\t.adjfine\t= ptp_qoriq_adjfine,\n\t.adjtime\t= ptp_qoriq_adjtime,\n\t.gettime64\t= ptp_qoriq_gettime,\n\t.settime64\t= ptp_qoriq_settime,\n\t.enable\t\t= ptp_qoriq_enable,\n};\n\nstatic int enetc_ptp_probe(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tstruct ptp_qoriq *ptp_qoriq;\n\tvoid __iomem *base;\n\tint err, len, n;\n\n\tif (pdev->dev.of_node && !of_device_is_available(pdev->dev.of_node)) {\n\t\tdev_info(&pdev->dev, \"device is disabled, skipping\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = pci_enable_device_mem(pdev);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err, \"device enable failed\\n\");\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"DMA configuration failed: 0x%x\\n\", err);\n\t\tgoto err_dma;\n\t}\n\n\terr = pci_request_mem_regions(pdev, KBUILD_MODNAME);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"pci_request_regions failed err=%d\\n\", err);\n\t\tgoto err_pci_mem_reg;\n\t}\n\n\tpci_set_master(pdev);\n\n\tptp_qoriq = kzalloc(sizeof(*ptp_qoriq), GFP_KERNEL);\n\tif (!ptp_qoriq) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_ptp;\n\t}\n\n\tlen = pci_resource_len(pdev, ENETC_BAR_REGS);\n\n\tbase = ioremap(pci_resource_start(pdev, ENETC_BAR_REGS), len);\n\tif (!base) {\n\t\terr = -ENXIO;\n\t\tdev_err(&pdev->dev, \"ioremap() failed\\n\");\n\t\tgoto err_ioremap;\n\t}\n\n\t \n\tn = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSIX);\n\tif (n != 1) {\n\t\terr = -EPERM;\n\t\tgoto err_irq_vectors;\n\t}\n\n\tptp_qoriq->irq = pci_irq_vector(pdev, 0);\n\n\terr = request_irq(ptp_qoriq->irq, ptp_qoriq_isr, 0, DRIVER, ptp_qoriq);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"request_irq() failed!\\n\");\n\t\tgoto err_irq;\n\t}\n\n\tptp_qoriq->dev = &pdev->dev;\n\n\terr = ptp_qoriq_init(ptp_qoriq, base, &enetc_ptp_caps);\n\tif (err)\n\t\tgoto err_no_clock;\n\n\tenetc_phc_index = ptp_qoriq->phc_index;\n\tpci_set_drvdata(pdev, ptp_qoriq);\n\n\treturn 0;\n\nerr_no_clock:\n\tfree_irq(ptp_qoriq->irq, ptp_qoriq);\nerr_irq:\n\tpci_free_irq_vectors(pdev);\nerr_irq_vectors:\n\tiounmap(base);\nerr_ioremap:\n\tkfree(ptp_qoriq);\nerr_alloc_ptp:\n\tpci_release_mem_regions(pdev);\nerr_pci_mem_reg:\nerr_dma:\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\nstatic void enetc_ptp_remove(struct pci_dev *pdev)\n{\n\tstruct ptp_qoriq *ptp_qoriq = pci_get_drvdata(pdev);\n\n\tenetc_phc_index = -1;\n\tptp_qoriq_free(ptp_qoriq);\n\tpci_free_irq_vectors(pdev);\n\tkfree(ptp_qoriq);\n\n\tpci_release_mem_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic const struct pci_device_id enetc_ptp_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, ENETC_DEV_ID_PTP) },\n\t{ 0, }  \n};\nMODULE_DEVICE_TABLE(pci, enetc_ptp_id_table);\n\nstatic struct pci_driver enetc_ptp_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = enetc_ptp_id_table,\n\t.probe = enetc_ptp_probe,\n\t.remove = enetc_ptp_remove,\n};\nmodule_pci_driver(enetc_ptp_driver);\n\nMODULE_DESCRIPTION(\"ENETC PTP clock driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}