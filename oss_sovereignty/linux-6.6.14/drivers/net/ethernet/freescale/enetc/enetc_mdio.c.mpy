{
  "module_name": "enetc_mdio.c",
  "hash_id": "a1b1b84266a1296e4e82ba5b8edbf8564e068551444fa08538802a4e96f1c935",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/enetc/enetc_mdio.c",
  "human_readable_source": "\n \n\n#include <linux/fsl/enetc_mdio.h>\n#include <linux/mdio.h>\n#include <linux/of_mdio.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n\n#include \"enetc_pf.h\"\n\n#define\tENETC_MDIO_CFG\t0x0\t \n#define\tENETC_MDIO_CTL\t0x4\t \n#define\tENETC_MDIO_DATA\t0x8\t \n#define\tENETC_MDIO_ADDR\t0xc\t \n\n#define MDIO_CFG_CLKDIV(x)\t((((x) >> 1) & 0xff) << 8)\n#define MDIO_CFG_BSY\t\tBIT(0)\n#define MDIO_CFG_RD_ER\t\tBIT(1)\n#define MDIO_CFG_HOLD(x)\t(((x) << 2) & GENMASK(4, 2))\n#define MDIO_CFG_ENC45\t\tBIT(6)\n  \n#define MDIO_CFG_NEG\t\tBIT(23)\n\n#define ENETC_EMDIO_CFG \\\n\t(MDIO_CFG_HOLD(2) | \\\n\t MDIO_CFG_CLKDIV(258) | \\\n\t MDIO_CFG_NEG)\n\n#define MDIO_CTL_DEV_ADDR(x)\t((x) & 0x1f)\n#define MDIO_CTL_PORT_ADDR(x)\t(((x) & 0x1f) << 5)\n#define MDIO_CTL_READ\t\tBIT(15)\n\nstatic inline u32 enetc_mdio_rd(struct enetc_mdio_priv *mdio_priv, int off)\n{\n\treturn enetc_port_rd_mdio(mdio_priv->hw, mdio_priv->mdio_base + off);\n}\n\nstatic inline void enetc_mdio_wr(struct enetc_mdio_priv *mdio_priv, int off,\n\t\t\t\t u32 val)\n{\n\tenetc_port_wr_mdio(mdio_priv->hw, mdio_priv->mdio_base + off, val);\n}\n\nstatic bool enetc_mdio_is_busy(struct enetc_mdio_priv *mdio_priv)\n{\n\treturn enetc_mdio_rd(mdio_priv, ENETC_MDIO_CFG) & MDIO_CFG_BSY;\n}\n\nstatic int enetc_mdio_wait_complete(struct enetc_mdio_priv *mdio_priv)\n{\n\tbool is_busy;\n\n\treturn readx_poll_timeout(enetc_mdio_is_busy, mdio_priv,\n\t\t\t\t  is_busy, !is_busy, 10, 10 * 1000);\n}\n\nint enetc_mdio_write_c22(struct mii_bus *bus, int phy_id, int regnum,\n\t\t\t u16 value)\n{\n\tstruct enetc_mdio_priv *mdio_priv = bus->priv;\n\tu32 mdio_ctl, mdio_cfg;\n\tu16 dev_addr;\n\tint ret;\n\n\tmdio_cfg = ENETC_EMDIO_CFG;\n\tdev_addr = regnum & 0x1f;\n\tmdio_cfg &= ~MDIO_CFG_ENC45;\n\n\tenetc_mdio_wr(mdio_priv, ENETC_MDIO_CFG, mdio_cfg);\n\n\tret = enetc_mdio_wait_complete(mdio_priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);\n\tenetc_mdio_wr(mdio_priv, ENETC_MDIO_CTL, mdio_ctl);\n\n\t \n\tenetc_mdio_wr(mdio_priv, ENETC_MDIO_DATA, value);\n\n\tret = enetc_mdio_wait_complete(mdio_priv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(enetc_mdio_write_c22);\n\nint enetc_mdio_write_c45(struct mii_bus *bus, int phy_id, int dev_addr,\n\t\t\t int regnum, u16 value)\n{\n\tstruct enetc_mdio_priv *mdio_priv = bus->priv;\n\tu32 mdio_ctl, mdio_cfg;\n\tint ret;\n\n\tmdio_cfg = ENETC_EMDIO_CFG;\n\tmdio_cfg |= MDIO_CFG_ENC45;\n\n\tenetc_mdio_wr(mdio_priv, ENETC_MDIO_CFG, mdio_cfg);\n\n\tret = enetc_mdio_wait_complete(mdio_priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);\n\tenetc_mdio_wr(mdio_priv, ENETC_MDIO_CTL, mdio_ctl);\n\n\t \n\tenetc_mdio_wr(mdio_priv, ENETC_MDIO_ADDR, regnum & 0xffff);\n\n\tret = enetc_mdio_wait_complete(mdio_priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tenetc_mdio_wr(mdio_priv, ENETC_MDIO_DATA, value);\n\n\tret = enetc_mdio_wait_complete(mdio_priv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(enetc_mdio_write_c45);\n\nint enetc_mdio_read_c22(struct mii_bus *bus, int phy_id, int regnum)\n{\n\tstruct enetc_mdio_priv *mdio_priv = bus->priv;\n\tu32 mdio_ctl, mdio_cfg;\n\tu16 dev_addr, value;\n\tint ret;\n\n\tmdio_cfg = ENETC_EMDIO_CFG;\n\tdev_addr = regnum & 0x1f;\n\tmdio_cfg &= ~MDIO_CFG_ENC45;\n\n\tenetc_mdio_wr(mdio_priv, ENETC_MDIO_CFG, mdio_cfg);\n\n\tret = enetc_mdio_wait_complete(mdio_priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);\n\tenetc_mdio_wr(mdio_priv, ENETC_MDIO_CTL, mdio_ctl);\n\n\t \n\tenetc_mdio_wr(mdio_priv, ENETC_MDIO_CTL, mdio_ctl | MDIO_CTL_READ);\n\n\tret = enetc_mdio_wait_complete(mdio_priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (enetc_mdio_rd(mdio_priv, ENETC_MDIO_CFG) & MDIO_CFG_RD_ER) {\n\t\tdev_dbg(&bus->dev,\n\t\t\t\"Error while reading PHY%d reg at %d.%d\\n\",\n\t\t\tphy_id, dev_addr, regnum);\n\t\treturn 0xffff;\n\t}\n\n\tvalue = enetc_mdio_rd(mdio_priv, ENETC_MDIO_DATA) & 0xffff;\n\n\treturn value;\n}\nEXPORT_SYMBOL_GPL(enetc_mdio_read_c22);\n\nint enetc_mdio_read_c45(struct mii_bus *bus, int phy_id, int dev_addr,\n\t\t\tint regnum)\n{\n\tstruct enetc_mdio_priv *mdio_priv = bus->priv;\n\tu32 mdio_ctl, mdio_cfg;\n\tu16 value;\n\tint ret;\n\n\tmdio_cfg = ENETC_EMDIO_CFG;\n\tmdio_cfg |= MDIO_CFG_ENC45;\n\n\tenetc_mdio_wr(mdio_priv, ENETC_MDIO_CFG, mdio_cfg);\n\n\tret = enetc_mdio_wait_complete(mdio_priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);\n\tenetc_mdio_wr(mdio_priv, ENETC_MDIO_CTL, mdio_ctl);\n\n\t \n\tenetc_mdio_wr(mdio_priv, ENETC_MDIO_ADDR, regnum & 0xffff);\n\n\tret = enetc_mdio_wait_complete(mdio_priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tenetc_mdio_wr(mdio_priv, ENETC_MDIO_CTL, mdio_ctl | MDIO_CTL_READ);\n\n\tret = enetc_mdio_wait_complete(mdio_priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (enetc_mdio_rd(mdio_priv, ENETC_MDIO_CFG) & MDIO_CFG_RD_ER) {\n\t\tdev_dbg(&bus->dev,\n\t\t\t\"Error while reading PHY%d reg at %d.%d\\n\",\n\t\t\tphy_id, dev_addr, regnum);\n\t\treturn 0xffff;\n\t}\n\n\tvalue = enetc_mdio_rd(mdio_priv, ENETC_MDIO_DATA) & 0xffff;\n\n\treturn value;\n}\nEXPORT_SYMBOL_GPL(enetc_mdio_read_c45);\n\nstruct enetc_hw *enetc_hw_alloc(struct device *dev, void __iomem *port_regs)\n{\n\tstruct enetc_hw *hw;\n\n\thw = devm_kzalloc(dev, sizeof(*hw), GFP_KERNEL);\n\tif (!hw)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thw->port = port_regs;\n\n\treturn hw;\n}\nEXPORT_SYMBOL_GPL(enetc_hw_alloc);\n\n \nDEFINE_RWLOCK(enetc_mdio_lock);\nEXPORT_SYMBOL_GPL(enetc_mdio_lock);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}