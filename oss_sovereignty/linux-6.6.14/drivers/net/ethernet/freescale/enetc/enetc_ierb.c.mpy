{
  "module_name": "enetc_ierb.c",
  "hash_id": "27e63b7052a6a916be5fcba28018822613c704f54ffb206389f4b75dd111cc62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/enetc/enetc_ierb.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include \"enetc.h\"\n#include \"enetc_ierb.h\"\n\n \n#define ENETC_IERB_TXMBAR(port)\t\t\t(((port) * 0x100) + 0x8080)\n#define ENETC_IERB_RXMBER(port)\t\t\t(((port) * 0x100) + 0x8090)\n#define ENETC_IERB_RXMBLR(port)\t\t\t(((port) * 0x100) + 0x8094)\n#define ENETC_IERB_RXBCR(port)\t\t\t(((port) * 0x100) + 0x80a0)\n#define ENETC_IERB_TXBCR(port)\t\t\t(((port) * 0x100) + 0x80a8)\n#define ENETC_IERB_FMBDTR\t\t\t0xa000\n\n#define ENETC_RESERVED_FOR_ICM\t\t\t1024\n\nstruct enetc_ierb {\n\tvoid __iomem *regs;\n};\n\nstatic void enetc_ierb_write(struct enetc_ierb *ierb, u32 offset, u32 val)\n{\n\tiowrite32(val, ierb->regs + offset);\n}\n\nint enetc_ierb_register_pf(struct platform_device *pdev,\n\t\t\t   struct pci_dev *pf_pdev)\n{\n\tstruct enetc_ierb *ierb = platform_get_drvdata(pdev);\n\tint port = enetc_pf_to_port(pf_pdev);\n\tu16 tx_credit, rx_credit, tx_alloc;\n\n\tif (port < 0)\n\t\treturn -ENODEV;\n\n\tif (!ierb)\n\t\treturn -EPROBE_DEFER;\n\n\t \n\ttx_credit = roundup(1000 + ENETC_MAC_MAXFRM_SIZE / 2, 100);\n\n\t \n\ttx_alloc = roundup(2 * tx_credit + 4 * ENETC_MAC_MAXFRM_SIZE + 64, 16);\n\n\t \n\trx_credit = DIV_ROUND_UP(ENETC_MAC_MAXFRM_SIZE * 2, 8);\n\n\tenetc_ierb_write(ierb, ENETC_IERB_TXBCR(port), tx_credit);\n\tenetc_ierb_write(ierb, ENETC_IERB_TXMBAR(port), tx_alloc);\n\tenetc_ierb_write(ierb, ENETC_IERB_RXBCR(port), rx_credit);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(enetc_ierb_register_pf);\n\nstatic int enetc_ierb_probe(struct platform_device *pdev)\n{\n\tstruct enetc_ierb *ierb;\n\tvoid __iomem *regs;\n\n\tierb = devm_kzalloc(&pdev->dev, sizeof(*ierb), GFP_KERNEL);\n\tif (!ierb)\n\t\treturn -ENOMEM;\n\n\tregs = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tierb->regs = regs;\n\n\t \n\tenetc_ierb_write(ierb, ENETC_IERB_FMBDTR, ENETC_RESERVED_FOR_ICM);\n\n\tplatform_set_drvdata(pdev, ierb);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id enetc_ierb_match[] = {\n\t{ .compatible = \"fsl,ls1028a-enetc-ierb\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, enetc_ierb_match);\n\nstatic struct platform_driver enetc_ierb_driver = {\n\t.driver = {\n\t\t.name = \"fsl-enetc-ierb\",\n\t\t.of_match_table = enetc_ierb_match,\n\t},\n\t.probe = enetc_ierb_probe,\n};\n\nmodule_platform_driver(enetc_ierb_driver);\n\nMODULE_DESCRIPTION(\"NXP ENETC IERB\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}