{
  "module_name": "enetc_ethtool.c",
  "hash_id": "06ac673022e0b5c2d8c3cd0b70cc6a99dd6960e4fc05fe9c87e623955296b6e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/enetc/enetc_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool_netlink.h>\n#include <linux/net_tstamp.h>\n#include <linux/module.h>\n#include \"enetc.h\"\n\nstatic const u32 enetc_si_regs[] = {\n\tENETC_SIMR, ENETC_SIPMAR0, ENETC_SIPMAR1, ENETC_SICBDRMR,\n\tENETC_SICBDRSR,\tENETC_SICBDRBAR0, ENETC_SICBDRBAR1, ENETC_SICBDRPIR,\n\tENETC_SICBDRCIR, ENETC_SICBDRLENR, ENETC_SICAPR0, ENETC_SICAPR1,\n\tENETC_SIUEFDCR\n};\n\nstatic const u32 enetc_txbdr_regs[] = {\n\tENETC_TBMR, ENETC_TBSR, ENETC_TBBAR0, ENETC_TBBAR1,\n\tENETC_TBPIR, ENETC_TBCIR, ENETC_TBLENR, ENETC_TBIER, ENETC_TBICR0,\n\tENETC_TBICR1\n};\n\nstatic const u32 enetc_rxbdr_regs[] = {\n\tENETC_RBMR, ENETC_RBSR, ENETC_RBBSR, ENETC_RBCIR, ENETC_RBBAR0,\n\tENETC_RBBAR1, ENETC_RBPIR, ENETC_RBLENR, ENETC_RBIER, ENETC_RBICR0,\n\tENETC_RBICR1\n};\n\nstatic const u32 enetc_port_regs[] = {\n\tENETC_PMR, ENETC_PSR, ENETC_PSIPMR, ENETC_PSIPMAR0(0),\n\tENETC_PSIPMAR1(0), ENETC_PTXMBAR, ENETC_PCAPR0, ENETC_PCAPR1,\n\tENETC_PSICFGR0(0), ENETC_PRFSCAPR, ENETC_PTCMSDUR(0),\n\tENETC_PM0_CMD_CFG, ENETC_PM0_MAXFRM, ENETC_PM0_IF_MODE\n};\n\nstatic const u32 enetc_port_mm_regs[] = {\n\tENETC_MMCSR, ENETC_PFPMR, ENETC_PTCFPR(0), ENETC_PTCFPR(1),\n\tENETC_PTCFPR(2), ENETC_PTCFPR(3), ENETC_PTCFPR(4), ENETC_PTCFPR(5),\n\tENETC_PTCFPR(6), ENETC_PTCFPR(7),\n};\n\nstatic int enetc_get_reglen(struct net_device *ndev)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tint len;\n\n\tlen = ARRAY_SIZE(enetc_si_regs);\n\tlen += ARRAY_SIZE(enetc_txbdr_regs) * priv->num_tx_rings;\n\tlen += ARRAY_SIZE(enetc_rxbdr_regs) * priv->num_rx_rings;\n\n\tif (hw->port)\n\t\tlen += ARRAY_SIZE(enetc_port_regs);\n\n\tif (hw->port && !!(priv->si->hw_features & ENETC_SI_F_QBU))\n\t\tlen += ARRAY_SIZE(enetc_port_mm_regs);\n\n\tlen *= sizeof(u32) * 2;  \n\n\treturn len;\n}\n\nstatic void enetc_get_regs(struct net_device *ndev, struct ethtool_regs *regs,\n\t\t\t   void *regbuf)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tu32 *buf = (u32 *)regbuf;\n\tint i, j;\n\tu32 addr;\n\n\tfor (i = 0; i < ARRAY_SIZE(enetc_si_regs); i++) {\n\t\t*buf++ = enetc_si_regs[i];\n\t\t*buf++ = enetc_rd(hw, enetc_si_regs[i]);\n\t}\n\n\tfor (i = 0; i < priv->num_tx_rings; i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(enetc_txbdr_regs); j++) {\n\t\t\taddr = ENETC_BDR(TX, i, enetc_txbdr_regs[j]);\n\n\t\t\t*buf++ = addr;\n\t\t\t*buf++ = enetc_rd(hw, addr);\n\t\t}\n\t}\n\n\tfor (i = 0; i < priv->num_rx_rings; i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(enetc_rxbdr_regs); j++) {\n\t\t\taddr = ENETC_BDR(RX, i, enetc_rxbdr_regs[j]);\n\n\t\t\t*buf++ = addr;\n\t\t\t*buf++ = enetc_rd(hw, addr);\n\t\t}\n\t}\n\n\tif (!hw->port)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(enetc_port_regs); i++) {\n\t\taddr = ENETC_PORT_BASE + enetc_port_regs[i];\n\t\t*buf++ = addr;\n\t\t*buf++ = enetc_rd(hw, addr);\n\t}\n\n\tif (priv->si->hw_features & ENETC_SI_F_QBU) {\n\t\tfor (i = 0; i < ARRAY_SIZE(enetc_port_mm_regs); i++) {\n\t\t\taddr = ENETC_PORT_BASE + enetc_port_mm_regs[i];\n\t\t\t*buf++ = addr;\n\t\t\t*buf++ = enetc_rd(hw, addr);\n\t\t}\n\t}\n}\n\nstatic const struct {\n\tint reg;\n\tchar name[ETH_GSTRING_LEN];\n} enetc_si_counters[] =  {\n\t{ ENETC_SIROCT, \"SI rx octets\" },\n\t{ ENETC_SIRFRM, \"SI rx frames\" },\n\t{ ENETC_SIRUCA, \"SI rx u-cast frames\" },\n\t{ ENETC_SIRMCA, \"SI rx m-cast frames\" },\n\t{ ENETC_SITOCT, \"SI tx octets\" },\n\t{ ENETC_SITFRM, \"SI tx frames\" },\n\t{ ENETC_SITUCA, \"SI tx u-cast frames\" },\n\t{ ENETC_SITMCA, \"SI tx m-cast frames\" },\n\t{ ENETC_RBDCR(0), \"Rx ring  0 discarded frames\" },\n\t{ ENETC_RBDCR(1), \"Rx ring  1 discarded frames\" },\n\t{ ENETC_RBDCR(2), \"Rx ring  2 discarded frames\" },\n\t{ ENETC_RBDCR(3), \"Rx ring  3 discarded frames\" },\n\t{ ENETC_RBDCR(4), \"Rx ring  4 discarded frames\" },\n\t{ ENETC_RBDCR(5), \"Rx ring  5 discarded frames\" },\n\t{ ENETC_RBDCR(6), \"Rx ring  6 discarded frames\" },\n\t{ ENETC_RBDCR(7), \"Rx ring  7 discarded frames\" },\n\t{ ENETC_RBDCR(8), \"Rx ring  8 discarded frames\" },\n\t{ ENETC_RBDCR(9), \"Rx ring  9 discarded frames\" },\n\t{ ENETC_RBDCR(10), \"Rx ring 10 discarded frames\" },\n\t{ ENETC_RBDCR(11), \"Rx ring 11 discarded frames\" },\n\t{ ENETC_RBDCR(12), \"Rx ring 12 discarded frames\" },\n\t{ ENETC_RBDCR(13), \"Rx ring 13 discarded frames\" },\n\t{ ENETC_RBDCR(14), \"Rx ring 14 discarded frames\" },\n\t{ ENETC_RBDCR(15), \"Rx ring 15 discarded frames\" },\n};\n\nstatic const struct {\n\tint reg;\n\tchar name[ETH_GSTRING_LEN];\n} enetc_port_counters[] = {\n\t{ ENETC_PM_REOCT(0),\t\"MAC rx ethernet octets\" },\n\t{ ENETC_PM_RALN(0),\t\"MAC rx alignment errors\" },\n\t{ ENETC_PM_RXPF(0),\t\"MAC rx valid pause frames\" },\n\t{ ENETC_PM_RFRM(0),\t\"MAC rx valid frames\" },\n\t{ ENETC_PM_RFCS(0),\t\"MAC rx fcs errors\" },\n\t{ ENETC_PM_RVLAN(0),\t\"MAC rx VLAN frames\" },\n\t{ ENETC_PM_RERR(0),\t\"MAC rx frame errors\" },\n\t{ ENETC_PM_RUCA(0),\t\"MAC rx unicast frames\" },\n\t{ ENETC_PM_RMCA(0),\t\"MAC rx multicast frames\" },\n\t{ ENETC_PM_RBCA(0),\t\"MAC rx broadcast frames\" },\n\t{ ENETC_PM_RDRP(0),\t\"MAC rx dropped packets\" },\n\t{ ENETC_PM_RPKT(0),\t\"MAC rx packets\" },\n\t{ ENETC_PM_RUND(0),\t\"MAC rx undersized packets\" },\n\t{ ENETC_PM_R64(0),\t\"MAC rx 64 byte packets\" },\n\t{ ENETC_PM_R127(0),\t\"MAC rx 65-127 byte packets\" },\n\t{ ENETC_PM_R255(0),\t\"MAC rx 128-255 byte packets\" },\n\t{ ENETC_PM_R511(0),\t\"MAC rx 256-511 byte packets\" },\n\t{ ENETC_PM_R1023(0),\t\"MAC rx 512-1023 byte packets\" },\n\t{ ENETC_PM_R1522(0),\t\"MAC rx 1024-1522 byte packets\" },\n\t{ ENETC_PM_R1523X(0),\t\"MAC rx 1523 to max-octet packets\" },\n\t{ ENETC_PM_ROVR(0),\t\"MAC rx oversized packets\" },\n\t{ ENETC_PM_RJBR(0),\t\"MAC rx jabber packets\" },\n\t{ ENETC_PM_RFRG(0),\t\"MAC rx fragment packets\" },\n\t{ ENETC_PM_RCNP(0),\t\"MAC rx control packets\" },\n\t{ ENETC_PM_RDRNTP(0),\t\"MAC rx fifo drop\" },\n\t{ ENETC_PM_TEOCT(0),\t\"MAC tx ethernet octets\" },\n\t{ ENETC_PM_TOCT(0),\t\"MAC tx octets\" },\n\t{ ENETC_PM_TCRSE(0),\t\"MAC tx carrier sense errors\" },\n\t{ ENETC_PM_TXPF(0),\t\"MAC tx valid pause frames\" },\n\t{ ENETC_PM_TFRM(0),\t\"MAC tx frames\" },\n\t{ ENETC_PM_TFCS(0),\t\"MAC tx fcs errors\" },\n\t{ ENETC_PM_TVLAN(0),\t\"MAC tx VLAN frames\" },\n\t{ ENETC_PM_TERR(0),\t\"MAC tx frame errors\" },\n\t{ ENETC_PM_TUCA(0),\t\"MAC tx unicast frames\" },\n\t{ ENETC_PM_TMCA(0),\t\"MAC tx multicast frames\" },\n\t{ ENETC_PM_TBCA(0),\t\"MAC tx broadcast frames\" },\n\t{ ENETC_PM_TPKT(0),\t\"MAC tx packets\" },\n\t{ ENETC_PM_TUND(0),\t\"MAC tx undersized packets\" },\n\t{ ENETC_PM_T64(0),\t\"MAC tx 64 byte packets\" },\n\t{ ENETC_PM_T127(0),\t\"MAC tx 65-127 byte packets\" },\n\t{ ENETC_PM_T255(0),\t\"MAC tx 128-255 byte packets\" },\n\t{ ENETC_PM_T511(0),\t\"MAC tx 256-511 byte packets\" },\n\t{ ENETC_PM_T1023(0),\t\"MAC tx 512-1023 byte packets\" },\n\t{ ENETC_PM_T1522(0),\t\"MAC tx 1024-1522 byte packets\" },\n\t{ ENETC_PM_T1523X(0),\t\"MAC tx 1523 to max-octet packets\" },\n\t{ ENETC_PM_TCNP(0),\t\"MAC tx control packets\" },\n\t{ ENETC_PM_TDFR(0),\t\"MAC tx deferred packets\" },\n\t{ ENETC_PM_TMCOL(0),\t\"MAC tx multiple collisions\" },\n\t{ ENETC_PM_TSCOL(0),\t\"MAC tx single collisions\" },\n\t{ ENETC_PM_TLCOL(0),\t\"MAC tx late collisions\" },\n\t{ ENETC_PM_TECOL(0),\t\"MAC tx excessive collisions\" },\n\t{ ENETC_UFDMF,\t\t\"SI MAC nomatch u-cast discards\" },\n\t{ ENETC_MFDMF,\t\t\"SI MAC nomatch m-cast discards\" },\n\t{ ENETC_PBFDSIR,\t\"SI MAC nomatch b-cast discards\" },\n\t{ ENETC_PUFDVFR,\t\"SI VLAN nomatch u-cast discards\" },\n\t{ ENETC_PMFDVFR,\t\"SI VLAN nomatch m-cast discards\" },\n\t{ ENETC_PBFDVFR,\t\"SI VLAN nomatch b-cast discards\" },\n\t{ ENETC_PFDMSAPR,\t\"SI pruning discarded frames\" },\n\t{ ENETC_PICDR(0),\t\"ICM DR0 discarded frames\" },\n\t{ ENETC_PICDR(1),\t\"ICM DR1 discarded frames\" },\n\t{ ENETC_PICDR(2),\t\"ICM DR2 discarded frames\" },\n\t{ ENETC_PICDR(3),\t\"ICM DR3 discarded frames\" },\n};\n\nstatic const char rx_ring_stats[][ETH_GSTRING_LEN] = {\n\t\"Rx ring %2d frames\",\n\t\"Rx ring %2d alloc errors\",\n\t\"Rx ring %2d XDP drops\",\n\t\"Rx ring %2d recycles\",\n\t\"Rx ring %2d recycle failures\",\n\t\"Rx ring %2d redirects\",\n\t\"Rx ring %2d redirect failures\",\n};\n\nstatic const char tx_ring_stats[][ETH_GSTRING_LEN] = {\n\t\"Tx ring %2d frames\",\n\t\"Tx ring %2d XDP frames\",\n\t\"Tx ring %2d XDP drops\",\n\t\"Tx window drop %2d frames\",\n};\n\nstatic int enetc_get_sset_count(struct net_device *ndev, int sset)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tint len;\n\n\tif (sset != ETH_SS_STATS)\n\t\treturn -EOPNOTSUPP;\n\n\tlen = ARRAY_SIZE(enetc_si_counters) +\n\t      ARRAY_SIZE(tx_ring_stats) * priv->num_tx_rings +\n\t      ARRAY_SIZE(rx_ring_stats) * priv->num_rx_rings;\n\n\tif (!enetc_si_is_pf(priv->si))\n\t\treturn len;\n\n\tlen += ARRAY_SIZE(enetc_port_counters);\n\n\treturn len;\n}\n\nstatic void enetc_get_strings(struct net_device *ndev, u32 stringset, u8 *data)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tu8 *p = data;\n\tint i, j;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < ARRAY_SIZE(enetc_si_counters); i++) {\n\t\t\tstrscpy(p, enetc_si_counters[i].name, ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tfor (i = 0; i < priv->num_tx_rings; i++) {\n\t\t\tfor (j = 0; j < ARRAY_SIZE(tx_ring_stats); j++) {\n\t\t\t\tsnprintf(p, ETH_GSTRING_LEN, tx_ring_stats[j],\n\t\t\t\t\t i);\n\t\t\t\tp += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < priv->num_rx_rings; i++) {\n\t\t\tfor (j = 0; j < ARRAY_SIZE(rx_ring_stats); j++) {\n\t\t\t\tsnprintf(p, ETH_GSTRING_LEN, rx_ring_stats[j],\n\t\t\t\t\t i);\n\t\t\t\tp += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\n\t\tif (!enetc_si_is_pf(priv->si))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(enetc_port_counters); i++) {\n\t\t\tstrscpy(p, enetc_port_counters[i].name,\n\t\t\t\tETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void enetc_get_ethtool_stats(struct net_device *ndev,\n\t\t\t\t    struct ethtool_stats *stats, u64 *data)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tint i, o = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(enetc_si_counters); i++)\n\t\tdata[o++] = enetc_rd64(hw, enetc_si_counters[i].reg);\n\n\tfor (i = 0; i < priv->num_tx_rings; i++) {\n\t\tdata[o++] = priv->tx_ring[i]->stats.packets;\n\t\tdata[o++] = priv->tx_ring[i]->stats.xdp_tx;\n\t\tdata[o++] = priv->tx_ring[i]->stats.xdp_tx_drops;\n\t\tdata[o++] = priv->tx_ring[i]->stats.win_drop;\n\t}\n\n\tfor (i = 0; i < priv->num_rx_rings; i++) {\n\t\tdata[o++] = priv->rx_ring[i]->stats.packets;\n\t\tdata[o++] = priv->rx_ring[i]->stats.rx_alloc_errs;\n\t\tdata[o++] = priv->rx_ring[i]->stats.xdp_drops;\n\t\tdata[o++] = priv->rx_ring[i]->stats.recycles;\n\t\tdata[o++] = priv->rx_ring[i]->stats.recycle_failures;\n\t\tdata[o++] = priv->rx_ring[i]->stats.xdp_redirect;\n\t\tdata[o++] = priv->rx_ring[i]->stats.xdp_redirect_failures;\n\t}\n\n\tif (!enetc_si_is_pf(priv->si))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(enetc_port_counters); i++)\n\t\tdata[o++] = enetc_port_rd(hw, enetc_port_counters[i].reg);\n}\n\nstatic void enetc_pause_stats(struct enetc_hw *hw, int mac,\n\t\t\t      struct ethtool_pause_stats *pause_stats)\n{\n\tpause_stats->tx_pause_frames = enetc_port_rd(hw, ENETC_PM_TXPF(mac));\n\tpause_stats->rx_pause_frames = enetc_port_rd(hw, ENETC_PM_RXPF(mac));\n}\n\nstatic void enetc_get_pause_stats(struct net_device *ndev,\n\t\t\t\t  struct ethtool_pause_stats *pause_stats)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tstruct enetc_si *si = priv->si;\n\n\tswitch (pause_stats->src) {\n\tcase ETHTOOL_MAC_STATS_SRC_EMAC:\n\t\tenetc_pause_stats(hw, 0, pause_stats);\n\t\tbreak;\n\tcase ETHTOOL_MAC_STATS_SRC_PMAC:\n\t\tif (si->hw_features & ENETC_SI_F_QBU)\n\t\t\tenetc_pause_stats(hw, 1, pause_stats);\n\t\tbreak;\n\tcase ETHTOOL_MAC_STATS_SRC_AGGREGATE:\n\t\tethtool_aggregate_pause_stats(ndev, pause_stats);\n\t\tbreak;\n\t}\n}\n\nstatic void enetc_mac_stats(struct enetc_hw *hw, int mac,\n\t\t\t    struct ethtool_eth_mac_stats *s)\n{\n\ts->FramesTransmittedOK = enetc_port_rd(hw, ENETC_PM_TFRM(mac));\n\ts->SingleCollisionFrames = enetc_port_rd(hw, ENETC_PM_TSCOL(mac));\n\ts->MultipleCollisionFrames = enetc_port_rd(hw, ENETC_PM_TMCOL(mac));\n\ts->FramesReceivedOK = enetc_port_rd(hw, ENETC_PM_RFRM(mac));\n\ts->FrameCheckSequenceErrors = enetc_port_rd(hw, ENETC_PM_RFCS(mac));\n\ts->AlignmentErrors = enetc_port_rd(hw, ENETC_PM_RALN(mac));\n\ts->OctetsTransmittedOK = enetc_port_rd(hw, ENETC_PM_TEOCT(mac));\n\ts->FramesWithDeferredXmissions = enetc_port_rd(hw, ENETC_PM_TDFR(mac));\n\ts->LateCollisions = enetc_port_rd(hw, ENETC_PM_TLCOL(mac));\n\ts->FramesAbortedDueToXSColls = enetc_port_rd(hw, ENETC_PM_TECOL(mac));\n\ts->FramesLostDueToIntMACXmitError = enetc_port_rd(hw, ENETC_PM_TERR(mac));\n\ts->CarrierSenseErrors = enetc_port_rd(hw, ENETC_PM_TCRSE(mac));\n\ts->OctetsReceivedOK = enetc_port_rd(hw, ENETC_PM_REOCT(mac));\n\ts->FramesLostDueToIntMACRcvError = enetc_port_rd(hw, ENETC_PM_RDRNTP(mac));\n\ts->MulticastFramesXmittedOK = enetc_port_rd(hw, ENETC_PM_TMCA(mac));\n\ts->BroadcastFramesXmittedOK = enetc_port_rd(hw, ENETC_PM_TBCA(mac));\n\ts->MulticastFramesReceivedOK = enetc_port_rd(hw, ENETC_PM_RMCA(mac));\n\ts->BroadcastFramesReceivedOK = enetc_port_rd(hw, ENETC_PM_RBCA(mac));\n}\n\nstatic void enetc_ctrl_stats(struct enetc_hw *hw, int mac,\n\t\t\t     struct ethtool_eth_ctrl_stats *s)\n{\n\ts->MACControlFramesTransmitted = enetc_port_rd(hw, ENETC_PM_TCNP(mac));\n\ts->MACControlFramesReceived = enetc_port_rd(hw, ENETC_PM_RCNP(mac));\n}\n\nstatic const struct ethtool_rmon_hist_range enetc_rmon_ranges[] = {\n\t{   64,   64 },\n\t{   65,  127 },\n\t{  128,  255 },\n\t{  256,  511 },\n\t{  512, 1023 },\n\t{ 1024, 1522 },\n\t{ 1523, ENETC_MAC_MAXFRM_SIZE },\n\t{},\n};\n\nstatic void enetc_rmon_stats(struct enetc_hw *hw, int mac,\n\t\t\t     struct ethtool_rmon_stats *s)\n{\n\ts->undersize_pkts = enetc_port_rd(hw, ENETC_PM_RUND(mac));\n\ts->oversize_pkts = enetc_port_rd(hw, ENETC_PM_ROVR(mac));\n\ts->fragments = enetc_port_rd(hw, ENETC_PM_RFRG(mac));\n\ts->jabbers = enetc_port_rd(hw, ENETC_PM_RJBR(mac));\n\n\ts->hist[0] = enetc_port_rd(hw, ENETC_PM_R64(mac));\n\ts->hist[1] = enetc_port_rd(hw, ENETC_PM_R127(mac));\n\ts->hist[2] = enetc_port_rd(hw, ENETC_PM_R255(mac));\n\ts->hist[3] = enetc_port_rd(hw, ENETC_PM_R511(mac));\n\ts->hist[4] = enetc_port_rd(hw, ENETC_PM_R1023(mac));\n\ts->hist[5] = enetc_port_rd(hw, ENETC_PM_R1522(mac));\n\ts->hist[6] = enetc_port_rd(hw, ENETC_PM_R1523X(mac));\n\n\ts->hist_tx[0] = enetc_port_rd(hw, ENETC_PM_T64(mac));\n\ts->hist_tx[1] = enetc_port_rd(hw, ENETC_PM_T127(mac));\n\ts->hist_tx[2] = enetc_port_rd(hw, ENETC_PM_T255(mac));\n\ts->hist_tx[3] = enetc_port_rd(hw, ENETC_PM_T511(mac));\n\ts->hist_tx[4] = enetc_port_rd(hw, ENETC_PM_T1023(mac));\n\ts->hist_tx[5] = enetc_port_rd(hw, ENETC_PM_T1522(mac));\n\ts->hist_tx[6] = enetc_port_rd(hw, ENETC_PM_T1523X(mac));\n}\n\nstatic void enetc_get_eth_mac_stats(struct net_device *ndev,\n\t\t\t\t    struct ethtool_eth_mac_stats *mac_stats)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tstruct enetc_si *si = priv->si;\n\n\tswitch (mac_stats->src) {\n\tcase ETHTOOL_MAC_STATS_SRC_EMAC:\n\t\tenetc_mac_stats(hw, 0, mac_stats);\n\t\tbreak;\n\tcase ETHTOOL_MAC_STATS_SRC_PMAC:\n\t\tif (si->hw_features & ENETC_SI_F_QBU)\n\t\t\tenetc_mac_stats(hw, 1, mac_stats);\n\t\tbreak;\n\tcase ETHTOOL_MAC_STATS_SRC_AGGREGATE:\n\t\tethtool_aggregate_mac_stats(ndev, mac_stats);\n\t\tbreak;\n\t}\n}\n\nstatic void enetc_get_eth_ctrl_stats(struct net_device *ndev,\n\t\t\t\t     struct ethtool_eth_ctrl_stats *ctrl_stats)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tstruct enetc_si *si = priv->si;\n\n\tswitch (ctrl_stats->src) {\n\tcase ETHTOOL_MAC_STATS_SRC_EMAC:\n\t\tenetc_ctrl_stats(hw, 0, ctrl_stats);\n\t\tbreak;\n\tcase ETHTOOL_MAC_STATS_SRC_PMAC:\n\t\tif (si->hw_features & ENETC_SI_F_QBU)\n\t\t\tenetc_ctrl_stats(hw, 1, ctrl_stats);\n\t\tbreak;\n\tcase ETHTOOL_MAC_STATS_SRC_AGGREGATE:\n\t\tethtool_aggregate_ctrl_stats(ndev, ctrl_stats);\n\t\tbreak;\n\t}\n}\n\nstatic void enetc_get_rmon_stats(struct net_device *ndev,\n\t\t\t\t struct ethtool_rmon_stats *rmon_stats,\n\t\t\t\t const struct ethtool_rmon_hist_range **ranges)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tstruct enetc_si *si = priv->si;\n\n\t*ranges = enetc_rmon_ranges;\n\n\tswitch (rmon_stats->src) {\n\tcase ETHTOOL_MAC_STATS_SRC_EMAC:\n\t\tenetc_rmon_stats(hw, 0, rmon_stats);\n\t\tbreak;\n\tcase ETHTOOL_MAC_STATS_SRC_PMAC:\n\t\tif (si->hw_features & ENETC_SI_F_QBU)\n\t\t\tenetc_rmon_stats(hw, 1, rmon_stats);\n\t\tbreak;\n\tcase ETHTOOL_MAC_STATS_SRC_AGGREGATE:\n\t\tethtool_aggregate_rmon_stats(ndev, rmon_stats);\n\t\tbreak;\n\t}\n}\n\n#define ENETC_RSSHASH_L3 (RXH_L2DA | RXH_VLAN | RXH_L3_PROTO | RXH_IP_SRC | \\\n\t\t\t  RXH_IP_DST)\n#define ENETC_RSSHASH_L4 (ENETC_RSSHASH_L3 | RXH_L4_B_0_1 | RXH_L4_B_2_3)\nstatic int enetc_get_rsshash(struct ethtool_rxnfc *rxnfc)\n{\n\tstatic const u32 rsshash[] = {\n\t\t\t[TCP_V4_FLOW]    = ENETC_RSSHASH_L4,\n\t\t\t[UDP_V4_FLOW]    = ENETC_RSSHASH_L4,\n\t\t\t[SCTP_V4_FLOW]   = ENETC_RSSHASH_L4,\n\t\t\t[AH_ESP_V4_FLOW] = ENETC_RSSHASH_L3,\n\t\t\t[IPV4_FLOW]      = ENETC_RSSHASH_L3,\n\t\t\t[TCP_V6_FLOW]    = ENETC_RSSHASH_L4,\n\t\t\t[UDP_V6_FLOW]    = ENETC_RSSHASH_L4,\n\t\t\t[SCTP_V6_FLOW]   = ENETC_RSSHASH_L4,\n\t\t\t[AH_ESP_V6_FLOW] = ENETC_RSSHASH_L3,\n\t\t\t[IPV6_FLOW]      = ENETC_RSSHASH_L3,\n\t\t\t[ETHER_FLOW]     = 0,\n\t};\n\n\tif (rxnfc->flow_type >= ARRAY_SIZE(rsshash))\n\t\treturn -EINVAL;\n\n\trxnfc->data = rsshash[rxnfc->flow_type];\n\n\treturn 0;\n}\n\n \nstatic void ether_addr_copy_swap(u8 *dst, const u8 *src)\n{\n\tint i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tdst[i] = src[ETH_ALEN - i - 1];\n}\n\nstatic int enetc_set_cls_entry(struct enetc_si *si,\n\t\t\t       struct ethtool_rx_flow_spec *fs, bool en)\n{\n\tstruct ethtool_tcpip4_spec *l4ip4_h, *l4ip4_m;\n\tstruct ethtool_usrip4_spec *l3ip4_h, *l3ip4_m;\n\tstruct ethhdr *eth_h, *eth_m;\n\tstruct enetc_cmd_rfse rfse = { {0} };\n\n\tif (!en)\n\t\tgoto done;\n\n\tswitch (fs->flow_type & 0xff) {\n\tcase TCP_V4_FLOW:\n\t\tl4ip4_h = &fs->h_u.tcp_ip4_spec;\n\t\tl4ip4_m = &fs->m_u.tcp_ip4_spec;\n\t\tgoto l4ip4;\n\tcase UDP_V4_FLOW:\n\t\tl4ip4_h = &fs->h_u.udp_ip4_spec;\n\t\tl4ip4_m = &fs->m_u.udp_ip4_spec;\n\t\tgoto l4ip4;\n\tcase SCTP_V4_FLOW:\n\t\tl4ip4_h = &fs->h_u.sctp_ip4_spec;\n\t\tl4ip4_m = &fs->m_u.sctp_ip4_spec;\nl4ip4:\n\t\trfse.sip_h[0] = l4ip4_h->ip4src;\n\t\trfse.sip_m[0] = l4ip4_m->ip4src;\n\t\trfse.dip_h[0] = l4ip4_h->ip4dst;\n\t\trfse.dip_m[0] = l4ip4_m->ip4dst;\n\t\trfse.sport_h = ntohs(l4ip4_h->psrc);\n\t\trfse.sport_m = ntohs(l4ip4_m->psrc);\n\t\trfse.dport_h = ntohs(l4ip4_h->pdst);\n\t\trfse.dport_m = ntohs(l4ip4_m->pdst);\n\t\tif (l4ip4_m->tos)\n\t\t\tnetdev_warn(si->ndev, \"ToS field is not supported and was ignored\\n\");\n\t\trfse.ethtype_h = ETH_P_IP;  \n\t\trfse.ethtype_m = 0xffff;\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tl3ip4_h = &fs->h_u.usr_ip4_spec;\n\t\tl3ip4_m = &fs->m_u.usr_ip4_spec;\n\n\t\trfse.sip_h[0] = l3ip4_h->ip4src;\n\t\trfse.sip_m[0] = l3ip4_m->ip4src;\n\t\trfse.dip_h[0] = l3ip4_h->ip4dst;\n\t\trfse.dip_m[0] = l3ip4_m->ip4dst;\n\t\tif (l3ip4_m->tos)\n\t\t\tnetdev_warn(si->ndev, \"ToS field is not supported and was ignored\\n\");\n\t\trfse.ethtype_h = ETH_P_IP;  \n\t\trfse.ethtype_m = 0xffff;\n\t\tbreak;\n\tcase ETHER_FLOW:\n\t\teth_h = &fs->h_u.ether_spec;\n\t\teth_m = &fs->m_u.ether_spec;\n\n\t\tether_addr_copy_swap(rfse.smac_h, eth_h->h_source);\n\t\tether_addr_copy_swap(rfse.smac_m, eth_m->h_source);\n\t\tether_addr_copy_swap(rfse.dmac_h, eth_h->h_dest);\n\t\tether_addr_copy_swap(rfse.dmac_m, eth_m->h_dest);\n\t\trfse.ethtype_h = ntohs(eth_h->h_proto);\n\t\trfse.ethtype_m = ntohs(eth_m->h_proto);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trfse.mode |= ENETC_RFSE_EN;\n\tif (fs->ring_cookie != RX_CLS_FLOW_DISC) {\n\t\trfse.mode |= ENETC_RFSE_MODE_BD;\n\t\trfse.result = fs->ring_cookie;\n\t}\ndone:\n\treturn enetc_set_fs_entry(si, &rfse, fs->location);\n}\n\nstatic int enetc_get_rxnfc(struct net_device *ndev, struct ethtool_rxnfc *rxnfc,\n\t\t\t   u32 *rule_locs)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tint i, j;\n\n\tswitch (rxnfc->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\trxnfc->data = priv->num_rx_rings;\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\t\t \n\t\treturn enetc_get_rsshash(rxnfc);\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\t \n\t\trxnfc->data = priv->si->num_fs_entries;\n\t\t \n\t\trxnfc->rule_cnt = 0;\n\t\tfor (i = 0; i < priv->si->num_fs_entries; i++)\n\t\t\tif (priv->cls_rules[i].used)\n\t\t\t\trxnfc->rule_cnt++;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tif (rxnfc->fs.location >= priv->si->num_fs_entries)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\trxnfc->fs = priv->cls_rules[rxnfc->fs.location].fs;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\t \n\t\trxnfc->data = priv->si->num_fs_entries;\n\t\t \n\t\tj = 0;\n\t\tfor (i = 0; i < priv->si->num_fs_entries; i++) {\n\t\t\tif (!priv->cls_rules[i].used)\n\t\t\t\tcontinue;\n\t\t\tif (j == rxnfc->rule_cnt)\n\t\t\t\treturn -EMSGSIZE;\n\t\t\trule_locs[j++] = i;\n\t\t}\n\t\t \n\t\trxnfc->rule_cnt = j;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int enetc_set_rxnfc(struct net_device *ndev, struct ethtool_rxnfc *rxnfc)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tint err;\n\n\tswitch (rxnfc->cmd) {\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tif (rxnfc->fs.location >= priv->si->num_fs_entries)\n\t\t\treturn -EINVAL;\n\n\t\tif (rxnfc->fs.ring_cookie >= priv->num_rx_rings &&\n\t\t    rxnfc->fs.ring_cookie != RX_CLS_FLOW_DISC)\n\t\t\treturn -EINVAL;\n\n\t\terr = enetc_set_cls_entry(priv->si, &rxnfc->fs, true);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpriv->cls_rules[rxnfc->fs.location].fs = rxnfc->fs;\n\t\tpriv->cls_rules[rxnfc->fs.location].used = 1;\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tif (rxnfc->fs.location >= priv->si->num_fs_entries)\n\t\t\treturn -EINVAL;\n\n\t\terr = enetc_set_cls_entry(priv->si, &rxnfc->fs, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpriv->cls_rules[rxnfc->fs.location].used = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 enetc_get_rxfh_key_size(struct net_device *ndev)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\n\t \n\treturn (priv->si->hw.port) ? ENETC_RSSHASH_KEY_SIZE : 0;\n}\n\nstatic u32 enetc_get_rxfh_indir_size(struct net_device *ndev)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\n\t \n\treturn priv->si->num_rss;\n}\n\nstatic int enetc_get_rxfh(struct net_device *ndev, u32 *indir, u8 *key,\n\t\t\t  u8 *hfunc)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tint err = 0, i;\n\n\t \n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\t \n\tif (key && hw->port)\n\t\tfor (i = 0; i < ENETC_RSSHASH_KEY_SIZE / 4; i++)\n\t\t\t((u32 *)key)[i] = enetc_port_rd(hw, ENETC_PRSSK(i));\n\n\t \n\tif (indir)\n\t\terr = enetc_get_rss_table(priv->si, indir, priv->si->num_rss);\n\n\treturn err;\n}\n\nvoid enetc_set_rss_key(struct enetc_hw *hw, const u8 *bytes)\n{\n\tint i;\n\n\tfor (i = 0; i < ENETC_RSSHASH_KEY_SIZE / 4; i++)\n\t\tenetc_port_wr(hw, ENETC_PRSSK(i), ((u32 *)bytes)[i]);\n}\nEXPORT_SYMBOL_GPL(enetc_set_rss_key);\n\nstatic int enetc_set_rxfh(struct net_device *ndev, const u32 *indir,\n\t\t\t  const u8 *key, const u8 hfunc)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tint err = 0;\n\n\t \n\tif (key && hw->port)\n\t\tenetc_set_rss_key(hw, key);\n\n\t \n\tif (indir)\n\t\terr = enetc_set_rss_table(priv->si, indir, priv->si->num_rss);\n\n\treturn err;\n}\n\nstatic void enetc_get_ringparam(struct net_device *ndev,\n\t\t\t\tstruct ethtool_ringparam *ring,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\n\tring->rx_pending = priv->rx_bd_count;\n\tring->tx_pending = priv->tx_bd_count;\n\n\t \n\tif (netif_running(ndev)) {\n\t\tstruct enetc_hw *hw = &priv->si->hw;\n\t\tu32 val = enetc_rxbdr_rd(hw, 0, ENETC_RBLENR);\n\n\t\tif (val != priv->rx_bd_count)\n\t\t\tnetif_err(priv, hw, ndev, \"RxBDR[RBLENR] = %d!\\n\", val);\n\n\t\tval = enetc_txbdr_rd(hw, 0, ENETC_TBLENR);\n\n\t\tif (val != priv->tx_bd_count)\n\t\t\tnetif_err(priv, hw, ndev, \"TxBDR[TBLENR] = %d!\\n\", val);\n\t}\n}\n\nstatic int enetc_get_coalesce(struct net_device *ndev,\n\t\t\t      struct ethtool_coalesce *ic,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_int_vector *v = priv->int_vector[0];\n\n\tic->tx_coalesce_usecs = enetc_cycles_to_usecs(priv->tx_ictt);\n\tic->rx_coalesce_usecs = enetc_cycles_to_usecs(v->rx_ictt);\n\n\tic->tx_max_coalesced_frames = ENETC_TXIC_PKTTHR;\n\tic->rx_max_coalesced_frames = ENETC_RXIC_PKTTHR;\n\n\tic->use_adaptive_rx_coalesce = priv->ic_mode & ENETC_IC_RX_ADAPTIVE;\n\n\treturn 0;\n}\n\nstatic int enetc_set_coalesce(struct net_device *ndev,\n\t\t\t      struct ethtool_coalesce *ic,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tu32 rx_ictt, tx_ictt;\n\tint i, ic_mode;\n\tbool changed;\n\n\ttx_ictt = enetc_usecs_to_cycles(ic->tx_coalesce_usecs);\n\trx_ictt = enetc_usecs_to_cycles(ic->rx_coalesce_usecs);\n\n\tif (ic->rx_max_coalesced_frames != ENETC_RXIC_PKTTHR)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ic->tx_max_coalesced_frames != ENETC_TXIC_PKTTHR)\n\t\treturn -EOPNOTSUPP;\n\n\tic_mode = ENETC_IC_NONE;\n\tif (ic->use_adaptive_rx_coalesce) {\n\t\tic_mode |= ENETC_IC_RX_ADAPTIVE;\n\t\trx_ictt = 0x1;\n\t} else {\n\t\tic_mode |= rx_ictt ? ENETC_IC_RX_MANUAL : 0;\n\t}\n\n\tic_mode |= tx_ictt ? ENETC_IC_TX_MANUAL : 0;\n\n\t \n\tchanged = (ic_mode != priv->ic_mode) || (priv->tx_ictt != tx_ictt);\n\n\tpriv->ic_mode = ic_mode;\n\tpriv->tx_ictt = tx_ictt;\n\n\tfor (i = 0; i < priv->bdr_int_num; i++) {\n\t\tstruct enetc_int_vector *v = priv->int_vector[i];\n\n\t\tv->rx_ictt = rx_ictt;\n\t\tv->rx_dim_en = !!(ic_mode & ENETC_IC_RX_ADAPTIVE);\n\t}\n\n\tif (netif_running(ndev) && changed) {\n\t\t \n\t\tenetc_stop(ndev);\n\t\tenetc_start(ndev);\n\t}\n\n\treturn 0;\n}\n\nstatic int enetc_get_ts_info(struct net_device *ndev,\n\t\t\t     struct ethtool_ts_info *info)\n{\n\tint *phc_idx;\n\n\tphc_idx = symbol_get(enetc_phc_index);\n\tif (phc_idx) {\n\t\tinfo->phc_index = *phc_idx;\n\t\tsymbol_put(enetc_phc_index);\n\t} else {\n\t\tinfo->phc_index = -1;\n\t}\n\n#ifdef CONFIG_FSL_ENETC_PTP_CLOCK\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE;\n\n\tinfo->tx_types = (1 << HWTSTAMP_TX_OFF) |\n\t\t\t (1 << HWTSTAMP_TX_ON) |\n\t\t\t (1 << HWTSTAMP_TX_ONESTEP_SYNC);\n\tinfo->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t   (1 << HWTSTAMP_FILTER_ALL);\n#else\n\tinfo->so_timestamping = SOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE;\n#endif\n\treturn 0;\n}\n\nstatic void enetc_get_wol(struct net_device *dev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\twol->supported = 0;\n\twol->wolopts = 0;\n\n\tif (dev->phydev)\n\t\tphy_ethtool_get_wol(dev->phydev, wol);\n}\n\nstatic int enetc_set_wol(struct net_device *dev,\n\t\t\t struct ethtool_wolinfo *wol)\n{\n\tint ret;\n\n\tif (!dev->phydev)\n\t\treturn -EOPNOTSUPP;\n\n\tret = phy_ethtool_set_wol(dev->phydev, wol);\n\tif (!ret)\n\t\tdevice_set_wakeup_enable(&dev->dev, wol->wolopts);\n\n\treturn ret;\n}\n\nstatic void enetc_get_pauseparam(struct net_device *dev,\n\t\t\t\t struct ethtool_pauseparam *pause)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(dev);\n\n\tphylink_ethtool_get_pauseparam(priv->phylink, pause);\n}\n\nstatic int enetc_set_pauseparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(dev);\n\n\treturn phylink_ethtool_set_pauseparam(priv->phylink, pause);\n}\n\nstatic int enetc_get_link_ksettings(struct net_device *dev,\n\t\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(dev);\n\n\tif (!priv->phylink)\n\t\treturn -EOPNOTSUPP;\n\n\treturn phylink_ethtool_ksettings_get(priv->phylink, cmd);\n}\n\nstatic int enetc_set_link_ksettings(struct net_device *dev,\n\t\t\t\t    const struct ethtool_link_ksettings *cmd)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(dev);\n\n\tif (!priv->phylink)\n\t\treturn -EOPNOTSUPP;\n\n\treturn phylink_ethtool_ksettings_set(priv->phylink, cmd);\n}\n\nstatic void enetc_get_mm_stats(struct net_device *ndev,\n\t\t\t       struct ethtool_mm_stats *s)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tstruct enetc_si *si = priv->si;\n\n\tif (!(si->hw_features & ENETC_SI_F_QBU))\n\t\treturn;\n\n\ts->MACMergeFrameAssErrorCount = enetc_port_rd(hw, ENETC_MMFAECR);\n\ts->MACMergeFrameSmdErrorCount = enetc_port_rd(hw, ENETC_MMFSECR);\n\ts->MACMergeFrameAssOkCount = enetc_port_rd(hw, ENETC_MMFAOCR);\n\ts->MACMergeFragCountRx = enetc_port_rd(hw, ENETC_MMFCRXR);\n\ts->MACMergeFragCountTx = enetc_port_rd(hw, ENETC_MMFCTXR);\n\ts->MACMergeHoldCount = enetc_port_rd(hw, ENETC_MMHCR);\n}\n\nstatic int enetc_get_mm(struct net_device *ndev, struct ethtool_mm_state *state)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_si *si = priv->si;\n\tstruct enetc_hw *hw = &si->hw;\n\tu32 lafs, rafs, val;\n\n\tif (!(si->hw_features & ENETC_SI_F_QBU))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&priv->mm_lock);\n\n\tval = enetc_port_rd(hw, ENETC_PFPMR);\n\tstate->pmac_enabled = !!(val & ENETC_PFPMR_PMACE);\n\n\tval = enetc_port_rd(hw, ENETC_MMCSR);\n\n\tswitch (ENETC_MMCSR_GET_VSTS(val)) {\n\tcase 0:\n\t\tstate->verify_status = ETHTOOL_MM_VERIFY_STATUS_DISABLED;\n\t\tbreak;\n\tcase 2:\n\t\tstate->verify_status = ETHTOOL_MM_VERIFY_STATUS_VERIFYING;\n\t\tbreak;\n\tcase 3:\n\t\tstate->verify_status = ETHTOOL_MM_VERIFY_STATUS_SUCCEEDED;\n\t\tbreak;\n\tcase 4:\n\t\tstate->verify_status = ETHTOOL_MM_VERIFY_STATUS_FAILED;\n\t\tbreak;\n\tcase 5:\n\tdefault:\n\t\tstate->verify_status = ETHTOOL_MM_VERIFY_STATUS_UNKNOWN;\n\t\tbreak;\n\t}\n\n\trafs = ENETC_MMCSR_GET_RAFS(val);\n\tstate->tx_min_frag_size = ethtool_mm_frag_size_add_to_min(rafs);\n\tlafs = ENETC_MMCSR_GET_LAFS(val);\n\tstate->rx_min_frag_size = ethtool_mm_frag_size_add_to_min(lafs);\n\tstate->tx_enabled = !!(val & ENETC_MMCSR_LPE);  \n\tstate->tx_active = state->tx_enabled &&\n\t\t\t   (state->verify_status == ETHTOOL_MM_VERIFY_STATUS_SUCCEEDED ||\n\t\t\t    state->verify_status == ETHTOOL_MM_VERIFY_STATUS_DISABLED);\n\tstate->verify_enabled = !(val & ENETC_MMCSR_VDIS);\n\tstate->verify_time = ENETC_MMCSR_GET_VT(val);\n\t \n\tstate->max_verify_time = 127;\n\n\tmutex_unlock(&priv->mm_lock);\n\n\treturn 0;\n}\n\nstatic int enetc_mm_wait_tx_active(struct enetc_hw *hw, int verify_time)\n{\n\tint timeout = verify_time * USEC_PER_MSEC * ENETC_MM_VERIFY_RETRIES;\n\tu32 val;\n\n\t \n\treturn read_poll_timeout(enetc_port_rd, val,\n\t\t\t\t ENETC_MMCSR_GET_VSTS(val) == 3,\n\t\t\t\t ENETC_MM_VERIFY_SLEEP_US, timeout,\n\t\t\t\t true, hw, ENETC_MMCSR);\n}\n\nstatic void enetc_set_ptcfpr(struct enetc_hw *hw, u8 preemptible_tcs)\n{\n\tu32 val;\n\tint tc;\n\n\tfor (tc = 0; tc < 8; tc++) {\n\t\tval = enetc_port_rd(hw, ENETC_PTCFPR(tc));\n\n\t\tif (preemptible_tcs & BIT(tc))\n\t\t\tval |= ENETC_PTCFPR_FPE;\n\t\telse\n\t\t\tval &= ~ENETC_PTCFPR_FPE;\n\n\t\tenetc_port_wr(hw, ENETC_PTCFPR(tc), val);\n\t}\n}\n\n \nvoid enetc_mm_commit_preemptible_tcs(struct enetc_ndev_priv *priv)\n{\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tu8 preemptible_tcs = 0;\n\tu32 val;\n\tint err;\n\n\tval = enetc_port_rd(hw, ENETC_MMCSR);\n\tif (!(val & ENETC_MMCSR_ME))\n\t\tgoto out;\n\n\tif (!(val & ENETC_MMCSR_VDIS)) {\n\t\terr = enetc_mm_wait_tx_active(hw, ENETC_MMCSR_GET_VT(val));\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tpreemptible_tcs = priv->preemptible_tcs;\nout:\n\tenetc_set_ptcfpr(hw, preemptible_tcs);\n}\n\n \nstatic void enetc_restart_emac_rx(struct enetc_si *si)\n{\n\tu32 val = enetc_port_rd(&si->hw, ENETC_PM0_CMD_CFG);\n\n\tenetc_port_wr(&si->hw, ENETC_PM0_CMD_CFG, val & ~ENETC_PM0_RX_EN);\n\n\tif (val & ENETC_PM0_RX_EN)\n\t\tenetc_port_wr(&si->hw, ENETC_PM0_CMD_CFG, val);\n}\n\nstatic int enetc_set_mm(struct net_device *ndev, struct ethtool_mm_cfg *cfg,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tstruct enetc_si *si = priv->si;\n\tu32 val, add_frag_size;\n\tint err;\n\n\tif (!(si->hw_features & ENETC_SI_F_QBU))\n\t\treturn -EOPNOTSUPP;\n\n\terr = ethtool_mm_frag_size_min_to_add(cfg->tx_min_frag_size,\n\t\t\t\t\t      &add_frag_size, extack);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&priv->mm_lock);\n\n\tval = enetc_port_rd(hw, ENETC_PFPMR);\n\tif (cfg->pmac_enabled)\n\t\tval |= ENETC_PFPMR_PMACE;\n\telse\n\t\tval &= ~ENETC_PFPMR_PMACE;\n\tenetc_port_wr(hw, ENETC_PFPMR, val);\n\n\tval = enetc_port_rd(hw, ENETC_MMCSR);\n\n\tif (cfg->verify_enabled)\n\t\tval &= ~ENETC_MMCSR_VDIS;\n\telse\n\t\tval |= ENETC_MMCSR_VDIS;\n\n\tif (cfg->tx_enabled)\n\t\tpriv->active_offloads |= ENETC_F_QBU;\n\telse\n\t\tpriv->active_offloads &= ~ENETC_F_QBU;\n\n\t \n\tif (!(val & ENETC_MMCSR_LINK_FAIL)) {\n\t\tif (!!(priv->active_offloads & ENETC_F_QBU))\n\t\t\tval |= ENETC_MMCSR_ME;\n\t\telse\n\t\t\tval &= ~ENETC_MMCSR_ME;\n\t}\n\n\tval &= ~ENETC_MMCSR_VT_MASK;\n\tval |= ENETC_MMCSR_VT(cfg->verify_time);\n\n\tval &= ~ENETC_MMCSR_RAFS_MASK;\n\tval |= ENETC_MMCSR_RAFS(add_frag_size);\n\n\tenetc_port_wr(hw, ENETC_MMCSR, val);\n\n\tenetc_restart_emac_rx(priv->si);\n\n\tenetc_mm_commit_preemptible_tcs(priv);\n\n\tmutex_unlock(&priv->mm_lock);\n\n\treturn 0;\n}\n\n \nvoid enetc_mm_link_state_update(struct enetc_ndev_priv *priv, bool link)\n{\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tu32 val;\n\n\tmutex_lock(&priv->mm_lock);\n\n\tval = enetc_port_rd(hw, ENETC_MMCSR);\n\n\tif (link) {\n\t\tval &= ~ENETC_MMCSR_LINK_FAIL;\n\t\tif (priv->active_offloads & ENETC_F_QBU)\n\t\t\tval |= ENETC_MMCSR_ME;\n\t} else {\n\t\tval |= ENETC_MMCSR_LINK_FAIL;\n\t\tif (priv->active_offloads & ENETC_F_QBU)\n\t\t\tval &= ~ENETC_MMCSR_ME;\n\t}\n\n\tenetc_port_wr(hw, ENETC_MMCSR, val);\n\n\tenetc_mm_commit_preemptible_tcs(priv);\n\n\tmutex_unlock(&priv->mm_lock);\n}\nEXPORT_SYMBOL_GPL(enetc_mm_link_state_update);\n\nstatic const struct ethtool_ops enetc_pf_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE_RX,\n\t.get_regs_len = enetc_get_reglen,\n\t.get_regs = enetc_get_regs,\n\t.get_sset_count = enetc_get_sset_count,\n\t.get_strings = enetc_get_strings,\n\t.get_ethtool_stats = enetc_get_ethtool_stats,\n\t.get_pause_stats = enetc_get_pause_stats,\n\t.get_rmon_stats = enetc_get_rmon_stats,\n\t.get_eth_ctrl_stats = enetc_get_eth_ctrl_stats,\n\t.get_eth_mac_stats = enetc_get_eth_mac_stats,\n\t.get_rxnfc = enetc_get_rxnfc,\n\t.set_rxnfc = enetc_set_rxnfc,\n\t.get_rxfh_key_size = enetc_get_rxfh_key_size,\n\t.get_rxfh_indir_size = enetc_get_rxfh_indir_size,\n\t.get_rxfh = enetc_get_rxfh,\n\t.set_rxfh = enetc_set_rxfh,\n\t.get_ringparam = enetc_get_ringparam,\n\t.get_coalesce = enetc_get_coalesce,\n\t.set_coalesce = enetc_set_coalesce,\n\t.get_link_ksettings = enetc_get_link_ksettings,\n\t.set_link_ksettings = enetc_set_link_ksettings,\n\t.get_link = ethtool_op_get_link,\n\t.get_ts_info = enetc_get_ts_info,\n\t.get_wol = enetc_get_wol,\n\t.set_wol = enetc_set_wol,\n\t.get_pauseparam = enetc_get_pauseparam,\n\t.set_pauseparam = enetc_set_pauseparam,\n\t.get_mm = enetc_get_mm,\n\t.set_mm = enetc_set_mm,\n\t.get_mm_stats = enetc_get_mm_stats,\n};\n\nstatic const struct ethtool_ops enetc_vf_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE_RX,\n\t.get_regs_len = enetc_get_reglen,\n\t.get_regs = enetc_get_regs,\n\t.get_sset_count = enetc_get_sset_count,\n\t.get_strings = enetc_get_strings,\n\t.get_ethtool_stats = enetc_get_ethtool_stats,\n\t.get_rxnfc = enetc_get_rxnfc,\n\t.set_rxnfc = enetc_set_rxnfc,\n\t.get_rxfh_indir_size = enetc_get_rxfh_indir_size,\n\t.get_rxfh = enetc_get_rxfh,\n\t.set_rxfh = enetc_set_rxfh,\n\t.get_ringparam = enetc_get_ringparam,\n\t.get_coalesce = enetc_get_coalesce,\n\t.set_coalesce = enetc_set_coalesce,\n\t.get_link = ethtool_op_get_link,\n\t.get_ts_info = enetc_get_ts_info,\n};\n\nvoid enetc_set_ethtool_ops(struct net_device *ndev)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\n\tif (enetc_si_is_pf(priv->si))\n\t\tndev->ethtool_ops = &enetc_pf_ethtool_ops;\n\telse\n\t\tndev->ethtool_ops = &enetc_vf_ethtool_ops;\n}\nEXPORT_SYMBOL_GPL(enetc_set_ethtool_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}