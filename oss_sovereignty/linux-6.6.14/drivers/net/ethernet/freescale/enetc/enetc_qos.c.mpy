{
  "module_name": "enetc_qos.c",
  "hash_id": "bb9873258b6a699ca90a85c25b5c3083abed968f28bbb3924ffd428cad88bcba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/enetc/enetc_qos.c",
  "human_readable_source": "\n \n\n#include \"enetc.h\"\n\n#include <net/pkt_sched.h>\n#include <linux/math64.h>\n#include <linux/refcount.h>\n#include <net/pkt_cls.h>\n#include <net/tc_act/tc_gate.h>\n\nstatic u16 enetc_get_max_gcl_len(struct enetc_hw *hw)\n{\n\treturn enetc_rd(hw, ENETC_PTGCAPR) & ENETC_PTGCAPR_MAX_GCL_LEN_MASK;\n}\n\nvoid enetc_sched_speed_set(struct enetc_ndev_priv *priv, int speed)\n{\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tu32 old_speed = priv->speed;\n\tu32 pspeed, tmp;\n\n\tif (speed == old_speed)\n\t\treturn;\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\tpspeed = ENETC_PMR_PSPEED_1000M;\n\t\tbreak;\n\tcase SPEED_2500:\n\t\tpspeed = ENETC_PMR_PSPEED_2500M;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tpspeed = ENETC_PMR_PSPEED_100M;\n\t\tbreak;\n\tcase SPEED_10:\n\tdefault:\n\t\tpspeed = ENETC_PMR_PSPEED_10M;\n\t}\n\n\tpriv->speed = speed;\n\ttmp = enetc_port_rd(hw, ENETC_PMR);\n\tenetc_port_wr(hw, ENETC_PMR, (tmp & ~ENETC_PMR_PSPEED_MASK) | pspeed);\n}\n\nstatic int enetc_setup_taprio(struct enetc_ndev_priv *priv,\n\t\t\t      struct tc_taprio_qopt_offload *admin_conf)\n{\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tstruct enetc_cbd cbd = {.cmd = 0};\n\tstruct tgs_gcl_conf *gcl_config;\n\tstruct tgs_gcl_data *gcl_data;\n\tdma_addr_t dma;\n\tstruct gce *gce;\n\tu16 data_size;\n\tu16 gcl_len;\n\tvoid *tmp;\n\tu32 tge;\n\tint err;\n\tint i;\n\n\t \n\tfor (i = 0; i < priv->num_tx_rings; i++)\n\t\tif (priv->tx_ring[i]->tsd_enable)\n\t\t\treturn -EBUSY;\n\n\tif (admin_conf->num_entries > enetc_get_max_gcl_len(hw))\n\t\treturn -EINVAL;\n\n\tif (admin_conf->cycle_time > U32_MAX ||\n\t    admin_conf->cycle_time_extension > U32_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tgcl_config = &cbd.gcl_conf;\n\tgcl_len = admin_conf->num_entries;\n\n\tdata_size = struct_size(gcl_data, entry, gcl_len);\n\ttmp = enetc_cbd_alloc_data_mem(priv->si, &cbd, data_size,\n\t\t\t\t       &dma, (void *)&gcl_data);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tgce = (struct gce *)(gcl_data + 1);\n\n\t \n\tgcl_config->atc = 0xff;\n\tgcl_config->acl_len = cpu_to_le16(gcl_len);\n\n\tgcl_data->btl = cpu_to_le32(lower_32_bits(admin_conf->base_time));\n\tgcl_data->bth = cpu_to_le32(upper_32_bits(admin_conf->base_time));\n\tgcl_data->ct = cpu_to_le32(admin_conf->cycle_time);\n\tgcl_data->cte = cpu_to_le32(admin_conf->cycle_time_extension);\n\n\tfor (i = 0; i < gcl_len; i++) {\n\t\tstruct tc_taprio_sched_entry *temp_entry;\n\t\tstruct gce *temp_gce = gce + i;\n\n\t\ttemp_entry = &admin_conf->entries[i];\n\n\t\ttemp_gce->gate = (u8)temp_entry->gate_mask;\n\t\ttemp_gce->period = cpu_to_le32(temp_entry->interval);\n\t}\n\n\tcbd.status_flags = 0;\n\n\tcbd.cls = BDCR_CMD_PORT_GCL;\n\tcbd.status_flags = 0;\n\n\ttge = enetc_rd(hw, ENETC_PTGCR);\n\tenetc_wr(hw, ENETC_PTGCR, tge | ENETC_PTGCR_TGE);\n\n\terr = enetc_send_cmd(priv->si, &cbd);\n\tif (err)\n\t\tenetc_wr(hw, ENETC_PTGCR, tge & ~ENETC_PTGCR_TGE);\n\n\tenetc_cbd_free_data_mem(priv->si, data_size, tmp, &dma);\n\n\tif (err)\n\t\treturn err;\n\n\tenetc_set_ptcmsdur(hw, admin_conf->max_sdu);\n\tpriv->active_offloads |= ENETC_F_QBV;\n\n\treturn 0;\n}\n\nstatic void enetc_reset_taprio_stats(struct enetc_ndev_priv *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->num_tx_rings; i++)\n\t\tpriv->tx_ring[i]->stats.win_drop = 0;\n}\n\nstatic void enetc_reset_taprio(struct enetc_ndev_priv *priv)\n{\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tu32 val;\n\n\tval = enetc_rd(hw, ENETC_PTGCR);\n\tenetc_wr(hw, ENETC_PTGCR, val & ~ENETC_PTGCR_TGE);\n\tenetc_reset_ptcmsdur(hw);\n\n\tpriv->active_offloads &= ~ENETC_F_QBV;\n}\n\nstatic void enetc_taprio_destroy(struct net_device *ndev)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\n\tenetc_reset_taprio(priv);\n\tenetc_reset_tc_mqprio(ndev);\n\tenetc_reset_taprio_stats(priv);\n}\n\nstatic void enetc_taprio_stats(struct net_device *ndev,\n\t\t\t       struct tc_taprio_qopt_stats *stats)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tu64 window_drops = 0;\n\tint i;\n\n\tfor (i = 0; i < priv->num_tx_rings; i++)\n\t\twindow_drops += priv->tx_ring[i]->stats.win_drop;\n\n\tstats->window_drops = window_drops;\n}\n\nstatic void enetc_taprio_queue_stats(struct net_device *ndev,\n\t\t\t\t     struct tc_taprio_qopt_queue_stats *queue_stats)\n{\n\tstruct tc_taprio_qopt_stats *stats = &queue_stats->stats;\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tint queue = queue_stats->queue;\n\n\tstats->window_drops = priv->tx_ring[queue]->stats.win_drop;\n}\n\nstatic int enetc_taprio_replace(struct net_device *ndev,\n\t\t\t\tstruct tc_taprio_qopt_offload *offload)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tint err;\n\n\terr = enetc_setup_tc_mqprio(ndev, &offload->mqprio);\n\tif (err)\n\t\treturn err;\n\n\terr = enetc_setup_taprio(priv, offload);\n\tif (err)\n\t\tenetc_reset_tc_mqprio(ndev);\n\n\treturn err;\n}\n\nint enetc_setup_tc_taprio(struct net_device *ndev, void *type_data)\n{\n\tstruct tc_taprio_qopt_offload *offload = type_data;\n\tint err = 0;\n\n\tswitch (offload->cmd) {\n\tcase TAPRIO_CMD_REPLACE:\n\t\terr = enetc_taprio_replace(ndev, offload);\n\t\tbreak;\n\tcase TAPRIO_CMD_DESTROY:\n\t\tenetc_taprio_destroy(ndev);\n\t\tbreak;\n\tcase TAPRIO_CMD_STATS:\n\t\tenetc_taprio_stats(ndev, &offload->stats);\n\t\tbreak;\n\tcase TAPRIO_CMD_QUEUE_STATS:\n\t\tenetc_taprio_queue_stats(ndev, &offload->queue_stats);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic u32 enetc_get_cbs_enable(struct enetc_hw *hw, u8 tc)\n{\n\treturn enetc_port_rd(hw, ENETC_PTCCBSR0(tc)) & ENETC_CBSE;\n}\n\nstatic u8 enetc_get_cbs_bw(struct enetc_hw *hw, u8 tc)\n{\n\treturn enetc_port_rd(hw, ENETC_PTCCBSR0(tc)) & ENETC_CBS_BW_MASK;\n}\n\nint enetc_setup_tc_cbs(struct net_device *ndev, void *type_data)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct tc_cbs_qopt_offload *cbs = type_data;\n\tu32 port_transmit_rate = priv->speed;\n\tu8 tc_nums = netdev_get_num_tc(ndev);\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tu32 hi_credit_bit, hi_credit_reg;\n\tu32 max_interference_size;\n\tu32 port_frame_max_size;\n\tu8 tc = cbs->queue;\n\tu8 prio_top, prio_next;\n\tint bw_sum = 0;\n\tu8 bw;\n\n\tprio_top = tc_nums - 1;\n\tprio_next = tc_nums - 2;\n\n\t \n\tif (tc != prio_top && tc != prio_next)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!cbs->enable) {\n\t\t \n\t\tif (tc == prio_top &&\n\t\t    enetc_get_cbs_enable(hw, prio_next)) {\n\t\t\tdev_err(&ndev->dev,\n\t\t\t\t\"Disable TC%d before disable TC%d\\n\",\n\t\t\t\tprio_next, tc);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tenetc_port_wr(hw, ENETC_PTCCBSR1(tc), 0);\n\t\tenetc_port_wr(hw, ENETC_PTCCBSR0(tc), 0);\n\n\t\treturn 0;\n\t}\n\n\tif (cbs->idleslope - cbs->sendslope != port_transmit_rate * 1000L ||\n\t    cbs->idleslope < 0 || cbs->sendslope > 0)\n\t\treturn -EOPNOTSUPP;\n\n\tport_frame_max_size = ndev->mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;\n\n\tbw = cbs->idleslope / (port_transmit_rate * 10UL);\n\n\t \n\tif (tc == prio_next) {\n\t\tif (!enetc_get_cbs_enable(hw, prio_top)) {\n\t\t\tdev_err(&ndev->dev,\n\t\t\t\t\"Enable TC%d first before enable TC%d\\n\",\n\t\t\t\tprio_top, prio_next);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbw_sum += enetc_get_cbs_bw(hw, prio_top);\n\t}\n\n\tif (bw_sum + bw >= 100) {\n\t\tdev_err(&ndev->dev,\n\t\t\t\"The sum of all CBS Bandwidth can't exceed 100\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tenetc_port_rd(hw, ENETC_PTCMSDUR(tc));\n\n\t \n\n\tif (tc == prio_top) {\n\t\tmax_interference_size = port_frame_max_size * 8;\n\t} else {\n\t\tu32 m0, ma, r0, ra;\n\n\t\tm0 = port_frame_max_size * 8;\n\t\tma = enetc_port_rd(hw, ENETC_PTCMSDUR(prio_top)) * 8;\n\t\tra = enetc_get_cbs_bw(hw, prio_top) *\n\t\t\tport_transmit_rate * 10000ULL;\n\t\tr0 = port_transmit_rate * 1000000ULL;\n\t\tmax_interference_size = m0 + ma +\n\t\t\t(u32)div_u64((u64)ra * m0, r0 - ra);\n\t}\n\n\t \n\thi_credit_bit = max_interference_size * bw / 100;\n\n\t \n\thi_credit_reg = (u32)div_u64((ENETC_CLK * 100ULL) * hi_credit_bit,\n\t\t\t\t     port_transmit_rate * 1000000ULL);\n\n\tenetc_port_wr(hw, ENETC_PTCCBSR1(tc), hi_credit_reg);\n\n\t \n\tenetc_port_wr(hw, ENETC_PTCCBSR0(tc), bw | ENETC_CBSE);\n\n\treturn 0;\n}\n\nint enetc_setup_tc_txtime(struct net_device *ndev, void *type_data)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct tc_etf_qopt_offload *qopt = type_data;\n\tu8 tc_nums = netdev_get_num_tc(ndev);\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tint tc;\n\n\tif (!tc_nums)\n\t\treturn -EOPNOTSUPP;\n\n\ttc = qopt->queue;\n\n\tif (tc < 0 || tc >= priv->num_tx_rings)\n\t\treturn -EINVAL;\n\n\t \n\tif (enetc_rd(hw, ENETC_PTGCR) & ENETC_PTGCR_TGE)\n\t\treturn -EBUSY;\n\n\tpriv->tx_ring[tc]->tsd_enable = qopt->enable;\n\tenetc_port_wr(hw, ENETC_PTCTSDR(tc), qopt->enable ? ENETC_TSDE : 0);\n\n\treturn 0;\n}\n\nenum streamid_type {\n\tSTREAMID_TYPE_RESERVED = 0,\n\tSTREAMID_TYPE_NULL,\n\tSTREAMID_TYPE_SMAC,\n};\n\nenum streamid_vlan_tagged {\n\tSTREAMID_VLAN_RESERVED = 0,\n\tSTREAMID_VLAN_TAGGED,\n\tSTREAMID_VLAN_UNTAGGED,\n\tSTREAMID_VLAN_ALL,\n};\n\n#define ENETC_PSFP_WILDCARD -1\n#define HANDLE_OFFSET 100\n\nenum forward_type {\n\tFILTER_ACTION_TYPE_PSFP = BIT(0),\n\tFILTER_ACTION_TYPE_ACL = BIT(1),\n\tFILTER_ACTION_TYPE_BOTH = GENMASK(1, 0),\n};\n\n \nstruct actions_fwd {\n\tu64 actions;\n\tu64 keys;\t \n\tenum forward_type output;\n};\n\nstruct psfp_streamfilter_counters {\n\tu64 matching_frames_count;\n\tu64 passing_frames_count;\n\tu64 not_passing_frames_count;\n\tu64 passing_sdu_count;\n\tu64 not_passing_sdu_count;\n\tu64 red_frames_count;\n};\n\nstruct enetc_streamid {\n\tu32 index;\n\tunion {\n\t\tu8 src_mac[6];\n\t\tu8 dst_mac[6];\n\t};\n\tu8 filtertype;\n\tu16 vid;\n\tu8 tagged;\n\ts32 handle;\n};\n\nstruct enetc_psfp_filter {\n\tu32 index;\n\ts32 handle;\n\ts8 prio;\n\tu32 maxsdu;\n\tu32 gate_id;\n\ts32 meter_id;\n\trefcount_t refcount;\n\tstruct hlist_node node;\n};\n\nstruct enetc_psfp_gate {\n\tu32 index;\n\ts8 init_ipv;\n\tu64 basetime;\n\tu64 cycletime;\n\tu64 cycletimext;\n\tu32 num_entries;\n\trefcount_t refcount;\n\tstruct hlist_node node;\n\tstruct action_gate_entry entries[];\n};\n\n \nstruct enetc_psfp_meter {\n\tu32 index;\n\tu32 cir;\n\tu32 cbs;\n\trefcount_t refcount;\n\tstruct hlist_node node;\n};\n\n#define ENETC_PSFP_FLAGS_FMI BIT(0)\n\nstruct enetc_stream_filter {\n\tstruct enetc_streamid sid;\n\tu32 sfi_index;\n\tu32 sgi_index;\n\tu32 flags;\n\tu32 fmi_index;\n\tstruct flow_stats stats;\n\tstruct hlist_node node;\n};\n\nstruct enetc_psfp {\n\tunsigned long dev_bitmap;\n\tunsigned long *psfp_sfi_bitmap;\n\tstruct hlist_head stream_list;\n\tstruct hlist_head psfp_filter_list;\n\tstruct hlist_head psfp_gate_list;\n\tstruct hlist_head psfp_meter_list;\n\tspinlock_t psfp_lock;  \n};\n\nstatic struct actions_fwd enetc_act_fwd[] = {\n\t{\n\t\tBIT(FLOW_ACTION_GATE),\n\t\tBIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS),\n\t\tFILTER_ACTION_TYPE_PSFP\n\t},\n\t{\n\t\tBIT(FLOW_ACTION_POLICE) |\n\t\tBIT(FLOW_ACTION_GATE),\n\t\tBIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS),\n\t\tFILTER_ACTION_TYPE_PSFP\n\t},\n\t \n\t{\n\t\tBIT(FLOW_ACTION_DROP),\n\t\t0,\n\t\tFILTER_ACTION_TYPE_ACL\n\t}\n};\n\nstatic struct enetc_psfp epsfp = {\n\t.dev_bitmap = 0,\n\t.psfp_sfi_bitmap = NULL,\n};\n\nstatic LIST_HEAD(enetc_block_cb_list);\n\n \nstatic int enetc_streamid_hw_set(struct enetc_ndev_priv *priv,\n\t\t\t\t struct enetc_streamid *sid,\n\t\t\t\t u8 enable)\n{\n\tstruct enetc_cbd cbd = {.cmd = 0};\n\tstruct streamid_data *si_data;\n\tstruct streamid_conf *si_conf;\n\tdma_addr_t dma;\n\tu16 data_size;\n\tvoid *tmp;\n\tint port;\n\tint err;\n\n\tport = enetc_pf_to_port(priv->si->pdev);\n\tif (port < 0)\n\t\treturn -EINVAL;\n\n\tif (sid->index >= priv->psfp_cap.max_streamid)\n\t\treturn -EINVAL;\n\n\tif (sid->filtertype != STREAMID_TYPE_NULL &&\n\t    sid->filtertype != STREAMID_TYPE_SMAC)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tcbd.index = cpu_to_le16((u16)sid->index);\n\tcbd.cls = BDCR_CMD_STREAM_IDENTIFY;\n\tcbd.status_flags = 0;\n\n\tdata_size = sizeof(struct streamid_data);\n\ttmp = enetc_cbd_alloc_data_mem(priv->si, &cbd, data_size,\n\t\t\t\t       &dma, (void *)&si_data);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\teth_broadcast_addr(si_data->dmac);\n\tsi_data->vid_vidm_tg = (ENETC_CBDR_SID_VID_MASK\n\t\t\t       + ((0x3 << 14) | ENETC_CBDR_SID_VIDM));\n\n\tsi_conf = &cbd.sid_set;\n\t \n\tsi_conf->iports = cpu_to_le32(1 << port);\n\tsi_conf->id_type = 1;\n\tsi_conf->oui[2] = 0x0;\n\tsi_conf->oui[1] = 0x80;\n\tsi_conf->oui[0] = 0xC2;\n\n\terr = enetc_send_cmd(priv->si, &cbd);\n\tif (err)\n\t\tgoto out;\n\n\tif (!enable)\n\t\tgoto out;\n\n\t \n\tcbd.status_flags = 0;\n\n\tsi_conf->en = 0x80;\n\tsi_conf->stream_handle = cpu_to_le32(sid->handle);\n\tsi_conf->iports = cpu_to_le32(1 << port);\n\tsi_conf->id_type = sid->filtertype;\n\tsi_conf->oui[2] = 0x0;\n\tsi_conf->oui[1] = 0x80;\n\tsi_conf->oui[0] = 0xC2;\n\n\tmemset(si_data, 0, data_size);\n\n\t \n\tif (si_conf->id_type == STREAMID_TYPE_NULL) {\n\t\tether_addr_copy(si_data->dmac, sid->dst_mac);\n\t\tsi_data->vid_vidm_tg = (sid->vid & ENETC_CBDR_SID_VID_MASK) +\n\t\t\t\t       ((((u16)(sid->tagged) & 0x3) << 14)\n\t\t\t\t       | ENETC_CBDR_SID_VIDM);\n\t} else if (si_conf->id_type == STREAMID_TYPE_SMAC) {\n\t\tether_addr_copy(si_data->smac, sid->src_mac);\n\t\tsi_data->vid_vidm_tg = (sid->vid & ENETC_CBDR_SID_VID_MASK) +\n\t\t\t\t       ((((u16)(sid->tagged) & 0x3) << 14)\n\t\t\t\t       | ENETC_CBDR_SID_VIDM);\n\t}\n\n\terr = enetc_send_cmd(priv->si, &cbd);\nout:\n\tenetc_cbd_free_data_mem(priv->si, data_size, tmp, &dma);\n\n\treturn err;\n}\n\n \nstatic int enetc_streamfilter_hw_set(struct enetc_ndev_priv *priv,\n\t\t\t\t     struct enetc_psfp_filter *sfi,\n\t\t\t\t     u8 enable)\n{\n\tstruct enetc_cbd cbd = {.cmd = 0};\n\tstruct sfi_conf *sfi_config;\n\tint port;\n\n\tport = enetc_pf_to_port(priv->si->pdev);\n\tif (port < 0)\n\t\treturn -EINVAL;\n\n\tcbd.index = cpu_to_le16(sfi->index);\n\tcbd.cls = BDCR_CMD_STREAM_FILTER;\n\tcbd.status_flags = 0x80;\n\tcbd.length = cpu_to_le16(1);\n\n\tsfi_config = &cbd.sfi_conf;\n\tif (!enable)\n\t\tgoto exit;\n\n\tsfi_config->en = 0x80;\n\n\tif (sfi->handle >= 0) {\n\t\tsfi_config->stream_handle =\n\t\t\tcpu_to_le32(sfi->handle);\n\t\tsfi_config->sthm |= 0x80;\n\t}\n\n\tsfi_config->sg_inst_table_index = cpu_to_le16(sfi->gate_id);\n\tsfi_config->input_ports = cpu_to_le32(1 << port);\n\n\t \n\tif (sfi->prio >= 0)\n\t\tsfi_config->multi |= (sfi->prio & 0x7) | 0x8;\n\n\t \n\tif (sfi->maxsdu) {\n\t\tsfi_config->msdu =\n\t\tcpu_to_le16(sfi->maxsdu);\n\t\tsfi_config->multi |= 0x40;\n\t}\n\n\tif (sfi->meter_id >= 0) {\n\t\tsfi_config->fm_inst_table_index = cpu_to_le16(sfi->meter_id);\n\t\tsfi_config->multi |= 0x80;\n\t}\n\nexit:\n\treturn enetc_send_cmd(priv->si, &cbd);\n}\n\nstatic int enetc_streamcounter_hw_get(struct enetc_ndev_priv *priv,\n\t\t\t\t      u32 index,\n\t\t\t\t      struct psfp_streamfilter_counters *cnt)\n{\n\tstruct enetc_cbd cbd = { .cmd = 2 };\n\tstruct sfi_counter_data *data_buf;\n\tdma_addr_t dma;\n\tu16 data_size;\n\tvoid *tmp;\n\tint err;\n\n\tcbd.index = cpu_to_le16((u16)index);\n\tcbd.cmd = 2;\n\tcbd.cls = BDCR_CMD_STREAM_FILTER;\n\tcbd.status_flags = 0;\n\n\tdata_size = sizeof(struct sfi_counter_data);\n\n\ttmp = enetc_cbd_alloc_data_mem(priv->si, &cbd, data_size,\n\t\t\t\t       &dma, (void *)&data_buf);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\terr = enetc_send_cmd(priv->si, &cbd);\n\tif (err)\n\t\tgoto exit;\n\n\tcnt->matching_frames_count = ((u64)data_buf->matchh << 32) +\n\t\t\t\t     data_buf->matchl;\n\n\tcnt->not_passing_sdu_count = ((u64)data_buf->msdu_droph << 32) +\n\t\t\t\t     data_buf->msdu_dropl;\n\n\tcnt->passing_sdu_count = cnt->matching_frames_count\n\t\t\t\t- cnt->not_passing_sdu_count;\n\n\tcnt->not_passing_frames_count =\n\t\t\t\t((u64)data_buf->stream_gate_droph << 32) +\n\t\t\t\tdata_buf->stream_gate_dropl;\n\n\tcnt->passing_frames_count = cnt->matching_frames_count -\n\t\t\t\t    cnt->not_passing_sdu_count -\n\t\t\t\t    cnt->not_passing_frames_count;\n\n\tcnt->red_frames_count =\t((u64)data_buf->flow_meter_droph << 32)\t+\n\t\t\t\tdata_buf->flow_meter_dropl;\n\nexit:\n\tenetc_cbd_free_data_mem(priv->si, data_size, tmp, &dma);\n\n\treturn err;\n}\n\nstatic u64 get_ptp_now(struct enetc_hw *hw)\n{\n\tu64 now_lo, now_hi, now;\n\n\tnow_lo = enetc_rd(hw, ENETC_SICTR0);\n\tnow_hi = enetc_rd(hw, ENETC_SICTR1);\n\tnow = now_lo | now_hi << 32;\n\n\treturn now;\n}\n\nstatic int get_start_ns(u64 now, u64 cycle, u64 *start)\n{\n\tu64 n;\n\n\tif (!cycle)\n\t\treturn -EFAULT;\n\n\tn = div64_u64(now, cycle);\n\n\t*start = (n + 1) * cycle;\n\n\treturn 0;\n}\n\n \nstatic int enetc_streamgate_hw_set(struct enetc_ndev_priv *priv,\n\t\t\t\t   struct enetc_psfp_gate *sgi,\n\t\t\t\t   u8 enable)\n{\n\tstruct enetc_cbd cbd = { .cmd = 0 };\n\tstruct sgi_table *sgi_config;\n\tstruct sgcl_conf *sgcl_config;\n\tstruct sgcl_data *sgcl_data;\n\tstruct sgce *sgce;\n\tdma_addr_t dma;\n\tu16 data_size;\n\tint err, i;\n\tvoid *tmp;\n\tu64 now;\n\n\tcbd.index = cpu_to_le16(sgi->index);\n\tcbd.cmd = 0;\n\tcbd.cls = BDCR_CMD_STREAM_GCL;\n\tcbd.status_flags = 0x80;\n\n\t \n\tif (!enable)\n\t\treturn enetc_send_cmd(priv->si, &cbd);\n\n\tif (!sgi->num_entries)\n\t\treturn 0;\n\n\tif (sgi->num_entries > priv->psfp_cap.max_psfp_gatelist ||\n\t    !sgi->cycletime)\n\t\treturn -EINVAL;\n\n\t \n\tsgi_config = &cbd.sgi_table;\n\n\t \n\tsgi_config->ocgtst = 0x80;\n\n\tsgi_config->oipv = (sgi->init_ipv < 0) ?\n\t\t\t\t0x0 : ((sgi->init_ipv & 0x7) | 0x8);\n\n\tsgi_config->en = 0x80;\n\n\t \n\terr = enetc_send_cmd(priv->si, &cbd);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tmemset(&cbd, 0, sizeof(cbd));\n\n\tcbd.index = cpu_to_le16(sgi->index);\n\tcbd.cmd = 1;\n\tcbd.cls = BDCR_CMD_STREAM_GCL;\n\tcbd.status_flags = 0;\n\n\tsgcl_config = &cbd.sgcl_conf;\n\n\tsgcl_config->acl_len = (sgi->num_entries - 1) & 0x3;\n\n\tdata_size = struct_size(sgcl_data, sgcl, sgi->num_entries);\n\ttmp = enetc_cbd_alloc_data_mem(priv->si, &cbd, data_size,\n\t\t\t\t       &dma, (void *)&sgcl_data);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tsgce = &sgcl_data->sgcl[0];\n\n\tsgcl_config->agtst = 0x80;\n\n\tsgcl_data->ct = sgi->cycletime;\n\tsgcl_data->cte = sgi->cycletimext;\n\n\tif (sgi->init_ipv >= 0)\n\t\tsgcl_config->aipv = (sgi->init_ipv & 0x7) | 0x8;\n\n\tfor (i = 0; i < sgi->num_entries; i++) {\n\t\tstruct action_gate_entry *from = &sgi->entries[i];\n\t\tstruct sgce *to = &sgce[i];\n\n\t\tif (from->gate_state)\n\t\t\tto->multi |= 0x10;\n\n\t\tif (from->ipv >= 0)\n\t\t\tto->multi |= ((from->ipv & 0x7) << 5) | 0x08;\n\n\t\tif (from->maxoctets >= 0) {\n\t\t\tto->multi |= 0x01;\n\t\t\tto->msdu[0] = from->maxoctets & 0xFF;\n\t\t\tto->msdu[1] = (from->maxoctets >> 8) & 0xFF;\n\t\t\tto->msdu[2] = (from->maxoctets >> 16) & 0xFF;\n\t\t}\n\n\t\tto->interval = from->interval;\n\t}\n\n\t \n\tnow = get_ptp_now(&priv->si->hw);\n\n\tif (sgi->basetime < now) {\n\t\tu64 start;\n\n\t\terr = get_start_ns(now, sgi->cycletime, &start);\n\t\tif (err)\n\t\t\tgoto exit;\n\t\tsgcl_data->btl = lower_32_bits(start);\n\t\tsgcl_data->bth = upper_32_bits(start);\n\t} else {\n\t\tu32 hi, lo;\n\n\t\thi = upper_32_bits(sgi->basetime);\n\t\tlo = lower_32_bits(sgi->basetime);\n\t\tsgcl_data->bth = hi;\n\t\tsgcl_data->btl = lo;\n\t}\n\n\terr = enetc_send_cmd(priv->si, &cbd);\n\nexit:\n\tenetc_cbd_free_data_mem(priv->si, data_size, tmp, &dma);\n\treturn err;\n}\n\nstatic int enetc_flowmeter_hw_set(struct enetc_ndev_priv *priv,\n\t\t\t\t  struct enetc_psfp_meter *fmi,\n\t\t\t\t  u8 enable)\n{\n\tstruct enetc_cbd cbd = { .cmd = 0 };\n\tstruct fmi_conf *fmi_config;\n\tu64 temp = 0;\n\n\tcbd.index = cpu_to_le16((u16)fmi->index);\n\tcbd.cls = BDCR_CMD_FLOW_METER;\n\tcbd.status_flags = 0x80;\n\n\tif (!enable)\n\t\treturn enetc_send_cmd(priv->si, &cbd);\n\n\tfmi_config = &cbd.fmi_conf;\n\tfmi_config->en = 0x80;\n\n\tif (fmi->cir) {\n\t\ttemp = (u64)8000 * fmi->cir;\n\t\ttemp = div_u64(temp, 3725);\n\t}\n\n\tfmi_config->cir = cpu_to_le32((u32)temp);\n\tfmi_config->cbs = cpu_to_le32(fmi->cbs);\n\n\t \n\tfmi_config->eir = 0;\n\tfmi_config->ebs = 0;\n\n\t \n\tfmi_config->conf = 0;\n\n\treturn enetc_send_cmd(priv->si, &cbd);\n}\n\nstatic struct enetc_stream_filter *enetc_get_stream_by_index(u32 index)\n{\n\tstruct enetc_stream_filter *f;\n\n\thlist_for_each_entry(f, &epsfp.stream_list, node)\n\t\tif (f->sid.index == index)\n\t\t\treturn f;\n\n\treturn NULL;\n}\n\nstatic struct enetc_psfp_gate *enetc_get_gate_by_index(u32 index)\n{\n\tstruct enetc_psfp_gate *g;\n\n\thlist_for_each_entry(g, &epsfp.psfp_gate_list, node)\n\t\tif (g->index == index)\n\t\t\treturn g;\n\n\treturn NULL;\n}\n\nstatic struct enetc_psfp_filter *enetc_get_filter_by_index(u32 index)\n{\n\tstruct enetc_psfp_filter *s;\n\n\thlist_for_each_entry(s, &epsfp.psfp_filter_list, node)\n\t\tif (s->index == index)\n\t\t\treturn s;\n\n\treturn NULL;\n}\n\nstatic struct enetc_psfp_meter *enetc_get_meter_by_index(u32 index)\n{\n\tstruct enetc_psfp_meter *m;\n\n\thlist_for_each_entry(m, &epsfp.psfp_meter_list, node)\n\t\tif (m->index == index)\n\t\t\treturn m;\n\n\treturn NULL;\n}\n\nstatic struct enetc_psfp_filter\n\t*enetc_psfp_check_sfi(struct enetc_psfp_filter *sfi)\n{\n\tstruct enetc_psfp_filter *s;\n\n\thlist_for_each_entry(s, &epsfp.psfp_filter_list, node)\n\t\tif (s->gate_id == sfi->gate_id &&\n\t\t    s->prio == sfi->prio &&\n\t\t    s->maxsdu == sfi->maxsdu &&\n\t\t    s->meter_id == sfi->meter_id)\n\t\t\treturn s;\n\n\treturn NULL;\n}\n\nstatic int enetc_get_free_index(struct enetc_ndev_priv *priv)\n{\n\tu32 max_size = priv->psfp_cap.max_psfp_filter;\n\tunsigned long index;\n\n\tindex = find_first_zero_bit(epsfp.psfp_sfi_bitmap, max_size);\n\tif (index == max_size)\n\t\treturn -1;\n\n\treturn index;\n}\n\nstatic void stream_filter_unref(struct enetc_ndev_priv *priv, u32 index)\n{\n\tstruct enetc_psfp_filter *sfi;\n\tu8 z;\n\n\tsfi = enetc_get_filter_by_index(index);\n\tWARN_ON(!sfi);\n\tz = refcount_dec_and_test(&sfi->refcount);\n\n\tif (z) {\n\t\tenetc_streamfilter_hw_set(priv, sfi, false);\n\t\thlist_del(&sfi->node);\n\t\tkfree(sfi);\n\t\tclear_bit(index, epsfp.psfp_sfi_bitmap);\n\t}\n}\n\nstatic void stream_gate_unref(struct enetc_ndev_priv *priv, u32 index)\n{\n\tstruct enetc_psfp_gate *sgi;\n\tu8 z;\n\n\tsgi = enetc_get_gate_by_index(index);\n\tWARN_ON(!sgi);\n\tz = refcount_dec_and_test(&sgi->refcount);\n\tif (z) {\n\t\tenetc_streamgate_hw_set(priv, sgi, false);\n\t\thlist_del(&sgi->node);\n\t\tkfree(sgi);\n\t}\n}\n\nstatic void flow_meter_unref(struct enetc_ndev_priv *priv, u32 index)\n{\n\tstruct enetc_psfp_meter *fmi;\n\tu8 z;\n\n\tfmi = enetc_get_meter_by_index(index);\n\tWARN_ON(!fmi);\n\tz = refcount_dec_and_test(&fmi->refcount);\n\tif (z) {\n\t\tenetc_flowmeter_hw_set(priv, fmi, false);\n\t\thlist_del(&fmi->node);\n\t\tkfree(fmi);\n\t}\n}\n\nstatic void remove_one_chain(struct enetc_ndev_priv *priv,\n\t\t\t     struct enetc_stream_filter *filter)\n{\n\tif (filter->flags & ENETC_PSFP_FLAGS_FMI)\n\t\tflow_meter_unref(priv, filter->fmi_index);\n\n\tstream_gate_unref(priv, filter->sgi_index);\n\tstream_filter_unref(priv, filter->sfi_index);\n\n\thlist_del(&filter->node);\n\tkfree(filter);\n}\n\nstatic int enetc_psfp_hw_set(struct enetc_ndev_priv *priv,\n\t\t\t     struct enetc_streamid *sid,\n\t\t\t     struct enetc_psfp_filter *sfi,\n\t\t\t     struct enetc_psfp_gate *sgi,\n\t\t\t     struct enetc_psfp_meter *fmi)\n{\n\tint err;\n\n\terr = enetc_streamid_hw_set(priv, sid, true);\n\tif (err)\n\t\treturn err;\n\n\tif (sfi) {\n\t\terr = enetc_streamfilter_hw_set(priv, sfi, true);\n\t\tif (err)\n\t\t\tgoto revert_sid;\n\t}\n\n\terr = enetc_streamgate_hw_set(priv, sgi, true);\n\tif (err)\n\t\tgoto revert_sfi;\n\n\tif (fmi) {\n\t\terr = enetc_flowmeter_hw_set(priv, fmi, true);\n\t\tif (err)\n\t\t\tgoto revert_sgi;\n\t}\n\n\treturn 0;\n\nrevert_sgi:\n\tenetc_streamgate_hw_set(priv, sgi, false);\nrevert_sfi:\n\tif (sfi)\n\t\tenetc_streamfilter_hw_set(priv, sfi, false);\nrevert_sid:\n\tenetc_streamid_hw_set(priv, sid, false);\n\treturn err;\n}\n\nstatic struct actions_fwd *\nenetc_check_flow_actions(u64 acts, unsigned long long inputkeys)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(enetc_act_fwd); i++)\n\t\tif (acts == enetc_act_fwd[i].actions &&\n\t\t    inputkeys & enetc_act_fwd[i].keys)\n\t\t\treturn &enetc_act_fwd[i];\n\n\treturn NULL;\n}\n\nstatic int enetc_psfp_policer_validate(const struct flow_action *action,\n\t\t\t\t       const struct flow_action_entry *act,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tif (act->police.exceed.act_id != FLOW_ACTION_DROP) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when exceed action is not drop\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.notexceed.act_id != FLOW_ACTION_PIPE &&\n\t    act->police.notexceed.act_id != FLOW_ACTION_ACCEPT) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when conform action is not pipe or ok\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.notexceed.act_id == FLOW_ACTION_ACCEPT &&\n\t    !flow_action_is_last_entry(action, act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when conform action is ok, but action is not last\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.peakrate_bytes_ps ||\n\t    act->police.avrate || act->police.overhead) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when peakrate/avrate/overhead is configured\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.rate_pkt_ps) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"QoS offload not support packets per second\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int enetc_psfp_parse_clsflower(struct enetc_ndev_priv *priv,\n\t\t\t\t      struct flow_cls_offload *f)\n{\n\tstruct flow_action_entry *entryg = NULL, *entryp = NULL;\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct enetc_stream_filter *filter, *old_filter;\n\tstruct enetc_psfp_meter *fmi = NULL, *old_fmi;\n\tstruct enetc_psfp_filter *sfi, *old_sfi;\n\tstruct enetc_psfp_gate *sgi, *old_sgi;\n\tstruct flow_action_entry *entry;\n\tstruct action_gate_entry *e;\n\tu8 sfi_overwrite = 0;\n\tint entries_size;\n\tint i, err;\n\n\tif (f->common.chain_index >= priv->psfp_cap.max_streamid) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"No Stream identify resource!\");\n\t\treturn -ENOSPC;\n\t}\n\n\tflow_action_for_each(i, entry, &rule->action)\n\t\tif (entry->id == FLOW_ACTION_GATE)\n\t\t\tentryg = entry;\n\t\telse if (entry->id == FLOW_ACTION_POLICE)\n\t\t\tentryp = entry;\n\n\t \n\tif (!entryg)\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (!filter)\n\t\treturn -ENOMEM;\n\n\tfilter->sid.index = f->common.chain_index;\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct flow_match_eth_addrs match;\n\n\t\tflow_rule_match_eth_addrs(rule, &match);\n\n\t\tif (!is_zero_ether_addr(match.mask->dst) &&\n\t\t    !is_zero_ether_addr(match.mask->src)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Cannot match on both source and destination MAC\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto free_filter;\n\t\t}\n\n\t\tif (!is_zero_ether_addr(match.mask->dst)) {\n\t\t\tif (!is_broadcast_ether_addr(match.mask->dst)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Masked matching on destination MAC not supported\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free_filter;\n\t\t\t}\n\t\t\tether_addr_copy(filter->sid.dst_mac, match.key->dst);\n\t\t\tfilter->sid.filtertype = STREAMID_TYPE_NULL;\n\t\t}\n\n\t\tif (!is_zero_ether_addr(match.mask->src)) {\n\t\t\tif (!is_broadcast_ether_addr(match.mask->src)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Masked matching on source MAC not supported\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free_filter;\n\t\t\t}\n\t\t\tether_addr_copy(filter->sid.src_mac, match.key->src);\n\t\t\tfilter->sid.filtertype = STREAMID_TYPE_SMAC;\n\t\t}\n\t} else {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported, must include ETH_ADDRS\");\n\t\terr = -EINVAL;\n\t\tgoto free_filter;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tstruct flow_match_vlan match;\n\n\t\tflow_rule_match_vlan(rule, &match);\n\t\tif (match.mask->vlan_priority) {\n\t\t\tif (match.mask->vlan_priority !=\n\t\t\t    (VLAN_PRIO_MASK >> VLAN_PRIO_SHIFT)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Only full mask is supported for VLAN priority\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free_filter;\n\t\t\t}\n\t\t}\n\n\t\tif (match.mask->vlan_id) {\n\t\t\tif (match.mask->vlan_id != VLAN_VID_MASK) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Only full mask is supported for VLAN id\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free_filter;\n\t\t\t}\n\n\t\t\tfilter->sid.vid = match.key->vlan_id;\n\t\t\tif (!filter->sid.vid)\n\t\t\t\tfilter->sid.tagged = STREAMID_VLAN_UNTAGGED;\n\t\t\telse\n\t\t\t\tfilter->sid.tagged = STREAMID_VLAN_TAGGED;\n\t\t}\n\t} else {\n\t\tfilter->sid.tagged = STREAMID_VLAN_ALL;\n\t}\n\n\t \n\tif (entryg->hw_index >= priv->psfp_cap.max_psfp_gate) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"No Stream Gate resource!\");\n\t\terr = -ENOSPC;\n\t\tgoto free_filter;\n\t}\n\n\tif (entryg->gate.num_entries >= priv->psfp_cap.max_psfp_gatelist) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"No Stream Gate resource!\");\n\t\terr = -ENOSPC;\n\t\tgoto free_filter;\n\t}\n\n\tentries_size = struct_size(sgi, entries, entryg->gate.num_entries);\n\tsgi = kzalloc(entries_size, GFP_KERNEL);\n\tif (!sgi) {\n\t\terr = -ENOMEM;\n\t\tgoto free_filter;\n\t}\n\n\trefcount_set(&sgi->refcount, 1);\n\tsgi->index = entryg->hw_index;\n\tsgi->init_ipv = entryg->gate.prio;\n\tsgi->basetime = entryg->gate.basetime;\n\tsgi->cycletime = entryg->gate.cycletime;\n\tsgi->num_entries = entryg->gate.num_entries;\n\n\te = sgi->entries;\n\tfor (i = 0; i < entryg->gate.num_entries; i++) {\n\t\te[i].gate_state = entryg->gate.entries[i].gate_state;\n\t\te[i].interval = entryg->gate.entries[i].interval;\n\t\te[i].ipv = entryg->gate.entries[i].ipv;\n\t\te[i].maxoctets = entryg->gate.entries[i].maxoctets;\n\t}\n\n\tfilter->sgi_index = sgi->index;\n\n\tsfi = kzalloc(sizeof(*sfi), GFP_KERNEL);\n\tif (!sfi) {\n\t\terr = -ENOMEM;\n\t\tgoto free_gate;\n\t}\n\n\trefcount_set(&sfi->refcount, 1);\n\tsfi->gate_id = sgi->index;\n\tsfi->meter_id = ENETC_PSFP_WILDCARD;\n\n\t \n\tif (entryp) {\n\t\terr = enetc_psfp_policer_validate(&rule->action, entryp, extack);\n\t\tif (err)\n\t\t\tgoto free_sfi;\n\n\t\tif (entryp->police.burst) {\n\t\t\tfmi = kzalloc(sizeof(*fmi), GFP_KERNEL);\n\t\t\tif (!fmi) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto free_sfi;\n\t\t\t}\n\t\t\trefcount_set(&fmi->refcount, 1);\n\t\t\tfmi->cir = entryp->police.rate_bytes_ps;\n\t\t\tfmi->cbs = entryp->police.burst;\n\t\t\tfmi->index = entryp->hw_index;\n\t\t\tfilter->flags |= ENETC_PSFP_FLAGS_FMI;\n\t\t\tfilter->fmi_index = fmi->index;\n\t\t\tsfi->meter_id = fmi->index;\n\t\t}\n\n\t\tif (entryp->police.mtu)\n\t\t\tsfi->maxsdu = entryp->police.mtu;\n\t}\n\n\t \n\tif (f->common.prio && f->common.prio <= BIT(3))\n\t\tsfi->prio = f->common.prio - 1;\n\telse\n\t\tsfi->prio = ENETC_PSFP_WILDCARD;\n\n\told_sfi = enetc_psfp_check_sfi(sfi);\n\tif (!old_sfi) {\n\t\tint index;\n\n\t\tindex = enetc_get_free_index(priv);\n\t\tif (index < 0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"No Stream Filter resource!\");\n\t\t\terr = -ENOSPC;\n\t\t\tgoto free_fmi;\n\t\t}\n\n\t\tsfi->index = index;\n\t\tsfi->handle = index + HANDLE_OFFSET;\n\t\t \n\t\tfilter->sid.handle = sfi->handle;\n\t\tfilter->sfi_index = sfi->index;\n\t\tsfi_overwrite = 0;\n\t} else {\n\t\tfilter->sfi_index = old_sfi->index;\n\t\tfilter->sid.handle = old_sfi->handle;\n\t\tsfi_overwrite = 1;\n\t}\n\n\terr = enetc_psfp_hw_set(priv, &filter->sid,\n\t\t\t\tsfi_overwrite ? NULL : sfi, sgi, fmi);\n\tif (err)\n\t\tgoto free_fmi;\n\n\tspin_lock(&epsfp.psfp_lock);\n\tif (filter->flags & ENETC_PSFP_FLAGS_FMI) {\n\t\told_fmi = enetc_get_meter_by_index(filter->fmi_index);\n\t\tif (old_fmi) {\n\t\t\tfmi->refcount = old_fmi->refcount;\n\t\t\trefcount_set(&fmi->refcount,\n\t\t\t\t     refcount_read(&old_fmi->refcount) + 1);\n\t\t\thlist_del(&old_fmi->node);\n\t\t\tkfree(old_fmi);\n\t\t}\n\t\thlist_add_head(&fmi->node, &epsfp.psfp_meter_list);\n\t}\n\n\t \n\told_sgi = enetc_get_gate_by_index(filter->sgi_index);\n\tif (old_sgi) {\n\t\trefcount_set(&sgi->refcount,\n\t\t\t     refcount_read(&old_sgi->refcount) + 1);\n\t\thlist_del(&old_sgi->node);\n\t\tkfree(old_sgi);\n\t}\n\n\thlist_add_head(&sgi->node, &epsfp.psfp_gate_list);\n\n\tif (!old_sfi) {\n\t\thlist_add_head(&sfi->node, &epsfp.psfp_filter_list);\n\t\tset_bit(sfi->index, epsfp.psfp_sfi_bitmap);\n\t} else {\n\t\tkfree(sfi);\n\t\trefcount_inc(&old_sfi->refcount);\n\t}\n\n\told_filter = enetc_get_stream_by_index(filter->sid.index);\n\tif (old_filter)\n\t\tremove_one_chain(priv, old_filter);\n\n\tfilter->stats.lastused = jiffies;\n\thlist_add_head(&filter->node, &epsfp.stream_list);\n\n\tspin_unlock(&epsfp.psfp_lock);\n\n\treturn 0;\n\nfree_fmi:\n\tkfree(fmi);\nfree_sfi:\n\tkfree(sfi);\nfree_gate:\n\tkfree(sgi);\nfree_filter:\n\tkfree(filter);\n\n\treturn err;\n}\n\nstatic int enetc_config_clsflower(struct enetc_ndev_priv *priv,\n\t\t\t\t  struct flow_cls_offload *cls_flower)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(cls_flower);\n\tstruct netlink_ext_ack *extack = cls_flower->common.extack;\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tstruct flow_action *action = &rule->action;\n\tstruct flow_action_entry *entry;\n\tstruct actions_fwd *fwd;\n\tu64 actions = 0;\n\tint i, err;\n\n\tif (!flow_action_has_entries(action)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"At least one action is needed\");\n\t\treturn -EINVAL;\n\t}\n\n\tflow_action_for_each(i, entry, action)\n\t\tactions |= BIT(entry->id);\n\n\tfwd = enetc_check_flow_actions(actions, dissector->used_keys);\n\tif (!fwd) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported filter type!\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (fwd->output & FILTER_ACTION_TYPE_PSFP) {\n\t\terr = enetc_psfp_parse_clsflower(priv, cls_flower);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid PSFP inputs\");\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported actions\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int enetc_psfp_destroy_clsflower(struct enetc_ndev_priv *priv,\n\t\t\t\t\tstruct flow_cls_offload *f)\n{\n\tstruct enetc_stream_filter *filter;\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tint err;\n\n\tif (f->common.chain_index >= priv->psfp_cap.max_streamid) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"No Stream identify resource!\");\n\t\treturn -ENOSPC;\n\t}\n\n\tfilter = enetc_get_stream_by_index(f->common.chain_index);\n\tif (!filter)\n\t\treturn -EINVAL;\n\n\terr = enetc_streamid_hw_set(priv, &filter->sid, false);\n\tif (err)\n\t\treturn err;\n\n\tremove_one_chain(priv, filter);\n\n\treturn 0;\n}\n\nstatic int enetc_destroy_clsflower(struct enetc_ndev_priv *priv,\n\t\t\t\t   struct flow_cls_offload *f)\n{\n\treturn enetc_psfp_destroy_clsflower(priv, f);\n}\n\nstatic int enetc_psfp_get_stats(struct enetc_ndev_priv *priv,\n\t\t\t\tstruct flow_cls_offload *f)\n{\n\tstruct psfp_streamfilter_counters counters = {};\n\tstruct enetc_stream_filter *filter;\n\tstruct flow_stats stats = {};\n\tint err;\n\n\tfilter = enetc_get_stream_by_index(f->common.chain_index);\n\tif (!filter)\n\t\treturn -EINVAL;\n\n\terr = enetc_streamcounter_hw_get(priv, filter->sfi_index, &counters);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tspin_lock(&epsfp.psfp_lock);\n\tstats.pkts = counters.matching_frames_count +\n\t\t     counters.not_passing_sdu_count -\n\t\t     filter->stats.pkts;\n\tstats.drops = counters.not_passing_frames_count +\n\t\t      counters.not_passing_sdu_count +\n\t\t      counters.red_frames_count -\n\t\t      filter->stats.drops;\n\tstats.lastused = filter->stats.lastused;\n\tfilter->stats.pkts += stats.pkts;\n\tfilter->stats.drops += stats.drops;\n\tspin_unlock(&epsfp.psfp_lock);\n\n\tflow_stats_update(&f->stats, 0x0, stats.pkts, stats.drops,\n\t\t\t  stats.lastused, FLOW_ACTION_HW_STATS_DELAYED);\n\n\treturn 0;\n}\n\nstatic int enetc_setup_tc_cls_flower(struct enetc_ndev_priv *priv,\n\t\t\t\t     struct flow_cls_offload *cls_flower)\n{\n\tswitch (cls_flower->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn enetc_config_clsflower(priv, cls_flower);\n\tcase FLOW_CLS_DESTROY:\n\t\treturn enetc_destroy_clsflower(priv, cls_flower);\n\tcase FLOW_CLS_STATS:\n\t\treturn enetc_psfp_get_stats(priv, cls_flower);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic inline void clean_psfp_sfi_bitmap(void)\n{\n\tbitmap_free(epsfp.psfp_sfi_bitmap);\n\tepsfp.psfp_sfi_bitmap = NULL;\n}\n\nstatic void clean_stream_list(void)\n{\n\tstruct enetc_stream_filter *s;\n\tstruct hlist_node *tmp;\n\n\thlist_for_each_entry_safe(s, tmp, &epsfp.stream_list, node) {\n\t\thlist_del(&s->node);\n\t\tkfree(s);\n\t}\n}\n\nstatic void clean_sfi_list(void)\n{\n\tstruct enetc_psfp_filter *sfi;\n\tstruct hlist_node *tmp;\n\n\thlist_for_each_entry_safe(sfi, tmp, &epsfp.psfp_filter_list, node) {\n\t\thlist_del(&sfi->node);\n\t\tkfree(sfi);\n\t}\n}\n\nstatic void clean_sgi_list(void)\n{\n\tstruct enetc_psfp_gate *sgi;\n\tstruct hlist_node *tmp;\n\n\thlist_for_each_entry_safe(sgi, tmp, &epsfp.psfp_gate_list, node) {\n\t\thlist_del(&sgi->node);\n\t\tkfree(sgi);\n\t}\n}\n\nstatic void clean_psfp_all(void)\n{\n\t \n\tclean_sfi_list();\n\tclean_sgi_list();\n\tclean_stream_list();\n\tepsfp.dev_bitmap = 0;\n\tclean_psfp_sfi_bitmap();\n}\n\nint enetc_setup_tc_block_cb(enum tc_setup_type type, void *type_data,\n\t\t\t    void *cb_priv)\n{\n\tstruct net_device *ndev = cb_priv;\n\n\tif (!tc_can_offload(ndev))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn enetc_setup_tc_cls_flower(netdev_priv(ndev), type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint enetc_set_psfp(struct net_device *ndev, bool en)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tint err;\n\n\tif (en) {\n\t\terr = enetc_psfp_enable(priv);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tpriv->active_offloads |= ENETC_F_QCI;\n\t\treturn 0;\n\t}\n\n\terr = enetc_psfp_disable(priv);\n\tif (err)\n\t\treturn err;\n\n\tpriv->active_offloads &= ~ENETC_F_QCI;\n\n\treturn 0;\n}\n\nint enetc_psfp_init(struct enetc_ndev_priv *priv)\n{\n\tif (epsfp.psfp_sfi_bitmap)\n\t\treturn 0;\n\n\tepsfp.psfp_sfi_bitmap = bitmap_zalloc(priv->psfp_cap.max_psfp_filter,\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!epsfp.psfp_sfi_bitmap)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&epsfp.psfp_lock);\n\n\tif (list_empty(&enetc_block_cb_list))\n\t\tepsfp.dev_bitmap = 0;\n\n\treturn 0;\n}\n\nint enetc_psfp_clean(struct enetc_ndev_priv *priv)\n{\n\tif (!list_empty(&enetc_block_cb_list))\n\t\treturn -EBUSY;\n\n\tclean_psfp_all();\n\n\treturn 0;\n}\n\nint enetc_setup_tc_psfp(struct net_device *ndev, void *type_data)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct flow_block_offload *f = type_data;\n\tint port, err;\n\n\terr = flow_block_cb_setup_simple(f, &enetc_block_cb_list,\n\t\t\t\t\t enetc_setup_tc_block_cb,\n\t\t\t\t\t ndev, ndev, true);\n\tif (err)\n\t\treturn err;\n\n\tswitch (f->command) {\n\tcase FLOW_BLOCK_BIND:\n\t\tport = enetc_pf_to_port(priv->si->pdev);\n\t\tif (port < 0)\n\t\t\treturn -EINVAL;\n\n\t\tset_bit(port, &epsfp.dev_bitmap);\n\t\tbreak;\n\tcase FLOW_BLOCK_UNBIND:\n\t\tport = enetc_pf_to_port(priv->si->pdev);\n\t\tif (port < 0)\n\t\t\treturn -EINVAL;\n\n\t\tclear_bit(port, &epsfp.dev_bitmap);\n\t\tif (!epsfp.dev_bitmap)\n\t\t\tclean_psfp_all();\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint enetc_qos_query_caps(struct net_device *ndev, void *type_data)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct tc_query_caps_base *base = type_data;\n\tstruct enetc_si *si = priv->si;\n\n\tswitch (base->type) {\n\tcase TC_SETUP_QDISC_MQPRIO: {\n\t\tstruct tc_mqprio_caps *caps = base->caps;\n\n\t\tcaps->validate_queue_counts = true;\n\n\t\treturn 0;\n\t}\n\tcase TC_SETUP_QDISC_TAPRIO: {\n\t\tstruct tc_taprio_caps *caps = base->caps;\n\n\t\tif (si->hw_features & ENETC_SI_F_QBV)\n\t\t\tcaps->supports_queue_max_sdu = true;\n\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}