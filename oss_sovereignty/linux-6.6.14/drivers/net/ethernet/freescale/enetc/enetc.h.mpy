{
  "module_name": "enetc.h",
  "hash_id": "5b55f8e471066a016a3ec8559c4f782b26bec9944b03fdc94fd070db847e36bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/enetc/enetc.h",
  "human_readable_source": " \n \n\n#include <linux/timer.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/dma-mapping.h>\n#include <linux/skbuff.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n#include <linux/phylink.h>\n#include <linux/dim.h>\n#include <net/xdp.h>\n\n#include \"enetc_hw.h\"\n\n#define ENETC_MAC_MAXFRM_SIZE\t9600\n#define ENETC_MAX_MTU\t\t(ENETC_MAC_MAXFRM_SIZE - \\\n\t\t\t\t(ETH_FCS_LEN + ETH_HLEN + VLAN_HLEN))\n\n#define ENETC_CBD_DATA_MEM_ALIGN 64\n\nstruct enetc_tx_swbd {\n\tunion {\n\t\tstruct sk_buff *skb;\n\t\tstruct xdp_frame *xdp_frame;\n\t};\n\tdma_addr_t dma;\n\tstruct page *page;\t \n\tu16 page_offset;\t \n\tu16 len;\n\tenum dma_data_direction dir;\n\tu8 is_dma_page:1;\n\tu8 check_wb:1;\n\tu8 do_twostep_tstamp:1;\n\tu8 is_eof:1;\n\tu8 is_xdp_tx:1;\n\tu8 is_xdp_redirect:1;\n\tu8 qbv_en:1;\n};\n\n#define ENETC_RX_MAXFRM_SIZE\tENETC_MAC_MAXFRM_SIZE\n#define ENETC_RXB_TRUESIZE\t2048  \n#define ENETC_RXB_PAD\t\tNET_SKB_PAD  \n#define ENETC_RXB_DMA_SIZE\t\\\n\t(SKB_WITH_OVERHEAD(ENETC_RXB_TRUESIZE) - ENETC_RXB_PAD)\n#define ENETC_RXB_DMA_SIZE_XDP\t\\\n\t(SKB_WITH_OVERHEAD(ENETC_RXB_TRUESIZE) - XDP_PACKET_HEADROOM)\n\nstruct enetc_rx_swbd {\n\tdma_addr_t dma;\n\tstruct page *page;\n\tu16 page_offset;\n\tenum dma_data_direction dir;\n\tu16 len;\n};\n\n \n#define ENETC_TXBDS_NEEDED(val)\t((val) + 2)\n \n#define ENETC_MAX_SKB_FRAGS\t13\n#define ENETC_TXBDS_MAX_NEEDED\tENETC_TXBDS_NEEDED(ENETC_MAX_SKB_FRAGS + 1)\n\nstruct enetc_ring_stats {\n\tunsigned int packets;\n\tunsigned int bytes;\n\tunsigned int rx_alloc_errs;\n\tunsigned int xdp_drops;\n\tunsigned int xdp_tx;\n\tunsigned int xdp_tx_drops;\n\tunsigned int xdp_redirect;\n\tunsigned int xdp_redirect_failures;\n\tunsigned int recycles;\n\tunsigned int recycle_failures;\n\tunsigned int win_drop;\n};\n\nstruct enetc_xdp_data {\n\tstruct xdp_rxq_info rxq;\n\tstruct bpf_prog *prog;\n\tint xdp_tx_in_flight;\n};\n\n#define ENETC_RX_RING_DEFAULT_SIZE\t2048\n#define ENETC_TX_RING_DEFAULT_SIZE\t2048\n#define ENETC_DEFAULT_TX_WORK\t\t(ENETC_TX_RING_DEFAULT_SIZE / 2)\n\nstruct enetc_bdr_resource {\n\t \n\tstruct device *dev;  \n\tsize_t bd_count;\n\tsize_t bd_size;\n\n\t \n\tvoid *bd_base;  \n\tdma_addr_t bd_dma_base;\n\tunion {\n\t\tstruct enetc_tx_swbd *tx_swbd;\n\t\tstruct enetc_rx_swbd *rx_swbd;\n\t};\n\tchar *tso_headers;\n\tdma_addr_t tso_headers_dma;\n};\n\nstruct enetc_bdr {\n\tstruct device *dev;  \n\tstruct net_device *ndev;\n\tvoid *bd_base;  \n\tunion {\n\t\tvoid __iomem *tpir;\n\t\tvoid __iomem *rcir;\n\t};\n\tu16 index;\n\tu16 prio;\n\tint bd_count;  \n\tint next_to_use;\n\tint next_to_clean;\n\tunion {\n\t\tstruct enetc_tx_swbd *tx_swbd;\n\t\tstruct enetc_rx_swbd *rx_swbd;\n\t};\n\tunion {\n\t\tvoid __iomem *tcir;  \n\t\tint next_to_alloc;  \n\t};\n\tvoid __iomem *idr;  \n\n\tint buffer_offset;\n\tstruct enetc_xdp_data xdp;\n\n\tstruct enetc_ring_stats stats;\n\n\tdma_addr_t bd_dma_base;\n\tu8 tsd_enable;  \n\tbool ext_en;  \n\n\t \n\tchar *tso_headers;\n\tdma_addr_t tso_headers_dma;\n} ____cacheline_aligned_in_smp;\n\nstatic inline void enetc_bdr_idx_inc(struct enetc_bdr *bdr, int *i)\n{\n\tif (unlikely(++*i == bdr->bd_count))\n\t\t*i = 0;\n}\n\nstatic inline int enetc_bd_unused(struct enetc_bdr *bdr)\n{\n\tif (bdr->next_to_clean > bdr->next_to_use)\n\t\treturn bdr->next_to_clean - bdr->next_to_use - 1;\n\n\treturn bdr->bd_count + bdr->next_to_clean - bdr->next_to_use - 1;\n}\n\nstatic inline int enetc_swbd_unused(struct enetc_bdr *bdr)\n{\n\tif (bdr->next_to_clean > bdr->next_to_alloc)\n\t\treturn bdr->next_to_clean - bdr->next_to_alloc - 1;\n\n\treturn bdr->bd_count + bdr->next_to_clean - bdr->next_to_alloc - 1;\n}\n\n \n#define ENETC_CBDR_DEFAULT_SIZE\t64\nstruct enetc_cbdr {\n\tvoid *bd_base;  \n\tvoid __iomem *pir;\n\tvoid __iomem *cir;\n\tvoid __iomem *mr;  \n\n\tint bd_count;  \n\tint next_to_use;\n\tint next_to_clean;\n\n\tdma_addr_t bd_dma_base;\n\tstruct device *dma_dev;\n};\n\n#define ENETC_TXBD(BDR, i) (&(((union enetc_tx_bd *)((BDR).bd_base))[i]))\n\nstatic inline union enetc_rx_bd *enetc_rxbd(struct enetc_bdr *rx_ring, int i)\n{\n\tint hw_idx = i;\n\n#ifdef CONFIG_FSL_ENETC_PTP_CLOCK\n\tif (rx_ring->ext_en)\n\t\thw_idx = 2 * i;\n#endif\n\treturn &(((union enetc_rx_bd *)rx_ring->bd_base)[hw_idx]);\n}\n\nstatic inline void enetc_rxbd_next(struct enetc_bdr *rx_ring,\n\t\t\t\t   union enetc_rx_bd **old_rxbd, int *old_index)\n{\n\tunion enetc_rx_bd *new_rxbd = *old_rxbd;\n\tint new_index = *old_index;\n\n\tnew_rxbd++;\n\n#ifdef CONFIG_FSL_ENETC_PTP_CLOCK\n\tif (rx_ring->ext_en)\n\t\tnew_rxbd++;\n#endif\n\n\tif (unlikely(++new_index == rx_ring->bd_count)) {\n\t\tnew_rxbd = rx_ring->bd_base;\n\t\tnew_index = 0;\n\t}\n\n\t*old_rxbd = new_rxbd;\n\t*old_index = new_index;\n}\n\nstatic inline union enetc_rx_bd *enetc_rxbd_ext(union enetc_rx_bd *rxbd)\n{\n\treturn ++rxbd;\n}\n\nstruct enetc_msg_swbd {\n\tvoid *vaddr;\n\tdma_addr_t dma;\n\tint size;\n};\n\n#define ENETC_REV1\t0x1\nenum enetc_errata {\n\tENETC_ERR_VLAN_ISOL\t= BIT(0),\n\tENETC_ERR_UCMCSWP\t= BIT(1),\n};\n\n#define ENETC_SI_F_PSFP BIT(0)\n#define ENETC_SI_F_QBV  BIT(1)\n#define ENETC_SI_F_QBU  BIT(2)\n\n \nstruct enetc_si {\n\tstruct pci_dev *pdev;\n\tstruct enetc_hw hw;\n\tenum enetc_errata errata;\n\n\tstruct net_device *ndev;  \n\n\tstruct enetc_cbdr cbd_ring;\n\n\tint num_rx_rings;  \n\tint num_tx_rings;\n\tint num_fs_entries;\n\tint num_rss;  \n\tunsigned short pad;\n\tint hw_features;\n};\n\n#define ENETC_SI_ALIGN\t32\n\nstatic inline void *enetc_si_priv(const struct enetc_si *si)\n{\n\treturn (char *)si + ALIGN(sizeof(struct enetc_si), ENETC_SI_ALIGN);\n}\n\nstatic inline bool enetc_si_is_pf(struct enetc_si *si)\n{\n\treturn !!(si->hw.port);\n}\n\nstatic inline int enetc_pf_to_port(struct pci_dev *pf_pdev)\n{\n\tswitch (pf_pdev->devfn) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\treturn 1;\n\tcase 2:\n\t\treturn 2;\n\tcase 6:\n\t\treturn 3;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n#define ENETC_MAX_NUM_TXQS\t8\n#define ENETC_INT_NAME_MAX\t(IFNAMSIZ + 8)\n\nstruct enetc_int_vector {\n\tvoid __iomem *rbier;\n\tvoid __iomem *tbier_base;\n\tvoid __iomem *ricr1;\n\tunsigned long tx_rings_map;\n\tint count_tx_rings;\n\tu32 rx_ictt;\n\tu16 comp_cnt;\n\tbool rx_dim_en, rx_napi_work;\n\tstruct napi_struct napi ____cacheline_aligned_in_smp;\n\tstruct dim rx_dim ____cacheline_aligned_in_smp;\n\tchar name[ENETC_INT_NAME_MAX];\n\n\tstruct enetc_bdr rx_ring;\n\tstruct enetc_bdr tx_ring[];\n} ____cacheline_aligned_in_smp;\n\nstruct enetc_cls_rule {\n\tstruct ethtool_rx_flow_spec fs;\n\tint used;\n};\n\n#define ENETC_MAX_BDR_INT\t2  \nstruct psfp_cap {\n\tu32 max_streamid;\n\tu32 max_psfp_filter;\n\tu32 max_psfp_gate;\n\tu32 max_psfp_gatelist;\n\tu32 max_psfp_meter;\n};\n\n#define ENETC_F_TX_TSTAMP_MASK\t0xff\nenum enetc_active_offloads {\n\t \n\tENETC_F_TX_TSTAMP\t\t= BIT(0),\n\tENETC_F_TX_ONESTEP_SYNC_TSTAMP\t= BIT(1),\n\n\tENETC_F_RX_TSTAMP\t\t= BIT(8),\n\tENETC_F_QBV\t\t\t= BIT(9),\n\tENETC_F_QCI\t\t\t= BIT(10),\n\tENETC_F_QBU\t\t\t= BIT(11),\n};\n\nenum enetc_flags_bit {\n\tENETC_TX_ONESTEP_TSTAMP_IN_PROGRESS = 0,\n};\n\n \nenum enetc_ic_mode {\n\t \n\tENETC_IC_NONE = 0,\n\t \n\tENETC_IC_RX_MANUAL = BIT(0),\n\tENETC_IC_TX_MANUAL = BIT(1),\n\t \n\tENETC_IC_RX_ADAPTIVE = BIT(2),\n};\n\n#define ENETC_RXIC_PKTTHR\tmin_t(u32, 256, ENETC_RX_RING_DEFAULT_SIZE / 2)\n#define ENETC_TXIC_PKTTHR\tmin_t(u32, 128, ENETC_TX_RING_DEFAULT_SIZE / 2)\n#define ENETC_TXIC_TIMETHR\tenetc_usecs_to_cycles(600)\n\nstruct enetc_ndev_priv {\n\tstruct net_device *ndev;\n\tstruct device *dev;  \n\tstruct enetc_si *si;\n\n\tint bdr_int_num;  \n\tstruct enetc_int_vector *int_vector[ENETC_MAX_BDR_INT];\n\tu16 num_rx_rings, num_tx_rings;\n\tu16 rx_bd_count, tx_bd_count;\n\n\tu16 msg_enable;\n\n\tu8 preemptible_tcs;\n\n\tenum enetc_active_offloads active_offloads;\n\n\tu32 speed;  \n\n\tstruct enetc_bdr **xdp_tx_ring;\n\tstruct enetc_bdr *tx_ring[16];\n\tstruct enetc_bdr *rx_ring[16];\n\tconst struct enetc_bdr_resource *tx_res;\n\tconst struct enetc_bdr_resource *rx_res;\n\n\tstruct enetc_cls_rule *cls_rules;\n\n\tstruct psfp_cap psfp_cap;\n\n\t \n\tunsigned int min_num_stack_tx_queues;\n\n\tstruct phylink *phylink;\n\tint ic_mode;\n\tu32 tx_ictt;\n\n\tstruct bpf_prog *xdp_prog;\n\n\tunsigned long flags;\n\n\tstruct work_struct\ttx_onestep_tstamp;\n\tstruct sk_buff_head\ttx_skbs;\n\n\t \n\tstruct mutex\t\tmm_lock;\n};\n\n \n\n \nstruct enetc_msg_cmd_set_primary_mac {\n\tstruct enetc_msg_cmd_header header;\n\tstruct sockaddr mac;\n};\n\n#define ENETC_CBD(R, i)\t(&(((struct enetc_cbd *)((R).bd_base))[i]))\n\n#define ENETC_CBDR_TIMEOUT\t1000  \n\n \nextern int enetc_phc_index;\n\n \nu32 enetc_port_mac_rd(struct enetc_si *si, u32 reg);\nvoid enetc_port_mac_wr(struct enetc_si *si, u32 reg, u32 val);\nint enetc_pci_probe(struct pci_dev *pdev, const char *name, int sizeof_priv);\nvoid enetc_pci_remove(struct pci_dev *pdev);\nint enetc_alloc_msix(struct enetc_ndev_priv *priv);\nvoid enetc_free_msix(struct enetc_ndev_priv *priv);\nvoid enetc_get_si_caps(struct enetc_si *si);\nvoid enetc_init_si_rings_params(struct enetc_ndev_priv *priv);\nint enetc_alloc_si_resources(struct enetc_ndev_priv *priv);\nvoid enetc_free_si_resources(struct enetc_ndev_priv *priv);\nint enetc_configure_si(struct enetc_ndev_priv *priv);\n\nint enetc_open(struct net_device *ndev);\nint enetc_close(struct net_device *ndev);\nvoid enetc_start(struct net_device *ndev);\nvoid enetc_stop(struct net_device *ndev);\nnetdev_tx_t enetc_xmit(struct sk_buff *skb, struct net_device *ndev);\nstruct net_device_stats *enetc_get_stats(struct net_device *ndev);\nvoid enetc_set_features(struct net_device *ndev, netdev_features_t features);\nint enetc_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd);\nint enetc_setup_tc_mqprio(struct net_device *ndev, void *type_data);\nvoid enetc_reset_tc_mqprio(struct net_device *ndev);\nint enetc_setup_bpf(struct net_device *ndev, struct netdev_bpf *bpf);\nint enetc_xdp_xmit(struct net_device *ndev, int num_frames,\n\t\t   struct xdp_frame **frames, u32 flags);\n\n \nvoid enetc_set_ethtool_ops(struct net_device *ndev);\nvoid enetc_mm_link_state_update(struct enetc_ndev_priv *priv, bool link);\nvoid enetc_mm_commit_preemptible_tcs(struct enetc_ndev_priv *priv);\n\n \nint enetc_setup_cbdr(struct device *dev, struct enetc_hw *hw, int bd_count,\n\t\t     struct enetc_cbdr *cbdr);\nvoid enetc_teardown_cbdr(struct enetc_cbdr *cbdr);\nint enetc_set_mac_flt_entry(struct enetc_si *si, int index,\n\t\t\t    char *mac_addr, int si_map);\nint enetc_clear_mac_flt_entry(struct enetc_si *si, int index);\nint enetc_set_fs_entry(struct enetc_si *si, struct enetc_cmd_rfse *rfse,\n\t\t       int index);\nvoid enetc_set_rss_key(struct enetc_hw *hw, const u8 *bytes);\nint enetc_get_rss_table(struct enetc_si *si, u32 *table, int count);\nint enetc_set_rss_table(struct enetc_si *si, const u32 *table, int count);\nint enetc_send_cmd(struct enetc_si *si, struct enetc_cbd *cbd);\n\nstatic inline void *enetc_cbd_alloc_data_mem(struct enetc_si *si,\n\t\t\t\t\t     struct enetc_cbd *cbd,\n\t\t\t\t\t     int size, dma_addr_t *dma,\n\t\t\t\t\t     void **data_align)\n{\n\tstruct enetc_cbdr *ring = &si->cbd_ring;\n\tdma_addr_t dma_align;\n\tvoid *data;\n\n\tdata = dma_alloc_coherent(ring->dma_dev,\n\t\t\t\t  size + ENETC_CBD_DATA_MEM_ALIGN,\n\t\t\t\t  dma, GFP_KERNEL);\n\tif (!data) {\n\t\tdev_err(ring->dma_dev, \"CBD alloc data memory failed!\\n\");\n\t\treturn NULL;\n\t}\n\n\tdma_align = ALIGN(*dma, ENETC_CBD_DATA_MEM_ALIGN);\n\t*data_align = PTR_ALIGN(data, ENETC_CBD_DATA_MEM_ALIGN);\n\n\tcbd->addr[0] = cpu_to_le32(lower_32_bits(dma_align));\n\tcbd->addr[1] = cpu_to_le32(upper_32_bits(dma_align));\n\tcbd->length = cpu_to_le16(size);\n\n\treturn data;\n}\n\nstatic inline void enetc_cbd_free_data_mem(struct enetc_si *si, int size,\n\t\t\t\t\t   void *data, dma_addr_t *dma)\n{\n\tstruct enetc_cbdr *ring = &si->cbd_ring;\n\n\tdma_free_coherent(ring->dma_dev, size + ENETC_CBD_DATA_MEM_ALIGN,\n\t\t\t  data, *dma);\n}\n\nvoid enetc_reset_ptcmsdur(struct enetc_hw *hw);\nvoid enetc_set_ptcmsdur(struct enetc_hw *hw, u32 *queue_max_sdu);\n\n#ifdef CONFIG_FSL_ENETC_QOS\nint enetc_qos_query_caps(struct net_device *ndev, void *type_data);\nint enetc_setup_tc_taprio(struct net_device *ndev, void *type_data);\nvoid enetc_sched_speed_set(struct enetc_ndev_priv *priv, int speed);\nint enetc_setup_tc_cbs(struct net_device *ndev, void *type_data);\nint enetc_setup_tc_txtime(struct net_device *ndev, void *type_data);\nint enetc_setup_tc_block_cb(enum tc_setup_type type, void *type_data,\n\t\t\t    void *cb_priv);\nint enetc_setup_tc_psfp(struct net_device *ndev, void *type_data);\nint enetc_psfp_init(struct enetc_ndev_priv *priv);\nint enetc_psfp_clean(struct enetc_ndev_priv *priv);\nint enetc_set_psfp(struct net_device *ndev, bool en);\n\nstatic inline void enetc_get_max_cap(struct enetc_ndev_priv *priv)\n{\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tu32 reg;\n\n\treg = enetc_port_rd(hw, ENETC_PSIDCAPR);\n\tpriv->psfp_cap.max_streamid = reg & ENETC_PSIDCAPR_MSK;\n\t \n\treg = enetc_port_rd(hw, ENETC_PSFCAPR);\n\tpriv->psfp_cap.max_psfp_filter = reg & ENETC_PSFCAPR_MSK;\n\t \n\treg = enetc_port_rd(hw, ENETC_PSGCAPR);\n\tpriv->psfp_cap.max_psfp_gate = (reg & ENETC_PSGCAPR_SGIT_MSK);\n\tpriv->psfp_cap.max_psfp_gatelist = (reg & ENETC_PSGCAPR_GCL_MSK) >> 16;\n\t \n\treg = enetc_port_rd(hw, ENETC_PFMCAPR);\n\tpriv->psfp_cap.max_psfp_meter = reg & ENETC_PFMCAPR_MSK;\n}\n\nstatic inline int enetc_psfp_enable(struct enetc_ndev_priv *priv)\n{\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tint err;\n\n\tenetc_get_max_cap(priv);\n\n\terr = enetc_psfp_init(priv);\n\tif (err)\n\t\treturn err;\n\n\tenetc_wr(hw, ENETC_PPSFPMR, enetc_rd(hw, ENETC_PPSFPMR) |\n\t\t ENETC_PPSFPMR_PSFPEN | ENETC_PPSFPMR_VS |\n\t\t ENETC_PPSFPMR_PVC | ENETC_PPSFPMR_PVZC);\n\n\treturn 0;\n}\n\nstatic inline int enetc_psfp_disable(struct enetc_ndev_priv *priv)\n{\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tint err;\n\n\terr = enetc_psfp_clean(priv);\n\tif (err)\n\t\treturn err;\n\n\tenetc_wr(hw, ENETC_PPSFPMR, enetc_rd(hw, ENETC_PPSFPMR) &\n\t\t ~ENETC_PPSFPMR_PSFPEN & ~ENETC_PPSFPMR_VS &\n\t\t ~ENETC_PPSFPMR_PVC & ~ENETC_PPSFPMR_PVZC);\n\n\tmemset(&priv->psfp_cap, 0, sizeof(struct psfp_cap));\n\n\treturn 0;\n}\n\n#else\n#define enetc_qos_query_caps(ndev, type_data) -EOPNOTSUPP\n#define enetc_setup_tc_taprio(ndev, type_data) -EOPNOTSUPP\n#define enetc_sched_speed_set(priv, speed) (void)0\n#define enetc_setup_tc_cbs(ndev, type_data) -EOPNOTSUPP\n#define enetc_setup_tc_txtime(ndev, type_data) -EOPNOTSUPP\n#define enetc_setup_tc_psfp(ndev, type_data) -EOPNOTSUPP\n#define enetc_setup_tc_block_cb NULL\n\n#define enetc_get_max_cap(p)\t\t\\\n\tmemset(&((p)->psfp_cap), 0, sizeof(struct psfp_cap))\n\nstatic inline int enetc_psfp_enable(struct enetc_ndev_priv *priv)\n{\n\treturn 0;\n}\n\nstatic inline int enetc_psfp_disable(struct enetc_ndev_priv *priv)\n{\n\treturn 0;\n}\n\nstatic inline int enetc_set_psfp(struct net_device *ndev, bool en)\n{\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}