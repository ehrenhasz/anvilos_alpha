{
  "module_name": "enetc_vf.c",
  "hash_id": "a564d097526794fc74416733b420abd54df24147fe13337a80e1f510cc7c7876",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/enetc/enetc_vf.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include \"enetc.h\"\n\n#define ENETC_DRV_NAME_STR \"ENETC VF driver\"\n\n \nstatic void enetc_msg_vsi_write_msg(struct enetc_hw *hw,\n\t\t\t\t    struct enetc_msg_swbd *msg)\n{\n\tu32 val;\n\n\tval = enetc_vsi_set_msize(msg->size) | lower_32_bits(msg->dma);\n\tenetc_wr(hw, ENETC_VSIMSGSNDAR1, upper_32_bits(msg->dma));\n\tenetc_wr(hw, ENETC_VSIMSGSNDAR0, val);\n}\n\nstatic int enetc_msg_vsi_send(struct enetc_si *si, struct enetc_msg_swbd *msg)\n{\n\tint timeout = 100;\n\tu32 vsimsgsr;\n\n\tenetc_msg_vsi_write_msg(&si->hw, msg);\n\n\tdo {\n\t\tvsimsgsr = enetc_rd(&si->hw, ENETC_VSIMSGSR);\n\t\tif (!(vsimsgsr & ENETC_VSIMSGSR_MB))\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 2000);\n\t} while (--timeout);\n\n\tif (!timeout)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tif (vsimsgsr & ENETC_VSIMSGSR_MS) {\n\t\tdev_err(&si->pdev->dev, \"VSI command execute error: %d\\n\",\n\t\t\tENETC_SIMSGSR_GET_MC(vsimsgsr));\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int enetc_msg_vsi_set_primary_mac_addr(struct enetc_ndev_priv *priv,\n\t\t\t\t\t      struct sockaddr *saddr)\n{\n\tstruct enetc_msg_cmd_set_primary_mac *cmd;\n\tstruct enetc_msg_swbd msg;\n\tint err;\n\n\tmsg.size = ALIGN(sizeof(struct enetc_msg_cmd_set_primary_mac), 64);\n\tmsg.vaddr = dma_alloc_coherent(priv->dev, msg.size, &msg.dma,\n\t\t\t\t       GFP_KERNEL);\n\tif (!msg.vaddr) {\n\t\tdev_err(priv->dev, \"Failed to alloc Tx msg (size: %d)\\n\",\n\t\t\tmsg.size);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd = (struct enetc_msg_cmd_set_primary_mac *)msg.vaddr;\n\tcmd->header.type = ENETC_MSG_CMD_MNG_MAC;\n\tcmd->header.id = ENETC_MSG_CMD_MNG_ADD;\n\tmemcpy(&cmd->mac, saddr, sizeof(struct sockaddr));\n\n\t \n\terr = enetc_msg_vsi_send(priv->si, &msg);\n\n\tdma_free_coherent(priv->dev, msg.size, msg.vaddr, msg.dma);\n\n\treturn err;\n}\n\nstatic int enetc_vf_set_mac_addr(struct net_device *ndev, void *addr)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct sockaddr *saddr = addr;\n\n\tif (!is_valid_ether_addr(saddr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\treturn enetc_msg_vsi_set_primary_mac_addr(priv, saddr);\n}\n\nstatic int enetc_vf_set_features(struct net_device *ndev,\n\t\t\t\t netdev_features_t features)\n{\n\tenetc_set_features(ndev, features);\n\n\treturn 0;\n}\n\nstatic int enetc_vf_setup_tc(struct net_device *ndev, enum tc_setup_type type,\n\t\t\t     void *type_data)\n{\n\tswitch (type) {\n\tcase TC_SETUP_QDISC_MQPRIO:\n\t\treturn enetc_setup_tc_mqprio(ndev, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic const struct net_device_ops enetc_ndev_ops = {\n\t.ndo_open\t\t= enetc_open,\n\t.ndo_stop\t\t= enetc_close,\n\t.ndo_start_xmit\t\t= enetc_xmit,\n\t.ndo_get_stats\t\t= enetc_get_stats,\n\t.ndo_set_mac_address\t= enetc_vf_set_mac_addr,\n\t.ndo_set_features\t= enetc_vf_set_features,\n\t.ndo_eth_ioctl\t\t= enetc_ioctl,\n\t.ndo_setup_tc\t\t= enetc_vf_setup_tc,\n};\n\nstatic void enetc_vf_netdev_setup(struct enetc_si *si, struct net_device *ndev,\n\t\t\t\t  const struct net_device_ops *ndev_ops)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\n\tSET_NETDEV_DEV(ndev, &si->pdev->dev);\n\tpriv->ndev = ndev;\n\tpriv->si = si;\n\tpriv->dev = &si->pdev->dev;\n\tsi->ndev = ndev;\n\n\tpriv->msg_enable = (NETIF_MSG_IFUP << 1) - 1;\n\tndev->netdev_ops = ndev_ops;\n\tenetc_set_ethtool_ops(ndev);\n\tndev->watchdog_timeo = 5 * HZ;\n\tndev->max_mtu = ENETC_MAX_MTU;\n\n\tndev->hw_features = NETIF_F_SG | NETIF_F_RXCSUM |\n\t\t\t    NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t    NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t    NETIF_F_HW_CSUM | NETIF_F_TSO | NETIF_F_TSO6;\n\tndev->features = NETIF_F_HIGHDMA | NETIF_F_SG | NETIF_F_RXCSUM |\n\t\t\t NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t NETIF_F_HW_CSUM | NETIF_F_TSO | NETIF_F_TSO6;\n\tndev->vlan_features = NETIF_F_SG | NETIF_F_HW_CSUM |\n\t\t\t      NETIF_F_TSO | NETIF_F_TSO6;\n\n\tif (si->num_rss)\n\t\tndev->hw_features |= NETIF_F_RXHASH;\n\n\t \n\tenetc_load_primary_mac_addr(&si->hw, ndev);\n}\n\nstatic int enetc_vf_probe(struct pci_dev *pdev,\n\t\t\t  const struct pci_device_id *ent)\n{\n\tstruct enetc_ndev_priv *priv;\n\tstruct net_device *ndev;\n\tstruct enetc_si *si;\n\tint err;\n\n\terr = enetc_pci_probe(pdev, KBUILD_MODNAME, 0);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err, \"PCI probing failed\\n\");\n\n\tsi = pci_get_drvdata(pdev);\n\n\tenetc_get_si_caps(si);\n\n\tndev = alloc_etherdev_mq(sizeof(*priv), ENETC_MAX_NUM_TXQS);\n\tif (!ndev) {\n\t\terr = -ENOMEM;\n\t\tdev_err(&pdev->dev, \"netdev creation failed\\n\");\n\t\tgoto err_alloc_netdev;\n\t}\n\n\tenetc_vf_netdev_setup(si, ndev, &enetc_ndev_ops);\n\n\tpriv = netdev_priv(ndev);\n\n\tenetc_init_si_rings_params(priv);\n\n\terr = enetc_setup_cbdr(priv->dev, &si->hw, ENETC_CBDR_DEFAULT_SIZE,\n\t\t\t       &si->cbd_ring);\n\tif (err)\n\t\tgoto err_setup_cbdr;\n\n\terr = enetc_alloc_si_resources(priv);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"SI resource alloc failed\\n\");\n\t\tgoto err_alloc_si_res;\n\t}\n\n\terr = enetc_configure_si(priv);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to configure SI\\n\");\n\t\tgoto err_config_si;\n\t}\n\n\terr = enetc_alloc_msix(priv);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"MSIX alloc failed\\n\");\n\t\tgoto err_alloc_msix;\n\t}\n\n\terr = register_netdev(ndev);\n\tif (err)\n\t\tgoto err_reg_netdev;\n\n\tnetif_carrier_off(ndev);\n\n\treturn 0;\n\nerr_reg_netdev:\n\tenetc_free_msix(priv);\nerr_config_si:\nerr_alloc_msix:\n\tenetc_free_si_resources(priv);\nerr_alloc_si_res:\n\tenetc_teardown_cbdr(&si->cbd_ring);\nerr_setup_cbdr:\n\tsi->ndev = NULL;\n\tfree_netdev(ndev);\nerr_alloc_netdev:\n\tenetc_pci_remove(pdev);\n\n\treturn err;\n}\n\nstatic void enetc_vf_remove(struct pci_dev *pdev)\n{\n\tstruct enetc_si *si = pci_get_drvdata(pdev);\n\tstruct enetc_ndev_priv *priv;\n\n\tpriv = netdev_priv(si->ndev);\n\tunregister_netdev(si->ndev);\n\n\tenetc_free_msix(priv);\n\n\tenetc_free_si_resources(priv);\n\tenetc_teardown_cbdr(&si->cbd_ring);\n\n\tfree_netdev(si->ndev);\n\n\tenetc_pci_remove(pdev);\n}\n\nstatic const struct pci_device_id enetc_vf_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, ENETC_DEV_ID_VF) },\n\t{ 0, }  \n};\nMODULE_DEVICE_TABLE(pci, enetc_vf_id_table);\n\nstatic struct pci_driver enetc_vf_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = enetc_vf_id_table,\n\t.probe = enetc_vf_probe,\n\t.remove = enetc_vf_remove,\n};\nmodule_pci_driver(enetc_vf_driver);\n\nMODULE_DESCRIPTION(ENETC_DRV_NAME_STR);\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}