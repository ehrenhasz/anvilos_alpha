{
  "module_name": "enetc_pf.c",
  "hash_id": "5b488c293b608795067b353b385ab4615ab509cca3c40400d23c78c574a52142",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/enetc/enetc_pf.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/mdio.h>\n#include <linux/module.h>\n#include <linux/fsl/enetc_mdio.h>\n#include <linux/of_platform.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/pcs-lynx.h>\n#include \"enetc_ierb.h\"\n#include \"enetc_pf.h\"\n\n#define ENETC_DRV_NAME_STR \"ENETC PF driver\"\n\nstatic void enetc_pf_get_primary_mac_addr(struct enetc_hw *hw, int si, u8 *addr)\n{\n\tu32 upper = __raw_readl(hw->port + ENETC_PSIPMAR0(si));\n\tu16 lower = __raw_readw(hw->port + ENETC_PSIPMAR1(si));\n\n\tput_unaligned_le32(upper, addr);\n\tput_unaligned_le16(lower, addr + 4);\n}\n\nstatic void enetc_pf_set_primary_mac_addr(struct enetc_hw *hw, int si,\n\t\t\t\t\t  const u8 *addr)\n{\n\tu32 upper = get_unaligned_le32(addr);\n\tu16 lower = get_unaligned_le16(addr + 4);\n\n\t__raw_writel(upper, hw->port + ENETC_PSIPMAR0(si));\n\t__raw_writew(lower, hw->port + ENETC_PSIPMAR1(si));\n}\n\nstatic int enetc_pf_set_mac_addr(struct net_device *ndev, void *addr)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct sockaddr *saddr = addr;\n\n\tif (!is_valid_ether_addr(saddr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(ndev, saddr->sa_data);\n\tenetc_pf_set_primary_mac_addr(&priv->si->hw, 0, saddr->sa_data);\n\n\treturn 0;\n}\n\nstatic void enetc_set_vlan_promisc(struct enetc_hw *hw, char si_map)\n{\n\tu32 val = enetc_port_rd(hw, ENETC_PSIPVMR);\n\n\tval &= ~ENETC_PSIPVMR_SET_VP(ENETC_VLAN_PROMISC_MAP_ALL);\n\tenetc_port_wr(hw, ENETC_PSIPVMR, ENETC_PSIPVMR_SET_VP(si_map) | val);\n}\n\nstatic void enetc_enable_si_vlan_promisc(struct enetc_pf *pf, int si_idx)\n{\n\tpf->vlan_promisc_simap |= BIT(si_idx);\n\tenetc_set_vlan_promisc(&pf->si->hw, pf->vlan_promisc_simap);\n}\n\nstatic void enetc_disable_si_vlan_promisc(struct enetc_pf *pf, int si_idx)\n{\n\tpf->vlan_promisc_simap &= ~BIT(si_idx);\n\tenetc_set_vlan_promisc(&pf->si->hw, pf->vlan_promisc_simap);\n}\n\nstatic void enetc_set_isol_vlan(struct enetc_hw *hw, int si, u16 vlan, u8 qos)\n{\n\tu32 val = 0;\n\n\tif (vlan)\n\t\tval = ENETC_PSIVLAN_EN | ENETC_PSIVLAN_SET_QOS(qos) | vlan;\n\n\tenetc_port_wr(hw, ENETC_PSIVLANR(si), val);\n}\n\nstatic int enetc_mac_addr_hash_idx(const u8 *addr)\n{\n\tu64 fold = __swab64(ether_addr_to_u64(addr)) >> 16;\n\tu64 mask = 0;\n\tint res = 0;\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tmask |= BIT_ULL(i * 6);\n\n\tfor (i = 0; i < 6; i++)\n\t\tres |= (hweight64(fold & (mask << i)) & 0x1) << i;\n\n\treturn res;\n}\n\nstatic void enetc_reset_mac_addr_filter(struct enetc_mac_filter *filter)\n{\n\tfilter->mac_addr_cnt = 0;\n\n\tbitmap_zero(filter->mac_hash_table,\n\t\t    ENETC_MADDR_HASH_TBL_SZ);\n}\n\nstatic void enetc_add_mac_addr_em_filter(struct enetc_mac_filter *filter,\n\t\t\t\t\t const unsigned char *addr)\n{\n\t \n\tether_addr_copy(filter->mac_addr, addr);\n\tfilter->mac_addr_cnt++;\n}\n\nstatic void enetc_add_mac_addr_ht_filter(struct enetc_mac_filter *filter,\n\t\t\t\t\t const unsigned char *addr)\n{\n\tint idx = enetc_mac_addr_hash_idx(addr);\n\n\t \n\t__set_bit(idx, filter->mac_hash_table);\n\tfilter->mac_addr_cnt++;\n}\n\nstatic void enetc_clear_mac_ht_flt(struct enetc_si *si, int si_idx, int type)\n{\n\tbool err = si->errata & ENETC_ERR_UCMCSWP;\n\n\tif (type == UC) {\n\t\tenetc_port_wr(&si->hw, ENETC_PSIUMHFR0(si_idx, err), 0);\n\t\tenetc_port_wr(&si->hw, ENETC_PSIUMHFR1(si_idx), 0);\n\t} else {  \n\t\tenetc_port_wr(&si->hw, ENETC_PSIMMHFR0(si_idx, err), 0);\n\t\tenetc_port_wr(&si->hw, ENETC_PSIMMHFR1(si_idx), 0);\n\t}\n}\n\nstatic void enetc_set_mac_ht_flt(struct enetc_si *si, int si_idx, int type,\n\t\t\t\t unsigned long hash)\n{\n\tbool err = si->errata & ENETC_ERR_UCMCSWP;\n\n\tif (type == UC) {\n\t\tenetc_port_wr(&si->hw, ENETC_PSIUMHFR0(si_idx, err),\n\t\t\t      lower_32_bits(hash));\n\t\tenetc_port_wr(&si->hw, ENETC_PSIUMHFR1(si_idx),\n\t\t\t      upper_32_bits(hash));\n\t} else {  \n\t\tenetc_port_wr(&si->hw, ENETC_PSIMMHFR0(si_idx, err),\n\t\t\t      lower_32_bits(hash));\n\t\tenetc_port_wr(&si->hw, ENETC_PSIMMHFR1(si_idx),\n\t\t\t      upper_32_bits(hash));\n\t}\n}\n\nstatic void enetc_sync_mac_filters(struct enetc_pf *pf)\n{\n\tstruct enetc_mac_filter *f = pf->mac_filter;\n\tstruct enetc_si *si = pf->si;\n\tint i, pos;\n\n\tpos = EMETC_MAC_ADDR_FILT_RES;\n\n\tfor (i = 0; i < MADDR_TYPE; i++, f++) {\n\t\tbool em = (f->mac_addr_cnt == 1) && (i == UC);\n\t\tbool clear = !f->mac_addr_cnt;\n\n\t\tif (clear) {\n\t\t\tif (i == UC)\n\t\t\t\tenetc_clear_mac_flt_entry(si, pos);\n\n\t\t\tenetc_clear_mac_ht_flt(si, 0, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (em) {\n\t\t\tint err;\n\n\t\t\tenetc_clear_mac_ht_flt(si, 0, UC);\n\n\t\t\terr = enetc_set_mac_flt_entry(si, pos, f->mac_addr,\n\t\t\t\t\t\t      BIT(0));\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tdev_warn(&si->pdev->dev, \"fallback to HT filt (%d)\\n\",\n\t\t\t\t err);\n\t\t}\n\n\t\t \n\t\tif (i == UC)\n\t\t\tenetc_clear_mac_flt_entry(si, pos);\n\n\t\tenetc_set_mac_ht_flt(si, 0, i, *f->mac_hash_table);\n\t}\n}\n\nstatic void enetc_pf_set_rx_mode(struct net_device *ndev)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_pf *pf = enetc_si_priv(priv->si);\n\tstruct enetc_hw *hw = &priv->si->hw;\n\tbool uprom = false, mprom = false;\n\tstruct enetc_mac_filter *filter;\n\tstruct netdev_hw_addr *ha;\n\tu32 psipmr = 0;\n\tbool em;\n\n\tif (ndev->flags & IFF_PROMISC) {\n\t\t \n\t\tpsipmr = ENETC_PSIPMR_SET_UP(0) | ENETC_PSIPMR_SET_MP(0);\n\t\tuprom = true;\n\t\tmprom = true;\n\t} else if (ndev->flags & IFF_ALLMULTI) {\n\t\t \n\t\tpsipmr = ENETC_PSIPMR_SET_MP(0);\n\t\tmprom = true;\n\t}\n\n\t \n\tif (!uprom) {\n\t\t \n\t\tfilter = &pf->mac_filter[UC];\n\t\tenetc_reset_mac_addr_filter(filter);\n\n\t\tem = (netdev_uc_count(ndev) == 1);\n\t\tnetdev_for_each_uc_addr(ha, ndev) {\n\t\t\tif (em) {\n\t\t\t\tenetc_add_mac_addr_em_filter(filter, ha->addr);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tenetc_add_mac_addr_ht_filter(filter, ha->addr);\n\t\t}\n\t}\n\n\tif (!mprom) {\n\t\t \n\t\tfilter = &pf->mac_filter[MC];\n\t\tenetc_reset_mac_addr_filter(filter);\n\n\t\tnetdev_for_each_mc_addr(ha, ndev) {\n\t\t\tif (!is_multicast_ether_addr(ha->addr))\n\t\t\t\tcontinue;\n\n\t\t\tenetc_add_mac_addr_ht_filter(filter, ha->addr);\n\t\t}\n\t}\n\n\tif (!uprom || !mprom)\n\t\t \n\t\tenetc_sync_mac_filters(pf);\n\n\tpsipmr |= enetc_port_rd(hw, ENETC_PSIPMR) &\n\t\t  ~(ENETC_PSIPMR_SET_UP(0) | ENETC_PSIPMR_SET_MP(0));\n\tenetc_port_wr(hw, ENETC_PSIPMR, psipmr);\n}\n\nstatic void enetc_set_vlan_ht_filter(struct enetc_hw *hw, int si_idx,\n\t\t\t\t     unsigned long hash)\n{\n\tenetc_port_wr(hw, ENETC_PSIVHFR0(si_idx), lower_32_bits(hash));\n\tenetc_port_wr(hw, ENETC_PSIVHFR1(si_idx), upper_32_bits(hash));\n}\n\nstatic int enetc_vid_hash_idx(unsigned int vid)\n{\n\tint res = 0;\n\tint i;\n\n\tfor (i = 0; i < 6; i++)\n\t\tres |= (hweight8(vid & (BIT(i) | BIT(i + 6))) & 0x1) << i;\n\n\treturn res;\n}\n\nstatic void enetc_sync_vlan_ht_filter(struct enetc_pf *pf, bool rehash)\n{\n\tint i;\n\n\tif (rehash) {\n\t\tbitmap_zero(pf->vlan_ht_filter, ENETC_VLAN_HT_SIZE);\n\n\t\tfor_each_set_bit(i, pf->active_vlans, VLAN_N_VID) {\n\t\t\tint hidx = enetc_vid_hash_idx(i);\n\n\t\t\t__set_bit(hidx, pf->vlan_ht_filter);\n\t\t}\n\t}\n\n\tenetc_set_vlan_ht_filter(&pf->si->hw, 0, *pf->vlan_ht_filter);\n}\n\nstatic int enetc_vlan_rx_add_vid(struct net_device *ndev, __be16 prot, u16 vid)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_pf *pf = enetc_si_priv(priv->si);\n\tint idx;\n\n\t__set_bit(vid, pf->active_vlans);\n\n\tidx = enetc_vid_hash_idx(vid);\n\tif (!__test_and_set_bit(idx, pf->vlan_ht_filter))\n\t\tenetc_sync_vlan_ht_filter(pf, false);\n\n\treturn 0;\n}\n\nstatic int enetc_vlan_rx_del_vid(struct net_device *ndev, __be16 prot, u16 vid)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_pf *pf = enetc_si_priv(priv->si);\n\n\t__clear_bit(vid, pf->active_vlans);\n\tenetc_sync_vlan_ht_filter(pf, true);\n\n\treturn 0;\n}\n\nstatic void enetc_set_loopback(struct net_device *ndev, bool en)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_si *si = priv->si;\n\tu32 reg;\n\n\treg = enetc_port_mac_rd(si, ENETC_PM0_IF_MODE);\n\tif (reg & ENETC_PM0_IFM_RG) {\n\t\t \n\t\treg = (reg & ~ENETC_PM0_IFM_RLP) |\n\t\t      (en ? ENETC_PM0_IFM_RLP : 0);\n\t\tenetc_port_mac_wr(si, ENETC_PM0_IF_MODE, reg);\n\t} else {\n\t\t \n\t\treg = enetc_port_mac_rd(si, ENETC_PM0_CMD_CFG);\n\t\treg = (reg & ~ENETC_PM0_CMD_XGLP) |\n\t\t      (en ? ENETC_PM0_CMD_XGLP : 0);\n\t\treg = (reg & ~ENETC_PM0_CMD_PHY_TX_EN) |\n\t\t      (en ? ENETC_PM0_CMD_PHY_TX_EN : 0);\n\t\tenetc_port_mac_wr(si, ENETC_PM0_CMD_CFG, reg);\n\t}\n}\n\nstatic int enetc_pf_set_vf_mac(struct net_device *ndev, int vf, u8 *mac)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_pf *pf = enetc_si_priv(priv->si);\n\tstruct enetc_vf_state *vf_state;\n\n\tif (vf >= pf->total_vfs)\n\t\treturn -EINVAL;\n\n\tif (!is_valid_ether_addr(mac))\n\t\treturn -EADDRNOTAVAIL;\n\n\tvf_state = &pf->vf_state[vf];\n\tvf_state->flags |= ENETC_VF_FLAG_PF_SET_MAC;\n\tenetc_pf_set_primary_mac_addr(&priv->si->hw, vf + 1, mac);\n\treturn 0;\n}\n\nstatic int enetc_pf_set_vf_vlan(struct net_device *ndev, int vf, u16 vlan,\n\t\t\t\tu8 qos, __be16 proto)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_pf *pf = enetc_si_priv(priv->si);\n\n\tif (priv->si->errata & ENETC_ERR_VLAN_ISOL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (vf >= pf->total_vfs)\n\t\treturn -EINVAL;\n\n\tif (proto != htons(ETH_P_8021Q))\n\t\t \n\t\treturn -EPROTONOSUPPORT;\n\n\tenetc_set_isol_vlan(&priv->si->hw, vf + 1, vlan, qos);\n\treturn 0;\n}\n\nstatic int enetc_pf_set_vf_spoofchk(struct net_device *ndev, int vf, bool en)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tstruct enetc_pf *pf = enetc_si_priv(priv->si);\n\tu32 cfgr;\n\n\tif (vf >= pf->total_vfs)\n\t\treturn -EINVAL;\n\n\tcfgr = enetc_port_rd(&priv->si->hw, ENETC_PSICFGR0(vf + 1));\n\tcfgr = (cfgr & ~ENETC_PSICFGR0_ASE) | (en ? ENETC_PSICFGR0_ASE : 0);\n\tenetc_port_wr(&priv->si->hw, ENETC_PSICFGR0(vf + 1), cfgr);\n\n\treturn 0;\n}\n\nstatic int enetc_setup_mac_address(struct device_node *np, struct enetc_pf *pf,\n\t\t\t\t   int si)\n{\n\tstruct device *dev = &pf->si->pdev->dev;\n\tstruct enetc_hw *hw = &pf->si->hw;\n\tu8 mac_addr[ETH_ALEN] = { 0 };\n\tint err;\n\n\t \n\tif (np) {\n\t\terr = of_get_mac_address(np, mac_addr);\n\t\tif (err == -EPROBE_DEFER)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (is_zero_ether_addr(mac_addr))\n\t\tenetc_pf_get_primary_mac_addr(hw, si, mac_addr);\n\n\t \n\tif (is_zero_ether_addr(mac_addr)) {\n\t\teth_random_addr(mac_addr);\n\t\tdev_info(dev, \"no MAC address specified for SI%d, using %pM\\n\",\n\t\t\t si, mac_addr);\n\t}\n\n\tenetc_pf_set_primary_mac_addr(hw, si, mac_addr);\n\n\treturn 0;\n}\n\nstatic int enetc_setup_mac_addresses(struct device_node *np,\n\t\t\t\t     struct enetc_pf *pf)\n{\n\tint err, i;\n\n\t \n\terr = enetc_setup_mac_address(np, pf, 0);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < pf->total_vfs; i++) {\n\t\terr = enetc_setup_mac_address(NULL, pf, i + 1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void enetc_port_assign_rfs_entries(struct enetc_si *si)\n{\n\tstruct enetc_pf *pf = enetc_si_priv(si);\n\tstruct enetc_hw *hw = &si->hw;\n\tint num_entries, vf_entries, i;\n\tu32 val;\n\n\t \n\tval = enetc_port_rd(hw, ENETC_PRFSCAPR);\n\tnum_entries = ENETC_PRFSCAPR_GET_NUM_RFS(val);\n\tvf_entries = num_entries / (pf->total_vfs + 1);\n\n\tfor (i = 0; i < pf->total_vfs; i++)\n\t\tenetc_port_wr(hw, ENETC_PSIRFSCFGR(i + 1), vf_entries);\n\tenetc_port_wr(hw, ENETC_PSIRFSCFGR(0),\n\t\t      num_entries - vf_entries * pf->total_vfs);\n\n\t \n\tenetc_port_wr(hw, ENETC_PRFSMR, ENETC_PRFSMR_RFSE);\n}\n\nstatic void enetc_port_si_configure(struct enetc_si *si)\n{\n\tstruct enetc_pf *pf = enetc_si_priv(si);\n\tstruct enetc_hw *hw = &si->hw;\n\tint num_rings, i;\n\tu32 val;\n\n\tval = enetc_port_rd(hw, ENETC_PCAPR0);\n\tnum_rings = min(ENETC_PCAPR0_RXBDR(val), ENETC_PCAPR0_TXBDR(val));\n\n\tval = ENETC_PSICFGR0_SET_TXBDR(ENETC_PF_NUM_RINGS);\n\tval |= ENETC_PSICFGR0_SET_RXBDR(ENETC_PF_NUM_RINGS);\n\n\tif (unlikely(num_rings < ENETC_PF_NUM_RINGS)) {\n\t\tval = ENETC_PSICFGR0_SET_TXBDR(num_rings);\n\t\tval |= ENETC_PSICFGR0_SET_RXBDR(num_rings);\n\n\t\tdev_warn(&si->pdev->dev, \"Found %d rings, expected %d!\\n\",\n\t\t\t num_rings, ENETC_PF_NUM_RINGS);\n\n\t\tnum_rings = 0;\n\t}\n\n\t \n\tval |= ENETC_PSICFGR0_SIVC(ENETC_VLAN_TYPE_C | ENETC_VLAN_TYPE_S);\n\n\tenetc_port_wr(hw, ENETC_PSICFGR0(0), val);\n\n\tif (num_rings)\n\t\tnum_rings -= ENETC_PF_NUM_RINGS;\n\n\t \n\tval = ENETC_PSICFGR0_SIVC(ENETC_VLAN_TYPE_C | ENETC_VLAN_TYPE_S);\n\tval |= ENETC_PSICFGR0_VTE | ENETC_PSICFGR0_SIVIE;\n\n\tif (num_rings) {\n\t\tnum_rings /= pf->total_vfs;\n\t\tval |= ENETC_PSICFGR0_SET_TXBDR(num_rings);\n\t\tval |= ENETC_PSICFGR0_SET_RXBDR(num_rings);\n\t}\n\n\tfor (i = 0; i < pf->total_vfs; i++)\n\t\tenetc_port_wr(hw, ENETC_PSICFGR0(i + 1), val);\n\n\t \n\tval = ENETC_PVCLCTR_OVTPIDL(ENETC_VLAN_TYPE_C | ENETC_VLAN_TYPE_S);\n\tenetc_port_wr(hw, ENETC_PVCLCTR, val);\n\t \n\tenetc_port_wr(hw, ENETC_PSIVLANFMR, ENETC_PSIVLANFMR_VS);\n}\n\nvoid enetc_set_ptcmsdur(struct enetc_hw *hw, u32 *max_sdu)\n{\n\tint tc;\n\n\tfor (tc = 0; tc < 8; tc++) {\n\t\tu32 val = ENETC_MAC_MAXFRM_SIZE;\n\n\t\tif (max_sdu[tc])\n\t\t\tval = max_sdu[tc] + VLAN_ETH_HLEN;\n\n\t\tenetc_port_wr(hw, ENETC_PTCMSDUR(tc), val);\n\t}\n}\n\nvoid enetc_reset_ptcmsdur(struct enetc_hw *hw)\n{\n\tint tc;\n\n\tfor (tc = 0; tc < 8; tc++)\n\t\tenetc_port_wr(hw, ENETC_PTCMSDUR(tc), ENETC_MAC_MAXFRM_SIZE);\n}\n\nstatic void enetc_configure_port_mac(struct enetc_si *si)\n{\n\tstruct enetc_hw *hw = &si->hw;\n\n\tenetc_port_mac_wr(si, ENETC_PM0_MAXFRM,\n\t\t\t  ENETC_SET_MAXFRM(ENETC_RX_MAXFRM_SIZE));\n\n\tenetc_reset_ptcmsdur(hw);\n\n\tenetc_port_mac_wr(si, ENETC_PM0_CMD_CFG, ENETC_PM0_CMD_PHY_TX_EN |\n\t\t\t  ENETC_PM0_CMD_TXP | ENETC_PM0_PROMISC);\n\n\t \n\tenetc_port_mac_wr(si, ENETC_PM0_RX_FIFO, ENETC_PM0_RX_FIFO_VAL);\n}\n\nstatic void enetc_mac_config(struct enetc_si *si, phy_interface_t phy_mode)\n{\n\tu32 val;\n\n\tif (phy_interface_mode_is_rgmii(phy_mode)) {\n\t\tval = enetc_port_mac_rd(si, ENETC_PM0_IF_MODE);\n\t\tval &= ~(ENETC_PM0_IFM_EN_AUTO | ENETC_PM0_IFM_IFMODE_MASK);\n\t\tval |= ENETC_PM0_IFM_IFMODE_GMII | ENETC_PM0_IFM_RG;\n\t\tenetc_port_mac_wr(si, ENETC_PM0_IF_MODE, val);\n\t}\n\n\tif (phy_mode == PHY_INTERFACE_MODE_USXGMII) {\n\t\tval = ENETC_PM0_IFM_FULL_DPX | ENETC_PM0_IFM_IFMODE_XGMII;\n\t\tenetc_port_mac_wr(si, ENETC_PM0_IF_MODE, val);\n\t}\n}\n\nstatic void enetc_mac_enable(struct enetc_si *si, bool en)\n{\n\tu32 val = enetc_port_mac_rd(si, ENETC_PM0_CMD_CFG);\n\n\tval &= ~(ENETC_PM0_TX_EN | ENETC_PM0_RX_EN);\n\tval |= en ? (ENETC_PM0_TX_EN | ENETC_PM0_RX_EN) : 0;\n\n\tenetc_port_mac_wr(si, ENETC_PM0_CMD_CFG, val);\n}\n\nstatic void enetc_configure_port(struct enetc_pf *pf)\n{\n\tu8 hash_key[ENETC_RSSHASH_KEY_SIZE];\n\tstruct enetc_hw *hw = &pf->si->hw;\n\n\tenetc_configure_port_mac(pf->si);\n\n\tenetc_port_si_configure(pf->si);\n\n\t \n\tget_random_bytes(hash_key, ENETC_RSSHASH_KEY_SIZE);\n\tenetc_set_rss_key(hw, hash_key);\n\n\t \n\tenetc_port_assign_rfs_entries(pf->si);\n\n\t \n\tpf->vlan_promisc_simap = ENETC_VLAN_PROMISC_MAP_ALL;\n\tenetc_set_vlan_promisc(hw, pf->vlan_promisc_simap);\n\n\tenetc_port_wr(hw, ENETC_PSIPMR, 0);\n\n\t \n\tenetc_port_wr(hw, ENETC_PMR, ENETC_PMR_EN);\n}\n\n \nstatic u16 enetc_msg_pf_set_vf_primary_mac_addr(struct enetc_pf *pf,\n\t\t\t\t\t\tint vf_id)\n{\n\tstruct enetc_vf_state *vf_state = &pf->vf_state[vf_id];\n\tstruct enetc_msg_swbd *msg = &pf->rxmsg[vf_id];\n\tstruct enetc_msg_cmd_set_primary_mac *cmd;\n\tstruct device *dev = &pf->si->pdev->dev;\n\tu16 cmd_id;\n\tchar *addr;\n\n\tcmd = (struct enetc_msg_cmd_set_primary_mac *)msg->vaddr;\n\tcmd_id = cmd->header.id;\n\tif (cmd_id != ENETC_MSG_CMD_MNG_ADD)\n\t\treturn ENETC_MSG_CMD_STATUS_FAIL;\n\n\taddr = cmd->mac.sa_data;\n\tif (vf_state->flags & ENETC_VF_FLAG_PF_SET_MAC)\n\t\tdev_warn(dev, \"Attempt to override PF set mac addr for VF%d\\n\",\n\t\t\t vf_id);\n\telse\n\t\tenetc_pf_set_primary_mac_addr(&pf->si->hw, vf_id + 1, addr);\n\n\treturn ENETC_MSG_CMD_STATUS_OK;\n}\n\nvoid enetc_msg_handle_rxmsg(struct enetc_pf *pf, int vf_id, u16 *status)\n{\n\tstruct enetc_msg_swbd *msg = &pf->rxmsg[vf_id];\n\tstruct device *dev = &pf->si->pdev->dev;\n\tstruct enetc_msg_cmd_header *cmd_hdr;\n\tu16 cmd_type;\n\n\t*status = ENETC_MSG_CMD_STATUS_OK;\n\tcmd_hdr = (struct enetc_msg_cmd_header *)msg->vaddr;\n\tcmd_type = cmd_hdr->type;\n\n\tswitch (cmd_type) {\n\tcase ENETC_MSG_CMD_MNG_MAC:\n\t\t*status = enetc_msg_pf_set_vf_primary_mac_addr(pf, vf_id);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"command not supported (cmd_type: 0x%x)\\n\",\n\t\t\tcmd_type);\n\t}\n}\n\n#ifdef CONFIG_PCI_IOV\nstatic int enetc_sriov_configure(struct pci_dev *pdev, int num_vfs)\n{\n\tstruct enetc_si *si = pci_get_drvdata(pdev);\n\tstruct enetc_pf *pf = enetc_si_priv(si);\n\tint err;\n\n\tif (!num_vfs) {\n\t\tenetc_msg_psi_free(pf);\n\t\tkfree(pf->vf_state);\n\t\tpf->num_vfs = 0;\n\t\tpci_disable_sriov(pdev);\n\t} else {\n\t\tpf->num_vfs = num_vfs;\n\n\t\tpf->vf_state = kcalloc(num_vfs, sizeof(struct enetc_vf_state),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!pf->vf_state) {\n\t\t\tpf->num_vfs = 0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terr = enetc_msg_psi_init(pf);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"enetc_msg_psi_init (%d)\\n\", err);\n\t\t\tgoto err_msg_psi;\n\t\t}\n\n\t\terr = pci_enable_sriov(pdev, num_vfs);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"pci_enable_sriov err %d\\n\", err);\n\t\t\tgoto err_en_sriov;\n\t\t}\n\t}\n\n\treturn num_vfs;\n\nerr_en_sriov:\n\tenetc_msg_psi_free(pf);\nerr_msg_psi:\n\tkfree(pf->vf_state);\n\tpf->num_vfs = 0;\n\n\treturn err;\n}\n#else\n#define enetc_sriov_configure(pdev, num_vfs)\t(void)0\n#endif\n\nstatic int enetc_pf_set_features(struct net_device *ndev,\n\t\t\t\t netdev_features_t features)\n{\n\tnetdev_features_t changed = ndev->features ^ features;\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\tint err;\n\n\tif (changed & NETIF_F_HW_TC) {\n\t\terr = enetc_set_psfp(ndev, !!(features & NETIF_F_HW_TC));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_FILTER) {\n\t\tstruct enetc_pf *pf = enetc_si_priv(priv->si);\n\n\t\tif (!!(features & NETIF_F_HW_VLAN_CTAG_FILTER))\n\t\t\tenetc_disable_si_vlan_promisc(pf, 0);\n\t\telse\n\t\t\tenetc_enable_si_vlan_promisc(pf, 0);\n\t}\n\n\tif (changed & NETIF_F_LOOPBACK)\n\t\tenetc_set_loopback(ndev, !!(features & NETIF_F_LOOPBACK));\n\n\tenetc_set_features(ndev, features);\n\n\treturn 0;\n}\n\nstatic int enetc_pf_setup_tc(struct net_device *ndev, enum tc_setup_type type,\n\t\t\t     void *type_data)\n{\n\tswitch (type) {\n\tcase TC_QUERY_CAPS:\n\t\treturn enetc_qos_query_caps(ndev, type_data);\n\tcase TC_SETUP_QDISC_MQPRIO:\n\t\treturn enetc_setup_tc_mqprio(ndev, type_data);\n\tcase TC_SETUP_QDISC_TAPRIO:\n\t\treturn enetc_setup_tc_taprio(ndev, type_data);\n\tcase TC_SETUP_QDISC_CBS:\n\t\treturn enetc_setup_tc_cbs(ndev, type_data);\n\tcase TC_SETUP_QDISC_ETF:\n\t\treturn enetc_setup_tc_txtime(ndev, type_data);\n\tcase TC_SETUP_BLOCK:\n\t\treturn enetc_setup_tc_psfp(ndev, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct net_device_ops enetc_ndev_ops = {\n\t.ndo_open\t\t= enetc_open,\n\t.ndo_stop\t\t= enetc_close,\n\t.ndo_start_xmit\t\t= enetc_xmit,\n\t.ndo_get_stats\t\t= enetc_get_stats,\n\t.ndo_set_mac_address\t= enetc_pf_set_mac_addr,\n\t.ndo_set_rx_mode\t= enetc_pf_set_rx_mode,\n\t.ndo_vlan_rx_add_vid\t= enetc_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= enetc_vlan_rx_del_vid,\n\t.ndo_set_vf_mac\t\t= enetc_pf_set_vf_mac,\n\t.ndo_set_vf_vlan\t= enetc_pf_set_vf_vlan,\n\t.ndo_set_vf_spoofchk\t= enetc_pf_set_vf_spoofchk,\n\t.ndo_set_features\t= enetc_pf_set_features,\n\t.ndo_eth_ioctl\t\t= enetc_ioctl,\n\t.ndo_setup_tc\t\t= enetc_pf_setup_tc,\n\t.ndo_bpf\t\t= enetc_setup_bpf,\n\t.ndo_xdp_xmit\t\t= enetc_xdp_xmit,\n};\n\nstatic void enetc_pf_netdev_setup(struct enetc_si *si, struct net_device *ndev,\n\t\t\t\t  const struct net_device_ops *ndev_ops)\n{\n\tstruct enetc_ndev_priv *priv = netdev_priv(ndev);\n\n\tSET_NETDEV_DEV(ndev, &si->pdev->dev);\n\tpriv->ndev = ndev;\n\tpriv->si = si;\n\tpriv->dev = &si->pdev->dev;\n\tsi->ndev = ndev;\n\n\tpriv->msg_enable = (NETIF_MSG_WOL << 1) - 1;\n\tndev->netdev_ops = ndev_ops;\n\tenetc_set_ethtool_ops(ndev);\n\tndev->watchdog_timeo = 5 * HZ;\n\tndev->max_mtu = ENETC_MAX_MTU;\n\n\tndev->hw_features = NETIF_F_SG | NETIF_F_RXCSUM |\n\t\t\t    NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t    NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_LOOPBACK |\n\t\t\t    NETIF_F_HW_CSUM | NETIF_F_TSO | NETIF_F_TSO6;\n\tndev->features = NETIF_F_HIGHDMA | NETIF_F_SG | NETIF_F_RXCSUM |\n\t\t\t NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t NETIF_F_HW_CSUM | NETIF_F_TSO | NETIF_F_TSO6;\n\tndev->vlan_features = NETIF_F_SG | NETIF_F_HW_CSUM |\n\t\t\t      NETIF_F_TSO | NETIF_F_TSO6;\n\n\tif (si->num_rss)\n\t\tndev->hw_features |= NETIF_F_RXHASH;\n\n\tndev->priv_flags |= IFF_UNICAST_FLT;\n\tndev->xdp_features = NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT |\n\t\t\t     NETDEV_XDP_ACT_NDO_XMIT | NETDEV_XDP_ACT_RX_SG |\n\t\t\t     NETDEV_XDP_ACT_NDO_XMIT_SG;\n\n\tif (si->hw_features & ENETC_SI_F_PSFP && !enetc_psfp_enable(priv)) {\n\t\tpriv->active_offloads |= ENETC_F_QCI;\n\t\tndev->features |= NETIF_F_HW_TC;\n\t\tndev->hw_features |= NETIF_F_HW_TC;\n\t}\n\n\t \n\tenetc_load_primary_mac_addr(&si->hw, ndev);\n}\n\nstatic int enetc_mdio_probe(struct enetc_pf *pf, struct device_node *np)\n{\n\tstruct device *dev = &pf->si->pdev->dev;\n\tstruct enetc_mdio_priv *mdio_priv;\n\tstruct mii_bus *bus;\n\tint err;\n\n\tbus = devm_mdiobus_alloc_size(dev, sizeof(*mdio_priv));\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->name = \"Freescale ENETC MDIO Bus\";\n\tbus->read = enetc_mdio_read_c22;\n\tbus->write = enetc_mdio_write_c22;\n\tbus->read_c45 = enetc_mdio_read_c45;\n\tbus->write_c45 = enetc_mdio_write_c45;\n\tbus->parent = dev;\n\tmdio_priv = bus->priv;\n\tmdio_priv->hw = &pf->si->hw;\n\tmdio_priv->mdio_base = ENETC_EMDIO_BASE;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s\", dev_name(dev));\n\n\terr = of_mdiobus_register(bus, np);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"cannot register MDIO bus\\n\");\n\n\tpf->mdio = bus;\n\n\treturn 0;\n}\n\nstatic void enetc_mdio_remove(struct enetc_pf *pf)\n{\n\tif (pf->mdio)\n\t\tmdiobus_unregister(pf->mdio);\n}\n\nstatic int enetc_imdio_create(struct enetc_pf *pf)\n{\n\tstruct device *dev = &pf->si->pdev->dev;\n\tstruct enetc_mdio_priv *mdio_priv;\n\tstruct phylink_pcs *phylink_pcs;\n\tstruct mii_bus *bus;\n\tint err;\n\n\tbus = mdiobus_alloc_size(sizeof(*mdio_priv));\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->name = \"Freescale ENETC internal MDIO Bus\";\n\tbus->read = enetc_mdio_read_c22;\n\tbus->write = enetc_mdio_write_c22;\n\tbus->read_c45 = enetc_mdio_read_c45;\n\tbus->write_c45 = enetc_mdio_write_c45;\n\tbus->parent = dev;\n\tbus->phy_mask = ~0;\n\tmdio_priv = bus->priv;\n\tmdio_priv->hw = &pf->si->hw;\n\tmdio_priv->mdio_base = ENETC_PM_IMDIO_BASE;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-imdio\", dev_name(dev));\n\n\terr = mdiobus_register(bus);\n\tif (err) {\n\t\tdev_err(dev, \"cannot register internal MDIO bus (%d)\\n\", err);\n\t\tgoto free_mdio_bus;\n\t}\n\n\tphylink_pcs = lynx_pcs_create_mdiodev(bus, 0);\n\tif (IS_ERR(phylink_pcs)) {\n\t\terr = PTR_ERR(phylink_pcs);\n\t\tdev_err(dev, \"cannot create lynx pcs (%d)\\n\", err);\n\t\tgoto unregister_mdiobus;\n\t}\n\n\tpf->imdio = bus;\n\tpf->pcs = phylink_pcs;\n\n\treturn 0;\n\nunregister_mdiobus:\n\tmdiobus_unregister(bus);\nfree_mdio_bus:\n\tmdiobus_free(bus);\n\treturn err;\n}\n\nstatic void enetc_imdio_remove(struct enetc_pf *pf)\n{\n\tif (pf->pcs)\n\t\tlynx_pcs_destroy(pf->pcs);\n\tif (pf->imdio) {\n\t\tmdiobus_unregister(pf->imdio);\n\t\tmdiobus_free(pf->imdio);\n\t}\n}\n\nstatic bool enetc_port_has_pcs(struct enetc_pf *pf)\n{\n\treturn (pf->if_mode == PHY_INTERFACE_MODE_SGMII ||\n\t\tpf->if_mode == PHY_INTERFACE_MODE_2500BASEX ||\n\t\tpf->if_mode == PHY_INTERFACE_MODE_USXGMII);\n}\n\nstatic int enetc_mdiobus_create(struct enetc_pf *pf, struct device_node *node)\n{\n\tstruct device_node *mdio_np;\n\tint err;\n\n\tmdio_np = of_get_child_by_name(node, \"mdio\");\n\tif (mdio_np) {\n\t\terr = enetc_mdio_probe(pf, mdio_np);\n\n\t\tof_node_put(mdio_np);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (enetc_port_has_pcs(pf)) {\n\t\terr = enetc_imdio_create(pf);\n\t\tif (err) {\n\t\t\tenetc_mdio_remove(pf);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void enetc_mdiobus_destroy(struct enetc_pf *pf)\n{\n\tenetc_mdio_remove(pf);\n\tenetc_imdio_remove(pf);\n}\n\nstatic struct phylink_pcs *\nenetc_pl_mac_select_pcs(struct phylink_config *config, phy_interface_t iface)\n{\n\tstruct enetc_pf *pf = phylink_to_enetc_pf(config);\n\n\treturn pf->pcs;\n}\n\nstatic void enetc_pl_mac_config(struct phylink_config *config,\n\t\t\t\tunsigned int mode,\n\t\t\t\tconst struct phylink_link_state *state)\n{\n\tstruct enetc_pf *pf = phylink_to_enetc_pf(config);\n\n\tenetc_mac_config(pf->si, state->interface);\n}\n\nstatic void enetc_force_rgmii_mac(struct enetc_si *si, int speed, int duplex)\n{\n\tu32 old_val, val;\n\n\told_val = val = enetc_port_mac_rd(si, ENETC_PM0_IF_MODE);\n\n\tif (speed == SPEED_1000) {\n\t\tval &= ~ENETC_PM0_IFM_SSP_MASK;\n\t\tval |= ENETC_PM0_IFM_SSP_1000;\n\t} else if (speed == SPEED_100) {\n\t\tval &= ~ENETC_PM0_IFM_SSP_MASK;\n\t\tval |= ENETC_PM0_IFM_SSP_100;\n\t} else if (speed == SPEED_10) {\n\t\tval &= ~ENETC_PM0_IFM_SSP_MASK;\n\t\tval |= ENETC_PM0_IFM_SSP_10;\n\t}\n\n\tif (duplex == DUPLEX_FULL)\n\t\tval |= ENETC_PM0_IFM_FULL_DPX;\n\telse\n\t\tval &= ~ENETC_PM0_IFM_FULL_DPX;\n\n\tif (val == old_val)\n\t\treturn;\n\n\tenetc_port_mac_wr(si, ENETC_PM0_IF_MODE, val);\n}\n\nstatic void enetc_pl_mac_link_up(struct phylink_config *config,\n\t\t\t\t struct phy_device *phy, unsigned int mode,\n\t\t\t\t phy_interface_t interface, int speed,\n\t\t\t\t int duplex, bool tx_pause, bool rx_pause)\n{\n\tstruct enetc_pf *pf = phylink_to_enetc_pf(config);\n\tu32 pause_off_thresh = 0, pause_on_thresh = 0;\n\tu32 init_quanta = 0, refresh_quanta = 0;\n\tstruct enetc_hw *hw = &pf->si->hw;\n\tstruct enetc_si *si = pf->si;\n\tstruct enetc_ndev_priv *priv;\n\tu32 rbmr, cmd_cfg;\n\tint idx;\n\n\tpriv = netdev_priv(pf->si->ndev);\n\n\tif (pf->si->hw_features & ENETC_SI_F_QBV)\n\t\tenetc_sched_speed_set(priv, speed);\n\n\tif (!phylink_autoneg_inband(mode) &&\n\t    phy_interface_mode_is_rgmii(interface))\n\t\tenetc_force_rgmii_mac(si, speed, duplex);\n\n\t \n\tfor (idx = 0; idx < priv->num_rx_rings; idx++) {\n\t\trbmr = enetc_rxbdr_rd(hw, idx, ENETC_RBMR);\n\n\t\tif (tx_pause)\n\t\t\trbmr |= ENETC_RBMR_CM;\n\t\telse\n\t\t\trbmr &= ~ENETC_RBMR_CM;\n\n\t\tenetc_rxbdr_wr(hw, idx, ENETC_RBMR, rbmr);\n\t}\n\n\tif (tx_pause) {\n\t\t \n\t\tinit_quanta = 0xffff;\n\n\t\t \n\t\trefresh_quanta = 0xffff / 2;\n\n\t\t \n\t\tpause_on_thresh = 3 * ENETC_MAC_MAXFRM_SIZE;\n\t\tpause_off_thresh = 1 * ENETC_MAC_MAXFRM_SIZE;\n\t}\n\n\tenetc_port_mac_wr(si, ENETC_PM0_PAUSE_QUANTA, init_quanta);\n\tenetc_port_mac_wr(si, ENETC_PM0_PAUSE_THRESH, refresh_quanta);\n\tenetc_port_wr(hw, ENETC_PPAUONTR, pause_on_thresh);\n\tenetc_port_wr(hw, ENETC_PPAUOFFTR, pause_off_thresh);\n\n\tcmd_cfg = enetc_port_mac_rd(si, ENETC_PM0_CMD_CFG);\n\n\tif (rx_pause)\n\t\tcmd_cfg &= ~ENETC_PM0_PAUSE_IGN;\n\telse\n\t\tcmd_cfg |= ENETC_PM0_PAUSE_IGN;\n\n\tenetc_port_mac_wr(si, ENETC_PM0_CMD_CFG, cmd_cfg);\n\n\tenetc_mac_enable(si, true);\n\n\tif (si->hw_features & ENETC_SI_F_QBU)\n\t\tenetc_mm_link_state_update(priv, true);\n}\n\nstatic void enetc_pl_mac_link_down(struct phylink_config *config,\n\t\t\t\t   unsigned int mode,\n\t\t\t\t   phy_interface_t interface)\n{\n\tstruct enetc_pf *pf = phylink_to_enetc_pf(config);\n\tstruct enetc_si *si = pf->si;\n\tstruct enetc_ndev_priv *priv;\n\n\tpriv = netdev_priv(si->ndev);\n\n\tif (si->hw_features & ENETC_SI_F_QBU)\n\t\tenetc_mm_link_state_update(priv, false);\n\n\tenetc_mac_enable(si, false);\n}\n\nstatic const struct phylink_mac_ops enetc_mac_phylink_ops = {\n\t.mac_select_pcs = enetc_pl_mac_select_pcs,\n\t.mac_config = enetc_pl_mac_config,\n\t.mac_link_up = enetc_pl_mac_link_up,\n\t.mac_link_down = enetc_pl_mac_link_down,\n};\n\nstatic int enetc_phylink_create(struct enetc_ndev_priv *priv,\n\t\t\t\tstruct device_node *node)\n{\n\tstruct enetc_pf *pf = enetc_si_priv(priv->si);\n\tstruct phylink *phylink;\n\tint err;\n\n\tpf->phylink_config.dev = &priv->ndev->dev;\n\tpf->phylink_config.type = PHYLINK_NETDEV;\n\tpf->phylink_config.mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |\n\t\tMAC_10 | MAC_100 | MAC_1000 | MAC_2500FD;\n\n\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t  pf->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_SGMII,\n\t\t  pf->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_2500BASEX,\n\t\t  pf->phylink_config.supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_USXGMII,\n\t\t  pf->phylink_config.supported_interfaces);\n\tphy_interface_set_rgmii(pf->phylink_config.supported_interfaces);\n\n\tphylink = phylink_create(&pf->phylink_config, of_fwnode_handle(node),\n\t\t\t\t pf->if_mode, &enetc_mac_phylink_ops);\n\tif (IS_ERR(phylink)) {\n\t\terr = PTR_ERR(phylink);\n\t\treturn err;\n\t}\n\n\tpriv->phylink = phylink;\n\n\treturn 0;\n}\n\nstatic void enetc_phylink_destroy(struct enetc_ndev_priv *priv)\n{\n\tphylink_destroy(priv->phylink);\n}\n\n \nstatic int enetc_init_port_rfs_memory(struct enetc_si *si)\n{\n\tstruct enetc_cmd_rfse rfse = {0};\n\tstruct enetc_hw *hw = &si->hw;\n\tint num_rfs, i, err = 0;\n\tu32 val;\n\n\tval = enetc_port_rd(hw, ENETC_PRFSCAPR);\n\tnum_rfs = ENETC_PRFSCAPR_GET_NUM_RFS(val);\n\n\tfor (i = 0; i < num_rfs; i++) {\n\t\terr = enetc_set_fs_entry(si, &rfse, i);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int enetc_init_port_rss_memory(struct enetc_si *si)\n{\n\tstruct enetc_hw *hw = &si->hw;\n\tint num_rss, err;\n\tint *rss_table;\n\tu32 val;\n\n\tval = enetc_port_rd(hw, ENETC_PRSSCAPR);\n\tnum_rss = ENETC_PRSSCAPR_GET_NUM_RSS(val);\n\tif (!num_rss)\n\t\treturn 0;\n\n\trss_table = kcalloc(num_rss, sizeof(*rss_table), GFP_KERNEL);\n\tif (!rss_table)\n\t\treturn -ENOMEM;\n\n\terr = enetc_set_rss_table(si, rss_table, num_rss);\n\n\tkfree(rss_table);\n\n\treturn err;\n}\n\nstatic int enetc_pf_register_with_ierb(struct pci_dev *pdev)\n{\n\tstruct platform_device *ierb_pdev;\n\tstruct device_node *ierb_node;\n\n\tierb_node = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t    \"fsl,ls1028a-enetc-ierb\");\n\tif (!ierb_node || !of_device_is_available(ierb_node))\n\t\treturn -ENODEV;\n\n\tierb_pdev = of_find_device_by_node(ierb_node);\n\tof_node_put(ierb_node);\n\n\tif (!ierb_pdev)\n\t\treturn -EPROBE_DEFER;\n\n\treturn enetc_ierb_register_pf(ierb_pdev, pdev);\n}\n\nstatic struct enetc_si *enetc_psi_create(struct pci_dev *pdev)\n{\n\tstruct enetc_si *si;\n\tint err;\n\n\terr = enetc_pci_probe(pdev, KBUILD_MODNAME, sizeof(struct enetc_pf));\n\tif (err) {\n\t\tdev_err_probe(&pdev->dev, err, \"PCI probing failed\\n\");\n\t\tgoto out;\n\t}\n\n\tsi = pci_get_drvdata(pdev);\n\tif (!si->hw.port || !si->hw.global) {\n\t\terr = -ENODEV;\n\t\tdev_err(&pdev->dev, \"could not map PF space, probing a VF?\\n\");\n\t\tgoto out_pci_remove;\n\t}\n\n\terr = enetc_setup_cbdr(&pdev->dev, &si->hw, ENETC_CBDR_DEFAULT_SIZE,\n\t\t\t       &si->cbd_ring);\n\tif (err)\n\t\tgoto out_pci_remove;\n\n\terr = enetc_init_port_rfs_memory(si);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize RFS memory\\n\");\n\t\tgoto out_teardown_cbdr;\n\t}\n\n\terr = enetc_init_port_rss_memory(si);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize RSS memory\\n\");\n\t\tgoto out_teardown_cbdr;\n\t}\n\n\treturn si;\n\nout_teardown_cbdr:\n\tenetc_teardown_cbdr(&si->cbd_ring);\nout_pci_remove:\n\tenetc_pci_remove(pdev);\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic void enetc_psi_destroy(struct pci_dev *pdev)\n{\n\tstruct enetc_si *si = pci_get_drvdata(pdev);\n\n\tenetc_teardown_cbdr(&si->cbd_ring);\n\tenetc_pci_remove(pdev);\n}\n\nstatic int enetc_pf_probe(struct pci_dev *pdev,\n\t\t\t  const struct pci_device_id *ent)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct enetc_ndev_priv *priv;\n\tstruct net_device *ndev;\n\tstruct enetc_si *si;\n\tstruct enetc_pf *pf;\n\tint err;\n\n\terr = enetc_pf_register_with_ierb(pdev);\n\tif (err == -EPROBE_DEFER)\n\t\treturn err;\n\tif (err)\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Could not register with IERB driver: %pe, please update the device tree\\n\",\n\t\t\t ERR_PTR(err));\n\n\tsi = enetc_psi_create(pdev);\n\tif (IS_ERR(si)) {\n\t\terr = PTR_ERR(si);\n\t\tgoto err_psi_create;\n\t}\n\n\tpf = enetc_si_priv(si);\n\tpf->si = si;\n\tpf->total_vfs = pci_sriov_get_totalvfs(pdev);\n\n\terr = enetc_setup_mac_addresses(node, pf);\n\tif (err)\n\t\tgoto err_setup_mac_addresses;\n\n\tenetc_configure_port(pf);\n\n\tenetc_get_si_caps(si);\n\n\tndev = alloc_etherdev_mq(sizeof(*priv), ENETC_MAX_NUM_TXQS);\n\tif (!ndev) {\n\t\terr = -ENOMEM;\n\t\tdev_err(&pdev->dev, \"netdev creation failed\\n\");\n\t\tgoto err_alloc_netdev;\n\t}\n\n\tenetc_pf_netdev_setup(si, ndev, &enetc_ndev_ops);\n\n\tpriv = netdev_priv(ndev);\n\n\tmutex_init(&priv->mm_lock);\n\n\tenetc_init_si_rings_params(priv);\n\n\terr = enetc_alloc_si_resources(priv);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"SI resource alloc failed\\n\");\n\t\tgoto err_alloc_si_res;\n\t}\n\n\terr = enetc_configure_si(priv);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to configure SI\\n\");\n\t\tgoto err_config_si;\n\t}\n\n\terr = enetc_alloc_msix(priv);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"MSIX alloc failed\\n\");\n\t\tgoto err_alloc_msix;\n\t}\n\n\terr = of_get_phy_mode(node, &pf->if_mode);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to read PHY mode\\n\");\n\t\tgoto err_phy_mode;\n\t}\n\n\terr = enetc_mdiobus_create(pf, node);\n\tif (err)\n\t\tgoto err_mdiobus_create;\n\n\terr = enetc_phylink_create(priv, node);\n\tif (err)\n\t\tgoto err_phylink_create;\n\n\terr = register_netdev(ndev);\n\tif (err)\n\t\tgoto err_reg_netdev;\n\n\treturn 0;\n\nerr_reg_netdev:\n\tenetc_phylink_destroy(priv);\nerr_phylink_create:\n\tenetc_mdiobus_destroy(pf);\nerr_mdiobus_create:\nerr_phy_mode:\n\tenetc_free_msix(priv);\nerr_config_si:\nerr_alloc_msix:\n\tenetc_free_si_resources(priv);\nerr_alloc_si_res:\n\tsi->ndev = NULL;\n\tfree_netdev(ndev);\nerr_alloc_netdev:\nerr_setup_mac_addresses:\n\tenetc_psi_destroy(pdev);\nerr_psi_create:\n\treturn err;\n}\n\nstatic void enetc_pf_remove(struct pci_dev *pdev)\n{\n\tstruct enetc_si *si = pci_get_drvdata(pdev);\n\tstruct enetc_pf *pf = enetc_si_priv(si);\n\tstruct enetc_ndev_priv *priv;\n\n\tpriv = netdev_priv(si->ndev);\n\n\tif (pf->num_vfs)\n\t\tenetc_sriov_configure(pdev, 0);\n\n\tunregister_netdev(si->ndev);\n\n\tenetc_phylink_destroy(priv);\n\tenetc_mdiobus_destroy(pf);\n\n\tenetc_free_msix(priv);\n\n\tenetc_free_si_resources(priv);\n\n\tfree_netdev(si->ndev);\n\n\tenetc_psi_destroy(pdev);\n}\n\nstatic void enetc_fixup_clear_rss_rfs(struct pci_dev *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct enetc_si *si;\n\n\t \n\tif (node && of_device_is_available(node))\n\t\treturn;\n\n\tsi = enetc_psi_create(pdev);\n\tif (!IS_ERR(si))\n\t\tenetc_psi_destroy(pdev);\n}\nDECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_FREESCALE, ENETC_DEV_ID_PF,\n\t\t\tenetc_fixup_clear_rss_rfs);\n\nstatic const struct pci_device_id enetc_pf_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_FREESCALE, ENETC_DEV_ID_PF) },\n\t{ 0, }  \n};\nMODULE_DEVICE_TABLE(pci, enetc_pf_id_table);\n\nstatic struct pci_driver enetc_pf_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = enetc_pf_id_table,\n\t.probe = enetc_pf_probe,\n\t.remove = enetc_pf_remove,\n#ifdef CONFIG_PCI_IOV\n\t.sriov_configure = enetc_sriov_configure,\n#endif\n};\nmodule_pci_driver(enetc_pf_driver);\n\nMODULE_DESCRIPTION(ENETC_DRV_NAME_STR);\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}