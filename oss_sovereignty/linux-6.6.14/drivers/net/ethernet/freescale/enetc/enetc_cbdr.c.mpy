{
  "module_name": "enetc_cbdr.c",
  "hash_id": "3586948a3340fda0cad8f3d6165c72dc4a32366205c6a36db5e8b93e652656e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/enetc/enetc_cbdr.c",
  "human_readable_source": "\n \n\n#include \"enetc.h\"\n\nint enetc_setup_cbdr(struct device *dev, struct enetc_hw *hw, int bd_count,\n\t\t     struct enetc_cbdr *cbdr)\n{\n\tint size = bd_count * sizeof(struct enetc_cbd);\n\n\tcbdr->bd_base = dma_alloc_coherent(dev, size, &cbdr->bd_dma_base,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!cbdr->bd_base)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!IS_ALIGNED(cbdr->bd_dma_base, 128)) {\n\t\tdma_free_coherent(dev, size, cbdr->bd_base,\n\t\t\t\t  cbdr->bd_dma_base);\n\t\treturn -EINVAL;\n\t}\n\n\tcbdr->next_to_clean = 0;\n\tcbdr->next_to_use = 0;\n\tcbdr->dma_dev = dev;\n\tcbdr->bd_count = bd_count;\n\n\tcbdr->pir = hw->reg + ENETC_SICBDRPIR;\n\tcbdr->cir = hw->reg + ENETC_SICBDRCIR;\n\tcbdr->mr = hw->reg + ENETC_SICBDRMR;\n\n\t \n\tenetc_wr(hw, ENETC_SICAR2,\n\t\t ENETC_SICAR_RD_COHERENT | ENETC_SICAR_WR_COHERENT);\n\n\tenetc_wr(hw, ENETC_SICBDRBAR0, lower_32_bits(cbdr->bd_dma_base));\n\tenetc_wr(hw, ENETC_SICBDRBAR1, upper_32_bits(cbdr->bd_dma_base));\n\tenetc_wr(hw, ENETC_SICBDRLENR, ENETC_RTBLENR_LEN(cbdr->bd_count));\n\n\tenetc_wr_reg(cbdr->pir, cbdr->next_to_clean);\n\tenetc_wr_reg(cbdr->cir, cbdr->next_to_use);\n\t \n\tenetc_wr_reg(cbdr->mr, BIT(31));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(enetc_setup_cbdr);\n\nvoid enetc_teardown_cbdr(struct enetc_cbdr *cbdr)\n{\n\tint size = cbdr->bd_count * sizeof(struct enetc_cbd);\n\n\t \n\tenetc_wr_reg(cbdr->mr, 0);\n\n\tdma_free_coherent(cbdr->dma_dev, size, cbdr->bd_base,\n\t\t\t  cbdr->bd_dma_base);\n\tcbdr->bd_base = NULL;\n\tcbdr->dma_dev = NULL;\n}\nEXPORT_SYMBOL_GPL(enetc_teardown_cbdr);\n\nstatic void enetc_clean_cbdr(struct enetc_cbdr *ring)\n{\n\tstruct enetc_cbd *dest_cbd;\n\tint i, status;\n\n\ti = ring->next_to_clean;\n\n\twhile (enetc_rd_reg(ring->cir) != i) {\n\t\tdest_cbd = ENETC_CBD(*ring, i);\n\t\tstatus = dest_cbd->status_flags & ENETC_CBD_STATUS_MASK;\n\t\tif (status)\n\t\t\tdev_warn(ring->dma_dev, \"CMD err %04x for cmd %04x\\n\",\n\t\t\t\t status, dest_cbd->cmd);\n\n\t\tmemset(dest_cbd, 0, sizeof(*dest_cbd));\n\n\t\ti = (i + 1) % ring->bd_count;\n\t}\n\n\tring->next_to_clean = i;\n}\n\nstatic int enetc_cbd_unused(struct enetc_cbdr *r)\n{\n\treturn (r->next_to_clean - r->next_to_use - 1 + r->bd_count) %\n\t\tr->bd_count;\n}\n\nint enetc_send_cmd(struct enetc_si *si, struct enetc_cbd *cbd)\n{\n\tstruct enetc_cbdr *ring = &si->cbd_ring;\n\tint timeout = ENETC_CBDR_TIMEOUT;\n\tstruct enetc_cbd *dest_cbd;\n\tint i;\n\n\tif (unlikely(!ring->bd_base))\n\t\treturn -EIO;\n\n\tif (unlikely(!enetc_cbd_unused(ring)))\n\t\tenetc_clean_cbdr(ring);\n\n\ti = ring->next_to_use;\n\tdest_cbd = ENETC_CBD(*ring, i);\n\n\t \n\t*dest_cbd = *cbd;\n\ti = (i + 1) % ring->bd_count;\n\n\tring->next_to_use = i;\n\t \n\tenetc_wr_reg(ring->pir, i);\n\n\tdo {\n\t\tif (enetc_rd_reg(ring->cir) == i)\n\t\t\tbreak;\n\t\tudelay(10);  \n\t\ttimeout -= 10;\n\t} while (timeout);\n\n\tif (!timeout)\n\t\treturn -EBUSY;\n\n\t \n\t*cbd = *dest_cbd;\n\n\tenetc_clean_cbdr(ring);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(enetc_send_cmd);\n\nint enetc_clear_mac_flt_entry(struct enetc_si *si, int index)\n{\n\tstruct enetc_cbd cbd;\n\n\tmemset(&cbd, 0, sizeof(cbd));\n\n\tcbd.cls = 1;\n\tcbd.status_flags = ENETC_CBD_FLAGS_SF;\n\tcbd.index = cpu_to_le16(index);\n\n\treturn enetc_send_cmd(si, &cbd);\n}\nEXPORT_SYMBOL_GPL(enetc_clear_mac_flt_entry);\n\nint enetc_set_mac_flt_entry(struct enetc_si *si, int index,\n\t\t\t    char *mac_addr, int si_map)\n{\n\tstruct enetc_cbd cbd;\n\tu32 upper;\n\tu16 lower;\n\n\tmemset(&cbd, 0, sizeof(cbd));\n\n\t \n\tcbd.cls = 1;\n\tcbd.status_flags = ENETC_CBD_FLAGS_SF;\n\tcbd.index = cpu_to_le16(index);\n\tcbd.opt[3] = cpu_to_le32(si_map);\n\t \n\tcbd.opt[0] = cpu_to_le32(BIT(31));\n\n\tupper = *(const u32 *)mac_addr;\n\tlower = *(const u16 *)(mac_addr + 4);\n\tcbd.addr[0] = cpu_to_le32(upper);\n\tcbd.addr[1] = cpu_to_le32(lower);\n\n\treturn enetc_send_cmd(si, &cbd);\n}\nEXPORT_SYMBOL_GPL(enetc_set_mac_flt_entry);\n\n \nint enetc_set_fs_entry(struct enetc_si *si, struct enetc_cmd_rfse *rfse,\n\t\t       int index)\n{\n\tstruct enetc_cbdr *ring = &si->cbd_ring;\n\tstruct enetc_cbd cbd = {.cmd = 0};\n\tvoid *tmp, *tmp_align;\n\tdma_addr_t dma;\n\tint err;\n\n\t \n\tcbd.cmd = 0;\n\tcbd.cls = 4;\n\tcbd.index = cpu_to_le16(index);\n\tcbd.opt[3] = cpu_to_le32(0);  \n\n\ttmp = enetc_cbd_alloc_data_mem(si, &cbd, sizeof(*rfse),\n\t\t\t\t       &dma, &tmp_align);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tmemcpy(tmp_align, rfse, sizeof(*rfse));\n\n\terr = enetc_send_cmd(si, &cbd);\n\tif (err)\n\t\tdev_err(ring->dma_dev, \"FS entry add failed (%d)!\", err);\n\n\tenetc_cbd_free_data_mem(si, sizeof(*rfse), tmp, &dma);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(enetc_set_fs_entry);\n\nstatic int enetc_cmd_rss_table(struct enetc_si *si, u32 *table, int count,\n\t\t\t       bool read)\n{\n\tstruct enetc_cbdr *ring = &si->cbd_ring;\n\tstruct enetc_cbd cbd = {.cmd = 0};\n\tu8 *tmp, *tmp_align;\n\tdma_addr_t dma;\n\tint err, i;\n\n\tif (count < ENETC_CBD_DATA_MEM_ALIGN)\n\t\t \n\t\treturn -EINVAL;\n\n\ttmp = enetc_cbd_alloc_data_mem(si, &cbd, count,\n\t\t\t\t       &dma, (void *)&tmp_align);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tif (!read)\n\t\tfor (i = 0; i < count; i++)\n\t\t\ttmp_align[i] = (u8)(table[i]);\n\n\t \n\tcbd.cmd = read ? 2 : 1;\n\tcbd.cls = 3;\n\n\terr = enetc_send_cmd(si, &cbd);\n\tif (err)\n\t\tdev_err(ring->dma_dev, \"RSS cmd failed (%d)!\", err);\n\n\tif (read)\n\t\tfor (i = 0; i < count; i++)\n\t\t\ttable[i] = tmp_align[i];\n\n\tenetc_cbd_free_data_mem(si, count, tmp, &dma);\n\n\treturn err;\n}\n\n \nint enetc_get_rss_table(struct enetc_si *si, u32 *table, int count)\n{\n\treturn enetc_cmd_rss_table(si, table, count, true);\n}\nEXPORT_SYMBOL_GPL(enetc_get_rss_table);\n\n \nint enetc_set_rss_table(struct enetc_si *si, const u32 *table, int count)\n{\n\treturn enetc_cmd_rss_table(si, (u32 *)table, count, false);\n}\nEXPORT_SYMBOL_GPL(enetc_set_rss_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}