{
  "module_name": "enetc_msg.c",
  "hash_id": "33f1288e51d9770daf73eaa2ce37cc2c3a5de4c59b4ab1704cb195e46dc68e95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/enetc/enetc_msg.c",
  "human_readable_source": "\n \n\n#include \"enetc_pf.h\"\n\nstatic void enetc_msg_disable_mr_int(struct enetc_hw *hw)\n{\n\tu32 psiier = enetc_rd(hw, ENETC_PSIIER);\n\t \n\tenetc_wr(hw, ENETC_PSIIER, psiier & ~ENETC_PSIIER_MR_MASK);\n}\n\nstatic void enetc_msg_enable_mr_int(struct enetc_hw *hw)\n{\n\tu32 psiier = enetc_rd(hw, ENETC_PSIIER);\n\n\tenetc_wr(hw, ENETC_PSIIER, psiier | ENETC_PSIIER_MR_MASK);\n}\n\nstatic irqreturn_t enetc_msg_psi_msix(int irq, void *data)\n{\n\tstruct enetc_si *si = (struct enetc_si *)data;\n\tstruct enetc_pf *pf = enetc_si_priv(si);\n\n\tenetc_msg_disable_mr_int(&si->hw);\n\tschedule_work(&pf->msg_task);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void enetc_msg_task(struct work_struct *work)\n{\n\tstruct enetc_pf *pf = container_of(work, struct enetc_pf, msg_task);\n\tstruct enetc_hw *hw = &pf->si->hw;\n\tunsigned long mr_mask;\n\tint i;\n\n\tfor (;;) {\n\t\tmr_mask = enetc_rd(hw, ENETC_PSIMSGRR) & ENETC_PSIMSGRR_MR_MASK;\n\t\tif (!mr_mask) {\n\t\t\t \n\t\t\tenetc_wr(hw, ENETC_PSIIDR, ENETC_PSIIER_MR_MASK);\n\t\t\tenetc_msg_enable_mr_int(hw);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (i = 0; i < pf->num_vfs; i++) {\n\t\t\tu32 psimsgrr;\n\t\t\tu16 msg_code;\n\n\t\t\tif (!(ENETC_PSIMSGRR_MR(i) & mr_mask))\n\t\t\t\tcontinue;\n\n\t\t\tenetc_msg_handle_rxmsg(pf, i, &msg_code);\n\n\t\t\tpsimsgrr = ENETC_SIMSGSR_SET_MC(msg_code);\n\t\t\tpsimsgrr |= ENETC_PSIMSGRR_MR(i);  \n\t\t\tenetc_wr(hw, ENETC_PSIMSGRR, psimsgrr);\n\t\t}\n\t}\n}\n\n \nstatic int enetc_msg_alloc_mbx(struct enetc_si *si, int idx)\n{\n\tstruct enetc_pf *pf = enetc_si_priv(si);\n\tstruct device *dev = &si->pdev->dev;\n\tstruct enetc_hw *hw = &si->hw;\n\tstruct enetc_msg_swbd *msg;\n\tu32 val;\n\n\tmsg = &pf->rxmsg[idx];\n\t \n\tmsg->size = ENETC_DEFAULT_MSG_SIZE;\n\n\tmsg->vaddr = dma_alloc_coherent(dev, msg->size, &msg->dma,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!msg->vaddr) {\n\t\tdev_err(dev, \"msg: fail to alloc dma buffer of size: %d\\n\",\n\t\t\tmsg->size);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tval = lower_32_bits(msg->dma);\n\tenetc_wr(hw, ENETC_PSIVMSGRCVAR0(idx), val);\n\tval = upper_32_bits(msg->dma);\n\tenetc_wr(hw, ENETC_PSIVMSGRCVAR1(idx), val);\n\n\treturn 0;\n}\n\nstatic void enetc_msg_free_mbx(struct enetc_si *si, int idx)\n{\n\tstruct enetc_pf *pf = enetc_si_priv(si);\n\tstruct enetc_hw *hw = &si->hw;\n\tstruct enetc_msg_swbd *msg;\n\n\tmsg = &pf->rxmsg[idx];\n\tdma_free_coherent(&si->pdev->dev, msg->size, msg->vaddr, msg->dma);\n\tmemset(msg, 0, sizeof(*msg));\n\n\tenetc_wr(hw, ENETC_PSIVMSGRCVAR0(idx), 0);\n\tenetc_wr(hw, ENETC_PSIVMSGRCVAR1(idx), 0);\n}\n\nint enetc_msg_psi_init(struct enetc_pf *pf)\n{\n\tstruct enetc_si *si = pf->si;\n\tint vector, i, err;\n\n\t \n\tsnprintf(pf->msg_int_name, sizeof(pf->msg_int_name), \"%s-vfmsg\",\n\t\t si->ndev->name);\n\tvector = pci_irq_vector(si->pdev, ENETC_SI_INT_IDX);\n\terr = request_irq(vector, enetc_msg_psi_msix, 0, pf->msg_int_name, si);\n\tif (err) {\n\t\tdev_err(&si->pdev->dev,\n\t\t\t\"PSI messaging: request_irq() failed!\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tenetc_wr(&si->hw, ENETC_SIMSIVR, ENETC_SI_INT_IDX);\n\n\t \n\tINIT_WORK(&pf->msg_task, enetc_msg_task);\n\n\tfor (i = 0; i < pf->num_vfs; i++) {\n\t\terr = enetc_msg_alloc_mbx(si, i);\n\t\tif (err)\n\t\t\tgoto err_init_mbx;\n\t}\n\n\t \n\tenetc_msg_enable_mr_int(&si->hw);\n\n\treturn 0;\n\nerr_init_mbx:\n\tfor (i--; i >= 0; i--)\n\t\tenetc_msg_free_mbx(si, i);\n\n\tfree_irq(vector, si);\n\n\treturn err;\n}\n\nvoid enetc_msg_psi_free(struct enetc_pf *pf)\n{\n\tstruct enetc_si *si = pf->si;\n\tint i;\n\n\tcancel_work_sync(&pf->msg_task);\n\n\t \n\tenetc_msg_disable_mr_int(&si->hw);\n\n\tfor (i = 0; i < pf->num_vfs; i++)\n\t\tenetc_msg_free_mbx(si, i);\n\n\t \n\tfree_irq(pci_irq_vector(si->pdev, ENETC_SI_INT_IDX), si);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}