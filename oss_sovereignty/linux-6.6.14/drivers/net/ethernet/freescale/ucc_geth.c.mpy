{
  "module_name": "ucc_geth.c",
  "hash_id": "7254dd871158128a0f474c457c1855ba81408acd9ab6d2478542edc7bd80ff4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/ucc_geth.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/dma-mapping.h>\n#include <linux/mii.h>\n#include <linux/phy.h>\n#include <linux/phy_fixed.h>\n#include <linux/workqueue.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/platform_device.h>\n\n#include <linux/uaccess.h>\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <soc/fsl/qe/immap_qe.h>\n#include <soc/fsl/qe/qe.h>\n#include <soc/fsl/qe/ucc.h>\n#include <soc/fsl/qe/ucc_fast.h>\n#include <asm/machdep.h>\n\n#include \"ucc_geth.h\"\n\n#undef DEBUG\n\n#define ugeth_printk(level, format, arg...)  \\\n        printk(level format \"\\n\", ## arg)\n\n#define ugeth_dbg(format, arg...)            \\\n        ugeth_printk(KERN_DEBUG , format , ## arg)\n\n#ifdef UGETH_VERBOSE_DEBUG\n#define ugeth_vdbg ugeth_dbg\n#else\n#define ugeth_vdbg(fmt, args...) do { } while (0)\n#endif\t\t\t\t \n#define UGETH_MSG_DEFAULT\t(NETIF_MSG_IFUP << 1 ) - 1\n\n\nstatic DEFINE_SPINLOCK(ugeth_lock);\n\nstatic struct {\n\tu32 msg_enable;\n} debug = { -1 };\n\nmodule_param_named(debug, debug.msg_enable, int, 0);\nMODULE_PARM_DESC(debug, \"Debug verbosity level (0=none, ..., 0xffff=all)\");\n\nstatic int ucc_geth_thread_count(enum ucc_geth_num_of_threads idx)\n{\n\tstatic const u8 count[] = {\n\t\t[UCC_GETH_NUM_OF_THREADS_1] = 1,\n\t\t[UCC_GETH_NUM_OF_THREADS_2] = 2,\n\t\t[UCC_GETH_NUM_OF_THREADS_4] = 4,\n\t\t[UCC_GETH_NUM_OF_THREADS_6] = 6,\n\t\t[UCC_GETH_NUM_OF_THREADS_8] = 8,\n\t};\n\tif (idx >= ARRAY_SIZE(count))\n\t\treturn 0;\n\treturn count[idx];\n}\n\nstatic inline int ucc_geth_tx_queues(const struct ucc_geth_info *info)\n{\n\treturn 1;\n}\n\nstatic inline int ucc_geth_rx_queues(const struct ucc_geth_info *info)\n{\n\treturn 1;\n}\n\nstatic const struct ucc_geth_info ugeth_primary_info = {\n\t.uf_info = {\n\t\t    .rtsm = UCC_FAST_SEND_IDLES_BETWEEN_FRAMES,\n\t\t    .max_rx_buf_length = 1536,\n\t\t     \n\t\t    .urfs = UCC_GETH_URFS_INIT,\n\t\t    .urfet = UCC_GETH_URFET_INIT,\n\t\t    .urfset = UCC_GETH_URFSET_INIT,\n\t\t    .utfs = UCC_GETH_UTFS_INIT,\n\t\t    .utfet = UCC_GETH_UTFET_INIT,\n\t\t    .utftt = UCC_GETH_UTFTT_INIT,\n\t\t    .ufpt = 256,\n\t\t    .mode = UCC_FAST_PROTOCOL_MODE_ETHERNET,\n\t\t    .ttx_trx = UCC_FAST_GUMR_TRANSPARENT_TTX_TRX_NORMAL,\n\t\t    .tenc = UCC_FAST_TX_ENCODING_NRZ,\n\t\t    .renc = UCC_FAST_RX_ENCODING_NRZ,\n\t\t    .tcrc = UCC_FAST_16_BIT_CRC,\n\t\t    .synl = UCC_FAST_SYNC_LEN_NOT_USED,\n\t\t    },\n\t.extendedFilteringChainPointer = ((uint32_t) NULL),\n\t.typeorlen = 3072   ,\n\t.nonBackToBackIfgPart1 = 0x40,\n\t.nonBackToBackIfgPart2 = 0x60,\n\t.miminumInterFrameGapEnforcement = 0x50,\n\t.backToBackInterFrameGap = 0x60,\n\t.mblinterval = 128,\n\t.nortsrbytetime = 5,\n\t.fracsiz = 1,\n\t.strictpriorityq = 0xff,\n\t.altBebTruncation = 0xa,\n\t.excessDefer = 1,\n\t.maxRetransmission = 0xf,\n\t.collisionWindow = 0x37,\n\t.receiveFlowControl = 1,\n\t.transmitFlowControl = 1,\n\t.maxGroupAddrInHash = 4,\n\t.maxIndAddrInHash = 4,\n\t.prel = 7,\n\t.maxFrameLength = 1518+16,  \n\t.minFrameLength = 64,\n\t.maxD1Length = 1520+16,  \n\t.maxD2Length = 1520+16,  \n\t.vlantype = 0x8100,\n\t.ecamptr = ((uint32_t) NULL),\n\t.eventRegMask = UCCE_OTHER,\n\t.pausePeriod = 0xf000,\n\t.interruptcoalescingmaxvalue = {1, 1, 1, 1, 1, 1, 1, 1},\n\t.bdRingLenTx = {\n\t\t\tTX_BD_RING_LEN,\n\t\t\tTX_BD_RING_LEN,\n\t\t\tTX_BD_RING_LEN,\n\t\t\tTX_BD_RING_LEN,\n\t\t\tTX_BD_RING_LEN,\n\t\t\tTX_BD_RING_LEN,\n\t\t\tTX_BD_RING_LEN,\n\t\t\tTX_BD_RING_LEN},\n\n\t.bdRingLenRx = {\n\t\t\tRX_BD_RING_LEN,\n\t\t\tRX_BD_RING_LEN,\n\t\t\tRX_BD_RING_LEN,\n\t\t\tRX_BD_RING_LEN,\n\t\t\tRX_BD_RING_LEN,\n\t\t\tRX_BD_RING_LEN,\n\t\t\tRX_BD_RING_LEN,\n\t\t\tRX_BD_RING_LEN},\n\n\t.numStationAddresses = UCC_GETH_NUM_OF_STATION_ADDRESSES_1,\n\t.largestexternallookupkeysize =\n\t    QE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_NONE,\n\t.statisticsMode = UCC_GETH_STATISTICS_GATHERING_MODE_HARDWARE |\n\t\tUCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_TX |\n\t\tUCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_RX,\n\t.vlanOperationTagged = UCC_GETH_VLAN_OPERATION_TAGGED_NOP,\n\t.vlanOperationNonTagged = UCC_GETH_VLAN_OPERATION_NON_TAGGED_NOP,\n\t.rxQoSMode = UCC_GETH_QOS_MODE_DEFAULT,\n\t.aufc = UPSMR_AUTOMATIC_FLOW_CONTROL_MODE_NONE,\n\t.padAndCrc = MACCFG2_PAD_AND_CRC_MODE_PAD_AND_CRC,\n\t.numThreadsTx = UCC_GETH_NUM_OF_THREADS_1,\n\t.numThreadsRx = UCC_GETH_NUM_OF_THREADS_1,\n\t.riscTx = QE_RISC_ALLOCATION_RISC1_AND_RISC2,\n\t.riscRx = QE_RISC_ALLOCATION_RISC1_AND_RISC2,\n};\n\n#ifdef DEBUG\nstatic void mem_disp(u8 *addr, int size)\n{\n\tu8 *i;\n\tint size16Aling = (size >> 4) << 4;\n\tint size4Aling = (size >> 2) << 2;\n\tint notAlign = 0;\n\tif (size % 16)\n\t\tnotAlign = 1;\n\n\tfor (i = addr; (u32) i < (u32) addr + size16Aling; i += 16)\n\t\tprintk(\"0x%08x: %08x %08x %08x %08x\\r\\n\",\n\t\t       (u32) i,\n\t\t       *((u32 *) (i)),\n\t\t       *((u32 *) (i + 4)),\n\t\t       *((u32 *) (i + 8)), *((u32 *) (i + 12)));\n\tif (notAlign == 1)\n\t\tprintk(\"0x%08x: \", (u32) i);\n\tfor (; (u32) i < (u32) addr + size4Aling; i += 4)\n\t\tprintk(\"%08x \", *((u32 *) (i)));\n\tfor (; (u32) i < (u32) addr + size; i++)\n\t\tprintk(\"%02x\", *((i)));\n\tif (notAlign == 1)\n\t\tprintk(\"\\r\\n\");\n}\n#endif  \n\nstatic struct list_head *dequeue(struct list_head *lh)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ugeth_lock, flags);\n\tif (!list_empty(lh)) {\n\t\tstruct list_head *node = lh->next;\n\t\tlist_del(node);\n\t\tspin_unlock_irqrestore(&ugeth_lock, flags);\n\t\treturn node;\n\t} else {\n\t\tspin_unlock_irqrestore(&ugeth_lock, flags);\n\t\treturn NULL;\n\t}\n}\n\nstatic struct sk_buff *get_new_skb(struct ucc_geth_private *ugeth,\n\t\tu8 __iomem *bd)\n{\n\tstruct sk_buff *skb;\n\n\tskb = netdev_alloc_skb(ugeth->ndev,\n\t\t\t       ugeth->ug_info->uf_info.max_rx_buf_length +\n\t\t\t       UCC_GETH_RX_DATA_BUF_ALIGNMENT);\n\tif (!skb)\n\t\treturn NULL;\n\n\t \n\tskb_reserve(skb,\n\t\t    UCC_GETH_RX_DATA_BUF_ALIGNMENT -\n\t\t    (((unsigned)skb->data) & (UCC_GETH_RX_DATA_BUF_ALIGNMENT -\n\t\t\t\t\t      1)));\n\n\tout_be32(&((struct qe_bd __iomem *)bd)->buf,\n\t\t      dma_map_single(ugeth->dev,\n\t\t\t\t     skb->data,\n\t\t\t\t     ugeth->ug_info->uf_info.max_rx_buf_length +\n\t\t\t\t     UCC_GETH_RX_DATA_BUF_ALIGNMENT,\n\t\t\t\t     DMA_FROM_DEVICE));\n\n\tout_be32((u32 __iomem *)bd,\n\t\t\t(R_E | R_I | (in_be32((u32 __iomem*)bd) & R_W)));\n\n\treturn skb;\n}\n\nstatic int rx_bd_buffer_set(struct ucc_geth_private *ugeth, u8 rxQ)\n{\n\tu8 __iomem *bd;\n\tu32 bd_status;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tbd = ugeth->p_rx_bd_ring[rxQ];\n\ti = 0;\n\n\tdo {\n\t\tbd_status = in_be32((u32 __iomem *)bd);\n\t\tskb = get_new_skb(ugeth, bd);\n\n\t\tif (!skb)\t \n\t\t\treturn -ENOMEM;\n\n\t\tugeth->rx_skbuff[rxQ][i] = skb;\n\n\t\t \n\t\tbd += sizeof(struct qe_bd);\n\t\ti++;\n\t} while (!(bd_status & R_W));\n\n\treturn 0;\n}\n\nstatic int fill_init_enet_entries(struct ucc_geth_private *ugeth,\n\t\t\t\t  u32 *p_start,\n\t\t\t\t  u8 num_entries,\n\t\t\t\t  u32 thread_size,\n\t\t\t\t  u32 thread_alignment,\n\t\t\t\t  unsigned int risc,\n\t\t\t\t  int skip_page_for_first_entry)\n{\n\tu32 init_enet_offset;\n\tu8 i;\n\tint snum;\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tif ((snum = qe_get_snum()) < 0) {\n\t\t\tif (netif_msg_ifup(ugeth))\n\t\t\t\tpr_err(\"Can not get SNUM\\n\");\n\t\t\treturn snum;\n\t\t}\n\t\tif ((i == 0) && skip_page_for_first_entry)\n\t\t \n\t\t\tinit_enet_offset = 0;\n\t\telse {\n\t\t\tinit_enet_offset =\n\t\t\t    qe_muram_alloc(thread_size, thread_alignment);\n\t\t\tif (IS_ERR_VALUE(init_enet_offset)) {\n\t\t\t\tif (netif_msg_ifup(ugeth))\n\t\t\t\t\tpr_err(\"Can not allocate DPRAM memory\\n\");\n\t\t\t\tqe_put_snum((u8) snum);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t\t*(p_start++) =\n\t\t    ((u8) snum << ENET_INIT_PARAM_SNUM_SHIFT) | init_enet_offset\n\t\t    | risc;\n\t}\n\n\treturn 0;\n}\n\nstatic int return_init_enet_entries(struct ucc_geth_private *ugeth,\n\t\t\t\t    u32 *p_start,\n\t\t\t\t    u8 num_entries,\n\t\t\t\t    unsigned int risc,\n\t\t\t\t    int skip_page_for_first_entry)\n{\n\tu32 init_enet_offset;\n\tu8 i;\n\tint snum;\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tu32 val = *p_start;\n\n\t\t \n\t\tif ((val & ENET_INIT_PARAM_RISC_MASK) == risc) {\n\t\t\tsnum =\n\t\t\t    (u32) (val & ENET_INIT_PARAM_SNUM_MASK) >>\n\t\t\t    ENET_INIT_PARAM_SNUM_SHIFT;\n\t\t\tqe_put_snum((u8) snum);\n\t\t\tif (!((i == 0) && skip_page_for_first_entry)) {\n\t\t\t \n\t\t\t\tinit_enet_offset =\n\t\t\t\t    (val & ENET_INIT_PARAM_PTR_MASK);\n\t\t\t\tqe_muram_free(init_enet_offset);\n\t\t\t}\n\t\t\t*p_start++ = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef DEBUG\nstatic int dump_init_enet_entries(struct ucc_geth_private *ugeth,\n\t\t\t\t  u32 __iomem *p_start,\n\t\t\t\t  u8 num_entries,\n\t\t\t\t  u32 thread_size,\n\t\t\t\t  unsigned int risc,\n\t\t\t\t  int skip_page_for_first_entry)\n{\n\tu32 init_enet_offset;\n\tu8 i;\n\tint snum;\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tu32 val = in_be32(p_start);\n\n\t\t \n\t\tif ((val & ENET_INIT_PARAM_RISC_MASK) == risc) {\n\t\t\tsnum =\n\t\t\t    (u32) (val & ENET_INIT_PARAM_SNUM_MASK) >>\n\t\t\t    ENET_INIT_PARAM_SNUM_SHIFT;\n\t\t\tqe_put_snum((u8) snum);\n\t\t\tif (!((i == 0) && skip_page_for_first_entry)) {\n\t\t\t \n\t\t\t\tinit_enet_offset =\n\t\t\t\t    (in_be32(p_start) &\n\t\t\t\t     ENET_INIT_PARAM_PTR_MASK);\n\t\t\t\tpr_info(\"Init enet entry %d:\\n\", i);\n\t\t\t\tpr_info(\"Base address: 0x%08x\\n\",\n\t\t\t\t\t(u32)qe_muram_addr(init_enet_offset));\n\t\t\t\tmem_disp(qe_muram_addr(init_enet_offset),\n\t\t\t\t\t thread_size);\n\t\t\t}\n\t\t\tp_start++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic void put_enet_addr_container(struct enet_addr_container *enet_addr_cont)\n{\n\tkfree(enet_addr_cont);\n}\n\nstatic void set_mac_addr(__be16 __iomem *reg, u8 *mac)\n{\n\tout_be16(&reg[0], ((u16)mac[5] << 8) | mac[4]);\n\tout_be16(&reg[1], ((u16)mac[3] << 8) | mac[2]);\n\tout_be16(&reg[2], ((u16)mac[1] << 8) | mac[0]);\n}\n\nstatic int hw_clear_addr_in_paddr(struct ucc_geth_private *ugeth, u8 paddr_num)\n{\n\tstruct ucc_geth_82xx_address_filtering_pram __iomem *p_82xx_addr_filt;\n\n\tif (paddr_num >= NUM_OF_PADDRS) {\n\t\tpr_warn(\"%s: Invalid paddr_num: %u\\n\", __func__, paddr_num);\n\t\treturn -EINVAL;\n\t}\n\n\tp_82xx_addr_filt =\n\t    (struct ucc_geth_82xx_address_filtering_pram __iomem *) ugeth->p_rx_glbl_pram->\n\t    addressfiltering;\n\n\t \n\tout_be16(&p_82xx_addr_filt->paddr[paddr_num].h, 0xffff);\n\tout_be16(&p_82xx_addr_filt->paddr[paddr_num].m, 0xffff);\n\tout_be16(&p_82xx_addr_filt->paddr[paddr_num].l, 0xffff);\n\n\treturn 0;\n}\n\nstatic void hw_add_addr_in_hash(struct ucc_geth_private *ugeth,\n                                u8 *p_enet_addr)\n{\n\tstruct ucc_geth_82xx_address_filtering_pram __iomem *p_82xx_addr_filt;\n\tu32 cecr_subblock;\n\n\tp_82xx_addr_filt =\n\t    (struct ucc_geth_82xx_address_filtering_pram __iomem *) ugeth->p_rx_glbl_pram->\n\t    addressfiltering;\n\n\tcecr_subblock =\n\t    ucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);\n\n\t \n\t \n\n\tset_mac_addr(&p_82xx_addr_filt->taddr.h, p_enet_addr);\n\n\tqe_issue_cmd(QE_SET_GROUP_ADDRESS, cecr_subblock,\n\t\t     QE_CR_PROTOCOL_ETHERNET, 0);\n}\n\n#ifdef DEBUG\nstatic void get_statistics(struct ucc_geth_private *ugeth,\n\t\t\t   struct ucc_geth_tx_firmware_statistics *\n\t\t\t   tx_firmware_statistics,\n\t\t\t   struct ucc_geth_rx_firmware_statistics *\n\t\t\t   rx_firmware_statistics,\n\t\t\t   struct ucc_geth_hardware_statistics *hardware_statistics)\n{\n\tstruct ucc_fast __iomem *uf_regs;\n\tstruct ucc_geth __iomem *ug_regs;\n\tstruct ucc_geth_tx_firmware_statistics_pram *p_tx_fw_statistics_pram;\n\tstruct ucc_geth_rx_firmware_statistics_pram *p_rx_fw_statistics_pram;\n\n\tug_regs = ugeth->ug_regs;\n\tuf_regs = (struct ucc_fast __iomem *) ug_regs;\n\tp_tx_fw_statistics_pram = ugeth->p_tx_fw_statistics_pram;\n\tp_rx_fw_statistics_pram = ugeth->p_rx_fw_statistics_pram;\n\n\t \n\tif (tx_firmware_statistics && p_tx_fw_statistics_pram) {\n\t\ttx_firmware_statistics->sicoltx =\n\t\t    in_be32(&p_tx_fw_statistics_pram->sicoltx);\n\t\ttx_firmware_statistics->mulcoltx =\n\t\t    in_be32(&p_tx_fw_statistics_pram->mulcoltx);\n\t\ttx_firmware_statistics->latecoltxfr =\n\t\t    in_be32(&p_tx_fw_statistics_pram->latecoltxfr);\n\t\ttx_firmware_statistics->frabortduecol =\n\t\t    in_be32(&p_tx_fw_statistics_pram->frabortduecol);\n\t\ttx_firmware_statistics->frlostinmactxer =\n\t\t    in_be32(&p_tx_fw_statistics_pram->frlostinmactxer);\n\t\ttx_firmware_statistics->carriersenseertx =\n\t\t    in_be32(&p_tx_fw_statistics_pram->carriersenseertx);\n\t\ttx_firmware_statistics->frtxok =\n\t\t    in_be32(&p_tx_fw_statistics_pram->frtxok);\n\t\ttx_firmware_statistics->txfrexcessivedefer =\n\t\t    in_be32(&p_tx_fw_statistics_pram->txfrexcessivedefer);\n\t\ttx_firmware_statistics->txpkts256 =\n\t\t    in_be32(&p_tx_fw_statistics_pram->txpkts256);\n\t\ttx_firmware_statistics->txpkts512 =\n\t\t    in_be32(&p_tx_fw_statistics_pram->txpkts512);\n\t\ttx_firmware_statistics->txpkts1024 =\n\t\t    in_be32(&p_tx_fw_statistics_pram->txpkts1024);\n\t\ttx_firmware_statistics->txpktsjumbo =\n\t\t    in_be32(&p_tx_fw_statistics_pram->txpktsjumbo);\n\t}\n\n\t \n\tif (rx_firmware_statistics && p_rx_fw_statistics_pram) {\n\t\tint i;\n\t\trx_firmware_statistics->frrxfcser =\n\t\t    in_be32(&p_rx_fw_statistics_pram->frrxfcser);\n\t\trx_firmware_statistics->fraligner =\n\t\t    in_be32(&p_rx_fw_statistics_pram->fraligner);\n\t\trx_firmware_statistics->inrangelenrxer =\n\t\t    in_be32(&p_rx_fw_statistics_pram->inrangelenrxer);\n\t\trx_firmware_statistics->outrangelenrxer =\n\t\t    in_be32(&p_rx_fw_statistics_pram->outrangelenrxer);\n\t\trx_firmware_statistics->frtoolong =\n\t\t    in_be32(&p_rx_fw_statistics_pram->frtoolong);\n\t\trx_firmware_statistics->runt =\n\t\t    in_be32(&p_rx_fw_statistics_pram->runt);\n\t\trx_firmware_statistics->verylongevent =\n\t\t    in_be32(&p_rx_fw_statistics_pram->verylongevent);\n\t\trx_firmware_statistics->symbolerror =\n\t\t    in_be32(&p_rx_fw_statistics_pram->symbolerror);\n\t\trx_firmware_statistics->dropbsy =\n\t\t    in_be32(&p_rx_fw_statistics_pram->dropbsy);\n\t\tfor (i = 0; i < 0x8; i++)\n\t\t\trx_firmware_statistics->res0[i] =\n\t\t\t    p_rx_fw_statistics_pram->res0[i];\n\t\trx_firmware_statistics->mismatchdrop =\n\t\t    in_be32(&p_rx_fw_statistics_pram->mismatchdrop);\n\t\trx_firmware_statistics->underpkts =\n\t\t    in_be32(&p_rx_fw_statistics_pram->underpkts);\n\t\trx_firmware_statistics->pkts256 =\n\t\t    in_be32(&p_rx_fw_statistics_pram->pkts256);\n\t\trx_firmware_statistics->pkts512 =\n\t\t    in_be32(&p_rx_fw_statistics_pram->pkts512);\n\t\trx_firmware_statistics->pkts1024 =\n\t\t    in_be32(&p_rx_fw_statistics_pram->pkts1024);\n\t\trx_firmware_statistics->pktsjumbo =\n\t\t    in_be32(&p_rx_fw_statistics_pram->pktsjumbo);\n\t\trx_firmware_statistics->frlossinmacer =\n\t\t    in_be32(&p_rx_fw_statistics_pram->frlossinmacer);\n\t\trx_firmware_statistics->pausefr =\n\t\t    in_be32(&p_rx_fw_statistics_pram->pausefr);\n\t\tfor (i = 0; i < 0x4; i++)\n\t\t\trx_firmware_statistics->res1[i] =\n\t\t\t    p_rx_fw_statistics_pram->res1[i];\n\t\trx_firmware_statistics->removevlan =\n\t\t    in_be32(&p_rx_fw_statistics_pram->removevlan);\n\t\trx_firmware_statistics->replacevlan =\n\t\t    in_be32(&p_rx_fw_statistics_pram->replacevlan);\n\t\trx_firmware_statistics->insertvlan =\n\t\t    in_be32(&p_rx_fw_statistics_pram->insertvlan);\n\t}\n\n\t \n\tif (hardware_statistics &&\n\t    (in_be32(&uf_regs->upsmr) & UCC_GETH_UPSMR_HSE)) {\n\t\thardware_statistics->tx64 = in_be32(&ug_regs->tx64);\n\t\thardware_statistics->tx127 = in_be32(&ug_regs->tx127);\n\t\thardware_statistics->tx255 = in_be32(&ug_regs->tx255);\n\t\thardware_statistics->rx64 = in_be32(&ug_regs->rx64);\n\t\thardware_statistics->rx127 = in_be32(&ug_regs->rx127);\n\t\thardware_statistics->rx255 = in_be32(&ug_regs->rx255);\n\t\thardware_statistics->txok = in_be32(&ug_regs->txok);\n\t\thardware_statistics->txcf = in_be16(&ug_regs->txcf);\n\t\thardware_statistics->tmca = in_be32(&ug_regs->tmca);\n\t\thardware_statistics->tbca = in_be32(&ug_regs->tbca);\n\t\thardware_statistics->rxfok = in_be32(&ug_regs->rxfok);\n\t\thardware_statistics->rxbok = in_be32(&ug_regs->rxbok);\n\t\thardware_statistics->rbyt = in_be32(&ug_regs->rbyt);\n\t\thardware_statistics->rmca = in_be32(&ug_regs->rmca);\n\t\thardware_statistics->rbca = in_be32(&ug_regs->rbca);\n\t}\n}\n\nstatic void dump_bds(struct ucc_geth_private *ugeth)\n{\n\tint i;\n\tint length;\n\n\tfor (i = 0; i < ucc_geth_tx_queues(ugeth->ug_info); i++) {\n\t\tif (ugeth->p_tx_bd_ring[i]) {\n\t\t\tlength =\n\t\t\t    (ugeth->ug_info->bdRingLenTx[i] *\n\t\t\t     sizeof(struct qe_bd));\n\t\t\tpr_info(\"TX BDs[%d]\\n\", i);\n\t\t\tmem_disp(ugeth->p_tx_bd_ring[i], length);\n\t\t}\n\t}\n\tfor (i = 0; i < ucc_geth_rx_queues(ugeth->ug_info); i++) {\n\t\tif (ugeth->p_rx_bd_ring[i]) {\n\t\t\tlength =\n\t\t\t    (ugeth->ug_info->bdRingLenRx[i] *\n\t\t\t     sizeof(struct qe_bd));\n\t\t\tpr_info(\"RX BDs[%d]\\n\", i);\n\t\t\tmem_disp(ugeth->p_rx_bd_ring[i], length);\n\t\t}\n\t}\n}\n\nstatic void dump_regs(struct ucc_geth_private *ugeth)\n{\n\tint i;\n\n\tpr_info(\"UCC%d Geth registers:\\n\", ugeth->ug_info->uf_info.ucc_num + 1);\n\tpr_info(\"Base address: 0x%08x\\n\", (u32)ugeth->ug_regs);\n\n\tpr_info(\"maccfg1    : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->maccfg1,\n\t\tin_be32(&ugeth->ug_regs->maccfg1));\n\tpr_info(\"maccfg2    : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->maccfg2,\n\t\tin_be32(&ugeth->ug_regs->maccfg2));\n\tpr_info(\"ipgifg     : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->ipgifg,\n\t\tin_be32(&ugeth->ug_regs->ipgifg));\n\tpr_info(\"hafdup     : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->hafdup,\n\t\tin_be32(&ugeth->ug_regs->hafdup));\n\tpr_info(\"ifctl      : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->ifctl,\n\t\tin_be32(&ugeth->ug_regs->ifctl));\n\tpr_info(\"ifstat     : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->ifstat,\n\t\tin_be32(&ugeth->ug_regs->ifstat));\n\tpr_info(\"macstnaddr1: addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->macstnaddr1,\n\t\tin_be32(&ugeth->ug_regs->macstnaddr1));\n\tpr_info(\"macstnaddr2: addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->macstnaddr2,\n\t\tin_be32(&ugeth->ug_regs->macstnaddr2));\n\tpr_info(\"uempr      : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->uempr,\n\t\tin_be32(&ugeth->ug_regs->uempr));\n\tpr_info(\"utbipar    : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->utbipar,\n\t\tin_be32(&ugeth->ug_regs->utbipar));\n\tpr_info(\"uescr      : addr - 0x%08x, val - 0x%04x\\n\",\n\t\t(u32)&ugeth->ug_regs->uescr,\n\t\tin_be16(&ugeth->ug_regs->uescr));\n\tpr_info(\"tx64       : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->tx64,\n\t\tin_be32(&ugeth->ug_regs->tx64));\n\tpr_info(\"tx127      : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->tx127,\n\t\tin_be32(&ugeth->ug_regs->tx127));\n\tpr_info(\"tx255      : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->tx255,\n\t\tin_be32(&ugeth->ug_regs->tx255));\n\tpr_info(\"rx64       : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->rx64,\n\t\tin_be32(&ugeth->ug_regs->rx64));\n\tpr_info(\"rx127      : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->rx127,\n\t\tin_be32(&ugeth->ug_regs->rx127));\n\tpr_info(\"rx255      : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->rx255,\n\t\tin_be32(&ugeth->ug_regs->rx255));\n\tpr_info(\"txok       : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->txok,\n\t\tin_be32(&ugeth->ug_regs->txok));\n\tpr_info(\"txcf       : addr - 0x%08x, val - 0x%04x\\n\",\n\t\t(u32)&ugeth->ug_regs->txcf,\n\t\tin_be16(&ugeth->ug_regs->txcf));\n\tpr_info(\"tmca       : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->tmca,\n\t\tin_be32(&ugeth->ug_regs->tmca));\n\tpr_info(\"tbca       : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->tbca,\n\t\tin_be32(&ugeth->ug_regs->tbca));\n\tpr_info(\"rxfok      : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->rxfok,\n\t\tin_be32(&ugeth->ug_regs->rxfok));\n\tpr_info(\"rxbok      : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->rxbok,\n\t\tin_be32(&ugeth->ug_regs->rxbok));\n\tpr_info(\"rbyt       : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->rbyt,\n\t\tin_be32(&ugeth->ug_regs->rbyt));\n\tpr_info(\"rmca       : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->rmca,\n\t\tin_be32(&ugeth->ug_regs->rmca));\n\tpr_info(\"rbca       : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->rbca,\n\t\tin_be32(&ugeth->ug_regs->rbca));\n\tpr_info(\"scar       : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->scar,\n\t\tin_be32(&ugeth->ug_regs->scar));\n\tpr_info(\"scam       : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t(u32)&ugeth->ug_regs->scam,\n\t\tin_be32(&ugeth->ug_regs->scam));\n\n\tif (ugeth->p_thread_data_tx) {\n\t\tint count = ucc_geth_thread_count(ugeth->ug_info->numThreadsTx);\n\n\t\tpr_info(\"Thread data TXs:\\n\");\n\t\tpr_info(\"Base address: 0x%08x\\n\",\n\t\t\t(u32)ugeth->p_thread_data_tx);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tpr_info(\"Thread data TX[%d]:\\n\", i);\n\t\t\tpr_info(\"Base address: 0x%08x\\n\",\n\t\t\t\t(u32)&ugeth->p_thread_data_tx[i]);\n\t\t\tmem_disp((u8 *) & ugeth->p_thread_data_tx[i],\n\t\t\t\t sizeof(struct ucc_geth_thread_data_tx));\n\t\t}\n\t}\n\tif (ugeth->p_thread_data_rx) {\n\t\tint count = ucc_geth_thread_count(ugeth->ug_info->numThreadsRx);\n\n\t\tpr_info(\"Thread data RX:\\n\");\n\t\tpr_info(\"Base address: 0x%08x\\n\",\n\t\t\t(u32)ugeth->p_thread_data_rx);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tpr_info(\"Thread data RX[%d]:\\n\", i);\n\t\t\tpr_info(\"Base address: 0x%08x\\n\",\n\t\t\t\t(u32)&ugeth->p_thread_data_rx[i]);\n\t\t\tmem_disp((u8 *) & ugeth->p_thread_data_rx[i],\n\t\t\t\t sizeof(struct ucc_geth_thread_data_rx));\n\t\t}\n\t}\n\tif (ugeth->p_exf_glbl_param) {\n\t\tpr_info(\"EXF global param:\\n\");\n\t\tpr_info(\"Base address: 0x%08x\\n\",\n\t\t\t(u32)ugeth->p_exf_glbl_param);\n\t\tmem_disp((u8 *) ugeth->p_exf_glbl_param,\n\t\t\t sizeof(*ugeth->p_exf_glbl_param));\n\t}\n\tif (ugeth->p_tx_glbl_pram) {\n\t\tpr_info(\"TX global param:\\n\");\n\t\tpr_info(\"Base address: 0x%08x\\n\", (u32)ugeth->p_tx_glbl_pram);\n\t\tpr_info(\"temoder      : addr - 0x%08x, val - 0x%04x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->temoder,\n\t\t\tin_be16(&ugeth->p_tx_glbl_pram->temoder));\n\t       pr_info(\"sqptr        : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->sqptr,\n\t\t\tin_be32(&ugeth->p_tx_glbl_pram->sqptr));\n\t\tpr_info(\"schedulerbasepointer: addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->schedulerbasepointer,\n\t\t\tin_be32(&ugeth->p_tx_glbl_pram->schedulerbasepointer));\n\t\tpr_info(\"txrmonbaseptr: addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->txrmonbaseptr,\n\t\t\tin_be32(&ugeth->p_tx_glbl_pram->txrmonbaseptr));\n\t\tpr_info(\"tstate       : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->tstate,\n\t\t\tin_be32(&ugeth->p_tx_glbl_pram->tstate));\n\t\tpr_info(\"iphoffset[0] : addr - 0x%08x, val - 0x%02x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->iphoffset[0],\n\t\t\tugeth->p_tx_glbl_pram->iphoffset[0]);\n\t\tpr_info(\"iphoffset[1] : addr - 0x%08x, val - 0x%02x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->iphoffset[1],\n\t\t\tugeth->p_tx_glbl_pram->iphoffset[1]);\n\t\tpr_info(\"iphoffset[2] : addr - 0x%08x, val - 0x%02x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->iphoffset[2],\n\t\t\tugeth->p_tx_glbl_pram->iphoffset[2]);\n\t\tpr_info(\"iphoffset[3] : addr - 0x%08x, val - 0x%02x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->iphoffset[3],\n\t\t\tugeth->p_tx_glbl_pram->iphoffset[3]);\n\t\tpr_info(\"iphoffset[4] : addr - 0x%08x, val - 0x%02x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->iphoffset[4],\n\t\t\tugeth->p_tx_glbl_pram->iphoffset[4]);\n\t\tpr_info(\"iphoffset[5] : addr - 0x%08x, val - 0x%02x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->iphoffset[5],\n\t\t\tugeth->p_tx_glbl_pram->iphoffset[5]);\n\t\tpr_info(\"iphoffset[6] : addr - 0x%08x, val - 0x%02x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->iphoffset[6],\n\t\t\tugeth->p_tx_glbl_pram->iphoffset[6]);\n\t\tpr_info(\"iphoffset[7] : addr - 0x%08x, val - 0x%02x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->iphoffset[7],\n\t\t\tugeth->p_tx_glbl_pram->iphoffset[7]);\n\t\tpr_info(\"vtagtable[0] : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->vtagtable[0],\n\t\t\tin_be32(&ugeth->p_tx_glbl_pram->vtagtable[0]));\n\t\tpr_info(\"vtagtable[1] : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->vtagtable[1],\n\t\t\tin_be32(&ugeth->p_tx_glbl_pram->vtagtable[1]));\n\t\tpr_info(\"vtagtable[2] : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->vtagtable[2],\n\t\t\tin_be32(&ugeth->p_tx_glbl_pram->vtagtable[2]));\n\t\tpr_info(\"vtagtable[3] : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->vtagtable[3],\n\t\t\tin_be32(&ugeth->p_tx_glbl_pram->vtagtable[3]));\n\t\tpr_info(\"vtagtable[4] : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->vtagtable[4],\n\t\t\tin_be32(&ugeth->p_tx_glbl_pram->vtagtable[4]));\n\t\tpr_info(\"vtagtable[5] : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->vtagtable[5],\n\t\t\tin_be32(&ugeth->p_tx_glbl_pram->vtagtable[5]));\n\t\tpr_info(\"vtagtable[6] : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->vtagtable[6],\n\t\t\tin_be32(&ugeth->p_tx_glbl_pram->vtagtable[6]));\n\t\tpr_info(\"vtagtable[7] : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->vtagtable[7],\n\t\t\tin_be32(&ugeth->p_tx_glbl_pram->vtagtable[7]));\n\t\tpr_info(\"tqptr        : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_tx_glbl_pram->tqptr,\n\t\t\tin_be32(&ugeth->p_tx_glbl_pram->tqptr));\n\t}\n\tif (ugeth->p_rx_glbl_pram) {\n\t\tpr_info(\"RX global param:\\n\");\n\t\tpr_info(\"Base address: 0x%08x\\n\", (u32)ugeth->p_rx_glbl_pram);\n\t\tpr_info(\"remoder         : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->remoder,\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->remoder));\n\t\tpr_info(\"rqptr           : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->rqptr,\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->rqptr));\n\t\tpr_info(\"typeorlen       : addr - 0x%08x, val - 0x%04x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->typeorlen,\n\t\t\tin_be16(&ugeth->p_rx_glbl_pram->typeorlen));\n\t\tpr_info(\"rxgstpack       : addr - 0x%08x, val - 0x%02x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->rxgstpack,\n\t\t\tugeth->p_rx_glbl_pram->rxgstpack);\n\t\tpr_info(\"rxrmonbaseptr   : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->rxrmonbaseptr,\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->rxrmonbaseptr));\n\t\tpr_info(\"intcoalescingptr: addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->intcoalescingptr,\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->intcoalescingptr));\n\t\tpr_info(\"rstate          : addr - 0x%08x, val - 0x%02x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->rstate,\n\t\t\tugeth->p_rx_glbl_pram->rstate);\n\t\tpr_info(\"mrblr           : addr - 0x%08x, val - 0x%04x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->mrblr,\n\t\t\tin_be16(&ugeth->p_rx_glbl_pram->mrblr));\n\t\tpr_info(\"rbdqptr         : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->rbdqptr,\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->rbdqptr));\n\t\tpr_info(\"mflr            : addr - 0x%08x, val - 0x%04x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->mflr,\n\t\t\tin_be16(&ugeth->p_rx_glbl_pram->mflr));\n\t\tpr_info(\"minflr          : addr - 0x%08x, val - 0x%04x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->minflr,\n\t\t\tin_be16(&ugeth->p_rx_glbl_pram->minflr));\n\t\tpr_info(\"maxd1           : addr - 0x%08x, val - 0x%04x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->maxd1,\n\t\t\tin_be16(&ugeth->p_rx_glbl_pram->maxd1));\n\t\tpr_info(\"maxd2           : addr - 0x%08x, val - 0x%04x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->maxd2,\n\t\t\tin_be16(&ugeth->p_rx_glbl_pram->maxd2));\n\t\tpr_info(\"ecamptr         : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->ecamptr,\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->ecamptr));\n\t\tpr_info(\"l2qt            : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->l2qt,\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->l2qt));\n\t\tpr_info(\"l3qt[0]         : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->l3qt[0],\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->l3qt[0]));\n\t\tpr_info(\"l3qt[1]         : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->l3qt[1],\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->l3qt[1]));\n\t\tpr_info(\"l3qt[2]         : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->l3qt[2],\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->l3qt[2]));\n\t\tpr_info(\"l3qt[3]         : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->l3qt[3],\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->l3qt[3]));\n\t\tpr_info(\"l3qt[4]         : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->l3qt[4],\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->l3qt[4]));\n\t\tpr_info(\"l3qt[5]         : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->l3qt[5],\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->l3qt[5]));\n\t\tpr_info(\"l3qt[6]         : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->l3qt[6],\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->l3qt[6]));\n\t\tpr_info(\"l3qt[7]         : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->l3qt[7],\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->l3qt[7]));\n\t\tpr_info(\"vlantype        : addr - 0x%08x, val - 0x%04x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->vlantype,\n\t\t\tin_be16(&ugeth->p_rx_glbl_pram->vlantype));\n\t\tpr_info(\"vlantci         : addr - 0x%08x, val - 0x%04x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->vlantci,\n\t\t\tin_be16(&ugeth->p_rx_glbl_pram->vlantci));\n\t\tfor (i = 0; i < 64; i++)\n\t\t\tpr_info(\"addressfiltering[%d]: addr - 0x%08x, val - 0x%02x\\n\",\n\t\t\t\ti,\n\t\t\t\t(u32)&ugeth->p_rx_glbl_pram->addressfiltering[i],\n\t\t\t\tugeth->p_rx_glbl_pram->addressfiltering[i]);\n\t\tpr_info(\"exfGlobalParam  : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t(u32)&ugeth->p_rx_glbl_pram->exfGlobalParam,\n\t\t\tin_be32(&ugeth->p_rx_glbl_pram->exfGlobalParam));\n\t}\n\tif (ugeth->p_send_q_mem_reg) {\n\t\tpr_info(\"Send Q memory registers:\\n\");\n\t\tpr_info(\"Base address: 0x%08x\\n\", (u32)ugeth->p_send_q_mem_reg);\n\t\tfor (i = 0; i < ucc_geth_tx_queues(ugeth->ug_info); i++) {\n\t\t\tpr_info(\"SQQD[%d]:\\n\", i);\n\t\t\tpr_info(\"Base address: 0x%08x\\n\",\n\t\t\t\t(u32)&ugeth->p_send_q_mem_reg->sqqd[i]);\n\t\t\tmem_disp((u8 *) & ugeth->p_send_q_mem_reg->sqqd[i],\n\t\t\t\t sizeof(struct ucc_geth_send_queue_qd));\n\t\t}\n\t}\n\tif (ugeth->p_scheduler) {\n\t\tpr_info(\"Scheduler:\\n\");\n\t\tpr_info(\"Base address: 0x%08x\\n\", (u32)ugeth->p_scheduler);\n\t\tmem_disp((u8 *) ugeth->p_scheduler,\n\t\t\t sizeof(*ugeth->p_scheduler));\n\t}\n\tif (ugeth->p_tx_fw_statistics_pram) {\n\t\tpr_info(\"TX FW statistics pram:\\n\");\n\t\tpr_info(\"Base address: 0x%08x\\n\",\n\t\t\t(u32)ugeth->p_tx_fw_statistics_pram);\n\t\tmem_disp((u8 *) ugeth->p_tx_fw_statistics_pram,\n\t\t\t sizeof(*ugeth->p_tx_fw_statistics_pram));\n\t}\n\tif (ugeth->p_rx_fw_statistics_pram) {\n\t\tpr_info(\"RX FW statistics pram:\\n\");\n\t\tpr_info(\"Base address: 0x%08x\\n\",\n\t\t\t(u32)ugeth->p_rx_fw_statistics_pram);\n\t\tmem_disp((u8 *) ugeth->p_rx_fw_statistics_pram,\n\t\t\t sizeof(*ugeth->p_rx_fw_statistics_pram));\n\t}\n\tif (ugeth->p_rx_irq_coalescing_tbl) {\n\t\tpr_info(\"RX IRQ coalescing tables:\\n\");\n\t\tpr_info(\"Base address: 0x%08x\\n\",\n\t\t\t(u32)ugeth->p_rx_irq_coalescing_tbl);\n\t\tfor (i = 0; i < ucc_geth_rx_queues(ugeth->ug_info); i++) {\n\t\t\tpr_info(\"RX IRQ coalescing table entry[%d]:\\n\", i);\n\t\t\tpr_info(\"Base address: 0x%08x\\n\",\n\t\t\t\t(u32)&ugeth->p_rx_irq_coalescing_tbl->\n\t\t\t\tcoalescingentry[i]);\n\t\t\tpr_info(\"interruptcoalescingmaxvalue: addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t\t(u32)&ugeth->p_rx_irq_coalescing_tbl->\n\t\t\t\tcoalescingentry[i].interruptcoalescingmaxvalue,\n\t\t\t\tin_be32(&ugeth->p_rx_irq_coalescing_tbl->\n\t\t\t\t\tcoalescingentry[i].\n\t\t\t\t\tinterruptcoalescingmaxvalue));\n\t\t\tpr_info(\"interruptcoalescingcounter : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t\t(u32)&ugeth->p_rx_irq_coalescing_tbl->\n\t\t\t\tcoalescingentry[i].interruptcoalescingcounter,\n\t\t\t\tin_be32(&ugeth->p_rx_irq_coalescing_tbl->\n\t\t\t\t\tcoalescingentry[i].\n\t\t\t\t\tinterruptcoalescingcounter));\n\t\t}\n\t}\n\tif (ugeth->p_rx_bd_qs_tbl) {\n\t\tpr_info(\"RX BD QS tables:\\n\");\n\t\tpr_info(\"Base address: 0x%08x\\n\", (u32)ugeth->p_rx_bd_qs_tbl);\n\t\tfor (i = 0; i < ucc_geth_rx_queues(ugeth->ug_info); i++) {\n\t\t\tpr_info(\"RX BD QS table[%d]:\\n\", i);\n\t\t\tpr_info(\"Base address: 0x%08x\\n\",\n\t\t\t\t(u32)&ugeth->p_rx_bd_qs_tbl[i]);\n\t\t\tpr_info(\"bdbaseptr        : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t\t(u32)&ugeth->p_rx_bd_qs_tbl[i].bdbaseptr,\n\t\t\t\tin_be32(&ugeth->p_rx_bd_qs_tbl[i].bdbaseptr));\n\t\t\tpr_info(\"bdptr            : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t\t(u32)&ugeth->p_rx_bd_qs_tbl[i].bdptr,\n\t\t\t\tin_be32(&ugeth->p_rx_bd_qs_tbl[i].bdptr));\n\t\t\tpr_info(\"externalbdbaseptr: addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t\t(u32)&ugeth->p_rx_bd_qs_tbl[i].externalbdbaseptr,\n\t\t\t\tin_be32(&ugeth->p_rx_bd_qs_tbl[i].\n\t\t\t\t\texternalbdbaseptr));\n\t\t\tpr_info(\"externalbdptr    : addr - 0x%08x, val - 0x%08x\\n\",\n\t\t\t\t(u32)&ugeth->p_rx_bd_qs_tbl[i].externalbdptr,\n\t\t\t\tin_be32(&ugeth->p_rx_bd_qs_tbl[i].externalbdptr));\n\t\t\tpr_info(\"ucode RX Prefetched BDs:\\n\");\n\t\t\tpr_info(\"Base address: 0x%08x\\n\",\n\t\t\t\t(u32)qe_muram_addr(in_be32\n\t\t\t\t\t\t   (&ugeth->p_rx_bd_qs_tbl[i].\n\t\t\t\t\t\t    bdbaseptr)));\n\t\t\tmem_disp((u8 *)\n\t\t\t\t qe_muram_addr(in_be32\n\t\t\t\t\t       (&ugeth->p_rx_bd_qs_tbl[i].\n\t\t\t\t\t\tbdbaseptr)),\n\t\t\t\t sizeof(struct ucc_geth_rx_prefetched_bds));\n\t\t}\n\t}\n\tif (ugeth->p_init_enet_param_shadow) {\n\t\tint size;\n\t\tpr_info(\"Init enet param shadow:\\n\");\n\t\tpr_info(\"Base address: 0x%08x\\n\",\n\t\t\t(u32) ugeth->p_init_enet_param_shadow);\n\t\tmem_disp((u8 *) ugeth->p_init_enet_param_shadow,\n\t\t\t sizeof(*ugeth->p_init_enet_param_shadow));\n\n\t\tsize = sizeof(struct ucc_geth_thread_rx_pram);\n\t\tif (ugeth->ug_info->rxExtendedFiltering) {\n\t\t\tsize +=\n\t\t\t    THREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING;\n\t\t\tif (ugeth->ug_info->largestexternallookupkeysize ==\n\t\t\t    QE_FLTR_TABLE_LOOKUP_KEY_SIZE_8_BYTES)\n\t\t\t\tsize +=\n\t\t\tTHREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING_8;\n\t\t\tif (ugeth->ug_info->largestexternallookupkeysize ==\n\t\t\t    QE_FLTR_TABLE_LOOKUP_KEY_SIZE_16_BYTES)\n\t\t\t\tsize +=\n\t\t\tTHREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING_16;\n\t\t}\n\n\t\tdump_init_enet_entries(ugeth,\n\t\t\t\t       &(ugeth->p_init_enet_param_shadow->\n\t\t\t\t\t txthread[0]),\n\t\t\t\t       ENET_INIT_PARAM_MAX_ENTRIES_TX,\n\t\t\t\t       sizeof(struct ucc_geth_thread_tx_pram),\n\t\t\t\t       ugeth->ug_info->riscTx, 0);\n\t\tdump_init_enet_entries(ugeth,\n\t\t\t\t       &(ugeth->p_init_enet_param_shadow->\n\t\t\t\t\t rxthread[0]),\n\t\t\t\t       ENET_INIT_PARAM_MAX_ENTRIES_RX, size,\n\t\t\t\t       ugeth->ug_info->riscRx, 1);\n\t}\n}\n#endif  \n\nstatic void init_default_reg_vals(u32 __iomem *upsmr_register,\n\t\t\t\t  u32 __iomem *maccfg1_register,\n\t\t\t\t  u32 __iomem *maccfg2_register)\n{\n\tout_be32(upsmr_register, UCC_GETH_UPSMR_INIT);\n\tout_be32(maccfg1_register, UCC_GETH_MACCFG1_INIT);\n\tout_be32(maccfg2_register, UCC_GETH_MACCFG2_INIT);\n}\n\nstatic int init_half_duplex_params(int alt_beb,\n\t\t\t\t   int back_pressure_no_backoff,\n\t\t\t\t   int no_backoff,\n\t\t\t\t   int excess_defer,\n\t\t\t\t   u8 alt_beb_truncation,\n\t\t\t\t   u8 max_retransmissions,\n\t\t\t\t   u8 collision_window,\n\t\t\t\t   u32 __iomem *hafdup_register)\n{\n\tu32 value = 0;\n\n\tif ((alt_beb_truncation > HALFDUP_ALT_BEB_TRUNCATION_MAX) ||\n\t    (max_retransmissions > HALFDUP_MAX_RETRANSMISSION_MAX) ||\n\t    (collision_window > HALFDUP_COLLISION_WINDOW_MAX))\n\t\treturn -EINVAL;\n\n\tvalue = (u32) (alt_beb_truncation << HALFDUP_ALT_BEB_TRUNCATION_SHIFT);\n\n\tif (alt_beb)\n\t\tvalue |= HALFDUP_ALT_BEB;\n\tif (back_pressure_no_backoff)\n\t\tvalue |= HALFDUP_BACK_PRESSURE_NO_BACKOFF;\n\tif (no_backoff)\n\t\tvalue |= HALFDUP_NO_BACKOFF;\n\tif (excess_defer)\n\t\tvalue |= HALFDUP_EXCESSIVE_DEFER;\n\n\tvalue |= (max_retransmissions << HALFDUP_MAX_RETRANSMISSION_SHIFT);\n\n\tvalue |= collision_window;\n\n\tout_be32(hafdup_register, value);\n\treturn 0;\n}\n\nstatic int init_inter_frame_gap_params(u8 non_btb_cs_ipg,\n\t\t\t\t       u8 non_btb_ipg,\n\t\t\t\t       u8 min_ifg,\n\t\t\t\t       u8 btb_ipg,\n\t\t\t\t       u32 __iomem *ipgifg_register)\n{\n\tu32 value = 0;\n\n\t \n\tif (non_btb_cs_ipg > non_btb_ipg)\n\t\treturn -EINVAL;\n\n\tif ((non_btb_cs_ipg > IPGIFG_NON_BACK_TO_BACK_IFG_PART1_MAX) ||\n\t    (non_btb_ipg > IPGIFG_NON_BACK_TO_BACK_IFG_PART2_MAX) ||\n\t     \n\t    (btb_ipg > IPGIFG_BACK_TO_BACK_IFG_MAX))\n\t\treturn -EINVAL;\n\n\tvalue |=\n\t    ((non_btb_cs_ipg << IPGIFG_NON_BACK_TO_BACK_IFG_PART1_SHIFT) &\n\t     IPGIFG_NBTB_CS_IPG_MASK);\n\tvalue |=\n\t    ((non_btb_ipg << IPGIFG_NON_BACK_TO_BACK_IFG_PART2_SHIFT) &\n\t     IPGIFG_NBTB_IPG_MASK);\n\tvalue |=\n\t    ((min_ifg << IPGIFG_MINIMUM_IFG_ENFORCEMENT_SHIFT) &\n\t     IPGIFG_MIN_IFG_MASK);\n\tvalue |= (btb_ipg & IPGIFG_BTB_IPG_MASK);\n\n\tout_be32(ipgifg_register, value);\n\treturn 0;\n}\n\nint init_flow_control_params(u32 automatic_flow_control_mode,\n\t\t\t\t    int rx_flow_control_enable,\n\t\t\t\t    int tx_flow_control_enable,\n\t\t\t\t    u16 pause_period,\n\t\t\t\t    u16 extension_field,\n\t\t\t\t    u32 __iomem *upsmr_register,\n\t\t\t\t    u32 __iomem *uempr_register,\n\t\t\t\t    u32 __iomem *maccfg1_register)\n{\n\tu32 value = 0;\n\n\t \n\tvalue = (u32) pause_period << UEMPR_PAUSE_TIME_VALUE_SHIFT;\n\tvalue |= (u32) extension_field << UEMPR_EXTENDED_PAUSE_TIME_VALUE_SHIFT;\n\tout_be32(uempr_register, value);\n\n\t \n\tsetbits32(upsmr_register, automatic_flow_control_mode);\n\n\tvalue = in_be32(maccfg1_register);\n\tif (rx_flow_control_enable)\n\t\tvalue |= MACCFG1_FLOW_RX;\n\tif (tx_flow_control_enable)\n\t\tvalue |= MACCFG1_FLOW_TX;\n\tout_be32(maccfg1_register, value);\n\n\treturn 0;\n}\n\nstatic int init_hw_statistics_gathering_mode(int enable_hardware_statistics,\n\t\t\t\t\t     int auto_zero_hardware_statistics,\n\t\t\t\t\t     u32 __iomem *upsmr_register,\n\t\t\t\t\t     u16 __iomem *uescr_register)\n{\n\tu16 uescr_value = 0;\n\n\t \n\tif (enable_hardware_statistics)\n\t\tsetbits32(upsmr_register, UCC_GETH_UPSMR_HSE);\n\n\t \n\tuescr_value = in_be16(uescr_register);\n\tuescr_value |= UESCR_CLRCNT;\n\t \n\tif (auto_zero_hardware_statistics)\n\t\tuescr_value |= UESCR_AUTOZ;\n\tout_be16(uescr_register, uescr_value);\n\n\treturn 0;\n}\n\nstatic int init_firmware_statistics_gathering_mode(int\n\t\tenable_tx_firmware_statistics,\n\t\tint enable_rx_firmware_statistics,\n\t\tu32 __iomem *tx_rmon_base_ptr,\n\t\tu32 tx_firmware_statistics_structure_address,\n\t\tu32 __iomem *rx_rmon_base_ptr,\n\t\tu32 rx_firmware_statistics_structure_address,\n\t\tu16 __iomem *temoder_register,\n\t\tu32 __iomem *remoder_register)\n{\n\t \n\t \n\n\tif (enable_tx_firmware_statistics) {\n\t\tout_be32(tx_rmon_base_ptr,\n\t\t\t tx_firmware_statistics_structure_address);\n\t\tsetbits16(temoder_register, TEMODER_TX_RMON_STATISTICS_ENABLE);\n\t}\n\n\tif (enable_rx_firmware_statistics) {\n\t\tout_be32(rx_rmon_base_ptr,\n\t\t\t rx_firmware_statistics_structure_address);\n\t\tsetbits32(remoder_register, REMODER_RX_RMON_STATISTICS_ENABLE);\n\t}\n\n\treturn 0;\n}\n\nstatic int init_mac_station_addr_regs(u8 address_byte_0,\n\t\t\t\t      u8 address_byte_1,\n\t\t\t\t      u8 address_byte_2,\n\t\t\t\t      u8 address_byte_3,\n\t\t\t\t      u8 address_byte_4,\n\t\t\t\t      u8 address_byte_5,\n\t\t\t\t      u32 __iomem *macstnaddr1_register,\n\t\t\t\t      u32 __iomem *macstnaddr2_register)\n{\n\tu32 value = 0;\n\n\t \n\t \n\n\t \n\n\t \n\t \n\t \n\t \n\tvalue |= (u32) ((address_byte_2 << 0) & 0x000000FF);\n\tvalue |= (u32) ((address_byte_3 << 8) & 0x0000FF00);\n\tvalue |= (u32) ((address_byte_4 << 16) & 0x00FF0000);\n\tvalue |= (u32) ((address_byte_5 << 24) & 0xFF000000);\n\n\tout_be32(macstnaddr1_register, value);\n\n\t \n\n\t \n\t \n\t \n\t \n\tvalue = 0;\n\tvalue |= (u32) ((address_byte_0 << 16) & 0x00FF0000);\n\tvalue |= (u32) ((address_byte_1 << 24) & 0xFF000000);\n\n\tout_be32(macstnaddr2_register, value);\n\n\treturn 0;\n}\n\nstatic int init_check_frame_length_mode(int length_check,\n\t\t\t\t\tu32 __iomem *maccfg2_register)\n{\n\tu32 value = 0;\n\n\tvalue = in_be32(maccfg2_register);\n\n\tif (length_check)\n\t\tvalue |= MACCFG2_LC;\n\telse\n\t\tvalue &= ~MACCFG2_LC;\n\n\tout_be32(maccfg2_register, value);\n\treturn 0;\n}\n\nstatic int init_preamble_length(u8 preamble_length,\n\t\t\t\tu32 __iomem *maccfg2_register)\n{\n\tif ((preamble_length < 3) || (preamble_length > 7))\n\t\treturn -EINVAL;\n\n\tclrsetbits_be32(maccfg2_register, MACCFG2_PREL_MASK,\n\t\t\tpreamble_length << MACCFG2_PREL_SHIFT);\n\n\treturn 0;\n}\n\nstatic int init_rx_parameters(int reject_broadcast,\n\t\t\t      int receive_short_frames,\n\t\t\t      int promiscuous, u32 __iomem *upsmr_register)\n{\n\tu32 value = 0;\n\n\tvalue = in_be32(upsmr_register);\n\n\tif (reject_broadcast)\n\t\tvalue |= UCC_GETH_UPSMR_BRO;\n\telse\n\t\tvalue &= ~UCC_GETH_UPSMR_BRO;\n\n\tif (receive_short_frames)\n\t\tvalue |= UCC_GETH_UPSMR_RSH;\n\telse\n\t\tvalue &= ~UCC_GETH_UPSMR_RSH;\n\n\tif (promiscuous)\n\t\tvalue |= UCC_GETH_UPSMR_PRO;\n\telse\n\t\tvalue &= ~UCC_GETH_UPSMR_PRO;\n\n\tout_be32(upsmr_register, value);\n\n\treturn 0;\n}\n\nstatic int init_max_rx_buff_len(u16 max_rx_buf_len,\n\t\t\t\tu16 __iomem *mrblr_register)\n{\n\t \n\tif ((max_rx_buf_len == 0) ||\n\t    (max_rx_buf_len % UCC_GETH_MRBLR_ALIGNMENT))\n\t\treturn -EINVAL;\n\n\tout_be16(mrblr_register, max_rx_buf_len);\n\treturn 0;\n}\n\nstatic int init_min_frame_len(u16 min_frame_length,\n\t\t\t      u16 __iomem *minflr_register,\n\t\t\t      u16 __iomem *mrblr_register)\n{\n\tu16 mrblr_value = 0;\n\n\tmrblr_value = in_be16(mrblr_register);\n\tif (min_frame_length >= (mrblr_value - 4))\n\t\treturn -EINVAL;\n\n\tout_be16(minflr_register, min_frame_length);\n\treturn 0;\n}\n\nstatic int adjust_enet_interface(struct ucc_geth_private *ugeth)\n{\n\tstruct ucc_geth_info *ug_info;\n\tstruct ucc_geth __iomem *ug_regs;\n\tstruct ucc_fast __iomem *uf_regs;\n\tint ret_val;\n\tu32 upsmr, maccfg2;\n\tu16 value;\n\n\tugeth_vdbg(\"%s: IN\", __func__);\n\n\tug_info = ugeth->ug_info;\n\tug_regs = ugeth->ug_regs;\n\tuf_regs = ugeth->uccf->uf_regs;\n\n\t \n\tmaccfg2 = in_be32(&ug_regs->maccfg2);\n\tmaccfg2 &= ~MACCFG2_INTERFACE_MODE_MASK;\n\tif ((ugeth->max_speed == SPEED_10) ||\n\t    (ugeth->max_speed == SPEED_100))\n\t\tmaccfg2 |= MACCFG2_INTERFACE_MODE_NIBBLE;\n\telse if (ugeth->max_speed == SPEED_1000)\n\t\tmaccfg2 |= MACCFG2_INTERFACE_MODE_BYTE;\n\tmaccfg2 |= ug_info->padAndCrc;\n\tout_be32(&ug_regs->maccfg2, maccfg2);\n\n\t \n\tupsmr = in_be32(&uf_regs->upsmr);\n\tupsmr &= ~(UCC_GETH_UPSMR_RPM | UCC_GETH_UPSMR_R10M |\n\t\t   UCC_GETH_UPSMR_TBIM | UCC_GETH_UPSMR_RMM);\n\tif ((ugeth->phy_interface == PHY_INTERFACE_MODE_RMII) ||\n\t    (ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII) ||\n\t    (ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII_ID) ||\n\t    (ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII_RXID) ||\n\t    (ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII_TXID) ||\n\t    (ugeth->phy_interface == PHY_INTERFACE_MODE_RTBI)) {\n\t\tif (ugeth->phy_interface != PHY_INTERFACE_MODE_RMII)\n\t\t\tupsmr |= UCC_GETH_UPSMR_RPM;\n\t\tswitch (ugeth->max_speed) {\n\t\tcase SPEED_10:\n\t\t\tupsmr |= UCC_GETH_UPSMR_R10M;\n\t\t\tfallthrough;\n\t\tcase SPEED_100:\n\t\t\tif (ugeth->phy_interface != PHY_INTERFACE_MODE_RTBI)\n\t\t\t\tupsmr |= UCC_GETH_UPSMR_RMM;\n\t\t}\n\t}\n\tif ((ugeth->phy_interface == PHY_INTERFACE_MODE_TBI) ||\n\t    (ugeth->phy_interface == PHY_INTERFACE_MODE_RTBI)) {\n\t\tupsmr |= UCC_GETH_UPSMR_TBIM;\n\t}\n\tif (ugeth->phy_interface == PHY_INTERFACE_MODE_SGMII)\n\t\tupsmr |= UCC_GETH_UPSMR_SGMM;\n\n\tout_be32(&uf_regs->upsmr, upsmr);\n\n\t \n\t \n\tif ((ugeth->phy_interface == PHY_INTERFACE_MODE_TBI) ||\n\t    (ugeth->phy_interface == PHY_INTERFACE_MODE_RTBI)) {\n\t\tstruct ucc_geth_info *ug_info = ugeth->ug_info;\n\t\tstruct phy_device *tbiphy;\n\n\t\tif (!ug_info->tbi_node)\n\t\t\tpr_warn(\"TBI mode requires that the device tree specify a tbi-handle\\n\");\n\n\t\ttbiphy = of_phy_find_device(ug_info->tbi_node);\n\t\tif (!tbiphy)\n\t\t\tpr_warn(\"Could not get TBI device\\n\");\n\n\t\tvalue = phy_read(tbiphy, ENET_TBI_MII_CR);\n\t\tvalue &= ~0x1000;\t \n\t\tphy_write(tbiphy, ENET_TBI_MII_CR, value);\n\n\t\tput_device(&tbiphy->mdio.dev);\n\t}\n\n\tinit_check_frame_length_mode(ug_info->lengthCheckRx, &ug_regs->maccfg2);\n\n\tret_val = init_preamble_length(ug_info->prel, &ug_regs->maccfg2);\n\tif (ret_val != 0) {\n\t\tif (netif_msg_probe(ugeth))\n\t\t\tpr_err(\"Preamble length must be between 3 and 7 inclusive\\n\");\n\t\treturn ret_val;\n\t}\n\n\treturn 0;\n}\n\nstatic int ugeth_graceful_stop_tx(struct ucc_geth_private *ugeth)\n{\n\tstruct ucc_fast_private *uccf;\n\tu32 cecr_subblock;\n\tu32 temp;\n\tint i = 10;\n\n\tuccf = ugeth->uccf;\n\n\t \n\tclrbits32(uccf->p_uccm, UCC_GETH_UCCE_GRA);\n\tout_be32(uccf->p_ucce, UCC_GETH_UCCE_GRA);   \n\n\t \n\tcecr_subblock =\n\t    ucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);\n\tqe_issue_cmd(QE_GRACEFUL_STOP_TX, cecr_subblock,\n\t\t     QE_CR_PROTOCOL_ETHERNET, 0);\n\n\t \n\tdo {\n\t\tmsleep(10);\n\t\ttemp = in_be32(uccf->p_ucce);\n\t} while (!(temp & UCC_GETH_UCCE_GRA) && --i);\n\n\tuccf->stopped_tx = 1;\n\n\treturn 0;\n}\n\nstatic int ugeth_graceful_stop_rx(struct ucc_geth_private *ugeth)\n{\n\tstruct ucc_fast_private *uccf;\n\tu32 cecr_subblock;\n\tu8 temp;\n\tint i = 10;\n\n\tuccf = ugeth->uccf;\n\n\t \n\ttemp = in_8(&ugeth->p_rx_glbl_pram->rxgstpack);\n\ttemp &= ~GRACEFUL_STOP_ACKNOWLEDGE_RX;\n\tout_8(&ugeth->p_rx_glbl_pram->rxgstpack, temp);\n\n\t \n\tdo {\n\t\t \n\t\tcecr_subblock =\n\t\t    ucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.\n\t\t\t\t\t\tucc_num);\n\t\tqe_issue_cmd(QE_GRACEFUL_STOP_RX, cecr_subblock,\n\t\t\t     QE_CR_PROTOCOL_ETHERNET, 0);\n\t\tmsleep(10);\n\t\ttemp = in_8(&ugeth->p_rx_glbl_pram->rxgstpack);\n\t} while (!(temp & GRACEFUL_STOP_ACKNOWLEDGE_RX) && --i);\n\n\tuccf->stopped_rx = 1;\n\n\treturn 0;\n}\n\nstatic int ugeth_restart_tx(struct ucc_geth_private *ugeth)\n{\n\tstruct ucc_fast_private *uccf;\n\tu32 cecr_subblock;\n\n\tuccf = ugeth->uccf;\n\n\tcecr_subblock =\n\t    ucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);\n\tqe_issue_cmd(QE_RESTART_TX, cecr_subblock, QE_CR_PROTOCOL_ETHERNET, 0);\n\tuccf->stopped_tx = 0;\n\n\treturn 0;\n}\n\nstatic int ugeth_restart_rx(struct ucc_geth_private *ugeth)\n{\n\tstruct ucc_fast_private *uccf;\n\tu32 cecr_subblock;\n\n\tuccf = ugeth->uccf;\n\n\tcecr_subblock =\n\t    ucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);\n\tqe_issue_cmd(QE_RESTART_RX, cecr_subblock, QE_CR_PROTOCOL_ETHERNET,\n\t\t     0);\n\tuccf->stopped_rx = 0;\n\n\treturn 0;\n}\n\nstatic int ugeth_enable(struct ucc_geth_private *ugeth, enum comm_dir mode)\n{\n\tstruct ucc_fast_private *uccf;\n\tint enabled_tx, enabled_rx;\n\n\tuccf = ugeth->uccf;\n\n\t \n\tif (ugeth->ug_info->uf_info.ucc_num >= UCC_MAX_NUM) {\n\t\tif (netif_msg_probe(ugeth))\n\t\t\tpr_err(\"ucc_num out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tenabled_tx = uccf->enabled_tx;\n\tenabled_rx = uccf->enabled_rx;\n\n\t \n\tif ((mode & COMM_DIR_TX) && (!enabled_tx) && uccf->stopped_tx)\n\t\tugeth_restart_tx(ugeth);\n\tif ((mode & COMM_DIR_RX) && (!enabled_rx) && uccf->stopped_rx)\n\t\tugeth_restart_rx(ugeth);\n\n\tucc_fast_enable(uccf, mode);\t \n\n\treturn 0;\n\n}\n\nstatic int ugeth_disable(struct ucc_geth_private *ugeth, enum comm_dir mode)\n{\n\tstruct ucc_fast_private *uccf;\n\n\tuccf = ugeth->uccf;\n\n\t \n\tif (ugeth->ug_info->uf_info.ucc_num >= UCC_MAX_NUM) {\n\t\tif (netif_msg_probe(ugeth))\n\t\t\tpr_err(\"ucc_num out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((mode & COMM_DIR_TX) && uccf->enabled_tx && !uccf->stopped_tx)\n\t\tugeth_graceful_stop_tx(ugeth);\n\n\t \n\tif ((mode & COMM_DIR_RX) && uccf->enabled_rx && !uccf->stopped_rx)\n\t\tugeth_graceful_stop_rx(ugeth);\n\n\tucc_fast_disable(ugeth->uccf, mode);  \n\n\treturn 0;\n}\n\nstatic void ugeth_quiesce(struct ucc_geth_private *ugeth)\n{\n\t \n\tnetif_tx_stop_all_queues(ugeth->ndev);\n\n\t \n\tdisable_irq(ugeth->ug_info->uf_info.irq);\n\n\t \n\tnapi_disable(&ugeth->napi);\n}\n\nstatic void ugeth_activate(struct ucc_geth_private *ugeth)\n{\n\tnapi_enable(&ugeth->napi);\n\tenable_irq(ugeth->ug_info->uf_info.irq);\n\n\t \n\tnetif_tx_wake_all_queues(ugeth->ndev);\n\t__netdev_watchdog_up(ugeth->ndev);\n}\n\n \n\nstatic void adjust_link(struct net_device *dev)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(dev);\n\tstruct ucc_geth __iomem *ug_regs;\n\tstruct ucc_fast __iomem *uf_regs;\n\tstruct phy_device *phydev = ugeth->phydev;\n\tint new_state = 0;\n\n\tug_regs = ugeth->ug_regs;\n\tuf_regs = ugeth->uccf->uf_regs;\n\n\tif (phydev->link) {\n\t\tu32 tempval = in_be32(&ug_regs->maccfg2);\n\t\tu32 upsmr = in_be32(&uf_regs->upsmr);\n\t\t \n\t\tif (phydev->duplex != ugeth->oldduplex) {\n\t\t\tnew_state = 1;\n\t\t\tif (!(phydev->duplex))\n\t\t\t\ttempval &= ~(MACCFG2_FDX);\n\t\t\telse\n\t\t\t\ttempval |= MACCFG2_FDX;\n\t\t\tugeth->oldduplex = phydev->duplex;\n\t\t}\n\n\t\tif (phydev->speed != ugeth->oldspeed) {\n\t\t\tnew_state = 1;\n\t\t\tswitch (phydev->speed) {\n\t\t\tcase SPEED_1000:\n\t\t\t\ttempval = ((tempval &\n\t\t\t\t\t    ~(MACCFG2_INTERFACE_MODE_MASK)) |\n\t\t\t\t\t    MACCFG2_INTERFACE_MODE_BYTE);\n\t\t\t\tbreak;\n\t\t\tcase SPEED_100:\n\t\t\tcase SPEED_10:\n\t\t\t\ttempval = ((tempval &\n\t\t\t\t\t    ~(MACCFG2_INTERFACE_MODE_MASK)) |\n\t\t\t\t\t    MACCFG2_INTERFACE_MODE_NIBBLE);\n\t\t\t\t \n\t\t\t\tif ((ugeth->phy_interface == PHY_INTERFACE_MODE_RMII) ||\n\t\t\t\t    (ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII) ||\n\t\t\t\t    (ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII_ID) ||\n\t\t\t\t    (ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII_RXID) ||\n\t\t\t\t    (ugeth->phy_interface == PHY_INTERFACE_MODE_RGMII_TXID) ||\n\t\t\t\t    (ugeth->phy_interface == PHY_INTERFACE_MODE_RTBI)) {\n\t\t\t\t\tif (phydev->speed == SPEED_10)\n\t\t\t\t\t\tupsmr |= UCC_GETH_UPSMR_R10M;\n\t\t\t\t\telse\n\t\t\t\t\t\tupsmr &= ~UCC_GETH_UPSMR_R10M;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (netif_msg_link(ugeth))\n\t\t\t\t\tpr_warn(\n\t\t\t\t\t\t\"%s: Ack!  Speed (%d) is not 10/100/1000!\",\n\t\t\t\t\t\tdev->name, phydev->speed);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tugeth->oldspeed = phydev->speed;\n\t\t}\n\n\t\tif (!ugeth->oldlink) {\n\t\t\tnew_state = 1;\n\t\t\tugeth->oldlink = 1;\n\t\t}\n\n\t\tif (new_state) {\n\t\t\t \n\t\t\tugeth_quiesce(ugeth);\n\t\t\tugeth_disable(ugeth, COMM_DIR_RX_AND_TX);\n\n\t\t\tout_be32(&ug_regs->maccfg2, tempval);\n\t\t\tout_be32(&uf_regs->upsmr, upsmr);\n\n\t\t\tugeth_enable(ugeth, COMM_DIR_RX_AND_TX);\n\t\t\tugeth_activate(ugeth);\n\t\t}\n\t} else if (ugeth->oldlink) {\n\t\t\tnew_state = 1;\n\t\t\tugeth->oldlink = 0;\n\t\t\tugeth->oldspeed = 0;\n\t\t\tugeth->oldduplex = -1;\n\t}\n\n\tif (new_state && netif_msg_link(ugeth))\n\t\tphy_print_status(phydev);\n}\n\n \nstatic void uec_configure_serdes(struct net_device *dev)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(dev);\n\tstruct ucc_geth_info *ug_info = ugeth->ug_info;\n\tstruct phy_device *tbiphy;\n\n\tif (!ug_info->tbi_node) {\n\t\tdev_warn(&dev->dev, \"SGMII mode requires that the device \"\n\t\t\t\"tree specify a tbi-handle\\n\");\n\t\treturn;\n\t}\n\n\ttbiphy = of_phy_find_device(ug_info->tbi_node);\n\tif (!tbiphy) {\n\t\tdev_err(&dev->dev, \"error: Could not get TBI device\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (phy_read(tbiphy, ENET_TBI_MII_SR) & TBISR_LSTATUS) {\n\t\tput_device(&tbiphy->mdio.dev);\n\t\treturn;\n\t}\n\n\t \n\tphy_write(tbiphy, ENET_TBI_MII_ANA, TBIANA_SETTINGS);\n\n\tphy_write(tbiphy, ENET_TBI_MII_TBICON, TBICON_CLK_SELECT);\n\n\tphy_write(tbiphy, ENET_TBI_MII_CR, TBICR_SETTINGS);\n\n\tput_device(&tbiphy->mdio.dev);\n}\n\n \nstatic int init_phy(struct net_device *dev)\n{\n\tstruct ucc_geth_private *priv = netdev_priv(dev);\n\tstruct ucc_geth_info *ug_info = priv->ug_info;\n\tstruct phy_device *phydev;\n\n\tpriv->oldlink = 0;\n\tpriv->oldspeed = 0;\n\tpriv->oldduplex = -1;\n\n\tphydev = of_phy_connect(dev, ug_info->phy_node, &adjust_link, 0,\n\t\t\t\tpriv->phy_interface);\n\tif (!phydev) {\n\t\tdev_err(&dev->dev, \"Could not attach to PHY\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (priv->phy_interface == PHY_INTERFACE_MODE_SGMII)\n\t\tuec_configure_serdes(dev);\n\n\tphy_set_max_speed(phydev, priv->max_speed);\n\n\tpriv->phydev = phydev;\n\n\treturn 0;\n}\n\nstatic void ugeth_dump_regs(struct ucc_geth_private *ugeth)\n{\n#ifdef DEBUG\n\tucc_fast_dump_regs(ugeth->uccf);\n\tdump_regs(ugeth);\n\tdump_bds(ugeth);\n#endif\n}\n\nstatic int ugeth_82xx_filtering_clear_all_addr_in_hash(struct ucc_geth_private *\n\t\t\t\t\t\t       ugeth,\n\t\t\t\t\t\t       enum enet_addr_type\n\t\t\t\t\t\t       enet_addr_type)\n{\n\tstruct ucc_geth_82xx_address_filtering_pram __iomem *p_82xx_addr_filt;\n\tstruct ucc_fast_private *uccf;\n\tenum comm_dir comm_dir;\n\tstruct list_head *p_lh;\n\tu16 i, num;\n\tu32 __iomem *addr_h;\n\tu32 __iomem *addr_l;\n\tu8 *p_counter;\n\n\tuccf = ugeth->uccf;\n\n\tp_82xx_addr_filt =\n\t    (struct ucc_geth_82xx_address_filtering_pram __iomem *)\n\t    ugeth->p_rx_glbl_pram->addressfiltering;\n\n\tif (enet_addr_type == ENET_ADDR_TYPE_GROUP) {\n\t\taddr_h = &(p_82xx_addr_filt->gaddr_h);\n\t\taddr_l = &(p_82xx_addr_filt->gaddr_l);\n\t\tp_lh = &ugeth->group_hash_q;\n\t\tp_counter = &(ugeth->numGroupAddrInHash);\n\t} else if (enet_addr_type == ENET_ADDR_TYPE_INDIVIDUAL) {\n\t\taddr_h = &(p_82xx_addr_filt->iaddr_h);\n\t\taddr_l = &(p_82xx_addr_filt->iaddr_l);\n\t\tp_lh = &ugeth->ind_hash_q;\n\t\tp_counter = &(ugeth->numIndAddrInHash);\n\t} else\n\t\treturn -EINVAL;\n\n\tcomm_dir = 0;\n\tif (uccf->enabled_tx)\n\t\tcomm_dir |= COMM_DIR_TX;\n\tif (uccf->enabled_rx)\n\t\tcomm_dir |= COMM_DIR_RX;\n\tif (comm_dir)\n\t\tugeth_disable(ugeth, comm_dir);\n\n\t \n\tout_be32(addr_h, 0x00000000);\n\tout_be32(addr_l, 0x00000000);\n\n\tif (!p_lh)\n\t\treturn 0;\n\n\tnum = *p_counter;\n\n\t \n\tfor (i = 0; i < num; i++)\n\t\tput_enet_addr_container(ENET_ADDR_CONT_ENTRY(dequeue(p_lh)));\n\n\t*p_counter = 0;\n\n\tif (comm_dir)\n\t\tugeth_enable(ugeth, comm_dir);\n\n\treturn 0;\n}\n\nstatic int ugeth_82xx_filtering_clear_addr_in_paddr(struct ucc_geth_private *ugeth,\n\t\t\t\t\t\t    u8 paddr_num)\n{\n\tugeth->indAddrRegUsed[paddr_num] = 0;  \n\treturn hw_clear_addr_in_paddr(ugeth, paddr_num); \n}\n\nstatic void ucc_geth_free_rx(struct ucc_geth_private *ugeth)\n{\n\tstruct ucc_geth_info *ug_info;\n\tstruct ucc_fast_info *uf_info;\n\tu16 i, j;\n\tu8 __iomem *bd;\n\n\n\tug_info = ugeth->ug_info;\n\tuf_info = &ug_info->uf_info;\n\n\tfor (i = 0; i < ucc_geth_rx_queues(ugeth->ug_info); i++) {\n\t\tif (ugeth->p_rx_bd_ring[i]) {\n\t\t\t \n\t\t\tbd = ugeth->p_rx_bd_ring[i];\n\t\t\tfor (j = 0; j < ugeth->ug_info->bdRingLenRx[i]; j++) {\n\t\t\t\tif (ugeth->rx_skbuff[i][j]) {\n\t\t\t\t\tdma_unmap_single(ugeth->dev,\n\t\t\t\t\t\tin_be32(&((struct qe_bd __iomem *)bd)->buf),\n\t\t\t\t\t\tugeth->ug_info->\n\t\t\t\t\t\tuf_info.max_rx_buf_length +\n\t\t\t\t\t\tUCC_GETH_RX_DATA_BUF_ALIGNMENT,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\t\tdev_kfree_skb_any(\n\t\t\t\t\t\tugeth->rx_skbuff[i][j]);\n\t\t\t\t\tugeth->rx_skbuff[i][j] = NULL;\n\t\t\t\t}\n\t\t\t\tbd += sizeof(struct qe_bd);\n\t\t\t}\n\n\t\t\tkfree(ugeth->rx_skbuff[i]);\n\n\t\t\tkfree(ugeth->p_rx_bd_ring[i]);\n\t\t\tugeth->p_rx_bd_ring[i] = NULL;\n\t\t}\n\t}\n\n}\n\nstatic void ucc_geth_free_tx(struct ucc_geth_private *ugeth)\n{\n\tstruct ucc_geth_info *ug_info;\n\tstruct ucc_fast_info *uf_info;\n\tu16 i, j;\n\tu8 __iomem *bd;\n\n\tnetdev_reset_queue(ugeth->ndev);\n\n\tug_info = ugeth->ug_info;\n\tuf_info = &ug_info->uf_info;\n\n\tfor (i = 0; i < ucc_geth_tx_queues(ugeth->ug_info); i++) {\n\t\tbd = ugeth->p_tx_bd_ring[i];\n\t\tif (!bd)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < ugeth->ug_info->bdRingLenTx[i]; j++) {\n\t\t\tif (ugeth->tx_skbuff[i][j]) {\n\t\t\t\tdma_unmap_single(ugeth->dev,\n\t\t\t\t\t\t in_be32(&((struct qe_bd __iomem *)bd)->buf),\n\t\t\t\t\t\t (in_be32((u32 __iomem *)bd) &\n\t\t\t\t\t\t  BD_LENGTH_MASK),\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\tdev_kfree_skb_any(ugeth->tx_skbuff[i][j]);\n\t\t\t\tugeth->tx_skbuff[i][j] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(ugeth->tx_skbuff[i]);\n\n\t\tkfree(ugeth->p_tx_bd_ring[i]);\n\t\tugeth->p_tx_bd_ring[i] = NULL;\n\t}\n\n}\n\nstatic void ucc_geth_memclean(struct ucc_geth_private *ugeth)\n{\n\tif (!ugeth)\n\t\treturn;\n\n\tif (ugeth->uccf) {\n\t\tucc_fast_free(ugeth->uccf);\n\t\tugeth->uccf = NULL;\n\t}\n\n\tqe_muram_free_addr(ugeth->p_thread_data_tx);\n\tugeth->p_thread_data_tx = NULL;\n\n\tqe_muram_free_addr(ugeth->p_thread_data_rx);\n\tugeth->p_thread_data_rx = NULL;\n\n\tqe_muram_free_addr(ugeth->p_exf_glbl_param);\n\tugeth->p_exf_glbl_param = NULL;\n\n\tqe_muram_free_addr(ugeth->p_rx_glbl_pram);\n\tugeth->p_rx_glbl_pram = NULL;\n\n\tqe_muram_free_addr(ugeth->p_tx_glbl_pram);\n\tugeth->p_tx_glbl_pram = NULL;\n\n\tqe_muram_free_addr(ugeth->p_send_q_mem_reg);\n\tugeth->p_send_q_mem_reg = NULL;\n\n\tqe_muram_free_addr(ugeth->p_scheduler);\n\tugeth->p_scheduler = NULL;\n\n\tqe_muram_free_addr(ugeth->p_tx_fw_statistics_pram);\n\tugeth->p_tx_fw_statistics_pram = NULL;\n\n\tqe_muram_free_addr(ugeth->p_rx_fw_statistics_pram);\n\tugeth->p_rx_fw_statistics_pram = NULL;\n\n\tqe_muram_free_addr(ugeth->p_rx_irq_coalescing_tbl);\n\tugeth->p_rx_irq_coalescing_tbl = NULL;\n\n\tqe_muram_free_addr(ugeth->p_rx_bd_qs_tbl);\n\tugeth->p_rx_bd_qs_tbl = NULL;\n\n\tif (ugeth->p_init_enet_param_shadow) {\n\t\treturn_init_enet_entries(ugeth,\n\t\t\t\t\t &(ugeth->p_init_enet_param_shadow->\n\t\t\t\t\t   rxthread[0]),\n\t\t\t\t\t ENET_INIT_PARAM_MAX_ENTRIES_RX,\n\t\t\t\t\t ugeth->ug_info->riscRx, 1);\n\t\treturn_init_enet_entries(ugeth,\n\t\t\t\t\t &(ugeth->p_init_enet_param_shadow->\n\t\t\t\t\t   txthread[0]),\n\t\t\t\t\t ENET_INIT_PARAM_MAX_ENTRIES_TX,\n\t\t\t\t\t ugeth->ug_info->riscTx, 0);\n\t\tkfree(ugeth->p_init_enet_param_shadow);\n\t\tugeth->p_init_enet_param_shadow = NULL;\n\t}\n\tucc_geth_free_tx(ugeth);\n\tucc_geth_free_rx(ugeth);\n\twhile (!list_empty(&ugeth->group_hash_q))\n\t\tput_enet_addr_container(ENET_ADDR_CONT_ENTRY\n\t\t\t\t\t(dequeue(&ugeth->group_hash_q)));\n\twhile (!list_empty(&ugeth->ind_hash_q))\n\t\tput_enet_addr_container(ENET_ADDR_CONT_ENTRY\n\t\t\t\t\t(dequeue(&ugeth->ind_hash_q)));\n\tif (ugeth->ug_regs) {\n\t\tiounmap(ugeth->ug_regs);\n\t\tugeth->ug_regs = NULL;\n\t}\n}\n\nstatic void ucc_geth_set_multi(struct net_device *dev)\n{\n\tstruct ucc_geth_private *ugeth;\n\tstruct netdev_hw_addr *ha;\n\tstruct ucc_fast __iomem *uf_regs;\n\tstruct ucc_geth_82xx_address_filtering_pram __iomem *p_82xx_addr_filt;\n\n\tugeth = netdev_priv(dev);\n\n\tuf_regs = ugeth->uccf->uf_regs;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tsetbits32(&uf_regs->upsmr, UCC_GETH_UPSMR_PRO);\n\t} else {\n\t\tclrbits32(&uf_regs->upsmr, UCC_GETH_UPSMR_PRO);\n\n\t\tp_82xx_addr_filt =\n\t\t    (struct ucc_geth_82xx_address_filtering_pram __iomem *) ugeth->\n\t\t    p_rx_glbl_pram->addressfiltering;\n\n\t\tif (dev->flags & IFF_ALLMULTI) {\n\t\t\t \n\t\t\tout_be32(&p_82xx_addr_filt->gaddr_h, 0xffffffff);\n\t\t\tout_be32(&p_82xx_addr_filt->gaddr_l, 0xffffffff);\n\t\t} else {\n\t\t\t \n\t\t\tout_be32(&p_82xx_addr_filt->gaddr_h, 0x0);\n\t\t\tout_be32(&p_82xx_addr_filt->gaddr_l, 0x0);\n\n\t\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t\t \n\t\t\t\thw_add_addr_in_hash(ugeth, ha->addr);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void ucc_geth_stop(struct ucc_geth_private *ugeth)\n{\n\tstruct ucc_geth __iomem *ug_regs = ugeth->ug_regs;\n\tstruct phy_device *phydev = ugeth->phydev;\n\n\tugeth_vdbg(\"%s: IN\", __func__);\n\n\t \n\tphy_stop(phydev);\n\n\t \n\tugeth_disable(ugeth, COMM_DIR_RX_AND_TX);\n\n\t \n\tout_be32(ugeth->uccf->p_uccm, 0x00000000);\n\n\t \n\tout_be32(ugeth->uccf->p_ucce, 0xffffffff);\n\n\t \n\tclrbits32(&ug_regs->maccfg1, MACCFG1_ENABLE_RX | MACCFG1_ENABLE_TX);\n\n\tucc_geth_memclean(ugeth);\n}\n\nstatic int ucc_struct_init(struct ucc_geth_private *ugeth)\n{\n\tstruct ucc_geth_info *ug_info;\n\tstruct ucc_fast_info *uf_info;\n\tint i;\n\n\tug_info = ugeth->ug_info;\n\tuf_info = &ug_info->uf_info;\n\n\t \n\tfor (i = 0; i < ucc_geth_rx_queues(ug_info); i++) {\n\t\tif ((ug_info->bdRingLenRx[i] < UCC_GETH_RX_BD_RING_SIZE_MIN) ||\n\t\t    (ug_info->bdRingLenRx[i] %\n\t\t     UCC_GETH_RX_BD_RING_SIZE_ALIGNMENT)) {\n\t\t\tif (netif_msg_probe(ugeth))\n\t\t\t\tpr_err(\"Rx BD ring length must be multiple of 4, no smaller than 8\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ucc_geth_tx_queues(ug_info); i++) {\n\t\tif (ug_info->bdRingLenTx[i] < UCC_GETH_TX_BD_RING_SIZE_MIN) {\n\t\t\tif (netif_msg_probe(ugeth))\n\t\t\t\tpr_err(\"Tx BD ring length must be no smaller than 2\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif ((uf_info->max_rx_buf_length == 0) ||\n\t    (uf_info->max_rx_buf_length % UCC_GETH_MRBLR_ALIGNMENT)) {\n\t\tif (netif_msg_probe(ugeth))\n\t\t\tpr_err(\"max_rx_buf_length must be non-zero multiple of 128\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ucc_geth_tx_queues(ug_info) > NUM_TX_QUEUES) {\n\t\tif (netif_msg_probe(ugeth))\n\t\t\tpr_err(\"number of tx queues too large\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ucc_geth_rx_queues(ug_info) > NUM_RX_QUEUES) {\n\t\tif (netif_msg_probe(ugeth))\n\t\t\tpr_err(\"number of rx queues too large\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < UCC_GETH_VLAN_PRIORITY_MAX; i++) {\n\t\tif (ug_info->l2qt[i] >= ucc_geth_rx_queues(ug_info)) {\n\t\t\tif (netif_msg_probe(ugeth))\n\t\t\t\tpr_err(\"VLAN priority table entry must not be larger than number of Rx queues\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < UCC_GETH_IP_PRIORITY_MAX; i++) {\n\t\tif (ug_info->l3qt[i] >= ucc_geth_rx_queues(ug_info)) {\n\t\t\tif (netif_msg_probe(ugeth))\n\t\t\t\tpr_err(\"IP priority table entry must not be larger than number of Rx queues\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ug_info->cam && !ug_info->ecamptr) {\n\t\tif (netif_msg_probe(ugeth))\n\t\t\tpr_err(\"If cam mode is chosen, must supply cam ptr\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ug_info->numStationAddresses !=\n\t     UCC_GETH_NUM_OF_STATION_ADDRESSES_1) &&\n\t    ug_info->rxExtendedFiltering) {\n\t\tif (netif_msg_probe(ugeth))\n\t\t\tpr_err(\"Number of station addresses greater than 1 not allowed in extended parsing mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tuf_info->uccm_mask = ug_info->eventRegMask & UCCE_OTHER; \n\tfor (i = 0; i < ucc_geth_rx_queues(ug_info); i++)\n\t\tuf_info->uccm_mask |= (UCC_GETH_UCCE_RXF0 << i);\n\n\tfor (i = 0; i < ucc_geth_tx_queues(ug_info); i++)\n\t\tuf_info->uccm_mask |= (UCC_GETH_UCCE_TXB0 << i);\n\t \n\tif (ucc_fast_init(uf_info, &ugeth->uccf)) {\n\t\tif (netif_msg_probe(ugeth))\n\t\t\tpr_err(\"Failed to init uccf\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (qe_get_num_of_risc() == 4) {\n\t\tug_info->riscTx = QE_RISC_ALLOCATION_FOUR_RISCS;\n\t\tug_info->riscRx = QE_RISC_ALLOCATION_FOUR_RISCS;\n\t}\n\n\tugeth->ug_regs = ioremap(uf_info->regs, sizeof(*ugeth->ug_regs));\n\tif (!ugeth->ug_regs) {\n\t\tif (netif_msg_probe(ugeth))\n\t\t\tpr_err(\"Failed to ioremap regs\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int ucc_geth_alloc_tx(struct ucc_geth_private *ugeth)\n{\n\tstruct ucc_geth_info *ug_info;\n\tstruct ucc_fast_info *uf_info;\n\tint length;\n\tu16 i, j;\n\tu8 __iomem *bd;\n\n\tug_info = ugeth->ug_info;\n\tuf_info = &ug_info->uf_info;\n\n\t \n\tfor (j = 0; j < ucc_geth_tx_queues(ug_info); j++) {\n\t\tu32 align = max(UCC_GETH_TX_BD_RING_ALIGNMENT,\n\t\t\t\tUCC_GETH_TX_BD_RING_SIZE_MEMORY_ALIGNMENT);\n\t\tu32 alloc;\n\n\t\tlength = ug_info->bdRingLenTx[j] * sizeof(struct qe_bd);\n\t\talloc = round_up(length, align);\n\t\talloc = roundup_pow_of_two(alloc);\n\n\t\tugeth->p_tx_bd_ring[j] = kmalloc(alloc, GFP_KERNEL);\n\n\t\tif (!ugeth->p_tx_bd_ring[j]) {\n\t\t\tif (netif_msg_ifup(ugeth))\n\t\t\t\tpr_err(\"Can not allocate memory for Tx bd rings\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t \n\t\tmemset(ugeth->p_tx_bd_ring[j] + length, 0, alloc - length);\n\t}\n\n\t \n\tfor (j = 0; j < ucc_geth_tx_queues(ug_info); j++) {\n\t\t \n\t\tugeth->tx_skbuff[j] =\n\t\t\tkcalloc(ugeth->ug_info->bdRingLenTx[j],\n\t\t\t\tsizeof(struct sk_buff *), GFP_KERNEL);\n\n\t\tif (ugeth->tx_skbuff[j] == NULL) {\n\t\t\tif (netif_msg_ifup(ugeth))\n\t\t\t\tpr_err(\"Could not allocate tx_skbuff\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tugeth->skb_curtx[j] = ugeth->skb_dirtytx[j] = 0;\n\t\tbd = ugeth->confBd[j] = ugeth->txBd[j] = ugeth->p_tx_bd_ring[j];\n\t\tfor (i = 0; i < ug_info->bdRingLenTx[j]; i++) {\n\t\t\t \n\t\t\tout_be32(&((struct qe_bd __iomem *)bd)->buf, 0);\n\t\t\t \n\t\t\tout_be32((u32 __iomem *)bd, 0);\n\t\t\tbd += sizeof(struct qe_bd);\n\t\t}\n\t\tbd -= sizeof(struct qe_bd);\n\t\t \n\t\tout_be32((u32 __iomem *)bd, T_W);  \n\t}\n\n\treturn 0;\n}\n\nstatic int ucc_geth_alloc_rx(struct ucc_geth_private *ugeth)\n{\n\tstruct ucc_geth_info *ug_info;\n\tstruct ucc_fast_info *uf_info;\n\tint length;\n\tu16 i, j;\n\tu8 __iomem *bd;\n\n\tug_info = ugeth->ug_info;\n\tuf_info = &ug_info->uf_info;\n\n\t \n\tfor (j = 0; j < ucc_geth_rx_queues(ug_info); j++) {\n\t\tu32 align = UCC_GETH_RX_BD_RING_ALIGNMENT;\n\t\tu32 alloc;\n\n\t\tlength = ug_info->bdRingLenRx[j] * sizeof(struct qe_bd);\n\t\talloc = round_up(length, align);\n\t\talloc = roundup_pow_of_two(alloc);\n\n\t\tugeth->p_rx_bd_ring[j] = kmalloc(alloc, GFP_KERNEL);\n\t\tif (!ugeth->p_rx_bd_ring[j]) {\n\t\t\tif (netif_msg_ifup(ugeth))\n\t\t\t\tpr_err(\"Can not allocate memory for Rx bd rings\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tfor (j = 0; j < ucc_geth_rx_queues(ug_info); j++) {\n\t\t \n\t\tugeth->rx_skbuff[j] =\n\t\t\tkcalloc(ugeth->ug_info->bdRingLenRx[j],\n\t\t\t\tsizeof(struct sk_buff *), GFP_KERNEL);\n\n\t\tif (ugeth->rx_skbuff[j] == NULL) {\n\t\t\tif (netif_msg_ifup(ugeth))\n\t\t\t\tpr_err(\"Could not allocate rx_skbuff\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tugeth->skb_currx[j] = 0;\n\t\tbd = ugeth->rxBd[j] = ugeth->p_rx_bd_ring[j];\n\t\tfor (i = 0; i < ug_info->bdRingLenRx[j]; i++) {\n\t\t\t \n\t\t\tout_be32((u32 __iomem *)bd, R_I);\n\t\t\t \n\t\t\tout_be32(&((struct qe_bd __iomem *)bd)->buf, 0);\n\t\t\tbd += sizeof(struct qe_bd);\n\t\t}\n\t\tbd -= sizeof(struct qe_bd);\n\t\t \n\t\tout_be32((u32 __iomem *)bd, R_W);  \n\t}\n\n\treturn 0;\n}\n\nstatic int ucc_geth_startup(struct ucc_geth_private *ugeth)\n{\n\tstruct ucc_geth_82xx_address_filtering_pram __iomem *p_82xx_addr_filt;\n\tstruct ucc_geth_init_pram __iomem *p_init_enet_pram;\n\tstruct ucc_fast_private *uccf;\n\tstruct ucc_geth_info *ug_info;\n\tstruct ucc_fast_info *uf_info;\n\tstruct ucc_fast __iomem *uf_regs;\n\tstruct ucc_geth __iomem *ug_regs;\n\tint ret_val = -EINVAL;\n\tu32 remoder = UCC_GETH_REMODER_INIT;\n\tu32 init_enet_pram_offset, cecr_subblock, command;\n\tu32 ifstat, i, j, size, l2qt, l3qt;\n\tu16 temoder = UCC_GETH_TEMODER_INIT;\n\tu8 function_code = 0;\n\tu8 __iomem *endOfRing;\n\tu8 numThreadsRxNumerical, numThreadsTxNumerical;\n\ts32 rx_glbl_pram_offset, tx_glbl_pram_offset;\n\n\tugeth_vdbg(\"%s: IN\", __func__);\n\tuccf = ugeth->uccf;\n\tug_info = ugeth->ug_info;\n\tuf_info = &ug_info->uf_info;\n\tuf_regs = uccf->uf_regs;\n\tug_regs = ugeth->ug_regs;\n\n\tnumThreadsRxNumerical = ucc_geth_thread_count(ug_info->numThreadsRx);\n\tif (!numThreadsRxNumerical) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Bad number of Rx threads value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnumThreadsTxNumerical = ucc_geth_thread_count(ug_info->numThreadsTx);\n\tif (!numThreadsTxNumerical) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Bad number of Tx threads value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tugeth->rx_non_dynamic_extended_features = ug_info->ipCheckSumCheck ||\n\t    ug_info->ipAddressAlignment ||\n\t    (ug_info->numStationAddresses !=\n\t     UCC_GETH_NUM_OF_STATION_ADDRESSES_1);\n\n\tugeth->rx_extended_features = ugeth->rx_non_dynamic_extended_features ||\n\t\t(ug_info->vlanOperationTagged != UCC_GETH_VLAN_OPERATION_TAGGED_NOP) ||\n\t\t(ug_info->vlanOperationNonTagged !=\n\t\t UCC_GETH_VLAN_OPERATION_NON_TAGGED_NOP);\n\n\tinit_default_reg_vals(&uf_regs->upsmr,\n\t\t\t      &ug_regs->maccfg1, &ug_regs->maccfg2);\n\n\t \n\t \n\tinit_rx_parameters(ug_info->bro,\n\t\t\t   ug_info->rsh, ug_info->pro, &uf_regs->upsmr);\n\n\t \n\t \n\n\t \n\t \n\tinit_flow_control_params(ug_info->aufc,\n\t\t\t\t ug_info->receiveFlowControl,\n\t\t\t\t ug_info->transmitFlowControl,\n\t\t\t\t ug_info->pausePeriod,\n\t\t\t\t ug_info->extensionField,\n\t\t\t\t &uf_regs->upsmr,\n\t\t\t\t &ug_regs->uempr, &ug_regs->maccfg1);\n\n\tsetbits32(&ug_regs->maccfg1, MACCFG1_ENABLE_RX | MACCFG1_ENABLE_TX);\n\n\t \n\t \n\tret_val = init_inter_frame_gap_params(ug_info->nonBackToBackIfgPart1,\n\t\t\t\t\t      ug_info->nonBackToBackIfgPart2,\n\t\t\t\t\t      ug_info->\n\t\t\t\t\t      miminumInterFrameGapEnforcement,\n\t\t\t\t\t      ug_info->backToBackInterFrameGap,\n\t\t\t\t\t      &ug_regs->ipgifg);\n\tif (ret_val != 0) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"IPGIFG initialization parameter too large\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\t \n\tret_val = init_half_duplex_params(ug_info->altBeb,\n\t\t\t\t\t  ug_info->backPressureNoBackoff,\n\t\t\t\t\t  ug_info->noBackoff,\n\t\t\t\t\t  ug_info->excessDefer,\n\t\t\t\t\t  ug_info->altBebTruncation,\n\t\t\t\t\t  ug_info->maxRetransmission,\n\t\t\t\t\t  ug_info->collisionWindow,\n\t\t\t\t\t  &ug_regs->hafdup);\n\tif (ret_val != 0) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Half Duplex initialization parameter too large\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\t \n\t \n\tifstat = in_be32(&ug_regs->ifstat);\n\n\t \n\t \n\tout_be32(&ug_regs->uempr, 0);\n\n\t \n\t \n\tinit_hw_statistics_gathering_mode((ug_info->statisticsMode &\n\t\t\t\tUCC_GETH_STATISTICS_GATHERING_MODE_HARDWARE),\n\t\t\t\t0, &uf_regs->upsmr, &ug_regs->uescr);\n\n\tret_val = ucc_geth_alloc_tx(ugeth);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\tret_val = ucc_geth_alloc_rx(ugeth);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\t \n\t \n\t \n\ttx_glbl_pram_offset =\n\t    qe_muram_alloc(sizeof(struct ucc_geth_tx_global_pram),\n\t\t\t   UCC_GETH_TX_GLOBAL_PRAM_ALIGNMENT);\n\tif (tx_glbl_pram_offset < 0) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Can not allocate DPRAM memory for p_tx_glbl_pram\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tugeth->p_tx_glbl_pram = qe_muram_addr(tx_glbl_pram_offset);\n\t \n\n\t \n\t \n\tugeth->thread_dat_tx_offset =\n\t    qe_muram_alloc(numThreadsTxNumerical *\n\t\t\t   sizeof(struct ucc_geth_thread_data_tx) +\n\t\t\t   32 * (numThreadsTxNumerical == 1),\n\t\t\t   UCC_GETH_THREAD_DATA_ALIGNMENT);\n\tif (IS_ERR_VALUE(ugeth->thread_dat_tx_offset)) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Can not allocate DPRAM memory for p_thread_data_tx\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tugeth->p_thread_data_tx =\n\t    (struct ucc_geth_thread_data_tx __iomem *) qe_muram_addr(ugeth->\n\t\t\t\t\t\t\tthread_dat_tx_offset);\n\tout_be32(&ugeth->p_tx_glbl_pram->tqptr, ugeth->thread_dat_tx_offset);\n\n\t \n\tfor (i = 0; i < UCC_GETH_TX_VTAG_TABLE_ENTRY_MAX; i++)\n\t\tout_be32(&ugeth->p_tx_glbl_pram->vtagtable[i],\n\t\t\t ug_info->vtagtable[i]);\n\n\t \n\tfor (i = 0; i < TX_IP_OFFSET_ENTRY_MAX; i++)\n\t\tout_8(&ugeth->p_tx_glbl_pram->iphoffset[i],\n\t\t\t\tug_info->iphoffset[i]);\n\n\t \n\t \n\tugeth->send_q_mem_reg_offset =\n\t    qe_muram_alloc(ucc_geth_tx_queues(ug_info) *\n\t\t\t   sizeof(struct ucc_geth_send_queue_qd),\n\t\t\t   UCC_GETH_SEND_QUEUE_QUEUE_DESCRIPTOR_ALIGNMENT);\n\tif (IS_ERR_VALUE(ugeth->send_q_mem_reg_offset)) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Can not allocate DPRAM memory for p_send_q_mem_reg\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tugeth->p_send_q_mem_reg =\n\t    (struct ucc_geth_send_queue_mem_region __iomem *) qe_muram_addr(ugeth->\n\t\t\tsend_q_mem_reg_offset);\n\tout_be32(&ugeth->p_tx_glbl_pram->sqptr, ugeth->send_q_mem_reg_offset);\n\n\t \n\t \n\tfor (i = 0; i < ucc_geth_tx_queues(ug_info); i++) {\n\t\tendOfRing =\n\t\t    ugeth->p_tx_bd_ring[i] + (ug_info->bdRingLenTx[i] -\n\t\t\t\t\t      1) * sizeof(struct qe_bd);\n\t\tout_be32(&ugeth->p_send_q_mem_reg->sqqd[i].bd_ring_base,\n\t\t\t (u32) virt_to_phys(ugeth->p_tx_bd_ring[i]));\n\t\tout_be32(&ugeth->p_send_q_mem_reg->sqqd[i].\n\t\t\t last_bd_completed_address,\n\t\t\t (u32) virt_to_phys(endOfRing));\n\t}\n\n\t \n\n\tif (ucc_geth_tx_queues(ug_info) > 1) {\n\t \n\t\tugeth->scheduler_offset =\n\t\t    qe_muram_alloc(sizeof(struct ucc_geth_scheduler),\n\t\t\t\t   UCC_GETH_SCHEDULER_ALIGNMENT);\n\t\tif (IS_ERR_VALUE(ugeth->scheduler_offset)) {\n\t\t\tif (netif_msg_ifup(ugeth))\n\t\t\t\tpr_err(\"Can not allocate DPRAM memory for p_scheduler\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tugeth->p_scheduler =\n\t\t    (struct ucc_geth_scheduler __iomem *) qe_muram_addr(ugeth->\n\t\t\t\t\t\t\t   scheduler_offset);\n\t\tout_be32(&ugeth->p_tx_glbl_pram->schedulerbasepointer,\n\t\t\t ugeth->scheduler_offset);\n\n\t\t \n\t\tout_be32(&ugeth->p_scheduler->mblinterval,\n\t\t\t ug_info->mblinterval);\n\t\tout_be16(&ugeth->p_scheduler->nortsrbytetime,\n\t\t\t ug_info->nortsrbytetime);\n\t\tout_8(&ugeth->p_scheduler->fracsiz, ug_info->fracsiz);\n\t\tout_8(&ugeth->p_scheduler->strictpriorityq,\n\t\t\t\tug_info->strictpriorityq);\n\t\tout_8(&ugeth->p_scheduler->txasap, ug_info->txasap);\n\t\tout_8(&ugeth->p_scheduler->extrabw, ug_info->extrabw);\n\t\tfor (i = 0; i < NUM_TX_QUEUES; i++)\n\t\t\tout_8(&ugeth->p_scheduler->weightfactor[i],\n\t\t\t    ug_info->weightfactor[i]);\n\n\t\t \n\t\tugeth->p_cpucount[0] = &(ugeth->p_scheduler->cpucount0);\n\t\tugeth->p_cpucount[1] = &(ugeth->p_scheduler->cpucount1);\n\t\tugeth->p_cpucount[2] = &(ugeth->p_scheduler->cpucount2);\n\t\tugeth->p_cpucount[3] = &(ugeth->p_scheduler->cpucount3);\n\t\tugeth->p_cpucount[4] = &(ugeth->p_scheduler->cpucount4);\n\t\tugeth->p_cpucount[5] = &(ugeth->p_scheduler->cpucount5);\n\t\tugeth->p_cpucount[6] = &(ugeth->p_scheduler->cpucount6);\n\t\tugeth->p_cpucount[7] = &(ugeth->p_scheduler->cpucount7);\n\t}\n\n\t \n\t \n\tif (ug_info->\n\t    statisticsMode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_TX) {\n\t\tugeth->tx_fw_statistics_pram_offset =\n\t\t    qe_muram_alloc(sizeof\n\t\t\t\t   (struct ucc_geth_tx_firmware_statistics_pram),\n\t\t\t\t   UCC_GETH_TX_STATISTICS_ALIGNMENT);\n\t\tif (IS_ERR_VALUE(ugeth->tx_fw_statistics_pram_offset)) {\n\t\t\tif (netif_msg_ifup(ugeth))\n\t\t\t\tpr_err(\"Can not allocate DPRAM memory for p_tx_fw_statistics_pram\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tugeth->p_tx_fw_statistics_pram =\n\t\t    (struct ucc_geth_tx_firmware_statistics_pram __iomem *)\n\t\t    qe_muram_addr(ugeth->tx_fw_statistics_pram_offset);\n\t}\n\n\t \n\t \n\n\tif (ucc_geth_tx_queues(ug_info) > 1)\n\t\ttemoder |= TEMODER_SCHEDULER_ENABLE;\n\tif (ug_info->ipCheckSumGenerate)\n\t\ttemoder |= TEMODER_IP_CHECKSUM_GENERATE;\n\ttemoder |= ((ucc_geth_tx_queues(ug_info) - 1) << TEMODER_NUM_OF_QUEUES_SHIFT);\n\tout_be16(&ugeth->p_tx_glbl_pram->temoder, temoder);\n\n\t \n\tfunction_code = UCC_BMR_BO_BE | UCC_BMR_GBL;\n\t \n\n\t \n\tout_be32(&ugeth->p_tx_glbl_pram->tstate, ((u32) function_code) << 24);\n\n\t \n\t \n\trx_glbl_pram_offset =\n\t    qe_muram_alloc(sizeof(struct ucc_geth_rx_global_pram),\n\t\t\t   UCC_GETH_RX_GLOBAL_PRAM_ALIGNMENT);\n\tif (rx_glbl_pram_offset < 0) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Can not allocate DPRAM memory for p_rx_glbl_pram\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tugeth->p_rx_glbl_pram = qe_muram_addr(rx_glbl_pram_offset);\n\t \n\n\t \n\t \n\tugeth->thread_dat_rx_offset =\n\t    qe_muram_alloc(numThreadsRxNumerical *\n\t\t\t   sizeof(struct ucc_geth_thread_data_rx),\n\t\t\t   UCC_GETH_THREAD_DATA_ALIGNMENT);\n\tif (IS_ERR_VALUE(ugeth->thread_dat_rx_offset)) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Can not allocate DPRAM memory for p_thread_data_rx\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tugeth->p_thread_data_rx =\n\t    (struct ucc_geth_thread_data_rx __iomem *) qe_muram_addr(ugeth->\n\t\t\t\t\t\t\tthread_dat_rx_offset);\n\tout_be32(&ugeth->p_rx_glbl_pram->rqptr, ugeth->thread_dat_rx_offset);\n\n\t \n\tout_be16(&ugeth->p_rx_glbl_pram->typeorlen, ug_info->typeorlen);\n\n\t \n\tif (ug_info->\n\t    statisticsMode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_RX) {\n\t\tugeth->rx_fw_statistics_pram_offset =\n\t\t    qe_muram_alloc(sizeof\n\t\t\t\t   (struct ucc_geth_rx_firmware_statistics_pram),\n\t\t\t\t   UCC_GETH_RX_STATISTICS_ALIGNMENT);\n\t\tif (IS_ERR_VALUE(ugeth->rx_fw_statistics_pram_offset)) {\n\t\t\tif (netif_msg_ifup(ugeth))\n\t\t\t\tpr_err(\"Can not allocate DPRAM memory for p_rx_fw_statistics_pram\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tugeth->p_rx_fw_statistics_pram =\n\t\t    (struct ucc_geth_rx_firmware_statistics_pram __iomem *)\n\t\t    qe_muram_addr(ugeth->rx_fw_statistics_pram_offset);\n\t}\n\n\t \n\n\t \n\tugeth->rx_irq_coalescing_tbl_offset =\n\t    qe_muram_alloc(ucc_geth_rx_queues(ug_info) *\n\t\t\t   sizeof(struct ucc_geth_rx_interrupt_coalescing_entry)\n\t\t\t   + 4, UCC_GETH_RX_INTERRUPT_COALESCING_ALIGNMENT);\n\tif (IS_ERR_VALUE(ugeth->rx_irq_coalescing_tbl_offset)) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Can not allocate DPRAM memory for p_rx_irq_coalescing_tbl\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tugeth->p_rx_irq_coalescing_tbl =\n\t    (struct ucc_geth_rx_interrupt_coalescing_table __iomem *)\n\t    qe_muram_addr(ugeth->rx_irq_coalescing_tbl_offset);\n\tout_be32(&ugeth->p_rx_glbl_pram->intcoalescingptr,\n\t\t ugeth->rx_irq_coalescing_tbl_offset);\n\n\t \n\tfor (i = 0; i < ucc_geth_rx_queues(ug_info); i++) {\n\t\tout_be32(&ugeth->p_rx_irq_coalescing_tbl->coalescingentry[i].\n\t\t\t interruptcoalescingmaxvalue,\n\t\t\t ug_info->interruptcoalescingmaxvalue[i]);\n\t\tout_be32(&ugeth->p_rx_irq_coalescing_tbl->coalescingentry[i].\n\t\t\t interruptcoalescingcounter,\n\t\t\t ug_info->interruptcoalescingmaxvalue[i]);\n\t}\n\n\t \n\tinit_max_rx_buff_len(uf_info->max_rx_buf_length,\n\t\t\t     &ugeth->p_rx_glbl_pram->mrblr);\n\t \n\tout_be16(&ugeth->p_rx_glbl_pram->mflr, ug_info->maxFrameLength);\n\t \n\tinit_min_frame_len(ug_info->minFrameLength,\n\t\t\t   &ugeth->p_rx_glbl_pram->minflr,\n\t\t\t   &ugeth->p_rx_glbl_pram->mrblr);\n\t \n\tout_be16(&ugeth->p_rx_glbl_pram->maxd1, ug_info->maxD1Length);\n\t \n\tout_be16(&ugeth->p_rx_glbl_pram->maxd2, ug_info->maxD2Length);\n\n\t \n\tl2qt = 0;\n\tfor (i = 0; i < UCC_GETH_VLAN_PRIORITY_MAX; i++)\n\t\tl2qt |= (ug_info->l2qt[i] << (28 - 4 * i));\n\tout_be32(&ugeth->p_rx_glbl_pram->l2qt, l2qt);\n\n\t \n\tfor (j = 0; j < UCC_GETH_IP_PRIORITY_MAX; j += 8) {\n\t\tl3qt = 0;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tl3qt |= (ug_info->l3qt[j + i] << (28 - 4 * i));\n\t\tout_be32(&ugeth->p_rx_glbl_pram->l3qt[j/8], l3qt);\n\t}\n\n\t \n\tout_be16(&ugeth->p_rx_glbl_pram->vlantype, ug_info->vlantype);\n\n\t \n\tout_be16(&ugeth->p_rx_glbl_pram->vlantci, ug_info->vlantci);\n\n\t \n\tout_be32(&ugeth->p_rx_glbl_pram->ecamptr, ug_info->ecamptr);\n\n\t \n\t \n\tugeth->rx_bd_qs_tbl_offset =\n\t    qe_muram_alloc(ucc_geth_rx_queues(ug_info) *\n\t\t\t   (sizeof(struct ucc_geth_rx_bd_queues_entry) +\n\t\t\t    sizeof(struct ucc_geth_rx_prefetched_bds)),\n\t\t\t   UCC_GETH_RX_BD_QUEUES_ALIGNMENT);\n\tif (IS_ERR_VALUE(ugeth->rx_bd_qs_tbl_offset)) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Can not allocate DPRAM memory for p_rx_bd_qs_tbl\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tugeth->p_rx_bd_qs_tbl =\n\t    (struct ucc_geth_rx_bd_queues_entry __iomem *) qe_muram_addr(ugeth->\n\t\t\t\t    rx_bd_qs_tbl_offset);\n\tout_be32(&ugeth->p_rx_glbl_pram->rbdqptr, ugeth->rx_bd_qs_tbl_offset);\n\n\t \n\t \n\tfor (i = 0; i < ucc_geth_rx_queues(ug_info); i++) {\n\t\tout_be32(&ugeth->p_rx_bd_qs_tbl[i].externalbdbaseptr,\n\t\t\t (u32) virt_to_phys(ugeth->p_rx_bd_ring[i]));\n\t\t \n\t}\n\n\t \n\t \n\n\tif (ugeth->rx_extended_features)\n\t\tremoder |= REMODER_RX_EXTENDED_FEATURES;\n\tif (ug_info->rxExtendedFiltering)\n\t\tremoder |= REMODER_RX_EXTENDED_FILTERING;\n\tif (ug_info->dynamicMaxFrameLength)\n\t\tremoder |= REMODER_DYNAMIC_MAX_FRAME_LENGTH;\n\tif (ug_info->dynamicMinFrameLength)\n\t\tremoder |= REMODER_DYNAMIC_MIN_FRAME_LENGTH;\n\tremoder |=\n\t    ug_info->vlanOperationTagged << REMODER_VLAN_OPERATION_TAGGED_SHIFT;\n\tremoder |=\n\t    ug_info->\n\t    vlanOperationNonTagged << REMODER_VLAN_OPERATION_NON_TAGGED_SHIFT;\n\tremoder |= ug_info->rxQoSMode << REMODER_RX_QOS_MODE_SHIFT;\n\tremoder |= ((ucc_geth_rx_queues(ug_info) - 1) << REMODER_NUM_OF_QUEUES_SHIFT);\n\tif (ug_info->ipCheckSumCheck)\n\t\tremoder |= REMODER_IP_CHECKSUM_CHECK;\n\tif (ug_info->ipAddressAlignment)\n\t\tremoder |= REMODER_IP_ADDRESS_ALIGNMENT;\n\tout_be32(&ugeth->p_rx_glbl_pram->remoder, remoder);\n\n\t \n\t \n\t \n\tinit_firmware_statistics_gathering_mode((ug_info->\n\t\tstatisticsMode &\n\t\tUCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_TX),\n\t\t(ug_info->statisticsMode &\n\t\tUCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_RX),\n\t\t&ugeth->p_tx_glbl_pram->txrmonbaseptr,\n\t\tugeth->tx_fw_statistics_pram_offset,\n\t\t&ugeth->p_rx_glbl_pram->rxrmonbaseptr,\n\t\tugeth->rx_fw_statistics_pram_offset,\n\t\t&ugeth->p_tx_glbl_pram->temoder,\n\t\t&ugeth->p_rx_glbl_pram->remoder);\n\n\t \n\tout_8(&ugeth->p_rx_glbl_pram->rstate, function_code);\n\n\t \n\tif (ug_info->rxExtendedFiltering) {\n\t\tif (!ug_info->extendedFilteringChainPointer) {\n\t\t\tif (netif_msg_ifup(ugeth))\n\t\t\t\tpr_err(\"Null Extended Filtering Chain Pointer\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tugeth->exf_glbl_param_offset =\n\t\t    qe_muram_alloc(sizeof(struct ucc_geth_exf_global_pram),\n\t\tUCC_GETH_RX_EXTENDED_FILTERING_GLOBAL_PARAMETERS_ALIGNMENT);\n\t\tif (IS_ERR_VALUE(ugeth->exf_glbl_param_offset)) {\n\t\t\tif (netif_msg_ifup(ugeth))\n\t\t\t\tpr_err(\"Can not allocate DPRAM memory for p_exf_glbl_param\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tugeth->p_exf_glbl_param =\n\t\t    (struct ucc_geth_exf_global_pram __iomem *) qe_muram_addr(ugeth->\n\t\t\t\t exf_glbl_param_offset);\n\t\tout_be32(&ugeth->p_rx_glbl_pram->exfGlobalParam,\n\t\t\t ugeth->exf_glbl_param_offset);\n\t\tout_be32(&ugeth->p_exf_glbl_param->l2pcdptr,\n\t\t\t (u32) ug_info->extendedFilteringChainPointer);\n\n\t} else {\t\t \n\n\t\t \n\n\t\tfor (j = 0; j < NUM_OF_PADDRS; j++)\n\t\t\tugeth_82xx_filtering_clear_addr_in_paddr(ugeth, (u8) j);\n\n\t\tp_82xx_addr_filt =\n\t\t    (struct ucc_geth_82xx_address_filtering_pram __iomem *) ugeth->\n\t\t    p_rx_glbl_pram->addressfiltering;\n\n\t\tugeth_82xx_filtering_clear_all_addr_in_hash(ugeth,\n\t\t\tENET_ADDR_TYPE_GROUP);\n\t\tugeth_82xx_filtering_clear_all_addr_in_hash(ugeth,\n\t\t\tENET_ADDR_TYPE_INDIVIDUAL);\n\t}\n\n\t \n\n\tcommand = QE_INIT_TX_RX;\n\n\t \n\tif (!(ugeth->p_init_enet_param_shadow =\n\t      kzalloc(sizeof(struct ucc_geth_init_pram), GFP_KERNEL))) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Can not allocate memory for p_UccInitEnetParamShadows\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\n\tugeth->p_init_enet_param_shadow->resinit1 =\n\t    ENET_INIT_PARAM_MAGIC_RES_INIT1;\n\tugeth->p_init_enet_param_shadow->resinit2 =\n\t    ENET_INIT_PARAM_MAGIC_RES_INIT2;\n\tugeth->p_init_enet_param_shadow->resinit3 =\n\t    ENET_INIT_PARAM_MAGIC_RES_INIT3;\n\tugeth->p_init_enet_param_shadow->resinit4 =\n\t    ENET_INIT_PARAM_MAGIC_RES_INIT4;\n\tugeth->p_init_enet_param_shadow->resinit5 =\n\t    ENET_INIT_PARAM_MAGIC_RES_INIT5;\n\tugeth->p_init_enet_param_shadow->rgftgfrxglobal |=\n\t    ((u32) ug_info->numThreadsRx) << ENET_INIT_PARAM_RGF_SHIFT;\n\tugeth->p_init_enet_param_shadow->rgftgfrxglobal |=\n\t    ((u32) ug_info->numThreadsTx) << ENET_INIT_PARAM_TGF_SHIFT;\n\n\tugeth->p_init_enet_param_shadow->rgftgfrxglobal |=\n\t    rx_glbl_pram_offset | ug_info->riscRx;\n\tif ((ug_info->largestexternallookupkeysize !=\n\t     QE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_NONE) &&\n\t    (ug_info->largestexternallookupkeysize !=\n\t     QE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_8_BYTES) &&\n\t    (ug_info->largestexternallookupkeysize !=\n\t     QE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_16_BYTES)) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Invalid largest External Lookup Key Size\\n\");\n\t\treturn -EINVAL;\n\t}\n\tugeth->p_init_enet_param_shadow->largestexternallookupkeysize =\n\t    ug_info->largestexternallookupkeysize;\n\tsize = sizeof(struct ucc_geth_thread_rx_pram);\n\tif (ug_info->rxExtendedFiltering) {\n\t\tsize += THREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING;\n\t\tif (ug_info->largestexternallookupkeysize ==\n\t\t    QE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_8_BYTES)\n\t\t\tsize +=\n\t\t\t    THREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING_8;\n\t\tif (ug_info->largestexternallookupkeysize ==\n\t\t    QE_FLTR_LARGEST_EXTERNAL_TABLE_LOOKUP_KEY_SIZE_16_BYTES)\n\t\t\tsize +=\n\t\t\t    THREAD_RX_PRAM_ADDITIONAL_FOR_EXTENDED_FILTERING_16;\n\t}\n\n\tif ((ret_val = fill_init_enet_entries(ugeth, &(ugeth->\n\t\tp_init_enet_param_shadow->rxthread[0]),\n\t\t(u8) (numThreadsRxNumerical + 1)\n\t\t \n\t\t, size, UCC_GETH_THREAD_RX_PRAM_ALIGNMENT,\n\t\tug_info->riscRx, 1)) != 0) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Can not fill p_init_enet_param_shadow\\n\");\n\t\treturn ret_val;\n\t}\n\n\tugeth->p_init_enet_param_shadow->txglobal =\n\t    tx_glbl_pram_offset | ug_info->riscTx;\n\tif ((ret_val =\n\t     fill_init_enet_entries(ugeth,\n\t\t\t\t    &(ugeth->p_init_enet_param_shadow->\n\t\t\t\t      txthread[0]), numThreadsTxNumerical,\n\t\t\t\t    sizeof(struct ucc_geth_thread_tx_pram),\n\t\t\t\t    UCC_GETH_THREAD_TX_PRAM_ALIGNMENT,\n\t\t\t\t    ug_info->riscTx, 0)) != 0) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Can not fill p_init_enet_param_shadow\\n\");\n\t\treturn ret_val;\n\t}\n\n\t \n\tfor (i = 0; i < ucc_geth_rx_queues(ug_info); i++) {\n\t\tif ((ret_val = rx_bd_buffer_set(ugeth, (u8) i)) != 0) {\n\t\t\tif (netif_msg_ifup(ugeth))\n\t\t\t\tpr_err(\"Can not fill Rx bds with buffers\\n\");\n\t\t\treturn ret_val;\n\t\t}\n\t}\n\n\t \n\tinit_enet_pram_offset = qe_muram_alloc(sizeof(struct ucc_geth_init_pram), 4);\n\tif (IS_ERR_VALUE(init_enet_pram_offset)) {\n\t\tif (netif_msg_ifup(ugeth))\n\t\t\tpr_err(\"Can not allocate DPRAM memory for p_init_enet_pram\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tp_init_enet_pram =\n\t    (struct ucc_geth_init_pram __iomem *) qe_muram_addr(init_enet_pram_offset);\n\n\t \n\tout_8(&p_init_enet_pram->resinit1,\n\t\t\tugeth->p_init_enet_param_shadow->resinit1);\n\tout_8(&p_init_enet_pram->resinit2,\n\t\t\tugeth->p_init_enet_param_shadow->resinit2);\n\tout_8(&p_init_enet_pram->resinit3,\n\t\t\tugeth->p_init_enet_param_shadow->resinit3);\n\tout_8(&p_init_enet_pram->resinit4,\n\t\t\tugeth->p_init_enet_param_shadow->resinit4);\n\tout_be16(&p_init_enet_pram->resinit5,\n\t\t ugeth->p_init_enet_param_shadow->resinit5);\n\tout_8(&p_init_enet_pram->largestexternallookupkeysize,\n\t    ugeth->p_init_enet_param_shadow->largestexternallookupkeysize);\n\tout_be32(&p_init_enet_pram->rgftgfrxglobal,\n\t\t ugeth->p_init_enet_param_shadow->rgftgfrxglobal);\n\tfor (i = 0; i < ENET_INIT_PARAM_MAX_ENTRIES_RX; i++)\n\t\tout_be32(&p_init_enet_pram->rxthread[i],\n\t\t\t ugeth->p_init_enet_param_shadow->rxthread[i]);\n\tout_be32(&p_init_enet_pram->txglobal,\n\t\t ugeth->p_init_enet_param_shadow->txglobal);\n\tfor (i = 0; i < ENET_INIT_PARAM_MAX_ENTRIES_TX; i++)\n\t\tout_be32(&p_init_enet_pram->txthread[i],\n\t\t\t ugeth->p_init_enet_param_shadow->txthread[i]);\n\n\t \n\tcecr_subblock =\n\t    ucc_fast_get_qe_cr_subblock(ugeth->ug_info->uf_info.ucc_num);\n\tqe_issue_cmd(command, cecr_subblock, QE_CR_PROTOCOL_ETHERNET,\n\t\t     init_enet_pram_offset);\n\n\t \n\tqe_muram_free(init_enet_pram_offset);\n\n\treturn 0;\n}\n\n \n \nstatic netdev_tx_t\nucc_geth_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(dev);\n#ifdef CONFIG_UGETH_TX_ON_DEMAND\n\tstruct ucc_fast_private *uccf;\n#endif\n\tu8 __iomem *bd;\t\t\t \n\tu32 bd_status;\n\tu8 txQ = 0;\n\tunsigned long flags;\n\n\tugeth_vdbg(\"%s: IN\", __func__);\n\n\tnetdev_sent_queue(dev, skb->len);\n\tspin_lock_irqsave(&ugeth->lock, flags);\n\n\tdev->stats.tx_bytes += skb->len;\n\n\t \n\tbd = ugeth->txBd[txQ];\n\tbd_status = in_be32((u32 __iomem *)bd);\n\t \n\tugeth->tx_skbuff[txQ][ugeth->skb_curtx[txQ]] = skb;\n\n\t \n\tugeth->skb_curtx[txQ] =\n\t    (ugeth->skb_curtx[txQ] +\n\t     1) & TX_RING_MOD_MASK(ugeth->ug_info->bdRingLenTx[txQ]);\n\n\t \n\tout_be32(&((struct qe_bd __iomem *)bd)->buf,\n\t\t      dma_map_single(ugeth->dev, skb->data,\n\t\t\t      skb->len, DMA_TO_DEVICE));\n\n\t \n\n\tbd_status = (bd_status & T_W) | T_R | T_I | T_L | skb->len;\n\n\t \n\tout_be32((u32 __iomem *)bd, bd_status);\n\n\t \n\tif (!(bd_status & T_W))\n\t\tbd += sizeof(struct qe_bd);\n\telse\n\t\tbd = ugeth->p_tx_bd_ring[txQ];\n\n\t \n\tif (bd == ugeth->confBd[txQ]) {\n\t\tif (!netif_queue_stopped(dev))\n\t\t\tnetif_stop_queue(dev);\n\t}\n\n\tugeth->txBd[txQ] = bd;\n\n\tskb_tx_timestamp(skb);\n\n\tif (ugeth->p_scheduler) {\n\t\tugeth->cpucount[txQ]++;\n\t\t \n\t\t \n\t\tout_be16(ugeth->p_cpucount[txQ], ugeth->cpucount[txQ]);\n\t}\n\n#ifdef CONFIG_UGETH_TX_ON_DEMAND\n\tuccf = ugeth->uccf;\n\tout_be16(uccf->p_utodr, UCC_FAST_TOD);\n#endif\n\tspin_unlock_irqrestore(&ugeth->lock, flags);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ucc_geth_rx(struct ucc_geth_private *ugeth, u8 rxQ, int rx_work_limit)\n{\n\tstruct sk_buff *skb;\n\tu8 __iomem *bd;\n\tu16 length, howmany = 0;\n\tu32 bd_status;\n\tu8 *bdBuffer;\n\tstruct net_device *dev;\n\n\tugeth_vdbg(\"%s: IN\", __func__);\n\n\tdev = ugeth->ndev;\n\n\t \n\tbd = ugeth->rxBd[rxQ];\n\n\tbd_status = in_be32((u32 __iomem *)bd);\n\n\t \n\twhile (!((bd_status & (R_E)) || (--rx_work_limit < 0))) {\n\t\tbdBuffer = (u8 *) in_be32(&((struct qe_bd __iomem *)bd)->buf);\n\t\tlength = (u16) ((bd_status & BD_LENGTH_MASK) - 4);\n\t\tskb = ugeth->rx_skbuff[rxQ][ugeth->skb_currx[rxQ]];\n\n\t\t \n\t\tif (!skb ||\n\t\t    (!(bd_status & (R_F | R_L))) ||\n\t\t    (bd_status & R_ERRORS_FATAL)) {\n\t\t\tif (netif_msg_rx_err(ugeth))\n\t\t\t\tpr_err(\"%d: ERROR!!! skb - 0x%08x\\n\",\n\t\t\t\t       __LINE__, (u32)skb);\n\t\t\tdev_kfree_skb(skb);\n\n\t\t\tugeth->rx_skbuff[rxQ][ugeth->skb_currx[rxQ]] = NULL;\n\t\t\tdev->stats.rx_dropped++;\n\t\t} else {\n\t\t\tdev->stats.rx_packets++;\n\t\t\thowmany++;\n\n\t\t\t \n\t\t\tskb_put(skb, length);\n\n\t\t\t \n\t\t\tskb->protocol = eth_type_trans(skb, ugeth->ndev);\n\n\t\t\tdev->stats.rx_bytes += length;\n\t\t\t \n\t\t\tnetif_receive_skb(skb);\n\t\t}\n\n\t\tskb = get_new_skb(ugeth, bd);\n\t\tif (!skb) {\n\t\t\tif (netif_msg_rx_err(ugeth))\n\t\t\t\tpr_warn(\"No Rx Data Buffer\\n\");\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tbreak;\n\t\t}\n\n\t\tugeth->rx_skbuff[rxQ][ugeth->skb_currx[rxQ]] = skb;\n\n\t\t \n\t\tugeth->skb_currx[rxQ] =\n\t\t    (ugeth->skb_currx[rxQ] +\n\t\t     1) & RX_RING_MOD_MASK(ugeth->ug_info->bdRingLenRx[rxQ]);\n\n\t\tif (bd_status & R_W)\n\t\t\tbd = ugeth->p_rx_bd_ring[rxQ];\n\t\telse\n\t\t\tbd += sizeof(struct qe_bd);\n\n\t\tbd_status = in_be32((u32 __iomem *)bd);\n\t}\n\n\tugeth->rxBd[rxQ] = bd;\n\treturn howmany;\n}\n\nstatic int ucc_geth_tx(struct net_device *dev, u8 txQ)\n{\n\t \n\tstruct ucc_geth_private *ugeth = netdev_priv(dev);\n\tunsigned int bytes_sent = 0;\n\tint howmany = 0;\n\tu8 __iomem *bd;\t\t \n\tu32 bd_status;\n\n\tbd = ugeth->confBd[txQ];\n\tbd_status = in_be32((u32 __iomem *)bd);\n\n\t \n\twhile ((bd_status & T_R) == 0) {\n\t\tstruct sk_buff *skb;\n\n\t\t \n\t\t \n\t\t \n\n\t\tskb = ugeth->tx_skbuff[txQ][ugeth->skb_dirtytx[txQ]];\n\t\tif (!skb)\n\t\t\tbreak;\n\t\thowmany++;\n\t\tbytes_sent += skb->len;\n\t\tdev->stats.tx_packets++;\n\n\t\tdev_consume_skb_any(skb);\n\n\t\tugeth->tx_skbuff[txQ][ugeth->skb_dirtytx[txQ]] = NULL;\n\t\tugeth->skb_dirtytx[txQ] =\n\t\t    (ugeth->skb_dirtytx[txQ] +\n\t\t     1) & TX_RING_MOD_MASK(ugeth->ug_info->bdRingLenTx[txQ]);\n\n\t\t \n\t\tif (netif_queue_stopped(dev))\n\t\t\tnetif_wake_queue(dev);\n\n\t\t \n\t\tif (!(bd_status & T_W))\n\t\t\tbd += sizeof(struct qe_bd);\n\t\telse\n\t\t\tbd = ugeth->p_tx_bd_ring[txQ];\n\t\tbd_status = in_be32((u32 __iomem *)bd);\n\t}\n\tugeth->confBd[txQ] = bd;\n\tnetdev_completed_queue(dev, howmany, bytes_sent);\n\treturn 0;\n}\n\nstatic int ucc_geth_poll(struct napi_struct *napi, int budget)\n{\n\tstruct ucc_geth_private *ugeth = container_of(napi, struct ucc_geth_private, napi);\n\tstruct ucc_geth_info *ug_info;\n\tint howmany, i;\n\n\tug_info = ugeth->ug_info;\n\n\t \n\tspin_lock(&ugeth->lock);\n\tfor (i = 0; i < ucc_geth_tx_queues(ug_info); i++)\n\t\tucc_geth_tx(ugeth->ndev, i);\n\tspin_unlock(&ugeth->lock);\n\n\thowmany = 0;\n\tfor (i = 0; i < ucc_geth_rx_queues(ug_info); i++)\n\t\thowmany += ucc_geth_rx(ugeth, i, budget - howmany);\n\n\tif (howmany < budget) {\n\t\tnapi_complete_done(napi, howmany);\n\t\tsetbits32(ugeth->uccf->p_uccm, UCCE_RX_EVENTS | UCCE_TX_EVENTS);\n\t}\n\n\treturn howmany;\n}\n\nstatic irqreturn_t ucc_geth_irq_handler(int irq, void *info)\n{\n\tstruct net_device *dev = info;\n\tstruct ucc_geth_private *ugeth = netdev_priv(dev);\n\tstruct ucc_fast_private *uccf;\n\tstruct ucc_geth_info *ug_info;\n\tregister u32 ucce;\n\tregister u32 uccm;\n\n\tugeth_vdbg(\"%s: IN\", __func__);\n\n\tuccf = ugeth->uccf;\n\tug_info = ugeth->ug_info;\n\n\t \n\tucce = (u32) in_be32(uccf->p_ucce);\n\tuccm = (u32) in_be32(uccf->p_uccm);\n\tucce &= uccm;\n\tout_be32(uccf->p_ucce, ucce);\n\n\t \n\tif (ucce & (UCCE_RX_EVENTS | UCCE_TX_EVENTS)) {\n\t\tif (napi_schedule_prep(&ugeth->napi)) {\n\t\t\tuccm &= ~(UCCE_RX_EVENTS | UCCE_TX_EVENTS);\n\t\t\tout_be32(uccf->p_uccm, uccm);\n\t\t\t__napi_schedule(&ugeth->napi);\n\t\t}\n\t}\n\n\t \n\tif (ucce & UCCE_OTHER) {\n\t\tif (ucce & UCC_GETH_UCCE_BSY)\n\t\t\tdev->stats.rx_errors++;\n\t\tif (ucce & UCC_GETH_UCCE_TXE)\n\t\t\tdev->stats.tx_errors++;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void ucc_netpoll(struct net_device *dev)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(dev);\n\tint irq = ugeth->ug_info->uf_info.irq;\n\n\tdisable_irq(irq);\n\tucc_geth_irq_handler(irq, dev);\n\tenable_irq(irq);\n}\n#endif  \n\nstatic int ucc_geth_set_mac_addr(struct net_device *dev, void *p)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(dev);\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\t \n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tspin_lock_irq(&ugeth->lock);\n\tinit_mac_station_addr_regs(dev->dev_addr[0],\n\t\t\t\t   dev->dev_addr[1],\n\t\t\t\t   dev->dev_addr[2],\n\t\t\t\t   dev->dev_addr[3],\n\t\t\t\t   dev->dev_addr[4],\n\t\t\t\t   dev->dev_addr[5],\n\t\t\t\t   &ugeth->ug_regs->macstnaddr1,\n\t\t\t\t   &ugeth->ug_regs->macstnaddr2);\n\tspin_unlock_irq(&ugeth->lock);\n\n\treturn 0;\n}\n\nstatic int ucc_geth_init_mac(struct ucc_geth_private *ugeth)\n{\n\tstruct net_device *dev = ugeth->ndev;\n\tint err;\n\n\terr = ucc_struct_init(ugeth);\n\tif (err) {\n\t\tnetif_err(ugeth, ifup, dev, \"Cannot configure internal struct, aborting\\n\");\n\t\tgoto err;\n\t}\n\n\terr = ucc_geth_startup(ugeth);\n\tif (err) {\n\t\tnetif_err(ugeth, ifup, dev, \"Cannot configure net device, aborting\\n\");\n\t\tgoto err;\n\t}\n\n\terr = adjust_enet_interface(ugeth);\n\tif (err) {\n\t\tnetif_err(ugeth, ifup, dev, \"Cannot configure net device, aborting\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\t \n\tinit_mac_station_addr_regs(dev->dev_addr[0],\n\t\t\t\t   dev->dev_addr[1],\n\t\t\t\t   dev->dev_addr[2],\n\t\t\t\t   dev->dev_addr[3],\n\t\t\t\t   dev->dev_addr[4],\n\t\t\t\t   dev->dev_addr[5],\n\t\t\t\t   &ugeth->ug_regs->macstnaddr1,\n\t\t\t\t   &ugeth->ug_regs->macstnaddr2);\n\n\terr = ugeth_enable(ugeth, COMM_DIR_RX_AND_TX);\n\tif (err) {\n\t\tnetif_err(ugeth, ifup, dev, \"Cannot enable net device, aborting\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tucc_geth_stop(ugeth);\n\treturn err;\n}\n\n \n \nstatic int ucc_geth_open(struct net_device *dev)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(dev);\n\tint err;\n\n\tugeth_vdbg(\"%s: IN\", __func__);\n\n\t \n\tif (dev->dev_addr[0] & ENET_GROUP_ADDR) {\n\t\tnetif_err(ugeth, ifup, dev,\n\t\t\t  \"Multicast address used for station address - is this what you wanted?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = init_phy(dev);\n\tif (err) {\n\t\tnetif_err(ugeth, ifup, dev, \"Cannot initialize PHY, aborting\\n\");\n\t\treturn err;\n\t}\n\n\terr = ucc_geth_init_mac(ugeth);\n\tif (err) {\n\t\tnetif_err(ugeth, ifup, dev, \"Cannot initialize MAC, aborting\\n\");\n\t\tgoto err;\n\t}\n\n\terr = request_irq(ugeth->ug_info->uf_info.irq, ucc_geth_irq_handler,\n\t\t\t  0, \"UCC Geth\", dev);\n\tif (err) {\n\t\tnetif_err(ugeth, ifup, dev, \"Cannot get IRQ for net device, aborting\\n\");\n\t\tgoto err;\n\t}\n\n\tphy_start(ugeth->phydev);\n\tnapi_enable(&ugeth->napi);\n\tnetdev_reset_queue(dev);\n\tnetif_start_queue(dev);\n\n\tdevice_set_wakeup_capable(&dev->dev,\n\t\t\tqe_alive_during_sleep() || ugeth->phydev->irq);\n\tdevice_set_wakeup_enable(&dev->dev, ugeth->wol_en);\n\n\treturn err;\n\nerr:\n\tucc_geth_stop(ugeth);\n\treturn err;\n}\n\n \nstatic int ucc_geth_close(struct net_device *dev)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(dev);\n\n\tugeth_vdbg(\"%s: IN\", __func__);\n\n\tnapi_disable(&ugeth->napi);\n\n\tcancel_work_sync(&ugeth->timeout_work);\n\tucc_geth_stop(ugeth);\n\tphy_disconnect(ugeth->phydev);\n\tugeth->phydev = NULL;\n\n\tfree_irq(ugeth->ug_info->uf_info.irq, ugeth->ndev);\n\n\tnetif_stop_queue(dev);\n\tnetdev_reset_queue(dev);\n\n\treturn 0;\n}\n\n \nstatic void ucc_geth_timeout_work(struct work_struct *work)\n{\n\tstruct ucc_geth_private *ugeth;\n\tstruct net_device *dev;\n\n\tugeth = container_of(work, struct ucc_geth_private, timeout_work);\n\tdev = ugeth->ndev;\n\n\tugeth_vdbg(\"%s: IN\", __func__);\n\n\tdev->stats.tx_errors++;\n\n\tugeth_dump_regs(ugeth);\n\n\tif (dev->flags & IFF_UP) {\n\t\t \n\t\tnetif_tx_stop_all_queues(dev);\n\t\tucc_geth_stop(ugeth);\n\t\tucc_geth_init_mac(ugeth);\n\t\t \n\t\tphy_start(ugeth->phydev);\n\t\tnetif_tx_start_all_queues(dev);\n\t}\n\n\tnetif_tx_schedule_all(dev);\n}\n\n \nstatic void ucc_geth_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(dev);\n\n\tschedule_work(&ugeth->timeout_work);\n}\n\n\n#ifdef CONFIG_PM\n\nstatic int ucc_geth_suspend(struct platform_device *ofdev, pm_message_t state)\n{\n\tstruct net_device *ndev = platform_get_drvdata(ofdev);\n\tstruct ucc_geth_private *ugeth = netdev_priv(ndev);\n\n\tif (!netif_running(ndev))\n\t\treturn 0;\n\n\tnetif_device_detach(ndev);\n\tnapi_disable(&ugeth->napi);\n\n\t \n\tugeth_disable(ugeth, COMM_DIR_RX_AND_TX);\n\n\tif (ugeth->wol_en & WAKE_MAGIC) {\n\t\tsetbits32(ugeth->uccf->p_uccm, UCC_GETH_UCCE_MPD);\n\t\tsetbits32(&ugeth->ug_regs->maccfg2, MACCFG2_MPE);\n\t\tucc_fast_enable(ugeth->uccf, COMM_DIR_RX_AND_TX);\n\t} else if (!(ugeth->wol_en & WAKE_PHY)) {\n\t\tphy_stop(ugeth->phydev);\n\t}\n\n\treturn 0;\n}\n\nstatic int ucc_geth_resume(struct platform_device *ofdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(ofdev);\n\tstruct ucc_geth_private *ugeth = netdev_priv(ndev);\n\tint err;\n\n\tif (!netif_running(ndev))\n\t\treturn 0;\n\n\tif (qe_alive_during_sleep()) {\n\t\tif (ugeth->wol_en & WAKE_MAGIC) {\n\t\t\tucc_fast_disable(ugeth->uccf, COMM_DIR_RX_AND_TX);\n\t\t\tclrbits32(&ugeth->ug_regs->maccfg2, MACCFG2_MPE);\n\t\t\tclrbits32(ugeth->uccf->p_uccm, UCC_GETH_UCCE_MPD);\n\t\t}\n\t\tugeth_enable(ugeth, COMM_DIR_RX_AND_TX);\n\t} else {\n\t\t \n\t\tucc_geth_memclean(ugeth);\n\n\t\terr = ucc_geth_init_mac(ugeth);\n\t\tif (err) {\n\t\t\tnetdev_err(ndev, \"Cannot initialize MAC, aborting\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tugeth->oldlink = 0;\n\tugeth->oldspeed = 0;\n\tugeth->oldduplex = -1;\n\n\tphy_stop(ugeth->phydev);\n\tphy_start(ugeth->phydev);\n\n\tnapi_enable(&ugeth->napi);\n\tnetif_device_attach(ndev);\n\n\treturn 0;\n}\n\n#else\n#define ucc_geth_suspend NULL\n#define ucc_geth_resume NULL\n#endif\n\nstatic phy_interface_t to_phy_interface(const char *phy_connection_type)\n{\n\tif (strcasecmp(phy_connection_type, \"mii\") == 0)\n\t\treturn PHY_INTERFACE_MODE_MII;\n\tif (strcasecmp(phy_connection_type, \"gmii\") == 0)\n\t\treturn PHY_INTERFACE_MODE_GMII;\n\tif (strcasecmp(phy_connection_type, \"tbi\") == 0)\n\t\treturn PHY_INTERFACE_MODE_TBI;\n\tif (strcasecmp(phy_connection_type, \"rmii\") == 0)\n\t\treturn PHY_INTERFACE_MODE_RMII;\n\tif (strcasecmp(phy_connection_type, \"rgmii\") == 0)\n\t\treturn PHY_INTERFACE_MODE_RGMII;\n\tif (strcasecmp(phy_connection_type, \"rgmii-id\") == 0)\n\t\treturn PHY_INTERFACE_MODE_RGMII_ID;\n\tif (strcasecmp(phy_connection_type, \"rgmii-txid\") == 0)\n\t\treturn PHY_INTERFACE_MODE_RGMII_TXID;\n\tif (strcasecmp(phy_connection_type, \"rgmii-rxid\") == 0)\n\t\treturn PHY_INTERFACE_MODE_RGMII_RXID;\n\tif (strcasecmp(phy_connection_type, \"rtbi\") == 0)\n\t\treturn PHY_INTERFACE_MODE_RTBI;\n\tif (strcasecmp(phy_connection_type, \"sgmii\") == 0)\n\t\treturn PHY_INTERFACE_MODE_SGMII;\n\n\treturn PHY_INTERFACE_MODE_MII;\n}\n\nstatic int ucc_geth_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\n\tif (!ugeth->phydev)\n\t\treturn -ENODEV;\n\n\treturn phy_mii_ioctl(ugeth->phydev, rq, cmd);\n}\n\nstatic const struct net_device_ops ucc_geth_netdev_ops = {\n\t.ndo_open\t\t= ucc_geth_open,\n\t.ndo_stop\t\t= ucc_geth_close,\n\t.ndo_start_xmit\t\t= ucc_geth_start_xmit,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_change_carrier     = fixed_phy_change_carrier,\n\t.ndo_set_mac_address\t= ucc_geth_set_mac_addr,\n\t.ndo_set_rx_mode\t= ucc_geth_set_multi,\n\t.ndo_tx_timeout\t\t= ucc_geth_timeout,\n\t.ndo_eth_ioctl\t\t= ucc_geth_ioctl,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= ucc_netpoll,\n#endif\n};\n\nstatic int ucc_geth_parse_clock(struct device_node *np, const char *which,\n\t\t\t\tenum qe_clock *out)\n{\n\tconst char *sprop;\n\tchar buf[24];\n\n\tsnprintf(buf, sizeof(buf), \"%s-clock-name\", which);\n\tsprop = of_get_property(np, buf, NULL);\n\tif (sprop) {\n\t\t*out = qe_clock_source(sprop);\n\t} else {\n\t\tu32 val;\n\n\t\tsnprintf(buf, sizeof(buf), \"%s-clock\", which);\n\t\tif (of_property_read_u32(np, buf, &val)) {\n\t\t\t \n\t\t\tpr_err(\"missing %s-clock-name property\\n\", buf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*out = val;\n\t}\n\tif (*out < QE_CLK_NONE || *out > QE_CLK24) {\n\t\tpr_err(\"invalid %s property\\n\", buf);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int ucc_geth_probe(struct platform_device* ofdev)\n{\n\tstruct device *device = &ofdev->dev;\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct net_device *dev = NULL;\n\tstruct ucc_geth_private *ugeth = NULL;\n\tstruct ucc_geth_info *ug_info;\n\tstruct resource res;\n\tint err, ucc_num, max_speed = 0;\n\tconst unsigned int *prop;\n\tphy_interface_t phy_interface;\n\tstatic const int enet_to_speed[] = {\n\t\tSPEED_10, SPEED_10, SPEED_10,\n\t\tSPEED_100, SPEED_100, SPEED_100,\n\t\tSPEED_1000, SPEED_1000, SPEED_1000, SPEED_1000,\n\t};\n\tstatic const phy_interface_t enet_to_phy_interface[] = {\n\t\tPHY_INTERFACE_MODE_MII, PHY_INTERFACE_MODE_RMII,\n\t\tPHY_INTERFACE_MODE_RGMII, PHY_INTERFACE_MODE_MII,\n\t\tPHY_INTERFACE_MODE_RMII, PHY_INTERFACE_MODE_RGMII,\n\t\tPHY_INTERFACE_MODE_GMII, PHY_INTERFACE_MODE_RGMII,\n\t\tPHY_INTERFACE_MODE_TBI, PHY_INTERFACE_MODE_RTBI,\n\t\tPHY_INTERFACE_MODE_SGMII,\n\t};\n\n\tugeth_vdbg(\"%s: IN\", __func__);\n\n\tprop = of_get_property(np, \"cell-index\", NULL);\n\tif (!prop) {\n\t\tprop = of_get_property(np, \"device-id\", NULL);\n\t\tif (!prop)\n\t\t\treturn -ENODEV;\n\t}\n\n\tucc_num = *prop - 1;\n\tif ((ucc_num < 0) || (ucc_num > 7))\n\t\treturn -ENODEV;\n\n\tug_info = kmemdup(&ugeth_primary_info, sizeof(*ug_info), GFP_KERNEL);\n\tif (ug_info == NULL)\n\t\treturn -ENOMEM;\n\n\tug_info->uf_info.ucc_num = ucc_num;\n\n\terr = ucc_geth_parse_clock(np, \"rx\", &ug_info->uf_info.rx_clock);\n\tif (err)\n\t\tgoto err_free_info;\n\terr = ucc_geth_parse_clock(np, \"tx\", &ug_info->uf_info.tx_clock);\n\tif (err)\n\t\tgoto err_free_info;\n\n\terr = of_address_to_resource(np, 0, &res);\n\tif (err)\n\t\tgoto err_free_info;\n\n\tug_info->uf_info.regs = res.start;\n\tug_info->uf_info.irq = irq_of_parse_and_map(np, 0);\n\n\tug_info->phy_node = of_parse_phandle(np, \"phy-handle\", 0);\n\tif (!ug_info->phy_node && of_phy_is_fixed_link(np)) {\n\t\t \n\t\terr = of_phy_register_fixed_link(np);\n\t\tif (err)\n\t\t\tgoto err_free_info;\n\t\tug_info->phy_node = of_node_get(np);\n\t}\n\n\t \n\tug_info->tbi_node = of_parse_phandle(np, \"tbi-handle\", 0);\n\n\t \n\tprop = of_get_property(np, \"phy-connection-type\", NULL);\n\tif (!prop) {\n\t\t \n\t\tprop = of_get_property(ug_info->phy_node, \"interface\", NULL);\n\t\tif (prop != NULL) {\n\t\t\tphy_interface = enet_to_phy_interface[*prop];\n\t\t\tmax_speed = enet_to_speed[*prop];\n\t\t} else\n\t\t\tphy_interface = PHY_INTERFACE_MODE_MII;\n\t} else {\n\t\tphy_interface = to_phy_interface((const char *)prop);\n\t}\n\n\t \n\tif (max_speed == 0)\n\t\tswitch (phy_interface) {\n\t\tcase PHY_INTERFACE_MODE_GMII:\n\t\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tcase PHY_INTERFACE_MODE_TBI:\n\t\tcase PHY_INTERFACE_MODE_RTBI:\n\t\tcase PHY_INTERFACE_MODE_SGMII:\n\t\t\tmax_speed = SPEED_1000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmax_speed = SPEED_100;\n\t\t\tbreak;\n\t\t}\n\n\tif (max_speed == SPEED_1000) {\n\t\tunsigned int snums = qe_get_num_of_snums();\n\n\t\t \n\t\tug_info->uf_info.urfs = UCC_GETH_URFS_GIGA_INIT;\n\t\tug_info->uf_info.urfet = UCC_GETH_URFET_GIGA_INIT;\n\t\tug_info->uf_info.urfset = UCC_GETH_URFSET_GIGA_INIT;\n\t\tug_info->uf_info.utfs = UCC_GETH_UTFS_GIGA_INIT;\n\t\tug_info->uf_info.utfet = UCC_GETH_UTFET_GIGA_INIT;\n\t\tug_info->uf_info.utftt = UCC_GETH_UTFTT_GIGA_INIT;\n\t\tug_info->numThreadsTx = UCC_GETH_NUM_OF_THREADS_4;\n\n\t\t \n\t\tif ((snums == 76) || (snums == 46))\n\t\t\tug_info->numThreadsRx = UCC_GETH_NUM_OF_THREADS_6;\n\t\telse\n\t\t\tug_info->numThreadsRx = UCC_GETH_NUM_OF_THREADS_4;\n\t}\n\n\tif (netif_msg_probe(&debug))\n\t\tpr_info(\"UCC%1d at 0x%8llx (irq = %d)\\n\",\n\t\t\tug_info->uf_info.ucc_num + 1,\n\t\t\t(u64)ug_info->uf_info.regs,\n\t\t\tug_info->uf_info.irq);\n\n\t \n\tdev = alloc_etherdev(sizeof(*ugeth));\n\n\tif (dev == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err_deregister_fixed_link;\n\t}\n\n\tugeth = netdev_priv(dev);\n\tspin_lock_init(&ugeth->lock);\n\n\t \n\tINIT_LIST_HEAD(&ugeth->group_hash_q);\n\tINIT_LIST_HEAD(&ugeth->ind_hash_q);\n\n\tdev_set_drvdata(device, dev);\n\n\t \n\tdev->base_addr = (unsigned long)(ug_info->uf_info.regs);\n\n\tSET_NETDEV_DEV(dev, device);\n\n\t \n\tuec_set_ethtool_ops(dev);\n\tdev->netdev_ops = &ucc_geth_netdev_ops;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tINIT_WORK(&ugeth->timeout_work, ucc_geth_timeout_work);\n\tnetif_napi_add(dev, &ugeth->napi, ucc_geth_poll);\n\tdev->mtu = 1500;\n\tdev->max_mtu = 1518;\n\n\tugeth->msg_enable = netif_msg_init(debug.msg_enable, UGETH_MSG_DEFAULT);\n\tugeth->phy_interface = phy_interface;\n\tugeth->max_speed = max_speed;\n\n\t \n\tnetif_carrier_off(dev);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tif (netif_msg_probe(ugeth))\n\t\t\tpr_err(\"%s: Cannot register net device, aborting\\n\",\n\t\t\t       dev->name);\n\t\tgoto err_free_netdev;\n\t}\n\n\tof_get_ethdev_address(np, dev);\n\n\tugeth->ug_info = ug_info;\n\tugeth->dev = device;\n\tugeth->ndev = dev;\n\tugeth->node = np;\n\n\treturn 0;\n\nerr_free_netdev:\n\tfree_netdev(dev);\nerr_deregister_fixed_link:\n\tif (of_phy_is_fixed_link(np))\n\t\tof_phy_deregister_fixed_link(np);\n\tof_node_put(ug_info->tbi_node);\n\tof_node_put(ug_info->phy_node);\nerr_free_info:\n\tkfree(ug_info);\n\n\treturn err;\n}\n\nstatic void ucc_geth_remove(struct platform_device* ofdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(ofdev);\n\tstruct ucc_geth_private *ugeth = netdev_priv(dev);\n\tstruct device_node *np = ofdev->dev.of_node;\n\n\tunregister_netdev(dev);\n\tucc_geth_memclean(ugeth);\n\tif (of_phy_is_fixed_link(np))\n\t\tof_phy_deregister_fixed_link(np);\n\tof_node_put(ugeth->ug_info->tbi_node);\n\tof_node_put(ugeth->ug_info->phy_node);\n\tkfree(ugeth->ug_info);\n\tfree_netdev(dev);\n}\n\nstatic const struct of_device_id ucc_geth_match[] = {\n\t{\n\t\t.type = \"network\",\n\t\t.compatible = \"ucc_geth\",\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, ucc_geth_match);\n\nstatic struct platform_driver ucc_geth_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = ucc_geth_match,\n\t},\n\t.probe\t\t= ucc_geth_probe,\n\t.remove_new\t= ucc_geth_remove,\n\t.suspend\t= ucc_geth_suspend,\n\t.resume\t\t= ucc_geth_resume,\n};\n\nstatic int __init ucc_geth_init(void)\n{\n\tif (netif_msg_drv(&debug))\n\t\tpr_info(DRV_DESC \"\\n\");\n\n\treturn platform_driver_register(&ucc_geth_driver);\n}\n\nstatic void __exit ucc_geth_exit(void)\n{\n\tplatform_driver_unregister(&ucc_geth_driver);\n}\n\nmodule_init(ucc_geth_init);\nmodule_exit(ucc_geth_exit);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc\");\nMODULE_DESCRIPTION(DRV_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}