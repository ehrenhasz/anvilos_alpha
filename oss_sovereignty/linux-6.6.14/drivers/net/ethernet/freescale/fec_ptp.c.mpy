{
  "module_name": "fec_ptp.c",
  "hash_id": "afbc8fe3f95e034eb6be2625e6132b70537d5d9a282de241d3069ee9b1c490cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fec_ptp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/clk.h>\n#include <linux/platform_device.h>\n#include <linux/phy.h>\n#include <linux/fec.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/of_net.h>\n\n#include \"fec.h\"\n\n \n#define FEC_T_CTRL_SLAVE                0x00002000\n#define FEC_T_CTRL_CAPTURE              0x00000800\n#define FEC_T_CTRL_RESTART              0x00000200\n#define FEC_T_CTRL_PERIOD_RST           0x00000030\n#define FEC_T_CTRL_PERIOD_EN\t\t0x00000010\n#define FEC_T_CTRL_ENABLE               0x00000001\n\n#define FEC_T_INC_MASK                  0x0000007f\n#define FEC_T_INC_OFFSET                0\n#define FEC_T_INC_CORR_MASK             0x00007f00\n#define FEC_T_INC_CORR_OFFSET           8\n\n#define FEC_T_CTRL_PINPER\t\t0x00000080\n#define FEC_T_TF0_MASK\t\t\t0x00000001\n#define FEC_T_TF0_OFFSET\t\t0\n#define FEC_T_TF1_MASK\t\t\t0x00000002\n#define FEC_T_TF1_OFFSET\t\t1\n#define FEC_T_TF2_MASK\t\t\t0x00000004\n#define FEC_T_TF2_OFFSET\t\t2\n#define FEC_T_TF3_MASK\t\t\t0x00000008\n#define FEC_T_TF3_OFFSET\t\t3\n#define FEC_T_TDRE_MASK\t\t\t0x00000001\n#define FEC_T_TDRE_OFFSET\t\t0\n#define FEC_T_TMODE_MASK\t\t0x0000003C\n#define FEC_T_TMODE_OFFSET\t\t2\n#define FEC_T_TIE_MASK\t\t\t0x00000040\n#define FEC_T_TIE_OFFSET\t\t6\n#define FEC_T_TF_MASK\t\t\t0x00000080\n#define FEC_T_TF_OFFSET\t\t\t7\n\n#define FEC_ATIME_CTRL\t\t0x400\n#define FEC_ATIME\t\t0x404\n#define FEC_ATIME_EVT_OFFSET\t0x408\n#define FEC_ATIME_EVT_PERIOD\t0x40c\n#define FEC_ATIME_CORR\t\t0x410\n#define FEC_ATIME_INC\t\t0x414\n#define FEC_TS_TIMESTAMP\t0x418\n\n#define FEC_TGSR\t\t0x604\n#define FEC_TCSR(n)\t\t(0x608 + n * 0x08)\n#define FEC_TCCR(n)\t\t(0x60C + n * 0x08)\n#define MAX_TIMER_CHANNEL\t3\n#define FEC_TMODE_TOGGLE\t0x05\n#define FEC_HIGH_PULSE\t\t0x0F\n\n#define FEC_CC_MULT\t(1 << 31)\n#define FEC_COUNTER_PERIOD\t(1 << 31)\n#define PPS_OUPUT_RELOAD_PERIOD\tNSEC_PER_SEC\n#define FEC_CHANNLE_0\t\t0\n#define DEFAULT_PPS_CHANNEL\tFEC_CHANNLE_0\n\n#define FEC_PTP_MAX_NSEC_PERIOD\t\t4000000000ULL\n#define FEC_PTP_MAX_NSEC_COUNTER\t0x80000000ULL\n\n \nstatic int fec_ptp_enable_pps(struct fec_enet_private *fep, uint enable)\n{\n\tunsigned long flags;\n\tu32 val, tempval;\n\tstruct timespec64 ts;\n\tu64 ns;\n\n\tif (fep->pps_enable == enable)\n\t\treturn 0;\n\n\tfep->pps_channel = DEFAULT_PPS_CHANNEL;\n\tfep->reload_period = PPS_OUPUT_RELOAD_PERIOD;\n\n\tspin_lock_irqsave(&fep->tmreg_lock, flags);\n\n\tif (enable) {\n\t\t \n\t\twritel(FEC_T_TF_MASK, fep->hwp + FEC_TCSR(fep->pps_channel));\n\n\t\t \n\t\tval = readl(fep->hwp + FEC_TCSR(fep->pps_channel));\n\t\tdo {\n\t\t\tval &= ~(FEC_T_TMODE_MASK);\n\t\t\twritel(val, fep->hwp + FEC_TCSR(fep->pps_channel));\n\t\t\tval = readl(fep->hwp + FEC_TCSR(fep->pps_channel));\n\t\t} while (val & FEC_T_TMODE_MASK);\n\n\t\t \n\t\ttimecounter_read(&fep->tc);\n\t\t \n\t\ttempval = fep->cc.read(&fep->cc);\n\t\t \n\t\tns = timecounter_cyc2time(&fep->tc, tempval);\n\t\tts = ns_to_timespec64(ns);\n\n\t\t \n\t\tval = NSEC_PER_SEC - (u32)ts.tv_nsec + tempval;\n\n\t\t \n\t\tval += NSEC_PER_SEC;\n\n\t\t \n\t\tval &= fep->cc.mask;\n\t\twritel(val, fep->hwp + FEC_TCCR(fep->pps_channel));\n\n\t\t \n\t\tfep->next_counter = (val + fep->reload_period) & fep->cc.mask;\n\n\t\t \n\t\tval = readl(fep->hwp + FEC_ATIME_CTRL);\n\t\tval |= FEC_T_CTRL_PINPER;\n\t\twritel(val, fep->hwp + FEC_ATIME_CTRL);\n\n\t\t \n\t\tval = readl(fep->hwp + FEC_TCSR(fep->pps_channel));\n\t\tval |= (1 << FEC_T_TF_OFFSET | 1 << FEC_T_TIE_OFFSET);\n\t\tval &= ~(1 << FEC_T_TDRE_OFFSET);\n\t\tval &= ~(FEC_T_TMODE_MASK);\n\t\tval |= (FEC_HIGH_PULSE << FEC_T_TMODE_OFFSET);\n\t\twritel(val, fep->hwp + FEC_TCSR(fep->pps_channel));\n\n\t\t \n\t\twritel(fep->next_counter, fep->hwp + FEC_TCCR(fep->pps_channel));\n\t\tfep->next_counter = (fep->next_counter + fep->reload_period) & fep->cc.mask;\n\t} else {\n\t\twritel(0, fep->hwp + FEC_TCSR(fep->pps_channel));\n\t}\n\n\tfep->pps_enable = enable;\n\tspin_unlock_irqrestore(&fep->tmreg_lock, flags);\n\n\treturn 0;\n}\n\nstatic int fec_ptp_pps_perout(struct fec_enet_private *fep)\n{\n\tu32 compare_val, ptp_hc, temp_val;\n\tu64 curr_time;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fep->tmreg_lock, flags);\n\n\t \n\ttimecounter_read(&fep->tc);\n\n\t \n\ttemp_val = readl(fep->hwp + FEC_ATIME_CTRL);\n\ttemp_val |= FEC_T_CTRL_CAPTURE;\n\twritel(temp_val, fep->hwp + FEC_ATIME_CTRL);\n\tif (fep->quirks & FEC_QUIRK_BUG_CAPTURE)\n\t\tudelay(1);\n\n\tptp_hc = readl(fep->hwp + FEC_ATIME);\n\n\t \n\tcurr_time = timecounter_cyc2time(&fep->tc, ptp_hc);\n\n\t \n\tif (fep->perout_stime < curr_time + 100 * NSEC_PER_MSEC) {\n\t\tdev_err(&fep->pdev->dev, \"Current time is too close to the start time!\\n\");\n\t\tspin_unlock_irqrestore(&fep->tmreg_lock, flags);\n\t\treturn -1;\n\t}\n\n\tcompare_val = fep->perout_stime - curr_time + ptp_hc;\n\tcompare_val &= fep->cc.mask;\n\n\twritel(compare_val, fep->hwp + FEC_TCCR(fep->pps_channel));\n\tfep->next_counter = (compare_val + fep->reload_period) & fep->cc.mask;\n\n\t \n\ttemp_val = readl(fep->hwp + FEC_ATIME_CTRL);\n\ttemp_val |= FEC_T_CTRL_PINPER;\n\twritel(temp_val, fep->hwp + FEC_ATIME_CTRL);\n\n\t \n\ttemp_val = readl(fep->hwp + FEC_TCSR(fep->pps_channel));\n\ttemp_val |= (1 << FEC_T_TF_OFFSET | 1 << FEC_T_TIE_OFFSET);\n\ttemp_val &= ~(1 << FEC_T_TDRE_OFFSET);\n\ttemp_val &= ~(FEC_T_TMODE_MASK);\n\ttemp_val |= (FEC_TMODE_TOGGLE << FEC_T_TMODE_OFFSET);\n\twritel(temp_val, fep->hwp + FEC_TCSR(fep->pps_channel));\n\n\t \n\twritel(fep->next_counter, fep->hwp + FEC_TCCR(fep->pps_channel));\n\tfep->next_counter = (fep->next_counter + fep->reload_period) & fep->cc.mask;\n\tspin_unlock_irqrestore(&fep->tmreg_lock, flags);\n\n\treturn 0;\n}\n\nstatic enum hrtimer_restart fec_ptp_pps_perout_handler(struct hrtimer *timer)\n{\n\tstruct fec_enet_private *fep = container_of(timer,\n\t\t\t\t\tstruct fec_enet_private, perout_timer);\n\n\tfec_ptp_pps_perout(fep);\n\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic u64 fec_ptp_read(const struct cyclecounter *cc)\n{\n\tstruct fec_enet_private *fep =\n\t\tcontainer_of(cc, struct fec_enet_private, cc);\n\tu32 tempval;\n\n\ttempval = readl(fep->hwp + FEC_ATIME_CTRL);\n\ttempval |= FEC_T_CTRL_CAPTURE;\n\twritel(tempval, fep->hwp + FEC_ATIME_CTRL);\n\n\tif (fep->quirks & FEC_QUIRK_BUG_CAPTURE)\n\t\tudelay(1);\n\n\treturn readl(fep->hwp + FEC_ATIME);\n}\n\n \nvoid fec_ptp_start_cyclecounter(struct net_device *ndev)\n{\n\tstruct fec_enet_private *fep = netdev_priv(ndev);\n\tunsigned long flags;\n\tint inc;\n\n\tinc = 1000000000 / fep->cycle_speed;\n\n\t \n\tspin_lock_irqsave(&fep->tmreg_lock, flags);\n\n\t \n\twritel(inc << FEC_T_INC_OFFSET, fep->hwp + FEC_ATIME_INC);\n\n\t \n\twritel(FEC_COUNTER_PERIOD, fep->hwp + FEC_ATIME_EVT_PERIOD);\n\n\twritel(FEC_T_CTRL_ENABLE | FEC_T_CTRL_PERIOD_RST,\n\t\tfep->hwp + FEC_ATIME_CTRL);\n\n\tmemset(&fep->cc, 0, sizeof(fep->cc));\n\tfep->cc.read = fec_ptp_read;\n\tfep->cc.mask = CLOCKSOURCE_MASK(31);\n\tfep->cc.shift = 31;\n\tfep->cc.mult = FEC_CC_MULT;\n\n\t \n\ttimecounter_init(&fep->tc, &fep->cc, 0);\n\n\tspin_unlock_irqrestore(&fep->tmreg_lock, flags);\n}\n\n \nstatic int fec_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\ts32 ppb = scaled_ppm_to_ppb(scaled_ppm);\n\tunsigned long flags;\n\tint neg_adj = 0;\n\tu32 i, tmp;\n\tu32 corr_inc, corr_period;\n\tu32 corr_ns;\n\tu64 lhs, rhs;\n\n\tstruct fec_enet_private *fep =\n\t    container_of(ptp, struct fec_enet_private, ptp_caps);\n\n\tif (ppb == 0)\n\t\treturn 0;\n\n\tif (ppb < 0) {\n\t\tppb = -ppb;\n\t\tneg_adj = 1;\n\t}\n\n\t \n\tlhs = NSEC_PER_SEC;\n\trhs = (u64)ppb * (u64)fep->ptp_inc;\n\tfor (i = 1; i <= fep->ptp_inc; i++) {\n\t\tif (lhs >= rhs) {\n\t\t\tcorr_inc = i;\n\t\t\tcorr_period = div_u64(lhs, rhs);\n\t\t\tbreak;\n\t\t}\n\t\tlhs += NSEC_PER_SEC;\n\t}\n\t \n\tif (i > fep->ptp_inc) {\n\t\tcorr_inc = fep->ptp_inc;\n\t\tcorr_period = 1;\n\t}\n\n\tif (neg_adj)\n\t\tcorr_ns = fep->ptp_inc - corr_inc;\n\telse\n\t\tcorr_ns = fep->ptp_inc + corr_inc;\n\n\tspin_lock_irqsave(&fep->tmreg_lock, flags);\n\n\ttmp = readl(fep->hwp + FEC_ATIME_INC) & FEC_T_INC_MASK;\n\ttmp |= corr_ns << FEC_T_INC_CORR_OFFSET;\n\twritel(tmp, fep->hwp + FEC_ATIME_INC);\n\tcorr_period = corr_period > 1 ? corr_period - 1 : corr_period;\n\twritel(corr_period, fep->hwp + FEC_ATIME_CORR);\n\t \n\ttimecounter_read(&fep->tc);\n\n\tspin_unlock_irqrestore(&fep->tmreg_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int fec_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct fec_enet_private *fep =\n\t    container_of(ptp, struct fec_enet_private, ptp_caps);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fep->tmreg_lock, flags);\n\ttimecounter_adjtime(&fep->tc, delta);\n\tspin_unlock_irqrestore(&fep->tmreg_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int fec_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tstruct fec_enet_private *fep =\n\t    container_of(ptp, struct fec_enet_private, ptp_caps);\n\tu64 ns;\n\tunsigned long flags;\n\n\tmutex_lock(&fep->ptp_clk_mutex);\n\t \n\tif (!fep->ptp_clk_on) {\n\t\tmutex_unlock(&fep->ptp_clk_mutex);\n\t\treturn -EINVAL;\n\t}\n\tspin_lock_irqsave(&fep->tmreg_lock, flags);\n\tns = timecounter_read(&fep->tc);\n\tspin_unlock_irqrestore(&fep->tmreg_lock, flags);\n\tmutex_unlock(&fep->ptp_clk_mutex);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\n \nstatic int fec_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t   const struct timespec64 *ts)\n{\n\tstruct fec_enet_private *fep =\n\t    container_of(ptp, struct fec_enet_private, ptp_caps);\n\n\tu64 ns;\n\tunsigned long flags;\n\tu32 counter;\n\n\tmutex_lock(&fep->ptp_clk_mutex);\n\t \n\tif (!fep->ptp_clk_on) {\n\t\tmutex_unlock(&fep->ptp_clk_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tns = timespec64_to_ns(ts);\n\t \n\tcounter = ns & fep->cc.mask;\n\n\tspin_lock_irqsave(&fep->tmreg_lock, flags);\n\twritel(counter, fep->hwp + FEC_ATIME);\n\ttimecounter_init(&fep->tc, &fep->cc, ns);\n\tspin_unlock_irqrestore(&fep->tmreg_lock, flags);\n\tmutex_unlock(&fep->ptp_clk_mutex);\n\treturn 0;\n}\n\nstatic int fec_ptp_pps_disable(struct fec_enet_private *fep, uint channel)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fep->tmreg_lock, flags);\n\twritel(0, fep->hwp + FEC_TCSR(channel));\n\tspin_unlock_irqrestore(&fep->tmreg_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int fec_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t  struct ptp_clock_request *rq, int on)\n{\n\tstruct fec_enet_private *fep =\n\t    container_of(ptp, struct fec_enet_private, ptp_caps);\n\tktime_t timeout;\n\tstruct timespec64 start_time, period;\n\tu64 curr_time, delta, period_ns;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (rq->type == PTP_CLK_REQ_PPS) {\n\t\tret = fec_ptp_enable_pps(fep, on);\n\n\t\treturn ret;\n\t} else if (rq->type == PTP_CLK_REQ_PEROUT) {\n\t\t \n\t\tif (rq->perout.flags)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (rq->perout.index != DEFAULT_PPS_CHANNEL)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tfep->pps_channel = DEFAULT_PPS_CHANNEL;\n\t\tperiod.tv_sec = rq->perout.period.sec;\n\t\tperiod.tv_nsec = rq->perout.period.nsec;\n\t\tperiod_ns = timespec64_to_ns(&period);\n\n\t\t \n\t\tif (period_ns > FEC_PTP_MAX_NSEC_PERIOD) {\n\t\t\tdev_err(&fep->pdev->dev, \"The period must equal to or less than 4s!\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tfep->reload_period = div_u64(period_ns, 2);\n\t\tif (on && fep->reload_period) {\n\t\t\t \n\t\t\tstart_time.tv_sec = rq->perout.start.sec;\n\t\t\tstart_time.tv_nsec = rq->perout.start.nsec;\n\t\t\tfep->perout_stime = timespec64_to_ns(&start_time);\n\n\t\t\tmutex_lock(&fep->ptp_clk_mutex);\n\t\t\tif (!fep->ptp_clk_on) {\n\t\t\t\tdev_err(&fep->pdev->dev, \"Error: PTP clock is closed!\\n\");\n\t\t\t\tmutex_unlock(&fep->ptp_clk_mutex);\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tspin_lock_irqsave(&fep->tmreg_lock, flags);\n\t\t\t \n\t\t\tcurr_time = timecounter_read(&fep->tc);\n\t\t\tspin_unlock_irqrestore(&fep->tmreg_lock, flags);\n\t\t\tmutex_unlock(&fep->ptp_clk_mutex);\n\n\t\t\t \n\t\t\tdelta = fep->perout_stime - curr_time;\n\n\t\t\tif (fep->perout_stime <= curr_time) {\n\t\t\t\tdev_err(&fep->pdev->dev, \"Start time must larger than current time!\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (delta > FEC_PTP_MAX_NSEC_COUNTER) {\n\t\t\t\ttimeout = ns_to_ktime(delta - NSEC_PER_SEC);\n\t\t\t\thrtimer_start(&fep->perout_timer, timeout, HRTIMER_MODE_REL);\n\t\t\t} else {\n\t\t\t\treturn fec_ptp_pps_perout(fep);\n\t\t\t}\n\t\t} else {\n\t\t\tfec_ptp_pps_disable(fep, fep->pps_channel);\n\t\t}\n\n\t\treturn 0;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint fec_ptp_set(struct net_device *ndev, struct kernel_hwtstamp_config *config,\n\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct fec_enet_private *fep = netdev_priv(ndev);\n\n\tswitch (config->tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\tfep->hwts_tx_en = 0;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tfep->hwts_tx_en = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tfep->hwts_rx_en = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tfep->hwts_rx_en = 1;\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nvoid fec_ptp_get(struct net_device *ndev, struct kernel_hwtstamp_config *config)\n{\n\tstruct fec_enet_private *fep = netdev_priv(ndev);\n\n\tconfig->flags = 0;\n\tconfig->tx_type = fep->hwts_tx_en ? HWTSTAMP_TX_ON : HWTSTAMP_TX_OFF;\n\tconfig->rx_filter = (fep->hwts_rx_en ?\n\t\t\t     HWTSTAMP_FILTER_ALL : HWTSTAMP_FILTER_NONE);\n}\n\n \nstatic void fec_time_keep(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct fec_enet_private *fep = container_of(dwork, struct fec_enet_private, time_keep);\n\tunsigned long flags;\n\n\tmutex_lock(&fep->ptp_clk_mutex);\n\tif (fep->ptp_clk_on) {\n\t\tspin_lock_irqsave(&fep->tmreg_lock, flags);\n\t\ttimecounter_read(&fep->tc);\n\t\tspin_unlock_irqrestore(&fep->tmreg_lock, flags);\n\t}\n\tmutex_unlock(&fep->ptp_clk_mutex);\n\n\tschedule_delayed_work(&fep->time_keep, HZ);\n}\n\n \nstatic irqreturn_t fec_pps_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *ndev = dev_id;\n\tstruct fec_enet_private *fep = netdev_priv(ndev);\n\tu32 val;\n\tu8 channel = fep->pps_channel;\n\tstruct ptp_clock_event event;\n\n\tval = readl(fep->hwp + FEC_TCSR(channel));\n\tif (val & FEC_T_TF_MASK) {\n\t\t \n\t\twritel(fep->next_counter, fep->hwp + FEC_TCCR(channel));\n\t\tdo {\n\t\t\twritel(val, fep->hwp + FEC_TCSR(channel));\n\t\t} while (readl(fep->hwp + FEC_TCSR(channel)) & FEC_T_TF_MASK);\n\n\t\t \n\t\tfep->next_counter = (fep->next_counter + fep->reload_period) &\n\t\t\t\tfep->cc.mask;\n\n\t\tevent.type = PTP_CLOCK_PPS;\n\t\tptp_clock_event(fep->ptp_clock, &event);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\n \n\nvoid fec_ptp_init(struct platform_device *pdev, int irq_idx)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct fec_enet_private *fep = netdev_priv(ndev);\n\tint irq;\n\tint ret;\n\n\tfep->ptp_caps.owner = THIS_MODULE;\n\tstrscpy(fep->ptp_caps.name, \"fec ptp\", sizeof(fep->ptp_caps.name));\n\n\tfep->ptp_caps.max_adj = 250000000;\n\tfep->ptp_caps.n_alarm = 0;\n\tfep->ptp_caps.n_ext_ts = 0;\n\tfep->ptp_caps.n_per_out = 1;\n\tfep->ptp_caps.n_pins = 0;\n\tfep->ptp_caps.pps = 1;\n\tfep->ptp_caps.adjfine = fec_ptp_adjfine;\n\tfep->ptp_caps.adjtime = fec_ptp_adjtime;\n\tfep->ptp_caps.gettime64 = fec_ptp_gettime;\n\tfep->ptp_caps.settime64 = fec_ptp_settime;\n\tfep->ptp_caps.enable = fec_ptp_enable;\n\n\tfep->cycle_speed = clk_get_rate(fep->clk_ptp);\n\tif (!fep->cycle_speed) {\n\t\tfep->cycle_speed = NSEC_PER_SEC;\n\t\tdev_err(&fep->pdev->dev, \"clk_ptp clock rate is zero\\n\");\n\t}\n\tfep->ptp_inc = NSEC_PER_SEC / fep->cycle_speed;\n\n\tspin_lock_init(&fep->tmreg_lock);\n\n\tfec_ptp_start_cyclecounter(ndev);\n\n\tINIT_DELAYED_WORK(&fep->time_keep, fec_time_keep);\n\n\thrtimer_init(&fep->perout_timer, CLOCK_REALTIME, HRTIMER_MODE_REL);\n\tfep->perout_timer.function = fec_ptp_pps_perout_handler;\n\n\tirq = platform_get_irq_byname_optional(pdev, \"pps\");\n\tif (irq < 0)\n\t\tirq = platform_get_irq_optional(pdev, irq_idx);\n\t \n\tif (irq >= 0) {\n\t\tret = devm_request_irq(&pdev->dev, irq, fec_pps_interrupt,\n\t\t\t\t       0, pdev->name, ndev);\n\t\tif (ret < 0)\n\t\t\tdev_warn(&pdev->dev, \"request for pps irq failed(%d)\\n\",\n\t\t\t\t ret);\n\t}\n\n\tfep->ptp_clock = ptp_clock_register(&fep->ptp_caps, &pdev->dev);\n\tif (IS_ERR(fep->ptp_clock)) {\n\t\tfep->ptp_clock = NULL;\n\t\tdev_err(&pdev->dev, \"ptp_clock_register failed\\n\");\n\t}\n\n\tschedule_delayed_work(&fep->time_keep, HZ);\n}\n\nvoid fec_ptp_stop(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct fec_enet_private *fep = netdev_priv(ndev);\n\n\tcancel_delayed_work_sync(&fep->time_keep);\n\thrtimer_cancel(&fep->perout_timer);\n\tif (fep->ptp_clock)\n\t\tptp_clock_unregister(fep->ptp_clock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}