{
  "module_name": "ucc_geth_ethtool.c",
  "hash_id": "e77dadf51e6453fa1703200e6a4d18b5ac514cd68befa6b44ebb9f3ec635cc52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/ucc_geth_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/ethtool.h>\n#include <linux/mii.h>\n#include <linux/phy.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n#include <asm/types.h>\n\n#include \"ucc_geth.h\"\n\nstatic const char hw_stat_gstrings[][ETH_GSTRING_LEN] = {\n\t\"tx-64-frames\",\n\t\"tx-65-127-frames\",\n\t\"tx-128-255-frames\",\n\t\"rx-64-frames\",\n\t\"rx-65-127-frames\",\n\t\"rx-128-255-frames\",\n\t\"tx-bytes-ok\",\n\t\"tx-pause-frames\",\n\t\"tx-multicast-frames\",\n\t\"tx-broadcast-frames\",\n\t\"rx-frames\",\n\t\"rx-bytes-ok\",\n\t\"rx-bytes-all\",\n\t\"rx-multicast-frames\",\n\t\"rx-broadcast-frames\",\n\t\"stats-counter-carry\",\n\t\"stats-counter-mask\",\n\t\"rx-dropped-frames\",\n};\n\nstatic const char tx_fw_stat_gstrings[][ETH_GSTRING_LEN] = {\n\t\"tx-single-collision\",\n\t\"tx-multiple-collision\",\n\t\"tx-late-collision\",\n\t\"tx-aborted-frames\",\n\t\"tx-lost-frames\",\n\t\"tx-carrier-sense-errors\",\n\t\"tx-frames-ok\",\n\t\"tx-excessive-differ-frames\",\n\t\"tx-256-511-frames\",\n\t\"tx-512-1023-frames\",\n\t\"tx-1024-1518-frames\",\n\t\"tx-jumbo-frames\",\n};\n\nstatic const char rx_fw_stat_gstrings[][ETH_GSTRING_LEN] = {\n\t\"rx-crc-errors\",\n\t\"rx-alignment-errors\",\n\t\"rx-in-range-length-errors\",\n\t\"rx-out-of-range-length-errors\",\n\t\"rx-too-long-frames\",\n\t\"rx-runt\",\n\t\"rx-very-long-event\",\n\t\"rx-symbol-errors\",\n\t\"rx-busy-drop-frames\",\n\t\"reserved\",\n\t\"reserved\",\n\t\"rx-mismatch-drop-frames\",\n\t\"rx-small-than-64\",\n\t\"rx-256-511-frames\",\n\t\"rx-512-1023-frames\",\n\t\"rx-1024-1518-frames\",\n\t\"rx-jumbo-frames\",\n\t\"rx-mac-error-loss\",\n\t\"rx-pause-frames\",\n\t\"reserved\",\n\t\"rx-vlan-removed\",\n\t\"rx-vlan-replaced\",\n\t\"rx-vlan-inserted\",\n\t\"rx-ip-checksum-errors\",\n};\n\n#define UEC_HW_STATS_LEN ARRAY_SIZE(hw_stat_gstrings)\n#define UEC_TX_FW_STATS_LEN ARRAY_SIZE(tx_fw_stat_gstrings)\n#define UEC_RX_FW_STATS_LEN ARRAY_SIZE(rx_fw_stat_gstrings)\n\nstatic int\nuec_get_ksettings(struct net_device *netdev, struct ethtool_link_ksettings *cmd)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(netdev);\n\tstruct phy_device *phydev = ugeth->phydev;\n\n\tif (!phydev)\n\t\treturn -ENODEV;\n\n\tphy_ethtool_ksettings_get(phydev, cmd);\n\n\treturn 0;\n}\n\nstatic int\nuec_set_ksettings(struct net_device *netdev,\n\t\t  const struct ethtool_link_ksettings *cmd)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(netdev);\n\tstruct phy_device *phydev = ugeth->phydev;\n\n\tif (!phydev)\n\t\treturn -ENODEV;\n\n\treturn phy_ethtool_ksettings_set(phydev, cmd);\n}\n\nstatic void\nuec_get_pauseparam(struct net_device *netdev,\n                     struct ethtool_pauseparam *pause)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(netdev);\n\n\tpause->autoneg = ugeth->phydev->autoneg;\n\n\tif (ugeth->ug_info->receiveFlowControl)\n\t\tpause->rx_pause = 1;\n\tif (ugeth->ug_info->transmitFlowControl)\n\t\tpause->tx_pause = 1;\n}\n\nstatic int\nuec_set_pauseparam(struct net_device *netdev,\n                     struct ethtool_pauseparam *pause)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(netdev);\n\tint ret = 0;\n\n\tugeth->ug_info->receiveFlowControl = pause->rx_pause;\n\tugeth->ug_info->transmitFlowControl = pause->tx_pause;\n\n\tif (ugeth->phydev->autoneg) {\n\t\tif (netif_running(netdev)) {\n\t\t\t \n\t\t\tnetdev_info(netdev, \"Please re-open the interface\\n\");\n\t\t}\n\t} else {\n\t\tstruct ucc_geth_info *ug_info = ugeth->ug_info;\n\n\t\tret = init_flow_control_params(ug_info->aufc,\n\t\t\t\t\tug_info->receiveFlowControl,\n\t\t\t\t\tug_info->transmitFlowControl,\n\t\t\t\t\tug_info->pausePeriod,\n\t\t\t\t\tug_info->extensionField,\n\t\t\t\t\t&ugeth->uccf->uf_regs->upsmr,\n\t\t\t\t\t&ugeth->ug_regs->uempr,\n\t\t\t\t\t&ugeth->ug_regs->maccfg1);\n\t}\n\n\treturn ret;\n}\n\nstatic uint32_t\nuec_get_msglevel(struct net_device *netdev)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(netdev);\n\treturn ugeth->msg_enable;\n}\n\nstatic void\nuec_set_msglevel(struct net_device *netdev, uint32_t data)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(netdev);\n\tugeth->msg_enable = data;\n}\n\nstatic int\nuec_get_regs_len(struct net_device *netdev)\n{\n\treturn sizeof(struct ucc_geth);\n}\n\nstatic void\nuec_get_regs(struct net_device *netdev,\n               struct ethtool_regs *regs, void *p)\n{\n\tint i;\n\tstruct ucc_geth_private *ugeth = netdev_priv(netdev);\n\tu32 __iomem *ug_regs = (u32 __iomem *)ugeth->ug_regs;\n\tu32 *buff = p;\n\n\tfor (i = 0; i < sizeof(struct ucc_geth) / sizeof(u32); i++)\n\t\tbuff[i] = in_be32(&ug_regs[i]);\n}\n\nstatic void\nuec_get_ringparam(struct net_device *netdev,\n\t\t  struct ethtool_ringparam *ring,\n\t\t  struct kernel_ethtool_ringparam *kernel_ring,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(netdev);\n\tstruct ucc_geth_info *ug_info = ugeth->ug_info;\n\tint queue = 0;\n\n\tring->rx_max_pending = UCC_GETH_BD_RING_SIZE_MAX;\n\tring->rx_mini_max_pending = UCC_GETH_BD_RING_SIZE_MAX;\n\tring->rx_jumbo_max_pending = UCC_GETH_BD_RING_SIZE_MAX;\n\tring->tx_max_pending = UCC_GETH_BD_RING_SIZE_MAX;\n\n\tring->rx_pending = ug_info->bdRingLenRx[queue];\n\tring->rx_mini_pending = ug_info->bdRingLenRx[queue];\n\tring->rx_jumbo_pending = ug_info->bdRingLenRx[queue];\n\tring->tx_pending = ug_info->bdRingLenTx[queue];\n}\n\nstatic int\nuec_set_ringparam(struct net_device *netdev,\n\t\t  struct ethtool_ringparam *ring,\n\t\t  struct kernel_ethtool_ringparam *kernel_ring,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(netdev);\n\tstruct ucc_geth_info *ug_info = ugeth->ug_info;\n\tint queue = 0, ret = 0;\n\n\tif (ring->rx_pending < UCC_GETH_RX_BD_RING_SIZE_MIN) {\n\t\tnetdev_info(netdev, \"RxBD ring size must be no smaller than %d\\n\",\n\t\t\t    UCC_GETH_RX_BD_RING_SIZE_MIN);\n\t\treturn -EINVAL;\n\t}\n\tif (ring->rx_pending % UCC_GETH_RX_BD_RING_SIZE_ALIGNMENT) {\n\t\tnetdev_info(netdev, \"RxBD ring size must be multiple of %d\\n\",\n\t\t\t    UCC_GETH_RX_BD_RING_SIZE_ALIGNMENT);\n\t\treturn -EINVAL;\n\t}\n\tif (ring->tx_pending < UCC_GETH_TX_BD_RING_SIZE_MIN) {\n\t\tnetdev_info(netdev, \"TxBD ring size must be no smaller than %d\\n\",\n\t\t\t    UCC_GETH_TX_BD_RING_SIZE_MIN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (netif_running(netdev))\n\t\treturn -EBUSY;\n\n\tug_info->bdRingLenRx[queue] = ring->rx_pending;\n\tug_info->bdRingLenTx[queue] = ring->tx_pending;\n\n\treturn ret;\n}\n\nstatic int uec_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(netdev);\n\tu32 stats_mode = ugeth->ug_info->statisticsMode;\n\tint len = 0;\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\tif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_HARDWARE)\n\t\t\tlen += UEC_HW_STATS_LEN;\n\t\tif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_TX)\n\t\t\tlen += UEC_TX_FW_STATS_LEN;\n\t\tif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_RX)\n\t\t\tlen += UEC_RX_FW_STATS_LEN;\n\n\t\treturn len;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void uec_get_strings(struct net_device *netdev, u32 stringset, u8 *buf)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(netdev);\n\tu32 stats_mode = ugeth->ug_info->statisticsMode;\n\n\tif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_HARDWARE) {\n\t\tmemcpy(buf, hw_stat_gstrings, UEC_HW_STATS_LEN *\n\t\t\t       \tETH_GSTRING_LEN);\n\t\tbuf += UEC_HW_STATS_LEN * ETH_GSTRING_LEN;\n\t}\n\tif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_TX) {\n\t\tmemcpy(buf, tx_fw_stat_gstrings, UEC_TX_FW_STATS_LEN *\n\t\t\t       \tETH_GSTRING_LEN);\n\t\tbuf += UEC_TX_FW_STATS_LEN * ETH_GSTRING_LEN;\n\t}\n\tif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_RX)\n\t\tmemcpy(buf, rx_fw_stat_gstrings, UEC_RX_FW_STATS_LEN *\n\t\t\t       \tETH_GSTRING_LEN);\n}\n\nstatic void uec_get_ethtool_stats(struct net_device *netdev,\n\t\tstruct ethtool_stats *stats, uint64_t *data)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(netdev);\n\tu32 stats_mode = ugeth->ug_info->statisticsMode;\n\tu32 __iomem *base;\n\tint i, j = 0;\n\n\tif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_HARDWARE) {\n\t\tif (ugeth->ug_regs)\n\t\t\tbase = (u32 __iomem *)&ugeth->ug_regs->tx64;\n\t\telse\n\t\t\tbase = NULL;\n\n\t\tfor (i = 0; i < UEC_HW_STATS_LEN; i++)\n\t\t\tdata[j++] = base ? in_be32(&base[i]) : 0;\n\t}\n\tif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_TX) {\n\t\tbase = (u32 __iomem *)ugeth->p_tx_fw_statistics_pram;\n\t\tfor (i = 0; i < UEC_TX_FW_STATS_LEN; i++)\n\t\t\tdata[j++] = base ? in_be32(&base[i]) : 0;\n\t}\n\tif (stats_mode & UCC_GETH_STATISTICS_GATHERING_MODE_FIRMWARE_RX) {\n\t\tbase = (u32 __iomem *)ugeth->p_rx_fw_statistics_pram;\n\t\tfor (i = 0; i < UEC_RX_FW_STATS_LEN; i++)\n\t\t\tdata[j++] = base ? in_be32(&base[i]) : 0;\n\t}\n}\n\n \nstatic void\nuec_get_drvinfo(struct net_device *netdev,\n                       struct ethtool_drvinfo *drvinfo)\n{\n\tstrscpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->bus_info, \"QUICC ENGINE\", sizeof(drvinfo->bus_info));\n}\n\n#ifdef CONFIG_PM\n\nstatic void uec_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(netdev);\n\tstruct phy_device *phydev = ugeth->phydev;\n\n\tif (phydev && phydev->irq)\n\t\twol->supported |= WAKE_PHY;\n\tif (qe_alive_during_sleep())\n\t\twol->supported |= WAKE_MAGIC;\n\n\twol->wolopts = ugeth->wol_en;\n}\n\nstatic int uec_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct ucc_geth_private *ugeth = netdev_priv(netdev);\n\tstruct phy_device *phydev = ugeth->phydev;\n\n\tif (wol->wolopts & ~(WAKE_PHY | WAKE_MAGIC))\n\t\treturn -EINVAL;\n\telse if (wol->wolopts & WAKE_PHY && (!phydev || !phydev->irq))\n\t\treturn -EINVAL;\n\telse if (wol->wolopts & WAKE_MAGIC && !qe_alive_during_sleep())\n\t\treturn -EINVAL;\n\n\tugeth->wol_en = wol->wolopts;\n\tdevice_set_wakeup_enable(&netdev->dev, ugeth->wol_en);\n\n\treturn 0;\n}\n\n#else\n#define uec_get_wol NULL\n#define uec_set_wol NULL\n#endif  \n\nstatic const struct ethtool_ops uec_ethtool_ops = {\n\t.get_drvinfo            = uec_get_drvinfo,\n\t.get_regs_len           = uec_get_regs_len,\n\t.get_regs               = uec_get_regs,\n\t.get_msglevel           = uec_get_msglevel,\n\t.set_msglevel           = uec_set_msglevel,\n\t.nway_reset             = phy_ethtool_nway_reset,\n\t.get_link               = ethtool_op_get_link,\n\t.get_ringparam          = uec_get_ringparam,\n\t.set_ringparam          = uec_set_ringparam,\n\t.get_pauseparam         = uec_get_pauseparam,\n\t.set_pauseparam         = uec_set_pauseparam,\n\t.get_sset_count\t\t= uec_get_sset_count,\n\t.get_strings            = uec_get_strings,\n\t.get_ethtool_stats      = uec_get_ethtool_stats,\n\t.get_wol\t\t= uec_get_wol,\n\t.set_wol\t\t= uec_set_wol,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_link_ksettings\t= uec_get_ksettings,\n\t.set_link_ksettings\t= uec_set_ksettings,\n};\n\nvoid uec_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &uec_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}