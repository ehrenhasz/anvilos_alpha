{
  "module_name": "fman_tgec.c",
  "hash_id": "3202790f635099f244c298f55874fc3f56b6c002c21b8bc4dcbaaba7e02b9051",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fman/fman_tgec.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"fman_tgec.h\"\n#include \"fman.h\"\n#include \"mac.h\"\n\n#include <linux/slab.h>\n#include <linux/bitrev.h>\n#include <linux/io.h>\n#include <linux/crc32.h>\n#include <linux/netdevice.h>\n\n \n#define TGEC_TX_IPG_LENGTH_MASK\t0x000003ff\n\n \n#define CMD_CFG_EN_TIMESTAMP\t\t0x00100000\n#define CMD_CFG_NO_LEN_CHK\t\t0x00020000\n#define CMD_CFG_PAUSE_IGNORE\t\t0x00000100\n#define CMF_CFG_CRC_FWD\t\t\t0x00000040\n#define CMD_CFG_PROMIS_EN\t\t0x00000010\n#define CMD_CFG_RX_EN\t\t\t0x00000002\n#define CMD_CFG_TX_EN\t\t\t0x00000001\n\n \n#define TGEC_IMASK_MDIO_SCAN_EVENT\t0x00010000\n#define TGEC_IMASK_MDIO_CMD_CMPL\t0x00008000\n#define TGEC_IMASK_REM_FAULT\t\t0x00004000\n#define TGEC_IMASK_LOC_FAULT\t\t0x00002000\n#define TGEC_IMASK_TX_ECC_ER\t\t0x00001000\n#define TGEC_IMASK_TX_FIFO_UNFL\t0x00000800\n#define TGEC_IMASK_TX_FIFO_OVFL\t0x00000400\n#define TGEC_IMASK_TX_ER\t\t0x00000200\n#define TGEC_IMASK_RX_FIFO_OVFL\t0x00000100\n#define TGEC_IMASK_RX_ECC_ER\t\t0x00000080\n#define TGEC_IMASK_RX_JAB_FRM\t\t0x00000040\n#define TGEC_IMASK_RX_OVRSZ_FRM\t0x00000020\n#define TGEC_IMASK_RX_RUNT_FRM\t\t0x00000010\n#define TGEC_IMASK_RX_FRAG_FRM\t\t0x00000008\n#define TGEC_IMASK_RX_LEN_ER\t\t0x00000004\n#define TGEC_IMASK_RX_CRC_ER\t\t0x00000002\n#define TGEC_IMASK_RX_ALIGN_ER\t\t0x00000001\n\n \n#define TGEC_HASH_MCAST_SHIFT\t\t23\n#define TGEC_HASH_MCAST_EN\t\t0x00000200\n#define TGEC_HASH_ADR_MSK\t\t0x000001ff\n\n#define DEFAULT_TX_IPG_LENGTH\t\t\t12\n#define DEFAULT_MAX_FRAME_LENGTH\t\t0x600\n#define DEFAULT_PAUSE_QUANT\t\t\t0xf000\n\n \n#define TGEC_NUM_OF_PADDRS          1\n\n \n#define GROUP_ADDRESS               0x0000010000000000LL\n\n \n#define TGEC_HASH_TABLE_SIZE             512\n\n \nstruct tgec_regs {\n\tu32 tgec_id;\t\t \n\tu32 reserved001[1];\t \n\tu32 command_config;\t \n\tu32 mac_addr_0;\t\t \n\tu32 mac_addr_1;\t\t \n\tu32 maxfrm;\t\t \n\tu32 pause_quant;\t \n\tu32 rx_fifo_sections;\t \n\tu32 tx_fifo_sections;\t \n\tu32 rx_fifo_almost_f_e;\t \n\tu32 tx_fifo_almost_f_e;\t \n\tu32 hashtable_ctrl;\t \n\tu32 mdio_cfg_status;\t \n\tu32 mdio_command;\t \n\tu32 mdio_data;\t\t \n\tu32 mdio_regaddr;\t \n\tu32 status;\t\t \n\tu32 tx_ipg_len;\t\t \n\tu32 mac_addr_2;\t\t \n\tu32 mac_addr_3;\t\t \n\tu32 rx_fifo_ptr_rd;\t \n\tu32 rx_fifo_ptr_wr;\t \n\tu32 tx_fifo_ptr_rd;\t \n\tu32 tx_fifo_ptr_wr;\t \n\tu32 imask;\t\t \n\tu32 ievent;\t\t \n\tu32 udp_port;\t\t \n\tu32 type_1588v2;\t \n\tu32 reserved070[4];\t \n\t \n\tu32 tfrm_u;\t\t \n\tu32 tfrm_l;\t\t \n\tu32 rfrm_u;\t\t \n\tu32 rfrm_l;\t\t \n\tu32 rfcs_u;\t\t \n\tu32 rfcs_l;\t\t \n\tu32 raln_u;\t\t \n\tu32 raln_l;\t\t \n\tu32 txpf_u;\t\t \n\tu32 txpf_l;\t\t \n\tu32 rxpf_u;\t\t \n\tu32 rxpf_l;\t\t \n\tu32 rlong_u;\t\t \n\tu32 rlong_l;\t\t \n\tu32 rflr_u;\t\t \n\tu32 rflr_l;\t\t \n\tu32 tvlan_u;\t\t \n\tu32 tvlan_l;\t\t \n\tu32 rvlan_u;\t\t \n\tu32 rvlan_l;\t\t \n\tu32 toct_u;\t\t \n\tu32 toct_l;\t\t \n\tu32 roct_u;\t\t \n\tu32 roct_l;\t\t \n\tu32 ruca_u;\t\t \n\tu32 ruca_l;\t\t \n\tu32 rmca_u;\t\t \n\tu32 rmca_l;\t\t \n\tu32 rbca_u;\t\t \n\tu32 rbca_l;\t\t \n\tu32 terr_u;\t\t \n\tu32 terr_l;\t\t \n\tu32 reserved100[2];\t \n\tu32 tuca_u;\t\t \n\tu32 tuca_l;\t\t \n\tu32 tmca_u;\t\t \n\tu32 tmca_l;\t\t \n\tu32 tbca_u;\t\t \n\tu32 tbca_l;\t\t \n\tu32 rdrp_u;\t\t \n\tu32 rdrp_l;\t\t \n\tu32 reoct_u;\t\t \n\tu32 reoct_l;\t\t \n\tu32 rpkt_u;\t\t \n\tu32 rpkt_l;\t\t \n\tu32 trund_u;\t\t \n\tu32 trund_l;\t\t \n\tu32 r64_u;\t\t \n\tu32 r64_l;\t\t \n\tu32 r127_u;\t\t \n\tu32 r127_l;\t\t \n\tu32 r255_u;\t\t \n\tu32 r255_l;\t\t \n\tu32 r511_u;\t\t \n\tu32 r511_l;\t\t \n\tu32 r1023_u;\t\t \n\tu32 r1023_l;\t\t \n\tu32 r1518_u;\t\t \n\tu32 r1518_l;\t\t \n\tu32 r1519x_u;\t\t \n\tu32 r1519x_l;\t\t \n\tu32 trovr_u;\t\t \n\tu32 trovr_l;\t\t \n\tu32 trjbr_u;\t\t \n\tu32 trjbr_l;\t\t \n\tu32 trfrg_u;\t\t \n\tu32 trfrg_l;\t\t \n\tu32 rerr_u;\t\t \n\tu32 rerr_l;\t\t \n};\n\nstruct tgec_cfg {\n\tbool pause_ignore;\n\tbool promiscuous_mode_enable;\n\tu16 max_frame_length;\n\tu16 pause_quant;\n\tu32 tx_ipg_length;\n};\n\nstruct fman_mac {\n\t \n\tstruct tgec_regs __iomem *regs;\n\t \n\tu64 addr;\n\tu16 max_speed;\n\tstruct mac_device *dev_id;  \n\tfman_mac_exception_cb *exception_cb;\n\tfman_mac_exception_cb *event_cb;\n\t \n\tstruct eth_hash_t *multicast_addr_hash;\n\t \n\tstruct eth_hash_t *unicast_addr_hash;\n\tu8 mac_id;\n\tu32 exceptions;\n\tstruct tgec_cfg *cfg;\n\tvoid *fm;\n\tstruct fman_rev_info fm_rev_info;\n\tbool allmulti_enabled;\n};\n\nstatic void set_mac_address(struct tgec_regs __iomem *regs, const u8 *adr)\n{\n\tu32 tmp0, tmp1;\n\n\ttmp0 = (u32)(adr[0] | adr[1] << 8 | adr[2] << 16 | adr[3] << 24);\n\ttmp1 = (u32)(adr[4] | adr[5] << 8);\n\tiowrite32be(tmp0, &regs->mac_addr_0);\n\tiowrite32be(tmp1, &regs->mac_addr_1);\n}\n\nstatic void set_dflts(struct tgec_cfg *cfg)\n{\n\tcfg->promiscuous_mode_enable = false;\n\tcfg->pause_ignore = false;\n\tcfg->tx_ipg_length = DEFAULT_TX_IPG_LENGTH;\n\tcfg->max_frame_length = DEFAULT_MAX_FRAME_LENGTH;\n\tcfg->pause_quant = DEFAULT_PAUSE_QUANT;\n}\n\nstatic int init(struct tgec_regs __iomem *regs, struct tgec_cfg *cfg,\n\t\tu32 exception_mask)\n{\n\tu32 tmp;\n\n\t \n\ttmp = CMF_CFG_CRC_FWD;\n\tif (cfg->promiscuous_mode_enable)\n\t\ttmp |= CMD_CFG_PROMIS_EN;\n\tif (cfg->pause_ignore)\n\t\ttmp |= CMD_CFG_PAUSE_IGNORE;\n\t \n\ttmp |= CMD_CFG_NO_LEN_CHK;\n\tiowrite32be(tmp, &regs->command_config);\n\n\t \n\tiowrite32be((u32)cfg->max_frame_length, &regs->maxfrm);\n\t \n\tiowrite32be(cfg->pause_quant, &regs->pause_quant);\n\n\t \n\tiowrite32be(0xffffffff, &regs->ievent);\n\tiowrite32be(ioread32be(&regs->imask) | exception_mask, &regs->imask);\n\n\treturn 0;\n}\n\nstatic int check_init_parameters(struct fman_mac *tgec)\n{\n\tif (!tgec->exception_cb) {\n\t\tpr_err(\"uninitialized exception_cb\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!tgec->event_cb) {\n\t\tpr_err(\"uninitialized event_cb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_exception_flag(enum fman_mac_exceptions exception)\n{\n\tu32 bit_mask;\n\n\tswitch (exception) {\n\tcase FM_MAC_EX_10G_MDIO_SCAN_EVENT:\n\t\tbit_mask = TGEC_IMASK_MDIO_SCAN_EVENT;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_MDIO_CMD_CMPL:\n\t\tbit_mask = TGEC_IMASK_MDIO_CMD_CMPL;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_REM_FAULT:\n\t\tbit_mask = TGEC_IMASK_REM_FAULT;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_LOC_FAULT:\n\t\tbit_mask = TGEC_IMASK_LOC_FAULT;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_TX_ECC_ER:\n\t\tbit_mask = TGEC_IMASK_TX_ECC_ER;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_TX_FIFO_UNFL:\n\t\tbit_mask = TGEC_IMASK_TX_FIFO_UNFL;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_TX_FIFO_OVFL:\n\t\tbit_mask = TGEC_IMASK_TX_FIFO_OVFL;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_TX_ER:\n\t\tbit_mask = TGEC_IMASK_TX_ER;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_RX_FIFO_OVFL:\n\t\tbit_mask = TGEC_IMASK_RX_FIFO_OVFL;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_RX_ECC_ER:\n\t\tbit_mask = TGEC_IMASK_RX_ECC_ER;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_RX_JAB_FRM:\n\t\tbit_mask = TGEC_IMASK_RX_JAB_FRM;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_RX_OVRSZ_FRM:\n\t\tbit_mask = TGEC_IMASK_RX_OVRSZ_FRM;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_RX_RUNT_FRM:\n\t\tbit_mask = TGEC_IMASK_RX_RUNT_FRM;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_RX_FRAG_FRM:\n\t\tbit_mask = TGEC_IMASK_RX_FRAG_FRM;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_RX_LEN_ER:\n\t\tbit_mask = TGEC_IMASK_RX_LEN_ER;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_RX_CRC_ER:\n\t\tbit_mask = TGEC_IMASK_RX_CRC_ER;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_RX_ALIGN_ER:\n\t\tbit_mask = TGEC_IMASK_RX_ALIGN_ER;\n\t\tbreak;\n\tdefault:\n\t\tbit_mask = 0;\n\t\tbreak;\n\t}\n\n\treturn bit_mask;\n}\n\nstatic void tgec_err_exception(void *handle)\n{\n\tstruct fman_mac *tgec = (struct fman_mac *)handle;\n\tstruct tgec_regs __iomem *regs = tgec->regs;\n\tu32 event;\n\n\t \n\tevent = ioread32be(&regs->ievent) &\n\t\t\t   ~(TGEC_IMASK_MDIO_SCAN_EVENT |\n\t\t\t   TGEC_IMASK_MDIO_CMD_CMPL);\n\n\tevent &= ioread32be(&regs->imask);\n\n\tiowrite32be(event, &regs->ievent);\n\n\tif (event & TGEC_IMASK_REM_FAULT)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_REM_FAULT);\n\tif (event & TGEC_IMASK_LOC_FAULT)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_LOC_FAULT);\n\tif (event & TGEC_IMASK_TX_ECC_ER)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_TX_ECC_ER);\n\tif (event & TGEC_IMASK_TX_FIFO_UNFL)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_TX_FIFO_UNFL);\n\tif (event & TGEC_IMASK_TX_FIFO_OVFL)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_TX_FIFO_OVFL);\n\tif (event & TGEC_IMASK_TX_ER)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_TX_ER);\n\tif (event & TGEC_IMASK_RX_FIFO_OVFL)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_FIFO_OVFL);\n\tif (event & TGEC_IMASK_RX_ECC_ER)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_ECC_ER);\n\tif (event & TGEC_IMASK_RX_JAB_FRM)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_JAB_FRM);\n\tif (event & TGEC_IMASK_RX_OVRSZ_FRM)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_OVRSZ_FRM);\n\tif (event & TGEC_IMASK_RX_RUNT_FRM)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_RUNT_FRM);\n\tif (event & TGEC_IMASK_RX_FRAG_FRM)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_FRAG_FRM);\n\tif (event & TGEC_IMASK_RX_LEN_ER)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_LEN_ER);\n\tif (event & TGEC_IMASK_RX_CRC_ER)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_CRC_ER);\n\tif (event & TGEC_IMASK_RX_ALIGN_ER)\n\t\ttgec->exception_cb(tgec->dev_id, FM_MAC_EX_10G_RX_ALIGN_ER);\n}\n\nstatic void free_init_resources(struct fman_mac *tgec)\n{\n\tfman_unregister_intr(tgec->fm, FMAN_MOD_MAC, tgec->mac_id,\n\t\t\t     FMAN_INTR_TYPE_ERR);\n\n\t \n\tfree_hash_table(tgec->multicast_addr_hash);\n\ttgec->multicast_addr_hash = NULL;\n\n\t \n\tfree_hash_table(tgec->unicast_addr_hash);\n\ttgec->unicast_addr_hash = NULL;\n}\n\nstatic int tgec_enable(struct fman_mac *tgec)\n{\n\treturn 0;\n}\n\nstatic void tgec_disable(struct fman_mac *tgec)\n{\n}\n\nstatic int tgec_set_promiscuous(struct fman_mac *tgec, bool new_val)\n{\n\tstruct tgec_regs __iomem *regs = tgec->regs;\n\tu32 tmp;\n\n\ttmp = ioread32be(&regs->command_config);\n\tif (new_val)\n\t\ttmp |= CMD_CFG_PROMIS_EN;\n\telse\n\t\ttmp &= ~CMD_CFG_PROMIS_EN;\n\tiowrite32be(tmp, &regs->command_config);\n\n\treturn 0;\n}\n\nstatic int tgec_set_tx_pause_frames(struct fman_mac *tgec,\n\t\t\t\t    u8 __maybe_unused priority, u16 pause_time,\n\t\t\t\t    u16 __maybe_unused thresh_time)\n{\n\tstruct tgec_regs __iomem *regs = tgec->regs;\n\n\tiowrite32be((u32)pause_time, &regs->pause_quant);\n\n\treturn 0;\n}\n\nstatic int tgec_accept_rx_pause_frames(struct fman_mac *tgec, bool en)\n{\n\tstruct tgec_regs __iomem *regs = tgec->regs;\n\tu32 tmp;\n\n\ttmp = ioread32be(&regs->command_config);\n\tif (!en)\n\t\ttmp |= CMD_CFG_PAUSE_IGNORE;\n\telse\n\t\ttmp &= ~CMD_CFG_PAUSE_IGNORE;\n\tiowrite32be(tmp, &regs->command_config);\n\n\treturn 0;\n}\n\nstatic void tgec_mac_config(struct phylink_config *config, unsigned int mode,\n\t\t\t    const struct phylink_link_state *state)\n{\n}\n\nstatic void tgec_link_up(struct phylink_config *config, struct phy_device *phy,\n\t\t\t unsigned int mode, phy_interface_t interface,\n\t\t\t int speed, int duplex, bool tx_pause, bool rx_pause)\n{\n\tstruct mac_device *mac_dev = fman_config_to_mac(config);\n\tstruct fman_mac *tgec = mac_dev->fman_mac;\n\tstruct tgec_regs __iomem *regs = tgec->regs;\n\tu16 pause_time = tx_pause ? FSL_FM_PAUSE_TIME_ENABLE :\n\t\t\t FSL_FM_PAUSE_TIME_DISABLE;\n\tu32 tmp;\n\n\ttgec_set_tx_pause_frames(tgec, 0, pause_time, 0);\n\ttgec_accept_rx_pause_frames(tgec, rx_pause);\n\tmac_dev->update_speed(mac_dev, speed);\n\n\ttmp = ioread32be(&regs->command_config);\n\ttmp |= CMD_CFG_RX_EN | CMD_CFG_TX_EN;\n\tiowrite32be(tmp, &regs->command_config);\n}\n\nstatic void tgec_link_down(struct phylink_config *config, unsigned int mode,\n\t\t\t   phy_interface_t interface)\n{\n\tstruct fman_mac *tgec = fman_config_to_mac(config)->fman_mac;\n\tstruct tgec_regs __iomem *regs = tgec->regs;\n\tu32 tmp;\n\n\ttmp = ioread32be(&regs->command_config);\n\ttmp &= ~(CMD_CFG_RX_EN | CMD_CFG_TX_EN);\n\tiowrite32be(tmp, &regs->command_config);\n}\n\nstatic const struct phylink_mac_ops tgec_mac_ops = {\n\t.mac_config = tgec_mac_config,\n\t.mac_link_up = tgec_link_up,\n\t.mac_link_down = tgec_link_down,\n};\n\nstatic int tgec_modify_mac_address(struct fman_mac *tgec,\n\t\t\t\t   const enet_addr_t *p_enet_addr)\n{\n\ttgec->addr = ENET_ADDR_TO_UINT64(*p_enet_addr);\n\tset_mac_address(tgec->regs, (const u8 *)(*p_enet_addr));\n\n\treturn 0;\n}\n\nstatic int tgec_add_hash_mac_address(struct fman_mac *tgec,\n\t\t\t\t     enet_addr_t *eth_addr)\n{\n\tstruct tgec_regs __iomem *regs = tgec->regs;\n\tstruct eth_hash_entry *hash_entry;\n\tu32 crc = 0xFFFFFFFF, hash;\n\tu64 addr;\n\n\taddr = ENET_ADDR_TO_UINT64(*eth_addr);\n\n\tif (!(addr & GROUP_ADDRESS)) {\n\t\t \n\t\tpr_err(\"Unicast Address\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tcrc = crc32_le(crc, (u8 *)eth_addr, ETH_ALEN);\n\tcrc = bitrev32(crc);\n\t \n\thash = (crc >> TGEC_HASH_MCAST_SHIFT) & TGEC_HASH_ADR_MSK;\n\n\t \n\thash_entry = kmalloc(sizeof(*hash_entry), GFP_ATOMIC);\n\tif (!hash_entry)\n\t\treturn -ENOMEM;\n\thash_entry->addr = addr;\n\tINIT_LIST_HEAD(&hash_entry->node);\n\n\tlist_add_tail(&hash_entry->node,\n\t\t      &tgec->multicast_addr_hash->lsts[hash]);\n\tiowrite32be((hash | TGEC_HASH_MCAST_EN), &regs->hashtable_ctrl);\n\n\treturn 0;\n}\n\nstatic int tgec_set_allmulti(struct fman_mac *tgec, bool enable)\n{\n\tu32 entry;\n\tstruct tgec_regs __iomem *regs = tgec->regs;\n\n\tif (enable) {\n\t\tfor (entry = 0; entry < TGEC_HASH_TABLE_SIZE; entry++)\n\t\t\tiowrite32be(entry | TGEC_HASH_MCAST_EN,\n\t\t\t\t    &regs->hashtable_ctrl);\n\t} else {\n\t\tfor (entry = 0; entry < TGEC_HASH_TABLE_SIZE; entry++)\n\t\t\tiowrite32be(entry & ~TGEC_HASH_MCAST_EN,\n\t\t\t\t    &regs->hashtable_ctrl);\n\t}\n\n\ttgec->allmulti_enabled = enable;\n\n\treturn 0;\n}\n\nstatic int tgec_set_tstamp(struct fman_mac *tgec, bool enable)\n{\n\tstruct tgec_regs __iomem *regs = tgec->regs;\n\tu32 tmp;\n\n\ttmp = ioread32be(&regs->command_config);\n\n\tif (enable)\n\t\ttmp |= CMD_CFG_EN_TIMESTAMP;\n\telse\n\t\ttmp &= ~CMD_CFG_EN_TIMESTAMP;\n\n\tiowrite32be(tmp, &regs->command_config);\n\n\treturn 0;\n}\n\nstatic int tgec_del_hash_mac_address(struct fman_mac *tgec,\n\t\t\t\t     enet_addr_t *eth_addr)\n{\n\tstruct tgec_regs __iomem *regs = tgec->regs;\n\tstruct eth_hash_entry *hash_entry = NULL;\n\tstruct list_head *pos;\n\tu32 crc = 0xFFFFFFFF, hash;\n\tu64 addr;\n\n\taddr = ((*(u64 *)eth_addr) >> 16);\n\n\t \n\tcrc = crc32_le(crc, (u8 *)eth_addr, ETH_ALEN);\n\tcrc = bitrev32(crc);\n\t \n\thash = (crc >> TGEC_HASH_MCAST_SHIFT) & TGEC_HASH_ADR_MSK;\n\n\tlist_for_each(pos, &tgec->multicast_addr_hash->lsts[hash]) {\n\t\thash_entry = ETH_HASH_ENTRY_OBJ(pos);\n\t\tif (hash_entry && hash_entry->addr == addr) {\n\t\t\tlist_del_init(&hash_entry->node);\n\t\t\tkfree(hash_entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!tgec->allmulti_enabled) {\n\t\tif (list_empty(&tgec->multicast_addr_hash->lsts[hash]))\n\t\t\tiowrite32be((hash & ~TGEC_HASH_MCAST_EN),\n\t\t\t\t    &regs->hashtable_ctrl);\n\t}\n\n\treturn 0;\n}\n\nstatic int tgec_set_exception(struct fman_mac *tgec,\n\t\t\t      enum fman_mac_exceptions exception, bool enable)\n{\n\tstruct tgec_regs __iomem *regs = tgec->regs;\n\tu32 bit_mask = 0;\n\n\tbit_mask = get_exception_flag(exception);\n\tif (bit_mask) {\n\t\tif (enable)\n\t\t\ttgec->exceptions |= bit_mask;\n\t\telse\n\t\t\ttgec->exceptions &= ~bit_mask;\n\t} else {\n\t\tpr_err(\"Undefined exception\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (enable)\n\t\tiowrite32be(ioread32be(&regs->imask) | bit_mask, &regs->imask);\n\telse\n\t\tiowrite32be(ioread32be(&regs->imask) & ~bit_mask, &regs->imask);\n\n\treturn 0;\n}\n\nstatic int tgec_init(struct fman_mac *tgec)\n{\n\tstruct tgec_cfg *cfg;\n\tenet_addr_t eth_addr;\n\tint err;\n\n\tif (DEFAULT_RESET_ON_INIT &&\n\t    (fman_reset_mac(tgec->fm, tgec->mac_id) != 0)) {\n\t\tpr_err(\"Can't reset MAC!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_init_parameters(tgec);\n\tif (err)\n\t\treturn err;\n\n\tcfg = tgec->cfg;\n\n\tif (tgec->addr) {\n\t\tMAKE_ENET_ADDR_FROM_UINT64(tgec->addr, eth_addr);\n\t\tset_mac_address(tgec->regs, (const u8 *)eth_addr);\n\t}\n\n\t \n\t \n\tif (tgec->fm_rev_info.major <= 2)\n\t\ttgec->exceptions &= ~(TGEC_IMASK_REM_FAULT |\n\t\t\t\t      TGEC_IMASK_LOC_FAULT);\n\n\terr = init(tgec->regs, cfg, tgec->exceptions);\n\tif (err) {\n\t\tfree_init_resources(tgec);\n\t\tpr_err(\"TGEC version doesn't support this i/f mode\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = fman_set_mac_max_frame(tgec->fm, tgec->mac_id,\n\t\t\t\t     cfg->max_frame_length);\n\tif (err) {\n\t\tpr_err(\"Setting max frame length FAILED\\n\");\n\t\tfree_init_resources(tgec);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (tgec->fm_rev_info.major == 2) {\n\t\tstruct tgec_regs __iomem *regs = tgec->regs;\n\t\tu32 tmp;\n\n\t\t \n\t\ttmp = (ioread32be(&regs->tx_ipg_len) &\n\t\t       ~TGEC_TX_IPG_LENGTH_MASK) | 12;\n\n\t\tiowrite32be(tmp, &regs->tx_ipg_len);\n\t}\n\n\ttgec->multicast_addr_hash = alloc_hash_table(TGEC_HASH_TABLE_SIZE);\n\tif (!tgec->multicast_addr_hash) {\n\t\tfree_init_resources(tgec);\n\t\tpr_err(\"allocation hash table is FAILED\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttgec->unicast_addr_hash = alloc_hash_table(TGEC_HASH_TABLE_SIZE);\n\tif (!tgec->unicast_addr_hash) {\n\t\tfree_init_resources(tgec);\n\t\tpr_err(\"allocation hash table is FAILED\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfman_register_intr(tgec->fm, FMAN_MOD_MAC, tgec->mac_id,\n\t\t\t   FMAN_INTR_TYPE_ERR, tgec_err_exception, tgec);\n\n\tkfree(cfg);\n\ttgec->cfg = NULL;\n\n\treturn 0;\n}\n\nstatic int tgec_free(struct fman_mac *tgec)\n{\n\tfree_init_resources(tgec);\n\n\tkfree(tgec->cfg);\n\tkfree(tgec);\n\n\treturn 0;\n}\n\nstatic struct fman_mac *tgec_config(struct mac_device *mac_dev,\n\t\t\t\t    struct fman_mac_params *params)\n{\n\tstruct fman_mac *tgec;\n\tstruct tgec_cfg *cfg;\n\n\t \n\ttgec = kzalloc(sizeof(*tgec), GFP_KERNEL);\n\tif (!tgec)\n\t\treturn NULL;\n\n\t \n\tcfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg) {\n\t\ttgec_free(tgec);\n\t\treturn NULL;\n\t}\n\n\t \n\ttgec->cfg = cfg;\n\n\tset_dflts(cfg);\n\n\ttgec->regs = mac_dev->vaddr;\n\ttgec->addr = ENET_ADDR_TO_UINT64(mac_dev->addr);\n\ttgec->mac_id = params->mac_id;\n\ttgec->exceptions = (TGEC_IMASK_MDIO_SCAN_EVENT\t|\n\t\t\t    TGEC_IMASK_REM_FAULT\t|\n\t\t\t    TGEC_IMASK_LOC_FAULT\t|\n\t\t\t    TGEC_IMASK_TX_ECC_ER\t|\n\t\t\t    TGEC_IMASK_TX_FIFO_UNFL\t|\n\t\t\t    TGEC_IMASK_TX_FIFO_OVFL\t|\n\t\t\t    TGEC_IMASK_TX_ER\t\t|\n\t\t\t    TGEC_IMASK_RX_FIFO_OVFL\t|\n\t\t\t    TGEC_IMASK_RX_ECC_ER\t|\n\t\t\t    TGEC_IMASK_RX_JAB_FRM\t|\n\t\t\t    TGEC_IMASK_RX_OVRSZ_FRM\t|\n\t\t\t    TGEC_IMASK_RX_RUNT_FRM\t|\n\t\t\t    TGEC_IMASK_RX_FRAG_FRM\t|\n\t\t\t    TGEC_IMASK_RX_CRC_ER\t|\n\t\t\t    TGEC_IMASK_RX_ALIGN_ER);\n\ttgec->exception_cb = params->exception_cb;\n\ttgec->event_cb = params->event_cb;\n\ttgec->dev_id = mac_dev;\n\ttgec->fm = params->fm;\n\n\t \n\tfman_get_revision(tgec->fm, &tgec->fm_rev_info);\n\n\treturn tgec;\n}\n\nint tgec_initialization(struct mac_device *mac_dev,\n\t\t\tstruct device_node *mac_node,\n\t\t\tstruct fman_mac_params *params)\n{\n\tint err;\n\tstruct fman_mac\t\t*tgec;\n\n\tmac_dev->phylink_ops\t\t= &tgec_mac_ops;\n\tmac_dev->set_promisc\t\t= tgec_set_promiscuous;\n\tmac_dev->change_addr\t\t= tgec_modify_mac_address;\n\tmac_dev->add_hash_mac_addr\t= tgec_add_hash_mac_address;\n\tmac_dev->remove_hash_mac_addr\t= tgec_del_hash_mac_address;\n\tmac_dev->set_exception\t\t= tgec_set_exception;\n\tmac_dev->set_allmulti\t\t= tgec_set_allmulti;\n\tmac_dev->set_tstamp\t\t= tgec_set_tstamp;\n\tmac_dev->set_multi\t\t= fman_set_multi;\n\tmac_dev->enable\t\t\t= tgec_enable;\n\tmac_dev->disable\t\t= tgec_disable;\n\n\tmac_dev->fman_mac = tgec_config(mac_dev, params);\n\tif (!mac_dev->fman_mac) {\n\t\terr = -EINVAL;\n\t\tgoto _return;\n\t}\n\n\t \n\tif (mac_dev->phy_if == PHY_INTERFACE_MODE_XGMII)\n\t\tmac_dev->phy_if = PHY_INTERFACE_MODE_XAUI;\n\n\t__set_bit(PHY_INTERFACE_MODE_XAUI,\n\t\t  mac_dev->phylink_config.supported_interfaces);\n\tmac_dev->phylink_config.mac_capabilities =\n\t\tMAC_SYM_PAUSE | MAC_ASYM_PAUSE | MAC_10000FD;\n\n\ttgec = mac_dev->fman_mac;\n\ttgec->cfg->max_frame_length = fman_get_max_frm();\n\terr = tgec_init(tgec);\n\tif (err < 0)\n\t\tgoto _return_fm_mac_free;\n\n\t \n\terr = tgec_set_exception(tgec, FM_MAC_EX_10G_TX_ECC_ER, false);\n\tif (err < 0)\n\t\tgoto _return_fm_mac_free;\n\n\tpr_info(\"FMan XGEC version: 0x%08x\\n\",\n\t\tioread32be(&tgec->regs->tgec_id));\n\tgoto _return;\n\n_return_fm_mac_free:\n\ttgec_free(mac_dev->fman_mac);\n\n_return:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}