{
  "module_name": "fman_keygen.c",
  "hash_id": "ef0fe7f314c26291b2be40880ca78688b5a91bb809b365e95a9c110617b39e80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fman/fman_keygen.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n\n#include \"fman_keygen.h\"\n\n \n#define FMAN_MAX_NUM_OF_HW_PORTS\t\t64\n\n \n#define FM_KG_MAX_NUM_OF_SCHEMES\t\t32\n\n \n#define FM_KG_NUM_OF_GENERIC_REGS\t\t8\n\n \n#define DUMMY_PORT_ID\t\t\t\t0\n\n \n#define KG_SCH_DEF_USE_KGSE_DV_0\t\t2\n#define KG_SCH_DEF_USE_KGSE_DV_1\t\t3\n\n \n#define FM_KG_KGAR_NUM_SHIFT\t\t\t16\n#define KG_SCH_DEF_L4_PORT_SHIFT\t\t8\n#define KG_SCH_DEF_IP_ADDR_SHIFT\t\t18\n#define KG_SCH_HASH_CONFIG_SHIFT_SHIFT\t\t24\n\n \n\n \n#define FM_KG_KGGCR_EN\t\t\t\t0x80000000\n\n \n#define FM_KG_KGAR_GO\t\t\t\t0x80000000\n#define FM_KG_KGAR_READ\t\t\t\t0x40000000\n#define FM_KG_KGAR_WRITE\t\t\t0x00000000\n#define FM_KG_KGAR_SEL_SCHEME_ENTRY\t\t0x00000000\n#define FM_KG_KGAR_SCM_WSEL_UPDATE_CNT\t\t0x00008000\n\n#define FM_KG_KGAR_ERR\t\t\t\t0x20000000\n#define FM_KG_KGAR_SEL_CLS_PLAN_ENTRY\t\t0x01000000\n#define FM_KG_KGAR_SEL_PORT_ENTRY\t\t0x02000000\n#define FM_KG_KGAR_SEL_PORT_WSEL_SP\t\t0x00008000\n#define FM_KG_KGAR_SEL_PORT_WSEL_CPP\t\t0x00004000\n\n \n#define FM_EX_KG_DOUBLE_ECC\t\t\t0x80000000\n#define FM_EX_KG_KEYSIZE_OVERFLOW\t\t0x40000000\n\n \n#define KG_SCH_MODE_EN\t\t\t\t0x80000000\n#define KG_SCH_VSP_NO_KSP_EN\t\t\t0x80000000\n#define KG_SCH_HASH_CONFIG_SYM\t\t\t0x40000000\n\n \n#define KG_SCH_KN_PORT_ID\t\t0x80000000\n#define KG_SCH_KN_MACDST\t\t0x40000000\n#define KG_SCH_KN_MACSRC\t\t0x20000000\n#define KG_SCH_KN_TCI1\t\t\t0x10000000\n#define KG_SCH_KN_TCI2\t\t\t0x08000000\n#define KG_SCH_KN_ETYPE\t\t\t0x04000000\n#define KG_SCH_KN_PPPSID\t\t0x02000000\n#define KG_SCH_KN_PPPID\t\t\t0x01000000\n#define KG_SCH_KN_MPLS1\t\t\t0x00800000\n#define KG_SCH_KN_MPLS2\t\t\t0x00400000\n#define KG_SCH_KN_MPLS_LAST\t\t0x00200000\n#define KG_SCH_KN_IPSRC1\t\t0x00100000\n#define KG_SCH_KN_IPDST1\t\t0x00080000\n#define KG_SCH_KN_PTYPE1\t\t0x00040000\n#define KG_SCH_KN_IPTOS_TC1\t\t0x00020000\n#define KG_SCH_KN_IPV6FL1\t\t0x00010000\n#define KG_SCH_KN_IPSRC2\t\t0x00008000\n#define KG_SCH_KN_IPDST2\t\t0x00004000\n#define KG_SCH_KN_PTYPE2\t\t0x00002000\n#define KG_SCH_KN_IPTOS_TC2\t\t0x00001000\n#define KG_SCH_KN_IPV6FL2\t\t0x00000800\n#define KG_SCH_KN_GREPTYPE\t\t0x00000400\n#define KG_SCH_KN_IPSEC_SPI\t\t0x00000200\n#define KG_SCH_KN_IPSEC_NH\t\t0x00000100\n#define KG_SCH_KN_IPPID\t\t\t0x00000080\n#define KG_SCH_KN_L4PSRC\t\t0x00000004\n#define KG_SCH_KN_L4PDST\t\t0x00000002\n#define KG_SCH_KN_TFLG\t\t\t0x00000001\n\n \n#define NIA_ENG_BMI\t\t\t0x00500000\n#define NIA_BMI_AC_ENQ_FRAME\t\t0x00000002\n#define ENQUEUE_KG_DFLT_NIA\t\t(NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)\n\n \n\n \n#define DEFAULT_HASH_DIST_FQID_SHIFT\t\t0\n\n \n#define DEFAULT_HASH_SHIFT\t\t\t0\n\n \n#define DEFAULT_SYMMETRIC_HASH\t\t\tfalse\n\n \n#define DEFAULT_HASH_KEY_EXTRACT_FIELDS\t\t\\\n\t(KG_SCH_KN_IPSRC1 | KG_SCH_KN_IPDST1 | \\\n\t KG_SCH_KN_L4PSRC | KG_SCH_KN_L4PDST | \\\n\t KG_SCH_KN_IPSEC_SPI)\n\n \n \n#define DEFAULT_HASH_KEY_IPv4_ADDR\t\t0x0A0A0A0A\n \n#define DEFAULT_HASH_KEY_L4_PORT\t\t0x0B0B0B0B\n\n \n\n \nstruct fman_kg_scheme_regs {\n\tu32 kgse_mode;\t\t \n\tu32 kgse_ekfc;\t\t \n\tu32 kgse_ekdv;\t\t \n\tu32 kgse_bmch;\t\t \n\tu32 kgse_bmcl;\t\t \n\tu32 kgse_fqb;\t\t \n\tu32 kgse_hc;\t\t \n\tu32 kgse_ppc;\t\t \n\tu32 kgse_gec[FM_KG_NUM_OF_GENERIC_REGS];\n\t\t\t \n\tu32 kgse_spc;\n\t\t \n\tu32 kgse_dv0;\t \n\tu32 kgse_dv1;\t \n\tu32 kgse_ccbs;\n\t\t \n\tu32 kgse_mv;\t \n\tu32 kgse_om;\t \n\tu32 kgse_vsp;\n\t\t \n};\n\n \nstruct fman_kg_pe_regs {\n\tu32 fmkg_pe_sp;\t\t \n\tu32 fmkg_pe_cpp;\n\t\t \n};\n\n \nstruct fman_kg_regs {\n\tu32 fmkg_gcr;\t \n\tu32 res004;\t \n\tu32 res008;\t \n\tu32 fmkg_eer;\t \n\tu32 fmkg_eeer;\t \n\tu32 res014;\t \n\tu32 res018;\t \n\tu32 fmkg_seer;\t \n\tu32 fmkg_seeer;\t \n\tu32 fmkg_gsr;\t \n\tu32 fmkg_tpc;\t \n\tu32 fmkg_serc;\t \n\tu32 res030[4];\t \n\tu32 fmkg_fdor;\t \n\tu32 fmkg_gdv0r;\t \n\tu32 fmkg_gdv1r;\t \n\tu32 res04c[6];\t \n\tu32 fmkg_feer;\t \n\tu32 res068[38];\t \n\tunion {\n\t\tu32 fmkg_indirect[63];\t \n\t\tstruct fman_kg_scheme_regs fmkg_sch;  \n\t\tstruct fman_kg_pe_regs fmkg_pe;  \n\t};\n\tu32 fmkg_ar;\t \n};\n\n \nstruct keygen_scheme {\n\tbool used;\t \n\tu8 hw_port_id;\n\t\t \n\tu32 base_fqid;\n\t\t \n\tu32 hash_fqid_count;\n\t\t \n\tbool use_hashing;\t \n\tbool symmetric_hash;\t \n\tu8 hashShift;\n\t\t \n\tu32 match_vector;\t \n};\n\n \nstruct fman_keygen {\n\tstruct keygen_scheme schemes[FM_KG_MAX_NUM_OF_SCHEMES];\n\t\t\t\t \n\tstruct fman_kg_regs __iomem *keygen_regs;\t \n};\n\n \nstatic int keygen_write_ar_wait(struct fman_kg_regs __iomem *regs, u32 fmkg_ar)\n{\n\tiowrite32be(fmkg_ar, &regs->fmkg_ar);\n\n\t \n\twhile (fmkg_ar & FM_KG_KGAR_GO)\n\t\tfmkg_ar = ioread32be(&regs->fmkg_ar);\n\n\tif (fmkg_ar & FM_KG_KGAR_ERR)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic u32 build_ar_scheme(u8 scheme_id, bool update_counter, bool write)\n{\n\tu32 rw = (u32)(write ? FM_KG_KGAR_WRITE : FM_KG_KGAR_READ);\n\n\treturn (u32)(FM_KG_KGAR_GO |\n\t\t\trw |\n\t\t\tFM_KG_KGAR_SEL_SCHEME_ENTRY |\n\t\t\tDUMMY_PORT_ID |\n\t\t\t((u32)scheme_id << FM_KG_KGAR_NUM_SHIFT) |\n\t\t\t(update_counter ? FM_KG_KGAR_SCM_WSEL_UPDATE_CNT : 0));\n}\n\n \nstatic u32 build_ar_bind_scheme(u8 hwport_id, bool write)\n{\n\tu32 rw = write ? (u32)FM_KG_KGAR_WRITE : (u32)FM_KG_KGAR_READ;\n\n\treturn (u32)(FM_KG_KGAR_GO |\n\t\t\trw |\n\t\t\tFM_KG_KGAR_SEL_PORT_ENTRY |\n\t\t\thwport_id |\n\t\t\tFM_KG_KGAR_SEL_PORT_WSEL_SP);\n}\n\n \nstatic void keygen_write_sp(struct fman_kg_regs __iomem *regs, u32 sp, bool add)\n{\n\tu32 tmp;\n\n\ttmp = ioread32be(&regs->fmkg_pe.fmkg_pe_sp);\n\n\tif (add)\n\t\ttmp |= sp;\n\telse\n\t\ttmp &= ~sp;\n\n\tiowrite32be(tmp, &regs->fmkg_pe.fmkg_pe_sp);\n}\n\n \nstatic u32 build_ar_bind_cls_plan(u8 hwport_id, bool write)\n{\n\tu32 rw = write ? (u32)FM_KG_KGAR_WRITE : (u32)FM_KG_KGAR_READ;\n\n\treturn (u32)(FM_KG_KGAR_GO |\n\t\t\trw |\n\t\t\tFM_KG_KGAR_SEL_PORT_ENTRY |\n\t\t\thwport_id |\n\t\t\tFM_KG_KGAR_SEL_PORT_WSEL_CPP);\n}\n\n \nstatic void keygen_write_cpp(struct fman_kg_regs __iomem *regs, u32 cpp)\n{\n\tiowrite32be(cpp, &regs->fmkg_pe.fmkg_pe_cpp);\n}\n\n \nstatic int keygen_write_scheme(struct fman_kg_regs __iomem *regs, u8 scheme_id,\n\t\t\t       struct fman_kg_scheme_regs *scheme_regs,\n\t\t\t\tbool update_counter)\n{\n\tu32 ar_reg;\n\tint err, i;\n\n\t \n\tiowrite32be(scheme_regs->kgse_mode, &regs->fmkg_sch.kgse_mode);\n\tiowrite32be(scheme_regs->kgse_ekfc, &regs->fmkg_sch.kgse_ekfc);\n\tiowrite32be(scheme_regs->kgse_ekdv, &regs->fmkg_sch.kgse_ekdv);\n\tiowrite32be(scheme_regs->kgse_bmch, &regs->fmkg_sch.kgse_bmch);\n\tiowrite32be(scheme_regs->kgse_bmcl, &regs->fmkg_sch.kgse_bmcl);\n\tiowrite32be(scheme_regs->kgse_fqb, &regs->fmkg_sch.kgse_fqb);\n\tiowrite32be(scheme_regs->kgse_hc, &regs->fmkg_sch.kgse_hc);\n\tiowrite32be(scheme_regs->kgse_ppc, &regs->fmkg_sch.kgse_ppc);\n\tiowrite32be(scheme_regs->kgse_spc, &regs->fmkg_sch.kgse_spc);\n\tiowrite32be(scheme_regs->kgse_dv0, &regs->fmkg_sch.kgse_dv0);\n\tiowrite32be(scheme_regs->kgse_dv1, &regs->fmkg_sch.kgse_dv1);\n\tiowrite32be(scheme_regs->kgse_ccbs, &regs->fmkg_sch.kgse_ccbs);\n\tiowrite32be(scheme_regs->kgse_mv, &regs->fmkg_sch.kgse_mv);\n\tiowrite32be(scheme_regs->kgse_om, &regs->fmkg_sch.kgse_om);\n\tiowrite32be(scheme_regs->kgse_vsp, &regs->fmkg_sch.kgse_vsp);\n\n\tfor (i = 0 ; i < FM_KG_NUM_OF_GENERIC_REGS ; i++)\n\t\tiowrite32be(scheme_regs->kgse_gec[i],\n\t\t\t    &regs->fmkg_sch.kgse_gec[i]);\n\n\t \n\tar_reg = build_ar_scheme(scheme_id, update_counter, true);\n\terr = keygen_write_ar_wait(regs, ar_reg);\n\tif (err != 0) {\n\t\tpr_err(\"Writing Action Register failed\\n\");\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\n \nstatic int get_free_scheme_id(struct fman_keygen *keygen, u8 *scheme_id)\n{\n\tu8 i;\n\n\tfor (i = 0; i < FM_KG_MAX_NUM_OF_SCHEMES; i++)\n\t\tif (!keygen->schemes[i].used) {\n\t\t\t*scheme_id = i;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic struct keygen_scheme *get_scheme(struct fman_keygen *keygen,\n\t\t\t\t\tu8 scheme_id)\n{\n\tif (scheme_id >= FM_KG_MAX_NUM_OF_SCHEMES)\n\t\treturn NULL;\n\treturn &keygen->schemes[scheme_id];\n}\n\n \nstatic int keygen_bind_port_to_schemes(struct fman_keygen *keygen,\n\t\t\t\t       u8 scheme_id,\n\t\t\t\t\tbool bind)\n{\n\tstruct fman_kg_regs __iomem *keygen_regs = keygen->keygen_regs;\n\tstruct keygen_scheme *scheme;\n\tu32 ar_reg;\n\tu32 schemes_vector = 0;\n\tint err;\n\n\tscheme = get_scheme(keygen, scheme_id);\n\tif (!scheme) {\n\t\tpr_err(\"Requested Scheme does not exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!scheme->used) {\n\t\tpr_err(\"Cannot bind port to an invalid scheme\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tschemes_vector |= 1 << (31 - scheme_id);\n\n\tar_reg = build_ar_bind_scheme(scheme->hw_port_id, false);\n\terr = keygen_write_ar_wait(keygen_regs, ar_reg);\n\tif (err != 0) {\n\t\tpr_err(\"Reading Action Register failed\\n\");\n\t\treturn err;\n\t}\n\n\tkeygen_write_sp(keygen_regs, schemes_vector, bind);\n\n\tar_reg = build_ar_bind_scheme(scheme->hw_port_id, true);\n\terr = keygen_write_ar_wait(keygen_regs, ar_reg);\n\tif (err != 0) {\n\t\tpr_err(\"Writing Action Register failed\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int keygen_scheme_setup(struct fman_keygen *keygen, u8 scheme_id,\n\t\t\t       bool enable)\n{\n\tstruct fman_kg_regs __iomem *keygen_regs = keygen->keygen_regs;\n\tstruct fman_kg_scheme_regs scheme_regs;\n\tstruct keygen_scheme *scheme;\n\tu32 tmp_reg;\n\tint err;\n\n\tscheme = get_scheme(keygen, scheme_id);\n\tif (!scheme) {\n\t\tpr_err(\"Requested Scheme does not exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (enable && scheme->used) {\n\t\tpr_err(\"The requested Scheme is already used\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemset(&scheme_regs, 0, sizeof(struct fman_kg_scheme_regs));\n\n\t \n\ttmp_reg = 0;\n\n\tif (enable) {\n\t\t \n\t\ttmp_reg |= KG_SCH_MODE_EN;\n\t\t \n\t\ttmp_reg |= ENQUEUE_KG_DFLT_NIA;\n\t}\n\n\tscheme_regs.kgse_mode = tmp_reg;\n\n\tscheme_regs.kgse_mv = scheme->match_vector;\n\n\t \n\tscheme_regs.kgse_vsp = KG_SCH_VSP_NO_KSP_EN;\n\n\t \n\n\tif (scheme->use_hashing) {\n\t\t \n\t\tscheme_regs.kgse_ekfc = DEFAULT_HASH_KEY_EXTRACT_FIELDS;\n\n\t\t \n\t\ttmp_reg = 0;\n\t\ttmp_reg |= (KG_SCH_DEF_USE_KGSE_DV_0 <<\n\t\t\t\tKG_SCH_DEF_IP_ADDR_SHIFT);\n\t\ttmp_reg |= (KG_SCH_DEF_USE_KGSE_DV_1 <<\n\t\t\t\tKG_SCH_DEF_L4_PORT_SHIFT);\n\t\tscheme_regs.kgse_ekdv = tmp_reg;\n\n\t\t \n\t\tscheme_regs.kgse_dv0 = DEFAULT_HASH_KEY_IPv4_ADDR;\n\t\t \n\t\tscheme_regs.kgse_dv1 = DEFAULT_HASH_KEY_L4_PORT;\n\n\t\t \n\t\ttmp_reg = 0;\n\t\ttmp_reg |= ((scheme->hash_fqid_count - 1) <<\n\t\t\t\tDEFAULT_HASH_DIST_FQID_SHIFT);\n\t\ttmp_reg |= scheme->hashShift << KG_SCH_HASH_CONFIG_SHIFT_SHIFT;\n\n\t\tif (scheme->symmetric_hash) {\n\t\t\t \n\t\t\ttmp_reg |= KG_SCH_HASH_CONFIG_SYM;\n\t\t}\n\t\tscheme_regs.kgse_hc = tmp_reg;\n\t} else {\n\t\tscheme_regs.kgse_ekfc = 0;\n\t\tscheme_regs.kgse_hc = 0;\n\t\tscheme_regs.kgse_ekdv = 0;\n\t\tscheme_regs.kgse_dv0 = 0;\n\t\tscheme_regs.kgse_dv1 = 0;\n\t}\n\n\t \n\ttmp_reg = 0;\n\ttmp_reg |= scheme->base_fqid;\n\tscheme_regs.kgse_fqb = tmp_reg;\n\n\t \n\tscheme_regs.kgse_bmch = 0;\n\tscheme_regs.kgse_bmcl = 0;\n\tscheme_regs.kgse_spc = 0;\n\n\t \n\terr = keygen_write_scheme(keygen_regs, scheme_id, &scheme_regs, true);\n\tif (err != 0) {\n\t\tpr_err(\"Writing scheme registers failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tscheme->used = enable;\n\n\treturn 0;\n}\n\n \nstruct fman_keygen *keygen_init(struct fman_kg_regs __iomem *keygen_regs)\n{\n\tstruct fman_keygen *keygen;\n\tu32 ar;\n\tint i;\n\n\t \n\tkeygen = kzalloc(sizeof(*keygen), GFP_KERNEL);\n\tif (!keygen)\n\t\treturn NULL;\n\n\tkeygen->keygen_regs = keygen_regs;\n\n\t \n\tiowrite32be(ENQUEUE_KG_DFLT_NIA, &keygen_regs->fmkg_gcr);\n\n\tiowrite32be(FM_EX_KG_DOUBLE_ECC | FM_EX_KG_KEYSIZE_OVERFLOW,\n\t\t    &keygen_regs->fmkg_eer);\n\n\tiowrite32be(0, &keygen_regs->fmkg_fdor);\n\tiowrite32be(0, &keygen_regs->fmkg_gdv0r);\n\tiowrite32be(0, &keygen_regs->fmkg_gdv1r);\n\n\t \n\tfor (i = 0; i < FMAN_MAX_NUM_OF_HW_PORTS; i++) {\n\t\t \n\t\tkeygen_write_sp(keygen_regs, 0xffffffff, false);\n\t\tar = build_ar_bind_scheme(i, true);\n\t\tkeygen_write_ar_wait(keygen_regs, ar);\n\n\t\t \n\t\tkeygen_write_cpp(keygen_regs, 0);\n\t\tar = build_ar_bind_cls_plan(i, true);\n\t\tkeygen_write_ar_wait(keygen_regs, ar);\n\t}\n\n\t \n\tiowrite32be(0xFFFFFFFF, &keygen_regs->fmkg_seer);\n\tiowrite32be(0xFFFFFFFF, &keygen_regs->fmkg_seeer);\n\n\t \n\tiowrite32be(ioread32be(&keygen_regs->fmkg_gcr) | FM_KG_KGGCR_EN,\n\t\t    &keygen_regs->fmkg_gcr);\n\n\treturn keygen;\n}\nEXPORT_SYMBOL(keygen_init);\n\n \nint keygen_port_hashing_init(struct fman_keygen *keygen, u8 hw_port_id,\n\t\t\t     u32 hash_base_fqid, u32 hash_size)\n{\n\tstruct keygen_scheme *scheme;\n\tu8 scheme_id;\n\tint err;\n\n\t \n\tif (hash_base_fqid == 0 || (hash_base_fqid & ~0x00FFFFFF)) {\n\t\tpr_err(\"Base FQID must be between 1 and 2^24-1\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (hash_size == 0 || (hash_size & (hash_size - 1)) != 0) {\n\t\tpr_err(\"Hash size must be power of two\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = get_free_scheme_id(keygen, &scheme_id);\n\tif (err) {\n\t\tpr_err(\"The maximum number of available Schemes has been exceeded\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tscheme = get_scheme(keygen, scheme_id);\n\tif (!scheme) {\n\t\tpr_err(\"Requested Scheme does not exist\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (scheme->used) {\n\t\tpr_err(\"The requested Scheme is already used\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemset(scheme, 0, sizeof(struct keygen_scheme));\n\n\t \n\tscheme->hw_port_id = hw_port_id;\n\tscheme->use_hashing = true;\n\tscheme->base_fqid = hash_base_fqid;\n\tscheme->hash_fqid_count = hash_size;\n\tscheme->symmetric_hash = DEFAULT_SYMMETRIC_HASH;\n\tscheme->hashShift = DEFAULT_HASH_SHIFT;\n\n\t \n\tscheme->match_vector = 0;\n\n\terr = keygen_scheme_setup(keygen, scheme_id, true);\n\tif (err != 0) {\n\t\tpr_err(\"Scheme setup failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = keygen_bind_port_to_schemes(keygen, scheme_id, true);\n\tif (err != 0) {\n\t\tpr_err(\"Binding port to schemes failed\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(keygen_port_hashing_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}