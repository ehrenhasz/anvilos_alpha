{
  "module_name": "fman_port.c",
  "hash_id": "3565a053de06da1d984f73f296f6b0250b2c187f0bd9733a782d6a9eff2d8ac6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fman/fman_port.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/of_platform.h>\n#include <linux/of_address.h>\n#include <linux/delay.h>\n#include <linux/libfdt_env.h>\n\n#include \"fman.h\"\n#include \"fman_port.h\"\n#include \"fman_sp.h\"\n#include \"fman_keygen.h\"\n\n \n#define DFLT_FQ_ID\t\t0x00FFFFFF\n\n \n#define PORT_BMI_FIFO_UNITS\t\t0x100\n\n#define MAX_PORT_FIFO_SIZE(bmi_max_fifo_size)\t\\\n\tmin((u32)bmi_max_fifo_size, (u32)1024 * FMAN_BMI_FIFO_UNITS)\n\n#define PORT_CG_MAP_NUM\t\t\t8\n#define PORT_PRS_RESULT_WORDS_NUM\t8\n#define PORT_IC_OFFSET_UNITS\t\t0x10\n\n#define MIN_EXT_BUF_SIZE\t\t64\n\n#define BMI_PORT_REGS_OFFSET\t\t\t\t0\n#define QMI_PORT_REGS_OFFSET\t\t\t\t0x400\n#define HWP_PORT_REGS_OFFSET\t\t\t\t0x800\n\n \n#define DFLT_PORT_BUFFER_PREFIX_CONTEXT_DATA_ALIGN\t\t\\\n\tDFLT_FM_SP_BUFFER_PREFIX_CONTEXT_DATA_ALIGN\n\n#define DFLT_PORT_CUT_BYTES_FROM_END\t\t4\n\n#define DFLT_PORT_ERRORS_TO_DISCARD\t\tFM_PORT_FRM_ERR_CLS_DISCARD\n#define DFLT_PORT_MAX_FRAME_LENGTH\t\t9600\n\n#define DFLT_PORT_RX_FIFO_PRI_ELEVATION_LEV(bmi_max_fifo_size)\t\\\n\tMAX_PORT_FIFO_SIZE(bmi_max_fifo_size)\n\n#define DFLT_PORT_RX_FIFO_THRESHOLD(major, bmi_max_fifo_size)\t\\\n\t(major == 6 ?\t\t\t\t\t\t\\\n\tMAX_PORT_FIFO_SIZE(bmi_max_fifo_size) :\t\t\\\n\t(MAX_PORT_FIFO_SIZE(bmi_max_fifo_size) * 3 / 4))\t\\\n\n#define DFLT_PORT_EXTRA_NUM_OF_FIFO_BUFS\t\t0\n\n \n#define QMI_DEQ_CFG_SUBPORTAL_MASK\t\t0x1f\n\n#define QMI_PORT_CFG_EN\t\t\t\t0x80000000\n#define QMI_PORT_STATUS_DEQ_FD_BSY\t\t0x20000000\n\n#define QMI_DEQ_CFG_PRI\t\t\t\t0x80000000\n#define QMI_DEQ_CFG_TYPE1\t\t\t0x10000000\n#define QMI_DEQ_CFG_TYPE2\t\t\t0x20000000\n#define QMI_DEQ_CFG_TYPE3\t\t\t0x30000000\n#define QMI_DEQ_CFG_PREFETCH_PARTIAL\t\t0x01000000\n#define QMI_DEQ_CFG_PREFETCH_FULL\t\t0x03000000\n#define QMI_DEQ_CFG_SP_MASK\t\t\t0xf\n#define QMI_DEQ_CFG_SP_SHIFT\t\t\t20\n\n#define QMI_BYTE_COUNT_LEVEL_CONTROL(_type)\t\\\n\t(_type == FMAN_PORT_TYPE_TX ? 0x1400 : 0x400)\n\n \n#define BMI_EBD_EN\t\t\t\t0x80000000\n\n#define BMI_PORT_CFG_EN\t\t\t\t0x80000000\n\n#define BMI_PORT_STATUS_BSY\t\t\t0x80000000\n\n#define BMI_DMA_ATTR_SWP_SHIFT\t\t\tFMAN_SP_DMA_ATTR_SWP_SHIFT\n#define BMI_DMA_ATTR_WRITE_OPTIMIZE\t\tFMAN_SP_DMA_ATTR_WRITE_OPTIMIZE\n\n#define BMI_RX_FIFO_PRI_ELEVATION_SHIFT\t16\n#define BMI_RX_FIFO_THRESHOLD_ETHE\t\t0x80000000\n\n#define BMI_FRAME_END_CS_IGNORE_SHIFT\t\t24\n#define BMI_FRAME_END_CS_IGNORE_MASK\t\t0x0000001f\n\n#define BMI_RX_FRAME_END_CUT_SHIFT\t\t16\n#define BMI_RX_FRAME_END_CUT_MASK\t\t0x0000001f\n\n#define BMI_IC_TO_EXT_SHIFT\t\t\tFMAN_SP_IC_TO_EXT_SHIFT\n#define BMI_IC_TO_EXT_MASK\t\t\t0x0000001f\n#define BMI_IC_FROM_INT_SHIFT\t\t\tFMAN_SP_IC_FROM_INT_SHIFT\n#define BMI_IC_FROM_INT_MASK\t\t\t0x0000000f\n#define BMI_IC_SIZE_MASK\t\t\t0x0000001f\n\n#define BMI_INT_BUF_MARG_SHIFT\t\t\t28\n#define BMI_INT_BUF_MARG_MASK\t\t\t0x0000000f\n#define BMI_EXT_BUF_MARG_START_SHIFT\t\tFMAN_SP_EXT_BUF_MARG_START_SHIFT\n#define BMI_EXT_BUF_MARG_START_MASK\t\t0x000001ff\n#define BMI_EXT_BUF_MARG_END_MASK\t\t0x000001ff\n\n#define BMI_CMD_MR_LEAC\t\t\t\t0x00200000\n#define BMI_CMD_MR_SLEAC\t\t\t0x00100000\n#define BMI_CMD_MR_MA\t\t\t\t0x00080000\n#define BMI_CMD_MR_DEAS\t\t\t\t0x00040000\n#define BMI_CMD_RX_MR_DEF\t\t\t(BMI_CMD_MR_LEAC | \\\n\t\t\t\t\t\tBMI_CMD_MR_SLEAC | \\\n\t\t\t\t\t\tBMI_CMD_MR_MA | \\\n\t\t\t\t\t\tBMI_CMD_MR_DEAS)\n#define BMI_CMD_TX_MR_DEF\t\t\t0\n\n#define BMI_CMD_ATTR_ORDER\t\t\t0x80000000\n#define BMI_CMD_ATTR_SYNC\t\t\t0x02000000\n#define BMI_CMD_ATTR_COLOR_SHIFT\t\t26\n\n#define BMI_FIFO_PIPELINE_DEPTH_SHIFT\t\t12\n#define BMI_FIFO_PIPELINE_DEPTH_MASK\t\t0x0000000f\n#define BMI_NEXT_ENG_FD_BITS_SHIFT\t\t24\n\n#define BMI_EXT_BUF_POOL_VALID\t\t\tFMAN_SP_EXT_BUF_POOL_VALID\n#define BMI_EXT_BUF_POOL_EN_COUNTER\t\tFMAN_SP_EXT_BUF_POOL_EN_COUNTER\n#define BMI_EXT_BUF_POOL_BACKUP\t\tFMAN_SP_EXT_BUF_POOL_BACKUP\n#define BMI_EXT_BUF_POOL_ID_SHIFT\t\t16\n#define BMI_EXT_BUF_POOL_ID_MASK\t\t0x003F0000\n#define BMI_POOL_DEP_NUM_OF_POOLS_SHIFT\t16\n\n#define BMI_TX_FIFO_MIN_FILL_SHIFT\t\t16\n\n#define BMI_PRIORITY_ELEVATION_LEVEL ((0x3FF + 1) * PORT_BMI_FIFO_UNITS)\n#define BMI_FIFO_THRESHOLD\t      ((0x3FF + 1) * PORT_BMI_FIFO_UNITS)\n\n#define BMI_DEQUEUE_PIPELINE_DEPTH(_type, _speed)\t\t\\\n\t((_type == FMAN_PORT_TYPE_TX && _speed == 10000) ? 4 : 1)\n\n#define RX_ERRS_TO_ENQ\t\t\t\t  \\\n\t(FM_PORT_FRM_ERR_DMA\t\t\t| \\\n\tFM_PORT_FRM_ERR_PHYSICAL\t\t| \\\n\tFM_PORT_FRM_ERR_SIZE\t\t\t| \\\n\tFM_PORT_FRM_ERR_EXTRACTION\t\t| \\\n\tFM_PORT_FRM_ERR_NO_SCHEME\t\t| \\\n\tFM_PORT_FRM_ERR_PRS_TIMEOUT\t\t| \\\n\tFM_PORT_FRM_ERR_PRS_ILL_INSTRUCT\t| \\\n\tFM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED\t| \\\n\tFM_PORT_FRM_ERR_PRS_HDR_ERR\t\t| \\\n\tFM_PORT_FRM_ERR_KEYSIZE_OVERFLOW\t| \\\n\tFM_PORT_FRM_ERR_IPRE)\n\n \n#define NIA_ORDER_RESTOR\t\t\t\t0x00800000\n#define NIA_ENG_BMI\t\t\t\t\t0x00500000\n#define NIA_ENG_QMI_ENQ\t\t\t\t\t0x00540000\n#define NIA_ENG_QMI_DEQ\t\t\t\t\t0x00580000\n#define NIA_ENG_HWP\t\t\t\t\t0x00440000\n#define NIA_ENG_HWK\t\t\t\t\t0x00480000\n#define NIA_BMI_AC_ENQ_FRAME\t\t\t\t0x00000002\n#define NIA_BMI_AC_TX_RELEASE\t\t\t\t0x000002C0\n#define NIA_BMI_AC_RELEASE\t\t\t\t0x000000C0\n#define NIA_BMI_AC_TX\t\t\t\t\t0x00000274\n#define NIA_BMI_AC_FETCH_ALL_FRAME\t\t\t0x0000020c\n\n \n#define TX_10G_PORT_BASE\t\t0x30\n#define RX_10G_PORT_BASE\t\t0x10\n\n \nstruct fman_port_rx_bmi_regs {\n\tu32 fmbm_rcfg;\t\t \n\tu32 fmbm_rst;\t\t \n\tu32 fmbm_rda;\t\t \n\tu32 fmbm_rfp;\t\t \n\tu32 fmbm_rfed;\t\t \n\tu32 fmbm_ricp;\t\t \n\tu32 fmbm_rim;\t\t \n\tu32 fmbm_rebm;\t\t \n\tu32 fmbm_rfne;\t\t \n\tu32 fmbm_rfca;\t\t \n\tu32 fmbm_rfpne;\t\t \n\tu32 fmbm_rpso;\t\t \n\tu32 fmbm_rpp;\t\t \n\tu32 fmbm_rccb;\t\t \n\tu32 fmbm_reth;\t\t \n\tu32 reserved003c[1];\t \n\tu32 fmbm_rprai[PORT_PRS_RESULT_WORDS_NUM];\n\t \n\tu32 fmbm_rfqid;\t\t \n\tu32 fmbm_refqid;\t \n\tu32 fmbm_rfsdm;\t\t \n\tu32 fmbm_rfsem;\t\t \n\tu32 fmbm_rfene;\t\t \n\tu32 reserved0074[0x2];\t \n\tu32 fmbm_rcmne;\t\t \n\tu32 reserved0080[0x20];\t \n\tu32 fmbm_ebmpi[FMAN_PORT_MAX_EXT_POOLS_NUM];\n\t \n\tu32 fmbm_acnt[FMAN_PORT_MAX_EXT_POOLS_NUM];\t \n\tu32 reserved0130[8];\t \n\tu32 fmbm_rcgm[PORT_CG_MAP_NUM];\t \n\tu32 fmbm_mpd;\t\t \n\tu32 reserved0184[0x1F];\t \n\tu32 fmbm_rstc;\t\t \n\tu32 fmbm_rfrc;\t\t \n\tu32 fmbm_rfbc;\t\t \n\tu32 fmbm_rlfc;\t\t \n\tu32 fmbm_rffc;\t\t \n\tu32 fmbm_rfdc;\t\t \n\tu32 fmbm_rfldec;\t\t \n\tu32 fmbm_rodc;\t\t \n\tu32 fmbm_rbdc;\t\t \n\tu32 fmbm_rpec;\t\t \n\tu32 reserved0224[0x16];\t \n\tu32 fmbm_rpc;\t\t \n\tu32 fmbm_rpcp;\t\t \n\tu32 fmbm_rccn;\t\t \n\tu32 fmbm_rtuc;\t\t \n\tu32 fmbm_rrquc;\t\t \n\tu32 fmbm_rduc;\t\t \n\tu32 fmbm_rfuc;\t\t \n\tu32 fmbm_rpac;\t\t \n\tu32 reserved02a0[0x18];\t \n\tu32 fmbm_rdcfg[0x3];\t \n\tu32 fmbm_rgpr;\t\t \n\tu32 reserved0310[0x3a];\n};\n\n \nstruct fman_port_tx_bmi_regs {\n\tu32 fmbm_tcfg;\t\t \n\tu32 fmbm_tst;\t\t \n\tu32 fmbm_tda;\t\t \n\tu32 fmbm_tfp;\t\t \n\tu32 fmbm_tfed;\t\t \n\tu32 fmbm_ticp;\t\t \n\tu32 fmbm_tfdne;\t\t \n\tu32 fmbm_tfca;\t\t \n\tu32 fmbm_tcfqid;\t \n\tu32 fmbm_tefqid;\t \n\tu32 fmbm_tfene;\t\t \n\tu32 fmbm_trlmts;\t \n\tu32 fmbm_trlmt;\t\t \n\tu32 reserved0034[0x0e];\t \n\tu32 fmbm_tccb;\t\t \n\tu32 fmbm_tfne;\t\t \n\tu32 fmbm_tpfcm[0x02];\n\t \n\tu32 fmbm_tcmne;\t\t \n\tu32 reserved0080[0x60];\t \n\tu32 fmbm_tstc;\t\t \n\tu32 fmbm_tfrc;\t\t \n\tu32 fmbm_tfdc;\t\t \n\tu32 fmbm_tfledc;\t \n\tu32 fmbm_tfufdc;\t \n\tu32 fmbm_tbdc;\t\t \n\tu32 reserved0218[0x1A];\t \n\tu32 fmbm_tpc;\t\t \n\tu32 fmbm_tpcp;\t\t \n\tu32 fmbm_tccn;\t\t \n\tu32 fmbm_ttuc;\t\t \n\tu32 fmbm_ttcquc;\t \n\tu32 fmbm_tduc;\t\t \n\tu32 fmbm_tfuc;\t\t \n\tu32 reserved029c[16];\t \n\tu32 fmbm_tdcfg[0x3];\t \n\tu32 fmbm_tgpr;\t\t \n\tu32 reserved0310[0x3a];  \n};\n\n \nunion fman_port_bmi_regs {\n\tstruct fman_port_rx_bmi_regs rx;\n\tstruct fman_port_tx_bmi_regs tx;\n};\n\n \nstruct fman_port_qmi_regs {\n\tu32 fmqm_pnc;\t\t \n\tu32 fmqm_pns;\t\t \n\tu32 fmqm_pnts;\t\t \n\tu32 reserved00c[4];\t \n\tu32 fmqm_pnen;\t\t \n\tu32 fmqm_pnetfc;\t\t \n\tu32 reserved024[2];\t \n\tu32 fmqm_pndn;\t\t \n\tu32 fmqm_pndc;\t\t \n\tu32 fmqm_pndtfc;\t\t \n\tu32 fmqm_pndfdc;\t\t \n\tu32 fmqm_pndcc;\t\t \n};\n\n#define HWP_HXS_COUNT 16\n#define HWP_HXS_PHE_REPORT 0x00000800\n#define HWP_HXS_PCAC_PSTAT 0x00000100\n#define HWP_HXS_PCAC_PSTOP 0x00000001\n#define HWP_HXS_TCP_OFFSET 0xA\n#define HWP_HXS_UDP_OFFSET 0xB\n#define HWP_HXS_SH_PAD_REM 0x80000000\n\nstruct fman_port_hwp_regs {\n\tstruct {\n\t\tu32 ssa;  \n\t\tu32 lcv;  \n\t} pmda[HWP_HXS_COUNT];  \n\tu32 reserved080[(0x3f8 - 0x080) / 4];  \n\tu32 fmpr_pcac;  \n};\n\n \nenum fman_port_deq_prefetch {\n\tFMAN_PORT_DEQ_NO_PREFETCH,  \n\tFMAN_PORT_DEQ_PART_PREFETCH,  \n\tFMAN_PORT_DEQ_FULL_PREFETCH  \n};\n\n \nstruct fman_port_rsrc {\n\tu32 num;  \n\tu32 extra;  \n};\n\nenum fman_port_dma_swap {\n\tFMAN_PORT_DMA_NO_SWAP,\t \n\tFMAN_PORT_DMA_SWAP_LE,\n\t \n\tFMAN_PORT_DMA_SWAP_BE\n\t \n};\n\n \nenum fman_port_color {\n\tFMAN_PORT_COLOR_GREEN,\t \n\tFMAN_PORT_COLOR_YELLOW,\t \n\tFMAN_PORT_COLOR_RED,\t\t \n\tFMAN_PORT_COLOR_OVERRIDE\t \n};\n\n \nenum fman_port_deq_type {\n\tFMAN_PORT_DEQ_BY_PRI,\n\t \n\tFMAN_PORT_DEQ_ACTIVE_FQ,\n\t \n\tFMAN_PORT_DEQ_ACTIVE_FQ_NO_ICS\n\t \n};\n\n \nstruct fman_port_bpools {\n\tu8 count;\t\t\t \n\tbool counters_enable;\t\t \n\tu8 grp_bp_depleted_num;\n\t \n\tstruct {\n\t\tu8 bpid;\t\t \n\t\tu16 size;\n\t\t \n\t\tbool is_backup;\n\t\t \n\t\tbool grp_bp_depleted;\n\t\t \n\t\tbool single_bp_depleted;\n\t\t \n\t} bpool[FMAN_PORT_MAX_EXT_POOLS_NUM];\n};\n\nstruct fman_port_cfg {\n\tu32 dflt_fqid;\n\tu32 err_fqid;\n\tu32 pcd_base_fqid;\n\tu32 pcd_fqs_count;\n\tu8 deq_sp;\n\tbool deq_high_priority;\n\tenum fman_port_deq_type deq_type;\n\tenum fman_port_deq_prefetch deq_prefetch_option;\n\tu16 deq_byte_cnt;\n\tu8 cheksum_last_bytes_ignore;\n\tu8 rx_cut_end_bytes;\n\tstruct fman_buf_pool_depletion buf_pool_depletion;\n\tstruct fman_ext_pools ext_buf_pools;\n\tu32 tx_fifo_min_level;\n\tu32 tx_fifo_low_comf_level;\n\tu32 rx_pri_elevation;\n\tu32 rx_fifo_thr;\n\tstruct fman_sp_buf_margins buf_margins;\n\tu32 int_buf_start_margin;\n\tstruct fman_sp_int_context_data_copy int_context;\n\tu32 discard_mask;\n\tu32 err_mask;\n\tstruct fman_buffer_prefix_content buffer_prefix_content;\n\tbool dont_release_buf;\n\n\tu8 rx_fd_bits;\n\tu32 tx_fifo_deq_pipeline_depth;\n\tbool errata_A006320;\n\tbool excessive_threshold_register;\n\tbool fmbm_tfne_has_features;\n\n\tenum fman_port_dma_swap dma_swap_data;\n\tenum fman_port_color color;\n};\n\nstruct fman_port_rx_pools_params {\n\tu8 num_of_pools;\n\tu16 largest_buf_size;\n};\n\nstruct fman_port_dts_params {\n\tvoid __iomem *base_addr;\t \n\tenum fman_port_type type;\t \n\tu16 speed;\t\t\t \n\tu8 id;\t\t\t\t \n\tu32 qman_channel_id;\t\t \n\tstruct fman *fman;\t\t \n};\n\nstruct fman_port {\n\tvoid *fm;\n\tstruct device *dev;\n\tstruct fman_rev_info rev_info;\n\tu8 port_id;\n\tenum fman_port_type port_type;\n\tu16 port_speed;\n\n\tunion fman_port_bmi_regs __iomem *bmi_regs;\n\tstruct fman_port_qmi_regs __iomem *qmi_regs;\n\tstruct fman_port_hwp_regs __iomem *hwp_regs;\n\n\tstruct fman_sp_buffer_offsets buffer_offsets;\n\n\tu8 internal_buf_offset;\n\tstruct fman_ext_pools ext_buf_pools;\n\n\tu16 max_frame_length;\n\tstruct fman_port_rsrc open_dmas;\n\tstruct fman_port_rsrc tasks;\n\tstruct fman_port_rsrc fifo_bufs;\n\tstruct fman_port_rx_pools_params rx_pools_params;\n\n\tstruct fman_port_cfg *cfg;\n\tstruct fman_port_dts_params dts_params;\n\n\tu8 ext_pools_num;\n\tu32 max_port_fifo_size;\n\tu32 max_num_of_ext_pools;\n\tu32 max_num_of_sub_portals;\n\tu32 bm_max_num_of_pools;\n};\n\nstatic int init_bmi_rx(struct fman_port *port)\n{\n\tstruct fman_port_rx_bmi_regs __iomem *regs = &port->bmi_regs->rx;\n\tstruct fman_port_cfg *cfg = port->cfg;\n\tu32 tmp;\n\n\t \n\ttmp = (u32)cfg->dma_swap_data << BMI_DMA_ATTR_SWP_SHIFT;\n\t \n\ttmp |= BMI_DMA_ATTR_WRITE_OPTIMIZE;\n\tiowrite32be(tmp, &regs->fmbm_rda);\n\n\t \n\ttmp = (cfg->rx_pri_elevation / PORT_BMI_FIFO_UNITS - 1) <<\n\t\tBMI_RX_FIFO_PRI_ELEVATION_SHIFT;\n\ttmp |= cfg->rx_fifo_thr / PORT_BMI_FIFO_UNITS - 1;\n\tiowrite32be(tmp, &regs->fmbm_rfp);\n\n\tif (cfg->excessive_threshold_register)\n\t\t \n\t\tiowrite32be(BMI_RX_FIFO_THRESHOLD_ETHE, &regs->fmbm_reth);\n\n\t \n\ttmp = (cfg->cheksum_last_bytes_ignore & BMI_FRAME_END_CS_IGNORE_MASK) <<\n\t\tBMI_FRAME_END_CS_IGNORE_SHIFT;\n\ttmp |= (cfg->rx_cut_end_bytes & BMI_RX_FRAME_END_CUT_MASK) <<\n\t\tBMI_RX_FRAME_END_CUT_SHIFT;\n\tif (cfg->errata_A006320)\n\t\ttmp &= 0xffe0ffff;\n\tiowrite32be(tmp, &regs->fmbm_rfed);\n\n\t \n\ttmp = ((cfg->int_context.ext_buf_offset / PORT_IC_OFFSET_UNITS) &\n\t\tBMI_IC_TO_EXT_MASK) << BMI_IC_TO_EXT_SHIFT;\n\ttmp |= ((cfg->int_context.int_context_offset / PORT_IC_OFFSET_UNITS) &\n\t\tBMI_IC_FROM_INT_MASK) << BMI_IC_FROM_INT_SHIFT;\n\ttmp |= (cfg->int_context.size / PORT_IC_OFFSET_UNITS) &\n\t\tBMI_IC_SIZE_MASK;\n\tiowrite32be(tmp, &regs->fmbm_ricp);\n\n\t \n\ttmp = ((cfg->int_buf_start_margin / PORT_IC_OFFSET_UNITS) &\n\t\tBMI_INT_BUF_MARG_MASK) << BMI_INT_BUF_MARG_SHIFT;\n\tiowrite32be(tmp, &regs->fmbm_rim);\n\n\t \n\ttmp = (cfg->buf_margins.start_margins & BMI_EXT_BUF_MARG_START_MASK) <<\n\t\tBMI_EXT_BUF_MARG_START_SHIFT;\n\ttmp |= cfg->buf_margins.end_margins & BMI_EXT_BUF_MARG_END_MASK;\n\tiowrite32be(tmp, &regs->fmbm_rebm);\n\n\t \n\ttmp = BMI_CMD_RX_MR_DEF;\n\ttmp |= BMI_CMD_ATTR_ORDER;\n\ttmp |= (u32)cfg->color << BMI_CMD_ATTR_COLOR_SHIFT;\n\t \n\ttmp |= BMI_CMD_ATTR_SYNC;\n\n\tiowrite32be(tmp, &regs->fmbm_rfca);\n\n\t \n\ttmp = (u32)cfg->rx_fd_bits << BMI_NEXT_ENG_FD_BITS_SHIFT;\n\n\ttmp |= NIA_ENG_HWP;\n\tiowrite32be(tmp, &regs->fmbm_rfne);\n\n\t \n\tiowrite32be(NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME, &regs->fmbm_rfpne);\n\n\t \n\tiowrite32be(NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR, &regs->fmbm_rfene);\n\n\t \n\tiowrite32be((cfg->dflt_fqid & DFLT_FQ_ID), &regs->fmbm_rfqid);\n\tiowrite32be((cfg->err_fqid & DFLT_FQ_ID), &regs->fmbm_refqid);\n\n\t \n\tiowrite32be(cfg->discard_mask, &regs->fmbm_rfsdm);\n\tiowrite32be(cfg->err_mask, &regs->fmbm_rfsem);\n\n\treturn 0;\n}\n\nstatic int init_bmi_tx(struct fman_port *port)\n{\n\tstruct fman_port_tx_bmi_regs __iomem *regs = &port->bmi_regs->tx;\n\tstruct fman_port_cfg *cfg = port->cfg;\n\tu32 tmp;\n\n\t \n\ttmp = 0;\n\tiowrite32be(tmp, &regs->fmbm_tcfg);\n\n\t \n\ttmp = (u32)cfg->dma_swap_data << BMI_DMA_ATTR_SWP_SHIFT;\n\tiowrite32be(tmp, &regs->fmbm_tda);\n\n\t \n\ttmp = (cfg->tx_fifo_min_level / PORT_BMI_FIFO_UNITS) <<\n\t\tBMI_TX_FIFO_MIN_FILL_SHIFT;\n\ttmp |= ((cfg->tx_fifo_deq_pipeline_depth - 1) &\n\t\tBMI_FIFO_PIPELINE_DEPTH_MASK) << BMI_FIFO_PIPELINE_DEPTH_SHIFT;\n\ttmp |= (cfg->tx_fifo_low_comf_level / PORT_BMI_FIFO_UNITS) - 1;\n\tiowrite32be(tmp, &regs->fmbm_tfp);\n\n\t \n\ttmp = (cfg->cheksum_last_bytes_ignore & BMI_FRAME_END_CS_IGNORE_MASK) <<\n\t\tBMI_FRAME_END_CS_IGNORE_SHIFT;\n\tiowrite32be(tmp, &regs->fmbm_tfed);\n\n\t \n\ttmp = ((cfg->int_context.ext_buf_offset / PORT_IC_OFFSET_UNITS) &\n\t\tBMI_IC_TO_EXT_MASK) << BMI_IC_TO_EXT_SHIFT;\n\ttmp |= ((cfg->int_context.int_context_offset / PORT_IC_OFFSET_UNITS) &\n\t\tBMI_IC_FROM_INT_MASK) << BMI_IC_FROM_INT_SHIFT;\n\ttmp |= (cfg->int_context.size / PORT_IC_OFFSET_UNITS) &\n\t\tBMI_IC_SIZE_MASK;\n\tiowrite32be(tmp, &regs->fmbm_ticp);\n\n\t \n\ttmp = BMI_CMD_TX_MR_DEF;\n\ttmp |= BMI_CMD_ATTR_ORDER;\n\ttmp |= (u32)cfg->color << BMI_CMD_ATTR_COLOR_SHIFT;\n\tiowrite32be(tmp, &regs->fmbm_tfca);\n\n\t \n\tiowrite32be(NIA_ENG_QMI_DEQ, &regs->fmbm_tfdne);\n\tiowrite32be(NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR, &regs->fmbm_tfene);\n\tif (cfg->fmbm_tfne_has_features)\n\t\tiowrite32be(!cfg->dflt_fqid ?\n\t\t\t    BMI_EBD_EN | NIA_BMI_AC_FETCH_ALL_FRAME :\n\t\t\t    NIA_BMI_AC_FETCH_ALL_FRAME, &regs->fmbm_tfne);\n\tif (!cfg->dflt_fqid && cfg->dont_release_buf) {\n\t\tiowrite32be(DFLT_FQ_ID, &regs->fmbm_tcfqid);\n\t\tiowrite32be(NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE,\n\t\t\t    &regs->fmbm_tfene);\n\t\tif (cfg->fmbm_tfne_has_features)\n\t\t\tiowrite32be(ioread32be(&regs->fmbm_tfne) & ~BMI_EBD_EN,\n\t\t\t\t    &regs->fmbm_tfne);\n\t}\n\n\t \n\tif (cfg->dflt_fqid || !cfg->dont_release_buf)\n\t\tiowrite32be(cfg->dflt_fqid & DFLT_FQ_ID, &regs->fmbm_tcfqid);\n\tiowrite32be((cfg->err_fqid & DFLT_FQ_ID), &regs->fmbm_tefqid);\n\n\treturn 0;\n}\n\nstatic int init_qmi(struct fman_port *port)\n{\n\tstruct fman_port_qmi_regs __iomem *regs = port->qmi_regs;\n\tstruct fman_port_cfg *cfg = port->cfg;\n\tu32 tmp;\n\n\t \n\tif (port->port_type == FMAN_PORT_TYPE_RX) {\n\t\t \n\t\tiowrite32be(NIA_ENG_BMI | NIA_BMI_AC_RELEASE, &regs->fmqm_pnen);\n\t\treturn 0;\n\t}\n\n\t \n\tif (port->port_type == FMAN_PORT_TYPE_TX) {\n\t\t \n\t\tiowrite32be(NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE,\n\t\t\t    &regs->fmqm_pnen);\n\t\t \n\t\tiowrite32be(NIA_ENG_BMI | NIA_BMI_AC_TX, &regs->fmqm_pndn);\n\t}\n\n\t \n\ttmp = 0;\n\tif (cfg->deq_high_priority)\n\t\ttmp |= QMI_DEQ_CFG_PRI;\n\n\tswitch (cfg->deq_type) {\n\tcase FMAN_PORT_DEQ_BY_PRI:\n\t\ttmp |= QMI_DEQ_CFG_TYPE1;\n\t\tbreak;\n\tcase FMAN_PORT_DEQ_ACTIVE_FQ:\n\t\ttmp |= QMI_DEQ_CFG_TYPE2;\n\t\tbreak;\n\tcase FMAN_PORT_DEQ_ACTIVE_FQ_NO_ICS:\n\t\ttmp |= QMI_DEQ_CFG_TYPE3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cfg->deq_prefetch_option) {\n\tcase FMAN_PORT_DEQ_NO_PREFETCH:\n\t\tbreak;\n\tcase FMAN_PORT_DEQ_PART_PREFETCH:\n\t\ttmp |= QMI_DEQ_CFG_PREFETCH_PARTIAL;\n\t\tbreak;\n\tcase FMAN_PORT_DEQ_FULL_PREFETCH:\n\t\ttmp |= QMI_DEQ_CFG_PREFETCH_FULL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttmp |= (cfg->deq_sp & QMI_DEQ_CFG_SP_MASK) << QMI_DEQ_CFG_SP_SHIFT;\n\ttmp |= cfg->deq_byte_cnt;\n\tiowrite32be(tmp, &regs->fmqm_pndc);\n\n\treturn 0;\n}\n\nstatic void stop_port_hwp(struct fman_port *port)\n{\n\tstruct fman_port_hwp_regs __iomem *regs = port->hwp_regs;\n\tint cnt = 100;\n\n\tiowrite32be(HWP_HXS_PCAC_PSTOP, &regs->fmpr_pcac);\n\n\twhile (cnt-- > 0 &&\n\t       (ioread32be(&regs->fmpr_pcac) & HWP_HXS_PCAC_PSTAT))\n\t\tudelay(10);\n\tif (!cnt)\n\t\tpr_err(\"Timeout stopping HW Parser\\n\");\n}\n\nstatic void start_port_hwp(struct fman_port *port)\n{\n\tstruct fman_port_hwp_regs __iomem *regs = port->hwp_regs;\n\tint cnt = 100;\n\n\tiowrite32be(0, &regs->fmpr_pcac);\n\n\twhile (cnt-- > 0 &&\n\t       !(ioread32be(&regs->fmpr_pcac) & HWP_HXS_PCAC_PSTAT))\n\t\tudelay(10);\n\tif (!cnt)\n\t\tpr_err(\"Timeout starting HW Parser\\n\");\n}\n\nstatic void init_hwp(struct fman_port *port)\n{\n\tstruct fman_port_hwp_regs __iomem *regs = port->hwp_regs;\n\tint i;\n\n\tstop_port_hwp(port);\n\n\tfor (i = 0; i < HWP_HXS_COUNT; i++) {\n\t\t \n\t\tiowrite32be(0x00000000, &regs->pmda[i].ssa);\n\t\tiowrite32be(0xffffffff, &regs->pmda[i].lcv);\n\t}\n\n\t \n\tiowrite32be(HWP_HXS_SH_PAD_REM, &regs->pmda[HWP_HXS_TCP_OFFSET].ssa);\n\tiowrite32be(HWP_HXS_SH_PAD_REM, &regs->pmda[HWP_HXS_UDP_OFFSET].ssa);\n\n\tstart_port_hwp(port);\n}\n\nstatic int init(struct fman_port *port)\n{\n\tint err;\n\n\t \n\tswitch (port->port_type) {\n\tcase FMAN_PORT_TYPE_RX:\n\t\terr = init_bmi_rx(port);\n\t\tif (!err)\n\t\t\tinit_hwp(port);\n\t\tbreak;\n\tcase FMAN_PORT_TYPE_TX:\n\t\terr = init_bmi_tx(port);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = init_qmi(port);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int set_bpools(const struct fman_port *port,\n\t\t      const struct fman_port_bpools *bp)\n{\n\tu32 __iomem *bp_reg, *bp_depl_reg;\n\tu32 tmp;\n\tu8 i, max_bp_num;\n\tbool grp_depl_used = false, rx_port;\n\n\tswitch (port->port_type) {\n\tcase FMAN_PORT_TYPE_RX:\n\t\tmax_bp_num = port->ext_pools_num;\n\t\trx_port = true;\n\t\tbp_reg = port->bmi_regs->rx.fmbm_ebmpi;\n\t\tbp_depl_reg = &port->bmi_regs->rx.fmbm_mpd;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (rx_port) {\n\t\t \n\t\tfor (i = 0; (i < (bp->count - 1) &&\n\t\t\t     (i < FMAN_PORT_MAX_EXT_POOLS_NUM - 1)); i++) {\n\t\t\tif (bp->bpool[i].size > bp->bpool[i + 1].size)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < bp->count; i++) {\n\t\ttmp = BMI_EXT_BUF_POOL_VALID;\n\t\ttmp |= ((u32)bp->bpool[i].bpid <<\n\t\t\tBMI_EXT_BUF_POOL_ID_SHIFT) & BMI_EXT_BUF_POOL_ID_MASK;\n\n\t\tif (rx_port) {\n\t\t\tif (bp->counters_enable)\n\t\t\t\ttmp |= BMI_EXT_BUF_POOL_EN_COUNTER;\n\n\t\t\tif (bp->bpool[i].is_backup)\n\t\t\t\ttmp |= BMI_EXT_BUF_POOL_BACKUP;\n\n\t\t\ttmp |= (u32)bp->bpool[i].size;\n\t\t}\n\n\t\tiowrite32be(tmp, &bp_reg[i]);\n\t}\n\n\t \n\tfor (i = bp->count; i < max_bp_num; i++)\n\t\tiowrite32be(0, &bp_reg[i]);\n\n\t \n\ttmp = 0;\n\tfor (i = 0; i < FMAN_PORT_MAX_EXT_POOLS_NUM; i++) {\n\t\tif (bp->bpool[i].grp_bp_depleted) {\n\t\t\tgrp_depl_used = true;\n\t\t\ttmp |= 0x80000000 >> i;\n\t\t}\n\n\t\tif (bp->bpool[i].single_bp_depleted)\n\t\t\ttmp |= 0x80 >> i;\n\t}\n\n\tif (grp_depl_used)\n\t\ttmp |= ((u32)bp->grp_bp_depleted_num - 1) <<\n\t\t    BMI_POOL_DEP_NUM_OF_POOLS_SHIFT;\n\n\tiowrite32be(tmp, bp_depl_reg);\n\treturn 0;\n}\n\nstatic bool is_init_done(struct fman_port_cfg *cfg)\n{\n\t \n\tif (!cfg)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int verify_size_of_fifo(struct fman_port *port)\n{\n\tu32 min_fifo_size_required = 0, opt_fifo_size_for_b2b = 0;\n\n\t \n\tif (port->port_type == FMAN_PORT_TYPE_TX) {\n\t\tmin_fifo_size_required = (u32)\n\t\t    (roundup(port->max_frame_length,\n\t\t\t     FMAN_BMI_FIFO_UNITS) + (3 * FMAN_BMI_FIFO_UNITS));\n\n\t\tmin_fifo_size_required +=\n\t\t    port->cfg->tx_fifo_deq_pipeline_depth *\n\t\t    FMAN_BMI_FIFO_UNITS;\n\n\t\topt_fifo_size_for_b2b = min_fifo_size_required;\n\n\t\t \n\t\tif (port->port_speed == 10000)\n\t\t\topt_fifo_size_for_b2b += 3 * FMAN_BMI_FIFO_UNITS;\n\t\telse\n\t\t\topt_fifo_size_for_b2b += 2 * FMAN_BMI_FIFO_UNITS;\n\t}\n\n\t \n\telse if (port->port_type == FMAN_PORT_TYPE_RX) {\n\t\tif (port->rev_info.major >= 6)\n\t\t\tmin_fifo_size_required = (u32)\n\t\t\t(roundup(port->max_frame_length,\n\t\t\t\t FMAN_BMI_FIFO_UNITS) +\n\t\t\t\t (5 * FMAN_BMI_FIFO_UNITS));\n\t\t\t \n\t\telse\n\t\t\tmin_fifo_size_required = (u32)\n\t\t\t(roundup(min(port->max_frame_length,\n\t\t\t\t     port->rx_pools_params.largest_buf_size),\n\t\t\t\t     FMAN_BMI_FIFO_UNITS) +\n\t\t\t\t     (7 * FMAN_BMI_FIFO_UNITS));\n\n\t\topt_fifo_size_for_b2b = min_fifo_size_required;\n\n\t\t \n\t\tif (port->port_speed == 10000)\n\t\t\topt_fifo_size_for_b2b += 8 * FMAN_BMI_FIFO_UNITS;\n\t\telse\n\t\t\topt_fifo_size_for_b2b += 3 * FMAN_BMI_FIFO_UNITS;\n\t}\n\n\tWARN_ON(min_fifo_size_required <= 0);\n\tWARN_ON(opt_fifo_size_for_b2b < min_fifo_size_required);\n\n\t \n\tif (port->fifo_bufs.num < min_fifo_size_required)\n\t\tdev_dbg(port->dev, \"%s: FIFO size should be enlarged to %d bytes\\n\",\n\t\t\t__func__, min_fifo_size_required);\n\telse if (port->fifo_bufs.num < opt_fifo_size_for_b2b)\n\t\tdev_dbg(port->dev, \"%s: For b2b processing,FIFO may be enlarged to %d bytes\\n\",\n\t\t\t__func__, opt_fifo_size_for_b2b);\n\n\treturn 0;\n}\n\nstatic int set_ext_buffer_pools(struct fman_port *port)\n{\n\tstruct fman_ext_pools *ext_buf_pools = &port->cfg->ext_buf_pools;\n\tstruct fman_buf_pool_depletion *buf_pool_depletion =\n\t&port->cfg->buf_pool_depletion;\n\tu8 ordered_array[FMAN_PORT_MAX_EXT_POOLS_NUM];\n\tu16 sizes_array[BM_MAX_NUM_OF_POOLS];\n\tint i = 0, j = 0, err;\n\tstruct fman_port_bpools bpools;\n\n\tmemset(&ordered_array, 0, sizeof(u8) * FMAN_PORT_MAX_EXT_POOLS_NUM);\n\tmemset(&sizes_array, 0, sizeof(u16) * BM_MAX_NUM_OF_POOLS);\n\tmemcpy(&port->ext_buf_pools, ext_buf_pools,\n\t       sizeof(struct fman_ext_pools));\n\n\tfman_sp_set_buf_pools_in_asc_order_of_buf_sizes(ext_buf_pools,\n\t\t\t\t\t\t\tordered_array,\n\t\t\t\t\t\t\tsizes_array);\n\n\tmemset(&bpools, 0, sizeof(struct fman_port_bpools));\n\tbpools.count = ext_buf_pools->num_of_pools_used;\n\tbpools.counters_enable = true;\n\tfor (i = 0; i < ext_buf_pools->num_of_pools_used; i++) {\n\t\tbpools.bpool[i].bpid = ordered_array[i];\n\t\tbpools.bpool[i].size = sizes_array[ordered_array[i]];\n\t}\n\n\t \n\tport->rx_pools_params.num_of_pools = ext_buf_pools->num_of_pools_used;\n\tport->rx_pools_params.largest_buf_size =\n\t    sizes_array[ordered_array[ext_buf_pools->num_of_pools_used - 1]];\n\n\t \n\tif (buf_pool_depletion->pools_grp_mode_enable) {\n\t\tbpools.grp_bp_depleted_num = buf_pool_depletion->num_of_pools;\n\t\tfor (i = 0; i < port->bm_max_num_of_pools; i++) {\n\t\t\tif (buf_pool_depletion->pools_to_consider[i]) {\n\t\t\t\tfor (j = 0; j < ext_buf_pools->\n\t\t\t\t     num_of_pools_used; j++) {\n\t\t\t\t\tif (i == ordered_array[j]) {\n\t\t\t\t\t\tbpools.bpool[j].\n\t\t\t\t\t\t    grp_bp_depleted = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (buf_pool_depletion->single_pool_mode_enable) {\n\t\tfor (i = 0; i < port->bm_max_num_of_pools; i++) {\n\t\t\tif (buf_pool_depletion->\n\t\t\t    pools_to_consider_for_single_mode[i]) {\n\t\t\t\tfor (j = 0; j < ext_buf_pools->\n\t\t\t\t     num_of_pools_used; j++) {\n\t\t\t\t\tif (i == ordered_array[j]) {\n\t\t\t\t\t\tbpools.bpool[j].\n\t\t\t\t\t\t    single_bp_depleted = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\terr = set_bpools(port, &bpools);\n\tif (err != 0) {\n\t\tdev_err(port->dev, \"%s: set_bpools() failed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int init_low_level_driver(struct fman_port *port)\n{\n\tstruct fman_port_cfg *cfg = port->cfg;\n\tu32 tmp_val;\n\n\tswitch (port->port_type) {\n\tcase FMAN_PORT_TYPE_RX:\n\t\tcfg->err_mask = (RX_ERRS_TO_ENQ & ~cfg->discard_mask);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttmp_val = (u32)((port->internal_buf_offset % OFFSET_UNITS) ?\n\t\t(port->internal_buf_offset / OFFSET_UNITS + 1) :\n\t\t(port->internal_buf_offset / OFFSET_UNITS));\n\tport->internal_buf_offset = (u8)(tmp_val * OFFSET_UNITS);\n\tport->cfg->int_buf_start_margin = port->internal_buf_offset;\n\n\tif (init(port) != 0) {\n\t\tdev_err(port->dev, \"%s: fman port initialization failed\\n\",\n\t\t\t__func__);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (port->port_type == FMAN_PORT_TYPE_TX) {\n\t\tif (!cfg->dflt_fqid && cfg->dont_release_buf) {\n\t\t\t \n\t\t\tiowrite32be(0xFFFFFF, &port->bmi_regs->tx.fmbm_tcfqid);\n\t\t\tiowrite32be(NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE,\n\t\t\t\t    &port->bmi_regs->tx.fmbm_tfene);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int fill_soc_specific_params(struct fman_port *port)\n{\n\tu32 bmi_max_fifo_size;\n\n\tbmi_max_fifo_size = fman_get_bmi_max_fifo_size(port->fm);\n\tport->max_port_fifo_size = MAX_PORT_FIFO_SIZE(bmi_max_fifo_size);\n\tport->bm_max_num_of_pools = 64;\n\n\t \n\tswitch (port->rev_info.major) {\n\tcase 2:\n\tcase 3:\n\t\tport->max_num_of_ext_pools\t\t= 4;\n\t\tport->max_num_of_sub_portals\t\t= 12;\n\t\tbreak;\n\n\tcase 6:\n\t\tport->max_num_of_ext_pools\t\t= 8;\n\t\tport->max_num_of_sub_portals\t\t= 16;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(port->dev, \"%s: Unsupported FMan version\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_dflt_fifo_deq_pipeline_depth(u8 major, enum fman_port_type type,\n\t\t\t\t\t    u16 speed)\n{\n\tswitch (type) {\n\tcase FMAN_PORT_TYPE_RX:\n\tcase FMAN_PORT_TYPE_TX:\n\t\tswitch (speed) {\n\t\tcase 10000:\n\t\t\treturn 4;\n\t\tcase 1000:\n\t\t\tif (major >= 6)\n\t\t\t\treturn 2;\n\t\t\telse\n\t\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int get_dflt_num_of_tasks(u8 major, enum fman_port_type type,\n\t\t\t\t u16 speed)\n{\n\tswitch (type) {\n\tcase FMAN_PORT_TYPE_RX:\n\tcase FMAN_PORT_TYPE_TX:\n\t\tswitch (speed) {\n\t\tcase 10000:\n\t\t\treturn 16;\n\t\tcase 1000:\n\t\t\tif (major >= 6)\n\t\t\t\treturn 4;\n\t\t\telse\n\t\t\t\treturn 3;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int get_dflt_extra_num_of_tasks(u8 major, enum fman_port_type type,\n\t\t\t\t       u16 speed)\n{\n\tswitch (type) {\n\tcase FMAN_PORT_TYPE_RX:\n\t\t \n\t\tif (major >= 6)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (speed == 10000)\n\t\t\treturn 8;\n\t\telse\n\t\t\treturn 2;\n\tcase FMAN_PORT_TYPE_TX:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int get_dflt_num_of_open_dmas(u8 major, enum fman_port_type type,\n\t\t\t\t     u16 speed)\n{\n\tint val;\n\n\tif (major >= 6) {\n\t\tswitch (type) {\n\t\tcase FMAN_PORT_TYPE_TX:\n\t\t\tif (speed == 10000)\n\t\t\t\tval = 12;\n\t\t\telse\n\t\t\t\tval = 3;\n\t\t\tbreak;\n\t\tcase FMAN_PORT_TYPE_RX:\n\t\t\tif (speed == 10000)\n\t\t\t\tval = 8;\n\t\t\telse\n\t\t\t\tval = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\tcase FMAN_PORT_TYPE_TX:\n\t\tcase FMAN_PORT_TYPE_RX:\n\t\t\tif (speed == 10000)\n\t\t\t\tval = 8;\n\t\t\telse\n\t\t\t\tval = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval = 0;\n\t\t}\n\t}\n\n\treturn val;\n}\n\nstatic int get_dflt_extra_num_of_open_dmas(u8 major, enum fman_port_type type,\n\t\t\t\t\t   u16 speed)\n{\n\t \n\tif (major >= 6)\n\t\treturn 0;\n\n\t \n\tswitch (type) {\n\tcase FMAN_PORT_TYPE_RX:\n\tcase FMAN_PORT_TYPE_TX:\n\t\tif (speed == 10000)\n\t\t\treturn 8;\n\t\telse\n\t\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int get_dflt_num_of_fifo_bufs(u8 major, enum fman_port_type type,\n\t\t\t\t     u16 speed)\n{\n\tint val;\n\n\tif (major >= 6) {\n\t\tswitch (type) {\n\t\tcase FMAN_PORT_TYPE_TX:\n\t\t\tif (speed == 10000)\n\t\t\t\tval = 64;\n\t\t\telse\n\t\t\t\tval = 50;\n\t\t\tbreak;\n\t\tcase FMAN_PORT_TYPE_RX:\n\t\t\tif (speed == 10000)\n\t\t\t\tval = 96;\n\t\t\telse\n\t\t\t\tval = 50;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval = 0;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\tcase FMAN_PORT_TYPE_TX:\n\t\t\tif (speed == 10000)\n\t\t\t\tval = 48;\n\t\t\telse\n\t\t\t\tval = 44;\n\t\t\tbreak;\n\t\tcase FMAN_PORT_TYPE_RX:\n\t\t\tif (speed == 10000)\n\t\t\t\tval = 48;\n\t\t\telse\n\t\t\t\tval = 45;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval = 0;\n\t\t}\n\t}\n\n\treturn val;\n}\n\nstatic void set_dflt_cfg(struct fman_port *port,\n\t\t\t struct fman_port_params *port_params)\n{\n\tstruct fman_port_cfg *cfg = port->cfg;\n\n\tcfg->dma_swap_data = FMAN_PORT_DMA_NO_SWAP;\n\tcfg->color = FMAN_PORT_COLOR_GREEN;\n\tcfg->rx_cut_end_bytes = DFLT_PORT_CUT_BYTES_FROM_END;\n\tcfg->rx_pri_elevation = BMI_PRIORITY_ELEVATION_LEVEL;\n\tcfg->rx_fifo_thr = BMI_FIFO_THRESHOLD;\n\tcfg->tx_fifo_low_comf_level = (5 * 1024);\n\tcfg->deq_type = FMAN_PORT_DEQ_BY_PRI;\n\tcfg->deq_prefetch_option = FMAN_PORT_DEQ_FULL_PREFETCH;\n\tcfg->tx_fifo_deq_pipeline_depth =\n\t\tBMI_DEQUEUE_PIPELINE_DEPTH(port->port_type, port->port_speed);\n\tcfg->deq_byte_cnt = QMI_BYTE_COUNT_LEVEL_CONTROL(port->port_type);\n\n\tcfg->rx_pri_elevation =\n\t\tDFLT_PORT_RX_FIFO_PRI_ELEVATION_LEV(port->max_port_fifo_size);\n\tport->cfg->rx_fifo_thr =\n\t\tDFLT_PORT_RX_FIFO_THRESHOLD(port->rev_info.major,\n\t\t\t\t\t    port->max_port_fifo_size);\n\n\tif ((port->rev_info.major == 6) &&\n\t    ((port->rev_info.minor == 0) || (port->rev_info.minor == 3)))\n\t\tcfg->errata_A006320 = true;\n\n\t \n\tif (port->rev_info.major < 6)\n\t\tcfg->excessive_threshold_register = true;\n\telse\n\t\tcfg->fmbm_tfne_has_features = true;\n\n\tcfg->buffer_prefix_content.data_align =\n\t\tDFLT_PORT_BUFFER_PREFIX_CONTEXT_DATA_ALIGN;\n}\n\nstatic void set_rx_dflt_cfg(struct fman_port *port,\n\t\t\t    struct fman_port_params *port_params)\n{\n\tport->cfg->discard_mask = DFLT_PORT_ERRORS_TO_DISCARD;\n\n\tmemcpy(&port->cfg->ext_buf_pools,\n\t       &port_params->specific_params.rx_params.ext_buf_pools,\n\t       sizeof(struct fman_ext_pools));\n\tport->cfg->err_fqid =\n\t\tport_params->specific_params.rx_params.err_fqid;\n\tport->cfg->dflt_fqid =\n\t\tport_params->specific_params.rx_params.dflt_fqid;\n\tport->cfg->pcd_base_fqid =\n\t\tport_params->specific_params.rx_params.pcd_base_fqid;\n\tport->cfg->pcd_fqs_count =\n\t\tport_params->specific_params.rx_params.pcd_fqs_count;\n}\n\nstatic void set_tx_dflt_cfg(struct fman_port *port,\n\t\t\t    struct fman_port_params *port_params,\n\t\t\t    struct fman_port_dts_params *dts_params)\n{\n\tport->cfg->tx_fifo_deq_pipeline_depth =\n\t\tget_dflt_fifo_deq_pipeline_depth(port->rev_info.major,\n\t\t\t\t\t\t port->port_type,\n\t\t\t\t\t\t port->port_speed);\n\tport->cfg->err_fqid =\n\t\tport_params->specific_params.non_rx_params.err_fqid;\n\tport->cfg->deq_sp =\n\t\t(u8)(dts_params->qman_channel_id & QMI_DEQ_CFG_SUBPORTAL_MASK);\n\tport->cfg->dflt_fqid =\n\t\tport_params->specific_params.non_rx_params.dflt_fqid;\n\tport->cfg->deq_high_priority = true;\n}\n\n \nint fman_port_config(struct fman_port *port, struct fman_port_params *params)\n{\n\tvoid __iomem *base_addr = port->dts_params.base_addr;\n\tint err;\n\n\t \n\tport->cfg = kzalloc(sizeof(*port->cfg), GFP_KERNEL);\n\tif (!port->cfg)\n\t\treturn -EINVAL;\n\n\t \n\tport->port_type = port->dts_params.type;\n\tport->port_speed = port->dts_params.speed;\n\tport->port_id = port->dts_params.id;\n\tport->fm = port->dts_params.fman;\n\tport->ext_pools_num = (u8)8;\n\n\t \n\tfman_get_revision(port->fm, &port->rev_info);\n\n\terr = fill_soc_specific_params(port);\n\tif (err)\n\t\tgoto err_port_cfg;\n\n\tswitch (port->port_type) {\n\tcase FMAN_PORT_TYPE_RX:\n\t\tset_rx_dflt_cfg(port, params);\n\t\tfallthrough;\n\tcase FMAN_PORT_TYPE_TX:\n\t\tset_tx_dflt_cfg(port, params, &port->dts_params);\n\t\tfallthrough;\n\tdefault:\n\t\tset_dflt_cfg(port, params);\n\t}\n\n\t \n\t \n\tport->bmi_regs = base_addr + BMI_PORT_REGS_OFFSET;\n\tport->qmi_regs = base_addr + QMI_PORT_REGS_OFFSET;\n\tport->hwp_regs = base_addr + HWP_PORT_REGS_OFFSET;\n\n\tport->max_frame_length = DFLT_PORT_MAX_FRAME_LENGTH;\n\t \n\n\tport->fifo_bufs.num =\n\tget_dflt_num_of_fifo_bufs(port->rev_info.major, port->port_type,\n\t\t\t\t  port->port_speed) * FMAN_BMI_FIFO_UNITS;\n\tport->fifo_bufs.extra =\n\tDFLT_PORT_EXTRA_NUM_OF_FIFO_BUFS * FMAN_BMI_FIFO_UNITS;\n\n\tport->open_dmas.num =\n\tget_dflt_num_of_open_dmas(port->rev_info.major,\n\t\t\t\t  port->port_type, port->port_speed);\n\tport->open_dmas.extra =\n\tget_dflt_extra_num_of_open_dmas(port->rev_info.major,\n\t\t\t\t\tport->port_type, port->port_speed);\n\tport->tasks.num =\n\tget_dflt_num_of_tasks(port->rev_info.major,\n\t\t\t      port->port_type, port->port_speed);\n\tport->tasks.extra =\n\tget_dflt_extra_num_of_tasks(port->rev_info.major,\n\t\t\t\t    port->port_type, port->port_speed);\n\n\t \n\tif ((port->rev_info.major == 6) && (port->rev_info.minor == 0) &&\n\t    (((port->port_type == FMAN_PORT_TYPE_TX) &&\n\t    (port->port_speed == 1000)))) {\n\t\tport->open_dmas.num = 16;\n\t\tport->open_dmas.extra = 0;\n\t}\n\n\tif (port->rev_info.major >= 6 &&\n\t    port->port_type == FMAN_PORT_TYPE_TX &&\n\t    port->port_speed == 1000) {\n\t\t \n\t\tu32 reg;\n\n\t\treg = 0x00001013;\n\t\tiowrite32be(reg, &port->bmi_regs->tx.fmbm_tfp);\n\t}\n\n\treturn 0;\n\nerr_port_cfg:\n\tkfree(port->cfg);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(fman_port_config);\n\n \nvoid fman_port_use_kg_hash(struct fman_port *port, bool enable)\n{\n\tif (enable)\n\t\t \n\t\tiowrite32be(NIA_ENG_HWK, &port->bmi_regs->rx.fmbm_rfpne);\n\telse\n\t\t \n\t\tiowrite32be(NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME,\n\t\t\t    &port->bmi_regs->rx.fmbm_rfpne);\n}\nEXPORT_SYMBOL(fman_port_use_kg_hash);\n\n \nint fman_port_init(struct fman_port *port)\n{\n\tstruct fman_port_init_params params;\n\tstruct fman_keygen *keygen;\n\tstruct fman_port_cfg *cfg;\n\tint err;\n\n\tif (is_init_done(port->cfg))\n\t\treturn -EINVAL;\n\n\terr = fman_sp_build_buffer_struct(&port->cfg->int_context,\n\t\t\t\t\t  &port->cfg->buffer_prefix_content,\n\t\t\t\t\t  &port->cfg->buf_margins,\n\t\t\t\t\t  &port->buffer_offsets,\n\t\t\t\t\t  &port->internal_buf_offset);\n\tif (err)\n\t\treturn err;\n\n\tcfg = port->cfg;\n\n\tif (port->port_type == FMAN_PORT_TYPE_RX) {\n\t\t \n\t\t \n\t\terr = set_ext_buffer_pools(port);\n\t\tif (err)\n\t\t\treturn err;\n\t\t \n\t\tif (cfg->buf_margins.start_margins + MIN_EXT_BUF_SIZE +\n\t\t    cfg->buf_margins.end_margins >\n\t\t    port->rx_pools_params.largest_buf_size) {\n\t\t\tdev_err(port->dev, \"%s: buf_margins.start_margins (%d) + minimum buf size (64) + buf_margins.end_margins (%d) is larger than maximum external buffer size (%d)\\n\",\n\t\t\t\t__func__, cfg->buf_margins.start_margins,\n\t\t\t\tcfg->buf_margins.end_margins,\n\t\t\t\tport->rx_pools_params.largest_buf_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tmemset(&params, 0, sizeof(params));\n\tparams.port_id = port->port_id;\n\tparams.port_type = port->port_type;\n\tparams.port_speed = port->port_speed;\n\tparams.num_of_tasks = (u8)port->tasks.num;\n\tparams.num_of_extra_tasks = (u8)port->tasks.extra;\n\tparams.num_of_open_dmas = (u8)port->open_dmas.num;\n\tparams.num_of_extra_open_dmas = (u8)port->open_dmas.extra;\n\n\tif (port->fifo_bufs.num) {\n\t\terr = verify_size_of_fifo(port);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tparams.size_of_fifo = port->fifo_bufs.num;\n\tparams.extra_size_of_fifo = port->fifo_bufs.extra;\n\tparams.deq_pipeline_depth = port->cfg->tx_fifo_deq_pipeline_depth;\n\tparams.max_frame_length = port->max_frame_length;\n\n\terr = fman_set_port_params(port->fm, &params);\n\tif (err)\n\t\treturn err;\n\n\terr = init_low_level_driver(port);\n\tif (err)\n\t\treturn err;\n\n\tif (port->cfg->pcd_fqs_count) {\n\t\tkeygen = port->dts_params.fman->keygen;\n\t\terr = keygen_port_hashing_init(keygen, port->port_id,\n\t\t\t\t\t       port->cfg->pcd_base_fqid,\n\t\t\t\t\t       port->cfg->pcd_fqs_count);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfman_port_use_kg_hash(port, true);\n\t}\n\n\tkfree(port->cfg);\n\tport->cfg = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fman_port_init);\n\n \nint fman_port_cfg_buf_prefix_content(struct fman_port *port,\n\t\t\t\t     struct fman_buffer_prefix_content *\n\t\t\t\t     buffer_prefix_content)\n{\n\tif (is_init_done(port->cfg))\n\t\treturn -EINVAL;\n\n\tmemcpy(&port->cfg->buffer_prefix_content,\n\t       buffer_prefix_content,\n\t       sizeof(struct fman_buffer_prefix_content));\n\t \n\tif (!port->cfg->buffer_prefix_content.data_align)\n\t\tport->cfg->buffer_prefix_content.data_align =\n\t\tDFLT_PORT_BUFFER_PREFIX_CONTEXT_DATA_ALIGN;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fman_port_cfg_buf_prefix_content);\n\n \nint fman_port_disable(struct fman_port *port)\n{\n\tu32 __iomem *bmi_cfg_reg, *bmi_status_reg;\n\tu32 tmp;\n\tbool rx_port, failure = false;\n\tint count;\n\n\tif (!is_init_done(port->cfg))\n\t\treturn -EINVAL;\n\n\tswitch (port->port_type) {\n\tcase FMAN_PORT_TYPE_RX:\n\t\tbmi_cfg_reg = &port->bmi_regs->rx.fmbm_rcfg;\n\t\tbmi_status_reg = &port->bmi_regs->rx.fmbm_rst;\n\t\trx_port = true;\n\t\tbreak;\n\tcase FMAN_PORT_TYPE_TX:\n\t\tbmi_cfg_reg = &port->bmi_regs->tx.fmbm_tcfg;\n\t\tbmi_status_reg = &port->bmi_regs->tx.fmbm_tst;\n\t\trx_port = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!rx_port) {\n\t\ttmp = ioread32be(&port->qmi_regs->fmqm_pnc) & ~QMI_PORT_CFG_EN;\n\t\tiowrite32be(tmp, &port->qmi_regs->fmqm_pnc);\n\n\t\t \n\t\tcount = 100;\n\t\tdo {\n\t\t\tudelay(10);\n\t\t\ttmp = ioread32be(&port->qmi_regs->fmqm_pns);\n\t\t} while ((tmp & QMI_PORT_STATUS_DEQ_FD_BSY) && --count);\n\n\t\tif (count == 0) {\n\t\t\t \n\t\t\tfailure = true;\n\t\t}\n\t}\n\n\t \n\ttmp = ioread32be(bmi_cfg_reg) & ~BMI_PORT_CFG_EN;\n\tiowrite32be(tmp, bmi_cfg_reg);\n\n\t \n\tcount = 500;\n\tdo {\n\t\tudelay(10);\n\t\ttmp = ioread32be(bmi_status_reg);\n\t} while ((tmp & BMI_PORT_STATUS_BSY) && --count);\n\n\tif (count == 0) {\n\t\t \n\t\tfailure = true;\n\t}\n\n\tif (failure)\n\t\tdev_dbg(port->dev, \"%s: FMan Port[%d]: BMI or QMI is Busy. Port forced down\\n\",\n\t\t\t__func__,  port->port_id);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fman_port_disable);\n\n \nint fman_port_enable(struct fman_port *port)\n{\n\tu32 __iomem *bmi_cfg_reg;\n\tu32 tmp;\n\tbool rx_port;\n\n\tif (!is_init_done(port->cfg))\n\t\treturn -EINVAL;\n\n\tswitch (port->port_type) {\n\tcase FMAN_PORT_TYPE_RX:\n\t\tbmi_cfg_reg = &port->bmi_regs->rx.fmbm_rcfg;\n\t\trx_port = true;\n\t\tbreak;\n\tcase FMAN_PORT_TYPE_TX:\n\t\tbmi_cfg_reg = &port->bmi_regs->tx.fmbm_tcfg;\n\t\trx_port = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!rx_port) {\n\t\ttmp = ioread32be(&port->qmi_regs->fmqm_pnc) | QMI_PORT_CFG_EN;\n\t\tiowrite32be(tmp, &port->qmi_regs->fmqm_pnc);\n\t}\n\n\t \n\ttmp = ioread32be(bmi_cfg_reg) | BMI_PORT_CFG_EN;\n\tiowrite32be(tmp, bmi_cfg_reg);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fman_port_enable);\n\n \nstruct fman_port *fman_port_bind(struct device *dev)\n{\n\treturn (struct fman_port *)(dev_get_drvdata(get_device(dev)));\n}\nEXPORT_SYMBOL(fman_port_bind);\n\n \nu32 fman_port_get_qman_channel_id(struct fman_port *port)\n{\n\treturn port->dts_params.qman_channel_id;\n}\nEXPORT_SYMBOL(fman_port_get_qman_channel_id);\n\n \nstruct device *fman_port_get_device(struct fman_port *port)\n{\n\treturn port->dev;\n}\nEXPORT_SYMBOL(fman_port_get_device);\n\nint fman_port_get_hash_result_offset(struct fman_port *port, u32 *offset)\n{\n\tif (port->buffer_offsets.hash_result_offset == ILLEGAL_BASE)\n\t\treturn -EINVAL;\n\n\t*offset = port->buffer_offsets.hash_result_offset;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fman_port_get_hash_result_offset);\n\nint fman_port_get_tstamp(struct fman_port *port, const void *data, u64 *tstamp)\n{\n\tif (port->buffer_offsets.time_stamp_offset == ILLEGAL_BASE)\n\t\treturn -EINVAL;\n\n\t*tstamp = be64_to_cpu(*(__be64 *)(data +\n\t\t\tport->buffer_offsets.time_stamp_offset));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fman_port_get_tstamp);\n\nstatic int fman_port_probe(struct platform_device *of_dev)\n{\n\tstruct fman_port *port;\n\tstruct fman *fman;\n\tstruct device_node *fm_node, *port_node;\n\tstruct platform_device *fm_pdev;\n\tstruct resource res;\n\tstruct resource *dev_res;\n\tu32 val;\n\tint err = 0, lenp;\n\tenum fman_port_type port_type;\n\tu16 port_speed;\n\tu8 port_id;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tport->dev = &of_dev->dev;\n\n\tport_node = of_node_get(of_dev->dev.of_node);\n\n\t \n\tfm_node = of_get_parent(port_node);\n\tif (!fm_node) {\n\t\tdev_err(port->dev, \"%s: of_get_parent() failed\\n\", __func__);\n\t\terr = -ENODEV;\n\t\tgoto return_err;\n\t}\n\n\tfm_pdev = of_find_device_by_node(fm_node);\n\tof_node_put(fm_node);\n\tif (!fm_pdev) {\n\t\terr = -EINVAL;\n\t\tgoto return_err;\n\t}\n\n\tfman = dev_get_drvdata(&fm_pdev->dev);\n\tif (!fman) {\n\t\terr = -EINVAL;\n\t\tgoto put_device;\n\t}\n\n\terr = of_property_read_u32(port_node, \"cell-index\", &val);\n\tif (err) {\n\t\tdev_err(port->dev, \"%s: reading cell-index for %pOF failed\\n\",\n\t\t\t__func__, port_node);\n\t\terr = -EINVAL;\n\t\tgoto put_device;\n\t}\n\tport_id = (u8)val;\n\tport->dts_params.id = port_id;\n\n\tif (of_device_is_compatible(port_node, \"fsl,fman-v3-port-tx\")) {\n\t\tport_type = FMAN_PORT_TYPE_TX;\n\t\tport_speed = 1000;\n\t\tif (of_find_property(port_node, \"fsl,fman-10g-port\", &lenp))\n\t\t\tport_speed = 10000;\n\n\t} else if (of_device_is_compatible(port_node, \"fsl,fman-v2-port-tx\")) {\n\t\tif (port_id >= TX_10G_PORT_BASE)\n\t\t\tport_speed = 10000;\n\t\telse\n\t\t\tport_speed = 1000;\n\t\tport_type = FMAN_PORT_TYPE_TX;\n\n\t} else if (of_device_is_compatible(port_node, \"fsl,fman-v3-port-rx\")) {\n\t\tport_type = FMAN_PORT_TYPE_RX;\n\t\tport_speed = 1000;\n\t\tif (of_find_property(port_node, \"fsl,fman-10g-port\", &lenp))\n\t\t\tport_speed = 10000;\n\n\t} else if (of_device_is_compatible(port_node, \"fsl,fman-v2-port-rx\")) {\n\t\tif (port_id >= RX_10G_PORT_BASE)\n\t\t\tport_speed = 10000;\n\t\telse\n\t\t\tport_speed = 1000;\n\t\tport_type = FMAN_PORT_TYPE_RX;\n\n\t}  else {\n\t\tdev_err(port->dev, \"%s: Illegal port type\\n\", __func__);\n\t\terr = -EINVAL;\n\t\tgoto put_device;\n\t}\n\n\tport->dts_params.type = port_type;\n\tport->dts_params.speed = port_speed;\n\n\tif (port_type == FMAN_PORT_TYPE_TX) {\n\t\tu32 qman_channel_id;\n\n\t\tqman_channel_id = fman_get_qman_channel_id(fman, port_id);\n\t\tif (qman_channel_id == 0) {\n\t\t\tdev_err(port->dev, \"%s: incorrect qman-channel-id\\n\",\n\t\t\t\t__func__);\n\t\t\terr = -EINVAL;\n\t\t\tgoto put_device;\n\t\t}\n\t\tport->dts_params.qman_channel_id = qman_channel_id;\n\t}\n\n\terr = of_address_to_resource(port_node, 0, &res);\n\tif (err < 0) {\n\t\tdev_err(port->dev, \"%s: of_address_to_resource() failed\\n\",\n\t\t\t__func__);\n\t\terr = -ENOMEM;\n\t\tgoto put_device;\n\t}\n\n\tport->dts_params.fman = fman;\n\n\tof_node_put(port_node);\n\n\tdev_res = __devm_request_region(port->dev, &res, res.start,\n\t\t\t\t\tresource_size(&res), \"fman-port\");\n\tif (!dev_res) {\n\t\tdev_err(port->dev, \"%s: __devm_request_region() failed\\n\",\n\t\t\t__func__);\n\t\terr = -EINVAL;\n\t\tgoto free_port;\n\t}\n\n\tport->dts_params.base_addr = devm_ioremap(port->dev, res.start,\n\t\t\t\t\t\t  resource_size(&res));\n\tif (!port->dts_params.base_addr)\n\t\tdev_err(port->dev, \"%s: devm_ioremap() failed\\n\", __func__);\n\n\tdev_set_drvdata(&of_dev->dev, port);\n\n\treturn 0;\n\nput_device:\n\tput_device(&fm_pdev->dev);\nreturn_err:\n\tof_node_put(port_node);\nfree_port:\n\tkfree(port);\n\treturn err;\n}\n\nstatic const struct of_device_id fman_port_match[] = {\n\t{.compatible = \"fsl,fman-v3-port-rx\"},\n\t{.compatible = \"fsl,fman-v2-port-rx\"},\n\t{.compatible = \"fsl,fman-v3-port-tx\"},\n\t{.compatible = \"fsl,fman-v2-port-tx\"},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, fman_port_match);\n\nstatic struct platform_driver fman_port_driver = {\n\t.driver = {\n\t\t.name = \"fsl-fman-port\",\n\t\t.of_match_table = fman_port_match,\n\t},\n\t.probe = fman_port_probe,\n};\n\nstatic int __init fman_port_load(void)\n{\n\tint err;\n\n\tpr_debug(\"FSL DPAA FMan driver\\n\");\n\n\terr = platform_driver_register(&fman_port_driver);\n\tif (err < 0)\n\t\tpr_err(\"Error, platform_driver_register() = %d\\n\", err);\n\n\treturn err;\n}\nmodule_init(fman_port_load);\n\nstatic void __exit fman_port_unload(void)\n{\n\tplatform_driver_unregister(&fman_port_driver);\n}\nmodule_exit(fman_port_unload);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"Freescale DPAA Frame Manager Port driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}