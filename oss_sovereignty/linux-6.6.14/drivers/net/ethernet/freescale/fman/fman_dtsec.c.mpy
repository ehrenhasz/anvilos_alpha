{
  "module_name": "fman_dtsec.c",
  "hash_id": "5f31d267079178664adbdca735493ccba5ce8a979955281bb81a7206659160a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fman/fman_dtsec.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"fman_dtsec.h\"\n#include \"fman.h\"\n#include \"mac.h\"\n\n#include <linux/slab.h>\n#include <linux/bitrev.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/phy.h>\n#include <linux/crc32.h>\n#include <linux/of_mdio.h>\n#include <linux/mii.h>\n#include <linux/netdevice.h>\n\n \n#define MII_TBICON\t\t0x11\n\n \n#define TBICON_SOFT_RESET\t0x8000\t \n#define TBICON_DISABLE_RX_DIS\t0x2000\t \n#define TBICON_DISABLE_TX_DIS\t0x1000\t \n#define TBICON_AN_SENSE\t\t0x0100\t \n#define TBICON_CLK_SELECT\t0x0020\t \n#define TBICON_MI_MODE\t\t0x0010\t \n\n \n#define DTSEC_IMASK_BREN\t0x80000000\n#define DTSEC_IMASK_RXCEN\t0x40000000\n#define DTSEC_IMASK_MSROEN\t0x04000000\n#define DTSEC_IMASK_GTSCEN\t0x02000000\n#define DTSEC_IMASK_BTEN\t0x01000000\n#define DTSEC_IMASK_TXCEN\t0x00800000\n#define DTSEC_IMASK_TXEEN\t0x00400000\n#define DTSEC_IMASK_LCEN\t0x00040000\n#define DTSEC_IMASK_CRLEN\t0x00020000\n#define DTSEC_IMASK_XFUNEN\t0x00010000\n#define DTSEC_IMASK_ABRTEN\t0x00008000\n#define DTSEC_IMASK_IFERREN\t0x00004000\n#define DTSEC_IMASK_MAGEN\t0x00000800\n#define DTSEC_IMASK_MMRDEN\t0x00000400\n#define DTSEC_IMASK_MMWREN\t0x00000200\n#define DTSEC_IMASK_GRSCEN\t0x00000100\n#define DTSEC_IMASK_TDPEEN\t0x00000002\n#define DTSEC_IMASK_RDPEEN\t0x00000001\n\n#define DTSEC_EVENTS_MASK\t\t\\\n\t ((u32)(DTSEC_IMASK_BREN    |\t\\\n\t\tDTSEC_IMASK_RXCEN   |\t\\\n\t\tDTSEC_IMASK_BTEN    |\t\\\n\t\tDTSEC_IMASK_TXCEN   |\t\\\n\t\tDTSEC_IMASK_TXEEN   |\t\\\n\t\tDTSEC_IMASK_ABRTEN  |\t\\\n\t\tDTSEC_IMASK_LCEN    |\t\\\n\t\tDTSEC_IMASK_CRLEN   |\t\\\n\t\tDTSEC_IMASK_XFUNEN  |\t\\\n\t\tDTSEC_IMASK_IFERREN |\t\\\n\t\tDTSEC_IMASK_MAGEN   |\t\\\n\t\tDTSEC_IMASK_TDPEEN  |\t\\\n\t\tDTSEC_IMASK_RDPEEN))\n\n \n#define TMR_PEMASK_TSREEN\t0x00010000\n#define TMR_PEVENT_TSRE\t\t0x00010000\n\n \n#define MAC_GROUP_ADDRESS\t0x0000010000000000ULL\n\n \n#define DEFAULT_HALFDUP_RETRANSMIT\t\t0xf\n#define DEFAULT_HALFDUP_COLL_WINDOW\t\t0x37\n#define DEFAULT_TX_PAUSE_TIME\t\t\t0xf000\n#define DEFAULT_RX_PREPEND\t\t\t0\n#define DEFAULT_PREAMBLE_LEN\t\t\t7\n#define DEFAULT_TX_PAUSE_TIME_EXTD\t\t0\n#define DEFAULT_NON_BACK_TO_BACK_IPG1\t\t0x40\n#define DEFAULT_NON_BACK_TO_BACK_IPG2\t\t0x60\n#define DEFAULT_MIN_IFG_ENFORCEMENT\t\t0x50\n#define DEFAULT_BACK_TO_BACK_IPG\t\t0x60\n#define DEFAULT_MAXIMUM_FRAME\t\t\t0x600\n\n \n#define DTSEC_ID2_INT_REDUCED_OFF\t0x00010000\n\n#define DTSEC_ECNTRL_GMIIM\t\t0x00000040\n#define DTSEC_ECNTRL_TBIM\t\t0x00000020\n#define DTSEC_ECNTRL_RPM\t\t0x00000010\n#define DTSEC_ECNTRL_R100M\t\t0x00000008\n#define DTSEC_ECNTRL_RMM\t\t0x00000004\n#define DTSEC_ECNTRL_SGMIIM\t\t0x00000002\n#define DTSEC_ECNTRL_QSGMIIM\t\t0x00000001\n\n#define TCTRL_TTSE\t\t\t0x00000040\n#define TCTRL_GTS\t\t\t0x00000020\n\n#define RCTRL_PAL_MASK\t\t\t0x001f0000\n#define RCTRL_PAL_SHIFT\t\t\t16\n#define RCTRL_GHTX\t\t\t0x00000400\n#define RCTRL_RTSE\t\t\t0x00000040\n#define RCTRL_GRS\t\t\t0x00000020\n#define RCTRL_MPROM\t\t\t0x00000008\n#define RCTRL_RSF\t\t\t0x00000004\n#define RCTRL_UPROM\t\t\t0x00000001\n\n#define MACCFG1_SOFT_RESET\t\t0x80000000\n#define MACCFG1_RX_FLOW\t\t\t0x00000020\n#define MACCFG1_TX_FLOW\t\t\t0x00000010\n#define MACCFG1_TX_EN\t\t\t0x00000001\n#define MACCFG1_RX_EN\t\t\t0x00000004\n\n#define MACCFG2_NIBBLE_MODE\t\t0x00000100\n#define MACCFG2_BYTE_MODE\t\t0x00000200\n#define MACCFG2_PAD_CRC_EN\t\t0x00000004\n#define MACCFG2_FULL_DUPLEX\t\t0x00000001\n#define MACCFG2_PREAMBLE_LENGTH_MASK\t0x0000f000\n#define MACCFG2_PREAMBLE_LENGTH_SHIFT\t12\n\n#define IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT\t24\n#define IPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT\t16\n#define IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT\t8\n\n#define IPGIFG_NON_BACK_TO_BACK_IPG_1\t0x7F000000\n#define IPGIFG_NON_BACK_TO_BACK_IPG_2\t0x007F0000\n#define IPGIFG_MIN_IFG_ENFORCEMENT\t0x0000FF00\n#define IPGIFG_BACK_TO_BACK_IPG\t0x0000007F\n\n#define HAFDUP_EXCESS_DEFER\t\t\t0x00010000\n#define HAFDUP_COLLISION_WINDOW\t\t0x000003ff\n#define HAFDUP_RETRANSMISSION_MAX_SHIFT\t12\n#define HAFDUP_RETRANSMISSION_MAX\t\t0x0000f000\n\n#define NUM_OF_HASH_REGS\t8\t \n\n#define PTV_PTE_MASK\t\t0xffff0000\n#define PTV_PT_MASK\t\t0x0000ffff\n#define PTV_PTE_SHIFT\t\t16\n\n#define MAX_PACKET_ALIGNMENT\t\t31\n#define MAX_INTER_PACKET_GAP\t\t0x7f\n#define MAX_RETRANSMISSION\t\t0x0f\n#define MAX_COLLISION_WINDOW\t\t0x03ff\n\n \n#define DTSEC_HASH_TABLE_SIZE\t\t256\n \n#define EXTENDED_HASH_TABLE_SIZE\t512\n\n \nstruct dtsec_regs {\n\t \n\tu32 tsec_id;\t\t \n\tu32 tsec_id2;\t\t \n\tu32 ievent;\t\t \n\tu32 imask;\t\t \n\tu32 reserved0010[1];\n\tu32 ecntrl;\t\t \n\tu32 ptv;\t\t \n\tu32 tbipa;\t\t \n\tu32 tmr_ctrl;\t\t \n\tu32 tmr_pevent;\t\t \n\tu32 tmr_pemask;\t\t \n\tu32 reserved002c[5];\n\tu32 tctrl;\t\t \n\tu32 reserved0044[3];\n\tu32 rctrl;\t\t \n\tu32 reserved0054[11];\n\tu32 igaddr[8];\t\t \n\tu32 gaddr[8];\t\t \n\tu32 reserved00c0[16];\n\tu32 maccfg1;\t\t \n\tu32 maccfg2;\t\t \n\tu32 ipgifg;\t\t \n\tu32 hafdup;\t\t \n\tu32 maxfrm;\t\t \n\tu32 reserved0114[10];\n\tu32 ifstat;\t\t \n\tu32 macstnaddr1;\t \n\tu32 macstnaddr2;\t \n\tstruct {\n\t\tu32 exact_match1;\t \n\t\tu32 exact_match2;\t \n\t} macaddr[15];\t\t \n\tu32 reserved01c0[16];\n\tu32 tr64;\t \n\tu32 tr127;\t \n\tu32 tr255;\t \n\tu32 tr511;\t \n\tu32 tr1k;\t \n\tu32 trmax;\t \n\tu32 trmgv;\n\t \n\tu32 rbyt;\t \n\tu32 rpkt;\t \n\tu32 rfcs;\t \n\tu32 rmca;\t \n\tu32 rbca;\t \n\tu32 rxcf;\t \n\tu32 rxpf;\t \n\tu32 rxuo;\t \n\tu32 raln;\t \n\tu32 rflr;\t \n\tu32 rcde;\t \n\tu32 rcse;\t \n\tu32 rund;\t \n\tu32 rovr;\t \n\tu32 rfrg;\t \n\tu32 rjbr;\t \n\tu32 rdrp;\t \n\tu32 tbyt;\t \n\tu32 tpkt;\t \n\tu32 tmca;\t \n\tu32 tbca;\t \n\tu32 txpf;\t \n\tu32 tdfr;\t \n\tu32 tedf;\t \n\tu32 tscl;\t \n\tu32 tmcl;\t \n\tu32 tlcl;\t \n\tu32 txcl;\t \n\tu32 tncl;\t \n\tu32 reserved0290[1];\n\tu32 tdrp;\t \n\tu32 tjbr;\t \n\tu32 tfcs;\t \n\tu32 txcf;\t \n\tu32 tovr;\t \n\tu32 tund;\t \n\tu32 tfrg;\t \n\tu32 car1;\t \n\tu32 car2;\t \n\tu32 cam1;\t \n\tu32 cam2;\t \n\tu32 reserved02c0[848];\n};\n\n \nstruct dtsec_cfg {\n\tu16 halfdup_retransmit;\n\tu16 halfdup_coll_window;\n\tbool tx_pad_crc;\n\tu16 tx_pause_time;\n\tbool ptp_tsu_en;\n\tbool ptp_exception_en;\n\tu32 preamble_len;\n\tu32 rx_prepend;\n\tu16 tx_pause_time_extd;\n\tu16 maximum_frame;\n\tu32 non_back_to_back_ipg1;\n\tu32 non_back_to_back_ipg2;\n\tu32 min_ifg_enforcement;\n\tu32 back_to_back_ipg;\n};\n\nstruct fman_mac {\n\t \n\tstruct dtsec_regs __iomem *regs;\n\t \n\tu64 addr;\n\t \n\tphy_interface_t phy_if;\n\tu16 max_speed;\n\tstruct mac_device *dev_id;  \n\tfman_mac_exception_cb *exception_cb;\n\tfman_mac_exception_cb *event_cb;\n\t \n\tu8 num_of_ind_addr_in_regs;\n\t \n\tstruct eth_hash_t *multicast_addr_hash;\n\t \n\tstruct eth_hash_t *unicast_addr_hash;\n\tu8 mac_id;\n\tu32 exceptions;\n\tbool ptp_tsu_enabled;\n\tbool en_tsu_err_exception;\n\tstruct dtsec_cfg *dtsec_drv_param;\n\tvoid *fm;\n\tstruct fman_rev_info fm_rev_info;\n\tbool basex_if;\n\tstruct mdio_device *tbidev;\n\tstruct phylink_pcs pcs;\n};\n\nstatic void set_dflts(struct dtsec_cfg *cfg)\n{\n\tcfg->halfdup_retransmit = DEFAULT_HALFDUP_RETRANSMIT;\n\tcfg->halfdup_coll_window = DEFAULT_HALFDUP_COLL_WINDOW;\n\tcfg->tx_pad_crc = true;\n\tcfg->tx_pause_time = DEFAULT_TX_PAUSE_TIME;\n\t \n\tcfg->rx_prepend = DEFAULT_RX_PREPEND;\n\tcfg->ptp_tsu_en = true;\n\tcfg->ptp_exception_en = true;\n\tcfg->preamble_len = DEFAULT_PREAMBLE_LEN;\n\tcfg->tx_pause_time_extd = DEFAULT_TX_PAUSE_TIME_EXTD;\n\tcfg->non_back_to_back_ipg1 = DEFAULT_NON_BACK_TO_BACK_IPG1;\n\tcfg->non_back_to_back_ipg2 = DEFAULT_NON_BACK_TO_BACK_IPG2;\n\tcfg->min_ifg_enforcement = DEFAULT_MIN_IFG_ENFORCEMENT;\n\tcfg->back_to_back_ipg = DEFAULT_BACK_TO_BACK_IPG;\n\tcfg->maximum_frame = DEFAULT_MAXIMUM_FRAME;\n}\n\nstatic void set_mac_address(struct dtsec_regs __iomem *regs, const u8 *adr)\n{\n\tu32 tmp;\n\n\ttmp = (u32)((adr[5] << 24) |\n\t\t    (adr[4] << 16) | (adr[3] << 8) | adr[2]);\n\tiowrite32be(tmp, &regs->macstnaddr1);\n\n\ttmp = (u32)((adr[1] << 24) | (adr[0] << 16));\n\tiowrite32be(tmp, &regs->macstnaddr2);\n}\n\nstatic int init(struct dtsec_regs __iomem *regs, struct dtsec_cfg *cfg,\n\t\tphy_interface_t iface, u16 iface_speed, u64 addr,\n\t\tu32 exception_mask, u8 tbi_addr)\n{\n\tenet_addr_t eth_addr;\n\tu32 tmp = 0;\n\tint i;\n\n\t \n\tiowrite32be(MACCFG1_SOFT_RESET, &regs->maccfg1);\n\tiowrite32be(0, &regs->maccfg1);\n\n\tif (cfg->tx_pause_time)\n\t\ttmp |= cfg->tx_pause_time;\n\tif (cfg->tx_pause_time_extd)\n\t\ttmp |= cfg->tx_pause_time_extd << PTV_PTE_SHIFT;\n\tiowrite32be(tmp, &regs->ptv);\n\n\ttmp = 0;\n\ttmp |= (cfg->rx_prepend << RCTRL_PAL_SHIFT) & RCTRL_PAL_MASK;\n\t \n\ttmp |= RCTRL_RSF;\n\n\tiowrite32be(tmp, &regs->rctrl);\n\n\t \n\tiowrite32be(tbi_addr, &regs->tbipa);\n\n\tiowrite32be(0, &regs->tmr_ctrl);\n\n\tif (cfg->ptp_tsu_en) {\n\t\ttmp = 0;\n\t\ttmp |= TMR_PEVENT_TSRE;\n\t\tiowrite32be(tmp, &regs->tmr_pevent);\n\n\t\tif (cfg->ptp_exception_en) {\n\t\t\ttmp = 0;\n\t\t\ttmp |= TMR_PEMASK_TSREEN;\n\t\t\tiowrite32be(tmp, &regs->tmr_pemask);\n\t\t}\n\t}\n\n\ttmp = 0;\n\ttmp |= MACCFG1_RX_FLOW;\n\ttmp |= MACCFG1_TX_FLOW;\n\tiowrite32be(tmp, &regs->maccfg1);\n\n\ttmp = 0;\n\n\ttmp |= (cfg->preamble_len << MACCFG2_PREAMBLE_LENGTH_SHIFT) &\n\t\tMACCFG2_PREAMBLE_LENGTH_MASK;\n\tif (cfg->tx_pad_crc)\n\t\ttmp |= MACCFG2_PAD_CRC_EN;\n\tiowrite32be(tmp, &regs->maccfg2);\n\n\ttmp = (((cfg->non_back_to_back_ipg1 <<\n\t\t IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT)\n\t\t& IPGIFG_NON_BACK_TO_BACK_IPG_1)\n\t       | ((cfg->non_back_to_back_ipg2 <<\n\t\t   IPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT)\n\t\t & IPGIFG_NON_BACK_TO_BACK_IPG_2)\n\t       | ((cfg->min_ifg_enforcement << IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT)\n\t\t & IPGIFG_MIN_IFG_ENFORCEMENT)\n\t       | (cfg->back_to_back_ipg & IPGIFG_BACK_TO_BACK_IPG));\n\tiowrite32be(tmp, &regs->ipgifg);\n\n\ttmp = 0;\n\ttmp |= HAFDUP_EXCESS_DEFER;\n\ttmp |= ((cfg->halfdup_retransmit << HAFDUP_RETRANSMISSION_MAX_SHIFT)\n\t\t& HAFDUP_RETRANSMISSION_MAX);\n\ttmp |= (cfg->halfdup_coll_window & HAFDUP_COLLISION_WINDOW);\n\n\tiowrite32be(tmp, &regs->hafdup);\n\n\t \n\tiowrite32be(cfg->maximum_frame, &regs->maxfrm);\n\n\tiowrite32be(0xffffffff, &regs->cam1);\n\tiowrite32be(0xffffffff, &regs->cam2);\n\n\tiowrite32be(exception_mask, &regs->imask);\n\n\tiowrite32be(0xffffffff, &regs->ievent);\n\n\tif (addr) {\n\t\tMAKE_ENET_ADDR_FROM_UINT64(addr, eth_addr);\n\t\tset_mac_address(regs, (const u8 *)eth_addr);\n\t}\n\n\t \n\tfor (i = 0; i < NUM_OF_HASH_REGS; i++) {\n\t\t \n\t\tiowrite32be(0, &regs->igaddr[i]);\n\t\t \n\t\tiowrite32be(0, &regs->gaddr[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic void set_bucket(struct dtsec_regs __iomem *regs, int bucket,\n\t\t       bool enable)\n{\n\tint reg_idx = (bucket >> 5) & 0xf;\n\tint bit_idx = bucket & 0x1f;\n\tu32 bit_mask = 0x80000000 >> bit_idx;\n\tu32 __iomem *reg;\n\n\tif (reg_idx > 7)\n\t\treg = &regs->gaddr[reg_idx - 8];\n\telse\n\t\treg = &regs->igaddr[reg_idx];\n\n\tif (enable)\n\t\tiowrite32be(ioread32be(reg) | bit_mask, reg);\n\telse\n\t\tiowrite32be(ioread32be(reg) & (~bit_mask), reg);\n}\n\nstatic int check_init_parameters(struct fman_mac *dtsec)\n{\n\tif ((dtsec->dtsec_drv_param)->rx_prepend >\n\t    MAX_PACKET_ALIGNMENT) {\n\t\tpr_err(\"packetAlignmentPadding can't be > than %d\\n\",\n\t\t       MAX_PACKET_ALIGNMENT);\n\t\treturn -EINVAL;\n\t}\n\tif (((dtsec->dtsec_drv_param)->non_back_to_back_ipg1 >\n\t     MAX_INTER_PACKET_GAP) ||\n\t    ((dtsec->dtsec_drv_param)->non_back_to_back_ipg2 >\n\t     MAX_INTER_PACKET_GAP) ||\n\t     ((dtsec->dtsec_drv_param)->back_to_back_ipg >\n\t      MAX_INTER_PACKET_GAP)) {\n\t\tpr_err(\"Inter packet gap can't be greater than %d\\n\",\n\t\t       MAX_INTER_PACKET_GAP);\n\t\treturn -EINVAL;\n\t}\n\tif ((dtsec->dtsec_drv_param)->halfdup_retransmit >\n\t    MAX_RETRANSMISSION) {\n\t\tpr_err(\"maxRetransmission can't be greater than %d\\n\",\n\t\t       MAX_RETRANSMISSION);\n\t\treturn -EINVAL;\n\t}\n\tif ((dtsec->dtsec_drv_param)->halfdup_coll_window >\n\t    MAX_COLLISION_WINDOW) {\n\t\tpr_err(\"collisionWindow can't be greater than %d\\n\",\n\t\t       MAX_COLLISION_WINDOW);\n\t\treturn -EINVAL;\n\t \n\t}\n\tif (!dtsec->exception_cb) {\n\t\tpr_err(\"uninitialized exception_cb\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!dtsec->event_cb) {\n\t\tpr_err(\"uninitialized event_cb\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_exception_flag(enum fman_mac_exceptions exception)\n{\n\tu32 bit_mask;\n\n\tswitch (exception) {\n\tcase FM_MAC_EX_1G_BAB_RX:\n\t\tbit_mask = DTSEC_IMASK_BREN;\n\t\tbreak;\n\tcase FM_MAC_EX_1G_RX_CTL:\n\t\tbit_mask = DTSEC_IMASK_RXCEN;\n\t\tbreak;\n\tcase FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET:\n\t\tbit_mask = DTSEC_IMASK_GTSCEN;\n\t\tbreak;\n\tcase FM_MAC_EX_1G_BAB_TX:\n\t\tbit_mask = DTSEC_IMASK_BTEN;\n\t\tbreak;\n\tcase FM_MAC_EX_1G_TX_CTL:\n\t\tbit_mask = DTSEC_IMASK_TXCEN;\n\t\tbreak;\n\tcase FM_MAC_EX_1G_TX_ERR:\n\t\tbit_mask = DTSEC_IMASK_TXEEN;\n\t\tbreak;\n\tcase FM_MAC_EX_1G_LATE_COL:\n\t\tbit_mask = DTSEC_IMASK_LCEN;\n\t\tbreak;\n\tcase FM_MAC_EX_1G_COL_RET_LMT:\n\t\tbit_mask = DTSEC_IMASK_CRLEN;\n\t\tbreak;\n\tcase FM_MAC_EX_1G_TX_FIFO_UNDRN:\n\t\tbit_mask = DTSEC_IMASK_XFUNEN;\n\t\tbreak;\n\tcase FM_MAC_EX_1G_MAG_PCKT:\n\t\tbit_mask = DTSEC_IMASK_MAGEN;\n\t\tbreak;\n\tcase FM_MAC_EX_1G_MII_MNG_RD_COMPLET:\n\t\tbit_mask = DTSEC_IMASK_MMRDEN;\n\t\tbreak;\n\tcase FM_MAC_EX_1G_MII_MNG_WR_COMPLET:\n\t\tbit_mask = DTSEC_IMASK_MMWREN;\n\t\tbreak;\n\tcase FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET:\n\t\tbit_mask = DTSEC_IMASK_GRSCEN;\n\t\tbreak;\n\tcase FM_MAC_EX_1G_DATA_ERR:\n\t\tbit_mask = DTSEC_IMASK_TDPEEN;\n\t\tbreak;\n\tcase FM_MAC_EX_1G_RX_MIB_CNT_OVFL:\n\t\tbit_mask = DTSEC_IMASK_MSROEN;\n\t\tbreak;\n\tdefault:\n\t\tbit_mask = 0;\n\t\tbreak;\n\t}\n\n\treturn bit_mask;\n}\n\nstatic u16 dtsec_get_max_frame_length(struct fman_mac *dtsec)\n{\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\n\treturn (u16)ioread32be(&regs->maxfrm);\n}\n\nstatic void dtsec_isr(void *handle)\n{\n\tstruct fman_mac *dtsec = (struct fman_mac *)handle;\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\tu32 event;\n\n\t \n\tevent = ioread32be(&regs->ievent) &\n\t\t(u32)(~(DTSEC_IMASK_MMRDEN | DTSEC_IMASK_MMWREN));\n\n\tevent &= ioread32be(&regs->imask);\n\n\tiowrite32be(event, &regs->ievent);\n\n\tif (event & DTSEC_IMASK_BREN)\n\t\tdtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_BAB_RX);\n\tif (event & DTSEC_IMASK_RXCEN)\n\t\tdtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_RX_CTL);\n\tif (event & DTSEC_IMASK_GTSCEN)\n\t\tdtsec->exception_cb(dtsec->dev_id,\n\t\t\t\t    FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET);\n\tif (event & DTSEC_IMASK_BTEN)\n\t\tdtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_BAB_TX);\n\tif (event & DTSEC_IMASK_TXCEN)\n\t\tdtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_TX_CTL);\n\tif (event & DTSEC_IMASK_TXEEN)\n\t\tdtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_TX_ERR);\n\tif (event & DTSEC_IMASK_LCEN)\n\t\tdtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_LATE_COL);\n\tif (event & DTSEC_IMASK_CRLEN)\n\t\tdtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_COL_RET_LMT);\n\tif (event & DTSEC_IMASK_XFUNEN) {\n\t\t \n\t\t \n\t\tif (dtsec->fm_rev_info.major == 2) {\n\t\t\tu32 tpkt1, tmp_reg1, tpkt2, tmp_reg2, i;\n\t\t\t \n\t\t\ttpkt1 = ioread32be(&regs->tpkt);\n\n\t\t\t \n\t\t\ttmp_reg1 = ioread32be(&regs->reserved02c0[27]);\n\n\t\t\t \n\t\t\tif ((tmp_reg1 & 0x007F0000) !=\n\t\t\t\t(tmp_reg1 & 0x0000007F)) {\n\t\t\t\t \n\t\t\t\tusleep_range((u32)(min\n\t\t\t\t\t(dtsec_get_max_frame_length(dtsec) *\n\t\t\t\t\t16 / 1000, 1)), (u32)\n\t\t\t\t\t(min(dtsec_get_max_frame_length\n\t\t\t\t\t(dtsec) * 16 / 1000, 1) + 1));\n\t\t\t}\n\n\t\t\t \n\t\t\ttpkt2 = ioread32be(&regs->tpkt);\n\t\t\ttmp_reg2 = ioread32be(&regs->reserved02c0[27]);\n\n\t\t\t \n\t\t\tif ((tpkt1 == tpkt2) && ((tmp_reg1 & 0x007F0000) ==\n\t\t\t\t(tmp_reg2 & 0x007F0000))) {\n\t\t\t\t \n\n\t\t\t\t \n\n\t\t\t\tiowrite32be(ioread32be(&regs->rctrl) |\n\t\t\t\t\t    RCTRL_GRS, &regs->rctrl);\n\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\t\tif (ioread32be(&regs->ievent) &\n\t\t\t\t\t    DTSEC_IMASK_GRSCEN)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tudelay(1);\n\t\t\t\t}\n\t\t\t\tif (ioread32be(&regs->ievent) &\n\t\t\t\t    DTSEC_IMASK_GRSCEN)\n\t\t\t\t\tiowrite32be(DTSEC_IMASK_GRSCEN,\n\t\t\t\t\t\t    &regs->ievent);\n\t\t\t\telse\n\t\t\t\t\tpr_debug(\"Rx lockup due to Tx lockup\\n\");\n\n\t\t\t\t \n\t\t\t\tfman_reset_mac(dtsec->fm, dtsec->mac_id);\n\n\t\t\t\t \n\t\t\t\tudelay(1);\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t}\n\t\t}\n\n\t\tdtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_TX_FIFO_UNDRN);\n\t}\n\tif (event & DTSEC_IMASK_MAGEN)\n\t\tdtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_MAG_PCKT);\n\tif (event & DTSEC_IMASK_GRSCEN)\n\t\tdtsec->exception_cb(dtsec->dev_id,\n\t\t\t\t    FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET);\n\tif (event & DTSEC_IMASK_TDPEEN)\n\t\tdtsec->exception_cb(dtsec->dev_id, FM_MAC_EX_1G_DATA_ERR);\n\tif (event & DTSEC_IMASK_RDPEEN)\n\t\tdtsec->exception_cb(dtsec->dev_id, FM_MAC_1G_RX_DATA_ERR);\n\n\t \n\tWARN_ON(event & DTSEC_IMASK_ABRTEN);\n\tWARN_ON(event & DTSEC_IMASK_IFERREN);\n}\n\nstatic void dtsec_1588_isr(void *handle)\n{\n\tstruct fman_mac *dtsec = (struct fman_mac *)handle;\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\tu32 event;\n\n\tif (dtsec->ptp_tsu_enabled) {\n\t\tevent = ioread32be(&regs->tmr_pevent);\n\t\tevent &= ioread32be(&regs->tmr_pemask);\n\n\t\tif (event) {\n\t\t\tiowrite32be(event, &regs->tmr_pevent);\n\t\t\tWARN_ON(event & TMR_PEVENT_TSRE);\n\t\t\tdtsec->exception_cb(dtsec->dev_id,\n\t\t\t\t\t    FM_MAC_EX_1G_1588_TS_RX_ERR);\n\t\t}\n\t}\n}\n\nstatic void free_init_resources(struct fman_mac *dtsec)\n{\n\tfman_unregister_intr(dtsec->fm, FMAN_MOD_MAC, dtsec->mac_id,\n\t\t\t     FMAN_INTR_TYPE_ERR);\n\tfman_unregister_intr(dtsec->fm, FMAN_MOD_MAC, dtsec->mac_id,\n\t\t\t     FMAN_INTR_TYPE_NORMAL);\n\n\t \n\tfree_hash_table(dtsec->multicast_addr_hash);\n\tdtsec->multicast_addr_hash = NULL;\n\n\t \n\tfree_hash_table(dtsec->unicast_addr_hash);\n\tdtsec->unicast_addr_hash = NULL;\n}\n\nstatic struct fman_mac *pcs_to_dtsec(struct phylink_pcs *pcs)\n{\n\treturn container_of(pcs, struct fman_mac, pcs);\n}\n\nstatic void dtsec_pcs_get_state(struct phylink_pcs *pcs,\n\t\t\t\tstruct phylink_link_state *state)\n{\n\tstruct fman_mac *dtsec = pcs_to_dtsec(pcs);\n\n\tphylink_mii_c22_pcs_get_state(dtsec->tbidev, state);\n}\n\nstatic int dtsec_pcs_config(struct phylink_pcs *pcs, unsigned int neg_mode,\n\t\t\t    phy_interface_t interface,\n\t\t\t    const unsigned long *advertising,\n\t\t\t    bool permit_pause_to_mac)\n{\n\tstruct fman_mac *dtsec = pcs_to_dtsec(pcs);\n\n\treturn phylink_mii_c22_pcs_config(dtsec->tbidev, interface,\n\t\t\t\t\t  advertising, neg_mode);\n}\n\nstatic void dtsec_pcs_an_restart(struct phylink_pcs *pcs)\n{\n\tstruct fman_mac *dtsec = pcs_to_dtsec(pcs);\n\n\tphylink_mii_c22_pcs_an_restart(dtsec->tbidev);\n}\n\nstatic const struct phylink_pcs_ops dtsec_pcs_ops = {\n\t.pcs_get_state = dtsec_pcs_get_state,\n\t.pcs_config = dtsec_pcs_config,\n\t.pcs_an_restart = dtsec_pcs_an_restart,\n};\n\nstatic void graceful_start(struct fman_mac *dtsec)\n{\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\n\tiowrite32be(ioread32be(&regs->tctrl) & ~TCTRL_GTS, &regs->tctrl);\n\tiowrite32be(ioread32be(&regs->rctrl) & ~RCTRL_GRS, &regs->rctrl);\n}\n\nstatic void graceful_stop(struct fman_mac *dtsec)\n{\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\tu32 tmp;\n\n\t \n\ttmp = ioread32be(&regs->rctrl) | RCTRL_GRS;\n\tiowrite32be(tmp, &regs->rctrl);\n\n\tif (dtsec->fm_rev_info.major == 2) {\n\t\t \n\t\tusleep_range(100, 200);\n\t} else {\n\t\t \n\t\tusleep_range(10, 50);\n\t}\n\n\t \n\tif (dtsec->fm_rev_info.major == 2) {\n\t\t \n\t\tpr_debug(\"GTS not supported due to DTSEC_A004 Errata.\\n\");\n\t} else {\n\t\ttmp = ioread32be(&regs->tctrl) | TCTRL_GTS;\n\t\tiowrite32be(tmp, &regs->tctrl);\n\n\t\t \n\t\tusleep_range(10, 50);\n\t}\n}\n\nstatic int dtsec_enable(struct fman_mac *dtsec)\n{\n\treturn 0;\n}\n\nstatic void dtsec_disable(struct fman_mac *dtsec)\n{\n}\n\nstatic int dtsec_set_tx_pause_frames(struct fman_mac *dtsec,\n\t\t\t\t     u8 __maybe_unused priority,\n\t\t\t\t     u16 pause_time,\n\t\t\t\t     u16 __maybe_unused thresh_time)\n{\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\tu32 ptv = 0;\n\n\tif (pause_time) {\n\t\t \n\t\tif (dtsec->fm_rev_info.major == 2 && pause_time <= 320) {\n\t\t\tpr_warn(\"pause-time: %d illegal.Should be > 320\\n\",\n\t\t\t\tpause_time);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tptv = ioread32be(&regs->ptv);\n\t\tptv &= PTV_PTE_MASK;\n\t\tptv |= pause_time & PTV_PT_MASK;\n\t\tiowrite32be(ptv, &regs->ptv);\n\n\t\t \n\t\tiowrite32be(ioread32be(&regs->maccfg1) | MACCFG1_TX_FLOW,\n\t\t\t    &regs->maccfg1);\n\t} else\n\t\tiowrite32be(ioread32be(&regs->maccfg1) & ~MACCFG1_TX_FLOW,\n\t\t\t    &regs->maccfg1);\n\n\treturn 0;\n}\n\nstatic int dtsec_accept_rx_pause_frames(struct fman_mac *dtsec, bool en)\n{\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\tu32 tmp;\n\n\ttmp = ioread32be(&regs->maccfg1);\n\tif (en)\n\t\ttmp |= MACCFG1_RX_FLOW;\n\telse\n\t\ttmp &= ~MACCFG1_RX_FLOW;\n\tiowrite32be(tmp, &regs->maccfg1);\n\n\treturn 0;\n}\n\nstatic struct phylink_pcs *dtsec_select_pcs(struct phylink_config *config,\n\t\t\t\t\t    phy_interface_t iface)\n{\n\tstruct fman_mac *dtsec = fman_config_to_mac(config)->fman_mac;\n\n\tswitch (iface) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\treturn &dtsec->pcs;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic void dtsec_mac_config(struct phylink_config *config, unsigned int mode,\n\t\t\t     const struct phylink_link_state *state)\n{\n\tstruct mac_device *mac_dev = fman_config_to_mac(config);\n\tstruct dtsec_regs __iomem *regs = mac_dev->fman_mac->regs;\n\tu32 tmp;\n\n\tswitch (state->interface) {\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\ttmp = DTSEC_ECNTRL_RMM;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\ttmp = DTSEC_ECNTRL_GMIIM | DTSEC_ECNTRL_RPM;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\ttmp = DTSEC_ECNTRL_TBIM | DTSEC_ECNTRL_SGMIIM;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(mac_dev->dev, \"cannot configure dTSEC for %s\\n\",\n\t\t\t phy_modes(state->interface));\n\t\treturn;\n\t}\n\n\tiowrite32be(tmp, &regs->ecntrl);\n}\n\nstatic void dtsec_link_up(struct phylink_config *config, struct phy_device *phy,\n\t\t\t  unsigned int mode, phy_interface_t interface,\n\t\t\t  int speed, int duplex, bool tx_pause, bool rx_pause)\n{\n\tstruct mac_device *mac_dev = fman_config_to_mac(config);\n\tstruct fman_mac *dtsec = mac_dev->fman_mac;\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\tu16 pause_time = tx_pause ? FSL_FM_PAUSE_TIME_ENABLE :\n\t\t\t FSL_FM_PAUSE_TIME_DISABLE;\n\tu32 tmp;\n\n\tdtsec_set_tx_pause_frames(dtsec, 0, pause_time, 0);\n\tdtsec_accept_rx_pause_frames(dtsec, rx_pause);\n\n\ttmp = ioread32be(&regs->ecntrl);\n\tif (speed == SPEED_100)\n\t\ttmp |= DTSEC_ECNTRL_R100M;\n\telse\n\t\ttmp &= ~DTSEC_ECNTRL_R100M;\n\tiowrite32be(tmp, &regs->ecntrl);\n\n\ttmp = ioread32be(&regs->maccfg2);\n\ttmp &= ~(MACCFG2_NIBBLE_MODE | MACCFG2_BYTE_MODE | MACCFG2_FULL_DUPLEX);\n\tif (speed >= SPEED_1000)\n\t\ttmp |= MACCFG2_BYTE_MODE;\n\telse\n\t\ttmp |= MACCFG2_NIBBLE_MODE;\n\n\tif (duplex == DUPLEX_FULL)\n\t\ttmp |= MACCFG2_FULL_DUPLEX;\n\n\tiowrite32be(tmp, &regs->maccfg2);\n\n\tmac_dev->update_speed(mac_dev, speed);\n\n\t \n\ttmp = ioread32be(&regs->maccfg1);\n\ttmp |= MACCFG1_RX_EN | MACCFG1_TX_EN;\n\tiowrite32be(tmp, &regs->maccfg1);\n\n\t \n\tgraceful_start(dtsec);\n}\n\nstatic void dtsec_link_down(struct phylink_config *config, unsigned int mode,\n\t\t\t    phy_interface_t interface)\n{\n\tstruct fman_mac *dtsec = fman_config_to_mac(config)->fman_mac;\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\tu32 tmp;\n\n\t \n\tgraceful_stop(dtsec);\n\n\ttmp = ioread32be(&regs->maccfg1);\n\ttmp &= ~(MACCFG1_RX_EN | MACCFG1_TX_EN);\n\tiowrite32be(tmp, &regs->maccfg1);\n}\n\nstatic const struct phylink_mac_ops dtsec_mac_ops = {\n\t.mac_select_pcs = dtsec_select_pcs,\n\t.mac_config = dtsec_mac_config,\n\t.mac_link_up = dtsec_link_up,\n\t.mac_link_down = dtsec_link_down,\n};\n\nstatic int dtsec_modify_mac_address(struct fman_mac *dtsec,\n\t\t\t\t    const enet_addr_t *enet_addr)\n{\n\tgraceful_stop(dtsec);\n\n\t \n\tdtsec->addr = ENET_ADDR_TO_UINT64(*enet_addr);\n\tset_mac_address(dtsec->regs, (const u8 *)(*enet_addr));\n\n\tgraceful_start(dtsec);\n\n\treturn 0;\n}\n\nstatic int dtsec_add_hash_mac_address(struct fman_mac *dtsec,\n\t\t\t\t      enet_addr_t *eth_addr)\n{\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\tstruct eth_hash_entry *hash_entry;\n\tu64 addr;\n\ts32 bucket;\n\tu32 crc = 0xFFFFFFFF;\n\tbool mcast, ghtx;\n\n\taddr = ENET_ADDR_TO_UINT64(*eth_addr);\n\n\tghtx = (bool)((ioread32be(&regs->rctrl) & RCTRL_GHTX) ? true : false);\n\tmcast = (bool)((addr & MAC_GROUP_ADDRESS) ? true : false);\n\n\t \n\tif (ghtx && !mcast) {\n\t\tpr_err(\"Could not compute hash bucket\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcrc = crc32_le(crc, (u8 *)eth_addr, ETH_ALEN);\n\tcrc = bitrev32(crc);\n\n\t \n\n\tif (ghtx) {\n\t\tbucket = (s32)((crc >> 23) & 0x1ff);\n\t} else {\n\t\tbucket = (s32)((crc >> 24) & 0xff);\n\t\t \n\t\tif (mcast)\n\t\t\tbucket += 0x100;\n\t}\n\n\tset_bucket(dtsec->regs, bucket, true);\n\n\t \n\thash_entry = kmalloc(sizeof(*hash_entry), GFP_ATOMIC);\n\tif (!hash_entry)\n\t\treturn -ENOMEM;\n\thash_entry->addr = addr;\n\tINIT_LIST_HEAD(&hash_entry->node);\n\n\tif (addr & MAC_GROUP_ADDRESS)\n\t\t \n\t\tlist_add_tail(&hash_entry->node,\n\t\t\t      &dtsec->multicast_addr_hash->lsts[bucket]);\n\telse\n\t\tlist_add_tail(&hash_entry->node,\n\t\t\t      &dtsec->unicast_addr_hash->lsts[bucket]);\n\n\treturn 0;\n}\n\nstatic int dtsec_set_allmulti(struct fman_mac *dtsec, bool enable)\n{\n\tu32 tmp;\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\n\ttmp = ioread32be(&regs->rctrl);\n\tif (enable)\n\t\ttmp |= RCTRL_MPROM;\n\telse\n\t\ttmp &= ~RCTRL_MPROM;\n\n\tiowrite32be(tmp, &regs->rctrl);\n\n\treturn 0;\n}\n\nstatic int dtsec_set_tstamp(struct fman_mac *dtsec, bool enable)\n{\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\tu32 rctrl, tctrl;\n\n\trctrl = ioread32be(&regs->rctrl);\n\ttctrl = ioread32be(&regs->tctrl);\n\n\tif (enable) {\n\t\trctrl |= RCTRL_RTSE;\n\t\ttctrl |= TCTRL_TTSE;\n\t} else {\n\t\trctrl &= ~RCTRL_RTSE;\n\t\ttctrl &= ~TCTRL_TTSE;\n\t}\n\n\tiowrite32be(rctrl, &regs->rctrl);\n\tiowrite32be(tctrl, &regs->tctrl);\n\n\treturn 0;\n}\n\nstatic int dtsec_del_hash_mac_address(struct fman_mac *dtsec,\n\t\t\t\t      enet_addr_t *eth_addr)\n{\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\tstruct list_head *pos;\n\tstruct eth_hash_entry *hash_entry = NULL;\n\tu64 addr;\n\ts32 bucket;\n\tu32 crc = 0xFFFFFFFF;\n\tbool mcast, ghtx;\n\n\taddr = ENET_ADDR_TO_UINT64(*eth_addr);\n\n\tghtx = (bool)((ioread32be(&regs->rctrl) & RCTRL_GHTX) ? true : false);\n\tmcast = (bool)((addr & MAC_GROUP_ADDRESS) ? true : false);\n\n\t \n\tif (ghtx && !mcast) {\n\t\tpr_err(\"Could not compute hash bucket\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcrc = crc32_le(crc, (u8 *)eth_addr, ETH_ALEN);\n\tcrc = bitrev32(crc);\n\n\tif (ghtx) {\n\t\tbucket = (s32)((crc >> 23) & 0x1ff);\n\t} else {\n\t\tbucket = (s32)((crc >> 24) & 0xff);\n\t\t \n\t\tif (mcast)\n\t\t\tbucket += 0x100;\n\t}\n\n\tif (addr & MAC_GROUP_ADDRESS) {\n\t\t \n\t\tlist_for_each(pos,\n\t\t\t      &dtsec->multicast_addr_hash->lsts[bucket]) {\n\t\t\thash_entry = ETH_HASH_ENTRY_OBJ(pos);\n\t\t\tif (hash_entry && hash_entry->addr == addr) {\n\t\t\t\tlist_del_init(&hash_entry->node);\n\t\t\t\tkfree(hash_entry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (list_empty(&dtsec->multicast_addr_hash->lsts[bucket]))\n\t\t\tset_bucket(dtsec->regs, bucket, false);\n\t} else {\n\t\t \n\t\tlist_for_each(pos,\n\t\t\t      &dtsec->unicast_addr_hash->lsts[bucket]) {\n\t\t\thash_entry = ETH_HASH_ENTRY_OBJ(pos);\n\t\t\tif (hash_entry && hash_entry->addr == addr) {\n\t\t\t\tlist_del_init(&hash_entry->node);\n\t\t\t\tkfree(hash_entry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (list_empty(&dtsec->unicast_addr_hash->lsts[bucket]))\n\t\t\tset_bucket(dtsec->regs, bucket, false);\n\t}\n\n\t \n\tWARN_ON(!hash_entry);\n\n\treturn 0;\n}\n\nstatic int dtsec_set_promiscuous(struct fman_mac *dtsec, bool new_val)\n{\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\tu32 tmp;\n\n\t \n\ttmp = ioread32be(&regs->rctrl);\n\tif (new_val)\n\t\ttmp |= RCTRL_UPROM;\n\telse\n\t\ttmp &= ~RCTRL_UPROM;\n\n\tiowrite32be(tmp, &regs->rctrl);\n\n\t \n\ttmp = ioread32be(&regs->rctrl);\n\tif (new_val)\n\t\ttmp |= RCTRL_MPROM;\n\telse\n\t\ttmp &= ~RCTRL_MPROM;\n\n\tiowrite32be(tmp, &regs->rctrl);\n\n\treturn 0;\n}\n\nstatic int dtsec_set_exception(struct fman_mac *dtsec,\n\t\t\t       enum fman_mac_exceptions exception, bool enable)\n{\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\tu32 bit_mask = 0;\n\n\tif (exception != FM_MAC_EX_1G_1588_TS_RX_ERR) {\n\t\tbit_mask = get_exception_flag(exception);\n\t\tif (bit_mask) {\n\t\t\tif (enable)\n\t\t\t\tdtsec->exceptions |= bit_mask;\n\t\t\telse\n\t\t\t\tdtsec->exceptions &= ~bit_mask;\n\t\t} else {\n\t\t\tpr_err(\"Undefined exception\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (enable)\n\t\t\tiowrite32be(ioread32be(&regs->imask) | bit_mask,\n\t\t\t\t    &regs->imask);\n\t\telse\n\t\t\tiowrite32be(ioread32be(&regs->imask) & ~bit_mask,\n\t\t\t\t    &regs->imask);\n\t} else {\n\t\tif (!dtsec->ptp_tsu_enabled) {\n\t\t\tpr_err(\"Exception valid for 1588 only\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (exception) {\n\t\tcase FM_MAC_EX_1G_1588_TS_RX_ERR:\n\t\t\tif (enable) {\n\t\t\t\tdtsec->en_tsu_err_exception = true;\n\t\t\t\tiowrite32be(ioread32be(&regs->tmr_pemask) |\n\t\t\t\t\t    TMR_PEMASK_TSREEN,\n\t\t\t\t\t    &regs->tmr_pemask);\n\t\t\t} else {\n\t\t\t\tdtsec->en_tsu_err_exception = false;\n\t\t\t\tiowrite32be(ioread32be(&regs->tmr_pemask) &\n\t\t\t\t\t    ~TMR_PEMASK_TSREEN,\n\t\t\t\t\t    &regs->tmr_pemask);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Undefined exception\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dtsec_init(struct fman_mac *dtsec)\n{\n\tstruct dtsec_regs __iomem *regs = dtsec->regs;\n\tstruct dtsec_cfg *dtsec_drv_param;\n\tu16 max_frm_ln, tbicon;\n\tint err;\n\n\tif (DEFAULT_RESET_ON_INIT &&\n\t    (fman_reset_mac(dtsec->fm, dtsec->mac_id) != 0)) {\n\t\tpr_err(\"Can't reset MAC!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_init_parameters(dtsec);\n\tif (err)\n\t\treturn err;\n\n\tdtsec_drv_param = dtsec->dtsec_drv_param;\n\n\terr = init(dtsec->regs, dtsec_drv_param, dtsec->phy_if,\n\t\t   dtsec->max_speed, dtsec->addr, dtsec->exceptions,\n\t\t   dtsec->tbidev->addr);\n\tif (err) {\n\t\tfree_init_resources(dtsec);\n\t\tpr_err(\"DTSEC version doesn't support this i/f mode\\n\");\n\t\treturn err;\n\t}\n\n\t \n\ttbicon = TBICON_CLK_SELECT | TBICON_SOFT_RESET;\n\tmdiodev_write(dtsec->tbidev, MII_TBICON, tbicon);\n\n\ttbicon = TBICON_CLK_SELECT;\n\tmdiodev_write(dtsec->tbidev, MII_TBICON, tbicon);\n\n\t \n\tmax_frm_ln = (u16)ioread32be(&regs->maxfrm);\n\terr = fman_set_mac_max_frame(dtsec->fm, dtsec->mac_id, max_frm_ln);\n\tif (err) {\n\t\tpr_err(\"Setting max frame length failed\\n\");\n\t\tfree_init_resources(dtsec);\n\t\treturn -EINVAL;\n\t}\n\n\tdtsec->multicast_addr_hash =\n\talloc_hash_table(EXTENDED_HASH_TABLE_SIZE);\n\tif (!dtsec->multicast_addr_hash) {\n\t\tfree_init_resources(dtsec);\n\t\tpr_err(\"MC hash table is failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdtsec->unicast_addr_hash = alloc_hash_table(DTSEC_HASH_TABLE_SIZE);\n\tif (!dtsec->unicast_addr_hash) {\n\t\tfree_init_resources(dtsec);\n\t\tpr_err(\"UC hash table is failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfman_register_intr(dtsec->fm, FMAN_MOD_MAC, dtsec->mac_id,\n\t\t\t   FMAN_INTR_TYPE_ERR, dtsec_isr, dtsec);\n\t \n\tfman_register_intr(dtsec->fm, FMAN_MOD_MAC, dtsec->mac_id,\n\t\t\t   FMAN_INTR_TYPE_NORMAL, dtsec_1588_isr, dtsec);\n\n\tkfree(dtsec_drv_param);\n\tdtsec->dtsec_drv_param = NULL;\n\n\treturn 0;\n}\n\nstatic int dtsec_free(struct fman_mac *dtsec)\n{\n\tfree_init_resources(dtsec);\n\n\tkfree(dtsec->dtsec_drv_param);\n\tdtsec->dtsec_drv_param = NULL;\n\tif (!IS_ERR_OR_NULL(dtsec->tbidev))\n\t\tput_device(&dtsec->tbidev->dev);\n\tkfree(dtsec);\n\n\treturn 0;\n}\n\nstatic struct fman_mac *dtsec_config(struct mac_device *mac_dev,\n\t\t\t\t     struct fman_mac_params *params)\n{\n\tstruct fman_mac *dtsec;\n\tstruct dtsec_cfg *dtsec_drv_param;\n\n\t \n\tdtsec = kzalloc(sizeof(*dtsec), GFP_KERNEL);\n\tif (!dtsec)\n\t\treturn NULL;\n\n\t \n\tdtsec_drv_param = kzalloc(sizeof(*dtsec_drv_param), GFP_KERNEL);\n\tif (!dtsec_drv_param)\n\t\tgoto err_dtsec;\n\n\t \n\tdtsec->dtsec_drv_param = dtsec_drv_param;\n\n\tset_dflts(dtsec_drv_param);\n\n\tdtsec->regs = mac_dev->vaddr;\n\tdtsec->addr = ENET_ADDR_TO_UINT64(mac_dev->addr);\n\tdtsec->phy_if = mac_dev->phy_if;\n\tdtsec->mac_id = params->mac_id;\n\tdtsec->exceptions = (DTSEC_IMASK_BREN\t|\n\t\t\t     DTSEC_IMASK_RXCEN\t|\n\t\t\t     DTSEC_IMASK_BTEN\t|\n\t\t\t     DTSEC_IMASK_TXCEN\t|\n\t\t\t     DTSEC_IMASK_TXEEN\t|\n\t\t\t     DTSEC_IMASK_ABRTEN\t|\n\t\t\t     DTSEC_IMASK_LCEN\t|\n\t\t\t     DTSEC_IMASK_CRLEN\t|\n\t\t\t     DTSEC_IMASK_XFUNEN\t|\n\t\t\t     DTSEC_IMASK_IFERREN |\n\t\t\t     DTSEC_IMASK_MAGEN\t|\n\t\t\t     DTSEC_IMASK_TDPEEN\t|\n\t\t\t     DTSEC_IMASK_RDPEEN);\n\tdtsec->exception_cb = params->exception_cb;\n\tdtsec->event_cb = params->event_cb;\n\tdtsec->dev_id = mac_dev;\n\tdtsec->ptp_tsu_enabled = dtsec->dtsec_drv_param->ptp_tsu_en;\n\tdtsec->en_tsu_err_exception = dtsec->dtsec_drv_param->ptp_exception_en;\n\n\tdtsec->fm = params->fm;\n\n\t \n\tfman_get_revision(dtsec->fm, &dtsec->fm_rev_info);\n\n\treturn dtsec;\n\nerr_dtsec:\n\tkfree(dtsec);\n\treturn NULL;\n}\n\nint dtsec_initialization(struct mac_device *mac_dev,\n\t\t\t struct device_node *mac_node,\n\t\t\t struct fman_mac_params *params)\n{\n\tint\t\t\terr;\n\tstruct fman_mac\t\t*dtsec;\n\tstruct device_node\t*phy_node;\n\tunsigned long\t\t capabilities;\n\tunsigned long\t\t*supported;\n\n\tmac_dev->phylink_ops\t\t= &dtsec_mac_ops;\n\tmac_dev->set_promisc\t\t= dtsec_set_promiscuous;\n\tmac_dev->change_addr\t\t= dtsec_modify_mac_address;\n\tmac_dev->add_hash_mac_addr\t= dtsec_add_hash_mac_address;\n\tmac_dev->remove_hash_mac_addr\t= dtsec_del_hash_mac_address;\n\tmac_dev->set_exception\t\t= dtsec_set_exception;\n\tmac_dev->set_allmulti\t\t= dtsec_set_allmulti;\n\tmac_dev->set_tstamp\t\t= dtsec_set_tstamp;\n\tmac_dev->set_multi\t\t= fman_set_multi;\n\tmac_dev->enable\t\t\t= dtsec_enable;\n\tmac_dev->disable\t\t= dtsec_disable;\n\n\tmac_dev->fman_mac = dtsec_config(mac_dev, params);\n\tif (!mac_dev->fman_mac) {\n\t\terr = -EINVAL;\n\t\tgoto _return;\n\t}\n\n\tdtsec = mac_dev->fman_mac;\n\tdtsec->dtsec_drv_param->maximum_frame = fman_get_max_frm();\n\tdtsec->dtsec_drv_param->tx_pad_crc = true;\n\n\tphy_node = of_parse_phandle(mac_node, \"tbi-handle\", 0);\n\tif (!phy_node || !of_device_is_available(phy_node)) {\n\t\tof_node_put(phy_node);\n\t\terr = -EINVAL;\n\t\tdev_err_probe(mac_dev->dev, err,\n\t\t\t      \"TBI PCS node is not available\\n\");\n\t\tgoto _return_fm_mac_free;\n\t}\n\n\tdtsec->tbidev = of_mdio_find_device(phy_node);\n\tof_node_put(phy_node);\n\tif (!dtsec->tbidev) {\n\t\terr = -EPROBE_DEFER;\n\t\tdev_err_probe(mac_dev->dev, err,\n\t\t\t      \"could not find mdiodev for PCS\\n\");\n\t\tgoto _return_fm_mac_free;\n\t}\n\tdtsec->pcs.ops = &dtsec_pcs_ops;\n\tdtsec->pcs.neg_mode = true;\n\tdtsec->pcs.poll = true;\n\n\tsupported = mac_dev->phylink_config.supported_interfaces;\n\n\t \n\tif (mac_dev->phy_if == PHY_INTERFACE_MODE_SGMII ||\n\t    mac_dev->phy_if == PHY_INTERFACE_MODE_1000BASEX) {\n\t\t__set_bit(PHY_INTERFACE_MODE_SGMII, supported);\n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX, supported);\n\t} else if (mac_dev->phy_if == PHY_INTERFACE_MODE_2500BASEX) {\n\t\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, supported);\n\t}\n\n\tif (!(ioread32be(&dtsec->regs->tsec_id2) & DTSEC_ID2_INT_REDUCED_OFF)) {\n\t\tphy_interface_set_rgmii(supported);\n\n\t\t \n\t\tif (of_machine_is_compatible(\"fsl,P1023\") ||\n\t\t    of_machine_is_compatible(\"fsl,P1023RDB\"))\n\t\t\t__set_bit(PHY_INTERFACE_MODE_RMII, supported);\n\t}\n\n\tcapabilities = MAC_SYM_PAUSE | MAC_ASYM_PAUSE;\n\tcapabilities |= MAC_10 | MAC_100 | MAC_1000FD | MAC_2500FD;\n\tmac_dev->phylink_config.mac_capabilities = capabilities;\n\n\terr = dtsec_init(dtsec);\n\tif (err < 0)\n\t\tgoto _return_fm_mac_free;\n\n\t \n\terr = dtsec_set_exception(dtsec, FM_MAC_EX_1G_RX_MIB_CNT_OVFL, false);\n\tif (err < 0)\n\t\tgoto _return_fm_mac_free;\n\n\tdev_info(mac_dev->dev, \"FMan dTSEC version: 0x%08x\\n\",\n\t\t ioread32be(&dtsec->regs->tsec_id));\n\n\tgoto _return;\n\n_return_fm_mac_free:\n\tdtsec_free(dtsec);\n\n_return:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}