{
  "module_name": "fman_memac.c",
  "hash_id": "c3aef004a2fbb1dfc4934d2a4d33de4757bdf2d34b92705e905d1884d48fd235",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fman/fman_memac.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"fman_memac.h\"\n#include \"fman.h\"\n#include \"mac.h\"\n\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/pcs-lynx.h>\n#include <linux/phy.h>\n#include <linux/phy_fixed.h>\n#include <linux/phy/phy.h>\n#include <linux/of_mdio.h>\n\n \n#define MEMAC_NUM_OF_PADDRS 7\n\n \n#define CMD_CFG_REG_LOWP_RXETY\t0x01000000  \n#define CMD_CFG_TX_LOWP_ENA\t0x00800000  \n#define CMD_CFG_PFC_MODE\t0x00080000  \n#define CMD_CFG_NO_LEN_CHK\t0x00020000  \n#define CMD_CFG_SW_RESET\t0x00001000  \n#define CMD_CFG_TX_PAD_EN\t0x00000800  \n#define CMD_CFG_PAUSE_IGNORE\t0x00000100  \n#define CMD_CFG_CRC_FWD\t\t0x00000040  \n#define CMD_CFG_PAD_EN\t\t0x00000020  \n#define CMD_CFG_PROMIS_EN\t0x00000010  \n#define CMD_CFG_RX_EN\t\t0x00000002  \n#define CMD_CFG_TX_EN\t\t0x00000001  \n\n \n#define TX_FIFO_SECTIONS_TX_EMPTY_MASK\t\t\t0xFFFF0000\n#define TX_FIFO_SECTIONS_TX_AVAIL_MASK\t\t\t0x0000FFFF\n#define TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_10G\t\t0x00400000\n#define TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_1G\t\t0x00100000\n#define TX_FIFO_SECTIONS_TX_AVAIL_10G\t\t\t0x00000019\n#define TX_FIFO_SECTIONS_TX_AVAIL_1G\t\t\t0x00000020\n#define TX_FIFO_SECTIONS_TX_AVAIL_SLOW_10G\t\t0x00000060\n\n#define GET_TX_EMPTY_DEFAULT_VALUE(_val)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t_val &= ~TX_FIFO_SECTIONS_TX_EMPTY_MASK;\t\t\t\\\n\t((_val == TX_FIFO_SECTIONS_TX_AVAIL_10G) ?\t\t\t\\\n\t\t\t(_val |= TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_10G) :\\\n\t\t\t(_val |= TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_1G));\\\n} while (0)\n\n \n\n#define IF_MODE_MASK\t\t0x00000003  \n#define IF_MODE_10G\t\t0x00000000  \n#define IF_MODE_MII\t\t0x00000001  \n#define IF_MODE_GMII\t\t0x00000002  \n#define IF_MODE_RGMII\t\t0x00000004\n#define IF_MODE_RGMII_AUTO\t0x00008000\n#define IF_MODE_RGMII_1000\t0x00004000  \n#define IF_MODE_RGMII_100\t0x00000000  \n#define IF_MODE_RGMII_10\t0x00002000  \n#define IF_MODE_RGMII_SP_MASK\t0x00006000  \n#define IF_MODE_RGMII_FD\t0x00001000  \n#define IF_MODE_HD\t\t0x00000040  \n\n \n#define HASH_CTRL_MCAST_EN\t0x00000100\n \n#define HASH_CTRL_ADDR_MASK\t0x0000003F\n \n#define GROUP_ADDRESS\t\t0x0000010000000000LL\n#define HASH_TABLE_SIZE\t\t64\t \n\n \n#define MEMAC_IMASK_MGI\t\t0x40000000  \n#define MEMAC_IMASK_TSECC_ER\t0x20000000  \n#define MEMAC_IMASK_TECC_ER\t0x02000000  \n#define MEMAC_IMASK_RECC_ER\t0x01000000  \n\n#define MEMAC_ALL_ERRS_IMASK\t\t\t\t\t\\\n\t\t((u32)(MEMAC_IMASK_TSECC_ER\t|\t\\\n\t\t       MEMAC_IMASK_TECC_ER\t\t|\t\\\n\t\t       MEMAC_IMASK_RECC_ER\t\t|\t\\\n\t\t       MEMAC_IMASK_MGI))\n\n#define MEMAC_IEVNT_PCS\t\t\t0x80000000  \n#define MEMAC_IEVNT_AN\t\t\t0x40000000  \n#define MEMAC_IEVNT_LT\t\t\t0x20000000  \n#define MEMAC_IEVNT_MGI\t\t\t0x00004000  \n#define MEMAC_IEVNT_TS_ECC_ER\t\t0x00002000  \n#define MEMAC_IEVNT_RX_FIFO_OVFL\t0x00001000  \n#define MEMAC_IEVNT_TX_FIFO_UNFL\t0x00000800  \n#define MEMAC_IEVNT_TX_FIFO_OVFL\t0x00000400  \n#define MEMAC_IEVNT_TX_ECC_ER\t\t0x00000200  \n#define MEMAC_IEVNT_RX_ECC_ER\t\t0x00000100  \n#define MEMAC_IEVNT_LI_FAULT\t\t0x00000080  \n#define MEMAC_IEVNT_RX_EMPTY\t\t0x00000040  \n#define MEMAC_IEVNT_TX_EMPTY\t\t0x00000020  \n#define MEMAC_IEVNT_RX_LOWP\t\t0x00000010  \n#define MEMAC_IEVNT_PHY_LOS\t\t0x00000004  \n#define MEMAC_IEVNT_REM_FAULT\t\t0x00000002  \n#define MEMAC_IEVNT_LOC_FAULT\t\t0x00000001  \n\n#define DEFAULT_PAUSE_QUANTA\t0xf000\n#define DEFAULT_FRAME_LENGTH\t0x600\n#define DEFAULT_TX_IPG_LENGTH\t12\n\n#define CLXY_PAUSE_QUANTA_CLX_PQNT\t0x0000FFFF\n#define CLXY_PAUSE_QUANTA_CLY_PQNT\t0xFFFF0000\n#define CLXY_PAUSE_THRESH_CLX_QTH\t0x0000FFFF\n#define CLXY_PAUSE_THRESH_CLY_QTH\t0xFFFF0000\n\nstruct mac_addr {\n\t \n\tu32 mac_addr_l;\n\t \n\tu32 mac_addr_u;\n};\n\n \nstruct memac_regs {\n\tu32 res0000[2];\t\t\t \n\tu32 command_config;\t\t \n\tstruct mac_addr mac_addr0;\t \n\tu32 maxfrm;\t\t\t \n\tu32 res0018[1];\n\tu32 rx_fifo_sections;\t\t \n\tu32 tx_fifo_sections;\t\t \n\tu32 res0024[2];\n\tu32 hashtable_ctrl;\t\t \n\tu32 res0030[4];\n\tu32 ievent;\t\t\t \n\tu32 tx_ipg_length;\t\t \n\tu32 res0048;\n\tu32 imask;\t\t\t \n\tu32 res0050;\n\tu32 pause_quanta[4];\t\t \n\tu32 pause_thresh[4];\t\t \n\tu32 rx_pause_status;\t\t \n\tu32 res0078[2];\n\tstruct mac_addr mac_addr[MEMAC_NUM_OF_PADDRS]; \n\tu32 lpwake_timer;\t\t \n\tu32 sleep_timer;\t\t \n\tu32 res00c0[8];\n\tu32 statn_config;\t\t \n\tu32 res00e4[7];\n\t \n\tu32 reoct_l;\n\tu32 reoct_u;\n\tu32 roct_l;\n\tu32 roct_u;\n\tu32 raln_l;\n\tu32 raln_u;\n\tu32 rxpf_l;\n\tu32 rxpf_u;\n\tu32 rfrm_l;\n\tu32 rfrm_u;\n\tu32 rfcs_l;\n\tu32 rfcs_u;\n\tu32 rvlan_l;\n\tu32 rvlan_u;\n\tu32 rerr_l;\n\tu32 rerr_u;\n\tu32 ruca_l;\n\tu32 ruca_u;\n\tu32 rmca_l;\n\tu32 rmca_u;\n\tu32 rbca_l;\n\tu32 rbca_u;\n\tu32 rdrp_l;\n\tu32 rdrp_u;\n\tu32 rpkt_l;\n\tu32 rpkt_u;\n\tu32 rund_l;\n\tu32 rund_u;\n\tu32 r64_l;\n\tu32 r64_u;\n\tu32 r127_l;\n\tu32 r127_u;\n\tu32 r255_l;\n\tu32 r255_u;\n\tu32 r511_l;\n\tu32 r511_u;\n\tu32 r1023_l;\n\tu32 r1023_u;\n\tu32 r1518_l;\n\tu32 r1518_u;\n\tu32 r1519x_l;\n\tu32 r1519x_u;\n\tu32 rovr_l;\n\tu32 rovr_u;\n\tu32 rjbr_l;\n\tu32 rjbr_u;\n\tu32 rfrg_l;\n\tu32 rfrg_u;\n\tu32 rcnp_l;\n\tu32 rcnp_u;\n\tu32 rdrntp_l;\n\tu32 rdrntp_u;\n\tu32 res01d0[12];\n\t \n\tu32 teoct_l;\n\tu32 teoct_u;\n\tu32 toct_l;\n\tu32 toct_u;\n\tu32 res0210[2];\n\tu32 txpf_l;\n\tu32 txpf_u;\n\tu32 tfrm_l;\n\tu32 tfrm_u;\n\tu32 tfcs_l;\n\tu32 tfcs_u;\n\tu32 tvlan_l;\n\tu32 tvlan_u;\n\tu32 terr_l;\n\tu32 terr_u;\n\tu32 tuca_l;\n\tu32 tuca_u;\n\tu32 tmca_l;\n\tu32 tmca_u;\n\tu32 tbca_l;\n\tu32 tbca_u;\n\tu32 res0258[2];\n\tu32 tpkt_l;\n\tu32 tpkt_u;\n\tu32 tund_l;\n\tu32 tund_u;\n\tu32 t64_l;\n\tu32 t64_u;\n\tu32 t127_l;\n\tu32 t127_u;\n\tu32 t255_l;\n\tu32 t255_u;\n\tu32 t511_l;\n\tu32 t511_u;\n\tu32 t1023_l;\n\tu32 t1023_u;\n\tu32 t1518_l;\n\tu32 t1518_u;\n\tu32 t1519x_l;\n\tu32 t1519x_u;\n\tu32 res02a8[6];\n\tu32 tcnp_l;\n\tu32 tcnp_u;\n\tu32 res02c8[14];\n\t \n\tu32 if_mode;\t\t \n\tu32 if_status;\t\t \n\tu32 res0308[14];\n\t \n\tu32 hg_config;\t\t \n\tu32 res0344[3];\n\tu32 hg_pause_quanta;\t \n\tu32 res0354[3];\n\tu32 hg_pause_thresh;\t \n\tu32 res0364[3];\n\tu32 hgrx_pause_status;\t \n\tu32 hg_fifos_status;\t \n\tu32 rhm;\t\t \n\tu32 thm;\t\t \n};\n\nstruct memac_cfg {\n\tbool reset_on_init;\n\tbool pause_ignore;\n\tbool promiscuous_mode_enable;\n\tstruct fixed_phy_status *fixed_link;\n\tu16 max_frame_length;\n\tu16 pause_quanta;\n\tu32 tx_ipg_length;\n};\n\nstruct fman_mac {\n\t \n\tstruct memac_regs __iomem *regs;\n\t \n\tu64 addr;\n\tstruct mac_device *dev_id;  \n\tfman_mac_exception_cb *exception_cb;\n\tfman_mac_exception_cb *event_cb;\n\t \n\tstruct eth_hash_t *multicast_addr_hash;\n\t \n\tstruct eth_hash_t *unicast_addr_hash;\n\tu8 mac_id;\n\tu32 exceptions;\n\tstruct memac_cfg *memac_drv_param;\n\tvoid *fm;\n\tstruct fman_rev_info fm_rev_info;\n\tstruct phy *serdes;\n\tstruct phylink_pcs *sgmii_pcs;\n\tstruct phylink_pcs *qsgmii_pcs;\n\tstruct phylink_pcs *xfi_pcs;\n\tbool allmulti_enabled;\n\tbool rgmii_no_half_duplex;\n};\n\nstatic void add_addr_in_paddr(struct memac_regs __iomem *regs, const u8 *adr,\n\t\t\t      u8 paddr_num)\n{\n\tu32 tmp0, tmp1;\n\n\ttmp0 = (u32)(adr[0] | adr[1] << 8 | adr[2] << 16 | adr[3] << 24);\n\ttmp1 = (u32)(adr[4] | adr[5] << 8);\n\n\tif (paddr_num == 0) {\n\t\tiowrite32be(tmp0, &regs->mac_addr0.mac_addr_l);\n\t\tiowrite32be(tmp1, &regs->mac_addr0.mac_addr_u);\n\t} else {\n\t\tiowrite32be(tmp0, &regs->mac_addr[paddr_num - 1].mac_addr_l);\n\t\tiowrite32be(tmp1, &regs->mac_addr[paddr_num - 1].mac_addr_u);\n\t}\n}\n\nstatic int reset(struct memac_regs __iomem *regs)\n{\n\tu32 tmp;\n\tint count;\n\n\ttmp = ioread32be(&regs->command_config);\n\n\ttmp |= CMD_CFG_SW_RESET;\n\n\tiowrite32be(tmp, &regs->command_config);\n\n\tcount = 100;\n\tdo {\n\t\tudelay(1);\n\t} while ((ioread32be(&regs->command_config) & CMD_CFG_SW_RESET) &&\n\t\t --count);\n\n\tif (count == 0)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic void set_exception(struct memac_regs __iomem *regs, u32 val,\n\t\t\t  bool enable)\n{\n\tu32 tmp;\n\n\ttmp = ioread32be(&regs->imask);\n\tif (enable)\n\t\ttmp |= val;\n\telse\n\t\ttmp &= ~val;\n\n\tiowrite32be(tmp, &regs->imask);\n}\n\nstatic int init(struct memac_regs __iomem *regs, struct memac_cfg *cfg,\n\t\tu32 exceptions)\n{\n\tu32 tmp;\n\n\t \n\ttmp = 0;\n\tif (cfg->promiscuous_mode_enable)\n\t\ttmp |= CMD_CFG_PROMIS_EN;\n\tif (cfg->pause_ignore)\n\t\ttmp |= CMD_CFG_PAUSE_IGNORE;\n\n\t \n\ttmp |= CMD_CFG_NO_LEN_CHK;\n\t \n\ttmp |= CMD_CFG_TX_PAD_EN;\n\n\ttmp |= CMD_CFG_CRC_FWD;\n\n\tiowrite32be(tmp, &regs->command_config);\n\n\t \n\tiowrite32be((u32)cfg->max_frame_length, &regs->maxfrm);\n\n\t \n\tiowrite32be((u32)cfg->pause_quanta, &regs->pause_quanta[0]);\n\tiowrite32be((u32)0, &regs->pause_thresh[0]);\n\n\t \n\tiowrite32be(0xffffffff, &regs->ievent);\n\tset_exception(regs, exceptions, true);\n\n\treturn 0;\n}\n\nstatic void set_dflts(struct memac_cfg *cfg)\n{\n\tcfg->reset_on_init = false;\n\tcfg->promiscuous_mode_enable = false;\n\tcfg->pause_ignore = false;\n\tcfg->tx_ipg_length = DEFAULT_TX_IPG_LENGTH;\n\tcfg->max_frame_length = DEFAULT_FRAME_LENGTH;\n\tcfg->pause_quanta = DEFAULT_PAUSE_QUANTA;\n}\n\nstatic u32 get_mac_addr_hash_code(u64 eth_addr)\n{\n\tu64 mask1, mask2;\n\tu32 xor_val = 0;\n\tu8 i, j;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tmask1 = eth_addr & (u64)0x01;\n\t\teth_addr >>= 1;\n\n\t\tfor (j = 0; j < 7; j++) {\n\t\t\tmask2 = eth_addr & (u64)0x01;\n\t\t\tmask1 ^= mask2;\n\t\t\teth_addr >>= 1;\n\t\t}\n\n\t\txor_val |= (mask1 << (5 - i));\n\t}\n\n\treturn xor_val;\n}\n\nstatic int check_init_parameters(struct fman_mac *memac)\n{\n\tif (!memac->exception_cb) {\n\t\tpr_err(\"Uninitialized exception handler\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!memac->event_cb) {\n\t\tpr_warn(\"Uninitialize event handler\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_exception_flag(enum fman_mac_exceptions exception)\n{\n\tu32 bit_mask;\n\n\tswitch (exception) {\n\tcase FM_MAC_EX_10G_TX_ECC_ER:\n\t\tbit_mask = MEMAC_IMASK_TECC_ER;\n\t\tbreak;\n\tcase FM_MAC_EX_10G_RX_ECC_ER:\n\t\tbit_mask = MEMAC_IMASK_RECC_ER;\n\t\tbreak;\n\tcase FM_MAC_EX_TS_FIFO_ECC_ERR:\n\t\tbit_mask = MEMAC_IMASK_TSECC_ER;\n\t\tbreak;\n\tcase FM_MAC_EX_MAGIC_PACKET_INDICATION:\n\t\tbit_mask = MEMAC_IMASK_MGI;\n\t\tbreak;\n\tdefault:\n\t\tbit_mask = 0;\n\t\tbreak;\n\t}\n\n\treturn bit_mask;\n}\n\nstatic void memac_err_exception(void *handle)\n{\n\tstruct fman_mac *memac = (struct fman_mac *)handle;\n\tstruct memac_regs __iomem *regs = memac->regs;\n\tu32 event, imask;\n\n\tevent = ioread32be(&regs->ievent);\n\timask = ioread32be(&regs->imask);\n\n\t \n\tevent &= ((imask & MEMAC_ALL_ERRS_IMASK) >> 16);\n\n\tiowrite32be(event, &regs->ievent);\n\n\tif (event & MEMAC_IEVNT_TS_ECC_ER)\n\t\tmemac->exception_cb(memac->dev_id, FM_MAC_EX_TS_FIFO_ECC_ERR);\n\tif (event & MEMAC_IEVNT_TX_ECC_ER)\n\t\tmemac->exception_cb(memac->dev_id, FM_MAC_EX_10G_TX_ECC_ER);\n\tif (event & MEMAC_IEVNT_RX_ECC_ER)\n\t\tmemac->exception_cb(memac->dev_id, FM_MAC_EX_10G_RX_ECC_ER);\n}\n\nstatic void memac_exception(void *handle)\n{\n\tstruct fman_mac *memac = (struct fman_mac *)handle;\n\tstruct memac_regs __iomem *regs = memac->regs;\n\tu32 event, imask;\n\n\tevent = ioread32be(&regs->ievent);\n\timask = ioread32be(&regs->imask);\n\n\t \n\tevent &= ((imask & MEMAC_ALL_ERRS_IMASK) >> 16);\n\n\tiowrite32be(event, &regs->ievent);\n\n\tif (event & MEMAC_IEVNT_MGI)\n\t\tmemac->exception_cb(memac->dev_id,\n\t\t\t\t    FM_MAC_EX_MAGIC_PACKET_INDICATION);\n}\n\nstatic void free_init_resources(struct fman_mac *memac)\n{\n\tfman_unregister_intr(memac->fm, FMAN_MOD_MAC, memac->mac_id,\n\t\t\t     FMAN_INTR_TYPE_ERR);\n\n\tfman_unregister_intr(memac->fm, FMAN_MOD_MAC, memac->mac_id,\n\t\t\t     FMAN_INTR_TYPE_NORMAL);\n\n\t \n\tfree_hash_table(memac->multicast_addr_hash);\n\tmemac->multicast_addr_hash = NULL;\n\n\t \n\tfree_hash_table(memac->unicast_addr_hash);\n\tmemac->unicast_addr_hash = NULL;\n}\n\nstatic int memac_enable(struct fman_mac *memac)\n{\n\tint ret;\n\n\tret = phy_init(memac->serdes);\n\tif (ret) {\n\t\tdev_err(memac->dev_id->dev,\n\t\t\t\"could not initialize serdes: %pe\\n\", ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tret = phy_power_on(memac->serdes);\n\tif (ret) {\n\t\tdev_err(memac->dev_id->dev,\n\t\t\t\"could not power on serdes: %pe\\n\", ERR_PTR(ret));\n\t\tphy_exit(memac->serdes);\n\t}\n\n\treturn ret;\n}\n\nstatic void memac_disable(struct fman_mac *memac)\n{\n\tphy_power_off(memac->serdes);\n\tphy_exit(memac->serdes);\n}\n\nstatic int memac_set_promiscuous(struct fman_mac *memac, bool new_val)\n{\n\tstruct memac_regs __iomem *regs = memac->regs;\n\tu32 tmp;\n\n\ttmp = ioread32be(&regs->command_config);\n\tif (new_val)\n\t\ttmp |= CMD_CFG_PROMIS_EN;\n\telse\n\t\ttmp &= ~CMD_CFG_PROMIS_EN;\n\n\tiowrite32be(tmp, &regs->command_config);\n\n\treturn 0;\n}\n\nstatic int memac_set_tx_pause_frames(struct fman_mac *memac, u8 priority,\n\t\t\t\t     u16 pause_time, u16 thresh_time)\n{\n\tstruct memac_regs __iomem *regs = memac->regs;\n\tu32 tmp;\n\n\ttmp = ioread32be(&regs->tx_fifo_sections);\n\n\tGET_TX_EMPTY_DEFAULT_VALUE(tmp);\n\tiowrite32be(tmp, &regs->tx_fifo_sections);\n\n\ttmp = ioread32be(&regs->command_config);\n\ttmp &= ~CMD_CFG_PFC_MODE;\n\n\tiowrite32be(tmp, &regs->command_config);\n\n\ttmp = ioread32be(&regs->pause_quanta[priority / 2]);\n\tif (priority % 2)\n\t\ttmp &= CLXY_PAUSE_QUANTA_CLX_PQNT;\n\telse\n\t\ttmp &= CLXY_PAUSE_QUANTA_CLY_PQNT;\n\ttmp |= ((u32)pause_time << (16 * (priority % 2)));\n\tiowrite32be(tmp, &regs->pause_quanta[priority / 2]);\n\n\ttmp = ioread32be(&regs->pause_thresh[priority / 2]);\n\tif (priority % 2)\n\t\ttmp &= CLXY_PAUSE_THRESH_CLX_QTH;\n\telse\n\t\ttmp &= CLXY_PAUSE_THRESH_CLY_QTH;\n\ttmp |= ((u32)thresh_time << (16 * (priority % 2)));\n\tiowrite32be(tmp, &regs->pause_thresh[priority / 2]);\n\n\treturn 0;\n}\n\nstatic int memac_accept_rx_pause_frames(struct fman_mac *memac, bool en)\n{\n\tstruct memac_regs __iomem *regs = memac->regs;\n\tu32 tmp;\n\n\ttmp = ioread32be(&regs->command_config);\n\tif (en)\n\t\ttmp &= ~CMD_CFG_PAUSE_IGNORE;\n\telse\n\t\ttmp |= CMD_CFG_PAUSE_IGNORE;\n\n\tiowrite32be(tmp, &regs->command_config);\n\n\treturn 0;\n}\n\nstatic void memac_validate(struct phylink_config *config,\n\t\t\t   unsigned long *supported,\n\t\t\t   struct phylink_link_state *state)\n{\n\tstruct fman_mac *memac = fman_config_to_mac(config)->fman_mac;\n\tunsigned long caps = config->mac_capabilities;\n\n\tif (phy_interface_mode_is_rgmii(state->interface) &&\n\t    memac->rgmii_no_half_duplex)\n\t\tcaps &= ~(MAC_10HD | MAC_100HD);\n\n\tphylink_validate_mask_caps(supported, state, caps);\n}\n\n \nstatic u32 memac_if_mode(phy_interface_t interface)\n{\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\treturn IF_MODE_MII;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\treturn IF_MODE_GMII | IF_MODE_RGMII;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\t\treturn IF_MODE_GMII;\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\treturn IF_MODE_10G;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n}\n\nstatic struct phylink_pcs *memac_select_pcs(struct phylink_config *config,\n\t\t\t\t\t    phy_interface_t iface)\n{\n\tstruct fman_mac *memac = fman_config_to_mac(config)->fman_mac;\n\n\tswitch (iface) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\treturn memac->sgmii_pcs;\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\t\treturn memac->qsgmii_pcs;\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\treturn memac->xfi_pcs;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int memac_prepare(struct phylink_config *config, unsigned int mode,\n\t\t\t phy_interface_t iface)\n{\n\tstruct fman_mac *memac = fman_config_to_mac(config)->fman_mac;\n\n\tswitch (iface) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\treturn phy_set_mode_ext(memac->serdes, PHY_MODE_ETHERNET,\n\t\t\t\t\tiface);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void memac_mac_config(struct phylink_config *config, unsigned int mode,\n\t\t\t     const struct phylink_link_state *state)\n{\n\tstruct mac_device *mac_dev = fman_config_to_mac(config);\n\tstruct memac_regs __iomem *regs = mac_dev->fman_mac->regs;\n\tu32 tmp = ioread32be(&regs->if_mode);\n\n\ttmp &= ~(IF_MODE_MASK | IF_MODE_RGMII);\n\ttmp |= memac_if_mode(state->interface);\n\tif (phylink_autoneg_inband(mode))\n\t\ttmp |= IF_MODE_RGMII_AUTO;\n\tiowrite32be(tmp, &regs->if_mode);\n}\n\nstatic void memac_link_up(struct phylink_config *config, struct phy_device *phy,\n\t\t\t  unsigned int mode, phy_interface_t interface,\n\t\t\t  int speed, int duplex, bool tx_pause, bool rx_pause)\n{\n\tstruct mac_device *mac_dev = fman_config_to_mac(config);\n\tstruct fman_mac *memac = mac_dev->fman_mac;\n\tstruct memac_regs __iomem *regs = memac->regs;\n\tu32 tmp = memac_if_mode(interface);\n\tu16 pause_time = tx_pause ? FSL_FM_PAUSE_TIME_ENABLE :\n\t\t\t FSL_FM_PAUSE_TIME_DISABLE;\n\n\tmemac_set_tx_pause_frames(memac, 0, pause_time, 0);\n\tmemac_accept_rx_pause_frames(memac, rx_pause);\n\n\tif (duplex == DUPLEX_HALF)\n\t\ttmp |= IF_MODE_HD;\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\ttmp |= IF_MODE_RGMII_1000;\n\t\tbreak;\n\tcase SPEED_100:\n\t\ttmp |= IF_MODE_RGMII_100;\n\t\tbreak;\n\tcase SPEED_10:\n\t\ttmp |= IF_MODE_RGMII_10;\n\t\tbreak;\n\t}\n\tiowrite32be(tmp, &regs->if_mode);\n\n\t \n\n\tif (speed == SPEED_10000) {\n\t\tif (memac->fm_rev_info.major == 6 &&\n\t\t    memac->fm_rev_info.minor == 4)\n\t\t\ttmp = TX_FIFO_SECTIONS_TX_AVAIL_SLOW_10G;\n\t\telse\n\t\t\ttmp = TX_FIFO_SECTIONS_TX_AVAIL_10G;\n\t\ttmp |= TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_10G;\n\t} else {\n\t\ttmp = TX_FIFO_SECTIONS_TX_AVAIL_1G |\n\t\t      TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_1G;\n\t}\n\tiowrite32be(tmp, &regs->tx_fifo_sections);\n\n\tmac_dev->update_speed(mac_dev, speed);\n\n\ttmp = ioread32be(&regs->command_config);\n\ttmp |= CMD_CFG_RX_EN | CMD_CFG_TX_EN;\n\tiowrite32be(tmp, &regs->command_config);\n}\n\nstatic void memac_link_down(struct phylink_config *config, unsigned int mode,\n\t\t\t    phy_interface_t interface)\n{\n\tstruct fman_mac *memac = fman_config_to_mac(config)->fman_mac;\n\tstruct memac_regs __iomem *regs = memac->regs;\n\tu32 tmp;\n\n\t \n\ttmp = ioread32be(&regs->command_config);\n\ttmp &= ~(CMD_CFG_RX_EN | CMD_CFG_TX_EN);\n\tiowrite32be(tmp, &regs->command_config);\n}\n\nstatic const struct phylink_mac_ops memac_mac_ops = {\n\t.validate = memac_validate,\n\t.mac_select_pcs = memac_select_pcs,\n\t.mac_prepare = memac_prepare,\n\t.mac_config = memac_mac_config,\n\t.mac_link_up = memac_link_up,\n\t.mac_link_down = memac_link_down,\n};\n\nstatic int memac_modify_mac_address(struct fman_mac *memac,\n\t\t\t\t    const enet_addr_t *enet_addr)\n{\n\tadd_addr_in_paddr(memac->regs, (const u8 *)(*enet_addr), 0);\n\n\treturn 0;\n}\n\nstatic int memac_add_hash_mac_address(struct fman_mac *memac,\n\t\t\t\t      enet_addr_t *eth_addr)\n{\n\tstruct memac_regs __iomem *regs = memac->regs;\n\tstruct eth_hash_entry *hash_entry;\n\tu32 hash;\n\tu64 addr;\n\n\taddr = ENET_ADDR_TO_UINT64(*eth_addr);\n\n\tif (!(addr & GROUP_ADDRESS)) {\n\t\t \n\t\tpr_err(\"Unicast Address\\n\");\n\t\treturn -EINVAL;\n\t}\n\thash = get_mac_addr_hash_code(addr) & HASH_CTRL_ADDR_MASK;\n\n\t \n\thash_entry = kmalloc(sizeof(*hash_entry), GFP_ATOMIC);\n\tif (!hash_entry)\n\t\treturn -ENOMEM;\n\thash_entry->addr = addr;\n\tINIT_LIST_HEAD(&hash_entry->node);\n\n\tlist_add_tail(&hash_entry->node,\n\t\t      &memac->multicast_addr_hash->lsts[hash]);\n\tiowrite32be(hash | HASH_CTRL_MCAST_EN, &regs->hashtable_ctrl);\n\n\treturn 0;\n}\n\nstatic int memac_set_allmulti(struct fman_mac *memac, bool enable)\n{\n\tu32 entry;\n\tstruct memac_regs __iomem *regs = memac->regs;\n\n\tif (enable) {\n\t\tfor (entry = 0; entry < HASH_TABLE_SIZE; entry++)\n\t\t\tiowrite32be(entry | HASH_CTRL_MCAST_EN,\n\t\t\t\t    &regs->hashtable_ctrl);\n\t} else {\n\t\tfor (entry = 0; entry < HASH_TABLE_SIZE; entry++)\n\t\t\tiowrite32be(entry & ~HASH_CTRL_MCAST_EN,\n\t\t\t\t    &regs->hashtable_ctrl);\n\t}\n\n\tmemac->allmulti_enabled = enable;\n\n\treturn 0;\n}\n\nstatic int memac_set_tstamp(struct fman_mac *memac, bool enable)\n{\n\treturn 0;  \n}\n\nstatic int memac_del_hash_mac_address(struct fman_mac *memac,\n\t\t\t\t      enet_addr_t *eth_addr)\n{\n\tstruct memac_regs __iomem *regs = memac->regs;\n\tstruct eth_hash_entry *hash_entry = NULL;\n\tstruct list_head *pos;\n\tu32 hash;\n\tu64 addr;\n\n\taddr = ENET_ADDR_TO_UINT64(*eth_addr);\n\n\thash = get_mac_addr_hash_code(addr) & HASH_CTRL_ADDR_MASK;\n\n\tlist_for_each(pos, &memac->multicast_addr_hash->lsts[hash]) {\n\t\thash_entry = ETH_HASH_ENTRY_OBJ(pos);\n\t\tif (hash_entry && hash_entry->addr == addr) {\n\t\t\tlist_del_init(&hash_entry->node);\n\t\t\tkfree(hash_entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!memac->allmulti_enabled) {\n\t\tif (list_empty(&memac->multicast_addr_hash->lsts[hash]))\n\t\t\tiowrite32be(hash & ~HASH_CTRL_MCAST_EN,\n\t\t\t\t    &regs->hashtable_ctrl);\n\t}\n\n\treturn 0;\n}\n\nstatic int memac_set_exception(struct fman_mac *memac,\n\t\t\t       enum fman_mac_exceptions exception, bool enable)\n{\n\tu32 bit_mask = 0;\n\n\tbit_mask = get_exception_flag(exception);\n\tif (bit_mask) {\n\t\tif (enable)\n\t\t\tmemac->exceptions |= bit_mask;\n\t\telse\n\t\t\tmemac->exceptions &= ~bit_mask;\n\t} else {\n\t\tpr_err(\"Undefined exception\\n\");\n\t\treturn -EINVAL;\n\t}\n\tset_exception(memac->regs, bit_mask, enable);\n\n\treturn 0;\n}\n\nstatic int memac_init(struct fman_mac *memac)\n{\n\tstruct memac_cfg *memac_drv_param;\n\tenet_addr_t eth_addr;\n\tint err;\n\tu32 reg32 = 0;\n\n\terr = check_init_parameters(memac);\n\tif (err)\n\t\treturn err;\n\n\tmemac_drv_param = memac->memac_drv_param;\n\n\t \n\tif (memac_drv_param->reset_on_init) {\n\t\terr = reset(memac->regs);\n\t\tif (err) {\n\t\t\tpr_err(\"mEMAC reset failed\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (memac->addr != 0) {\n\t\tMAKE_ENET_ADDR_FROM_UINT64(memac->addr, eth_addr);\n\t\tadd_addr_in_paddr(memac->regs, (const u8 *)eth_addr, 0);\n\t}\n\n\tinit(memac->regs, memac->memac_drv_param, memac->exceptions);\n\n\t \n\tif ((memac->fm_rev_info.major == 6) &&\n\t    ((memac->fm_rev_info.minor == 0) ||\n\t    (memac->fm_rev_info.minor == 3))) {\n\t\t \n\t\treg32 = ioread32be(&memac->regs->command_config);\n\t\treg32 &= ~CMD_CFG_CRC_FWD;\n\t\tiowrite32be(reg32, &memac->regs->command_config);\n\t}\n\n\t \n\terr = fman_set_mac_max_frame(memac->fm, memac->mac_id,\n\t\t\t\t     memac_drv_param->max_frame_length);\n\tif (err) {\n\t\tpr_err(\"settings Mac max frame length is FAILED\\n\");\n\t\treturn err;\n\t}\n\n\tmemac->multicast_addr_hash = alloc_hash_table(HASH_TABLE_SIZE);\n\tif (!memac->multicast_addr_hash) {\n\t\tfree_init_resources(memac);\n\t\tpr_err(\"allocation hash table is FAILED\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemac->unicast_addr_hash = alloc_hash_table(HASH_TABLE_SIZE);\n\tif (!memac->unicast_addr_hash) {\n\t\tfree_init_resources(memac);\n\t\tpr_err(\"allocation hash table is FAILED\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfman_register_intr(memac->fm, FMAN_MOD_MAC, memac->mac_id,\n\t\t\t   FMAN_INTR_TYPE_ERR, memac_err_exception, memac);\n\n\tfman_register_intr(memac->fm, FMAN_MOD_MAC, memac->mac_id,\n\t\t\t   FMAN_INTR_TYPE_NORMAL, memac_exception, memac);\n\n\treturn 0;\n}\n\nstatic void pcs_put(struct phylink_pcs *pcs)\n{\n\tif (IS_ERR_OR_NULL(pcs))\n\t\treturn;\n\n\tlynx_pcs_destroy(pcs);\n}\n\nstatic int memac_free(struct fman_mac *memac)\n{\n\tfree_init_resources(memac);\n\n\tpcs_put(memac->sgmii_pcs);\n\tpcs_put(memac->qsgmii_pcs);\n\tpcs_put(memac->xfi_pcs);\n\tkfree(memac->memac_drv_param);\n\tkfree(memac);\n\n\treturn 0;\n}\n\nstatic struct fman_mac *memac_config(struct mac_device *mac_dev,\n\t\t\t\t     struct fman_mac_params *params)\n{\n\tstruct fman_mac *memac;\n\tstruct memac_cfg *memac_drv_param;\n\n\t \n\tmemac = kzalloc(sizeof(*memac), GFP_KERNEL);\n\tif (!memac)\n\t\treturn NULL;\n\n\t \n\tmemac_drv_param = kzalloc(sizeof(*memac_drv_param), GFP_KERNEL);\n\tif (!memac_drv_param) {\n\t\tmemac_free(memac);\n\t\treturn NULL;\n\t}\n\n\t \n\tmemac->memac_drv_param = memac_drv_param;\n\n\tset_dflts(memac_drv_param);\n\n\tmemac->addr = ENET_ADDR_TO_UINT64(mac_dev->addr);\n\n\tmemac->regs = mac_dev->vaddr;\n\tmemac->mac_id = params->mac_id;\n\tmemac->exceptions = (MEMAC_IMASK_TSECC_ER | MEMAC_IMASK_TECC_ER |\n\t\t\t     MEMAC_IMASK_RECC_ER | MEMAC_IMASK_MGI);\n\tmemac->exception_cb = params->exception_cb;\n\tmemac->event_cb = params->event_cb;\n\tmemac->dev_id = mac_dev;\n\tmemac->fm = params->fm;\n\n\t \n\tfman_get_revision(memac->fm, &memac->fm_rev_info);\n\n\treturn memac;\n}\n\nstatic struct phylink_pcs *memac_pcs_create(struct device_node *mac_node,\n\t\t\t\t\t    int index)\n{\n\tstruct device_node *node;\n\tstruct phylink_pcs *pcs;\n\n\tnode = of_parse_phandle(mac_node, \"pcsphy-handle\", index);\n\tif (!node)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpcs = lynx_pcs_create_fwnode(of_fwnode_handle(node));\n\tof_node_put(node);\n\n\treturn pcs;\n}\n\nstatic bool memac_supports(struct mac_device *mac_dev, phy_interface_t iface)\n{\n\t \n\tif (!mac_dev->fman_mac->serdes)\n\t\treturn mac_dev->phy_if == iface;\n\t \n\treturn !phy_validate(mac_dev->fman_mac->serdes, PHY_MODE_ETHERNET,\n\t\t\t     iface, NULL);\n}\n\nint memac_initialization(struct mac_device *mac_dev,\n\t\t\t struct device_node *mac_node,\n\t\t\t struct fman_mac_params *params)\n{\n\tint\t\t\t err;\n\tstruct device_node      *fixed;\n\tstruct phylink_pcs\t*pcs;\n\tstruct fman_mac\t\t*memac;\n\tunsigned long\t\t capabilities;\n\tunsigned long\t\t*supported;\n\n\tmac_dev->phylink_ops\t\t= &memac_mac_ops;\n\tmac_dev->set_promisc\t\t= memac_set_promiscuous;\n\tmac_dev->change_addr\t\t= memac_modify_mac_address;\n\tmac_dev->add_hash_mac_addr\t= memac_add_hash_mac_address;\n\tmac_dev->remove_hash_mac_addr\t= memac_del_hash_mac_address;\n\tmac_dev->set_exception\t\t= memac_set_exception;\n\tmac_dev->set_allmulti\t\t= memac_set_allmulti;\n\tmac_dev->set_tstamp\t\t= memac_set_tstamp;\n\tmac_dev->set_multi\t\t= fman_set_multi;\n\tmac_dev->enable\t\t\t= memac_enable;\n\tmac_dev->disable\t\t= memac_disable;\n\n\tmac_dev->fman_mac = memac_config(mac_dev, params);\n\tif (!mac_dev->fman_mac)\n\t\treturn -EINVAL;\n\n\tmemac = mac_dev->fman_mac;\n\tmemac->memac_drv_param->max_frame_length = fman_get_max_frm();\n\tmemac->memac_drv_param->reset_on_init = true;\n\n\terr = of_property_match_string(mac_node, \"pcs-handle-names\", \"xfi\");\n\tif (err >= 0) {\n\t\tmemac->xfi_pcs = memac_pcs_create(mac_node, err);\n\t\tif (IS_ERR(memac->xfi_pcs)) {\n\t\t\terr = PTR_ERR(memac->xfi_pcs);\n\t\t\tdev_err_probe(mac_dev->dev, err, \"missing xfi pcs\\n\");\n\t\t\tgoto _return_fm_mac_free;\n\t\t}\n\t} else if (err != -EINVAL && err != -ENODATA) {\n\t\tgoto _return_fm_mac_free;\n\t}\n\n\terr = of_property_match_string(mac_node, \"pcs-handle-names\", \"qsgmii\");\n\tif (err >= 0) {\n\t\tmemac->qsgmii_pcs = memac_pcs_create(mac_node, err);\n\t\tif (IS_ERR(memac->qsgmii_pcs)) {\n\t\t\terr = PTR_ERR(memac->qsgmii_pcs);\n\t\t\tdev_err_probe(mac_dev->dev, err,\n\t\t\t\t      \"missing qsgmii pcs\\n\");\n\t\t\tgoto _return_fm_mac_free;\n\t\t}\n\t} else if (err != -EINVAL && err != -ENODATA) {\n\t\tgoto _return_fm_mac_free;\n\t}\n\n\t \n\terr = of_property_match_string(mac_node, \"pcs-handle-names\", \"sgmii\");\n\tif (err == -EINVAL || err == -ENODATA)\n\t\tpcs = memac_pcs_create(mac_node, 0);\n\telse if (err < 0)\n\t\tgoto _return_fm_mac_free;\n\telse\n\t\tpcs = memac_pcs_create(mac_node, err);\n\n\tif (IS_ERR(pcs)) {\n\t\terr = PTR_ERR(pcs);\n\t\tdev_err_probe(mac_dev->dev, err, \"missing pcs\\n\");\n\t\tgoto _return_fm_mac_free;\n\t}\n\n\t \n\tif (err && mac_dev->phy_if == PHY_INTERFACE_MODE_XGMII)\n\t\tmemac->xfi_pcs = pcs;\n\telse\n\t\tmemac->sgmii_pcs = pcs;\n\n\tmemac->serdes = devm_of_phy_optional_get(mac_dev->dev, mac_node,\n\t\t\t\t\t\t \"serdes\");\n\tif (!memac->serdes) {\n\t\tdev_dbg(mac_dev->dev, \"could not get (optional) serdes\\n\");\n\t} else if (IS_ERR(memac->serdes)) {\n\t\terr = PTR_ERR(memac->serdes);\n\t\tgoto _return_fm_mac_free;\n\t}\n\n\t \n\tif (mac_dev->phy_if == PHY_INTERFACE_MODE_XGMII)\n\t\tmac_dev->phy_if = PHY_INTERFACE_MODE_10GBASER;\n\n\t \n\tsupported = mac_dev->phylink_config.supported_interfaces;\n\n\t \n\n\tif (memac->sgmii_pcs &&\n\t    (memac_supports(mac_dev, PHY_INTERFACE_MODE_SGMII) ||\n\t     memac_supports(mac_dev, PHY_INTERFACE_MODE_1000BASEX))) {\n\t\t__set_bit(PHY_INTERFACE_MODE_SGMII, supported);\n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX, supported);\n\t}\n\n\tif (memac->sgmii_pcs &&\n\t    memac_supports(mac_dev, PHY_INTERFACE_MODE_2500BASEX))\n\t\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, supported);\n\n\tif (memac->qsgmii_pcs &&\n\t    memac_supports(mac_dev, PHY_INTERFACE_MODE_QSGMII))\n\t\t__set_bit(PHY_INTERFACE_MODE_QSGMII, supported);\n\telse if (mac_dev->phy_if == PHY_INTERFACE_MODE_QSGMII)\n\t\tdev_warn(mac_dev->dev, \"no QSGMII pcs specified\\n\");\n\n\tif (memac->xfi_pcs &&\n\t    memac_supports(mac_dev, PHY_INTERFACE_MODE_10GBASER)) {\n\t\t__set_bit(PHY_INTERFACE_MODE_10GBASER, supported);\n\t} else {\n\t\t \n\t\tphy_interface_set_rgmii(supported);\n\t\t__set_bit(PHY_INTERFACE_MODE_MII, supported);\n\t}\n\n\tcapabilities = MAC_SYM_PAUSE | MAC_ASYM_PAUSE | MAC_10 | MAC_100;\n\tcapabilities |= MAC_1000FD | MAC_2500FD | MAC_10000FD;\n\n\t \n\tif (of_machine_is_compatible(\"fsl,ls1043a\") ||\n\t    of_machine_is_compatible(\"fsl,ls1046a\") ||\n\t    of_machine_is_compatible(\"fsl,B4QDS\"))\n\t\tcapabilities &= ~(MAC_10HD | MAC_100HD);\n\n\tmac_dev->phylink_config.mac_capabilities = capabilities;\n\n\t \n\tif (of_machine_is_compatible(\"fsl,T2080QDS\") ||\n\t    of_machine_is_compatible(\"fsl,T2080RDB\") ||\n\t    of_machine_is_compatible(\"fsl,T2081QDS\") ||\n\t    of_machine_is_compatible(\"fsl,T4240QDS\") ||\n\t    of_machine_is_compatible(\"fsl,T4240RDB\"))\n\t\tmemac->rgmii_no_half_duplex = true;\n\n\t \n\tfixed = of_get_child_by_name(mac_node, \"fixed-link\");\n\tif (!fixed && !of_property_read_bool(mac_node, \"fixed-link\") &&\n\t    !of_property_read_bool(mac_node, \"managed\") &&\n\t    mac_dev->phy_if != PHY_INTERFACE_MODE_MII &&\n\t    !phy_interface_mode_is_rgmii(mac_dev->phy_if))\n\t\tmac_dev->phylink_config.ovr_an_inband = true;\n\tof_node_put(fixed);\n\n\terr = memac_init(mac_dev->fman_mac);\n\tif (err < 0)\n\t\tgoto _return_fm_mac_free;\n\n\tdev_info(mac_dev->dev, \"FMan MEMAC\\n\");\n\n\treturn 0;\n\n_return_fm_mac_free:\n\tmemac_free(mac_dev->fman_mac);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}