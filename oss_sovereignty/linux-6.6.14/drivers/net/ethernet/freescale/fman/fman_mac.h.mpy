{
  "module_name": "fman_mac.h",
  "hash_id": "4f78a40a1aaea69b8426acc68a0c68ef6aface238bbadd2f4f6bac35fe8120c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fman/fman_mac.h",
  "human_readable_source": " \n\n \n#ifndef __FM_MAC_H\n#define __FM_MAC_H\n\n#include \"fman.h\"\n\n#include <linux/slab.h>\n#include <linux/phy.h>\n#include <linux/if_ether.h>\n\nstruct fman_mac;\nstruct mac_device;\n\n \ntypedef u8 enet_addr_t[ETH_ALEN];\n\n#define ENET_ADDR_TO_UINT64(_enet_addr)\t\t\\\n\t(u64)(((u64)(_enet_addr)[0] << 40) |\t\t\\\n\t      ((u64)(_enet_addr)[1] << 32) |\t\t\\\n\t      ((u64)(_enet_addr)[2] << 24) |\t\t\\\n\t      ((u64)(_enet_addr)[3] << 16) |\t\t\\\n\t      ((u64)(_enet_addr)[4] << 8) |\t\t\\\n\t      ((u64)(_enet_addr)[5]))\n\n#define MAKE_ENET_ADDR_FROM_UINT64(_addr64, _enet_addr) \\\n\tdo { \\\n\t\tint i; \\\n\t\tfor (i = 0; i < ETH_ALEN; i++) \\\n\t\t\t(_enet_addr)[i] = \\\n\t\t\t(u8)((_addr64) >> ((5 - i) * 8)); \\\n\t} while (0)\n\n \n#define DEFAULT_RESET_ON_INIT                 false\n\n \n#define FSL_FM_PAUSE_TIME_ENABLE\t0xf000\n#define FSL_FM_PAUSE_TIME_DISABLE\t0\n#define FSL_FM_PAUSE_THRESH_DEFAULT\t0\n\n#define FM_MAC_NO_PFC   0xff\n\n \n#define ETH_HASH_ENTRY_OBJ(ptr)\t\\\n\thlist_entry_safe(ptr, struct eth_hash_entry, node)\n\n \nenum fman_mac_exceptions {\n\tFM_MAC_EX_10G_MDIO_SCAN_EVENT = 0\n\t \n\t, FM_MAC_EX_10G_MDIO_CMD_CMPL\n\t \n\t, FM_MAC_EX_10G_REM_FAULT\n\t \n\t, FM_MAC_EX_10G_LOC_FAULT\n\t \n\t, FM_MAC_EX_10G_TX_ECC_ER\n\t \n\t, FM_MAC_EX_10G_TX_FIFO_UNFL\n\t \n\t, FM_MAC_EX_10G_TX_FIFO_OVFL\n\t \n\t, FM_MAC_EX_10G_TX_ER\n\t \n\t, FM_MAC_EX_10G_RX_FIFO_OVFL\n\t \n\t, FM_MAC_EX_10G_RX_ECC_ER\n\t \n\t, FM_MAC_EX_10G_RX_JAB_FRM\n\t \n\t, FM_MAC_EX_10G_RX_OVRSZ_FRM\n\t \n\t, FM_MAC_EX_10G_RX_RUNT_FRM\n\t \n\t, FM_MAC_EX_10G_RX_FRAG_FRM\n\t \n\t, FM_MAC_EX_10G_RX_LEN_ER\n\t \n\t, FM_MAC_EX_10G_RX_CRC_ER\n\t \n\t, FM_MAC_EX_10G_RX_ALIGN_ER\n\t \n\t, FM_MAC_EX_1G_BAB_RX\n\t \n\t, FM_MAC_EX_1G_RX_CTL\n\t \n\t, FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET\n\t \n\t, FM_MAC_EX_1G_BAB_TX\n\t \n\t, FM_MAC_EX_1G_TX_CTL\n\t \n\t, FM_MAC_EX_1G_TX_ERR\n\t \n\t, FM_MAC_EX_1G_LATE_COL\n\t \n\t, FM_MAC_EX_1G_COL_RET_LMT\n\t \n\t, FM_MAC_EX_1G_TX_FIFO_UNDRN\n\t \n\t, FM_MAC_EX_1G_MAG_PCKT\n\t \n\t, FM_MAC_EX_1G_MII_MNG_RD_COMPLET\n\t \n\t, FM_MAC_EX_1G_MII_MNG_WR_COMPLET\n\t \n\t, FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET\n\t \n\t, FM_MAC_EX_1G_DATA_ERR\n\t \n\t, FM_MAC_1G_RX_DATA_ERR\n\t \n\t, FM_MAC_EX_1G_1588_TS_RX_ERR\n\t \n\t, FM_MAC_EX_1G_RX_MIB_CNT_OVFL\n\t \n\t, FM_MAC_EX_TS_FIFO_ECC_ERR\n\t \n\t, FM_MAC_EX_MAGIC_PACKET_INDICATION = FM_MAC_EX_1G_MAG_PCKT\n\t \n};\n\nstruct eth_hash_entry {\n\tu64 addr;\t\t \n\tstruct list_head node;\n};\n\ntypedef void (fman_mac_exception_cb)(struct mac_device *dev_id,\n\t\t\t\t     enum fman_mac_exceptions exceptions);\n\n \nstruct fman_mac_params {\n\t \n\tu8 mac_id;\n\t \n\tvoid *fm;\n\tfman_mac_exception_cb *event_cb;     \n\tfman_mac_exception_cb *exception_cb; \n};\n\nstruct eth_hash_t {\n\tu16 size;\n\tstruct list_head *lsts;\n};\n\nstatic inline struct eth_hash_entry\n*dequeue_addr_from_hash_entry(struct list_head *addr_lst)\n{\n\tstruct eth_hash_entry *hash_entry = NULL;\n\n\tif (!list_empty(addr_lst)) {\n\t\thash_entry = ETH_HASH_ENTRY_OBJ(addr_lst->next);\n\t\tlist_del_init(&hash_entry->node);\n\t}\n\treturn hash_entry;\n}\n\nstatic inline void free_hash_table(struct eth_hash_t *hash)\n{\n\tstruct eth_hash_entry *hash_entry;\n\tint i = 0;\n\n\tif (hash) {\n\t\tif (hash->lsts) {\n\t\t\tfor (i = 0; i < hash->size; i++) {\n\t\t\t\thash_entry =\n\t\t\t\tdequeue_addr_from_hash_entry(&hash->lsts[i]);\n\t\t\t\twhile (hash_entry) {\n\t\t\t\t\tkfree(hash_entry);\n\t\t\t\t\thash_entry =\n\t\t\t\t\tdequeue_addr_from_hash_entry(&hash->\n\t\t\t\t\t\t\t\t     lsts[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tkfree(hash->lsts);\n\t\t}\n\n\t\tkfree(hash);\n\t}\n}\n\nstatic inline struct eth_hash_t *alloc_hash_table(u16 size)\n{\n\tu32 i;\n\tstruct eth_hash_t *hash;\n\n\t \n\thash = kmalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\thash->size = size;\n\n\thash->lsts = kmalloc_array(hash->size, sizeof(struct list_head),\n\t\t\t\t   GFP_KERNEL);\n\tif (!hash->lsts) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < hash->size; i++)\n\t\tINIT_LIST_HEAD(&hash->lsts[i]);\n\n\treturn hash;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}