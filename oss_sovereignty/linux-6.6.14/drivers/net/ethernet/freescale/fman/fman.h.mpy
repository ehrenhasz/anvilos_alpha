{
  "module_name": "fman.h",
  "hash_id": "12c816eeb47fc2b38b1b21b884f5c6bbcd4329b6b7103d4a18e7294b2b039f21",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fman/fman.h",
  "human_readable_source": " \n \n\n#ifndef __FM_H\n#define __FM_H\n\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/of_irq.h>\n\n \n \n#define FM_FD_CMD_FCO                   0x80000000\n#define FM_FD_CMD_RPD                   0x40000000   \n#define FM_FD_CMD_UPD\t\t\t0x20000000   \n#define FM_FD_CMD_DTC                   0x10000000   \n\n \n#define FM_FD_ERR_UNSUPPORTED_FORMAT    0x04000000\n \n#define FM_FD_ERR_LENGTH                0x02000000\n#define FM_FD_ERR_DMA                   0x01000000   \n\n \n#define FM_FD_IPR                       0x00000001\n \n#define FM_FD_ERR_IPR_NCSP              (0x00100000 | FM_FD_IPR)\n \n#define FM_FD_ERR_IPR                   (0x00200000 | FM_FD_IPR)\n \n#define FM_FD_ERR_IPR_TO                (0x00300000 | FM_FD_IPR)\n \n#define FM_FD_ERR_IPRE                  (FM_FD_ERR_IPR & ~FM_FD_IPR)\n\n \n#define FM_FD_ERR_PHYSICAL              0x00080000\n \n#define FM_FD_ERR_SIZE                  0x00040000\n \n#define FM_FD_ERR_CLS_DISCARD           0x00020000\n \n#define FM_FD_ERR_EXTRACTION            0x00008000\n \n#define FM_FD_ERR_NO_SCHEME             0x00004000\n \n#define FM_FD_ERR_KEYSIZE_OVERFLOW      0x00002000\n \n#define FM_FD_ERR_COLOR_RED             0x00000800\n \n#define FM_FD_ERR_COLOR_YELLOW          0x00000400\n \n#define FM_FD_ERR_PRS_TIMEOUT           0x00000080\n \n#define FM_FD_ERR_PRS_ILL_INSTRUCT      0x00000040\n \n#define FM_FD_ERR_PRS_HDR_ERR           0x00000020\n \n#define FM_FD_ERR_BLOCK_LIMIT_EXCEEDED  0x00000008\n\n \n#define FM_FD_RX_STATUS_ERR_NON_FM      0x00400000\n\n \n#define FMAN_BMI_FIFO_UNITS\t\t0x100\n#define OFFSET_UNITS\t\t\t16\n\n \n#define BM_MAX_NUM_OF_POOLS\t\t64  \n#define FMAN_PORT_MAX_EXT_POOLS_NUM\t8   \n\nstruct fman;  \n\n \nenum fman_port_type {\n\tFMAN_PORT_TYPE_TX = 0,\t \n\tFMAN_PORT_TYPE_RX,\t \n};\n\nstruct fman_rev_info {\n\tu8 major;\t\t\t \n\tu8 minor;\t\t\t \n};\n\nenum fman_exceptions {\n\tFMAN_EX_DMA_BUS_ERROR = 0,\t \n\tFMAN_EX_DMA_READ_ECC,\t\t \n\tFMAN_EX_DMA_SYSTEM_WRITE_ECC,\t \n\tFMAN_EX_DMA_FM_WRITE_ECC,\t \n\tFMAN_EX_DMA_SINGLE_PORT_ECC,\t \n\tFMAN_EX_FPM_STALL_ON_TASKS,\t \n\tFMAN_EX_FPM_SINGLE_ECC,\t\t \n\tFMAN_EX_FPM_DOUBLE_ECC,\t\t \n\tFMAN_EX_QMI_SINGLE_ECC,\t \n\tFMAN_EX_QMI_DOUBLE_ECC,\t \n\tFMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID, \n\tFMAN_EX_BMI_LIST_RAM_ECC,\t \n\tFMAN_EX_BMI_STORAGE_PROFILE_ECC, \n\tFMAN_EX_BMI_STATISTICS_RAM_ECC, \n\tFMAN_EX_BMI_DISPATCH_RAM_ECC,\t \n\tFMAN_EX_IRAM_ECC,\t\t \n\tFMAN_EX_MURAM_ECC\t\t \n};\n\n \nstruct fman_prs_result {\n\tu8 lpid;\t\t \n\tu8 shimr;\t\t \n\t__be16 l2r;\t\t \n\t__be16 l3r;\t\t \n\tu8 l4r;\t\t \n\tu8 cplan;\t\t \n\t__be16 nxthdr;\t\t \n\t__be16 cksum;\t\t \n\t \n\t__be16 flags_frag_off;\n\t \n\tu8 route_type;\n\t \n\tu8 rhp_ip_valid;\n\tu8 shim_off[2];\t\t \n\tu8 ip_pid_off;\t\t \n\tu8 eth_off;\t\t \n\tu8 llc_snap_off;\t \n\tu8 vlan_off[2];\t\t \n\tu8 etype_off;\t\t \n\tu8 pppoe_off;\t\t \n\tu8 mpls_off[2];\t\t \n\tu8 ip_off[2];\t\t \n\tu8 gre_off;\t\t \n\tu8 l4_off;\t\t \n\tu8 nxthdr_off;\t\t \n};\n\n \nstruct fman_buffer_prefix_content {\n\t \n\tu16 priv_data_size;\n\t \n\tbool pass_prs_result;\n\t \n\tbool pass_time_stamp;\n\t \n\tbool pass_hash_result;\n\t \n\tu16 data_align;\n};\n\n \nstruct fman_ext_pool_params {\n\tu8 id;\t\t     \n\tu16 size;\t\t     \n};\n\n \nstruct fman_ext_pools {\n\tu8 num_of_pools_used;  \n\tstruct fman_ext_pool_params ext_buf_pool[FMAN_PORT_MAX_EXT_POOLS_NUM];\n\t\t\t\t\t \n};\n\n \nstruct fman_buf_pool_depletion {\n\t \n\tbool pools_grp_mode_enable;\n\t \n\tu8 num_of_pools;\n\t \n\tbool pools_to_consider[BM_MAX_NUM_OF_POOLS];\n\t \n\tbool single_pool_mode_enable;\n\t \n\tbool pools_to_consider_for_single_mode[BM_MAX_NUM_OF_POOLS];\n};\n\n \nenum fman_event_modules {\n\tFMAN_MOD_MAC = 0,\t\t \n\tFMAN_MOD_FMAN_CTRL,\t \n\tFMAN_MOD_DUMMY_LAST\n};\n\n \nenum fman_intr_type {\n\tFMAN_INTR_TYPE_ERR,\n\tFMAN_INTR_TYPE_NORMAL\n};\n\n \nenum fman_inter_module_event {\n\tFMAN_EV_ERR_MAC0 = 0,\t \n\tFMAN_EV_ERR_MAC1,\t\t \n\tFMAN_EV_ERR_MAC2,\t\t \n\tFMAN_EV_ERR_MAC3,\t\t \n\tFMAN_EV_ERR_MAC4,\t\t \n\tFMAN_EV_ERR_MAC5,\t\t \n\tFMAN_EV_ERR_MAC6,\t\t \n\tFMAN_EV_ERR_MAC7,\t\t \n\tFMAN_EV_ERR_MAC8,\t\t \n\tFMAN_EV_ERR_MAC9,\t\t \n\tFMAN_EV_MAC0,\t\t \n\tFMAN_EV_MAC1,\t\t \n\tFMAN_EV_MAC2,\t\t \n\tFMAN_EV_MAC3,\t\t \n\tFMAN_EV_MAC4,\t\t \n\tFMAN_EV_MAC5,\t\t \n\tFMAN_EV_MAC6,\t\t \n\tFMAN_EV_MAC7,\t\t \n\tFMAN_EV_MAC8,\t\t \n\tFMAN_EV_MAC9,\t\t \n\tFMAN_EV_FMAN_CTRL_0,\t \n\tFMAN_EV_FMAN_CTRL_1,\t \n\tFMAN_EV_FMAN_CTRL_2,\t \n\tFMAN_EV_FMAN_CTRL_3,\t \n\tFMAN_EV_CNT\n};\n\nstruct fman_intr_src {\n\tvoid (*isr_cb)(void *src_arg);\n\tvoid *src_handle;\n};\n\n \ntypedef irqreturn_t (fman_exceptions_cb)(struct fman *fman,\n\t\t\t\t\t enum fman_exceptions exception);\n \ntypedef irqreturn_t (fman_bus_error_cb)(struct fman *fman, u8 port_id,\n\t\t\t\t\tu64 addr, u8 tnum, u16 liodn);\n\n \nstruct fman_dts_params {\n\tvoid __iomem *base_addr;                 \n\tstruct resource *res;                    \n\tu8 id;                                   \n\n\tint err_irq;                             \n\n\tu16 clk_freq;                            \n\n\tu32 qman_channel_base;                   \n\tu32 num_of_qman_channels;                \n\n\tstruct resource muram_res;               \n};\n\nstruct fman {\n\tstruct device *dev;\n\tvoid __iomem *base_addr;\n\tstruct fman_intr_src intr_mng[FMAN_EV_CNT];\n\n\tstruct fman_fpm_regs __iomem *fpm_regs;\n\tstruct fman_bmi_regs __iomem *bmi_regs;\n\tstruct fman_qmi_regs __iomem *qmi_regs;\n\tstruct fman_dma_regs __iomem *dma_regs;\n\tstruct fman_hwp_regs __iomem *hwp_regs;\n\tstruct fman_kg_regs __iomem *kg_regs;\n\tfman_exceptions_cb *exception_cb;\n\tfman_bus_error_cb *bus_error_cb;\n\t \n\tspinlock_t spinlock;\n\tstruct fman_state_struct *state;\n\n\tstruct fman_cfg *cfg;\n\tstruct muram_info *muram;\n\tstruct fman_keygen *keygen;\n\t \n\tunsigned long cam_offset;\n\tsize_t cam_size;\n\t \n\tunsigned long fifo_offset;\n\tsize_t fifo_size;\n\n\tu32 liodn_base[64];\n\tu32 liodn_offset[64];\n\n\tstruct fman_dts_params dts_params;\n};\n\n \nstruct fman_port_init_params {\n\tu8 port_id;\t\t\t \n\tenum fman_port_type port_type;\t \n\tu16 port_speed;\t\t\t \n\tu16 liodn_offset;\t\t \n\tu8 num_of_tasks;\t\t \n\tu8 num_of_extra_tasks;\t\t \n\tu8 num_of_open_dmas;\t\t \n\tu8 num_of_extra_open_dmas;\t \n\tu32 size_of_fifo;\t\t \n\tu32 extra_size_of_fifo;\t\t \n\tu8 deq_pipeline_depth;\t\t \n\tu16 max_frame_length;\t\t \n\tu16 liodn_base;\n\t \n};\n\nvoid fman_get_revision(struct fman *fman, struct fman_rev_info *rev_info);\n\nvoid fman_register_intr(struct fman *fman, enum fman_event_modules mod,\n\t\t\tu8 mod_id, enum fman_intr_type intr_type,\n\t\t\tvoid (*f_isr)(void *h_src_arg), void *h_src_arg);\n\nvoid fman_unregister_intr(struct fman *fman, enum fman_event_modules mod,\n\t\t\t  u8 mod_id, enum fman_intr_type intr_type);\n\nint fman_set_port_params(struct fman *fman,\n\t\t\t struct fman_port_init_params *port_params);\n\nint fman_reset_mac(struct fman *fman, u8 mac_id);\n\nu16 fman_get_clock_freq(struct fman *fman);\n\nu32 fman_get_bmi_max_fifo_size(struct fman *fman);\n\nint fman_set_mac_max_frame(struct fman *fman, u8 mac_id, u16 mfl);\n\nu32 fman_get_qman_channel_id(struct fman *fman, u32 port_id);\n\nstruct resource *fman_get_mem_region(struct fman *fman);\n\nu16 fman_get_max_frm(void);\n\nint fman_get_rx_extra_headroom(void);\n\n#ifdef CONFIG_DPAA_ERRATUM_A050385\nbool fman_has_errata_a050385(void);\n#endif\n\nstruct fman *fman_bind(struct device *dev);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}