{
  "module_name": "mac.c",
  "hash_id": "d5092f7c675c6e89af67dc761fe5b4178a3c6b335637806e1b384f3a876ea4f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fman/mac.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/of_net.h>\n#include <linux/of_mdio.h>\n#include <linux/device.h>\n#include <linux/phy.h>\n#include <linux/netdevice.h>\n#include <linux/phy_fixed.h>\n#include <linux/phylink.h>\n#include <linux/etherdevice.h>\n#include <linux/libfdt_env.h>\n#include <linux/platform_device.h>\n\n#include \"mac.h\"\n#include \"fman_mac.h\"\n#include \"fman_dtsec.h\"\n#include \"fman_tgec.h\"\n#include \"fman_memac.h\"\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"FSL FMan MAC API based driver\");\n\nstruct mac_priv_s {\n\tu8\t\t\t\tcell_index;\n\tstruct fman\t\t\t*fman;\n\t \n\tstruct list_head\t\tmc_addr_list;\n\tstruct platform_device\t\t*eth_dev;\n\tu16\t\t\t\tspeed;\n};\n\nstruct mac_address {\n\tu8 addr[ETH_ALEN];\n\tstruct list_head list;\n};\n\nstatic void mac_exception(struct mac_device *mac_dev,\n\t\t\t  enum fman_mac_exceptions ex)\n{\n\tif (ex == FM_MAC_EX_10G_RX_FIFO_OVFL) {\n\t\t \n\t\tmac_dev->set_exception(mac_dev->fman_mac,\n\t\t\t\t       FM_MAC_EX_10G_RX_FIFO_OVFL, false);\n\t\tdev_err(mac_dev->dev, \"10G MAC got RX FIFO Error = %x\\n\", ex);\n\t}\n\n\tdev_dbg(mac_dev->dev, \"%s:%s() -> %d\\n\", KBUILD_BASENAME \".c\",\n\t\t__func__, ex);\n}\n\nint fman_set_multi(struct net_device *net_dev, struct mac_device *mac_dev)\n{\n\tstruct mac_priv_s\t*priv;\n\tstruct mac_address\t*old_addr, *tmp;\n\tstruct netdev_hw_addr\t*ha;\n\tint\t\t\terr;\n\tenet_addr_t\t\t*addr;\n\n\tpriv = mac_dev->priv;\n\n\t \n\tlist_for_each_entry_safe(old_addr, tmp, &priv->mc_addr_list, list) {\n\t\taddr = (enet_addr_t *)old_addr->addr;\n\t\terr = mac_dev->remove_hash_mac_addr(mac_dev->fman_mac, addr);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tlist_del(&old_addr->list);\n\t\tkfree(old_addr);\n\t}\n\n\t \n\tnetdev_for_each_mc_addr(ha, net_dev) {\n\t\taddr = (enet_addr_t *)ha->addr;\n\t\terr = mac_dev->add_hash_mac_addr(mac_dev->fman_mac, addr);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\ttmp = kmalloc(sizeof(*tmp), GFP_ATOMIC);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\n\t\tether_addr_copy(tmp->addr, ha->addr);\n\t\tlist_add(&tmp->list, &priv->mc_addr_list);\n\t}\n\treturn 0;\n}\n\nstatic DEFINE_MUTEX(eth_lock);\n\nstatic struct platform_device *dpaa_eth_add_device(int fman_id,\n\t\t\t\t\t\t   struct mac_device *mac_dev)\n{\n\tstruct platform_device *pdev;\n\tstruct dpaa_eth_data data;\n\tstruct mac_priv_s\t*priv;\n\tstatic int dpaa_eth_dev_cnt;\n\tint ret;\n\n\tpriv = mac_dev->priv;\n\n\tdata.mac_dev = mac_dev;\n\tdata.mac_hw_id = priv->cell_index;\n\tdata.fman_hw_id = fman_id;\n\n\tmutex_lock(&eth_lock);\n\tpdev = platform_device_alloc(\"dpaa-ethernet\", dpaa_eth_dev_cnt);\n\tif (!pdev) {\n\t\tret = -ENOMEM;\n\t\tgoto no_mem;\n\t}\n\n\tpdev->dev.parent = mac_dev->dev;\n\n\tret = platform_device_add_data(pdev, &data, sizeof(data));\n\tif (ret)\n\t\tgoto err;\n\n\tret = platform_device_add(pdev);\n\tif (ret)\n\t\tgoto err;\n\n\tdpaa_eth_dev_cnt++;\n\tmutex_unlock(&eth_lock);\n\n\treturn pdev;\n\nerr:\n\tplatform_device_put(pdev);\nno_mem:\n\tmutex_unlock(&eth_lock);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic const struct of_device_id mac_match[] = {\n\t{ .compatible   = \"fsl,fman-dtsec\", .data = dtsec_initialization },\n\t{ .compatible   = \"fsl,fman-xgec\", .data = tgec_initialization },\n\t{ .compatible\t= \"fsl,fman-memac\", .data = memac_initialization },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mac_match);\n\nstatic int mac_probe(struct platform_device *_of_dev)\n{\n\tint\t\t\t err, i, nph;\n\tint (*init)(struct mac_device *mac_dev, struct device_node *mac_node,\n\t\t    struct fman_mac_params *params);\n\tstruct device\t\t*dev;\n\tstruct device_node\t*mac_node, *dev_node;\n\tstruct mac_device\t*mac_dev;\n\tstruct platform_device\t*of_dev;\n\tstruct mac_priv_s\t*priv;\n\tstruct fman_mac_params\t params;\n\tu32\t\t\t val;\n\tu8\t\t\tfman_id;\n\tphy_interface_t          phy_if;\n\n\tdev = &_of_dev->dev;\n\tmac_node = dev->of_node;\n\tinit = of_device_get_match_data(dev);\n\n\tmac_dev = devm_kzalloc(dev, sizeof(*mac_dev), GFP_KERNEL);\n\tif (!mac_dev)\n\t\treturn -ENOMEM;\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(_of_dev, mac_dev);\n\n\t \n\tmac_dev->priv = priv;\n\tmac_dev->dev = dev;\n\n\tINIT_LIST_HEAD(&priv->mc_addr_list);\n\n\t \n\tdev_node = of_get_parent(mac_node);\n\tif (!dev_node) {\n\t\tdev_err(dev, \"of_get_parent(%pOF) failed\\n\",\n\t\t\tmac_node);\n\t\treturn -EINVAL;\n\t}\n\n\tof_dev = of_find_device_by_node(dev_node);\n\tif (!of_dev) {\n\t\tdev_err(dev, \"of_find_device_by_node(%pOF) failed\\n\", dev_node);\n\t\terr = -EINVAL;\n\t\tgoto _return_of_node_put;\n\t}\n\n\t \n\terr = of_property_read_u32(dev_node, \"cell-index\", &val);\n\tif (err) {\n\t\tdev_err(dev, \"failed to read cell-index for %pOF\\n\", dev_node);\n\t\terr = -EINVAL;\n\t\tgoto _return_of_node_put;\n\t}\n\t \n\tfman_id = (u8)(val + 1);\n\n\tpriv->fman = fman_bind(&of_dev->dev);\n\tif (!priv->fman) {\n\t\tdev_err(dev, \"fman_bind(%pOF) failed\\n\", dev_node);\n\t\terr = -ENODEV;\n\t\tgoto _return_of_node_put;\n\t}\n\n\tof_node_put(dev_node);\n\n\t \n\tmac_dev->res = platform_get_mem_or_io(_of_dev, 0);\n\tif (!mac_dev->res) {\n\t\tdev_err(dev, \"could not get registers\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = devm_request_resource(dev, fman_get_mem_region(priv->fman),\n\t\t\t\t    mac_dev->res);\n\tif (err) {\n\t\tdev_err_probe(dev, err, \"could not request resource\\n\");\n\t\treturn err;\n\t}\n\n\tmac_dev->vaddr = devm_ioremap(dev, mac_dev->res->start,\n\t\t\t\t      resource_size(mac_dev->res));\n\tif (!mac_dev->vaddr) {\n\t\tdev_err(dev, \"devm_ioremap() failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (!of_device_is_available(mac_node))\n\t\treturn -ENODEV;\n\n\t \n\terr = of_property_read_u32(mac_node, \"cell-index\", &val);\n\tif (err) {\n\t\tdev_err(dev, \"failed to read cell-index for %pOF\\n\", mac_node);\n\t\treturn -EINVAL;\n\t}\n\tpriv->cell_index = (u8)val;\n\n\t \n\terr = of_get_mac_address(mac_node, mac_dev->addr);\n\tif (err)\n\t\tdev_warn(dev, \"of_get_mac_address(%pOF) failed\\n\", mac_node);\n\n\t \n\tnph = of_count_phandle_with_args(mac_node, \"fsl,fman-ports\", NULL);\n\tif (unlikely(nph < 0)) {\n\t\tdev_err(dev, \"of_count_phandle_with_args(%pOF, fsl,fman-ports) failed\\n\",\n\t\t\tmac_node);\n\t\treturn nph;\n\t}\n\n\tif (nph != ARRAY_SIZE(mac_dev->port)) {\n\t\tdev_err(dev, \"Not supported number of fman-ports handles of mac node %pOF from device tree\\n\",\n\t\t\tmac_node);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mac_dev->port); i++) {\n\t\t \n\t\tdev_node = of_parse_phandle(mac_node, \"fsl,fman-ports\", i);\n\t\tif (!dev_node) {\n\t\t\tdev_err(dev, \"of_parse_phandle(%pOF, fsl,fman-ports) failed\\n\",\n\t\t\t\tmac_node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tof_dev = of_find_device_by_node(dev_node);\n\t\tif (!of_dev) {\n\t\t\tdev_err(dev, \"of_find_device_by_node(%pOF) failed\\n\",\n\t\t\t\tdev_node);\n\t\t\terr = -EINVAL;\n\t\t\tgoto _return_of_node_put;\n\t\t}\n\n\t\tmac_dev->port[i] = fman_port_bind(&of_dev->dev);\n\t\tif (!mac_dev->port[i]) {\n\t\t\tdev_err(dev, \"dev_get_drvdata(%pOF) failed\\n\",\n\t\t\t\tdev_node);\n\t\t\terr = -EINVAL;\n\t\t\tgoto _return_of_node_put;\n\t\t}\n\t\tof_node_put(dev_node);\n\t}\n\n\t \n\terr = of_get_phy_mode(mac_node, &phy_if);\n\tif (err) {\n\t\tdev_warn(dev,\n\t\t\t \"of_get_phy_mode() for %pOF failed. Defaulting to SGMII\\n\",\n\t\t\t mac_node);\n\t\tphy_if = PHY_INTERFACE_MODE_SGMII;\n\t}\n\tmac_dev->phy_if = phy_if;\n\n\tparams.mac_id\t\t= priv->cell_index;\n\tparams.fm\t\t= (void *)priv->fman;\n\tparams.exception_cb\t= mac_exception;\n\tparams.event_cb\t\t= mac_exception;\n\n\terr = init(mac_dev, mac_node, &params);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!is_zero_ether_addr(mac_dev->addr))\n\t\tdev_info(dev, \"FMan MAC address: %pM\\n\", mac_dev->addr);\n\n\tpriv->eth_dev = dpaa_eth_add_device(fman_id, mac_dev);\n\tif (IS_ERR(priv->eth_dev)) {\n\t\terr = PTR_ERR(priv->eth_dev);\n\t\tdev_err(dev, \"failed to add Ethernet platform device for MAC %d\\n\",\n\t\t\tpriv->cell_index);\n\t\tpriv->eth_dev = NULL;\n\t}\n\n\treturn err;\n\n_return_of_node_put:\n\tof_node_put(dev_node);\n\treturn err;\n}\n\nstatic void mac_remove(struct platform_device *pdev)\n{\n\tstruct mac_device *mac_dev = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister(mac_dev->priv->eth_dev);\n}\n\nstatic struct platform_driver mac_driver = {\n\t.driver = {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.of_match_table\t= mac_match,\n\t},\n\t.probe\t\t= mac_probe,\n\t.remove_new\t= mac_remove,\n};\n\nbuiltin_platform_driver(mac_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}