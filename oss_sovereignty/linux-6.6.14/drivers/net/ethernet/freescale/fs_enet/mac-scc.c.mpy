{
  "module_name": "mac-scc.c",
  "hash_id": "aaee1f22af3b31c70f536d292c82975be0eb09b6515c485325b1a1b05a309450",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fs_enet/mac-scc.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/platform_device.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n\n#include \"fs_enet.h\"\n\n \n#if defined(CONFIG_CPM1)\n \n#define __fs_out32(addr, x)\t__raw_writel(x, addr)\n#define __fs_out16(addr, x)\t__raw_writew(x, addr)\n#define __fs_out8(addr, x)\t__raw_writeb(x, addr)\n#define __fs_in32(addr)\t__raw_readl(addr)\n#define __fs_in16(addr)\t__raw_readw(addr)\n#define __fs_in8(addr)\t__raw_readb(addr)\n#else\n \n#define __fs_out32(addr, x)\tout_be32(addr, x)\n#define __fs_out16(addr, x)\tout_be16(addr, x)\n#define __fs_in32(addr)\tin_be32(addr)\n#define __fs_in16(addr)\tin_be16(addr)\n#define __fs_out8(addr, x)\tout_8(addr, x)\n#define __fs_in8(addr)\tin_8(addr)\n#endif\n\n \n#define W32(_p, _m, _v) __fs_out32(&(_p)->_m, (_v))\n#define R32(_p, _m)     __fs_in32(&(_p)->_m)\n#define S32(_p, _m, _v) W32(_p, _m, R32(_p, _m) | (_v))\n#define C32(_p, _m, _v) W32(_p, _m, R32(_p, _m) & ~(_v))\n\n#define W16(_p, _m, _v) __fs_out16(&(_p)->_m, (_v))\n#define R16(_p, _m)     __fs_in16(&(_p)->_m)\n#define S16(_p, _m, _v) W16(_p, _m, R16(_p, _m) | (_v))\n#define C16(_p, _m, _v) W16(_p, _m, R16(_p, _m) & ~(_v))\n\n#define W8(_p, _m, _v)  __fs_out8(&(_p)->_m, (_v))\n#define R8(_p, _m)      __fs_in8(&(_p)->_m)\n#define S8(_p, _m, _v)  W8(_p, _m, R8(_p, _m) | (_v))\n#define C8(_p, _m, _v)  W8(_p, _m, R8(_p, _m) & ~(_v))\n\n#define SCC_MAX_MULTICAST_ADDRS\t64\n\n \n#define SCC_RESET_DELAY\t\t50\n\nstatic inline int scc_cr_cmd(struct fs_enet_private *fep, u32 op)\n{\n\tconst struct fs_platform_info *fpi = fep->fpi;\n\n\treturn cpm_command(fpi->cp_command, op);\n}\n\nstatic int do_pd_setup(struct fs_enet_private *fep)\n{\n\tstruct platform_device *ofdev = to_platform_device(fep->dev);\n\n\tfep->interrupt = irq_of_parse_and_map(ofdev->dev.of_node, 0);\n\tif (!fep->interrupt)\n\t\treturn -EINVAL;\n\n\tfep->scc.sccp = of_iomap(ofdev->dev.of_node, 0);\n\tif (!fep->scc.sccp)\n\t\treturn -EINVAL;\n\n\tfep->scc.ep = of_iomap(ofdev->dev.of_node, 1);\n\tif (!fep->scc.ep) {\n\t\tiounmap(fep->scc.sccp);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#define SCC_NAPI_EVENT_MSK\t(SCCE_ENET_RXF | SCCE_ENET_RXB | SCCE_ENET_TXB)\n#define SCC_EVENT\t\t(SCCE_ENET_RXF | SCCE_ENET_TXB)\n#define SCC_ERR_EVENT_MSK\t(SCCE_ENET_TXE | SCCE_ENET_BSY)\n\nstatic int setup_data(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\tdo_pd_setup(fep);\n\n\tfep->scc.hthi = 0;\n\tfep->scc.htlo = 0;\n\n\tfep->ev_napi = SCC_NAPI_EVENT_MSK;\n\tfep->ev = SCC_EVENT | SCCE_ENET_TXE;\n\tfep->ev_err = SCC_ERR_EVENT_MSK;\n\n\treturn 0;\n}\n\nstatic int allocate_bd(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tconst struct fs_platform_info *fpi = fep->fpi;\n\n\tfep->ring_mem_addr = cpm_muram_alloc((fpi->tx_ring + fpi->rx_ring) *\n\t\t\t\t\t     sizeof(cbd_t), 8);\n\tif (IS_ERR_VALUE(fep->ring_mem_addr))\n\t\treturn -ENOMEM;\n\n\tfep->ring_base = (void __iomem __force*)\n\t\tcpm_muram_addr(fep->ring_mem_addr);\n\n\treturn 0;\n}\n\nstatic void free_bd(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\tif (fep->ring_base)\n\t\tcpm_muram_free(fep->ring_mem_addr);\n}\n\nstatic void cleanup_data(struct net_device *dev)\n{\n\t \n}\n\nstatic void set_promiscuous_mode(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tscc_t __iomem *sccp = fep->scc.sccp;\n\n\tS16(sccp, scc_psmr, SCC_PSMR_PRO);\n}\n\nstatic void set_multicast_start(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tscc_enet_t __iomem *ep = fep->scc.ep;\n\n\tW16(ep, sen_gaddr1, 0);\n\tW16(ep, sen_gaddr2, 0);\n\tW16(ep, sen_gaddr3, 0);\n\tW16(ep, sen_gaddr4, 0);\n}\n\nstatic void set_multicast_one(struct net_device *dev, const u8 * mac)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tscc_enet_t __iomem *ep = fep->scc.ep;\n\tu16 taddrh, taddrm, taddrl;\n\n\ttaddrh = ((u16) mac[5] << 8) | mac[4];\n\ttaddrm = ((u16) mac[3] << 8) | mac[2];\n\ttaddrl = ((u16) mac[1] << 8) | mac[0];\n\n\tW16(ep, sen_taddrh, taddrh);\n\tW16(ep, sen_taddrm, taddrm);\n\tW16(ep, sen_taddrl, taddrl);\n\tscc_cr_cmd(fep, CPM_CR_SET_GADDR);\n}\n\nstatic void set_multicast_finish(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tscc_t __iomem *sccp = fep->scc.sccp;\n\tscc_enet_t __iomem *ep = fep->scc.ep;\n\n\t \n\tC16(sccp, scc_psmr, SCC_PSMR_PRO);\n\n\t \n\tif ((dev->flags & IFF_ALLMULTI) != 0 ||\n\t    netdev_mc_count(dev) > SCC_MAX_MULTICAST_ADDRS) {\n\n\t\tW16(ep, sen_gaddr1, 0xffff);\n\t\tW16(ep, sen_gaddr2, 0xffff);\n\t\tW16(ep, sen_gaddr3, 0xffff);\n\t\tW16(ep, sen_gaddr4, 0xffff);\n\t}\n}\n\nstatic void set_multicast_list(struct net_device *dev)\n{\n\tstruct netdev_hw_addr *ha;\n\n\tif ((dev->flags & IFF_PROMISC) == 0) {\n\t\tset_multicast_start(dev);\n\t\tnetdev_for_each_mc_addr(ha, dev)\n\t\t\tset_multicast_one(dev, ha->addr);\n\t\tset_multicast_finish(dev);\n\t} else\n\t\tset_promiscuous_mode(dev);\n}\n\n \nstatic void restart(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tscc_t __iomem *sccp = fep->scc.sccp;\n\tscc_enet_t __iomem *ep = fep->scc.ep;\n\tconst struct fs_platform_info *fpi = fep->fpi;\n\tu16 paddrh, paddrm, paddrl;\n\tconst unsigned char *mac;\n\tint i;\n\n\tC32(sccp, scc_gsmrl, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\n\n\t \n\tfor (i = 0; i < sizeof(*ep); i++)\n\t\t__fs_out8((u8 __iomem *)ep + i, 0);\n\n\t \n\tW16(ep, sen_genscc.scc_rbase, fep->ring_mem_addr);\n\tW16(ep, sen_genscc.scc_tbase,\n\t    fep->ring_mem_addr + sizeof(cbd_t) * fpi->rx_ring);\n\n\t \n#ifndef CONFIG_NOT_COHERENT_CACHE\n\tW8(ep, sen_genscc.scc_rfcr, SCC_EB | SCC_GBL);\n\tW8(ep, sen_genscc.scc_tfcr, SCC_EB | SCC_GBL);\n#else\n\tW8(ep, sen_genscc.scc_rfcr, SCC_EB);\n\tW8(ep, sen_genscc.scc_tfcr, SCC_EB);\n#endif\n\n\t \n\tW16(ep, sen_genscc.scc_mrblr, 0x5f0);\n\n\t \n\tW32(ep, sen_cpres, 0xffffffff);\n\tW32(ep, sen_cmask, 0xdebb20e3);\n\n\tW32(ep, sen_crcec, 0);\t \n\tW32(ep, sen_alec, 0);\t \n\tW32(ep, sen_disfc, 0);\t \n\n\tW16(ep, sen_pads, 0x8888);\t \n\tW16(ep, sen_retlim, 15);\t \n\n\tW16(ep, sen_maxflr, 0x5ee);\t \n\n\tW16(ep, sen_minflr, PKT_MINBUF_SIZE);\t \n\n\tW16(ep, sen_maxd1, 0x000005f0);\t \n\tW16(ep, sen_maxd2, 0x000005f0);\t \n\n\t \n\tW16(ep, sen_gaddr1, 0);\n\tW16(ep, sen_gaddr2, 0);\n\tW16(ep, sen_gaddr3, 0);\n\tW16(ep, sen_gaddr4, 0);\n\tW16(ep, sen_iaddr1, 0);\n\tW16(ep, sen_iaddr2, 0);\n\tW16(ep, sen_iaddr3, 0);\n\tW16(ep, sen_iaddr4, 0);\n\n\t \n\tmac = dev->dev_addr;\n\tpaddrh = ((u16) mac[5] << 8) | mac[4];\n\tpaddrm = ((u16) mac[3] << 8) | mac[2];\n\tpaddrl = ((u16) mac[1] << 8) | mac[0];\n\n\tW16(ep, sen_paddrh, paddrh);\n\tW16(ep, sen_paddrm, paddrm);\n\tW16(ep, sen_paddrl, paddrl);\n\n\tW16(ep, sen_pper, 0);\n\tW16(ep, sen_taddrl, 0);\n\tW16(ep, sen_taddrm, 0);\n\tW16(ep, sen_taddrh, 0);\n\n\tfs_init_bds(dev);\n\n\tscc_cr_cmd(fep, CPM_CR_INIT_TRX);\n\n\tW16(sccp, scc_scce, 0xffff);\n\n\t \n\tW16(sccp, scc_sccm, SCCE_ENET_TXE | SCCE_ENET_RXF | SCCE_ENET_TXB);\n\n\t \n\tW32(sccp, scc_gsmrh, 0);\n\tW32(sccp, scc_gsmrl,\n\t    SCC_GSMRL_TCI | SCC_GSMRL_TPL_48 | SCC_GSMRL_TPP_10 |\n\t    SCC_GSMRL_MODE_ENET);\n\n\t \n\tW16(sccp, scc_dsr, 0xd555);\n\n\t \n\tW16(sccp, scc_psmr, SCC_PSMR_ENCRC | SCC_PSMR_NIB22);\n\n\t \n\tif (dev->phydev->duplex)\n\t\tS16(sccp, scc_psmr, SCC_PSMR_LPB | SCC_PSMR_FDE);\n\n\t \n\tset_multicast_list(dev);\n\n\tS32(sccp, scc_gsmrl, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\n}\n\nstatic void stop(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tscc_t __iomem *sccp = fep->scc.sccp;\n\tint i;\n\n\tfor (i = 0; (R16(sccp, scc_sccm) == 0) && i < SCC_RESET_DELAY; i++)\n\t\tudelay(1);\n\n\tif (i == SCC_RESET_DELAY)\n\t\tdev_warn(fep->dev, \"SCC timeout on graceful transmit stop\\n\");\n\n\tW16(sccp, scc_sccm, 0);\n\tC32(sccp, scc_gsmrl, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\n\n\tfs_cleanup_bds(dev);\n}\n\nstatic void napi_clear_event_fs(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tscc_t __iomem *sccp = fep->scc.sccp;\n\n\tW16(sccp, scc_scce, SCC_NAPI_EVENT_MSK);\n}\n\nstatic void napi_enable_fs(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tscc_t __iomem *sccp = fep->scc.sccp;\n\n\tS16(sccp, scc_sccm, SCC_NAPI_EVENT_MSK);\n}\n\nstatic void napi_disable_fs(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tscc_t __iomem *sccp = fep->scc.sccp;\n\n\tC16(sccp, scc_sccm, SCC_NAPI_EVENT_MSK);\n}\n\nstatic void rx_bd_done(struct net_device *dev)\n{\n\t \n}\n\nstatic void tx_kickstart(struct net_device *dev)\n{\n\t \n}\n\nstatic u32 get_int_events(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tscc_t __iomem *sccp = fep->scc.sccp;\n\n\treturn (u32) R16(sccp, scc_scce);\n}\n\nstatic void clear_int_events(struct net_device *dev, u32 int_events)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tscc_t __iomem *sccp = fep->scc.sccp;\n\n\tW16(sccp, scc_scce, int_events & 0xffff);\n}\n\nstatic void ev_error(struct net_device *dev, u32 int_events)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\tdev_warn(fep->dev, \"SCC ERROR(s) 0x%x\\n\", int_events);\n}\n\nstatic int get_regs(struct net_device *dev, void *p, int *sizep)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\tif (*sizep < sizeof(scc_t) + sizeof(scc_enet_t __iomem *))\n\t\treturn -EINVAL;\n\n\tmemcpy_fromio(p, fep->scc.sccp, sizeof(scc_t));\n\tp = (char *)p + sizeof(scc_t);\n\n\tmemcpy_fromio(p, fep->scc.ep, sizeof(scc_enet_t __iomem *));\n\n\treturn 0;\n}\n\nstatic int get_regs_len(struct net_device *dev)\n{\n\treturn sizeof(scc_t) + sizeof(scc_enet_t __iomem *);\n}\n\nstatic void tx_restart(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\tscc_cr_cmd(fep, CPM_CR_RESTART_TX);\n}\n\n\n\n \n\nconst struct fs_ops fs_scc_ops = {\n\t.setup_data\t\t= setup_data,\n\t.cleanup_data\t\t= cleanup_data,\n\t.set_multicast_list\t= set_multicast_list,\n\t.restart\t\t= restart,\n\t.stop\t\t\t= stop,\n\t.napi_clear_event\t= napi_clear_event_fs,\n\t.napi_enable\t\t= napi_enable_fs,\n\t.napi_disable\t\t= napi_disable_fs,\n\t.rx_bd_done\t\t= rx_bd_done,\n\t.tx_kickstart\t\t= tx_kickstart,\n\t.get_int_events\t\t= get_int_events,\n\t.clear_int_events\t= clear_int_events,\n\t.ev_error\t\t= ev_error,\n\t.get_regs\t\t= get_regs,\n\t.get_regs_len\t\t= get_regs_len,\n\t.tx_restart\t\t= tx_restart,\n\t.allocate_bd\t\t= allocate_bd,\n\t.free_bd\t\t= free_bd,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}