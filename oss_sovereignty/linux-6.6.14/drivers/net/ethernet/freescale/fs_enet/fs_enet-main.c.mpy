{
  "module_name": "fs_enet-main.c",
  "hash_id": "9ef1f4a65f68562cc94cb9c207e29d5c353c85e42a1aa71d7b73494658b15e72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/platform_device.h>\n#include <linux/phy.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_platform.h>\n#include <linux/of_gpio.h>\n#include <linux/of_net.h>\n#include <linux/pgtable.h>\n\n#include <linux/vmalloc.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n\n#include \"fs_enet.h\"\n\n \n\nMODULE_AUTHOR(\"Pantelis Antoniou <panto@intracom.gr>\");\nMODULE_DESCRIPTION(\"Freescale Ethernet Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int fs_enet_debug = -1;  \nmodule_param(fs_enet_debug, int, 0);\nMODULE_PARM_DESC(fs_enet_debug,\n\t\t \"Freescale bitmapped debugging message enable value\");\n\n#define RX_RING_SIZE\t32\n#define TX_RING_SIZE\t64\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void fs_enet_netpoll(struct net_device *dev);\n#endif\n\nstatic void fs_set_multicast_list(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\t(*fep->ops->set_multicast_list)(dev);\n}\n\nstatic void skb_align(struct sk_buff *skb, int align)\n{\n\tint off = ((unsigned long)skb->data) & (align - 1);\n\n\tif (off)\n\t\tskb_reserve(skb, align - off);\n}\n\n \nstatic int fs_enet_napi(struct napi_struct *napi, int budget)\n{\n\tstruct fs_enet_private *fep = container_of(napi, struct fs_enet_private, napi);\n\tstruct net_device *dev = fep->ndev;\n\tconst struct fs_platform_info *fpi = fep->fpi;\n\tcbd_t __iomem *bdp;\n\tstruct sk_buff *skb, *skbn;\n\tint received = 0;\n\tu16 pkt_len, sc;\n\tint curidx;\n\tint dirtyidx, do_wake, do_restart;\n\tint tx_left = TX_RING_SIZE;\n\n\tspin_lock(&fep->tx_lock);\n\tbdp = fep->dirty_tx;\n\n\t \n\t(*fep->ops->napi_clear_event)(dev);\n\n\tdo_wake = do_restart = 0;\n\twhile (((sc = CBDR_SC(bdp)) & BD_ENET_TX_READY) == 0 && tx_left) {\n\t\tdirtyidx = bdp - fep->tx_bd_base;\n\n\t\tif (fep->tx_free == fep->tx_ring)\n\t\t\tbreak;\n\n\t\tskb = fep->tx_skbuff[dirtyidx];\n\n\t\t \n\t\tif (sc & (BD_ENET_TX_HB | BD_ENET_TX_LC |\n\t\t\t  BD_ENET_TX_RL | BD_ENET_TX_UN | BD_ENET_TX_CSL)) {\n\n\t\t\tif (sc & BD_ENET_TX_HB)\t \n\t\t\t\tdev->stats.tx_heartbeat_errors++;\n\t\t\tif (sc & BD_ENET_TX_LC)\t \n\t\t\t\tdev->stats.tx_window_errors++;\n\t\t\tif (sc & BD_ENET_TX_RL)\t \n\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\tif (sc & BD_ENET_TX_UN)\t \n\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\tif (sc & BD_ENET_TX_CSL)\t \n\t\t\t\tdev->stats.tx_carrier_errors++;\n\n\t\t\tif (sc & (BD_ENET_TX_LC | BD_ENET_TX_RL | BD_ENET_TX_UN)) {\n\t\t\t\tdev->stats.tx_errors++;\n\t\t\t\tdo_restart = 1;\n\t\t\t}\n\t\t} else\n\t\t\tdev->stats.tx_packets++;\n\n\t\tif (sc & BD_ENET_TX_READY) {\n\t\t\tdev_warn(fep->dev,\n\t\t\t\t \"HEY! Enet xmit interrupt and TX_READY.\\n\");\n\t\t}\n\n\t\t \n\t\tif (sc & BD_ENET_TX_DEF)\n\t\t\tdev->stats.collisions++;\n\n\t\t \n\t\tif (fep->mapped_as_page[dirtyidx])\n\t\t\tdma_unmap_page(fep->dev, CBDR_BUFADDR(bdp),\n\t\t\t\t       CBDR_DATLEN(bdp), DMA_TO_DEVICE);\n\t\telse\n\t\t\tdma_unmap_single(fep->dev, CBDR_BUFADDR(bdp),\n\t\t\t\t\t CBDR_DATLEN(bdp), DMA_TO_DEVICE);\n\n\t\t \n\t\tif (skb) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tfep->tx_skbuff[dirtyidx] = NULL;\n\t\t}\n\n\t\t \n\t\tif ((sc & BD_ENET_TX_WRAP) == 0)\n\t\t\tbdp++;\n\t\telse\n\t\t\tbdp = fep->tx_bd_base;\n\n\t\t \n\t\tif (++fep->tx_free == MAX_SKB_FRAGS)\n\t\t\tdo_wake = 1;\n\t\ttx_left--;\n\t}\n\n\tfep->dirty_tx = bdp;\n\n\tif (do_restart)\n\t\t(*fep->ops->tx_restart)(dev);\n\n\tspin_unlock(&fep->tx_lock);\n\n\tif (do_wake)\n\t\tnetif_wake_queue(dev);\n\n\t \n\tbdp = fep->cur_rx;\n\n\twhile (((sc = CBDR_SC(bdp)) & BD_ENET_RX_EMPTY) == 0 &&\n\t       received < budget) {\n\t\tcuridx = bdp - fep->rx_bd_base;\n\n\t\t \n\t\tif ((sc & BD_ENET_RX_LAST) == 0)\n\t\t\tdev_warn(fep->dev, \"rcv is not +last\\n\");\n\n\t\t \n\t\tif (sc & (BD_ENET_RX_LG | BD_ENET_RX_SH | BD_ENET_RX_CL |\n\t\t\t  BD_ENET_RX_NO | BD_ENET_RX_CR | BD_ENET_RX_OV)) {\n\t\t\tdev->stats.rx_errors++;\n\t\t\t \n\t\t\tif (sc & (BD_ENET_RX_LG | BD_ENET_RX_SH))\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t \n\t\t\tif (sc & (BD_ENET_RX_NO | BD_ENET_RX_CL))\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\t \n\t\t\tif (sc & BD_ENET_RX_CR)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t \n\t\t\tif (sc & BD_ENET_RX_OV)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\n\t\t\tskbn = fep->rx_skbuff[curidx];\n\t\t} else {\n\t\t\tskb = fep->rx_skbuff[curidx];\n\n\t\t\t \n\t\t\tdev->stats.rx_packets++;\n\t\t\tpkt_len = CBDR_DATLEN(bdp) - 4;\t \n\t\t\tdev->stats.rx_bytes += pkt_len + 4;\n\n\t\t\tif (pkt_len <= fpi->rx_copybreak) {\n\t\t\t\t \n\t\t\t\tskbn = netdev_alloc_skb(dev, pkt_len + 2);\n\t\t\t\tif (skbn != NULL) {\n\t\t\t\t\tskb_reserve(skbn, 2);\t \n\t\t\t\t\tskb_copy_from_linear_data(skb,\n\t\t\t\t\t\t      skbn->data, pkt_len);\n\t\t\t\t\tswap(skb, skbn);\n\t\t\t\t\tdma_sync_single_for_cpu(fep->dev,\n\t\t\t\t\t\tCBDR_BUFADDR(bdp),\n\t\t\t\t\t\tL1_CACHE_ALIGN(pkt_len),\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tskbn = netdev_alloc_skb(dev, ENET_RX_FRSIZE);\n\n\t\t\t\tif (skbn) {\n\t\t\t\t\tdma_addr_t dma;\n\n\t\t\t\t\tskb_align(skbn, ENET_RX_ALIGN);\n\n\t\t\t\t\tdma_unmap_single(fep->dev,\n\t\t\t\t\t\tCBDR_BUFADDR(bdp),\n\t\t\t\t\t\tL1_CACHE_ALIGN(PKT_MAXBUF_SIZE),\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\t\t\t\tdma = dma_map_single(fep->dev,\n\t\t\t\t\t\tskbn->data,\n\t\t\t\t\t\tL1_CACHE_ALIGN(PKT_MAXBUF_SIZE),\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\t\tCBDW_BUFADDR(bdp, dma);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skbn != NULL) {\n\t\t\t\tskb_put(skb, pkt_len);\t \n\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t\treceived++;\n\t\t\t\tnetif_receive_skb(skb);\n\t\t\t} else {\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\tskbn = skb;\n\t\t\t}\n\t\t}\n\n\t\tfep->rx_skbuff[curidx] = skbn;\n\t\tCBDW_DATLEN(bdp, 0);\n\t\tCBDW_SC(bdp, (sc & ~BD_ENET_RX_STATS) | BD_ENET_RX_EMPTY);\n\n\t\t \n\t\tif ((sc & BD_ENET_RX_WRAP) == 0)\n\t\t\tbdp++;\n\t\telse\n\t\t\tbdp = fep->rx_bd_base;\n\n\t\t(*fep->ops->rx_bd_done)(dev);\n\t}\n\n\tfep->cur_rx = bdp;\n\n\tif (received < budget && tx_left) {\n\t\t \n\t\tnapi_complete_done(napi, received);\n\t\t(*fep->ops->napi_enable)(dev);\n\n\t\treturn received;\n\t}\n\n\treturn budget;\n}\n\n \nstatic irqreturn_t\nfs_enet_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct fs_enet_private *fep;\n\tu32 int_events;\n\tu32 int_clr_events;\n\tint nr, napi_ok;\n\tint handled;\n\n\tfep = netdev_priv(dev);\n\n\tnr = 0;\n\twhile ((int_events = (*fep->ops->get_int_events)(dev)) != 0) {\n\t\tnr++;\n\n\t\tint_clr_events = int_events;\n\t\tint_clr_events &= ~fep->ev_napi;\n\n\t\t(*fep->ops->clear_int_events)(dev, int_clr_events);\n\n\t\tif (int_events & fep->ev_err)\n\t\t\t(*fep->ops->ev_error)(dev, int_events);\n\n\t\tif (int_events & fep->ev) {\n\t\t\tnapi_ok = napi_schedule_prep(&fep->napi);\n\n\t\t\t(*fep->ops->napi_disable)(dev);\n\t\t\t(*fep->ops->clear_int_events)(dev, fep->ev_napi);\n\n\t\t\t \n\t\t\t \n\t\t\tif (napi_ok)\n\t\t\t\t__napi_schedule(&fep->napi);\n\t\t}\n\n\t}\n\n\thandled = nr > 0;\n\treturn IRQ_RETVAL(handled);\n}\n\nvoid fs_init_bds(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tcbd_t __iomem *bdp;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfs_cleanup_bds(dev);\n\n\tfep->dirty_tx = fep->cur_tx = fep->tx_bd_base;\n\tfep->tx_free = fep->tx_ring;\n\tfep->cur_rx = fep->rx_bd_base;\n\n\t \n\tfor (i = 0, bdp = fep->rx_bd_base; i < fep->rx_ring; i++, bdp++) {\n\t\tskb = netdev_alloc_skb(dev, ENET_RX_FRSIZE);\n\t\tif (skb == NULL)\n\t\t\tbreak;\n\n\t\tskb_align(skb, ENET_RX_ALIGN);\n\t\tfep->rx_skbuff[i] = skb;\n\t\tCBDW_BUFADDR(bdp,\n\t\t\tdma_map_single(fep->dev, skb->data,\n\t\t\t\tL1_CACHE_ALIGN(PKT_MAXBUF_SIZE),\n\t\t\t\tDMA_FROM_DEVICE));\n\t\tCBDW_DATLEN(bdp, 0);\t \n\t\tCBDW_SC(bdp, BD_ENET_RX_EMPTY |\n\t\t\t((i < fep->rx_ring - 1) ? 0 : BD_SC_WRAP));\n\t}\n\t \n\tfor (; i < fep->rx_ring; i++, bdp++) {\n\t\tfep->rx_skbuff[i] = NULL;\n\t\tCBDW_SC(bdp, (i < fep->rx_ring - 1) ? 0 : BD_SC_WRAP);\n\t}\n\n\t \n\tfor (i = 0, bdp = fep->tx_bd_base; i < fep->tx_ring; i++, bdp++) {\n\t\tfep->tx_skbuff[i] = NULL;\n\t\tCBDW_BUFADDR(bdp, 0);\n\t\tCBDW_DATLEN(bdp, 0);\n\t\tCBDW_SC(bdp, (i < fep->tx_ring - 1) ? 0 : BD_SC_WRAP);\n\t}\n}\n\nvoid fs_cleanup_bds(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tcbd_t __iomem *bdp;\n\tint i;\n\n\t \n\tfor (i = 0, bdp = fep->tx_bd_base; i < fep->tx_ring; i++, bdp++) {\n\t\tif ((skb = fep->tx_skbuff[i]) == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tdma_unmap_single(fep->dev, CBDR_BUFADDR(bdp),\n\t\t\t\tskb->len, DMA_TO_DEVICE);\n\n\t\tfep->tx_skbuff[i] = NULL;\n\t\tdev_kfree_skb(skb);\n\t}\n\n\t \n\tfor (i = 0, bdp = fep->rx_bd_base; i < fep->rx_ring; i++, bdp++) {\n\t\tif ((skb = fep->rx_skbuff[i]) == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tdma_unmap_single(fep->dev, CBDR_BUFADDR(bdp),\n\t\t\tL1_CACHE_ALIGN(PKT_MAXBUF_SIZE),\n\t\t\tDMA_FROM_DEVICE);\n\n\t\tfep->rx_skbuff[i] = NULL;\n\n\t\tdev_kfree_skb(skb);\n\t}\n}\n\n \n\n#ifdef CONFIG_FS_ENET_MPC5121_FEC\n \nstatic struct sk_buff *tx_skb_align_workaround(struct net_device *dev,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct sk_buff *new_skb;\n\n\tif (skb_linearize(skb))\n\t\treturn NULL;\n\n\t \n\tnew_skb = netdev_alloc_skb(dev, skb->len + 4);\n\tif (!new_skb)\n\t\treturn NULL;\n\n\t \n\tskb_align(new_skb, 4);\n\n\t \n\tskb_copy_from_linear_data(skb, new_skb->data, skb->len);\n\tskb_put(new_skb, skb->len);\n\n\t \n\tdev_kfree_skb_any(skb);\n\n\treturn new_skb;\n}\n#endif\n\nstatic netdev_tx_t\nfs_enet_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tcbd_t __iomem *bdp;\n\tint curidx;\n\tu16 sc;\n\tint nr_frags;\n\tskb_frag_t *frag;\n\tint len;\n#ifdef CONFIG_FS_ENET_MPC5121_FEC\n\tint is_aligned = 1;\n\tint i;\n\n\tif (!IS_ALIGNED((unsigned long)skb->data, 4)) {\n\t\tis_aligned = 0;\n\t} else {\n\t\tnr_frags = skb_shinfo(skb)->nr_frags;\n\t\tfrag = skb_shinfo(skb)->frags;\n\t\tfor (i = 0; i < nr_frags; i++, frag++) {\n\t\t\tif (!IS_ALIGNED(skb_frag_off(frag), 4)) {\n\t\t\t\tis_aligned = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!is_aligned) {\n\t\tskb = tx_skb_align_workaround(dev, skb);\n\t\tif (!skb) {\n\t\t\t \n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t}\n#endif\n\n\tspin_lock(&fep->tx_lock);\n\n\t \n\tbdp = fep->cur_tx;\n\n\tnr_frags = skb_shinfo(skb)->nr_frags;\n\tif (fep->tx_free <= nr_frags || (CBDR_SC(bdp) & BD_ENET_TX_READY)) {\n\t\tnetif_stop_queue(dev);\n\t\tspin_unlock(&fep->tx_lock);\n\n\t\t \n\t\tdev_warn(fep->dev, \"tx queue full!.\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tcuridx = bdp - fep->tx_bd_base;\n\n\tlen = skb->len;\n\tdev->stats.tx_bytes += len;\n\tif (nr_frags)\n\t\tlen -= skb->data_len;\n\tfep->tx_free -= nr_frags + 1;\n\t \n\tCBDW_BUFADDR(bdp, dma_map_single(fep->dev,\n\t\t\t\tskb->data, len, DMA_TO_DEVICE));\n\tCBDW_DATLEN(bdp, len);\n\n\tfep->mapped_as_page[curidx] = 0;\n\tfrag = skb_shinfo(skb)->frags;\n\twhile (nr_frags) {\n\t\tCBDC_SC(bdp,\n\t\t\tBD_ENET_TX_STATS | BD_ENET_TX_INTR | BD_ENET_TX_LAST |\n\t\t\tBD_ENET_TX_TC);\n\t\tCBDS_SC(bdp, BD_ENET_TX_READY);\n\n\t\tif ((CBDR_SC(bdp) & BD_ENET_TX_WRAP) == 0) {\n\t\t\tbdp++;\n\t\t\tcuridx++;\n\t\t} else {\n\t\t\tbdp = fep->tx_bd_base;\n\t\t\tcuridx = 0;\n\t\t}\n\n\t\tlen = skb_frag_size(frag);\n\t\tCBDW_BUFADDR(bdp, skb_frag_dma_map(fep->dev, frag, 0, len,\n\t\t\t\t\t\t   DMA_TO_DEVICE));\n\t\tCBDW_DATLEN(bdp, len);\n\n\t\tfep->tx_skbuff[curidx] = NULL;\n\t\tfep->mapped_as_page[curidx] = 1;\n\n\t\tfrag++;\n\t\tnr_frags--;\n\t}\n\n\t \n\tsc = BD_ENET_TX_READY | BD_ENET_TX_INTR |\n\t     BD_ENET_TX_LAST | BD_ENET_TX_TC;\n\n\t \n\tif (skb->len <= 60)\n\t\tsc |= BD_ENET_TX_PAD;\n\tCBDC_SC(bdp, BD_ENET_TX_STATS);\n\tCBDS_SC(bdp, sc);\n\n\t \n\tfep->tx_skbuff[curidx] = skb;\n\n\t \n\tif ((CBDR_SC(bdp) & BD_ENET_TX_WRAP) == 0)\n\t\tbdp++;\n\telse\n\t\tbdp = fep->tx_bd_base;\n\tfep->cur_tx = bdp;\n\n\tif (fep->tx_free < MAX_SKB_FRAGS)\n\t\tnetif_stop_queue(dev);\n\n\tskb_tx_timestamp(skb);\n\n\t(*fep->ops->tx_kickstart)(dev);\n\n\tspin_unlock(&fep->tx_lock);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void fs_timeout_work(struct work_struct *work)\n{\n\tstruct fs_enet_private *fep = container_of(work, struct fs_enet_private,\n\t\t\t\t\t\t   timeout_work);\n\tstruct net_device *dev = fep->ndev;\n\tunsigned long flags;\n\tint wake = 0;\n\n\tdev->stats.tx_errors++;\n\n\tspin_lock_irqsave(&fep->lock, flags);\n\n\tif (dev->flags & IFF_UP) {\n\t\tphy_stop(dev->phydev);\n\t\t(*fep->ops->stop)(dev);\n\t\t(*fep->ops->restart)(dev);\n\t}\n\n\tphy_start(dev->phydev);\n\twake = fep->tx_free >= MAX_SKB_FRAGS &&\n\t       !(CBDR_SC(fep->cur_tx) & BD_ENET_TX_READY);\n\tspin_unlock_irqrestore(&fep->lock, flags);\n\n\tif (wake)\n\t\tnetif_wake_queue(dev);\n}\n\nstatic void fs_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\tschedule_work(&fep->timeout_work);\n}\n\n \nstatic void generic_adjust_link(struct  net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tint new_state = 0;\n\n\tif (phydev->link) {\n\t\t \n\t\tif (phydev->duplex != fep->oldduplex) {\n\t\t\tnew_state = 1;\n\t\t\tfep->oldduplex = phydev->duplex;\n\t\t}\n\n\t\tif (phydev->speed != fep->oldspeed) {\n\t\t\tnew_state = 1;\n\t\t\tfep->oldspeed = phydev->speed;\n\t\t}\n\n\t\tif (!fep->oldlink) {\n\t\t\tnew_state = 1;\n\t\t\tfep->oldlink = 1;\n\t\t}\n\n\t\tif (new_state)\n\t\t\tfep->ops->restart(dev);\n\t} else if (fep->oldlink) {\n\t\tnew_state = 1;\n\t\tfep->oldlink = 0;\n\t\tfep->oldspeed = 0;\n\t\tfep->oldduplex = -1;\n\t}\n\n\tif (new_state && netif_msg_link(fep))\n\t\tphy_print_status(phydev);\n}\n\n\nstatic void fs_adjust_link(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fep->lock, flags);\n\n\tif(fep->ops->adjust_link)\n\t\tfep->ops->adjust_link(dev);\n\telse\n\t\tgeneric_adjust_link(dev);\n\n\tspin_unlock_irqrestore(&fep->lock, flags);\n}\n\nstatic int fs_init_phy(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct phy_device *phydev;\n\tphy_interface_t iface;\n\n\tfep->oldlink = 0;\n\tfep->oldspeed = 0;\n\tfep->oldduplex = -1;\n\n\tiface = fep->fpi->use_rmii ?\n\t\tPHY_INTERFACE_MODE_RMII : PHY_INTERFACE_MODE_MII;\n\n\tphydev = of_phy_connect(dev, fep->fpi->phy_node, &fs_adjust_link, 0,\n\t\t\t\tiface);\n\tif (!phydev) {\n\t\tdev_err(&dev->dev, \"Could not attach to PHY\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int fs_enet_open(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tint r;\n\tint err;\n\n\t \n\t \n\tfs_init_bds(fep->ndev);\n\n\tnapi_enable(&fep->napi);\n\n\t \n\tr = request_irq(fep->interrupt, fs_enet_interrupt, IRQF_SHARED,\n\t\t\t\"fs_enet-mac\", dev);\n\tif (r != 0) {\n\t\tdev_err(fep->dev, \"Could not allocate FS_ENET IRQ!\");\n\t\tnapi_disable(&fep->napi);\n\t\treturn -EINVAL;\n\t}\n\n\terr = fs_init_phy(dev);\n\tif (err) {\n\t\tfree_irq(fep->interrupt, dev);\n\t\tnapi_disable(&fep->napi);\n\t\treturn err;\n\t}\n\tphy_start(dev->phydev);\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic int fs_enet_close(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tunsigned long flags;\n\n\tnetif_stop_queue(dev);\n\tnetif_carrier_off(dev);\n\tnapi_disable(&fep->napi);\n\tcancel_work_sync(&fep->timeout_work);\n\tphy_stop(dev->phydev);\n\n\tspin_lock_irqsave(&fep->lock, flags);\n\tspin_lock(&fep->tx_lock);\n\t(*fep->ops->stop)(dev);\n\tspin_unlock(&fep->tx_lock);\n\tspin_unlock_irqrestore(&fep->lock, flags);\n\n\t \n\tphy_disconnect(dev->phydev);\n\tfree_irq(fep->interrupt, dev);\n\n\treturn 0;\n}\n\n \n\nstatic void fs_get_drvinfo(struct net_device *dev,\n\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\n}\n\nstatic int fs_get_regs_len(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\treturn (*fep->ops->get_regs_len)(dev);\n}\n\nstatic void fs_get_regs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t\t void *p)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tunsigned long flags;\n\tint r, len;\n\n\tlen = regs->len;\n\n\tspin_lock_irqsave(&fep->lock, flags);\n\tr = (*fep->ops->get_regs)(dev, p, &len);\n\tspin_unlock_irqrestore(&fep->lock, flags);\n\n\tif (r == 0)\n\t\tregs->version = 0;\n}\n\nstatic u32 fs_get_msglevel(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\treturn fep->msg_enable;\n}\n\nstatic void fs_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tfep->msg_enable = value;\n}\n\nstatic int fs_get_tunable(struct net_device *dev,\n\t\t\t  const struct ethtool_tunable *tuna, void *data)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct fs_platform_info *fpi = fep->fpi;\n\tint ret = 0;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\t*(u32 *)data = fpi->rx_copybreak;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int fs_set_tunable(struct net_device *dev,\n\t\t\t  const struct ethtool_tunable *tuna, const void *data)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct fs_platform_info *fpi = fep->fpi;\n\tint ret = 0;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\tfpi->rx_copybreak = *(u32 *)data;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct ethtool_ops fs_ethtool_ops = {\n\t.get_drvinfo = fs_get_drvinfo,\n\t.get_regs_len = fs_get_regs_len,\n\t.nway_reset = phy_ethtool_nway_reset,\n\t.get_link = ethtool_op_get_link,\n\t.get_msglevel = fs_get_msglevel,\n\t.set_msglevel = fs_set_msglevel,\n\t.get_regs = fs_get_regs,\n\t.get_ts_info = ethtool_op_get_ts_info,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n\t.get_tunable = fs_get_tunable,\n\t.set_tunable = fs_set_tunable,\n};\n\n \n\n#ifdef CONFIG_FS_ENET_HAS_FEC\n#define IS_FEC(match) ((match)->data == &fs_fec_ops)\n#else\n#define IS_FEC(match) 0\n#endif\n\nstatic const struct net_device_ops fs_enet_netdev_ops = {\n\t.ndo_open\t\t= fs_enet_open,\n\t.ndo_stop\t\t= fs_enet_close,\n\t.ndo_start_xmit\t\t= fs_enet_start_xmit,\n\t.ndo_tx_timeout\t\t= fs_timeout,\n\t.ndo_set_rx_mode\t= fs_set_multicast_list,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl_running,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= fs_enet_netpoll,\n#endif\n};\n\nstatic const struct of_device_id fs_enet_match[];\nstatic int fs_enet_probe(struct platform_device *ofdev)\n{\n\tconst struct of_device_id *match;\n\tstruct net_device *ndev;\n\tstruct fs_enet_private *fep;\n\tstruct fs_platform_info *fpi;\n\tconst u32 *data;\n\tstruct clk *clk;\n\tint err;\n\tconst char *phy_connection_type;\n\tint privsize, len, ret = -ENODEV;\n\n\tmatch = of_match_device(fs_enet_match, &ofdev->dev);\n\tif (!match)\n\t\treturn -EINVAL;\n\n\tfpi = kzalloc(sizeof(*fpi), GFP_KERNEL);\n\tif (!fpi)\n\t\treturn -ENOMEM;\n\n\tif (!IS_FEC(match)) {\n\t\tdata = of_get_property(ofdev->dev.of_node, \"fsl,cpm-command\", &len);\n\t\tif (!data || len != 4)\n\t\t\tgoto out_free_fpi;\n\n\t\tfpi->cp_command = *data;\n\t}\n\n\tfpi->rx_ring = RX_RING_SIZE;\n\tfpi->tx_ring = TX_RING_SIZE;\n\tfpi->rx_copybreak = 240;\n\tfpi->napi_weight = 17;\n\tfpi->phy_node = of_parse_phandle(ofdev->dev.of_node, \"phy-handle\", 0);\n\tif (!fpi->phy_node && of_phy_is_fixed_link(ofdev->dev.of_node)) {\n\t\terr = of_phy_register_fixed_link(ofdev->dev.of_node);\n\t\tif (err)\n\t\t\tgoto out_free_fpi;\n\n\t\t \n\t\tfpi->phy_node = of_node_get(ofdev->dev.of_node);\n\t}\n\n\tif (of_device_is_compatible(ofdev->dev.of_node, \"fsl,mpc5125-fec\")) {\n\t\tphy_connection_type = of_get_property(ofdev->dev.of_node,\n\t\t\t\t\t\t\"phy-connection-type\", NULL);\n\t\tif (phy_connection_type && !strcmp(\"rmii\", phy_connection_type))\n\t\t\tfpi->use_rmii = 1;\n\t}\n\n\t \n\tclk = devm_clk_get(&ofdev->dev, \"per\");\n\tif (!IS_ERR(clk)) {\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret)\n\t\t\tgoto out_deregister_fixed_link;\n\n\t\tfpi->clk_per = clk;\n\t}\n\n\tprivsize = sizeof(*fep) +\n\t           sizeof(struct sk_buff **) *\n\t\t     (fpi->rx_ring + fpi->tx_ring) +\n\t\t   sizeof(char) * fpi->tx_ring;\n\n\tndev = alloc_etherdev(privsize);\n\tif (!ndev) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\tSET_NETDEV_DEV(ndev, &ofdev->dev);\n\tplatform_set_drvdata(ofdev, ndev);\n\n\tfep = netdev_priv(ndev);\n\tfep->dev = &ofdev->dev;\n\tfep->ndev = ndev;\n\tfep->fpi = fpi;\n\tfep->ops = match->data;\n\n\tret = fep->ops->setup_data(ndev);\n\tif (ret)\n\t\tgoto out_free_dev;\n\n\tfep->rx_skbuff = (struct sk_buff **)&fep[1];\n\tfep->tx_skbuff = fep->rx_skbuff + fpi->rx_ring;\n\tfep->mapped_as_page = (char *)(fep->rx_skbuff + fpi->rx_ring +\n\t\t\t\t       fpi->tx_ring);\n\n\tspin_lock_init(&fep->lock);\n\tspin_lock_init(&fep->tx_lock);\n\n\tof_get_ethdev_address(ofdev->dev.of_node, ndev);\n\n\tret = fep->ops->allocate_bd(ndev);\n\tif (ret)\n\t\tgoto out_cleanup_data;\n\n\tfep->rx_bd_base = fep->ring_base;\n\tfep->tx_bd_base = fep->rx_bd_base + fpi->rx_ring;\n\n\tfep->tx_ring = fpi->tx_ring;\n\tfep->rx_ring = fpi->rx_ring;\n\n\tndev->netdev_ops = &fs_enet_netdev_ops;\n\tndev->watchdog_timeo = 2 * HZ;\n\tINIT_WORK(&fep->timeout_work, fs_timeout_work);\n\tnetif_napi_add_weight(ndev, &fep->napi, fs_enet_napi,\n\t\t\t      fpi->napi_weight);\n\n\tndev->ethtool_ops = &fs_ethtool_ops;\n\n\tnetif_carrier_off(ndev);\n\n\tndev->features |= NETIF_F_SG;\n\n\tret = register_netdev(ndev);\n\tif (ret)\n\t\tgoto out_free_bd;\n\n\tpr_info(\"%s: fs_enet: %pM\\n\", ndev->name, ndev->dev_addr);\n\n\treturn 0;\n\nout_free_bd:\n\tfep->ops->free_bd(ndev);\nout_cleanup_data:\n\tfep->ops->cleanup_data(ndev);\nout_free_dev:\n\tfree_netdev(ndev);\nout_put:\n\tclk_disable_unprepare(fpi->clk_per);\nout_deregister_fixed_link:\n\tof_node_put(fpi->phy_node);\n\tif (of_phy_is_fixed_link(ofdev->dev.of_node))\n\t\tof_phy_deregister_fixed_link(ofdev->dev.of_node);\nout_free_fpi:\n\tkfree(fpi);\n\treturn ret;\n}\n\nstatic void fs_enet_remove(struct platform_device *ofdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(ofdev);\n\tstruct fs_enet_private *fep = netdev_priv(ndev);\n\n\tunregister_netdev(ndev);\n\n\tfep->ops->free_bd(ndev);\n\tfep->ops->cleanup_data(ndev);\n\tdev_set_drvdata(fep->dev, NULL);\n\tof_node_put(fep->fpi->phy_node);\n\tclk_disable_unprepare(fep->fpi->clk_per);\n\tif (of_phy_is_fixed_link(ofdev->dev.of_node))\n\t\tof_phy_deregister_fixed_link(ofdev->dev.of_node);\n\tfree_netdev(ndev);\n}\n\nstatic const struct of_device_id fs_enet_match[] = {\n#ifdef CONFIG_FS_ENET_HAS_SCC\n\t{\n\t\t.compatible = \"fsl,cpm1-scc-enet\",\n\t\t.data = (void *)&fs_scc_ops,\n\t},\n\t{\n\t\t.compatible = \"fsl,cpm2-scc-enet\",\n\t\t.data = (void *)&fs_scc_ops,\n\t},\n#endif\n#ifdef CONFIG_FS_ENET_HAS_FCC\n\t{\n\t\t.compatible = \"fsl,cpm2-fcc-enet\",\n\t\t.data = (void *)&fs_fcc_ops,\n\t},\n#endif\n#ifdef CONFIG_FS_ENET_HAS_FEC\n#ifdef CONFIG_FS_ENET_MPC5121_FEC\n\t{\n\t\t.compatible = \"fsl,mpc5121-fec\",\n\t\t.data = (void *)&fs_fec_ops,\n\t},\n\t{\n\t\t.compatible = \"fsl,mpc5125-fec\",\n\t\t.data = (void *)&fs_fec_ops,\n\t},\n#else\n\t{\n\t\t.compatible = \"fsl,pq1-fec-enet\",\n\t\t.data = (void *)&fs_fec_ops,\n\t},\n#endif\n#endif\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fs_enet_match);\n\nstatic struct platform_driver fs_enet_driver = {\n\t.driver = {\n\t\t.name = \"fs_enet\",\n\t\t.of_match_table = fs_enet_match,\n\t},\n\t.probe = fs_enet_probe,\n\t.remove_new = fs_enet_remove,\n};\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void fs_enet_netpoll(struct net_device *dev)\n{\n       disable_irq(dev->irq);\n       fs_enet_interrupt(dev->irq, dev);\n       enable_irq(dev->irq);\n}\n#endif\n\nmodule_platform_driver(fs_enet_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}