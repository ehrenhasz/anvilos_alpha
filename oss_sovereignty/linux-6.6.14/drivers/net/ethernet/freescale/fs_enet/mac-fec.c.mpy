{
  "module_name": "mac-fec.c",
  "hash_id": "9c22db1dd770dfb73f403368fc4e8413254436e03994633f32a861c850ec74ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fs_enet/mac-fec.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/crc32.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/platform_device.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/gfp.h>\n\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n\n#include \"fs_enet.h\"\n#include \"fec.h\"\n\n \n\n#if defined(CONFIG_CPM1)\n \n#define __fs_out32(addr, x)\t__raw_writel(x, addr)\n#define __fs_out16(addr, x)\t__raw_writew(x, addr)\n#define __fs_in32(addr)\t__raw_readl(addr)\n#define __fs_in16(addr)\t__raw_readw(addr)\n#else\n \n#define __fs_out32(addr, x)\tout_be32(addr, x)\n#define __fs_out16(addr, x)\tout_be16(addr, x)\n#define __fs_in32(addr)\tin_be32(addr)\n#define __fs_in16(addr)\tin_be16(addr)\n#endif\n\n \n#define FW(_fecp, _reg, _v) __fs_out32(&(_fecp)->fec_ ## _reg, (_v))\n\n \n#define FR(_fecp, _reg)\t__fs_in32(&(_fecp)->fec_ ## _reg)\n\n \n#define FS(_fecp, _reg, _v) FW(_fecp, _reg, FR(_fecp, _reg) | (_v))\n\n \n#define FC(_fecp, _reg, _v) FW(_fecp, _reg, FR(_fecp, _reg) & ~(_v))\n\n \n#define FEC_RESET_DELAY\t\t50\n\nstatic int whack_reset(struct fec __iomem *fecp)\n{\n\tint i;\n\n\tFW(fecp, ecntrl, FEC_ECNTRL_PINMUX | FEC_ECNTRL_RESET);\n\tfor (i = 0; i < FEC_RESET_DELAY; i++) {\n\t\tif ((FR(fecp, ecntrl) & FEC_ECNTRL_RESET) == 0)\n\t\t\treturn 0;\t \n\t\tudelay(1);\n\t}\n\n\treturn -1;\n}\n\nstatic int do_pd_setup(struct fs_enet_private *fep)\n{\n\tstruct platform_device *ofdev = to_platform_device(fep->dev);\n\n\tfep->interrupt = irq_of_parse_and_map(ofdev->dev.of_node, 0);\n\tif (!fep->interrupt)\n\t\treturn -EINVAL;\n\n\tfep->fec.fecp = of_iomap(ofdev->dev.of_node, 0);\n\tif (!fep->fec.fecp)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n#define FEC_NAPI_EVENT_MSK\t(FEC_ENET_RXF | FEC_ENET_RXB | FEC_ENET_TXF)\n#define FEC_EVENT\t\t(FEC_ENET_RXF | FEC_ENET_TXF)\n#define FEC_ERR_EVENT_MSK\t(FEC_ENET_HBERR | FEC_ENET_BABR | \\\n\t\t\t\t FEC_ENET_BABT | FEC_ENET_EBERR)\n\nstatic int setup_data(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\tif (do_pd_setup(fep) != 0)\n\t\treturn -EINVAL;\n\n\tfep->fec.hthi = 0;\n\tfep->fec.htlo = 0;\n\n\tfep->ev_napi = FEC_NAPI_EVENT_MSK;\n\tfep->ev = FEC_EVENT;\n\tfep->ev_err = FEC_ERR_EVENT_MSK;\n\n\treturn 0;\n}\n\nstatic int allocate_bd(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tconst struct fs_platform_info *fpi = fep->fpi;\n\n\tfep->ring_base = (void __force __iomem *)dma_alloc_coherent(fep->dev,\n\t\t\t\t\t    (fpi->tx_ring + fpi->rx_ring) *\n\t\t\t\t\t    sizeof(cbd_t), &fep->ring_mem_addr,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (fep->ring_base == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void free_bd(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tconst struct fs_platform_info *fpi = fep->fpi;\n\n\tif(fep->ring_base)\n\t\tdma_free_coherent(fep->dev, (fpi->tx_ring + fpi->rx_ring)\n\t\t\t\t\t* sizeof(cbd_t),\n\t\t\t\t\t(void __force *)fep->ring_base,\n\t\t\t\t\tfep->ring_mem_addr);\n}\n\nstatic void cleanup_data(struct net_device *dev)\n{\n\t \n}\n\nstatic void set_promiscuous_mode(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct fec __iomem *fecp = fep->fec.fecp;\n\n\tFS(fecp, r_cntrl, FEC_RCNTRL_PROM);\n}\n\nstatic void set_multicast_start(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\tfep->fec.hthi = 0;\n\tfep->fec.htlo = 0;\n}\n\nstatic void set_multicast_one(struct net_device *dev, const u8 *mac)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tint temp, hash_index;\n\tu32 crc, csrVal;\n\n\tcrc = ether_crc(6, mac);\n\n\ttemp = (crc & 0x3f) >> 1;\n\thash_index = ((temp & 0x01) << 4) |\n\t\t     ((temp & 0x02) << 2) |\n\t\t     ((temp & 0x04)) |\n\t\t     ((temp & 0x08) >> 2) |\n\t\t     ((temp & 0x10) >> 4);\n\tcsrVal = 1 << hash_index;\n\tif (crc & 1)\n\t\tfep->fec.hthi |= csrVal;\n\telse\n\t\tfep->fec.htlo |= csrVal;\n}\n\nstatic void set_multicast_finish(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct fec __iomem *fecp = fep->fec.fecp;\n\n\t \n\tif ((dev->flags & IFF_ALLMULTI) != 0 ||\n\t    netdev_mc_count(dev) > FEC_MAX_MULTICAST_ADDRS) {\n\t\tfep->fec.hthi = 0xffffffffU;\n\t\tfep->fec.htlo = 0xffffffffU;\n\t}\n\n\tFC(fecp, r_cntrl, FEC_RCNTRL_PROM);\n\tFW(fecp, grp_hash_table_high, fep->fec.hthi);\n\tFW(fecp, grp_hash_table_low, fep->fec.htlo);\n}\n\nstatic void set_multicast_list(struct net_device *dev)\n{\n\tstruct netdev_hw_addr *ha;\n\n\tif ((dev->flags & IFF_PROMISC) == 0) {\n\t\tset_multicast_start(dev);\n\t\tnetdev_for_each_mc_addr(ha, dev)\n\t\t\tset_multicast_one(dev, ha->addr);\n\t\tset_multicast_finish(dev);\n\t} else\n\t\tset_promiscuous_mode(dev);\n}\n\nstatic void restart(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct fec __iomem *fecp = fep->fec.fecp;\n\tconst struct fs_platform_info *fpi = fep->fpi;\n\tdma_addr_t rx_bd_base_phys, tx_bd_base_phys;\n\tint r;\n\tu32 addrhi, addrlo;\n\n\tstruct mii_bus *mii = dev->phydev->mdio.bus;\n\tstruct fec_info* fec_inf = mii->priv;\n\n\tr = whack_reset(fep->fec.fecp);\n\tif (r != 0)\n\t\tdev_err(fep->dev, \"FEC Reset FAILED!\\n\");\n\t \n\taddrhi = ((u32) dev->dev_addr[0] << 24) |\n\t\t ((u32) dev->dev_addr[1] << 16) |\n\t\t ((u32) dev->dev_addr[2] <<  8) |\n\t\t  (u32) dev->dev_addr[3];\n\taddrlo = ((u32) dev->dev_addr[4] << 24) |\n\t\t ((u32) dev->dev_addr[5] << 16);\n\tFW(fecp, addr_low, addrhi);\n\tFW(fecp, addr_high, addrlo);\n\n\t \n\tFW(fecp, grp_hash_table_high, fep->fec.hthi);\n\tFW(fecp, grp_hash_table_low, fep->fec.htlo);\n\n\t \n\tFW(fecp, r_buff_size, PKT_MAXBLR_SIZE);\n#ifdef CONFIG_FS_ENET_MPC5121_FEC\n\tFW(fecp, r_cntrl, PKT_MAXBUF_SIZE << 16);\n#else\n\tFW(fecp, r_hash, PKT_MAXBUF_SIZE);\n#endif\n\n\t \n\trx_bd_base_phys = fep->ring_mem_addr;\n\ttx_bd_base_phys = rx_bd_base_phys + sizeof(cbd_t) * fpi->rx_ring;\n\n\t \n\tFW(fecp, r_des_start, rx_bd_base_phys);\n\tFW(fecp, x_des_start, tx_bd_base_phys);\n\n\tfs_init_bds(dev);\n\n\t \n#ifdef CONFIG_FS_ENET_MPC5121_FEC\n\tFS(fecp, dma_control, 0xC0000000);\n#else\n\tFW(fecp, fun_code, 0x78000000);\n#endif\n\n\t \n\tFW(fecp, mii_speed, fec_inf->mii_speed);\n\n\t \n\tFW(fecp, ievent, 0xffc0);\n#ifndef CONFIG_FS_ENET_MPC5121_FEC\n\tFW(fecp, ivec, (virq_to_hw(fep->interrupt) / 2) << 29);\n\n\tFW(fecp, r_cntrl, FEC_RCNTRL_MII_MODE);\t \n#else\n\t \n\tFS(fecp, r_cntrl, fpi->use_rmii ?\n\t\t\tFEC_RCNTRL_RMII_MODE : FEC_RCNTRL_MII_MODE);\n#endif\n\t \n\tif (dev->phydev->duplex) {\n\t\tFC(fecp, r_cntrl, FEC_RCNTRL_DRT);\n\t\tFS(fecp, x_cntrl, FEC_TCNTRL_FDEN);\t \n\t} else {\n\t\tFS(fecp, r_cntrl, FEC_RCNTRL_DRT);\n\t\tFC(fecp, x_cntrl, FEC_TCNTRL_FDEN);\t \n\t}\n\n\t \n\tset_multicast_list(dev);\n\n\t \n\tFW(fecp, imask, FEC_ENET_TXF | FEC_ENET_TXB |\n\t   FEC_ENET_RXF | FEC_ENET_RXB);\n\n\t \n\tFW(fecp, ecntrl, FEC_ECNTRL_PINMUX | FEC_ECNTRL_ETHER_EN);\n\tFW(fecp, r_des_active, 0x01000000);\n}\n\nstatic void stop(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct fec __iomem *fecp = fep->fec.fecp;\n\tint i;\n\n\tif ((FR(fecp, ecntrl) & FEC_ECNTRL_ETHER_EN) == 0)\n\t\treturn;\t\t \n\n\tFW(fecp, x_cntrl, 0x01);\t \n\tfor (i = 0; ((FR(fecp, ievent) & 0x10000000) == 0) &&\n\t     i < FEC_RESET_DELAY; i++)\n\t\tudelay(1);\n\n\tif (i == FEC_RESET_DELAY)\n\t\tdev_warn(fep->dev, \"FEC timeout on graceful transmit stop\\n\");\n\t \n\tFW(fecp, imask, 0);\n\tFC(fecp, ecntrl, FEC_ECNTRL_ETHER_EN);\n\n\tfs_cleanup_bds(dev);\n}\n\nstatic void napi_clear_event_fs(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct fec __iomem *fecp = fep->fec.fecp;\n\n\tFW(fecp, ievent, FEC_NAPI_EVENT_MSK);\n}\n\nstatic void napi_enable_fs(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct fec __iomem *fecp = fep->fec.fecp;\n\n\tFS(fecp, imask, FEC_NAPI_EVENT_MSK);\n}\n\nstatic void napi_disable_fs(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct fec __iomem *fecp = fep->fec.fecp;\n\n\tFC(fecp, imask, FEC_NAPI_EVENT_MSK);\n}\n\nstatic void rx_bd_done(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct fec __iomem *fecp = fep->fec.fecp;\n\n\tFW(fecp, r_des_active, 0x01000000);\n}\n\nstatic void tx_kickstart(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct fec __iomem *fecp = fep->fec.fecp;\n\n\tFW(fecp, x_des_active, 0x01000000);\n}\n\nstatic u32 get_int_events(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct fec __iomem *fecp = fep->fec.fecp;\n\n\treturn FR(fecp, ievent) & FR(fecp, imask);\n}\n\nstatic void clear_int_events(struct net_device *dev, u32 int_events)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tstruct fec __iomem *fecp = fep->fec.fecp;\n\n\tFW(fecp, ievent, int_events);\n}\n\nstatic void ev_error(struct net_device *dev, u32 int_events)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\tdev_warn(fep->dev, \"FEC ERROR(s) 0x%x\\n\", int_events);\n}\n\nstatic int get_regs(struct net_device *dev, void *p, int *sizep)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\tif (*sizep < sizeof(struct fec))\n\t\treturn -EINVAL;\n\n\tmemcpy_fromio(p, fep->fec.fecp, sizeof(struct fec));\n\n\treturn 0;\n}\n\nstatic int get_regs_len(struct net_device *dev)\n{\n\treturn sizeof(struct fec);\n}\n\nstatic void tx_restart(struct net_device *dev)\n{\n\t \n}\n\n \n\nconst struct fs_ops fs_fec_ops = {\n\t.setup_data\t\t= setup_data,\n\t.cleanup_data\t\t= cleanup_data,\n\t.set_multicast_list\t= set_multicast_list,\n\t.restart\t\t= restart,\n\t.stop\t\t\t= stop,\n\t.napi_clear_event\t= napi_clear_event_fs,\n\t.napi_enable\t\t= napi_enable_fs,\n\t.napi_disable\t\t= napi_disable_fs,\n\t.rx_bd_done\t\t= rx_bd_done,\n\t.tx_kickstart\t\t= tx_kickstart,\n\t.get_int_events\t\t= get_int_events,\n\t.clear_int_events\t= clear_int_events,\n\t.ev_error\t\t= ev_error,\n\t.get_regs\t\t= get_regs,\n\t.get_regs_len\t\t= get_regs_len,\n\t.tx_restart\t\t= tx_restart,\n\t.allocate_bd\t\t= allocate_bd,\n\t.free_bd\t\t= free_bd,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}