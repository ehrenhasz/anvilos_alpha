{
  "module_name": "mac-fcc.c",
  "hash_id": "b061394512a3ef8b94f849573c5d7ea2b48586249605740bb3424939462a2849",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fs_enet/mac-fcc.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/platform_device.h>\n#include <linux/phy.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/gfp.h>\n#include <linux/pgtable.h>\n\n#include <asm/immap_cpm2.h>\n#include <asm/cpm2.h>\n\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n\n#include \"fs_enet.h\"\n\n \n\n \n\n \n#define W32(_p, _m, _v)\tout_be32(&(_p)->_m, (_v))\n#define R32(_p, _m)\tin_be32(&(_p)->_m)\n#define S32(_p, _m, _v)\tW32(_p, _m, R32(_p, _m) | (_v))\n#define C32(_p, _m, _v)\tW32(_p, _m, R32(_p, _m) & ~(_v))\n\n#define W16(_p, _m, _v)\tout_be16(&(_p)->_m, (_v))\n#define R16(_p, _m)\tin_be16(&(_p)->_m)\n#define S16(_p, _m, _v)\tW16(_p, _m, R16(_p, _m) | (_v))\n#define C16(_p, _m, _v)\tW16(_p, _m, R16(_p, _m) & ~(_v))\n\n#define W8(_p, _m, _v)\tout_8(&(_p)->_m, (_v))\n#define R8(_p, _m)\tin_8(&(_p)->_m)\n#define S8(_p, _m, _v)\tW8(_p, _m, R8(_p, _m) | (_v))\n#define C8(_p, _m, _v)\tW8(_p, _m, R8(_p, _m) & ~(_v))\n\n \n\n#define FCC_MAX_MULTICAST_ADDRS\t64\n\n#define mk_mii_read(REG)\t(0x60020000 | ((REG & 0x1f) << 18))\n#define mk_mii_write(REG, VAL)\t(0x50020000 | ((REG & 0x1f) << 18) | (VAL & 0xffff))\n#define mk_mii_end\t\t0\n\n#define MAX_CR_CMD_LOOPS\t10000\n\nstatic inline int fcc_cr_cmd(struct fs_enet_private *fep, u32 op)\n{\n\tconst struct fs_platform_info *fpi = fep->fpi;\n\n\treturn cpm_command(fpi->cp_command, op);\n}\n\nstatic int do_pd_setup(struct fs_enet_private *fep)\n{\n\tstruct platform_device *ofdev = to_platform_device(fep->dev);\n\tstruct fs_platform_info *fpi = fep->fpi;\n\tint ret = -EINVAL;\n\n\tfep->interrupt = irq_of_parse_and_map(ofdev->dev.of_node, 0);\n\tif (!fep->interrupt)\n\t\tgoto out;\n\n\tfep->fcc.fccp = of_iomap(ofdev->dev.of_node, 0);\n\tif (!fep->fcc.fccp)\n\t\tgoto out;\n\n\tfep->fcc.ep = of_iomap(ofdev->dev.of_node, 1);\n\tif (!fep->fcc.ep)\n\t\tgoto out_fccp;\n\n\tfep->fcc.fcccp = of_iomap(ofdev->dev.of_node, 2);\n\tif (!fep->fcc.fcccp)\n\t\tgoto out_ep;\n\n\tfep->fcc.mem = (void __iomem *)cpm2_immr;\n\tfpi->dpram_offset = cpm_muram_alloc(128, 32);\n\tif (IS_ERR_VALUE(fpi->dpram_offset)) {\n\t\tret = fpi->dpram_offset;\n\t\tgoto out_fcccp;\n\t}\n\n\treturn 0;\n\nout_fcccp:\n\tiounmap(fep->fcc.fcccp);\nout_ep:\n\tiounmap(fep->fcc.ep);\nout_fccp:\n\tiounmap(fep->fcc.fccp);\nout:\n\treturn ret;\n}\n\n#define FCC_NAPI_EVENT_MSK\t(FCC_ENET_RXF | FCC_ENET_RXB | FCC_ENET_TXB)\n#define FCC_EVENT\t\t(FCC_ENET_RXF | FCC_ENET_TXB)\n#define FCC_ERR_EVENT_MSK\t(FCC_ENET_TXE)\n\nstatic int setup_data(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\tif (do_pd_setup(fep) != 0)\n\t\treturn -EINVAL;\n\n\tfep->ev_napi = FCC_NAPI_EVENT_MSK;\n\tfep->ev = FCC_EVENT;\n\tfep->ev_err = FCC_ERR_EVENT_MSK;\n\n\treturn 0;\n}\n\nstatic int allocate_bd(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tconst struct fs_platform_info *fpi = fep->fpi;\n\n\tfep->ring_base = (void __iomem __force *)dma_alloc_coherent(fep->dev,\n\t\t\t\t\t    (fpi->tx_ring + fpi->rx_ring) *\n\t\t\t\t\t    sizeof(cbd_t), &fep->ring_mem_addr,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (fep->ring_base == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void free_bd(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tconst struct fs_platform_info *fpi = fep->fpi;\n\n\tif (fep->ring_base)\n\t\tdma_free_coherent(fep->dev,\n\t\t\t(fpi->tx_ring + fpi->rx_ring) * sizeof(cbd_t),\n\t\t\t(void __force *)fep->ring_base, fep->ring_mem_addr);\n}\n\nstatic void cleanup_data(struct net_device *dev)\n{\n\t \n}\n\nstatic void set_promiscuous_mode(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tfcc_t __iomem *fccp = fep->fcc.fccp;\n\n\tS32(fccp, fcc_fpsmr, FCC_PSMR_PRO);\n}\n\nstatic void set_multicast_start(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tfcc_enet_t __iomem *ep = fep->fcc.ep;\n\n\tW32(ep, fen_gaddrh, 0);\n\tW32(ep, fen_gaddrl, 0);\n}\n\nstatic void set_multicast_one(struct net_device *dev, const u8 *mac)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tfcc_enet_t __iomem *ep = fep->fcc.ep;\n\tu16 taddrh, taddrm, taddrl;\n\n\ttaddrh = ((u16)mac[5] << 8) | mac[4];\n\ttaddrm = ((u16)mac[3] << 8) | mac[2];\n\ttaddrl = ((u16)mac[1] << 8) | mac[0];\n\n\tW16(ep, fen_taddrh, taddrh);\n\tW16(ep, fen_taddrm, taddrm);\n\tW16(ep, fen_taddrl, taddrl);\n\tfcc_cr_cmd(fep, CPM_CR_SET_GADDR);\n}\n\nstatic void set_multicast_finish(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tfcc_t __iomem *fccp = fep->fcc.fccp;\n\tfcc_enet_t __iomem *ep = fep->fcc.ep;\n\n\t \n\tC32(fccp, fcc_fpsmr, FCC_PSMR_PRO);\n\n\t \n\tif ((dev->flags & IFF_ALLMULTI) != 0 ||\n\t    netdev_mc_count(dev) > FCC_MAX_MULTICAST_ADDRS) {\n\n\t\tW32(ep, fen_gaddrh, 0xffffffff);\n\t\tW32(ep, fen_gaddrl, 0xffffffff);\n\t}\n\n\t \n\tfep->fcc.gaddrh = R32(ep, fen_gaddrh);\n\tfep->fcc.gaddrl = R32(ep, fen_gaddrl);\n}\n\nstatic void set_multicast_list(struct net_device *dev)\n{\n\tstruct netdev_hw_addr *ha;\n\n\tif ((dev->flags & IFF_PROMISC) == 0) {\n\t\tset_multicast_start(dev);\n\t\tnetdev_for_each_mc_addr(ha, dev)\n\t\t\tset_multicast_one(dev, ha->addr);\n\t\tset_multicast_finish(dev);\n\t} else\n\t\tset_promiscuous_mode(dev);\n}\n\nstatic void restart(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tconst struct fs_platform_info *fpi = fep->fpi;\n\tfcc_t __iomem *fccp = fep->fcc.fccp;\n\tfcc_c_t __iomem *fcccp = fep->fcc.fcccp;\n\tfcc_enet_t __iomem *ep = fep->fcc.ep;\n\tdma_addr_t rx_bd_base_phys, tx_bd_base_phys;\n\tu16 paddrh, paddrm, paddrl;\n\tconst unsigned char *mac;\n\tint i;\n\n\tC32(fccp, fcc_gfmr, FCC_GFMR_ENR | FCC_GFMR_ENT);\n\n\t \n\tfor (i = 0; i < sizeof(*ep); i++)\n\t\tout_8((u8 __iomem *)ep + i, 0);\n\n\t \n\trx_bd_base_phys = fep->ring_mem_addr;\n\ttx_bd_base_phys = rx_bd_base_phys + sizeof(cbd_t) * fpi->rx_ring;\n\n\t \n\tW32(ep, fen_genfcc.fcc_rbase, rx_bd_base_phys);\n\tW32(ep, fen_genfcc.fcc_tbase, tx_bd_base_phys);\n\n\t \n\tW16(ep, fen_genfcc.fcc_mrblr, PKT_MAXBLR_SIZE);\n\n\tW32(ep, fen_genfcc.fcc_rstate, (CPMFCR_GBL | CPMFCR_EB) << 24);\n\tW32(ep, fen_genfcc.fcc_tstate, (CPMFCR_GBL | CPMFCR_EB) << 24);\n\n\t \n\n\tW16(ep, fen_genfcc.fcc_riptr, fpi->dpram_offset);\n\tW16(ep, fen_genfcc.fcc_tiptr, fpi->dpram_offset + 32);\n\n\tW16(ep, fen_padptr, fpi->dpram_offset + 64);\n\n\t \n\tmemset_io(fep->fcc.mem + fpi->dpram_offset + 64, 0x88, 32);\n\n\tW32(ep, fen_genfcc.fcc_rbptr, 0);\n\tW32(ep, fen_genfcc.fcc_tbptr, 0);\n\tW32(ep, fen_genfcc.fcc_rcrc, 0);\n\tW32(ep, fen_genfcc.fcc_tcrc, 0);\n\tW16(ep, fen_genfcc.fcc_res1, 0);\n\tW32(ep, fen_genfcc.fcc_res2, 0);\n\n\t \n\tW32(ep, fen_camptr, 0);\n\n\t \n\tW32(ep, fen_cmask, 0xdebb20e3);\n\tW32(ep, fen_cpres, 0xffffffff);\n\n\tW32(ep, fen_crcec, 0);\t\t \n\tW32(ep, fen_alec, 0);\t\t \n\tW32(ep, fen_disfc, 0);\t\t \n\tW16(ep, fen_retlim, 15);\t \n\tW16(ep, fen_pper, 0);\t\t \n\n\t \n\tW32(ep, fen_gaddrh, fep->fcc.gaddrh);\n\tW32(ep, fen_gaddrl, fep->fcc.gaddrh);\n\n\t \n\tW32(ep, fen_iaddrh, 0);\n\tW32(ep, fen_iaddrl, 0);\n\n\t \n\tW16(ep, fen_tfcstat, 0);\n\tW16(ep, fen_tfclen, 0);\n\tW32(ep, fen_tfcptr, 0);\n\n\tW16(ep, fen_mflr, PKT_MAXBUF_SIZE);\t \n\tW16(ep, fen_minflr, PKT_MINBUF_SIZE);\t \n\n\t \n\tmac = dev->dev_addr;\n\tpaddrh = ((u16)mac[5] << 8) | mac[4];\n\tpaddrm = ((u16)mac[3] << 8) | mac[2];\n\tpaddrl = ((u16)mac[1] << 8) | mac[0];\n\n\tW16(ep, fen_paddrh, paddrh);\n\tW16(ep, fen_paddrm, paddrm);\n\tW16(ep, fen_paddrl, paddrl);\n\n\tW16(ep, fen_taddrh, 0);\n\tW16(ep, fen_taddrm, 0);\n\tW16(ep, fen_taddrl, 0);\n\n\tW16(ep, fen_maxd1, 1520);\t \n\tW16(ep, fen_maxd2, 1520);\t \n\n\t \n\tW32(ep, fen_octc, 0);\n\tW32(ep, fen_colc, 0);\n\tW32(ep, fen_broc, 0);\n\tW32(ep, fen_mulc, 0);\n\tW32(ep, fen_uspc, 0);\n\tW32(ep, fen_frgc, 0);\n\tW32(ep, fen_ospc, 0);\n\tW32(ep, fen_jbrc, 0);\n\tW32(ep, fen_p64c, 0);\n\tW32(ep, fen_p65c, 0);\n\tW32(ep, fen_p128c, 0);\n\tW32(ep, fen_p256c, 0);\n\tW32(ep, fen_p512c, 0);\n\tW32(ep, fen_p1024c, 0);\n\n\tW16(ep, fen_rfthr, 0);\t \n\tW16(ep, fen_rfcnt, 0);\n\tW16(ep, fen_cftype, 0);\n\n\tfs_init_bds(dev);\n\n\t \n\tif (fpi->use_rmii) {\n\t\tif (dev->phydev->speed == 100)\n\t\t\tC8(fcccp, fcc_gfemr, 0x20);\n\t\telse\n\t\t\tS8(fcccp, fcc_gfemr, 0x20);\n\t}\n\n\tfcc_cr_cmd(fep, CPM_CR_INIT_TRX);\n\n\t \n\tW16(fccp, fcc_fcce, 0xffff);\n\n\t \n\tW16(fccp, fcc_fccm, FCC_ENET_TXE | FCC_ENET_RXF | FCC_ENET_TXB);\n\n\t \n\tW32(fccp, fcc_gfmr, FCC_GFMR_TCI | FCC_GFMR_MODE_ENET);\n\n\t \n\tW16(fccp, fcc_fdsr, 0xd555);\n\n\tW32(fccp, fcc_fpsmr, FCC_PSMR_ENCRC);\n\n\tif (fpi->use_rmii)\n\t\tS32(fccp, fcc_fpsmr, FCC_PSMR_RMII);\n\n\t \n\tif (dev->phydev->duplex)\n\t\tS32(fccp, fcc_fpsmr, FCC_PSMR_FDE | FCC_PSMR_LPB);\n\telse\n\t\tC32(fccp, fcc_fpsmr, FCC_PSMR_FDE | FCC_PSMR_LPB);\n\n\t \n\tset_multicast_list(dev);\n\n\tS32(fccp, fcc_gfmr, FCC_GFMR_ENR | FCC_GFMR_ENT);\n}\n\nstatic void stop(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tfcc_t __iomem *fccp = fep->fcc.fccp;\n\n\t \n\tC32(fccp, fcc_gfmr, FCC_GFMR_ENR | FCC_GFMR_ENT);\n\n\t \n\tW16(fccp, fcc_fcce, 0xffff);\n\n\t \n\tW16(fccp, fcc_fccm, 0);\n\n\tfs_cleanup_bds(dev);\n}\n\nstatic void napi_clear_event_fs(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tfcc_t __iomem *fccp = fep->fcc.fccp;\n\n\tW16(fccp, fcc_fcce, FCC_NAPI_EVENT_MSK);\n}\n\nstatic void napi_enable_fs(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tfcc_t __iomem *fccp = fep->fcc.fccp;\n\n\tS16(fccp, fcc_fccm, FCC_NAPI_EVENT_MSK);\n}\n\nstatic void napi_disable_fs(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tfcc_t __iomem *fccp = fep->fcc.fccp;\n\n\tC16(fccp, fcc_fccm, FCC_NAPI_EVENT_MSK);\n}\n\nstatic void rx_bd_done(struct net_device *dev)\n{\n\t \n}\n\nstatic void tx_kickstart(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tfcc_t __iomem *fccp = fep->fcc.fccp;\n\n\tS16(fccp, fcc_ftodr, 0x8000);\n}\n\nstatic u32 get_int_events(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tfcc_t __iomem *fccp = fep->fcc.fccp;\n\n\treturn (u32)R16(fccp, fcc_fcce);\n}\n\nstatic void clear_int_events(struct net_device *dev, u32 int_events)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tfcc_t __iomem *fccp = fep->fcc.fccp;\n\n\tW16(fccp, fcc_fcce, int_events & 0xffff);\n}\n\nstatic void ev_error(struct net_device *dev, u32 int_events)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\tdev_warn(fep->dev, \"FS_ENET ERROR(s) 0x%x\\n\", int_events);\n}\n\nstatic int get_regs(struct net_device *dev, void *p, int *sizep)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\n\tif (*sizep < sizeof(fcc_t) + sizeof(fcc_enet_t) + 1)\n\t\treturn -EINVAL;\n\n\tmemcpy_fromio(p, fep->fcc.fccp, sizeof(fcc_t));\n\tp = (char *)p + sizeof(fcc_t);\n\n\tmemcpy_fromio(p, fep->fcc.ep, sizeof(fcc_enet_t));\n\tp = (char *)p + sizeof(fcc_enet_t);\n\n\tmemcpy_fromio(p, fep->fcc.fcccp, 1);\n\treturn 0;\n}\n\nstatic int get_regs_len(struct net_device *dev)\n{\n\treturn sizeof(fcc_t) + sizeof(fcc_enet_t) + 1;\n}\n\n \nstatic void tx_restart(struct net_device *dev)\n{\n\tstruct fs_enet_private *fep = netdev_priv(dev);\n\tfcc_t __iomem *fccp = fep->fcc.fccp;\n\tconst struct fs_platform_info *fpi = fep->fpi;\n\tfcc_enet_t __iomem *ep = fep->fcc.ep;\n\tcbd_t __iomem *curr_tbptr;\n\tcbd_t __iomem *recheck_bd;\n\tcbd_t __iomem *prev_bd;\n\tcbd_t __iomem *last_tx_bd;\n\n\tlast_tx_bd = fep->tx_bd_base + (fpi->tx_ring - 1);\n\n\t \n\trecheck_bd = curr_tbptr = (cbd_t __iomem *)\n\t\t((R32(ep, fen_genfcc.fcc_tbptr) - fep->ring_mem_addr) +\n\t\tfep->ring_base);\n\n\tprev_bd = (recheck_bd == fep->tx_bd_base) ? last_tx_bd : recheck_bd - 1;\n\n\t \n\twhile ((CBDR_SC(prev_bd) & BD_ENET_TX_READY) != 0) {\n\t\t \n\t\trecheck_bd = prev_bd;\n\n\t\t \n\t\tprev_bd = (prev_bd == fep->tx_bd_base) ? last_tx_bd : prev_bd - 1;\n\n\t\t \n\t\tif (recheck_bd == curr_tbptr)\n\t\t\tbreak;\n\t}\n\t \n\tW32(ep, fen_genfcc.fcc_tbptr,\n\t\t(uint)(((void __iomem *)recheck_bd - fep->ring_base) +\n\t\tfep->ring_mem_addr));\n\tfep->dirty_tx = recheck_bd;\n\n\tC32(fccp, fcc_gfmr, FCC_GFMR_ENT);\n\tudelay(10);\n\tS32(fccp, fcc_gfmr, FCC_GFMR_ENT);\n\n\tfcc_cr_cmd(fep, CPM_CR_RESTART_TX);\n}\n\n \n\nconst struct fs_ops fs_fcc_ops = {\n\t.setup_data\t\t= setup_data,\n\t.cleanup_data\t\t= cleanup_data,\n\t.set_multicast_list\t= set_multicast_list,\n\t.restart\t\t= restart,\n\t.stop\t\t\t= stop,\n\t.napi_clear_event\t= napi_clear_event_fs,\n\t.napi_enable\t\t= napi_enable_fs,\n\t.napi_disable\t\t= napi_disable_fs,\n\t.rx_bd_done\t\t= rx_bd_done,\n\t.tx_kickstart\t\t= tx_kickstart,\n\t.get_int_events\t\t= get_int_events,\n\t.clear_int_events\t= clear_int_events,\n\t.ev_error\t\t= ev_error,\n\t.get_regs\t\t= get_regs,\n\t.get_regs_len\t\t= get_regs_len,\n\t.tx_restart\t\t= tx_restart,\n\t.allocate_bd\t\t= allocate_bd,\n\t.free_bd\t\t= free_bd,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}