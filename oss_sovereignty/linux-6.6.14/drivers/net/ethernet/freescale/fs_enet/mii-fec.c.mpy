{
  "module_name": "mii-fec.c",
  "hash_id": "fd6ebed2c180b7b3d79550cfcfd636aa54350c574a5485b3c933d2ba7edeb053",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fs_enet/mii-fec.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/bitops.h>\n#include <linux/platform_device.h>\n#include <linux/of_address.h>\n#include <linux/of_mdio.h>\n#include <linux/of_platform.h>\n#include <linux/pgtable.h>\n\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n#include <asm/mpc5xxx.h>\n\n#include \"fs_enet.h\"\n#include \"fec.h\"\n\n \n#define mk_mii_read(REG)\t(0x60020000 | ((REG & 0x1f) << 18))\n#define mk_mii_write(REG, VAL)\t(0x50020000 | ((REG & 0x1f) << 18) | (VAL & 0xffff))\n#define mk_mii_end\t\t0\n\n#define FEC_MII_LOOPS\t10000\n\nstatic int fs_enet_fec_mii_read(struct mii_bus *bus , int phy_id, int location)\n{\n\tstruct fec_info* fec = bus->priv;\n\tstruct fec __iomem *fecp = fec->fecp;\n\tint i, ret = -1;\n\n\tBUG_ON((in_be32(&fecp->fec_r_cntrl) & FEC_RCNTRL_MII_MODE) == 0);\n\n\t \n\tout_be32(&fecp->fec_mii_data, (phy_id << 23) | mk_mii_read(location));\n\n\tfor (i = 0; i < FEC_MII_LOOPS; i++)\n\t\tif ((in_be32(&fecp->fec_ievent) & FEC_ENET_MII) != 0)\n\t\t\tbreak;\n\n\tif (i < FEC_MII_LOOPS) {\n\t\tout_be32(&fecp->fec_ievent, FEC_ENET_MII);\n\t\tret = in_be32(&fecp->fec_mii_data) & 0xffff;\n\t}\n\n\treturn ret;\n}\n\nstatic int fs_enet_fec_mii_write(struct mii_bus *bus, int phy_id, int location, u16 val)\n{\n\tstruct fec_info* fec = bus->priv;\n\tstruct fec __iomem *fecp = fec->fecp;\n\tint i;\n\n\t \n\tBUG_ON((in_be32(&fecp->fec_r_cntrl) & FEC_RCNTRL_MII_MODE) == 0);\n\n\t \n\tout_be32(&fecp->fec_mii_data, (phy_id << 23) | mk_mii_write(location, val));\n\n\tfor (i = 0; i < FEC_MII_LOOPS; i++)\n\t\tif ((in_be32(&fecp->fec_ievent) & FEC_ENET_MII) != 0)\n\t\t\tbreak;\n\n\tif (i < FEC_MII_LOOPS)\n\t\tout_be32(&fecp->fec_ievent, FEC_ENET_MII);\n\n\treturn 0;\n\n}\n\nstatic const struct of_device_id fs_enet_mdio_fec_match[];\nstatic int fs_enet_mdio_probe(struct platform_device *ofdev)\n{\n\tconst struct of_device_id *match;\n\tstruct resource res;\n\tstruct mii_bus *new_bus;\n\tstruct fec_info *fec;\n\tint (*get_bus_freq)(struct device *);\n\tint ret = -ENOMEM, clock, speed;\n\n\tmatch = of_match_device(fs_enet_mdio_fec_match, &ofdev->dev);\n\tif (!match)\n\t\treturn -EINVAL;\n\tget_bus_freq = match->data;\n\n\tnew_bus = mdiobus_alloc();\n\tif (!new_bus)\n\t\tgoto out;\n\n\tfec = kzalloc(sizeof(struct fec_info), GFP_KERNEL);\n\tif (!fec)\n\t\tgoto out_mii;\n\n\tnew_bus->priv = fec;\n\tnew_bus->name = \"FEC MII Bus\";\n\tnew_bus->read = &fs_enet_fec_mii_read;\n\tnew_bus->write = &fs_enet_fec_mii_write;\n\n\tret = of_address_to_resource(ofdev->dev.of_node, 0, &res);\n\tif (ret)\n\t\tgoto out_res;\n\n\tsnprintf(new_bus->id, MII_BUS_ID_SIZE, \"%pap\", &res.start);\n\n\tfec->fecp = ioremap(res.start, resource_size(&res));\n\tif (!fec->fecp) {\n\t\tret = -ENOMEM;\n\t\tgoto out_fec;\n\t}\n\n\tif (get_bus_freq) {\n\t\tclock = get_bus_freq(&ofdev->dev);\n\t\tif (!clock) {\n\t\t\t \n\t\t\tdev_warn(&ofdev->dev, \"could not determine IPS clock\\n\");\n\t\t\tclock = 0x3F * 5000000;\n\t\t}\n\t} else\n\t\tclock = ppc_proc_freq;\n\n\t \n\tspeed = (clock + 4999999) / 5000000;\n\tif (speed > 0x3F) {\n\t\tspeed = 0x3F;\n\t\tdev_err(&ofdev->dev,\n\t\t\t\"MII clock (%d Hz) exceeds max (2.5 MHz)\\n\",\n\t\t\tclock / speed);\n\t}\n\n\tfec->mii_speed = speed << 1;\n\n\tsetbits32(&fec->fecp->fec_r_cntrl, FEC_RCNTRL_MII_MODE);\n\tsetbits32(&fec->fecp->fec_ecntrl, FEC_ECNTRL_PINMUX |\n\t                                  FEC_ECNTRL_ETHER_EN);\n\tout_be32(&fec->fecp->fec_ievent, FEC_ENET_MII);\n\tclrsetbits_be32(&fec->fecp->fec_mii_speed, 0x7E, fec->mii_speed);\n\n\tnew_bus->phy_mask = ~0;\n\n\tnew_bus->parent = &ofdev->dev;\n\tplatform_set_drvdata(ofdev, new_bus);\n\n\tret = of_mdiobus_register(new_bus, ofdev->dev.of_node);\n\tif (ret)\n\t\tgoto out_unmap_regs;\n\n\treturn 0;\n\nout_unmap_regs:\n\tiounmap(fec->fecp);\nout_res:\nout_fec:\n\tkfree(fec);\nout_mii:\n\tmdiobus_free(new_bus);\nout:\n\treturn ret;\n}\n\nstatic void fs_enet_mdio_remove(struct platform_device *ofdev)\n{\n\tstruct mii_bus *bus = platform_get_drvdata(ofdev);\n\tstruct fec_info *fec = bus->priv;\n\n\tmdiobus_unregister(bus);\n\tiounmap(fec->fecp);\n\tkfree(fec);\n\tmdiobus_free(bus);\n}\n\nstatic const struct of_device_id fs_enet_mdio_fec_match[] = {\n\t{\n\t\t.compatible = \"fsl,pq1-fec-mdio\",\n\t},\n#if defined(CONFIG_PPC_MPC512x)\n\t{\n\t\t.compatible = \"fsl,mpc5121-fec-mdio\",\n\t\t.data = mpc5xxx_get_bus_frequency,\n\t},\n#endif\n\t{},\n};\nMODULE_DEVICE_TABLE(of, fs_enet_mdio_fec_match);\n\nstatic struct platform_driver fs_enet_fec_mdio_driver = {\n\t.driver = {\n\t\t.name = \"fsl-fec-mdio\",\n\t\t.of_match_table = fs_enet_mdio_fec_match,\n\t},\n\t.probe = fs_enet_mdio_probe,\n\t.remove_new = fs_enet_mdio_remove,\n};\n\nmodule_platform_driver(fs_enet_fec_mdio_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}