{
  "module_name": "xgmac_mdio.c",
  "hash_id": "1da2c3cd28c5393f9a1873f316845aa92dfead7cd2f45f16f5119bfa626579a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/xgmac_mdio.c",
  "human_readable_source": " \n\n#include <linux/acpi.h>\n#include <linux/acpi_mdio.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mdio.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n \n#define TIMEOUT\t1000\n\nstruct tgec_mdio_controller {\n\t__be32\treserved[12];\n\t__be32\tmdio_stat;\t \n\t__be32\tmdio_ctl;\t \n\t__be32\tmdio_data;\t \n\t__be32\tmdio_addr;\t \n} __packed;\n\n#define MDIO_STAT_ENC\t\tBIT(6)\n#define MDIO_STAT_CLKDIV(x)\t(((x) & 0x1ff) << 7)\n#define MDIO_STAT_BSY\t\tBIT(0)\n#define MDIO_STAT_RD_ER\t\tBIT(1)\n#define MDIO_STAT_PRE_DIS\tBIT(5)\n#define MDIO_CTL_DEV_ADDR(x) \t(x & 0x1f)\n#define MDIO_CTL_PORT_ADDR(x)\t((x & 0x1f) << 5)\n#define MDIO_CTL_PRE_DIS\tBIT(10)\n#define MDIO_CTL_SCAN_EN\tBIT(11)\n#define MDIO_CTL_POST_INC\tBIT(14)\n#define MDIO_CTL_READ\t\tBIT(15)\n\n#define MDIO_DATA(x)\t\t(x & 0xffff)\n\nstruct mdio_fsl_priv {\n\tstruct\ttgec_mdio_controller __iomem *mdio_base;\n\tstruct\tclk *enet_clk;\n\tu32\tmdc_freq;\n\tbool\tis_little_endian;\n\tbool\thas_a009885;\n\tbool\thas_a011043;\n};\n\nstatic u32 xgmac_read32(void __iomem *regs,\n\t\t\tbool is_little_endian)\n{\n\tif (is_little_endian)\n\t\treturn ioread32(regs);\n\telse\n\t\treturn ioread32be(regs);\n}\n\nstatic void xgmac_write32(u32 value,\n\t\t\t  void __iomem *regs,\n\t\t\t  bool is_little_endian)\n{\n\tif (is_little_endian)\n\t\tiowrite32(value, regs);\n\telse\n\t\tiowrite32be(value, regs);\n}\n\n \nstatic int xgmac_wait_until_free(struct device *dev,\n\t\t\t\t struct tgec_mdio_controller __iomem *regs,\n\t\t\t\t bool is_little_endian)\n{\n\tunsigned int timeout;\n\n\t \n\ttimeout = TIMEOUT;\n\twhile ((xgmac_read32(&regs->mdio_stat, is_little_endian) &\n\t\tMDIO_STAT_BSY) && timeout) {\n\t\tcpu_relax();\n\t\ttimeout--;\n\t}\n\n\tif (!timeout) {\n\t\tdev_err(dev, \"timeout waiting for bus to be free\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int xgmac_wait_until_done(struct device *dev,\n\t\t\t\t struct tgec_mdio_controller __iomem *regs,\n\t\t\t\t bool is_little_endian)\n{\n\tunsigned int timeout;\n\n\t \n\ttimeout = TIMEOUT;\n\twhile ((xgmac_read32(&regs->mdio_stat, is_little_endian) &\n\t\tMDIO_STAT_BSY) && timeout) {\n\t\tcpu_relax();\n\t\ttimeout--;\n\t}\n\n\tif (!timeout) {\n\t\tdev_err(dev, \"timeout waiting for operation to complete\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int xgmac_mdio_write_c22(struct mii_bus *bus, int phy_id, int regnum,\n\t\t\t\tu16 value)\n{\n\tstruct mdio_fsl_priv *priv = (struct mdio_fsl_priv *)bus->priv;\n\tstruct tgec_mdio_controller __iomem *regs = priv->mdio_base;\n\tbool endian = priv->is_little_endian;\n\tu16 dev_addr = regnum & 0x1f;\n\tu32 mdio_ctl, mdio_stat;\n\tint ret;\n\n\tmdio_stat = xgmac_read32(&regs->mdio_stat, endian);\n\tmdio_stat &= ~MDIO_STAT_ENC;\n\txgmac_write32(mdio_stat, &regs->mdio_stat, endian);\n\n\tret = xgmac_wait_until_free(&bus->dev, regs, endian);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);\n\txgmac_write32(mdio_ctl, &regs->mdio_ctl, endian);\n\n\t \n\txgmac_write32(MDIO_DATA(value), &regs->mdio_data, endian);\n\n\tret = xgmac_wait_until_done(&bus->dev, regs, endian);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int xgmac_mdio_write_c45(struct mii_bus *bus, int phy_id, int dev_addr,\n\t\t\t\tint regnum, u16 value)\n{\n\tstruct mdio_fsl_priv *priv = (struct mdio_fsl_priv *)bus->priv;\n\tstruct tgec_mdio_controller __iomem *regs = priv->mdio_base;\n\tbool endian = priv->is_little_endian;\n\tu32 mdio_ctl, mdio_stat;\n\tint ret;\n\n\tmdio_stat = xgmac_read32(&regs->mdio_stat, endian);\n\tmdio_stat |= MDIO_STAT_ENC;\n\n\txgmac_write32(mdio_stat, &regs->mdio_stat, endian);\n\n\tret = xgmac_wait_until_free(&bus->dev, regs, endian);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);\n\txgmac_write32(mdio_ctl, &regs->mdio_ctl, endian);\n\n\t \n\txgmac_write32(regnum & 0xffff, &regs->mdio_addr, endian);\n\n\tret = xgmac_wait_until_free(&bus->dev, regs, endian);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\txgmac_write32(MDIO_DATA(value), &regs->mdio_data, endian);\n\n\tret = xgmac_wait_until_done(&bus->dev, regs, endian);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int xgmac_mdio_read_c22(struct mii_bus *bus, int phy_id, int regnum)\n{\n\tstruct mdio_fsl_priv *priv = (struct mdio_fsl_priv *)bus->priv;\n\tstruct tgec_mdio_controller __iomem *regs = priv->mdio_base;\n\tbool endian = priv->is_little_endian;\n\tu16 dev_addr = regnum & 0x1f;\n\tunsigned long flags;\n\tuint32_t mdio_stat;\n\tuint32_t mdio_ctl;\n\tint ret;\n\n\tmdio_stat = xgmac_read32(&regs->mdio_stat, endian);\n\tmdio_stat &= ~MDIO_STAT_ENC;\n\txgmac_write32(mdio_stat, &regs->mdio_stat, endian);\n\n\tret = xgmac_wait_until_free(&bus->dev, regs, endian);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);\n\txgmac_write32(mdio_ctl, &regs->mdio_ctl, endian);\n\n\tif (priv->has_a009885)\n\t\t \n\t\tlocal_irq_save(flags);\n\n\t \n\txgmac_write32(mdio_ctl | MDIO_CTL_READ, &regs->mdio_ctl, endian);\n\n\tret = xgmac_wait_until_done(&bus->dev, regs, endian);\n\tif (ret)\n\t\tgoto irq_restore;\n\n\t \n\tif ((xgmac_read32(&regs->mdio_stat, endian) & MDIO_STAT_RD_ER) &&\n\t    !priv->has_a011043) {\n\t\tdev_dbg(&bus->dev,\n\t\t\t\"Error while reading PHY%d reg at %d.%d\\n\",\n\t\t\tphy_id, dev_addr, regnum);\n\t\tret = 0xffff;\n\t} else {\n\t\tret = xgmac_read32(&regs->mdio_data, endian) & 0xffff;\n\t\tdev_dbg(&bus->dev, \"read %04x\\n\", ret);\n\t}\n\nirq_restore:\n\tif (priv->has_a009885)\n\t\tlocal_irq_restore(flags);\n\n\treturn ret;\n}\n\n \nstatic int xgmac_mdio_read_c45(struct mii_bus *bus, int phy_id, int dev_addr,\n\t\t\t       int regnum)\n{\n\tstruct mdio_fsl_priv *priv = (struct mdio_fsl_priv *)bus->priv;\n\tstruct tgec_mdio_controller __iomem *regs = priv->mdio_base;\n\tbool endian = priv->is_little_endian;\n\tu32 mdio_stat, mdio_ctl;\n\tunsigned long flags;\n\tint ret;\n\n\tmdio_stat = xgmac_read32(&regs->mdio_stat, endian);\n\tmdio_stat |= MDIO_STAT_ENC;\n\n\txgmac_write32(mdio_stat, &regs->mdio_stat, endian);\n\n\tret = xgmac_wait_until_free(&bus->dev, regs, endian);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);\n\txgmac_write32(mdio_ctl, &regs->mdio_ctl, endian);\n\n\t \n\txgmac_write32(regnum & 0xffff, &regs->mdio_addr, endian);\n\n\tret = xgmac_wait_until_free(&bus->dev, regs, endian);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->has_a009885)\n\t\t \n\t\tlocal_irq_save(flags);\n\n\t \n\txgmac_write32(mdio_ctl | MDIO_CTL_READ, &regs->mdio_ctl, endian);\n\n\tret = xgmac_wait_until_done(&bus->dev, regs, endian);\n\tif (ret)\n\t\tgoto irq_restore;\n\n\t \n\tif ((xgmac_read32(&regs->mdio_stat, endian) & MDIO_STAT_RD_ER) &&\n\t    !priv->has_a011043) {\n\t\tdev_dbg(&bus->dev,\n\t\t\t\"Error while reading PHY%d reg at %d.%d\\n\",\n\t\t\tphy_id, dev_addr, regnum);\n\t\tret = 0xffff;\n\t} else {\n\t\tret = xgmac_read32(&regs->mdio_data, endian) & 0xffff;\n\t\tdev_dbg(&bus->dev, \"read %04x\\n\", ret);\n\t}\n\nirq_restore:\n\tif (priv->has_a009885)\n\t\tlocal_irq_restore(flags);\n\n\treturn ret;\n}\n\nstatic int xgmac_mdio_set_mdc_freq(struct mii_bus *bus)\n{\n\tstruct mdio_fsl_priv *priv = (struct mdio_fsl_priv *)bus->priv;\n\tstruct tgec_mdio_controller __iomem *regs = priv->mdio_base;\n\tstruct device *dev = bus->parent;\n\tu32 mdio_stat, div;\n\n\tif (device_property_read_u32(dev, \"clock-frequency\", &priv->mdc_freq))\n\t\treturn 0;\n\n\tpriv->enet_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->enet_clk)) {\n\t\tdev_err(dev, \"Input clock unknown, not changing MDC frequency\");\n\t\treturn PTR_ERR(priv->enet_clk);\n\t}\n\n\tdiv = ((clk_get_rate(priv->enet_clk) / priv->mdc_freq) - 1) / 2;\n\tif (div < 5 || div > 0x1ff) {\n\t\tdev_err(dev, \"Requested MDC frequency is out of range, ignoring\");\n\t\treturn -EINVAL;\n\t}\n\n\tmdio_stat = xgmac_read32(&regs->mdio_stat, priv->is_little_endian);\n\tmdio_stat &= ~MDIO_STAT_CLKDIV(0x1ff);\n\tmdio_stat |= MDIO_STAT_CLKDIV(div);\n\txgmac_write32(mdio_stat, &regs->mdio_stat, priv->is_little_endian);\n\treturn 0;\n}\n\nstatic void xgmac_mdio_set_suppress_preamble(struct mii_bus *bus)\n{\n\tstruct mdio_fsl_priv *priv = (struct mdio_fsl_priv *)bus->priv;\n\tstruct tgec_mdio_controller __iomem *regs = priv->mdio_base;\n\tstruct device *dev = bus->parent;\n\tu32 mdio_stat;\n\n\tif (!device_property_read_bool(dev, \"suppress-preamble\"))\n\t\treturn;\n\n\tmdio_stat = xgmac_read32(&regs->mdio_stat, priv->is_little_endian);\n\tmdio_stat |= MDIO_STAT_PRE_DIS;\n\txgmac_write32(mdio_stat, &regs->mdio_stat, priv->is_little_endian);\n}\n\nstatic int xgmac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct fwnode_handle *fwnode;\n\tstruct mdio_fsl_priv *priv;\n\tstruct resource *res;\n\tstruct mii_bus *bus;\n\tint ret;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"could not obtain address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbus = devm_mdiobus_alloc_size(&pdev->dev, sizeof(struct mdio_fsl_priv));\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->name = \"Freescale XGMAC MDIO Bus\";\n\tbus->read = xgmac_mdio_read_c22;\n\tbus->write = xgmac_mdio_write_c22;\n\tbus->read_c45 = xgmac_mdio_read_c45;\n\tbus->write_c45 = xgmac_mdio_write_c45;\n\tbus->parent = &pdev->dev;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%pa\", &res->start);\n\n\tpriv = bus->priv;\n\tpriv->mdio_base = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t       resource_size(res));\n\tif (!priv->mdio_base)\n\t\treturn -ENOMEM;\n\n\t \n\tpriv->is_little_endian = device_property_read_bool(&pdev->dev,\n\t\t\t\t\t\t\t   \"little-endian\");\n\n\tpriv->has_a009885 = device_property_read_bool(&pdev->dev,\n\t\t\t\t\t\t      \"fsl,erratum-a009885\");\n\tpriv->has_a011043 = device_property_read_bool(&pdev->dev,\n\t\t\t\t\t\t      \"fsl,erratum-a011043\");\n\n\txgmac_mdio_set_suppress_preamble(bus);\n\n\tret = xgmac_mdio_set_mdc_freq(bus);\n\tif (ret)\n\t\treturn ret;\n\n\tfwnode = dev_fwnode(&pdev->dev);\n\tif (is_of_node(fwnode))\n\t\tret = of_mdiobus_register(bus, to_of_node(fwnode));\n\telse if (is_acpi_node(fwnode))\n\t\tret = acpi_mdiobus_register(bus, fwnode);\n\telse\n\t\tret = -EINVAL;\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot register MDIO bus\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, bus);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id xgmac_mdio_match[] = {\n\t{\n\t\t.compatible = \"fsl,fman-xmdio\",\n\t},\n\t{\n\t\t.compatible = \"fsl,fman-memac-mdio\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xgmac_mdio_match);\n\nstatic const struct acpi_device_id xgmac_acpi_match[] = {\n\t{ \"NXP0006\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, xgmac_acpi_match);\n\nstatic struct platform_driver xgmac_mdio_driver = {\n\t.driver = {\n\t\t.name = \"fsl-fman_xmdio\",\n\t\t.of_match_table = xgmac_mdio_match,\n\t\t.acpi_match_table = xgmac_acpi_match,\n\t},\n\t.probe = xgmac_mdio_probe,\n};\n\nmodule_platform_driver(xgmac_mdio_driver);\n\nMODULE_DESCRIPTION(\"Freescale QorIQ 10G MDIO Controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}