{
  "module_name": "dpaa_ethtool.c",
  "hash_id": "81592c288ab104ca76dc0ab285a1f06ef0cb5a7aca77c46c59c273561e9c4fc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/dpaa/dpaa_ethtool.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/string.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/net_tstamp.h>\n#include <linux/fsl/ptp_qoriq.h>\n\n#include \"dpaa_eth.h\"\n#include \"mac.h\"\n\nstatic const char dpaa_stats_percpu[][ETH_GSTRING_LEN] = {\n\t\"interrupts\",\n\t\"rx packets\",\n\t\"tx packets\",\n\t\"tx confirm\",\n\t\"tx S/G\",\n\t\"tx error\",\n\t\"rx error\",\n\t\"rx dropped\",\n\t\"tx dropped\",\n};\n\nstatic char dpaa_stats_global[][ETH_GSTRING_LEN] = {\n\t \n\t\"rx dma error\",\n\t\"rx frame physical error\",\n\t\"rx frame size error\",\n\t\"rx header error\",\n\n\t \n\t\"qman cg_tdrop\",\n\t\"qman wred\",\n\t\"qman error cond\",\n\t\"qman early window\",\n\t\"qman late window\",\n\t\"qman fq tdrop\",\n\t\"qman fq retired\",\n\t\"qman orp disabled\",\n\n\t \n\t\"congestion time (ms)\",\n\t\"entered congestion\",\n\t\"congested (0/1)\"\n};\n\n#define DPAA_STATS_PERCPU_LEN ARRAY_SIZE(dpaa_stats_percpu)\n#define DPAA_STATS_GLOBAL_LEN ARRAY_SIZE(dpaa_stats_global)\n\nstatic int dpaa_get_link_ksettings(struct net_device *net_dev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct dpaa_priv *priv = netdev_priv(net_dev);\n\tstruct mac_device *mac_dev = priv->mac_dev;\n\n\treturn phylink_ethtool_ksettings_get(mac_dev->phylink, cmd);\n}\n\nstatic int dpaa_set_link_ksettings(struct net_device *net_dev,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tstruct dpaa_priv *priv = netdev_priv(net_dev);\n\tstruct mac_device *mac_dev = priv->mac_dev;\n\n\treturn phylink_ethtool_ksettings_set(mac_dev->phylink, cmd);\n}\n\nstatic void dpaa_get_drvinfo(struct net_device *net_dev,\n\t\t\t     struct ethtool_drvinfo *drvinfo)\n{\n\tstrscpy(drvinfo->driver, KBUILD_MODNAME,\n\t\tsizeof(drvinfo->driver));\n\tstrscpy(drvinfo->bus_info, dev_name(net_dev->dev.parent->parent),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic u32 dpaa_get_msglevel(struct net_device *net_dev)\n{\n\treturn ((struct dpaa_priv *)netdev_priv(net_dev))->msg_enable;\n}\n\nstatic void dpaa_set_msglevel(struct net_device *net_dev,\n\t\t\t      u32 msg_enable)\n{\n\t((struct dpaa_priv *)netdev_priv(net_dev))->msg_enable = msg_enable;\n}\n\nstatic int dpaa_nway_reset(struct net_device *net_dev)\n{\n\tstruct dpaa_priv *priv = netdev_priv(net_dev);\n\tstruct mac_device *mac_dev = priv->mac_dev;\n\n\treturn phylink_ethtool_nway_reset(mac_dev->phylink);\n}\n\nstatic void dpaa_get_pauseparam(struct net_device *net_dev,\n\t\t\t\tstruct ethtool_pauseparam *epause)\n{\n\tstruct dpaa_priv *priv = netdev_priv(net_dev);\n\tstruct mac_device *mac_dev = priv->mac_dev;\n\n\tphylink_ethtool_get_pauseparam(mac_dev->phylink, epause);\n}\n\nstatic int dpaa_set_pauseparam(struct net_device *net_dev,\n\t\t\t       struct ethtool_pauseparam *epause)\n{\n\tstruct dpaa_priv *priv = netdev_priv(net_dev);\n\tstruct mac_device *mac_dev = priv->mac_dev;\n\n\treturn phylink_ethtool_set_pauseparam(mac_dev->phylink, epause);\n}\n\nstatic int dpaa_get_sset_count(struct net_device *net_dev, int type)\n{\n\tunsigned int total_stats, num_stats;\n\n\tnum_stats   = num_online_cpus() + 1;\n\ttotal_stats = num_stats * (DPAA_STATS_PERCPU_LEN + 1) +\n\t\t\tDPAA_STATS_GLOBAL_LEN;\n\n\tswitch (type) {\n\tcase ETH_SS_STATS:\n\t\treturn total_stats;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void copy_stats(struct dpaa_percpu_priv *percpu_priv, int num_cpus,\n\t\t       int crr_cpu, u64 bp_count, u64 *data)\n{\n\tint num_values = num_cpus + 1;\n\tint crr = 0;\n\n\t \n\tdata[crr * num_values + crr_cpu] = percpu_priv->in_interrupt;\n\tdata[crr++ * num_values + num_cpus] += percpu_priv->in_interrupt;\n\n\tdata[crr * num_values + crr_cpu] = percpu_priv->stats.rx_packets;\n\tdata[crr++ * num_values + num_cpus] += percpu_priv->stats.rx_packets;\n\n\tdata[crr * num_values + crr_cpu] = percpu_priv->stats.tx_packets;\n\tdata[crr++ * num_values + num_cpus] += percpu_priv->stats.tx_packets;\n\n\tdata[crr * num_values + crr_cpu] = percpu_priv->tx_confirm;\n\tdata[crr++ * num_values + num_cpus] += percpu_priv->tx_confirm;\n\n\tdata[crr * num_values + crr_cpu] = percpu_priv->tx_frag_skbuffs;\n\tdata[crr++ * num_values + num_cpus] += percpu_priv->tx_frag_skbuffs;\n\n\tdata[crr * num_values + crr_cpu] = percpu_priv->stats.tx_errors;\n\tdata[crr++ * num_values + num_cpus] += percpu_priv->stats.tx_errors;\n\n\tdata[crr * num_values + crr_cpu] = percpu_priv->stats.rx_errors;\n\tdata[crr++ * num_values + num_cpus] += percpu_priv->stats.rx_errors;\n\n\tdata[crr * num_values + crr_cpu] = percpu_priv->stats.rx_dropped;\n\tdata[crr++ * num_values + num_cpus] += percpu_priv->stats.rx_dropped;\n\n\tdata[crr * num_values + crr_cpu] = percpu_priv->stats.tx_dropped;\n\tdata[crr++ * num_values + num_cpus] += percpu_priv->stats.tx_dropped;\n\n\tdata[crr * num_values + crr_cpu] = bp_count;\n\tdata[crr++ * num_values + num_cpus] += bp_count;\n}\n\nstatic void dpaa_get_ethtool_stats(struct net_device *net_dev,\n\t\t\t\t   struct ethtool_stats *stats, u64 *data)\n{\n\tstruct dpaa_percpu_priv *percpu_priv;\n\tstruct dpaa_rx_errors rx_errors;\n\tunsigned int num_cpus, offset;\n\tu64 bp_count, cg_time, cg_num;\n\tstruct dpaa_ern_cnt ern_cnt;\n\tstruct dpaa_bp *dpaa_bp;\n\tstruct dpaa_priv *priv;\n\tint total_stats, i;\n\tbool cg_status;\n\n\ttotal_stats = dpaa_get_sset_count(net_dev, ETH_SS_STATS);\n\tpriv     = netdev_priv(net_dev);\n\tnum_cpus = num_online_cpus();\n\n\tmemset(&bp_count, 0, sizeof(bp_count));\n\tmemset(&rx_errors, 0, sizeof(struct dpaa_rx_errors));\n\tmemset(&ern_cnt, 0, sizeof(struct dpaa_ern_cnt));\n\tmemset(data, 0, total_stats * sizeof(u64));\n\n\tfor_each_online_cpu(i) {\n\t\tpercpu_priv = per_cpu_ptr(priv->percpu_priv, i);\n\t\tdpaa_bp = priv->dpaa_bp;\n\t\tif (!dpaa_bp->percpu_count)\n\t\t\tcontinue;\n\t\tbp_count = *(per_cpu_ptr(dpaa_bp->percpu_count, i));\n\t\trx_errors.dme += percpu_priv->rx_errors.dme;\n\t\trx_errors.fpe += percpu_priv->rx_errors.fpe;\n\t\trx_errors.fse += percpu_priv->rx_errors.fse;\n\t\trx_errors.phe += percpu_priv->rx_errors.phe;\n\n\t\tern_cnt.cg_tdrop     += percpu_priv->ern_cnt.cg_tdrop;\n\t\tern_cnt.wred         += percpu_priv->ern_cnt.wred;\n\t\tern_cnt.err_cond     += percpu_priv->ern_cnt.err_cond;\n\t\tern_cnt.early_window += percpu_priv->ern_cnt.early_window;\n\t\tern_cnt.late_window  += percpu_priv->ern_cnt.late_window;\n\t\tern_cnt.fq_tdrop     += percpu_priv->ern_cnt.fq_tdrop;\n\t\tern_cnt.fq_retired   += percpu_priv->ern_cnt.fq_retired;\n\t\tern_cnt.orp_zero     += percpu_priv->ern_cnt.orp_zero;\n\n\t\tcopy_stats(percpu_priv, num_cpus, i, bp_count, data);\n\t}\n\n\toffset = (num_cpus + 1) * (DPAA_STATS_PERCPU_LEN + 1);\n\tmemcpy(data + offset, &rx_errors, sizeof(struct dpaa_rx_errors));\n\n\toffset += sizeof(struct dpaa_rx_errors) / sizeof(u64);\n\tmemcpy(data + offset, &ern_cnt, sizeof(struct dpaa_ern_cnt));\n\n\t \n\tcg_num    = 0;\n\tcg_status = false;\n\tcg_time   = jiffies_to_msecs(priv->cgr_data.congested_jiffies);\n\tif (qman_query_cgr_congested(&priv->cgr_data.cgr, &cg_status) == 0) {\n\t\tcg_num    = priv->cgr_data.cgr_congested_count;\n\n\t\t \n\t\tpriv->cgr_data.congested_jiffies   = 0;\n\t\tpriv->cgr_data.cgr_congested_count = 0;\n\t}\n\n\toffset += sizeof(struct dpaa_ern_cnt) / sizeof(u64);\n\tdata[offset++] = cg_time;\n\tdata[offset++] = cg_num;\n\tdata[offset++] = cg_status;\n}\n\nstatic void dpaa_get_strings(struct net_device *net_dev, u32 stringset,\n\t\t\t     u8 *data)\n{\n\tunsigned int i, j, num_cpus, size;\n\tchar string_cpu[ETH_GSTRING_LEN];\n\tu8 *strings;\n\n\tmemset(string_cpu, 0, sizeof(string_cpu));\n\tstrings   = data;\n\tnum_cpus  = num_online_cpus();\n\tsize      = DPAA_STATS_GLOBAL_LEN * ETH_GSTRING_LEN;\n\n\tfor (i = 0; i < DPAA_STATS_PERCPU_LEN; i++) {\n\t\tfor (j = 0; j < num_cpus; j++) {\n\t\t\tsnprintf(string_cpu, ETH_GSTRING_LEN, \"%s [CPU %d]\",\n\t\t\t\t dpaa_stats_percpu[i], j);\n\t\t\tmemcpy(strings, string_cpu, ETH_GSTRING_LEN);\n\t\t\tstrings += ETH_GSTRING_LEN;\n\t\t}\n\t\tsnprintf(string_cpu, ETH_GSTRING_LEN, \"%s [TOTAL]\",\n\t\t\t dpaa_stats_percpu[i]);\n\t\tmemcpy(strings, string_cpu, ETH_GSTRING_LEN);\n\t\tstrings += ETH_GSTRING_LEN;\n\t}\n\tfor (j = 0; j < num_cpus; j++) {\n\t\tsnprintf(string_cpu, ETH_GSTRING_LEN,\n\t\t\t \"bpool [CPU %d]\", j);\n\t\tmemcpy(strings, string_cpu, ETH_GSTRING_LEN);\n\t\tstrings += ETH_GSTRING_LEN;\n\t}\n\tsnprintf(string_cpu, ETH_GSTRING_LEN, \"bpool [TOTAL]\");\n\tmemcpy(strings, string_cpu, ETH_GSTRING_LEN);\n\tstrings += ETH_GSTRING_LEN;\n\n\tmemcpy(strings, dpaa_stats_global, size);\n}\n\nstatic int dpaa_get_hash_opts(struct net_device *dev,\n\t\t\t      struct ethtool_rxnfc *cmd)\n{\n\tstruct dpaa_priv *priv = netdev_priv(dev);\n\n\tcmd->data = 0;\n\n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase UDP_V6_FLOW:\n\t\tif (priv->keygen_in_use)\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tfallthrough;\n\tcase IPV4_FLOW:\n\tcase IPV6_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V4_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase ESP_V6_FLOW:\n\t\tif (priv->keygen_in_use)\n\t\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tdefault:\n\t\tcmd->data = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int dpaa_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\n\t\t\t  u32 *unused)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXFH:\n\t\tret = dpaa_get_hash_opts(dev, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void dpaa_set_hash(struct net_device *net_dev, bool enable)\n{\n\tstruct mac_device *mac_dev;\n\tstruct fman_port *rxport;\n\tstruct dpaa_priv *priv;\n\n\tpriv = netdev_priv(net_dev);\n\tmac_dev = priv->mac_dev;\n\trxport = mac_dev->port[0];\n\n\tfman_port_use_kg_hash(rxport, enable);\n\tpriv->keygen_in_use = enable;\n}\n\nstatic int dpaa_set_hash_opts(struct net_device *dev,\n\t\t\t      struct ethtool_rxnfc *nfc)\n{\n\tint ret = -EINVAL;\n\n\t \n\tif (nfc->data &\n\t    ~(RXH_IP_SRC | RXH_IP_DST | RXH_L4_B_0_1 | RXH_L4_B_2_3))\n\t\treturn -EINVAL;\n\n\tswitch (nfc->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase UDP_V6_FLOW:\n\tcase IPV4_FLOW:\n\tcase IPV6_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V4_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase ESP_V6_FLOW:\n\t\tdpaa_set_hash(dev, !!nfc->data);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int dpaa_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\tret = dpaa_set_hash_opts(dev, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int dpaa_get_ts_info(struct net_device *net_dev,\n\t\t\t    struct ethtool_ts_info *info)\n{\n\tstruct device *dev = net_dev->dev.parent;\n\tstruct device_node *mac_node = dev->of_node;\n\tstruct device_node *fman_node = NULL, *ptp_node = NULL;\n\tstruct platform_device *ptp_dev = NULL;\n\tstruct ptp_qoriq *ptp = NULL;\n\n\tinfo->phc_index = -1;\n\n\tfman_node = of_get_parent(mac_node);\n\tif (fman_node) {\n\t\tptp_node = of_parse_phandle(fman_node, \"ptimer-handle\", 0);\n\t\tof_node_put(fman_node);\n\t}\n\n\tif (ptp_node) {\n\t\tptp_dev = of_find_device_by_node(ptp_node);\n\t\tof_node_put(ptp_node);\n\t}\n\n\tif (ptp_dev)\n\t\tptp = platform_get_drvdata(ptp_dev);\n\n\tif (ptp)\n\t\tinfo->phc_index = ptp->phc_index;\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tinfo->tx_types = (1 << HWTSTAMP_TX_OFF) |\n\t\t\t (1 << HWTSTAMP_TX_ON);\n\tinfo->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t   (1 << HWTSTAMP_FILTER_ALL);\n\n\treturn 0;\n}\n\nstatic int dpaa_get_coalesce(struct net_device *dev,\n\t\t\t     struct ethtool_coalesce *c,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct qman_portal *portal;\n\tu32 period;\n\tu8 thresh;\n\n\tportal = qman_get_affine_portal(smp_processor_id());\n\tqman_portal_get_iperiod(portal, &period);\n\tqman_dqrr_get_ithresh(portal, &thresh);\n\n\tc->rx_coalesce_usecs = period;\n\tc->rx_max_coalesced_frames = thresh;\n\n\treturn 0;\n}\n\nstatic int dpaa_set_coalesce(struct net_device *dev,\n\t\t\t     struct ethtool_coalesce *c,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tconst cpumask_t *cpus = qman_affine_cpus();\n\tbool needs_revert[NR_CPUS] = {false};\n\tstruct qman_portal *portal;\n\tu32 period, prev_period;\n\tu8 thresh, prev_thresh;\n\tint cpu, res;\n\n\tperiod = c->rx_coalesce_usecs;\n\tthresh = c->rx_max_coalesced_frames;\n\n\t \n\tportal = qman_get_affine_portal(smp_processor_id());\n\tqman_portal_get_iperiod(portal, &prev_period);\n\tqman_dqrr_get_ithresh(portal, &prev_thresh);\n\n\t \n\tfor_each_cpu_and(cpu, cpus, cpu_online_mask) {\n\t\tportal = qman_get_affine_portal(cpu);\n\t\tres = qman_portal_set_iperiod(portal, period);\n\t\tif (res)\n\t\t\tgoto revert_values;\n\t\tres = qman_dqrr_set_ithresh(portal, thresh);\n\t\tif (res) {\n\t\t\tqman_portal_set_iperiod(portal, prev_period);\n\t\t\tgoto revert_values;\n\t\t}\n\t\tneeds_revert[cpu] = true;\n\t}\n\n\treturn 0;\n\nrevert_values:\n\t \n\tfor_each_cpu_and(cpu, cpus, cpu_online_mask) {\n\t\tif (!needs_revert[cpu])\n\t\t\tcontinue;\n\t\tportal = qman_get_affine_portal(cpu);\n\t\t \n\t\tqman_portal_set_iperiod(portal, prev_period);\n\t\tqman_dqrr_set_ithresh(portal, prev_thresh);\n\t}\n\n\treturn res;\n}\n\nconst struct ethtool_ops dpaa_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_RX_MAX_FRAMES,\n\t.get_drvinfo = dpaa_get_drvinfo,\n\t.get_msglevel = dpaa_get_msglevel,\n\t.set_msglevel = dpaa_set_msglevel,\n\t.nway_reset = dpaa_nway_reset,\n\t.get_pauseparam = dpaa_get_pauseparam,\n\t.set_pauseparam = dpaa_set_pauseparam,\n\t.get_link = ethtool_op_get_link,\n\t.get_sset_count = dpaa_get_sset_count,\n\t.get_ethtool_stats = dpaa_get_ethtool_stats,\n\t.get_strings = dpaa_get_strings,\n\t.get_link_ksettings = dpaa_get_link_ksettings,\n\t.set_link_ksettings = dpaa_set_link_ksettings,\n\t.get_rxnfc = dpaa_get_rxnfc,\n\t.set_rxnfc = dpaa_set_rxnfc,\n\t.get_ts_info = dpaa_get_ts_info,\n\t.get_coalesce = dpaa_get_coalesce,\n\t.set_coalesce = dpaa_set_coalesce,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}