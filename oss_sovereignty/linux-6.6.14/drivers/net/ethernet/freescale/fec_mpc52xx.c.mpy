{
  "module_name": "fec_mpc52xx.c",
  "hash_id": "a3803b53d083c52e40ffaa6e3cf316dad94a5bd4ed7c81daaa827bfd8de1acda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fec_mpc52xx.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/crc32.h>\n#include <linux/hardirq.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/platform_device.h>\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/skbuff.h>\n\n#include <asm/io.h>\n#include <asm/delay.h>\n#include <asm/mpc52xx.h>\n\n#include <linux/fsl/bestcomm/bestcomm.h>\n#include <linux/fsl/bestcomm/fec.h>\n\n#include \"fec_mpc52xx.h\"\n\n#define DRIVER_NAME \"mpc52xx-fec\"\n\n \nstruct mpc52xx_fec_priv {\n\tstruct net_device *ndev;\n\tint duplex;\n\tint speed;\n\tint r_irq;\n\tint t_irq;\n\tstruct mpc52xx_fec __iomem *fec;\n\tstruct bcom_task *rx_dmatsk;\n\tstruct bcom_task *tx_dmatsk;\n\tspinlock_t lock;\n\tint msg_enable;\n\n\t \n\tunsigned int mdio_speed;\n\tstruct device_node *phy_node;\n\tenum phy_state link;\n\tint seven_wire_mode;\n};\n\n\nstatic irqreturn_t mpc52xx_fec_interrupt(int, void *);\nstatic irqreturn_t mpc52xx_fec_rx_interrupt(int, void *);\nstatic irqreturn_t mpc52xx_fec_tx_interrupt(int, void *);\nstatic void mpc52xx_fec_stop(struct net_device *dev, bool may_sleep);\nstatic void mpc52xx_fec_start(struct net_device *dev);\nstatic void mpc52xx_fec_reset(struct net_device *dev);\n\n#define MPC52xx_MESSAGES_DEFAULT ( NETIF_MSG_DRV | NETIF_MSG_PROBE | \\\n\t\tNETIF_MSG_LINK | NETIF_MSG_IFDOWN | NETIF_MSG_IFUP)\nstatic int debug = -1;\t \nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"debugging messages level\");\n\nstatic void mpc52xx_fec_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tunsigned long flags;\n\n\tdev_warn(&dev->dev, \"transmit timed out\\n\");\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tmpc52xx_fec_reset(dev);\n\tdev->stats.tx_errors++;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tnetif_wake_queue(dev);\n}\n\nstatic void mpc52xx_fec_set_paddr(struct net_device *dev, const u8 *mac)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct mpc52xx_fec __iomem *fec = priv->fec;\n\n\tout_be32(&fec->paddr1, *(const u32 *)(&mac[0]));\n\tout_be32(&fec->paddr2, (*(const u16 *)(&mac[4]) << 16) | FEC_PADDR2_TYPE);\n}\n\nstatic int mpc52xx_fec_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *sock = addr;\n\n\teth_hw_addr_set(dev, sock->sa_data);\n\n\tmpc52xx_fec_set_paddr(dev, sock->sa_data);\n\treturn 0;\n}\n\nstatic void mpc52xx_fec_free_rx_buffers(struct net_device *dev, struct bcom_task *s)\n{\n\twhile (!bcom_queue_empty(s)) {\n\t\tstruct bcom_fec_bd *bd;\n\t\tstruct sk_buff *skb;\n\n\t\tskb = bcom_retrieve_buffer(s, NULL, (struct bcom_bd **)&bd);\n\t\tdma_unmap_single(dev->dev.parent, bd->skb_pa, skb->len,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tkfree_skb(skb);\n\t}\n}\n\nstatic void\nmpc52xx_fec_rx_submit(struct net_device *dev, struct sk_buff *rskb)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct bcom_fec_bd *bd;\n\n\tbd = (struct bcom_fec_bd *) bcom_prepare_next_buffer(priv->rx_dmatsk);\n\tbd->status = FEC_RX_BUFFER_SIZE;\n\tbd->skb_pa = dma_map_single(dev->dev.parent, rskb->data,\n\t\t\t\t    FEC_RX_BUFFER_SIZE, DMA_FROM_DEVICE);\n\tbcom_submit_next_buffer(priv->rx_dmatsk, rskb);\n}\n\nstatic int mpc52xx_fec_alloc_rx_buffers(struct net_device *dev, struct bcom_task *rxtsk)\n{\n\tstruct sk_buff *skb;\n\n\twhile (!bcom_queue_full(rxtsk)) {\n\t\tskb = netdev_alloc_skb(dev, FEC_RX_BUFFER_SIZE);\n\t\tif (!skb)\n\t\t\treturn -EAGAIN;\n\n\t\t \n\t\tmemset(skb->data, 0, FEC_RX_BUFFER_SIZE);\n\t\tmpc52xx_fec_rx_submit(dev, skb);\n\t}\n\treturn 0;\n}\n\n \nstatic void mpc52xx_fec_adjust_link(struct net_device *dev)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tint new_state = 0;\n\n\tif (phydev->link != PHY_DOWN) {\n\t\tif (phydev->duplex != priv->duplex) {\n\t\t\tstruct mpc52xx_fec __iomem *fec = priv->fec;\n\t\t\tu32 rcntrl;\n\t\t\tu32 tcntrl;\n\n\t\t\tnew_state = 1;\n\t\t\tpriv->duplex = phydev->duplex;\n\n\t\t\trcntrl = in_be32(&fec->r_cntrl);\n\t\t\ttcntrl = in_be32(&fec->x_cntrl);\n\n\t\t\trcntrl &= ~FEC_RCNTRL_DRT;\n\t\t\ttcntrl &= ~FEC_TCNTRL_FDEN;\n\t\t\tif (phydev->duplex == DUPLEX_FULL)\n\t\t\t\ttcntrl |= FEC_TCNTRL_FDEN;\t \n\t\t\telse\n\t\t\t\trcntrl |= FEC_RCNTRL_DRT;\t \n\n\t\t\tout_be32(&fec->r_cntrl, rcntrl);\n\t\t\tout_be32(&fec->x_cntrl, tcntrl);\n\t\t}\n\n\t\tif (phydev->speed != priv->speed) {\n\t\t\tnew_state = 1;\n\t\t\tpriv->speed = phydev->speed;\n\t\t}\n\n\t\tif (priv->link == PHY_DOWN) {\n\t\t\tnew_state = 1;\n\t\t\tpriv->link = phydev->link;\n\t\t}\n\n\t} else if (priv->link) {\n\t\tnew_state = 1;\n\t\tpriv->link = PHY_DOWN;\n\t\tpriv->speed = 0;\n\t\tpriv->duplex = -1;\n\t}\n\n\tif (new_state && netif_msg_link(priv))\n\t\tphy_print_status(phydev);\n}\n\nstatic int mpc52xx_fec_open(struct net_device *dev)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct phy_device *phydev = NULL;\n\tint err = -EBUSY;\n\n\tif (priv->phy_node) {\n\t\tphydev = of_phy_connect(priv->ndev, priv->phy_node,\n\t\t\t\t\tmpc52xx_fec_adjust_link, 0, 0);\n\t\tif (!phydev) {\n\t\t\tdev_err(&dev->dev, \"of_phy_connect failed\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tphy_start(phydev);\n\t}\n\n\tif (request_irq(dev->irq, mpc52xx_fec_interrupt, IRQF_SHARED,\n\t                DRIVER_NAME \"_ctrl\", dev)) {\n\t\tdev_err(&dev->dev, \"ctrl interrupt request failed\\n\");\n\t\tgoto free_phy;\n\t}\n\tif (request_irq(priv->r_irq, mpc52xx_fec_rx_interrupt, 0,\n\t                DRIVER_NAME \"_rx\", dev)) {\n\t\tdev_err(&dev->dev, \"rx interrupt request failed\\n\");\n\t\tgoto free_ctrl_irq;\n\t}\n\tif (request_irq(priv->t_irq, mpc52xx_fec_tx_interrupt, 0,\n\t                DRIVER_NAME \"_tx\", dev)) {\n\t\tdev_err(&dev->dev, \"tx interrupt request failed\\n\");\n\t\tgoto free_2irqs;\n\t}\n\n\tbcom_fec_rx_reset(priv->rx_dmatsk);\n\tbcom_fec_tx_reset(priv->tx_dmatsk);\n\n\terr = mpc52xx_fec_alloc_rx_buffers(dev, priv->rx_dmatsk);\n\tif (err) {\n\t\tdev_err(&dev->dev, \"mpc52xx_fec_alloc_rx_buffers failed\\n\");\n\t\tgoto free_irqs;\n\t}\n\n\tbcom_enable(priv->rx_dmatsk);\n\tbcom_enable(priv->tx_dmatsk);\n\n\tmpc52xx_fec_start(dev);\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n\n free_irqs:\n\tfree_irq(priv->t_irq, dev);\n free_2irqs:\n\tfree_irq(priv->r_irq, dev);\n free_ctrl_irq:\n\tfree_irq(dev->irq, dev);\n free_phy:\n\tif (phydev) {\n\t\tphy_stop(phydev);\n\t\tphy_disconnect(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic int mpc52xx_fec_close(struct net_device *dev)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\n\tnetif_stop_queue(dev);\n\n\tmpc52xx_fec_stop(dev, true);\n\n\tmpc52xx_fec_free_rx_buffers(dev, priv->rx_dmatsk);\n\n\tfree_irq(dev->irq, dev);\n\tfree_irq(priv->r_irq, dev);\n\tfree_irq(priv->t_irq, dev);\n\n\tif (phydev) {\n\t\t \n\t\tphy_stop(phydev);\n\t\tphy_disconnect(phydev);\n\t}\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t\nmpc52xx_fec_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct bcom_fec_bd *bd;\n\tunsigned long flags;\n\n\tif (bcom_queue_full(priv->tx_dmatsk)) {\n\t\tif (net_ratelimit())\n\t\t\tdev_err(&dev->dev, \"transmit queue overrun\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tbd = (struct bcom_fec_bd *)\n\t\tbcom_prepare_next_buffer(priv->tx_dmatsk);\n\n\tbd->status = skb->len | BCOM_FEC_TX_BD_TFD | BCOM_FEC_TX_BD_TC;\n\tbd->skb_pa = dma_map_single(dev->dev.parent, skb->data, skb->len,\n\t\t\t\t    DMA_TO_DEVICE);\n\n\tskb_tx_timestamp(skb);\n\tbcom_submit_next_buffer(priv->tx_dmatsk, skb);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tif (bcom_queue_full(priv->tx_dmatsk)) {\n\t\tnetif_stop_queue(dev);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void mpc52xx_fec_poll_controller(struct net_device *dev)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\n\tdisable_irq(priv->t_irq);\n\tmpc52xx_fec_tx_interrupt(priv->t_irq, dev);\n\tenable_irq(priv->t_irq);\n\tdisable_irq(priv->r_irq);\n\tmpc52xx_fec_rx_interrupt(priv->r_irq, dev);\n\tenable_irq(priv->r_irq);\n}\n#endif\n\n\n \nstatic irqreturn_t mpc52xx_fec_tx_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\n\tspin_lock(&priv->lock);\n\twhile (bcom_buffer_done(priv->tx_dmatsk)) {\n\t\tstruct sk_buff *skb;\n\t\tstruct bcom_fec_bd *bd;\n\t\tskb = bcom_retrieve_buffer(priv->tx_dmatsk, NULL,\n\t\t\t\t(struct bcom_bd **)&bd);\n\t\tdma_unmap_single(dev->dev.parent, bd->skb_pa, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\n\t\tdev_consume_skb_irq(skb);\n\t}\n\tspin_unlock(&priv->lock);\n\n\tnetif_wake_queue(dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mpc52xx_fec_rx_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct sk_buff *rskb;  \n\tstruct sk_buff *skb;   \n\tstruct bcom_fec_bd *bd;\n\tu32 status, physaddr;\n\tint length;\n\n\tspin_lock(&priv->lock);\n\n\twhile (bcom_buffer_done(priv->rx_dmatsk)) {\n\n\t\trskb = bcom_retrieve_buffer(priv->rx_dmatsk, &status,\n\t\t\t\t\t    (struct bcom_bd **)&bd);\n\t\tphysaddr = bd->skb_pa;\n\n\t\t \n\t\tif (status & BCOM_FEC_RX_BD_ERRORS) {\n\t\t\t \n\t\t\tmpc52xx_fec_rx_submit(dev, rskb);\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tskb = netdev_alloc_skb(dev, FEC_RX_BUFFER_SIZE);\n\t\tif (!skb) {\n\t\t\t \n\t\t\tdev_notice(&dev->dev, \"Low memory - dropped packet.\\n\");\n\t\t\tmpc52xx_fec_rx_submit(dev, rskb);\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmpc52xx_fec_rx_submit(dev, skb);\n\n\t\t \n\t\tspin_unlock(&priv->lock);\n\n\t\tdma_unmap_single(dev->dev.parent, physaddr, rskb->len,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tlength = status & BCOM_FEC_RX_BD_LEN_MASK;\n\t\tskb_put(rskb, length - 4);\t \n\t\trskb->protocol = eth_type_trans(rskb, dev);\n\t\tif (!skb_defer_rx_timestamp(rskb))\n\t\t\tnetif_rx(rskb);\n\n\t\tspin_lock(&priv->lock);\n\t}\n\n\tspin_unlock(&priv->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mpc52xx_fec_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct mpc52xx_fec __iomem *fec = priv->fec;\n\tu32 ievent;\n\n\tievent = in_be32(&fec->ievent);\n\n\tievent &= ~FEC_IEVENT_MII;\t \n\tif (!ievent)\n\t\treturn IRQ_NONE;\n\n\tout_be32(&fec->ievent, ievent);\t\t \n\n\t \n\tif (ievent & (FEC_IEVENT_RFIFO_ERROR | FEC_IEVENT_XFIFO_ERROR)) {\n\n\t\tif (net_ratelimit() && (ievent & FEC_IEVENT_RFIFO_ERROR))\n\t\t\tdev_warn(&dev->dev, \"FEC_IEVENT_RFIFO_ERROR\\n\");\n\t\tif (net_ratelimit() && (ievent & FEC_IEVENT_XFIFO_ERROR))\n\t\t\tdev_warn(&dev->dev, \"FEC_IEVENT_XFIFO_ERROR\\n\");\n\n\t\tspin_lock(&priv->lock);\n\t\tmpc52xx_fec_reset(dev);\n\t\tspin_unlock(&priv->lock);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (ievent & ~FEC_IEVENT_TFINT)\n\t\tdev_dbg(&dev->dev, \"ievent: %08x\\n\", ievent);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic struct net_device_stats *mpc52xx_fec_get_stats(struct net_device *dev)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct mpc52xx_fec __iomem *fec = priv->fec;\n\n\tstats->rx_bytes = in_be32(&fec->rmon_r_octets);\n\tstats->rx_packets = in_be32(&fec->rmon_r_packets);\n\tstats->rx_errors = in_be32(&fec->rmon_r_crc_align) +\n\t\tin_be32(&fec->rmon_r_undersize) +\n\t\tin_be32(&fec->rmon_r_oversize) +\n\t\tin_be32(&fec->rmon_r_frag) +\n\t\tin_be32(&fec->rmon_r_jab);\n\n\tstats->tx_bytes = in_be32(&fec->rmon_t_octets);\n\tstats->tx_packets = in_be32(&fec->rmon_t_packets);\n\tstats->tx_errors = in_be32(&fec->rmon_t_crc_align) +\n\t\tin_be32(&fec->rmon_t_undersize) +\n\t\tin_be32(&fec->rmon_t_oversize) +\n\t\tin_be32(&fec->rmon_t_frag) +\n\t\tin_be32(&fec->rmon_t_jab);\n\n\tstats->multicast = in_be32(&fec->rmon_r_mc_pkt);\n\tstats->collisions = in_be32(&fec->rmon_t_col);\n\n\t \n\tstats->rx_length_errors = in_be32(&fec->rmon_r_undersize)\n\t\t\t\t\t+ in_be32(&fec->rmon_r_oversize)\n\t\t\t\t\t+ in_be32(&fec->rmon_r_frag)\n\t\t\t\t\t+ in_be32(&fec->rmon_r_jab);\n\tstats->rx_over_errors = in_be32(&fec->r_macerr);\n\tstats->rx_crc_errors = in_be32(&fec->ieee_r_crc);\n\tstats->rx_frame_errors = in_be32(&fec->ieee_r_align);\n\tstats->rx_fifo_errors = in_be32(&fec->rmon_r_drop);\n\tstats->rx_missed_errors = in_be32(&fec->rmon_r_drop);\n\n\t \n\tstats->tx_aborted_errors = 0;\n\tstats->tx_carrier_errors = in_be32(&fec->ieee_t_cserr);\n\tstats->tx_fifo_errors = in_be32(&fec->rmon_t_drop);\n\tstats->tx_heartbeat_errors = in_be32(&fec->ieee_t_sqe);\n\tstats->tx_window_errors = in_be32(&fec->ieee_t_lcol);\n\n\treturn stats;\n}\n\n \nstatic void mpc52xx_fec_reset_stats(struct net_device *dev)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct mpc52xx_fec __iomem *fec = priv->fec;\n\n\tout_be32(&fec->mib_control, FEC_MIB_DISABLE);\n\tmemset_io(&fec->rmon_t_drop, 0,\n\t\t   offsetof(struct mpc52xx_fec, reserved10) -\n\t\t   offsetof(struct mpc52xx_fec, rmon_t_drop));\n\tout_be32(&fec->mib_control, 0);\n\n\tmemset(&dev->stats, 0, sizeof(dev->stats));\n}\n\n \nstatic void mpc52xx_fec_set_multicast_list(struct net_device *dev)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct mpc52xx_fec __iomem *fec = priv->fec;\n\tu32 rx_control;\n\n\trx_control = in_be32(&fec->r_cntrl);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\trx_control |= FEC_RCNTRL_PROM;\n\t\tout_be32(&fec->r_cntrl, rx_control);\n\t} else {\n\t\trx_control &= ~FEC_RCNTRL_PROM;\n\t\tout_be32(&fec->r_cntrl, rx_control);\n\n\t\tif (dev->flags & IFF_ALLMULTI) {\n\t\t\tout_be32(&fec->gaddr1, 0xffffffff);\n\t\t\tout_be32(&fec->gaddr2, 0xffffffff);\n\t\t} else {\n\t\t\tu32 crc;\n\t\t\tstruct netdev_hw_addr *ha;\n\t\t\tu32 gaddr1 = 0x00000000;\n\t\t\tu32 gaddr2 = 0x00000000;\n\n\t\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t\tcrc = ether_crc_le(6, ha->addr) >> 26;\n\t\t\t\tif (crc >= 32)\n\t\t\t\t\tgaddr1 |= 1 << (crc-32);\n\t\t\t\telse\n\t\t\t\t\tgaddr2 |= 1 << crc;\n\t\t\t}\n\t\t\tout_be32(&fec->gaddr1, gaddr1);\n\t\t\tout_be32(&fec->gaddr2, gaddr2);\n\t\t}\n\t}\n}\n\n \nstatic void mpc52xx_fec_hw_init(struct net_device *dev)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct mpc52xx_fec __iomem *fec = priv->fec;\n\tint i;\n\n\t \n\tout_be32(&fec->ecntrl, FEC_ECNTRL_RESET);\n\tfor (i = 0; i < FEC_RESET_DELAY; ++i) {\n\t\tif ((in_be32(&fec->ecntrl) & FEC_ECNTRL_RESET) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (i == FEC_RESET_DELAY)\n\t\tdev_err(&dev->dev, \"FEC Reset timeout!\\n\");\n\n\t \n\tout_be32(&fec->op_pause, FEC_OP_PAUSE_OPCODE | 0x20);\n\n\t \n\tout_be32(&fec->rfifo_cntrl, FEC_FIFO_CNTRL_FRAME | FEC_FIFO_CNTRL_LTG_7);\n\tout_be32(&fec->tfifo_cntrl, FEC_FIFO_CNTRL_FRAME | FEC_FIFO_CNTRL_LTG_7);\n\n\t \n\tout_be32(&fec->rfifo_alarm, 0x0000030c);\n\tout_be32(&fec->tfifo_alarm, 0x00000100);\n\n\t \n\tout_be32(&fec->x_wmrk, FEC_FIFO_WMRK_256B);\n\n\t \n\tout_be32(&fec->xmit_fsm, FEC_XMIT_FSM_APPEND_CRC | FEC_XMIT_FSM_ENABLE_CRC);\n\tout_be32(&fec->iaddr1, 0x00000000);\t \n\tout_be32(&fec->iaddr2, 0x00000000);\t \n\n\t \n\tout_be32(&fec->mii_speed, priv->mdio_speed);\n}\n\n \nstatic void mpc52xx_fec_start(struct net_device *dev)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct mpc52xx_fec __iomem *fec = priv->fec;\n\tu32 rcntrl;\n\tu32 tcntrl;\n\tu32 tmp;\n\n\t \n\ttmp = FEC_FIFO_STATUS_ERR | FEC_FIFO_STATUS_UF | FEC_FIFO_STATUS_OF;\n\tout_be32(&fec->rfifo_status, in_be32(&fec->rfifo_status) & tmp);\n\tout_be32(&fec->tfifo_status, in_be32(&fec->tfifo_status) & tmp);\n\n\t \n\tout_be32(&fec->reset_cntrl, FEC_RESET_CNTRL_ENABLE_IS_RESET);\n\n\t \n\tmpc52xx_fec_set_paddr(dev, dev->dev_addr);\n\n\tmpc52xx_fec_set_multicast_list(dev);\n\n\t \n\trcntrl = FEC_RX_BUFFER_SIZE << 16;\t \n\trcntrl |= FEC_RCNTRL_FCE;\n\n\tif (!priv->seven_wire_mode)\n\t\trcntrl |= FEC_RCNTRL_MII_MODE;\n\n\tif (priv->duplex == DUPLEX_FULL)\n\t\ttcntrl = FEC_TCNTRL_FDEN;\t \n\telse {\n\t\trcntrl |= FEC_RCNTRL_DRT;\t \n\t\ttcntrl = 0;\n\t}\n\tout_be32(&fec->r_cntrl, rcntrl);\n\tout_be32(&fec->x_cntrl, tcntrl);\n\n\t \n\tout_be32(&fec->ievent, 0xffffffff);\n\n\t \n\tout_be32(&fec->imask, FEC_IMASK_ENABLE);\n\n\t \n\tout_be32(&fec->ecntrl, FEC_ECNTRL_ETHER_EN);\n\tout_be32(&fec->r_des_active, 0x01000000);\n}\n\n \nstatic void mpc52xx_fec_stop(struct net_device *dev, bool may_sleep)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct mpc52xx_fec __iomem *fec = priv->fec;\n\tunsigned long timeout;\n\n\t \n\tout_be32(&fec->imask, 0);\n\n\t \n\tbcom_disable(priv->rx_dmatsk);\n\n\t \n\tif (may_sleep) {\n\t\ttimeout = jiffies + msecs_to_jiffies(2000);\n\t\twhile (time_before(jiffies, timeout) &&\n\t\t\t\t!bcom_queue_empty(priv->tx_dmatsk))\n\t\t\tmsleep(100);\n\n\t\tif (time_after_eq(jiffies, timeout))\n\t\t\tdev_err(&dev->dev, \"queues didn't drain\\n\");\n#if 1\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tdev_err(&dev->dev, \"  tx: index: %i, outdex: %i\\n\",\n\t\t\t\t\tpriv->tx_dmatsk->index,\n\t\t\t\t\tpriv->tx_dmatsk->outdex);\n\t\t\tdev_err(&dev->dev, \"  rx: index: %i, outdex: %i\\n\",\n\t\t\t\t\tpriv->rx_dmatsk->index,\n\t\t\t\t\tpriv->rx_dmatsk->outdex);\n\t\t}\n#endif\n\t}\n\n\tbcom_disable(priv->tx_dmatsk);\n\n\t \n\tout_be32(&fec->ecntrl, in_be32(&fec->ecntrl) & ~FEC_ECNTRL_ETHER_EN);\n}\n\n \nstatic void mpc52xx_fec_reset(struct net_device *dev)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tstruct mpc52xx_fec __iomem *fec = priv->fec;\n\n\tmpc52xx_fec_stop(dev, false);\n\n\tout_be32(&fec->rfifo_status, in_be32(&fec->rfifo_status));\n\tout_be32(&fec->reset_cntrl, FEC_RESET_CNTRL_RESET_FIFO);\n\n\tmpc52xx_fec_free_rx_buffers(dev, priv->rx_dmatsk);\n\n\tmpc52xx_fec_hw_init(dev);\n\n\tbcom_fec_rx_reset(priv->rx_dmatsk);\n\tbcom_fec_tx_reset(priv->tx_dmatsk);\n\n\tmpc52xx_fec_alloc_rx_buffers(dev, priv->rx_dmatsk);\n\n\tbcom_enable(priv->rx_dmatsk);\n\tbcom_enable(priv->tx_dmatsk);\n\n\tmpc52xx_fec_start(dev);\n\n\tnetif_wake_queue(dev);\n}\n\n\n \n\nstatic u32 mpc52xx_fec_get_msglevel(struct net_device *dev)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\treturn priv->msg_enable;\n}\n\nstatic void mpc52xx_fec_set_msglevel(struct net_device *dev, u32 level)\n{\n\tstruct mpc52xx_fec_priv *priv = netdev_priv(dev);\n\tpriv->msg_enable = level;\n}\n\nstatic const struct ethtool_ops mpc52xx_fec_ethtool_ops = {\n\t.get_link = ethtool_op_get_link,\n\t.get_msglevel = mpc52xx_fec_get_msglevel,\n\t.set_msglevel = mpc52xx_fec_set_msglevel,\n\t.get_ts_info = ethtool_op_get_ts_info,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n};\n\n\nstatic const struct net_device_ops mpc52xx_fec_netdev_ops = {\n\t.ndo_open = mpc52xx_fec_open,\n\t.ndo_stop = mpc52xx_fec_close,\n\t.ndo_start_xmit = mpc52xx_fec_start_xmit,\n\t.ndo_set_rx_mode = mpc52xx_fec_set_multicast_list,\n\t.ndo_set_mac_address = mpc52xx_fec_set_mac_address,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_eth_ioctl = phy_do_ioctl,\n\t.ndo_tx_timeout = mpc52xx_fec_tx_timeout,\n\t.ndo_get_stats = mpc52xx_fec_get_stats,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller = mpc52xx_fec_poll_controller,\n#endif\n};\n\n \n \n \n\nstatic int mpc52xx_fec_probe(struct platform_device *op)\n{\n\tint rv;\n\tstruct net_device *ndev;\n\tstruct mpc52xx_fec_priv *priv = NULL;\n\tstruct resource mem;\n\tconst u32 *prop;\n\tint prop_size;\n\tstruct device_node *np = op->dev.of_node;\n\n\tphys_addr_t rx_fifo;\n\tphys_addr_t tx_fifo;\n\n\t \n\tndev = alloc_etherdev(sizeof(struct mpc52xx_fec_priv));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tpriv = netdev_priv(ndev);\n\tpriv->ndev = ndev;\n\n\t \n\trv = of_address_to_resource(np, 0, &mem);\n\tif (rv) {\n\t\tpr_err(\"Error while parsing device node resource\\n\");\n\t\tgoto err_netdev;\n\t}\n\tif (resource_size(&mem) < sizeof(struct mpc52xx_fec)) {\n\t\tpr_err(\"invalid resource size (%lx < %x), check mpc52xx_devices.c\\n\",\n\t\t       (unsigned long)resource_size(&mem),\n\t\t       sizeof(struct mpc52xx_fec));\n\t\trv = -EINVAL;\n\t\tgoto err_netdev;\n\t}\n\n\tif (!request_mem_region(mem.start, sizeof(struct mpc52xx_fec),\n\t\t\t\tDRIVER_NAME)) {\n\t\trv = -EBUSY;\n\t\tgoto err_netdev;\n\t}\n\n\t \n\tndev->netdev_ops\t= &mpc52xx_fec_netdev_ops;\n\tndev->ethtool_ops\t= &mpc52xx_fec_ethtool_ops;\n\tndev->watchdog_timeo\t= FEC_WATCHDOG_TIMEOUT;\n\tndev->base_addr\t\t= mem.start;\n\tSET_NETDEV_DEV(ndev, &op->dev);\n\n\tspin_lock_init(&priv->lock);\n\n\t \n\tpriv->fec = ioremap(mem.start, sizeof(struct mpc52xx_fec));\n\n\tif (!priv->fec) {\n\t\trv = -ENOMEM;\n\t\tgoto err_mem_region;\n\t}\n\n\t \n\trx_fifo = ndev->base_addr + offsetof(struct mpc52xx_fec, rfifo_data);\n\ttx_fifo = ndev->base_addr + offsetof(struct mpc52xx_fec, tfifo_data);\n\n\tpriv->rx_dmatsk = bcom_fec_rx_init(FEC_RX_NUM_BD, rx_fifo, FEC_RX_BUFFER_SIZE);\n\tpriv->tx_dmatsk = bcom_fec_tx_init(FEC_TX_NUM_BD, tx_fifo);\n\n\tif (!priv->rx_dmatsk || !priv->tx_dmatsk) {\n\t\tpr_err(\"Can not init SDMA tasks\\n\");\n\t\trv = -ENOMEM;\n\t\tgoto err_rx_tx_dmatsk;\n\t}\n\n\t \n\t\t \n\tndev->irq = irq_of_parse_and_map(np, 0);\n\n\t\t \n\tpriv->r_irq = bcom_get_task_irq(priv->rx_dmatsk);\n\n\t\t \n\tpriv->t_irq = bcom_get_task_irq(priv->tx_dmatsk);\n\n\t \n\trv = of_get_ethdev_address(np, ndev);\n\tif (rv) {\n\t\tstruct mpc52xx_fec __iomem *fec = priv->fec;\n\t\tu8 addr[ETH_ALEN] __aligned(4);\n\n\t\t \n\t\t*(u32 *)(&addr[0]) = in_be32(&fec->paddr1);\n\t\t*(u16 *)(&addr[4]) = in_be32(&fec->paddr2) >> 16;\n\t\teth_hw_addr_set(ndev, addr);\n\t}\n\n\t \n\tif (!is_valid_ether_addr(ndev->dev_addr)) {\n\t\teth_hw_addr_random(ndev);\n\t\tdev_warn(&ndev->dev, \"using random MAC address %pM\\n\",\n\t\t\t ndev->dev_addr);\n\t}\n\n\tpriv->msg_enable = netif_msg_init(debug, MPC52xx_MESSAGES_DEFAULT);\n\n\t \n\n\t \n\tpriv->speed = 100;\n\tpriv->duplex = DUPLEX_HALF;\n\tpriv->mdio_speed = ((mpc5xxx_get_bus_frequency(&op->dev) >> 20) / 5) << 1;\n\n\t \n\tprop = of_get_property(np, \"current-speed\", &prop_size);\n\tif (prop && (prop_size >= sizeof(u32) * 2)) {\n\t\tpriv->speed = prop[0];\n\t\tpriv->duplex = prop[1] ? DUPLEX_FULL : DUPLEX_HALF;\n\t}\n\n\t \n\tpriv->phy_node = of_parse_phandle(np, \"phy-handle\", 0);\n\n\t \n\tif (of_property_read_bool(np, \"fsl,7-wire-mode\")) {\n\t\tpriv->seven_wire_mode = 1;\n\t\tdev_info(&ndev->dev, \"using 7-wire PHY mode\\n\");\n\t}\n\n\t \n\tmpc52xx_fec_hw_init(ndev);\n\tmpc52xx_fec_reset_stats(ndev);\n\n\trv = register_netdev(ndev);\n\tif (rv < 0)\n\t\tgoto err_node;\n\n\t \n\tplatform_set_drvdata(op, ndev);\n\tnetdev_info(ndev, \"%pOF MAC %pM\\n\",\n\t\t    op->dev.of_node, ndev->dev_addr);\n\n\treturn 0;\n\nerr_node:\n\tof_node_put(priv->phy_node);\n\tirq_dispose_mapping(ndev->irq);\nerr_rx_tx_dmatsk:\n\tif (priv->rx_dmatsk)\n\t\tbcom_fec_rx_release(priv->rx_dmatsk);\n\tif (priv->tx_dmatsk)\n\t\tbcom_fec_tx_release(priv->tx_dmatsk);\n\tiounmap(priv->fec);\nerr_mem_region:\n\trelease_mem_region(mem.start, sizeof(struct mpc52xx_fec));\nerr_netdev:\n\tfree_netdev(ndev);\n\n\treturn rv;\n}\n\nstatic void\nmpc52xx_fec_remove(struct platform_device *op)\n{\n\tstruct net_device *ndev;\n\tstruct mpc52xx_fec_priv *priv;\n\n\tndev = platform_get_drvdata(op);\n\tpriv = netdev_priv(ndev);\n\n\tunregister_netdev(ndev);\n\n\tof_node_put(priv->phy_node);\n\tpriv->phy_node = NULL;\n\n\tirq_dispose_mapping(ndev->irq);\n\n\tbcom_fec_rx_release(priv->rx_dmatsk);\n\tbcom_fec_tx_release(priv->tx_dmatsk);\n\n\tiounmap(priv->fec);\n\n\trelease_mem_region(ndev->base_addr, sizeof(struct mpc52xx_fec));\n\n\tfree_netdev(ndev);\n}\n\n#ifdef CONFIG_PM\nstatic int mpc52xx_fec_of_suspend(struct platform_device *op, pm_message_t state)\n{\n\tstruct net_device *dev = platform_get_drvdata(op);\n\n\tif (netif_running(dev))\n\t\tmpc52xx_fec_close(dev);\n\n\treturn 0;\n}\n\nstatic int mpc52xx_fec_of_resume(struct platform_device *op)\n{\n\tstruct net_device *dev = platform_get_drvdata(op);\n\n\tmpc52xx_fec_hw_init(dev);\n\tmpc52xx_fec_reset_stats(dev);\n\n\tif (netif_running(dev))\n\t\tmpc52xx_fec_open(dev);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct of_device_id mpc52xx_fec_match[] = {\n\t{ .compatible = \"fsl,mpc5200b-fec\", },\n\t{ .compatible = \"fsl,mpc5200-fec\", },\n\t{ .compatible = \"mpc5200-fec\", },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, mpc52xx_fec_match);\n\nstatic struct platform_driver mpc52xx_fec_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = mpc52xx_fec_match,\n\t},\n\t.probe\t\t= mpc52xx_fec_probe,\n\t.remove_new\t= mpc52xx_fec_remove,\n#ifdef CONFIG_PM\n\t.suspend\t= mpc52xx_fec_of_suspend,\n\t.resume\t\t= mpc52xx_fec_of_resume,\n#endif\n};\n\n\n \n \n \n\nstatic struct platform_driver * const drivers[] = {\n#ifdef CONFIG_FEC_MPC52xx_MDIO\n\t&mpc52xx_fec_mdio_driver,\n#endif\n\t&mpc52xx_fec_driver,\n};\n\nstatic int __init\nmpc52xx_fec_init(void)\n{\n\treturn platform_register_drivers(drivers, ARRAY_SIZE(drivers));\n}\n\nstatic void __exit\nmpc52xx_fec_exit(void)\n{\n\tplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\n}\n\n\nmodule_init(mpc52xx_fec_init);\nmodule_exit(mpc52xx_fec_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Dale Farnsworth\");\nMODULE_DESCRIPTION(\"Ethernet driver for the Freescale MPC52xx FEC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}