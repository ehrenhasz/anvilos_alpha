{
  "module_name": "fsl_pq_mdio.c",
  "hash_id": "293b7e6bd4527b6d3fed7aec62b5b6718a4780c9cae2c13521c9a7ff34ec50ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/fsl_pq_mdio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/of_address.h>\n#include <linux/of_mdio.h>\n#include <linux/of_device.h>\n\n#include <asm/io.h>\n#if IS_ENABLED(CONFIG_UCC_GETH)\n#include <soc/fsl/qe/ucc.h>\n#endif\n\n#include \"gianfar.h\"\n\n#define MIIMIND_BUSY\t\t0x00000001\n#define MIIMIND_NOTVALID\t0x00000004\n#define MIIMCFG_INIT_VALUE\t0x00000007\n#define MIIMCFG_RESET\t\t0x80000000\n\n#define MII_READ_COMMAND\t0x00000001\n\nstruct fsl_pq_mii {\n\tu32 miimcfg;\t \n\tu32 miimcom;\t \n\tu32 miimadd;\t \n\tu32 miimcon;\t \n\tu32 miimstat;\t \n\tu32 miimind;\t \n};\n\nstruct fsl_pq_mdio {\n\tu8 res1[16];\n\tu32 ieventm;\t \n\tu32 imaskm;\t \n\tu8 res2[4];\n\tu32 emapm;\t \n\tu8 res3[1280];\n\tstruct fsl_pq_mii mii;\n\tu8 res4[28];\n\tu32 utbipar;\t \n\tu8 res5[2728];\n} __packed;\n\n \n#define MII_TIMEOUT\t1000\n\nstruct fsl_pq_mdio_priv {\n\tvoid __iomem *map;\n\tstruct fsl_pq_mii __iomem *regs;\n};\n\n \nstruct fsl_pq_mdio_data {\n\tunsigned int mii_offset;\t \n\tuint32_t __iomem * (*get_tbipa)(void __iomem *p);\n\tvoid (*ucc_configure)(phys_addr_t start, phys_addr_t end);\n};\n\n \nstatic int fsl_pq_mdio_write(struct mii_bus *bus, int mii_id, int regnum,\n\t\tu16 value)\n{\n\tstruct fsl_pq_mdio_priv *priv = bus->priv;\n\tstruct fsl_pq_mii __iomem *regs = priv->regs;\n\tunsigned int timeout;\n\n\t \n\tiowrite32be((mii_id << 8) | regnum, &regs->miimadd);\n\n\t \n\tiowrite32be(value, &regs->miimcon);\n\n\t \n\ttimeout = MII_TIMEOUT;\n\twhile ((ioread32be(&regs->miimind) & MIIMIND_BUSY) && timeout) {\n\t\tcpu_relax();\n\t\ttimeout--;\n\t}\n\n\treturn timeout ? 0 : -ETIMEDOUT;\n}\n\n \nstatic int fsl_pq_mdio_read(struct mii_bus *bus, int mii_id, int regnum)\n{\n\tstruct fsl_pq_mdio_priv *priv = bus->priv;\n\tstruct fsl_pq_mii __iomem *regs = priv->regs;\n\tunsigned int timeout;\n\tu16 value;\n\n\t \n\tiowrite32be((mii_id << 8) | regnum, &regs->miimadd);\n\n\t \n\tiowrite32be(0, &regs->miimcom);\n\tiowrite32be(MII_READ_COMMAND, &regs->miimcom);\n\n\t \n\ttimeout = MII_TIMEOUT;\n\twhile ((ioread32be(&regs->miimind) &\n\t       (MIIMIND_NOTVALID | MIIMIND_BUSY)) && timeout) {\n\t\tcpu_relax();\n\t\ttimeout--;\n\t}\n\n\tif (!timeout)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tvalue = ioread32be(&regs->miimstat);\n\n\tdev_dbg(&bus->dev, \"read %04x from address %x/%x\\n\", value, mii_id, regnum);\n\treturn value;\n}\n\n \nstatic int fsl_pq_mdio_reset(struct mii_bus *bus)\n{\n\tstruct fsl_pq_mdio_priv *priv = bus->priv;\n\tstruct fsl_pq_mii __iomem *regs = priv->regs;\n\tunsigned int timeout;\n\n\tmutex_lock(&bus->mdio_lock);\n\n\t \n\tiowrite32be(MIIMCFG_RESET, &regs->miimcfg);\n\n\t \n\tiowrite32be(MIIMCFG_INIT_VALUE, &regs->miimcfg);\n\n\t \n\ttimeout = MII_TIMEOUT;\n\twhile ((ioread32be(&regs->miimind) & MIIMIND_BUSY) && timeout) {\n\t\tcpu_relax();\n\t\ttimeout--;\n\t}\n\n\tmutex_unlock(&bus->mdio_lock);\n\n\tif (!timeout) {\n\t\tdev_err(&bus->dev, \"timeout waiting for MII bus\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_GIANFAR)\n \nstatic uint32_t __iomem *get_gfar_tbipa_from_mdio(void __iomem *p)\n{\n\tstruct gfar __iomem *enet_regs = p;\n\n\treturn &enet_regs->tbipa;\n}\n\n \nstatic uint32_t __iomem *get_gfar_tbipa_from_mii(void __iomem *p)\n{\n\treturn get_gfar_tbipa_from_mdio(container_of(p, struct gfar, gfar_mii_regs));\n}\n\n \nstatic uint32_t __iomem *get_etsec_tbipa(void __iomem *p)\n{\n\treturn p;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_UCC_GETH)\n \nstatic uint32_t __iomem *get_ucc_tbipa(void __iomem *p)\n{\n\tstruct fsl_pq_mdio __iomem *mdio = container_of(p, struct fsl_pq_mdio, mii);\n\n\treturn &mdio->utbipar;\n}\n\n \nstatic void ucc_configure(phys_addr_t start, phys_addr_t end)\n{\n\tstatic bool found_mii_master;\n\tstruct device_node *np = NULL;\n\n\tif (found_mii_master)\n\t\treturn;\n\n\tfor_each_compatible_node(np, NULL, \"ucc_geth\") {\n\t\tstruct resource res;\n\t\tconst uint32_t *iprop;\n\t\tuint32_t id;\n\t\tint ret;\n\n\t\tret = of_address_to_resource(np, 0, &res);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"fsl-pq-mdio: no address range in node %pOF\\n\",\n\t\t\t\t np);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif ((start < res.start) || (end > res.end))\n\t\t\tcontinue;\n\n\t\tiprop = of_get_property(np, \"cell-index\", NULL);\n\t\tif (!iprop) {\n\t\t\tiprop = of_get_property(np, \"device-id\", NULL);\n\t\t\tif (!iprop) {\n\t\t\t\tpr_debug(\"fsl-pq-mdio: no UCC ID in node %pOF\\n\",\n\t\t\t\t\t np);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tid = be32_to_cpup(iprop);\n\n\t\t \n\t\tif (ucc_set_qe_mux_mii_mng(id - 1) < 0) {\n\t\t\tpr_debug(\"fsl-pq-mdio: invalid UCC ID in node %pOF\\n\",\n\t\t\t\t np);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_debug(\"fsl-pq-mdio: setting node UCC%u to MII master\\n\", id);\n\t\tfound_mii_master = true;\n\t}\n}\n\n#endif\n\nstatic const struct of_device_id fsl_pq_mdio_match[] = {\n#if IS_ENABLED(CONFIG_GIANFAR)\n\t{\n\t\t.compatible = \"fsl,gianfar-tbi\",\n\t\t.data = &(struct fsl_pq_mdio_data) {\n\t\t\t.mii_offset = 0,\n\t\t\t.get_tbipa = get_gfar_tbipa_from_mii,\n\t\t},\n\t},\n\t{\n\t\t.compatible = \"fsl,gianfar-mdio\",\n\t\t.data = &(struct fsl_pq_mdio_data) {\n\t\t\t.mii_offset = 0,\n\t\t\t.get_tbipa = get_gfar_tbipa_from_mii,\n\t\t},\n\t},\n\t{\n\t\t.type = \"mdio\",\n\t\t.compatible = \"gianfar\",\n\t\t.data = &(struct fsl_pq_mdio_data) {\n\t\t\t.mii_offset = offsetof(struct fsl_pq_mdio, mii),\n\t\t\t.get_tbipa = get_gfar_tbipa_from_mdio,\n\t\t},\n\t},\n\t{\n\t\t.compatible = \"fsl,etsec2-tbi\",\n\t\t.data = &(struct fsl_pq_mdio_data) {\n\t\t\t.mii_offset = offsetof(struct fsl_pq_mdio, mii),\n\t\t\t.get_tbipa = get_etsec_tbipa,\n\t\t},\n\t},\n\t{\n\t\t.compatible = \"fsl,etsec2-mdio\",\n\t\t.data = &(struct fsl_pq_mdio_data) {\n\t\t\t.mii_offset = offsetof(struct fsl_pq_mdio, mii),\n\t\t\t.get_tbipa = get_etsec_tbipa,\n\t\t},\n\t},\n#endif\n#if IS_ENABLED(CONFIG_UCC_GETH)\n\t{\n\t\t.compatible = \"fsl,ucc-mdio\",\n\t\t.data = &(struct fsl_pq_mdio_data) {\n\t\t\t.mii_offset = 0,\n\t\t\t.get_tbipa = get_ucc_tbipa,\n\t\t\t.ucc_configure = ucc_configure,\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.type = \"mdio\",\n\t\t.compatible = \"ucc_geth_phy\",\n\t\t.data = &(struct fsl_pq_mdio_data) {\n\t\t\t.mii_offset = 0,\n\t\t\t.get_tbipa = get_ucc_tbipa,\n\t\t\t.ucc_configure = ucc_configure,\n\t\t},\n\t},\n#endif\n\t \n\t{\n\t\t.compatible = \"fsl,fman-mdio\",\n\t\t.data = &(struct fsl_pq_mdio_data) {\n\t\t\t.mii_offset = 0,\n\t\t\t \n\t\t},\n\t},\n\n\t{},\n};\nMODULE_DEVICE_TABLE(of, fsl_pq_mdio_match);\n\nstatic void set_tbipa(const u32 tbipa_val, struct platform_device *pdev,\n\t\t      uint32_t __iomem * (*get_tbipa)(void __iomem *),\n\t\t      void __iomem *reg_map, struct resource *reg_res)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tuint32_t __iomem *tbipa;\n\tbool tbipa_mapped;\n\n\ttbipa = of_iomap(np, 1);\n\tif (tbipa) {\n\t\ttbipa_mapped = true;\n\t} else {\n\t\ttbipa_mapped = false;\n\t\ttbipa = (*get_tbipa)(reg_map);\n\n\t\t \n\t\tif ((void *)tbipa > reg_map + resource_size(reg_res) - 4)\n\t\t\tdev_err(&pdev->dev, \"invalid register map (should be at least 0x%04zx to contain TBI address)\\n\",\n\t\t\t\t((void *)tbipa - reg_map) + 4);\n\t}\n\n\tiowrite32be(be32_to_cpu(tbipa_val), tbipa);\n\n\tif (tbipa_mapped)\n\t\tiounmap(tbipa);\n}\n\nstatic int fsl_pq_mdio_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *id =\n\t\tof_match_device(fsl_pq_mdio_match, &pdev->dev);\n\tconst struct fsl_pq_mdio_data *data;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct resource res;\n\tstruct device_node *tbi;\n\tstruct fsl_pq_mdio_priv *priv;\n\tstruct mii_bus *new_bus;\n\tint err;\n\n\tif (!id) {\n\t\tdev_err(&pdev->dev, \"Failed to match device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdata = id->data;\n\n\tdev_dbg(&pdev->dev, \"found %s compatible node\\n\", id->compatible);\n\n\tnew_bus = mdiobus_alloc_size(sizeof(*priv));\n\tif (!new_bus)\n\t\treturn -ENOMEM;\n\n\tpriv = new_bus->priv;\n\tnew_bus->name = \"Freescale PowerQUICC MII Bus\";\n\tnew_bus->read = &fsl_pq_mdio_read;\n\tnew_bus->write = &fsl_pq_mdio_write;\n\tnew_bus->reset = &fsl_pq_mdio_reset;\n\n\terr = of_address_to_resource(np, 0, &res);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"could not obtain address information\\n\");\n\t\tgoto error;\n\t}\n\n\tsnprintf(new_bus->id, MII_BUS_ID_SIZE, \"%pOFn@%llx\", np,\n\t\t (unsigned long long)res.start);\n\n\tpriv->map = of_iomap(np, 0);\n\tif (!priv->map) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tif (data->mii_offset > resource_size(&res)) {\n\t\tdev_err(&pdev->dev, \"invalid register map\\n\");\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\tpriv->regs = priv->map + data->mii_offset;\n\n\tnew_bus->parent = &pdev->dev;\n\tplatform_set_drvdata(pdev, new_bus);\n\n\tif (data->get_tbipa) {\n\t\tfor_each_child_of_node(np, tbi) {\n\t\t\tif (of_node_is_type(tbi, \"tbi-phy\")) {\n\t\t\t\tdev_dbg(&pdev->dev, \"found TBI PHY node %pOFP\\n\",\n\t\t\t\t\ttbi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (tbi) {\n\t\t\tconst u32 *prop = of_get_property(tbi, \"reg\", NULL);\n\t\t\tif (!prop) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"missing 'reg' property in node %pOF\\n\",\n\t\t\t\t\ttbi);\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tset_tbipa(*prop, pdev,\n\t\t\t\t  data->get_tbipa, priv->map, &res);\n\t\t}\n\t}\n\n\tif (data->ucc_configure)\n\t\tdata->ucc_configure(res.start, res.end);\n\n\terr = of_mdiobus_register(new_bus, np);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot register %s as MDIO bus\\n\",\n\t\t\tnew_bus->name);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (priv->map)\n\t\tiounmap(priv->map);\n\n\tkfree(new_bus);\n\n\treturn err;\n}\n\n\nstatic void fsl_pq_mdio_remove(struct platform_device *pdev)\n{\n\tstruct device *device = &pdev->dev;\n\tstruct mii_bus *bus = dev_get_drvdata(device);\n\tstruct fsl_pq_mdio_priv *priv = bus->priv;\n\n\tmdiobus_unregister(bus);\n\n\tiounmap(priv->map);\n\tmdiobus_free(bus);\n}\n\nstatic struct platform_driver fsl_pq_mdio_driver = {\n\t.driver = {\n\t\t.name = \"fsl-pq_mdio\",\n\t\t.of_match_table = fsl_pq_mdio_match,\n\t},\n\t.probe = fsl_pq_mdio_probe,\n\t.remove_new = fsl_pq_mdio_remove,\n};\n\nmodule_platform_driver(fsl_pq_mdio_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}