{
  "module_name": "dpsw.h",
  "hash_id": "823a7712aab9af830c86ec24dcd2df57a464457b9de5c90e3ca4b66e7798e149",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/dpaa2/dpsw.h",
  "human_readable_source": " \n \n\n#ifndef __FSL_DPSW_H\n#define __FSL_DPSW_H\n\n \n\nstruct fsl_mc_io;\n\n \n\n#define DPSW_MAX_PRIORITIES\t8\n\n#define DPSW_MAX_IF\t\t64\n\nint dpsw_open(struct fsl_mc_io *mc_io, u32 cmd_flags, int dpsw_id, u16 *token);\n\nint dpsw_close(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token);\n\n \n\n \n#define DPSW_OPT_FLOODING_DIS\t\t0x0000000000000001ULL\n \n#define DPSW_OPT_MULTICAST_DIS\t\t0x0000000000000004ULL\n \n#define DPSW_OPT_CTRL_IF_DIS\t\t0x0000000000000010ULL\n\n \nenum dpsw_component_type {\n\tDPSW_COMPONENT_TYPE_C_VLAN = 0,\n\tDPSW_COMPONENT_TYPE_S_VLAN\n};\n\n \nenum dpsw_flooding_cfg {\n\tDPSW_FLOODING_PER_VLAN = 0,\n\tDPSW_FLOODING_PER_FDB,\n};\n\n \nenum dpsw_broadcast_cfg {\n\tDPSW_BROADCAST_PER_OBJECT = 0,\n\tDPSW_BROADCAST_PER_FDB,\n};\n\nint dpsw_enable(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token);\n\nint dpsw_disable(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token);\n\nint dpsw_reset(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token);\n\n \n\n#define DPSW_IRQ_INDEX_IF\t\t0x0000\n#define DPSW_IRQ_INDEX_L2SW\t\t0x0001\n\n \n#define DPSW_IRQ_EVENT_LINK_CHANGED\t0x0001\n\n \n#define DPSW_IRQ_EVENT_ENDPOINT_CHANGED\t0x0002\n\n \nstruct dpsw_irq_cfg {\n\tu64 addr;\n\tu32 val;\n\tint irq_num;\n};\n\nint dpsw_set_irq_enable(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\tu8 irq_index, u8 en);\n\nint dpsw_set_irq_mask(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t      u8 irq_index, u32 mask);\n\nint dpsw_get_irq_status(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\tu8 irq_index, u32 *status);\n\nint dpsw_clear_irq_status(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t  u8 irq_index, u32 status);\n\n \nstruct dpsw_attr {\n\tint id;\n\tu64 options;\n\tu16 max_vlans;\n\tu8 max_meters_per_if;\n\tu8 max_fdbs;\n\tu16 max_fdb_entries;\n\tu16 fdb_aging_time;\n\tu16 max_fdb_mc_groups;\n\tu16 num_ifs;\n\tu16 mem_size;\n\tu16 num_vlans;\n\tu8 num_fdbs;\n\tenum dpsw_component_type component_type;\n\tenum dpsw_flooding_cfg flooding_cfg;\n\tenum dpsw_broadcast_cfg broadcast_cfg;\n};\n\nint dpsw_get_attributes(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\tstruct dpsw_attr *attr);\n\n \nstruct dpsw_ctrl_if_attr {\n\tu32 rx_fqid;\n\tu32 rx_err_fqid;\n\tu32 tx_err_conf_fqid;\n};\n\nint dpsw_ctrl_if_get_attributes(struct fsl_mc_io *mc_io, u32 cmd_flags,\n\t\t\t\tu16 token, struct dpsw_ctrl_if_attr *attr);\n\nenum dpsw_queue_type {\n\tDPSW_QUEUE_RX,\n\tDPSW_QUEUE_TX_ERR_CONF,\n\tDPSW_QUEUE_RX_ERR,\n};\n\n#define DPSW_MAX_DPBP     8\n\n \nstruct dpsw_ctrl_if_pools_cfg {\n\tu8 num_dpbp;\n\tstruct {\n\t\tint dpbp_id;\n\t\tu16 buffer_size;\n\t\tint backup_pool;\n\t} pools[DPSW_MAX_DPBP];\n};\n\nint dpsw_ctrl_if_set_pools(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t   const struct dpsw_ctrl_if_pools_cfg *cfg);\n\n#define DPSW_CTRL_IF_QUEUE_OPT_USER_CTX\t\t0x00000001\n#define DPSW_CTRL_IF_QUEUE_OPT_DEST\t\t0x00000002\n\nenum dpsw_ctrl_if_dest {\n\tDPSW_CTRL_IF_DEST_NONE = 0,\n\tDPSW_CTRL_IF_DEST_DPIO = 1,\n};\n\nstruct dpsw_ctrl_if_dest_cfg {\n\tenum dpsw_ctrl_if_dest dest_type;\n\tint dest_id;\n\tu8 priority;\n};\n\nstruct dpsw_ctrl_if_queue_cfg {\n\tu32 options;\n\tu64 user_ctx;\n\tstruct dpsw_ctrl_if_dest_cfg dest_cfg;\n};\n\nint dpsw_ctrl_if_set_queue(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t   enum dpsw_queue_type qtype,\n\t\t\t   const struct dpsw_ctrl_if_queue_cfg *cfg);\n\nint dpsw_ctrl_if_enable(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token);\n\nint dpsw_ctrl_if_disable(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token);\n\n \nenum dpsw_action {\n\tDPSW_ACTION_DROP = 0,\n\tDPSW_ACTION_REDIRECT = 1\n};\n\n#define DPSW_LINK_OPT_AUTONEG\t\t0x0000000000000001ULL\n#define DPSW_LINK_OPT_HALF_DUPLEX\t0x0000000000000002ULL\n#define DPSW_LINK_OPT_PAUSE\t\t0x0000000000000004ULL\n#define DPSW_LINK_OPT_ASYM_PAUSE\t0x0000000000000008ULL\n\n \nstruct dpsw_link_cfg {\n\tu32 rate;\n\tu64 options;\n};\n\nint dpsw_if_set_link_cfg(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token, u16 if_id,\n\t\t\t struct dpsw_link_cfg *cfg);\n\n \nstruct dpsw_link_state {\n\tu32 rate;\n\tu64 options;\n\tu8 up;\n};\n\nint dpsw_if_get_link_state(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t   u16 if_id, struct dpsw_link_state *state);\n\n \nstruct dpsw_tci_cfg {\n\tu8 pcp;\n\tu8 dei;\n\tu16 vlan_id;\n};\n\nint dpsw_if_set_tci(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token, u16 if_id,\n\t\t    const struct dpsw_tci_cfg *cfg);\n\nint dpsw_if_get_tci(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token, u16 if_id,\n\t\t    struct dpsw_tci_cfg *cfg);\n\n \nenum dpsw_stp_state {\n\tDPSW_STP_STATE_DISABLED = 0,\n\tDPSW_STP_STATE_LISTENING = 1,\n\tDPSW_STP_STATE_LEARNING = 2,\n\tDPSW_STP_STATE_FORWARDING = 3,\n\tDPSW_STP_STATE_BLOCKING = 0\n};\n\n \nstruct dpsw_stp_cfg {\n\tu16 vlan_id;\n\tenum dpsw_stp_state state;\n};\n\nint dpsw_if_set_stp(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token, u16 if_id,\n\t\t    const struct dpsw_stp_cfg *cfg);\n\n \nenum dpsw_accepted_frames {\n\tDPSW_ADMIT_ALL = 1,\n\tDPSW_ADMIT_ONLY_VLAN_TAGGED = 3\n};\n\n \nenum dpsw_counter {\n\tDPSW_CNT_ING_FRAME = 0x0,\n\tDPSW_CNT_ING_BYTE = 0x1,\n\tDPSW_CNT_ING_FLTR_FRAME = 0x2,\n\tDPSW_CNT_ING_FRAME_DISCARD = 0x3,\n\tDPSW_CNT_ING_MCAST_FRAME = 0x4,\n\tDPSW_CNT_ING_MCAST_BYTE = 0x5,\n\tDPSW_CNT_ING_BCAST_FRAME = 0x6,\n\tDPSW_CNT_ING_BCAST_BYTES = 0x7,\n\tDPSW_CNT_EGR_FRAME = 0x8,\n\tDPSW_CNT_EGR_BYTE = 0x9,\n\tDPSW_CNT_EGR_FRAME_DISCARD = 0xa,\n\tDPSW_CNT_EGR_STP_FRAME_DISCARD = 0xb,\n\tDPSW_CNT_ING_NO_BUFF_DISCARD = 0xc,\n};\n\nint dpsw_if_get_counter(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\tu16 if_id, enum dpsw_counter type, u64 *counter);\n\nint dpsw_if_enable(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token, u16 if_id);\n\nint dpsw_if_disable(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token, u16 if_id);\n\n \nstruct dpsw_if_attr {\n\tu8 num_tcs;\n\tu32 rate;\n\tu32 options;\n\tint enabled;\n\tint accept_all_vlan;\n\tenum dpsw_accepted_frames admit_untagged;\n\tu16 qdid;\n};\n\nint dpsw_if_get_attributes(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t   u16 if_id, struct dpsw_if_attr *attr);\n\nint dpsw_if_set_max_frame_length(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t\t u16 if_id, u16 frame_length);\n\n \nstruct dpsw_vlan_cfg {\n\tu16 fdb_id;\n};\n\nint dpsw_vlan_add(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t  u16 vlan_id, const struct dpsw_vlan_cfg *cfg);\n\n#define DPSW_VLAN_ADD_IF_OPT_FDB_ID            0x0001\n\n \nstruct dpsw_vlan_if_cfg {\n\tu16 num_ifs;\n\tu16 options;\n\tu16 if_id[DPSW_MAX_IF];\n\tu16 fdb_id;\n};\n\nint dpsw_vlan_add_if(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t     u16 vlan_id, const struct dpsw_vlan_if_cfg *cfg);\n\nint dpsw_vlan_add_if_untagged(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t      u16 vlan_id, const struct dpsw_vlan_if_cfg *cfg);\n\nint dpsw_vlan_remove_if(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\tu16 vlan_id, const struct dpsw_vlan_if_cfg *cfg);\n\nint dpsw_vlan_remove_if_untagged(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t\t u16 vlan_id, const struct dpsw_vlan_if_cfg *cfg);\n\nint dpsw_vlan_remove(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t     u16 vlan_id);\n\n \nenum dpsw_fdb_entry_type {\n\tDPSW_FDB_ENTRY_STATIC = 0,\n\tDPSW_FDB_ENTRY_DINAMIC = 1\n};\n\n \nstruct dpsw_fdb_unicast_cfg {\n\tenum dpsw_fdb_entry_type type;\n\tu8 mac_addr[6];\n\tu16 if_egress;\n};\n\nint dpsw_fdb_add_unicast(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t u16 fdb_id, const struct dpsw_fdb_unicast_cfg *cfg);\n\nint dpsw_fdb_remove_unicast(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t    u16 fdb_id, const struct dpsw_fdb_unicast_cfg *cfg);\n\n#define DPSW_FDB_ENTRY_TYPE_DYNAMIC  BIT(0)\n#define DPSW_FDB_ENTRY_TYPE_UNICAST  BIT(1)\n\n \nstruct fdb_dump_entry {\n\tu8 mac_addr[6];\n\tu8 type;\n\tu8 if_info;\n\tu8 if_mask[8];\n};\n\nint dpsw_fdb_dump(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token, u16 fdb_id,\n\t\t  u64 iova_addr, u32 iova_size, u16 *num_entries);\n\n \nstruct dpsw_fdb_multicast_cfg {\n\tenum dpsw_fdb_entry_type type;\n\tu8 mac_addr[6];\n\tu16 num_ifs;\n\tu16 if_id[DPSW_MAX_IF];\n};\n\nint dpsw_fdb_add_multicast(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t   u16 fdb_id, const struct dpsw_fdb_multicast_cfg *cfg);\n\nint dpsw_fdb_remove_multicast(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t      u16 fdb_id, const struct dpsw_fdb_multicast_cfg *cfg);\n\n \nenum dpsw_learning_mode {\n\tDPSW_LEARNING_MODE_DIS = 0,\n\tDPSW_LEARNING_MODE_HW = 1,\n\tDPSW_LEARNING_MODE_NON_SECURE = 2,\n\tDPSW_LEARNING_MODE_SECURE = 3\n};\n\n \nstruct dpsw_fdb_attr {\n\tu16 max_fdb_entries;\n\tu16 fdb_ageing_time;\n\tenum dpsw_learning_mode learning_mode;\n\tu16 num_fdb_mc_groups;\n\tu16 max_fdb_mc_groups;\n};\n\nint dpsw_get_api_version(struct fsl_mc_io *mc_io, u32 cmd_flags,\n\t\t\t u16 *major_ver, u16 *minor_ver);\n\nint dpsw_if_get_port_mac_addr(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t      u16 if_id, u8 mac_addr[6]);\n\n \nstruct dpsw_fdb_cfg {\n\tu16 num_fdb_entries;\n\tu16 fdb_ageing_time;\n};\n\nint dpsw_fdb_add(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token, u16 *fdb_id,\n\t\t const struct dpsw_fdb_cfg *cfg);\n\nint dpsw_fdb_remove(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token, u16 fdb_id);\n\n \nenum dpsw_flood_type {\n\tDPSW_BROADCAST = 0,\n\tDPSW_FLOODING,\n};\n\nstruct dpsw_egress_flood_cfg {\n\tu16 fdb_id;\n\tenum dpsw_flood_type flood_type;\n\tu16 num_ifs;\n\tu16 if_id[DPSW_MAX_IF];\n};\n\nint dpsw_set_egress_flood(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t  const struct dpsw_egress_flood_cfg *cfg);\n\nint dpsw_if_set_learning_mode(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t      u16 if_id, enum dpsw_learning_mode mode);\n\n \nstruct dpsw_acl_cfg {\n\tu16 max_entries;\n};\n\nint dpsw_acl_add(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token, u16 *acl_id,\n\t\t const struct dpsw_acl_cfg *cfg);\n\nint dpsw_acl_remove(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t    u16 acl_id);\n\n \nstruct dpsw_acl_if_cfg {\n\tu16 num_ifs;\n\tu16 if_id[DPSW_MAX_IF];\n};\n\nint dpsw_acl_add_if(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t    u16 acl_id, const struct dpsw_acl_if_cfg *cfg);\n\nint dpsw_acl_remove_if(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t       u16 acl_id, const struct dpsw_acl_if_cfg *cfg);\n\n \nstruct dpsw_acl_fields {\n\tu8 l2_dest_mac[6];\n\tu8 l2_source_mac[6];\n\tu16 l2_tpid;\n\tu8 l2_pcp_dei;\n\tu16 l2_vlan_id;\n\tu16 l2_ether_type;\n\tu8 l3_dscp;\n\tu8 l3_protocol;\n\tu32 l3_source_ip;\n\tu32 l3_dest_ip;\n\tu16 l4_source_port;\n\tu16 l4_dest_port;\n};\n\n \nstruct dpsw_acl_key {\n\tstruct dpsw_acl_fields match;\n\tstruct dpsw_acl_fields mask;\n};\n\n \nenum dpsw_acl_action {\n\tDPSW_ACL_ACTION_DROP,\n\tDPSW_ACL_ACTION_REDIRECT,\n\tDPSW_ACL_ACTION_ACCEPT,\n\tDPSW_ACL_ACTION_REDIRECT_TO_CTRL_IF\n};\n\n \nstruct dpsw_acl_result {\n\tenum dpsw_acl_action action;\n\tu16 if_id;\n};\n\n \nstruct dpsw_acl_entry_cfg {\n\tu64 key_iova;\n\tstruct dpsw_acl_result result;\n\tint precedence;\n};\n\nvoid dpsw_acl_prepare_entry_cfg(const struct dpsw_acl_key *key,\n\t\t\t\tu8 *entry_cfg_buf);\n\nint dpsw_acl_add_entry(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t       u16 acl_id, const struct dpsw_acl_entry_cfg *cfg);\n\nint dpsw_acl_remove_entry(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t  u16 acl_id, const struct dpsw_acl_entry_cfg *cfg);\n\n \nenum dpsw_reflection_filter {\n\tDPSW_REFLECTION_FILTER_INGRESS_ALL = 0,\n\tDPSW_REFLECTION_FILTER_INGRESS_VLAN = 1\n};\n\n \nstruct dpsw_reflection_cfg {\n\tenum dpsw_reflection_filter filter;\n\tu16 vlan_id;\n};\n\nint dpsw_set_reflection_if(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t   u16 if_id);\n\nint dpsw_if_add_reflection(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t   u16 if_id, const struct dpsw_reflection_cfg *cfg);\n\nint dpsw_if_remove_reflection(struct fsl_mc_io *mc_io, u32 cmd_flags, u16 token,\n\t\t\t      u16 if_id, const struct dpsw_reflection_cfg *cfg);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}