{
  "module_name": "dpaa2-mac.c",
  "hash_id": "a58811b259cc702cddbcb25a6329509f00eabf5a76845fc19a72c30f0f9fa453",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/dpaa2/dpaa2-mac.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/pcs-lynx.h>\n#include <linux/phy/phy.h>\n#include <linux/property.h>\n\n#include \"dpaa2-eth.h\"\n#include \"dpaa2-mac.h\"\n\n#define phylink_to_dpaa2_mac(config) \\\n\tcontainer_of((config), struct dpaa2_mac, phylink_config)\n\n#define DPMAC_PROTOCOL_CHANGE_VER_MAJOR\t\t4\n#define DPMAC_PROTOCOL_CHANGE_VER_MINOR\t\t8\n\n#define DPAA2_MAC_FEATURE_PROTOCOL_CHANGE\tBIT(0)\n\nstatic int dpaa2_mac_cmp_ver(struct dpaa2_mac *mac,\n\t\t\t     u16 ver_major, u16 ver_minor)\n{\n\tif (mac->ver_major == ver_major)\n\t\treturn mac->ver_minor - ver_minor;\n\treturn mac->ver_major - ver_major;\n}\n\nstatic void dpaa2_mac_detect_features(struct dpaa2_mac *mac)\n{\n\tmac->features = 0;\n\n\tif (dpaa2_mac_cmp_ver(mac, DPMAC_PROTOCOL_CHANGE_VER_MAJOR,\n\t\t\t      DPMAC_PROTOCOL_CHANGE_VER_MINOR) >= 0)\n\t\tmac->features |= DPAA2_MAC_FEATURE_PROTOCOL_CHANGE;\n}\n\nstatic int phy_mode(enum dpmac_eth_if eth_if, phy_interface_t *if_mode)\n{\n\t*if_mode = PHY_INTERFACE_MODE_NA;\n\n\tswitch (eth_if) {\n\tcase DPMAC_ETH_IF_RGMII:\n\t\t*if_mode = PHY_INTERFACE_MODE_RGMII;\n\t\tbreak;\n\tcase DPMAC_ETH_IF_USXGMII:\n\t\t*if_mode = PHY_INTERFACE_MODE_USXGMII;\n\t\tbreak;\n\tcase DPMAC_ETH_IF_QSGMII:\n\t\t*if_mode = PHY_INTERFACE_MODE_QSGMII;\n\t\tbreak;\n\tcase DPMAC_ETH_IF_SGMII:\n\t\t*if_mode = PHY_INTERFACE_MODE_SGMII;\n\t\tbreak;\n\tcase DPMAC_ETH_IF_XFI:\n\t\t*if_mode = PHY_INTERFACE_MODE_10GBASER;\n\t\tbreak;\n\tcase DPMAC_ETH_IF_CAUI:\n\t\t*if_mode = PHY_INTERFACE_MODE_25GBASER;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic enum dpmac_eth_if dpmac_eth_if_mode(phy_interface_t if_mode)\n{\n\tswitch (if_mode) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\treturn DPMAC_ETH_IF_RGMII;\n\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\treturn DPMAC_ETH_IF_USXGMII;\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\t\treturn DPMAC_ETH_IF_QSGMII;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\treturn DPMAC_ETH_IF_SGMII;\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\treturn DPMAC_ETH_IF_XFI;\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\treturn DPMAC_ETH_IF_1000BASEX;\n\tcase PHY_INTERFACE_MODE_25GBASER:\n\t\treturn DPMAC_ETH_IF_CAUI;\n\tdefault:\n\t\treturn DPMAC_ETH_IF_MII;\n\t}\n}\n\nstatic struct fwnode_handle *dpaa2_mac_get_node(struct device *dev,\n\t\t\t\t\t\tu16 dpmac_id)\n{\n\tstruct fwnode_handle *fwnode, *parent = NULL, *child  = NULL;\n\tstruct device_node *dpmacs = NULL;\n\tint err;\n\tu32 id;\n\n\tfwnode = dev_fwnode(dev->parent);\n\tif (is_of_node(fwnode)) {\n\t\tdpmacs = of_find_node_by_name(NULL, \"dpmacs\");\n\t\tif (!dpmacs)\n\t\t\treturn NULL;\n\t\tparent = of_fwnode_handle(dpmacs);\n\t} else if (is_acpi_node(fwnode)) {\n\t\tparent = fwnode;\n\t} else {\n\t\t \n\t\tdev_dbg(dev, \"dprc not finished probing\\n\");\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tfwnode_for_each_child_node(parent, child) {\n\t\terr = -EINVAL;\n\t\tif (is_acpi_device_node(child))\n\t\t\terr = acpi_get_local_address(ACPI_HANDLE_FWNODE(child), &id);\n\t\telse if (is_of_node(child))\n\t\t\terr = of_property_read_u32(to_of_node(child), \"reg\", &id);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\tif (id == dpmac_id) {\n\t\t\tof_node_put(dpmacs);\n\t\t\treturn child;\n\t\t}\n\t}\n\tof_node_put(dpmacs);\n\treturn NULL;\n}\n\nstatic int dpaa2_mac_get_if_mode(struct fwnode_handle *dpmac_node,\n\t\t\t\t struct dpmac_attr attr)\n{\n\tphy_interface_t if_mode;\n\tint err;\n\n\terr = fwnode_get_phy_mode(dpmac_node);\n\tif (err > 0)\n\t\treturn err;\n\n\terr = phy_mode(attr.eth_if, &if_mode);\n\tif (!err)\n\t\treturn if_mode;\n\n\treturn err;\n}\n\nstatic struct phylink_pcs *dpaa2_mac_select_pcs(struct phylink_config *config,\n\t\t\t\t\t\tphy_interface_t interface)\n{\n\tstruct dpaa2_mac *mac = phylink_to_dpaa2_mac(config);\n\n\treturn mac->pcs;\n}\n\nstatic void dpaa2_mac_config(struct phylink_config *config, unsigned int mode,\n\t\t\t     const struct phylink_link_state *state)\n{\n\tstruct dpaa2_mac *mac = phylink_to_dpaa2_mac(config);\n\tstruct dpmac_link_state *dpmac_state = &mac->state;\n\tint err;\n\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t      state->advertising))\n\t\tdpmac_state->options |= DPMAC_LINK_OPT_AUTONEG;\n\telse\n\t\tdpmac_state->options &= ~DPMAC_LINK_OPT_AUTONEG;\n\n\terr = dpmac_set_link_state(mac->mc_io, 0,\n\t\t\t\t   mac->mc_dev->mc_handle, dpmac_state);\n\tif (err)\n\t\tnetdev_err(mac->net_dev, \"%s: dpmac_set_link_state() = %d\\n\",\n\t\t\t   __func__, err);\n\n\tif (!mac->serdes_phy)\n\t\treturn;\n\n\t \n\terr = dpmac_set_protocol(mac->mc_io, 0, mac->mc_dev->mc_handle,\n\t\t\t\t dpmac_eth_if_mode(state->interface));\n\tif (err)\n\t\tnetdev_err(mac->net_dev,  \"dpmac_set_protocol() = %d\\n\", err);\n\n\terr = phy_set_mode_ext(mac->serdes_phy, PHY_MODE_ETHERNET, state->interface);\n\tif (err)\n\t\tnetdev_err(mac->net_dev, \"phy_set_mode_ext() = %d\\n\", err);\n}\n\nstatic void dpaa2_mac_link_up(struct phylink_config *config,\n\t\t\t      struct phy_device *phy,\n\t\t\t      unsigned int mode, phy_interface_t interface,\n\t\t\t      int speed, int duplex,\n\t\t\t      bool tx_pause, bool rx_pause)\n{\n\tstruct dpaa2_mac *mac = phylink_to_dpaa2_mac(config);\n\tstruct dpmac_link_state *dpmac_state = &mac->state;\n\tint err;\n\n\tdpmac_state->up = 1;\n\n\tdpmac_state->rate = speed;\n\n\tif (duplex == DUPLEX_HALF)\n\t\tdpmac_state->options |= DPMAC_LINK_OPT_HALF_DUPLEX;\n\telse if (duplex == DUPLEX_FULL)\n\t\tdpmac_state->options &= ~DPMAC_LINK_OPT_HALF_DUPLEX;\n\n\tif (rx_pause)\n\t\tdpmac_state->options |= DPMAC_LINK_OPT_PAUSE;\n\telse\n\t\tdpmac_state->options &= ~DPMAC_LINK_OPT_PAUSE;\n\n\tif (rx_pause ^ tx_pause)\n\t\tdpmac_state->options |= DPMAC_LINK_OPT_ASYM_PAUSE;\n\telse\n\t\tdpmac_state->options &= ~DPMAC_LINK_OPT_ASYM_PAUSE;\n\n\terr = dpmac_set_link_state(mac->mc_io, 0,\n\t\t\t\t   mac->mc_dev->mc_handle, dpmac_state);\n\tif (err)\n\t\tnetdev_err(mac->net_dev, \"%s: dpmac_set_link_state() = %d\\n\",\n\t\t\t   __func__, err);\n}\n\nstatic void dpaa2_mac_link_down(struct phylink_config *config,\n\t\t\t\tunsigned int mode,\n\t\t\t\tphy_interface_t interface)\n{\n\tstruct dpaa2_mac *mac = phylink_to_dpaa2_mac(config);\n\tstruct dpmac_link_state *dpmac_state = &mac->state;\n\tint err;\n\n\tdpmac_state->up = 0;\n\terr = dpmac_set_link_state(mac->mc_io, 0,\n\t\t\t\t   mac->mc_dev->mc_handle, dpmac_state);\n\tif (err)\n\t\tnetdev_err(mac->net_dev, \"dpmac_set_link_state() = %d\\n\", err);\n}\n\nstatic const struct phylink_mac_ops dpaa2_mac_phylink_ops = {\n\t.mac_select_pcs = dpaa2_mac_select_pcs,\n\t.mac_config = dpaa2_mac_config,\n\t.mac_link_up = dpaa2_mac_link_up,\n\t.mac_link_down = dpaa2_mac_link_down,\n};\n\nstatic int dpaa2_pcs_create(struct dpaa2_mac *mac,\n\t\t\t    struct fwnode_handle *dpmac_node,\n\t\t\t    int id)\n{\n\tstruct fwnode_handle *node;\n\tstruct phylink_pcs *pcs;\n\n\tnode = fwnode_find_reference(dpmac_node, \"pcs-handle\", 0);\n\tif (IS_ERR(node)) {\n\t\t \n\t\tnetdev_warn(mac->net_dev, \"pcs-handle node not found\\n\");\n\t\treturn 0;\n\t}\n\n\tpcs = lynx_pcs_create_fwnode(node);\n\tfwnode_handle_put(node);\n\n\tif (pcs == ERR_PTR(-EPROBE_DEFER)) {\n\t\tnetdev_dbg(mac->net_dev, \"missing PCS device\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tif (pcs == ERR_PTR(-ENODEV)) {\n\t\tnetdev_err(mac->net_dev, \"pcs-handle node not available\\n\");\n\t\treturn PTR_ERR(pcs);\n\t}\n\n\tif (IS_ERR(pcs)) {\n\t\tnetdev_err(mac->net_dev,\n\t\t\t   \"lynx_pcs_create_fwnode() failed: %pe\\n\", pcs);\n\t\treturn PTR_ERR(pcs);\n\t}\n\n\tmac->pcs = pcs;\n\n\treturn 0;\n}\n\nstatic void dpaa2_pcs_destroy(struct dpaa2_mac *mac)\n{\n\tstruct phylink_pcs *phylink_pcs = mac->pcs;\n\n\tif (phylink_pcs) {\n\t\tlynx_pcs_destroy(phylink_pcs);\n\t\tmac->pcs = NULL;\n\t}\n}\n\nstatic void dpaa2_mac_set_supported_interfaces(struct dpaa2_mac *mac)\n{\n\tint intf, err;\n\n\t \n\t__set_bit(mac->if_mode, mac->phylink_config.supported_interfaces);\n\tif (mac->pcs) {\n\t\tswitch (mac->if_mode) {\n\t\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\tcase PHY_INTERFACE_MODE_SGMII:\n\t\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX,\n\t\t\t\t  mac->phylink_config.supported_interfaces);\n\t\t\t__set_bit(PHY_INTERFACE_MODE_SGMII,\n\t\t\t\t  mac->phylink_config.supported_interfaces);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!mac->serdes_phy)\n\t\treturn;\n\n\t \n\tfor (intf = 0; intf < PHY_INTERFACE_MODE_MAX; intf++) {\n\t\tif (intf == PHY_INTERFACE_MODE_NA)\n\t\t\tcontinue;\n\n\t\terr = phy_validate(mac->serdes_phy, PHY_MODE_ETHERNET, intf, NULL);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\t__set_bit(intf, mac->phylink_config.supported_interfaces);\n\t}\n}\n\nvoid dpaa2_mac_start(struct dpaa2_mac *mac)\n{\n\tASSERT_RTNL();\n\n\tif (mac->serdes_phy)\n\t\tphy_power_on(mac->serdes_phy);\n\n\tphylink_start(mac->phylink);\n}\n\nvoid dpaa2_mac_stop(struct dpaa2_mac *mac)\n{\n\tASSERT_RTNL();\n\n\tphylink_stop(mac->phylink);\n\n\tif (mac->serdes_phy)\n\t\tphy_power_off(mac->serdes_phy);\n}\n\nint dpaa2_mac_connect(struct dpaa2_mac *mac)\n{\n\tstruct net_device *net_dev = mac->net_dev;\n\tstruct fwnode_handle *dpmac_node;\n\tstruct phy *serdes_phy = NULL;\n\tstruct phylink *phylink;\n\tint err;\n\n\tmac->if_link_type = mac->attr.link_type;\n\n\tdpmac_node = mac->fw_node;\n\tif (!dpmac_node) {\n\t\tnetdev_err(net_dev, \"No dpmac@%d node found.\\n\", mac->attr.id);\n\t\treturn -ENODEV;\n\t}\n\n\terr = dpaa2_mac_get_if_mode(dpmac_node, mac->attr);\n\tif (err < 0)\n\t\treturn -EINVAL;\n\tmac->if_mode = err;\n\n\tif (mac->features & DPAA2_MAC_FEATURE_PROTOCOL_CHANGE &&\n\t    !phy_interface_mode_is_rgmii(mac->if_mode) &&\n\t    is_of_node(dpmac_node)) {\n\t\tserdes_phy = of_phy_get(to_of_node(dpmac_node), NULL);\n\n\t\tif (serdes_phy == ERR_PTR(-ENODEV))\n\t\t\tserdes_phy = NULL;\n\t\telse if (IS_ERR(serdes_phy))\n\t\t\treturn PTR_ERR(serdes_phy);\n\t\telse\n\t\t\tphy_init(serdes_phy);\n\t}\n\tmac->serdes_phy = serdes_phy;\n\n\t \n\tif (of_phy_is_fixed_link(to_of_node(dpmac_node)) &&\n\t    (mac->if_mode == PHY_INTERFACE_MODE_RGMII_ID ||\n\t     mac->if_mode == PHY_INTERFACE_MODE_RGMII_RXID ||\n\t     mac->if_mode == PHY_INTERFACE_MODE_RGMII_TXID)) {\n\t\tnetdev_err(net_dev, \"RGMII delay not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((mac->attr.link_type == DPMAC_LINK_TYPE_PHY &&\n\t     mac->attr.eth_if != DPMAC_ETH_IF_RGMII) ||\n\t    mac->attr.link_type == DPMAC_LINK_TYPE_BACKPLANE) {\n\t\terr = dpaa2_pcs_create(mac, dpmac_node, mac->attr.id);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemset(&mac->phylink_config, 0, sizeof(mac->phylink_config));\n\tmac->phylink_config.dev = &net_dev->dev;\n\tmac->phylink_config.type = PHYLINK_NETDEV;\n\n\tmac->phylink_config.mac_capabilities = MAC_SYM_PAUSE | MAC_ASYM_PAUSE |\n\t\tMAC_10FD | MAC_100FD | MAC_1000FD | MAC_2500FD | MAC_5000FD |\n\t\tMAC_10000FD | MAC_25000FD;\n\n\tdpaa2_mac_set_supported_interfaces(mac);\n\n\tphylink = phylink_create(&mac->phylink_config,\n\t\t\t\t dpmac_node, mac->if_mode,\n\t\t\t\t &dpaa2_mac_phylink_ops);\n\tif (IS_ERR(phylink)) {\n\t\terr = PTR_ERR(phylink);\n\t\tgoto err_pcs_destroy;\n\t}\n\tmac->phylink = phylink;\n\n\trtnl_lock();\n\terr = phylink_fwnode_phy_connect(mac->phylink, dpmac_node, 0);\n\trtnl_unlock();\n\tif (err) {\n\t\tnetdev_err(net_dev, \"phylink_fwnode_phy_connect() = %d\\n\", err);\n\t\tgoto err_phylink_destroy;\n\t}\n\n\treturn 0;\n\nerr_phylink_destroy:\n\tphylink_destroy(mac->phylink);\nerr_pcs_destroy:\n\tdpaa2_pcs_destroy(mac);\n\n\treturn err;\n}\n\nvoid dpaa2_mac_disconnect(struct dpaa2_mac *mac)\n{\n\trtnl_lock();\n\tphylink_disconnect_phy(mac->phylink);\n\trtnl_unlock();\n\n\tphylink_destroy(mac->phylink);\n\tdpaa2_pcs_destroy(mac);\n\tof_phy_put(mac->serdes_phy);\n\tmac->serdes_phy = NULL;\n}\n\nint dpaa2_mac_open(struct dpaa2_mac *mac)\n{\n\tstruct fsl_mc_device *dpmac_dev = mac->mc_dev;\n\tstruct net_device *net_dev = mac->net_dev;\n\tstruct fwnode_handle *fw_node;\n\tint err;\n\n\terr = dpmac_open(mac->mc_io, 0, dpmac_dev->obj_desc.id,\n\t\t\t &dpmac_dev->mc_handle);\n\tif (err || !dpmac_dev->mc_handle) {\n\t\tnetdev_err(net_dev, \"dpmac_open() = %d\\n\", err);\n\t\treturn -ENODEV;\n\t}\n\n\terr = dpmac_get_attributes(mac->mc_io, 0, dpmac_dev->mc_handle,\n\t\t\t\t   &mac->attr);\n\tif (err) {\n\t\tnetdev_err(net_dev, \"dpmac_get_attributes() = %d\\n\", err);\n\t\tgoto err_close_dpmac;\n\t}\n\n\terr = dpmac_get_api_version(mac->mc_io, 0, &mac->ver_major, &mac->ver_minor);\n\tif (err) {\n\t\tnetdev_err(net_dev, \"dpmac_get_api_version() = %d\\n\", err);\n\t\tgoto err_close_dpmac;\n\t}\n\n\tdpaa2_mac_detect_features(mac);\n\n\t \n\tfw_node = dpaa2_mac_get_node(&mac->mc_dev->dev, mac->attr.id);\n\tif (IS_ERR(fw_node)) {\n\t\terr = PTR_ERR(fw_node);\n\t\tgoto err_close_dpmac;\n\t}\n\n\tmac->fw_node = fw_node;\n\tnet_dev->dev.of_node = to_of_node(mac->fw_node);\n\n\treturn 0;\n\nerr_close_dpmac:\n\tdpmac_close(mac->mc_io, 0, dpmac_dev->mc_handle);\n\treturn err;\n}\n\nvoid dpaa2_mac_close(struct dpaa2_mac *mac)\n{\n\tstruct fsl_mc_device *dpmac_dev = mac->mc_dev;\n\n\tdpmac_close(mac->mc_io, 0, dpmac_dev->mc_handle);\n\tif (mac->fw_node)\n\t\tfwnode_handle_put(mac->fw_node);\n}\n\nstatic char dpaa2_mac_ethtool_stats[][ETH_GSTRING_LEN] = {\n\t[DPMAC_CNT_ING_ALL_FRAME]\t\t= \"[mac] rx all frames\",\n\t[DPMAC_CNT_ING_GOOD_FRAME]\t\t= \"[mac] rx frames ok\",\n\t[DPMAC_CNT_ING_ERR_FRAME]\t\t= \"[mac] rx frame errors\",\n\t[DPMAC_CNT_ING_FRAME_DISCARD]\t\t= \"[mac] rx frame discards\",\n\t[DPMAC_CNT_ING_UCAST_FRAME]\t\t= \"[mac] rx u-cast\",\n\t[DPMAC_CNT_ING_BCAST_FRAME]\t\t= \"[mac] rx b-cast\",\n\t[DPMAC_CNT_ING_MCAST_FRAME]\t\t= \"[mac] rx m-cast\",\n\t[DPMAC_CNT_ING_FRAME_64]\t\t= \"[mac] rx 64 bytes\",\n\t[DPMAC_CNT_ING_FRAME_127]\t\t= \"[mac] rx 65-127 bytes\",\n\t[DPMAC_CNT_ING_FRAME_255]\t\t= \"[mac] rx 128-255 bytes\",\n\t[DPMAC_CNT_ING_FRAME_511]\t\t= \"[mac] rx 256-511 bytes\",\n\t[DPMAC_CNT_ING_FRAME_1023]\t\t= \"[mac] rx 512-1023 bytes\",\n\t[DPMAC_CNT_ING_FRAME_1518]\t\t= \"[mac] rx 1024-1518 bytes\",\n\t[DPMAC_CNT_ING_FRAME_1519_MAX]\t\t= \"[mac] rx 1519-max bytes\",\n\t[DPMAC_CNT_ING_FRAG]\t\t\t= \"[mac] rx frags\",\n\t[DPMAC_CNT_ING_JABBER]\t\t\t= \"[mac] rx jabber\",\n\t[DPMAC_CNT_ING_ALIGN_ERR]\t\t= \"[mac] rx align errors\",\n\t[DPMAC_CNT_ING_OVERSIZED]\t\t= \"[mac] rx oversized\",\n\t[DPMAC_CNT_ING_VALID_PAUSE_FRAME]\t= \"[mac] rx pause\",\n\t[DPMAC_CNT_ING_BYTE]\t\t\t= \"[mac] rx bytes\",\n\t[DPMAC_CNT_EGR_GOOD_FRAME]\t\t= \"[mac] tx frames ok\",\n\t[DPMAC_CNT_EGR_UCAST_FRAME]\t\t= \"[mac] tx u-cast\",\n\t[DPMAC_CNT_EGR_MCAST_FRAME]\t\t= \"[mac] tx m-cast\",\n\t[DPMAC_CNT_EGR_BCAST_FRAME]\t\t= \"[mac] tx b-cast\",\n\t[DPMAC_CNT_EGR_ERR_FRAME]\t\t= \"[mac] tx frame errors\",\n\t[DPMAC_CNT_EGR_UNDERSIZED]\t\t= \"[mac] tx undersized\",\n\t[DPMAC_CNT_EGR_VALID_PAUSE_FRAME]\t= \"[mac] tx b-pause\",\n\t[DPMAC_CNT_EGR_BYTE]\t\t\t= \"[mac] tx bytes\",\n};\n\n#define DPAA2_MAC_NUM_STATS\tARRAY_SIZE(dpaa2_mac_ethtool_stats)\n\nint dpaa2_mac_get_sset_count(void)\n{\n\treturn DPAA2_MAC_NUM_STATS;\n}\n\nvoid dpaa2_mac_get_strings(u8 *data)\n{\n\tu8 *p = data;\n\tint i;\n\n\tfor (i = 0; i < DPAA2_MAC_NUM_STATS; i++) {\n\t\tstrscpy(p, dpaa2_mac_ethtool_stats[i], ETH_GSTRING_LEN);\n\t\tp += ETH_GSTRING_LEN;\n\t}\n}\n\nvoid dpaa2_mac_get_ethtool_stats(struct dpaa2_mac *mac, u64 *data)\n{\n\tstruct fsl_mc_device *dpmac_dev = mac->mc_dev;\n\tint i, err;\n\tu64 value;\n\n\tfor (i = 0; i < DPAA2_MAC_NUM_STATS; i++) {\n\t\terr = dpmac_get_counter(mac->mc_io, 0, dpmac_dev->mc_handle,\n\t\t\t\t\ti, &value);\n\t\tif (err) {\n\t\t\tnetdev_err_once(mac->net_dev,\n\t\t\t\t\t\"dpmac_get_counter error %d\\n\", err);\n\t\t\t*(data + i) = U64_MAX;\n\t\t\tcontinue;\n\t\t}\n\t\t*(data + i) = value;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}