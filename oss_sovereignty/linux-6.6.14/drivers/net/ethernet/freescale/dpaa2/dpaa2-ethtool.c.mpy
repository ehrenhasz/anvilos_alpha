{
  "module_name": "dpaa2-ethtool.c",
  "hash_id": "18b954fc8d7a5b4f280a036a6d70aa68987eafc2f97f007f338219b7fffe155f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/dpaa2/dpaa2-ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/net_tstamp.h>\n#include <linux/nospec.h>\n\n#include \"dpni.h\"\t \n#include \"dpaa2-eth.h\"\n\n \nstatic char dpaa2_ethtool_stats[][ETH_GSTRING_LEN] = {\n\t\"[hw] rx frames\",\n\t\"[hw] rx bytes\",\n\t\"[hw] rx mcast frames\",\n\t\"[hw] rx mcast bytes\",\n\t\"[hw] rx bcast frames\",\n\t\"[hw] rx bcast bytes\",\n\t\"[hw] tx frames\",\n\t\"[hw] tx bytes\",\n\t\"[hw] tx mcast frames\",\n\t\"[hw] tx mcast bytes\",\n\t\"[hw] tx bcast frames\",\n\t\"[hw] tx bcast bytes\",\n\t\"[hw] rx filtered frames\",\n\t\"[hw] rx discarded frames\",\n\t\"[hw] rx nobuffer discards\",\n\t\"[hw] tx discarded frames\",\n\t\"[hw] tx confirmed frames\",\n\t\"[hw] tx dequeued bytes\",\n\t\"[hw] tx dequeued frames\",\n\t\"[hw] tx rejected bytes\",\n\t\"[hw] tx rejected frames\",\n\t\"[hw] tx pending frames\",\n};\n\n#define DPAA2_ETH_NUM_STATS\tARRAY_SIZE(dpaa2_ethtool_stats)\n\nstatic char dpaa2_ethtool_extras[][ETH_GSTRING_LEN] = {\n\t \n\t\"[drv] tx conf frames\",\n\t\"[drv] tx conf bytes\",\n\t\"[drv] tx sg frames\",\n\t\"[drv] tx sg bytes\",\n\t\"[drv] tx tso frames\",\n\t\"[drv] tx tso bytes\",\n\t\"[drv] rx sg frames\",\n\t\"[drv] rx sg bytes\",\n\t\"[drv] tx converted sg frames\",\n\t\"[drv] tx converted sg bytes\",\n\t\"[drv] enqueue portal busy\",\n\t \n\t\"[drv] dequeue portal busy\",\n\t\"[drv] channel pull errors\",\n\t\"[drv] cdan\",\n\t\"[drv] xdp drop\",\n\t\"[drv] xdp tx\",\n\t\"[drv] xdp tx errors\",\n\t\"[drv] xdp redirect\",\n\t \n\t\"[qbman] rx pending frames\",\n\t\"[qbman] rx pending bytes\",\n\t\"[qbman] tx conf pending frames\",\n\t\"[qbman] tx conf pending bytes\",\n\t\"[qbman] buffer count\",\n};\n\n#define DPAA2_ETH_NUM_EXTRA_STATS\tARRAY_SIZE(dpaa2_ethtool_extras)\n\nstatic void dpaa2_eth_get_drvinfo(struct net_device *net_dev,\n\t\t\t\t  struct ethtool_drvinfo *drvinfo)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\n\tstrscpy(drvinfo->driver, KBUILD_MODNAME, sizeof(drvinfo->driver));\n\n\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t \"%u.%u\", priv->dpni_ver_major, priv->dpni_ver_minor);\n\n\tstrscpy(drvinfo->bus_info, dev_name(net_dev->dev.parent->parent),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic int dpaa2_eth_nway_reset(struct net_device *net_dev)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\tint err = -EOPNOTSUPP;\n\n\tmutex_lock(&priv->mac_lock);\n\n\tif (dpaa2_eth_is_type_phy(priv))\n\t\terr = phylink_ethtool_nway_reset(priv->mac->phylink);\n\n\tmutex_unlock(&priv->mac_lock);\n\n\treturn err;\n}\n\nstatic int\ndpaa2_eth_get_link_ksettings(struct net_device *net_dev,\n\t\t\t     struct ethtool_link_ksettings *link_settings)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\tint err;\n\n\tmutex_lock(&priv->mac_lock);\n\n\tif (dpaa2_eth_is_type_phy(priv)) {\n\t\terr = phylink_ethtool_ksettings_get(priv->mac->phylink,\n\t\t\t\t\t\t    link_settings);\n\t\tmutex_unlock(&priv->mac_lock);\n\t\treturn err;\n\t}\n\n\tmutex_unlock(&priv->mac_lock);\n\n\tlink_settings->base.autoneg = AUTONEG_DISABLE;\n\tif (!(priv->link_state.options & DPNI_LINK_OPT_HALF_DUPLEX))\n\t\tlink_settings->base.duplex = DUPLEX_FULL;\n\tlink_settings->base.speed = priv->link_state.rate;\n\n\treturn 0;\n}\n\nstatic int\ndpaa2_eth_set_link_ksettings(struct net_device *net_dev,\n\t\t\t     const struct ethtool_link_ksettings *link_settings)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\tint err = -EOPNOTSUPP;\n\n\tmutex_lock(&priv->mac_lock);\n\n\tif (dpaa2_eth_is_type_phy(priv))\n\t\terr = phylink_ethtool_ksettings_set(priv->mac->phylink,\n\t\t\t\t\t\t    link_settings);\n\n\tmutex_unlock(&priv->mac_lock);\n\n\treturn err;\n}\n\nstatic void dpaa2_eth_get_pauseparam(struct net_device *net_dev,\n\t\t\t\t     struct ethtool_pauseparam *pause)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\tu64 link_options = priv->link_state.options;\n\n\tmutex_lock(&priv->mac_lock);\n\n\tif (dpaa2_eth_is_type_phy(priv)) {\n\t\tphylink_ethtool_get_pauseparam(priv->mac->phylink, pause);\n\t\tmutex_unlock(&priv->mac_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&priv->mac_lock);\n\n\tpause->rx_pause = dpaa2_eth_rx_pause_enabled(link_options);\n\tpause->tx_pause = dpaa2_eth_tx_pause_enabled(link_options);\n\tpause->autoneg = AUTONEG_DISABLE;\n}\n\nstatic int dpaa2_eth_set_pauseparam(struct net_device *net_dev,\n\t\t\t\t    struct ethtool_pauseparam *pause)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\tstruct dpni_link_cfg cfg = {0};\n\tint err;\n\n\tif (!dpaa2_eth_has_pause_support(priv)) {\n\t\tnetdev_info(net_dev, \"No pause frame support for DPNI version < %d.%d\\n\",\n\t\t\t    DPNI_PAUSE_VER_MAJOR, DPNI_PAUSE_VER_MINOR);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&priv->mac_lock);\n\n\tif (dpaa2_eth_is_type_phy(priv)) {\n\t\terr = phylink_ethtool_set_pauseparam(priv->mac->phylink,\n\t\t\t\t\t\t     pause);\n\t\tmutex_unlock(&priv->mac_lock);\n\t\treturn err;\n\t}\n\n\tmutex_unlock(&priv->mac_lock);\n\n\tif (pause->autoneg)\n\t\treturn -EOPNOTSUPP;\n\n\tcfg.rate = priv->link_state.rate;\n\tcfg.options = priv->link_state.options;\n\tif (pause->rx_pause)\n\t\tcfg.options |= DPNI_LINK_OPT_PAUSE;\n\telse\n\t\tcfg.options &= ~DPNI_LINK_OPT_PAUSE;\n\tif (!!pause->rx_pause ^ !!pause->tx_pause)\n\t\tcfg.options |= DPNI_LINK_OPT_ASYM_PAUSE;\n\telse\n\t\tcfg.options &= ~DPNI_LINK_OPT_ASYM_PAUSE;\n\n\tif (cfg.options == priv->link_state.options)\n\t\treturn 0;\n\n\terr = dpni_set_link_cfg(priv->mc_io, 0, priv->mc_token, &cfg);\n\tif (err) {\n\t\tnetdev_err(net_dev, \"dpni_set_link_state failed\\n\");\n\t\treturn err;\n\t}\n\n\tpriv->link_state.options = cfg.options;\n\n\treturn 0;\n}\n\nstatic void dpaa2_eth_get_strings(struct net_device *netdev, u32 stringset,\n\t\t\t\t  u8 *data)\n{\n\tu8 *p = data;\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < DPAA2_ETH_NUM_STATS; i++) {\n\t\t\tstrscpy(p, dpaa2_ethtool_stats[i], ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tfor (i = 0; i < DPAA2_ETH_NUM_EXTRA_STATS; i++) {\n\t\t\tstrscpy(p, dpaa2_ethtool_extras[i], ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tdpaa2_mac_get_strings(p);\n\t\tbreak;\n\t}\n}\n\nstatic int dpaa2_eth_get_sset_count(struct net_device *net_dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:  \n\t\treturn DPAA2_ETH_NUM_STATS + DPAA2_ETH_NUM_EXTRA_STATS +\n\t\t       dpaa2_mac_get_sset_count();\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic void dpaa2_eth_get_ethtool_stats(struct net_device *net_dev,\n\t\t\t\t\tstruct ethtool_stats *stats,\n\t\t\t\t\tu64 *data)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\tunion dpni_statistics dpni_stats;\n\tint dpni_stats_page_size[DPNI_STATISTICS_CNT] = {\n\t\tsizeof(dpni_stats.page_0),\n\t\tsizeof(dpni_stats.page_1),\n\t\tsizeof(dpni_stats.page_2),\n\t\tsizeof(dpni_stats.page_3),\n\t\tsizeof(dpni_stats.page_4),\n\t\tsizeof(dpni_stats.page_5),\n\t\tsizeof(dpni_stats.page_6),\n\t};\n\tu32 fcnt_rx_total = 0, fcnt_tx_total = 0;\n\tu32 bcnt_rx_total = 0, bcnt_tx_total = 0;\n\tstruct dpaa2_eth_ch_stats *ch_stats;\n\tstruct dpaa2_eth_drv_stats *extras;\n\tu32 buf_cnt, buf_cnt_total = 0;\n\tint j, k, err, num_cnt, i = 0;\n\tu32 fcnt, bcnt;\n\n\tmemset(data, 0,\n\t       sizeof(u64) * (DPAA2_ETH_NUM_STATS + DPAA2_ETH_NUM_EXTRA_STATS));\n\n\t \n\tfor (j = 0; j <= 6; j++) {\n\t\t \n\t\tif (j == 4 || j == 5)\n\t\t\tcontinue;\n\t\terr = dpni_get_statistics(priv->mc_io, 0, priv->mc_token,\n\t\t\t\t\t  j, &dpni_stats);\n\t\tif (err == -EINVAL)\n\t\t\t \n\t\t\tmemset(&dpni_stats, 0, sizeof(dpni_stats));\n\t\telse if (err)\n\t\t\tnetdev_warn(net_dev, \"dpni_get_stats(%d) failed\\n\", j);\n\n\t\tnum_cnt = dpni_stats_page_size[j] / sizeof(u64);\n\t\tfor (k = 0; k < num_cnt; k++)\n\t\t\t*(data + i++) = dpni_stats.raw.counter[k];\n\t}\n\n\t \n\tfor_each_online_cpu(k) {\n\t\textras = per_cpu_ptr(priv->percpu_extras, k);\n\t\tfor (j = 0; j < sizeof(*extras) / sizeof(__u64); j++)\n\t\t\t*((__u64 *)data + i + j) += *((__u64 *)extras + j);\n\t}\n\ti += j;\n\n\t \n\tfor (k = 0; k < priv->num_channels; k++) {\n\t\tch_stats = &priv->channel[k]->stats;\n\t\tfor (j = 0; j < DPAA2_ETH_CH_STATS; j++)\n\t\t\t*((__u64 *)data + i + j) += *((__u64 *)ch_stats + j);\n\t}\n\ti += j;\n\n\tfor (j = 0; j < priv->num_fqs; j++) {\n\t\t \n\t\terr = dpaa2_io_query_fq_count(NULL, priv->fq[j].fqid,\n\t\t\t\t\t      &fcnt, &bcnt);\n\t\tif (err) {\n\t\t\tnetdev_warn(net_dev, \"FQ query error %d\", err);\n\t\t\treturn;\n\t\t}\n\n\t\tif (priv->fq[j].type == DPAA2_TX_CONF_FQ) {\n\t\t\tfcnt_tx_total += fcnt;\n\t\t\tbcnt_tx_total += bcnt;\n\t\t} else {\n\t\t\tfcnt_rx_total += fcnt;\n\t\t\tbcnt_rx_total += bcnt;\n\t\t}\n\t}\n\n\t*(data + i++) = fcnt_rx_total;\n\t*(data + i++) = bcnt_rx_total;\n\t*(data + i++) = fcnt_tx_total;\n\t*(data + i++) = bcnt_tx_total;\n\n\tfor (j = 0; j < priv->num_bps; j++) {\n\t\terr = dpaa2_io_query_bp_count(NULL, priv->bp[j]->bpid, &buf_cnt);\n\t\tif (err) {\n\t\t\tnetdev_warn(net_dev, \"Buffer count query error %d\\n\", err);\n\t\t\treturn;\n\t\t}\n\t\tbuf_cnt_total += buf_cnt;\n\t}\n\t*(data + i++) = buf_cnt_total;\n\n\tmutex_lock(&priv->mac_lock);\n\n\tif (dpaa2_eth_has_mac(priv))\n\t\tdpaa2_mac_get_ethtool_stats(priv->mac, data + i);\n\n\tmutex_unlock(&priv->mac_lock);\n}\n\nstatic int dpaa2_eth_prep_eth_rule(struct ethhdr *eth_value, struct ethhdr *eth_mask,\n\t\t\t\t   void *key, void *mask, u64 *fields)\n{\n\tint off;\n\n\tif (eth_mask->h_proto) {\n\t\toff = dpaa2_eth_cls_fld_off(NET_PROT_ETH, NH_FLD_ETH_TYPE);\n\t\t*(__be16 *)(key + off) = eth_value->h_proto;\n\t\t*(__be16 *)(mask + off) = eth_mask->h_proto;\n\t\t*fields |= DPAA2_ETH_DIST_ETHTYPE;\n\t}\n\n\tif (!is_zero_ether_addr(eth_mask->h_source)) {\n\t\toff = dpaa2_eth_cls_fld_off(NET_PROT_ETH, NH_FLD_ETH_SA);\n\t\tether_addr_copy(key + off, eth_value->h_source);\n\t\tether_addr_copy(mask + off, eth_mask->h_source);\n\t\t*fields |= DPAA2_ETH_DIST_ETHSRC;\n\t}\n\n\tif (!is_zero_ether_addr(eth_mask->h_dest)) {\n\t\toff = dpaa2_eth_cls_fld_off(NET_PROT_ETH, NH_FLD_ETH_DA);\n\t\tether_addr_copy(key + off, eth_value->h_dest);\n\t\tether_addr_copy(mask + off, eth_mask->h_dest);\n\t\t*fields |= DPAA2_ETH_DIST_ETHDST;\n\t}\n\n\treturn 0;\n}\n\nstatic int dpaa2_eth_prep_uip_rule(struct ethtool_usrip4_spec *uip_value,\n\t\t\t\t   struct ethtool_usrip4_spec *uip_mask,\n\t\t\t\t   void *key, void *mask, u64 *fields)\n{\n\tint off;\n\tu32 tmp_value, tmp_mask;\n\n\tif (uip_mask->tos || uip_mask->ip_ver)\n\t\treturn -EOPNOTSUPP;\n\n\tif (uip_mask->ip4src) {\n\t\toff = dpaa2_eth_cls_fld_off(NET_PROT_IP, NH_FLD_IP_SRC);\n\t\t*(__be32 *)(key + off) = uip_value->ip4src;\n\t\t*(__be32 *)(mask + off) = uip_mask->ip4src;\n\t\t*fields |= DPAA2_ETH_DIST_IPSRC;\n\t}\n\n\tif (uip_mask->ip4dst) {\n\t\toff = dpaa2_eth_cls_fld_off(NET_PROT_IP, NH_FLD_IP_DST);\n\t\t*(__be32 *)(key + off) = uip_value->ip4dst;\n\t\t*(__be32 *)(mask + off) = uip_mask->ip4dst;\n\t\t*fields |= DPAA2_ETH_DIST_IPDST;\n\t}\n\n\tif (uip_mask->proto) {\n\t\toff = dpaa2_eth_cls_fld_off(NET_PROT_IP, NH_FLD_IP_PROTO);\n\t\t*(u8 *)(key + off) = uip_value->proto;\n\t\t*(u8 *)(mask + off) = uip_mask->proto;\n\t\t*fields |= DPAA2_ETH_DIST_IPPROTO;\n\t}\n\n\tif (uip_mask->l4_4_bytes) {\n\t\ttmp_value = be32_to_cpu(uip_value->l4_4_bytes);\n\t\ttmp_mask = be32_to_cpu(uip_mask->l4_4_bytes);\n\n\t\toff = dpaa2_eth_cls_fld_off(NET_PROT_UDP, NH_FLD_UDP_PORT_SRC);\n\t\t*(__be16 *)(key + off) = htons(tmp_value >> 16);\n\t\t*(__be16 *)(mask + off) = htons(tmp_mask >> 16);\n\t\t*fields |= DPAA2_ETH_DIST_L4SRC;\n\n\t\toff = dpaa2_eth_cls_fld_off(NET_PROT_UDP, NH_FLD_UDP_PORT_DST);\n\t\t*(__be16 *)(key + off) = htons(tmp_value & 0xFFFF);\n\t\t*(__be16 *)(mask + off) = htons(tmp_mask & 0xFFFF);\n\t\t*fields |= DPAA2_ETH_DIST_L4DST;\n\t}\n\n\t \n\toff = dpaa2_eth_cls_fld_off(NET_PROT_ETH, NH_FLD_ETH_TYPE);\n\t*(__be16 *)(key + off) = htons(ETH_P_IP);\n\t*(__be16 *)(mask + off) = htons(0xFFFF);\n\t*fields |= DPAA2_ETH_DIST_ETHTYPE;\n\n\treturn 0;\n}\n\nstatic int dpaa2_eth_prep_l4_rule(struct ethtool_tcpip4_spec *l4_value,\n\t\t\t\t  struct ethtool_tcpip4_spec *l4_mask,\n\t\t\t\t  void *key, void *mask, u8 l4_proto, u64 *fields)\n{\n\tint off;\n\n\tif (l4_mask->tos)\n\t\treturn -EOPNOTSUPP;\n\n\tif (l4_mask->ip4src) {\n\t\toff = dpaa2_eth_cls_fld_off(NET_PROT_IP, NH_FLD_IP_SRC);\n\t\t*(__be32 *)(key + off) = l4_value->ip4src;\n\t\t*(__be32 *)(mask + off) = l4_mask->ip4src;\n\t\t*fields |= DPAA2_ETH_DIST_IPSRC;\n\t}\n\n\tif (l4_mask->ip4dst) {\n\t\toff = dpaa2_eth_cls_fld_off(NET_PROT_IP, NH_FLD_IP_DST);\n\t\t*(__be32 *)(key + off) = l4_value->ip4dst;\n\t\t*(__be32 *)(mask + off) = l4_mask->ip4dst;\n\t\t*fields |= DPAA2_ETH_DIST_IPDST;\n\t}\n\n\tif (l4_mask->psrc) {\n\t\toff = dpaa2_eth_cls_fld_off(NET_PROT_UDP, NH_FLD_UDP_PORT_SRC);\n\t\t*(__be16 *)(key + off) = l4_value->psrc;\n\t\t*(__be16 *)(mask + off) = l4_mask->psrc;\n\t\t*fields |= DPAA2_ETH_DIST_L4SRC;\n\t}\n\n\tif (l4_mask->pdst) {\n\t\toff = dpaa2_eth_cls_fld_off(NET_PROT_UDP, NH_FLD_UDP_PORT_DST);\n\t\t*(__be16 *)(key + off) = l4_value->pdst;\n\t\t*(__be16 *)(mask + off) = l4_mask->pdst;\n\t\t*fields |= DPAA2_ETH_DIST_L4DST;\n\t}\n\n\t \n\toff = dpaa2_eth_cls_fld_off(NET_PROT_ETH, NH_FLD_ETH_TYPE);\n\t*(__be16 *)(key + off) = htons(ETH_P_IP);\n\t*(__be16 *)(mask + off) = htons(0xFFFF);\n\t*fields |= DPAA2_ETH_DIST_ETHTYPE;\n\n\toff = dpaa2_eth_cls_fld_off(NET_PROT_IP, NH_FLD_IP_PROTO);\n\t*(u8 *)(key + off) = l4_proto;\n\t*(u8 *)(mask + off) = 0xFF;\n\t*fields |= DPAA2_ETH_DIST_IPPROTO;\n\n\treturn 0;\n}\n\nstatic int dpaa2_eth_prep_ext_rule(struct ethtool_flow_ext *ext_value,\n\t\t\t\t   struct ethtool_flow_ext *ext_mask,\n\t\t\t\t   void *key, void *mask, u64 *fields)\n{\n\tint off;\n\n\tif (ext_mask->vlan_etype)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ext_mask->vlan_tci) {\n\t\toff = dpaa2_eth_cls_fld_off(NET_PROT_VLAN, NH_FLD_VLAN_TCI);\n\t\t*(__be16 *)(key + off) = ext_value->vlan_tci;\n\t\t*(__be16 *)(mask + off) = ext_mask->vlan_tci;\n\t\t*fields |= DPAA2_ETH_DIST_VLAN;\n\t}\n\n\treturn 0;\n}\n\nstatic int dpaa2_eth_prep_mac_ext_rule(struct ethtool_flow_ext *ext_value,\n\t\t\t\t       struct ethtool_flow_ext *ext_mask,\n\t\t\t\t       void *key, void *mask, u64 *fields)\n{\n\tint off;\n\n\tif (!is_zero_ether_addr(ext_mask->h_dest)) {\n\t\toff = dpaa2_eth_cls_fld_off(NET_PROT_ETH, NH_FLD_ETH_DA);\n\t\tether_addr_copy(key + off, ext_value->h_dest);\n\t\tether_addr_copy(mask + off, ext_mask->h_dest);\n\t\t*fields |= DPAA2_ETH_DIST_ETHDST;\n\t}\n\n\treturn 0;\n}\n\nstatic int dpaa2_eth_prep_cls_rule(struct ethtool_rx_flow_spec *fs, void *key,\n\t\t\t\t   void *mask, u64 *fields)\n{\n\tint err;\n\n\tswitch (fs->flow_type & 0xFF) {\n\tcase ETHER_FLOW:\n\t\terr = dpaa2_eth_prep_eth_rule(&fs->h_u.ether_spec, &fs->m_u.ether_spec,\n\t\t\t\t\t      key, mask, fields);\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\terr = dpaa2_eth_prep_uip_rule(&fs->h_u.usr_ip4_spec,\n\t\t\t\t\t      &fs->m_u.usr_ip4_spec, key, mask, fields);\n\t\tbreak;\n\tcase TCP_V4_FLOW:\n\t\terr = dpaa2_eth_prep_l4_rule(&fs->h_u.tcp_ip4_spec, &fs->m_u.tcp_ip4_spec,\n\t\t\t\t\t     key, mask, IPPROTO_TCP, fields);\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\terr = dpaa2_eth_prep_l4_rule(&fs->h_u.udp_ip4_spec, &fs->m_u.udp_ip4_spec,\n\t\t\t\t\t     key, mask, IPPROTO_UDP, fields);\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\t\terr = dpaa2_eth_prep_l4_rule(&fs->h_u.sctp_ip4_spec,\n\t\t\t\t\t     &fs->m_u.sctp_ip4_spec, key, mask,\n\t\t\t\t\t     IPPROTO_SCTP, fields);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\tif (fs->flow_type & FLOW_EXT) {\n\t\terr = dpaa2_eth_prep_ext_rule(&fs->h_ext, &fs->m_ext, key, mask, fields);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (fs->flow_type & FLOW_MAC_EXT) {\n\t\terr = dpaa2_eth_prep_mac_ext_rule(&fs->h_ext, &fs->m_ext, key,\n\t\t\t\t\t\t  mask, fields);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int dpaa2_eth_do_cls_rule(struct net_device *net_dev,\n\t\t\t\t struct ethtool_rx_flow_spec *fs,\n\t\t\t\t bool add)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\tstruct device *dev = net_dev->dev.parent;\n\tstruct dpni_rule_cfg rule_cfg = { 0 };\n\tstruct dpni_fs_action_cfg fs_act = { 0 };\n\tdma_addr_t key_iova;\n\tu64 fields = 0;\n\tvoid *key_buf;\n\tint i, err;\n\n\tif (fs->ring_cookie != RX_CLS_FLOW_DISC &&\n\t    fs->ring_cookie >= dpaa2_eth_queue_count(priv))\n\t\treturn -EINVAL;\n\n\trule_cfg.key_size = dpaa2_eth_cls_key_size(DPAA2_ETH_DIST_ALL);\n\n\t \n\tkey_buf = kzalloc(rule_cfg.key_size * 2, GFP_KERNEL);\n\tif (!key_buf)\n\t\treturn -ENOMEM;\n\n\t \n\terr = dpaa2_eth_prep_cls_rule(fs, key_buf, key_buf + rule_cfg.key_size, &fields);\n\tif (err)\n\t\tgoto free_mem;\n\n\tif (!dpaa2_eth_fs_mask_enabled(priv)) {\n\t\t \n\t\tif (!priv->rx_cls_fields) {\n\t\t\terr = dpaa2_eth_set_cls(net_dev, fields);\n\t\t\tif (err)\n\t\t\t\tgoto free_mem;\n\n\t\t\tpriv->rx_cls_fields = fields;\n\t\t} else if (priv->rx_cls_fields != fields) {\n\t\t\tnetdev_err(net_dev, \"No support for multiple FS keys, need to delete existing rules\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto free_mem;\n\t\t}\n\n\t\tdpaa2_eth_cls_trim_rule(key_buf, fields);\n\t\trule_cfg.key_size = dpaa2_eth_cls_key_size(fields);\n\t}\n\n\tkey_iova = dma_map_single(dev, key_buf, rule_cfg.key_size * 2,\n\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, key_iova)) {\n\t\terr = -ENOMEM;\n\t\tgoto free_mem;\n\t}\n\n\trule_cfg.key_iova = key_iova;\n\tif (dpaa2_eth_fs_mask_enabled(priv))\n\t\trule_cfg.mask_iova = key_iova + rule_cfg.key_size;\n\n\tif (add) {\n\t\tif (fs->ring_cookie == RX_CLS_FLOW_DISC)\n\t\t\tfs_act.options |= DPNI_FS_OPT_DISCARD;\n\t\telse\n\t\t\tfs_act.flow_id = fs->ring_cookie;\n\t}\n\tfor (i = 0; i < dpaa2_eth_tc_count(priv); i++) {\n\t\tif (add)\n\t\t\terr = dpni_add_fs_entry(priv->mc_io, 0, priv->mc_token,\n\t\t\t\t\t\ti, fs->location, &rule_cfg,\n\t\t\t\t\t\t&fs_act);\n\t\telse\n\t\t\terr = dpni_remove_fs_entry(priv->mc_io, 0,\n\t\t\t\t\t\t   priv->mc_token, i,\n\t\t\t\t\t\t   &rule_cfg);\n\t\tif (err || priv->dpni_attrs.options & DPNI_OPT_SHARED_FS)\n\t\t\tbreak;\n\t}\n\n\tdma_unmap_single(dev, key_iova, rule_cfg.key_size * 2, DMA_TO_DEVICE);\n\nfree_mem:\n\tkfree(key_buf);\n\n\treturn err;\n}\n\nstatic int dpaa2_eth_num_cls_rules(struct dpaa2_eth_priv *priv)\n{\n\tint i, rules = 0;\n\n\tfor (i = 0; i < dpaa2_eth_fs_count(priv); i++)\n\t\tif (priv->cls_rules[i].in_use)\n\t\t\trules++;\n\n\treturn rules;\n}\n\nstatic int dpaa2_eth_update_cls_rule(struct net_device *net_dev,\n\t\t\t\t     struct ethtool_rx_flow_spec *new_fs,\n\t\t\t\t     unsigned int location)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\tstruct dpaa2_eth_cls_rule *rule;\n\tint err = -EINVAL;\n\n\tif (!priv->rx_cls_enabled)\n\t\treturn -EOPNOTSUPP;\n\n\tif (location >= dpaa2_eth_fs_count(priv))\n\t\treturn -EINVAL;\n\n\trule = &priv->cls_rules[location];\n\n\t \n\tif (rule->in_use) {\n\t\terr = dpaa2_eth_do_cls_rule(net_dev, &rule->fs, false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\trule->in_use = 0;\n\n\t\tif (!dpaa2_eth_fs_mask_enabled(priv) &&\n\t\t    !dpaa2_eth_num_cls_rules(priv))\n\t\t\tpriv->rx_cls_fields = 0;\n\t}\n\n\t \n\tif (!new_fs)\n\t\treturn err;\n\n\terr = dpaa2_eth_do_cls_rule(net_dev, new_fs, true);\n\tif (err)\n\t\treturn err;\n\n\trule->in_use = 1;\n\trule->fs = *new_fs;\n\n\treturn 0;\n}\n\nstatic int dpaa2_eth_get_rxnfc(struct net_device *net_dev,\n\t\t\t       struct ethtool_rxnfc *rxnfc, u32 *rule_locs)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\tint max_rules = dpaa2_eth_fs_count(priv);\n\tint i, j = 0;\n\n\tswitch (rxnfc->cmd) {\n\tcase ETHTOOL_GRXFH:\n\t\t \n\t\trxnfc->data = priv->rx_hash_fields;\n\t\tbreak;\n\tcase ETHTOOL_GRXRINGS:\n\t\trxnfc->data = dpaa2_eth_queue_count(priv);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\trxnfc->rule_cnt = 0;\n\t\trxnfc->rule_cnt = dpaa2_eth_num_cls_rules(priv);\n\t\trxnfc->data = max_rules;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tif (rxnfc->fs.location >= max_rules)\n\t\t\treturn -EINVAL;\n\t\trxnfc->fs.location = array_index_nospec(rxnfc->fs.location,\n\t\t\t\t\t\t\tmax_rules);\n\t\tif (!priv->cls_rules[rxnfc->fs.location].in_use)\n\t\t\treturn -EINVAL;\n\t\trxnfc->fs = priv->cls_rules[rxnfc->fs.location].fs;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tfor (i = 0; i < max_rules; i++) {\n\t\t\tif (!priv->cls_rules[i].in_use)\n\t\t\t\tcontinue;\n\t\t\tif (j == rxnfc->rule_cnt)\n\t\t\t\treturn -EMSGSIZE;\n\t\t\trule_locs[j++] = i;\n\t\t}\n\t\trxnfc->rule_cnt = j;\n\t\trxnfc->data = max_rules;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int dpaa2_eth_set_rxnfc(struct net_device *net_dev,\n\t\t\t       struct ethtool_rxnfc *rxnfc)\n{\n\tint err = 0;\n\n\tswitch (rxnfc->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\tif ((rxnfc->data & DPAA2_RXH_SUPPORTED) != rxnfc->data)\n\t\t\treturn -EOPNOTSUPP;\n\t\terr = dpaa2_eth_set_hash(net_dev, rxnfc->data);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\terr = dpaa2_eth_update_cls_rule(net_dev, &rxnfc->fs, rxnfc->fs.location);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\terr = dpaa2_eth_update_cls_rule(net_dev, NULL, rxnfc->fs.location);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nint dpaa2_phc_index = -1;\nEXPORT_SYMBOL(dpaa2_phc_index);\n\nstatic int dpaa2_eth_get_ts_info(struct net_device *dev,\n\t\t\t\t struct ethtool_ts_info *info)\n{\n\tif (!dpaa2_ptp)\n\t\treturn ethtool_op_get_ts_info(dev, info);\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tinfo->phc_index = dpaa2_phc_index;\n\n\tinfo->tx_types = (1 << HWTSTAMP_TX_OFF) |\n\t\t\t (1 << HWTSTAMP_TX_ON) |\n\t\t\t (1 << HWTSTAMP_TX_ONESTEP_SYNC);\n\n\tinfo->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t   (1 << HWTSTAMP_FILTER_ALL);\n\treturn 0;\n}\n\nstatic int dpaa2_eth_get_tunable(struct net_device *net_dev,\n\t\t\t\t const struct ethtool_tunable *tuna,\n\t\t\t\t void *data)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\tint err = 0;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\t*(u32 *)data = priv->rx_copybreak;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int dpaa2_eth_set_tunable(struct net_device *net_dev,\n\t\t\t\t const struct ethtool_tunable *tuna,\n\t\t\t\t const void *data)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\tint err = 0;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\tpriv->rx_copybreak = *(u32 *)data;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int dpaa2_eth_get_coalesce(struct net_device *dev,\n\t\t\t\t  struct ethtool_coalesce *ic,\n\t\t\t\t  struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(dev);\n\tstruct dpaa2_io *dpio = priv->channel[0]->dpio;\n\n\tdpaa2_io_get_irq_coalescing(dpio, &ic->rx_coalesce_usecs);\n\tic->use_adaptive_rx_coalesce = dpaa2_io_get_adaptive_coalescing(dpio);\n\n\treturn 0;\n}\n\nstatic int dpaa2_eth_set_coalesce(struct net_device *dev,\n\t\t\t\t  struct ethtool_coalesce *ic,\n\t\t\t\t  struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(dev);\n\tstruct dpaa2_io *dpio;\n\tint prev_adaptive;\n\tu32 prev_rx_usecs;\n\tint i, j, err;\n\n\t \n\tdpio = priv->channel[0]->dpio;\n\tdpaa2_io_get_irq_coalescing(dpio, &prev_rx_usecs);\n\tprev_adaptive = dpaa2_io_get_adaptive_coalescing(dpio);\n\n\t \n\tfor (i = 0; i < priv->num_channels; i++) {\n\t\tdpio = priv->channel[i]->dpio;\n\n\t\tdpaa2_io_set_adaptive_coalescing(dpio,\n\t\t\t\t\t\t ic->use_adaptive_rx_coalesce);\n\t\terr = dpaa2_io_set_irq_coalescing(dpio, ic->rx_coalesce_usecs);\n\t\tif (err)\n\t\t\tgoto restore_rx_usecs;\n\t}\n\n\treturn 0;\n\nrestore_rx_usecs:\n\tfor (j = 0; j < i; j++) {\n\t\tdpio = priv->channel[j]->dpio;\n\n\t\tdpaa2_io_set_irq_coalescing(dpio, prev_rx_usecs);\n\t\tdpaa2_io_set_adaptive_coalescing(dpio, prev_adaptive);\n\t}\n\n\treturn err;\n}\n\nstatic void dpaa2_eth_get_channels(struct net_device *net_dev,\n\t\t\t\t   struct ethtool_channels *channels)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\tint queue_count = dpaa2_eth_queue_count(priv);\n\n\tchannels->max_rx = queue_count;\n\tchannels->max_tx = queue_count;\n\tchannels->rx_count = queue_count;\n\tchannels->tx_count = queue_count;\n\n\t \n\tchannels->max_other = queue_count + 1;\n\tchannels->max_combined = channels->max_rx +\n\t\t\t\t channels->max_tx +\n\t\t\t\t channels->max_other;\n\t \n\tchannels->other_count = queue_count + 1;\n\tchannels->combined_count = channels->rx_count +\n\t\t\t\t   channels->tx_count +\n\t\t\t\t   channels->other_count;\n}\n\nconst struct ethtool_ops dpaa2_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_RX_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE_RX,\n\t.get_drvinfo = dpaa2_eth_get_drvinfo,\n\t.nway_reset = dpaa2_eth_nway_reset,\n\t.get_link = ethtool_op_get_link,\n\t.get_link_ksettings = dpaa2_eth_get_link_ksettings,\n\t.set_link_ksettings = dpaa2_eth_set_link_ksettings,\n\t.get_pauseparam = dpaa2_eth_get_pauseparam,\n\t.set_pauseparam = dpaa2_eth_set_pauseparam,\n\t.get_sset_count = dpaa2_eth_get_sset_count,\n\t.get_ethtool_stats = dpaa2_eth_get_ethtool_stats,\n\t.get_strings = dpaa2_eth_get_strings,\n\t.get_rxnfc = dpaa2_eth_get_rxnfc,\n\t.set_rxnfc = dpaa2_eth_set_rxnfc,\n\t.get_ts_info = dpaa2_eth_get_ts_info,\n\t.get_tunable = dpaa2_eth_get_tunable,\n\t.set_tunable = dpaa2_eth_set_tunable,\n\t.get_coalesce = dpaa2_eth_get_coalesce,\n\t.set_coalesce = dpaa2_eth_set_coalesce,\n\t.get_channels = dpaa2_eth_get_channels,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}