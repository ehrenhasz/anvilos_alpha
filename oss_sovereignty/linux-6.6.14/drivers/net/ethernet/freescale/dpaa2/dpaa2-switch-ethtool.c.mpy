{
  "module_name": "dpaa2-switch-ethtool.c",
  "hash_id": "9490ba03f15bfd6cdb9fcbd04008b22ff68713f8cd21ed5f53a7a4c50e2af4df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/dpaa2/dpaa2-switch-ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n\n#include \"dpaa2-switch.h\"\n\nstatic struct {\n\tenum dpsw_counter id;\n\tchar name[ETH_GSTRING_LEN];\n} dpaa2_switch_ethtool_counters[] =  {\n\t{DPSW_CNT_ING_FRAME,\t\t\"[hw] rx frames\"},\n\t{DPSW_CNT_ING_BYTE,\t\t\"[hw] rx bytes\"},\n\t{DPSW_CNT_ING_FLTR_FRAME,\t\"[hw] rx filtered frames\"},\n\t{DPSW_CNT_ING_FRAME_DISCARD,\t\"[hw] rx discarded frames\"},\n\t{DPSW_CNT_ING_BCAST_FRAME,\t\"[hw] rx bcast frames\"},\n\t{DPSW_CNT_ING_BCAST_BYTES,\t\"[hw] rx bcast bytes\"},\n\t{DPSW_CNT_ING_MCAST_FRAME,\t\"[hw] rx mcast frames\"},\n\t{DPSW_CNT_ING_MCAST_BYTE,\t\"[hw] rx mcast bytes\"},\n\t{DPSW_CNT_EGR_FRAME,\t\t\"[hw] tx frames\"},\n\t{DPSW_CNT_EGR_BYTE,\t\t\"[hw] tx bytes\"},\n\t{DPSW_CNT_EGR_FRAME_DISCARD,\t\"[hw] tx discarded frames\"},\n\t{DPSW_CNT_ING_NO_BUFF_DISCARD,\t\"[hw] rx nobuffer discards\"},\n};\n\n#define DPAA2_SWITCH_NUM_COUNTERS\tARRAY_SIZE(dpaa2_switch_ethtool_counters)\n\nstatic void dpaa2_switch_get_drvinfo(struct net_device *netdev,\n\t\t\t\t     struct ethtool_drvinfo *drvinfo)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tu16 version_major, version_minor;\n\tint err;\n\n\tstrscpy(drvinfo->driver, KBUILD_MODNAME, sizeof(drvinfo->driver));\n\n\terr = dpsw_get_api_version(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t   &version_major,\n\t\t\t\t   &version_minor);\n\tif (err)\n\t\tstrscpy(drvinfo->fw_version, \"N/A\",\n\t\t\tsizeof(drvinfo->fw_version));\n\telse\n\t\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t\t \"%u.%u\", version_major, version_minor);\n\n\tstrscpy(drvinfo->bus_info, dev_name(netdev->dev.parent->parent),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic int\ndpaa2_switch_get_link_ksettings(struct net_device *netdev,\n\t\t\t\tstruct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tstruct dpsw_link_state state = {0};\n\tint err;\n\n\tmutex_lock(&port_priv->mac_lock);\n\n\tif (dpaa2_switch_port_is_type_phy(port_priv)) {\n\t\terr = phylink_ethtool_ksettings_get(port_priv->mac->phylink,\n\t\t\t\t\t\t    link_ksettings);\n\t\tmutex_unlock(&port_priv->mac_lock);\n\t\treturn err;\n\t}\n\n\tmutex_unlock(&port_priv->mac_lock);\n\n\terr = dpsw_if_get_link_state(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t     port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t     port_priv->idx,\n\t\t\t\t     &state);\n\tif (err) {\n\t\tnetdev_err(netdev, \"ERROR %d getting link state\\n\", err);\n\t\tgoto out;\n\t}\n\n\t \n\tif (state.options & DPSW_LINK_OPT_AUTONEG)\n\t\tlink_ksettings->base.autoneg = AUTONEG_ENABLE;\n\tif (!(state.options & DPSW_LINK_OPT_HALF_DUPLEX))\n\t\tlink_ksettings->base.duplex = DUPLEX_FULL;\n\tlink_ksettings->base.speed = state.rate;\n\nout:\n\treturn err;\n}\n\nstatic int\ndpaa2_switch_set_link_ksettings(struct net_device *netdev,\n\t\t\t\tconst struct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct dpsw_link_cfg cfg = {0};\n\tbool if_running;\n\tint err = 0, ret;\n\n\tmutex_lock(&port_priv->mac_lock);\n\n\tif (dpaa2_switch_port_is_type_phy(port_priv)) {\n\t\terr = phylink_ethtool_ksettings_set(port_priv->mac->phylink,\n\t\t\t\t\t\t    link_ksettings);\n\t\tmutex_unlock(&port_priv->mac_lock);\n\t\treturn err;\n\t}\n\n\tmutex_unlock(&port_priv->mac_lock);\n\n\t \n\tif_running = netif_running(netdev);\n\tif (if_running) {\n\t\terr = dpsw_if_disable(ethsw->mc_io, 0,\n\t\t\t\t      ethsw->dpsw_handle,\n\t\t\t\t      port_priv->idx);\n\t\tif (err) {\n\t\t\tnetdev_err(netdev, \"dpsw_if_disable err %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tcfg.rate = link_ksettings->base.speed;\n\tif (link_ksettings->base.autoneg == AUTONEG_ENABLE)\n\t\tcfg.options |= DPSW_LINK_OPT_AUTONEG;\n\telse\n\t\tcfg.options &= ~DPSW_LINK_OPT_AUTONEG;\n\tif (link_ksettings->base.duplex  == DUPLEX_HALF)\n\t\tcfg.options |= DPSW_LINK_OPT_HALF_DUPLEX;\n\telse\n\t\tcfg.options &= ~DPSW_LINK_OPT_HALF_DUPLEX;\n\n\terr = dpsw_if_set_link_cfg(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t   port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t   port_priv->idx,\n\t\t\t\t   &cfg);\n\n\tif (if_running) {\n\t\tret = dpsw_if_enable(ethsw->mc_io, 0,\n\t\t\t\t     ethsw->dpsw_handle,\n\t\t\t\t     port_priv->idx);\n\t\tif (ret) {\n\t\t\tnetdev_err(netdev, \"dpsw_if_enable err %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int\ndpaa2_switch_ethtool_get_sset_count(struct net_device *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn DPAA2_SWITCH_NUM_COUNTERS + dpaa2_mac_get_sset_count();\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void dpaa2_switch_ethtool_get_strings(struct net_device *netdev,\n\t\t\t\t\t     u32 stringset, u8 *data)\n{\n\tu8 *p = data;\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < DPAA2_SWITCH_NUM_COUNTERS; i++) {\n\t\t\tmemcpy(p, dpaa2_switch_ethtool_counters[i].name,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tdpaa2_mac_get_strings(p);\n\t\tbreak;\n\t}\n}\n\nstatic void dpaa2_switch_ethtool_get_stats(struct net_device *netdev,\n\t\t\t\t\t   struct ethtool_stats *stats,\n\t\t\t\t\t   u64 *data)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tint i, err;\n\n\tfor (i = 0; i < DPAA2_SWITCH_NUM_COUNTERS; i++) {\n\t\terr = dpsw_if_get_counter(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t\t  port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t\t  port_priv->idx,\n\t\t\t\t\t  dpaa2_switch_ethtool_counters[i].id,\n\t\t\t\t\t  &data[i]);\n\t\tif (err)\n\t\t\tnetdev_err(netdev, \"dpsw_if_get_counter[%s] err %d\\n\",\n\t\t\t\t   dpaa2_switch_ethtool_counters[i].name, err);\n\t}\n\n\tmutex_lock(&port_priv->mac_lock);\n\n\tif (dpaa2_switch_port_has_mac(port_priv))\n\t\tdpaa2_mac_get_ethtool_stats(port_priv->mac, data + i);\n\n\tmutex_unlock(&port_priv->mac_lock);\n}\n\nconst struct ethtool_ops dpaa2_switch_port_ethtool_ops = {\n\t.get_drvinfo\t\t= dpaa2_switch_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_link_ksettings\t= dpaa2_switch_get_link_ksettings,\n\t.set_link_ksettings\t= dpaa2_switch_set_link_ksettings,\n\t.get_strings\t\t= dpaa2_switch_ethtool_get_strings,\n\t.get_ethtool_stats\t= dpaa2_switch_ethtool_get_stats,\n\t.get_sset_count\t\t= dpaa2_switch_ethtool_get_sset_count,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}