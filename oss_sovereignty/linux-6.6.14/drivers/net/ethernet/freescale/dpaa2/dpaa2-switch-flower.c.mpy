{
  "module_name": "dpaa2-switch-flower.c",
  "hash_id": "a23622339b77a5f7b3c5c5844cde55865c8d3d00b819887eb53c10f5037800f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/dpaa2/dpaa2-switch-flower.c",
  "human_readable_source": "\n \n\n#include \"dpaa2-switch.h\"\n\nstatic int dpaa2_switch_flower_parse_key(struct flow_cls_offload *cls,\n\t\t\t\t\t struct dpsw_acl_key *acl_key)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(cls);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct dpsw_acl_fields *acl_h, *acl_m;\n\n\tif (dissector->used_keys &\n\t    ~(BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_VLAN) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_PORTS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IP) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV6_ADDRS) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_IPV4_ADDRS))) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Unsupported keys used\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tacl_h = &acl_key->match;\n\tacl_m = &acl_key->mask;\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC)) {\n\t\tstruct flow_match_basic match;\n\n\t\tflow_rule_match_basic(rule, &match);\n\t\tacl_h->l3_protocol = match.key->ip_proto;\n\t\tacl_h->l2_ether_type = be16_to_cpu(match.key->n_proto);\n\t\tacl_m->l3_protocol = match.mask->ip_proto;\n\t\tacl_m->l2_ether_type = be16_to_cpu(match.mask->n_proto);\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct flow_match_eth_addrs match;\n\n\t\tflow_rule_match_eth_addrs(rule, &match);\n\t\tether_addr_copy(acl_h->l2_dest_mac, &match.key->dst[0]);\n\t\tether_addr_copy(acl_h->l2_source_mac, &match.key->src[0]);\n\t\tether_addr_copy(acl_m->l2_dest_mac, &match.mask->dst[0]);\n\t\tether_addr_copy(acl_m->l2_source_mac, &match.mask->src[0]);\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tstruct flow_match_vlan match;\n\n\t\tflow_rule_match_vlan(rule, &match);\n\t\tacl_h->l2_vlan_id = match.key->vlan_id;\n\t\tacl_h->l2_tpid = be16_to_cpu(match.key->vlan_tpid);\n\t\tacl_h->l2_pcp_dei = match.key->vlan_priority << 1 |\n\t\t\t\t    match.key->vlan_dei;\n\n\t\tacl_m->l2_vlan_id = match.mask->vlan_id;\n\t\tacl_m->l2_tpid = be16_to_cpu(match.mask->vlan_tpid);\n\t\tacl_m->l2_pcp_dei = match.mask->vlan_priority << 1 |\n\t\t\t\t    match.mask->vlan_dei;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IPV4_ADDRS)) {\n\t\tstruct flow_match_ipv4_addrs match;\n\n\t\tflow_rule_match_ipv4_addrs(rule, &match);\n\t\tacl_h->l3_source_ip = be32_to_cpu(match.key->src);\n\t\tacl_h->l3_dest_ip = be32_to_cpu(match.key->dst);\n\t\tacl_m->l3_source_ip = be32_to_cpu(match.mask->src);\n\t\tacl_m->l3_dest_ip = be32_to_cpu(match.mask->dst);\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_PORTS)) {\n\t\tstruct flow_match_ports match;\n\n\t\tflow_rule_match_ports(rule, &match);\n\t\tacl_h->l4_source_port = be16_to_cpu(match.key->src);\n\t\tacl_h->l4_dest_port = be16_to_cpu(match.key->dst);\n\t\tacl_m->l4_source_port = be16_to_cpu(match.mask->src);\n\t\tacl_m->l4_dest_port = be16_to_cpu(match.mask->dst);\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IP)) {\n\t\tstruct flow_match_ip match;\n\n\t\tflow_rule_match_ip(rule, &match);\n\t\tif (match.mask->ttl != 0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Matching on TTL not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif ((match.mask->tos & 0x3) != 0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Matching on ECN not supported, only DSCP\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tacl_h->l3_dscp = match.key->tos >> 2;\n\t\tacl_m->l3_dscp = match.mask->tos >> 2;\n\t}\n\n\treturn 0;\n}\n\nint dpaa2_switch_acl_entry_add(struct dpaa2_switch_filter_block *filter_block,\n\t\t\t       struct dpaa2_switch_acl_entry *entry)\n{\n\tstruct dpsw_acl_entry_cfg *acl_entry_cfg = &entry->cfg;\n\tstruct ethsw_core *ethsw = filter_block->ethsw;\n\tstruct dpsw_acl_key *acl_key = &entry->key;\n\tstruct device *dev = ethsw->dev;\n\tu8 *cmd_buff;\n\tint err;\n\n\tcmd_buff = kzalloc(DPAA2_ETHSW_PORT_ACL_CMD_BUF_SIZE, GFP_KERNEL);\n\tif (!cmd_buff)\n\t\treturn -ENOMEM;\n\n\tdpsw_acl_prepare_entry_cfg(acl_key, cmd_buff);\n\n\tacl_entry_cfg->key_iova = dma_map_single(dev, cmd_buff,\n\t\t\t\t\t\t DPAA2_ETHSW_PORT_ACL_CMD_BUF_SIZE,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(dev, acl_entry_cfg->key_iova))) {\n\t\tdev_err(dev, \"DMA mapping failed\\n\");\n\t\tkfree(cmd_buff);\n\t\treturn -EFAULT;\n\t}\n\n\terr = dpsw_acl_add_entry(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t filter_block->acl_id, acl_entry_cfg);\n\n\tdma_unmap_single(dev, acl_entry_cfg->key_iova,\n\t\t\t DPAA2_ETHSW_PORT_ACL_CMD_BUF_SIZE,\n\t\t\t DMA_TO_DEVICE);\n\tif (err) {\n\t\tdev_err(dev, \"dpsw_acl_add_entry() failed %d\\n\", err);\n\t\tkfree(cmd_buff);\n\t\treturn err;\n\t}\n\n\tkfree(cmd_buff);\n\n\treturn 0;\n}\n\nstatic int\ndpaa2_switch_acl_entry_remove(struct dpaa2_switch_filter_block *block,\n\t\t\t      struct dpaa2_switch_acl_entry *entry)\n{\n\tstruct dpsw_acl_entry_cfg *acl_entry_cfg = &entry->cfg;\n\tstruct dpsw_acl_key *acl_key = &entry->key;\n\tstruct ethsw_core *ethsw = block->ethsw;\n\tstruct device *dev = ethsw->dev;\n\tu8 *cmd_buff;\n\tint err;\n\n\tcmd_buff = kzalloc(DPAA2_ETHSW_PORT_ACL_CMD_BUF_SIZE, GFP_KERNEL);\n\tif (!cmd_buff)\n\t\treturn -ENOMEM;\n\n\tdpsw_acl_prepare_entry_cfg(acl_key, cmd_buff);\n\n\tacl_entry_cfg->key_iova = dma_map_single(dev, cmd_buff,\n\t\t\t\t\t\t DPAA2_ETHSW_PORT_ACL_CMD_BUF_SIZE,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(dev, acl_entry_cfg->key_iova))) {\n\t\tdev_err(dev, \"DMA mapping failed\\n\");\n\t\tkfree(cmd_buff);\n\t\treturn -EFAULT;\n\t}\n\n\terr = dpsw_acl_remove_entry(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t    block->acl_id, acl_entry_cfg);\n\n\tdma_unmap_single(dev, acl_entry_cfg->key_iova,\n\t\t\t DPAA2_ETHSW_PORT_ACL_CMD_BUF_SIZE, DMA_TO_DEVICE);\n\tif (err) {\n\t\tdev_err(dev, \"dpsw_acl_remove_entry() failed %d\\n\", err);\n\t\tkfree(cmd_buff);\n\t\treturn err;\n\t}\n\n\tkfree(cmd_buff);\n\n\treturn 0;\n}\n\nstatic int\ndpaa2_switch_acl_entry_add_to_list(struct dpaa2_switch_filter_block *block,\n\t\t\t\t   struct dpaa2_switch_acl_entry *entry)\n{\n\tstruct dpaa2_switch_acl_entry *tmp;\n\tstruct list_head *pos, *n;\n\tint index = 0;\n\n\tif (list_empty(&block->acl_entries)) {\n\t\tlist_add(&entry->list, &block->acl_entries);\n\t\treturn index;\n\t}\n\n\tlist_for_each_safe(pos, n, &block->acl_entries) {\n\t\ttmp = list_entry(pos, struct dpaa2_switch_acl_entry, list);\n\t\tif (entry->prio < tmp->prio)\n\t\t\tbreak;\n\t\tindex++;\n\t}\n\tlist_add(&entry->list, pos->prev);\n\treturn index;\n}\n\nstatic struct dpaa2_switch_acl_entry*\ndpaa2_switch_acl_entry_get_by_index(struct dpaa2_switch_filter_block *block,\n\t\t\t\t    int index)\n{\n\tstruct dpaa2_switch_acl_entry *tmp;\n\tint i = 0;\n\n\tlist_for_each_entry(tmp, &block->acl_entries, list) {\n\t\tif (i == index)\n\t\t\treturn tmp;\n\t\t++i;\n\t}\n\n\treturn NULL;\n}\n\nstatic int\ndpaa2_switch_acl_entry_set_precedence(struct dpaa2_switch_filter_block *block,\n\t\t\t\t      struct dpaa2_switch_acl_entry *entry,\n\t\t\t\t      int precedence)\n{\n\tint err;\n\n\terr = dpaa2_switch_acl_entry_remove(block, entry);\n\tif (err)\n\t\treturn err;\n\n\tentry->cfg.precedence = precedence;\n\treturn dpaa2_switch_acl_entry_add(block, entry);\n}\n\nstatic int\ndpaa2_switch_acl_tbl_add_entry(struct dpaa2_switch_filter_block *block,\n\t\t\t       struct dpaa2_switch_acl_entry *entry)\n{\n\tstruct dpaa2_switch_acl_entry *tmp;\n\tint index, i, precedence, err;\n\n\t \n\tindex = dpaa2_switch_acl_entry_add_to_list(block, entry);\n\n\t \n\tprecedence = DPAA2_ETHSW_PORT_MAX_ACL_ENTRIES - block->num_acl_rules - 1;\n\tfor (i = 0; i < index; i++) {\n\t\ttmp = dpaa2_switch_acl_entry_get_by_index(block, i);\n\n\t\terr = dpaa2_switch_acl_entry_set_precedence(block, tmp,\n\t\t\t\t\t\t\t    precedence);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tprecedence++;\n\t}\n\n\t \n\tentry->cfg.precedence = precedence;\n\terr = dpaa2_switch_acl_entry_add(block, entry);\n\tblock->num_acl_rules++;\n\n\treturn err;\n}\n\nstatic struct dpaa2_switch_acl_entry *\ndpaa2_switch_acl_tbl_find_entry_by_cookie(struct dpaa2_switch_filter_block *block,\n\t\t\t\t\t  unsigned long cookie)\n{\n\tstruct dpaa2_switch_acl_entry *tmp, *n;\n\n\tlist_for_each_entry_safe(tmp, n, &block->acl_entries, list) {\n\t\tif (tmp->cookie == cookie)\n\t\t\treturn tmp;\n\t}\n\treturn NULL;\n}\n\nstatic int\ndpaa2_switch_acl_entry_get_index(struct dpaa2_switch_filter_block *block,\n\t\t\t\t struct dpaa2_switch_acl_entry *entry)\n{\n\tstruct dpaa2_switch_acl_entry *tmp, *n;\n\tint index = 0;\n\n\tlist_for_each_entry_safe(tmp, n, &block->acl_entries, list) {\n\t\tif (tmp->cookie == entry->cookie)\n\t\t\treturn index;\n\t\tindex++;\n\t}\n\treturn -ENOENT;\n}\n\nstatic struct dpaa2_switch_mirror_entry *\ndpaa2_switch_mirror_find_entry_by_cookie(struct dpaa2_switch_filter_block *block,\n\t\t\t\t\t unsigned long cookie)\n{\n\tstruct dpaa2_switch_mirror_entry *tmp, *n;\n\n\tlist_for_each_entry_safe(tmp, n, &block->mirror_entries, list) {\n\t\tif (tmp->cookie == cookie)\n\t\t\treturn tmp;\n\t}\n\treturn NULL;\n}\n\nstatic int\ndpaa2_switch_acl_tbl_remove_entry(struct dpaa2_switch_filter_block *block,\n\t\t\t\t  struct dpaa2_switch_acl_entry *entry)\n{\n\tstruct dpaa2_switch_acl_entry *tmp;\n\tint index, i, precedence, err;\n\n\tindex = dpaa2_switch_acl_entry_get_index(block, entry);\n\n\t \n\terr = dpaa2_switch_acl_entry_remove(block, entry);\n\tif (err)\n\t\treturn err;\n\n\tblock->num_acl_rules--;\n\n\t \n\tlist_del(&entry->list);\n\n\t \n\tprecedence = entry->cfg.precedence;\n\tfor (i = index - 1; i >= 0; i--) {\n\t\ttmp = dpaa2_switch_acl_entry_get_by_index(block, i);\n\t\terr = dpaa2_switch_acl_entry_set_precedence(block, tmp,\n\t\t\t\t\t\t\t    precedence);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tprecedence--;\n\t}\n\n\tkfree(entry);\n\n\treturn 0;\n}\n\nstatic int dpaa2_switch_tc_parse_action_acl(struct ethsw_core *ethsw,\n\t\t\t\t\t    struct flow_action_entry *cls_act,\n\t\t\t\t\t    struct dpsw_acl_result *dpsw_act,\n\t\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tint err = 0;\n\n\tswitch (cls_act->id) {\n\tcase FLOW_ACTION_TRAP:\n\t\tdpsw_act->action = DPSW_ACL_ACTION_REDIRECT_TO_CTRL_IF;\n\t\tbreak;\n\tcase FLOW_ACTION_REDIRECT:\n\t\tif (!dpaa2_switch_port_dev_check(cls_act->dev)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Destination not a DPAA2 switch port\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tdpsw_act->if_id = dpaa2_switch_get_index(ethsw, cls_act->dev);\n\t\tdpsw_act->action = DPSW_ACL_ACTION_REDIRECT;\n\t\tbreak;\n\tcase FLOW_ACTION_DROP:\n\t\tdpsw_act->action = DPSW_ACL_ACTION_DROP;\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Action not supported\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\nout:\n\treturn err;\n}\n\nstatic int\ndpaa2_switch_block_add_mirror(struct dpaa2_switch_filter_block *block,\n\t\t\t      struct dpaa2_switch_mirror_entry *entry,\n\t\t\t      u16 to, struct netlink_ext_ack *extack)\n{\n\tunsigned long block_ports = block->ports;\n\tstruct ethsw_core *ethsw = block->ethsw;\n\tstruct ethsw_port_priv *port_priv;\n\tunsigned long ports_added = 0;\n\tu16 vlan = entry->cfg.vlan_id;\n\tbool mirror_port_enabled;\n\tint err, port;\n\n\t \n\tmirror_port_enabled = (ethsw->mirror_port != ethsw->sw_attr.num_ifs);\n\tif (!mirror_port_enabled) {\n\t\terr = dpsw_set_reflection_if(ethsw->mc_io, 0,\n\t\t\t\t\t     ethsw->dpsw_handle, to);\n\t\tif (err)\n\t\t\treturn err;\n\t\tethsw->mirror_port = to;\n\t}\n\n\t \n\tfor_each_set_bit(port, &block_ports, ethsw->sw_attr.num_ifs) {\n\t\tport_priv = ethsw->ports[port];\n\n\t\t \n\t\tif (entry->cfg.filter == DPSW_REFLECTION_FILTER_INGRESS_VLAN &&\n\t\t    !(port_priv->vlans[vlan] & ETHSW_VLAN_MEMBER)) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"VLAN must be installed on the switch port\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_remove_filters;\n\t\t}\n\n\t\terr = dpsw_if_add_reflection(ethsw->mc_io, 0,\n\t\t\t\t\t     ethsw->dpsw_handle,\n\t\t\t\t\t     port, &entry->cfg);\n\t\tif (err)\n\t\t\tgoto err_remove_filters;\n\n\t\tports_added |= BIT(port);\n\t}\n\n\tlist_add(&entry->list, &block->mirror_entries);\n\n\treturn 0;\n\nerr_remove_filters:\n\tfor_each_set_bit(port, &ports_added, ethsw->sw_attr.num_ifs) {\n\t\tdpsw_if_remove_reflection(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t\t  port, &entry->cfg);\n\t}\n\n\tif (!mirror_port_enabled)\n\t\tethsw->mirror_port = ethsw->sw_attr.num_ifs;\n\n\treturn err;\n}\n\nstatic int\ndpaa2_switch_block_remove_mirror(struct dpaa2_switch_filter_block *block,\n\t\t\t\t struct dpaa2_switch_mirror_entry *entry)\n{\n\tstruct dpsw_reflection_cfg *cfg = &entry->cfg;\n\tunsigned long block_ports = block->ports;\n\tstruct ethsw_core *ethsw = block->ethsw;\n\tint port;\n\n\t \n\tfor_each_set_bit(port, &block_ports, ethsw->sw_attr.num_ifs)\n\t\tdpsw_if_remove_reflection(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t\t  port, cfg);\n\n\t \n\tlist_del(&entry->list);\n\tkfree(entry);\n\n\t \n\tif (list_empty(&block->mirror_entries))\n\t\tethsw->mirror_port =  ethsw->sw_attr.num_ifs;\n\n\treturn 0;\n}\n\nstatic int\ndpaa2_switch_cls_flower_replace_acl(struct dpaa2_switch_filter_block *block,\n\t\t\t\t    struct flow_cls_offload *cls)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(cls);\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct dpaa2_switch_acl_entry *acl_entry;\n\tstruct ethsw_core *ethsw = block->ethsw;\n\tstruct flow_action_entry *act;\n\tint err;\n\n\tif (dpaa2_switch_acl_tbl_is_full(block)) {\n\t\tNL_SET_ERR_MSG(extack, \"Maximum filter capacity reached\");\n\t\treturn -ENOMEM;\n\t}\n\n\tacl_entry = kzalloc(sizeof(*acl_entry), GFP_KERNEL);\n\tif (!acl_entry)\n\t\treturn -ENOMEM;\n\n\terr = dpaa2_switch_flower_parse_key(cls, &acl_entry->key);\n\tif (err)\n\t\tgoto free_acl_entry;\n\n\tact = &rule->action.entries[0];\n\terr = dpaa2_switch_tc_parse_action_acl(ethsw, act,\n\t\t\t\t\t       &acl_entry->cfg.result, extack);\n\tif (err)\n\t\tgoto free_acl_entry;\n\n\tacl_entry->prio = cls->common.prio;\n\tacl_entry->cookie = cls->cookie;\n\n\terr = dpaa2_switch_acl_tbl_add_entry(block, acl_entry);\n\tif (err)\n\t\tgoto free_acl_entry;\n\n\treturn 0;\n\nfree_acl_entry:\n\tkfree(acl_entry);\n\n\treturn err;\n}\n\nstatic int dpaa2_switch_flower_parse_mirror_key(struct flow_cls_offload *cls,\n\t\t\t\t\t\tu16 *vlan)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(cls);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tint ret = -EOPNOTSUPP;\n\n\tif (dissector->used_keys &\n\t    ~(BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_VLAN))) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Mirroring is supported only per VLAN\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tstruct flow_match_vlan match;\n\n\t\tflow_rule_match_vlan(rule, &match);\n\n\t\tif (match.mask->vlan_priority != 0 ||\n\t\t    match.mask->vlan_dei != 0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Only matching on VLAN ID supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (match.mask->vlan_id != 0xFFF) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Masked matching not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\t*vlan = (u16)match.key->vlan_id;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int\ndpaa2_switch_cls_flower_replace_mirror(struct dpaa2_switch_filter_block *block,\n\t\t\t\t       struct flow_cls_offload *cls)\n{\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct dpaa2_switch_mirror_entry *mirror_entry;\n\tstruct ethsw_core *ethsw = block->ethsw;\n\tstruct dpaa2_switch_mirror_entry *tmp;\n\tstruct flow_action_entry *cls_act;\n\tstruct list_head *pos, *n;\n\tbool mirror_port_enabled;\n\tu16 if_id, vlan;\n\tint err;\n\n\tmirror_port_enabled = (ethsw->mirror_port != ethsw->sw_attr.num_ifs);\n\tcls_act = &cls->rule->action.entries[0];\n\n\t \n\tif (!dpaa2_switch_port_dev_check(cls_act->dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Destination not a DPAA2 switch port\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif_id = dpaa2_switch_get_index(ethsw, cls_act->dev);\n\n\t \n\tif (mirror_port_enabled && ethsw->mirror_port != if_id) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Multiple mirror ports not supported\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\terr = dpaa2_switch_flower_parse_mirror_key(cls, &vlan);\n\tif (err)\n\t\treturn err;\n\n\t \n\tlist_for_each_safe(pos, n, &block->mirror_entries) {\n\t\ttmp = list_entry(pos, struct dpaa2_switch_mirror_entry, list);\n\n\t\tif (tmp->cfg.filter == DPSW_REFLECTION_FILTER_INGRESS_VLAN &&\n\t\t    tmp->cfg.vlan_id == vlan) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"VLAN mirror filter already installed\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tmirror_entry = kzalloc(sizeof(*mirror_entry), GFP_KERNEL);\n\tif (!mirror_entry)\n\t\treturn -ENOMEM;\n\n\tmirror_entry->cfg.filter = DPSW_REFLECTION_FILTER_INGRESS_VLAN;\n\tmirror_entry->cfg.vlan_id = vlan;\n\tmirror_entry->cookie = cls->cookie;\n\n\treturn dpaa2_switch_block_add_mirror(block, mirror_entry, if_id,\n\t\t\t\t\t     extack);\n}\n\nint dpaa2_switch_cls_flower_replace(struct dpaa2_switch_filter_block *block,\n\t\t\t\t    struct flow_cls_offload *cls)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(cls);\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct flow_action_entry *act;\n\n\tif (!flow_offload_has_one_action(&rule->action)) {\n\t\tNL_SET_ERR_MSG(extack, \"Only singular actions are supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tact = &rule->action.entries[0];\n\tswitch (act->id) {\n\tcase FLOW_ACTION_REDIRECT:\n\tcase FLOW_ACTION_TRAP:\n\tcase FLOW_ACTION_DROP:\n\t\treturn dpaa2_switch_cls_flower_replace_acl(block, cls);\n\tcase FLOW_ACTION_MIRRED:\n\t\treturn dpaa2_switch_cls_flower_replace_mirror(block, cls);\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Action not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint dpaa2_switch_cls_flower_destroy(struct dpaa2_switch_filter_block *block,\n\t\t\t\t    struct flow_cls_offload *cls)\n{\n\tstruct dpaa2_switch_mirror_entry *mirror_entry;\n\tstruct dpaa2_switch_acl_entry *acl_entry;\n\n\t \n\tacl_entry = dpaa2_switch_acl_tbl_find_entry_by_cookie(block,\n\t\t\t\t\t\t\t      cls->cookie);\n\tif (acl_entry)\n\t\treturn dpaa2_switch_acl_tbl_remove_entry(block, acl_entry);\n\n\t \n\tmirror_entry = dpaa2_switch_mirror_find_entry_by_cookie(block,\n\t\t\t\t\t\t\t\tcls->cookie);\n\tif (mirror_entry)\n\t\treturn dpaa2_switch_block_remove_mirror(block,\n\t\t\t\t\t\t\tmirror_entry);\n\n\treturn 0;\n}\n\nstatic int\ndpaa2_switch_cls_matchall_replace_acl(struct dpaa2_switch_filter_block *block,\n\t\t\t\t      struct tc_cls_matchall_offload *cls)\n{\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct ethsw_core *ethsw = block->ethsw;\n\tstruct dpaa2_switch_acl_entry *acl_entry;\n\tstruct flow_action_entry *act;\n\tint err;\n\n\tif (dpaa2_switch_acl_tbl_is_full(block)) {\n\t\tNL_SET_ERR_MSG(extack, \"Maximum filter capacity reached\");\n\t\treturn -ENOMEM;\n\t}\n\n\tacl_entry = kzalloc(sizeof(*acl_entry), GFP_KERNEL);\n\tif (!acl_entry)\n\t\treturn -ENOMEM;\n\n\tact = &cls->rule->action.entries[0];\n\terr = dpaa2_switch_tc_parse_action_acl(ethsw, act,\n\t\t\t\t\t       &acl_entry->cfg.result, extack);\n\tif (err)\n\t\tgoto free_acl_entry;\n\n\tacl_entry->prio = cls->common.prio;\n\tacl_entry->cookie = cls->cookie;\n\n\terr = dpaa2_switch_acl_tbl_add_entry(block, acl_entry);\n\tif (err)\n\t\tgoto free_acl_entry;\n\n\treturn 0;\n\nfree_acl_entry:\n\tkfree(acl_entry);\n\n\treturn err;\n}\n\nstatic int\ndpaa2_switch_cls_matchall_replace_mirror(struct dpaa2_switch_filter_block *block,\n\t\t\t\t\t struct tc_cls_matchall_offload *cls)\n{\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct dpaa2_switch_mirror_entry *mirror_entry;\n\tstruct ethsw_core *ethsw = block->ethsw;\n\tstruct dpaa2_switch_mirror_entry *tmp;\n\tstruct flow_action_entry *cls_act;\n\tstruct list_head *pos, *n;\n\tbool mirror_port_enabled;\n\tu16 if_id;\n\n\tmirror_port_enabled = (ethsw->mirror_port != ethsw->sw_attr.num_ifs);\n\tcls_act = &cls->rule->action.entries[0];\n\n\t \n\tif (!dpaa2_switch_port_dev_check(cls_act->dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Destination not a DPAA2 switch port\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif_id = dpaa2_switch_get_index(ethsw, cls_act->dev);\n\n\t \n\tif (mirror_port_enabled && ethsw->mirror_port != if_id) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Multiple mirror ports not supported\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tlist_for_each_safe(pos, n, &block->mirror_entries) {\n\t\ttmp = list_entry(pos, struct dpaa2_switch_mirror_entry, list);\n\n\t\tif (tmp->cfg.filter == DPSW_REFLECTION_FILTER_INGRESS_ALL) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Matchall mirror filter already installed\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tmirror_entry = kzalloc(sizeof(*mirror_entry), GFP_KERNEL);\n\tif (!mirror_entry)\n\t\treturn -ENOMEM;\n\n\tmirror_entry->cfg.filter = DPSW_REFLECTION_FILTER_INGRESS_ALL;\n\tmirror_entry->cookie = cls->cookie;\n\n\treturn dpaa2_switch_block_add_mirror(block, mirror_entry, if_id,\n\t\t\t\t\t     extack);\n}\n\nint dpaa2_switch_cls_matchall_replace(struct dpaa2_switch_filter_block *block,\n\t\t\t\t      struct tc_cls_matchall_offload *cls)\n{\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct flow_action_entry *act;\n\n\tif (!flow_offload_has_one_action(&cls->rule->action)) {\n\t\tNL_SET_ERR_MSG(extack, \"Only singular actions are supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tact = &cls->rule->action.entries[0];\n\tswitch (act->id) {\n\tcase FLOW_ACTION_REDIRECT:\n\tcase FLOW_ACTION_TRAP:\n\tcase FLOW_ACTION_DROP:\n\t\treturn dpaa2_switch_cls_matchall_replace_acl(block, cls);\n\tcase FLOW_ACTION_MIRRED:\n\t\treturn dpaa2_switch_cls_matchall_replace_mirror(block, cls);\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Action not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint dpaa2_switch_block_offload_mirror(struct dpaa2_switch_filter_block *block,\n\t\t\t\t      struct ethsw_port_priv *port_priv)\n{\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct dpaa2_switch_mirror_entry *tmp;\n\tint err;\n\n\tlist_for_each_entry(tmp, &block->mirror_entries, list) {\n\t\terr = dpsw_if_add_reflection(ethsw->mc_io, 0,\n\t\t\t\t\t     ethsw->dpsw_handle,\n\t\t\t\t\t     port_priv->idx, &tmp->cfg);\n\t\tif (err)\n\t\t\tgoto unwind_add;\n\t}\n\n\treturn 0;\n\nunwind_add:\n\tlist_for_each_entry(tmp, &block->mirror_entries, list)\n\t\tdpsw_if_remove_reflection(ethsw->mc_io, 0,\n\t\t\t\t\t  ethsw->dpsw_handle,\n\t\t\t\t\t  port_priv->idx, &tmp->cfg);\n\n\treturn err;\n}\n\nint dpaa2_switch_block_unoffload_mirror(struct dpaa2_switch_filter_block *block,\n\t\t\t\t\tstruct ethsw_port_priv *port_priv)\n{\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct dpaa2_switch_mirror_entry *tmp;\n\tint err;\n\n\tlist_for_each_entry(tmp, &block->mirror_entries, list) {\n\t\terr = dpsw_if_remove_reflection(ethsw->mc_io, 0,\n\t\t\t\t\t\tethsw->dpsw_handle,\n\t\t\t\t\t\tport_priv->idx, &tmp->cfg);\n\t\tif (err)\n\t\t\tgoto unwind_remove;\n\t}\n\n\treturn 0;\n\nunwind_remove:\n\tlist_for_each_entry(tmp, &block->mirror_entries, list)\n\t\tdpsw_if_add_reflection(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t       port_priv->idx, &tmp->cfg);\n\n\treturn err;\n}\n\nint dpaa2_switch_cls_matchall_destroy(struct dpaa2_switch_filter_block *block,\n\t\t\t\t      struct tc_cls_matchall_offload *cls)\n{\n\tstruct dpaa2_switch_mirror_entry *mirror_entry;\n\tstruct dpaa2_switch_acl_entry *acl_entry;\n\n\t \n\tacl_entry = dpaa2_switch_acl_tbl_find_entry_by_cookie(block,\n\t\t\t\t\t\t\t      cls->cookie);\n\tif (acl_entry)\n\t\treturn dpaa2_switch_acl_tbl_remove_entry(block,\n\t\t\t\t\t\t\t acl_entry);\n\n\t \n\tmirror_entry = dpaa2_switch_mirror_find_entry_by_cookie(block,\n\t\t\t\t\t\t\t\tcls->cookie);\n\tif (mirror_entry)\n\t\treturn dpaa2_switch_block_remove_mirror(block,\n\t\t\t\t\t\t\tmirror_entry);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}