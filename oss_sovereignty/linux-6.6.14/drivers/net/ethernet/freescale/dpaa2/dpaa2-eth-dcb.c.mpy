{
  "module_name": "dpaa2-eth-dcb.c",
  "hash_id": "3a9398e1fcda8fc9e02121478b646a2652683c20b4d1ec72a49f6ace60cc4b27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/dpaa2/dpaa2-eth-dcb.c",
  "human_readable_source": "\n \n\n#include \"dpaa2-eth.h\"\n\nstatic int dpaa2_eth_dcbnl_ieee_getpfc(struct net_device *net_dev,\n\t\t\t\t       struct ieee_pfc *pfc)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\n\tif (!(priv->link_state.options & DPNI_LINK_OPT_PFC_PAUSE))\n\t\treturn 0;\n\n\tmemcpy(pfc, &priv->pfc, sizeof(priv->pfc));\n\tpfc->pfc_cap = dpaa2_eth_tc_count(priv);\n\n\treturn 0;\n}\n\nstatic inline bool dpaa2_eth_is_prio_enabled(u8 pfc_en, u8 tc)\n{\n\treturn !!(pfc_en & (1 << tc));\n}\n\nstatic int dpaa2_eth_set_pfc_cn(struct dpaa2_eth_priv *priv, u8 pfc_en)\n{\n\tstruct dpni_congestion_notification_cfg cfg = {0};\n\tint i, err;\n\n\tcfg.notification_mode = DPNI_CONG_OPT_FLOW_CONTROL;\n\tcfg.units = DPNI_CONGESTION_UNIT_FRAMES;\n\tcfg.message_iova = 0ULL;\n\tcfg.message_ctx = 0ULL;\n\n\tfor (i = 0; i < dpaa2_eth_tc_count(priv); i++) {\n\t\tif (dpaa2_eth_is_prio_enabled(pfc_en, i)) {\n\t\t\tcfg.threshold_entry = DPAA2_ETH_CN_THRESH_ENTRY(priv);\n\t\t\tcfg.threshold_exit = DPAA2_ETH_CN_THRESH_EXIT(priv);\n\t\t} else {\n\t\t\t \n\t\t\tcfg.threshold_entry = 0;\n\t\t\tcfg.threshold_exit = 0;\n\t\t}\n\n\t\terr = dpni_set_congestion_notification(priv->mc_io, 0,\n\t\t\t\t\t\t       priv->mc_token,\n\t\t\t\t\t\t       DPNI_QUEUE_RX, i, &cfg);\n\t\tif (err) {\n\t\t\tnetdev_err(priv->net_dev,\n\t\t\t\t   \"dpni_set_congestion_notification failed\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dpaa2_eth_dcbnl_ieee_setpfc(struct net_device *net_dev,\n\t\t\t\t       struct ieee_pfc *pfc)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\tstruct dpni_link_cfg link_cfg = {0};\n\tbool tx_pause;\n\tint err;\n\n\tif (pfc->mbc || pfc->delay)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (priv->pfc.pfc_en == pfc->pfc_en)\n\t\treturn 0;\n\n\t \n\ttx_pause = dpaa2_eth_tx_pause_enabled(priv->link_state.options);\n\tif (!dpaa2_eth_rx_pause_enabled(priv->link_state.options) || !tx_pause)\n\t\tnetdev_warn(net_dev, \"Pause support must be enabled in order for PFC to work!\\n\");\n\n\tlink_cfg.rate = priv->link_state.rate;\n\tlink_cfg.options = priv->link_state.options;\n\tif (pfc->pfc_en)\n\t\tlink_cfg.options |= DPNI_LINK_OPT_PFC_PAUSE;\n\telse\n\t\tlink_cfg.options &= ~DPNI_LINK_OPT_PFC_PAUSE;\n\terr = dpni_set_link_cfg(priv->mc_io, 0, priv->mc_token, &link_cfg);\n\tif (err) {\n\t\tnetdev_err(net_dev, \"dpni_set_link_cfg failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = dpaa2_eth_set_pfc_cn(priv, pfc->pfc_en);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(&priv->pfc, pfc, sizeof(priv->pfc));\n\tpriv->pfc_enabled = !!pfc->pfc_en;\n\n\tdpaa2_eth_set_rx_taildrop(priv, tx_pause, priv->pfc_enabled);\n\n\treturn 0;\n}\n\nstatic u8 dpaa2_eth_dcbnl_getdcbx(struct net_device *net_dev)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\n\treturn priv->dcbx_mode;\n}\n\nstatic u8 dpaa2_eth_dcbnl_setdcbx(struct net_device *net_dev, u8 mode)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\n\treturn (mode != (priv->dcbx_mode)) ? 1 : 0;\n}\n\nstatic u8 dpaa2_eth_dcbnl_getcap(struct net_device *net_dev, int capid, u8 *cap)\n{\n\tstruct dpaa2_eth_priv *priv = netdev_priv(net_dev);\n\n\tswitch (capid) {\n\tcase DCB_CAP_ATTR_PFC:\n\t\t*cap = true;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_PFC_TCS:\n\t\t*cap = 1 << (dpaa2_eth_tc_count(priv) - 1);\n\t\tbreak;\n\tcase DCB_CAP_ATTR_DCBX:\n\t\t*cap = priv->dcbx_mode;\n\t\tbreak;\n\tdefault:\n\t\t*cap = false;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nconst struct dcbnl_rtnl_ops dpaa2_eth_dcbnl_ops = {\n\t.ieee_getpfc\t= dpaa2_eth_dcbnl_ieee_getpfc,\n\t.ieee_setpfc\t= dpaa2_eth_dcbnl_ieee_setpfc,\n\t.getdcbx\t= dpaa2_eth_dcbnl_getdcbx,\n\t.setdcbx\t= dpaa2_eth_dcbnl_setdcbx,\n\t.getcap\t\t= dpaa2_eth_dcbnl_getcap,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}