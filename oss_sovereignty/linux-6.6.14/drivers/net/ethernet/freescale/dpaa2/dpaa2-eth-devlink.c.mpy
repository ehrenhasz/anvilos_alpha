{
  "module_name": "dpaa2-eth-devlink.c",
  "hash_id": "94a4fd6c2047400d1def2895c16cb88a5a45778d04b10f93e75f46b72a30c673",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/dpaa2/dpaa2-eth-devlink.c",
  "human_readable_source": "\n#include \"dpaa2-eth.h\"\n \n\n#define DPAA2_ETH_TRAP_DROP(_id, _group_id)\t\t\t\t\t\\\n\tDEVLINK_TRAP_GENERIC(DROP, DROP, _id,\t\t\t\t\t\\\n\t\t\t     DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id, 0)\n\nstatic const struct devlink_trap_group dpaa2_eth_trap_groups_arr[] = {\n\tDEVLINK_TRAP_GROUP_GENERIC(PARSER_ERROR_DROPS, 0),\n};\n\nstatic const struct devlink_trap dpaa2_eth_traps_arr[] = {\n\tDPAA2_ETH_TRAP_DROP(VXLAN_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(LLC_SNAP_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(VLAN_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(PPPOE_PPP_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(MPLS_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(ARP_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(IP_1_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(IP_N_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(GRE_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(UDP_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(TCP_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(IPSEC_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(SCTP_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(DCCP_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(GTP_PARSING, PARSER_ERROR_DROPS),\n\tDPAA2_ETH_TRAP_DROP(ESP_PARSING, PARSER_ERROR_DROPS),\n};\n\nstatic int dpaa2_eth_dl_info_get(struct devlink *devlink,\n\t\t\t\t struct devlink_info_req *req,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct dpaa2_eth_devlink_priv *dl_priv = devlink_priv(devlink);\n\tstruct dpaa2_eth_priv *priv = dl_priv->dpaa2_priv;\n\tchar buf[10];\n\n\tscnprintf(buf, 10, \"%d.%d\", priv->dpni_ver_major, priv->dpni_ver_minor);\n\treturn devlink_info_version_running_put(req, \"dpni\", buf);\n}\n\nstatic struct dpaa2_eth_trap_item *\ndpaa2_eth_dl_trap_item_lookup(struct dpaa2_eth_priv *priv, u16 trap_id)\n{\n\tstruct dpaa2_eth_trap_data *dpaa2_eth_trap_data = priv->trap_data;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dpaa2_eth_traps_arr); i++) {\n\t\tif (dpaa2_eth_traps_arr[i].id == trap_id)\n\t\t\treturn &dpaa2_eth_trap_data->trap_items_arr[i];\n\t}\n\n\treturn NULL;\n}\n\nstruct dpaa2_eth_trap_item *dpaa2_eth_dl_get_trap(struct dpaa2_eth_priv *priv,\n\t\t\t\t\t\t  struct dpaa2_fapr *fapr)\n{\n\tstatic const struct dpaa2_faf_error_bit {\n\t\tint position;\n\t\tenum devlink_trap_generic_id trap_id;\n\t} faf_bits[] = {\n\t\t{ .position = 5,  .trap_id = DEVLINK_TRAP_GENERIC_ID_VXLAN_PARSING },\n\t\t{ .position = 20, .trap_id = DEVLINK_TRAP_GENERIC_ID_LLC_SNAP_PARSING },\n\t\t{ .position = 24, .trap_id = DEVLINK_TRAP_GENERIC_ID_VLAN_PARSING },\n\t\t{ .position = 26, .trap_id = DEVLINK_TRAP_GENERIC_ID_PPPOE_PPP_PARSING },\n\t\t{ .position = 29, .trap_id = DEVLINK_TRAP_GENERIC_ID_MPLS_PARSING },\n\t\t{ .position = 31, .trap_id = DEVLINK_TRAP_GENERIC_ID_ARP_PARSING },\n\t\t{ .position = 52, .trap_id = DEVLINK_TRAP_GENERIC_ID_IP_1_PARSING },\n\t\t{ .position = 61, .trap_id = DEVLINK_TRAP_GENERIC_ID_IP_N_PARSING },\n\t\t{ .position = 67, .trap_id = DEVLINK_TRAP_GENERIC_ID_GRE_PARSING },\n\t\t{ .position = 71, .trap_id = DEVLINK_TRAP_GENERIC_ID_UDP_PARSING },\n\t\t{ .position = 76, .trap_id = DEVLINK_TRAP_GENERIC_ID_TCP_PARSING },\n\t\t{ .position = 80, .trap_id = DEVLINK_TRAP_GENERIC_ID_IPSEC_PARSING },\n\t\t{ .position = 82, .trap_id = DEVLINK_TRAP_GENERIC_ID_SCTP_PARSING },\n\t\t{ .position = 84, .trap_id = DEVLINK_TRAP_GENERIC_ID_DCCP_PARSING },\n\t\t{ .position = 88, .trap_id = DEVLINK_TRAP_GENERIC_ID_GTP_PARSING },\n\t\t{ .position = 90, .trap_id = DEVLINK_TRAP_GENERIC_ID_ESP_PARSING },\n\t};\n\tu64 faf_word;\n\tu64 mask;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(faf_bits); i++) {\n\t\tif (faf_bits[i].position < 32) {\n\t\t\t \n\t\t\tmask = 1ull << (31 - faf_bits[i].position);\n\t\t\tfaf_word = __le32_to_cpu(fapr->faf_lo);\n\t\t} else {\n\t\t\t \n\t\t\tmask = 1ull << (63 - (faf_bits[i].position - 32));\n\t\t\tfaf_word = __le64_to_cpu(fapr->faf_hi);\n\t\t}\n\t\tif (faf_word & mask)\n\t\t\treturn dpaa2_eth_dl_trap_item_lookup(priv, faf_bits[i].trap_id);\n\t}\n\treturn NULL;\n}\n\nstatic int dpaa2_eth_dl_trap_init(struct devlink *devlink,\n\t\t\t\t  const struct devlink_trap *trap,\n\t\t\t\t  void *trap_ctx)\n{\n\tstruct dpaa2_eth_devlink_priv *dl_priv = devlink_priv(devlink);\n\tstruct dpaa2_eth_priv *priv = dl_priv->dpaa2_priv;\n\tstruct dpaa2_eth_trap_item *dpaa2_eth_trap_item;\n\n\tdpaa2_eth_trap_item = dpaa2_eth_dl_trap_item_lookup(priv, trap->id);\n\tif (WARN_ON(!dpaa2_eth_trap_item))\n\t\treturn -ENOENT;\n\n\tdpaa2_eth_trap_item->trap_ctx = trap_ctx;\n\n\treturn 0;\n}\n\nstatic int dpaa2_eth_dl_trap_action_set(struct devlink *devlink,\n\t\t\t\t\tconst struct devlink_trap *trap,\n\t\t\t\t\tenum devlink_trap_action action,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\t \n\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t   \"Cannot change trap action independently of group\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic int dpaa2_eth_dl_trap_group_action_set(struct devlink *devlink,\n\t\t\t\t\t      const struct devlink_trap_group *group,\n\t\t\t\t\t      enum devlink_trap_action action,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct dpaa2_eth_devlink_priv *dl_priv = devlink_priv(devlink);\n\tstruct dpaa2_eth_priv *priv = dl_priv->dpaa2_priv;\n\tstruct net_device *net_dev = priv->net_dev;\n\tstruct device *dev = net_dev->dev.parent;\n\tstruct dpni_error_cfg err_cfg = {0};\n\tint err;\n\n\tif (group->id != DEVLINK_TRAP_GROUP_GENERIC_ID_PARSER_ERROR_DROPS)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\terr_cfg.errors = DPAA2_FAS_RX_ERR_MASK;\n\terr_cfg.set_frame_annotation = 1;\n\n\tswitch (action) {\n\tcase DEVLINK_TRAP_ACTION_DROP:\n\t\terr_cfg.error_action = DPNI_ERROR_ACTION_DISCARD;\n\t\tbreak;\n\tcase DEVLINK_TRAP_ACTION_TRAP:\n\t\terr_cfg.error_action = DPNI_ERROR_ACTION_SEND_TO_ERROR_QUEUE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = dpni_set_errors_behavior(priv->mc_io, 0, priv->mc_token, &err_cfg);\n\tif (err) {\n\t\tdev_err(dev, \"dpni_set_errors_behavior failed\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct devlink_ops dpaa2_eth_devlink_ops = {\n\t.info_get = dpaa2_eth_dl_info_get,\n\t.trap_init = dpaa2_eth_dl_trap_init,\n\t.trap_action_set = dpaa2_eth_dl_trap_action_set,\n\t.trap_group_action_set = dpaa2_eth_dl_trap_group_action_set,\n};\n\nint dpaa2_eth_dl_alloc(struct dpaa2_eth_priv *priv)\n{\n\tstruct net_device *net_dev = priv->net_dev;\n\tstruct device *dev = net_dev->dev.parent;\n\tstruct dpaa2_eth_devlink_priv *dl_priv;\n\n\tpriv->devlink =\n\t\tdevlink_alloc(&dpaa2_eth_devlink_ops, sizeof(*dl_priv), dev);\n\tif (!priv->devlink) {\n\t\tdev_err(dev, \"devlink_alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdl_priv = devlink_priv(priv->devlink);\n\tdl_priv->dpaa2_priv = priv;\n\treturn 0;\n}\n\nvoid dpaa2_eth_dl_free(struct dpaa2_eth_priv *priv)\n{\n\tdevlink_free(priv->devlink);\n}\n\n\nvoid dpaa2_eth_dl_register(struct dpaa2_eth_priv *priv)\n{\n\tdevlink_register(priv->devlink);\n}\n\nvoid dpaa2_eth_dl_unregister(struct dpaa2_eth_priv *priv)\n{\n\tdevlink_unregister(priv->devlink);\n}\n\nint dpaa2_eth_dl_port_add(struct dpaa2_eth_priv *priv)\n{\n\tstruct devlink_port *devlink_port = &priv->devlink_port;\n\tstruct devlink_port_attrs attrs = {};\n\n\tattrs.flavour = DEVLINK_PORT_FLAVOUR_PHYSICAL;\n\tdevlink_port_attrs_set(devlink_port, &attrs);\n\treturn devlink_port_register(priv->devlink, devlink_port, 0);\n}\n\nvoid dpaa2_eth_dl_port_del(struct dpaa2_eth_priv *priv)\n{\n\tstruct devlink_port *devlink_port = &priv->devlink_port;\n\n\tdevlink_port_unregister(devlink_port);\n}\n\nint dpaa2_eth_dl_traps_register(struct dpaa2_eth_priv *priv)\n{\n\tstruct dpaa2_eth_trap_data *dpaa2_eth_trap_data;\n\tstruct net_device *net_dev = priv->net_dev;\n\tstruct device *dev = net_dev->dev.parent;\n\tint err;\n\n\tdpaa2_eth_trap_data = kzalloc(sizeof(*dpaa2_eth_trap_data), GFP_KERNEL);\n\tif (!dpaa2_eth_trap_data)\n\t\treturn -ENOMEM;\n\tpriv->trap_data = dpaa2_eth_trap_data;\n\n\tdpaa2_eth_trap_data->trap_items_arr = kcalloc(ARRAY_SIZE(dpaa2_eth_traps_arr),\n\t\t\t\t\t\t      sizeof(struct dpaa2_eth_trap_item),\n\t\t\t\t\t\t      GFP_KERNEL);\n\tif (!dpaa2_eth_trap_data->trap_items_arr) {\n\t\terr = -ENOMEM;\n\t\tgoto trap_data_free;\n\t}\n\n\terr = devlink_trap_groups_register(priv->devlink, dpaa2_eth_trap_groups_arr,\n\t\t\t\t\t   ARRAY_SIZE(dpaa2_eth_trap_groups_arr));\n\tif (err) {\n\t\tdev_err(dev, \"devlink_trap_groups_register() = %d\\n\", err);\n\t\tgoto trap_items_arr_free;\n\t}\n\n\terr = devlink_traps_register(priv->devlink, dpaa2_eth_traps_arr,\n\t\t\t\t     ARRAY_SIZE(dpaa2_eth_traps_arr), priv);\n\tif (err) {\n\t\tdev_err(dev, \"devlink_traps_register() = %d\\n\", err);\n\t\tgoto trap_groups_unregiser;\n\t}\n\n\treturn 0;\n\ntrap_groups_unregiser:\n\tdevlink_trap_groups_unregister(priv->devlink, dpaa2_eth_trap_groups_arr,\n\t\t\t\t       ARRAY_SIZE(dpaa2_eth_trap_groups_arr));\ntrap_items_arr_free:\n\tkfree(dpaa2_eth_trap_data->trap_items_arr);\ntrap_data_free:\n\tkfree(dpaa2_eth_trap_data);\n\tpriv->trap_data = NULL;\n\n\treturn err;\n}\n\nvoid dpaa2_eth_dl_traps_unregister(struct dpaa2_eth_priv *priv)\n{\n\tdevlink_traps_unregister(priv->devlink, dpaa2_eth_traps_arr,\n\t\t\t\t ARRAY_SIZE(dpaa2_eth_traps_arr));\n\tdevlink_trap_groups_unregister(priv->devlink, dpaa2_eth_trap_groups_arr,\n\t\t\t\t       ARRAY_SIZE(dpaa2_eth_trap_groups_arr));\n\tkfree(priv->trap_data->trap_items_arr);\n\tkfree(priv->trap_data);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}