{
  "module_name": "dpaa2-switch.c",
  "hash_id": "d99fdb9d2bd35f5dbc18100ab230d124982f2001a53aedf49a48700021bfc1ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/dpaa2/dpaa2-switch.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <linux/interrupt.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/iommu.h>\n#include <net/pkt_cls.h>\n\n#include <linux/fsl/mc.h>\n\n#include \"dpaa2-switch.h\"\n\n \n#define DPSW_MIN_VER_MAJOR\t\t8\n#define DPSW_MIN_VER_MINOR\t\t9\n\n#define DEFAULT_VLAN_ID\t\t\t1\n\nstatic u16 dpaa2_switch_port_get_fdb_id(struct ethsw_port_priv *port_priv)\n{\n\treturn port_priv->fdb->fdb_id;\n}\n\nstatic struct dpaa2_switch_fdb *dpaa2_switch_fdb_get_unused(struct ethsw_core *ethsw)\n{\n\tint i;\n\n\tfor (i = 0; i < ethsw->sw_attr.num_ifs; i++)\n\t\tif (!ethsw->fdbs[i].in_use)\n\t\t\treturn &ethsw->fdbs[i];\n\treturn NULL;\n}\n\nstatic struct dpaa2_switch_filter_block *\ndpaa2_switch_filter_block_get_unused(struct ethsw_core *ethsw)\n{\n\tint i;\n\n\tfor (i = 0; i < ethsw->sw_attr.num_ifs; i++)\n\t\tif (!ethsw->filter_blocks[i].in_use)\n\t\t\treturn &ethsw->filter_blocks[i];\n\treturn NULL;\n}\n\nstatic u16 dpaa2_switch_port_set_fdb(struct ethsw_port_priv *port_priv,\n\t\t\t\t     struct net_device *bridge_dev)\n{\n\tstruct ethsw_port_priv *other_port_priv = NULL;\n\tstruct dpaa2_switch_fdb *fdb;\n\tstruct net_device *other_dev;\n\tstruct list_head *iter;\n\n\t \n\tif (!bridge_dev) {\n\t\tfdb = dpaa2_switch_fdb_get_unused(port_priv->ethsw_data);\n\n\t\t \n\n\t\tif (!fdb) {\n\t\t\tport_priv->fdb->bridge_dev = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tport_priv->fdb = fdb;\n\t\tport_priv->fdb->in_use = true;\n\t\tport_priv->fdb->bridge_dev = NULL;\n\t\treturn 0;\n\t}\n\n\t \n\tASSERT_RTNL();\n\n\t \n\tnetdev_for_each_lower_dev(bridge_dev, other_dev, iter) {\n\t\tif (!dpaa2_switch_port_dev_check(other_dev))\n\t\t\tcontinue;\n\n\t\tif (other_dev == port_priv->netdev)\n\t\t\tcontinue;\n\n\t\tother_port_priv = netdev_priv(other_dev);\n\t\tbreak;\n\t}\n\n\t \n\tif (other_port_priv) {\n\t\t \n\t\tport_priv->fdb->in_use = false;\n\t\tport_priv->fdb->bridge_dev = NULL;\n\n\t\t \n\t\tport_priv->fdb = other_port_priv->fdb;\n\t}\n\n\t \n\tport_priv->fdb->bridge_dev = bridge_dev;\n\n\treturn 0;\n}\n\nstatic void dpaa2_switch_fdb_get_flood_cfg(struct ethsw_core *ethsw, u16 fdb_id,\n\t\t\t\t\t   enum dpsw_flood_type type,\n\t\t\t\t\t   struct dpsw_egress_flood_cfg *cfg)\n{\n\tint i = 0, j;\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\n\t \n\tfor (j = 0; j < ethsw->sw_attr.num_ifs; j++) {\n\t\tif (!ethsw->ports[j])\n\t\t\tcontinue;\n\t\tif (ethsw->ports[j]->fdb->fdb_id != fdb_id)\n\t\t\tcontinue;\n\n\t\tif (type == DPSW_BROADCAST && ethsw->ports[j]->bcast_flood)\n\t\t\tcfg->if_id[i++] = ethsw->ports[j]->idx;\n\t\telse if (type == DPSW_FLOODING && ethsw->ports[j]->ucast_flood)\n\t\t\tcfg->if_id[i++] = ethsw->ports[j]->idx;\n\t}\n\n\t \n\tcfg->if_id[i++] = ethsw->sw_attr.num_ifs;\n\n\tcfg->fdb_id = fdb_id;\n\tcfg->flood_type = type;\n\tcfg->num_ifs = i;\n}\n\nstatic int dpaa2_switch_fdb_set_egress_flood(struct ethsw_core *ethsw, u16 fdb_id)\n{\n\tstruct dpsw_egress_flood_cfg flood_cfg;\n\tint err;\n\n\t \n\tdpaa2_switch_fdb_get_flood_cfg(ethsw, fdb_id, DPSW_BROADCAST, &flood_cfg);\n\terr = dpsw_set_egress_flood(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t    &flood_cfg);\n\tif (err) {\n\t\tdev_err(ethsw->dev, \"dpsw_set_egress_flood() = %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tdpaa2_switch_fdb_get_flood_cfg(ethsw, fdb_id, DPSW_FLOODING, &flood_cfg);\n\terr = dpsw_set_egress_flood(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t    &flood_cfg);\n\tif (err) {\n\t\tdev_err(ethsw->dev, \"dpsw_set_egress_flood() = %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void *dpaa2_iova_to_virt(struct iommu_domain *domain,\n\t\t\t\tdma_addr_t iova_addr)\n{\n\tphys_addr_t phys_addr;\n\n\tphys_addr = domain ? iommu_iova_to_phys(domain, iova_addr) : iova_addr;\n\n\treturn phys_to_virt(phys_addr);\n}\n\nstatic int dpaa2_switch_add_vlan(struct ethsw_port_priv *port_priv, u16 vid)\n{\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct dpsw_vlan_cfg vcfg = {0};\n\tint err;\n\n\tvcfg.fdb_id = dpaa2_switch_port_get_fdb_id(port_priv);\n\terr = dpsw_vlan_add(ethsw->mc_io, 0,\n\t\t\t    ethsw->dpsw_handle, vid, &vcfg);\n\tif (err) {\n\t\tdev_err(ethsw->dev, \"dpsw_vlan_add err %d\\n\", err);\n\t\treturn err;\n\t}\n\tethsw->vlans[vid] = ETHSW_VLAN_MEMBER;\n\n\treturn 0;\n}\n\nstatic bool dpaa2_switch_port_is_up(struct ethsw_port_priv *port_priv)\n{\n\tstruct net_device *netdev = port_priv->netdev;\n\tstruct dpsw_link_state state;\n\tint err;\n\n\terr = dpsw_if_get_link_state(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t     port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t     port_priv->idx, &state);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dpsw_if_get_link_state() err %d\\n\", err);\n\t\treturn true;\n\t}\n\n\tWARN_ONCE(state.up > 1, \"Garbage read into link_state\");\n\n\treturn state.up ? true : false;\n}\n\nstatic int dpaa2_switch_port_set_pvid(struct ethsw_port_priv *port_priv, u16 pvid)\n{\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct net_device *netdev = port_priv->netdev;\n\tstruct dpsw_tci_cfg tci_cfg = { 0 };\n\tbool up;\n\tint err, ret;\n\n\terr = dpsw_if_get_tci(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t      port_priv->idx, &tci_cfg);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dpsw_if_get_tci err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttci_cfg.vlan_id = pvid;\n\n\t \n\tup = dpaa2_switch_port_is_up(port_priv);\n\tif (up) {\n\t\terr = dpsw_if_disable(ethsw->mc_io, 0,\n\t\t\t\t      ethsw->dpsw_handle,\n\t\t\t\t      port_priv->idx);\n\t\tif (err) {\n\t\t\tnetdev_err(netdev, \"dpsw_if_disable err %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = dpsw_if_set_tci(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t      port_priv->idx, &tci_cfg);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dpsw_if_set_tci err %d\\n\", err);\n\t\tgoto set_tci_error;\n\t}\n\n\t \n\tport_priv->vlans[port_priv->pvid] &= ~ETHSW_VLAN_PVID;\n\tport_priv->vlans[pvid] |= ETHSW_VLAN_PVID;\n\tport_priv->pvid = pvid;\n\nset_tci_error:\n\tif (up) {\n\t\tret = dpsw_if_enable(ethsw->mc_io, 0,\n\t\t\t\t     ethsw->dpsw_handle,\n\t\t\t\t     port_priv->idx);\n\t\tif (ret) {\n\t\t\tnetdev_err(netdev, \"dpsw_if_enable err %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int dpaa2_switch_port_add_vlan(struct ethsw_port_priv *port_priv,\n\t\t\t\t      u16 vid, u16 flags)\n{\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct net_device *netdev = port_priv->netdev;\n\tstruct dpsw_vlan_if_cfg vcfg = {0};\n\tint err;\n\n\tif (port_priv->vlans[vid]) {\n\t\tnetdev_warn(netdev, \"VLAN %d already configured\\n\", vid);\n\t\treturn -EEXIST;\n\t}\n\n\t \n\tvcfg.num_ifs = 1;\n\tvcfg.if_id[0] = port_priv->idx;\n\tvcfg.fdb_id = dpaa2_switch_port_get_fdb_id(port_priv);\n\tvcfg.options |= DPSW_VLAN_ADD_IF_OPT_FDB_ID;\n\terr = dpsw_vlan_add_if(ethsw->mc_io, 0, ethsw->dpsw_handle, vid, &vcfg);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dpsw_vlan_add_if err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tport_priv->vlans[vid] = ETHSW_VLAN_MEMBER;\n\n\tif (flags & BRIDGE_VLAN_INFO_UNTAGGED) {\n\t\terr = dpsw_vlan_add_if_untagged(ethsw->mc_io, 0,\n\t\t\t\t\t\tethsw->dpsw_handle,\n\t\t\t\t\t\tvid, &vcfg);\n\t\tif (err) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"dpsw_vlan_add_if_untagged err %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tport_priv->vlans[vid] |= ETHSW_VLAN_UNTAGGED;\n\t}\n\n\tif (flags & BRIDGE_VLAN_INFO_PVID) {\n\t\terr = dpaa2_switch_port_set_pvid(port_priv, vid);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic enum dpsw_stp_state br_stp_state_to_dpsw(u8 state)\n{\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\t\treturn DPSW_STP_STATE_DISABLED;\n\tcase BR_STATE_LISTENING:\n\t\treturn DPSW_STP_STATE_LISTENING;\n\tcase BR_STATE_LEARNING:\n\t\treturn DPSW_STP_STATE_LEARNING;\n\tcase BR_STATE_FORWARDING:\n\t\treturn DPSW_STP_STATE_FORWARDING;\n\tcase BR_STATE_BLOCKING:\n\t\treturn DPSW_STP_STATE_BLOCKING;\n\tdefault:\n\t\treturn DPSW_STP_STATE_DISABLED;\n\t}\n}\n\nstatic int dpaa2_switch_port_set_stp_state(struct ethsw_port_priv *port_priv, u8 state)\n{\n\tstruct dpsw_stp_cfg stp_cfg = {0};\n\tint err;\n\tu16 vid;\n\n\tif (!netif_running(port_priv->netdev) || state == port_priv->stp_state)\n\t\treturn 0;\t \n\n\tstp_cfg.state = br_stp_state_to_dpsw(state);\n\tfor (vid = 0; vid <= VLAN_VID_MASK; vid++) {\n\t\tif (port_priv->vlans[vid] & ETHSW_VLAN_MEMBER) {\n\t\t\tstp_cfg.vlan_id = vid;\n\t\t\terr = dpsw_if_set_stp(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t\t      port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t\t      port_priv->idx, &stp_cfg);\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(port_priv->netdev,\n\t\t\t\t\t   \"dpsw_if_set_stp err %d\\n\", err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\tport_priv->stp_state = state;\n\n\treturn 0;\n}\n\nstatic int dpaa2_switch_dellink(struct ethsw_core *ethsw, u16 vid)\n{\n\tstruct ethsw_port_priv *ppriv_local = NULL;\n\tint i, err;\n\n\tif (!ethsw->vlans[vid])\n\t\treturn -ENOENT;\n\n\terr = dpsw_vlan_remove(ethsw->mc_io, 0, ethsw->dpsw_handle, vid);\n\tif (err) {\n\t\tdev_err(ethsw->dev, \"dpsw_vlan_remove err %d\\n\", err);\n\t\treturn err;\n\t}\n\tethsw->vlans[vid] = 0;\n\n\tfor (i = 0; i < ethsw->sw_attr.num_ifs; i++) {\n\t\tppriv_local = ethsw->ports[i];\n\t\tif (ppriv_local)\n\t\t\tppriv_local->vlans[vid] = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int dpaa2_switch_port_fdb_add_uc(struct ethsw_port_priv *port_priv,\n\t\t\t\t\tconst unsigned char *addr)\n{\n\tstruct dpsw_fdb_unicast_cfg entry = {0};\n\tu16 fdb_id;\n\tint err;\n\n\tentry.if_egress = port_priv->idx;\n\tentry.type = DPSW_FDB_ENTRY_STATIC;\n\tether_addr_copy(entry.mac_addr, addr);\n\n\tfdb_id = dpaa2_switch_port_get_fdb_id(port_priv);\n\terr = dpsw_fdb_add_unicast(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t   port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t   fdb_id, &entry);\n\tif (err)\n\t\tnetdev_err(port_priv->netdev,\n\t\t\t   \"dpsw_fdb_add_unicast err %d\\n\", err);\n\treturn err;\n}\n\nstatic int dpaa2_switch_port_fdb_del_uc(struct ethsw_port_priv *port_priv,\n\t\t\t\t\tconst unsigned char *addr)\n{\n\tstruct dpsw_fdb_unicast_cfg entry = {0};\n\tu16 fdb_id;\n\tint err;\n\n\tentry.if_egress = port_priv->idx;\n\tentry.type = DPSW_FDB_ENTRY_STATIC;\n\tether_addr_copy(entry.mac_addr, addr);\n\n\tfdb_id = dpaa2_switch_port_get_fdb_id(port_priv);\n\terr = dpsw_fdb_remove_unicast(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t      port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t      fdb_id, &entry);\n\t \n\tif (err && err != -ENXIO)\n\t\tnetdev_err(port_priv->netdev,\n\t\t\t   \"dpsw_fdb_remove_unicast err %d\\n\", err);\n\treturn err;\n}\n\nstatic int dpaa2_switch_port_fdb_add_mc(struct ethsw_port_priv *port_priv,\n\t\t\t\t\tconst unsigned char *addr)\n{\n\tstruct dpsw_fdb_multicast_cfg entry = {0};\n\tu16 fdb_id;\n\tint err;\n\n\tether_addr_copy(entry.mac_addr, addr);\n\tentry.type = DPSW_FDB_ENTRY_STATIC;\n\tentry.num_ifs = 1;\n\tentry.if_id[0] = port_priv->idx;\n\n\tfdb_id = dpaa2_switch_port_get_fdb_id(port_priv);\n\terr = dpsw_fdb_add_multicast(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t     port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t     fdb_id, &entry);\n\t \n\tif (err && err != -ENXIO)\n\t\tnetdev_err(port_priv->netdev, \"dpsw_fdb_add_multicast err %d\\n\",\n\t\t\t   err);\n\treturn err;\n}\n\nstatic int dpaa2_switch_port_fdb_del_mc(struct ethsw_port_priv *port_priv,\n\t\t\t\t\tconst unsigned char *addr)\n{\n\tstruct dpsw_fdb_multicast_cfg entry = {0};\n\tu16 fdb_id;\n\tint err;\n\n\tether_addr_copy(entry.mac_addr, addr);\n\tentry.type = DPSW_FDB_ENTRY_STATIC;\n\tentry.num_ifs = 1;\n\tentry.if_id[0] = port_priv->idx;\n\n\tfdb_id = dpaa2_switch_port_get_fdb_id(port_priv);\n\terr = dpsw_fdb_remove_multicast(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t\tport_priv->ethsw_data->dpsw_handle,\n\t\t\t\t\tfdb_id, &entry);\n\t \n\tif (err && err != -ENAVAIL)\n\t\tnetdev_err(port_priv->netdev,\n\t\t\t   \"dpsw_fdb_remove_multicast err %d\\n\", err);\n\treturn err;\n}\n\nstatic void dpaa2_switch_port_get_stats(struct net_device *netdev,\n\t\t\t\t\tstruct rtnl_link_stats64 *stats)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tu64 tmp;\n\tint err;\n\n\terr = dpsw_if_get_counter(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t  port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t  port_priv->idx,\n\t\t\t\t  DPSW_CNT_ING_FRAME, &stats->rx_packets);\n\tif (err)\n\t\tgoto error;\n\n\terr = dpsw_if_get_counter(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t  port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t  port_priv->idx,\n\t\t\t\t  DPSW_CNT_EGR_FRAME, &stats->tx_packets);\n\tif (err)\n\t\tgoto error;\n\n\terr = dpsw_if_get_counter(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t  port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t  port_priv->idx,\n\t\t\t\t  DPSW_CNT_ING_BYTE, &stats->rx_bytes);\n\tif (err)\n\t\tgoto error;\n\n\terr = dpsw_if_get_counter(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t  port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t  port_priv->idx,\n\t\t\t\t  DPSW_CNT_EGR_BYTE, &stats->tx_bytes);\n\tif (err)\n\t\tgoto error;\n\n\terr = dpsw_if_get_counter(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t  port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t  port_priv->idx,\n\t\t\t\t  DPSW_CNT_ING_FRAME_DISCARD,\n\t\t\t\t  &stats->rx_dropped);\n\tif (err)\n\t\tgoto error;\n\n\terr = dpsw_if_get_counter(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t  port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t  port_priv->idx,\n\t\t\t\t  DPSW_CNT_ING_FLTR_FRAME,\n\t\t\t\t  &tmp);\n\tif (err)\n\t\tgoto error;\n\tstats->rx_dropped += tmp;\n\n\terr = dpsw_if_get_counter(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t  port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t  port_priv->idx,\n\t\t\t\t  DPSW_CNT_EGR_FRAME_DISCARD,\n\t\t\t\t  &stats->tx_dropped);\n\tif (err)\n\t\tgoto error;\n\n\treturn;\n\nerror:\n\tnetdev_err(netdev, \"dpsw_if_get_counter err %d\\n\", err);\n}\n\nstatic bool dpaa2_switch_port_has_offload_stats(const struct net_device *netdev,\n\t\t\t\t\t\tint attr_id)\n{\n\treturn (attr_id == IFLA_OFFLOAD_XSTATS_CPU_HIT);\n}\n\nstatic int dpaa2_switch_port_get_offload_stats(int attr_id,\n\t\t\t\t\t       const struct net_device *netdev,\n\t\t\t\t\t       void *sp)\n{\n\tswitch (attr_id) {\n\tcase IFLA_OFFLOAD_XSTATS_CPU_HIT:\n\t\tdpaa2_switch_port_get_stats((struct net_device *)netdev, sp);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int dpaa2_switch_port_change_mtu(struct net_device *netdev, int mtu)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tint err;\n\n\terr = dpsw_if_set_max_frame_length(port_priv->ethsw_data->mc_io,\n\t\t\t\t\t   0,\n\t\t\t\t\t   port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t\t   port_priv->idx,\n\t\t\t\t\t   (u16)ETHSW_L2_MAX_FRM(mtu));\n\tif (err) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"dpsw_if_set_max_frame_length() err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tnetdev->mtu = mtu;\n\treturn 0;\n}\n\nstatic int dpaa2_switch_port_link_state_update(struct net_device *netdev)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tstruct dpsw_link_state state;\n\tint err;\n\n\t \n\tif (dpaa2_mac_is_type_phy(port_priv->mac))\n\t\treturn 0;\n\n\t \n\tif (!netif_running(netdev))\n\t\treturn 0;\n\n\terr = dpsw_if_get_link_state(port_priv->ethsw_data->mc_io, 0,\n\t\t\t\t     port_priv->ethsw_data->dpsw_handle,\n\t\t\t\t     port_priv->idx, &state);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dpsw_if_get_link_state() err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tWARN_ONCE(state.up > 1, \"Garbage read into link_state\");\n\n\tif (state.up != port_priv->link_state) {\n\t\tif (state.up) {\n\t\t\tnetif_carrier_on(netdev);\n\t\t\tnetif_tx_start_all_queues(netdev);\n\t\t} else {\n\t\t\tnetif_carrier_off(netdev);\n\t\t\tnetif_tx_stop_all_queues(netdev);\n\t\t}\n\t\tport_priv->link_state = state.up;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void dpaa2_switch_enable_ctrl_if_napi(struct ethsw_core *ethsw)\n{\n\tint i;\n\n\t \n\tASSERT_RTNL();\n\n\t \n\tethsw->napi_users++;\n\n\t \n\tif (ethsw->napi_users > 1)\n\t\treturn;\n\n\tfor (i = 0; i < DPAA2_SWITCH_RX_NUM_FQS; i++)\n\t\tnapi_enable(&ethsw->fq[i].napi);\n}\n\nstatic void dpaa2_switch_disable_ctrl_if_napi(struct ethsw_core *ethsw)\n{\n\tint i;\n\n\t \n\tASSERT_RTNL();\n\n\t \n\tethsw->napi_users--;\n\tif (ethsw->napi_users)\n\t\treturn;\n\n\tfor (i = 0; i < DPAA2_SWITCH_RX_NUM_FQS; i++)\n\t\tnapi_disable(&ethsw->fq[i].napi);\n}\n\nstatic int dpaa2_switch_port_open(struct net_device *netdev)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tint err;\n\n\tmutex_lock(&port_priv->mac_lock);\n\n\tif (!dpaa2_switch_port_is_type_phy(port_priv)) {\n\t\t \n\t\tnetif_carrier_off(netdev);\n\t}\n\n\terr = dpsw_if_enable(port_priv->ethsw_data->mc_io, 0,\n\t\t\t     port_priv->ethsw_data->dpsw_handle,\n\t\t\t     port_priv->idx);\n\tif (err) {\n\t\tmutex_unlock(&port_priv->mac_lock);\n\t\tnetdev_err(netdev, \"dpsw_if_enable err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tdpaa2_switch_enable_ctrl_if_napi(ethsw);\n\n\tif (dpaa2_switch_port_is_type_phy(port_priv))\n\t\tdpaa2_mac_start(port_priv->mac);\n\n\tmutex_unlock(&port_priv->mac_lock);\n\n\treturn 0;\n}\n\nstatic int dpaa2_switch_port_stop(struct net_device *netdev)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tint err;\n\n\tmutex_lock(&port_priv->mac_lock);\n\n\tif (dpaa2_switch_port_is_type_phy(port_priv)) {\n\t\tdpaa2_mac_stop(port_priv->mac);\n\t} else {\n\t\tnetif_tx_stop_all_queues(netdev);\n\t\tnetif_carrier_off(netdev);\n\t}\n\n\tmutex_unlock(&port_priv->mac_lock);\n\n\terr = dpsw_if_disable(port_priv->ethsw_data->mc_io, 0,\n\t\t\t      port_priv->ethsw_data->dpsw_handle,\n\t\t\t      port_priv->idx);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dpsw_if_disable err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tdpaa2_switch_disable_ctrl_if_napi(ethsw);\n\n\treturn 0;\n}\n\nstatic int dpaa2_switch_port_parent_id(struct net_device *dev,\n\t\t\t\t       struct netdev_phys_item_id *ppid)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(dev);\n\n\tppid->id_len = 1;\n\tppid->id[0] = port_priv->ethsw_data->dev_id;\n\n\treturn 0;\n}\n\nstatic int dpaa2_switch_port_get_phys_name(struct net_device *netdev, char *name,\n\t\t\t\t\t   size_t len)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tint err;\n\n\terr = snprintf(name, len, \"p%d\", port_priv->idx);\n\tif (err >= len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstruct ethsw_dump_ctx {\n\tstruct net_device *dev;\n\tstruct sk_buff *skb;\n\tstruct netlink_callback *cb;\n\tint idx;\n};\n\nstatic int dpaa2_switch_fdb_dump_nl(struct fdb_dump_entry *entry,\n\t\t\t\t    struct ethsw_dump_ctx *dump)\n{\n\tint is_dynamic = entry->type & DPSW_FDB_ENTRY_DINAMIC;\n\tu32 portid = NETLINK_CB(dump->cb->skb).portid;\n\tu32 seq = dump->cb->nlh->nlmsg_seq;\n\tstruct nlmsghdr *nlh;\n\tstruct ndmsg *ndm;\n\n\tif (dump->idx < dump->cb->args[2])\n\t\tgoto skip;\n\n\tnlh = nlmsg_put(dump->skb, portid, seq, RTM_NEWNEIGH,\n\t\t\tsizeof(*ndm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tndm = nlmsg_data(nlh);\n\tndm->ndm_family  = AF_BRIDGE;\n\tndm->ndm_pad1    = 0;\n\tndm->ndm_pad2    = 0;\n\tndm->ndm_flags   = NTF_SELF;\n\tndm->ndm_type    = 0;\n\tndm->ndm_ifindex = dump->dev->ifindex;\n\tndm->ndm_state   = is_dynamic ? NUD_REACHABLE : NUD_NOARP;\n\n\tif (nla_put(dump->skb, NDA_LLADDR, ETH_ALEN, entry->mac_addr))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(dump->skb, nlh);\n\nskip:\n\tdump->idx++;\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(dump->skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int dpaa2_switch_port_fdb_valid_entry(struct fdb_dump_entry *entry,\n\t\t\t\t\t     struct ethsw_port_priv *port_priv)\n{\n\tint idx = port_priv->idx;\n\tint valid;\n\n\tif (entry->type & DPSW_FDB_ENTRY_TYPE_UNICAST)\n\t\tvalid = entry->if_info == port_priv->idx;\n\telse\n\t\tvalid = entry->if_mask[idx / 8] & BIT(idx % 8);\n\n\treturn valid;\n}\n\nstatic int dpaa2_switch_fdb_iterate(struct ethsw_port_priv *port_priv,\n\t\t\t\t    dpaa2_switch_fdb_cb_t cb, void *data)\n{\n\tstruct net_device *net_dev = port_priv->netdev;\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct device *dev = net_dev->dev.parent;\n\tstruct fdb_dump_entry *fdb_entries;\n\tstruct fdb_dump_entry fdb_entry;\n\tdma_addr_t fdb_dump_iova;\n\tu16 num_fdb_entries;\n\tu32 fdb_dump_size;\n\tint err = 0, i;\n\tu8 *dma_mem;\n\tu16 fdb_id;\n\n\tfdb_dump_size = ethsw->sw_attr.max_fdb_entries * sizeof(fdb_entry);\n\tdma_mem = kzalloc(fdb_dump_size, GFP_KERNEL);\n\tif (!dma_mem)\n\t\treturn -ENOMEM;\n\n\tfdb_dump_iova = dma_map_single(dev, dma_mem, fdb_dump_size,\n\t\t\t\t       DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, fdb_dump_iova)) {\n\t\tnetdev_err(net_dev, \"dma_map_single() failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_map;\n\t}\n\n\tfdb_id = dpaa2_switch_port_get_fdb_id(port_priv);\n\terr = dpsw_fdb_dump(ethsw->mc_io, 0, ethsw->dpsw_handle, fdb_id,\n\t\t\t    fdb_dump_iova, fdb_dump_size, &num_fdb_entries);\n\tif (err) {\n\t\tnetdev_err(net_dev, \"dpsw_fdb_dump() = %d\\n\", err);\n\t\tgoto err_dump;\n\t}\n\n\tdma_unmap_single(dev, fdb_dump_iova, fdb_dump_size, DMA_FROM_DEVICE);\n\n\tfdb_entries = (struct fdb_dump_entry *)dma_mem;\n\tfor (i = 0; i < num_fdb_entries; i++) {\n\t\tfdb_entry = fdb_entries[i];\n\n\t\terr = cb(port_priv, &fdb_entry, data);\n\t\tif (err)\n\t\t\tgoto end;\n\t}\n\nend:\n\tkfree(dma_mem);\n\n\treturn 0;\n\nerr_dump:\n\tdma_unmap_single(dev, fdb_dump_iova, fdb_dump_size, DMA_TO_DEVICE);\nerr_map:\n\tkfree(dma_mem);\n\treturn err;\n}\n\nstatic int dpaa2_switch_fdb_entry_dump(struct ethsw_port_priv *port_priv,\n\t\t\t\t       struct fdb_dump_entry *fdb_entry,\n\t\t\t\t       void *data)\n{\n\tif (!dpaa2_switch_port_fdb_valid_entry(fdb_entry, port_priv))\n\t\treturn 0;\n\n\treturn dpaa2_switch_fdb_dump_nl(fdb_entry, data);\n}\n\nstatic int dpaa2_switch_port_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t\t      struct net_device *net_dev,\n\t\t\t\t      struct net_device *filter_dev, int *idx)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(net_dev);\n\tstruct ethsw_dump_ctx dump = {\n\t\t.dev = net_dev,\n\t\t.skb = skb,\n\t\t.cb = cb,\n\t\t.idx = *idx,\n\t};\n\tint err;\n\n\terr = dpaa2_switch_fdb_iterate(port_priv, dpaa2_switch_fdb_entry_dump, &dump);\n\t*idx = dump.idx;\n\n\treturn err;\n}\n\nstatic int dpaa2_switch_fdb_entry_fast_age(struct ethsw_port_priv *port_priv,\n\t\t\t\t\t   struct fdb_dump_entry *fdb_entry,\n\t\t\t\t\t   void *data __always_unused)\n{\n\tif (!dpaa2_switch_port_fdb_valid_entry(fdb_entry, port_priv))\n\t\treturn 0;\n\n\tif (!(fdb_entry->type & DPSW_FDB_ENTRY_TYPE_DYNAMIC))\n\t\treturn 0;\n\n\tif (fdb_entry->type & DPSW_FDB_ENTRY_TYPE_UNICAST)\n\t\tdpaa2_switch_port_fdb_del_uc(port_priv, fdb_entry->mac_addr);\n\telse\n\t\tdpaa2_switch_port_fdb_del_mc(port_priv, fdb_entry->mac_addr);\n\n\treturn 0;\n}\n\nstatic void dpaa2_switch_port_fast_age(struct ethsw_port_priv *port_priv)\n{\n\tdpaa2_switch_fdb_iterate(port_priv,\n\t\t\t\t dpaa2_switch_fdb_entry_fast_age, NULL);\n}\n\nstatic int dpaa2_switch_port_vlan_add(struct net_device *netdev, __be16 proto,\n\t\t\t\t      u16 vid)\n{\n\tstruct switchdev_obj_port_vlan vlan = {\n\t\t.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,\n\t\t.vid = vid,\n\t\t.obj.orig_dev = netdev,\n\t\t \n\t\t.flags = 0,\n\t};\n\n\treturn dpaa2_switch_port_vlans_add(netdev, &vlan);\n}\n\nstatic int dpaa2_switch_port_vlan_kill(struct net_device *netdev, __be16 proto,\n\t\t\t\t       u16 vid)\n{\n\tstruct switchdev_obj_port_vlan vlan = {\n\t\t.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,\n\t\t.vid = vid,\n\t\t.obj.orig_dev = netdev,\n\t\t \n\t\t.flags = 0,\n\t};\n\n\treturn dpaa2_switch_port_vlans_del(netdev, &vlan);\n}\n\nstatic int dpaa2_switch_port_set_mac_addr(struct ethsw_port_priv *port_priv)\n{\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct net_device *net_dev = port_priv->netdev;\n\tstruct device *dev = net_dev->dev.parent;\n\tu8 mac_addr[ETH_ALEN];\n\tint err;\n\n\tif (!(ethsw->features & ETHSW_FEATURE_MAC_ADDR))\n\t\treturn 0;\n\n\t \n\terr = dpsw_if_get_port_mac_addr(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t\tport_priv->idx, mac_addr);\n\tif (err) {\n\t\tdev_err(dev, \"dpsw_if_get_port_mac_addr() failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (!is_zero_ether_addr(mac_addr)) {\n\t\teth_hw_addr_set(net_dev, mac_addr);\n\t} else {\n\t\t \n\t\teth_hw_addr_random(net_dev);\n\t\tdev_dbg_once(dev, \"device(s) have all-zero hwaddr, replaced with random\\n\");\n\n\t\t \n\t\tnet_dev->addr_assign_type = NET_ADDR_PERM;\n\t}\n\n\treturn 0;\n}\n\nstatic void dpaa2_switch_free_fd(const struct ethsw_core *ethsw,\n\t\t\t\t const struct dpaa2_fd *fd)\n{\n\tstruct device *dev = ethsw->dev;\n\tunsigned char *buffer_start;\n\tstruct sk_buff **skbh, *skb;\n\tdma_addr_t fd_addr;\n\n\tfd_addr = dpaa2_fd_get_addr(fd);\n\tskbh = dpaa2_iova_to_virt(ethsw->iommu_domain, fd_addr);\n\n\tskb = *skbh;\n\tbuffer_start = (unsigned char *)skbh;\n\n\tdma_unmap_single(dev, fd_addr,\n\t\t\t skb_tail_pointer(skb) - buffer_start,\n\t\t\t DMA_TO_DEVICE);\n\n\t \n\tdev_kfree_skb(skb);\n}\n\nstatic int dpaa2_switch_build_single_fd(struct ethsw_core *ethsw,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tstruct dpaa2_fd *fd)\n{\n\tstruct device *dev = ethsw->dev;\n\tstruct sk_buff **skbh;\n\tdma_addr_t addr;\n\tu8 *buff_start;\n\tvoid *hwa;\n\n\tbuff_start = PTR_ALIGN(skb->data - DPAA2_SWITCH_TX_DATA_OFFSET -\n\t\t\t       DPAA2_SWITCH_TX_BUF_ALIGN,\n\t\t\t       DPAA2_SWITCH_TX_BUF_ALIGN);\n\n\t \n\thwa = buff_start + DPAA2_SWITCH_SWA_SIZE;\n\tmemset(hwa, 0, 8);\n\n\t \n\tskbh = (struct sk_buff **)buff_start;\n\t*skbh = skb;\n\n\taddr = dma_map_single(dev, buff_start,\n\t\t\t      skb_tail_pointer(skb) - buff_start,\n\t\t\t      DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(dev, addr)))\n\t\treturn -ENOMEM;\n\n\t \n\tmemset(fd, 0, sizeof(*fd));\n\n\tdpaa2_fd_set_addr(fd, addr);\n\tdpaa2_fd_set_offset(fd, (u16)(skb->data - buff_start));\n\tdpaa2_fd_set_len(fd, skb->len);\n\tdpaa2_fd_set_format(fd, dpaa2_fd_single);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t dpaa2_switch_port_tx(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *net_dev)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(net_dev);\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tint retries = DPAA2_SWITCH_SWP_BUSY_RETRIES;\n\tstruct dpaa2_fd fd;\n\tint err;\n\n\tif (unlikely(skb_headroom(skb) < DPAA2_SWITCH_NEEDED_HEADROOM)) {\n\t\tstruct sk_buff *ns;\n\n\t\tns = skb_realloc_headroom(skb, DPAA2_SWITCH_NEEDED_HEADROOM);\n\t\tif (unlikely(!ns)) {\n\t\t\tnet_err_ratelimited(\"%s: Error reallocating skb headroom\\n\", net_dev->name);\n\t\t\tgoto err_free_skb;\n\t\t}\n\t\tdev_consume_skb_any(skb);\n\t\tskb = ns;\n\t}\n\n\t \n\tskb = skb_unshare(skb, GFP_ATOMIC);\n\tif (unlikely(!skb)) {\n\t\t \n\t\tnet_err_ratelimited(\"%s: Error copying the socket buffer\\n\", net_dev->name);\n\t\tgoto err_exit;\n\t}\n\n\t \n\terr = skb_linearize(skb);\n\tif (err) {\n\t\tnet_err_ratelimited(\"%s: skb_linearize error (%d)!\\n\", net_dev->name, err);\n\t\tgoto err_free_skb;\n\t}\n\n\terr = dpaa2_switch_build_single_fd(ethsw, skb, &fd);\n\tif (unlikely(err)) {\n\t\tnet_err_ratelimited(\"%s: ethsw_build_*_fd() %d\\n\", net_dev->name, err);\n\t\tgoto err_free_skb;\n\t}\n\n\tdo {\n\t\terr = dpaa2_io_service_enqueue_qd(NULL,\n\t\t\t\t\t\t  port_priv->tx_qdid,\n\t\t\t\t\t\t  8, 0, &fd);\n\t\tretries--;\n\t} while (err == -EBUSY && retries);\n\n\tif (unlikely(err < 0)) {\n\t\tdpaa2_switch_free_fd(ethsw, &fd);\n\t\tgoto err_exit;\n\t}\n\n\treturn NETDEV_TX_OK;\n\nerr_free_skb:\n\tdev_kfree_skb(skb);\nerr_exit:\n\treturn NETDEV_TX_OK;\n}\n\nstatic int\ndpaa2_switch_setup_tc_cls_flower(struct dpaa2_switch_filter_block *filter_block,\n\t\t\t\t struct flow_cls_offload *f)\n{\n\tswitch (f->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn dpaa2_switch_cls_flower_replace(filter_block, f);\n\tcase FLOW_CLS_DESTROY:\n\t\treturn dpaa2_switch_cls_flower_destroy(filter_block, f);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\ndpaa2_switch_setup_tc_cls_matchall(struct dpaa2_switch_filter_block *block,\n\t\t\t\t   struct tc_cls_matchall_offload *f)\n{\n\tswitch (f->command) {\n\tcase TC_CLSMATCHALL_REPLACE:\n\t\treturn dpaa2_switch_cls_matchall_replace(block, f);\n\tcase TC_CLSMATCHALL_DESTROY:\n\t\treturn dpaa2_switch_cls_matchall_destroy(block, f);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int dpaa2_switch_port_setup_tc_block_cb_ig(enum tc_setup_type type,\n\t\t\t\t\t\t  void *type_data,\n\t\t\t\t\t\t  void *cb_priv)\n{\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn dpaa2_switch_setup_tc_cls_flower(cb_priv, type_data);\n\tcase TC_SETUP_CLSMATCHALL:\n\t\treturn dpaa2_switch_setup_tc_cls_matchall(cb_priv, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic LIST_HEAD(dpaa2_switch_block_cb_list);\n\nstatic int\ndpaa2_switch_port_acl_tbl_bind(struct ethsw_port_priv *port_priv,\n\t\t\t       struct dpaa2_switch_filter_block *block)\n{\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct net_device *netdev = port_priv->netdev;\n\tstruct dpsw_acl_if_cfg acl_if_cfg;\n\tint err;\n\n\tif (port_priv->filter_block)\n\t\treturn -EINVAL;\n\n\tacl_if_cfg.if_id[0] = port_priv->idx;\n\tacl_if_cfg.num_ifs = 1;\n\terr = dpsw_acl_add_if(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t      block->acl_id, &acl_if_cfg);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dpsw_acl_add_if err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tblock->ports |= BIT(port_priv->idx);\n\tport_priv->filter_block = block;\n\n\treturn 0;\n}\n\nstatic int\ndpaa2_switch_port_acl_tbl_unbind(struct ethsw_port_priv *port_priv,\n\t\t\t\t struct dpaa2_switch_filter_block *block)\n{\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct net_device *netdev = port_priv->netdev;\n\tstruct dpsw_acl_if_cfg acl_if_cfg;\n\tint err;\n\n\tif (port_priv->filter_block != block)\n\t\treturn -EINVAL;\n\n\tacl_if_cfg.if_id[0] = port_priv->idx;\n\tacl_if_cfg.num_ifs = 1;\n\terr = dpsw_acl_remove_if(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t block->acl_id, &acl_if_cfg);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dpsw_acl_add_if err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tblock->ports &= ~BIT(port_priv->idx);\n\tport_priv->filter_block = NULL;\n\treturn 0;\n}\n\nstatic int dpaa2_switch_port_block_bind(struct ethsw_port_priv *port_priv,\n\t\t\t\t\tstruct dpaa2_switch_filter_block *block)\n{\n\tstruct dpaa2_switch_filter_block *old_block = port_priv->filter_block;\n\tint err;\n\n\t \n\terr = dpaa2_switch_block_offload_mirror(block, port_priv);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (port_priv->filter_block == block)\n\t\treturn 0;\n\n\terr = dpaa2_switch_port_acl_tbl_unbind(port_priv, old_block);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (old_block->ports == 0)\n\t\told_block->in_use = false;\n\n\treturn dpaa2_switch_port_acl_tbl_bind(port_priv, block);\n}\n\nstatic int\ndpaa2_switch_port_block_unbind(struct ethsw_port_priv *port_priv,\n\t\t\t       struct dpaa2_switch_filter_block *block)\n{\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct dpaa2_switch_filter_block *new_block;\n\tint err;\n\n\t \n\terr = dpaa2_switch_block_unoffload_mirror(block, port_priv);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (block->ports == BIT(port_priv->idx))\n\t\treturn 0;\n\n\terr = dpaa2_switch_port_acl_tbl_unbind(port_priv, block);\n\tif (err)\n\t\treturn err;\n\n\tif (block->ports == 0)\n\t\tblock->in_use = false;\n\n\tnew_block = dpaa2_switch_filter_block_get_unused(ethsw);\n\tnew_block->in_use = true;\n\treturn dpaa2_switch_port_acl_tbl_bind(port_priv, new_block);\n}\n\nstatic int dpaa2_switch_setup_tc_block_bind(struct net_device *netdev,\n\t\t\t\t\t    struct flow_block_offload *f)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct dpaa2_switch_filter_block *filter_block;\n\tstruct flow_block_cb *block_cb;\n\tbool register_block = false;\n\tint err;\n\n\tblock_cb = flow_block_cb_lookup(f->block,\n\t\t\t\t\tdpaa2_switch_port_setup_tc_block_cb_ig,\n\t\t\t\t\tethsw);\n\n\tif (!block_cb) {\n\t\t \n\t\tfilter_block = port_priv->filter_block;\n\n\t\tblock_cb = flow_block_cb_alloc(dpaa2_switch_port_setup_tc_block_cb_ig,\n\t\t\t\t\t       ethsw, filter_block, NULL);\n\t\tif (IS_ERR(block_cb))\n\t\t\treturn PTR_ERR(block_cb);\n\n\t\tregister_block = true;\n\t} else {\n\t\tfilter_block = flow_block_cb_priv(block_cb);\n\t}\n\n\tflow_block_cb_incref(block_cb);\n\terr = dpaa2_switch_port_block_bind(port_priv, filter_block);\n\tif (err)\n\t\tgoto err_block_bind;\n\n\tif (register_block) {\n\t\tflow_block_cb_add(block_cb, f);\n\t\tlist_add_tail(&block_cb->driver_list,\n\t\t\t      &dpaa2_switch_block_cb_list);\n\t}\n\n\treturn 0;\n\nerr_block_bind:\n\tif (!flow_block_cb_decref(block_cb))\n\t\tflow_block_cb_free(block_cb);\n\treturn err;\n}\n\nstatic void dpaa2_switch_setup_tc_block_unbind(struct net_device *netdev,\n\t\t\t\t\t       struct flow_block_offload *f)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct dpaa2_switch_filter_block *filter_block;\n\tstruct flow_block_cb *block_cb;\n\tint err;\n\n\tblock_cb = flow_block_cb_lookup(f->block,\n\t\t\t\t\tdpaa2_switch_port_setup_tc_block_cb_ig,\n\t\t\t\t\tethsw);\n\tif (!block_cb)\n\t\treturn;\n\n\tfilter_block = flow_block_cb_priv(block_cb);\n\terr = dpaa2_switch_port_block_unbind(port_priv, filter_block);\n\tif (!err && !flow_block_cb_decref(block_cb)) {\n\t\tflow_block_cb_remove(block_cb, f);\n\t\tlist_del(&block_cb->driver_list);\n\t}\n}\n\nstatic int dpaa2_switch_setup_tc_block(struct net_device *netdev,\n\t\t\t\t       struct flow_block_offload *f)\n{\n\tif (f->binder_type != FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS)\n\t\treturn -EOPNOTSUPP;\n\n\tf->driver_block_list = &dpaa2_switch_block_cb_list;\n\n\tswitch (f->command) {\n\tcase FLOW_BLOCK_BIND:\n\t\treturn dpaa2_switch_setup_tc_block_bind(netdev, f);\n\tcase FLOW_BLOCK_UNBIND:\n\t\tdpaa2_switch_setup_tc_block_unbind(netdev, f);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int dpaa2_switch_port_setup_tc(struct net_device *netdev,\n\t\t\t\t      enum tc_setup_type type,\n\t\t\t\t      void *type_data)\n{\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK: {\n\t\treturn dpaa2_switch_setup_tc_block(netdev, type_data);\n\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops dpaa2_switch_port_ops = {\n\t.ndo_open\t\t= dpaa2_switch_port_open,\n\t.ndo_stop\t\t= dpaa2_switch_port_stop,\n\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_get_stats64\t= dpaa2_switch_port_get_stats,\n\t.ndo_change_mtu\t\t= dpaa2_switch_port_change_mtu,\n\t.ndo_has_offload_stats\t= dpaa2_switch_port_has_offload_stats,\n\t.ndo_get_offload_stats\t= dpaa2_switch_port_get_offload_stats,\n\t.ndo_fdb_dump\t\t= dpaa2_switch_port_fdb_dump,\n\t.ndo_vlan_rx_add_vid\t= dpaa2_switch_port_vlan_add,\n\t.ndo_vlan_rx_kill_vid\t= dpaa2_switch_port_vlan_kill,\n\n\t.ndo_start_xmit\t\t= dpaa2_switch_port_tx,\n\t.ndo_get_port_parent_id\t= dpaa2_switch_port_parent_id,\n\t.ndo_get_phys_port_name = dpaa2_switch_port_get_phys_name,\n\t.ndo_setup_tc\t\t= dpaa2_switch_port_setup_tc,\n};\n\nbool dpaa2_switch_port_dev_check(const struct net_device *netdev)\n{\n\treturn netdev->netdev_ops == &dpaa2_switch_port_ops;\n}\n\nstatic int dpaa2_switch_port_connect_mac(struct ethsw_port_priv *port_priv)\n{\n\tstruct fsl_mc_device *dpsw_port_dev, *dpmac_dev;\n\tstruct dpaa2_mac *mac;\n\tint err;\n\n\tdpsw_port_dev = to_fsl_mc_device(port_priv->netdev->dev.parent);\n\tdpmac_dev = fsl_mc_get_endpoint(dpsw_port_dev, port_priv->idx);\n\n\tif (PTR_ERR(dpmac_dev) == -EPROBE_DEFER)\n\t\treturn PTR_ERR(dpmac_dev);\n\n\tif (IS_ERR(dpmac_dev) || dpmac_dev->dev.type != &fsl_mc_bus_dpmac_type)\n\t\treturn 0;\n\n\tmac = kzalloc(sizeof(*mac), GFP_KERNEL);\n\tif (!mac)\n\t\treturn -ENOMEM;\n\n\tmac->mc_dev = dpmac_dev;\n\tmac->mc_io = port_priv->ethsw_data->mc_io;\n\tmac->net_dev = port_priv->netdev;\n\n\terr = dpaa2_mac_open(mac);\n\tif (err)\n\t\tgoto err_free_mac;\n\n\tif (dpaa2_mac_is_type_phy(mac)) {\n\t\terr = dpaa2_mac_connect(mac);\n\t\tif (err) {\n\t\t\tnetdev_err(port_priv->netdev,\n\t\t\t\t   \"Error connecting to the MAC endpoint %pe\\n\",\n\t\t\t\t   ERR_PTR(err));\n\t\t\tgoto err_close_mac;\n\t\t}\n\t}\n\n\tmutex_lock(&port_priv->mac_lock);\n\tport_priv->mac = mac;\n\tmutex_unlock(&port_priv->mac_lock);\n\n\treturn 0;\n\nerr_close_mac:\n\tdpaa2_mac_close(mac);\nerr_free_mac:\n\tkfree(mac);\n\treturn err;\n}\n\nstatic void dpaa2_switch_port_disconnect_mac(struct ethsw_port_priv *port_priv)\n{\n\tstruct dpaa2_mac *mac;\n\n\tmutex_lock(&port_priv->mac_lock);\n\tmac = port_priv->mac;\n\tport_priv->mac = NULL;\n\tmutex_unlock(&port_priv->mac_lock);\n\n\tif (!mac)\n\t\treturn;\n\n\tif (dpaa2_mac_is_type_phy(mac))\n\t\tdpaa2_mac_disconnect(mac);\n\n\tdpaa2_mac_close(mac);\n\tkfree(mac);\n}\n\nstatic irqreturn_t dpaa2_switch_irq0_handler_thread(int irq_num, void *arg)\n{\n\tstruct device *dev = (struct device *)arg;\n\tstruct ethsw_core *ethsw = dev_get_drvdata(dev);\n\tstruct ethsw_port_priv *port_priv;\n\tu32 status = ~0;\n\tint err, if_id;\n\tbool had_mac;\n\n\terr = dpsw_get_irq_status(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t  DPSW_IRQ_INDEX_IF, &status);\n\tif (err) {\n\t\tdev_err(dev, \"Can't get irq status (err %d)\\n\", err);\n\t\tgoto out;\n\t}\n\n\tif_id = (status & 0xFFFF0000) >> 16;\n\tport_priv = ethsw->ports[if_id];\n\n\tif (status & DPSW_IRQ_EVENT_LINK_CHANGED) {\n\t\tdpaa2_switch_port_link_state_update(port_priv->netdev);\n\t\tdpaa2_switch_port_set_mac_addr(port_priv);\n\t}\n\n\tif (status & DPSW_IRQ_EVENT_ENDPOINT_CHANGED) {\n\t\t \n\t\thad_mac = !!port_priv->mac;\n\t\tif (had_mac)\n\t\t\tdpaa2_switch_port_disconnect_mac(port_priv);\n\t\telse\n\t\t\tdpaa2_switch_port_connect_mac(port_priv);\n\t}\n\nout:\n\terr = dpsw_clear_irq_status(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t    DPSW_IRQ_INDEX_IF, status);\n\tif (err)\n\t\tdev_err(dev, \"Can't clear irq status (err %d)\\n\", err);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dpaa2_switch_setup_irqs(struct fsl_mc_device *sw_dev)\n{\n\tstruct device *dev = &sw_dev->dev;\n\tstruct ethsw_core *ethsw = dev_get_drvdata(dev);\n\tu32 mask = DPSW_IRQ_EVENT_LINK_CHANGED;\n\tstruct fsl_mc_device_irq *irq;\n\tint err;\n\n\terr = fsl_mc_allocate_irqs(sw_dev);\n\tif (err) {\n\t\tdev_err(dev, \"MC irqs allocation failed\\n\");\n\t\treturn err;\n\t}\n\n\tif (WARN_ON(sw_dev->obj_desc.irq_count != DPSW_IRQ_NUM)) {\n\t\terr = -EINVAL;\n\t\tgoto free_irq;\n\t}\n\n\terr = dpsw_set_irq_enable(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t  DPSW_IRQ_INDEX_IF, 0);\n\tif (err) {\n\t\tdev_err(dev, \"dpsw_set_irq_enable err %d\\n\", err);\n\t\tgoto free_irq;\n\t}\n\n\tirq = sw_dev->irqs[DPSW_IRQ_INDEX_IF];\n\n\terr = devm_request_threaded_irq(dev, irq->virq, NULL,\n\t\t\t\t\tdpaa2_switch_irq0_handler_thread,\n\t\t\t\t\tIRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dev), dev);\n\tif (err) {\n\t\tdev_err(dev, \"devm_request_threaded_irq(): %d\\n\", err);\n\t\tgoto free_irq;\n\t}\n\n\terr = dpsw_set_irq_mask(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\tDPSW_IRQ_INDEX_IF, mask);\n\tif (err) {\n\t\tdev_err(dev, \"dpsw_set_irq_mask(): %d\\n\", err);\n\t\tgoto free_devm_irq;\n\t}\n\n\terr = dpsw_set_irq_enable(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t  DPSW_IRQ_INDEX_IF, 1);\n\tif (err) {\n\t\tdev_err(dev, \"dpsw_set_irq_enable(): %d\\n\", err);\n\t\tgoto free_devm_irq;\n\t}\n\n\treturn 0;\n\nfree_devm_irq:\n\tdevm_free_irq(dev, irq->virq, dev);\nfree_irq:\n\tfsl_mc_free_irqs(sw_dev);\n\treturn err;\n}\n\nstatic void dpaa2_switch_teardown_irqs(struct fsl_mc_device *sw_dev)\n{\n\tstruct device *dev = &sw_dev->dev;\n\tstruct ethsw_core *ethsw = dev_get_drvdata(dev);\n\tint err;\n\n\terr = dpsw_set_irq_enable(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t  DPSW_IRQ_INDEX_IF, 0);\n\tif (err)\n\t\tdev_err(dev, \"dpsw_set_irq_enable err %d\\n\", err);\n\n\tfsl_mc_free_irqs(sw_dev);\n}\n\nstatic int dpaa2_switch_port_set_learning(struct ethsw_port_priv *port_priv, bool enable)\n{\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tenum dpsw_learning_mode learn_mode;\n\tint err;\n\n\tif (enable)\n\t\tlearn_mode = DPSW_LEARNING_MODE_HW;\n\telse\n\t\tlearn_mode = DPSW_LEARNING_MODE_DIS;\n\n\terr = dpsw_if_set_learning_mode(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t\tport_priv->idx, learn_mode);\n\tif (err)\n\t\tnetdev_err(port_priv->netdev, \"dpsw_if_set_learning_mode err %d\\n\", err);\n\n\tif (!enable)\n\t\tdpaa2_switch_port_fast_age(port_priv);\n\n\treturn err;\n}\n\nstatic int dpaa2_switch_port_attr_stp_state_set(struct net_device *netdev,\n\t\t\t\t\t\tu8 state)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tint err;\n\n\terr = dpaa2_switch_port_set_stp_state(port_priv, state);\n\tif (err)\n\t\treturn err;\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\tcase BR_STATE_BLOCKING:\n\tcase BR_STATE_LISTENING:\n\t\terr = dpaa2_switch_port_set_learning(port_priv, false);\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\tcase BR_STATE_FORWARDING:\n\t\terr = dpaa2_switch_port_set_learning(port_priv,\n\t\t\t\t\t\t     port_priv->learn_ena);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int dpaa2_switch_port_flood(struct ethsw_port_priv *port_priv,\n\t\t\t\t   struct switchdev_brport_flags flags)\n{\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\n\tif (flags.mask & BR_BCAST_FLOOD)\n\t\tport_priv->bcast_flood = !!(flags.val & BR_BCAST_FLOOD);\n\n\tif (flags.mask & BR_FLOOD)\n\t\tport_priv->ucast_flood = !!(flags.val & BR_FLOOD);\n\n\treturn dpaa2_switch_fdb_set_egress_flood(ethsw, port_priv->fdb->fdb_id);\n}\n\nstatic int dpaa2_switch_port_pre_bridge_flags(struct net_device *netdev,\n\t\t\t\t\t      struct switchdev_brport_flags flags,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tif (flags.mask & ~(BR_LEARNING | BR_BCAST_FLOOD | BR_FLOOD |\n\t\t\t   BR_MCAST_FLOOD))\n\t\treturn -EINVAL;\n\n\tif (flags.mask & (BR_FLOOD | BR_MCAST_FLOOD)) {\n\t\tbool multicast = !!(flags.val & BR_MCAST_FLOOD);\n\t\tbool unicast = !!(flags.val & BR_FLOOD);\n\n\t\tif (unicast != multicast) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Cannot configure multicast flooding independently of unicast\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dpaa2_switch_port_bridge_flags(struct net_device *netdev,\n\t\t\t\t\t  struct switchdev_brport_flags flags,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tint err;\n\n\tif (flags.mask & BR_LEARNING) {\n\t\tbool learn_ena = !!(flags.val & BR_LEARNING);\n\n\t\terr = dpaa2_switch_port_set_learning(port_priv, learn_ena);\n\t\tif (err)\n\t\t\treturn err;\n\t\tport_priv->learn_ena = learn_ena;\n\t}\n\n\tif (flags.mask & (BR_BCAST_FLOOD | BR_FLOOD | BR_MCAST_FLOOD)) {\n\t\terr = dpaa2_switch_port_flood(port_priv, flags);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int dpaa2_switch_port_attr_set(struct net_device *netdev, const void *ctx,\n\t\t\t\t      const struct switchdev_attr *attr,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint err = 0;\n\n\tswitch (attr->id) {\n\tcase SWITCHDEV_ATTR_ID_PORT_STP_STATE:\n\t\terr = dpaa2_switch_port_attr_stp_state_set(netdev,\n\t\t\t\t\t\t\t   attr->u.stp_state);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING:\n\t\tif (!attr->u.vlan_filtering) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"The DPAA2 switch does not support VLAN-unaware operation\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS:\n\t\terr = dpaa2_switch_port_pre_bridge_flags(netdev, attr->u.brport_flags, extack);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:\n\t\terr = dpaa2_switch_port_bridge_flags(netdev, attr->u.brport_flags, extack);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint dpaa2_switch_port_vlans_add(struct net_device *netdev,\n\t\t\t\tconst struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct dpsw_attr *attr = &ethsw->sw_attr;\n\tint err = 0;\n\n\t \n\tif (port_priv->vlans[vlan->vid] & ETHSW_VLAN_MEMBER)\n\t\treturn -EEXIST;\n\n\t \n\terr = dpsw_get_attributes(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t  &ethsw->sw_attr);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dpsw_get_attributes err %d\\n\", err);\n\t\treturn err;\n\t}\n\tif (attr->max_vlans - attr->num_vlans < 1)\n\t\treturn -ENOSPC;\n\n\t \n\terr = dpsw_get_attributes(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t  &ethsw->sw_attr);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dpsw_get_attributes err %d\\n\", err);\n\t\treturn err;\n\t}\n\tif (attr->max_vlans - attr->num_vlans < 1)\n\t\treturn -ENOSPC;\n\n\tif (!port_priv->ethsw_data->vlans[vlan->vid]) {\n\t\t \n\t\terr = dpaa2_switch_add_vlan(port_priv, vlan->vid);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tport_priv->ethsw_data->vlans[vlan->vid] |= ETHSW_VLAN_GLOBAL;\n\t}\n\n\treturn dpaa2_switch_port_add_vlan(port_priv, vlan->vid, vlan->flags);\n}\n\nstatic int dpaa2_switch_port_lookup_address(struct net_device *netdev, int is_uc,\n\t\t\t\t\t    const unsigned char *addr)\n{\n\tstruct netdev_hw_addr_list *list = (is_uc) ? &netdev->uc : &netdev->mc;\n\tstruct netdev_hw_addr *ha;\n\n\tnetif_addr_lock_bh(netdev);\n\tlist_for_each_entry(ha, &list->list, list) {\n\t\tif (ether_addr_equal(ha->addr, addr)) {\n\t\t\tnetif_addr_unlock_bh(netdev);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tnetif_addr_unlock_bh(netdev);\n\treturn 0;\n}\n\nstatic int dpaa2_switch_port_mdb_add(struct net_device *netdev,\n\t\t\t\t     const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tint err;\n\n\t \n\tif (dpaa2_switch_port_lookup_address(netdev, 0, mdb->addr))\n\t\treturn -EEXIST;\n\n\terr = dpaa2_switch_port_fdb_add_mc(port_priv, mdb->addr);\n\tif (err)\n\t\treturn err;\n\n\terr = dev_mc_add(netdev, mdb->addr);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dev_mc_add err %d\\n\", err);\n\t\tdpaa2_switch_port_fdb_del_mc(port_priv, mdb->addr);\n\t}\n\n\treturn err;\n}\n\nstatic int dpaa2_switch_port_obj_add(struct net_device *netdev,\n\t\t\t\t     const struct switchdev_obj *obj)\n{\n\tint err;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\terr = dpaa2_switch_port_vlans_add(netdev,\n\t\t\t\t\t\t  SWITCHDEV_OBJ_PORT_VLAN(obj));\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\t\terr = dpaa2_switch_port_mdb_add(netdev,\n\t\t\t\t\t\tSWITCHDEV_OBJ_PORT_MDB(obj));\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int dpaa2_switch_port_del_vlan(struct ethsw_port_priv *port_priv, u16 vid)\n{\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct net_device *netdev = port_priv->netdev;\n\tstruct dpsw_vlan_if_cfg vcfg;\n\tint i, err;\n\n\tif (!port_priv->vlans[vid])\n\t\treturn -ENOENT;\n\n\tif (port_priv->vlans[vid] & ETHSW_VLAN_PVID) {\n\t\t \n\t\terr = dpaa2_switch_port_set_pvid(port_priv, 4095);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tvcfg.num_ifs = 1;\n\tvcfg.if_id[0] = port_priv->idx;\n\tif (port_priv->vlans[vid] & ETHSW_VLAN_UNTAGGED) {\n\t\terr = dpsw_vlan_remove_if_untagged(ethsw->mc_io, 0,\n\t\t\t\t\t\t   ethsw->dpsw_handle,\n\t\t\t\t\t\t   vid, &vcfg);\n\t\tif (err) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"dpsw_vlan_remove_if_untagged err %d\\n\",\n\t\t\t\t   err);\n\t\t}\n\t\tport_priv->vlans[vid] &= ~ETHSW_VLAN_UNTAGGED;\n\t}\n\n\tif (port_priv->vlans[vid] & ETHSW_VLAN_MEMBER) {\n\t\terr = dpsw_vlan_remove_if(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t\t  vid, &vcfg);\n\t\tif (err) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"dpsw_vlan_remove_if err %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\tport_priv->vlans[vid] &= ~ETHSW_VLAN_MEMBER;\n\n\t\t \n\t\tfor (i = 0; i < ethsw->sw_attr.num_ifs; i++) {\n\t\t\tif (ethsw->ports[i] &&\n\t\t\t    ethsw->ports[i]->vlans[vid] & ETHSW_VLAN_MEMBER)\n\t\t\t\treturn 0;  \n\t\t}\n\n\t\tethsw->vlans[vid] &= ~ETHSW_VLAN_GLOBAL;\n\n\t\terr = dpaa2_switch_dellink(ethsw, vid);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint dpaa2_switch_port_vlans_del(struct net_device *netdev,\n\t\t\t\tconst struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\n\tif (netif_is_bridge_master(vlan->obj.orig_dev))\n\t\treturn -EOPNOTSUPP;\n\n\treturn dpaa2_switch_port_del_vlan(port_priv, vlan->vid);\n}\n\nstatic int dpaa2_switch_port_mdb_del(struct net_device *netdev,\n\t\t\t\t     const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tint err;\n\n\tif (!dpaa2_switch_port_lookup_address(netdev, 0, mdb->addr))\n\t\treturn -ENOENT;\n\n\terr = dpaa2_switch_port_fdb_del_mc(port_priv, mdb->addr);\n\tif (err)\n\t\treturn err;\n\n\terr = dev_mc_del(netdev, mdb->addr);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dev_mc_del err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic int dpaa2_switch_port_obj_del(struct net_device *netdev,\n\t\t\t\t     const struct switchdev_obj *obj)\n{\n\tint err;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\terr = dpaa2_switch_port_vlans_del(netdev, SWITCHDEV_OBJ_PORT_VLAN(obj));\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\t\terr = dpaa2_switch_port_mdb_del(netdev, SWITCHDEV_OBJ_PORT_MDB(obj));\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic int dpaa2_switch_port_attr_set_event(struct net_device *netdev,\n\t\t\t\t\t    struct switchdev_notifier_port_attr_info *ptr)\n{\n\tint err;\n\n\terr = switchdev_handle_port_attr_set(netdev, ptr,\n\t\t\t\t\t     dpaa2_switch_port_dev_check,\n\t\t\t\t\t     dpaa2_switch_port_attr_set);\n\treturn notifier_from_errno(err);\n}\n\nstatic int dpaa2_switch_port_bridge_join(struct net_device *netdev,\n\t\t\t\t\t struct net_device *upper_dev,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct ethsw_port_priv *other_port_priv;\n\tstruct net_device *other_dev;\n\tstruct list_head *iter;\n\tbool learn_ena;\n\tint err;\n\n\tnetdev_for_each_lower_dev(upper_dev, other_dev, iter) {\n\t\tif (!dpaa2_switch_port_dev_check(other_dev))\n\t\t\tcontinue;\n\n\t\tother_port_priv = netdev_priv(other_dev);\n\t\tif (other_port_priv->ethsw_data != port_priv->ethsw_data) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Interface from a different DPSW is in the bridge already\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\terr = dpaa2_switch_port_del_vlan(port_priv, 1);\n\tif (err)\n\t\treturn err;\n\n\tdpaa2_switch_port_set_fdb(port_priv, upper_dev);\n\n\t \n\tlearn_ena = br_port_flag_is_set(netdev, BR_LEARNING);\n\terr = dpaa2_switch_port_set_learning(port_priv, learn_ena);\n\tport_priv->learn_ena = learn_ena;\n\n\t \n\terr = dpaa2_switch_fdb_set_egress_flood(ethsw, port_priv->fdb->fdb_id);\n\tif (err)\n\t\tgoto err_egress_flood;\n\n\terr = switchdev_bridge_port_offload(netdev, netdev, NULL,\n\t\t\t\t\t    NULL, NULL, false, extack);\n\tif (err)\n\t\tgoto err_switchdev_offload;\n\n\treturn 0;\n\nerr_switchdev_offload:\nerr_egress_flood:\n\tdpaa2_switch_port_set_fdb(port_priv, NULL);\n\treturn err;\n}\n\nstatic int dpaa2_switch_port_clear_rxvlan(struct net_device *vdev, int vid, void *arg)\n{\n\t__be16 vlan_proto = htons(ETH_P_8021Q);\n\n\tif (vdev)\n\t\tvlan_proto = vlan_dev_vlan_proto(vdev);\n\n\treturn dpaa2_switch_port_vlan_kill(arg, vlan_proto, vid);\n}\n\nstatic int dpaa2_switch_port_restore_rxvlan(struct net_device *vdev, int vid, void *arg)\n{\n\t__be16 vlan_proto = htons(ETH_P_8021Q);\n\n\tif (vdev)\n\t\tvlan_proto = vlan_dev_vlan_proto(vdev);\n\n\treturn dpaa2_switch_port_vlan_add(arg, vlan_proto, vid);\n}\n\nstatic void dpaa2_switch_port_pre_bridge_leave(struct net_device *netdev)\n{\n\tswitchdev_bridge_port_unoffload(netdev, NULL, NULL, NULL);\n}\n\nstatic int dpaa2_switch_port_bridge_leave(struct net_device *netdev)\n{\n\tstruct ethsw_port_priv *port_priv = netdev_priv(netdev);\n\tstruct dpaa2_switch_fdb *old_fdb = port_priv->fdb;\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tint err;\n\n\t \n\tdpaa2_switch_port_fast_age(port_priv);\n\n\t \n\terr = vlan_for_each(netdev, dpaa2_switch_port_clear_rxvlan, netdev);\n\tif (err)\n\t\tnetdev_err(netdev, \"Unable to clear RX VLANs from old FDB table, err (%d)\\n\", err);\n\n\tdpaa2_switch_port_set_fdb(port_priv, NULL);\n\n\t \n\terr = vlan_for_each(netdev, dpaa2_switch_port_restore_rxvlan, netdev);\n\tif (err)\n\t\tnetdev_err(netdev, \"Unable to restore RX VLANs to the new FDB, err (%d)\\n\", err);\n\n\t \n\tport_priv->bcast_flood = true;\n\tport_priv->ucast_flood = true;\n\n\t \n\terr = dpaa2_switch_fdb_set_egress_flood(ethsw, port_priv->fdb->fdb_id);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = dpaa2_switch_fdb_set_egress_flood(ethsw, old_fdb->fdb_id);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = dpaa2_switch_port_set_learning(port_priv, false);\n\tif (err)\n\t\treturn err;\n\tport_priv->learn_ena = false;\n\n\t \n\treturn dpaa2_switch_port_add_vlan(port_priv, DEFAULT_VLAN_ID,\n\t\t\t\t\t  BRIDGE_VLAN_INFO_UNTAGGED | BRIDGE_VLAN_INFO_PVID);\n}\n\nstatic int dpaa2_switch_prevent_bridging_with_8021q_upper(struct net_device *netdev)\n{\n\tstruct net_device *upper_dev;\n\tstruct list_head *iter;\n\n\t \n\tnetdev_for_each_upper_dev_rcu(netdev, upper_dev, iter)\n\t\tif (is_vlan_dev(upper_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int\ndpaa2_switch_prechangeupper_sanity_checks(struct net_device *netdev,\n\t\t\t\t\t  struct net_device *upper_dev,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tif (!br_vlan_enabled(upper_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot join a VLAN-unaware bridge\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = dpaa2_switch_prevent_bridging_with_8021q_upper(netdev);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Cannot join a bridge while VLAN uppers are present\");\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int dpaa2_switch_port_netdevice_event(struct notifier_block *nb,\n\t\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_notifier_changeupper_info *info = ptr;\n\tstruct netlink_ext_ack *extack;\n\tstruct net_device *upper_dev;\n\tint err = 0;\n\n\tif (!dpaa2_switch_port_dev_check(netdev))\n\t\treturn NOTIFY_DONE;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\n\tswitch (event) {\n\tcase NETDEV_PRECHANGEUPPER:\n\t\tupper_dev = info->upper_dev;\n\t\tif (!netif_is_bridge_master(upper_dev))\n\t\t\tbreak;\n\n\t\terr = dpaa2_switch_prechangeupper_sanity_checks(netdev,\n\t\t\t\t\t\t\t\tupper_dev,\n\t\t\t\t\t\t\t\textack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (!info->linking)\n\t\t\tdpaa2_switch_port_pre_bridge_leave(netdev);\n\n\t\tbreak;\n\tcase NETDEV_CHANGEUPPER:\n\t\tupper_dev = info->upper_dev;\n\t\tif (netif_is_bridge_master(upper_dev)) {\n\t\t\tif (info->linking)\n\t\t\t\terr = dpaa2_switch_port_bridge_join(netdev,\n\t\t\t\t\t\t\t\t    upper_dev,\n\t\t\t\t\t\t\t\t    extack);\n\t\t\telse\n\t\t\t\terr = dpaa2_switch_port_bridge_leave(netdev);\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\treturn notifier_from_errno(err);\n}\n\nstruct ethsw_switchdev_event_work {\n\tstruct work_struct work;\n\tstruct switchdev_notifier_fdb_info fdb_info;\n\tstruct net_device *dev;\n\tunsigned long event;\n};\n\nstatic void dpaa2_switch_event_work(struct work_struct *work)\n{\n\tstruct ethsw_switchdev_event_work *switchdev_work =\n\t\tcontainer_of(work, struct ethsw_switchdev_event_work, work);\n\tstruct net_device *dev = switchdev_work->dev;\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tint err;\n\n\trtnl_lock();\n\tfdb_info = &switchdev_work->fdb_info;\n\n\tswitch (switchdev_work->event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\tif (!fdb_info->added_by_user || fdb_info->is_local)\n\t\t\tbreak;\n\t\tif (is_unicast_ether_addr(fdb_info->addr))\n\t\t\terr = dpaa2_switch_port_fdb_add_uc(netdev_priv(dev),\n\t\t\t\t\t\t\t   fdb_info->addr);\n\t\telse\n\t\t\terr = dpaa2_switch_port_fdb_add_mc(netdev_priv(dev),\n\t\t\t\t\t\t\t   fdb_info->addr);\n\t\tif (err)\n\t\t\tbreak;\n\t\tfdb_info->offloaded = true;\n\t\tcall_switchdev_notifiers(SWITCHDEV_FDB_OFFLOADED, dev,\n\t\t\t\t\t &fdb_info->info, NULL);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tif (!fdb_info->added_by_user || fdb_info->is_local)\n\t\t\tbreak;\n\t\tif (is_unicast_ether_addr(fdb_info->addr))\n\t\t\tdpaa2_switch_port_fdb_del_uc(netdev_priv(dev), fdb_info->addr);\n\t\telse\n\t\t\tdpaa2_switch_port_fdb_del_mc(netdev_priv(dev), fdb_info->addr);\n\t\tbreak;\n\t}\n\n\trtnl_unlock();\n\tkfree(switchdev_work->fdb_info.addr);\n\tkfree(switchdev_work);\n\tdev_put(dev);\n}\n\n \nstatic int dpaa2_switch_port_event(struct notifier_block *nb,\n\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tstruct ethsw_port_priv *port_priv = netdev_priv(dev);\n\tstruct ethsw_switchdev_event_work *switchdev_work;\n\tstruct switchdev_notifier_fdb_info *fdb_info = ptr;\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\n\tif (event == SWITCHDEV_PORT_ATTR_SET)\n\t\treturn dpaa2_switch_port_attr_set_event(dev, ptr);\n\n\tif (!dpaa2_switch_port_dev_check(dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitchdev_work = kzalloc(sizeof(*switchdev_work), GFP_ATOMIC);\n\tif (!switchdev_work)\n\t\treturn NOTIFY_BAD;\n\n\tINIT_WORK(&switchdev_work->work, dpaa2_switch_event_work);\n\tswitchdev_work->dev = dev;\n\tswitchdev_work->event = event;\n\n\tswitch (event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tmemcpy(&switchdev_work->fdb_info, ptr,\n\t\t       sizeof(switchdev_work->fdb_info));\n\t\tswitchdev_work->fdb_info.addr = kzalloc(ETH_ALEN, GFP_ATOMIC);\n\t\tif (!switchdev_work->fdb_info.addr)\n\t\t\tgoto err_addr_alloc;\n\n\t\tether_addr_copy((u8 *)switchdev_work->fdb_info.addr,\n\t\t\t\tfdb_info->addr);\n\n\t\t \n\t\tdev_hold(dev);\n\t\tbreak;\n\tdefault:\n\t\tkfree(switchdev_work);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tqueue_work(ethsw->workqueue, &switchdev_work->work);\n\n\treturn NOTIFY_DONE;\n\nerr_addr_alloc:\n\tkfree(switchdev_work);\n\treturn NOTIFY_BAD;\n}\n\nstatic int dpaa2_switch_port_obj_event(unsigned long event,\n\t\t\t\t       struct net_device *netdev,\n\t\t\t\t       struct switchdev_notifier_port_obj_info *port_obj_info)\n{\n\tint err = -EOPNOTSUPP;\n\n\tif (!dpaa2_switch_port_dev_check(netdev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_OBJ_ADD:\n\t\terr = dpaa2_switch_port_obj_add(netdev, port_obj_info->obj);\n\t\tbreak;\n\tcase SWITCHDEV_PORT_OBJ_DEL:\n\t\terr = dpaa2_switch_port_obj_del(netdev, port_obj_info->obj);\n\t\tbreak;\n\t}\n\n\tport_obj_info->handled = true;\n\treturn notifier_from_errno(err);\n}\n\nstatic int dpaa2_switch_port_blocking_event(struct notifier_block *nb,\n\t\t\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_OBJ_ADD:\n\tcase SWITCHDEV_PORT_OBJ_DEL:\n\t\treturn dpaa2_switch_port_obj_event(event, dev, ptr);\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\treturn dpaa2_switch_port_attr_set_event(dev, ptr);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic struct sk_buff *dpaa2_switch_build_linear_skb(struct ethsw_core *ethsw,\n\t\t\t\t\t\t     const struct dpaa2_fd *fd)\n{\n\tu16 fd_offset = dpaa2_fd_get_offset(fd);\n\tdma_addr_t addr = dpaa2_fd_get_addr(fd);\n\tu32 fd_length = dpaa2_fd_get_len(fd);\n\tstruct device *dev = ethsw->dev;\n\tstruct sk_buff *skb = NULL;\n\tvoid *fd_vaddr;\n\n\tfd_vaddr = dpaa2_iova_to_virt(ethsw->iommu_domain, addr);\n\tdma_unmap_page(dev, addr, DPAA2_SWITCH_RX_BUF_SIZE,\n\t\t       DMA_FROM_DEVICE);\n\n\tskb = build_skb(fd_vaddr, DPAA2_SWITCH_RX_BUF_SIZE +\n\t\t\tSKB_DATA_ALIGN(sizeof(struct skb_shared_info)));\n\tif (unlikely(!skb)) {\n\t\tdev_err(dev, \"build_skb() failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tskb_reserve(skb, fd_offset);\n\tskb_put(skb, fd_length);\n\n\tethsw->buf_count--;\n\n\treturn skb;\n}\n\nstatic void dpaa2_switch_tx_conf(struct dpaa2_switch_fq *fq,\n\t\t\t\t const struct dpaa2_fd *fd)\n{\n\tdpaa2_switch_free_fd(fq->ethsw, fd);\n}\n\nstatic void dpaa2_switch_rx(struct dpaa2_switch_fq *fq,\n\t\t\t    const struct dpaa2_fd *fd)\n{\n\tstruct ethsw_core *ethsw = fq->ethsw;\n\tstruct ethsw_port_priv *port_priv;\n\tstruct net_device *netdev;\n\tstruct vlan_ethhdr *hdr;\n\tstruct sk_buff *skb;\n\tu16 vlan_tci, vid;\n\tint if_id, err;\n\n\t \n\tif_id = upper_32_bits(dpaa2_fd_get_flc(fd)) & 0x0000FFFF;\n\n\tif (if_id >= ethsw->sw_attr.num_ifs) {\n\t\tdev_err(ethsw->dev, \"Frame received from unknown interface!\\n\");\n\t\tgoto err_free_fd;\n\t}\n\tport_priv = ethsw->ports[if_id];\n\tnetdev = port_priv->netdev;\n\n\t \n\tif (dpaa2_fd_get_format(fd) != dpaa2_fd_single) {\n\t\tif (net_ratelimit()) {\n\t\t\tnetdev_err(netdev, \"Received invalid frame format\\n\");\n\t\t\tgoto err_free_fd;\n\t\t}\n\t}\n\n\tskb = dpaa2_switch_build_linear_skb(ethsw, fd);\n\tif (unlikely(!skb))\n\t\tgoto err_free_fd;\n\n\tskb_reset_mac_header(skb);\n\n\t \n\thdr = vlan_eth_hdr(skb);\n\tvid = ntohs(hdr->h_vlan_TCI) & VLAN_VID_MASK;\n\tif (vid == port_priv->pvid) {\n\t\terr = __skb_vlan_pop(skb, &vlan_tci);\n\t\tif (err) {\n\t\t\tdev_info(ethsw->dev, \"__skb_vlan_pop() returned %d\", err);\n\t\t\tgoto err_free_fd;\n\t\t}\n\t}\n\n\tskb->dev = netdev;\n\tskb->protocol = eth_type_trans(skb, skb->dev);\n\n\t \n\tskb->offload_fwd_mark = !!(port_priv->fdb->bridge_dev);\n\n\tnetif_receive_skb(skb);\n\n\treturn;\n\nerr_free_fd:\n\tdpaa2_switch_free_fd(ethsw, fd);\n}\n\nstatic void dpaa2_switch_detect_features(struct ethsw_core *ethsw)\n{\n\tethsw->features = 0;\n\n\tif (ethsw->major > 8 || (ethsw->major == 8 && ethsw->minor >= 6))\n\t\tethsw->features |= ETHSW_FEATURE_MAC_ADDR;\n}\n\nstatic int dpaa2_switch_setup_fqs(struct ethsw_core *ethsw)\n{\n\tstruct dpsw_ctrl_if_attr ctrl_if_attr;\n\tstruct device *dev = ethsw->dev;\n\tint i = 0;\n\tint err;\n\n\terr = dpsw_ctrl_if_get_attributes(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t\t  &ctrl_if_attr);\n\tif (err) {\n\t\tdev_err(dev, \"dpsw_ctrl_if_get_attributes() = %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tethsw->fq[i].fqid = ctrl_if_attr.rx_fqid;\n\tethsw->fq[i].ethsw = ethsw;\n\tethsw->fq[i++].type = DPSW_QUEUE_RX;\n\n\tethsw->fq[i].fqid = ctrl_if_attr.tx_err_conf_fqid;\n\tethsw->fq[i].ethsw = ethsw;\n\tethsw->fq[i++].type = DPSW_QUEUE_TX_ERR_CONF;\n\n\treturn 0;\n}\n\n \nstatic void dpaa2_switch_free_bufs(struct ethsw_core *ethsw, u64 *buf_array, int count)\n{\n\tstruct device *dev = ethsw->dev;\n\tvoid *vaddr;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tvaddr = dpaa2_iova_to_virt(ethsw->iommu_domain, buf_array[i]);\n\t\tdma_unmap_page(dev, buf_array[i], DPAA2_SWITCH_RX_BUF_SIZE,\n\t\t\t       DMA_FROM_DEVICE);\n\t\tfree_pages((unsigned long)vaddr, 0);\n\t}\n}\n\n \nstatic int dpaa2_switch_add_bufs(struct ethsw_core *ethsw, u16 bpid)\n{\n\tstruct device *dev = ethsw->dev;\n\tu64 buf_array[BUFS_PER_CMD];\n\tstruct page *page;\n\tint retries = 0;\n\tdma_addr_t addr;\n\tint err;\n\tint i;\n\n\tfor (i = 0; i < BUFS_PER_CMD; i++) {\n\t\t \n\t\tpage = dev_alloc_pages(0);\n\t\tif (!page) {\n\t\t\tdev_err(dev, \"buffer allocation failed\\n\");\n\t\t\tgoto err_alloc;\n\t\t}\n\n\t\taddr = dma_map_page(dev, page, 0, DPAA2_SWITCH_RX_BUF_SIZE,\n\t\t\t\t    DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(dev, addr)) {\n\t\t\tdev_err(dev, \"dma_map_single() failed\\n\");\n\t\t\tgoto err_map;\n\t\t}\n\t\tbuf_array[i] = addr;\n\t}\n\nrelease_bufs:\n\t \n\twhile ((err = dpaa2_io_service_release(NULL, bpid,\n\t\t\t\t\t       buf_array, i)) == -EBUSY) {\n\t\tif (retries++ >= DPAA2_SWITCH_SWP_BUSY_RETRIES)\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t}\n\n\t \n\tif (err) {\n\t\tdpaa2_switch_free_bufs(ethsw, buf_array, i);\n\t\treturn 0;\n\t}\n\n\treturn i;\n\nerr_map:\n\t__free_pages(page, 0);\nerr_alloc:\n\t \n\tif (i)\n\t\tgoto release_bufs;\n\n\treturn 0;\n}\n\nstatic int dpaa2_switch_refill_bp(struct ethsw_core *ethsw)\n{\n\tint *count = &ethsw->buf_count;\n\tint new_count;\n\tint err = 0;\n\n\tif (unlikely(*count < DPAA2_ETHSW_REFILL_THRESH)) {\n\t\tdo {\n\t\t\tnew_count = dpaa2_switch_add_bufs(ethsw, ethsw->bpid);\n\t\t\tif (unlikely(!new_count)) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*count += new_count;\n\t\t} while (*count < DPAA2_ETHSW_NUM_BUFS);\n\n\t\tif (unlikely(*count < DPAA2_ETHSW_NUM_BUFS))\n\t\t\terr = -ENOMEM;\n\t}\n\n\treturn err;\n}\n\nstatic int dpaa2_switch_seed_bp(struct ethsw_core *ethsw)\n{\n\tint *count, i;\n\n\tfor (i = 0; i < DPAA2_ETHSW_NUM_BUFS; i += BUFS_PER_CMD) {\n\t\tcount = &ethsw->buf_count;\n\t\t*count += dpaa2_switch_add_bufs(ethsw, ethsw->bpid);\n\n\t\tif (unlikely(*count < BUFS_PER_CMD))\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void dpaa2_switch_drain_bp(struct ethsw_core *ethsw)\n{\n\tu64 buf_array[BUFS_PER_CMD];\n\tint ret;\n\n\tdo {\n\t\tret = dpaa2_io_service_acquire(NULL, ethsw->bpid,\n\t\t\t\t\t       buf_array, BUFS_PER_CMD);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ethsw->dev,\n\t\t\t\t\"dpaa2_io_service_acquire() = %d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\t\tdpaa2_switch_free_bufs(ethsw, buf_array, ret);\n\n\t} while (ret);\n}\n\nstatic int dpaa2_switch_setup_dpbp(struct ethsw_core *ethsw)\n{\n\tstruct dpsw_ctrl_if_pools_cfg dpsw_ctrl_if_pools_cfg = { 0 };\n\tstruct device *dev = ethsw->dev;\n\tstruct fsl_mc_device *dpbp_dev;\n\tstruct dpbp_attr dpbp_attrs;\n\tint err;\n\n\terr = fsl_mc_object_allocate(to_fsl_mc_device(dev), FSL_MC_POOL_DPBP,\n\t\t\t\t     &dpbp_dev);\n\tif (err) {\n\t\tif (err == -ENXIO)\n\t\t\terr = -EPROBE_DEFER;\n\t\telse\n\t\t\tdev_err(dev, \"DPBP device allocation failed\\n\");\n\t\treturn err;\n\t}\n\tethsw->dpbp_dev = dpbp_dev;\n\n\terr = dpbp_open(ethsw->mc_io, 0, dpbp_dev->obj_desc.id,\n\t\t\t&dpbp_dev->mc_handle);\n\tif (err) {\n\t\tdev_err(dev, \"dpbp_open() failed\\n\");\n\t\tgoto err_open;\n\t}\n\n\terr = dpbp_reset(ethsw->mc_io, 0, dpbp_dev->mc_handle);\n\tif (err) {\n\t\tdev_err(dev, \"dpbp_reset() failed\\n\");\n\t\tgoto err_reset;\n\t}\n\n\terr = dpbp_enable(ethsw->mc_io, 0, dpbp_dev->mc_handle);\n\tif (err) {\n\t\tdev_err(dev, \"dpbp_enable() failed\\n\");\n\t\tgoto err_enable;\n\t}\n\n\terr = dpbp_get_attributes(ethsw->mc_io, 0, dpbp_dev->mc_handle,\n\t\t\t\t  &dpbp_attrs);\n\tif (err) {\n\t\tdev_err(dev, \"dpbp_get_attributes() failed\\n\");\n\t\tgoto err_get_attr;\n\t}\n\n\tdpsw_ctrl_if_pools_cfg.num_dpbp = 1;\n\tdpsw_ctrl_if_pools_cfg.pools[0].dpbp_id = dpbp_attrs.id;\n\tdpsw_ctrl_if_pools_cfg.pools[0].buffer_size = DPAA2_SWITCH_RX_BUF_SIZE;\n\tdpsw_ctrl_if_pools_cfg.pools[0].backup_pool = 0;\n\n\terr = dpsw_ctrl_if_set_pools(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t     &dpsw_ctrl_if_pools_cfg);\n\tif (err) {\n\t\tdev_err(dev, \"dpsw_ctrl_if_set_pools() failed\\n\");\n\t\tgoto err_get_attr;\n\t}\n\tethsw->bpid = dpbp_attrs.id;\n\n\treturn 0;\n\nerr_get_attr:\n\tdpbp_disable(ethsw->mc_io, 0, dpbp_dev->mc_handle);\nerr_enable:\nerr_reset:\n\tdpbp_close(ethsw->mc_io, 0, dpbp_dev->mc_handle);\nerr_open:\n\tfsl_mc_object_free(dpbp_dev);\n\treturn err;\n}\n\nstatic void dpaa2_switch_free_dpbp(struct ethsw_core *ethsw)\n{\n\tdpbp_disable(ethsw->mc_io, 0, ethsw->dpbp_dev->mc_handle);\n\tdpbp_close(ethsw->mc_io, 0, ethsw->dpbp_dev->mc_handle);\n\tfsl_mc_object_free(ethsw->dpbp_dev);\n}\n\nstatic int dpaa2_switch_alloc_rings(struct ethsw_core *ethsw)\n{\n\tint i;\n\n\tfor (i = 0; i < DPAA2_SWITCH_RX_NUM_FQS; i++) {\n\t\tethsw->fq[i].store =\n\t\t\tdpaa2_io_store_create(DPAA2_SWITCH_STORE_SIZE,\n\t\t\t\t\t      ethsw->dev);\n\t\tif (!ethsw->fq[i].store) {\n\t\t\tdev_err(ethsw->dev, \"dpaa2_io_store_create failed\\n\");\n\t\t\twhile (--i >= 0)\n\t\t\t\tdpaa2_io_store_destroy(ethsw->fq[i].store);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void dpaa2_switch_destroy_rings(struct ethsw_core *ethsw)\n{\n\tint i;\n\n\tfor (i = 0; i < DPAA2_SWITCH_RX_NUM_FQS; i++)\n\t\tdpaa2_io_store_destroy(ethsw->fq[i].store);\n}\n\nstatic int dpaa2_switch_pull_fq(struct dpaa2_switch_fq *fq)\n{\n\tint err, retries = 0;\n\n\t \n\tdo {\n\t\terr = dpaa2_io_service_pull_fq(NULL, fq->fqid, fq->store);\n\t\tcpu_relax();\n\t} while (err == -EBUSY && retries++ < DPAA2_SWITCH_SWP_BUSY_RETRIES);\n\n\tif (unlikely(err))\n\t\tdev_err(fq->ethsw->dev, \"dpaa2_io_service_pull err %d\", err);\n\n\treturn err;\n}\n\n \nstatic int dpaa2_switch_store_consume(struct dpaa2_switch_fq *fq)\n{\n\tstruct ethsw_core *ethsw = fq->ethsw;\n\tint cleaned = 0, is_last;\n\tstruct dpaa2_dq *dq;\n\tint retries = 0;\n\n\tdo {\n\t\t \n\t\tdq = dpaa2_io_store_next(fq->store, &is_last);\n\t\tif (unlikely(!dq)) {\n\t\t\tif (retries++ >= DPAA2_SWITCH_SWP_BUSY_RETRIES) {\n\t\t\t\tdev_err_once(ethsw->dev,\n\t\t\t\t\t     \"No valid dequeue response\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fq->type == DPSW_QUEUE_RX)\n\t\t\tdpaa2_switch_rx(fq, dpaa2_dq_fd(dq));\n\t\telse\n\t\t\tdpaa2_switch_tx_conf(fq, dpaa2_dq_fd(dq));\n\t\tcleaned++;\n\n\t} while (!is_last);\n\n\treturn cleaned;\n}\n\n \nstatic int dpaa2_switch_poll(struct napi_struct *napi, int budget)\n{\n\tint err, cleaned = 0, store_cleaned, work_done;\n\tstruct dpaa2_switch_fq *fq;\n\tint retries = 0;\n\n\tfq = container_of(napi, struct dpaa2_switch_fq, napi);\n\n\tdo {\n\t\terr = dpaa2_switch_pull_fq(fq);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\n\t\t \n\t\tdpaa2_switch_refill_bp(fq->ethsw);\n\n\t\tstore_cleaned = dpaa2_switch_store_consume(fq);\n\t\tcleaned += store_cleaned;\n\n\t\tif (cleaned >= budget) {\n\t\t\twork_done = budget;\n\t\t\tgoto out;\n\t\t}\n\n\t} while (store_cleaned);\n\n\t \n\tnapi_complete_done(napi, cleaned);\n\tdo {\n\t\terr = dpaa2_io_service_rearm(NULL, &fq->nctx);\n\t\tcpu_relax();\n\t} while (err == -EBUSY && retries++ < DPAA2_SWITCH_SWP_BUSY_RETRIES);\n\n\twork_done = max(cleaned, 1);\nout:\n\n\treturn work_done;\n}\n\nstatic void dpaa2_switch_fqdan_cb(struct dpaa2_io_notification_ctx *nctx)\n{\n\tstruct dpaa2_switch_fq *fq;\n\n\tfq = container_of(nctx, struct dpaa2_switch_fq, nctx);\n\n\tnapi_schedule(&fq->napi);\n}\n\nstatic int dpaa2_switch_setup_dpio(struct ethsw_core *ethsw)\n{\n\tstruct dpsw_ctrl_if_queue_cfg queue_cfg;\n\tstruct dpaa2_io_notification_ctx *nctx;\n\tint err, i, j;\n\n\tfor (i = 0; i < DPAA2_SWITCH_RX_NUM_FQS; i++) {\n\t\tnctx = &ethsw->fq[i].nctx;\n\n\t\t \n\t\tnctx->is_cdan = 0;\n\t\tnctx->id = ethsw->fq[i].fqid;\n\t\tnctx->desired_cpu = DPAA2_IO_ANY_CPU;\n\t\tnctx->cb = dpaa2_switch_fqdan_cb;\n\t\terr = dpaa2_io_service_register(NULL, nctx, ethsw->dev);\n\t\tif (err) {\n\t\t\terr = -EPROBE_DEFER;\n\t\t\tgoto err_register;\n\t\t}\n\n\t\tqueue_cfg.options = DPSW_CTRL_IF_QUEUE_OPT_DEST |\n\t\t\t\t    DPSW_CTRL_IF_QUEUE_OPT_USER_CTX;\n\t\tqueue_cfg.dest_cfg.dest_type = DPSW_CTRL_IF_DEST_DPIO;\n\t\tqueue_cfg.dest_cfg.dest_id = nctx->dpio_id;\n\t\tqueue_cfg.dest_cfg.priority = 0;\n\t\tqueue_cfg.user_ctx = nctx->qman64;\n\n\t\terr = dpsw_ctrl_if_set_queue(ethsw->mc_io, 0,\n\t\t\t\t\t     ethsw->dpsw_handle,\n\t\t\t\t\t     ethsw->fq[i].type,\n\t\t\t\t\t     &queue_cfg);\n\t\tif (err)\n\t\t\tgoto err_set_queue;\n\t}\n\n\treturn 0;\n\nerr_set_queue:\n\tdpaa2_io_service_deregister(NULL, nctx, ethsw->dev);\nerr_register:\n\tfor (j = 0; j < i; j++)\n\t\tdpaa2_io_service_deregister(NULL, &ethsw->fq[j].nctx,\n\t\t\t\t\t    ethsw->dev);\n\n\treturn err;\n}\n\nstatic void dpaa2_switch_free_dpio(struct ethsw_core *ethsw)\n{\n\tint i;\n\n\tfor (i = 0; i < DPAA2_SWITCH_RX_NUM_FQS; i++)\n\t\tdpaa2_io_service_deregister(NULL, &ethsw->fq[i].nctx,\n\t\t\t\t\t    ethsw->dev);\n}\n\nstatic int dpaa2_switch_ctrl_if_setup(struct ethsw_core *ethsw)\n{\n\tint err;\n\n\t \n\terr = dpaa2_switch_setup_fqs(ethsw);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = dpaa2_switch_setup_dpbp(ethsw);\n\tif (err)\n\t\treturn err;\n\n\terr = dpaa2_switch_alloc_rings(ethsw);\n\tif (err)\n\t\tgoto err_free_dpbp;\n\n\terr = dpaa2_switch_setup_dpio(ethsw);\n\tif (err)\n\t\tgoto err_destroy_rings;\n\n\terr = dpaa2_switch_seed_bp(ethsw);\n\tif (err)\n\t\tgoto err_deregister_dpio;\n\n\terr = dpsw_ctrl_if_enable(ethsw->mc_io, 0, ethsw->dpsw_handle);\n\tif (err) {\n\t\tdev_err(ethsw->dev, \"dpsw_ctrl_if_enable err %d\\n\", err);\n\t\tgoto err_drain_dpbp;\n\t}\n\n\treturn 0;\n\nerr_drain_dpbp:\n\tdpaa2_switch_drain_bp(ethsw);\nerr_deregister_dpio:\n\tdpaa2_switch_free_dpio(ethsw);\nerr_destroy_rings:\n\tdpaa2_switch_destroy_rings(ethsw);\nerr_free_dpbp:\n\tdpaa2_switch_free_dpbp(ethsw);\n\n\treturn err;\n}\n\nstatic void dpaa2_switch_remove_port(struct ethsw_core *ethsw,\n\t\t\t\t     u16 port_idx)\n{\n\tstruct ethsw_port_priv *port_priv = ethsw->ports[port_idx];\n\n\tdpaa2_switch_port_disconnect_mac(port_priv);\n\tfree_netdev(port_priv->netdev);\n\tethsw->ports[port_idx] = NULL;\n}\n\nstatic int dpaa2_switch_init(struct fsl_mc_device *sw_dev)\n{\n\tstruct device *dev = &sw_dev->dev;\n\tstruct ethsw_core *ethsw = dev_get_drvdata(dev);\n\tstruct dpsw_vlan_if_cfg vcfg = {0};\n\tstruct dpsw_tci_cfg tci_cfg = {0};\n\tstruct dpsw_stp_cfg stp_cfg;\n\tint err;\n\tu16 i;\n\n\tethsw->dev_id = sw_dev->obj_desc.id;\n\n\terr = dpsw_open(ethsw->mc_io, 0, ethsw->dev_id, &ethsw->dpsw_handle);\n\tif (err) {\n\t\tdev_err(dev, \"dpsw_open err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = dpsw_get_attributes(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t  &ethsw->sw_attr);\n\tif (err) {\n\t\tdev_err(dev, \"dpsw_get_attributes err %d\\n\", err);\n\t\tgoto err_close;\n\t}\n\n\terr = dpsw_get_api_version(ethsw->mc_io, 0,\n\t\t\t\t   &ethsw->major,\n\t\t\t\t   &ethsw->minor);\n\tif (err) {\n\t\tdev_err(dev, \"dpsw_get_api_version err %d\\n\", err);\n\t\tgoto err_close;\n\t}\n\n\t \n\tif (ethsw->major < DPSW_MIN_VER_MAJOR ||\n\t    (ethsw->major == DPSW_MIN_VER_MAJOR &&\n\t     ethsw->minor < DPSW_MIN_VER_MINOR)) {\n\t\tdev_err(dev, \"DPSW version %d:%d not supported. Use firmware 10.28.0 or greater.\\n\",\n\t\t\tethsw->major, ethsw->minor);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_close;\n\t}\n\n\tif (!dpaa2_switch_supports_cpu_traffic(ethsw)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_close;\n\t}\n\n\tdpaa2_switch_detect_features(ethsw);\n\n\terr = dpsw_reset(ethsw->mc_io, 0, ethsw->dpsw_handle);\n\tif (err) {\n\t\tdev_err(dev, \"dpsw_reset err %d\\n\", err);\n\t\tgoto err_close;\n\t}\n\n\tstp_cfg.vlan_id = DEFAULT_VLAN_ID;\n\tstp_cfg.state = DPSW_STP_STATE_FORWARDING;\n\n\tfor (i = 0; i < ethsw->sw_attr.num_ifs; i++) {\n\t\terr = dpsw_if_disable(ethsw->mc_io, 0, ethsw->dpsw_handle, i);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"dpsw_if_disable err %d\\n\", err);\n\t\t\tgoto err_close;\n\t\t}\n\n\t\terr = dpsw_if_set_stp(ethsw->mc_io, 0, ethsw->dpsw_handle, i,\n\t\t\t\t      &stp_cfg);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"dpsw_if_set_stp err %d for port %d\\n\",\n\t\t\t\terr, i);\n\t\t\tgoto err_close;\n\t\t}\n\n\t\t \n\t\tvcfg.num_ifs = 1;\n\t\tvcfg.if_id[0] = i;\n\t\terr = dpsw_vlan_remove_if_untagged(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t\t\t   DEFAULT_VLAN_ID, &vcfg);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"dpsw_vlan_remove_if_untagged err %d\\n\",\n\t\t\t\terr);\n\t\t\tgoto err_close;\n\t\t}\n\n\t\ttci_cfg.vlan_id = 4095;\n\t\terr = dpsw_if_set_tci(ethsw->mc_io, 0, ethsw->dpsw_handle, i, &tci_cfg);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"dpsw_if_set_tci err %d\\n\", err);\n\t\t\tgoto err_close;\n\t\t}\n\n\t\terr = dpsw_vlan_remove_if(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t\t  DEFAULT_VLAN_ID, &vcfg);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"dpsw_vlan_remove_if err %d\\n\", err);\n\t\t\tgoto err_close;\n\t\t}\n\t}\n\n\terr = dpsw_vlan_remove(ethsw->mc_io, 0, ethsw->dpsw_handle, DEFAULT_VLAN_ID);\n\tif (err) {\n\t\tdev_err(dev, \"dpsw_vlan_remove err %d\\n\", err);\n\t\tgoto err_close;\n\t}\n\n\tethsw->workqueue = alloc_ordered_workqueue(\"%s_%d_ordered\",\n\t\t\t\t\t\t   WQ_MEM_RECLAIM, \"ethsw\",\n\t\t\t\t\t\t   ethsw->sw_attr.id);\n\tif (!ethsw->workqueue) {\n\t\terr = -ENOMEM;\n\t\tgoto err_close;\n\t}\n\n\terr = dpsw_fdb_remove(ethsw->mc_io, 0, ethsw->dpsw_handle, 0);\n\tif (err)\n\t\tgoto err_destroy_ordered_workqueue;\n\n\terr = dpaa2_switch_ctrl_if_setup(ethsw);\n\tif (err)\n\t\tgoto err_destroy_ordered_workqueue;\n\n\treturn 0;\n\nerr_destroy_ordered_workqueue:\n\tdestroy_workqueue(ethsw->workqueue);\n\nerr_close:\n\tdpsw_close(ethsw->mc_io, 0, ethsw->dpsw_handle);\n\treturn err;\n}\n\n \nstatic int dpaa2_switch_port_trap_mac_addr(struct ethsw_port_priv *port_priv,\n\t\t\t\t\t   const char *mac)\n{\n\tstruct dpaa2_switch_acl_entry acl_entry = {0};\n\n\t \n\tether_addr_copy(acl_entry.key.match.l2_dest_mac, mac);\n\teth_broadcast_addr(acl_entry.key.mask.l2_dest_mac);\n\n\t \n\tacl_entry.cfg.precedence = 0;\n\tacl_entry.cfg.result.action = DPSW_ACL_ACTION_REDIRECT_TO_CTRL_IF;\n\n\treturn dpaa2_switch_acl_entry_add(port_priv->filter_block, &acl_entry);\n}\n\nstatic int dpaa2_switch_port_init(struct ethsw_port_priv *port_priv, u16 port)\n{\n\tconst char stpa[ETH_ALEN] = {0x01, 0x80, 0xc2, 0x00, 0x00, 0x00};\n\tstruct switchdev_obj_port_vlan vlan = {\n\t\t.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,\n\t\t.vid = DEFAULT_VLAN_ID,\n\t\t.flags = BRIDGE_VLAN_INFO_UNTAGGED | BRIDGE_VLAN_INFO_PVID,\n\t};\n\tstruct net_device *netdev = port_priv->netdev;\n\tstruct ethsw_core *ethsw = port_priv->ethsw_data;\n\tstruct dpaa2_switch_filter_block *filter_block;\n\tstruct dpsw_fdb_cfg fdb_cfg = {0};\n\tstruct dpsw_if_attr dpsw_if_attr;\n\tstruct dpaa2_switch_fdb *fdb;\n\tstruct dpsw_acl_cfg acl_cfg;\n\tu16 fdb_id, acl_tbl_id;\n\tint err;\n\n\t \n\terr = dpsw_if_get_attributes(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t\t     port_priv->idx, &dpsw_if_attr);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dpsw_if_get_attributes err %d\\n\", err);\n\t\treturn err;\n\t}\n\tport_priv->tx_qdid = dpsw_if_attr.qdid;\n\n\t \n\tfdb_cfg.num_fdb_entries = ethsw->sw_attr.max_fdb_entries / ethsw->sw_attr.num_ifs;\n\terr = dpsw_fdb_add(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t   &fdb_id, &fdb_cfg);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dpsw_fdb_add err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tfdb = dpaa2_switch_fdb_get_unused(ethsw);\n\tfdb->fdb_id = fdb_id;\n\tfdb->in_use = true;\n\tfdb->bridge_dev = NULL;\n\tport_priv->fdb = fdb;\n\n\t \n\terr = dpaa2_switch_port_vlans_add(netdev, &vlan);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = dpaa2_switch_fdb_set_egress_flood(ethsw, port_priv->fdb->fdb_id);\n\tif (err)\n\t\treturn err;\n\n\t \n\tacl_cfg.max_entries = DPAA2_ETHSW_PORT_MAX_ACL_ENTRIES;\n\terr = dpsw_acl_add(ethsw->mc_io, 0, ethsw->dpsw_handle,\n\t\t\t   &acl_tbl_id, &acl_cfg);\n\tif (err) {\n\t\tnetdev_err(netdev, \"dpsw_acl_add err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tfilter_block = dpaa2_switch_filter_block_get_unused(ethsw);\n\tfilter_block->ethsw = ethsw;\n\tfilter_block->acl_id = acl_tbl_id;\n\tfilter_block->in_use = true;\n\tfilter_block->num_acl_rules = 0;\n\tINIT_LIST_HEAD(&filter_block->acl_entries);\n\tINIT_LIST_HEAD(&filter_block->mirror_entries);\n\n\terr = dpaa2_switch_port_acl_tbl_bind(port_priv, filter_block);\n\tif (err)\n\t\treturn err;\n\n\terr = dpaa2_switch_port_trap_mac_addr(port_priv, stpa);\n\tif (err)\n\t\treturn err;\n\n\treturn err;\n}\n\nstatic void dpaa2_switch_ctrl_if_teardown(struct ethsw_core *ethsw)\n{\n\tdpsw_ctrl_if_disable(ethsw->mc_io, 0, ethsw->dpsw_handle);\n\tdpaa2_switch_free_dpio(ethsw);\n\tdpaa2_switch_destroy_rings(ethsw);\n\tdpaa2_switch_drain_bp(ethsw);\n\tdpaa2_switch_free_dpbp(ethsw);\n}\n\nstatic void dpaa2_switch_teardown(struct fsl_mc_device *sw_dev)\n{\n\tstruct device *dev = &sw_dev->dev;\n\tstruct ethsw_core *ethsw = dev_get_drvdata(dev);\n\tint err;\n\n\tdpaa2_switch_ctrl_if_teardown(ethsw);\n\n\tdestroy_workqueue(ethsw->workqueue);\n\n\terr = dpsw_close(ethsw->mc_io, 0, ethsw->dpsw_handle);\n\tif (err)\n\t\tdev_warn(dev, \"dpsw_close err %d\\n\", err);\n}\n\nstatic void dpaa2_switch_remove(struct fsl_mc_device *sw_dev)\n{\n\tstruct ethsw_port_priv *port_priv;\n\tstruct ethsw_core *ethsw;\n\tstruct device *dev;\n\tint i;\n\n\tdev = &sw_dev->dev;\n\tethsw = dev_get_drvdata(dev);\n\n\tdpaa2_switch_teardown_irqs(sw_dev);\n\n\tdpsw_disable(ethsw->mc_io, 0, ethsw->dpsw_handle);\n\n\tfor (i = 0; i < ethsw->sw_attr.num_ifs; i++) {\n\t\tport_priv = ethsw->ports[i];\n\t\tunregister_netdev(port_priv->netdev);\n\t\tdpaa2_switch_remove_port(ethsw, i);\n\t}\n\n\tkfree(ethsw->fdbs);\n\tkfree(ethsw->filter_blocks);\n\tkfree(ethsw->ports);\n\n\tdpaa2_switch_teardown(sw_dev);\n\n\tfsl_mc_portal_free(ethsw->mc_io);\n\n\tkfree(ethsw);\n\n\tdev_set_drvdata(dev, NULL);\n}\n\nstatic int dpaa2_switch_probe_port(struct ethsw_core *ethsw,\n\t\t\t\t   u16 port_idx)\n{\n\tstruct ethsw_port_priv *port_priv;\n\tstruct device *dev = ethsw->dev;\n\tstruct net_device *port_netdev;\n\tint err;\n\n\tport_netdev = alloc_etherdev(sizeof(struct ethsw_port_priv));\n\tif (!port_netdev) {\n\t\tdev_err(dev, \"alloc_etherdev error\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tport_priv = netdev_priv(port_netdev);\n\tport_priv->netdev = port_netdev;\n\tport_priv->ethsw_data = ethsw;\n\n\tmutex_init(&port_priv->mac_lock);\n\n\tport_priv->idx = port_idx;\n\tport_priv->stp_state = BR_STATE_FORWARDING;\n\n\tSET_NETDEV_DEV(port_netdev, dev);\n\tport_netdev->netdev_ops = &dpaa2_switch_port_ops;\n\tport_netdev->ethtool_ops = &dpaa2_switch_port_ethtool_ops;\n\n\tport_netdev->needed_headroom = DPAA2_SWITCH_NEEDED_HEADROOM;\n\n\tport_priv->bcast_flood = true;\n\tport_priv->ucast_flood = true;\n\n\t \n\tport_netdev->min_mtu = ETH_MIN_MTU;\n\tport_netdev->max_mtu = ETHSW_MAX_FRAME_LENGTH;\n\n\t \n\tethsw->ports[port_idx] = port_priv;\n\n\t \n\tport_netdev->features = NETIF_F_HW_VLAN_CTAG_FILTER |\n\t\t\t\tNETIF_F_HW_VLAN_STAG_FILTER |\n\t\t\t\tNETIF_F_HW_TC;\n\n\terr = dpaa2_switch_port_init(port_priv, port_idx);\n\tif (err)\n\t\tgoto err_port_probe;\n\n\terr = dpaa2_switch_port_set_mac_addr(port_priv);\n\tif (err)\n\t\tgoto err_port_probe;\n\n\terr = dpaa2_switch_port_set_learning(port_priv, false);\n\tif (err)\n\t\tgoto err_port_probe;\n\tport_priv->learn_ena = false;\n\n\terr = dpaa2_switch_port_connect_mac(port_priv);\n\tif (err)\n\t\tgoto err_port_probe;\n\n\treturn 0;\n\nerr_port_probe:\n\tfree_netdev(port_netdev);\n\tethsw->ports[port_idx] = NULL;\n\n\treturn err;\n}\n\nstatic int dpaa2_switch_probe(struct fsl_mc_device *sw_dev)\n{\n\tstruct device *dev = &sw_dev->dev;\n\tstruct ethsw_core *ethsw;\n\tint i, err;\n\n\t \n\tethsw = kzalloc(sizeof(*ethsw), GFP_KERNEL);\n\n\tif (!ethsw)\n\t\treturn -ENOMEM;\n\n\tethsw->dev = dev;\n\tethsw->iommu_domain = iommu_get_domain_for_dev(dev);\n\tdev_set_drvdata(dev, ethsw);\n\n\terr = fsl_mc_portal_allocate(sw_dev, FSL_MC_IO_ATOMIC_CONTEXT_PORTAL,\n\t\t\t\t     &ethsw->mc_io);\n\tif (err) {\n\t\tif (err == -ENXIO)\n\t\t\terr = -EPROBE_DEFER;\n\t\telse\n\t\t\tdev_err(dev, \"fsl_mc_portal_allocate err %d\\n\", err);\n\t\tgoto err_free_drvdata;\n\t}\n\n\terr = dpaa2_switch_init(sw_dev);\n\tif (err)\n\t\tgoto err_free_cmdport;\n\n\tethsw->ports = kcalloc(ethsw->sw_attr.num_ifs, sizeof(*ethsw->ports),\n\t\t\t       GFP_KERNEL);\n\tif (!(ethsw->ports)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_teardown;\n\t}\n\n\tethsw->fdbs = kcalloc(ethsw->sw_attr.num_ifs, sizeof(*ethsw->fdbs),\n\t\t\t      GFP_KERNEL);\n\tif (!ethsw->fdbs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_ports;\n\t}\n\n\tethsw->filter_blocks = kcalloc(ethsw->sw_attr.num_ifs,\n\t\t\t\t       sizeof(*ethsw->filter_blocks),\n\t\t\t\t       GFP_KERNEL);\n\tif (!ethsw->filter_blocks) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_fdbs;\n\t}\n\n\tfor (i = 0; i < ethsw->sw_attr.num_ifs; i++) {\n\t\terr = dpaa2_switch_probe_port(ethsw, i);\n\t\tif (err)\n\t\t\tgoto err_free_netdev;\n\t}\n\n\t \n\tfor (i = 0; i < DPAA2_SWITCH_RX_NUM_FQS; i++)\n\t\tnetif_napi_add(ethsw->ports[0]->netdev, &ethsw->fq[i].napi,\n\t\t\t       dpaa2_switch_poll);\n\n\t \n\terr = dpaa2_switch_setup_irqs(sw_dev);\n\tif (err)\n\t\tgoto err_stop;\n\n\t \n\tethsw->mirror_port =  ethsw->sw_attr.num_ifs;\n\n\t \n\tfor (i = 0; i < ethsw->sw_attr.num_ifs; i++) {\n\t\terr = register_netdev(ethsw->ports[i]->netdev);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"register_netdev error %d\\n\", err);\n\t\t\tgoto err_unregister_ports;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_unregister_ports:\n\tfor (i--; i >= 0; i--)\n\t\tunregister_netdev(ethsw->ports[i]->netdev);\n\tdpaa2_switch_teardown_irqs(sw_dev);\nerr_stop:\n\tdpsw_disable(ethsw->mc_io, 0, ethsw->dpsw_handle);\nerr_free_netdev:\n\tfor (i--; i >= 0; i--)\n\t\tdpaa2_switch_remove_port(ethsw, i);\n\tkfree(ethsw->filter_blocks);\nerr_free_fdbs:\n\tkfree(ethsw->fdbs);\nerr_free_ports:\n\tkfree(ethsw->ports);\n\nerr_teardown:\n\tdpaa2_switch_teardown(sw_dev);\n\nerr_free_cmdport:\n\tfsl_mc_portal_free(ethsw->mc_io);\n\nerr_free_drvdata:\n\tkfree(ethsw);\n\tdev_set_drvdata(dev, NULL);\n\n\treturn err;\n}\n\nstatic const struct fsl_mc_device_id dpaa2_switch_match_id_table[] = {\n\t{\n\t\t.vendor = FSL_MC_VENDOR_FREESCALE,\n\t\t.obj_type = \"dpsw\",\n\t},\n\t{ .vendor = 0x0 }\n};\nMODULE_DEVICE_TABLE(fslmc, dpaa2_switch_match_id_table);\n\nstatic struct fsl_mc_driver dpaa2_switch_drv = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t},\n\t.probe = dpaa2_switch_probe,\n\t.remove = dpaa2_switch_remove,\n\t.match_id_table = dpaa2_switch_match_id_table\n};\n\nstatic struct notifier_block dpaa2_switch_port_nb __read_mostly = {\n\t.notifier_call = dpaa2_switch_port_netdevice_event,\n};\n\nstatic struct notifier_block dpaa2_switch_port_switchdev_nb = {\n\t.notifier_call = dpaa2_switch_port_event,\n};\n\nstatic struct notifier_block dpaa2_switch_port_switchdev_blocking_nb = {\n\t.notifier_call = dpaa2_switch_port_blocking_event,\n};\n\nstatic int dpaa2_switch_register_notifiers(void)\n{\n\tint err;\n\n\terr = register_netdevice_notifier(&dpaa2_switch_port_nb);\n\tif (err) {\n\t\tpr_err(\"dpaa2-switch: failed to register net_device notifier (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = register_switchdev_notifier(&dpaa2_switch_port_switchdev_nb);\n\tif (err) {\n\t\tpr_err(\"dpaa2-switch: failed to register switchdev notifier (%d)\\n\", err);\n\t\tgoto err_switchdev_nb;\n\t}\n\n\terr = register_switchdev_blocking_notifier(&dpaa2_switch_port_switchdev_blocking_nb);\n\tif (err) {\n\t\tpr_err(\"dpaa2-switch: failed to register switchdev blocking notifier (%d)\\n\", err);\n\t\tgoto err_switchdev_blocking_nb;\n\t}\n\n\treturn 0;\n\nerr_switchdev_blocking_nb:\n\tunregister_switchdev_notifier(&dpaa2_switch_port_switchdev_nb);\nerr_switchdev_nb:\n\tunregister_netdevice_notifier(&dpaa2_switch_port_nb);\n\n\treturn err;\n}\n\nstatic void dpaa2_switch_unregister_notifiers(void)\n{\n\tint err;\n\n\terr = unregister_switchdev_blocking_notifier(&dpaa2_switch_port_switchdev_blocking_nb);\n\tif (err)\n\t\tpr_err(\"dpaa2-switch: failed to unregister switchdev blocking notifier (%d)\\n\",\n\t\t       err);\n\n\terr = unregister_switchdev_notifier(&dpaa2_switch_port_switchdev_nb);\n\tif (err)\n\t\tpr_err(\"dpaa2-switch: failed to unregister switchdev notifier (%d)\\n\", err);\n\n\terr = unregister_netdevice_notifier(&dpaa2_switch_port_nb);\n\tif (err)\n\t\tpr_err(\"dpaa2-switch: failed to unregister net_device notifier (%d)\\n\", err);\n}\n\nstatic int __init dpaa2_switch_driver_init(void)\n{\n\tint err;\n\n\terr = fsl_mc_driver_register(&dpaa2_switch_drv);\n\tif (err)\n\t\treturn err;\n\n\terr = dpaa2_switch_register_notifiers();\n\tif (err) {\n\t\tfsl_mc_driver_unregister(&dpaa2_switch_drv);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit dpaa2_switch_driver_exit(void)\n{\n\tdpaa2_switch_unregister_notifiers();\n\tfsl_mc_driver_unregister(&dpaa2_switch_drv);\n}\n\nmodule_init(dpaa2_switch_driver_init);\nmodule_exit(dpaa2_switch_driver_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"DPAA2 Ethernet Switch Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}