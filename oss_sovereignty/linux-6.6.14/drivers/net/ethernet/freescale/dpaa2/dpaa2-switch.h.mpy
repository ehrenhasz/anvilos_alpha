{
  "module_name": "dpaa2-switch.h",
  "hash_id": "88777a813287b929de8c2d998d0027108d27e8114767dacf5d8895b29ac02c12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/dpaa2/dpaa2-switch.h",
  "human_readable_source": " \n \n\n#ifndef __ETHSW_H\n#define __ETHSW_H\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_vlan.h>\n#include <uapi/linux/if_bridge.h>\n#include <net/switchdev.h>\n#include <linux/if_bridge.h>\n#include <linux/fsl/mc.h>\n#include <net/pkt_cls.h>\n#include <soc/fsl/dpaa2-io.h>\n\n#include \"dpaa2-mac.h\"\n#include \"dpsw.h\"\n\n \n#define DPSW_IRQ_NUM\t2\n\n \n#define ETHSW_VLAN_MEMBER\t1\n \n#define ETHSW_VLAN_UNTAGGED\t2\n \n#define ETHSW_VLAN_PVID\t\t4\n \n#define ETHSW_VLAN_GLOBAL\t8\n\n \n#define DPAA2_MFL\t\t(10 * 1024)\n#define ETHSW_MAX_FRAME_LENGTH\t(DPAA2_MFL - VLAN_ETH_HLEN - ETH_FCS_LEN)\n#define ETHSW_L2_MAX_FRM(mtu)\t((mtu) + VLAN_ETH_HLEN + ETH_FCS_LEN)\n\n#define ETHSW_FEATURE_MAC_ADDR\tBIT(0)\n\n \n#define DPAA2_SWITCH_RX_NUM_FQS\t2\n\n \n#define DPAA2_SWITCH_RX_BUF_RAW_SIZE\tPAGE_SIZE\n#define DPAA2_SWITCH_RX_BUF_TAILROOM \\\n\tSKB_DATA_ALIGN(sizeof(struct skb_shared_info))\n#define DPAA2_SWITCH_RX_BUF_SIZE \\\n\t(DPAA2_SWITCH_RX_BUF_RAW_SIZE - DPAA2_SWITCH_RX_BUF_TAILROOM)\n\n#define DPAA2_SWITCH_STORE_SIZE 16\n\n \n#define BUFS_PER_CMD\t\t\t7\n#define DPAA2_ETHSW_NUM_BUFS\t\t(1024 * BUFS_PER_CMD)\n#define DPAA2_ETHSW_REFILL_THRESH\t(DPAA2_ETHSW_NUM_BUFS * 5 / 6)\n\n \n#define DPAA2_SWITCH_SWP_BUSY_RETRIES\t\t1000\n\n \n#define DPAA2_SWITCH_HWA_SIZE\t\t\t64\n \n#define DPAA2_SWITCH_SWA_SIZE\t\t\t64\n\n#define DPAA2_SWITCH_TX_BUF_ALIGN\t\t64\n\n#define DPAA2_SWITCH_TX_DATA_OFFSET \\\n\t(DPAA2_SWITCH_HWA_SIZE + DPAA2_SWITCH_SWA_SIZE)\n\n#define DPAA2_SWITCH_NEEDED_HEADROOM \\\n\t(DPAA2_SWITCH_TX_DATA_OFFSET + DPAA2_SWITCH_TX_BUF_ALIGN)\n\n#define DPAA2_ETHSW_PORT_MAX_ACL_ENTRIES\t16\n#define DPAA2_ETHSW_PORT_DEFAULT_TRAPS\t\t1\n\n#define DPAA2_ETHSW_PORT_ACL_CMD_BUF_SIZE\t256\n\nextern const struct ethtool_ops dpaa2_switch_port_ethtool_ops;\n\nstruct ethsw_core;\n\nstruct dpaa2_switch_fq {\n\tstruct ethsw_core *ethsw;\n\tenum dpsw_queue_type type;\n\tstruct dpaa2_io_store *store;\n\tstruct dpaa2_io_notification_ctx nctx;\n\tstruct napi_struct napi;\n\tu32 fqid;\n};\n\nstruct dpaa2_switch_fdb {\n\tstruct net_device\t*bridge_dev;\n\tu16\t\t\tfdb_id;\n\tbool\t\t\tin_use;\n};\n\nstruct dpaa2_switch_acl_entry {\n\tstruct list_head\tlist;\n\tu16\t\t\tprio;\n\tunsigned long\t\tcookie;\n\n\tstruct dpsw_acl_entry_cfg cfg;\n\tstruct dpsw_acl_key\tkey;\n};\n\nstruct dpaa2_switch_mirror_entry {\n\tstruct list_head\tlist;\n\tstruct dpsw_reflection_cfg cfg;\n\tunsigned long\t\tcookie;\n\tu16 if_id;\n};\n\nstruct dpaa2_switch_filter_block {\n\tstruct ethsw_core\t*ethsw;\n\tu64\t\t\tports;\n\tbool\t\t\tin_use;\n\n\tstruct list_head\tacl_entries;\n\tu16\t\t\tacl_id;\n\tu8\t\t\tnum_acl_rules;\n\n\tstruct list_head\tmirror_entries;\n};\n\nstatic inline bool\ndpaa2_switch_acl_tbl_is_full(struct dpaa2_switch_filter_block *filter_block)\n{\n\tif ((filter_block->num_acl_rules + DPAA2_ETHSW_PORT_DEFAULT_TRAPS) >=\n\t    DPAA2_ETHSW_PORT_MAX_ACL_ENTRIES)\n\t\treturn true;\n\treturn false;\n}\n\n \nstruct ethsw_port_priv {\n\tstruct net_device\t*netdev;\n\tu16\t\t\tidx;\n\tstruct ethsw_core\t*ethsw_data;\n\tu8\t\t\tlink_state;\n\tu8\t\t\tstp_state;\n\n\tu8\t\t\tvlans[VLAN_VID_MASK + 1];\n\tu16\t\t\tpvid;\n\tu16\t\t\ttx_qdid;\n\n\tstruct dpaa2_switch_fdb\t*fdb;\n\tbool\t\t\tbcast_flood;\n\tbool\t\t\tucast_flood;\n\tbool\t\t\tlearn_ena;\n\n\tstruct dpaa2_switch_filter_block *filter_block;\n\tstruct dpaa2_mac\t*mac;\n\t \n\tstruct mutex\t\tmac_lock;\n};\n\n \nstruct ethsw_core {\n\tstruct device\t\t\t*dev;\n\tstruct fsl_mc_io\t\t*mc_io;\n\tu16\t\t\t\tdpsw_handle;\n\tstruct dpsw_attr\t\tsw_attr;\n\tu16\t\t\t\tmajor, minor;\n\tunsigned long\t\t\tfeatures;\n\tint\t\t\t\tdev_id;\n\tstruct ethsw_port_priv\t\t**ports;\n\tstruct iommu_domain\t\t*iommu_domain;\n\n\tu8\t\t\t\tvlans[VLAN_VID_MASK + 1];\n\n\tstruct workqueue_struct\t\t*workqueue;\n\n\tstruct dpaa2_switch_fq\t\tfq[DPAA2_SWITCH_RX_NUM_FQS];\n\tstruct fsl_mc_device\t\t*dpbp_dev;\n\tint\t\t\t\tbuf_count;\n\tu16\t\t\t\tbpid;\n\tint\t\t\t\tnapi_users;\n\n\tstruct dpaa2_switch_fdb\t\t*fdbs;\n\tstruct dpaa2_switch_filter_block *filter_blocks;\n\tu16\t\t\t\tmirror_port;\n};\n\nstatic inline int dpaa2_switch_get_index(struct ethsw_core *ethsw,\n\t\t\t\t\t struct net_device *netdev)\n{\n\tint i;\n\n\tfor (i = 0; i < ethsw->sw_attr.num_ifs; i++)\n\t\tif (ethsw->ports[i]->netdev == netdev)\n\t\t\treturn ethsw->ports[i]->idx;\n\n\treturn -EINVAL;\n}\n\nstatic inline bool dpaa2_switch_supports_cpu_traffic(struct ethsw_core *ethsw)\n{\n\tif (ethsw->sw_attr.options & DPSW_OPT_CTRL_IF_DIS) {\n\t\tdev_err(ethsw->dev, \"Control Interface is disabled, cannot probe\\n\");\n\t\treturn false;\n\t}\n\n\tif (ethsw->sw_attr.flooding_cfg != DPSW_FLOODING_PER_FDB) {\n\t\tdev_err(ethsw->dev, \"Flooding domain is not per FDB, cannot probe\\n\");\n\t\treturn false;\n\t}\n\n\tif (ethsw->sw_attr.broadcast_cfg != DPSW_BROADCAST_PER_FDB) {\n\t\tdev_err(ethsw->dev, \"Broadcast domain is not per FDB, cannot probe\\n\");\n\t\treturn false;\n\t}\n\n\tif (ethsw->sw_attr.max_fdbs < ethsw->sw_attr.num_ifs) {\n\t\tdev_err(ethsw->dev, \"The number of FDBs is lower than the number of ports, cannot probe\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic inline bool\ndpaa2_switch_port_is_type_phy(struct ethsw_port_priv *port_priv)\n{\n\treturn dpaa2_mac_is_type_phy(port_priv->mac);\n}\n\nstatic inline bool dpaa2_switch_port_has_mac(struct ethsw_port_priv *port_priv)\n{\n\treturn port_priv->mac ? true : false;\n}\n\nbool dpaa2_switch_port_dev_check(const struct net_device *netdev);\n\nint dpaa2_switch_port_vlans_add(struct net_device *netdev,\n\t\t\t\tconst struct switchdev_obj_port_vlan *vlan);\n\nint dpaa2_switch_port_vlans_del(struct net_device *netdev,\n\t\t\t\tconst struct switchdev_obj_port_vlan *vlan);\n\ntypedef int dpaa2_switch_fdb_cb_t(struct ethsw_port_priv *port_priv,\n\t\t\t\t  struct fdb_dump_entry *fdb_entry,\n\t\t\t\t  void *data);\n\n \n\nint dpaa2_switch_cls_flower_replace(struct dpaa2_switch_filter_block *block,\n\t\t\t\t    struct flow_cls_offload *cls);\n\nint dpaa2_switch_cls_flower_destroy(struct dpaa2_switch_filter_block *block,\n\t\t\t\t    struct flow_cls_offload *cls);\n\nint dpaa2_switch_cls_matchall_replace(struct dpaa2_switch_filter_block *block,\n\t\t\t\t      struct tc_cls_matchall_offload *cls);\n\nint dpaa2_switch_cls_matchall_destroy(struct dpaa2_switch_filter_block *block,\n\t\t\t\t      struct tc_cls_matchall_offload *cls);\n\nint dpaa2_switch_acl_entry_add(struct dpaa2_switch_filter_block *block,\n\t\t\t       struct dpaa2_switch_acl_entry *entry);\n\nint dpaa2_switch_block_offload_mirror(struct dpaa2_switch_filter_block *block,\n\t\t\t\t      struct ethsw_port_priv *port_priv);\n\nint dpaa2_switch_block_unoffload_mirror(struct dpaa2_switch_filter_block *block,\n\t\t\t\t\tstruct ethsw_port_priv *port_priv);\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}