{
  "module_name": "dpaa2-ptp.c",
  "hash_id": "3eaf81585c98fdc00c79e8dbd3b45c53939a4ac3c81503c104ca6dc033ce3b37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/freescale/dpaa2/dpaa2-ptp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/fsl/mc.h>\n\n#include \"dpaa2-ptp.h\"\n\nstatic int dpaa2_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t    struct ptp_clock_request *rq, int on)\n{\n\tstruct ptp_qoriq *ptp_qoriq = container_of(ptp, struct ptp_qoriq, caps);\n\tstruct fsl_mc_device *mc_dev;\n\tstruct device *dev;\n\tu32 mask = 0;\n\tu32 bit;\n\tint err;\n\n\tdev = ptp_qoriq->dev;\n\tmc_dev = to_fsl_mc_device(dev);\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\tswitch (rq->extts.index) {\n\t\tcase 0:\n\t\t\tbit = DPRTC_EVENT_ETS1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbit = DPRTC_EVENT_ETS2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (on)\n\t\t\textts_clean_up(ptp_qoriq, rq->extts.index, false);\n\t\tbreak;\n\tcase PTP_CLK_REQ_PPS:\n\t\tbit = DPRTC_EVENT_PPS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = dprtc_get_irq_mask(mc_dev->mc_io, 0, mc_dev->mc_handle,\n\t\t\t\t DPRTC_IRQ_INDEX, &mask);\n\tif (err < 0) {\n\t\tdev_err(dev, \"dprtc_get_irq_mask(): %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (on)\n\t\tmask |= bit;\n\telse\n\t\tmask &= ~bit;\n\n\terr = dprtc_set_irq_mask(mc_dev->mc_io, 0, mc_dev->mc_handle,\n\t\t\t\t DPRTC_IRQ_INDEX, mask);\n\tif (err < 0) {\n\t\tdev_err(dev, \"dprtc_set_irq_mask(): %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ptp_clock_info dpaa2_ptp_caps = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"DPAA2 PTP Clock\",\n\t.max_adj\t= 512000,\n\t.n_alarm\t= 2,\n\t.n_ext_ts\t= 2,\n\t.n_per_out\t= 3,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 1,\n\t.adjfine\t= ptp_qoriq_adjfine,\n\t.adjtime\t= ptp_qoriq_adjtime,\n\t.gettime64\t= ptp_qoriq_gettime,\n\t.settime64\t= ptp_qoriq_settime,\n\t.enable\t\t= dpaa2_ptp_enable,\n};\n\nstatic irqreturn_t dpaa2_ptp_irq_handler_thread(int irq, void *priv)\n{\n\tstruct ptp_qoriq *ptp_qoriq = priv;\n\tstruct ptp_clock_event event;\n\tstruct fsl_mc_device *mc_dev;\n\tstruct device *dev;\n\tu32 status = 0;\n\tint err;\n\n\tdev = ptp_qoriq->dev;\n\tmc_dev = to_fsl_mc_device(dev);\n\n\terr = dprtc_get_irq_status(mc_dev->mc_io, 0, mc_dev->mc_handle,\n\t\t\t\t   DPRTC_IRQ_INDEX, &status);\n\tif (unlikely(err)) {\n\t\tdev_err(dev, \"dprtc_get_irq_status err %d\\n\", err);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (status & DPRTC_EVENT_PPS) {\n\t\tevent.type = PTP_CLOCK_PPS;\n\t\tptp_clock_event(ptp_qoriq->clock, &event);\n\t}\n\n\tif (status & DPRTC_EVENT_ETS1)\n\t\textts_clean_up(ptp_qoriq, 0, true);\n\n\tif (status & DPRTC_EVENT_ETS2)\n\t\textts_clean_up(ptp_qoriq, 1, true);\n\n\terr = dprtc_clear_irq_status(mc_dev->mc_io, 0, mc_dev->mc_handle,\n\t\t\t\t     DPRTC_IRQ_INDEX, status);\n\tif (unlikely(err)) {\n\t\tdev_err(dev, \"dprtc_clear_irq_status err %d\\n\", err);\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dpaa2_ptp_probe(struct fsl_mc_device *mc_dev)\n{\n\tstruct device *dev = &mc_dev->dev;\n\tstruct ptp_qoriq *ptp_qoriq;\n\tstruct device_node *node;\n\tvoid __iomem *base;\n\tint err;\n\n\tptp_qoriq = devm_kzalloc(dev, sizeof(*ptp_qoriq), GFP_KERNEL);\n\tif (!ptp_qoriq)\n\t\treturn -ENOMEM;\n\n\terr = fsl_mc_portal_allocate(mc_dev, 0, &mc_dev->mc_io);\n\tif (err) {\n\t\tif (err == -ENXIO)\n\t\t\terr = -EPROBE_DEFER;\n\t\telse\n\t\t\tdev_err(dev, \"fsl_mc_portal_allocate err %d\\n\", err);\n\t\tgoto err_exit;\n\t}\n\n\terr = dprtc_open(mc_dev->mc_io, 0, mc_dev->obj_desc.id,\n\t\t\t &mc_dev->mc_handle);\n\tif (err) {\n\t\tdev_err(dev, \"dprtc_open err %d\\n\", err);\n\t\tgoto err_free_mcp;\n\t}\n\n\tptp_qoriq->dev = dev;\n\n\tnode = of_find_compatible_node(NULL, NULL, \"fsl,dpaa2-ptp\");\n\tif (!node) {\n\t\terr = -ENODEV;\n\t\tgoto err_close;\n\t}\n\n\tdev->of_node = node;\n\n\tbase = of_iomap(node, 0);\n\tif (!base) {\n\t\terr = -ENOMEM;\n\t\tgoto err_put;\n\t}\n\n\terr = fsl_mc_allocate_irqs(mc_dev);\n\tif (err) {\n\t\tdev_err(dev, \"MC irqs allocation failed\\n\");\n\t\tgoto err_unmap;\n\t}\n\n\tptp_qoriq->irq = mc_dev->irqs[0]->virq;\n\n\terr = request_threaded_irq(ptp_qoriq->irq, NULL,\n\t\t\t\t   dpaa2_ptp_irq_handler_thread,\n\t\t\t\t   IRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\t\t   dev_name(dev), ptp_qoriq);\n\tif (err < 0) {\n\t\tdev_err(dev, \"devm_request_threaded_irq(): %d\\n\", err);\n\t\tgoto err_free_mc_irq;\n\t}\n\n\terr = dprtc_set_irq_enable(mc_dev->mc_io, 0, mc_dev->mc_handle,\n\t\t\t\t   DPRTC_IRQ_INDEX, 1);\n\tif (err < 0) {\n\t\tdev_err(dev, \"dprtc_set_irq_enable(): %d\\n\", err);\n\t\tgoto err_free_threaded_irq;\n\t}\n\n\terr = ptp_qoriq_init(ptp_qoriq, base, &dpaa2_ptp_caps);\n\tif (err)\n\t\tgoto err_free_threaded_irq;\n\n\tdpaa2_phc_index = ptp_qoriq->phc_index;\n\tdpaa2_ptp = ptp_qoriq;\n\tdev_set_drvdata(dev, ptp_qoriq);\n\n\treturn 0;\n\nerr_free_threaded_irq:\n\tfree_irq(ptp_qoriq->irq, ptp_qoriq);\nerr_free_mc_irq:\n\tfsl_mc_free_irqs(mc_dev);\nerr_unmap:\n\tiounmap(base);\nerr_put:\n\tof_node_put(node);\nerr_close:\n\tdprtc_close(mc_dev->mc_io, 0, mc_dev->mc_handle);\nerr_free_mcp:\n\tfsl_mc_portal_free(mc_dev->mc_io);\nerr_exit:\n\treturn err;\n}\n\nstatic void dpaa2_ptp_remove(struct fsl_mc_device *mc_dev)\n{\n\tstruct device *dev = &mc_dev->dev;\n\tstruct ptp_qoriq *ptp_qoriq;\n\n\tptp_qoriq = dev_get_drvdata(dev);\n\n\tdpaa2_phc_index = -1;\n\tptp_qoriq_free(ptp_qoriq);\n\n\tfsl_mc_free_irqs(mc_dev);\n\tdprtc_close(mc_dev->mc_io, 0, mc_dev->mc_handle);\n\tfsl_mc_portal_free(mc_dev->mc_io);\n}\n\nstatic const struct fsl_mc_device_id dpaa2_ptp_match_id_table[] = {\n\t{\n\t\t.vendor = FSL_MC_VENDOR_FREESCALE,\n\t\t.obj_type = \"dprtc\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(fslmc, dpaa2_ptp_match_id_table);\n\nstatic struct fsl_mc_driver dpaa2_ptp_drv = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.owner = THIS_MODULE,\n\t},\n\t.probe = dpaa2_ptp_probe,\n\t.remove = dpaa2_ptp_remove,\n\t.match_id_table = dpaa2_ptp_match_id_table,\n};\n\nmodule_fsl_mc_driver(dpaa2_ptp_drv);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"DPAA2 PTP Clock Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}