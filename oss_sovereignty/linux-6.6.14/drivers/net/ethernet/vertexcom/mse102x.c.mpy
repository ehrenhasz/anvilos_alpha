{
  "module_name": "mse102x.c",
  "hash_id": "65a7c394728021c1e6eb301556e0cbd0a7b5e24d55949420733953e2fd3ef925",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/vertexcom/mse102x.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/cache.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\n#include <linux/spi/spi.h>\n#include <linux/of_net.h>\n\n#define MSG_DEFAULT\t(NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK | \\\n\t\t\t NETIF_MSG_TIMER)\n\n#define DRV_NAME\t\"mse102x\"\n\n#define DET_CMD\t\t0x0001\n#define DET_SOF\t\t0x0002\n#define DET_DFT\t\t0x55AA\n\n#define CMD_SHIFT\t12\n#define CMD_RTS\t\t(0x1 << CMD_SHIFT)\n#define CMD_CTR\t\t(0x2 << CMD_SHIFT)\n\n#define CMD_MASK\tGENMASK(15, CMD_SHIFT)\n#define LEN_MASK\tGENMASK(CMD_SHIFT - 1, 0)\n\n#define DET_CMD_LEN\t4\n#define DET_SOF_LEN\t2\n#define DET_DFT_LEN\t2\n\n#define MIN_FREQ_HZ\t6000000\n#define MAX_FREQ_HZ\t7142857\n\nstruct mse102x_stats {\n\tu64 xfer_err;\n\tu64 invalid_cmd;\n\tu64 invalid_ctr;\n\tu64 invalid_dft;\n\tu64 invalid_len;\n\tu64 invalid_rts;\n\tu64 invalid_sof;\n\tu64 tx_timeout;\n};\n\nstatic const char mse102x_gstrings_stats[][ETH_GSTRING_LEN] = {\n\t\"SPI transfer errors\",\n\t\"Invalid command\",\n\t\"Invalid CTR\",\n\t\"Invalid DFT\",\n\t\"Invalid frame length\",\n\t\"Invalid RTS\",\n\t\"Invalid SOF\",\n\t\"TX timeout\",\n};\n\nstruct mse102x_net {\n\tstruct net_device\t*ndev;\n\n\tu8\t\t\trxd[8];\n\tu8\t\t\ttxd[8];\n\n\tu32\t\t\tmsg_enable ____cacheline_aligned;\n\n\tstruct sk_buff_head\ttxq;\n\tstruct mse102x_stats\tstats;\n};\n\nstruct mse102x_net_spi {\n\tstruct mse102x_net\tmse102x;\n\tstruct mutex\t\tlock;\t\t \n\tstruct work_struct\ttx_work;\n\tstruct spi_device\t*spidev;\n\tstruct spi_message\tspi_msg;\n\tstruct spi_transfer\tspi_xfer;\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry\t\t*device_root;\n#endif\n};\n\n#define to_mse102x_spi(mse) container_of((mse), struct mse102x_net_spi, mse102x)\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic int mse102x_info_show(struct seq_file *s, void *what)\n{\n\tstruct mse102x_net_spi *mses = s->private;\n\n\tseq_printf(s, \"TX ring size        : %u\\n\",\n\t\t   skb_queue_len(&mses->mse102x.txq));\n\n\tseq_printf(s, \"IRQ                 : %d\\n\",\n\t\t   mses->spidev->irq);\n\n\tseq_printf(s, \"SPI effective speed : %lu\\n\",\n\t\t   (unsigned long)mses->spi_xfer.effective_speed_hz);\n\tseq_printf(s, \"SPI mode            : %x\\n\",\n\t\t   mses->spidev->mode);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(mse102x_info);\n\nstatic void mse102x_init_device_debugfs(struct mse102x_net_spi *mses)\n{\n\tmses->device_root = debugfs_create_dir(dev_name(&mses->mse102x.ndev->dev),\n\t\t\t\t\t       NULL);\n\n\tdebugfs_create_file(\"info\", S_IFREG | 0444, mses->device_root, mses,\n\t\t\t    &mse102x_info_fops);\n}\n\nstatic void mse102x_remove_device_debugfs(struct mse102x_net_spi *mses)\n{\n\tdebugfs_remove_recursive(mses->device_root);\n}\n\n#else  \n\nstatic void mse102x_init_device_debugfs(struct mse102x_net_spi *mses)\n{\n}\n\nstatic void mse102x_remove_device_debugfs(struct mse102x_net_spi *mses)\n{\n}\n\n#endif\n\n \n\nstatic void mse102x_tx_cmd_spi(struct mse102x_net *mse, u16 cmd)\n{\n\tstruct mse102x_net_spi *mses = to_mse102x_spi(mse);\n\tstruct spi_transfer *xfer = &mses->spi_xfer;\n\tstruct spi_message *msg = &mses->spi_msg;\n\t__be16 txb[2];\n\tint ret;\n\n\ttxb[0] = cpu_to_be16(DET_CMD);\n\ttxb[1] = cpu_to_be16(cmd);\n\n\txfer->tx_buf = txb;\n\txfer->rx_buf = NULL;\n\txfer->len = DET_CMD_LEN;\n\n\tret = spi_sync(mses->spidev, msg);\n\tif (ret < 0) {\n\t\tnetdev_err(mse->ndev, \"%s: spi_sync() failed: %d\\n\",\n\t\t\t   __func__, ret);\n\t\tmse->stats.xfer_err++;\n\t}\n}\n\nstatic int mse102x_rx_cmd_spi(struct mse102x_net *mse, u8 *rxb)\n{\n\tstruct mse102x_net_spi *mses = to_mse102x_spi(mse);\n\tstruct spi_transfer *xfer = &mses->spi_xfer;\n\tstruct spi_message *msg = &mses->spi_msg;\n\t__be16 *txb = (__be16 *)mse->txd;\n\t__be16 *cmd = (__be16 *)mse->rxd;\n\tu8 *trx = mse->rxd;\n\tint ret;\n\n\ttxb[0] = 0;\n\ttxb[1] = 0;\n\n\txfer->tx_buf = txb;\n\txfer->rx_buf = trx;\n\txfer->len = DET_CMD_LEN;\n\n\tret = spi_sync(mses->spidev, msg);\n\tif (ret < 0) {\n\t\tnetdev_err(mse->ndev, \"%s: spi_sync() failed: %d\\n\",\n\t\t\t   __func__, ret);\n\t\tmse->stats.xfer_err++;\n\t} else if (*cmd != cpu_to_be16(DET_CMD)) {\n\t\tnet_dbg_ratelimited(\"%s: Unexpected response (0x%04x)\\n\",\n\t\t\t\t    __func__, *cmd);\n\t\tmse->stats.invalid_cmd++;\n\t\tret = -EIO;\n\t} else {\n\t\tmemcpy(rxb, trx + 2, 2);\n\t}\n\n\treturn ret;\n}\n\nstatic inline void mse102x_push_header(struct sk_buff *skb)\n{\n\t__be16 *header = skb_push(skb, DET_SOF_LEN);\n\n\t*header = cpu_to_be16(DET_SOF);\n}\n\nstatic inline void mse102x_put_footer(struct sk_buff *skb)\n{\n\t__be16 *footer = skb_put(skb, DET_DFT_LEN);\n\n\t*footer = cpu_to_be16(DET_DFT);\n}\n\nstatic int mse102x_tx_frame_spi(struct mse102x_net *mse, struct sk_buff *txp,\n\t\t\t\tunsigned int pad)\n{\n\tstruct mse102x_net_spi *mses = to_mse102x_spi(mse);\n\tstruct spi_transfer *xfer = &mses->spi_xfer;\n\tstruct spi_message *msg = &mses->spi_msg;\n\tstruct sk_buff *tskb;\n\tint ret;\n\n\tnetif_dbg(mse, tx_queued, mse->ndev, \"%s: skb %p, %d@%p\\n\",\n\t\t  __func__, txp, txp->len, txp->data);\n\n\tif ((skb_headroom(txp) < DET_SOF_LEN) ||\n\t    (skb_tailroom(txp) < DET_DFT_LEN + pad)) {\n\t\ttskb = skb_copy_expand(txp, DET_SOF_LEN, DET_DFT_LEN + pad,\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!tskb)\n\t\t\treturn -ENOMEM;\n\n\t\tdev_kfree_skb(txp);\n\t\ttxp = tskb;\n\t}\n\n\tmse102x_push_header(txp);\n\n\tif (pad)\n\t\tskb_put_zero(txp, pad);\n\n\tmse102x_put_footer(txp);\n\n\txfer->tx_buf = txp->data;\n\txfer->rx_buf = NULL;\n\txfer->len = txp->len;\n\n\tret = spi_sync(mses->spidev, msg);\n\tif (ret < 0) {\n\t\tnetdev_err(mse->ndev, \"%s: spi_sync() failed: %d\\n\",\n\t\t\t   __func__, ret);\n\t\tmse->stats.xfer_err++;\n\t}\n\n\treturn ret;\n}\n\nstatic int mse102x_rx_frame_spi(struct mse102x_net *mse, u8 *buff,\n\t\t\t\tunsigned int frame_len)\n{\n\tstruct mse102x_net_spi *mses = to_mse102x_spi(mse);\n\tstruct spi_transfer *xfer = &mses->spi_xfer;\n\tstruct spi_message *msg = &mses->spi_msg;\n\t__be16 *sof = (__be16 *)buff;\n\t__be16 *dft = (__be16 *)(buff + DET_SOF_LEN + frame_len);\n\tint ret;\n\n\txfer->rx_buf = buff;\n\txfer->tx_buf = NULL;\n\txfer->len = DET_SOF_LEN + frame_len + DET_DFT_LEN;\n\n\tret = spi_sync(mses->spidev, msg);\n\tif (ret < 0) {\n\t\tnetdev_err(mse->ndev, \"%s: spi_sync() failed: %d\\n\",\n\t\t\t   __func__, ret);\n\t\tmse->stats.xfer_err++;\n\t} else if (*sof != cpu_to_be16(DET_SOF)) {\n\t\tnetdev_dbg(mse->ndev, \"%s: SPI start of frame is invalid (0x%04x)\\n\",\n\t\t\t   __func__, *sof);\n\t\tmse->stats.invalid_sof++;\n\t\tret = -EIO;\n\t} else if (*dft != cpu_to_be16(DET_DFT)) {\n\t\tnetdev_dbg(mse->ndev, \"%s: SPI frame tail is invalid (0x%04x)\\n\",\n\t\t\t   __func__, *dft);\n\t\tmse->stats.invalid_dft++;\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic void mse102x_dump_packet(const char *msg, int len, const char *data)\n{\n\tprintk(KERN_DEBUG \": %s - packet len:%d\\n\", msg, len);\n\tprint_hex_dump(KERN_DEBUG, \"pk data: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       data, len, true);\n}\n\nstatic void mse102x_rx_pkt_spi(struct mse102x_net *mse)\n{\n\tstruct sk_buff *skb;\n\tunsigned int rxalign;\n\tunsigned int rxlen;\n\t__be16 rx = 0;\n\tu16 cmd_resp;\n\tu8 *rxpkt;\n\tint ret;\n\n\tmse102x_tx_cmd_spi(mse, CMD_CTR);\n\tret = mse102x_rx_cmd_spi(mse, (u8 *)&rx);\n\tcmd_resp = be16_to_cpu(rx);\n\n\tif (ret || ((cmd_resp & CMD_MASK) != CMD_RTS)) {\n\t\tusleep_range(50, 100);\n\n\t\tmse102x_tx_cmd_spi(mse, CMD_CTR);\n\t\tret = mse102x_rx_cmd_spi(mse, (u8 *)&rx);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tcmd_resp = be16_to_cpu(rx);\n\t\tif ((cmd_resp & CMD_MASK) != CMD_RTS) {\n\t\t\tnet_dbg_ratelimited(\"%s: Unexpected response (0x%04x)\\n\",\n\t\t\t\t\t    __func__, cmd_resp);\n\t\t\tmse->stats.invalid_rts++;\n\t\t\treturn;\n\t\t}\n\n\t\tnet_dbg_ratelimited(\"%s: Unexpected response to first CMD\\n\",\n\t\t\t\t    __func__);\n\t}\n\n\trxlen = cmd_resp & LEN_MASK;\n\tif (!rxlen) {\n\t\tnet_dbg_ratelimited(\"%s: No frame length defined\\n\", __func__);\n\t\tmse->stats.invalid_len++;\n\t\treturn;\n\t}\n\n\trxalign = ALIGN(rxlen + DET_SOF_LEN + DET_DFT_LEN, 4);\n\tskb = netdev_alloc_skb_ip_align(mse->ndev, rxalign);\n\tif (!skb)\n\t\treturn;\n\n\t \n\trxpkt = skb_put(skb, rxlen) - DET_SOF_LEN;\n\tif (mse102x_rx_frame_spi(mse, rxpkt, rxlen)) {\n\t\tmse->ndev->stats.rx_errors++;\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (netif_msg_pktdata(mse))\n\t\tmse102x_dump_packet(__func__, skb->len, skb->data);\n\n\tskb->protocol = eth_type_trans(skb, mse->ndev);\n\tnetif_rx(skb);\n\n\tmse->ndev->stats.rx_packets++;\n\tmse->ndev->stats.rx_bytes += rxlen;\n}\n\nstatic int mse102x_tx_pkt_spi(struct mse102x_net *mse, struct sk_buff *txb,\n\t\t\t      unsigned long work_timeout)\n{\n\tunsigned int pad = 0;\n\t__be16 rx = 0;\n\tu16 cmd_resp;\n\tint ret;\n\tbool first = true;\n\n\tif (txb->len < 60)\n\t\tpad = 60 - txb->len;\n\n\twhile (1) {\n\t\tmse102x_tx_cmd_spi(mse, CMD_RTS | (txb->len + pad));\n\t\tret = mse102x_rx_cmd_spi(mse, (u8 *)&rx);\n\t\tcmd_resp = be16_to_cpu(rx);\n\n\t\tif (!ret) {\n\t\t\t \n\t\t\tif (cmd_resp == CMD_CTR)\n\t\t\t\tbreak;\n\n\t\t\tnet_dbg_ratelimited(\"%s: Unexpected response (0x%04x)\\n\",\n\t\t\t\t\t    __func__, cmd_resp);\n\t\t\tmse->stats.invalid_ctr++;\n\t\t}\n\n\t\t \n\t\tif (time_after(jiffies, work_timeout))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tif (first) {\n\t\t\t \n\t\t\tnetif_stop_queue(mse->ndev);\n\t\t\t \n\t\t\tusleep_range(50, 100);\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tmsleep(20);\n\t\t}\n\t}\n\n\tret = mse102x_tx_frame_spi(mse, txb, pad);\n\tif (ret)\n\t\tnet_dbg_ratelimited(\"%s: Failed to send (%d), drop frame\\n\",\n\t\t\t\t    __func__, ret);\n\n\treturn ret;\n}\n\n#define TX_QUEUE_MAX 10\n\nstatic void mse102x_tx_work(struct work_struct *work)\n{\n\t \n\tunsigned long work_timeout = jiffies + msecs_to_jiffies(1000);\n\tstruct mse102x_net_spi *mses;\n\tstruct mse102x_net *mse;\n\tstruct sk_buff *txb;\n\tint ret = 0;\n\n\tmses = container_of(work, struct mse102x_net_spi, tx_work);\n\tmse = &mses->mse102x;\n\n\twhile ((txb = skb_dequeue(&mse->txq))) {\n\t\tmutex_lock(&mses->lock);\n\t\tret = mse102x_tx_pkt_spi(mse, txb, work_timeout);\n\t\tmutex_unlock(&mses->lock);\n\t\tif (ret) {\n\t\t\tmse->ndev->stats.tx_dropped++;\n\t\t} else {\n\t\t\tmse->ndev->stats.tx_bytes += txb->len;\n\t\t\tmse->ndev->stats.tx_packets++;\n\t\t}\n\n\t\tdev_kfree_skb(txb);\n\t}\n\n\tif (ret == -ETIMEDOUT) {\n\t\tif (netif_msg_timer(mse))\n\t\t\tnetdev_err(mse->ndev, \"tx work timeout\\n\");\n\n\t\tmse->stats.tx_timeout++;\n\t}\n\n\tnetif_wake_queue(mse->ndev);\n}\n\nstatic netdev_tx_t mse102x_start_xmit_spi(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *ndev)\n{\n\tstruct mse102x_net *mse = netdev_priv(ndev);\n\tstruct mse102x_net_spi *mses = to_mse102x_spi(mse);\n\n\tnetif_dbg(mse, tx_queued, ndev,\n\t\t  \"%s: skb %p, %d@%p\\n\", __func__, skb, skb->len, skb->data);\n\n\tskb_queue_tail(&mse->txq, skb);\n\n\tif (skb_queue_len(&mse->txq) >= TX_QUEUE_MAX)\n\t\tnetif_stop_queue(ndev);\n\n\tschedule_work(&mses->tx_work);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void mse102x_init_mac(struct mse102x_net *mse, struct device_node *np)\n{\n\tstruct net_device *ndev = mse->ndev;\n\tint ret = of_get_ethdev_address(np, ndev);\n\n\tif (ret) {\n\t\teth_hw_addr_random(ndev);\n\t\tnetdev_err(ndev, \"Using random MAC address: %pM\\n\",\n\t\t\t   ndev->dev_addr);\n\t}\n}\n\n \nstatic irqreturn_t mse102x_irq(int irq, void *_mse)\n{\n\tstruct mse102x_net *mse = _mse;\n\tstruct mse102x_net_spi *mses = to_mse102x_spi(mse);\n\n\tmutex_lock(&mses->lock);\n\tmse102x_rx_pkt_spi(mse);\n\tmutex_unlock(&mses->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mse102x_net_open(struct net_device *ndev)\n{\n\tstruct mse102x_net *mse = netdev_priv(ndev);\n\tint ret;\n\n\tret = request_threaded_irq(ndev->irq, NULL, mse102x_irq, IRQF_ONESHOT,\n\t\t\t\t   ndev->name, mse);\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"Failed to get irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnetif_dbg(mse, ifup, ndev, \"opening\\n\");\n\n\tnetif_start_queue(ndev);\n\n\tnetif_carrier_on(ndev);\n\n\tnetif_dbg(mse, ifup, ndev, \"network device up\\n\");\n\n\treturn 0;\n}\n\nstatic int mse102x_net_stop(struct net_device *ndev)\n{\n\tstruct mse102x_net *mse = netdev_priv(ndev);\n\tstruct mse102x_net_spi *mses = to_mse102x_spi(mse);\n\n\tnetif_info(mse, ifdown, ndev, \"shutting down\\n\");\n\n\tnetif_carrier_off(mse->ndev);\n\n\t \n\tflush_work(&mses->tx_work);\n\n\tnetif_stop_queue(ndev);\n\n\tskb_queue_purge(&mse->txq);\n\n\tfree_irq(ndev->irq, mse);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops mse102x_netdev_ops = {\n\t.ndo_open\t\t= mse102x_net_open,\n\t.ndo_stop\t\t= mse102x_net_stop,\n\t.ndo_start_xmit\t\t= mse102x_start_xmit_spi,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n \n\nstatic void mse102x_get_drvinfo(struct net_device *ndev,\n\t\t\t\tstruct ethtool_drvinfo *di)\n{\n\tstrscpy(di->driver, DRV_NAME, sizeof(di->driver));\n\tstrscpy(di->bus_info, dev_name(ndev->dev.parent), sizeof(di->bus_info));\n}\n\nstatic u32 mse102x_get_msglevel(struct net_device *ndev)\n{\n\tstruct mse102x_net *mse = netdev_priv(ndev);\n\n\treturn mse->msg_enable;\n}\n\nstatic void mse102x_set_msglevel(struct net_device *ndev, u32 to)\n{\n\tstruct mse102x_net *mse = netdev_priv(ndev);\n\n\tmse->msg_enable = to;\n}\n\nstatic void mse102x_get_ethtool_stats(struct net_device *ndev,\n\t\t\t\t      struct ethtool_stats *estats, u64 *data)\n{\n\tstruct mse102x_net *mse = netdev_priv(ndev);\n\tstruct mse102x_stats *st = &mse->stats;\n\n\tmemcpy(data, st, ARRAY_SIZE(mse102x_gstrings_stats) * sizeof(u64));\n}\n\nstatic void mse102x_get_strings(struct net_device *ndev, u32 stringset, u8 *buf)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(buf, &mse102x_gstrings_stats,\n\t\t       sizeof(mse102x_gstrings_stats));\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nstatic int mse102x_get_sset_count(struct net_device *ndev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(mse102x_gstrings_stats);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct ethtool_ops mse102x_ethtool_ops = {\n\t.get_drvinfo\t\t= mse102x_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_msglevel\t\t= mse102x_get_msglevel,\n\t.set_msglevel\t\t= mse102x_set_msglevel,\n\t.get_ethtool_stats\t= mse102x_get_ethtool_stats,\n\t.get_strings\t\t= mse102x_get_strings,\n\t.get_sset_count\t\t= mse102x_get_sset_count,\n};\n\n \n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int mse102x_suspend(struct device *dev)\n{\n\tstruct mse102x_net *mse = dev_get_drvdata(dev);\n\tstruct net_device *ndev = mse->ndev;\n\n\tif (netif_running(ndev)) {\n\t\tnetif_device_detach(ndev);\n\t\tmse102x_net_stop(ndev);\n\t}\n\n\treturn 0;\n}\n\nstatic int mse102x_resume(struct device *dev)\n{\n\tstruct mse102x_net *mse = dev_get_drvdata(dev);\n\tstruct net_device *ndev = mse->ndev;\n\n\tif (netif_running(ndev)) {\n\t\tmse102x_net_open(ndev);\n\t\tnetif_device_attach(ndev);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(mse102x_pm_ops, mse102x_suspend, mse102x_resume);\n\nstatic int mse102x_probe_spi(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct mse102x_net_spi *mses;\n\tstruct net_device *ndev;\n\tstruct mse102x_net *mse;\n\tint ret;\n\n\tspi->bits_per_word = 8;\n\tspi->mode |= SPI_MODE_3;\n\t \n\tspi->master->min_speed_hz = MIN_FREQ_HZ;\n\n\tif (!spi->max_speed_hz)\n\t\tspi->max_speed_hz = MAX_FREQ_HZ;\n\n\tif (spi->max_speed_hz < MIN_FREQ_HZ ||\n\t    spi->max_speed_hz > MAX_FREQ_HZ) {\n\t\tdev_err(&spi->dev, \"SPI max frequency out of range (min: %u, max: %u)\\n\",\n\t\t\tMIN_FREQ_HZ, MAX_FREQ_HZ);\n\t\treturn -EINVAL;\n\t}\n\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"Unable to setup SPI device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tndev = devm_alloc_etherdev(dev, sizeof(struct mse102x_net_spi));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tndev->needed_tailroom += ALIGN(DET_DFT_LEN, 4);\n\tndev->needed_headroom += ALIGN(DET_SOF_LEN, 4);\n\tndev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tndev->tx_queue_len = 100;\n\n\tmse = netdev_priv(ndev);\n\tmses = to_mse102x_spi(mse);\n\n\tmses->spidev = spi;\n\tmutex_init(&mses->lock);\n\tINIT_WORK(&mses->tx_work, mse102x_tx_work);\n\n\t \n\tspi_message_init(&mses->spi_msg);\n\tspi_message_add_tail(&mses->spi_xfer, &mses->spi_msg);\n\n\tndev->irq = spi->irq;\n\tmse->ndev = ndev;\n\n\t \n\tmse->msg_enable = netif_msg_init(-1, MSG_DEFAULT);\n\n\tskb_queue_head_init(&mse->txq);\n\n\tSET_NETDEV_DEV(ndev, dev);\n\n\tdev_set_drvdata(dev, mse);\n\n\tnetif_carrier_off(mse->ndev);\n\tndev->netdev_ops = &mse102x_netdev_ops;\n\tndev->ethtool_ops = &mse102x_ethtool_ops;\n\n\tmse102x_init_mac(mse, dev->of_node);\n\n\tret = register_netdev(ndev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register network device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmse102x_init_device_debugfs(mses);\n\n\treturn 0;\n}\n\nstatic void mse102x_remove_spi(struct spi_device *spi)\n{\n\tstruct mse102x_net *mse = dev_get_drvdata(&spi->dev);\n\tstruct mse102x_net_spi *mses = to_mse102x_spi(mse);\n\n\tif (netif_msg_drv(mse))\n\t\tdev_info(&spi->dev, \"remove\\n\");\n\n\tmse102x_remove_device_debugfs(mses);\n\tunregister_netdev(mse->ndev);\n}\n\nstatic const struct of_device_id mse102x_match_table[] = {\n\t{ .compatible = \"vertexcom,mse1021\" },\n\t{ .compatible = \"vertexcom,mse1022\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mse102x_match_table);\n\nstatic const struct spi_device_id mse102x_ids[] = {\n\t{ \"mse1021\" },\n\t{ \"mse1022\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, mse102x_ids);\n\nstatic struct spi_driver mse102x_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = mse102x_match_table,\n\t\t.pm = &mse102x_pm_ops,\n\t},\n\t.probe = mse102x_probe_spi,\n\t.remove = mse102x_remove_spi,\n\t.id_table = mse102x_ids,\n};\nmodule_spi_driver(mse102x_driver);\n\nMODULE_DESCRIPTION(\"MSE102x Network driver\");\nMODULE_AUTHOR(\"Stefan Wahren <stefan.wahren@chargebyte.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}