{
  "module_name": "en_resources.c",
  "hash_id": "dcf2e80998f63fd29f30e256d22e6faa788f907ca8240e5810ed67f97e06ecb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/en_resources.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mlx4/qp.h>\n\n#include \"mlx4_en.h\"\n\nvoid mlx4_en_fill_qp_context(struct mlx4_en_priv *priv, int size, int stride,\n\t\t\t     int is_tx, int rss, int qpn, int cqn,\n\t\t\t     int user_prio, struct mlx4_qp_context *context)\n{\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct net_device *dev = priv->dev;\n\n\tmemset(context, 0, sizeof(*context));\n\tcontext->flags = cpu_to_be32(7 << 16 | rss << MLX4_RSS_QPC_FLAG_OFFSET);\n\tcontext->pd = cpu_to_be32(mdev->priv_pdn);\n\tcontext->mtu_msgmax = 0xff;\n\tif (!is_tx && !rss)\n\t\tcontext->rq_size_stride = ilog2(size) << 3 | (ilog2(stride) - 4);\n\tif (is_tx) {\n\t\tcontext->sq_size_stride = ilog2(size) << 3 | (ilog2(stride) - 4);\n\t\tif (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_PORT_REMAP)\n\t\t\tcontext->params2 |= cpu_to_be32(MLX4_QP_BIT_FPP);\n\n\t} else {\n\t\tcontext->sq_size_stride = ilog2(TXBB_SIZE) - 4;\n\t}\n\tcontext->usr_page = cpu_to_be32(mlx4_to_hw_uar_index(mdev->dev,\n\t\t\t\t\tmdev->priv_uar.index));\n\tcontext->local_qpn = cpu_to_be32(qpn);\n\tcontext->pri_path.ackto = 1 & 0x07;\n\tcontext->pri_path.sched_queue = 0x83 | (priv->port - 1) << 6;\n\t \n\tif (user_prio >= 0 && priv->prof->num_up == MLX4_EN_NUM_UP_HIGH) {\n\t\tcontext->pri_path.sched_queue |= user_prio << 3;\n\t\tcontext->pri_path.feup = MLX4_FEUP_FORCE_ETH_UP;\n\t}\n\tcontext->pri_path.counter_index = priv->counter_index;\n\tcontext->cqn_send = cpu_to_be32(cqn);\n\tcontext->cqn_recv = cpu_to_be32(cqn);\n\tif (!rss &&\n\t    (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_LB_SRC_CHK) &&\n\t    context->pri_path.counter_index !=\n\t\t\t    MLX4_SINK_COUNTER_INDEX(mdev->dev)) {\n\t\t \n\t\tif (!(dev->features & NETIF_F_LOOPBACK))\n\t\t\tcontext->pri_path.fl |= MLX4_FL_ETH_SRC_CHECK_MC_LB;\n\t\tcontext->pri_path.control |= MLX4_CTRL_ETH_SRC_CHECK_IF_COUNTER;\n\t}\n\tcontext->db_rec_addr = cpu_to_be64(priv->res.db.dma << 2);\n\tif (!(dev->features & NETIF_F_HW_VLAN_CTAG_RX))\n\t\tcontext->param3 |= cpu_to_be32(1 << 30);\n\n\tif (!is_tx && !rss &&\n\t    (mdev->dev->caps.tunnel_offload_mode ==  MLX4_TUNNEL_OFFLOAD_MODE_VXLAN)) {\n\t\ten_dbg(HW, priv, \"Setting RX qp %x tunnel mode to RX tunneled & non-tunneled\\n\", qpn);\n\t\tcontext->srqn = cpu_to_be32(7 << 28);  \n\t}\n}\n\nint mlx4_en_change_mcast_lb(struct mlx4_en_priv *priv, struct mlx4_qp *qp,\n\t\t\t    int loopback)\n{\n\tint ret;\n\tstruct mlx4_update_qp_params qp_params;\n\n\tmemset(&qp_params, 0, sizeof(qp_params));\n\tif (!loopback)\n\t\tqp_params.flags = MLX4_UPDATE_QP_PARAMS_FLAGS_ETH_CHECK_MC_LB;\n\n\tret = mlx4_update_qp(priv->mdev->dev, qp->qpn,\n\t\t\t     MLX4_UPDATE_QP_ETH_SRC_CHECK_MC_LB,\n\t\t\t     &qp_params);\n\n\treturn ret;\n}\n\nvoid mlx4_en_sqp_event(struct mlx4_qp *qp, enum mlx4_event event)\n{\n    return;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}