{
  "module_name": "en_main.c",
  "hash_id": "98ab9d45439b862229702bf807df4fee730cfa3c52de6f47a44ad718deda654e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/en_main.c",
  "human_readable_source": " \n\n#include <linux/cpumask.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n\n#include <linux/mlx4/driver.h>\n#include <linux/mlx4/device.h>\n#include <linux/mlx4/cmd.h>\n\n#include \"mlx4_en.h\"\n\nMODULE_AUTHOR(\"Liran Liss, Yevgeny Petrilin\");\nMODULE_DESCRIPTION(\"Mellanox ConnectX HCA Ethernet driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_VERSION(DRV_VERSION);\n\nstatic const char mlx4_en_version[] =\n\tDRV_NAME \": Mellanox ConnectX HCA Ethernet driver v\"\n\tDRV_VERSION \"\\n\";\n\n#define MLX4_EN_PARM_INT(X, def_val, desc) \\\n\tstatic unsigned int X = def_val;\\\n\tmodule_param(X , uint, 0444); \\\n\tMODULE_PARM_DESC(X, desc);\n\n\n \n\n \nMLX4_EN_PARM_INT(udp_rss, 1,\n\t\t \"Enable RSS for incoming UDP traffic or disabled (0)\");\n\n \nMLX4_EN_PARM_INT(pfctx, 0, \"Priority based Flow Control policy on TX[7:0].\"\n\t\t\t   \" Per priority bit mask\");\nMLX4_EN_PARM_INT(pfcrx, 0, \"Priority based Flow Control policy on RX[7:0].\"\n\t\t\t   \" Per priority bit mask\");\n\nMLX4_EN_PARM_INT(inline_thold, MAX_INLINE,\n\t\t \"Threshold for using inline data (range: 17-104, default: 104)\");\n\n#define MAX_PFC_TX     0xff\n#define MAX_PFC_RX     0xff\n\nvoid en_print(const char *level, const struct mlx4_en_priv *priv,\n\t      const char *format, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\n\tva_start(args, format);\n\n\tvaf.fmt = format;\n\tvaf.va = &args;\n\tif (priv->registered)\n\t\tprintk(\"%s%s: %s: %pV\",\n\t\t       level, DRV_NAME, priv->dev->name, &vaf);\n\telse\n\t\tprintk(\"%s%s: %s: Port %d: %pV\",\n\t\t       level, DRV_NAME, dev_name(&priv->mdev->pdev->dev),\n\t\t       priv->port, &vaf);\n\tva_end(args);\n}\n\nvoid mlx4_en_update_loopback_state(struct net_device *dev,\n\t\t\t\t   netdev_features_t features)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\tif (features & NETIF_F_LOOPBACK)\n\t\tpriv->ctrl_flags |= cpu_to_be32(MLX4_WQE_CTRL_FORCE_LOOPBACK);\n\telse\n\t\tpriv->ctrl_flags &= cpu_to_be32(~MLX4_WQE_CTRL_FORCE_LOOPBACK);\n\n\tpriv->flags &= ~(MLX4_EN_FLAG_RX_FILTER_NEEDED|\n\t\t\tMLX4_EN_FLAG_ENABLE_HW_LOOPBACK);\n\n\t \n\tif (mlx4_is_mfunc(priv->mdev->dev) &&\n\t    !(features & NETIF_F_LOOPBACK) && !priv->validate_loopback)\n\t\tpriv->flags |= MLX4_EN_FLAG_RX_FILTER_NEEDED;\n\n\t \n\tif (mlx4_is_mfunc(priv->mdev->dev) || priv->validate_loopback)\n\t\tpriv->flags |= MLX4_EN_FLAG_ENABLE_HW_LOOPBACK;\n\n\tmutex_lock(&priv->mdev->state_lock);\n\tif ((priv->mdev->dev->caps.flags2 &\n\t     MLX4_DEV_CAP_FLAG2_UPDATE_QP_SRC_CHECK_LB) &&\n\t    priv->rss_map.indir_qp && priv->rss_map.indir_qp->qpn) {\n\t\tint i;\n\t\tint err = 0;\n\t\tint loopback = !!(features & NETIF_F_LOOPBACK);\n\n\t\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\t\tint ret;\n\n\t\t\tret = mlx4_en_change_mcast_lb(priv,\n\t\t\t\t\t\t      &priv->rss_map.qps[i],\n\t\t\t\t\t\t      loopback);\n\t\t\tif (!err)\n\t\t\t\terr = ret;\n\t\t}\n\t\tif (err)\n\t\t\tmlx4_warn(priv->mdev, \"failed to change mcast loopback\\n\");\n\t}\n\tmutex_unlock(&priv->mdev->state_lock);\n}\n\nstatic void mlx4_en_get_profile(struct mlx4_en_dev *mdev)\n{\n\tstruct mlx4_en_profile *params = &mdev->profile;\n\tint i;\n\n\tparams->udp_rss = udp_rss;\n\tparams->max_num_tx_rings_p_up = mlx4_low_memory_profile() ?\n\t\tMLX4_EN_MIN_TX_RING_P_UP :\n\t\tmin_t(int, num_online_cpus(), MLX4_EN_MAX_TX_RING_P_UP);\n\n\tif (params->udp_rss && !(mdev->dev->caps.flags\n\t\t\t\t\t& MLX4_DEV_CAP_FLAG_UDP_RSS)) {\n\t\tmlx4_warn(mdev, \"UDP RSS is not supported on this device\\n\");\n\t\tparams->udp_rss = 0;\n\t}\n\tfor (i = 1; i <= MLX4_MAX_PORTS; i++) {\n\t\tparams->prof[i].rx_pause = !(pfcrx || pfctx);\n\t\tparams->prof[i].rx_ppp = pfcrx;\n\t\tparams->prof[i].tx_pause = !(pfcrx || pfctx);\n\t\tparams->prof[i].tx_ppp = pfctx;\n\t\tif (mlx4_low_memory_profile()) {\n\t\t\tparams->prof[i].tx_ring_size = MLX4_EN_MIN_TX_SIZE;\n\t\t\tparams->prof[i].rx_ring_size = MLX4_EN_MIN_RX_SIZE;\n\t\t} else {\n\t\t\tparams->prof[i].tx_ring_size = MLX4_EN_DEF_TX_RING_SIZE;\n\t\t\tparams->prof[i].rx_ring_size = MLX4_EN_DEF_RX_RING_SIZE;\n\t\t}\n\t\tparams->prof[i].num_up = MLX4_EN_NUM_UP_LOW;\n\t\tparams->prof[i].num_tx_rings_p_up = params->max_num_tx_rings_p_up;\n\t\tparams->prof[i].tx_ring_num[TX] = params->max_num_tx_rings_p_up *\n\t\t\tparams->prof[i].num_up;\n\t\tparams->prof[i].rss_rings = 0;\n\t\tparams->prof[i].inline_thold = inline_thold;\n\t}\n}\n\nstatic int mlx4_en_event(struct notifier_block *this, unsigned long event,\n\t\t\t void *param)\n{\n\tstruct mlx4_en_dev *mdev =\n\t\tcontainer_of(this, struct mlx4_en_dev, mlx_nb);\n\tstruct mlx4_dev *dev = mdev->dev;\n\tstruct mlx4_en_priv *priv;\n\tint port;\n\n\tswitch (event) {\n\tcase MLX4_DEV_EVENT_CATASTROPHIC_ERROR:\n\tcase MLX4_DEV_EVENT_PORT_MGMT_CHANGE:\n\tcase MLX4_DEV_EVENT_SLAVE_INIT:\n\tcase MLX4_DEV_EVENT_SLAVE_SHUTDOWN:\n\t\tbreak;\n\tdefault:\n\t\tport = *(int *)param;\n\t\tbreak;\n\t}\n\n\tswitch (event) {\n\tcase MLX4_DEV_EVENT_PORT_UP:\n\tcase MLX4_DEV_EVENT_PORT_DOWN:\n\t\tif (!mdev->pndev[port])\n\t\t\treturn NOTIFY_DONE;\n\t\tpriv = netdev_priv(mdev->pndev[port]);\n\t\t \n\t\tpriv->link_state = event;\n\t\tqueue_work(mdev->workqueue, &priv->linkstate_task);\n\t\tbreak;\n\n\tcase MLX4_DEV_EVENT_CATASTROPHIC_ERROR:\n\t\tmlx4_err(mdev, \"Internal error detected, restarting device\\n\");\n\t\tbreak;\n\n\tcase MLX4_DEV_EVENT_PORT_MGMT_CHANGE:\n\tcase MLX4_DEV_EVENT_SLAVE_INIT:\n\tcase MLX4_DEV_EVENT_SLAVE_SHUTDOWN:\n\t\tbreak;\n\tdefault:\n\t\tif (port < 1 || port > dev->caps.num_ports ||\n\t\t    !mdev->pndev[port])\n\t\t\treturn NOTIFY_DONE;\n\t\tmlx4_warn(mdev, \"Unhandled event %d for port %d\\n\", (int)event,\n\t\t\t  port);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void mlx4_en_remove(struct auxiliary_device *adev)\n{\n\tstruct mlx4_adev *madev = container_of(adev, struct mlx4_adev, adev);\n\tstruct mlx4_dev *dev = madev->mdev;\n\tstruct mlx4_en_dev *mdev = auxiliary_get_drvdata(adev);\n\tint i;\n\n\tmlx4_unregister_event_notifier(dev, &mdev->mlx_nb);\n\n\tmutex_lock(&mdev->state_lock);\n\tmdev->device_up = false;\n\tmutex_unlock(&mdev->state_lock);\n\n\tmlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH)\n\t\tif (mdev->pndev[i])\n\t\t\tmlx4_en_destroy_netdev(mdev->pndev[i]);\n\n\tdestroy_workqueue(mdev->workqueue);\n\t(void) mlx4_mr_free(dev, &mdev->mr);\n\tiounmap(mdev->uar_map);\n\tmlx4_uar_free(dev, &mdev->priv_uar);\n\tmlx4_pd_free(dev, mdev->priv_pdn);\n\tif (mdev->netdev_nb.notifier_call)\n\t\tunregister_netdevice_notifier(&mdev->netdev_nb);\n\tkfree(mdev);\n}\n\nstatic int mlx4_en_probe(struct auxiliary_device *adev,\n\t\t\t const struct auxiliary_device_id *id)\n{\n\tstruct mlx4_adev *madev = container_of(adev, struct mlx4_adev, adev);\n\tstruct mlx4_dev *dev = madev->mdev;\n\tstruct mlx4_en_dev *mdev;\n\tint err, i;\n\n\tprintk_once(KERN_INFO \"%s\", mlx4_en_version);\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_res;\n\t}\n\n\terr = mlx4_pd_alloc(dev, &mdev->priv_pdn);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\terr = mlx4_uar_alloc(dev, &mdev->priv_uar);\n\tif (err)\n\t\tgoto err_pd;\n\n\tmdev->uar_map = ioremap((phys_addr_t) mdev->priv_uar.pfn << PAGE_SHIFT,\n\t\t\t\tPAGE_SIZE);\n\tif (!mdev->uar_map) {\n\t\terr = -ENOMEM;\n\t\tgoto err_uar;\n\t}\n\tspin_lock_init(&mdev->uar_lock);\n\n\tmdev->dev = dev;\n\tmdev->dma_device = &dev->persist->pdev->dev;\n\tmdev->pdev = dev->persist->pdev;\n\tmdev->device_up = false;\n\n\tmdev->LSO_support = !!(dev->caps.flags & (1 << 15));\n\tif (!mdev->LSO_support)\n\t\tmlx4_warn(mdev, \"LSO not supported, please upgrade to later FW version to enable LSO\\n\");\n\n\terr = mlx4_mr_alloc(mdev->dev, mdev->priv_pdn, 0, ~0ull,\n\t\t\t    MLX4_PERM_LOCAL_WRITE | MLX4_PERM_LOCAL_READ, 0, 0,\n\t\t\t    &mdev->mr);\n\tif (err) {\n\t\tmlx4_err(mdev, \"Failed allocating memory region\\n\");\n\t\tgoto err_map;\n\t}\n\terr = mlx4_mr_enable(mdev->dev, &mdev->mr);\n\tif (err) {\n\t\tmlx4_err(mdev, \"Failed enabling memory region\\n\");\n\t\tgoto err_mr;\n\t}\n\n\t \n\tmlx4_en_get_profile(mdev);\n\n\t \n\tmdev->port_cnt = 0;\n\tmlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH)\n\t\tmdev->port_cnt++;\n\n\t \n\tmlx4_en_set_num_rx_rings(mdev);\n\n\t \n\tmdev->workqueue = create_singlethread_workqueue(\"mlx4_en\");\n\tif (!mdev->workqueue) {\n\t\terr = -ENOMEM;\n\t\tgoto err_mr;\n\t}\n\n\t \n\tmutex_init(&mdev->state_lock);\n\tmdev->device_up = true;\n\n\t \n\tmdev->mlx_nb.notifier_call = mlx4_en_event;\n\terr = mlx4_register_event_notifier(dev, &mdev->mlx_nb);\n\tWARN(err, \"failed to register mlx4 event notifier (%d)\", err);\n\n\t \n\n\t \n\tmlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH) {\n\t\tmlx4_info(mdev, \"Activating port:%d\\n\", i);\n\t\tif (mlx4_en_init_netdev(mdev, i, &mdev->profile.prof[i]))\n\t\t\tmdev->pndev[i] = NULL;\n\t}\n\n\t \n\tmdev->netdev_nb.notifier_call = mlx4_en_netdev_event;\n\tif (register_netdevice_notifier(&mdev->netdev_nb)) {\n\t\tmdev->netdev_nb.notifier_call = NULL;\n\t\tmlx4_err(mdev, \"Failed to create netdev notifier\\n\");\n\t}\n\n\tauxiliary_set_drvdata(adev, mdev);\n\treturn 0;\n\nerr_mr:\n\t(void) mlx4_mr_free(dev, &mdev->mr);\nerr_map:\n\tif (mdev->uar_map)\n\t\tiounmap(mdev->uar_map);\nerr_uar:\n\tmlx4_uar_free(dev, &mdev->priv_uar);\nerr_pd:\n\tmlx4_pd_free(dev, mdev->priv_pdn);\nerr_free_dev:\n\tkfree(mdev);\nerr_free_res:\n\treturn err;\n}\n\nstatic const struct auxiliary_device_id mlx4_en_id_table[] = {\n\t{ .name = MLX4_ADEV_NAME \".eth\" },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(auxiliary, mlx4_en_id_table);\n\nstatic struct mlx4_adrv mlx4_en_adrv = {\n\t.adrv = {\n\t\t.name\t= \"eth\",\n\t\t.probe\t= mlx4_en_probe,\n\t\t.remove\t= mlx4_en_remove,\n\t\t.id_table = mlx4_en_id_table,\n\t},\n\t.protocol\t= MLX4_PROT_ETH,\n};\n\nstatic void mlx4_en_verify_params(void)\n{\n\tif (pfctx > MAX_PFC_TX) {\n\t\tpr_warn(\"mlx4_en: WARNING: illegal module parameter pfctx 0x%x - should be in range 0-0x%x, will be changed to default (0)\\n\",\n\t\t\tpfctx, MAX_PFC_TX);\n\t\tpfctx = 0;\n\t}\n\n\tif (pfcrx > MAX_PFC_RX) {\n\t\tpr_warn(\"mlx4_en: WARNING: illegal module parameter pfcrx 0x%x - should be in range 0-0x%x, will be changed to default (0)\\n\",\n\t\t\tpfcrx, MAX_PFC_RX);\n\t\tpfcrx = 0;\n\t}\n\n\tif (inline_thold < MIN_PKT_LEN || inline_thold > MAX_INLINE) {\n\t\tpr_warn(\"mlx4_en: WARNING: illegal module parameter inline_thold %d - should be in range %d-%d, will be changed to default (%d)\\n\",\n\t\t\tinline_thold, MIN_PKT_LEN, MAX_INLINE, MAX_INLINE);\n\t\tinline_thold = MAX_INLINE;\n\t}\n}\n\nstatic int __init mlx4_en_init(void)\n{\n\tmlx4_en_verify_params();\n\tmlx4_en_init_ptys2ethtool_map();\n\n\treturn mlx4_register_auxiliary_driver(&mlx4_en_adrv);\n}\n\nstatic void __exit mlx4_en_cleanup(void)\n{\n\tmlx4_unregister_auxiliary_driver(&mlx4_en_adrv);\n}\n\nmodule_init(mlx4_en_init);\nmodule_exit(mlx4_en_cleanup);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}