{
  "module_name": "en_clock.c",
  "hash_id": "64551133a1adfd7cce0597da128c572e6b85c80a38bf0142ccc344c8571e4fa4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/en_clock.c",
  "human_readable_source": " \n\n#include <linux/mlx4/device.h>\n#include <linux/clocksource.h>\n\n#include \"mlx4_en.h\"\n\n \nstatic u64 mlx4_en_read_clock(const struct cyclecounter *tc)\n{\n\tstruct mlx4_en_dev *mdev =\n\t\tcontainer_of(tc, struct mlx4_en_dev, cycles);\n\tstruct mlx4_dev *dev = mdev->dev;\n\n\treturn mlx4_read_clock(dev) & tc->mask;\n}\n\nu64 mlx4_en_get_cqe_ts(struct mlx4_cqe *cqe)\n{\n\tu64 hi, lo;\n\tstruct mlx4_ts_cqe *ts_cqe = (struct mlx4_ts_cqe *)cqe;\n\n\tlo = (u64)be16_to_cpu(ts_cqe->timestamp_lo);\n\thi = ((u64)be32_to_cpu(ts_cqe->timestamp_hi) + !lo) << 16;\n\n\treturn hi | lo;\n}\n\nu64 mlx4_en_get_hwtstamp(struct mlx4_en_dev *mdev, u64 timestamp)\n{\n\tunsigned int seq;\n\tu64 nsec;\n\n\tdo {\n\t\tseq = read_seqbegin(&mdev->clock_lock);\n\t\tnsec = timecounter_cyc2time(&mdev->clock, timestamp);\n\t} while (read_seqretry(&mdev->clock_lock, seq));\n\n\treturn ns_to_ktime(nsec);\n}\n\nvoid mlx4_en_fill_hwtstamps(struct mlx4_en_dev *mdev,\n\t\t\t    struct skb_shared_hwtstamps *hwts,\n\t\t\t    u64 timestamp)\n{\n\tmemset(hwts, 0, sizeof(struct skb_shared_hwtstamps));\n\thwts->hwtstamp = mlx4_en_get_hwtstamp(mdev, timestamp);\n}\n\n \nvoid mlx4_en_remove_timestamp(struct mlx4_en_dev *mdev)\n{\n\tif (mdev->ptp_clock) {\n\t\tptp_clock_unregister(mdev->ptp_clock);\n\t\tmdev->ptp_clock = NULL;\n\t\tmlx4_info(mdev, \"removed PHC\\n\");\n\t}\n}\n\n#define MLX4_EN_WRAP_AROUND_SEC\t10UL\n \n#define MLX4_EN_OVERFLOW_PERIOD (MLX4_EN_WRAP_AROUND_SEC * HZ / 2)\n\nvoid mlx4_en_ptp_overflow_check(struct mlx4_en_dev *mdev)\n{\n\tbool timeout = time_is_before_jiffies(mdev->last_overflow_check +\n\t\t\t\t\t      MLX4_EN_OVERFLOW_PERIOD);\n\tunsigned long flags;\n\n\tif (timeout) {\n\t\twrite_seqlock_irqsave(&mdev->clock_lock, flags);\n\t\ttimecounter_read(&mdev->clock);\n\t\twrite_sequnlock_irqrestore(&mdev->clock_lock, flags);\n\t\tmdev->last_overflow_check = jiffies;\n\t}\n}\n\n \nstatic int mlx4_en_phc_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tu32 mult;\n\tunsigned long flags;\n\tstruct mlx4_en_dev *mdev = container_of(ptp, struct mlx4_en_dev,\n\t\t\t\t\t\tptp_clock_info);\n\n\tmult = (u32)adjust_by_scaled_ppm(mdev->nominal_c_mult, scaled_ppm);\n\n\twrite_seqlock_irqsave(&mdev->clock_lock, flags);\n\ttimecounter_read(&mdev->clock);\n\tmdev->cycles.mult = mult;\n\twrite_sequnlock_irqrestore(&mdev->clock_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int mlx4_en_phc_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct mlx4_en_dev *mdev = container_of(ptp, struct mlx4_en_dev,\n\t\t\t\t\t\tptp_clock_info);\n\tunsigned long flags;\n\n\twrite_seqlock_irqsave(&mdev->clock_lock, flags);\n\ttimecounter_adjtime(&mdev->clock, delta);\n\twrite_sequnlock_irqrestore(&mdev->clock_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int mlx4_en_phc_gettime(struct ptp_clock_info *ptp,\n\t\t\t       struct timespec64 *ts)\n{\n\tstruct mlx4_en_dev *mdev = container_of(ptp, struct mlx4_en_dev,\n\t\t\t\t\t\tptp_clock_info);\n\tunsigned long flags;\n\tu64 ns;\n\n\twrite_seqlock_irqsave(&mdev->clock_lock, flags);\n\tns = timecounter_read(&mdev->clock);\n\twrite_sequnlock_irqrestore(&mdev->clock_lock, flags);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\n \nstatic int mlx4_en_phc_settime(struct ptp_clock_info *ptp,\n\t\t\t       const struct timespec64 *ts)\n{\n\tstruct mlx4_en_dev *mdev = container_of(ptp, struct mlx4_en_dev,\n\t\t\t\t\t\tptp_clock_info);\n\tu64 ns = timespec64_to_ns(ts);\n\tunsigned long flags;\n\n\t \n\twrite_seqlock_irqsave(&mdev->clock_lock, flags);\n\ttimecounter_init(&mdev->clock, &mdev->cycles, ns);\n\twrite_sequnlock_irqrestore(&mdev->clock_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int mlx4_en_phc_enable(struct ptp_clock_info __always_unused *ptp,\n\t\t\t      struct ptp_clock_request __always_unused *request,\n\t\t\t      int __always_unused on)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct ptp_clock_info mlx4_en_ptp_clock_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.max_adj\t= 100000000,\n\t.n_alarm\t= 0,\n\t.n_ext_ts\t= 0,\n\t.n_per_out\t= 0,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 0,\n\t.adjfine\t= mlx4_en_phc_adjfine,\n\t.adjtime\t= mlx4_en_phc_adjtime,\n\t.gettime64\t= mlx4_en_phc_gettime,\n\t.settime64\t= mlx4_en_phc_settime,\n\t.enable\t\t= mlx4_en_phc_enable,\n};\n\n\n \nstatic u32 freq_to_shift(u16 freq)\n{\n\tu32 freq_khz = freq * 1000;\n\tu64 max_val_cycles = freq_khz * 1000 * MLX4_EN_WRAP_AROUND_SEC;\n\tu64 max_val_cycles_rounded = 1ULL << fls64(max_val_cycles - 1);\n\t \n\tu64 max_mul = div64_u64(ULLONG_MAX, max_val_cycles_rounded);\n\n\t \n\treturn ilog2(div_u64(max_mul * freq_khz, 1000000));\n}\n\nvoid mlx4_en_init_timestamp(struct mlx4_en_dev *mdev)\n{\n\tstruct mlx4_dev *dev = mdev->dev;\n\tunsigned long flags;\n\n\t \n\tif (mdev->ptp_clock)\n\t\treturn;\n\n\tseqlock_init(&mdev->clock_lock);\n\n\tmemset(&mdev->cycles, 0, sizeof(mdev->cycles));\n\tmdev->cycles.read = mlx4_en_read_clock;\n\tmdev->cycles.mask = CLOCKSOURCE_MASK(48);\n\tmdev->cycles.shift = freq_to_shift(dev->caps.hca_core_clock);\n\tmdev->cycles.mult =\n\t\tclocksource_khz2mult(1000 * dev->caps.hca_core_clock, mdev->cycles.shift);\n\tmdev->nominal_c_mult = mdev->cycles.mult;\n\n\twrite_seqlock_irqsave(&mdev->clock_lock, flags);\n\ttimecounter_init(&mdev->clock, &mdev->cycles,\n\t\t\t ktime_to_ns(ktime_get_real()));\n\twrite_sequnlock_irqrestore(&mdev->clock_lock, flags);\n\n\t \n\tmdev->ptp_clock_info = mlx4_en_ptp_clock_info;\n\tsnprintf(mdev->ptp_clock_info.name, 16, \"mlx4 ptp\");\n\n\tmdev->ptp_clock = ptp_clock_register(&mdev->ptp_clock_info,\n\t\t\t\t\t     &mdev->pdev->dev);\n\tif (IS_ERR(mdev->ptp_clock)) {\n\t\tmdev->ptp_clock = NULL;\n\t\tmlx4_err(mdev, \"ptp_clock_register failed\\n\");\n\t} else if (mdev->ptp_clock) {\n\t\tmlx4_info(mdev, \"registered PHC clock\\n\");\n\t}\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}