{
  "module_name": "icm.h",
  "hash_id": "c90f08b7fe616d7f60c70054bd195a2fcec75afffabe579fc7beda830d30aa36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/icm.h",
  "human_readable_source": " \n\n#ifndef MLX4_ICM_H\n#define MLX4_ICM_H\n\n#include <linux/list.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n\n#define MLX4_ICM_CHUNK_LEN\t\t\t\t\t\t\\\n\t((256 - sizeof(struct list_head) - 2 * sizeof(int)) /\t\t\\\n\t (sizeof(struct scatterlist)))\n\nenum {\n\tMLX4_ICM_PAGE_SHIFT\t= 12,\n\tMLX4_ICM_PAGE_SIZE\t= 1 << MLX4_ICM_PAGE_SHIFT,\n};\n\nstruct mlx4_icm_buf {\n\tvoid\t\t\t*addr;\n\tsize_t\t\t\tsize;\n\tdma_addr_t\t\tdma_addr;\n};\n\nstruct mlx4_icm_chunk {\n\tstruct list_head\tlist;\n\tint\t\t\tnpages;\n\tint\t\t\tnsg;\n\tbool\t\t\tcoherent;\n\tunion {\n\t\tstruct scatterlist\tsg[MLX4_ICM_CHUNK_LEN];\n\t\tstruct mlx4_icm_buf\tbuf[MLX4_ICM_CHUNK_LEN];\n\t};\n};\n\nstruct mlx4_icm {\n\tstruct list_head\tchunk_list;\n\tint\t\t\trefcount;\n};\n\nstruct mlx4_icm_iter {\n\tstruct mlx4_icm\t       *icm;\n\tstruct mlx4_icm_chunk  *chunk;\n\tint\t\t\tpage_idx;\n};\n\nstruct mlx4_dev;\n\nstruct mlx4_icm *mlx4_alloc_icm(struct mlx4_dev *dev, int npages,\n\t\t\t\tgfp_t gfp_mask, int coherent);\nvoid mlx4_free_icm(struct mlx4_dev *dev, struct mlx4_icm *icm, int coherent);\n\nint mlx4_table_get(struct mlx4_dev *dev, struct mlx4_icm_table *table, u32 obj);\nvoid mlx4_table_put(struct mlx4_dev *dev, struct mlx4_icm_table *table, u32 obj);\nint mlx4_table_get_range(struct mlx4_dev *dev, struct mlx4_icm_table *table,\n\t\t\t u32 start, u32 end);\nvoid mlx4_table_put_range(struct mlx4_dev *dev, struct mlx4_icm_table *table,\n\t\t\t  u32 start, u32 end);\nint mlx4_init_icm_table(struct mlx4_dev *dev, struct mlx4_icm_table *table,\n\t\t\tu64 virt, int obj_size,\tu32 nobj, int reserved,\n\t\t\tint use_lowmem, int use_coherent);\nvoid mlx4_cleanup_icm_table(struct mlx4_dev *dev, struct mlx4_icm_table *table);\nvoid *mlx4_table_find(struct mlx4_icm_table *table, u32 obj, dma_addr_t *dma_handle);\n\nstatic inline void mlx4_icm_first(struct mlx4_icm *icm,\n\t\t\t\t  struct mlx4_icm_iter *iter)\n{\n\titer->icm      = icm;\n\titer->chunk    = list_empty(&icm->chunk_list) ?\n\t\tNULL : list_entry(icm->chunk_list.next,\n\t\t\t\t  struct mlx4_icm_chunk, list);\n\titer->page_idx = 0;\n}\n\nstatic inline int mlx4_icm_last(struct mlx4_icm_iter *iter)\n{\n\treturn !iter->chunk;\n}\n\nstatic inline void mlx4_icm_next(struct mlx4_icm_iter *iter)\n{\n\tif (++iter->page_idx >= iter->chunk->nsg) {\n\t\tif (iter->chunk->list.next == &iter->icm->chunk_list) {\n\t\t\titer->chunk = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\titer->chunk = list_entry(iter->chunk->list.next,\n\t\t\t\t\t struct mlx4_icm_chunk, list);\n\t\titer->page_idx = 0;\n\t}\n}\n\nstatic inline dma_addr_t mlx4_icm_addr(struct mlx4_icm_iter *iter)\n{\n\tif (iter->chunk->coherent)\n\t\treturn iter->chunk->buf[iter->page_idx].dma_addr;\n\telse\n\t\treturn sg_dma_address(&iter->chunk->sg[iter->page_idx]);\n}\n\nstatic inline unsigned long mlx4_icm_size(struct mlx4_icm_iter *iter)\n{\n\tif (iter->chunk->coherent)\n\t\treturn iter->chunk->buf[iter->page_idx].size;\n\telse\n\t\treturn sg_dma_len(&iter->chunk->sg[iter->page_idx]);\n}\n\nint mlx4_MAP_ICM_AUX(struct mlx4_dev *dev, struct mlx4_icm *icm);\nint mlx4_UNMAP_ICM_AUX(struct mlx4_dev *dev);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}