{
  "module_name": "profile.c",
  "hash_id": "17c5239fc9074bbd3a259ea6f8fa934682b84fe0a8967e8588fe9ff7298af4a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/profile.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n\n#include \"mlx4.h\"\n#include \"fw.h\"\n\nenum {\n\tMLX4_RES_QP,\n\tMLX4_RES_RDMARC,\n\tMLX4_RES_ALTC,\n\tMLX4_RES_AUXC,\n\tMLX4_RES_SRQ,\n\tMLX4_RES_CQ,\n\tMLX4_RES_EQ,\n\tMLX4_RES_DMPT,\n\tMLX4_RES_CMPT,\n\tMLX4_RES_MTT,\n\tMLX4_RES_MCG,\n\tMLX4_RES_NUM\n};\n\nstatic const char *res_name[] = {\n\t[MLX4_RES_QP]\t\t= \"QP\",\n\t[MLX4_RES_RDMARC]\t= \"RDMARC\",\n\t[MLX4_RES_ALTC]\t\t= \"ALTC\",\n\t[MLX4_RES_AUXC]\t\t= \"AUXC\",\n\t[MLX4_RES_SRQ]\t\t= \"SRQ\",\n\t[MLX4_RES_CQ]\t\t= \"CQ\",\n\t[MLX4_RES_EQ]\t\t= \"EQ\",\n\t[MLX4_RES_DMPT]\t\t= \"DMPT\",\n\t[MLX4_RES_CMPT]\t\t= \"CMPT\",\n\t[MLX4_RES_MTT]\t\t= \"MTT\",\n\t[MLX4_RES_MCG]\t\t= \"MCG\",\n};\n\nu64 mlx4_make_profile(struct mlx4_dev *dev,\n\t\t      struct mlx4_profile *request,\n\t\t      struct mlx4_dev_cap *dev_cap,\n\t\t      struct mlx4_init_hca_param *init_hca)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_resource {\n\t\tu64 size;\n\t\tu64 start;\n\t\tint type;\n\t\tu32 num;\n\t\tint log_num;\n\t};\n\n\tu64 total_size = 0;\n\tstruct mlx4_resource *profile;\n\tstruct sysinfo si;\n\tint i, j;\n\n\tprofile = kcalloc(MLX4_RES_NUM, sizeof(*profile), GFP_KERNEL);\n\tif (!profile)\n\t\treturn -ENOMEM;\n\n\t \n\tsi_meminfo(&si);\n\trequest->num_mtt =\n\t\troundup_pow_of_two(max_t(unsigned, request->num_mtt,\n\t\t\t\t\t min(1UL << (31 - log_mtts_per_seg),\n\t\t\t\t\t     (si.totalram << 1) >> log_mtts_per_seg)));\n\n\n\tprofile[MLX4_RES_QP].size     = dev_cap->qpc_entry_sz;\n\tprofile[MLX4_RES_RDMARC].size = dev_cap->rdmarc_entry_sz;\n\tprofile[MLX4_RES_ALTC].size   = dev_cap->altc_entry_sz;\n\tprofile[MLX4_RES_AUXC].size   = dev_cap->aux_entry_sz;\n\tprofile[MLX4_RES_SRQ].size    = dev_cap->srq_entry_sz;\n\tprofile[MLX4_RES_CQ].size     = dev_cap->cqc_entry_sz;\n\tprofile[MLX4_RES_EQ].size     = dev_cap->eqc_entry_sz;\n\tprofile[MLX4_RES_DMPT].size   = dev_cap->dmpt_entry_sz;\n\tprofile[MLX4_RES_CMPT].size   = dev_cap->cmpt_entry_sz;\n\tprofile[MLX4_RES_MTT].size    = dev_cap->mtt_entry_sz;\n\tprofile[MLX4_RES_MCG].size    = mlx4_get_mgm_entry_size(dev);\n\n\tprofile[MLX4_RES_QP].num      = request->num_qp;\n\tprofile[MLX4_RES_RDMARC].num  = request->num_qp * request->rdmarc_per_qp;\n\tprofile[MLX4_RES_ALTC].num    = request->num_qp;\n\tprofile[MLX4_RES_AUXC].num    = request->num_qp;\n\tprofile[MLX4_RES_SRQ].num     = request->num_srq;\n\tprofile[MLX4_RES_CQ].num      = request->num_cq;\n\tprofile[MLX4_RES_EQ].num = mlx4_is_mfunc(dev) ? dev->phys_caps.num_phys_eqs :\n\t\t\t\t\tmin_t(unsigned, dev_cap->max_eqs, MAX_MSIX);\n\tprofile[MLX4_RES_DMPT].num    = request->num_mpt;\n\tprofile[MLX4_RES_CMPT].num    = MLX4_NUM_CMPTS;\n\tprofile[MLX4_RES_MTT].num     = request->num_mtt * (1 << log_mtts_per_seg);\n\tprofile[MLX4_RES_MCG].num     = request->num_mcg;\n\n\tfor (i = 0; i < MLX4_RES_NUM; ++i) {\n\t\tprofile[i].type     = i;\n\t\tprofile[i].num      = roundup_pow_of_two(profile[i].num);\n\t\tprofile[i].log_num  = ilog2(profile[i].num);\n\t\tprofile[i].size    *= profile[i].num;\n\t\tprofile[i].size     = max(profile[i].size, (u64) PAGE_SIZE);\n\t}\n\n\t \n\tfor (i = MLX4_RES_NUM; i > 0; --i)\n\t\tfor (j = 1; j < i; ++j) {\n\t\t\tif (profile[j].size > profile[j - 1].size)\n\t\t\t\tswap(profile[j], profile[j - 1]);\n\t\t}\n\n\tfor (i = 0; i < MLX4_RES_NUM; ++i) {\n\t\tif (profile[i].size) {\n\t\t\tprofile[i].start = total_size;\n\t\t\ttotal_size\t+= profile[i].size;\n\t\t}\n\n\t\tif (total_size > dev_cap->max_icm_sz) {\n\t\t\tmlx4_err(dev, \"Profile requires 0x%llx bytes; won't fit in 0x%llx bytes of context memory\\n\",\n\t\t\t\t (unsigned long long) total_size,\n\t\t\t\t (unsigned long long) dev_cap->max_icm_sz);\n\t\t\tkfree(profile);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (profile[i].size)\n\t\t\tmlx4_dbg(dev, \"  profile[%2d] (%6s): 2^%02d entries @ 0x%10llx, size 0x%10llx\\n\",\n\t\t\t\t i, res_name[profile[i].type],\n\t\t\t\t profile[i].log_num,\n\t\t\t\t (unsigned long long) profile[i].start,\n\t\t\t\t (unsigned long long) profile[i].size);\n\t}\n\n\tmlx4_dbg(dev, \"HCA context memory: reserving %d KB\\n\",\n\t\t (int) (total_size >> 10));\n\n\tfor (i = 0; i < MLX4_RES_NUM; ++i) {\n\t\tswitch (profile[i].type) {\n\t\tcase MLX4_RES_QP:\n\t\t\tdev->caps.num_qps     = profile[i].num;\n\t\t\tinit_hca->qpc_base    = profile[i].start;\n\t\t\tinit_hca->log_num_qps = profile[i].log_num;\n\t\t\tbreak;\n\t\tcase MLX4_RES_RDMARC:\n\t\t\tfor (priv->qp_table.rdmarc_shift = 0;\n\t\t\t     request->num_qp << priv->qp_table.rdmarc_shift < profile[i].num;\n\t\t\t     ++priv->qp_table.rdmarc_shift)\n\t\t\t\t;  \n\t\t\tdev->caps.max_qp_dest_rdma = 1 << priv->qp_table.rdmarc_shift;\n\t\t\tpriv->qp_table.rdmarc_base   = (u32) profile[i].start;\n\t\t\tinit_hca->rdmarc_base\t     = profile[i].start;\n\t\t\tinit_hca->log_rd_per_qp\t     = priv->qp_table.rdmarc_shift;\n\t\t\tbreak;\n\t\tcase MLX4_RES_ALTC:\n\t\t\tinit_hca->altc_base = profile[i].start;\n\t\t\tbreak;\n\t\tcase MLX4_RES_AUXC:\n\t\t\tinit_hca->auxc_base = profile[i].start;\n\t\t\tbreak;\n\t\tcase MLX4_RES_SRQ:\n\t\t\tdev->caps.num_srqs     = profile[i].num;\n\t\t\tinit_hca->srqc_base    = profile[i].start;\n\t\t\tinit_hca->log_num_srqs = profile[i].log_num;\n\t\t\tbreak;\n\t\tcase MLX4_RES_CQ:\n\t\t\tdev->caps.num_cqs     = profile[i].num;\n\t\t\tinit_hca->cqc_base    = profile[i].start;\n\t\t\tinit_hca->log_num_cqs = profile[i].log_num;\n\t\t\tbreak;\n\t\tcase MLX4_RES_EQ:\n\t\t\tif (dev_cap->flags2 & MLX4_DEV_CAP_FLAG2_SYS_EQS) {\n\t\t\t\tinit_hca->log_num_eqs = 0x1f;\n\t\t\t\tinit_hca->eqc_base    = profile[i].start;\n\t\t\t\tinit_hca->num_sys_eqs = dev_cap->num_sys_eqs;\n\t\t\t} else {\n\t\t\t\tdev->caps.num_eqs     = roundup_pow_of_two(\n\t\t\t\t\t\t\t\tmin_t(unsigned,\n\t\t\t\t\t\t\t\t      dev_cap->max_eqs,\n\t\t\t\t\t\t\t\t      MAX_MSIX));\n\t\t\t\tinit_hca->eqc_base    = profile[i].start;\n\t\t\t\tinit_hca->log_num_eqs = ilog2(dev->caps.num_eqs);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MLX4_RES_DMPT:\n\t\t\tdev->caps.num_mpts\t= profile[i].num;\n\t\t\tpriv->mr_table.mpt_base = profile[i].start;\n\t\t\tinit_hca->dmpt_base\t= profile[i].start;\n\t\t\tinit_hca->log_mpt_sz\t= profile[i].log_num;\n\t\t\tbreak;\n\t\tcase MLX4_RES_CMPT:\n\t\t\tinit_hca->cmpt_base\t = profile[i].start;\n\t\t\tbreak;\n\t\tcase MLX4_RES_MTT:\n\t\t\tdev->caps.num_mtts\t = profile[i].num;\n\t\t\tpriv->mr_table.mtt_base\t = profile[i].start;\n\t\t\tinit_hca->mtt_base\t = profile[i].start;\n\t\t\tbreak;\n\t\tcase MLX4_RES_MCG:\n\t\t\tinit_hca->mc_base\t  = profile[i].start;\n\t\t\tinit_hca->log_mc_entry_sz =\n\t\t\t\t\tilog2(mlx4_get_mgm_entry_size(dev));\n\t\t\tinit_hca->log_mc_table_sz = profile[i].log_num;\n\t\t\tif (dev->caps.steering_mode ==\n\t\t\t    MLX4_STEERING_MODE_DEVICE_MANAGED) {\n\t\t\t\tdev->caps.num_mgms = profile[i].num;\n\t\t\t} else {\n\t\t\t\tinit_hca->log_mc_hash_sz =\n\t\t\t\t\t\tprofile[i].log_num - 1;\n\t\t\t\tdev->caps.num_mgms = profile[i].num >> 1;\n\t\t\t\tdev->caps.num_amgms = profile[i].num >> 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tdev->caps.num_pds = MLX4_NUM_PDS;\n\n\tkfree(profile);\n\treturn total_size;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}