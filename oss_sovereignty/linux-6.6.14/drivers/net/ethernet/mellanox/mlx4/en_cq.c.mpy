{
  "module_name": "en_cq.c",
  "hash_id": "61d3fa6982736fa731963c5a876121582e34eb65a7ce91c0f1186e9e766d11d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/en_cq.c",
  "human_readable_source": " \n\n#include <linux/mlx4/cq.h>\n#include <linux/mlx4/qp.h>\n#include <linux/mlx4/cmd.h>\n\n#include \"mlx4_en.h\"\n\nstatic void mlx4_en_cq_event(struct mlx4_cq *cq, enum mlx4_event event)\n{\n\treturn;\n}\n\n\nint mlx4_en_create_cq(struct mlx4_en_priv *priv,\n\t\t      struct mlx4_en_cq **pcq,\n\t\t      int entries, int ring, enum cq_type mode,\n\t\t      int node)\n{\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_en_cq *cq;\n\tint err;\n\n\tcq = kzalloc_node(sizeof(*cq), GFP_KERNEL, node);\n\tif (!cq) {\n\t\ten_err(priv, \"Failed to allocate CQ structure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcq->size = entries;\n\tcq->buf_size = cq->size * mdev->dev->caps.cqe_size;\n\n\tcq->ring = ring;\n\tcq->type = mode;\n\tcq->vector = mdev->dev->caps.num_comp_vectors;\n\n\t \n\tset_dev_node(&mdev->dev->persist->pdev->dev, node);\n\terr = mlx4_alloc_hwq_res(mdev->dev, &cq->wqres,\n\t\t\t\tcq->buf_size);\n\tset_dev_node(&mdev->dev->persist->pdev->dev, mdev->dev->numa_node);\n\tif (err)\n\t\tgoto err_cq;\n\n\tcq->buf = (struct mlx4_cqe *)cq->wqres.buf.direct.buf;\n\t*pcq = cq;\n\n\treturn 0;\n\nerr_cq:\n\tkfree(cq);\n\t*pcq = NULL;\n\treturn err;\n}\n\nint mlx4_en_activate_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq,\n\t\t\tint cq_idx)\n{\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint irq, err = 0;\n\tint timestamp_en = 0;\n\tbool assigned_eq = false;\n\n\tcq->dev = mdev->pndev[priv->port];\n\tcq->mcq.set_ci_db  = cq->wqres.db.db;\n\tcq->mcq.arm_db     = cq->wqres.db.db + 1;\n\t*cq->mcq.set_ci_db = 0;\n\t*cq->mcq.arm_db    = 0;\n\tmemset(cq->buf, 0, cq->buf_size);\n\n\tif (cq->type == RX) {\n\t\tif (!mlx4_is_eq_vector_valid(mdev->dev, priv->port,\n\t\t\t\t\t     cq->vector)) {\n\t\t\tcq->vector = cpumask_first(priv->rx_ring[cq->ring]->affinity_mask);\n\n\t\t\terr = mlx4_assign_eq(mdev->dev, priv->port,\n\t\t\t\t\t     &cq->vector);\n\t\t\tif (err) {\n\t\t\t\tmlx4_err(mdev, \"Failed assigning an EQ to CQ vector %d\\n\",\n\t\t\t\t\t cq->vector);\n\t\t\t\tgoto free_eq;\n\t\t\t}\n\n\t\t\tassigned_eq = true;\n\t\t}\n\t\tirq = mlx4_eq_get_irq(mdev->dev, cq->vector);\n\t\tcq->aff_mask = irq_get_effective_affinity_mask(irq);\n\t} else {\n\t\t \n\t\tstruct mlx4_en_cq *rx_cq;\n\n\t\tcq_idx = cq_idx % priv->rx_ring_num;\n\t\trx_cq = priv->rx_cq[cq_idx];\n\t\tcq->vector = rx_cq->vector;\n\t}\n\n\tif (cq->type == RX)\n\t\tcq->size = priv->rx_ring[cq->ring]->actual_size;\n\n\tif ((cq->type != RX && priv->hwtstamp_config.tx_type) ||\n\t    (cq->type == RX && priv->hwtstamp_config.rx_filter))\n\t\ttimestamp_en = 1;\n\n\tcq->mcq.usage = MLX4_RES_USAGE_DRIVER;\n\terr = mlx4_cq_alloc(mdev->dev, cq->size, &cq->wqres.mtt,\n\t\t\t    &mdev->priv_uar, cq->wqres.db.dma, &cq->mcq,\n\t\t\t    cq->vector, 0, timestamp_en, &cq->wqres.buf, false);\n\tif (err)\n\t\tgoto free_eq;\n\n\tcq->mcq.event = mlx4_en_cq_event;\n\n\tswitch (cq->type) {\n\tcase TX:\n\t\tcq->mcq.comp = mlx4_en_tx_irq;\n\t\tnetif_napi_add_tx(cq->dev, &cq->napi, mlx4_en_poll_tx_cq);\n\t\tnapi_enable(&cq->napi);\n\t\tbreak;\n\tcase RX:\n\t\tcq->mcq.comp = mlx4_en_rx_irq;\n\t\tnetif_napi_add(cq->dev, &cq->napi, mlx4_en_poll_rx_cq);\n\t\tnapi_enable(&cq->napi);\n\t\tbreak;\n\tcase TX_XDP:\n\t\t \n\t\tcq->xdp_busy = false;\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nfree_eq:\n\tif (assigned_eq)\n\t\tmlx4_release_eq(mdev->dev, cq->vector);\n\tcq->vector = mdev->dev->caps.num_comp_vectors;\n\treturn err;\n}\n\nvoid mlx4_en_destroy_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq **pcq)\n{\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_en_cq *cq = *pcq;\n\n\tmlx4_free_hwq_res(mdev->dev, &cq->wqres, cq->buf_size);\n\tif (mlx4_is_eq_vector_valid(mdev->dev, priv->port, cq->vector) &&\n\t    cq->type == RX)\n\t\tmlx4_release_eq(priv->mdev->dev, cq->vector);\n\tcq->vector = 0;\n\tcq->buf_size = 0;\n\tcq->buf = NULL;\n\tkfree(cq);\n\t*pcq = NULL;\n}\n\nvoid mlx4_en_deactivate_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq)\n{\n\tif (cq->type != TX_XDP) {\n\t\tnapi_disable(&cq->napi);\n\t\tnetif_napi_del(&cq->napi);\n\t}\n\n\tmlx4_cq_free(priv->mdev->dev, &cq->mcq);\n}\n\n \nint mlx4_en_set_cq_moder(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq)\n{\n\treturn mlx4_cq_modify(priv->mdev->dev, &cq->mcq,\n\t\t\t      cq->moder_cnt, cq->moder_time);\n}\n\nvoid mlx4_en_arm_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq)\n{\n\tmlx4_cq_arm(&cq->mcq, MLX4_CQ_DB_REQ_NOT, priv->mdev->uar_map,\n\t\t    &priv->mdev->uar_lock);\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}