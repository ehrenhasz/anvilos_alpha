{
  "module_name": "cmd.c",
  "hash_id": "d390e2eba3f5e2fcd244bb8503999227568a7c4d2451197b8b4dc1afc311680c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/cmd.c",
  "human_readable_source": " \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/pci.h>\n#include <linux/errno.h>\n\n#include <linux/mlx4/cmd.h>\n#include <linux/mlx4/device.h>\n#include <linux/semaphore.h>\n#include <rdma/ib_smi.h>\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n\n#include <asm/io.h>\n\n#include \"mlx4.h\"\n#include \"fw.h\"\n#include \"fw_qos.h\"\n#include \"mlx4_stats.h\"\n\n#define CMD_POLL_TOKEN 0xffff\n#define INBOX_MASK\t0xffffffffffffff00ULL\n\n#define CMD_CHAN_VER 1\n#define CMD_CHAN_IF_REV 1\n\nenum {\n\t \n\tCMD_STAT_OK\t\t= 0x00,\n\t \n\tCMD_STAT_INTERNAL_ERR\t= 0x01,\n\t \n\tCMD_STAT_BAD_OP\t\t= 0x02,\n\t \n\tCMD_STAT_BAD_PARAM\t= 0x03,\n\t \n\tCMD_STAT_BAD_SYS_STATE\t= 0x04,\n\t \n\tCMD_STAT_BAD_RESOURCE\t= 0x05,\n\t \n\tCMD_STAT_RESOURCE_BUSY\t= 0x06,\n\t \n\tCMD_STAT_EXCEED_LIM\t= 0x08,\n\t \n\tCMD_STAT_BAD_RES_STATE\t= 0x09,\n\t \n\tCMD_STAT_BAD_INDEX\t= 0x0a,\n\t \n\tCMD_STAT_BAD_NVMEM\t= 0x0b,\n\t \n\tCMD_STAT_ICM_ERROR\t= 0x0c,\n\t \n\tCMD_STAT_BAD_QP_STATE   = 0x10,\n\t \n\tCMD_STAT_BAD_SEG_PARAM\t= 0x20,\n\t \n\tCMD_STAT_REG_BOUND\t= 0x21,\n\t \n\tCMD_STAT_LAM_NOT_PRE\t= 0x22,\n\t \n\tCMD_STAT_BAD_PKT\t= 0x30,\n\t \n\tCMD_STAT_BAD_SIZE\t= 0x40,\n\t \n\tCMD_STAT_MULTI_FUNC_REQ\t= 0x50,\n};\n\nenum {\n\tHCR_IN_PARAM_OFFSET\t= 0x00,\n\tHCR_IN_MODIFIER_OFFSET\t= 0x08,\n\tHCR_OUT_PARAM_OFFSET\t= 0x0c,\n\tHCR_TOKEN_OFFSET\t= 0x14,\n\tHCR_STATUS_OFFSET\t= 0x18,\n\n\tHCR_OPMOD_SHIFT\t\t= 12,\n\tHCR_T_BIT\t\t= 21,\n\tHCR_E_BIT\t\t= 22,\n\tHCR_GO_BIT\t\t= 23\n};\n\nenum {\n\tGO_BIT_TIMEOUT_MSECS\t= 10000\n};\n\nenum mlx4_vlan_transition {\n\tMLX4_VLAN_TRANSITION_VST_VST = 0,\n\tMLX4_VLAN_TRANSITION_VST_VGT = 1,\n\tMLX4_VLAN_TRANSITION_VGT_VST = 2,\n\tMLX4_VLAN_TRANSITION_VGT_VGT = 3,\n};\n\n\nstruct mlx4_cmd_context {\n\tstruct completion\tdone;\n\tint\t\t\tresult;\n\tint\t\t\tnext;\n\tu64\t\t\tout_param;\n\tu16\t\t\ttoken;\n\tu8\t\t\tfw_status;\n};\n\nstatic int mlx4_master_process_vhcr(struct mlx4_dev *dev, int slave,\n\t\t\t\t    struct mlx4_vhcr_cmd *in_vhcr);\n\nstatic int mlx4_status_to_errno(u8 status)\n{\n\tstatic const int trans_table[] = {\n\t\t[CMD_STAT_INTERNAL_ERR]\t  = -EIO,\n\t\t[CMD_STAT_BAD_OP]\t  = -EPERM,\n\t\t[CMD_STAT_BAD_PARAM]\t  = -EINVAL,\n\t\t[CMD_STAT_BAD_SYS_STATE]  = -ENXIO,\n\t\t[CMD_STAT_BAD_RESOURCE]\t  = -EBADF,\n\t\t[CMD_STAT_RESOURCE_BUSY]  = -EBUSY,\n\t\t[CMD_STAT_EXCEED_LIM]\t  = -ENOMEM,\n\t\t[CMD_STAT_BAD_RES_STATE]  = -EBADF,\n\t\t[CMD_STAT_BAD_INDEX]\t  = -EBADF,\n\t\t[CMD_STAT_BAD_NVMEM]\t  = -EFAULT,\n\t\t[CMD_STAT_ICM_ERROR]\t  = -ENFILE,\n\t\t[CMD_STAT_BAD_QP_STATE]   = -EINVAL,\n\t\t[CMD_STAT_BAD_SEG_PARAM]  = -EFAULT,\n\t\t[CMD_STAT_REG_BOUND]\t  = -EBUSY,\n\t\t[CMD_STAT_LAM_NOT_PRE]\t  = -EAGAIN,\n\t\t[CMD_STAT_BAD_PKT]\t  = -EINVAL,\n\t\t[CMD_STAT_BAD_SIZE]\t  = -ENOMEM,\n\t\t[CMD_STAT_MULTI_FUNC_REQ] = -EACCES,\n\t};\n\n\tif (status >= ARRAY_SIZE(trans_table) ||\n\t    (status != CMD_STAT_OK && trans_table[status] == 0))\n\t\treturn -EIO;\n\n\treturn trans_table[status];\n}\n\nstatic u8 mlx4_errno_to_status(int errno)\n{\n\tswitch (errno) {\n\tcase -EPERM:\n\t\treturn CMD_STAT_BAD_OP;\n\tcase -EINVAL:\n\t\treturn CMD_STAT_BAD_PARAM;\n\tcase -ENXIO:\n\t\treturn CMD_STAT_BAD_SYS_STATE;\n\tcase -EBUSY:\n\t\treturn CMD_STAT_RESOURCE_BUSY;\n\tcase -ENOMEM:\n\t\treturn CMD_STAT_EXCEED_LIM;\n\tcase -ENFILE:\n\t\treturn CMD_STAT_ICM_ERROR;\n\tdefault:\n\t\treturn CMD_STAT_INTERNAL_ERR;\n\t}\n}\n\nstatic int mlx4_internal_err_ret_value(struct mlx4_dev *dev, u16 op,\n\t\t\t\t       u8 op_modifier)\n{\n\tswitch (op) {\n\tcase MLX4_CMD_UNMAP_ICM:\n\tcase MLX4_CMD_UNMAP_ICM_AUX:\n\tcase MLX4_CMD_UNMAP_FA:\n\tcase MLX4_CMD_2RST_QP:\n\tcase MLX4_CMD_HW2SW_EQ:\n\tcase MLX4_CMD_HW2SW_CQ:\n\tcase MLX4_CMD_HW2SW_SRQ:\n\tcase MLX4_CMD_HW2SW_MPT:\n\tcase MLX4_CMD_CLOSE_HCA:\n\tcase MLX4_QP_FLOW_STEERING_DETACH:\n\tcase MLX4_CMD_FREE_RES:\n\tcase MLX4_CMD_CLOSE_PORT:\n\t\treturn CMD_STAT_OK;\n\n\tcase MLX4_CMD_QP_ATTACH:\n\t\t \n\t\tif (op_modifier == 0)\n\t\t\treturn CMD_STAT_OK;\n\t\treturn mlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\n\n\tdefault:\n\t\treturn mlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\n\t}\n}\n\nstatic int mlx4_closing_cmd_fatal_error(u16 op, u8 fw_status)\n{\n\t \n\tif (op == MLX4_CMD_CLOSE_HCA ||\n\t    op == MLX4_CMD_HW2SW_EQ ||\n\t    op == MLX4_CMD_HW2SW_CQ ||\n\t    op == MLX4_CMD_2RST_QP ||\n\t    op == MLX4_CMD_HW2SW_SRQ ||\n\t    op == MLX4_CMD_SYNC_TPT ||\n\t    op == MLX4_CMD_UNMAP_ICM ||\n\t    op == MLX4_CMD_UNMAP_ICM_AUX ||\n\t    op == MLX4_CMD_UNMAP_FA)\n\t\treturn 1;\n\t \n\tif (op == MLX4_CMD_HW2SW_MPT && fw_status != CMD_STAT_REG_BOUND)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int mlx4_cmd_reset_flow(struct mlx4_dev *dev, u16 op, u8 op_modifier,\n\t\t\t       int err)\n{\n\t \n\tif (mlx4_internal_err_reset) {\n\t\tmlx4_enter_error_state(dev->persist);\n\t\terr = mlx4_internal_err_ret_value(dev, op, op_modifier);\n\t}\n\n\treturn err;\n}\n\nstatic int comm_pending(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tu32 status = readl(&priv->mfunc.comm->slave_read);\n\n\treturn (swab32(status) >> 31) != priv->cmd.comm_toggle;\n}\n\nstatic int mlx4_comm_cmd_post(struct mlx4_dev *dev, u8 cmd, u16 param)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tu32 val;\n\n\t \n\tmutex_lock(&dev->persist->device_state_mutex);\n\n\tif (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR) {\n\t\tmutex_unlock(&dev->persist->device_state_mutex);\n\t\treturn -EIO;\n\t}\n\n\tpriv->cmd.comm_toggle ^= 1;\n\tval = param | (cmd << 16) | (priv->cmd.comm_toggle << 31);\n\t__raw_writel((__force u32) cpu_to_be32(val),\n\t\t     &priv->mfunc.comm->slave_write);\n\tmutex_unlock(&dev->persist->device_state_mutex);\n\treturn 0;\n}\n\nstatic int mlx4_comm_cmd_poll(struct mlx4_dev *dev, u8 cmd, u16 param,\n\t\t       unsigned long timeout)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tunsigned long end;\n\tint err = 0;\n\tint ret_from_pending = 0;\n\n\t \n\tif (comm_pending(dev)) {\n\t\tmlx4_warn(dev, \"Communication channel is not idle - my toggle is %d (cmd:0x%x)\\n\",\n\t\t\t  priv->cmd.comm_toggle, cmd);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tdown(&priv->cmd.poll_sem);\n\tif (mlx4_comm_cmd_post(dev, cmd, param)) {\n\t\t \n\t\terr = mlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\n\t\tgoto out;\n\t}\n\n\tend = msecs_to_jiffies(timeout) + jiffies;\n\twhile (comm_pending(dev) && time_before(jiffies, end))\n\t\tcond_resched();\n\tret_from_pending = comm_pending(dev);\n\tif (ret_from_pending) {\n\t\t \n\t\tif ((MLX4_COMM_CMD_RESET == cmd)) {\n\t\t\terr = MLX4_DELAY_RESET_SLAVE;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tmlx4_warn(dev, \"Communication channel command 0x%x timed out\\n\",\n\t\t\t\t  cmd);\n\t\t\terr = mlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\n\t\t}\n\t}\n\n\tif (err)\n\t\tmlx4_enter_error_state(dev->persist);\nout:\n\tup(&priv->cmd.poll_sem);\n\treturn err;\n}\n\nstatic int mlx4_comm_cmd_wait(struct mlx4_dev *dev, u8 vhcr_cmd,\n\t\t\t      u16 param, u16 op, unsigned long timeout)\n{\n\tstruct mlx4_cmd *cmd = &mlx4_priv(dev)->cmd;\n\tstruct mlx4_cmd_context *context;\n\tunsigned long end;\n\tint err = 0;\n\n\tdown(&cmd->event_sem);\n\n\tspin_lock(&cmd->context_lock);\n\tBUG_ON(cmd->free_head < 0);\n\tcontext = &cmd->context[cmd->free_head];\n\tcontext->token += cmd->token_mask + 1;\n\tcmd->free_head = context->next;\n\tspin_unlock(&cmd->context_lock);\n\n\treinit_completion(&context->done);\n\n\tif (mlx4_comm_cmd_post(dev, vhcr_cmd, param)) {\n\t\t \n\t\terr = mlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\n\t\tgoto out;\n\t}\n\n\tif (!wait_for_completion_timeout(&context->done,\n\t\t\t\t\t msecs_to_jiffies(timeout))) {\n\t\tmlx4_warn(dev, \"communication channel command 0x%x (op=0x%x) timed out\\n\",\n\t\t\t  vhcr_cmd, op);\n\t\tgoto out_reset;\n\t}\n\n\terr = context->result;\n\tif (err && context->fw_status != CMD_STAT_MULTI_FUNC_REQ) {\n\t\tmlx4_err(dev, \"command 0x%x failed: fw status = 0x%x\\n\",\n\t\t\t vhcr_cmd, context->fw_status);\n\t\tif (mlx4_closing_cmd_fatal_error(op, context->fw_status))\n\t\t\tgoto out_reset;\n\t}\n\n\t \n\tif (!(dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)) {\n\t\tend = msecs_to_jiffies(timeout) + jiffies;\n\t\twhile (comm_pending(dev) && time_before(jiffies, end))\n\t\t\tcond_resched();\n\t}\n\tgoto out;\n\nout_reset:\n\terr = mlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\n\tmlx4_enter_error_state(dev->persist);\nout:\n\tspin_lock(&cmd->context_lock);\n\tcontext->next = cmd->free_head;\n\tcmd->free_head = context - cmd->context;\n\tspin_unlock(&cmd->context_lock);\n\n\tup(&cmd->event_sem);\n\treturn err;\n}\n\nint mlx4_comm_cmd(struct mlx4_dev *dev, u8 cmd, u16 param,\n\t\t  u16 op, unsigned long timeout)\n{\n\tif (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)\n\t\treturn mlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\n\n\tif (mlx4_priv(dev)->cmd.use_events)\n\t\treturn mlx4_comm_cmd_wait(dev, cmd, param, op, timeout);\n\treturn mlx4_comm_cmd_poll(dev, cmd, param, timeout);\n}\n\nstatic int cmd_pending(struct mlx4_dev *dev)\n{\n\tu32 status;\n\n\tif (pci_channel_offline(dev->persist->pdev))\n\t\treturn -EIO;\n\n\tstatus = readl(mlx4_priv(dev)->cmd.hcr + HCR_STATUS_OFFSET);\n\n\treturn (status & swab32(1 << HCR_GO_BIT)) ||\n\t\t(mlx4_priv(dev)->cmd.toggle ==\n\t\t !!(status & swab32(1 << HCR_T_BIT)));\n}\n\nstatic int mlx4_cmd_post(struct mlx4_dev *dev, u64 in_param, u64 out_param,\n\t\t\t u32 in_modifier, u8 op_modifier, u16 op, u16 token,\n\t\t\t int event)\n{\n\tstruct mlx4_cmd *cmd = &mlx4_priv(dev)->cmd;\n\tu32 __iomem *hcr = cmd->hcr;\n\tint ret = -EIO;\n\tunsigned long end;\n\n\tmutex_lock(&dev->persist->device_state_mutex);\n\t \n\tif (pci_channel_offline(dev->persist->pdev) ||\n\t    (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)) {\n\t\t \n\t\tgoto out;\n\t}\n\n\tend = jiffies;\n\tif (event)\n\t\tend += msecs_to_jiffies(GO_BIT_TIMEOUT_MSECS);\n\n\twhile (cmd_pending(dev)) {\n\t\tif (pci_channel_offline(dev->persist->pdev)) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\t\tif (time_after_eq(jiffies, end)) {\n\t\t\tmlx4_err(dev, \"%s:cmd_pending failed\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\t \n\t__raw_writel((__force u32) cpu_to_be32(in_param >> 32),\t\t  hcr + 0);\n\t__raw_writel((__force u32) cpu_to_be32(in_param & 0xfffffffful),  hcr + 1);\n\t__raw_writel((__force u32) cpu_to_be32(in_modifier),\t\t  hcr + 2);\n\t__raw_writel((__force u32) cpu_to_be32(out_param >> 32),\t  hcr + 3);\n\t__raw_writel((__force u32) cpu_to_be32(out_param & 0xfffffffful), hcr + 4);\n\t__raw_writel((__force u32) cpu_to_be32(token << 16),\t\t  hcr + 5);\n\n\t \n\twmb();\n\n\t__raw_writel((__force u32) cpu_to_be32((1 << HCR_GO_BIT)\t\t|\n\t\t\t\t\t       (cmd->toggle << HCR_T_BIT)\t|\n\t\t\t\t\t       (event ? (1 << HCR_E_BIT) : 0)\t|\n\t\t\t\t\t       (op_modifier << HCR_OPMOD_SHIFT) |\n\t\t\t\t\t       op), hcr + 6);\n\n\tcmd->toggle = cmd->toggle ^ 1;\n\n\tret = 0;\n\nout:\n\tif (ret)\n\t\tmlx4_warn(dev, \"Could not post command 0x%x: ret=%d, in_param=0x%llx, in_mod=0x%x, op_mod=0x%x\\n\",\n\t\t\t  op, ret, in_param, in_modifier, op_modifier);\n\tmutex_unlock(&dev->persist->device_state_mutex);\n\n\treturn ret;\n}\n\nstatic int mlx4_slave_cmd(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\n\t\t\t  int out_is_imm, u32 in_modifier, u8 op_modifier,\n\t\t\t  u16 op, unsigned long timeout)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_vhcr_cmd *vhcr = priv->mfunc.vhcr;\n\tint ret;\n\n\tmutex_lock(&priv->cmd.slave_cmd_mutex);\n\n\tvhcr->in_param = cpu_to_be64(in_param);\n\tvhcr->out_param = out_param ? cpu_to_be64(*out_param) : 0;\n\tvhcr->in_modifier = cpu_to_be32(in_modifier);\n\tvhcr->opcode = cpu_to_be16((((u16) op_modifier) << 12) | (op & 0xfff));\n\tvhcr->token = cpu_to_be16(CMD_POLL_TOKEN);\n\tvhcr->status = 0;\n\tvhcr->flags = !!(priv->cmd.use_events) << 6;\n\n\tif (mlx4_is_master(dev)) {\n\t\tret = mlx4_master_process_vhcr(dev, dev->caps.function, vhcr);\n\t\tif (!ret) {\n\t\t\tif (out_is_imm) {\n\t\t\t\tif (out_param)\n\t\t\t\t\t*out_param =\n\t\t\t\t\t\tbe64_to_cpu(vhcr->out_param);\n\t\t\t\telse {\n\t\t\t\t\tmlx4_err(dev, \"response expected while output mailbox is NULL for command 0x%x\\n\",\n\t\t\t\t\t\t op);\n\t\t\t\t\tvhcr->status = CMD_STAT_BAD_PARAM;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = mlx4_status_to_errno(vhcr->status);\n\t\t}\n\t\tif (ret &&\n\t\t    dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)\n\t\t\tret = mlx4_internal_err_ret_value(dev, op, op_modifier);\n\t} else {\n\t\tret = mlx4_comm_cmd(dev, MLX4_COMM_CMD_VHCR_POST, 0, op,\n\t\t\t\t    MLX4_COMM_TIME + timeout);\n\t\tif (!ret) {\n\t\t\tif (out_is_imm) {\n\t\t\t\tif (out_param)\n\t\t\t\t\t*out_param =\n\t\t\t\t\t\tbe64_to_cpu(vhcr->out_param);\n\t\t\t\telse {\n\t\t\t\t\tmlx4_err(dev, \"response expected while output mailbox is NULL for command 0x%x\\n\",\n\t\t\t\t\t\t op);\n\t\t\t\t\tvhcr->status = CMD_STAT_BAD_PARAM;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = mlx4_status_to_errno(vhcr->status);\n\t\t} else {\n\t\t\tif (dev->persist->state &\n\t\t\t    MLX4_DEVICE_STATE_INTERNAL_ERROR)\n\t\t\t\tret = mlx4_internal_err_ret_value(dev, op,\n\t\t\t\t\t\t\t\t  op_modifier);\n\t\t\telse\n\t\t\t\tmlx4_err(dev, \"failed execution of VHCR_POST command opcode 0x%x\\n\", op);\n\t\t}\n\t}\n\n\tmutex_unlock(&priv->cmd.slave_cmd_mutex);\n\treturn ret;\n}\n\nstatic int mlx4_cmd_poll(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\n\t\t\t int out_is_imm, u32 in_modifier, u8 op_modifier,\n\t\t\t u16 op, unsigned long timeout)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tvoid __iomem *hcr = priv->cmd.hcr;\n\tint err = 0;\n\tunsigned long end;\n\tu32 stat;\n\n\tdown(&priv->cmd.poll_sem);\n\n\tif (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR) {\n\t\t \n\t\terr = mlx4_internal_err_ret_value(dev, op, op_modifier);\n\t\tgoto out;\n\t}\n\n\tif (out_is_imm && !out_param) {\n\t\tmlx4_err(dev, \"response expected while output mailbox is NULL for command 0x%x\\n\",\n\t\t\t op);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = mlx4_cmd_post(dev, in_param, out_param ? *out_param : 0,\n\t\t\t    in_modifier, op_modifier, op, CMD_POLL_TOKEN, 0);\n\tif (err)\n\t\tgoto out_reset;\n\n\tend = msecs_to_jiffies(timeout) + jiffies;\n\twhile (cmd_pending(dev) && time_before(jiffies, end)) {\n\t\tif (pci_channel_offline(dev->persist->pdev)) {\n\t\t\t \n\t\t\terr = -EIO;\n\t\t\tgoto out_reset;\n\t\t}\n\n\t\tif (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR) {\n\t\t\terr = mlx4_internal_err_ret_value(dev, op, op_modifier);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\tif (cmd_pending(dev)) {\n\t\tmlx4_warn(dev, \"command 0x%x timed out (go bit not cleared)\\n\",\n\t\t\t  op);\n\t\terr = -EIO;\n\t\tgoto out_reset;\n\t}\n\n\tif (out_is_imm)\n\t\t*out_param =\n\t\t\t(u64) be32_to_cpu((__force __be32)\n\t\t\t\t\t  __raw_readl(hcr + HCR_OUT_PARAM_OFFSET)) << 32 |\n\t\t\t(u64) be32_to_cpu((__force __be32)\n\t\t\t\t\t  __raw_readl(hcr + HCR_OUT_PARAM_OFFSET + 4));\n\tstat = be32_to_cpu((__force __be32)\n\t\t\t   __raw_readl(hcr + HCR_STATUS_OFFSET)) >> 24;\n\terr = mlx4_status_to_errno(stat);\n\tif (err) {\n\t\tmlx4_err(dev, \"command 0x%x failed: fw status = 0x%x\\n\",\n\t\t\t op, stat);\n\t\tif (mlx4_closing_cmd_fatal_error(op, stat))\n\t\t\tgoto out_reset;\n\t\tgoto out;\n\t}\n\nout_reset:\n\tif (err)\n\t\terr = mlx4_cmd_reset_flow(dev, op, op_modifier, err);\nout:\n\tup(&priv->cmd.poll_sem);\n\treturn err;\n}\n\nvoid mlx4_cmd_event(struct mlx4_dev *dev, u16 token, u8 status, u64 out_param)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_cmd_context *context =\n\t\t&priv->cmd.context[token & priv->cmd.token_mask];\n\n\t \n\tif (token != context->token)\n\t\treturn;\n\n\tcontext->fw_status = status;\n\tcontext->result    = mlx4_status_to_errno(status);\n\tcontext->out_param = out_param;\n\n\tcomplete(&context->done);\n}\n\nstatic int mlx4_cmd_wait(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\n\t\t\t int out_is_imm, u32 in_modifier, u8 op_modifier,\n\t\t\t u16 op, unsigned long timeout)\n{\n\tstruct mlx4_cmd *cmd = &mlx4_priv(dev)->cmd;\n\tstruct mlx4_cmd_context *context;\n\tlong ret_wait;\n\tint err = 0;\n\n\tdown(&cmd->event_sem);\n\n\tspin_lock(&cmd->context_lock);\n\tBUG_ON(cmd->free_head < 0);\n\tcontext = &cmd->context[cmd->free_head];\n\tcontext->token += cmd->token_mask + 1;\n\tcmd->free_head = context->next;\n\tspin_unlock(&cmd->context_lock);\n\n\tif (out_is_imm && !out_param) {\n\t\tmlx4_err(dev, \"response expected while output mailbox is NULL for command 0x%x\\n\",\n\t\t\t op);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\treinit_completion(&context->done);\n\n\terr = mlx4_cmd_post(dev, in_param, out_param ? *out_param : 0,\n\t\t\t    in_modifier, op_modifier, op, context->token, 1);\n\tif (err)\n\t\tgoto out_reset;\n\n\tif (op == MLX4_CMD_SENSE_PORT) {\n\t\tret_wait =\n\t\t\twait_for_completion_interruptible_timeout(&context->done,\n\t\t\t\t\t\t\t\t  msecs_to_jiffies(timeout));\n\t\tif (ret_wait < 0) {\n\t\t\tcontext->fw_status = 0;\n\t\t\tcontext->out_param = 0;\n\t\t\tcontext->result = 0;\n\t\t}\n\t} else {\n\t\tret_wait = (long)wait_for_completion_timeout(&context->done,\n\t\t\t\t\t\t\t     msecs_to_jiffies(timeout));\n\t}\n\tif (!ret_wait) {\n\t\tmlx4_warn(dev, \"command 0x%x timed out (go bit not cleared)\\n\",\n\t\t\t  op);\n\t\tif (op == MLX4_CMD_NOP) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\terr = -EIO;\n\t\t\tgoto out_reset;\n\t\t}\n\t}\n\n\terr = context->result;\n\tif (err) {\n\t\t \n\t\tif (op == MLX4_CMD_SET_PORT &&\n\t\t    (in_modifier == 1 || in_modifier == 2) &&\n\t\t    op_modifier == MLX4_SET_PORT_IB_OPCODE &&\n\t\t    context->fw_status == CMD_STAT_BAD_SIZE)\n\t\t\tmlx4_dbg(dev, \"command 0x%x failed: fw status = 0x%x\\n\",\n\t\t\t\t op, context->fw_status);\n\t\telse\n\t\t\tmlx4_err(dev, \"command 0x%x failed: fw status = 0x%x\\n\",\n\t\t\t\t op, context->fw_status);\n\t\tif (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)\n\t\t\terr = mlx4_internal_err_ret_value(dev, op, op_modifier);\n\t\telse if (mlx4_closing_cmd_fatal_error(op, context->fw_status))\n\t\t\tgoto out_reset;\n\n\t\tgoto out;\n\t}\n\n\tif (out_is_imm)\n\t\t*out_param = context->out_param;\n\nout_reset:\n\tif (err)\n\t\terr = mlx4_cmd_reset_flow(dev, op, op_modifier, err);\nout:\n\tspin_lock(&cmd->context_lock);\n\tcontext->next = cmd->free_head;\n\tcmd->free_head = context - cmd->context;\n\tspin_unlock(&cmd->context_lock);\n\n\tup(&cmd->event_sem);\n\treturn err;\n}\n\nint __mlx4_cmd(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\n\t       int out_is_imm, u32 in_modifier, u8 op_modifier,\n\t       u16 op, unsigned long timeout, int native)\n{\n\tif (pci_channel_offline(dev->persist->pdev))\n\t\treturn mlx4_cmd_reset_flow(dev, op, op_modifier, -EIO);\n\n\tif (!mlx4_is_mfunc(dev) || (native && mlx4_is_master(dev))) {\n\t\tint ret;\n\n\t\tif (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)\n\t\t\treturn mlx4_internal_err_ret_value(dev, op,\n\t\t\t\t\t\t\t  op_modifier);\n\t\tdown_read(&mlx4_priv(dev)->cmd.switch_sem);\n\t\tif (mlx4_priv(dev)->cmd.use_events)\n\t\t\tret = mlx4_cmd_wait(dev, in_param, out_param,\n\t\t\t\t\t    out_is_imm, in_modifier,\n\t\t\t\t\t    op_modifier, op, timeout);\n\t\telse\n\t\t\tret = mlx4_cmd_poll(dev, in_param, out_param,\n\t\t\t\t\t    out_is_imm, in_modifier,\n\t\t\t\t\t    op_modifier, op, timeout);\n\n\t\tup_read(&mlx4_priv(dev)->cmd.switch_sem);\n\t\treturn ret;\n\t}\n\treturn mlx4_slave_cmd(dev, in_param, out_param, out_is_imm,\n\t\t\t      in_modifier, op_modifier, op, timeout);\n}\nEXPORT_SYMBOL_GPL(__mlx4_cmd);\n\n\nint mlx4_ARM_COMM_CHANNEL(struct mlx4_dev *dev)\n{\n\treturn mlx4_cmd(dev, 0, 0, 0, MLX4_CMD_ARM_COMM_CHANNEL,\n\t\t\tMLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);\n}\n\nstatic int mlx4_ACCESS_MEM(struct mlx4_dev *dev, u64 master_addr,\n\t\t\t   int slave, u64 slave_addr,\n\t\t\t   int size, int is_read)\n{\n\tu64 in_param;\n\tu64 out_param;\n\n\tif ((slave_addr & 0xfff) | (master_addr & 0xfff) |\n\t    (slave & ~0x7f) | (size & 0xff)) {\n\t\tmlx4_err(dev, \"Bad access mem params - slave_addr:0x%llx master_addr:0x%llx slave_id:%d size:%d\\n\",\n\t\t\t slave_addr, master_addr, slave, size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_read) {\n\t\tin_param = (u64) slave | slave_addr;\n\t\tout_param = (u64) dev->caps.function | master_addr;\n\t} else {\n\t\tin_param = (u64) dev->caps.function | master_addr;\n\t\tout_param = (u64) slave | slave_addr;\n\t}\n\n\treturn mlx4_cmd_imm(dev, in_param, &out_param, size, 0,\n\t\t\t    MLX4_CMD_ACCESS_MEM,\n\t\t\t    MLX4_CMD_TIME_CLASS_A, MLX4_CMD_NATIVE);\n}\n\nstatic int query_pkey_block(struct mlx4_dev *dev, u8 port, u16 index, u16 *pkey,\n\t\t\t       struct mlx4_cmd_mailbox *inbox,\n\t\t\t       struct mlx4_cmd_mailbox *outbox)\n{\n\tstruct ib_smp *in_mad = (struct ib_smp *)(inbox->buf);\n\tstruct ib_smp *out_mad = (struct ib_smp *)(outbox->buf);\n\tint err;\n\tint i;\n\n\tif (index & 0x1f)\n\t\treturn -EINVAL;\n\n\tin_mad->attr_mod = cpu_to_be32(index / 32);\n\n\terr = mlx4_cmd_box(dev, inbox->dma, outbox->dma, port, 3,\n\t\t\t   MLX4_CMD_MAD_IFC, MLX4_CMD_TIME_CLASS_C,\n\t\t\t   MLX4_CMD_NATIVE);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < 32; ++i)\n\t\tpkey[i] = be16_to_cpu(((__be16 *) out_mad->data)[i]);\n\n\treturn err;\n}\n\nstatic int get_full_pkey_table(struct mlx4_dev *dev, u8 port, u16 *table,\n\t\t\t       struct mlx4_cmd_mailbox *inbox,\n\t\t\t       struct mlx4_cmd_mailbox *outbox)\n{\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < dev->caps.pkey_table_len[port]; i += 32) {\n\t\terr = query_pkey_block(dev, port, i, table + i, inbox, outbox);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n#define PORT_CAPABILITY_LOCATION_IN_SMP 20\n#define PORT_STATE_OFFSET 32\n\nstatic enum ib_port_state vf_port_state(struct mlx4_dev *dev, int port, int vf)\n{\n\tif (mlx4_get_slave_port_state(dev, vf, port) == SLAVE_PORT_UP)\n\t\treturn IB_PORT_ACTIVE;\n\telse\n\t\treturn IB_PORT_DOWN;\n}\n\nstatic int mlx4_MAD_IFC_wrapper(struct mlx4_dev *dev, int slave,\n\t\t\t\tstruct mlx4_vhcr *vhcr,\n\t\t\t\tstruct mlx4_cmd_mailbox *inbox,\n\t\t\t\tstruct mlx4_cmd_mailbox *outbox,\n\t\t\t\tstruct mlx4_cmd_info *cmd)\n{\n\tstruct ib_smp *smp = inbox->buf;\n\tu32 index;\n\tu8 port, slave_port;\n\tu8 opcode_modifier;\n\tu16 *table;\n\tint err;\n\tint vidx, pidx;\n\tint network_view;\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct ib_smp *outsmp = outbox->buf;\n\t__be16 *outtab = (__be16 *)(outsmp->data);\n\t__be32 slave_cap_mask;\n\t__be64 slave_node_guid;\n\n\tslave_port = vhcr->in_modifier;\n\tport = mlx4_slave_convert_port(dev, slave, slave_port);\n\n\t \n\topcode_modifier = vhcr->op_modifier & ~0x8;  \n\tnetwork_view = !!(vhcr->op_modifier & 0x8);\n\n\tif (smp->base_version == 1 &&\n\t    smp->mgmt_class == IB_MGMT_CLASS_SUBN_LID_ROUTED &&\n\t    smp->class_version == 1) {\n\t\t \n\t\tif (!network_view && smp->method == IB_MGMT_METHOD_GET) {\n\t\t\tif (smp->attr_id == IB_SMP_ATTR_PKEY_TABLE) {\n\t\t\t\tindex = be32_to_cpu(smp->attr_mod);\n\t\t\t\tif (port < 1 || port > dev->caps.num_ports)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\ttable = kcalloc((dev->caps.pkey_table_len[port] / 32) + 1,\n\t\t\t\t\t\tsizeof(*table) * 32, GFP_KERNEL);\n\n\t\t\t\tif (!table)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t \n\t\t\t\terr = get_full_pkey_table(dev, port, table, inbox, outbox);\n\t\t\t\tif (!err) {\n\t\t\t\t\tfor (vidx = index * 32; vidx < (index + 1) * 32; ++vidx) {\n\t\t\t\t\t\tpidx = priv->virt2phys_pkey[slave][port - 1][vidx];\n\t\t\t\t\t\touttab[vidx % 32] = cpu_to_be16(table[pidx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkfree(table);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (smp->attr_id == IB_SMP_ATTR_PORT_INFO) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tsmp->attr_mod = cpu_to_be32(port);\n\t\t\t\terr = mlx4_cmd_box(dev, inbox->dma, outbox->dma,\n\t\t\t\t\t    port, opcode_modifier,\n\t\t\t\t\t    vhcr->op, MLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);\n\t\t\t\t \n\t\t\t\tif (!err && slave != mlx4_master_func_num(dev)) {\n\t\t\t\t\tu8 *state = outsmp->data + PORT_STATE_OFFSET;\n\n\t\t\t\t\t*state = (*state & 0xf0) | vf_port_state(dev, port, slave);\n\t\t\t\t\tslave_cap_mask = priv->mfunc.master.slave_state[slave].ib_cap_mask[port];\n\t\t\t\t\tmemcpy(outsmp->data + PORT_CAPABILITY_LOCATION_IN_SMP, &slave_cap_mask, 4);\n\t\t\t\t}\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (smp->attr_id == IB_SMP_ATTR_GUID_INFO) {\n\t\t\t\t__be64 guid = mlx4_get_admin_guid(dev, slave,\n\t\t\t\t\t\t\t\t  port);\n\n\t\t\t\t \n\t\t\t\tif (slave == 0 && guid == 0) {\n\t\t\t\t\tsmp->attr_mod = 0;\n\t\t\t\t\terr = mlx4_cmd_box(dev,\n\t\t\t\t\t\t\t   inbox->dma,\n\t\t\t\t\t\t\t   outbox->dma,\n\t\t\t\t\t\t\t   vhcr->in_modifier,\n\t\t\t\t\t\t\t   opcode_modifier,\n\t\t\t\t\t\t\t   vhcr->op,\n\t\t\t\t\t\t\t   MLX4_CMD_TIME_CLASS_C,\n\t\t\t\t\t\t\t   MLX4_CMD_NATIVE);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tmlx4_set_admin_guid(dev,\n\t\t\t\t\t\t\t    *(__be64 *)outsmp->\n\t\t\t\t\t\t\t    data, slave, port);\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(outsmp->data, &guid, 8);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tmemset(outsmp->data + 8, 0, 56);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (smp->attr_id == IB_SMP_ATTR_NODE_INFO) {\n\t\t\t\terr = mlx4_cmd_box(dev, inbox->dma, outbox->dma,\n\t\t\t\t\t     port, opcode_modifier,\n\t\t\t\t\t     vhcr->op, MLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);\n\t\t\t\tif (!err) {\n\t\t\t\t\tslave_node_guid =  mlx4_get_slave_node_guid(dev, slave);\n\t\t\t\t\tmemcpy(outsmp->data + 12, &slave_node_guid, 8);\n\t\t\t\t}\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (slave != mlx4_master_func_num(dev) &&\n\t    !mlx4_vf_smi_enabled(dev, slave, port)) {\n\t\tif (!(smp->mgmt_class == IB_MGMT_CLASS_SUBN_LID_ROUTED &&\n\t\t      smp->method == IB_MGMT_METHOD_GET) || network_view) {\n\t\t\tmlx4_err(dev, \"Unprivileged slave %d is trying to execute a Subnet MGMT MAD, class 0x%x, method 0x%x, view=%s for attr 0x%x. Rejecting\\n\",\n\t\t\t\t slave, smp->mgmt_class, smp->method,\n\t\t\t\t network_view ? \"Network\" : \"Host\",\n\t\t\t\t be16_to_cpu(smp->attr_id));\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn mlx4_cmd_box(dev, inbox->dma, outbox->dma,\n\t\t\t\t    vhcr->in_modifier, opcode_modifier,\n\t\t\t\t    vhcr->op, MLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);\n}\n\nstatic int mlx4_CMD_EPERM_wrapper(struct mlx4_dev *dev, int slave,\n\t\t     struct mlx4_vhcr *vhcr,\n\t\t     struct mlx4_cmd_mailbox *inbox,\n\t\t     struct mlx4_cmd_mailbox *outbox,\n\t\t     struct mlx4_cmd_info *cmd)\n{\n\treturn -EPERM;\n}\n\nint mlx4_DMA_wrapper(struct mlx4_dev *dev, int slave,\n\t\t     struct mlx4_vhcr *vhcr,\n\t\t     struct mlx4_cmd_mailbox *inbox,\n\t\t     struct mlx4_cmd_mailbox *outbox,\n\t\t     struct mlx4_cmd_info *cmd)\n{\n\tu64 in_param;\n\tu64 out_param;\n\tint err;\n\n\tin_param = cmd->has_inbox ? (u64) inbox->dma : vhcr->in_param;\n\tout_param = cmd->has_outbox ? (u64) outbox->dma : vhcr->out_param;\n\tif (cmd->encode_slave_id) {\n\t\tin_param &= 0xffffffffffffff00ll;\n\t\tin_param |= slave;\n\t}\n\n\terr = __mlx4_cmd(dev, in_param, &out_param, cmd->out_is_imm,\n\t\t\t vhcr->in_modifier, vhcr->op_modifier, vhcr->op,\n\t\t\t MLX4_CMD_TIME_CLASS_A, MLX4_CMD_NATIVE);\n\n\tif (cmd->out_is_imm)\n\t\tvhcr->out_param = out_param;\n\n\treturn err;\n}\n\nstatic struct mlx4_cmd_info cmd_info[] = {\n\t{\n\t\t.opcode = MLX4_CMD_QUERY_FW,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_QUERY_FW_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_QUERY_HCA,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = NULL\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_QUERY_DEV_CAP,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_QUERY_DEV_CAP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_QUERY_FUNC_CAP,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_QUERY_FUNC_CAP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_QUERY_ADAPTER,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = NULL\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_INIT_PORT,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_INIT_PORT_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_CLOSE_PORT,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm  = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_CLOSE_PORT_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_QUERY_PORT,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_QUERY_PORT_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_SET_PORT,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_SET_PORT_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_MAP_EQ,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_MAP_EQ_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_SW2HW_EQ,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = true,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_SW2HW_EQ_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_HW_HEALTH_CHECK,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = NULL\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_NOP,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = NULL\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_CONFIG_DEV,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_CONFIG_DEV_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_ALLOC_RES,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = true,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_ALLOC_RES_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_FREE_RES,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_FREE_RES_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_SW2HW_MPT,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = true,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_SW2HW_MPT_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_QUERY_MPT,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_QUERY_MPT_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_HW2SW_MPT,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_HW2SW_MPT_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_READ_MTT,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = NULL\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_WRITE_MTT,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_WRITE_MTT_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_SYNC_TPT,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = NULL\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_HW2SW_EQ,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = true,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_HW2SW_EQ_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_QUERY_EQ,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = true,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_QUERY_EQ_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_SW2HW_CQ,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = true,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_SW2HW_CQ_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_HW2SW_CQ,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_HW2SW_CQ_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_QUERY_CQ,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_QUERY_CQ_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_MODIFY_CQ,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = true,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_MODIFY_CQ_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_SW2HW_SRQ,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = true,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_SW2HW_SRQ_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_HW2SW_SRQ,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_HW2SW_SRQ_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_QUERY_SRQ,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_QUERY_SRQ_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_ARM_SRQ,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_ARM_SRQ_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_RST2INIT_QP,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = true,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_RST2INIT_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_INIT2INIT_QP,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_INIT2INIT_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_INIT2RTR_QP,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_INIT2RTR_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_RTR2RTS_QP,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_RTR2RTS_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_RTS2RTS_QP,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_RTS2RTS_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_SQERR2RTS_QP,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_SQERR2RTS_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_2ERR_QP,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_GEN_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_RTS2SQD_QP,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_GEN_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_SQD2SQD_QP,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_SQD2SQD_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_SQD2RTS_QP,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_SQD2RTS_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_2RST_QP,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_2RST_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_QUERY_QP,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_GEN_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_SUSPEND_QP,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_GEN_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_UNSUSPEND_QP,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_GEN_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_UPDATE_QP,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_UPDATE_QP_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_GET_OP_REQ,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_CMD_EPERM_wrapper,\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_ALLOCATE_VPP,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_CMD_EPERM_wrapper,\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_SET_VPORT_QOS,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_CMD_EPERM_wrapper,\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_CONF_SPECIAL_QP,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,  \n\t\t.wrapper = NULL\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_MAD_IFC,\n\t\t.has_inbox = true,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_MAD_IFC_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_MAD_DEMUX,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_CMD_EPERM_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_QUERY_IF_STAT,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_QUERY_IF_STAT_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_ACCESS_REG,\n\t\t.has_inbox = true,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_ACCESS_REG_wrapper,\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_CONGESTION_CTRL_OPCODE,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_CMD_EPERM_wrapper,\n\t},\n\t \n\t{\n\t\t.opcode = MLX4_CMD_QP_ATTACH,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_QP_ATTACH_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_PROMISC,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_PROMISC_wrapper\n\t},\n\t \n\t{\n\t\t.opcode = MLX4_CMD_SET_VLAN_FLTR,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_SET_VLAN_FLTR_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_SET_MCAST_FLTR,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_SET_MCAST_FLTR_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_DUMP_ETH_STATS,\n\t\t.has_inbox = false,\n\t\t.has_outbox = true,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_DUMP_ETH_STATS_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_INFORM_FLR_DONE,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = NULL\n\t},\n\t \n\t{\n\t\t.opcode = MLX4_QP_FLOW_STEERING_ATTACH,\n\t\t.has_inbox = true,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = true,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_QP_FLOW_STEERING_ATTACH_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_QP_FLOW_STEERING_DETACH,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_QP_FLOW_STEERING_DETACH_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_FLOW_STEERING_IB_UC_QP_RANGE,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_CMD_EPERM_wrapper\n\t},\n\t{\n\t\t.opcode = MLX4_CMD_VIRT_PORT_MAP,\n\t\t.has_inbox = false,\n\t\t.has_outbox = false,\n\t\t.out_is_imm = false,\n\t\t.encode_slave_id = false,\n\t\t.verify = NULL,\n\t\t.wrapper = mlx4_CMD_EPERM_wrapper\n\t},\n};\n\nstatic int mlx4_master_process_vhcr(struct mlx4_dev *dev, int slave,\n\t\t\t\t    struct mlx4_vhcr_cmd *in_vhcr)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_cmd_info *cmd = NULL;\n\tstruct mlx4_vhcr_cmd *vhcr_cmd = in_vhcr ? in_vhcr : priv->mfunc.vhcr;\n\tstruct mlx4_vhcr *vhcr;\n\tstruct mlx4_cmd_mailbox *inbox = NULL;\n\tstruct mlx4_cmd_mailbox *outbox = NULL;\n\tu64 in_param;\n\tu64 out_param;\n\tint ret = 0;\n\tint i;\n\tint err = 0;\n\n\t \n\tvhcr = kzalloc(sizeof(struct mlx4_vhcr), GFP_KERNEL);\n\tif (!vhcr)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!in_vhcr) {\n\t\tret = mlx4_ACCESS_MEM(dev, priv->mfunc.vhcr_dma, slave,\n\t\t\t\t      priv->mfunc.master.slave_state[slave].vhcr_dma,\n\t\t\t\t      ALIGN(sizeof(struct mlx4_vhcr_cmd),\n\t\t\t\t\t    MLX4_ACCESS_MEM_ALIGN), 1);\n\t\tif (ret) {\n\t\t\tif (!(dev->persist->state &\n\t\t\t    MLX4_DEVICE_STATE_INTERNAL_ERROR))\n\t\t\t\tmlx4_err(dev, \"%s: Failed reading vhcr ret: 0x%x\\n\",\n\t\t\t\t\t __func__, ret);\n\t\t\tkfree(vhcr);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tvhcr->in_param = be64_to_cpu(vhcr_cmd->in_param);\n\tvhcr->out_param = be64_to_cpu(vhcr_cmd->out_param);\n\tvhcr->in_modifier = be32_to_cpu(vhcr_cmd->in_modifier);\n\tvhcr->token = be16_to_cpu(vhcr_cmd->token);\n\tvhcr->op = be16_to_cpu(vhcr_cmd->opcode) & 0xfff;\n\tvhcr->op_modifier = (u8) (be16_to_cpu(vhcr_cmd->opcode) >> 12);\n\tvhcr->e_bit = vhcr_cmd->flags & (1 << 6);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cmd_info); ++i) {\n\t\tif (vhcr->op == cmd_info[i].opcode) {\n\t\t\tcmd = &cmd_info[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cmd) {\n\t\tmlx4_err(dev, \"Unknown command:0x%x accepted from slave:%d\\n\",\n\t\t\t vhcr->op, slave);\n\t\tvhcr_cmd->status = CMD_STAT_BAD_PARAM;\n\t\tgoto out_status;\n\t}\n\n\t \n\tif (cmd->has_inbox) {\n\t\tvhcr->in_param &= INBOX_MASK;\n\t\tinbox = mlx4_alloc_cmd_mailbox(dev);\n\t\tif (IS_ERR(inbox)) {\n\t\t\tvhcr_cmd->status = CMD_STAT_BAD_SIZE;\n\t\t\tinbox = NULL;\n\t\t\tgoto out_status;\n\t\t}\n\n\t\tret = mlx4_ACCESS_MEM(dev, inbox->dma, slave,\n\t\t\t\t      vhcr->in_param,\n\t\t\t\t      MLX4_MAILBOX_SIZE, 1);\n\t\tif (ret) {\n\t\t\tif (!(dev->persist->state &\n\t\t\t    MLX4_DEVICE_STATE_INTERNAL_ERROR))\n\t\t\t\tmlx4_err(dev, \"%s: Failed reading inbox (cmd:0x%x)\\n\",\n\t\t\t\t\t __func__, cmd->opcode);\n\t\t\tvhcr_cmd->status = CMD_STAT_INTERNAL_ERR;\n\t\t\tgoto out_status;\n\t\t}\n\t}\n\n\t \n\tif (cmd->verify && cmd->verify(dev, slave, vhcr, inbox)) {\n\t\tmlx4_warn(dev, \"Command:0x%x from slave: %d failed protection checks for resource_id:%d\\n\",\n\t\t\t  vhcr->op, slave, vhcr->in_modifier);\n\t\tvhcr_cmd->status = CMD_STAT_BAD_OP;\n\t\tgoto out_status;\n\t}\n\n\t \n\tif (cmd->has_outbox) {\n\t\toutbox = mlx4_alloc_cmd_mailbox(dev);\n\t\tif (IS_ERR(outbox)) {\n\t\t\tvhcr_cmd->status = CMD_STAT_BAD_SIZE;\n\t\t\toutbox = NULL;\n\t\t\tgoto out_status;\n\t\t}\n\t}\n\n\t \n\tif (cmd->wrapper) {\n\t\terr = cmd->wrapper(dev, slave, vhcr, inbox, outbox,\n\t\t\t\t   cmd);\n\t\tif (cmd->out_is_imm)\n\t\t\tvhcr_cmd->out_param = cpu_to_be64(vhcr->out_param);\n\t} else {\n\t\tin_param = cmd->has_inbox ? (u64) inbox->dma :\n\t\t\tvhcr->in_param;\n\t\tout_param = cmd->has_outbox ? (u64) outbox->dma :\n\t\t\tvhcr->out_param;\n\t\terr = __mlx4_cmd(dev, in_param, &out_param,\n\t\t\t\t cmd->out_is_imm, vhcr->in_modifier,\n\t\t\t\t vhcr->op_modifier, vhcr->op,\n\t\t\t\t MLX4_CMD_TIME_CLASS_A,\n\t\t\t\t MLX4_CMD_NATIVE);\n\n\t\tif (cmd->out_is_imm) {\n\t\t\tvhcr->out_param = out_param;\n\t\t\tvhcr_cmd->out_param = cpu_to_be64(vhcr->out_param);\n\t\t}\n\t}\n\n\tif (err) {\n\t\tif (!(dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)) {\n\t\t\tif (vhcr->op == MLX4_CMD_ALLOC_RES &&\n\t\t\t    (vhcr->in_modifier & 0xff) == RES_COUNTER &&\n\t\t\t    err == -EDQUOT)\n\t\t\t\tmlx4_dbg(dev,\n\t\t\t\t\t \"Unable to allocate counter for slave %d (%d)\\n\",\n\t\t\t\t\t slave, err);\n\t\t\telse\n\t\t\t\tmlx4_warn(dev, \"vhcr command:0x%x slave:%d failed with error:%d, status %d\\n\",\n\t\t\t\t\t  vhcr->op, slave, vhcr->errno, err);\n\t\t}\n\t\tvhcr_cmd->status = mlx4_errno_to_status(err);\n\t\tgoto out_status;\n\t}\n\n\n\t \n\tif (cmd->has_outbox && !vhcr_cmd->status) {\n\t\tret = mlx4_ACCESS_MEM(dev, outbox->dma, slave,\n\t\t\t\t      vhcr->out_param,\n\t\t\t\t      MLX4_MAILBOX_SIZE, MLX4_CMD_WRAPPED);\n\t\tif (ret) {\n\t\t\t \n\t\t\tif (!(dev->persist->state &\n\t\t\t    MLX4_DEVICE_STATE_INTERNAL_ERROR))\n\t\t\t\tmlx4_err(dev, \"%s:Failed writing outbox\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout_status:\n\t \n\tif (!in_vhcr) {\n\t\tret = mlx4_ACCESS_MEM(dev, priv->mfunc.vhcr_dma, slave,\n\t\t\t\t      priv->mfunc.master.slave_state[slave].vhcr_dma,\n\t\t\t\t      ALIGN(sizeof(struct mlx4_vhcr),\n\t\t\t\t\t    MLX4_ACCESS_MEM_ALIGN),\n\t\t\t\t      MLX4_CMD_WRAPPED);\n\t\tif (ret)\n\t\t\tmlx4_err(dev, \"%s:Failed writing vhcr result\\n\",\n\t\t\t\t __func__);\n\t\telse if (vhcr->e_bit &&\n\t\t\t mlx4_GEN_EQE(dev, slave, &priv->mfunc.master.cmd_eqe))\n\t\t\t\tmlx4_warn(dev, \"Failed to generate command completion eqe for slave %d\\n\",\n\t\t\t\t\t  slave);\n\t}\n\nout:\n\tkfree(vhcr);\n\tmlx4_free_cmd_mailbox(dev, inbox);\n\tmlx4_free_cmd_mailbox(dev, outbox);\n\treturn ret;\n}\n\nstatic int mlx4_master_immediate_activate_vlan_qos(struct mlx4_priv *priv,\n\t\t\t\t\t    int slave, int port)\n{\n\tstruct mlx4_vport_oper_state *vp_oper;\n\tstruct mlx4_vport_state *vp_admin;\n\tstruct mlx4_vf_immed_vlan_work *work;\n\tstruct mlx4_dev *dev = &(priv->dev);\n\tint err;\n\tint admin_vlan_ix = NO_INDX;\n\n\tvp_oper = &priv->mfunc.master.vf_oper[slave].vport[port];\n\tvp_admin = &priv->mfunc.master.vf_admin[slave].vport[port];\n\n\tif (vp_oper->state.default_vlan == vp_admin->default_vlan &&\n\t    vp_oper->state.default_qos == vp_admin->default_qos &&\n\t    vp_oper->state.vlan_proto == vp_admin->vlan_proto &&\n\t    vp_oper->state.link_state == vp_admin->link_state &&\n\t    vp_oper->state.qos_vport == vp_admin->qos_vport)\n\t\treturn 0;\n\n\tif (!(priv->mfunc.master.slave_state[slave].active &&\n\t      dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_UPDATE_QP)) {\n\t\t \n\t\tvp_oper->state.link_state = vp_admin->link_state;\n\t\treturn -1;\n\t}\n\n\tmlx4_dbg(dev, \"updating immediately admin params slave %d port %d\\n\",\n\t\t slave, port);\n\tmlx4_dbg(dev, \"vlan %d QoS %d link down %d\\n\",\n\t\t vp_admin->default_vlan, vp_admin->default_qos,\n\t\t vp_admin->link_state);\n\n\twork = kzalloc(sizeof(*work), GFP_KERNEL);\n\tif (!work)\n\t\treturn -ENOMEM;\n\n\tif (vp_oper->state.default_vlan != vp_admin->default_vlan) {\n\t\tif (MLX4_VGT != vp_admin->default_vlan) {\n\t\t\terr = __mlx4_register_vlan(&priv->dev, port,\n\t\t\t\t\t\t   vp_admin->default_vlan,\n\t\t\t\t\t\t   &admin_vlan_ix);\n\t\t\tif (err) {\n\t\t\t\tkfree(work);\n\t\t\t\tmlx4_warn(&priv->dev,\n\t\t\t\t\t  \"No vlan resources slave %d, port %d\\n\",\n\t\t\t\t\t  slave, port);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else {\n\t\t\tadmin_vlan_ix = NO_INDX;\n\t\t}\n\t\twork->flags |= MLX4_VF_IMMED_VLAN_FLAG_VLAN;\n\t\tmlx4_dbg(&priv->dev,\n\t\t\t \"alloc vlan %d idx  %d slave %d port %d\\n\",\n\t\t\t (int)(vp_admin->default_vlan),\n\t\t\t admin_vlan_ix, slave, port);\n\t}\n\n\t \n\twork->orig_vlan_id = vp_oper->state.default_vlan;\n\twork->orig_vlan_ix = vp_oper->vlan_idx;\n\n\t \n\tif (vp_oper->state.default_qos != vp_admin->default_qos)\n\t\twork->flags |= MLX4_VF_IMMED_VLAN_FLAG_QOS;\n\n\tif (work->flags & MLX4_VF_IMMED_VLAN_FLAG_VLAN)\n\t\tvp_oper->vlan_idx = admin_vlan_ix;\n\n\tvp_oper->state.default_vlan = vp_admin->default_vlan;\n\tvp_oper->state.default_qos = vp_admin->default_qos;\n\tvp_oper->state.vlan_proto = vp_admin->vlan_proto;\n\tvp_oper->state.link_state = vp_admin->link_state;\n\tvp_oper->state.qos_vport = vp_admin->qos_vport;\n\n\tif (vp_admin->link_state == IFLA_VF_LINK_STATE_DISABLE)\n\t\twork->flags |= MLX4_VF_IMMED_VLAN_FLAG_LINK_DISABLE;\n\n\t \n\twork->port = port;\n\twork->slave = slave;\n\twork->qos = vp_oper->state.default_qos;\n\twork->qos_vport = vp_oper->state.qos_vport;\n\twork->vlan_id = vp_oper->state.default_vlan;\n\twork->vlan_ix = vp_oper->vlan_idx;\n\twork->vlan_proto = vp_oper->state.vlan_proto;\n\twork->priv = priv;\n\tINIT_WORK(&work->work, mlx4_vf_immed_vlan_work_handler);\n\tqueue_work(priv->mfunc.master.comm_wq, &work->work);\n\n\treturn 0;\n}\n\nstatic void mlx4_set_default_port_qos(struct mlx4_dev *dev, int port)\n{\n\tstruct mlx4_qos_manager *port_qos_ctl;\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tport_qos_ctl = &priv->mfunc.master.qos_ctl[port];\n\tbitmap_zero(port_qos_ctl->priority_bm, MLX4_NUM_UP);\n\n\t \n\tset_bit(MLX4_DEFAULT_QOS_PRIO, port_qos_ctl->priority_bm);\n}\n\nstatic void mlx4_allocate_port_vpps(struct mlx4_dev *dev, int port)\n{\n\tint i;\n\tint err;\n\tint num_vfs;\n\tu16 available_vpp;\n\tu8 vpp_param[MLX4_NUM_UP];\n\tstruct mlx4_qos_manager *port_qos;\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\terr = mlx4_ALLOCATE_VPP_get(dev, port, &available_vpp, vpp_param);\n\tif (err) {\n\t\tmlx4_info(dev, \"Failed query available VPPs\\n\");\n\t\treturn;\n\t}\n\n\tport_qos = &priv->mfunc.master.qos_ctl[port];\n\tnum_vfs = (available_vpp /\n\t\t   bitmap_weight(port_qos->priority_bm, MLX4_NUM_UP));\n\n\tfor (i = 0; i < MLX4_NUM_UP; i++) {\n\t\tif (test_bit(i, port_qos->priority_bm))\n\t\t\tvpp_param[i] = num_vfs;\n\t}\n\n\terr = mlx4_ALLOCATE_VPP_set(dev, port, vpp_param);\n\tif (err) {\n\t\tmlx4_info(dev, \"Failed allocating VPPs\\n\");\n\t\treturn;\n\t}\n\n\t \n\terr = mlx4_ALLOCATE_VPP_get(dev, port, &available_vpp, vpp_param);\n\tif (err) {\n\t\tmlx4_info(dev, \"Failed query available VPPs\\n\");\n\t\treturn;\n\t}\n\n\tport_qos->num_of_qos_vfs = num_vfs;\n\tmlx4_dbg(dev, \"Port %d Available VPPs %d\\n\", port, available_vpp);\n\n\tfor (i = 0; i < MLX4_NUM_UP; i++)\n\t\tmlx4_dbg(dev, \"Port %d UP %d Allocated %d VPPs\\n\", port, i,\n\t\t\t vpp_param[i]);\n}\n\nstatic int mlx4_master_activate_admin_state(struct mlx4_priv *priv, int slave)\n{\n\tint p, port, err;\n\tstruct mlx4_vport_state *vp_admin;\n\tstruct mlx4_vport_oper_state *vp_oper;\n\tstruct mlx4_slave_state *slave_state =\n\t\t&priv->mfunc.master.slave_state[slave];\n\tstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(\n\t\t\t&priv->dev, slave);\n\n\tfor_each_set_bit(p, actv_ports.ports, priv->dev.caps.num_ports) {\n\t\tport = p + 1;\n\t\tpriv->mfunc.master.vf_oper[slave].smi_enabled[port] =\n\t\t\tpriv->mfunc.master.vf_admin[slave].enable_smi[port];\n\t\tvp_oper = &priv->mfunc.master.vf_oper[slave].vport[port];\n\t\tvp_admin = &priv->mfunc.master.vf_admin[slave].vport[port];\n\t\tif (vp_admin->vlan_proto != htons(ETH_P_8021AD) ||\n\t\t    slave_state->vst_qinq_supported) {\n\t\t\tvp_oper->state.vlan_proto   = vp_admin->vlan_proto;\n\t\t\tvp_oper->state.default_vlan = vp_admin->default_vlan;\n\t\t\tvp_oper->state.default_qos  = vp_admin->default_qos;\n\t\t}\n\t\tvp_oper->state.link_state = vp_admin->link_state;\n\t\tvp_oper->state.mac        = vp_admin->mac;\n\t\tvp_oper->state.spoofchk   = vp_admin->spoofchk;\n\t\tvp_oper->state.tx_rate    = vp_admin->tx_rate;\n\t\tvp_oper->state.qos_vport  = vp_admin->qos_vport;\n\t\tvp_oper->state.guid       = vp_admin->guid;\n\n\t\tif (MLX4_VGT != vp_admin->default_vlan) {\n\t\t\terr = __mlx4_register_vlan(&priv->dev, port,\n\t\t\t\t\t\t   vp_admin->default_vlan, &(vp_oper->vlan_idx));\n\t\t\tif (err) {\n\t\t\t\tvp_oper->vlan_idx = NO_INDX;\n\t\t\t\tvp_oper->state.default_vlan = MLX4_VGT;\n\t\t\t\tvp_oper->state.vlan_proto = htons(ETH_P_8021Q);\n\t\t\t\tmlx4_warn(&priv->dev,\n\t\t\t\t\t  \"No vlan resources slave %d, port %d\\n\",\n\t\t\t\t\t  slave, port);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tmlx4_dbg(&priv->dev, \"alloc vlan %d idx  %d slave %d port %d\\n\",\n\t\t\t\t (int)(vp_oper->state.default_vlan),\n\t\t\t\t vp_oper->vlan_idx, slave, port);\n\t\t}\n\t\tif (vp_admin->spoofchk) {\n\t\t\tvp_oper->mac_idx = __mlx4_register_mac(&priv->dev,\n\t\t\t\t\t\t\t       port,\n\t\t\t\t\t\t\t       vp_admin->mac);\n\t\t\tif (0 > vp_oper->mac_idx) {\n\t\t\t\terr = vp_oper->mac_idx;\n\t\t\t\tvp_oper->mac_idx = NO_INDX;\n\t\t\t\tmlx4_warn(&priv->dev,\n\t\t\t\t\t  \"No mac resources slave %d, port %d\\n\",\n\t\t\t\t\t  slave, port);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tmlx4_dbg(&priv->dev, \"alloc mac %llx idx  %d slave %d port %d\\n\",\n\t\t\t\t vp_oper->state.mac, vp_oper->mac_idx, slave, port);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void mlx4_master_deactivate_admin_state(struct mlx4_priv *priv, int slave)\n{\n\tint p, port;\n\tstruct mlx4_vport_oper_state *vp_oper;\n\tstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(\n\t\t\t&priv->dev, slave);\n\n\tfor_each_set_bit(p, actv_ports.ports, priv->dev.caps.num_ports) {\n\t\tport = p + 1;\n\t\tpriv->mfunc.master.vf_oper[slave].smi_enabled[port] =\n\t\t\tMLX4_VF_SMI_DISABLED;\n\t\tvp_oper = &priv->mfunc.master.vf_oper[slave].vport[port];\n\t\tif (NO_INDX != vp_oper->vlan_idx) {\n\t\t\t__mlx4_unregister_vlan(&priv->dev,\n\t\t\t\t\t       port, vp_oper->state.default_vlan);\n\t\t\tvp_oper->vlan_idx = NO_INDX;\n\t\t}\n\t\tif (NO_INDX != vp_oper->mac_idx) {\n\t\t\t__mlx4_unregister_mac(&priv->dev, port, vp_oper->state.mac);\n\t\t\tvp_oper->mac_idx = NO_INDX;\n\t\t}\n\t}\n\treturn;\n}\n\nstatic void mlx4_master_do_cmd(struct mlx4_dev *dev, int slave, u8 cmd,\n\t\t\t       u16 param, u8 toggle)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_slave_state *slave_state = priv->mfunc.master.slave_state;\n\tu32 reply;\n\tu8 is_going_down = 0;\n\tint i;\n\tunsigned long flags;\n\n\tslave_state[slave].comm_toggle ^= 1;\n\treply = (u32) slave_state[slave].comm_toggle << 31;\n\tif (toggle != slave_state[slave].comm_toggle) {\n\t\tmlx4_warn(dev, \"Incorrect toggle %d from slave %d. *** MASTER STATE COMPROMISED ***\\n\",\n\t\t\t  toggle, slave);\n\t\tgoto reset_slave;\n\t}\n\tif (cmd == MLX4_COMM_CMD_RESET) {\n\t\tmlx4_warn(dev, \"Received reset from slave:%d\\n\", slave);\n\t\tslave_state[slave].active = false;\n\t\tslave_state[slave].old_vlan_api = false;\n\t\tslave_state[slave].vst_qinq_supported = false;\n\t\tmlx4_master_deactivate_admin_state(priv, slave);\n\t\tfor (i = 0; i < MLX4_EVENT_TYPES_NUM; ++i) {\n\t\t\t\tslave_state[slave].event_eq[i].eqn = -1;\n\t\t\t\tslave_state[slave].event_eq[i].token = 0;\n\t\t}\n\t\t \n\t\tif (MLX4_COMM_CMD_FLR == slave_state[slave].last_cmd)\n\t\t\tgoto inform_slave_state;\n\n\t\tmlx4_dispatch_event(dev, MLX4_DEV_EVENT_SLAVE_SHUTDOWN, &slave);\n\n\t\t \n\t\treply |= mlx4_comm_get_version();\n\n\t\tgoto reset_slave;\n\t}\n\t \n\tif (cmd != MLX4_COMM_CMD_RESET &&\n\t    MLX4_COMM_CMD_FLR == slave_state[slave].last_cmd) {\n\t\tmlx4_warn(dev, \"slave:%d is Trying to run cmd(0x%x) in the middle of FLR\\n\",\n\t\t\t  slave, cmd);\n\t\treturn;\n\t}\n\n\tswitch (cmd) {\n\tcase MLX4_COMM_CMD_VHCR0:\n\t\tif (slave_state[slave].last_cmd != MLX4_COMM_CMD_RESET)\n\t\t\tgoto reset_slave;\n\t\tslave_state[slave].vhcr_dma = ((u64) param) << 48;\n\t\tpriv->mfunc.master.slave_state[slave].cookie = 0;\n\t\tbreak;\n\tcase MLX4_COMM_CMD_VHCR1:\n\t\tif (slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR0)\n\t\t\tgoto reset_slave;\n\t\tslave_state[slave].vhcr_dma |= ((u64) param) << 32;\n\t\tbreak;\n\tcase MLX4_COMM_CMD_VHCR2:\n\t\tif (slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR1)\n\t\t\tgoto reset_slave;\n\t\tslave_state[slave].vhcr_dma |= ((u64) param) << 16;\n\t\tbreak;\n\tcase MLX4_COMM_CMD_VHCR_EN:\n\t\tif (slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR2)\n\t\t\tgoto reset_slave;\n\t\tslave_state[slave].vhcr_dma |= param;\n\t\tif (mlx4_master_activate_admin_state(priv, slave))\n\t\t\t\tgoto reset_slave;\n\t\tslave_state[slave].active = true;\n\t\tmlx4_dispatch_event(dev, MLX4_DEV_EVENT_SLAVE_INIT, &slave);\n\t\tbreak;\n\tcase MLX4_COMM_CMD_VHCR_POST:\n\t\tif ((slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR_EN) &&\n\t\t    (slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR_POST)) {\n\t\t\tmlx4_warn(dev, \"slave:%d is out of sync, cmd=0x%x, last command=0x%x, reset is needed\\n\",\n\t\t\t\t  slave, cmd, slave_state[slave].last_cmd);\n\t\t\tgoto reset_slave;\n\t\t}\n\n\t\tmutex_lock(&priv->cmd.slave_cmd_mutex);\n\t\tif (mlx4_master_process_vhcr(dev, slave, NULL)) {\n\t\t\tmlx4_err(dev, \"Failed processing vhcr for slave:%d, resetting slave\\n\",\n\t\t\t\t slave);\n\t\t\tmutex_unlock(&priv->cmd.slave_cmd_mutex);\n\t\t\tgoto reset_slave;\n\t\t}\n\t\tmutex_unlock(&priv->cmd.slave_cmd_mutex);\n\t\tbreak;\n\tdefault:\n\t\tmlx4_warn(dev, \"Bad comm cmd:%d from slave:%d\\n\", cmd, slave);\n\t\tgoto reset_slave;\n\t}\n\tspin_lock_irqsave(&priv->mfunc.master.slave_state_lock, flags);\n\tif (!slave_state[slave].is_slave_going_down)\n\t\tslave_state[slave].last_cmd = cmd;\n\telse\n\t\tis_going_down = 1;\n\tspin_unlock_irqrestore(&priv->mfunc.master.slave_state_lock, flags);\n\tif (is_going_down) {\n\t\tmlx4_warn(dev, \"Slave is going down aborting command(%d) executing from slave:%d\\n\",\n\t\t\t  cmd, slave);\n\t\treturn;\n\t}\n\t__raw_writel((__force u32) cpu_to_be32(reply),\n\t\t     &priv->mfunc.comm[slave].slave_read);\n\n\treturn;\n\nreset_slave:\n\t \n\tif (dev->persist->interface_state & MLX4_INTERFACE_STATE_UP)\n\t\tmlx4_delete_all_resources_for_slave(dev, slave);\n\n\tif (cmd != MLX4_COMM_CMD_RESET) {\n\t\tmlx4_warn(dev, \"Turn on internal error to force reset, slave=%d, cmd=0x%x\\n\",\n\t\t\t  slave, cmd);\n\t\t \n\t\treply |= ((u32)COMM_CHAN_EVENT_INTERNAL_ERR);\n\t}\n\n\tspin_lock_irqsave(&priv->mfunc.master.slave_state_lock, flags);\n\tif (!slave_state[slave].is_slave_going_down)\n\t\tslave_state[slave].last_cmd = MLX4_COMM_CMD_RESET;\n\tspin_unlock_irqrestore(&priv->mfunc.master.slave_state_lock, flags);\n\t \ninform_slave_state:\n\tmemset(&slave_state[slave].event_eq, 0,\n\t       sizeof(struct mlx4_slave_event_eq_info));\n\t__raw_writel((__force u32) cpu_to_be32(reply),\n\t\t     &priv->mfunc.comm[slave].slave_read);\n\twmb();\n}\n\n \nvoid mlx4_master_comm_channel(struct work_struct *work)\n{\n\tstruct mlx4_mfunc_master_ctx *master =\n\t\tcontainer_of(work,\n\t\t\t     struct mlx4_mfunc_master_ctx,\n\t\t\t     comm_work);\n\tstruct mlx4_mfunc *mfunc =\n\t\tcontainer_of(master, struct mlx4_mfunc, master);\n\tstruct mlx4_priv *priv =\n\t\tcontainer_of(mfunc, struct mlx4_priv, mfunc);\n\tstruct mlx4_dev *dev = &priv->dev;\n\tu32 lbit_vec[COMM_CHANNEL_BIT_ARRAY_SIZE];\n\tu32 nmbr_bits;\n\tu32 comm_cmd;\n\tint i, slave;\n\tint toggle;\n\tbool first = true;\n\tint served = 0;\n\tint reported = 0;\n\tu32 slt;\n\n\tfor (i = 0; i < COMM_CHANNEL_BIT_ARRAY_SIZE; i++)\n\t\tlbit_vec[i] = be32_to_cpu(master->comm_arm_bit_vector[i]);\n\tnmbr_bits = dev->persist->num_vfs + 1;\n\tif (++master->next_slave >= nmbr_bits)\n\t\tmaster->next_slave = 0;\n\tslave = master->next_slave;\n\twhile (true) {\n\t\tslave = find_next_bit((const unsigned long *)&lbit_vec, nmbr_bits, slave);\n\t\tif  (!first && slave >= master->next_slave)\n\t\t\tbreak;\n\t\tif (slave == nmbr_bits) {\n\t\t\tif (!first)\n\t\t\t\tbreak;\n\t\t\tfirst = false;\n\t\t\tslave = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t++reported;\n\t\tcomm_cmd = swab32(readl(&mfunc->comm[slave].slave_write));\n\t\tslt = swab32(readl(&mfunc->comm[slave].slave_read)) >> 31;\n\t\ttoggle = comm_cmd >> 31;\n\t\tif (toggle != slt) {\n\t\t\tif (master->slave_state[slave].comm_toggle\n\t\t\t    != slt) {\n\t\t\t\tpr_info(\"slave %d out of sync. read toggle %d, state toggle %d. Resynching.\\n\",\n\t\t\t\t\tslave, slt,\n\t\t\t\t\tmaster->slave_state[slave].comm_toggle);\n\t\t\t\tmaster->slave_state[slave].comm_toggle =\n\t\t\t\t\tslt;\n\t\t\t}\n\t\t\tmlx4_master_do_cmd(dev, slave,\n\t\t\t\t\t   comm_cmd >> 16 & 0xff,\n\t\t\t\t\t   comm_cmd & 0xffff, toggle);\n\t\t\t++served;\n\t\t}\n\t\tslave++;\n\t}\n\n\tif (reported && reported != served)\n\t\tmlx4_warn(dev, \"Got command event with bitmask from %d slaves but %d were served\\n\",\n\t\t\t  reported, served);\n\n\tif (mlx4_ARM_COMM_CHANNEL(dev))\n\t\tmlx4_warn(dev, \"Failed to arm comm channel events\\n\");\n}\n\nstatic int sync_toggles(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tu32 wr_toggle;\n\tu32 rd_toggle;\n\tunsigned long end;\n\n\twr_toggle = swab32(readl(&priv->mfunc.comm->slave_write));\n\tif (wr_toggle == 0xffffffff)\n\t\tend = jiffies + msecs_to_jiffies(30000);\n\telse\n\t\tend = jiffies + msecs_to_jiffies(5000);\n\n\twhile (time_before(jiffies, end)) {\n\t\trd_toggle = swab32(readl(&priv->mfunc.comm->slave_read));\n\t\tif (wr_toggle == 0xffffffff || rd_toggle == 0xffffffff) {\n\t\t\t \n\n\t\t\t \n\t\t\tif (dev->persist->interface_state &\n\t\t\t    MLX4_INTERFACE_STATE_NOWAIT) {\n\t\t\t\tmlx4_warn(dev,\n\t\t\t\t\t  \"communication channel is offline\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tmsleep(100);\n\t\t\twr_toggle = swab32(readl(&priv->mfunc.comm->\n\t\t\t\t\t   slave_write));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rd_toggle >> 31 == wr_toggle >> 31) {\n\t\t\tpriv->cmd.comm_toggle = rd_toggle >> 31;\n\t\t\treturn 0;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\t \n\tmlx4_warn(dev, \"recovering from previously mis-behaved VM\\n\");\n\t__raw_writel((__force u32) 0, &priv->mfunc.comm->slave_read);\n\t__raw_writel((__force u32) 0, &priv->mfunc.comm->slave_write);\n\tpriv->cmd.comm_toggle = 0;\n\n\treturn 0;\n}\n\nint mlx4_multi_func_init(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_slave_state *s_state;\n\tint i, j, err, port;\n\n\tif (mlx4_is_master(dev))\n\t\tpriv->mfunc.comm =\n\t\tioremap(pci_resource_start(dev->persist->pdev,\n\t\t\t\t\t   priv->fw.comm_bar) +\n\t\t\tpriv->fw.comm_base, MLX4_COMM_PAGESIZE);\n\telse\n\t\tpriv->mfunc.comm =\n\t\tioremap(pci_resource_start(dev->persist->pdev, 2) +\n\t\t\tMLX4_SLAVE_COMM_BASE, MLX4_COMM_PAGESIZE);\n\tif (!priv->mfunc.comm) {\n\t\tmlx4_err(dev, \"Couldn't map communication vector\\n\");\n\t\tgoto err_vhcr;\n\t}\n\n\tif (mlx4_is_master(dev)) {\n\t\tstruct mlx4_vf_oper_state *vf_oper;\n\t\tstruct mlx4_vf_admin_state *vf_admin;\n\n\t\tpriv->mfunc.master.slave_state =\n\t\t\tkcalloc(dev->num_slaves,\n\t\t\t\tsizeof(struct mlx4_slave_state),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!priv->mfunc.master.slave_state)\n\t\t\tgoto err_comm;\n\n\t\tpriv->mfunc.master.vf_admin =\n\t\t\tkcalloc(dev->num_slaves,\n\t\t\t\tsizeof(struct mlx4_vf_admin_state),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!priv->mfunc.master.vf_admin)\n\t\t\tgoto err_comm_admin;\n\n\t\tpriv->mfunc.master.vf_oper =\n\t\t\tkcalloc(dev->num_slaves,\n\t\t\t\tsizeof(struct mlx4_vf_oper_state),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!priv->mfunc.master.vf_oper)\n\t\t\tgoto err_comm_oper;\n\n\t\tpriv->mfunc.master.next_slave = 0;\n\n\t\tfor (i = 0; i < dev->num_slaves; ++i) {\n\t\t\tvf_admin = &priv->mfunc.master.vf_admin[i];\n\t\t\tvf_oper = &priv->mfunc.master.vf_oper[i];\n\t\t\ts_state = &priv->mfunc.master.slave_state[i];\n\t\t\ts_state->last_cmd = MLX4_COMM_CMD_RESET;\n\t\t\ts_state->vst_qinq_supported = false;\n\t\t\tmutex_init(&priv->mfunc.master.gen_eqe_mutex[i]);\n\t\t\tfor (j = 0; j < MLX4_EVENT_TYPES_NUM; ++j)\n\t\t\t\ts_state->event_eq[j].eqn = -1;\n\t\t\t__raw_writel((__force u32) 0,\n\t\t\t\t     &priv->mfunc.comm[i].slave_write);\n\t\t\t__raw_writel((__force u32) 0,\n\t\t\t\t     &priv->mfunc.comm[i].slave_read);\n\t\t\tfor (port = 1; port <= MLX4_MAX_PORTS; port++) {\n\t\t\t\tstruct mlx4_vport_state *admin_vport;\n\t\t\t\tstruct mlx4_vport_state *oper_vport;\n\n\t\t\t\ts_state->vlan_filter[port] =\n\t\t\t\t\tkzalloc(sizeof(struct mlx4_vlan_fltr),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tif (!s_state->vlan_filter[port]) {\n\t\t\t\t\tif (--port)\n\t\t\t\t\t\tkfree(s_state->vlan_filter[port]);\n\t\t\t\t\tgoto err_slaves;\n\t\t\t\t}\n\n\t\t\t\tadmin_vport = &vf_admin->vport[port];\n\t\t\t\toper_vport = &vf_oper->vport[port].state;\n\t\t\t\tINIT_LIST_HEAD(&s_state->mcast_filters[port]);\n\t\t\t\tadmin_vport->default_vlan = MLX4_VGT;\n\t\t\t\toper_vport->default_vlan = MLX4_VGT;\n\t\t\t\tadmin_vport->qos_vport =\n\t\t\t\t\t\tMLX4_VPP_DEFAULT_VPORT;\n\t\t\t\toper_vport->qos_vport = MLX4_VPP_DEFAULT_VPORT;\n\t\t\t\tadmin_vport->vlan_proto = htons(ETH_P_8021Q);\n\t\t\t\toper_vport->vlan_proto = htons(ETH_P_8021Q);\n\t\t\t\tvf_oper->vport[port].vlan_idx = NO_INDX;\n\t\t\t\tvf_oper->vport[port].mac_idx = NO_INDX;\n\t\t\t\tmlx4_set_random_admin_guid(dev, i, port);\n\t\t\t}\n\t\t\tspin_lock_init(&s_state->lock);\n\t\t}\n\n\t\tif (dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_QOS_VPP) {\n\t\t\tfor (port = 1; port <= dev->caps.num_ports; port++) {\n\t\t\t\tif (mlx4_is_eth(dev, port)) {\n\t\t\t\t\tmlx4_set_default_port_qos(dev, port);\n\t\t\t\t\tmlx4_allocate_port_vpps(dev, port);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(&priv->mfunc.master.cmd_eqe, 0, sizeof(struct mlx4_eqe));\n\t\tpriv->mfunc.master.cmd_eqe.type = MLX4_EVENT_TYPE_CMD;\n\t\tINIT_WORK(&priv->mfunc.master.comm_work,\n\t\t\t  mlx4_master_comm_channel);\n\t\tINIT_WORK(&priv->mfunc.master.slave_event_work,\n\t\t\t  mlx4_gen_slave_eqe);\n\t\tINIT_WORK(&priv->mfunc.master.slave_flr_event_work,\n\t\t\t  mlx4_master_handle_slave_flr);\n\t\tspin_lock_init(&priv->mfunc.master.slave_state_lock);\n\t\tspin_lock_init(&priv->mfunc.master.slave_eq.event_lock);\n\t\tpriv->mfunc.master.comm_wq =\n\t\t\tcreate_singlethread_workqueue(\"mlx4_comm\");\n\t\tif (!priv->mfunc.master.comm_wq)\n\t\t\tgoto err_slaves;\n\n\t\tif (mlx4_init_resource_tracker(dev))\n\t\t\tgoto err_thread;\n\n\t} else {\n\t\terr = sync_toggles(dev);\n\t\tif (err) {\n\t\t\tmlx4_err(dev, \"Couldn't sync toggles\\n\");\n\t\t\tgoto err_comm;\n\t\t}\n\t}\n\treturn 0;\n\nerr_thread:\n\tdestroy_workqueue(priv->mfunc.master.comm_wq);\nerr_slaves:\n\twhile (i--) {\n\t\tfor (port = 1; port <= MLX4_MAX_PORTS; port++)\n\t\t\tkfree(priv->mfunc.master.slave_state[i].vlan_filter[port]);\n\t}\n\tkfree(priv->mfunc.master.vf_oper);\nerr_comm_oper:\n\tkfree(priv->mfunc.master.vf_admin);\nerr_comm_admin:\n\tkfree(priv->mfunc.master.slave_state);\nerr_comm:\n\tiounmap(priv->mfunc.comm);\n\tpriv->mfunc.comm = NULL;\nerr_vhcr:\n\tdma_free_coherent(&dev->persist->pdev->dev, PAGE_SIZE,\n\t\t\t  priv->mfunc.vhcr,\n\t\t\t  priv->mfunc.vhcr_dma);\n\tpriv->mfunc.vhcr = NULL;\n\treturn -ENOMEM;\n}\n\nint mlx4_cmd_init(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint flags = 0;\n\n\tif (!priv->cmd.initialized) {\n\t\tinit_rwsem(&priv->cmd.switch_sem);\n\t\tmutex_init(&priv->cmd.slave_cmd_mutex);\n\t\tsema_init(&priv->cmd.poll_sem, 1);\n\t\tpriv->cmd.use_events = 0;\n\t\tpriv->cmd.toggle     = 1;\n\t\tpriv->cmd.initialized = 1;\n\t\tflags |= MLX4_CMD_CLEANUP_STRUCT;\n\t}\n\n\tif (!mlx4_is_slave(dev) && !priv->cmd.hcr) {\n\t\tpriv->cmd.hcr = ioremap(pci_resource_start(dev->persist->pdev,\n\t\t\t\t\t0) + MLX4_HCR_BASE, MLX4_HCR_SIZE);\n\t\tif (!priv->cmd.hcr) {\n\t\t\tmlx4_err(dev, \"Couldn't map command register\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tflags |= MLX4_CMD_CLEANUP_HCR;\n\t}\n\n\tif (mlx4_is_mfunc(dev) && !priv->mfunc.vhcr) {\n\t\tpriv->mfunc.vhcr = dma_alloc_coherent(&dev->persist->pdev->dev,\n\t\t\t\t\t\t      PAGE_SIZE,\n\t\t\t\t\t\t      &priv->mfunc.vhcr_dma,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!priv->mfunc.vhcr)\n\t\t\tgoto err;\n\n\t\tflags |= MLX4_CMD_CLEANUP_VHCR;\n\t}\n\n\tif (!priv->cmd.pool) {\n\t\tpriv->cmd.pool = dma_pool_create(\"mlx4_cmd\",\n\t\t\t\t\t\t &dev->persist->pdev->dev,\n\t\t\t\t\t\t MLX4_MAILBOX_SIZE,\n\t\t\t\t\t\t MLX4_MAILBOX_SIZE, 0);\n\t\tif (!priv->cmd.pool)\n\t\t\tgoto err;\n\n\t\tflags |= MLX4_CMD_CLEANUP_POOL;\n\t}\n\n\treturn 0;\n\nerr:\n\tmlx4_cmd_cleanup(dev, flags);\n\treturn -ENOMEM;\n}\n\nvoid mlx4_report_internal_err_comm_event(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint slave;\n\tu32 slave_read;\n\n\t \n\tif (!priv->mfunc.comm)\n\t\treturn;\n\n\t \n\tfor (slave = 0; slave < dev->num_slaves; slave++) {\n\t\tslave_read = swab32(readl(&priv->mfunc.comm[slave].slave_read));\n\t\tslave_read |= (u32)COMM_CHAN_EVENT_INTERNAL_ERR;\n\t\t__raw_writel((__force u32)cpu_to_be32(slave_read),\n\t\t\t     &priv->mfunc.comm[slave].slave_read);\n\t}\n}\n\nvoid mlx4_multi_func_cleanup(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint i, port;\n\n\tif (mlx4_is_master(dev)) {\n\t\tdestroy_workqueue(priv->mfunc.master.comm_wq);\n\t\tfor (i = 0; i < dev->num_slaves; i++) {\n\t\t\tfor (port = 1; port <= MLX4_MAX_PORTS; port++)\n\t\t\t\tkfree(priv->mfunc.master.slave_state[i].vlan_filter[port]);\n\t\t}\n\t\tkfree(priv->mfunc.master.slave_state);\n\t\tkfree(priv->mfunc.master.vf_admin);\n\t\tkfree(priv->mfunc.master.vf_oper);\n\t\tdev->num_slaves = 0;\n\t}\n\n\tiounmap(priv->mfunc.comm);\n\tpriv->mfunc.comm = NULL;\n}\n\nvoid mlx4_cmd_cleanup(struct mlx4_dev *dev, int cleanup_mask)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tif (priv->cmd.pool && (cleanup_mask & MLX4_CMD_CLEANUP_POOL)) {\n\t\tdma_pool_destroy(priv->cmd.pool);\n\t\tpriv->cmd.pool = NULL;\n\t}\n\n\tif (!mlx4_is_slave(dev) && priv->cmd.hcr &&\n\t    (cleanup_mask & MLX4_CMD_CLEANUP_HCR)) {\n\t\tiounmap(priv->cmd.hcr);\n\t\tpriv->cmd.hcr = NULL;\n\t}\n\tif (mlx4_is_mfunc(dev) && priv->mfunc.vhcr &&\n\t    (cleanup_mask & MLX4_CMD_CLEANUP_VHCR)) {\n\t\tdma_free_coherent(&dev->persist->pdev->dev, PAGE_SIZE,\n\t\t\t\t  priv->mfunc.vhcr, priv->mfunc.vhcr_dma);\n\t\tpriv->mfunc.vhcr = NULL;\n\t}\n\tif (priv->cmd.initialized && (cleanup_mask & MLX4_CMD_CLEANUP_STRUCT))\n\t\tpriv->cmd.initialized = 0;\n}\n\n \nint mlx4_cmd_use_events(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint i;\n\tint err = 0;\n\n\tpriv->cmd.context = kmalloc_array(priv->cmd.max_cmds,\n\t\t\t\t\t  sizeof(struct mlx4_cmd_context),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!priv->cmd.context)\n\t\treturn -ENOMEM;\n\n\tif (mlx4_is_mfunc(dev))\n\t\tmutex_lock(&priv->cmd.slave_cmd_mutex);\n\tdown_write(&priv->cmd.switch_sem);\n\tfor (i = 0; i < priv->cmd.max_cmds; ++i) {\n\t\tpriv->cmd.context[i].token = i;\n\t\tpriv->cmd.context[i].next  = i + 1;\n\t\t \n\t\tinit_completion(&priv->cmd.context[i].done);\n\t}\n\n\tpriv->cmd.context[priv->cmd.max_cmds - 1].next = -1;\n\tpriv->cmd.free_head = 0;\n\n\tsema_init(&priv->cmd.event_sem, priv->cmd.max_cmds);\n\n\tfor (priv->cmd.token_mask = 1;\n\t     priv->cmd.token_mask < priv->cmd.max_cmds;\n\t     priv->cmd.token_mask <<= 1)\n\t\t;  \n\t--priv->cmd.token_mask;\n\n\tdown(&priv->cmd.poll_sem);\n\tpriv->cmd.use_events = 1;\n\tup_write(&priv->cmd.switch_sem);\n\tif (mlx4_is_mfunc(dev))\n\t\tmutex_unlock(&priv->cmd.slave_cmd_mutex);\n\n\treturn err;\n}\n\n \nvoid mlx4_cmd_use_polling(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint i;\n\n\tif (mlx4_is_mfunc(dev))\n\t\tmutex_lock(&priv->cmd.slave_cmd_mutex);\n\tdown_write(&priv->cmd.switch_sem);\n\tpriv->cmd.use_events = 0;\n\n\tfor (i = 0; i < priv->cmd.max_cmds; ++i)\n\t\tdown(&priv->cmd.event_sem);\n\n\tkfree(priv->cmd.context);\n\tpriv->cmd.context = NULL;\n\n\tup(&priv->cmd.poll_sem);\n\tup_write(&priv->cmd.switch_sem);\n\tif (mlx4_is_mfunc(dev))\n\t\tmutex_unlock(&priv->cmd.slave_cmd_mutex);\n}\n\nstruct mlx4_cmd_mailbox *mlx4_alloc_cmd_mailbox(struct mlx4_dev *dev)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\n\tmailbox = kmalloc(sizeof(*mailbox), GFP_KERNEL);\n\tif (!mailbox)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmailbox->buf = dma_pool_zalloc(mlx4_priv(dev)->cmd.pool, GFP_KERNEL,\n\t\t\t\t       &mailbox->dma);\n\tif (!mailbox->buf) {\n\t\tkfree(mailbox);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn mailbox;\n}\nEXPORT_SYMBOL_GPL(mlx4_alloc_cmd_mailbox);\n\nvoid mlx4_free_cmd_mailbox(struct mlx4_dev *dev,\n\t\t\t   struct mlx4_cmd_mailbox *mailbox)\n{\n\tif (!mailbox)\n\t\treturn;\n\n\tdma_pool_free(mlx4_priv(dev)->cmd.pool, mailbox->buf, mailbox->dma);\n\tkfree(mailbox);\n}\nEXPORT_SYMBOL_GPL(mlx4_free_cmd_mailbox);\n\nu32 mlx4_comm_get_version(void)\n{\n\t return ((u32) CMD_CHAN_IF_REV << 8) | (u32) CMD_CHAN_VER;\n}\n\nstatic int mlx4_get_slave_indx(struct mlx4_dev *dev, int vf)\n{\n\tif ((vf < 0) || (vf >= dev->persist->num_vfs)) {\n\t\tmlx4_err(dev, \"Bad vf number:%d (number of activated vf: %d)\\n\",\n\t\t\t vf, dev->persist->num_vfs);\n\t\treturn -EINVAL;\n\t}\n\n\treturn vf+1;\n}\n\nint mlx4_get_vf_indx(struct mlx4_dev *dev, int slave)\n{\n\tif (slave < 1 || slave > dev->persist->num_vfs) {\n\t\tmlx4_err(dev,\n\t\t\t \"Bad slave number:%d (number of activated slaves: %lu)\\n\",\n\t\t\t slave, dev->num_slaves);\n\t\treturn -EINVAL;\n\t}\n\treturn slave - 1;\n}\n\nvoid mlx4_cmd_wake_completions(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_cmd_context *context;\n\tint i;\n\n\tspin_lock(&priv->cmd.context_lock);\n\tif (priv->cmd.context) {\n\t\tfor (i = 0; i < priv->cmd.max_cmds; ++i) {\n\t\t\tcontext = &priv->cmd.context[i];\n\t\t\tcontext->fw_status = CMD_STAT_INTERNAL_ERR;\n\t\t\tcontext->result    =\n\t\t\t\tmlx4_status_to_errno(CMD_STAT_INTERNAL_ERR);\n\t\t\tcomplete(&context->done);\n\t\t}\n\t}\n\tspin_unlock(&priv->cmd.context_lock);\n}\n\nstruct mlx4_active_ports mlx4_get_active_ports(struct mlx4_dev *dev, int slave)\n{\n\tstruct mlx4_active_ports actv_ports;\n\tint vf;\n\n\tbitmap_zero(actv_ports.ports, MLX4_MAX_PORTS);\n\n\tif (slave == 0) {\n\t\tbitmap_fill(actv_ports.ports, dev->caps.num_ports);\n\t\treturn actv_ports;\n\t}\n\n\tvf = mlx4_get_vf_indx(dev, slave);\n\tif (vf < 0)\n\t\treturn actv_ports;\n\n\tbitmap_set(actv_ports.ports, dev->dev_vfs[vf].min_port - 1,\n\t\t   min((int)dev->dev_vfs[mlx4_get_vf_indx(dev, slave)].n_ports,\n\t\t   dev->caps.num_ports));\n\n\treturn actv_ports;\n}\nEXPORT_SYMBOL_GPL(mlx4_get_active_ports);\n\nint mlx4_slave_convert_port(struct mlx4_dev *dev, int slave, int port)\n{\n\tunsigned n;\n\tstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(dev, slave);\n\tunsigned m = bitmap_weight(actv_ports.ports, dev->caps.num_ports);\n\n\tif (port <= 0 || port > m)\n\t\treturn -EINVAL;\n\n\tn = find_first_bit(actv_ports.ports, dev->caps.num_ports);\n\tif (port <= n)\n\t\tport = n + 1;\n\n\treturn port;\n}\nEXPORT_SYMBOL_GPL(mlx4_slave_convert_port);\n\nint mlx4_phys_to_slave_port(struct mlx4_dev *dev, int slave, int port)\n{\n\tstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(dev, slave);\n\tif (test_bit(port - 1, actv_ports.ports))\n\t\treturn port -\n\t\t\tfind_first_bit(actv_ports.ports, dev->caps.num_ports);\n\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(mlx4_phys_to_slave_port);\n\nstruct mlx4_slaves_pport mlx4_phys_to_slaves_pport(struct mlx4_dev *dev,\n\t\t\t\t\t\t   int port)\n{\n\tunsigned i;\n\tstruct mlx4_slaves_pport slaves_pport;\n\n\tbitmap_zero(slaves_pport.slaves, MLX4_MFUNC_MAX);\n\n\tif (port <= 0 || port > dev->caps.num_ports)\n\t\treturn slaves_pport;\n\n\tfor (i = 0; i < dev->persist->num_vfs + 1; i++) {\n\t\tstruct mlx4_active_ports actv_ports =\n\t\t\tmlx4_get_active_ports(dev, i);\n\t\tif (test_bit(port - 1, actv_ports.ports))\n\t\t\tset_bit(i, slaves_pport.slaves);\n\t}\n\n\treturn slaves_pport;\n}\nEXPORT_SYMBOL_GPL(mlx4_phys_to_slaves_pport);\n\nstruct mlx4_slaves_pport mlx4_phys_to_slaves_pport_actv(\n\t\tstruct mlx4_dev *dev,\n\t\tconst struct mlx4_active_ports *crit_ports)\n{\n\tunsigned i;\n\tstruct mlx4_slaves_pport slaves_pport;\n\n\tbitmap_zero(slaves_pport.slaves, MLX4_MFUNC_MAX);\n\n\tfor (i = 0; i < dev->persist->num_vfs + 1; i++) {\n\t\tstruct mlx4_active_ports actv_ports =\n\t\t\tmlx4_get_active_ports(dev, i);\n\t\tif (bitmap_equal(crit_ports->ports, actv_ports.ports,\n\t\t\t\t dev->caps.num_ports))\n\t\t\tset_bit(i, slaves_pport.slaves);\n\t}\n\n\treturn slaves_pport;\n}\nEXPORT_SYMBOL_GPL(mlx4_phys_to_slaves_pport_actv);\n\nstatic int mlx4_slaves_closest_port(struct mlx4_dev *dev, int slave, int port)\n{\n\tstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(dev, slave);\n\tint min_port = find_first_bit(actv_ports.ports, dev->caps.num_ports)\n\t\t\t+ 1;\n\tint max_port = min_port +\n\t\tbitmap_weight(actv_ports.ports, dev->caps.num_ports);\n\n\tif (port < min_port)\n\t\tport = min_port;\n\telse if (port >= max_port)\n\t\tport = max_port - 1;\n\n\treturn port;\n}\n\nstatic int mlx4_set_vport_qos(struct mlx4_priv *priv, int slave, int port,\n\t\t\t      int max_tx_rate)\n{\n\tint i;\n\tint err;\n\tstruct mlx4_qos_manager *port_qos;\n\tstruct mlx4_dev *dev = &priv->dev;\n\tstruct mlx4_vport_qos_param vpp_qos[MLX4_NUM_UP];\n\n\tport_qos = &priv->mfunc.master.qos_ctl[port];\n\tmemset(vpp_qos, 0, sizeof(struct mlx4_vport_qos_param) * MLX4_NUM_UP);\n\n\tif (slave > port_qos->num_of_qos_vfs) {\n\t\tmlx4_info(dev, \"No available VPP resources for this VF\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = mlx4_SET_VPORT_QOS_get(dev, port, 0, vpp_qos);\n\tif (err) {\n\t\tmlx4_info(dev, \"Failed to query Vport 0 QoS values\\n\");\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < MLX4_NUM_UP; i++) {\n\t\tif (test_bit(i, port_qos->priority_bm) && max_tx_rate) {\n\t\t\tvpp_qos[i].max_avg_bw = max_tx_rate;\n\t\t\tvpp_qos[i].enable = 1;\n\t\t} else {\n\t\t\t \n\t\t\tvpp_qos[i].enable = 0;\n\t\t}\n\t}\n\n\terr = mlx4_SET_VPORT_QOS_set(dev, port, slave, vpp_qos);\n\tif (err) {\n\t\tmlx4_info(dev, \"Failed to set Vport %d QoS values\\n\", slave);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic bool mlx4_is_vf_vst_and_prio_qos(struct mlx4_dev *dev, int port,\n\t\t\t\t\tstruct mlx4_vport_state *vf_admin)\n{\n\tstruct mlx4_qos_manager *info;\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tif (!mlx4_is_master(dev) ||\n\t    !(dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_QOS_VPP))\n\t\treturn false;\n\n\tinfo = &priv->mfunc.master.qos_ctl[port];\n\n\tif (vf_admin->default_vlan != MLX4_VGT &&\n\t    test_bit(vf_admin->default_qos, info->priority_bm))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool mlx4_valid_vf_state_change(struct mlx4_dev *dev, int port,\n\t\t\t\t       struct mlx4_vport_state *vf_admin,\n\t\t\t\t       int vlan, int qos)\n{\n\tstruct mlx4_vport_state dummy_admin = {0};\n\n\tif (!mlx4_is_vf_vst_and_prio_qos(dev, port, vf_admin) ||\n\t    !vf_admin->tx_rate)\n\t\treturn true;\n\n\tdummy_admin.default_qos = qos;\n\tdummy_admin.default_vlan = vlan;\n\n\t \n\tif (mlx4_is_vf_vst_and_prio_qos(dev, port, &dummy_admin))\n\t\treturn true;\n\n\tmlx4_info(dev, \"Cannot change VF state to %s while rate is set\\n\",\n\t\t  (vlan == MLX4_VGT) ? \"VGT\" : \"VST\");\n\n\tif (vlan != MLX4_VGT)\n\t\tmlx4_info(dev, \"VST priority %d not supported for QoS\\n\", qos);\n\n\tmlx4_info(dev, \"Please set rate to 0 prior to this VF state change\\n\");\n\n\treturn false;\n}\n\nint mlx4_set_vf_mac(struct mlx4_dev *dev, int port, int vf, u8 *mac)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_vport_state *s_info;\n\tint slave;\n\n\tif (!mlx4_is_master(dev))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (is_multicast_ether_addr(mac))\n\t\treturn -EINVAL;\n\n\tslave = mlx4_get_slave_indx(dev, vf);\n\tif (slave < 0)\n\t\treturn -EINVAL;\n\n\tport = mlx4_slaves_closest_port(dev, slave, port);\n\ts_info = &priv->mfunc.master.vf_admin[slave].vport[port];\n\n\tif (s_info->spoofchk && is_zero_ether_addr(mac)) {\n\t\tmlx4_info(dev, \"MAC invalidation is not allowed when spoofchk is on\\n\");\n\t\treturn -EPERM;\n\t}\n\n\ts_info->mac = ether_addr_to_u64(mac);\n\tmlx4_info(dev, \"default mac on vf %d port %d to %llX will take effect only after vf restart\\n\",\n\t\t  vf, port, s_info->mac);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx4_set_vf_mac);\n\n\nint mlx4_set_vf_vlan(struct mlx4_dev *dev, int port, int vf, u16 vlan, u8 qos,\n\t\t     __be16 proto)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_vport_state *vf_admin;\n\tstruct mlx4_slave_state *slave_state;\n\tstruct mlx4_vport_oper_state *vf_oper;\n\tint slave;\n\n\tif ((!mlx4_is_master(dev)) ||\n\t    !(dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_VLAN_CONTROL))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif ((vlan > 4095) || (qos > 7))\n\t\treturn -EINVAL;\n\n\tif (proto == htons(ETH_P_8021AD) &&\n\t    !(dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_SVLAN_BY_QP))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (proto != htons(ETH_P_8021Q) &&\n\t    proto != htons(ETH_P_8021AD))\n\t\treturn -EINVAL;\n\n\tif ((proto == htons(ETH_P_8021AD)) &&\n\t    ((vlan == 0) || (vlan == MLX4_VGT)))\n\t\treturn -EINVAL;\n\n\tslave = mlx4_get_slave_indx(dev, vf);\n\tif (slave < 0)\n\t\treturn -EINVAL;\n\n\tslave_state = &priv->mfunc.master.slave_state[slave];\n\tif ((proto == htons(ETH_P_8021AD)) && (slave_state->active) &&\n\t    (!slave_state->vst_qinq_supported)) {\n\t\tmlx4_err(dev, \"vf %d does not support VST QinQ mode\\n\", vf);\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\tport = mlx4_slaves_closest_port(dev, slave, port);\n\tvf_admin = &priv->mfunc.master.vf_admin[slave].vport[port];\n\tvf_oper = &priv->mfunc.master.vf_oper[slave].vport[port];\n\n\tif (!mlx4_valid_vf_state_change(dev, port, vf_admin, vlan, qos))\n\t\treturn -EPERM;\n\n\tif ((0 == vlan) && (0 == qos))\n\t\tvf_admin->default_vlan = MLX4_VGT;\n\telse\n\t\tvf_admin->default_vlan = vlan;\n\tvf_admin->default_qos = qos;\n\tvf_admin->vlan_proto = proto;\n\n\t \n\tif (mlx4_is_vf_vst_and_prio_qos(dev, port, vf_admin) &&\n\t    vf_admin->tx_rate)\n\t\tvf_admin->qos_vport = slave;\n\n\t \n\tif ((proto == htons(ETH_P_8021AD) &&\n\t     vf_oper->state.vlan_proto != proto) ||\n\t    mlx4_master_immediate_activate_vlan_qos(priv, slave, port))\n\t\tmlx4_info(dev,\n\t\t\t  \"updating vf %d port %d config will take effect on next VF restart\\n\",\n\t\t\t  vf, port);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx4_set_vf_vlan);\n\nint mlx4_set_vf_rate(struct mlx4_dev *dev, int port, int vf, int min_tx_rate,\n\t\t     int max_tx_rate)\n{\n\tint err;\n\tint slave;\n\tstruct mlx4_vport_state *vf_admin;\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tif (!mlx4_is_master(dev) ||\n\t    !(dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_QOS_VPP))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (min_tx_rate) {\n\t\tmlx4_info(dev, \"Minimum BW share not supported\\n\");\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\tslave = mlx4_get_slave_indx(dev, vf);\n\tif (slave < 0)\n\t\treturn -EINVAL;\n\n\tport = mlx4_slaves_closest_port(dev, slave, port);\n\tvf_admin = &priv->mfunc.master.vf_admin[slave].vport[port];\n\n\terr = mlx4_set_vport_qos(priv, slave, port, max_tx_rate);\n\tif (err) {\n\t\tmlx4_info(dev, \"vf %d failed to set rate %d\\n\", vf,\n\t\t\t  max_tx_rate);\n\t\treturn err;\n\t}\n\n\tvf_admin->tx_rate = max_tx_rate;\n\t \n\tif (!mlx4_is_vf_vst_and_prio_qos(dev, port, vf_admin)) {\n\t\tmlx4_info(dev,\n\t\t\t  \"rate set for VF %d when not in valid state\\n\", vf);\n\n\t\tif (vf_admin->default_vlan != MLX4_VGT)\n\t\t\tmlx4_info(dev, \"VST priority not supported by QoS\\n\");\n\t\telse\n\t\t\tmlx4_info(dev, \"VF in VGT mode (needed VST)\\n\");\n\n\t\tmlx4_info(dev,\n\t\t\t  \"rate %d take affect when VF moves to valid state\\n\",\n\t\t\t  max_tx_rate);\n\t\treturn 0;\n\t}\n\n\t \n\tvf_admin->qos_vport = max_tx_rate ? slave : MLX4_VPP_DEFAULT_VPORT;\n\n\tif (priv->mfunc.master.slave_state[slave].active &&\n\t    dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_UPDATE_QP)\n\t\tmlx4_master_immediate_activate_vlan_qos(priv, slave, port);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx4_set_vf_rate);\n\n  \nbool mlx4_get_slave_default_vlan(struct mlx4_dev *dev, int port, int slave,\n\t\t\t\t u16 *vlan, u8 *qos)\n{\n\tstruct mlx4_vport_oper_state *vp_oper;\n\tstruct mlx4_priv *priv;\n\n\tpriv = mlx4_priv(dev);\n\tport = mlx4_slaves_closest_port(dev, slave, port);\n\tvp_oper = &priv->mfunc.master.vf_oper[slave].vport[port];\n\n\tif (MLX4_VGT != vp_oper->state.default_vlan) {\n\t\tif (vlan)\n\t\t\t*vlan = vp_oper->state.default_vlan;\n\t\tif (qos)\n\t\t\t*qos = vp_oper->state.default_qos;\n\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(mlx4_get_slave_default_vlan);\n\nint mlx4_set_vf_spoofchk(struct mlx4_dev *dev, int port, int vf, bool setting)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_vport_state *s_info;\n\tint slave;\n\tu8 mac[ETH_ALEN];\n\n\tif ((!mlx4_is_master(dev)) ||\n\t    !(dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_FSM))\n\t\treturn -EPROTONOSUPPORT;\n\n\tslave = mlx4_get_slave_indx(dev, vf);\n\tif (slave < 0)\n\t\treturn -EINVAL;\n\n\tport = mlx4_slaves_closest_port(dev, slave, port);\n\ts_info = &priv->mfunc.master.vf_admin[slave].vport[port];\n\n\tu64_to_ether_addr(s_info->mac, mac);\n\tif (setting && !is_valid_ether_addr(mac)) {\n\t\tmlx4_info(dev, \"Illegal MAC with spoofchk\\n\");\n\t\treturn -EPERM;\n\t}\n\n\ts_info->spoofchk = setting;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx4_set_vf_spoofchk);\n\nint mlx4_get_vf_config(struct mlx4_dev *dev, int port, int vf, struct ifla_vf_info *ivf)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_vport_state *s_info;\n\tint slave;\n\n\tif (!mlx4_is_master(dev))\n\t\treturn -EPROTONOSUPPORT;\n\n\tslave = mlx4_get_slave_indx(dev, vf);\n\tif (slave < 0)\n\t\treturn -EINVAL;\n\n\ts_info = &priv->mfunc.master.vf_admin[slave].vport[port];\n\tivf->vf = vf;\n\n\t \n\tivf->mac[0] = ((s_info->mac >> (5*8)) & 0xff);\n\tivf->mac[1] = ((s_info->mac >> (4*8)) & 0xff);\n\tivf->mac[2] = ((s_info->mac >> (3*8)) & 0xff);\n\tivf->mac[3] = ((s_info->mac >> (2*8)) & 0xff);\n\tivf->mac[4] = ((s_info->mac >> (1*8)) & 0xff);\n\tivf->mac[5] = ((s_info->mac)  & 0xff);\n\n\tivf->vlan\t\t= s_info->default_vlan;\n\tivf->qos\t\t= s_info->default_qos;\n\tivf->vlan_proto\t\t= s_info->vlan_proto;\n\n\tif (mlx4_is_vf_vst_and_prio_qos(dev, port, s_info))\n\t\tivf->max_tx_rate = s_info->tx_rate;\n\telse\n\t\tivf->max_tx_rate = 0;\n\n\tivf->min_tx_rate\t= 0;\n\tivf->spoofchk\t\t= s_info->spoofchk;\n\tivf->linkstate\t\t= s_info->link_state;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx4_get_vf_config);\n\nint mlx4_set_vf_link_state(struct mlx4_dev *dev, int port, int vf, int link_state)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_vport_state *s_info;\n\tint slave;\n\tu8 link_stat_event;\n\n\tslave = mlx4_get_slave_indx(dev, vf);\n\tif (slave < 0)\n\t\treturn -EINVAL;\n\n\tport = mlx4_slaves_closest_port(dev, slave, port);\n\tswitch (link_state) {\n\tcase IFLA_VF_LINK_STATE_AUTO:\n\t\t \n\t\tif (!priv->sense.do_sense_port[port])\n\t\t\tlink_stat_event = MLX4_PORT_CHANGE_SUBTYPE_ACTIVE;\n\t\telse\n\t\t\tlink_stat_event = MLX4_PORT_CHANGE_SUBTYPE_DOWN;\n\t    break;\n\n\tcase IFLA_VF_LINK_STATE_ENABLE:\n\t\tlink_stat_event = MLX4_PORT_CHANGE_SUBTYPE_ACTIVE;\n\t    break;\n\n\tcase IFLA_VF_LINK_STATE_DISABLE:\n\t\tlink_stat_event = MLX4_PORT_CHANGE_SUBTYPE_DOWN;\n\t    break;\n\n\tdefault:\n\t\tmlx4_warn(dev, \"unknown value for link_state %02x on slave %d port %d\\n\",\n\t\t\t  link_state, slave, port);\n\t\treturn -EINVAL;\n\t}\n\ts_info = &priv->mfunc.master.vf_admin[slave].vport[port];\n\ts_info->link_state = link_state;\n\n\t \n\tmlx4_gen_port_state_change_eqe(dev, slave, port, link_stat_event);\n\n\tif (mlx4_master_immediate_activate_vlan_qos(priv, slave, port))\n\t\tmlx4_dbg(dev,\n\t\t\t \"updating vf %d port %d no link state HW enforcement\\n\",\n\t\t\t vf, port);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx4_set_vf_link_state);\n\nint mlx4_get_counter_stats(struct mlx4_dev *dev, int counter_index,\n\t\t\t   struct mlx4_counter *counter_stats, int reset)\n{\n\tstruct mlx4_cmd_mailbox *mailbox = NULL;\n\tstruct mlx4_counter *tmp_counter;\n\tint err;\n\tu32 if_stat_in_mod;\n\n\tif (!counter_stats)\n\t\treturn -EINVAL;\n\n\tif (counter_index == MLX4_SINK_COUNTER_INDEX(dev))\n\t\treturn 0;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tmemset(mailbox->buf, 0, sizeof(struct mlx4_counter));\n\tif_stat_in_mod = counter_index;\n\tif (reset)\n\t\tif_stat_in_mod |= MLX4_QUERY_IF_STAT_RESET;\n\terr = mlx4_cmd_box(dev, 0, mailbox->dma,\n\t\t\t   if_stat_in_mod, 0,\n\t\t\t   MLX4_CMD_QUERY_IF_STAT,\n\t\t\t   MLX4_CMD_TIME_CLASS_C,\n\t\t\t   MLX4_CMD_NATIVE);\n\tif (err) {\n\t\tmlx4_dbg(dev, \"%s: failed to read statistics for counter index %d\\n\",\n\t\t\t __func__, counter_index);\n\t\tgoto if_stat_out;\n\t}\n\ttmp_counter = (struct mlx4_counter *)mailbox->buf;\n\tcounter_stats->counter_mode = tmp_counter->counter_mode;\n\tif (counter_stats->counter_mode == 0) {\n\t\tcounter_stats->rx_frames =\n\t\t\tcpu_to_be64(be64_to_cpu(counter_stats->rx_frames) +\n\t\t\t\t    be64_to_cpu(tmp_counter->rx_frames));\n\t\tcounter_stats->tx_frames =\n\t\t\tcpu_to_be64(be64_to_cpu(counter_stats->tx_frames) +\n\t\t\t\t    be64_to_cpu(tmp_counter->tx_frames));\n\t\tcounter_stats->rx_bytes =\n\t\t\tcpu_to_be64(be64_to_cpu(counter_stats->rx_bytes) +\n\t\t\t\t    be64_to_cpu(tmp_counter->rx_bytes));\n\t\tcounter_stats->tx_bytes =\n\t\t\tcpu_to_be64(be64_to_cpu(counter_stats->tx_bytes) +\n\t\t\t\t    be64_to_cpu(tmp_counter->tx_bytes));\n\t}\n\nif_stat_out:\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx4_get_counter_stats);\n\nint mlx4_get_vf_stats(struct mlx4_dev *dev, int port, int vf_idx,\n\t\t      struct ifla_vf_stats *vf_stats)\n{\n\tstruct mlx4_counter tmp_vf_stats;\n\tint slave;\n\tint err = 0;\n\n\tif (!vf_stats)\n\t\treturn -EINVAL;\n\n\tif (!mlx4_is_master(dev))\n\t\treturn -EPROTONOSUPPORT;\n\n\tslave = mlx4_get_slave_indx(dev, vf_idx);\n\tif (slave < 0)\n\t\treturn -EINVAL;\n\n\tport = mlx4_slaves_closest_port(dev, slave, port);\n\terr = mlx4_calc_vf_counters(dev, slave, port, &tmp_vf_stats);\n\tif (!err && tmp_vf_stats.counter_mode == 0) {\n\t\tvf_stats->rx_packets = be64_to_cpu(tmp_vf_stats.rx_frames);\n\t\tvf_stats->tx_packets = be64_to_cpu(tmp_vf_stats.tx_frames);\n\t\tvf_stats->rx_bytes = be64_to_cpu(tmp_vf_stats.rx_bytes);\n\t\tvf_stats->tx_bytes = be64_to_cpu(tmp_vf_stats.tx_bytes);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx4_get_vf_stats);\n\nint mlx4_vf_smi_enabled(struct mlx4_dev *dev, int slave, int port)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tif (slave < 1 || slave >= dev->num_slaves ||\n\t    port < 1 || port > MLX4_MAX_PORTS)\n\t\treturn 0;\n\n\treturn priv->mfunc.master.vf_oper[slave].smi_enabled[port] ==\n\t\tMLX4_VF_SMI_ENABLED;\n}\nEXPORT_SYMBOL_GPL(mlx4_vf_smi_enabled);\n\nint mlx4_vf_get_enable_smi_admin(struct mlx4_dev *dev, int slave, int port)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tif (slave == mlx4_master_func_num(dev))\n\t\treturn 1;\n\n\tif (slave < 1 || slave >= dev->num_slaves ||\n\t    port < 1 || port > MLX4_MAX_PORTS)\n\t\treturn 0;\n\n\treturn priv->mfunc.master.vf_admin[slave].enable_smi[port] ==\n\t\tMLX4_VF_SMI_ENABLED;\n}\nEXPORT_SYMBOL_GPL(mlx4_vf_get_enable_smi_admin);\n\nint mlx4_vf_set_enable_smi_admin(struct mlx4_dev *dev, int slave, int port,\n\t\t\t\t int enabled)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(\n\t\t\t&priv->dev, slave);\n\tint min_port = find_first_bit(actv_ports.ports,\n\t\t\t\t      priv->dev.caps.num_ports) + 1;\n\tint max_port = min_port - 1 +\n\t\tbitmap_weight(actv_ports.ports, priv->dev.caps.num_ports);\n\n\tif (slave == mlx4_master_func_num(dev))\n\t\treturn 0;\n\n\tif (slave < 1 || slave >= dev->num_slaves ||\n\t    port < 1 || port > MLX4_MAX_PORTS ||\n\t    enabled < 0 || enabled > 1)\n\t\treturn -EINVAL;\n\n\tif (min_port == max_port && dev->caps.num_ports > 1) {\n\t\tmlx4_info(dev, \"SMI access disallowed for single ported VFs\\n\");\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\tpriv->mfunc.master.vf_admin[slave].enable_smi[port] = enabled;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx4_vf_set_enable_smi_admin);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}