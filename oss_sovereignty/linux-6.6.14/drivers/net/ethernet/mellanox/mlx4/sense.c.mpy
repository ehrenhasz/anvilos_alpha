{
  "module_name": "sense.c",
  "hash_id": "ad7cfd4d1cfee44f797d0aa78160985029fc90d347f4697da6040f3387e532ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/sense.c",
  "human_readable_source": " \n\n#include <linux/errno.h>\n#include <linux/if_ether.h>\n\n#include <linux/mlx4/cmd.h>\n\n#include \"mlx4.h\"\n\nint mlx4_SENSE_PORT(struct mlx4_dev *dev, int port,\n\t\t    enum mlx4_port_type *type)\n{\n\tu64 out_param;\n\tint err = 0;\n\n\terr = mlx4_cmd_imm(dev, 0, &out_param, port, 0,\n\t\t\t   MLX4_CMD_SENSE_PORT, MLX4_CMD_TIME_CLASS_B,\n\t\t\t   MLX4_CMD_WRAPPED);\n\tif (err) {\n\t\tmlx4_err(dev, \"Sense command failed for port: %d\\n\", port);\n\t\treturn err;\n\t}\n\n\tif (out_param > 2) {\n\t\tmlx4_err(dev, \"Sense returned illegal value: 0x%llx\\n\", out_param);\n\t\treturn -EINVAL;\n\t}\n\n\t*type = out_param;\n\treturn 0;\n}\n\nvoid mlx4_do_sense_ports(struct mlx4_dev *dev,\n\t\t\t enum mlx4_port_type *stype,\n\t\t\t enum mlx4_port_type *defaults)\n{\n\tstruct mlx4_sense *sense = &mlx4_priv(dev)->sense;\n\tint err;\n\tint i;\n\n\tfor (i = 1; i <= dev->caps.num_ports; i++) {\n\t\tstype[i - 1] = 0;\n\t\tif (sense->do_sense_port[i] && sense->sense_allowed[i] &&\n\t\t    dev->caps.possible_type[i] == MLX4_PORT_TYPE_AUTO) {\n\t\t\terr = mlx4_SENSE_PORT(dev, i, &stype[i - 1]);\n\t\t\tif (err)\n\t\t\t\tstype[i - 1] = defaults[i - 1];\n\t\t} else\n\t\t\tstype[i - 1] = defaults[i - 1];\n\t}\n\n\t \n\tfor (i = 0; i < dev->caps.num_ports; i++)\n\t\tstype[i] = stype[i] ? stype[i] : defaults[i];\n\n}\n\nstatic void mlx4_sense_port(struct work_struct *work)\n{\n\tstruct delayed_work *delay = to_delayed_work(work);\n\tstruct mlx4_sense *sense = container_of(delay, struct mlx4_sense,\n\t\t\t\t\t\tsense_poll);\n\tstruct mlx4_dev *dev = sense->dev;\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tenum mlx4_port_type stype[MLX4_MAX_PORTS];\n\n\tmutex_lock(&priv->port_mutex);\n\tmlx4_do_sense_ports(dev, stype, &dev->caps.port_type[1]);\n\n\tif (mlx4_check_port_params(dev, stype))\n\t\tgoto sense_again;\n\n\tif (mlx4_change_port_types(dev, stype))\n\t\tmlx4_err(dev, \"Failed to change port_types\\n\");\n\nsense_again:\n\tmutex_unlock(&priv->port_mutex);\n\tqueue_delayed_work(mlx4_wq , &sense->sense_poll,\n\t\t\t   round_jiffies_relative(MLX4_SENSE_RANGE));\n}\n\nvoid mlx4_start_sense(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_sense *sense = &priv->sense;\n\n\tif (!(dev->caps.flags & MLX4_DEV_CAP_FLAG_DPDP))\n\t\treturn;\n\n\tqueue_delayed_work(mlx4_wq , &sense->sense_poll,\n\t\t\t   round_jiffies_relative(MLX4_SENSE_RANGE));\n}\n\nvoid mlx4_stop_sense(struct mlx4_dev *dev)\n{\n\tcancel_delayed_work_sync(&mlx4_priv(dev)->sense.sense_poll);\n}\n\nvoid  mlx4_sense_init(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_sense *sense = &priv->sense;\n\tint port;\n\n\tsense->dev = dev;\n\tfor (port = 1; port <= dev->caps.num_ports; port++)\n\t\tsense->do_sense_port[port] = 1;\n\n\tINIT_DEFERRABLE_WORK(&sense->sense_poll, mlx4_sense_port);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}