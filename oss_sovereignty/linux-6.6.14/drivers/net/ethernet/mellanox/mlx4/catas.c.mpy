{
  "module_name": "catas.c",
  "hash_id": "ec3b828f8321c7fc0817ec900a38905bfde76244cf532542471ae69a3e236744",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/catas.c",
  "human_readable_source": " \n\n#include <linux/workqueue.h>\n#include <linux/module.h>\n\n#include \"mlx4.h\"\n\nenum {\n\tMLX4_CATAS_POLL_INTERVAL\t= 5 * HZ,\n};\n\n\n\nint mlx4_internal_err_reset = 1;\nmodule_param_named(internal_err_reset, mlx4_internal_err_reset,  int, 0644);\nMODULE_PARM_DESC(internal_err_reset,\n\t\t \"Reset device on internal errors if non-zero (default 1)\");\n\nstatic int read_vendor_id(struct mlx4_dev *dev)\n{\n\tu16 vendor_id = 0;\n\tint ret;\n\n\tret = pci_read_config_word(dev->persist->pdev, 0, &vendor_id);\n\tif (ret) {\n\t\tmlx4_err(dev, \"Failed to read vendor ID, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (vendor_id == 0xffff) {\n\t\tmlx4_err(dev, \"PCI can't be accessed to read vendor id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx4_reset_master(struct mlx4_dev *dev)\n{\n\tint err = 0;\n\n\tif (mlx4_is_master(dev))\n\t\tmlx4_report_internal_err_comm_event(dev);\n\n\tif (!pci_channel_offline(dev->persist->pdev)) {\n\t\terr = read_vendor_id(dev);\n\t\t \n\t\tif (err)\n\t\t\treturn 0;\n\n\t\terr = mlx4_reset(dev);\n\t\tif (err)\n\t\t\tmlx4_err(dev, \"Fail to reset HCA\\n\");\n\t}\n\n\treturn err;\n}\n\nstatic int mlx4_reset_slave(struct mlx4_dev *dev)\n{\n#define COM_CHAN_RST_REQ_OFFSET 0x10\n#define COM_CHAN_RST_ACK_OFFSET 0x08\n\n\tu32 comm_flags;\n\tu32 rst_req;\n\tu32 rst_ack;\n\tunsigned long end;\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tif (pci_channel_offline(dev->persist->pdev))\n\t\treturn 0;\n\n\tcomm_flags = swab32(readl((__iomem char *)priv->mfunc.comm +\n\t\t\t\t  MLX4_COMM_CHAN_FLAGS));\n\tif (comm_flags == 0xffffffff) {\n\t\tmlx4_err(dev, \"VF reset is not needed\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!(dev->caps.vf_caps & MLX4_VF_CAP_FLAG_RESET)) {\n\t\tmlx4_err(dev, \"VF reset is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trst_req = (comm_flags & (u32)(1 << COM_CHAN_RST_REQ_OFFSET)) >>\n\t\tCOM_CHAN_RST_REQ_OFFSET;\n\trst_ack = (comm_flags & (u32)(1 << COM_CHAN_RST_ACK_OFFSET)) >>\n\t\tCOM_CHAN_RST_ACK_OFFSET;\n\tif (rst_req != rst_ack) {\n\t\tmlx4_err(dev, \"Communication channel isn't sync, fail to send reset\\n\");\n\t\treturn -EIO;\n\t}\n\n\trst_req ^= 1;\n\tmlx4_warn(dev, \"VF is sending reset request to Firmware\\n\");\n\tcomm_flags = rst_req << COM_CHAN_RST_REQ_OFFSET;\n\t__raw_writel((__force u32)cpu_to_be32(comm_flags),\n\t\t     (__iomem char *)priv->mfunc.comm + MLX4_COMM_CHAN_FLAGS);\n\n\tend = msecs_to_jiffies(MLX4_COMM_TIME) + jiffies;\n\twhile (time_before(jiffies, end)) {\n\t\tcomm_flags = swab32(readl((__iomem char *)priv->mfunc.comm +\n\t\t\t\t\t  MLX4_COMM_CHAN_FLAGS));\n\t\trst_ack = (comm_flags & (u32)(1 << COM_CHAN_RST_ACK_OFFSET)) >>\n\t\t\tCOM_CHAN_RST_ACK_OFFSET;\n\n\t\t \n\t\trst_req = (comm_flags & (u32)(1 << COM_CHAN_RST_REQ_OFFSET)) >>\n\t\t\tCOM_CHAN_RST_REQ_OFFSET;\n\n\t\tif (rst_ack == rst_req) {\n\t\t\tmlx4_warn(dev, \"VF Reset succeed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tcond_resched();\n\t}\n\tmlx4_err(dev, \"Fail to send reset over the communication channel\\n\");\n\treturn -ETIMEDOUT;\n}\n\nint mlx4_comm_internal_err(u32 slave_read)\n{\n\treturn (u32)COMM_CHAN_EVENT_INTERNAL_ERR ==\n\t\t(slave_read & (u32)COMM_CHAN_EVENT_INTERNAL_ERR) ? 1 : 0;\n}\n\nvoid mlx4_enter_error_state(struct mlx4_dev_persistent *persist)\n{\n\tint err;\n\tstruct mlx4_dev *dev;\n\n\tif (!mlx4_internal_err_reset)\n\t\treturn;\n\n\tmutex_lock(&persist->device_state_mutex);\n\tif (persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)\n\t\tgoto out;\n\n\tdev = persist->dev;\n\tmlx4_err(dev, \"device is going to be reset\\n\");\n\tif (mlx4_is_slave(dev)) {\n\t\terr = mlx4_reset_slave(dev);\n\t} else {\n\t\tmlx4_crdump_collect(dev);\n\t\terr = mlx4_reset_master(dev);\n\t}\n\n\tif (!err) {\n\t\tmlx4_err(dev, \"device was reset successfully\\n\");\n\t} else {\n\t\t \n\t\tif (!pci_channel_offline(dev->persist->pdev))\n\t\t\tBUG_ON(1);\n\t}\n\tdev->persist->state |= MLX4_DEVICE_STATE_INTERNAL_ERROR;\n\tmutex_unlock(&persist->device_state_mutex);\n\n\t \n\tmlx4_dispatch_event(dev, MLX4_DEV_EVENT_CATASTROPHIC_ERROR, NULL);\n\tmlx4_cmd_wake_completions(dev);\n\treturn;\n\nout:\n\tmutex_unlock(&persist->device_state_mutex);\n}\n\nstatic void mlx4_handle_error_state(struct mlx4_dev_persistent *persist)\n{\n\tstruct mlx4_dev *dev = persist->dev;\n\tstruct devlink *devlink;\n\tint err = 0;\n\n\tmlx4_enter_error_state(persist);\n\tdevlink = priv_to_devlink(mlx4_priv(dev));\n\tdevl_lock(devlink);\n\tmutex_lock(&persist->interface_state_mutex);\n\tif (persist->interface_state & MLX4_INTERFACE_STATE_UP &&\n\t    !(persist->interface_state & MLX4_INTERFACE_STATE_DELETION)) {\n\t\terr = mlx4_restart_one(persist->pdev);\n\t\tmlx4_info(persist->dev, \"mlx4_restart_one was ended, ret=%d\\n\",\n\t\t\t  err);\n\t}\n\tmutex_unlock(&persist->interface_state_mutex);\n\tdevl_unlock(devlink);\n}\n\nstatic void dump_err_buf(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tint i;\n\n\tmlx4_err(dev, \"Internal error detected:\\n\");\n\tfor (i = 0; i < priv->fw.catas_size; ++i)\n\t\tmlx4_err(dev, \"  buf[%02x]: %08x\\n\",\n\t\t\t i, swab32(readl(priv->catas_err.map + i)));\n}\n\nstatic void poll_catas(struct timer_list *t)\n{\n\tstruct mlx4_priv *priv = from_timer(priv, t, catas_err.timer);\n\tstruct mlx4_dev *dev = &priv->dev;\n\tu32 slave_read;\n\n\tif (mlx4_is_slave(dev)) {\n\t\tslave_read = swab32(readl(&priv->mfunc.comm->slave_read));\n\t\tif (mlx4_comm_internal_err(slave_read)) {\n\t\t\tmlx4_warn(dev, \"Internal error detected on the communication channel\\n\");\n\t\t\tgoto internal_err;\n\t\t}\n\t} else if (readl(priv->catas_err.map)) {\n\t\tdump_err_buf(dev);\n\t\tgoto internal_err;\n\t}\n\n\tif (dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR) {\n\t\tmlx4_warn(dev, \"Internal error mark was detected on device\\n\");\n\t\tgoto internal_err;\n\t}\n\n\tmod_timer(&priv->catas_err.timer,\n\t\t  round_jiffies(jiffies + MLX4_CATAS_POLL_INTERVAL));\n\treturn;\n\ninternal_err:\n\tif (mlx4_internal_err_reset)\n\t\tqueue_work(dev->persist->catas_wq, &dev->persist->catas_work);\n}\n\nstatic void catas_reset(struct work_struct *work)\n{\n\tstruct mlx4_dev_persistent *persist =\n\t\tcontainer_of(work, struct mlx4_dev_persistent,\n\t\t\t     catas_work);\n\n\tmlx4_handle_error_state(persist);\n}\n\nvoid mlx4_start_catas_poll(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tphys_addr_t addr;\n\n\tINIT_LIST_HEAD(&priv->catas_err.list);\n\ttimer_setup(&priv->catas_err.timer, poll_catas, 0);\n\tpriv->catas_err.map = NULL;\n\n\tif (!mlx4_is_slave(dev)) {\n\t\taddr = pci_resource_start(dev->persist->pdev,\n\t\t\t\t\t  priv->fw.catas_bar) +\n\t\t\t\t\t  priv->fw.catas_offset;\n\n\t\tpriv->catas_err.map = ioremap(addr, priv->fw.catas_size * 4);\n\t\tif (!priv->catas_err.map) {\n\t\t\tmlx4_warn(dev, \"Failed to map internal error buffer at 0x%llx\\n\",\n\t\t\t\t  (unsigned long long)addr);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tpriv->catas_err.timer.expires  =\n\t\tround_jiffies(jiffies + MLX4_CATAS_POLL_INTERVAL);\n\tadd_timer(&priv->catas_err.timer);\n}\n\nvoid mlx4_stop_catas_poll(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tdel_timer_sync(&priv->catas_err.timer);\n\n\tif (priv->catas_err.map) {\n\t\tiounmap(priv->catas_err.map);\n\t\tpriv->catas_err.map = NULL;\n\t}\n\n\tif (dev->persist->interface_state & MLX4_INTERFACE_STATE_DELETION)\n\t\tflush_workqueue(dev->persist->catas_wq);\n}\n\nint  mlx4_catas_init(struct mlx4_dev *dev)\n{\n\tINIT_WORK(&dev->persist->catas_work, catas_reset);\n\tdev->persist->catas_wq = create_singlethread_workqueue(\"mlx4_health\");\n\tif (!dev->persist->catas_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid mlx4_catas_end(struct mlx4_dev *dev)\n{\n\tif (dev->persist->catas_wq) {\n\t\tdestroy_workqueue(dev->persist->catas_wq);\n\t\tdev->persist->catas_wq = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}