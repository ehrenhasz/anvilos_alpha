{
  "module_name": "en_ethtool.c",
  "hash_id": "855b95d22d51e031ff7f03e6ac51cca77be5480800d21b9188b25d73518e38af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/mlx4/driver.h>\n#include <linux/mlx4/device.h>\n#include <linux/in.h>\n#include <net/ip.h>\n#include <linux/bitmap.h>\n#include <linux/mii.h>\n\n#include \"mlx4_en.h\"\n#include \"en_port.h\"\n\n#define EN_ETHTOOL_QP_ATTACH (1ull << 63)\n#define EN_ETHTOOL_SHORT_MASK cpu_to_be16(0xffff)\n#define EN_ETHTOOL_WORD_MASK  cpu_to_be32(0xffffffff)\n\nint mlx4_en_moderation_update(struct mlx4_en_priv *priv)\n{\n\tint i, t;\n\tint err = 0;\n\n\tfor (t = 0 ; t < MLX4_EN_NUM_TX_TYPES; t++) {\n\t\tfor (i = 0; i < priv->tx_ring_num[t]; i++) {\n\t\t\tpriv->tx_cq[t][i]->moder_cnt = priv->tx_frames;\n\t\t\tpriv->tx_cq[t][i]->moder_time = priv->tx_usecs;\n\t\t\tif (priv->port_up) {\n\t\t\t\terr = mlx4_en_set_cq_moder(priv,\n\t\t\t\t\t\t\t   priv->tx_cq[t][i]);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (priv->adaptive_rx_coal)\n\t\treturn 0;\n\n\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\tpriv->rx_cq[i]->moder_cnt = priv->rx_frames;\n\t\tpriv->rx_cq[i]->moder_time = priv->rx_usecs;\n\t\tpriv->last_moder_time[i] = MLX4_EN_AUTO_CONF;\n\t\tif (priv->port_up) {\n\t\t\terr = mlx4_en_set_cq_moder(priv, priv->rx_cq[i]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic void\nmlx4_en_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\n\tstrscpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->version, DRV_VERSION,\n\t\tsizeof(drvinfo->version));\n\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t\"%d.%d.%d\",\n\t\t(u16) (mdev->dev->caps.fw_ver >> 32),\n\t\t(u16) ((mdev->dev->caps.fw_ver >> 16) & 0xffff),\n\t\t(u16) (mdev->dev->caps.fw_ver & 0xffff));\n\tstrscpy(drvinfo->bus_info, pci_name(mdev->dev->persist->pdev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic const char mlx4_en_priv_flags[][ETH_GSTRING_LEN] = {\n\t\"blueflame\",\n\t\"phv-bit\"\n};\n\nstatic const char main_strings[][ETH_GSTRING_LEN] = {\n\t \n\t\"rx_packets\", \"tx_packets\", \"rx_bytes\", \"tx_bytes\", \"rx_errors\",\n\t\"tx_errors\", \"rx_dropped\", \"tx_dropped\", \"multicast\", \"collisions\",\n\t\"rx_length_errors\", \"rx_over_errors\", \"rx_crc_errors\",\n\t\"rx_frame_errors\", \"rx_fifo_errors\", \"rx_missed_errors\",\n\t\"tx_aborted_errors\", \"tx_carrier_errors\", \"tx_fifo_errors\",\n\t\"tx_heartbeat_errors\", \"tx_window_errors\",\n\n\t \n\t\"tso_packets\",\n\t\"xmit_more\",\n\t\"queue_stopped\", \"wake_queue\", \"tx_timeout\", \"rx_alloc_pages\",\n\t\"rx_csum_good\", \"rx_csum_none\", \"rx_csum_complete\", \"tx_chksum_offload\",\n\n\t \n\t\"pf_rx_packets\",\n\t\"pf_rx_bytes\",\n\t\"pf_tx_packets\",\n\t\"pf_tx_bytes\",\n\n\t \n\t\"rx_pause_prio_0\", \"rx_pause_duration_prio_0\",\n\t\"rx_pause_transition_prio_0\",\n\t\"rx_pause_prio_1\", \"rx_pause_duration_prio_1\",\n\t\"rx_pause_transition_prio_1\",\n\t\"rx_pause_prio_2\", \"rx_pause_duration_prio_2\",\n\t\"rx_pause_transition_prio_2\",\n\t\"rx_pause_prio_3\", \"rx_pause_duration_prio_3\",\n\t\"rx_pause_transition_prio_3\",\n\t\"rx_pause_prio_4\", \"rx_pause_duration_prio_4\",\n\t\"rx_pause_transition_prio_4\",\n\t\"rx_pause_prio_5\", \"rx_pause_duration_prio_5\",\n\t\"rx_pause_transition_prio_5\",\n\t\"rx_pause_prio_6\", \"rx_pause_duration_prio_6\",\n\t\"rx_pause_transition_prio_6\",\n\t\"rx_pause_prio_7\", \"rx_pause_duration_prio_7\",\n\t\"rx_pause_transition_prio_7\",\n\n\t \n\t\"rx_pause\", \"rx_pause_duration\", \"rx_pause_transition\",\n\n\t \n\t\"tx_pause_prio_0\", \"tx_pause_duration_prio_0\",\n\t\"tx_pause_transition_prio_0\",\n\t\"tx_pause_prio_1\", \"tx_pause_duration_prio_1\",\n\t\"tx_pause_transition_prio_1\",\n\t\"tx_pause_prio_2\", \"tx_pause_duration_prio_2\",\n\t\"tx_pause_transition_prio_2\",\n\t\"tx_pause_prio_3\", \"tx_pause_duration_prio_3\",\n\t\"tx_pause_transition_prio_3\",\n\t\"tx_pause_prio_4\", \"tx_pause_duration_prio_4\",\n\t\"tx_pause_transition_prio_4\",\n\t\"tx_pause_prio_5\", \"tx_pause_duration_prio_5\",\n\t\"tx_pause_transition_prio_5\",\n\t\"tx_pause_prio_6\", \"tx_pause_duration_prio_6\",\n\t\"tx_pause_transition_prio_6\",\n\t\"tx_pause_prio_7\", \"tx_pause_duration_prio_7\",\n\t\"tx_pause_transition_prio_7\",\n\n\t \n\t\"tx_pause\", \"tx_pause_duration\", \"tx_pause_transition\",\n\n\t \n\t\"rx_multicast_packets\",\n\t\"rx_broadcast_packets\",\n\t\"rx_jabbers\",\n\t\"rx_in_range_length_error\",\n\t\"rx_out_range_length_error\",\n\t\"tx_multicast_packets\",\n\t\"tx_broadcast_packets\",\n\t\"rx_prio_0_packets\", \"rx_prio_0_bytes\",\n\t\"rx_prio_1_packets\", \"rx_prio_1_bytes\",\n\t\"rx_prio_2_packets\", \"rx_prio_2_bytes\",\n\t\"rx_prio_3_packets\", \"rx_prio_3_bytes\",\n\t\"rx_prio_4_packets\", \"rx_prio_4_bytes\",\n\t\"rx_prio_5_packets\", \"rx_prio_5_bytes\",\n\t\"rx_prio_6_packets\", \"rx_prio_6_bytes\",\n\t\"rx_prio_7_packets\", \"rx_prio_7_bytes\",\n\t\"rx_novlan_packets\", \"rx_novlan_bytes\",\n\t\"tx_prio_0_packets\", \"tx_prio_0_bytes\",\n\t\"tx_prio_1_packets\", \"tx_prio_1_bytes\",\n\t\"tx_prio_2_packets\", \"tx_prio_2_bytes\",\n\t\"tx_prio_3_packets\", \"tx_prio_3_bytes\",\n\t\"tx_prio_4_packets\", \"tx_prio_4_bytes\",\n\t\"tx_prio_5_packets\", \"tx_prio_5_bytes\",\n\t\"tx_prio_6_packets\", \"tx_prio_6_bytes\",\n\t\"tx_prio_7_packets\", \"tx_prio_7_bytes\",\n\t\"tx_novlan_packets\", \"tx_novlan_bytes\",\n\n\t \n\t\"rx_xdp_drop\",\n\t\"rx_xdp_redirect\",\n\t\"rx_xdp_redirect_fail\",\n\t\"rx_xdp_tx\",\n\t\"rx_xdp_tx_full\",\n\n\t \n\t\"rx_packets_phy\", \"rx_bytes_phy\",\n\t\"tx_packets_phy\", \"tx_bytes_phy\",\n};\n\nstatic const char mlx4_en_test_names[][ETH_GSTRING_LEN]= {\n\t\"Interrupt Test\",\n\t\"Link Test\",\n\t\"Speed Test\",\n\t\"Register Test\",\n\t\"Loopback Test\",\n};\n\nstatic u32 mlx4_en_get_msglevel(struct net_device *dev)\n{\n\treturn ((struct mlx4_en_priv *) netdev_priv(dev))->msg_enable;\n}\n\nstatic void mlx4_en_set_msglevel(struct net_device *dev, u32 val)\n{\n\t((struct mlx4_en_priv *) netdev_priv(dev))->msg_enable = val;\n}\n\nstatic void mlx4_en_get_wol(struct net_device *netdev,\n\t\t\t    struct ethtool_wolinfo *wol)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(netdev);\n\tstruct mlx4_caps *caps = &priv->mdev->dev->caps;\n\tint err = 0;\n\tu64 config = 0;\n\tu64 mask;\n\n\tif ((priv->port < 1) || (priv->port > 2)) {\n\t\ten_err(priv, \"Failed to get WoL information\\n\");\n\t\treturn;\n\t}\n\n\tmask = (priv->port == 1) ? MLX4_DEV_CAP_FLAG_WOL_PORT1 :\n\t\tMLX4_DEV_CAP_FLAG_WOL_PORT2;\n\n\tif (!(caps->flags & mask)) {\n\t\twol->supported = 0;\n\t\twol->wolopts = 0;\n\t\treturn;\n\t}\n\n\tif (caps->wol_port[priv->port])\n\t\twol->supported = WAKE_MAGIC;\n\telse\n\t\twol->supported = 0;\n\n\terr = mlx4_wol_read(priv->mdev->dev, &config, priv->port);\n\tif (err) {\n\t\ten_err(priv, \"Failed to get WoL information\\n\");\n\t\treturn;\n\t}\n\n\tif ((config & MLX4_EN_WOL_ENABLED) && (config & MLX4_EN_WOL_MAGIC))\n\t\twol->wolopts = WAKE_MAGIC;\n\telse\n\t\twol->wolopts = 0;\n}\n\nstatic int mlx4_en_set_wol(struct net_device *netdev,\n\t\t\t    struct ethtool_wolinfo *wol)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(netdev);\n\tu64 config = 0;\n\tint err = 0;\n\tu64 mask;\n\n\tif ((priv->port < 1) || (priv->port > 2))\n\t\treturn -EOPNOTSUPP;\n\n\tmask = (priv->port == 1) ? MLX4_DEV_CAP_FLAG_WOL_PORT1 :\n\t\tMLX4_DEV_CAP_FLAG_WOL_PORT2;\n\n\tif (!(priv->mdev->dev->caps.flags & mask))\n\t\treturn -EOPNOTSUPP;\n\n\tif (wol->supported & ~WAKE_MAGIC)\n\t\treturn -EINVAL;\n\n\terr = mlx4_wol_read(priv->mdev->dev, &config, priv->port);\n\tif (err) {\n\t\ten_err(priv, \"Failed to get WoL info, unable to modify\\n\");\n\t\treturn err;\n\t}\n\n\tif (wol->wolopts & WAKE_MAGIC) {\n\t\tconfig |= MLX4_EN_WOL_DO_MODIFY | MLX4_EN_WOL_ENABLED |\n\t\t\t\tMLX4_EN_WOL_MAGIC;\n\t} else {\n\t\tconfig &= ~(MLX4_EN_WOL_ENABLED | MLX4_EN_WOL_MAGIC);\n\t\tconfig |= MLX4_EN_WOL_DO_MODIFY;\n\t}\n\n\terr = mlx4_wol_write(priv->mdev->dev, config, priv->port);\n\tif (err)\n\t\ten_err(priv, \"Failed to set WoL information\\n\");\n\n\treturn err;\n}\n\nstruct bitmap_iterator {\n\tunsigned long *stats_bitmap;\n\tunsigned int count;\n\tunsigned int iterator;\n\tbool advance_array;  \n};\n\nstatic inline void bitmap_iterator_init(struct bitmap_iterator *h,\n\t\t\t\t\tunsigned long *stats_bitmap,\n\t\t\t\t\tint count)\n{\n\th->iterator = 0;\n\th->advance_array = !bitmap_empty(stats_bitmap, count);\n\th->count = h->advance_array ? bitmap_weight(stats_bitmap, count)\n\t\t: count;\n\th->stats_bitmap = stats_bitmap;\n}\n\nstatic inline int bitmap_iterator_test(struct bitmap_iterator *h)\n{\n\treturn !h->advance_array ? 1 : test_bit(h->iterator, h->stats_bitmap);\n}\n\nstatic inline int bitmap_iterator_inc(struct bitmap_iterator *h)\n{\n\treturn h->iterator++;\n}\n\nstatic inline unsigned int\nbitmap_iterator_count(struct bitmap_iterator *h)\n{\n\treturn h->count;\n}\n\nstatic int mlx4_en_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct bitmap_iterator it;\n\n\tbitmap_iterator_init(&it, priv->stats_bitmap.bitmap, NUM_ALL_STATS);\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn bitmap_iterator_count(&it) +\n\t\t\t(priv->tx_ring_num[TX] * 2) +\n\t\t\t(priv->rx_ring_num * (3 + NUM_XDP_STATS));\n\tcase ETH_SS_TEST:\n\t\treturn MLX4_EN_NUM_SELF_TEST - !(priv->mdev->dev->caps.flags\n\t\t\t\t\t& MLX4_DEV_CAP_FLAG_UC_LOOPBACK) * 2;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn ARRAY_SIZE(mlx4_en_priv_flags);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void mlx4_en_get_ethtool_stats(struct net_device *dev,\n\t\tstruct ethtool_stats *stats, uint64_t *data)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tint index = 0;\n\tint i;\n\tstruct bitmap_iterator it;\n\n\tbitmap_iterator_init(&it, priv->stats_bitmap.bitmap, NUM_ALL_STATS);\n\n\tspin_lock_bh(&priv->stats_lock);\n\n\tmlx4_en_fold_software_stats(dev);\n\n\tfor (i = 0; i < NUM_MAIN_STATS; i++, bitmap_iterator_inc(&it))\n\t\tif (bitmap_iterator_test(&it))\n\t\t\tdata[index++] = ((unsigned long *)&dev->stats)[i];\n\n\tfor (i = 0; i < NUM_PORT_STATS; i++, bitmap_iterator_inc(&it))\n\t\tif (bitmap_iterator_test(&it))\n\t\t\tdata[index++] = ((unsigned long *)&priv->port_stats)[i];\n\n\tfor (i = 0; i < NUM_PF_STATS; i++, bitmap_iterator_inc(&it))\n\t\tif (bitmap_iterator_test(&it))\n\t\t\tdata[index++] =\n\t\t\t\t((unsigned long *)&priv->pf_stats)[i];\n\n\tfor (i = 0; i < NUM_FLOW_PRIORITY_STATS_RX;\n\t     i++, bitmap_iterator_inc(&it))\n\t\tif (bitmap_iterator_test(&it))\n\t\t\tdata[index++] =\n\t\t\t\t((u64 *)&priv->rx_priority_flowstats)[i];\n\n\tfor (i = 0; i < NUM_FLOW_STATS_RX; i++, bitmap_iterator_inc(&it))\n\t\tif (bitmap_iterator_test(&it))\n\t\t\tdata[index++] = ((u64 *)&priv->rx_flowstats)[i];\n\n\tfor (i = 0; i < NUM_FLOW_PRIORITY_STATS_TX;\n\t     i++, bitmap_iterator_inc(&it))\n\t\tif (bitmap_iterator_test(&it))\n\t\t\tdata[index++] =\n\t\t\t\t((u64 *)&priv->tx_priority_flowstats)[i];\n\n\tfor (i = 0; i < NUM_FLOW_STATS_TX; i++, bitmap_iterator_inc(&it))\n\t\tif (bitmap_iterator_test(&it))\n\t\t\tdata[index++] = ((u64 *)&priv->tx_flowstats)[i];\n\n\tfor (i = 0; i < NUM_PKT_STATS; i++, bitmap_iterator_inc(&it))\n\t\tif (bitmap_iterator_test(&it))\n\t\t\tdata[index++] = ((unsigned long *)&priv->pkstats)[i];\n\n\tfor (i = 0; i < NUM_XDP_STATS; i++, bitmap_iterator_inc(&it))\n\t\tif (bitmap_iterator_test(&it))\n\t\t\tdata[index++] = ((unsigned long *)&priv->xdp_stats)[i];\n\n\tfor (i = 0; i < NUM_PHY_STATS; i++, bitmap_iterator_inc(&it))\n\t\tif (bitmap_iterator_test(&it))\n\t\t\tdata[index++] = ((unsigned long *)&priv->phy_stats)[i];\n\n\tfor (i = 0; i < priv->tx_ring_num[TX]; i++) {\n\t\tdata[index++] = priv->tx_ring[TX][i]->packets;\n\t\tdata[index++] = priv->tx_ring[TX][i]->bytes;\n\t}\n\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\tdata[index++] = priv->rx_ring[i]->packets;\n\t\tdata[index++] = priv->rx_ring[i]->bytes;\n\t\tdata[index++] = priv->rx_ring[i]->dropped;\n\t\tdata[index++] = priv->rx_ring[i]->xdp_drop;\n\t\tdata[index++] = priv->rx_ring[i]->xdp_redirect;\n\t\tdata[index++] = priv->rx_ring[i]->xdp_redirect_fail;\n\t\tdata[index++] = priv->rx_ring[i]->xdp_tx;\n\t\tdata[index++] = priv->rx_ring[i]->xdp_tx_full;\n\t}\n\tspin_unlock_bh(&priv->stats_lock);\n\n}\n\nstatic void mlx4_en_self_test(struct net_device *dev,\n\t\t\t      struct ethtool_test *etest, u64 *buf)\n{\n\tmlx4_en_ex_selftest(dev, &etest->flags, buf);\n}\n\nstatic void mlx4_en_get_strings(struct net_device *dev,\n\t\t\t\tuint32_t stringset, uint8_t *data)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tint index = 0;\n\tint i, strings = 0;\n\tstruct bitmap_iterator it;\n\n\tbitmap_iterator_init(&it, priv->stats_bitmap.bitmap, NUM_ALL_STATS);\n\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\tfor (i = 0; i < MLX4_EN_NUM_SELF_TEST - 2; i++)\n\t\t\tstrcpy(data + i * ETH_GSTRING_LEN, mlx4_en_test_names[i]);\n\t\tif (priv->mdev->dev->caps.flags & MLX4_DEV_CAP_FLAG_UC_LOOPBACK)\n\t\t\tfor (; i < MLX4_EN_NUM_SELF_TEST; i++)\n\t\t\t\tstrcpy(data + i * ETH_GSTRING_LEN, mlx4_en_test_names[i]);\n\t\tbreak;\n\n\tcase ETH_SS_STATS:\n\t\t \n\t\tfor (i = 0; i < NUM_MAIN_STATS; i++, strings++,\n\t\t     bitmap_iterator_inc(&it))\n\t\t\tif (bitmap_iterator_test(&it))\n\t\t\t\tstrcpy(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t       main_strings[strings]);\n\n\t\tfor (i = 0; i < NUM_PORT_STATS; i++, strings++,\n\t\t     bitmap_iterator_inc(&it))\n\t\t\tif (bitmap_iterator_test(&it))\n\t\t\t\tstrcpy(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t       main_strings[strings]);\n\n\t\tfor (i = 0; i < NUM_PF_STATS; i++, strings++,\n\t\t     bitmap_iterator_inc(&it))\n\t\t\tif (bitmap_iterator_test(&it))\n\t\t\t\tstrcpy(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t       main_strings[strings]);\n\n\t\tfor (i = 0; i < NUM_FLOW_STATS; i++, strings++,\n\t\t     bitmap_iterator_inc(&it))\n\t\t\tif (bitmap_iterator_test(&it))\n\t\t\t\tstrcpy(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t       main_strings[strings]);\n\n\t\tfor (i = 0; i < NUM_PKT_STATS; i++, strings++,\n\t\t     bitmap_iterator_inc(&it))\n\t\t\tif (bitmap_iterator_test(&it))\n\t\t\t\tstrcpy(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t       main_strings[strings]);\n\n\t\tfor (i = 0; i < NUM_XDP_STATS; i++, strings++,\n\t\t     bitmap_iterator_inc(&it))\n\t\t\tif (bitmap_iterator_test(&it))\n\t\t\t\tstrcpy(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t       main_strings[strings]);\n\n\t\tfor (i = 0; i < NUM_PHY_STATS; i++, strings++,\n\t\t     bitmap_iterator_inc(&it))\n\t\t\tif (bitmap_iterator_test(&it))\n\t\t\t\tstrcpy(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t       main_strings[strings]);\n\n\t\tfor (i = 0; i < priv->tx_ring_num[TX]; i++) {\n\t\t\tsprintf(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t\"tx%d_packets\", i);\n\t\t\tsprintf(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t\"tx%d_bytes\", i);\n\t\t}\n\t\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\t\tsprintf(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t\"rx%d_packets\", i);\n\t\t\tsprintf(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t\"rx%d_bytes\", i);\n\t\t\tsprintf(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t\"rx%d_dropped\", i);\n\t\t\tsprintf(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t\"rx%d_xdp_drop\", i);\n\t\t\tsprintf(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t\"rx%d_xdp_redirect\", i);\n\t\t\tsprintf(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t\"rx%d_xdp_redirect_fail\", i);\n\t\t\tsprintf(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t\"rx%d_xdp_tx\", i);\n\t\t\tsprintf(data + (index++) * ETH_GSTRING_LEN,\n\t\t\t\t\"rx%d_xdp_tx_full\", i);\n\t\t}\n\t\tbreak;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tfor (i = 0; i < ARRAY_SIZE(mlx4_en_priv_flags); i++)\n\t\t\tstrcpy(data + i * ETH_GSTRING_LEN,\n\t\t\t       mlx4_en_priv_flags[i]);\n\t\tbreak;\n\n\t}\n}\n\nstatic u32 mlx4_en_autoneg_get(struct net_device *dev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tu32 autoneg = AUTONEG_DISABLE;\n\n\tif ((mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_ETH_BACKPL_AN_REP) &&\n\t    (priv->port_state.flags & MLX4_EN_PORT_ANE))\n\t\tautoneg = AUTONEG_ENABLE;\n\n\treturn autoneg;\n}\n\nstatic void ptys2ethtool_update_supported_port(unsigned long *mask,\n\t\t\t\t\t       struct mlx4_ptys_reg *ptys_reg)\n{\n\tu32 eth_proto = be32_to_cpu(ptys_reg->eth_proto_cap);\n\n\tif (eth_proto & (MLX4_PROT_MASK(MLX4_10GBASE_T)\n\t\t\t | MLX4_PROT_MASK(MLX4_1000BASE_T)\n\t\t\t | MLX4_PROT_MASK(MLX4_100BASE_TX))) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_TP_BIT, mask);\n\t} else if (eth_proto & (MLX4_PROT_MASK(MLX4_10GBASE_CR)\n\t\t\t | MLX4_PROT_MASK(MLX4_10GBASE_SR)\n\t\t\t | MLX4_PROT_MASK(MLX4_56GBASE_SR4)\n\t\t\t | MLX4_PROT_MASK(MLX4_40GBASE_CR4)\n\t\t\t | MLX4_PROT_MASK(MLX4_40GBASE_SR4)\n\t\t\t | MLX4_PROT_MASK(MLX4_1000BASE_CX_SGMII))) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_FIBRE_BIT, mask);\n\t} else if (eth_proto & (MLX4_PROT_MASK(MLX4_56GBASE_KR4)\n\t\t\t | MLX4_PROT_MASK(MLX4_40GBASE_KR4)\n\t\t\t | MLX4_PROT_MASK(MLX4_20GBASE_KR2)\n\t\t\t | MLX4_PROT_MASK(MLX4_10GBASE_KR)\n\t\t\t | MLX4_PROT_MASK(MLX4_10GBASE_KX4)\n\t\t\t | MLX4_PROT_MASK(MLX4_1000BASE_KX))) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_Backplane_BIT, mask);\n\t}\n}\n\nstatic u32 ptys_get_active_port(struct mlx4_ptys_reg *ptys_reg)\n{\n\tu32 eth_proto = be32_to_cpu(ptys_reg->eth_proto_oper);\n\n\tif (!eth_proto)  \n\t\teth_proto = be32_to_cpu(ptys_reg->eth_proto_cap);\n\n\tif (eth_proto & (MLX4_PROT_MASK(MLX4_10GBASE_T)\n\t\t\t | MLX4_PROT_MASK(MLX4_1000BASE_T)\n\t\t\t | MLX4_PROT_MASK(MLX4_100BASE_TX))) {\n\t\t\treturn PORT_TP;\n\t}\n\n\tif (eth_proto & (MLX4_PROT_MASK(MLX4_10GBASE_SR)\n\t\t\t | MLX4_PROT_MASK(MLX4_56GBASE_SR4)\n\t\t\t | MLX4_PROT_MASK(MLX4_40GBASE_SR4)\n\t\t\t | MLX4_PROT_MASK(MLX4_1000BASE_CX_SGMII))) {\n\t\t\treturn PORT_FIBRE;\n\t}\n\n\tif (eth_proto & (MLX4_PROT_MASK(MLX4_10GBASE_CR)\n\t\t\t | MLX4_PROT_MASK(MLX4_56GBASE_CR4)\n\t\t\t | MLX4_PROT_MASK(MLX4_40GBASE_CR4))) {\n\t\t\treturn PORT_DA;\n\t}\n\n\tif (eth_proto & (MLX4_PROT_MASK(MLX4_56GBASE_KR4)\n\t\t\t | MLX4_PROT_MASK(MLX4_40GBASE_KR4)\n\t\t\t | MLX4_PROT_MASK(MLX4_20GBASE_KR2)\n\t\t\t | MLX4_PROT_MASK(MLX4_10GBASE_KR)\n\t\t\t | MLX4_PROT_MASK(MLX4_10GBASE_KX4)\n\t\t\t | MLX4_PROT_MASK(MLX4_1000BASE_KX))) {\n\t\t\treturn PORT_NONE;\n\t}\n\treturn PORT_OTHER;\n}\n\n#define MLX4_LINK_MODES_SZ \\\n\t(sizeof_field(struct mlx4_ptys_reg, eth_proto_cap) * 8)\n\nenum ethtool_report {\n\tSUPPORTED = 0,\n\tADVERTISED = 1,\n};\n\nstruct ptys2ethtool_config {\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(supported);\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(advertised);\n\tu32 speed;\n};\n\nstatic unsigned long *ptys2ethtool_link_mode(struct ptys2ethtool_config *cfg,\n\t\t\t\t\t     enum ethtool_report report)\n{\n\tswitch (report) {\n\tcase SUPPORTED:\n\t\treturn cfg->supported;\n\tcase ADVERTISED:\n\t\treturn cfg->advertised;\n\t}\n\treturn NULL;\n}\n\n#define MLX4_BUILD_PTYS2ETHTOOL_CONFIG(reg_, speed_, ...)\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tstruct ptys2ethtool_config *cfg;\t\t\t\\\n\t\tstatic const unsigned int modes[] = { __VA_ARGS__ };\t\\\n\t\tunsigned int i;\t\t\t\t\t\t\\\n\t\tcfg = &ptys2ethtool_map[reg_];\t\t\t\t\\\n\t\tcfg->speed = speed_;\t\t\t\t\t\\\n\t\tlinkmode_zero(cfg->supported);\t\t\t\t\\\n\t\tlinkmode_zero(cfg->advertised);\t\t\t\t\\\n\t\tfor (i = 0 ; i < ARRAY_SIZE(modes) ; ++i) {\t\t\\\n\t\t\t__set_bit(modes[i], cfg->supported);\t\t\\\n\t\t\t__set_bit(modes[i], cfg->advertised);\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t})\n\n \nstatic struct ptys2ethtool_config ptys2ethtool_map[MLX4_LINK_MODES_SZ];\n\nvoid __init mlx4_en_init_ptys2ethtool_map(void)\n{\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_100BASE_TX, SPEED_100,\n\t\t\t\t       ETHTOOL_LINK_MODE_100baseT_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_1000BASE_T, SPEED_1000,\n\t\t\t\t       ETHTOOL_LINK_MODE_1000baseT_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_1000BASE_CX_SGMII, SPEED_1000,\n\t\t\t\t       ETHTOOL_LINK_MODE_1000baseX_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_1000BASE_KX, SPEED_1000,\n\t\t\t\t       ETHTOOL_LINK_MODE_1000baseKX_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_10GBASE_T, SPEED_10000,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseT_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_10GBASE_CX4, SPEED_10000,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_10GBASE_KX4, SPEED_10000,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_10GBASE_KR, SPEED_10000,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseKR_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_10GBASE_CR, SPEED_10000,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseCR_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_10GBASE_SR, SPEED_10000,\n\t\t\t\t       ETHTOOL_LINK_MODE_10000baseSR_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_20GBASE_KR2, SPEED_20000,\n\t\t\t\t       ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT,\n\t\t\t\t       ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_40GBASE_CR4, SPEED_40000,\n\t\t\t\t       ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_40GBASE_KR4, SPEED_40000,\n\t\t\t\t       ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_40GBASE_SR4, SPEED_40000,\n\t\t\t\t       ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_56GBASE_KR4, SPEED_56000,\n\t\t\t\t       ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_56GBASE_CR4, SPEED_56000,\n\t\t\t\t       ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT);\n\tMLX4_BUILD_PTYS2ETHTOOL_CONFIG(MLX4_56GBASE_SR4, SPEED_56000,\n\t\t\t\t       ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT);\n};\n\nstatic void ptys2ethtool_update_link_modes(unsigned long *link_modes,\n\t\t\t\t\t   u32 eth_proto,\n\t\t\t\t\t   enum ethtool_report report)\n{\n\tint i;\n\tfor (i = 0; i < MLX4_LINK_MODES_SZ; i++) {\n\t\tif (eth_proto & MLX4_PROT_MASK(i))\n\t\t\tlinkmode_or(link_modes, link_modes,\n\t\t\t\t    ptys2ethtool_link_mode(&ptys2ethtool_map[i], report));\n\t}\n}\n\nstatic u32 ethtool2ptys_link_modes(const unsigned long *link_modes,\n\t\t\t\t   enum ethtool_report report)\n{\n\tint i;\n\tu32 ptys_modes = 0;\n\n\tfor (i = 0; i < MLX4_LINK_MODES_SZ; i++) {\n\t\tulong *map_mode = ptys2ethtool_link_mode(&ptys2ethtool_map[i],\n\t\t\t\t\t\t\t report);\n\t\tif (linkmode_intersects(map_mode, link_modes))\n\t\t\tptys_modes |= 1 << i;\n\t}\n\treturn ptys_modes;\n}\n\n \nstatic u32 speed2ptys_link_modes(u32 speed)\n{\n\tint i;\n\tu32 ptys_modes = 0;\n\n\tfor (i = 0; i < MLX4_LINK_MODES_SZ; i++) {\n\t\tif (ptys2ethtool_map[i].speed == speed)\n\t\t\tptys_modes |= 1 << i;\n\t}\n\treturn ptys_modes;\n}\n\nstatic int\nethtool_get_ptys_link_ksettings(struct net_device *dev,\n\t\t\t\tstruct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_ptys_reg ptys_reg;\n\tu32 eth_proto;\n\tint ret;\n\n\tmemset(&ptys_reg, 0, sizeof(ptys_reg));\n\tptys_reg.local_port = priv->port;\n\tptys_reg.proto_mask = MLX4_PTYS_EN;\n\tret = mlx4_ACCESS_PTYS_REG(priv->mdev->dev,\n\t\t\t\t   MLX4_ACCESS_REG_QUERY, &ptys_reg);\n\tif (ret) {\n\t\ten_warn(priv, \"Failed to run mlx4_ACCESS_PTYS_REG status(%x)\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\ten_dbg(DRV, priv, \"ptys_reg.proto_mask       %x\\n\",\n\t       ptys_reg.proto_mask);\n\ten_dbg(DRV, priv, \"ptys_reg.eth_proto_cap    %x\\n\",\n\t       be32_to_cpu(ptys_reg.eth_proto_cap));\n\ten_dbg(DRV, priv, \"ptys_reg.eth_proto_admin  %x\\n\",\n\t       be32_to_cpu(ptys_reg.eth_proto_admin));\n\ten_dbg(DRV, priv, \"ptys_reg.eth_proto_oper   %x\\n\",\n\t       be32_to_cpu(ptys_reg.eth_proto_oper));\n\ten_dbg(DRV, priv, \"ptys_reg.eth_proto_lp_adv %x\\n\",\n\t       be32_to_cpu(ptys_reg.eth_proto_lp_adv));\n\n\t \n\tethtool_link_ksettings_zero_link_mode(link_ksettings, supported);\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, advertising);\n\n\tptys2ethtool_update_supported_port(link_ksettings->link_modes.supported,\n\t\t\t\t\t   &ptys_reg);\n\n\teth_proto = be32_to_cpu(ptys_reg.eth_proto_cap);\n\tptys2ethtool_update_link_modes(link_ksettings->link_modes.supported,\n\t\t\t\t       eth_proto, SUPPORTED);\n\n\teth_proto = be32_to_cpu(ptys_reg.eth_proto_admin);\n\tptys2ethtool_update_link_modes(link_ksettings->link_modes.advertising,\n\t\t\t\t       eth_proto, ADVERTISED);\n\n\tethtool_link_ksettings_add_link_mode(link_ksettings, supported,\n\t\t\t\t\t     Pause);\n\tethtool_link_ksettings_add_link_mode(link_ksettings, supported,\n\t\t\t\t\t     Asym_Pause);\n\n\tif (priv->prof->tx_pause)\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, Pause);\n\tif (priv->prof->tx_pause ^ priv->prof->rx_pause)\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, Asym_Pause);\n\n\tlink_ksettings->base.port = ptys_get_active_port(&ptys_reg);\n\n\tif (mlx4_en_autoneg_get(dev)) {\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     supported, Autoneg);\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, Autoneg);\n\t}\n\n\tlink_ksettings->base.autoneg\n\t\t= (priv->port_state.flags & MLX4_EN_PORT_ANC) ?\n\t\tAUTONEG_ENABLE : AUTONEG_DISABLE;\n\n\teth_proto = be32_to_cpu(ptys_reg.eth_proto_lp_adv);\n\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, lp_advertising);\n\tptys2ethtool_update_link_modes(\n\t\tlink_ksettings->link_modes.lp_advertising,\n\t\teth_proto, ADVERTISED);\n\tif (priv->port_state.flags & MLX4_EN_PORT_ANC)\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     lp_advertising, Autoneg);\n\n\tlink_ksettings->base.phy_address = 0;\n\tlink_ksettings->base.mdio_support = 0;\n\tlink_ksettings->base.eth_tp_mdix = ETH_TP_MDI_INVALID;\n\tlink_ksettings->base.eth_tp_mdix_ctrl = ETH_TP_MDI_AUTO;\n\n\treturn ret;\n}\n\nstatic void\nethtool_get_default_link_ksettings(\n\tstruct net_device *dev, struct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tint trans_type;\n\n\tlink_ksettings->base.autoneg = AUTONEG_DISABLE;\n\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, supported);\n\tethtool_link_ksettings_add_link_mode(link_ksettings, supported,\n\t\t\t\t\t     10000baseT_Full);\n\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, advertising);\n\tethtool_link_ksettings_add_link_mode(link_ksettings, advertising,\n\t\t\t\t\t     10000baseT_Full);\n\n\ttrans_type = priv->port_state.transceiver;\n\tif (trans_type > 0 && trans_type <= 0xC) {\n\t\tlink_ksettings->base.port = PORT_FIBRE;\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     supported, FIBRE);\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, FIBRE);\n\t} else if (trans_type == 0x80 || trans_type == 0) {\n\t\tlink_ksettings->base.port = PORT_TP;\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     supported, TP);\n\t\tethtool_link_ksettings_add_link_mode(link_ksettings,\n\t\t\t\t\t\t     advertising, TP);\n\t} else  {\n\t\tlink_ksettings->base.port = -1;\n\t}\n}\n\nstatic int\nmlx4_en_get_link_ksettings(struct net_device *dev,\n\t\t\t   struct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tint ret = -EINVAL;\n\n\tif (mlx4_en_QUERY_PORT(priv->mdev, priv->port))\n\t\treturn -ENOMEM;\n\n\ten_dbg(DRV, priv, \"query port state.flags ANC(%x) ANE(%x)\\n\",\n\t       priv->port_state.flags & MLX4_EN_PORT_ANC,\n\t       priv->port_state.flags & MLX4_EN_PORT_ANE);\n\n\tif (priv->mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_ETH_PROT_CTRL)\n\t\tret = ethtool_get_ptys_link_ksettings(dev, link_ksettings);\n\tif (ret)  \n\t\tethtool_get_default_link_ksettings(dev, link_ksettings);\n\n\tif (netif_carrier_ok(dev)) {\n\t\tlink_ksettings->base.speed = priv->port_state.link_speed;\n\t\tlink_ksettings->base.duplex = DUPLEX_FULL;\n\t} else {\n\t\tlink_ksettings->base.speed = SPEED_UNKNOWN;\n\t\tlink_ksettings->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\treturn 0;\n}\n\n \nstatic __be32 speed_set_ptys_admin(struct mlx4_en_priv *priv, u32 speed,\n\t\t\t\t   __be32 proto_cap)\n{\n\t__be32 proto_admin = 0;\n\n\tif (!speed) {  \n\t\tproto_admin = proto_cap;\n\t\ten_info(priv, \"Speed was set to 0, Reset advertised Link Modes to default (%x)\\n\",\n\t\t\tbe32_to_cpu(proto_cap));\n\t} else {\n\t\tu32 ptys_link_modes = speed2ptys_link_modes(speed);\n\n\t\tproto_admin = cpu_to_be32(ptys_link_modes) & proto_cap;\n\t\ten_info(priv, \"Setting Speed to %d\\n\", speed);\n\t}\n\treturn proto_admin;\n}\n\nstatic int\nmlx4_en_set_link_ksettings(struct net_device *dev,\n\t\t\t   const struct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_ptys_reg ptys_reg;\n\t__be32 proto_admin;\n\tu8 cur_autoneg;\n\tint ret;\n\n\tu32 ptys_adv = ethtool2ptys_link_modes(\n\t\tlink_ksettings->link_modes.advertising, ADVERTISED);\n\tconst int speed = link_ksettings->base.speed;\n\n\ten_dbg(DRV, priv,\n\t       \"Set Speed=%d adv={%*pbl} autoneg=%d duplex=%d\\n\",\n\t       speed, __ETHTOOL_LINK_MODE_MASK_NBITS,\n\t       link_ksettings->link_modes.advertising,\n\t       link_ksettings->base.autoneg,\n\t       link_ksettings->base.duplex);\n\n\tif (!(priv->mdev->dev->caps.flags2 &\n\t      MLX4_DEV_CAP_FLAG2_ETH_PROT_CTRL) ||\n\t    (link_ksettings->base.duplex == DUPLEX_HALF))\n\t\treturn -EINVAL;\n\n\tmemset(&ptys_reg, 0, sizeof(ptys_reg));\n\tptys_reg.local_port = priv->port;\n\tptys_reg.proto_mask = MLX4_PTYS_EN;\n\tret = mlx4_ACCESS_PTYS_REG(priv->mdev->dev,\n\t\t\t\t   MLX4_ACCESS_REG_QUERY, &ptys_reg);\n\tif (ret) {\n\t\ten_warn(priv, \"Failed to QUERY mlx4_ACCESS_PTYS_REG status(%x)\\n\",\n\t\t\tret);\n\t\treturn 0;\n\t}\n\n\tcur_autoneg = ptys_reg.flags & MLX4_PTYS_AN_DISABLE_ADMIN ?\n\t\t\t\tAUTONEG_DISABLE : AUTONEG_ENABLE;\n\n\tif (link_ksettings->base.autoneg == AUTONEG_DISABLE) {\n\t\tproto_admin = speed_set_ptys_admin(priv, speed,\n\t\t\t\t\t\t   ptys_reg.eth_proto_cap);\n\t\tif ((be32_to_cpu(proto_admin) &\n\t\t     (MLX4_PROT_MASK(MLX4_1000BASE_CX_SGMII) |\n\t\t      MLX4_PROT_MASK(MLX4_1000BASE_KX))) &&\n\t\t    (ptys_reg.flags & MLX4_PTYS_AN_DISABLE_CAP))\n\t\t\tptys_reg.flags |= MLX4_PTYS_AN_DISABLE_ADMIN;\n\t} else {\n\t\tproto_admin = cpu_to_be32(ptys_adv);\n\t\tptys_reg.flags &= ~MLX4_PTYS_AN_DISABLE_ADMIN;\n\t}\n\n\tproto_admin &= ptys_reg.eth_proto_cap;\n\tif (!proto_admin) {\n\t\ten_warn(priv, \"Not supported link mode(s) requested, check supported link modes.\\n\");\n\t\treturn -EINVAL;  \n\t}\n\n\tif ((proto_admin == ptys_reg.eth_proto_admin) &&\n\t    ((ptys_reg.flags & MLX4_PTYS_AN_DISABLE_CAP) &&\n\t     (link_ksettings->base.autoneg == cur_autoneg)))\n\t\treturn 0;  \n\n\ten_dbg(DRV, priv, \"mlx4_ACCESS_PTYS_REG SET: ptys_reg.eth_proto_admin = 0x%x\\n\",\n\t       be32_to_cpu(proto_admin));\n\n\tptys_reg.eth_proto_admin = proto_admin;\n\tret = mlx4_ACCESS_PTYS_REG(priv->mdev->dev, MLX4_ACCESS_REG_WRITE,\n\t\t\t\t   &ptys_reg);\n\tif (ret) {\n\t\ten_warn(priv, \"Failed to write mlx4_ACCESS_PTYS_REG eth_proto_admin(0x%x) status(0x%x)\",\n\t\t\tbe32_to_cpu(ptys_reg.eth_proto_admin), ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&priv->mdev->state_lock);\n\tif (priv->port_up) {\n\t\ten_warn(priv, \"Port link mode changed, restarting port...\\n\");\n\t\tmlx4_en_stop_port(dev, 1);\n\t\tif (mlx4_en_start_port(dev))\n\t\t\ten_err(priv, \"Failed restarting port %d\\n\", priv->port);\n\t}\n\tmutex_unlock(&priv->mdev->state_lock);\n\treturn 0;\n}\n\nstatic int mlx4_en_get_coalesce(struct net_device *dev,\n\t\t\t\tstruct ethtool_coalesce *coal,\n\t\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\tcoal->tx_coalesce_usecs = priv->tx_usecs;\n\tcoal->tx_max_coalesced_frames = priv->tx_frames;\n\tcoal->tx_max_coalesced_frames_irq = priv->tx_work_limit;\n\n\tcoal->rx_coalesce_usecs = priv->rx_usecs;\n\tcoal->rx_max_coalesced_frames = priv->rx_frames;\n\n\tcoal->pkt_rate_low = priv->pkt_rate_low;\n\tcoal->rx_coalesce_usecs_low = priv->rx_usecs_low;\n\tcoal->pkt_rate_high = priv->pkt_rate_high;\n\tcoal->rx_coalesce_usecs_high = priv->rx_usecs_high;\n\tcoal->rate_sample_interval = priv->sample_interval;\n\tcoal->use_adaptive_rx_coalesce = priv->adaptive_rx_coal;\n\n\treturn 0;\n}\n\nstatic int mlx4_en_set_coalesce(struct net_device *dev,\n\t\t\t\tstruct ethtool_coalesce *coal,\n\t\t\t\tstruct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\tif (!coal->tx_max_coalesced_frames_irq)\n\t\treturn -EINVAL;\n\n\tif (coal->tx_coalesce_usecs > MLX4_EN_MAX_COAL_TIME ||\n\t    coal->rx_coalesce_usecs > MLX4_EN_MAX_COAL_TIME ||\n\t    coal->rx_coalesce_usecs_low > MLX4_EN_MAX_COAL_TIME ||\n\t    coal->rx_coalesce_usecs_high > MLX4_EN_MAX_COAL_TIME) {\n\t\tnetdev_info(dev, \"%s: maximum coalesce time supported is %d usecs\\n\",\n\t\t\t    __func__, MLX4_EN_MAX_COAL_TIME);\n\t\treturn -ERANGE;\n\t}\n\n\tif (coal->tx_max_coalesced_frames > MLX4_EN_MAX_COAL_PKTS ||\n\t    coal->rx_max_coalesced_frames > MLX4_EN_MAX_COAL_PKTS) {\n\t\tnetdev_info(dev, \"%s: maximum coalesced frames supported is %d\\n\",\n\t\t\t    __func__, MLX4_EN_MAX_COAL_PKTS);\n\t\treturn -ERANGE;\n\t}\n\n\tpriv->rx_frames = (coal->rx_max_coalesced_frames ==\n\t\t\t   MLX4_EN_AUTO_CONF) ?\n\t\t\t\tMLX4_EN_RX_COAL_TARGET :\n\t\t\t\tcoal->rx_max_coalesced_frames;\n\tpriv->rx_usecs = (coal->rx_coalesce_usecs ==\n\t\t\t  MLX4_EN_AUTO_CONF) ?\n\t\t\t\tMLX4_EN_RX_COAL_TIME :\n\t\t\t\tcoal->rx_coalesce_usecs;\n\n\t \n\tif (coal->tx_coalesce_usecs != priv->tx_usecs ||\n\t    coal->tx_max_coalesced_frames != priv->tx_frames) {\n\t\tpriv->tx_usecs = coal->tx_coalesce_usecs;\n\t\tpriv->tx_frames = coal->tx_max_coalesced_frames;\n\t}\n\n\t \n\tpriv->pkt_rate_low = coal->pkt_rate_low;\n\tpriv->rx_usecs_low = coal->rx_coalesce_usecs_low;\n\tpriv->pkt_rate_high = coal->pkt_rate_high;\n\tpriv->rx_usecs_high = coal->rx_coalesce_usecs_high;\n\tpriv->sample_interval = coal->rate_sample_interval;\n\tpriv->adaptive_rx_coal = coal->use_adaptive_rx_coalesce;\n\tpriv->tx_work_limit = coal->tx_max_coalesced_frames_irq;\n\n\treturn mlx4_en_moderation_update(priv);\n}\n\nstatic int mlx4_en_set_pauseparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_pauseparam *pause)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tu8 tx_pause, tx_ppp, rx_pause, rx_ppp;\n\tint err;\n\n\tif (pause->autoneg)\n\t\treturn -EINVAL;\n\n\ttx_pause = !!(pause->tx_pause);\n\trx_pause = !!(pause->rx_pause);\n\trx_ppp = (tx_pause || rx_pause) ? 0 : priv->prof->rx_ppp;\n\ttx_ppp = (tx_pause || rx_pause) ? 0 : priv->prof->tx_ppp;\n\n\terr = mlx4_SET_PORT_general(mdev->dev, priv->port,\n\t\t\t\t    priv->rx_skb_size + ETH_FCS_LEN,\n\t\t\t\t    tx_pause, tx_ppp, rx_pause, rx_ppp);\n\tif (err) {\n\t\ten_err(priv, \"Failed setting pause params, err = %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tmlx4_en_update_pfc_stats_bitmap(mdev->dev, &priv->stats_bitmap,\n\t\t\t\t\trx_ppp, rx_pause, tx_ppp, tx_pause);\n\n\tpriv->prof->tx_pause = tx_pause;\n\tpriv->prof->rx_pause = rx_pause;\n\tpriv->prof->tx_ppp = tx_ppp;\n\tpriv->prof->rx_ppp = rx_ppp;\n\n\treturn err;\n}\n\nstatic void mlx4_en_get_pause_stats(struct net_device *dev,\n\t\t\t\t    struct ethtool_pause_stats *stats)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct bitmap_iterator it;\n\n\tbitmap_iterator_init(&it, priv->stats_bitmap.bitmap, NUM_ALL_STATS);\n\n\tspin_lock_bh(&priv->stats_lock);\n\tif (test_bit(FLOW_PRIORITY_STATS_IDX_TX_FRAMES,\n\t\t     priv->stats_bitmap.bitmap))\n\t\tstats->tx_pause_frames = priv->tx_flowstats.tx_pause;\n\tif (test_bit(FLOW_PRIORITY_STATS_IDX_RX_FRAMES,\n\t\t     priv->stats_bitmap.bitmap))\n\t\tstats->rx_pause_frames = priv->rx_flowstats.rx_pause;\n\tspin_unlock_bh(&priv->stats_lock);\n}\n\nstatic void mlx4_en_get_pauseparam(struct net_device *dev,\n\t\t\t\t struct ethtool_pauseparam *pause)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\tpause->tx_pause = priv->prof->tx_pause;\n\tpause->rx_pause = priv->prof->rx_pause;\n}\n\nstatic int mlx4_en_set_ringparam(struct net_device *dev,\n\t\t\t\t struct ethtool_ringparam *param,\n\t\t\t\t struct kernel_ethtool_ringparam *kernel_param,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_en_port_profile new_prof;\n\tstruct mlx4_en_priv *tmp;\n\tu32 rx_size, tx_size;\n\tint port_up = 0;\n\tint err = 0;\n\n\tif (param->rx_jumbo_pending || param->rx_mini_pending)\n\t\treturn -EINVAL;\n\n\tif (param->rx_pending < MLX4_EN_MIN_RX_SIZE) {\n\t\ten_warn(priv, \"%s: rx_pending (%d) < min (%d)\\n\",\n\t\t\t__func__, param->rx_pending,\n\t\t\tMLX4_EN_MIN_RX_SIZE);\n\t\treturn -EINVAL;\n\t}\n\tif (param->tx_pending < MLX4_EN_MIN_TX_SIZE) {\n\t\ten_warn(priv, \"%s: tx_pending (%d) < min (%lu)\\n\",\n\t\t\t__func__, param->tx_pending,\n\t\t\tMLX4_EN_MIN_TX_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\trx_size = roundup_pow_of_two(param->rx_pending);\n\ttx_size = roundup_pow_of_two(param->tx_pending);\n\n\tif (rx_size == (priv->port_up ? priv->rx_ring[0]->actual_size :\n\t\t\t\t\tpriv->rx_ring[0]->size) &&\n\t    tx_size == priv->tx_ring[TX][0]->size)\n\t\treturn 0;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&mdev->state_lock);\n\tmemcpy(&new_prof, priv->prof, sizeof(struct mlx4_en_port_profile));\n\tnew_prof.tx_ring_size = tx_size;\n\tnew_prof.rx_ring_size = rx_size;\n\terr = mlx4_en_try_alloc_resources(priv, tmp, &new_prof, true);\n\tif (err)\n\t\tgoto out;\n\n\tif (priv->port_up) {\n\t\tport_up = 1;\n\t\tmlx4_en_stop_port(dev, 1);\n\t}\n\n\tmlx4_en_safe_replace_resources(priv, tmp);\n\n\tif (port_up) {\n\t\terr = mlx4_en_start_port(dev);\n\t\tif (err)\n\t\t\ten_err(priv, \"Failed starting port\\n\");\n\t}\n\n\terr = mlx4_en_moderation_update(priv);\nout:\n\tkfree(tmp);\n\tmutex_unlock(&mdev->state_lock);\n\treturn err;\n}\n\nstatic void mlx4_en_get_ringparam(struct net_device *dev,\n\t\t\t\t  struct ethtool_ringparam *param,\n\t\t\t\t  struct kernel_ethtool_ringparam *kernel_param,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\tmemset(param, 0, sizeof(*param));\n\tparam->rx_max_pending = MLX4_EN_MAX_RX_SIZE;\n\tparam->tx_max_pending = MLX4_EN_MAX_TX_SIZE;\n\tparam->rx_pending = priv->port_up ?\n\t\tpriv->rx_ring[0]->actual_size : priv->rx_ring[0]->size;\n\tparam->tx_pending = priv->tx_ring[TX][0]->size;\n}\n\nstatic u32 mlx4_en_get_rxfh_indir_size(struct net_device *dev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\treturn rounddown_pow_of_two(priv->rx_ring_num);\n}\n\nstatic u32 mlx4_en_get_rxfh_key_size(struct net_device *netdev)\n{\n\treturn MLX4_EN_RSS_KEY_SIZE;\n}\n\nstatic int mlx4_en_check_rxfh_func(struct net_device *dev, u8 hfunc)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\t \n\tif (hfunc == ETH_RSS_HASH_TOP) {\n\t\tif (!(priv->mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_RSS_TOP))\n\t\t\treturn -EINVAL;\n\t\tif (!(dev->features & NETIF_F_RXHASH))\n\t\t\ten_warn(priv, \"Toeplitz hash function should be used in conjunction with RX hashing for optimal performance\\n\");\n\t\treturn 0;\n\t} else if (hfunc == ETH_RSS_HASH_XOR) {\n\t\tif (!(priv->mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_RSS_XOR))\n\t\t\treturn -EINVAL;\n\t\tif (dev->features & NETIF_F_RXHASH)\n\t\t\ten_warn(priv, \"Enabling both XOR Hash function and RX Hashing can limit RPS functionality\\n\");\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mlx4_en_get_rxfh(struct net_device *dev, u32 *ring_index, u8 *key,\n\t\t\t    u8 *hfunc)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tu32 n = mlx4_en_get_rxfh_indir_size(dev);\n\tu32 i, rss_rings;\n\n\trss_rings = priv->prof->rss_rings ?: n;\n\trss_rings = rounddown_pow_of_two(rss_rings);\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (!ring_index)\n\t\t\tbreak;\n\t\tring_index[i] = i % rss_rings;\n\t}\n\tif (key)\n\t\tmemcpy(key, priv->rss_key, MLX4_EN_RSS_KEY_SIZE);\n\tif (hfunc)\n\t\t*hfunc = priv->rss_hash_fn;\n\treturn 0;\n}\n\nstatic int mlx4_en_set_rxfh(struct net_device *dev, const u32 *ring_index,\n\t\t\t    const u8 *key, const u8 hfunc)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tu32 n = mlx4_en_get_rxfh_indir_size(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint port_up = 0;\n\tint err = 0;\n\tint i;\n\tint rss_rings = 0;\n\n\t \n\tfor (i = 0; i < n; i++) {\n\t\tif (!ring_index)\n\t\t\tbreak;\n\t\tif (i > 0 && !ring_index[i] && !rss_rings)\n\t\t\trss_rings = i;\n\n\t\tif (ring_index[i] != (i % (rss_rings ?: n)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rss_rings)\n\t\trss_rings = n;\n\n\t \n\tif (!is_power_of_2(rss_rings))\n\t\treturn -EINVAL;\n\n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE) {\n\t\terr = mlx4_en_check_rxfh_func(dev, hfunc);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmutex_lock(&mdev->state_lock);\n\tif (priv->port_up) {\n\t\tport_up = 1;\n\t\tmlx4_en_stop_port(dev, 1);\n\t}\n\n\tif (ring_index)\n\t\tpriv->prof->rss_rings = rss_rings;\n\tif (key)\n\t\tmemcpy(priv->rss_key, key, MLX4_EN_RSS_KEY_SIZE);\n\tif (hfunc !=  ETH_RSS_HASH_NO_CHANGE)\n\t\tpriv->rss_hash_fn = hfunc;\n\n\tif (port_up) {\n\t\terr = mlx4_en_start_port(dev);\n\t\tif (err)\n\t\t\ten_err(priv, \"Failed starting port\\n\");\n\t}\n\n\tmutex_unlock(&mdev->state_lock);\n\treturn err;\n}\n\n#define all_zeros_or_all_ones(field)\t\t\\\n\t((field) == 0 || (field) == (__force typeof(field))-1)\n\nstatic int mlx4_en_validate_flow(struct net_device *dev,\n\t\t\t\t struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_usrip4_spec *l3_mask;\n\tstruct ethtool_tcpip4_spec *l4_mask;\n\tstruct ethhdr *eth_mask;\n\n\tif (cmd->fs.location >= MAX_NUM_OF_FS_RULES)\n\t\treturn -EINVAL;\n\n\tif (cmd->fs.flow_type & FLOW_MAC_EXT) {\n\t\t \n\t\tif (!is_broadcast_ether_addr(cmd->fs.m_ext.h_dest))\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd->fs.flow_type & ~(FLOW_EXT | FLOW_MAC_EXT)) {\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\t\tif (cmd->fs.m_u.tcp_ip4_spec.tos)\n\t\t\treturn -EINVAL;\n\t\tl4_mask = &cmd->fs.m_u.tcp_ip4_spec;\n\t\t \n\t\tif (!all_zeros_or_all_ones(l4_mask->ip4src) ||\n\t\t    !all_zeros_or_all_ones(l4_mask->ip4dst) ||\n\t\t    !all_zeros_or_all_ones(l4_mask->psrc) ||\n\t\t    !all_zeros_or_all_ones(l4_mask->pdst))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tl3_mask = &cmd->fs.m_u.usr_ip4_spec;\n\t\tif (l3_mask->l4_4_bytes || l3_mask->tos || l3_mask->proto ||\n\t\t    cmd->fs.h_u.usr_ip4_spec.ip_ver != ETH_RX_NFC_IP4 ||\n\t\t    (!l3_mask->ip4src && !l3_mask->ip4dst) ||\n\t\t    !all_zeros_or_all_ones(l3_mask->ip4src) ||\n\t\t    !all_zeros_or_all_ones(l3_mask->ip4dst))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase ETHER_FLOW:\n\t\teth_mask = &cmd->fs.m_u.ether_spec;\n\t\t \n\t\tif (!is_zero_ether_addr(eth_mask->h_source))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!is_broadcast_ether_addr(eth_mask->h_dest))\n\t\t\treturn -EINVAL;\n\n\t\tif (!all_zeros_or_all_ones(eth_mask->h_proto))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((cmd->fs.flow_type & FLOW_EXT)) {\n\t\tif (cmd->fs.m_ext.vlan_etype ||\n\t\t    !((cmd->fs.m_ext.vlan_tci & cpu_to_be16(VLAN_VID_MASK)) ==\n\t\t      0 ||\n\t\t      (cmd->fs.m_ext.vlan_tci & cpu_to_be16(VLAN_VID_MASK)) ==\n\t\t      cpu_to_be16(VLAN_VID_MASK)))\n\t\t\treturn -EINVAL;\n\n\t\tif (cmd->fs.m_ext.vlan_tci) {\n\t\t\tif (be16_to_cpu(cmd->fs.h_ext.vlan_tci) >= VLAN_N_VID)\n\t\t\t\treturn -EINVAL;\n\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx4_en_ethtool_add_mac_rule(struct ethtool_rxnfc *cmd,\n\t\t\t\t\tstruct list_head *rule_list_h,\n\t\t\t\t\tstruct mlx4_spec_list *spec_l2,\n\t\t\t\t\tunsigned char *mac)\n{\n\t__be64 mac_msk = cpu_to_be64(MLX4_MAC_MASK << 16);\n\n\tspec_l2->id = MLX4_NET_TRANS_RULE_ID_ETH;\n\tmemcpy(spec_l2->eth.dst_mac_msk, &mac_msk, ETH_ALEN);\n\tmemcpy(spec_l2->eth.dst_mac, mac, ETH_ALEN);\n\n\tif ((cmd->fs.flow_type & FLOW_EXT) &&\n\t    (cmd->fs.m_ext.vlan_tci & cpu_to_be16(VLAN_VID_MASK))) {\n\t\tspec_l2->eth.vlan_id = cmd->fs.h_ext.vlan_tci;\n\t\tspec_l2->eth.vlan_id_msk = cpu_to_be16(VLAN_VID_MASK);\n\t}\n\n\tlist_add_tail(&spec_l2->list, rule_list_h);\n\n\treturn 0;\n}\n\nstatic int mlx4_en_ethtool_add_mac_rule_by_ipv4(struct mlx4_en_priv *priv,\n\t\t\t\t\t\tstruct ethtool_rxnfc *cmd,\n\t\t\t\t\t\tstruct list_head *rule_list_h,\n\t\t\t\t\t\tstruct mlx4_spec_list *spec_l2,\n\t\t\t\t\t\t__be32 ipv4_dst)\n{\n#ifdef CONFIG_INET\n\tunsigned char mac[ETH_ALEN];\n\n\tif (!ipv4_is_multicast(ipv4_dst)) {\n\t\tif (cmd->fs.flow_type & FLOW_MAC_EXT)\n\t\t\tmemcpy(&mac, cmd->fs.h_ext.h_dest, ETH_ALEN);\n\t\telse\n\t\t\tmemcpy(&mac, priv->dev->dev_addr, ETH_ALEN);\n\t} else {\n\t\tip_eth_mc_map(ipv4_dst, mac);\n\t}\n\n\treturn mlx4_en_ethtool_add_mac_rule(cmd, rule_list_h, spec_l2, &mac[0]);\n#else\n\treturn -EINVAL;\n#endif\n}\n\nstatic int add_ip_rule(struct mlx4_en_priv *priv,\n\t\t       struct ethtool_rxnfc *cmd,\n\t\t       struct list_head *list_h)\n{\n\tint err;\n\tstruct mlx4_spec_list *spec_l2;\n\tstruct mlx4_spec_list *spec_l3;\n\tstruct ethtool_usrip4_spec *l3_mask = &cmd->fs.m_u.usr_ip4_spec;\n\n\tspec_l3 = kzalloc(sizeof(*spec_l3), GFP_KERNEL);\n\tspec_l2 = kzalloc(sizeof(*spec_l2), GFP_KERNEL);\n\tif (!spec_l2 || !spec_l3) {\n\t\terr = -ENOMEM;\n\t\tgoto free_spec;\n\t}\n\n\terr = mlx4_en_ethtool_add_mac_rule_by_ipv4(priv, cmd, list_h, spec_l2,\n\t\t\t\t\t\t   cmd->fs.h_u.\n\t\t\t\t\t\t   usr_ip4_spec.ip4dst);\n\tif (err)\n\t\tgoto free_spec;\n\tspec_l3->id = MLX4_NET_TRANS_RULE_ID_IPV4;\n\tspec_l3->ipv4.src_ip = cmd->fs.h_u.usr_ip4_spec.ip4src;\n\tif (l3_mask->ip4src)\n\t\tspec_l3->ipv4.src_ip_msk = EN_ETHTOOL_WORD_MASK;\n\tspec_l3->ipv4.dst_ip = cmd->fs.h_u.usr_ip4_spec.ip4dst;\n\tif (l3_mask->ip4dst)\n\t\tspec_l3->ipv4.dst_ip_msk = EN_ETHTOOL_WORD_MASK;\n\tlist_add_tail(&spec_l3->list, list_h);\n\n\treturn 0;\n\nfree_spec:\n\tkfree(spec_l2);\n\tkfree(spec_l3);\n\treturn err;\n}\n\nstatic int add_tcp_udp_rule(struct mlx4_en_priv *priv,\n\t\t\t     struct ethtool_rxnfc *cmd,\n\t\t\t     struct list_head *list_h, int proto)\n{\n\tint err;\n\tstruct mlx4_spec_list *spec_l2;\n\tstruct mlx4_spec_list *spec_l3;\n\tstruct mlx4_spec_list *spec_l4;\n\tstruct ethtool_tcpip4_spec *l4_mask = &cmd->fs.m_u.tcp_ip4_spec;\n\n\tspec_l2 = kzalloc(sizeof(*spec_l2), GFP_KERNEL);\n\tspec_l3 = kzalloc(sizeof(*spec_l3), GFP_KERNEL);\n\tspec_l4 = kzalloc(sizeof(*spec_l4), GFP_KERNEL);\n\tif (!spec_l2 || !spec_l3 || !spec_l4) {\n\t\terr = -ENOMEM;\n\t\tgoto free_spec;\n\t}\n\n\tspec_l3->id = MLX4_NET_TRANS_RULE_ID_IPV4;\n\n\tif (proto == TCP_V4_FLOW) {\n\t\terr = mlx4_en_ethtool_add_mac_rule_by_ipv4(priv, cmd, list_h,\n\t\t\t\t\t\t\t   spec_l2,\n\t\t\t\t\t\t\t   cmd->fs.h_u.\n\t\t\t\t\t\t\t   tcp_ip4_spec.ip4dst);\n\t\tif (err)\n\t\t\tgoto free_spec;\n\t\tspec_l4->id = MLX4_NET_TRANS_RULE_ID_TCP;\n\t\tspec_l3->ipv4.src_ip = cmd->fs.h_u.tcp_ip4_spec.ip4src;\n\t\tspec_l3->ipv4.dst_ip = cmd->fs.h_u.tcp_ip4_spec.ip4dst;\n\t\tspec_l4->tcp_udp.src_port = cmd->fs.h_u.tcp_ip4_spec.psrc;\n\t\tspec_l4->tcp_udp.dst_port = cmd->fs.h_u.tcp_ip4_spec.pdst;\n\t} else {\n\t\terr = mlx4_en_ethtool_add_mac_rule_by_ipv4(priv, cmd, list_h,\n\t\t\t\t\t\t\t   spec_l2,\n\t\t\t\t\t\t\t   cmd->fs.h_u.\n\t\t\t\t\t\t\t   udp_ip4_spec.ip4dst);\n\t\tif (err)\n\t\t\tgoto free_spec;\n\t\tspec_l4->id = MLX4_NET_TRANS_RULE_ID_UDP;\n\t\tspec_l3->ipv4.src_ip = cmd->fs.h_u.udp_ip4_spec.ip4src;\n\t\tspec_l3->ipv4.dst_ip = cmd->fs.h_u.udp_ip4_spec.ip4dst;\n\t\tspec_l4->tcp_udp.src_port = cmd->fs.h_u.udp_ip4_spec.psrc;\n\t\tspec_l4->tcp_udp.dst_port = cmd->fs.h_u.udp_ip4_spec.pdst;\n\t}\n\n\tif (l4_mask->ip4src)\n\t\tspec_l3->ipv4.src_ip_msk = EN_ETHTOOL_WORD_MASK;\n\tif (l4_mask->ip4dst)\n\t\tspec_l3->ipv4.dst_ip_msk = EN_ETHTOOL_WORD_MASK;\n\n\tif (l4_mask->psrc)\n\t\tspec_l4->tcp_udp.src_port_msk = EN_ETHTOOL_SHORT_MASK;\n\tif (l4_mask->pdst)\n\t\tspec_l4->tcp_udp.dst_port_msk = EN_ETHTOOL_SHORT_MASK;\n\n\tlist_add_tail(&spec_l3->list, list_h);\n\tlist_add_tail(&spec_l4->list, list_h);\n\n\treturn 0;\n\nfree_spec:\n\tkfree(spec_l2);\n\tkfree(spec_l3);\n\tkfree(spec_l4);\n\treturn err;\n}\n\nstatic int mlx4_en_ethtool_to_net_trans_rule(struct net_device *dev,\n\t\t\t\t\t     struct ethtool_rxnfc *cmd,\n\t\t\t\t\t     struct list_head *rule_list_h)\n{\n\tint err;\n\tstruct ethhdr *eth_spec;\n\tstruct mlx4_spec_list *spec_l2;\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\terr = mlx4_en_validate_flow(dev, cmd);\n\tif (err)\n\t\treturn err;\n\n\tswitch (cmd->fs.flow_type & ~(FLOW_EXT | FLOW_MAC_EXT)) {\n\tcase ETHER_FLOW:\n\t\tspec_l2 = kzalloc(sizeof(*spec_l2), GFP_KERNEL);\n\t\tif (!spec_l2)\n\t\t\treturn -ENOMEM;\n\n\t\teth_spec = &cmd->fs.h_u.ether_spec;\n\t\tmlx4_en_ethtool_add_mac_rule(cmd, rule_list_h, spec_l2,\n\t\t\t\t\t     &eth_spec->h_dest[0]);\n\t\tspec_l2->eth.ether_type = eth_spec->h_proto;\n\t\tif (eth_spec->h_proto)\n\t\t\tspec_l2->eth.ether_type_enable = 1;\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\terr = add_ip_rule(priv, cmd, rule_list_h);\n\t\tbreak;\n\tcase TCP_V4_FLOW:\n\t\terr = add_tcp_udp_rule(priv, cmd, rule_list_h, TCP_V4_FLOW);\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\terr = add_tcp_udp_rule(priv, cmd, rule_list_h, UDP_V4_FLOW);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int mlx4_en_flow_replace(struct net_device *dev,\n\t\t\t\tstruct ethtool_rxnfc *cmd)\n{\n\tint err;\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct ethtool_flow_id *loc_rule;\n\tstruct mlx4_spec_list *spec, *tmp_spec;\n\tu32 qpn;\n\tu64 reg_id;\n\n\tstruct mlx4_net_trans_rule rule = {\n\t\t.queue_mode = MLX4_NET_TRANS_Q_FIFO,\n\t\t.exclusive = 0,\n\t\t.allow_loopback = 1,\n\t\t.promisc_mode = MLX4_FS_REGULAR,\n\t};\n\n\trule.port = priv->port;\n\trule.priority = MLX4_DOMAIN_ETHTOOL | cmd->fs.location;\n\tINIT_LIST_HEAD(&rule.list);\n\n\t \n\tif (cmd->fs.ring_cookie == RX_CLS_FLOW_DISC)\n\t\tqpn = priv->drop_qp.qpn;\n\telse if (cmd->fs.ring_cookie & EN_ETHTOOL_QP_ATTACH) {\n\t\tqpn = cmd->fs.ring_cookie & (EN_ETHTOOL_QP_ATTACH - 1);\n\t} else {\n\t\tif (cmd->fs.ring_cookie >= priv->rx_ring_num) {\n\t\t\ten_warn(priv, \"rxnfc: RX ring (%llu) doesn't exist\\n\",\n\t\t\t\tcmd->fs.ring_cookie);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tqpn = priv->rss_map.qps[cmd->fs.ring_cookie].qpn;\n\t\tif (!qpn) {\n\t\t\ten_warn(priv, \"rxnfc: RX ring (%llu) is inactive\\n\",\n\t\t\t\tcmd->fs.ring_cookie);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\trule.qpn = qpn;\n\terr = mlx4_en_ethtool_to_net_trans_rule(dev, cmd, &rule.list);\n\tif (err)\n\t\tgoto out_free_list;\n\n\tloc_rule = &priv->ethtool_rules[cmd->fs.location];\n\tif (loc_rule->id) {\n\t\terr = mlx4_flow_detach(priv->mdev->dev, loc_rule->id);\n\t\tif (err) {\n\t\t\ten_err(priv, \"Fail to detach network rule at location %d. registration id = %llx\\n\",\n\t\t\t       cmd->fs.location, loc_rule->id);\n\t\t\tgoto out_free_list;\n\t\t}\n\t\tloc_rule->id = 0;\n\t\tmemset(&loc_rule->flow_spec, 0,\n\t\t       sizeof(struct ethtool_rx_flow_spec));\n\t\tlist_del(&loc_rule->list);\n\t}\n\terr = mlx4_flow_attach(priv->mdev->dev, &rule, &reg_id);\n\tif (err) {\n\t\ten_err(priv, \"Fail to attach network rule at location %d\\n\",\n\t\t       cmd->fs.location);\n\t\tgoto out_free_list;\n\t}\n\tloc_rule->id = reg_id;\n\tmemcpy(&loc_rule->flow_spec, &cmd->fs,\n\t       sizeof(struct ethtool_rx_flow_spec));\n\tlist_add_tail(&loc_rule->list, &priv->ethtool_list);\n\nout_free_list:\n\tlist_for_each_entry_safe(spec, tmp_spec, &rule.list, list) {\n\t\tlist_del(&spec->list);\n\t\tkfree(spec);\n\t}\n\treturn err;\n}\n\nstatic int mlx4_en_flow_detach(struct net_device *dev,\n\t\t\t       struct ethtool_rxnfc *cmd)\n{\n\tint err = 0;\n\tstruct ethtool_flow_id *rule;\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\tif (cmd->fs.location >= MAX_NUM_OF_FS_RULES)\n\t\treturn -EINVAL;\n\n\trule = &priv->ethtool_rules[cmd->fs.location];\n\tif (!rule->id) {\n\t\terr =  -ENOENT;\n\t\tgoto out;\n\t}\n\n\terr = mlx4_flow_detach(priv->mdev->dev, rule->id);\n\tif (err) {\n\t\ten_err(priv, \"Fail to detach network rule at location %d. registration id = 0x%llx\\n\",\n\t\t       cmd->fs.location, rule->id);\n\t\tgoto out;\n\t}\n\trule->id = 0;\n\tmemset(&rule->flow_spec, 0, sizeof(struct ethtool_rx_flow_spec));\n\tlist_del(&rule->list);\nout:\n\treturn err;\n\n}\n\nstatic int mlx4_en_get_flow(struct net_device *dev, struct ethtool_rxnfc *cmd,\n\t\t\t    int loc)\n{\n\tint err = 0;\n\tstruct ethtool_flow_id *rule;\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\tif (loc < 0 || loc >= MAX_NUM_OF_FS_RULES)\n\t\treturn -EINVAL;\n\n\trule = &priv->ethtool_rules[loc];\n\tif (rule->id)\n\t\tmemcpy(&cmd->fs, &rule->flow_spec,\n\t\t       sizeof(struct ethtool_rx_flow_spec));\n\telse\n\t\terr = -ENOENT;\n\n\treturn err;\n}\n\nstatic int mlx4_en_get_num_flows(struct mlx4_en_priv *priv)\n{\n\n\tint i, res = 0;\n\tfor (i = 0; i < MAX_NUM_OF_FS_RULES; i++) {\n\t\tif (priv->ethtool_rules[i].id)\n\t\t\tres++;\n\t}\n\treturn res;\n\n}\n\nstatic int mlx4_en_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\n\t\t\t     u32 *rule_locs)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint err = 0;\n\tint i = 0, priority = 0;\n\n\tif ((cmd->cmd == ETHTOOL_GRXCLSRLCNT ||\n\t     cmd->cmd == ETHTOOL_GRXCLSRULE ||\n\t     cmd->cmd == ETHTOOL_GRXCLSRLALL) &&\n\t    (mdev->dev->caps.steering_mode !=\n\t     MLX4_STEERING_MODE_DEVICE_MANAGED || !priv->port_up))\n\t\treturn -EINVAL;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = priv->rx_ring_num;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tcmd->rule_cnt = mlx4_en_get_num_flows(priv);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\terr = mlx4_en_get_flow(dev, cmd, cmd->fs.location);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tcmd->data = MAX_NUM_OF_FS_RULES;\n\t\twhile ((!err || err == -ENOENT) && priority < cmd->rule_cnt) {\n\t\t\terr = mlx4_en_get_flow(dev, cmd, i);\n\t\t\tif (!err)\n\t\t\t\trule_locs[priority++] = i;\n\t\t\ti++;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int mlx4_en_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tint err = 0;\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\n\tif (mdev->dev->caps.steering_mode !=\n\t    MLX4_STEERING_MODE_DEVICE_MANAGED || !priv->port_up)\n\t\treturn -EINVAL;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\terr = mlx4_en_flow_replace(dev, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\terr = mlx4_en_flow_detach(dev, cmd);\n\t\tbreak;\n\tdefault:\n\t\ten_warn(priv, \"Unsupported ethtool command. (%d)\\n\", cmd->cmd);\n\t\treturn -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic int mlx4_en_get_max_num_rx_rings(struct net_device *dev)\n{\n\treturn min_t(int, num_online_cpus(), MAX_RX_RINGS);\n}\n\nstatic void mlx4_en_get_channels(struct net_device *dev,\n\t\t\t\t struct ethtool_channels *channel)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\tchannel->max_rx = mlx4_en_get_max_num_rx_rings(dev);\n\tchannel->max_tx = priv->mdev->profile.max_num_tx_rings_p_up;\n\n\tchannel->rx_count = priv->rx_ring_num;\n\tchannel->tx_count = priv->tx_ring_num[TX] /\n\t\t\t    priv->prof->num_up;\n}\n\nstatic int mlx4_en_set_channels(struct net_device *dev,\n\t\t\t\tstruct ethtool_channels *channel)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_en_port_profile new_prof;\n\tstruct mlx4_en_priv *tmp;\n\tint total_tx_count;\n\tint port_up = 0;\n\tint xdp_count;\n\tint err = 0;\n\tu8 up;\n\n\tif (!channel->tx_count || !channel->rx_count)\n\t\treturn -EINVAL;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&mdev->state_lock);\n\txdp_count = priv->tx_ring_num[TX_XDP] ? channel->rx_count : 0;\n\ttotal_tx_count = channel->tx_count * priv->prof->num_up + xdp_count;\n\tif (total_tx_count > MAX_TX_RINGS) {\n\t\terr = -EINVAL;\n\t\ten_err(priv,\n\t\t       \"Total number of TX and XDP rings (%d) exceeds the maximum supported (%d)\\n\",\n\t\t       total_tx_count, MAX_TX_RINGS);\n\t\tgoto out;\n\t}\n\n\tmemcpy(&new_prof, priv->prof, sizeof(struct mlx4_en_port_profile));\n\tnew_prof.num_tx_rings_p_up = channel->tx_count;\n\tnew_prof.tx_ring_num[TX] = channel->tx_count * priv->prof->num_up;\n\tnew_prof.tx_ring_num[TX_XDP] = xdp_count;\n\tnew_prof.rx_ring_num = channel->rx_count;\n\n\terr = mlx4_en_try_alloc_resources(priv, tmp, &new_prof, true);\n\tif (err)\n\t\tgoto out;\n\n\tif (priv->port_up) {\n\t\tport_up = 1;\n\t\tmlx4_en_stop_port(dev, 1);\n\t}\n\n\tmlx4_en_safe_replace_resources(priv, tmp);\n\n\tnetif_set_real_num_rx_queues(dev, priv->rx_ring_num);\n\n\tup = (priv->prof->num_up == MLX4_EN_NUM_UP_LOW) ?\n\t\t\t\t    0 : priv->prof->num_up;\n\tmlx4_en_setup_tc(dev, up);\n\n\ten_warn(priv, \"Using %d TX rings\\n\", priv->tx_ring_num[TX]);\n\ten_warn(priv, \"Using %d RX rings\\n\", priv->rx_ring_num);\n\n\tif (port_up) {\n\t\terr = mlx4_en_start_port(dev);\n\t\tif (err)\n\t\t\ten_err(priv, \"Failed starting port\\n\");\n\t}\n\n\terr = mlx4_en_moderation_update(priv);\nout:\n\tmutex_unlock(&mdev->state_lock);\n\tkfree(tmp);\n\treturn err;\n}\n\nstatic int mlx4_en_get_ts_info(struct net_device *dev,\n\t\t\t       struct ethtool_ts_info *info)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint ret;\n\n\tret = ethtool_op_get_ts_info(dev, info);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_TS) {\n\t\tinfo->so_timestamping |=\n\t\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\t\tinfo->tx_types =\n\t\t\t(1 << HWTSTAMP_TX_OFF) |\n\t\t\t(1 << HWTSTAMP_TX_ON);\n\n\t\tinfo->rx_filters =\n\t\t\t(1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t(1 << HWTSTAMP_FILTER_ALL);\n\n\t\tif (mdev->ptp_clock)\n\t\t\tinfo->phc_index = ptp_clock_index(mdev->ptp_clock);\n\t}\n\n\treturn ret;\n}\n\nstatic int mlx4_en_set_priv_flags(struct net_device *dev, u32 flags)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tbool bf_enabled_new = !!(flags & MLX4_EN_PRIV_FLAGS_BLUEFLAME);\n\tbool bf_enabled_old = !!(priv->pflags & MLX4_EN_PRIV_FLAGS_BLUEFLAME);\n\tbool phv_enabled_new = !!(flags & MLX4_EN_PRIV_FLAGS_PHV);\n\tbool phv_enabled_old = !!(priv->pflags & MLX4_EN_PRIV_FLAGS_PHV);\n\tint i;\n\tint ret = 0;\n\n\tif (bf_enabled_new != bf_enabled_old) {\n\t\tint t;\n\n\t\tif (bf_enabled_new) {\n\t\t\tbool bf_supported = true;\n\n\t\t\tfor (t = 0; t < MLX4_EN_NUM_TX_TYPES; t++)\n\t\t\t\tfor (i = 0; i < priv->tx_ring_num[t]; i++)\n\t\t\t\t\tbf_supported &=\n\t\t\t\t\t\tpriv->tx_ring[t][i]->bf_alloced;\n\n\t\t\tif (!bf_supported) {\n\t\t\t\ten_err(priv, \"BlueFlame is not supported\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tpriv->pflags |= MLX4_EN_PRIV_FLAGS_BLUEFLAME;\n\t\t} else {\n\t\t\tpriv->pflags &= ~MLX4_EN_PRIV_FLAGS_BLUEFLAME;\n\t\t}\n\n\t\tfor (t = 0; t < MLX4_EN_NUM_TX_TYPES; t++)\n\t\t\tfor (i = 0; i < priv->tx_ring_num[t]; i++)\n\t\t\t\tpriv->tx_ring[t][i]->bf_enabled =\n\t\t\t\t\tbf_enabled_new;\n\n\t\ten_info(priv, \"BlueFlame %s\\n\",\n\t\t\tbf_enabled_new ?  \"Enabled\" : \"Disabled\");\n\t}\n\n\tif (phv_enabled_new != phv_enabled_old) {\n\t\tret = set_phv_bit(mdev->dev, priv->port, (int)phv_enabled_new);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\telse if (phv_enabled_new)\n\t\t\tpriv->pflags |= MLX4_EN_PRIV_FLAGS_PHV;\n\t\telse\n\t\t\tpriv->pflags &= ~MLX4_EN_PRIV_FLAGS_PHV;\n\t\ten_info(priv, \"PHV bit %s\\n\",\n\t\t\tphv_enabled_new ?  \"Enabled\" : \"Disabled\");\n\t}\n\treturn 0;\n}\n\nstatic u32 mlx4_en_get_priv_flags(struct net_device *dev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\treturn priv->pflags;\n}\n\nstatic int mlx4_en_get_tunable(struct net_device *dev,\n\t\t\t       const struct ethtool_tunable *tuna,\n\t\t\t       void *data)\n{\n\tconst struct mlx4_en_priv *priv = netdev_priv(dev);\n\tint ret = 0;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_TX_COPYBREAK:\n\t\t*(u32 *)data = priv->prof->inline_thold;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int mlx4_en_set_tunable(struct net_device *dev,\n\t\t\t       const struct ethtool_tunable *tuna,\n\t\t\t       const void *data)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tint val, ret = 0;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_TX_COPYBREAK:\n\t\tval = *(u32 *)data;\n\t\tif (val < MIN_PKT_LEN || val > MAX_INLINE)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tpriv->prof->inline_thold = val;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int mlx4_en_get_module_info(struct net_device *dev,\n\t\t\t\t   struct ethtool_modinfo *modinfo)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint ret;\n\tu8 data[4];\n\n\t \n\tret = mlx4_get_module_info(mdev->dev, priv->port,\n\t\t\t\t   0 , 2 , data);\n\tif (ret < 2)\n\t\treturn -EIO;\n\n\tswitch (data[0]  ) {\n\tcase MLX4_MODULE_ID_QSFP:\n\t\tmodinfo->type = ETH_MODULE_SFF_8436;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_LEN;\n\t\tbreak;\n\tcase MLX4_MODULE_ID_QSFP_PLUS:\n\t\tif (data[1] >= 0x3) {  \n\t\t\tmodinfo->type = ETH_MODULE_SFF_8636;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8636_LEN;\n\t\t} else {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8436;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_LEN;\n\t\t}\n\t\tbreak;\n\tcase MLX4_MODULE_ID_QSFP28:\n\t\tmodinfo->type = ETH_MODULE_SFF_8636;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8636_LEN;\n\t\tbreak;\n\tcase MLX4_MODULE_ID_SFP:\n\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx4_en_get_module_eeprom(struct net_device *dev,\n\t\t\t\t     struct ethtool_eeprom *ee,\n\t\t\t\t     u8 *data)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint offset = ee->offset;\n\tint i = 0, ret;\n\n\tif (ee->len == 0)\n\t\treturn -EINVAL;\n\n\tmemset(data, 0, ee->len);\n\n\twhile (i < ee->len) {\n\t\ten_dbg(DRV, priv,\n\t\t       \"mlx4_get_module_info i(%d) offset(%d) len(%d)\\n\",\n\t\t       i, offset, ee->len - i);\n\n\t\tret = mlx4_get_module_info(mdev->dev, priv->port,\n\t\t\t\t\t   offset, ee->len - i, data + i);\n\n\t\tif (!ret)  \n\t\t\treturn 0;\n\n\t\tif (ret < 0) {\n\t\t\ten_err(priv,\n\t\t\t       \"mlx4_get_module_info i(%d) offset(%d) bytes_to_read(%d) - FAILED (0x%x)\\n\",\n\t\t\t       i, offset, ee->len - i, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\ti += ret;\n\t\toffset += ret;\n\t}\n\treturn 0;\n}\n\nstatic int mlx4_en_set_phys_id(struct net_device *dev,\n\t\t\t       enum ethtool_phys_id_state state)\n{\n\tint err;\n\tu16 beacon_duration;\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\n\tif (!(mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_PORT_BEACON))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tbeacon_duration = PORT_BEACON_MAX_LIMIT;\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tbeacon_duration = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = mlx4_SET_PORT_BEACON(mdev->dev, priv->port, beacon_duration);\n\treturn err;\n}\n\nconst struct ethtool_ops mlx4_en_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_TX_MAX_FRAMES_IRQ |\n\t\t\t\t     ETHTOOL_COALESCE_PKT_RATE_RX_USECS,\n\t.get_drvinfo = mlx4_en_get_drvinfo,\n\t.get_link_ksettings = mlx4_en_get_link_ksettings,\n\t.set_link_ksettings = mlx4_en_set_link_ksettings,\n\t.get_link = ethtool_op_get_link,\n\t.get_strings = mlx4_en_get_strings,\n\t.get_sset_count = mlx4_en_get_sset_count,\n\t.get_ethtool_stats = mlx4_en_get_ethtool_stats,\n\t.self_test = mlx4_en_self_test,\n\t.set_phys_id = mlx4_en_set_phys_id,\n\t.get_wol = mlx4_en_get_wol,\n\t.set_wol = mlx4_en_set_wol,\n\t.get_msglevel = mlx4_en_get_msglevel,\n\t.set_msglevel = mlx4_en_set_msglevel,\n\t.get_coalesce = mlx4_en_get_coalesce,\n\t.set_coalesce = mlx4_en_set_coalesce,\n\t.get_pause_stats = mlx4_en_get_pause_stats,\n\t.get_pauseparam = mlx4_en_get_pauseparam,\n\t.set_pauseparam = mlx4_en_set_pauseparam,\n\t.get_ringparam = mlx4_en_get_ringparam,\n\t.set_ringparam = mlx4_en_set_ringparam,\n\t.get_rxnfc = mlx4_en_get_rxnfc,\n\t.set_rxnfc = mlx4_en_set_rxnfc,\n\t.get_rxfh_indir_size = mlx4_en_get_rxfh_indir_size,\n\t.get_rxfh_key_size = mlx4_en_get_rxfh_key_size,\n\t.get_rxfh = mlx4_en_get_rxfh,\n\t.set_rxfh = mlx4_en_set_rxfh,\n\t.get_channels = mlx4_en_get_channels,\n\t.set_channels = mlx4_en_set_channels,\n\t.get_ts_info = mlx4_en_get_ts_info,\n\t.set_priv_flags = mlx4_en_set_priv_flags,\n\t.get_priv_flags = mlx4_en_get_priv_flags,\n\t.get_tunable\t\t= mlx4_en_get_tunable,\n\t.set_tunable\t\t= mlx4_en_set_tunable,\n\t.get_module_info = mlx4_en_get_module_info,\n\t.get_module_eeprom = mlx4_en_get_module_eeprom\n};\n\n\n\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}