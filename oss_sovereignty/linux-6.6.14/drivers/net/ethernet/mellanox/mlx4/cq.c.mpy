{
  "module_name": "cq.c",
  "hash_id": "e891d5f637e3662ba80aefe737084316d58b39c53bdff7cf8bbaec834e691e26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/cq.c",
  "human_readable_source": " \n\n#include <linux/hardirq.h>\n#include <linux/export.h>\n\n#include <linux/mlx4/cmd.h>\n#include <linux/mlx4/cq.h>\n\n#include \"mlx4.h\"\n#include \"icm.h\"\n\n#define MLX4_CQ_STATUS_OK\t\t( 0 << 28)\n#define MLX4_CQ_STATUS_OVERFLOW\t\t( 9 << 28)\n#define MLX4_CQ_STATUS_WRITE_FAIL\t(10 << 28)\n#define MLX4_CQ_FLAG_CC\t\t\t( 1 << 18)\n#define MLX4_CQ_FLAG_OI\t\t\t( 1 << 17)\n#define MLX4_CQ_STATE_ARMED\t\t( 9 <<  8)\n#define MLX4_CQ_STATE_ARMED_SOL\t\t( 6 <<  8)\n#define MLX4_EQ_STATE_FIRED\t\t(10 <<  8)\n\n#define TASKLET_MAX_TIME 2\n#define TASKLET_MAX_TIME_JIFFIES msecs_to_jiffies(TASKLET_MAX_TIME)\n\nvoid mlx4_cq_tasklet_cb(struct tasklet_struct *t)\n{\n\tunsigned long flags;\n\tunsigned long end = jiffies + TASKLET_MAX_TIME_JIFFIES;\n\tstruct mlx4_eq_tasklet *ctx = from_tasklet(ctx, t, task);\n\tstruct mlx4_cq *mcq, *temp;\n\n\tspin_lock_irqsave(&ctx->lock, flags);\n\tlist_splice_tail_init(&ctx->list, &ctx->process_list);\n\tspin_unlock_irqrestore(&ctx->lock, flags);\n\n\tlist_for_each_entry_safe(mcq, temp, &ctx->process_list, tasklet_ctx.list) {\n\t\tlist_del_init(&mcq->tasklet_ctx.list);\n\t\tmcq->tasklet_ctx.comp(mcq);\n\t\tif (refcount_dec_and_test(&mcq->refcount))\n\t\t\tcomplete(&mcq->free);\n\t\tif (time_after(jiffies, end))\n\t\t\tbreak;\n\t}\n\n\tif (!list_empty(&ctx->process_list))\n\t\ttasklet_schedule(&ctx->task);\n}\n\nstatic void mlx4_add_cq_to_tasklet(struct mlx4_cq *cq)\n{\n\tstruct mlx4_eq_tasklet *tasklet_ctx = cq->tasklet_ctx.priv;\n\tunsigned long flags;\n\tbool kick;\n\n\tspin_lock_irqsave(&tasklet_ctx->lock, flags);\n\t \n\tif (list_empty_careful(&cq->tasklet_ctx.list)) {\n\t\trefcount_inc(&cq->refcount);\n\t\tkick = list_empty(&tasklet_ctx->list);\n\t\tlist_add_tail(&cq->tasklet_ctx.list, &tasklet_ctx->list);\n\t\tif (kick)\n\t\t\ttasklet_schedule(&tasklet_ctx->task);\n\t}\n\tspin_unlock_irqrestore(&tasklet_ctx->lock, flags);\n}\n\nvoid mlx4_cq_completion(struct mlx4_dev *dev, u32 cqn)\n{\n\tstruct mlx4_cq *cq;\n\n\trcu_read_lock();\n\tcq = radix_tree_lookup(&mlx4_priv(dev)->cq_table.tree,\n\t\t\t       cqn & (dev->caps.num_cqs - 1));\n\trcu_read_unlock();\n\n\tif (!cq) {\n\t\tmlx4_dbg(dev, \"Completion event for bogus CQ %08x\\n\", cqn);\n\t\treturn;\n\t}\n\n\t \n\t++cq->arm_sn;\n\n\tcq->comp(cq);\n}\n\nvoid mlx4_cq_event(struct mlx4_dev *dev, u32 cqn, int event_type)\n{\n\tstruct mlx4_cq_table *cq_table = &mlx4_priv(dev)->cq_table;\n\tstruct mlx4_cq *cq;\n\n\trcu_read_lock();\n\tcq = radix_tree_lookup(&cq_table->tree, cqn & (dev->caps.num_cqs - 1));\n\trcu_read_unlock();\n\n\tif (!cq) {\n\t\tmlx4_dbg(dev, \"Async event for bogus CQ %08x\\n\", cqn);\n\t\treturn;\n\t}\n\n\t \n\tcq->event(cq, event_type);\n}\n\nstatic int mlx4_SW2HW_CQ(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,\n\t\t\t int cq_num, u8 opmod)\n{\n\treturn mlx4_cmd(dev, mailbox->dma, cq_num, opmod,\n\t\t\tMLX4_CMD_SW2HW_CQ, MLX4_CMD_TIME_CLASS_A,\n\t\t\tMLX4_CMD_WRAPPED);\n}\n\nstatic int mlx4_MODIFY_CQ(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,\n\t\t\t int cq_num, u32 opmod)\n{\n\treturn mlx4_cmd(dev, mailbox->dma, cq_num, opmod, MLX4_CMD_MODIFY_CQ,\n\t\t\tMLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n}\n\nstatic int mlx4_HW2SW_CQ(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,\n\t\t\t int cq_num)\n{\n\treturn mlx4_cmd_box(dev, 0, mailbox ? mailbox->dma : 0,\n\t\t\t    cq_num, mailbox ? 0 : 1, MLX4_CMD_HW2SW_CQ,\n\t\t\t    MLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n}\n\nint mlx4_cq_modify(struct mlx4_dev *dev, struct mlx4_cq *cq,\n\t\t   u16 count, u16 period)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tstruct mlx4_cq_context *cq_context;\n\tint err;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tcq_context = mailbox->buf;\n\tcq_context->cq_max_count = cpu_to_be16(count);\n\tcq_context->cq_period    = cpu_to_be16(period);\n\n\terr = mlx4_MODIFY_CQ(dev, mailbox, cq->cqn, 1);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx4_cq_modify);\n\nint mlx4_cq_resize(struct mlx4_dev *dev, struct mlx4_cq *cq,\n\t\t   int entries, struct mlx4_mtt *mtt)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tstruct mlx4_cq_context *cq_context;\n\tu64 mtt_addr;\n\tint err;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tcq_context = mailbox->buf;\n\tcq_context->logsize_usrpage = cpu_to_be32(ilog2(entries) << 24);\n\tcq_context->log_page_size   = mtt->page_shift - 12;\n\tmtt_addr = mlx4_mtt_addr(dev, mtt);\n\tcq_context->mtt_base_addr_h = mtt_addr >> 32;\n\tcq_context->mtt_base_addr_l = cpu_to_be32(mtt_addr & 0xffffffff);\n\n\terr = mlx4_MODIFY_CQ(dev, mailbox, cq->cqn, 0);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx4_cq_resize);\n\nint __mlx4_cq_alloc_icm(struct mlx4_dev *dev, int *cqn)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_cq_table *cq_table = &priv->cq_table;\n\tint err;\n\n\t*cqn = mlx4_bitmap_alloc(&cq_table->bitmap);\n\tif (*cqn == -1)\n\t\treturn -ENOMEM;\n\n\terr = mlx4_table_get(dev, &cq_table->table, *cqn);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = mlx4_table_get(dev, &cq_table->cmpt_table, *cqn);\n\tif (err)\n\t\tgoto err_put;\n\treturn 0;\n\nerr_put:\n\tmlx4_table_put(dev, &cq_table->table, *cqn);\n\nerr_out:\n\tmlx4_bitmap_free(&cq_table->bitmap, *cqn, MLX4_NO_RR);\n\treturn err;\n}\n\nstatic int mlx4_cq_alloc_icm(struct mlx4_dev *dev, int *cqn, u8 usage)\n{\n\tu32 in_modifier = RES_CQ | (((u32)usage & 3) << 30);\n\tu64 out_param;\n\tint err;\n\n\tif (mlx4_is_mfunc(dev)) {\n\t\terr = mlx4_cmd_imm(dev, 0, &out_param, in_modifier,\n\t\t\t\t   RES_OP_RESERVE_AND_MAP, MLX4_CMD_ALLOC_RES,\n\t\t\t\t   MLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n\t\tif (err)\n\t\t\treturn err;\n\t\telse {\n\t\t\t*cqn = get_param_l(&out_param);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn __mlx4_cq_alloc_icm(dev, cqn);\n}\n\nvoid __mlx4_cq_free_icm(struct mlx4_dev *dev, int cqn)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_cq_table *cq_table = &priv->cq_table;\n\n\tmlx4_table_put(dev, &cq_table->cmpt_table, cqn);\n\tmlx4_table_put(dev, &cq_table->table, cqn);\n\tmlx4_bitmap_free(&cq_table->bitmap, cqn, MLX4_NO_RR);\n}\n\nstatic void mlx4_cq_free_icm(struct mlx4_dev *dev, int cqn)\n{\n\tu64 in_param = 0;\n\tint err;\n\n\tif (mlx4_is_mfunc(dev)) {\n\t\tset_param_l(&in_param, cqn);\n\t\terr = mlx4_cmd(dev, in_param, RES_CQ, RES_OP_RESERVE_AND_MAP,\n\t\t\t       MLX4_CMD_FREE_RES,\n\t\t\t       MLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n\t\tif (err)\n\t\t\tmlx4_warn(dev, \"Failed freeing cq:%d\\n\", cqn);\n\t} else\n\t\t__mlx4_cq_free_icm(dev, cqn);\n}\n\nstatic int mlx4_init_user_cqes(void *buf, int entries, int cqe_size)\n{\n\tint entries_per_copy = PAGE_SIZE / cqe_size;\n\tvoid *init_ents;\n\tint err = 0;\n\tint i;\n\n\tinit_ents = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!init_ents)\n\t\treturn -ENOMEM;\n\n\t \n\tmemset(init_ents, 0xcc, PAGE_SIZE);\n\n\tif (entries_per_copy < entries) {\n\t\tfor (i = 0; i < entries / entries_per_copy; i++) {\n\t\t\terr = copy_to_user((void __user *)buf, init_ents, PAGE_SIZE) ?\n\t\t\t\t-EFAULT : 0;\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tbuf += PAGE_SIZE;\n\t\t}\n\t} else {\n\t\terr = copy_to_user((void __user *)buf, init_ents,\n\t\t\t\t   array_size(entries, cqe_size)) ?\n\t\t\t-EFAULT : 0;\n\t}\n\nout:\n\tkfree(init_ents);\n\n\treturn err;\n}\n\nstatic void mlx4_init_kernel_cqes(struct mlx4_buf *buf,\n\t\t\t\t  int entries,\n\t\t\t\t  int cqe_size)\n{\n\tint i;\n\n\tif (buf->nbufs == 1)\n\t\tmemset(buf->direct.buf, 0xcc, entries * cqe_size);\n\telse\n\t\tfor (i = 0; i < buf->npages; i++)\n\t\t\tmemset(buf->page_list[i].buf, 0xcc,\n\t\t\t       1UL << buf->page_shift);\n}\n\nint mlx4_cq_alloc(struct mlx4_dev *dev, int nent,\n\t\t  struct mlx4_mtt *mtt, struct mlx4_uar *uar, u64 db_rec,\n\t\t  struct mlx4_cq *cq, unsigned vector, int collapsed,\n\t\t  int timestamp_en, void *buf_addr, bool user_cq)\n{\n\tbool sw_cq_init = dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_SW_CQ_INIT;\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_cq_table *cq_table = &priv->cq_table;\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tstruct mlx4_cq_context *cq_context;\n\tu64 mtt_addr;\n\tint err;\n\n\tif (vector >= dev->caps.num_comp_vectors)\n\t\treturn -EINVAL;\n\n\tcq->vector = vector;\n\n\terr = mlx4_cq_alloc_icm(dev, &cq->cqn, cq->usage);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock(&cq_table->lock);\n\terr = radix_tree_insert(&cq_table->tree, cq->cqn, cq);\n\tspin_unlock(&cq_table->lock);\n\tif (err)\n\t\tgoto err_icm;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox)) {\n\t\terr = PTR_ERR(mailbox);\n\t\tgoto err_radix;\n\t}\n\n\tcq_context = mailbox->buf;\n\tcq_context->flags\t    = cpu_to_be32(!!collapsed << 18);\n\tif (timestamp_en)\n\t\tcq_context->flags  |= cpu_to_be32(1 << 19);\n\n\tcq_context->logsize_usrpage =\n\t\tcpu_to_be32((ilog2(nent) << 24) |\n\t\t\t    mlx4_to_hw_uar_index(dev, uar->index));\n\tcq_context->comp_eqn\t    = priv->eq_table.eq[MLX4_CQ_TO_EQ_VECTOR(vector)].eqn;\n\tcq_context->log_page_size   = mtt->page_shift - MLX4_ICM_PAGE_SHIFT;\n\n\tmtt_addr = mlx4_mtt_addr(dev, mtt);\n\tcq_context->mtt_base_addr_h = mtt_addr >> 32;\n\tcq_context->mtt_base_addr_l = cpu_to_be32(mtt_addr & 0xffffffff);\n\tcq_context->db_rec_addr     = cpu_to_be64(db_rec);\n\n\tif (sw_cq_init) {\n\t\tif (user_cq) {\n\t\t\terr = mlx4_init_user_cqes(buf_addr, nent,\n\t\t\t\t\t\t  dev->caps.cqe_size);\n\t\t\tif (err)\n\t\t\t\tsw_cq_init = false;\n\t\t} else {\n\t\t\tmlx4_init_kernel_cqes(buf_addr, nent,\n\t\t\t\t\t      dev->caps.cqe_size);\n\t\t}\n\t}\n\n\terr = mlx4_SW2HW_CQ(dev, mailbox, cq->cqn, sw_cq_init);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\tif (err)\n\t\tgoto err_radix;\n\n\tcq->cons_index = 0;\n\tcq->arm_sn     = 1;\n\tcq->uar        = uar;\n\trefcount_set(&cq->refcount, 1);\n\tinit_completion(&cq->free);\n\tcq->comp = mlx4_add_cq_to_tasklet;\n\tcq->tasklet_ctx.priv =\n\t\t&priv->eq_table.eq[MLX4_CQ_TO_EQ_VECTOR(vector)].tasklet_ctx;\n\tINIT_LIST_HEAD(&cq->tasklet_ctx.list);\n\n\n\tcq->irq = priv->eq_table.eq[MLX4_CQ_TO_EQ_VECTOR(vector)].irq;\n\treturn 0;\n\nerr_radix:\n\tspin_lock(&cq_table->lock);\n\tradix_tree_delete(&cq_table->tree, cq->cqn);\n\tspin_unlock(&cq_table->lock);\n\nerr_icm:\n\tmlx4_cq_free_icm(dev, cq->cqn);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx4_cq_alloc);\n\nvoid mlx4_cq_free(struct mlx4_dev *dev, struct mlx4_cq *cq)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_cq_table *cq_table = &priv->cq_table;\n\tint err;\n\n\terr = mlx4_HW2SW_CQ(dev, NULL, cq->cqn);\n\tif (err)\n\t\tmlx4_warn(dev, \"HW2SW_CQ failed (%d) for CQN %06x\\n\", err, cq->cqn);\n\n\tspin_lock(&cq_table->lock);\n\tradix_tree_delete(&cq_table->tree, cq->cqn);\n\tspin_unlock(&cq_table->lock);\n\n\tsynchronize_irq(priv->eq_table.eq[MLX4_CQ_TO_EQ_VECTOR(cq->vector)].irq);\n\tif (priv->eq_table.eq[MLX4_CQ_TO_EQ_VECTOR(cq->vector)].irq !=\n\t    priv->eq_table.eq[MLX4_EQ_ASYNC].irq)\n\t\tsynchronize_irq(priv->eq_table.eq[MLX4_EQ_ASYNC].irq);\n\n\tif (refcount_dec_and_test(&cq->refcount))\n\t\tcomplete(&cq->free);\n\twait_for_completion(&cq->free);\n\n\tmlx4_cq_free_icm(dev, cq->cqn);\n}\nEXPORT_SYMBOL_GPL(mlx4_cq_free);\n\nint mlx4_init_cq_table(struct mlx4_dev *dev)\n{\n\tstruct mlx4_cq_table *cq_table = &mlx4_priv(dev)->cq_table;\n\n\tspin_lock_init(&cq_table->lock);\n\tINIT_RADIX_TREE(&cq_table->tree, GFP_ATOMIC);\n\tif (mlx4_is_slave(dev))\n\t\treturn 0;\n\n\treturn mlx4_bitmap_init(&cq_table->bitmap, dev->caps.num_cqs,\n\t\t\t\tdev->caps.num_cqs - 1, dev->caps.reserved_cqs, 0);\n}\n\nvoid mlx4_cleanup_cq_table(struct mlx4_dev *dev)\n{\n\tif (mlx4_is_slave(dev))\n\t\treturn;\n\t \n\tmlx4_bitmap_cleanup(&mlx4_priv(dev)->cq_table.bitmap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}