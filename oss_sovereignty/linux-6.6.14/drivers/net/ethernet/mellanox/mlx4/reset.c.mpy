{
  "module_name": "reset.c",
  "hash_id": "5e534c823a16c82526ed26b442d3035c31c5ce8f3f3d4ce94770f1c1783fd05e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/reset.c",
  "human_readable_source": " \n\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n\n#include \"mlx4.h\"\n\nint mlx4_reset(struct mlx4_dev *dev)\n{\n\tvoid __iomem *reset;\n\tu32 *hca_header = NULL;\n\tint pcie_cap;\n\tu16 devctl;\n\tu16 linkctl;\n\tu16 vendor;\n\tunsigned long end;\n\tu32 sem;\n\tint i;\n\tint err = 0;\n\n#define MLX4_RESET_BASE\t\t0xf0000\n#define MLX4_RESET_SIZE\t\t  0x400\n#define MLX4_SEM_OFFSET\t\t  0x3fc\n#define MLX4_RESET_OFFSET\t   0x10\n#define MLX4_RESET_VALUE\tswab32(1)\n\n#define MLX4_SEM_TIMEOUT_JIFFIES\t(10 * HZ)\n#define MLX4_RESET_TIMEOUT_JIFFIES\t(2 * HZ)\n\n\t \n\n\t \n\thca_header = kmalloc(256, GFP_KERNEL);\n\tif (!hca_header) {\n\t\terr = -ENOMEM;\n\t\tmlx4_err(dev, \"Couldn't allocate memory to save HCA PCI header, aborting\\n\");\n\t\tgoto out;\n\t}\n\n\tpcie_cap = pci_pcie_cap(dev->persist->pdev);\n\n\tfor (i = 0; i < 64; ++i) {\n\t\tif (i == 22 || i == 23)\n\t\t\tcontinue;\n\t\tif (pci_read_config_dword(dev->persist->pdev, i * 4,\n\t\t\t\t\t  hca_header + i)) {\n\t\t\terr = -ENODEV;\n\t\t\tmlx4_err(dev, \"Couldn't save HCA PCI header, aborting\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treset = ioremap(pci_resource_start(dev->persist->pdev, 0) +\n\t\t\tMLX4_RESET_BASE,\n\t\t\tMLX4_RESET_SIZE);\n\tif (!reset) {\n\t\terr = -ENOMEM;\n\t\tmlx4_err(dev, \"Couldn't map HCA reset register, aborting\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tend = jiffies + MLX4_SEM_TIMEOUT_JIFFIES;\n\tdo {\n\t\tsem = readl(reset + MLX4_SEM_OFFSET);\n\t\tif (!sem)\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t} while (time_before(jiffies, end));\n\n\tif (sem) {\n\t\tmlx4_err(dev, \"Failed to obtain HW semaphore, aborting\\n\");\n\t\terr = -EAGAIN;\n\t\tiounmap(reset);\n\t\tgoto out;\n\t}\n\n\t \n\twritel(MLX4_RESET_VALUE, reset + MLX4_RESET_OFFSET);\n\tiounmap(reset);\n\n\t \n\tmsleep(1000);\n\n\tend = jiffies + MLX4_RESET_TIMEOUT_JIFFIES;\n\tdo {\n\t\tif (!pci_read_config_word(dev->persist->pdev, PCI_VENDOR_ID,\n\t\t\t\t\t  &vendor) && vendor != 0xffff)\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t} while (time_before(jiffies, end));\n\n\tif (vendor == 0xffff) {\n\t\terr = -ENODEV;\n\t\tmlx4_err(dev, \"PCI device did not come back after reset, aborting\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (pcie_cap) {\n\t\tdevctl = hca_header[(pcie_cap + PCI_EXP_DEVCTL) / 4];\n\t\tif (pcie_capability_write_word(dev->persist->pdev,\n\t\t\t\t\t       PCI_EXP_DEVCTL,\n\t\t\t\t\t       devctl)) {\n\t\t\terr = -ENODEV;\n\t\t\tmlx4_err(dev, \"Couldn't restore HCA PCI Express Device Control register, aborting\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tlinkctl = hca_header[(pcie_cap + PCI_EXP_LNKCTL) / 4];\n\t\tif (pcie_capability_write_word(dev->persist->pdev,\n\t\t\t\t\t       PCI_EXP_LNKCTL,\n\t\t\t\t\t       linkctl)) {\n\t\t\terr = -ENODEV;\n\t\t\tmlx4_err(dev, \"Couldn't restore HCA PCI Express Link control register, aborting\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 16; ++i) {\n\t\tif (i * 4 == PCI_COMMAND)\n\t\t\tcontinue;\n\n\t\tif (pci_write_config_dword(dev->persist->pdev, i * 4,\n\t\t\t\t\t   hca_header[i])) {\n\t\t\terr = -ENODEV;\n\t\t\tmlx4_err(dev, \"Couldn't restore HCA reg %x, aborting\\n\",\n\t\t\t\t i);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (pci_write_config_dword(dev->persist->pdev, PCI_COMMAND,\n\t\t\t\t   hca_header[PCI_COMMAND / 4])) {\n\t\terr = -ENODEV;\n\t\tmlx4_err(dev, \"Couldn't restore HCA COMMAND, aborting\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(hca_header);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}