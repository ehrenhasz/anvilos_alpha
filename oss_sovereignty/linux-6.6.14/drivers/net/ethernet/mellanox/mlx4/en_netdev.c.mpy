{
  "module_name": "en_netdev.c",
  "hash_id": "7532d8948d0fdf2406f2c284e75c5b8a66d06f866eae4adaab1d85e4fded5086",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/en_netdev.c",
  "human_readable_source": " \n\n#include <linux/bpf.h>\n#include <linux/etherdevice.h>\n#include <linux/filter.h>\n#include <linux/tcp.h>\n#include <linux/if_vlan.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <net/ip.h>\n#include <net/vxlan.h>\n#include <net/devlink.h>\n\n#include <linux/mlx4/driver.h>\n#include <linux/mlx4/device.h>\n#include <linux/mlx4/cmd.h>\n#include <linux/mlx4/cq.h>\n\n#include \"mlx4_en.h\"\n#include \"en_port.h\"\n\n#define MLX4_EN_MAX_XDP_MTU ((int)(PAGE_SIZE - ETH_HLEN - (2 * VLAN_HLEN) - \\\n\t\t\t\tXDP_PACKET_HEADROOM -\t\t\t    \\\n\t\t\t\tSKB_DATA_ALIGN(sizeof(struct skb_shared_info))))\n\nint mlx4_en_setup_tc(struct net_device *dev, u8 up)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tint i;\n\tunsigned int offset = 0;\n\n\tif (up && up != MLX4_EN_NUM_UP_HIGH)\n\t\treturn -EINVAL;\n\n\tnetdev_set_num_tc(dev, up);\n\tnetif_set_real_num_tx_queues(dev, priv->tx_ring_num[TX]);\n\t \n\tfor (i = 0; i < up; i++) {\n\t\tnetdev_set_tc_queue(dev, i, priv->num_tx_rings_p_up, offset);\n\t\toffset += priv->num_tx_rings_p_up;\n\t}\n\n#ifdef CONFIG_MLX4_EN_DCB\n\tif (!mlx4_is_slave(priv->mdev->dev)) {\n\t\tif (up) {\n\t\t\tif (priv->dcbx_cap)\n\t\t\t\tpriv->flags |= MLX4_EN_FLAG_DCB_ENABLED;\n\t\t} else {\n\t\t\tpriv->flags &= ~MLX4_EN_FLAG_DCB_ENABLED;\n\t\t\tpriv->cee_config.pfc_state = false;\n\t\t}\n\t}\n#endif  \n\n\treturn 0;\n}\n\nint mlx4_en_alloc_tx_queue_per_tc(struct net_device *dev, u8 tc)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_en_port_profile new_prof;\n\tstruct mlx4_en_priv *tmp;\n\tint total_count;\n\tint port_up = 0;\n\tint err = 0;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&mdev->state_lock);\n\tmemcpy(&new_prof, priv->prof, sizeof(struct mlx4_en_port_profile));\n\tnew_prof.num_up = (tc == 0) ? MLX4_EN_NUM_UP_LOW :\n\t\t\t\t      MLX4_EN_NUM_UP_HIGH;\n\tnew_prof.tx_ring_num[TX] = new_prof.num_tx_rings_p_up *\n\t\t\t\t   new_prof.num_up;\n\ttotal_count = new_prof.tx_ring_num[TX] + new_prof.tx_ring_num[TX_XDP];\n\tif (total_count > MAX_TX_RINGS) {\n\t\terr = -EINVAL;\n\t\ten_err(priv,\n\t\t       \"Total number of TX and XDP rings (%d) exceeds the maximum supported (%d)\\n\",\n\t\t       total_count, MAX_TX_RINGS);\n\t\tgoto out;\n\t}\n\terr = mlx4_en_try_alloc_resources(priv, tmp, &new_prof, true);\n\tif (err)\n\t\tgoto out;\n\n\tif (priv->port_up) {\n\t\tport_up = 1;\n\t\tmlx4_en_stop_port(dev, 1);\n\t}\n\n\tmlx4_en_safe_replace_resources(priv, tmp);\n\tif (port_up) {\n\t\terr = mlx4_en_start_port(dev);\n\t\tif (err) {\n\t\t\ten_err(priv, \"Failed starting port for setup TC\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = mlx4_en_setup_tc(dev, tc);\nout:\n\tmutex_unlock(&mdev->state_lock);\n\tkfree(tmp);\n\treturn err;\n}\n\nstatic int __mlx4_en_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t\t      void *type_data)\n{\n\tstruct tc_mqprio_qopt *mqprio = type_data;\n\n\tif (type != TC_SETUP_QDISC_MQPRIO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (mqprio->num_tc && mqprio->num_tc != MLX4_EN_NUM_UP_HIGH)\n\t\treturn -EINVAL;\n\n\tmqprio->hw = TC_MQPRIO_HW_OFFLOAD_TCS;\n\n\treturn mlx4_en_alloc_tx_queue_per_tc(dev, mqprio->num_tc);\n}\n\n#ifdef CONFIG_RFS_ACCEL\n\nstruct mlx4_en_filter {\n\tstruct list_head next;\n\tstruct work_struct work;\n\n\tu8     ip_proto;\n\t__be32 src_ip;\n\t__be32 dst_ip;\n\t__be16 src_port;\n\t__be16 dst_port;\n\n\tint rxq_index;\n\tstruct mlx4_en_priv *priv;\n\tu32 flow_id;\t\t\t \n\tint id;\t\t\t\t \n\tu64 reg_id;\t\t\t \n\tu8 activated;\t\t\t \n\tstruct hlist_node filter_chain;\n};\n\nstatic void mlx4_en_filter_rfs_expire(struct mlx4_en_priv *priv);\n\nstatic enum mlx4_net_trans_rule_id mlx4_ip_proto_to_trans_rule_id(u8 ip_proto)\n{\n\tswitch (ip_proto) {\n\tcase IPPROTO_UDP:\n\t\treturn MLX4_NET_TRANS_RULE_ID_UDP;\n\tcase IPPROTO_TCP:\n\t\treturn MLX4_NET_TRANS_RULE_ID_TCP;\n\tdefault:\n\t\treturn MLX4_NET_TRANS_RULE_NUM;\n\t}\n};\n\n \nstatic void mlx4_en_filter_work(struct work_struct *work)\n{\n\tstruct mlx4_en_filter *filter = container_of(work,\n\t\t\t\t\t\t     struct mlx4_en_filter,\n\t\t\t\t\t\t     work);\n\tstruct mlx4_en_priv *priv = filter->priv;\n\tstruct mlx4_spec_list spec_tcp_udp = {\n\t\t.id = mlx4_ip_proto_to_trans_rule_id(filter->ip_proto),\n\t\t{\n\t\t\t.tcp_udp = {\n\t\t\t\t.dst_port = filter->dst_port,\n\t\t\t\t.dst_port_msk = (__force __be16)-1,\n\t\t\t\t.src_port = filter->src_port,\n\t\t\t\t.src_port_msk = (__force __be16)-1,\n\t\t\t},\n\t\t},\n\t};\n\tstruct mlx4_spec_list spec_ip = {\n\t\t.id = MLX4_NET_TRANS_RULE_ID_IPV4,\n\t\t{\n\t\t\t.ipv4 = {\n\t\t\t\t.dst_ip = filter->dst_ip,\n\t\t\t\t.dst_ip_msk = (__force __be32)-1,\n\t\t\t\t.src_ip = filter->src_ip,\n\t\t\t\t.src_ip_msk = (__force __be32)-1,\n\t\t\t},\n\t\t},\n\t};\n\tstruct mlx4_spec_list spec_eth = {\n\t\t.id = MLX4_NET_TRANS_RULE_ID_ETH,\n\t};\n\tstruct mlx4_net_trans_rule rule = {\n\t\t.list = LIST_HEAD_INIT(rule.list),\n\t\t.queue_mode = MLX4_NET_TRANS_Q_LIFO,\n\t\t.exclusive = 1,\n\t\t.allow_loopback = 1,\n\t\t.promisc_mode = MLX4_FS_REGULAR,\n\t\t.port = priv->port,\n\t\t.priority = MLX4_DOMAIN_RFS,\n\t};\n\tint rc;\n\t__be64 mac_mask = cpu_to_be64(MLX4_MAC_MASK << 16);\n\n\tif (spec_tcp_udp.id >= MLX4_NET_TRANS_RULE_NUM) {\n\t\ten_warn(priv, \"RFS: ignoring unsupported ip protocol (%d)\\n\",\n\t\t\tfilter->ip_proto);\n\t\tgoto ignore;\n\t}\n\tlist_add_tail(&spec_eth.list, &rule.list);\n\tlist_add_tail(&spec_ip.list, &rule.list);\n\tlist_add_tail(&spec_tcp_udp.list, &rule.list);\n\n\trule.qpn = priv->rss_map.qps[filter->rxq_index].qpn;\n\tmemcpy(spec_eth.eth.dst_mac, priv->dev->dev_addr, ETH_ALEN);\n\tmemcpy(spec_eth.eth.dst_mac_msk, &mac_mask, ETH_ALEN);\n\n\tfilter->activated = 0;\n\n\tif (filter->reg_id) {\n\t\trc = mlx4_flow_detach(priv->mdev->dev, filter->reg_id);\n\t\tif (rc && rc != -ENOENT)\n\t\t\ten_err(priv, \"Error detaching flow. rc = %d\\n\", rc);\n\t}\n\n\trc = mlx4_flow_attach(priv->mdev->dev, &rule, &filter->reg_id);\n\tif (rc)\n\t\ten_err(priv, \"Error attaching flow. err = %d\\n\", rc);\n\nignore:\n\tmlx4_en_filter_rfs_expire(priv);\n\n\tfilter->activated = 1;\n}\n\nstatic inline struct hlist_head *\nfilter_hash_bucket(struct mlx4_en_priv *priv, __be32 src_ip, __be32 dst_ip,\n\t\t   __be16 src_port, __be16 dst_port)\n{\n\tunsigned long l;\n\tint bucket_idx;\n\n\tl = (__force unsigned long)src_port |\n\t    ((__force unsigned long)dst_port << 2);\n\tl ^= (__force unsigned long)(src_ip ^ dst_ip);\n\n\tbucket_idx = hash_long(l, MLX4_EN_FILTER_HASH_SHIFT);\n\n\treturn &priv->filter_hash[bucket_idx];\n}\n\nstatic struct mlx4_en_filter *\nmlx4_en_filter_alloc(struct mlx4_en_priv *priv, int rxq_index, __be32 src_ip,\n\t\t     __be32 dst_ip, u8 ip_proto, __be16 src_port,\n\t\t     __be16 dst_port, u32 flow_id)\n{\n\tstruct mlx4_en_filter *filter;\n\n\tfilter = kzalloc(sizeof(struct mlx4_en_filter), GFP_ATOMIC);\n\tif (!filter)\n\t\treturn NULL;\n\n\tfilter->priv = priv;\n\tfilter->rxq_index = rxq_index;\n\tINIT_WORK(&filter->work, mlx4_en_filter_work);\n\n\tfilter->src_ip = src_ip;\n\tfilter->dst_ip = dst_ip;\n\tfilter->ip_proto = ip_proto;\n\tfilter->src_port = src_port;\n\tfilter->dst_port = dst_port;\n\n\tfilter->flow_id = flow_id;\n\n\tfilter->id = priv->last_filter_id++ % RPS_NO_FILTER;\n\n\tlist_add_tail(&filter->next, &priv->filters);\n\thlist_add_head(&filter->filter_chain,\n\t\t       filter_hash_bucket(priv, src_ip, dst_ip, src_port,\n\t\t\t\t\t  dst_port));\n\n\treturn filter;\n}\n\nstatic void mlx4_en_filter_free(struct mlx4_en_filter *filter)\n{\n\tstruct mlx4_en_priv *priv = filter->priv;\n\tint rc;\n\n\tlist_del(&filter->next);\n\n\trc = mlx4_flow_detach(priv->mdev->dev, filter->reg_id);\n\tif (rc && rc != -ENOENT)\n\t\ten_err(priv, \"Error detaching flow. rc = %d\\n\", rc);\n\n\tkfree(filter);\n}\n\nstatic inline struct mlx4_en_filter *\nmlx4_en_filter_find(struct mlx4_en_priv *priv, __be32 src_ip, __be32 dst_ip,\n\t\t    u8 ip_proto, __be16 src_port, __be16 dst_port)\n{\n\tstruct mlx4_en_filter *filter;\n\tstruct mlx4_en_filter *ret = NULL;\n\n\thlist_for_each_entry(filter,\n\t\t\t     filter_hash_bucket(priv, src_ip, dst_ip,\n\t\t\t\t\t\tsrc_port, dst_port),\n\t\t\t     filter_chain) {\n\t\tif (filter->src_ip == src_ip &&\n\t\t    filter->dst_ip == dst_ip &&\n\t\t    filter->ip_proto == ip_proto &&\n\t\t    filter->src_port == src_port &&\n\t\t    filter->dst_port == dst_port) {\n\t\t\tret = filter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int\nmlx4_en_filter_rfs(struct net_device *net_dev, const struct sk_buff *skb,\n\t\t   u16 rxq_index, u32 flow_id)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(net_dev);\n\tstruct mlx4_en_filter *filter;\n\tconst struct iphdr *ip;\n\tconst __be16 *ports;\n\tu8 ip_proto;\n\t__be32 src_ip;\n\t__be32 dst_ip;\n\t__be16 src_port;\n\t__be16 dst_port;\n\tint nhoff = skb_network_offset(skb);\n\tint ret = 0;\n\n\tif (skb->encapsulation)\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (skb->protocol != htons(ETH_P_IP))\n\t\treturn -EPROTONOSUPPORT;\n\n\tip = (const struct iphdr *)(skb->data + nhoff);\n\tif (ip_is_fragment(ip))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif ((ip->protocol != IPPROTO_TCP) && (ip->protocol != IPPROTO_UDP))\n\t\treturn -EPROTONOSUPPORT;\n\tports = (const __be16 *)(skb->data + nhoff + 4 * ip->ihl);\n\n\tip_proto = ip->protocol;\n\tsrc_ip = ip->saddr;\n\tdst_ip = ip->daddr;\n\tsrc_port = ports[0];\n\tdst_port = ports[1];\n\n\tspin_lock_bh(&priv->filters_lock);\n\tfilter = mlx4_en_filter_find(priv, src_ip, dst_ip, ip_proto,\n\t\t\t\t     src_port, dst_port);\n\tif (filter) {\n\t\tif (filter->rxq_index == rxq_index)\n\t\t\tgoto out;\n\n\t\tfilter->rxq_index = rxq_index;\n\t} else {\n\t\tfilter = mlx4_en_filter_alloc(priv, rxq_index,\n\t\t\t\t\t      src_ip, dst_ip, ip_proto,\n\t\t\t\t\t      src_port, dst_port, flow_id);\n\t\tif (!filter) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tqueue_work(priv->mdev->workqueue, &filter->work);\n\nout:\n\tret = filter->id;\nerr:\n\tspin_unlock_bh(&priv->filters_lock);\n\n\treturn ret;\n}\n\nvoid mlx4_en_cleanup_filters(struct mlx4_en_priv *priv)\n{\n\tstruct mlx4_en_filter *filter, *tmp;\n\tLIST_HEAD(del_list);\n\n\tspin_lock_bh(&priv->filters_lock);\n\tlist_for_each_entry_safe(filter, tmp, &priv->filters, next) {\n\t\tlist_move(&filter->next, &del_list);\n\t\thlist_del(&filter->filter_chain);\n\t}\n\tspin_unlock_bh(&priv->filters_lock);\n\n\tlist_for_each_entry_safe(filter, tmp, &del_list, next) {\n\t\tcancel_work_sync(&filter->work);\n\t\tmlx4_en_filter_free(filter);\n\t}\n}\n\nstatic void mlx4_en_filter_rfs_expire(struct mlx4_en_priv *priv)\n{\n\tstruct mlx4_en_filter *filter = NULL, *tmp, *last_filter = NULL;\n\tLIST_HEAD(del_list);\n\tint i = 0;\n\n\tspin_lock_bh(&priv->filters_lock);\n\tlist_for_each_entry_safe(filter, tmp, &priv->filters, next) {\n\t\tif (i > MLX4_EN_FILTER_EXPIRY_QUOTA)\n\t\t\tbreak;\n\n\t\tif (filter->activated &&\n\t\t    !work_pending(&filter->work) &&\n\t\t    rps_may_expire_flow(priv->dev,\n\t\t\t\t\tfilter->rxq_index, filter->flow_id,\n\t\t\t\t\tfilter->id)) {\n\t\t\tlist_move(&filter->next, &del_list);\n\t\t\thlist_del(&filter->filter_chain);\n\t\t} else\n\t\t\tlast_filter = filter;\n\n\t\ti++;\n\t}\n\n\tif (last_filter && (&last_filter->next != priv->filters.next))\n\t\tlist_move(&priv->filters, &last_filter->next);\n\n\tspin_unlock_bh(&priv->filters_lock);\n\n\tlist_for_each_entry_safe(filter, tmp, &del_list, next)\n\t\tmlx4_en_filter_free(filter);\n}\n#endif\n\nstatic int mlx4_en_vlan_rx_add_vid(struct net_device *dev,\n\t\t\t\t   __be16 proto, u16 vid)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint err;\n\tint idx;\n\n\ten_dbg(HW, priv, \"adding VLAN:%d\\n\", vid);\n\n\tset_bit(vid, priv->active_vlans);\n\n\t \n\tmutex_lock(&mdev->state_lock);\n\tif (mdev->device_up && priv->port_up) {\n\t\terr = mlx4_SET_VLAN_FLTR(mdev->dev, priv);\n\t\tif (err) {\n\t\t\ten_err(priv, \"Failed configuring VLAN filter\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = mlx4_register_vlan(mdev->dev, priv->port, vid, &idx);\n\tif (err)\n\t\ten_dbg(HW, priv, \"Failed adding vlan %d\\n\", vid);\n\nout:\n\tmutex_unlock(&mdev->state_lock);\n\treturn err;\n}\n\nstatic int mlx4_en_vlan_rx_kill_vid(struct net_device *dev,\n\t\t\t\t    __be16 proto, u16 vid)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint err = 0;\n\n\ten_dbg(HW, priv, \"Killing VID:%d\\n\", vid);\n\n\tclear_bit(vid, priv->active_vlans);\n\n\t \n\tmutex_lock(&mdev->state_lock);\n\tmlx4_unregister_vlan(mdev->dev, priv->port, vid);\n\n\tif (mdev->device_up && priv->port_up) {\n\t\terr = mlx4_SET_VLAN_FLTR(mdev->dev, priv);\n\t\tif (err)\n\t\t\ten_err(priv, \"Failed configuring VLAN filter\\n\");\n\t}\n\tmutex_unlock(&mdev->state_lock);\n\n\treturn err;\n}\n\nstatic void mlx4_en_u64_to_mac(struct net_device *dev, u64 src_mac)\n{\n\tu8 addr[ETH_ALEN];\n\n\tu64_to_ether_addr(src_mac, addr);\n\teth_hw_addr_set(dev, addr);\n}\n\n\nstatic int mlx4_en_tunnel_steer_add(struct mlx4_en_priv *priv,\n\t\t\t\t    const unsigned char *addr,\n\t\t\t\t    int qpn, u64 *reg_id)\n{\n\tint err;\n\n\tif (priv->mdev->dev->caps.tunnel_offload_mode != MLX4_TUNNEL_OFFLOAD_MODE_VXLAN ||\n\t    priv->mdev->dev->caps.dmfs_high_steer_mode == MLX4_STEERING_DMFS_A0_STATIC)\n\t\treturn 0;  \n\n\terr = mlx4_tunnel_steer_add(priv->mdev->dev, addr, priv->port, qpn,\n\t\t\t\t    MLX4_DOMAIN_NIC, reg_id);\n\tif (err) {\n\t\ten_err(priv, \"failed to add vxlan steering rule, err %d\\n\", err);\n\t\treturn err;\n\t}\n\ten_dbg(DRV, priv, \"added vxlan steering rule, mac %pM reg_id %llx\\n\", addr, *reg_id);\n\treturn 0;\n}\n\n\nstatic int mlx4_en_uc_steer_add(struct mlx4_en_priv *priv,\n\t\t\t\tconst unsigned char *mac, int *qpn, u64 *reg_id)\n{\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_dev *dev = mdev->dev;\n\tint err;\n\n\tswitch (dev->caps.steering_mode) {\n\tcase MLX4_STEERING_MODE_B0: {\n\t\tstruct mlx4_qp qp;\n\t\tu8 gid[16] = {0};\n\n\t\tqp.qpn = *qpn;\n\t\tmemcpy(&gid[10], mac, ETH_ALEN);\n\t\tgid[5] = priv->port;\n\n\t\terr = mlx4_unicast_attach(dev, &qp, gid, 0, MLX4_PROT_ETH);\n\t\tbreak;\n\t}\n\tcase MLX4_STEERING_MODE_DEVICE_MANAGED: {\n\t\tstruct mlx4_spec_list spec_eth = { {NULL} };\n\t\t__be64 mac_mask = cpu_to_be64(MLX4_MAC_MASK << 16);\n\n\t\tstruct mlx4_net_trans_rule rule = {\n\t\t\t.queue_mode = MLX4_NET_TRANS_Q_FIFO,\n\t\t\t.exclusive = 0,\n\t\t\t.allow_loopback = 1,\n\t\t\t.promisc_mode = MLX4_FS_REGULAR,\n\t\t\t.priority = MLX4_DOMAIN_NIC,\n\t\t};\n\n\t\trule.port = priv->port;\n\t\trule.qpn = *qpn;\n\t\tINIT_LIST_HEAD(&rule.list);\n\n\t\tspec_eth.id = MLX4_NET_TRANS_RULE_ID_ETH;\n\t\tmemcpy(spec_eth.eth.dst_mac, mac, ETH_ALEN);\n\t\tmemcpy(spec_eth.eth.dst_mac_msk, &mac_mask, ETH_ALEN);\n\t\tlist_add_tail(&spec_eth.list, &rule.list);\n\n\t\terr = mlx4_flow_attach(dev, &rule, reg_id);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (err)\n\t\ten_warn(priv, \"Failed Attaching Unicast\\n\");\n\n\treturn err;\n}\n\nstatic void mlx4_en_uc_steer_release(struct mlx4_en_priv *priv,\n\t\t\t\t     const unsigned char *mac,\n\t\t\t\t     int qpn, u64 reg_id)\n{\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_dev *dev = mdev->dev;\n\n\tswitch (dev->caps.steering_mode) {\n\tcase MLX4_STEERING_MODE_B0: {\n\t\tstruct mlx4_qp qp;\n\t\tu8 gid[16] = {0};\n\n\t\tqp.qpn = qpn;\n\t\tmemcpy(&gid[10], mac, ETH_ALEN);\n\t\tgid[5] = priv->port;\n\n\t\tmlx4_unicast_detach(dev, &qp, gid, MLX4_PROT_ETH);\n\t\tbreak;\n\t}\n\tcase MLX4_STEERING_MODE_DEVICE_MANAGED: {\n\t\tmlx4_flow_detach(dev, reg_id);\n\t\tbreak;\n\t}\n\tdefault:\n\t\ten_err(priv, \"Invalid steering mode.\\n\");\n\t}\n}\n\nstatic int mlx4_en_get_qp(struct mlx4_en_priv *priv)\n{\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_dev *dev = mdev->dev;\n\tint index = 0;\n\tint err = 0;\n\tint *qpn = &priv->base_qpn;\n\tu64 mac = ether_addr_to_u64(priv->dev->dev_addr);\n\n\ten_dbg(DRV, priv, \"Registering MAC: %pM for adding\\n\",\n\t       priv->dev->dev_addr);\n\tindex = mlx4_register_mac(dev, priv->port, mac);\n\tif (index < 0) {\n\t\terr = index;\n\t\ten_err(priv, \"Failed adding MAC: %pM\\n\",\n\t\t       priv->dev->dev_addr);\n\t\treturn err;\n\t}\n\n\ten_info(priv, \"Steering Mode %d\\n\", dev->caps.steering_mode);\n\n\tif (dev->caps.steering_mode == MLX4_STEERING_MODE_A0) {\n\t\tint base_qpn = mlx4_get_base_qpn(dev, priv->port);\n\t\t*qpn = base_qpn + index;\n\t\treturn 0;\n\t}\n\n\terr = mlx4_qp_reserve_range(dev, 1, 1, qpn, MLX4_RESERVE_A0_QP,\n\t\t\t\t    MLX4_RES_USAGE_DRIVER);\n\ten_dbg(DRV, priv, \"Reserved qp %d\\n\", *qpn);\n\tif (err) {\n\t\ten_err(priv, \"Failed to reserve qp for mac registration\\n\");\n\t\tmlx4_unregister_mac(dev, priv->port, mac);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void mlx4_en_put_qp(struct mlx4_en_priv *priv)\n{\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_dev *dev = mdev->dev;\n\tint qpn = priv->base_qpn;\n\n\tif (dev->caps.steering_mode == MLX4_STEERING_MODE_A0) {\n\t\tu64 mac = ether_addr_to_u64(priv->dev->dev_addr);\n\t\ten_dbg(DRV, priv, \"Registering MAC: %pM for deleting\\n\",\n\t\t       priv->dev->dev_addr);\n\t\tmlx4_unregister_mac(dev, priv->port, mac);\n\t} else {\n\t\ten_dbg(DRV, priv, \"Releasing qp: port %d, qpn %d\\n\",\n\t\t       priv->port, qpn);\n\t\tmlx4_qp_release_range(dev, qpn, 1);\n\t\tpriv->flags &= ~MLX4_EN_FLAG_FORCE_PROMISC;\n\t}\n}\n\nstatic int mlx4_en_replace_mac(struct mlx4_en_priv *priv, int qpn,\n\t\t\t       unsigned char *new_mac, unsigned char *prev_mac)\n{\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_dev *dev = mdev->dev;\n\tint err = 0;\n\tu64 new_mac_u64 = ether_addr_to_u64(new_mac);\n\n\tif (dev->caps.steering_mode != MLX4_STEERING_MODE_A0) {\n\t\tstruct hlist_head *bucket;\n\t\tunsigned int mac_hash;\n\t\tstruct mlx4_mac_entry *entry;\n\t\tstruct hlist_node *tmp;\n\t\tu64 prev_mac_u64 = ether_addr_to_u64(prev_mac);\n\n\t\tbucket = &priv->mac_hash[prev_mac[MLX4_EN_MAC_HASH_IDX]];\n\t\thlist_for_each_entry_safe(entry, tmp, bucket, hlist) {\n\t\t\tif (ether_addr_equal_64bits(entry->mac, prev_mac)) {\n\t\t\t\tmlx4_en_uc_steer_release(priv, entry->mac,\n\t\t\t\t\t\t\t qpn, entry->reg_id);\n\t\t\t\tmlx4_unregister_mac(dev, priv->port,\n\t\t\t\t\t\t    prev_mac_u64);\n\t\t\t\thlist_del_rcu(&entry->hlist);\n\t\t\t\tsynchronize_rcu();\n\t\t\t\tmemcpy(entry->mac, new_mac, ETH_ALEN);\n\t\t\t\tentry->reg_id = 0;\n\t\t\t\tmac_hash = new_mac[MLX4_EN_MAC_HASH_IDX];\n\t\t\t\thlist_add_head_rcu(&entry->hlist,\n\t\t\t\t\t\t   &priv->mac_hash[mac_hash]);\n\t\t\t\tmlx4_register_mac(dev, priv->port, new_mac_u64);\n\t\t\t\terr = mlx4_en_uc_steer_add(priv, new_mac,\n\t\t\t\t\t\t\t   &qpn,\n\t\t\t\t\t\t\t   &entry->reg_id);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tif (priv->tunnel_reg_id) {\n\t\t\t\t\tmlx4_flow_detach(priv->mdev->dev, priv->tunnel_reg_id);\n\t\t\t\t\tpriv->tunnel_reg_id = 0;\n\t\t\t\t}\n\t\t\t\terr = mlx4_en_tunnel_steer_add(priv, new_mac, qpn,\n\t\t\t\t\t\t\t       &priv->tunnel_reg_id);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\treturn __mlx4_replace_mac(dev, priv->port, qpn, new_mac_u64);\n}\n\nstatic void mlx4_en_update_user_mac(struct mlx4_en_priv *priv,\n\t\t\t\t    unsigned char new_mac[ETH_ALEN + 2])\n{\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint err;\n\n\tif (!(mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_USER_MAC_EN))\n\t\treturn;\n\n\terr = mlx4_SET_PORT_user_mac(mdev->dev, priv->port, new_mac);\n\tif (err)\n\t\ten_err(priv, \"Failed to pass user MAC(%pM) to Firmware for port %d, with error %d\\n\",\n\t\t       new_mac, priv->port, err);\n}\n\nstatic int mlx4_en_do_set_mac(struct mlx4_en_priv *priv,\n\t\t\t      unsigned char new_mac[ETH_ALEN + 2])\n{\n\tint err = 0;\n\n\tif (priv->port_up) {\n\t\t \n\t\terr = mlx4_en_replace_mac(priv, priv->base_qpn,\n\t\t\t\t\t  new_mac, priv->current_mac);\n\t\tif (err)\n\t\t\ten_err(priv, \"Failed changing HW MAC address\\n\");\n\t} else\n\t\ten_dbg(HW, priv, \"Port is down while registering mac, exiting...\\n\");\n\n\tif (!err)\n\t\tmemcpy(priv->current_mac, new_mac, sizeof(priv->current_mac));\n\n\treturn err;\n}\n\nstatic int mlx4_en_set_mac(struct net_device *dev, void *addr)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct sockaddr *saddr = addr;\n\tunsigned char new_mac[ETH_ALEN + 2];\n\tint err;\n\n\tif (!is_valid_ether_addr(saddr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tmutex_lock(&mdev->state_lock);\n\tmemcpy(new_mac, saddr->sa_data, ETH_ALEN);\n\terr = mlx4_en_do_set_mac(priv, new_mac);\n\tif (err)\n\t\tgoto out;\n\n\teth_hw_addr_set(dev, saddr->sa_data);\n\tmlx4_en_update_user_mac(priv, new_mac);\nout:\n\tmutex_unlock(&mdev->state_lock);\n\n\treturn err;\n}\n\nstatic void mlx4_en_clear_list(struct net_device *dev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_mc_list *tmp, *mc_to_del;\n\n\tlist_for_each_entry_safe(mc_to_del, tmp, &priv->mc_list, list) {\n\t\tlist_del(&mc_to_del->list);\n\t\tkfree(mc_to_del);\n\t}\n}\n\nstatic void mlx4_en_cache_mclist(struct net_device *dev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct netdev_hw_addr *ha;\n\tstruct mlx4_en_mc_list *tmp;\n\n\tmlx4_en_clear_list(dev);\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\ttmp = kzalloc(sizeof(struct mlx4_en_mc_list), GFP_ATOMIC);\n\t\tif (!tmp) {\n\t\t\tmlx4_en_clear_list(dev);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(tmp->addr, ha->addr, ETH_ALEN);\n\t\tlist_add_tail(&tmp->list, &priv->mc_list);\n\t}\n}\n\nstatic void update_mclist_flags(struct mlx4_en_priv *priv,\n\t\t\t\tstruct list_head *dst,\n\t\t\t\tstruct list_head *src)\n{\n\tstruct mlx4_en_mc_list *dst_tmp, *src_tmp, *new_mc;\n\tbool found;\n\n\t \n\tlist_for_each_entry(dst_tmp, dst, list) {\n\t\tfound = false;\n\t\tlist_for_each_entry(src_tmp, src, list) {\n\t\t\tif (ether_addr_equal(dst_tmp->addr, src_tmp->addr)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tdst_tmp->action = MCLIST_REM;\n\t}\n\n\t \n\tlist_for_each_entry(src_tmp, src, list) {\n\t\tfound = false;\n\t\tlist_for_each_entry(dst_tmp, dst, list) {\n\t\t\tif (ether_addr_equal(dst_tmp->addr, src_tmp->addr)) {\n\t\t\t\tdst_tmp->action = MCLIST_NONE;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tnew_mc = kmemdup(src_tmp,\n\t\t\t\t\t sizeof(struct mlx4_en_mc_list),\n\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!new_mc)\n\t\t\t\treturn;\n\n\t\t\tnew_mc->action = MCLIST_ADD;\n\t\t\tlist_add_tail(&new_mc->list, dst);\n\t\t}\n\t}\n}\n\nstatic void mlx4_en_set_rx_mode(struct net_device *dev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\tif (!priv->port_up)\n\t\treturn;\n\n\tqueue_work(priv->mdev->workqueue, &priv->rx_mode_task);\n}\n\nstatic void mlx4_en_set_promisc_mode(struct mlx4_en_priv *priv,\n\t\t\t\t     struct mlx4_en_dev *mdev)\n{\n\tint err = 0;\n\n\tif (!(priv->flags & MLX4_EN_FLAG_PROMISC)) {\n\t\tif (netif_msg_rx_status(priv))\n\t\t\ten_warn(priv, \"Entering promiscuous mode\\n\");\n\t\tpriv->flags |= MLX4_EN_FLAG_PROMISC;\n\n\t\t \n\t\tswitch (mdev->dev->caps.steering_mode) {\n\t\tcase MLX4_STEERING_MODE_DEVICE_MANAGED:\n\t\t\terr = mlx4_flow_steer_promisc_add(mdev->dev,\n\t\t\t\t\t\t\t  priv->port,\n\t\t\t\t\t\t\t  priv->base_qpn,\n\t\t\t\t\t\t\t  MLX4_FS_ALL_DEFAULT);\n\t\t\tif (err)\n\t\t\t\ten_err(priv, \"Failed enabling promiscuous mode\\n\");\n\t\t\tpriv->flags |= MLX4_EN_FLAG_MC_PROMISC;\n\t\t\tbreak;\n\n\t\tcase MLX4_STEERING_MODE_B0:\n\t\t\terr = mlx4_unicast_promisc_add(mdev->dev,\n\t\t\t\t\t\t       priv->base_qpn,\n\t\t\t\t\t\t       priv->port);\n\t\t\tif (err)\n\t\t\t\ten_err(priv, \"Failed enabling unicast promiscuous mode\\n\");\n\n\t\t\t \n\t\t\tif (!(priv->flags & MLX4_EN_FLAG_MC_PROMISC)) {\n\t\t\t\terr = mlx4_multicast_promisc_add(mdev->dev,\n\t\t\t\t\t\t\t\t priv->base_qpn,\n\t\t\t\t\t\t\t\t priv->port);\n\t\t\t\tif (err)\n\t\t\t\t\ten_err(priv, \"Failed enabling multicast promiscuous mode\\n\");\n\t\t\t\tpriv->flags |= MLX4_EN_FLAG_MC_PROMISC;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MLX4_STEERING_MODE_A0:\n\t\t\terr = mlx4_SET_PORT_qpn_calc(mdev->dev,\n\t\t\t\t\t\t     priv->port,\n\t\t\t\t\t\t     priv->base_qpn,\n\t\t\t\t\t\t     1);\n\t\t\tif (err)\n\t\t\t\ten_err(priv, \"Failed enabling promiscuous mode\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\terr = mlx4_SET_MCAST_FLTR(mdev->dev, priv->port, 0,\n\t\t\t\t\t  0, MLX4_MCAST_DISABLE);\n\t\tif (err)\n\t\t\ten_err(priv, \"Failed disabling multicast filter\\n\");\n\t}\n}\n\nstatic void mlx4_en_clear_promisc_mode(struct mlx4_en_priv *priv,\n\t\t\t\t       struct mlx4_en_dev *mdev)\n{\n\tint err = 0;\n\n\tif (netif_msg_rx_status(priv))\n\t\ten_warn(priv, \"Leaving promiscuous mode\\n\");\n\tpriv->flags &= ~MLX4_EN_FLAG_PROMISC;\n\n\t \n\tswitch (mdev->dev->caps.steering_mode) {\n\tcase MLX4_STEERING_MODE_DEVICE_MANAGED:\n\t\terr = mlx4_flow_steer_promisc_remove(mdev->dev,\n\t\t\t\t\t\t     priv->port,\n\t\t\t\t\t\t     MLX4_FS_ALL_DEFAULT);\n\t\tif (err)\n\t\t\ten_err(priv, \"Failed disabling promiscuous mode\\n\");\n\t\tpriv->flags &= ~MLX4_EN_FLAG_MC_PROMISC;\n\t\tbreak;\n\n\tcase MLX4_STEERING_MODE_B0:\n\t\terr = mlx4_unicast_promisc_remove(mdev->dev,\n\t\t\t\t\t\t  priv->base_qpn,\n\t\t\t\t\t\t  priv->port);\n\t\tif (err)\n\t\t\ten_err(priv, \"Failed disabling unicast promiscuous mode\\n\");\n\t\t \n\t\tif (priv->flags & MLX4_EN_FLAG_MC_PROMISC) {\n\t\t\terr = mlx4_multicast_promisc_remove(mdev->dev,\n\t\t\t\t\t\t\t    priv->base_qpn,\n\t\t\t\t\t\t\t    priv->port);\n\t\t\tif (err)\n\t\t\t\ten_err(priv, \"Failed disabling multicast promiscuous mode\\n\");\n\t\t\tpriv->flags &= ~MLX4_EN_FLAG_MC_PROMISC;\n\t\t}\n\t\tbreak;\n\n\tcase MLX4_STEERING_MODE_A0:\n\t\terr = mlx4_SET_PORT_qpn_calc(mdev->dev,\n\t\t\t\t\t     priv->port,\n\t\t\t\t\t     priv->base_qpn, 0);\n\t\tif (err)\n\t\t\ten_err(priv, \"Failed disabling promiscuous mode\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void mlx4_en_do_multicast(struct mlx4_en_priv *priv,\n\t\t\t\t struct net_device *dev,\n\t\t\t\t struct mlx4_en_dev *mdev)\n{\n\tstruct mlx4_en_mc_list *mclist, *tmp;\n\tu64 mcast_addr = 0;\n\tu8 mc_list[16] = {0};\n\tint err = 0;\n\n\t \n\tif (dev->flags & IFF_ALLMULTI) {\n\t\terr = mlx4_SET_MCAST_FLTR(mdev->dev, priv->port, 0,\n\t\t\t\t\t  0, MLX4_MCAST_DISABLE);\n\t\tif (err)\n\t\t\ten_err(priv, \"Failed disabling multicast filter\\n\");\n\n\t\t \n\t\tif (!(priv->flags & MLX4_EN_FLAG_MC_PROMISC)) {\n\t\t\tswitch (mdev->dev->caps.steering_mode) {\n\t\t\tcase MLX4_STEERING_MODE_DEVICE_MANAGED:\n\t\t\t\terr = mlx4_flow_steer_promisc_add(mdev->dev,\n\t\t\t\t\t\t\t\t  priv->port,\n\t\t\t\t\t\t\t\t  priv->base_qpn,\n\t\t\t\t\t\t\t\t  MLX4_FS_MC_DEFAULT);\n\t\t\t\tbreak;\n\n\t\t\tcase MLX4_STEERING_MODE_B0:\n\t\t\t\terr = mlx4_multicast_promisc_add(mdev->dev,\n\t\t\t\t\t\t\t\t priv->base_qpn,\n\t\t\t\t\t\t\t\t priv->port);\n\t\t\t\tbreak;\n\n\t\t\tcase MLX4_STEERING_MODE_A0:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (err)\n\t\t\t\ten_err(priv, \"Failed entering multicast promisc mode\\n\");\n\t\t\tpriv->flags |= MLX4_EN_FLAG_MC_PROMISC;\n\t\t}\n\t} else {\n\t\t \n\t\tif (priv->flags & MLX4_EN_FLAG_MC_PROMISC) {\n\t\t\tswitch (mdev->dev->caps.steering_mode) {\n\t\t\tcase MLX4_STEERING_MODE_DEVICE_MANAGED:\n\t\t\t\terr = mlx4_flow_steer_promisc_remove(mdev->dev,\n\t\t\t\t\t\t\t\t     priv->port,\n\t\t\t\t\t\t\t\t     MLX4_FS_MC_DEFAULT);\n\t\t\t\tbreak;\n\n\t\t\tcase MLX4_STEERING_MODE_B0:\n\t\t\t\terr = mlx4_multicast_promisc_remove(mdev->dev,\n\t\t\t\t\t\t\t\t    priv->base_qpn,\n\t\t\t\t\t\t\t\t    priv->port);\n\t\t\t\tbreak;\n\n\t\t\tcase MLX4_STEERING_MODE_A0:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (err)\n\t\t\t\ten_err(priv, \"Failed disabling multicast promiscuous mode\\n\");\n\t\t\tpriv->flags &= ~MLX4_EN_FLAG_MC_PROMISC;\n\t\t}\n\n\t\terr = mlx4_SET_MCAST_FLTR(mdev->dev, priv->port, 0,\n\t\t\t\t\t  0, MLX4_MCAST_DISABLE);\n\t\tif (err)\n\t\t\ten_err(priv, \"Failed disabling multicast filter\\n\");\n\n\t\t \n\t\tmlx4_SET_MCAST_FLTR(mdev->dev, priv->port, ETH_BCAST,\n\t\t\t\t    1, MLX4_MCAST_CONFIG);\n\n\t\t \n\t\tnetif_addr_lock_bh(dev);\n\t\tmlx4_en_cache_mclist(dev);\n\t\tnetif_addr_unlock_bh(dev);\n\t\tlist_for_each_entry(mclist, &priv->mc_list, list) {\n\t\t\tmcast_addr = ether_addr_to_u64(mclist->addr);\n\t\t\tmlx4_SET_MCAST_FLTR(mdev->dev, priv->port,\n\t\t\t\t\t    mcast_addr, 0, MLX4_MCAST_CONFIG);\n\t\t}\n\t\terr = mlx4_SET_MCAST_FLTR(mdev->dev, priv->port, 0,\n\t\t\t\t\t  0, MLX4_MCAST_ENABLE);\n\t\tif (err)\n\t\t\ten_err(priv, \"Failed enabling multicast filter\\n\");\n\n\t\tupdate_mclist_flags(priv, &priv->curr_list, &priv->mc_list);\n\t\tlist_for_each_entry_safe(mclist, tmp, &priv->curr_list, list) {\n\t\t\tif (mclist->action == MCLIST_REM) {\n\t\t\t\t \n\t\t\t\tmemcpy(&mc_list[10], mclist->addr, ETH_ALEN);\n\t\t\t\tmc_list[5] = priv->port;\n\t\t\t\terr = mlx4_multicast_detach(mdev->dev,\n\t\t\t\t\t\t\t    priv->rss_map.indir_qp,\n\t\t\t\t\t\t\t    mc_list,\n\t\t\t\t\t\t\t    MLX4_PROT_ETH,\n\t\t\t\t\t\t\t    mclist->reg_id);\n\t\t\t\tif (err)\n\t\t\t\t\ten_err(priv, \"Fail to detach multicast address\\n\");\n\n\t\t\t\tif (mclist->tunnel_reg_id) {\n\t\t\t\t\terr = mlx4_flow_detach(priv->mdev->dev, mclist->tunnel_reg_id);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\ten_err(priv, \"Failed to detach multicast address\\n\");\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tlist_del(&mclist->list);\n\t\t\t\tkfree(mclist);\n\t\t\t} else if (mclist->action == MCLIST_ADD) {\n\t\t\t\t \n\t\t\t\tmemcpy(&mc_list[10], mclist->addr, ETH_ALEN);\n\t\t\t\t \n\t\t\t\tmc_list[5] = priv->port;\n\t\t\t\terr = mlx4_multicast_attach(mdev->dev,\n\t\t\t\t\t\t\t    priv->rss_map.indir_qp,\n\t\t\t\t\t\t\t    mc_list,\n\t\t\t\t\t\t\t    priv->port, 0,\n\t\t\t\t\t\t\t    MLX4_PROT_ETH,\n\t\t\t\t\t\t\t    &mclist->reg_id);\n\t\t\t\tif (err)\n\t\t\t\t\ten_err(priv, \"Fail to attach multicast address\\n\");\n\n\t\t\t\terr = mlx4_en_tunnel_steer_add(priv, &mc_list[10], priv->base_qpn,\n\t\t\t\t\t\t\t       &mclist->tunnel_reg_id);\n\t\t\t\tif (err)\n\t\t\t\t\ten_err(priv, \"Failed to attach multicast address\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void mlx4_en_do_uc_filter(struct mlx4_en_priv *priv,\n\t\t\t\t struct net_device *dev,\n\t\t\t\t struct mlx4_en_dev *mdev)\n{\n\tstruct netdev_hw_addr *ha;\n\tstruct mlx4_mac_entry *entry;\n\tstruct hlist_node *tmp;\n\tbool found;\n\tu64 mac;\n\tint err = 0;\n\tstruct hlist_head *bucket;\n\tunsigned int i;\n\tint removed = 0;\n\tu32 prev_flags;\n\n\t \n\n\t \n\tfor (i = 0; i < MLX4_EN_MAC_HASH_SIZE; ++i) {\n\t\tbucket = &priv->mac_hash[i];\n\t\thlist_for_each_entry_safe(entry, tmp, bucket, hlist) {\n\t\t\tfound = false;\n\t\t\tnetdev_for_each_uc_addr(ha, dev) {\n\t\t\t\tif (ether_addr_equal_64bits(entry->mac,\n\t\t\t\t\t\t\t    ha->addr)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ether_addr_equal_64bits(entry->mac,\n\t\t\t\t\t\t    priv->current_mac))\n\t\t\t\tfound = true;\n\n\t\t\tif (!found) {\n\t\t\t\tmac = ether_addr_to_u64(entry->mac);\n\t\t\t\tmlx4_en_uc_steer_release(priv, entry->mac,\n\t\t\t\t\t\t\t priv->base_qpn,\n\t\t\t\t\t\t\t entry->reg_id);\n\t\t\t\tmlx4_unregister_mac(mdev->dev, priv->port, mac);\n\n\t\t\t\thlist_del_rcu(&entry->hlist);\n\t\t\t\tkfree_rcu(entry, rcu);\n\t\t\t\ten_dbg(DRV, priv, \"Removed MAC %pM on port:%d\\n\",\n\t\t\t\t       entry->mac, priv->port);\n\t\t\t\t++removed;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif ((priv->flags & MLX4_EN_FLAG_FORCE_PROMISC) && 0 == removed)\n\t\treturn;\n\n\tprev_flags = priv->flags;\n\tpriv->flags &= ~MLX4_EN_FLAG_FORCE_PROMISC;\n\n\t \n\tnetdev_for_each_uc_addr(ha, dev) {\n\t\tfound = false;\n\t\tbucket = &priv->mac_hash[ha->addr[MLX4_EN_MAC_HASH_IDX]];\n\t\thlist_for_each_entry(entry, bucket, hlist) {\n\t\t\tif (ether_addr_equal_64bits(entry->mac, ha->addr)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\t\t\tif (!entry) {\n\t\t\t\ten_err(priv, \"Failed adding MAC %pM on port:%d (out of memory)\\n\",\n\t\t\t\t       ha->addr, priv->port);\n\t\t\t\tpriv->flags |= MLX4_EN_FLAG_FORCE_PROMISC;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmac = ether_addr_to_u64(ha->addr);\n\t\t\tmemcpy(entry->mac, ha->addr, ETH_ALEN);\n\t\t\terr = mlx4_register_mac(mdev->dev, priv->port, mac);\n\t\t\tif (err < 0) {\n\t\t\t\ten_err(priv, \"Failed registering MAC %pM on port %d: %d\\n\",\n\t\t\t\t       ha->addr, priv->port, err);\n\t\t\t\tkfree(entry);\n\t\t\t\tpriv->flags |= MLX4_EN_FLAG_FORCE_PROMISC;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = mlx4_en_uc_steer_add(priv, ha->addr,\n\t\t\t\t\t\t   &priv->base_qpn,\n\t\t\t\t\t\t   &entry->reg_id);\n\t\t\tif (err) {\n\t\t\t\ten_err(priv, \"Failed adding MAC %pM on port %d: %d\\n\",\n\t\t\t\t       ha->addr, priv->port, err);\n\t\t\t\tmlx4_unregister_mac(mdev->dev, priv->port, mac);\n\t\t\t\tkfree(entry);\n\t\t\t\tpriv->flags |= MLX4_EN_FLAG_FORCE_PROMISC;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tunsigned int mac_hash;\n\t\t\t\ten_dbg(DRV, priv, \"Added MAC %pM on port:%d\\n\",\n\t\t\t\t       ha->addr, priv->port);\n\t\t\t\tmac_hash = ha->addr[MLX4_EN_MAC_HASH_IDX];\n\t\t\t\tbucket = &priv->mac_hash[mac_hash];\n\t\t\t\thlist_add_head_rcu(&entry->hlist, bucket);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (priv->flags & MLX4_EN_FLAG_FORCE_PROMISC) {\n\t\ten_warn(priv, \"Forcing promiscuous mode on port:%d\\n\",\n\t\t\tpriv->port);\n\t} else if (prev_flags & MLX4_EN_FLAG_FORCE_PROMISC) {\n\t\ten_warn(priv, \"Stop forcing promiscuous mode on port:%d\\n\",\n\t\t\tpriv->port);\n\t}\n}\n\nstatic void mlx4_en_do_set_rx_mode(struct work_struct *work)\n{\n\tstruct mlx4_en_priv *priv = container_of(work, struct mlx4_en_priv,\n\t\t\t\t\t\t rx_mode_task);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct net_device *dev = priv->dev;\n\n\tmutex_lock(&mdev->state_lock);\n\tif (!mdev->device_up) {\n\t\ten_dbg(HW, priv, \"Card is not up, ignoring rx mode change.\\n\");\n\t\tgoto out;\n\t}\n\tif (!priv->port_up) {\n\t\ten_dbg(HW, priv, \"Port is down, ignoring rx mode change.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!netif_carrier_ok(dev)) {\n\t\tif (!mlx4_en_QUERY_PORT(mdev, priv->port)) {\n\t\t\tif (priv->port_state.link_state) {\n\t\t\t\tnetif_carrier_on(dev);\n\t\t\t\ten_dbg(LINK, priv, \"Link Up\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dev->priv_flags & IFF_UNICAST_FLT)\n\t\tmlx4_en_do_uc_filter(priv, dev, mdev);\n\n\t \n\tif ((dev->flags & IFF_PROMISC) ||\n\t    (priv->flags & MLX4_EN_FLAG_FORCE_PROMISC)) {\n\t\tmlx4_en_set_promisc_mode(priv, mdev);\n\t\tgoto out;\n\t}\n\n\t \n\tif (priv->flags & MLX4_EN_FLAG_PROMISC)\n\t\tmlx4_en_clear_promisc_mode(priv, mdev);\n\n\tmlx4_en_do_multicast(priv, dev, mdev);\nout:\n\tmutex_unlock(&mdev->state_lock);\n}\n\nstatic int mlx4_en_set_rss_steer_rules(struct mlx4_en_priv *priv)\n{\n\tu64 reg_id;\n\tint err = 0;\n\tint *qpn = &priv->base_qpn;\n\tstruct mlx4_mac_entry *entry;\n\n\terr = mlx4_en_uc_steer_add(priv, priv->dev->dev_addr, qpn, &reg_id);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx4_en_tunnel_steer_add(priv, priv->dev->dev_addr, *qpn,\n\t\t\t\t       &priv->tunnel_reg_id);\n\tif (err)\n\t\tgoto tunnel_err;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\terr = -ENOMEM;\n\t\tgoto alloc_err;\n\t}\n\n\tmemcpy(entry->mac, priv->dev->dev_addr, sizeof(entry->mac));\n\tmemcpy(priv->current_mac, entry->mac, sizeof(priv->current_mac));\n\tentry->reg_id = reg_id;\n\thlist_add_head_rcu(&entry->hlist,\n\t\t\t   &priv->mac_hash[entry->mac[MLX4_EN_MAC_HASH_IDX]]);\n\n\treturn 0;\n\nalloc_err:\n\tif (priv->tunnel_reg_id)\n\t\tmlx4_flow_detach(priv->mdev->dev, priv->tunnel_reg_id);\n\ntunnel_err:\n\tmlx4_en_uc_steer_release(priv, priv->dev->dev_addr, *qpn, reg_id);\n\treturn err;\n}\n\nstatic void mlx4_en_delete_rss_steer_rules(struct mlx4_en_priv *priv)\n{\n\tu64 mac;\n\tunsigned int i;\n\tint qpn = priv->base_qpn;\n\tstruct hlist_head *bucket;\n\tstruct hlist_node *tmp;\n\tstruct mlx4_mac_entry *entry;\n\n\tfor (i = 0; i < MLX4_EN_MAC_HASH_SIZE; ++i) {\n\t\tbucket = &priv->mac_hash[i];\n\t\thlist_for_each_entry_safe(entry, tmp, bucket, hlist) {\n\t\t\tmac = ether_addr_to_u64(entry->mac);\n\t\t\ten_dbg(DRV, priv, \"Registering MAC:%pM for deleting\\n\",\n\t\t\t       entry->mac);\n\t\t\tmlx4_en_uc_steer_release(priv, entry->mac,\n\t\t\t\t\t\t qpn, entry->reg_id);\n\n\t\t\tmlx4_unregister_mac(priv->mdev->dev, priv->port, mac);\n\t\t\thlist_del_rcu(&entry->hlist);\n\t\t\tkfree_rcu(entry, rcu);\n\t\t}\n\t}\n\n\tif (priv->tunnel_reg_id) {\n\t\tmlx4_flow_detach(priv->mdev->dev, priv->tunnel_reg_id);\n\t\tpriv->tunnel_reg_id = 0;\n\t}\n}\n\nstatic void mlx4_en_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_en_tx_ring *tx_ring = priv->tx_ring[TX][txqueue];\n\n\tif (netif_msg_timer(priv))\n\t\ten_warn(priv, \"Tx timeout called on port:%d\\n\", priv->port);\n\n\ten_warn(priv, \"TX timeout on queue: %d, QP: 0x%x, CQ: 0x%x, Cons: 0x%x, Prod: 0x%x\\n\",\n\t\ttxqueue, tx_ring->qpn, tx_ring->sp_cqn,\n\t\ttx_ring->cons, tx_ring->prod);\n\n\tpriv->port_stats.tx_timeout++;\n\tif (!test_and_set_bit(MLX4_EN_STATE_FLAG_RESTARTING, &priv->state)) {\n\t\ten_dbg(DRV, priv, \"Scheduling port restart\\n\");\n\t\tqueue_work(mdev->workqueue, &priv->restart_task);\n\t}\n}\n\n\nstatic void\nmlx4_en_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\tspin_lock_bh(&priv->stats_lock);\n\tmlx4_en_fold_software_stats(dev);\n\tnetdev_stats_to_stats64(stats, &dev->stats);\n\tspin_unlock_bh(&priv->stats_lock);\n}\n\nstatic void mlx4_en_set_default_moderation(struct mlx4_en_priv *priv)\n{\n\tstruct mlx4_en_cq *cq;\n\tint i, t;\n\n\t \n\tpriv->rx_frames = MLX4_EN_RX_COAL_TARGET;\n\tpriv->rx_usecs = MLX4_EN_RX_COAL_TIME;\n\tpriv->tx_frames = MLX4_EN_TX_COAL_PKTS;\n\tpriv->tx_usecs = MLX4_EN_TX_COAL_TIME;\n\ten_dbg(INTR, priv, \"Default coalescing params for mtu:%d - rx_frames:%d rx_usecs:%d\\n\",\n\t       priv->dev->mtu, priv->rx_frames, priv->rx_usecs);\n\n\t \n\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\tcq = priv->rx_cq[i];\n\t\tcq->moder_cnt = priv->rx_frames;\n\t\tcq->moder_time = priv->rx_usecs;\n\t\tpriv->last_moder_time[i] = MLX4_EN_AUTO_CONF;\n\t\tpriv->last_moder_packets[i] = 0;\n\t\tpriv->last_moder_bytes[i] = 0;\n\t}\n\n\tfor (t = 0 ; t < MLX4_EN_NUM_TX_TYPES; t++) {\n\t\tfor (i = 0; i < priv->tx_ring_num[t]; i++) {\n\t\t\tcq = priv->tx_cq[t][i];\n\t\t\tcq->moder_cnt = priv->tx_frames;\n\t\t\tcq->moder_time = priv->tx_usecs;\n\t\t}\n\t}\n\n\t \n\tpriv->pkt_rate_low = MLX4_EN_RX_RATE_LOW;\n\tpriv->rx_usecs_low = MLX4_EN_RX_COAL_TIME_LOW;\n\tpriv->pkt_rate_high = MLX4_EN_RX_RATE_HIGH;\n\tpriv->rx_usecs_high = MLX4_EN_RX_COAL_TIME_HIGH;\n\tpriv->sample_interval = MLX4_EN_SAMPLE_INTERVAL;\n\tpriv->adaptive_rx_coal = 1;\n\tpriv->last_moder_jiffies = 0;\n\tpriv->last_moder_tx_packets = 0;\n}\n\nstatic void mlx4_en_auto_moderation(struct mlx4_en_priv *priv)\n{\n\tunsigned long period = (unsigned long) (jiffies - priv->last_moder_jiffies);\n\tu32 pkt_rate_high, pkt_rate_low;\n\tstruct mlx4_en_cq *cq;\n\tunsigned long packets;\n\tunsigned long rate;\n\tunsigned long avg_pkt_size;\n\tunsigned long rx_packets;\n\tunsigned long rx_bytes;\n\tunsigned long rx_pkt_diff;\n\tint moder_time;\n\tint ring, err;\n\n\tif (!priv->adaptive_rx_coal || period < priv->sample_interval * HZ)\n\t\treturn;\n\n\tpkt_rate_low = READ_ONCE(priv->pkt_rate_low);\n\tpkt_rate_high = READ_ONCE(priv->pkt_rate_high);\n\n\tfor (ring = 0; ring < priv->rx_ring_num; ring++) {\n\t\trx_packets = READ_ONCE(priv->rx_ring[ring]->packets);\n\t\trx_bytes = READ_ONCE(priv->rx_ring[ring]->bytes);\n\n\t\trx_pkt_diff = rx_packets - priv->last_moder_packets[ring];\n\t\tpackets = rx_pkt_diff;\n\t\trate = packets * HZ / period;\n\t\tavg_pkt_size = packets ? (rx_bytes -\n\t\t\t\tpriv->last_moder_bytes[ring]) / packets : 0;\n\n\t\t \n\t\tif (rate > (MLX4_EN_RX_RATE_THRESH / priv->rx_ring_num) &&\n\t\t    avg_pkt_size > MLX4_EN_AVG_PKT_SMALL) {\n\t\t\tif (rate <= pkt_rate_low)\n\t\t\t\tmoder_time = priv->rx_usecs_low;\n\t\t\telse if (rate >= pkt_rate_high)\n\t\t\t\tmoder_time = priv->rx_usecs_high;\n\t\t\telse\n\t\t\t\tmoder_time = (rate - pkt_rate_low) *\n\t\t\t\t\t(priv->rx_usecs_high - priv->rx_usecs_low) /\n\t\t\t\t\t(pkt_rate_high - pkt_rate_low) +\n\t\t\t\t\tpriv->rx_usecs_low;\n\t\t} else {\n\t\t\tmoder_time = priv->rx_usecs_low;\n\t\t}\n\n\t\tcq = priv->rx_cq[ring];\n\t\tif (moder_time != priv->last_moder_time[ring] ||\n\t\t    cq->moder_cnt != priv->rx_frames) {\n\t\t\tpriv->last_moder_time[ring] = moder_time;\n\t\t\tcq->moder_time = moder_time;\n\t\t\tcq->moder_cnt = priv->rx_frames;\n\t\t\terr = mlx4_en_set_cq_moder(priv, cq);\n\t\t\tif (err)\n\t\t\t\ten_err(priv, \"Failed modifying moderation for cq:%d\\n\",\n\t\t\t\t       ring);\n\t\t}\n\t\tpriv->last_moder_packets[ring] = rx_packets;\n\t\tpriv->last_moder_bytes[ring] = rx_bytes;\n\t}\n\n\tpriv->last_moder_jiffies = jiffies;\n}\n\nstatic void mlx4_en_do_get_stats(struct work_struct *work)\n{\n\tstruct delayed_work *delay = to_delayed_work(work);\n\tstruct mlx4_en_priv *priv = container_of(delay, struct mlx4_en_priv,\n\t\t\t\t\t\t stats_task);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint err;\n\n\tmutex_lock(&mdev->state_lock);\n\tif (mdev->device_up) {\n\t\tif (priv->port_up) {\n\t\t\terr = mlx4_en_DUMP_ETH_STATS(mdev, priv->port, 0);\n\t\t\tif (err)\n\t\t\t\ten_dbg(HW, priv, \"Could not update stats\\n\");\n\n\t\t\tmlx4_en_auto_moderation(priv);\n\t\t}\n\n\t\tqueue_delayed_work(mdev->workqueue, &priv->stats_task, STATS_DELAY);\n\t}\n\tif (mdev->mac_removed[MLX4_MAX_PORTS + 1 - priv->port]) {\n\t\tmlx4_en_do_set_mac(priv, priv->current_mac);\n\t\tmdev->mac_removed[MLX4_MAX_PORTS + 1 - priv->port] = 0;\n\t}\n\tmutex_unlock(&mdev->state_lock);\n}\n\n \nstatic void mlx4_en_service_task(struct work_struct *work)\n{\n\tstruct delayed_work *delay = to_delayed_work(work);\n\tstruct mlx4_en_priv *priv = container_of(delay, struct mlx4_en_priv,\n\t\t\t\t\t\t service_task);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\n\tmutex_lock(&mdev->state_lock);\n\tif (mdev->device_up) {\n\t\tif (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_TS)\n\t\t\tmlx4_en_ptp_overflow_check(mdev);\n\n\t\tmlx4_en_recover_from_oom(priv);\n\t\tqueue_delayed_work(mdev->workqueue, &priv->service_task,\n\t\t\t\t   SERVICE_TASK_DELAY);\n\t}\n\tmutex_unlock(&mdev->state_lock);\n}\n\nstatic void mlx4_en_linkstate(struct mlx4_en_priv *priv)\n{\n\tstruct mlx4_en_port_state *port_state = &priv->port_state;\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct net_device *dev = priv->dev;\n\tbool up;\n\n\tif (mlx4_en_QUERY_PORT(mdev, priv->port))\n\t\tport_state->link_state = MLX4_PORT_STATE_DEV_EVENT_PORT_DOWN;\n\n\tup = port_state->link_state == MLX4_PORT_STATE_DEV_EVENT_PORT_UP;\n\tif (up == netif_carrier_ok(dev))\n\t\tnetif_carrier_event(dev);\n\tif (!up) {\n\t\ten_info(priv, \"Link Down\\n\");\n\t\tnetif_carrier_off(dev);\n\t} else {\n\t\ten_info(priv, \"Link Up\\n\");\n\t\tnetif_carrier_on(dev);\n\t}\n}\n\nstatic void mlx4_en_linkstate_work(struct work_struct *work)\n{\n\tstruct mlx4_en_priv *priv = container_of(work, struct mlx4_en_priv,\n\t\t\t\t\t\t linkstate_task);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\n\tmutex_lock(&mdev->state_lock);\n\tmlx4_en_linkstate(priv);\n\tmutex_unlock(&mdev->state_lock);\n}\n\nstatic int mlx4_en_init_affinity_hint(struct mlx4_en_priv *priv, int ring_idx)\n{\n\tstruct mlx4_en_rx_ring *ring = priv->rx_ring[ring_idx];\n\tint numa_node = priv->mdev->dev->numa_node;\n\n\tif (!zalloc_cpumask_var(&ring->affinity_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpumask_set_cpu(cpumask_local_spread(ring_idx, numa_node),\n\t\t\tring->affinity_mask);\n\treturn 0;\n}\n\nstatic void mlx4_en_free_affinity_hint(struct mlx4_en_priv *priv, int ring_idx)\n{\n\tfree_cpumask_var(priv->rx_ring[ring_idx]->affinity_mask);\n}\n\nstatic void mlx4_en_init_recycle_ring(struct mlx4_en_priv *priv,\n\t\t\t\t      int tx_ring_idx)\n{\n\tstruct mlx4_en_tx_ring *tx_ring = priv->tx_ring[TX_XDP][tx_ring_idx];\n\tint rr_index = tx_ring_idx;\n\n\ttx_ring->free_tx_desc = mlx4_en_recycle_tx_desc;\n\ttx_ring->recycle_ring = priv->rx_ring[rr_index];\n\ten_dbg(DRV, priv, \"Set tx_ring[%d][%d]->recycle_ring = rx_ring[%d]\\n\",\n\t       TX_XDP, tx_ring_idx, rr_index);\n}\n\nint mlx4_en_start_port(struct net_device *dev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_en_cq *cq;\n\tstruct mlx4_en_tx_ring *tx_ring;\n\tint rx_index = 0;\n\tint err = 0;\n\tint i, t;\n\tint j;\n\tu8 mc_list[16] = {0};\n\n\tif (priv->port_up) {\n\t\ten_dbg(DRV, priv, \"start port called while port already up\\n\");\n\t\treturn 0;\n\t}\n\n\tINIT_LIST_HEAD(&priv->mc_list);\n\tINIT_LIST_HEAD(&priv->curr_list);\n\tINIT_LIST_HEAD(&priv->ethtool_list);\n\tmemset(&priv->ethtool_rules[0], 0,\n\t       sizeof(struct ethtool_flow_id) * MAX_NUM_OF_FS_RULES);\n\n\t \n\tdev->mtu = min(dev->mtu, priv->max_mtu);\n\tmlx4_en_calc_rx_buf(dev);\n\ten_dbg(DRV, priv, \"Rx buf size:%d\\n\", priv->rx_skb_size);\n\n\t \n\terr = mlx4_en_activate_rx_rings(priv);\n\tif (err) {\n\t\ten_err(priv, \"Failed to activate RX rings\\n\");\n\t\treturn err;\n\t}\n\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\tcq = priv->rx_cq[i];\n\n\t\terr = mlx4_en_init_affinity_hint(priv, i);\n\t\tif (err) {\n\t\t\ten_err(priv, \"Failed preparing IRQ affinity hint\\n\");\n\t\t\tgoto cq_err;\n\t\t}\n\n\t\terr = mlx4_en_activate_cq(priv, cq, i);\n\t\tif (err) {\n\t\t\ten_err(priv, \"Failed activating Rx CQ\\n\");\n\t\t\tmlx4_en_free_affinity_hint(priv, i);\n\t\t\tgoto cq_err;\n\t\t}\n\n\t\tfor (j = 0; j < cq->size; j++) {\n\t\t\tstruct mlx4_cqe *cqe = NULL;\n\n\t\t\tcqe = mlx4_en_get_cqe(cq->buf, j, priv->cqe_size) +\n\t\t\t      priv->cqe_factor;\n\t\t\tcqe->owner_sr_opcode = MLX4_CQE_OWNER_MASK;\n\t\t}\n\n\t\terr = mlx4_en_set_cq_moder(priv, cq);\n\t\tif (err) {\n\t\t\ten_err(priv, \"Failed setting cq moderation parameters\\n\");\n\t\t\tmlx4_en_deactivate_cq(priv, cq);\n\t\t\tmlx4_en_free_affinity_hint(priv, i);\n\t\t\tgoto cq_err;\n\t\t}\n\t\tmlx4_en_arm_cq(priv, cq);\n\t\tpriv->rx_ring[i]->cqn = cq->mcq.cqn;\n\t\t++rx_index;\n\t}\n\n\t \n\ten_dbg(DRV, priv, \"Getting qp number for port %d\\n\", priv->port);\n\terr = mlx4_en_get_qp(priv);\n\tif (err) {\n\t\ten_err(priv, \"Failed getting eth qp\\n\");\n\t\tgoto cq_err;\n\t}\n\tmdev->mac_removed[priv->port] = 0;\n\n\tpriv->counter_index =\n\t\t\tmlx4_get_default_counter_index(mdev->dev, priv->port);\n\n\terr = mlx4_en_config_rss_steer(priv);\n\tif (err) {\n\t\ten_err(priv, \"Failed configuring rss steering\\n\");\n\t\tgoto mac_err;\n\t}\n\n\terr = mlx4_en_create_drop_qp(priv);\n\tif (err)\n\t\tgoto rss_err;\n\n\t \n\tfor (t = 0 ; t < MLX4_EN_NUM_TX_TYPES; t++) {\n\t\tu8 num_tx_rings_p_up = t == TX ?\n\t\t\tpriv->num_tx_rings_p_up : priv->tx_ring_num[t];\n\n\t\tfor (i = 0; i < priv->tx_ring_num[t]; i++) {\n\t\t\t \n\t\t\tcq = priv->tx_cq[t][i];\n\t\t\terr = mlx4_en_activate_cq(priv, cq, i);\n\t\t\tif (err) {\n\t\t\t\ten_err(priv, \"Failed allocating Tx CQ\\n\");\n\t\t\t\tgoto tx_err;\n\t\t\t}\n\t\t\terr = mlx4_en_set_cq_moder(priv, cq);\n\t\t\tif (err) {\n\t\t\t\ten_err(priv, \"Failed setting cq moderation parameters\\n\");\n\t\t\t\tmlx4_en_deactivate_cq(priv, cq);\n\t\t\t\tgoto tx_err;\n\t\t\t}\n\t\t\ten_dbg(DRV, priv,\n\t\t\t       \"Resetting index of collapsed CQ:%d to -1\\n\", i);\n\t\t\tcq->buf->wqe_index = cpu_to_be16(0xffff);\n\n\t\t\t \n\t\t\ttx_ring = priv->tx_ring[t][i];\n\t\t\terr = mlx4_en_activate_tx_ring(priv, tx_ring,\n\t\t\t\t\t\t       cq->mcq.cqn,\n\t\t\t\t\t\t       i / num_tx_rings_p_up);\n\t\t\tif (err) {\n\t\t\t\ten_err(priv, \"Failed allocating Tx ring\\n\");\n\t\t\t\tmlx4_en_deactivate_cq(priv, cq);\n\t\t\t\tgoto tx_err;\n\t\t\t}\n\t\t\tclear_bit(MLX4_EN_TX_RING_STATE_RECOVERING, &tx_ring->state);\n\t\t\tif (t != TX_XDP) {\n\t\t\t\ttx_ring->tx_queue = netdev_get_tx_queue(dev, i);\n\t\t\t\ttx_ring->recycle_ring = NULL;\n\n\t\t\t\t \n\t\t\t\tmlx4_en_arm_cq(priv, cq);\n\n\t\t\t} else {\n\t\t\t\tmlx4_en_init_tx_xdp_ring_descs(priv, tx_ring);\n\t\t\t\tmlx4_en_init_recycle_ring(priv, i);\n\t\t\t\t \n\t\t\t}\n\n\t\t\t \n\t\t\tfor (j = 0; j < tx_ring->buf_size; j += STAMP_STRIDE)\n\t\t\t\t*((u32 *)(tx_ring->buf + j)) = 0xffffffff;\n\t\t}\n\t}\n\n\t \n\terr = mlx4_SET_PORT_general(mdev->dev, priv->port,\n\t\t\t\t    priv->rx_skb_size + ETH_FCS_LEN,\n\t\t\t\t    priv->prof->tx_pause,\n\t\t\t\t    priv->prof->tx_ppp,\n\t\t\t\t    priv->prof->rx_pause,\n\t\t\t\t    priv->prof->rx_ppp);\n\tif (err) {\n\t\ten_err(priv, \"Failed setting port general configurations for port %d, with error %d\\n\",\n\t\t       priv->port, err);\n\t\tgoto tx_err;\n\t}\n\n\terr = mlx4_SET_PORT_user_mtu(mdev->dev, priv->port, dev->mtu);\n\tif (err) {\n\t\ten_err(priv, \"Failed to pass user MTU(%d) to Firmware for port %d, with error %d\\n\",\n\t\t       dev->mtu, priv->port, err);\n\t\tgoto tx_err;\n\t}\n\n\t \n\terr = mlx4_SET_PORT_qpn_calc(mdev->dev, priv->port, priv->base_qpn, 0);\n\tif (err) {\n\t\ten_err(priv, \"Failed setting default qp numbers\\n\");\n\t\tgoto tx_err;\n\t}\n\n\tif (mdev->dev->caps.tunnel_offload_mode == MLX4_TUNNEL_OFFLOAD_MODE_VXLAN) {\n\t\terr = mlx4_SET_PORT_VXLAN(mdev->dev, priv->port, VXLAN_STEER_BY_OUTER_MAC, 1);\n\t\tif (err) {\n\t\t\ten_err(priv, \"Failed setting port L2 tunnel configuration, err %d\\n\",\n\t\t\t       err);\n\t\t\tgoto tx_err;\n\t\t}\n\t}\n\n\t \n\ten_dbg(HW, priv, \"Initializing port\\n\");\n\terr = mlx4_INIT_PORT(mdev->dev, priv->port);\n\tif (err) {\n\t\ten_err(priv, \"Failed Initializing port\\n\");\n\t\tgoto tx_err;\n\t}\n\n\t \n\tif (mdev->dev->caps.steering_mode != MLX4_STEERING_MODE_A0 &&\n\t    mlx4_en_set_rss_steer_rules(priv))\n\t\tmlx4_warn(mdev, \"Failed setting steering rules\\n\");\n\n\t \n\teth_broadcast_addr(&mc_list[10]);\n\tmc_list[5] = priv->port;  \n\tif (mlx4_multicast_attach(mdev->dev, priv->rss_map.indir_qp, mc_list,\n\t\t\t\t  priv->port, 0, MLX4_PROT_ETH,\n\t\t\t\t  &priv->broadcast_id))\n\t\tmlx4_warn(mdev, \"Failed Attaching Broadcast\\n\");\n\n\t \n\tpriv->flags &= ~(MLX4_EN_FLAG_PROMISC | MLX4_EN_FLAG_MC_PROMISC);\n\n\t \n\tqueue_work(mdev->workqueue, &priv->rx_mode_task);\n\n\tif (priv->mdev->dev->caps.tunnel_offload_mode == MLX4_TUNNEL_OFFLOAD_MODE_VXLAN)\n\t\tudp_tunnel_nic_reset_ntf(dev);\n\n\tpriv->port_up = true;\n\n\t \n\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\tlocal_bh_disable();\n\t\tnapi_schedule(&priv->rx_cq[i]->napi);\n\t\tlocal_bh_enable();\n\t}\n\n\tclear_bit(MLX4_EN_STATE_FLAG_RESTARTING, &priv->state);\n\tnetif_tx_start_all_queues(dev);\n\tnetif_device_attach(dev);\n\n\treturn 0;\n\ntx_err:\n\tif (t == MLX4_EN_NUM_TX_TYPES) {\n\t\tt--;\n\t\ti = priv->tx_ring_num[t];\n\t}\n\twhile (t >= 0) {\n\t\twhile (i--) {\n\t\t\tmlx4_en_deactivate_tx_ring(priv, priv->tx_ring[t][i]);\n\t\t\tmlx4_en_deactivate_cq(priv, priv->tx_cq[t][i]);\n\t\t}\n\t\tif (!t--)\n\t\t\tbreak;\n\t\ti = priv->tx_ring_num[t];\n\t}\n\tmlx4_en_destroy_drop_qp(priv);\nrss_err:\n\tmlx4_en_release_rss_steer(priv);\nmac_err:\n\tmlx4_en_put_qp(priv);\ncq_err:\n\twhile (rx_index--) {\n\t\tmlx4_en_deactivate_cq(priv, priv->rx_cq[rx_index]);\n\t\tmlx4_en_free_affinity_hint(priv, rx_index);\n\t}\n\tfor (i = 0; i < priv->rx_ring_num; i++)\n\t\tmlx4_en_deactivate_rx_ring(priv, priv->rx_ring[i]);\n\n\treturn err;  \n}\n\n\nvoid mlx4_en_stop_port(struct net_device *dev, int detach)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_en_mc_list *mclist, *tmp;\n\tstruct ethtool_flow_id *flow, *tmp_flow;\n\tint i, t;\n\tu8 mc_list[16] = {0};\n\n\tif (!priv->port_up) {\n\t\ten_dbg(DRV, priv, \"stop port called while port already down\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmlx4_CLOSE_PORT(mdev->dev, priv->port);\n\n\t \n\tnetif_tx_lock_bh(dev);\n\tif (detach)\n\t\tnetif_device_detach(dev);\n\tnetif_tx_stop_all_queues(dev);\n\tnetif_tx_unlock_bh(dev);\n\n\tnetif_tx_disable(dev);\n\n\tspin_lock_bh(&priv->stats_lock);\n\tmlx4_en_fold_software_stats(dev);\n\t \n\tpriv->port_up = false;\n\tspin_unlock_bh(&priv->stats_lock);\n\n\tpriv->counter_index = MLX4_SINK_COUNTER_INDEX(mdev->dev);\n\n\t \n\tif (mdev->dev->caps.steering_mode ==\n\t    MLX4_STEERING_MODE_DEVICE_MANAGED) {\n\t\tpriv->flags &= ~(MLX4_EN_FLAG_PROMISC |\n\t\t\t\t MLX4_EN_FLAG_MC_PROMISC);\n\t\tmlx4_flow_steer_promisc_remove(mdev->dev,\n\t\t\t\t\t       priv->port,\n\t\t\t\t\t       MLX4_FS_ALL_DEFAULT);\n\t\tmlx4_flow_steer_promisc_remove(mdev->dev,\n\t\t\t\t\t       priv->port,\n\t\t\t\t\t       MLX4_FS_MC_DEFAULT);\n\t} else if (priv->flags & MLX4_EN_FLAG_PROMISC) {\n\t\tpriv->flags &= ~MLX4_EN_FLAG_PROMISC;\n\n\t\t \n\t\tmlx4_unicast_promisc_remove(mdev->dev, priv->base_qpn,\n\t\t\t\t\t    priv->port);\n\n\t\t \n\t\tif (priv->flags & MLX4_EN_FLAG_MC_PROMISC) {\n\t\t\tmlx4_multicast_promisc_remove(mdev->dev, priv->base_qpn,\n\t\t\t\t\t\t      priv->port);\n\t\t\tpriv->flags &= ~MLX4_EN_FLAG_MC_PROMISC;\n\t\t}\n\t}\n\n\t \n\teth_broadcast_addr(&mc_list[10]);\n\tmc_list[5] = priv->port;  \n\tmlx4_multicast_detach(mdev->dev, priv->rss_map.indir_qp, mc_list,\n\t\t\t      MLX4_PROT_ETH, priv->broadcast_id);\n\tlist_for_each_entry(mclist, &priv->curr_list, list) {\n\t\tmemcpy(&mc_list[10], mclist->addr, ETH_ALEN);\n\t\tmc_list[5] = priv->port;\n\t\tmlx4_multicast_detach(mdev->dev, priv->rss_map.indir_qp,\n\t\t\t\t      mc_list, MLX4_PROT_ETH, mclist->reg_id);\n\t\tif (mclist->tunnel_reg_id)\n\t\t\tmlx4_flow_detach(mdev->dev, mclist->tunnel_reg_id);\n\t}\n\tmlx4_en_clear_list(dev);\n\tlist_for_each_entry_safe(mclist, tmp, &priv->curr_list, list) {\n\t\tlist_del(&mclist->list);\n\t\tkfree(mclist);\n\t}\n\n\t \n\tmlx4_SET_MCAST_FLTR(mdev->dev, priv->port, 0, 1, MLX4_MCAST_CONFIG);\n\n\t \n\tif (mdev->dev->caps.steering_mode ==\n\t    MLX4_STEERING_MODE_DEVICE_MANAGED) {\n\t\tASSERT_RTNL();\n\t\tlist_for_each_entry_safe(flow, tmp_flow,\n\t\t\t\t\t &priv->ethtool_list, list) {\n\t\t\tmlx4_flow_detach(mdev->dev, flow->id);\n\t\t\tlist_del(&flow->list);\n\t\t}\n\t}\n\n\tmlx4_en_destroy_drop_qp(priv);\n\n\t \n\tfor (t = 0; t < MLX4_EN_NUM_TX_TYPES; t++) {\n\t\tfor (i = 0; i < priv->tx_ring_num[t]; i++) {\n\t\t\tmlx4_en_deactivate_tx_ring(priv, priv->tx_ring[t][i]);\n\t\t\tmlx4_en_deactivate_cq(priv, priv->tx_cq[t][i]);\n\t\t}\n\t}\n\tmsleep(10);\n\n\tfor (t = 0; t < MLX4_EN_NUM_TX_TYPES; t++)\n\t\tfor (i = 0; i < priv->tx_ring_num[t]; i++)\n\t\t\tmlx4_en_free_tx_buf(dev, priv->tx_ring[t][i]);\n\n\tif (mdev->dev->caps.steering_mode != MLX4_STEERING_MODE_A0)\n\t\tmlx4_en_delete_rss_steer_rules(priv);\n\n\t \n\tmlx4_en_release_rss_steer(priv);\n\n\t \n\tmlx4_en_put_qp(priv);\n\tif (!(mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_REASSIGN_MAC_EN))\n\t\tmdev->mac_removed[priv->port] = 1;\n\n\t \n\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\tstruct mlx4_en_cq *cq = priv->rx_cq[i];\n\n\t\tnapi_synchronize(&cq->napi);\n\t\tmlx4_en_deactivate_rx_ring(priv, priv->rx_ring[i]);\n\t\tmlx4_en_deactivate_cq(priv, cq);\n\n\t\tmlx4_en_free_affinity_hint(priv, i);\n\t}\n}\n\nstatic void mlx4_en_restart(struct work_struct *work)\n{\n\tstruct mlx4_en_priv *priv = container_of(work, struct mlx4_en_priv,\n\t\t\t\t\t\t restart_task);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct net_device *dev = priv->dev;\n\n\ten_dbg(DRV, priv, \"Watchdog task called for port %d\\n\", priv->port);\n\n\trtnl_lock();\n\tmutex_lock(&mdev->state_lock);\n\tif (priv->port_up) {\n\t\tmlx4_en_stop_port(dev, 1);\n\t\tif (mlx4_en_start_port(dev))\n\t\t\ten_err(priv, \"Failed restarting port %d\\n\", priv->port);\n\t}\n\tmutex_unlock(&mdev->state_lock);\n\trtnl_unlock();\n}\n\nstatic void mlx4_en_clear_stats(struct net_device *dev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_en_tx_ring **tx_ring;\n\tint i;\n\n\tif (!mlx4_is_slave(mdev->dev))\n\t\tif (mlx4_en_DUMP_ETH_STATS(mdev, priv->port, 1))\n\t\t\ten_dbg(HW, priv, \"Failed dumping statistics\\n\");\n\n\tmemset(&priv->pkstats, 0, sizeof(priv->pkstats));\n\tmemset(&priv->port_stats, 0, sizeof(priv->port_stats));\n\tmemset(&priv->rx_flowstats, 0, sizeof(priv->rx_flowstats));\n\tmemset(&priv->tx_flowstats, 0, sizeof(priv->tx_flowstats));\n\tmemset(&priv->rx_priority_flowstats, 0,\n\t       sizeof(priv->rx_priority_flowstats));\n\tmemset(&priv->tx_priority_flowstats, 0,\n\t       sizeof(priv->tx_priority_flowstats));\n\tmemset(&priv->pf_stats, 0, sizeof(priv->pf_stats));\n\n\ttx_ring = priv->tx_ring[TX];\n\tfor (i = 0; i < priv->tx_ring_num[TX]; i++) {\n\t\ttx_ring[i]->bytes = 0;\n\t\ttx_ring[i]->packets = 0;\n\t\ttx_ring[i]->tx_csum = 0;\n\t\ttx_ring[i]->tx_dropped = 0;\n\t\ttx_ring[i]->queue_stopped = 0;\n\t\ttx_ring[i]->wake_queue = 0;\n\t\ttx_ring[i]->tso_packets = 0;\n\t\ttx_ring[i]->xmit_more = 0;\n\t}\n\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\tpriv->rx_ring[i]->bytes = 0;\n\t\tpriv->rx_ring[i]->packets = 0;\n\t\tpriv->rx_ring[i]->csum_ok = 0;\n\t\tpriv->rx_ring[i]->csum_none = 0;\n\t\tpriv->rx_ring[i]->csum_complete = 0;\n\t}\n}\n\nstatic int mlx4_en_open(struct net_device *dev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint err = 0;\n\n\tmutex_lock(&mdev->state_lock);\n\n\tif (!mdev->device_up) {\n\t\ten_err(priv, \"Cannot open - device down/disabled\\n\");\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tmlx4_en_clear_stats(dev);\n\n\terr = mlx4_en_start_port(dev);\n\tif (err) {\n\t\ten_err(priv, \"Failed starting port:%d\\n\", priv->port);\n\t\tgoto out;\n\t}\n\tmlx4_en_linkstate(priv);\nout:\n\tmutex_unlock(&mdev->state_lock);\n\treturn err;\n}\n\n\nstatic int mlx4_en_close(struct net_device *dev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\n\ten_dbg(IFDOWN, priv, \"Close port called\\n\");\n\n\tmutex_lock(&mdev->state_lock);\n\n\tmlx4_en_stop_port(dev, 0);\n\tnetif_carrier_off(dev);\n\n\tmutex_unlock(&mdev->state_lock);\n\treturn 0;\n}\n\nstatic void mlx4_en_free_resources(struct mlx4_en_priv *priv)\n{\n\tint i, t;\n\n#ifdef CONFIG_RFS_ACCEL\n\tpriv->dev->rx_cpu_rmap = NULL;\n#endif\n\n\tfor (t = 0; t < MLX4_EN_NUM_TX_TYPES; t++) {\n\t\tfor (i = 0; i < priv->tx_ring_num[t]; i++) {\n\t\t\tif (priv->tx_ring[t] && priv->tx_ring[t][i])\n\t\t\t\tmlx4_en_destroy_tx_ring(priv,\n\t\t\t\t\t\t\t&priv->tx_ring[t][i]);\n\t\t\tif (priv->tx_cq[t] && priv->tx_cq[t][i])\n\t\t\t\tmlx4_en_destroy_cq(priv, &priv->tx_cq[t][i]);\n\t\t}\n\t\tkfree(priv->tx_ring[t]);\n\t\tkfree(priv->tx_cq[t]);\n\t}\n\n\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\tif (priv->rx_ring[i])\n\t\t\tmlx4_en_destroy_rx_ring(priv, &priv->rx_ring[i],\n\t\t\t\tpriv->prof->rx_ring_size, priv->stride);\n\t\tif (priv->rx_cq[i])\n\t\t\tmlx4_en_destroy_cq(priv, &priv->rx_cq[i]);\n\t}\n\n}\n\nstatic int mlx4_en_alloc_resources(struct mlx4_en_priv *priv)\n{\n\tstruct mlx4_en_port_profile *prof = priv->prof;\n\tint i, t;\n\tint node;\n\n\t \n\tfor (t = 0; t < MLX4_EN_NUM_TX_TYPES; t++) {\n\t\tfor (i = 0; i < priv->tx_ring_num[t]; i++) {\n\t\t\tnode = cpu_to_node(i % num_online_cpus());\n\t\t\tif (mlx4_en_create_cq(priv, &priv->tx_cq[t][i],\n\t\t\t\t\t      prof->tx_ring_size, i, t, node))\n\t\t\t\tgoto err;\n\n\t\t\tif (mlx4_en_create_tx_ring(priv, &priv->tx_ring[t][i],\n\t\t\t\t\t\t   prof->tx_ring_size,\n\t\t\t\t\t\t   TXBB_SIZE, node, i))\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\tnode = cpu_to_node(i % num_online_cpus());\n\t\tif (mlx4_en_create_cq(priv, &priv->rx_cq[i],\n\t\t\t\t      prof->rx_ring_size, i, RX, node))\n\t\t\tgoto err;\n\n\t\tif (mlx4_en_create_rx_ring(priv, &priv->rx_ring[i],\n\t\t\t\t\t   prof->rx_ring_size, priv->stride,\n\t\t\t\t\t   node, i))\n\t\t\tgoto err;\n\n\t}\n\n#ifdef CONFIG_RFS_ACCEL\n\tpriv->dev->rx_cpu_rmap = mlx4_get_cpu_rmap(priv->mdev->dev, priv->port);\n#endif\n\n\treturn 0;\n\nerr:\n\ten_err(priv, \"Failed to allocate NIC resources\\n\");\n\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\tif (priv->rx_ring[i])\n\t\t\tmlx4_en_destroy_rx_ring(priv, &priv->rx_ring[i],\n\t\t\t\t\t\tprof->rx_ring_size,\n\t\t\t\t\t\tpriv->stride);\n\t\tif (priv->rx_cq[i])\n\t\t\tmlx4_en_destroy_cq(priv, &priv->rx_cq[i]);\n\t}\n\tfor (t = 0; t < MLX4_EN_NUM_TX_TYPES; t++) {\n\t\tfor (i = 0; i < priv->tx_ring_num[t]; i++) {\n\t\t\tif (priv->tx_ring[t][i])\n\t\t\t\tmlx4_en_destroy_tx_ring(priv,\n\t\t\t\t\t\t\t&priv->tx_ring[t][i]);\n\t\t\tif (priv->tx_cq[t][i])\n\t\t\t\tmlx4_en_destroy_cq(priv, &priv->tx_cq[t][i]);\n\t\t}\n\t}\n\treturn -ENOMEM;\n}\n\n\nstatic int mlx4_en_copy_priv(struct mlx4_en_priv *dst,\n\t\t\t     struct mlx4_en_priv *src,\n\t\t\t     struct mlx4_en_port_profile *prof)\n{\n\tint t;\n\n\tmemcpy(&dst->hwtstamp_config, &prof->hwtstamp_config,\n\t       sizeof(dst->hwtstamp_config));\n\tdst->num_tx_rings_p_up = prof->num_tx_rings_p_up;\n\tdst->rx_ring_num = prof->rx_ring_num;\n\tdst->flags = prof->flags;\n\tdst->mdev = src->mdev;\n\tdst->port = src->port;\n\tdst->dev = src->dev;\n\tdst->prof = prof;\n\tdst->stride = roundup_pow_of_two(sizeof(struct mlx4_en_rx_desc) +\n\t\t\t\t\t DS_SIZE * MLX4_EN_MAX_RX_FRAGS);\n\n\tfor (t = 0; t < MLX4_EN_NUM_TX_TYPES; t++) {\n\t\tdst->tx_ring_num[t] = prof->tx_ring_num[t];\n\t\tif (!dst->tx_ring_num[t])\n\t\t\tcontinue;\n\n\t\tdst->tx_ring[t] = kcalloc(MAX_TX_RINGS,\n\t\t\t\t\t  sizeof(struct mlx4_en_tx_ring *),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!dst->tx_ring[t])\n\t\t\tgoto err_free_tx;\n\n\t\tdst->tx_cq[t] = kcalloc(MAX_TX_RINGS,\n\t\t\t\t\tsizeof(struct mlx4_en_cq *),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!dst->tx_cq[t]) {\n\t\t\tkfree(dst->tx_ring[t]);\n\t\t\tgoto err_free_tx;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_free_tx:\n\twhile (t--) {\n\t\tkfree(dst->tx_ring[t]);\n\t\tkfree(dst->tx_cq[t]);\n\t}\n\treturn -ENOMEM;\n}\n\nstatic void mlx4_en_update_priv(struct mlx4_en_priv *dst,\n\t\t\t\tstruct mlx4_en_priv *src)\n{\n\tint t;\n\tmemcpy(dst->rx_ring, src->rx_ring,\n\t       sizeof(struct mlx4_en_rx_ring *) * src->rx_ring_num);\n\tmemcpy(dst->rx_cq, src->rx_cq,\n\t       sizeof(struct mlx4_en_cq *) * src->rx_ring_num);\n\tmemcpy(&dst->hwtstamp_config, &src->hwtstamp_config,\n\t       sizeof(dst->hwtstamp_config));\n\tfor (t = 0; t < MLX4_EN_NUM_TX_TYPES; t++) {\n\t\tdst->tx_ring_num[t] = src->tx_ring_num[t];\n\t\tdst->tx_ring[t] = src->tx_ring[t];\n\t\tdst->tx_cq[t] = src->tx_cq[t];\n\t}\n\tdst->num_tx_rings_p_up = src->num_tx_rings_p_up;\n\tdst->rx_ring_num = src->rx_ring_num;\n\tmemcpy(dst->prof, src->prof, sizeof(struct mlx4_en_port_profile));\n}\n\nint mlx4_en_try_alloc_resources(struct mlx4_en_priv *priv,\n\t\t\t\tstruct mlx4_en_priv *tmp,\n\t\t\t\tstruct mlx4_en_port_profile *prof,\n\t\t\t\tbool carry_xdp_prog)\n{\n\tstruct bpf_prog *xdp_prog;\n\tint i, t, ret;\n\n\tret = mlx4_en_copy_priv(tmp, priv, prof);\n\tif (ret) {\n\t\ten_warn(priv, \"%s: mlx4_en_copy_priv() failed, return\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tif (mlx4_en_alloc_resources(tmp)) {\n\t\ten_warn(priv,\n\t\t\t\"%s: Resource allocation failed, using previous configuration\\n\",\n\t\t\t__func__);\n\t\tfor (t = 0; t < MLX4_EN_NUM_TX_TYPES; t++) {\n\t\t\tkfree(tmp->tx_ring[t]);\n\t\t\tkfree(tmp->tx_cq[t]);\n\t\t}\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\txdp_prog = rcu_dereference_protected(\n\t\tpriv->rx_ring[0]->xdp_prog,\n\t\tlockdep_is_held(&priv->mdev->state_lock));\n\n\tif (xdp_prog && carry_xdp_prog) {\n\t\tbpf_prog_add(xdp_prog, tmp->rx_ring_num);\n\t\tfor (i = 0; i < tmp->rx_ring_num; i++)\n\t\t\trcu_assign_pointer(tmp->rx_ring[i]->xdp_prog,\n\t\t\t\t\t   xdp_prog);\n\t}\n\n\treturn 0;\n}\n\nvoid mlx4_en_safe_replace_resources(struct mlx4_en_priv *priv,\n\t\t\t\t    struct mlx4_en_priv *tmp)\n{\n\tmlx4_en_free_resources(priv);\n\tmlx4_en_update_priv(priv, tmp);\n}\n\nvoid mlx4_en_destroy_netdev(struct net_device *dev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\n\ten_dbg(DRV, priv, \"Destroying netdev on port:%d\\n\", priv->port);\n\n\t \n\tif (priv->registered)\n\t\tunregister_netdev(dev);\n\n\tif (priv->allocated)\n\t\tmlx4_free_hwq_res(mdev->dev, &priv->res, MLX4_EN_PAGE_SIZE);\n\n\tcancel_delayed_work(&priv->stats_task);\n\tcancel_delayed_work(&priv->service_task);\n\t \n\tflush_workqueue(mdev->workqueue);\n\n\tif (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_TS)\n\t\tmlx4_en_remove_timestamp(mdev);\n\n\t \n\tmutex_lock(&mdev->state_lock);\n\tmdev->pndev[priv->port] = NULL;\n\tmdev->upper[priv->port] = NULL;\n\n#ifdef CONFIG_RFS_ACCEL\n\tmlx4_en_cleanup_filters(priv);\n#endif\n\n\tmlx4_en_free_resources(priv);\n\tmutex_unlock(&mdev->state_lock);\n\n\tfree_netdev(dev);\n}\n\nstatic bool mlx4_en_check_xdp_mtu(struct net_device *dev, int mtu)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\tif (mtu > MLX4_EN_MAX_XDP_MTU) {\n\t\ten_err(priv, \"mtu:%d > max:%d when XDP prog is attached\\n\",\n\t\t       mtu, MLX4_EN_MAX_XDP_MTU);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int mlx4_en_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint err = 0;\n\n\ten_dbg(DRV, priv, \"Change MTU called - current:%d new:%d\\n\",\n\t\t dev->mtu, new_mtu);\n\n\tif (priv->tx_ring_num[TX_XDP] &&\n\t    !mlx4_en_check_xdp_mtu(dev, new_mtu))\n\t\treturn -EOPNOTSUPP;\n\n\tdev->mtu = new_mtu;\n\n\tif (netif_running(dev)) {\n\t\tmutex_lock(&mdev->state_lock);\n\t\tif (!mdev->device_up) {\n\t\t\t \n\t\t\ten_dbg(DRV, priv, \"Change MTU called with card down!?\\n\");\n\t\t} else {\n\t\t\tmlx4_en_stop_port(dev, 1);\n\t\t\terr = mlx4_en_start_port(dev);\n\t\t\tif (err) {\n\t\t\t\ten_err(priv, \"Failed restarting port:%d\\n\",\n\t\t\t\t\t priv->port);\n\t\t\t\tif (!test_and_set_bit(MLX4_EN_STATE_FLAG_RESTARTING,\n\t\t\t\t\t\t      &priv->state))\n\t\t\t\t\tqueue_work(mdev->workqueue, &priv->restart_task);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&mdev->state_lock);\n\t}\n\treturn 0;\n}\n\nstatic int mlx4_en_hwtstamp_set(struct net_device *dev, struct ifreq *ifr)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct hwtstamp_config config;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\t \n\tif (!(mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_TS))\n\t\treturn -EINVAL;\n\n\t \n\tswitch (config.tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\tcase HWTSTAMP_TX_ON:\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\t \n\tswitch (config.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_ALL:\n\tcase HWTSTAMP_FILTER_SOME:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\t\tconfig.rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tif (mlx4_en_reset_config(dev, config, dev->features)) {\n\t\tconfig.tx_type = HWTSTAMP_TX_OFF;\n\t\tconfig.rx_filter = HWTSTAMP_FILTER_NONE;\n\t}\n\n\treturn copy_to_user(ifr->ifr_data, &config,\n\t\t\t    sizeof(config)) ? -EFAULT : 0;\n}\n\nstatic int mlx4_en_hwtstamp_get(struct net_device *dev, struct ifreq *ifr)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\treturn copy_to_user(ifr->ifr_data, &priv->hwtstamp_config,\n\t\t\t    sizeof(priv->hwtstamp_config)) ? -EFAULT : 0;\n}\n\nstatic int mlx4_en_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tswitch (cmd) {\n\tcase SIOCSHWTSTAMP:\n\t\treturn mlx4_en_hwtstamp_set(dev, ifr);\n\tcase SIOCGHWTSTAMP:\n\t\treturn mlx4_en_hwtstamp_get(dev, ifr);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic netdev_features_t mlx4_en_fix_features(struct net_device *netdev,\n\t\t\t\t\t      netdev_features_t features)\n{\n\tstruct mlx4_en_priv *en_priv = netdev_priv(netdev);\n\tstruct mlx4_en_dev *mdev = en_priv->mdev;\n\n\t \n\tif (features & NETIF_F_HW_VLAN_CTAG_RX &&\n\t    !(mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_SKIP_OUTER_VLAN))\n\t\tfeatures |= NETIF_F_HW_VLAN_STAG_RX;\n\telse\n\t\tfeatures &= ~NETIF_F_HW_VLAN_STAG_RX;\n\n\treturn features;\n}\n\nstatic int mlx4_en_set_features(struct net_device *netdev,\n\t\tnetdev_features_t features)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(netdev);\n\tbool reset = false;\n\tint ret = 0;\n\n\tif (DEV_FEATURE_CHANGED(netdev, features, NETIF_F_RXFCS)) {\n\t\ten_info(priv, \"Turn %s RX-FCS\\n\",\n\t\t\t(features & NETIF_F_RXFCS) ? \"ON\" : \"OFF\");\n\t\treset = true;\n\t}\n\n\tif (DEV_FEATURE_CHANGED(netdev, features, NETIF_F_RXALL)) {\n\t\tu8 ignore_fcs_value = (features & NETIF_F_RXALL) ? 1 : 0;\n\n\t\ten_info(priv, \"Turn %s RX-ALL\\n\",\n\t\t\tignore_fcs_value ? \"ON\" : \"OFF\");\n\t\tret = mlx4_SET_PORT_fcs_check(priv->mdev->dev,\n\t\t\t\t\t      priv->port, ignore_fcs_value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (DEV_FEATURE_CHANGED(netdev, features, NETIF_F_HW_VLAN_CTAG_RX)) {\n\t\ten_info(priv, \"Turn %s RX vlan strip offload\\n\",\n\t\t\t(features & NETIF_F_HW_VLAN_CTAG_RX) ? \"ON\" : \"OFF\");\n\t\treset = true;\n\t}\n\n\tif (DEV_FEATURE_CHANGED(netdev, features, NETIF_F_HW_VLAN_CTAG_TX))\n\t\ten_info(priv, \"Turn %s TX vlan strip offload\\n\",\n\t\t\t(features & NETIF_F_HW_VLAN_CTAG_TX) ? \"ON\" : \"OFF\");\n\n\tif (DEV_FEATURE_CHANGED(netdev, features, NETIF_F_HW_VLAN_STAG_TX))\n\t\ten_info(priv, \"Turn %s TX S-VLAN strip offload\\n\",\n\t\t\t(features & NETIF_F_HW_VLAN_STAG_TX) ? \"ON\" : \"OFF\");\n\n\tif (DEV_FEATURE_CHANGED(netdev, features, NETIF_F_LOOPBACK)) {\n\t\ten_info(priv, \"Turn %s loopback\\n\",\n\t\t\t(features & NETIF_F_LOOPBACK) ? \"ON\" : \"OFF\");\n\t\tmlx4_en_update_loopback_state(netdev, features);\n\t}\n\n\tif (reset) {\n\t\tret = mlx4_en_reset_config(netdev, priv->hwtstamp_config,\n\t\t\t\t\t   features);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx4_en_set_vf_mac(struct net_device *dev, int queue, u8 *mac)\n{\n\tstruct mlx4_en_priv *en_priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = en_priv->mdev;\n\n\treturn mlx4_set_vf_mac(mdev->dev, en_priv->port, queue, mac);\n}\n\nstatic int mlx4_en_set_vf_vlan(struct net_device *dev, int vf, u16 vlan, u8 qos,\n\t\t\t       __be16 vlan_proto)\n{\n\tstruct mlx4_en_priv *en_priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = en_priv->mdev;\n\n\treturn mlx4_set_vf_vlan(mdev->dev, en_priv->port, vf, vlan, qos,\n\t\t\t\tvlan_proto);\n}\n\nstatic int mlx4_en_set_vf_rate(struct net_device *dev, int vf, int min_tx_rate,\n\t\t\t       int max_tx_rate)\n{\n\tstruct mlx4_en_priv *en_priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = en_priv->mdev;\n\n\treturn mlx4_set_vf_rate(mdev->dev, en_priv->port, vf, min_tx_rate,\n\t\t\t\tmax_tx_rate);\n}\n\nstatic int mlx4_en_set_vf_spoofchk(struct net_device *dev, int vf, bool setting)\n{\n\tstruct mlx4_en_priv *en_priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = en_priv->mdev;\n\n\treturn mlx4_set_vf_spoofchk(mdev->dev, en_priv->port, vf, setting);\n}\n\nstatic int mlx4_en_get_vf_config(struct net_device *dev, int vf, struct ifla_vf_info *ivf)\n{\n\tstruct mlx4_en_priv *en_priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = en_priv->mdev;\n\n\treturn mlx4_get_vf_config(mdev->dev, en_priv->port, vf, ivf);\n}\n\nstatic int mlx4_en_set_vf_link_state(struct net_device *dev, int vf, int link_state)\n{\n\tstruct mlx4_en_priv *en_priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = en_priv->mdev;\n\n\treturn mlx4_set_vf_link_state(mdev->dev, en_priv->port, vf, link_state);\n}\n\nstatic int mlx4_en_get_vf_stats(struct net_device *dev, int vf,\n\t\t\t\tstruct ifla_vf_stats *vf_stats)\n{\n\tstruct mlx4_en_priv *en_priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = en_priv->mdev;\n\n\treturn mlx4_get_vf_stats(mdev->dev, en_priv->port, vf, vf_stats);\n}\n\n#define PORT_ID_BYTE_LEN 8\nstatic int mlx4_en_get_phys_port_id(struct net_device *dev,\n\t\t\t\t    struct netdev_phys_item_id *ppid)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_dev *mdev = priv->mdev->dev;\n\tint i;\n\tu64 phys_port_id = mdev->caps.phys_port_id[priv->port];\n\n\tif (!phys_port_id)\n\t\treturn -EOPNOTSUPP;\n\n\tppid->id_len = sizeof(phys_port_id);\n\tfor (i = PORT_ID_BYTE_LEN - 1; i >= 0; --i) {\n\t\tppid->id[i] =  phys_port_id & 0xff;\n\t\tphys_port_id >>= 8;\n\t}\n\treturn 0;\n}\n\nstatic int mlx4_udp_tunnel_sync(struct net_device *dev, unsigned int table)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct udp_tunnel_info ti;\n\tint ret;\n\n\tudp_tunnel_nic_get_port(dev, table, 0, &ti);\n\tpriv->vxlan_port = ti.port;\n\n\tret = mlx4_config_vxlan_port(priv->mdev->dev, priv->vxlan_port);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mlx4_SET_PORT_VXLAN(priv->mdev->dev, priv->port,\n\t\t\t\t   VXLAN_STEER_BY_OUTER_MAC,\n\t\t\t\t   !!priv->vxlan_port);\n}\n\nstatic const struct udp_tunnel_nic_info mlx4_udp_tunnels = {\n\t.sync_table\t= mlx4_udp_tunnel_sync,\n\t.flags\t\t= UDP_TUNNEL_NIC_INFO_MAY_SLEEP |\n\t\t\t  UDP_TUNNEL_NIC_INFO_IPV4_ONLY,\n\t.tables\t\t= {\n\t\t{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_VXLAN, },\n\t},\n};\n\nstatic netdev_features_t mlx4_en_features_check(struct sk_buff *skb,\n\t\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\t\tnetdev_features_t features)\n{\n\tfeatures = vlan_features_check(skb, features);\n\tfeatures = vxlan_features_check(skb, features);\n\n\t \n\tif (skb->encapsulation &&\n\t    (skb->ip_summed == CHECKSUM_PARTIAL)) {\n\t\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\t\tif (!priv->vxlan_port ||\n\t\t    (ip_hdr(skb)->version != 4) ||\n\t\t    (udp_hdr(skb)->dest != priv->vxlan_port))\n\t\t\tfeatures &= ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n\t}\n\n\treturn features;\n}\n\nstatic int mlx4_en_set_tx_maxrate(struct net_device *dev, int queue_index, u32 maxrate)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_tx_ring *tx_ring = priv->tx_ring[TX][queue_index];\n\tstruct mlx4_update_qp_params params;\n\tint err;\n\n\tif (!(priv->mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_QP_RATE_LIMIT))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (maxrate >> 12) {\n\t\tparams.rate_unit = MLX4_QP_RATE_LIMIT_GBS;\n\t\tparams.rate_val  = maxrate / 1000;\n\t} else if (maxrate) {\n\t\tparams.rate_unit = MLX4_QP_RATE_LIMIT_MBS;\n\t\tparams.rate_val  = maxrate;\n\t} else {  \n\t\tparams.rate_unit = 0;\n\t\tparams.rate_val  = 0;\n\t}\n\n\terr = mlx4_update_qp(priv->mdev->dev, tx_ring->qpn, MLX4_UPDATE_QP_RATE_LIMIT,\n\t\t\t     &params);\n\treturn err;\n}\n\nstatic int mlx4_xdp_set(struct net_device *dev, struct bpf_prog *prog)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_en_port_profile new_prof;\n\tstruct bpf_prog *old_prog;\n\tstruct mlx4_en_priv *tmp;\n\tint tx_changed = 0;\n\tint xdp_ring_num;\n\tint port_up = 0;\n\tint err;\n\tint i;\n\n\txdp_ring_num = prog ? priv->rx_ring_num : 0;\n\n\t \n\tif (priv->tx_ring_num[TX_XDP] == xdp_ring_num) {\n\t\tif (prog)\n\t\t\tbpf_prog_add(prog, priv->rx_ring_num - 1);\n\n\t\tmutex_lock(&mdev->state_lock);\n\t\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\t\told_prog = rcu_dereference_protected(\n\t\t\t\t\tpriv->rx_ring[i]->xdp_prog,\n\t\t\t\t\tlockdep_is_held(&mdev->state_lock));\n\t\t\trcu_assign_pointer(priv->rx_ring[i]->xdp_prog, prog);\n\t\t\tif (old_prog)\n\t\t\t\tbpf_prog_put(old_prog);\n\t\t}\n\t\tmutex_unlock(&mdev->state_lock);\n\t\treturn 0;\n\t}\n\n\tif (!mlx4_en_check_xdp_mtu(dev, dev->mtu))\n\t\treturn -EOPNOTSUPP;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tif (prog)\n\t\tbpf_prog_add(prog, priv->rx_ring_num - 1);\n\n\tmutex_lock(&mdev->state_lock);\n\tmemcpy(&new_prof, priv->prof, sizeof(struct mlx4_en_port_profile));\n\tnew_prof.tx_ring_num[TX_XDP] = xdp_ring_num;\n\n\tif (priv->tx_ring_num[TX] + xdp_ring_num > MAX_TX_RINGS) {\n\t\ttx_changed = 1;\n\t\tnew_prof.tx_ring_num[TX] =\n\t\t\tMAX_TX_RINGS - ALIGN(xdp_ring_num, priv->prof->num_up);\n\t\ten_warn(priv, \"Reducing the number of TX rings, to not exceed the max total rings number.\\n\");\n\t}\n\n\terr = mlx4_en_try_alloc_resources(priv, tmp, &new_prof, false);\n\tif (err) {\n\t\tif (prog)\n\t\t\tbpf_prog_sub(prog, priv->rx_ring_num - 1);\n\t\tgoto unlock_out;\n\t}\n\n\tif (priv->port_up) {\n\t\tport_up = 1;\n\t\tmlx4_en_stop_port(dev, 1);\n\t}\n\n\tmlx4_en_safe_replace_resources(priv, tmp);\n\tif (tx_changed)\n\t\tnetif_set_real_num_tx_queues(dev, priv->tx_ring_num[TX]);\n\n\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\told_prog = rcu_dereference_protected(\n\t\t\t\t\tpriv->rx_ring[i]->xdp_prog,\n\t\t\t\t\tlockdep_is_held(&mdev->state_lock));\n\t\trcu_assign_pointer(priv->rx_ring[i]->xdp_prog, prog);\n\t\tif (old_prog)\n\t\t\tbpf_prog_put(old_prog);\n\t}\n\n\tif (port_up) {\n\t\terr = mlx4_en_start_port(dev);\n\t\tif (err) {\n\t\t\ten_err(priv, \"Failed starting port %d for XDP change\\n\",\n\t\t\t       priv->port);\n\t\t\tif (!test_and_set_bit(MLX4_EN_STATE_FLAG_RESTARTING, &priv->state))\n\t\t\t\tqueue_work(mdev->workqueue, &priv->restart_task);\n\t\t}\n\t}\n\nunlock_out:\n\tmutex_unlock(&mdev->state_lock);\n\tkfree(tmp);\n\treturn err;\n}\n\nstatic int mlx4_xdp(struct net_device *dev, struct netdev_bpf *xdp)\n{\n\tswitch (xdp->command) {\n\tcase XDP_SETUP_PROG:\n\t\treturn mlx4_xdp_set(dev, xdp->prog);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct net_device_ops mlx4_netdev_ops = {\n\t.ndo_open\t\t= mlx4_en_open,\n\t.ndo_stop\t\t= mlx4_en_close,\n\t.ndo_start_xmit\t\t= mlx4_en_xmit,\n\t.ndo_select_queue\t= mlx4_en_select_queue,\n\t.ndo_get_stats64\t= mlx4_en_get_stats64,\n\t.ndo_set_rx_mode\t= mlx4_en_set_rx_mode,\n\t.ndo_set_mac_address\t= mlx4_en_set_mac,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_change_mtu\t\t= mlx4_en_change_mtu,\n\t.ndo_eth_ioctl\t\t= mlx4_en_ioctl,\n\t.ndo_tx_timeout\t\t= mlx4_en_tx_timeout,\n\t.ndo_vlan_rx_add_vid\t= mlx4_en_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= mlx4_en_vlan_rx_kill_vid,\n\t.ndo_set_features\t= mlx4_en_set_features,\n\t.ndo_fix_features\t= mlx4_en_fix_features,\n\t.ndo_setup_tc\t\t= __mlx4_en_setup_tc,\n#ifdef CONFIG_RFS_ACCEL\n\t.ndo_rx_flow_steer\t= mlx4_en_filter_rfs,\n#endif\n\t.ndo_get_phys_port_id\t= mlx4_en_get_phys_port_id,\n\t.ndo_features_check\t= mlx4_en_features_check,\n\t.ndo_set_tx_maxrate\t= mlx4_en_set_tx_maxrate,\n\t.ndo_bpf\t\t= mlx4_xdp,\n};\n\nstatic const struct net_device_ops mlx4_netdev_ops_master = {\n\t.ndo_open\t\t= mlx4_en_open,\n\t.ndo_stop\t\t= mlx4_en_close,\n\t.ndo_start_xmit\t\t= mlx4_en_xmit,\n\t.ndo_select_queue\t= mlx4_en_select_queue,\n\t.ndo_get_stats64\t= mlx4_en_get_stats64,\n\t.ndo_set_rx_mode\t= mlx4_en_set_rx_mode,\n\t.ndo_set_mac_address\t= mlx4_en_set_mac,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_change_mtu\t\t= mlx4_en_change_mtu,\n\t.ndo_tx_timeout\t\t= mlx4_en_tx_timeout,\n\t.ndo_vlan_rx_add_vid\t= mlx4_en_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= mlx4_en_vlan_rx_kill_vid,\n\t.ndo_set_vf_mac\t\t= mlx4_en_set_vf_mac,\n\t.ndo_set_vf_vlan\t= mlx4_en_set_vf_vlan,\n\t.ndo_set_vf_rate\t= mlx4_en_set_vf_rate,\n\t.ndo_set_vf_spoofchk\t= mlx4_en_set_vf_spoofchk,\n\t.ndo_set_vf_link_state\t= mlx4_en_set_vf_link_state,\n\t.ndo_get_vf_stats       = mlx4_en_get_vf_stats,\n\t.ndo_get_vf_config\t= mlx4_en_get_vf_config,\n\t.ndo_set_features\t= mlx4_en_set_features,\n\t.ndo_fix_features\t= mlx4_en_fix_features,\n\t.ndo_setup_tc\t\t= __mlx4_en_setup_tc,\n#ifdef CONFIG_RFS_ACCEL\n\t.ndo_rx_flow_steer\t= mlx4_en_filter_rfs,\n#endif\n\t.ndo_get_phys_port_id\t= mlx4_en_get_phys_port_id,\n\t.ndo_features_check\t= mlx4_en_features_check,\n\t.ndo_set_tx_maxrate\t= mlx4_en_set_tx_maxrate,\n\t.ndo_bpf\t\t= mlx4_xdp,\n};\n\nstatic const struct xdp_metadata_ops mlx4_xdp_metadata_ops = {\n\t.xmo_rx_timestamp\t\t= mlx4_en_xdp_rx_timestamp,\n\t.xmo_rx_hash\t\t\t= mlx4_en_xdp_rx_hash,\n};\n\nint mlx4_en_netdev_event(struct notifier_block *this,\n\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *ndev = netdev_notifier_info_to_dev(ptr);\n\tu8 port = 0;\n\tstruct mlx4_en_dev *mdev;\n\tstruct mlx4_dev *dev;\n\tint i, num_eth_ports = 0;\n\tbool do_bond = true;\n\tu8 v2p_port1 = 0;\n\tu8 v2p_port2 = 0;\n\n\tif (!net_eq(dev_net(ndev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tmdev = container_of(this, struct mlx4_en_dev, netdev_nb);\n\tdev = mdev->dev;\n\n\t \n\tmlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH) {\n\t\t++num_eth_ports;\n\t\tif (!port && (mdev->pndev[i] == ndev))\n\t\t\tport = i;\n\t\tmdev->upper[i] = mdev->pndev[i] ?\n\t\t\tnetdev_master_upper_dev_get(mdev->pndev[i]) : NULL;\n\t\t \n\t\tif (!mdev->upper[i])\n\t\t\tdo_bond = false;\n\t\tif (num_eth_ports < 2)\n\t\t\tcontinue;\n\t\t \n\t\tif (mdev->upper[i] != mdev->upper[i-1])\n\t\t\tdo_bond = false;\n\t}\n\t \n\tdo_bond = (num_eth_ports ==  2) ? do_bond : false;\n\n\t \n\tif ((do_bond && (event != NETDEV_BONDING_INFO)) || !port)\n\t\treturn NOTIFY_DONE;\n\n\tif (do_bond) {\n\t\tstruct netdev_notifier_bonding_info *notifier_info = ptr;\n\t\tstruct netdev_bonding_info *bonding_info =\n\t\t\t&notifier_info->bonding_info;\n\n\t\t \n\t\tif ((bonding_info->master.bond_mode != BOND_MODE_ACTIVEBACKUP) &&\n\t\t    (bonding_info->master.bond_mode != BOND_MODE_XOR) &&\n\t\t    (bonding_info->master.bond_mode != BOND_MODE_8023AD))\n\t\t\tdo_bond = false;\n\n\t\t \n\t\tif (bonding_info->master.num_slaves != 2)\n\t\t\tdo_bond = false;\n\n\t\t \n\t\tif (do_bond) {\n\t\t\tif (bonding_info->master.bond_mode ==\n\t\t\t    BOND_MODE_ACTIVEBACKUP) {\n\t\t\t\t \n\t\t\t\tif (bonding_info->slave.state ==\n\t\t\t\t    BOND_STATE_BACKUP) {\n\t\t\t\t\tif (port == 1) {\n\t\t\t\t\t\tv2p_port1 = 2;\n\t\t\t\t\t\tv2p_port2 = 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv2p_port1 = 1;\n\t\t\t\t\t\tv2p_port2 = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {  \n\t\t\t\t\tif (port == 1) {\n\t\t\t\t\t\tv2p_port1 = 1;\n\t\t\t\t\t\tv2p_port2 = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv2p_port1 = 2;\n\t\t\t\t\t\tv2p_port2 = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {  \n\t\t\t\t \n\t\t\t\t__s8 link = bonding_info->slave.link;\n\n\t\t\t\tif (port == 1)\n\t\t\t\t\tv2p_port2 = 2;\n\t\t\t\telse\n\t\t\t\t\tv2p_port1 = 1;\n\t\t\t\tif ((link == BOND_LINK_UP) ||\n\t\t\t\t    (link == BOND_LINK_FAIL)) {\n\t\t\t\t\tif (port == 1)\n\t\t\t\t\t\tv2p_port1 = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tv2p_port2 = 2;\n\t\t\t\t} else {  \n\t\t\t\t\tif (port == 1)\n\t\t\t\t\t\tv2p_port1 = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\tv2p_port2 = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmlx4_queue_bond_work(dev, do_bond, v2p_port1, v2p_port2);\n\n\treturn NOTIFY_DONE;\n}\n\nvoid mlx4_en_update_pfc_stats_bitmap(struct mlx4_dev *dev,\n\t\t\t\t     struct mlx4_en_stats_bitmap *stats_bitmap,\n\t\t\t\t     u8 rx_ppp, u8 rx_pause,\n\t\t\t\t     u8 tx_ppp, u8 tx_pause)\n{\n\tint last_i = NUM_MAIN_STATS + NUM_PORT_STATS + NUM_PF_STATS;\n\n\tif (!mlx4_is_slave(dev) &&\n\t    (dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_FLOWSTATS_EN)) {\n\t\tmutex_lock(&stats_bitmap->mutex);\n\t\tbitmap_clear(stats_bitmap->bitmap, last_i, NUM_FLOW_STATS);\n\n\t\tif (rx_ppp)\n\t\t\tbitmap_set(stats_bitmap->bitmap, last_i,\n\t\t\t\t   NUM_FLOW_PRIORITY_STATS_RX);\n\t\tlast_i += NUM_FLOW_PRIORITY_STATS_RX;\n\n\t\tif (rx_pause && !(rx_ppp))\n\t\t\tbitmap_set(stats_bitmap->bitmap, last_i,\n\t\t\t\t   NUM_FLOW_STATS_RX);\n\t\tlast_i += NUM_FLOW_STATS_RX;\n\n\t\tif (tx_ppp)\n\t\t\tbitmap_set(stats_bitmap->bitmap, last_i,\n\t\t\t\t   NUM_FLOW_PRIORITY_STATS_TX);\n\t\tlast_i += NUM_FLOW_PRIORITY_STATS_TX;\n\n\t\tif (tx_pause && !(tx_ppp))\n\t\t\tbitmap_set(stats_bitmap->bitmap, last_i,\n\t\t\t\t   NUM_FLOW_STATS_TX);\n\t\tlast_i += NUM_FLOW_STATS_TX;\n\n\t\tmutex_unlock(&stats_bitmap->mutex);\n\t}\n}\n\nvoid mlx4_en_set_stats_bitmap(struct mlx4_dev *dev,\n\t\t\t      struct mlx4_en_stats_bitmap *stats_bitmap,\n\t\t\t      u8 rx_ppp, u8 rx_pause,\n\t\t\t      u8 tx_ppp, u8 tx_pause)\n{\n\tint last_i = 0;\n\n\tmutex_init(&stats_bitmap->mutex);\n\tbitmap_zero(stats_bitmap->bitmap, NUM_ALL_STATS);\n\n\tif (mlx4_is_slave(dev)) {\n\t\tbitmap_set(stats_bitmap->bitmap, last_i +\n\t\t\t\t\t MLX4_FIND_NETDEV_STAT(rx_packets), 1);\n\t\tbitmap_set(stats_bitmap->bitmap, last_i +\n\t\t\t\t\t MLX4_FIND_NETDEV_STAT(tx_packets), 1);\n\t\tbitmap_set(stats_bitmap->bitmap, last_i +\n\t\t\t\t\t MLX4_FIND_NETDEV_STAT(rx_bytes), 1);\n\t\tbitmap_set(stats_bitmap->bitmap, last_i +\n\t\t\t\t\t MLX4_FIND_NETDEV_STAT(tx_bytes), 1);\n\t\tbitmap_set(stats_bitmap->bitmap, last_i +\n\t\t\t\t\t MLX4_FIND_NETDEV_STAT(rx_dropped), 1);\n\t\tbitmap_set(stats_bitmap->bitmap, last_i +\n\t\t\t\t\t MLX4_FIND_NETDEV_STAT(tx_dropped), 1);\n\t} else {\n\t\tbitmap_set(stats_bitmap->bitmap, last_i, NUM_MAIN_STATS);\n\t}\n\tlast_i += NUM_MAIN_STATS;\n\n\tbitmap_set(stats_bitmap->bitmap, last_i, NUM_PORT_STATS);\n\tlast_i += NUM_PORT_STATS;\n\n\tif (mlx4_is_master(dev))\n\t\tbitmap_set(stats_bitmap->bitmap, last_i,\n\t\t\t   NUM_PF_STATS);\n\tlast_i += NUM_PF_STATS;\n\n\tmlx4_en_update_pfc_stats_bitmap(dev, stats_bitmap,\n\t\t\t\t\trx_ppp, rx_pause,\n\t\t\t\t\ttx_ppp, tx_pause);\n\tlast_i += NUM_FLOW_STATS;\n\n\tif (!mlx4_is_slave(dev))\n\t\tbitmap_set(stats_bitmap->bitmap, last_i, NUM_PKT_STATS);\n\tlast_i += NUM_PKT_STATS;\n\n\tbitmap_set(stats_bitmap->bitmap, last_i, NUM_XDP_STATS);\n\tlast_i += NUM_XDP_STATS;\n\n\tif (!mlx4_is_slave(dev))\n\t\tbitmap_set(stats_bitmap->bitmap, last_i, NUM_PHY_STATS);\n\tlast_i += NUM_PHY_STATS;\n}\n\nint mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,\n\t\t\tstruct mlx4_en_port_profile *prof)\n{\n\tstruct net_device *dev;\n\tstruct mlx4_en_priv *priv;\n\tint i, t;\n\tint err;\n\n\tdev = alloc_etherdev_mqs(sizeof(struct mlx4_en_priv),\n\t\t\t\t MAX_TX_RINGS, MAX_RX_RINGS);\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tnetif_set_real_num_tx_queues(dev, prof->tx_ring_num[TX]);\n\tnetif_set_real_num_rx_queues(dev, prof->rx_ring_num);\n\n\tSET_NETDEV_DEV(dev, &mdev->dev->persist->pdev->dev);\n\tdev->dev_port = port - 1;\n\n\t \n\n\tpriv = netdev_priv(dev);\n\tmemset(priv, 0, sizeof(struct mlx4_en_priv));\n\tpriv->counter_index = MLX4_SINK_COUNTER_INDEX(mdev->dev);\n\tspin_lock_init(&priv->stats_lock);\n\tINIT_WORK(&priv->rx_mode_task, mlx4_en_do_set_rx_mode);\n\tINIT_WORK(&priv->restart_task, mlx4_en_restart);\n\tINIT_WORK(&priv->linkstate_task, mlx4_en_linkstate_work);\n\tINIT_DELAYED_WORK(&priv->stats_task, mlx4_en_do_get_stats);\n\tINIT_DELAYED_WORK(&priv->service_task, mlx4_en_service_task);\n#ifdef CONFIG_RFS_ACCEL\n\tINIT_LIST_HEAD(&priv->filters);\n\tspin_lock_init(&priv->filters_lock);\n#endif\n\n\tpriv->dev = dev;\n\tpriv->mdev = mdev;\n\tpriv->ddev = &mdev->pdev->dev;\n\tpriv->prof = prof;\n\tpriv->port = port;\n\tpriv->port_up = false;\n\tpriv->flags = prof->flags;\n\tpriv->pflags = MLX4_EN_PRIV_FLAGS_BLUEFLAME;\n\tpriv->ctrl_flags = cpu_to_be32(MLX4_WQE_CTRL_CQ_UPDATE |\n\t\t\tMLX4_WQE_CTRL_SOLICITED);\n\tpriv->num_tx_rings_p_up = mdev->profile.max_num_tx_rings_p_up;\n\tpriv->tx_work_limit = MLX4_EN_DEFAULT_TX_WORK;\n\tnetdev_rss_key_fill(priv->rss_key, sizeof(priv->rss_key));\n\n\tfor (t = 0; t < MLX4_EN_NUM_TX_TYPES; t++) {\n\t\tpriv->tx_ring_num[t] = prof->tx_ring_num[t];\n\t\tif (!priv->tx_ring_num[t])\n\t\t\tcontinue;\n\n\t\tpriv->tx_ring[t] = kcalloc(MAX_TX_RINGS,\n\t\t\t\t\t   sizeof(struct mlx4_en_tx_ring *),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!priv->tx_ring[t]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tpriv->tx_cq[t] = kcalloc(MAX_TX_RINGS,\n\t\t\t\t\t sizeof(struct mlx4_en_cq *),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!priv->tx_cq[t]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tpriv->rx_ring_num = prof->rx_ring_num;\n\tpriv->cqe_factor = (mdev->dev->caps.cqe_size == 64) ? 1 : 0;\n\tpriv->cqe_size = mdev->dev->caps.cqe_size;\n\tpriv->mac_index = -1;\n\tpriv->msg_enable = MLX4_EN_MSG_LEVEL;\n#ifdef CONFIG_MLX4_EN_DCB\n\tif (!mlx4_is_slave(priv->mdev->dev)) {\n\t\tu8 prio;\n\n\t\tfor (prio = 0; prio < IEEE_8021QAZ_MAX_TCS; ++prio) {\n\t\t\tpriv->ets.prio_tc[prio] = prio;\n\t\t\tpriv->ets.tc_tsa[prio]  = IEEE_8021QAZ_TSA_VENDOR;\n\t\t}\n\n\t\tpriv->dcbx_cap = DCB_CAP_DCBX_VER_CEE | DCB_CAP_DCBX_HOST |\n\t\t\tDCB_CAP_DCBX_VER_IEEE;\n\t\tpriv->flags |= MLX4_EN_DCB_ENABLED;\n\t\tpriv->cee_config.pfc_state = false;\n\n\t\tfor (i = 0; i < MLX4_EN_NUM_UP_HIGH; i++)\n\t\t\tpriv->cee_config.dcb_pfc[i] = pfc_disabled;\n\n\t\tif (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_ETS_CFG) {\n\t\t\tdev->dcbnl_ops = &mlx4_en_dcbnl_ops;\n\t\t} else {\n\t\t\ten_info(priv, \"enabling only PFC DCB ops\\n\");\n\t\t\tdev->dcbnl_ops = &mlx4_en_dcbnl_pfc_ops;\n\t\t}\n\t}\n#endif\n\n\tfor (i = 0; i < MLX4_EN_MAC_HASH_SIZE; ++i)\n\t\tINIT_HLIST_HEAD(&priv->mac_hash[i]);\n\n\t \n\tpriv->max_mtu = mdev->dev->caps.eth_mtu_cap[priv->port];\n\n\tif (mdev->dev->caps.rx_checksum_flags_port[priv->port] &\n\t    MLX4_RX_CSUM_MODE_VAL_NON_TCP_UDP)\n\t\tpriv->flags |= MLX4_EN_FLAG_RX_CSUM_NON_TCP_UDP;\n\n\t \n\tdev->addr_len = ETH_ALEN;\n\tmlx4_en_u64_to_mac(dev, mdev->dev->caps.def_mac[priv->port]);\n\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\ten_err(priv, \"Port: %d, invalid mac burned: %pM, quitting\\n\",\n\t\t       priv->port, dev->dev_addr);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t} else if (mlx4_is_slave(priv->mdev->dev) &&\n\t\t   (priv->mdev->dev->port_random_macs & 1 << priv->port)) {\n\t\t \n\t\tdev->addr_assign_type |= NET_ADDR_RANDOM;\n\t\ten_warn(priv, \"Assigned random MAC address %pM\\n\", dev->dev_addr);\n\t}\n\n\tmemcpy(priv->current_mac, dev->dev_addr, sizeof(priv->current_mac));\n\n\tpriv->stride = roundup_pow_of_two(sizeof(struct mlx4_en_rx_desc) +\n\t\t\t\t\t  DS_SIZE * MLX4_EN_MAX_RX_FRAGS);\n\terr = mlx4_en_alloc_resources(priv);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tpriv->hwtstamp_config.flags = 0;\n\tpriv->hwtstamp_config.tx_type = HWTSTAMP_TX_OFF;\n\tpriv->hwtstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;\n\n\t \n\terr = mlx4_alloc_hwq_res(mdev->dev, &priv->res,\n\t\t\t\tMLX4_EN_PAGE_SIZE);\n\tif (err) {\n\t\ten_err(priv, \"Failed to allocate page for rx qps\\n\");\n\t\tgoto out;\n\t}\n\tpriv->allocated = 1;\n\n\t \n\tif (mlx4_is_master(priv->mdev->dev))\n\t\tdev->netdev_ops = &mlx4_netdev_ops_master;\n\telse\n\t\tdev->netdev_ops = &mlx4_netdev_ops;\n\tdev->xdp_metadata_ops = &mlx4_xdp_metadata_ops;\n\tdev->watchdog_timeo = MLX4_EN_WATCHDOG_TIMEOUT;\n\tnetif_set_real_num_tx_queues(dev, priv->tx_ring_num[TX]);\n\tnetif_set_real_num_rx_queues(dev, priv->rx_ring_num);\n\n\tdev->ethtool_ops = &mlx4_en_ethtool_ops;\n\n\t \n\tdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\n\tif (mdev->LSO_support)\n\t\tdev->hw_features |= NETIF_F_TSO | NETIF_F_TSO6;\n\n\tif (mdev->dev->caps.tunnel_offload_mode ==\n\t    MLX4_TUNNEL_OFFLOAD_MODE_VXLAN) {\n\t\tdev->hw_features |= NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t    NETIF_F_GSO_UDP_TUNNEL_CSUM |\n\t\t\t\t    NETIF_F_GSO_PARTIAL;\n\t\tdev->features    |= NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t    NETIF_F_GSO_UDP_TUNNEL_CSUM |\n\t\t\t\t    NETIF_F_GSO_PARTIAL;\n\t\tdev->gso_partial_features = NETIF_F_GSO_UDP_TUNNEL_CSUM;\n\t\tdev->hw_enc_features = NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\n\t\t\t\t       NETIF_F_RXCSUM |\n\t\t\t\t       NETIF_F_TSO | NETIF_F_TSO6 |\n\t\t\t\t       NETIF_F_GSO_UDP_TUNNEL |\n\t\t\t\t       NETIF_F_GSO_UDP_TUNNEL_CSUM |\n\t\t\t\t       NETIF_F_GSO_PARTIAL;\n\n\t\tdev->udp_tunnel_nic_info = &mlx4_udp_tunnels;\n\t}\n\n\tdev->vlan_features = dev->hw_features;\n\n\tdev->hw_features |= NETIF_F_RXCSUM | NETIF_F_RXHASH;\n\tdev->features = dev->hw_features | NETIF_F_HIGHDMA |\n\t\t\tNETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\tNETIF_F_HW_VLAN_CTAG_FILTER;\n\tdev->hw_features |= NETIF_F_LOOPBACK |\n\t\t\tNETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX;\n\n\tif (!(mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_SKIP_OUTER_VLAN)) {\n\t\tdev->features |= NETIF_F_HW_VLAN_STAG_RX |\n\t\t\tNETIF_F_HW_VLAN_STAG_FILTER;\n\t\tdev->hw_features |= NETIF_F_HW_VLAN_STAG_RX;\n\t}\n\n\tif (mlx4_is_slave(mdev->dev)) {\n\t\tbool vlan_offload_disabled;\n\t\tint phv;\n\n\t\terr = get_phv_bit(mdev->dev, port, &phv);\n\t\tif (!err && phv) {\n\t\t\tdev->hw_features |= NETIF_F_HW_VLAN_STAG_TX;\n\t\t\tpriv->pflags |= MLX4_EN_PRIV_FLAGS_PHV;\n\t\t}\n\t\terr = mlx4_get_is_vlan_offload_disabled(mdev->dev, port,\n\t\t\t\t\t\t\t&vlan_offload_disabled);\n\t\tif (!err && vlan_offload_disabled) {\n\t\t\tdev->hw_features &= ~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t\t      NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t\t\t      NETIF_F_HW_VLAN_STAG_TX |\n\t\t\t\t\t      NETIF_F_HW_VLAN_STAG_RX);\n\t\t\tdev->features &= ~(NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t\t\t   NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\t\t\t   NETIF_F_HW_VLAN_STAG_TX |\n\t\t\t\t\t   NETIF_F_HW_VLAN_STAG_RX);\n\t\t}\n\t} else {\n\t\tif (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_PHV_EN &&\n\t\t    !(mdev->dev->caps.flags2 &\n\t\t      MLX4_DEV_CAP_FLAG2_SKIP_OUTER_VLAN))\n\t\t\tdev->hw_features |= NETIF_F_HW_VLAN_STAG_TX;\n\t}\n\n\tif (mdev->dev->caps.flags & MLX4_DEV_CAP_FLAG_FCS_KEEP)\n\t\tdev->hw_features |= NETIF_F_RXFCS;\n\n\tif (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_IGNORE_FCS)\n\t\tdev->hw_features |= NETIF_F_RXALL;\n\n\tif (mdev->dev->caps.steering_mode ==\n\t    MLX4_STEERING_MODE_DEVICE_MANAGED &&\n\t    mdev->dev->caps.dmfs_high_steer_mode != MLX4_STEERING_DMFS_A0_STATIC)\n\t\tdev->hw_features |= NETIF_F_NTUPLE;\n\n\tif (mdev->dev->caps.steering_mode != MLX4_STEERING_MODE_A0)\n\t\tdev->priv_flags |= IFF_UNICAST_FLT;\n\n\t \n\tif (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_RSS_TOP) {\n\t\tpriv->rss_hash_fn = ETH_RSS_HASH_TOP;\n\t} else if (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_RSS_XOR) {\n\t\tpriv->rss_hash_fn = ETH_RSS_HASH_XOR;\n\t} else {\n\t\ten_warn(priv,\n\t\t\t\"No RSS hash capabilities exposed, using Toeplitz\\n\");\n\t\tpriv->rss_hash_fn = ETH_RSS_HASH_TOP;\n\t}\n\n\tdev->xdp_features = NETDEV_XDP_ACT_BASIC | NETDEV_XDP_ACT_REDIRECT;\n\n\t \n\tdev->min_mtu = ETH_MIN_MTU;\n\tdev->max_mtu = priv->max_mtu;\n\n\t \n\tnetif_set_tso_max_size(dev, GSO_MAX_SIZE);\n\n\tmdev->pndev[port] = dev;\n\tmdev->upper[port] = NULL;\n\n\tnetif_carrier_off(dev);\n\tmlx4_en_set_default_moderation(priv);\n\n\ten_warn(priv, \"Using %d TX rings\\n\", prof->tx_ring_num[TX]);\n\ten_warn(priv, \"Using %d RX rings\\n\", prof->rx_ring_num);\n\n\tmlx4_en_update_loopback_state(priv->dev, priv->dev->features);\n\n\t \n\tmlx4_en_calc_rx_buf(dev);\n\terr = mlx4_SET_PORT_general(mdev->dev, priv->port,\n\t\t\t\t    priv->rx_skb_size + ETH_FCS_LEN,\n\t\t\t\t    prof->tx_pause, prof->tx_ppp,\n\t\t\t\t    prof->rx_pause, prof->rx_ppp);\n\tif (err) {\n\t\ten_err(priv, \"Failed setting port general configurations for port %d, with error %d\\n\",\n\t\t       priv->port, err);\n\t\tgoto out;\n\t}\n\n\tif (mdev->dev->caps.tunnel_offload_mode == MLX4_TUNNEL_OFFLOAD_MODE_VXLAN) {\n\t\terr = mlx4_SET_PORT_VXLAN(mdev->dev, priv->port, VXLAN_STEER_BY_OUTER_MAC, 1);\n\t\tif (err) {\n\t\t\ten_err(priv, \"Failed setting port L2 tunnel configuration, err %d\\n\",\n\t\t\t       err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\ten_warn(priv, \"Initializing port\\n\");\n\terr = mlx4_INIT_PORT(mdev->dev, priv->port);\n\tif (err) {\n\t\ten_err(priv, \"Failed Initializing port\\n\");\n\t\tgoto out;\n\t}\n\tqueue_delayed_work(mdev->workqueue, &priv->stats_task, STATS_DELAY);\n\n\t \n\tif (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_TS)\n\t\tmlx4_en_init_timestamp(mdev);\n\n\tqueue_delayed_work(mdev->workqueue, &priv->service_task,\n\t\t\t   SERVICE_TASK_DELAY);\n\n\tmlx4_en_set_stats_bitmap(mdev->dev, &priv->stats_bitmap,\n\t\t\t\t mdev->profile.prof[priv->port].rx_ppp,\n\t\t\t\t mdev->profile.prof[priv->port].rx_pause,\n\t\t\t\t mdev->profile.prof[priv->port].tx_ppp,\n\t\t\t\t mdev->profile.prof[priv->port].tx_pause);\n\n\tSET_NETDEV_DEVLINK_PORT(dev,\n\t\t\t\tmlx4_get_devlink_port(mdev->dev, priv->port));\n\terr = register_netdev(dev);\n\tif (err) {\n\t\ten_err(priv, \"Netdev registration failed for port %d\\n\", port);\n\t\tgoto out;\n\t}\n\n\tpriv->registered = 1;\n\n\treturn 0;\n\nout:\n\tmlx4_en_destroy_netdev(dev);\n\treturn err;\n}\n\nint mlx4_en_reset_config(struct net_device *dev,\n\t\t\t struct hwtstamp_config ts_config,\n\t\t\t netdev_features_t features)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tstruct mlx4_en_port_profile new_prof;\n\tstruct mlx4_en_priv *tmp;\n\tint port_up = 0;\n\tint err = 0;\n\n\tif (priv->hwtstamp_config.tx_type == ts_config.tx_type &&\n\t    priv->hwtstamp_config.rx_filter == ts_config.rx_filter &&\n\t    !DEV_FEATURE_CHANGED(dev, features, NETIF_F_HW_VLAN_CTAG_RX) &&\n\t    !DEV_FEATURE_CHANGED(dev, features, NETIF_F_RXFCS))\n\t\treturn 0;  \n\n\tif (DEV_FEATURE_CHANGED(dev, features, NETIF_F_HW_VLAN_CTAG_RX) &&\n\t    (features & NETIF_F_HW_VLAN_CTAG_RX) &&\n\t    (priv->hwtstamp_config.rx_filter != HWTSTAMP_FILTER_NONE)) {\n\t\ten_warn(priv, \"Can't turn ON rx vlan offload while time-stamping rx filter is ON\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&mdev->state_lock);\n\n\tmemcpy(&new_prof, priv->prof, sizeof(struct mlx4_en_port_profile));\n\tmemcpy(&new_prof.hwtstamp_config, &ts_config, sizeof(ts_config));\n\n\terr = mlx4_en_try_alloc_resources(priv, tmp, &new_prof, true);\n\tif (err)\n\t\tgoto out;\n\n\tif (priv->port_up) {\n\t\tport_up = 1;\n\t\tmlx4_en_stop_port(dev, 1);\n\t}\n\n\tmlx4_en_safe_replace_resources(priv, tmp);\n\n\tif (DEV_FEATURE_CHANGED(dev, features, NETIF_F_HW_VLAN_CTAG_RX)) {\n\t\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\t\tdev->features |= NETIF_F_HW_VLAN_CTAG_RX;\n\t\telse\n\t\t\tdev->features &= ~NETIF_F_HW_VLAN_CTAG_RX;\n\t} else if (ts_config.rx_filter == HWTSTAMP_FILTER_NONE) {\n\t\t \n\t\tif (dev->wanted_features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\t\tdev->features |= NETIF_F_HW_VLAN_CTAG_RX;\n\t\telse\n\t\t\tdev->features &= ~NETIF_F_HW_VLAN_CTAG_RX;\n\t}\n\n\tif (DEV_FEATURE_CHANGED(dev, features, NETIF_F_RXFCS)) {\n\t\tif (features & NETIF_F_RXFCS)\n\t\t\tdev->features |= NETIF_F_RXFCS;\n\t\telse\n\t\t\tdev->features &= ~NETIF_F_RXFCS;\n\t}\n\n\t \n\tif (ts_config.rx_filter != HWTSTAMP_FILTER_NONE) {\n\t\tif (dev->features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\t\ten_warn(priv, \"Turning off RX vlan offload since RX time-stamping is ON\\n\");\n\t\tdev->features &= ~NETIF_F_HW_VLAN_CTAG_RX;\n\t}\n\n\tif (port_up) {\n\t\terr = mlx4_en_start_port(dev);\n\t\tif (err)\n\t\t\ten_err(priv, \"Failed starting port\\n\");\n\t}\n\n\tif (!err)\n\t\terr = mlx4_en_moderation_update(priv);\nout:\n\tmutex_unlock(&mdev->state_lock);\n\tkfree(tmp);\n\tif (!err)\n\t\tnetdev_features_change(dev);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}