{
  "module_name": "eq.c",
  "hash_id": "c7f4a118f75aa4ba48becb2454a563875411ff9ccb0a05fd17a9ade9148aaab1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/eq.c",
  "human_readable_source": " \n\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-mapping.h>\n\n#include <linux/mlx4/cmd.h>\n#include <linux/cpu_rmap.h>\n\n#include \"mlx4.h\"\n#include \"fw.h\"\n\nenum {\n\tMLX4_IRQNAME_SIZE\t= 32\n};\n\nenum {\n\tMLX4_NUM_ASYNC_EQE\t= 0x100,\n\tMLX4_NUM_SPARE_EQE\t= 0x80,\n\tMLX4_EQ_ENTRY_SIZE\t= 0x20\n};\n\n#define MLX4_EQ_STATUS_OK\t   ( 0 << 28)\n#define MLX4_EQ_STATUS_WRITE_FAIL  (10 << 28)\n#define MLX4_EQ_OWNER_SW\t   ( 0 << 24)\n#define MLX4_EQ_OWNER_HW\t   ( 1 << 24)\n#define MLX4_EQ_FLAG_EC\t\t   ( 1 << 18)\n#define MLX4_EQ_FLAG_OI\t\t   ( 1 << 17)\n#define MLX4_EQ_STATE_ARMED\t   ( 9 <<  8)\n#define MLX4_EQ_STATE_FIRED\t   (10 <<  8)\n#define MLX4_EQ_STATE_ALWAYS_ARMED (11 <<  8)\n\n#define MLX4_ASYNC_EVENT_MASK ((1ull << MLX4_EVENT_TYPE_PATH_MIG)\t    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_COMM_EST)\t    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_SQ_DRAINED)\t    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_CQ_ERROR)\t    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_WQ_CATAS_ERROR)\t    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_EEC_CATAS_ERROR)    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_PATH_MIG_FAILED)    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_WQ_INVAL_REQ_ERROR) | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_WQ_ACCESS_ERROR)    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_PORT_CHANGE)\t    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_ECC_DETECT)\t    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_SRQ_CATAS_ERROR)    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_SRQ_QP_LAST_WQE)    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_SRQ_LIMIT)\t    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_CMD)\t\t    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_OP_REQUIRED)\t    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_COMM_CHANNEL)       | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_FLR_EVENT)\t    | \\\n\t\t\t       (1ull << MLX4_EVENT_TYPE_FATAL_WARNING))\n\nstatic u64 get_async_ev_mask(struct mlx4_dev *dev)\n{\n\tu64 async_ev_mask = MLX4_ASYNC_EVENT_MASK;\n\tif (dev->caps.flags & MLX4_DEV_CAP_FLAG_PORT_MNG_CHG_EV)\n\t\tasync_ev_mask |= (1ull << MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT);\n\tif (dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_RECOVERABLE_ERROR_EVENT)\n\t\tasync_ev_mask |= (1ull << MLX4_EVENT_TYPE_RECOVERABLE_ERROR_EVENT);\n\n\treturn async_ev_mask;\n}\n\nstatic void eq_set_ci(struct mlx4_eq *eq, int req_not)\n{\n\t__raw_writel((__force u32) cpu_to_be32((eq->cons_index & 0xffffff) |\n\t\t\t\t\t       req_not << 31),\n\t\t     eq->doorbell);\n\t \n\twmb();\n}\n\nstatic struct mlx4_eqe *get_eqe(struct mlx4_eq *eq, u32 entry, u8 eqe_factor,\n\t\t\t\tu8 eqe_size)\n{\n\t \n\tunsigned long offset = (entry & (eq->nent - 1)) * eqe_size;\n\t \n\treturn eq->page_list[offset / PAGE_SIZE].buf + (offset + (eqe_factor ? MLX4_EQ_ENTRY_SIZE : 0)) % PAGE_SIZE;\n}\n\nstatic struct mlx4_eqe *next_eqe_sw(struct mlx4_eq *eq, u8 eqe_factor, u8 size)\n{\n\tstruct mlx4_eqe *eqe = get_eqe(eq, eq->cons_index, eqe_factor, size);\n\treturn !!(eqe->owner & 0x80) ^ !!(eq->cons_index & eq->nent) ? NULL : eqe;\n}\n\nstatic struct mlx4_eqe *next_slave_event_eqe(struct mlx4_slave_event_eq *slave_eq)\n{\n\tstruct mlx4_eqe *eqe =\n\t\t&slave_eq->event_eqe[slave_eq->cons & (SLAVE_EVENT_EQ_SIZE - 1)];\n\treturn (!!(eqe->owner & 0x80) ^\n\t\t!!(slave_eq->cons & SLAVE_EVENT_EQ_SIZE)) ?\n\t\teqe : NULL;\n}\n\nvoid mlx4_gen_slave_eqe(struct work_struct *work)\n{\n\tstruct mlx4_mfunc_master_ctx *master =\n\t\tcontainer_of(work, struct mlx4_mfunc_master_ctx,\n\t\t\t     slave_event_work);\n\tstruct mlx4_mfunc *mfunc =\n\t\tcontainer_of(master, struct mlx4_mfunc, master);\n\tstruct mlx4_priv *priv = container_of(mfunc, struct mlx4_priv, mfunc);\n\tstruct mlx4_dev *dev = &priv->dev;\n\tstruct mlx4_slave_event_eq *slave_eq = &mfunc->master.slave_eq;\n\tstruct mlx4_eqe *eqe;\n\tu8 slave;\n\tint i, phys_port, slave_port;\n\n\tfor (eqe = next_slave_event_eqe(slave_eq); eqe;\n\t      eqe = next_slave_event_eqe(slave_eq)) {\n\t\tslave = eqe->slave_id;\n\n\t\tif (eqe->type == MLX4_EVENT_TYPE_PORT_CHANGE &&\n\t\t    eqe->subtype == MLX4_PORT_CHANGE_SUBTYPE_DOWN &&\n\t\t    mlx4_is_bonded(dev)) {\n\t\t\tstruct mlx4_port_cap port_cap;\n\n\t\t\tif (!mlx4_QUERY_PORT(dev, 1, &port_cap) && port_cap.link_state)\n\t\t\t\tgoto consume;\n\n\t\t\tif (!mlx4_QUERY_PORT(dev, 2, &port_cap) && port_cap.link_state)\n\t\t\t\tgoto consume;\n\t\t}\n\t\t \n\t\tif (slave == ALL_SLAVES) {\n\t\t\tfor (i = 0; i <= dev->persist->num_vfs; i++) {\n\t\t\t\tphys_port = 0;\n\t\t\t\tif (eqe->type == MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT &&\n\t\t\t\t    eqe->subtype == MLX4_DEV_PMC_SUBTYPE_PORT_INFO) {\n\t\t\t\t\tphys_port  = eqe->event.port_mgmt_change.port;\n\t\t\t\t\tslave_port = mlx4_phys_to_slave_port(dev, i, phys_port);\n\t\t\t\t\tif (slave_port < 0)  \n\t\t\t\t\t\tcontinue;\n\t\t\t\t\teqe->event.port_mgmt_change.port = slave_port;\n\t\t\t\t}\n\t\t\t\tif (mlx4_GEN_EQE(dev, i, eqe))\n\t\t\t\t\tmlx4_warn(dev, \"Failed to generate event for slave %d\\n\",\n\t\t\t\t\t\t  i);\n\t\t\t\tif (phys_port)\n\t\t\t\t\teqe->event.port_mgmt_change.port = phys_port;\n\t\t\t}\n\t\t} else {\n\t\t\tif (mlx4_GEN_EQE(dev, slave, eqe))\n\t\t\t\tmlx4_warn(dev, \"Failed to generate event for slave %d\\n\",\n\t\t\t\t\t  slave);\n\t\t}\nconsume:\n\t\t++slave_eq->cons;\n\t}\n}\n\n\nstatic void slave_event(struct mlx4_dev *dev, u8 slave, struct mlx4_eqe *eqe)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_slave_event_eq *slave_eq = &priv->mfunc.master.slave_eq;\n\tstruct mlx4_eqe *s_eqe;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_eq->event_lock, flags);\n\ts_eqe = &slave_eq->event_eqe[slave_eq->prod & (SLAVE_EVENT_EQ_SIZE - 1)];\n\tif ((!!(s_eqe->owner & 0x80)) ^\n\t    (!!(slave_eq->prod & SLAVE_EVENT_EQ_SIZE))) {\n\t\tmlx4_warn(dev, \"Master failed to generate an EQE for slave: %d. No free EQE on slave events queue\\n\",\n\t\t\t  slave);\n\t\tspin_unlock_irqrestore(&slave_eq->event_lock, flags);\n\t\treturn;\n\t}\n\n\tmemcpy(s_eqe, eqe, sizeof(struct mlx4_eqe) - 1);\n\ts_eqe->slave_id = slave;\n\t \n\tdma_wmb();\n\ts_eqe->owner = !!(slave_eq->prod & SLAVE_EVENT_EQ_SIZE) ? 0x0 : 0x80;\n\t++slave_eq->prod;\n\n\tqueue_work(priv->mfunc.master.comm_wq,\n\t\t   &priv->mfunc.master.slave_event_work);\n\tspin_unlock_irqrestore(&slave_eq->event_lock, flags);\n}\n\nstatic void mlx4_slave_event(struct mlx4_dev *dev, int slave,\n\t\t\t     struct mlx4_eqe *eqe)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tif (slave < 0 || slave > dev->persist->num_vfs ||\n\t    slave == dev->caps.function ||\n\t    !priv->mfunc.master.slave_state[slave].active)\n\t\treturn;\n\n\tslave_event(dev, slave, eqe);\n}\n\n#if defined(CONFIG_SMP)\nstatic void mlx4_set_eq_affinity_hint(struct mlx4_priv *priv, int vec)\n{\n\tint hint_err;\n\tstruct mlx4_dev *dev = &priv->dev;\n\tstruct mlx4_eq *eq = &priv->eq_table.eq[vec];\n\n\tif (!cpumask_available(eq->affinity_mask) ||\n\t    cpumask_empty(eq->affinity_mask))\n\t\treturn;\n\n\thint_err = irq_update_affinity_hint(eq->irq, eq->affinity_mask);\n\tif (hint_err)\n\t\tmlx4_warn(dev, \"irq_update_affinity_hint failed, err %d\\n\", hint_err);\n}\n#endif\n\nint mlx4_gen_pkey_eqe(struct mlx4_dev *dev, int slave, u8 port)\n{\n\tstruct mlx4_eqe eqe;\n\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_slave_state *s_slave = &priv->mfunc.master.slave_state[slave];\n\n\tif (!s_slave->active)\n\t\treturn 0;\n\n\tmemset(&eqe, 0, sizeof(eqe));\n\n\teqe.type = MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT;\n\teqe.subtype = MLX4_DEV_PMC_SUBTYPE_PKEY_TABLE;\n\teqe.event.port_mgmt_change.port = mlx4_phys_to_slave_port(dev, slave, port);\n\n\treturn mlx4_GEN_EQE(dev, slave, &eqe);\n}\nEXPORT_SYMBOL(mlx4_gen_pkey_eqe);\n\nint mlx4_gen_guid_change_eqe(struct mlx4_dev *dev, int slave, u8 port)\n{\n\tstruct mlx4_eqe eqe;\n\n\t \n\tif (dev->persist->num_vfs < slave)\n\t\treturn 0;\n\tmemset(&eqe, 0, sizeof(eqe));\n\n\teqe.type = MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT;\n\teqe.subtype = MLX4_DEV_PMC_SUBTYPE_GUID_INFO;\n\teqe.event.port_mgmt_change.port = mlx4_phys_to_slave_port(dev, slave, port);\n\n\treturn mlx4_GEN_EQE(dev, slave, &eqe);\n}\nEXPORT_SYMBOL(mlx4_gen_guid_change_eqe);\n\nint mlx4_gen_port_state_change_eqe(struct mlx4_dev *dev, int slave, u8 port,\n\t\t\t\t   u8 port_subtype_change)\n{\n\tstruct mlx4_eqe eqe;\n\tu8 slave_port = mlx4_phys_to_slave_port(dev, slave, port);\n\n\t \n\tif (dev->persist->num_vfs < slave)\n\t\treturn 0;\n\tmemset(&eqe, 0, sizeof(eqe));\n\n\teqe.type = MLX4_EVENT_TYPE_PORT_CHANGE;\n\teqe.subtype = port_subtype_change;\n\teqe.event.port_change.port = cpu_to_be32(slave_port << 28);\n\n\tmlx4_dbg(dev, \"%s: sending: %d to slave: %d on port: %d\\n\", __func__,\n\t\t port_subtype_change, slave, port);\n\treturn mlx4_GEN_EQE(dev, slave, &eqe);\n}\nEXPORT_SYMBOL(mlx4_gen_port_state_change_eqe);\n\nenum slave_port_state mlx4_get_slave_port_state(struct mlx4_dev *dev, int slave, u8 port)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_slave_state *s_state = priv->mfunc.master.slave_state;\n\tstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(dev, slave);\n\n\tif (slave >= dev->num_slaves || port > dev->caps.num_ports ||\n\t    port <= 0 || !test_bit(port - 1, actv_ports.ports)) {\n\t\tpr_err(\"%s: Error: asking for slave:%d, port:%d\\n\",\n\t\t       __func__, slave, port);\n\t\treturn SLAVE_PORT_DOWN;\n\t}\n\treturn s_state[slave].port_state[port];\n}\nEXPORT_SYMBOL(mlx4_get_slave_port_state);\n\nstatic int mlx4_set_slave_port_state(struct mlx4_dev *dev, int slave, u8 port,\n\t\t\t\t     enum slave_port_state state)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_slave_state *s_state = priv->mfunc.master.slave_state;\n\tstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(dev, slave);\n\n\tif (slave >= dev->num_slaves || port > dev->caps.num_ports ||\n\t    port <= 0 || !test_bit(port - 1, actv_ports.ports)) {\n\t\tpr_err(\"%s: Error: asking for slave:%d, port:%d\\n\",\n\t\t       __func__, slave, port);\n\t\treturn -1;\n\t}\n\ts_state[slave].port_state[port] = state;\n\n\treturn 0;\n}\n\nstatic void set_all_slave_state(struct mlx4_dev *dev, u8 port, int event)\n{\n\tint i;\n\tenum slave_port_gen_event gen_event;\n\tstruct mlx4_slaves_pport slaves_pport = mlx4_phys_to_slaves_pport(dev,\n\t\t\t\t\t\t\t\t\t  port);\n\n\tfor (i = 0; i < dev->persist->num_vfs + 1; i++)\n\t\tif (test_bit(i, slaves_pport.slaves))\n\t\t\tset_and_calc_slave_port_state(dev, i, port,\n\t\t\t\t\t\t      event, &gen_event);\n}\n \nint set_and_calc_slave_port_state(struct mlx4_dev *dev, int slave,\n\t\t\t\t  u8 port, int event,\n\t\t\t\t  enum slave_port_gen_event *gen_event)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_slave_state *ctx = NULL;\n\tunsigned long flags;\n\tint ret = -1;\n\tstruct mlx4_active_ports actv_ports = mlx4_get_active_ports(dev, slave);\n\tenum slave_port_state cur_state =\n\t\tmlx4_get_slave_port_state(dev, slave, port);\n\n\t*gen_event = SLAVE_PORT_GEN_EVENT_NONE;\n\n\tif (slave >= dev->num_slaves || port > dev->caps.num_ports ||\n\t    port <= 0 || !test_bit(port - 1, actv_ports.ports)) {\n\t\tpr_err(\"%s: Error: asking for slave:%d, port:%d\\n\",\n\t\t       __func__, slave, port);\n\t\treturn ret;\n\t}\n\n\tctx = &priv->mfunc.master.slave_state[slave];\n\tspin_lock_irqsave(&ctx->lock, flags);\n\n\tswitch (cur_state) {\n\tcase SLAVE_PORT_DOWN:\n\t\tif (MLX4_PORT_STATE_DEV_EVENT_PORT_UP == event)\n\t\t\tmlx4_set_slave_port_state(dev, slave, port,\n\t\t\t\t\t\t  SLAVE_PENDING_UP);\n\t\tbreak;\n\tcase SLAVE_PENDING_UP:\n\t\tif (MLX4_PORT_STATE_DEV_EVENT_PORT_DOWN == event)\n\t\t\tmlx4_set_slave_port_state(dev, slave, port,\n\t\t\t\t\t\t  SLAVE_PORT_DOWN);\n\t\telse if (MLX4_PORT_STATE_IB_PORT_STATE_EVENT_GID_VALID == event) {\n\t\t\tmlx4_set_slave_port_state(dev, slave, port,\n\t\t\t\t\t\t  SLAVE_PORT_UP);\n\t\t\t*gen_event = SLAVE_PORT_GEN_EVENT_UP;\n\t\t}\n\t\tbreak;\n\tcase SLAVE_PORT_UP:\n\t\tif (MLX4_PORT_STATE_DEV_EVENT_PORT_DOWN == event) {\n\t\t\tmlx4_set_slave_port_state(dev, slave, port,\n\t\t\t\t\t\t  SLAVE_PORT_DOWN);\n\t\t\t*gen_event = SLAVE_PORT_GEN_EVENT_DOWN;\n\t\t} else if (MLX4_PORT_STATE_IB_EVENT_GID_INVALID ==\n\t\t\t\tevent) {\n\t\t\tmlx4_set_slave_port_state(dev, slave, port,\n\t\t\t\t\t\t  SLAVE_PENDING_UP);\n\t\t\t*gen_event = SLAVE_PORT_GEN_EVENT_DOWN;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: BUG!!! UNKNOWN state: slave:%d, port:%d\\n\",\n\t\t       __func__, slave, port);\n\t\tgoto out;\n\t}\n\tret = mlx4_get_slave_port_state(dev, slave, port);\n\nout:\n\tspin_unlock_irqrestore(&ctx->lock, flags);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(set_and_calc_slave_port_state);\n\nint mlx4_gen_slaves_port_mgt_ev(struct mlx4_dev *dev, u8 port, int attr)\n{\n\tstruct mlx4_eqe eqe;\n\n\tmemset(&eqe, 0, sizeof(eqe));\n\n\teqe.type = MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT;\n\teqe.subtype = MLX4_DEV_PMC_SUBTYPE_PORT_INFO;\n\teqe.event.port_mgmt_change.port = port;\n\teqe.event.port_mgmt_change.params.port_info.changed_attr =\n\t\tcpu_to_be32((u32) attr);\n\n\tslave_event(dev, ALL_SLAVES, &eqe);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlx4_gen_slaves_port_mgt_ev);\n\nvoid mlx4_master_handle_slave_flr(struct work_struct *work)\n{\n\tstruct mlx4_mfunc_master_ctx *master =\n\t\tcontainer_of(work, struct mlx4_mfunc_master_ctx,\n\t\t\t     slave_flr_event_work);\n\tstruct mlx4_mfunc *mfunc =\n\t\tcontainer_of(master, struct mlx4_mfunc, master);\n\tstruct mlx4_priv *priv =\n\t\tcontainer_of(mfunc, struct mlx4_priv, mfunc);\n\tstruct mlx4_dev *dev = &priv->dev;\n\tstruct mlx4_slave_state *slave_state = priv->mfunc.master.slave_state;\n\tint i;\n\tint err;\n\tunsigned long flags;\n\n\tmlx4_dbg(dev, \"mlx4_handle_slave_flr\\n\");\n\n\tfor (i = 0 ; i < dev->num_slaves; i++) {\n\n\t\tif (MLX4_COMM_CMD_FLR == slave_state[i].last_cmd) {\n\t\t\tmlx4_dbg(dev, \"mlx4_handle_slave_flr: clean slave: %d\\n\",\n\t\t\t\t i);\n\t\t\t \n\t\t\tif (dev->persist->interface_state &\n\t\t\t    MLX4_INTERFACE_STATE_UP)\n\t\t\t\tmlx4_delete_all_resources_for_slave(dev, i);\n\t\t\t \n\t\t\tspin_lock_irqsave(&priv->mfunc.master.slave_state_lock, flags);\n\t\t\tslave_state[i].last_cmd = MLX4_COMM_CMD_RESET;\n\t\t\tslave_state[i].is_slave_going_down = 0;\n\t\t\tspin_unlock_irqrestore(&priv->mfunc.master.slave_state_lock, flags);\n\t\t\t \n\t\t\terr = mlx4_cmd(dev, 0, i, 0, MLX4_CMD_INFORM_FLR_DONE,\n\t\t\t\t       MLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n\t\t\tif (err)\n\t\t\t\tmlx4_warn(dev, \"Failed to notify FW on FLR done (slave:%d)\\n\",\n\t\t\t\t\t  i);\n\t\t}\n\t}\n}\n\nstatic int mlx4_eq_int(struct mlx4_dev *dev, struct mlx4_eq *eq)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_eqe *eqe;\n\tint cqn;\n\tint eqes_found = 0;\n\tint set_ci = 0;\n\tint port;\n\tint slave = 0;\n\tint ret;\n\tint flr_slave;\n\tu8 update_slave_state;\n\tint i;\n\tenum slave_port_gen_event gen_event;\n\tunsigned long flags;\n\tstruct mlx4_vport_state *s_info;\n\tint eqe_size = dev->caps.eqe_size;\n\n\twhile ((eqe = next_eqe_sw(eq, dev->caps.eqe_factor, eqe_size))) {\n\t\t \n\t\tdma_rmb();\n\n\t\tswitch (eqe->type) {\n\t\tcase MLX4_EVENT_TYPE_COMP:\n\t\t\tcqn = be32_to_cpu(eqe->event.comp.cqn) & 0xffffff;\n\t\t\tmlx4_cq_completion(dev, cqn);\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_PATH_MIG:\n\t\tcase MLX4_EVENT_TYPE_COMM_EST:\n\t\tcase MLX4_EVENT_TYPE_SQ_DRAINED:\n\t\tcase MLX4_EVENT_TYPE_SRQ_QP_LAST_WQE:\n\t\tcase MLX4_EVENT_TYPE_WQ_CATAS_ERROR:\n\t\tcase MLX4_EVENT_TYPE_PATH_MIG_FAILED:\n\t\tcase MLX4_EVENT_TYPE_WQ_INVAL_REQ_ERROR:\n\t\tcase MLX4_EVENT_TYPE_WQ_ACCESS_ERROR:\n\t\t\tmlx4_dbg(dev, \"event %d arrived\\n\", eqe->type);\n\t\t\tif (mlx4_is_master(dev)) {\n\t\t\t\t \n\t\t\t\tret = mlx4_get_slave_from_resource_id(dev,\n\t\t\t\t\t\tRES_QP,\n\t\t\t\t\t\tbe32_to_cpu(eqe->event.qp.qpn)\n\t\t\t\t\t\t& 0xffffff, &slave);\n\t\t\t\tif (ret && ret != -ENOENT) {\n\t\t\t\t\tmlx4_dbg(dev, \"QP event %02x(%02x) on EQ %d at index %u: could not get slave id (%d)\\n\",\n\t\t\t\t\t\t eqe->type, eqe->subtype,\n\t\t\t\t\t\t eq->eqn, eq->cons_index, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!ret && slave != dev->caps.function) {\n\t\t\t\t\tmlx4_slave_event(dev, slave, eqe);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tmlx4_qp_event(dev, be32_to_cpu(eqe->event.qp.qpn) &\n\t\t\t\t      0xffffff, eqe->type);\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_SRQ_LIMIT:\n\t\t\tmlx4_dbg(dev, \"%s: MLX4_EVENT_TYPE_SRQ_LIMIT. srq_no=0x%x, eq 0x%x\\n\",\n\t\t\t\t __func__, be32_to_cpu(eqe->event.srq.srqn),\n\t\t\t\t eq->eqn);\n\t\t\tfallthrough;\n\t\tcase MLX4_EVENT_TYPE_SRQ_CATAS_ERROR:\n\t\t\tif (mlx4_is_master(dev)) {\n\t\t\t\t \n\t\t\t\tret = mlx4_get_slave_from_resource_id(dev,\n\t\t\t\t\t\tRES_SRQ,\n\t\t\t\t\t\tbe32_to_cpu(eqe->event.srq.srqn)\n\t\t\t\t\t\t& 0xffffff,\n\t\t\t\t\t\t&slave);\n\t\t\t\tif (ret && ret != -ENOENT) {\n\t\t\t\t\tmlx4_warn(dev, \"SRQ event %02x(%02x) on EQ %d at index %u: could not get slave id (%d)\\n\",\n\t\t\t\t\t\t  eqe->type, eqe->subtype,\n\t\t\t\t\t\t  eq->eqn, eq->cons_index, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (eqe->type ==\n\t\t\t\t    MLX4_EVENT_TYPE_SRQ_CATAS_ERROR)\n\t\t\t\t\tmlx4_warn(dev, \"%s: slave:%d, srq_no:0x%x, event: %02x(%02x)\\n\",\n\t\t\t\t\t\t  __func__, slave,\n\t\t\t\t\t\t  be32_to_cpu(eqe->event.srq.srqn),\n\t\t\t\t\t\t  eqe->type, eqe->subtype);\n\n\t\t\t\tif (!ret && slave != dev->caps.function) {\n\t\t\t\t\tif (eqe->type ==\n\t\t\t\t\t    MLX4_EVENT_TYPE_SRQ_CATAS_ERROR)\n\t\t\t\t\t\tmlx4_warn(dev, \"%s: sending event %02x(%02x) to slave:%d\\n\",\n\t\t\t\t\t\t\t  __func__, eqe->type,\n\t\t\t\t\t\t\t  eqe->subtype, slave);\n\t\t\t\t\tmlx4_slave_event(dev, slave, eqe);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmlx4_srq_event(dev, be32_to_cpu(eqe->event.srq.srqn) &\n\t\t\t\t       0xffffff, eqe->type);\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_CMD:\n\t\t\tmlx4_cmd_event(dev,\n\t\t\t\t       be16_to_cpu(eqe->event.cmd.token),\n\t\t\t\t       eqe->event.cmd.status,\n\t\t\t\t       be64_to_cpu(eqe->event.cmd.out_param));\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_PORT_CHANGE: {\n\t\t\tstruct mlx4_slaves_pport slaves_port;\n\t\t\tport = be32_to_cpu(eqe->event.port_change.port) >> 28;\n\t\t\tslaves_port = mlx4_phys_to_slaves_pport(dev, port);\n\t\t\tif (eqe->subtype == MLX4_PORT_CHANGE_SUBTYPE_DOWN) {\n\t\t\t\tmlx4_dispatch_event(\n\t\t\t\t\tdev, MLX4_DEV_EVENT_PORT_DOWN, &port);\n\t\t\t\tmlx4_priv(dev)->sense.do_sense_port[port] = 1;\n\t\t\t\tif (!mlx4_is_master(dev))\n\t\t\t\t\tbreak;\n\t\t\t\tfor (i = 0; i < dev->persist->num_vfs + 1;\n\t\t\t\t     i++) {\n\t\t\t\t\tint reported_port = mlx4_is_bonded(dev) ? 1 : mlx4_phys_to_slave_port(dev, i, port);\n\n\t\t\t\t\tif (!test_bit(i, slaves_port.slaves) && !mlx4_is_bonded(dev))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dev->caps.port_type[port] == MLX4_PORT_TYPE_ETH) {\n\t\t\t\t\t\tif (i == mlx4_master_func_num(dev))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tmlx4_dbg(dev, \"%s: Sending MLX4_PORT_CHANGE_SUBTYPE_DOWN to slave: %d, port:%d\\n\",\n\t\t\t\t\t\t\t __func__, i, port);\n\t\t\t\t\t\ts_info = &priv->mfunc.master.vf_oper[i].vport[port].state;\n\t\t\t\t\t\tif (IFLA_VF_LINK_STATE_AUTO == s_info->link_state) {\n\t\t\t\t\t\t\teqe->event.port_change.port =\n\t\t\t\t\t\t\t\tcpu_to_be32(\n\t\t\t\t\t\t\t\t(be32_to_cpu(eqe->event.port_change.port) & 0xFFFFFFF)\n\t\t\t\t\t\t\t\t| (reported_port << 28));\n\t\t\t\t\t\t\tmlx4_slave_event(dev, i, eqe);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {   \n\t\t\t\t\t\tset_and_calc_slave_port_state(dev, i, port,\n\t\t\t\t\t\t\t\t\t      MLX4_PORT_STATE_DEV_EVENT_PORT_DOWN,\n\t\t\t\t\t\t\t\t\t      &gen_event);\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (SLAVE_PORT_GEN_EVENT_DOWN ==  gen_event) {\n\t\t\t\t\t\t\tif (i == mlx4_master_func_num(dev))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\teqe->event.port_change.port =\n\t\t\t\t\t\t\t\tcpu_to_be32(\n\t\t\t\t\t\t\t\t(be32_to_cpu(eqe->event.port_change.port) & 0xFFFFFFF)\n\t\t\t\t\t\t\t\t| (mlx4_phys_to_slave_port(dev, i, port) << 28));\n\t\t\t\t\t\t\tmlx4_slave_event(dev, i, eqe);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmlx4_dispatch_event(dev, MLX4_DEV_EVENT_PORT_UP,\n\t\t\t\t\t\t    &port);\n\n\t\t\t\tmlx4_priv(dev)->sense.do_sense_port[port] = 0;\n\n\t\t\t\tif (!mlx4_is_master(dev))\n\t\t\t\t\tbreak;\n\t\t\t\tif (dev->caps.port_type[port] == MLX4_PORT_TYPE_ETH)\n\t\t\t\t\tfor (i = 0;\n\t\t\t\t\t     i < dev->persist->num_vfs + 1;\n\t\t\t\t\t     i++) {\n\t\t\t\t\t\tint reported_port = mlx4_is_bonded(dev) ? 1 : mlx4_phys_to_slave_port(dev, i, port);\n\n\t\t\t\t\t\tif (!test_bit(i, slaves_port.slaves) && !mlx4_is_bonded(dev))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (i == mlx4_master_func_num(dev))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\ts_info = &priv->mfunc.master.vf_oper[i].vport[port].state;\n\t\t\t\t\t\tif (IFLA_VF_LINK_STATE_AUTO == s_info->link_state) {\n\t\t\t\t\t\t\teqe->event.port_change.port =\n\t\t\t\t\t\t\t\tcpu_to_be32(\n\t\t\t\t\t\t\t\t(be32_to_cpu(eqe->event.port_change.port) & 0xFFFFFFF)\n\t\t\t\t\t\t\t\t| (reported_port << 28));\n\t\t\t\t\t\t\tmlx4_slave_event(dev, i, eqe);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse  \n\t\t\t\t\t \n\t\t\t\t\tset_all_slave_state(dev, port, MLX4_DEV_EVENT_PORT_UP);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase MLX4_EVENT_TYPE_CQ_ERROR:\n\t\t\tmlx4_warn(dev, \"CQ %s on CQN %06x\\n\",\n\t\t\t\t  eqe->event.cq_err.syndrome == 1 ?\n\t\t\t\t  \"overrun\" : \"access violation\",\n\t\t\t\t  be32_to_cpu(eqe->event.cq_err.cqn) & 0xffffff);\n\t\t\tif (mlx4_is_master(dev)) {\n\t\t\t\tret = mlx4_get_slave_from_resource_id(dev,\n\t\t\t\t\tRES_CQ,\n\t\t\t\t\tbe32_to_cpu(eqe->event.cq_err.cqn)\n\t\t\t\t\t& 0xffffff, &slave);\n\t\t\t\tif (ret && ret != -ENOENT) {\n\t\t\t\t\tmlx4_dbg(dev, \"CQ event %02x(%02x) on EQ %d at index %u: could not get slave id (%d)\\n\",\n\t\t\t\t\t\t eqe->type, eqe->subtype,\n\t\t\t\t\t\t eq->eqn, eq->cons_index, ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!ret && slave != dev->caps.function) {\n\t\t\t\t\tmlx4_slave_event(dev, slave, eqe);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmlx4_cq_event(dev,\n\t\t\t\t      be32_to_cpu(eqe->event.cq_err.cqn)\n\t\t\t\t      & 0xffffff,\n\t\t\t\t      eqe->type);\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_EQ_OVERFLOW:\n\t\t\tmlx4_warn(dev, \"EQ overrun on EQN %d\\n\", eq->eqn);\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_OP_REQUIRED:\n\t\t\tatomic_inc(&priv->opreq_count);\n\t\t\t \n\t\t\tqueue_work(mlx4_wq, &priv->opreq_task);\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_COMM_CHANNEL:\n\t\t\tif (!mlx4_is_master(dev)) {\n\t\t\t\tmlx4_warn(dev, \"Received comm channel event for non master device\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(&priv->mfunc.master.comm_arm_bit_vector,\n\t\t\t       eqe->event.comm_channel_arm.bit_vec,\n\t\t\t       sizeof(eqe->event.comm_channel_arm.bit_vec));\n\t\t\tqueue_work(priv->mfunc.master.comm_wq,\n\t\t\t\t   &priv->mfunc.master.comm_work);\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_FLR_EVENT:\n\t\t\tflr_slave = be32_to_cpu(eqe->event.flr_event.slave_id);\n\t\t\tif (!mlx4_is_master(dev)) {\n\t\t\t\tmlx4_warn(dev, \"Non-master function received FLR event\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmlx4_dbg(dev, \"FLR event for slave: %d\\n\", flr_slave);\n\n\t\t\tif (flr_slave >= dev->num_slaves) {\n\t\t\t\tmlx4_warn(dev,\n\t\t\t\t\t  \"Got FLR for unknown function: %d\\n\",\n\t\t\t\t\t  flr_slave);\n\t\t\t\tupdate_slave_state = 0;\n\t\t\t} else\n\t\t\t\tupdate_slave_state = 1;\n\n\t\t\tspin_lock_irqsave(&priv->mfunc.master.slave_state_lock, flags);\n\t\t\tif (update_slave_state) {\n\t\t\t\tpriv->mfunc.master.slave_state[flr_slave].active = false;\n\t\t\t\tpriv->mfunc.master.slave_state[flr_slave].last_cmd = MLX4_COMM_CMD_FLR;\n\t\t\t\tpriv->mfunc.master.slave_state[flr_slave].is_slave_going_down = 1;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&priv->mfunc.master.slave_state_lock, flags);\n\t\t\tmlx4_dispatch_event(dev, MLX4_DEV_EVENT_SLAVE_SHUTDOWN,\n\t\t\t\t\t    &flr_slave);\n\t\t\tqueue_work(priv->mfunc.master.comm_wq,\n\t\t\t\t   &priv->mfunc.master.slave_flr_event_work);\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_FATAL_WARNING:\n\t\t\tif (eqe->subtype == MLX4_FATAL_WARNING_SUBTYPE_WARMING) {\n\t\t\t\tif (mlx4_is_master(dev))\n\t\t\t\t\tfor (i = 0; i < dev->num_slaves; i++) {\n\t\t\t\t\t\tmlx4_dbg(dev, \"%s: Sending MLX4_FATAL_WARNING_SUBTYPE_WARMING to slave: %d\\n\",\n\t\t\t\t\t\t\t __func__, i);\n\t\t\t\t\t\tif (i == dev->caps.function)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tmlx4_slave_event(dev, i, eqe);\n\t\t\t\t\t}\n\t\t\t\tmlx4_err(dev, \"Temperature Threshold was reached! Threshold: %d celsius degrees; Current Temperature: %d\\n\",\n\t\t\t\t\t be16_to_cpu(eqe->event.warming.warning_threshold),\n\t\t\t\t\t be16_to_cpu(eqe->event.warming.current_temperature));\n\t\t\t} else\n\t\t\t\tmlx4_warn(dev, \"Unhandled event FATAL WARNING (%02x), subtype %02x on EQ %d at index %u. owner=%x, nent=0x%x, slave=%x, ownership=%s\\n\",\n\t\t\t\t\t  eqe->type, eqe->subtype, eq->eqn,\n\t\t\t\t\t  eq->cons_index, eqe->owner, eq->nent,\n\t\t\t\t\t  eqe->slave_id,\n\t\t\t\t\t  !!(eqe->owner & 0x80) ^\n\t\t\t\t\t  !!(eq->cons_index & eq->nent) ? \"HW\" : \"SW\");\n\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT:\n\t\t\tmlx4_dispatch_event(\n\t\t\t\tdev, MLX4_DEV_EVENT_PORT_MGMT_CHANGE, eqe);\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_RECOVERABLE_ERROR_EVENT:\n\t\t\tswitch (eqe->subtype) {\n\t\t\tcase MLX4_RECOVERABLE_ERROR_EVENT_SUBTYPE_BAD_CABLE:\n\t\t\t\tmlx4_warn(dev, \"Bad cable detected on port %u\\n\",\n\t\t\t\t\t  eqe->event.bad_cable.port);\n\t\t\t\tbreak;\n\t\t\tcase MLX4_RECOVERABLE_ERROR_EVENT_SUBTYPE_UNSUPPORTED_CABLE:\n\t\t\t\tmlx4_warn(dev, \"Unsupported cable detected\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmlx4_dbg(dev,\n\t\t\t\t\t \"Unhandled recoverable error event detected: %02x(%02x) on EQ %d at index %u. owner=%x, nent=0x%x, ownership=%s\\n\",\n\t\t\t\t\t eqe->type, eqe->subtype, eq->eqn,\n\t\t\t\t\t eq->cons_index, eqe->owner, eq->nent,\n\t\t\t\t\t !!(eqe->owner & 0x80) ^\n\t\t\t\t\t !!(eq->cons_index & eq->nent) ? \"HW\" : \"SW\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MLX4_EVENT_TYPE_EEC_CATAS_ERROR:\n\t\tcase MLX4_EVENT_TYPE_ECC_DETECT:\n\t\tdefault:\n\t\t\tmlx4_warn(dev, \"Unhandled event %02x(%02x) on EQ %d at index %u. owner=%x, nent=0x%x, slave=%x, ownership=%s\\n\",\n\t\t\t\t  eqe->type, eqe->subtype, eq->eqn,\n\t\t\t\t  eq->cons_index, eqe->owner, eq->nent,\n\t\t\t\t  eqe->slave_id,\n\t\t\t\t  !!(eqe->owner & 0x80) ^\n\t\t\t\t  !!(eq->cons_index & eq->nent) ? \"HW\" : \"SW\");\n\t\t\tbreak;\n\t\t}\n\n\t\t++eq->cons_index;\n\t\teqes_found = 1;\n\t\t++set_ci;\n\n\t\t \n\t\tif (unlikely(set_ci >= MLX4_NUM_SPARE_EQE)) {\n\t\t\teq_set_ci(eq, 0);\n\t\t\tset_ci = 0;\n\t\t}\n\t}\n\n\teq_set_ci(eq, 1);\n\n\treturn eqes_found;\n}\n\nstatic irqreturn_t mlx4_interrupt(int irq, void *dev_ptr)\n{\n\tstruct mlx4_dev *dev = dev_ptr;\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint work = 0;\n\tint i;\n\n\twritel(priv->eq_table.clr_mask, priv->eq_table.clr_int);\n\n\tfor (i = 0; i < dev->caps.num_comp_vectors + 1; ++i)\n\t\twork |= mlx4_eq_int(dev, &priv->eq_table.eq[i]);\n\n\treturn IRQ_RETVAL(work);\n}\n\nstatic irqreturn_t mlx4_msi_x_interrupt(int irq, void *eq_ptr)\n{\n\tstruct mlx4_eq  *eq  = eq_ptr;\n\tstruct mlx4_dev *dev = eq->dev;\n\n\tmlx4_eq_int(dev, eq);\n\n\t \n\treturn IRQ_HANDLED;\n}\n\nint mlx4_MAP_EQ_wrapper(struct mlx4_dev *dev, int slave,\n\t\t\tstruct mlx4_vhcr *vhcr,\n\t\t\tstruct mlx4_cmd_mailbox *inbox,\n\t\t\tstruct mlx4_cmd_mailbox *outbox,\n\t\t\tstruct mlx4_cmd_info *cmd)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_slave_event_eq_info *event_eq =\n\t\tpriv->mfunc.master.slave_state[slave].event_eq;\n\tu32 in_modifier = vhcr->in_modifier;\n\tu32 eqn = in_modifier & 0x3FF;\n\tu64 in_param =  vhcr->in_param;\n\tint err = 0;\n\tint i;\n\n\tif (slave == dev->caps.function)\n\t\terr = mlx4_cmd(dev, in_param, (in_modifier & 0x80000000) | eqn,\n\t\t\t       0, MLX4_CMD_MAP_EQ, MLX4_CMD_TIME_CLASS_B,\n\t\t\t       MLX4_CMD_NATIVE);\n\tif (!err)\n\t\tfor (i = 0; i < MLX4_EVENT_TYPES_NUM; ++i)\n\t\t\tif (in_param & (1LL << i))\n\t\t\t\tevent_eq[i].eqn = in_modifier >> 31 ? -1 : eqn;\n\n\treturn err;\n}\n\nstatic int mlx4_MAP_EQ(struct mlx4_dev *dev, u64 event_mask, int unmap,\n\t\t\tint eq_num)\n{\n\treturn mlx4_cmd(dev, event_mask, (unmap << 31) | eq_num,\n\t\t\t0, MLX4_CMD_MAP_EQ, MLX4_CMD_TIME_CLASS_B,\n\t\t\tMLX4_CMD_WRAPPED);\n}\n\nstatic int mlx4_SW2HW_EQ(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,\n\t\t\t int eq_num)\n{\n\treturn mlx4_cmd(dev, mailbox->dma, eq_num, 0,\n\t\t\tMLX4_CMD_SW2HW_EQ, MLX4_CMD_TIME_CLASS_A,\n\t\t\tMLX4_CMD_WRAPPED);\n}\n\nstatic int mlx4_HW2SW_EQ(struct mlx4_dev *dev,  int eq_num)\n{\n\treturn mlx4_cmd(dev, 0, eq_num, 1, MLX4_CMD_HW2SW_EQ,\n\t\t\tMLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n}\n\nstatic int mlx4_num_eq_uar(struct mlx4_dev *dev)\n{\n\t \n\treturn (dev->caps.num_comp_vectors + 1 + dev->caps.reserved_eqs) / 4 -\n\t\tdev->caps.reserved_eqs / 4 + 1;\n}\n\nstatic void __iomem *mlx4_get_eq_uar(struct mlx4_dev *dev, struct mlx4_eq *eq)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint index;\n\n\tindex = eq->eqn / 4 - dev->caps.reserved_eqs / 4;\n\n\tif (!priv->eq_table.uar_map[index]) {\n\t\tpriv->eq_table.uar_map[index] =\n\t\t\tioremap(\n\t\t\t\tpci_resource_start(dev->persist->pdev, 2) +\n\t\t\t\t((eq->eqn / 4) << (dev->uar_page_shift)),\n\t\t\t\t(1 << (dev->uar_page_shift)));\n\t\tif (!priv->eq_table.uar_map[index]) {\n\t\t\tmlx4_err(dev, \"Couldn't map EQ doorbell for EQN 0x%06x\\n\",\n\t\t\t\t eq->eqn);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn priv->eq_table.uar_map[index] + 0x800 + 8 * (eq->eqn % 4);\n}\n\nstatic void mlx4_unmap_uar(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint i;\n\n\tfor (i = 0; i < mlx4_num_eq_uar(dev); ++i)\n\t\tif (priv->eq_table.uar_map[i]) {\n\t\t\tiounmap(priv->eq_table.uar_map[i]);\n\t\t\tpriv->eq_table.uar_map[i] = NULL;\n\t\t}\n}\n\nstatic int mlx4_create_eq(struct mlx4_dev *dev, int nent,\n\t\t\t  u8 intr, struct mlx4_eq *eq)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tstruct mlx4_eq_context *eq_context;\n\tint npages;\n\tu64 *dma_list = NULL;\n\tdma_addr_t t;\n\tu64 mtt_addr;\n\tint err = -ENOMEM;\n\tint i;\n\n\teq->dev   = dev;\n\teq->nent  = roundup_pow_of_two(max(nent, 2));\n\t \n\tnpages = PAGE_ALIGN(eq->nent * dev->caps.eqe_size) / PAGE_SIZE;\n\n\teq->page_list = kmalloc_array(npages, sizeof(*eq->page_list),\n\t\t\t\t      GFP_KERNEL);\n\tif (!eq->page_list)\n\t\tgoto err_out;\n\n\tfor (i = 0; i < npages; ++i)\n\t\teq->page_list[i].buf = NULL;\n\n\tdma_list = kmalloc_array(npages, sizeof(*dma_list), GFP_KERNEL);\n\tif (!dma_list)\n\t\tgoto err_out_free;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\tgoto err_out_free;\n\teq_context = mailbox->buf;\n\n\tfor (i = 0; i < npages; ++i) {\n\t\teq->page_list[i].buf = dma_alloc_coherent(&dev->persist->\n\t\t\t\t\t\t\t  pdev->dev,\n\t\t\t\t\t\t\t  PAGE_SIZE, &t,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!eq->page_list[i].buf)\n\t\t\tgoto err_out_free_pages;\n\n\t\tdma_list[i] = t;\n\t\teq->page_list[i].map = t;\n\t}\n\n\teq->eqn = mlx4_bitmap_alloc(&priv->eq_table.bitmap);\n\tif (eq->eqn == -1)\n\t\tgoto err_out_free_pages;\n\n\teq->doorbell = mlx4_get_eq_uar(dev, eq);\n\tif (!eq->doorbell) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_eq;\n\t}\n\n\terr = mlx4_mtt_init(dev, npages, PAGE_SHIFT, &eq->mtt);\n\tif (err)\n\t\tgoto err_out_free_eq;\n\n\terr = mlx4_write_mtt(dev, &eq->mtt, 0, npages, dma_list);\n\tif (err)\n\t\tgoto err_out_free_mtt;\n\n\teq_context->flags\t  = cpu_to_be32(MLX4_EQ_STATUS_OK   |\n\t\t\t\t\t\tMLX4_EQ_STATE_ARMED);\n\teq_context->log_eq_size\t  = ilog2(eq->nent);\n\teq_context->intr\t  = intr;\n\teq_context->log_page_size = PAGE_SHIFT - MLX4_ICM_PAGE_SHIFT;\n\n\tmtt_addr = mlx4_mtt_addr(dev, &eq->mtt);\n\teq_context->mtt_base_addr_h = mtt_addr >> 32;\n\teq_context->mtt_base_addr_l = cpu_to_be32(mtt_addr & 0xffffffff);\n\n\terr = mlx4_SW2HW_EQ(dev, mailbox, eq->eqn);\n\tif (err) {\n\t\tmlx4_warn(dev, \"SW2HW_EQ failed (%d)\\n\", err);\n\t\tgoto err_out_free_mtt;\n\t}\n\n\tkfree(dma_list);\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\n\teq->cons_index = 0;\n\n\tINIT_LIST_HEAD(&eq->tasklet_ctx.list);\n\tINIT_LIST_HEAD(&eq->tasklet_ctx.process_list);\n\tspin_lock_init(&eq->tasklet_ctx.lock);\n\ttasklet_setup(&eq->tasklet_ctx.task, mlx4_cq_tasklet_cb);\n\n\treturn err;\n\nerr_out_free_mtt:\n\tmlx4_mtt_cleanup(dev, &eq->mtt);\n\nerr_out_free_eq:\n\tmlx4_bitmap_free(&priv->eq_table.bitmap, eq->eqn, MLX4_USE_RR);\n\nerr_out_free_pages:\n\tfor (i = 0; i < npages; ++i)\n\t\tif (eq->page_list[i].buf)\n\t\t\tdma_free_coherent(&dev->persist->pdev->dev, PAGE_SIZE,\n\t\t\t\t\t  eq->page_list[i].buf,\n\t\t\t\t\t  eq->page_list[i].map);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\nerr_out_free:\n\tkfree(eq->page_list);\n\tkfree(dma_list);\n\nerr_out:\n\treturn err;\n}\n\nstatic void mlx4_free_eq(struct mlx4_dev *dev,\n\t\t\t struct mlx4_eq *eq)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint err;\n\tint i;\n\t \n\tint npages = PAGE_ALIGN(dev->caps.eqe_size  * eq->nent) / PAGE_SIZE;\n\n\terr = mlx4_HW2SW_EQ(dev, eq->eqn);\n\tif (err)\n\t\tmlx4_warn(dev, \"HW2SW_EQ failed (%d)\\n\", err);\n\n\tsynchronize_irq(eq->irq);\n\ttasklet_disable(&eq->tasklet_ctx.task);\n\n\tmlx4_mtt_cleanup(dev, &eq->mtt);\n\tfor (i = 0; i < npages; ++i)\n\t\tdma_free_coherent(&dev->persist->pdev->dev, PAGE_SIZE,\n\t\t\t\t  eq->page_list[i].buf,\n\t\t\t\t  eq->page_list[i].map);\n\n\tkfree(eq->page_list);\n\tmlx4_bitmap_free(&priv->eq_table.bitmap, eq->eqn, MLX4_USE_RR);\n}\n\nstatic void mlx4_free_irqs(struct mlx4_dev *dev)\n{\n\tstruct mlx4_eq_table *eq_table = &mlx4_priv(dev)->eq_table;\n\tint\ti;\n\n\tif (eq_table->have_irq)\n\t\tfree_irq(dev->persist->pdev->irq, dev);\n\n\tfor (i = 0; i < dev->caps.num_comp_vectors + 1; ++i)\n\t\tif (eq_table->eq[i].have_irq) {\n\t\t\tfree_cpumask_var(eq_table->eq[i].affinity_mask);\n\t\t\tirq_update_affinity_hint(eq_table->eq[i].irq, NULL);\n\t\t\tfree_irq(eq_table->eq[i].irq, eq_table->eq + i);\n\t\t\teq_table->eq[i].have_irq = 0;\n\t\t}\n\n\tkfree(eq_table->irq_names);\n}\n\nstatic int mlx4_map_clr_int(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tpriv->clr_base = ioremap(pci_resource_start(dev->persist->pdev,\n\t\t\t\t priv->fw.clr_int_bar) +\n\t\t\t\t priv->fw.clr_int_base, MLX4_CLR_INT_SIZE);\n\tif (!priv->clr_base) {\n\t\tmlx4_err(dev, \"Couldn't map interrupt clear register, aborting\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void mlx4_unmap_clr_int(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tiounmap(priv->clr_base);\n}\n\nint mlx4_alloc_eq_table(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tpriv->eq_table.eq = kcalloc(dev->caps.num_eqs - dev->caps.reserved_eqs,\n\t\t\t\t    sizeof(*priv->eq_table.eq), GFP_KERNEL);\n\tif (!priv->eq_table.eq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid mlx4_free_eq_table(struct mlx4_dev *dev)\n{\n\tkfree(mlx4_priv(dev)->eq_table.eq);\n}\n\nint mlx4_init_eq_table(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint err;\n\tint i;\n\n\tpriv->eq_table.uar_map = kcalloc(mlx4_num_eq_uar(dev),\n\t\t\t\t\t sizeof(*priv->eq_table.uar_map),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!priv->eq_table.uar_map) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free;\n\t}\n\n\terr = mlx4_bitmap_init(&priv->eq_table.bitmap,\n\t\t\t       roundup_pow_of_two(dev->caps.num_eqs),\n\t\t\t       dev->caps.num_eqs - 1,\n\t\t\t       dev->caps.reserved_eqs,\n\t\t\t       roundup_pow_of_two(dev->caps.num_eqs) -\n\t\t\t       dev->caps.num_eqs);\n\tif (err)\n\t\tgoto err_out_free;\n\n\tfor (i = 0; i < mlx4_num_eq_uar(dev); ++i)\n\t\tpriv->eq_table.uar_map[i] = NULL;\n\n\tif (!mlx4_is_slave(dev)) {\n\t\terr = mlx4_map_clr_int(dev);\n\t\tif (err)\n\t\t\tgoto err_out_bitmap;\n\n\t\tpriv->eq_table.clr_mask =\n\t\t\tswab32(1 << (priv->eq_table.inta_pin & 31));\n\t\tpriv->eq_table.clr_int  = priv->clr_base +\n\t\t\t(priv->eq_table.inta_pin < 32 ? 4 : 0);\n\t}\n\n\tpriv->eq_table.irq_names =\n\t\tkmalloc_array(MLX4_IRQNAME_SIZE,\n\t\t\t      (dev->caps.num_comp_vectors + 1),\n\t\t\t      GFP_KERNEL);\n\tif (!priv->eq_table.irq_names) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_clr_int;\n\t}\n\n\tfor (i = 0; i < dev->caps.num_comp_vectors + 1; ++i) {\n\t\tif (i == MLX4_EQ_ASYNC) {\n\t\t\terr = mlx4_create_eq(dev,\n\t\t\t\t\t     MLX4_NUM_ASYNC_EQE + MLX4_NUM_SPARE_EQE,\n\t\t\t\t\t     0, &priv->eq_table.eq[MLX4_EQ_ASYNC]);\n\t\t} else {\n\t\t\tstruct mlx4_eq\t*eq = &priv->eq_table.eq[i];\n#ifdef CONFIG_RFS_ACCEL\n\t\t\tint port = find_first_bit(eq->actv_ports.ports,\n\t\t\t\t\t\t  dev->caps.num_ports) + 1;\n\n\t\t\tif (port <= dev->caps.num_ports) {\n\t\t\t\tstruct mlx4_port_info *info =\n\t\t\t\t\t&mlx4_priv(dev)->port[port];\n\n\t\t\t\tif (!info->rmap) {\n\t\t\t\t\tinfo->rmap = alloc_irq_cpu_rmap(\n\t\t\t\t\t\tmlx4_get_eqs_per_port(dev, port));\n\t\t\t\t\tif (!info->rmap) {\n\t\t\t\t\t\tmlx4_warn(dev, \"Failed to allocate cpu rmap\\n\");\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tgoto err_out_unmap;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\terr = irq_cpu_rmap_add(\n\t\t\t\t\tinfo->rmap, eq->irq);\n\t\t\t\tif (err)\n\t\t\t\t\tmlx4_warn(dev, \"Failed adding irq rmap\\n\");\n\t\t\t}\n#endif\n\t\t\terr = mlx4_create_eq(dev, dev->quotas.cq +\n\t\t\t\t\t     MLX4_NUM_SPARE_EQE,\n\t\t\t\t\t     (dev->flags & MLX4_FLAG_MSI_X) ?\n\t\t\t\t\t     i + 1 - !!(i > MLX4_EQ_ASYNC) : 0,\n\t\t\t\t\t     eq);\n\t\t}\n\t\tif (err)\n\t\t\tgoto err_out_unmap;\n\t}\n\n\tif (dev->flags & MLX4_FLAG_MSI_X) {\n\t\tconst char *eq_name;\n\n\t\tsnprintf(priv->eq_table.irq_names +\n\t\t\t MLX4_EQ_ASYNC * MLX4_IRQNAME_SIZE,\n\t\t\t MLX4_IRQNAME_SIZE,\n\t\t\t \"mlx4-async@pci:%s\",\n\t\t\t pci_name(dev->persist->pdev));\n\t\teq_name = priv->eq_table.irq_names +\n\t\t\tMLX4_EQ_ASYNC * MLX4_IRQNAME_SIZE;\n\n\t\terr = request_irq(priv->eq_table.eq[MLX4_EQ_ASYNC].irq,\n\t\t\t\t  mlx4_msi_x_interrupt, 0, eq_name,\n\t\t\t\t  priv->eq_table.eq + MLX4_EQ_ASYNC);\n\t\tif (err)\n\t\t\tgoto err_out_unmap;\n\n\t\tpriv->eq_table.eq[MLX4_EQ_ASYNC].have_irq = 1;\n\t} else {\n\t\tsnprintf(priv->eq_table.irq_names,\n\t\t\t MLX4_IRQNAME_SIZE,\n\t\t\t DRV_NAME \"@pci:%s\",\n\t\t\t pci_name(dev->persist->pdev));\n\t\terr = request_irq(dev->persist->pdev->irq, mlx4_interrupt,\n\t\t\t\t  IRQF_SHARED, priv->eq_table.irq_names, dev);\n\t\tif (err)\n\t\t\tgoto err_out_unmap;\n\n\t\tpriv->eq_table.have_irq = 1;\n\t}\n\n\terr = mlx4_MAP_EQ(dev, get_async_ev_mask(dev), 0,\n\t\t\t  priv->eq_table.eq[MLX4_EQ_ASYNC].eqn);\n\tif (err)\n\t\tmlx4_warn(dev, \"MAP_EQ for async EQ %d failed (%d)\\n\",\n\t\t\t   priv->eq_table.eq[MLX4_EQ_ASYNC].eqn, err);\n\n\t \n\teq_set_ci(&priv->eq_table.eq[MLX4_EQ_ASYNC], 1);\n\n\treturn 0;\n\nerr_out_unmap:\n\twhile (i > 0)\n\t\tmlx4_free_eq(dev, &priv->eq_table.eq[--i]);\n#ifdef CONFIG_RFS_ACCEL\n\tfor (i = 1; i <= dev->caps.num_ports; i++) {\n\t\tif (mlx4_priv(dev)->port[i].rmap) {\n\t\t\tfree_irq_cpu_rmap(mlx4_priv(dev)->port[i].rmap);\n\t\t\tmlx4_priv(dev)->port[i].rmap = NULL;\n\t\t}\n\t}\n#endif\n\tmlx4_free_irqs(dev);\n\nerr_out_clr_int:\n\tif (!mlx4_is_slave(dev))\n\t\tmlx4_unmap_clr_int(dev);\n\nerr_out_bitmap:\n\tmlx4_unmap_uar(dev);\n\tmlx4_bitmap_cleanup(&priv->eq_table.bitmap);\n\nerr_out_free:\n\tkfree(priv->eq_table.uar_map);\n\n\treturn err;\n}\n\nvoid mlx4_cleanup_eq_table(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint i;\n\n\tmlx4_MAP_EQ(dev, get_async_ev_mask(dev), 1,\n\t\t    priv->eq_table.eq[MLX4_EQ_ASYNC].eqn);\n\n#ifdef CONFIG_RFS_ACCEL\n\tfor (i = 1; i <= dev->caps.num_ports; i++) {\n\t\tif (mlx4_priv(dev)->port[i].rmap) {\n\t\t\tfree_irq_cpu_rmap(mlx4_priv(dev)->port[i].rmap);\n\t\t\tmlx4_priv(dev)->port[i].rmap = NULL;\n\t\t}\n\t}\n#endif\n\tmlx4_free_irqs(dev);\n\n\tfor (i = 0; i < dev->caps.num_comp_vectors + 1; ++i)\n\t\tmlx4_free_eq(dev, &priv->eq_table.eq[i]);\n\n\tif (!mlx4_is_slave(dev))\n\t\tmlx4_unmap_clr_int(dev);\n\n\tmlx4_unmap_uar(dev);\n\tmlx4_bitmap_cleanup(&priv->eq_table.bitmap);\n\n\tkfree(priv->eq_table.uar_map);\n}\n\n \nint mlx4_test_async(struct mlx4_dev *dev)\n{\n\treturn mlx4_NOP(dev);\n}\nEXPORT_SYMBOL(mlx4_test_async);\n\n \nint mlx4_test_interrupt(struct mlx4_dev *dev, int vector)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint err;\n\n\t \n\tmlx4_cmd_use_polling(dev);\n\n\t \n\terr = mlx4_MAP_EQ(dev, get_async_ev_mask(dev), 0,\n\t\t\t  priv->eq_table.eq[MLX4_CQ_TO_EQ_VECTOR(vector)].eqn);\n\tif (err) {\n\t\tmlx4_warn(dev, \"Failed mapping eq for interrupt test\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tmlx4_cmd_use_events(dev);\n\terr = mlx4_NOP(dev);\n\n\t \n\tmlx4_cmd_use_polling(dev);\nout:\n\tmlx4_MAP_EQ(dev, get_async_ev_mask(dev), 0,\n\t\t    priv->eq_table.eq[MLX4_EQ_ASYNC].eqn);\n\tmlx4_cmd_use_events(dev);\n\n\treturn err;\n}\nEXPORT_SYMBOL(mlx4_test_interrupt);\n\nbool mlx4_is_eq_vector_valid(struct mlx4_dev *dev, u8 port, int vector)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tvector = MLX4_CQ_TO_EQ_VECTOR(vector);\n\tif (vector < 0 || (vector >= dev->caps.num_comp_vectors + 1) ||\n\t    (vector == MLX4_EQ_ASYNC))\n\t\treturn false;\n\n\treturn test_bit(port - 1, priv->eq_table.eq[vector].actv_ports.ports);\n}\nEXPORT_SYMBOL(mlx4_is_eq_vector_valid);\n\nu32 mlx4_get_eqs_per_port(struct mlx4_dev *dev, u8 port)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tunsigned int i;\n\tunsigned int sum = 0;\n\n\tfor (i = 0; i < dev->caps.num_comp_vectors + 1; i++)\n\t\tsum += !!test_bit(port - 1,\n\t\t\t\t  priv->eq_table.eq[i].actv_ports.ports);\n\n\treturn sum;\n}\nEXPORT_SYMBOL(mlx4_get_eqs_per_port);\n\nint mlx4_is_eq_shared(struct mlx4_dev *dev, int vector)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tvector = MLX4_CQ_TO_EQ_VECTOR(vector);\n\tif (vector <= 0 || (vector >= dev->caps.num_comp_vectors + 1))\n\t\treturn -EINVAL;\n\n\treturn !!(bitmap_weight(priv->eq_table.eq[vector].actv_ports.ports,\n\t\t\t\tdev->caps.num_ports) > 1);\n}\nEXPORT_SYMBOL(mlx4_is_eq_shared);\n\nstruct cpu_rmap *mlx4_get_cpu_rmap(struct mlx4_dev *dev, int port)\n{\n\treturn mlx4_priv(dev)->port[port].rmap;\n}\nEXPORT_SYMBOL(mlx4_get_cpu_rmap);\n\nint mlx4_assign_eq(struct mlx4_dev *dev, u8 port, int *vector)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint err = 0, i = 0;\n\tu32 min_ref_count_val = (u32)-1;\n\tint requested_vector = MLX4_CQ_TO_EQ_VECTOR(*vector);\n\tint *prequested_vector = NULL;\n\n\n\tmutex_lock(&priv->msix_ctl.pool_lock);\n\tif (requested_vector < (dev->caps.num_comp_vectors + 1) &&\n\t    (requested_vector >= 0) &&\n\t    (requested_vector != MLX4_EQ_ASYNC)) {\n\t\tif (test_bit(port - 1,\n\t\t\t     priv->eq_table.eq[requested_vector].actv_ports.ports)) {\n\t\t\tprequested_vector = &requested_vector;\n\t\t} else {\n\t\t\tstruct mlx4_eq *eq;\n\n\t\t\tfor (i = 1; i < port;\n\t\t\t     requested_vector += mlx4_get_eqs_per_port(dev, i++))\n\t\t\t\t;\n\n\t\t\teq = &priv->eq_table.eq[requested_vector];\n\t\t\tif (requested_vector < dev->caps.num_comp_vectors + 1 &&\n\t\t\t    test_bit(port - 1, eq->actv_ports.ports)) {\n\t\t\t\tprequested_vector = &requested_vector;\n\t\t\t}\n\t\t}\n\t}\n\n\tif  (!prequested_vector) {\n\t\trequested_vector = -1;\n\t\tfor (i = 0; min_ref_count_val && i < dev->caps.num_comp_vectors + 1;\n\t\t     i++) {\n\t\t\tstruct mlx4_eq *eq = &priv->eq_table.eq[i];\n\n\t\t\tif (min_ref_count_val > eq->ref_count &&\n\t\t\t    test_bit(port - 1, eq->actv_ports.ports)) {\n\t\t\t\tmin_ref_count_val = eq->ref_count;\n\t\t\t\trequested_vector = i;\n\t\t\t}\n\t\t}\n\n\t\tif (requested_vector < 0) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto err_unlock;\n\t\t}\n\n\t\tprequested_vector = &requested_vector;\n\t}\n\n\tif (!test_bit(*prequested_vector, priv->msix_ctl.pool_bm) &&\n\t    dev->flags & MLX4_FLAG_MSI_X) {\n\t\tset_bit(*prequested_vector, priv->msix_ctl.pool_bm);\n\t\tsnprintf(priv->eq_table.irq_names +\n\t\t\t *prequested_vector * MLX4_IRQNAME_SIZE,\n\t\t\t MLX4_IRQNAME_SIZE, \"mlx4-%d@%s\",\n\t\t\t *prequested_vector, dev_name(&dev->persist->pdev->dev));\n\n\t\terr = request_irq(priv->eq_table.eq[*prequested_vector].irq,\n\t\t\t\t  mlx4_msi_x_interrupt, 0,\n\t\t\t\t  &priv->eq_table.irq_names[*prequested_vector << 5],\n\t\t\t\t  priv->eq_table.eq + *prequested_vector);\n\n\t\tif (err) {\n\t\t\tclear_bit(*prequested_vector, priv->msix_ctl.pool_bm);\n\t\t\t*prequested_vector = -1;\n\t\t} else {\n#if defined(CONFIG_SMP)\n\t\t\tmlx4_set_eq_affinity_hint(priv, *prequested_vector);\n#endif\n\t\t\teq_set_ci(&priv->eq_table.eq[*prequested_vector], 1);\n\t\t\tpriv->eq_table.eq[*prequested_vector].have_irq = 1;\n\t\t}\n\t}\n\n\tif (!err && *prequested_vector >= 0)\n\t\tpriv->eq_table.eq[*prequested_vector].ref_count++;\n\nerr_unlock:\n\tmutex_unlock(&priv->msix_ctl.pool_lock);\n\n\tif (!err && *prequested_vector >= 0)\n\t\t*vector = MLX4_EQ_TO_CQ_VECTOR(*prequested_vector);\n\telse\n\t\t*vector = 0;\n\n\treturn err;\n}\nEXPORT_SYMBOL(mlx4_assign_eq);\n\nint mlx4_eq_get_irq(struct mlx4_dev *dev, int cq_vec)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\treturn priv->eq_table.eq[MLX4_CQ_TO_EQ_VECTOR(cq_vec)].irq;\n}\nEXPORT_SYMBOL(mlx4_eq_get_irq);\n\nvoid mlx4_release_eq(struct mlx4_dev *dev, int vec)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint eq_vec = MLX4_CQ_TO_EQ_VECTOR(vec);\n\n\tmutex_lock(&priv->msix_ctl.pool_lock);\n\tpriv->eq_table.eq[eq_vec].ref_count--;\n\n\t \n\tmutex_unlock(&priv->msix_ctl.pool_lock);\n}\nEXPORT_SYMBOL(mlx4_release_eq);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}