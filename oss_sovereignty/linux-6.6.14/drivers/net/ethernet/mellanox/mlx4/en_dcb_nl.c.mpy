{
  "module_name": "en_dcb_nl.c",
  "hash_id": "5b408e75bc038f557d1db47a0a7b900d1dadf74474aff197c3ca374cbe5bc3e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c",
  "human_readable_source": " \n\n#include <linux/dcbnl.h>\n#include <linux/math64.h>\n\n#include \"mlx4_en.h\"\n#include \"fw_qos.h\"\n\nenum {\n\tMLX4_CEE_STATE_DOWN   = 0,\n\tMLX4_CEE_STATE_UP     = 1,\n};\n\n \n\nstruct mlx4_congestion_control_mb_prio_802_1_qau_params {\n\t__be32 modify_enable_high;\n\t__be32 modify_enable_low;\n\t__be32 reserved1;\n\t__be32 extended_enable;\n\t__be32 rppp_max_rps;\n\t__be32 rpg_time_reset;\n\t__be32 rpg_byte_reset;\n\t__be32 rpg_threshold;\n\t__be32 rpg_max_rate;\n\t__be32 rpg_ai_rate;\n\t__be32 rpg_hai_rate;\n\t__be32 rpg_gd;\n\t__be32 rpg_min_dec_fac;\n\t__be32 rpg_min_rate;\n\t__be32 max_time_rise;\n\t__be32 max_byte_rise;\n\t__be32 max_qdelta;\n\t__be32 min_qoffset;\n\t__be32 gd_coefficient;\n\t__be32 reserved2[5];\n\t__be32 cp_sample_base;\n\t__be32 reserved3[39];\n};\n\nstruct mlx4_congestion_control_mb_prio_802_1_qau_statistics {\n\t__be64 rppp_rp_centiseconds;\n\t__be32 reserved1;\n\t__be32 ignored_cnm;\n\t__be32 rppp_created_rps;\n\t__be32 estimated_total_rate;\n\t__be32 max_active_rate_limiter_index;\n\t__be32 dropped_cnms_busy_fw;\n\t__be32 reserved2;\n\t__be32 cnms_handled_successfully;\n\t__be32 min_total_limiters_rate;\n\t__be32 max_total_limiters_rate;\n\t__be32 reserved3[4];\n};\n\nstatic u8 mlx4_en_dcbnl_getcap(struct net_device *dev, int capid, u8 *cap)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\tswitch (capid) {\n\tcase DCB_CAP_ATTR_PFC:\n\t\t*cap = true;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_DCBX:\n\t\t*cap = priv->dcbx_cap;\n\t\tbreak;\n\tcase DCB_CAP_ATTR_PFC_TCS:\n\t\t*cap = 1 <<  mlx4_max_tc(priv->mdev->dev);\n\t\tbreak;\n\tdefault:\n\t\t*cap = false;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 mlx4_en_dcbnl_getpfcstate(struct net_device *netdev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(netdev);\n\n\treturn priv->cee_config.pfc_state;\n}\n\nstatic void mlx4_en_dcbnl_setpfcstate(struct net_device *netdev, u8 state)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(netdev);\n\n\tpriv->cee_config.pfc_state = state;\n}\n\nstatic void mlx4_en_dcbnl_get_pfc_cfg(struct net_device *netdev, int priority,\n\t\t\t\t      u8 *setting)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(netdev);\n\n\t*setting = priv->cee_config.dcb_pfc[priority];\n}\n\nstatic void mlx4_en_dcbnl_set_pfc_cfg(struct net_device *netdev, int priority,\n\t\t\t\t      u8 setting)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(netdev);\n\n\tpriv->cee_config.dcb_pfc[priority] = setting;\n\tpriv->cee_config.pfc_state = true;\n}\n\nstatic int mlx4_en_dcbnl_getnumtcs(struct net_device *netdev, int tcid, u8 *num)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(netdev);\n\n\tif (!(priv->flags & MLX4_EN_FLAG_DCB_ENABLED))\n\t\treturn -EINVAL;\n\n\tif (tcid == DCB_NUMTCS_ATTR_PFC)\n\t\t*num = mlx4_max_tc(priv->mdev->dev);\n\telse\n\t\t*num = 0;\n\n\treturn 0;\n}\n\nstatic u8 mlx4_en_dcbnl_set_all(struct net_device *netdev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(netdev);\n\tstruct mlx4_en_port_profile *prof = priv->prof;\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tu8 tx_pause, tx_ppp, rx_pause, rx_ppp;\n\n\tif (!(priv->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn 1;\n\n\tif (priv->cee_config.pfc_state) {\n\t\tint tc;\n\t\trx_ppp = prof->rx_ppp;\n\t\ttx_ppp = prof->tx_ppp;\n\n\t\tfor (tc = 0; tc < CEE_DCBX_MAX_PRIO; tc++) {\n\t\t\tu8 tc_mask = 1 << tc;\n\n\t\t\tswitch (priv->cee_config.dcb_pfc[tc]) {\n\t\t\tcase pfc_disabled:\n\t\t\t\ttx_ppp &= ~tc_mask;\n\t\t\t\trx_ppp &= ~tc_mask;\n\t\t\t\tbreak;\n\t\t\tcase pfc_enabled_full:\n\t\t\t\ttx_ppp |= tc_mask;\n\t\t\t\trx_ppp |= tc_mask;\n\t\t\t\tbreak;\n\t\t\tcase pfc_enabled_tx:\n\t\t\t\ttx_ppp |= tc_mask;\n\t\t\t\trx_ppp &= ~tc_mask;\n\t\t\t\tbreak;\n\t\t\tcase pfc_enabled_rx:\n\t\t\t\ttx_ppp &= ~tc_mask;\n\t\t\t\trx_ppp |= tc_mask;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trx_pause = !!(rx_ppp || tx_ppp) ? 0 : prof->rx_pause;\n\t\ttx_pause = !!(rx_ppp || tx_ppp) ? 0 : prof->tx_pause;\n\t} else {\n\t\trx_ppp = 0;\n\t\ttx_ppp = 0;\n\t\trx_pause = prof->rx_pause;\n\t\ttx_pause = prof->tx_pause;\n\t}\n\n\tif (mlx4_SET_PORT_general(mdev->dev, priv->port,\n\t\t\t\t  priv->rx_skb_size + ETH_FCS_LEN,\n\t\t\t\t  tx_pause, tx_ppp, rx_pause, rx_ppp)) {\n\t\ten_err(priv, \"Failed setting pause params\\n\");\n\t\treturn 1;\n\t}\n\n\tprof->tx_ppp = tx_ppp;\n\tprof->rx_ppp = rx_ppp;\n\tprof->tx_pause = tx_pause;\n\tprof->rx_pause = rx_pause;\n\n\treturn 0;\n}\n\nstatic u8 mlx4_en_dcbnl_get_state(struct net_device *dev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\tif (priv->flags & MLX4_EN_FLAG_DCB_ENABLED)\n\t\treturn MLX4_CEE_STATE_UP;\n\n\treturn MLX4_CEE_STATE_DOWN;\n}\n\nstatic u8 mlx4_en_dcbnl_set_state(struct net_device *dev, u8 state)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tint num_tcs = 0;\n\n\tif (!(priv->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn 1;\n\n\tif (!!(state) == !!(priv->flags & MLX4_EN_FLAG_DCB_ENABLED))\n\t\treturn 0;\n\n\tif (state) {\n\t\tpriv->flags |= MLX4_EN_FLAG_DCB_ENABLED;\n\t\tnum_tcs = IEEE_8021QAZ_MAX_TCS;\n\t} else {\n\t\tpriv->flags &= ~MLX4_EN_FLAG_DCB_ENABLED;\n\t}\n\n\tif (mlx4_en_alloc_tx_queue_per_tc(dev, num_tcs))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic int mlx4_en_dcbnl_getapp(struct net_device *netdev, u8 idtype, u16 id)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(netdev);\n\tstruct dcb_app app = {\n\t\t\t\t.selector = idtype,\n\t\t\t\t.protocol = id,\n\t\t\t     };\n\tif (!(priv->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn 0;\n\n\treturn dcb_getapp(netdev, &app);\n}\n\nstatic int mlx4_en_dcbnl_setapp(struct net_device *netdev, u8 idtype,\n\t\t\t\tu16 id, u8 up)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(netdev);\n\tstruct dcb_app app;\n\n\tif (!(priv->dcbx_cap & DCB_CAP_DCBX_VER_CEE))\n\t\treturn -EINVAL;\n\n\tmemset(&app, 0, sizeof(struct dcb_app));\n\tapp.selector = idtype;\n\tapp.protocol = id;\n\tapp.priority = up;\n\n\treturn dcb_setapp(netdev, &app);\n}\n\nstatic int mlx4_en_dcbnl_ieee_getets(struct net_device *dev,\n\t\t\t\t   struct ieee_ets *ets)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct ieee_ets *my_ets = &priv->ets;\n\n\tif (!my_ets)\n\t\treturn -EINVAL;\n\n\tets->ets_cap = IEEE_8021QAZ_MAX_TCS;\n\tets->cbs = my_ets->cbs;\n\tmemcpy(ets->tc_tx_bw, my_ets->tc_tx_bw, sizeof(ets->tc_tx_bw));\n\tmemcpy(ets->tc_tsa, my_ets->tc_tsa, sizeof(ets->tc_tsa));\n\tmemcpy(ets->prio_tc, my_ets->prio_tc, sizeof(ets->prio_tc));\n\n\treturn 0;\n}\n\nstatic int mlx4_en_ets_validate(struct mlx4_en_priv *priv, struct ieee_ets *ets)\n{\n\tint i;\n\tint total_ets_bw = 0;\n\tint has_ets_tc = 0;\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tif (ets->prio_tc[i] >= MLX4_EN_NUM_UP_HIGH) {\n\t\t\ten_err(priv, \"Bad priority in UP <=> TC mapping. TC: %d, UP: %d\\n\",\n\t\t\t\t\ti, ets->prio_tc[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (ets->tc_tsa[i]) {\n\t\tcase IEEE_8021QAZ_TSA_VENDOR:\n\t\tcase IEEE_8021QAZ_TSA_STRICT:\n\t\t\tbreak;\n\t\tcase IEEE_8021QAZ_TSA_ETS:\n\t\t\thas_ets_tc = 1;\n\t\t\ttotal_ets_bw += ets->tc_tx_bw[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ten_err(priv, \"TC[%d]: Not supported TSA: %d\\n\",\n\t\t\t\t\ti, ets->tc_tsa[i]);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (has_ets_tc && total_ets_bw != MLX4_EN_BW_MAX) {\n\t\ten_err(priv, \"Bad ETS BW sum: %d. Should be exactly 100%%\\n\",\n\t\t\t\ttotal_ets_bw);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx4_en_config_port_scheduler(struct mlx4_en_priv *priv,\n\t\tstruct ieee_ets *ets, u16 *ratelimit)\n{\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint num_strict = 0;\n\tint i;\n\t__u8 tc_tx_bw[IEEE_8021QAZ_MAX_TCS] = { 0 };\n\t__u8 pg[IEEE_8021QAZ_MAX_TCS] = { 0 };\n\n\tets = ets ?: &priv->ets;\n\tratelimit = ratelimit ?: priv->maxrate;\n\n\t \n\tfor (i = IEEE_8021QAZ_MAX_TCS - 1; i >= 0; i--) {\n\t\tswitch (ets->tc_tsa[i]) {\n\t\tcase IEEE_8021QAZ_TSA_VENDOR:\n\t\t\tpg[i] = MLX4_EN_TC_VENDOR;\n\t\t\ttc_tx_bw[i] = MLX4_EN_BW_MAX;\n\t\t\tbreak;\n\t\tcase IEEE_8021QAZ_TSA_STRICT:\n\t\t\tpg[i] = num_strict++;\n\t\t\ttc_tx_bw[i] = MLX4_EN_BW_MAX;\n\t\t\tbreak;\n\t\tcase IEEE_8021QAZ_TSA_ETS:\n\t\t\tpg[i] = MLX4_EN_TC_ETS;\n\t\t\ttc_tx_bw[i] = ets->tc_tx_bw[i] ?: MLX4_EN_BW_MIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn mlx4_SET_PORT_SCHEDULER(mdev->dev, priv->port, tc_tx_bw, pg,\n\t\t\tratelimit);\n}\n\nstatic int\nmlx4_en_dcbnl_ieee_setets(struct net_device *dev, struct ieee_ets *ets)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint err;\n\n\terr = mlx4_en_ets_validate(priv, ets);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx4_SET_PORT_PRIO2TC(mdev->dev, priv->port, ets->prio_tc);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx4_en_config_port_scheduler(priv, ets, NULL);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(&priv->ets, ets, sizeof(priv->ets));\n\n\treturn 0;\n}\n\nstatic int mlx4_en_dcbnl_ieee_getpfc(struct net_device *dev,\n\t\tstruct ieee_pfc *pfc)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\tpfc->pfc_cap = IEEE_8021QAZ_MAX_TCS;\n\tpfc->pfc_en = priv->prof->tx_ppp;\n\n\treturn 0;\n}\n\nstatic int mlx4_en_dcbnl_ieee_setpfc(struct net_device *dev,\n\t\tstruct ieee_pfc *pfc)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_en_port_profile *prof = priv->prof;\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tu32 tx_pause, tx_ppp, rx_pause, rx_ppp;\n\tint err;\n\n\ten_dbg(DRV, priv, \"cap: 0x%x en: 0x%x mbc: 0x%x delay: %d\\n\",\n\t\t\tpfc->pfc_cap,\n\t\t\tpfc->pfc_en,\n\t\t\tpfc->mbc,\n\t\t\tpfc->delay);\n\n\trx_pause = prof->rx_pause && !pfc->pfc_en;\n\ttx_pause = prof->tx_pause && !pfc->pfc_en;\n\trx_ppp = pfc->pfc_en;\n\ttx_ppp = pfc->pfc_en;\n\n\terr = mlx4_SET_PORT_general(mdev->dev, priv->port,\n\t\t\t\t    priv->rx_skb_size + ETH_FCS_LEN,\n\t\t\t\t    tx_pause, tx_ppp, rx_pause, rx_ppp);\n\tif (err) {\n\t\ten_err(priv, \"Failed setting pause params\\n\");\n\t\treturn err;\n\t}\n\n\tmlx4_en_update_pfc_stats_bitmap(mdev->dev, &priv->stats_bitmap,\n\t\t\t\t\trx_ppp, rx_pause, tx_ppp, tx_pause);\n\n\tprof->tx_ppp = tx_ppp;\n\tprof->rx_ppp = rx_ppp;\n\tprof->rx_pause = rx_pause;\n\tprof->tx_pause = tx_pause;\n\n\treturn err;\n}\n\nstatic u8 mlx4_en_dcbnl_getdcbx(struct net_device *dev)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\n\treturn priv->dcbx_cap;\n}\n\nstatic u8 mlx4_en_dcbnl_setdcbx(struct net_device *dev, u8 mode)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct ieee_ets ets = {0};\n\tstruct ieee_pfc pfc = {0};\n\n\tif (mode == priv->dcbx_cap)\n\t\treturn 0;\n\n\tif ((mode & DCB_CAP_DCBX_LLD_MANAGED) ||\n\t    ((mode & DCB_CAP_DCBX_VER_IEEE) &&\n\t     (mode & DCB_CAP_DCBX_VER_CEE)) ||\n\t    !(mode & DCB_CAP_DCBX_HOST))\n\t\tgoto err;\n\n\tpriv->dcbx_cap = mode;\n\n\tets.ets_cap = IEEE_8021QAZ_MAX_TCS;\n\tpfc.pfc_cap = IEEE_8021QAZ_MAX_TCS;\n\n\tif (mode & DCB_CAP_DCBX_VER_IEEE) {\n\t\tif (mlx4_en_dcbnl_ieee_setets(dev, &ets))\n\t\t\tgoto err;\n\t\tif (mlx4_en_dcbnl_ieee_setpfc(dev, &pfc))\n\t\t\tgoto err;\n\t} else if (mode & DCB_CAP_DCBX_VER_CEE) {\n\t\tif (mlx4_en_dcbnl_set_all(dev))\n\t\t\tgoto err;\n\t} else {\n\t\tif (mlx4_en_dcbnl_ieee_setets(dev, &ets))\n\t\t\tgoto err;\n\t\tif (mlx4_en_dcbnl_ieee_setpfc(dev, &pfc))\n\t\t\tgoto err;\n\t\tif (mlx4_en_alloc_tx_queue_per_tc(dev, 0))\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\treturn 1;\n}\n\n#define MLX4_RATELIMIT_UNITS_IN_KB 100000  \nstatic int mlx4_en_dcbnl_ieee_getmaxrate(struct net_device *dev,\n\t\t\t\t   struct ieee_maxrate *maxrate)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tint i;\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\n\t\tmaxrate->tc_maxrate[i] =\n\t\t\tpriv->maxrate[i] * MLX4_RATELIMIT_UNITS_IN_KB;\n\n\treturn 0;\n}\n\nstatic int mlx4_en_dcbnl_ieee_setmaxrate(struct net_device *dev,\n\t\tstruct ieee_maxrate *maxrate)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tu16 tmp[IEEE_8021QAZ_MAX_TCS];\n\tint i, err;\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\t \n\t\ttmp[i] = div_u64(maxrate->tc_maxrate[i] +\n\t\t\t\t MLX4_RATELIMIT_UNITS_IN_KB - 1,\n\t\t\t\t MLX4_RATELIMIT_UNITS_IN_KB);\n\t}\n\n\terr = mlx4_en_config_port_scheduler(priv, NULL, tmp);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(priv->maxrate, tmp, sizeof(priv->maxrate));\n\n\treturn 0;\n}\n\n#define RPG_ENABLE_BIT\t31\n#define CN_TAG_BIT\t30\n\nstatic int mlx4_en_dcbnl_ieee_getqcn(struct net_device *dev,\n\t\t\t\t     struct ieee_qcn *qcn)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_congestion_control_mb_prio_802_1_qau_params *hw_qcn;\n\tstruct mlx4_cmd_mailbox *mailbox_out = NULL;\n\tu64 mailbox_in_dma = 0;\n\tu32 inmod = 0;\n\tint i, err;\n\n\tif (!(priv->mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_QCN))\n\t\treturn -EOPNOTSUPP;\n\n\tmailbox_out = mlx4_alloc_cmd_mailbox(priv->mdev->dev);\n\tif (IS_ERR(mailbox_out))\n\t\treturn -ENOMEM;\n\thw_qcn =\n\t(struct mlx4_congestion_control_mb_prio_802_1_qau_params *)\n\tmailbox_out->buf;\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tinmod = priv->port | ((1 << i) << 8) |\n\t\t\t (MLX4_CTRL_ALGO_802_1_QAU_REACTION_POINT << 16);\n\t\terr = mlx4_cmd_box(priv->mdev->dev, mailbox_in_dma,\n\t\t\t\t   mailbox_out->dma,\n\t\t\t\t   inmod, MLX4_CONGESTION_CONTROL_GET_PARAMS,\n\t\t\t\t   MLX4_CMD_CONGESTION_CTRL_OPCODE,\n\t\t\t\t   MLX4_CMD_TIME_CLASS_C,\n\t\t\t\t   MLX4_CMD_NATIVE);\n\t\tif (err) {\n\t\t\tmlx4_free_cmd_mailbox(priv->mdev->dev, mailbox_out);\n\t\t\treturn err;\n\t\t}\n\n\t\tqcn->rpg_enable[i] =\n\t\t\tbe32_to_cpu(hw_qcn->extended_enable) >> RPG_ENABLE_BIT;\n\t\tqcn->rppp_max_rps[i] =\n\t\t\tbe32_to_cpu(hw_qcn->rppp_max_rps);\n\t\tqcn->rpg_time_reset[i] =\n\t\t\tbe32_to_cpu(hw_qcn->rpg_time_reset);\n\t\tqcn->rpg_byte_reset[i] =\n\t\t\tbe32_to_cpu(hw_qcn->rpg_byte_reset);\n\t\tqcn->rpg_threshold[i] =\n\t\t\tbe32_to_cpu(hw_qcn->rpg_threshold);\n\t\tqcn->rpg_max_rate[i] =\n\t\t\tbe32_to_cpu(hw_qcn->rpg_max_rate);\n\t\tqcn->rpg_ai_rate[i] =\n\t\t\tbe32_to_cpu(hw_qcn->rpg_ai_rate);\n\t\tqcn->rpg_hai_rate[i] =\n\t\t\tbe32_to_cpu(hw_qcn->rpg_hai_rate);\n\t\tqcn->rpg_gd[i] =\n\t\t\tbe32_to_cpu(hw_qcn->rpg_gd);\n\t\tqcn->rpg_min_dec_fac[i] =\n\t\t\tbe32_to_cpu(hw_qcn->rpg_min_dec_fac);\n\t\tqcn->rpg_min_rate[i] =\n\t\t\tbe32_to_cpu(hw_qcn->rpg_min_rate);\n\t\tqcn->cndd_state_machine[i] =\n\t\t\tpriv->cndd_state[i];\n\t}\n\tmlx4_free_cmd_mailbox(priv->mdev->dev, mailbox_out);\n\treturn 0;\n}\n\nstatic int mlx4_en_dcbnl_ieee_setqcn(struct net_device *dev,\n\t\t\t\t     struct ieee_qcn *qcn)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_congestion_control_mb_prio_802_1_qau_params *hw_qcn;\n\tstruct mlx4_cmd_mailbox *mailbox_in = NULL;\n\tu64 mailbox_in_dma = 0;\n\tu32 inmod = 0;\n\tint i, err;\n#define MODIFY_ENABLE_HIGH_MASK 0xc0000000\n#define MODIFY_ENABLE_LOW_MASK 0xffc00000\n\n\tif (!(priv->mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_QCN))\n\t\treturn -EOPNOTSUPP;\n\n\tmailbox_in = mlx4_alloc_cmd_mailbox(priv->mdev->dev);\n\tif (IS_ERR(mailbox_in))\n\t\treturn -ENOMEM;\n\n\tmailbox_in_dma = mailbox_in->dma;\n\thw_qcn =\n\t(struct mlx4_congestion_control_mb_prio_802_1_qau_params *)mailbox_in->buf;\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tinmod = priv->port | ((1 << i) << 8) |\n\t\t\t (MLX4_CTRL_ALGO_802_1_QAU_REACTION_POINT << 16);\n\n\t\t \n\n\t\thw_qcn->modify_enable_high = cpu_to_be32(\n\t\t\t\t\t\tMODIFY_ENABLE_HIGH_MASK);\n\t\thw_qcn->modify_enable_low = cpu_to_be32(MODIFY_ENABLE_LOW_MASK);\n\n\t\thw_qcn->extended_enable = cpu_to_be32(qcn->rpg_enable[i] << RPG_ENABLE_BIT);\n\t\thw_qcn->rppp_max_rps = cpu_to_be32(qcn->rppp_max_rps[i]);\n\t\thw_qcn->rpg_time_reset = cpu_to_be32(qcn->rpg_time_reset[i]);\n\t\thw_qcn->rpg_byte_reset = cpu_to_be32(qcn->rpg_byte_reset[i]);\n\t\thw_qcn->rpg_threshold = cpu_to_be32(qcn->rpg_threshold[i]);\n\t\thw_qcn->rpg_max_rate = cpu_to_be32(qcn->rpg_max_rate[i]);\n\t\thw_qcn->rpg_ai_rate = cpu_to_be32(qcn->rpg_ai_rate[i]);\n\t\thw_qcn->rpg_hai_rate = cpu_to_be32(qcn->rpg_hai_rate[i]);\n\t\thw_qcn->rpg_gd = cpu_to_be32(qcn->rpg_gd[i]);\n\t\thw_qcn->rpg_min_dec_fac = cpu_to_be32(qcn->rpg_min_dec_fac[i]);\n\t\thw_qcn->rpg_min_rate = cpu_to_be32(qcn->rpg_min_rate[i]);\n\t\tpriv->cndd_state[i] = qcn->cndd_state_machine[i];\n\t\tif (qcn->cndd_state_machine[i] == DCB_CNDD_INTERIOR_READY)\n\t\t\thw_qcn->extended_enable |= cpu_to_be32(1 << CN_TAG_BIT);\n\n\t\terr = mlx4_cmd(priv->mdev->dev, mailbox_in_dma, inmod,\n\t\t\t       MLX4_CONGESTION_CONTROL_SET_PARAMS,\n\t\t\t       MLX4_CMD_CONGESTION_CTRL_OPCODE,\n\t\t\t       MLX4_CMD_TIME_CLASS_C,\n\t\t\t       MLX4_CMD_NATIVE);\n\t\tif (err) {\n\t\t\tmlx4_free_cmd_mailbox(priv->mdev->dev, mailbox_in);\n\t\t\treturn err;\n\t\t}\n\t}\n\tmlx4_free_cmd_mailbox(priv->mdev->dev, mailbox_in);\n\treturn 0;\n}\n\nstatic int mlx4_en_dcbnl_ieee_getqcnstats(struct net_device *dev,\n\t\t\t\t\t  struct ieee_qcn_stats *qcn_stats)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tstruct mlx4_congestion_control_mb_prio_802_1_qau_statistics *hw_qcn_stats;\n\tstruct mlx4_cmd_mailbox *mailbox_out = NULL;\n\tu64 mailbox_in_dma = 0;\n\tu32 inmod = 0;\n\tint i, err;\n\n\tif (!(priv->mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_QCN))\n\t\treturn -EOPNOTSUPP;\n\n\tmailbox_out = mlx4_alloc_cmd_mailbox(priv->mdev->dev);\n\tif (IS_ERR(mailbox_out))\n\t\treturn -ENOMEM;\n\n\thw_qcn_stats =\n\t(struct mlx4_congestion_control_mb_prio_802_1_qau_statistics *)\n\tmailbox_out->buf;\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tinmod = priv->port | ((1 << i) << 8) |\n\t\t\t (MLX4_CTRL_ALGO_802_1_QAU_REACTION_POINT << 16);\n\t\terr = mlx4_cmd_box(priv->mdev->dev, mailbox_in_dma,\n\t\t\t\t   mailbox_out->dma, inmod,\n\t\t\t\t   MLX4_CONGESTION_CONTROL_GET_STATISTICS,\n\t\t\t\t   MLX4_CMD_CONGESTION_CTRL_OPCODE,\n\t\t\t\t   MLX4_CMD_TIME_CLASS_C,\n\t\t\t\t   MLX4_CMD_NATIVE);\n\t\tif (err) {\n\t\t\tmlx4_free_cmd_mailbox(priv->mdev->dev, mailbox_out);\n\t\t\treturn err;\n\t\t}\n\t\tqcn_stats->rppp_rp_centiseconds[i] =\n\t\t\tbe64_to_cpu(hw_qcn_stats->rppp_rp_centiseconds);\n\t\tqcn_stats->rppp_created_rps[i] =\n\t\t\tbe32_to_cpu(hw_qcn_stats->rppp_created_rps);\n\t}\n\tmlx4_free_cmd_mailbox(priv->mdev->dev, mailbox_out);\n\treturn 0;\n}\n\nconst struct dcbnl_rtnl_ops mlx4_en_dcbnl_ops = {\n\t.ieee_getets\t\t= mlx4_en_dcbnl_ieee_getets,\n\t.ieee_setets\t\t= mlx4_en_dcbnl_ieee_setets,\n\t.ieee_getmaxrate\t= mlx4_en_dcbnl_ieee_getmaxrate,\n\t.ieee_setmaxrate\t= mlx4_en_dcbnl_ieee_setmaxrate,\n\t.ieee_getqcn\t\t= mlx4_en_dcbnl_ieee_getqcn,\n\t.ieee_setqcn\t\t= mlx4_en_dcbnl_ieee_setqcn,\n\t.ieee_getqcnstats\t= mlx4_en_dcbnl_ieee_getqcnstats,\n\t.ieee_getpfc\t\t= mlx4_en_dcbnl_ieee_getpfc,\n\t.ieee_setpfc\t\t= mlx4_en_dcbnl_ieee_setpfc,\n\n\t.getstate\t= mlx4_en_dcbnl_get_state,\n\t.setstate\t= mlx4_en_dcbnl_set_state,\n\t.getpfccfg\t= mlx4_en_dcbnl_get_pfc_cfg,\n\t.setpfccfg\t= mlx4_en_dcbnl_set_pfc_cfg,\n\t.setall\t\t= mlx4_en_dcbnl_set_all,\n\t.getcap\t\t= mlx4_en_dcbnl_getcap,\n\t.getnumtcs\t= mlx4_en_dcbnl_getnumtcs,\n\t.getpfcstate\t= mlx4_en_dcbnl_getpfcstate,\n\t.setpfcstate\t= mlx4_en_dcbnl_setpfcstate,\n\t.getapp\t\t= mlx4_en_dcbnl_getapp,\n\t.setapp\t\t= mlx4_en_dcbnl_setapp,\n\n\t.getdcbx\t= mlx4_en_dcbnl_getdcbx,\n\t.setdcbx\t= mlx4_en_dcbnl_setdcbx,\n};\n\nconst struct dcbnl_rtnl_ops mlx4_en_dcbnl_pfc_ops = {\n\t.ieee_getpfc\t= mlx4_en_dcbnl_ieee_getpfc,\n\t.ieee_setpfc\t= mlx4_en_dcbnl_ieee_setpfc,\n\n\t.setstate\t= mlx4_en_dcbnl_set_state,\n\t.getpfccfg\t= mlx4_en_dcbnl_get_pfc_cfg,\n\t.setpfccfg\t= mlx4_en_dcbnl_set_pfc_cfg,\n\t.setall\t\t= mlx4_en_dcbnl_set_all,\n\t.getnumtcs\t= mlx4_en_dcbnl_getnumtcs,\n\t.getpfcstate\t= mlx4_en_dcbnl_getpfcstate,\n\t.setpfcstate\t= mlx4_en_dcbnl_setpfcstate,\n\t.getapp\t\t= mlx4_en_dcbnl_getapp,\n\t.setapp\t\t= mlx4_en_dcbnl_setapp,\n\n\t.getdcbx\t= mlx4_en_dcbnl_getdcbx,\n\t.setdcbx\t= mlx4_en_dcbnl_setdcbx,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}