{
  "module_name": "en_selftest.c",
  "hash_id": "76bf9db2b8c6f59cb8a4814c9b91f2d70b6e34c4c8bba7aacc6b3d4a72a5cbb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/en_selftest.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/mlx4/driver.h>\n\n#include \"mlx4_en.h\"\n\n\nstatic int mlx4_en_test_registers(struct mlx4_en_priv *priv)\n{\n\treturn mlx4_cmd(priv->mdev->dev, 0, 0, 0, MLX4_CMD_HW_HEALTH_CHECK,\n\t\t\tMLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n}\n\nstatic int mlx4_en_test_loopback_xmit(struct mlx4_en_priv *priv)\n{\n\tstruct sk_buff *skb;\n\tstruct ethhdr *ethh;\n\tunsigned char *packet;\n\tunsigned int packet_size = MLX4_LOOPBACK_TEST_PAYLOAD;\n\tunsigned int i;\n\tint err;\n\n\n\t \n\tskb = netdev_alloc_skb(priv->dev, MLX4_LOOPBACK_TEST_PAYLOAD + ETH_HLEN + NET_IP_ALIGN);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, NET_IP_ALIGN);\n\n\tethh = skb_put(skb, sizeof(struct ethhdr));\n\tpacket = skb_put(skb, packet_size);\n\tmemcpy(ethh->h_dest, priv->dev->dev_addr, ETH_ALEN);\n\teth_zero_addr(ethh->h_source);\n\tethh->h_proto = htons(ETH_P_ARP);\n\tskb_reset_mac_header(skb);\n\tfor (i = 0; i < packet_size; ++i)\t \n\t\tpacket[i] = (unsigned char)(i & 0xff);\n\n\t \n\terr = mlx4_en_xmit(skb, priv->dev);\n\treturn err;\n}\n\nstatic int mlx4_en_test_loopback(struct mlx4_en_priv *priv)\n{\n\tu32 loopback_ok = 0;\n\tint i;\n\n        priv->loopback_ok = 0;\n\tpriv->validate_loopback = 1;\n\n\tmlx4_en_update_loopback_state(priv->dev, priv->dev->features);\n\n\t \n\tif (mlx4_en_test_loopback_xmit(priv)) {\n\t\ten_err(priv, \"Transmitting loopback packet failed\\n\");\n\t\tgoto mlx4_en_test_loopback_exit;\n\t}\n\n\t \n\tfor (i = 0; i < MLX4_EN_LOOPBACK_RETRIES; ++i) {\n\t\tmsleep(MLX4_EN_LOOPBACK_TIMEOUT);\n\t\tif (priv->loopback_ok) {\n\t\t\tloopback_ok = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!loopback_ok)\n\t\ten_err(priv, \"Loopback packet didn't arrive\\n\");\n\nmlx4_en_test_loopback_exit:\n\n\tpriv->validate_loopback = 0;\n\n\tmlx4_en_update_loopback_state(priv->dev, priv->dev->features);\n\treturn !loopback_ok;\n}\n\nstatic int mlx4_en_test_interrupts(struct mlx4_en_priv *priv)\n{\n\tstruct mlx4_en_dev *mdev = priv->mdev;\n\tint err = 0;\n\tint i = 0;\n\n\terr = mlx4_test_async(mdev->dev);\n\t \n\tif (!(mdev->dev->flags & MLX4_FLAG_MSI_X) || mlx4_is_slave(mdev->dev))\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < priv->rx_ring_num; i++) {\n\t\terr = mlx4_test_interrupt(mdev->dev, priv->rx_cq[i]->vector);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int mlx4_en_test_link(struct mlx4_en_priv *priv)\n{\n\tif (mlx4_en_QUERY_PORT(priv->mdev, priv->port))\n\t\treturn -ENOMEM;\n\tif (priv->port_state.link_state == 1)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic int mlx4_en_test_speed(struct mlx4_en_priv *priv)\n{\n\n\tif (mlx4_en_QUERY_PORT(priv->mdev, priv->port))\n\t\treturn -ENOMEM;\n\n\t \n\tif (priv->port_state.link_speed != SPEED_100 &&\n\t    priv->port_state.link_speed != SPEED_1000 &&\n\t    priv->port_state.link_speed != SPEED_10000 &&\n\t    priv->port_state.link_speed != SPEED_20000 &&\n\t    priv->port_state.link_speed != SPEED_40000 &&\n\t    priv->port_state.link_speed != SPEED_56000)\n\t\treturn priv->port_state.link_speed;\n\n\treturn 0;\n}\n\n\nvoid mlx4_en_ex_selftest(struct net_device *dev, u32 *flags, u64 *buf)\n{\n\tstruct mlx4_en_priv *priv = netdev_priv(dev);\n\tint i, carrier_ok;\n\n\tmemset(buf, 0, sizeof(u64) * MLX4_EN_NUM_SELF_TEST);\n\n\tif (*flags & ETH_TEST_FL_OFFLINE) {\n\t\t \n\t\tcarrier_ok = netif_carrier_ok(dev);\n\n\t\tnetif_carrier_off(dev);\n\t\t \n\t\tmsleep(200);\n\n\t\tif (priv->mdev->dev->caps.flags &\n\t\t\t\t\tMLX4_DEV_CAP_FLAG_UC_LOOPBACK) {\n\t\t\tbuf[3] = mlx4_en_test_registers(priv);\n\t\t\tif (priv->port_up && dev->mtu >= MLX4_SELFTEST_LB_MIN_MTU)\n\t\t\t\tbuf[4] = mlx4_en_test_loopback(priv);\n\t\t}\n\n\t\tif (carrier_ok)\n\t\t\tnetif_carrier_on(dev);\n\n\t}\n\tbuf[0] = mlx4_en_test_interrupts(priv);\n\tbuf[1] = mlx4_en_test_link(priv);\n\tbuf[2] = mlx4_en_test_speed(priv);\n\n\tfor (i = 0; i < MLX4_EN_NUM_SELF_TEST; i++) {\n\t\tif (buf[i])\n\t\t\t*flags |= ETH_TEST_FL_FAILED;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}