{
  "module_name": "qp.c",
  "hash_id": "a7dc2b2639d95e31a239b61b06e56e2dc991cb70e9e675367e192de8eb3631c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/qp.c",
  "human_readable_source": " \n\n#include <linux/gfp.h>\n#include <linux/export.h>\n\n#include <linux/mlx4/cmd.h>\n#include <linux/mlx4/qp.h>\n\n#include \"mlx4.h\"\n#include \"icm.h\"\n\n \n#define MLX4_BF_QP_SKIP_MASK\t0xc0\n#define MLX4_MAX_BF_QP_RANGE\t0x40\n\nvoid mlx4_put_qp(struct mlx4_qp *qp)\n{\n\tif (refcount_dec_and_test(&qp->refcount))\n\t\tcomplete(&qp->free);\n}\nEXPORT_SYMBOL_GPL(mlx4_put_qp);\n\nvoid mlx4_qp_event(struct mlx4_dev *dev, u32 qpn, int event_type)\n{\n\tstruct mlx4_qp_table *qp_table = &mlx4_priv(dev)->qp_table;\n\tstruct mlx4_qp *qp;\n\n\tspin_lock(&qp_table->lock);\n\n\tqp = __mlx4_qp_lookup(dev, qpn);\n\tif (qp)\n\t\trefcount_inc(&qp->refcount);\n\n\tspin_unlock(&qp_table->lock);\n\n\tif (!qp) {\n\t\tmlx4_dbg(dev, \"Async event for none existent QP %08x\\n\", qpn);\n\t\treturn;\n\t}\n\n\t \n\tqp->event(qp, event_type);\n}\n\n \nstatic int is_master_qp0(struct mlx4_dev *dev, struct mlx4_qp *qp, int *real_qp0, int *proxy_qp0)\n{\n\t \n\t \n\tu32 pf_proxy_offset = dev->phys_caps.base_proxy_sqpn + 8 * mlx4_master_func_num(dev);\n\t*proxy_qp0 = qp->qpn >= pf_proxy_offset && qp->qpn <= pf_proxy_offset + 1;\n\n\t*real_qp0 = qp->qpn >= dev->phys_caps.base_sqpn &&\n\t\tqp->qpn <= dev->phys_caps.base_sqpn + 1;\n\n\treturn *real_qp0 || *proxy_qp0;\n}\n\nstatic int __mlx4_qp_modify(struct mlx4_dev *dev, struct mlx4_mtt *mtt,\n\t\t     enum mlx4_qp_state cur_state, enum mlx4_qp_state new_state,\n\t\t     struct mlx4_qp_context *context,\n\t\t     enum mlx4_qp_optpar optpar,\n\t\t     int sqd_event, struct mlx4_qp *qp, int native)\n{\n\tstatic const u16 op[MLX4_QP_NUM_STATE][MLX4_QP_NUM_STATE] = {\n\t\t[MLX4_QP_STATE_RST] = {\n\t\t\t[MLX4_QP_STATE_RST]\t= MLX4_CMD_2RST_QP,\n\t\t\t[MLX4_QP_STATE_ERR]\t= MLX4_CMD_2ERR_QP,\n\t\t\t[MLX4_QP_STATE_INIT]\t= MLX4_CMD_RST2INIT_QP,\n\t\t},\n\t\t[MLX4_QP_STATE_INIT]  = {\n\t\t\t[MLX4_QP_STATE_RST]\t= MLX4_CMD_2RST_QP,\n\t\t\t[MLX4_QP_STATE_ERR]\t= MLX4_CMD_2ERR_QP,\n\t\t\t[MLX4_QP_STATE_INIT]\t= MLX4_CMD_INIT2INIT_QP,\n\t\t\t[MLX4_QP_STATE_RTR]\t= MLX4_CMD_INIT2RTR_QP,\n\t\t},\n\t\t[MLX4_QP_STATE_RTR]   = {\n\t\t\t[MLX4_QP_STATE_RST]\t= MLX4_CMD_2RST_QP,\n\t\t\t[MLX4_QP_STATE_ERR]\t= MLX4_CMD_2ERR_QP,\n\t\t\t[MLX4_QP_STATE_RTS]\t= MLX4_CMD_RTR2RTS_QP,\n\t\t},\n\t\t[MLX4_QP_STATE_RTS]   = {\n\t\t\t[MLX4_QP_STATE_RST]\t= MLX4_CMD_2RST_QP,\n\t\t\t[MLX4_QP_STATE_ERR]\t= MLX4_CMD_2ERR_QP,\n\t\t\t[MLX4_QP_STATE_RTS]\t= MLX4_CMD_RTS2RTS_QP,\n\t\t\t[MLX4_QP_STATE_SQD]\t= MLX4_CMD_RTS2SQD_QP,\n\t\t},\n\t\t[MLX4_QP_STATE_SQD] = {\n\t\t\t[MLX4_QP_STATE_RST]\t= MLX4_CMD_2RST_QP,\n\t\t\t[MLX4_QP_STATE_ERR]\t= MLX4_CMD_2ERR_QP,\n\t\t\t[MLX4_QP_STATE_RTS]\t= MLX4_CMD_SQD2RTS_QP,\n\t\t\t[MLX4_QP_STATE_SQD]\t= MLX4_CMD_SQD2SQD_QP,\n\t\t},\n\t\t[MLX4_QP_STATE_SQER] = {\n\t\t\t[MLX4_QP_STATE_RST]\t= MLX4_CMD_2RST_QP,\n\t\t\t[MLX4_QP_STATE_ERR]\t= MLX4_CMD_2ERR_QP,\n\t\t\t[MLX4_QP_STATE_RTS]\t= MLX4_CMD_SQERR2RTS_QP,\n\t\t},\n\t\t[MLX4_QP_STATE_ERR] = {\n\t\t\t[MLX4_QP_STATE_RST]\t= MLX4_CMD_2RST_QP,\n\t\t\t[MLX4_QP_STATE_ERR]\t= MLX4_CMD_2ERR_QP,\n\t\t}\n\t};\n\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tint ret = 0;\n\tint real_qp0 = 0;\n\tint proxy_qp0 = 0;\n\tu8 port;\n\n\tif (cur_state >= MLX4_QP_NUM_STATE || new_state >= MLX4_QP_NUM_STATE ||\n\t    !op[cur_state][new_state])\n\t\treturn -EINVAL;\n\n\tif (op[cur_state][new_state] == MLX4_CMD_2RST_QP) {\n\t\tret = mlx4_cmd(dev, 0, qp->qpn, 2,\n\t\t\tMLX4_CMD_2RST_QP, MLX4_CMD_TIME_CLASS_A, native);\n\t\tif (mlx4_is_master(dev) && cur_state != MLX4_QP_STATE_ERR &&\n\t\t    cur_state != MLX4_QP_STATE_RST &&\n\t\t    is_master_qp0(dev, qp, &real_qp0, &proxy_qp0)) {\n\t\t\tport = (qp->qpn & 1) + 1;\n\t\t\tif (proxy_qp0)\n\t\t\t\tpriv->mfunc.master.qp0_state[port].proxy_qp0_active = 0;\n\t\t\telse\n\t\t\t\tpriv->mfunc.master.qp0_state[port].qp0_active = 0;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tif (cur_state == MLX4_QP_STATE_RST && new_state == MLX4_QP_STATE_INIT) {\n\t\tu64 mtt_addr = mlx4_mtt_addr(dev, mtt);\n\t\tcontext->mtt_base_addr_h = mtt_addr >> 32;\n\t\tcontext->mtt_base_addr_l = cpu_to_be32(mtt_addr & 0xffffffff);\n\t\tcontext->log_page_size   = mtt->page_shift - MLX4_ICM_PAGE_SHIFT;\n\t}\n\n\tif ((cur_state == MLX4_QP_STATE_RTR) &&\n\t    (new_state == MLX4_QP_STATE_RTS) &&\n\t    dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_ROCE_V1_V2)\n\t\tcontext->roce_entropy =\n\t\t\tcpu_to_be16(mlx4_qp_roce_entropy(dev, qp->qpn));\n\n\t*(__be32 *) mailbox->buf = cpu_to_be32(optpar);\n\tmemcpy(mailbox->buf + 8, context, sizeof(*context));\n\n\t((struct mlx4_qp_context *) (mailbox->buf + 8))->local_qpn =\n\t\tcpu_to_be32(qp->qpn);\n\n\tret = mlx4_cmd(dev, mailbox->dma,\n\t\t       qp->qpn | (!!sqd_event << 31),\n\t\t       new_state == MLX4_QP_STATE_RST ? 2 : 0,\n\t\t       op[cur_state][new_state], MLX4_CMD_TIME_CLASS_C, native);\n\n\tif (mlx4_is_master(dev) && is_master_qp0(dev, qp, &real_qp0, &proxy_qp0)) {\n\t\tport = (qp->qpn & 1) + 1;\n\t\tif (cur_state != MLX4_QP_STATE_ERR &&\n\t\t    cur_state != MLX4_QP_STATE_RST &&\n\t\t    new_state == MLX4_QP_STATE_ERR) {\n\t\t\tif (proxy_qp0)\n\t\t\t\tpriv->mfunc.master.qp0_state[port].proxy_qp0_active = 0;\n\t\t\telse\n\t\t\t\tpriv->mfunc.master.qp0_state[port].qp0_active = 0;\n\t\t} else if (new_state == MLX4_QP_STATE_RTR) {\n\t\t\tif (proxy_qp0)\n\t\t\t\tpriv->mfunc.master.qp0_state[port].proxy_qp0_active = 1;\n\t\t\telse\n\t\t\t\tpriv->mfunc.master.qp0_state[port].qp0_active = 1;\n\t\t}\n\t}\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn ret;\n}\n\nint mlx4_qp_modify(struct mlx4_dev *dev, struct mlx4_mtt *mtt,\n\t\t   enum mlx4_qp_state cur_state, enum mlx4_qp_state new_state,\n\t\t   struct mlx4_qp_context *context,\n\t\t   enum mlx4_qp_optpar optpar,\n\t\t   int sqd_event, struct mlx4_qp *qp)\n{\n\treturn __mlx4_qp_modify(dev, mtt, cur_state, new_state, context,\n\t\t\t\toptpar, sqd_event, qp, 0);\n}\nEXPORT_SYMBOL_GPL(mlx4_qp_modify);\n\nint __mlx4_qp_reserve_range(struct mlx4_dev *dev, int cnt, int align,\n\t\t\t    int *base, u8 flags)\n{\n\tu32 uid;\n\tint bf_qp = !!(flags & (u8)MLX4_RESERVE_ETH_BF_QP);\n\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_qp_table *qp_table = &priv->qp_table;\n\n\tif (cnt > MLX4_MAX_BF_QP_RANGE && bf_qp)\n\t\treturn -ENOMEM;\n\n\tuid = MLX4_QP_TABLE_ZONE_GENERAL;\n\tif (flags & (u8)MLX4_RESERVE_A0_QP) {\n\t\tif (bf_qp)\n\t\t\tuid = MLX4_QP_TABLE_ZONE_RAW_ETH;\n\t\telse\n\t\t\tuid = MLX4_QP_TABLE_ZONE_RSS;\n\t}\n\n\t*base = mlx4_zone_alloc_entries(qp_table->zones, uid, cnt, align,\n\t\t\t\t\tbf_qp ? MLX4_BF_QP_SKIP_MASK : 0, NULL);\n\tif (*base == -1)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint mlx4_qp_reserve_range(struct mlx4_dev *dev, int cnt, int align,\n\t\t\t  int *base, u8 flags, u8 usage)\n{\n\tu32 in_modifier = RES_QP | (((u32)usage & 3) << 30);\n\tu64 in_param = 0;\n\tu64 out_param;\n\tint err;\n\n\t \n\tflags &= dev->caps.alloc_res_qp_mask;\n\n\tif (mlx4_is_mfunc(dev)) {\n\t\tset_param_l(&in_param, (((u32)flags) << 24) | (u32)cnt);\n\t\tset_param_h(&in_param, align);\n\t\terr = mlx4_cmd_imm(dev, in_param, &out_param,\n\t\t\t\t   in_modifier, RES_OP_RESERVE,\n\t\t\t\t   MLX4_CMD_ALLOC_RES,\n\t\t\t\t   MLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*base = get_param_l(&out_param);\n\t\treturn 0;\n\t}\n\treturn __mlx4_qp_reserve_range(dev, cnt, align, base, flags);\n}\nEXPORT_SYMBOL_GPL(mlx4_qp_reserve_range);\n\nvoid __mlx4_qp_release_range(struct mlx4_dev *dev, int base_qpn, int cnt)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_qp_table *qp_table = &priv->qp_table;\n\n\tif (mlx4_is_qp_reserved(dev, (u32) base_qpn))\n\t\treturn;\n\tmlx4_zone_free_entries_unique(qp_table->zones, base_qpn, cnt);\n}\n\nvoid mlx4_qp_release_range(struct mlx4_dev *dev, int base_qpn, int cnt)\n{\n\tu64 in_param = 0;\n\tint err;\n\n\tif (!cnt)\n\t\treturn;\n\n\tif (mlx4_is_mfunc(dev)) {\n\t\tset_param_l(&in_param, base_qpn);\n\t\tset_param_h(&in_param, cnt);\n\t\terr = mlx4_cmd(dev, in_param, RES_QP, RES_OP_RESERVE,\n\t\t\t       MLX4_CMD_FREE_RES,\n\t\t\t       MLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n\t\tif (err) {\n\t\t\tmlx4_warn(dev, \"Failed to release qp range base:%d cnt:%d\\n\",\n\t\t\t\t  base_qpn, cnt);\n\t\t}\n\t} else\n\t\t __mlx4_qp_release_range(dev, base_qpn, cnt);\n}\nEXPORT_SYMBOL_GPL(mlx4_qp_release_range);\n\nint __mlx4_qp_alloc_icm(struct mlx4_dev *dev, int qpn)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_qp_table *qp_table = &priv->qp_table;\n\tint err;\n\n\terr = mlx4_table_get(dev, &qp_table->qp_table, qpn);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = mlx4_table_get(dev, &qp_table->auxc_table, qpn);\n\tif (err)\n\t\tgoto err_put_qp;\n\n\terr = mlx4_table_get(dev, &qp_table->altc_table, qpn);\n\tif (err)\n\t\tgoto err_put_auxc;\n\n\terr = mlx4_table_get(dev, &qp_table->rdmarc_table, qpn);\n\tif (err)\n\t\tgoto err_put_altc;\n\n\terr = mlx4_table_get(dev, &qp_table->cmpt_table, qpn);\n\tif (err)\n\t\tgoto err_put_rdmarc;\n\n\treturn 0;\n\nerr_put_rdmarc:\n\tmlx4_table_put(dev, &qp_table->rdmarc_table, qpn);\n\nerr_put_altc:\n\tmlx4_table_put(dev, &qp_table->altc_table, qpn);\n\nerr_put_auxc:\n\tmlx4_table_put(dev, &qp_table->auxc_table, qpn);\n\nerr_put_qp:\n\tmlx4_table_put(dev, &qp_table->qp_table, qpn);\n\nerr_out:\n\treturn err;\n}\n\nstatic int mlx4_qp_alloc_icm(struct mlx4_dev *dev, int qpn)\n{\n\tu64 param = 0;\n\n\tif (mlx4_is_mfunc(dev)) {\n\t\tset_param_l(&param, qpn);\n\t\treturn mlx4_cmd_imm(dev, param, &param, RES_QP, RES_OP_MAP_ICM,\n\t\t\t\t    MLX4_CMD_ALLOC_RES, MLX4_CMD_TIME_CLASS_A,\n\t\t\t\t    MLX4_CMD_WRAPPED);\n\t}\n\treturn __mlx4_qp_alloc_icm(dev, qpn);\n}\n\nvoid __mlx4_qp_free_icm(struct mlx4_dev *dev, int qpn)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_qp_table *qp_table = &priv->qp_table;\n\n\tmlx4_table_put(dev, &qp_table->cmpt_table, qpn);\n\tmlx4_table_put(dev, &qp_table->rdmarc_table, qpn);\n\tmlx4_table_put(dev, &qp_table->altc_table, qpn);\n\tmlx4_table_put(dev, &qp_table->auxc_table, qpn);\n\tmlx4_table_put(dev, &qp_table->qp_table, qpn);\n}\n\nstatic void mlx4_qp_free_icm(struct mlx4_dev *dev, int qpn)\n{\n\tu64 in_param = 0;\n\n\tif (mlx4_is_mfunc(dev)) {\n\t\tset_param_l(&in_param, qpn);\n\t\tif (mlx4_cmd(dev, in_param, RES_QP, RES_OP_MAP_ICM,\n\t\t\t     MLX4_CMD_FREE_RES, MLX4_CMD_TIME_CLASS_A,\n\t\t\t     MLX4_CMD_WRAPPED))\n\t\t\tmlx4_warn(dev, \"Failed to free icm of qp:%d\\n\", qpn);\n\t} else\n\t\t__mlx4_qp_free_icm(dev, qpn);\n}\n\nstruct mlx4_qp *mlx4_qp_lookup(struct mlx4_dev *dev, u32 qpn)\n{\n\tstruct mlx4_qp_table *qp_table = &mlx4_priv(dev)->qp_table;\n\tstruct mlx4_qp *qp;\n\n\tspin_lock_irq(&qp_table->lock);\n\n\tqp = __mlx4_qp_lookup(dev, qpn);\n\n\tspin_unlock_irq(&qp_table->lock);\n\treturn qp;\n}\n\nint mlx4_qp_alloc(struct mlx4_dev *dev, int qpn, struct mlx4_qp *qp)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_qp_table *qp_table = &priv->qp_table;\n\tint err;\n\n\tif (!qpn)\n\t\treturn -EINVAL;\n\n\tqp->qpn = qpn;\n\n\terr = mlx4_qp_alloc_icm(dev, qpn);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock_irq(&qp_table->lock);\n\terr = radix_tree_insert(&dev->qp_table_tree, qp->qpn &\n\t\t\t\t(dev->caps.num_qps - 1), qp);\n\tspin_unlock_irq(&qp_table->lock);\n\tif (err)\n\t\tgoto err_icm;\n\n\trefcount_set(&qp->refcount, 1);\n\tinit_completion(&qp->free);\n\n\treturn 0;\n\nerr_icm:\n\tmlx4_qp_free_icm(dev, qpn);\n\treturn err;\n}\n\nEXPORT_SYMBOL_GPL(mlx4_qp_alloc);\n\nint mlx4_update_qp(struct mlx4_dev *dev, u32 qpn,\n\t\t   enum mlx4_update_qp_attr attr,\n\t\t   struct mlx4_update_qp_params *params)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tstruct mlx4_update_qp_context *cmd;\n\tu64 pri_addr_path_mask = 0;\n\tu64 qp_mask = 0;\n\tint err = 0;\n\n\tif (!attr || (attr & ~MLX4_UPDATE_QP_SUPPORTED_ATTRS))\n\t\treturn -EINVAL;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tcmd = (struct mlx4_update_qp_context *)mailbox->buf;\n\n\tif (attr & MLX4_UPDATE_QP_SMAC) {\n\t\tpri_addr_path_mask |= 1ULL << MLX4_UPD_QP_PATH_MASK_MAC_INDEX;\n\t\tcmd->qp_context.pri_path.grh_mylmc = params->smac_index;\n\t}\n\n\tif (attr & MLX4_UPDATE_QP_ETH_SRC_CHECK_MC_LB) {\n\t\tif (!(dev->caps.flags2\n\t\t      & MLX4_DEV_CAP_FLAG2_UPDATE_QP_SRC_CHECK_LB)) {\n\t\t\tmlx4_warn(dev,\n\t\t\t\t  \"Trying to set src check LB, but it isn't supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tpri_addr_path_mask |=\n\t\t\t1ULL << MLX4_UPD_QP_PATH_MASK_ETH_SRC_CHECK_MC_LB;\n\t\tif (params->flags &\n\t\t    MLX4_UPDATE_QP_PARAMS_FLAGS_ETH_CHECK_MC_LB) {\n\t\t\tcmd->qp_context.pri_path.fl |=\n\t\t\t\tMLX4_FL_ETH_SRC_CHECK_MC_LB;\n\t\t}\n\t}\n\n\tif (attr & MLX4_UPDATE_QP_VSD) {\n\t\tqp_mask |= 1ULL << MLX4_UPD_QP_MASK_VSD;\n\t\tif (params->flags & MLX4_UPDATE_QP_PARAMS_FLAGS_VSD_ENABLE)\n\t\t\tcmd->qp_context.param3 |= cpu_to_be32(MLX4_STRIP_VLAN);\n\t}\n\n\tif (attr & MLX4_UPDATE_QP_RATE_LIMIT) {\n\t\tqp_mask |= 1ULL << MLX4_UPD_QP_MASK_RATE_LIMIT;\n\t\tcmd->qp_context.rate_limit_params = cpu_to_be16((params->rate_unit << 14) | params->rate_val);\n\t}\n\n\tif (attr & MLX4_UPDATE_QP_QOS_VPORT) {\n\t\tif (!(dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_QOS_VPP)) {\n\t\t\tmlx4_warn(dev, \"Granular QoS per VF is not enabled\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tqp_mask |= 1ULL << MLX4_UPD_QP_MASK_QOS_VPP;\n\t\tcmd->qp_context.qos_vport = params->qos_vport;\n\t}\n\n\tcmd->primary_addr_path_mask = cpu_to_be64(pri_addr_path_mask);\n\tcmd->qp_mask = cpu_to_be64(qp_mask);\n\n\terr = mlx4_cmd(dev, mailbox->dma, qpn & 0xffffff, 0,\n\t\t       MLX4_CMD_UPDATE_QP, MLX4_CMD_TIME_CLASS_A,\n\t\t       MLX4_CMD_NATIVE);\nout:\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx4_update_qp);\n\nvoid mlx4_qp_remove(struct mlx4_dev *dev, struct mlx4_qp *qp)\n{\n\tstruct mlx4_qp_table *qp_table = &mlx4_priv(dev)->qp_table;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qp_table->lock, flags);\n\tradix_tree_delete(&dev->qp_table_tree, qp->qpn & (dev->caps.num_qps - 1));\n\tspin_unlock_irqrestore(&qp_table->lock, flags);\n}\nEXPORT_SYMBOL_GPL(mlx4_qp_remove);\n\nvoid mlx4_qp_free(struct mlx4_dev *dev, struct mlx4_qp *qp)\n{\n\tmlx4_put_qp(qp);\n\twait_for_completion(&qp->free);\n\n\tmlx4_qp_free_icm(dev, qp->qpn);\n}\nEXPORT_SYMBOL_GPL(mlx4_qp_free);\n\nstatic int mlx4_CONF_SPECIAL_QP(struct mlx4_dev *dev, u32 base_qpn)\n{\n\treturn mlx4_cmd(dev, 0, base_qpn, 0, MLX4_CMD_CONF_SPECIAL_QP,\n\t\t\tMLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);\n}\n\n#define MLX4_QP_TABLE_RSS_ETH_PRIORITY 2\n#define MLX4_QP_TABLE_RAW_ETH_PRIORITY 1\n#define MLX4_QP_TABLE_RAW_ETH_SIZE     256\n\nstatic int mlx4_create_zones(struct mlx4_dev *dev,\n\t\t\t     u32 reserved_bottom_general,\n\t\t\t     u32 reserved_top_general,\n\t\t\t     u32 reserved_bottom_rss,\n\t\t\t     u32 start_offset_rss,\n\t\t\t     u32 max_table_offset)\n{\n\tstruct mlx4_qp_table *qp_table = &mlx4_priv(dev)->qp_table;\n\tstruct mlx4_bitmap (*bitmap)[MLX4_QP_TABLE_ZONE_NUM] = NULL;\n\tint bitmap_initialized = 0;\n\tu32 last_offset;\n\tint k;\n\tint err;\n\n\tqp_table->zones = mlx4_zone_allocator_create(MLX4_ZONE_ALLOC_FLAGS_NO_OVERLAP);\n\n\tif (NULL == qp_table->zones)\n\t\treturn -ENOMEM;\n\n\tbitmap = kmalloc(sizeof(*bitmap), GFP_KERNEL);\n\n\tif (NULL == bitmap) {\n\t\terr = -ENOMEM;\n\t\tgoto free_zone;\n\t}\n\n\terr = mlx4_bitmap_init(*bitmap + MLX4_QP_TABLE_ZONE_GENERAL, dev->caps.num_qps,\n\t\t\t       (1 << 23) - 1, reserved_bottom_general,\n\t\t\t       reserved_top_general);\n\n\tif (err)\n\t\tgoto free_bitmap;\n\n\t++bitmap_initialized;\n\n\terr = mlx4_zone_add_one(qp_table->zones, *bitmap + MLX4_QP_TABLE_ZONE_GENERAL,\n\t\t\t\tMLX4_ZONE_FALLBACK_TO_HIGHER_PRIO |\n\t\t\t\tMLX4_ZONE_USE_RR, 0,\n\t\t\t\t0, qp_table->zones_uids + MLX4_QP_TABLE_ZONE_GENERAL);\n\n\tif (err)\n\t\tgoto free_bitmap;\n\n\terr = mlx4_bitmap_init(*bitmap + MLX4_QP_TABLE_ZONE_RSS,\n\t\t\t       reserved_bottom_rss,\n\t\t\t       reserved_bottom_rss - 1,\n\t\t\t       dev->caps.reserved_qps_cnt[MLX4_QP_REGION_FW],\n\t\t\t       reserved_bottom_rss - start_offset_rss);\n\n\tif (err)\n\t\tgoto free_bitmap;\n\n\t++bitmap_initialized;\n\n\terr = mlx4_zone_add_one(qp_table->zones, *bitmap + MLX4_QP_TABLE_ZONE_RSS,\n\t\t\t\tMLX4_ZONE_ALLOW_ALLOC_FROM_LOWER_PRIO |\n\t\t\t\tMLX4_ZONE_ALLOW_ALLOC_FROM_EQ_PRIO |\n\t\t\t\tMLX4_ZONE_USE_RR, MLX4_QP_TABLE_RSS_ETH_PRIORITY,\n\t\t\t\t0, qp_table->zones_uids + MLX4_QP_TABLE_ZONE_RSS);\n\n\tif (err)\n\t\tgoto free_bitmap;\n\n\tlast_offset = dev->caps.reserved_qps_cnt[MLX4_QP_REGION_FW];\n\t \n\tfor (k = MLX4_QP_TABLE_ZONE_RSS + 1; k < sizeof(*bitmap)/sizeof((*bitmap)[0]);\n\t     k++) {\n\t\tint size;\n\t\tu32 offset = start_offset_rss;\n\t\tu32 bf_mask;\n\t\tu32 requested_size;\n\n\t\t \n\t\tbf_mask = (MLX4_BF_QP_SKIP_MASK & ~(MLX4_BF_QP_SKIP_MASK - 1)) - 1;\n\t\trequested_size = min((u32)MLX4_QP_TABLE_RAW_ETH_SIZE, bf_mask + 1);\n\n\t\tif (((last_offset & MLX4_BF_QP_SKIP_MASK) &&\n\t\t     ((int)(max_table_offset - last_offset)) >=\n\t\t     roundup_pow_of_two(MLX4_BF_QP_SKIP_MASK)) ||\n\t\t    (!(last_offset & MLX4_BF_QP_SKIP_MASK) &&\n\t\t     !((last_offset + requested_size - 1) &\n\t\t       MLX4_BF_QP_SKIP_MASK)))\n\t\t\tsize = requested_size;\n\t\telse {\n\t\t\tu32 candidate_offset =\n\t\t\t\t(last_offset | MLX4_BF_QP_SKIP_MASK | bf_mask) + 1;\n\n\t\t\tif (last_offset & MLX4_BF_QP_SKIP_MASK)\n\t\t\t\tlast_offset = candidate_offset;\n\n\t\t\t \n\n\t\t\tif (last_offset > max_table_offset) {\n\t\t\t\t \n\t\t\t\tsize = -1;\n\t\t\t} else {\n\t\t\t\tsize = min3(max_table_offset - last_offset,\n\t\t\t\t\t    bf_mask - (last_offset & bf_mask),\n\t\t\t\t\t    requested_size);\n\t\t\t\tif (size < requested_size) {\n\t\t\t\t\tint candidate_size;\n\n\t\t\t\t\tcandidate_size = min3(\n\t\t\t\t\t\tmax_table_offset - candidate_offset,\n\t\t\t\t\t\tbf_mask - (last_offset & bf_mask),\n\t\t\t\t\t\trequested_size);\n\n\t\t\t\t\t \n\t\t\t\t\tif (candidate_size > size) {\n\t\t\t\t\t\tlast_offset = candidate_offset;\n\t\t\t\t\t\tsize = candidate_size;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (size > 0) {\n\t\t\t \n\t\t\toffset = mlx4_bitmap_alloc_range(\n\t\t\t\t\t*bitmap + MLX4_QP_TABLE_ZONE_RSS,\n\t\t\t\t\tsize, 1,\n\t\t\t\t\tMLX4_BF_QP_SKIP_MASK);\n\n\t\t\tif (offset == (u32)-1) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlast_offset = offset + size;\n\n\t\t\terr = mlx4_bitmap_init(*bitmap + k, roundup_pow_of_two(size),\n\t\t\t\t\t       roundup_pow_of_two(size) - 1, 0,\n\t\t\t\t\t       roundup_pow_of_two(size) - size);\n\t\t} else {\n\t\t\t \n\t\t\terr = mlx4_bitmap_init(*bitmap + k, 1,\n\t\t\t\t\t       MLX4_QP_TABLE_RAW_ETH_SIZE - 1, 0,\n\t\t\t\t\t       0);\n\t\t\tif (!err)\n\t\t\t\tmlx4_bitmap_alloc_range(*bitmap + k, 1, 1, 0);\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t++bitmap_initialized;\n\n\t\terr = mlx4_zone_add_one(qp_table->zones, *bitmap + k,\n\t\t\t\t\tMLX4_ZONE_ALLOW_ALLOC_FROM_LOWER_PRIO |\n\t\t\t\t\tMLX4_ZONE_ALLOW_ALLOC_FROM_EQ_PRIO |\n\t\t\t\t\tMLX4_ZONE_USE_RR, MLX4_QP_TABLE_RAW_ETH_PRIORITY,\n\t\t\t\t\toffset, qp_table->zones_uids + k);\n\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (err)\n\t\tgoto free_bitmap;\n\n\tqp_table->bitmap_gen = *bitmap;\n\n\treturn err;\n\nfree_bitmap:\n\tfor (k = 0; k < bitmap_initialized; k++)\n\t\tmlx4_bitmap_cleanup(*bitmap + k);\n\tkfree(bitmap);\nfree_zone:\n\tmlx4_zone_allocator_destroy(qp_table->zones);\n\treturn err;\n}\n\nstatic void mlx4_cleanup_qp_zones(struct mlx4_dev *dev)\n{\n\tstruct mlx4_qp_table *qp_table = &mlx4_priv(dev)->qp_table;\n\n\tif (qp_table->zones) {\n\t\tint i;\n\n\t\tfor (i = 0;\n\t\t     i < ARRAY_SIZE(qp_table->zones_uids);\n\t\t     i++) {\n\t\t\tstruct mlx4_bitmap *bitmap =\n\t\t\t\tmlx4_zone_get_bitmap(qp_table->zones,\n\t\t\t\t\t\t     qp_table->zones_uids[i]);\n\n\t\t\tmlx4_zone_remove_one(qp_table->zones, qp_table->zones_uids[i]);\n\t\t\tif (NULL == bitmap)\n\t\t\t\tcontinue;\n\n\t\t\tmlx4_bitmap_cleanup(bitmap);\n\t\t}\n\t\tmlx4_zone_allocator_destroy(qp_table->zones);\n\t\tkfree(qp_table->bitmap_gen);\n\t\tqp_table->bitmap_gen = NULL;\n\t\tqp_table->zones = NULL;\n\t}\n}\n\nint mlx4_init_qp_table(struct mlx4_dev *dev)\n{\n\tstruct mlx4_qp_table *qp_table = &mlx4_priv(dev)->qp_table;\n\tint err;\n\tint reserved_from_top = 0;\n\tint reserved_from_bot;\n\tint k;\n\tint fixed_reserved_from_bot_rv = 0;\n\tint bottom_reserved_for_rss_bitmap;\n\tu32 max_table_offset = dev->caps.dmfs_high_rate_qpn_base +\n\t\t\tdev->caps.dmfs_high_rate_qpn_range;\n\n\tspin_lock_init(&qp_table->lock);\n\tINIT_RADIX_TREE(&dev->qp_table_tree, GFP_ATOMIC);\n\tif (mlx4_is_slave(dev))\n\t\treturn 0;\n\n\t \n\tfor (k = 0; k <= MLX4_QP_REGION_BOTTOM; k++)\n\t\tfixed_reserved_from_bot_rv += dev->caps.reserved_qps_cnt[k];\n\n\tif (fixed_reserved_from_bot_rv < max_table_offset)\n\t\tfixed_reserved_from_bot_rv = max_table_offset;\n\n\t \n\tbottom_reserved_for_rss_bitmap =\n\t\troundup_pow_of_two(fixed_reserved_from_bot_rv + 1);\n\tdev->phys_caps.base_sqpn = ALIGN(bottom_reserved_for_rss_bitmap, 8);\n\n\t{\n\t\tint sort[MLX4_NUM_QP_REGION];\n\t\tint i, j;\n\t\tint last_base = dev->caps.num_qps;\n\n\t\tfor (i = 1; i < MLX4_NUM_QP_REGION; ++i)\n\t\t\tsort[i] = i;\n\n\t\tfor (i = MLX4_NUM_QP_REGION; i > MLX4_QP_REGION_BOTTOM; --i) {\n\t\t\tfor (j = MLX4_QP_REGION_BOTTOM + 2; j < i; ++j) {\n\t\t\t\tif (dev->caps.reserved_qps_cnt[sort[j]] >\n\t\t\t\t    dev->caps.reserved_qps_cnt[sort[j - 1]])\n\t\t\t\t\tswap(sort[j], sort[j - 1]);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = MLX4_QP_REGION_BOTTOM + 1; i < MLX4_NUM_QP_REGION; ++i) {\n\t\t\tlast_base -= dev->caps.reserved_qps_cnt[sort[i]];\n\t\t\tdev->caps.reserved_qps_base[sort[i]] = last_base;\n\t\t\treserved_from_top +=\n\t\t\t\tdev->caps.reserved_qps_cnt[sort[i]];\n\t\t}\n\t}\n\n        \n\treserved_from_bot = mlx4_num_reserved_sqps(dev);\n\tif (reserved_from_bot + reserved_from_top > dev->caps.num_qps) {\n\t\tmlx4_err(dev, \"Number of reserved QPs is higher than number of QPs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = mlx4_create_zones(dev, reserved_from_bot, reserved_from_bot,\n\t\t\t\tbottom_reserved_for_rss_bitmap,\n\t\t\t\tfixed_reserved_from_bot_rv,\n\t\t\t\tmax_table_offset);\n\n\tif (err)\n\t\treturn err;\n\n\tif (mlx4_is_mfunc(dev)) {\n\t\t \n\t\tdev->phys_caps.base_proxy_sqpn = dev->phys_caps.base_sqpn + 8;\n\t\tdev->phys_caps.base_tunnel_sqpn = dev->phys_caps.base_sqpn + 8 + 8 * MLX4_MFUNC_MAX;\n\n\t\t \n\t\tdev->caps.spec_qps = kcalloc(dev->caps.num_ports,\n\t\t\t\t\t     sizeof(*dev->caps.spec_qps),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!dev->caps.spec_qps) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_mem;\n\t\t}\n\n\t\tfor (k = 0; k < dev->caps.num_ports; k++) {\n\t\t\tdev->caps.spec_qps[k].qp0_proxy = dev->phys_caps.base_proxy_sqpn +\n\t\t\t\t8 * mlx4_master_func_num(dev) + k;\n\t\t\tdev->caps.spec_qps[k].qp0_tunnel = dev->caps.spec_qps[k].qp0_proxy + 8 * MLX4_MFUNC_MAX;\n\t\t\tdev->caps.spec_qps[k].qp1_proxy = dev->phys_caps.base_proxy_sqpn +\n\t\t\t\t8 * mlx4_master_func_num(dev) + MLX4_MAX_PORTS + k;\n\t\t\tdev->caps.spec_qps[k].qp1_tunnel = dev->caps.spec_qps[k].qp1_proxy + 8 * MLX4_MFUNC_MAX;\n\t\t}\n\t}\n\n\n\terr = mlx4_CONF_SPECIAL_QP(dev, dev->phys_caps.base_sqpn);\n\tif (err)\n\t\tgoto err_mem;\n\n\treturn err;\n\nerr_mem:\n\tkfree(dev->caps.spec_qps);\n\tdev->caps.spec_qps = NULL;\n\tmlx4_cleanup_qp_zones(dev);\n\treturn err;\n}\n\nvoid mlx4_cleanup_qp_table(struct mlx4_dev *dev)\n{\n\tif (mlx4_is_slave(dev))\n\t\treturn;\n\n\tmlx4_CONF_SPECIAL_QP(dev, 0);\n\n\tmlx4_cleanup_qp_zones(dev);\n}\n\nint mlx4_qp_query(struct mlx4_dev *dev, struct mlx4_qp *qp,\n\t\t  struct mlx4_qp_context *context)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tint err;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\terr = mlx4_cmd_box(dev, 0, mailbox->dma, qp->qpn, 0,\n\t\t\t   MLX4_CMD_QUERY_QP, MLX4_CMD_TIME_CLASS_A,\n\t\t\t   MLX4_CMD_WRAPPED);\n\tif (!err)\n\t\tmemcpy(context, mailbox->buf + 8, sizeof(*context));\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx4_qp_query);\n\nint mlx4_qp_to_ready(struct mlx4_dev *dev, struct mlx4_mtt *mtt,\n\t\t     struct mlx4_qp_context *context,\n\t\t     struct mlx4_qp *qp, enum mlx4_qp_state *qp_state)\n{\n\tint err;\n\tint i;\n\tstatic const enum mlx4_qp_state states[] = {\n\t\tMLX4_QP_STATE_RST,\n\t\tMLX4_QP_STATE_INIT,\n\t\tMLX4_QP_STATE_RTR,\n\t\tMLX4_QP_STATE_RTS\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(states) - 1; i++) {\n\t\tcontext->flags &= cpu_to_be32(~(0xf << 28));\n\t\tcontext->flags |= cpu_to_be32(states[i + 1] << 28);\n\t\tif (states[i + 1] != MLX4_QP_STATE_RTR)\n\t\t\tcontext->params2 &= ~cpu_to_be32(MLX4_QP_BIT_FPP);\n\t\terr = mlx4_qp_modify(dev, mtt, states[i], states[i + 1],\n\t\t\t\t     context, 0, 0, qp);\n\t\tif (err) {\n\t\t\tmlx4_err(dev, \"Failed to bring QP to state: %d with error: %d\\n\",\n\t\t\t\t states[i + 1], err);\n\t\t\treturn err;\n\t\t}\n\n\t\t*qp_state = states[i + 1];\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx4_qp_to_ready);\n\nu16 mlx4_qp_roce_entropy(struct mlx4_dev *dev, u32 qpn)\n{\n\tstruct mlx4_qp_context context;\n\tstruct mlx4_qp qp;\n\tint err;\n\n\tqp.qpn = qpn;\n\terr = mlx4_qp_query(dev, &qp, &context);\n\tif (!err) {\n\t\tu32 dest_qpn = be32_to_cpu(context.remote_qpn) & 0xffffff;\n\t\tu16 folded_dst = folded_qp(dest_qpn);\n\t\tu16 folded_src = folded_qp(qpn);\n\n\t\treturn (dest_qpn != qpn) ?\n\t\t\t((folded_dst ^ folded_src) | 0xC000) :\n\t\t\tfolded_src | 0xC000;\n\t}\n\treturn 0xdead;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}