{
  "module_name": "pd.c",
  "hash_id": "de3094d97304aebbb2d48629c4cbfa7958d6105f428097aa3199a06b70277a2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/pd.c",
  "human_readable_source": " \n\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/io-mapping.h>\n\n#include <asm/page.h>\n\n#include \"mlx4.h\"\n#include \"icm.h\"\n\nenum {\n\tMLX4_NUM_RESERVED_UARS = 8\n};\n\nint mlx4_pd_alloc(struct mlx4_dev *dev, u32 *pdn)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\t*pdn = mlx4_bitmap_alloc(&priv->pd_bitmap);\n\tif (*pdn == -1)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx4_pd_alloc);\n\nvoid mlx4_pd_free(struct mlx4_dev *dev, u32 pdn)\n{\n\tmlx4_bitmap_free(&mlx4_priv(dev)->pd_bitmap, pdn, MLX4_USE_RR);\n}\nEXPORT_SYMBOL_GPL(mlx4_pd_free);\n\nint __mlx4_xrcd_alloc(struct mlx4_dev *dev, u32 *xrcdn)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\t*xrcdn = mlx4_bitmap_alloc(&priv->xrcd_bitmap);\n\tif (*xrcdn == -1)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint mlx4_xrcd_alloc(struct mlx4_dev *dev, u32 *xrcdn)\n{\n\tu64 out_param;\n\tint err;\n\n\tif (mlx4_is_mfunc(dev)) {\n\t\terr = mlx4_cmd_imm(dev, 0, &out_param,\n\t\t\t\t   RES_XRCD, RES_OP_RESERVE,\n\t\t\t\t   MLX4_CMD_ALLOC_RES,\n\t\t\t\t   MLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*xrcdn = get_param_l(&out_param);\n\t\treturn 0;\n\t}\n\treturn __mlx4_xrcd_alloc(dev, xrcdn);\n}\nEXPORT_SYMBOL_GPL(mlx4_xrcd_alloc);\n\nvoid __mlx4_xrcd_free(struct mlx4_dev *dev, u32 xrcdn)\n{\n\tmlx4_bitmap_free(&mlx4_priv(dev)->xrcd_bitmap, xrcdn, MLX4_USE_RR);\n}\n\nvoid mlx4_xrcd_free(struct mlx4_dev *dev, u32 xrcdn)\n{\n\tu64 in_param = 0;\n\tint err;\n\n\tif (mlx4_is_mfunc(dev)) {\n\t\tset_param_l(&in_param, xrcdn);\n\t\terr = mlx4_cmd(dev, in_param, RES_XRCD,\n\t\t\t       RES_OP_RESERVE, MLX4_CMD_FREE_RES,\n\t\t\t       MLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n\t\tif (err)\n\t\t\tmlx4_warn(dev, \"Failed to release xrcdn %d\\n\", xrcdn);\n\t} else\n\t\t__mlx4_xrcd_free(dev, xrcdn);\n}\nEXPORT_SYMBOL_GPL(mlx4_xrcd_free);\n\nint mlx4_init_pd_table(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\treturn mlx4_bitmap_init(&priv->pd_bitmap, dev->caps.num_pds,\n\t\t\t\t(1 << NOT_MASKED_PD_BITS) - 1,\n\t\t\t\t dev->caps.reserved_pds, 0);\n}\n\nvoid mlx4_cleanup_pd_table(struct mlx4_dev *dev)\n{\n\tmlx4_bitmap_cleanup(&mlx4_priv(dev)->pd_bitmap);\n}\n\nint mlx4_init_xrcd_table(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\treturn mlx4_bitmap_init(&priv->xrcd_bitmap, (1 << 16),\n\t\t\t\t(1 << 16) - 1, dev->caps.reserved_xrcds + 1, 0);\n}\n\nvoid mlx4_cleanup_xrcd_table(struct mlx4_dev *dev)\n{\n\tmlx4_bitmap_cleanup(&mlx4_priv(dev)->xrcd_bitmap);\n}\n\nint mlx4_uar_alloc(struct mlx4_dev *dev, struct mlx4_uar *uar)\n{\n\tint offset;\n\n\tuar->index = mlx4_bitmap_alloc(&mlx4_priv(dev)->uar_table.bitmap);\n\tif (uar->index == -1)\n\t\treturn -ENOMEM;\n\n\tif (mlx4_is_slave(dev))\n\t\toffset = uar->index % ((int)pci_resource_len(dev->persist->pdev,\n\t\t\t\t\t\t\t     2) /\n\t\t\t\t       dev->caps.uar_page_size);\n\telse\n\t\toffset = uar->index;\n\tuar->pfn = (pci_resource_start(dev->persist->pdev, 2) >> PAGE_SHIFT)\n\t\t    + offset;\n\tuar->map = NULL;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mlx4_uar_alloc);\n\nvoid mlx4_uar_free(struct mlx4_dev *dev, struct mlx4_uar *uar)\n{\n\tmlx4_bitmap_free(&mlx4_priv(dev)->uar_table.bitmap, uar->index, MLX4_USE_RR);\n}\nEXPORT_SYMBOL_GPL(mlx4_uar_free);\n\nint mlx4_bf_alloc(struct mlx4_dev *dev, struct mlx4_bf *bf, int node)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_uar *uar;\n\tint err = 0;\n\tint idx;\n\n\tif (!priv->bf_mapping)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&priv->bf_mutex);\n\tif (!list_empty(&priv->bf_list))\n\t\tuar = list_entry(priv->bf_list.next, struct mlx4_uar, bf_list);\n\telse {\n\t\tif (mlx4_bitmap_avail(&priv->uar_table.bitmap) < MLX4_NUM_RESERVED_UARS) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tuar = kmalloc_node(sizeof(*uar), GFP_KERNEL, node);\n\t\tif (!uar) {\n\t\t\tuar = kmalloc(sizeof(*uar), GFP_KERNEL);\n\t\t\tif (!uar) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\terr = mlx4_uar_alloc(dev, uar);\n\t\tif (err)\n\t\t\tgoto free_kmalloc;\n\n\t\tuar->map = ioremap(uar->pfn << PAGE_SHIFT, PAGE_SIZE);\n\t\tif (!uar->map) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_uar;\n\t\t}\n\n\t\tuar->bf_map = io_mapping_map_wc(priv->bf_mapping,\n\t\t\t\t\t\tuar->index << PAGE_SHIFT,\n\t\t\t\t\t\tPAGE_SIZE);\n\t\tif (!uar->bf_map) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unamp_uar;\n\t\t}\n\t\tuar->free_bf_bmap = 0;\n\t\tlist_add(&uar->bf_list, &priv->bf_list);\n\t}\n\n\tidx = ffz(uar->free_bf_bmap);\n\tuar->free_bf_bmap |= 1 << idx;\n\tbf->uar = uar;\n\tbf->offset = 0;\n\tbf->buf_size = dev->caps.bf_reg_size / 2;\n\tbf->reg = uar->bf_map + idx * dev->caps.bf_reg_size;\n\tif (uar->free_bf_bmap == (1 << dev->caps.bf_regs_per_page) - 1)\n\t\tlist_del_init(&uar->bf_list);\n\n\tgoto out;\n\nunamp_uar:\n\tbf->uar = NULL;\n\tiounmap(uar->map);\n\nfree_uar:\n\tmlx4_uar_free(dev, uar);\n\nfree_kmalloc:\n\tkfree(uar);\n\nout:\n\tmutex_unlock(&priv->bf_mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx4_bf_alloc);\n\nvoid mlx4_bf_free(struct mlx4_dev *dev, struct mlx4_bf *bf)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint idx;\n\n\tif (!bf->uar || !bf->uar->bf_map)\n\t\treturn;\n\n\tmutex_lock(&priv->bf_mutex);\n\tidx = (bf->reg - bf->uar->bf_map) / dev->caps.bf_reg_size;\n\tbf->uar->free_bf_bmap &= ~(1 << idx);\n\tif (!bf->uar->free_bf_bmap) {\n\t\tif (!list_empty(&bf->uar->bf_list))\n\t\t\tlist_del(&bf->uar->bf_list);\n\n\t\tio_mapping_unmap(bf->uar->bf_map);\n\t\tiounmap(bf->uar->map);\n\t\tmlx4_uar_free(dev, bf->uar);\n\t\tkfree(bf->uar);\n\t} else if (list_empty(&bf->uar->bf_list))\n\t\tlist_add(&bf->uar->bf_list, &priv->bf_list);\n\n\tmutex_unlock(&priv->bf_mutex);\n}\nEXPORT_SYMBOL_GPL(mlx4_bf_free);\n\nint mlx4_init_uar_table(struct mlx4_dev *dev)\n{\n\tint num_reserved_uar = mlx4_get_num_reserved_uar(dev);\n\n\tmlx4_dbg(dev, \"uar_page_shift = %d\", dev->uar_page_shift);\n\tmlx4_dbg(dev, \"Effective reserved_uars=%d\", dev->caps.reserved_uars);\n\n\tif (dev->caps.num_uars <= num_reserved_uar) {\n\t\tmlx4_err(\n\t\t\tdev, \"Only %d UAR pages (need more than %d)\\n\",\n\t\t\tdev->caps.num_uars, num_reserved_uar);\n\t\tmlx4_err(dev, \"Increase firmware log2_uar_bar_megabytes?\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn mlx4_bitmap_init(&mlx4_priv(dev)->uar_table.bitmap,\n\t\t\t\tdev->caps.num_uars, dev->caps.num_uars - 1,\n\t\t\t\tdev->caps.reserved_uars, 0);\n}\n\nvoid mlx4_cleanup_uar_table(struct mlx4_dev *dev)\n{\n\tmlx4_bitmap_cleanup(&mlx4_priv(dev)->uar_table.bitmap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}