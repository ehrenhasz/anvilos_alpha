{
  "module_name": "port.c",
  "hash_id": "2081fbf771cca50e317d7438d790813c5d44cd9157888a12a6ad16d2fb248f27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/port.c",
  "human_readable_source": " \n\n#include <linux/errno.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/export.h>\n\n#include <linux/mlx4/cmd.h>\n\n#include \"mlx4.h\"\n#include \"mlx4_stats.h\"\n\n#define MLX4_MAC_VALID\t\t(1ull << 63)\n\n#define MLX4_VLAN_VALID\t\t(1u << 31)\n#define MLX4_VLAN_MASK\t\t0xfff\n\n#define MLX4_STATS_TRAFFIC_COUNTERS_MASK\t0xfULL\n#define MLX4_STATS_TRAFFIC_DROPS_MASK\t\t0xc0ULL\n#define MLX4_STATS_ERROR_COUNTERS_MASK\t\t0x1ffc30ULL\n#define MLX4_STATS_PORT_COUNTERS_MASK\t\t0x1fe00000ULL\n\n#define MLX4_FLAG2_V_IGNORE_FCS_MASK\t\tBIT(1)\n#define MLX4_FLAG2_V_USER_MTU_MASK\t\tBIT(5)\n#define MLX4_FLAG2_V_USER_MAC_MASK\t\tBIT(6)\n#define MLX4_FLAG_V_MTU_MASK\t\t\tBIT(0)\n#define MLX4_FLAG_V_PPRX_MASK\t\t\tBIT(1)\n#define MLX4_FLAG_V_PPTX_MASK\t\t\tBIT(2)\n#define MLX4_IGNORE_FCS_MASK\t\t\t0x1\n#define MLX4_TC_MAX_NUMBER\t\t\t8\n\nvoid mlx4_init_mac_table(struct mlx4_dev *dev, struct mlx4_mac_table *table)\n{\n\tint i;\n\n\tmutex_init(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM; i++) {\n\t\ttable->entries[i] = 0;\n\t\ttable->refs[i]\t = 0;\n\t\ttable->is_dup[i] = false;\n\t}\n\ttable->max   = 1 << dev->caps.log_num_macs;\n\ttable->total = 0;\n}\n\nvoid mlx4_init_vlan_table(struct mlx4_dev *dev, struct mlx4_vlan_table *table)\n{\n\tint i;\n\n\tmutex_init(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\ttable->entries[i] = 0;\n\t\ttable->refs[i]\t = 0;\n\t\ttable->is_dup[i] = false;\n\t}\n\ttable->max   = (1 << dev->caps.log_num_vlans) - MLX4_VLAN_REGULAR;\n\ttable->total = 0;\n}\n\nvoid mlx4_init_roce_gid_table(struct mlx4_dev *dev,\n\t\t\t      struct mlx4_roce_gid_table *table)\n{\n\tint i;\n\n\tmutex_init(&table->mutex);\n\tfor (i = 0; i < MLX4_ROCE_MAX_GIDS; i++)\n\t\tmemset(table->roce_gids[i].raw, 0, MLX4_ROCE_GID_ENTRY_SIZE);\n}\n\nstatic int validate_index(struct mlx4_dev *dev,\n\t\t\t  struct mlx4_mac_table *table, int index)\n{\n\tint err = 0;\n\n\tif (index < 0 || index >= table->max || !table->entries[index]) {\n\t\tmlx4_warn(dev, \"No valid Mac entry for the given index\\n\");\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic int find_index(struct mlx4_dev *dev,\n\t\t      struct mlx4_mac_table *table, u64 mac)\n{\n\tint i;\n\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM; i++) {\n\t\tif (table->refs[i] &&\n\t\t    (MLX4_MAC_MASK & mac) ==\n\t\t    (MLX4_MAC_MASK & be64_to_cpu(table->entries[i])))\n\t\t\treturn i;\n\t}\n\t \n\treturn -EINVAL;\n}\n\nstatic int mlx4_set_port_mac_table(struct mlx4_dev *dev, u8 port,\n\t\t\t\t   __be64 *entries)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tu32 in_mod;\n\tint err;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tmemcpy(mailbox->buf, entries, MLX4_MAC_TABLE_SIZE);\n\n\tin_mod = MLX4_SET_PORT_MAC_TABLE << 8 | port;\n\n\terr = mlx4_cmd(dev, mailbox->dma, in_mod, MLX4_SET_PORT_ETH_OPCODE,\n\t\t       MLX4_CMD_SET_PORT, MLX4_CMD_TIME_CLASS_B,\n\t\t       MLX4_CMD_NATIVE);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mlx4_find_cached_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *idx)\n{\n\tstruct mlx4_port_info *info = &mlx4_priv(dev)->port[port];\n\tstruct mlx4_mac_table *table = &info->mac_table;\n\tint i;\n\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM; i++) {\n\t\tif (!table->refs[i])\n\t\t\tcontinue;\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t*idx = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(mlx4_find_cached_mac);\n\nstatic bool mlx4_need_mf_bond(struct mlx4_dev *dev)\n{\n\tint i, num_eth_ports = 0;\n\n\tif (!mlx4_is_mfunc(dev))\n\t\treturn false;\n\tmlx4_foreach_port(i, dev, MLX4_PORT_TYPE_ETH)\n\t\t++num_eth_ports;\n\n\treturn (num_eth_ports ==  2) ? true : false;\n}\n\nint __mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac)\n{\n\tstruct mlx4_port_info *info = &mlx4_priv(dev)->port[port];\n\tstruct mlx4_mac_table *table = &info->mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\tint free_for_dup = -1;\n\tbool dup = mlx4_is_mf_bonded(dev);\n\tu8 dup_port = (port == 1) ? 2 : 1;\n\tstruct mlx4_mac_table *dup_table = &mlx4_priv(dev)->port[dup_port].mac_table;\n\tbool need_mf_bond = mlx4_need_mf_bond(dev);\n\tbool can_mf_bond = true;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx for port %d %s duplicate\\n\",\n\t\t (unsigned long long)mac, port,\n\t\t dup ? \"with\" : \"without\");\n\n\tif (need_mf_bond) {\n\t\tif (port == 1) {\n\t\t\tmutex_lock(&table->mutex);\n\t\t\tmutex_lock_nested(&dup_table->mutex, SINGLE_DEPTH_NESTING);\n\t\t} else {\n\t\t\tmutex_lock(&dup_table->mutex);\n\t\t\tmutex_lock_nested(&table->mutex, SINGLE_DEPTH_NESTING);\n\t\t}\n\t} else {\n\t\tmutex_lock(&table->mutex);\n\t}\n\n\tif (need_mf_bond) {\n\t\tint index_at_port = -1;\n\t\tint index_at_dup_port = -1;\n\n\t\tfor (i = 0; i < MLX4_MAX_MAC_NUM; i++) {\n\t\t\tif (((MLX4_MAC_MASK & mac) == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))))\n\t\t\t\tindex_at_port = i;\n\t\t\tif (((MLX4_MAC_MASK & mac) == (MLX4_MAC_MASK & be64_to_cpu(dup_table->entries[i]))))\n\t\t\t\tindex_at_dup_port = i;\n\t\t}\n\n\t\t \n\t\tif ((index_at_port != index_at_dup_port) &&\n\t\t    (index_at_port >= 0) &&\n\t\t    (index_at_dup_port >= 0))\n\t\t\tcan_mf_bond = false;\n\n\t\t \n\t\tif (index_at_port >= 0 && index_at_dup_port < 0 &&\n\t\t    dup_table->refs[index_at_port]) {\n\t\t\tcan_mf_bond = false;\n\t\t}\n\t\t \n\t\tif (index_at_dup_port >= 0) {\n\t\t\tif (!table->refs[index_at_dup_port] ||\n\t\t\t    ((MLX4_MAC_MASK & mac) == (MLX4_MAC_MASK & be64_to_cpu(table->entries[index_at_dup_port]))))\n\t\t\t\tfree_for_dup = index_at_dup_port;\n\t\t\telse\n\t\t\t\tcan_mf_bond = false;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM; i++) {\n\t\tif (!table->refs[i]) {\n\t\t\tif (free < 0)\n\t\t\t\tfree = i;\n\t\t\tif (free_for_dup < 0 && need_mf_bond && can_mf_bond) {\n\t\t\t\tif (!dup_table->refs[i])\n\t\t\t\t\tfree_for_dup = i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((MLX4_MAC_MASK & mac) ==\n\t\t     (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t \n\t\t\terr = i;\n\t\t\t++table->refs[i];\n\t\t\tif (dup) {\n\t\t\t\tu64 dup_mac = MLX4_MAC_MASK & be64_to_cpu(dup_table->entries[i]);\n\n\t\t\t\tif (dup_mac != mac || !dup_table->is_dup[i]) {\n\t\t\t\t\tmlx4_warn(dev, \"register mac: expect duplicate mac 0x%llx on port %d index %d\\n\",\n\t\t\t\t\t\t  mac, dup_port, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (need_mf_bond && (free_for_dup < 0)) {\n\t\tif (dup) {\n\t\t\tmlx4_warn(dev, \"Fail to allocate duplicate MAC table entry\\n\");\n\t\t\tmlx4_warn(dev, \"High Availability for virtual functions may not work as expected\\n\");\n\t\t\tdup = false;\n\t\t}\n\t\tcan_mf_bond = false;\n\t}\n\n\tif (need_mf_bond && can_mf_bond)\n\t\tfree = free_for_dup;\n\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\n\tif (table->total == table->max) {\n\t\t \n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t \n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\",\n\t\t\t (unsigned long long) mac);\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->is_dup[free] = false;\n\t++table->total;\n\tif (dup) {\n\t\tdup_table->refs[free] = 0;\n\t\tdup_table->is_dup[free] = true;\n\t\tdup_table->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\t\terr = mlx4_set_port_mac_table(dev, dup_port, dup_table->entries);\n\t\tif (unlikely(err)) {\n\t\t\tmlx4_warn(dev, \"Failed adding duplicate mac: 0x%llx\\n\", mac);\n\t\t\tdup_table->is_dup[free] = false;\n\t\t\tdup_table->entries[free] = 0;\n\t\t\tgoto out;\n\t\t}\n\t\t++dup_table->total;\n\t}\n\terr = free;\nout:\n\tif (need_mf_bond) {\n\t\tif (port == 2) {\n\t\t\tmutex_unlock(&table->mutex);\n\t\t\tmutex_unlock(&dup_table->mutex);\n\t\t} else {\n\t\t\tmutex_unlock(&dup_table->mutex);\n\t\t\tmutex_unlock(&table->mutex);\n\t\t}\n\t} else {\n\t\tmutex_unlock(&table->mutex);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(__mlx4_register_mac);\n\nint mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac)\n{\n\tu64 out_param = 0;\n\tint err = -EINVAL;\n\n\tif (mlx4_is_mfunc(dev)) {\n\t\tif (!(dev->flags & MLX4_FLAG_OLD_REG_MAC)) {\n\t\t\terr = mlx4_cmd_imm(dev, mac, &out_param,\n\t\t\t\t\t   ((u32) port) << 8 | (u32) RES_MAC,\n\t\t\t\t\t   RES_OP_RESERVE_AND_MAP, MLX4_CMD_ALLOC_RES,\n\t\t\t\t\t   MLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n\t\t}\n\t\tif (err && err == -EINVAL && mlx4_is_slave(dev)) {\n\t\t\t \n\t\t\tset_param_l(&out_param, port);\n\t\t\terr = mlx4_cmd_imm(dev, mac, &out_param, RES_MAC,\n\t\t\t\t\t   RES_OP_RESERVE_AND_MAP, MLX4_CMD_ALLOC_RES,\n\t\t\t\t\t   MLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n\t\t\tif (!err)\n\t\t\t\tdev->flags |= MLX4_FLAG_OLD_REG_MAC;\n\t\t}\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn get_param_l(&out_param);\n\t}\n\treturn __mlx4_register_mac(dev, port, mac);\n}\nEXPORT_SYMBOL_GPL(mlx4_register_mac);\n\nint mlx4_get_base_qpn(struct mlx4_dev *dev, u8 port)\n{\n\treturn dev->caps.reserved_qps_base[MLX4_QP_REGION_ETH_ADDR] +\n\t\t\t(port - 1) * (1 << dev->caps.log_num_macs);\n}\nEXPORT_SYMBOL_GPL(mlx4_get_base_qpn);\n\nvoid __mlx4_unregister_mac(struct mlx4_dev *dev, u8 port, u64 mac)\n{\n\tstruct mlx4_port_info *info;\n\tstruct mlx4_mac_table *table;\n\tint index;\n\tbool dup = mlx4_is_mf_bonded(dev);\n\tu8 dup_port = (port == 1) ? 2 : 1;\n\tstruct mlx4_mac_table *dup_table = &mlx4_priv(dev)->port[dup_port].mac_table;\n\n\tif (port < 1 || port > dev->caps.num_ports) {\n\t\tmlx4_warn(dev, \"invalid port number (%d), aborting...\\n\", port);\n\t\treturn;\n\t}\n\tinfo = &mlx4_priv(dev)->port[port];\n\ttable = &info->mac_table;\n\n\tif (dup) {\n\t\tif (port == 1) {\n\t\t\tmutex_lock(&table->mutex);\n\t\t\tmutex_lock_nested(&dup_table->mutex, SINGLE_DEPTH_NESTING);\n\t\t} else {\n\t\t\tmutex_lock(&dup_table->mutex);\n\t\t\tmutex_lock_nested(&table->mutex, SINGLE_DEPTH_NESTING);\n\t\t}\n\t} else {\n\t\tmutex_lock(&table->mutex);\n\t}\n\n\tindex = find_index(dev, table, mac);\n\n\tif (validate_index(dev, table, index))\n\t\tgoto out;\n\n\tif (--table->refs[index] || table->is_dup[index]) {\n\t\tmlx4_dbg(dev, \"Have more references for index %d, no need to modify mac table\\n\",\n\t\t\t index);\n\t\tif (!table->refs[index])\n\t\t\tdup_table->is_dup[index] = false;\n\t\tgoto out;\n\t}\n\n\ttable->entries[index] = 0;\n\tif (mlx4_set_port_mac_table(dev, port, table->entries))\n\t\tmlx4_warn(dev, \"Fail to set mac in port %d during unregister\\n\", port);\n\t--table->total;\n\n\tif (dup) {\n\t\tdup_table->is_dup[index] = false;\n\t\tif (dup_table->refs[index])\n\t\t\tgoto out;\n\t\tdup_table->entries[index] = 0;\n\t\tif (mlx4_set_port_mac_table(dev, dup_port, dup_table->entries))\n\t\t\tmlx4_warn(dev, \"Fail to set mac in duplicate port %d during unregister\\n\", dup_port);\n\n\t\t--table->total;\n\t}\nout:\n\tif (dup) {\n\t\tif (port == 2) {\n\t\t\tmutex_unlock(&table->mutex);\n\t\t\tmutex_unlock(&dup_table->mutex);\n\t\t} else {\n\t\t\tmutex_unlock(&dup_table->mutex);\n\t\t\tmutex_unlock(&table->mutex);\n\t\t}\n\t} else {\n\t\tmutex_unlock(&table->mutex);\n\t}\n}\nEXPORT_SYMBOL_GPL(__mlx4_unregister_mac);\n\nvoid mlx4_unregister_mac(struct mlx4_dev *dev, u8 port, u64 mac)\n{\n\tu64 out_param = 0;\n\n\tif (mlx4_is_mfunc(dev)) {\n\t\tif (!(dev->flags & MLX4_FLAG_OLD_REG_MAC)) {\n\t\t\t(void) mlx4_cmd_imm(dev, mac, &out_param,\n\t\t\t\t\t    ((u32) port) << 8 | (u32) RES_MAC,\n\t\t\t\t\t    RES_OP_RESERVE_AND_MAP, MLX4_CMD_FREE_RES,\n\t\t\t\t\t    MLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n\t\t} else {\n\t\t\t \n\t\t\tset_param_l(&out_param, port);\n\t\t\t(void) mlx4_cmd_imm(dev, mac, &out_param, RES_MAC,\n\t\t\t\t\t    RES_OP_RESERVE_AND_MAP, MLX4_CMD_FREE_RES,\n\t\t\t\t\t    MLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n\t\t}\n\t\treturn;\n\t}\n\t__mlx4_unregister_mac(dev, port, mac);\n\treturn;\n}\nEXPORT_SYMBOL_GPL(mlx4_unregister_mac);\n\nint __mlx4_replace_mac(struct mlx4_dev *dev, u8 port, int qpn, u64 new_mac)\n{\n\tstruct mlx4_port_info *info = &mlx4_priv(dev)->port[port];\n\tstruct mlx4_mac_table *table = &info->mac_table;\n\tint index = qpn - info->base_qpn;\n\tint err = 0;\n\tbool dup = mlx4_is_mf_bonded(dev);\n\tu8 dup_port = (port == 1) ? 2 : 1;\n\tstruct mlx4_mac_table *dup_table = &mlx4_priv(dev)->port[dup_port].mac_table;\n\n\t \n\tif (dup) {\n\t\tif (port == 1) {\n\t\t\tmutex_lock(&table->mutex);\n\t\t\tmutex_lock_nested(&dup_table->mutex, SINGLE_DEPTH_NESTING);\n\t\t} else {\n\t\t\tmutex_lock(&dup_table->mutex);\n\t\t\tmutex_lock_nested(&table->mutex, SINGLE_DEPTH_NESTING);\n\t\t}\n\t} else {\n\t\tmutex_lock(&table->mutex);\n\t}\n\n\terr = validate_index(dev, table, index);\n\tif (err)\n\t\tgoto out;\n\n\ttable->entries[index] = cpu_to_be64(new_mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\",\n\t\t\t (unsigned long long) new_mac);\n\t\ttable->entries[index] = 0;\n\t} else {\n\t\tif (dup) {\n\t\t\tdup_table->entries[index] = cpu_to_be64(new_mac | MLX4_MAC_VALID);\n\n\t\t\terr = mlx4_set_port_mac_table(dev, dup_port, dup_table->entries);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tmlx4_err(dev, \"Failed adding duplicate MAC: 0x%llx\\n\",\n\t\t\t\t\t (unsigned long long)new_mac);\n\t\t\t\tdup_table->entries[index] = 0;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tif (dup) {\n\t\tif (port == 2) {\n\t\t\tmutex_unlock(&table->mutex);\n\t\t\tmutex_unlock(&dup_table->mutex);\n\t\t} else {\n\t\t\tmutex_unlock(&dup_table->mutex);\n\t\t\tmutex_unlock(&table->mutex);\n\t\t}\n\t} else {\n\t\tmutex_unlock(&table->mutex);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(__mlx4_replace_mac);\n\nstatic int mlx4_set_port_vlan_table(struct mlx4_dev *dev, u8 port,\n\t\t\t\t    __be32 *entries)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tu32 in_mod;\n\tint err;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tmemcpy(mailbox->buf, entries, MLX4_VLAN_TABLE_SIZE);\n\tin_mod = MLX4_SET_PORT_VLAN_TABLE << 8 | port;\n\terr = mlx4_cmd(dev, mailbox->dma, in_mod, MLX4_SET_PORT_ETH_OPCODE,\n\t\t       MLX4_CMD_SET_PORT, MLX4_CMD_TIME_CLASS_B,\n\t\t       MLX4_CMD_NATIVE);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\n\treturn err;\n}\n\nint mlx4_find_cached_vlan(struct mlx4_dev *dev, u8 port, u16 vid, int *idx)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i;\n\n\tfor (i = 0; i < MLX4_MAX_VLAN_NUM; ++i) {\n\t\tif (table->refs[i] &&\n\t\t    (vid == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t \n\t\t\t*idx = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(mlx4_find_cached_vlan);\n\nint __mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan,\n\t\t\t\tint *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\tint free_for_dup = -1;\n\tbool dup = mlx4_is_mf_bonded(dev);\n\tu8 dup_port = (port == 1) ? 2 : 1;\n\tstruct mlx4_vlan_table *dup_table = &mlx4_priv(dev)->port[dup_port].vlan_table;\n\tbool need_mf_bond = mlx4_need_mf_bond(dev);\n\tbool can_mf_bond = true;\n\n\tmlx4_dbg(dev, \"Registering VLAN: %d for port %d %s duplicate\\n\",\n\t\t vlan, port,\n\t\t dup ? \"with\" : \"without\");\n\n\tif (need_mf_bond) {\n\t\tif (port == 1) {\n\t\t\tmutex_lock(&table->mutex);\n\t\t\tmutex_lock_nested(&dup_table->mutex, SINGLE_DEPTH_NESTING);\n\t\t} else {\n\t\t\tmutex_lock(&dup_table->mutex);\n\t\t\tmutex_lock_nested(&table->mutex, SINGLE_DEPTH_NESTING);\n\t\t}\n\t} else {\n\t\tmutex_lock(&table->mutex);\n\t}\n\n\tif (table->total == table->max) {\n\t\t \n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tif (need_mf_bond) {\n\t\tint index_at_port = -1;\n\t\tint index_at_dup_port = -1;\n\n\t\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\t\tif (vlan == (MLX4_VLAN_MASK & be32_to_cpu(table->entries[i])))\n\t\t\t\tindex_at_port = i;\n\t\t\tif (vlan == (MLX4_VLAN_MASK & be32_to_cpu(dup_table->entries[i])))\n\t\t\t\tindex_at_dup_port = i;\n\t\t}\n\t\t \n\t\tif ((index_at_port != index_at_dup_port) &&\n\t\t    (index_at_port >= 0) &&\n\t\t    (index_at_dup_port >= 0))\n\t\t\tcan_mf_bond = false;\n\n\t\t \n\t\tif (index_at_port >= 0 && index_at_dup_port < 0 &&\n\t\t    dup_table->refs[index_at_port]) {\n\t\t\tcan_mf_bond = false;\n\t\t}\n\t\t \n\t\tif (index_at_dup_port >= 0) {\n\t\t\tif (!table->refs[index_at_dup_port] ||\n\t\t\t    (vlan == (MLX4_VLAN_MASK & be32_to_cpu(dup_table->entries[index_at_dup_port]))))\n\t\t\t\tfree_for_dup = index_at_dup_port;\n\t\t\telse\n\t\t\t\tcan_mf_bond = false;\n\t\t}\n\t}\n\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (!table->refs[i]) {\n\t\t\tif (free < 0)\n\t\t\t\tfree = i;\n\t\t\tif (free_for_dup < 0 && need_mf_bond && can_mf_bond) {\n\t\t\t\tif (!dup_table->refs[i])\n\t\t\t\t\tfree_for_dup = i;\n\t\t\t}\n\t\t}\n\n\t\tif ((table->refs[i] || table->is_dup[i]) &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t \n\t\t\tmlx4_dbg(dev, \"vlan %u is already registered.\\n\", vlan);\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tif (dup) {\n\t\t\t\tu16 dup_vlan = MLX4_VLAN_MASK & be32_to_cpu(dup_table->entries[i]);\n\n\t\t\t\tif (dup_vlan != vlan || !dup_table->is_dup[i]) {\n\t\t\t\t\tmlx4_warn(dev, \"register vlan: expected duplicate vlan %u on port %d index %d\\n\",\n\t\t\t\t\t\t  vlan, dup_port, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (need_mf_bond && (free_for_dup < 0)) {\n\t\tif (dup) {\n\t\t\tmlx4_warn(dev, \"Fail to allocate duplicate VLAN table entry\\n\");\n\t\t\tmlx4_warn(dev, \"High Availability for virtual functions may not work as expected\\n\");\n\t\t\tdup = false;\n\t\t}\n\t\tcan_mf_bond = false;\n\t}\n\n\tif (need_mf_bond && can_mf_bond)\n\t\tfree = free_for_dup;\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\ttable->refs[free] = 1;\n\ttable->is_dup[free] = false;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t++table->total;\n\tif (dup) {\n\t\tdup_table->refs[free] = 0;\n\t\tdup_table->is_dup[free] = true;\n\t\tdup_table->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\t\terr = mlx4_set_port_vlan_table(dev, dup_port, dup_table->entries);\n\t\tif (unlikely(err)) {\n\t\t\tmlx4_warn(dev, \"Failed adding duplicate vlan: %u\\n\", vlan);\n\t\t\tdup_table->is_dup[free] = false;\n\t\t\tdup_table->entries[free] = 0;\n\t\t\tgoto out;\n\t\t}\n\t\t++dup_table->total;\n\t}\n\n\t*index = free;\nout:\n\tif (need_mf_bond) {\n\t\tif (port == 2) {\n\t\t\tmutex_unlock(&table->mutex);\n\t\t\tmutex_unlock(&dup_table->mutex);\n\t\t} else {\n\t\t\tmutex_unlock(&dup_table->mutex);\n\t\t\tmutex_unlock(&table->mutex);\n\t\t}\n\t} else {\n\t\tmutex_unlock(&table->mutex);\n\t}\n\treturn err;\n}\n\nint mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tu64 out_param = 0;\n\tint err;\n\n\tif (vlan > 4095)\n\t\treturn -EINVAL;\n\n\tif (mlx4_is_mfunc(dev)) {\n\t\terr = mlx4_cmd_imm(dev, vlan, &out_param,\n\t\t\t\t   ((u32) port) << 8 | (u32) RES_VLAN,\n\t\t\t\t   RES_OP_RESERVE_AND_MAP, MLX4_CMD_ALLOC_RES,\n\t\t\t\t   MLX4_CMD_TIME_CLASS_A, MLX4_CMD_WRAPPED);\n\t\tif (!err)\n\t\t\t*index = get_param_l(&out_param);\n\n\t\treturn err;\n\t}\n\treturn __mlx4_register_vlan(dev, port, vlan, index);\n}\nEXPORT_SYMBOL_GPL(mlx4_register_vlan);\n\nvoid __mlx4_unregister_vlan(struct mlx4_dev *dev, u8 port, u16 vlan)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint index;\n\tbool dup = mlx4_is_mf_bonded(dev);\n\tu8 dup_port = (port == 1) ? 2 : 1;\n\tstruct mlx4_vlan_table *dup_table = &mlx4_priv(dev)->port[dup_port].vlan_table;\n\n\tif (dup) {\n\t\tif (port == 1) {\n\t\t\tmutex_lock(&table->mutex);\n\t\t\tmutex_lock_nested(&dup_table->mutex, SINGLE_DEPTH_NESTING);\n\t\t} else {\n\t\t\tmutex_lock(&dup_table->mutex);\n\t\t\tmutex_lock_nested(&table->mutex, SINGLE_DEPTH_NESTING);\n\t\t}\n\t} else {\n\t\tmutex_lock(&table->mutex);\n\t}\n\n\tif (mlx4_find_cached_vlan(dev, port, vlan, &index)) {\n\t\tmlx4_warn(dev, \"vlan 0x%x is not in the vlan table\\n\", vlan);\n\t\tgoto out;\n\t}\n\n\tif (index < MLX4_VLAN_REGULAR) {\n\t\tmlx4_warn(dev, \"Trying to free special vlan index %d\\n\", index);\n\t\tgoto out;\n\t}\n\n\tif (--table->refs[index] || table->is_dup[index]) {\n\t\tmlx4_dbg(dev, \"Have %d more references for index %d, no need to modify vlan table\\n\",\n\t\t\t table->refs[index], index);\n\t\tif (!table->refs[index])\n\t\t\tdup_table->is_dup[index] = false;\n\t\tgoto out;\n\t}\n\ttable->entries[index] = 0;\n\tif (mlx4_set_port_vlan_table(dev, port, table->entries))\n\t\tmlx4_warn(dev, \"Fail to set vlan in port %d during unregister\\n\", port);\n\t--table->total;\n\tif (dup) {\n\t\tdup_table->is_dup[index] = false;\n\t\tif (dup_table->refs[index])\n\t\t\tgoto out;\n\t\tdup_table->entries[index] = 0;\n\t\tif (mlx4_set_port_vlan_table(dev, dup_port, dup_table->entries))\n\t\t\tmlx4_warn(dev, \"Fail to set vlan in duplicate port %d during unregister\\n\", dup_port);\n\t\t--dup_table->total;\n\t}\nout:\n\tif (dup) {\n\t\tif (port == 2) {\n\t\t\tmutex_unlock(&table->mutex);\n\t\t\tmutex_unlock(&dup_table->mutex);\n\t\t} else {\n\t\t\tmutex_unlock(&dup_table->mutex);\n\t\t\tmutex_unlock(&table->mutex);\n\t\t}\n\t} else {\n\t\tmutex_unlock(&table->mutex);\n\t}\n}\n\nvoid mlx4_unregister_vlan(struct mlx4_dev *dev, u8 port, u16 vlan)\n{\n\tu64 out_param = 0;\n\n\tif (mlx4_is_mfunc(dev)) {\n\t\t(void) mlx4_cmd_imm(dev, vlan, &out_param,\n\t\t\t\t    ((u32) port) << 8 | (u32) RES_VLAN,\n\t\t\t\t    RES_OP_RESERVE_AND_MAP,\n\t\t\t\t    MLX4_CMD_FREE_RES, MLX4_CMD_TIME_CLASS_A,\n\t\t\t\t    MLX4_CMD_WRAPPED);\n\t\treturn;\n\t}\n\t__mlx4_unregister_vlan(dev, port, vlan);\n}\nEXPORT_SYMBOL_GPL(mlx4_unregister_vlan);\n\nint mlx4_bond_mac_table(struct mlx4_dev *dev)\n{\n\tstruct mlx4_mac_table *t1 = &mlx4_priv(dev)->port[1].mac_table;\n\tstruct mlx4_mac_table *t2 = &mlx4_priv(dev)->port[2].mac_table;\n\tint ret = 0;\n\tint i;\n\tbool update1 = false;\n\tbool update2 = false;\n\n\tmutex_lock(&t1->mutex);\n\tmutex_lock(&t2->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM; i++) {\n\t\tif ((t1->entries[i] != t2->entries[i]) &&\n\t\t    t1->entries[i] && t2->entries[i]) {\n\t\t\tmlx4_warn(dev, \"can't duplicate entry %d in mac table\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM; i++) {\n\t\tif (t1->entries[i] && !t2->entries[i]) {\n\t\t\tt2->entries[i] = t1->entries[i];\n\t\t\tt2->is_dup[i] = true;\n\t\t\tupdate2 = true;\n\t\t} else if (!t1->entries[i] && t2->entries[i]) {\n\t\t\tt1->entries[i] = t2->entries[i];\n\t\t\tt1->is_dup[i] = true;\n\t\t\tupdate1 = true;\n\t\t} else if (t1->entries[i] && t2->entries[i]) {\n\t\t\tt1->is_dup[i] = true;\n\t\t\tt2->is_dup[i] = true;\n\t\t}\n\t}\n\n\tif (update1) {\n\t\tret = mlx4_set_port_mac_table(dev, 1, t1->entries);\n\t\tif (ret)\n\t\t\tmlx4_warn(dev, \"failed to set MAC table for port 1 (%d)\\n\", ret);\n\t}\n\tif (!ret && update2) {\n\t\tret = mlx4_set_port_mac_table(dev, 2, t2->entries);\n\t\tif (ret)\n\t\t\tmlx4_warn(dev, \"failed to set MAC table for port 2 (%d)\\n\", ret);\n\t}\n\n\tif (ret)\n\t\tmlx4_warn(dev, \"failed to create mirror MAC tables\\n\");\nunlock:\n\tmutex_unlock(&t2->mutex);\n\tmutex_unlock(&t1->mutex);\n\treturn ret;\n}\n\nint mlx4_unbond_mac_table(struct mlx4_dev *dev)\n{\n\tstruct mlx4_mac_table *t1 = &mlx4_priv(dev)->port[1].mac_table;\n\tstruct mlx4_mac_table *t2 = &mlx4_priv(dev)->port[2].mac_table;\n\tint ret = 0;\n\tint ret1;\n\tint i;\n\tbool update1 = false;\n\tbool update2 = false;\n\n\tmutex_lock(&t1->mutex);\n\tmutex_lock(&t2->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM; i++) {\n\t\tif (t1->entries[i] != t2->entries[i]) {\n\t\t\tmlx4_warn(dev, \"mac table is in an unexpected state when trying to unbond\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM; i++) {\n\t\tif (!t1->entries[i])\n\t\t\tcontinue;\n\t\tt1->is_dup[i] = false;\n\t\tif (!t1->refs[i]) {\n\t\t\tt1->entries[i] = 0;\n\t\t\tupdate1 = true;\n\t\t}\n\t\tt2->is_dup[i] = false;\n\t\tif (!t2->refs[i]) {\n\t\t\tt2->entries[i] = 0;\n\t\t\tupdate2 = true;\n\t\t}\n\t}\n\n\tif (update1) {\n\t\tret = mlx4_set_port_mac_table(dev, 1, t1->entries);\n\t\tif (ret)\n\t\t\tmlx4_warn(dev, \"failed to unmirror MAC tables for port 1(%d)\\n\", ret);\n\t}\n\tif (update2) {\n\t\tret1 = mlx4_set_port_mac_table(dev, 2, t2->entries);\n\t\tif (ret1) {\n\t\t\tmlx4_warn(dev, \"failed to unmirror MAC tables for port 2(%d)\\n\", ret1);\n\t\t\tret = ret1;\n\t\t}\n\t}\nunlock:\n\tmutex_unlock(&t2->mutex);\n\tmutex_unlock(&t1->mutex);\n\treturn ret;\n}\n\nint mlx4_bond_vlan_table(struct mlx4_dev *dev)\n{\n\tstruct mlx4_vlan_table *t1 = &mlx4_priv(dev)->port[1].vlan_table;\n\tstruct mlx4_vlan_table *t2 = &mlx4_priv(dev)->port[2].vlan_table;\n\tint ret = 0;\n\tint i;\n\tbool update1 = false;\n\tbool update2 = false;\n\n\tmutex_lock(&t1->mutex);\n\tmutex_lock(&t2->mutex);\n\tfor (i = 0; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif ((t1->entries[i] != t2->entries[i]) &&\n\t\t    t1->entries[i] && t2->entries[i]) {\n\t\t\tmlx4_warn(dev, \"can't duplicate entry %d in vlan table\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (t1->entries[i] && !t2->entries[i]) {\n\t\t\tt2->entries[i] = t1->entries[i];\n\t\t\tt2->is_dup[i] = true;\n\t\t\tupdate2 = true;\n\t\t} else if (!t1->entries[i] && t2->entries[i]) {\n\t\t\tt1->entries[i] = t2->entries[i];\n\t\t\tt1->is_dup[i] = true;\n\t\t\tupdate1 = true;\n\t\t} else if (t1->entries[i] && t2->entries[i]) {\n\t\t\tt1->is_dup[i] = true;\n\t\t\tt2->is_dup[i] = true;\n\t\t}\n\t}\n\n\tif (update1) {\n\t\tret = mlx4_set_port_vlan_table(dev, 1, t1->entries);\n\t\tif (ret)\n\t\t\tmlx4_warn(dev, \"failed to set VLAN table for port 1 (%d)\\n\", ret);\n\t}\n\tif (!ret && update2) {\n\t\tret = mlx4_set_port_vlan_table(dev, 2, t2->entries);\n\t\tif (ret)\n\t\t\tmlx4_warn(dev, \"failed to set VLAN table for port 2 (%d)\\n\", ret);\n\t}\n\n\tif (ret)\n\t\tmlx4_warn(dev, \"failed to create mirror VLAN tables\\n\");\nunlock:\n\tmutex_unlock(&t2->mutex);\n\tmutex_unlock(&t1->mutex);\n\treturn ret;\n}\n\nint mlx4_unbond_vlan_table(struct mlx4_dev *dev)\n{\n\tstruct mlx4_vlan_table *t1 = &mlx4_priv(dev)->port[1].vlan_table;\n\tstruct mlx4_vlan_table *t2 = &mlx4_priv(dev)->port[2].vlan_table;\n\tint ret = 0;\n\tint ret1;\n\tint i;\n\tbool update1 = false;\n\tbool update2 = false;\n\n\tmutex_lock(&t1->mutex);\n\tmutex_lock(&t2->mutex);\n\tfor (i = 0; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (t1->entries[i] != t2->entries[i]) {\n\t\t\tmlx4_warn(dev, \"vlan table is in an unexpected state when trying to unbond\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (!t1->entries[i])\n\t\t\tcontinue;\n\t\tt1->is_dup[i] = false;\n\t\tif (!t1->refs[i]) {\n\t\t\tt1->entries[i] = 0;\n\t\t\tupdate1 = true;\n\t\t}\n\t\tt2->is_dup[i] = false;\n\t\tif (!t2->refs[i]) {\n\t\t\tt2->entries[i] = 0;\n\t\t\tupdate2 = true;\n\t\t}\n\t}\n\n\tif (update1) {\n\t\tret = mlx4_set_port_vlan_table(dev, 1, t1->entries);\n\t\tif (ret)\n\t\t\tmlx4_warn(dev, \"failed to unmirror VLAN tables for port 1(%d)\\n\", ret);\n\t}\n\tif (update2) {\n\t\tret1 = mlx4_set_port_vlan_table(dev, 2, t2->entries);\n\t\tif (ret1) {\n\t\t\tmlx4_warn(dev, \"failed to unmirror VLAN tables for port 2(%d)\\n\", ret1);\n\t\t\tret = ret1;\n\t\t}\n\t}\nunlock:\n\tmutex_unlock(&t2->mutex);\n\tmutex_unlock(&t1->mutex);\n\treturn ret;\n}\n\nint mlx4_get_port_ib_caps(struct mlx4_dev *dev, u8 port, __be32 *caps)\n{\n\tstruct mlx4_cmd_mailbox *inmailbox, *outmailbox;\n\tu8 *inbuf, *outbuf;\n\tint err;\n\n\tinmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(inmailbox))\n\t\treturn PTR_ERR(inmailbox);\n\n\toutmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(outmailbox)) {\n\t\tmlx4_free_cmd_mailbox(dev, inmailbox);\n\t\treturn PTR_ERR(outmailbox);\n\t}\n\n\tinbuf = inmailbox->buf;\n\toutbuf = outmailbox->buf;\n\tinbuf[0] = 1;\n\tinbuf[1] = 1;\n\tinbuf[2] = 1;\n\tinbuf[3] = 1;\n\t*(__be16 *) (&inbuf[16]) = cpu_to_be16(0x0015);\n\t*(__be32 *) (&inbuf[20]) = cpu_to_be32(port);\n\n\terr = mlx4_cmd_box(dev, inmailbox->dma, outmailbox->dma, port, 3,\n\t\t\t   MLX4_CMD_MAD_IFC, MLX4_CMD_TIME_CLASS_C,\n\t\t\t   MLX4_CMD_NATIVE);\n\tif (!err)\n\t\t*caps = *(__be32 *) (outbuf + 84);\n\tmlx4_free_cmd_mailbox(dev, inmailbox);\n\tmlx4_free_cmd_mailbox(dev, outmailbox);\n\treturn err;\n}\nstatic struct mlx4_roce_gid_entry zgid_entry;\n\nint mlx4_get_slave_num_gids(struct mlx4_dev *dev, int slave, int port)\n{\n\tint vfs;\n\tint slave_gid = slave;\n\tunsigned i;\n\tstruct mlx4_slaves_pport slaves_pport;\n\tstruct mlx4_active_ports actv_ports;\n\tunsigned max_port_p_one;\n\n\tif (slave == 0)\n\t\treturn MLX4_ROCE_PF_GIDS;\n\n\t \n\tslaves_pport = mlx4_phys_to_slaves_pport(dev, port);\n\tactv_ports = mlx4_get_active_ports(dev, slave);\n\tmax_port_p_one = find_first_bit(actv_ports.ports, dev->caps.num_ports) +\n\t\tbitmap_weight(actv_ports.ports, dev->caps.num_ports) + 1;\n\n\tfor (i = 1; i < max_port_p_one; i++) {\n\t\tstruct mlx4_active_ports exclusive_ports;\n\t\tstruct mlx4_slaves_pport slaves_pport_actv;\n\t\tbitmap_zero(exclusive_ports.ports, dev->caps.num_ports);\n\t\tset_bit(i - 1, exclusive_ports.ports);\n\t\tif (i == port)\n\t\t\tcontinue;\n\t\tslaves_pport_actv = mlx4_phys_to_slaves_pport_actv(\n\t\t\t\t    dev, &exclusive_ports);\n\t\tslave_gid -= bitmap_weight(slaves_pport_actv.slaves,\n\t\t\t\t\t   dev->persist->num_vfs + 1);\n\t}\n\tvfs = bitmap_weight(slaves_pport.slaves, dev->persist->num_vfs + 1) - 1;\n\tif (slave_gid <= ((MLX4_ROCE_MAX_GIDS - MLX4_ROCE_PF_GIDS) % vfs))\n\t\treturn ((MLX4_ROCE_MAX_GIDS - MLX4_ROCE_PF_GIDS) / vfs) + 1;\n\treturn (MLX4_ROCE_MAX_GIDS - MLX4_ROCE_PF_GIDS) / vfs;\n}\n\nint mlx4_get_base_gid_ix(struct mlx4_dev *dev, int slave, int port)\n{\n\tint gids;\n\tunsigned i;\n\tint slave_gid = slave;\n\tint vfs;\n\n\tstruct mlx4_slaves_pport slaves_pport;\n\tstruct mlx4_active_ports actv_ports;\n\tunsigned max_port_p_one;\n\n\tif (slave == 0)\n\t\treturn 0;\n\n\tslaves_pport = mlx4_phys_to_slaves_pport(dev, port);\n\tactv_ports = mlx4_get_active_ports(dev, slave);\n\tmax_port_p_one = find_first_bit(actv_ports.ports, dev->caps.num_ports) +\n\t\tbitmap_weight(actv_ports.ports, dev->caps.num_ports) + 1;\n\n\tfor (i = 1; i < max_port_p_one; i++) {\n\t\tstruct mlx4_active_ports exclusive_ports;\n\t\tstruct mlx4_slaves_pport slaves_pport_actv;\n\t\tbitmap_zero(exclusive_ports.ports, dev->caps.num_ports);\n\t\tset_bit(i - 1, exclusive_ports.ports);\n\t\tif (i == port)\n\t\t\tcontinue;\n\t\tslaves_pport_actv = mlx4_phys_to_slaves_pport_actv(\n\t\t\t\t    dev, &exclusive_ports);\n\t\tslave_gid -= bitmap_weight(slaves_pport_actv.slaves,\n\t\t\t\t\t   dev->persist->num_vfs + 1);\n\t}\n\tgids = MLX4_ROCE_MAX_GIDS - MLX4_ROCE_PF_GIDS;\n\tvfs = bitmap_weight(slaves_pport.slaves, dev->persist->num_vfs + 1) - 1;\n\tif (slave_gid <= gids % vfs)\n\t\treturn MLX4_ROCE_PF_GIDS + ((gids / vfs) + 1) * (slave_gid - 1);\n\n\treturn MLX4_ROCE_PF_GIDS + (gids % vfs) +\n\t\t((gids / vfs) * (slave_gid - 1));\n}\nEXPORT_SYMBOL_GPL(mlx4_get_base_gid_ix);\n\nstatic int mlx4_reset_roce_port_gids(struct mlx4_dev *dev, int slave,\n\t\t\t\t     int port, struct mlx4_cmd_mailbox *mailbox)\n{\n\tstruct mlx4_roce_gid_entry *gid_entry_mbox;\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint num_gids, base, offset;\n\tint i, err;\n\n\tnum_gids = mlx4_get_slave_num_gids(dev, slave, port);\n\tbase = mlx4_get_base_gid_ix(dev, slave, port);\n\n\tmemset(mailbox->buf, 0, MLX4_MAILBOX_SIZE);\n\n\tmutex_lock(&(priv->port[port].gid_table.mutex));\n\t \n\tfor (i = 0, offset = base; i < num_gids; offset++, i++)\n\t\tmemcpy(priv->port[port].gid_table.roce_gids[offset].raw,\n\t\t       zgid_entry.raw, MLX4_ROCE_GID_ENTRY_SIZE);\n\n\t \n\tgid_entry_mbox = (struct mlx4_roce_gid_entry *)mailbox->buf;\n\tfor (i = 0; i < MLX4_ROCE_MAX_GIDS; gid_entry_mbox++, i++)\n\t\tmemcpy(gid_entry_mbox->raw,\n\t\t       priv->port[port].gid_table.roce_gids[i].raw,\n\t\t       MLX4_ROCE_GID_ENTRY_SIZE);\n\n\terr = mlx4_cmd(dev, mailbox->dma,\n\t\t       ((u32)port) | (MLX4_SET_PORT_GID_TABLE << 8),\n\t\t       MLX4_SET_PORT_ETH_OPCODE, MLX4_CMD_SET_PORT,\n\t\t       MLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);\n\tmutex_unlock(&(priv->port[port].gid_table.mutex));\n\treturn err;\n}\n\n\nvoid mlx4_reset_roce_gids(struct mlx4_dev *dev, int slave)\n{\n\tstruct mlx4_active_ports actv_ports;\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tint num_eth_ports, err;\n\tint i;\n\n\tif (slave < 0 || slave > dev->persist->num_vfs)\n\t\treturn;\n\n\tactv_ports = mlx4_get_active_ports(dev, slave);\n\n\tfor (i = 0, num_eth_ports = 0; i < dev->caps.num_ports; i++) {\n\t\tif (test_bit(i, actv_ports.ports)) {\n\t\t\tif (dev->caps.port_type[i + 1] != MLX4_PORT_TYPE_ETH)\n\t\t\t\tcontinue;\n\t\t\tnum_eth_ports++;\n\t\t}\n\t}\n\n\tif (!num_eth_ports)\n\t\treturn;\n\n\t \n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn;\n\n\tfor (i = 0; i < dev->caps.num_ports; i++) {\n\t\tif (test_bit(i, actv_ports.ports)) {\n\t\t\tif (dev->caps.port_type[i + 1] != MLX4_PORT_TYPE_ETH)\n\t\t\t\tcontinue;\n\t\t\terr = mlx4_reset_roce_port_gids(dev, slave, i + 1, mailbox);\n\t\t\tif (err)\n\t\t\t\tmlx4_warn(dev, \"Could not reset ETH port GID table for slave %d, port %d (%d)\\n\",\n\t\t\t\t\t  slave, i + 1, err);\n\t\t}\n\t}\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn;\n}\n\nstatic void\nmlx4_en_set_port_mtu(struct mlx4_dev *dev, int slave, int port,\n\t\t     struct mlx4_set_port_general_context *gen_context)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_mfunc_master_ctx *master = &priv->mfunc.master;\n\tstruct mlx4_slave_state *slave_st = &master->slave_state[slave];\n\tu16 mtu, prev_mtu;\n\n\t \n\tmtu = be16_to_cpu(gen_context->mtu);\n\tmtu = min_t(int, mtu, dev->caps.eth_mtu_cap[port] +\n\t\t    ETH_HLEN + VLAN_HLEN + ETH_FCS_LEN);\n\tprev_mtu = slave_st->mtu[port];\n\tslave_st->mtu[port] = mtu;\n\tif (mtu > master->max_mtu[port])\n\t\tmaster->max_mtu[port] = mtu;\n\tif (mtu < prev_mtu && prev_mtu == master->max_mtu[port]) {\n\t\tint i;\n\n\t\tslave_st->mtu[port] = mtu;\n\t\tmaster->max_mtu[port] = mtu;\n\t\tfor (i = 0; i < dev->num_slaves; i++)\n\t\t\tmaster->max_mtu[port] =\n\t\t\t\tmax_t(u16, master->max_mtu[port],\n\t\t\t\t      master->slave_state[i].mtu[port]);\n\t}\n\tgen_context->mtu = cpu_to_be16(master->max_mtu[port]);\n}\n\nstatic void\nmlx4_en_set_port_user_mtu(struct mlx4_dev *dev, int slave, int port,\n\t\t\t  struct mlx4_set_port_general_context *gen_context)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_mfunc_master_ctx *master = &priv->mfunc.master;\n\tstruct mlx4_slave_state *slave_st = &master->slave_state[slave];\n\tu16 user_mtu, prev_user_mtu;\n\n\t \n\tuser_mtu = be16_to_cpu(gen_context->user_mtu);\n\tuser_mtu = min_t(int, user_mtu, dev->caps.eth_mtu_cap[port]);\n\tprev_user_mtu = slave_st->user_mtu[port];\n\tslave_st->user_mtu[port] = user_mtu;\n\tif (user_mtu > master->max_user_mtu[port])\n\t\tmaster->max_user_mtu[port] = user_mtu;\n\tif (user_mtu < prev_user_mtu &&\n\t    prev_user_mtu == master->max_user_mtu[port]) {\n\t\tint i;\n\n\t\tslave_st->user_mtu[port] = user_mtu;\n\t\tmaster->max_user_mtu[port] = user_mtu;\n\t\tfor (i = 0; i < dev->num_slaves; i++)\n\t\t\tmaster->max_user_mtu[port] =\n\t\t\t\tmax_t(u16, master->max_user_mtu[port],\n\t\t\t\t      master->slave_state[i].user_mtu[port]);\n\t}\n\tgen_context->user_mtu = cpu_to_be16(master->max_user_mtu[port]);\n}\n\nstatic void\nmlx4_en_set_port_global_pause(struct mlx4_dev *dev, int slave,\n\t\t\t      struct mlx4_set_port_general_context *gen_context)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_mfunc_master_ctx *master = &priv->mfunc.master;\n\n\t \n\tif (slave != mlx4_master_func_num(dev) &&\n\t    (gen_context->pptx != master->pptx ||\n\t     gen_context->pprx != master->pprx)) {\n\t\tgen_context->pptx = master->pptx;\n\t\tgen_context->pprx = master->pprx;\n\t\tmlx4_warn(dev, \"denying Global Pause change for slave:%d\\n\",\n\t\t\t  slave);\n\t} else {\n\t\tmaster->pptx = gen_context->pptx;\n\t\tmaster->pprx = gen_context->pprx;\n\t}\n}\n\nstatic int mlx4_common_set_port(struct mlx4_dev *dev, int slave, u32 in_mod,\n\t\t\t\tu8 op_mod, struct mlx4_cmd_mailbox *inbox)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tstruct mlx4_port_info *port_info;\n\tstruct mlx4_set_port_rqp_calc_context *qpn_context;\n\tstruct mlx4_set_port_general_context *gen_context;\n\tstruct mlx4_roce_gid_entry *gid_entry_tbl, *gid_entry_mbox, *gid_entry_mb1;\n\tint reset_qkey_viols;\n\tint port;\n\tint is_eth;\n\tint num_gids;\n\tint base;\n\tu32 in_modifier;\n\tu32 promisc;\n\tint err;\n\tint i, j;\n\tint offset;\n\t__be32 agg_cap_mask;\n\t__be32 slave_cap_mask;\n\t__be32 new_cap_mask;\n\n\tport = in_mod & 0xff;\n\tin_modifier = in_mod >> 8;\n\tis_eth = op_mod;\n\tport_info = &priv->port[port];\n\n\t \n\tif (is_eth) {\n\t\tif (slave != dev->caps.function &&\n\t\t    in_modifier != MLX4_SET_PORT_GENERAL &&\n\t\t    in_modifier != MLX4_SET_PORT_GID_TABLE) {\n\t\t\tmlx4_warn(dev, \"denying SET_PORT for slave:%d\\n\",\n\t\t\t\t\tslave);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (in_modifier) {\n\t\tcase MLX4_SET_PORT_RQP_CALC:\n\t\t\tqpn_context = inbox->buf;\n\t\t\tqpn_context->base_qpn =\n\t\t\t\tcpu_to_be32(port_info->base_qpn);\n\t\t\tqpn_context->n_mac = 0x7;\n\t\t\tpromisc = be32_to_cpu(qpn_context->promisc) >>\n\t\t\t\tSET_PORT_PROMISC_SHIFT;\n\t\t\tqpn_context->promisc = cpu_to_be32(\n\t\t\t\tpromisc << SET_PORT_PROMISC_SHIFT |\n\t\t\t\tport_info->base_qpn);\n\t\t\tpromisc = be32_to_cpu(qpn_context->mcast) >>\n\t\t\t\tSET_PORT_MC_PROMISC_SHIFT;\n\t\t\tqpn_context->mcast = cpu_to_be32(\n\t\t\t\tpromisc << SET_PORT_MC_PROMISC_SHIFT |\n\t\t\t\tport_info->base_qpn);\n\t\t\tbreak;\n\t\tcase MLX4_SET_PORT_GENERAL:\n\t\t\tgen_context = inbox->buf;\n\n\t\t\tif (gen_context->flags & MLX4_FLAG_V_MTU_MASK)\n\t\t\t\tmlx4_en_set_port_mtu(dev, slave, port,\n\t\t\t\t\t\t     gen_context);\n\n\t\t\tif (gen_context->flags2 & MLX4_FLAG2_V_USER_MTU_MASK)\n\t\t\t\tmlx4_en_set_port_user_mtu(dev, slave, port,\n\t\t\t\t\t\t\t  gen_context);\n\n\t\t\tif (gen_context->flags &\n\t\t\t    (MLX4_FLAG_V_PPRX_MASK | MLX4_FLAG_V_PPTX_MASK))\n\t\t\t\tmlx4_en_set_port_global_pause(dev, slave,\n\t\t\t\t\t\t\t      gen_context);\n\n\t\t\tbreak;\n\t\tcase MLX4_SET_PORT_GID_TABLE:\n\t\t\t \n\t\t\tnum_gids = mlx4_get_slave_num_gids(dev, slave, port);\n\t\t\tbase = mlx4_get_base_gid_ix(dev, slave, port);\n\t\t\tgid_entry_mbox = (struct mlx4_roce_gid_entry *)(inbox->buf);\n\t\t\tfor (i = 0; i < num_gids; gid_entry_mbox++, i++) {\n\t\t\t\tif (!memcmp(gid_entry_mbox->raw, zgid_entry.raw,\n\t\t\t\t\t    sizeof(zgid_entry)))\n\t\t\t\t\tcontinue;\n\t\t\t\tgid_entry_mb1 = gid_entry_mbox + 1;\n\t\t\t\tfor (j = i + 1; j < num_gids; gid_entry_mb1++, j++) {\n\t\t\t\t\tif (!memcmp(gid_entry_mb1->raw,\n\t\t\t\t\t\t    zgid_entry.raw, sizeof(zgid_entry)))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!memcmp(gid_entry_mb1->raw, gid_entry_mbox->raw,\n\t\t\t\t\t\t    sizeof(gid_entry_mbox->raw))) {\n\t\t\t\t\t\t \n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\n\t\t\tmutex_lock(&(priv->port[port].gid_table.mutex));\n\t\t\tfor (i = 0; i < MLX4_ROCE_MAX_GIDS; i++) {\n\t\t\t\tif (i >= base && i < base + num_gids)\n\t\t\t\t\tcontinue;  \n\t\t\t\tgid_entry_tbl = &priv->port[port].gid_table.roce_gids[i];\n\t\t\t\tif (!memcmp(gid_entry_tbl->raw, zgid_entry.raw, sizeof(zgid_entry)))\n\t\t\t\t\tcontinue;\n\t\t\t\tgid_entry_mbox = (struct mlx4_roce_gid_entry *)(inbox->buf);\n\t\t\t\tfor (j = 0; j < num_gids; gid_entry_mbox++, j++) {\n\t\t\t\t\tif (!memcmp(gid_entry_mbox->raw, zgid_entry.raw,\n\t\t\t\t\t\t    sizeof(zgid_entry)))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!memcmp(gid_entry_mbox->raw, gid_entry_tbl->raw,\n\t\t\t\t\t\t    sizeof(gid_entry_tbl->raw))) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tmlx4_warn(dev, \"requested gid entry for slave:%d is a duplicate of gid at index %d\\n\",\n\t\t\t\t\t\t\t  slave, i);\n\t\t\t\t\t\tmutex_unlock(&(priv->port[port].gid_table.mutex));\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tgid_entry_mbox = (struct mlx4_roce_gid_entry *)(inbox->buf);\n\t\t\tfor (i = 0, offset = base; i < num_gids; gid_entry_mbox++, offset++, i++)\n\t\t\t\tmemcpy(priv->port[port].gid_table.roce_gids[offset].raw,\n\t\t\t\t       gid_entry_mbox->raw, MLX4_ROCE_GID_ENTRY_SIZE);\n\n\t\t\t \n\t\t\tgid_entry_mbox = (struct mlx4_roce_gid_entry *)(inbox->buf);\n\t\t\tfor (i = 0; i < MLX4_ROCE_MAX_GIDS; gid_entry_mbox++, i++)\n\t\t\t\tmemcpy(gid_entry_mbox->raw,\n\t\t\t\t       priv->port[port].gid_table.roce_gids[i].raw,\n\t\t\t\t       MLX4_ROCE_GID_ENTRY_SIZE);\n\n\t\t\terr = mlx4_cmd(dev, inbox->dma, in_mod & 0xffff, op_mod,\n\t\t\t\t       MLX4_CMD_SET_PORT, MLX4_CMD_TIME_CLASS_B,\n\t\t\t\t       MLX4_CMD_NATIVE);\n\t\t\tmutex_unlock(&(priv->port[port].gid_table.mutex));\n\t\t\treturn err;\n\t\t}\n\n\t\treturn mlx4_cmd(dev, inbox->dma, in_mod & 0xffff, op_mod,\n\t\t\t\tMLX4_CMD_SET_PORT, MLX4_CMD_TIME_CLASS_B,\n\t\t\t\tMLX4_CMD_NATIVE);\n\t}\n\n\t \n\tif (op_mod == MLX4_SET_PORT_BEACON_OPCODE) {\n\t\tmlx4_warn(dev, \"denying SET_PORT Beacon slave:%d\\n\", slave);\n\t\treturn -EPERM;\n\t}\n\n\t \n\n\tif (dev->flags & MLX4_FLAG_OLD_PORT_CMDS) {\n\t\treset_qkey_viols = (*(u8 *) inbox->buf) & 0x40;\n\t\tnew_cap_mask = ((__be32 *) inbox->buf)[2];\n\t} else {\n\t\treset_qkey_viols = ((u8 *) inbox->buf)[3] & 0x1;\n\t\tnew_cap_mask = ((__be32 *) inbox->buf)[1];\n\t}\n\n\t \n\tif (slave != mlx4_master_func_num(dev) &&\n\t    (be32_to_cpu(new_cap_mask) & MLX4_PORT_CAP_IS_SM))\n\t\treturn -EINVAL;\n\n\t \n\tif (mlx4_is_mfunc(dev) &&\n\t    (be32_to_cpu(new_cap_mask) & MLX4_PORT_CAP_DEV_MGMT_SUP))\n\t\treturn -EINVAL;\n\n\tagg_cap_mask = 0;\n\tslave_cap_mask =\n\t\tpriv->mfunc.master.slave_state[slave].ib_cap_mask[port];\n\tpriv->mfunc.master.slave_state[slave].ib_cap_mask[port] = new_cap_mask;\n\tfor (i = 0; i < dev->num_slaves; i++)\n\t\tagg_cap_mask |=\n\t\t\tpriv->mfunc.master.slave_state[i].ib_cap_mask[port];\n\n\t \n\tif (slave != dev->caps.function)\n\t\tmemset(inbox->buf, 0, 256);\n\tif (dev->flags & MLX4_FLAG_OLD_PORT_CMDS) {\n\t\t*(u8 *) inbox->buf\t   |= !!reset_qkey_viols << 6;\n\t\t((__be32 *) inbox->buf)[2] = agg_cap_mask;\n\t} else {\n\t\t((u8 *) inbox->buf)[3]     |= !!reset_qkey_viols;\n\t\t((__be32 *) inbox->buf)[1] = agg_cap_mask;\n\t}\n\n\terr = mlx4_cmd(dev, inbox->dma, port, is_eth, MLX4_CMD_SET_PORT,\n\t\t       MLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);\n\tif (err)\n\t\tpriv->mfunc.master.slave_state[slave].ib_cap_mask[port] =\n\t\t\tslave_cap_mask;\n\treturn err;\n}\n\nint mlx4_SET_PORT_wrapper(struct mlx4_dev *dev, int slave,\n\t\t\t  struct mlx4_vhcr *vhcr,\n\t\t\t  struct mlx4_cmd_mailbox *inbox,\n\t\t\t  struct mlx4_cmd_mailbox *outbox,\n\t\t\t  struct mlx4_cmd_info *cmd)\n{\n\tint port = mlx4_slave_convert_port(\n\t\t\tdev, slave, vhcr->in_modifier & 0xFF);\n\n\tif (port < 0)\n\t\treturn -EINVAL;\n\n\tvhcr->in_modifier = (vhcr->in_modifier & ~0xFF) |\n\t\t\t    (port & 0xFF);\n\n\treturn mlx4_common_set_port(dev, slave, vhcr->in_modifier,\n\t\t\t\t    vhcr->op_modifier, inbox);\n}\n\n \nenum {\n\tMLX4_SET_PORT_VL_CAP\t = 4,  \n\tMLX4_SET_PORT_MTU_CAP\t = 12,  \n\tMLX4_CHANGE_PORT_PKEY_TBL_SZ = 20,\n\tMLX4_CHANGE_PORT_VL_CAP\t = 21,\n\tMLX4_CHANGE_PORT_MTU_CAP = 22,\n};\n\nint mlx4_SET_PORT(struct mlx4_dev *dev, u8 port, int pkey_tbl_sz)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tint err, vl_cap, pkey_tbl_flag = 0;\n\n\tif (dev->caps.port_type[port] == MLX4_PORT_TYPE_ETH)\n\t\treturn 0;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\t((__be32 *) mailbox->buf)[1] = dev->caps.ib_port_def_cap[port];\n\n\tif (pkey_tbl_sz >= 0 && mlx4_is_master(dev)) {\n\t\tpkey_tbl_flag = 1;\n\t\t((__be16 *) mailbox->buf)[20] = cpu_to_be16(pkey_tbl_sz);\n\t}\n\n\t \n\tfor (vl_cap = 8; vl_cap >= 1; vl_cap >>= 1) {\n\t\t((__be32 *) mailbox->buf)[0] = cpu_to_be32(\n\t\t\t(1 << MLX4_CHANGE_PORT_MTU_CAP) |\n\t\t\t(1 << MLX4_CHANGE_PORT_VL_CAP)  |\n\t\t\t(pkey_tbl_flag << MLX4_CHANGE_PORT_PKEY_TBL_SZ) |\n\t\t\t(dev->caps.port_ib_mtu[port] << MLX4_SET_PORT_MTU_CAP) |\n\t\t\t(vl_cap << MLX4_SET_PORT_VL_CAP));\n\t\terr = mlx4_cmd(dev, mailbox->dma, port,\n\t\t\t       MLX4_SET_PORT_IB_OPCODE, MLX4_CMD_SET_PORT,\n\t\t\t       MLX4_CMD_TIME_CLASS_B, MLX4_CMD_WRAPPED);\n\t\tif (err != -ENOMEM)\n\t\t\tbreak;\n\t}\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\n\n#define SET_PORT_ROCE_2_FLAGS          0x10\n#define MLX4_SET_PORT_ROCE_V1_V2       0x2\nint mlx4_SET_PORT_general(struct mlx4_dev *dev, u8 port, int mtu,\n\t\t\t  u8 pptx, u8 pfctx, u8 pprx, u8 pfcrx)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tstruct mlx4_set_port_general_context *context;\n\tint err;\n\tu32 in_mod;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tcontext = mailbox->buf;\n\tcontext->flags = SET_PORT_GEN_ALL_VALID;\n\tcontext->mtu = cpu_to_be16(mtu);\n\tcontext->pptx = (pptx * (!pfctx)) << 7;\n\tcontext->pfctx = pfctx;\n\tcontext->pprx = (pprx * (!pfcrx)) << 7;\n\tcontext->pfcrx = pfcrx;\n\n\tif (dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_ROCE_V1_V2) {\n\t\tcontext->flags |= SET_PORT_ROCE_2_FLAGS;\n\t\tcontext->roce_mode |=\n\t\t\tMLX4_SET_PORT_ROCE_V1_V2 << 4;\n\t}\n\tin_mod = MLX4_SET_PORT_GENERAL << 8 | port;\n\terr = mlx4_cmd(dev, mailbox->dma, in_mod, MLX4_SET_PORT_ETH_OPCODE,\n\t\t       MLX4_CMD_SET_PORT, MLX4_CMD_TIME_CLASS_B,\n\t\t       MLX4_CMD_WRAPPED);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\nEXPORT_SYMBOL(mlx4_SET_PORT_general);\n\nint mlx4_SET_PORT_qpn_calc(struct mlx4_dev *dev, u8 port, u32 base_qpn,\n\t\t\t   u8 promisc)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tstruct mlx4_set_port_rqp_calc_context *context;\n\tint err;\n\tu32 in_mod;\n\tu32 m_promisc = (dev->caps.flags & MLX4_DEV_CAP_FLAG_VEP_MC_STEER) ?\n\t\tMCAST_DIRECT : MCAST_DEFAULT;\n\n\tif (dev->caps.steering_mode != MLX4_STEERING_MODE_A0)\n\t\treturn 0;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tcontext = mailbox->buf;\n\tcontext->base_qpn = cpu_to_be32(base_qpn);\n\tcontext->n_mac = dev->caps.log_num_macs;\n\tcontext->promisc = cpu_to_be32(promisc << SET_PORT_PROMISC_SHIFT |\n\t\t\t\t       base_qpn);\n\tcontext->mcast = cpu_to_be32(m_promisc << SET_PORT_MC_PROMISC_SHIFT |\n\t\t\t\t     base_qpn);\n\tcontext->intra_no_vlan = 0;\n\tcontext->no_vlan = MLX4_NO_VLAN_IDX;\n\tcontext->intra_vlan_miss = 0;\n\tcontext->vlan_miss = MLX4_VLAN_MISS_IDX;\n\n\tin_mod = MLX4_SET_PORT_RQP_CALC << 8 | port;\n\terr = mlx4_cmd(dev, mailbox->dma, in_mod, MLX4_SET_PORT_ETH_OPCODE,\n\t\t       MLX4_CMD_SET_PORT, MLX4_CMD_TIME_CLASS_B,\n\t\t       MLX4_CMD_WRAPPED);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\nEXPORT_SYMBOL(mlx4_SET_PORT_qpn_calc);\n\nint mlx4_SET_PORT_user_mtu(struct mlx4_dev *dev, u8 port, u16 user_mtu)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tstruct mlx4_set_port_general_context *context;\n\tu32 in_mod;\n\tint err;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tcontext = mailbox->buf;\n\tcontext->flags2 |= MLX4_FLAG2_V_USER_MTU_MASK;\n\tcontext->user_mtu = cpu_to_be16(user_mtu);\n\n\tin_mod = MLX4_SET_PORT_GENERAL << 8 | port;\n\terr = mlx4_cmd(dev, mailbox->dma, in_mod, MLX4_SET_PORT_ETH_OPCODE,\n\t\t       MLX4_CMD_SET_PORT, MLX4_CMD_TIME_CLASS_B,\n\t\t       MLX4_CMD_WRAPPED);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\nEXPORT_SYMBOL(mlx4_SET_PORT_user_mtu);\n\nint mlx4_SET_PORT_user_mac(struct mlx4_dev *dev, u8 port, u8 *user_mac)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tstruct mlx4_set_port_general_context *context;\n\tu32 in_mod;\n\tint err;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tcontext = mailbox->buf;\n\tcontext->flags2 |= MLX4_FLAG2_V_USER_MAC_MASK;\n\tmemcpy(context->user_mac, user_mac, sizeof(context->user_mac));\n\n\tin_mod = MLX4_SET_PORT_GENERAL << 8 | port;\n\terr = mlx4_cmd(dev, mailbox->dma, in_mod, MLX4_SET_PORT_ETH_OPCODE,\n\t\t       MLX4_CMD_SET_PORT, MLX4_CMD_TIME_CLASS_B,\n\t\t       MLX4_CMD_NATIVE);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\nEXPORT_SYMBOL(mlx4_SET_PORT_user_mac);\n\nint mlx4_SET_PORT_fcs_check(struct mlx4_dev *dev, u8 port, u8 ignore_fcs_value)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tstruct mlx4_set_port_general_context *context;\n\tu32 in_mod;\n\tint err;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tcontext = mailbox->buf;\n\tcontext->flags2 |= MLX4_FLAG2_V_IGNORE_FCS_MASK;\n\tif (ignore_fcs_value)\n\t\tcontext->ignore_fcs |= MLX4_IGNORE_FCS_MASK;\n\telse\n\t\tcontext->ignore_fcs &= ~MLX4_IGNORE_FCS_MASK;\n\n\tin_mod = MLX4_SET_PORT_GENERAL << 8 | port;\n\terr = mlx4_cmd(dev, mailbox->dma, in_mod, 1, MLX4_CMD_SET_PORT,\n\t\t       MLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\nEXPORT_SYMBOL(mlx4_SET_PORT_fcs_check);\n\nenum {\n\tVXLAN_ENABLE_MODIFY\t= 1 << 7,\n\tVXLAN_STEERING_MODIFY\t= 1 << 6,\n\n\tVXLAN_ENABLE\t\t= 1 << 7,\n};\n\nstruct mlx4_set_port_vxlan_context {\n\tu32\treserved1;\n\tu8\tmodify_flags;\n\tu8\treserved2;\n\tu8\tenable_flags;\n\tu8\tsteering;\n};\n\nint mlx4_SET_PORT_VXLAN(struct mlx4_dev *dev, u8 port, u8 steering, int enable)\n{\n\tint err;\n\tu32 in_mod;\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tstruct mlx4_set_port_vxlan_context  *context;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tcontext = mailbox->buf;\n\tmemset(context, 0, sizeof(*context));\n\n\tcontext->modify_flags = VXLAN_ENABLE_MODIFY | VXLAN_STEERING_MODIFY;\n\tif (enable)\n\t\tcontext->enable_flags = VXLAN_ENABLE;\n\tcontext->steering  = steering;\n\n\tin_mod = MLX4_SET_PORT_VXLAN << 8 | port;\n\terr = mlx4_cmd(dev, mailbox->dma, in_mod, MLX4_SET_PORT_ETH_OPCODE,\n\t\t       MLX4_CMD_SET_PORT, MLX4_CMD_TIME_CLASS_B,\n\t\t       MLX4_CMD_NATIVE);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\nEXPORT_SYMBOL(mlx4_SET_PORT_VXLAN);\n\nint mlx4_SET_PORT_BEACON(struct mlx4_dev *dev, u8 port, u16 time)\n{\n\tint err;\n\tstruct mlx4_cmd_mailbox *mailbox;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\t*((__be32 *)mailbox->buf) = cpu_to_be32(time);\n\n\terr = mlx4_cmd(dev, mailbox->dma, port, MLX4_SET_PORT_BEACON_OPCODE,\n\t\t       MLX4_CMD_SET_PORT, MLX4_CMD_TIME_CLASS_B,\n\t\t       MLX4_CMD_NATIVE);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\nEXPORT_SYMBOL(mlx4_SET_PORT_BEACON);\n\nint mlx4_SET_MCAST_FLTR_wrapper(struct mlx4_dev *dev, int slave,\n\t\t\t\tstruct mlx4_vhcr *vhcr,\n\t\t\t\tstruct mlx4_cmd_mailbox *inbox,\n\t\t\t\tstruct mlx4_cmd_mailbox *outbox,\n\t\t\t\tstruct mlx4_cmd_info *cmd)\n{\n\tint err = 0;\n\n\treturn err;\n}\n\nint mlx4_SET_MCAST_FLTR(struct mlx4_dev *dev, u8 port,\n\t\t\tu64 mac, u64 clear, u8 mode)\n{\n\treturn mlx4_cmd(dev, (mac | (clear << 63)), port, mode,\n\t\t\tMLX4_CMD_SET_MCAST_FLTR, MLX4_CMD_TIME_CLASS_B,\n\t\t\tMLX4_CMD_WRAPPED);\n}\nEXPORT_SYMBOL(mlx4_SET_MCAST_FLTR);\n\nint mlx4_SET_VLAN_FLTR_wrapper(struct mlx4_dev *dev, int slave,\n\t\t\t       struct mlx4_vhcr *vhcr,\n\t\t\t       struct mlx4_cmd_mailbox *inbox,\n\t\t\t       struct mlx4_cmd_mailbox *outbox,\n\t\t\t       struct mlx4_cmd_info *cmd)\n{\n\tint err = 0;\n\n\treturn err;\n}\n\nint mlx4_DUMP_ETH_STATS_wrapper(struct mlx4_dev *dev, int slave,\n\t\t\t\tstruct mlx4_vhcr *vhcr,\n\t\t\t\tstruct mlx4_cmd_mailbox *inbox,\n\t\t\t\tstruct mlx4_cmd_mailbox *outbox,\n\t\t\t\tstruct mlx4_cmd_info *cmd)\n{\n\treturn 0;\n}\n\nint mlx4_get_slave_from_roce_gid(struct mlx4_dev *dev, int port, u8 *gid,\n\t\t\t\t int *slave_id)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint i, found_ix = -1;\n\tint vf_gids = MLX4_ROCE_MAX_GIDS - MLX4_ROCE_PF_GIDS;\n\tstruct mlx4_slaves_pport slaves_pport;\n\tunsigned num_vfs;\n\tint slave_gid;\n\n\tif (!mlx4_is_mfunc(dev))\n\t\treturn -EINVAL;\n\n\tslaves_pport = mlx4_phys_to_slaves_pport(dev, port);\n\tnum_vfs = bitmap_weight(slaves_pport.slaves,\n\t\t\t\tdev->persist->num_vfs + 1) - 1;\n\n\tfor (i = 0; i < MLX4_ROCE_MAX_GIDS; i++) {\n\t\tif (!memcmp(priv->port[port].gid_table.roce_gids[i].raw, gid,\n\t\t\t    MLX4_ROCE_GID_ENTRY_SIZE)) {\n\t\t\tfound_ix = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found_ix >= 0) {\n\t\t \n\t\tif (found_ix < MLX4_ROCE_PF_GIDS)\n\t\t\tslave_gid = 0;\n\t\telse if (found_ix < MLX4_ROCE_PF_GIDS + (vf_gids % num_vfs) *\n\t\t\t (vf_gids / num_vfs + 1))\n\t\t\tslave_gid = ((found_ix - MLX4_ROCE_PF_GIDS) /\n\t\t\t\t     (vf_gids / num_vfs + 1)) + 1;\n\t\telse\n\t\t\tslave_gid =\n\t\t\t((found_ix - MLX4_ROCE_PF_GIDS -\n\t\t\t  ((vf_gids % num_vfs) * ((vf_gids / num_vfs + 1)))) /\n\t\t\t (vf_gids / num_vfs)) + vf_gids % num_vfs + 1;\n\n\t\t \n\t\tif (slave_gid) {\n\t\t\tstruct mlx4_active_ports exclusive_ports;\n\t\t\tstruct mlx4_active_ports actv_ports;\n\t\t\tstruct mlx4_slaves_pport slaves_pport_actv;\n\t\t\tunsigned max_port_p_one;\n\t\t\tint num_vfs_before = 0;\n\t\t\tint candidate_slave_gid;\n\n\t\t\t \n\t\t\tfor (i = 1; i < port; i++) {\n\t\t\t\tbitmap_zero(exclusive_ports.ports, dev->caps.num_ports);\n\t\t\t\tset_bit(i - 1, exclusive_ports.ports);\n\t\t\t\tslaves_pport_actv =\n\t\t\t\t\tmlx4_phys_to_slaves_pport_actv(\n\t\t\t\t\t\t\tdev, &exclusive_ports);\n\t\t\t\tnum_vfs_before += bitmap_weight(\n\t\t\t\t\t\tslaves_pport_actv.slaves,\n\t\t\t\t\t\tdev->persist->num_vfs + 1);\n\t\t\t}\n\n\t\t\t \n\t\t\tcandidate_slave_gid = slave_gid + num_vfs_before;\n\n\t\t\tactv_ports = mlx4_get_active_ports(dev, candidate_slave_gid);\n\t\t\tmax_port_p_one = find_first_bit(\n\t\t\t\tactv_ports.ports, dev->caps.num_ports) +\n\t\t\t\tbitmap_weight(actv_ports.ports,\n\t\t\t\t\t      dev->caps.num_ports) + 1;\n\n\t\t\t \n\t\t\tfor (i = 1; i < max_port_p_one; i++) {\n\t\t\t\tif (i == port)\n\t\t\t\t\tcontinue;\n\t\t\t\tbitmap_zero(exclusive_ports.ports,\n\t\t\t\t\t    dev->caps.num_ports);\n\t\t\t\tset_bit(i - 1, exclusive_ports.ports);\n\t\t\t\tslaves_pport_actv =\n\t\t\t\t\tmlx4_phys_to_slaves_pport_actv(\n\t\t\t\t\t\tdev, &exclusive_ports);\n\t\t\t\tslave_gid += bitmap_weight(\n\t\t\t\t\t\tslaves_pport_actv.slaves,\n\t\t\t\t\t\tdev->persist->num_vfs + 1);\n\t\t\t}\n\t\t}\n\t\t*slave_id = slave_gid;\n\t}\n\n\treturn (found_ix >= 0) ? 0 : -EINVAL;\n}\nEXPORT_SYMBOL(mlx4_get_slave_from_roce_gid);\n\nint mlx4_get_roce_gid_from_slave(struct mlx4_dev *dev, int port, int slave_id,\n\t\t\t\t u8 *gid)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tif (!mlx4_is_master(dev))\n\t\treturn -EINVAL;\n\n\tmemcpy(gid, priv->port[port].gid_table.roce_gids[slave_id].raw,\n\t       MLX4_ROCE_GID_ENTRY_SIZE);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlx4_get_roce_gid_from_slave);\n\n \n#define MODULE_INFO_MAX_READ 48\n\n#define I2C_ADDR_LOW  0x50\n#define I2C_ADDR_HIGH 0x51\n#define I2C_PAGE_SIZE 256\n#define I2C_HIGH_PAGE_SIZE 128\n\n \nstruct mlx4_cable_info {\n\tu8\ti2c_addr;\n\tu8\tpage_num;\n\t__be16\tdev_mem_address;\n\t__be16\treserved1;\n\t__be16\tsize;\n\t__be32\treserved2[2];\n\tu8\tdata[MODULE_INFO_MAX_READ];\n};\n\nenum cable_info_err {\n\t CABLE_INF_INV_PORT      = 0x1,\n\t CABLE_INF_OP_NOSUP      = 0x2,\n\t CABLE_INF_NOT_CONN      = 0x3,\n\t CABLE_INF_NO_EEPRM      = 0x4,\n\t CABLE_INF_PAGE_ERR      = 0x5,\n\t CABLE_INF_INV_ADDR      = 0x6,\n\t CABLE_INF_I2C_ADDR      = 0x7,\n\t CABLE_INF_QSFP_VIO      = 0x8,\n\t CABLE_INF_I2C_BUSY      = 0x9,\n};\n\n#define MAD_STATUS_2_CABLE_ERR(mad_status) ((mad_status >> 8) & 0xFF)\n\nstatic inline const char *cable_info_mad_err_str(u16 mad_status)\n{\n\tu8 err = MAD_STATUS_2_CABLE_ERR(mad_status);\n\n\tswitch (err) {\n\tcase CABLE_INF_INV_PORT:\n\t\treturn \"invalid port selected\";\n\tcase CABLE_INF_OP_NOSUP:\n\t\treturn \"operation not supported for this port (the port is of type CX4 or internal)\";\n\tcase CABLE_INF_NOT_CONN:\n\t\treturn \"cable is not connected\";\n\tcase CABLE_INF_NO_EEPRM:\n\t\treturn \"the connected cable has no EPROM (passive copper cable)\";\n\tcase CABLE_INF_PAGE_ERR:\n\t\treturn \"page number is greater than 15\";\n\tcase CABLE_INF_INV_ADDR:\n\t\treturn \"invalid device_address or size (that is, size equals 0 or address+size is greater than 256)\";\n\tcase CABLE_INF_I2C_ADDR:\n\t\treturn \"invalid I2C slave address\";\n\tcase CABLE_INF_QSFP_VIO:\n\t\treturn \"at least one cable violates the QSFP specification and ignores the modsel signal\";\n\tcase CABLE_INF_I2C_BUSY:\n\t\treturn \"I2C bus is constantly busy\";\n\t}\n\treturn \"Unknown Error\";\n}\n\nstatic int mlx4_get_module_id(struct mlx4_dev *dev, u8 port, u8 *module_id)\n{\n\tstruct mlx4_cmd_mailbox *inbox, *outbox;\n\tstruct mlx4_mad_ifc *inmad, *outmad;\n\tstruct mlx4_cable_info *cable_info;\n\tint ret;\n\n\tinbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(inbox))\n\t\treturn PTR_ERR(inbox);\n\n\toutbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(outbox)) {\n\t\tmlx4_free_cmd_mailbox(dev, inbox);\n\t\treturn PTR_ERR(outbox);\n\t}\n\n\tinmad = (struct mlx4_mad_ifc *)(inbox->buf);\n\toutmad = (struct mlx4_mad_ifc *)(outbox->buf);\n\n\tinmad->method = 0x1;  \n\tinmad->class_version = 0x1;\n\tinmad->mgmt_class = 0x1;\n\tinmad->base_version = 0x1;\n\tinmad->attr_id = cpu_to_be16(0xFF60);  \n\n\tcable_info = (struct mlx4_cable_info *)inmad->data;\n\tcable_info->dev_mem_address = 0;\n\tcable_info->page_num = 0;\n\tcable_info->i2c_addr = I2C_ADDR_LOW;\n\tcable_info->size = cpu_to_be16(1);\n\n\tret = mlx4_cmd_box(dev, inbox->dma, outbox->dma, port, 3,\n\t\t\t   MLX4_CMD_MAD_IFC, MLX4_CMD_TIME_CLASS_C,\n\t\t\t   MLX4_CMD_NATIVE);\n\tif (ret)\n\t\tgoto out;\n\n\tif (be16_to_cpu(outmad->status)) {\n\t\t \n\t\tret = be16_to_cpu(outmad->status);\n\t\tmlx4_warn(dev,\n\t\t\t  \"MLX4_CMD_MAD_IFC Get Module ID attr(%x) port(%d) i2c_addr(%x) offset(%d) size(%d): Response Mad Status(%x) - %s\\n\",\n\t\t\t  0xFF60, port, I2C_ADDR_LOW, 0, 1, ret,\n\t\t\t  cable_info_mad_err_str(ret));\n\t\tret = -ret;\n\t\tgoto out;\n\t}\n\tcable_info = (struct mlx4_cable_info *)outmad->data;\n\t*module_id = cable_info->data[0];\nout:\n\tmlx4_free_cmd_mailbox(dev, inbox);\n\tmlx4_free_cmd_mailbox(dev, outbox);\n\treturn ret;\n}\n\nstatic void mlx4_sfp_eeprom_params_set(u8 *i2c_addr, u8 *page_num, u16 *offset)\n{\n\t*i2c_addr = I2C_ADDR_LOW;\n\t*page_num = 0;\n\n\tif (*offset < I2C_PAGE_SIZE)\n\t\treturn;\n\n\t*i2c_addr = I2C_ADDR_HIGH;\n\t*offset -= I2C_PAGE_SIZE;\n}\n\nstatic void mlx4_qsfp_eeprom_params_set(u8 *i2c_addr, u8 *page_num, u16 *offset)\n{\n\t \n\tif (*offset < I2C_PAGE_SIZE)\n\t\t*page_num = 0;\n\telse\n\t\t*page_num = 1 + (*offset - I2C_PAGE_SIZE) / I2C_HIGH_PAGE_SIZE;\n\t*i2c_addr = I2C_ADDR_LOW;\n\t*offset -= *page_num * I2C_HIGH_PAGE_SIZE;\n}\n\n \nint mlx4_get_module_info(struct mlx4_dev *dev, u8 port,\n\t\t\t u16 offset, u16 size, u8 *data)\n{\n\tstruct mlx4_cmd_mailbox *inbox, *outbox;\n\tstruct mlx4_mad_ifc *inmad, *outmad;\n\tstruct mlx4_cable_info *cable_info;\n\tu8 module_id, i2c_addr, page_num;\n\tint ret;\n\n\tif (size > MODULE_INFO_MAX_READ)\n\t\tsize = MODULE_INFO_MAX_READ;\n\n\tret = mlx4_get_module_id(dev, port, &module_id);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (module_id) {\n\tcase MLX4_MODULE_ID_SFP:\n\t\tmlx4_sfp_eeprom_params_set(&i2c_addr, &page_num, &offset);\n\t\tbreak;\n\tcase MLX4_MODULE_ID_QSFP:\n\tcase MLX4_MODULE_ID_QSFP_PLUS:\n\tcase MLX4_MODULE_ID_QSFP28:\n\t\tmlx4_qsfp_eeprom_params_set(&i2c_addr, &page_num, &offset);\n\t\tbreak;\n\tdefault:\n\t\tmlx4_err(dev, \"Module ID not recognized: %#x\\n\", module_id);\n\t\treturn -EINVAL;\n\t}\n\n\tinbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(inbox))\n\t\treturn PTR_ERR(inbox);\n\n\toutbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(outbox)) {\n\t\tmlx4_free_cmd_mailbox(dev, inbox);\n\t\treturn PTR_ERR(outbox);\n\t}\n\n\tinmad = (struct mlx4_mad_ifc *)(inbox->buf);\n\toutmad = (struct mlx4_mad_ifc *)(outbox->buf);\n\n\tinmad->method = 0x1;  \n\tinmad->class_version = 0x1;\n\tinmad->mgmt_class = 0x1;\n\tinmad->base_version = 0x1;\n\tinmad->attr_id = cpu_to_be16(0xFF60);  \n\n\tif (offset < I2C_PAGE_SIZE && offset + size > I2C_PAGE_SIZE)\n\t\t \n\t\tsize -= offset + size - I2C_PAGE_SIZE;\n\n\tcable_info = (struct mlx4_cable_info *)inmad->data;\n\tcable_info->dev_mem_address = cpu_to_be16(offset);\n\tcable_info->page_num = page_num;\n\tcable_info->i2c_addr = i2c_addr;\n\tcable_info->size = cpu_to_be16(size);\n\n\tret = mlx4_cmd_box(dev, inbox->dma, outbox->dma, port, 3,\n\t\t\t   MLX4_CMD_MAD_IFC, MLX4_CMD_TIME_CLASS_C,\n\t\t\t   MLX4_CMD_NATIVE);\n\tif (ret)\n\t\tgoto out;\n\n\tif (be16_to_cpu(outmad->status)) {\n\t\t \n\t\tret = be16_to_cpu(outmad->status);\n\t\tmlx4_warn(dev,\n\t\t\t  \"MLX4_CMD_MAD_IFC Get Module info attr(%x) port(%d) i2c_addr(%x) offset(%d) size(%d): Response Mad Status(%x) - %s\\n\",\n\t\t\t  0xFF60, port, i2c_addr, offset, size,\n\t\t\t  ret, cable_info_mad_err_str(ret));\n\n\t\tif (i2c_addr == I2C_ADDR_HIGH &&\n\t\t    MAD_STATUS_2_CABLE_ERR(ret) == CABLE_INF_I2C_ADDR)\n\t\t\t \n\t\t\tret = 0;\n\t\telse\n\t\t\tret = -ret;\n\t\tgoto out;\n\t}\n\tcable_info = (struct mlx4_cable_info *)outmad->data;\n\tmemcpy(data, cable_info->data, size);\n\tret = size;\nout:\n\tmlx4_free_cmd_mailbox(dev, inbox);\n\tmlx4_free_cmd_mailbox(dev, outbox);\n\treturn ret;\n}\nEXPORT_SYMBOL(mlx4_get_module_info);\n\nint mlx4_max_tc(struct mlx4_dev *dev)\n{\n\tu8 num_tc = dev->caps.max_tc_eth;\n\n\tif (!num_tc)\n\t\tnum_tc = MLX4_TC_MAX_NUMBER;\n\n\treturn num_tc;\n}\nEXPORT_SYMBOL(mlx4_max_tc);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}