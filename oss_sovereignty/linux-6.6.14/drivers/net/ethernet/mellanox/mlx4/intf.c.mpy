{
  "module_name": "intf.c",
  "hash_id": "95c3415d37e147698f9b2d4be32fce75b674f78e5a624705f152d32d46e2148d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx4/intf.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n#include <net/devlink.h>\n\n#include \"mlx4.h\"\n\nstatic DEFINE_MUTEX(intf_mutex);\nstatic DEFINE_IDA(mlx4_adev_ida);\n\nstatic bool is_eth_supported(struct mlx4_dev *dev)\n{\n\tfor (int port = 1; port <= dev->caps.num_ports; port++)\n\t\tif (dev->caps.port_type[port] == MLX4_PORT_TYPE_ETH)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool is_ib_supported(struct mlx4_dev *dev)\n{\n\tfor (int port = 1; port <= dev->caps.num_ports; port++)\n\t\tif (dev->caps.port_type[port] == MLX4_PORT_TYPE_IB)\n\t\t\treturn true;\n\n\tif (dev->caps.flags & MLX4_DEV_CAP_FLAG_IBOE)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct mlx4_adev_device {\n\tconst char *suffix;\n\tbool (*is_supported)(struct mlx4_dev *dev);\n} mlx4_adev_devices[] = {\n\t{ \"eth\", is_eth_supported },\n\t{ \"ib\", is_ib_supported },\n};\n\nint mlx4_adev_init(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tpriv->adev_idx = ida_alloc(&mlx4_adev_ida, GFP_KERNEL);\n\tif (priv->adev_idx < 0)\n\t\treturn priv->adev_idx;\n\n\tpriv->adev = kcalloc(ARRAY_SIZE(mlx4_adev_devices),\n\t\t\t     sizeof(struct mlx4_adev *), GFP_KERNEL);\n\tif (!priv->adev) {\n\t\tida_free(&mlx4_adev_ida, priv->adev_idx);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid mlx4_adev_cleanup(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tkfree(priv->adev);\n\tida_free(&mlx4_adev_ida, priv->adev_idx);\n}\n\nstatic void adev_release(struct device *dev)\n{\n\tstruct mlx4_adev *mlx4_adev =\n\t\tcontainer_of(dev, struct mlx4_adev, adev.dev);\n\tstruct mlx4_priv *priv = mlx4_priv(mlx4_adev->mdev);\n\tint idx = mlx4_adev->idx;\n\n\tkfree(mlx4_adev);\n\tpriv->adev[idx] = NULL;\n}\n\nstatic struct mlx4_adev *add_adev(struct mlx4_dev *dev, int idx)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tconst char *suffix = mlx4_adev_devices[idx].suffix;\n\tstruct auxiliary_device *adev;\n\tstruct mlx4_adev *madev;\n\tint ret;\n\n\tmadev = kzalloc(sizeof(*madev), GFP_KERNEL);\n\tif (!madev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tadev = &madev->adev;\n\tadev->id = priv->adev_idx;\n\tadev->name = suffix;\n\tadev->dev.parent = &dev->persist->pdev->dev;\n\tadev->dev.release = adev_release;\n\tmadev->mdev = dev;\n\tmadev->idx = idx;\n\n\tret = auxiliary_device_init(adev);\n\tif (ret) {\n\t\tkfree(madev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = auxiliary_device_add(adev);\n\tif (ret) {\n\t\tauxiliary_device_uninit(adev);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn madev;\n}\n\nstatic void del_adev(struct auxiliary_device *adev)\n{\n\tauxiliary_device_delete(adev);\n\tauxiliary_device_uninit(adev);\n}\n\nint mlx4_register_auxiliary_driver(struct mlx4_adrv *madrv)\n{\n\treturn auxiliary_driver_register(&madrv->adrv);\n}\nEXPORT_SYMBOL_GPL(mlx4_register_auxiliary_driver);\n\nvoid mlx4_unregister_auxiliary_driver(struct mlx4_adrv *madrv)\n{\n\tauxiliary_driver_unregister(&madrv->adrv);\n}\nEXPORT_SYMBOL_GPL(mlx4_unregister_auxiliary_driver);\n\nint mlx4_do_bond(struct mlx4_dev *dev, bool enable)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint i, ret;\n\n\tif (!(dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_PORT_REMAP))\n\t\treturn -EOPNOTSUPP;\n\n\tret = mlx4_disable_rx_port_check(dev, enable);\n\tif (ret) {\n\t\tmlx4_err(dev, \"Fail to %s rx port check\\n\",\n\t\t\t enable ? \"enable\" : \"disable\");\n\t\treturn ret;\n\t}\n\tif (enable) {\n\t\tdev->flags |= MLX4_FLAG_BONDED;\n\t} else {\n\t\tret = mlx4_virt2phy_port_map(dev, 1, 2);\n\t\tif (ret) {\n\t\t\tmlx4_err(dev, \"Fail to reset port map\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tdev->flags &= ~MLX4_FLAG_BONDED;\n\t}\n\n\tmutex_lock(&intf_mutex);\n\n\tfor (i = 0; i < ARRAY_SIZE(mlx4_adev_devices); i++) {\n\t\tstruct mlx4_adev *madev = priv->adev[i];\n\t\tstruct mlx4_adrv *madrv;\n\t\tenum mlx4_protocol protocol;\n\n\t\tif (!madev)\n\t\t\tcontinue;\n\n\t\tdevice_lock(&madev->adev.dev);\n\t\tif (!madev->adev.dev.driver) {\n\t\t\tdevice_unlock(&madev->adev.dev);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmadrv = container_of(madev->adev.dev.driver, struct mlx4_adrv,\n\t\t\t\t     adrv.driver);\n\t\tif (!(madrv->flags & MLX4_INTFF_BONDING)) {\n\t\t\tdevice_unlock(&madev->adev.dev);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mlx4_is_mfunc(dev)) {\n\t\t\tmlx4_dbg(dev,\n\t\t\t\t \"SRIOV, disabled HA mode for intf proto %d\\n\",\n\t\t\t\t madrv->protocol);\n\t\t\tdevice_unlock(&madev->adev.dev);\n\t\t\tcontinue;\n\t\t}\n\n\t\tprotocol = madrv->protocol;\n\t\tdevice_unlock(&madev->adev.dev);\n\n\t\tdel_adev(&madev->adev);\n\t\tpriv->adev[i] = add_adev(dev, i);\n\t\tif (IS_ERR(priv->adev[i])) {\n\t\t\tmlx4_warn(dev, \"Device[%d] (%s) failed to load\\n\", i,\n\t\t\t\t  mlx4_adev_devices[i].suffix);\n\t\t\tpriv->adev[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmlx4_dbg(dev,\n\t\t\t \"Interface for protocol %d restarted with bonded mode %s\\n\",\n\t\t\t protocol, enable ? \"enabled\" : \"disabled\");\n\t}\n\n\tmutex_unlock(&intf_mutex);\n\n\treturn 0;\n}\n\nvoid mlx4_dispatch_event(struct mlx4_dev *dev, enum mlx4_dev_event type,\n\t\t\t void *param)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\tatomic_notifier_call_chain(&priv->event_nh, type, param);\n}\n\nint mlx4_register_event_notifier(struct mlx4_dev *dev,\n\t\t\t\t struct notifier_block *nb)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\treturn atomic_notifier_chain_register(&priv->event_nh, nb);\n}\nEXPORT_SYMBOL(mlx4_register_event_notifier);\n\nint mlx4_unregister_event_notifier(struct mlx4_dev *dev,\n\t\t\t\t   struct notifier_block *nb)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\n\treturn atomic_notifier_chain_unregister(&priv->event_nh, nb);\n}\nEXPORT_SYMBOL(mlx4_unregister_event_notifier);\n\nstatic int add_drivers(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tint i, ret = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(mlx4_adev_devices); i++) {\n\t\tbool is_supported = false;\n\n\t\tif (priv->adev[i])\n\t\t\tcontinue;\n\n\t\tif (mlx4_adev_devices[i].is_supported)\n\t\t\tis_supported = mlx4_adev_devices[i].is_supported(dev);\n\n\t\tif (!is_supported)\n\t\t\tcontinue;\n\n\t\tpriv->adev[i] = add_adev(dev, i);\n\t\tif (IS_ERR(priv->adev[i])) {\n\t\t\tmlx4_warn(dev, \"Device[%d] (%s) failed to load\\n\", i,\n\t\t\t\t  mlx4_adev_devices[i].suffix);\n\t\t\t \n\t\t\tret = PTR_ERR(priv->adev[i]);\n\t\t\tpriv->adev[i] = NULL;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void delete_drivers(struct mlx4_dev *dev)\n{\n\tstruct mlx4_priv *priv = mlx4_priv(dev);\n\tbool delete_all;\n\tint i;\n\n\tdelete_all = !(dev->persist->interface_state & MLX4_INTERFACE_STATE_UP);\n\n\tfor (i = ARRAY_SIZE(mlx4_adev_devices) - 1; i >= 0; i--) {\n\t\tbool is_supported = false;\n\n\t\tif (!priv->adev[i])\n\t\t\tcontinue;\n\n\t\tif (mlx4_adev_devices[i].is_supported && !delete_all)\n\t\t\tis_supported = mlx4_adev_devices[i].is_supported(dev);\n\n\t\tif (is_supported)\n\t\t\tcontinue;\n\n\t\tdel_adev(&priv->adev[i]->adev);\n\t\tpriv->adev[i] = NULL;\n\t}\n}\n\n \nstatic int rescan_drivers_locked(struct mlx4_dev *dev)\n{\n\tlockdep_assert_held(&intf_mutex);\n\n\tdelete_drivers(dev);\n\tif (!(dev->persist->interface_state & MLX4_INTERFACE_STATE_UP))\n\t\treturn 0;\n\n\treturn add_drivers(dev);\n}\n\nint mlx4_register_device(struct mlx4_dev *dev)\n{\n\tint ret;\n\n\tmutex_lock(&intf_mutex);\n\n\tdev->persist->interface_state |= MLX4_INTERFACE_STATE_UP;\n\n\tret = rescan_drivers_locked(dev);\n\n\tmutex_unlock(&intf_mutex);\n\n\tif (ret) {\n\t\tmlx4_unregister_device(dev);\n\t\treturn ret;\n\t}\n\n\tmlx4_start_catas_poll(dev);\n\n\treturn ret;\n}\n\nvoid mlx4_unregister_device(struct mlx4_dev *dev)\n{\n\tif (!(dev->persist->interface_state & MLX4_INTERFACE_STATE_UP))\n\t\treturn;\n\n\tmlx4_stop_catas_poll(dev);\n\tif (dev->persist->interface_state & MLX4_INTERFACE_STATE_DELETION &&\n\t    mlx4_is_slave(dev)) {\n\t\t \n\t\tu32 slave_read =\n\t\t\tswab32(readl(&mlx4_priv(dev)->mfunc.comm->slave_read));\n\n\t\tif (mlx4_comm_internal_err(slave_read)) {\n\t\t\tmlx4_dbg(dev, \"%s: comm channel is down, entering error state.\\n\",\n\t\t\t\t __func__);\n\t\t\tmlx4_enter_error_state(dev->persist);\n\t\t}\n\t}\n\tmutex_lock(&intf_mutex);\n\n\tdev->persist->interface_state &= ~MLX4_INTERFACE_STATE_UP;\n\n\trescan_drivers_locked(dev);\n\n\tmutex_unlock(&intf_mutex);\n}\n\nstruct devlink_port *mlx4_get_devlink_port(struct mlx4_dev *dev, int port)\n{\n\tstruct mlx4_port_info *info = &mlx4_priv(dev)->port[port];\n\n\treturn &info->devlink_port;\n}\nEXPORT_SYMBOL_GPL(mlx4_get_devlink_port);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}