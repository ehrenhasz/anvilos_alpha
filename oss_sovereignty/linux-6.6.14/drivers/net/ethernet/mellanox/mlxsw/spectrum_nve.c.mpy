{
  "module_name": "spectrum_nve.c",
  "hash_id": "11fd8a4ae5894e93d98ea09c14aba86debfcb96bed0f832e5d8bad622769631e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_nve.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <net/inet_ecn.h>\n#include <net/ipv6.h>\n\n#include \"reg.h\"\n#include \"spectrum.h\"\n#include \"spectrum_nve.h\"\n\nconst struct mlxsw_sp_nve_ops *mlxsw_sp1_nve_ops_arr[] = {\n\t[MLXSW_SP_NVE_TYPE_VXLAN]\t= &mlxsw_sp1_nve_vxlan_ops,\n};\n\nconst struct mlxsw_sp_nve_ops *mlxsw_sp2_nve_ops_arr[] = {\n\t[MLXSW_SP_NVE_TYPE_VXLAN]\t= &mlxsw_sp2_nve_vxlan_ops,\n};\n\nstruct mlxsw_sp_nve_mc_entry;\nstruct mlxsw_sp_nve_mc_record;\nstruct mlxsw_sp_nve_mc_list;\n\nstruct mlxsw_sp_nve_mc_record_ops {\n\tenum mlxsw_reg_tnumt_record_type type;\n\tint (*entry_add)(struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t struct mlxsw_sp_nve_mc_entry *mc_entry,\n\t\t\t const union mlxsw_sp_l3addr *addr);\n\tvoid (*entry_del)(const struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t  const struct mlxsw_sp_nve_mc_entry *mc_entry);\n\tvoid (*entry_set)(const struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t  const struct mlxsw_sp_nve_mc_entry *mc_entry,\n\t\t\t  char *tnumt_pl, unsigned int entry_index);\n\tbool (*entry_compare)(const struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t      const struct mlxsw_sp_nve_mc_entry *mc_entry,\n\t\t\t      const union mlxsw_sp_l3addr *addr);\n};\n\nstruct mlxsw_sp_nve_mc_list_key {\n\tu16 fid_index;\n};\n\nstruct mlxsw_sp_nve_mc_ipv6_entry {\n\tstruct in6_addr addr6;\n\tu32 addr6_kvdl_index;\n};\n\nstruct mlxsw_sp_nve_mc_entry {\n\tunion {\n\t\t__be32 addr4;\n\t\tstruct mlxsw_sp_nve_mc_ipv6_entry ipv6_entry;\n\t};\n\tu8 valid:1;\n};\n\nstruct mlxsw_sp_nve_mc_record {\n\tstruct list_head list;\n\tenum mlxsw_sp_l3proto proto;\n\tunsigned int num_entries;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct mlxsw_sp_nve_mc_list *mc_list;\n\tconst struct mlxsw_sp_nve_mc_record_ops *ops;\n\tu32 kvdl_index;\n\tstruct mlxsw_sp_nve_mc_entry entries[];\n};\n\nstruct mlxsw_sp_nve_mc_list {\n\tstruct list_head records_list;\n\tstruct rhash_head ht_node;\n\tstruct mlxsw_sp_nve_mc_list_key key;\n};\n\nstatic const struct rhashtable_params mlxsw_sp_nve_mc_list_ht_params = {\n\t.key_len = sizeof(struct mlxsw_sp_nve_mc_list_key),\n\t.key_offset = offsetof(struct mlxsw_sp_nve_mc_list, key),\n\t.head_offset = offsetof(struct mlxsw_sp_nve_mc_list, ht_node),\n};\n\nstatic int\nmlxsw_sp_nve_mc_record_ipv4_entry_add(struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t\t      struct mlxsw_sp_nve_mc_entry *mc_entry,\n\t\t\t\t      const union mlxsw_sp_l3addr *addr)\n{\n\tmc_entry->addr4 = addr->addr4;\n\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_nve_mc_record_ipv4_entry_del(const struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t\t      const struct mlxsw_sp_nve_mc_entry *mc_entry)\n{\n}\n\nstatic void\nmlxsw_sp_nve_mc_record_ipv4_entry_set(const struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t\t      const struct mlxsw_sp_nve_mc_entry *mc_entry,\n\t\t\t\t      char *tnumt_pl, unsigned int entry_index)\n{\n\tu32 udip = be32_to_cpu(mc_entry->addr4);\n\n\tmlxsw_reg_tnumt_udip_set(tnumt_pl, entry_index, udip);\n}\n\nstatic bool\nmlxsw_sp_nve_mc_record_ipv4_entry_compare(const struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t\t\t  const struct mlxsw_sp_nve_mc_entry *mc_entry,\n\t\t\t\t\t  const union mlxsw_sp_l3addr *addr)\n{\n\treturn mc_entry->addr4 == addr->addr4;\n}\n\nstatic const struct mlxsw_sp_nve_mc_record_ops\nmlxsw_sp_nve_mc_record_ipv4_ops = {\n\t.type\t\t= MLXSW_REG_TNUMT_RECORD_TYPE_IPV4,\n\t.entry_add\t= &mlxsw_sp_nve_mc_record_ipv4_entry_add,\n\t.entry_del\t= &mlxsw_sp_nve_mc_record_ipv4_entry_del,\n\t.entry_set\t= &mlxsw_sp_nve_mc_record_ipv4_entry_set,\n\t.entry_compare\t= &mlxsw_sp_nve_mc_record_ipv4_entry_compare,\n};\n\nstatic int\nmlxsw_sp_nve_mc_record_ipv6_entry_add(struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t\t      struct mlxsw_sp_nve_mc_entry *mc_entry,\n\t\t\t\t      const union mlxsw_sp_l3addr *addr)\n{\n\tu32 kvdl_index;\n\tint err;\n\n\terr = mlxsw_sp_ipv6_addr_kvdl_index_get(mc_record->mlxsw_sp,\n\t\t\t\t\t\t&addr->addr6, &kvdl_index);\n\tif (err)\n\t\treturn err;\n\n\tmc_entry->ipv6_entry.addr6 = addr->addr6;\n\tmc_entry->ipv6_entry.addr6_kvdl_index = kvdl_index;\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_nve_mc_record_ipv6_entry_del(const struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t\t      const struct mlxsw_sp_nve_mc_entry *mc_entry)\n{\n\tmlxsw_sp_ipv6_addr_put(mc_record->mlxsw_sp,\n\t\t\t       &mc_entry->ipv6_entry.addr6);\n}\n\nstatic void\nmlxsw_sp_nve_mc_record_ipv6_entry_set(const struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t\t      const struct mlxsw_sp_nve_mc_entry *mc_entry,\n\t\t\t\t      char *tnumt_pl, unsigned int entry_index)\n{\n\tu32 udip_ptr = mc_entry->ipv6_entry.addr6_kvdl_index;\n\n\tmlxsw_reg_tnumt_udip_ptr_set(tnumt_pl, entry_index, udip_ptr);\n}\n\nstatic bool\nmlxsw_sp_nve_mc_record_ipv6_entry_compare(const struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t\t\t  const struct mlxsw_sp_nve_mc_entry *mc_entry,\n\t\t\t\t\t  const union mlxsw_sp_l3addr *addr)\n{\n\treturn ipv6_addr_equal(&mc_entry->ipv6_entry.addr6, &addr->addr6);\n}\n\nstatic const struct mlxsw_sp_nve_mc_record_ops\nmlxsw_sp_nve_mc_record_ipv6_ops = {\n\t.type\t\t= MLXSW_REG_TNUMT_RECORD_TYPE_IPV6,\n\t.entry_add\t= &mlxsw_sp_nve_mc_record_ipv6_entry_add,\n\t.entry_del\t= &mlxsw_sp_nve_mc_record_ipv6_entry_del,\n\t.entry_set\t= &mlxsw_sp_nve_mc_record_ipv6_entry_set,\n\t.entry_compare\t= &mlxsw_sp_nve_mc_record_ipv6_entry_compare,\n};\n\nstatic const struct mlxsw_sp_nve_mc_record_ops *\nmlxsw_sp_nve_mc_record_ops_arr[] = {\n\t[MLXSW_SP_L3_PROTO_IPV4] = &mlxsw_sp_nve_mc_record_ipv4_ops,\n\t[MLXSW_SP_L3_PROTO_IPV6] = &mlxsw_sp_nve_mc_record_ipv6_ops,\n};\n\nint mlxsw_sp_nve_learned_ip_resolve(struct mlxsw_sp *mlxsw_sp, u32 uip,\n\t\t\t\t    enum mlxsw_sp_l3proto proto,\n\t\t\t\t    union mlxsw_sp_l3addr *addr)\n{\n\tswitch (proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\taddr->addr4 = cpu_to_be32(uip);\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic struct mlxsw_sp_nve_mc_list *\nmlxsw_sp_nve_mc_list_find(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  const struct mlxsw_sp_nve_mc_list_key *key)\n{\n\tstruct mlxsw_sp_nve *nve = mlxsw_sp->nve;\n\n\treturn rhashtable_lookup_fast(&nve->mc_list_ht, key,\n\t\t\t\t      mlxsw_sp_nve_mc_list_ht_params);\n}\n\nstatic struct mlxsw_sp_nve_mc_list *\nmlxsw_sp_nve_mc_list_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    const struct mlxsw_sp_nve_mc_list_key *key)\n{\n\tstruct mlxsw_sp_nve *nve = mlxsw_sp->nve;\n\tstruct mlxsw_sp_nve_mc_list *mc_list;\n\tint err;\n\n\tmc_list = kmalloc(sizeof(*mc_list), GFP_KERNEL);\n\tif (!mc_list)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&mc_list->records_list);\n\tmc_list->key = *key;\n\n\terr = rhashtable_insert_fast(&nve->mc_list_ht, &mc_list->ht_node,\n\t\t\t\t     mlxsw_sp_nve_mc_list_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_insert;\n\n\treturn mc_list;\n\nerr_rhashtable_insert:\n\tkfree(mc_list);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_nve_mc_list_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t struct mlxsw_sp_nve_mc_list *mc_list)\n{\n\tstruct mlxsw_sp_nve *nve = mlxsw_sp->nve;\n\n\trhashtable_remove_fast(&nve->mc_list_ht, &mc_list->ht_node,\n\t\t\t       mlxsw_sp_nve_mc_list_ht_params);\n\tWARN_ON(!list_empty(&mc_list->records_list));\n\tkfree(mc_list);\n}\n\nstatic struct mlxsw_sp_nve_mc_list *\nmlxsw_sp_nve_mc_list_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t const struct mlxsw_sp_nve_mc_list_key *key)\n{\n\tstruct mlxsw_sp_nve_mc_list *mc_list;\n\n\tmc_list = mlxsw_sp_nve_mc_list_find(mlxsw_sp, key);\n\tif (mc_list)\n\t\treturn mc_list;\n\n\treturn mlxsw_sp_nve_mc_list_create(mlxsw_sp, key);\n}\n\nstatic void\nmlxsw_sp_nve_mc_list_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t struct mlxsw_sp_nve_mc_list *mc_list)\n{\n\tif (!list_empty(&mc_list->records_list))\n\t\treturn;\n\tmlxsw_sp_nve_mc_list_destroy(mlxsw_sp, mc_list);\n}\n\nstatic struct mlxsw_sp_nve_mc_record *\nmlxsw_sp_nve_mc_record_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_nve_mc_list *mc_list,\n\t\t\t      enum mlxsw_sp_l3proto proto)\n{\n\tunsigned int num_max_entries = mlxsw_sp->nve->num_max_mc_entries[proto];\n\tstruct mlxsw_sp_nve_mc_record *mc_record;\n\tint err;\n\n\tmc_record = kzalloc(struct_size(mc_record, entries, num_max_entries),\n\t\t\t    GFP_KERNEL);\n\tif (!mc_record)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = mlxsw_sp_kvdl_alloc(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_TNUMT, 1,\n\t\t\t\t  &mc_record->kvdl_index);\n\tif (err)\n\t\tgoto err_kvdl_alloc;\n\n\tmc_record->ops = mlxsw_sp_nve_mc_record_ops_arr[proto];\n\tmc_record->mlxsw_sp = mlxsw_sp;\n\tmc_record->mc_list = mc_list;\n\tmc_record->proto = proto;\n\tlist_add_tail(&mc_record->list, &mc_list->records_list);\n\n\treturn mc_record;\n\nerr_kvdl_alloc:\n\tkfree(mc_record);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_nve_mc_record_destroy(struct mlxsw_sp_nve_mc_record *mc_record)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mc_record->mlxsw_sp;\n\n\tlist_del(&mc_record->list);\n\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_TNUMT, 1,\n\t\t\t   mc_record->kvdl_index);\n\tWARN_ON(mc_record->num_entries);\n\tkfree(mc_record);\n}\n\nstatic struct mlxsw_sp_nve_mc_record *\nmlxsw_sp_nve_mc_record_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   struct mlxsw_sp_nve_mc_list *mc_list,\n\t\t\t   enum mlxsw_sp_l3proto proto)\n{\n\tstruct mlxsw_sp_nve_mc_record *mc_record;\n\n\tlist_for_each_entry_reverse(mc_record, &mc_list->records_list, list) {\n\t\tunsigned int num_entries = mc_record->num_entries;\n\t\tstruct mlxsw_sp_nve *nve = mlxsw_sp->nve;\n\n\t\tif (mc_record->proto == proto &&\n\t\t    num_entries < nve->num_max_mc_entries[proto])\n\t\t\treturn mc_record;\n\t}\n\n\treturn mlxsw_sp_nve_mc_record_create(mlxsw_sp, mc_list, proto);\n}\n\nstatic void\nmlxsw_sp_nve_mc_record_put(struct mlxsw_sp_nve_mc_record *mc_record)\n{\n\tif (mc_record->num_entries != 0)\n\t\treturn;\n\n\tmlxsw_sp_nve_mc_record_destroy(mc_record);\n}\n\nstatic struct mlxsw_sp_nve_mc_entry *\nmlxsw_sp_nve_mc_free_entry_find(struct mlxsw_sp_nve_mc_record *mc_record)\n{\n\tstruct mlxsw_sp_nve *nve = mc_record->mlxsw_sp->nve;\n\tunsigned int num_max_entries;\n\tint i;\n\n\tnum_max_entries = nve->num_max_mc_entries[mc_record->proto];\n\tfor (i = 0; i < num_max_entries; i++) {\n\t\tif (mc_record->entries[i].valid)\n\t\t\tcontinue;\n\t\treturn &mc_record->entries[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int\nmlxsw_sp_nve_mc_record_refresh(struct mlxsw_sp_nve_mc_record *mc_record)\n{\n\tenum mlxsw_reg_tnumt_record_type type = mc_record->ops->type;\n\tstruct mlxsw_sp_nve_mc_list *mc_list = mc_record->mc_list;\n\tstruct mlxsw_sp *mlxsw_sp = mc_record->mlxsw_sp;\n\tchar tnumt_pl[MLXSW_REG_TNUMT_LEN];\n\tunsigned int num_max_entries;\n\tunsigned int num_entries = 0;\n\tu32 next_kvdl_index = 0;\n\tbool next_valid = false;\n\tint i;\n\n\tif (!list_is_last(&mc_record->list, &mc_list->records_list)) {\n\t\tstruct mlxsw_sp_nve_mc_record *next_record;\n\n\t\tnext_record = list_next_entry(mc_record, list);\n\t\tnext_kvdl_index = next_record->kvdl_index;\n\t\tnext_valid = true;\n\t}\n\n\tmlxsw_reg_tnumt_pack(tnumt_pl, type, MLXSW_REG_TUNNEL_PORT_NVE,\n\t\t\t     mc_record->kvdl_index, next_valid,\n\t\t\t     next_kvdl_index, mc_record->num_entries);\n\n\tnum_max_entries = mlxsw_sp->nve->num_max_mc_entries[mc_record->proto];\n\tfor (i = 0; i < num_max_entries; i++) {\n\t\tstruct mlxsw_sp_nve_mc_entry *mc_entry;\n\n\t\tmc_entry = &mc_record->entries[i];\n\t\tif (!mc_entry->valid)\n\t\t\tcontinue;\n\t\tmc_record->ops->entry_set(mc_record, mc_entry, tnumt_pl,\n\t\t\t\t\t  num_entries++);\n\t}\n\n\tWARN_ON(num_entries != mc_record->num_entries);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(tnumt), tnumt_pl);\n}\n\nstatic bool\nmlxsw_sp_nve_mc_record_is_first(struct mlxsw_sp_nve_mc_record *mc_record)\n{\n\tstruct mlxsw_sp_nve_mc_list *mc_list = mc_record->mc_list;\n\tstruct mlxsw_sp_nve_mc_record *first_record;\n\n\tfirst_record = list_first_entry(&mc_list->records_list,\n\t\t\t\t\tstruct mlxsw_sp_nve_mc_record, list);\n\n\treturn mc_record == first_record;\n}\n\nstatic struct mlxsw_sp_nve_mc_entry *\nmlxsw_sp_nve_mc_entry_find(struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t   union mlxsw_sp_l3addr *addr)\n{\n\tstruct mlxsw_sp_nve *nve = mc_record->mlxsw_sp->nve;\n\tunsigned int num_max_entries;\n\tint i;\n\n\tnum_max_entries = nve->num_max_mc_entries[mc_record->proto];\n\tfor (i = 0; i < num_max_entries; i++) {\n\t\tstruct mlxsw_sp_nve_mc_entry *mc_entry;\n\n\t\tmc_entry = &mc_record->entries[i];\n\t\tif (!mc_entry->valid)\n\t\t\tcontinue;\n\t\tif (mc_record->ops->entry_compare(mc_record, mc_entry, addr))\n\t\t\treturn mc_entry;\n\t}\n\n\treturn NULL;\n}\n\nstatic int\nmlxsw_sp_nve_mc_record_ip_add(struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t      union mlxsw_sp_l3addr *addr)\n{\n\tstruct mlxsw_sp_nve_mc_entry *mc_entry = NULL;\n\tint err;\n\n\tmc_entry = mlxsw_sp_nve_mc_free_entry_find(mc_record);\n\tif (WARN_ON(!mc_entry))\n\t\treturn -EINVAL;\n\n\terr = mc_record->ops->entry_add(mc_record, mc_entry, addr);\n\tif (err)\n\t\treturn err;\n\tmc_record->num_entries++;\n\tmc_entry->valid = true;\n\n\terr = mlxsw_sp_nve_mc_record_refresh(mc_record);\n\tif (err)\n\t\tgoto err_record_refresh;\n\n\t \n\tif (mc_record->num_entries != 1 ||\n\t    mlxsw_sp_nve_mc_record_is_first(mc_record))\n\t\treturn 0;\n\n\terr = mlxsw_sp_nve_mc_record_refresh(list_prev_entry(mc_record, list));\n\tif (err)\n\t\tgoto err_prev_record_refresh;\n\n\treturn 0;\n\nerr_prev_record_refresh:\nerr_record_refresh:\n\tmc_entry->valid = false;\n\tmc_record->num_entries--;\n\tmc_record->ops->entry_del(mc_record, mc_entry);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_nve_mc_record_entry_del(struct mlxsw_sp_nve_mc_record *mc_record,\n\t\t\t\t struct mlxsw_sp_nve_mc_entry *mc_entry)\n{\n\tstruct mlxsw_sp_nve_mc_list *mc_list = mc_record->mc_list;\n\n\tmc_entry->valid = false;\n\tmc_record->num_entries--;\n\n\t \n\tif (mc_record->num_entries != 0) {\n\t\tmlxsw_sp_nve_mc_record_refresh(mc_record);\n\t\tmc_record->ops->entry_del(mc_record, mc_entry);\n\t\treturn;\n\t}\n\n\t \n\tif (!mlxsw_sp_nve_mc_record_is_first(mc_record)) {\n\t\tstruct mlxsw_sp_nve_mc_record *prev_record;\n\n\t\tprev_record = list_prev_entry(mc_record, list);\n\t\tlist_del(&mc_record->list);\n\t\tmlxsw_sp_nve_mc_record_refresh(prev_record);\n\t\tlist_add_tail(&mc_record->list, &mc_list->records_list);\n\t\tmc_record->ops->entry_del(mc_record, mc_entry);\n\t\treturn;\n\t}\n\n\t \n\tif (mlxsw_sp_nve_mc_record_is_first(mc_record) &&\n\t    !list_is_singular(&mc_list->records_list)) {\n\t\tstruct mlxsw_sp_nve_mc_record *next_record;\n\n\t\tnext_record = list_next_entry(mc_record, list);\n\t\tswap(mc_record->kvdl_index, next_record->kvdl_index);\n\t\tmlxsw_sp_nve_mc_record_refresh(next_record);\n\t\tmc_record->ops->entry_del(mc_record, mc_entry);\n\t\treturn;\n\t}\n\n\t \n\tmc_record->ops->entry_del(mc_record, mc_entry);\n}\n\nstatic struct mlxsw_sp_nve_mc_record *\nmlxsw_sp_nve_mc_record_find(struct mlxsw_sp_nve_mc_list *mc_list,\n\t\t\t    enum mlxsw_sp_l3proto proto,\n\t\t\t    union mlxsw_sp_l3addr *addr,\n\t\t\t    struct mlxsw_sp_nve_mc_entry **mc_entry)\n{\n\tstruct mlxsw_sp_nve_mc_record *mc_record;\n\n\tlist_for_each_entry(mc_record, &mc_list->records_list, list) {\n\t\tif (mc_record->proto != proto)\n\t\t\tcontinue;\n\n\t\t*mc_entry = mlxsw_sp_nve_mc_entry_find(mc_record, addr);\n\t\tif (*mc_entry)\n\t\t\treturn mc_record;\n\t}\n\n\treturn NULL;\n}\n\nstatic int mlxsw_sp_nve_mc_list_ip_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_nve_mc_list *mc_list,\n\t\t\t\t       enum mlxsw_sp_l3proto proto,\n\t\t\t\t       union mlxsw_sp_l3addr *addr)\n{\n\tstruct mlxsw_sp_nve_mc_record *mc_record;\n\tint err;\n\n\tmc_record = mlxsw_sp_nve_mc_record_get(mlxsw_sp, mc_list, proto);\n\tif (IS_ERR(mc_record))\n\t\treturn PTR_ERR(mc_record);\n\n\terr = mlxsw_sp_nve_mc_record_ip_add(mc_record, addr);\n\tif (err)\n\t\tgoto err_ip_add;\n\n\treturn 0;\n\nerr_ip_add:\n\tmlxsw_sp_nve_mc_record_put(mc_record);\n\treturn err;\n}\n\nstatic void mlxsw_sp_nve_mc_list_ip_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_nve_mc_list *mc_list,\n\t\t\t\t\tenum mlxsw_sp_l3proto proto,\n\t\t\t\t\tunion mlxsw_sp_l3addr *addr)\n{\n\tstruct mlxsw_sp_nve_mc_record *mc_record;\n\tstruct mlxsw_sp_nve_mc_entry *mc_entry;\n\n\tmc_record = mlxsw_sp_nve_mc_record_find(mc_list, proto, addr,\n\t\t\t\t\t\t&mc_entry);\n\tif (!mc_record)\n\t\treturn;\n\n\tmlxsw_sp_nve_mc_record_entry_del(mc_record, mc_entry);\n\tmlxsw_sp_nve_mc_record_put(mc_record);\n}\n\nstatic int\nmlxsw_sp_nve_fid_flood_index_set(struct mlxsw_sp_fid *fid,\n\t\t\t\t struct mlxsw_sp_nve_mc_list *mc_list)\n{\n\tstruct mlxsw_sp_nve_mc_record *mc_record;\n\n\t \n\tif (mlxsw_sp_fid_nve_flood_index_is_set(fid))\n\t\treturn 0;\n\n\tmc_record = list_first_entry(&mc_list->records_list,\n\t\t\t\t     struct mlxsw_sp_nve_mc_record, list);\n\n\treturn mlxsw_sp_fid_nve_flood_index_set(fid, mc_record->kvdl_index);\n}\n\nstatic void\nmlxsw_sp_nve_fid_flood_index_clear(struct mlxsw_sp_fid *fid,\n\t\t\t\t   struct mlxsw_sp_nve_mc_list *mc_list)\n{\n\tstruct mlxsw_sp_nve_mc_record *mc_record;\n\n\t \n\tif (!list_is_singular(&mc_list->records_list))\n\t\treturn;\n\n\tmc_record = list_first_entry(&mc_list->records_list,\n\t\t\t\t     struct mlxsw_sp_nve_mc_record, list);\n\tif (mc_record->num_entries != 1)\n\t\treturn;\n\n\treturn mlxsw_sp_fid_nve_flood_index_clear(fid);\n}\n\nint mlxsw_sp_nve_flood_ip_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_fid *fid,\n\t\t\t      enum mlxsw_sp_l3proto proto,\n\t\t\t      union mlxsw_sp_l3addr *addr)\n{\n\tstruct mlxsw_sp_nve_mc_list_key key = { 0 };\n\tstruct mlxsw_sp_nve_mc_list *mc_list;\n\tint err;\n\n\tkey.fid_index = mlxsw_sp_fid_index(fid);\n\tmc_list = mlxsw_sp_nve_mc_list_get(mlxsw_sp, &key);\n\tif (IS_ERR(mc_list))\n\t\treturn PTR_ERR(mc_list);\n\n\terr = mlxsw_sp_nve_mc_list_ip_add(mlxsw_sp, mc_list, proto, addr);\n\tif (err)\n\t\tgoto err_add_ip;\n\n\terr = mlxsw_sp_nve_fid_flood_index_set(fid, mc_list);\n\tif (err)\n\t\tgoto err_fid_flood_index_set;\n\n\treturn 0;\n\nerr_fid_flood_index_set:\n\tmlxsw_sp_nve_mc_list_ip_del(mlxsw_sp, mc_list, proto, addr);\nerr_add_ip:\n\tmlxsw_sp_nve_mc_list_put(mlxsw_sp, mc_list);\n\treturn err;\n}\n\nvoid mlxsw_sp_nve_flood_ip_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_fid *fid,\n\t\t\t       enum mlxsw_sp_l3proto proto,\n\t\t\t       union mlxsw_sp_l3addr *addr)\n{\n\tstruct mlxsw_sp_nve_mc_list_key key = { 0 };\n\tstruct mlxsw_sp_nve_mc_list *mc_list;\n\n\tkey.fid_index = mlxsw_sp_fid_index(fid);\n\tmc_list = mlxsw_sp_nve_mc_list_find(mlxsw_sp, &key);\n\tif (!mc_list)\n\t\treturn;\n\n\tmlxsw_sp_nve_fid_flood_index_clear(fid, mc_list);\n\tmlxsw_sp_nve_mc_list_ip_del(mlxsw_sp, mc_list, proto, addr);\n\tmlxsw_sp_nve_mc_list_put(mlxsw_sp, mc_list);\n}\n\nstatic void\nmlxsw_sp_nve_mc_record_delete(struct mlxsw_sp_nve_mc_record *mc_record)\n{\n\tstruct mlxsw_sp_nve *nve = mc_record->mlxsw_sp->nve;\n\tunsigned int num_max_entries;\n\tint i;\n\n\tnum_max_entries = nve->num_max_mc_entries[mc_record->proto];\n\tfor (i = 0; i < num_max_entries; i++) {\n\t\tstruct mlxsw_sp_nve_mc_entry *mc_entry = &mc_record->entries[i];\n\n\t\tif (!mc_entry->valid)\n\t\t\tcontinue;\n\t\tmlxsw_sp_nve_mc_record_entry_del(mc_record, mc_entry);\n\t}\n\n\tWARN_ON(mc_record->num_entries);\n\tmlxsw_sp_nve_mc_record_put(mc_record);\n}\n\nstatic void mlxsw_sp_nve_flood_ip_flush(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_fid *fid)\n{\n\tstruct mlxsw_sp_nve_mc_record *mc_record, *tmp;\n\tstruct mlxsw_sp_nve_mc_list_key key = { 0 };\n\tstruct mlxsw_sp_nve_mc_list *mc_list;\n\n\tif (!mlxsw_sp_fid_nve_flood_index_is_set(fid))\n\t\treturn;\n\n\tmlxsw_sp_fid_nve_flood_index_clear(fid);\n\n\tkey.fid_index = mlxsw_sp_fid_index(fid);\n\tmc_list = mlxsw_sp_nve_mc_list_find(mlxsw_sp, &key);\n\tif (WARN_ON(!mc_list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(mc_record, tmp, &mc_list->records_list, list)\n\t\tmlxsw_sp_nve_mc_record_delete(mc_record);\n\n\tWARN_ON(!list_empty(&mc_list->records_list));\n\tmlxsw_sp_nve_mc_list_put(mlxsw_sp, mc_list);\n}\n\nstatic int mlxsw_sp_nve_tunnel_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_nve_config *config)\n{\n\tstruct mlxsw_sp_nve *nve = mlxsw_sp->nve;\n\tconst struct mlxsw_sp_nve_ops *ops;\n\tint err;\n\n\tif (nve->num_nve_tunnels++ != 0)\n\t\treturn 0;\n\n\tnve->config = *config;\n\n\terr = mlxsw_sp_kvdl_alloc(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ADJ, 1,\n\t\t\t\t  &nve->tunnel_index);\n\tif (err)\n\t\tgoto err_kvdl_alloc;\n\n\tops = nve->nve_ops_arr[config->type];\n\terr = ops->init(nve, config);\n\tif (err)\n\t\tgoto err_ops_init;\n\n\treturn 0;\n\nerr_ops_init:\n\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ADJ, 1,\n\t\t\t   nve->tunnel_index);\nerr_kvdl_alloc:\n\tmemset(&nve->config, 0, sizeof(nve->config));\n\tnve->num_nve_tunnels--;\n\treturn err;\n}\n\nstatic void mlxsw_sp_nve_tunnel_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_nve *nve = mlxsw_sp->nve;\n\tconst struct mlxsw_sp_nve_ops *ops;\n\n\tops = nve->nve_ops_arr[nve->config.type];\n\n\tif (mlxsw_sp->nve->num_nve_tunnels == 1) {\n\t\tops->fini(nve);\n\t\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ADJ, 1,\n\t\t\t\t   nve->tunnel_index);\n\t\tmemset(&nve->config, 0, sizeof(nve->config));\n\t}\n\tnve->num_nve_tunnels--;\n}\n\nstatic void mlxsw_sp_nve_fdb_flush_by_fid(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  u16 fid_index)\n{\n\tchar sfdf_pl[MLXSW_REG_SFDF_LEN];\n\n\tmlxsw_reg_sfdf_pack(sfdf_pl, MLXSW_REG_SFDF_FLUSH_PER_NVE_AND_FID);\n\tmlxsw_reg_sfdf_fid_set(sfdf_pl, fid_index);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfdf), sfdf_pl);\n}\n\nstatic void mlxsw_sp_nve_fdb_clear_offload(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   const struct mlxsw_sp_fid *fid,\n\t\t\t\t\t   const struct net_device *nve_dev,\n\t\t\t\t\t   __be32 vni)\n{\n\tconst struct mlxsw_sp_nve_ops *ops;\n\tenum mlxsw_sp_nve_type type;\n\n\tif (WARN_ON(mlxsw_sp_fid_nve_type(fid, &type)))\n\t\treturn;\n\n\tops = mlxsw_sp->nve->nve_ops_arr[type];\n\tops->fdb_clear_offload(nve_dev, vni);\n}\n\nstruct mlxsw_sp_nve_ipv6_ht_key {\n\tu8 mac[ETH_ALEN];\n\tu16 fid_index;\n};\n\nstruct mlxsw_sp_nve_ipv6_ht_node {\n\tstruct rhash_head ht_node;\n\tstruct list_head list;\n\tstruct mlxsw_sp_nve_ipv6_ht_key key;\n\tstruct in6_addr addr6;\n};\n\nstatic const struct rhashtable_params mlxsw_sp_nve_ipv6_ht_params = {\n\t.key_len = sizeof(struct mlxsw_sp_nve_ipv6_ht_key),\n\t.key_offset = offsetof(struct mlxsw_sp_nve_ipv6_ht_node, key),\n\t.head_offset = offsetof(struct mlxsw_sp_nve_ipv6_ht_node, ht_node),\n};\n\nint mlxsw_sp_nve_ipv6_addr_kvdl_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    const struct in6_addr *addr6,\n\t\t\t\t    u32 *p_kvdl_index)\n{\n\treturn mlxsw_sp_ipv6_addr_kvdl_index_get(mlxsw_sp, addr6, p_kvdl_index);\n}\n\nvoid mlxsw_sp_nve_ipv6_addr_kvdl_unset(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       const struct in6_addr *addr6)\n{\n\tmlxsw_sp_ipv6_addr_put(mlxsw_sp, addr6);\n}\n\nstatic struct mlxsw_sp_nve_ipv6_ht_node *\nmlxsw_sp_nve_ipv6_ht_node_lookup(struct mlxsw_sp *mlxsw_sp, const char *mac,\n\t\t\t\t u16 fid_index)\n{\n\tstruct mlxsw_sp_nve_ipv6_ht_key key = {};\n\n\tether_addr_copy(key.mac, mac);\n\tkey.fid_index = fid_index;\n\treturn rhashtable_lookup_fast(&mlxsw_sp->nve->ipv6_ht, &key,\n\t\t\t\t      mlxsw_sp_nve_ipv6_ht_params);\n}\n\nstatic int mlxsw_sp_nve_ipv6_ht_insert(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       const char *mac, u16 fid_index,\n\t\t\t\t       const struct in6_addr *addr6)\n{\n\tstruct mlxsw_sp_nve_ipv6_ht_node *ipv6_ht_node;\n\tstruct mlxsw_sp_nve *nve = mlxsw_sp->nve;\n\tint err;\n\n\tipv6_ht_node = kzalloc(sizeof(*ipv6_ht_node), GFP_KERNEL);\n\tif (!ipv6_ht_node)\n\t\treturn -ENOMEM;\n\n\tether_addr_copy(ipv6_ht_node->key.mac, mac);\n\tipv6_ht_node->key.fid_index = fid_index;\n\tipv6_ht_node->addr6 = *addr6;\n\n\terr = rhashtable_insert_fast(&nve->ipv6_ht, &ipv6_ht_node->ht_node,\n\t\t\t\t     mlxsw_sp_nve_ipv6_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_insert;\n\n\tlist_add(&ipv6_ht_node->list, &nve->ipv6_addr_list);\n\n\treturn 0;\n\nerr_rhashtable_insert:\n\tkfree(ipv6_ht_node);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_nve_ipv6_ht_remove(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_nve_ipv6_ht_node *ipv6_ht_node)\n{\n\tstruct mlxsw_sp_nve *nve = mlxsw_sp->nve;\n\n\tlist_del(&ipv6_ht_node->list);\n\trhashtable_remove_fast(&nve->ipv6_ht, &ipv6_ht_node->ht_node,\n\t\t\t       mlxsw_sp_nve_ipv6_ht_params);\n\tkfree(ipv6_ht_node);\n}\n\nint\nmlxsw_sp_nve_ipv6_addr_map_replace(struct mlxsw_sp *mlxsw_sp, const char *mac,\n\t\t\t\t   u16 fid_index,\n\t\t\t\t   const struct in6_addr *new_addr6)\n{\n\tstruct mlxsw_sp_nve_ipv6_ht_node *ipv6_ht_node;\n\n\tASSERT_RTNL();\n\n\tipv6_ht_node = mlxsw_sp_nve_ipv6_ht_node_lookup(mlxsw_sp, mac,\n\t\t\t\t\t\t\tfid_index);\n\tif (!ipv6_ht_node)\n\t\treturn mlxsw_sp_nve_ipv6_ht_insert(mlxsw_sp, mac, fid_index,\n\t\t\t\t\t\t   new_addr6);\n\n\tmlxsw_sp_ipv6_addr_put(mlxsw_sp, &ipv6_ht_node->addr6);\n\tipv6_ht_node->addr6 = *new_addr6;\n\treturn 0;\n}\n\nvoid mlxsw_sp_nve_ipv6_addr_map_del(struct mlxsw_sp *mlxsw_sp, const char *mac,\n\t\t\t\t    u16 fid_index)\n{\n\tstruct mlxsw_sp_nve_ipv6_ht_node *ipv6_ht_node;\n\n\tASSERT_RTNL();\n\n\tipv6_ht_node = mlxsw_sp_nve_ipv6_ht_node_lookup(mlxsw_sp, mac,\n\t\t\t\t\t\t\tfid_index);\n\tif (WARN_ON(!ipv6_ht_node))\n\t\treturn;\n\n\tmlxsw_sp_nve_ipv6_ht_remove(mlxsw_sp, ipv6_ht_node);\n}\n\nstatic void mlxsw_sp_nve_ipv6_addr_flush_by_fid(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tu16 fid_index)\n{\n\tstruct mlxsw_sp_nve_ipv6_ht_node *ipv6_ht_node, *tmp;\n\tstruct mlxsw_sp_nve *nve = mlxsw_sp->nve;\n\n\tlist_for_each_entry_safe(ipv6_ht_node, tmp, &nve->ipv6_addr_list,\n\t\t\t\t list) {\n\t\tif (ipv6_ht_node->key.fid_index != fid_index)\n\t\t\tcontinue;\n\n\t\tmlxsw_sp_ipv6_addr_put(mlxsw_sp, &ipv6_ht_node->addr6);\n\t\tmlxsw_sp_nve_ipv6_ht_remove(mlxsw_sp, ipv6_ht_node);\n\t}\n}\n\nint mlxsw_sp_nve_fid_enable(struct mlxsw_sp *mlxsw_sp, struct mlxsw_sp_fid *fid,\n\t\t\t    struct mlxsw_sp_nve_params *params,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_nve *nve = mlxsw_sp->nve;\n\tconst struct mlxsw_sp_nve_ops *ops;\n\tstruct mlxsw_sp_nve_config config;\n\tint err;\n\n\tops = nve->nve_ops_arr[params->type];\n\n\tif (!ops->can_offload(nve, params, extack))\n\t\treturn -EINVAL;\n\n\tmemset(&config, 0, sizeof(config));\n\tops->nve_config(nve, params, &config);\n\tif (nve->num_nve_tunnels &&\n\t    memcmp(&config, &nve->config, sizeof(config))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Conflicting NVE tunnels configuration\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = mlxsw_sp_nve_tunnel_init(mlxsw_sp, &config);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to initialize NVE tunnel\");\n\t\treturn err;\n\t}\n\n\terr = mlxsw_sp_fid_vni_set(fid, params->type, params->vni,\n\t\t\t\t   params->dev->ifindex);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to set VNI on FID\");\n\t\tgoto err_fid_vni_set;\n\t}\n\n\terr = ops->fdb_replay(params->dev, params->vni, extack);\n\tif (err)\n\t\tgoto err_fdb_replay;\n\n\treturn 0;\n\nerr_fdb_replay:\n\tmlxsw_sp_fid_vni_clear(fid);\nerr_fid_vni_set:\n\tmlxsw_sp_nve_tunnel_fini(mlxsw_sp);\n\treturn err;\n}\n\nvoid mlxsw_sp_nve_fid_disable(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_fid *fid)\n{\n\tu16 fid_index = mlxsw_sp_fid_index(fid);\n\tstruct net_device *nve_dev;\n\tint nve_ifindex;\n\t__be32 vni;\n\n\t \n\tASSERT_RTNL();\n\n\tmlxsw_sp_nve_flood_ip_flush(mlxsw_sp, fid);\n\tmlxsw_sp_nve_fdb_flush_by_fid(mlxsw_sp, fid_index);\n\tmlxsw_sp_nve_ipv6_addr_flush_by_fid(mlxsw_sp, fid_index);\n\n\tif (WARN_ON(mlxsw_sp_fid_nve_ifindex(fid, &nve_ifindex) ||\n\t\t    mlxsw_sp_fid_vni(fid, &vni)))\n\t\tgoto out;\n\n\tnve_dev = __dev_get_by_index(mlxsw_sp_net(mlxsw_sp), nve_ifindex);\n\tif (!nve_dev)\n\t\tgoto out;\n\n\tmlxsw_sp_nve_fdb_clear_offload(mlxsw_sp, fid, nve_dev, vni);\n\tmlxsw_sp_fid_fdb_clear_offload(fid, nve_dev);\n\nout:\n\tmlxsw_sp_fid_vni_clear(fid);\n\tmlxsw_sp_nve_tunnel_fini(mlxsw_sp);\n}\n\nint mlxsw_sp_port_nve_init(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar tnqdr_pl[MLXSW_REG_TNQDR_LEN];\n\n\tmlxsw_reg_tnqdr_pack(tnqdr_pl, mlxsw_sp_port->local_port);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(tnqdr), tnqdr_pl);\n}\n\nvoid mlxsw_sp_port_nve_fini(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n}\n\nstatic int mlxsw_sp_nve_qos_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tchar tnqcr_pl[MLXSW_REG_TNQCR_LEN];\n\n\tmlxsw_reg_tnqcr_pack(tnqcr_pl);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(tnqcr), tnqcr_pl);\n}\n\nstatic int mlxsw_sp_nve_ecn_encap_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tint i;\n\n\t \n\tfor (i = INET_ECN_NOT_ECT; i <= INET_ECN_CE; i++) {\n\t\tu8 outer_ecn = INET_ECN_encapsulate(0, i);\n\t\tchar tneem_pl[MLXSW_REG_TNEEM_LEN];\n\t\tint err;\n\n\t\tmlxsw_reg_tneem_pack(tneem_pl, i, outer_ecn);\n\t\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(tneem),\n\t\t\t\t      tneem_pl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __mlxsw_sp_nve_ecn_decap_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t u8 inner_ecn, u8 outer_ecn)\n{\n\tchar tndem_pl[MLXSW_REG_TNDEM_LEN];\n\tu8 new_inner_ecn;\n\tbool trap_en;\n\n\tnew_inner_ecn = mlxsw_sp_tunnel_ecn_decap(outer_ecn, inner_ecn,\n\t\t\t\t\t\t  &trap_en);\n\tmlxsw_reg_tndem_pack(tndem_pl, outer_ecn, inner_ecn, new_inner_ecn,\n\t\t\t     trap_en, trap_en ? MLXSW_TRAP_ID_DECAP_ECN0 : 0);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(tndem), tndem_pl);\n}\n\nstatic int mlxsw_sp_nve_ecn_decap_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tint i;\n\n\t \n\tfor (i = INET_ECN_NOT_ECT; i <= INET_ECN_CE; i++) {\n\t\tint j;\n\n\t\t \n\t\tfor (j = INET_ECN_NOT_ECT; j <= INET_ECN_CE; j++) {\n\t\t\tint err;\n\n\t\t\terr = __mlxsw_sp_nve_ecn_decap_init(mlxsw_sp, i, j);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_nve_ecn_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tint err;\n\n\terr = mlxsw_sp_nve_ecn_encap_init(mlxsw_sp);\n\tif (err)\n\t\treturn err;\n\n\treturn mlxsw_sp_nve_ecn_decap_init(mlxsw_sp);\n}\n\nstatic int mlxsw_sp_nve_resources_query(struct mlxsw_sp *mlxsw_sp)\n{\n\tunsigned int max;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, MAX_NVE_MC_ENTRIES_IPV4) ||\n\t    !MLXSW_CORE_RES_VALID(mlxsw_sp->core, MAX_NVE_MC_ENTRIES_IPV6))\n\t\treturn -EIO;\n\tmax = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_NVE_MC_ENTRIES_IPV4);\n\tmlxsw_sp->nve->num_max_mc_entries[MLXSW_SP_L3_PROTO_IPV4] = max;\n\tmax = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_NVE_MC_ENTRIES_IPV6);\n\tmlxsw_sp->nve->num_max_mc_entries[MLXSW_SP_L3_PROTO_IPV6] = max;\n\n\treturn 0;\n}\n\nint mlxsw_sp_nve_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_nve *nve;\n\tint err;\n\n\tnve = kzalloc(sizeof(*mlxsw_sp->nve), GFP_KERNEL);\n\tif (!nve)\n\t\treturn -ENOMEM;\n\tmlxsw_sp->nve = nve;\n\tnve->mlxsw_sp = mlxsw_sp;\n\tnve->nve_ops_arr = mlxsw_sp->nve_ops_arr;\n\n\terr = rhashtable_init(&nve->mc_list_ht,\n\t\t\t      &mlxsw_sp_nve_mc_list_ht_params);\n\tif (err)\n\t\tgoto err_mc_rhashtable_init;\n\n\terr = rhashtable_init(&nve->ipv6_ht, &mlxsw_sp_nve_ipv6_ht_params);\n\tif (err)\n\t\tgoto err_ipv6_rhashtable_init;\n\n\tINIT_LIST_HEAD(&nve->ipv6_addr_list);\n\n\terr = mlxsw_sp_nve_qos_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_nve_qos_init;\n\n\terr = mlxsw_sp_nve_ecn_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_nve_ecn_init;\n\n\terr = mlxsw_sp_nve_resources_query(mlxsw_sp);\n\tif (err)\n\t\tgoto err_nve_resources_query;\n\n\treturn 0;\n\nerr_nve_resources_query:\nerr_nve_ecn_init:\nerr_nve_qos_init:\n\trhashtable_destroy(&nve->ipv6_ht);\nerr_ipv6_rhashtable_init:\n\trhashtable_destroy(&nve->mc_list_ht);\nerr_mc_rhashtable_init:\n\tmlxsw_sp->nve = NULL;\n\tkfree(nve);\n\treturn err;\n}\n\nvoid mlxsw_sp_nve_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tWARN_ON(mlxsw_sp->nve->num_nve_tunnels);\n\tWARN_ON(!list_empty(&mlxsw_sp->nve->ipv6_addr_list));\n\trhashtable_destroy(&mlxsw_sp->nve->ipv6_ht);\n\trhashtable_destroy(&mlxsw_sp->nve->mc_list_ht);\n\tkfree(mlxsw_sp->nve);\n\tmlxsw_sp->nve = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}