{
  "module_name": "spectrum_ipip.c",
  "hash_id": "65af16159e1e23f6f5a822b906ef56f5f75213783d17e34d1ae08296d9f7d782",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_ipip.c",
  "human_readable_source": "\n \n\n#include <net/ip_tunnels.h>\n#include <net/ip6_tunnel.h>\n#include <net/inet_ecn.h>\n\n#include \"spectrum_ipip.h\"\n#include \"reg.h\"\n\nstruct ip_tunnel_parm\nmlxsw_sp_ipip_netdev_parms4(const struct net_device *ol_dev)\n{\n\tstruct ip_tunnel *tun = netdev_priv(ol_dev);\n\n\treturn tun->parms;\n}\n\nstruct __ip6_tnl_parm\nmlxsw_sp_ipip_netdev_parms6(const struct net_device *ol_dev)\n{\n\tstruct ip6_tnl *tun = netdev_priv(ol_dev);\n\n\treturn tun->parms;\n}\n\nstatic bool mlxsw_sp_ipip_parms4_has_ikey(const struct ip_tunnel_parm *parms)\n{\n\treturn !!(parms->i_flags & TUNNEL_KEY);\n}\n\nstatic bool mlxsw_sp_ipip_parms6_has_ikey(const struct __ip6_tnl_parm *parms)\n{\n\treturn !!(parms->i_flags & TUNNEL_KEY);\n}\n\nstatic bool mlxsw_sp_ipip_parms4_has_okey(const struct ip_tunnel_parm *parms)\n{\n\treturn !!(parms->o_flags & TUNNEL_KEY);\n}\n\nstatic bool mlxsw_sp_ipip_parms6_has_okey(const struct __ip6_tnl_parm *parms)\n{\n\treturn !!(parms->o_flags & TUNNEL_KEY);\n}\n\nstatic u32 mlxsw_sp_ipip_parms4_ikey(const struct ip_tunnel_parm *parms)\n{\n\treturn mlxsw_sp_ipip_parms4_has_ikey(parms) ?\n\t\tbe32_to_cpu(parms->i_key) : 0;\n}\n\nstatic u32 mlxsw_sp_ipip_parms6_ikey(const struct __ip6_tnl_parm *parms)\n{\n\treturn mlxsw_sp_ipip_parms6_has_ikey(parms) ?\n\t\tbe32_to_cpu(parms->i_key) : 0;\n}\n\nstatic u32 mlxsw_sp_ipip_parms4_okey(const struct ip_tunnel_parm *parms)\n{\n\treturn mlxsw_sp_ipip_parms4_has_okey(parms) ?\n\t\tbe32_to_cpu(parms->o_key) : 0;\n}\n\nstatic u32 mlxsw_sp_ipip_parms6_okey(const struct __ip6_tnl_parm *parms)\n{\n\treturn mlxsw_sp_ipip_parms6_has_okey(parms) ?\n\t\tbe32_to_cpu(parms->o_key) : 0;\n}\n\nstatic union mlxsw_sp_l3addr\nmlxsw_sp_ipip_parms4_saddr(const struct ip_tunnel_parm *parms)\n{\n\treturn (union mlxsw_sp_l3addr) { .addr4 = parms->iph.saddr };\n}\n\nstatic union mlxsw_sp_l3addr\nmlxsw_sp_ipip_parms6_saddr(const struct __ip6_tnl_parm *parms)\n{\n\treturn (union mlxsw_sp_l3addr) { .addr6 = parms->laddr };\n}\n\nstatic union mlxsw_sp_l3addr\nmlxsw_sp_ipip_parms4_daddr(const struct ip_tunnel_parm *parms)\n{\n\treturn (union mlxsw_sp_l3addr) { .addr4 = parms->iph.daddr };\n}\n\nstatic union mlxsw_sp_l3addr\nmlxsw_sp_ipip_parms6_daddr(const struct __ip6_tnl_parm *parms)\n{\n\treturn (union mlxsw_sp_l3addr) { .addr6 = parms->raddr };\n}\n\nunion mlxsw_sp_l3addr\nmlxsw_sp_ipip_netdev_saddr(enum mlxsw_sp_l3proto proto,\n\t\t\t   const struct net_device *ol_dev)\n{\n\tstruct ip_tunnel_parm parms4;\n\tstruct __ip6_tnl_parm parms6;\n\n\tswitch (proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\tparms4 = mlxsw_sp_ipip_netdev_parms4(ol_dev);\n\t\treturn mlxsw_sp_ipip_parms4_saddr(&parms4);\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\tparms6 = mlxsw_sp_ipip_netdev_parms6(ol_dev);\n\t\treturn mlxsw_sp_ipip_parms6_saddr(&parms6);\n\t}\n\n\tWARN_ON(1);\n\treturn (union mlxsw_sp_l3addr) {0};\n}\n\nstatic __be32 mlxsw_sp_ipip_netdev_daddr4(const struct net_device *ol_dev)\n{\n\n\tstruct ip_tunnel_parm parms4 = mlxsw_sp_ipip_netdev_parms4(ol_dev);\n\n\treturn mlxsw_sp_ipip_parms4_daddr(&parms4).addr4;\n}\n\nstatic union mlxsw_sp_l3addr\nmlxsw_sp_ipip_netdev_daddr(enum mlxsw_sp_l3proto proto,\n\t\t\t   const struct net_device *ol_dev)\n{\n\tstruct ip_tunnel_parm parms4;\n\tstruct __ip6_tnl_parm parms6;\n\n\tswitch (proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\tparms4 = mlxsw_sp_ipip_netdev_parms4(ol_dev);\n\t\treturn mlxsw_sp_ipip_parms4_daddr(&parms4);\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\tparms6 = mlxsw_sp_ipip_netdev_parms6(ol_dev);\n\t\treturn mlxsw_sp_ipip_parms6_daddr(&parms6);\n\t}\n\n\tWARN_ON(1);\n\treturn (union mlxsw_sp_l3addr) {0};\n}\n\nbool mlxsw_sp_l3addr_is_zero(union mlxsw_sp_l3addr addr)\n{\n\tunion mlxsw_sp_l3addr naddr = {0};\n\n\treturn !memcmp(&addr, &naddr, sizeof(naddr));\n}\n\nstatic struct mlxsw_sp_ipip_parms\nmlxsw_sp_ipip_netdev_parms_init_gre4(const struct net_device *ol_dev)\n{\n\tstruct ip_tunnel_parm parms = mlxsw_sp_ipip_netdev_parms4(ol_dev);\n\n\treturn (struct mlxsw_sp_ipip_parms) {\n\t\t.proto = MLXSW_SP_L3_PROTO_IPV4,\n\t\t.saddr = mlxsw_sp_ipip_parms4_saddr(&parms),\n\t\t.daddr = mlxsw_sp_ipip_parms4_daddr(&parms),\n\t\t.link = parms.link,\n\t\t.ikey = mlxsw_sp_ipip_parms4_ikey(&parms),\n\t\t.okey = mlxsw_sp_ipip_parms4_okey(&parms),\n\t};\n}\n\nstatic int\nmlxsw_sp_ipip_nexthop_update_gre4(struct mlxsw_sp *mlxsw_sp, u32 adj_index,\n\t\t\t\t  struct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\t  bool force, char *ratr_pl)\n{\n\tu16 rif_index = mlxsw_sp_ipip_lb_rif_index(ipip_entry->ol_lb);\n\t__be32 daddr4 = mlxsw_sp_ipip_netdev_daddr4(ipip_entry->ol_dev);\n\tenum mlxsw_reg_ratr_op op;\n\n\top = force ? MLXSW_REG_RATR_OP_WRITE_WRITE_ENTRY :\n\t\t     MLXSW_REG_RATR_OP_WRITE_WRITE_ENTRY_ON_ACTIVITY;\n\tmlxsw_reg_ratr_pack(ratr_pl, op, true, MLXSW_REG_RATR_TYPE_IPIP,\n\t\t\t    adj_index, rif_index);\n\tmlxsw_reg_ratr_ipip4_entry_pack(ratr_pl, be32_to_cpu(daddr4));\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ratr), ratr_pl);\n}\n\nstatic int\nmlxsw_sp_ipip_decap_config_gre4(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\tu32 tunnel_index)\n{\n\tu16 rif_index = mlxsw_sp_ipip_lb_rif_index(ipip_entry->ol_lb);\n\tu16 ul_rif_id = mlxsw_sp_ipip_lb_ul_rif_id(ipip_entry->ol_lb);\n\tchar rtdp_pl[MLXSW_REG_RTDP_LEN];\n\tstruct ip_tunnel_parm parms;\n\tunsigned int type_check;\n\tbool has_ikey;\n\tu32 daddr4;\n\tu32 ikey;\n\n\tparms = mlxsw_sp_ipip_netdev_parms4(ipip_entry->ol_dev);\n\thas_ikey = mlxsw_sp_ipip_parms4_has_ikey(&parms);\n\tikey = mlxsw_sp_ipip_parms4_ikey(&parms);\n\n\tmlxsw_reg_rtdp_pack(rtdp_pl, MLXSW_REG_RTDP_TYPE_IPIP, tunnel_index);\n\tmlxsw_reg_rtdp_egress_router_interface_set(rtdp_pl, ul_rif_id);\n\n\ttype_check = has_ikey ?\n\t\tMLXSW_REG_RTDP_IPIP_TYPE_CHECK_ALLOW_GRE_KEY :\n\t\tMLXSW_REG_RTDP_IPIP_TYPE_CHECK_ALLOW_GRE;\n\n\t \n\tdaddr4 = be32_to_cpu(mlxsw_sp_ipip_netdev_daddr4(ipip_entry->ol_dev));\n\tmlxsw_reg_rtdp_ipip4_pack(rtdp_pl, rif_index,\n\t\t\t\t  MLXSW_REG_RTDP_IPIP_SIP_CHECK_FILTER_IPV4,\n\t\t\t\t  type_check, has_ikey, daddr4, ikey);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rtdp), rtdp_pl);\n}\n\nstatic bool mlxsw_sp_ipip_tunnel_complete(enum mlxsw_sp_l3proto proto,\n\t\t\t\t\t  const struct net_device *ol_dev)\n{\n\tunion mlxsw_sp_l3addr saddr = mlxsw_sp_ipip_netdev_saddr(proto, ol_dev);\n\tunion mlxsw_sp_l3addr daddr = mlxsw_sp_ipip_netdev_daddr(proto, ol_dev);\n\n\t \n\treturn !mlxsw_sp_l3addr_is_zero(saddr) &&\n\t       !mlxsw_sp_l3addr_is_zero(daddr);\n}\n\nstatic bool mlxsw_sp_ipip_can_offload_gre4(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   const struct net_device *ol_dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(ol_dev);\n\t__be16 okflags = TUNNEL_KEY;  \n\tbool inherit_ttl = tunnel->parms.iph.ttl == 0;\n\tbool inherit_tos = tunnel->parms.iph.tos & 0x1;\n\n\treturn (tunnel->parms.i_flags & ~okflags) == 0 &&\n\t       (tunnel->parms.o_flags & ~okflags) == 0 &&\n\t       inherit_ttl && inherit_tos &&\n\t       mlxsw_sp_ipip_tunnel_complete(MLXSW_SP_L3_PROTO_IPV4, ol_dev);\n}\n\nstatic struct mlxsw_sp_rif_ipip_lb_config\nmlxsw_sp_ipip_ol_loopback_config_gre4(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      const struct net_device *ol_dev)\n{\n\tstruct ip_tunnel_parm parms = mlxsw_sp_ipip_netdev_parms4(ol_dev);\n\tenum mlxsw_reg_ritr_loopback_ipip_type lb_ipipt;\n\n\tlb_ipipt = mlxsw_sp_ipip_parms4_has_okey(&parms) ?\n\t\tMLXSW_REG_RITR_LOOPBACK_IPIP_TYPE_IP_IN_GRE_KEY_IN_IP :\n\t\tMLXSW_REG_RITR_LOOPBACK_IPIP_TYPE_IP_IN_GRE_IN_IP;\n\treturn (struct mlxsw_sp_rif_ipip_lb_config){\n\t\t.lb_ipipt = lb_ipipt,\n\t\t.okey = mlxsw_sp_ipip_parms4_okey(&parms),\n\t\t.ul_protocol = MLXSW_SP_L3_PROTO_IPV4,\n\t\t.saddr = mlxsw_sp_ipip_netdev_saddr(MLXSW_SP_L3_PROTO_IPV4,\n\t\t\t\t\t\t    ol_dev),\n\t};\n}\n\nstatic int\nmlxsw_sp_ipip_ol_netdev_change_gre(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\t   const struct mlxsw_sp_ipip_parms *new_parms,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tconst struct mlxsw_sp_ipip_parms *old_parms = &ipip_entry->parms;\n\tbool update_tunnel = false;\n\tbool update_decap = false;\n\tbool update_nhs = false;\n\tint err = 0;\n\n\tif (!mlxsw_sp_l3addr_eq(&new_parms->saddr, &old_parms->saddr)) {\n\t\tu16 ul_tb_id = mlxsw_sp_ipip_dev_ul_tb_id(ipip_entry->ol_dev);\n\n\t\t \n\t\tif (mlxsw_sp_ipip_demote_tunnel_by_saddr(mlxsw_sp,\n\t\t\t\t\t\t\t new_parms->proto,\n\t\t\t\t\t\t\t new_parms->saddr,\n\t\t\t\t\t\t\t ul_tb_id,\n\t\t\t\t\t\t\t ipip_entry)) {\n\t\t\tmlxsw_sp_ipip_entry_demote_tunnel(mlxsw_sp, ipip_entry);\n\t\t\treturn 0;\n\t\t}\n\n\t\tupdate_tunnel = true;\n\t} else if (old_parms->okey != new_parms->okey ||\n\t\t   old_parms->link != new_parms->link) {\n\t\tupdate_tunnel = true;\n\t} else if (!mlxsw_sp_l3addr_eq(&new_parms->daddr, &old_parms->daddr)) {\n\t\tupdate_nhs = true;\n\t} else if (old_parms->ikey != new_parms->ikey) {\n\t\tupdate_decap = true;\n\t}\n\n\tif (update_tunnel)\n\t\terr = __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,\n\t\t\t\t\t\t\t  true, true, true,\n\t\t\t\t\t\t\t  extack);\n\telse if (update_nhs)\n\t\terr = __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,\n\t\t\t\t\t\t\t  false, false, true,\n\t\t\t\t\t\t\t  extack);\n\telse if (update_decap)\n\t\terr = __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,\n\t\t\t\t\t\t\t  false, false, false,\n\t\t\t\t\t\t\t  extack);\n\tif (err)\n\t\treturn err;\n\n\tipip_entry->parms = *new_parms;\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_ipip_ol_netdev_change_gre4(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_ipip_parms new_parms;\n\n\tnew_parms = mlxsw_sp_ipip_netdev_parms_init_gre4(ipip_entry->ol_dev);\n\treturn mlxsw_sp_ipip_ol_netdev_change_gre(mlxsw_sp, ipip_entry,\n\t\t\t\t\t\t  &new_parms, extack);\n}\n\nstatic int\nmlxsw_sp_ipip_rem_addr_set_gre4(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_ipip_entry *ipip_entry)\n{\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_ipip_rem_addr_unset_gre4(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  const struct mlxsw_sp_ipip_entry *ipip_entry)\n{\n}\n\nstatic const struct mlxsw_sp_ipip_ops mlxsw_sp_ipip_gre4_ops = {\n\t.dev_type = ARPHRD_IPGRE,\n\t.ul_proto = MLXSW_SP_L3_PROTO_IPV4,\n\t.inc_parsing_depth = false,\n\t.parms_init = mlxsw_sp_ipip_netdev_parms_init_gre4,\n\t.nexthop_update = mlxsw_sp_ipip_nexthop_update_gre4,\n\t.decap_config = mlxsw_sp_ipip_decap_config_gre4,\n\t.can_offload = mlxsw_sp_ipip_can_offload_gre4,\n\t.ol_loopback_config = mlxsw_sp_ipip_ol_loopback_config_gre4,\n\t.ol_netdev_change = mlxsw_sp_ipip_ol_netdev_change_gre4,\n\t.rem_ip_addr_set = mlxsw_sp_ipip_rem_addr_set_gre4,\n\t.rem_ip_addr_unset = mlxsw_sp_ipip_rem_addr_unset_gre4,\n};\n\nstatic struct mlxsw_sp_ipip_parms\nmlxsw_sp_ipip_netdev_parms_init_gre6(const struct net_device *ol_dev)\n{\n\tstruct __ip6_tnl_parm parms = mlxsw_sp_ipip_netdev_parms6(ol_dev);\n\n\treturn (struct mlxsw_sp_ipip_parms) {\n\t\t.proto = MLXSW_SP_L3_PROTO_IPV6,\n\t\t.saddr = mlxsw_sp_ipip_parms6_saddr(&parms),\n\t\t.daddr = mlxsw_sp_ipip_parms6_daddr(&parms),\n\t\t.link = parms.link,\n\t\t.ikey = mlxsw_sp_ipip_parms6_ikey(&parms),\n\t\t.okey = mlxsw_sp_ipip_parms6_okey(&parms),\n\t};\n}\n\nstatic int\nmlxsw_sp_ipip_nexthop_update_gre6(struct mlxsw_sp *mlxsw_sp, u32 adj_index,\n\t\t\t\t  struct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\t  bool force, char *ratr_pl)\n{\n\tu16 rif_index = mlxsw_sp_ipip_lb_rif_index(ipip_entry->ol_lb);\n\tenum mlxsw_reg_ratr_op op;\n\n\top = force ? MLXSW_REG_RATR_OP_WRITE_WRITE_ENTRY :\n\t\t     MLXSW_REG_RATR_OP_WRITE_WRITE_ENTRY_ON_ACTIVITY;\n\tmlxsw_reg_ratr_pack(ratr_pl, op, true, MLXSW_REG_RATR_TYPE_IPIP,\n\t\t\t    adj_index, rif_index);\n\tmlxsw_reg_ratr_ipip6_entry_pack(ratr_pl,\n\t\t\t\t\tipip_entry->dip_kvdl_index);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ratr), ratr_pl);\n}\n\nstatic int\nmlxsw_sp_ipip_decap_config_gre6(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\tu32 tunnel_index)\n{\n\tu16 rif_index = mlxsw_sp_ipip_lb_rif_index(ipip_entry->ol_lb);\n\tu16 ul_rif_id = mlxsw_sp_ipip_lb_ul_rif_id(ipip_entry->ol_lb);\n\tchar rtdp_pl[MLXSW_REG_RTDP_LEN];\n\tstruct __ip6_tnl_parm parms;\n\tunsigned int type_check;\n\tbool has_ikey;\n\tu32 ikey;\n\n\tparms = mlxsw_sp_ipip_netdev_parms6(ipip_entry->ol_dev);\n\thas_ikey = mlxsw_sp_ipip_parms6_has_ikey(&parms);\n\tikey = mlxsw_sp_ipip_parms6_ikey(&parms);\n\n\tmlxsw_reg_rtdp_pack(rtdp_pl, MLXSW_REG_RTDP_TYPE_IPIP, tunnel_index);\n\tmlxsw_reg_rtdp_egress_router_interface_set(rtdp_pl, ul_rif_id);\n\n\ttype_check = has_ikey ?\n\t\tMLXSW_REG_RTDP_IPIP_TYPE_CHECK_ALLOW_GRE_KEY :\n\t\tMLXSW_REG_RTDP_IPIP_TYPE_CHECK_ALLOW_GRE;\n\n\t \n\tmlxsw_reg_rtdp_ipip6_pack(rtdp_pl, rif_index,\n\t\t\t\t  MLXSW_REG_RTDP_IPIP_SIP_CHECK_FILTER_IPV6,\n\t\t\t\t  type_check, has_ikey,\n\t\t\t\t  ipip_entry->dip_kvdl_index, ikey);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rtdp), rtdp_pl);\n}\n\nstatic bool mlxsw_sp_ipip_can_offload_gre6(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   const struct net_device *ol_dev)\n{\n\tstruct __ip6_tnl_parm tparm = mlxsw_sp_ipip_netdev_parms6(ol_dev);\n\tbool inherit_tos = tparm.flags & IP6_TNL_F_USE_ORIG_TCLASS;\n\tbool inherit_ttl = tparm.hop_limit == 0;\n\t__be16 okflags = TUNNEL_KEY;  \n\n\treturn (tparm.i_flags & ~okflags) == 0 &&\n\t       (tparm.o_flags & ~okflags) == 0 &&\n\t       inherit_ttl && inherit_tos &&\n\t       mlxsw_sp_ipip_tunnel_complete(MLXSW_SP_L3_PROTO_IPV6, ol_dev);\n}\n\nstatic struct mlxsw_sp_rif_ipip_lb_config\nmlxsw_sp_ipip_ol_loopback_config_gre6(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      const struct net_device *ol_dev)\n{\n\tstruct __ip6_tnl_parm parms = mlxsw_sp_ipip_netdev_parms6(ol_dev);\n\tenum mlxsw_reg_ritr_loopback_ipip_type lb_ipipt;\n\n\tlb_ipipt = mlxsw_sp_ipip_parms6_has_okey(&parms) ?\n\t\tMLXSW_REG_RITR_LOOPBACK_IPIP_TYPE_IP_IN_GRE_KEY_IN_IP :\n\t\tMLXSW_REG_RITR_LOOPBACK_IPIP_TYPE_IP_IN_GRE_IN_IP;\n\treturn (struct mlxsw_sp_rif_ipip_lb_config){\n\t\t.lb_ipipt = lb_ipipt,\n\t\t.okey = mlxsw_sp_ipip_parms6_okey(&parms),\n\t\t.ul_protocol = MLXSW_SP_L3_PROTO_IPV6,\n\t\t.saddr = mlxsw_sp_ipip_netdev_saddr(MLXSW_SP_L3_PROTO_IPV6,\n\t\t\t\t\t\t    ol_dev),\n\t};\n}\n\nstatic int\nmlxsw_sp_ipip_ol_netdev_change_gre6(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_ipip_parms new_parms;\n\n\tnew_parms = mlxsw_sp_ipip_netdev_parms_init_gre6(ipip_entry->ol_dev);\n\treturn mlxsw_sp_ipip_ol_netdev_change_gre(mlxsw_sp, ipip_entry,\n\t\t\t\t\t\t  &new_parms, extack);\n}\n\nstatic int\nmlxsw_sp_ipip_rem_addr_set_gre6(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_ipip_entry *ipip_entry)\n{\n\treturn mlxsw_sp_ipv6_addr_kvdl_index_get(mlxsw_sp,\n\t\t\t\t\t\t &ipip_entry->parms.daddr.addr6,\n\t\t\t\t\t\t &ipip_entry->dip_kvdl_index);\n}\n\nstatic void\nmlxsw_sp_ipip_rem_addr_unset_gre6(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  const struct mlxsw_sp_ipip_entry *ipip_entry)\n{\n\tmlxsw_sp_ipv6_addr_put(mlxsw_sp, &ipip_entry->parms.daddr.addr6);\n}\n\nstatic const struct mlxsw_sp_ipip_ops mlxsw_sp1_ipip_gre6_ops = {\n\t.dev_type = ARPHRD_IP6GRE,\n\t.ul_proto = MLXSW_SP_L3_PROTO_IPV6,\n\t.inc_parsing_depth = true,\n\t.double_rif_entry = true,\n\t.parms_init = mlxsw_sp_ipip_netdev_parms_init_gre6,\n\t.nexthop_update = mlxsw_sp_ipip_nexthop_update_gre6,\n\t.decap_config = mlxsw_sp_ipip_decap_config_gre6,\n\t.can_offload = mlxsw_sp_ipip_can_offload_gre6,\n\t.ol_loopback_config = mlxsw_sp_ipip_ol_loopback_config_gre6,\n\t.ol_netdev_change = mlxsw_sp_ipip_ol_netdev_change_gre6,\n\t.rem_ip_addr_set = mlxsw_sp_ipip_rem_addr_set_gre6,\n\t.rem_ip_addr_unset = mlxsw_sp_ipip_rem_addr_unset_gre6,\n};\n\nconst struct mlxsw_sp_ipip_ops *mlxsw_sp1_ipip_ops_arr[] = {\n\t[MLXSW_SP_IPIP_TYPE_GRE4] = &mlxsw_sp_ipip_gre4_ops,\n\t[MLXSW_SP_IPIP_TYPE_GRE6] = &mlxsw_sp1_ipip_gre6_ops,\n};\n\nstatic const struct mlxsw_sp_ipip_ops mlxsw_sp2_ipip_gre6_ops = {\n\t.dev_type = ARPHRD_IP6GRE,\n\t.ul_proto = MLXSW_SP_L3_PROTO_IPV6,\n\t.inc_parsing_depth = true,\n\t.parms_init = mlxsw_sp_ipip_netdev_parms_init_gre6,\n\t.nexthop_update = mlxsw_sp_ipip_nexthop_update_gre6,\n\t.decap_config = mlxsw_sp_ipip_decap_config_gre6,\n\t.can_offload = mlxsw_sp_ipip_can_offload_gre6,\n\t.ol_loopback_config = mlxsw_sp_ipip_ol_loopback_config_gre6,\n\t.ol_netdev_change = mlxsw_sp_ipip_ol_netdev_change_gre6,\n\t.rem_ip_addr_set = mlxsw_sp_ipip_rem_addr_set_gre6,\n\t.rem_ip_addr_unset = mlxsw_sp_ipip_rem_addr_unset_gre6,\n};\n\nconst struct mlxsw_sp_ipip_ops *mlxsw_sp2_ipip_ops_arr[] = {\n\t[MLXSW_SP_IPIP_TYPE_GRE4] = &mlxsw_sp_ipip_gre4_ops,\n\t[MLXSW_SP_IPIP_TYPE_GRE6] = &mlxsw_sp2_ipip_gre6_ops,\n};\n\nstatic int mlxsw_sp_ipip_ecn_encap_init_one(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    u8 inner_ecn, u8 outer_ecn)\n{\n\tchar tieem_pl[MLXSW_REG_TIEEM_LEN];\n\n\tmlxsw_reg_tieem_pack(tieem_pl, inner_ecn, outer_ecn);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(tieem), tieem_pl);\n}\n\nint mlxsw_sp_ipip_ecn_encap_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tint i;\n\n\t \n\tfor (i = INET_ECN_NOT_ECT; i <= INET_ECN_CE; i++) {\n\t\tu8 outer_ecn = INET_ECN_encapsulate(0, i);\n\t\tint err;\n\n\t\terr = mlxsw_sp_ipip_ecn_encap_init_one(mlxsw_sp, i, outer_ecn);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_ipip_ecn_decap_init_one(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    u8 inner_ecn, u8 outer_ecn)\n{\n\tchar tidem_pl[MLXSW_REG_TIDEM_LEN];\n\tu8 new_inner_ecn;\n\tbool trap_en;\n\n\tnew_inner_ecn = mlxsw_sp_tunnel_ecn_decap(outer_ecn, inner_ecn,\n\t\t\t\t\t\t  &trap_en);\n\tmlxsw_reg_tidem_pack(tidem_pl, outer_ecn, inner_ecn, new_inner_ecn,\n\t\t\t     trap_en, trap_en ? MLXSW_TRAP_ID_DECAP_ECN0 : 0);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(tidem), tidem_pl);\n}\n\nint mlxsw_sp_ipip_ecn_decap_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tint i, j, err;\n\n\t \n\tfor (i = INET_ECN_NOT_ECT; i <= INET_ECN_CE; i++) {\n\t\t \n\t\tfor (j = INET_ECN_NOT_ECT; j <= INET_ECN_CE; j++) {\n\t\t\terr = mlxsw_sp_ipip_ecn_decap_init_one(mlxsw_sp, i, j);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct net_device *\nmlxsw_sp_ipip_netdev_ul_dev_get(const struct net_device *ol_dev)\n{\n\tstruct net *net = dev_net(ol_dev);\n\tstruct ip_tunnel *tun4;\n\tstruct ip6_tnl *tun6;\n\n\tswitch (ol_dev->type) {\n\tcase ARPHRD_IPGRE:\n\t\ttun4 = netdev_priv(ol_dev);\n\t\treturn dev_get_by_index_rcu(net, tun4->parms.link);\n\tcase ARPHRD_IP6GRE:\n\t\ttun6 = netdev_priv(ol_dev);\n\t\treturn dev_get_by_index_rcu(net, tun6->parms.link);\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}