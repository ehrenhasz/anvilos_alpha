{
  "module_name": "spectrum_nve_vxlan.c",
  "hash_id": "512118207ccd4583c8f48290ed7de3eea4f731cd7b552c3a050cf9270af0b5b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_nve_vxlan.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/random.h>\n#include <net/vxlan.h>\n\n#include \"reg.h\"\n#include \"spectrum.h\"\n#include \"spectrum_nve.h\"\n\n#define MLXSW_SP_NVE_VXLAN_IPV4_SUPPORTED_FLAGS (VXLAN_F_UDP_ZERO_CSUM_TX | \\\n\t\t\t\t\t\t VXLAN_F_LEARN | \\\n\t\t\t\t\t\t VXLAN_F_LOCALBYPASS)\n#define MLXSW_SP_NVE_VXLAN_IPV6_SUPPORTED_FLAGS (VXLAN_F_IPV6 | \\\n\t\t\t\t\t\t VXLAN_F_UDP_ZERO_CSUM6_TX | \\\n\t\t\t\t\t\t VXLAN_F_UDP_ZERO_CSUM6_RX | \\\n\t\t\t\t\t\t VXLAN_F_LOCALBYPASS)\n\nstatic bool mlxsw_sp_nve_vxlan_ipv4_flags_check(const struct vxlan_config *cfg,\n\t\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (!(cfg->flags & VXLAN_F_UDP_ZERO_CSUM_TX)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: Zero UDP checksum must be allowed for TX\");\n\t\treturn false;\n\t}\n\n\tif (cfg->flags & ~MLXSW_SP_NVE_VXLAN_IPV4_SUPPORTED_FLAGS) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: Unsupported flag\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool mlxsw_sp_nve_vxlan_ipv6_flags_check(const struct vxlan_config *cfg,\n\t\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (!(cfg->flags & VXLAN_F_UDP_ZERO_CSUM6_TX)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: Zero UDP checksum must be allowed for TX\");\n\t\treturn false;\n\t}\n\n\tif (!(cfg->flags & VXLAN_F_UDP_ZERO_CSUM6_RX)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: Zero UDP checksum must be allowed for RX\");\n\t\treturn false;\n\t}\n\n\tif (cfg->flags & ~MLXSW_SP_NVE_VXLAN_IPV6_SUPPORTED_FLAGS) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: Unsupported flag\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool mlxsw_sp_nve_vxlan_can_offload(const struct mlxsw_sp_nve *nve,\n\t\t\t\t\t   const struct mlxsw_sp_nve_params *params,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(params->dev);\n\tstruct vxlan_config *cfg = &vxlan->cfg;\n\n\tif (vxlan_addr_multicast(&cfg->remote_ip)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: Multicast destination IP is not supported\");\n\t\treturn false;\n\t}\n\n\tif (vxlan_addr_any(&cfg->saddr)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: Source address must be specified\");\n\t\treturn false;\n\t}\n\n\tif (cfg->remote_ifindex) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: Local interface is not supported\");\n\t\treturn false;\n\t}\n\n\tif (cfg->port_min || cfg->port_max) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: Only default UDP source port range is supported\");\n\t\treturn false;\n\t}\n\n\tif (cfg->tos != 1) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: TOS must be configured to inherit\");\n\t\treturn false;\n\t}\n\n\tif (cfg->flags & VXLAN_F_TTL_INHERIT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: TTL must not be configured to inherit\");\n\t\treturn false;\n\t}\n\n\tswitch (cfg->saddr.sa.sa_family) {\n\tcase AF_INET:\n\t\tif (!mlxsw_sp_nve_vxlan_ipv4_flags_check(cfg, extack))\n\t\t\treturn false;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (!mlxsw_sp_nve_vxlan_ipv6_flags_check(cfg, extack))\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\tif (cfg->ttl == 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: TTL must not be configured to 0\");\n\t\treturn false;\n\t}\n\n\tif (cfg->label != 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: Flow label must be configured to 0\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool mlxsw_sp1_nve_vxlan_can_offload(const struct mlxsw_sp_nve *nve,\n\t\t\t\t\t    const struct mlxsw_sp_nve_params *params,\n\t\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (params->ethertype == ETH_P_8021AD) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: 802.1ad bridge is not supported with VxLAN\");\n\t\treturn false;\n\t}\n\n\treturn mlxsw_sp_nve_vxlan_can_offload(nve, params, extack);\n}\n\nstatic void\nmlxsw_sp_nve_vxlan_ul_proto_sip_config(const struct vxlan_config *cfg,\n\t\t\t\t       struct mlxsw_sp_nve_config *config)\n{\n\tswitch (cfg->saddr.sa.sa_family) {\n\tcase AF_INET:\n\t\tconfig->ul_proto = MLXSW_SP_L3_PROTO_IPV4;\n\t\tconfig->ul_sip.addr4 = cfg->saddr.sin.sin_addr.s_addr;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tconfig->ul_proto = MLXSW_SP_L3_PROTO_IPV6;\n\t\tconfig->ul_sip.addr6 = cfg->saddr.sin6.sin6_addr;\n\t\tbreak;\n\t}\n}\n\nstatic void mlxsw_sp_nve_vxlan_config(const struct mlxsw_sp_nve *nve,\n\t\t\t\t      const struct mlxsw_sp_nve_params *params,\n\t\t\t\t      struct mlxsw_sp_nve_config *config)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(params->dev);\n\tstruct vxlan_config *cfg = &vxlan->cfg;\n\n\tconfig->type = MLXSW_SP_NVE_TYPE_VXLAN;\n\tconfig->ttl = cfg->ttl;\n\tconfig->flowlabel = cfg->label;\n\tconfig->learning_en = cfg->flags & VXLAN_F_LEARN ? 1 : 0;\n\tconfig->ul_tb_id = RT_TABLE_MAIN;\n\tmlxsw_sp_nve_vxlan_ul_proto_sip_config(cfg, config);\n\tconfig->udp_dport = cfg->dst_port;\n}\n\nstatic void\nmlxsw_sp_nve_vxlan_config_prepare(char *tngcr_pl,\n\t\t\t\t  const struct mlxsw_sp_nve_config *config)\n{\n\tstruct in6_addr addr6;\n\tu8 udp_sport;\n\n\tmlxsw_reg_tngcr_pack(tngcr_pl, MLXSW_REG_TNGCR_TYPE_VXLAN, true,\n\t\t\t     config->ttl);\n\t \n\tget_random_bytes(&udp_sport, sizeof(udp_sport));\n\tudp_sport = (udp_sport % (0xee - 0x80 + 1)) + 0x80;\n\tmlxsw_reg_tngcr_nve_udp_sport_prefix_set(tngcr_pl, udp_sport);\n\n\tswitch (config->ul_proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\tmlxsw_reg_tngcr_usipv4_set(tngcr_pl,\n\t\t\t\t\t   be32_to_cpu(config->ul_sip.addr4));\n\t\tbreak;\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\taddr6 = config->ul_sip.addr6;\n\t\tmlxsw_reg_tngcr_usipv6_memcpy_to(tngcr_pl,\n\t\t\t\t\t\t (const char *)&addr6);\n\t\tbreak;\n\t}\n}\n\nstatic int\nmlxsw_sp1_nve_vxlan_config_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       const struct mlxsw_sp_nve_config *config)\n{\n\tchar tngcr_pl[MLXSW_REG_TNGCR_LEN];\n\tu16 ul_vr_id;\n\tint err;\n\n\terr = mlxsw_sp_router_tb_id_vr_id(mlxsw_sp, config->ul_tb_id,\n\t\t\t\t\t  &ul_vr_id);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_sp_nve_vxlan_config_prepare(tngcr_pl, config);\n\tmlxsw_reg_tngcr_learn_enable_set(tngcr_pl, config->learning_en);\n\tmlxsw_reg_tngcr_underlay_virtual_router_set(tngcr_pl, ul_vr_id);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(tngcr), tngcr_pl);\n}\n\nstatic void mlxsw_sp1_nve_vxlan_config_clear(struct mlxsw_sp *mlxsw_sp)\n{\n\tchar tngcr_pl[MLXSW_REG_TNGCR_LEN];\n\n\tmlxsw_reg_tngcr_pack(tngcr_pl, MLXSW_REG_TNGCR_TYPE_VXLAN, false, 0);\n\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(tngcr), tngcr_pl);\n}\n\nstatic int mlxsw_sp1_nve_vxlan_rtdp_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tunsigned int tunnel_index)\n{\n\tchar rtdp_pl[MLXSW_REG_RTDP_LEN];\n\n\tmlxsw_reg_rtdp_pack(rtdp_pl, MLXSW_REG_RTDP_TYPE_NVE, tunnel_index);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rtdp), rtdp_pl);\n}\n\nstatic int mlxsw_sp1_nve_vxlan_init(struct mlxsw_sp_nve *nve,\n\t\t\t\t    const struct mlxsw_sp_nve_config *config)\n{\n\tstruct mlxsw_sp *mlxsw_sp = nve->mlxsw_sp;\n\tint err;\n\n\terr = mlxsw_sp_parsing_vxlan_udp_dport_set(mlxsw_sp, config->udp_dport);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_parsing_depth_inc(mlxsw_sp);\n\tif (err)\n\t\tgoto err_parsing_depth_inc;\n\n\terr = mlxsw_sp1_nve_vxlan_config_set(mlxsw_sp, config);\n\tif (err)\n\t\tgoto err_config_set;\n\n\terr = mlxsw_sp1_nve_vxlan_rtdp_set(mlxsw_sp, nve->tunnel_index);\n\tif (err)\n\t\tgoto err_rtdp_set;\n\n\terr = mlxsw_sp_router_nve_promote_decap(mlxsw_sp, config->ul_tb_id,\n\t\t\t\t\t\tconfig->ul_proto,\n\t\t\t\t\t\t&config->ul_sip,\n\t\t\t\t\t\tnve->tunnel_index);\n\tif (err)\n\t\tgoto err_promote_decap;\n\n\treturn 0;\n\nerr_promote_decap:\nerr_rtdp_set:\n\tmlxsw_sp1_nve_vxlan_config_clear(mlxsw_sp);\nerr_config_set:\n\tmlxsw_sp_parsing_depth_dec(mlxsw_sp);\nerr_parsing_depth_inc:\n\tmlxsw_sp_parsing_vxlan_udp_dport_set(mlxsw_sp, 0);\n\treturn err;\n}\n\nstatic void mlxsw_sp1_nve_vxlan_fini(struct mlxsw_sp_nve *nve)\n{\n\tstruct mlxsw_sp_nve_config *config = &nve->config;\n\tstruct mlxsw_sp *mlxsw_sp = nve->mlxsw_sp;\n\n\tmlxsw_sp_router_nve_demote_decap(mlxsw_sp, config->ul_tb_id,\n\t\t\t\t\t config->ul_proto, &config->ul_sip);\n\tmlxsw_sp1_nve_vxlan_config_clear(mlxsw_sp);\n\tmlxsw_sp_parsing_depth_dec(mlxsw_sp);\n\tmlxsw_sp_parsing_vxlan_udp_dport_set(mlxsw_sp, 0);\n}\n\nstatic int\nmlxsw_sp_nve_vxlan_fdb_replay(const struct net_device *nve_dev, __be32 vni,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tif (WARN_ON(!netif_is_vxlan(nve_dev)))\n\t\treturn -EINVAL;\n\treturn vxlan_fdb_replay(nve_dev, vni, &mlxsw_sp_switchdev_notifier,\n\t\t\t\textack);\n}\n\nstatic void\nmlxsw_sp_nve_vxlan_clear_offload(const struct net_device *nve_dev, __be32 vni)\n{\n\tif (WARN_ON(!netif_is_vxlan(nve_dev)))\n\t\treturn;\n\tvxlan_fdb_clear_offload(nve_dev, vni);\n}\n\nconst struct mlxsw_sp_nve_ops mlxsw_sp1_nve_vxlan_ops = {\n\t.type\t\t= MLXSW_SP_NVE_TYPE_VXLAN,\n\t.can_offload\t= mlxsw_sp1_nve_vxlan_can_offload,\n\t.nve_config\t= mlxsw_sp_nve_vxlan_config,\n\t.init\t\t= mlxsw_sp1_nve_vxlan_init,\n\t.fini\t\t= mlxsw_sp1_nve_vxlan_fini,\n\t.fdb_replay\t= mlxsw_sp_nve_vxlan_fdb_replay,\n\t.fdb_clear_offload = mlxsw_sp_nve_vxlan_clear_offload,\n};\n\nstatic int mlxsw_sp2_nve_vxlan_learning_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    bool learning_en)\n{\n\tchar tnpc_pl[MLXSW_REG_TNPC_LEN];\n\n\tmlxsw_reg_tnpc_pack(tnpc_pl, MLXSW_REG_TUNNEL_PORT_NVE,\n\t\t\t    learning_en);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(tnpc), tnpc_pl);\n}\n\nstatic int\nmlxsw_sp2_nve_decap_ethertype_set(struct mlxsw_sp *mlxsw_sp)\n{\n\tchar spvid_pl[MLXSW_REG_SPVID_LEN] = {};\n\n\tmlxsw_reg_spvid_tport_set(spvid_pl, true);\n\tmlxsw_reg_spvid_local_port_set(spvid_pl,\n\t\t\t\t       MLXSW_REG_TUNNEL_PORT_NVE);\n\tmlxsw_reg_spvid_egr_et_set_set(spvid_pl, true);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(spvid), spvid_pl);\n}\n\nstatic int\nmlxsw_sp2_nve_vxlan_config_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       const struct mlxsw_sp_nve_config *config)\n{\n\tchar tngcr_pl[MLXSW_REG_TNGCR_LEN];\n\tchar spvtr_pl[MLXSW_REG_SPVTR_LEN];\n\tu16 ul_rif_index;\n\tint err;\n\n\terr = mlxsw_sp_router_ul_rif_get(mlxsw_sp, config->ul_tb_id,\n\t\t\t\t\t &ul_rif_index);\n\tif (err)\n\t\treturn err;\n\tmlxsw_sp->nve->ul_rif_index = ul_rif_index;\n\n\terr = mlxsw_sp2_nve_vxlan_learning_set(mlxsw_sp, config->learning_en);\n\tif (err)\n\t\tgoto err_vxlan_learning_set;\n\n\tmlxsw_sp_nve_vxlan_config_prepare(tngcr_pl, config);\n\tmlxsw_reg_tngcr_underlay_rif_set(tngcr_pl, ul_rif_index);\n\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(tngcr), tngcr_pl);\n\tif (err)\n\t\tgoto err_tngcr_write;\n\n\tmlxsw_reg_spvtr_pack(spvtr_pl, true, MLXSW_REG_TUNNEL_PORT_NVE,\n\t\t\t     MLXSW_REG_SPVTR_IPVID_MODE_ALWAYS_PUSH_VLAN);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(spvtr), spvtr_pl);\n\tif (err)\n\t\tgoto err_spvtr_write;\n\n\terr = mlxsw_sp2_nve_decap_ethertype_set(mlxsw_sp);\n\tif (err)\n\t\tgoto err_decap_ethertype_set;\n\n\treturn 0;\n\nerr_decap_ethertype_set:\n\tmlxsw_reg_spvtr_pack(spvtr_pl, true, MLXSW_REG_TUNNEL_PORT_NVE,\n\t\t\t     MLXSW_REG_SPVTR_IPVID_MODE_IEEE_COMPLIANT_PVID);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(spvtr), spvtr_pl);\nerr_spvtr_write:\n\tmlxsw_reg_tngcr_pack(tngcr_pl, MLXSW_REG_TNGCR_TYPE_VXLAN, false, 0);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(tngcr), tngcr_pl);\nerr_tngcr_write:\n\tmlxsw_sp2_nve_vxlan_learning_set(mlxsw_sp, false);\nerr_vxlan_learning_set:\n\tmlxsw_sp_router_ul_rif_put(mlxsw_sp, ul_rif_index);\n\treturn err;\n}\n\nstatic void mlxsw_sp2_nve_vxlan_config_clear(struct mlxsw_sp *mlxsw_sp)\n{\n\tchar spvtr_pl[MLXSW_REG_SPVTR_LEN];\n\tchar tngcr_pl[MLXSW_REG_TNGCR_LEN];\n\n\tmlxsw_reg_spvtr_pack(spvtr_pl, true, MLXSW_REG_TUNNEL_PORT_NVE,\n\t\t\t     MLXSW_REG_SPVTR_IPVID_MODE_IEEE_COMPLIANT_PVID);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(spvtr), spvtr_pl);\n\tmlxsw_reg_tngcr_pack(tngcr_pl, MLXSW_REG_TNGCR_TYPE_VXLAN, false, 0);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(tngcr), tngcr_pl);\n\tmlxsw_sp2_nve_vxlan_learning_set(mlxsw_sp, false);\n\tmlxsw_sp_router_ul_rif_put(mlxsw_sp, mlxsw_sp->nve->ul_rif_index);\n}\n\nstatic int mlxsw_sp2_nve_vxlan_rtdp_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tunsigned int tunnel_index,\n\t\t\t\t\tu16 ul_rif_index)\n{\n\tchar rtdp_pl[MLXSW_REG_RTDP_LEN];\n\n\tmlxsw_reg_rtdp_pack(rtdp_pl, MLXSW_REG_RTDP_TYPE_NVE, tunnel_index);\n\tmlxsw_reg_rtdp_egress_router_interface_set(rtdp_pl, ul_rif_index);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rtdp), rtdp_pl);\n}\n\nstatic int mlxsw_sp2_nve_vxlan_init(struct mlxsw_sp_nve *nve,\n\t\t\t\t    const struct mlxsw_sp_nve_config *config)\n{\n\tstruct mlxsw_sp *mlxsw_sp = nve->mlxsw_sp;\n\tint err;\n\n\terr = mlxsw_sp_parsing_vxlan_udp_dport_set(mlxsw_sp, config->udp_dport);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_parsing_depth_inc(mlxsw_sp);\n\tif (err)\n\t\tgoto err_parsing_depth_inc;\n\n\terr = mlxsw_sp2_nve_vxlan_config_set(mlxsw_sp, config);\n\tif (err)\n\t\tgoto err_config_set;\n\n\terr = mlxsw_sp2_nve_vxlan_rtdp_set(mlxsw_sp, nve->tunnel_index,\n\t\t\t\t\t   nve->ul_rif_index);\n\tif (err)\n\t\tgoto err_rtdp_set;\n\n\terr = mlxsw_sp_router_nve_promote_decap(mlxsw_sp, config->ul_tb_id,\n\t\t\t\t\t\tconfig->ul_proto,\n\t\t\t\t\t\t&config->ul_sip,\n\t\t\t\t\t\tnve->tunnel_index);\n\tif (err)\n\t\tgoto err_promote_decap;\n\n\treturn 0;\n\nerr_promote_decap:\nerr_rtdp_set:\n\tmlxsw_sp2_nve_vxlan_config_clear(mlxsw_sp);\nerr_config_set:\n\tmlxsw_sp_parsing_depth_dec(mlxsw_sp);\nerr_parsing_depth_inc:\n\tmlxsw_sp_parsing_vxlan_udp_dport_set(mlxsw_sp, 0);\n\treturn err;\n}\n\nstatic void mlxsw_sp2_nve_vxlan_fini(struct mlxsw_sp_nve *nve)\n{\n\tstruct mlxsw_sp_nve_config *config = &nve->config;\n\tstruct mlxsw_sp *mlxsw_sp = nve->mlxsw_sp;\n\n\tmlxsw_sp_router_nve_demote_decap(mlxsw_sp, config->ul_tb_id,\n\t\t\t\t\t config->ul_proto, &config->ul_sip);\n\tmlxsw_sp2_nve_vxlan_config_clear(mlxsw_sp);\n\tmlxsw_sp_parsing_depth_dec(mlxsw_sp);\n\tmlxsw_sp_parsing_vxlan_udp_dport_set(mlxsw_sp, 0);\n}\n\nconst struct mlxsw_sp_nve_ops mlxsw_sp2_nve_vxlan_ops = {\n\t.type\t\t= MLXSW_SP_NVE_TYPE_VXLAN,\n\t.can_offload\t= mlxsw_sp_nve_vxlan_can_offload,\n\t.nve_config\t= mlxsw_sp_nve_vxlan_config,\n\t.init\t\t= mlxsw_sp2_nve_vxlan_init,\n\t.fini\t\t= mlxsw_sp2_nve_vxlan_fini,\n\t.fdb_replay\t= mlxsw_sp_nve_vxlan_fdb_replay,\n\t.fdb_clear_offload = mlxsw_sp_nve_vxlan_clear_offload,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}