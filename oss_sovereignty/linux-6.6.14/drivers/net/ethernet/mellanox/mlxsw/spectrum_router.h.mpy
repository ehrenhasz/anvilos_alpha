{
  "module_name": "spectrum_router.h",
  "hash_id": "8576e742825a508cc5ad2dc35be7c77ba2c7ea490e9beba1cce7b0c35b8a9c64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.h",
  "human_readable_source": " \n \n\n#ifndef _MLXSW_ROUTER_H_\n#define _MLXSW_ROUTER_H_\n\n#include \"spectrum.h\"\n#include \"reg.h\"\n\nstruct mlxsw_sp_router_nve_decap {\n\tu32 ul_tb_id;\n\tu32 tunnel_index;\n\tenum mlxsw_sp_l3proto ul_proto;\n\tunion mlxsw_sp_l3addr ul_sip;\n\tu8 valid:1;\n};\n\n \n#define MLXSW_SP_ROUTER_GENALLOC_OFFSET 0x100\n\nstruct mlxsw_sp_router {\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct rhashtable crif_ht;\n\tstruct gen_pool *rifs_table;\n\tstruct mlxsw_sp_rif **rifs;\n\tstruct idr rif_mac_profiles_idr;\n\tatomic_t rif_mac_profiles_count;\n\tatomic_t rifs_count;\n\tu8 max_rif_mac_profile;\n\tstruct mlxsw_sp_vr *vrs;\n\tstruct rhashtable neigh_ht;\n\tstruct rhashtable nexthop_group_ht;\n\tstruct rhashtable nexthop_ht;\n\tstruct list_head nexthop_list;\n\tstruct {\n\t\t \n\t\tstruct mlxsw_sp_lpm_tree *proto_trees[2];\n\t\tstruct mlxsw_sp_lpm_tree *trees;\n\t\tunsigned int tree_count;\n\t} lpm;\n\tstruct {\n\t\tstruct delayed_work dw;\n\t\tunsigned long interval;\t \n\t\tatomic_t neigh_count;\n\t} neighs_update;\n\tstruct delayed_work nexthop_probe_dw;\n#define MLXSW_SP_UNRESOLVED_NH_PROBE_INTERVAL 5000  \n\tstruct list_head nexthop_neighs_list;\n\tstruct list_head ipip_list;\n\tstruct notifier_block nexthop_nb;\n\tstruct notifier_block fib_nb;\n\tstruct notifier_block netevent_nb;\n\tstruct notifier_block inetaddr_nb;\n\tstruct notifier_block inet6addr_nb;\n\tstruct notifier_block netdevice_nb;\n\tstruct notifier_block inetaddr_valid_nb;\n\tstruct notifier_block inet6addr_valid_nb;\n\tconst struct mlxsw_sp_rif_ops **rif_ops_arr;\n\tconst struct mlxsw_sp_ipip_ops **ipip_ops_arr;\n\tstruct mlxsw_sp_router_nve_decap nve_decap_config;\n\tstruct mutex lock;  \n\tstruct mlxsw_sp_fib_entry_op_ctx *ll_op_ctx;\n\tstruct mlxsw_sp_crif *lb_crif;\n\tconst struct mlxsw_sp_adj_grp_size_range *adj_grp_size_ranges;\n\tsize_t adj_grp_size_ranges_count;\n\tstruct delayed_work nh_grp_activity_dw;\n\tstruct list_head nh_res_grp_list;\n\tbool inc_parsing_depth;\n\trefcount_t num_groups;\n\tu32 adj_trap_index;\n};\n\nstruct mlxsw_sp_rif_ipip_lb;\nstruct mlxsw_sp_rif_ipip_lb_config {\n\tenum mlxsw_reg_ritr_loopback_ipip_type lb_ipipt;\n\tu32 okey;\n\tenum mlxsw_sp_l3proto ul_protocol;  \n\tunion mlxsw_sp_l3addr saddr;\n};\n\nenum mlxsw_sp_rif_counter_dir {\n\tMLXSW_SP_RIF_COUNTER_INGRESS,\n\tMLXSW_SP_RIF_COUNTER_EGRESS,\n};\n\nstruct mlxsw_sp_neigh_entry;\nstruct mlxsw_sp_nexthop;\nstruct mlxsw_sp_ipip_entry;\n\nstruct mlxsw_sp_rif *mlxsw_sp_rif_by_index(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   u16 rif_index);\nu16 mlxsw_sp_ipip_lb_rif_index(const struct mlxsw_sp_rif_ipip_lb *rif);\nu16 mlxsw_sp_ipip_lb_ul_vr_id(const struct mlxsw_sp_rif_ipip_lb *rif);\nu16 mlxsw_sp_ipip_lb_ul_rif_id(const struct mlxsw_sp_rif_ipip_lb *lb_rif);\nu32 mlxsw_sp_ipip_dev_ul_tb_id(const struct net_device *ol_dev);\nint mlxsw_sp_rif_dev_ifindex(const struct mlxsw_sp_rif *rif);\nbool mlxsw_sp_rif_has_dev(const struct mlxsw_sp_rif *rif);\nbool mlxsw_sp_rif_dev_is(const struct mlxsw_sp_rif *rif,\n\t\t\t const struct net_device *dev);\nint mlxsw_sp_rif_counter_value_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_rif *rif,\n\t\t\t\t   enum mlxsw_sp_rif_counter_dir dir,\n\t\t\t\t   u64 *cnt);\nvoid mlxsw_sp_rif_counter_free(struct mlxsw_sp_rif *rif,\n\t\t\t       enum mlxsw_sp_rif_counter_dir dir);\nint mlxsw_sp_rif_counter_alloc(struct mlxsw_sp_rif *rif,\n\t\t\t       enum mlxsw_sp_rif_counter_dir dir);\nstruct mlxsw_sp_neigh_entry *\nmlxsw_sp_rif_neigh_next(struct mlxsw_sp_rif *rif,\n\t\t\tstruct mlxsw_sp_neigh_entry *neigh_entry);\nint mlxsw_sp_neigh_entry_type(struct mlxsw_sp_neigh_entry *neigh_entry);\nunsigned char *\nmlxsw_sp_neigh_entry_ha(struct mlxsw_sp_neigh_entry *neigh_entry);\nu32 mlxsw_sp_neigh4_entry_dip(struct mlxsw_sp_neigh_entry *neigh_entry);\nstruct in6_addr *\nmlxsw_sp_neigh6_entry_dip(struct mlxsw_sp_neigh_entry *neigh_entry);\n\n#define mlxsw_sp_rif_neigh_for_each(neigh_entry, rif)\t\t\t\t\\\n\tfor (neigh_entry = mlxsw_sp_rif_neigh_next(rif, NULL); neigh_entry;\t\\\n\t     neigh_entry = mlxsw_sp_rif_neigh_next(rif, neigh_entry))\nint mlxsw_sp_neigh_counter_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_neigh_entry *neigh_entry,\n\t\t\t       u64 *p_counter);\nvoid\nmlxsw_sp_neigh_entry_counter_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_neigh_entry *neigh_entry,\n\t\t\t\t    bool adding);\nbool mlxsw_sp_neigh_ipv6_ignore(struct mlxsw_sp_neigh_entry *neigh_entry);\nint __mlxsw_sp_ipip_entry_update_tunnel(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\t\tbool recreate_loopback,\n\t\t\t\t\tbool keep_encap,\n\t\t\t\t\tbool update_nexthops,\n\t\t\t\t\tstruct netlink_ext_ack *extack);\nvoid mlxsw_sp_ipip_entry_demote_tunnel(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_ipip_entry *ipip_entry);\nbool\nmlxsw_sp_ipip_demote_tunnel_by_saddr(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     enum mlxsw_sp_l3proto ul_proto,\n\t\t\t\t     union mlxsw_sp_l3addr saddr,\n\t\t\t\t     u32 ul_tb_id,\n\t\t\t\t     const struct mlxsw_sp_ipip_entry *except);\nstruct mlxsw_sp_nexthop *mlxsw_sp_nexthop_next(struct mlxsw_sp_router *router,\n\t\t\t\t\t       struct mlxsw_sp_nexthop *nh);\nbool mlxsw_sp_nexthop_is_forward(const struct mlxsw_sp_nexthop *nh);\nunsigned char *mlxsw_sp_nexthop_ha(struct mlxsw_sp_nexthop *nh);\nint mlxsw_sp_nexthop_indexes(struct mlxsw_sp_nexthop *nh, u32 *p_adj_index,\n\t\t\t     u32 *p_adj_size, u32 *p_adj_hash_index);\nstruct mlxsw_sp_rif *mlxsw_sp_nexthop_rif(struct mlxsw_sp_nexthop *nh);\nbool mlxsw_sp_nexthop_group_has_ipip(struct mlxsw_sp_nexthop *nh);\n#define mlxsw_sp_nexthop_for_each(nh, router)\t\t\t\t\\\n\tfor (nh = mlxsw_sp_nexthop_next(router, NULL); nh;\t\t\\\n\t     nh = mlxsw_sp_nexthop_next(router, nh))\nint mlxsw_sp_nexthop_counter_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_nexthop *nh, u64 *p_counter);\nint mlxsw_sp_nexthop_eth_update(struct mlxsw_sp *mlxsw_sp, u32 adj_index,\n\t\t\t\tstruct mlxsw_sp_nexthop *nh, bool force,\n\t\t\t\tchar *ratr_pl);\nvoid mlxsw_sp_nexthop_counter_alloc(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_nexthop *nh);\nvoid mlxsw_sp_nexthop_counter_free(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_nexthop *nh);\n\nstatic inline bool mlxsw_sp_l3addr_eq(const union mlxsw_sp_l3addr *addr1,\n\t\t\t\t      const union mlxsw_sp_l3addr *addr2)\n{\n\treturn !memcmp(addr1, addr2, sizeof(*addr1));\n}\n\nint mlxsw_sp_ipip_ecn_encap_init(struct mlxsw_sp *mlxsw_sp);\nint mlxsw_sp_ipip_ecn_decap_init(struct mlxsw_sp *mlxsw_sp);\nstruct net_device *\nmlxsw_sp_ipip_netdev_ul_dev_get(const struct net_device *ol_dev);\nint mlxsw_sp_router_bridge_vlan_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct net_device *dev,\n\t\t\t\t    u16 new_vid, bool is_pvid,\n\t\t\t\t    struct netlink_ext_ack *extack);\nint mlxsw_sp_router_port_join_lag(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  struct net_device *lag_dev,\n\t\t\t\t  struct netlink_ext_ack *extack);\nvoid mlxsw_sp_router_port_leave_lag(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    struct net_device *lag_dev);\nint mlxsw_sp_netdevice_enslavement_replay(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct net_device *upper_dev,\n\t\t\t\t\t  struct netlink_ext_ack *extack);\nvoid mlxsw_sp_netdevice_deslavement_replay(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   struct net_device *dev);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}