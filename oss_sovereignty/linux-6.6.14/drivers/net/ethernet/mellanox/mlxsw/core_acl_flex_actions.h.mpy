{
  "module_name": "core_acl_flex_actions.h",
  "hash_id": "fcd72a41a269054e9dd47ef888c79c37c2c883a774f1d4c63b9d99dde300eee2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_actions.h",
  "human_readable_source": " \n \n\n#ifndef _MLXSW_CORE_ACL_FLEX_ACTIONS_H\n#define _MLXSW_CORE_ACL_FLEX_ACTIONS_H\n\n#include <linux/types.h>\n#include <linux/netdevice.h>\n#include <net/flow_offload.h>\n\nstruct mlxsw_afa;\nstruct mlxsw_afa_block;\n\nstruct mlxsw_afa_ops {\n\tint (*kvdl_set_add)(void *priv, u32 *p_kvdl_index,\n\t\t\t    char *enc_actions, bool is_first);\n\tvoid (*kvdl_set_del)(void *priv, u32 kvdl_index, bool is_first);\n\tint (*kvdl_set_activity_get)(void *priv, u32 kvdl_index,\n\t\t\t\t     bool *activity);\n\tint (*kvdl_fwd_entry_add)(void *priv, u32 *p_kvdl_index, u16 local_port);\n\tvoid (*kvdl_fwd_entry_del)(void *priv, u32 kvdl_index);\n\tint (*counter_index_get)(void *priv, unsigned int *p_counter_index);\n\tvoid (*counter_index_put)(void *priv, unsigned int counter_index);\n\tint (*mirror_add)(void *priv, u16 local_in_port,\n\t\t\t  const struct net_device *out_dev,\n\t\t\t  bool ingress, int *p_span_id);\n\tvoid (*mirror_del)(void *priv, u16 local_in_port, int span_id,\n\t\t\t   bool ingress);\n\tint (*policer_add)(void *priv, u64 rate_bytes_ps, u32 burst,\n\t\t\t   u16 *p_policer_index,\n\t\t\t   struct netlink_ext_ack *extack);\n\tvoid (*policer_del)(void *priv, u16 policer_index);\n\tint (*sampler_add)(void *priv, u16 local_port,\n\t\t\t   struct psample_group *psample_group, u32 rate,\n\t\t\t   u32 trunc_size, bool truncate, bool ingress,\n\t\t\t   int *p_span_id, struct netlink_ext_ack *extack);\n\tvoid (*sampler_del)(void *priv, u16 local_port, int span_id,\n\t\t\t    bool ingress);\n\tbool dummy_first_set;\n};\n\nstruct mlxsw_afa *mlxsw_afa_create(unsigned int max_acts_per_set,\n\t\t\t\t   const struct mlxsw_afa_ops *ops,\n\t\t\t\t   void *ops_priv);\nvoid mlxsw_afa_destroy(struct mlxsw_afa *mlxsw_afa);\nstruct mlxsw_afa_block *mlxsw_afa_block_create(struct mlxsw_afa *mlxsw_afa);\nvoid mlxsw_afa_block_destroy(struct mlxsw_afa_block *block);\nint mlxsw_afa_block_commit(struct mlxsw_afa_block *block);\nchar *mlxsw_afa_block_first_set(struct mlxsw_afa_block *block);\nchar *mlxsw_afa_block_cur_set(struct mlxsw_afa_block *block);\nu32 mlxsw_afa_block_first_kvdl_index(struct mlxsw_afa_block *block);\nint mlxsw_afa_block_activity_get(struct mlxsw_afa_block *block, bool *activity);\nint mlxsw_afa_block_continue(struct mlxsw_afa_block *block);\nint mlxsw_afa_block_jump(struct mlxsw_afa_block *block, u16 group_id);\nint mlxsw_afa_block_terminate(struct mlxsw_afa_block *block);\nconst struct flow_action_cookie *\nmlxsw_afa_cookie_lookup(struct mlxsw_afa *mlxsw_afa, u32 cookie_index);\nint mlxsw_afa_block_append_drop(struct mlxsw_afa_block *block, bool ingress,\n\t\t\t\tconst struct flow_action_cookie *fa_cookie,\n\t\t\t\tstruct netlink_ext_ack *extack);\nint mlxsw_afa_block_append_trap(struct mlxsw_afa_block *block, u16 trap_id);\nint mlxsw_afa_block_append_trap_and_forward(struct mlxsw_afa_block *block,\n\t\t\t\t\t    u16 trap_id);\nint mlxsw_afa_block_append_mirror(struct mlxsw_afa_block *block,\n\t\t\t\t  u16 local_in_port,\n\t\t\t\t  const struct net_device *out_dev,\n\t\t\t\t  bool ingress,\n\t\t\t\t  struct netlink_ext_ack *extack);\nint mlxsw_afa_block_append_fwd(struct mlxsw_afa_block *block,\n\t\t\t       u16 local_port, bool in_port,\n\t\t\t       struct netlink_ext_ack *extack);\nint mlxsw_afa_block_append_vlan_modify(struct mlxsw_afa_block *block,\n\t\t\t\t       u16 vid, u8 pcp, u8 et,\n\t\t\t\t       struct netlink_ext_ack *extack);\nint mlxsw_afa_block_append_qos_switch_prio(struct mlxsw_afa_block *block,\n\t\t\t\t\t   u8 prio,\n\t\t\t\t\t   struct netlink_ext_ack *extack);\nint mlxsw_afa_block_append_qos_dsfield(struct mlxsw_afa_block *block,\n\t\t\t\t       u8 dsfield,\n\t\t\t\t       struct netlink_ext_ack *extack);\nint mlxsw_afa_block_append_qos_dscp(struct mlxsw_afa_block *block,\n\t\t\t\t    u8 dscp, struct netlink_ext_ack *extack);\nint mlxsw_afa_block_append_qos_ecn(struct mlxsw_afa_block *block,\n\t\t\t\t   u8 ecn, struct netlink_ext_ack *extack);\nint mlxsw_afa_block_append_allocated_counter(struct mlxsw_afa_block *block,\n\t\t\t\t\t     u32 counter_index);\nint mlxsw_afa_block_append_counter(struct mlxsw_afa_block *block,\n\t\t\t\t   u32 *p_counter_index,\n\t\t\t\t   struct netlink_ext_ack *extack);\nint mlxsw_afa_block_append_fid_set(struct mlxsw_afa_block *block, u16 fid,\n\t\t\t\t   struct netlink_ext_ack *extack);\nint mlxsw_afa_block_append_ignore(struct mlxsw_afa_block *block,\n\t\t\t\t  bool disable_learning, bool disable_security);\nint mlxsw_afa_block_append_mcrouter(struct mlxsw_afa_block *block,\n\t\t\t\t    u16 expected_irif, u16 min_mtu,\n\t\t\t\t    bool rmid_valid, u32 kvdl_index);\nint mlxsw_afa_block_append_ip(struct mlxsw_afa_block *block, bool is_dip,\n\t\t\t      bool is_lsb, u32 val_31_0, u32 val_63_32,\n\t\t\t      struct netlink_ext_ack *extack);\nint mlxsw_afa_block_append_l4port(struct mlxsw_afa_block *block, bool is_dport, u16 l4_port,\n\t\t\t\t  struct netlink_ext_ack *extack);\nint mlxsw_afa_block_append_police(struct mlxsw_afa_block *block,\n\t\t\t\t  u32 fa_index, u64 rate_bytes_ps, u32 burst,\n\t\t\t\t  u16 *p_policer_index,\n\t\t\t\t  struct netlink_ext_ack *extack);\nint mlxsw_afa_block_append_sampler(struct mlxsw_afa_block *block, u16 local_port,\n\t\t\t\t   struct psample_group *psample_group,\n\t\t\t\t   u32 rate, u32 trunc_size, bool truncate,\n\t\t\t\t   bool ingress,\n\t\t\t\t   struct netlink_ext_ack *extack);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}