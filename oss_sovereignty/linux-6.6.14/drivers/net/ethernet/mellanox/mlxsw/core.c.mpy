{
  "module_name": "core.c",
  "hash_id": "0d0b94cf4be3b99d3bf58d1b50a04632cbb1da508fe19ab9bce8c400938f04fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/err.h>\n#include <linux/if_link.h>\n#include <linux/netdevice.h>\n#include <linux/completion.h>\n#include <linux/skbuff.h>\n#include <linux/etherdevice.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/gfp.h>\n#include <linux/random.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/firmware.h>\n#include <asm/byteorder.h>\n#include <net/devlink.h>\n#include <trace/events/devlink.h>\n\n#include \"core.h\"\n#include \"core_env.h\"\n#include \"item.h\"\n#include \"cmd.h\"\n#include \"port.h\"\n#include \"trap.h\"\n#include \"emad.h\"\n#include \"reg.h\"\n#include \"resources.h\"\n#include \"../mlxfw/mlxfw.h\"\n\nstatic LIST_HEAD(mlxsw_core_driver_list);\nstatic DEFINE_SPINLOCK(mlxsw_core_driver_list_lock);\n\nstatic const char mlxsw_core_driver_name[] = \"mlxsw_core\";\n\nstatic struct workqueue_struct *mlxsw_wq;\nstatic struct workqueue_struct *mlxsw_owq;\n\nstruct mlxsw_core_port {\n\tstruct devlink_port devlink_port;\n\tvoid *port_driver_priv;\n\tu16 local_port;\n\tstruct mlxsw_linecard *linecard;\n};\n\nvoid *mlxsw_core_port_driver_priv(struct mlxsw_core_port *mlxsw_core_port)\n{\n\treturn mlxsw_core_port->port_driver_priv;\n}\nEXPORT_SYMBOL(mlxsw_core_port_driver_priv);\n\nstatic bool mlxsw_core_port_check(struct mlxsw_core_port *mlxsw_core_port)\n{\n\treturn mlxsw_core_port->port_driver_priv != NULL;\n}\n\nstruct mlxsw_core {\n\tstruct mlxsw_driver *driver;\n\tconst struct mlxsw_bus *bus;\n\tvoid *bus_priv;\n\tconst struct mlxsw_bus_info *bus_info;\n\tstruct workqueue_struct *emad_wq;\n\tstruct list_head rx_listener_list;\n\tstruct list_head event_listener_list;\n\tstruct list_head irq_event_handler_list;\n\tstruct mutex irq_event_handler_lock;  \n\tstruct {\n\t\tatomic64_t tid;\n\t\tstruct list_head trans_list;\n\t\tspinlock_t trans_list_lock;  \n\t\tbool use_emad;\n\t\tbool enable_string_tlv;\n\t\tbool enable_latency_tlv;\n\t} emad;\n\tstruct {\n\t\tu16 *mapping;  \n\t} lag;\n\tstruct mlxsw_res res;\n\tstruct mlxsw_hwmon *hwmon;\n\tstruct mlxsw_thermal *thermal;\n\tstruct mlxsw_linecards *linecards;\n\tstruct mlxsw_core_port *ports;\n\tunsigned int max_ports;\n\tatomic_t active_ports_count;\n\tbool fw_flash_in_progress;\n\tstruct {\n\t\tstruct devlink_health_reporter *fw_fatal;\n\t} health;\n\tstruct mlxsw_env *env;\n\tunsigned long driver_priv[];\n\t \n};\n\nstruct mlxsw_linecards *mlxsw_core_linecards(struct mlxsw_core *mlxsw_core)\n{\n\treturn mlxsw_core->linecards;\n}\n\nvoid mlxsw_core_linecards_set(struct mlxsw_core *mlxsw_core,\n\t\t\t      struct mlxsw_linecards *linecards)\n{\n\tmlxsw_core->linecards = linecards;\n}\n\n#define MLXSW_PORT_MAX_PORTS_DEFAULT\t0x40\n\nstatic u64 mlxsw_ports_occ_get(void *priv)\n{\n\tstruct mlxsw_core *mlxsw_core = priv;\n\n\treturn atomic_read(&mlxsw_core->active_ports_count);\n}\n\nstatic int mlxsw_core_resources_ports_register(struct mlxsw_core *mlxsw_core)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tstruct devlink_resource_size_params ports_num_params;\n\tu32 max_ports;\n\n\tmax_ports = mlxsw_core->max_ports - 1;\n\tdevlink_resource_size_params_init(&ports_num_params, max_ports,\n\t\t\t\t\t  max_ports, 1,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\n\treturn devl_resource_register(devlink,\n\t\t\t\t      DEVLINK_RESOURCE_GENERIC_NAME_PORTS,\n\t\t\t\t      max_ports, MLXSW_CORE_RESOURCE_PORTS,\n\t\t\t\t      DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t      &ports_num_params);\n}\n\nstatic int mlxsw_ports_init(struct mlxsw_core *mlxsw_core, bool reload)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tint err;\n\n\t \n\tif (MLXSW_CORE_RES_VALID(mlxsw_core, MAX_SYSTEM_PORT))\n\t\tmlxsw_core->max_ports = MLXSW_CORE_RES_GET(mlxsw_core,\n\t\t\t\t\t\t\t   MAX_SYSTEM_PORT) + 1;\n\telse\n\t\tmlxsw_core->max_ports = MLXSW_PORT_MAX_PORTS_DEFAULT + 1;\n\n\tmlxsw_core->ports = kcalloc(mlxsw_core->max_ports,\n\t\t\t\t    sizeof(struct mlxsw_core_port), GFP_KERNEL);\n\tif (!mlxsw_core->ports)\n\t\treturn -ENOMEM;\n\n\tif (!reload) {\n\t\terr = mlxsw_core_resources_ports_register(mlxsw_core);\n\t\tif (err)\n\t\t\tgoto err_resources_ports_register;\n\t}\n\tatomic_set(&mlxsw_core->active_ports_count, 0);\n\tdevl_resource_occ_get_register(devlink, MLXSW_CORE_RESOURCE_PORTS,\n\t\t\t\t       mlxsw_ports_occ_get, mlxsw_core);\n\n\treturn 0;\n\nerr_resources_ports_register:\n\tkfree(mlxsw_core->ports);\n\treturn err;\n}\n\nstatic void mlxsw_ports_fini(struct mlxsw_core *mlxsw_core, bool reload)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\n\tdevl_resource_occ_get_unregister(devlink, MLXSW_CORE_RESOURCE_PORTS);\n\tif (!reload)\n\t\tdevl_resources_unregister(priv_to_devlink(mlxsw_core));\n\n\tkfree(mlxsw_core->ports);\n}\n\nunsigned int mlxsw_core_max_ports(const struct mlxsw_core *mlxsw_core)\n{\n\treturn mlxsw_core->max_ports;\n}\nEXPORT_SYMBOL(mlxsw_core_max_ports);\n\nint mlxsw_core_max_lag(struct mlxsw_core *mlxsw_core, u16 *p_max_lag)\n{\n\tstruct mlxsw_driver *driver = mlxsw_core->driver;\n\n\tif (driver->profile->used_max_lag) {\n\t\t*p_max_lag = driver->profile->max_lag;\n\t\treturn 0;\n\t}\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_core, MAX_LAG))\n\t\treturn -EIO;\n\n\t*p_max_lag = MLXSW_CORE_RES_GET(mlxsw_core, MAX_LAG);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_core_max_lag);\n\nvoid *mlxsw_core_driver_priv(struct mlxsw_core *mlxsw_core)\n{\n\treturn mlxsw_core->driver_priv;\n}\nEXPORT_SYMBOL(mlxsw_core_driver_priv);\n\nbool\nmlxsw_core_fw_rev_minor_subminor_validate(const struct mlxsw_fw_rev *rev,\n\t\t\t\t\t  const struct mlxsw_fw_rev *req_rev)\n{\n\treturn rev->minor > req_rev->minor ||\n\t       (rev->minor == req_rev->minor &&\n\t\trev->subminor >= req_rev->subminor);\n}\nEXPORT_SYMBOL(mlxsw_core_fw_rev_minor_subminor_validate);\n\nstruct mlxsw_rx_listener_item {\n\tstruct list_head list;\n\tstruct mlxsw_rx_listener rxl;\n\tvoid *priv;\n\tbool enabled;\n};\n\nstruct mlxsw_event_listener_item {\n\tstruct list_head list;\n\tstruct mlxsw_core *mlxsw_core;\n\tstruct mlxsw_event_listener el;\n\tvoid *priv;\n};\n\nstatic const u8 mlxsw_core_trap_groups[] = {\n\tMLXSW_REG_HTGT_TRAP_GROUP_EMAD,\n\tMLXSW_REG_HTGT_TRAP_GROUP_CORE_EVENT,\n};\n\nstatic int mlxsw_core_trap_groups_set(struct mlxsw_core *mlxsw_core)\n{\n\tchar htgt_pl[MLXSW_REG_HTGT_LEN];\n\tint err;\n\tint i;\n\n\tif (!(mlxsw_core->bus->features & MLXSW_BUS_F_TXRX))\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(mlxsw_core_trap_groups); i++) {\n\t\tmlxsw_reg_htgt_pack(htgt_pl, mlxsw_core_trap_groups[i],\n\t\t\t\t    MLXSW_REG_HTGT_INVALID_POLICER,\n\t\t\t\t    MLXSW_REG_HTGT_DEFAULT_PRIORITY,\n\t\t\t\t    MLXSW_REG_HTGT_DEFAULT_TC);\n\t\terr = mlxsw_reg_write(mlxsw_core, MLXSW_REG(htgt), htgt_pl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \n\n \nMLXSW_ITEM_BUF(emad, eth_hdr, dmac, 0x00, 6);\n\n \nMLXSW_ITEM_BUF(emad, eth_hdr, smac, 0x06, 6);\n\n \nMLXSW_ITEM32(emad, eth_hdr, ethertype, 0x0C, 16, 16);\n\n \nMLXSW_ITEM32(emad, eth_hdr, mlx_proto, 0x0C, 8, 8);\n\n \nMLXSW_ITEM32(emad, eth_hdr, ver, 0x0C, 4, 4);\n\n \nMLXSW_ITEM32(emad, op_tlv, type, 0x00, 27, 5);\n\n \nMLXSW_ITEM32(emad, op_tlv, len, 0x00, 16, 11);\n\n \nMLXSW_ITEM32(emad, op_tlv, dr, 0x00, 15, 1);\n\n \nMLXSW_ITEM32(emad, op_tlv, status, 0x00, 8, 7);\n\n \nMLXSW_ITEM32(emad, op_tlv, register_id, 0x04, 16, 16);\n\n \nMLXSW_ITEM32(emad, op_tlv, r, 0x04, 15, 1);\n\n \nMLXSW_ITEM32(emad, op_tlv, method, 0x04, 8, 7);\n\n \nMLXSW_ITEM32(emad, op_tlv, class, 0x04, 0, 8);\n\n \nMLXSW_ITEM64(emad, op_tlv, tid, 0x08, 0, 64);\n\n \nMLXSW_ITEM32(emad, string_tlv, type, 0x00, 27, 5);\n\n \nMLXSW_ITEM32(emad, string_tlv, len, 0x00, 16, 11);\n\n#define MLXSW_EMAD_STRING_TLV_STRING_LEN 128\n\n \nMLXSW_ITEM_BUF(emad, string_tlv, string, 0x04,\n\t       MLXSW_EMAD_STRING_TLV_STRING_LEN);\n\n \nMLXSW_ITEM32(emad, latency_tlv, type, 0x00, 27, 5);\n\n \nMLXSW_ITEM32(emad, latency_tlv, len, 0x00, 16, 11);\n\n \nMLXSW_ITEM32(emad, latency_tlv, latency_time, 0x04, 0, 32);\n\n \nMLXSW_ITEM32(emad, reg_tlv, type, 0x00, 27, 5);\n\n \nMLXSW_ITEM32(emad, reg_tlv, len, 0x00, 16, 11);\n\n \nMLXSW_ITEM32(emad, end_tlv, type, 0x00, 27, 5);\n\n \nMLXSW_ITEM32(emad, end_tlv, len, 0x00, 16, 11);\n\nenum mlxsw_core_reg_access_type {\n\tMLXSW_CORE_REG_ACCESS_TYPE_QUERY,\n\tMLXSW_CORE_REG_ACCESS_TYPE_WRITE,\n};\n\nstatic inline const char *\nmlxsw_core_reg_access_type_str(enum mlxsw_core_reg_access_type type)\n{\n\tswitch (type) {\n\tcase MLXSW_CORE_REG_ACCESS_TYPE_QUERY:\n\t\treturn \"query\";\n\tcase MLXSW_CORE_REG_ACCESS_TYPE_WRITE:\n\t\treturn \"write\";\n\t}\n\tBUG();\n}\n\nstatic void mlxsw_emad_pack_end_tlv(char *end_tlv)\n{\n\tmlxsw_emad_end_tlv_type_set(end_tlv, MLXSW_EMAD_TLV_TYPE_END);\n\tmlxsw_emad_end_tlv_len_set(end_tlv, MLXSW_EMAD_END_TLV_LEN);\n}\n\nstatic void mlxsw_emad_pack_reg_tlv(char *reg_tlv,\n\t\t\t\t    const struct mlxsw_reg_info *reg,\n\t\t\t\t    char *payload)\n{\n\tmlxsw_emad_reg_tlv_type_set(reg_tlv, MLXSW_EMAD_TLV_TYPE_REG);\n\tmlxsw_emad_reg_tlv_len_set(reg_tlv, reg->len / sizeof(u32) + 1);\n\tmemcpy(reg_tlv + sizeof(u32), payload, reg->len);\n}\n\nstatic void mlxsw_emad_pack_string_tlv(char *string_tlv)\n{\n\tmlxsw_emad_string_tlv_type_set(string_tlv, MLXSW_EMAD_TLV_TYPE_STRING);\n\tmlxsw_emad_string_tlv_len_set(string_tlv, MLXSW_EMAD_STRING_TLV_LEN);\n}\n\nstatic void mlxsw_emad_pack_op_tlv(char *op_tlv,\n\t\t\t\t   const struct mlxsw_reg_info *reg,\n\t\t\t\t   enum mlxsw_core_reg_access_type type,\n\t\t\t\t   u64 tid)\n{\n\tmlxsw_emad_op_tlv_type_set(op_tlv, MLXSW_EMAD_TLV_TYPE_OP);\n\tmlxsw_emad_op_tlv_len_set(op_tlv, MLXSW_EMAD_OP_TLV_LEN);\n\tmlxsw_emad_op_tlv_dr_set(op_tlv, 0);\n\tmlxsw_emad_op_tlv_status_set(op_tlv, 0);\n\tmlxsw_emad_op_tlv_register_id_set(op_tlv, reg->id);\n\tmlxsw_emad_op_tlv_r_set(op_tlv, MLXSW_EMAD_OP_TLV_REQUEST);\n\tif (type == MLXSW_CORE_REG_ACCESS_TYPE_QUERY)\n\t\tmlxsw_emad_op_tlv_method_set(op_tlv,\n\t\t\t\t\t     MLXSW_EMAD_OP_TLV_METHOD_QUERY);\n\telse\n\t\tmlxsw_emad_op_tlv_method_set(op_tlv,\n\t\t\t\t\t     MLXSW_EMAD_OP_TLV_METHOD_WRITE);\n\tmlxsw_emad_op_tlv_class_set(op_tlv,\n\t\t\t\t    MLXSW_EMAD_OP_TLV_CLASS_REG_ACCESS);\n\tmlxsw_emad_op_tlv_tid_set(op_tlv, tid);\n}\n\nstatic void mlxsw_emad_pack_latency_tlv(char *latency_tlv)\n{\n\tmlxsw_emad_latency_tlv_type_set(latency_tlv, MLXSW_EMAD_TLV_TYPE_LATENCY);\n\tmlxsw_emad_latency_tlv_len_set(latency_tlv, MLXSW_EMAD_LATENCY_TLV_LEN);\n}\n\nstatic int mlxsw_emad_construct_eth_hdr(struct sk_buff *skb)\n{\n\tchar *eth_hdr = skb_push(skb, MLXSW_EMAD_ETH_HDR_LEN);\n\n\tmlxsw_emad_eth_hdr_dmac_memcpy_to(eth_hdr, MLXSW_EMAD_EH_DMAC);\n\tmlxsw_emad_eth_hdr_smac_memcpy_to(eth_hdr, MLXSW_EMAD_EH_SMAC);\n\tmlxsw_emad_eth_hdr_ethertype_set(eth_hdr, MLXSW_EMAD_EH_ETHERTYPE);\n\tmlxsw_emad_eth_hdr_mlx_proto_set(eth_hdr, MLXSW_EMAD_EH_MLX_PROTO);\n\tmlxsw_emad_eth_hdr_ver_set(eth_hdr, MLXSW_EMAD_EH_PROTO_VERSION);\n\n\tskb_reset_mac_header(skb);\n\n\treturn 0;\n}\n\nstatic void mlxsw_emad_construct(const struct mlxsw_core *mlxsw_core,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t const struct mlxsw_reg_info *reg,\n\t\t\t\t char *payload,\n\t\t\t\t enum mlxsw_core_reg_access_type type, u64 tid)\n{\n\tchar *buf;\n\n\tbuf = skb_push(skb, MLXSW_EMAD_END_TLV_LEN * sizeof(u32));\n\tmlxsw_emad_pack_end_tlv(buf);\n\n\tbuf = skb_push(skb, reg->len + sizeof(u32));\n\tmlxsw_emad_pack_reg_tlv(buf, reg, payload);\n\n\tif (mlxsw_core->emad.enable_latency_tlv) {\n\t\tbuf = skb_push(skb, MLXSW_EMAD_LATENCY_TLV_LEN * sizeof(u32));\n\t\tmlxsw_emad_pack_latency_tlv(buf);\n\t}\n\n\tif (mlxsw_core->emad.enable_string_tlv) {\n\t\tbuf = skb_push(skb, MLXSW_EMAD_STRING_TLV_LEN * sizeof(u32));\n\t\tmlxsw_emad_pack_string_tlv(buf);\n\t}\n\n\tbuf = skb_push(skb, MLXSW_EMAD_OP_TLV_LEN * sizeof(u32));\n\tmlxsw_emad_pack_op_tlv(buf, reg, type, tid);\n\n\tmlxsw_emad_construct_eth_hdr(skb);\n}\n\nstruct mlxsw_emad_tlv_offsets {\n\tu16 op_tlv;\n\tu16 string_tlv;\n\tu16 latency_tlv;\n\tu16 reg_tlv;\n};\n\nstatic bool mlxsw_emad_tlv_is_string_tlv(const char *tlv)\n{\n\tu8 tlv_type = mlxsw_emad_string_tlv_type_get(tlv);\n\n\treturn tlv_type == MLXSW_EMAD_TLV_TYPE_STRING;\n}\n\nstatic bool mlxsw_emad_tlv_is_latency_tlv(const char *tlv)\n{\n\tu8 tlv_type = mlxsw_emad_latency_tlv_type_get(tlv);\n\n\treturn tlv_type == MLXSW_EMAD_TLV_TYPE_LATENCY;\n}\n\nstatic void mlxsw_emad_tlv_parse(struct sk_buff *skb)\n{\n\tstruct mlxsw_emad_tlv_offsets *offsets =\n\t\t(struct mlxsw_emad_tlv_offsets *) skb->cb;\n\n\toffsets->op_tlv = MLXSW_EMAD_ETH_HDR_LEN;\n\toffsets->string_tlv = 0;\n\toffsets->latency_tlv = 0;\n\n\toffsets->reg_tlv = MLXSW_EMAD_ETH_HDR_LEN +\n\t\t\t   MLXSW_EMAD_OP_TLV_LEN * sizeof(u32);\n\n\t \n\tif (mlxsw_emad_tlv_is_string_tlv(skb->data + offsets->reg_tlv)) {\n\t\toffsets->string_tlv = offsets->reg_tlv;\n\t\toffsets->reg_tlv += MLXSW_EMAD_STRING_TLV_LEN * sizeof(u32);\n\t}\n\n\tif (mlxsw_emad_tlv_is_latency_tlv(skb->data + offsets->reg_tlv)) {\n\t\toffsets->latency_tlv = offsets->reg_tlv;\n\t\toffsets->reg_tlv += MLXSW_EMAD_LATENCY_TLV_LEN * sizeof(u32);\n\t}\n}\n\nstatic char *mlxsw_emad_op_tlv(const struct sk_buff *skb)\n{\n\tstruct mlxsw_emad_tlv_offsets *offsets =\n\t\t(struct mlxsw_emad_tlv_offsets *) skb->cb;\n\n\treturn ((char *) (skb->data + offsets->op_tlv));\n}\n\nstatic char *mlxsw_emad_string_tlv(const struct sk_buff *skb)\n{\n\tstruct mlxsw_emad_tlv_offsets *offsets =\n\t\t(struct mlxsw_emad_tlv_offsets *) skb->cb;\n\n\tif (!offsets->string_tlv)\n\t\treturn NULL;\n\n\treturn ((char *) (skb->data + offsets->string_tlv));\n}\n\nstatic char *mlxsw_emad_reg_tlv(const struct sk_buff *skb)\n{\n\tstruct mlxsw_emad_tlv_offsets *offsets =\n\t\t(struct mlxsw_emad_tlv_offsets *) skb->cb;\n\n\treturn ((char *) (skb->data + offsets->reg_tlv));\n}\n\nstatic char *mlxsw_emad_reg_payload(const char *reg_tlv)\n{\n\treturn ((char *) (reg_tlv + sizeof(u32)));\n}\n\nstatic char *mlxsw_emad_reg_payload_cmd(const char *mbox)\n{\n\treturn ((char *) (mbox + (MLXSW_EMAD_OP_TLV_LEN + 1) * sizeof(u32)));\n}\n\nstatic u64 mlxsw_emad_get_tid(const struct sk_buff *skb)\n{\n\tchar *op_tlv;\n\n\top_tlv = mlxsw_emad_op_tlv(skb);\n\treturn mlxsw_emad_op_tlv_tid_get(op_tlv);\n}\n\nstatic bool mlxsw_emad_is_resp(const struct sk_buff *skb)\n{\n\tchar *op_tlv;\n\n\top_tlv = mlxsw_emad_op_tlv(skb);\n\treturn (mlxsw_emad_op_tlv_r_get(op_tlv) == MLXSW_EMAD_OP_TLV_RESPONSE);\n}\n\nstatic int mlxsw_emad_process_status(char *op_tlv,\n\t\t\t\t     enum mlxsw_emad_op_tlv_status *p_status)\n{\n\t*p_status = mlxsw_emad_op_tlv_status_get(op_tlv);\n\n\tswitch (*p_status) {\n\tcase MLXSW_EMAD_OP_TLV_STATUS_SUCCESS:\n\t\treturn 0;\n\tcase MLXSW_EMAD_OP_TLV_STATUS_BUSY:\n\tcase MLXSW_EMAD_OP_TLV_STATUS_MESSAGE_RECEIPT_ACK:\n\t\treturn -EAGAIN;\n\tcase MLXSW_EMAD_OP_TLV_STATUS_VERSION_NOT_SUPPORTED:\n\tcase MLXSW_EMAD_OP_TLV_STATUS_UNKNOWN_TLV:\n\tcase MLXSW_EMAD_OP_TLV_STATUS_REGISTER_NOT_SUPPORTED:\n\tcase MLXSW_EMAD_OP_TLV_STATUS_CLASS_NOT_SUPPORTED:\n\tcase MLXSW_EMAD_OP_TLV_STATUS_METHOD_NOT_SUPPORTED:\n\tcase MLXSW_EMAD_OP_TLV_STATUS_BAD_PARAMETER:\n\tcase MLXSW_EMAD_OP_TLV_STATUS_RESOURCE_NOT_AVAILABLE:\n\tcase MLXSW_EMAD_OP_TLV_STATUS_INTERNAL_ERROR:\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic int\nmlxsw_emad_process_status_skb(struct sk_buff *skb,\n\t\t\t      enum mlxsw_emad_op_tlv_status *p_status)\n{\n\treturn mlxsw_emad_process_status(mlxsw_emad_op_tlv(skb), p_status);\n}\n\nstruct mlxsw_reg_trans {\n\tstruct list_head list;\n\tstruct list_head bulk_list;\n\tstruct mlxsw_core *core;\n\tstruct sk_buff *tx_skb;\n\tstruct mlxsw_tx_info tx_info;\n\tstruct delayed_work timeout_dw;\n\tunsigned int retries;\n\tu64 tid;\n\tstruct completion completion;\n\tatomic_t active;\n\tmlxsw_reg_trans_cb_t *cb;\n\tunsigned long cb_priv;\n\tconst struct mlxsw_reg_info *reg;\n\tenum mlxsw_core_reg_access_type type;\n\tint err;\n\tchar *emad_err_string;\n\tenum mlxsw_emad_op_tlv_status emad_status;\n\tstruct rcu_head rcu;\n};\n\nstatic void mlxsw_emad_process_string_tlv(const struct sk_buff *skb,\n\t\t\t\t\t  struct mlxsw_reg_trans *trans)\n{\n\tchar *string_tlv;\n\tchar *string;\n\n\tstring_tlv = mlxsw_emad_string_tlv(skb);\n\tif (!string_tlv)\n\t\treturn;\n\n\ttrans->emad_err_string = kzalloc(MLXSW_EMAD_STRING_TLV_STRING_LEN,\n\t\t\t\t\t GFP_ATOMIC);\n\tif (!trans->emad_err_string)\n\t\treturn;\n\n\tstring = mlxsw_emad_string_tlv_string_data(string_tlv);\n\tstrscpy(trans->emad_err_string, string,\n\t\tMLXSW_EMAD_STRING_TLV_STRING_LEN);\n}\n\n#define MLXSW_EMAD_TIMEOUT_DURING_FW_FLASH_MS\t3000\n#define MLXSW_EMAD_TIMEOUT_MS\t\t\t200\n\nstatic void mlxsw_emad_trans_timeout_schedule(struct mlxsw_reg_trans *trans)\n{\n\tunsigned long timeout = msecs_to_jiffies(MLXSW_EMAD_TIMEOUT_MS);\n\n\tif (trans->core->fw_flash_in_progress)\n\t\ttimeout = msecs_to_jiffies(MLXSW_EMAD_TIMEOUT_DURING_FW_FLASH_MS);\n\n\tqueue_delayed_work(trans->core->emad_wq, &trans->timeout_dw,\n\t\t\t   timeout << trans->retries);\n}\n\nstatic int mlxsw_emad_transmit(struct mlxsw_core *mlxsw_core,\n\t\t\t       struct mlxsw_reg_trans *trans)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = skb_clone(trans->tx_skb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\ttrace_devlink_hwmsg(priv_to_devlink(mlxsw_core), false, 0,\n\t\t\t    skb->data + mlxsw_core->driver->txhdr_len,\n\t\t\t    skb->len - mlxsw_core->driver->txhdr_len);\n\n\tatomic_set(&trans->active, 1);\n\terr = mlxsw_core_skb_transmit(mlxsw_core, skb, &trans->tx_info);\n\tif (err) {\n\t\tdev_kfree_skb(skb);\n\t\treturn err;\n\t}\n\tmlxsw_emad_trans_timeout_schedule(trans);\n\treturn 0;\n}\n\nstatic void mlxsw_emad_trans_finish(struct mlxsw_reg_trans *trans, int err)\n{\n\tstruct mlxsw_core *mlxsw_core = trans->core;\n\n\tdev_kfree_skb(trans->tx_skb);\n\tspin_lock_bh(&mlxsw_core->emad.trans_list_lock);\n\tlist_del_rcu(&trans->list);\n\tspin_unlock_bh(&mlxsw_core->emad.trans_list_lock);\n\ttrans->err = err;\n\tcomplete(&trans->completion);\n}\n\nstatic void mlxsw_emad_transmit_retry(struct mlxsw_core *mlxsw_core,\n\t\t\t\t      struct mlxsw_reg_trans *trans)\n{\n\tint err;\n\n\tif (trans->retries < MLXSW_EMAD_MAX_RETRY) {\n\t\ttrans->retries++;\n\t\terr = mlxsw_emad_transmit(trans->core, trans);\n\t\tif (err == 0)\n\t\t\treturn;\n\n\t\tif (!atomic_dec_and_test(&trans->active))\n\t\t\treturn;\n\t} else {\n\t\terr = -EIO;\n\t}\n\tmlxsw_emad_trans_finish(trans, err);\n}\n\nstatic void mlxsw_emad_trans_timeout_work(struct work_struct *work)\n{\n\tstruct mlxsw_reg_trans *trans = container_of(work,\n\t\t\t\t\t\t     struct mlxsw_reg_trans,\n\t\t\t\t\t\t     timeout_dw.work);\n\n\tif (!atomic_dec_and_test(&trans->active))\n\t\treturn;\n\n\tmlxsw_emad_transmit_retry(trans->core, trans);\n}\n\nstatic void mlxsw_emad_process_response(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\tstruct mlxsw_reg_trans *trans,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tint err;\n\n\tif (!atomic_dec_and_test(&trans->active))\n\t\treturn;\n\n\terr = mlxsw_emad_process_status_skb(skb, &trans->emad_status);\n\tif (err == -EAGAIN) {\n\t\tmlxsw_emad_transmit_retry(mlxsw_core, trans);\n\t} else {\n\t\tif (err == 0) {\n\t\t\tchar *reg_tlv = mlxsw_emad_reg_tlv(skb);\n\n\t\t\tif (trans->cb)\n\t\t\t\ttrans->cb(mlxsw_core,\n\t\t\t\t\t  mlxsw_emad_reg_payload(reg_tlv),\n\t\t\t\t\t  trans->reg->len, trans->cb_priv);\n\t\t} else {\n\t\t\tmlxsw_emad_process_string_tlv(skb, trans);\n\t\t}\n\t\tmlxsw_emad_trans_finish(trans, err);\n\t}\n}\n\n \nstatic void mlxsw_emad_rx_listener_func(struct sk_buff *skb, u16 local_port,\n\t\t\t\t\tvoid *priv)\n{\n\tstruct mlxsw_core *mlxsw_core = priv;\n\tstruct mlxsw_reg_trans *trans;\n\n\ttrace_devlink_hwmsg(priv_to_devlink(mlxsw_core), true, 0,\n\t\t\t    skb->data, skb->len);\n\n\tmlxsw_emad_tlv_parse(skb);\n\n\tif (!mlxsw_emad_is_resp(skb))\n\t\tgoto free_skb;\n\n\tlist_for_each_entry_rcu(trans, &mlxsw_core->emad.trans_list, list) {\n\t\tif (mlxsw_emad_get_tid(skb) == trans->tid) {\n\t\t\tmlxsw_emad_process_response(mlxsw_core, trans, skb);\n\t\t\tbreak;\n\t\t}\n\t}\n\nfree_skb:\n\tdev_kfree_skb(skb);\n}\n\nstatic const struct mlxsw_listener mlxsw_emad_rx_listener =\n\tMLXSW_RXL(mlxsw_emad_rx_listener_func, ETHEMAD, TRAP_TO_CPU, false,\n\t\t  EMAD, DISCARD);\n\nstatic int mlxsw_emad_tlv_enable(struct mlxsw_core *mlxsw_core)\n{\n\tchar mgir_pl[MLXSW_REG_MGIR_LEN];\n\tbool string_tlv, latency_tlv;\n\tint err;\n\n\tmlxsw_reg_mgir_pack(mgir_pl);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mgir), mgir_pl);\n\tif (err)\n\t\treturn err;\n\n\tstring_tlv = mlxsw_reg_mgir_fw_info_string_tlv_get(mgir_pl);\n\tmlxsw_core->emad.enable_string_tlv = string_tlv;\n\n\tlatency_tlv = mlxsw_reg_mgir_fw_info_latency_tlv_get(mgir_pl);\n\tmlxsw_core->emad.enable_latency_tlv = latency_tlv;\n\n\treturn 0;\n}\n\nstatic void mlxsw_emad_tlv_disable(struct mlxsw_core *mlxsw_core)\n{\n\tmlxsw_core->emad.enable_latency_tlv = false;\n\tmlxsw_core->emad.enable_string_tlv = false;\n}\n\nstatic int mlxsw_emad_init(struct mlxsw_core *mlxsw_core)\n{\n\tstruct workqueue_struct *emad_wq;\n\tu64 tid;\n\tint err;\n\n\tif (!(mlxsw_core->bus->features & MLXSW_BUS_F_TXRX))\n\t\treturn 0;\n\n\temad_wq = alloc_workqueue(\"mlxsw_core_emad\", 0, 0);\n\tif (!emad_wq)\n\t\treturn -ENOMEM;\n\tmlxsw_core->emad_wq = emad_wq;\n\n\t \n\tget_random_bytes(&tid, 4);\n\ttid <<= 32;\n\tatomic64_set(&mlxsw_core->emad.tid, tid);\n\n\tINIT_LIST_HEAD(&mlxsw_core->emad.trans_list);\n\tspin_lock_init(&mlxsw_core->emad.trans_list_lock);\n\n\terr = mlxsw_core_trap_register(mlxsw_core, &mlxsw_emad_rx_listener,\n\t\t\t\t       mlxsw_core);\n\tif (err)\n\t\tgoto err_trap_register;\n\n\terr = mlxsw_emad_tlv_enable(mlxsw_core);\n\tif (err)\n\t\tgoto err_emad_tlv_enable;\n\n\tmlxsw_core->emad.use_emad = true;\n\n\treturn 0;\n\nerr_emad_tlv_enable:\n\tmlxsw_core_trap_unregister(mlxsw_core, &mlxsw_emad_rx_listener,\n\t\t\t\t   mlxsw_core);\nerr_trap_register:\n\tdestroy_workqueue(mlxsw_core->emad_wq);\n\treturn err;\n}\n\nstatic void mlxsw_emad_fini(struct mlxsw_core *mlxsw_core)\n{\n\n\tif (!(mlxsw_core->bus->features & MLXSW_BUS_F_TXRX))\n\t\treturn;\n\n\tmlxsw_core->emad.use_emad = false;\n\tmlxsw_emad_tlv_disable(mlxsw_core);\n\tmlxsw_core_trap_unregister(mlxsw_core, &mlxsw_emad_rx_listener,\n\t\t\t\t   mlxsw_core);\n\tdestroy_workqueue(mlxsw_core->emad_wq);\n}\n\nstatic struct sk_buff *mlxsw_emad_alloc(const struct mlxsw_core *mlxsw_core,\n\t\t\t\t\tu16 reg_len)\n{\n\tstruct sk_buff *skb;\n\tu16 emad_len;\n\n\temad_len = (reg_len + sizeof(u32) + MLXSW_EMAD_ETH_HDR_LEN +\n\t\t    (MLXSW_EMAD_OP_TLV_LEN + MLXSW_EMAD_END_TLV_LEN) *\n\t\t    sizeof(u32) + mlxsw_core->driver->txhdr_len);\n\tif (mlxsw_core->emad.enable_string_tlv)\n\t\temad_len += MLXSW_EMAD_STRING_TLV_LEN * sizeof(u32);\n\tif (mlxsw_core->emad.enable_latency_tlv)\n\t\temad_len +=  MLXSW_EMAD_LATENCY_TLV_LEN * sizeof(u32);\n\tif (emad_len > MLXSW_EMAD_MAX_FRAME_LEN)\n\t\treturn NULL;\n\n\tskb = netdev_alloc_skb(NULL, emad_len);\n\tif (!skb)\n\t\treturn NULL;\n\tmemset(skb->data, 0, emad_len);\n\tskb_reserve(skb, emad_len);\n\n\treturn skb;\n}\n\nstatic int mlxsw_emad_reg_access(struct mlxsw_core *mlxsw_core,\n\t\t\t\t const struct mlxsw_reg_info *reg,\n\t\t\t\t char *payload,\n\t\t\t\t enum mlxsw_core_reg_access_type type,\n\t\t\t\t struct mlxsw_reg_trans *trans,\n\t\t\t\t struct list_head *bulk_list,\n\t\t\t\t mlxsw_reg_trans_cb_t *cb,\n\t\t\t\t unsigned long cb_priv, u64 tid)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tdev_dbg(mlxsw_core->bus_info->dev, \"EMAD reg access (tid=%llx,reg_id=%x(%s),type=%s)\\n\",\n\t\ttid, reg->id, mlxsw_reg_id_str(reg->id),\n\t\tmlxsw_core_reg_access_type_str(type));\n\n\tskb = mlxsw_emad_alloc(mlxsw_core, reg->len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tlist_add_tail(&trans->bulk_list, bulk_list);\n\ttrans->core = mlxsw_core;\n\ttrans->tx_skb = skb;\n\ttrans->tx_info.local_port = MLXSW_PORT_CPU_PORT;\n\ttrans->tx_info.is_emad = true;\n\tINIT_DELAYED_WORK(&trans->timeout_dw, mlxsw_emad_trans_timeout_work);\n\ttrans->tid = tid;\n\tinit_completion(&trans->completion);\n\ttrans->cb = cb;\n\ttrans->cb_priv = cb_priv;\n\ttrans->reg = reg;\n\ttrans->type = type;\n\n\tmlxsw_emad_construct(mlxsw_core, skb, reg, payload, type, trans->tid);\n\tmlxsw_core->driver->txhdr_construct(skb, &trans->tx_info);\n\n\tspin_lock_bh(&mlxsw_core->emad.trans_list_lock);\n\tlist_add_tail_rcu(&trans->list, &mlxsw_core->emad.trans_list);\n\tspin_unlock_bh(&mlxsw_core->emad.trans_list_lock);\n\terr = mlxsw_emad_transmit(mlxsw_core, trans);\n\tif (err)\n\t\tgoto err_out;\n\treturn 0;\n\nerr_out:\n\tspin_lock_bh(&mlxsw_core->emad.trans_list_lock);\n\tlist_del_rcu(&trans->list);\n\tspin_unlock_bh(&mlxsw_core->emad.trans_list_lock);\n\tlist_del(&trans->bulk_list);\n\tdev_kfree_skb(trans->tx_skb);\n\treturn err;\n}\n\n \n\nint mlxsw_core_driver_register(struct mlxsw_driver *mlxsw_driver)\n{\n\tspin_lock(&mlxsw_core_driver_list_lock);\n\tlist_add_tail(&mlxsw_driver->list, &mlxsw_core_driver_list);\n\tspin_unlock(&mlxsw_core_driver_list_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_core_driver_register);\n\nvoid mlxsw_core_driver_unregister(struct mlxsw_driver *mlxsw_driver)\n{\n\tspin_lock(&mlxsw_core_driver_list_lock);\n\tlist_del(&mlxsw_driver->list);\n\tspin_unlock(&mlxsw_core_driver_list_lock);\n}\nEXPORT_SYMBOL(mlxsw_core_driver_unregister);\n\nstatic struct mlxsw_driver *__driver_find(const char *kind)\n{\n\tstruct mlxsw_driver *mlxsw_driver;\n\n\tlist_for_each_entry(mlxsw_driver, &mlxsw_core_driver_list, list) {\n\t\tif (strcmp(mlxsw_driver->kind, kind) == 0)\n\t\t\treturn mlxsw_driver;\n\t}\n\treturn NULL;\n}\n\nstatic struct mlxsw_driver *mlxsw_core_driver_get(const char *kind)\n{\n\tstruct mlxsw_driver *mlxsw_driver;\n\n\tspin_lock(&mlxsw_core_driver_list_lock);\n\tmlxsw_driver = __driver_find(kind);\n\tspin_unlock(&mlxsw_core_driver_list_lock);\n\treturn mlxsw_driver;\n}\n\nint mlxsw_core_fw_flash(struct mlxsw_core *mlxsw_core,\n\t\t\tstruct mlxfw_dev *mlxfw_dev,\n\t\t\tconst struct firmware *firmware,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tmlxsw_core->fw_flash_in_progress = true;\n\terr = mlxfw_firmware_flash(mlxfw_dev, firmware, extack);\n\tmlxsw_core->fw_flash_in_progress = false;\n\n\treturn err;\n}\n\nstruct mlxsw_core_fw_info {\n\tstruct mlxfw_dev mlxfw_dev;\n\tstruct mlxsw_core *mlxsw_core;\n};\n\nstatic int mlxsw_core_fw_component_query(struct mlxfw_dev *mlxfw_dev,\n\t\t\t\t\t u16 component_index, u32 *p_max_size,\n\t\t\t\t\t u8 *p_align_bits, u16 *p_max_write_size)\n{\n\tstruct mlxsw_core_fw_info *mlxsw_core_fw_info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_core_fw_info, mlxfw_dev);\n\tstruct mlxsw_core *mlxsw_core = mlxsw_core_fw_info->mlxsw_core;\n\tchar mcqi_pl[MLXSW_REG_MCQI_LEN];\n\tint err;\n\n\tmlxsw_reg_mcqi_pack(mcqi_pl, component_index);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mcqi), mcqi_pl);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_mcqi_unpack(mcqi_pl, p_max_size, p_align_bits, p_max_write_size);\n\n\t*p_align_bits = max_t(u8, *p_align_bits, 2);\n\t*p_max_write_size = min_t(u16, *p_max_write_size, MLXSW_REG_MCDA_MAX_DATA_LEN);\n\treturn 0;\n}\n\nstatic int mlxsw_core_fw_fsm_lock(struct mlxfw_dev *mlxfw_dev, u32 *fwhandle)\n{\n\tstruct mlxsw_core_fw_info *mlxsw_core_fw_info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_core_fw_info, mlxfw_dev);\n\tstruct mlxsw_core *mlxsw_core = mlxsw_core_fw_info->mlxsw_core;\n\tchar mcc_pl[MLXSW_REG_MCC_LEN];\n\tu8 control_state;\n\tint err;\n\n\tmlxsw_reg_mcc_pack(mcc_pl, 0, 0, 0, 0);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mcc), mcc_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mcc_unpack(mcc_pl, fwhandle, NULL, &control_state);\n\tif (control_state != MLXFW_FSM_STATE_IDLE)\n\t\treturn -EBUSY;\n\n\tmlxsw_reg_mcc_pack(mcc_pl, MLXSW_REG_MCC_INSTRUCTION_LOCK_UPDATE_HANDLE, 0, *fwhandle, 0);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mcc), mcc_pl);\n}\n\nstatic int mlxsw_core_fw_fsm_component_update(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\n\t\t\t\t\t      u16 component_index, u32 component_size)\n{\n\tstruct mlxsw_core_fw_info *mlxsw_core_fw_info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_core_fw_info, mlxfw_dev);\n\tstruct mlxsw_core *mlxsw_core = mlxsw_core_fw_info->mlxsw_core;\n\tchar mcc_pl[MLXSW_REG_MCC_LEN];\n\n\tmlxsw_reg_mcc_pack(mcc_pl, MLXSW_REG_MCC_INSTRUCTION_UPDATE_COMPONENT,\n\t\t\t   component_index, fwhandle, component_size);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mcc), mcc_pl);\n}\n\nstatic int mlxsw_core_fw_fsm_block_download(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\n\t\t\t\t\t    u8 *data, u16 size, u32 offset)\n{\n\tstruct mlxsw_core_fw_info *mlxsw_core_fw_info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_core_fw_info, mlxfw_dev);\n\tstruct mlxsw_core *mlxsw_core = mlxsw_core_fw_info->mlxsw_core;\n\tchar mcda_pl[MLXSW_REG_MCDA_LEN];\n\n\tmlxsw_reg_mcda_pack(mcda_pl, fwhandle, offset, size, data);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mcda), mcda_pl);\n}\n\nstatic int mlxsw_core_fw_fsm_component_verify(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\n\t\t\t\t\t      u16 component_index)\n{\n\tstruct mlxsw_core_fw_info *mlxsw_core_fw_info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_core_fw_info, mlxfw_dev);\n\tstruct mlxsw_core *mlxsw_core = mlxsw_core_fw_info->mlxsw_core;\n\tchar mcc_pl[MLXSW_REG_MCC_LEN];\n\n\tmlxsw_reg_mcc_pack(mcc_pl, MLXSW_REG_MCC_INSTRUCTION_VERIFY_COMPONENT,\n\t\t\t   component_index, fwhandle, 0);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mcc), mcc_pl);\n}\n\nstatic int mlxsw_core_fw_fsm_activate(struct mlxfw_dev *mlxfw_dev, u32 fwhandle)\n{\n\tstruct mlxsw_core_fw_info *mlxsw_core_fw_info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_core_fw_info, mlxfw_dev);\n\tstruct mlxsw_core *mlxsw_core = mlxsw_core_fw_info->mlxsw_core;\n\tchar mcc_pl[MLXSW_REG_MCC_LEN];\n\n\tmlxsw_reg_mcc_pack(mcc_pl, MLXSW_REG_MCC_INSTRUCTION_ACTIVATE, 0, fwhandle, 0);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mcc), mcc_pl);\n}\n\nstatic int mlxsw_core_fw_fsm_query_state(struct mlxfw_dev *mlxfw_dev, u32 fwhandle,\n\t\t\t\t\t enum mlxfw_fsm_state *fsm_state,\n\t\t\t\t\t enum mlxfw_fsm_state_err *fsm_state_err)\n{\n\tstruct mlxsw_core_fw_info *mlxsw_core_fw_info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_core_fw_info, mlxfw_dev);\n\tstruct mlxsw_core *mlxsw_core = mlxsw_core_fw_info->mlxsw_core;\n\tchar mcc_pl[MLXSW_REG_MCC_LEN];\n\tu8 control_state;\n\tu8 error_code;\n\tint err;\n\n\tmlxsw_reg_mcc_pack(mcc_pl, 0, 0, fwhandle, 0);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mcc), mcc_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mcc_unpack(mcc_pl, NULL, &error_code, &control_state);\n\t*fsm_state = control_state;\n\t*fsm_state_err = min_t(enum mlxfw_fsm_state_err, error_code, MLXFW_FSM_STATE_ERR_MAX);\n\treturn 0;\n}\n\nstatic void mlxsw_core_fw_fsm_cancel(struct mlxfw_dev *mlxfw_dev, u32 fwhandle)\n{\n\tstruct mlxsw_core_fw_info *mlxsw_core_fw_info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_core_fw_info, mlxfw_dev);\n\tstruct mlxsw_core *mlxsw_core = mlxsw_core_fw_info->mlxsw_core;\n\tchar mcc_pl[MLXSW_REG_MCC_LEN];\n\n\tmlxsw_reg_mcc_pack(mcc_pl, MLXSW_REG_MCC_INSTRUCTION_CANCEL, 0, fwhandle, 0);\n\tmlxsw_reg_write(mlxsw_core, MLXSW_REG(mcc), mcc_pl);\n}\n\nstatic void mlxsw_core_fw_fsm_release(struct mlxfw_dev *mlxfw_dev, u32 fwhandle)\n{\n\tstruct mlxsw_core_fw_info *mlxsw_core_fw_info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_core_fw_info, mlxfw_dev);\n\tstruct mlxsw_core *mlxsw_core = mlxsw_core_fw_info->mlxsw_core;\n\tchar mcc_pl[MLXSW_REG_MCC_LEN];\n\n\tmlxsw_reg_mcc_pack(mcc_pl, MLXSW_REG_MCC_INSTRUCTION_RELEASE_UPDATE_HANDLE, 0, fwhandle, 0);\n\tmlxsw_reg_write(mlxsw_core, MLXSW_REG(mcc), mcc_pl);\n}\n\nstatic const struct mlxfw_dev_ops mlxsw_core_fw_mlxsw_dev_ops = {\n\t.component_query\t= mlxsw_core_fw_component_query,\n\t.fsm_lock\t\t= mlxsw_core_fw_fsm_lock,\n\t.fsm_component_update\t= mlxsw_core_fw_fsm_component_update,\n\t.fsm_block_download\t= mlxsw_core_fw_fsm_block_download,\n\t.fsm_component_verify\t= mlxsw_core_fw_fsm_component_verify,\n\t.fsm_activate\t\t= mlxsw_core_fw_fsm_activate,\n\t.fsm_query_state\t= mlxsw_core_fw_fsm_query_state,\n\t.fsm_cancel\t\t= mlxsw_core_fw_fsm_cancel,\n\t.fsm_release\t\t= mlxsw_core_fw_fsm_release,\n};\n\nstatic int mlxsw_core_dev_fw_flash(struct mlxsw_core *mlxsw_core,\n\t\t\t\t   const struct firmware *firmware,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core_fw_info mlxsw_core_fw_info = {\n\t\t.mlxfw_dev = {\n\t\t\t.ops = &mlxsw_core_fw_mlxsw_dev_ops,\n\t\t\t.psid = mlxsw_core->bus_info->psid,\n\t\t\t.psid_size = strlen(mlxsw_core->bus_info->psid),\n\t\t\t.devlink = priv_to_devlink(mlxsw_core),\n\t\t},\n\t\t.mlxsw_core = mlxsw_core\n\t};\n\n\treturn mlxsw_core_fw_flash(mlxsw_core, &mlxsw_core_fw_info.mlxfw_dev,\n\t\t\t\t   firmware, extack);\n}\n\nstatic int mlxsw_core_fw_rev_validate(struct mlxsw_core *mlxsw_core,\n\t\t\t\t      const struct mlxsw_bus_info *mlxsw_bus_info,\n\t\t\t\t      const struct mlxsw_fw_rev *req_rev,\n\t\t\t\t      const char *filename)\n{\n\tconst struct mlxsw_fw_rev *rev = &mlxsw_bus_info->fw_rev;\n\tunion devlink_param_value value;\n\tconst struct firmware *firmware;\n\tint err;\n\n\t \n\tif (!req_rev || !filename)\n\t\treturn 0;\n\n\t \n\terr = devl_param_driverinit_value_get(priv_to_devlink(mlxsw_core),\n\t\t\t\t\t      DEVLINK_PARAM_GENERIC_ID_FW_LOAD_POLICY,\n\t\t\t\t\t      &value);\n\tif (err)\n\t\treturn err;\n\tif (value.vu8 == DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_FLASH)\n\t\treturn 0;\n\n\t \n\tif (rev->major != req_rev->major) {\n\t\tWARN(1, \"Mismatch in major FW version [%d:%d] is never expected; Please contact support\\n\",\n\t\t     rev->major, req_rev->major);\n\t\treturn -EINVAL;\n\t}\n\tif (mlxsw_core_fw_rev_minor_subminor_validate(rev, req_rev))\n\t\treturn 0;\n\n\tdev_err(mlxsw_bus_info->dev, \"The firmware version %d.%d.%d is incompatible with the driver (required >= %d.%d.%d)\\n\",\n\t\trev->major, rev->minor, rev->subminor, req_rev->major,\n\t\treq_rev->minor, req_rev->subminor);\n\tdev_info(mlxsw_bus_info->dev, \"Flashing firmware using file %s\\n\", filename);\n\n\terr = request_firmware_direct(&firmware, filename, mlxsw_bus_info->dev);\n\tif (err) {\n\t\tdev_err(mlxsw_bus_info->dev, \"Could not request firmware file %s\\n\", filename);\n\t\treturn err;\n\t}\n\n\terr = mlxsw_core_dev_fw_flash(mlxsw_core, firmware, NULL);\n\trelease_firmware(firmware);\n\tif (err)\n\t\tdev_err(mlxsw_bus_info->dev, \"Could not upgrade firmware\\n\");\n\n\t \n\tif (rev->minor >= req_rev->can_reset_minor)\n\t\treturn err ? err : -EAGAIN;\n\telse\n\t\treturn 0;\n}\n\nstatic int mlxsw_core_fw_flash_update(struct mlxsw_core *mlxsw_core,\n\t\t\t\t      struct devlink_flash_update_params *params,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn mlxsw_core_dev_fw_flash(mlxsw_core, params->fw, extack);\n}\n\nstatic int mlxsw_core_devlink_param_fw_load_policy_validate(struct devlink *devlink, u32 id,\n\t\t\t\t\t\t\t    union devlink_param_value val,\n\t\t\t\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (val.vu8 != DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_DRIVER &&\n\t    val.vu8 != DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_FLASH) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"'fw_load_policy' must be 'driver' or 'flash'\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct devlink_param mlxsw_core_fw_devlink_params[] = {\n\tDEVLINK_PARAM_GENERIC(FW_LOAD_POLICY, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT), NULL, NULL,\n\t\t\t      mlxsw_core_devlink_param_fw_load_policy_validate),\n};\n\nstatic int mlxsw_core_fw_params_register(struct mlxsw_core *mlxsw_core)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tunion devlink_param_value value;\n\tint err;\n\n\terr = devl_params_register(devlink, mlxsw_core_fw_devlink_params,\n\t\t\t\t   ARRAY_SIZE(mlxsw_core_fw_devlink_params));\n\tif (err)\n\t\treturn err;\n\n\tvalue.vu8 = DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_DRIVER;\n\tdevl_param_driverinit_value_set(devlink,\n\t\t\t\t\tDEVLINK_PARAM_GENERIC_ID_FW_LOAD_POLICY,\n\t\t\t\t\tvalue);\n\treturn 0;\n}\n\nstatic void mlxsw_core_fw_params_unregister(struct mlxsw_core *mlxsw_core)\n{\n\tdevl_params_unregister(priv_to_devlink(mlxsw_core), mlxsw_core_fw_devlink_params,\n\t\t\t       ARRAY_SIZE(mlxsw_core_fw_devlink_params));\n}\n\nstatic void *__dl_port(struct devlink_port *devlink_port)\n{\n\treturn container_of(devlink_port, struct mlxsw_core_port, devlink_port);\n}\n\nstatic int mlxsw_devlink_port_split(struct devlink *devlink,\n\t\t\t\t    struct devlink_port *port,\n\t\t\t\t    unsigned int count,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core_port *mlxsw_core_port = __dl_port(port);\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\n\tif (!mlxsw_core->driver->port_split)\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_core->driver->port_split(mlxsw_core,\n\t\t\t\t\t      mlxsw_core_port->local_port,\n\t\t\t\t\t      count, extack);\n}\n\nstatic int mlxsw_devlink_port_unsplit(struct devlink *devlink,\n\t\t\t\t      struct devlink_port *port,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core_port *mlxsw_core_port = __dl_port(port);\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\n\tif (!mlxsw_core->driver->port_unsplit)\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_core->driver->port_unsplit(mlxsw_core,\n\t\t\t\t\t\tmlxsw_core_port->local_port,\n\t\t\t\t\t\textack);\n}\n\nstatic int\nmlxsw_devlink_sb_pool_get(struct devlink *devlink,\n\t\t\t  unsigned int sb_index, u16 pool_index,\n\t\t\t  struct devlink_sb_pool_info *pool_info)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\n\tif (!mlxsw_driver->sb_pool_get)\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->sb_pool_get(mlxsw_core, sb_index,\n\t\t\t\t\t pool_index, pool_info);\n}\n\nstatic int\nmlxsw_devlink_sb_pool_set(struct devlink *devlink,\n\t\t\t  unsigned int sb_index, u16 pool_index, u32 size,\n\t\t\t  enum devlink_sb_threshold_type threshold_type,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\n\tif (!mlxsw_driver->sb_pool_set)\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->sb_pool_set(mlxsw_core, sb_index,\n\t\t\t\t\t pool_index, size, threshold_type,\n\t\t\t\t\t extack);\n}\n\nstatic int mlxsw_devlink_sb_port_pool_get(struct devlink_port *devlink_port,\n\t\t\t\t\t  unsigned int sb_index, u16 pool_index,\n\t\t\t\t\t  u32 *p_threshold)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink_port->devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\tstruct mlxsw_core_port *mlxsw_core_port = __dl_port(devlink_port);\n\n\tif (!mlxsw_driver->sb_port_pool_get ||\n\t    !mlxsw_core_port_check(mlxsw_core_port))\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->sb_port_pool_get(mlxsw_core_port, sb_index,\n\t\t\t\t\t      pool_index, p_threshold);\n}\n\nstatic int mlxsw_devlink_sb_port_pool_set(struct devlink_port *devlink_port,\n\t\t\t\t\t  unsigned int sb_index, u16 pool_index,\n\t\t\t\t\t  u32 threshold,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink_port->devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\tstruct mlxsw_core_port *mlxsw_core_port = __dl_port(devlink_port);\n\n\tif (!mlxsw_driver->sb_port_pool_set ||\n\t    !mlxsw_core_port_check(mlxsw_core_port))\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->sb_port_pool_set(mlxsw_core_port, sb_index,\n\t\t\t\t\t      pool_index, threshold, extack);\n}\n\nstatic int\nmlxsw_devlink_sb_tc_pool_bind_get(struct devlink_port *devlink_port,\n\t\t\t\t  unsigned int sb_index, u16 tc_index,\n\t\t\t\t  enum devlink_sb_pool_type pool_type,\n\t\t\t\t  u16 *p_pool_index, u32 *p_threshold)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink_port->devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\tstruct mlxsw_core_port *mlxsw_core_port = __dl_port(devlink_port);\n\n\tif (!mlxsw_driver->sb_tc_pool_bind_get ||\n\t    !mlxsw_core_port_check(mlxsw_core_port))\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->sb_tc_pool_bind_get(mlxsw_core_port, sb_index,\n\t\t\t\t\t\t tc_index, pool_type,\n\t\t\t\t\t\t p_pool_index, p_threshold);\n}\n\nstatic int\nmlxsw_devlink_sb_tc_pool_bind_set(struct devlink_port *devlink_port,\n\t\t\t\t  unsigned int sb_index, u16 tc_index,\n\t\t\t\t  enum devlink_sb_pool_type pool_type,\n\t\t\t\t  u16 pool_index, u32 threshold,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink_port->devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\tstruct mlxsw_core_port *mlxsw_core_port = __dl_port(devlink_port);\n\n\tif (!mlxsw_driver->sb_tc_pool_bind_set ||\n\t    !mlxsw_core_port_check(mlxsw_core_port))\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->sb_tc_pool_bind_set(mlxsw_core_port, sb_index,\n\t\t\t\t\t\t tc_index, pool_type,\n\t\t\t\t\t\t pool_index, threshold, extack);\n}\n\nstatic int mlxsw_devlink_sb_occ_snapshot(struct devlink *devlink,\n\t\t\t\t\t unsigned int sb_index)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\n\tif (!mlxsw_driver->sb_occ_snapshot)\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->sb_occ_snapshot(mlxsw_core, sb_index);\n}\n\nstatic int mlxsw_devlink_sb_occ_max_clear(struct devlink *devlink,\n\t\t\t\t\t  unsigned int sb_index)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\n\tif (!mlxsw_driver->sb_occ_max_clear)\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->sb_occ_max_clear(mlxsw_core, sb_index);\n}\n\nstatic int\nmlxsw_devlink_sb_occ_port_pool_get(struct devlink_port *devlink_port,\n\t\t\t\t   unsigned int sb_index, u16 pool_index,\n\t\t\t\t   u32 *p_cur, u32 *p_max)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink_port->devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\tstruct mlxsw_core_port *mlxsw_core_port = __dl_port(devlink_port);\n\n\tif (!mlxsw_driver->sb_occ_port_pool_get ||\n\t    !mlxsw_core_port_check(mlxsw_core_port))\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->sb_occ_port_pool_get(mlxsw_core_port, sb_index,\n\t\t\t\t\t\t  pool_index, p_cur, p_max);\n}\n\nstatic int\nmlxsw_devlink_sb_occ_tc_port_bind_get(struct devlink_port *devlink_port,\n\t\t\t\t      unsigned int sb_index, u16 tc_index,\n\t\t\t\t      enum devlink_sb_pool_type pool_type,\n\t\t\t\t      u32 *p_cur, u32 *p_max)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink_port->devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\tstruct mlxsw_core_port *mlxsw_core_port = __dl_port(devlink_port);\n\n\tif (!mlxsw_driver->sb_occ_tc_port_bind_get ||\n\t    !mlxsw_core_port_check(mlxsw_core_port))\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->sb_occ_tc_port_bind_get(mlxsw_core_port,\n\t\t\t\t\t\t     sb_index, tc_index,\n\t\t\t\t\t\t     pool_type, p_cur, p_max);\n}\n\nstatic int\nmlxsw_devlink_info_get(struct devlink *devlink, struct devlink_info_req *req,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tchar fw_info_psid[MLXSW_REG_MGIR_FW_INFO_PSID_SIZE];\n\tu32 hw_rev, fw_major, fw_minor, fw_sub_minor;\n\tchar mgir_pl[MLXSW_REG_MGIR_LEN];\n\tchar buf[32];\n\tint err;\n\n\tmlxsw_reg_mgir_pack(mgir_pl);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mgir), mgir_pl);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_mgir_unpack(mgir_pl, &hw_rev, fw_info_psid, &fw_major,\n\t\t\t      &fw_minor, &fw_sub_minor);\n\n\tsprintf(buf, \"%X\", hw_rev);\n\terr = devlink_info_version_fixed_put(req, \"hw.revision\", buf);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_info_version_fixed_put(req,\n\t\t\t\t\t     DEVLINK_INFO_VERSION_GENERIC_FW_PSID,\n\t\t\t\t\t     fw_info_psid);\n\tif (err)\n\t\treturn err;\n\n\tsprintf(buf, \"%d.%d.%d\", fw_major, fw_minor, fw_sub_minor);\n\terr = devlink_info_version_running_put(req, \"fw.version\", buf);\n\tif (err)\n\t\treturn err;\n\n\treturn devlink_info_version_running_put(req,\n\t\t\t\t\t\tDEVLINK_INFO_VERSION_GENERIC_FW,\n\t\t\t\t\t\tbuf);\n}\n\nstatic int\nmlxsw_devlink_core_bus_device_reload_down(struct devlink *devlink,\n\t\t\t\t\t  bool netns_change, enum devlink_reload_action action,\n\t\t\t\t\t  enum devlink_reload_limit limit,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\n\tif (!(mlxsw_core->bus->features & MLXSW_BUS_F_RESET))\n\t\treturn -EOPNOTSUPP;\n\n\tmlxsw_core_bus_device_unregister(mlxsw_core, true);\n\treturn 0;\n}\n\nstatic int\nmlxsw_devlink_core_bus_device_reload_up(struct devlink *devlink, enum devlink_reload_action action,\n\t\t\t\t\tenum devlink_reload_limit limit, u32 *actions_performed,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tint err;\n\n\t*actions_performed = BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT) |\n\t\t\t     BIT(DEVLINK_RELOAD_ACTION_FW_ACTIVATE);\n\terr = mlxsw_core_bus_device_register(mlxsw_core->bus_info,\n\t\t\t\t\t     mlxsw_core->bus,\n\t\t\t\t\t     mlxsw_core->bus_priv, true,\n\t\t\t\t\t     devlink, extack);\n\treturn err;\n}\n\nstatic int mlxsw_devlink_flash_update(struct devlink *devlink,\n\t\t\t\t      struct devlink_flash_update_params *params,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\n\treturn mlxsw_core_fw_flash_update(mlxsw_core, params, extack);\n}\n\nstatic int mlxsw_devlink_trap_init(struct devlink *devlink,\n\t\t\t\t   const struct devlink_trap *trap,\n\t\t\t\t   void *trap_ctx)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\n\tif (!mlxsw_driver->trap_init)\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->trap_init(mlxsw_core, trap, trap_ctx);\n}\n\nstatic void mlxsw_devlink_trap_fini(struct devlink *devlink,\n\t\t\t\t    const struct devlink_trap *trap,\n\t\t\t\t    void *trap_ctx)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\n\tif (!mlxsw_driver->trap_fini)\n\t\treturn;\n\tmlxsw_driver->trap_fini(mlxsw_core, trap, trap_ctx);\n}\n\nstatic int mlxsw_devlink_trap_action_set(struct devlink *devlink,\n\t\t\t\t\t const struct devlink_trap *trap,\n\t\t\t\t\t enum devlink_trap_action action,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\n\tif (!mlxsw_driver->trap_action_set)\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->trap_action_set(mlxsw_core, trap, action, extack);\n}\n\nstatic int\nmlxsw_devlink_trap_group_init(struct devlink *devlink,\n\t\t\t      const struct devlink_trap_group *group)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\n\tif (!mlxsw_driver->trap_group_init)\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->trap_group_init(mlxsw_core, group);\n}\n\nstatic int\nmlxsw_devlink_trap_group_set(struct devlink *devlink,\n\t\t\t     const struct devlink_trap_group *group,\n\t\t\t     const struct devlink_trap_policer *policer,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\n\tif (!mlxsw_driver->trap_group_set)\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->trap_group_set(mlxsw_core, group, policer, extack);\n}\n\nstatic int\nmlxsw_devlink_trap_policer_init(struct devlink *devlink,\n\t\t\t\tconst struct devlink_trap_policer *policer)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\n\tif (!mlxsw_driver->trap_policer_init)\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->trap_policer_init(mlxsw_core, policer);\n}\n\nstatic void\nmlxsw_devlink_trap_policer_fini(struct devlink *devlink,\n\t\t\t\tconst struct devlink_trap_policer *policer)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\n\tif (!mlxsw_driver->trap_policer_fini)\n\t\treturn;\n\tmlxsw_driver->trap_policer_fini(mlxsw_core, policer);\n}\n\nstatic int\nmlxsw_devlink_trap_policer_set(struct devlink *devlink,\n\t\t\t       const struct devlink_trap_policer *policer,\n\t\t\t       u64 rate, u64 burst,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\n\tif (!mlxsw_driver->trap_policer_set)\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->trap_policer_set(mlxsw_core, policer, rate, burst,\n\t\t\t\t\t      extack);\n}\n\nstatic int\nmlxsw_devlink_trap_policer_counter_get(struct devlink *devlink,\n\t\t\t\t       const struct devlink_trap_policer *policer,\n\t\t\t\t       u64 *p_drops)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;\n\n\tif (!mlxsw_driver->trap_policer_counter_get)\n\t\treturn -EOPNOTSUPP;\n\treturn mlxsw_driver->trap_policer_counter_get(mlxsw_core, policer,\n\t\t\t\t\t\t      p_drops);\n}\n\nstatic const struct devlink_ops mlxsw_devlink_ops = {\n\t.reload_actions\t\t= BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT) |\n\t\t\t\t  BIT(DEVLINK_RELOAD_ACTION_FW_ACTIVATE),\n\t.reload_down\t\t= mlxsw_devlink_core_bus_device_reload_down,\n\t.reload_up\t\t= mlxsw_devlink_core_bus_device_reload_up,\n\t.sb_pool_get\t\t\t= mlxsw_devlink_sb_pool_get,\n\t.sb_pool_set\t\t\t= mlxsw_devlink_sb_pool_set,\n\t.sb_port_pool_get\t\t= mlxsw_devlink_sb_port_pool_get,\n\t.sb_port_pool_set\t\t= mlxsw_devlink_sb_port_pool_set,\n\t.sb_tc_pool_bind_get\t\t= mlxsw_devlink_sb_tc_pool_bind_get,\n\t.sb_tc_pool_bind_set\t\t= mlxsw_devlink_sb_tc_pool_bind_set,\n\t.sb_occ_snapshot\t\t= mlxsw_devlink_sb_occ_snapshot,\n\t.sb_occ_max_clear\t\t= mlxsw_devlink_sb_occ_max_clear,\n\t.sb_occ_port_pool_get\t\t= mlxsw_devlink_sb_occ_port_pool_get,\n\t.sb_occ_tc_port_bind_get\t= mlxsw_devlink_sb_occ_tc_port_bind_get,\n\t.info_get\t\t\t= mlxsw_devlink_info_get,\n\t.flash_update\t\t\t= mlxsw_devlink_flash_update,\n\t.trap_init\t\t\t= mlxsw_devlink_trap_init,\n\t.trap_fini\t\t\t= mlxsw_devlink_trap_fini,\n\t.trap_action_set\t\t= mlxsw_devlink_trap_action_set,\n\t.trap_group_init\t\t= mlxsw_devlink_trap_group_init,\n\t.trap_group_set\t\t\t= mlxsw_devlink_trap_group_set,\n\t.trap_policer_init\t\t= mlxsw_devlink_trap_policer_init,\n\t.trap_policer_fini\t\t= mlxsw_devlink_trap_policer_fini,\n\t.trap_policer_set\t\t= mlxsw_devlink_trap_policer_set,\n\t.trap_policer_counter_get\t= mlxsw_devlink_trap_policer_counter_get,\n};\n\nstatic int mlxsw_core_params_register(struct mlxsw_core *mlxsw_core)\n{\n\treturn mlxsw_core_fw_params_register(mlxsw_core);\n}\n\nstatic void mlxsw_core_params_unregister(struct mlxsw_core *mlxsw_core)\n{\n\tmlxsw_core_fw_params_unregister(mlxsw_core);\n}\n\nstruct mlxsw_core_health_event {\n\tstruct mlxsw_core *mlxsw_core;\n\tchar mfde_pl[MLXSW_REG_MFDE_LEN];\n\tstruct work_struct work;\n};\n\nstatic void mlxsw_core_health_event_work(struct work_struct *work)\n{\n\tstruct mlxsw_core_health_event *event;\n\tstruct mlxsw_core *mlxsw_core;\n\n\tevent = container_of(work, struct mlxsw_core_health_event, work);\n\tmlxsw_core = event->mlxsw_core;\n\tdevlink_health_report(mlxsw_core->health.fw_fatal, \"FW fatal event occurred\",\n\t\t\t      event->mfde_pl);\n\tkfree(event);\n}\n\nstatic void mlxsw_core_health_listener_func(const struct mlxsw_reg_info *reg,\n\t\t\t\t\t    char *mfde_pl, void *priv)\n{\n\tstruct mlxsw_core_health_event *event;\n\tstruct mlxsw_core *mlxsw_core = priv;\n\n\tevent = kmalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event)\n\t\treturn;\n\tevent->mlxsw_core = mlxsw_core;\n\tmemcpy(event->mfde_pl, mfde_pl, sizeof(event->mfde_pl));\n\tINIT_WORK(&event->work, mlxsw_core_health_event_work);\n\tmlxsw_core_schedule_work(&event->work);\n}\n\nstatic const struct mlxsw_listener mlxsw_core_health_listener =\n\tMLXSW_CORE_EVENTL(mlxsw_core_health_listener_func, MFDE);\n\nstatic int\nmlxsw_core_health_fw_fatal_dump_fatal_cause(const char *mfde_pl,\n\t\t\t\t\t    struct devlink_fmsg *fmsg)\n{\n\tu32 val, tile_v;\n\tint err;\n\n\tval = mlxsw_reg_mfde_fatal_cause_id_get(mfde_pl);\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"cause_id\", val);\n\tif (err)\n\t\treturn err;\n\ttile_v = mlxsw_reg_mfde_fatal_cause_tile_v_get(mfde_pl);\n\tif (tile_v) {\n\t\tval = mlxsw_reg_mfde_fatal_cause_tile_index_get(mfde_pl);\n\t\terr = devlink_fmsg_u8_pair_put(fmsg, \"tile_index\", val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_core_health_fw_fatal_dump_fw_assert(const char *mfde_pl,\n\t\t\t\t\t  struct devlink_fmsg *fmsg)\n{\n\tu32 val, tile_v;\n\tint err;\n\n\tval = mlxsw_reg_mfde_fw_assert_var0_get(mfde_pl);\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"var0\", val);\n\tif (err)\n\t\treturn err;\n\tval = mlxsw_reg_mfde_fw_assert_var1_get(mfde_pl);\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"var1\", val);\n\tif (err)\n\t\treturn err;\n\tval = mlxsw_reg_mfde_fw_assert_var2_get(mfde_pl);\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"var2\", val);\n\tif (err)\n\t\treturn err;\n\tval = mlxsw_reg_mfde_fw_assert_var3_get(mfde_pl);\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"var3\", val);\n\tif (err)\n\t\treturn err;\n\tval = mlxsw_reg_mfde_fw_assert_var4_get(mfde_pl);\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"var4\", val);\n\tif (err)\n\t\treturn err;\n\tval = mlxsw_reg_mfde_fw_assert_existptr_get(mfde_pl);\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"existptr\", val);\n\tif (err)\n\t\treturn err;\n\tval = mlxsw_reg_mfde_fw_assert_callra_get(mfde_pl);\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"callra\", val);\n\tif (err)\n\t\treturn err;\n\tval = mlxsw_reg_mfde_fw_assert_oe_get(mfde_pl);\n\terr = devlink_fmsg_bool_pair_put(fmsg, \"old_event\", val);\n\tif (err)\n\t\treturn err;\n\ttile_v = mlxsw_reg_mfde_fw_assert_tile_v_get(mfde_pl);\n\tif (tile_v) {\n\t\tval = mlxsw_reg_mfde_fw_assert_tile_index_get(mfde_pl);\n\t\terr = devlink_fmsg_u8_pair_put(fmsg, \"tile_index\", val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tval = mlxsw_reg_mfde_fw_assert_ext_synd_get(mfde_pl);\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"ext_synd\", val);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_core_health_fw_fatal_dump_kvd_im_stop(const char *mfde_pl,\n\t\t\t\t\t    struct devlink_fmsg *fmsg)\n{\n\tu32 val;\n\tint err;\n\n\tval = mlxsw_reg_mfde_kvd_im_stop_oe_get(mfde_pl);\n\terr = devlink_fmsg_bool_pair_put(fmsg, \"old_event\", val);\n\tif (err)\n\t\treturn err;\n\tval = mlxsw_reg_mfde_kvd_im_stop_pipes_mask_get(mfde_pl);\n\treturn devlink_fmsg_u32_pair_put(fmsg, \"pipes_mask\", val);\n}\n\nstatic int\nmlxsw_core_health_fw_fatal_dump_crspace_to(const char *mfde_pl,\n\t\t\t\t\t   struct devlink_fmsg *fmsg)\n{\n\tu32 val;\n\tint err;\n\n\tval = mlxsw_reg_mfde_crspace_to_log_address_get(mfde_pl);\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"log_address\", val);\n\tif (err)\n\t\treturn err;\n\tval = mlxsw_reg_mfde_crspace_to_oe_get(mfde_pl);\n\terr = devlink_fmsg_bool_pair_put(fmsg, \"old_event\", val);\n\tif (err)\n\t\treturn err;\n\tval = mlxsw_reg_mfde_crspace_to_log_id_get(mfde_pl);\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"log_irisc_id\", val);\n\tif (err)\n\t\treturn err;\n\tval = mlxsw_reg_mfde_crspace_to_log_ip_get(mfde_pl);\n\terr = devlink_fmsg_u64_pair_put(fmsg, \"log_ip\", val);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int mlxsw_core_health_fw_fatal_dump(struct devlink_health_reporter *reporter,\n\t\t\t\t\t   struct devlink_fmsg *fmsg, void *priv_ctx,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tchar *mfde_pl = priv_ctx;\n\tchar *val_str;\n\tu8 event_id;\n\tu32 val;\n\tint err;\n\n\tif (!priv_ctx)\n\t\t \n\t\treturn -EOPNOTSUPP;\n\n\tval = mlxsw_reg_mfde_irisc_id_get(mfde_pl);\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"irisc_id\", val);\n\tif (err)\n\t\treturn err;\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"event\");\n\tif (err)\n\t\treturn err;\n\n\tevent_id = mlxsw_reg_mfde_event_id_get(mfde_pl);\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"id\", event_id);\n\tif (err)\n\t\treturn err;\n\tswitch (event_id) {\n\tcase MLXSW_REG_MFDE_EVENT_ID_CRSPACE_TO:\n\t\tval_str = \"CR space timeout\";\n\t\tbreak;\n\tcase MLXSW_REG_MFDE_EVENT_ID_KVD_IM_STOP:\n\t\tval_str = \"KVD insertion machine stopped\";\n\t\tbreak;\n\tcase MLXSW_REG_MFDE_EVENT_ID_TEST:\n\t\tval_str = \"Test\";\n\t\tbreak;\n\tcase MLXSW_REG_MFDE_EVENT_ID_FW_ASSERT:\n\t\tval_str = \"FW assert\";\n\t\tbreak;\n\tcase MLXSW_REG_MFDE_EVENT_ID_FATAL_CAUSE:\n\t\tval_str = \"Fatal cause\";\n\t\tbreak;\n\tdefault:\n\t\tval_str = NULL;\n\t}\n\tif (val_str) {\n\t\terr = devlink_fmsg_string_pair_put(fmsg, \"desc\", val_str);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"severity\");\n\tif (err)\n\t\treturn err;\n\n\tval = mlxsw_reg_mfde_severity_get(mfde_pl);\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"id\", val);\n\tif (err)\n\t\treturn err;\n\tswitch (val) {\n\tcase MLXSW_REG_MFDE_SEVERITY_FATL:\n\t\tval_str = \"Fatal\";\n\t\tbreak;\n\tcase MLXSW_REG_MFDE_SEVERITY_NRML:\n\t\tval_str = \"Normal\";\n\t\tbreak;\n\tcase MLXSW_REG_MFDE_SEVERITY_INTR:\n\t\tval_str = \"Debug\";\n\t\tbreak;\n\tdefault:\n\t\tval_str = NULL;\n\t}\n\tif (val_str) {\n\t\terr = devlink_fmsg_string_pair_put(fmsg, \"desc\", val_str);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\n\tval = mlxsw_reg_mfde_method_get(mfde_pl);\n\tswitch (val) {\n\tcase MLXSW_REG_MFDE_METHOD_QUERY:\n\t\tval_str = \"query\";\n\t\tbreak;\n\tcase MLXSW_REG_MFDE_METHOD_WRITE:\n\t\tval_str = \"write\";\n\t\tbreak;\n\tdefault:\n\t\tval_str = NULL;\n\t}\n\tif (val_str) {\n\t\terr = devlink_fmsg_string_pair_put(fmsg, \"method\", val_str);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tval = mlxsw_reg_mfde_long_process_get(mfde_pl);\n\terr = devlink_fmsg_bool_pair_put(fmsg, \"long_process\", val);\n\tif (err)\n\t\treturn err;\n\n\tval = mlxsw_reg_mfde_command_type_get(mfde_pl);\n\tswitch (val) {\n\tcase MLXSW_REG_MFDE_COMMAND_TYPE_MAD:\n\t\tval_str = \"mad\";\n\t\tbreak;\n\tcase MLXSW_REG_MFDE_COMMAND_TYPE_EMAD:\n\t\tval_str = \"emad\";\n\t\tbreak;\n\tcase MLXSW_REG_MFDE_COMMAND_TYPE_CMDIF:\n\t\tval_str = \"cmdif\";\n\t\tbreak;\n\tdefault:\n\t\tval_str = NULL;\n\t}\n\tif (val_str) {\n\t\terr = devlink_fmsg_string_pair_put(fmsg, \"command_type\", val_str);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tval = mlxsw_reg_mfde_reg_attr_id_get(mfde_pl);\n\terr = devlink_fmsg_u32_pair_put(fmsg, \"reg_attr_id\", val);\n\tif (err)\n\t\treturn err;\n\n\tswitch (event_id) {\n\tcase MLXSW_REG_MFDE_EVENT_ID_CRSPACE_TO:\n\t\treturn mlxsw_core_health_fw_fatal_dump_crspace_to(mfde_pl,\n\t\t\t\t\t\t\t\t  fmsg);\n\tcase MLXSW_REG_MFDE_EVENT_ID_KVD_IM_STOP:\n\t\treturn mlxsw_core_health_fw_fatal_dump_kvd_im_stop(mfde_pl,\n\t\t\t\t\t\t\t\t   fmsg);\n\tcase MLXSW_REG_MFDE_EVENT_ID_FW_ASSERT:\n\t\treturn mlxsw_core_health_fw_fatal_dump_fw_assert(mfde_pl, fmsg);\n\tcase MLXSW_REG_MFDE_EVENT_ID_FATAL_CAUSE:\n\t\treturn mlxsw_core_health_fw_fatal_dump_fatal_cause(mfde_pl,\n\t\t\t\t\t\t\t\t   fmsg);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_core_health_fw_fatal_test(struct devlink_health_reporter *reporter,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_health_reporter_priv(reporter);\n\tchar mfgd_pl[MLXSW_REG_MFGD_LEN];\n\tint err;\n\n\t \n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mfgd), mfgd_pl);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_mfgd_trigger_test_set(mfgd_pl, true);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mfgd), mfgd_pl);\n}\n\nstatic const struct devlink_health_reporter_ops\nmlxsw_core_health_fw_fatal_ops = {\n\t.name = \"fw_fatal\",\n\t.dump = mlxsw_core_health_fw_fatal_dump,\n\t.test = mlxsw_core_health_fw_fatal_test,\n};\n\nstatic int mlxsw_core_health_fw_fatal_config(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t     bool enable)\n{\n\tchar mfgd_pl[MLXSW_REG_MFGD_LEN];\n\tint err;\n\n\t \n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mfgd), mfgd_pl);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_mfgd_fatal_event_mode_set(mfgd_pl, enable);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mfgd), mfgd_pl);\n}\n\nstatic int mlxsw_core_health_init(struct mlxsw_core *mlxsw_core)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tstruct devlink_health_reporter *fw_fatal;\n\tint err;\n\n\tif (!(mlxsw_core->bus->features & MLXSW_BUS_F_TXRX))\n\t\treturn 0;\n\n\tfw_fatal = devl_health_reporter_create(devlink, &mlxsw_core_health_fw_fatal_ops,\n\t\t\t\t\t       0, mlxsw_core);\n\tif (IS_ERR(fw_fatal)) {\n\t\tdev_err(mlxsw_core->bus_info->dev, \"Failed to create fw fatal reporter\");\n\t\treturn PTR_ERR(fw_fatal);\n\t}\n\tmlxsw_core->health.fw_fatal = fw_fatal;\n\n\terr = mlxsw_core_trap_register(mlxsw_core, &mlxsw_core_health_listener, mlxsw_core);\n\tif (err)\n\t\tgoto err_trap_register;\n\n\terr = mlxsw_core_health_fw_fatal_config(mlxsw_core, true);\n\tif (err)\n\t\tgoto err_fw_fatal_config;\n\n\treturn 0;\n\nerr_fw_fatal_config:\n\tmlxsw_core_trap_unregister(mlxsw_core, &mlxsw_core_health_listener, mlxsw_core);\nerr_trap_register:\n\tdevl_health_reporter_destroy(mlxsw_core->health.fw_fatal);\n\treturn err;\n}\n\nstatic void mlxsw_core_health_fini(struct mlxsw_core *mlxsw_core)\n{\n\tif (!(mlxsw_core->bus->features & MLXSW_BUS_F_TXRX))\n\t\treturn;\n\n\tmlxsw_core_health_fw_fatal_config(mlxsw_core, false);\n\tmlxsw_core_trap_unregister(mlxsw_core, &mlxsw_core_health_listener, mlxsw_core);\n\t \n\tmlxsw_core_flush_owq();\n\tdevl_health_reporter_destroy(mlxsw_core->health.fw_fatal);\n}\n\nstatic void mlxsw_core_irq_event_handler_init(struct mlxsw_core *mlxsw_core)\n{\n\tINIT_LIST_HEAD(&mlxsw_core->irq_event_handler_list);\n\tmutex_init(&mlxsw_core->irq_event_handler_lock);\n}\n\nstatic void mlxsw_core_irq_event_handler_fini(struct mlxsw_core *mlxsw_core)\n{\n\tmutex_destroy(&mlxsw_core->irq_event_handler_lock);\n\tWARN_ON(!list_empty(&mlxsw_core->irq_event_handler_list));\n}\n\nstatic int\n__mlxsw_core_bus_device_register(const struct mlxsw_bus_info *mlxsw_bus_info,\n\t\t\t\t const struct mlxsw_bus *mlxsw_bus,\n\t\t\t\t void *bus_priv, bool reload,\n\t\t\t\t struct devlink *devlink,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tconst char *device_kind = mlxsw_bus_info->device_kind;\n\tstruct mlxsw_core *mlxsw_core;\n\tstruct mlxsw_driver *mlxsw_driver;\n\tsize_t alloc_size;\n\tu16 max_lag;\n\tint err;\n\n\tmlxsw_driver = mlxsw_core_driver_get(device_kind);\n\tif (!mlxsw_driver)\n\t\treturn -EINVAL;\n\n\tif (!reload) {\n\t\talloc_size = sizeof(*mlxsw_core) + mlxsw_driver->priv_size;\n\t\tdevlink = devlink_alloc(&mlxsw_devlink_ops, alloc_size,\n\t\t\t\t\tmlxsw_bus_info->dev);\n\t\tif (!devlink) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_devlink_alloc;\n\t\t}\n\t\tdevl_lock(devlink);\n\t\tdevl_register(devlink);\n\t}\n\n\tmlxsw_core = devlink_priv(devlink);\n\tINIT_LIST_HEAD(&mlxsw_core->rx_listener_list);\n\tINIT_LIST_HEAD(&mlxsw_core->event_listener_list);\n\tmlxsw_core->driver = mlxsw_driver;\n\tmlxsw_core->bus = mlxsw_bus;\n\tmlxsw_core->bus_priv = bus_priv;\n\tmlxsw_core->bus_info = mlxsw_bus_info;\n\tmlxsw_core_irq_event_handler_init(mlxsw_core);\n\n\terr = mlxsw_bus->init(bus_priv, mlxsw_core, mlxsw_driver->profile,\n\t\t\t      &mlxsw_core->res);\n\tif (err)\n\t\tgoto err_bus_init;\n\n\tif (mlxsw_driver->resources_register && !reload) {\n\t\terr = mlxsw_driver->resources_register(mlxsw_core);\n\t\tif (err)\n\t\t\tgoto err_register_resources;\n\t}\n\n\terr = mlxsw_ports_init(mlxsw_core, reload);\n\tif (err)\n\t\tgoto err_ports_init;\n\n\terr = mlxsw_core_max_lag(mlxsw_core, &max_lag);\n\tif (!err && MLXSW_CORE_RES_VALID(mlxsw_core, MAX_LAG_MEMBERS)) {\n\t\talloc_size = sizeof(*mlxsw_core->lag.mapping) * max_lag *\n\t\t\tMLXSW_CORE_RES_GET(mlxsw_core, MAX_LAG_MEMBERS);\n\t\tmlxsw_core->lag.mapping = kzalloc(alloc_size, GFP_KERNEL);\n\t\tif (!mlxsw_core->lag.mapping) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_alloc_lag_mapping;\n\t\t}\n\t}\n\n\terr = mlxsw_core_trap_groups_set(mlxsw_core);\n\tif (err)\n\t\tgoto err_trap_groups_set;\n\n\terr = mlxsw_emad_init(mlxsw_core);\n\tif (err)\n\t\tgoto err_emad_init;\n\n\tif (!reload) {\n\t\terr = mlxsw_core_params_register(mlxsw_core);\n\t\tif (err)\n\t\t\tgoto err_register_params;\n\t}\n\n\terr = mlxsw_core_fw_rev_validate(mlxsw_core, mlxsw_bus_info, mlxsw_driver->fw_req_rev,\n\t\t\t\t\t mlxsw_driver->fw_filename);\n\tif (err)\n\t\tgoto err_fw_rev_validate;\n\n\terr = mlxsw_linecards_init(mlxsw_core, mlxsw_bus_info);\n\tif (err)\n\t\tgoto err_linecards_init;\n\n\terr = mlxsw_core_health_init(mlxsw_core);\n\tif (err)\n\t\tgoto err_health_init;\n\n\terr = mlxsw_hwmon_init(mlxsw_core, mlxsw_bus_info, &mlxsw_core->hwmon);\n\tif (err)\n\t\tgoto err_hwmon_init;\n\n\terr = mlxsw_thermal_init(mlxsw_core, mlxsw_bus_info,\n\t\t\t\t &mlxsw_core->thermal);\n\tif (err)\n\t\tgoto err_thermal_init;\n\n\terr = mlxsw_env_init(mlxsw_core, mlxsw_bus_info, &mlxsw_core->env);\n\tif (err)\n\t\tgoto err_env_init;\n\n\tif (mlxsw_driver->init) {\n\t\terr = mlxsw_driver->init(mlxsw_core, mlxsw_bus_info, extack);\n\t\tif (err)\n\t\t\tgoto err_driver_init;\n\t}\n\n\tif (!reload)\n\t\tdevl_unlock(devlink);\n\treturn 0;\n\nerr_driver_init:\n\tmlxsw_env_fini(mlxsw_core->env);\nerr_env_init:\n\tmlxsw_thermal_fini(mlxsw_core->thermal);\nerr_thermal_init:\n\tmlxsw_hwmon_fini(mlxsw_core->hwmon);\nerr_hwmon_init:\n\tmlxsw_core_health_fini(mlxsw_core);\nerr_health_init:\n\tmlxsw_linecards_fini(mlxsw_core);\nerr_linecards_init:\nerr_fw_rev_validate:\n\tif (!reload)\n\t\tmlxsw_core_params_unregister(mlxsw_core);\nerr_register_params:\n\tmlxsw_emad_fini(mlxsw_core);\nerr_emad_init:\nerr_trap_groups_set:\n\tkfree(mlxsw_core->lag.mapping);\nerr_alloc_lag_mapping:\n\tmlxsw_ports_fini(mlxsw_core, reload);\nerr_ports_init:\n\tif (!reload)\n\t\tdevl_resources_unregister(devlink);\nerr_register_resources:\n\tmlxsw_bus->fini(bus_priv);\nerr_bus_init:\n\tmlxsw_core_irq_event_handler_fini(mlxsw_core);\n\tif (!reload) {\n\t\tdevl_unregister(devlink);\n\t\tdevl_unlock(devlink);\n\t\tdevlink_free(devlink);\n\t}\nerr_devlink_alloc:\n\treturn err;\n}\n\nint mlxsw_core_bus_device_register(const struct mlxsw_bus_info *mlxsw_bus_info,\n\t\t\t\t   const struct mlxsw_bus *mlxsw_bus,\n\t\t\t\t   void *bus_priv, bool reload,\n\t\t\t\t   struct devlink *devlink,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tbool called_again = false;\n\tint err;\n\nagain:\n\terr = __mlxsw_core_bus_device_register(mlxsw_bus_info, mlxsw_bus,\n\t\t\t\t\t       bus_priv, reload,\n\t\t\t\t\t       devlink, extack);\n\t \n\tif (err == -EAGAIN && !called_again) {\n\t\tcalled_again = true;\n\t\tgoto again;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL(mlxsw_core_bus_device_register);\n\nvoid mlxsw_core_bus_device_unregister(struct mlxsw_core *mlxsw_core,\n\t\t\t\t      bool reload)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\n\tif (!reload)\n\t\tdevl_lock(devlink);\n\n\tif (devlink_is_reload_failed(devlink)) {\n\t\tif (!reload)\n\t\t\t \n\t\t\tgoto reload_fail_deinit;\n\t\telse\n\t\t\treturn;\n\t}\n\n\tif (mlxsw_core->driver->fini)\n\t\tmlxsw_core->driver->fini(mlxsw_core);\n\tmlxsw_env_fini(mlxsw_core->env);\n\tmlxsw_thermal_fini(mlxsw_core->thermal);\n\tmlxsw_hwmon_fini(mlxsw_core->hwmon);\n\tmlxsw_core_health_fini(mlxsw_core);\n\tmlxsw_linecards_fini(mlxsw_core);\n\tif (!reload)\n\t\tmlxsw_core_params_unregister(mlxsw_core);\n\tmlxsw_emad_fini(mlxsw_core);\n\tkfree(mlxsw_core->lag.mapping);\n\tmlxsw_ports_fini(mlxsw_core, reload);\n\tif (!reload)\n\t\tdevl_resources_unregister(devlink);\n\tmlxsw_core->bus->fini(mlxsw_core->bus_priv);\n\tmlxsw_core_irq_event_handler_fini(mlxsw_core);\n\tif (!reload) {\n\t\tdevl_unregister(devlink);\n\t\tdevl_unlock(devlink);\n\t\tdevlink_free(devlink);\n\t}\n\n\treturn;\n\nreload_fail_deinit:\n\tmlxsw_core_params_unregister(mlxsw_core);\n\tdevl_resources_unregister(devlink);\n\tdevl_unregister(devlink);\n\tdevl_unlock(devlink);\n\tdevlink_free(devlink);\n}\nEXPORT_SYMBOL(mlxsw_core_bus_device_unregister);\n\nbool mlxsw_core_skb_transmit_busy(struct mlxsw_core *mlxsw_core,\n\t\t\t\t  const struct mlxsw_tx_info *tx_info)\n{\n\treturn mlxsw_core->bus->skb_transmit_busy(mlxsw_core->bus_priv,\n\t\t\t\t\t\t  tx_info);\n}\nEXPORT_SYMBOL(mlxsw_core_skb_transmit_busy);\n\nint mlxsw_core_skb_transmit(struct mlxsw_core *mlxsw_core, struct sk_buff *skb,\n\t\t\t    const struct mlxsw_tx_info *tx_info)\n{\n\treturn mlxsw_core->bus->skb_transmit(mlxsw_core->bus_priv, skb,\n\t\t\t\t\t     tx_info);\n}\nEXPORT_SYMBOL(mlxsw_core_skb_transmit);\n\nvoid mlxsw_core_ptp_transmitted(struct mlxsw_core *mlxsw_core,\n\t\t\t\tstruct sk_buff *skb, u16 local_port)\n{\n\tif (mlxsw_core->driver->ptp_transmitted)\n\t\tmlxsw_core->driver->ptp_transmitted(mlxsw_core, skb,\n\t\t\t\t\t\t    local_port);\n}\nEXPORT_SYMBOL(mlxsw_core_ptp_transmitted);\n\nstatic bool __is_rx_listener_equal(const struct mlxsw_rx_listener *rxl_a,\n\t\t\t\t   const struct mlxsw_rx_listener *rxl_b)\n{\n\treturn (rxl_a->func == rxl_b->func &&\n\t\trxl_a->local_port == rxl_b->local_port &&\n\t\trxl_a->trap_id == rxl_b->trap_id &&\n\t\trxl_a->mirror_reason == rxl_b->mirror_reason);\n}\n\nstatic struct mlxsw_rx_listener_item *\n__find_rx_listener_item(struct mlxsw_core *mlxsw_core,\n\t\t\tconst struct mlxsw_rx_listener *rxl)\n{\n\tstruct mlxsw_rx_listener_item *rxl_item;\n\n\tlist_for_each_entry(rxl_item, &mlxsw_core->rx_listener_list, list) {\n\t\tif (__is_rx_listener_equal(&rxl_item->rxl, rxl))\n\t\t\treturn rxl_item;\n\t}\n\treturn NULL;\n}\n\nint mlxsw_core_rx_listener_register(struct mlxsw_core *mlxsw_core,\n\t\t\t\t    const struct mlxsw_rx_listener *rxl,\n\t\t\t\t    void *priv, bool enabled)\n{\n\tstruct mlxsw_rx_listener_item *rxl_item;\n\n\trxl_item = __find_rx_listener_item(mlxsw_core, rxl);\n\tif (rxl_item)\n\t\treturn -EEXIST;\n\trxl_item = kmalloc(sizeof(*rxl_item), GFP_KERNEL);\n\tif (!rxl_item)\n\t\treturn -ENOMEM;\n\trxl_item->rxl = *rxl;\n\trxl_item->priv = priv;\n\trxl_item->enabled = enabled;\n\n\tlist_add_rcu(&rxl_item->list, &mlxsw_core->rx_listener_list);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_core_rx_listener_register);\n\nvoid mlxsw_core_rx_listener_unregister(struct mlxsw_core *mlxsw_core,\n\t\t\t\t       const struct mlxsw_rx_listener *rxl)\n{\n\tstruct mlxsw_rx_listener_item *rxl_item;\n\n\trxl_item = __find_rx_listener_item(mlxsw_core, rxl);\n\tif (!rxl_item)\n\t\treturn;\n\tlist_del_rcu(&rxl_item->list);\n\tsynchronize_rcu();\n\tkfree(rxl_item);\n}\nEXPORT_SYMBOL(mlxsw_core_rx_listener_unregister);\n\nstatic void\nmlxsw_core_rx_listener_state_set(struct mlxsw_core *mlxsw_core,\n\t\t\t\t const struct mlxsw_rx_listener *rxl,\n\t\t\t\t bool enabled)\n{\n\tstruct mlxsw_rx_listener_item *rxl_item;\n\n\trxl_item = __find_rx_listener_item(mlxsw_core, rxl);\n\tif (WARN_ON(!rxl_item))\n\t\treturn;\n\trxl_item->enabled = enabled;\n}\n\nstatic void mlxsw_core_event_listener_func(struct sk_buff *skb, u16 local_port,\n\t\t\t\t\t   void *priv)\n{\n\tstruct mlxsw_event_listener_item *event_listener_item = priv;\n\tstruct mlxsw_core *mlxsw_core;\n\tstruct mlxsw_reg_info reg;\n\tchar *payload;\n\tchar *reg_tlv;\n\tchar *op_tlv;\n\n\tmlxsw_core = event_listener_item->mlxsw_core;\n\ttrace_devlink_hwmsg(priv_to_devlink(mlxsw_core), true, 0,\n\t\t\t    skb->data, skb->len);\n\n\tmlxsw_emad_tlv_parse(skb);\n\top_tlv = mlxsw_emad_op_tlv(skb);\n\treg_tlv = mlxsw_emad_reg_tlv(skb);\n\n\treg.id = mlxsw_emad_op_tlv_register_id_get(op_tlv);\n\treg.len = (mlxsw_emad_reg_tlv_len_get(reg_tlv) - 1) * sizeof(u32);\n\tpayload = mlxsw_emad_reg_payload(reg_tlv);\n\tevent_listener_item->el.func(&reg, payload, event_listener_item->priv);\n\tdev_kfree_skb(skb);\n}\n\nstatic bool __is_event_listener_equal(const struct mlxsw_event_listener *el_a,\n\t\t\t\t      const struct mlxsw_event_listener *el_b)\n{\n\treturn (el_a->func == el_b->func &&\n\t\tel_a->trap_id == el_b->trap_id);\n}\n\nstatic struct mlxsw_event_listener_item *\n__find_event_listener_item(struct mlxsw_core *mlxsw_core,\n\t\t\t   const struct mlxsw_event_listener *el)\n{\n\tstruct mlxsw_event_listener_item *el_item;\n\n\tlist_for_each_entry(el_item, &mlxsw_core->event_listener_list, list) {\n\t\tif (__is_event_listener_equal(&el_item->el, el))\n\t\t\treturn el_item;\n\t}\n\treturn NULL;\n}\n\nint mlxsw_core_event_listener_register(struct mlxsw_core *mlxsw_core,\n\t\t\t\t       const struct mlxsw_event_listener *el,\n\t\t\t\t       void *priv)\n{\n\tint err;\n\tstruct mlxsw_event_listener_item *el_item;\n\tconst struct mlxsw_rx_listener rxl = {\n\t\t.func = mlxsw_core_event_listener_func,\n\t\t.local_port = MLXSW_PORT_DONT_CARE,\n\t\t.trap_id = el->trap_id,\n\t};\n\n\tel_item = __find_event_listener_item(mlxsw_core, el);\n\tif (el_item)\n\t\treturn -EEXIST;\n\tel_item = kmalloc(sizeof(*el_item), GFP_KERNEL);\n\tif (!el_item)\n\t\treturn -ENOMEM;\n\tel_item->mlxsw_core = mlxsw_core;\n\tel_item->el = *el;\n\tel_item->priv = priv;\n\n\terr = mlxsw_core_rx_listener_register(mlxsw_core, &rxl, el_item, true);\n\tif (err)\n\t\tgoto err_rx_listener_register;\n\n\t \n\tlist_add_rcu(&el_item->list, &mlxsw_core->event_listener_list);\n\n\treturn 0;\n\nerr_rx_listener_register:\n\tkfree(el_item);\n\treturn err;\n}\nEXPORT_SYMBOL(mlxsw_core_event_listener_register);\n\nvoid mlxsw_core_event_listener_unregister(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t  const struct mlxsw_event_listener *el)\n{\n\tstruct mlxsw_event_listener_item *el_item;\n\tconst struct mlxsw_rx_listener rxl = {\n\t\t.func = mlxsw_core_event_listener_func,\n\t\t.local_port = MLXSW_PORT_DONT_CARE,\n\t\t.trap_id = el->trap_id,\n\t};\n\n\tel_item = __find_event_listener_item(mlxsw_core, el);\n\tif (!el_item)\n\t\treturn;\n\tmlxsw_core_rx_listener_unregister(mlxsw_core, &rxl);\n\tlist_del(&el_item->list);\n\tkfree(el_item);\n}\nEXPORT_SYMBOL(mlxsw_core_event_listener_unregister);\n\nstatic int mlxsw_core_listener_register(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\tconst struct mlxsw_listener *listener,\n\t\t\t\t\tvoid *priv, bool enabled)\n{\n\tif (listener->is_event) {\n\t\tWARN_ON(!enabled);\n\t\treturn mlxsw_core_event_listener_register(mlxsw_core,\n\t\t\t\t\t\t&listener->event_listener,\n\t\t\t\t\t\tpriv);\n\t} else {\n\t\treturn mlxsw_core_rx_listener_register(mlxsw_core,\n\t\t\t\t\t\t&listener->rx_listener,\n\t\t\t\t\t\tpriv, enabled);\n\t}\n}\n\nstatic void mlxsw_core_listener_unregister(struct mlxsw_core *mlxsw_core,\n\t\t\t\t      const struct mlxsw_listener *listener,\n\t\t\t\t      void *priv)\n{\n\tif (listener->is_event)\n\t\tmlxsw_core_event_listener_unregister(mlxsw_core,\n\t\t\t\t\t\t     &listener->event_listener);\n\telse\n\t\tmlxsw_core_rx_listener_unregister(mlxsw_core,\n\t\t\t\t\t\t  &listener->rx_listener);\n}\n\nint mlxsw_core_trap_register(struct mlxsw_core *mlxsw_core,\n\t\t\t     const struct mlxsw_listener *listener, void *priv)\n{\n\tenum mlxsw_reg_htgt_trap_group trap_group;\n\tenum mlxsw_reg_hpkt_action action;\n\tchar hpkt_pl[MLXSW_REG_HPKT_LEN];\n\tint err;\n\n\tif (!(mlxsw_core->bus->features & MLXSW_BUS_F_TXRX))\n\t\treturn 0;\n\n\terr = mlxsw_core_listener_register(mlxsw_core, listener, priv,\n\t\t\t\t\t   listener->enabled_on_register);\n\tif (err)\n\t\treturn err;\n\n\taction = listener->enabled_on_register ? listener->en_action :\n\t\t\t\t\t\t listener->dis_action;\n\ttrap_group = listener->enabled_on_register ? listener->en_trap_group :\n\t\t\t\t\t\t     listener->dis_trap_group;\n\tmlxsw_reg_hpkt_pack(hpkt_pl, action, listener->trap_id,\n\t\t\t    trap_group, listener->is_ctrl);\n\terr = mlxsw_reg_write(mlxsw_core,  MLXSW_REG(hpkt), hpkt_pl);\n\tif (err)\n\t\tgoto err_trap_set;\n\n\treturn 0;\n\nerr_trap_set:\n\tmlxsw_core_listener_unregister(mlxsw_core, listener, priv);\n\treturn err;\n}\nEXPORT_SYMBOL(mlxsw_core_trap_register);\n\nvoid mlxsw_core_trap_unregister(struct mlxsw_core *mlxsw_core,\n\t\t\t\tconst struct mlxsw_listener *listener,\n\t\t\t\tvoid *priv)\n{\n\tchar hpkt_pl[MLXSW_REG_HPKT_LEN];\n\n\tif (!(mlxsw_core->bus->features & MLXSW_BUS_F_TXRX))\n\t\treturn;\n\n\tif (!listener->is_event) {\n\t\tmlxsw_reg_hpkt_pack(hpkt_pl, listener->dis_action,\n\t\t\t\t    listener->trap_id, listener->dis_trap_group,\n\t\t\t\t    listener->is_ctrl);\n\t\tmlxsw_reg_write(mlxsw_core, MLXSW_REG(hpkt), hpkt_pl);\n\t}\n\n\tmlxsw_core_listener_unregister(mlxsw_core, listener, priv);\n}\nEXPORT_SYMBOL(mlxsw_core_trap_unregister);\n\nint mlxsw_core_traps_register(struct mlxsw_core *mlxsw_core,\n\t\t\t      const struct mlxsw_listener *listeners,\n\t\t\t      size_t listeners_count, void *priv)\n{\n\tint i, err;\n\n\tfor (i = 0; i < listeners_count; i++) {\n\t\terr = mlxsw_core_trap_register(mlxsw_core,\n\t\t\t\t\t       &listeners[i],\n\t\t\t\t\t       priv);\n\t\tif (err)\n\t\t\tgoto err_listener_register;\n\t}\n\treturn 0;\n\nerr_listener_register:\n\tfor (i--; i >= 0; i--) {\n\t\tmlxsw_core_trap_unregister(mlxsw_core,\n\t\t\t\t\t   &listeners[i],\n\t\t\t\t\t   priv);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL(mlxsw_core_traps_register);\n\nvoid mlxsw_core_traps_unregister(struct mlxsw_core *mlxsw_core,\n\t\t\t\t const struct mlxsw_listener *listeners,\n\t\t\t\t size_t listeners_count, void *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < listeners_count; i++) {\n\t\tmlxsw_core_trap_unregister(mlxsw_core,\n\t\t\t\t\t   &listeners[i],\n\t\t\t\t\t   priv);\n\t}\n}\nEXPORT_SYMBOL(mlxsw_core_traps_unregister);\n\nint mlxsw_core_trap_state_set(struct mlxsw_core *mlxsw_core,\n\t\t\t      const struct mlxsw_listener *listener,\n\t\t\t      bool enabled)\n{\n\tenum mlxsw_reg_htgt_trap_group trap_group;\n\tenum mlxsw_reg_hpkt_action action;\n\tchar hpkt_pl[MLXSW_REG_HPKT_LEN];\n\tint err;\n\n\t \n\tif (WARN_ON(listener->is_event))\n\t\treturn -EINVAL;\n\n\taction = enabled ? listener->en_action : listener->dis_action;\n\ttrap_group = enabled ? listener->en_trap_group :\n\t\t\t       listener->dis_trap_group;\n\tmlxsw_reg_hpkt_pack(hpkt_pl, action, listener->trap_id,\n\t\t\t    trap_group, listener->is_ctrl);\n\terr = mlxsw_reg_write(mlxsw_core, MLXSW_REG(hpkt), hpkt_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_core_rx_listener_state_set(mlxsw_core, &listener->rx_listener,\n\t\t\t\t\t enabled);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_core_trap_state_set);\n\nstatic u64 mlxsw_core_tid_get(struct mlxsw_core *mlxsw_core)\n{\n\treturn atomic64_inc_return(&mlxsw_core->emad.tid);\n}\n\nstatic int mlxsw_core_reg_access_emad(struct mlxsw_core *mlxsw_core,\n\t\t\t\t      const struct mlxsw_reg_info *reg,\n\t\t\t\t      char *payload,\n\t\t\t\t      enum mlxsw_core_reg_access_type type,\n\t\t\t\t      struct list_head *bulk_list,\n\t\t\t\t      mlxsw_reg_trans_cb_t *cb,\n\t\t\t\t      unsigned long cb_priv)\n{\n\tu64 tid = mlxsw_core_tid_get(mlxsw_core);\n\tstruct mlxsw_reg_trans *trans;\n\tint err;\n\n\ttrans = kzalloc(sizeof(*trans), GFP_KERNEL);\n\tif (!trans)\n\t\treturn -ENOMEM;\n\n\terr = mlxsw_emad_reg_access(mlxsw_core, reg, payload, type, trans,\n\t\t\t\t    bulk_list, cb, cb_priv, tid);\n\tif (err) {\n\t\tkfree_rcu(trans, rcu);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nint mlxsw_reg_trans_query(struct mlxsw_core *mlxsw_core,\n\t\t\t  const struct mlxsw_reg_info *reg, char *payload,\n\t\t\t  struct list_head *bulk_list,\n\t\t\t  mlxsw_reg_trans_cb_t *cb, unsigned long cb_priv)\n{\n\treturn mlxsw_core_reg_access_emad(mlxsw_core, reg, payload,\n\t\t\t\t\t  MLXSW_CORE_REG_ACCESS_TYPE_QUERY,\n\t\t\t\t\t  bulk_list, cb, cb_priv);\n}\nEXPORT_SYMBOL(mlxsw_reg_trans_query);\n\nint mlxsw_reg_trans_write(struct mlxsw_core *mlxsw_core,\n\t\t\t  const struct mlxsw_reg_info *reg, char *payload,\n\t\t\t  struct list_head *bulk_list,\n\t\t\t  mlxsw_reg_trans_cb_t *cb, unsigned long cb_priv)\n{\n\treturn mlxsw_core_reg_access_emad(mlxsw_core, reg, payload,\n\t\t\t\t\t  MLXSW_CORE_REG_ACCESS_TYPE_WRITE,\n\t\t\t\t\t  bulk_list, cb, cb_priv);\n}\nEXPORT_SYMBOL(mlxsw_reg_trans_write);\n\n#define MLXSW_REG_TRANS_ERR_STRING_SIZE\t256\n\nstatic int mlxsw_reg_trans_wait(struct mlxsw_reg_trans *trans)\n{\n\tchar err_string[MLXSW_REG_TRANS_ERR_STRING_SIZE];\n\tstruct mlxsw_core *mlxsw_core = trans->core;\n\tint err;\n\n\twait_for_completion(&trans->completion);\n\tcancel_delayed_work_sync(&trans->timeout_dw);\n\terr = trans->err;\n\n\tif (trans->retries)\n\t\tdev_warn(mlxsw_core->bus_info->dev, \"EMAD retries (%d/%d) (tid=%llx)\\n\",\n\t\t\t trans->retries, MLXSW_EMAD_MAX_RETRY, trans->tid);\n\tif (err) {\n\t\tdev_err(mlxsw_core->bus_info->dev, \"EMAD reg access failed (tid=%llx,reg_id=%x(%s),type=%s,status=%x(%s))\\n\",\n\t\t\ttrans->tid, trans->reg->id,\n\t\t\tmlxsw_reg_id_str(trans->reg->id),\n\t\t\tmlxsw_core_reg_access_type_str(trans->type),\n\t\t\ttrans->emad_status,\n\t\t\tmlxsw_emad_op_tlv_status_str(trans->emad_status));\n\n\t\tsnprintf(err_string, MLXSW_REG_TRANS_ERR_STRING_SIZE,\n\t\t\t \"(tid=%llx,reg_id=%x(%s)) %s (%s)\\n\", trans->tid,\n\t\t\t trans->reg->id, mlxsw_reg_id_str(trans->reg->id),\n\t\t\t mlxsw_emad_op_tlv_status_str(trans->emad_status),\n\t\t\t trans->emad_err_string ? trans->emad_err_string : \"\");\n\n\t\ttrace_devlink_hwerr(priv_to_devlink(mlxsw_core),\n\t\t\t\t    trans->emad_status, err_string);\n\n\t\tkfree(trans->emad_err_string);\n\t}\n\n\tlist_del(&trans->bulk_list);\n\tkfree_rcu(trans, rcu);\n\treturn err;\n}\n\nint mlxsw_reg_trans_bulk_wait(struct list_head *bulk_list)\n{\n\tstruct mlxsw_reg_trans *trans;\n\tstruct mlxsw_reg_trans *tmp;\n\tint sum_err = 0;\n\tint err;\n\n\tlist_for_each_entry_safe(trans, tmp, bulk_list, bulk_list) {\n\t\terr = mlxsw_reg_trans_wait(trans);\n\t\tif (err && sum_err == 0)\n\t\t\tsum_err = err;  \n\t}\n\treturn sum_err;\n}\nEXPORT_SYMBOL(mlxsw_reg_trans_bulk_wait);\n\nstruct mlxsw_core_irq_event_handler_item {\n\tstruct list_head list;\n\tvoid (*cb)(struct mlxsw_core *mlxsw_core);\n};\n\nint mlxsw_core_irq_event_handler_register(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t  mlxsw_irq_event_cb_t cb)\n{\n\tstruct mlxsw_core_irq_event_handler_item *item;\n\n\titem = kzalloc(sizeof(*item), GFP_KERNEL);\n\tif (!item)\n\t\treturn -ENOMEM;\n\titem->cb = cb;\n\tmutex_lock(&mlxsw_core->irq_event_handler_lock);\n\tlist_add_tail(&item->list, &mlxsw_core->irq_event_handler_list);\n\tmutex_unlock(&mlxsw_core->irq_event_handler_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_core_irq_event_handler_register);\n\nvoid mlxsw_core_irq_event_handler_unregister(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t     mlxsw_irq_event_cb_t cb)\n{\n\tstruct mlxsw_core_irq_event_handler_item *item, *tmp;\n\n\tmutex_lock(&mlxsw_core->irq_event_handler_lock);\n\tlist_for_each_entry_safe(item, tmp,\n\t\t\t\t &mlxsw_core->irq_event_handler_list, list) {\n\t\tif (item->cb == cb) {\n\t\t\tlist_del(&item->list);\n\t\t\tkfree(item);\n\t\t}\n\t}\n\tmutex_unlock(&mlxsw_core->irq_event_handler_lock);\n}\nEXPORT_SYMBOL(mlxsw_core_irq_event_handler_unregister);\n\nvoid mlxsw_core_irq_event_handlers_call(struct mlxsw_core *mlxsw_core)\n{\n\tstruct mlxsw_core_irq_event_handler_item *item;\n\n\tmutex_lock(&mlxsw_core->irq_event_handler_lock);\n\tlist_for_each_entry(item, &mlxsw_core->irq_event_handler_list, list) {\n\t\tif (item->cb)\n\t\t\titem->cb(mlxsw_core);\n\t}\n\tmutex_unlock(&mlxsw_core->irq_event_handler_lock);\n}\nEXPORT_SYMBOL(mlxsw_core_irq_event_handlers_call);\n\nstatic int mlxsw_core_reg_access_cmd(struct mlxsw_core *mlxsw_core,\n\t\t\t\t     const struct mlxsw_reg_info *reg,\n\t\t\t\t     char *payload,\n\t\t\t\t     enum mlxsw_core_reg_access_type type)\n{\n\tenum mlxsw_emad_op_tlv_status status;\n\tint err, n_retry;\n\tbool reset_ok;\n\tchar *in_mbox, *out_mbox, *tmp;\n\n\tdev_dbg(mlxsw_core->bus_info->dev, \"Reg cmd access (reg_id=%x(%s),type=%s)\\n\",\n\t\treg->id, mlxsw_reg_id_str(reg->id),\n\t\tmlxsw_core_reg_access_type_str(type));\n\n\tin_mbox = mlxsw_cmd_mbox_alloc();\n\tif (!in_mbox)\n\t\treturn -ENOMEM;\n\n\tout_mbox = mlxsw_cmd_mbox_alloc();\n\tif (!out_mbox) {\n\t\terr = -ENOMEM;\n\t\tgoto free_in_mbox;\n\t}\n\n\tmlxsw_emad_pack_op_tlv(in_mbox, reg, type,\n\t\t\t       mlxsw_core_tid_get(mlxsw_core));\n\ttmp = in_mbox + MLXSW_EMAD_OP_TLV_LEN * sizeof(u32);\n\tmlxsw_emad_pack_reg_tlv(tmp, reg, payload);\n\n\t \n\treset_ok = reg->id == MLXSW_REG_MRSR_ID;\n\n\tn_retry = 0;\nretry:\n\terr = mlxsw_cmd_access_reg(mlxsw_core, reset_ok, in_mbox, out_mbox);\n\tif (!err) {\n\t\terr = mlxsw_emad_process_status(out_mbox, &status);\n\t\tif (err) {\n\t\t\tif (err == -EAGAIN && n_retry++ < MLXSW_EMAD_MAX_RETRY)\n\t\t\t\tgoto retry;\n\t\t\tdev_err(mlxsw_core->bus_info->dev, \"Reg cmd access status failed (status=%x(%s))\\n\",\n\t\t\t\tstatus, mlxsw_emad_op_tlv_status_str(status));\n\t\t}\n\t}\n\n\tif (!err)\n\t\tmemcpy(payload, mlxsw_emad_reg_payload_cmd(out_mbox),\n\t\t       reg->len);\n\n\tmlxsw_cmd_mbox_free(out_mbox);\nfree_in_mbox:\n\tmlxsw_cmd_mbox_free(in_mbox);\n\tif (err)\n\t\tdev_err(mlxsw_core->bus_info->dev, \"Reg cmd access failed (reg_id=%x(%s),type=%s)\\n\",\n\t\t\treg->id, mlxsw_reg_id_str(reg->id),\n\t\t\tmlxsw_core_reg_access_type_str(type));\n\treturn err;\n}\n\nstatic void mlxsw_core_reg_access_cb(struct mlxsw_core *mlxsw_core,\n\t\t\t\t     char *payload, size_t payload_len,\n\t\t\t\t     unsigned long cb_priv)\n{\n\tchar *orig_payload = (char *) cb_priv;\n\n\tmemcpy(orig_payload, payload, payload_len);\n}\n\nstatic int mlxsw_core_reg_access(struct mlxsw_core *mlxsw_core,\n\t\t\t\t const struct mlxsw_reg_info *reg,\n\t\t\t\t char *payload,\n\t\t\t\t enum mlxsw_core_reg_access_type type)\n{\n\tLIST_HEAD(bulk_list);\n\tint err;\n\n\t \n\tif (!mlxsw_core->emad.use_emad)\n\t\treturn mlxsw_core_reg_access_cmd(mlxsw_core, reg,\n\t\t\t\t\t\t payload, type);\n\n\terr = mlxsw_core_reg_access_emad(mlxsw_core, reg,\n\t\t\t\t\t payload, type, &bulk_list,\n\t\t\t\t\t mlxsw_core_reg_access_cb,\n\t\t\t\t\t (unsigned long) payload);\n\tif (err)\n\t\treturn err;\n\treturn mlxsw_reg_trans_bulk_wait(&bulk_list);\n}\n\nint mlxsw_reg_query(struct mlxsw_core *mlxsw_core,\n\t\t    const struct mlxsw_reg_info *reg, char *payload)\n{\n\treturn mlxsw_core_reg_access(mlxsw_core, reg, payload,\n\t\t\t\t     MLXSW_CORE_REG_ACCESS_TYPE_QUERY);\n}\nEXPORT_SYMBOL(mlxsw_reg_query);\n\nint mlxsw_reg_write(struct mlxsw_core *mlxsw_core,\n\t\t    const struct mlxsw_reg_info *reg, char *payload)\n{\n\treturn mlxsw_core_reg_access(mlxsw_core, reg, payload,\n\t\t\t\t     MLXSW_CORE_REG_ACCESS_TYPE_WRITE);\n}\nEXPORT_SYMBOL(mlxsw_reg_write);\n\nvoid mlxsw_core_skb_receive(struct mlxsw_core *mlxsw_core, struct sk_buff *skb,\n\t\t\t    struct mlxsw_rx_info *rx_info)\n{\n\tstruct mlxsw_rx_listener_item *rxl_item;\n\tconst struct mlxsw_rx_listener *rxl;\n\tu16 local_port;\n\tbool found = false;\n\n\tif (rx_info->is_lag) {\n\t\tdev_dbg_ratelimited(mlxsw_core->bus_info->dev, \"%s: lag_id = %d, lag_port_index = 0x%x\\n\",\n\t\t\t\t    __func__, rx_info->u.lag_id,\n\t\t\t\t    rx_info->trap_id);\n\t\t \n\t\tlocal_port = mlxsw_core_lag_mapping_get(mlxsw_core,\n\t\t\t\t\t\t\trx_info->u.lag_id,\n\t\t\t\t\t\t\trx_info->lag_port_index);\n\t} else {\n\t\tlocal_port = rx_info->u.sys_port;\n\t}\n\n\tdev_dbg_ratelimited(mlxsw_core->bus_info->dev, \"%s: local_port = %d, trap_id = 0x%x\\n\",\n\t\t\t    __func__, local_port, rx_info->trap_id);\n\n\tif ((rx_info->trap_id >= MLXSW_TRAP_ID_MAX) ||\n\t    (local_port >= mlxsw_core->max_ports))\n\t\tgoto drop;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(rxl_item, &mlxsw_core->rx_listener_list, list) {\n\t\trxl = &rxl_item->rxl;\n\t\tif ((rxl->local_port == MLXSW_PORT_DONT_CARE ||\n\t\t     rxl->local_port == local_port) &&\n\t\t    rxl->trap_id == rx_info->trap_id &&\n\t\t    rxl->mirror_reason == rx_info->mirror_reason) {\n\t\t\tif (rxl_item->enabled)\n\t\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\trcu_read_unlock();\n\t\tgoto drop;\n\t}\n\n\trxl->func(skb, local_port, rxl_item->priv);\n\trcu_read_unlock();\n\treturn;\n\ndrop:\n\tdev_kfree_skb(skb);\n}\nEXPORT_SYMBOL(mlxsw_core_skb_receive);\n\nstatic int mlxsw_core_lag_mapping_index(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\tu16 lag_id, u8 port_index)\n{\n\treturn MLXSW_CORE_RES_GET(mlxsw_core, MAX_LAG_MEMBERS) * lag_id +\n\t       port_index;\n}\n\nvoid mlxsw_core_lag_mapping_set(struct mlxsw_core *mlxsw_core,\n\t\t\t\tu16 lag_id, u8 port_index, u16 local_port)\n{\n\tint index = mlxsw_core_lag_mapping_index(mlxsw_core,\n\t\t\t\t\t\t lag_id, port_index);\n\n\tmlxsw_core->lag.mapping[index] = local_port;\n}\nEXPORT_SYMBOL(mlxsw_core_lag_mapping_set);\n\nu16 mlxsw_core_lag_mapping_get(struct mlxsw_core *mlxsw_core,\n\t\t\t       u16 lag_id, u8 port_index)\n{\n\tint index = mlxsw_core_lag_mapping_index(mlxsw_core,\n\t\t\t\t\t\t lag_id, port_index);\n\n\treturn mlxsw_core->lag.mapping[index];\n}\nEXPORT_SYMBOL(mlxsw_core_lag_mapping_get);\n\nvoid mlxsw_core_lag_mapping_clear(struct mlxsw_core *mlxsw_core,\n\t\t\t\t  u16 lag_id, u16 local_port)\n{\n\tint i;\n\n\tfor (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_core, MAX_LAG_MEMBERS); i++) {\n\t\tint index = mlxsw_core_lag_mapping_index(mlxsw_core,\n\t\t\t\t\t\t\t lag_id, i);\n\n\t\tif (mlxsw_core->lag.mapping[index] == local_port)\n\t\t\tmlxsw_core->lag.mapping[index] = 0;\n\t}\n}\nEXPORT_SYMBOL(mlxsw_core_lag_mapping_clear);\n\nbool mlxsw_core_res_valid(struct mlxsw_core *mlxsw_core,\n\t\t\t  enum mlxsw_res_id res_id)\n{\n\treturn mlxsw_res_valid(&mlxsw_core->res, res_id);\n}\nEXPORT_SYMBOL(mlxsw_core_res_valid);\n\nu64 mlxsw_core_res_get(struct mlxsw_core *mlxsw_core,\n\t\t       enum mlxsw_res_id res_id)\n{\n\treturn mlxsw_res_get(&mlxsw_core->res, res_id);\n}\nEXPORT_SYMBOL(mlxsw_core_res_get);\n\nstatic const struct devlink_port_ops mlxsw_devlink_port_ops = {\n\t.port_split\t\t\t= mlxsw_devlink_port_split,\n\t.port_unsplit\t\t\t= mlxsw_devlink_port_unsplit,\n};\n\nstatic int __mlxsw_core_port_init(struct mlxsw_core *mlxsw_core, u16 local_port,\n\t\t\t\t  enum devlink_port_flavour flavour,\n\t\t\t\t  u8 slot_index, u32 port_number, bool split,\n\t\t\t\t  u32 split_port_subnumber,\n\t\t\t\t  bool splittable, u32 lanes,\n\t\t\t\t  const unsigned char *switch_id,\n\t\t\t\t  unsigned char switch_id_len)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tstruct mlxsw_core_port *mlxsw_core_port =\n\t\t\t\t\t&mlxsw_core->ports[local_port];\n\tstruct devlink_port *devlink_port = &mlxsw_core_port->devlink_port;\n\tstruct devlink_port_attrs attrs = {};\n\tint err;\n\n\tattrs.split = split;\n\tattrs.lanes = lanes;\n\tattrs.splittable = splittable;\n\tattrs.flavour = flavour;\n\tattrs.phys.port_number = port_number;\n\tattrs.phys.split_subport_number = split_port_subnumber;\n\tmemcpy(attrs.switch_id.id, switch_id, switch_id_len);\n\tattrs.switch_id.id_len = switch_id_len;\n\tmlxsw_core_port->local_port = local_port;\n\tdevlink_port_attrs_set(devlink_port, &attrs);\n\tif (slot_index) {\n\t\tstruct mlxsw_linecard *linecard;\n\n\t\tlinecard = mlxsw_linecard_get(mlxsw_core->linecards,\n\t\t\t\t\t      slot_index);\n\t\tmlxsw_core_port->linecard = linecard;\n\t\tdevlink_port_linecard_set(devlink_port,\n\t\t\t\t\t  linecard->devlink_linecard);\n\t}\n\terr = devl_port_register_with_ops(devlink, devlink_port, local_port,\n\t\t\t\t\t  &mlxsw_devlink_port_ops);\n\tif (err)\n\t\tmemset(mlxsw_core_port, 0, sizeof(*mlxsw_core_port));\n\treturn err;\n}\n\nstatic void __mlxsw_core_port_fini(struct mlxsw_core *mlxsw_core, u16 local_port)\n{\n\tstruct mlxsw_core_port *mlxsw_core_port =\n\t\t\t\t\t&mlxsw_core->ports[local_port];\n\tstruct devlink_port *devlink_port = &mlxsw_core_port->devlink_port;\n\n\tdevl_port_unregister(devlink_port);\n\tmemset(mlxsw_core_port, 0, sizeof(*mlxsw_core_port));\n}\n\nint mlxsw_core_port_init(struct mlxsw_core *mlxsw_core, u16 local_port,\n\t\t\t u8 slot_index, u32 port_number, bool split,\n\t\t\t u32 split_port_subnumber,\n\t\t\t bool splittable, u32 lanes,\n\t\t\t const unsigned char *switch_id,\n\t\t\t unsigned char switch_id_len)\n{\n\tint err;\n\n\terr = __mlxsw_core_port_init(mlxsw_core, local_port,\n\t\t\t\t     DEVLINK_PORT_FLAVOUR_PHYSICAL, slot_index,\n\t\t\t\t     port_number, split, split_port_subnumber,\n\t\t\t\t     splittable, lanes,\n\t\t\t\t     switch_id, switch_id_len);\n\tif (err)\n\t\treturn err;\n\n\tatomic_inc(&mlxsw_core->active_ports_count);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_core_port_init);\n\nvoid mlxsw_core_port_fini(struct mlxsw_core *mlxsw_core, u16 local_port)\n{\n\tatomic_dec(&mlxsw_core->active_ports_count);\n\n\t__mlxsw_core_port_fini(mlxsw_core, local_port);\n}\nEXPORT_SYMBOL(mlxsw_core_port_fini);\n\nint mlxsw_core_cpu_port_init(struct mlxsw_core *mlxsw_core,\n\t\t\t     void *port_driver_priv,\n\t\t\t     const unsigned char *switch_id,\n\t\t\t     unsigned char switch_id_len)\n{\n\tstruct mlxsw_core_port *mlxsw_core_port =\n\t\t\t\t&mlxsw_core->ports[MLXSW_PORT_CPU_PORT];\n\tint err;\n\n\terr = __mlxsw_core_port_init(mlxsw_core, MLXSW_PORT_CPU_PORT,\n\t\t\t\t     DEVLINK_PORT_FLAVOUR_CPU,\n\t\t\t\t     0, 0, false, 0, false, 0,\n\t\t\t\t     switch_id, switch_id_len);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_core_port->port_driver_priv = port_driver_priv;\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_core_cpu_port_init);\n\nvoid mlxsw_core_cpu_port_fini(struct mlxsw_core *mlxsw_core)\n{\n\t__mlxsw_core_port_fini(mlxsw_core, MLXSW_PORT_CPU_PORT);\n}\nEXPORT_SYMBOL(mlxsw_core_cpu_port_fini);\n\nvoid mlxsw_core_port_netdev_link(struct mlxsw_core *mlxsw_core, u16 local_port,\n\t\t\t\t void *port_driver_priv, struct net_device *dev)\n{\n\tstruct mlxsw_core_port *mlxsw_core_port =\n\t\t\t\t\t&mlxsw_core->ports[local_port];\n\tstruct devlink_port *devlink_port = &mlxsw_core_port->devlink_port;\n\n\tmlxsw_core_port->port_driver_priv = port_driver_priv;\n\tSET_NETDEV_DEVLINK_PORT(dev, devlink_port);\n}\nEXPORT_SYMBOL(mlxsw_core_port_netdev_link);\n\nstruct devlink_port *\nmlxsw_core_port_devlink_port_get(struct mlxsw_core *mlxsw_core,\n\t\t\t\t u16 local_port)\n{\n\tstruct mlxsw_core_port *mlxsw_core_port =\n\t\t\t\t\t&mlxsw_core->ports[local_port];\n\tstruct devlink_port *devlink_port = &mlxsw_core_port->devlink_port;\n\n\treturn devlink_port;\n}\nEXPORT_SYMBOL(mlxsw_core_port_devlink_port_get);\n\nstruct mlxsw_linecard *\nmlxsw_core_port_linecard_get(struct mlxsw_core *mlxsw_core,\n\t\t\t     u16 local_port)\n{\n\tstruct mlxsw_core_port *mlxsw_core_port =\n\t\t\t\t\t&mlxsw_core->ports[local_port];\n\n\treturn mlxsw_core_port->linecard;\n}\n\nvoid mlxsw_core_ports_remove_selected(struct mlxsw_core *mlxsw_core,\n\t\t\t\t      bool (*selector)(void *priv, u16 local_port),\n\t\t\t\t      void *priv)\n{\n\tif (WARN_ON_ONCE(!mlxsw_core->driver->ports_remove_selected))\n\t\treturn;\n\tmlxsw_core->driver->ports_remove_selected(mlxsw_core, selector, priv);\n}\n\nstruct mlxsw_env *mlxsw_core_env(const struct mlxsw_core *mlxsw_core)\n{\n\treturn mlxsw_core->env;\n}\n\nstatic void mlxsw_core_buf_dump_dbg(struct mlxsw_core *mlxsw_core,\n\t\t\t\t    const char *buf, size_t size)\n{\n\t__be32 *m = (__be32 *) buf;\n\tint i;\n\tint count = size / sizeof(__be32);\n\n\tfor (i = count - 1; i >= 0; i--)\n\t\tif (m[i])\n\t\t\tbreak;\n\ti++;\n\tcount = i ? i : 1;\n\tfor (i = 0; i < count; i += 4)\n\t\tdev_dbg(mlxsw_core->bus_info->dev, \"%04x - %08x %08x %08x %08x\\n\",\n\t\t\ti * 4, be32_to_cpu(m[i]), be32_to_cpu(m[i + 1]),\n\t\t\tbe32_to_cpu(m[i + 2]), be32_to_cpu(m[i + 3]));\n}\n\nint mlxsw_cmd_exec(struct mlxsw_core *mlxsw_core, u16 opcode, u8 opcode_mod,\n\t\t   u32 in_mod, bool out_mbox_direct, bool reset_ok,\n\t\t   char *in_mbox, size_t in_mbox_size,\n\t\t   char *out_mbox, size_t out_mbox_size)\n{\n\tu8 status;\n\tint err;\n\n\tBUG_ON(in_mbox_size % sizeof(u32) || out_mbox_size % sizeof(u32));\n\tif (!mlxsw_core->bus->cmd_exec)\n\t\treturn -EOPNOTSUPP;\n\n\tdev_dbg(mlxsw_core->bus_info->dev, \"Cmd exec (opcode=%x(%s),opcode_mod=%x,in_mod=%x)\\n\",\n\t\topcode, mlxsw_cmd_opcode_str(opcode), opcode_mod, in_mod);\n\tif (in_mbox) {\n\t\tdev_dbg(mlxsw_core->bus_info->dev, \"Input mailbox:\\n\");\n\t\tmlxsw_core_buf_dump_dbg(mlxsw_core, in_mbox, in_mbox_size);\n\t}\n\n\terr = mlxsw_core->bus->cmd_exec(mlxsw_core->bus_priv, opcode,\n\t\t\t\t\topcode_mod, in_mod, out_mbox_direct,\n\t\t\t\t\tin_mbox, in_mbox_size,\n\t\t\t\t\tout_mbox, out_mbox_size, &status);\n\n\tif (!err && out_mbox) {\n\t\tdev_dbg(mlxsw_core->bus_info->dev, \"Output mailbox:\\n\");\n\t\tmlxsw_core_buf_dump_dbg(mlxsw_core, out_mbox, out_mbox_size);\n\t}\n\n\tif (reset_ok && err == -EIO &&\n\t    status == MLXSW_CMD_STATUS_RUNNING_RESET) {\n\t\terr = 0;\n\t} else if (err == -EIO && status != MLXSW_CMD_STATUS_OK) {\n\t\tdev_err(mlxsw_core->bus_info->dev, \"Cmd exec failed (opcode=%x(%s),opcode_mod=%x,in_mod=%x,status=%x(%s))\\n\",\n\t\t\topcode, mlxsw_cmd_opcode_str(opcode), opcode_mod,\n\t\t\tin_mod, status, mlxsw_cmd_status_str(status));\n\t} else if (err == -ETIMEDOUT) {\n\t\tdev_err(mlxsw_core->bus_info->dev, \"Cmd exec timed-out (opcode=%x(%s),opcode_mod=%x,in_mod=%x)\\n\",\n\t\t\topcode, mlxsw_cmd_opcode_str(opcode), opcode_mod,\n\t\t\tin_mod);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL(mlxsw_cmd_exec);\n\nint mlxsw_core_schedule_dw(struct delayed_work *dwork, unsigned long delay)\n{\n\treturn queue_delayed_work(mlxsw_wq, dwork, delay);\n}\nEXPORT_SYMBOL(mlxsw_core_schedule_dw);\n\nbool mlxsw_core_schedule_work(struct work_struct *work)\n{\n\treturn queue_work(mlxsw_owq, work);\n}\nEXPORT_SYMBOL(mlxsw_core_schedule_work);\n\nvoid mlxsw_core_flush_owq(void)\n{\n\tflush_workqueue(mlxsw_owq);\n}\nEXPORT_SYMBOL(mlxsw_core_flush_owq);\n\nint mlxsw_core_kvd_sizes_get(struct mlxsw_core *mlxsw_core,\n\t\t\t     const struct mlxsw_config_profile *profile,\n\t\t\t     u64 *p_single_size, u64 *p_double_size,\n\t\t\t     u64 *p_linear_size)\n{\n\tstruct mlxsw_driver *driver = mlxsw_core->driver;\n\n\tif (!driver->kvd_sizes_get)\n\t\treturn -EINVAL;\n\n\treturn driver->kvd_sizes_get(mlxsw_core, profile,\n\t\t\t\t     p_single_size, p_double_size,\n\t\t\t\t     p_linear_size);\n}\nEXPORT_SYMBOL(mlxsw_core_kvd_sizes_get);\n\nint mlxsw_core_resources_query(struct mlxsw_core *mlxsw_core, char *mbox,\n\t\t\t       struct mlxsw_res *res)\n{\n\tint index, i;\n\tu64 data;\n\tu16 id;\n\tint err;\n\n\tmlxsw_cmd_mbox_zero(mbox);\n\n\tfor (index = 0; index < MLXSW_CMD_QUERY_RESOURCES_MAX_QUERIES;\n\t     index++) {\n\t\terr = mlxsw_cmd_query_resources(mlxsw_core, mbox, index);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfor (i = 0; i < MLXSW_CMD_QUERY_RESOURCES_PER_QUERY; i++) {\n\t\t\tid = mlxsw_cmd_mbox_query_resource_id_get(mbox, i);\n\t\t\tdata = mlxsw_cmd_mbox_query_resource_data_get(mbox, i);\n\n\t\t\tif (id == MLXSW_CMD_QUERY_RESOURCES_TABLE_END_ID)\n\t\t\t\treturn 0;\n\n\t\t\tmlxsw_res_parse(res, id, data);\n\t\t}\n\t}\n\n\t \n\treturn -EIO;\n}\nEXPORT_SYMBOL(mlxsw_core_resources_query);\n\nu32 mlxsw_core_read_frc_h(struct mlxsw_core *mlxsw_core)\n{\n\treturn mlxsw_core->bus->read_frc_h(mlxsw_core->bus_priv);\n}\nEXPORT_SYMBOL(mlxsw_core_read_frc_h);\n\nu32 mlxsw_core_read_frc_l(struct mlxsw_core *mlxsw_core)\n{\n\treturn mlxsw_core->bus->read_frc_l(mlxsw_core->bus_priv);\n}\nEXPORT_SYMBOL(mlxsw_core_read_frc_l);\n\nu32 mlxsw_core_read_utc_sec(struct mlxsw_core *mlxsw_core)\n{\n\treturn mlxsw_core->bus->read_utc_sec(mlxsw_core->bus_priv);\n}\nEXPORT_SYMBOL(mlxsw_core_read_utc_sec);\n\nu32 mlxsw_core_read_utc_nsec(struct mlxsw_core *mlxsw_core)\n{\n\treturn mlxsw_core->bus->read_utc_nsec(mlxsw_core->bus_priv);\n}\nEXPORT_SYMBOL(mlxsw_core_read_utc_nsec);\n\nbool mlxsw_core_sdq_supports_cqe_v2(struct mlxsw_core *mlxsw_core)\n{\n\treturn mlxsw_core->driver->sdq_supports_cqe_v2;\n}\nEXPORT_SYMBOL(mlxsw_core_sdq_supports_cqe_v2);\n\nstatic int __init mlxsw_core_module_init(void)\n{\n\tint err;\n\n\terr = mlxsw_linecard_driver_register();\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_wq = alloc_workqueue(mlxsw_core_driver_name, 0, 0);\n\tif (!mlxsw_wq) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_workqueue;\n\t}\n\tmlxsw_owq = alloc_ordered_workqueue(\"%s_ordered\", 0,\n\t\t\t\t\t    mlxsw_core_driver_name);\n\tif (!mlxsw_owq) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_ordered_workqueue;\n\t}\n\treturn 0;\n\nerr_alloc_ordered_workqueue:\n\tdestroy_workqueue(mlxsw_wq);\nerr_alloc_workqueue:\n\tmlxsw_linecard_driver_unregister();\n\treturn err;\n}\n\nstatic void __exit mlxsw_core_module_exit(void)\n{\n\tdestroy_workqueue(mlxsw_owq);\n\tdestroy_workqueue(mlxsw_wq);\n\tmlxsw_linecard_driver_unregister();\n}\n\nmodule_init(mlxsw_core_module_init);\nmodule_exit(mlxsw_core_module_exit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Jiri Pirko <jiri@mellanox.com>\");\nMODULE_DESCRIPTION(\"Mellanox switch device core driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}