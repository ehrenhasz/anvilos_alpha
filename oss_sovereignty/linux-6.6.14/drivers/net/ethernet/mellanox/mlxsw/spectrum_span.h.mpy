{
  "module_name": "spectrum_span.h",
  "hash_id": "1a33fae64f920db45ee20fbd7cbfb21be05fe0efff02d7b405af023fd17d9b54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.h",
  "human_readable_source": " \n \n\n#ifndef _MLXSW_SPECTRUM_SPAN_H\n#define _MLXSW_SPECTRUM_SPAN_H\n\n#include <linux/types.h>\n#include <linux/if_ether.h>\n#include <linux/refcount.h>\n\n#include \"spectrum_router.h\"\n\nstruct mlxsw_sp;\nstruct mlxsw_sp_port;\n\n \nenum mlxsw_sp_span_session_id {\n\tMLXSW_SP_SPAN_SESSION_ID_BUFFER,\n\tMLXSW_SP_SPAN_SESSION_ID_SAMPLING,\n\n\t__MLXSW_SP_SPAN_SESSION_ID_MAX = 8,\n};\n\nstruct mlxsw_sp_span_parms {\n\tstruct mlxsw_sp_port *dest_port;  \n\tunsigned int ttl;\n\tunsigned char dmac[ETH_ALEN];\n\tunsigned char smac[ETH_ALEN];\n\tunion mlxsw_sp_l3addr daddr;\n\tunion mlxsw_sp_l3addr saddr;\n\tu16 vid;\n\tu16 policer_id;\n\tbool policer_enable;\n\tenum mlxsw_sp_span_session_id session_id;\n};\n\nenum mlxsw_sp_span_trigger {\n\tMLXSW_SP_SPAN_TRIGGER_INGRESS,\n\tMLXSW_SP_SPAN_TRIGGER_EGRESS,\n\tMLXSW_SP_SPAN_TRIGGER_TAIL_DROP,\n\tMLXSW_SP_SPAN_TRIGGER_EARLY_DROP,\n\tMLXSW_SP_SPAN_TRIGGER_ECN,\n};\n\nstruct mlxsw_sp_span_trigger_parms {\n\tint span_id;\n\tu32 probability_rate;\n};\n\nstruct mlxsw_sp_span_agent_parms {\n\tconst struct net_device *to_dev;\n\tu16 policer_id;\n\tbool policer_enable;\n\tenum mlxsw_sp_span_session_id session_id;\n};\n\nstruct mlxsw_sp_span_entry_ops;\n\nstruct mlxsw_sp_span_ops {\n\tint (*init)(struct mlxsw_sp *mlxsw_sp);\n\tint (*policer_id_base_set)(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   u16 policer_id_base);\n};\n\nstruct mlxsw_sp_span_entry {\n\tconst struct net_device *to_dev;\n\tconst struct mlxsw_sp_span_entry_ops *ops;\n\tstruct mlxsw_sp_span_parms parms;\n\trefcount_t ref_count;\n\tint id;\n};\n\nstruct mlxsw_sp_span_entry_ops {\n\tbool is_static;\n\tbool (*can_handle)(const struct net_device *to_dev);\n\tint (*parms_set)(struct mlxsw_sp *mlxsw_sp,\n\t\t\t const struct net_device *to_dev,\n\t\t\t struct mlxsw_sp_span_parms *sparmsp);\n\tint (*configure)(struct mlxsw_sp_span_entry *span_entry,\n\t\t\t struct mlxsw_sp_span_parms sparms);\n\tvoid (*deconfigure)(struct mlxsw_sp_span_entry *span_entry);\n};\n\nint mlxsw_sp_span_init(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_span_fini(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_span_respin(struct mlxsw_sp *mlxsw_sp);\n\nstruct mlxsw_sp_span_entry *\nmlxsw_sp_span_entry_find_by_port(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t const struct net_device *to_dev);\nvoid mlxsw_sp_span_entry_invalidate(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_span_entry *span_entry);\nint mlxsw_sp_span_agent_get(struct mlxsw_sp *mlxsw_sp, int *p_span_id,\n\t\t\t    const struct mlxsw_sp_span_agent_parms *parms);\nvoid mlxsw_sp_span_agent_put(struct mlxsw_sp *mlxsw_sp, int span_id);\nint mlxsw_sp_span_analyzed_port_get(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    bool ingress);\nvoid mlxsw_sp_span_analyzed_port_put(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t     bool ingress);\nint mlxsw_sp_span_agent_bind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     enum mlxsw_sp_span_trigger trigger,\n\t\t\t     struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t     const struct mlxsw_sp_span_trigger_parms *parms);\nvoid\nmlxsw_sp_span_agent_unbind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   enum mlxsw_sp_span_trigger trigger,\n\t\t\t   struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t   const struct mlxsw_sp_span_trigger_parms *parms);\nint mlxsw_sp_span_trigger_enable(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t enum mlxsw_sp_span_trigger trigger, u8 tc);\nvoid mlxsw_sp_span_trigger_disable(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t   enum mlxsw_sp_span_trigger trigger, u8 tc);\nbool mlxsw_sp_span_trigger_is_ingress(enum mlxsw_sp_span_trigger trigger);\n\nextern const struct mlxsw_sp_span_ops mlxsw_sp1_span_ops;\nextern const struct mlxsw_sp_span_ops mlxsw_sp2_span_ops;\nextern const struct mlxsw_sp_span_ops mlxsw_sp3_span_ops;\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}