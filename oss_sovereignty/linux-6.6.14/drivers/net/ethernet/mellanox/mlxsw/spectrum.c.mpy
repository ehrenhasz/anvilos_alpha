{
  "module_name": "spectrum.c",
  "hash_id": "7c73ceac82b614e33cb7829706d0072bb4fb59d7e9562fad62e2c381f8b2fd3f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/skbuff.h>\n#include <linux/if_vlan.h>\n#include <linux/if_bridge.h>\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/list.h>\n#include <linux/notifier.h>\n#include <linux/dcbnl.h>\n#include <linux/inetdevice.h>\n#include <linux/netlink.h>\n#include <linux/jhash.h>\n#include <linux/log2.h>\n#include <linux/refcount.h>\n#include <linux/rhashtable.h>\n#include <net/switchdev.h>\n#include <net/pkt_cls.h>\n#include <net/netevent.h>\n#include <net/addrconf.h>\n#include <linux/ptp_classify.h>\n\n#include \"spectrum.h\"\n#include \"pci.h\"\n#include \"core.h\"\n#include \"core_env.h\"\n#include \"reg.h\"\n#include \"port.h\"\n#include \"trap.h\"\n#include \"txheader.h\"\n#include \"spectrum_cnt.h\"\n#include \"spectrum_dpipe.h\"\n#include \"spectrum_acl_flex_actions.h\"\n#include \"spectrum_span.h\"\n#include \"spectrum_ptp.h\"\n#include \"spectrum_trap.h\"\n\n#define MLXSW_SP_FWREV_MINOR 2010\n#define MLXSW_SP_FWREV_SUBMINOR 1006\n\n#define MLXSW_SP1_FWREV_MAJOR 13\n#define MLXSW_SP1_FWREV_CAN_RESET_MINOR 1702\n\nstatic const struct mlxsw_fw_rev mlxsw_sp1_fw_rev = {\n\t.major = MLXSW_SP1_FWREV_MAJOR,\n\t.minor = MLXSW_SP_FWREV_MINOR,\n\t.subminor = MLXSW_SP_FWREV_SUBMINOR,\n\t.can_reset_minor = MLXSW_SP1_FWREV_CAN_RESET_MINOR,\n};\n\n#define MLXSW_SP1_FW_FILENAME \\\n\t\"mellanox/mlxsw_spectrum-\" __stringify(MLXSW_SP1_FWREV_MAJOR) \\\n\t\".\" __stringify(MLXSW_SP_FWREV_MINOR) \\\n\t\".\" __stringify(MLXSW_SP_FWREV_SUBMINOR) \".mfa2\"\n\n#define MLXSW_SP2_FWREV_MAJOR 29\n\nstatic const struct mlxsw_fw_rev mlxsw_sp2_fw_rev = {\n\t.major = MLXSW_SP2_FWREV_MAJOR,\n\t.minor = MLXSW_SP_FWREV_MINOR,\n\t.subminor = MLXSW_SP_FWREV_SUBMINOR,\n};\n\n#define MLXSW_SP2_FW_FILENAME \\\n\t\"mellanox/mlxsw_spectrum2-\" __stringify(MLXSW_SP2_FWREV_MAJOR) \\\n\t\".\" __stringify(MLXSW_SP_FWREV_MINOR) \\\n\t\".\" __stringify(MLXSW_SP_FWREV_SUBMINOR) \".mfa2\"\n\n#define MLXSW_SP3_FWREV_MAJOR 30\n\nstatic const struct mlxsw_fw_rev mlxsw_sp3_fw_rev = {\n\t.major = MLXSW_SP3_FWREV_MAJOR,\n\t.minor = MLXSW_SP_FWREV_MINOR,\n\t.subminor = MLXSW_SP_FWREV_SUBMINOR,\n};\n\n#define MLXSW_SP3_FW_FILENAME \\\n\t\"mellanox/mlxsw_spectrum3-\" __stringify(MLXSW_SP3_FWREV_MAJOR) \\\n\t\".\" __stringify(MLXSW_SP_FWREV_MINOR) \\\n\t\".\" __stringify(MLXSW_SP_FWREV_SUBMINOR) \".mfa2\"\n\n#define MLXSW_SP_LINECARDS_INI_BUNDLE_FILENAME \\\n\t\"mellanox/lc_ini_bundle_\" \\\n\t__stringify(MLXSW_SP_FWREV_MINOR) \"_\" \\\n\t__stringify(MLXSW_SP_FWREV_SUBMINOR) \".bin\"\n\nstatic const char mlxsw_sp1_driver_name[] = \"mlxsw_spectrum\";\nstatic const char mlxsw_sp2_driver_name[] = \"mlxsw_spectrum2\";\nstatic const char mlxsw_sp3_driver_name[] = \"mlxsw_spectrum3\";\nstatic const char mlxsw_sp4_driver_name[] = \"mlxsw_spectrum4\";\n\nstatic const unsigned char mlxsw_sp1_mac_mask[ETH_ALEN] = {\n\t0xff, 0xff, 0xff, 0xff, 0xfc, 0x00\n};\nstatic const unsigned char mlxsw_sp2_mac_mask[ETH_ALEN] = {\n\t0xff, 0xff, 0xff, 0xff, 0xf0, 0x00\n};\n\n \nMLXSW_ITEM32(tx, hdr, version, 0x00, 28, 4);\n\n \nMLXSW_ITEM32(tx, hdr, ctl, 0x00, 26, 2);\n\n \nMLXSW_ITEM32(tx, hdr, proto, 0x00, 21, 3);\n\n \nMLXSW_ITEM32(tx, hdr, rx_is_router, 0x00, 19, 1);\n\n \nMLXSW_ITEM32(tx, hdr, fid_valid, 0x00, 16, 1);\n\n \nMLXSW_ITEM32(tx, hdr, swid, 0x00, 12, 3);\n\n \nMLXSW_ITEM32(tx, hdr, control_tclass, 0x00, 6, 1);\n\n \nMLXSW_ITEM32(tx, hdr, etclass, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(tx, hdr, port_mid, 0x04, 16, 16);\n\n \nMLXSW_ITEM32(tx, hdr, fid, 0x08, 16, 16);\n\n \nMLXSW_ITEM32(tx, hdr, type, 0x0C, 0, 4);\n\nint mlxsw_sp_flow_counter_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      unsigned int counter_index, u64 *packets,\n\t\t\t      u64 *bytes)\n{\n\tchar mgpc_pl[MLXSW_REG_MGPC_LEN];\n\tint err;\n\n\tmlxsw_reg_mgpc_pack(mgpc_pl, counter_index, MLXSW_REG_MGPC_OPCODE_NOP,\n\t\t\t    MLXSW_REG_FLOW_COUNTER_SET_TYPE_PACKETS_BYTES);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(mgpc), mgpc_pl);\n\tif (err)\n\t\treturn err;\n\tif (packets)\n\t\t*packets = mlxsw_reg_mgpc_packet_counter_get(mgpc_pl);\n\tif (bytes)\n\t\t*bytes = mlxsw_reg_mgpc_byte_counter_get(mgpc_pl);\n\treturn 0;\n}\n\nstatic int mlxsw_sp_flow_counter_clear(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       unsigned int counter_index)\n{\n\tchar mgpc_pl[MLXSW_REG_MGPC_LEN];\n\n\tmlxsw_reg_mgpc_pack(mgpc_pl, counter_index, MLXSW_REG_MGPC_OPCODE_CLEAR,\n\t\t\t    MLXSW_REG_FLOW_COUNTER_SET_TYPE_PACKETS_BYTES);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mgpc), mgpc_pl);\n}\n\nint mlxsw_sp_flow_counter_alloc(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tunsigned int *p_counter_index)\n{\n\tint err;\n\n\terr = mlxsw_sp_counter_alloc(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_FLOW,\n\t\t\t\t     p_counter_index);\n\tif (err)\n\t\treturn err;\n\terr = mlxsw_sp_flow_counter_clear(mlxsw_sp, *p_counter_index);\n\tif (err)\n\t\tgoto err_counter_clear;\n\treturn 0;\n\nerr_counter_clear:\n\tmlxsw_sp_counter_free(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_FLOW,\n\t\t\t      *p_counter_index);\n\treturn err;\n}\n\nvoid mlxsw_sp_flow_counter_free(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tunsigned int counter_index)\n{\n\t mlxsw_sp_counter_free(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_FLOW,\n\t\t\t       counter_index);\n}\n\nvoid mlxsw_sp_txhdr_construct(struct sk_buff *skb,\n\t\t\t      const struct mlxsw_tx_info *tx_info)\n{\n\tchar *txhdr = skb_push(skb, MLXSW_TXHDR_LEN);\n\n\tmemset(txhdr, 0, MLXSW_TXHDR_LEN);\n\n\tmlxsw_tx_hdr_version_set(txhdr, MLXSW_TXHDR_VERSION_1);\n\tmlxsw_tx_hdr_ctl_set(txhdr, MLXSW_TXHDR_ETH_CTL);\n\tmlxsw_tx_hdr_proto_set(txhdr, MLXSW_TXHDR_PROTO_ETH);\n\tmlxsw_tx_hdr_swid_set(txhdr, 0);\n\tmlxsw_tx_hdr_control_tclass_set(txhdr, 1);\n\tmlxsw_tx_hdr_port_mid_set(txhdr, tx_info->local_port);\n\tmlxsw_tx_hdr_type_set(txhdr, MLXSW_TXHDR_TYPE_CONTROL);\n}\n\nint\nmlxsw_sp_txhdr_ptp_data_construct(struct mlxsw_core *mlxsw_core,\n\t\t\t\t  struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  const struct mlxsw_tx_info *tx_info)\n{\n\tchar *txhdr;\n\tu16 max_fid;\n\tint err;\n\n\tif (skb_cow_head(skb, MLXSW_TXHDR_LEN)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_skb_cow_head;\n\t}\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_core, FID)) {\n\t\terr = -EIO;\n\t\tgoto err_res_valid;\n\t}\n\tmax_fid = MLXSW_CORE_RES_GET(mlxsw_core, FID);\n\n\ttxhdr = skb_push(skb, MLXSW_TXHDR_LEN);\n\tmemset(txhdr, 0, MLXSW_TXHDR_LEN);\n\n\tmlxsw_tx_hdr_version_set(txhdr, MLXSW_TXHDR_VERSION_1);\n\tmlxsw_tx_hdr_proto_set(txhdr, MLXSW_TXHDR_PROTO_ETH);\n\tmlxsw_tx_hdr_rx_is_router_set(txhdr, true);\n\tmlxsw_tx_hdr_fid_valid_set(txhdr, true);\n\tmlxsw_tx_hdr_fid_set(txhdr, max_fid + tx_info->local_port - 1);\n\tmlxsw_tx_hdr_type_set(txhdr, MLXSW_TXHDR_TYPE_DATA);\n\treturn 0;\n\nerr_res_valid:\nerr_skb_cow_head:\n\tthis_cpu_inc(mlxsw_sp_port->pcpu_stats->tx_dropped);\n\tdev_kfree_skb_any(skb);\n\treturn err;\n}\n\nstatic bool mlxsw_sp_skb_requires_ts(struct sk_buff *skb)\n{\n\tunsigned int type;\n\n\tif (!(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP))\n\t\treturn false;\n\n\ttype = ptp_classify_raw(skb);\n\treturn !!ptp_parse_header(skb, type);\n}\n\nstatic int mlxsw_sp_txhdr_handle(struct mlxsw_core *mlxsw_core,\n\t\t\t\t struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t const struct mlxsw_tx_info *tx_info)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\n\t \n\tif (unlikely(mlxsw_sp_skb_requires_ts(skb)))\n\t\treturn mlxsw_sp->ptp_ops->txhdr_construct(mlxsw_core,\n\t\t\t\t\t\t\t  mlxsw_sp_port, skb,\n\t\t\t\t\t\t\t  tx_info);\n\n\tif (skb_cow_head(skb, MLXSW_TXHDR_LEN)) {\n\t\tthis_cpu_inc(mlxsw_sp_port->pcpu_stats->tx_dropped);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\tmlxsw_sp_txhdr_construct(skb, tx_info);\n\treturn 0;\n}\n\nenum mlxsw_reg_spms_state mlxsw_sp_stp_spms_state(u8 state)\n{\n\tswitch (state) {\n\tcase BR_STATE_FORWARDING:\n\t\treturn MLXSW_REG_SPMS_STATE_FORWARDING;\n\tcase BR_STATE_LEARNING:\n\t\treturn MLXSW_REG_SPMS_STATE_LEARNING;\n\tcase BR_STATE_LISTENING:\n\tcase BR_STATE_DISABLED:\n\tcase BR_STATE_BLOCKING:\n\t\treturn MLXSW_REG_SPMS_STATE_DISCARDING;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nint mlxsw_sp_port_vid_stp_set(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid,\n\t\t\t      u8 state)\n{\n\tenum mlxsw_reg_spms_state spms_state = mlxsw_sp_stp_spms_state(state);\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar *spms_pl;\n\tint err;\n\n\tspms_pl = kmalloc(MLXSW_REG_SPMS_LEN, GFP_KERNEL);\n\tif (!spms_pl)\n\t\treturn -ENOMEM;\n\tmlxsw_reg_spms_pack(spms_pl, mlxsw_sp_port->local_port);\n\tmlxsw_reg_spms_vid_pack(spms_pl, vid, spms_state);\n\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(spms), spms_pl);\n\tkfree(spms_pl);\n\treturn err;\n}\n\nstatic int mlxsw_sp_base_mac_get(struct mlxsw_sp *mlxsw_sp)\n{\n\tchar spad_pl[MLXSW_REG_SPAD_LEN] = {0};\n\tint err;\n\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(spad), spad_pl);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_spad_base_mac_memcpy_from(spad_pl, mlxsw_sp->base_mac);\n\treturn 0;\n}\n\nint mlxsw_sp_port_admin_status_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t   bool is_up)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar paos_pl[MLXSW_REG_PAOS_LEN];\n\n\tmlxsw_reg_paos_pack(paos_pl, mlxsw_sp_port->local_port,\n\t\t\t    is_up ? MLXSW_PORT_ADMIN_STATUS_UP :\n\t\t\t    MLXSW_PORT_ADMIN_STATUS_DOWN);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(paos), paos_pl);\n}\n\nstatic int mlxsw_sp_port_dev_addr_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      const unsigned char *addr)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar ppad_pl[MLXSW_REG_PPAD_LEN];\n\n\tmlxsw_reg_ppad_pack(ppad_pl, true, mlxsw_sp_port->local_port);\n\tmlxsw_reg_ppad_mac_memcpy_to(ppad_pl, addr);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ppad), ppad_pl);\n}\n\nstatic int mlxsw_sp_port_dev_addr_init(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\n\teth_hw_addr_gen(mlxsw_sp_port->dev, mlxsw_sp->base_mac,\n\t\t\tmlxsw_sp_port->local_port);\n\treturn mlxsw_sp_port_dev_addr_set(mlxsw_sp_port,\n\t\t\t\t\t  mlxsw_sp_port->dev->dev_addr);\n}\n\nstatic int mlxsw_sp_port_max_mtu_get(struct mlxsw_sp_port *mlxsw_sp_port, int *p_max_mtu)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar pmtu_pl[MLXSW_REG_PMTU_LEN];\n\tint err;\n\n\tmlxsw_reg_pmtu_pack(pmtu_pl, mlxsw_sp_port->local_port, 0);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(pmtu), pmtu_pl);\n\tif (err)\n\t\treturn err;\n\n\t*p_max_mtu = mlxsw_reg_pmtu_max_mtu_get(pmtu_pl);\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_mtu_set(struct mlxsw_sp_port *mlxsw_sp_port, u16 mtu)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar pmtu_pl[MLXSW_REG_PMTU_LEN];\n\n\tmtu += MLXSW_TXHDR_LEN + ETH_HLEN;\n\tif (mtu > mlxsw_sp_port->max_mtu)\n\t\treturn -EINVAL;\n\n\tmlxsw_reg_pmtu_pack(pmtu_pl, mlxsw_sp_port->local_port, mtu);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pmtu), pmtu_pl);\n}\n\nstatic int mlxsw_sp_port_swid_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  u16 local_port, u8 swid)\n{\n\tchar pspa_pl[MLXSW_REG_PSPA_LEN];\n\n\tmlxsw_reg_pspa_pack(pspa_pl, swid, local_port);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pspa), pspa_pl);\n}\n\nint mlxsw_sp_port_vp_mode_set(struct mlxsw_sp_port *mlxsw_sp_port, bool enable)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar svpe_pl[MLXSW_REG_SVPE_LEN];\n\n\tmlxsw_reg_svpe_pack(svpe_pl, mlxsw_sp_port->local_port, enable);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(svpe), svpe_pl);\n}\n\nint mlxsw_sp_port_vid_learning_set(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid,\n\t\t\t\t   bool learn_enable)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar *spvmlr_pl;\n\tint err;\n\n\tspvmlr_pl = kmalloc(MLXSW_REG_SPVMLR_LEN, GFP_KERNEL);\n\tif (!spvmlr_pl)\n\t\treturn -ENOMEM;\n\tmlxsw_reg_spvmlr_pack(spvmlr_pl, mlxsw_sp_port->local_port, vid, vid,\n\t\t\t      learn_enable);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(spvmlr), spvmlr_pl);\n\tkfree(spvmlr_pl);\n\treturn err;\n}\n\nint mlxsw_sp_port_security_set(struct mlxsw_sp_port *mlxsw_sp_port, bool enable)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar spfsr_pl[MLXSW_REG_SPFSR_LEN];\n\tint err;\n\n\tif (mlxsw_sp_port->security == enable)\n\t\treturn 0;\n\n\tmlxsw_reg_spfsr_pack(spfsr_pl, mlxsw_sp_port->local_port, enable);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(spfsr), spfsr_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_sp_port->security = enable;\n\treturn 0;\n}\n\nint mlxsw_sp_ethtype_to_sver_type(u16 ethtype, u8 *p_sver_type)\n{\n\tswitch (ethtype) {\n\tcase ETH_P_8021Q:\n\t\t*p_sver_type = 0;\n\t\tbreak;\n\tcase ETH_P_8021AD:\n\t\t*p_sver_type = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint mlxsw_sp_port_egress_ethtype_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t     u16 ethtype)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar spevet_pl[MLXSW_REG_SPEVET_LEN];\n\tu8 sver_type;\n\tint err;\n\n\terr = mlxsw_sp_ethtype_to_sver_type(ethtype, &sver_type);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_spevet_pack(spevet_pl, mlxsw_sp_port->local_port, sver_type);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(spevet), spevet_pl);\n}\n\nstatic int __mlxsw_sp_port_pvid_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    u16 vid, u16 ethtype)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar spvid_pl[MLXSW_REG_SPVID_LEN];\n\tu8 sver_type;\n\tint err;\n\n\terr = mlxsw_sp_ethtype_to_sver_type(ethtype, &sver_type);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_spvid_pack(spvid_pl, mlxsw_sp_port->local_port, vid,\n\t\t\t     sver_type);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(spvid), spvid_pl);\n}\n\nstatic int mlxsw_sp_port_allow_untagged_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t    bool allow)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar spaft_pl[MLXSW_REG_SPAFT_LEN];\n\n\tmlxsw_reg_spaft_pack(spaft_pl, mlxsw_sp_port->local_port, allow);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(spaft), spaft_pl);\n}\n\nint mlxsw_sp_port_pvid_set(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid,\n\t\t\t   u16 ethtype)\n{\n\tint err;\n\n\tif (!vid) {\n\t\terr = mlxsw_sp_port_allow_untagged_set(mlxsw_sp_port, false);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\terr = __mlxsw_sp_port_pvid_set(mlxsw_sp_port, vid, ethtype);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = mlxsw_sp_port_allow_untagged_set(mlxsw_sp_port, true);\n\t\tif (err)\n\t\t\tgoto err_port_allow_untagged_set;\n\t}\n\n\tmlxsw_sp_port->pvid = vid;\n\treturn 0;\n\nerr_port_allow_untagged_set:\n\t__mlxsw_sp_port_pvid_set(mlxsw_sp_port, mlxsw_sp_port->pvid, ethtype);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_port_system_port_mapping_set(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar sspr_pl[MLXSW_REG_SSPR_LEN];\n\n\tmlxsw_reg_sspr_pack(sspr_pl, mlxsw_sp_port->local_port);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sspr), sspr_pl);\n}\n\nstatic int\nmlxsw_sp_port_module_info_parse(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tu16 local_port, char *pmlp_pl,\n\t\t\t\tstruct mlxsw_sp_port_mapping *port_mapping)\n{\n\tbool separate_rxtx;\n\tu8 first_lane;\n\tu8 slot_index;\n\tu8 module;\n\tu8 width;\n\tint i;\n\n\tmodule = mlxsw_reg_pmlp_module_get(pmlp_pl, 0);\n\tslot_index = mlxsw_reg_pmlp_slot_index_get(pmlp_pl, 0);\n\twidth = mlxsw_reg_pmlp_width_get(pmlp_pl);\n\tseparate_rxtx = mlxsw_reg_pmlp_rxtx_get(pmlp_pl);\n\tfirst_lane = mlxsw_reg_pmlp_tx_lane_get(pmlp_pl, 0);\n\n\tif (width && !is_power_of_2(width)) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Unsupported module config: width value is not power of 2\\n\",\n\t\t\tlocal_port);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < width; i++) {\n\t\tif (mlxsw_reg_pmlp_module_get(pmlp_pl, i) != module) {\n\t\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Unsupported module config: contains multiple modules\\n\",\n\t\t\t\tlocal_port);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (mlxsw_reg_pmlp_slot_index_get(pmlp_pl, i) != slot_index) {\n\t\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Unsupported module config: contains multiple slot indexes\\n\",\n\t\t\t\tlocal_port);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (separate_rxtx &&\n\t\t    mlxsw_reg_pmlp_tx_lane_get(pmlp_pl, i) !=\n\t\t    mlxsw_reg_pmlp_rx_lane_get(pmlp_pl, i)) {\n\t\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Unsupported module config: TX and RX lane numbers are different\\n\",\n\t\t\t\tlocal_port);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (mlxsw_reg_pmlp_tx_lane_get(pmlp_pl, i) != i + first_lane) {\n\t\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Unsupported module config: TX and RX lane numbers are not sequential\\n\",\n\t\t\t\tlocal_port);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tport_mapping->module = module;\n\tport_mapping->slot_index = slot_index;\n\tport_mapping->width = width;\n\tport_mapping->module_width = width;\n\tport_mapping->lane = mlxsw_reg_pmlp_tx_lane_get(pmlp_pl, 0);\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_port_module_info_get(struct mlxsw_sp *mlxsw_sp, u16 local_port,\n\t\t\t      struct mlxsw_sp_port_mapping *port_mapping)\n{\n\tchar pmlp_pl[MLXSW_REG_PMLP_LEN];\n\tint err;\n\n\tmlxsw_reg_pmlp_pack(pmlp_pl, local_port);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(pmlp), pmlp_pl);\n\tif (err)\n\t\treturn err;\n\treturn mlxsw_sp_port_module_info_parse(mlxsw_sp, local_port,\n\t\t\t\t\t       pmlp_pl, port_mapping);\n}\n\nstatic int\nmlxsw_sp_port_module_map(struct mlxsw_sp *mlxsw_sp, u16 local_port,\n\t\t\t const struct mlxsw_sp_port_mapping *port_mapping)\n{\n\tchar pmlp_pl[MLXSW_REG_PMLP_LEN];\n\tint i, err;\n\n\tmlxsw_env_module_port_map(mlxsw_sp->core, port_mapping->slot_index,\n\t\t\t\t  port_mapping->module);\n\n\tmlxsw_reg_pmlp_pack(pmlp_pl, local_port);\n\tmlxsw_reg_pmlp_width_set(pmlp_pl, port_mapping->width);\n\tfor (i = 0; i < port_mapping->width; i++) {\n\t\tmlxsw_reg_pmlp_slot_index_set(pmlp_pl, i,\n\t\t\t\t\t      port_mapping->slot_index);\n\t\tmlxsw_reg_pmlp_module_set(pmlp_pl, i, port_mapping->module);\n\t\tmlxsw_reg_pmlp_tx_lane_set(pmlp_pl, i, port_mapping->lane + i);  \n\t}\n\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pmlp), pmlp_pl);\n\tif (err)\n\t\tgoto err_pmlp_write;\n\treturn 0;\n\nerr_pmlp_write:\n\tmlxsw_env_module_port_unmap(mlxsw_sp->core, port_mapping->slot_index,\n\t\t\t\t    port_mapping->module);\n\treturn err;\n}\n\nstatic void mlxsw_sp_port_module_unmap(struct mlxsw_sp *mlxsw_sp, u16 local_port,\n\t\t\t\t       u8 slot_index, u8 module)\n{\n\tchar pmlp_pl[MLXSW_REG_PMLP_LEN];\n\n\tmlxsw_reg_pmlp_pack(pmlp_pl, local_port);\n\tmlxsw_reg_pmlp_width_set(pmlp_pl, 0);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pmlp), pmlp_pl);\n\tmlxsw_env_module_port_unmap(mlxsw_sp->core, slot_index, module);\n}\n\nstatic int mlxsw_sp_port_open(struct net_device *dev)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tint err;\n\n\terr = mlxsw_env_module_port_up(mlxsw_sp->core,\n\t\t\t\t       mlxsw_sp_port->mapping.slot_index,\n\t\t\t\t       mlxsw_sp_port->mapping.module);\n\tif (err)\n\t\treturn err;\n\terr = mlxsw_sp_port_admin_status_set(mlxsw_sp_port, true);\n\tif (err)\n\t\tgoto err_port_admin_status_set;\n\tnetif_start_queue(dev);\n\treturn 0;\n\nerr_port_admin_status_set:\n\tmlxsw_env_module_port_down(mlxsw_sp->core,\n\t\t\t\t   mlxsw_sp_port->mapping.slot_index,\n\t\t\t\t   mlxsw_sp_port->mapping.module);\n\treturn err;\n}\n\nstatic int mlxsw_sp_port_stop(struct net_device *dev)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\n\tnetif_stop_queue(dev);\n\tmlxsw_sp_port_admin_status_set(mlxsw_sp_port, false);\n\tmlxsw_env_module_port_down(mlxsw_sp->core,\n\t\t\t\t   mlxsw_sp_port->mapping.slot_index,\n\t\t\t\t   mlxsw_sp_port->mapping.module);\n\treturn 0;\n}\n\nstatic netdev_tx_t mlxsw_sp_port_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_port_pcpu_stats *pcpu_stats;\n\tconst struct mlxsw_tx_info tx_info = {\n\t\t.local_port = mlxsw_sp_port->local_port,\n\t\t.is_emad = false,\n\t};\n\tu64 len;\n\tint err;\n\n\tmemset(skb->cb, 0, sizeof(struct mlxsw_skb_cb));\n\n\tif (mlxsw_core_skb_transmit_busy(mlxsw_sp->core, &tx_info))\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (eth_skb_pad(skb)) {\n\t\tthis_cpu_inc(mlxsw_sp_port->pcpu_stats->tx_dropped);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\terr = mlxsw_sp_txhdr_handle(mlxsw_sp->core, mlxsw_sp_port, skb,\n\t\t\t\t    &tx_info);\n\tif (err)\n\t\treturn NETDEV_TX_OK;\n\n\t \n\tlen = skb->len - MLXSW_TXHDR_LEN;\n\n\t \n\terr = mlxsw_core_skb_transmit(mlxsw_sp->core, skb, &tx_info);\n\n\tif (!err) {\n\t\tpcpu_stats = this_cpu_ptr(mlxsw_sp_port->pcpu_stats);\n\t\tu64_stats_update_begin(&pcpu_stats->syncp);\n\t\tpcpu_stats->tx_packets++;\n\t\tpcpu_stats->tx_bytes += len;\n\t\tu64_stats_update_end(&pcpu_stats->syncp);\n\t} else {\n\t\tthis_cpu_inc(mlxsw_sp_port->pcpu_stats->tx_dropped);\n\t\tdev_kfree_skb_any(skb);\n\t}\n\treturn NETDEV_TX_OK;\n}\n\nstatic void mlxsw_sp_set_rx_mode(struct net_device *dev)\n{\n}\n\nstatic int mlxsw_sp_port_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tstruct sockaddr *addr = p;\n\tint err;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = mlxsw_sp_port_dev_addr_set(mlxsw_sp_port, addr->sa_data);\n\tif (err)\n\t\treturn err;\n\teth_hw_addr_set(dev, addr->sa_data);\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_change_mtu(struct net_device *dev, int mtu)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tstruct mlxsw_sp_hdroom orig_hdroom;\n\tstruct mlxsw_sp_hdroom hdroom;\n\tint err;\n\n\torig_hdroom = *mlxsw_sp_port->hdroom;\n\n\thdroom = orig_hdroom;\n\thdroom.mtu = mtu;\n\tmlxsw_sp_hdroom_bufs_reset_sizes(mlxsw_sp_port, &hdroom);\n\n\terr = mlxsw_sp_hdroom_configure(mlxsw_sp_port, &hdroom);\n\tif (err) {\n\t\tnetdev_err(dev, \"Failed to configure port's headroom\\n\");\n\t\treturn err;\n\t}\n\n\terr = mlxsw_sp_port_mtu_set(mlxsw_sp_port, mtu);\n\tif (err)\n\t\tgoto err_port_mtu_set;\n\tdev->mtu = mtu;\n\treturn 0;\n\nerr_port_mtu_set:\n\tmlxsw_sp_hdroom_configure(mlxsw_sp_port, &orig_hdroom);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_port_get_sw_stats64(const struct net_device *dev,\n\t\t\t     struct rtnl_link_stats64 *stats)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tstruct mlxsw_sp_port_pcpu_stats *p;\n\tu64 rx_packets, rx_bytes, tx_packets, tx_bytes;\n\tu32 tx_dropped = 0;\n\tunsigned int start;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tp = per_cpu_ptr(mlxsw_sp_port->pcpu_stats, i);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&p->syncp);\n\t\t\trx_packets\t= p->rx_packets;\n\t\t\trx_bytes\t= p->rx_bytes;\n\t\t\ttx_packets\t= p->tx_packets;\n\t\t\ttx_bytes\t= p->tx_bytes;\n\t\t} while (u64_stats_fetch_retry(&p->syncp, start));\n\n\t\tstats->rx_packets\t+= rx_packets;\n\t\tstats->rx_bytes\t\t+= rx_bytes;\n\t\tstats->tx_packets\t+= tx_packets;\n\t\tstats->tx_bytes\t\t+= tx_bytes;\n\t\t \n\t\ttx_dropped\t+= p->tx_dropped;\n\t}\n\tstats->tx_dropped\t= tx_dropped;\n\treturn 0;\n}\n\nstatic bool mlxsw_sp_port_has_offload_stats(const struct net_device *dev, int attr_id)\n{\n\tswitch (attr_id) {\n\tcase IFLA_OFFLOAD_XSTATS_CPU_HIT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int mlxsw_sp_port_get_offload_stats(int attr_id, const struct net_device *dev,\n\t\t\t\t\t   void *sp)\n{\n\tswitch (attr_id) {\n\tcase IFLA_OFFLOAD_XSTATS_CPU_HIT:\n\t\treturn mlxsw_sp_port_get_sw_stats64(dev, sp);\n\t}\n\n\treturn -EINVAL;\n}\n\nint mlxsw_sp_port_get_stats_raw(struct net_device *dev, int grp,\n\t\t\t\tint prio, char *ppcnt_pl)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\n\tmlxsw_reg_ppcnt_pack(ppcnt_pl, mlxsw_sp_port->local_port, grp, prio);\n\treturn mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ppcnt), ppcnt_pl);\n}\n\nstatic int mlxsw_sp_port_get_hw_stats(struct net_device *dev,\n\t\t\t\t      struct rtnl_link_stats64 *stats)\n{\n\tchar ppcnt_pl[MLXSW_REG_PPCNT_LEN];\n\tint err;\n\n\terr = mlxsw_sp_port_get_stats_raw(dev, MLXSW_REG_PPCNT_IEEE_8023_CNT,\n\t\t\t\t\t  0, ppcnt_pl);\n\tif (err)\n\t\tgoto out;\n\n\tstats->tx_packets =\n\t\tmlxsw_reg_ppcnt_a_frames_transmitted_ok_get(ppcnt_pl);\n\tstats->rx_packets =\n\t\tmlxsw_reg_ppcnt_a_frames_received_ok_get(ppcnt_pl);\n\tstats->tx_bytes =\n\t\tmlxsw_reg_ppcnt_a_octets_transmitted_ok_get(ppcnt_pl);\n\tstats->rx_bytes =\n\t\tmlxsw_reg_ppcnt_a_octets_received_ok_get(ppcnt_pl);\n\tstats->multicast =\n\t\tmlxsw_reg_ppcnt_a_multicast_frames_received_ok_get(ppcnt_pl);\n\n\tstats->rx_crc_errors =\n\t\tmlxsw_reg_ppcnt_a_frame_check_sequence_errors_get(ppcnt_pl);\n\tstats->rx_frame_errors =\n\t\tmlxsw_reg_ppcnt_a_alignment_errors_get(ppcnt_pl);\n\n\tstats->rx_length_errors = (\n\t\tmlxsw_reg_ppcnt_a_in_range_length_errors_get(ppcnt_pl) +\n\t\tmlxsw_reg_ppcnt_a_out_of_range_length_field_get(ppcnt_pl) +\n\t\tmlxsw_reg_ppcnt_a_frame_too_long_errors_get(ppcnt_pl));\n\n\tstats->rx_errors = (stats->rx_crc_errors +\n\t\tstats->rx_frame_errors + stats->rx_length_errors);\n\nout:\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_port_get_hw_xstats(struct net_device *dev,\n\t\t\t    struct mlxsw_sp_port_xstats *xstats)\n{\n\tchar ppcnt_pl[MLXSW_REG_PPCNT_LEN];\n\tint err, i;\n\n\terr = mlxsw_sp_port_get_stats_raw(dev, MLXSW_REG_PPCNT_EXT_CNT, 0,\n\t\t\t\t\t  ppcnt_pl);\n\tif (!err)\n\t\txstats->ecn = mlxsw_reg_ppcnt_ecn_marked_get(ppcnt_pl);\n\n\tfor (i = 0; i < TC_MAX_QUEUE; i++) {\n\t\terr = mlxsw_sp_port_get_stats_raw(dev,\n\t\t\t\t\t\t  MLXSW_REG_PPCNT_TC_CONG_CNT,\n\t\t\t\t\t\t  i, ppcnt_pl);\n\t\tif (err)\n\t\t\tgoto tc_cnt;\n\n\t\txstats->wred_drop[i] =\n\t\t\tmlxsw_reg_ppcnt_wred_discard_get(ppcnt_pl);\n\t\txstats->tc_ecn[i] = mlxsw_reg_ppcnt_ecn_marked_tc_get(ppcnt_pl);\n\ntc_cnt:\n\t\terr = mlxsw_sp_port_get_stats_raw(dev, MLXSW_REG_PPCNT_TC_CNT,\n\t\t\t\t\t\t  i, ppcnt_pl);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\txstats->backlog[i] =\n\t\t\tmlxsw_reg_ppcnt_tc_transmit_queue_get(ppcnt_pl);\n\t\txstats->tail_drop[i] =\n\t\t\tmlxsw_reg_ppcnt_tc_no_buffer_discard_uc_get(ppcnt_pl);\n\t}\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\terr = mlxsw_sp_port_get_stats_raw(dev, MLXSW_REG_PPCNT_PRIO_CNT,\n\t\t\t\t\t\t  i, ppcnt_pl);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\txstats->tx_packets[i] = mlxsw_reg_ppcnt_tx_frames_get(ppcnt_pl);\n\t\txstats->tx_bytes[i] = mlxsw_reg_ppcnt_tx_octets_get(ppcnt_pl);\n\t}\n}\n\nstatic void update_stats_cache(struct work_struct *work)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port =\n\t\tcontainer_of(work, struct mlxsw_sp_port,\n\t\t\t     periodic_hw_stats.update_dw.work);\n\n\tif (!netif_carrier_ok(mlxsw_sp_port->dev))\n\t\t \n\t\tgoto out;\n\n\tmlxsw_sp_port_get_hw_stats(mlxsw_sp_port->dev,\n\t\t\t\t   &mlxsw_sp_port->periodic_hw_stats.stats);\n\tmlxsw_sp_port_get_hw_xstats(mlxsw_sp_port->dev,\n\t\t\t\t    &mlxsw_sp_port->periodic_hw_stats.xstats);\n\nout:\n\tmlxsw_core_schedule_dw(&mlxsw_sp_port->periodic_hw_stats.update_dw,\n\t\t\t       MLXSW_HW_STATS_UPDATE_TIME);\n}\n\n \nstatic void\nmlxsw_sp_port_get_stats64(struct net_device *dev,\n\t\t\t  struct rtnl_link_stats64 *stats)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\n\tmemcpy(stats, &mlxsw_sp_port->periodic_hw_stats.stats, sizeof(*stats));\n}\n\nstatic int __mlxsw_sp_port_vlan_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    u16 vid_begin, u16 vid_end,\n\t\t\t\t    bool is_member, bool untagged)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar *spvm_pl;\n\tint err;\n\n\tspvm_pl = kmalloc(MLXSW_REG_SPVM_LEN, GFP_KERNEL);\n\tif (!spvm_pl)\n\t\treturn -ENOMEM;\n\n\tmlxsw_reg_spvm_pack(spvm_pl, mlxsw_sp_port->local_port,\tvid_begin,\n\t\t\t    vid_end, is_member, untagged);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(spvm), spvm_pl);\n\tkfree(spvm_pl);\n\treturn err;\n}\n\nint mlxsw_sp_port_vlan_set(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid_begin,\n\t\t\t   u16 vid_end, bool is_member, bool untagged)\n{\n\tu16 vid, vid_e;\n\tint err;\n\n\tfor (vid = vid_begin; vid <= vid_end;\n\t     vid += MLXSW_REG_SPVM_REC_MAX_COUNT) {\n\t\tvid_e = min((u16) (vid + MLXSW_REG_SPVM_REC_MAX_COUNT - 1),\n\t\t\t    vid_end);\n\n\t\terr = __mlxsw_sp_port_vlan_set(mlxsw_sp_port, vid, vid_e,\n\t\t\t\t\t       is_member, untagged);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_port_vlan_flush(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t     bool flush_default)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan, *tmp;\n\n\tlist_for_each_entry_safe(mlxsw_sp_port_vlan, tmp,\n\t\t\t\t &mlxsw_sp_port->vlans_list, list) {\n\t\tif (!flush_default &&\n\t\t    mlxsw_sp_port_vlan->vid == MLXSW_SP_DEFAULT_VID)\n\t\t\tcontinue;\n\t\tmlxsw_sp_port_vlan_destroy(mlxsw_sp_port_vlan);\n\t}\n}\n\nstatic void\nmlxsw_sp_port_vlan_cleanup(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan)\n{\n\tif (mlxsw_sp_port_vlan->bridge_port)\n\t\tmlxsw_sp_port_vlan_bridge_leave(mlxsw_sp_port_vlan);\n\telse if (mlxsw_sp_port_vlan->fid)\n\t\tmlxsw_sp_port_vlan_router_leave(mlxsw_sp_port_vlan);\n}\n\nstruct mlxsw_sp_port_vlan *\nmlxsw_sp_port_vlan_create(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tbool untagged = vid == MLXSW_SP_DEFAULT_VID;\n\tint err;\n\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);\n\tif (mlxsw_sp_port_vlan)\n\t\treturn ERR_PTR(-EEXIST);\n\n\terr = mlxsw_sp_port_vlan_set(mlxsw_sp_port, vid, vid, true, untagged);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmlxsw_sp_port_vlan = kzalloc(sizeof(*mlxsw_sp_port_vlan), GFP_KERNEL);\n\tif (!mlxsw_sp_port_vlan) {\n\t\terr = -ENOMEM;\n\t\tgoto err_port_vlan_alloc;\n\t}\n\n\tmlxsw_sp_port_vlan->mlxsw_sp_port = mlxsw_sp_port;\n\tmlxsw_sp_port_vlan->vid = vid;\n\tlist_add(&mlxsw_sp_port_vlan->list, &mlxsw_sp_port->vlans_list);\n\n\treturn mlxsw_sp_port_vlan;\n\nerr_port_vlan_alloc:\n\tmlxsw_sp_port_vlan_set(mlxsw_sp_port, vid, vid, false, false);\n\treturn ERR_PTR(err);\n}\n\nvoid mlxsw_sp_port_vlan_destroy(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;\n\tu16 vid = mlxsw_sp_port_vlan->vid;\n\n\tmlxsw_sp_port_vlan_cleanup(mlxsw_sp_port_vlan);\n\tlist_del(&mlxsw_sp_port_vlan->list);\n\tkfree(mlxsw_sp_port_vlan);\n\tmlxsw_sp_port_vlan_set(mlxsw_sp_port, vid, vid, false, false);\n}\n\nstatic int mlxsw_sp_port_add_vid(struct net_device *dev,\n\t\t\t\t __be16 __always_unused proto, u16 vid)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\n\t \n\tif (!vid)\n\t\treturn 0;\n\n\treturn PTR_ERR_OR_ZERO(mlxsw_sp_port_vlan_create(mlxsw_sp_port, vid));\n}\n\nint mlxsw_sp_port_kill_vid(struct net_device *dev,\n\t\t\t   __be16 __always_unused proto, u16 vid)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\n\t \n\tif (!vid)\n\t\treturn 0;\n\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);\n\tif (!mlxsw_sp_port_vlan)\n\t\treturn 0;\n\tmlxsw_sp_port_vlan_destroy(mlxsw_sp_port_vlan);\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_setup_tc_block(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t   struct flow_block_offload *f)\n{\n\tswitch (f->binder_type) {\n\tcase FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS:\n\t\treturn mlxsw_sp_setup_tc_block_clsact(mlxsw_sp_port, f, true);\n\tcase FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS:\n\t\treturn mlxsw_sp_setup_tc_block_clsact(mlxsw_sp_port, f, false);\n\tcase FLOW_BLOCK_BINDER_TYPE_RED_EARLY_DROP:\n\t\treturn mlxsw_sp_setup_tc_block_qevent_early_drop(mlxsw_sp_port, f);\n\tcase FLOW_BLOCK_BINDER_TYPE_RED_MARK:\n\t\treturn mlxsw_sp_setup_tc_block_qevent_mark(mlxsw_sp_port, f);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int mlxsw_sp_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t\t     void *type_data)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK:\n\t\treturn mlxsw_sp_setup_tc_block(mlxsw_sp_port, type_data);\n\tcase TC_SETUP_QDISC_RED:\n\t\treturn mlxsw_sp_setup_tc_red(mlxsw_sp_port, type_data);\n\tcase TC_SETUP_QDISC_PRIO:\n\t\treturn mlxsw_sp_setup_tc_prio(mlxsw_sp_port, type_data);\n\tcase TC_SETUP_QDISC_ETS:\n\t\treturn mlxsw_sp_setup_tc_ets(mlxsw_sp_port, type_data);\n\tcase TC_SETUP_QDISC_TBF:\n\t\treturn mlxsw_sp_setup_tc_tbf(mlxsw_sp_port, type_data);\n\tcase TC_SETUP_QDISC_FIFO:\n\t\treturn mlxsw_sp_setup_tc_fifo(mlxsw_sp_port, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int mlxsw_sp_feature_hw_tc(struct net_device *dev, bool enable)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\n\tif (!enable) {\n\t\tif (mlxsw_sp_flow_block_rule_count(mlxsw_sp_port->ing_flow_block) ||\n\t\t    mlxsw_sp_flow_block_rule_count(mlxsw_sp_port->eg_flow_block)) {\n\t\t\tnetdev_err(dev, \"Active offloaded tc filters, can't turn hw_tc_offload off\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmlxsw_sp_flow_block_disable_inc(mlxsw_sp_port->ing_flow_block);\n\t\tmlxsw_sp_flow_block_disable_inc(mlxsw_sp_port->eg_flow_block);\n\t} else {\n\t\tmlxsw_sp_flow_block_disable_dec(mlxsw_sp_port->ing_flow_block);\n\t\tmlxsw_sp_flow_block_disable_dec(mlxsw_sp_port->eg_flow_block);\n\t}\n\treturn 0;\n}\n\nstatic int mlxsw_sp_feature_loopback(struct net_device *dev, bool enable)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tchar pplr_pl[MLXSW_REG_PPLR_LEN];\n\tint err;\n\n\tif (netif_running(dev))\n\t\tmlxsw_sp_port_admin_status_set(mlxsw_sp_port, false);\n\n\tmlxsw_reg_pplr_pack(pplr_pl, mlxsw_sp_port->local_port, enable);\n\terr = mlxsw_reg_write(mlxsw_sp_port->mlxsw_sp->core, MLXSW_REG(pplr),\n\t\t\t      pplr_pl);\n\n\tif (netif_running(dev))\n\t\tmlxsw_sp_port_admin_status_set(mlxsw_sp_port, true);\n\n\treturn err;\n}\n\ntypedef int (*mlxsw_sp_feature_handler)(struct net_device *dev, bool enable);\n\nstatic int mlxsw_sp_handle_feature(struct net_device *dev,\n\t\t\t\t   netdev_features_t wanted_features,\n\t\t\t\t   netdev_features_t feature,\n\t\t\t\t   mlxsw_sp_feature_handler feature_handler)\n{\n\tnetdev_features_t changes = wanted_features ^ dev->features;\n\tbool enable = !!(wanted_features & feature);\n\tint err;\n\n\tif (!(changes & feature))\n\t\treturn 0;\n\n\terr = feature_handler(dev, enable);\n\tif (err) {\n\t\tnetdev_err(dev, \"%s feature %pNF failed, err %d\\n\",\n\t\t\t   enable ? \"Enable\" : \"Disable\", &feature, err);\n\t\treturn err;\n\t}\n\n\tif (enable)\n\t\tdev->features |= feature;\n\telse\n\t\tdev->features &= ~feature;\n\n\treturn 0;\n}\nstatic int mlxsw_sp_set_features(struct net_device *dev,\n\t\t\t\t netdev_features_t features)\n{\n\tnetdev_features_t oper_features = dev->features;\n\tint err = 0;\n\n\terr |= mlxsw_sp_handle_feature(dev, features, NETIF_F_HW_TC,\n\t\t\t\t       mlxsw_sp_feature_hw_tc);\n\terr |= mlxsw_sp_handle_feature(dev, features, NETIF_F_LOOPBACK,\n\t\t\t\t       mlxsw_sp_feature_loopback);\n\n\tif (err) {\n\t\tdev->features = oper_features;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_hwtstamp_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      struct ifreq *ifr)\n{\n\tstruct hwtstamp_config config;\n\tint err;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\terr = mlxsw_sp_port->mlxsw_sp->ptp_ops->hwtstamp_set(mlxsw_sp_port,\n\t\t\t\t\t\t\t     &config);\n\tif (err)\n\t\treturn err;\n\n\tif (copy_to_user(ifr->ifr_data, &config, sizeof(config)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_hwtstamp_get(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      struct ifreq *ifr)\n{\n\tstruct hwtstamp_config config;\n\tint err;\n\n\terr = mlxsw_sp_port->mlxsw_sp->ptp_ops->hwtstamp_get(mlxsw_sp_port,\n\t\t\t\t\t\t\t     &config);\n\tif (err)\n\t\treturn err;\n\n\tif (copy_to_user(ifr->ifr_data, &config, sizeof(config)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic inline void mlxsw_sp_port_ptp_clear(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct hwtstamp_config config = {0};\n\n\tmlxsw_sp_port->mlxsw_sp->ptp_ops->hwtstamp_set(mlxsw_sp_port, &config);\n}\n\nstatic int\nmlxsw_sp_port_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\n\tswitch (cmd) {\n\tcase SIOCSHWTSTAMP:\n\t\treturn mlxsw_sp_port_hwtstamp_set(mlxsw_sp_port, ifr);\n\tcase SIOCGHWTSTAMP:\n\t\treturn mlxsw_sp_port_hwtstamp_get(mlxsw_sp_port, ifr);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct net_device_ops mlxsw_sp_port_netdev_ops = {\n\t.ndo_open\t\t= mlxsw_sp_port_open,\n\t.ndo_stop\t\t= mlxsw_sp_port_stop,\n\t.ndo_start_xmit\t\t= mlxsw_sp_port_xmit,\n\t.ndo_setup_tc           = mlxsw_sp_setup_tc,\n\t.ndo_set_rx_mode\t= mlxsw_sp_set_rx_mode,\n\t.ndo_set_mac_address\t= mlxsw_sp_port_set_mac_address,\n\t.ndo_change_mtu\t\t= mlxsw_sp_port_change_mtu,\n\t.ndo_get_stats64\t= mlxsw_sp_port_get_stats64,\n\t.ndo_has_offload_stats\t= mlxsw_sp_port_has_offload_stats,\n\t.ndo_get_offload_stats\t= mlxsw_sp_port_get_offload_stats,\n\t.ndo_vlan_rx_add_vid\t= mlxsw_sp_port_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= mlxsw_sp_port_kill_vid,\n\t.ndo_set_features\t= mlxsw_sp_set_features,\n\t.ndo_eth_ioctl\t\t= mlxsw_sp_port_ioctl,\n};\n\nstatic int\nmlxsw_sp_port_speed_by_width_set(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu32 eth_proto_cap, eth_proto_admin, eth_proto_oper;\n\tconst struct mlxsw_sp_port_type_speed_ops *ops;\n\tchar ptys_pl[MLXSW_REG_PTYS_LEN];\n\tu32 eth_proto_cap_masked;\n\tint err;\n\n\tops = mlxsw_sp->port_type_speed_ops;\n\n\t \n\tops->reg_ptys_eth_pack(mlxsw_sp, ptys_pl, mlxsw_sp_port->local_port,\n\t\t\t       0, false);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ptys), ptys_pl);\n\tif (err)\n\t\treturn err;\n\n\tops->reg_ptys_eth_unpack(mlxsw_sp, ptys_pl, &eth_proto_cap,\n\t\t\t\t &eth_proto_admin, &eth_proto_oper);\n\teth_proto_cap_masked = ops->ptys_proto_cap_masked_get(eth_proto_cap);\n\tops->reg_ptys_eth_pack(mlxsw_sp, ptys_pl, mlxsw_sp_port->local_port,\n\t\t\t       eth_proto_cap_masked,\n\t\t\t       mlxsw_sp_port->link.autoneg);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ptys), ptys_pl);\n}\n\nint mlxsw_sp_port_speed_get(struct mlxsw_sp_port *mlxsw_sp_port, u32 *speed)\n{\n\tconst struct mlxsw_sp_port_type_speed_ops *port_type_speed_ops;\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar ptys_pl[MLXSW_REG_PTYS_LEN];\n\tu32 eth_proto_oper;\n\tint err;\n\n\tport_type_speed_ops = mlxsw_sp->port_type_speed_ops;\n\tport_type_speed_ops->reg_ptys_eth_pack(mlxsw_sp, ptys_pl,\n\t\t\t\t\t       mlxsw_sp_port->local_port, 0,\n\t\t\t\t\t       false);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ptys), ptys_pl);\n\tif (err)\n\t\treturn err;\n\tport_type_speed_ops->reg_ptys_eth_unpack(mlxsw_sp, ptys_pl, NULL, NULL,\n\t\t\t\t\t\t &eth_proto_oper);\n\t*speed = port_type_speed_ops->from_ptys_speed(mlxsw_sp, eth_proto_oper);\n\treturn 0;\n}\n\nint mlxsw_sp_port_ets_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t  enum mlxsw_reg_qeec_hr hr, u8 index, u8 next_index,\n\t\t\t  bool dwrr, u8 dwrr_weight)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar qeec_pl[MLXSW_REG_QEEC_LEN];\n\n\tmlxsw_reg_qeec_pack(qeec_pl, mlxsw_sp_port->local_port, hr, index,\n\t\t\t    next_index);\n\tmlxsw_reg_qeec_de_set(qeec_pl, true);\n\tmlxsw_reg_qeec_dwrr_set(qeec_pl, dwrr);\n\tmlxsw_reg_qeec_dwrr_weight_set(qeec_pl, dwrr_weight);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qeec), qeec_pl);\n}\n\nint mlxsw_sp_port_ets_maxrate_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  enum mlxsw_reg_qeec_hr hr, u8 index,\n\t\t\t\t  u8 next_index, u32 maxrate, u8 burst_size)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar qeec_pl[MLXSW_REG_QEEC_LEN];\n\n\tmlxsw_reg_qeec_pack(qeec_pl, mlxsw_sp_port->local_port, hr, index,\n\t\t\t    next_index);\n\tmlxsw_reg_qeec_mase_set(qeec_pl, true);\n\tmlxsw_reg_qeec_max_shaper_rate_set(qeec_pl, maxrate);\n\tmlxsw_reg_qeec_max_shaper_bs_set(qeec_pl, burst_size);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qeec), qeec_pl);\n}\n\nstatic int mlxsw_sp_port_min_bw_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    enum mlxsw_reg_qeec_hr hr, u8 index,\n\t\t\t\t    u8 next_index, u32 minrate)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar qeec_pl[MLXSW_REG_QEEC_LEN];\n\n\tmlxsw_reg_qeec_pack(qeec_pl, mlxsw_sp_port->local_port, hr, index,\n\t\t\t    next_index);\n\tmlxsw_reg_qeec_mise_set(qeec_pl, true);\n\tmlxsw_reg_qeec_min_shaper_rate_set(qeec_pl, minrate);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qeec), qeec_pl);\n}\n\nint mlxsw_sp_port_prio_tc_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t      u8 switch_prio, u8 tclass)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar qtct_pl[MLXSW_REG_QTCT_LEN];\n\n\tmlxsw_reg_qtct_pack(qtct_pl, mlxsw_sp_port->local_port, switch_prio,\n\t\t\t    tclass);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qtct), qtct_pl);\n}\n\nstatic int mlxsw_sp_port_ets_init(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tint err, i;\n\n\t \n\terr = mlxsw_sp_port_ets_set(mlxsw_sp_port,\n\t\t\t\t    MLXSW_REG_QEEC_HR_GROUP, 0, 0, false, 0);\n\tif (err)\n\t\treturn err;\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\terr = mlxsw_sp_port_ets_set(mlxsw_sp_port,\n\t\t\t\t\t    MLXSW_REG_QEEC_HR_SUBGROUP, i,\n\t\t\t\t\t    0, false, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\terr = mlxsw_sp_port_ets_set(mlxsw_sp_port,\n\t\t\t\t\t    MLXSW_REG_QEEC_HR_TC, i, i,\n\t\t\t\t\t    false, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mlxsw_sp_port_ets_set(mlxsw_sp_port,\n\t\t\t\t\t    MLXSW_REG_QEEC_HR_TC,\n\t\t\t\t\t    i + 8, i,\n\t\t\t\t\t    true, 100);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = mlxsw_sp_port_ets_maxrate_set(mlxsw_sp_port,\n\t\t\t\t\t    MLXSW_REG_QEEC_HR_PORT, 0, 0,\n\t\t\t\t\t    MLXSW_REG_QEEC_MAS_DIS, 0);\n\tif (err)\n\t\treturn err;\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\terr = mlxsw_sp_port_ets_maxrate_set(mlxsw_sp_port,\n\t\t\t\t\t\t    MLXSW_REG_QEEC_HR_SUBGROUP,\n\t\t\t\t\t\t    i, 0,\n\t\t\t\t\t\t    MLXSW_REG_QEEC_MAS_DIS, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\terr = mlxsw_sp_port_ets_maxrate_set(mlxsw_sp_port,\n\t\t\t\t\t\t    MLXSW_REG_QEEC_HR_TC,\n\t\t\t\t\t\t    i, i,\n\t\t\t\t\t\t    MLXSW_REG_QEEC_MAS_DIS, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mlxsw_sp_port_ets_maxrate_set(mlxsw_sp_port,\n\t\t\t\t\t\t    MLXSW_REG_QEEC_HR_TC,\n\t\t\t\t\t\t    i + 8, i,\n\t\t\t\t\t\t    MLXSW_REG_QEEC_MAS_DIS, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\terr = mlxsw_sp_port_min_bw_set(mlxsw_sp_port,\n\t\t\t\t\t       MLXSW_REG_QEEC_HR_TC,\n\t\t\t\t\t       i + 8, i,\n\t\t\t\t\t       MLXSW_REG_QEEC_MIS_MIN);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\terr = mlxsw_sp_port_prio_tc_set(mlxsw_sp_port, i, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_tc_mc_mode_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\tbool enable)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar qtctm_pl[MLXSW_REG_QTCTM_LEN];\n\n\tmlxsw_reg_qtctm_pack(qtctm_pl, mlxsw_sp_port->local_port, enable);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qtctm), qtctm_pl);\n}\n\nstatic int mlxsw_sp_port_overheat_init_val_set(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu8 slot_index = mlxsw_sp_port->mapping.slot_index;\n\tu8 module = mlxsw_sp_port->mapping.module;\n\tu64 overheat_counter;\n\tint err;\n\n\terr = mlxsw_env_module_overheat_counter_get(mlxsw_sp->core, slot_index,\n\t\t\t\t\t\t    module, &overheat_counter);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_sp_port->module_overheat_initial_val = overheat_counter;\n\treturn 0;\n}\n\nint\nmlxsw_sp_port_vlan_classification_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      bool is_8021ad_tagged,\n\t\t\t\t      bool is_8021q_tagged)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar spvc_pl[MLXSW_REG_SPVC_LEN];\n\n\tmlxsw_reg_spvc_pack(spvc_pl, mlxsw_sp_port->local_port,\n\t\t\t    is_8021ad_tagged, is_8021q_tagged);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(spvc), spvc_pl);\n}\n\nstatic int mlxsw_sp_port_label_info_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tu16 local_port, u8 *port_number,\n\t\t\t\t\tu8 *split_port_subnumber,\n\t\t\t\t\tu8 *slot_index)\n{\n\tchar pllp_pl[MLXSW_REG_PLLP_LEN];\n\tint err;\n\n\tmlxsw_reg_pllp_pack(pllp_pl, local_port);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(pllp), pllp_pl);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_pllp_unpack(pllp_pl, port_number,\n\t\t\t      split_port_subnumber, slot_index);\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_create(struct mlxsw_sp *mlxsw_sp, u16 local_port,\n\t\t\t\tbool split,\n\t\t\t\tstruct mlxsw_sp_port_mapping *port_mapping)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tu32 lanes = port_mapping->width;\n\tu8 split_port_subnumber;\n\tstruct net_device *dev;\n\tu8 port_number;\n\tu8 slot_index;\n\tbool splittable;\n\tint err;\n\n\terr = mlxsw_sp_port_module_map(mlxsw_sp, local_port, port_mapping);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to map module\\n\",\n\t\t\tlocal_port);\n\t\treturn err;\n\t}\n\n\terr = mlxsw_sp_port_swid_set(mlxsw_sp, local_port, 0);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to set SWID\\n\",\n\t\t\tlocal_port);\n\t\tgoto err_port_swid_set;\n\t}\n\n\terr = mlxsw_sp_port_label_info_get(mlxsw_sp, local_port, &port_number,\n\t\t\t\t\t   &split_port_subnumber, &slot_index);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to get port label information\\n\",\n\t\t\tlocal_port);\n\t\tgoto err_port_label_info_get;\n\t}\n\n\tsplittable = lanes > 1 && !split;\n\terr = mlxsw_core_port_init(mlxsw_sp->core, local_port, slot_index,\n\t\t\t\t   port_number, split, split_port_subnumber,\n\t\t\t\t   splittable, lanes, mlxsw_sp->base_mac,\n\t\t\t\t   sizeof(mlxsw_sp->base_mac));\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to init core port\\n\",\n\t\t\tlocal_port);\n\t\tgoto err_core_port_init;\n\t}\n\n\tdev = alloc_etherdev(sizeof(struct mlxsw_sp_port));\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_etherdev;\n\t}\n\tSET_NETDEV_DEV(dev, mlxsw_sp->bus_info->dev);\n\tdev_net_set(dev, mlxsw_sp_net(mlxsw_sp));\n\tmlxsw_sp_port = netdev_priv(dev);\n\tmlxsw_core_port_netdev_link(mlxsw_sp->core, local_port,\n\t\t\t\t    mlxsw_sp_port, dev);\n\tmlxsw_sp_port->dev = dev;\n\tmlxsw_sp_port->mlxsw_sp = mlxsw_sp;\n\tmlxsw_sp_port->local_port = local_port;\n\tmlxsw_sp_port->pvid = MLXSW_SP_DEFAULT_VID;\n\tmlxsw_sp_port->split = split;\n\tmlxsw_sp_port->mapping = *port_mapping;\n\tmlxsw_sp_port->link.autoneg = 1;\n\tINIT_LIST_HEAD(&mlxsw_sp_port->vlans_list);\n\n\tmlxsw_sp_port->pcpu_stats =\n\t\tnetdev_alloc_pcpu_stats(struct mlxsw_sp_port_pcpu_stats);\n\tif (!mlxsw_sp_port->pcpu_stats) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_stats;\n\t}\n\n\tINIT_DELAYED_WORK(&mlxsw_sp_port->periodic_hw_stats.update_dw,\n\t\t\t  &update_stats_cache);\n\n\tdev->netdev_ops = &mlxsw_sp_port_netdev_ops;\n\tdev->ethtool_ops = &mlxsw_sp_port_ethtool_ops;\n\n\terr = mlxsw_sp_port_dev_addr_init(mlxsw_sp_port);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Unable to init port mac address\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_dev_addr_init;\n\t}\n\n\tnetif_carrier_off(dev);\n\n\tdev->features |= NETIF_F_NETNS_LOCAL | NETIF_F_LLTX | NETIF_F_SG |\n\t\t\t NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_HW_TC;\n\tdev->hw_features |= NETIF_F_HW_TC | NETIF_F_LOOPBACK;\n\n\tdev->min_mtu = 0;\n\tdev->max_mtu = ETH_MAX_MTU;\n\n\t \n\tdev->needed_headroom = MLXSW_TXHDR_LEN;\n\n\terr = mlxsw_sp_port_system_port_mapping_set(mlxsw_sp_port);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to set system port mapping\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_port_system_port_mapping_set;\n\t}\n\n\terr = mlxsw_sp_port_speed_by_width_set(mlxsw_sp_port);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to enable speeds\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_port_speed_by_width_set;\n\t}\n\n\terr = mlxsw_sp->port_type_speed_ops->ptys_max_speed(mlxsw_sp_port,\n\t\t\t\t\t\t\t    &mlxsw_sp_port->max_speed);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to get maximum speed\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_max_speed_get;\n\t}\n\n\terr = mlxsw_sp_port_max_mtu_get(mlxsw_sp_port, &mlxsw_sp_port->max_mtu);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to get maximum MTU\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_port_max_mtu_get;\n\t}\n\n\terr = mlxsw_sp_port_mtu_set(mlxsw_sp_port, ETH_DATA_LEN);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to set MTU\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_port_mtu_set;\n\t}\n\n\terr = mlxsw_sp_port_admin_status_set(mlxsw_sp_port, false);\n\tif (err)\n\t\tgoto err_port_admin_status_set;\n\n\terr = mlxsw_sp_port_buffers_init(mlxsw_sp_port);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to initialize buffers\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_port_buffers_init;\n\t}\n\n\terr = mlxsw_sp_port_ets_init(mlxsw_sp_port);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to initialize ETS\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_port_ets_init;\n\t}\n\n\terr = mlxsw_sp_port_tc_mc_mode_set(mlxsw_sp_port, true);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to initialize TC MC mode\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_port_tc_mc_mode;\n\t}\n\n\t \n\terr = mlxsw_sp_port_dcb_init(mlxsw_sp_port);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to initialize DCB\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_port_dcb_init;\n\t}\n\n\terr = mlxsw_sp_port_fids_init(mlxsw_sp_port);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to initialize FIDs\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_port_fids_init;\n\t}\n\n\terr = mlxsw_sp_tc_qdisc_init(mlxsw_sp_port);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to initialize TC qdiscs\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_port_qdiscs_init;\n\t}\n\n\terr = mlxsw_sp_port_vlan_set(mlxsw_sp_port, 0, VLAN_N_VID - 1, false,\n\t\t\t\t     false);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to clear VLAN filter\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_port_vlan_clear;\n\t}\n\n\terr = mlxsw_sp_port_nve_init(mlxsw_sp_port);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to initialize NVE\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_port_nve_init;\n\t}\n\n\terr = mlxsw_sp_port_pvid_set(mlxsw_sp_port, MLXSW_SP_DEFAULT_VID,\n\t\t\t\t     ETH_P_8021Q);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to set PVID\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_port_pvid_set;\n\t}\n\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_create(mlxsw_sp_port,\n\t\t\t\t\t\t       MLXSW_SP_DEFAULT_VID);\n\tif (IS_ERR(mlxsw_sp_port_vlan)) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to create VID 1\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\terr = PTR_ERR(mlxsw_sp_port_vlan);\n\t\tgoto err_port_vlan_create;\n\t}\n\tmlxsw_sp_port->default_vlan = mlxsw_sp_port_vlan;\n\n\t \n\terr = mlxsw_sp_port_vlan_classification_set(mlxsw_sp_port, false, true);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to set default VLAN classification\\n\",\n\t\t\tlocal_port);\n\t\tgoto err_port_vlan_classification_set;\n\t}\n\n\tINIT_DELAYED_WORK(&mlxsw_sp_port->ptp.shaper_dw,\n\t\t\t  mlxsw_sp->ptp_ops->shaper_work);\n\n\tmlxsw_sp->ports[local_port] = mlxsw_sp_port;\n\n\terr = mlxsw_sp_port_overheat_init_val_set(mlxsw_sp_port);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to set overheat initial value\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_port_overheat_init_val_set;\n\t}\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port %d: Failed to register netdev\\n\",\n\t\t\tmlxsw_sp_port->local_port);\n\t\tgoto err_register_netdev;\n\t}\n\n\tmlxsw_core_schedule_dw(&mlxsw_sp_port->periodic_hw_stats.update_dw, 0);\n\treturn 0;\n\nerr_register_netdev:\nerr_port_overheat_init_val_set:\n\tmlxsw_sp_port_vlan_classification_set(mlxsw_sp_port, true, true);\nerr_port_vlan_classification_set:\n\tmlxsw_sp->ports[local_port] = NULL;\n\tmlxsw_sp_port_vlan_destroy(mlxsw_sp_port_vlan);\nerr_port_vlan_create:\nerr_port_pvid_set:\n\tmlxsw_sp_port_nve_fini(mlxsw_sp_port);\nerr_port_nve_init:\nerr_port_vlan_clear:\n\tmlxsw_sp_tc_qdisc_fini(mlxsw_sp_port);\nerr_port_qdiscs_init:\n\tmlxsw_sp_port_fids_fini(mlxsw_sp_port);\nerr_port_fids_init:\n\tmlxsw_sp_port_dcb_fini(mlxsw_sp_port);\nerr_port_dcb_init:\n\tmlxsw_sp_port_tc_mc_mode_set(mlxsw_sp_port, false);\nerr_port_tc_mc_mode:\nerr_port_ets_init:\n\tmlxsw_sp_port_buffers_fini(mlxsw_sp_port);\nerr_port_buffers_init:\nerr_port_admin_status_set:\nerr_port_mtu_set:\nerr_port_max_mtu_get:\nerr_max_speed_get:\nerr_port_speed_by_width_set:\nerr_port_system_port_mapping_set:\nerr_dev_addr_init:\n\tfree_percpu(mlxsw_sp_port->pcpu_stats);\nerr_alloc_stats:\n\tfree_netdev(dev);\nerr_alloc_etherdev:\n\tmlxsw_core_port_fini(mlxsw_sp->core, local_port);\nerr_core_port_init:\nerr_port_label_info_get:\n\tmlxsw_sp_port_swid_set(mlxsw_sp, local_port,\n\t\t\t       MLXSW_PORT_SWID_DISABLED_PORT);\nerr_port_swid_set:\n\tmlxsw_sp_port_module_unmap(mlxsw_sp, local_port,\n\t\t\t\t   port_mapping->slot_index,\n\t\t\t\t   port_mapping->module);\n\treturn err;\n}\n\nstatic void mlxsw_sp_port_remove(struct mlxsw_sp *mlxsw_sp, u16 local_port)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp->ports[local_port];\n\tu8 slot_index = mlxsw_sp_port->mapping.slot_index;\n\tu8 module = mlxsw_sp_port->mapping.module;\n\n\tcancel_delayed_work_sync(&mlxsw_sp_port->periodic_hw_stats.update_dw);\n\tcancel_delayed_work_sync(&mlxsw_sp_port->ptp.shaper_dw);\n\tunregister_netdev(mlxsw_sp_port->dev);  \n\tmlxsw_sp_port_ptp_clear(mlxsw_sp_port);\n\tmlxsw_sp_port_vlan_classification_set(mlxsw_sp_port, true, true);\n\tmlxsw_sp->ports[local_port] = NULL;\n\tmlxsw_sp_port_vlan_flush(mlxsw_sp_port, true);\n\tmlxsw_sp_port_nve_fini(mlxsw_sp_port);\n\tmlxsw_sp_tc_qdisc_fini(mlxsw_sp_port);\n\tmlxsw_sp_port_fids_fini(mlxsw_sp_port);\n\tmlxsw_sp_port_dcb_fini(mlxsw_sp_port);\n\tmlxsw_sp_port_tc_mc_mode_set(mlxsw_sp_port, false);\n\tmlxsw_sp_port_buffers_fini(mlxsw_sp_port);\n\tfree_percpu(mlxsw_sp_port->pcpu_stats);\n\tWARN_ON_ONCE(!list_empty(&mlxsw_sp_port->vlans_list));\n\tfree_netdev(mlxsw_sp_port->dev);\n\tmlxsw_core_port_fini(mlxsw_sp->core, local_port);\n\tmlxsw_sp_port_swid_set(mlxsw_sp, local_port,\n\t\t\t       MLXSW_PORT_SWID_DISABLED_PORT);\n\tmlxsw_sp_port_module_unmap(mlxsw_sp, local_port, slot_index, module);\n}\n\nstatic int mlxsw_sp_cpu_port_create(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tint err;\n\n\tmlxsw_sp_port = kzalloc(sizeof(*mlxsw_sp_port), GFP_KERNEL);\n\tif (!mlxsw_sp_port)\n\t\treturn -ENOMEM;\n\n\tmlxsw_sp_port->mlxsw_sp = mlxsw_sp;\n\tmlxsw_sp_port->local_port = MLXSW_PORT_CPU_PORT;\n\n\terr = mlxsw_core_cpu_port_init(mlxsw_sp->core,\n\t\t\t\t       mlxsw_sp_port,\n\t\t\t\t       mlxsw_sp->base_mac,\n\t\t\t\t       sizeof(mlxsw_sp->base_mac));\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize core CPU port\\n\");\n\t\tgoto err_core_cpu_port_init;\n\t}\n\n\tmlxsw_sp->ports[MLXSW_PORT_CPU_PORT] = mlxsw_sp_port;\n\treturn 0;\n\nerr_core_cpu_port_init:\n\tkfree(mlxsw_sp_port);\n\treturn err;\n}\n\nstatic void mlxsw_sp_cpu_port_remove(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port =\n\t\t\t\tmlxsw_sp->ports[MLXSW_PORT_CPU_PORT];\n\n\tmlxsw_core_cpu_port_fini(mlxsw_sp->core);\n\tmlxsw_sp->ports[MLXSW_PORT_CPU_PORT] = NULL;\n\tkfree(mlxsw_sp_port);\n}\n\nstatic bool mlxsw_sp_local_port_valid(u16 local_port)\n{\n\treturn local_port != MLXSW_PORT_CPU_PORT;\n}\n\nstatic bool mlxsw_sp_port_created(struct mlxsw_sp *mlxsw_sp, u16 local_port)\n{\n\tif (!mlxsw_sp_local_port_valid(local_port))\n\t\treturn false;\n\treturn mlxsw_sp->ports[local_port] != NULL;\n}\n\nstatic int mlxsw_sp_port_mapping_event_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   u16 local_port, bool enable)\n{\n\tchar pmecr_pl[MLXSW_REG_PMECR_LEN];\n\n\tmlxsw_reg_pmecr_pack(pmecr_pl, local_port,\n\t\t\t     enable ? MLXSW_REG_PMECR_E_GENERATE_EVENT :\n\t\t\t\t      MLXSW_REG_PMECR_E_DO_NOT_GENERATE_EVENT);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pmecr), pmecr_pl);\n}\n\nstruct mlxsw_sp_port_mapping_event {\n\tstruct list_head list;\n\tchar pmlp_pl[MLXSW_REG_PMLP_LEN];\n};\n\nstatic void mlxsw_sp_port_mapping_events_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_port_mapping_event *event, *next_event;\n\tstruct mlxsw_sp_port_mapping_events *events;\n\tstruct mlxsw_sp_port_mapping port_mapping;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct devlink *devlink;\n\tLIST_HEAD(event_queue);\n\tu16 local_port;\n\tint err;\n\n\tevents = container_of(work, struct mlxsw_sp_port_mapping_events, work);\n\tmlxsw_sp = container_of(events, struct mlxsw_sp, port_mapping_events);\n\tdevlink = priv_to_devlink(mlxsw_sp->core);\n\n\tspin_lock_bh(&events->queue_lock);\n\tlist_splice_init(&events->queue, &event_queue);\n\tspin_unlock_bh(&events->queue_lock);\n\n\tlist_for_each_entry_safe(event, next_event, &event_queue, list) {\n\t\tlocal_port = mlxsw_reg_pmlp_local_port_get(event->pmlp_pl);\n\t\terr = mlxsw_sp_port_module_info_parse(mlxsw_sp, local_port,\n\t\t\t\t\t\t      event->pmlp_pl, &port_mapping);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON_ONCE(!port_mapping.width))\n\t\t\tgoto out;\n\n\t\tdevl_lock(devlink);\n\n\t\tif (!mlxsw_sp_port_created(mlxsw_sp, local_port))\n\t\t\tmlxsw_sp_port_create(mlxsw_sp, local_port,\n\t\t\t\t\t     false, &port_mapping);\n\t\telse\n\t\t\tWARN_ON_ONCE(1);\n\n\t\tdevl_unlock(devlink);\n\n\t\tmlxsw_sp->port_mapping[local_port] = port_mapping;\n\nout:\n\t\tkfree(event);\n\t}\n}\n\nstatic void\nmlxsw_sp_port_mapping_listener_func(const struct mlxsw_reg_info *reg,\n\t\t\t\t    char *pmlp_pl, void *priv)\n{\n\tstruct mlxsw_sp_port_mapping_events *events;\n\tstruct mlxsw_sp_port_mapping_event *event;\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\tu16 local_port;\n\n\tlocal_port = mlxsw_reg_pmlp_local_port_get(pmlp_pl);\n\tif (WARN_ON_ONCE(!mlxsw_sp_local_port_is_valid(mlxsw_sp, local_port)))\n\t\treturn;\n\n\tevents = &mlxsw_sp->port_mapping_events;\n\tevent = kmalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event)\n\t\treturn;\n\tmemcpy(event->pmlp_pl, pmlp_pl, sizeof(event->pmlp_pl));\n\tspin_lock(&events->queue_lock);\n\tlist_add_tail(&event->list, &events->queue);\n\tspin_unlock(&events->queue_lock);\n\tmlxsw_core_schedule_work(&events->work);\n}\n\nstatic void\n__mlxsw_sp_port_mapping_events_cancel(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_port_mapping_event *event, *next_event;\n\tstruct mlxsw_sp_port_mapping_events *events;\n\n\tevents = &mlxsw_sp->port_mapping_events;\n\n\t \n\tcancel_work_sync(&events->work);\n\tlist_for_each_entry_safe(event, next_event, &events->queue, list) {\n\t\tlist_del(&event->list);\n\t\tkfree(event);\n\t}\n}\n\nstatic void mlxsw_sp_ports_remove(struct mlxsw_sp *mlxsw_sp)\n{\n\tunsigned int max_ports = mlxsw_core_max_ports(mlxsw_sp->core);\n\tint i;\n\n\tfor (i = 1; i < max_ports; i++)\n\t\tmlxsw_sp_port_mapping_event_set(mlxsw_sp, i, false);\n\t \n\t__mlxsw_sp_port_mapping_events_cancel(mlxsw_sp);\n\n\tfor (i = 1; i < max_ports; i++)\n\t\tif (mlxsw_sp_port_created(mlxsw_sp, i))\n\t\t\tmlxsw_sp_port_remove(mlxsw_sp, i);\n\tmlxsw_sp_cpu_port_remove(mlxsw_sp);\n\tkfree(mlxsw_sp->ports);\n\tmlxsw_sp->ports = NULL;\n}\n\nstatic void\nmlxsw_sp_ports_remove_selected(struct mlxsw_core *mlxsw_core,\n\t\t\t       bool (*selector)(void *priv, u16 local_port),\n\t\t\t       void *priv)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tunsigned int max_ports = mlxsw_core_max_ports(mlxsw_core);\n\tint i;\n\n\tfor (i = 1; i < max_ports; i++)\n\t\tif (mlxsw_sp_port_created(mlxsw_sp, i) && selector(priv, i))\n\t\t\tmlxsw_sp_port_remove(mlxsw_sp, i);\n}\n\nstatic int mlxsw_sp_ports_create(struct mlxsw_sp *mlxsw_sp)\n{\n\tunsigned int max_ports = mlxsw_core_max_ports(mlxsw_sp->core);\n\tstruct mlxsw_sp_port_mapping_events *events;\n\tstruct mlxsw_sp_port_mapping *port_mapping;\n\tsize_t alloc_size;\n\tint i;\n\tint err;\n\n\talloc_size = sizeof(struct mlxsw_sp_port *) * max_ports;\n\tmlxsw_sp->ports = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!mlxsw_sp->ports)\n\t\treturn -ENOMEM;\n\n\tevents = &mlxsw_sp->port_mapping_events;\n\tINIT_LIST_HEAD(&events->queue);\n\tspin_lock_init(&events->queue_lock);\n\tINIT_WORK(&events->work, mlxsw_sp_port_mapping_events_work);\n\n\tfor (i = 1; i < max_ports; i++) {\n\t\terr = mlxsw_sp_port_mapping_event_set(mlxsw_sp, i, true);\n\t\tif (err)\n\t\t\tgoto err_event_enable;\n\t}\n\n\terr = mlxsw_sp_cpu_port_create(mlxsw_sp);\n\tif (err)\n\t\tgoto err_cpu_port_create;\n\n\tfor (i = 1; i < max_ports; i++) {\n\t\tport_mapping = &mlxsw_sp->port_mapping[i];\n\t\tif (!port_mapping->width)\n\t\t\tcontinue;\n\t\terr = mlxsw_sp_port_create(mlxsw_sp, i, false, port_mapping);\n\t\tif (err)\n\t\t\tgoto err_port_create;\n\t}\n\treturn 0;\n\nerr_port_create:\n\tfor (i--; i >= 1; i--)\n\t\tif (mlxsw_sp_port_created(mlxsw_sp, i))\n\t\t\tmlxsw_sp_port_remove(mlxsw_sp, i);\n\ti = max_ports;\n\tmlxsw_sp_cpu_port_remove(mlxsw_sp);\nerr_cpu_port_create:\nerr_event_enable:\n\tfor (i--; i >= 1; i--)\n\t\tmlxsw_sp_port_mapping_event_set(mlxsw_sp, i, false);\n\t \n\t__mlxsw_sp_port_mapping_events_cancel(mlxsw_sp);\n\tkfree(mlxsw_sp->ports);\n\tmlxsw_sp->ports = NULL;\n\treturn err;\n}\n\nstatic int mlxsw_sp_port_module_info_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tunsigned int max_ports = mlxsw_core_max_ports(mlxsw_sp->core);\n\tstruct mlxsw_sp_port_mapping *port_mapping;\n\tint i;\n\tint err;\n\n\tmlxsw_sp->port_mapping = kcalloc(max_ports,\n\t\t\t\t\t sizeof(struct mlxsw_sp_port_mapping),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!mlxsw_sp->port_mapping)\n\t\treturn -ENOMEM;\n\n\tfor (i = 1; i < max_ports; i++) {\n\t\tport_mapping = &mlxsw_sp->port_mapping[i];\n\t\terr = mlxsw_sp_port_module_info_get(mlxsw_sp, i, port_mapping);\n\t\tif (err)\n\t\t\tgoto err_port_module_info_get;\n\t}\n\treturn 0;\n\nerr_port_module_info_get:\n\tkfree(mlxsw_sp->port_mapping);\n\treturn err;\n}\n\nstatic void mlxsw_sp_port_module_info_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tkfree(mlxsw_sp->port_mapping);\n}\n\nstatic int\nmlxsw_sp_port_split_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   struct mlxsw_sp_port_mapping *port_mapping,\n\t\t\t   unsigned int count, const char *pmtdb_pl)\n{\n\tstruct mlxsw_sp_port_mapping split_port_mapping;\n\tint err, i;\n\n\tsplit_port_mapping = *port_mapping;\n\tsplit_port_mapping.width /= count;\n\tfor (i = 0; i < count; i++) {\n\t\tu16 s_local_port = mlxsw_reg_pmtdb_port_num_get(pmtdb_pl, i);\n\n\t\tif (!mlxsw_sp_local_port_valid(s_local_port))\n\t\t\tcontinue;\n\n\t\terr = mlxsw_sp_port_create(mlxsw_sp, s_local_port,\n\t\t\t\t\t   true, &split_port_mapping);\n\t\tif (err)\n\t\t\tgoto err_port_create;\n\t\tsplit_port_mapping.lane += split_port_mapping.width;\n\t}\n\n\treturn 0;\n\nerr_port_create:\n\tfor (i--; i >= 0; i--) {\n\t\tu16 s_local_port = mlxsw_reg_pmtdb_port_num_get(pmtdb_pl, i);\n\n\t\tif (mlxsw_sp_port_created(mlxsw_sp, s_local_port))\n\t\t\tmlxsw_sp_port_remove(mlxsw_sp, s_local_port);\n\t}\n\treturn err;\n}\n\nstatic void mlxsw_sp_port_unsplit_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t unsigned int count,\n\t\t\t\t\t const char *pmtdb_pl)\n{\n\tstruct mlxsw_sp_port_mapping *port_mapping;\n\tint i;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tu16 local_port = mlxsw_reg_pmtdb_port_num_get(pmtdb_pl, i);\n\n\t\tport_mapping = &mlxsw_sp->port_mapping[local_port];\n\t\tif (!port_mapping->width || !mlxsw_sp_local_port_valid(local_port))\n\t\t\tcontinue;\n\t\tmlxsw_sp_port_create(mlxsw_sp, local_port,\n\t\t\t\t     false, port_mapping);\n\t}\n}\n\nstatic struct mlxsw_sp_port *\nmlxsw_sp_port_get_by_local_port(struct mlxsw_sp *mlxsw_sp, u16 local_port)\n{\n\tif (mlxsw_sp->ports && mlxsw_sp->ports[local_port])\n\t\treturn mlxsw_sp->ports[local_port];\n\treturn NULL;\n}\n\nstatic int mlxsw_sp_port_split(struct mlxsw_core *mlxsw_core, u16 local_port,\n\t\t\t       unsigned int count,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tstruct mlxsw_sp_port_mapping port_mapping;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tenum mlxsw_reg_pmtdb_status status;\n\tchar pmtdb_pl[MLXSW_REG_PMTDB_LEN];\n\tint i;\n\tint err;\n\n\tmlxsw_sp_port = mlxsw_sp_port_get_by_local_port(mlxsw_sp, local_port);\n\tif (!mlxsw_sp_port) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port number \\\"%d\\\" does not exist\\n\",\n\t\t\tlocal_port);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Port number does not exist\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mlxsw_sp_port->split) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Port is already split\");\n\t\treturn -EINVAL;\n\t}\n\n\tmlxsw_reg_pmtdb_pack(pmtdb_pl, mlxsw_sp_port->mapping.slot_index,\n\t\t\t     mlxsw_sp_port->mapping.module,\n\t\t\t     mlxsw_sp_port->mapping.module_width / count,\n\t\t\t     count);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(pmtdb), pmtdb_pl);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to query split info\");\n\t\treturn err;\n\t}\n\n\tstatus = mlxsw_reg_pmtdb_status_get(pmtdb_pl);\n\tif (status != MLXSW_REG_PMTDB_STATUS_SUCCESS) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported split configuration\");\n\t\treturn -EINVAL;\n\t}\n\n\tport_mapping = mlxsw_sp_port->mapping;\n\n\tfor (i = 0; i < count; i++) {\n\t\tu16 s_local_port = mlxsw_reg_pmtdb_port_num_get(pmtdb_pl, i);\n\n\t\tif (mlxsw_sp_port_created(mlxsw_sp, s_local_port))\n\t\t\tmlxsw_sp_port_remove(mlxsw_sp, s_local_port);\n\t}\n\n\terr = mlxsw_sp_port_split_create(mlxsw_sp, &port_mapping,\n\t\t\t\t\t count, pmtdb_pl);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to create split ports\\n\");\n\t\tgoto err_port_split_create;\n\t}\n\n\treturn 0;\n\nerr_port_split_create:\n\tmlxsw_sp_port_unsplit_create(mlxsw_sp, count, pmtdb_pl);\n\n\treturn err;\n}\n\nstatic int mlxsw_sp_port_unsplit(struct mlxsw_core *mlxsw_core, u16 local_port,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tchar pmtdb_pl[MLXSW_REG_PMTDB_LEN];\n\tunsigned int count;\n\tint i;\n\tint err;\n\n\tmlxsw_sp_port = mlxsw_sp_port_get_by_local_port(mlxsw_sp, local_port);\n\tif (!mlxsw_sp_port) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Port number \\\"%d\\\" does not exist\\n\",\n\t\t\tlocal_port);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Port number does not exist\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!mlxsw_sp_port->split) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Port was not split\");\n\t\treturn -EINVAL;\n\t}\n\n\tcount = mlxsw_sp_port->mapping.module_width /\n\t\tmlxsw_sp_port->mapping.width;\n\n\tmlxsw_reg_pmtdb_pack(pmtdb_pl, mlxsw_sp_port->mapping.slot_index,\n\t\t\t     mlxsw_sp_port->mapping.module,\n\t\t\t     mlxsw_sp_port->mapping.module_width / count,\n\t\t\t     count);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(pmtdb), pmtdb_pl);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to query split info\");\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tu16 s_local_port = mlxsw_reg_pmtdb_port_num_get(pmtdb_pl, i);\n\n\t\tif (mlxsw_sp_port_created(mlxsw_sp, s_local_port))\n\t\t\tmlxsw_sp_port_remove(mlxsw_sp, s_local_port);\n\t}\n\n\tmlxsw_sp_port_unsplit_create(mlxsw_sp, count, pmtdb_pl);\n\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_port_down_wipe_counters(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tint i;\n\n\tfor (i = 0; i < TC_MAX_QUEUE; i++)\n\t\tmlxsw_sp_port->periodic_hw_stats.xstats.backlog[i] = 0;\n}\n\nstatic void mlxsw_sp_pude_event_func(const struct mlxsw_reg_info *reg,\n\t\t\t\t     char *pude_pl, void *priv)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tenum mlxsw_reg_pude_oper_status status;\n\tu16 local_port;\n\n\tlocal_port = mlxsw_reg_pude_local_port_get(pude_pl);\n\n\tif (WARN_ON_ONCE(!mlxsw_sp_local_port_is_valid(mlxsw_sp, local_port)))\n\t\treturn;\n\tmlxsw_sp_port = mlxsw_sp->ports[local_port];\n\tif (!mlxsw_sp_port)\n\t\treturn;\n\n\tstatus = mlxsw_reg_pude_oper_status_get(pude_pl);\n\tif (status == MLXSW_PORT_OPER_STATUS_UP) {\n\t\tnetdev_info(mlxsw_sp_port->dev, \"link up\\n\");\n\t\tnetif_carrier_on(mlxsw_sp_port->dev);\n\t\tmlxsw_core_schedule_dw(&mlxsw_sp_port->ptp.shaper_dw, 0);\n\t} else {\n\t\tnetdev_info(mlxsw_sp_port->dev, \"link down\\n\");\n\t\tnetif_carrier_off(mlxsw_sp_port->dev);\n\t\tmlxsw_sp_port_down_wipe_counters(mlxsw_sp_port);\n\t}\n}\n\nstatic void mlxsw_sp1_ptp_fifo_event_func(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  char *mtpptr_pl, bool ingress)\n{\n\tu16 local_port;\n\tu8 num_rec;\n\tint i;\n\n\tlocal_port = mlxsw_reg_mtpptr_local_port_get(mtpptr_pl);\n\tnum_rec = mlxsw_reg_mtpptr_num_rec_get(mtpptr_pl);\n\tfor (i = 0; i < num_rec; i++) {\n\t\tu8 domain_number;\n\t\tu8 message_type;\n\t\tu16 sequence_id;\n\t\tu64 timestamp;\n\n\t\tmlxsw_reg_mtpptr_unpack(mtpptr_pl, i, &message_type,\n\t\t\t\t\t&domain_number, &sequence_id,\n\t\t\t\t\t&timestamp);\n\t\tmlxsw_sp1_ptp_got_timestamp(mlxsw_sp, ingress, local_port,\n\t\t\t\t\t    message_type, domain_number,\n\t\t\t\t\t    sequence_id, timestamp);\n\t}\n}\n\nstatic void mlxsw_sp1_ptp_ing_fifo_event_func(const struct mlxsw_reg_info *reg,\n\t\t\t\t\t      char *mtpptr_pl, void *priv)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\tmlxsw_sp1_ptp_fifo_event_func(mlxsw_sp, mtpptr_pl, true);\n}\n\nstatic void mlxsw_sp1_ptp_egr_fifo_event_func(const struct mlxsw_reg_info *reg,\n\t\t\t\t\t      char *mtpptr_pl, void *priv)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\tmlxsw_sp1_ptp_fifo_event_func(mlxsw_sp, mtpptr_pl, false);\n}\n\nvoid mlxsw_sp_rx_listener_no_mark_func(struct sk_buff *skb,\n\t\t\t\t       u16 local_port, void *priv)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\tstruct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp->ports[local_port];\n\tstruct mlxsw_sp_port_pcpu_stats *pcpu_stats;\n\n\tif (unlikely(!mlxsw_sp_port)) {\n\t\tdev_warn_ratelimited(mlxsw_sp->bus_info->dev, \"Port %d: skb received for non-existent port\\n\",\n\t\t\t\t     local_port);\n\t\treturn;\n\t}\n\n\tskb->dev = mlxsw_sp_port->dev;\n\n\tpcpu_stats = this_cpu_ptr(mlxsw_sp_port->pcpu_stats);\n\tu64_stats_update_begin(&pcpu_stats->syncp);\n\tpcpu_stats->rx_packets++;\n\tpcpu_stats->rx_bytes += skb->len;\n\tu64_stats_update_end(&pcpu_stats->syncp);\n\n\tskb->protocol = eth_type_trans(skb, skb->dev);\n\tnetif_receive_skb(skb);\n}\n\nstatic void mlxsw_sp_rx_listener_mark_func(struct sk_buff *skb, u16 local_port,\n\t\t\t\t\t   void *priv)\n{\n\tskb->offload_fwd_mark = 1;\n\treturn mlxsw_sp_rx_listener_no_mark_func(skb, local_port, priv);\n}\n\nstatic void mlxsw_sp_rx_listener_l3_mark_func(struct sk_buff *skb,\n\t\t\t\t\t      u16 local_port, void *priv)\n{\n\tskb->offload_l3_fwd_mark = 1;\n\tskb->offload_fwd_mark = 1;\n\treturn mlxsw_sp_rx_listener_no_mark_func(skb, local_port, priv);\n}\n\nvoid mlxsw_sp_ptp_receive(struct mlxsw_sp *mlxsw_sp, struct sk_buff *skb,\n\t\t\t  u16 local_port)\n{\n\tmlxsw_sp->ptp_ops->receive(mlxsw_sp, skb, local_port);\n}\n\n#define MLXSW_SP_RXL_NO_MARK(_trap_id, _action, _trap_group, _is_ctrl)\t\\\n\tMLXSW_RXL(mlxsw_sp_rx_listener_no_mark_func, _trap_id, _action,\t\\\n\t\t  _is_ctrl, SP_##_trap_group, DISCARD)\n\n#define MLXSW_SP_RXL_MARK(_trap_id, _action, _trap_group, _is_ctrl)\t\\\n\tMLXSW_RXL(mlxsw_sp_rx_listener_mark_func, _trap_id, _action,\t\\\n\t\t_is_ctrl, SP_##_trap_group, DISCARD)\n\n#define MLXSW_SP_RXL_L3_MARK(_trap_id, _action, _trap_group, _is_ctrl)\t\\\n\tMLXSW_RXL(mlxsw_sp_rx_listener_l3_mark_func, _trap_id, _action,\t\\\n\t\t_is_ctrl, SP_##_trap_group, DISCARD)\n\n#define MLXSW_SP_EVENTL(_func, _trap_id)\t\t\\\n\tMLXSW_EVENTL(_func, _trap_id, SP_EVENT)\n\nstatic const struct mlxsw_listener mlxsw_sp_listener[] = {\n\t \n\tMLXSW_SP_EVENTL(mlxsw_sp_pude_event_func, PUDE),\n\t \n\tMLXSW_SP_RXL_NO_MARK(FID_MISS, TRAP_TO_CPU, FID_MISS, false),\n\t \n\tMLXSW_SP_RXL_MARK(IPV6_UNSPECIFIED_ADDRESS, TRAP_TO_CPU, ROUTER_EXP,\n\t\t\t  false),\n\tMLXSW_SP_RXL_MARK(IPV6_LINK_LOCAL_SRC, TRAP_TO_CPU, ROUTER_EXP, false),\n\tMLXSW_SP_RXL_MARK(IPV6_MC_LINK_LOCAL_DEST, TRAP_TO_CPU, ROUTER_EXP,\n\t\t\t  false),\n\tMLXSW_SP_RXL_NO_MARK(DISCARD_ING_ROUTER_SIP_CLASS_E, FORWARD,\n\t\t\t     ROUTER_EXP, false),\n\tMLXSW_SP_RXL_NO_MARK(DISCARD_ING_ROUTER_MC_DMAC, FORWARD,\n\t\t\t     ROUTER_EXP, false),\n\tMLXSW_SP_RXL_NO_MARK(DISCARD_ING_ROUTER_SIP_DIP, FORWARD,\n\t\t\t     ROUTER_EXP, false),\n\tMLXSW_SP_RXL_NO_MARK(DISCARD_ING_ROUTER_DIP_LINK_LOCAL, FORWARD,\n\t\t\t     ROUTER_EXP, false),\n\t \n\tMLXSW_SP_RXL_MARK(ACL1, TRAP_TO_CPU, MULTICAST, false),\n\tMLXSW_SP_RXL_L3_MARK(ACL2, TRAP_TO_CPU, MULTICAST, false),\n\t \n\tMLXSW_SP_RXL_MARK(NVE_ENCAP_ARP, TRAP_TO_CPU, NEIGH_DISCOVERY, false),\n};\n\nstatic const struct mlxsw_listener mlxsw_sp1_listener[] = {\n\t \n\tMLXSW_EVENTL(mlxsw_sp1_ptp_egr_fifo_event_func, PTP_EGR_FIFO, SP_PTP0),\n\tMLXSW_EVENTL(mlxsw_sp1_ptp_ing_fifo_event_func, PTP_ING_FIFO, SP_PTP0),\n};\n\nstatic const struct mlxsw_listener mlxsw_sp2_listener[] = {\n\t \n\tMLXSW_SP_EVENTL(mlxsw_sp_port_mapping_listener_func, PMLPE),\n};\n\nstatic int mlxsw_sp_cpu_policers_set(struct mlxsw_core *mlxsw_core)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tchar qpcr_pl[MLXSW_REG_QPCR_LEN];\n\tenum mlxsw_reg_qpcr_ir_units ir_units;\n\tint max_cpu_policers;\n\tbool is_bytes;\n\tu8 burst_size;\n\tu32 rate;\n\tint i, err;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_core, MAX_CPU_POLICERS))\n\t\treturn -EIO;\n\n\tmax_cpu_policers = MLXSW_CORE_RES_GET(mlxsw_core, MAX_CPU_POLICERS);\n\n\tir_units = MLXSW_REG_QPCR_IR_UNITS_M;\n\tfor (i = 0; i < max_cpu_policers; i++) {\n\t\tis_bytes = false;\n\t\tswitch (i) {\n\t\tcase MLXSW_REG_HTGT_TRAP_GROUP_SP_ROUTER_EXP:\n\t\tcase MLXSW_REG_HTGT_TRAP_GROUP_SP_MULTICAST:\n\t\tcase MLXSW_REG_HTGT_TRAP_GROUP_SP_FID_MISS:\n\t\t\trate = 1024;\n\t\t\tburst_size = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\t__set_bit(i, mlxsw_sp->trap->policers_usage);\n\t\tmlxsw_reg_qpcr_pack(qpcr_pl, i, ir_units, is_bytes, rate,\n\t\t\t\t    burst_size);\n\t\terr = mlxsw_reg_write(mlxsw_core, MLXSW_REG(qpcr), qpcr_pl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_trap_groups_set(struct mlxsw_core *mlxsw_core)\n{\n\tchar htgt_pl[MLXSW_REG_HTGT_LEN];\n\tenum mlxsw_reg_htgt_trap_group i;\n\tint max_cpu_policers;\n\tint max_trap_groups;\n\tu8 priority, tc;\n\tu16 policer_id;\n\tint err;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_core, MAX_TRAP_GROUPS))\n\t\treturn -EIO;\n\n\tmax_trap_groups = MLXSW_CORE_RES_GET(mlxsw_core, MAX_TRAP_GROUPS);\n\tmax_cpu_policers = MLXSW_CORE_RES_GET(mlxsw_core, MAX_CPU_POLICERS);\n\n\tfor (i = 0; i < max_trap_groups; i++) {\n\t\tpolicer_id = i;\n\t\tswitch (i) {\n\t\tcase MLXSW_REG_HTGT_TRAP_GROUP_SP_ROUTER_EXP:\n\t\tcase MLXSW_REG_HTGT_TRAP_GROUP_SP_MULTICAST:\n\t\tcase MLXSW_REG_HTGT_TRAP_GROUP_SP_FID_MISS:\n\t\t\tpriority = 1;\n\t\t\ttc = 1;\n\t\t\tbreak;\n\t\tcase MLXSW_REG_HTGT_TRAP_GROUP_SP_EVENT:\n\t\t\tpriority = MLXSW_REG_HTGT_DEFAULT_PRIORITY;\n\t\t\ttc = MLXSW_REG_HTGT_DEFAULT_TC;\n\t\t\tpolicer_id = MLXSW_REG_HTGT_INVALID_POLICER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (max_cpu_policers <= policer_id &&\n\t\t    policer_id != MLXSW_REG_HTGT_INVALID_POLICER)\n\t\t\treturn -EIO;\n\n\t\tmlxsw_reg_htgt_pack(htgt_pl, i, policer_id, priority, tc);\n\t\terr = mlxsw_reg_write(mlxsw_core, MLXSW_REG(htgt), htgt_pl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_traps_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_trap *trap;\n\tu64 max_policers;\n\tint err;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, MAX_CPU_POLICERS))\n\t\treturn -EIO;\n\tmax_policers = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_CPU_POLICERS);\n\ttrap = kzalloc(struct_size(trap, policers_usage,\n\t\t\t\t   BITS_TO_LONGS(max_policers)), GFP_KERNEL);\n\tif (!trap)\n\t\treturn -ENOMEM;\n\ttrap->max_policers = max_policers;\n\tmlxsw_sp->trap = trap;\n\n\terr = mlxsw_sp_cpu_policers_set(mlxsw_sp->core);\n\tif (err)\n\t\tgoto err_cpu_policers_set;\n\n\terr = mlxsw_sp_trap_groups_set(mlxsw_sp->core);\n\tif (err)\n\t\tgoto err_trap_groups_set;\n\n\terr = mlxsw_core_traps_register(mlxsw_sp->core, mlxsw_sp_listener,\n\t\t\t\t\tARRAY_SIZE(mlxsw_sp_listener),\n\t\t\t\t\tmlxsw_sp);\n\tif (err)\n\t\tgoto err_traps_register;\n\n\terr = mlxsw_core_traps_register(mlxsw_sp->core, mlxsw_sp->listeners,\n\t\t\t\t\tmlxsw_sp->listeners_count, mlxsw_sp);\n\tif (err)\n\t\tgoto err_extra_traps_init;\n\n\treturn 0;\n\nerr_extra_traps_init:\n\tmlxsw_core_traps_unregister(mlxsw_sp->core, mlxsw_sp_listener,\n\t\t\t\t    ARRAY_SIZE(mlxsw_sp_listener),\n\t\t\t\t    mlxsw_sp);\nerr_traps_register:\nerr_trap_groups_set:\nerr_cpu_policers_set:\n\tkfree(trap);\n\treturn err;\n}\n\nstatic void mlxsw_sp_traps_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tmlxsw_core_traps_unregister(mlxsw_sp->core, mlxsw_sp->listeners,\n\t\t\t\t    mlxsw_sp->listeners_count,\n\t\t\t\t    mlxsw_sp);\n\tmlxsw_core_traps_unregister(mlxsw_sp->core, mlxsw_sp_listener,\n\t\t\t\t    ARRAY_SIZE(mlxsw_sp_listener), mlxsw_sp);\n\tkfree(mlxsw_sp->trap);\n}\n\n#define MLXSW_SP_LAG_SEED_INIT 0xcafecafe\n\nstatic int mlxsw_sp_lag_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tchar slcr_pl[MLXSW_REG_SLCR_LEN];\n\tu16 max_lag;\n\tu32 seed;\n\tint err;\n\n\tseed = jhash(mlxsw_sp->base_mac, sizeof(mlxsw_sp->base_mac),\n\t\t     MLXSW_SP_LAG_SEED_INIT);\n\tmlxsw_reg_slcr_pack(slcr_pl, MLXSW_REG_SLCR_LAG_HASH_SMAC |\n\t\t\t\t     MLXSW_REG_SLCR_LAG_HASH_DMAC |\n\t\t\t\t     MLXSW_REG_SLCR_LAG_HASH_ETHERTYPE |\n\t\t\t\t     MLXSW_REG_SLCR_LAG_HASH_VLANID |\n\t\t\t\t     MLXSW_REG_SLCR_LAG_HASH_SIP |\n\t\t\t\t     MLXSW_REG_SLCR_LAG_HASH_DIP |\n\t\t\t\t     MLXSW_REG_SLCR_LAG_HASH_SPORT |\n\t\t\t\t     MLXSW_REG_SLCR_LAG_HASH_DPORT |\n\t\t\t\t     MLXSW_REG_SLCR_LAG_HASH_IPPROTO, seed);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(slcr), slcr_pl);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_core_max_lag(mlxsw_sp->core, &max_lag);\n\tif (err)\n\t\treturn err;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, MAX_LAG_MEMBERS))\n\t\treturn -EIO;\n\n\tmlxsw_sp->lags = kcalloc(max_lag, sizeof(struct mlxsw_sp_upper),\n\t\t\t\t GFP_KERNEL);\n\tif (!mlxsw_sp->lags)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_lag_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tkfree(mlxsw_sp->lags);\n}\n\nstatic const struct mlxsw_sp_ptp_ops mlxsw_sp1_ptp_ops = {\n\t.clock_init\t= mlxsw_sp1_ptp_clock_init,\n\t.clock_fini\t= mlxsw_sp1_ptp_clock_fini,\n\t.init\t\t= mlxsw_sp1_ptp_init,\n\t.fini\t\t= mlxsw_sp1_ptp_fini,\n\t.receive\t= mlxsw_sp1_ptp_receive,\n\t.transmitted\t= mlxsw_sp1_ptp_transmitted,\n\t.hwtstamp_get\t= mlxsw_sp1_ptp_hwtstamp_get,\n\t.hwtstamp_set\t= mlxsw_sp1_ptp_hwtstamp_set,\n\t.shaper_work\t= mlxsw_sp1_ptp_shaper_work,\n\t.get_ts_info\t= mlxsw_sp1_ptp_get_ts_info,\n\t.get_stats_count = mlxsw_sp1_get_stats_count,\n\t.get_stats_strings = mlxsw_sp1_get_stats_strings,\n\t.get_stats\t= mlxsw_sp1_get_stats,\n\t.txhdr_construct = mlxsw_sp_ptp_txhdr_construct,\n};\n\nstatic const struct mlxsw_sp_ptp_ops mlxsw_sp2_ptp_ops = {\n\t.clock_init\t= mlxsw_sp2_ptp_clock_init,\n\t.clock_fini\t= mlxsw_sp2_ptp_clock_fini,\n\t.init\t\t= mlxsw_sp2_ptp_init,\n\t.fini\t\t= mlxsw_sp2_ptp_fini,\n\t.receive\t= mlxsw_sp2_ptp_receive,\n\t.transmitted\t= mlxsw_sp2_ptp_transmitted,\n\t.hwtstamp_get\t= mlxsw_sp2_ptp_hwtstamp_get,\n\t.hwtstamp_set\t= mlxsw_sp2_ptp_hwtstamp_set,\n\t.shaper_work\t= mlxsw_sp2_ptp_shaper_work,\n\t.get_ts_info\t= mlxsw_sp2_ptp_get_ts_info,\n\t.get_stats_count = mlxsw_sp2_get_stats_count,\n\t.get_stats_strings = mlxsw_sp2_get_stats_strings,\n\t.get_stats\t= mlxsw_sp2_get_stats,\n\t.txhdr_construct = mlxsw_sp2_ptp_txhdr_construct,\n};\n\nstatic const struct mlxsw_sp_ptp_ops mlxsw_sp4_ptp_ops = {\n\t.clock_init\t= mlxsw_sp2_ptp_clock_init,\n\t.clock_fini\t= mlxsw_sp2_ptp_clock_fini,\n\t.init\t\t= mlxsw_sp2_ptp_init,\n\t.fini\t\t= mlxsw_sp2_ptp_fini,\n\t.receive\t= mlxsw_sp2_ptp_receive,\n\t.transmitted\t= mlxsw_sp2_ptp_transmitted,\n\t.hwtstamp_get\t= mlxsw_sp2_ptp_hwtstamp_get,\n\t.hwtstamp_set\t= mlxsw_sp2_ptp_hwtstamp_set,\n\t.shaper_work\t= mlxsw_sp2_ptp_shaper_work,\n\t.get_ts_info\t= mlxsw_sp2_ptp_get_ts_info,\n\t.get_stats_count = mlxsw_sp2_get_stats_count,\n\t.get_stats_strings = mlxsw_sp2_get_stats_strings,\n\t.get_stats\t= mlxsw_sp2_get_stats,\n\t.txhdr_construct = mlxsw_sp_ptp_txhdr_construct,\n};\n\nstruct mlxsw_sp_sample_trigger_node {\n\tstruct mlxsw_sp_sample_trigger trigger;\n\tstruct mlxsw_sp_sample_params params;\n\tstruct rhash_head ht_node;\n\tstruct rcu_head rcu;\n\trefcount_t refcount;\n};\n\nstatic const struct rhashtable_params mlxsw_sp_sample_trigger_ht_params = {\n\t.key_offset = offsetof(struct mlxsw_sp_sample_trigger_node, trigger),\n\t.head_offset = offsetof(struct mlxsw_sp_sample_trigger_node, ht_node),\n\t.key_len = sizeof(struct mlxsw_sp_sample_trigger),\n\t.automatic_shrinking = true,\n};\n\nstatic void\nmlxsw_sp_sample_trigger_key_init(struct mlxsw_sp_sample_trigger *key,\n\t\t\t\t const struct mlxsw_sp_sample_trigger *trigger)\n{\n\tmemset(key, 0, sizeof(*key));\n\tkey->type = trigger->type;\n\tkey->local_port = trigger->local_port;\n}\n\n \nstruct mlxsw_sp_sample_params *\nmlxsw_sp_sample_trigger_params_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      const struct mlxsw_sp_sample_trigger *trigger)\n{\n\tstruct mlxsw_sp_sample_trigger_node *trigger_node;\n\tstruct mlxsw_sp_sample_trigger key;\n\n\tmlxsw_sp_sample_trigger_key_init(&key, trigger);\n\ttrigger_node = rhashtable_lookup(&mlxsw_sp->sample_trigger_ht, &key,\n\t\t\t\t\t mlxsw_sp_sample_trigger_ht_params);\n\tif (!trigger_node)\n\t\treturn NULL;\n\n\treturn &trigger_node->params;\n}\n\nstatic int\nmlxsw_sp_sample_trigger_node_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  const struct mlxsw_sp_sample_trigger *trigger,\n\t\t\t\t  const struct mlxsw_sp_sample_params *params)\n{\n\tstruct mlxsw_sp_sample_trigger_node *trigger_node;\n\tint err;\n\n\ttrigger_node = kzalloc(sizeof(*trigger_node), GFP_KERNEL);\n\tif (!trigger_node)\n\t\treturn -ENOMEM;\n\n\ttrigger_node->trigger = *trigger;\n\ttrigger_node->params = *params;\n\trefcount_set(&trigger_node->refcount, 1);\n\n\terr = rhashtable_insert_fast(&mlxsw_sp->sample_trigger_ht,\n\t\t\t\t     &trigger_node->ht_node,\n\t\t\t\t     mlxsw_sp_sample_trigger_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_insert;\n\n\treturn 0;\n\nerr_rhashtable_insert:\n\tkfree(trigger_node);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_sample_trigger_node_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_sample_trigger_node *trigger_node)\n{\n\trhashtable_remove_fast(&mlxsw_sp->sample_trigger_ht,\n\t\t\t       &trigger_node->ht_node,\n\t\t\t       mlxsw_sp_sample_trigger_ht_params);\n\tkfree_rcu(trigger_node, rcu);\n}\n\nint\nmlxsw_sp_sample_trigger_params_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   const struct mlxsw_sp_sample_trigger *trigger,\n\t\t\t\t   const struct mlxsw_sp_sample_params *params,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_sample_trigger_node *trigger_node;\n\tstruct mlxsw_sp_sample_trigger key;\n\n\tASSERT_RTNL();\n\n\tmlxsw_sp_sample_trigger_key_init(&key, trigger);\n\n\ttrigger_node = rhashtable_lookup_fast(&mlxsw_sp->sample_trigger_ht,\n\t\t\t\t\t      &key,\n\t\t\t\t\t      mlxsw_sp_sample_trigger_ht_params);\n\tif (!trigger_node)\n\t\treturn mlxsw_sp_sample_trigger_node_init(mlxsw_sp, &key,\n\t\t\t\t\t\t\t params);\n\n\tif (trigger_node->trigger.local_port) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Sampling already enabled on port\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (trigger_node->params.psample_group != params->psample_group ||\n\t    trigger_node->params.truncate != params->truncate ||\n\t    trigger_node->params.rate != params->rate ||\n\t    trigger_node->params.trunc_size != params->trunc_size) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Sampling parameters do not match for an existing sampling trigger\");\n\t\treturn -EINVAL;\n\t}\n\n\trefcount_inc(&trigger_node->refcount);\n\n\treturn 0;\n}\n\nvoid\nmlxsw_sp_sample_trigger_params_unset(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     const struct mlxsw_sp_sample_trigger *trigger)\n{\n\tstruct mlxsw_sp_sample_trigger_node *trigger_node;\n\tstruct mlxsw_sp_sample_trigger key;\n\n\tASSERT_RTNL();\n\n\tmlxsw_sp_sample_trigger_key_init(&key, trigger);\n\n\ttrigger_node = rhashtable_lookup_fast(&mlxsw_sp->sample_trigger_ht,\n\t\t\t\t\t      &key,\n\t\t\t\t\t      mlxsw_sp_sample_trigger_ht_params);\n\tif (!trigger_node)\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&trigger_node->refcount))\n\t\treturn;\n\n\tmlxsw_sp_sample_trigger_node_fini(mlxsw_sp, trigger_node);\n}\n\nstatic int mlxsw_sp_netdevice_event(struct notifier_block *unused,\n\t\t\t\t    unsigned long event, void *ptr);\n\n#define MLXSW_SP_DEFAULT_PARSING_DEPTH 96\n#define MLXSW_SP_INCREASED_PARSING_DEPTH 128\n#define MLXSW_SP_DEFAULT_VXLAN_UDP_DPORT 4789\n\nstatic void mlxsw_sp_parsing_init(struct mlxsw_sp *mlxsw_sp)\n{\n\trefcount_set(&mlxsw_sp->parsing.parsing_depth_ref, 0);\n\tmlxsw_sp->parsing.parsing_depth = MLXSW_SP_DEFAULT_PARSING_DEPTH;\n\tmlxsw_sp->parsing.vxlan_udp_dport = MLXSW_SP_DEFAULT_VXLAN_UDP_DPORT;\n\tmutex_init(&mlxsw_sp->parsing.lock);\n}\n\nstatic void mlxsw_sp_parsing_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tmutex_destroy(&mlxsw_sp->parsing.lock);\n\tWARN_ON_ONCE(refcount_read(&mlxsw_sp->parsing.parsing_depth_ref));\n}\n\nstruct mlxsw_sp_ipv6_addr_node {\n\tstruct in6_addr key;\n\tstruct rhash_head ht_node;\n\tu32 kvdl_index;\n\trefcount_t refcount;\n};\n\nstatic const struct rhashtable_params mlxsw_sp_ipv6_addr_ht_params = {\n\t.key_offset = offsetof(struct mlxsw_sp_ipv6_addr_node, key),\n\t.head_offset = offsetof(struct mlxsw_sp_ipv6_addr_node, ht_node),\n\t.key_len = sizeof(struct in6_addr),\n\t.automatic_shrinking = true,\n};\n\nstatic int\nmlxsw_sp_ipv6_addr_init(struct mlxsw_sp *mlxsw_sp, const struct in6_addr *addr6,\n\t\t\tu32 *p_kvdl_index)\n{\n\tstruct mlxsw_sp_ipv6_addr_node *node;\n\tchar rips_pl[MLXSW_REG_RIPS_LEN];\n\tint err;\n\n\terr = mlxsw_sp_kvdl_alloc(mlxsw_sp,\n\t\t\t\t  MLXSW_SP_KVDL_ENTRY_TYPE_IPV6_ADDRESS, 1,\n\t\t\t\t  p_kvdl_index);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_rips_pack(rips_pl, *p_kvdl_index, addr6);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rips), rips_pl);\n\tif (err)\n\t\tgoto err_rips_write;\n\n\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\tif (!node) {\n\t\terr = -ENOMEM;\n\t\tgoto err_node_alloc;\n\t}\n\n\tnode->key = *addr6;\n\tnode->kvdl_index = *p_kvdl_index;\n\trefcount_set(&node->refcount, 1);\n\n\terr = rhashtable_insert_fast(&mlxsw_sp->ipv6_addr_ht,\n\t\t\t\t     &node->ht_node,\n\t\t\t\t     mlxsw_sp_ipv6_addr_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_insert;\n\n\treturn 0;\n\nerr_rhashtable_insert:\n\tkfree(node);\nerr_node_alloc:\nerr_rips_write:\n\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_IPV6_ADDRESS, 1,\n\t\t\t   *p_kvdl_index);\n\treturn err;\n}\n\nstatic void mlxsw_sp_ipv6_addr_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_ipv6_addr_node *node)\n{\n\tu32 kvdl_index = node->kvdl_index;\n\n\trhashtable_remove_fast(&mlxsw_sp->ipv6_addr_ht, &node->ht_node,\n\t\t\t       mlxsw_sp_ipv6_addr_ht_params);\n\tkfree(node);\n\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_IPV6_ADDRESS, 1,\n\t\t\t   kvdl_index);\n}\n\nint mlxsw_sp_ipv6_addr_kvdl_index_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      const struct in6_addr *addr6,\n\t\t\t\t      u32 *p_kvdl_index)\n{\n\tstruct mlxsw_sp_ipv6_addr_node *node;\n\tint err = 0;\n\n\tmutex_lock(&mlxsw_sp->ipv6_addr_ht_lock);\n\tnode = rhashtable_lookup_fast(&mlxsw_sp->ipv6_addr_ht, addr6,\n\t\t\t\t      mlxsw_sp_ipv6_addr_ht_params);\n\tif (node) {\n\t\trefcount_inc(&node->refcount);\n\t\t*p_kvdl_index = node->kvdl_index;\n\t\tgoto out_unlock;\n\t}\n\n\terr = mlxsw_sp_ipv6_addr_init(mlxsw_sp, addr6, p_kvdl_index);\n\nout_unlock:\n\tmutex_unlock(&mlxsw_sp->ipv6_addr_ht_lock);\n\treturn err;\n}\n\nvoid\nmlxsw_sp_ipv6_addr_put(struct mlxsw_sp *mlxsw_sp, const struct in6_addr *addr6)\n{\n\tstruct mlxsw_sp_ipv6_addr_node *node;\n\n\tmutex_lock(&mlxsw_sp->ipv6_addr_ht_lock);\n\tnode = rhashtable_lookup_fast(&mlxsw_sp->ipv6_addr_ht, addr6,\n\t\t\t\t      mlxsw_sp_ipv6_addr_ht_params);\n\tif (WARN_ON(!node))\n\t\tgoto out_unlock;\n\n\tif (!refcount_dec_and_test(&node->refcount))\n\t\tgoto out_unlock;\n\n\tmlxsw_sp_ipv6_addr_fini(mlxsw_sp, node);\n\nout_unlock:\n\tmutex_unlock(&mlxsw_sp->ipv6_addr_ht_lock);\n}\n\nstatic int mlxsw_sp_ipv6_addr_ht_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tint err;\n\n\terr = rhashtable_init(&mlxsw_sp->ipv6_addr_ht,\n\t\t\t      &mlxsw_sp_ipv6_addr_ht_params);\n\tif (err)\n\t\treturn err;\n\n\tmutex_init(&mlxsw_sp->ipv6_addr_ht_lock);\n\treturn 0;\n}\n\nstatic void mlxsw_sp_ipv6_addr_ht_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tmutex_destroy(&mlxsw_sp->ipv6_addr_ht_lock);\n\trhashtable_destroy(&mlxsw_sp->ipv6_addr_ht);\n}\n\nstatic int mlxsw_sp_init(struct mlxsw_core *mlxsw_core,\n\t\t\t const struct mlxsw_bus_info *mlxsw_bus_info,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tint err;\n\n\tmlxsw_sp->core = mlxsw_core;\n\tmlxsw_sp->bus_info = mlxsw_bus_info;\n\n\tmlxsw_sp_parsing_init(mlxsw_sp);\n\n\terr = mlxsw_sp_base_mac_get(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to get base mac\\n\");\n\t\treturn err;\n\t}\n\n\terr = mlxsw_sp_kvdl_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize KVDL\\n\");\n\t\treturn err;\n\t}\n\n\terr = mlxsw_sp_pgt_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize PGT\\n\");\n\t\tgoto err_pgt_init;\n\t}\n\n\terr = mlxsw_sp_fids_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize FIDs\\n\");\n\t\tgoto err_fids_init;\n\t}\n\n\terr = mlxsw_sp_policers_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize policers\\n\");\n\t\tgoto err_policers_init;\n\t}\n\n\terr = mlxsw_sp_traps_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to set traps\\n\");\n\t\tgoto err_traps_init;\n\t}\n\n\terr = mlxsw_sp_devlink_traps_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize devlink traps\\n\");\n\t\tgoto err_devlink_traps_init;\n\t}\n\n\terr = mlxsw_sp_buffers_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize buffers\\n\");\n\t\tgoto err_buffers_init;\n\t}\n\n\terr = mlxsw_sp_lag_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize LAG\\n\");\n\t\tgoto err_lag_init;\n\t}\n\n\t \n\terr = mlxsw_sp_span_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to init span system\\n\");\n\t\tgoto err_span_init;\n\t}\n\n\terr = mlxsw_sp_switchdev_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize switchdev\\n\");\n\t\tgoto err_switchdev_init;\n\t}\n\n\terr = mlxsw_sp_counter_pool_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to init counter pool\\n\");\n\t\tgoto err_counter_pool_init;\n\t}\n\n\terr = mlxsw_sp_afa_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize ACL actions\\n\");\n\t\tgoto err_afa_init;\n\t}\n\n\terr = mlxsw_sp_ipv6_addr_ht_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize hash table for IPv6 addresses\\n\");\n\t\tgoto err_ipv6_addr_ht_init;\n\t}\n\n\terr = mlxsw_sp_nve_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize NVE\\n\");\n\t\tgoto err_nve_init;\n\t}\n\n\terr = mlxsw_sp_port_range_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize port ranges\\n\");\n\t\tgoto err_port_range_init;\n\t}\n\n\terr = mlxsw_sp_acl_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize ACL\\n\");\n\t\tgoto err_acl_init;\n\t}\n\n\terr = mlxsw_sp_router_init(mlxsw_sp, extack);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize router\\n\");\n\t\tgoto err_router_init;\n\t}\n\n\tif (mlxsw_sp->bus_info->read_clock_capable) {\n\t\t \n\t\tmlxsw_sp->clock =\n\t\t\tmlxsw_sp->ptp_ops->clock_init(mlxsw_sp,\n\t\t\t\t\t\t      mlxsw_sp->bus_info->dev);\n\t\tif (IS_ERR(mlxsw_sp->clock)) {\n\t\t\terr = PTR_ERR(mlxsw_sp->clock);\n\t\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to init ptp clock\\n\");\n\t\t\tgoto err_ptp_clock_init;\n\t\t}\n\t}\n\n\tif (mlxsw_sp->clock) {\n\t\t \n\t\tmlxsw_sp->ptp_state = mlxsw_sp->ptp_ops->init(mlxsw_sp);\n\t\tif (IS_ERR(mlxsw_sp->ptp_state)) {\n\t\t\terr = PTR_ERR(mlxsw_sp->ptp_state);\n\t\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to initialize PTP\\n\");\n\t\t\tgoto err_ptp_init;\n\t\t}\n\t}\n\n\t \n\tmlxsw_sp->netdevice_nb.notifier_call = mlxsw_sp_netdevice_event;\n\terr = register_netdevice_notifier_net(mlxsw_sp_net(mlxsw_sp),\n\t\t\t\t\t      &mlxsw_sp->netdevice_nb);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to register netdev notifier\\n\");\n\t\tgoto err_netdev_notifier;\n\t}\n\n\terr = mlxsw_sp_dpipe_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to init pipeline debug\\n\");\n\t\tgoto err_dpipe_init;\n\t}\n\n\terr = mlxsw_sp_port_module_info_init(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to init port module info\\n\");\n\t\tgoto err_port_module_info_init;\n\t}\n\n\terr = rhashtable_init(&mlxsw_sp->sample_trigger_ht,\n\t\t\t      &mlxsw_sp_sample_trigger_ht_params);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to init sampling trigger hashtable\\n\");\n\t\tgoto err_sample_trigger_init;\n\t}\n\n\terr = mlxsw_sp_ports_create(mlxsw_sp);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to create ports\\n\");\n\t\tgoto err_ports_create;\n\t}\n\n\treturn 0;\n\nerr_ports_create:\n\trhashtable_destroy(&mlxsw_sp->sample_trigger_ht);\nerr_sample_trigger_init:\n\tmlxsw_sp_port_module_info_fini(mlxsw_sp);\nerr_port_module_info_init:\n\tmlxsw_sp_dpipe_fini(mlxsw_sp);\nerr_dpipe_init:\n\tunregister_netdevice_notifier_net(mlxsw_sp_net(mlxsw_sp),\n\t\t\t\t\t  &mlxsw_sp->netdevice_nb);\nerr_netdev_notifier:\n\tif (mlxsw_sp->clock)\n\t\tmlxsw_sp->ptp_ops->fini(mlxsw_sp->ptp_state);\nerr_ptp_init:\n\tif (mlxsw_sp->clock)\n\t\tmlxsw_sp->ptp_ops->clock_fini(mlxsw_sp->clock);\nerr_ptp_clock_init:\n\tmlxsw_sp_router_fini(mlxsw_sp);\nerr_router_init:\n\tmlxsw_sp_acl_fini(mlxsw_sp);\nerr_acl_init:\n\tmlxsw_sp_port_range_fini(mlxsw_sp);\nerr_port_range_init:\n\tmlxsw_sp_nve_fini(mlxsw_sp);\nerr_nve_init:\n\tmlxsw_sp_ipv6_addr_ht_fini(mlxsw_sp);\nerr_ipv6_addr_ht_init:\n\tmlxsw_sp_afa_fini(mlxsw_sp);\nerr_afa_init:\n\tmlxsw_sp_counter_pool_fini(mlxsw_sp);\nerr_counter_pool_init:\n\tmlxsw_sp_switchdev_fini(mlxsw_sp);\nerr_switchdev_init:\n\tmlxsw_sp_span_fini(mlxsw_sp);\nerr_span_init:\n\tmlxsw_sp_lag_fini(mlxsw_sp);\nerr_lag_init:\n\tmlxsw_sp_buffers_fini(mlxsw_sp);\nerr_buffers_init:\n\tmlxsw_sp_devlink_traps_fini(mlxsw_sp);\nerr_devlink_traps_init:\n\tmlxsw_sp_traps_fini(mlxsw_sp);\nerr_traps_init:\n\tmlxsw_sp_policers_fini(mlxsw_sp);\nerr_policers_init:\n\tmlxsw_sp_fids_fini(mlxsw_sp);\nerr_fids_init:\n\tmlxsw_sp_pgt_fini(mlxsw_sp);\nerr_pgt_init:\n\tmlxsw_sp_kvdl_fini(mlxsw_sp);\n\tmlxsw_sp_parsing_fini(mlxsw_sp);\n\treturn err;\n}\n\nstatic int mlxsw_sp1_init(struct mlxsw_core *mlxsw_core,\n\t\t\t  const struct mlxsw_bus_info *mlxsw_bus_info,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\n\tmlxsw_sp->switchdev_ops = &mlxsw_sp1_switchdev_ops;\n\tmlxsw_sp->kvdl_ops = &mlxsw_sp1_kvdl_ops;\n\tmlxsw_sp->afa_ops = &mlxsw_sp1_act_afa_ops;\n\tmlxsw_sp->afk_ops = &mlxsw_sp1_afk_ops;\n\tmlxsw_sp->mr_tcam_ops = &mlxsw_sp1_mr_tcam_ops;\n\tmlxsw_sp->acl_rulei_ops = &mlxsw_sp1_acl_rulei_ops;\n\tmlxsw_sp->acl_tcam_ops = &mlxsw_sp1_acl_tcam_ops;\n\tmlxsw_sp->nve_ops_arr = mlxsw_sp1_nve_ops_arr;\n\tmlxsw_sp->mac_mask = mlxsw_sp1_mac_mask;\n\tmlxsw_sp->sb_vals = &mlxsw_sp1_sb_vals;\n\tmlxsw_sp->sb_ops = &mlxsw_sp1_sb_ops;\n\tmlxsw_sp->port_type_speed_ops = &mlxsw_sp1_port_type_speed_ops;\n\tmlxsw_sp->ptp_ops = &mlxsw_sp1_ptp_ops;\n\tmlxsw_sp->span_ops = &mlxsw_sp1_span_ops;\n\tmlxsw_sp->policer_core_ops = &mlxsw_sp1_policer_core_ops;\n\tmlxsw_sp->trap_ops = &mlxsw_sp1_trap_ops;\n\tmlxsw_sp->mall_ops = &mlxsw_sp1_mall_ops;\n\tmlxsw_sp->router_ops = &mlxsw_sp1_router_ops;\n\tmlxsw_sp->listeners = mlxsw_sp1_listener;\n\tmlxsw_sp->listeners_count = ARRAY_SIZE(mlxsw_sp1_listener);\n\tmlxsw_sp->fid_family_arr = mlxsw_sp1_fid_family_arr;\n\tmlxsw_sp->lowest_shaper_bs = MLXSW_REG_QEEC_LOWEST_SHAPER_BS_SP1;\n\tmlxsw_sp->pgt_smpe_index_valid = true;\n\n\treturn mlxsw_sp_init(mlxsw_core, mlxsw_bus_info, extack);\n}\n\nstatic int mlxsw_sp2_init(struct mlxsw_core *mlxsw_core,\n\t\t\t  const struct mlxsw_bus_info *mlxsw_bus_info,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\n\tmlxsw_sp->switchdev_ops = &mlxsw_sp2_switchdev_ops;\n\tmlxsw_sp->kvdl_ops = &mlxsw_sp2_kvdl_ops;\n\tmlxsw_sp->afa_ops = &mlxsw_sp2_act_afa_ops;\n\tmlxsw_sp->afk_ops = &mlxsw_sp2_afk_ops;\n\tmlxsw_sp->mr_tcam_ops = &mlxsw_sp2_mr_tcam_ops;\n\tmlxsw_sp->acl_rulei_ops = &mlxsw_sp2_acl_rulei_ops;\n\tmlxsw_sp->acl_tcam_ops = &mlxsw_sp2_acl_tcam_ops;\n\tmlxsw_sp->acl_bf_ops = &mlxsw_sp2_acl_bf_ops;\n\tmlxsw_sp->nve_ops_arr = mlxsw_sp2_nve_ops_arr;\n\tmlxsw_sp->mac_mask = mlxsw_sp2_mac_mask;\n\tmlxsw_sp->sb_vals = &mlxsw_sp2_sb_vals;\n\tmlxsw_sp->sb_ops = &mlxsw_sp2_sb_ops;\n\tmlxsw_sp->port_type_speed_ops = &mlxsw_sp2_port_type_speed_ops;\n\tmlxsw_sp->ptp_ops = &mlxsw_sp2_ptp_ops;\n\tmlxsw_sp->span_ops = &mlxsw_sp2_span_ops;\n\tmlxsw_sp->policer_core_ops = &mlxsw_sp2_policer_core_ops;\n\tmlxsw_sp->trap_ops = &mlxsw_sp2_trap_ops;\n\tmlxsw_sp->mall_ops = &mlxsw_sp2_mall_ops;\n\tmlxsw_sp->router_ops = &mlxsw_sp2_router_ops;\n\tmlxsw_sp->listeners = mlxsw_sp2_listener;\n\tmlxsw_sp->listeners_count = ARRAY_SIZE(mlxsw_sp2_listener);\n\tmlxsw_sp->fid_family_arr = mlxsw_sp2_fid_family_arr;\n\tmlxsw_sp->lowest_shaper_bs = MLXSW_REG_QEEC_LOWEST_SHAPER_BS_SP2;\n\tmlxsw_sp->pgt_smpe_index_valid = false;\n\n\treturn mlxsw_sp_init(mlxsw_core, mlxsw_bus_info, extack);\n}\n\nstatic int mlxsw_sp3_init(struct mlxsw_core *mlxsw_core,\n\t\t\t  const struct mlxsw_bus_info *mlxsw_bus_info,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\n\tmlxsw_sp->switchdev_ops = &mlxsw_sp2_switchdev_ops;\n\tmlxsw_sp->kvdl_ops = &mlxsw_sp2_kvdl_ops;\n\tmlxsw_sp->afa_ops = &mlxsw_sp2_act_afa_ops;\n\tmlxsw_sp->afk_ops = &mlxsw_sp2_afk_ops;\n\tmlxsw_sp->mr_tcam_ops = &mlxsw_sp2_mr_tcam_ops;\n\tmlxsw_sp->acl_rulei_ops = &mlxsw_sp2_acl_rulei_ops;\n\tmlxsw_sp->acl_tcam_ops = &mlxsw_sp2_acl_tcam_ops;\n\tmlxsw_sp->acl_bf_ops = &mlxsw_sp2_acl_bf_ops;\n\tmlxsw_sp->nve_ops_arr = mlxsw_sp2_nve_ops_arr;\n\tmlxsw_sp->mac_mask = mlxsw_sp2_mac_mask;\n\tmlxsw_sp->sb_vals = &mlxsw_sp2_sb_vals;\n\tmlxsw_sp->sb_ops = &mlxsw_sp3_sb_ops;\n\tmlxsw_sp->port_type_speed_ops = &mlxsw_sp2_port_type_speed_ops;\n\tmlxsw_sp->ptp_ops = &mlxsw_sp2_ptp_ops;\n\tmlxsw_sp->span_ops = &mlxsw_sp3_span_ops;\n\tmlxsw_sp->policer_core_ops = &mlxsw_sp2_policer_core_ops;\n\tmlxsw_sp->trap_ops = &mlxsw_sp2_trap_ops;\n\tmlxsw_sp->mall_ops = &mlxsw_sp2_mall_ops;\n\tmlxsw_sp->router_ops = &mlxsw_sp2_router_ops;\n\tmlxsw_sp->listeners = mlxsw_sp2_listener;\n\tmlxsw_sp->listeners_count = ARRAY_SIZE(mlxsw_sp2_listener);\n\tmlxsw_sp->fid_family_arr = mlxsw_sp2_fid_family_arr;\n\tmlxsw_sp->lowest_shaper_bs = MLXSW_REG_QEEC_LOWEST_SHAPER_BS_SP3;\n\tmlxsw_sp->pgt_smpe_index_valid = false;\n\n\treturn mlxsw_sp_init(mlxsw_core, mlxsw_bus_info, extack);\n}\n\nstatic int mlxsw_sp4_init(struct mlxsw_core *mlxsw_core,\n\t\t\t  const struct mlxsw_bus_info *mlxsw_bus_info,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\n\tmlxsw_sp->switchdev_ops = &mlxsw_sp2_switchdev_ops;\n\tmlxsw_sp->kvdl_ops = &mlxsw_sp2_kvdl_ops;\n\tmlxsw_sp->afa_ops = &mlxsw_sp2_act_afa_ops;\n\tmlxsw_sp->afk_ops = &mlxsw_sp4_afk_ops;\n\tmlxsw_sp->mr_tcam_ops = &mlxsw_sp2_mr_tcam_ops;\n\tmlxsw_sp->acl_rulei_ops = &mlxsw_sp2_acl_rulei_ops;\n\tmlxsw_sp->acl_tcam_ops = &mlxsw_sp2_acl_tcam_ops;\n\tmlxsw_sp->acl_bf_ops = &mlxsw_sp4_acl_bf_ops;\n\tmlxsw_sp->nve_ops_arr = mlxsw_sp2_nve_ops_arr;\n\tmlxsw_sp->mac_mask = mlxsw_sp2_mac_mask;\n\tmlxsw_sp->sb_vals = &mlxsw_sp2_sb_vals;\n\tmlxsw_sp->sb_ops = &mlxsw_sp3_sb_ops;\n\tmlxsw_sp->port_type_speed_ops = &mlxsw_sp2_port_type_speed_ops;\n\tmlxsw_sp->ptp_ops = &mlxsw_sp4_ptp_ops;\n\tmlxsw_sp->span_ops = &mlxsw_sp3_span_ops;\n\tmlxsw_sp->policer_core_ops = &mlxsw_sp2_policer_core_ops;\n\tmlxsw_sp->trap_ops = &mlxsw_sp2_trap_ops;\n\tmlxsw_sp->mall_ops = &mlxsw_sp2_mall_ops;\n\tmlxsw_sp->router_ops = &mlxsw_sp2_router_ops;\n\tmlxsw_sp->listeners = mlxsw_sp2_listener;\n\tmlxsw_sp->listeners_count = ARRAY_SIZE(mlxsw_sp2_listener);\n\tmlxsw_sp->fid_family_arr = mlxsw_sp2_fid_family_arr;\n\tmlxsw_sp->lowest_shaper_bs = MLXSW_REG_QEEC_LOWEST_SHAPER_BS_SP4;\n\tmlxsw_sp->pgt_smpe_index_valid = false;\n\n\treturn mlxsw_sp_init(mlxsw_core, mlxsw_bus_info, extack);\n}\n\nstatic void mlxsw_sp_fini(struct mlxsw_core *mlxsw_core)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\n\tmlxsw_sp_ports_remove(mlxsw_sp);\n\trhashtable_destroy(&mlxsw_sp->sample_trigger_ht);\n\tmlxsw_sp_port_module_info_fini(mlxsw_sp);\n\tmlxsw_sp_dpipe_fini(mlxsw_sp);\n\tunregister_netdevice_notifier_net(mlxsw_sp_net(mlxsw_sp),\n\t\t\t\t\t  &mlxsw_sp->netdevice_nb);\n\tif (mlxsw_sp->clock) {\n\t\tmlxsw_sp->ptp_ops->fini(mlxsw_sp->ptp_state);\n\t\tmlxsw_sp->ptp_ops->clock_fini(mlxsw_sp->clock);\n\t}\n\tmlxsw_sp_router_fini(mlxsw_sp);\n\tmlxsw_sp_acl_fini(mlxsw_sp);\n\tmlxsw_sp_port_range_fini(mlxsw_sp);\n\tmlxsw_sp_nve_fini(mlxsw_sp);\n\tmlxsw_sp_ipv6_addr_ht_fini(mlxsw_sp);\n\tmlxsw_sp_afa_fini(mlxsw_sp);\n\tmlxsw_sp_counter_pool_fini(mlxsw_sp);\n\tmlxsw_sp_switchdev_fini(mlxsw_sp);\n\tmlxsw_sp_span_fini(mlxsw_sp);\n\tmlxsw_sp_lag_fini(mlxsw_sp);\n\tmlxsw_sp_buffers_fini(mlxsw_sp);\n\tmlxsw_sp_devlink_traps_fini(mlxsw_sp);\n\tmlxsw_sp_traps_fini(mlxsw_sp);\n\tmlxsw_sp_policers_fini(mlxsw_sp);\n\tmlxsw_sp_fids_fini(mlxsw_sp);\n\tmlxsw_sp_pgt_fini(mlxsw_sp);\n\tmlxsw_sp_kvdl_fini(mlxsw_sp);\n\tmlxsw_sp_parsing_fini(mlxsw_sp);\n}\n\nstatic const struct mlxsw_config_profile mlxsw_sp1_config_profile = {\n\t.used_flood_mode                = 1,\n\t.flood_mode                     = MLXSW_CMD_MBOX_CONFIG_PROFILE_FLOOD_MODE_CONTROLLED,\n\t.used_max_ib_mc\t\t\t= 1,\n\t.max_ib_mc\t\t\t= 0,\n\t.used_max_pkey\t\t\t= 1,\n\t.max_pkey\t\t\t= 0,\n\t.used_ubridge\t\t\t= 1,\n\t.ubridge\t\t\t= 1,\n\t.used_kvd_sizes\t\t\t= 1,\n\t.kvd_hash_single_parts\t\t= 59,\n\t.kvd_hash_double_parts\t\t= 41,\n\t.kvd_linear_size\t\t= MLXSW_SP_KVD_LINEAR_SIZE,\n\t.swid_config\t\t\t= {\n\t\t{\n\t\t\t.used_type\t= 1,\n\t\t\t.type\t\t= MLXSW_PORT_SWID_TYPE_ETH,\n\t\t}\n\t},\n};\n\nstatic const struct mlxsw_config_profile mlxsw_sp2_config_profile = {\n\t.used_flood_mode                = 1,\n\t.flood_mode                     = MLXSW_CMD_MBOX_CONFIG_PROFILE_FLOOD_MODE_CONTROLLED,\n\t.used_max_ib_mc\t\t\t= 1,\n\t.max_ib_mc\t\t\t= 0,\n\t.used_max_pkey\t\t\t= 1,\n\t.max_pkey\t\t\t= 0,\n\t.used_ubridge\t\t\t= 1,\n\t.ubridge\t\t\t= 1,\n\t.swid_config\t\t\t= {\n\t\t{\n\t\t\t.used_type\t= 1,\n\t\t\t.type\t\t= MLXSW_PORT_SWID_TYPE_ETH,\n\t\t}\n\t},\n\t.used_cqe_time_stamp_type\t= 1,\n\t.cqe_time_stamp_type\t\t= MLXSW_CMD_MBOX_CONFIG_PROFILE_CQE_TIME_STAMP_TYPE_UTC,\n};\n\n \n#define MLXSW_SP4_CONFIG_PROFILE_MAX_LAG 128\n\nstatic const struct mlxsw_config_profile mlxsw_sp4_config_profile = {\n\t.used_max_lag\t\t\t= 1,\n\t.max_lag\t\t\t= MLXSW_SP4_CONFIG_PROFILE_MAX_LAG,\n\t.used_flood_mode                = 1,\n\t.flood_mode                     = MLXSW_CMD_MBOX_CONFIG_PROFILE_FLOOD_MODE_CONTROLLED,\n\t.used_max_ib_mc\t\t\t= 1,\n\t.max_ib_mc\t\t\t= 0,\n\t.used_max_pkey\t\t\t= 1,\n\t.max_pkey\t\t\t= 0,\n\t.used_ubridge\t\t\t= 1,\n\t.ubridge\t\t\t= 1,\n\t.swid_config\t\t\t= {\n\t\t{\n\t\t\t.used_type\t= 1,\n\t\t\t.type\t\t= MLXSW_PORT_SWID_TYPE_ETH,\n\t\t}\n\t},\n\t.used_cqe_time_stamp_type\t= 1,\n\t.cqe_time_stamp_type\t\t= MLXSW_CMD_MBOX_CONFIG_PROFILE_CQE_TIME_STAMP_TYPE_UTC,\n};\n\nstatic void\nmlxsw_sp_resource_size_params_prepare(struct mlxsw_core *mlxsw_core,\n\t\t\t\t      struct devlink_resource_size_params *kvd_size_params,\n\t\t\t\t      struct devlink_resource_size_params *linear_size_params,\n\t\t\t\t      struct devlink_resource_size_params *hash_double_size_params,\n\t\t\t\t      struct devlink_resource_size_params *hash_single_size_params)\n{\n\tu32 single_size_min = MLXSW_CORE_RES_GET(mlxsw_core,\n\t\t\t\t\t\t KVD_SINGLE_MIN_SIZE);\n\tu32 double_size_min = MLXSW_CORE_RES_GET(mlxsw_core,\n\t\t\t\t\t\t KVD_DOUBLE_MIN_SIZE);\n\tu32 kvd_size = MLXSW_CORE_RES_GET(mlxsw_core, KVD_SIZE);\n\tu32 linear_size_min = 0;\n\n\tdevlink_resource_size_params_init(kvd_size_params, kvd_size, kvd_size,\n\t\t\t\t\t  MLXSW_SP_KVD_GRANULARITY,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\tdevlink_resource_size_params_init(linear_size_params, linear_size_min,\n\t\t\t\t\t  kvd_size - single_size_min -\n\t\t\t\t\t  double_size_min,\n\t\t\t\t\t  MLXSW_SP_KVD_GRANULARITY,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\tdevlink_resource_size_params_init(hash_double_size_params,\n\t\t\t\t\t  double_size_min,\n\t\t\t\t\t  kvd_size - single_size_min -\n\t\t\t\t\t  linear_size_min,\n\t\t\t\t\t  MLXSW_SP_KVD_GRANULARITY,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\tdevlink_resource_size_params_init(hash_single_size_params,\n\t\t\t\t\t  single_size_min,\n\t\t\t\t\t  kvd_size - double_size_min -\n\t\t\t\t\t  linear_size_min,\n\t\t\t\t\t  MLXSW_SP_KVD_GRANULARITY,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n}\n\nstatic int mlxsw_sp1_resources_kvd_register(struct mlxsw_core *mlxsw_core)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tstruct devlink_resource_size_params hash_single_size_params;\n\tstruct devlink_resource_size_params hash_double_size_params;\n\tstruct devlink_resource_size_params linear_size_params;\n\tstruct devlink_resource_size_params kvd_size_params;\n\tu32 kvd_size, single_size, double_size, linear_size;\n\tconst struct mlxsw_config_profile *profile;\n\tint err;\n\n\tprofile = &mlxsw_sp1_config_profile;\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_core, KVD_SIZE))\n\t\treturn -EIO;\n\n\tmlxsw_sp_resource_size_params_prepare(mlxsw_core, &kvd_size_params,\n\t\t\t\t\t      &linear_size_params,\n\t\t\t\t\t      &hash_double_size_params,\n\t\t\t\t\t      &hash_single_size_params);\n\n\tkvd_size = MLXSW_CORE_RES_GET(mlxsw_core, KVD_SIZE);\n\terr = devl_resource_register(devlink, MLXSW_SP_RESOURCE_NAME_KVD,\n\t\t\t\t     kvd_size, MLXSW_SP_RESOURCE_KVD,\n\t\t\t\t     DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t     &kvd_size_params);\n\tif (err)\n\t\treturn err;\n\n\tlinear_size = profile->kvd_linear_size;\n\terr = devl_resource_register(devlink, MLXSW_SP_RESOURCE_NAME_KVD_LINEAR,\n\t\t\t\t     linear_size,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD_LINEAR,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD,\n\t\t\t\t     &linear_size_params);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp1_kvdl_resources_register(mlxsw_core);\n\tif  (err)\n\t\treturn err;\n\n\tdouble_size = kvd_size - linear_size;\n\tdouble_size *= profile->kvd_hash_double_parts;\n\tdouble_size /= profile->kvd_hash_double_parts +\n\t\t       profile->kvd_hash_single_parts;\n\tdouble_size = rounddown(double_size, MLXSW_SP_KVD_GRANULARITY);\n\terr = devl_resource_register(devlink, MLXSW_SP_RESOURCE_NAME_KVD_HASH_DOUBLE,\n\t\t\t\t     double_size,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD_HASH_DOUBLE,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD,\n\t\t\t\t     &hash_double_size_params);\n\tif (err)\n\t\treturn err;\n\n\tsingle_size = kvd_size - double_size - linear_size;\n\terr = devl_resource_register(devlink, MLXSW_SP_RESOURCE_NAME_KVD_HASH_SINGLE,\n\t\t\t\t     single_size,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD_HASH_SINGLE,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD,\n\t\t\t\t     &hash_single_size_params);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp2_resources_kvd_register(struct mlxsw_core *mlxsw_core)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tstruct devlink_resource_size_params kvd_size_params;\n\tu32 kvd_size;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_core, KVD_SIZE))\n\t\treturn -EIO;\n\n\tkvd_size = MLXSW_CORE_RES_GET(mlxsw_core, KVD_SIZE);\n\tdevlink_resource_size_params_init(&kvd_size_params, kvd_size, kvd_size,\n\t\t\t\t\t  MLXSW_SP_KVD_GRANULARITY,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\n\treturn devl_resource_register(devlink, MLXSW_SP_RESOURCE_NAME_KVD,\n\t\t\t\t      kvd_size, MLXSW_SP_RESOURCE_KVD,\n\t\t\t\t      DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t      &kvd_size_params);\n}\n\nstatic int mlxsw_sp_resources_span_register(struct mlxsw_core *mlxsw_core)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tstruct devlink_resource_size_params span_size_params;\n\tu32 max_span;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_core, MAX_SPAN))\n\t\treturn -EIO;\n\n\tmax_span = MLXSW_CORE_RES_GET(mlxsw_core, MAX_SPAN);\n\tdevlink_resource_size_params_init(&span_size_params, max_span, max_span,\n\t\t\t\t\t  1, DEVLINK_RESOURCE_UNIT_ENTRY);\n\n\treturn devl_resource_register(devlink, MLXSW_SP_RESOURCE_NAME_SPAN,\n\t\t\t\t      max_span, MLXSW_SP_RESOURCE_SPAN,\n\t\t\t\t      DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t      &span_size_params);\n}\n\nstatic int\nmlxsw_sp_resources_rif_mac_profile_register(struct mlxsw_core *mlxsw_core)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tstruct devlink_resource_size_params size_params;\n\tu8 max_rif_mac_profiles;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_core, MAX_RIF_MAC_PROFILES))\n\t\tmax_rif_mac_profiles = 1;\n\telse\n\t\tmax_rif_mac_profiles = MLXSW_CORE_RES_GET(mlxsw_core,\n\t\t\t\t\t\t\t  MAX_RIF_MAC_PROFILES);\n\tdevlink_resource_size_params_init(&size_params, max_rif_mac_profiles,\n\t\t\t\t\t  max_rif_mac_profiles, 1,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\n\treturn devl_resource_register(devlink,\n\t\t\t\t      \"rif_mac_profiles\",\n\t\t\t\t      max_rif_mac_profiles,\n\t\t\t\t      MLXSW_SP_RESOURCE_RIF_MAC_PROFILES,\n\t\t\t\t      DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t      &size_params);\n}\n\nstatic int mlxsw_sp_resources_rifs_register(struct mlxsw_core *mlxsw_core)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tstruct devlink_resource_size_params size_params;\n\tu64 max_rifs;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_core, MAX_RIFS))\n\t\treturn -EIO;\n\n\tmax_rifs = MLXSW_CORE_RES_GET(mlxsw_core, MAX_RIFS);\n\tdevlink_resource_size_params_init(&size_params, max_rifs, max_rifs,\n\t\t\t\t\t  1, DEVLINK_RESOURCE_UNIT_ENTRY);\n\n\treturn devl_resource_register(devlink, \"rifs\", max_rifs,\n\t\t\t\t      MLXSW_SP_RESOURCE_RIFS,\n\t\t\t\t      DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t      &size_params);\n}\n\nstatic int\nmlxsw_sp_resources_port_range_register(struct mlxsw_core *mlxsw_core)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tstruct devlink_resource_size_params size_params;\n\tu64 max;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_core, ACL_MAX_L4_PORT_RANGE))\n\t\treturn -EIO;\n\n\tmax = MLXSW_CORE_RES_GET(mlxsw_core, ACL_MAX_L4_PORT_RANGE);\n\tdevlink_resource_size_params_init(&size_params, max, max, 1,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\n\treturn devl_resource_register(devlink, \"port_range_registers\", max,\n\t\t\t\t      MLXSW_SP_RESOURCE_PORT_RANGE_REGISTERS,\n\t\t\t\t      DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t      &size_params);\n}\n\nstatic int mlxsw_sp1_resources_register(struct mlxsw_core *mlxsw_core)\n{\n\tint err;\n\n\terr = mlxsw_sp1_resources_kvd_register(mlxsw_core);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_resources_span_register(mlxsw_core);\n\tif (err)\n\t\tgoto err_resources_span_register;\n\n\terr = mlxsw_sp_counter_resources_register(mlxsw_core);\n\tif (err)\n\t\tgoto err_resources_counter_register;\n\n\terr = mlxsw_sp_policer_resources_register(mlxsw_core);\n\tif (err)\n\t\tgoto err_policer_resources_register;\n\n\terr = mlxsw_sp_resources_rif_mac_profile_register(mlxsw_core);\n\tif (err)\n\t\tgoto err_resources_rif_mac_profile_register;\n\n\terr = mlxsw_sp_resources_rifs_register(mlxsw_core);\n\tif (err)\n\t\tgoto err_resources_rifs_register;\n\n\terr = mlxsw_sp_resources_port_range_register(mlxsw_core);\n\tif (err)\n\t\tgoto err_resources_port_range_register;\n\n\treturn 0;\n\nerr_resources_port_range_register:\nerr_resources_rifs_register:\nerr_resources_rif_mac_profile_register:\nerr_policer_resources_register:\nerr_resources_counter_register:\nerr_resources_span_register:\n\tdevl_resources_unregister(priv_to_devlink(mlxsw_core));\n\treturn err;\n}\n\nstatic int mlxsw_sp2_resources_register(struct mlxsw_core *mlxsw_core)\n{\n\tint err;\n\n\terr = mlxsw_sp2_resources_kvd_register(mlxsw_core);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_resources_span_register(mlxsw_core);\n\tif (err)\n\t\tgoto err_resources_span_register;\n\n\terr = mlxsw_sp_counter_resources_register(mlxsw_core);\n\tif (err)\n\t\tgoto err_resources_counter_register;\n\n\terr = mlxsw_sp_policer_resources_register(mlxsw_core);\n\tif (err)\n\t\tgoto err_policer_resources_register;\n\n\terr = mlxsw_sp_resources_rif_mac_profile_register(mlxsw_core);\n\tif (err)\n\t\tgoto err_resources_rif_mac_profile_register;\n\n\terr = mlxsw_sp_resources_rifs_register(mlxsw_core);\n\tif (err)\n\t\tgoto err_resources_rifs_register;\n\n\terr = mlxsw_sp_resources_port_range_register(mlxsw_core);\n\tif (err)\n\t\tgoto err_resources_port_range_register;\n\n\treturn 0;\n\nerr_resources_port_range_register:\nerr_resources_rifs_register:\nerr_resources_rif_mac_profile_register:\nerr_policer_resources_register:\nerr_resources_counter_register:\nerr_resources_span_register:\n\tdevl_resources_unregister(priv_to_devlink(mlxsw_core));\n\treturn err;\n}\n\nstatic int mlxsw_sp_kvd_sizes_get(struct mlxsw_core *mlxsw_core,\n\t\t\t\t  const struct mlxsw_config_profile *profile,\n\t\t\t\t  u64 *p_single_size, u64 *p_double_size,\n\t\t\t\t  u64 *p_linear_size)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tu32 double_size;\n\tint err;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_core, KVD_SINGLE_MIN_SIZE) ||\n\t    !MLXSW_CORE_RES_VALID(mlxsw_core, KVD_DOUBLE_MIN_SIZE))\n\t\treturn -EIO;\n\n\t \n\terr = devl_resource_size_get(devlink,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD_LINEAR,\n\t\t\t\t     p_linear_size);\n\tif (err)\n\t\t*p_linear_size = profile->kvd_linear_size;\n\n\terr = devl_resource_size_get(devlink,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD_HASH_DOUBLE,\n\t\t\t\t     p_double_size);\n\tif (err) {\n\t\tdouble_size = MLXSW_CORE_RES_GET(mlxsw_core, KVD_SIZE) -\n\t\t\t      *p_linear_size;\n\t\tdouble_size *= profile->kvd_hash_double_parts;\n\t\tdouble_size /= profile->kvd_hash_double_parts +\n\t\t\t       profile->kvd_hash_single_parts;\n\t\t*p_double_size = rounddown(double_size,\n\t\t\t\t\t   MLXSW_SP_KVD_GRANULARITY);\n\t}\n\n\terr = devl_resource_size_get(devlink,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD_HASH_SINGLE,\n\t\t\t\t     p_single_size);\n\tif (err)\n\t\t*p_single_size = MLXSW_CORE_RES_GET(mlxsw_core, KVD_SIZE) -\n\t\t\t\t *p_double_size - *p_linear_size;\n\n\t \n\tif (*p_single_size < MLXSW_CORE_RES_GET(mlxsw_core, KVD_SINGLE_MIN_SIZE) ||\n\t    *p_double_size < MLXSW_CORE_RES_GET(mlxsw_core, KVD_DOUBLE_MIN_SIZE) ||\n\t    MLXSW_CORE_RES_GET(mlxsw_core, KVD_SIZE) < *p_linear_size)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_ptp_transmitted(struct mlxsw_core *mlxsw_core,\n\t\t\t\t     struct sk_buff *skb, u16 local_port)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\n\tskb_pull(skb, MLXSW_TXHDR_LEN);\n\tmlxsw_sp->ptp_ops->transmitted(mlxsw_sp, skb, local_port);\n}\n\nstatic struct mlxsw_driver mlxsw_sp1_driver = {\n\t.kind\t\t\t\t= mlxsw_sp1_driver_name,\n\t.priv_size\t\t\t= sizeof(struct mlxsw_sp),\n\t.fw_req_rev\t\t\t= &mlxsw_sp1_fw_rev,\n\t.fw_filename\t\t\t= MLXSW_SP1_FW_FILENAME,\n\t.init\t\t\t\t= mlxsw_sp1_init,\n\t.fini\t\t\t\t= mlxsw_sp_fini,\n\t.port_split\t\t\t= mlxsw_sp_port_split,\n\t.port_unsplit\t\t\t= mlxsw_sp_port_unsplit,\n\t.sb_pool_get\t\t\t= mlxsw_sp_sb_pool_get,\n\t.sb_pool_set\t\t\t= mlxsw_sp_sb_pool_set,\n\t.sb_port_pool_get\t\t= mlxsw_sp_sb_port_pool_get,\n\t.sb_port_pool_set\t\t= mlxsw_sp_sb_port_pool_set,\n\t.sb_tc_pool_bind_get\t\t= mlxsw_sp_sb_tc_pool_bind_get,\n\t.sb_tc_pool_bind_set\t\t= mlxsw_sp_sb_tc_pool_bind_set,\n\t.sb_occ_snapshot\t\t= mlxsw_sp_sb_occ_snapshot,\n\t.sb_occ_max_clear\t\t= mlxsw_sp_sb_occ_max_clear,\n\t.sb_occ_port_pool_get\t\t= mlxsw_sp_sb_occ_port_pool_get,\n\t.sb_occ_tc_port_bind_get\t= mlxsw_sp_sb_occ_tc_port_bind_get,\n\t.trap_init\t\t\t= mlxsw_sp_trap_init,\n\t.trap_fini\t\t\t= mlxsw_sp_trap_fini,\n\t.trap_action_set\t\t= mlxsw_sp_trap_action_set,\n\t.trap_group_init\t\t= mlxsw_sp_trap_group_init,\n\t.trap_group_set\t\t\t= mlxsw_sp_trap_group_set,\n\t.trap_policer_init\t\t= mlxsw_sp_trap_policer_init,\n\t.trap_policer_fini\t\t= mlxsw_sp_trap_policer_fini,\n\t.trap_policer_set\t\t= mlxsw_sp_trap_policer_set,\n\t.trap_policer_counter_get\t= mlxsw_sp_trap_policer_counter_get,\n\t.txhdr_construct\t\t= mlxsw_sp_txhdr_construct,\n\t.resources_register\t\t= mlxsw_sp1_resources_register,\n\t.kvd_sizes_get\t\t\t= mlxsw_sp_kvd_sizes_get,\n\t.ptp_transmitted\t\t= mlxsw_sp_ptp_transmitted,\n\t.txhdr_len\t\t\t= MLXSW_TXHDR_LEN,\n\t.profile\t\t\t= &mlxsw_sp1_config_profile,\n\t.sdq_supports_cqe_v2\t\t= false,\n};\n\nstatic struct mlxsw_driver mlxsw_sp2_driver = {\n\t.kind\t\t\t\t= mlxsw_sp2_driver_name,\n\t.priv_size\t\t\t= sizeof(struct mlxsw_sp),\n\t.fw_req_rev\t\t\t= &mlxsw_sp2_fw_rev,\n\t.fw_filename\t\t\t= MLXSW_SP2_FW_FILENAME,\n\t.init\t\t\t\t= mlxsw_sp2_init,\n\t.fini\t\t\t\t= mlxsw_sp_fini,\n\t.port_split\t\t\t= mlxsw_sp_port_split,\n\t.port_unsplit\t\t\t= mlxsw_sp_port_unsplit,\n\t.ports_remove_selected\t\t= mlxsw_sp_ports_remove_selected,\n\t.sb_pool_get\t\t\t= mlxsw_sp_sb_pool_get,\n\t.sb_pool_set\t\t\t= mlxsw_sp_sb_pool_set,\n\t.sb_port_pool_get\t\t= mlxsw_sp_sb_port_pool_get,\n\t.sb_port_pool_set\t\t= mlxsw_sp_sb_port_pool_set,\n\t.sb_tc_pool_bind_get\t\t= mlxsw_sp_sb_tc_pool_bind_get,\n\t.sb_tc_pool_bind_set\t\t= mlxsw_sp_sb_tc_pool_bind_set,\n\t.sb_occ_snapshot\t\t= mlxsw_sp_sb_occ_snapshot,\n\t.sb_occ_max_clear\t\t= mlxsw_sp_sb_occ_max_clear,\n\t.sb_occ_port_pool_get\t\t= mlxsw_sp_sb_occ_port_pool_get,\n\t.sb_occ_tc_port_bind_get\t= mlxsw_sp_sb_occ_tc_port_bind_get,\n\t.trap_init\t\t\t= mlxsw_sp_trap_init,\n\t.trap_fini\t\t\t= mlxsw_sp_trap_fini,\n\t.trap_action_set\t\t= mlxsw_sp_trap_action_set,\n\t.trap_group_init\t\t= mlxsw_sp_trap_group_init,\n\t.trap_group_set\t\t\t= mlxsw_sp_trap_group_set,\n\t.trap_policer_init\t\t= mlxsw_sp_trap_policer_init,\n\t.trap_policer_fini\t\t= mlxsw_sp_trap_policer_fini,\n\t.trap_policer_set\t\t= mlxsw_sp_trap_policer_set,\n\t.trap_policer_counter_get\t= mlxsw_sp_trap_policer_counter_get,\n\t.txhdr_construct\t\t= mlxsw_sp_txhdr_construct,\n\t.resources_register\t\t= mlxsw_sp2_resources_register,\n\t.ptp_transmitted\t\t= mlxsw_sp_ptp_transmitted,\n\t.txhdr_len\t\t\t= MLXSW_TXHDR_LEN,\n\t.profile\t\t\t= &mlxsw_sp2_config_profile,\n\t.sdq_supports_cqe_v2\t\t= true,\n};\n\nstatic struct mlxsw_driver mlxsw_sp3_driver = {\n\t.kind\t\t\t\t= mlxsw_sp3_driver_name,\n\t.priv_size\t\t\t= sizeof(struct mlxsw_sp),\n\t.fw_req_rev\t\t\t= &mlxsw_sp3_fw_rev,\n\t.fw_filename\t\t\t= MLXSW_SP3_FW_FILENAME,\n\t.init\t\t\t\t= mlxsw_sp3_init,\n\t.fini\t\t\t\t= mlxsw_sp_fini,\n\t.port_split\t\t\t= mlxsw_sp_port_split,\n\t.port_unsplit\t\t\t= mlxsw_sp_port_unsplit,\n\t.ports_remove_selected\t\t= mlxsw_sp_ports_remove_selected,\n\t.sb_pool_get\t\t\t= mlxsw_sp_sb_pool_get,\n\t.sb_pool_set\t\t\t= mlxsw_sp_sb_pool_set,\n\t.sb_port_pool_get\t\t= mlxsw_sp_sb_port_pool_get,\n\t.sb_port_pool_set\t\t= mlxsw_sp_sb_port_pool_set,\n\t.sb_tc_pool_bind_get\t\t= mlxsw_sp_sb_tc_pool_bind_get,\n\t.sb_tc_pool_bind_set\t\t= mlxsw_sp_sb_tc_pool_bind_set,\n\t.sb_occ_snapshot\t\t= mlxsw_sp_sb_occ_snapshot,\n\t.sb_occ_max_clear\t\t= mlxsw_sp_sb_occ_max_clear,\n\t.sb_occ_port_pool_get\t\t= mlxsw_sp_sb_occ_port_pool_get,\n\t.sb_occ_tc_port_bind_get\t= mlxsw_sp_sb_occ_tc_port_bind_get,\n\t.trap_init\t\t\t= mlxsw_sp_trap_init,\n\t.trap_fini\t\t\t= mlxsw_sp_trap_fini,\n\t.trap_action_set\t\t= mlxsw_sp_trap_action_set,\n\t.trap_group_init\t\t= mlxsw_sp_trap_group_init,\n\t.trap_group_set\t\t\t= mlxsw_sp_trap_group_set,\n\t.trap_policer_init\t\t= mlxsw_sp_trap_policer_init,\n\t.trap_policer_fini\t\t= mlxsw_sp_trap_policer_fini,\n\t.trap_policer_set\t\t= mlxsw_sp_trap_policer_set,\n\t.trap_policer_counter_get\t= mlxsw_sp_trap_policer_counter_get,\n\t.txhdr_construct\t\t= mlxsw_sp_txhdr_construct,\n\t.resources_register\t\t= mlxsw_sp2_resources_register,\n\t.ptp_transmitted\t\t= mlxsw_sp_ptp_transmitted,\n\t.txhdr_len\t\t\t= MLXSW_TXHDR_LEN,\n\t.profile\t\t\t= &mlxsw_sp2_config_profile,\n\t.sdq_supports_cqe_v2\t\t= true,\n};\n\nstatic struct mlxsw_driver mlxsw_sp4_driver = {\n\t.kind\t\t\t\t= mlxsw_sp4_driver_name,\n\t.priv_size\t\t\t= sizeof(struct mlxsw_sp),\n\t.init\t\t\t\t= mlxsw_sp4_init,\n\t.fini\t\t\t\t= mlxsw_sp_fini,\n\t.port_split\t\t\t= mlxsw_sp_port_split,\n\t.port_unsplit\t\t\t= mlxsw_sp_port_unsplit,\n\t.ports_remove_selected\t\t= mlxsw_sp_ports_remove_selected,\n\t.sb_pool_get\t\t\t= mlxsw_sp_sb_pool_get,\n\t.sb_pool_set\t\t\t= mlxsw_sp_sb_pool_set,\n\t.sb_port_pool_get\t\t= mlxsw_sp_sb_port_pool_get,\n\t.sb_port_pool_set\t\t= mlxsw_sp_sb_port_pool_set,\n\t.sb_tc_pool_bind_get\t\t= mlxsw_sp_sb_tc_pool_bind_get,\n\t.sb_tc_pool_bind_set\t\t= mlxsw_sp_sb_tc_pool_bind_set,\n\t.sb_occ_snapshot\t\t= mlxsw_sp_sb_occ_snapshot,\n\t.sb_occ_max_clear\t\t= mlxsw_sp_sb_occ_max_clear,\n\t.sb_occ_port_pool_get\t\t= mlxsw_sp_sb_occ_port_pool_get,\n\t.sb_occ_tc_port_bind_get\t= mlxsw_sp_sb_occ_tc_port_bind_get,\n\t.trap_init\t\t\t= mlxsw_sp_trap_init,\n\t.trap_fini\t\t\t= mlxsw_sp_trap_fini,\n\t.trap_action_set\t\t= mlxsw_sp_trap_action_set,\n\t.trap_group_init\t\t= mlxsw_sp_trap_group_init,\n\t.trap_group_set\t\t\t= mlxsw_sp_trap_group_set,\n\t.trap_policer_init\t\t= mlxsw_sp_trap_policer_init,\n\t.trap_policer_fini\t\t= mlxsw_sp_trap_policer_fini,\n\t.trap_policer_set\t\t= mlxsw_sp_trap_policer_set,\n\t.trap_policer_counter_get\t= mlxsw_sp_trap_policer_counter_get,\n\t.txhdr_construct\t\t= mlxsw_sp_txhdr_construct,\n\t.resources_register\t\t= mlxsw_sp2_resources_register,\n\t.ptp_transmitted\t\t= mlxsw_sp_ptp_transmitted,\n\t.txhdr_len\t\t\t= MLXSW_TXHDR_LEN,\n\t.profile\t\t\t= &mlxsw_sp4_config_profile,\n\t.sdq_supports_cqe_v2\t\t= true,\n};\n\nbool mlxsw_sp_port_dev_check(const struct net_device *dev)\n{\n\treturn dev->netdev_ops == &mlxsw_sp_port_netdev_ops;\n}\n\nstatic int mlxsw_sp_lower_dev_walk(struct net_device *lower_dev,\n\t\t\t\t   struct netdev_nested_priv *priv)\n{\n\tint ret = 0;\n\n\tif (mlxsw_sp_port_dev_check(lower_dev)) {\n\t\tpriv->data = (void *)netdev_priv(lower_dev);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstruct mlxsw_sp_port *mlxsw_sp_port_dev_lower_find(struct net_device *dev)\n{\n\tstruct netdev_nested_priv priv = {\n\t\t.data = NULL,\n\t};\n\n\tif (mlxsw_sp_port_dev_check(dev))\n\t\treturn netdev_priv(dev);\n\n\tnetdev_walk_all_lower_dev(dev, mlxsw_sp_lower_dev_walk, &priv);\n\n\treturn (struct mlxsw_sp_port *)priv.data;\n}\n\nstruct mlxsw_sp *mlxsw_sp_lower_get(struct net_device *dev)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\n\tmlxsw_sp_port = mlxsw_sp_port_dev_lower_find(dev);\n\treturn mlxsw_sp_port ? mlxsw_sp_port->mlxsw_sp : NULL;\n}\n\nstruct mlxsw_sp_port *mlxsw_sp_port_dev_lower_find_rcu(struct net_device *dev)\n{\n\tstruct netdev_nested_priv priv = {\n\t\t.data = NULL,\n\t};\n\n\tif (mlxsw_sp_port_dev_check(dev))\n\t\treturn netdev_priv(dev);\n\n\tnetdev_walk_all_lower_dev_rcu(dev, mlxsw_sp_lower_dev_walk,\n\t\t\t\t      &priv);\n\n\treturn (struct mlxsw_sp_port *)priv.data;\n}\n\nint mlxsw_sp_parsing_depth_inc(struct mlxsw_sp *mlxsw_sp)\n{\n\tchar mprs_pl[MLXSW_REG_MPRS_LEN];\n\tint err = 0;\n\n\tmutex_lock(&mlxsw_sp->parsing.lock);\n\n\tif (refcount_inc_not_zero(&mlxsw_sp->parsing.parsing_depth_ref))\n\t\tgoto out_unlock;\n\n\tmlxsw_reg_mprs_pack(mprs_pl, MLXSW_SP_INCREASED_PARSING_DEPTH,\n\t\t\t    mlxsw_sp->parsing.vxlan_udp_dport);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mprs), mprs_pl);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tmlxsw_sp->parsing.parsing_depth = MLXSW_SP_INCREASED_PARSING_DEPTH;\n\trefcount_set(&mlxsw_sp->parsing.parsing_depth_ref, 1);\n\nout_unlock:\n\tmutex_unlock(&mlxsw_sp->parsing.lock);\n\treturn err;\n}\n\nvoid mlxsw_sp_parsing_depth_dec(struct mlxsw_sp *mlxsw_sp)\n{\n\tchar mprs_pl[MLXSW_REG_MPRS_LEN];\n\n\tmutex_lock(&mlxsw_sp->parsing.lock);\n\n\tif (!refcount_dec_and_test(&mlxsw_sp->parsing.parsing_depth_ref))\n\t\tgoto out_unlock;\n\n\tmlxsw_reg_mprs_pack(mprs_pl, MLXSW_SP_DEFAULT_PARSING_DEPTH,\n\t\t\t    mlxsw_sp->parsing.vxlan_udp_dport);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mprs), mprs_pl);\n\tmlxsw_sp->parsing.parsing_depth = MLXSW_SP_DEFAULT_PARSING_DEPTH;\n\nout_unlock:\n\tmutex_unlock(&mlxsw_sp->parsing.lock);\n}\n\nint mlxsw_sp_parsing_vxlan_udp_dport_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t __be16 udp_dport)\n{\n\tchar mprs_pl[MLXSW_REG_MPRS_LEN];\n\tint err;\n\n\tmutex_lock(&mlxsw_sp->parsing.lock);\n\n\tmlxsw_reg_mprs_pack(mprs_pl, mlxsw_sp->parsing.parsing_depth,\n\t\t\t    be16_to_cpu(udp_dport));\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mprs), mprs_pl);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tmlxsw_sp->parsing.vxlan_udp_dport = be16_to_cpu(udp_dport);\n\nout_unlock:\n\tmutex_unlock(&mlxsw_sp->parsing.lock);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_port_lag_uppers_cleanup(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t struct net_device *lag_dev)\n{\n\tstruct net_device *br_dev = netdev_master_upper_dev_get(lag_dev);\n\tstruct net_device *upper_dev;\n\tstruct list_head *iter;\n\n\tif (netif_is_bridge_port(lag_dev))\n\t\tmlxsw_sp_port_bridge_leave(mlxsw_sp_port, lag_dev, br_dev);\n\n\tnetdev_for_each_upper_dev_rcu(lag_dev, upper_dev, iter) {\n\t\tif (!netif_is_bridge_port(upper_dev))\n\t\t\tcontinue;\n\t\tbr_dev = netdev_master_upper_dev_get(upper_dev);\n\t\tmlxsw_sp_port_bridge_leave(mlxsw_sp_port, upper_dev, br_dev);\n\t}\n}\n\nstatic int mlxsw_sp_lag_create(struct mlxsw_sp *mlxsw_sp, u16 lag_id)\n{\n\tchar sldr_pl[MLXSW_REG_SLDR_LEN];\n\n\tmlxsw_reg_sldr_lag_create_pack(sldr_pl, lag_id);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sldr), sldr_pl);\n}\n\nstatic int mlxsw_sp_lag_destroy(struct mlxsw_sp *mlxsw_sp, u16 lag_id)\n{\n\tchar sldr_pl[MLXSW_REG_SLDR_LEN];\n\n\tmlxsw_reg_sldr_lag_destroy_pack(sldr_pl, lag_id);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sldr), sldr_pl);\n}\n\nstatic int mlxsw_sp_lag_col_port_add(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t     u16 lag_id, u8 port_index)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar slcor_pl[MLXSW_REG_SLCOR_LEN];\n\n\tmlxsw_reg_slcor_port_add_pack(slcor_pl, mlxsw_sp_port->local_port,\n\t\t\t\t      lag_id, port_index);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(slcor), slcor_pl);\n}\n\nstatic int mlxsw_sp_lag_col_port_remove(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\tu16 lag_id)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar slcor_pl[MLXSW_REG_SLCOR_LEN];\n\n\tmlxsw_reg_slcor_port_remove_pack(slcor_pl, mlxsw_sp_port->local_port,\n\t\t\t\t\t lag_id);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(slcor), slcor_pl);\n}\n\nstatic int mlxsw_sp_lag_col_port_enable(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\tu16 lag_id)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar slcor_pl[MLXSW_REG_SLCOR_LEN];\n\n\tmlxsw_reg_slcor_col_enable_pack(slcor_pl, mlxsw_sp_port->local_port,\n\t\t\t\t\tlag_id);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(slcor), slcor_pl);\n}\n\nstatic int mlxsw_sp_lag_col_port_disable(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t u16 lag_id)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar slcor_pl[MLXSW_REG_SLCOR_LEN];\n\n\tmlxsw_reg_slcor_col_disable_pack(slcor_pl, mlxsw_sp_port->local_port,\n\t\t\t\t\t lag_id);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(slcor), slcor_pl);\n}\n\nstatic int mlxsw_sp_lag_index_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct net_device *lag_dev,\n\t\t\t\t  u16 *p_lag_id)\n{\n\tstruct mlxsw_sp_upper *lag;\n\tint free_lag_id = -1;\n\tu16 max_lag;\n\tint err, i;\n\n\terr = mlxsw_core_max_lag(mlxsw_sp->core, &max_lag);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < max_lag; i++) {\n\t\tlag = mlxsw_sp_lag_get(mlxsw_sp, i);\n\t\tif (lag->ref_count) {\n\t\t\tif (lag->dev == lag_dev) {\n\t\t\t\t*p_lag_id = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (free_lag_id < 0) {\n\t\t\tfree_lag_id = i;\n\t\t}\n\t}\n\tif (free_lag_id < 0)\n\t\treturn -EBUSY;\n\t*p_lag_id = free_lag_id;\n\treturn 0;\n}\n\nstatic bool\nmlxsw_sp_master_lag_check(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  struct net_device *lag_dev,\n\t\t\t  struct netdev_lag_upper_info *lag_upper_info,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tu16 lag_id;\n\n\tif (mlxsw_sp_lag_index_get(mlxsw_sp, lag_dev, &lag_id) != 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Exceeded number of supported LAG devices\");\n\t\treturn false;\n\t}\n\tif (lag_upper_info->tx_type != NETDEV_LAG_TX_TYPE_HASH) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"LAG device using unsupported Tx type\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int mlxsw_sp_port_lag_index_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       u16 lag_id, u8 *p_port_index)\n{\n\tu64 max_lag_members;\n\tint i;\n\n\tmax_lag_members = MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t\t     MAX_LAG_MEMBERS);\n\tfor (i = 0; i < max_lag_members; i++) {\n\t\tif (!mlxsw_sp_port_lagged_get(mlxsw_sp, lag_id, i)) {\n\t\t\t*p_port_index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EBUSY;\n}\n\nstatic int mlxsw_sp_lag_uppers_bridge_join(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t   struct net_device *lag_dev,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net_device *upper_dev;\n\tstruct net_device *master;\n\tstruct list_head *iter;\n\tint done = 0;\n\tint err;\n\n\tmaster = netdev_master_upper_dev_get(lag_dev);\n\tif (master && netif_is_bridge_master(master)) {\n\t\terr = mlxsw_sp_port_bridge_join(mlxsw_sp_port, lag_dev, master,\n\t\t\t\t\t\textack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnetdev_for_each_upper_dev_rcu(lag_dev, upper_dev, iter) {\n\t\tif (!is_vlan_dev(upper_dev))\n\t\t\tcontinue;\n\n\t\tmaster = netdev_master_upper_dev_get(upper_dev);\n\t\tif (master && netif_is_bridge_master(master)) {\n\t\t\terr = mlxsw_sp_port_bridge_join(mlxsw_sp_port,\n\t\t\t\t\t\t\tupper_dev, master,\n\t\t\t\t\t\t\textack);\n\t\t\tif (err)\n\t\t\t\tgoto err_port_bridge_join;\n\t\t}\n\n\t\t++done;\n\t}\n\n\treturn 0;\n\nerr_port_bridge_join:\n\tnetdev_for_each_upper_dev_rcu(lag_dev, upper_dev, iter) {\n\t\tif (!is_vlan_dev(upper_dev))\n\t\t\tcontinue;\n\n\t\tmaster = netdev_master_upper_dev_get(upper_dev);\n\t\tif (!master || !netif_is_bridge_master(master))\n\t\t\tcontinue;\n\n\t\tif (!done--)\n\t\t\tbreak;\n\n\t\tmlxsw_sp_port_bridge_leave(mlxsw_sp_port, upper_dev, master);\n\t}\n\n\tmaster = netdev_master_upper_dev_get(lag_dev);\n\tif (master && netif_is_bridge_master(master))\n\t\tmlxsw_sp_port_bridge_leave(mlxsw_sp_port, lag_dev, master);\n\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_lag_uppers_bridge_leave(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t struct net_device *lag_dev)\n{\n\tstruct net_device *upper_dev;\n\tstruct net_device *master;\n\tstruct list_head *iter;\n\n\tnetdev_for_each_upper_dev_rcu(lag_dev, upper_dev, iter) {\n\t\tif (!is_vlan_dev(upper_dev))\n\t\t\tcontinue;\n\n\t\tmaster = netdev_master_upper_dev_get(upper_dev);\n\t\tif (!master)\n\t\t\tcontinue;\n\n\t\tmlxsw_sp_port_bridge_leave(mlxsw_sp_port, upper_dev, master);\n\t}\n\n\tmaster = netdev_master_upper_dev_get(lag_dev);\n\tif (master)\n\t\tmlxsw_sp_port_bridge_leave(mlxsw_sp_port, lag_dev, master);\n}\n\nstatic int mlxsw_sp_port_lag_join(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  struct net_device *lag_dev,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_upper *lag;\n\tu16 lag_id;\n\tu8 port_index;\n\tint err;\n\n\terr = mlxsw_sp_lag_index_get(mlxsw_sp, lag_dev, &lag_id);\n\tif (err)\n\t\treturn err;\n\tlag = mlxsw_sp_lag_get(mlxsw_sp, lag_id);\n\tif (!lag->ref_count) {\n\t\terr = mlxsw_sp_lag_create(mlxsw_sp, lag_id);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlag->dev = lag_dev;\n\t}\n\n\terr = mlxsw_sp_port_lag_index_get(mlxsw_sp, lag_id, &port_index);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_lag_uppers_bridge_join(mlxsw_sp_port, lag_dev,\n\t\t\t\t\t      extack);\n\tif (err)\n\t\tgoto err_lag_uppers_bridge_join;\n\n\terr = mlxsw_sp_lag_col_port_add(mlxsw_sp_port, lag_id, port_index);\n\tif (err)\n\t\tgoto err_col_port_add;\n\n\tmlxsw_core_lag_mapping_set(mlxsw_sp->core, lag_id, port_index,\n\t\t\t\t   mlxsw_sp_port->local_port);\n\tmlxsw_sp_port->lag_id = lag_id;\n\tmlxsw_sp_port->lagged = 1;\n\tlag->ref_count++;\n\n\t \n\tif (mlxsw_sp_port->default_vlan->fid)\n\t\tmlxsw_sp_port_vlan_router_leave(mlxsw_sp_port->default_vlan);\n\n\t \n\terr = mlxsw_sp_router_port_join_lag(mlxsw_sp_port, lag_dev,\n\t\t\t\t\t    extack);\n\tif (err)\n\t\tgoto err_router_join;\n\n\terr = mlxsw_sp_netdevice_enslavement_replay(mlxsw_sp, lag_dev, extack);\n\tif (err)\n\t\tgoto err_replay;\n\n\treturn 0;\n\nerr_replay:\n\tmlxsw_sp_router_port_leave_lag(mlxsw_sp_port, lag_dev);\nerr_router_join:\n\tlag->ref_count--;\n\tmlxsw_sp_port->lagged = 0;\n\tmlxsw_core_lag_mapping_clear(mlxsw_sp->core, lag_id,\n\t\t\t\t     mlxsw_sp_port->local_port);\n\tmlxsw_sp_lag_col_port_remove(mlxsw_sp_port, lag_id);\nerr_col_port_add:\n\tmlxsw_sp_lag_uppers_bridge_leave(mlxsw_sp_port, lag_dev);\nerr_lag_uppers_bridge_join:\n\tif (!lag->ref_count)\n\t\tmlxsw_sp_lag_destroy(mlxsw_sp, lag_id);\n\treturn err;\n}\n\nstatic void mlxsw_sp_port_lag_leave(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    struct net_device *lag_dev)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu16 lag_id = mlxsw_sp_port->lag_id;\n\tstruct mlxsw_sp_upper *lag;\n\n\tif (!mlxsw_sp_port->lagged)\n\t\treturn;\n\tlag = mlxsw_sp_lag_get(mlxsw_sp, lag_id);\n\tWARN_ON(lag->ref_count == 0);\n\n\tmlxsw_sp_lag_col_port_remove(mlxsw_sp_port, lag_id);\n\n\t \n\tmlxsw_sp_port_vlan_flush(mlxsw_sp_port, false);\n\tmlxsw_sp_port_vlan_cleanup(mlxsw_sp_port->default_vlan);\n\t \n\tmlxsw_sp_port_lag_uppers_cleanup(mlxsw_sp_port, lag_dev);\n\n\tif (lag->ref_count == 1)\n\t\tmlxsw_sp_lag_destroy(mlxsw_sp, lag_id);\n\n\tmlxsw_core_lag_mapping_clear(mlxsw_sp->core, lag_id,\n\t\t\t\t     mlxsw_sp_port->local_port);\n\tmlxsw_sp_port->lagged = 0;\n\tlag->ref_count--;\n\n\t \n\tmlxsw_sp_port_pvid_set(mlxsw_sp_port, MLXSW_SP_DEFAULT_VID,\n\t\t\t       ETH_P_8021Q);\n}\n\nstatic int mlxsw_sp_lag_dist_port_add(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      u16 lag_id)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar sldr_pl[MLXSW_REG_SLDR_LEN];\n\n\tmlxsw_reg_sldr_lag_add_port_pack(sldr_pl, lag_id,\n\t\t\t\t\t mlxsw_sp_port->local_port);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sldr), sldr_pl);\n}\n\nstatic int mlxsw_sp_lag_dist_port_remove(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t u16 lag_id)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar sldr_pl[MLXSW_REG_SLDR_LEN];\n\n\tmlxsw_reg_sldr_lag_remove_port_pack(sldr_pl, lag_id,\n\t\t\t\t\t    mlxsw_sp_port->local_port);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sldr), sldr_pl);\n}\n\nstatic int\nmlxsw_sp_port_lag_col_dist_enable(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tint err;\n\n\terr = mlxsw_sp_lag_col_port_enable(mlxsw_sp_port,\n\t\t\t\t\t   mlxsw_sp_port->lag_id);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_lag_dist_port_add(mlxsw_sp_port, mlxsw_sp_port->lag_id);\n\tif (err)\n\t\tgoto err_dist_port_add;\n\n\treturn 0;\n\nerr_dist_port_add:\n\tmlxsw_sp_lag_col_port_disable(mlxsw_sp_port, mlxsw_sp_port->lag_id);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_port_lag_col_dist_disable(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tint err;\n\n\terr = mlxsw_sp_lag_dist_port_remove(mlxsw_sp_port,\n\t\t\t\t\t    mlxsw_sp_port->lag_id);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_lag_col_port_disable(mlxsw_sp_port,\n\t\t\t\t\t    mlxsw_sp_port->lag_id);\n\tif (err)\n\t\tgoto err_col_port_disable;\n\n\treturn 0;\n\nerr_col_port_disable:\n\tmlxsw_sp_lag_dist_port_add(mlxsw_sp_port, mlxsw_sp_port->lag_id);\n\treturn err;\n}\n\nstatic int mlxsw_sp_port_lag_changed(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t     struct netdev_lag_lower_state_info *info)\n{\n\tif (info->tx_enabled)\n\t\treturn mlxsw_sp_port_lag_col_dist_enable(mlxsw_sp_port);\n\telse\n\t\treturn mlxsw_sp_port_lag_col_dist_disable(mlxsw_sp_port);\n}\n\nstatic int mlxsw_sp_port_stp_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t bool enable)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tenum mlxsw_reg_spms_state spms_state;\n\tchar *spms_pl;\n\tu16 vid;\n\tint err;\n\n\tspms_state = enable ? MLXSW_REG_SPMS_STATE_FORWARDING :\n\t\t\t      MLXSW_REG_SPMS_STATE_DISCARDING;\n\n\tspms_pl = kmalloc(MLXSW_REG_SPMS_LEN, GFP_KERNEL);\n\tif (!spms_pl)\n\t\treturn -ENOMEM;\n\tmlxsw_reg_spms_pack(spms_pl, mlxsw_sp_port->local_port);\n\n\tfor (vid = 0; vid < VLAN_N_VID; vid++)\n\t\tmlxsw_reg_spms_vid_pack(spms_pl, vid, spms_state);\n\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(spms), spms_pl);\n\tkfree(spms_pl);\n\treturn err;\n}\n\nstatic int mlxsw_sp_port_ovs_join(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tu16 vid = 1;\n\tint err;\n\n\terr = mlxsw_sp_port_vp_mode_set(mlxsw_sp_port, true);\n\tif (err)\n\t\treturn err;\n\terr = mlxsw_sp_port_stp_set(mlxsw_sp_port, true);\n\tif (err)\n\t\tgoto err_port_stp_set;\n\terr = mlxsw_sp_port_vlan_set(mlxsw_sp_port, 1, VLAN_N_VID - 2,\n\t\t\t\t     true, false);\n\tif (err)\n\t\tgoto err_port_vlan_set;\n\n\tfor (; vid <= VLAN_N_VID - 1; vid++) {\n\t\terr = mlxsw_sp_port_vid_learning_set(mlxsw_sp_port,\n\t\t\t\t\t\t     vid, false);\n\t\tif (err)\n\t\t\tgoto err_vid_learning_set;\n\t}\n\n\treturn 0;\n\nerr_vid_learning_set:\n\tfor (vid--; vid >= 1; vid--)\n\t\tmlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, true);\nerr_port_vlan_set:\n\tmlxsw_sp_port_stp_set(mlxsw_sp_port, false);\nerr_port_stp_set:\n\tmlxsw_sp_port_vp_mode_set(mlxsw_sp_port, false);\n\treturn err;\n}\n\nstatic void mlxsw_sp_port_ovs_leave(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tu16 vid;\n\n\tfor (vid = VLAN_N_VID - 1; vid >= 1; vid--)\n\t\tmlxsw_sp_port_vid_learning_set(mlxsw_sp_port,\n\t\t\t\t\t       vid, true);\n\n\tmlxsw_sp_port_vlan_set(mlxsw_sp_port, 1, VLAN_N_VID - 2,\n\t\t\t       false, false);\n\tmlxsw_sp_port_stp_set(mlxsw_sp_port, false);\n\tmlxsw_sp_port_vp_mode_set(mlxsw_sp_port, false);\n}\n\nstatic bool mlxsw_sp_bridge_has_multiple_vxlans(struct net_device *br_dev)\n{\n\tunsigned int num_vxlans = 0;\n\tstruct net_device *dev;\n\tstruct list_head *iter;\n\n\tnetdev_for_each_lower_dev(br_dev, dev, iter) {\n\t\tif (netif_is_vxlan(dev))\n\t\t\tnum_vxlans++;\n\t}\n\n\treturn num_vxlans > 1;\n}\n\nstatic bool mlxsw_sp_bridge_vxlan_vlan_is_valid(struct net_device *br_dev)\n{\n\tDECLARE_BITMAP(vlans, VLAN_N_VID) = {0};\n\tstruct net_device *dev;\n\tstruct list_head *iter;\n\n\tnetdev_for_each_lower_dev(br_dev, dev, iter) {\n\t\tu16 pvid;\n\t\tint err;\n\n\t\tif (!netif_is_vxlan(dev))\n\t\t\tcontinue;\n\n\t\terr = mlxsw_sp_vxlan_mapped_vid(dev, &pvid);\n\t\tif (err || !pvid)\n\t\t\tcontinue;\n\n\t\tif (test_and_set_bit(pvid, vlans))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool mlxsw_sp_bridge_vxlan_is_valid(struct net_device *br_dev,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tif (br_multicast_enabled(br_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Multicast can not be enabled on a bridge with a VxLAN device\");\n\t\treturn false;\n\t}\n\n\tif (!br_vlan_enabled(br_dev) &&\n\t    mlxsw_sp_bridge_has_multiple_vxlans(br_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Multiple VxLAN devices are not supported in a VLAN-unaware bridge\");\n\t\treturn false;\n\t}\n\n\tif (br_vlan_enabled(br_dev) &&\n\t    !mlxsw_sp_bridge_vxlan_vlan_is_valid(br_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Multiple VxLAN devices cannot have the same VLAN as PVID and egress untagged\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool mlxsw_sp_netdev_is_master(struct net_device *upper_dev,\n\t\t\t\t      struct net_device *dev)\n{\n\treturn upper_dev == netdev_master_upper_dev_get(dev);\n}\n\nstatic int __mlxsw_sp_netdevice_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      unsigned long event, void *ptr,\n\t\t\t\t      bool process_foreign);\n\nstatic int mlxsw_sp_netdevice_validate_uppers(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t      struct net_device *dev,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net_device *upper_dev;\n\tstruct list_head *iter;\n\tint err;\n\n\tnetdev_for_each_upper_dev_rcu(dev, upper_dev, iter) {\n\t\tstruct netdev_notifier_changeupper_info info = {\n\t\t\t.info = {\n\t\t\t\t.dev = dev,\n\t\t\t\t.extack = extack,\n\t\t\t},\n\t\t\t.master = mlxsw_sp_netdev_is_master(upper_dev, dev),\n\t\t\t.upper_dev = upper_dev,\n\t\t\t.linking = true,\n\n\t\t\t \n\t\t\t.upper_info = NULL,\n\t\t};\n\n\t\terr = __mlxsw_sp_netdevice_event(mlxsw_sp,\n\t\t\t\t\t\t NETDEV_PRECHANGEUPPER,\n\t\t\t\t\t\t &info, true);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mlxsw_sp_netdevice_validate_uppers(mlxsw_sp, upper_dev,\n\t\t\t\t\t\t\t extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_netdevice_port_upper_event(struct net_device *lower_dev,\n\t\t\t\t\t       struct net_device *dev,\n\t\t\t\t\t       unsigned long event, void *ptr,\n\t\t\t\t\t       bool replay_deslavement)\n{\n\tstruct netdev_notifier_changeupper_info *info;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tstruct netlink_ext_ack *extack;\n\tstruct net_device *upper_dev;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tint err = 0;\n\tu16 proto;\n\n\tmlxsw_sp_port = netdev_priv(dev);\n\tmlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tinfo = ptr;\n\textack = netdev_notifier_info_to_extack(&info->info);\n\n\tswitch (event) {\n\tcase NETDEV_PRECHANGEUPPER:\n\t\tupper_dev = info->upper_dev;\n\t\tif (!is_vlan_dev(upper_dev) &&\n\t\t    !netif_is_lag_master(upper_dev) &&\n\t\t    !netif_is_bridge_master(upper_dev) &&\n\t\t    !netif_is_ovs_master(upper_dev) &&\n\t\t    !netif_is_macvlan(upper_dev) &&\n\t\t    !netif_is_l3_master(upper_dev)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unknown upper device type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!info->linking)\n\t\t\tbreak;\n\t\tif (netif_is_bridge_master(upper_dev) &&\n\t\t    !mlxsw_sp_bridge_device_is_offloaded(mlxsw_sp, upper_dev) &&\n\t\t    mlxsw_sp_bridge_has_vxlan(upper_dev) &&\n\t\t    !mlxsw_sp_bridge_vxlan_is_valid(upper_dev, extack))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (netdev_has_any_upper_dev(upper_dev) &&\n\t\t    (!netif_is_bridge_master(upper_dev) ||\n\t\t     !mlxsw_sp_bridge_device_is_offloaded(mlxsw_sp,\n\t\t\t\t\t\t\t  upper_dev))) {\n\t\t\terr = mlxsw_sp_netdevice_validate_uppers(mlxsw_sp,\n\t\t\t\t\t\t\t\t upper_dev,\n\t\t\t\t\t\t\t\t extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (netif_is_lag_master(upper_dev) &&\n\t\t    !mlxsw_sp_master_lag_check(mlxsw_sp, upper_dev,\n\t\t\t\t\t       info->upper_info, extack))\n\t\t\treturn -EINVAL;\n\t\tif (netif_is_lag_master(upper_dev) && vlan_uses_dev(dev)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Master device is a LAG master and this device has a VLAN\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (netif_is_lag_port(dev) && is_vlan_dev(upper_dev) &&\n\t\t    !netif_is_lag_master(vlan_dev_real_dev(upper_dev))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Can not put a VLAN on a LAG port\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (netif_is_ovs_master(upper_dev) && vlan_uses_dev(dev)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Master device is an OVS master and this device has a VLAN\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (netif_is_ovs_port(dev) && is_vlan_dev(upper_dev)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Can not put a VLAN on an OVS port\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (netif_is_bridge_master(upper_dev)) {\n\t\t\tbr_vlan_get_proto(upper_dev, &proto);\n\t\t\tif (br_vlan_enabled(upper_dev) &&\n\t\t\t    proto != ETH_P_8021Q && proto != ETH_P_8021AD) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Enslaving a port to a bridge with unknown VLAN protocol is not supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (vlan_uses_dev(lower_dev) &&\n\t\t\t    br_vlan_enabled(upper_dev) &&\n\t\t\t    proto == ETH_P_8021AD) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Enslaving a port that already has a VLAN upper to an 802.1ad bridge is not supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t\tif (netif_is_bridge_port(lower_dev) && is_vlan_dev(upper_dev)) {\n\t\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(lower_dev);\n\n\t\t\tif (br_vlan_enabled(br_dev)) {\n\t\t\t\tbr_vlan_get_proto(br_dev, &proto);\n\t\t\t\tif (proto == ETH_P_8021AD) {\n\t\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"VLAN uppers are not supported on a port enslaved to an 802.1ad bridge\");\n\t\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (is_vlan_dev(upper_dev) &&\n\t\t    ntohs(vlan_dev_vlan_proto(upper_dev)) != ETH_P_8021Q) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"VLAN uppers are only supported with 802.1q VLAN protocol\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (is_vlan_dev(upper_dev) && mlxsw_sp_port->security) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"VLAN uppers are not supported on a locked port\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase NETDEV_CHANGEUPPER:\n\t\tupper_dev = info->upper_dev;\n\t\tif (netif_is_bridge_master(upper_dev)) {\n\t\t\tif (info->linking) {\n\t\t\t\terr = mlxsw_sp_port_bridge_join(mlxsw_sp_port,\n\t\t\t\t\t\t\t\tlower_dev,\n\t\t\t\t\t\t\t\tupper_dev,\n\t\t\t\t\t\t\t\textack);\n\t\t\t} else {\n\t\t\t\tmlxsw_sp_port_bridge_leave(mlxsw_sp_port,\n\t\t\t\t\t\t\t   lower_dev,\n\t\t\t\t\t\t\t   upper_dev);\n\t\t\t\tif (!replay_deslavement)\n\t\t\t\t\tbreak;\n\t\t\t\tmlxsw_sp_netdevice_deslavement_replay(mlxsw_sp,\n\t\t\t\t\t\t\t\t      lower_dev);\n\t\t\t}\n\t\t} else if (netif_is_lag_master(upper_dev)) {\n\t\t\tif (info->linking) {\n\t\t\t\terr = mlxsw_sp_port_lag_join(mlxsw_sp_port,\n\t\t\t\t\t\t\t     upper_dev, extack);\n\t\t\t} else {\n\t\t\t\tmlxsw_sp_port_lag_col_dist_disable(mlxsw_sp_port);\n\t\t\t\tmlxsw_sp_port_lag_leave(mlxsw_sp_port,\n\t\t\t\t\t\t\tupper_dev);\n\t\t\t\tmlxsw_sp_netdevice_deslavement_replay(mlxsw_sp,\n\t\t\t\t\t\t\t\t      dev);\n\t\t\t}\n\t\t} else if (netif_is_ovs_master(upper_dev)) {\n\t\t\tif (info->linking)\n\t\t\t\terr = mlxsw_sp_port_ovs_join(mlxsw_sp_port);\n\t\t\telse\n\t\t\t\tmlxsw_sp_port_ovs_leave(mlxsw_sp_port);\n\t\t} else if (netif_is_macvlan(upper_dev)) {\n\t\t\tif (!info->linking)\n\t\t\t\tmlxsw_sp_rif_macvlan_del(mlxsw_sp, upper_dev);\n\t\t} else if (is_vlan_dev(upper_dev)) {\n\t\t\tstruct net_device *br_dev;\n\n\t\t\tif (!netif_is_bridge_port(upper_dev))\n\t\t\t\tbreak;\n\t\t\tif (info->linking)\n\t\t\t\tbreak;\n\t\t\tbr_dev = netdev_master_upper_dev_get(upper_dev);\n\t\t\tmlxsw_sp_port_bridge_leave(mlxsw_sp_port, upper_dev,\n\t\t\t\t\t\t   br_dev);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int mlxsw_sp_netdevice_port_lower_event(struct net_device *dev,\n\t\t\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct netdev_notifier_changelowerstate_info *info;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tint err;\n\n\tmlxsw_sp_port = netdev_priv(dev);\n\tinfo = ptr;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGELOWERSTATE:\n\t\tif (netif_is_lag_port(dev) && mlxsw_sp_port->lagged) {\n\t\t\terr = mlxsw_sp_port_lag_changed(mlxsw_sp_port,\n\t\t\t\t\t\t\tinfo->lower_state_info);\n\t\t\tif (err)\n\t\t\t\tnetdev_err(dev, \"Failed to reflect link aggregation lower state change\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_netdevice_port_event(struct net_device *lower_dev,\n\t\t\t\t\t struct net_device *port_dev,\n\t\t\t\t\t unsigned long event, void *ptr,\n\t\t\t\t\t bool replay_deslavement)\n{\n\tswitch (event) {\n\tcase NETDEV_PRECHANGEUPPER:\n\tcase NETDEV_CHANGEUPPER:\n\t\treturn mlxsw_sp_netdevice_port_upper_event(lower_dev, port_dev,\n\t\t\t\t\t\t\t   event, ptr,\n\t\t\t\t\t\t\t   replay_deslavement);\n\tcase NETDEV_CHANGELOWERSTATE:\n\t\treturn mlxsw_sp_netdevice_port_lower_event(port_dev, event,\n\t\t\t\t\t\t\t   ptr);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mlxsw_sp_netdevice_post_lag_event(struct net_device *dev,\n\t\t\t\t\t     unsigned long event,\n\t\t\t\t\t     void *ptr)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(dev);\n\tstruct netdev_notifier_changeupper_info *info = ptr;\n\n\tif (!mlxsw_sp)\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGEUPPER:\n\t\tif (info->linking)\n\t\t\tbreak;\n\t\tif (netif_is_bridge_master(info->upper_dev))\n\t\t\tmlxsw_sp_netdevice_deslavement_replay(mlxsw_sp, dev);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int mlxsw_sp_netdevice_lag_event(struct net_device *lag_dev,\n\t\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *dev;\n\tstruct list_head *iter;\n\tint ret;\n\n\tnetdev_for_each_lower_dev(lag_dev, dev, iter) {\n\t\tif (mlxsw_sp_port_dev_check(dev)) {\n\t\t\tret = mlxsw_sp_netdevice_port_event(lag_dev, dev, event,\n\t\t\t\t\t\t\t    ptr, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn mlxsw_sp_netdevice_post_lag_event(lag_dev, event, ptr);\n}\n\nstatic int mlxsw_sp_netdevice_port_vlan_event(struct net_device *vlan_dev,\n\t\t\t\t\t      struct net_device *dev,\n\t\t\t\t\t      unsigned long event, void *ptr,\n\t\t\t\t\t      u16 vid, bool replay_deslavement)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct netdev_notifier_changeupper_info *info = ptr;\n\tstruct netlink_ext_ack *extack;\n\tstruct net_device *upper_dev;\n\tint err = 0;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\n\tswitch (event) {\n\tcase NETDEV_PRECHANGEUPPER:\n\t\tupper_dev = info->upper_dev;\n\t\tif (!netif_is_bridge_master(upper_dev) &&\n\t\t    !netif_is_macvlan(upper_dev) &&\n\t\t    !netif_is_l3_master(upper_dev)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unknown upper device type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!info->linking)\n\t\t\tbreak;\n\t\tif (netif_is_bridge_master(upper_dev) &&\n\t\t    !mlxsw_sp_bridge_device_is_offloaded(mlxsw_sp, upper_dev) &&\n\t\t    mlxsw_sp_bridge_has_vxlan(upper_dev) &&\n\t\t    !mlxsw_sp_bridge_vxlan_is_valid(upper_dev, extack))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (netdev_has_any_upper_dev(upper_dev) &&\n\t\t    (!netif_is_bridge_master(upper_dev) ||\n\t\t     !mlxsw_sp_bridge_device_is_offloaded(mlxsw_sp,\n\t\t\t\t\t\t\t  upper_dev))) {\n\t\t\terr = mlxsw_sp_netdevice_validate_uppers(mlxsw_sp,\n\t\t\t\t\t\t\t\t upper_dev,\n\t\t\t\t\t\t\t\t extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase NETDEV_CHANGEUPPER:\n\t\tupper_dev = info->upper_dev;\n\t\tif (netif_is_bridge_master(upper_dev)) {\n\t\t\tif (info->linking) {\n\t\t\t\terr = mlxsw_sp_port_bridge_join(mlxsw_sp_port,\n\t\t\t\t\t\t\t\tvlan_dev,\n\t\t\t\t\t\t\t\tupper_dev,\n\t\t\t\t\t\t\t\textack);\n\t\t\t} else {\n\t\t\t\tmlxsw_sp_port_bridge_leave(mlxsw_sp_port,\n\t\t\t\t\t\t\t   vlan_dev,\n\t\t\t\t\t\t\t   upper_dev);\n\t\t\t\tif (!replay_deslavement)\n\t\t\t\t\tbreak;\n\t\t\t\tmlxsw_sp_netdevice_deslavement_replay(mlxsw_sp,\n\t\t\t\t\t\t\t\t      vlan_dev);\n\t\t\t}\n\t\t} else if (netif_is_macvlan(upper_dev)) {\n\t\t\tif (!info->linking)\n\t\t\t\tmlxsw_sp_rif_macvlan_del(mlxsw_sp, upper_dev);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int mlxsw_sp_netdevice_lag_port_vlan_event(struct net_device *vlan_dev,\n\t\t\t\t\t\t  struct net_device *lag_dev,\n\t\t\t\t\t\t  unsigned long event,\n\t\t\t\t\t\t  void *ptr, u16 vid)\n{\n\tstruct net_device *dev;\n\tstruct list_head *iter;\n\tint ret;\n\n\tnetdev_for_each_lower_dev(lag_dev, dev, iter) {\n\t\tif (mlxsw_sp_port_dev_check(dev)) {\n\t\t\tret = mlxsw_sp_netdevice_port_vlan_event(vlan_dev, dev,\n\t\t\t\t\t\t\t\t event, ptr,\n\t\t\t\t\t\t\t\t vid, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn mlxsw_sp_netdevice_post_lag_event(vlan_dev, event, ptr);\n}\n\nstatic int mlxsw_sp_netdevice_bridge_vlan_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tstruct net_device *vlan_dev,\n\t\t\t\t\t\tstruct net_device *br_dev,\n\t\t\t\t\t\tunsigned long event, void *ptr,\n\t\t\t\t\t\tu16 vid, bool process_foreign)\n{\n\tstruct netdev_notifier_changeupper_info *info = ptr;\n\tstruct netlink_ext_ack *extack;\n\tstruct net_device *upper_dev;\n\n\tif (!process_foreign && !mlxsw_sp_lower_get(vlan_dev))\n\t\treturn 0;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\n\tswitch (event) {\n\tcase NETDEV_PRECHANGEUPPER:\n\t\tupper_dev = info->upper_dev;\n\t\tif (!netif_is_macvlan(upper_dev) &&\n\t\t    !netif_is_l3_master(upper_dev)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unknown upper device type\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase NETDEV_CHANGEUPPER:\n\t\tupper_dev = info->upper_dev;\n\t\tif (info->linking)\n\t\t\tbreak;\n\t\tif (netif_is_macvlan(upper_dev))\n\t\t\tmlxsw_sp_rif_macvlan_del(mlxsw_sp, upper_dev);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_netdevice_vlan_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t struct net_device *vlan_dev,\n\t\t\t\t\t unsigned long event, void *ptr,\n\t\t\t\t\t bool process_foreign)\n{\n\tstruct net_device *real_dev = vlan_dev_real_dev(vlan_dev);\n\tu16 vid = vlan_dev_vlan_id(vlan_dev);\n\n\tif (mlxsw_sp_port_dev_check(real_dev))\n\t\treturn mlxsw_sp_netdevice_port_vlan_event(vlan_dev, real_dev,\n\t\t\t\t\t\t\t  event, ptr, vid,\n\t\t\t\t\t\t\t  true);\n\telse if (netif_is_lag_master(real_dev))\n\t\treturn mlxsw_sp_netdevice_lag_port_vlan_event(vlan_dev,\n\t\t\t\t\t\t\t      real_dev, event,\n\t\t\t\t\t\t\t      ptr, vid);\n\telse if (netif_is_bridge_master(real_dev))\n\t\treturn mlxsw_sp_netdevice_bridge_vlan_event(mlxsw_sp, vlan_dev,\n\t\t\t\t\t\t\t    real_dev, event,\n\t\t\t\t\t\t\t    ptr, vid,\n\t\t\t\t\t\t\t    process_foreign);\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_netdevice_bridge_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   struct net_device *br_dev,\n\t\t\t\t\t   unsigned long event, void *ptr,\n\t\t\t\t\t   bool process_foreign)\n{\n\tstruct netdev_notifier_changeupper_info *info = ptr;\n\tstruct netlink_ext_ack *extack;\n\tstruct net_device *upper_dev;\n\tu16 proto;\n\n\tif (!process_foreign && !mlxsw_sp_lower_get(br_dev))\n\t\treturn 0;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\n\tswitch (event) {\n\tcase NETDEV_PRECHANGEUPPER:\n\t\tupper_dev = info->upper_dev;\n\t\tif (!is_vlan_dev(upper_dev) &&\n\t\t    !netif_is_macvlan(upper_dev) &&\n\t\t    !netif_is_l3_master(upper_dev)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unknown upper device type\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!info->linking)\n\t\t\tbreak;\n\t\tif (br_vlan_enabled(br_dev)) {\n\t\t\tbr_vlan_get_proto(br_dev, &proto);\n\t\t\tif (proto == ETH_P_8021AD) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Upper devices are not supported on top of an 802.1ad bridge\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t\tif (is_vlan_dev(upper_dev) &&\n\t\t    ntohs(vlan_dev_vlan_proto(upper_dev)) != ETH_P_8021Q) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"VLAN uppers are only supported with 802.1q VLAN protocol\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase NETDEV_CHANGEUPPER:\n\t\tupper_dev = info->upper_dev;\n\t\tif (info->linking)\n\t\t\tbreak;\n\t\tif (is_vlan_dev(upper_dev))\n\t\t\tmlxsw_sp_rif_destroy_by_dev(mlxsw_sp, upper_dev);\n\t\tif (netif_is_macvlan(upper_dev))\n\t\t\tmlxsw_sp_rif_macvlan_del(mlxsw_sp, upper_dev);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_netdevice_macvlan_event(struct net_device *macvlan_dev,\n\t\t\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(macvlan_dev);\n\tstruct netdev_notifier_changeupper_info *info = ptr;\n\tstruct netlink_ext_ack *extack;\n\tstruct net_device *upper_dev;\n\n\tif (!mlxsw_sp || event != NETDEV_PRECHANGEUPPER)\n\t\treturn 0;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\tupper_dev = info->upper_dev;\n\n\tif (!netif_is_l3_master(upper_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unknown upper device type\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_netdevice_vxlan_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct net_device *dev,\n\t\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct netdev_notifier_changeupper_info *cu_info;\n\tstruct netdev_notifier_info *info = ptr;\n\tstruct netlink_ext_ack *extack;\n\tstruct net_device *upper_dev;\n\n\textack = netdev_notifier_info_to_extack(info);\n\n\tswitch (event) {\n\tcase NETDEV_CHANGEUPPER:\n\t\tcu_info = container_of(info,\n\t\t\t\t       struct netdev_notifier_changeupper_info,\n\t\t\t\t       info);\n\t\tupper_dev = cu_info->upper_dev;\n\t\tif (!netif_is_bridge_master(upper_dev))\n\t\t\treturn 0;\n\t\tif (!mlxsw_sp_lower_get(upper_dev))\n\t\t\treturn 0;\n\t\tif (!mlxsw_sp_bridge_vxlan_is_valid(upper_dev, extack))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (cu_info->linking) {\n\t\t\tif (!netif_running(dev))\n\t\t\t\treturn 0;\n\t\t\t \n\t\t\tif (br_vlan_enabled(upper_dev))\n\t\t\t\treturn 0;\n\t\t\treturn mlxsw_sp_bridge_vxlan_join(mlxsw_sp, upper_dev,\n\t\t\t\t\t\t\t  dev, 0, extack);\n\t\t} else {\n\t\t\t \n\t\t\tif (br_vlan_enabled(upper_dev))\n\t\t\t\treturn 0;\n\t\t\tmlxsw_sp_bridge_vxlan_leave(mlxsw_sp, dev);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_PRE_UP:\n\t\tupper_dev = netdev_master_upper_dev_get(dev);\n\t\tif (!upper_dev)\n\t\t\treturn 0;\n\t\tif (!netif_is_bridge_master(upper_dev))\n\t\t\treturn 0;\n\t\tif (!mlxsw_sp_lower_get(upper_dev))\n\t\t\treturn 0;\n\t\treturn mlxsw_sp_bridge_vxlan_join(mlxsw_sp, upper_dev, dev, 0,\n\t\t\t\t\t\t  extack);\n\tcase NETDEV_DOWN:\n\t\tupper_dev = netdev_master_upper_dev_get(dev);\n\t\tif (!upper_dev)\n\t\t\treturn 0;\n\t\tif (!netif_is_bridge_master(upper_dev))\n\t\t\treturn 0;\n\t\tif (!mlxsw_sp_lower_get(upper_dev))\n\t\t\treturn 0;\n\t\tmlxsw_sp_bridge_vxlan_leave(mlxsw_sp, dev);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int __mlxsw_sp_netdevice_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      unsigned long event, void *ptr,\n\t\t\t\t      bool process_foreign)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct mlxsw_sp_span_entry *span_entry;\n\tint err = 0;\n\n\tif (event == NETDEV_UNREGISTER) {\n\t\tspan_entry = mlxsw_sp_span_entry_find_by_port(mlxsw_sp, dev);\n\t\tif (span_entry)\n\t\t\tmlxsw_sp_span_entry_invalidate(mlxsw_sp, span_entry);\n\t}\n\n\tif (netif_is_vxlan(dev))\n\t\terr = mlxsw_sp_netdevice_vxlan_event(mlxsw_sp, dev, event, ptr);\n\telse if (mlxsw_sp_port_dev_check(dev))\n\t\terr = mlxsw_sp_netdevice_port_event(dev, dev, event, ptr, true);\n\telse if (netif_is_lag_master(dev))\n\t\terr = mlxsw_sp_netdevice_lag_event(dev, event, ptr);\n\telse if (is_vlan_dev(dev))\n\t\terr = mlxsw_sp_netdevice_vlan_event(mlxsw_sp, dev, event, ptr,\n\t\t\t\t\t\t    process_foreign);\n\telse if (netif_is_bridge_master(dev))\n\t\terr = mlxsw_sp_netdevice_bridge_event(mlxsw_sp, dev, event, ptr,\n\t\t\t\t\t\t      process_foreign);\n\telse if (netif_is_macvlan(dev))\n\t\terr = mlxsw_sp_netdevice_macvlan_event(dev, event, ptr);\n\n\treturn err;\n}\n\nstatic int mlxsw_sp_netdevice_event(struct notifier_block *nb,\n\t\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct mlxsw_sp *mlxsw_sp;\n\tint err;\n\n\tmlxsw_sp = container_of(nb, struct mlxsw_sp, netdevice_nb);\n\tmlxsw_sp_span_respin(mlxsw_sp);\n\terr = __mlxsw_sp_netdevice_event(mlxsw_sp, event, ptr, false);\n\n\treturn notifier_from_errno(err);\n}\n\nstatic const struct pci_device_id mlxsw_sp1_pci_id_table[] = {\n\t{PCI_VDEVICE(MELLANOX, PCI_DEVICE_ID_MELLANOX_SPECTRUM), 0},\n\t{0, },\n};\n\nstatic struct pci_driver mlxsw_sp1_pci_driver = {\n\t.name = mlxsw_sp1_driver_name,\n\t.id_table = mlxsw_sp1_pci_id_table,\n};\n\nstatic const struct pci_device_id mlxsw_sp2_pci_id_table[] = {\n\t{PCI_VDEVICE(MELLANOX, PCI_DEVICE_ID_MELLANOX_SPECTRUM2), 0},\n\t{0, },\n};\n\nstatic struct pci_driver mlxsw_sp2_pci_driver = {\n\t.name = mlxsw_sp2_driver_name,\n\t.id_table = mlxsw_sp2_pci_id_table,\n};\n\nstatic const struct pci_device_id mlxsw_sp3_pci_id_table[] = {\n\t{PCI_VDEVICE(MELLANOX, PCI_DEVICE_ID_MELLANOX_SPECTRUM3), 0},\n\t{0, },\n};\n\nstatic struct pci_driver mlxsw_sp3_pci_driver = {\n\t.name = mlxsw_sp3_driver_name,\n\t.id_table = mlxsw_sp3_pci_id_table,\n};\n\nstatic const struct pci_device_id mlxsw_sp4_pci_id_table[] = {\n\t{PCI_VDEVICE(MELLANOX, PCI_DEVICE_ID_MELLANOX_SPECTRUM4), 0},\n\t{0, },\n};\n\nstatic struct pci_driver mlxsw_sp4_pci_driver = {\n\t.name = mlxsw_sp4_driver_name,\n\t.id_table = mlxsw_sp4_pci_id_table,\n};\n\nstatic int __init mlxsw_sp_module_init(void)\n{\n\tint err;\n\n\terr = mlxsw_core_driver_register(&mlxsw_sp1_driver);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_core_driver_register(&mlxsw_sp2_driver);\n\tif (err)\n\t\tgoto err_sp2_core_driver_register;\n\n\terr = mlxsw_core_driver_register(&mlxsw_sp3_driver);\n\tif (err)\n\t\tgoto err_sp3_core_driver_register;\n\n\terr = mlxsw_core_driver_register(&mlxsw_sp4_driver);\n\tif (err)\n\t\tgoto err_sp4_core_driver_register;\n\n\terr = mlxsw_pci_driver_register(&mlxsw_sp1_pci_driver);\n\tif (err)\n\t\tgoto err_sp1_pci_driver_register;\n\n\terr = mlxsw_pci_driver_register(&mlxsw_sp2_pci_driver);\n\tif (err)\n\t\tgoto err_sp2_pci_driver_register;\n\n\terr = mlxsw_pci_driver_register(&mlxsw_sp3_pci_driver);\n\tif (err)\n\t\tgoto err_sp3_pci_driver_register;\n\n\terr = mlxsw_pci_driver_register(&mlxsw_sp4_pci_driver);\n\tif (err)\n\t\tgoto err_sp4_pci_driver_register;\n\n\treturn 0;\n\nerr_sp4_pci_driver_register:\n\tmlxsw_pci_driver_unregister(&mlxsw_sp3_pci_driver);\nerr_sp3_pci_driver_register:\n\tmlxsw_pci_driver_unregister(&mlxsw_sp2_pci_driver);\nerr_sp2_pci_driver_register:\n\tmlxsw_pci_driver_unregister(&mlxsw_sp1_pci_driver);\nerr_sp1_pci_driver_register:\n\tmlxsw_core_driver_unregister(&mlxsw_sp4_driver);\nerr_sp4_core_driver_register:\n\tmlxsw_core_driver_unregister(&mlxsw_sp3_driver);\nerr_sp3_core_driver_register:\n\tmlxsw_core_driver_unregister(&mlxsw_sp2_driver);\nerr_sp2_core_driver_register:\n\tmlxsw_core_driver_unregister(&mlxsw_sp1_driver);\n\treturn err;\n}\n\nstatic void __exit mlxsw_sp_module_exit(void)\n{\n\tmlxsw_pci_driver_unregister(&mlxsw_sp4_pci_driver);\n\tmlxsw_pci_driver_unregister(&mlxsw_sp3_pci_driver);\n\tmlxsw_pci_driver_unregister(&mlxsw_sp2_pci_driver);\n\tmlxsw_pci_driver_unregister(&mlxsw_sp1_pci_driver);\n\tmlxsw_core_driver_unregister(&mlxsw_sp4_driver);\n\tmlxsw_core_driver_unregister(&mlxsw_sp3_driver);\n\tmlxsw_core_driver_unregister(&mlxsw_sp2_driver);\n\tmlxsw_core_driver_unregister(&mlxsw_sp1_driver);\n}\n\nmodule_init(mlxsw_sp_module_init);\nmodule_exit(mlxsw_sp_module_exit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Jiri Pirko <jiri@mellanox.com>\");\nMODULE_DESCRIPTION(\"Mellanox Spectrum driver\");\nMODULE_DEVICE_TABLE(pci, mlxsw_sp1_pci_id_table);\nMODULE_DEVICE_TABLE(pci, mlxsw_sp2_pci_id_table);\nMODULE_DEVICE_TABLE(pci, mlxsw_sp3_pci_id_table);\nMODULE_DEVICE_TABLE(pci, mlxsw_sp4_pci_id_table);\nMODULE_FIRMWARE(MLXSW_SP1_FW_FILENAME);\nMODULE_FIRMWARE(MLXSW_SP2_FW_FILENAME);\nMODULE_FIRMWARE(MLXSW_SP3_FW_FILENAME);\nMODULE_FIRMWARE(MLXSW_SP_LINECARDS_INI_BUNDLE_FILENAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}