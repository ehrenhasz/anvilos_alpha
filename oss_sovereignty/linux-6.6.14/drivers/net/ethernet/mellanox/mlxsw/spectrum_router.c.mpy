{
  "module_name": "spectrum_router.c",
  "hash_id": "fe7a985a5196f3e03a362868788c96a38dd46dc798d4e66e85c1e82294df37ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/rhashtable.h>\n#include <linux/bitops.h>\n#include <linux/in6.h>\n#include <linux/notifier.h>\n#include <linux/inetdevice.h>\n#include <linux/netdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/socket.h>\n#include <linux/route.h>\n#include <linux/gcd.h>\n#include <linux/if_macvlan.h>\n#include <linux/refcount.h>\n#include <linux/jhash.h>\n#include <linux/net_namespace.h>\n#include <linux/mutex.h>\n#include <linux/genalloc.h>\n#include <net/netevent.h>\n#include <net/neighbour.h>\n#include <net/arp.h>\n#include <net/inet_dscp.h>\n#include <net/ip_fib.h>\n#include <net/ip6_fib.h>\n#include <net/nexthop.h>\n#include <net/fib_rules.h>\n#include <net/ip_tunnels.h>\n#include <net/l3mdev.h>\n#include <net/addrconf.h>\n#include <net/ndisc.h>\n#include <net/ipv6.h>\n#include <net/fib_notifier.h>\n#include <net/switchdev.h>\n\n#include \"spectrum.h\"\n#include \"core.h\"\n#include \"reg.h\"\n#include \"spectrum_cnt.h\"\n#include \"spectrum_dpipe.h\"\n#include \"spectrum_ipip.h\"\n#include \"spectrum_mr.h\"\n#include \"spectrum_mr_tcam.h\"\n#include \"spectrum_router.h\"\n#include \"spectrum_span.h\"\n\nstruct mlxsw_sp_fib;\nstruct mlxsw_sp_vr;\nstruct mlxsw_sp_lpm_tree;\nstruct mlxsw_sp_rif_ops;\n\nstruct mlxsw_sp_crif_key {\n\tstruct net_device *dev;\n};\n\nstruct mlxsw_sp_crif {\n\tstruct mlxsw_sp_crif_key key;\n\tstruct rhash_head ht_node;\n\tbool can_destroy;\n\tstruct list_head nexthop_list;\n\tstruct mlxsw_sp_rif *rif;\n};\n\nstatic const struct rhashtable_params mlxsw_sp_crif_ht_params = {\n\t.key_offset = offsetof(struct mlxsw_sp_crif, key),\n\t.key_len = sizeof_field(struct mlxsw_sp_crif, key),\n\t.head_offset = offsetof(struct mlxsw_sp_crif, ht_node),\n};\n\nstruct mlxsw_sp_rif {\n\tstruct mlxsw_sp_crif *crif;  \n\tnetdevice_tracker dev_tracker;\n\tstruct list_head neigh_list;\n\tstruct mlxsw_sp_fid *fid;\n\tunsigned char addr[ETH_ALEN];\n\tint mtu;\n\tu16 rif_index;\n\tu8 mac_profile_id;\n\tu8 rif_entries;\n\tu16 vr_id;\n\tconst struct mlxsw_sp_rif_ops *ops;\n\tstruct mlxsw_sp *mlxsw_sp;\n\n\tunsigned int counter_ingress;\n\tbool counter_ingress_valid;\n\tunsigned int counter_egress;\n\tbool counter_egress_valid;\n};\n\nstatic struct net_device *mlxsw_sp_rif_dev(const struct mlxsw_sp_rif *rif)\n{\n\tif (!rif->crif)\n\t\treturn NULL;\n\treturn rif->crif->key.dev;\n}\n\nstruct mlxsw_sp_rif_params {\n\tstruct net_device *dev;\n\tunion {\n\t\tu16 system_port;\n\t\tu16 lag_id;\n\t};\n\tu16 vid;\n\tbool lag;\n\tbool double_entry;\n};\n\nstruct mlxsw_sp_rif_subport {\n\tstruct mlxsw_sp_rif common;\n\trefcount_t ref_count;\n\tunion {\n\t\tu16 system_port;\n\t\tu16 lag_id;\n\t};\n\tu16 vid;\n\tbool lag;\n};\n\nstruct mlxsw_sp_rif_ipip_lb {\n\tstruct mlxsw_sp_rif common;\n\tstruct mlxsw_sp_rif_ipip_lb_config lb_config;\n\tu16 ul_vr_id;\t \n\tu16 ul_rif_id;\t \n};\n\nstruct mlxsw_sp_rif_params_ipip_lb {\n\tstruct mlxsw_sp_rif_params common;\n\tstruct mlxsw_sp_rif_ipip_lb_config lb_config;\n};\n\nstruct mlxsw_sp_rif_ops {\n\tenum mlxsw_sp_rif_type type;\n\tsize_t rif_size;\n\n\tvoid (*setup)(struct mlxsw_sp_rif *rif,\n\t\t      const struct mlxsw_sp_rif_params *params);\n\tint (*configure)(struct mlxsw_sp_rif *rif,\n\t\t\t struct netlink_ext_ack *extack);\n\tvoid (*deconfigure)(struct mlxsw_sp_rif *rif);\n\tstruct mlxsw_sp_fid * (*fid_get)(struct mlxsw_sp_rif *rif,\n\t\t\t\t\t const struct mlxsw_sp_rif_params *params,\n\t\t\t\t\t struct netlink_ext_ack *extack);\n\tvoid (*fdb_del)(struct mlxsw_sp_rif *rif, const char *mac);\n};\n\nstruct mlxsw_sp_rif_mac_profile {\n\tunsigned char mac_prefix[ETH_ALEN];\n\trefcount_t ref_count;\n\tu8 id;\n};\n\nstruct mlxsw_sp_router_ops {\n\tint (*init)(struct mlxsw_sp *mlxsw_sp);\n\tint (*ipips_init)(struct mlxsw_sp *mlxsw_sp);\n};\n\nstatic struct mlxsw_sp_rif *\nmlxsw_sp_rif_find_by_dev(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t const struct net_device *dev);\nstatic void mlxsw_sp_rif_destroy(struct mlxsw_sp_rif *rif);\nstatic void mlxsw_sp_lpm_tree_hold(struct mlxsw_sp_lpm_tree *lpm_tree);\nstatic void mlxsw_sp_lpm_tree_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_lpm_tree *lpm_tree);\nstatic int mlxsw_sp_vr_lpm_tree_bind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     const struct mlxsw_sp_fib *fib,\n\t\t\t\t     u8 tree_id);\nstatic int mlxsw_sp_vr_lpm_tree_unbind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       const struct mlxsw_sp_fib *fib);\n\nstatic unsigned int *\nmlxsw_sp_rif_p_counter_get(struct mlxsw_sp_rif *rif,\n\t\t\t   enum mlxsw_sp_rif_counter_dir dir)\n{\n\tswitch (dir) {\n\tcase MLXSW_SP_RIF_COUNTER_EGRESS:\n\t\treturn &rif->counter_egress;\n\tcase MLXSW_SP_RIF_COUNTER_INGRESS:\n\t\treturn &rif->counter_ingress;\n\t}\n\treturn NULL;\n}\n\nstatic bool\nmlxsw_sp_rif_counter_valid_get(struct mlxsw_sp_rif *rif,\n\t\t\t       enum mlxsw_sp_rif_counter_dir dir)\n{\n\tswitch (dir) {\n\tcase MLXSW_SP_RIF_COUNTER_EGRESS:\n\t\treturn rif->counter_egress_valid;\n\tcase MLXSW_SP_RIF_COUNTER_INGRESS:\n\t\treturn rif->counter_ingress_valid;\n\t}\n\treturn false;\n}\n\nstatic void\nmlxsw_sp_rif_counter_valid_set(struct mlxsw_sp_rif *rif,\n\t\t\t       enum mlxsw_sp_rif_counter_dir dir,\n\t\t\t       bool valid)\n{\n\tswitch (dir) {\n\tcase MLXSW_SP_RIF_COUNTER_EGRESS:\n\t\trif->counter_egress_valid = valid;\n\t\tbreak;\n\tcase MLXSW_SP_RIF_COUNTER_INGRESS:\n\t\trif->counter_ingress_valid = valid;\n\t\tbreak;\n\t}\n}\n\nstatic int mlxsw_sp_rif_counter_edit(struct mlxsw_sp *mlxsw_sp, u16 rif_index,\n\t\t\t\t     unsigned int counter_index, bool enable,\n\t\t\t\t     enum mlxsw_sp_rif_counter_dir dir)\n{\n\tchar ritr_pl[MLXSW_REG_RITR_LEN];\n\tbool is_egress = false;\n\tint err;\n\n\tif (dir == MLXSW_SP_RIF_COUNTER_EGRESS)\n\t\tis_egress = true;\n\tmlxsw_reg_ritr_rif_pack(ritr_pl, rif_index);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_ritr_counter_pack(ritr_pl, counter_index, enable,\n\t\t\t\t    is_egress);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);\n}\n\nint mlxsw_sp_rif_counter_value_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_rif *rif,\n\t\t\t\t   enum mlxsw_sp_rif_counter_dir dir, u64 *cnt)\n{\n\tchar ricnt_pl[MLXSW_REG_RICNT_LEN];\n\tunsigned int *p_counter_index;\n\tbool valid;\n\tint err;\n\n\tvalid = mlxsw_sp_rif_counter_valid_get(rif, dir);\n\tif (!valid)\n\t\treturn -EINVAL;\n\n\tp_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);\n\tif (!p_counter_index)\n\t\treturn -EINVAL;\n\tmlxsw_reg_ricnt_pack(ricnt_pl, *p_counter_index,\n\t\t\t     MLXSW_REG_RICNT_OPCODE_NOP);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ricnt), ricnt_pl);\n\tif (err)\n\t\treturn err;\n\t*cnt = mlxsw_reg_ricnt_good_unicast_packets_get(ricnt_pl);\n\treturn 0;\n}\n\nstruct mlxsw_sp_rif_counter_set_basic {\n\tu64 good_unicast_packets;\n\tu64 good_multicast_packets;\n\tu64 good_broadcast_packets;\n\tu64 good_unicast_bytes;\n\tu64 good_multicast_bytes;\n\tu64 good_broadcast_bytes;\n\tu64 error_packets;\n\tu64 discard_packets;\n\tu64 error_bytes;\n\tu64 discard_bytes;\n};\n\nstatic int\nmlxsw_sp_rif_counter_fetch_clear(struct mlxsw_sp_rif *rif,\n\t\t\t\t enum mlxsw_sp_rif_counter_dir dir,\n\t\t\t\t struct mlxsw_sp_rif_counter_set_basic *set)\n{\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tchar ricnt_pl[MLXSW_REG_RICNT_LEN];\n\tunsigned int *p_counter_index;\n\tint err;\n\n\tif (!mlxsw_sp_rif_counter_valid_get(rif, dir))\n\t\treturn -EINVAL;\n\n\tp_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);\n\tif (!p_counter_index)\n\t\treturn -EINVAL;\n\n\tmlxsw_reg_ricnt_pack(ricnt_pl, *p_counter_index,\n\t\t\t     MLXSW_REG_RICNT_OPCODE_CLEAR);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ricnt), ricnt_pl);\n\tif (err)\n\t\treturn err;\n\n\tif (!set)\n\t\treturn 0;\n\n#define MLXSW_SP_RIF_COUNTER_EXTRACT(NAME)\t\t\t\t\\\n\t\t(set->NAME = mlxsw_reg_ricnt_ ## NAME ## _get(ricnt_pl))\n\n\tMLXSW_SP_RIF_COUNTER_EXTRACT(good_unicast_packets);\n\tMLXSW_SP_RIF_COUNTER_EXTRACT(good_multicast_packets);\n\tMLXSW_SP_RIF_COUNTER_EXTRACT(good_broadcast_packets);\n\tMLXSW_SP_RIF_COUNTER_EXTRACT(good_unicast_bytes);\n\tMLXSW_SP_RIF_COUNTER_EXTRACT(good_multicast_bytes);\n\tMLXSW_SP_RIF_COUNTER_EXTRACT(good_broadcast_bytes);\n\tMLXSW_SP_RIF_COUNTER_EXTRACT(error_packets);\n\tMLXSW_SP_RIF_COUNTER_EXTRACT(discard_packets);\n\tMLXSW_SP_RIF_COUNTER_EXTRACT(error_bytes);\n\tMLXSW_SP_RIF_COUNTER_EXTRACT(discard_bytes);\n\n#undef MLXSW_SP_RIF_COUNTER_EXTRACT\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_rif_counter_clear(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      unsigned int counter_index)\n{\n\tchar ricnt_pl[MLXSW_REG_RICNT_LEN];\n\n\tmlxsw_reg_ricnt_pack(ricnt_pl, counter_index,\n\t\t\t     MLXSW_REG_RICNT_OPCODE_CLEAR);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ricnt), ricnt_pl);\n}\n\nint mlxsw_sp_rif_counter_alloc(struct mlxsw_sp_rif *rif,\n\t\t\t       enum mlxsw_sp_rif_counter_dir dir)\n{\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tunsigned int *p_counter_index;\n\tint err;\n\n\tif (mlxsw_sp_rif_counter_valid_get(rif, dir))\n\t\treturn 0;\n\n\tp_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);\n\tif (!p_counter_index)\n\t\treturn -EINVAL;\n\n\terr = mlxsw_sp_counter_alloc(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,\n\t\t\t\t     p_counter_index);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_rif_counter_clear(mlxsw_sp, *p_counter_index);\n\tif (err)\n\t\tgoto err_counter_clear;\n\n\terr = mlxsw_sp_rif_counter_edit(mlxsw_sp, rif->rif_index,\n\t\t\t\t\t*p_counter_index, true, dir);\n\tif (err)\n\t\tgoto err_counter_edit;\n\tmlxsw_sp_rif_counter_valid_set(rif, dir, true);\n\treturn 0;\n\nerr_counter_edit:\nerr_counter_clear:\n\tmlxsw_sp_counter_free(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,\n\t\t\t      *p_counter_index);\n\treturn err;\n}\n\nvoid mlxsw_sp_rif_counter_free(struct mlxsw_sp_rif *rif,\n\t\t\t       enum mlxsw_sp_rif_counter_dir dir)\n{\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tunsigned int *p_counter_index;\n\n\tif (!mlxsw_sp_rif_counter_valid_get(rif, dir))\n\t\treturn;\n\n\tp_counter_index = mlxsw_sp_rif_p_counter_get(rif, dir);\n\tif (WARN_ON(!p_counter_index))\n\t\treturn;\n\tmlxsw_sp_rif_counter_edit(mlxsw_sp, rif->rif_index,\n\t\t\t\t  *p_counter_index, false, dir);\n\tmlxsw_sp_counter_free(mlxsw_sp, MLXSW_SP_COUNTER_SUB_POOL_RIF,\n\t\t\t      *p_counter_index);\n\tmlxsw_sp_rif_counter_valid_set(rif, dir, false);\n}\n\nstatic void mlxsw_sp_rif_counters_alloc(struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tstruct devlink *devlink;\n\n\tdevlink = priv_to_devlink(mlxsw_sp->core);\n\tif (!devlink_dpipe_table_counter_enabled(devlink,\n\t\t\t\t\t\t MLXSW_SP_DPIPE_TABLE_NAME_ERIF))\n\t\treturn;\n\tmlxsw_sp_rif_counter_alloc(rif, MLXSW_SP_RIF_COUNTER_EGRESS);\n}\n\nstatic void mlxsw_sp_rif_counters_free(struct mlxsw_sp_rif *rif)\n{\n\tmlxsw_sp_rif_counter_free(rif, MLXSW_SP_RIF_COUNTER_EGRESS);\n}\n\n#define MLXSW_SP_PREFIX_COUNT (sizeof(struct in6_addr) * BITS_PER_BYTE + 1)\n\nstruct mlxsw_sp_prefix_usage {\n\tDECLARE_BITMAP(b, MLXSW_SP_PREFIX_COUNT);\n};\n\n#define mlxsw_sp_prefix_usage_for_each(prefix, prefix_usage) \\\n\tfor_each_set_bit(prefix, (prefix_usage)->b, MLXSW_SP_PREFIX_COUNT)\n\nstatic bool\nmlxsw_sp_prefix_usage_eq(struct mlxsw_sp_prefix_usage *prefix_usage1,\n\t\t\t struct mlxsw_sp_prefix_usage *prefix_usage2)\n{\n\treturn !memcmp(prefix_usage1, prefix_usage2, sizeof(*prefix_usage1));\n}\n\nstatic void\nmlxsw_sp_prefix_usage_cpy(struct mlxsw_sp_prefix_usage *prefix_usage1,\n\t\t\t  struct mlxsw_sp_prefix_usage *prefix_usage2)\n{\n\tmemcpy(prefix_usage1, prefix_usage2, sizeof(*prefix_usage1));\n}\n\nstatic void\nmlxsw_sp_prefix_usage_set(struct mlxsw_sp_prefix_usage *prefix_usage,\n\t\t\t  unsigned char prefix_len)\n{\n\tset_bit(prefix_len, prefix_usage->b);\n}\n\nstatic void\nmlxsw_sp_prefix_usage_clear(struct mlxsw_sp_prefix_usage *prefix_usage,\n\t\t\t    unsigned char prefix_len)\n{\n\tclear_bit(prefix_len, prefix_usage->b);\n}\n\nstruct mlxsw_sp_fib_key {\n\tunsigned char addr[sizeof(struct in6_addr)];\n\tunsigned char prefix_len;\n};\n\nenum mlxsw_sp_fib_entry_type {\n\tMLXSW_SP_FIB_ENTRY_TYPE_REMOTE,\n\tMLXSW_SP_FIB_ENTRY_TYPE_LOCAL,\n\tMLXSW_SP_FIB_ENTRY_TYPE_TRAP,\n\tMLXSW_SP_FIB_ENTRY_TYPE_BLACKHOLE,\n\tMLXSW_SP_FIB_ENTRY_TYPE_UNREACHABLE,\n\n\t \n\tMLXSW_SP_FIB_ENTRY_TYPE_IPIP_DECAP,\n\tMLXSW_SP_FIB_ENTRY_TYPE_NVE_DECAP,\n};\n\nstruct mlxsw_sp_nexthop_group_info;\nstruct mlxsw_sp_nexthop_group;\nstruct mlxsw_sp_fib_entry;\n\nstruct mlxsw_sp_fib_node {\n\tstruct mlxsw_sp_fib_entry *fib_entry;\n\tstruct list_head list;\n\tstruct rhash_head ht_node;\n\tstruct mlxsw_sp_fib *fib;\n\tstruct mlxsw_sp_fib_key key;\n};\n\nstruct mlxsw_sp_fib_entry_decap {\n\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\tu32 tunnel_index;\n};\n\nstruct mlxsw_sp_fib_entry {\n\tstruct mlxsw_sp_fib_node *fib_node;\n\tenum mlxsw_sp_fib_entry_type type;\n\tstruct list_head nexthop_group_node;\n\tstruct mlxsw_sp_nexthop_group *nh_group;\n\tstruct mlxsw_sp_fib_entry_decap decap;  \n};\n\nstruct mlxsw_sp_fib4_entry {\n\tstruct mlxsw_sp_fib_entry common;\n\tstruct fib_info *fi;\n\tu32 tb_id;\n\tdscp_t dscp;\n\tu8 type;\n};\n\nstruct mlxsw_sp_fib6_entry {\n\tstruct mlxsw_sp_fib_entry common;\n\tstruct list_head rt6_list;\n\tunsigned int nrt6;\n};\n\nstruct mlxsw_sp_rt6 {\n\tstruct list_head list;\n\tstruct fib6_info *rt;\n};\n\nstruct mlxsw_sp_lpm_tree {\n\tu8 id;  \n\tunsigned int ref_count;\n\tenum mlxsw_sp_l3proto proto;\n\tunsigned long prefix_ref_count[MLXSW_SP_PREFIX_COUNT];\n\tstruct mlxsw_sp_prefix_usage prefix_usage;\n};\n\nstruct mlxsw_sp_fib {\n\tstruct rhashtable ht;\n\tstruct list_head node_list;\n\tstruct mlxsw_sp_vr *vr;\n\tstruct mlxsw_sp_lpm_tree *lpm_tree;\n\tenum mlxsw_sp_l3proto proto;\n};\n\nstruct mlxsw_sp_vr {\n\tu16 id;  \n\tu32 tb_id;  \n\tunsigned int rif_count;\n\tstruct mlxsw_sp_fib *fib4;\n\tstruct mlxsw_sp_fib *fib6;\n\tstruct mlxsw_sp_mr_table *mr_table[MLXSW_SP_L3_PROTO_MAX];\n\tstruct mlxsw_sp_rif *ul_rif;\n\trefcount_t ul_rif_refcnt;\n};\n\nstatic const struct rhashtable_params mlxsw_sp_fib_ht_params;\n\nstatic struct mlxsw_sp_fib *mlxsw_sp_fib_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tstruct mlxsw_sp_vr *vr,\n\t\t\t\t\t\tenum mlxsw_sp_l3proto proto)\n{\n\tstruct mlxsw_sp_lpm_tree *lpm_tree;\n\tstruct mlxsw_sp_fib *fib;\n\tint err;\n\n\tlpm_tree = mlxsw_sp->router->lpm.proto_trees[proto];\n\tfib = kzalloc(sizeof(*fib), GFP_KERNEL);\n\tif (!fib)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = rhashtable_init(&fib->ht, &mlxsw_sp_fib_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_init;\n\tINIT_LIST_HEAD(&fib->node_list);\n\tfib->proto = proto;\n\tfib->vr = vr;\n\tfib->lpm_tree = lpm_tree;\n\tmlxsw_sp_lpm_tree_hold(lpm_tree);\n\terr = mlxsw_sp_vr_lpm_tree_bind(mlxsw_sp, fib, lpm_tree->id);\n\tif (err)\n\t\tgoto err_lpm_tree_bind;\n\treturn fib;\n\nerr_lpm_tree_bind:\n\tmlxsw_sp_lpm_tree_put(mlxsw_sp, lpm_tree);\nerr_rhashtable_init:\n\tkfree(fib);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_fib_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_fib *fib)\n{\n\tmlxsw_sp_vr_lpm_tree_unbind(mlxsw_sp, fib);\n\tmlxsw_sp_lpm_tree_put(mlxsw_sp, fib->lpm_tree);\n\tWARN_ON(!list_empty(&fib->node_list));\n\trhashtable_destroy(&fib->ht);\n\tkfree(fib);\n}\n\nstatic struct mlxsw_sp_lpm_tree *\nmlxsw_sp_lpm_tree_find_unused(struct mlxsw_sp *mlxsw_sp)\n{\n\tstatic struct mlxsw_sp_lpm_tree *lpm_tree;\n\tint i;\n\n\tfor (i = 0; i < mlxsw_sp->router->lpm.tree_count; i++) {\n\t\tlpm_tree = &mlxsw_sp->router->lpm.trees[i];\n\t\tif (lpm_tree->ref_count == 0)\n\t\t\treturn lpm_tree;\n\t}\n\treturn NULL;\n}\n\nstatic int mlxsw_sp_lpm_tree_alloc(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_lpm_tree *lpm_tree)\n{\n\tchar ralta_pl[MLXSW_REG_RALTA_LEN];\n\n\tmlxsw_reg_ralta_pack(ralta_pl, true,\n\t\t\t     (enum mlxsw_reg_ralxx_protocol) lpm_tree->proto,\n\t\t\t     lpm_tree->id);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ralta), ralta_pl);\n}\n\nstatic void mlxsw_sp_lpm_tree_free(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_lpm_tree *lpm_tree)\n{\n\tchar ralta_pl[MLXSW_REG_RALTA_LEN];\n\n\tmlxsw_reg_ralta_pack(ralta_pl, false,\n\t\t\t     (enum mlxsw_reg_ralxx_protocol) lpm_tree->proto,\n\t\t\t     lpm_tree->id);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ralta), ralta_pl);\n}\n\nstatic int\nmlxsw_sp_lpm_tree_left_struct_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_prefix_usage *prefix_usage,\n\t\t\t\t  struct mlxsw_sp_lpm_tree *lpm_tree)\n{\n\tchar ralst_pl[MLXSW_REG_RALST_LEN];\n\tu8 root_bin = 0;\n\tu8 prefix;\n\tu8 last_prefix = MLXSW_REG_RALST_BIN_NO_CHILD;\n\n\tmlxsw_sp_prefix_usage_for_each(prefix, prefix_usage)\n\t\troot_bin = prefix;\n\n\tmlxsw_reg_ralst_pack(ralst_pl, root_bin, lpm_tree->id);\n\tmlxsw_sp_prefix_usage_for_each(prefix, prefix_usage) {\n\t\tif (prefix == 0)\n\t\t\tcontinue;\n\t\tmlxsw_reg_ralst_bin_pack(ralst_pl, prefix, last_prefix,\n\t\t\t\t\t MLXSW_REG_RALST_BIN_NO_CHILD);\n\t\tlast_prefix = prefix;\n\t}\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ralst), ralst_pl);\n}\n\nstatic struct mlxsw_sp_lpm_tree *\nmlxsw_sp_lpm_tree_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t struct mlxsw_sp_prefix_usage *prefix_usage,\n\t\t\t enum mlxsw_sp_l3proto proto)\n{\n\tstruct mlxsw_sp_lpm_tree *lpm_tree;\n\tint err;\n\n\tlpm_tree = mlxsw_sp_lpm_tree_find_unused(mlxsw_sp);\n\tif (!lpm_tree)\n\t\treturn ERR_PTR(-EBUSY);\n\tlpm_tree->proto = proto;\n\terr = mlxsw_sp_lpm_tree_alloc(mlxsw_sp, lpm_tree);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\terr = mlxsw_sp_lpm_tree_left_struct_set(mlxsw_sp, prefix_usage,\n\t\t\t\t\t\tlpm_tree);\n\tif (err)\n\t\tgoto err_left_struct_set;\n\tmemcpy(&lpm_tree->prefix_usage, prefix_usage,\n\t       sizeof(lpm_tree->prefix_usage));\n\tmemset(&lpm_tree->prefix_ref_count, 0,\n\t       sizeof(lpm_tree->prefix_ref_count));\n\tlpm_tree->ref_count = 1;\n\treturn lpm_tree;\n\nerr_left_struct_set:\n\tmlxsw_sp_lpm_tree_free(mlxsw_sp, lpm_tree);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_lpm_tree_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct mlxsw_sp_lpm_tree *lpm_tree)\n{\n\tmlxsw_sp_lpm_tree_free(mlxsw_sp, lpm_tree);\n}\n\nstatic struct mlxsw_sp_lpm_tree *\nmlxsw_sp_lpm_tree_get(struct mlxsw_sp *mlxsw_sp,\n\t\t      struct mlxsw_sp_prefix_usage *prefix_usage,\n\t\t      enum mlxsw_sp_l3proto proto)\n{\n\tstruct mlxsw_sp_lpm_tree *lpm_tree;\n\tint i;\n\n\tfor (i = 0; i < mlxsw_sp->router->lpm.tree_count; i++) {\n\t\tlpm_tree = &mlxsw_sp->router->lpm.trees[i];\n\t\tif (lpm_tree->ref_count != 0 &&\n\t\t    lpm_tree->proto == proto &&\n\t\t    mlxsw_sp_prefix_usage_eq(&lpm_tree->prefix_usage,\n\t\t\t\t\t     prefix_usage)) {\n\t\t\tmlxsw_sp_lpm_tree_hold(lpm_tree);\n\t\t\treturn lpm_tree;\n\t\t}\n\t}\n\treturn mlxsw_sp_lpm_tree_create(mlxsw_sp, prefix_usage, proto);\n}\n\nstatic void mlxsw_sp_lpm_tree_hold(struct mlxsw_sp_lpm_tree *lpm_tree)\n{\n\tlpm_tree->ref_count++;\n}\n\nstatic void mlxsw_sp_lpm_tree_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_lpm_tree *lpm_tree)\n{\n\tif (--lpm_tree->ref_count == 0)\n\t\tmlxsw_sp_lpm_tree_destroy(mlxsw_sp, lpm_tree);\n}\n\n#define MLXSW_SP_LPM_TREE_MIN 1  \n\nstatic int mlxsw_sp_lpm_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_prefix_usage req_prefix_usage = {{ 0 } };\n\tstruct mlxsw_sp_lpm_tree *lpm_tree;\n\tu64 max_trees;\n\tint err, i;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, MAX_LPM_TREES))\n\t\treturn -EIO;\n\n\tmax_trees = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_LPM_TREES);\n\tmlxsw_sp->router->lpm.tree_count = max_trees - MLXSW_SP_LPM_TREE_MIN;\n\tmlxsw_sp->router->lpm.trees = kcalloc(mlxsw_sp->router->lpm.tree_count,\n\t\t\t\t\t     sizeof(struct mlxsw_sp_lpm_tree),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!mlxsw_sp->router->lpm.trees)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < mlxsw_sp->router->lpm.tree_count; i++) {\n\t\tlpm_tree = &mlxsw_sp->router->lpm.trees[i];\n\t\tlpm_tree->id = i + MLXSW_SP_LPM_TREE_MIN;\n\t}\n\n\tlpm_tree = mlxsw_sp_lpm_tree_get(mlxsw_sp, &req_prefix_usage,\n\t\t\t\t\t MLXSW_SP_L3_PROTO_IPV4);\n\tif (IS_ERR(lpm_tree)) {\n\t\terr = PTR_ERR(lpm_tree);\n\t\tgoto err_ipv4_tree_get;\n\t}\n\tmlxsw_sp->router->lpm.proto_trees[MLXSW_SP_L3_PROTO_IPV4] = lpm_tree;\n\n\tlpm_tree = mlxsw_sp_lpm_tree_get(mlxsw_sp, &req_prefix_usage,\n\t\t\t\t\t MLXSW_SP_L3_PROTO_IPV6);\n\tif (IS_ERR(lpm_tree)) {\n\t\terr = PTR_ERR(lpm_tree);\n\t\tgoto err_ipv6_tree_get;\n\t}\n\tmlxsw_sp->router->lpm.proto_trees[MLXSW_SP_L3_PROTO_IPV6] = lpm_tree;\n\n\treturn 0;\n\nerr_ipv6_tree_get:\n\tlpm_tree = mlxsw_sp->router->lpm.proto_trees[MLXSW_SP_L3_PROTO_IPV4];\n\tmlxsw_sp_lpm_tree_put(mlxsw_sp, lpm_tree);\nerr_ipv4_tree_get:\n\tkfree(mlxsw_sp->router->lpm.trees);\n\treturn err;\n}\n\nstatic void mlxsw_sp_lpm_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_lpm_tree *lpm_tree;\n\n\tlpm_tree = mlxsw_sp->router->lpm.proto_trees[MLXSW_SP_L3_PROTO_IPV6];\n\tmlxsw_sp_lpm_tree_put(mlxsw_sp, lpm_tree);\n\n\tlpm_tree = mlxsw_sp->router->lpm.proto_trees[MLXSW_SP_L3_PROTO_IPV4];\n\tmlxsw_sp_lpm_tree_put(mlxsw_sp, lpm_tree);\n\n\tkfree(mlxsw_sp->router->lpm.trees);\n}\n\nstatic bool mlxsw_sp_vr_is_used(const struct mlxsw_sp_vr *vr)\n{\n\treturn !!vr->fib4 || !!vr->fib6 ||\n\t       !!vr->mr_table[MLXSW_SP_L3_PROTO_IPV4] ||\n\t       !!vr->mr_table[MLXSW_SP_L3_PROTO_IPV6];\n}\n\nstatic struct mlxsw_sp_vr *mlxsw_sp_vr_find_unused(struct mlxsw_sp *mlxsw_sp)\n{\n\tint max_vrs = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_VRS);\n\tstruct mlxsw_sp_vr *vr;\n\tint i;\n\n\tfor (i = 0; i < max_vrs; i++) {\n\t\tvr = &mlxsw_sp->router->vrs[i];\n\t\tif (!mlxsw_sp_vr_is_used(vr))\n\t\t\treturn vr;\n\t}\n\treturn NULL;\n}\n\nstatic int mlxsw_sp_vr_lpm_tree_bind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     const struct mlxsw_sp_fib *fib, u8 tree_id)\n{\n\tchar raltb_pl[MLXSW_REG_RALTB_LEN];\n\n\tmlxsw_reg_raltb_pack(raltb_pl, fib->vr->id,\n\t\t\t     (enum mlxsw_reg_ralxx_protocol) fib->proto,\n\t\t\t     tree_id);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(raltb), raltb_pl);\n}\n\nstatic int mlxsw_sp_vr_lpm_tree_unbind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       const struct mlxsw_sp_fib *fib)\n{\n\tchar raltb_pl[MLXSW_REG_RALTB_LEN];\n\n\t \n\tmlxsw_reg_raltb_pack(raltb_pl, fib->vr->id,\n\t\t\t     (enum mlxsw_reg_ralxx_protocol) fib->proto, 0);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(raltb), raltb_pl);\n}\n\nstatic u32 mlxsw_sp_fix_tb_id(u32 tb_id)\n{\n\t \n\tif (tb_id == RT_TABLE_LOCAL || tb_id == RT_TABLE_DEFAULT)\n\t\ttb_id = RT_TABLE_MAIN;\n\treturn tb_id;\n}\n\nstatic struct mlxsw_sp_vr *mlxsw_sp_vr_find(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    u32 tb_id)\n{\n\tint max_vrs = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_VRS);\n\tstruct mlxsw_sp_vr *vr;\n\tint i;\n\n\ttb_id = mlxsw_sp_fix_tb_id(tb_id);\n\n\tfor (i = 0; i < max_vrs; i++) {\n\t\tvr = &mlxsw_sp->router->vrs[i];\n\t\tif (mlxsw_sp_vr_is_used(vr) && vr->tb_id == tb_id)\n\t\t\treturn vr;\n\t}\n\treturn NULL;\n}\n\nint mlxsw_sp_router_tb_id_vr_id(struct mlxsw_sp *mlxsw_sp, u32 tb_id,\n\t\t\t\tu16 *vr_id)\n{\n\tstruct mlxsw_sp_vr *vr;\n\tint err = 0;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\tvr = mlxsw_sp_vr_find(mlxsw_sp, tb_id);\n\tif (!vr) {\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\t*vr_id = vr->id;\nout:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\treturn err;\n}\n\nstatic struct mlxsw_sp_fib *mlxsw_sp_vr_fib(const struct mlxsw_sp_vr *vr,\n\t\t\t\t\t    enum mlxsw_sp_l3proto proto)\n{\n\tswitch (proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\treturn vr->fib4;\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\treturn vr->fib6;\n\t}\n\treturn NULL;\n}\n\nstatic struct mlxsw_sp_vr *mlxsw_sp_vr_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t      u32 tb_id,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_mr_table *mr4_table, *mr6_table;\n\tstruct mlxsw_sp_fib *fib4;\n\tstruct mlxsw_sp_fib *fib6;\n\tstruct mlxsw_sp_vr *vr;\n\tint err;\n\n\tvr = mlxsw_sp_vr_find_unused(mlxsw_sp);\n\tif (!vr) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Exceeded number of supported virtual routers\");\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tfib4 = mlxsw_sp_fib_create(mlxsw_sp, vr, MLXSW_SP_L3_PROTO_IPV4);\n\tif (IS_ERR(fib4))\n\t\treturn ERR_CAST(fib4);\n\tfib6 = mlxsw_sp_fib_create(mlxsw_sp, vr, MLXSW_SP_L3_PROTO_IPV6);\n\tif (IS_ERR(fib6)) {\n\t\terr = PTR_ERR(fib6);\n\t\tgoto err_fib6_create;\n\t}\n\tmr4_table = mlxsw_sp_mr_table_create(mlxsw_sp, vr->id,\n\t\t\t\t\t     MLXSW_SP_L3_PROTO_IPV4);\n\tif (IS_ERR(mr4_table)) {\n\t\terr = PTR_ERR(mr4_table);\n\t\tgoto err_mr4_table_create;\n\t}\n\tmr6_table = mlxsw_sp_mr_table_create(mlxsw_sp, vr->id,\n\t\t\t\t\t     MLXSW_SP_L3_PROTO_IPV6);\n\tif (IS_ERR(mr6_table)) {\n\t\terr = PTR_ERR(mr6_table);\n\t\tgoto err_mr6_table_create;\n\t}\n\n\tvr->fib4 = fib4;\n\tvr->fib6 = fib6;\n\tvr->mr_table[MLXSW_SP_L3_PROTO_IPV4] = mr4_table;\n\tvr->mr_table[MLXSW_SP_L3_PROTO_IPV6] = mr6_table;\n\tvr->tb_id = tb_id;\n\treturn vr;\n\nerr_mr6_table_create:\n\tmlxsw_sp_mr_table_destroy(mr4_table);\nerr_mr4_table_create:\n\tmlxsw_sp_fib_destroy(mlxsw_sp, fib6);\nerr_fib6_create:\n\tmlxsw_sp_fib_destroy(mlxsw_sp, fib4);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_vr_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_vr *vr)\n{\n\tmlxsw_sp_mr_table_destroy(vr->mr_table[MLXSW_SP_L3_PROTO_IPV6]);\n\tvr->mr_table[MLXSW_SP_L3_PROTO_IPV6] = NULL;\n\tmlxsw_sp_mr_table_destroy(vr->mr_table[MLXSW_SP_L3_PROTO_IPV4]);\n\tvr->mr_table[MLXSW_SP_L3_PROTO_IPV4] = NULL;\n\tmlxsw_sp_fib_destroy(mlxsw_sp, vr->fib6);\n\tvr->fib6 = NULL;\n\tmlxsw_sp_fib_destroy(mlxsw_sp, vr->fib4);\n\tvr->fib4 = NULL;\n}\n\nstatic struct mlxsw_sp_vr *mlxsw_sp_vr_get(struct mlxsw_sp *mlxsw_sp, u32 tb_id,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_vr *vr;\n\n\ttb_id = mlxsw_sp_fix_tb_id(tb_id);\n\tvr = mlxsw_sp_vr_find(mlxsw_sp, tb_id);\n\tif (!vr)\n\t\tvr = mlxsw_sp_vr_create(mlxsw_sp, tb_id, extack);\n\treturn vr;\n}\n\nstatic void mlxsw_sp_vr_put(struct mlxsw_sp *mlxsw_sp, struct mlxsw_sp_vr *vr)\n{\n\tif (!vr->rif_count && list_empty(&vr->fib4->node_list) &&\n\t    list_empty(&vr->fib6->node_list) &&\n\t    mlxsw_sp_mr_table_empty(vr->mr_table[MLXSW_SP_L3_PROTO_IPV4]) &&\n\t    mlxsw_sp_mr_table_empty(vr->mr_table[MLXSW_SP_L3_PROTO_IPV6]))\n\t\tmlxsw_sp_vr_destroy(mlxsw_sp, vr);\n}\n\nstatic bool\nmlxsw_sp_vr_lpm_tree_should_replace(struct mlxsw_sp_vr *vr,\n\t\t\t\t    enum mlxsw_sp_l3proto proto, u8 tree_id)\n{\n\tstruct mlxsw_sp_fib *fib = mlxsw_sp_vr_fib(vr, proto);\n\n\tif (!mlxsw_sp_vr_is_used(vr))\n\t\treturn false;\n\tif (fib->lpm_tree->id == tree_id)\n\t\treturn true;\n\treturn false;\n}\n\nstatic int mlxsw_sp_vr_lpm_tree_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_fib *fib,\n\t\t\t\t\tstruct mlxsw_sp_lpm_tree *new_tree)\n{\n\tstruct mlxsw_sp_lpm_tree *old_tree = fib->lpm_tree;\n\tint err;\n\n\tfib->lpm_tree = new_tree;\n\tmlxsw_sp_lpm_tree_hold(new_tree);\n\terr = mlxsw_sp_vr_lpm_tree_bind(mlxsw_sp, fib, new_tree->id);\n\tif (err)\n\t\tgoto err_tree_bind;\n\tmlxsw_sp_lpm_tree_put(mlxsw_sp, old_tree);\n\treturn 0;\n\nerr_tree_bind:\n\tmlxsw_sp_lpm_tree_put(mlxsw_sp, new_tree);\n\tfib->lpm_tree = old_tree;\n\treturn err;\n}\n\nstatic int mlxsw_sp_vrs_lpm_tree_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t struct mlxsw_sp_fib *fib,\n\t\t\t\t\t struct mlxsw_sp_lpm_tree *new_tree)\n{\n\tint max_vrs = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_VRS);\n\tenum mlxsw_sp_l3proto proto = fib->proto;\n\tstruct mlxsw_sp_lpm_tree *old_tree;\n\tu8 old_id, new_id = new_tree->id;\n\tstruct mlxsw_sp_vr *vr;\n\tint i, err;\n\n\told_tree = mlxsw_sp->router->lpm.proto_trees[proto];\n\told_id = old_tree->id;\n\n\tfor (i = 0; i < max_vrs; i++) {\n\t\tvr = &mlxsw_sp->router->vrs[i];\n\t\tif (!mlxsw_sp_vr_lpm_tree_should_replace(vr, proto, old_id))\n\t\t\tcontinue;\n\t\terr = mlxsw_sp_vr_lpm_tree_replace(mlxsw_sp,\n\t\t\t\t\t\t   mlxsw_sp_vr_fib(vr, proto),\n\t\t\t\t\t\t   new_tree);\n\t\tif (err)\n\t\t\tgoto err_tree_replace;\n\t}\n\n\tmemcpy(new_tree->prefix_ref_count, old_tree->prefix_ref_count,\n\t       sizeof(new_tree->prefix_ref_count));\n\tmlxsw_sp->router->lpm.proto_trees[proto] = new_tree;\n\tmlxsw_sp_lpm_tree_put(mlxsw_sp, old_tree);\n\n\treturn 0;\n\nerr_tree_replace:\n\tfor (i--; i >= 0; i--) {\n\t\tif (!mlxsw_sp_vr_lpm_tree_should_replace(vr, proto, new_id))\n\t\t\tcontinue;\n\t\tmlxsw_sp_vr_lpm_tree_replace(mlxsw_sp,\n\t\t\t\t\t     mlxsw_sp_vr_fib(vr, proto),\n\t\t\t\t\t     old_tree);\n\t}\n\treturn err;\n}\n\nstatic int mlxsw_sp_vrs_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_vr *vr;\n\tu64 max_vrs;\n\tint i;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, MAX_VRS))\n\t\treturn -EIO;\n\n\tmax_vrs = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_VRS);\n\tmlxsw_sp->router->vrs = kcalloc(max_vrs, sizeof(struct mlxsw_sp_vr),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!mlxsw_sp->router->vrs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < max_vrs; i++) {\n\t\tvr = &mlxsw_sp->router->vrs[i];\n\t\tvr->id = i;\n\t}\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_router_fib_flush(struct mlxsw_sp *mlxsw_sp);\n\nstatic void mlxsw_sp_vrs_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\t \n\tmlxsw_core_flush_owq();\n\tmlxsw_sp_router_fib_flush(mlxsw_sp);\n\tkfree(mlxsw_sp->router->vrs);\n}\n\nu32 mlxsw_sp_ipip_dev_ul_tb_id(const struct net_device *ol_dev)\n{\n\tstruct net_device *d;\n\tu32 tb_id;\n\n\trcu_read_lock();\n\td = mlxsw_sp_ipip_netdev_ul_dev_get(ol_dev);\n\tif (d)\n\t\ttb_id = l3mdev_fib_table(d) ? : RT_TABLE_MAIN;\n\telse\n\t\ttb_id = RT_TABLE_MAIN;\n\trcu_read_unlock();\n\n\treturn tb_id;\n}\n\nstatic void\nmlxsw_sp_crif_init(struct mlxsw_sp_crif *crif, struct net_device *dev)\n{\n\tcrif->key.dev = dev;\n\tINIT_LIST_HEAD(&crif->nexthop_list);\n}\n\nstatic struct mlxsw_sp_crif *\nmlxsw_sp_crif_alloc(struct net_device *dev)\n{\n\tstruct mlxsw_sp_crif *crif;\n\n\tcrif = kzalloc(sizeof(*crif), GFP_KERNEL);\n\tif (!crif)\n\t\treturn NULL;\n\n\tmlxsw_sp_crif_init(crif, dev);\n\treturn crif;\n}\n\nstatic void mlxsw_sp_crif_free(struct mlxsw_sp_crif *crif)\n{\n\tif (WARN_ON(crif->rif))\n\t\treturn;\n\n\tWARN_ON(!list_empty(&crif->nexthop_list));\n\tkfree(crif);\n}\n\nstatic int mlxsw_sp_crif_insert(struct mlxsw_sp_router *router,\n\t\t\t\tstruct mlxsw_sp_crif *crif)\n{\n\treturn rhashtable_insert_fast(&router->crif_ht, &crif->ht_node,\n\t\t\t\t      mlxsw_sp_crif_ht_params);\n}\n\nstatic void mlxsw_sp_crif_remove(struct mlxsw_sp_router *router,\n\t\t\t\t struct mlxsw_sp_crif *crif)\n{\n\trhashtable_remove_fast(&router->crif_ht, &crif->ht_node,\n\t\t\t       mlxsw_sp_crif_ht_params);\n}\n\nstatic struct mlxsw_sp_crif *\nmlxsw_sp_crif_lookup(struct mlxsw_sp_router *router,\n\t\t     const struct net_device *dev)\n{\n\tstruct mlxsw_sp_crif_key key = {\n\t\t.dev = (struct net_device *)dev,\n\t};\n\n\treturn rhashtable_lookup_fast(&router->crif_ht, &key,\n\t\t\t\t      mlxsw_sp_crif_ht_params);\n}\n\nstatic struct mlxsw_sp_rif *\nmlxsw_sp_rif_create(struct mlxsw_sp *mlxsw_sp,\n\t\t    const struct mlxsw_sp_rif_params *params,\n\t\t    struct netlink_ext_ack *extack);\n\nstatic struct mlxsw_sp_rif_ipip_lb *\nmlxsw_sp_ipip_ol_ipip_lb_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tenum mlxsw_sp_ipip_type ipipt,\n\t\t\t\tstruct net_device *ol_dev,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_rif_params_ipip_lb lb_params;\n\tconst struct mlxsw_sp_ipip_ops *ipip_ops;\n\tstruct mlxsw_sp_rif *rif;\n\n\tipip_ops = mlxsw_sp->router->ipip_ops_arr[ipipt];\n\tlb_params = (struct mlxsw_sp_rif_params_ipip_lb) {\n\t\t.common.dev = ol_dev,\n\t\t.common.lag = false,\n\t\t.common.double_entry = ipip_ops->double_rif_entry,\n\t\t.lb_config = ipip_ops->ol_loopback_config(mlxsw_sp, ol_dev),\n\t};\n\n\trif = mlxsw_sp_rif_create(mlxsw_sp, &lb_params.common, extack);\n\tif (IS_ERR(rif))\n\t\treturn ERR_CAST(rif);\n\treturn container_of(rif, struct mlxsw_sp_rif_ipip_lb, common);\n}\n\nstatic struct mlxsw_sp_ipip_entry *\nmlxsw_sp_ipip_entry_alloc(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  enum mlxsw_sp_ipip_type ipipt,\n\t\t\t  struct net_device *ol_dev)\n{\n\tconst struct mlxsw_sp_ipip_ops *ipip_ops;\n\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\tstruct mlxsw_sp_ipip_entry *ret = NULL;\n\tint err;\n\n\tipip_ops = mlxsw_sp->router->ipip_ops_arr[ipipt];\n\tipip_entry = kzalloc(sizeof(*ipip_entry), GFP_KERNEL);\n\tif (!ipip_entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tipip_entry->ol_lb = mlxsw_sp_ipip_ol_ipip_lb_create(mlxsw_sp, ipipt,\n\t\t\t\t\t\t\t    ol_dev, NULL);\n\tif (IS_ERR(ipip_entry->ol_lb)) {\n\t\tret = ERR_CAST(ipip_entry->ol_lb);\n\t\tgoto err_ol_ipip_lb_create;\n\t}\n\n\tipip_entry->ipipt = ipipt;\n\tipip_entry->ol_dev = ol_dev;\n\tipip_entry->parms = ipip_ops->parms_init(ol_dev);\n\n\terr = ipip_ops->rem_ip_addr_set(mlxsw_sp, ipip_entry);\n\tif (err) {\n\t\tret = ERR_PTR(err);\n\t\tgoto err_rem_ip_addr_set;\n\t}\n\n\treturn ipip_entry;\n\nerr_rem_ip_addr_set:\n\tmlxsw_sp_rif_destroy(&ipip_entry->ol_lb->common);\nerr_ol_ipip_lb_create:\n\tkfree(ipip_entry);\n\treturn ret;\n}\n\nstatic void mlxsw_sp_ipip_entry_dealloc(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_ipip_entry *ipip_entry)\n{\n\tconst struct mlxsw_sp_ipip_ops *ipip_ops =\n\t\tmlxsw_sp->router->ipip_ops_arr[ipip_entry->ipipt];\n\n\tipip_ops->rem_ip_addr_unset(mlxsw_sp, ipip_entry);\n\tmlxsw_sp_rif_destroy(&ipip_entry->ol_lb->common);\n\tkfree(ipip_entry);\n}\n\nstatic bool\nmlxsw_sp_ipip_entry_saddr_matches(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  const enum mlxsw_sp_l3proto ul_proto,\n\t\t\t\t  union mlxsw_sp_l3addr saddr,\n\t\t\t\t  u32 ul_tb_id,\n\t\t\t\t  struct mlxsw_sp_ipip_entry *ipip_entry)\n{\n\tu32 tun_ul_tb_id = mlxsw_sp_ipip_dev_ul_tb_id(ipip_entry->ol_dev);\n\tenum mlxsw_sp_ipip_type ipipt = ipip_entry->ipipt;\n\tunion mlxsw_sp_l3addr tun_saddr;\n\n\tif (mlxsw_sp->router->ipip_ops_arr[ipipt]->ul_proto != ul_proto)\n\t\treturn false;\n\n\ttun_saddr = mlxsw_sp_ipip_netdev_saddr(ul_proto, ipip_entry->ol_dev);\n\treturn tun_ul_tb_id == ul_tb_id &&\n\t       mlxsw_sp_l3addr_eq(&tun_saddr, &saddr);\n}\n\nstatic int mlxsw_sp_ipip_decap_parsing_depth_inc(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t enum mlxsw_sp_ipip_type ipipt)\n{\n\tconst struct mlxsw_sp_ipip_ops *ipip_ops;\n\n\tipip_ops = mlxsw_sp->router->ipip_ops_arr[ipipt];\n\n\t \n\tif (ipip_ops->inc_parsing_depth)\n\t\treturn mlxsw_sp_parsing_depth_inc(mlxsw_sp);\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_ipip_decap_parsing_depth_dec(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t  enum mlxsw_sp_ipip_type ipipt)\n{\n\tconst struct mlxsw_sp_ipip_ops *ipip_ops =\n\t\tmlxsw_sp->router->ipip_ops_arr[ipipt];\n\n\tif (ipip_ops->inc_parsing_depth)\n\t\tmlxsw_sp_parsing_depth_dec(mlxsw_sp);\n}\n\nstatic int\nmlxsw_sp_fib_entry_decap_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t      struct mlxsw_sp_ipip_entry *ipip_entry)\n{\n\tu32 tunnel_index;\n\tint err;\n\n\terr = mlxsw_sp_kvdl_alloc(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ADJ,\n\t\t\t\t  1, &tunnel_index);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_ipip_decap_parsing_depth_inc(mlxsw_sp,\n\t\t\t\t\t\t    ipip_entry->ipipt);\n\tif (err)\n\t\tgoto err_parsing_depth_inc;\n\n\tipip_entry->decap_fib_entry = fib_entry;\n\tfib_entry->decap.ipip_entry = ipip_entry;\n\tfib_entry->decap.tunnel_index = tunnel_index;\n\n\treturn 0;\n\nerr_parsing_depth_inc:\n\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ADJ, 1,\n\t\t\t   fib_entry->decap.tunnel_index);\n\treturn err;\n}\n\nstatic void mlxsw_sp_fib_entry_decap_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct mlxsw_sp_fib_entry *fib_entry)\n{\n\tenum mlxsw_sp_ipip_type ipipt = fib_entry->decap.ipip_entry->ipipt;\n\n\t \n\tfib_entry->decap.ipip_entry->decap_fib_entry = NULL;\n\tfib_entry->decap.ipip_entry = NULL;\n\tmlxsw_sp_ipip_decap_parsing_depth_dec(mlxsw_sp, ipipt);\n\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ADJ,\n\t\t\t   1, fib_entry->decap.tunnel_index);\n}\n\nstatic struct mlxsw_sp_fib_node *\nmlxsw_sp_fib_node_lookup(struct mlxsw_sp_fib *fib, const void *addr,\n\t\t\t size_t addr_len, unsigned char prefix_len);\nstatic int mlxsw_sp_fib_entry_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_fib_entry *fib_entry);\n\nstatic void\nmlxsw_sp_ipip_entry_demote_decap(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_ipip_entry *ipip_entry)\n{\n\tstruct mlxsw_sp_fib_entry *fib_entry = ipip_entry->decap_fib_entry;\n\n\tmlxsw_sp_fib_entry_decap_fini(mlxsw_sp, fib_entry);\n\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_TRAP;\n\n\tmlxsw_sp_fib_entry_update(mlxsw_sp, fib_entry);\n}\n\nstatic void\nmlxsw_sp_ipip_entry_promote_decap(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\t  struct mlxsw_sp_fib_entry *decap_fib_entry)\n{\n\tif (mlxsw_sp_fib_entry_decap_init(mlxsw_sp, decap_fib_entry,\n\t\t\t\t\t  ipip_entry))\n\t\treturn;\n\tdecap_fib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_IPIP_DECAP;\n\n\tif (mlxsw_sp_fib_entry_update(mlxsw_sp, decap_fib_entry))\n\t\tmlxsw_sp_ipip_entry_demote_decap(mlxsw_sp, ipip_entry);\n}\n\nstatic struct mlxsw_sp_fib_entry *\nmlxsw_sp_router_ip2me_fib_entry_find(struct mlxsw_sp *mlxsw_sp, u32 tb_id,\n\t\t\t\t     enum mlxsw_sp_l3proto proto,\n\t\t\t\t     const union mlxsw_sp_l3addr *addr,\n\t\t\t\t     enum mlxsw_sp_fib_entry_type type)\n{\n\tstruct mlxsw_sp_fib_node *fib_node;\n\tunsigned char addr_prefix_len;\n\tstruct mlxsw_sp_fib *fib;\n\tstruct mlxsw_sp_vr *vr;\n\tconst void *addrp;\n\tsize_t addr_len;\n\tu32 addr4;\n\n\tvr = mlxsw_sp_vr_find(mlxsw_sp, tb_id);\n\tif (!vr)\n\t\treturn NULL;\n\tfib = mlxsw_sp_vr_fib(vr, proto);\n\n\tswitch (proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\taddr4 = be32_to_cpu(addr->addr4);\n\t\taddrp = &addr4;\n\t\taddr_len = 4;\n\t\taddr_prefix_len = 32;\n\t\tbreak;\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\taddrp = &addr->addr6;\n\t\taddr_len = 16;\n\t\taddr_prefix_len = 128;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\tfib_node = mlxsw_sp_fib_node_lookup(fib, addrp, addr_len,\n\t\t\t\t\t    addr_prefix_len);\n\tif (!fib_node || fib_node->fib_entry->type != type)\n\t\treturn NULL;\n\n\treturn fib_node->fib_entry;\n}\n\n \nstatic struct mlxsw_sp_fib_entry *\nmlxsw_sp_ipip_entry_find_decap(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_ipip_entry *ipip_entry)\n{\n\tstatic struct mlxsw_sp_fib_node *fib_node;\n\tconst struct mlxsw_sp_ipip_ops *ipip_ops;\n\tunsigned char saddr_prefix_len;\n\tunion mlxsw_sp_l3addr saddr;\n\tstruct mlxsw_sp_fib *ul_fib;\n\tstruct mlxsw_sp_vr *ul_vr;\n\tconst void *saddrp;\n\tsize_t saddr_len;\n\tu32 ul_tb_id;\n\tu32 saddr4;\n\n\tipip_ops = mlxsw_sp->router->ipip_ops_arr[ipip_entry->ipipt];\n\n\tul_tb_id = mlxsw_sp_ipip_dev_ul_tb_id(ipip_entry->ol_dev);\n\tul_vr = mlxsw_sp_vr_find(mlxsw_sp, ul_tb_id);\n\tif (!ul_vr)\n\t\treturn NULL;\n\n\tul_fib = mlxsw_sp_vr_fib(ul_vr, ipip_ops->ul_proto);\n\tsaddr = mlxsw_sp_ipip_netdev_saddr(ipip_ops->ul_proto,\n\t\t\t\t\t   ipip_entry->ol_dev);\n\n\tswitch (ipip_ops->ul_proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\tsaddr4 = be32_to_cpu(saddr.addr4);\n\t\tsaddrp = &saddr4;\n\t\tsaddr_len = 4;\n\t\tsaddr_prefix_len = 32;\n\t\tbreak;\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\tsaddrp = &saddr.addr6;\n\t\tsaddr_len = 16;\n\t\tsaddr_prefix_len = 128;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\tfib_node = mlxsw_sp_fib_node_lookup(ul_fib, saddrp, saddr_len,\n\t\t\t\t\t    saddr_prefix_len);\n\tif (!fib_node ||\n\t    fib_node->fib_entry->type != MLXSW_SP_FIB_ENTRY_TYPE_TRAP)\n\t\treturn NULL;\n\n\treturn fib_node->fib_entry;\n}\n\nstatic struct mlxsw_sp_ipip_entry *\nmlxsw_sp_ipip_entry_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   enum mlxsw_sp_ipip_type ipipt,\n\t\t\t   struct net_device *ol_dev)\n{\n\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\n\tipip_entry = mlxsw_sp_ipip_entry_alloc(mlxsw_sp, ipipt, ol_dev);\n\tif (IS_ERR(ipip_entry))\n\t\treturn ipip_entry;\n\n\tlist_add_tail(&ipip_entry->ipip_list_node,\n\t\t      &mlxsw_sp->router->ipip_list);\n\n\treturn ipip_entry;\n}\n\nstatic void\nmlxsw_sp_ipip_entry_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_ipip_entry *ipip_entry)\n{\n\tlist_del(&ipip_entry->ipip_list_node);\n\tmlxsw_sp_ipip_entry_dealloc(mlxsw_sp, ipip_entry);\n}\n\nstatic bool\nmlxsw_sp_ipip_entry_matches_decap(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  const struct net_device *ul_dev,\n\t\t\t\t  enum mlxsw_sp_l3proto ul_proto,\n\t\t\t\t  union mlxsw_sp_l3addr ul_dip,\n\t\t\t\t  struct mlxsw_sp_ipip_entry *ipip_entry)\n{\n\tu32 ul_tb_id = l3mdev_fib_table(ul_dev) ? : RT_TABLE_MAIN;\n\tenum mlxsw_sp_ipip_type ipipt = ipip_entry->ipipt;\n\n\tif (mlxsw_sp->router->ipip_ops_arr[ipipt]->ul_proto != ul_proto)\n\t\treturn false;\n\n\treturn mlxsw_sp_ipip_entry_saddr_matches(mlxsw_sp, ul_proto, ul_dip,\n\t\t\t\t\t\t ul_tb_id, ipip_entry);\n}\n\n \nstatic struct mlxsw_sp_ipip_entry *\nmlxsw_sp_ipip_entry_find_by_decap(struct mlxsw_sp *mlxsw_sp, int ul_dev_ifindex,\n\t\t\t\t  enum mlxsw_sp_l3proto ul_proto,\n\t\t\t\t  union mlxsw_sp_l3addr ul_dip)\n{\n\tstruct mlxsw_sp_ipip_entry *ipip_entry = NULL;\n\tstruct net_device *ul_dev;\n\n\trcu_read_lock();\n\n\tul_dev = dev_get_by_index_rcu(mlxsw_sp_net(mlxsw_sp), ul_dev_ifindex);\n\tif (!ul_dev)\n\t\tgoto out_unlock;\n\n\tlist_for_each_entry(ipip_entry, &mlxsw_sp->router->ipip_list,\n\t\t\t    ipip_list_node)\n\t\tif (mlxsw_sp_ipip_entry_matches_decap(mlxsw_sp, ul_dev,\n\t\t\t\t\t\t      ul_proto, ul_dip,\n\t\t\t\t\t\t      ipip_entry))\n\t\t\tgoto out_unlock;\n\n\trcu_read_unlock();\n\n\treturn NULL;\n\nout_unlock:\n\trcu_read_unlock();\n\treturn ipip_entry;\n}\n\nstatic bool mlxsw_sp_netdev_ipip_type(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      const struct net_device *dev,\n\t\t\t\t      enum mlxsw_sp_ipip_type *p_type)\n{\n\tstruct mlxsw_sp_router *router = mlxsw_sp->router;\n\tconst struct mlxsw_sp_ipip_ops *ipip_ops;\n\tenum mlxsw_sp_ipip_type ipipt;\n\n\tfor (ipipt = 0; ipipt < MLXSW_SP_IPIP_TYPE_MAX; ++ipipt) {\n\t\tipip_ops = router->ipip_ops_arr[ipipt];\n\t\tif (dev->type == ipip_ops->dev_type) {\n\t\t\tif (p_type)\n\t\t\t\t*p_type = ipipt;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool mlxsw_sp_netdev_is_ipip_ol(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       const struct net_device *dev)\n{\n\treturn mlxsw_sp_netdev_ipip_type(mlxsw_sp, dev, NULL);\n}\n\nstatic struct mlxsw_sp_ipip_entry *\nmlxsw_sp_ipip_entry_find_by_ol_dev(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   const struct net_device *ol_dev)\n{\n\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\n\tlist_for_each_entry(ipip_entry, &mlxsw_sp->router->ipip_list,\n\t\t\t    ipip_list_node)\n\t\tif (ipip_entry->ol_dev == ol_dev)\n\t\t\treturn ipip_entry;\n\n\treturn NULL;\n}\n\nstatic struct mlxsw_sp_ipip_entry *\nmlxsw_sp_ipip_entry_find_by_ul_dev(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   const struct net_device *ul_dev,\n\t\t\t\t   struct mlxsw_sp_ipip_entry *start)\n{\n\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\n\tipip_entry = list_prepare_entry(start, &mlxsw_sp->router->ipip_list,\n\t\t\t\t\tipip_list_node);\n\tlist_for_each_entry_continue(ipip_entry, &mlxsw_sp->router->ipip_list,\n\t\t\t\t     ipip_list_node) {\n\t\tstruct net_device *ol_dev = ipip_entry->ol_dev;\n\t\tstruct net_device *ipip_ul_dev;\n\n\t\trcu_read_lock();\n\t\tipip_ul_dev = mlxsw_sp_ipip_netdev_ul_dev_get(ol_dev);\n\t\trcu_read_unlock();\n\n\t\tif (ipip_ul_dev == ul_dev)\n\t\t\treturn ipip_entry;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool mlxsw_sp_netdev_is_ipip_ul(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       const struct net_device *dev)\n{\n\treturn mlxsw_sp_ipip_entry_find_by_ul_dev(mlxsw_sp, dev, NULL);\n}\n\nstatic bool mlxsw_sp_netdevice_ipip_can_offload(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tconst struct net_device *ol_dev,\n\t\t\t\t\t\tenum mlxsw_sp_ipip_type ipipt)\n{\n\tconst struct mlxsw_sp_ipip_ops *ops\n\t\t= mlxsw_sp->router->ipip_ops_arr[ipipt];\n\n\treturn ops->can_offload(mlxsw_sp, ol_dev);\n}\n\nstatic int mlxsw_sp_netdevice_ipip_ol_reg_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tstruct net_device *ol_dev)\n{\n\tenum mlxsw_sp_ipip_type ipipt = MLXSW_SP_IPIP_TYPE_MAX;\n\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\tenum mlxsw_sp_l3proto ul_proto;\n\tunion mlxsw_sp_l3addr saddr;\n\tu32 ul_tb_id;\n\n\tmlxsw_sp_netdev_ipip_type(mlxsw_sp, ol_dev, &ipipt);\n\tif (mlxsw_sp_netdevice_ipip_can_offload(mlxsw_sp, ol_dev, ipipt)) {\n\t\tul_tb_id = mlxsw_sp_ipip_dev_ul_tb_id(ol_dev);\n\t\tul_proto = mlxsw_sp->router->ipip_ops_arr[ipipt]->ul_proto;\n\t\tsaddr = mlxsw_sp_ipip_netdev_saddr(ul_proto, ol_dev);\n\t\tif (!mlxsw_sp_ipip_demote_tunnel_by_saddr(mlxsw_sp, ul_proto,\n\t\t\t\t\t\t\t  saddr, ul_tb_id,\n\t\t\t\t\t\t\t  NULL)) {\n\t\t\tipip_entry = mlxsw_sp_ipip_entry_create(mlxsw_sp, ipipt,\n\t\t\t\t\t\t\t\tol_dev);\n\t\t\tif (IS_ERR(ipip_entry))\n\t\t\t\treturn PTR_ERR(ipip_entry);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_netdevice_ipip_ol_unreg_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t   struct net_device *ol_dev)\n{\n\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\n\tipip_entry = mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);\n\tif (ipip_entry)\n\t\tmlxsw_sp_ipip_entry_destroy(mlxsw_sp, ipip_entry);\n}\n\nstatic void\nmlxsw_sp_ipip_entry_ol_up_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_ipip_entry *ipip_entry)\n{\n\tstruct mlxsw_sp_fib_entry *decap_fib_entry;\n\n\tdecap_fib_entry = mlxsw_sp_ipip_entry_find_decap(mlxsw_sp, ipip_entry);\n\tif (decap_fib_entry)\n\t\tmlxsw_sp_ipip_entry_promote_decap(mlxsw_sp, ipip_entry,\n\t\t\t\t\t\t  decap_fib_entry);\n}\n\nstatic int\nmlxsw_sp_rif_ipip_lb_op(struct mlxsw_sp_rif_ipip_lb *lb_rif, u16 ul_vr_id,\n\t\t\tu16 ul_rif_id, bool enable)\n{\n\tstruct mlxsw_sp_rif_ipip_lb_config lb_cf = lb_rif->lb_config;\n\tstruct net_device *dev = mlxsw_sp_rif_dev(&lb_rif->common);\n\tenum mlxsw_reg_ritr_loopback_ipip_options ipip_options;\n\tstruct mlxsw_sp_rif *rif = &lb_rif->common;\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tchar ritr_pl[MLXSW_REG_RITR_LEN];\n\tstruct in6_addr *saddr6;\n\tu32 saddr4;\n\n\tipip_options = MLXSW_REG_RITR_LOOPBACK_IPIP_OPTIONS_GRE_KEY_PRESET;\n\tswitch (lb_cf.ul_protocol) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\tsaddr4 = be32_to_cpu(lb_cf.saddr.addr4);\n\t\tmlxsw_reg_ritr_pack(ritr_pl, enable, MLXSW_REG_RITR_LOOPBACK_IF,\n\t\t\t\t    rif->rif_index, rif->vr_id, dev->mtu);\n\t\tmlxsw_reg_ritr_loopback_ipip4_pack(ritr_pl, lb_cf.lb_ipipt,\n\t\t\t\t\t\t   ipip_options, ul_vr_id,\n\t\t\t\t\t\t   ul_rif_id, saddr4,\n\t\t\t\t\t\t   lb_cf.okey);\n\t\tbreak;\n\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\tsaddr6 = &lb_cf.saddr.addr6;\n\t\tmlxsw_reg_ritr_pack(ritr_pl, enable, MLXSW_REG_RITR_LOOPBACK_IF,\n\t\t\t\t    rif->rif_index, rif->vr_id, dev->mtu);\n\t\tmlxsw_reg_ritr_loopback_ipip6_pack(ritr_pl, lb_cf.lb_ipipt,\n\t\t\t\t\t\t   ipip_options, ul_vr_id,\n\t\t\t\t\t\t   ul_rif_id, saddr6,\n\t\t\t\t\t\t   lb_cf.okey);\n\t\tbreak;\n\t}\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);\n}\n\nstatic int mlxsw_sp_netdevice_ipip_ol_update_mtu(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t struct net_device *ol_dev)\n{\n\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\tstruct mlxsw_sp_rif_ipip_lb *lb_rif;\n\tint err = 0;\n\n\tipip_entry = mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);\n\tif (ipip_entry) {\n\t\tlb_rif = ipip_entry->ol_lb;\n\t\terr = mlxsw_sp_rif_ipip_lb_op(lb_rif, lb_rif->ul_vr_id,\n\t\t\t\t\t      lb_rif->ul_rif_id, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tlb_rif->common.mtu = ol_dev->mtu;\n\t}\n\nout:\n\treturn err;\n}\n\nstatic void mlxsw_sp_netdevice_ipip_ol_up_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tstruct net_device *ol_dev)\n{\n\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\n\tipip_entry = mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);\n\tif (ipip_entry)\n\t\tmlxsw_sp_ipip_entry_ol_up_event(mlxsw_sp, ipip_entry);\n}\n\nstatic void\nmlxsw_sp_ipip_entry_ol_down_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_ipip_entry *ipip_entry)\n{\n\tif (ipip_entry->decap_fib_entry)\n\t\tmlxsw_sp_ipip_entry_demote_decap(mlxsw_sp, ipip_entry);\n}\n\nstatic void mlxsw_sp_netdevice_ipip_ol_down_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t  struct net_device *ol_dev)\n{\n\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\n\tipip_entry = mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);\n\tif (ipip_entry)\n\t\tmlxsw_sp_ipip_entry_ol_down_event(mlxsw_sp, ipip_entry);\n}\n\nstatic void mlxsw_sp_nexthop_rif_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_rif *rif);\n\nstatic void mlxsw_sp_rif_migrate_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t struct mlxsw_sp_rif *old_rif,\n\t\t\t\t\t struct mlxsw_sp_rif *new_rif,\n\t\t\t\t\t bool migrate_nhs)\n{\n\tstruct mlxsw_sp_crif *crif = old_rif->crif;\n\tstruct mlxsw_sp_crif mock_crif = {};\n\n\tif (migrate_nhs)\n\t\tmlxsw_sp_nexthop_rif_update(mlxsw_sp, new_rif);\n\n\t \n\tmlxsw_sp_crif_init(&mock_crif, crif->key.dev);\n\told_rif->crif = &mock_crif;\n\tmock_crif.rif = old_rif;\n\tmlxsw_sp_rif_destroy(old_rif);\n}\n\nstatic int\nmlxsw_sp_ipip_entry_ol_lb_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\t bool keep_encap,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_rif_ipip_lb *old_lb_rif = ipip_entry->ol_lb;\n\tstruct mlxsw_sp_rif_ipip_lb *new_lb_rif;\n\n\tnew_lb_rif = mlxsw_sp_ipip_ol_ipip_lb_create(mlxsw_sp,\n\t\t\t\t\t\t     ipip_entry->ipipt,\n\t\t\t\t\t\t     ipip_entry->ol_dev,\n\t\t\t\t\t\t     extack);\n\tif (IS_ERR(new_lb_rif))\n\t\treturn PTR_ERR(new_lb_rif);\n\tipip_entry->ol_lb = new_lb_rif;\n\n\tmlxsw_sp_rif_migrate_destroy(mlxsw_sp, &old_lb_rif->common,\n\t\t\t\t     &new_lb_rif->common, keep_encap);\n\treturn 0;\n}\n\n \nint __mlxsw_sp_ipip_entry_update_tunnel(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\t\tbool recreate_loopback,\n\t\t\t\t\tbool keep_encap,\n\t\t\t\t\tbool update_nexthops,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tint err;\n\n\t \n\tif (ipip_entry->decap_fib_entry)\n\t\tmlxsw_sp_ipip_entry_demote_decap(mlxsw_sp, ipip_entry);\n\n\tif (recreate_loopback) {\n\t\terr = mlxsw_sp_ipip_entry_ol_lb_update(mlxsw_sp, ipip_entry,\n\t\t\t\t\t\t       keep_encap, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (update_nexthops) {\n\t\tmlxsw_sp_nexthop_rif_update(mlxsw_sp,\n\t\t\t\t\t    &ipip_entry->ol_lb->common);\n\t}\n\n\tif (ipip_entry->ol_dev->flags & IFF_UP)\n\t\tmlxsw_sp_ipip_entry_ol_up_event(mlxsw_sp, ipip_entry);\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_netdevice_ipip_ol_vrf_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tstruct net_device *ol_dev,\n\t\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_ipip_entry *ipip_entry =\n\t\tmlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);\n\n\tif (!ipip_entry)\n\t\treturn 0;\n\n\treturn __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,\n\t\t\t\t\t\t   true, false, false, extack);\n}\n\nstatic int\nmlxsw_sp_netdevice_ipip_ul_vrf_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\t     struct net_device *ul_dev,\n\t\t\t\t     bool *demote_this,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tu32 ul_tb_id = l3mdev_fib_table(ul_dev) ? : RT_TABLE_MAIN;\n\tenum mlxsw_sp_l3proto ul_proto;\n\tunion mlxsw_sp_l3addr saddr;\n\n\t \n\tul_proto = mlxsw_sp->router->ipip_ops_arr[ipip_entry->ipipt]->ul_proto;\n\tsaddr = mlxsw_sp_ipip_netdev_saddr(ul_proto, ipip_entry->ol_dev);\n\tif (mlxsw_sp_ipip_demote_tunnel_by_saddr(mlxsw_sp, ul_proto,\n\t\t\t\t\t\t saddr, ul_tb_id,\n\t\t\t\t\t\t ipip_entry)) {\n\t\t*demote_this = true;\n\t\treturn 0;\n\t}\n\n\treturn __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,\n\t\t\t\t\t\t   true, true, false, extack);\n}\n\nstatic int\nmlxsw_sp_netdevice_ipip_ul_up_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\t    struct net_device *ul_dev)\n{\n\treturn __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,\n\t\t\t\t\t\t   false, false, true, NULL);\n}\n\nstatic int\nmlxsw_sp_netdevice_ipip_ul_down_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\t      struct net_device *ul_dev)\n{\n\t \n\treturn __mlxsw_sp_ipip_entry_update_tunnel(mlxsw_sp, ipip_entry,\n\t\t\t\t\t\t   false, false, true, NULL);\n}\n\nstatic int\nmlxsw_sp_netdevice_ipip_ol_change_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct net_device *ol_dev,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst struct mlxsw_sp_ipip_ops *ipip_ops;\n\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\tint err;\n\n\tipip_entry = mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, ol_dev);\n\tif (!ipip_entry)\n\t\t \n\t\treturn 0;\n\n\t \n\tif (!mlxsw_sp_netdevice_ipip_can_offload(mlxsw_sp, ol_dev,\n\t\t\t\t\t\t ipip_entry->ipipt)) {\n\t\tmlxsw_sp_ipip_entry_demote_tunnel(mlxsw_sp, ipip_entry);\n\t\treturn 0;\n\t}\n\n\tipip_ops = mlxsw_sp->router->ipip_ops_arr[ipip_entry->ipipt];\n\terr = ipip_ops->ol_netdev_change(mlxsw_sp, ipip_entry, extack);\n\treturn err;\n}\n\nvoid mlxsw_sp_ipip_entry_demote_tunnel(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_ipip_entry *ipip_entry)\n{\n\tstruct net_device *ol_dev = ipip_entry->ol_dev;\n\n\tif (ol_dev->flags & IFF_UP)\n\t\tmlxsw_sp_ipip_entry_ol_down_event(mlxsw_sp, ipip_entry);\n\tmlxsw_sp_ipip_entry_destroy(mlxsw_sp, ipip_entry);\n}\n\n \nbool\nmlxsw_sp_ipip_demote_tunnel_by_saddr(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     enum mlxsw_sp_l3proto ul_proto,\n\t\t\t\t     union mlxsw_sp_l3addr saddr,\n\t\t\t\t     u32 ul_tb_id,\n\t\t\t\t     const struct mlxsw_sp_ipip_entry *except)\n{\n\tstruct mlxsw_sp_ipip_entry *ipip_entry, *tmp;\n\n\tlist_for_each_entry_safe(ipip_entry, tmp, &mlxsw_sp->router->ipip_list,\n\t\t\t\t ipip_list_node) {\n\t\tif (ipip_entry != except &&\n\t\t    mlxsw_sp_ipip_entry_saddr_matches(mlxsw_sp, ul_proto, saddr,\n\t\t\t\t\t\t      ul_tb_id, ipip_entry)) {\n\t\t\tmlxsw_sp_ipip_entry_demote_tunnel(mlxsw_sp, ipip_entry);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic void mlxsw_sp_ipip_demote_tunnel_by_ul_netdev(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t     struct net_device *ul_dev)\n{\n\tstruct mlxsw_sp_ipip_entry *ipip_entry, *tmp;\n\n\tlist_for_each_entry_safe(ipip_entry, tmp, &mlxsw_sp->router->ipip_list,\n\t\t\t\t ipip_list_node) {\n\t\tstruct net_device *ol_dev = ipip_entry->ol_dev;\n\t\tstruct net_device *ipip_ul_dev;\n\n\t\trcu_read_lock();\n\t\tipip_ul_dev = mlxsw_sp_ipip_netdev_ul_dev_get(ol_dev);\n\t\trcu_read_unlock();\n\t\tif (ipip_ul_dev == ul_dev)\n\t\t\tmlxsw_sp_ipip_entry_demote_tunnel(mlxsw_sp, ipip_entry);\n\t}\n}\n\nstatic int mlxsw_sp_netdevice_ipip_ol_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    struct net_device *ol_dev,\n\t\t\t\t\t    unsigned long event,\n\t\t\t\t\t    struct netdev_notifier_info *info)\n{\n\tstruct netdev_notifier_changeupper_info *chup;\n\tstruct netlink_ext_ack *extack;\n\tint err = 0;\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\terr = mlxsw_sp_netdevice_ipip_ol_reg_event(mlxsw_sp, ol_dev);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\tmlxsw_sp_netdevice_ipip_ol_unreg_event(mlxsw_sp, ol_dev);\n\t\tbreak;\n\tcase NETDEV_UP:\n\t\tmlxsw_sp_netdevice_ipip_ol_up_event(mlxsw_sp, ol_dev);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tmlxsw_sp_netdevice_ipip_ol_down_event(mlxsw_sp, ol_dev);\n\t\tbreak;\n\tcase NETDEV_CHANGEUPPER:\n\t\tchup = container_of(info, typeof(*chup), info);\n\t\textack = info->extack;\n\t\tif (netif_is_l3_master(chup->upper_dev))\n\t\t\terr = mlxsw_sp_netdevice_ipip_ol_vrf_event(mlxsw_sp,\n\t\t\t\t\t\t\t\t   ol_dev,\n\t\t\t\t\t\t\t\t   extack);\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\textack = info->extack;\n\t\terr = mlxsw_sp_netdevice_ipip_ol_change_event(mlxsw_sp,\n\t\t\t\t\t\t\t      ol_dev, extack);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\terr = mlxsw_sp_netdevice_ipip_ol_update_mtu(mlxsw_sp, ol_dev);\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic int\n__mlxsw_sp_netdevice_ipip_ul_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_ipip_entry *ipip_entry,\n\t\t\t\t   struct net_device *ul_dev,\n\t\t\t\t   bool *demote_this,\n\t\t\t\t   unsigned long event,\n\t\t\t\t   struct netdev_notifier_info *info)\n{\n\tstruct netdev_notifier_changeupper_info *chup;\n\tstruct netlink_ext_ack *extack;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGEUPPER:\n\t\tchup = container_of(info, typeof(*chup), info);\n\t\textack = info->extack;\n\t\tif (netif_is_l3_master(chup->upper_dev))\n\t\t\treturn mlxsw_sp_netdevice_ipip_ul_vrf_event(mlxsw_sp,\n\t\t\t\t\t\t\t\t    ipip_entry,\n\t\t\t\t\t\t\t\t    ul_dev,\n\t\t\t\t\t\t\t\t    demote_this,\n\t\t\t\t\t\t\t\t    extack);\n\t\tbreak;\n\n\tcase NETDEV_UP:\n\t\treturn mlxsw_sp_netdevice_ipip_ul_up_event(mlxsw_sp, ipip_entry,\n\t\t\t\t\t\t\t   ul_dev);\n\tcase NETDEV_DOWN:\n\t\treturn mlxsw_sp_netdevice_ipip_ul_down_event(mlxsw_sp,\n\t\t\t\t\t\t\t     ipip_entry,\n\t\t\t\t\t\t\t     ul_dev);\n\t}\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_netdevice_ipip_ul_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct net_device *ul_dev,\n\t\t\t\t unsigned long event,\n\t\t\t\t struct netdev_notifier_info *info)\n{\n\tstruct mlxsw_sp_ipip_entry *ipip_entry = NULL;\n\tint err;\n\n\twhile ((ipip_entry = mlxsw_sp_ipip_entry_find_by_ul_dev(mlxsw_sp,\n\t\t\t\t\t\t\t\tul_dev,\n\t\t\t\t\t\t\t\tipip_entry))) {\n\t\tstruct mlxsw_sp_ipip_entry *prev;\n\t\tbool demote_this = false;\n\n\t\terr = __mlxsw_sp_netdevice_ipip_ul_event(mlxsw_sp, ipip_entry,\n\t\t\t\t\t\t\t ul_dev, &demote_this,\n\t\t\t\t\t\t\t event, info);\n\t\tif (err) {\n\t\t\tmlxsw_sp_ipip_demote_tunnel_by_ul_netdev(mlxsw_sp,\n\t\t\t\t\t\t\t\t ul_dev);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (demote_this) {\n\t\t\tif (list_is_first(&ipip_entry->ipip_list_node,\n\t\t\t\t\t  &mlxsw_sp->router->ipip_list))\n\t\t\t\tprev = NULL;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tprev = list_prev_entry(ipip_entry,\n\t\t\t\t\t\t       ipip_list_node);\n\t\t\tmlxsw_sp_ipip_entry_demote_tunnel(mlxsw_sp, ipip_entry);\n\t\t\tipip_entry = prev;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint mlxsw_sp_router_nve_promote_decap(struct mlxsw_sp *mlxsw_sp, u32 ul_tb_id,\n\t\t\t\t      enum mlxsw_sp_l3proto ul_proto,\n\t\t\t\t      const union mlxsw_sp_l3addr *ul_sip,\n\t\t\t\t      u32 tunnel_index)\n{\n\tenum mlxsw_sp_fib_entry_type type = MLXSW_SP_FIB_ENTRY_TYPE_TRAP;\n\tstruct mlxsw_sp_router *router = mlxsw_sp->router;\n\tstruct mlxsw_sp_fib_entry *fib_entry;\n\tint err = 0;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\n\tif (WARN_ON_ONCE(router->nve_decap_config.valid)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trouter->nve_decap_config.ul_tb_id = ul_tb_id;\n\trouter->nve_decap_config.tunnel_index = tunnel_index;\n\trouter->nve_decap_config.ul_proto = ul_proto;\n\trouter->nve_decap_config.ul_sip = *ul_sip;\n\trouter->nve_decap_config.valid = true;\n\n\t \n\tfib_entry = mlxsw_sp_router_ip2me_fib_entry_find(mlxsw_sp, ul_tb_id,\n\t\t\t\t\t\t\t ul_proto, ul_sip,\n\t\t\t\t\t\t\t type);\n\tif (!fib_entry)\n\t\tgoto out;\n\n\tfib_entry->decap.tunnel_index = tunnel_index;\n\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_NVE_DECAP;\n\n\terr = mlxsw_sp_fib_entry_update(mlxsw_sp, fib_entry);\n\tif (err)\n\t\tgoto err_fib_entry_update;\n\n\tgoto out;\n\nerr_fib_entry_update:\n\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_TRAP;\n\tmlxsw_sp_fib_entry_update(mlxsw_sp, fib_entry);\nout:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\treturn err;\n}\n\nvoid mlxsw_sp_router_nve_demote_decap(struct mlxsw_sp *mlxsw_sp, u32 ul_tb_id,\n\t\t\t\t      enum mlxsw_sp_l3proto ul_proto,\n\t\t\t\t      const union mlxsw_sp_l3addr *ul_sip)\n{\n\tenum mlxsw_sp_fib_entry_type type = MLXSW_SP_FIB_ENTRY_TYPE_NVE_DECAP;\n\tstruct mlxsw_sp_router *router = mlxsw_sp->router;\n\tstruct mlxsw_sp_fib_entry *fib_entry;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\n\tif (WARN_ON_ONCE(!router->nve_decap_config.valid))\n\t\tgoto out;\n\n\trouter->nve_decap_config.valid = false;\n\n\tfib_entry = mlxsw_sp_router_ip2me_fib_entry_find(mlxsw_sp, ul_tb_id,\n\t\t\t\t\t\t\t ul_proto, ul_sip,\n\t\t\t\t\t\t\t type);\n\tif (!fib_entry)\n\t\tgoto out;\n\n\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_TRAP;\n\tmlxsw_sp_fib_entry_update(mlxsw_sp, fib_entry);\nout:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n}\n\nstatic bool mlxsw_sp_router_nve_is_decap(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t u32 ul_tb_id,\n\t\t\t\t\t enum mlxsw_sp_l3proto ul_proto,\n\t\t\t\t\t const union mlxsw_sp_l3addr *ul_sip)\n{\n\tstruct mlxsw_sp_router *router = mlxsw_sp->router;\n\n\treturn router->nve_decap_config.valid &&\n\t       router->nve_decap_config.ul_tb_id == ul_tb_id &&\n\t       router->nve_decap_config.ul_proto == ul_proto &&\n\t       !memcmp(&router->nve_decap_config.ul_sip, ul_sip,\n\t\t       sizeof(*ul_sip));\n}\n\nstruct mlxsw_sp_neigh_key {\n\tstruct neighbour *n;\n};\n\nstruct mlxsw_sp_neigh_entry {\n\tstruct list_head rif_list_node;\n\tstruct rhash_head ht_node;\n\tstruct mlxsw_sp_neigh_key key;\n\tu16 rif;\n\tbool connected;\n\tunsigned char ha[ETH_ALEN];\n\tstruct list_head nexthop_list;  \n\tstruct list_head nexthop_neighs_list_node;\n\tunsigned int counter_index;\n\tbool counter_valid;\n};\n\nstatic const struct rhashtable_params mlxsw_sp_neigh_ht_params = {\n\t.key_offset = offsetof(struct mlxsw_sp_neigh_entry, key),\n\t.head_offset = offsetof(struct mlxsw_sp_neigh_entry, ht_node),\n\t.key_len = sizeof(struct mlxsw_sp_neigh_key),\n};\n\nstruct mlxsw_sp_neigh_entry *\nmlxsw_sp_rif_neigh_next(struct mlxsw_sp_rif *rif,\n\t\t\tstruct mlxsw_sp_neigh_entry *neigh_entry)\n{\n\tif (!neigh_entry) {\n\t\tif (list_empty(&rif->neigh_list))\n\t\t\treturn NULL;\n\t\telse\n\t\t\treturn list_first_entry(&rif->neigh_list,\n\t\t\t\t\t\ttypeof(*neigh_entry),\n\t\t\t\t\t\trif_list_node);\n\t}\n\tif (list_is_last(&neigh_entry->rif_list_node, &rif->neigh_list))\n\t\treturn NULL;\n\treturn list_next_entry(neigh_entry, rif_list_node);\n}\n\nint mlxsw_sp_neigh_entry_type(struct mlxsw_sp_neigh_entry *neigh_entry)\n{\n\treturn neigh_entry->key.n->tbl->family;\n}\n\nunsigned char *\nmlxsw_sp_neigh_entry_ha(struct mlxsw_sp_neigh_entry *neigh_entry)\n{\n\treturn neigh_entry->ha;\n}\n\nu32 mlxsw_sp_neigh4_entry_dip(struct mlxsw_sp_neigh_entry *neigh_entry)\n{\n\tstruct neighbour *n;\n\n\tn = neigh_entry->key.n;\n\treturn ntohl(*((__be32 *) n->primary_key));\n}\n\nstruct in6_addr *\nmlxsw_sp_neigh6_entry_dip(struct mlxsw_sp_neigh_entry *neigh_entry)\n{\n\tstruct neighbour *n;\n\n\tn = neigh_entry->key.n;\n\treturn (struct in6_addr *) &n->primary_key;\n}\n\nint mlxsw_sp_neigh_counter_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_neigh_entry *neigh_entry,\n\t\t\t       u64 *p_counter)\n{\n\tif (!neigh_entry->counter_valid)\n\t\treturn -EINVAL;\n\n\treturn mlxsw_sp_flow_counter_get(mlxsw_sp, neigh_entry->counter_index,\n\t\t\t\t\t p_counter, NULL);\n}\n\nstatic struct mlxsw_sp_neigh_entry *\nmlxsw_sp_neigh_entry_alloc(struct mlxsw_sp *mlxsw_sp, struct neighbour *n,\n\t\t\t   u16 rif)\n{\n\tstruct mlxsw_sp_neigh_entry *neigh_entry;\n\n\tneigh_entry = kzalloc(sizeof(*neigh_entry), GFP_KERNEL);\n\tif (!neigh_entry)\n\t\treturn NULL;\n\n\tneigh_entry->key.n = n;\n\tneigh_entry->rif = rif;\n\tINIT_LIST_HEAD(&neigh_entry->nexthop_list);\n\n\treturn neigh_entry;\n}\n\nstatic void mlxsw_sp_neigh_entry_free(struct mlxsw_sp_neigh_entry *neigh_entry)\n{\n\tkfree(neigh_entry);\n}\n\nstatic int\nmlxsw_sp_neigh_entry_insert(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_neigh_entry *neigh_entry)\n{\n\treturn rhashtable_insert_fast(&mlxsw_sp->router->neigh_ht,\n\t\t\t\t      &neigh_entry->ht_node,\n\t\t\t\t      mlxsw_sp_neigh_ht_params);\n}\n\nstatic void\nmlxsw_sp_neigh_entry_remove(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_neigh_entry *neigh_entry)\n{\n\trhashtable_remove_fast(&mlxsw_sp->router->neigh_ht,\n\t\t\t       &neigh_entry->ht_node,\n\t\t\t       mlxsw_sp_neigh_ht_params);\n}\n\nstatic bool\nmlxsw_sp_neigh_counter_should_alloc(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_neigh_entry *neigh_entry)\n{\n\tstruct devlink *devlink;\n\tconst char *table_name;\n\n\tswitch (mlxsw_sp_neigh_entry_type(neigh_entry)) {\n\tcase AF_INET:\n\t\ttable_name = MLXSW_SP_DPIPE_TABLE_NAME_HOST4;\n\t\tbreak;\n\tcase AF_INET6:\n\t\ttable_name = MLXSW_SP_DPIPE_TABLE_NAME_HOST6;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\n\tdevlink = priv_to_devlink(mlxsw_sp->core);\n\treturn devlink_dpipe_table_counter_enabled(devlink, table_name);\n}\n\nstatic void\nmlxsw_sp_neigh_counter_alloc(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     struct mlxsw_sp_neigh_entry *neigh_entry)\n{\n\tif (!mlxsw_sp_neigh_counter_should_alloc(mlxsw_sp, neigh_entry))\n\t\treturn;\n\n\tif (mlxsw_sp_flow_counter_alloc(mlxsw_sp, &neigh_entry->counter_index))\n\t\treturn;\n\n\tneigh_entry->counter_valid = true;\n}\n\nstatic void\nmlxsw_sp_neigh_counter_free(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_neigh_entry *neigh_entry)\n{\n\tif (!neigh_entry->counter_valid)\n\t\treturn;\n\tmlxsw_sp_flow_counter_free(mlxsw_sp,\n\t\t\t\t   neigh_entry->counter_index);\n\tneigh_entry->counter_valid = false;\n}\n\nstatic struct mlxsw_sp_neigh_entry *\nmlxsw_sp_neigh_entry_create(struct mlxsw_sp *mlxsw_sp, struct neighbour *n)\n{\n\tstruct mlxsw_sp_neigh_entry *neigh_entry;\n\tstruct mlxsw_sp_rif *rif;\n\tint err;\n\n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, n->dev);\n\tif (!rif)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tneigh_entry = mlxsw_sp_neigh_entry_alloc(mlxsw_sp, n, rif->rif_index);\n\tif (!neigh_entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = mlxsw_sp_neigh_entry_insert(mlxsw_sp, neigh_entry);\n\tif (err)\n\t\tgoto err_neigh_entry_insert;\n\n\tmlxsw_sp_neigh_counter_alloc(mlxsw_sp, neigh_entry);\n\tatomic_inc(&mlxsw_sp->router->neighs_update.neigh_count);\n\tlist_add(&neigh_entry->rif_list_node, &rif->neigh_list);\n\n\treturn neigh_entry;\n\nerr_neigh_entry_insert:\n\tmlxsw_sp_neigh_entry_free(neigh_entry);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_neigh_entry_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     struct mlxsw_sp_neigh_entry *neigh_entry)\n{\n\tlist_del(&neigh_entry->rif_list_node);\n\tatomic_dec(&mlxsw_sp->router->neighs_update.neigh_count);\n\tmlxsw_sp_neigh_counter_free(mlxsw_sp, neigh_entry);\n\tmlxsw_sp_neigh_entry_remove(mlxsw_sp, neigh_entry);\n\tmlxsw_sp_neigh_entry_free(neigh_entry);\n}\n\nstatic struct mlxsw_sp_neigh_entry *\nmlxsw_sp_neigh_entry_lookup(struct mlxsw_sp *mlxsw_sp, struct neighbour *n)\n{\n\tstruct mlxsw_sp_neigh_key key;\n\n\tkey.n = n;\n\treturn rhashtable_lookup_fast(&mlxsw_sp->router->neigh_ht,\n\t\t\t\t      &key, mlxsw_sp_neigh_ht_params);\n}\n\nstatic void\nmlxsw_sp_router_neighs_update_interval_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tunsigned long interval;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tinterval = min_t(unsigned long,\n\t\t\t NEIGH_VAR(&arp_tbl.parms, DELAY_PROBE_TIME),\n\t\t\t NEIGH_VAR(&nd_tbl.parms, DELAY_PROBE_TIME));\n#else\n\tinterval = NEIGH_VAR(&arp_tbl.parms, DELAY_PROBE_TIME);\n#endif\n\tmlxsw_sp->router->neighs_update.interval = jiffies_to_msecs(interval);\n}\n\nstatic void mlxsw_sp_router_neigh_ent_ipv4_process(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t   char *rauhtd_pl,\n\t\t\t\t\t\t   int ent_index)\n{\n\tu64 max_rifs = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS);\n\tstruct net_device *dev;\n\tstruct neighbour *n;\n\t__be32 dipn;\n\tu32 dip;\n\tu16 rif;\n\n\tmlxsw_reg_rauhtd_ent_ipv4_unpack(rauhtd_pl, ent_index, &rif, &dip);\n\n\tif (WARN_ON_ONCE(rif >= max_rifs))\n\t\treturn;\n\tif (!mlxsw_sp->router->rifs[rif]) {\n\t\tdev_err_ratelimited(mlxsw_sp->bus_info->dev, \"Incorrect RIF in neighbour entry\\n\");\n\t\treturn;\n\t}\n\n\tdipn = htonl(dip);\n\tdev = mlxsw_sp_rif_dev(mlxsw_sp->router->rifs[rif]);\n\tn = neigh_lookup(&arp_tbl, &dipn, dev);\n\tif (!n)\n\t\treturn;\n\n\tnetdev_dbg(dev, \"Updating neighbour with IP=%pI4h\\n\", &dip);\n\tneigh_event_send(n, NULL);\n\tneigh_release(n);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void mlxsw_sp_router_neigh_ent_ipv6_process(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t   char *rauhtd_pl,\n\t\t\t\t\t\t   int rec_index)\n{\n\tstruct net_device *dev;\n\tstruct neighbour *n;\n\tstruct in6_addr dip;\n\tu16 rif;\n\n\tmlxsw_reg_rauhtd_ent_ipv6_unpack(rauhtd_pl, rec_index, &rif,\n\t\t\t\t\t (char *) &dip);\n\n\tif (!mlxsw_sp->router->rifs[rif]) {\n\t\tdev_err_ratelimited(mlxsw_sp->bus_info->dev, \"Incorrect RIF in neighbour entry\\n\");\n\t\treturn;\n\t}\n\n\tdev = mlxsw_sp_rif_dev(mlxsw_sp->router->rifs[rif]);\n\tn = neigh_lookup(&nd_tbl, &dip, dev);\n\tif (!n)\n\t\treturn;\n\n\tnetdev_dbg(dev, \"Updating neighbour with IP=%pI6c\\n\", &dip);\n\tneigh_event_send(n, NULL);\n\tneigh_release(n);\n}\n#else\nstatic void mlxsw_sp_router_neigh_ent_ipv6_process(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t   char *rauhtd_pl,\n\t\t\t\t\t\t   int rec_index)\n{\n}\n#endif\n\nstatic void mlxsw_sp_router_neigh_rec_ipv4_process(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t   char *rauhtd_pl,\n\t\t\t\t\t\t   int rec_index)\n{\n\tu8 num_entries;\n\tint i;\n\n\tnum_entries = mlxsw_reg_rauhtd_ipv4_rec_num_entries_get(rauhtd_pl,\n\t\t\t\t\t\t\t\trec_index);\n\t \n\tnum_entries++;\n\n\t \n\tfor (i = 0; i < num_entries; i++) {\n\t\tint ent_index;\n\n\t\tent_index = rec_index * MLXSW_REG_RAUHTD_IPV4_ENT_PER_REC + i;\n\t\tmlxsw_sp_router_neigh_ent_ipv4_process(mlxsw_sp, rauhtd_pl,\n\t\t\t\t\t\t       ent_index);\n\t}\n\n}\n\nstatic void mlxsw_sp_router_neigh_rec_ipv6_process(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t   char *rauhtd_pl,\n\t\t\t\t\t\t   int rec_index)\n{\n\t \n\tmlxsw_sp_router_neigh_ent_ipv6_process(mlxsw_sp, rauhtd_pl,\n\t\t\t\t\t       rec_index);\n}\n\nstatic void mlxsw_sp_router_neigh_rec_process(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t      char *rauhtd_pl, int rec_index)\n{\n\tswitch (mlxsw_reg_rauhtd_rec_type_get(rauhtd_pl, rec_index)) {\n\tcase MLXSW_REG_RAUHTD_TYPE_IPV4:\n\t\tmlxsw_sp_router_neigh_rec_ipv4_process(mlxsw_sp, rauhtd_pl,\n\t\t\t\t\t\t       rec_index);\n\t\tbreak;\n\tcase MLXSW_REG_RAUHTD_TYPE_IPV6:\n\t\tmlxsw_sp_router_neigh_rec_ipv6_process(mlxsw_sp, rauhtd_pl,\n\t\t\t\t\t\t       rec_index);\n\t\tbreak;\n\t}\n}\n\nstatic bool mlxsw_sp_router_rauhtd_is_full(char *rauhtd_pl)\n{\n\tu8 num_rec, last_rec_index, num_entries;\n\n\tnum_rec = mlxsw_reg_rauhtd_num_rec_get(rauhtd_pl);\n\tlast_rec_index = num_rec - 1;\n\n\tif (num_rec < MLXSW_REG_RAUHTD_REC_MAX_NUM)\n\t\treturn false;\n\tif (mlxsw_reg_rauhtd_rec_type_get(rauhtd_pl, last_rec_index) ==\n\t    MLXSW_REG_RAUHTD_TYPE_IPV6)\n\t\treturn true;\n\n\tnum_entries = mlxsw_reg_rauhtd_ipv4_rec_num_entries_get(rauhtd_pl,\n\t\t\t\t\t\t\t\tlast_rec_index);\n\tif (++num_entries == MLXSW_REG_RAUHTD_IPV4_ENT_PER_REC)\n\t\treturn true;\n\treturn false;\n}\n\nstatic int\n__mlxsw_sp_router_neighs_update_rauhtd(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       char *rauhtd_pl,\n\t\t\t\t       enum mlxsw_reg_rauhtd_type type)\n{\n\tint i, num_rec;\n\tint err;\n\n\t \n\tmutex_lock(&mlxsw_sp->router->lock);\n\tdo {\n\t\tmlxsw_reg_rauhtd_pack(rauhtd_pl, type);\n\t\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(rauhtd),\n\t\t\t\t      rauhtd_pl);\n\t\tif (err) {\n\t\t\tdev_err_ratelimited(mlxsw_sp->bus_info->dev, \"Failed to dump neighbour table\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tnum_rec = mlxsw_reg_rauhtd_num_rec_get(rauhtd_pl);\n\t\tfor (i = 0; i < num_rec; i++)\n\t\t\tmlxsw_sp_router_neigh_rec_process(mlxsw_sp, rauhtd_pl,\n\t\t\t\t\t\t\t  i);\n\t} while (mlxsw_sp_router_rauhtd_is_full(rauhtd_pl));\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\n\treturn err;\n}\n\nstatic int mlxsw_sp_router_neighs_update_rauhtd(struct mlxsw_sp *mlxsw_sp)\n{\n\tenum mlxsw_reg_rauhtd_type type;\n\tchar *rauhtd_pl;\n\tint err;\n\n\tif (!atomic_read(&mlxsw_sp->router->neighs_update.neigh_count))\n\t\treturn 0;\n\n\trauhtd_pl = kmalloc(MLXSW_REG_RAUHTD_LEN, GFP_KERNEL);\n\tif (!rauhtd_pl)\n\t\treturn -ENOMEM;\n\n\ttype = MLXSW_REG_RAUHTD_TYPE_IPV4;\n\terr = __mlxsw_sp_router_neighs_update_rauhtd(mlxsw_sp, rauhtd_pl, type);\n\tif (err)\n\t\tgoto out;\n\n\ttype = MLXSW_REG_RAUHTD_TYPE_IPV6;\n\terr = __mlxsw_sp_router_neighs_update_rauhtd(mlxsw_sp, rauhtd_pl, type);\nout:\n\tkfree(rauhtd_pl);\n\treturn err;\n}\n\nstatic void mlxsw_sp_router_neighs_update_nh(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_neigh_entry *neigh_entry;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\tlist_for_each_entry(neigh_entry, &mlxsw_sp->router->nexthop_neighs_list,\n\t\t\t    nexthop_neighs_list_node)\n\t\t \n\t\tneigh_event_send(neigh_entry->key.n, NULL);\n\tmutex_unlock(&mlxsw_sp->router->lock);\n}\n\nstatic void\nmlxsw_sp_router_neighs_update_work_schedule(struct mlxsw_sp *mlxsw_sp)\n{\n\tunsigned long interval = mlxsw_sp->router->neighs_update.interval;\n\n\tmlxsw_core_schedule_dw(&mlxsw_sp->router->neighs_update.dw,\n\t\t\t       msecs_to_jiffies(interval));\n}\n\nstatic void mlxsw_sp_router_neighs_update_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_router *router;\n\tint err;\n\n\trouter = container_of(work, struct mlxsw_sp_router,\n\t\t\t      neighs_update.dw.work);\n\terr = mlxsw_sp_router_neighs_update_rauhtd(router->mlxsw_sp);\n\tif (err)\n\t\tdev_err(router->mlxsw_sp->bus_info->dev, \"Could not update kernel for neigh activity\");\n\n\tmlxsw_sp_router_neighs_update_nh(router->mlxsw_sp);\n\n\tmlxsw_sp_router_neighs_update_work_schedule(router->mlxsw_sp);\n}\n\nstatic void mlxsw_sp_router_probe_unresolved_nexthops(struct work_struct *work)\n{\n\tstruct mlxsw_sp_neigh_entry *neigh_entry;\n\tstruct mlxsw_sp_router *router;\n\n\trouter = container_of(work, struct mlxsw_sp_router,\n\t\t\t      nexthop_probe_dw.work);\n\t \n\tmutex_lock(&router->lock);\n\tlist_for_each_entry(neigh_entry, &router->nexthop_neighs_list,\n\t\t\t    nexthop_neighs_list_node)\n\t\tif (!neigh_entry->connected)\n\t\t\tneigh_event_send(neigh_entry->key.n, NULL);\n\tmutex_unlock(&router->lock);\n\n\tmlxsw_core_schedule_dw(&router->nexthop_probe_dw,\n\t\t\t       MLXSW_SP_UNRESOLVED_NH_PROBE_INTERVAL);\n}\n\nstatic void\nmlxsw_sp_nexthop_neigh_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_neigh_entry *neigh_entry,\n\t\t\t      bool removing, bool dead);\n\nstatic enum mlxsw_reg_rauht_op mlxsw_sp_rauht_op(bool adding)\n{\n\treturn adding ? MLXSW_REG_RAUHT_OP_WRITE_ADD :\n\t\t\tMLXSW_REG_RAUHT_OP_WRITE_DELETE;\n}\n\nstatic int\nmlxsw_sp_router_neigh_entry_op4(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_neigh_entry *neigh_entry,\n\t\t\t\tenum mlxsw_reg_rauht_op op)\n{\n\tstruct neighbour *n = neigh_entry->key.n;\n\tu32 dip = ntohl(*((__be32 *) n->primary_key));\n\tchar rauht_pl[MLXSW_REG_RAUHT_LEN];\n\n\tmlxsw_reg_rauht_pack4(rauht_pl, op, neigh_entry->rif, neigh_entry->ha,\n\t\t\t      dip);\n\tif (neigh_entry->counter_valid)\n\t\tmlxsw_reg_rauht_pack_counter(rauht_pl,\n\t\t\t\t\t     neigh_entry->counter_index);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rauht), rauht_pl);\n}\n\nstatic int\nmlxsw_sp_router_neigh_entry_op6(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_neigh_entry *neigh_entry,\n\t\t\t\tenum mlxsw_reg_rauht_op op)\n{\n\tstruct neighbour *n = neigh_entry->key.n;\n\tchar rauht_pl[MLXSW_REG_RAUHT_LEN];\n\tconst char *dip = n->primary_key;\n\n\tmlxsw_reg_rauht_pack6(rauht_pl, op, neigh_entry->rif, neigh_entry->ha,\n\t\t\t      dip);\n\tif (neigh_entry->counter_valid)\n\t\tmlxsw_reg_rauht_pack_counter(rauht_pl,\n\t\t\t\t\t     neigh_entry->counter_index);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rauht), rauht_pl);\n}\n\nbool mlxsw_sp_neigh_ipv6_ignore(struct mlxsw_sp_neigh_entry *neigh_entry)\n{\n\tstruct neighbour *n = neigh_entry->key.n;\n\n\t \n\tif (ipv6_addr_type((struct in6_addr *) &n->primary_key) &\n\t    IPV6_ADDR_LINKLOCAL)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void\nmlxsw_sp_neigh_entry_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_neigh_entry *neigh_entry,\n\t\t\t    bool adding)\n{\n\tenum mlxsw_reg_rauht_op op = mlxsw_sp_rauht_op(adding);\n\tint err;\n\n\tif (!adding && !neigh_entry->connected)\n\t\treturn;\n\tneigh_entry->connected = adding;\n\tif (neigh_entry->key.n->tbl->family == AF_INET) {\n\t\terr = mlxsw_sp_router_neigh_entry_op4(mlxsw_sp, neigh_entry,\n\t\t\t\t\t\t      op);\n\t\tif (err)\n\t\t\treturn;\n\t} else if (neigh_entry->key.n->tbl->family == AF_INET6) {\n\t\tif (mlxsw_sp_neigh_ipv6_ignore(neigh_entry))\n\t\t\treturn;\n\t\terr = mlxsw_sp_router_neigh_entry_op6(mlxsw_sp, neigh_entry,\n\t\t\t\t\t\t      op);\n\t\tif (err)\n\t\t\treturn;\n\t} else {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tif (adding)\n\t\tneigh_entry->key.n->flags |= NTF_OFFLOADED;\n\telse\n\t\tneigh_entry->key.n->flags &= ~NTF_OFFLOADED;\n}\n\nvoid\nmlxsw_sp_neigh_entry_counter_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_neigh_entry *neigh_entry,\n\t\t\t\t    bool adding)\n{\n\tif (adding)\n\t\tmlxsw_sp_neigh_counter_alloc(mlxsw_sp, neigh_entry);\n\telse\n\t\tmlxsw_sp_neigh_counter_free(mlxsw_sp, neigh_entry);\n\tmlxsw_sp_neigh_entry_update(mlxsw_sp, neigh_entry, true);\n}\n\nstruct mlxsw_sp_netevent_work {\n\tstruct work_struct work;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct neighbour *n;\n};\n\nstatic void mlxsw_sp_router_neigh_event_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_netevent_work *net_work =\n\t\tcontainer_of(work, struct mlxsw_sp_netevent_work, work);\n\tstruct mlxsw_sp *mlxsw_sp = net_work->mlxsw_sp;\n\tstruct mlxsw_sp_neigh_entry *neigh_entry;\n\tstruct neighbour *n = net_work->n;\n\tunsigned char ha[ETH_ALEN];\n\tbool entry_connected;\n\tu8 nud_state, dead;\n\n\t \n\tread_lock_bh(&n->lock);\n\tmemcpy(ha, n->ha, ETH_ALEN);\n\tnud_state = n->nud_state;\n\tdead = n->dead;\n\tread_unlock_bh(&n->lock);\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\tmlxsw_sp_span_respin(mlxsw_sp);\n\n\tentry_connected = nud_state & NUD_VALID && !dead;\n\tneigh_entry = mlxsw_sp_neigh_entry_lookup(mlxsw_sp, n);\n\tif (!entry_connected && !neigh_entry)\n\t\tgoto out;\n\tif (!neigh_entry) {\n\t\tneigh_entry = mlxsw_sp_neigh_entry_create(mlxsw_sp, n);\n\t\tif (IS_ERR(neigh_entry))\n\t\t\tgoto out;\n\t}\n\n\tif (neigh_entry->connected && entry_connected &&\n\t    !memcmp(neigh_entry->ha, ha, ETH_ALEN))\n\t\tgoto out;\n\n\tmemcpy(neigh_entry->ha, ha, ETH_ALEN);\n\tmlxsw_sp_neigh_entry_update(mlxsw_sp, neigh_entry, entry_connected);\n\tmlxsw_sp_nexthop_neigh_update(mlxsw_sp, neigh_entry, !entry_connected,\n\t\t\t\t      dead);\n\n\tif (!neigh_entry->connected && list_empty(&neigh_entry->nexthop_list))\n\t\tmlxsw_sp_neigh_entry_destroy(mlxsw_sp, neigh_entry);\n\nout:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\tneigh_release(n);\n\tkfree(net_work);\n}\n\nstatic int mlxsw_sp_mp_hash_init(struct mlxsw_sp *mlxsw_sp);\n\nstatic void mlxsw_sp_router_mp_hash_event_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_netevent_work *net_work =\n\t\tcontainer_of(work, struct mlxsw_sp_netevent_work, work);\n\tstruct mlxsw_sp *mlxsw_sp = net_work->mlxsw_sp;\n\n\tmlxsw_sp_mp_hash_init(mlxsw_sp);\n\tkfree(net_work);\n}\n\nstatic int __mlxsw_sp_router_init(struct mlxsw_sp *mlxsw_sp);\n\nstatic void mlxsw_sp_router_update_priority_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_netevent_work *net_work =\n\t\tcontainer_of(work, struct mlxsw_sp_netevent_work, work);\n\tstruct mlxsw_sp *mlxsw_sp = net_work->mlxsw_sp;\n\n\t__mlxsw_sp_router_init(mlxsw_sp);\n\tkfree(net_work);\n}\n\nstatic int mlxsw_sp_router_schedule_work(struct net *net,\n\t\t\t\t\t struct mlxsw_sp_router *router,\n\t\t\t\t\t struct neighbour *n,\n\t\t\t\t\t void (*cb)(struct work_struct *))\n{\n\tstruct mlxsw_sp_netevent_work *net_work;\n\n\tif (!net_eq(net, mlxsw_sp_net(router->mlxsw_sp)))\n\t\treturn NOTIFY_DONE;\n\n\tnet_work = kzalloc(sizeof(*net_work), GFP_ATOMIC);\n\tif (!net_work)\n\t\treturn NOTIFY_BAD;\n\n\tINIT_WORK(&net_work->work, cb);\n\tnet_work->mlxsw_sp = router->mlxsw_sp;\n\tnet_work->n = n;\n\tmlxsw_core_schedule_work(&net_work->work);\n\treturn NOTIFY_DONE;\n}\n\nstatic bool mlxsw_sp_dev_lower_is_port(struct net_device *dev)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\n\trcu_read_lock();\n\tmlxsw_sp_port = mlxsw_sp_port_dev_lower_find_rcu(dev);\n\trcu_read_unlock();\n\treturn !!mlxsw_sp_port;\n}\n\nstatic int mlxsw_sp_router_schedule_neigh_work(struct mlxsw_sp_router *router,\n\t\t\t\t\t       struct neighbour *n)\n{\n\tstruct net *net;\n\n\tnet = neigh_parms_net(n->parms);\n\n\t \n\tneigh_clone(n);\n\treturn mlxsw_sp_router_schedule_work(net, router, n,\n\t\t\t\t\t     mlxsw_sp_router_neigh_event_work);\n}\n\nstatic int mlxsw_sp_router_netevent_event(struct notifier_block *nb,\n\t\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct mlxsw_sp_router *router;\n\tunsigned long interval;\n\tstruct neigh_parms *p;\n\tstruct neighbour *n;\n\n\trouter = container_of(nb, struct mlxsw_sp_router, netevent_nb);\n\n\tswitch (event) {\n\tcase NETEVENT_DELAY_PROBE_TIME_UPDATE:\n\t\tp = ptr;\n\n\t\t \n\t\tif (!p->dev || (p->tbl->family != AF_INET &&\n\t\t\t\tp->tbl->family != AF_INET6))\n\t\t\treturn NOTIFY_DONE;\n\n\t\t \n\t\tif (!mlxsw_sp_dev_lower_is_port(p->dev))\n\t\t\treturn NOTIFY_DONE;\n\n\t\tinterval = jiffies_to_msecs(NEIGH_VAR(p, DELAY_PROBE_TIME));\n\t\trouter->neighs_update.interval = interval;\n\t\tbreak;\n\tcase NETEVENT_NEIGH_UPDATE:\n\t\tn = ptr;\n\n\t\tif (n->tbl->family != AF_INET && n->tbl->family != AF_INET6)\n\t\t\treturn NOTIFY_DONE;\n\n\t\tif (!mlxsw_sp_dev_lower_is_port(n->dev))\n\t\t\treturn NOTIFY_DONE;\n\n\t\treturn mlxsw_sp_router_schedule_neigh_work(router, n);\n\n\tcase NETEVENT_IPV4_MPATH_HASH_UPDATE:\n\tcase NETEVENT_IPV6_MPATH_HASH_UPDATE:\n\t\treturn mlxsw_sp_router_schedule_work(ptr, router, NULL,\n\t\t\t\tmlxsw_sp_router_mp_hash_event_work);\n\n\tcase NETEVENT_IPV4_FWD_UPDATE_PRIORITY_UPDATE:\n\t\treturn mlxsw_sp_router_schedule_work(ptr, router, NULL,\n\t\t\t\tmlxsw_sp_router_update_priority_work);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int mlxsw_sp_neigh_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tint err;\n\n\terr = rhashtable_init(&mlxsw_sp->router->neigh_ht,\n\t\t\t      &mlxsw_sp_neigh_ht_params);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmlxsw_sp_router_neighs_update_interval_init(mlxsw_sp);\n\n\t \n\tINIT_DELAYED_WORK(&mlxsw_sp->router->neighs_update.dw,\n\t\t\t  mlxsw_sp_router_neighs_update_work);\n\tINIT_DELAYED_WORK(&mlxsw_sp->router->nexthop_probe_dw,\n\t\t\t  mlxsw_sp_router_probe_unresolved_nexthops);\n\tatomic_set(&mlxsw_sp->router->neighs_update.neigh_count, 0);\n\tmlxsw_core_schedule_dw(&mlxsw_sp->router->neighs_update.dw, 0);\n\tmlxsw_core_schedule_dw(&mlxsw_sp->router->nexthop_probe_dw, 0);\n\treturn 0;\n}\n\nstatic void mlxsw_sp_neigh_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tcancel_delayed_work_sync(&mlxsw_sp->router->neighs_update.dw);\n\tcancel_delayed_work_sync(&mlxsw_sp->router->nexthop_probe_dw);\n\trhashtable_destroy(&mlxsw_sp->router->neigh_ht);\n}\n\nstatic void mlxsw_sp_neigh_rif_gone_sync(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp_neigh_entry *neigh_entry, *tmp;\n\n\tlist_for_each_entry_safe(neigh_entry, tmp, &rif->neigh_list,\n\t\t\t\t rif_list_node) {\n\t\tmlxsw_sp_neigh_entry_update(mlxsw_sp, neigh_entry, false);\n\t\tmlxsw_sp_neigh_entry_destroy(mlxsw_sp, neigh_entry);\n\t}\n}\n\nstruct mlxsw_sp_neigh_rif_made_sync {\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct mlxsw_sp_rif *rif;\n\tint err;\n};\n\nstatic void mlxsw_sp_neigh_rif_made_sync_each(struct neighbour *n, void *data)\n{\n\tstruct mlxsw_sp_neigh_rif_made_sync *rms = data;\n\tint rc;\n\n\tif (rms->err)\n\t\treturn;\n\tif (n->dev != mlxsw_sp_rif_dev(rms->rif))\n\t\treturn;\n\trc = mlxsw_sp_router_schedule_neigh_work(rms->mlxsw_sp->router, n);\n\tif (rc != NOTIFY_DONE)\n\t\trms->err = -ENOMEM;\n}\n\nstatic int mlxsw_sp_neigh_rif_made_sync(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp_neigh_rif_made_sync rms = {\n\t\t.mlxsw_sp = mlxsw_sp,\n\t\t.rif = rif,\n\t};\n\n\tneigh_for_each(&arp_tbl, mlxsw_sp_neigh_rif_made_sync_each, &rms);\n\tif (rms.err)\n\t\tgoto err_arp;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tneigh_for_each(&nd_tbl, mlxsw_sp_neigh_rif_made_sync_each, &rms);\n#endif\n\tif (rms.err)\n\t\tgoto err_nd;\n\n\treturn 0;\n\nerr_nd:\nerr_arp:\n\tmlxsw_sp_neigh_rif_gone_sync(mlxsw_sp, rif);\n\treturn rms.err;\n}\n\nenum mlxsw_sp_nexthop_type {\n\tMLXSW_SP_NEXTHOP_TYPE_ETH,\n\tMLXSW_SP_NEXTHOP_TYPE_IPIP,\n};\n\nenum mlxsw_sp_nexthop_action {\n\t \n\tMLXSW_SP_NEXTHOP_ACTION_FORWARD,\n\t \n\tMLXSW_SP_NEXTHOP_ACTION_DISCARD,\n\t \n\tMLXSW_SP_NEXTHOP_ACTION_TRAP,\n};\n\nstruct mlxsw_sp_nexthop_key {\n\tstruct fib_nh *fib_nh;\n};\n\nstruct mlxsw_sp_nexthop {\n\tstruct list_head neigh_list_node;  \n\tstruct list_head crif_list_node;\n\tstruct list_head router_list_node;\n\tstruct mlxsw_sp_nexthop_group_info *nhgi;  \n\tstruct rhash_head ht_node;\n\tstruct neigh_table *neigh_tbl;\n\tstruct mlxsw_sp_nexthop_key key;\n\tunsigned char gw_addr[sizeof(struct in6_addr)];\n\tint ifindex;\n\tint nh_weight;\n\tint norm_nh_weight;\n\tint num_adj_entries;\n\tstruct mlxsw_sp_crif *crif;\n\tu8 should_offload:1,  \n\t   offloaded:1,  \n\t   update:1;  \n\tenum mlxsw_sp_nexthop_action action;\n\tenum mlxsw_sp_nexthop_type type;\n\tunion {\n\t\tstruct mlxsw_sp_neigh_entry *neigh_entry;\n\t\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\t};\n\tunsigned int counter_index;\n\tbool counter_valid;\n};\n\nstatic struct net_device *\nmlxsw_sp_nexthop_dev(const struct mlxsw_sp_nexthop *nh)\n{\n\tif (!nh->crif)\n\t\treturn NULL;\n\treturn nh->crif->key.dev;\n}\n\nenum mlxsw_sp_nexthop_group_type {\n\tMLXSW_SP_NEXTHOP_GROUP_TYPE_IPV4,\n\tMLXSW_SP_NEXTHOP_GROUP_TYPE_IPV6,\n\tMLXSW_SP_NEXTHOP_GROUP_TYPE_OBJ,\n};\n\nstruct mlxsw_sp_nexthop_group_info {\n\tstruct mlxsw_sp_nexthop_group *nh_grp;\n\tu32 adj_index;\n\tu16 ecmp_size;\n\tu16 count;\n\tint sum_norm_weight;\n\tu8 adj_index_valid:1,\n\t   gateway:1,  \n\t   is_resilient:1;\n\tstruct list_head list;  \n\tstruct mlxsw_sp_nexthop nexthops[];\n};\n\nstatic struct mlxsw_sp_rif *\nmlxsw_sp_nhgi_rif(const struct mlxsw_sp_nexthop_group_info *nhgi)\n{\n\tstruct mlxsw_sp_crif *crif = nhgi->nexthops[0].crif;\n\n\tif (!crif)\n\t\treturn NULL;\n\treturn crif->rif;\n}\n\nstruct mlxsw_sp_nexthop_group_vr_key {\n\tu16 vr_id;\n\tenum mlxsw_sp_l3proto proto;\n};\n\nstruct mlxsw_sp_nexthop_group_vr_entry {\n\tstruct list_head list;  \n\tstruct rhash_head ht_node;  \n\trefcount_t ref_count;\n\tstruct mlxsw_sp_nexthop_group_vr_key key;\n};\n\nstruct mlxsw_sp_nexthop_group {\n\tstruct rhash_head ht_node;\n\tstruct list_head fib_list;  \n\tunion {\n\t\tstruct {\n\t\t\tstruct fib_info *fi;\n\t\t} ipv4;\n\t\tstruct {\n\t\t\tu32 id;\n\t\t} obj;\n\t};\n\tstruct mlxsw_sp_nexthop_group_info *nhgi;\n\tstruct list_head vr_list;\n\tstruct rhashtable vr_ht;\n\tenum mlxsw_sp_nexthop_group_type type;\n\tbool can_destroy;\n};\n\nvoid mlxsw_sp_nexthop_counter_alloc(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_nexthop *nh)\n{\n\tstruct devlink *devlink;\n\n\tdevlink = priv_to_devlink(mlxsw_sp->core);\n\tif (!devlink_dpipe_table_counter_enabled(devlink,\n\t\t\t\t\t\t MLXSW_SP_DPIPE_TABLE_NAME_ADJ))\n\t\treturn;\n\n\tif (mlxsw_sp_flow_counter_alloc(mlxsw_sp, &nh->counter_index))\n\t\treturn;\n\n\tnh->counter_valid = true;\n}\n\nvoid mlxsw_sp_nexthop_counter_free(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_nexthop *nh)\n{\n\tif (!nh->counter_valid)\n\t\treturn;\n\tmlxsw_sp_flow_counter_free(mlxsw_sp, nh->counter_index);\n\tnh->counter_valid = false;\n}\n\nint mlxsw_sp_nexthop_counter_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_nexthop *nh, u64 *p_counter)\n{\n\tif (!nh->counter_valid)\n\t\treturn -EINVAL;\n\n\treturn mlxsw_sp_flow_counter_get(mlxsw_sp, nh->counter_index,\n\t\t\t\t\t p_counter, NULL);\n}\n\nstruct mlxsw_sp_nexthop *mlxsw_sp_nexthop_next(struct mlxsw_sp_router *router,\n\t\t\t\t\t       struct mlxsw_sp_nexthop *nh)\n{\n\tif (!nh) {\n\t\tif (list_empty(&router->nexthop_list))\n\t\t\treturn NULL;\n\t\telse\n\t\t\treturn list_first_entry(&router->nexthop_list,\n\t\t\t\t\t\ttypeof(*nh), router_list_node);\n\t}\n\tif (list_is_last(&nh->router_list_node, &router->nexthop_list))\n\t\treturn NULL;\n\treturn list_next_entry(nh, router_list_node);\n}\n\nbool mlxsw_sp_nexthop_is_forward(const struct mlxsw_sp_nexthop *nh)\n{\n\treturn nh->offloaded && nh->action == MLXSW_SP_NEXTHOP_ACTION_FORWARD;\n}\n\nunsigned char *mlxsw_sp_nexthop_ha(struct mlxsw_sp_nexthop *nh)\n{\n\tif (nh->type != MLXSW_SP_NEXTHOP_TYPE_ETH ||\n\t    !mlxsw_sp_nexthop_is_forward(nh))\n\t\treturn NULL;\n\treturn nh->neigh_entry->ha;\n}\n\nint mlxsw_sp_nexthop_indexes(struct mlxsw_sp_nexthop *nh, u32 *p_adj_index,\n\t\t\t     u32 *p_adj_size, u32 *p_adj_hash_index)\n{\n\tstruct mlxsw_sp_nexthop_group_info *nhgi = nh->nhgi;\n\tu32 adj_hash_index = 0;\n\tint i;\n\n\tif (!nh->offloaded || !nhgi->adj_index_valid)\n\t\treturn -EINVAL;\n\n\t*p_adj_index = nhgi->adj_index;\n\t*p_adj_size = nhgi->ecmp_size;\n\n\tfor (i = 0; i < nhgi->count; i++) {\n\t\tstruct mlxsw_sp_nexthop *nh_iter = &nhgi->nexthops[i];\n\n\t\tif (nh_iter == nh)\n\t\t\tbreak;\n\t\tif (nh_iter->offloaded)\n\t\t\tadj_hash_index += nh_iter->num_adj_entries;\n\t}\n\n\t*p_adj_hash_index = adj_hash_index;\n\treturn 0;\n}\n\nstruct mlxsw_sp_rif *mlxsw_sp_nexthop_rif(struct mlxsw_sp_nexthop *nh)\n{\n\tif (WARN_ON(!nh->crif))\n\t\treturn NULL;\n\treturn nh->crif->rif;\n}\n\nbool mlxsw_sp_nexthop_group_has_ipip(struct mlxsw_sp_nexthop *nh)\n{\n\tstruct mlxsw_sp_nexthop_group_info *nhgi = nh->nhgi;\n\tint i;\n\n\tfor (i = 0; i < nhgi->count; i++) {\n\t\tstruct mlxsw_sp_nexthop *nh_iter = &nhgi->nexthops[i];\n\n\t\tif (nh_iter->type == MLXSW_SP_NEXTHOP_TYPE_IPIP)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const struct rhashtable_params mlxsw_sp_nexthop_group_vr_ht_params = {\n\t.key_offset = offsetof(struct mlxsw_sp_nexthop_group_vr_entry, key),\n\t.head_offset = offsetof(struct mlxsw_sp_nexthop_group_vr_entry, ht_node),\n\t.key_len = sizeof(struct mlxsw_sp_nexthop_group_vr_key),\n\t.automatic_shrinking = true,\n};\n\nstatic struct mlxsw_sp_nexthop_group_vr_entry *\nmlxsw_sp_nexthop_group_vr_entry_lookup(struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t\t       const struct mlxsw_sp_fib *fib)\n{\n\tstruct mlxsw_sp_nexthop_group_vr_key key;\n\n\tmemset(&key, 0, sizeof(key));\n\tkey.vr_id = fib->vr->id;\n\tkey.proto = fib->proto;\n\treturn rhashtable_lookup_fast(&nh_grp->vr_ht, &key,\n\t\t\t\t      mlxsw_sp_nexthop_group_vr_ht_params);\n}\n\nstatic int\nmlxsw_sp_nexthop_group_vr_entry_create(struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t\t       const struct mlxsw_sp_fib *fib)\n{\n\tstruct mlxsw_sp_nexthop_group_vr_entry *vr_entry;\n\tint err;\n\n\tvr_entry = kzalloc(sizeof(*vr_entry), GFP_KERNEL);\n\tif (!vr_entry)\n\t\treturn -ENOMEM;\n\n\tvr_entry->key.vr_id = fib->vr->id;\n\tvr_entry->key.proto = fib->proto;\n\trefcount_set(&vr_entry->ref_count, 1);\n\n\terr = rhashtable_insert_fast(&nh_grp->vr_ht, &vr_entry->ht_node,\n\t\t\t\t     mlxsw_sp_nexthop_group_vr_ht_params);\n\tif (err)\n\t\tgoto err_hashtable_insert;\n\n\tlist_add(&vr_entry->list, &nh_grp->vr_list);\n\n\treturn 0;\n\nerr_hashtable_insert:\n\tkfree(vr_entry);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_nexthop_group_vr_entry_destroy(struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t\t\tstruct mlxsw_sp_nexthop_group_vr_entry *vr_entry)\n{\n\tlist_del(&vr_entry->list);\n\trhashtable_remove_fast(&nh_grp->vr_ht, &vr_entry->ht_node,\n\t\t\t       mlxsw_sp_nexthop_group_vr_ht_params);\n\tkfree(vr_entry);\n}\n\nstatic int\nmlxsw_sp_nexthop_group_vr_link(struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t       const struct mlxsw_sp_fib *fib)\n{\n\tstruct mlxsw_sp_nexthop_group_vr_entry *vr_entry;\n\n\tvr_entry = mlxsw_sp_nexthop_group_vr_entry_lookup(nh_grp, fib);\n\tif (vr_entry) {\n\t\trefcount_inc(&vr_entry->ref_count);\n\t\treturn 0;\n\t}\n\n\treturn mlxsw_sp_nexthop_group_vr_entry_create(nh_grp, fib);\n}\n\nstatic void\nmlxsw_sp_nexthop_group_vr_unlink(struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t\t const struct mlxsw_sp_fib *fib)\n{\n\tstruct mlxsw_sp_nexthop_group_vr_entry *vr_entry;\n\n\tvr_entry = mlxsw_sp_nexthop_group_vr_entry_lookup(nh_grp, fib);\n\tif (WARN_ON_ONCE(!vr_entry))\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&vr_entry->ref_count))\n\t\treturn;\n\n\tmlxsw_sp_nexthop_group_vr_entry_destroy(nh_grp, vr_entry);\n}\n\nstruct mlxsw_sp_nexthop_group_cmp_arg {\n\tenum mlxsw_sp_nexthop_group_type type;\n\tunion {\n\t\tstruct fib_info *fi;\n\t\tstruct mlxsw_sp_fib6_entry *fib6_entry;\n\t\tu32 id;\n\t};\n};\n\nstatic bool\nmlxsw_sp_nexthop6_group_has_nexthop(const struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t\t    const struct in6_addr *gw, int ifindex,\n\t\t\t\t    int weight)\n{\n\tint i;\n\n\tfor (i = 0; i < nh_grp->nhgi->count; i++) {\n\t\tconst struct mlxsw_sp_nexthop *nh;\n\n\t\tnh = &nh_grp->nhgi->nexthops[i];\n\t\tif (nh->ifindex == ifindex && nh->nh_weight == weight &&\n\t\t    ipv6_addr_equal(gw, (struct in6_addr *) nh->gw_addr))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool\nmlxsw_sp_nexthop6_group_cmp(const struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t    const struct mlxsw_sp_fib6_entry *fib6_entry)\n{\n\tstruct mlxsw_sp_rt6 *mlxsw_sp_rt6;\n\n\tif (nh_grp->nhgi->count != fib6_entry->nrt6)\n\t\treturn false;\n\n\tlist_for_each_entry(mlxsw_sp_rt6, &fib6_entry->rt6_list, list) {\n\t\tstruct fib6_nh *fib6_nh = mlxsw_sp_rt6->rt->fib6_nh;\n\t\tstruct in6_addr *gw;\n\t\tint ifindex, weight;\n\n\t\tifindex = fib6_nh->fib_nh_dev->ifindex;\n\t\tweight = fib6_nh->fib_nh_weight;\n\t\tgw = &fib6_nh->fib_nh_gw6;\n\t\tif (!mlxsw_sp_nexthop6_group_has_nexthop(nh_grp, gw, ifindex,\n\t\t\t\t\t\t\t weight))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int\nmlxsw_sp_nexthop_group_cmp(struct rhashtable_compare_arg *arg, const void *ptr)\n{\n\tconst struct mlxsw_sp_nexthop_group_cmp_arg *cmp_arg = arg->key;\n\tconst struct mlxsw_sp_nexthop_group *nh_grp = ptr;\n\n\tif (nh_grp->type != cmp_arg->type)\n\t\treturn 1;\n\n\tswitch (cmp_arg->type) {\n\tcase MLXSW_SP_NEXTHOP_GROUP_TYPE_IPV4:\n\t\treturn cmp_arg->fi != nh_grp->ipv4.fi;\n\tcase MLXSW_SP_NEXTHOP_GROUP_TYPE_IPV6:\n\t\treturn !mlxsw_sp_nexthop6_group_cmp(nh_grp,\n\t\t\t\t\t\t    cmp_arg->fib6_entry);\n\tcase MLXSW_SP_NEXTHOP_GROUP_TYPE_OBJ:\n\t\treturn cmp_arg->id != nh_grp->obj.id;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn 1;\n\t}\n}\n\nstatic u32 mlxsw_sp_nexthop_group_hash_obj(const void *data, u32 len, u32 seed)\n{\n\tconst struct mlxsw_sp_nexthop_group *nh_grp = data;\n\tconst struct mlxsw_sp_nexthop *nh;\n\tstruct fib_info *fi;\n\tunsigned int val;\n\tint i;\n\n\tswitch (nh_grp->type) {\n\tcase MLXSW_SP_NEXTHOP_GROUP_TYPE_IPV4:\n\t\tfi = nh_grp->ipv4.fi;\n\t\treturn jhash(&fi, sizeof(fi), seed);\n\tcase MLXSW_SP_NEXTHOP_GROUP_TYPE_IPV6:\n\t\tval = nh_grp->nhgi->count;\n\t\tfor (i = 0; i < nh_grp->nhgi->count; i++) {\n\t\t\tnh = &nh_grp->nhgi->nexthops[i];\n\t\t\tval ^= jhash(&nh->ifindex, sizeof(nh->ifindex), seed);\n\t\t\tval ^= jhash(&nh->gw_addr, sizeof(nh->gw_addr), seed);\n\t\t}\n\t\treturn jhash(&val, sizeof(val), seed);\n\tcase MLXSW_SP_NEXTHOP_GROUP_TYPE_OBJ:\n\t\treturn jhash(&nh_grp->obj.id, sizeof(nh_grp->obj.id), seed);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n}\n\nstatic u32\nmlxsw_sp_nexthop6_group_hash(struct mlxsw_sp_fib6_entry *fib6_entry, u32 seed)\n{\n\tunsigned int val = fib6_entry->nrt6;\n\tstruct mlxsw_sp_rt6 *mlxsw_sp_rt6;\n\n\tlist_for_each_entry(mlxsw_sp_rt6, &fib6_entry->rt6_list, list) {\n\t\tstruct fib6_nh *fib6_nh = mlxsw_sp_rt6->rt->fib6_nh;\n\t\tstruct net_device *dev = fib6_nh->fib_nh_dev;\n\t\tstruct in6_addr *gw = &fib6_nh->fib_nh_gw6;\n\n\t\tval ^= jhash(&dev->ifindex, sizeof(dev->ifindex), seed);\n\t\tval ^= jhash(gw, sizeof(*gw), seed);\n\t}\n\n\treturn jhash(&val, sizeof(val), seed);\n}\n\nstatic u32\nmlxsw_sp_nexthop_group_hash(const void *data, u32 len, u32 seed)\n{\n\tconst struct mlxsw_sp_nexthop_group_cmp_arg *cmp_arg = data;\n\n\tswitch (cmp_arg->type) {\n\tcase MLXSW_SP_NEXTHOP_GROUP_TYPE_IPV4:\n\t\treturn jhash(&cmp_arg->fi, sizeof(cmp_arg->fi), seed);\n\tcase MLXSW_SP_NEXTHOP_GROUP_TYPE_IPV6:\n\t\treturn mlxsw_sp_nexthop6_group_hash(cmp_arg->fib6_entry, seed);\n\tcase MLXSW_SP_NEXTHOP_GROUP_TYPE_OBJ:\n\t\treturn jhash(&cmp_arg->id, sizeof(cmp_arg->id), seed);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n}\n\nstatic const struct rhashtable_params mlxsw_sp_nexthop_group_ht_params = {\n\t.head_offset = offsetof(struct mlxsw_sp_nexthop_group, ht_node),\n\t.hashfn\t     = mlxsw_sp_nexthop_group_hash,\n\t.obj_hashfn  = mlxsw_sp_nexthop_group_hash_obj,\n\t.obj_cmpfn   = mlxsw_sp_nexthop_group_cmp,\n};\n\nstatic int mlxsw_sp_nexthop_group_insert(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t struct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tif (nh_grp->type == MLXSW_SP_NEXTHOP_GROUP_TYPE_IPV6 &&\n\t    !nh_grp->nhgi->gateway)\n\t\treturn 0;\n\n\treturn rhashtable_insert_fast(&mlxsw_sp->router->nexthop_group_ht,\n\t\t\t\t      &nh_grp->ht_node,\n\t\t\t\t      mlxsw_sp_nexthop_group_ht_params);\n}\n\nstatic void mlxsw_sp_nexthop_group_remove(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tif (nh_grp->type == MLXSW_SP_NEXTHOP_GROUP_TYPE_IPV6 &&\n\t    !nh_grp->nhgi->gateway)\n\t\treturn;\n\n\trhashtable_remove_fast(&mlxsw_sp->router->nexthop_group_ht,\n\t\t\t       &nh_grp->ht_node,\n\t\t\t       mlxsw_sp_nexthop_group_ht_params);\n}\n\nstatic struct mlxsw_sp_nexthop_group *\nmlxsw_sp_nexthop4_group_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct fib_info *fi)\n{\n\tstruct mlxsw_sp_nexthop_group_cmp_arg cmp_arg;\n\n\tcmp_arg.type = MLXSW_SP_NEXTHOP_GROUP_TYPE_IPV4;\n\tcmp_arg.fi = fi;\n\treturn rhashtable_lookup_fast(&mlxsw_sp->router->nexthop_group_ht,\n\t\t\t\t      &cmp_arg,\n\t\t\t\t      mlxsw_sp_nexthop_group_ht_params);\n}\n\nstatic struct mlxsw_sp_nexthop_group *\nmlxsw_sp_nexthop6_group_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_fib6_entry *fib6_entry)\n{\n\tstruct mlxsw_sp_nexthop_group_cmp_arg cmp_arg;\n\n\tcmp_arg.type = MLXSW_SP_NEXTHOP_GROUP_TYPE_IPV6;\n\tcmp_arg.fib6_entry = fib6_entry;\n\treturn rhashtable_lookup_fast(&mlxsw_sp->router->nexthop_group_ht,\n\t\t\t\t      &cmp_arg,\n\t\t\t\t      mlxsw_sp_nexthop_group_ht_params);\n}\n\nstatic const struct rhashtable_params mlxsw_sp_nexthop_ht_params = {\n\t.key_offset = offsetof(struct mlxsw_sp_nexthop, key),\n\t.head_offset = offsetof(struct mlxsw_sp_nexthop, ht_node),\n\t.key_len = sizeof(struct mlxsw_sp_nexthop_key),\n};\n\nstatic int mlxsw_sp_nexthop_insert(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_nexthop *nh)\n{\n\treturn rhashtable_insert_fast(&mlxsw_sp->router->nexthop_ht,\n\t\t\t\t      &nh->ht_node, mlxsw_sp_nexthop_ht_params);\n}\n\nstatic void mlxsw_sp_nexthop_remove(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_nexthop *nh)\n{\n\trhashtable_remove_fast(&mlxsw_sp->router->nexthop_ht, &nh->ht_node,\n\t\t\t       mlxsw_sp_nexthop_ht_params);\n}\n\nstatic struct mlxsw_sp_nexthop *\nmlxsw_sp_nexthop_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\tstruct mlxsw_sp_nexthop_key key)\n{\n\treturn rhashtable_lookup_fast(&mlxsw_sp->router->nexthop_ht, &key,\n\t\t\t\t      mlxsw_sp_nexthop_ht_params);\n}\n\nstatic int mlxsw_sp_adj_index_mass_update_vr(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t     enum mlxsw_sp_l3proto proto,\n\t\t\t\t\t     u16 vr_id,\n\t\t\t\t\t     u32 adj_index, u16 ecmp_size,\n\t\t\t\t\t     u32 new_adj_index,\n\t\t\t\t\t     u16 new_ecmp_size)\n{\n\tchar raleu_pl[MLXSW_REG_RALEU_LEN];\n\n\tmlxsw_reg_raleu_pack(raleu_pl,\n\t\t\t     (enum mlxsw_reg_ralxx_protocol) proto, vr_id,\n\t\t\t     adj_index, ecmp_size, new_adj_index,\n\t\t\t     new_ecmp_size);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(raleu), raleu_pl);\n}\n\nstatic int mlxsw_sp_adj_index_mass_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t\t\t  u32 old_adj_index, u16 old_ecmp_size)\n{\n\tstruct mlxsw_sp_nexthop_group_info *nhgi = nh_grp->nhgi;\n\tstruct mlxsw_sp_nexthop_group_vr_entry *vr_entry;\n\tint err;\n\n\tlist_for_each_entry(vr_entry, &nh_grp->vr_list, list) {\n\t\terr = mlxsw_sp_adj_index_mass_update_vr(mlxsw_sp,\n\t\t\t\t\t\t\tvr_entry->key.proto,\n\t\t\t\t\t\t\tvr_entry->key.vr_id,\n\t\t\t\t\t\t\told_adj_index,\n\t\t\t\t\t\t\told_ecmp_size,\n\t\t\t\t\t\t\tnhgi->adj_index,\n\t\t\t\t\t\t\tnhgi->ecmp_size);\n\t\tif (err)\n\t\t\tgoto err_mass_update_vr;\n\t}\n\treturn 0;\n\nerr_mass_update_vr:\n\tlist_for_each_entry_continue_reverse(vr_entry, &nh_grp->vr_list, list)\n\t\tmlxsw_sp_adj_index_mass_update_vr(mlxsw_sp, vr_entry->key.proto,\n\t\t\t\t\t\t  vr_entry->key.vr_id,\n\t\t\t\t\t\t  nhgi->adj_index,\n\t\t\t\t\t\t  nhgi->ecmp_size,\n\t\t\t\t\t\t  old_adj_index, old_ecmp_size);\n\treturn err;\n}\n\nstatic int __mlxsw_sp_nexthop_eth_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t u32 adj_index,\n\t\t\t\t\t struct mlxsw_sp_nexthop *nh,\n\t\t\t\t\t bool force, char *ratr_pl)\n{\n\tstruct mlxsw_sp_neigh_entry *neigh_entry = nh->neigh_entry;\n\tstruct mlxsw_sp_rif *rif = mlxsw_sp_nexthop_rif(nh);\n\tenum mlxsw_reg_ratr_op op;\n\tu16 rif_index;\n\n\trif_index = rif ? rif->rif_index :\n\t\t\t  mlxsw_sp->router->lb_crif->rif->rif_index;\n\top = force ? MLXSW_REG_RATR_OP_WRITE_WRITE_ENTRY :\n\t\t     MLXSW_REG_RATR_OP_WRITE_WRITE_ENTRY_ON_ACTIVITY;\n\tmlxsw_reg_ratr_pack(ratr_pl, op, true, MLXSW_REG_RATR_TYPE_ETHERNET,\n\t\t\t    adj_index, rif_index);\n\tswitch (nh->action) {\n\tcase MLXSW_SP_NEXTHOP_ACTION_FORWARD:\n\t\tmlxsw_reg_ratr_eth_entry_pack(ratr_pl, neigh_entry->ha);\n\t\tbreak;\n\tcase MLXSW_SP_NEXTHOP_ACTION_DISCARD:\n\t\tmlxsw_reg_ratr_trap_action_set(ratr_pl,\n\t\t\t\t\t       MLXSW_REG_RATR_TRAP_ACTION_DISCARD_ERRORS);\n\t\tbreak;\n\tcase MLXSW_SP_NEXTHOP_ACTION_TRAP:\n\t\tmlxsw_reg_ratr_trap_action_set(ratr_pl,\n\t\t\t\t\t       MLXSW_REG_RATR_TRAP_ACTION_TRAP);\n\t\tmlxsw_reg_ratr_trap_id_set(ratr_pl, MLXSW_TRAP_ID_RTR_EGRESS0);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\tif (nh->counter_valid)\n\t\tmlxsw_reg_ratr_counter_pack(ratr_pl, nh->counter_index, true);\n\telse\n\t\tmlxsw_reg_ratr_counter_pack(ratr_pl, 0, false);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ratr), ratr_pl);\n}\n\nint mlxsw_sp_nexthop_eth_update(struct mlxsw_sp *mlxsw_sp, u32 adj_index,\n\t\t\t\tstruct mlxsw_sp_nexthop *nh, bool force,\n\t\t\t\tchar *ratr_pl)\n{\n\tint i;\n\n\tfor (i = 0; i < nh->num_adj_entries; i++) {\n\t\tint err;\n\n\t\terr = __mlxsw_sp_nexthop_eth_update(mlxsw_sp, adj_index + i,\n\t\t\t\t\t\t    nh, force, ratr_pl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __mlxsw_sp_nexthop_ipip_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  u32 adj_index,\n\t\t\t\t\t  struct mlxsw_sp_nexthop *nh,\n\t\t\t\t\t  bool force, char *ratr_pl)\n{\n\tconst struct mlxsw_sp_ipip_ops *ipip_ops;\n\n\tipip_ops = mlxsw_sp->router->ipip_ops_arr[nh->ipip_entry->ipipt];\n\treturn ipip_ops->nexthop_update(mlxsw_sp, adj_index, nh->ipip_entry,\n\t\t\t\t\tforce, ratr_pl);\n}\n\nstatic int mlxsw_sp_nexthop_ipip_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tu32 adj_index,\n\t\t\t\t\tstruct mlxsw_sp_nexthop *nh, bool force,\n\t\t\t\t\tchar *ratr_pl)\n{\n\tint i;\n\n\tfor (i = 0; i < nh->num_adj_entries; i++) {\n\t\tint err;\n\n\t\terr = __mlxsw_sp_nexthop_ipip_update(mlxsw_sp, adj_index + i,\n\t\t\t\t\t\t     nh, force, ratr_pl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_nexthop_update(struct mlxsw_sp *mlxsw_sp, u32 adj_index,\n\t\t\t\t   struct mlxsw_sp_nexthop *nh, bool force,\n\t\t\t\t   char *ratr_pl)\n{\n\t \n\tif (nh->type == MLXSW_SP_NEXTHOP_TYPE_ETH ||\n\t    nh->action == MLXSW_SP_NEXTHOP_ACTION_DISCARD ||\n\t    nh->action == MLXSW_SP_NEXTHOP_ACTION_TRAP)\n\t\treturn mlxsw_sp_nexthop_eth_update(mlxsw_sp, adj_index, nh,\n\t\t\t\t\t\t   force, ratr_pl);\n\telse\n\t\treturn mlxsw_sp_nexthop_ipip_update(mlxsw_sp, adj_index, nh,\n\t\t\t\t\t\t    force, ratr_pl);\n}\n\nstatic int\nmlxsw_sp_nexthop_group_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_nexthop_group_info *nhgi,\n\t\t\t      bool reallocate)\n{\n\tchar ratr_pl[MLXSW_REG_RATR_LEN];\n\tu32 adj_index = nhgi->adj_index;  \n\tstruct mlxsw_sp_nexthop *nh;\n\tint i;\n\n\tfor (i = 0; i < nhgi->count; i++) {\n\t\tnh = &nhgi->nexthops[i];\n\n\t\tif (!nh->should_offload) {\n\t\t\tnh->offloaded = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nh->update || reallocate) {\n\t\t\tint err = 0;\n\n\t\t\terr = mlxsw_sp_nexthop_update(mlxsw_sp, adj_index, nh,\n\t\t\t\t\t\t      true, ratr_pl);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tnh->update = 0;\n\t\t\tnh->offloaded = 1;\n\t\t}\n\t\tadj_index += nh->num_adj_entries;\n\t}\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_nexthop_fib_entries_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tstruct mlxsw_sp_fib_entry *fib_entry;\n\tint err;\n\n\tlist_for_each_entry(fib_entry, &nh_grp->fib_list, nexthop_group_node) {\n\t\terr = mlxsw_sp_fib_entry_update(mlxsw_sp, fib_entry);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstruct mlxsw_sp_adj_grp_size_range {\n\tu16 start;  \n\tu16 end;  \n};\n\n \nstatic const struct mlxsw_sp_adj_grp_size_range\nmlxsw_sp1_adj_grp_size_ranges[] = {\n\t{ .start = 1, .end = 64 },\n\t{ .start = 512, .end = 512 },\n\t{ .start = 1024, .end = 1024 },\n\t{ .start = 2048, .end = 2048 },\n\t{ .start = 4096, .end = 4096 },\n};\n\n \nstatic const struct mlxsw_sp_adj_grp_size_range\nmlxsw_sp2_adj_grp_size_ranges[] = {\n\t{ .start = 1, .end = 128 },\n\t{ .start = 256, .end = 256 },\n\t{ .start = 512, .end = 512 },\n\t{ .start = 1024, .end = 1024 },\n\t{ .start = 2048, .end = 2048 },\n\t{ .start = 4096, .end = 4096 },\n};\n\nstatic void mlxsw_sp_adj_grp_size_round_up(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   u16 *p_adj_grp_size)\n{\n\tint i;\n\n\tfor (i = 0; i < mlxsw_sp->router->adj_grp_size_ranges_count; i++) {\n\t\tconst struct mlxsw_sp_adj_grp_size_range *size_range;\n\n\t\tsize_range = &mlxsw_sp->router->adj_grp_size_ranges[i];\n\n\t\tif (*p_adj_grp_size >= size_range->start &&\n\t\t    *p_adj_grp_size <= size_range->end)\n\t\t\treturn;\n\n\t\tif (*p_adj_grp_size <= size_range->end) {\n\t\t\t*p_adj_grp_size = size_range->end;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void mlxsw_sp_adj_grp_size_round_down(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t     u16 *p_adj_grp_size,\n\t\t\t\t\t     unsigned int alloc_size)\n{\n\tint i;\n\n\tfor (i = mlxsw_sp->router->adj_grp_size_ranges_count - 1; i >= 0; i--) {\n\t\tconst struct mlxsw_sp_adj_grp_size_range *size_range;\n\n\t\tsize_range = &mlxsw_sp->router->adj_grp_size_ranges[i];\n\n\t\tif (alloc_size >= size_range->end) {\n\t\t\t*p_adj_grp_size = size_range->end;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int mlxsw_sp_fix_adj_grp_size(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     u16 *p_adj_grp_size)\n{\n\tunsigned int alloc_size;\n\tint err;\n\n\t \n\tmlxsw_sp_adj_grp_size_round_up(mlxsw_sp, p_adj_grp_size);\n\terr = mlxsw_sp_kvdl_alloc_count_query(mlxsw_sp,\n\t\t\t\t\t      MLXSW_SP_KVDL_ENTRY_TYPE_ADJ,\n\t\t\t\t\t      *p_adj_grp_size, &alloc_size);\n\tif (err)\n\t\treturn err;\n\t \n\tmlxsw_sp_adj_grp_size_round_down(mlxsw_sp, p_adj_grp_size, alloc_size);\n\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_nexthop_group_normalize(struct mlxsw_sp_nexthop_group_info *nhgi)\n{\n\tint i, g = 0, sum_norm_weight = 0;\n\tstruct mlxsw_sp_nexthop *nh;\n\n\tfor (i = 0; i < nhgi->count; i++) {\n\t\tnh = &nhgi->nexthops[i];\n\n\t\tif (!nh->should_offload)\n\t\t\tcontinue;\n\t\tif (g > 0)\n\t\t\tg = gcd(nh->nh_weight, g);\n\t\telse\n\t\t\tg = nh->nh_weight;\n\t}\n\n\tfor (i = 0; i < nhgi->count; i++) {\n\t\tnh = &nhgi->nexthops[i];\n\n\t\tif (!nh->should_offload)\n\t\t\tcontinue;\n\t\tnh->norm_nh_weight = nh->nh_weight / g;\n\t\tsum_norm_weight += nh->norm_nh_weight;\n\t}\n\n\tnhgi->sum_norm_weight = sum_norm_weight;\n}\n\nstatic void\nmlxsw_sp_nexthop_group_rebalance(struct mlxsw_sp_nexthop_group_info *nhgi)\n{\n\tint i, weight = 0, lower_bound = 0;\n\tint total = nhgi->sum_norm_weight;\n\tu16 ecmp_size = nhgi->ecmp_size;\n\n\tfor (i = 0; i < nhgi->count; i++) {\n\t\tstruct mlxsw_sp_nexthop *nh = &nhgi->nexthops[i];\n\t\tint upper_bound;\n\n\t\tif (!nh->should_offload)\n\t\t\tcontinue;\n\t\tweight += nh->norm_nh_weight;\n\t\tupper_bound = DIV_ROUND_CLOSEST(ecmp_size * weight, total);\n\t\tnh->num_adj_entries = upper_bound - lower_bound;\n\t\tlower_bound = upper_bound;\n\t}\n}\n\nstatic struct mlxsw_sp_nexthop *\nmlxsw_sp_rt6_nexthop(struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t     const struct mlxsw_sp_rt6 *mlxsw_sp_rt6);\n\nstatic void\nmlxsw_sp_nexthop4_group_offload_refresh(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tint i;\n\n\tfor (i = 0; i < nh_grp->nhgi->count; i++) {\n\t\tstruct mlxsw_sp_nexthop *nh = &nh_grp->nhgi->nexthops[i];\n\n\t\tif (nh->offloaded)\n\t\t\tnh->key.fib_nh->fib_nh_flags |= RTNH_F_OFFLOAD;\n\t\telse\n\t\t\tnh->key.fib_nh->fib_nh_flags &= ~RTNH_F_OFFLOAD;\n\t}\n}\n\nstatic void\n__mlxsw_sp_nexthop6_group_offload_refresh(struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t\t\t  struct mlxsw_sp_fib6_entry *fib6_entry)\n{\n\tstruct mlxsw_sp_rt6 *mlxsw_sp_rt6;\n\n\tlist_for_each_entry(mlxsw_sp_rt6, &fib6_entry->rt6_list, list) {\n\t\tstruct fib6_nh *fib6_nh = mlxsw_sp_rt6->rt->fib6_nh;\n\t\tstruct mlxsw_sp_nexthop *nh;\n\n\t\tnh = mlxsw_sp_rt6_nexthop(nh_grp, mlxsw_sp_rt6);\n\t\tif (nh && nh->offloaded)\n\t\t\tfib6_nh->fib_nh_flags |= RTNH_F_OFFLOAD;\n\t\telse\n\t\t\tfib6_nh->fib_nh_flags &= ~RTNH_F_OFFLOAD;\n\t}\n}\n\nstatic void\nmlxsw_sp_nexthop6_group_offload_refresh(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tstruct mlxsw_sp_fib6_entry *fib6_entry;\n\n\t \n\tlist_for_each_entry(fib6_entry, &nh_grp->fib_list,\n\t\t\t    common.nexthop_group_node)\n\t\t__mlxsw_sp_nexthop6_group_offload_refresh(nh_grp, fib6_entry);\n}\n\nstatic void\nmlxsw_sp_nexthop_bucket_offload_refresh(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tconst struct mlxsw_sp_nexthop *nh,\n\t\t\t\t\tu16 bucket_index)\n{\n\tstruct mlxsw_sp_nexthop_group *nh_grp = nh->nhgi->nh_grp;\n\tbool offload = false, trap = false;\n\n\tif (nh->offloaded) {\n\t\tif (nh->action == MLXSW_SP_NEXTHOP_ACTION_TRAP)\n\t\t\ttrap = true;\n\t\telse\n\t\t\toffload = true;\n\t}\n\tnexthop_bucket_set_hw_flags(mlxsw_sp_net(mlxsw_sp), nh_grp->obj.id,\n\t\t\t\t    bucket_index, offload, trap);\n}\n\nstatic void\nmlxsw_sp_nexthop_obj_group_offload_refresh(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   struct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tint i;\n\n\t \n\tif (nh_grp->can_destroy)\n\t\treturn;\n\n\tnexthop_set_hw_flags(mlxsw_sp_net(mlxsw_sp), nh_grp->obj.id,\n\t\t\t     nh_grp->nhgi->adj_index_valid, false);\n\n\t \n\tif (!nh_grp->nhgi->is_resilient)\n\t\treturn;\n\n\tfor (i = 0; i < nh_grp->nhgi->count; i++) {\n\t\tstruct mlxsw_sp_nexthop *nh = &nh_grp->nhgi->nexthops[i];\n\n\t\tmlxsw_sp_nexthop_bucket_offload_refresh(mlxsw_sp, nh, i);\n\t}\n}\n\nstatic void\nmlxsw_sp_nexthop_group_offload_refresh(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tswitch (nh_grp->type) {\n\tcase MLXSW_SP_NEXTHOP_GROUP_TYPE_IPV4:\n\t\tmlxsw_sp_nexthop4_group_offload_refresh(mlxsw_sp, nh_grp);\n\t\tbreak;\n\tcase MLXSW_SP_NEXTHOP_GROUP_TYPE_IPV6:\n\t\tmlxsw_sp_nexthop6_group_offload_refresh(mlxsw_sp, nh_grp);\n\t\tbreak;\n\tcase MLXSW_SP_NEXTHOP_GROUP_TYPE_OBJ:\n\t\tmlxsw_sp_nexthop_obj_group_offload_refresh(mlxsw_sp, nh_grp);\n\t\tbreak;\n\t}\n}\n\nstatic int\nmlxsw_sp_nexthop_group_refresh(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tstruct mlxsw_sp_nexthop_group_info *nhgi = nh_grp->nhgi;\n\tu16 ecmp_size, old_ecmp_size;\n\tstruct mlxsw_sp_nexthop *nh;\n\tbool offload_change = false;\n\tu32 adj_index;\n\tbool old_adj_index_valid;\n\tu32 old_adj_index;\n\tint i, err2, err;\n\n\tif (!nhgi->gateway)\n\t\treturn mlxsw_sp_nexthop_fib_entries_update(mlxsw_sp, nh_grp);\n\n\tfor (i = 0; i < nhgi->count; i++) {\n\t\tnh = &nhgi->nexthops[i];\n\n\t\tif (nh->should_offload != nh->offloaded) {\n\t\t\toffload_change = true;\n\t\t\tif (nh->should_offload)\n\t\t\t\tnh->update = 1;\n\t\t}\n\t}\n\tif (!offload_change) {\n\t\t \n\t\terr = mlxsw_sp_nexthop_group_update(mlxsw_sp, nhgi, false);\n\t\tif (err) {\n\t\t\tdev_warn(mlxsw_sp->bus_info->dev, \"Failed to update neigh MAC in adjacency table.\\n\");\n\t\t\tgoto set_trap;\n\t\t}\n\t\t \n\t\tmlxsw_sp_nexthop_group_offload_refresh(mlxsw_sp, nh_grp);\n\t\treturn 0;\n\t}\n\tmlxsw_sp_nexthop_group_normalize(nhgi);\n\tif (!nhgi->sum_norm_weight) {\n\t\t \n\t\terr = 0;\n\t\tgoto set_trap;\n\t}\n\n\tecmp_size = nhgi->sum_norm_weight;\n\terr = mlxsw_sp_fix_adj_grp_size(mlxsw_sp, &ecmp_size);\n\tif (err)\n\t\t \n\t\tgoto set_trap;\n\n\terr = mlxsw_sp_kvdl_alloc(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ADJ,\n\t\t\t\t  ecmp_size, &adj_index);\n\tif (err) {\n\t\t \n\t\tdev_warn(mlxsw_sp->bus_info->dev, \"Failed to allocate KVD linear area for nexthop group.\\n\");\n\t\tgoto set_trap;\n\t}\n\told_adj_index_valid = nhgi->adj_index_valid;\n\told_adj_index = nhgi->adj_index;\n\told_ecmp_size = nhgi->ecmp_size;\n\tnhgi->adj_index_valid = 1;\n\tnhgi->adj_index = adj_index;\n\tnhgi->ecmp_size = ecmp_size;\n\tmlxsw_sp_nexthop_group_rebalance(nhgi);\n\terr = mlxsw_sp_nexthop_group_update(mlxsw_sp, nhgi, true);\n\tif (err) {\n\t\tdev_warn(mlxsw_sp->bus_info->dev, \"Failed to update neigh MAC in adjacency table.\\n\");\n\t\tgoto set_trap;\n\t}\n\n\tmlxsw_sp_nexthop_group_offload_refresh(mlxsw_sp, nh_grp);\n\n\tif (!old_adj_index_valid) {\n\t\t \n\t\terr = mlxsw_sp_nexthop_fib_entries_update(mlxsw_sp, nh_grp);\n\t\tif (err) {\n\t\t\tdev_warn(mlxsw_sp->bus_info->dev, \"Failed to add adjacency index to fib entries.\\n\");\n\t\t\tgoto set_trap;\n\t\t}\n\t\treturn 0;\n\t}\n\n\terr = mlxsw_sp_adj_index_mass_update(mlxsw_sp, nh_grp,\n\t\t\t\t\t     old_adj_index, old_ecmp_size);\n\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ADJ,\n\t\t\t   old_ecmp_size, old_adj_index);\n\tif (err) {\n\t\tdev_warn(mlxsw_sp->bus_info->dev, \"Failed to mass-update adjacency index for nexthop group.\\n\");\n\t\tgoto set_trap;\n\t}\n\n\treturn 0;\n\nset_trap:\n\told_adj_index_valid = nhgi->adj_index_valid;\n\tnhgi->adj_index_valid = 0;\n\tfor (i = 0; i < nhgi->count; i++) {\n\t\tnh = &nhgi->nexthops[i];\n\t\tnh->offloaded = 0;\n\t}\n\terr2 = mlxsw_sp_nexthop_fib_entries_update(mlxsw_sp, nh_grp);\n\tif (err2)\n\t\tdev_warn(mlxsw_sp->bus_info->dev, \"Failed to set traps for fib entries.\\n\");\n\tmlxsw_sp_nexthop_group_offload_refresh(mlxsw_sp, nh_grp);\n\tif (old_adj_index_valid)\n\t\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ADJ,\n\t\t\t\t   nhgi->ecmp_size, nhgi->adj_index);\n\treturn err;\n}\n\nstatic void __mlxsw_sp_nexthop_neigh_update(struct mlxsw_sp_nexthop *nh,\n\t\t\t\t\t    bool removing)\n{\n\tif (!removing) {\n\t\tnh->action = MLXSW_SP_NEXTHOP_ACTION_FORWARD;\n\t\tnh->should_offload = 1;\n\t} else if (nh->nhgi->is_resilient) {\n\t\tnh->action = MLXSW_SP_NEXTHOP_ACTION_TRAP;\n\t\tnh->should_offload = 1;\n\t} else {\n\t\tnh->should_offload = 0;\n\t}\n\tnh->update = 1;\n}\n\nstatic int\nmlxsw_sp_nexthop_dead_neigh_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_neigh_entry *neigh_entry)\n{\n\tstruct neighbour *n, *old_n = neigh_entry->key.n;\n\tstruct mlxsw_sp_nexthop *nh;\n\tstruct net_device *dev;\n\tbool entry_connected;\n\tu8 nud_state, dead;\n\tint err;\n\n\tnh = list_first_entry(&neigh_entry->nexthop_list,\n\t\t\t      struct mlxsw_sp_nexthop, neigh_list_node);\n\tdev = mlxsw_sp_nexthop_dev(nh);\n\n\tn = neigh_lookup(nh->neigh_tbl, &nh->gw_addr, dev);\n\tif (!n) {\n\t\tn = neigh_create(nh->neigh_tbl, &nh->gw_addr, dev);\n\t\tif (IS_ERR(n))\n\t\t\treturn PTR_ERR(n);\n\t\tneigh_event_send(n, NULL);\n\t}\n\n\tmlxsw_sp_neigh_entry_remove(mlxsw_sp, neigh_entry);\n\tneigh_entry->key.n = n;\n\terr = mlxsw_sp_neigh_entry_insert(mlxsw_sp, neigh_entry);\n\tif (err)\n\t\tgoto err_neigh_entry_insert;\n\n\tread_lock_bh(&n->lock);\n\tnud_state = n->nud_state;\n\tdead = n->dead;\n\tread_unlock_bh(&n->lock);\n\tentry_connected = nud_state & NUD_VALID && !dead;\n\n\tlist_for_each_entry(nh, &neigh_entry->nexthop_list,\n\t\t\t    neigh_list_node) {\n\t\tneigh_release(old_n);\n\t\tneigh_clone(n);\n\t\t__mlxsw_sp_nexthop_neigh_update(nh, !entry_connected);\n\t\tmlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh->nhgi->nh_grp);\n\t}\n\n\tneigh_release(n);\n\n\treturn 0;\n\nerr_neigh_entry_insert:\n\tneigh_entry->key.n = old_n;\n\tmlxsw_sp_neigh_entry_insert(mlxsw_sp, neigh_entry);\n\tneigh_release(n);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_nexthop_neigh_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_neigh_entry *neigh_entry,\n\t\t\t      bool removing, bool dead)\n{\n\tstruct mlxsw_sp_nexthop *nh;\n\n\tif (list_empty(&neigh_entry->nexthop_list))\n\t\treturn;\n\n\tif (dead) {\n\t\tint err;\n\n\t\terr = mlxsw_sp_nexthop_dead_neigh_replace(mlxsw_sp,\n\t\t\t\t\t\t\t  neigh_entry);\n\t\tif (err)\n\t\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to replace dead neigh\\n\");\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(nh, &neigh_entry->nexthop_list,\n\t\t\t    neigh_list_node) {\n\t\t__mlxsw_sp_nexthop_neigh_update(nh, removing);\n\t\tmlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh->nhgi->nh_grp);\n\t}\n}\n\nstatic void mlxsw_sp_nexthop_crif_init(struct mlxsw_sp_nexthop *nh,\n\t\t\t\t       struct mlxsw_sp_crif *crif)\n{\n\tif (nh->crif)\n\t\treturn;\n\n\tnh->crif = crif;\n\tlist_add(&nh->crif_list_node, &crif->nexthop_list);\n}\n\nstatic void mlxsw_sp_nexthop_crif_fini(struct mlxsw_sp_nexthop *nh)\n{\n\tif (!nh->crif)\n\t\treturn;\n\n\tlist_del(&nh->crif_list_node);\n\tnh->crif = NULL;\n}\n\nstatic int mlxsw_sp_nexthop_neigh_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_nexthop *nh)\n{\n\tstruct mlxsw_sp_neigh_entry *neigh_entry;\n\tstruct net_device *dev;\n\tstruct neighbour *n;\n\tu8 nud_state, dead;\n\tint err;\n\n\tif (WARN_ON(!nh->crif->rif))\n\t\treturn 0;\n\n\tif (!nh->nhgi->gateway || nh->neigh_entry)\n\t\treturn 0;\n\tdev = mlxsw_sp_nexthop_dev(nh);\n\n\t \n\tn = neigh_lookup(nh->neigh_tbl, &nh->gw_addr, dev);\n\tif (!n) {\n\t\tn = neigh_create(nh->neigh_tbl, &nh->gw_addr, dev);\n\t\tif (IS_ERR(n))\n\t\t\treturn PTR_ERR(n);\n\t\tneigh_event_send(n, NULL);\n\t}\n\tneigh_entry = mlxsw_sp_neigh_entry_lookup(mlxsw_sp, n);\n\tif (!neigh_entry) {\n\t\tneigh_entry = mlxsw_sp_neigh_entry_create(mlxsw_sp, n);\n\t\tif (IS_ERR(neigh_entry)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_neigh_entry_create;\n\t\t}\n\t}\n\n\t \n\tif (list_empty(&neigh_entry->nexthop_list))\n\t\tlist_add_tail(&neigh_entry->nexthop_neighs_list_node,\n\t\t\t      &mlxsw_sp->router->nexthop_neighs_list);\n\n\tnh->neigh_entry = neigh_entry;\n\tlist_add_tail(&nh->neigh_list_node, &neigh_entry->nexthop_list);\n\tread_lock_bh(&n->lock);\n\tnud_state = n->nud_state;\n\tdead = n->dead;\n\tread_unlock_bh(&n->lock);\n\t__mlxsw_sp_nexthop_neigh_update(nh, !(nud_state & NUD_VALID && !dead));\n\n\treturn 0;\n\nerr_neigh_entry_create:\n\tneigh_release(n);\n\treturn err;\n}\n\nstatic void mlxsw_sp_nexthop_neigh_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_nexthop *nh)\n{\n\tstruct mlxsw_sp_neigh_entry *neigh_entry = nh->neigh_entry;\n\tstruct neighbour *n;\n\n\tif (!neigh_entry)\n\t\treturn;\n\tn = neigh_entry->key.n;\n\n\t__mlxsw_sp_nexthop_neigh_update(nh, true);\n\tlist_del(&nh->neigh_list_node);\n\tnh->neigh_entry = NULL;\n\n\t \n\tif (list_empty(&neigh_entry->nexthop_list))\n\t\tlist_del(&neigh_entry->nexthop_neighs_list_node);\n\n\tif (!neigh_entry->connected && list_empty(&neigh_entry->nexthop_list))\n\t\tmlxsw_sp_neigh_entry_destroy(mlxsw_sp, neigh_entry);\n\n\tneigh_release(n);\n}\n\nstatic bool mlxsw_sp_ipip_netdev_ul_up(struct net_device *ol_dev)\n{\n\tstruct net_device *ul_dev;\n\tbool is_up;\n\n\trcu_read_lock();\n\tul_dev = mlxsw_sp_ipip_netdev_ul_dev_get(ol_dev);\n\tis_up = ul_dev ? (ul_dev->flags & IFF_UP) : true;\n\trcu_read_unlock();\n\n\treturn is_up;\n}\n\nstatic void mlxsw_sp_nexthop_ipip_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_nexthop *nh,\n\t\t\t\t       struct mlxsw_sp_ipip_entry *ipip_entry)\n{\n\tstruct mlxsw_sp_crif *crif;\n\tbool removing;\n\n\tif (!nh->nhgi->gateway || nh->ipip_entry)\n\t\treturn;\n\n\tcrif = mlxsw_sp_crif_lookup(mlxsw_sp->router, ipip_entry->ol_dev);\n\tif (WARN_ON(!crif))\n\t\treturn;\n\n\tnh->ipip_entry = ipip_entry;\n\tremoving = !mlxsw_sp_ipip_netdev_ul_up(ipip_entry->ol_dev);\n\t__mlxsw_sp_nexthop_neigh_update(nh, removing);\n\tmlxsw_sp_nexthop_crif_init(nh, crif);\n}\n\nstatic void mlxsw_sp_nexthop_ipip_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_nexthop *nh)\n{\n\tstruct mlxsw_sp_ipip_entry *ipip_entry = nh->ipip_entry;\n\n\tif (!ipip_entry)\n\t\treturn;\n\n\t__mlxsw_sp_nexthop_neigh_update(nh, true);\n\tnh->ipip_entry = NULL;\n}\n\nstatic bool mlxsw_sp_nexthop4_ipip_type(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tconst struct fib_nh *fib_nh,\n\t\t\t\t\tenum mlxsw_sp_ipip_type *p_ipipt)\n{\n\tstruct net_device *dev = fib_nh->fib_nh_dev;\n\n\treturn dev &&\n\t       fib_nh->nh_parent->fib_type == RTN_UNICAST &&\n\t       mlxsw_sp_netdev_ipip_type(mlxsw_sp, dev, p_ipipt);\n}\n\nstatic int mlxsw_sp_nexthop_type_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct mlxsw_sp_nexthop *nh,\n\t\t\t\t      const struct net_device *dev)\n{\n\tconst struct mlxsw_sp_ipip_ops *ipip_ops;\n\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\tstruct mlxsw_sp_crif *crif;\n\tint err;\n\n\tipip_entry = mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, dev);\n\tif (ipip_entry) {\n\t\tipip_ops = mlxsw_sp->router->ipip_ops_arr[ipip_entry->ipipt];\n\t\tif (ipip_ops->can_offload(mlxsw_sp, dev)) {\n\t\t\tnh->type = MLXSW_SP_NEXTHOP_TYPE_IPIP;\n\t\t\tmlxsw_sp_nexthop_ipip_init(mlxsw_sp, nh, ipip_entry);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tnh->type = MLXSW_SP_NEXTHOP_TYPE_ETH;\n\tcrif = mlxsw_sp_crif_lookup(mlxsw_sp->router, dev);\n\tif (!crif)\n\t\treturn 0;\n\n\tmlxsw_sp_nexthop_crif_init(nh, crif);\n\n\tif (!crif->rif)\n\t\treturn 0;\n\n\terr = mlxsw_sp_nexthop_neigh_init(mlxsw_sp, nh);\n\tif (err)\n\t\tgoto err_neigh_init;\n\n\treturn 0;\n\nerr_neigh_init:\n\tmlxsw_sp_nexthop_crif_fini(nh);\n\treturn err;\n}\n\nstatic int mlxsw_sp_nexthop_type_rif_made(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct mlxsw_sp_nexthop *nh)\n{\n\tswitch (nh->type) {\n\tcase MLXSW_SP_NEXTHOP_TYPE_ETH:\n\t\treturn mlxsw_sp_nexthop_neigh_init(mlxsw_sp, nh);\n\tcase MLXSW_SP_NEXTHOP_TYPE_IPIP:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_nexthop_type_rif_gone(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   struct mlxsw_sp_nexthop *nh)\n{\n\tswitch (nh->type) {\n\tcase MLXSW_SP_NEXTHOP_TYPE_ETH:\n\t\tmlxsw_sp_nexthop_neigh_fini(mlxsw_sp, nh);\n\t\tbreak;\n\tcase MLXSW_SP_NEXTHOP_TYPE_IPIP:\n\t\tmlxsw_sp_nexthop_ipip_fini(mlxsw_sp, nh);\n\t\tbreak;\n\t}\n}\n\nstatic void mlxsw_sp_nexthop_type_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_nexthop *nh)\n{\n\tmlxsw_sp_nexthop_type_rif_gone(mlxsw_sp, nh);\n\tmlxsw_sp_nexthop_crif_fini(nh);\n}\n\nstatic int mlxsw_sp_nexthop4_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t\t  struct mlxsw_sp_nexthop *nh,\n\t\t\t\t  struct fib_nh *fib_nh)\n{\n\tstruct net_device *dev = fib_nh->fib_nh_dev;\n\tstruct in_device *in_dev;\n\tint err;\n\n\tnh->nhgi = nh_grp->nhgi;\n\tnh->key.fib_nh = fib_nh;\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\tnh->nh_weight = fib_nh->fib_nh_weight;\n#else\n\tnh->nh_weight = 1;\n#endif\n\tmemcpy(&nh->gw_addr, &fib_nh->fib_nh_gw4, sizeof(fib_nh->fib_nh_gw4));\n\tnh->neigh_tbl = &arp_tbl;\n\terr = mlxsw_sp_nexthop_insert(mlxsw_sp, nh);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_sp_nexthop_counter_alloc(mlxsw_sp, nh);\n\tlist_add_tail(&nh->router_list_node, &mlxsw_sp->router->nexthop_list);\n\n\tif (!dev)\n\t\treturn 0;\n\tnh->ifindex = dev->ifindex;\n\n\trcu_read_lock();\n\tin_dev = __in_dev_get_rcu(dev);\n\tif (in_dev && IN_DEV_IGNORE_ROUTES_WITH_LINKDOWN(in_dev) &&\n\t    fib_nh->fib_nh_flags & RTNH_F_LINKDOWN) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\terr = mlxsw_sp_nexthop_type_init(mlxsw_sp, nh, dev);\n\tif (err)\n\t\tgoto err_nexthop_neigh_init;\n\n\treturn 0;\n\nerr_nexthop_neigh_init:\n\tlist_del(&nh->router_list_node);\n\tmlxsw_sp_nexthop_counter_free(mlxsw_sp, nh);\n\tmlxsw_sp_nexthop_remove(mlxsw_sp, nh);\n\treturn err;\n}\n\nstatic void mlxsw_sp_nexthop4_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_nexthop *nh)\n{\n\tmlxsw_sp_nexthop_type_fini(mlxsw_sp, nh);\n\tlist_del(&nh->router_list_node);\n\tmlxsw_sp_nexthop_counter_free(mlxsw_sp, nh);\n\tmlxsw_sp_nexthop_remove(mlxsw_sp, nh);\n}\n\nstatic void mlxsw_sp_nexthop4_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    unsigned long event, struct fib_nh *fib_nh)\n{\n\tstruct mlxsw_sp_nexthop_key key;\n\tstruct mlxsw_sp_nexthop *nh;\n\n\tkey.fib_nh = fib_nh;\n\tnh = mlxsw_sp_nexthop_lookup(mlxsw_sp, key);\n\tif (!nh)\n\t\treturn;\n\n\tswitch (event) {\n\tcase FIB_EVENT_NH_ADD:\n\t\tmlxsw_sp_nexthop_type_init(mlxsw_sp, nh, fib_nh->fib_nh_dev);\n\t\tbreak;\n\tcase FIB_EVENT_NH_DEL:\n\t\tmlxsw_sp_nexthop_type_fini(mlxsw_sp, nh);\n\t\tbreak;\n\t}\n\n\tmlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh->nhgi->nh_grp);\n}\n\nstatic void mlxsw_sp_nexthop_rif_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_rif *rif)\n{\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tstruct mlxsw_sp_nexthop *nh;\n\tbool removing;\n\n\tlist_for_each_entry(nh, &rif->crif->nexthop_list, crif_list_node) {\n\t\tswitch (nh->type) {\n\t\tcase MLXSW_SP_NEXTHOP_TYPE_ETH:\n\t\t\tremoving = false;\n\t\t\tbreak;\n\t\tcase MLXSW_SP_NEXTHOP_TYPE_IPIP:\n\t\t\tremoving = !mlxsw_sp_ipip_netdev_ul_up(dev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t__mlxsw_sp_nexthop_neigh_update(nh, removing);\n\t\tmlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh->nhgi->nh_grp);\n\t}\n}\n\nstatic int mlxsw_sp_nexthop_rif_made_sync(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp_nexthop *nh, *tmp;\n\tunsigned int n = 0;\n\tint err;\n\n\tlist_for_each_entry_safe(nh, tmp, &rif->crif->nexthop_list,\n\t\t\t\t crif_list_node) {\n\t\terr = mlxsw_sp_nexthop_type_rif_made(mlxsw_sp, nh);\n\t\tif (err)\n\t\t\tgoto err_nexthop_type_rif;\n\t\tmlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh->nhgi->nh_grp);\n\t\tn++;\n\t}\n\n\treturn 0;\n\nerr_nexthop_type_rif:\n\tlist_for_each_entry_safe(nh, tmp, &rif->crif->nexthop_list,\n\t\t\t\t crif_list_node) {\n\t\tif (!n--)\n\t\t\tbreak;\n\t\tmlxsw_sp_nexthop_type_rif_gone(mlxsw_sp, nh);\n\t\tmlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh->nhgi->nh_grp);\n\t}\n\treturn err;\n}\n\nstatic void mlxsw_sp_nexthop_rif_gone_sync(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp_nexthop *nh, *tmp;\n\n\tlist_for_each_entry_safe(nh, tmp, &rif->crif->nexthop_list,\n\t\t\t\t crif_list_node) {\n\t\tmlxsw_sp_nexthop_type_rif_gone(mlxsw_sp, nh);\n\t\tmlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh->nhgi->nh_grp);\n\t}\n}\n\nstatic int mlxsw_sp_adj_trap_entry_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tenum mlxsw_reg_ratr_trap_action trap_action;\n\tchar ratr_pl[MLXSW_REG_RATR_LEN];\n\tint err;\n\n\terr = mlxsw_sp_kvdl_alloc(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ADJ, 1,\n\t\t\t\t  &mlxsw_sp->router->adj_trap_index);\n\tif (err)\n\t\treturn err;\n\n\ttrap_action = MLXSW_REG_RATR_TRAP_ACTION_TRAP;\n\tmlxsw_reg_ratr_pack(ratr_pl, MLXSW_REG_RATR_OP_WRITE_WRITE_ENTRY, true,\n\t\t\t    MLXSW_REG_RATR_TYPE_ETHERNET,\n\t\t\t    mlxsw_sp->router->adj_trap_index,\n\t\t\t    mlxsw_sp->router->lb_crif->rif->rif_index);\n\tmlxsw_reg_ratr_trap_action_set(ratr_pl, trap_action);\n\tmlxsw_reg_ratr_trap_id_set(ratr_pl, MLXSW_TRAP_ID_RTR_EGRESS0);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ratr), ratr_pl);\n\tif (err)\n\t\tgoto err_ratr_write;\n\n\treturn 0;\n\nerr_ratr_write:\n\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ADJ, 1,\n\t\t\t   mlxsw_sp->router->adj_trap_index);\n\treturn err;\n}\n\nstatic void mlxsw_sp_adj_trap_entry_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ADJ, 1,\n\t\t\t   mlxsw_sp->router->adj_trap_index);\n}\n\nstatic int mlxsw_sp_nexthop_group_inc(struct mlxsw_sp *mlxsw_sp)\n{\n\tint err;\n\n\tif (refcount_inc_not_zero(&mlxsw_sp->router->num_groups))\n\t\treturn 0;\n\n\terr = mlxsw_sp_adj_trap_entry_init(mlxsw_sp);\n\tif (err)\n\t\treturn err;\n\n\trefcount_set(&mlxsw_sp->router->num_groups, 1);\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_nexthop_group_dec(struct mlxsw_sp *mlxsw_sp)\n{\n\tif (!refcount_dec_and_test(&mlxsw_sp->router->num_groups))\n\t\treturn;\n\n\tmlxsw_sp_adj_trap_entry_fini(mlxsw_sp);\n}\n\nstatic void\nmlxsw_sp_nh_grp_activity_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     const struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t     unsigned long *activity)\n{\n\tchar *ratrad_pl;\n\tint i, err;\n\n\tratrad_pl = kmalloc(MLXSW_REG_RATRAD_LEN, GFP_KERNEL);\n\tif (!ratrad_pl)\n\t\treturn;\n\n\tmlxsw_reg_ratrad_pack(ratrad_pl, nh_grp->nhgi->adj_index,\n\t\t\t      nh_grp->nhgi->count);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ratrad), ratrad_pl);\n\tif (err)\n\t\tgoto out;\n\n\tfor (i = 0; i < nh_grp->nhgi->count; i++) {\n\t\tif (!mlxsw_reg_ratrad_activity_vector_get(ratrad_pl, i))\n\t\t\tcontinue;\n\t\tbitmap_set(activity, i, 1);\n\t}\n\nout:\n\tkfree(ratrad_pl);\n}\n\n#define MLXSW_SP_NH_GRP_ACTIVITY_UPDATE_INTERVAL 1000  \n\nstatic void\nmlxsw_sp_nh_grp_activity_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tconst struct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tunsigned long *activity;\n\n\tactivity = bitmap_zalloc(nh_grp->nhgi->count, GFP_KERNEL);\n\tif (!activity)\n\t\treturn;\n\n\tmlxsw_sp_nh_grp_activity_get(mlxsw_sp, nh_grp, activity);\n\tnexthop_res_grp_activity_update(mlxsw_sp_net(mlxsw_sp), nh_grp->obj.id,\n\t\t\t\t\tnh_grp->nhgi->count, activity);\n\n\tbitmap_free(activity);\n}\n\nstatic void\nmlxsw_sp_nh_grp_activity_work_schedule(struct mlxsw_sp *mlxsw_sp)\n{\n\tunsigned int interval = MLXSW_SP_NH_GRP_ACTIVITY_UPDATE_INTERVAL;\n\n\tmlxsw_core_schedule_dw(&mlxsw_sp->router->nh_grp_activity_dw,\n\t\t\t       msecs_to_jiffies(interval));\n}\n\nstatic void mlxsw_sp_nh_grp_activity_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_nexthop_group_info *nhgi;\n\tstruct mlxsw_sp_router *router;\n\tbool reschedule = false;\n\n\trouter = container_of(work, struct mlxsw_sp_router,\n\t\t\t      nh_grp_activity_dw.work);\n\n\tmutex_lock(&router->lock);\n\n\tlist_for_each_entry(nhgi, &router->nh_res_grp_list, list) {\n\t\tmlxsw_sp_nh_grp_activity_update(router->mlxsw_sp, nhgi->nh_grp);\n\t\treschedule = true;\n\t}\n\n\tmutex_unlock(&router->lock);\n\n\tif (!reschedule)\n\t\treturn;\n\tmlxsw_sp_nh_grp_activity_work_schedule(router->mlxsw_sp);\n}\n\nstatic int\nmlxsw_sp_nexthop_obj_single_validate(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     const struct nh_notifier_single_info *nh,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tint err = -EINVAL;\n\n\tif (nh->is_fdb)\n\t\tNL_SET_ERR_MSG_MOD(extack, \"FDB nexthops are not supported\");\n\telse if (nh->has_encap)\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Encapsulating nexthops are not supported\");\n\telse\n\t\terr = 0;\n\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_nexthop_obj_group_entry_validate(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  const struct nh_notifier_single_info *nh,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\terr = mlxsw_sp_nexthop_obj_single_validate(mlxsw_sp, nh, extack);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!nh->gw_family && !nh->is_reject &&\n\t    !mlxsw_sp_netdev_ipip_type(mlxsw_sp, nh->dev, NULL)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Nexthop group entry does not have a gateway\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_nexthop_obj_group_validate(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    const struct nh_notifier_grp_info *nh_grp,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tint i;\n\n\tif (nh_grp->is_fdb) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"FDB nexthop groups are not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < nh_grp->num_nh; i++) {\n\t\tconst struct nh_notifier_single_info *nh;\n\t\tint err;\n\n\t\tnh = &nh_grp->nh_entries[i].nh;\n\t\terr = mlxsw_sp_nexthop_obj_group_entry_validate(mlxsw_sp, nh,\n\t\t\t\t\t\t\t\textack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_nexthop_obj_res_group_size_validate(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t     const struct nh_notifier_res_table_info *nh_res_table,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tunsigned int alloc_size;\n\tbool valid_size = false;\n\tint err, i;\n\n\tif (nh_res_table->num_nh_buckets < 32) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Minimum number of buckets is 32\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < mlxsw_sp->router->adj_grp_size_ranges_count; i++) {\n\t\tconst struct mlxsw_sp_adj_grp_size_range *size_range;\n\n\t\tsize_range = &mlxsw_sp->router->adj_grp_size_ranges[i];\n\n\t\tif (nh_res_table->num_nh_buckets >= size_range->start &&\n\t\t    nh_res_table->num_nh_buckets <= size_range->end) {\n\t\t\tvalid_size = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!valid_size) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid number of buckets\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = mlxsw_sp_kvdl_alloc_count_query(mlxsw_sp,\n\t\t\t\t\t      MLXSW_SP_KVDL_ENTRY_TYPE_ADJ,\n\t\t\t\t\t      nh_res_table->num_nh_buckets,\n\t\t\t\t\t      &alloc_size);\n\tif (err || nh_res_table->num_nh_buckets != alloc_size) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Number of buckets does not fit allocation size of any KVDL partition\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_nexthop_obj_res_group_validate(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tconst struct nh_notifier_res_table_info *nh_res_table,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tint err;\n\tu16 i;\n\n\terr = mlxsw_sp_nexthop_obj_res_group_size_validate(mlxsw_sp,\n\t\t\t\t\t\t\t   nh_res_table,\n\t\t\t\t\t\t\t   extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < nh_res_table->num_nh_buckets; i++) {\n\t\tconst struct nh_notifier_single_info *nh;\n\t\tint err;\n\n\t\tnh = &nh_res_table->nhs[i];\n\t\terr = mlxsw_sp_nexthop_obj_group_entry_validate(mlxsw_sp, nh,\n\t\t\t\t\t\t\t\textack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_nexthop_obj_validate(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t unsigned long event,\n\t\t\t\t\t struct nh_notifier_info *info)\n{\n\tstruct nh_notifier_single_info *nh;\n\n\tif (event != NEXTHOP_EVENT_REPLACE &&\n\t    event != NEXTHOP_EVENT_RES_TABLE_PRE_REPLACE &&\n\t    event != NEXTHOP_EVENT_BUCKET_REPLACE)\n\t\treturn 0;\n\n\tswitch (info->type) {\n\tcase NH_NOTIFIER_INFO_TYPE_SINGLE:\n\t\treturn mlxsw_sp_nexthop_obj_single_validate(mlxsw_sp, info->nh,\n\t\t\t\t\t\t\t    info->extack);\n\tcase NH_NOTIFIER_INFO_TYPE_GRP:\n\t\treturn mlxsw_sp_nexthop_obj_group_validate(mlxsw_sp,\n\t\t\t\t\t\t\t   info->nh_grp,\n\t\t\t\t\t\t\t   info->extack);\n\tcase NH_NOTIFIER_INFO_TYPE_RES_TABLE:\n\t\treturn mlxsw_sp_nexthop_obj_res_group_validate(mlxsw_sp,\n\t\t\t\t\t\t\t       info->nh_res_table,\n\t\t\t\t\t\t\t       info->extack);\n\tcase NH_NOTIFIER_INFO_TYPE_RES_BUCKET:\n\t\tnh = &info->nh_res_bucket->new_nh;\n\t\treturn mlxsw_sp_nexthop_obj_group_entry_validate(mlxsw_sp, nh,\n\t\t\t\t\t\t\t\t info->extack);\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"Unsupported nexthop type\");\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic bool mlxsw_sp_nexthop_obj_is_gateway(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    const struct nh_notifier_info *info)\n{\n\tconst struct net_device *dev;\n\n\tswitch (info->type) {\n\tcase NH_NOTIFIER_INFO_TYPE_SINGLE:\n\t\tdev = info->nh->dev;\n\t\treturn info->nh->gw_family || info->nh->is_reject ||\n\t\t       mlxsw_sp_netdev_ipip_type(mlxsw_sp, dev, NULL);\n\tcase NH_NOTIFIER_INFO_TYPE_GRP:\n\tcase NH_NOTIFIER_INFO_TYPE_RES_TABLE:\n\t\t \n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void mlxsw_sp_nexthop_obj_blackhole_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tstruct mlxsw_sp_nexthop *nh)\n{\n\tnh->action = MLXSW_SP_NEXTHOP_ACTION_DISCARD;\n\tnh->should_offload = 1;\n\t \n\tnh->crif = mlxsw_sp->router->lb_crif;\n}\n\nstatic void mlxsw_sp_nexthop_obj_blackhole_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tstruct mlxsw_sp_nexthop *nh)\n{\n\tnh->crif = NULL;\n\tnh->should_offload = 0;\n}\n\nstatic int\nmlxsw_sp_nexthop_obj_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t  struct mlxsw_sp_nexthop *nh,\n\t\t\t  struct nh_notifier_single_info *nh_obj, int weight)\n{\n\tstruct net_device *dev = nh_obj->dev;\n\tint err;\n\n\tnh->nhgi = nh_grp->nhgi;\n\tnh->nh_weight = weight;\n\n\tswitch (nh_obj->gw_family) {\n\tcase AF_INET:\n\t\tmemcpy(&nh->gw_addr, &nh_obj->ipv4, sizeof(nh_obj->ipv4));\n\t\tnh->neigh_tbl = &arp_tbl;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tmemcpy(&nh->gw_addr, &nh_obj->ipv6, sizeof(nh_obj->ipv6));\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tnh->neigh_tbl = &nd_tbl;\n#endif\n\t\tbreak;\n\t}\n\n\tmlxsw_sp_nexthop_counter_alloc(mlxsw_sp, nh);\n\tlist_add_tail(&nh->router_list_node, &mlxsw_sp->router->nexthop_list);\n\tnh->ifindex = dev->ifindex;\n\n\terr = mlxsw_sp_nexthop_type_init(mlxsw_sp, nh, dev);\n\tif (err)\n\t\tgoto err_type_init;\n\n\tif (nh_obj->is_reject)\n\t\tmlxsw_sp_nexthop_obj_blackhole_init(mlxsw_sp, nh);\n\n\t \n\tif (nh_grp->nhgi->is_resilient && !nh->should_offload) {\n\t\tnh->action = MLXSW_SP_NEXTHOP_ACTION_TRAP;\n\t\tnh->should_offload = 1;\n\t}\n\n\treturn 0;\n\nerr_type_init:\n\tlist_del(&nh->router_list_node);\n\tmlxsw_sp_nexthop_counter_free(mlxsw_sp, nh);\n\treturn err;\n}\n\nstatic void mlxsw_sp_nexthop_obj_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct mlxsw_sp_nexthop *nh)\n{\n\tif (nh->action == MLXSW_SP_NEXTHOP_ACTION_DISCARD)\n\t\tmlxsw_sp_nexthop_obj_blackhole_fini(mlxsw_sp, nh);\n\tmlxsw_sp_nexthop_type_fini(mlxsw_sp, nh);\n\tlist_del(&nh->router_list_node);\n\tmlxsw_sp_nexthop_counter_free(mlxsw_sp, nh);\n\tnh->should_offload = 0;\n}\n\nstatic int\nmlxsw_sp_nexthop_obj_group_info_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t\t     struct nh_notifier_info *info)\n{\n\tstruct mlxsw_sp_nexthop_group_info *nhgi;\n\tstruct mlxsw_sp_nexthop *nh;\n\tbool is_resilient = false;\n\tunsigned int nhs;\n\tint err, i;\n\n\tswitch (info->type) {\n\tcase NH_NOTIFIER_INFO_TYPE_SINGLE:\n\t\tnhs = 1;\n\t\tbreak;\n\tcase NH_NOTIFIER_INFO_TYPE_GRP:\n\t\tnhs = info->nh_grp->num_nh;\n\t\tbreak;\n\tcase NH_NOTIFIER_INFO_TYPE_RES_TABLE:\n\t\tnhs = info->nh_res_table->num_nh_buckets;\n\t\tis_resilient = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tnhgi = kzalloc(struct_size(nhgi, nexthops, nhs), GFP_KERNEL);\n\tif (!nhgi)\n\t\treturn -ENOMEM;\n\tnh_grp->nhgi = nhgi;\n\tnhgi->nh_grp = nh_grp;\n\tnhgi->gateway = mlxsw_sp_nexthop_obj_is_gateway(mlxsw_sp, info);\n\tnhgi->is_resilient = is_resilient;\n\tnhgi->count = nhs;\n\tfor (i = 0; i < nhgi->count; i++) {\n\t\tstruct nh_notifier_single_info *nh_obj;\n\t\tint weight;\n\n\t\tnh = &nhgi->nexthops[i];\n\t\tswitch (info->type) {\n\t\tcase NH_NOTIFIER_INFO_TYPE_SINGLE:\n\t\t\tnh_obj = info->nh;\n\t\t\tweight = 1;\n\t\t\tbreak;\n\t\tcase NH_NOTIFIER_INFO_TYPE_GRP:\n\t\t\tnh_obj = &info->nh_grp->nh_entries[i].nh;\n\t\t\tweight = info->nh_grp->nh_entries[i].weight;\n\t\t\tbreak;\n\t\tcase NH_NOTIFIER_INFO_TYPE_RES_TABLE:\n\t\t\tnh_obj = &info->nh_res_table->nhs[i];\n\t\t\tweight = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_nexthop_obj_init;\n\t\t}\n\t\terr = mlxsw_sp_nexthop_obj_init(mlxsw_sp, nh_grp, nh, nh_obj,\n\t\t\t\t\t\tweight);\n\t\tif (err)\n\t\t\tgoto err_nexthop_obj_init;\n\t}\n\terr = mlxsw_sp_nexthop_group_inc(mlxsw_sp);\n\tif (err)\n\t\tgoto err_group_inc;\n\terr = mlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh_grp);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"Failed to write adjacency entries to the device\");\n\t\tgoto err_group_refresh;\n\t}\n\n\t \n\tif (nhgi->is_resilient) {\n\t\tif (list_empty(&mlxsw_sp->router->nh_res_grp_list))\n\t\t\tmlxsw_sp_nh_grp_activity_work_schedule(mlxsw_sp);\n\t\tlist_add(&nhgi->list, &mlxsw_sp->router->nh_res_grp_list);\n\t}\n\n\treturn 0;\n\nerr_group_refresh:\n\tmlxsw_sp_nexthop_group_dec(mlxsw_sp);\nerr_group_inc:\n\ti = nhgi->count;\nerr_nexthop_obj_init:\n\tfor (i--; i >= 0; i--) {\n\t\tnh = &nhgi->nexthops[i];\n\t\tmlxsw_sp_nexthop_obj_fini(mlxsw_sp, nh);\n\t}\n\tkfree(nhgi);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_nexthop_obj_group_info_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tstruct mlxsw_sp_nexthop_group_info *nhgi = nh_grp->nhgi;\n\tstruct mlxsw_sp_router *router = mlxsw_sp->router;\n\tint i;\n\n\tif (nhgi->is_resilient) {\n\t\tlist_del(&nhgi->list);\n\t\tif (list_empty(&mlxsw_sp->router->nh_res_grp_list))\n\t\t\tcancel_delayed_work(&router->nh_grp_activity_dw);\n\t}\n\n\tmlxsw_sp_nexthop_group_dec(mlxsw_sp);\n\tfor (i = nhgi->count - 1; i >= 0; i--) {\n\t\tstruct mlxsw_sp_nexthop *nh = &nhgi->nexthops[i];\n\n\t\tmlxsw_sp_nexthop_obj_fini(mlxsw_sp, nh);\n\t}\n\tmlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh_grp);\n\tWARN_ON_ONCE(nhgi->adj_index_valid);\n\tkfree(nhgi);\n}\n\nstatic struct mlxsw_sp_nexthop_group *\nmlxsw_sp_nexthop_obj_group_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct nh_notifier_info *info)\n{\n\tstruct mlxsw_sp_nexthop_group *nh_grp;\n\tint err;\n\n\tnh_grp = kzalloc(sizeof(*nh_grp), GFP_KERNEL);\n\tif (!nh_grp)\n\t\treturn ERR_PTR(-ENOMEM);\n\tINIT_LIST_HEAD(&nh_grp->vr_list);\n\terr = rhashtable_init(&nh_grp->vr_ht,\n\t\t\t      &mlxsw_sp_nexthop_group_vr_ht_params);\n\tif (err)\n\t\tgoto err_nexthop_group_vr_ht_init;\n\tINIT_LIST_HEAD(&nh_grp->fib_list);\n\tnh_grp->type = MLXSW_SP_NEXTHOP_GROUP_TYPE_OBJ;\n\tnh_grp->obj.id = info->id;\n\n\terr = mlxsw_sp_nexthop_obj_group_info_init(mlxsw_sp, nh_grp, info);\n\tif (err)\n\t\tgoto err_nexthop_group_info_init;\n\n\tnh_grp->can_destroy = false;\n\n\treturn nh_grp;\n\nerr_nexthop_group_info_init:\n\trhashtable_destroy(&nh_grp->vr_ht);\nerr_nexthop_group_vr_ht_init:\n\tkfree(nh_grp);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_nexthop_obj_group_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tif (!nh_grp->can_destroy)\n\t\treturn;\n\tmlxsw_sp_nexthop_obj_group_info_fini(mlxsw_sp, nh_grp);\n\tWARN_ON_ONCE(!list_empty(&nh_grp->fib_list));\n\tWARN_ON_ONCE(!list_empty(&nh_grp->vr_list));\n\trhashtable_destroy(&nh_grp->vr_ht);\n\tkfree(nh_grp);\n}\n\nstatic struct mlxsw_sp_nexthop_group *\nmlxsw_sp_nexthop_obj_group_lookup(struct mlxsw_sp *mlxsw_sp, u32 id)\n{\n\tstruct mlxsw_sp_nexthop_group_cmp_arg cmp_arg;\n\n\tcmp_arg.type = MLXSW_SP_NEXTHOP_GROUP_TYPE_OBJ;\n\tcmp_arg.id = id;\n\treturn rhashtable_lookup_fast(&mlxsw_sp->router->nexthop_group_ht,\n\t\t\t\t      &cmp_arg,\n\t\t\t\t      mlxsw_sp_nexthop_group_ht_params);\n}\n\nstatic int mlxsw_sp_nexthop_obj_group_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct mlxsw_sp_nexthop_group *nh_grp)\n{\n\treturn mlxsw_sp_nexthop_group_insert(mlxsw_sp, nh_grp);\n}\n\nstatic int\nmlxsw_sp_nexthop_obj_group_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t\t   struct mlxsw_sp_nexthop_group *old_nh_grp,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_nexthop_group_info *old_nhgi = old_nh_grp->nhgi;\n\tstruct mlxsw_sp_nexthop_group_info *new_nhgi = nh_grp->nhgi;\n\tint err;\n\n\told_nh_grp->nhgi = new_nhgi;\n\tnew_nhgi->nh_grp = old_nh_grp;\n\tnh_grp->nhgi = old_nhgi;\n\told_nhgi->nh_grp = nh_grp;\n\n\tif (old_nhgi->adj_index_valid && new_nhgi->adj_index_valid) {\n\t\t \n\t\terr = mlxsw_sp_adj_index_mass_update(mlxsw_sp, old_nh_grp,\n\t\t\t\t\t\t     old_nhgi->adj_index,\n\t\t\t\t\t\t     old_nhgi->ecmp_size);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to replace old adjacency index with new one\");\n\t\t\tgoto err_out;\n\t\t}\n\t} else if (old_nhgi->adj_index_valid && !new_nhgi->adj_index_valid) {\n\t\t \n\t\terr = mlxsw_sp_nexthop_fib_entries_update(mlxsw_sp, old_nh_grp);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to update routes to trap packets\");\n\t\t\tgoto err_out;\n\t\t}\n\t} else if (!old_nhgi->adj_index_valid && new_nhgi->adj_index_valid) {\n\t\t \n\t\terr = mlxsw_sp_nexthop_fib_entries_update(mlxsw_sp, old_nh_grp);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to update routes to forward packets\");\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\t \n\tmlxsw_sp_nexthop_obj_group_offload_refresh(mlxsw_sp, old_nh_grp);\n\n\t \n\tnh_grp->can_destroy = true;\n\tmlxsw_sp_nexthop_obj_group_destroy(mlxsw_sp, nh_grp);\n\n\treturn 0;\n\nerr_out:\n\told_nhgi->nh_grp = old_nh_grp;\n\tnh_grp->nhgi = new_nhgi;\n\tnew_nhgi->nh_grp = nh_grp;\n\told_nh_grp->nhgi = old_nhgi;\n\treturn err;\n}\n\nstatic int mlxsw_sp_nexthop_obj_new(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct nh_notifier_info *info)\n{\n\tstruct mlxsw_sp_nexthop_group *nh_grp, *old_nh_grp;\n\tstruct netlink_ext_ack *extack = info->extack;\n\tint err;\n\n\tnh_grp = mlxsw_sp_nexthop_obj_group_create(mlxsw_sp, info);\n\tif (IS_ERR(nh_grp))\n\t\treturn PTR_ERR(nh_grp);\n\n\told_nh_grp = mlxsw_sp_nexthop_obj_group_lookup(mlxsw_sp, info->id);\n\tif (!old_nh_grp)\n\t\terr = mlxsw_sp_nexthop_obj_group_add(mlxsw_sp, nh_grp);\n\telse\n\t\terr = mlxsw_sp_nexthop_obj_group_replace(mlxsw_sp, nh_grp,\n\t\t\t\t\t\t\t old_nh_grp, extack);\n\n\tif (err) {\n\t\tnh_grp->can_destroy = true;\n\t\tmlxsw_sp_nexthop_obj_group_destroy(mlxsw_sp, nh_grp);\n\t}\n\n\treturn err;\n}\n\nstatic void mlxsw_sp_nexthop_obj_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct nh_notifier_info *info)\n{\n\tstruct mlxsw_sp_nexthop_group *nh_grp;\n\n\tnh_grp = mlxsw_sp_nexthop_obj_group_lookup(mlxsw_sp, info->id);\n\tif (!nh_grp)\n\t\treturn;\n\n\tnh_grp->can_destroy = true;\n\tmlxsw_sp_nexthop_group_remove(mlxsw_sp, nh_grp);\n\n\t \n\tif (!list_empty(&nh_grp->fib_list))\n\t\treturn;\n\tmlxsw_sp_nexthop_obj_group_destroy(mlxsw_sp, nh_grp);\n}\n\nstatic int mlxsw_sp_nexthop_obj_bucket_query(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t     u32 adj_index, char *ratr_pl)\n{\n\tMLXSW_REG_ZERO(ratr, ratr_pl);\n\tmlxsw_reg_ratr_op_set(ratr_pl, MLXSW_REG_RATR_OP_QUERY_READ);\n\tmlxsw_reg_ratr_adjacency_index_low_set(ratr_pl, adj_index);\n\tmlxsw_reg_ratr_adjacency_index_high_set(ratr_pl, adj_index >> 16);\n\n\treturn mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ratr), ratr_pl);\n}\n\nstatic int mlxsw_sp_nexthop_obj_bucket_compare(char *ratr_pl, char *ratr_pl_new)\n{\n\t \n\tmlxsw_reg_ratr_op_set(ratr_pl, MLXSW_REG_RATR_OP_QUERY_READ);\n\tmlxsw_reg_ratr_a_set(ratr_pl, 0);\n\tmlxsw_reg_ratr_op_set(ratr_pl_new, MLXSW_REG_RATR_OP_QUERY_READ);\n\tmlxsw_reg_ratr_a_set(ratr_pl_new, 0);\n\n\t \n\tif (!memcmp(ratr_pl, ratr_pl_new, MLXSW_REG_RATR_LEN))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int\nmlxsw_sp_nexthop_obj_bucket_adj_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_nexthop *nh,\n\t\t\t\t       struct nh_notifier_info *info)\n{\n\tu16 bucket_index = info->nh_res_bucket->bucket_index;\n\tstruct netlink_ext_ack *extack = info->extack;\n\tbool force = info->nh_res_bucket->force;\n\tchar ratr_pl_new[MLXSW_REG_RATR_LEN];\n\tchar ratr_pl[MLXSW_REG_RATR_LEN];\n\tu32 adj_index;\n\tint err;\n\n\t \n\tif (!force && info->nh_res_bucket->idle_timer_ms <\n\t    MLXSW_SP_NH_GRP_ACTIVITY_UPDATE_INTERVAL)\n\t\tforce = true;\n\n\tadj_index = nh->nhgi->adj_index + bucket_index;\n\terr = mlxsw_sp_nexthop_update(mlxsw_sp, adj_index, nh, force, ratr_pl);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to overwrite nexthop bucket\");\n\t\treturn err;\n\t}\n\n\tif (!force) {\n\t\terr = mlxsw_sp_nexthop_obj_bucket_query(mlxsw_sp, adj_index,\n\t\t\t\t\t\t\tratr_pl_new);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to query nexthop bucket state after replacement. State might be inconsistent\");\n\t\t\treturn err;\n\t\t}\n\n\t\terr = mlxsw_sp_nexthop_obj_bucket_compare(ratr_pl, ratr_pl_new);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Nexthop bucket was not replaced because it was active during replacement\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tnh->update = 0;\n\tnh->offloaded = 1;\n\tmlxsw_sp_nexthop_bucket_offload_refresh(mlxsw_sp, nh, bucket_index);\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_nexthop_obj_bucket_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t       struct nh_notifier_info *info)\n{\n\tu16 bucket_index = info->nh_res_bucket->bucket_index;\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct mlxsw_sp_nexthop_group_info *nhgi;\n\tstruct nh_notifier_single_info *nh_obj;\n\tstruct mlxsw_sp_nexthop_group *nh_grp;\n\tstruct mlxsw_sp_nexthop *nh;\n\tint err;\n\n\tnh_grp = mlxsw_sp_nexthop_obj_group_lookup(mlxsw_sp, info->id);\n\tif (!nh_grp) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Nexthop group was not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tnhgi = nh_grp->nhgi;\n\n\tif (bucket_index >= nhgi->count) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Nexthop bucket index out of range\");\n\t\treturn -EINVAL;\n\t}\n\n\tnh = &nhgi->nexthops[bucket_index];\n\tmlxsw_sp_nexthop_obj_fini(mlxsw_sp, nh);\n\n\tnh_obj = &info->nh_res_bucket->new_nh;\n\terr = mlxsw_sp_nexthop_obj_init(mlxsw_sp, nh_grp, nh, nh_obj, 1);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to initialize nexthop object for nexthop bucket replacement\");\n\t\tgoto err_nexthop_obj_init;\n\t}\n\n\terr = mlxsw_sp_nexthop_obj_bucket_adj_update(mlxsw_sp, nh, info);\n\tif (err)\n\t\tgoto err_nexthop_obj_bucket_adj_update;\n\n\treturn 0;\n\nerr_nexthop_obj_bucket_adj_update:\n\tmlxsw_sp_nexthop_obj_fini(mlxsw_sp, nh);\nerr_nexthop_obj_init:\n\tnh_obj = &info->nh_res_bucket->old_nh;\n\tmlxsw_sp_nexthop_obj_init(mlxsw_sp, nh_grp, nh, nh_obj, 1);\n\t \n\tnh->update = 0;\n\tnh->offloaded = 1;\n\treturn err;\n}\n\nstatic int mlxsw_sp_nexthop_obj_event(struct notifier_block *nb,\n\t\t\t\t      unsigned long event, void *ptr)\n{\n\tstruct nh_notifier_info *info = ptr;\n\tstruct mlxsw_sp_router *router;\n\tint err = 0;\n\n\trouter = container_of(nb, struct mlxsw_sp_router, nexthop_nb);\n\terr = mlxsw_sp_nexthop_obj_validate(router->mlxsw_sp, event, info);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&router->lock);\n\n\tswitch (event) {\n\tcase NEXTHOP_EVENT_REPLACE:\n\t\terr = mlxsw_sp_nexthop_obj_new(router->mlxsw_sp, info);\n\t\tbreak;\n\tcase NEXTHOP_EVENT_DEL:\n\t\tmlxsw_sp_nexthop_obj_del(router->mlxsw_sp, info);\n\t\tbreak;\n\tcase NEXTHOP_EVENT_BUCKET_REPLACE:\n\t\terr = mlxsw_sp_nexthop_obj_bucket_replace(router->mlxsw_sp,\n\t\t\t\t\t\t\t  info);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&router->lock);\n\nout:\n\treturn notifier_from_errno(err);\n}\n\nstatic bool mlxsw_sp_fi_is_gateway(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct fib_info *fi)\n{\n\tconst struct fib_nh *nh = fib_info_nh(fi, 0);\n\n\treturn nh->fib_nh_gw_family ||\n\t       mlxsw_sp_nexthop4_ipip_type(mlxsw_sp, nh, NULL);\n}\n\nstatic int\nmlxsw_sp_nexthop4_group_info_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tunsigned int nhs = fib_info_num_path(nh_grp->ipv4.fi);\n\tstruct mlxsw_sp_nexthop_group_info *nhgi;\n\tstruct mlxsw_sp_nexthop *nh;\n\tint err, i;\n\n\tnhgi = kzalloc(struct_size(nhgi, nexthops, nhs), GFP_KERNEL);\n\tif (!nhgi)\n\t\treturn -ENOMEM;\n\tnh_grp->nhgi = nhgi;\n\tnhgi->nh_grp = nh_grp;\n\tnhgi->gateway = mlxsw_sp_fi_is_gateway(mlxsw_sp, nh_grp->ipv4.fi);\n\tnhgi->count = nhs;\n\tfor (i = 0; i < nhgi->count; i++) {\n\t\tstruct fib_nh *fib_nh;\n\n\t\tnh = &nhgi->nexthops[i];\n\t\tfib_nh = fib_info_nh(nh_grp->ipv4.fi, i);\n\t\terr = mlxsw_sp_nexthop4_init(mlxsw_sp, nh_grp, nh, fib_nh);\n\t\tif (err)\n\t\t\tgoto err_nexthop4_init;\n\t}\n\terr = mlxsw_sp_nexthop_group_inc(mlxsw_sp);\n\tif (err)\n\t\tgoto err_group_inc;\n\terr = mlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh_grp);\n\tif (err)\n\t\tgoto err_group_refresh;\n\n\treturn 0;\n\nerr_group_refresh:\n\tmlxsw_sp_nexthop_group_dec(mlxsw_sp);\nerr_group_inc:\n\ti = nhgi->count;\nerr_nexthop4_init:\n\tfor (i--; i >= 0; i--) {\n\t\tnh = &nhgi->nexthops[i];\n\t\tmlxsw_sp_nexthop4_fini(mlxsw_sp, nh);\n\t}\n\tkfree(nhgi);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_nexthop4_group_info_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tstruct mlxsw_sp_nexthop_group_info *nhgi = nh_grp->nhgi;\n\tint i;\n\n\tmlxsw_sp_nexthop_group_dec(mlxsw_sp);\n\tfor (i = nhgi->count - 1; i >= 0; i--) {\n\t\tstruct mlxsw_sp_nexthop *nh = &nhgi->nexthops[i];\n\n\t\tmlxsw_sp_nexthop4_fini(mlxsw_sp, nh);\n\t}\n\tmlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh_grp);\n\tWARN_ON_ONCE(nhgi->adj_index_valid);\n\tkfree(nhgi);\n}\n\nstatic struct mlxsw_sp_nexthop_group *\nmlxsw_sp_nexthop4_group_create(struct mlxsw_sp *mlxsw_sp, struct fib_info *fi)\n{\n\tstruct mlxsw_sp_nexthop_group *nh_grp;\n\tint err;\n\n\tnh_grp = kzalloc(sizeof(*nh_grp), GFP_KERNEL);\n\tif (!nh_grp)\n\t\treturn ERR_PTR(-ENOMEM);\n\tINIT_LIST_HEAD(&nh_grp->vr_list);\n\terr = rhashtable_init(&nh_grp->vr_ht,\n\t\t\t      &mlxsw_sp_nexthop_group_vr_ht_params);\n\tif (err)\n\t\tgoto err_nexthop_group_vr_ht_init;\n\tINIT_LIST_HEAD(&nh_grp->fib_list);\n\tnh_grp->type = MLXSW_SP_NEXTHOP_GROUP_TYPE_IPV4;\n\tnh_grp->ipv4.fi = fi;\n\tfib_info_hold(fi);\n\n\terr = mlxsw_sp_nexthop4_group_info_init(mlxsw_sp, nh_grp);\n\tif (err)\n\t\tgoto err_nexthop_group_info_init;\n\n\terr = mlxsw_sp_nexthop_group_insert(mlxsw_sp, nh_grp);\n\tif (err)\n\t\tgoto err_nexthop_group_insert;\n\n\tnh_grp->can_destroy = true;\n\n\treturn nh_grp;\n\nerr_nexthop_group_insert:\n\tmlxsw_sp_nexthop4_group_info_fini(mlxsw_sp, nh_grp);\nerr_nexthop_group_info_init:\n\tfib_info_put(fi);\n\trhashtable_destroy(&nh_grp->vr_ht);\nerr_nexthop_group_vr_ht_init:\n\tkfree(nh_grp);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_nexthop4_group_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tif (!nh_grp->can_destroy)\n\t\treturn;\n\tmlxsw_sp_nexthop_group_remove(mlxsw_sp, nh_grp);\n\tmlxsw_sp_nexthop4_group_info_fini(mlxsw_sp, nh_grp);\n\tfib_info_put(nh_grp->ipv4.fi);\n\tWARN_ON_ONCE(!list_empty(&nh_grp->vr_list));\n\trhashtable_destroy(&nh_grp->vr_ht);\n\tkfree(nh_grp);\n}\n\nstatic int mlxsw_sp_nexthop4_group_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t\t       struct fib_info *fi)\n{\n\tstruct mlxsw_sp_nexthop_group *nh_grp;\n\n\tif (fi->nh) {\n\t\tnh_grp = mlxsw_sp_nexthop_obj_group_lookup(mlxsw_sp,\n\t\t\t\t\t\t\t   fi->nh->id);\n\t\tif (WARN_ON_ONCE(!nh_grp))\n\t\t\treturn -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnh_grp = mlxsw_sp_nexthop4_group_lookup(mlxsw_sp, fi);\n\tif (!nh_grp) {\n\t\tnh_grp = mlxsw_sp_nexthop4_group_create(mlxsw_sp, fi);\n\t\tif (IS_ERR(nh_grp))\n\t\t\treturn PTR_ERR(nh_grp);\n\t}\nout:\n\tlist_add_tail(&fib_entry->nexthop_group_node, &nh_grp->fib_list);\n\tfib_entry->nh_group = nh_grp;\n\treturn 0;\n}\n\nstatic void mlxsw_sp_nexthop4_group_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_fib_entry *fib_entry)\n{\n\tstruct mlxsw_sp_nexthop_group *nh_grp = fib_entry->nh_group;\n\n\tlist_del(&fib_entry->nexthop_group_node);\n\tif (!list_empty(&nh_grp->fib_list))\n\t\treturn;\n\n\tif (nh_grp->type == MLXSW_SP_NEXTHOP_GROUP_TYPE_OBJ) {\n\t\tmlxsw_sp_nexthop_obj_group_destroy(mlxsw_sp, nh_grp);\n\t\treturn;\n\t}\n\n\tmlxsw_sp_nexthop4_group_destroy(mlxsw_sp, nh_grp);\n}\n\nstatic bool\nmlxsw_sp_fib4_entry_should_offload(const struct mlxsw_sp_fib_entry *fib_entry)\n{\n\tstruct mlxsw_sp_fib4_entry *fib4_entry;\n\n\tfib4_entry = container_of(fib_entry, struct mlxsw_sp_fib4_entry,\n\t\t\t\t  common);\n\treturn !fib4_entry->dscp;\n}\n\nstatic bool\nmlxsw_sp_fib_entry_should_offload(const struct mlxsw_sp_fib_entry *fib_entry)\n{\n\tstruct mlxsw_sp_nexthop_group *nh_group = fib_entry->nh_group;\n\n\tswitch (fib_entry->fib_node->fib->proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\tif (!mlxsw_sp_fib4_entry_should_offload(fib_entry))\n\t\t\treturn false;\n\t\tbreak;\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\tbreak;\n\t}\n\n\tswitch (fib_entry->type) {\n\tcase MLXSW_SP_FIB_ENTRY_TYPE_REMOTE:\n\t\treturn !!nh_group->nhgi->adj_index_valid;\n\tcase MLXSW_SP_FIB_ENTRY_TYPE_LOCAL:\n\t\treturn !!mlxsw_sp_nhgi_rif(nh_group->nhgi);\n\tcase MLXSW_SP_FIB_ENTRY_TYPE_BLACKHOLE:\n\tcase MLXSW_SP_FIB_ENTRY_TYPE_IPIP_DECAP:\n\tcase MLXSW_SP_FIB_ENTRY_TYPE_NVE_DECAP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic struct mlxsw_sp_nexthop *\nmlxsw_sp_rt6_nexthop(struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t     const struct mlxsw_sp_rt6 *mlxsw_sp_rt6)\n{\n\tint i;\n\n\tfor (i = 0; i < nh_grp->nhgi->count; i++) {\n\t\tstruct mlxsw_sp_nexthop *nh = &nh_grp->nhgi->nexthops[i];\n\t\tstruct net_device *dev = mlxsw_sp_nexthop_dev(nh);\n\t\tstruct fib6_info *rt = mlxsw_sp_rt6->rt;\n\n\t\tif (dev && dev == rt->fib6_nh->fib_nh_dev &&\n\t\t    ipv6_addr_equal((const struct in6_addr *) &nh->gw_addr,\n\t\t\t\t    &rt->fib6_nh->fib_nh_gw6))\n\t\t\treturn nh;\n\t}\n\n\treturn NULL;\n}\n\nstatic void\nmlxsw_sp_fib4_offload_failed_flag_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct fib_entry_notifier_info *fen_info)\n{\n\tu32 *p_dst = (u32 *) &fen_info->dst;\n\tstruct fib_rt_info fri;\n\n\tfri.fi = fen_info->fi;\n\tfri.tb_id = fen_info->tb_id;\n\tfri.dst = cpu_to_be32(*p_dst);\n\tfri.dst_len = fen_info->dst_len;\n\tfri.dscp = fen_info->dscp;\n\tfri.type = fen_info->type;\n\tfri.offload = false;\n\tfri.trap = false;\n\tfri.offload_failed = true;\n\tfib_alias_hw_flags_set(mlxsw_sp_net(mlxsw_sp), &fri);\n}\n\nstatic void\nmlxsw_sp_fib4_entry_hw_flags_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_fib_entry *fib_entry)\n{\n\tu32 *p_dst = (u32 *) fib_entry->fib_node->key.addr;\n\tint dst_len = fib_entry->fib_node->key.prefix_len;\n\tstruct mlxsw_sp_fib4_entry *fib4_entry;\n\tstruct fib_rt_info fri;\n\tbool should_offload;\n\n\tshould_offload = mlxsw_sp_fib_entry_should_offload(fib_entry);\n\tfib4_entry = container_of(fib_entry, struct mlxsw_sp_fib4_entry,\n\t\t\t\t  common);\n\tfri.fi = fib4_entry->fi;\n\tfri.tb_id = fib4_entry->tb_id;\n\tfri.dst = cpu_to_be32(*p_dst);\n\tfri.dst_len = dst_len;\n\tfri.dscp = fib4_entry->dscp;\n\tfri.type = fib4_entry->type;\n\tfri.offload = should_offload;\n\tfri.trap = !should_offload;\n\tfri.offload_failed = false;\n\tfib_alias_hw_flags_set(mlxsw_sp_net(mlxsw_sp), &fri);\n}\n\nstatic void\nmlxsw_sp_fib4_entry_hw_flags_clear(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_fib_entry *fib_entry)\n{\n\tu32 *p_dst = (u32 *) fib_entry->fib_node->key.addr;\n\tint dst_len = fib_entry->fib_node->key.prefix_len;\n\tstruct mlxsw_sp_fib4_entry *fib4_entry;\n\tstruct fib_rt_info fri;\n\n\tfib4_entry = container_of(fib_entry, struct mlxsw_sp_fib4_entry,\n\t\t\t\t  common);\n\tfri.fi = fib4_entry->fi;\n\tfri.tb_id = fib4_entry->tb_id;\n\tfri.dst = cpu_to_be32(*p_dst);\n\tfri.dst_len = dst_len;\n\tfri.dscp = fib4_entry->dscp;\n\tfri.type = fib4_entry->type;\n\tfri.offload = false;\n\tfri.trap = false;\n\tfri.offload_failed = false;\n\tfib_alias_hw_flags_set(mlxsw_sp_net(mlxsw_sp), &fri);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void\nmlxsw_sp_fib6_offload_failed_flag_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct fib6_info **rt_arr,\n\t\t\t\t      unsigned int nrt6)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < nrt6; i++)\n\t\tfib6_info_hw_flags_set(mlxsw_sp_net(mlxsw_sp), rt_arr[i],\n\t\t\t\t       false, false, true);\n}\n#else\nstatic void\nmlxsw_sp_fib6_offload_failed_flag_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct fib6_info **rt_arr,\n\t\t\t\t      unsigned int nrt6)\n{\n}\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void\nmlxsw_sp_fib6_entry_hw_flags_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_fib_entry *fib_entry)\n{\n\tstruct mlxsw_sp_fib6_entry *fib6_entry;\n\tstruct mlxsw_sp_rt6 *mlxsw_sp_rt6;\n\tbool should_offload;\n\n\tshould_offload = mlxsw_sp_fib_entry_should_offload(fib_entry);\n\n\t \n\tfib6_entry = container_of(fib_entry, struct mlxsw_sp_fib6_entry,\n\t\t\t\t  common);\n\tlist_for_each_entry(mlxsw_sp_rt6, &fib6_entry->rt6_list, list)\n\t\tfib6_info_hw_flags_set(mlxsw_sp_net(mlxsw_sp), mlxsw_sp_rt6->rt,\n\t\t\t\t       should_offload, !should_offload, false);\n}\n#else\nstatic void\nmlxsw_sp_fib6_entry_hw_flags_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_fib_entry *fib_entry)\n{\n}\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void\nmlxsw_sp_fib6_entry_hw_flags_clear(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_fib_entry *fib_entry)\n{\n\tstruct mlxsw_sp_fib6_entry *fib6_entry;\n\tstruct mlxsw_sp_rt6 *mlxsw_sp_rt6;\n\n\tfib6_entry = container_of(fib_entry, struct mlxsw_sp_fib6_entry,\n\t\t\t\t  common);\n\tlist_for_each_entry(mlxsw_sp_rt6, &fib6_entry->rt6_list, list)\n\t\tfib6_info_hw_flags_set(mlxsw_sp_net(mlxsw_sp), mlxsw_sp_rt6->rt,\n\t\t\t\t       false, false, false);\n}\n#else\nstatic void\nmlxsw_sp_fib6_entry_hw_flags_clear(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_fib_entry *fib_entry)\n{\n}\n#endif\n\nstatic void\nmlxsw_sp_fib_entry_hw_flags_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_fib_entry *fib_entry)\n{\n\tswitch (fib_entry->fib_node->fib->proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\tmlxsw_sp_fib4_entry_hw_flags_set(mlxsw_sp, fib_entry);\n\t\tbreak;\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\tmlxsw_sp_fib6_entry_hw_flags_set(mlxsw_sp, fib_entry);\n\t\tbreak;\n\t}\n}\n\nstatic void\nmlxsw_sp_fib_entry_hw_flags_clear(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_fib_entry *fib_entry)\n{\n\tswitch (fib_entry->fib_node->fib->proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\tmlxsw_sp_fib4_entry_hw_flags_clear(mlxsw_sp, fib_entry);\n\t\tbreak;\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\tmlxsw_sp_fib6_entry_hw_flags_clear(mlxsw_sp, fib_entry);\n\t\tbreak;\n\t}\n}\n\nstatic void\nmlxsw_sp_fib_entry_hw_flags_refresh(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t\t    enum mlxsw_reg_ralue_op op)\n{\n\tswitch (op) {\n\tcase MLXSW_REG_RALUE_OP_WRITE_WRITE:\n\t\tmlxsw_sp_fib_entry_hw_flags_set(mlxsw_sp, fib_entry);\n\t\tbreak;\n\tcase MLXSW_REG_RALUE_OP_WRITE_DELETE:\n\t\tmlxsw_sp_fib_entry_hw_flags_clear(mlxsw_sp, fib_entry);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmlxsw_sp_fib_entry_ralue_pack(char *ralue_pl,\n\t\t\t      const struct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t      enum mlxsw_reg_ralue_op op)\n{\n\tstruct mlxsw_sp_fib *fib = fib_entry->fib_node->fib;\n\tenum mlxsw_reg_ralxx_protocol proto;\n\tu32 *p_dip;\n\n\tproto = (enum mlxsw_reg_ralxx_protocol) fib->proto;\n\n\tswitch (fib->proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\tp_dip = (u32 *) fib_entry->fib_node->key.addr;\n\t\tmlxsw_reg_ralue_pack4(ralue_pl, proto, op, fib->vr->id,\n\t\t\t\t      fib_entry->fib_node->key.prefix_len,\n\t\t\t\t      *p_dip);\n\t\tbreak;\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\tmlxsw_reg_ralue_pack6(ralue_pl, proto, op, fib->vr->id,\n\t\t\t\t      fib_entry->fib_node->key.prefix_len,\n\t\t\t\t      fib_entry->fib_node->key.addr);\n\t\tbreak;\n\t}\n}\n\nstatic int mlxsw_sp_fib_entry_op_remote(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t\t\tenum mlxsw_reg_ralue_op op)\n{\n\tstruct mlxsw_sp_nexthop_group *nh_group = fib_entry->nh_group;\n\tstruct mlxsw_sp_nexthop_group_info *nhgi = nh_group->nhgi;\n\tchar ralue_pl[MLXSW_REG_RALUE_LEN];\n\tenum mlxsw_reg_ralue_trap_action trap_action;\n\tu16 trap_id = 0;\n\tu32 adjacency_index = 0;\n\tu16 ecmp_size = 0;\n\n\t \n\tif (mlxsw_sp_fib_entry_should_offload(fib_entry)) {\n\t\ttrap_action = MLXSW_REG_RALUE_TRAP_ACTION_NOP;\n\t\tadjacency_index = nhgi->adj_index;\n\t\tecmp_size = nhgi->ecmp_size;\n\t} else if (!nhgi->adj_index_valid && nhgi->count &&\n\t\t   mlxsw_sp_nhgi_rif(nhgi)) {\n\t\ttrap_action = MLXSW_REG_RALUE_TRAP_ACTION_NOP;\n\t\tadjacency_index = mlxsw_sp->router->adj_trap_index;\n\t\tecmp_size = 1;\n\t} else {\n\t\ttrap_action = MLXSW_REG_RALUE_TRAP_ACTION_TRAP;\n\t\ttrap_id = MLXSW_TRAP_ID_RTR_INGRESS0;\n\t}\n\n\tmlxsw_sp_fib_entry_ralue_pack(ralue_pl, fib_entry, op);\n\tmlxsw_reg_ralue_act_remote_pack(ralue_pl, trap_action, trap_id,\n\t\t\t\t\tadjacency_index, ecmp_size);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ralue), ralue_pl);\n}\n\nstatic int mlxsw_sp_fib_entry_op_local(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t\t       enum mlxsw_reg_ralue_op op)\n{\n\tstruct mlxsw_sp_rif *rif = mlxsw_sp_nhgi_rif(fib_entry->nh_group->nhgi);\n\tenum mlxsw_reg_ralue_trap_action trap_action;\n\tchar ralue_pl[MLXSW_REG_RALUE_LEN];\n\tu16 trap_id = 0;\n\tu16 rif_index = 0;\n\n\tif (mlxsw_sp_fib_entry_should_offload(fib_entry)) {\n\t\ttrap_action = MLXSW_REG_RALUE_TRAP_ACTION_NOP;\n\t\trif_index = rif->rif_index;\n\t} else {\n\t\ttrap_action = MLXSW_REG_RALUE_TRAP_ACTION_TRAP;\n\t\ttrap_id = MLXSW_TRAP_ID_RTR_INGRESS0;\n\t}\n\n\tmlxsw_sp_fib_entry_ralue_pack(ralue_pl, fib_entry, op);\n\tmlxsw_reg_ralue_act_local_pack(ralue_pl, trap_action, trap_id,\n\t\t\t\t       rif_index);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ralue), ralue_pl);\n}\n\nstatic int mlxsw_sp_fib_entry_op_trap(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t\t      enum mlxsw_reg_ralue_op op)\n{\n\tchar ralue_pl[MLXSW_REG_RALUE_LEN];\n\n\tmlxsw_sp_fib_entry_ralue_pack(ralue_pl, fib_entry, op);\n\tmlxsw_reg_ralue_act_ip2me_pack(ralue_pl);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ralue), ralue_pl);\n}\n\nstatic int mlxsw_sp_fib_entry_op_blackhole(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   struct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t\t\t   enum mlxsw_reg_ralue_op op)\n{\n\tenum mlxsw_reg_ralue_trap_action trap_action;\n\tchar ralue_pl[MLXSW_REG_RALUE_LEN];\n\n\ttrap_action = MLXSW_REG_RALUE_TRAP_ACTION_DISCARD_ERROR;\n\tmlxsw_sp_fib_entry_ralue_pack(ralue_pl, fib_entry, op);\n\tmlxsw_reg_ralue_act_local_pack(ralue_pl, trap_action, 0, 0);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ralue), ralue_pl);\n}\n\nstatic int\nmlxsw_sp_fib_entry_op_unreachable(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t\t  enum mlxsw_reg_ralue_op op)\n{\n\tenum mlxsw_reg_ralue_trap_action trap_action;\n\tchar ralue_pl[MLXSW_REG_RALUE_LEN];\n\tu16 trap_id;\n\n\ttrap_action = MLXSW_REG_RALUE_TRAP_ACTION_TRAP;\n\ttrap_id = MLXSW_TRAP_ID_RTR_INGRESS1;\n\n\tmlxsw_sp_fib_entry_ralue_pack(ralue_pl, fib_entry, op);\n\tmlxsw_reg_ralue_act_local_pack(ralue_pl, trap_action, trap_id, 0);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ralue), ralue_pl);\n}\n\nstatic int\nmlxsw_sp_fib_entry_op_ipip_decap(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t\t enum mlxsw_reg_ralue_op op)\n{\n\tstruct mlxsw_sp_ipip_entry *ipip_entry = fib_entry->decap.ipip_entry;\n\tconst struct mlxsw_sp_ipip_ops *ipip_ops;\n\tchar ralue_pl[MLXSW_REG_RALUE_LEN];\n\tint err;\n\n\tif (WARN_ON(!ipip_entry))\n\t\treturn -EINVAL;\n\n\tipip_ops = mlxsw_sp->router->ipip_ops_arr[ipip_entry->ipipt];\n\terr = ipip_ops->decap_config(mlxsw_sp, ipip_entry,\n\t\t\t\t     fib_entry->decap.tunnel_index);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_sp_fib_entry_ralue_pack(ralue_pl, fib_entry, op);\n\tmlxsw_reg_ralue_act_ip2me_tun_pack(ralue_pl,\n\t\t\t\t\t   fib_entry->decap.tunnel_index);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ralue), ralue_pl);\n}\n\nstatic int mlxsw_sp_fib_entry_op_nve_decap(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   struct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t\t\t   enum mlxsw_reg_ralue_op op)\n{\n\tchar ralue_pl[MLXSW_REG_RALUE_LEN];\n\n\tmlxsw_sp_fib_entry_ralue_pack(ralue_pl, fib_entry, op);\n\tmlxsw_reg_ralue_act_ip2me_tun_pack(ralue_pl,\n\t\t\t\t\t   fib_entry->decap.tunnel_index);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ralue), ralue_pl);\n}\n\nstatic int __mlxsw_sp_fib_entry_op(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t\t   enum mlxsw_reg_ralue_op op)\n{\n\tswitch (fib_entry->type) {\n\tcase MLXSW_SP_FIB_ENTRY_TYPE_REMOTE:\n\t\treturn mlxsw_sp_fib_entry_op_remote(mlxsw_sp, fib_entry, op);\n\tcase MLXSW_SP_FIB_ENTRY_TYPE_LOCAL:\n\t\treturn mlxsw_sp_fib_entry_op_local(mlxsw_sp, fib_entry, op);\n\tcase MLXSW_SP_FIB_ENTRY_TYPE_TRAP:\n\t\treturn mlxsw_sp_fib_entry_op_trap(mlxsw_sp, fib_entry, op);\n\tcase MLXSW_SP_FIB_ENTRY_TYPE_BLACKHOLE:\n\t\treturn mlxsw_sp_fib_entry_op_blackhole(mlxsw_sp, fib_entry, op);\n\tcase MLXSW_SP_FIB_ENTRY_TYPE_UNREACHABLE:\n\t\treturn mlxsw_sp_fib_entry_op_unreachable(mlxsw_sp, fib_entry,\n\t\t\t\t\t\t\t op);\n\tcase MLXSW_SP_FIB_ENTRY_TYPE_IPIP_DECAP:\n\t\treturn mlxsw_sp_fib_entry_op_ipip_decap(mlxsw_sp,\n\t\t\t\t\t\t\tfib_entry, op);\n\tcase MLXSW_SP_FIB_ENTRY_TYPE_NVE_DECAP:\n\t\treturn mlxsw_sp_fib_entry_op_nve_decap(mlxsw_sp, fib_entry, op);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int mlxsw_sp_fib_entry_op(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t\t enum mlxsw_reg_ralue_op op)\n{\n\tint err = __mlxsw_sp_fib_entry_op(mlxsw_sp, fib_entry, op);\n\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_sp_fib_entry_hw_flags_refresh(mlxsw_sp, fib_entry, op);\n\n\treturn err;\n}\n\nstatic int mlxsw_sp_fib_entry_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_fib_entry *fib_entry)\n{\n\treturn mlxsw_sp_fib_entry_op(mlxsw_sp, fib_entry,\n\t\t\t\t     MLXSW_REG_RALUE_OP_WRITE_WRITE);\n}\n\nstatic int mlxsw_sp_fib_entry_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_fib_entry *fib_entry)\n{\n\treturn mlxsw_sp_fib_entry_op(mlxsw_sp, fib_entry,\n\t\t\t\t     MLXSW_REG_RALUE_OP_WRITE_DELETE);\n}\n\nstatic int\nmlxsw_sp_fib4_entry_type_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     const struct fib_entry_notifier_info *fen_info,\n\t\t\t     struct mlxsw_sp_fib_entry *fib_entry)\n{\n\tstruct mlxsw_sp_nexthop_group_info *nhgi = fib_entry->nh_group->nhgi;\n\tunion mlxsw_sp_l3addr dip = { .addr4 = htonl(fen_info->dst) };\n\tstruct mlxsw_sp_router *router = mlxsw_sp->router;\n\tu32 tb_id = mlxsw_sp_fix_tb_id(fen_info->tb_id);\n\tint ifindex = nhgi->nexthops[0].ifindex;\n\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\n\tswitch (fen_info->type) {\n\tcase RTN_LOCAL:\n\t\tipip_entry = mlxsw_sp_ipip_entry_find_by_decap(mlxsw_sp, ifindex,\n\t\t\t\t\t\t\t       MLXSW_SP_L3_PROTO_IPV4, dip);\n\t\tif (ipip_entry && ipip_entry->ol_dev->flags & IFF_UP) {\n\t\t\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_IPIP_DECAP;\n\t\t\treturn mlxsw_sp_fib_entry_decap_init(mlxsw_sp,\n\t\t\t\t\t\t\t     fib_entry,\n\t\t\t\t\t\t\t     ipip_entry);\n\t\t}\n\t\tif (mlxsw_sp_router_nve_is_decap(mlxsw_sp, tb_id,\n\t\t\t\t\t\t MLXSW_SP_L3_PROTO_IPV4,\n\t\t\t\t\t\t &dip)) {\n\t\t\tu32 tunnel_index;\n\n\t\t\ttunnel_index = router->nve_decap_config.tunnel_index;\n\t\t\tfib_entry->decap.tunnel_index = tunnel_index;\n\t\t\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_NVE_DECAP;\n\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tcase RTN_BROADCAST:\n\t\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_TRAP;\n\t\treturn 0;\n\tcase RTN_BLACKHOLE:\n\t\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_BLACKHOLE;\n\t\treturn 0;\n\tcase RTN_UNREACHABLE:\n\tcase RTN_PROHIBIT:\n\t\t \n\t\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_UNREACHABLE;\n\t\treturn 0;\n\tcase RTN_UNICAST:\n\t\tif (nhgi->gateway)\n\t\t\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_REMOTE;\n\t\telse\n\t\t\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_LOCAL;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void\nmlxsw_sp_fib_entry_type_unset(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_fib_entry *fib_entry)\n{\n\tswitch (fib_entry->type) {\n\tcase MLXSW_SP_FIB_ENTRY_TYPE_IPIP_DECAP:\n\t\tmlxsw_sp_fib_entry_decap_fini(mlxsw_sp, fib_entry);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nmlxsw_sp_fib4_entry_type_unset(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_fib4_entry *fib4_entry)\n{\n\tmlxsw_sp_fib_entry_type_unset(mlxsw_sp, &fib4_entry->common);\n}\n\nstatic struct mlxsw_sp_fib4_entry *\nmlxsw_sp_fib4_entry_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   struct mlxsw_sp_fib_node *fib_node,\n\t\t\t   const struct fib_entry_notifier_info *fen_info)\n{\n\tstruct mlxsw_sp_fib4_entry *fib4_entry;\n\tstruct mlxsw_sp_fib_entry *fib_entry;\n\tint err;\n\n\tfib4_entry = kzalloc(sizeof(*fib4_entry), GFP_KERNEL);\n\tif (!fib4_entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfib_entry = &fib4_entry->common;\n\n\terr = mlxsw_sp_nexthop4_group_get(mlxsw_sp, fib_entry, fen_info->fi);\n\tif (err)\n\t\tgoto err_nexthop4_group_get;\n\n\terr = mlxsw_sp_nexthop_group_vr_link(fib_entry->nh_group,\n\t\t\t\t\t     fib_node->fib);\n\tif (err)\n\t\tgoto err_nexthop_group_vr_link;\n\n\terr = mlxsw_sp_fib4_entry_type_set(mlxsw_sp, fen_info, fib_entry);\n\tif (err)\n\t\tgoto err_fib4_entry_type_set;\n\n\tfib4_entry->fi = fen_info->fi;\n\tfib_info_hold(fib4_entry->fi);\n\tfib4_entry->tb_id = fen_info->tb_id;\n\tfib4_entry->type = fen_info->type;\n\tfib4_entry->dscp = fen_info->dscp;\n\n\tfib_entry->fib_node = fib_node;\n\n\treturn fib4_entry;\n\nerr_fib4_entry_type_set:\n\tmlxsw_sp_nexthop_group_vr_unlink(fib_entry->nh_group, fib_node->fib);\nerr_nexthop_group_vr_link:\n\tmlxsw_sp_nexthop4_group_put(mlxsw_sp, &fib4_entry->common);\nerr_nexthop4_group_get:\n\tkfree(fib4_entry);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_fib4_entry_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_fib4_entry *fib4_entry)\n{\n\tstruct mlxsw_sp_fib_node *fib_node = fib4_entry->common.fib_node;\n\n\tfib_info_put(fib4_entry->fi);\n\tmlxsw_sp_fib4_entry_type_unset(mlxsw_sp, fib4_entry);\n\tmlxsw_sp_nexthop_group_vr_unlink(fib4_entry->common.nh_group,\n\t\t\t\t\t fib_node->fib);\n\tmlxsw_sp_nexthop4_group_put(mlxsw_sp, &fib4_entry->common);\n\tkfree(fib4_entry);\n}\n\nstatic struct mlxsw_sp_fib4_entry *\nmlxsw_sp_fib4_entry_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   const struct fib_entry_notifier_info *fen_info)\n{\n\tstruct mlxsw_sp_fib4_entry *fib4_entry;\n\tstruct mlxsw_sp_fib_node *fib_node;\n\tstruct mlxsw_sp_fib *fib;\n\tstruct mlxsw_sp_vr *vr;\n\n\tvr = mlxsw_sp_vr_find(mlxsw_sp, fen_info->tb_id);\n\tif (!vr)\n\t\treturn NULL;\n\tfib = mlxsw_sp_vr_fib(vr, MLXSW_SP_L3_PROTO_IPV4);\n\n\tfib_node = mlxsw_sp_fib_node_lookup(fib, &fen_info->dst,\n\t\t\t\t\t    sizeof(fen_info->dst),\n\t\t\t\t\t    fen_info->dst_len);\n\tif (!fib_node)\n\t\treturn NULL;\n\n\tfib4_entry = container_of(fib_node->fib_entry,\n\t\t\t\t  struct mlxsw_sp_fib4_entry, common);\n\tif (fib4_entry->tb_id == fen_info->tb_id &&\n\t    fib4_entry->dscp == fen_info->dscp &&\n\t    fib4_entry->type == fen_info->type &&\n\t    fib4_entry->fi == fen_info->fi)\n\t\treturn fib4_entry;\n\n\treturn NULL;\n}\n\nstatic const struct rhashtable_params mlxsw_sp_fib_ht_params = {\n\t.key_offset = offsetof(struct mlxsw_sp_fib_node, key),\n\t.head_offset = offsetof(struct mlxsw_sp_fib_node, ht_node),\n\t.key_len = sizeof(struct mlxsw_sp_fib_key),\n\t.automatic_shrinking = true,\n};\n\nstatic int mlxsw_sp_fib_node_insert(struct mlxsw_sp_fib *fib,\n\t\t\t\t    struct mlxsw_sp_fib_node *fib_node)\n{\n\treturn rhashtable_insert_fast(&fib->ht, &fib_node->ht_node,\n\t\t\t\t      mlxsw_sp_fib_ht_params);\n}\n\nstatic void mlxsw_sp_fib_node_remove(struct mlxsw_sp_fib *fib,\n\t\t\t\t     struct mlxsw_sp_fib_node *fib_node)\n{\n\trhashtable_remove_fast(&fib->ht, &fib_node->ht_node,\n\t\t\t       mlxsw_sp_fib_ht_params);\n}\n\nstatic struct mlxsw_sp_fib_node *\nmlxsw_sp_fib_node_lookup(struct mlxsw_sp_fib *fib, const void *addr,\n\t\t\t size_t addr_len, unsigned char prefix_len)\n{\n\tstruct mlxsw_sp_fib_key key;\n\n\tmemset(&key, 0, sizeof(key));\n\tmemcpy(key.addr, addr, addr_len);\n\tkey.prefix_len = prefix_len;\n\treturn rhashtable_lookup_fast(&fib->ht, &key, mlxsw_sp_fib_ht_params);\n}\n\nstatic struct mlxsw_sp_fib_node *\nmlxsw_sp_fib_node_create(struct mlxsw_sp_fib *fib, const void *addr,\n\t\t\t size_t addr_len, unsigned char prefix_len)\n{\n\tstruct mlxsw_sp_fib_node *fib_node;\n\n\tfib_node = kzalloc(sizeof(*fib_node), GFP_KERNEL);\n\tif (!fib_node)\n\t\treturn NULL;\n\n\tlist_add(&fib_node->list, &fib->node_list);\n\tmemcpy(fib_node->key.addr, addr, addr_len);\n\tfib_node->key.prefix_len = prefix_len;\n\n\treturn fib_node;\n}\n\nstatic void mlxsw_sp_fib_node_destroy(struct mlxsw_sp_fib_node *fib_node)\n{\n\tlist_del(&fib_node->list);\n\tkfree(fib_node);\n}\n\nstatic int mlxsw_sp_fib_lpm_tree_link(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct mlxsw_sp_fib_node *fib_node)\n{\n\tstruct mlxsw_sp_prefix_usage req_prefix_usage;\n\tstruct mlxsw_sp_fib *fib = fib_node->fib;\n\tstruct mlxsw_sp_lpm_tree *lpm_tree;\n\tint err;\n\n\tlpm_tree = mlxsw_sp->router->lpm.proto_trees[fib->proto];\n\tif (lpm_tree->prefix_ref_count[fib_node->key.prefix_len] != 0)\n\t\tgoto out;\n\n\tmlxsw_sp_prefix_usage_cpy(&req_prefix_usage, &lpm_tree->prefix_usage);\n\tmlxsw_sp_prefix_usage_set(&req_prefix_usage, fib_node->key.prefix_len);\n\tlpm_tree = mlxsw_sp_lpm_tree_get(mlxsw_sp, &req_prefix_usage,\n\t\t\t\t\t fib->proto);\n\tif (IS_ERR(lpm_tree))\n\t\treturn PTR_ERR(lpm_tree);\n\n\terr = mlxsw_sp_vrs_lpm_tree_replace(mlxsw_sp, fib, lpm_tree);\n\tif (err)\n\t\tgoto err_lpm_tree_replace;\n\nout:\n\tlpm_tree->prefix_ref_count[fib_node->key.prefix_len]++;\n\treturn 0;\n\nerr_lpm_tree_replace:\n\tmlxsw_sp_lpm_tree_put(mlxsw_sp, lpm_tree);\n\treturn err;\n}\n\nstatic void mlxsw_sp_fib_lpm_tree_unlink(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t struct mlxsw_sp_fib_node *fib_node)\n{\n\tstruct mlxsw_sp_lpm_tree *lpm_tree = fib_node->fib->lpm_tree;\n\tstruct mlxsw_sp_prefix_usage req_prefix_usage;\n\tstruct mlxsw_sp_fib *fib = fib_node->fib;\n\tint err;\n\n\tif (--lpm_tree->prefix_ref_count[fib_node->key.prefix_len] != 0)\n\t\treturn;\n\t \n\tmlxsw_sp_prefix_usage_cpy(&req_prefix_usage, &lpm_tree->prefix_usage);\n\tmlxsw_sp_prefix_usage_clear(&req_prefix_usage,\n\t\t\t\t    fib_node->key.prefix_len);\n\tlpm_tree = mlxsw_sp_lpm_tree_get(mlxsw_sp, &req_prefix_usage,\n\t\t\t\t\t fib->proto);\n\tif (IS_ERR(lpm_tree))\n\t\treturn;\n\n\terr = mlxsw_sp_vrs_lpm_tree_replace(mlxsw_sp, fib, lpm_tree);\n\tif (err)\n\t\tgoto err_lpm_tree_replace;\n\n\treturn;\n\nerr_lpm_tree_replace:\n\tmlxsw_sp_lpm_tree_put(mlxsw_sp, lpm_tree);\n}\n\nstatic int mlxsw_sp_fib_node_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_fib_node *fib_node,\n\t\t\t\t  struct mlxsw_sp_fib *fib)\n{\n\tint err;\n\n\terr = mlxsw_sp_fib_node_insert(fib, fib_node);\n\tif (err)\n\t\treturn err;\n\tfib_node->fib = fib;\n\n\terr = mlxsw_sp_fib_lpm_tree_link(mlxsw_sp, fib_node);\n\tif (err)\n\t\tgoto err_fib_lpm_tree_link;\n\n\treturn 0;\n\nerr_fib_lpm_tree_link:\n\tfib_node->fib = NULL;\n\tmlxsw_sp_fib_node_remove(fib, fib_node);\n\treturn err;\n}\n\nstatic void mlxsw_sp_fib_node_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_fib_node *fib_node)\n{\n\tstruct mlxsw_sp_fib *fib = fib_node->fib;\n\n\tmlxsw_sp_fib_lpm_tree_unlink(mlxsw_sp, fib_node);\n\tfib_node->fib = NULL;\n\tmlxsw_sp_fib_node_remove(fib, fib_node);\n}\n\nstatic struct mlxsw_sp_fib_node *\nmlxsw_sp_fib_node_get(struct mlxsw_sp *mlxsw_sp, u32 tb_id, const void *addr,\n\t\t      size_t addr_len, unsigned char prefix_len,\n\t\t      enum mlxsw_sp_l3proto proto)\n{\n\tstruct mlxsw_sp_fib_node *fib_node;\n\tstruct mlxsw_sp_fib *fib;\n\tstruct mlxsw_sp_vr *vr;\n\tint err;\n\n\tvr = mlxsw_sp_vr_get(mlxsw_sp, tb_id, NULL);\n\tif (IS_ERR(vr))\n\t\treturn ERR_CAST(vr);\n\tfib = mlxsw_sp_vr_fib(vr, proto);\n\n\tfib_node = mlxsw_sp_fib_node_lookup(fib, addr, addr_len, prefix_len);\n\tif (fib_node)\n\t\treturn fib_node;\n\n\tfib_node = mlxsw_sp_fib_node_create(fib, addr, addr_len, prefix_len);\n\tif (!fib_node) {\n\t\terr = -ENOMEM;\n\t\tgoto err_fib_node_create;\n\t}\n\n\terr = mlxsw_sp_fib_node_init(mlxsw_sp, fib_node, fib);\n\tif (err)\n\t\tgoto err_fib_node_init;\n\n\treturn fib_node;\n\nerr_fib_node_init:\n\tmlxsw_sp_fib_node_destroy(fib_node);\nerr_fib_node_create:\n\tmlxsw_sp_vr_put(mlxsw_sp, vr);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_fib_node_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_fib_node *fib_node)\n{\n\tstruct mlxsw_sp_vr *vr = fib_node->fib->vr;\n\n\tif (fib_node->fib_entry)\n\t\treturn;\n\tmlxsw_sp_fib_node_fini(mlxsw_sp, fib_node);\n\tmlxsw_sp_fib_node_destroy(fib_node);\n\tmlxsw_sp_vr_put(mlxsw_sp, vr);\n}\n\nstatic int mlxsw_sp_fib_node_entry_link(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_fib_entry *fib_entry)\n{\n\tstruct mlxsw_sp_fib_node *fib_node = fib_entry->fib_node;\n\tint err;\n\n\tfib_node->fib_entry = fib_entry;\n\n\terr = mlxsw_sp_fib_entry_update(mlxsw_sp, fib_entry);\n\tif (err)\n\t\tgoto err_fib_entry_update;\n\n\treturn 0;\n\nerr_fib_entry_update:\n\tfib_node->fib_entry = NULL;\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_fib_node_entry_unlink(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_fib_entry *fib_entry)\n{\n\tstruct mlxsw_sp_fib_node *fib_node = fib_entry->fib_node;\n\n\tmlxsw_sp_fib_entry_del(mlxsw_sp, fib_entry);\n\tfib_node->fib_entry = NULL;\n}\n\nstatic bool mlxsw_sp_fib4_allow_replace(struct mlxsw_sp_fib4_entry *fib4_entry)\n{\n\tstruct mlxsw_sp_fib_node *fib_node = fib4_entry->common.fib_node;\n\tstruct mlxsw_sp_fib4_entry *fib4_replaced;\n\n\tif (!fib_node->fib_entry)\n\t\treturn true;\n\n\tfib4_replaced = container_of(fib_node->fib_entry,\n\t\t\t\t     struct mlxsw_sp_fib4_entry, common);\n\tif (fib4_entry->tb_id == RT_TABLE_MAIN &&\n\t    fib4_replaced->tb_id == RT_TABLE_LOCAL)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int\nmlxsw_sp_router_fib4_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     const struct fib_entry_notifier_info *fen_info)\n{\n\tstruct mlxsw_sp_fib4_entry *fib4_entry, *fib4_replaced;\n\tstruct mlxsw_sp_fib_entry *replaced;\n\tstruct mlxsw_sp_fib_node *fib_node;\n\tint err;\n\n\tif (fen_info->fi->nh &&\n\t    !mlxsw_sp_nexthop_obj_group_lookup(mlxsw_sp, fen_info->fi->nh->id))\n\t\treturn 0;\n\n\tfib_node = mlxsw_sp_fib_node_get(mlxsw_sp, fen_info->tb_id,\n\t\t\t\t\t &fen_info->dst, sizeof(fen_info->dst),\n\t\t\t\t\t fen_info->dst_len,\n\t\t\t\t\t MLXSW_SP_L3_PROTO_IPV4);\n\tif (IS_ERR(fib_node)) {\n\t\tdev_warn(mlxsw_sp->bus_info->dev, \"Failed to get FIB node\\n\");\n\t\treturn PTR_ERR(fib_node);\n\t}\n\n\tfib4_entry = mlxsw_sp_fib4_entry_create(mlxsw_sp, fib_node, fen_info);\n\tif (IS_ERR(fib4_entry)) {\n\t\tdev_warn(mlxsw_sp->bus_info->dev, \"Failed to create FIB entry\\n\");\n\t\terr = PTR_ERR(fib4_entry);\n\t\tgoto err_fib4_entry_create;\n\t}\n\n\tif (!mlxsw_sp_fib4_allow_replace(fib4_entry)) {\n\t\tmlxsw_sp_fib4_entry_destroy(mlxsw_sp, fib4_entry);\n\t\tmlxsw_sp_fib_node_put(mlxsw_sp, fib_node);\n\t\treturn 0;\n\t}\n\n\treplaced = fib_node->fib_entry;\n\terr = mlxsw_sp_fib_node_entry_link(mlxsw_sp, &fib4_entry->common);\n\tif (err) {\n\t\tdev_warn(mlxsw_sp->bus_info->dev, \"Failed to link FIB entry to node\\n\");\n\t\tgoto err_fib_node_entry_link;\n\t}\n\n\t \n\tif (!replaced)\n\t\treturn 0;\n\n\tmlxsw_sp_fib_entry_hw_flags_clear(mlxsw_sp, replaced);\n\tfib4_replaced = container_of(replaced, struct mlxsw_sp_fib4_entry,\n\t\t\t\t     common);\n\tmlxsw_sp_fib4_entry_destroy(mlxsw_sp, fib4_replaced);\n\n\treturn 0;\n\nerr_fib_node_entry_link:\n\tfib_node->fib_entry = replaced;\n\tmlxsw_sp_fib4_entry_destroy(mlxsw_sp, fib4_entry);\nerr_fib4_entry_create:\n\tmlxsw_sp_fib_node_put(mlxsw_sp, fib_node);\n\treturn err;\n}\n\nstatic void mlxsw_sp_router_fib4_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct fib_entry_notifier_info *fen_info)\n{\n\tstruct mlxsw_sp_fib4_entry *fib4_entry;\n\tstruct mlxsw_sp_fib_node *fib_node;\n\n\tfib4_entry = mlxsw_sp_fib4_entry_lookup(mlxsw_sp, fen_info);\n\tif (!fib4_entry)\n\t\treturn;\n\tfib_node = fib4_entry->common.fib_node;\n\n\tmlxsw_sp_fib_node_entry_unlink(mlxsw_sp, &fib4_entry->common);\n\tmlxsw_sp_fib4_entry_destroy(mlxsw_sp, fib4_entry);\n\tmlxsw_sp_fib_node_put(mlxsw_sp, fib_node);\n}\n\nstatic bool mlxsw_sp_fib6_rt_should_ignore(const struct fib6_info *rt)\n{\n\t \n\tif (ipv6_addr_type(&rt->fib6_dst.addr) & IPV6_ADDR_MULTICAST)\n\t\treturn true;\n\n\t \n\tif (rt->fib6_flags & RTF_CACHE)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct mlxsw_sp_rt6 *mlxsw_sp_rt6_create(struct fib6_info *rt)\n{\n\tstruct mlxsw_sp_rt6 *mlxsw_sp_rt6;\n\n\tmlxsw_sp_rt6 = kzalloc(sizeof(*mlxsw_sp_rt6), GFP_KERNEL);\n\tif (!mlxsw_sp_rt6)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tmlxsw_sp_rt6->rt = rt;\n\tfib6_info_hold(rt);\n\n\treturn mlxsw_sp_rt6;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void mlxsw_sp_rt6_release(struct fib6_info *rt)\n{\n\tfib6_info_release(rt);\n}\n#else\nstatic void mlxsw_sp_rt6_release(struct fib6_info *rt)\n{\n}\n#endif\n\nstatic void mlxsw_sp_rt6_destroy(struct mlxsw_sp_rt6 *mlxsw_sp_rt6)\n{\n\tstruct fib6_nh *fib6_nh = mlxsw_sp_rt6->rt->fib6_nh;\n\n\tif (!mlxsw_sp_rt6->rt->nh)\n\t\tfib6_nh->fib_nh_flags &= ~RTNH_F_OFFLOAD;\n\tmlxsw_sp_rt6_release(mlxsw_sp_rt6->rt);\n\tkfree(mlxsw_sp_rt6);\n}\n\nstatic struct fib6_info *\nmlxsw_sp_fib6_entry_rt(const struct mlxsw_sp_fib6_entry *fib6_entry)\n{\n\treturn list_first_entry(&fib6_entry->rt6_list, struct mlxsw_sp_rt6,\n\t\t\t\tlist)->rt;\n}\n\nstatic struct mlxsw_sp_rt6 *\nmlxsw_sp_fib6_entry_rt_find(const struct mlxsw_sp_fib6_entry *fib6_entry,\n\t\t\t    const struct fib6_info *rt)\n{\n\tstruct mlxsw_sp_rt6 *mlxsw_sp_rt6;\n\n\tlist_for_each_entry(mlxsw_sp_rt6, &fib6_entry->rt6_list, list) {\n\t\tif (mlxsw_sp_rt6->rt == rt)\n\t\t\treturn mlxsw_sp_rt6;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool mlxsw_sp_nexthop6_ipip_type(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tconst struct fib6_info *rt,\n\t\t\t\t\tenum mlxsw_sp_ipip_type *ret)\n{\n\treturn rt->fib6_nh->fib_nh_dev &&\n\t       mlxsw_sp_netdev_ipip_type(mlxsw_sp, rt->fib6_nh->fib_nh_dev, ret);\n}\n\nstatic int mlxsw_sp_nexthop6_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t\t  struct mlxsw_sp_nexthop *nh,\n\t\t\t\t  const struct fib6_info *rt)\n{\n\tstruct net_device *dev = rt->fib6_nh->fib_nh_dev;\n\tint err;\n\n\tnh->nhgi = nh_grp->nhgi;\n\tnh->nh_weight = rt->fib6_nh->fib_nh_weight;\n\tmemcpy(&nh->gw_addr, &rt->fib6_nh->fib_nh_gw6, sizeof(nh->gw_addr));\n#if IS_ENABLED(CONFIG_IPV6)\n\tnh->neigh_tbl = &nd_tbl;\n#endif\n\tmlxsw_sp_nexthop_counter_alloc(mlxsw_sp, nh);\n\n\tlist_add_tail(&nh->router_list_node, &mlxsw_sp->router->nexthop_list);\n\n\tif (!dev)\n\t\treturn 0;\n\tnh->ifindex = dev->ifindex;\n\n\terr = mlxsw_sp_nexthop_type_init(mlxsw_sp, nh, dev);\n\tif (err)\n\t\tgoto err_nexthop_type_init;\n\n\treturn 0;\n\nerr_nexthop_type_init:\n\tlist_del(&nh->router_list_node);\n\tmlxsw_sp_nexthop_counter_free(mlxsw_sp, nh);\n\treturn err;\n}\n\nstatic void mlxsw_sp_nexthop6_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_nexthop *nh)\n{\n\tmlxsw_sp_nexthop_type_fini(mlxsw_sp, nh);\n\tlist_del(&nh->router_list_node);\n\tmlxsw_sp_nexthop_counter_free(mlxsw_sp, nh);\n}\n\nstatic bool mlxsw_sp_rt6_is_gateway(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    const struct fib6_info *rt)\n{\n\treturn rt->fib6_nh->fib_nh_gw_family ||\n\t       mlxsw_sp_nexthop6_ipip_type(mlxsw_sp, rt, NULL);\n}\n\nstatic int\nmlxsw_sp_nexthop6_group_info_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_nexthop_group *nh_grp,\n\t\t\t\t  struct mlxsw_sp_fib6_entry *fib6_entry)\n{\n\tstruct mlxsw_sp_nexthop_group_info *nhgi;\n\tstruct mlxsw_sp_rt6 *mlxsw_sp_rt6;\n\tstruct mlxsw_sp_nexthop *nh;\n\tint err, i;\n\n\tnhgi = kzalloc(struct_size(nhgi, nexthops, fib6_entry->nrt6),\n\t\t       GFP_KERNEL);\n\tif (!nhgi)\n\t\treturn -ENOMEM;\n\tnh_grp->nhgi = nhgi;\n\tnhgi->nh_grp = nh_grp;\n\tmlxsw_sp_rt6 = list_first_entry(&fib6_entry->rt6_list,\n\t\t\t\t\tstruct mlxsw_sp_rt6, list);\n\tnhgi->gateway = mlxsw_sp_rt6_is_gateway(mlxsw_sp, mlxsw_sp_rt6->rt);\n\tnhgi->count = fib6_entry->nrt6;\n\tfor (i = 0; i < nhgi->count; i++) {\n\t\tstruct fib6_info *rt = mlxsw_sp_rt6->rt;\n\n\t\tnh = &nhgi->nexthops[i];\n\t\terr = mlxsw_sp_nexthop6_init(mlxsw_sp, nh_grp, nh, rt);\n\t\tif (err)\n\t\t\tgoto err_nexthop6_init;\n\t\tmlxsw_sp_rt6 = list_next_entry(mlxsw_sp_rt6, list);\n\t}\n\tnh_grp->nhgi = nhgi;\n\terr = mlxsw_sp_nexthop_group_inc(mlxsw_sp);\n\tif (err)\n\t\tgoto err_group_inc;\n\terr = mlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh_grp);\n\tif (err)\n\t\tgoto err_group_refresh;\n\n\treturn 0;\n\nerr_group_refresh:\n\tmlxsw_sp_nexthop_group_dec(mlxsw_sp);\nerr_group_inc:\n\ti = nhgi->count;\nerr_nexthop6_init:\n\tfor (i--; i >= 0; i--) {\n\t\tnh = &nhgi->nexthops[i];\n\t\tmlxsw_sp_nexthop6_fini(mlxsw_sp, nh);\n\t}\n\tkfree(nhgi);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_nexthop6_group_info_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tstruct mlxsw_sp_nexthop_group_info *nhgi = nh_grp->nhgi;\n\tint i;\n\n\tmlxsw_sp_nexthop_group_dec(mlxsw_sp);\n\tfor (i = nhgi->count - 1; i >= 0; i--) {\n\t\tstruct mlxsw_sp_nexthop *nh = &nhgi->nexthops[i];\n\n\t\tmlxsw_sp_nexthop6_fini(mlxsw_sp, nh);\n\t}\n\tmlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh_grp);\n\tWARN_ON_ONCE(nhgi->adj_index_valid);\n\tkfree(nhgi);\n}\n\nstatic struct mlxsw_sp_nexthop_group *\nmlxsw_sp_nexthop6_group_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_fib6_entry *fib6_entry)\n{\n\tstruct mlxsw_sp_nexthop_group *nh_grp;\n\tint err;\n\n\tnh_grp = kzalloc(sizeof(*nh_grp), GFP_KERNEL);\n\tif (!nh_grp)\n\t\treturn ERR_PTR(-ENOMEM);\n\tINIT_LIST_HEAD(&nh_grp->vr_list);\n\terr = rhashtable_init(&nh_grp->vr_ht,\n\t\t\t      &mlxsw_sp_nexthop_group_vr_ht_params);\n\tif (err)\n\t\tgoto err_nexthop_group_vr_ht_init;\n\tINIT_LIST_HEAD(&nh_grp->fib_list);\n\tnh_grp->type = MLXSW_SP_NEXTHOP_GROUP_TYPE_IPV6;\n\n\terr = mlxsw_sp_nexthop6_group_info_init(mlxsw_sp, nh_grp, fib6_entry);\n\tif (err)\n\t\tgoto err_nexthop_group_info_init;\n\n\terr = mlxsw_sp_nexthop_group_insert(mlxsw_sp, nh_grp);\n\tif (err)\n\t\tgoto err_nexthop_group_insert;\n\n\tnh_grp->can_destroy = true;\n\n\treturn nh_grp;\n\nerr_nexthop_group_insert:\n\tmlxsw_sp_nexthop6_group_info_fini(mlxsw_sp, nh_grp);\nerr_nexthop_group_info_init:\n\trhashtable_destroy(&nh_grp->vr_ht);\nerr_nexthop_group_vr_ht_init:\n\tkfree(nh_grp);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_nexthop6_group_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_nexthop_group *nh_grp)\n{\n\tif (!nh_grp->can_destroy)\n\t\treturn;\n\tmlxsw_sp_nexthop_group_remove(mlxsw_sp, nh_grp);\n\tmlxsw_sp_nexthop6_group_info_fini(mlxsw_sp, nh_grp);\n\tWARN_ON_ONCE(!list_empty(&nh_grp->vr_list));\n\trhashtable_destroy(&nh_grp->vr_ht);\n\tkfree(nh_grp);\n}\n\nstatic int mlxsw_sp_nexthop6_group_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_fib6_entry *fib6_entry)\n{\n\tstruct fib6_info *rt = mlxsw_sp_fib6_entry_rt(fib6_entry);\n\tstruct mlxsw_sp_nexthop_group *nh_grp;\n\n\tif (rt->nh) {\n\t\tnh_grp = mlxsw_sp_nexthop_obj_group_lookup(mlxsw_sp,\n\t\t\t\t\t\t\t   rt->nh->id);\n\t\tif (WARN_ON_ONCE(!nh_grp))\n\t\t\treturn -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnh_grp = mlxsw_sp_nexthop6_group_lookup(mlxsw_sp, fib6_entry);\n\tif (!nh_grp) {\n\t\tnh_grp = mlxsw_sp_nexthop6_group_create(mlxsw_sp, fib6_entry);\n\t\tif (IS_ERR(nh_grp))\n\t\t\treturn PTR_ERR(nh_grp);\n\t}\n\n\t \n\t__mlxsw_sp_nexthop6_group_offload_refresh(nh_grp, fib6_entry);\n\nout:\n\tlist_add_tail(&fib6_entry->common.nexthop_group_node,\n\t\t      &nh_grp->fib_list);\n\tfib6_entry->common.nh_group = nh_grp;\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_nexthop6_group_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_fib_entry *fib_entry)\n{\n\tstruct mlxsw_sp_nexthop_group *nh_grp = fib_entry->nh_group;\n\n\tlist_del(&fib_entry->nexthop_group_node);\n\tif (!list_empty(&nh_grp->fib_list))\n\t\treturn;\n\n\tif (nh_grp->type == MLXSW_SP_NEXTHOP_GROUP_TYPE_OBJ) {\n\t\tmlxsw_sp_nexthop_obj_group_destroy(mlxsw_sp, nh_grp);\n\t\treturn;\n\t}\n\n\tmlxsw_sp_nexthop6_group_destroy(mlxsw_sp, nh_grp);\n}\n\nstatic int\nmlxsw_sp_nexthop6_group_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_fib6_entry *fib6_entry)\n{\n\tstruct mlxsw_sp_nexthop_group *old_nh_grp = fib6_entry->common.nh_group;\n\tstruct mlxsw_sp_fib_node *fib_node = fib6_entry->common.fib_node;\n\tint err;\n\n\tmlxsw_sp_nexthop_group_vr_unlink(old_nh_grp, fib_node->fib);\n\tfib6_entry->common.nh_group = NULL;\n\tlist_del(&fib6_entry->common.nexthop_group_node);\n\n\terr = mlxsw_sp_nexthop6_group_get(mlxsw_sp, fib6_entry);\n\tif (err)\n\t\tgoto err_nexthop6_group_get;\n\n\terr = mlxsw_sp_nexthop_group_vr_link(fib6_entry->common.nh_group,\n\t\t\t\t\t     fib_node->fib);\n\tif (err)\n\t\tgoto err_nexthop_group_vr_link;\n\n\t \n\terr = mlxsw_sp_fib_entry_update(mlxsw_sp, &fib6_entry->common);\n\tif (err)\n\t\tgoto err_fib_entry_update;\n\n\tif (list_empty(&old_nh_grp->fib_list))\n\t\tmlxsw_sp_nexthop6_group_destroy(mlxsw_sp, old_nh_grp);\n\n\treturn 0;\n\nerr_fib_entry_update:\n\tmlxsw_sp_nexthop_group_vr_unlink(fib6_entry->common.nh_group,\n\t\t\t\t\t fib_node->fib);\nerr_nexthop_group_vr_link:\n\tmlxsw_sp_nexthop6_group_put(mlxsw_sp, &fib6_entry->common);\nerr_nexthop6_group_get:\n\tlist_add_tail(&fib6_entry->common.nexthop_group_node,\n\t\t      &old_nh_grp->fib_list);\n\tfib6_entry->common.nh_group = old_nh_grp;\n\tmlxsw_sp_nexthop_group_vr_link(old_nh_grp, fib_node->fib);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_fib6_entry_nexthop_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_fib6_entry *fib6_entry,\n\t\t\t\tstruct fib6_info **rt_arr, unsigned int nrt6)\n{\n\tstruct mlxsw_sp_rt6 *mlxsw_sp_rt6;\n\tint err, i;\n\n\tfor (i = 0; i < nrt6; i++) {\n\t\tmlxsw_sp_rt6 = mlxsw_sp_rt6_create(rt_arr[i]);\n\t\tif (IS_ERR(mlxsw_sp_rt6)) {\n\t\t\terr = PTR_ERR(mlxsw_sp_rt6);\n\t\t\tgoto err_rt6_unwind;\n\t\t}\n\n\t\tlist_add_tail(&mlxsw_sp_rt6->list, &fib6_entry->rt6_list);\n\t\tfib6_entry->nrt6++;\n\t}\n\n\terr = mlxsw_sp_nexthop6_group_update(mlxsw_sp, fib6_entry);\n\tif (err)\n\t\tgoto err_rt6_unwind;\n\n\treturn 0;\n\nerr_rt6_unwind:\n\tfor (; i > 0; i--) {\n\t\tfib6_entry->nrt6--;\n\t\tmlxsw_sp_rt6 = list_last_entry(&fib6_entry->rt6_list,\n\t\t\t\t\t       struct mlxsw_sp_rt6, list);\n\t\tlist_del(&mlxsw_sp_rt6->list);\n\t\tmlxsw_sp_rt6_destroy(mlxsw_sp_rt6);\n\t}\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_fib6_entry_nexthop_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_fib6_entry *fib6_entry,\n\t\t\t\tstruct fib6_info **rt_arr, unsigned int nrt6)\n{\n\tstruct mlxsw_sp_rt6 *mlxsw_sp_rt6;\n\tint i;\n\n\tfor (i = 0; i < nrt6; i++) {\n\t\tmlxsw_sp_rt6 = mlxsw_sp_fib6_entry_rt_find(fib6_entry,\n\t\t\t\t\t\t\t   rt_arr[i]);\n\t\tif (WARN_ON_ONCE(!mlxsw_sp_rt6))\n\t\t\tcontinue;\n\n\t\tfib6_entry->nrt6--;\n\t\tlist_del(&mlxsw_sp_rt6->list);\n\t\tmlxsw_sp_rt6_destroy(mlxsw_sp_rt6);\n\t}\n\n\tmlxsw_sp_nexthop6_group_update(mlxsw_sp, fib6_entry);\n}\n\nstatic int\nmlxsw_sp_fib6_entry_type_set_local(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t\t   const struct fib6_info *rt)\n{\n\tstruct mlxsw_sp_nexthop_group_info *nhgi = fib_entry->nh_group->nhgi;\n\tunion mlxsw_sp_l3addr dip = { .addr6 = rt->fib6_dst.addr };\n\tu32 tb_id = mlxsw_sp_fix_tb_id(rt->fib6_table->tb6_id);\n\tstruct mlxsw_sp_router *router = mlxsw_sp->router;\n\tint ifindex = nhgi->nexthops[0].ifindex;\n\tstruct mlxsw_sp_ipip_entry *ipip_entry;\n\n\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_TRAP;\n\tipip_entry = mlxsw_sp_ipip_entry_find_by_decap(mlxsw_sp, ifindex,\n\t\t\t\t\t\t       MLXSW_SP_L3_PROTO_IPV6,\n\t\t\t\t\t\t       dip);\n\n\tif (ipip_entry && ipip_entry->ol_dev->flags & IFF_UP) {\n\t\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_IPIP_DECAP;\n\t\treturn mlxsw_sp_fib_entry_decap_init(mlxsw_sp, fib_entry,\n\t\t\t\t\t\t     ipip_entry);\n\t}\n\tif (mlxsw_sp_router_nve_is_decap(mlxsw_sp, tb_id,\n\t\t\t\t\t MLXSW_SP_L3_PROTO_IPV6, &dip)) {\n\t\tu32 tunnel_index;\n\n\t\ttunnel_index = router->nve_decap_config.tunnel_index;\n\t\tfib_entry->decap.tunnel_index = tunnel_index;\n\t\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_NVE_DECAP;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_fib6_entry_type_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_fib_entry *fib_entry,\n\t\t\t\t\tconst struct fib6_info *rt)\n{\n\tif (rt->fib6_flags & RTF_LOCAL)\n\t\treturn mlxsw_sp_fib6_entry_type_set_local(mlxsw_sp, fib_entry,\n\t\t\t\t\t\t\t  rt);\n\tif (rt->fib6_flags & RTF_ANYCAST)\n\t\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_TRAP;\n\telse if (rt->fib6_type == RTN_BLACKHOLE)\n\t\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_BLACKHOLE;\n\telse if (rt->fib6_flags & RTF_REJECT)\n\t\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_UNREACHABLE;\n\telse if (fib_entry->nh_group->nhgi->gateway)\n\t\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_REMOTE;\n\telse\n\t\tfib_entry->type = MLXSW_SP_FIB_ENTRY_TYPE_LOCAL;\n\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_fib6_entry_rt_destroy_all(struct mlxsw_sp_fib6_entry *fib6_entry)\n{\n\tstruct mlxsw_sp_rt6 *mlxsw_sp_rt6, *tmp;\n\n\tlist_for_each_entry_safe(mlxsw_sp_rt6, tmp, &fib6_entry->rt6_list,\n\t\t\t\t list) {\n\t\tfib6_entry->nrt6--;\n\t\tlist_del(&mlxsw_sp_rt6->list);\n\t\tmlxsw_sp_rt6_destroy(mlxsw_sp_rt6);\n\t}\n}\n\nstatic struct mlxsw_sp_fib6_entry *\nmlxsw_sp_fib6_entry_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   struct mlxsw_sp_fib_node *fib_node,\n\t\t\t   struct fib6_info **rt_arr, unsigned int nrt6)\n{\n\tstruct mlxsw_sp_fib6_entry *fib6_entry;\n\tstruct mlxsw_sp_fib_entry *fib_entry;\n\tstruct mlxsw_sp_rt6 *mlxsw_sp_rt6;\n\tint err, i;\n\n\tfib6_entry = kzalloc(sizeof(*fib6_entry), GFP_KERNEL);\n\tif (!fib6_entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfib_entry = &fib6_entry->common;\n\n\tINIT_LIST_HEAD(&fib6_entry->rt6_list);\n\n\tfor (i = 0; i < nrt6; i++) {\n\t\tmlxsw_sp_rt6 = mlxsw_sp_rt6_create(rt_arr[i]);\n\t\tif (IS_ERR(mlxsw_sp_rt6)) {\n\t\t\terr = PTR_ERR(mlxsw_sp_rt6);\n\t\t\tgoto err_rt6_unwind;\n\t\t}\n\t\tlist_add_tail(&mlxsw_sp_rt6->list, &fib6_entry->rt6_list);\n\t\tfib6_entry->nrt6++;\n\t}\n\n\terr = mlxsw_sp_nexthop6_group_get(mlxsw_sp, fib6_entry);\n\tif (err)\n\t\tgoto err_rt6_unwind;\n\n\terr = mlxsw_sp_nexthop_group_vr_link(fib_entry->nh_group,\n\t\t\t\t\t     fib_node->fib);\n\tif (err)\n\t\tgoto err_nexthop_group_vr_link;\n\n\terr = mlxsw_sp_fib6_entry_type_set(mlxsw_sp, fib_entry, rt_arr[0]);\n\tif (err)\n\t\tgoto err_fib6_entry_type_set;\n\n\tfib_entry->fib_node = fib_node;\n\n\treturn fib6_entry;\n\nerr_fib6_entry_type_set:\n\tmlxsw_sp_nexthop_group_vr_unlink(fib_entry->nh_group, fib_node->fib);\nerr_nexthop_group_vr_link:\n\tmlxsw_sp_nexthop6_group_put(mlxsw_sp, fib_entry);\nerr_rt6_unwind:\n\tfor (; i > 0; i--) {\n\t\tfib6_entry->nrt6--;\n\t\tmlxsw_sp_rt6 = list_last_entry(&fib6_entry->rt6_list,\n\t\t\t\t\t       struct mlxsw_sp_rt6, list);\n\t\tlist_del(&mlxsw_sp_rt6->list);\n\t\tmlxsw_sp_rt6_destroy(mlxsw_sp_rt6);\n\t}\n\tkfree(fib6_entry);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_fib6_entry_type_unset(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_fib6_entry *fib6_entry)\n{\n\tmlxsw_sp_fib_entry_type_unset(mlxsw_sp, &fib6_entry->common);\n}\n\nstatic void mlxsw_sp_fib6_entry_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_fib6_entry *fib6_entry)\n{\n\tstruct mlxsw_sp_fib_node *fib_node = fib6_entry->common.fib_node;\n\n\tmlxsw_sp_fib6_entry_type_unset(mlxsw_sp, fib6_entry);\n\tmlxsw_sp_nexthop_group_vr_unlink(fib6_entry->common.nh_group,\n\t\t\t\t\t fib_node->fib);\n\tmlxsw_sp_nexthop6_group_put(mlxsw_sp, &fib6_entry->common);\n\tmlxsw_sp_fib6_entry_rt_destroy_all(fib6_entry);\n\tWARN_ON(fib6_entry->nrt6);\n\tkfree(fib6_entry);\n}\n\nstatic struct mlxsw_sp_fib6_entry *\nmlxsw_sp_fib6_entry_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   const struct fib6_info *rt)\n{\n\tstruct mlxsw_sp_fib6_entry *fib6_entry;\n\tstruct mlxsw_sp_fib_node *fib_node;\n\tstruct mlxsw_sp_fib *fib;\n\tstruct fib6_info *cmp_rt;\n\tstruct mlxsw_sp_vr *vr;\n\n\tvr = mlxsw_sp_vr_find(mlxsw_sp, rt->fib6_table->tb6_id);\n\tif (!vr)\n\t\treturn NULL;\n\tfib = mlxsw_sp_vr_fib(vr, MLXSW_SP_L3_PROTO_IPV6);\n\n\tfib_node = mlxsw_sp_fib_node_lookup(fib, &rt->fib6_dst.addr,\n\t\t\t\t\t    sizeof(rt->fib6_dst.addr),\n\t\t\t\t\t    rt->fib6_dst.plen);\n\tif (!fib_node)\n\t\treturn NULL;\n\n\tfib6_entry = container_of(fib_node->fib_entry,\n\t\t\t\t  struct mlxsw_sp_fib6_entry, common);\n\tcmp_rt = mlxsw_sp_fib6_entry_rt(fib6_entry);\n\tif (rt->fib6_table->tb6_id == cmp_rt->fib6_table->tb6_id &&\n\t    rt->fib6_metric == cmp_rt->fib6_metric &&\n\t    mlxsw_sp_fib6_entry_rt_find(fib6_entry, rt))\n\t\treturn fib6_entry;\n\n\treturn NULL;\n}\n\nstatic bool mlxsw_sp_fib6_allow_replace(struct mlxsw_sp_fib6_entry *fib6_entry)\n{\n\tstruct mlxsw_sp_fib_node *fib_node = fib6_entry->common.fib_node;\n\tstruct mlxsw_sp_fib6_entry *fib6_replaced;\n\tstruct fib6_info *rt, *rt_replaced;\n\n\tif (!fib_node->fib_entry)\n\t\treturn true;\n\n\tfib6_replaced = container_of(fib_node->fib_entry,\n\t\t\t\t     struct mlxsw_sp_fib6_entry,\n\t\t\t\t     common);\n\trt = mlxsw_sp_fib6_entry_rt(fib6_entry);\n\trt_replaced = mlxsw_sp_fib6_entry_rt(fib6_replaced);\n\tif (rt->fib6_table->tb6_id == RT_TABLE_MAIN &&\n\t    rt_replaced->fib6_table->tb6_id == RT_TABLE_LOCAL)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int mlxsw_sp_router_fib6_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct fib6_info **rt_arr,\n\t\t\t\t\tunsigned int nrt6)\n{\n\tstruct mlxsw_sp_fib6_entry *fib6_entry, *fib6_replaced;\n\tstruct mlxsw_sp_fib_entry *replaced;\n\tstruct mlxsw_sp_fib_node *fib_node;\n\tstruct fib6_info *rt = rt_arr[0];\n\tint err;\n\n\tif (rt->fib6_src.plen)\n\t\treturn -EINVAL;\n\n\tif (mlxsw_sp_fib6_rt_should_ignore(rt))\n\t\treturn 0;\n\n\tif (rt->nh && !mlxsw_sp_nexthop_obj_group_lookup(mlxsw_sp, rt->nh->id))\n\t\treturn 0;\n\n\tfib_node = mlxsw_sp_fib_node_get(mlxsw_sp, rt->fib6_table->tb6_id,\n\t\t\t\t\t &rt->fib6_dst.addr,\n\t\t\t\t\t sizeof(rt->fib6_dst.addr),\n\t\t\t\t\t rt->fib6_dst.plen,\n\t\t\t\t\t MLXSW_SP_L3_PROTO_IPV6);\n\tif (IS_ERR(fib_node))\n\t\treturn PTR_ERR(fib_node);\n\n\tfib6_entry = mlxsw_sp_fib6_entry_create(mlxsw_sp, fib_node, rt_arr,\n\t\t\t\t\t\tnrt6);\n\tif (IS_ERR(fib6_entry)) {\n\t\terr = PTR_ERR(fib6_entry);\n\t\tgoto err_fib6_entry_create;\n\t}\n\n\tif (!mlxsw_sp_fib6_allow_replace(fib6_entry)) {\n\t\tmlxsw_sp_fib6_entry_destroy(mlxsw_sp, fib6_entry);\n\t\tmlxsw_sp_fib_node_put(mlxsw_sp, fib_node);\n\t\treturn 0;\n\t}\n\n\treplaced = fib_node->fib_entry;\n\terr = mlxsw_sp_fib_node_entry_link(mlxsw_sp, &fib6_entry->common);\n\tif (err)\n\t\tgoto err_fib_node_entry_link;\n\n\t \n\tif (!replaced)\n\t\treturn 0;\n\n\tmlxsw_sp_fib_entry_hw_flags_clear(mlxsw_sp, replaced);\n\tfib6_replaced = container_of(replaced, struct mlxsw_sp_fib6_entry,\n\t\t\t\t     common);\n\tmlxsw_sp_fib6_entry_destroy(mlxsw_sp, fib6_replaced);\n\n\treturn 0;\n\nerr_fib_node_entry_link:\n\tfib_node->fib_entry = replaced;\n\tmlxsw_sp_fib6_entry_destroy(mlxsw_sp, fib6_entry);\nerr_fib6_entry_create:\n\tmlxsw_sp_fib_node_put(mlxsw_sp, fib_node);\n\treturn err;\n}\n\nstatic int mlxsw_sp_router_fib6_append(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct fib6_info **rt_arr,\n\t\t\t\t       unsigned int nrt6)\n{\n\tstruct mlxsw_sp_fib6_entry *fib6_entry;\n\tstruct mlxsw_sp_fib_node *fib_node;\n\tstruct fib6_info *rt = rt_arr[0];\n\tint err;\n\n\tif (rt->fib6_src.plen)\n\t\treturn -EINVAL;\n\n\tif (mlxsw_sp_fib6_rt_should_ignore(rt))\n\t\treturn 0;\n\n\tfib_node = mlxsw_sp_fib_node_get(mlxsw_sp, rt->fib6_table->tb6_id,\n\t\t\t\t\t &rt->fib6_dst.addr,\n\t\t\t\t\t sizeof(rt->fib6_dst.addr),\n\t\t\t\t\t rt->fib6_dst.plen,\n\t\t\t\t\t MLXSW_SP_L3_PROTO_IPV6);\n\tif (IS_ERR(fib_node))\n\t\treturn PTR_ERR(fib_node);\n\n\tif (WARN_ON_ONCE(!fib_node->fib_entry)) {\n\t\tmlxsw_sp_fib_node_put(mlxsw_sp, fib_node);\n\t\treturn -EINVAL;\n\t}\n\n\tfib6_entry = container_of(fib_node->fib_entry,\n\t\t\t\t  struct mlxsw_sp_fib6_entry, common);\n\terr = mlxsw_sp_fib6_entry_nexthop_add(mlxsw_sp, fib6_entry, rt_arr,\n\t\t\t\t\t      nrt6);\n\tif (err)\n\t\tgoto err_fib6_entry_nexthop_add;\n\n\treturn 0;\n\nerr_fib6_entry_nexthop_add:\n\tmlxsw_sp_fib_node_put(mlxsw_sp, fib_node);\n\treturn err;\n}\n\nstatic void mlxsw_sp_router_fib6_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct fib6_info **rt_arr,\n\t\t\t\t     unsigned int nrt6)\n{\n\tstruct mlxsw_sp_fib6_entry *fib6_entry;\n\tstruct mlxsw_sp_fib_node *fib_node;\n\tstruct fib6_info *rt = rt_arr[0];\n\n\tif (mlxsw_sp_fib6_rt_should_ignore(rt))\n\t\treturn;\n\n\t \n\tfib6_entry = mlxsw_sp_fib6_entry_lookup(mlxsw_sp, rt);\n\tif (!fib6_entry)\n\t\treturn;\n\n\t \n\tif (nrt6 != fib6_entry->nrt6) {\n\t\tmlxsw_sp_fib6_entry_nexthop_del(mlxsw_sp, fib6_entry, rt_arr,\n\t\t\t\t\t\tnrt6);\n\t\treturn;\n\t}\n\n\tfib_node = fib6_entry->common.fib_node;\n\n\tmlxsw_sp_fib_node_entry_unlink(mlxsw_sp, &fib6_entry->common);\n\tmlxsw_sp_fib6_entry_destroy(mlxsw_sp, fib6_entry);\n\tmlxsw_sp_fib_node_put(mlxsw_sp, fib_node);\n}\n\nstatic struct mlxsw_sp_mr_table *\nmlxsw_sp_router_fibmr_family_to_table(struct mlxsw_sp_vr *vr, int family)\n{\n\tif (family == RTNL_FAMILY_IPMR)\n\t\treturn vr->mr_table[MLXSW_SP_L3_PROTO_IPV4];\n\telse\n\t\treturn vr->mr_table[MLXSW_SP_L3_PROTO_IPV6];\n}\n\nstatic int mlxsw_sp_router_fibmr_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mfc_entry_notifier_info *men_info,\n\t\t\t\t     bool replace)\n{\n\tstruct mlxsw_sp_mr_table *mrt;\n\tstruct mlxsw_sp_vr *vr;\n\n\tvr = mlxsw_sp_vr_get(mlxsw_sp, men_info->tb_id, NULL);\n\tif (IS_ERR(vr))\n\t\treturn PTR_ERR(vr);\n\n\tmrt = mlxsw_sp_router_fibmr_family_to_table(vr, men_info->info.family);\n\treturn mlxsw_sp_mr_route_add(mrt, men_info->mfc, replace);\n}\n\nstatic void mlxsw_sp_router_fibmr_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct mfc_entry_notifier_info *men_info)\n{\n\tstruct mlxsw_sp_mr_table *mrt;\n\tstruct mlxsw_sp_vr *vr;\n\n\tvr = mlxsw_sp_vr_find(mlxsw_sp, men_info->tb_id);\n\tif (WARN_ON(!vr))\n\t\treturn;\n\n\tmrt = mlxsw_sp_router_fibmr_family_to_table(vr, men_info->info.family);\n\tmlxsw_sp_mr_route_del(mrt, men_info->mfc);\n\tmlxsw_sp_vr_put(mlxsw_sp, vr);\n}\n\nstatic int\nmlxsw_sp_router_fibmr_vif_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct vif_entry_notifier_info *ven_info)\n{\n\tstruct mlxsw_sp_mr_table *mrt;\n\tstruct mlxsw_sp_rif *rif;\n\tstruct mlxsw_sp_vr *vr;\n\n\tvr = mlxsw_sp_vr_get(mlxsw_sp, ven_info->tb_id, NULL);\n\tif (IS_ERR(vr))\n\t\treturn PTR_ERR(vr);\n\n\tmrt = mlxsw_sp_router_fibmr_family_to_table(vr, ven_info->info.family);\n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, ven_info->dev);\n\treturn mlxsw_sp_mr_vif_add(mrt, ven_info->dev,\n\t\t\t\t   ven_info->vif_index,\n\t\t\t\t   ven_info->vif_flags, rif);\n}\n\nstatic void\nmlxsw_sp_router_fibmr_vif_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct vif_entry_notifier_info *ven_info)\n{\n\tstruct mlxsw_sp_mr_table *mrt;\n\tstruct mlxsw_sp_vr *vr;\n\n\tvr = mlxsw_sp_vr_find(mlxsw_sp, ven_info->tb_id);\n\tif (WARN_ON(!vr))\n\t\treturn;\n\n\tmrt = mlxsw_sp_router_fibmr_family_to_table(vr, ven_info->info.family);\n\tmlxsw_sp_mr_vif_del(mrt, ven_info->vif_index);\n\tmlxsw_sp_vr_put(mlxsw_sp, vr);\n}\n\nstatic void mlxsw_sp_fib4_node_flush(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_fib_node *fib_node)\n{\n\tstruct mlxsw_sp_fib4_entry *fib4_entry;\n\n\tfib4_entry = container_of(fib_node->fib_entry,\n\t\t\t\t  struct mlxsw_sp_fib4_entry, common);\n\tmlxsw_sp_fib_node_entry_unlink(mlxsw_sp, fib_node->fib_entry);\n\tmlxsw_sp_fib4_entry_destroy(mlxsw_sp, fib4_entry);\n\tmlxsw_sp_fib_node_put(mlxsw_sp, fib_node);\n}\n\nstatic void mlxsw_sp_fib6_node_flush(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_fib_node *fib_node)\n{\n\tstruct mlxsw_sp_fib6_entry *fib6_entry;\n\n\tfib6_entry = container_of(fib_node->fib_entry,\n\t\t\t\t  struct mlxsw_sp_fib6_entry, common);\n\tmlxsw_sp_fib_node_entry_unlink(mlxsw_sp, fib_node->fib_entry);\n\tmlxsw_sp_fib6_entry_destroy(mlxsw_sp, fib6_entry);\n\tmlxsw_sp_fib_node_put(mlxsw_sp, fib_node);\n}\n\nstatic void mlxsw_sp_fib_node_flush(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_fib_node *fib_node)\n{\n\tswitch (fib_node->fib->proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\tmlxsw_sp_fib4_node_flush(mlxsw_sp, fib_node);\n\t\tbreak;\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\tmlxsw_sp_fib6_node_flush(mlxsw_sp, fib_node);\n\t\tbreak;\n\t}\n}\n\nstatic void mlxsw_sp_vr_fib_flush(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_vr *vr,\n\t\t\t\t  enum mlxsw_sp_l3proto proto)\n{\n\tstruct mlxsw_sp_fib *fib = mlxsw_sp_vr_fib(vr, proto);\n\tstruct mlxsw_sp_fib_node *fib_node, *tmp;\n\n\tlist_for_each_entry_safe(fib_node, tmp, &fib->node_list, list) {\n\t\tbool do_break = &tmp->list == &fib->node_list;\n\n\t\tmlxsw_sp_fib_node_flush(mlxsw_sp, fib_node);\n\t\tif (do_break)\n\t\t\tbreak;\n\t}\n}\n\nstatic void mlxsw_sp_router_fib_flush(struct mlxsw_sp *mlxsw_sp)\n{\n\tint max_vrs = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_VRS);\n\tint i, j;\n\n\tfor (i = 0; i < max_vrs; i++) {\n\t\tstruct mlxsw_sp_vr *vr = &mlxsw_sp->router->vrs[i];\n\n\t\tif (!mlxsw_sp_vr_is_used(vr))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < MLXSW_SP_L3_PROTO_MAX; j++)\n\t\t\tmlxsw_sp_mr_table_flush(vr->mr_table[j]);\n\t\tmlxsw_sp_vr_fib_flush(mlxsw_sp, vr, MLXSW_SP_L3_PROTO_IPV4);\n\n\t\t \n\t\tif (!mlxsw_sp_vr_is_used(vr))\n\t\t\tcontinue;\n\t\tmlxsw_sp_vr_fib_flush(mlxsw_sp, vr, MLXSW_SP_L3_PROTO_IPV6);\n\t}\n}\n\nstruct mlxsw_sp_fib6_event_work {\n\tstruct fib6_info **rt_arr;\n\tunsigned int nrt6;\n};\n\nstruct mlxsw_sp_fib_event_work {\n\tstruct work_struct work;\n\tnetdevice_tracker dev_tracker;\n\tunion {\n\t\tstruct mlxsw_sp_fib6_event_work fib6_work;\n\t\tstruct fib_entry_notifier_info fen_info;\n\t\tstruct fib_rule_notifier_info fr_info;\n\t\tstruct fib_nh_notifier_info fnh_info;\n\t\tstruct mfc_entry_notifier_info men_info;\n\t\tstruct vif_entry_notifier_info ven_info;\n\t};\n\tstruct mlxsw_sp *mlxsw_sp;\n\tunsigned long event;\n};\n\nstatic int\nmlxsw_sp_router_fib6_work_init(struct mlxsw_sp_fib6_event_work *fib6_work,\n\t\t\t       struct fib6_entry_notifier_info *fen6_info)\n{\n\tstruct fib6_info *rt = fen6_info->rt;\n\tstruct fib6_info **rt_arr;\n\tstruct fib6_info *iter;\n\tunsigned int nrt6;\n\tint i = 0;\n\n\tnrt6 = fen6_info->nsiblings + 1;\n\n\trt_arr = kcalloc(nrt6, sizeof(struct fib6_info *), GFP_ATOMIC);\n\tif (!rt_arr)\n\t\treturn -ENOMEM;\n\n\tfib6_work->rt_arr = rt_arr;\n\tfib6_work->nrt6 = nrt6;\n\n\trt_arr[0] = rt;\n\tfib6_info_hold(rt);\n\n\tif (!fen6_info->nsiblings)\n\t\treturn 0;\n\n\tlist_for_each_entry(iter, &rt->fib6_siblings, fib6_siblings) {\n\t\tif (i == fen6_info->nsiblings)\n\t\t\tbreak;\n\n\t\trt_arr[i + 1] = iter;\n\t\tfib6_info_hold(iter);\n\t\ti++;\n\t}\n\tWARN_ON_ONCE(i != fen6_info->nsiblings);\n\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_router_fib6_work_fini(struct mlxsw_sp_fib6_event_work *fib6_work)\n{\n\tint i;\n\n\tfor (i = 0; i < fib6_work->nrt6; i++)\n\t\tmlxsw_sp_rt6_release(fib6_work->rt_arr[i]);\n\tkfree(fib6_work->rt_arr);\n}\n\nstatic void mlxsw_sp_router_fib4_event_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_fib_event_work *fib_work =\n\t\tcontainer_of(work, struct mlxsw_sp_fib_event_work, work);\n\tstruct mlxsw_sp *mlxsw_sp = fib_work->mlxsw_sp;\n\tint err;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\tmlxsw_sp_span_respin(mlxsw_sp);\n\n\tswitch (fib_work->event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\t\terr = mlxsw_sp_router_fib4_replace(mlxsw_sp,\n\t\t\t\t\t\t   &fib_work->fen_info);\n\t\tif (err) {\n\t\t\tdev_warn(mlxsw_sp->bus_info->dev, \"FIB replace failed.\\n\");\n\t\t\tmlxsw_sp_fib4_offload_failed_flag_set(mlxsw_sp,\n\t\t\t\t\t\t\t      &fib_work->fen_info);\n\t\t}\n\t\tfib_info_put(fib_work->fen_info.fi);\n\t\tbreak;\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\tmlxsw_sp_router_fib4_del(mlxsw_sp, &fib_work->fen_info);\n\t\tfib_info_put(fib_work->fen_info.fi);\n\t\tbreak;\n\tcase FIB_EVENT_NH_ADD:\n\tcase FIB_EVENT_NH_DEL:\n\t\tmlxsw_sp_nexthop4_event(mlxsw_sp, fib_work->event,\n\t\t\t\t\tfib_work->fnh_info.fib_nh);\n\t\tfib_info_put(fib_work->fnh_info.fib_nh->nh_parent);\n\t\tbreak;\n\t}\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\tkfree(fib_work);\n}\n\nstatic void mlxsw_sp_router_fib6_event_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_fib_event_work *fib_work =\n\t\t    container_of(work, struct mlxsw_sp_fib_event_work, work);\n\tstruct mlxsw_sp_fib6_event_work *fib6_work = &fib_work->fib6_work;\n\tstruct mlxsw_sp *mlxsw_sp = fib_work->mlxsw_sp;\n\tint err;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\tmlxsw_sp_span_respin(mlxsw_sp);\n\n\tswitch (fib_work->event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\t\terr = mlxsw_sp_router_fib6_replace(mlxsw_sp,\n\t\t\t\t\t\t   fib6_work->rt_arr,\n\t\t\t\t\t\t   fib6_work->nrt6);\n\t\tif (err) {\n\t\t\tdev_warn(mlxsw_sp->bus_info->dev, \"FIB replace failed.\\n\");\n\t\t\tmlxsw_sp_fib6_offload_failed_flag_set(mlxsw_sp,\n\t\t\t\t\t\t\t      fib6_work->rt_arr,\n\t\t\t\t\t\t\t      fib6_work->nrt6);\n\t\t}\n\t\tmlxsw_sp_router_fib6_work_fini(fib6_work);\n\t\tbreak;\n\tcase FIB_EVENT_ENTRY_APPEND:\n\t\terr = mlxsw_sp_router_fib6_append(mlxsw_sp,\n\t\t\t\t\t\t  fib6_work->rt_arr,\n\t\t\t\t\t\t  fib6_work->nrt6);\n\t\tif (err) {\n\t\t\tdev_warn(mlxsw_sp->bus_info->dev, \"FIB append failed.\\n\");\n\t\t\tmlxsw_sp_fib6_offload_failed_flag_set(mlxsw_sp,\n\t\t\t\t\t\t\t      fib6_work->rt_arr,\n\t\t\t\t\t\t\t      fib6_work->nrt6);\n\t\t}\n\t\tmlxsw_sp_router_fib6_work_fini(fib6_work);\n\t\tbreak;\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\tmlxsw_sp_router_fib6_del(mlxsw_sp,\n\t\t\t\t\t fib6_work->rt_arr,\n\t\t\t\t\t fib6_work->nrt6);\n\t\tmlxsw_sp_router_fib6_work_fini(fib6_work);\n\t\tbreak;\n\t}\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\tkfree(fib_work);\n}\n\nstatic void mlxsw_sp_router_fibmr_event_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_fib_event_work *fib_work =\n\t\tcontainer_of(work, struct mlxsw_sp_fib_event_work, work);\n\tstruct mlxsw_sp *mlxsw_sp = fib_work->mlxsw_sp;\n\tbool replace;\n\tint err;\n\n\trtnl_lock();\n\tmutex_lock(&mlxsw_sp->router->lock);\n\tswitch (fib_work->event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\tcase FIB_EVENT_ENTRY_ADD:\n\t\treplace = fib_work->event == FIB_EVENT_ENTRY_REPLACE;\n\n\t\terr = mlxsw_sp_router_fibmr_add(mlxsw_sp, &fib_work->men_info,\n\t\t\t\t\t\treplace);\n\t\tif (err)\n\t\t\tdev_warn(mlxsw_sp->bus_info->dev, \"MR entry add failed.\\n\");\n\t\tmr_cache_put(fib_work->men_info.mfc);\n\t\tbreak;\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\tmlxsw_sp_router_fibmr_del(mlxsw_sp, &fib_work->men_info);\n\t\tmr_cache_put(fib_work->men_info.mfc);\n\t\tbreak;\n\tcase FIB_EVENT_VIF_ADD:\n\t\terr = mlxsw_sp_router_fibmr_vif_add(mlxsw_sp,\n\t\t\t\t\t\t    &fib_work->ven_info);\n\t\tif (err)\n\t\t\tdev_warn(mlxsw_sp->bus_info->dev, \"MR VIF add failed.\\n\");\n\t\tnetdev_put(fib_work->ven_info.dev, &fib_work->dev_tracker);\n\t\tbreak;\n\tcase FIB_EVENT_VIF_DEL:\n\t\tmlxsw_sp_router_fibmr_vif_del(mlxsw_sp,\n\t\t\t\t\t      &fib_work->ven_info);\n\t\tnetdev_put(fib_work->ven_info.dev, &fib_work->dev_tracker);\n\t\tbreak;\n\t}\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\trtnl_unlock();\n\tkfree(fib_work);\n}\n\nstatic void mlxsw_sp_router_fib4_event(struct mlxsw_sp_fib_event_work *fib_work,\n\t\t\t\t       struct fib_notifier_info *info)\n{\n\tstruct fib_entry_notifier_info *fen_info;\n\tstruct fib_nh_notifier_info *fnh_info;\n\n\tswitch (fib_work->event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\tfen_info = container_of(info, struct fib_entry_notifier_info,\n\t\t\t\t\tinfo);\n\t\tfib_work->fen_info = *fen_info;\n\t\t \n\t\tfib_info_hold(fib_work->fen_info.fi);\n\t\tbreak;\n\tcase FIB_EVENT_NH_ADD:\n\tcase FIB_EVENT_NH_DEL:\n\t\tfnh_info = container_of(info, struct fib_nh_notifier_info,\n\t\t\t\t\tinfo);\n\t\tfib_work->fnh_info = *fnh_info;\n\t\tfib_info_hold(fib_work->fnh_info.fib_nh->nh_parent);\n\t\tbreak;\n\t}\n}\n\nstatic int mlxsw_sp_router_fib6_event(struct mlxsw_sp_fib_event_work *fib_work,\n\t\t\t\t      struct fib_notifier_info *info)\n{\n\tstruct fib6_entry_notifier_info *fen6_info;\n\tint err;\n\n\tswitch (fib_work->event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\tcase FIB_EVENT_ENTRY_APPEND:\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\tfen6_info = container_of(info, struct fib6_entry_notifier_info,\n\t\t\t\t\t info);\n\t\terr = mlxsw_sp_router_fib6_work_init(&fib_work->fib6_work,\n\t\t\t\t\t\t     fen6_info);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_router_fibmr_event(struct mlxsw_sp_fib_event_work *fib_work,\n\t\t\t    struct fib_notifier_info *info)\n{\n\tswitch (fib_work->event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\tcase FIB_EVENT_ENTRY_ADD:\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\tmemcpy(&fib_work->men_info, info, sizeof(fib_work->men_info));\n\t\tmr_cache_hold(fib_work->men_info.mfc);\n\t\tbreak;\n\tcase FIB_EVENT_VIF_ADD:\n\tcase FIB_EVENT_VIF_DEL:\n\t\tmemcpy(&fib_work->ven_info, info, sizeof(fib_work->ven_info));\n\t\tnetdev_hold(fib_work->ven_info.dev, &fib_work->dev_tracker,\n\t\t\t    GFP_ATOMIC);\n\t\tbreak;\n\t}\n}\n\nstatic int mlxsw_sp_router_fib_rule_event(unsigned long event,\n\t\t\t\t\t  struct fib_notifier_info *info,\n\t\t\t\t\t  struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct fib_rule_notifier_info *fr_info;\n\tstruct fib_rule *rule;\n\tint err = 0;\n\n\t \n\tif (event == FIB_EVENT_RULE_DEL)\n\t\treturn 0;\n\n\tfr_info = container_of(info, struct fib_rule_notifier_info, info);\n\trule = fr_info->rule;\n\n\t \n\tif (rule->iifindex == mlxsw_sp_net(mlxsw_sp)->loopback_dev->ifindex)\n\t\treturn 0;\n\n\tswitch (info->family) {\n\tcase AF_INET:\n\t\tif (!fib4_rule_default(rule) && !rule->l3mdev)\n\t\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (!fib6_rule_default(rule) && !rule->l3mdev)\n\t\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\tcase RTNL_FAMILY_IPMR:\n\t\tif (!ipmr_rule_default(rule) && !rule->l3mdev)\n\t\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\tcase RTNL_FAMILY_IP6MR:\n\t\tif (!ip6mr_rule_default(rule) && !rule->l3mdev)\n\t\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (err < 0)\n\t\tNL_SET_ERR_MSG_MOD(extack, \"FIB rules not supported\");\n\n\treturn err;\n}\n\n \nstatic int mlxsw_sp_router_fib_event(struct notifier_block *nb,\n\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct mlxsw_sp_fib_event_work *fib_work;\n\tstruct fib_notifier_info *info = ptr;\n\tstruct mlxsw_sp_router *router;\n\tint err;\n\n\tif ((info->family != AF_INET && info->family != AF_INET6 &&\n\t     info->family != RTNL_FAMILY_IPMR &&\n\t     info->family != RTNL_FAMILY_IP6MR))\n\t\treturn NOTIFY_DONE;\n\n\trouter = container_of(nb, struct mlxsw_sp_router, fib_nb);\n\n\tswitch (event) {\n\tcase FIB_EVENT_RULE_ADD:\n\tcase FIB_EVENT_RULE_DEL:\n\t\terr = mlxsw_sp_router_fib_rule_event(event, info,\n\t\t\t\t\t\t     router->mlxsw_sp);\n\t\treturn notifier_from_errno(err);\n\tcase FIB_EVENT_ENTRY_ADD:\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\tcase FIB_EVENT_ENTRY_APPEND:\n\t\tif (info->family == AF_INET) {\n\t\t\tstruct fib_entry_notifier_info *fen_info = ptr;\n\n\t\t\tif (fen_info->fi->fib_nh_is_v6) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(info->extack, \"IPv6 gateway with IPv4 route is not supported\");\n\t\t\t\treturn notifier_from_errno(-EINVAL);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tfib_work = kzalloc(sizeof(*fib_work), GFP_ATOMIC);\n\tif (!fib_work)\n\t\treturn NOTIFY_BAD;\n\n\tfib_work->mlxsw_sp = router->mlxsw_sp;\n\tfib_work->event = event;\n\n\tswitch (info->family) {\n\tcase AF_INET:\n\t\tINIT_WORK(&fib_work->work, mlxsw_sp_router_fib4_event_work);\n\t\tmlxsw_sp_router_fib4_event(fib_work, info);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tINIT_WORK(&fib_work->work, mlxsw_sp_router_fib6_event_work);\n\t\terr = mlxsw_sp_router_fib6_event(fib_work, info);\n\t\tif (err)\n\t\t\tgoto err_fib_event;\n\t\tbreak;\n\tcase RTNL_FAMILY_IP6MR:\n\tcase RTNL_FAMILY_IPMR:\n\t\tINIT_WORK(&fib_work->work, mlxsw_sp_router_fibmr_event_work);\n\t\tmlxsw_sp_router_fibmr_event(fib_work, info);\n\t\tbreak;\n\t}\n\n\tmlxsw_core_schedule_work(&fib_work->work);\n\n\treturn NOTIFY_DONE;\n\nerr_fib_event:\n\tkfree(fib_work);\n\treturn NOTIFY_BAD;\n}\n\nstatic struct mlxsw_sp_rif *\nmlxsw_sp_rif_find_by_dev(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t const struct net_device *dev)\n{\n\tint max_rifs = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS);\n\tint i;\n\n\tfor (i = 0; i < max_rifs; i++)\n\t\tif (mlxsw_sp->router->rifs[i] &&\n\t\t    mlxsw_sp_rif_dev_is(mlxsw_sp->router->rifs[i], dev))\n\t\t\treturn mlxsw_sp->router->rifs[i];\n\n\treturn NULL;\n}\n\nbool mlxsw_sp_rif_exists(struct mlxsw_sp *mlxsw_sp,\n\t\t\t const struct net_device *dev)\n{\n\tstruct mlxsw_sp_rif *rif;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, dev);\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\n\treturn rif;\n}\n\nu16 mlxsw_sp_rif_vid(struct mlxsw_sp *mlxsw_sp, const struct net_device *dev)\n{\n\tstruct mlxsw_sp_rif *rif;\n\tu16 vid = 0;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, dev);\n\tif (!rif)\n\t\tgoto out;\n\n\t \n\tif (rif->ops->type != MLXSW_SP_RIF_TYPE_VLAN)\n\t\tgoto out;\n\n\tvid = mlxsw_sp_fid_8021q_vid(rif->fid);\n\nout:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\treturn vid;\n}\n\nstatic int mlxsw_sp_router_rif_disable(struct mlxsw_sp *mlxsw_sp, u16 rif)\n{\n\tchar ritr_pl[MLXSW_REG_RITR_LEN];\n\tint err;\n\n\tmlxsw_reg_ritr_rif_pack(ritr_pl, rif);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_ritr_enable_set(ritr_pl, false);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);\n}\n\nstatic int mlxsw_sp_router_rif_made_sync(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t struct mlxsw_sp_rif *rif)\n{\n\tint err;\n\n\terr = mlxsw_sp_neigh_rif_made_sync(mlxsw_sp, rif);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_nexthop_rif_made_sync(mlxsw_sp, rif);\n\tif (err)\n\t\tgoto err_nexthop;\n\n\treturn 0;\n\nerr_nexthop:\n\tmlxsw_sp_neigh_rif_gone_sync(mlxsw_sp, rif);\n\treturn err;\n}\n\nstatic void mlxsw_sp_router_rif_gone_sync(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct mlxsw_sp_rif *rif)\n{\n\t \n\trif->crif->rif = NULL;\n\n\tmlxsw_sp_router_rif_disable(mlxsw_sp, rif->rif_index);\n\tmlxsw_sp_nexthop_rif_gone_sync(mlxsw_sp, rif);\n\tmlxsw_sp_neigh_rif_gone_sync(mlxsw_sp, rif);\n}\n\nstatic bool __mlxsw_sp_dev_addr_list_empty(const struct net_device *dev)\n{\n\tstruct inet6_dev *inet6_dev;\n\tstruct in_device *idev;\n\n\tidev = __in_dev_get_rcu(dev);\n\tif (idev && idev->ifa_list)\n\t\treturn false;\n\n\tinet6_dev = __in6_dev_get(dev);\n\tif (inet6_dev && !list_empty(&inet6_dev->addr_list))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool mlxsw_sp_dev_addr_list_empty(const struct net_device *dev)\n{\n\tbool addr_list_empty;\n\n\trcu_read_lock();\n\taddr_list_empty = __mlxsw_sp_dev_addr_list_empty(dev);\n\trcu_read_unlock();\n\n\treturn addr_list_empty;\n}\n\nstatic bool\nmlxsw_sp_rif_should_config(struct mlxsw_sp_rif *rif, struct net_device *dev,\n\t\t\t   unsigned long event)\n{\n\tbool addr_list_empty;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\treturn rif == NULL;\n\tcase NETDEV_DOWN:\n\t\taddr_list_empty = mlxsw_sp_dev_addr_list_empty(dev);\n\n\t\t \n\t\tif (netif_is_macvlan(dev) && addr_list_empty)\n\t\t\treturn true;\n\n\t\tif (rif && addr_list_empty &&\n\t\t    !netif_is_l3_slave(mlxsw_sp_rif_dev(rif)))\n\t\t\treturn true;\n\t\t \n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nstatic enum mlxsw_sp_rif_type\nmlxsw_sp_dev_rif_type(const struct mlxsw_sp *mlxsw_sp,\n\t\t      const struct net_device *dev)\n{\n\tenum mlxsw_sp_fid_type type;\n\n\tif (mlxsw_sp_netdev_ipip_type(mlxsw_sp, dev, NULL))\n\t\treturn MLXSW_SP_RIF_TYPE_IPIP_LB;\n\n\t \n\tif (is_vlan_dev(dev) && netif_is_bridge_master(vlan_dev_real_dev(dev)))\n\t\ttype = MLXSW_SP_FID_TYPE_8021Q;\n\telse if (netif_is_bridge_master(dev) && br_vlan_enabled(dev))\n\t\ttype = MLXSW_SP_FID_TYPE_8021Q;\n\telse if (netif_is_bridge_master(dev))\n\t\ttype = MLXSW_SP_FID_TYPE_8021D;\n\telse\n\t\ttype = MLXSW_SP_FID_TYPE_RFID;\n\n\treturn mlxsw_sp_fid_type_rif_type(mlxsw_sp, type);\n}\n\nstatic int mlxsw_sp_rif_index_alloc(struct mlxsw_sp *mlxsw_sp, u16 *p_rif_index,\n\t\t\t\t    u8 rif_entries)\n{\n\t*p_rif_index = gen_pool_alloc(mlxsw_sp->router->rifs_table,\n\t\t\t\t      rif_entries);\n\tif (*p_rif_index == 0)\n\t\treturn -ENOBUFS;\n\t*p_rif_index -= MLXSW_SP_ROUTER_GENALLOC_OFFSET;\n\n\t \n\tWARN_ON_ONCE(*p_rif_index % rif_entries);\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_rif_index_free(struct mlxsw_sp *mlxsw_sp, u16 rif_index,\n\t\t\t\t    u8 rif_entries)\n{\n\tgen_pool_free(mlxsw_sp->router->rifs_table,\n\t\t      MLXSW_SP_ROUTER_GENALLOC_OFFSET + rif_index, rif_entries);\n}\n\nstatic struct mlxsw_sp_rif *mlxsw_sp_rif_alloc(size_t rif_size, u16 rif_index,\n\t\t\t\t\t       u16 vr_id,\n\t\t\t\t\t       struct mlxsw_sp_crif *crif)\n{\n\tstruct net_device *l3_dev = crif ? crif->key.dev : NULL;\n\tstruct mlxsw_sp_rif *rif;\n\n\trif = kzalloc(rif_size, GFP_KERNEL);\n\tif (!rif)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&rif->neigh_list);\n\tif (l3_dev) {\n\t\tether_addr_copy(rif->addr, l3_dev->dev_addr);\n\t\trif->mtu = l3_dev->mtu;\n\t}\n\trif->vr_id = vr_id;\n\trif->rif_index = rif_index;\n\tif (crif) {\n\t\trif->crif = crif;\n\t\tcrif->rif = rif;\n\t}\n\n\treturn rif;\n}\n\nstatic void mlxsw_sp_rif_free(struct mlxsw_sp_rif *rif)\n{\n\tWARN_ON(!list_empty(&rif->neigh_list));\n\n\tif (rif->crif)\n\t\trif->crif->rif = NULL;\n\tkfree(rif);\n}\n\nstruct mlxsw_sp_rif *mlxsw_sp_rif_by_index(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   u16 rif_index)\n{\n\treturn mlxsw_sp->router->rifs[rif_index];\n}\n\nu16 mlxsw_sp_rif_index(const struct mlxsw_sp_rif *rif)\n{\n\treturn rif->rif_index;\n}\n\nu16 mlxsw_sp_ipip_lb_rif_index(const struct mlxsw_sp_rif_ipip_lb *lb_rif)\n{\n\treturn lb_rif->common.rif_index;\n}\n\nu16 mlxsw_sp_ipip_lb_ul_vr_id(const struct mlxsw_sp_rif_ipip_lb *lb_rif)\n{\n\tstruct net_device *dev = mlxsw_sp_rif_dev(&lb_rif->common);\n\tu32 ul_tb_id = mlxsw_sp_ipip_dev_ul_tb_id(dev);\n\tstruct mlxsw_sp_vr *ul_vr;\n\n\tul_vr = mlxsw_sp_vr_get(lb_rif->common.mlxsw_sp, ul_tb_id, NULL);\n\tif (WARN_ON(IS_ERR(ul_vr)))\n\t\treturn 0;\n\n\treturn ul_vr->id;\n}\n\nu16 mlxsw_sp_ipip_lb_ul_rif_id(const struct mlxsw_sp_rif_ipip_lb *lb_rif)\n{\n\treturn lb_rif->ul_rif_id;\n}\n\nstatic bool\nmlxsw_sp_router_port_l3_stats_enabled(struct mlxsw_sp_rif *rif)\n{\n\treturn mlxsw_sp_rif_counter_valid_get(rif,\n\t\t\t\t\t      MLXSW_SP_RIF_COUNTER_EGRESS) &&\n\t       mlxsw_sp_rif_counter_valid_get(rif,\n\t\t\t\t\t      MLXSW_SP_RIF_COUNTER_INGRESS);\n}\n\nstatic int\nmlxsw_sp_router_port_l3_stats_enable(struct mlxsw_sp_rif *rif)\n{\n\tint err;\n\n\terr = mlxsw_sp_rif_counter_alloc(rif, MLXSW_SP_RIF_COUNTER_INGRESS);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mlxsw_sp_rif_counter_fetch_clear(rif,\n\t\t\t\t\t       MLXSW_SP_RIF_COUNTER_INGRESS,\n\t\t\t\t\t       NULL);\n\tif (err)\n\t\tgoto err_clear_ingress;\n\n\terr = mlxsw_sp_rif_counter_alloc(rif, MLXSW_SP_RIF_COUNTER_EGRESS);\n\tif (err)\n\t\tgoto err_alloc_egress;\n\n\t \n\terr = mlxsw_sp_rif_counter_fetch_clear(rif,\n\t\t\t\t\t       MLXSW_SP_RIF_COUNTER_EGRESS,\n\t\t\t\t\t       NULL);\n\tif (err)\n\t\tgoto err_clear_egress;\n\n\treturn 0;\n\nerr_clear_egress:\n\tmlxsw_sp_rif_counter_free(rif, MLXSW_SP_RIF_COUNTER_EGRESS);\nerr_alloc_egress:\nerr_clear_ingress:\n\tmlxsw_sp_rif_counter_free(rif, MLXSW_SP_RIF_COUNTER_INGRESS);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_router_port_l3_stats_disable(struct mlxsw_sp_rif *rif)\n{\n\tmlxsw_sp_rif_counter_free(rif, MLXSW_SP_RIF_COUNTER_EGRESS);\n\tmlxsw_sp_rif_counter_free(rif, MLXSW_SP_RIF_COUNTER_INGRESS);\n}\n\nstatic void\nmlxsw_sp_router_port_l3_stats_report_used(struct mlxsw_sp_rif *rif,\n\t\t\t\t\t  struct netdev_notifier_offload_xstats_info *info)\n{\n\tif (!mlxsw_sp_router_port_l3_stats_enabled(rif))\n\t\treturn;\n\tnetdev_offload_xstats_report_used(info->report_used);\n}\n\nstatic int\nmlxsw_sp_router_port_l3_stats_fetch(struct mlxsw_sp_rif *rif,\n\t\t\t\t    struct rtnl_hw_stats64 *p_stats)\n{\n\tstruct mlxsw_sp_rif_counter_set_basic ingress;\n\tstruct mlxsw_sp_rif_counter_set_basic egress;\n\tint err;\n\n\terr = mlxsw_sp_rif_counter_fetch_clear(rif,\n\t\t\t\t\t       MLXSW_SP_RIF_COUNTER_INGRESS,\n\t\t\t\t\t       &ingress);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_rif_counter_fetch_clear(rif,\n\t\t\t\t\t       MLXSW_SP_RIF_COUNTER_EGRESS,\n\t\t\t\t\t       &egress);\n\tif (err)\n\t\treturn err;\n\n#define MLXSW_SP_ROUTER_ALL_GOOD(SET, SFX)\t\t\\\n\t\t((SET.good_unicast_ ## SFX) +\t\t\\\n\t\t (SET.good_multicast_ ## SFX) +\t\t\\\n\t\t (SET.good_broadcast_ ## SFX))\n\n\tp_stats->rx_packets = MLXSW_SP_ROUTER_ALL_GOOD(ingress, packets);\n\tp_stats->tx_packets = MLXSW_SP_ROUTER_ALL_GOOD(egress, packets);\n\tp_stats->rx_bytes = MLXSW_SP_ROUTER_ALL_GOOD(ingress, bytes);\n\tp_stats->tx_bytes = MLXSW_SP_ROUTER_ALL_GOOD(egress, bytes);\n\tp_stats->rx_errors = ingress.error_packets;\n\tp_stats->tx_errors = egress.error_packets;\n\tp_stats->rx_dropped = ingress.discard_packets;\n\tp_stats->tx_dropped = egress.discard_packets;\n\tp_stats->multicast = ingress.good_multicast_packets +\n\t\t\t     ingress.good_broadcast_packets;\n\n#undef MLXSW_SP_ROUTER_ALL_GOOD\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_router_port_l3_stats_report_delta(struct mlxsw_sp_rif *rif,\n\t\t\t\t\t   struct netdev_notifier_offload_xstats_info *info)\n{\n\tstruct rtnl_hw_stats64 stats = {};\n\tint err;\n\n\tif (!mlxsw_sp_router_port_l3_stats_enabled(rif))\n\t\treturn 0;\n\n\terr = mlxsw_sp_router_port_l3_stats_fetch(rif, &stats);\n\tif (err)\n\t\treturn err;\n\n\tnetdev_offload_xstats_report_delta(info->report_delta, &stats);\n\treturn 0;\n}\n\nstruct mlxsw_sp_router_hwstats_notify_work {\n\tstruct work_struct work;\n\tstruct net_device *dev;\n\tnetdevice_tracker dev_tracker;\n};\n\nstatic void mlxsw_sp_router_hwstats_notify_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_router_hwstats_notify_work *hws_work =\n\t\tcontainer_of(work, struct mlxsw_sp_router_hwstats_notify_work,\n\t\t\t     work);\n\n\trtnl_lock();\n\trtnl_offload_xstats_notify(hws_work->dev);\n\trtnl_unlock();\n\tnetdev_put(hws_work->dev, &hws_work->dev_tracker);\n\tkfree(hws_work);\n}\n\nstatic void\nmlxsw_sp_router_hwstats_notify_schedule(struct net_device *dev)\n{\n\tstruct mlxsw_sp_router_hwstats_notify_work *hws_work;\n\n\t \n\n\thws_work = kzalloc(sizeof(*hws_work), GFP_KERNEL);\n\tif (!hws_work)\n\t\treturn;\n\n\tINIT_WORK(&hws_work->work, mlxsw_sp_router_hwstats_notify_work);\n\tnetdev_hold(dev, &hws_work->dev_tracker, GFP_KERNEL);\n\thws_work->dev = dev;\n\tmlxsw_core_schedule_work(&hws_work->work);\n}\n\nint mlxsw_sp_rif_dev_ifindex(const struct mlxsw_sp_rif *rif)\n{\n\treturn mlxsw_sp_rif_dev(rif)->ifindex;\n}\n\nbool mlxsw_sp_rif_has_dev(const struct mlxsw_sp_rif *rif)\n{\n\treturn !!mlxsw_sp_rif_dev(rif);\n}\n\nbool mlxsw_sp_rif_dev_is(const struct mlxsw_sp_rif *rif,\n\t\t\t const struct net_device *dev)\n{\n\treturn mlxsw_sp_rif_dev(rif) == dev;\n}\n\nstatic void mlxsw_sp_rif_push_l3_stats(struct mlxsw_sp_rif *rif)\n{\n\tstruct rtnl_hw_stats64 stats = {};\n\n\tif (!mlxsw_sp_router_port_l3_stats_fetch(rif, &stats))\n\t\tnetdev_offload_xstats_push_delta(mlxsw_sp_rif_dev(rif),\n\t\t\t\t\t\t NETDEV_OFFLOAD_XSTATS_TYPE_L3,\n\t\t\t\t\t\t &stats);\n}\n\nstatic struct mlxsw_sp_rif *\nmlxsw_sp_rif_create(struct mlxsw_sp *mlxsw_sp,\n\t\t    const struct mlxsw_sp_rif_params *params,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tu8 rif_entries = params->double_entry ? 2 : 1;\n\tu32 tb_id = l3mdev_fib_table(params->dev);\n\tconst struct mlxsw_sp_rif_ops *ops;\n\tstruct mlxsw_sp_fid *fid = NULL;\n\tenum mlxsw_sp_rif_type type;\n\tstruct mlxsw_sp_crif *crif;\n\tstruct mlxsw_sp_rif *rif;\n\tstruct mlxsw_sp_vr *vr;\n\tu16 rif_index;\n\tint i, err;\n\n\ttype = mlxsw_sp_dev_rif_type(mlxsw_sp, params->dev);\n\tops = mlxsw_sp->router->rif_ops_arr[type];\n\n\tvr = mlxsw_sp_vr_get(mlxsw_sp, tb_id ? : RT_TABLE_MAIN, extack);\n\tif (IS_ERR(vr))\n\t\treturn ERR_CAST(vr);\n\tvr->rif_count++;\n\n\terr = mlxsw_sp_rif_index_alloc(mlxsw_sp, &rif_index, rif_entries);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Exceeded number of supported router interfaces\");\n\t\tgoto err_rif_index_alloc;\n\t}\n\n\tcrif = mlxsw_sp_crif_lookup(mlxsw_sp->router, params->dev);\n\tif (WARN_ON(!crif)) {\n\t\terr = -ENOENT;\n\t\tgoto err_crif_lookup;\n\t}\n\n\trif = mlxsw_sp_rif_alloc(ops->rif_size, rif_index, vr->id, crif);\n\tif (!rif) {\n\t\terr = -ENOMEM;\n\t\tgoto err_rif_alloc;\n\t}\n\tnetdev_hold(params->dev, &rif->dev_tracker, GFP_KERNEL);\n\tmlxsw_sp->router->rifs[rif_index] = rif;\n\trif->mlxsw_sp = mlxsw_sp;\n\trif->ops = ops;\n\trif->rif_entries = rif_entries;\n\n\tif (ops->fid_get) {\n\t\tfid = ops->fid_get(rif, params, extack);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tgoto err_fid_get;\n\t\t}\n\t\trif->fid = fid;\n\t}\n\n\tif (ops->setup)\n\t\tops->setup(rif, params);\n\n\terr = ops->configure(rif, extack);\n\tif (err)\n\t\tgoto err_configure;\n\n\tfor (i = 0; i < MLXSW_SP_L3_PROTO_MAX; i++) {\n\t\terr = mlxsw_sp_mr_rif_add(vr->mr_table[i], rif);\n\t\tif (err)\n\t\t\tgoto err_mr_rif_add;\n\t}\n\n\terr = mlxsw_sp_router_rif_made_sync(mlxsw_sp, rif);\n\tif (err)\n\t\tgoto err_rif_made_sync;\n\n\tif (netdev_offload_xstats_enabled(params->dev,\n\t\t\t\t\t  NETDEV_OFFLOAD_XSTATS_TYPE_L3)) {\n\t\terr = mlxsw_sp_router_port_l3_stats_enable(rif);\n\t\tif (err)\n\t\t\tgoto err_stats_enable;\n\t\tmlxsw_sp_router_hwstats_notify_schedule(params->dev);\n\t} else {\n\t\tmlxsw_sp_rif_counters_alloc(rif);\n\t}\n\n\tatomic_add(rif_entries, &mlxsw_sp->router->rifs_count);\n\treturn rif;\n\nerr_stats_enable:\n\tmlxsw_sp_router_rif_gone_sync(mlxsw_sp, rif);\nerr_rif_made_sync:\nerr_mr_rif_add:\n\tfor (i--; i >= 0; i--)\n\t\tmlxsw_sp_mr_rif_del(vr->mr_table[i], rif);\n\tops->deconfigure(rif);\nerr_configure:\n\tif (fid)\n\t\tmlxsw_sp_fid_put(fid);\nerr_fid_get:\n\tmlxsw_sp->router->rifs[rif_index] = NULL;\n\tnetdev_put(params->dev, &rif->dev_tracker);\n\tmlxsw_sp_rif_free(rif);\nerr_rif_alloc:\nerr_crif_lookup:\n\tmlxsw_sp_rif_index_free(mlxsw_sp, rif_index, rif_entries);\nerr_rif_index_alloc:\n\tvr->rif_count--;\n\tmlxsw_sp_vr_put(mlxsw_sp, vr);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_rif_destroy(struct mlxsw_sp_rif *rif)\n{\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tconst struct mlxsw_sp_rif_ops *ops = rif->ops;\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tstruct mlxsw_sp_crif *crif = rif->crif;\n\tstruct mlxsw_sp_fid *fid = rif->fid;\n\tu8 rif_entries = rif->rif_entries;\n\tu16 rif_index = rif->rif_index;\n\tstruct mlxsw_sp_vr *vr;\n\tint i;\n\n\tatomic_sub(rif_entries, &mlxsw_sp->router->rifs_count);\n\tmlxsw_sp_router_rif_gone_sync(mlxsw_sp, rif);\n\tvr = &mlxsw_sp->router->vrs[rif->vr_id];\n\n\tif (netdev_offload_xstats_enabled(dev, NETDEV_OFFLOAD_XSTATS_TYPE_L3)) {\n\t\tmlxsw_sp_rif_push_l3_stats(rif);\n\t\tmlxsw_sp_router_port_l3_stats_disable(rif);\n\t\tmlxsw_sp_router_hwstats_notify_schedule(dev);\n\t} else {\n\t\tmlxsw_sp_rif_counters_free(rif);\n\t}\n\n\tfor (i = 0; i < MLXSW_SP_L3_PROTO_MAX; i++)\n\t\tmlxsw_sp_mr_rif_del(vr->mr_table[i], rif);\n\tops->deconfigure(rif);\n\tif (fid)\n\t\t \n\t\tmlxsw_sp_fid_put(fid);\n\tmlxsw_sp->router->rifs[rif->rif_index] = NULL;\n\tnetdev_put(dev, &rif->dev_tracker);\n\tmlxsw_sp_rif_free(rif);\n\tmlxsw_sp_rif_index_free(mlxsw_sp, rif_index, rif_entries);\n\tvr->rif_count--;\n\tmlxsw_sp_vr_put(mlxsw_sp, vr);\n\n\tif (crif->can_destroy)\n\t\tmlxsw_sp_crif_free(crif);\n}\n\nvoid mlxsw_sp_rif_destroy_by_dev(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct mlxsw_sp_rif *rif;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, dev);\n\tif (!rif)\n\t\tgoto out;\n\tmlxsw_sp_rif_destroy(rif);\nout:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n}\n\nstatic void mlxsw_sp_rif_destroy_vlan_upper(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    struct net_device *br_dev,\n\t\t\t\t\t    u16 vid)\n{\n\tstruct net_device *upper_dev;\n\tstruct mlxsw_sp_crif *crif;\n\n\trcu_read_lock();\n\tupper_dev = __vlan_find_dev_deep_rcu(br_dev, htons(ETH_P_8021Q), vid);\n\trcu_read_unlock();\n\n\tif (!upper_dev)\n\t\treturn;\n\n\tcrif = mlxsw_sp_crif_lookup(mlxsw_sp->router, upper_dev);\n\tif (!crif || !crif->rif)\n\t\treturn;\n\n\tmlxsw_sp_rif_destroy(crif->rif);\n}\n\nstatic int mlxsw_sp_inetaddr_bridge_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct net_device *l3_dev,\n\t\t\t\t\t  int lower_pvid,\n\t\t\t\t\t  unsigned long event,\n\t\t\t\t\t  struct netlink_ext_ack *extack);\n\nint mlxsw_sp_router_bridge_vlan_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct net_device *br_dev,\n\t\t\t\t    u16 new_vid, bool is_pvid,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_rif *old_rif;\n\tstruct mlxsw_sp_rif *new_rif;\n\tstruct net_device *upper_dev;\n\tu16 old_pvid = 0;\n\tu16 new_pvid;\n\tint err = 0;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\told_rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, br_dev);\n\tif (old_rif) {\n\t\t \n\t\tif (WARN_ON(old_rif->ops->type != MLXSW_SP_RIF_TYPE_VLAN))\n\t\t\told_rif = NULL;\n\t\telse\n\t\t\told_pvid = mlxsw_sp_fid_8021q_vid(old_rif->fid);\n\t}\n\n\tif (is_pvid)\n\t\tnew_pvid = new_vid;\n\telse if (old_pvid == new_vid)\n\t\tnew_pvid = 0;\n\telse\n\t\tgoto out;\n\n\tif (old_pvid == new_pvid)\n\t\tgoto out;\n\n\tif (new_pvid) {\n\t\tstruct mlxsw_sp_rif_params params = {\n\t\t\t.dev = br_dev,\n\t\t\t.vid = new_pvid,\n\t\t};\n\n\t\t \n\t\tmlxsw_sp_rif_destroy_vlan_upper(mlxsw_sp, br_dev, new_pvid);\n\n\t\tif (mlxsw_sp_dev_addr_list_empty(br_dev))\n\t\t\tgoto out;\n\t\tnew_rif = mlxsw_sp_rif_create(mlxsw_sp, &params, extack);\n\t\tif (IS_ERR(new_rif)) {\n\t\t\terr = PTR_ERR(new_rif);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (old_pvid)\n\t\t\tmlxsw_sp_rif_migrate_destroy(mlxsw_sp, old_rif, new_rif,\n\t\t\t\t\t\t     true);\n\t} else {\n\t\tmlxsw_sp_rif_destroy(old_rif);\n\t}\n\n\tif (old_pvid) {\n\t\trcu_read_lock();\n\t\tupper_dev = __vlan_find_dev_deep_rcu(br_dev, htons(ETH_P_8021Q),\n\t\t\t\t\t\t     old_pvid);\n\t\trcu_read_unlock();\n\t\tif (upper_dev)\n\t\t\terr = mlxsw_sp_inetaddr_bridge_event(mlxsw_sp,\n\t\t\t\t\t\t\t     upper_dev,\n\t\t\t\t\t\t\t     new_pvid,\n\t\t\t\t\t\t\t     NETDEV_UP, extack);\n\t}\n\nout:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_rif_subport_params_init(struct mlxsw_sp_rif_params *params,\n\t\t\t\t struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;\n\n\tparams->vid = mlxsw_sp_port_vlan->vid;\n\tparams->lag = mlxsw_sp_port->lagged;\n\tif (params->lag)\n\t\tparams->lag_id = mlxsw_sp_port->lag_id;\n\telse\n\t\tparams->system_port = mlxsw_sp_port->local_port;\n}\n\nstatic struct mlxsw_sp_rif_subport *\nmlxsw_sp_rif_subport_rif(const struct mlxsw_sp_rif *rif)\n{\n\treturn container_of(rif, struct mlxsw_sp_rif_subport, common);\n}\n\nstatic struct mlxsw_sp_rif *\nmlxsw_sp_rif_subport_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t const struct mlxsw_sp_rif_params *params,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_rif_subport *rif_subport;\n\tstruct mlxsw_sp_rif *rif;\n\n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, params->dev);\n\tif (!rif)\n\t\treturn mlxsw_sp_rif_create(mlxsw_sp, params, extack);\n\n\trif_subport = mlxsw_sp_rif_subport_rif(rif);\n\trefcount_inc(&rif_subport->ref_count);\n\treturn rif;\n}\n\nstatic void mlxsw_sp_rif_subport_put(struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp_rif_subport *rif_subport;\n\n\trif_subport = mlxsw_sp_rif_subport_rif(rif);\n\tif (!refcount_dec_and_test(&rif_subport->ref_count))\n\t\treturn;\n\n\tmlxsw_sp_rif_destroy(rif);\n}\n\nstatic int mlxsw_sp_rif_mac_profile_index_alloc(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tstruct mlxsw_sp_rif_mac_profile *profile,\n\t\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tu8 max_rif_mac_profiles = mlxsw_sp->router->max_rif_mac_profile;\n\tstruct mlxsw_sp_router *router = mlxsw_sp->router;\n\tint id;\n\n\tid = idr_alloc(&router->rif_mac_profiles_idr, profile, 0,\n\t\t       max_rif_mac_profiles, GFP_KERNEL);\n\n\tif (id >= 0) {\n\t\tprofile->id = id;\n\t\treturn 0;\n\t}\n\n\tif (id == -ENOSPC)\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Exceeded number of supported router interface MAC profiles\");\n\n\treturn id;\n}\n\nstatic struct mlxsw_sp_rif_mac_profile *\nmlxsw_sp_rif_mac_profile_index_free(struct mlxsw_sp *mlxsw_sp, u8 mac_profile)\n{\n\tstruct mlxsw_sp_rif_mac_profile *profile;\n\n\tprofile = idr_remove(&mlxsw_sp->router->rif_mac_profiles_idr,\n\t\t\t     mac_profile);\n\tWARN_ON(!profile);\n\treturn profile;\n}\n\nstatic struct mlxsw_sp_rif_mac_profile *\nmlxsw_sp_rif_mac_profile_alloc(const char *mac)\n{\n\tstruct mlxsw_sp_rif_mac_profile *profile;\n\n\tprofile = kzalloc(sizeof(*profile), GFP_KERNEL);\n\tif (!profile)\n\t\treturn NULL;\n\n\tether_addr_copy(profile->mac_prefix, mac);\n\trefcount_set(&profile->ref_count, 1);\n\treturn profile;\n}\n\nstatic struct mlxsw_sp_rif_mac_profile *\nmlxsw_sp_rif_mac_profile_find(const struct mlxsw_sp *mlxsw_sp, const char *mac)\n{\n\tstruct mlxsw_sp_router *router = mlxsw_sp->router;\n\tstruct mlxsw_sp_rif_mac_profile *profile;\n\tint id;\n\n\tidr_for_each_entry(&router->rif_mac_profiles_idr, profile, id) {\n\t\tif (ether_addr_equal_masked(profile->mac_prefix, mac,\n\t\t\t\t\t    mlxsw_sp->mac_mask))\n\t\t\treturn profile;\n\t}\n\n\treturn NULL;\n}\n\nstatic u64 mlxsw_sp_rif_mac_profiles_occ_get(void *priv)\n{\n\tconst struct mlxsw_sp *mlxsw_sp = priv;\n\n\treturn atomic_read(&mlxsw_sp->router->rif_mac_profiles_count);\n}\n\nstatic u64 mlxsw_sp_rifs_occ_get(void *priv)\n{\n\tconst struct mlxsw_sp *mlxsw_sp = priv;\n\n\treturn atomic_read(&mlxsw_sp->router->rifs_count);\n}\n\nstatic struct mlxsw_sp_rif_mac_profile *\nmlxsw_sp_rif_mac_profile_create(struct mlxsw_sp *mlxsw_sp, const char *mac,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_rif_mac_profile *profile;\n\tint err;\n\n\tprofile = mlxsw_sp_rif_mac_profile_alloc(mac);\n\tif (!profile)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = mlxsw_sp_rif_mac_profile_index_alloc(mlxsw_sp, profile, extack);\n\tif (err)\n\t\tgoto profile_index_alloc_err;\n\n\tatomic_inc(&mlxsw_sp->router->rif_mac_profiles_count);\n\treturn profile;\n\nprofile_index_alloc_err:\n\tkfree(profile);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_rif_mac_profile_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t     u8 mac_profile)\n{\n\tstruct mlxsw_sp_rif_mac_profile *profile;\n\n\tatomic_dec(&mlxsw_sp->router->rif_mac_profiles_count);\n\tprofile = mlxsw_sp_rif_mac_profile_index_free(mlxsw_sp, mac_profile);\n\tkfree(profile);\n}\n\nstatic int mlxsw_sp_rif_mac_profile_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tconst char *mac, u8 *p_mac_profile,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_rif_mac_profile *profile;\n\n\tprofile = mlxsw_sp_rif_mac_profile_find(mlxsw_sp, mac);\n\tif (profile) {\n\t\trefcount_inc(&profile->ref_count);\n\t\tgoto out;\n\t}\n\n\tprofile = mlxsw_sp_rif_mac_profile_create(mlxsw_sp, mac, extack);\n\tif (IS_ERR(profile))\n\t\treturn PTR_ERR(profile);\n\nout:\n\t*p_mac_profile = profile->id;\n\treturn 0;\n}\n\nstatic void mlxsw_sp_rif_mac_profile_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t u8 mac_profile)\n{\n\tstruct mlxsw_sp_rif_mac_profile *profile;\n\n\tprofile = idr_find(&mlxsw_sp->router->rif_mac_profiles_idr,\n\t\t\t   mac_profile);\n\tif (WARN_ON(!profile))\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&profile->ref_count))\n\t\treturn;\n\n\tmlxsw_sp_rif_mac_profile_destroy(mlxsw_sp, mac_profile);\n}\n\nstatic bool mlxsw_sp_rif_mac_profile_is_shared(const struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tstruct mlxsw_sp_rif_mac_profile *profile;\n\n\tprofile = idr_find(&mlxsw_sp->router->rif_mac_profiles_idr,\n\t\t\t   rif->mac_profile_id);\n\tif (WARN_ON(!profile))\n\t\treturn false;\n\n\treturn refcount_read(&profile->ref_count) > 1;\n}\n\nstatic int mlxsw_sp_rif_mac_profile_edit(struct mlxsw_sp_rif *rif,\n\t\t\t\t\t const char *new_mac)\n{\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tstruct mlxsw_sp_rif_mac_profile *profile;\n\n\tprofile = idr_find(&mlxsw_sp->router->rif_mac_profiles_idr,\n\t\t\t   rif->mac_profile_id);\n\tif (WARN_ON(!profile))\n\t\treturn -EINVAL;\n\n\tether_addr_copy(profile->mac_prefix, new_mac);\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_rif_mac_profile_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_rif *rif,\n\t\t\t\t const char *new_mac,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tu8 mac_profile;\n\tint err;\n\n\tif (!mlxsw_sp_rif_mac_profile_is_shared(rif) &&\n\t    !mlxsw_sp_rif_mac_profile_find(mlxsw_sp, new_mac))\n\t\treturn mlxsw_sp_rif_mac_profile_edit(rif, new_mac);\n\n\terr = mlxsw_sp_rif_mac_profile_get(mlxsw_sp, new_mac,\n\t\t\t\t\t   &mac_profile, extack);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_sp_rif_mac_profile_put(mlxsw_sp, rif->mac_profile_id);\n\trif->mac_profile_id = mac_profile;\n\treturn 0;\n}\n\nstatic int\n__mlxsw_sp_port_vlan_router_join(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan,\n\t\t\t\t struct net_device *l3_dev,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_rif_params params;\n\tu16 vid = mlxsw_sp_port_vlan->vid;\n\tstruct mlxsw_sp_rif *rif;\n\tstruct mlxsw_sp_fid *fid;\n\tint err;\n\n\tparams = (struct mlxsw_sp_rif_params) {\n\t\t.dev = l3_dev,\n\t\t.vid = vid,\n\t};\n\n\tmlxsw_sp_rif_subport_params_init(&params, mlxsw_sp_port_vlan);\n\trif = mlxsw_sp_rif_subport_get(mlxsw_sp, &params, extack);\n\tif (IS_ERR(rif))\n\t\treturn PTR_ERR(rif);\n\n\t \n\tfid = rif->ops->fid_get(rif, &params, extack);\n\terr = mlxsw_sp_fid_port_vid_map(fid, mlxsw_sp_port, vid);\n\tif (err)\n\t\tgoto err_fid_port_vid_map;\n\n\terr = mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, false);\n\tif (err)\n\t\tgoto err_port_vid_learning_set;\n\n\terr = mlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid,\n\t\t\t\t\tBR_STATE_FORWARDING);\n\tif (err)\n\t\tgoto err_port_vid_stp_set;\n\n\tmlxsw_sp_port_vlan->fid = fid;\n\n\treturn 0;\n\nerr_port_vid_stp_set:\n\tmlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, true);\nerr_port_vid_learning_set:\n\tmlxsw_sp_fid_port_vid_unmap(fid, mlxsw_sp_port, vid);\nerr_fid_port_vid_map:\n\tmlxsw_sp_fid_put(fid);\n\tmlxsw_sp_rif_subport_put(rif);\n\treturn err;\n}\n\nstatic void\n__mlxsw_sp_port_vlan_router_leave(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;\n\tstruct mlxsw_sp_fid *fid = mlxsw_sp_port_vlan->fid;\n\tstruct mlxsw_sp_rif *rif = mlxsw_sp_fid_rif(fid);\n\tu16 vid = mlxsw_sp_port_vlan->vid;\n\n\tif (WARN_ON(mlxsw_sp_fid_type(fid) != MLXSW_SP_FID_TYPE_RFID))\n\t\treturn;\n\n\tmlxsw_sp_port_vlan->fid = NULL;\n\tmlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid, BR_STATE_BLOCKING);\n\tmlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, true);\n\tmlxsw_sp_fid_port_vid_unmap(fid, mlxsw_sp_port, vid);\n\tmlxsw_sp_fid_put(fid);\n\tmlxsw_sp_rif_subport_put(rif);\n}\n\nstatic int\nmlxsw_sp_port_vlan_router_join_existing(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan,\n\t\t\t\t\tstruct net_device *l3_dev,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port_vlan->mlxsw_sp_port->mlxsw_sp;\n\n\tlockdep_assert_held(&mlxsw_sp->router->lock);\n\n\tif (!mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev))\n\t\treturn 0;\n\n\treturn __mlxsw_sp_port_vlan_router_join(mlxsw_sp_port_vlan, l3_dev,\n\t\t\t\t\t\textack);\n}\n\nvoid\nmlxsw_sp_port_vlan_router_leave(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port_vlan->mlxsw_sp_port->mlxsw_sp;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\t__mlxsw_sp_port_vlan_router_leave(mlxsw_sp_port_vlan);\n\tmutex_unlock(&mlxsw_sp->router->lock);\n}\n\nstatic int mlxsw_sp_inetaddr_port_vlan_event(struct net_device *l3_dev,\n\t\t\t\t\t     struct net_device *port_dev,\n\t\t\t\t\t     unsigned long event, u16 vid,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(port_dev);\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);\n\tif (WARN_ON(!mlxsw_sp_port_vlan))\n\t\treturn -EINVAL;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\treturn __mlxsw_sp_port_vlan_router_join(mlxsw_sp_port_vlan,\n\t\t\t\t\t\t\tl3_dev, extack);\n\tcase NETDEV_DOWN:\n\t\t__mlxsw_sp_port_vlan_router_leave(mlxsw_sp_port_vlan);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_inetaddr_port_event(struct net_device *port_dev,\n\t\t\t\t\tunsigned long event, bool nomaster,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (!nomaster && (netif_is_any_bridge_port(port_dev) ||\n\t\t\t  netif_is_lag_port(port_dev)))\n\t\treturn 0;\n\n\treturn mlxsw_sp_inetaddr_port_vlan_event(port_dev, port_dev, event,\n\t\t\t\t\t\t MLXSW_SP_DEFAULT_VID, extack);\n}\n\nstatic int __mlxsw_sp_inetaddr_lag_event(struct net_device *l3_dev,\n\t\t\t\t\t struct net_device *lag_dev,\n\t\t\t\t\t unsigned long event, u16 vid,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net_device *port_dev;\n\tstruct list_head *iter;\n\tint err;\n\n\tnetdev_for_each_lower_dev(lag_dev, port_dev, iter) {\n\t\tif (mlxsw_sp_port_dev_check(port_dev)) {\n\t\t\terr = mlxsw_sp_inetaddr_port_vlan_event(l3_dev,\n\t\t\t\t\t\t\t\tport_dev,\n\t\t\t\t\t\t\t\tevent, vid,\n\t\t\t\t\t\t\t\textack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_inetaddr_lag_event(struct net_device *lag_dev,\n\t\t\t\t       unsigned long event, bool nomaster,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tif (!nomaster && netif_is_bridge_port(lag_dev))\n\t\treturn 0;\n\n\treturn __mlxsw_sp_inetaddr_lag_event(lag_dev, lag_dev, event,\n\t\t\t\t\t     MLXSW_SP_DEFAULT_VID, extack);\n}\n\nstatic int mlxsw_sp_inetaddr_bridge_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct net_device *l3_dev,\n\t\t\t\t\t  int lower_pvid,\n\t\t\t\t\t  unsigned long event,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_rif_params params = {\n\t\t.dev = l3_dev,\n\t};\n\tstruct mlxsw_sp_rif *rif;\n\tint err;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tif (netif_is_bridge_master(l3_dev) && br_vlan_enabled(l3_dev)) {\n\t\t\tu16 proto;\n\n\t\t\tbr_vlan_get_proto(l3_dev, &proto);\n\t\t\tif (proto == ETH_P_8021AD) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Adding an IP address to 802.1ad bridge is not supported\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\terr = br_vlan_get_pvid(l3_dev, &params.vid);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (!params.vid)\n\t\t\t\treturn 0;\n\t\t} else if (is_vlan_dev(l3_dev)) {\n\t\t\tparams.vid = vlan_dev_vlan_id(l3_dev);\n\n\t\t\t \n\t\t\tif ((int)params.vid == lower_pvid)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\trif = mlxsw_sp_rif_create(mlxsw_sp, &params, extack);\n\t\tif (IS_ERR(rif))\n\t\t\treturn PTR_ERR(rif);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);\n\t\tmlxsw_sp_rif_destroy(rif);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_inetaddr_vlan_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct net_device *vlan_dev,\n\t\t\t\t\tunsigned long event, bool nomaster,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net_device *real_dev = vlan_dev_real_dev(vlan_dev);\n\tu16 vid = vlan_dev_vlan_id(vlan_dev);\n\tu16 lower_pvid;\n\tint err;\n\n\tif (!nomaster && netif_is_bridge_port(vlan_dev))\n\t\treturn 0;\n\n\tif (mlxsw_sp_port_dev_check(real_dev)) {\n\t\treturn mlxsw_sp_inetaddr_port_vlan_event(vlan_dev, real_dev,\n\t\t\t\t\t\t\t event, vid, extack);\n\t} else if (netif_is_lag_master(real_dev)) {\n\t\treturn __mlxsw_sp_inetaddr_lag_event(vlan_dev, real_dev, event,\n\t\t\t\t\t\t     vid, extack);\n\t} else if (netif_is_bridge_master(real_dev) &&\n\t\t   br_vlan_enabled(real_dev)) {\n\t\terr = br_vlan_get_pvid(real_dev, &lower_pvid);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn mlxsw_sp_inetaddr_bridge_event(mlxsw_sp, vlan_dev,\n\t\t\t\t\t\t      lower_pvid, event,\n\t\t\t\t\t\t      extack);\n\t}\n\n\treturn 0;\n}\n\nstatic bool mlxsw_sp_rif_macvlan_is_vrrp4(const u8 *mac)\n{\n\tu8 vrrp4[ETH_ALEN] = { 0x00, 0x00, 0x5e, 0x00, 0x01, 0x00 };\n\tu8 mask[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0x00 };\n\n\treturn ether_addr_equal_masked(mac, vrrp4, mask);\n}\n\nstatic bool mlxsw_sp_rif_macvlan_is_vrrp6(const u8 *mac)\n{\n\tu8 vrrp6[ETH_ALEN] = { 0x00, 0x00, 0x5e, 0x00, 0x02, 0x00 };\n\tu8 mask[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0x00 };\n\n\treturn ether_addr_equal_masked(mac, vrrp6, mask);\n}\n\nstatic int mlxsw_sp_rif_vrrp_op(struct mlxsw_sp *mlxsw_sp, u16 rif_index,\n\t\t\t\tconst u8 *mac, bool adding)\n{\n\tchar ritr_pl[MLXSW_REG_RITR_LEN];\n\tu8 vrrp_id = adding ? mac[5] : 0;\n\tint err;\n\n\tif (!mlxsw_sp_rif_macvlan_is_vrrp4(mac) &&\n\t    !mlxsw_sp_rif_macvlan_is_vrrp6(mac))\n\t\treturn 0;\n\n\tmlxsw_reg_ritr_rif_pack(ritr_pl, rif_index);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);\n\tif (err)\n\t\treturn err;\n\n\tif (mlxsw_sp_rif_macvlan_is_vrrp4(mac))\n\t\tmlxsw_reg_ritr_if_vrrp_id_ipv4_set(ritr_pl, vrrp_id);\n\telse\n\t\tmlxsw_reg_ritr_if_vrrp_id_ipv6_set(ritr_pl, vrrp_id);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);\n}\n\nstatic int mlxsw_sp_rif_macvlan_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    const struct net_device *macvlan_dev,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(macvlan_dev);\n\tstruct mlxsw_sp_rif *rif;\n\tint err;\n\n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, vlan->lowerdev);\n\tif (!rif)\n\t\treturn 0;\n\n\terr = mlxsw_sp_rif_fdb_op(mlxsw_sp, macvlan_dev->dev_addr,\n\t\t\t\t  mlxsw_sp_fid_index(rif->fid), true);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_rif_vrrp_op(mlxsw_sp, rif->rif_index,\n\t\t\t\t   macvlan_dev->dev_addr, true);\n\tif (err)\n\t\tgoto err_rif_vrrp_add;\n\n\t \n\tif (rif->ops->fdb_del)\n\t\trif->ops->fdb_del(rif, macvlan_dev->dev_addr);\n\n\treturn 0;\n\nerr_rif_vrrp_add:\n\tmlxsw_sp_rif_fdb_op(mlxsw_sp, macvlan_dev->dev_addr,\n\t\t\t    mlxsw_sp_fid_index(rif->fid), false);\n\treturn err;\n}\n\nstatic void __mlxsw_sp_rif_macvlan_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       const struct net_device *macvlan_dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(macvlan_dev);\n\tstruct mlxsw_sp_rif *rif;\n\n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, vlan->lowerdev);\n\t \n\tif (!rif)\n\t\treturn;\n\tmlxsw_sp_rif_vrrp_op(mlxsw_sp, rif->rif_index, macvlan_dev->dev_addr,\n\t\t\t     false);\n\tmlxsw_sp_rif_fdb_op(mlxsw_sp, macvlan_dev->dev_addr,\n\t\t\t    mlxsw_sp_fid_index(rif->fid), false);\n}\n\nvoid mlxsw_sp_rif_macvlan_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      const struct net_device *macvlan_dev)\n{\n\tmutex_lock(&mlxsw_sp->router->lock);\n\t__mlxsw_sp_rif_macvlan_del(mlxsw_sp, macvlan_dev);\n\tmutex_unlock(&mlxsw_sp->router->lock);\n}\n\nstatic int mlxsw_sp_inetaddr_macvlan_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   struct net_device *macvlan_dev,\n\t\t\t\t\t   unsigned long event,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\treturn mlxsw_sp_rif_macvlan_add(mlxsw_sp, macvlan_dev, extack);\n\tcase NETDEV_DOWN:\n\t\t__mlxsw_sp_rif_macvlan_del(mlxsw_sp, macvlan_dev);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int __mlxsw_sp_inetaddr_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     unsigned long event, bool nomaster,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tif (mlxsw_sp_port_dev_check(dev))\n\t\treturn mlxsw_sp_inetaddr_port_event(dev, event, nomaster,\n\t\t\t\t\t\t    extack);\n\telse if (netif_is_lag_master(dev))\n\t\treturn mlxsw_sp_inetaddr_lag_event(dev, event, nomaster,\n\t\t\t\t\t\t   extack);\n\telse if (netif_is_bridge_master(dev))\n\t\treturn mlxsw_sp_inetaddr_bridge_event(mlxsw_sp, dev, -1, event,\n\t\t\t\t\t\t      extack);\n\telse if (is_vlan_dev(dev))\n\t\treturn mlxsw_sp_inetaddr_vlan_event(mlxsw_sp, dev, event,\n\t\t\t\t\t\t    nomaster, extack);\n\telse if (netif_is_macvlan(dev))\n\t\treturn mlxsw_sp_inetaddr_macvlan_event(mlxsw_sp, dev, event,\n\t\t\t\t\t\t       extack);\n\telse\n\t\treturn 0;\n}\n\nstatic int mlxsw_sp_inetaddr_event(struct notifier_block *nb,\n\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *) ptr;\n\tstruct net_device *dev = ifa->ifa_dev->dev;\n\tstruct mlxsw_sp_router *router;\n\tstruct mlxsw_sp_rif *rif;\n\tint err = 0;\n\n\t \n\tif (event == NETDEV_UP)\n\t\treturn NOTIFY_DONE;\n\n\trouter = container_of(nb, struct mlxsw_sp_router, inetaddr_nb);\n\tmutex_lock(&router->lock);\n\trif = mlxsw_sp_rif_find_by_dev(router->mlxsw_sp, dev);\n\tif (!mlxsw_sp_rif_should_config(rif, dev, event))\n\t\tgoto out;\n\n\terr = __mlxsw_sp_inetaddr_event(router->mlxsw_sp, dev, event, false,\n\t\t\t\t\tNULL);\nout:\n\tmutex_unlock(&router->lock);\n\treturn notifier_from_errno(err);\n}\n\nstatic int mlxsw_sp_inetaddr_valid_event(struct notifier_block *unused,\n\t\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct in_validator_info *ivi = (struct in_validator_info *) ptr;\n\tstruct net_device *dev = ivi->ivi_dev->dev;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct mlxsw_sp_rif *rif;\n\tint err = 0;\n\n\tmlxsw_sp = mlxsw_sp_lower_get(dev);\n\tif (!mlxsw_sp)\n\t\treturn NOTIFY_DONE;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, dev);\n\tif (!mlxsw_sp_rif_should_config(rif, dev, event))\n\t\tgoto out;\n\n\terr = __mlxsw_sp_inetaddr_event(mlxsw_sp, dev, event, false,\n\t\t\t\t\tivi->extack);\nout:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\treturn notifier_from_errno(err);\n}\n\nstruct mlxsw_sp_inet6addr_event_work {\n\tstruct work_struct work;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct net_device *dev;\n\tnetdevice_tracker dev_tracker;\n\tunsigned long event;\n};\n\nstatic void mlxsw_sp_inet6addr_event_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_inet6addr_event_work *inet6addr_work =\n\t\tcontainer_of(work, struct mlxsw_sp_inet6addr_event_work, work);\n\tstruct mlxsw_sp *mlxsw_sp = inet6addr_work->mlxsw_sp;\n\tstruct net_device *dev = inet6addr_work->dev;\n\tunsigned long event = inet6addr_work->event;\n\tstruct mlxsw_sp_rif *rif;\n\n\trtnl_lock();\n\tmutex_lock(&mlxsw_sp->router->lock);\n\n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, dev);\n\tif (!mlxsw_sp_rif_should_config(rif, dev, event))\n\t\tgoto out;\n\n\t__mlxsw_sp_inetaddr_event(mlxsw_sp, dev, event, false, NULL);\nout:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\trtnl_unlock();\n\tnetdev_put(dev, &inet6addr_work->dev_tracker);\n\tkfree(inet6addr_work);\n}\n\n \nstatic int mlxsw_sp_inet6addr_event(struct notifier_block *nb,\n\t\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct inet6_ifaddr *if6 = (struct inet6_ifaddr *) ptr;\n\tstruct mlxsw_sp_inet6addr_event_work *inet6addr_work;\n\tstruct net_device *dev = if6->idev->dev;\n\tstruct mlxsw_sp_router *router;\n\n\t \n\tif (event == NETDEV_UP)\n\t\treturn NOTIFY_DONE;\n\n\tinet6addr_work = kzalloc(sizeof(*inet6addr_work), GFP_ATOMIC);\n\tif (!inet6addr_work)\n\t\treturn NOTIFY_BAD;\n\n\trouter = container_of(nb, struct mlxsw_sp_router, inet6addr_nb);\n\tINIT_WORK(&inet6addr_work->work, mlxsw_sp_inet6addr_event_work);\n\tinet6addr_work->mlxsw_sp = router->mlxsw_sp;\n\tinet6addr_work->dev = dev;\n\tinet6addr_work->event = event;\n\tnetdev_hold(dev, &inet6addr_work->dev_tracker, GFP_ATOMIC);\n\tmlxsw_core_schedule_work(&inet6addr_work->work);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int mlxsw_sp_inet6addr_valid_event(struct notifier_block *unused,\n\t\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct in6_validator_info *i6vi = (struct in6_validator_info *) ptr;\n\tstruct net_device *dev = i6vi->i6vi_dev->dev;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct mlxsw_sp_rif *rif;\n\tint err = 0;\n\n\tmlxsw_sp = mlxsw_sp_lower_get(dev);\n\tif (!mlxsw_sp)\n\t\treturn NOTIFY_DONE;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, dev);\n\tif (!mlxsw_sp_rif_should_config(rif, dev, event))\n\t\tgoto out;\n\n\terr = __mlxsw_sp_inetaddr_event(mlxsw_sp, dev, event, false,\n\t\t\t\t\ti6vi->extack);\nout:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\treturn notifier_from_errno(err);\n}\n\nstatic int mlxsw_sp_rif_edit(struct mlxsw_sp *mlxsw_sp, u16 rif_index,\n\t\t\t     const char *mac, int mtu, u8 mac_profile)\n{\n\tchar ritr_pl[MLXSW_REG_RITR_LEN];\n\tint err;\n\n\tmlxsw_reg_ritr_rif_pack(ritr_pl, rif_index);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_ritr_mtu_set(ritr_pl, mtu);\n\tmlxsw_reg_ritr_if_mac_memcpy_to(ritr_pl, mac);\n\tmlxsw_reg_ritr_if_mac_profile_id_set(ritr_pl, mac_profile);\n\tmlxsw_reg_ritr_op_set(ritr_pl, MLXSW_REG_RITR_RIF_CREATE);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);\n}\n\nstatic int\nmlxsw_sp_router_port_change_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_rif *rif,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tu8 old_mac_profile;\n\tu16 fid_index;\n\tint err;\n\n\tfid_index = mlxsw_sp_fid_index(rif->fid);\n\n\terr = mlxsw_sp_rif_fdb_op(mlxsw_sp, rif->addr, fid_index, false);\n\tif (err)\n\t\treturn err;\n\n\told_mac_profile = rif->mac_profile_id;\n\terr = mlxsw_sp_rif_mac_profile_replace(mlxsw_sp, rif, dev->dev_addr,\n\t\t\t\t\t       extack);\n\tif (err)\n\t\tgoto err_rif_mac_profile_replace;\n\n\terr = mlxsw_sp_rif_edit(mlxsw_sp, rif->rif_index, dev->dev_addr,\n\t\t\t\tdev->mtu, rif->mac_profile_id);\n\tif (err)\n\t\tgoto err_rif_edit;\n\n\terr = mlxsw_sp_rif_fdb_op(mlxsw_sp, dev->dev_addr, fid_index, true);\n\tif (err)\n\t\tgoto err_rif_fdb_op;\n\n\tif (rif->mtu != dev->mtu) {\n\t\tstruct mlxsw_sp_vr *vr;\n\t\tint i;\n\n\t\t \n\t\tvr = &mlxsw_sp->router->vrs[rif->vr_id];\n\t\tfor (i = 0; i < MLXSW_SP_L3_PROTO_MAX; i++)\n\t\t\tmlxsw_sp_mr_rif_mtu_update(vr->mr_table[i],\n\t\t\t\t\t\t   rif, dev->mtu);\n\t}\n\n\tether_addr_copy(rif->addr, dev->dev_addr);\n\trif->mtu = dev->mtu;\n\n\tnetdev_dbg(dev, \"Updated RIF=%d\\n\", rif->rif_index);\n\n\treturn 0;\n\nerr_rif_fdb_op:\n\tmlxsw_sp_rif_edit(mlxsw_sp, rif->rif_index, rif->addr, rif->mtu,\n\t\t\t  old_mac_profile);\nerr_rif_edit:\n\tmlxsw_sp_rif_mac_profile_replace(mlxsw_sp, rif, rif->addr, extack);\nerr_rif_mac_profile_replace:\n\tmlxsw_sp_rif_fdb_op(mlxsw_sp, rif->addr, fid_index, true);\n\treturn err;\n}\n\nstatic int mlxsw_sp_router_port_pre_changeaddr_event(struct mlxsw_sp_rif *rif,\n\t\t\t    struct netdev_notifier_pre_changeaddr_info *info)\n{\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tstruct mlxsw_sp_rif_mac_profile *profile;\n\tstruct netlink_ext_ack *extack;\n\tu8 max_rif_mac_profiles;\n\tu64 occ;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\n\tprofile = mlxsw_sp_rif_mac_profile_find(mlxsw_sp, info->dev_addr);\n\tif (profile)\n\t\treturn 0;\n\n\tmax_rif_mac_profiles = mlxsw_sp->router->max_rif_mac_profile;\n\tocc = mlxsw_sp_rif_mac_profiles_occ_get(mlxsw_sp);\n\tif (occ < max_rif_mac_profiles)\n\t\treturn 0;\n\n\tif (!mlxsw_sp_rif_mac_profile_is_shared(rif))\n\t\treturn 0;\n\n\tNL_SET_ERR_MSG_MOD(extack, \"Exceeded number of supported router interface MAC profiles\");\n\treturn -ENOBUFS;\n}\n\nstatic bool mlxsw_sp_router_netdevice_interesting(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t  struct net_device *dev)\n{\n\tstruct vlan_dev_priv *vlan;\n\n\tif (netif_is_lag_master(dev) ||\n\t    netif_is_bridge_master(dev) ||\n\t    mlxsw_sp_port_dev_check(dev) ||\n\t    mlxsw_sp_netdev_is_ipip_ol(mlxsw_sp, dev) ||\n\t    netif_is_l3_master(dev))\n\t\treturn true;\n\n\tif (!is_vlan_dev(dev))\n\t\treturn false;\n\n\tvlan = vlan_dev_priv(dev);\n\treturn netif_is_lag_master(vlan->real_dev) ||\n\t       netif_is_bridge_master(vlan->real_dev) ||\n\t       mlxsw_sp_port_dev_check(vlan->real_dev);\n}\n\nstatic struct mlxsw_sp_crif *\nmlxsw_sp_crif_register(struct mlxsw_sp_router *router, struct net_device *dev)\n{\n\tstruct mlxsw_sp_crif *crif;\n\tint err;\n\n\tif (WARN_ON(mlxsw_sp_crif_lookup(router, dev)))\n\t\treturn NULL;\n\n\tcrif = mlxsw_sp_crif_alloc(dev);\n\tif (!crif)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = mlxsw_sp_crif_insert(router, crif);\n\tif (err)\n\t\tgoto err_netdev_insert;\n\n\treturn crif;\n\nerr_netdev_insert:\n\tmlxsw_sp_crif_free(crif);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_crif_unregister(struct mlxsw_sp_router *router,\n\t\t\t\t     struct mlxsw_sp_crif *crif)\n{\n\tstruct mlxsw_sp_nexthop *nh, *tmp;\n\n\tmlxsw_sp_crif_remove(router, crif);\n\n\tlist_for_each_entry_safe(nh, tmp, &crif->nexthop_list, crif_list_node)\n\t\tmlxsw_sp_nexthop_type_fini(router->mlxsw_sp, nh);\n\n\tif (crif->rif)\n\t\tcrif->can_destroy = true;\n\telse\n\t\tmlxsw_sp_crif_free(crif);\n}\n\nstatic int mlxsw_sp_netdevice_register(struct mlxsw_sp_router *router,\n\t\t\t\t       struct net_device *dev)\n{\n\tstruct mlxsw_sp_crif *crif;\n\n\tif (!mlxsw_sp_router_netdevice_interesting(router->mlxsw_sp, dev))\n\t\treturn 0;\n\n\tcrif = mlxsw_sp_crif_register(router, dev);\n\treturn PTR_ERR_OR_ZERO(crif);\n}\n\nstatic void mlxsw_sp_netdevice_unregister(struct mlxsw_sp_router *router,\n\t\t\t\t\t  struct net_device *dev)\n{\n\tstruct mlxsw_sp_crif *crif;\n\n\tif (!mlxsw_sp_router_netdevice_interesting(router->mlxsw_sp, dev))\n\t\treturn;\n\n\t \n\tcrif = mlxsw_sp_crif_lookup(router, dev);\n\tif (dev->reg_state == NETREG_UNREGISTERED) {\n\t\tif (!WARN_ON(crif))\n\t\t\treturn;\n\t}\n\tif (WARN_ON(!crif))\n\t\treturn;\n\n\tmlxsw_sp_crif_unregister(router, crif);\n}\n\nstatic bool mlxsw_sp_is_offload_xstats_event(unsigned long event)\n{\n\tswitch (event) {\n\tcase NETDEV_OFFLOAD_XSTATS_ENABLE:\n\tcase NETDEV_OFFLOAD_XSTATS_DISABLE:\n\tcase NETDEV_OFFLOAD_XSTATS_REPORT_USED:\n\tcase NETDEV_OFFLOAD_XSTATS_REPORT_DELTA:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int\nmlxsw_sp_router_port_offload_xstats_cmd(struct mlxsw_sp_rif *rif,\n\t\t\t\t\tunsigned long event,\n\t\t\t\t\tstruct netdev_notifier_offload_xstats_info *info)\n{\n\tswitch (info->type) {\n\tcase NETDEV_OFFLOAD_XSTATS_TYPE_L3:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tswitch (event) {\n\tcase NETDEV_OFFLOAD_XSTATS_ENABLE:\n\t\treturn mlxsw_sp_router_port_l3_stats_enable(rif);\n\tcase NETDEV_OFFLOAD_XSTATS_DISABLE:\n\t\tmlxsw_sp_router_port_l3_stats_disable(rif);\n\t\treturn 0;\n\tcase NETDEV_OFFLOAD_XSTATS_REPORT_USED:\n\t\tmlxsw_sp_router_port_l3_stats_report_used(rif, info);\n\t\treturn 0;\n\tcase NETDEV_OFFLOAD_XSTATS_REPORT_DELTA:\n\t\treturn mlxsw_sp_router_port_l3_stats_report_delta(rif, info);\n\t}\n\n\tWARN_ON_ONCE(1);\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_netdevice_offload_xstats_cmd(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      unsigned long event,\n\t\t\t\t      struct netdev_notifier_offload_xstats_info *info)\n{\n\tstruct mlxsw_sp_rif *rif;\n\n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, dev);\n\tif (!rif)\n\t\treturn 0;\n\n\treturn mlxsw_sp_router_port_offload_xstats_cmd(rif, event, info);\n}\n\nstatic bool mlxsw_sp_is_router_event(unsigned long event)\n{\n\tswitch (event) {\n\tcase NETDEV_PRE_CHANGEADDR:\n\tcase NETDEV_CHANGEADDR:\n\tcase NETDEV_CHANGEMTU:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int mlxsw_sp_netdevice_router_port_event(struct net_device *dev,\n\t\t\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct netlink_ext_ack *extack = netdev_notifier_info_to_extack(ptr);\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct mlxsw_sp_rif *rif;\n\n\tmlxsw_sp = mlxsw_sp_lower_get(dev);\n\tif (!mlxsw_sp)\n\t\treturn 0;\n\n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, dev);\n\tif (!rif)\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGEMTU:\n\tcase NETDEV_CHANGEADDR:\n\t\treturn mlxsw_sp_router_port_change_event(mlxsw_sp, rif, extack);\n\tcase NETDEV_PRE_CHANGEADDR:\n\t\treturn mlxsw_sp_router_port_pre_changeaddr_event(rif, ptr);\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_vrf_join(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct net_device *l3_dev,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_rif *rif;\n\n\t \n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);\n\tif (rif)\n\t\t__mlxsw_sp_inetaddr_event(mlxsw_sp, l3_dev, NETDEV_DOWN, false,\n\t\t\t\t\t  extack);\n\n\treturn __mlxsw_sp_inetaddr_event(mlxsw_sp, l3_dev, NETDEV_UP, false,\n\t\t\t\t\t extack);\n}\n\nstatic void mlxsw_sp_port_vrf_leave(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct net_device *l3_dev)\n{\n\tstruct mlxsw_sp_rif *rif;\n\n\trif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, l3_dev);\n\tif (!rif)\n\t\treturn;\n\t__mlxsw_sp_inetaddr_event(mlxsw_sp, l3_dev, NETDEV_DOWN, false, NULL);\n}\n\nstatic bool mlxsw_sp_is_vrf_event(unsigned long event, void *ptr)\n{\n\tstruct netdev_notifier_changeupper_info *info = ptr;\n\n\tif (event != NETDEV_PRECHANGEUPPER && event != NETDEV_CHANGEUPPER)\n\t\treturn false;\n\treturn netif_is_l3_master(info->upper_dev);\n}\n\nstatic int\nmlxsw_sp_netdevice_vrf_event(struct net_device *l3_dev, unsigned long event,\n\t\t\t     struct netdev_notifier_changeupper_info *info)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(l3_dev);\n\tint err = 0;\n\n\t \n\tif (!mlxsw_sp || netif_is_macvlan(l3_dev))\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase NETDEV_PRECHANGEUPPER:\n\t\tbreak;\n\tcase NETDEV_CHANGEUPPER:\n\t\tif (info->linking) {\n\t\t\tstruct netlink_ext_ack *extack;\n\n\t\t\textack = netdev_notifier_info_to_extack(&info->info);\n\t\t\terr = mlxsw_sp_port_vrf_join(mlxsw_sp, l3_dev, extack);\n\t\t} else {\n\t\t\tmlxsw_sp_port_vrf_leave(mlxsw_sp, l3_dev);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstruct mlxsw_sp_router_replay_inetaddr_up {\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct netlink_ext_ack *extack;\n\tunsigned int done;\n\tbool deslavement;\n};\n\nstatic int mlxsw_sp_router_replay_inetaddr_up(struct net_device *dev,\n\t\t\t\t\t      struct netdev_nested_priv *priv)\n{\n\tstruct mlxsw_sp_router_replay_inetaddr_up *ctx = priv->data;\n\tbool nomaster = ctx->deslavement;\n\tstruct mlxsw_sp_crif *crif;\n\tint err;\n\n\tif (mlxsw_sp_dev_addr_list_empty(dev))\n\t\treturn 0;\n\n\tcrif = mlxsw_sp_crif_lookup(ctx->mlxsw_sp->router, dev);\n\tif (!crif || crif->rif)\n\t\treturn 0;\n\n\tif (!mlxsw_sp_rif_should_config(crif->rif, dev, NETDEV_UP))\n\t\treturn 0;\n\n\terr = __mlxsw_sp_inetaddr_event(ctx->mlxsw_sp, dev, NETDEV_UP,\n\t\t\t\t\tnomaster, ctx->extack);\n\tif (err)\n\t\treturn err;\n\n\tctx->done++;\n\treturn 0;\n}\n\nstatic int mlxsw_sp_router_unreplay_inetaddr_up(struct net_device *dev,\n\t\t\t\t\t\tstruct netdev_nested_priv *priv)\n{\n\tstruct mlxsw_sp_router_replay_inetaddr_up *ctx = priv->data;\n\tbool nomaster = ctx->deslavement;\n\tstruct mlxsw_sp_crif *crif;\n\n\tif (!ctx->done)\n\t\treturn 0;\n\n\tif (mlxsw_sp_dev_addr_list_empty(dev))\n\t\treturn 0;\n\n\tcrif = mlxsw_sp_crif_lookup(ctx->mlxsw_sp->router, dev);\n\tif (!crif || !crif->rif)\n\t\treturn 0;\n\n\t \n\tif (!mlxsw_sp_rif_should_config(crif->rif, dev, NETDEV_UP))\n\t\treturn 0;\n\n\t__mlxsw_sp_inetaddr_event(ctx->mlxsw_sp, dev, NETDEV_DOWN, nomaster,\n\t\t\t\t  NULL);\n\n\tctx->done--;\n\treturn 0;\n}\n\nint mlxsw_sp_netdevice_enslavement_replay(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct net_device *upper_dev,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_router_replay_inetaddr_up ctx = {\n\t\t.mlxsw_sp = mlxsw_sp,\n\t\t.extack = extack,\n\t\t.deslavement = false,\n\t};\n\tstruct netdev_nested_priv priv = {\n\t\t.data = &ctx,\n\t};\n\tint err;\n\n\terr = mlxsw_sp_router_replay_inetaddr_up(upper_dev, &priv);\n\tif (err)\n\t\treturn err;\n\n\terr = netdev_walk_all_upper_dev_rcu(upper_dev,\n\t\t\t\t\t    mlxsw_sp_router_replay_inetaddr_up,\n\t\t\t\t\t    &priv);\n\tif (err)\n\t\tgoto err_replay_up;\n\n\treturn 0;\n\nerr_replay_up:\n\tnetdev_walk_all_upper_dev_rcu(upper_dev,\n\t\t\t\t      mlxsw_sp_router_unreplay_inetaddr_up,\n\t\t\t\t      &priv);\n\tmlxsw_sp_router_unreplay_inetaddr_up(upper_dev, &priv);\n\treturn err;\n}\n\nvoid mlxsw_sp_netdevice_deslavement_replay(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   struct net_device *dev)\n{\n\tstruct mlxsw_sp_router_replay_inetaddr_up ctx = {\n\t\t.mlxsw_sp = mlxsw_sp,\n\t\t.deslavement = true,\n\t};\n\tstruct netdev_nested_priv priv = {\n\t\t.data = &ctx,\n\t};\n\n\tmlxsw_sp_router_replay_inetaddr_up(dev, &priv);\n}\n\nstatic int\nmlxsw_sp_port_vid_router_join_existing(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t       u16 vid, struct net_device *dev,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port,\n\t\t\t\t\t\t\t    vid);\n\tif (WARN_ON(!mlxsw_sp_port_vlan))\n\t\treturn -EINVAL;\n\n\treturn mlxsw_sp_port_vlan_router_join_existing(mlxsw_sp_port_vlan,\n\t\t\t\t\t\t       dev, extack);\n}\n\nstatic void\nmlxsw_sp_port_vid_router_leave(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid,\n\t\t\t       struct net_device *dev)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port,\n\t\t\t\t\t\t\t    vid);\n\tif (WARN_ON(!mlxsw_sp_port_vlan))\n\t\treturn;\n\n\t__mlxsw_sp_port_vlan_router_leave(mlxsw_sp_port_vlan);\n}\n\nstatic int __mlxsw_sp_router_port_join_lag(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t   struct net_device *lag_dev,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tu16 default_vid = MLXSW_SP_DEFAULT_VID;\n\tstruct net_device *upper_dev;\n\tstruct list_head *iter;\n\tint done = 0;\n\tu16 vid;\n\tint err;\n\n\terr = mlxsw_sp_port_vid_router_join_existing(mlxsw_sp_port, default_vid,\n\t\t\t\t\t\t     lag_dev, extack);\n\tif (err)\n\t\treturn err;\n\n\tnetdev_for_each_upper_dev_rcu(lag_dev, upper_dev, iter) {\n\t\tif (!is_vlan_dev(upper_dev))\n\t\t\tcontinue;\n\n\t\tvid = vlan_dev_vlan_id(upper_dev);\n\t\terr = mlxsw_sp_port_vid_router_join_existing(mlxsw_sp_port, vid,\n\t\t\t\t\t\t\t     upper_dev, extack);\n\t\tif (err)\n\t\t\tgoto err_router_join_dev;\n\n\t\t++done;\n\t}\n\n\treturn 0;\n\nerr_router_join_dev:\n\tnetdev_for_each_upper_dev_rcu(lag_dev, upper_dev, iter) {\n\t\tif (!is_vlan_dev(upper_dev))\n\t\t\tcontinue;\n\t\tif (!done--)\n\t\t\tbreak;\n\n\t\tvid = vlan_dev_vlan_id(upper_dev);\n\t\tmlxsw_sp_port_vid_router_leave(mlxsw_sp_port, vid, upper_dev);\n\t}\n\n\tmlxsw_sp_port_vid_router_leave(mlxsw_sp_port, default_vid, lag_dev);\n\treturn err;\n}\n\nstatic void\n__mlxsw_sp_router_port_leave_lag(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t struct net_device *lag_dev)\n{\n\tu16 default_vid = MLXSW_SP_DEFAULT_VID;\n\tstruct net_device *upper_dev;\n\tstruct list_head *iter;\n\tu16 vid;\n\n\tnetdev_for_each_upper_dev_rcu(lag_dev, upper_dev, iter) {\n\t\tif (!is_vlan_dev(upper_dev))\n\t\t\tcontinue;\n\n\t\tvid = vlan_dev_vlan_id(upper_dev);\n\t\tmlxsw_sp_port_vid_router_leave(mlxsw_sp_port, vid, upper_dev);\n\t}\n\n\tmlxsw_sp_port_vid_router_leave(mlxsw_sp_port, default_vid, lag_dev);\n}\n\nint mlxsw_sp_router_port_join_lag(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  struct net_device *lag_dev,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tmutex_lock(&mlxsw_sp_port->mlxsw_sp->router->lock);\n\terr = __mlxsw_sp_router_port_join_lag(mlxsw_sp_port, lag_dev, extack);\n\tmutex_unlock(&mlxsw_sp_port->mlxsw_sp->router->lock);\n\n\treturn err;\n}\n\nvoid mlxsw_sp_router_port_leave_lag(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    struct net_device *lag_dev)\n{\n\tmutex_lock(&mlxsw_sp_port->mlxsw_sp->router->lock);\n\t__mlxsw_sp_router_port_leave_lag(mlxsw_sp_port, lag_dev);\n\tmutex_unlock(&mlxsw_sp_port->mlxsw_sp->router->lock);\n}\n\nstatic int mlxsw_sp_router_netdevice_event(struct notifier_block *nb,\n\t\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct mlxsw_sp_router *router;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tint err = 0;\n\n\trouter = container_of(nb, struct mlxsw_sp_router, netdevice_nb);\n\tmlxsw_sp = router->mlxsw_sp;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\n\tif (event == NETDEV_REGISTER) {\n\t\terr = mlxsw_sp_netdevice_register(router, dev);\n\t\tif (err)\n\t\t\t \n\t\t\tgoto out;\n\t}\n\n\tif (mlxsw_sp_is_offload_xstats_event(event))\n\t\terr = mlxsw_sp_netdevice_offload_xstats_cmd(mlxsw_sp, dev,\n\t\t\t\t\t\t\t    event, ptr);\n\telse if (mlxsw_sp_netdev_is_ipip_ol(mlxsw_sp, dev))\n\t\terr = mlxsw_sp_netdevice_ipip_ol_event(mlxsw_sp, dev,\n\t\t\t\t\t\t       event, ptr);\n\telse if (mlxsw_sp_netdev_is_ipip_ul(mlxsw_sp, dev))\n\t\terr = mlxsw_sp_netdevice_ipip_ul_event(mlxsw_sp, dev,\n\t\t\t\t\t\t       event, ptr);\n\telse if (mlxsw_sp_is_router_event(event))\n\t\terr = mlxsw_sp_netdevice_router_port_event(dev, event, ptr);\n\telse if (mlxsw_sp_is_vrf_event(event, ptr))\n\t\terr = mlxsw_sp_netdevice_vrf_event(dev, event, ptr);\n\n\tif (event == NETDEV_UNREGISTER)\n\t\tmlxsw_sp_netdevice_unregister(router, dev);\n\nout:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\n\treturn notifier_from_errno(err);\n}\n\nstruct mlxsw_sp_macvlan_replay {\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct netlink_ext_ack *extack;\n};\n\nstatic int mlxsw_sp_macvlan_replay_upper(struct net_device *dev,\n\t\t\t\t\t struct netdev_nested_priv *priv)\n{\n\tconst struct mlxsw_sp_macvlan_replay *rms = priv->data;\n\tstruct netlink_ext_ack *extack = rms->extack;\n\tstruct mlxsw_sp *mlxsw_sp = rms->mlxsw_sp;\n\n\tif (!netif_is_macvlan(dev))\n\t\treturn 0;\n\n\treturn mlxsw_sp_rif_macvlan_add(mlxsw_sp, dev, extack);\n}\n\nstatic int mlxsw_sp_macvlan_replay(struct mlxsw_sp_rif *rif,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_macvlan_replay rms = {\n\t\t.mlxsw_sp = rif->mlxsw_sp,\n\t\t.extack = extack,\n\t};\n\tstruct netdev_nested_priv priv = {\n\t\t.data = &rms,\n\t};\n\n\treturn netdev_walk_all_upper_dev_rcu(mlxsw_sp_rif_dev(rif),\n\t\t\t\t\t     mlxsw_sp_macvlan_replay_upper,\n\t\t\t\t\t     &priv);\n}\n\nstatic int __mlxsw_sp_rif_macvlan_flush(struct net_device *dev,\n\t\t\t\t\tstruct netdev_nested_priv *priv)\n{\n\tstruct mlxsw_sp_rif *rif = (struct mlxsw_sp_rif *)priv->data;\n\n\tif (!netif_is_macvlan(dev))\n\t\treturn 0;\n\n\treturn mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, dev->dev_addr,\n\t\t\t\t   mlxsw_sp_fid_index(rif->fid), false);\n}\n\nstatic int mlxsw_sp_rif_macvlan_flush(struct mlxsw_sp_rif *rif)\n{\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tstruct netdev_nested_priv priv = {\n\t\t.data = (void *)rif,\n\t};\n\n\tif (!netif_is_macvlan_port(dev))\n\t\treturn 0;\n\n\treturn netdev_walk_all_upper_dev_rcu(dev,\n\t\t\t\t\t     __mlxsw_sp_rif_macvlan_flush, &priv);\n}\n\nstatic void mlxsw_sp_rif_subport_setup(struct mlxsw_sp_rif *rif,\n\t\t\t\t       const struct mlxsw_sp_rif_params *params)\n{\n\tstruct mlxsw_sp_rif_subport *rif_subport;\n\n\trif_subport = mlxsw_sp_rif_subport_rif(rif);\n\trefcount_set(&rif_subport->ref_count, 1);\n\trif_subport->vid = params->vid;\n\trif_subport->lag = params->lag;\n\tif (params->lag)\n\t\trif_subport->lag_id = params->lag_id;\n\telse\n\t\trif_subport->system_port = params->system_port;\n}\n\nstatic int mlxsw_sp_rif_subport_op(struct mlxsw_sp_rif *rif, bool enable)\n{\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tstruct mlxsw_sp_rif_subport *rif_subport;\n\tchar ritr_pl[MLXSW_REG_RITR_LEN];\n\tu16 efid;\n\n\trif_subport = mlxsw_sp_rif_subport_rif(rif);\n\tmlxsw_reg_ritr_pack(ritr_pl, enable, MLXSW_REG_RITR_SP_IF,\n\t\t\t    rif->rif_index, rif->vr_id, dev->mtu);\n\tmlxsw_reg_ritr_mac_pack(ritr_pl, dev->dev_addr);\n\tmlxsw_reg_ritr_if_mac_profile_id_set(ritr_pl, rif->mac_profile_id);\n\tefid = mlxsw_sp_fid_index(rif->fid);\n\tmlxsw_reg_ritr_sp_if_pack(ritr_pl, rif_subport->lag,\n\t\t\t\t  rif_subport->lag ? rif_subport->lag_id :\n\t\t\t\t\t\t     rif_subport->system_port,\n\t\t\t\t  efid, 0);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);\n}\n\nstatic int mlxsw_sp_rif_subport_configure(struct mlxsw_sp_rif *rif,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tu8 mac_profile;\n\tint err;\n\n\terr = mlxsw_sp_rif_mac_profile_get(rif->mlxsw_sp, rif->addr,\n\t\t\t\t\t   &mac_profile, extack);\n\tif (err)\n\t\treturn err;\n\trif->mac_profile_id = mac_profile;\n\n\terr = mlxsw_sp_rif_subport_op(rif, true);\n\tif (err)\n\t\tgoto err_rif_subport_op;\n\n\terr = mlxsw_sp_macvlan_replay(rif, extack);\n\tif (err)\n\t\tgoto err_macvlan_replay;\n\n\terr = mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, dev->dev_addr,\n\t\t\t\t  mlxsw_sp_fid_index(rif->fid), true);\n\tif (err)\n\t\tgoto err_rif_fdb_op;\n\n\terr = mlxsw_sp_fid_rif_set(rif->fid, rif);\n\tif (err)\n\t\tgoto err_fid_rif_set;\n\n\treturn 0;\n\nerr_fid_rif_set:\n\tmlxsw_sp_rif_fdb_op(rif->mlxsw_sp, dev->dev_addr,\n\t\t\t    mlxsw_sp_fid_index(rif->fid), false);\nerr_rif_fdb_op:\n\tmlxsw_sp_rif_macvlan_flush(rif);\nerr_macvlan_replay:\n\tmlxsw_sp_rif_subport_op(rif, false);\nerr_rif_subport_op:\n\tmlxsw_sp_rif_mac_profile_put(rif->mlxsw_sp, mac_profile);\n\treturn err;\n}\n\nstatic void mlxsw_sp_rif_subport_deconfigure(struct mlxsw_sp_rif *rif)\n{\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tstruct mlxsw_sp_fid *fid = rif->fid;\n\n\tmlxsw_sp_fid_rif_unset(fid);\n\tmlxsw_sp_rif_fdb_op(rif->mlxsw_sp, dev->dev_addr,\n\t\t\t    mlxsw_sp_fid_index(fid), false);\n\tmlxsw_sp_rif_macvlan_flush(rif);\n\tmlxsw_sp_rif_subport_op(rif, false);\n\tmlxsw_sp_rif_mac_profile_put(rif->mlxsw_sp, rif->mac_profile_id);\n}\n\nstatic struct mlxsw_sp_fid *\nmlxsw_sp_rif_subport_fid_get(struct mlxsw_sp_rif *rif,\n\t\t\t     const struct mlxsw_sp_rif_params *params,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\treturn mlxsw_sp_fid_rfid_get(rif->mlxsw_sp, rif->rif_index);\n}\n\nstatic const struct mlxsw_sp_rif_ops mlxsw_sp_rif_subport_ops = {\n\t.type\t\t\t= MLXSW_SP_RIF_TYPE_SUBPORT,\n\t.rif_size\t\t= sizeof(struct mlxsw_sp_rif_subport),\n\t.setup\t\t\t= mlxsw_sp_rif_subport_setup,\n\t.configure\t\t= mlxsw_sp_rif_subport_configure,\n\t.deconfigure\t\t= mlxsw_sp_rif_subport_deconfigure,\n\t.fid_get\t\t= mlxsw_sp_rif_subport_fid_get,\n};\n\nstatic int mlxsw_sp_rif_fid_op(struct mlxsw_sp_rif *rif, u16 fid, bool enable)\n{\n\tenum mlxsw_reg_ritr_if_type type = MLXSW_REG_RITR_FID_IF;\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tchar ritr_pl[MLXSW_REG_RITR_LEN];\n\n\tmlxsw_reg_ritr_pack(ritr_pl, enable, type, rif->rif_index, rif->vr_id,\n\t\t\t    dev->mtu);\n\tmlxsw_reg_ritr_mac_pack(ritr_pl, dev->dev_addr);\n\tmlxsw_reg_ritr_if_mac_profile_id_set(ritr_pl, rif->mac_profile_id);\n\tmlxsw_reg_ritr_fid_if_fid_set(ritr_pl, fid);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);\n}\n\nu16 mlxsw_sp_router_port(const struct mlxsw_sp *mlxsw_sp)\n{\n\treturn mlxsw_core_max_ports(mlxsw_sp->core) + 1;\n}\n\nstatic int mlxsw_sp_rif_fid_configure(struct mlxsw_sp_rif *rif,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tu16 fid_index = mlxsw_sp_fid_index(rif->fid);\n\tu8 mac_profile;\n\tint err;\n\n\terr = mlxsw_sp_rif_mac_profile_get(mlxsw_sp, rif->addr,\n\t\t\t\t\t   &mac_profile, extack);\n\tif (err)\n\t\treturn err;\n\trif->mac_profile_id = mac_profile;\n\n\terr = mlxsw_sp_rif_fid_op(rif, fid_index, true);\n\tif (err)\n\t\tgoto err_rif_fid_op;\n\n\terr = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,\n\t\t\t\t     mlxsw_sp_router_port(mlxsw_sp), true);\n\tif (err)\n\t\tgoto err_fid_mc_flood_set;\n\n\terr = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,\n\t\t\t\t     mlxsw_sp_router_port(mlxsw_sp), true);\n\tif (err)\n\t\tgoto err_fid_bc_flood_set;\n\n\terr = mlxsw_sp_macvlan_replay(rif, extack);\n\tif (err)\n\t\tgoto err_macvlan_replay;\n\n\terr = mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, dev->dev_addr,\n\t\t\t\t  mlxsw_sp_fid_index(rif->fid), true);\n\tif (err)\n\t\tgoto err_rif_fdb_op;\n\n\terr = mlxsw_sp_fid_rif_set(rif->fid, rif);\n\tif (err)\n\t\tgoto err_fid_rif_set;\n\n\treturn 0;\n\nerr_fid_rif_set:\n\tmlxsw_sp_rif_fdb_op(rif->mlxsw_sp, dev->dev_addr,\n\t\t\t    mlxsw_sp_fid_index(rif->fid), false);\nerr_rif_fdb_op:\n\tmlxsw_sp_rif_macvlan_flush(rif);\nerr_macvlan_replay:\n\tmlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,\n\t\t\t       mlxsw_sp_router_port(mlxsw_sp), false);\nerr_fid_bc_flood_set:\n\tmlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,\n\t\t\t       mlxsw_sp_router_port(mlxsw_sp), false);\nerr_fid_mc_flood_set:\n\tmlxsw_sp_rif_fid_op(rif, fid_index, false);\nerr_rif_fid_op:\n\tmlxsw_sp_rif_mac_profile_put(mlxsw_sp, mac_profile);\n\treturn err;\n}\n\nstatic void mlxsw_sp_rif_fid_deconfigure(struct mlxsw_sp_rif *rif)\n{\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tu16 fid_index = mlxsw_sp_fid_index(rif->fid);\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tstruct mlxsw_sp_fid *fid = rif->fid;\n\n\tmlxsw_sp_fid_rif_unset(fid);\n\tmlxsw_sp_rif_fdb_op(rif->mlxsw_sp, dev->dev_addr,\n\t\t\t    mlxsw_sp_fid_index(fid), false);\n\tmlxsw_sp_rif_macvlan_flush(rif);\n\tmlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,\n\t\t\t       mlxsw_sp_router_port(mlxsw_sp), false);\n\tmlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,\n\t\t\t       mlxsw_sp_router_port(mlxsw_sp), false);\n\tmlxsw_sp_rif_fid_op(rif, fid_index, false);\n\tmlxsw_sp_rif_mac_profile_put(rif->mlxsw_sp, rif->mac_profile_id);\n}\n\nstatic struct mlxsw_sp_fid *\nmlxsw_sp_rif_fid_fid_get(struct mlxsw_sp_rif *rif,\n\t\t\t const struct mlxsw_sp_rif_params *params,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tint rif_ifindex = mlxsw_sp_rif_dev_ifindex(rif);\n\n\treturn mlxsw_sp_fid_8021d_get(rif->mlxsw_sp, rif_ifindex);\n}\n\nstatic void mlxsw_sp_rif_fid_fdb_del(struct mlxsw_sp_rif *rif, const char *mac)\n{\n\tstruct switchdev_notifier_fdb_info info = {};\n\tstruct net_device *dev;\n\n\tdev = br_fdb_find_port(mlxsw_sp_rif_dev(rif), mac, 0);\n\tif (!dev)\n\t\treturn;\n\n\tinfo.addr = mac;\n\tinfo.vid = 0;\n\tcall_switchdev_notifiers(SWITCHDEV_FDB_DEL_TO_BRIDGE, dev, &info.info,\n\t\t\t\t NULL);\n}\n\nstatic const struct mlxsw_sp_rif_ops mlxsw_sp_rif_fid_ops = {\n\t.type\t\t\t= MLXSW_SP_RIF_TYPE_FID,\n\t.rif_size\t\t= sizeof(struct mlxsw_sp_rif),\n\t.configure\t\t= mlxsw_sp_rif_fid_configure,\n\t.deconfigure\t\t= mlxsw_sp_rif_fid_deconfigure,\n\t.fid_get\t\t= mlxsw_sp_rif_fid_fid_get,\n\t.fdb_del\t\t= mlxsw_sp_rif_fid_fdb_del,\n};\n\nstatic struct mlxsw_sp_fid *\nmlxsw_sp_rif_vlan_fid_get(struct mlxsw_sp_rif *rif,\n\t\t\t  const struct mlxsw_sp_rif_params *params,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tstruct net_device *br_dev;\n\n\tif (WARN_ON(!params->vid))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (is_vlan_dev(dev)) {\n\t\tbr_dev = vlan_dev_real_dev(dev);\n\t\tif (WARN_ON(!netif_is_bridge_master(br_dev)))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn mlxsw_sp_fid_8021q_get(rif->mlxsw_sp, params->vid);\n}\n\nstatic void mlxsw_sp_rif_vlan_fdb_del(struct mlxsw_sp_rif *rif, const char *mac)\n{\n\tstruct net_device *rif_dev = mlxsw_sp_rif_dev(rif);\n\tstruct switchdev_notifier_fdb_info info = {};\n\tu16 vid = mlxsw_sp_fid_8021q_vid(rif->fid);\n\tstruct net_device *br_dev;\n\tstruct net_device *dev;\n\n\tbr_dev = is_vlan_dev(rif_dev) ? vlan_dev_real_dev(rif_dev) : rif_dev;\n\tdev = br_fdb_find_port(br_dev, mac, vid);\n\tif (!dev)\n\t\treturn;\n\n\tinfo.addr = mac;\n\tinfo.vid = vid;\n\tcall_switchdev_notifiers(SWITCHDEV_FDB_DEL_TO_BRIDGE, dev, &info.info,\n\t\t\t\t NULL);\n}\n\nstatic int mlxsw_sp_rif_vlan_op(struct mlxsw_sp_rif *rif, u16 vid, u16 efid,\n\t\t\t\tbool enable)\n{\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tchar ritr_pl[MLXSW_REG_RITR_LEN];\n\n\tmlxsw_reg_ritr_vlan_if_pack(ritr_pl, enable, rif->rif_index, rif->vr_id,\n\t\t\t\t    dev->mtu, dev->dev_addr,\n\t\t\t\t    rif->mac_profile_id, vid, efid);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);\n}\n\nstatic int mlxsw_sp_rif_vlan_configure(struct mlxsw_sp_rif *rif, u16 efid,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tu16 vid = mlxsw_sp_fid_8021q_vid(rif->fid);\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tu8 mac_profile;\n\tint err;\n\n\terr = mlxsw_sp_rif_mac_profile_get(mlxsw_sp, rif->addr,\n\t\t\t\t\t   &mac_profile, extack);\n\tif (err)\n\t\treturn err;\n\trif->mac_profile_id = mac_profile;\n\n\terr = mlxsw_sp_rif_vlan_op(rif, vid, efid, true);\n\tif (err)\n\t\tgoto err_rif_vlan_fid_op;\n\n\terr = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,\n\t\t\t\t     mlxsw_sp_router_port(mlxsw_sp), true);\n\tif (err)\n\t\tgoto err_fid_mc_flood_set;\n\n\terr = mlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,\n\t\t\t\t     mlxsw_sp_router_port(mlxsw_sp), true);\n\tif (err)\n\t\tgoto err_fid_bc_flood_set;\n\n\terr = mlxsw_sp_macvlan_replay(rif, extack);\n\tif (err)\n\t\tgoto err_macvlan_replay;\n\n\terr = mlxsw_sp_rif_fdb_op(rif->mlxsw_sp, dev->dev_addr,\n\t\t\t\t  mlxsw_sp_fid_index(rif->fid), true);\n\tif (err)\n\t\tgoto err_rif_fdb_op;\n\n\terr = mlxsw_sp_fid_rif_set(rif->fid, rif);\n\tif (err)\n\t\tgoto err_fid_rif_set;\n\n\treturn 0;\n\nerr_fid_rif_set:\n\tmlxsw_sp_rif_fdb_op(rif->mlxsw_sp, dev->dev_addr,\n\t\t\t    mlxsw_sp_fid_index(rif->fid), false);\nerr_rif_fdb_op:\n\tmlxsw_sp_rif_macvlan_flush(rif);\nerr_macvlan_replay:\n\tmlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,\n\t\t\t       mlxsw_sp_router_port(mlxsw_sp), false);\nerr_fid_bc_flood_set:\n\tmlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,\n\t\t\t       mlxsw_sp_router_port(mlxsw_sp), false);\nerr_fid_mc_flood_set:\n\tmlxsw_sp_rif_vlan_op(rif, vid, 0, false);\nerr_rif_vlan_fid_op:\n\tmlxsw_sp_rif_mac_profile_put(mlxsw_sp, mac_profile);\n\treturn err;\n}\n\nstatic void mlxsw_sp_rif_vlan_deconfigure(struct mlxsw_sp_rif *rif)\n{\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tu16 vid = mlxsw_sp_fid_8021q_vid(rif->fid);\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\n\tmlxsw_sp_fid_rif_unset(rif->fid);\n\tmlxsw_sp_rif_fdb_op(rif->mlxsw_sp, dev->dev_addr,\n\t\t\t    mlxsw_sp_fid_index(rif->fid), false);\n\tmlxsw_sp_rif_macvlan_flush(rif);\n\tmlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_BC,\n\t\t\t       mlxsw_sp_router_port(mlxsw_sp), false);\n\tmlxsw_sp_fid_flood_set(rif->fid, MLXSW_SP_FLOOD_TYPE_MC,\n\t\t\t       mlxsw_sp_router_port(mlxsw_sp), false);\n\tmlxsw_sp_rif_vlan_op(rif, vid, 0, false);\n\tmlxsw_sp_rif_mac_profile_put(rif->mlxsw_sp, rif->mac_profile_id);\n}\n\nstatic int mlxsw_sp1_rif_vlan_configure(struct mlxsw_sp_rif *rif,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\treturn mlxsw_sp_rif_vlan_configure(rif, 0, extack);\n}\n\nstatic const struct mlxsw_sp_rif_ops mlxsw_sp1_rif_vlan_ops = {\n\t.type\t\t\t= MLXSW_SP_RIF_TYPE_VLAN,\n\t.rif_size\t\t= sizeof(struct mlxsw_sp_rif),\n\t.configure\t\t= mlxsw_sp1_rif_vlan_configure,\n\t.deconfigure\t\t= mlxsw_sp_rif_vlan_deconfigure,\n\t.fid_get\t\t= mlxsw_sp_rif_vlan_fid_get,\n\t.fdb_del\t\t= mlxsw_sp_rif_vlan_fdb_del,\n};\n\nstatic int mlxsw_sp2_rif_vlan_configure(struct mlxsw_sp_rif *rif,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tu16 efid = mlxsw_sp_fid_index(rif->fid);\n\n\treturn mlxsw_sp_rif_vlan_configure(rif, efid, extack);\n}\n\nstatic const struct mlxsw_sp_rif_ops mlxsw_sp2_rif_vlan_ops = {\n\t.type\t\t\t= MLXSW_SP_RIF_TYPE_VLAN,\n\t.rif_size\t\t= sizeof(struct mlxsw_sp_rif),\n\t.configure\t\t= mlxsw_sp2_rif_vlan_configure,\n\t.deconfigure\t\t= mlxsw_sp_rif_vlan_deconfigure,\n\t.fid_get\t\t= mlxsw_sp_rif_vlan_fid_get,\n\t.fdb_del\t\t= mlxsw_sp_rif_vlan_fdb_del,\n};\n\nstatic struct mlxsw_sp_rif_ipip_lb *\nmlxsw_sp_rif_ipip_lb_rif(struct mlxsw_sp_rif *rif)\n{\n\treturn container_of(rif, struct mlxsw_sp_rif_ipip_lb, common);\n}\n\nstatic void\nmlxsw_sp_rif_ipip_lb_setup(struct mlxsw_sp_rif *rif,\n\t\t\t   const struct mlxsw_sp_rif_params *params)\n{\n\tstruct mlxsw_sp_rif_params_ipip_lb *params_lb;\n\tstruct mlxsw_sp_rif_ipip_lb *rif_lb;\n\n\tparams_lb = container_of(params, struct mlxsw_sp_rif_params_ipip_lb,\n\t\t\t\t common);\n\trif_lb = mlxsw_sp_rif_ipip_lb_rif(rif);\n\trif_lb->lb_config = params_lb->lb_config;\n}\n\nstatic int\nmlxsw_sp1_rif_ipip_lb_configure(struct mlxsw_sp_rif *rif,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_rif_ipip_lb *lb_rif = mlxsw_sp_rif_ipip_lb_rif(rif);\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tu32 ul_tb_id = mlxsw_sp_ipip_dev_ul_tb_id(dev);\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tstruct mlxsw_sp_vr *ul_vr;\n\tint err;\n\n\tul_vr = mlxsw_sp_vr_get(mlxsw_sp, ul_tb_id, extack);\n\tif (IS_ERR(ul_vr))\n\t\treturn PTR_ERR(ul_vr);\n\n\terr = mlxsw_sp_rif_ipip_lb_op(lb_rif, ul_vr->id, 0, true);\n\tif (err)\n\t\tgoto err_loopback_op;\n\n\tlb_rif->ul_vr_id = ul_vr->id;\n\tlb_rif->ul_rif_id = 0;\n\t++ul_vr->rif_count;\n\treturn 0;\n\nerr_loopback_op:\n\tmlxsw_sp_vr_put(mlxsw_sp, ul_vr);\n\treturn err;\n}\n\nstatic void mlxsw_sp1_rif_ipip_lb_deconfigure(struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp_rif_ipip_lb *lb_rif = mlxsw_sp_rif_ipip_lb_rif(rif);\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tstruct mlxsw_sp_vr *ul_vr;\n\n\tul_vr = &mlxsw_sp->router->vrs[lb_rif->ul_vr_id];\n\tmlxsw_sp_rif_ipip_lb_op(lb_rif, ul_vr->id, 0, false);\n\n\t--ul_vr->rif_count;\n\tmlxsw_sp_vr_put(mlxsw_sp, ul_vr);\n}\n\nstatic const struct mlxsw_sp_rif_ops mlxsw_sp1_rif_ipip_lb_ops = {\n\t.type\t\t\t= MLXSW_SP_RIF_TYPE_IPIP_LB,\n\t.rif_size\t\t= sizeof(struct mlxsw_sp_rif_ipip_lb),\n\t.setup                  = mlxsw_sp_rif_ipip_lb_setup,\n\t.configure\t\t= mlxsw_sp1_rif_ipip_lb_configure,\n\t.deconfigure\t\t= mlxsw_sp1_rif_ipip_lb_deconfigure,\n};\n\nstatic const struct mlxsw_sp_rif_ops *mlxsw_sp1_rif_ops_arr[] = {\n\t[MLXSW_SP_RIF_TYPE_SUBPORT]\t= &mlxsw_sp_rif_subport_ops,\n\t[MLXSW_SP_RIF_TYPE_VLAN]\t= &mlxsw_sp1_rif_vlan_ops,\n\t[MLXSW_SP_RIF_TYPE_FID]\t\t= &mlxsw_sp_rif_fid_ops,\n\t[MLXSW_SP_RIF_TYPE_IPIP_LB]\t= &mlxsw_sp1_rif_ipip_lb_ops,\n};\n\nstatic int\nmlxsw_sp_rif_ipip_lb_ul_rif_op(struct mlxsw_sp_rif *ul_rif, bool enable)\n{\n\tstruct mlxsw_sp *mlxsw_sp = ul_rif->mlxsw_sp;\n\tchar ritr_pl[MLXSW_REG_RITR_LEN];\n\n\tmlxsw_reg_ritr_pack(ritr_pl, enable, MLXSW_REG_RITR_LOOPBACK_IF,\n\t\t\t    ul_rif->rif_index, ul_rif->vr_id, IP_MAX_MTU);\n\tmlxsw_reg_ritr_loopback_protocol_set(ritr_pl,\n\t\t\t\t\t     MLXSW_REG_RITR_LOOPBACK_GENERIC);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ritr), ritr_pl);\n}\n\nstatic struct mlxsw_sp_rif *\nmlxsw_sp_ul_rif_create(struct mlxsw_sp *mlxsw_sp, struct mlxsw_sp_vr *vr,\n\t\t       struct mlxsw_sp_crif *ul_crif,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_rif *ul_rif;\n\tu8 rif_entries = 1;\n\tu16 rif_index;\n\tint err;\n\n\terr = mlxsw_sp_rif_index_alloc(mlxsw_sp, &rif_index, rif_entries);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Exceeded number of supported router interfaces\");\n\t\treturn ERR_PTR(err);\n\t}\n\n\tul_rif = mlxsw_sp_rif_alloc(sizeof(*ul_rif), rif_index, vr->id,\n\t\t\t\t    ul_crif);\n\tif (!ul_rif) {\n\t\terr = -ENOMEM;\n\t\tgoto err_rif_alloc;\n\t}\n\n\tmlxsw_sp->router->rifs[rif_index] = ul_rif;\n\tul_rif->mlxsw_sp = mlxsw_sp;\n\tul_rif->rif_entries = rif_entries;\n\terr = mlxsw_sp_rif_ipip_lb_ul_rif_op(ul_rif, true);\n\tif (err)\n\t\tgoto ul_rif_op_err;\n\n\tatomic_add(rif_entries, &mlxsw_sp->router->rifs_count);\n\treturn ul_rif;\n\nul_rif_op_err:\n\tmlxsw_sp->router->rifs[rif_index] = NULL;\n\tmlxsw_sp_rif_free(ul_rif);\nerr_rif_alloc:\n\tmlxsw_sp_rif_index_free(mlxsw_sp, rif_index, rif_entries);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_ul_rif_destroy(struct mlxsw_sp_rif *ul_rif)\n{\n\tstruct mlxsw_sp *mlxsw_sp = ul_rif->mlxsw_sp;\n\tu8 rif_entries = ul_rif->rif_entries;\n\tu16 rif_index = ul_rif->rif_index;\n\n\tatomic_sub(rif_entries, &mlxsw_sp->router->rifs_count);\n\tmlxsw_sp_rif_ipip_lb_ul_rif_op(ul_rif, false);\n\tmlxsw_sp->router->rifs[ul_rif->rif_index] = NULL;\n\tmlxsw_sp_rif_free(ul_rif);\n\tmlxsw_sp_rif_index_free(mlxsw_sp, rif_index, rif_entries);\n}\n\nstatic struct mlxsw_sp_rif *\nmlxsw_sp_ul_rif_get(struct mlxsw_sp *mlxsw_sp, u32 tb_id,\n\t\t    struct mlxsw_sp_crif *ul_crif,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_vr *vr;\n\tint err;\n\n\tvr = mlxsw_sp_vr_get(mlxsw_sp, tb_id, extack);\n\tif (IS_ERR(vr))\n\t\treturn ERR_CAST(vr);\n\n\tif (refcount_inc_not_zero(&vr->ul_rif_refcnt))\n\t\treturn vr->ul_rif;\n\n\tvr->ul_rif = mlxsw_sp_ul_rif_create(mlxsw_sp, vr, ul_crif, extack);\n\tif (IS_ERR(vr->ul_rif)) {\n\t\terr = PTR_ERR(vr->ul_rif);\n\t\tgoto err_ul_rif_create;\n\t}\n\n\tvr->rif_count++;\n\trefcount_set(&vr->ul_rif_refcnt, 1);\n\n\treturn vr->ul_rif;\n\nerr_ul_rif_create:\n\tmlxsw_sp_vr_put(mlxsw_sp, vr);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_ul_rif_put(struct mlxsw_sp_rif *ul_rif)\n{\n\tstruct mlxsw_sp *mlxsw_sp = ul_rif->mlxsw_sp;\n\tstruct mlxsw_sp_vr *vr;\n\n\tvr = &mlxsw_sp->router->vrs[ul_rif->vr_id];\n\n\tif (!refcount_dec_and_test(&vr->ul_rif_refcnt))\n\t\treturn;\n\n\tvr->rif_count--;\n\tmlxsw_sp_ul_rif_destroy(ul_rif);\n\tmlxsw_sp_vr_put(mlxsw_sp, vr);\n}\n\nint mlxsw_sp_router_ul_rif_get(struct mlxsw_sp *mlxsw_sp, u32 ul_tb_id,\n\t\t\t       u16 *ul_rif_index)\n{\n\tstruct mlxsw_sp_rif *ul_rif;\n\tint err = 0;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\tul_rif = mlxsw_sp_ul_rif_get(mlxsw_sp, ul_tb_id, NULL, NULL);\n\tif (IS_ERR(ul_rif)) {\n\t\terr = PTR_ERR(ul_rif);\n\t\tgoto out;\n\t}\n\t*ul_rif_index = ul_rif->rif_index;\nout:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\treturn err;\n}\n\nvoid mlxsw_sp_router_ul_rif_put(struct mlxsw_sp *mlxsw_sp, u16 ul_rif_index)\n{\n\tstruct mlxsw_sp_rif *ul_rif;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\tul_rif = mlxsw_sp->router->rifs[ul_rif_index];\n\tif (WARN_ON(!ul_rif))\n\t\tgoto out;\n\n\tmlxsw_sp_ul_rif_put(ul_rif);\nout:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n}\n\nstatic int\nmlxsw_sp2_rif_ipip_lb_configure(struct mlxsw_sp_rif *rif,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_rif_ipip_lb *lb_rif = mlxsw_sp_rif_ipip_lb_rif(rif);\n\tstruct net_device *dev = mlxsw_sp_rif_dev(rif);\n\tu32 ul_tb_id = mlxsw_sp_ipip_dev_ul_tb_id(dev);\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tstruct mlxsw_sp_rif *ul_rif;\n\tint err;\n\n\tul_rif = mlxsw_sp_ul_rif_get(mlxsw_sp, ul_tb_id, NULL, extack);\n\tif (IS_ERR(ul_rif))\n\t\treturn PTR_ERR(ul_rif);\n\n\terr = mlxsw_sp_rif_ipip_lb_op(lb_rif, 0, ul_rif->rif_index, true);\n\tif (err)\n\t\tgoto err_loopback_op;\n\n\tlb_rif->ul_vr_id = 0;\n\tlb_rif->ul_rif_id = ul_rif->rif_index;\n\n\treturn 0;\n\nerr_loopback_op:\n\tmlxsw_sp_ul_rif_put(ul_rif);\n\treturn err;\n}\n\nstatic void mlxsw_sp2_rif_ipip_lb_deconfigure(struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp_rif_ipip_lb *lb_rif = mlxsw_sp_rif_ipip_lb_rif(rif);\n\tstruct mlxsw_sp *mlxsw_sp = rif->mlxsw_sp;\n\tstruct mlxsw_sp_rif *ul_rif;\n\n\tul_rif = mlxsw_sp_rif_by_index(mlxsw_sp, lb_rif->ul_rif_id);\n\tmlxsw_sp_rif_ipip_lb_op(lb_rif, 0, lb_rif->ul_rif_id, false);\n\tmlxsw_sp_ul_rif_put(ul_rif);\n}\n\nstatic const struct mlxsw_sp_rif_ops mlxsw_sp2_rif_ipip_lb_ops = {\n\t.type\t\t\t= MLXSW_SP_RIF_TYPE_IPIP_LB,\n\t.rif_size\t\t= sizeof(struct mlxsw_sp_rif_ipip_lb),\n\t.setup                  = mlxsw_sp_rif_ipip_lb_setup,\n\t.configure\t\t= mlxsw_sp2_rif_ipip_lb_configure,\n\t.deconfigure\t\t= mlxsw_sp2_rif_ipip_lb_deconfigure,\n};\n\nstatic const struct mlxsw_sp_rif_ops *mlxsw_sp2_rif_ops_arr[] = {\n\t[MLXSW_SP_RIF_TYPE_SUBPORT]\t= &mlxsw_sp_rif_subport_ops,\n\t[MLXSW_SP_RIF_TYPE_VLAN]\t= &mlxsw_sp2_rif_vlan_ops,\n\t[MLXSW_SP_RIF_TYPE_FID]\t\t= &mlxsw_sp_rif_fid_ops,\n\t[MLXSW_SP_RIF_TYPE_IPIP_LB]\t= &mlxsw_sp2_rif_ipip_lb_ops,\n};\n\nstatic int mlxsw_sp_rifs_table_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct gen_pool *rifs_table;\n\tint err;\n\n\trifs_table = gen_pool_create(0, -1);\n\tif (!rifs_table)\n\t\treturn -ENOMEM;\n\n\tgen_pool_set_algo(rifs_table, gen_pool_first_fit_order_align,\n\t\t\t  NULL);\n\n\terr = gen_pool_add(rifs_table, MLXSW_SP_ROUTER_GENALLOC_OFFSET,\n\t\t\t   MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS), -1);\n\tif (err)\n\t\tgoto err_gen_pool_add;\n\n\tmlxsw_sp->router->rifs_table = rifs_table;\n\n\treturn 0;\n\nerr_gen_pool_add:\n\tgen_pool_destroy(rifs_table);\n\treturn err;\n}\n\nstatic void mlxsw_sp_rifs_table_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tgen_pool_destroy(mlxsw_sp->router->rifs_table);\n}\n\nstatic int mlxsw_sp_rifs_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tu64 max_rifs = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS);\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tstruct mlxsw_core *core = mlxsw_sp->core;\n\tint err;\n\n\tif (!MLXSW_CORE_RES_VALID(core, MAX_RIF_MAC_PROFILES))\n\t\treturn -EIO;\n\tmlxsw_sp->router->max_rif_mac_profile =\n\t\tMLXSW_CORE_RES_GET(core, MAX_RIF_MAC_PROFILES);\n\n\tmlxsw_sp->router->rifs = kcalloc(max_rifs,\n\t\t\t\t\t sizeof(struct mlxsw_sp_rif *),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!mlxsw_sp->router->rifs)\n\t\treturn -ENOMEM;\n\n\terr = mlxsw_sp_rifs_table_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_rifs_table_init;\n\n\tidr_init(&mlxsw_sp->router->rif_mac_profiles_idr);\n\tatomic_set(&mlxsw_sp->router->rif_mac_profiles_count, 0);\n\tatomic_set(&mlxsw_sp->router->rifs_count, 0);\n\tdevl_resource_occ_get_register(devlink,\n\t\t\t\t       MLXSW_SP_RESOURCE_RIF_MAC_PROFILES,\n\t\t\t\t       mlxsw_sp_rif_mac_profiles_occ_get,\n\t\t\t\t       mlxsw_sp);\n\tdevl_resource_occ_get_register(devlink,\n\t\t\t\t       MLXSW_SP_RESOURCE_RIFS,\n\t\t\t\t       mlxsw_sp_rifs_occ_get,\n\t\t\t\t       mlxsw_sp);\n\n\treturn 0;\n\nerr_rifs_table_init:\n\tkfree(mlxsw_sp->router->rifs);\n\treturn err;\n}\n\nstatic void mlxsw_sp_rifs_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tint max_rifs = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS);\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tint i;\n\n\tWARN_ON_ONCE(atomic_read(&mlxsw_sp->router->rifs_count));\n\tfor (i = 0; i < max_rifs; i++)\n\t\tWARN_ON_ONCE(mlxsw_sp->router->rifs[i]);\n\n\tdevl_resource_occ_get_unregister(devlink, MLXSW_SP_RESOURCE_RIFS);\n\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t MLXSW_SP_RESOURCE_RIF_MAC_PROFILES);\n\tWARN_ON(!idr_is_empty(&mlxsw_sp->router->rif_mac_profiles_idr));\n\tidr_destroy(&mlxsw_sp->router->rif_mac_profiles_idr);\n\tmlxsw_sp_rifs_table_fini(mlxsw_sp);\n\tkfree(mlxsw_sp->router->rifs);\n}\n\nstatic int\nmlxsw_sp_ipip_config_tigcr(struct mlxsw_sp *mlxsw_sp)\n{\n\tchar tigcr_pl[MLXSW_REG_TIGCR_LEN];\n\n\tmlxsw_reg_tigcr_pack(tigcr_pl, true, 0);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(tigcr), tigcr_pl);\n}\n\nstatic int mlxsw_sp_ipips_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tint err;\n\n\tINIT_LIST_HEAD(&mlxsw_sp->router->ipip_list);\n\n\terr = mlxsw_sp_ipip_ecn_encap_init(mlxsw_sp);\n\tif (err)\n\t\treturn err;\n\terr = mlxsw_sp_ipip_ecn_decap_init(mlxsw_sp);\n\tif (err)\n\t\treturn err;\n\n\treturn mlxsw_sp_ipip_config_tigcr(mlxsw_sp);\n}\n\nstatic int mlxsw_sp1_ipips_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tmlxsw_sp->router->ipip_ops_arr = mlxsw_sp1_ipip_ops_arr;\n\treturn mlxsw_sp_ipips_init(mlxsw_sp);\n}\n\nstatic int mlxsw_sp2_ipips_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tmlxsw_sp->router->ipip_ops_arr = mlxsw_sp2_ipip_ops_arr;\n\treturn mlxsw_sp_ipips_init(mlxsw_sp);\n}\n\nstatic void mlxsw_sp_ipips_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tWARN_ON(!list_empty(&mlxsw_sp->router->ipip_list));\n}\n\nstatic void mlxsw_sp_router_fib_dump_flush(struct notifier_block *nb)\n{\n\tstruct mlxsw_sp_router *router;\n\n\t \n\tmlxsw_core_flush_owq();\n\trouter = container_of(nb, struct mlxsw_sp_router, fib_nb);\n\tmlxsw_sp_router_fib_flush(router->mlxsw_sp);\n}\n\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\nstruct mlxsw_sp_mp_hash_config {\n\tDECLARE_BITMAP(headers, __MLXSW_REG_RECR2_HEADER_CNT);\n\tDECLARE_BITMAP(fields, __MLXSW_REG_RECR2_FIELD_CNT);\n\tDECLARE_BITMAP(inner_headers, __MLXSW_REG_RECR2_HEADER_CNT);\n\tDECLARE_BITMAP(inner_fields, __MLXSW_REG_RECR2_INNER_FIELD_CNT);\n\tbool inc_parsing_depth;\n};\n\n#define MLXSW_SP_MP_HASH_HEADER_SET(_headers, _header) \\\n\tbitmap_set(_headers, MLXSW_REG_RECR2_##_header, 1)\n\n#define MLXSW_SP_MP_HASH_FIELD_SET(_fields, _field) \\\n\tbitmap_set(_fields, MLXSW_REG_RECR2_##_field, 1)\n\n#define MLXSW_SP_MP_HASH_FIELD_RANGE_SET(_fields, _field, _nr) \\\n\tbitmap_set(_fields, MLXSW_REG_RECR2_##_field, _nr)\n\nstatic void mlxsw_sp_mp_hash_inner_l3(struct mlxsw_sp_mp_hash_config *config)\n{\n\tunsigned long *inner_headers = config->inner_headers;\n\tunsigned long *inner_fields = config->inner_fields;\n\n\t \n\tMLXSW_SP_MP_HASH_HEADER_SET(inner_headers, IPV4_EN_NOT_TCP_NOT_UDP);\n\tMLXSW_SP_MP_HASH_HEADER_SET(inner_headers, IPV4_EN_TCP_UDP);\n\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(inner_fields, INNER_IPV4_SIP0, 4);\n\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(inner_fields, INNER_IPV4_DIP0, 4);\n\t \n\tMLXSW_SP_MP_HASH_HEADER_SET(inner_headers, IPV6_EN_NOT_TCP_NOT_UDP);\n\tMLXSW_SP_MP_HASH_HEADER_SET(inner_headers, IPV6_EN_TCP_UDP);\n\tMLXSW_SP_MP_HASH_FIELD_SET(inner_fields, INNER_IPV6_SIP0_7);\n\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(inner_fields, INNER_IPV6_SIP8, 8);\n\tMLXSW_SP_MP_HASH_FIELD_SET(inner_fields, INNER_IPV6_DIP0_7);\n\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(inner_fields, INNER_IPV6_DIP8, 8);\n\tMLXSW_SP_MP_HASH_FIELD_SET(inner_fields, INNER_IPV6_NEXT_HEADER);\n\tMLXSW_SP_MP_HASH_FIELD_SET(inner_fields, INNER_IPV6_FLOW_LABEL);\n}\n\nstatic void mlxsw_sp_mp4_hash_outer_addr(struct mlxsw_sp_mp_hash_config *config)\n{\n\tunsigned long *headers = config->headers;\n\tunsigned long *fields = config->fields;\n\n\tMLXSW_SP_MP_HASH_HEADER_SET(headers, IPV4_EN_NOT_TCP_NOT_UDP);\n\tMLXSW_SP_MP_HASH_HEADER_SET(headers, IPV4_EN_TCP_UDP);\n\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(fields, IPV4_SIP0, 4);\n\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(fields, IPV4_DIP0, 4);\n}\n\nstatic void\nmlxsw_sp_mp_hash_inner_custom(struct mlxsw_sp_mp_hash_config *config,\n\t\t\t      u32 hash_fields)\n{\n\tunsigned long *inner_headers = config->inner_headers;\n\tunsigned long *inner_fields = config->inner_fields;\n\n\t \n\tMLXSW_SP_MP_HASH_HEADER_SET(inner_headers, IPV4_EN_NOT_TCP_NOT_UDP);\n\tMLXSW_SP_MP_HASH_HEADER_SET(inner_headers, IPV4_EN_TCP_UDP);\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_SRC_IP)\n\t\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(inner_fields, INNER_IPV4_SIP0, 4);\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_DST_IP)\n\t\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(inner_fields, INNER_IPV4_DIP0, 4);\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_IP_PROTO)\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(inner_fields, INNER_IPV4_PROTOCOL);\n\t \n\tMLXSW_SP_MP_HASH_HEADER_SET(inner_headers, IPV6_EN_NOT_TCP_NOT_UDP);\n\tMLXSW_SP_MP_HASH_HEADER_SET(inner_headers, IPV6_EN_TCP_UDP);\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_SRC_IP) {\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(inner_fields, INNER_IPV6_SIP0_7);\n\t\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(inner_fields, INNER_IPV6_SIP8, 8);\n\t}\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_DST_IP) {\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(inner_fields, INNER_IPV6_DIP0_7);\n\t\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(inner_fields, INNER_IPV6_DIP8, 8);\n\t}\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_IP_PROTO)\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(inner_fields, INNER_IPV6_NEXT_HEADER);\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_FLOWLABEL)\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(inner_fields, INNER_IPV6_FLOW_LABEL);\n\t \n\tMLXSW_SP_MP_HASH_HEADER_SET(inner_headers, TCP_UDP_EN_IPV4);\n\tMLXSW_SP_MP_HASH_HEADER_SET(inner_headers, TCP_UDP_EN_IPV6);\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_SRC_PORT)\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(inner_fields, INNER_TCP_UDP_SPORT);\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_DST_PORT)\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(inner_fields, INNER_TCP_UDP_DPORT);\n}\n\nstatic void mlxsw_sp_mp4_hash_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_mp_hash_config *config)\n{\n\tstruct net *net = mlxsw_sp_net(mlxsw_sp);\n\tunsigned long *headers = config->headers;\n\tunsigned long *fields = config->fields;\n\tu32 hash_fields;\n\n\tswitch (READ_ONCE(net->ipv4.sysctl_fib_multipath_hash_policy)) {\n\tcase 0:\n\t\tmlxsw_sp_mp4_hash_outer_addr(config);\n\t\tbreak;\n\tcase 1:\n\t\tmlxsw_sp_mp4_hash_outer_addr(config);\n\t\tMLXSW_SP_MP_HASH_HEADER_SET(headers, TCP_UDP_EN_IPV4);\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, IPV4_PROTOCOL);\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, TCP_UDP_SPORT);\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, TCP_UDP_DPORT);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tmlxsw_sp_mp4_hash_outer_addr(config);\n\t\t \n\t\tmlxsw_sp_mp_hash_inner_l3(config);\n\t\tbreak;\n\tcase 3:\n\t\thash_fields = READ_ONCE(net->ipv4.sysctl_fib_multipath_hash_fields);\n\t\t \n\t\tMLXSW_SP_MP_HASH_HEADER_SET(headers, IPV4_EN_NOT_TCP_NOT_UDP);\n\t\tMLXSW_SP_MP_HASH_HEADER_SET(headers, IPV4_EN_TCP_UDP);\n\t\tMLXSW_SP_MP_HASH_HEADER_SET(headers, TCP_UDP_EN_IPV4);\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_SRC_IP)\n\t\t\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(fields, IPV4_SIP0, 4);\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_DST_IP)\n\t\t\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(fields, IPV4_DIP0, 4);\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_IP_PROTO)\n\t\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, IPV4_PROTOCOL);\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_SRC_PORT)\n\t\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, TCP_UDP_SPORT);\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_DST_PORT)\n\t\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, TCP_UDP_DPORT);\n\t\t \n\t\tmlxsw_sp_mp_hash_inner_custom(config, hash_fields);\n\t\tbreak;\n\t}\n}\n\nstatic void mlxsw_sp_mp6_hash_outer_addr(struct mlxsw_sp_mp_hash_config *config)\n{\n\tunsigned long *headers = config->headers;\n\tunsigned long *fields = config->fields;\n\n\tMLXSW_SP_MP_HASH_HEADER_SET(headers, IPV6_EN_NOT_TCP_NOT_UDP);\n\tMLXSW_SP_MP_HASH_HEADER_SET(headers, IPV6_EN_TCP_UDP);\n\tMLXSW_SP_MP_HASH_FIELD_SET(fields, IPV6_SIP0_7);\n\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(fields, IPV6_SIP8, 8);\n\tMLXSW_SP_MP_HASH_FIELD_SET(fields, IPV6_DIP0_7);\n\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(fields, IPV6_DIP8, 8);\n}\n\nstatic void mlxsw_sp_mp6_hash_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_mp_hash_config *config)\n{\n\tu32 hash_fields = ip6_multipath_hash_fields(mlxsw_sp_net(mlxsw_sp));\n\tunsigned long *headers = config->headers;\n\tunsigned long *fields = config->fields;\n\n\tswitch (ip6_multipath_hash_policy(mlxsw_sp_net(mlxsw_sp))) {\n\tcase 0:\n\t\tmlxsw_sp_mp6_hash_outer_addr(config);\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, IPV6_NEXT_HEADER);\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, IPV6_FLOW_LABEL);\n\t\tbreak;\n\tcase 1:\n\t\tmlxsw_sp_mp6_hash_outer_addr(config);\n\t\tMLXSW_SP_MP_HASH_HEADER_SET(headers, TCP_UDP_EN_IPV6);\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, IPV6_NEXT_HEADER);\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, TCP_UDP_SPORT);\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, TCP_UDP_DPORT);\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tmlxsw_sp_mp6_hash_outer_addr(config);\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, IPV6_NEXT_HEADER);\n\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, IPV6_FLOW_LABEL);\n\t\t \n\t\tmlxsw_sp_mp_hash_inner_l3(config);\n\t\tconfig->inc_parsing_depth = true;\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tMLXSW_SP_MP_HASH_HEADER_SET(headers, IPV6_EN_NOT_TCP_NOT_UDP);\n\t\tMLXSW_SP_MP_HASH_HEADER_SET(headers, IPV6_EN_TCP_UDP);\n\t\tMLXSW_SP_MP_HASH_HEADER_SET(headers, TCP_UDP_EN_IPV6);\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_SRC_IP) {\n\t\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, IPV6_SIP0_7);\n\t\t\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(fields, IPV6_SIP8, 8);\n\t\t}\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_DST_IP) {\n\t\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, IPV6_DIP0_7);\n\t\t\tMLXSW_SP_MP_HASH_FIELD_RANGE_SET(fields, IPV6_DIP8, 8);\n\t\t}\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_IP_PROTO)\n\t\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, IPV6_NEXT_HEADER);\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_FLOWLABEL)\n\t\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, IPV6_FLOW_LABEL);\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_SRC_PORT)\n\t\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, TCP_UDP_SPORT);\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_DST_PORT)\n\t\t\tMLXSW_SP_MP_HASH_FIELD_SET(fields, TCP_UDP_DPORT);\n\t\t \n\t\tmlxsw_sp_mp_hash_inner_custom(config, hash_fields);\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_MASK)\n\t\t\tconfig->inc_parsing_depth = true;\n\t\tbreak;\n\t}\n}\n\nstatic int mlxsw_sp_mp_hash_parsing_depth_adjust(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t bool old_inc_parsing_depth,\n\t\t\t\t\t\t bool new_inc_parsing_depth)\n{\n\tint err;\n\n\tif (!old_inc_parsing_depth && new_inc_parsing_depth) {\n\t\terr = mlxsw_sp_parsing_depth_inc(mlxsw_sp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmlxsw_sp->router->inc_parsing_depth = true;\n\t} else if (old_inc_parsing_depth && !new_inc_parsing_depth) {\n\t\tmlxsw_sp_parsing_depth_dec(mlxsw_sp);\n\t\tmlxsw_sp->router->inc_parsing_depth = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_mp_hash_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tbool old_inc_parsing_depth, new_inc_parsing_depth;\n\tstruct mlxsw_sp_mp_hash_config config = {};\n\tchar recr2_pl[MLXSW_REG_RECR2_LEN];\n\tunsigned long bit;\n\tu32 seed;\n\tint err;\n\n\tseed = jhash(mlxsw_sp->base_mac, sizeof(mlxsw_sp->base_mac), 0);\n\tmlxsw_reg_recr2_pack(recr2_pl, seed);\n\tmlxsw_sp_mp4_hash_init(mlxsw_sp, &config);\n\tmlxsw_sp_mp6_hash_init(mlxsw_sp, &config);\n\n\told_inc_parsing_depth = mlxsw_sp->router->inc_parsing_depth;\n\tnew_inc_parsing_depth = config.inc_parsing_depth;\n\terr = mlxsw_sp_mp_hash_parsing_depth_adjust(mlxsw_sp,\n\t\t\t\t\t\t    old_inc_parsing_depth,\n\t\t\t\t\t\t    new_inc_parsing_depth);\n\tif (err)\n\t\treturn err;\n\n\tfor_each_set_bit(bit, config.headers, __MLXSW_REG_RECR2_HEADER_CNT)\n\t\tmlxsw_reg_recr2_outer_header_enables_set(recr2_pl, bit, 1);\n\tfor_each_set_bit(bit, config.fields, __MLXSW_REG_RECR2_FIELD_CNT)\n\t\tmlxsw_reg_recr2_outer_header_fields_enable_set(recr2_pl, bit, 1);\n\tfor_each_set_bit(bit, config.inner_headers, __MLXSW_REG_RECR2_HEADER_CNT)\n\t\tmlxsw_reg_recr2_inner_header_enables_set(recr2_pl, bit, 1);\n\tfor_each_set_bit(bit, config.inner_fields, __MLXSW_REG_RECR2_INNER_FIELD_CNT)\n\t\tmlxsw_reg_recr2_inner_header_fields_enable_set(recr2_pl, bit, 1);\n\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(recr2), recr2_pl);\n\tif (err)\n\t\tgoto err_reg_write;\n\n\treturn 0;\n\nerr_reg_write:\n\tmlxsw_sp_mp_hash_parsing_depth_adjust(mlxsw_sp, new_inc_parsing_depth,\n\t\t\t\t\t      old_inc_parsing_depth);\n\treturn err;\n}\n\nstatic void mlxsw_sp_mp_hash_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tbool old_inc_parsing_depth = mlxsw_sp->router->inc_parsing_depth;\n\n\tmlxsw_sp_mp_hash_parsing_depth_adjust(mlxsw_sp, old_inc_parsing_depth,\n\t\t\t\t\t      false);\n}\n#else\nstatic int mlxsw_sp_mp_hash_init(struct mlxsw_sp *mlxsw_sp)\n{\n\treturn 0;\n}\n\nstatic void mlxsw_sp_mp_hash_fini(struct mlxsw_sp *mlxsw_sp)\n{\n}\n#endif\n\nstatic int mlxsw_sp_dscp_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tchar rdpm_pl[MLXSW_REG_RDPM_LEN];\n\tunsigned int i;\n\n\tMLXSW_REG_ZERO(rdpm, rdpm_pl);\n\n\t \n\tfor (i = 0; i < MLXSW_REG_RDPM_DSCP_ENTRY_REC_MAX_COUNT; i++)\n\t\tmlxsw_reg_rdpm_pack(rdpm_pl, i, rt_tos2priority(i << 2));\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rdpm), rdpm_pl);\n}\n\nstatic int __mlxsw_sp_router_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct net *net = mlxsw_sp_net(mlxsw_sp);\n\tchar rgcr_pl[MLXSW_REG_RGCR_LEN];\n\tu64 max_rifs;\n\tbool usp;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, MAX_RIFS))\n\t\treturn -EIO;\n\tmax_rifs = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS);\n\tusp = READ_ONCE(net->ipv4.sysctl_ip_fwd_update_priority);\n\n\tmlxsw_reg_rgcr_pack(rgcr_pl, true, true);\n\tmlxsw_reg_rgcr_max_router_interfaces_set(rgcr_pl, max_rifs);\n\tmlxsw_reg_rgcr_usp_set(rgcr_pl, usp);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rgcr), rgcr_pl);\n}\n\nstatic void __mlxsw_sp_router_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tchar rgcr_pl[MLXSW_REG_RGCR_LEN];\n\n\tmlxsw_reg_rgcr_pack(rgcr_pl, false, false);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rgcr), rgcr_pl);\n}\n\nstatic int mlxsw_sp_lb_rif_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_router *router = mlxsw_sp->router;\n\tstruct mlxsw_sp_rif *lb_rif;\n\tint err;\n\n\trouter->lb_crif = mlxsw_sp_crif_alloc(NULL);\n\tif (!router->lb_crif)\n\t\treturn -ENOMEM;\n\n\t \n\tlb_rif = mlxsw_sp_ul_rif_get(mlxsw_sp, RT_TABLE_MAIN, router->lb_crif,\n\t\t\t\t     extack);\n\tif (IS_ERR(lb_rif)) {\n\t\terr = PTR_ERR(lb_rif);\n\t\tgoto err_ul_rif_get;\n\t}\n\n\treturn 0;\n\nerr_ul_rif_get:\n\tmlxsw_sp_crif_free(router->lb_crif);\n\treturn err;\n}\n\nstatic void mlxsw_sp_lb_rif_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tmlxsw_sp_ul_rif_put(mlxsw_sp->router->lb_crif->rif);\n\tmlxsw_sp_crif_free(mlxsw_sp->router->lb_crif);\n}\n\nstatic int mlxsw_sp1_router_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tsize_t size_ranges_count = ARRAY_SIZE(mlxsw_sp1_adj_grp_size_ranges);\n\n\tmlxsw_sp->router->rif_ops_arr = mlxsw_sp1_rif_ops_arr;\n\tmlxsw_sp->router->adj_grp_size_ranges = mlxsw_sp1_adj_grp_size_ranges;\n\tmlxsw_sp->router->adj_grp_size_ranges_count = size_ranges_count;\n\n\treturn 0;\n}\n\nconst struct mlxsw_sp_router_ops mlxsw_sp1_router_ops = {\n\t.init = mlxsw_sp1_router_init,\n\t.ipips_init = mlxsw_sp1_ipips_init,\n};\n\nstatic int mlxsw_sp2_router_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tsize_t size_ranges_count = ARRAY_SIZE(mlxsw_sp2_adj_grp_size_ranges);\n\n\tmlxsw_sp->router->rif_ops_arr = mlxsw_sp2_rif_ops_arr;\n\tmlxsw_sp->router->adj_grp_size_ranges = mlxsw_sp2_adj_grp_size_ranges;\n\tmlxsw_sp->router->adj_grp_size_ranges_count = size_ranges_count;\n\n\treturn 0;\n}\n\nconst struct mlxsw_sp_router_ops mlxsw_sp2_router_ops = {\n\t.init = mlxsw_sp2_router_init,\n\t.ipips_init = mlxsw_sp2_ipips_init,\n};\n\nint mlxsw_sp_router_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_router *router;\n\tstruct notifier_block *nb;\n\tint err;\n\n\trouter = kzalloc(sizeof(*mlxsw_sp->router), GFP_KERNEL);\n\tif (!router)\n\t\treturn -ENOMEM;\n\tmutex_init(&router->lock);\n\tmlxsw_sp->router = router;\n\trouter->mlxsw_sp = mlxsw_sp;\n\n\terr = mlxsw_sp->router_ops->init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_router_ops_init;\n\n\tINIT_LIST_HEAD(&mlxsw_sp->router->nh_res_grp_list);\n\tINIT_DELAYED_WORK(&mlxsw_sp->router->nh_grp_activity_dw,\n\t\t\t  mlxsw_sp_nh_grp_activity_work);\n\tINIT_LIST_HEAD(&mlxsw_sp->router->nexthop_neighs_list);\n\terr = __mlxsw_sp_router_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_router_init;\n\n\terr = mlxsw_sp->router_ops->ipips_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_ipips_init;\n\n\terr = rhashtable_init(&mlxsw_sp->router->crif_ht,\n\t\t\t      &mlxsw_sp_crif_ht_params);\n\tif (err)\n\t\tgoto err_crif_ht_init;\n\n\terr = mlxsw_sp_rifs_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_rifs_init;\n\n\terr = rhashtable_init(&mlxsw_sp->router->nexthop_ht,\n\t\t\t      &mlxsw_sp_nexthop_ht_params);\n\tif (err)\n\t\tgoto err_nexthop_ht_init;\n\n\terr = rhashtable_init(&mlxsw_sp->router->nexthop_group_ht,\n\t\t\t      &mlxsw_sp_nexthop_group_ht_params);\n\tif (err)\n\t\tgoto err_nexthop_group_ht_init;\n\n\tINIT_LIST_HEAD(&mlxsw_sp->router->nexthop_list);\n\terr = mlxsw_sp_lpm_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_lpm_init;\n\n\terr = mlxsw_sp_mr_init(mlxsw_sp, &mlxsw_sp_mr_tcam_ops);\n\tif (err)\n\t\tgoto err_mr_init;\n\n\terr = mlxsw_sp_vrs_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_vrs_init;\n\n\terr = mlxsw_sp_lb_rif_init(mlxsw_sp, extack);\n\tif (err)\n\t\tgoto err_lb_rif_init;\n\n\terr = mlxsw_sp_neigh_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_neigh_init;\n\n\terr = mlxsw_sp_mp_hash_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_mp_hash_init;\n\n\terr = mlxsw_sp_dscp_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_dscp_init;\n\n\trouter->inetaddr_nb.notifier_call = mlxsw_sp_inetaddr_event;\n\terr = register_inetaddr_notifier(&router->inetaddr_nb);\n\tif (err)\n\t\tgoto err_register_inetaddr_notifier;\n\n\trouter->inet6addr_nb.notifier_call = mlxsw_sp_inet6addr_event;\n\terr = register_inet6addr_notifier(&router->inet6addr_nb);\n\tif (err)\n\t\tgoto err_register_inet6addr_notifier;\n\n\trouter->inetaddr_valid_nb.notifier_call = mlxsw_sp_inetaddr_valid_event;\n\terr = register_inetaddr_validator_notifier(&router->inetaddr_valid_nb);\n\tif (err)\n\t\tgoto err_register_inetaddr_valid_notifier;\n\n\tnb = &router->inet6addr_valid_nb;\n\tnb->notifier_call = mlxsw_sp_inet6addr_valid_event;\n\terr = register_inet6addr_validator_notifier(nb);\n\tif (err)\n\t\tgoto err_register_inet6addr_valid_notifier;\n\n\tmlxsw_sp->router->netevent_nb.notifier_call =\n\t\tmlxsw_sp_router_netevent_event;\n\terr = register_netevent_notifier(&mlxsw_sp->router->netevent_nb);\n\tif (err)\n\t\tgoto err_register_netevent_notifier;\n\n\tmlxsw_sp->router->netdevice_nb.notifier_call =\n\t\tmlxsw_sp_router_netdevice_event;\n\terr = register_netdevice_notifier_net(mlxsw_sp_net(mlxsw_sp),\n\t\t\t\t\t      &mlxsw_sp->router->netdevice_nb);\n\tif (err)\n\t\tgoto err_register_netdev_notifier;\n\n\tmlxsw_sp->router->nexthop_nb.notifier_call =\n\t\tmlxsw_sp_nexthop_obj_event;\n\terr = register_nexthop_notifier(mlxsw_sp_net(mlxsw_sp),\n\t\t\t\t\t&mlxsw_sp->router->nexthop_nb,\n\t\t\t\t\textack);\n\tif (err)\n\t\tgoto err_register_nexthop_notifier;\n\n\tmlxsw_sp->router->fib_nb.notifier_call = mlxsw_sp_router_fib_event;\n\terr = register_fib_notifier(mlxsw_sp_net(mlxsw_sp),\n\t\t\t\t    &mlxsw_sp->router->fib_nb,\n\t\t\t\t    mlxsw_sp_router_fib_dump_flush, extack);\n\tif (err)\n\t\tgoto err_register_fib_notifier;\n\n\treturn 0;\n\nerr_register_fib_notifier:\n\tunregister_nexthop_notifier(mlxsw_sp_net(mlxsw_sp),\n\t\t\t\t    &mlxsw_sp->router->nexthop_nb);\nerr_register_nexthop_notifier:\n\tunregister_netdevice_notifier_net(mlxsw_sp_net(mlxsw_sp),\n\t\t\t\t\t  &router->netdevice_nb);\nerr_register_netdev_notifier:\n\tunregister_netevent_notifier(&mlxsw_sp->router->netevent_nb);\nerr_register_netevent_notifier:\n\tunregister_inet6addr_validator_notifier(&router->inet6addr_valid_nb);\nerr_register_inet6addr_valid_notifier:\n\tunregister_inetaddr_validator_notifier(&router->inetaddr_valid_nb);\nerr_register_inetaddr_valid_notifier:\n\tunregister_inet6addr_notifier(&router->inet6addr_nb);\nerr_register_inet6addr_notifier:\n\tunregister_inetaddr_notifier(&router->inetaddr_nb);\nerr_register_inetaddr_notifier:\n\tmlxsw_core_flush_owq();\nerr_dscp_init:\n\tmlxsw_sp_mp_hash_fini(mlxsw_sp);\nerr_mp_hash_init:\n\tmlxsw_sp_neigh_fini(mlxsw_sp);\nerr_neigh_init:\n\tmlxsw_sp_lb_rif_fini(mlxsw_sp);\nerr_lb_rif_init:\n\tmlxsw_sp_vrs_fini(mlxsw_sp);\nerr_vrs_init:\n\tmlxsw_sp_mr_fini(mlxsw_sp);\nerr_mr_init:\n\tmlxsw_sp_lpm_fini(mlxsw_sp);\nerr_lpm_init:\n\trhashtable_destroy(&mlxsw_sp->router->nexthop_group_ht);\nerr_nexthop_group_ht_init:\n\trhashtable_destroy(&mlxsw_sp->router->nexthop_ht);\nerr_nexthop_ht_init:\n\tmlxsw_sp_rifs_fini(mlxsw_sp);\nerr_rifs_init:\n\trhashtable_destroy(&mlxsw_sp->router->crif_ht);\nerr_crif_ht_init:\n\tmlxsw_sp_ipips_fini(mlxsw_sp);\nerr_ipips_init:\n\t__mlxsw_sp_router_fini(mlxsw_sp);\nerr_router_init:\n\tcancel_delayed_work_sync(&mlxsw_sp->router->nh_grp_activity_dw);\nerr_router_ops_init:\n\tmutex_destroy(&mlxsw_sp->router->lock);\n\tkfree(mlxsw_sp->router);\n\treturn err;\n}\n\nvoid mlxsw_sp_router_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_router *router = mlxsw_sp->router;\n\n\tunregister_fib_notifier(mlxsw_sp_net(mlxsw_sp), &router->fib_nb);\n\tunregister_nexthop_notifier(mlxsw_sp_net(mlxsw_sp),\n\t\t\t\t    &router->nexthop_nb);\n\tunregister_netdevice_notifier_net(mlxsw_sp_net(mlxsw_sp),\n\t\t\t\t\t  &router->netdevice_nb);\n\tunregister_netevent_notifier(&router->netevent_nb);\n\tunregister_inet6addr_validator_notifier(&router->inet6addr_valid_nb);\n\tunregister_inetaddr_validator_notifier(&router->inetaddr_valid_nb);\n\tunregister_inet6addr_notifier(&router->inet6addr_nb);\n\tunregister_inetaddr_notifier(&router->inetaddr_nb);\n\tmlxsw_core_flush_owq();\n\tmlxsw_sp_mp_hash_fini(mlxsw_sp);\n\tmlxsw_sp_neigh_fini(mlxsw_sp);\n\tmlxsw_sp_lb_rif_fini(mlxsw_sp);\n\tmlxsw_sp_vrs_fini(mlxsw_sp);\n\tmlxsw_sp_mr_fini(mlxsw_sp);\n\tmlxsw_sp_lpm_fini(mlxsw_sp);\n\trhashtable_destroy(&router->nexthop_group_ht);\n\trhashtable_destroy(&router->nexthop_ht);\n\tmlxsw_sp_rifs_fini(mlxsw_sp);\n\trhashtable_destroy(&mlxsw_sp->router->crif_ht);\n\tmlxsw_sp_ipips_fini(mlxsw_sp);\n\t__mlxsw_sp_router_fini(mlxsw_sp);\n\tcancel_delayed_work_sync(&router->nh_grp_activity_dw);\n\tmutex_destroy(&router->lock);\n\tkfree(router);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}