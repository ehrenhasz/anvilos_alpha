{
  "module_name": "spectrum1_kvdl.c",
  "hash_id": "278f5622e4129d6683fec0cbdce23c66eb22e20e90e50322079910f7dd293d09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum1_kvdl.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n\n#include \"spectrum.h\"\n\n#define MLXSW_SP1_KVDL_SINGLE_BASE 0\n#define MLXSW_SP1_KVDL_SINGLE_SIZE 16384\n#define MLXSW_SP1_KVDL_SINGLE_END \\\n\t(MLXSW_SP1_KVDL_SINGLE_SIZE + MLXSW_SP1_KVDL_SINGLE_BASE - 1)\n\n#define MLXSW_SP1_KVDL_CHUNKS_BASE \\\n\t(MLXSW_SP1_KVDL_SINGLE_BASE + MLXSW_SP1_KVDL_SINGLE_SIZE)\n#define MLXSW_SP1_KVDL_CHUNKS_SIZE 49152\n#define MLXSW_SP1_KVDL_CHUNKS_END \\\n\t(MLXSW_SP1_KVDL_CHUNKS_SIZE + MLXSW_SP1_KVDL_CHUNKS_BASE - 1)\n\n#define MLXSW_SP1_KVDL_LARGE_CHUNKS_BASE \\\n\t(MLXSW_SP1_KVDL_CHUNKS_BASE + MLXSW_SP1_KVDL_CHUNKS_SIZE)\n#define MLXSW_SP1_KVDL_LARGE_CHUNKS_SIZE \\\n\t(MLXSW_SP_KVD_LINEAR_SIZE - MLXSW_SP1_KVDL_LARGE_CHUNKS_BASE)\n#define MLXSW_SP1_KVDL_LARGE_CHUNKS_END \\\n\t(MLXSW_SP1_KVDL_LARGE_CHUNKS_SIZE + MLXSW_SP1_KVDL_LARGE_CHUNKS_BASE - 1)\n\n#define MLXSW_SP1_KVDL_SINGLE_ALLOC_SIZE 1\n#define MLXSW_SP1_KVDL_CHUNKS_ALLOC_SIZE 32\n#define MLXSW_SP1_KVDL_LARGE_CHUNKS_ALLOC_SIZE 512\n\nstruct mlxsw_sp1_kvdl_part_info {\n\tunsigned int part_index;\n\tunsigned int start_index;\n\tunsigned int end_index;\n\tunsigned int alloc_size;\n\tenum mlxsw_sp_resource_id resource_id;\n};\n\nenum mlxsw_sp1_kvdl_part_id {\n\tMLXSW_SP1_KVDL_PART_ID_SINGLE,\n\tMLXSW_SP1_KVDL_PART_ID_CHUNKS,\n\tMLXSW_SP1_KVDL_PART_ID_LARGE_CHUNKS,\n};\n\n#define MLXSW_SP1_KVDL_PART_INFO(id)\t\t\t\t\\\n[MLXSW_SP1_KVDL_PART_ID_##id] = {\t\t\t\t\\\n\t.start_index = MLXSW_SP1_KVDL_##id##_BASE,\t\t\\\n\t.end_index = MLXSW_SP1_KVDL_##id##_END,\t\t\t\\\n\t.alloc_size = MLXSW_SP1_KVDL_##id##_ALLOC_SIZE,\t\t\\\n\t.resource_id = MLXSW_SP_RESOURCE_KVD_LINEAR_##id,\t\\\n}\n\nstatic const struct mlxsw_sp1_kvdl_part_info mlxsw_sp1_kvdl_parts_info[] = {\n\tMLXSW_SP1_KVDL_PART_INFO(SINGLE),\n\tMLXSW_SP1_KVDL_PART_INFO(CHUNKS),\n\tMLXSW_SP1_KVDL_PART_INFO(LARGE_CHUNKS),\n};\n\n#define MLXSW_SP1_KVDL_PARTS_INFO_LEN ARRAY_SIZE(mlxsw_sp1_kvdl_parts_info)\n\nstruct mlxsw_sp1_kvdl_part {\n\tstruct mlxsw_sp1_kvdl_part_info info;\n\tunsigned long usage[];\t \n};\n\nstruct mlxsw_sp1_kvdl {\n\tstruct mlxsw_sp1_kvdl_part *parts[MLXSW_SP1_KVDL_PARTS_INFO_LEN];\n};\n\nstatic struct mlxsw_sp1_kvdl_part *\nmlxsw_sp1_kvdl_alloc_size_part(struct mlxsw_sp1_kvdl *kvdl,\n\t\t\t       unsigned int alloc_size)\n{\n\tstruct mlxsw_sp1_kvdl_part *part, *min_part = NULL;\n\tint i;\n\n\tfor (i = 0; i < MLXSW_SP1_KVDL_PARTS_INFO_LEN; i++) {\n\t\tpart = kvdl->parts[i];\n\t\tif (alloc_size <= part->info.alloc_size &&\n\t\t    (!min_part ||\n\t\t     part->info.alloc_size <= min_part->info.alloc_size))\n\t\t\tmin_part = part;\n\t}\n\n\treturn min_part ?: ERR_PTR(-ENOBUFS);\n}\n\nstatic struct mlxsw_sp1_kvdl_part *\nmlxsw_sp1_kvdl_index_part(struct mlxsw_sp1_kvdl *kvdl, u32 kvdl_index)\n{\n\tstruct mlxsw_sp1_kvdl_part *part;\n\tint i;\n\n\tfor (i = 0; i < MLXSW_SP1_KVDL_PARTS_INFO_LEN; i++) {\n\t\tpart = kvdl->parts[i];\n\t\tif (kvdl_index >= part->info.start_index &&\n\t\t    kvdl_index <= part->info.end_index)\n\t\t\treturn part;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic u32\nmlxsw_sp1_kvdl_to_kvdl_index(const struct mlxsw_sp1_kvdl_part_info *info,\n\t\t\t     unsigned int entry_index)\n{\n\treturn info->start_index + entry_index * info->alloc_size;\n}\n\nstatic unsigned int\nmlxsw_sp1_kvdl_to_entry_index(const struct mlxsw_sp1_kvdl_part_info *info,\n\t\t\t      u32 kvdl_index)\n{\n\treturn (kvdl_index - info->start_index) / info->alloc_size;\n}\n\nstatic int mlxsw_sp1_kvdl_part_alloc(struct mlxsw_sp1_kvdl_part *part,\n\t\t\t\t     u32 *p_kvdl_index)\n{\n\tconst struct mlxsw_sp1_kvdl_part_info *info = &part->info;\n\tunsigned int entry_index, nr_entries;\n\n\tnr_entries = (info->end_index - info->start_index + 1) /\n\t\t     info->alloc_size;\n\tentry_index = find_first_zero_bit(part->usage, nr_entries);\n\tif (entry_index == nr_entries)\n\t\treturn -ENOBUFS;\n\t__set_bit(entry_index, part->usage);\n\n\t*p_kvdl_index = mlxsw_sp1_kvdl_to_kvdl_index(info, entry_index);\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp1_kvdl_part_free(struct mlxsw_sp1_kvdl_part *part,\n\t\t\t\t     u32 kvdl_index)\n{\n\tconst struct mlxsw_sp1_kvdl_part_info *info = &part->info;\n\tunsigned int entry_index;\n\n\tentry_index = mlxsw_sp1_kvdl_to_entry_index(info, kvdl_index);\n\t__clear_bit(entry_index, part->usage);\n}\n\nstatic int mlxsw_sp1_kvdl_alloc(struct mlxsw_sp *mlxsw_sp, void *priv,\n\t\t\t\tenum mlxsw_sp_kvdl_entry_type type,\n\t\t\t\tunsigned int entry_count,\n\t\t\t\tu32 *p_entry_index)\n{\n\tstruct mlxsw_sp1_kvdl *kvdl = priv;\n\tstruct mlxsw_sp1_kvdl_part *part;\n\n\t \n\tpart = mlxsw_sp1_kvdl_alloc_size_part(kvdl, entry_count);\n\tif (IS_ERR(part))\n\t\treturn PTR_ERR(part);\n\n\treturn mlxsw_sp1_kvdl_part_alloc(part, p_entry_index);\n}\n\nstatic void mlxsw_sp1_kvdl_free(struct mlxsw_sp *mlxsw_sp, void *priv,\n\t\t\t\tenum mlxsw_sp_kvdl_entry_type type,\n\t\t\t\tunsigned int entry_count, int entry_index)\n{\n\tstruct mlxsw_sp1_kvdl *kvdl = priv;\n\tstruct mlxsw_sp1_kvdl_part *part;\n\n\tpart = mlxsw_sp1_kvdl_index_part(kvdl, entry_index);\n\tif (IS_ERR(part))\n\t\treturn;\n\tmlxsw_sp1_kvdl_part_free(part, entry_index);\n}\n\nstatic int mlxsw_sp1_kvdl_alloc_size_query(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   void *priv,\n\t\t\t\t\t   enum mlxsw_sp_kvdl_entry_type type,\n\t\t\t\t\t   unsigned int entry_count,\n\t\t\t\t\t   unsigned int *p_alloc_size)\n{\n\tstruct mlxsw_sp1_kvdl *kvdl = priv;\n\tstruct mlxsw_sp1_kvdl_part *part;\n\n\tpart = mlxsw_sp1_kvdl_alloc_size_part(kvdl, entry_count);\n\tif (IS_ERR(part))\n\t\treturn PTR_ERR(part);\n\n\t*p_alloc_size = part->info.alloc_size;\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp1_kvdl_part_update(struct mlxsw_sp1_kvdl_part *part,\n\t\t\t\t       struct mlxsw_sp1_kvdl_part *part_prev,\n\t\t\t\t       unsigned int size)\n{\n\tif (!part_prev) {\n\t\tpart->info.end_index = size - 1;\n\t} else {\n\t\tpart->info.start_index = part_prev->info.end_index + 1;\n\t\tpart->info.end_index = part->info.start_index + size - 1;\n\t}\n}\n\nstatic struct mlxsw_sp1_kvdl_part *\nmlxsw_sp1_kvdl_part_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t const struct mlxsw_sp1_kvdl_part_info *info,\n\t\t\t struct mlxsw_sp1_kvdl_part *part_prev)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tstruct mlxsw_sp1_kvdl_part *part;\n\tbool need_update = true;\n\tunsigned int nr_entries;\n\tu64 resource_size;\n\tint err;\n\n\terr = devl_resource_size_get(devlink, info->resource_id,\n\t\t\t\t     &resource_size);\n\tif (err) {\n\t\tneed_update = false;\n\t\tresource_size = info->end_index - info->start_index + 1;\n\t}\n\n\tnr_entries = div_u64(resource_size, info->alloc_size);\n\tpart = kzalloc(struct_size(part, usage, BITS_TO_LONGS(nr_entries)),\n\t\t       GFP_KERNEL);\n\tif (!part)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(&part->info, info, sizeof(part->info));\n\n\tif (need_update)\n\t\tmlxsw_sp1_kvdl_part_update(part, part_prev, resource_size);\n\treturn part;\n}\n\nstatic void mlxsw_sp1_kvdl_part_fini(struct mlxsw_sp1_kvdl_part *part)\n{\n\tkfree(part);\n}\n\nstatic int mlxsw_sp1_kvdl_parts_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp1_kvdl *kvdl)\n{\n\tconst struct mlxsw_sp1_kvdl_part_info *info;\n\tstruct mlxsw_sp1_kvdl_part *part_prev = NULL;\n\tint err, i;\n\n\tfor (i = 0; i < MLXSW_SP1_KVDL_PARTS_INFO_LEN; i++) {\n\t\tinfo = &mlxsw_sp1_kvdl_parts_info[i];\n\t\tkvdl->parts[i] = mlxsw_sp1_kvdl_part_init(mlxsw_sp, info,\n\t\t\t\t\t\t\t  part_prev);\n\t\tif (IS_ERR(kvdl->parts[i])) {\n\t\t\terr = PTR_ERR(kvdl->parts[i]);\n\t\t\tgoto err_kvdl_part_init;\n\t\t}\n\t\tpart_prev = kvdl->parts[i];\n\t}\n\treturn 0;\n\nerr_kvdl_part_init:\n\tfor (i--; i >= 0; i--)\n\t\tmlxsw_sp1_kvdl_part_fini(kvdl->parts[i]);\n\treturn err;\n}\n\nstatic void mlxsw_sp1_kvdl_parts_fini(struct mlxsw_sp1_kvdl *kvdl)\n{\n\tint i;\n\n\tfor (i = 0; i < MLXSW_SP1_KVDL_PARTS_INFO_LEN; i++)\n\t\tmlxsw_sp1_kvdl_part_fini(kvdl->parts[i]);\n}\n\nstatic u64 mlxsw_sp1_kvdl_part_occ(struct mlxsw_sp1_kvdl_part *part)\n{\n\tconst struct mlxsw_sp1_kvdl_part_info *info = &part->info;\n\tunsigned int nr_entries;\n\tint bit = -1;\n\tu64 occ = 0;\n\n\tnr_entries = (info->end_index -\n\t\t      info->start_index + 1) /\n\t\t      info->alloc_size;\n\twhile ((bit = find_next_bit(part->usage, nr_entries, bit + 1))\n\t\t< nr_entries)\n\t\tocc += info->alloc_size;\n\treturn occ;\n}\n\nstatic u64 mlxsw_sp1_kvdl_occ_get(void *priv)\n{\n\tconst struct mlxsw_sp1_kvdl *kvdl = priv;\n\tu64 occ = 0;\n\tint i;\n\n\tfor (i = 0; i < MLXSW_SP1_KVDL_PARTS_INFO_LEN; i++)\n\t\tocc += mlxsw_sp1_kvdl_part_occ(kvdl->parts[i]);\n\n\treturn occ;\n}\n\nstatic u64 mlxsw_sp1_kvdl_single_occ_get(void *priv)\n{\n\tconst struct mlxsw_sp1_kvdl *kvdl = priv;\n\tstruct mlxsw_sp1_kvdl_part *part;\n\n\tpart = kvdl->parts[MLXSW_SP1_KVDL_PART_ID_SINGLE];\n\treturn mlxsw_sp1_kvdl_part_occ(part);\n}\n\nstatic u64 mlxsw_sp1_kvdl_chunks_occ_get(void *priv)\n{\n\tconst struct mlxsw_sp1_kvdl *kvdl = priv;\n\tstruct mlxsw_sp1_kvdl_part *part;\n\n\tpart = kvdl->parts[MLXSW_SP1_KVDL_PART_ID_CHUNKS];\n\treturn mlxsw_sp1_kvdl_part_occ(part);\n}\n\nstatic u64 mlxsw_sp1_kvdl_large_chunks_occ_get(void *priv)\n{\n\tconst struct mlxsw_sp1_kvdl *kvdl = priv;\n\tstruct mlxsw_sp1_kvdl_part *part;\n\n\tpart = kvdl->parts[MLXSW_SP1_KVDL_PART_ID_LARGE_CHUNKS];\n\treturn mlxsw_sp1_kvdl_part_occ(part);\n}\n\nstatic int mlxsw_sp1_kvdl_init(struct mlxsw_sp *mlxsw_sp, void *priv)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tstruct mlxsw_sp1_kvdl *kvdl = priv;\n\tint err;\n\n\terr = mlxsw_sp1_kvdl_parts_init(mlxsw_sp, kvdl);\n\tif (err)\n\t\treturn err;\n\tdevl_resource_occ_get_register(devlink,\n\t\t\t\t       MLXSW_SP_RESOURCE_KVD_LINEAR,\n\t\t\t\t       mlxsw_sp1_kvdl_occ_get,\n\t\t\t\t       kvdl);\n\tdevl_resource_occ_get_register(devlink,\n\t\t\t\t       MLXSW_SP_RESOURCE_KVD_LINEAR_SINGLE,\n\t\t\t\t       mlxsw_sp1_kvdl_single_occ_get,\n\t\t\t\t       kvdl);\n\tdevl_resource_occ_get_register(devlink,\n\t\t\t\t       MLXSW_SP_RESOURCE_KVD_LINEAR_CHUNKS,\n\t\t\t\t       mlxsw_sp1_kvdl_chunks_occ_get,\n\t\t\t\t       kvdl);\n\tdevl_resource_occ_get_register(devlink,\n\t\t\t\t       MLXSW_SP_RESOURCE_KVD_LINEAR_LARGE_CHUNKS,\n\t\t\t\t       mlxsw_sp1_kvdl_large_chunks_occ_get,\n\t\t\t\t       kvdl);\n\treturn 0;\n}\n\nstatic void mlxsw_sp1_kvdl_fini(struct mlxsw_sp *mlxsw_sp, void *priv)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tstruct mlxsw_sp1_kvdl *kvdl = priv;\n\n\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t MLXSW_SP_RESOURCE_KVD_LINEAR_LARGE_CHUNKS);\n\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t MLXSW_SP_RESOURCE_KVD_LINEAR_CHUNKS);\n\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t MLXSW_SP_RESOURCE_KVD_LINEAR_SINGLE);\n\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t MLXSW_SP_RESOURCE_KVD_LINEAR);\n\tmlxsw_sp1_kvdl_parts_fini(kvdl);\n}\n\nconst struct mlxsw_sp_kvdl_ops mlxsw_sp1_kvdl_ops = {\n\t.priv_size = sizeof(struct mlxsw_sp1_kvdl),\n\t.init = mlxsw_sp1_kvdl_init,\n\t.fini = mlxsw_sp1_kvdl_fini,\n\t.alloc = mlxsw_sp1_kvdl_alloc,\n\t.free = mlxsw_sp1_kvdl_free,\n\t.alloc_size_query = mlxsw_sp1_kvdl_alloc_size_query,\n};\n\nint mlxsw_sp1_kvdl_resources_register(struct mlxsw_core *mlxsw_core)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tstatic struct devlink_resource_size_params size_params;\n\tu32 kvdl_max_size;\n\tint err;\n\n\tkvdl_max_size = MLXSW_CORE_RES_GET(mlxsw_core, KVD_SIZE) -\n\t\t\tMLXSW_CORE_RES_GET(mlxsw_core, KVD_SINGLE_MIN_SIZE) -\n\t\t\tMLXSW_CORE_RES_GET(mlxsw_core, KVD_DOUBLE_MIN_SIZE);\n\n\tdevlink_resource_size_params_init(&size_params, 0, kvdl_max_size,\n\t\t\t\t\t  MLXSW_SP1_KVDL_SINGLE_ALLOC_SIZE,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\terr = devl_resource_register(devlink, MLXSW_SP_RESOURCE_NAME_KVD_LINEAR_SINGLES,\n\t\t\t\t     MLXSW_SP1_KVDL_SINGLE_SIZE,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD_LINEAR_SINGLE,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD_LINEAR,\n\t\t\t\t     &size_params);\n\tif (err)\n\t\treturn err;\n\n\tdevlink_resource_size_params_init(&size_params, 0, kvdl_max_size,\n\t\t\t\t\t  MLXSW_SP1_KVDL_CHUNKS_ALLOC_SIZE,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\terr = devl_resource_register(devlink, MLXSW_SP_RESOURCE_NAME_KVD_LINEAR_CHUNKS,\n\t\t\t\t     MLXSW_SP1_KVDL_CHUNKS_SIZE,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD_LINEAR_CHUNKS,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD_LINEAR,\n\t\t\t\t     &size_params);\n\tif (err)\n\t\treturn err;\n\n\tdevlink_resource_size_params_init(&size_params, 0, kvdl_max_size,\n\t\t\t\t\t  MLXSW_SP1_KVDL_LARGE_CHUNKS_ALLOC_SIZE,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\terr = devl_resource_register(devlink, MLXSW_SP_RESOURCE_NAME_KVD_LINEAR_LARGE_CHUNKS,\n\t\t\t\t     MLXSW_SP1_KVDL_LARGE_CHUNKS_SIZE,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD_LINEAR_LARGE_CHUNKS,\n\t\t\t\t     MLXSW_SP_RESOURCE_KVD_LINEAR,\n\t\t\t\t     &size_params);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}