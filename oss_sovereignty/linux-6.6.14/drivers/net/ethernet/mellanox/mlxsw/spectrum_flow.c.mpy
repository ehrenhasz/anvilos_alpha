{
  "module_name": "spectrum_flow.c",
  "hash_id": "524b458cd066dc6f5131c8be19de39ae1e216563e1136bdb20cd3ccbcf2e7543",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_flow.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <net/net_namespace.h>\n\n#include \"spectrum.h\"\n\nstruct mlxsw_sp_flow_block *\nmlxsw_sp_flow_block_create(struct mlxsw_sp *mlxsw_sp, struct net *net)\n{\n\tstruct mlxsw_sp_flow_block *block;\n\n\tblock = kzalloc(sizeof(*block), GFP_KERNEL);\n\tif (!block)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&block->binding_list);\n\tINIT_LIST_HEAD(&block->mall.list);\n\tblock->mlxsw_sp = mlxsw_sp;\n\tblock->net = net;\n\treturn block;\n}\n\nvoid mlxsw_sp_flow_block_destroy(struct mlxsw_sp_flow_block *block)\n{\n\tWARN_ON(!list_empty(&block->binding_list));\n\tkfree(block);\n}\n\nstatic struct mlxsw_sp_flow_block_binding *\nmlxsw_sp_flow_block_lookup(struct mlxsw_sp_flow_block *block,\n\t\t\t   struct mlxsw_sp_port *mlxsw_sp_port, bool ingress)\n{\n\tstruct mlxsw_sp_flow_block_binding *binding;\n\n\tlist_for_each_entry(binding, &block->binding_list, list)\n\t\tif (binding->mlxsw_sp_port == mlxsw_sp_port &&\n\t\t    binding->ingress == ingress)\n\t\t\treturn binding;\n\treturn NULL;\n}\n\nstatic bool\nmlxsw_sp_flow_block_ruleset_bound(const struct mlxsw_sp_flow_block *block)\n{\n\treturn block->ruleset_zero;\n}\n\nstatic int mlxsw_sp_flow_block_bind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_flow_block *block,\n\t\t\t\t    struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    bool ingress,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_flow_block_binding *binding;\n\tint err;\n\n\tif (WARN_ON(mlxsw_sp_flow_block_lookup(block, mlxsw_sp_port, ingress)))\n\t\treturn -EEXIST;\n\n\tif (ingress && block->ingress_blocker_rule_count) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Block cannot be bound to ingress because it contains unsupported rules\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!ingress && block->egress_blocker_rule_count) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Block cannot be bound to egress because it contains unsupported rules\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = mlxsw_sp_mall_port_bind(block, mlxsw_sp_port, extack);\n\tif (err)\n\t\treturn err;\n\n\tbinding = kzalloc(sizeof(*binding), GFP_KERNEL);\n\tif (!binding) {\n\t\terr = -ENOMEM;\n\t\tgoto err_binding_alloc;\n\t}\n\tbinding->mlxsw_sp_port = mlxsw_sp_port;\n\tbinding->ingress = ingress;\n\n\tif (mlxsw_sp_flow_block_ruleset_bound(block)) {\n\t\terr = mlxsw_sp_acl_ruleset_bind(mlxsw_sp, block, binding);\n\t\tif (err)\n\t\t\tgoto err_ruleset_bind;\n\t}\n\n\tif (ingress)\n\t\tblock->ingress_binding_count++;\n\telse\n\t\tblock->egress_binding_count++;\n\tlist_add(&binding->list, &block->binding_list);\n\treturn 0;\n\nerr_ruleset_bind:\n\tkfree(binding);\nerr_binding_alloc:\n\tmlxsw_sp_mall_port_unbind(block, mlxsw_sp_port);\n\n\treturn err;\n}\n\nstatic int mlxsw_sp_flow_block_unbind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct mlxsw_sp_flow_block *block,\n\t\t\t\t      struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      bool ingress)\n{\n\tstruct mlxsw_sp_flow_block_binding *binding;\n\n\tbinding = mlxsw_sp_flow_block_lookup(block, mlxsw_sp_port, ingress);\n\tif (!binding)\n\t\treturn -ENOENT;\n\n\tlist_del(&binding->list);\n\n\tif (ingress)\n\t\tblock->ingress_binding_count--;\n\telse\n\t\tblock->egress_binding_count--;\n\n\tif (mlxsw_sp_flow_block_ruleset_bound(block))\n\t\tmlxsw_sp_acl_ruleset_unbind(mlxsw_sp, block, binding);\n\n\tkfree(binding);\n\n\tmlxsw_sp_mall_port_unbind(block, mlxsw_sp_port);\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_flow_block_mall_cb(struct mlxsw_sp_flow_block *flow_block,\n\t\t\t\t       struct tc_cls_matchall_offload *f)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_flow_block_mlxsw_sp(flow_block);\n\n\tswitch (f->command) {\n\tcase TC_CLSMATCHALL_REPLACE:\n\t\treturn mlxsw_sp_mall_replace(mlxsw_sp, flow_block, f);\n\tcase TC_CLSMATCHALL_DESTROY:\n\t\tmlxsw_sp_mall_destroy(flow_block, f);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int mlxsw_sp_flow_block_flower_cb(struct mlxsw_sp_flow_block *flow_block,\n\t\t\t\t\t struct flow_cls_offload *f)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_flow_block_mlxsw_sp(flow_block);\n\n\tswitch (f->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn mlxsw_sp_flower_replace(mlxsw_sp, flow_block, f);\n\tcase FLOW_CLS_DESTROY:\n\t\tmlxsw_sp_flower_destroy(mlxsw_sp, flow_block, f);\n\t\treturn 0;\n\tcase FLOW_CLS_STATS:\n\t\treturn mlxsw_sp_flower_stats(mlxsw_sp, flow_block, f);\n\tcase FLOW_CLS_TMPLT_CREATE:\n\t\treturn mlxsw_sp_flower_tmplt_create(mlxsw_sp, flow_block, f);\n\tcase FLOW_CLS_TMPLT_DESTROY:\n\t\tmlxsw_sp_flower_tmplt_destroy(mlxsw_sp, flow_block, f);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int mlxsw_sp_flow_block_cb(enum tc_setup_type type,\n\t\t\t\t  void *type_data, void *cb_priv)\n{\n\tstruct mlxsw_sp_flow_block *flow_block = cb_priv;\n\n\tif (mlxsw_sp_flow_block_disabled(flow_block))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSMATCHALL:\n\t\treturn mlxsw_sp_flow_block_mall_cb(flow_block, type_data);\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn mlxsw_sp_flow_block_flower_cb(flow_block, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void mlxsw_sp_tc_block_release(void *cb_priv)\n{\n\tstruct mlxsw_sp_flow_block *flow_block = cb_priv;\n\n\tmlxsw_sp_flow_block_destroy(flow_block);\n}\n\nstatic LIST_HEAD(mlxsw_sp_block_cb_list);\n\nstatic int mlxsw_sp_setup_tc_block_bind(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\tstruct flow_block_offload *f,\n\t\t\t\t\tbool ingress)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_flow_block *flow_block;\n\tstruct flow_block_cb *block_cb;\n\tbool register_block = false;\n\tint err;\n\n\tblock_cb = flow_block_cb_lookup(f->block, mlxsw_sp_flow_block_cb,\n\t\t\t\t\tmlxsw_sp);\n\tif (!block_cb) {\n\t\tflow_block = mlxsw_sp_flow_block_create(mlxsw_sp, f->net);\n\t\tif (!flow_block)\n\t\t\treturn -ENOMEM;\n\t\tblock_cb = flow_block_cb_alloc(mlxsw_sp_flow_block_cb,\n\t\t\t\t\t       mlxsw_sp, flow_block,\n\t\t\t\t\t       mlxsw_sp_tc_block_release);\n\t\tif (IS_ERR(block_cb)) {\n\t\t\tmlxsw_sp_flow_block_destroy(flow_block);\n\t\t\treturn PTR_ERR(block_cb);\n\t\t}\n\t\tregister_block = true;\n\t} else {\n\t\tflow_block = flow_block_cb_priv(block_cb);\n\t}\n\tflow_block_cb_incref(block_cb);\n\terr = mlxsw_sp_flow_block_bind(mlxsw_sp, flow_block,\n\t\t\t\t       mlxsw_sp_port, ingress, f->extack);\n\tif (err)\n\t\tgoto err_block_bind;\n\n\tif (ingress)\n\t\tmlxsw_sp_port->ing_flow_block = flow_block;\n\telse\n\t\tmlxsw_sp_port->eg_flow_block = flow_block;\n\n\tif (register_block) {\n\t\tflow_block_cb_add(block_cb, f);\n\t\tlist_add_tail(&block_cb->driver_list, &mlxsw_sp_block_cb_list);\n\t}\n\n\treturn 0;\n\nerr_block_bind:\n\tif (!flow_block_cb_decref(block_cb))\n\t\tflow_block_cb_free(block_cb);\n\treturn err;\n}\n\nstatic void mlxsw_sp_setup_tc_block_unbind(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t   struct flow_block_offload *f,\n\t\t\t\t\t   bool ingress)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_flow_block *flow_block;\n\tstruct flow_block_cb *block_cb;\n\tint err;\n\n\tblock_cb = flow_block_cb_lookup(f->block, mlxsw_sp_flow_block_cb,\n\t\t\t\t\tmlxsw_sp);\n\tif (!block_cb)\n\t\treturn;\n\n\tif (ingress)\n\t\tmlxsw_sp_port->ing_flow_block = NULL;\n\telse\n\t\tmlxsw_sp_port->eg_flow_block = NULL;\n\n\tflow_block = flow_block_cb_priv(block_cb);\n\terr = mlxsw_sp_flow_block_unbind(mlxsw_sp, flow_block,\n\t\t\t\t\t mlxsw_sp_port, ingress);\n\tif (!err && !flow_block_cb_decref(block_cb)) {\n\t\tflow_block_cb_remove(block_cb, f);\n\t\tlist_del(&block_cb->driver_list);\n\t}\n}\n\nint mlxsw_sp_setup_tc_block_clsact(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t   struct flow_block_offload *f,\n\t\t\t\t   bool ingress)\n{\n\tf->driver_block_list = &mlxsw_sp_block_cb_list;\n\n\tswitch (f->command) {\n\tcase FLOW_BLOCK_BIND:\n\t\treturn mlxsw_sp_setup_tc_block_bind(mlxsw_sp_port, f, ingress);\n\tcase FLOW_BLOCK_UNBIND:\n\t\tmlxsw_sp_setup_tc_block_unbind(mlxsw_sp_port, f, ingress);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}