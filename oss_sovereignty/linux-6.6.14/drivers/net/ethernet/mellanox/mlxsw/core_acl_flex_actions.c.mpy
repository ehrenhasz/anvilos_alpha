{
  "module_name": "core_acl_flex_actions.c",
  "hash_id": "7ddd0b26459db8620b226294aacbf6edd977d96b94526ddf91be74c77ca4d5af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_actions.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/rhashtable.h>\n#include <linux/list.h>\n#include <linux/idr.h>\n#include <linux/refcount.h>\n#include <net/flow_offload.h>\n\n#include \"item.h\"\n#include \"trap.h\"\n#include \"core_acl_flex_actions.h\"\n\nenum mlxsw_afa_set_type {\n\tMLXSW_AFA_SET_TYPE_NEXT,\n\tMLXSW_AFA_SET_TYPE_GOTO,\n};\n\n \nMLXSW_ITEM32(afa, set, type, 0xA0, 28, 4);\n\n \nMLXSW_ITEM32(afa, set, next_action_set_ptr, 0xA4, 0, 24);\n\n \nMLXSW_ITEM32(afa, set, goto_g, 0xA4, 29, 1);\n\nenum mlxsw_afa_set_goto_binding_cmd {\n\t \n\tMLXSW_AFA_SET_GOTO_BINDING_CMD_NONE,\n\t \n\tMLXSW_AFA_SET_GOTO_BINDING_CMD_JUMP,\n\t \n\tMLXSW_AFA_SET_GOTO_BINDING_CMD_TERM = 4,\n};\n\n \nMLXSW_ITEM32(afa, set, goto_binding_cmd, 0xA4, 24, 3);\n\n \nMLXSW_ITEM32(afa, set, goto_next_binding, 0xA4, 0, 16);\n\n \nMLXSW_ITEM32(afa, all, action_type, 0x00, 24, 6);\n\nstruct mlxsw_afa {\n\tunsigned int max_acts_per_set;\n\tconst struct mlxsw_afa_ops *ops;\n\tvoid *ops_priv;\n\tstruct rhashtable set_ht;\n\tstruct rhashtable fwd_entry_ht;\n\tstruct rhashtable cookie_ht;\n\tstruct rhashtable policer_ht;\n\tstruct idr cookie_idr;\n\tstruct list_head policer_list;\n};\n\n#define MLXSW_AFA_SET_LEN 0xA8\n\nstruct mlxsw_afa_set_ht_key {\n\tchar enc_actions[MLXSW_AFA_SET_LEN];  \n\tbool is_first;\n};\n\n \n\nstruct mlxsw_afa_set {\n\tstruct rhash_head ht_node;\n\tstruct mlxsw_afa_set_ht_key ht_key;\n\tu32 kvdl_index;\n\tu8 shared:1,  \n\t   has_trap:1,\n\t   has_police:1;\n\tunsigned int ref_count;\n\tstruct mlxsw_afa_set *next;  \n\tstruct mlxsw_afa_set *prev;  \n};\n\nstatic const struct rhashtable_params mlxsw_afa_set_ht_params = {\n\t.key_len = sizeof(struct mlxsw_afa_set_ht_key),\n\t.key_offset = offsetof(struct mlxsw_afa_set, ht_key),\n\t.head_offset = offsetof(struct mlxsw_afa_set, ht_node),\n\t.automatic_shrinking = true,\n};\n\nstruct mlxsw_afa_fwd_entry_ht_key {\n\tu16 local_port;\n};\n\nstruct mlxsw_afa_fwd_entry {\n\tstruct rhash_head ht_node;\n\tstruct mlxsw_afa_fwd_entry_ht_key ht_key;\n\tu32 kvdl_index;\n\tunsigned int ref_count;\n};\n\nstatic const struct rhashtable_params mlxsw_afa_fwd_entry_ht_params = {\n\t.key_len = sizeof(struct mlxsw_afa_fwd_entry_ht_key),\n\t.key_offset = offsetof(struct mlxsw_afa_fwd_entry, ht_key),\n\t.head_offset = offsetof(struct mlxsw_afa_fwd_entry, ht_node),\n\t.automatic_shrinking = true,\n};\n\nstruct mlxsw_afa_cookie {\n\tstruct rhash_head ht_node;\n\trefcount_t ref_count;\n\tstruct rcu_head rcu;\n\tu32 cookie_index;\n\tstruct flow_action_cookie fa_cookie;\n};\n\nstatic u32 mlxsw_afa_cookie_hash(const struct flow_action_cookie *fa_cookie,\n\t\t\t\t u32 seed)\n{\n\treturn jhash2((u32 *) fa_cookie->cookie,\n\t\t      fa_cookie->cookie_len / sizeof(u32), seed);\n}\n\nstatic u32 mlxsw_afa_cookie_key_hashfn(const void *data, u32 len, u32 seed)\n{\n\tconst struct flow_action_cookie *fa_cookie = data;\n\n\treturn mlxsw_afa_cookie_hash(fa_cookie, seed);\n}\n\nstatic u32 mlxsw_afa_cookie_obj_hashfn(const void *data, u32 len, u32 seed)\n{\n\tconst struct mlxsw_afa_cookie *cookie = data;\n\n\treturn mlxsw_afa_cookie_hash(&cookie->fa_cookie, seed);\n}\n\nstatic int mlxsw_afa_cookie_obj_cmpfn(struct rhashtable_compare_arg *arg,\n\t\t\t\t      const void *obj)\n{\n\tconst struct flow_action_cookie *fa_cookie = arg->key;\n\tconst struct mlxsw_afa_cookie *cookie = obj;\n\n\tif (cookie->fa_cookie.cookie_len == fa_cookie->cookie_len)\n\t\treturn memcmp(cookie->fa_cookie.cookie, fa_cookie->cookie,\n\t\t\t      fa_cookie->cookie_len);\n\treturn 1;\n}\n\nstatic const struct rhashtable_params mlxsw_afa_cookie_ht_params = {\n\t.head_offset = offsetof(struct mlxsw_afa_cookie, ht_node),\n\t.hashfn\t= mlxsw_afa_cookie_key_hashfn,\n\t.obj_hashfn = mlxsw_afa_cookie_obj_hashfn,\n\t.obj_cmpfn = mlxsw_afa_cookie_obj_cmpfn,\n\t.automatic_shrinking = true,\n};\n\nstruct mlxsw_afa_policer {\n\tstruct rhash_head ht_node;\n\tstruct list_head list;  \n\trefcount_t ref_count;\n\tu32 fa_index;\n\tu16 policer_index;\n};\n\nstatic const struct rhashtable_params mlxsw_afa_policer_ht_params = {\n\t.key_len = sizeof(u32),\n\t.key_offset = offsetof(struct mlxsw_afa_policer, fa_index),\n\t.head_offset = offsetof(struct mlxsw_afa_policer, ht_node),\n\t.automatic_shrinking = true,\n};\n\nstruct mlxsw_afa *mlxsw_afa_create(unsigned int max_acts_per_set,\n\t\t\t\t   const struct mlxsw_afa_ops *ops,\n\t\t\t\t   void *ops_priv)\n{\n\tstruct mlxsw_afa *mlxsw_afa;\n\tint err;\n\n\tmlxsw_afa = kzalloc(sizeof(*mlxsw_afa), GFP_KERNEL);\n\tif (!mlxsw_afa)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = rhashtable_init(&mlxsw_afa->set_ht, &mlxsw_afa_set_ht_params);\n\tif (err)\n\t\tgoto err_set_rhashtable_init;\n\terr = rhashtable_init(&mlxsw_afa->fwd_entry_ht,\n\t\t\t      &mlxsw_afa_fwd_entry_ht_params);\n\tif (err)\n\t\tgoto err_fwd_entry_rhashtable_init;\n\terr = rhashtable_init(&mlxsw_afa->cookie_ht,\n\t\t\t      &mlxsw_afa_cookie_ht_params);\n\tif (err)\n\t\tgoto err_cookie_rhashtable_init;\n\terr = rhashtable_init(&mlxsw_afa->policer_ht,\n\t\t\t      &mlxsw_afa_policer_ht_params);\n\tif (err)\n\t\tgoto err_policer_rhashtable_init;\n\tidr_init(&mlxsw_afa->cookie_idr);\n\tINIT_LIST_HEAD(&mlxsw_afa->policer_list);\n\tmlxsw_afa->max_acts_per_set = max_acts_per_set;\n\tmlxsw_afa->ops = ops;\n\tmlxsw_afa->ops_priv = ops_priv;\n\treturn mlxsw_afa;\n\nerr_policer_rhashtable_init:\n\trhashtable_destroy(&mlxsw_afa->cookie_ht);\nerr_cookie_rhashtable_init:\n\trhashtable_destroy(&mlxsw_afa->fwd_entry_ht);\nerr_fwd_entry_rhashtable_init:\n\trhashtable_destroy(&mlxsw_afa->set_ht);\nerr_set_rhashtable_init:\n\tkfree(mlxsw_afa);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(mlxsw_afa_create);\n\nvoid mlxsw_afa_destroy(struct mlxsw_afa *mlxsw_afa)\n{\n\tWARN_ON(!list_empty(&mlxsw_afa->policer_list));\n\tWARN_ON(!idr_is_empty(&mlxsw_afa->cookie_idr));\n\tidr_destroy(&mlxsw_afa->cookie_idr);\n\trhashtable_destroy(&mlxsw_afa->policer_ht);\n\trhashtable_destroy(&mlxsw_afa->cookie_ht);\n\trhashtable_destroy(&mlxsw_afa->fwd_entry_ht);\n\trhashtable_destroy(&mlxsw_afa->set_ht);\n\tkfree(mlxsw_afa);\n}\nEXPORT_SYMBOL(mlxsw_afa_destroy);\n\nstatic void mlxsw_afa_set_goto_set(struct mlxsw_afa_set *set,\n\t\t\t\t   enum mlxsw_afa_set_goto_binding_cmd cmd,\n\t\t\t\t   u16 group_id)\n{\n\tchar *actions = set->ht_key.enc_actions;\n\n\tmlxsw_afa_set_type_set(actions, MLXSW_AFA_SET_TYPE_GOTO);\n\tmlxsw_afa_set_goto_g_set(actions, true);\n\tmlxsw_afa_set_goto_binding_cmd_set(actions, cmd);\n\tmlxsw_afa_set_goto_next_binding_set(actions, group_id);\n}\n\nstatic void mlxsw_afa_set_next_set(struct mlxsw_afa_set *set,\n\t\t\t\t   u32 next_set_kvdl_index)\n{\n\tchar *actions = set->ht_key.enc_actions;\n\n\tmlxsw_afa_set_type_set(actions, MLXSW_AFA_SET_TYPE_NEXT);\n\tmlxsw_afa_set_next_action_set_ptr_set(actions, next_set_kvdl_index);\n}\n\nstatic struct mlxsw_afa_set *mlxsw_afa_set_create(bool is_first)\n{\n\tstruct mlxsw_afa_set *set;\n\n\tset = kzalloc(sizeof(*set), GFP_KERNEL);\n\tif (!set)\n\t\treturn NULL;\n\t \n\tmlxsw_afa_set_goto_set(set, MLXSW_AFA_SET_GOTO_BINDING_CMD_TERM, 0);\n\tset->ht_key.is_first = is_first;\n\tset->ref_count = 1;\n\treturn set;\n}\n\nstatic void mlxsw_afa_set_destroy(struct mlxsw_afa_set *set)\n{\n\tkfree(set);\n}\n\nstatic int mlxsw_afa_set_share(struct mlxsw_afa *mlxsw_afa,\n\t\t\t       struct mlxsw_afa_set *set)\n{\n\tint err;\n\n\terr = rhashtable_insert_fast(&mlxsw_afa->set_ht, &set->ht_node,\n\t\t\t\t     mlxsw_afa_set_ht_params);\n\tif (err)\n\t\treturn err;\n\terr = mlxsw_afa->ops->kvdl_set_add(mlxsw_afa->ops_priv,\n\t\t\t\t\t   &set->kvdl_index,\n\t\t\t\t\t   set->ht_key.enc_actions,\n\t\t\t\t\t   set->ht_key.is_first);\n\tif (err)\n\t\tgoto err_kvdl_set_add;\n\tset->shared = true;\n\tset->prev = NULL;\n\treturn 0;\n\nerr_kvdl_set_add:\n\trhashtable_remove_fast(&mlxsw_afa->set_ht, &set->ht_node,\n\t\t\t       mlxsw_afa_set_ht_params);\n\treturn err;\n}\n\nstatic void mlxsw_afa_set_unshare(struct mlxsw_afa *mlxsw_afa,\n\t\t\t\t  struct mlxsw_afa_set *set)\n{\n\tmlxsw_afa->ops->kvdl_set_del(mlxsw_afa->ops_priv,\n\t\t\t\t     set->kvdl_index,\n\t\t\t\t     set->ht_key.is_first);\n\trhashtable_remove_fast(&mlxsw_afa->set_ht, &set->ht_node,\n\t\t\t       mlxsw_afa_set_ht_params);\n\tset->shared = false;\n}\n\nstatic void mlxsw_afa_set_put(struct mlxsw_afa *mlxsw_afa,\n\t\t\t      struct mlxsw_afa_set *set)\n{\n\tif (--set->ref_count)\n\t\treturn;\n\tif (set->shared)\n\t\tmlxsw_afa_set_unshare(mlxsw_afa, set);\n\tmlxsw_afa_set_destroy(set);\n}\n\nstatic struct mlxsw_afa_set *mlxsw_afa_set_get(struct mlxsw_afa *mlxsw_afa,\n\t\t\t\t\t       struct mlxsw_afa_set *orig_set)\n{\n\tstruct mlxsw_afa_set *set;\n\tint err;\n\n\t \n\tset = rhashtable_lookup_fast(&mlxsw_afa->set_ht, &orig_set->ht_key,\n\t\t\t\t     mlxsw_afa_set_ht_params);\n\tif (set) {\n\t\tset->ref_count++;\n\t\tmlxsw_afa_set_put(mlxsw_afa, orig_set);\n\t} else {\n\t\tset = orig_set;\n\t\terr = mlxsw_afa_set_share(mlxsw_afa, set);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn set;\n}\n\n \n\nstruct mlxsw_afa_block {\n\tstruct mlxsw_afa *afa;\n\tbool finished;\n\tstruct mlxsw_afa_set *first_set;\n\tstruct mlxsw_afa_set *cur_set;\n\tunsigned int cur_act_index;  \n\tstruct list_head resource_list;  \n};\n\nstruct mlxsw_afa_resource {\n\tstruct list_head list;\n\tvoid (*destructor)(struct mlxsw_afa_block *block,\n\t\t\t   struct mlxsw_afa_resource *resource);\n};\n\nstatic void mlxsw_afa_resource_add(struct mlxsw_afa_block *block,\n\t\t\t\t   struct mlxsw_afa_resource *resource)\n{\n\tlist_add(&resource->list, &block->resource_list);\n}\n\nstatic void mlxsw_afa_resource_del(struct mlxsw_afa_resource *resource)\n{\n\tlist_del(&resource->list);\n}\n\nstatic void mlxsw_afa_resources_destroy(struct mlxsw_afa_block *block)\n{\n\tstruct mlxsw_afa_resource *resource, *tmp;\n\n\tlist_for_each_entry_safe(resource, tmp, &block->resource_list, list) {\n\t\tresource->destructor(block, resource);\n\t}\n}\n\nstruct mlxsw_afa_block *mlxsw_afa_block_create(struct mlxsw_afa *mlxsw_afa)\n{\n\tstruct mlxsw_afa_block *block;\n\n\tblock = kzalloc(sizeof(*block), GFP_KERNEL);\n\tif (!block)\n\t\treturn ERR_PTR(-ENOMEM);\n\tINIT_LIST_HEAD(&block->resource_list);\n\tblock->afa = mlxsw_afa;\n\n\t \n\tblock->first_set = mlxsw_afa_set_create(true);\n\tif (!block->first_set)\n\t\tgoto err_first_set_create;\n\n\t \n\tif (mlxsw_afa->ops->dummy_first_set) {\n\t\tblock->cur_set = mlxsw_afa_set_create(false);\n\t\tif (!block->cur_set)\n\t\t\tgoto err_second_set_create;\n\t\tblock->cur_set->prev = block->first_set;\n\t\tblock->first_set->next = block->cur_set;\n\t} else {\n\t\tblock->cur_set = block->first_set;\n\t}\n\n\treturn block;\n\nerr_second_set_create:\n\tmlxsw_afa_set_destroy(block->first_set);\nerr_first_set_create:\n\tkfree(block);\n\treturn ERR_PTR(-ENOMEM);\n}\nEXPORT_SYMBOL(mlxsw_afa_block_create);\n\nvoid mlxsw_afa_block_destroy(struct mlxsw_afa_block *block)\n{\n\tstruct mlxsw_afa_set *set = block->first_set;\n\tstruct mlxsw_afa_set *next_set;\n\n\tdo {\n\t\tnext_set = set->next;\n\t\tmlxsw_afa_set_put(block->afa, set);\n\t\tset = next_set;\n\t} while (set);\n\tmlxsw_afa_resources_destroy(block);\n\tkfree(block);\n}\nEXPORT_SYMBOL(mlxsw_afa_block_destroy);\n\nint mlxsw_afa_block_commit(struct mlxsw_afa_block *block)\n{\n\tstruct mlxsw_afa_set *set = block->cur_set;\n\tstruct mlxsw_afa_set *prev_set;\n\n\tblock->cur_set = NULL;\n\tblock->finished = true;\n\n\t \n\tdo {\n\t\tprev_set = set->prev;\n\t\tset = mlxsw_afa_set_get(block->afa, set);\n\t\tif (IS_ERR(set))\n\t\t\t \n\t\t\treturn PTR_ERR(set);\n\t\tif (prev_set) {\n\t\t\tprev_set->next = set;\n\t\t\tmlxsw_afa_set_next_set(prev_set, set->kvdl_index);\n\t\t\tset = prev_set;\n\t\t}\n\t} while (prev_set);\n\n\tblock->first_set = set;\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_commit);\n\nchar *mlxsw_afa_block_first_set(struct mlxsw_afa_block *block)\n{\n\treturn block->first_set->ht_key.enc_actions;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_first_set);\n\nchar *mlxsw_afa_block_cur_set(struct mlxsw_afa_block *block)\n{\n\treturn block->cur_set->ht_key.enc_actions;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_cur_set);\n\nu32 mlxsw_afa_block_first_kvdl_index(struct mlxsw_afa_block *block)\n{\n\t \n\tif (WARN_ON(!block->first_set->next))\n\t\treturn 0;\n\treturn block->first_set->next->kvdl_index;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_first_kvdl_index);\n\nint mlxsw_afa_block_activity_get(struct mlxsw_afa_block *block, bool *activity)\n{\n\tu32 kvdl_index = mlxsw_afa_block_first_kvdl_index(block);\n\n\treturn block->afa->ops->kvdl_set_activity_get(block->afa->ops_priv,\n\t\t\t\t\t\t      kvdl_index, activity);\n}\nEXPORT_SYMBOL(mlxsw_afa_block_activity_get);\n\nint mlxsw_afa_block_continue(struct mlxsw_afa_block *block)\n{\n\tif (block->finished)\n\t\treturn -EINVAL;\n\tmlxsw_afa_set_goto_set(block->cur_set,\n\t\t\t       MLXSW_AFA_SET_GOTO_BINDING_CMD_NONE, 0);\n\tblock->finished = true;\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_continue);\n\nint mlxsw_afa_block_jump(struct mlxsw_afa_block *block, u16 group_id)\n{\n\tif (block->finished)\n\t\treturn -EINVAL;\n\tmlxsw_afa_set_goto_set(block->cur_set,\n\t\t\t       MLXSW_AFA_SET_GOTO_BINDING_CMD_JUMP, group_id);\n\tblock->finished = true;\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_jump);\n\nint mlxsw_afa_block_terminate(struct mlxsw_afa_block *block)\n{\n\tif (block->finished)\n\t\treturn -EINVAL;\n\tmlxsw_afa_set_goto_set(block->cur_set,\n\t\t\t       MLXSW_AFA_SET_GOTO_BINDING_CMD_TERM, 0);\n\tblock->finished = true;\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_terminate);\n\nstatic struct mlxsw_afa_fwd_entry *\nmlxsw_afa_fwd_entry_create(struct mlxsw_afa *mlxsw_afa, u16 local_port)\n{\n\tstruct mlxsw_afa_fwd_entry *fwd_entry;\n\tint err;\n\n\tfwd_entry = kzalloc(sizeof(*fwd_entry), GFP_KERNEL);\n\tif (!fwd_entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfwd_entry->ht_key.local_port = local_port;\n\tfwd_entry->ref_count = 1;\n\n\terr = rhashtable_insert_fast(&mlxsw_afa->fwd_entry_ht,\n\t\t\t\t     &fwd_entry->ht_node,\n\t\t\t\t     mlxsw_afa_fwd_entry_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_insert;\n\n\terr = mlxsw_afa->ops->kvdl_fwd_entry_add(mlxsw_afa->ops_priv,\n\t\t\t\t\t\t &fwd_entry->kvdl_index,\n\t\t\t\t\t\t local_port);\n\tif (err)\n\t\tgoto err_kvdl_fwd_entry_add;\n\treturn fwd_entry;\n\nerr_kvdl_fwd_entry_add:\n\trhashtable_remove_fast(&mlxsw_afa->fwd_entry_ht, &fwd_entry->ht_node,\n\t\t\t       mlxsw_afa_fwd_entry_ht_params);\nerr_rhashtable_insert:\n\tkfree(fwd_entry);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_afa_fwd_entry_destroy(struct mlxsw_afa *mlxsw_afa,\n\t\t\t\t\tstruct mlxsw_afa_fwd_entry *fwd_entry)\n{\n\tmlxsw_afa->ops->kvdl_fwd_entry_del(mlxsw_afa->ops_priv,\n\t\t\t\t\t   fwd_entry->kvdl_index);\n\trhashtable_remove_fast(&mlxsw_afa->fwd_entry_ht, &fwd_entry->ht_node,\n\t\t\t       mlxsw_afa_fwd_entry_ht_params);\n\tkfree(fwd_entry);\n}\n\nstatic struct mlxsw_afa_fwd_entry *\nmlxsw_afa_fwd_entry_get(struct mlxsw_afa *mlxsw_afa, u16 local_port)\n{\n\tstruct mlxsw_afa_fwd_entry_ht_key ht_key = {0};\n\tstruct mlxsw_afa_fwd_entry *fwd_entry;\n\n\tht_key.local_port = local_port;\n\tfwd_entry = rhashtable_lookup_fast(&mlxsw_afa->fwd_entry_ht, &ht_key,\n\t\t\t\t\t   mlxsw_afa_fwd_entry_ht_params);\n\tif (fwd_entry) {\n\t\tfwd_entry->ref_count++;\n\t\treturn fwd_entry;\n\t}\n\treturn mlxsw_afa_fwd_entry_create(mlxsw_afa, local_port);\n}\n\nstatic void mlxsw_afa_fwd_entry_put(struct mlxsw_afa *mlxsw_afa,\n\t\t\t\t    struct mlxsw_afa_fwd_entry *fwd_entry)\n{\n\tif (--fwd_entry->ref_count)\n\t\treturn;\n\tmlxsw_afa_fwd_entry_destroy(mlxsw_afa, fwd_entry);\n}\n\nstruct mlxsw_afa_fwd_entry_ref {\n\tstruct mlxsw_afa_resource resource;\n\tstruct mlxsw_afa_fwd_entry *fwd_entry;\n};\n\nstatic void\nmlxsw_afa_fwd_entry_ref_destroy(struct mlxsw_afa_block *block,\n\t\t\t\tstruct mlxsw_afa_fwd_entry_ref *fwd_entry_ref)\n{\n\tmlxsw_afa_resource_del(&fwd_entry_ref->resource);\n\tmlxsw_afa_fwd_entry_put(block->afa, fwd_entry_ref->fwd_entry);\n\tkfree(fwd_entry_ref);\n}\n\nstatic void\nmlxsw_afa_fwd_entry_ref_destructor(struct mlxsw_afa_block *block,\n\t\t\t\t   struct mlxsw_afa_resource *resource)\n{\n\tstruct mlxsw_afa_fwd_entry_ref *fwd_entry_ref;\n\n\tfwd_entry_ref = container_of(resource, struct mlxsw_afa_fwd_entry_ref,\n\t\t\t\t     resource);\n\tmlxsw_afa_fwd_entry_ref_destroy(block, fwd_entry_ref);\n}\n\nstatic struct mlxsw_afa_fwd_entry_ref *\nmlxsw_afa_fwd_entry_ref_create(struct mlxsw_afa_block *block, u16 local_port)\n{\n\tstruct mlxsw_afa_fwd_entry_ref *fwd_entry_ref;\n\tstruct mlxsw_afa_fwd_entry *fwd_entry;\n\tint err;\n\n\tfwd_entry_ref = kzalloc(sizeof(*fwd_entry_ref), GFP_KERNEL);\n\tif (!fwd_entry_ref)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfwd_entry = mlxsw_afa_fwd_entry_get(block->afa, local_port);\n\tif (IS_ERR(fwd_entry)) {\n\t\terr = PTR_ERR(fwd_entry);\n\t\tgoto err_fwd_entry_get;\n\t}\n\tfwd_entry_ref->fwd_entry = fwd_entry;\n\tfwd_entry_ref->resource.destructor = mlxsw_afa_fwd_entry_ref_destructor;\n\tmlxsw_afa_resource_add(block, &fwd_entry_ref->resource);\n\treturn fwd_entry_ref;\n\nerr_fwd_entry_get:\n\tkfree(fwd_entry_ref);\n\treturn ERR_PTR(err);\n}\n\nstruct mlxsw_afa_counter {\n\tstruct mlxsw_afa_resource resource;\n\tu32 counter_index;\n};\n\nstatic void\nmlxsw_afa_counter_destroy(struct mlxsw_afa_block *block,\n\t\t\t  struct mlxsw_afa_counter *counter)\n{\n\tmlxsw_afa_resource_del(&counter->resource);\n\tblock->afa->ops->counter_index_put(block->afa->ops_priv,\n\t\t\t\t\t   counter->counter_index);\n\tkfree(counter);\n}\n\nstatic void\nmlxsw_afa_counter_destructor(struct mlxsw_afa_block *block,\n\t\t\t     struct mlxsw_afa_resource *resource)\n{\n\tstruct mlxsw_afa_counter *counter;\n\n\tcounter = container_of(resource, struct mlxsw_afa_counter, resource);\n\tmlxsw_afa_counter_destroy(block, counter);\n}\n\nstatic struct mlxsw_afa_counter *\nmlxsw_afa_counter_create(struct mlxsw_afa_block *block)\n{\n\tstruct mlxsw_afa_counter *counter;\n\tint err;\n\n\tcounter = kzalloc(sizeof(*counter), GFP_KERNEL);\n\tif (!counter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = block->afa->ops->counter_index_get(block->afa->ops_priv,\n\t\t\t\t\t\t &counter->counter_index);\n\tif (err)\n\t\tgoto err_counter_index_get;\n\tcounter->resource.destructor = mlxsw_afa_counter_destructor;\n\tmlxsw_afa_resource_add(block, &counter->resource);\n\treturn counter;\n\nerr_counter_index_get:\n\tkfree(counter);\n\treturn ERR_PTR(err);\n}\n\n \n#define MLXSW_AFA_COOKIE_INDEX_BITS 20\n#define MLXSW_AFA_COOKIE_INDEX_MAX ((1 << MLXSW_AFA_COOKIE_INDEX_BITS) - 1)\n\nstatic struct mlxsw_afa_cookie *\nmlxsw_afa_cookie_create(struct mlxsw_afa *mlxsw_afa,\n\t\t\tconst struct flow_action_cookie *fa_cookie)\n{\n\tstruct mlxsw_afa_cookie *cookie;\n\tu32 cookie_index;\n\tint err;\n\n\tcookie = kzalloc(sizeof(*cookie) + fa_cookie->cookie_len, GFP_KERNEL);\n\tif (!cookie)\n\t\treturn ERR_PTR(-ENOMEM);\n\trefcount_set(&cookie->ref_count, 1);\n\tcookie->fa_cookie = *fa_cookie;\n\tmemcpy(cookie->fa_cookie.cookie, fa_cookie->cookie,\n\t       fa_cookie->cookie_len);\n\n\terr = rhashtable_insert_fast(&mlxsw_afa->cookie_ht, &cookie->ht_node,\n\t\t\t\t     mlxsw_afa_cookie_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_insert;\n\n\t \n\tcookie_index = 1;\n\terr = idr_alloc_u32(&mlxsw_afa->cookie_idr, cookie, &cookie_index,\n\t\t\t    MLXSW_AFA_COOKIE_INDEX_MAX, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_idr_alloc;\n\tcookie->cookie_index = cookie_index;\n\treturn cookie;\n\nerr_idr_alloc:\n\trhashtable_remove_fast(&mlxsw_afa->cookie_ht, &cookie->ht_node,\n\t\t\t       mlxsw_afa_cookie_ht_params);\nerr_rhashtable_insert:\n\tkfree(cookie);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_afa_cookie_destroy(struct mlxsw_afa *mlxsw_afa,\n\t\t\t\t     struct mlxsw_afa_cookie *cookie)\n{\n\tidr_remove(&mlxsw_afa->cookie_idr, cookie->cookie_index);\n\trhashtable_remove_fast(&mlxsw_afa->cookie_ht, &cookie->ht_node,\n\t\t\t       mlxsw_afa_cookie_ht_params);\n\tkfree_rcu(cookie, rcu);\n}\n\nstatic struct mlxsw_afa_cookie *\nmlxsw_afa_cookie_get(struct mlxsw_afa *mlxsw_afa,\n\t\t     const struct flow_action_cookie *fa_cookie)\n{\n\tstruct mlxsw_afa_cookie *cookie;\n\n\tcookie = rhashtable_lookup_fast(&mlxsw_afa->cookie_ht, fa_cookie,\n\t\t\t\t\tmlxsw_afa_cookie_ht_params);\n\tif (cookie) {\n\t\trefcount_inc(&cookie->ref_count);\n\t\treturn cookie;\n\t}\n\treturn mlxsw_afa_cookie_create(mlxsw_afa, fa_cookie);\n}\n\nstatic void mlxsw_afa_cookie_put(struct mlxsw_afa *mlxsw_afa,\n\t\t\t\t struct mlxsw_afa_cookie *cookie)\n{\n\tif (!refcount_dec_and_test(&cookie->ref_count))\n\t\treturn;\n\tmlxsw_afa_cookie_destroy(mlxsw_afa, cookie);\n}\n\n \nconst struct flow_action_cookie *\nmlxsw_afa_cookie_lookup(struct mlxsw_afa *mlxsw_afa, u32 cookie_index)\n{\n\tstruct mlxsw_afa_cookie *cookie;\n\n\t \n\tif (!cookie_index)\n\t\treturn NULL;\n\tcookie = idr_find(&mlxsw_afa->cookie_idr, cookie_index);\n\tif (!cookie)\n\t\treturn NULL;\n\treturn &cookie->fa_cookie;\n}\nEXPORT_SYMBOL(mlxsw_afa_cookie_lookup);\n\nstruct mlxsw_afa_cookie_ref {\n\tstruct mlxsw_afa_resource resource;\n\tstruct mlxsw_afa_cookie *cookie;\n};\n\nstatic void\nmlxsw_afa_cookie_ref_destroy(struct mlxsw_afa_block *block,\n\t\t\t     struct mlxsw_afa_cookie_ref *cookie_ref)\n{\n\tmlxsw_afa_resource_del(&cookie_ref->resource);\n\tmlxsw_afa_cookie_put(block->afa, cookie_ref->cookie);\n\tkfree(cookie_ref);\n}\n\nstatic void\nmlxsw_afa_cookie_ref_destructor(struct mlxsw_afa_block *block,\n\t\t\t\tstruct mlxsw_afa_resource *resource)\n{\n\tstruct mlxsw_afa_cookie_ref *cookie_ref;\n\n\tcookie_ref = container_of(resource, struct mlxsw_afa_cookie_ref,\n\t\t\t\t  resource);\n\tmlxsw_afa_cookie_ref_destroy(block, cookie_ref);\n}\n\nstatic struct mlxsw_afa_cookie_ref *\nmlxsw_afa_cookie_ref_create(struct mlxsw_afa_block *block,\n\t\t\t    const struct flow_action_cookie *fa_cookie)\n{\n\tstruct mlxsw_afa_cookie_ref *cookie_ref;\n\tstruct mlxsw_afa_cookie *cookie;\n\tint err;\n\n\tcookie_ref = kzalloc(sizeof(*cookie_ref), GFP_KERNEL);\n\tif (!cookie_ref)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcookie = mlxsw_afa_cookie_get(block->afa, fa_cookie);\n\tif (IS_ERR(cookie)) {\n\t\terr = PTR_ERR(cookie);\n\t\tgoto err_cookie_get;\n\t}\n\tcookie_ref->cookie = cookie;\n\tcookie_ref->resource.destructor = mlxsw_afa_cookie_ref_destructor;\n\tmlxsw_afa_resource_add(block, &cookie_ref->resource);\n\treturn cookie_ref;\n\nerr_cookie_get:\n\tkfree(cookie_ref);\n\treturn ERR_PTR(err);\n}\n\nstatic struct mlxsw_afa_policer *\nmlxsw_afa_policer_create(struct mlxsw_afa *mlxsw_afa, u32 fa_index,\n\t\t\t u64 rate_bytes_ps, u32 burst,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_afa_policer *policer;\n\tint err;\n\n\tpolicer = kzalloc(sizeof(*policer), GFP_KERNEL);\n\tif (!policer)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = mlxsw_afa->ops->policer_add(mlxsw_afa->ops_priv, rate_bytes_ps,\n\t\t\t\t\t  burst, &policer->policer_index,\n\t\t\t\t\t  extack);\n\tif (err)\n\t\tgoto err_policer_add;\n\n\trefcount_set(&policer->ref_count, 1);\n\tpolicer->fa_index = fa_index;\n\n\terr = rhashtable_insert_fast(&mlxsw_afa->policer_ht, &policer->ht_node,\n\t\t\t\t     mlxsw_afa_policer_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_insert;\n\n\tlist_add_tail(&policer->list, &mlxsw_afa->policer_list);\n\n\treturn policer;\n\nerr_rhashtable_insert:\n\tmlxsw_afa->ops->policer_del(mlxsw_afa->ops_priv,\n\t\t\t\t    policer->policer_index);\nerr_policer_add:\n\tkfree(policer);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_afa_policer_destroy(struct mlxsw_afa *mlxsw_afa,\n\t\t\t\t      struct mlxsw_afa_policer *policer)\n{\n\tlist_del(&policer->list);\n\trhashtable_remove_fast(&mlxsw_afa->policer_ht, &policer->ht_node,\n\t\t\t       mlxsw_afa_policer_ht_params);\n\tmlxsw_afa->ops->policer_del(mlxsw_afa->ops_priv,\n\t\t\t\t    policer->policer_index);\n\tkfree(policer);\n}\n\nstatic struct mlxsw_afa_policer *\nmlxsw_afa_policer_get(struct mlxsw_afa *mlxsw_afa, u32 fa_index,\n\t\t      u64 rate_bytes_ps, u32 burst,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_afa_policer *policer;\n\n\tpolicer = rhashtable_lookup_fast(&mlxsw_afa->policer_ht, &fa_index,\n\t\t\t\t\t mlxsw_afa_policer_ht_params);\n\tif (policer) {\n\t\trefcount_inc(&policer->ref_count);\n\t\treturn policer;\n\t}\n\n\treturn mlxsw_afa_policer_create(mlxsw_afa, fa_index, rate_bytes_ps,\n\t\t\t\t\tburst, extack);\n}\n\nstatic void mlxsw_afa_policer_put(struct mlxsw_afa *mlxsw_afa,\n\t\t\t\t  struct mlxsw_afa_policer *policer)\n{\n\tif (!refcount_dec_and_test(&policer->ref_count))\n\t\treturn;\n\tmlxsw_afa_policer_destroy(mlxsw_afa, policer);\n}\n\nstruct mlxsw_afa_policer_ref {\n\tstruct mlxsw_afa_resource resource;\n\tstruct mlxsw_afa_policer *policer;\n};\n\nstatic void\nmlxsw_afa_policer_ref_destroy(struct mlxsw_afa_block *block,\n\t\t\t      struct mlxsw_afa_policer_ref *policer_ref)\n{\n\tmlxsw_afa_resource_del(&policer_ref->resource);\n\tmlxsw_afa_policer_put(block->afa, policer_ref->policer);\n\tkfree(policer_ref);\n}\n\nstatic void\nmlxsw_afa_policer_ref_destructor(struct mlxsw_afa_block *block,\n\t\t\t\t struct mlxsw_afa_resource *resource)\n{\n\tstruct mlxsw_afa_policer_ref *policer_ref;\n\n\tpolicer_ref = container_of(resource, struct mlxsw_afa_policer_ref,\n\t\t\t\t   resource);\n\tmlxsw_afa_policer_ref_destroy(block, policer_ref);\n}\n\nstatic struct mlxsw_afa_policer_ref *\nmlxsw_afa_policer_ref_create(struct mlxsw_afa_block *block, u32 fa_index,\n\t\t\t     u64 rate_bytes_ps, u32 burst,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_afa_policer_ref *policer_ref;\n\tstruct mlxsw_afa_policer *policer;\n\tint err;\n\n\tpolicer_ref = kzalloc(sizeof(*policer_ref), GFP_KERNEL);\n\tif (!policer_ref)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpolicer = mlxsw_afa_policer_get(block->afa, fa_index, rate_bytes_ps,\n\t\t\t\t\tburst, extack);\n\tif (IS_ERR(policer)) {\n\t\terr = PTR_ERR(policer);\n\t\tgoto err_policer_get;\n\t}\n\n\tpolicer_ref->policer = policer;\n\tpolicer_ref->resource.destructor = mlxsw_afa_policer_ref_destructor;\n\tmlxsw_afa_resource_add(block, &policer_ref->resource);\n\n\treturn policer_ref;\n\nerr_policer_get:\n\tkfree(policer_ref);\n\treturn ERR_PTR(err);\n}\n\n#define MLXSW_AFA_ONE_ACTION_LEN 32\n#define MLXSW_AFA_PAYLOAD_OFFSET 4\n\nenum mlxsw_afa_action_type {\n\tMLXSW_AFA_ACTION_TYPE_TRAP,\n\tMLXSW_AFA_ACTION_TYPE_POLICE,\n\tMLXSW_AFA_ACTION_TYPE_OTHER,\n};\n\nstatic bool\nmlxsw_afa_block_need_split(const struct mlxsw_afa_block *block,\n\t\t\t   enum mlxsw_afa_action_type type)\n{\n\tstruct mlxsw_afa_set *cur_set = block->cur_set;\n\n\t \n\treturn (cur_set->has_trap && type == MLXSW_AFA_ACTION_TYPE_POLICE) ||\n\t       (cur_set->has_police && type == MLXSW_AFA_ACTION_TYPE_TRAP);\n}\n\nstatic char *mlxsw_afa_block_append_action_ext(struct mlxsw_afa_block *block,\n\t\t\t\t\t       u8 action_code, u8 action_size,\n\t\t\t\t\t       enum mlxsw_afa_action_type type)\n{\n\tchar *oneact;\n\tchar *actions;\n\n\tif (block->finished)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (block->cur_act_index + action_size > block->afa->max_acts_per_set ||\n\t    mlxsw_afa_block_need_split(block, type)) {\n\t\tstruct mlxsw_afa_set *set;\n\n\t\t \n\t\tset = mlxsw_afa_set_create(false);\n\t\tif (!set)\n\t\t\treturn ERR_PTR(-ENOBUFS);\n\t\tset->prev = block->cur_set;\n\t\tblock->cur_act_index = 0;\n\t\tblock->cur_set->next = set;\n\t\tblock->cur_set = set;\n\t}\n\n\tswitch (type) {\n\tcase MLXSW_AFA_ACTION_TYPE_TRAP:\n\t\tblock->cur_set->has_trap = true;\n\t\tbreak;\n\tcase MLXSW_AFA_ACTION_TYPE_POLICE:\n\t\tblock->cur_set->has_police = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tactions = block->cur_set->ht_key.enc_actions;\n\toneact = actions + block->cur_act_index * MLXSW_AFA_ONE_ACTION_LEN;\n\tblock->cur_act_index += action_size;\n\tmlxsw_afa_all_action_type_set(oneact, action_code);\n\treturn oneact + MLXSW_AFA_PAYLOAD_OFFSET;\n}\n\nstatic char *mlxsw_afa_block_append_action(struct mlxsw_afa_block *block,\n\t\t\t\t\t   u8 action_code, u8 action_size)\n{\n\treturn mlxsw_afa_block_append_action_ext(block, action_code,\n\t\t\t\t\t\t action_size,\n\t\t\t\t\t\t MLXSW_AFA_ACTION_TYPE_OTHER);\n}\n\n \n\n#define MLXSW_AFA_VLAN_CODE 0x02\n#define MLXSW_AFA_VLAN_SIZE 1\n\nenum mlxsw_afa_vlan_vlan_tag_cmd {\n\tMLXSW_AFA_VLAN_VLAN_TAG_CMD_NOP,\n\tMLXSW_AFA_VLAN_VLAN_TAG_CMD_PUSH_TAG,\n\tMLXSW_AFA_VLAN_VLAN_TAG_CMD_POP_TAG,\n};\n\nenum mlxsw_afa_vlan_cmd {\n\tMLXSW_AFA_VLAN_CMD_NOP,\n\tMLXSW_AFA_VLAN_CMD_SET_OUTER,\n\tMLXSW_AFA_VLAN_CMD_SET_INNER,\n\tMLXSW_AFA_VLAN_CMD_COPY_OUTER_TO_INNER,\n\tMLXSW_AFA_VLAN_CMD_COPY_INNER_TO_OUTER,\n\tMLXSW_AFA_VLAN_CMD_SWAP,\n};\n\n \nMLXSW_ITEM32(afa, vlan, vlan_tag_cmd, 0x00, 29, 3);\n\n \nMLXSW_ITEM32(afa, vlan, vid_cmd, 0x04, 29, 3);\n\n \nMLXSW_ITEM32(afa, vlan, vid, 0x04, 0, 12);\n\n \nMLXSW_ITEM32(afa, vlan, ethertype_cmd, 0x08, 29, 3);\n\n \nMLXSW_ITEM32(afa, vlan, ethertype, 0x08, 24, 3);\n\n \nMLXSW_ITEM32(afa, vlan, pcp_cmd, 0x08, 13, 3);\n\n \nMLXSW_ITEM32(afa, vlan, pcp, 0x08, 8, 3);\n\nstatic inline void\nmlxsw_afa_vlan_pack(char *payload,\n\t\t    enum mlxsw_afa_vlan_vlan_tag_cmd vlan_tag_cmd,\n\t\t    enum mlxsw_afa_vlan_cmd vid_cmd, u16 vid,\n\t\t    enum mlxsw_afa_vlan_cmd pcp_cmd, u8 pcp,\n\t\t    enum mlxsw_afa_vlan_cmd ethertype_cmd, u8 ethertype)\n{\n\tmlxsw_afa_vlan_vlan_tag_cmd_set(payload, vlan_tag_cmd);\n\tmlxsw_afa_vlan_vid_cmd_set(payload, vid_cmd);\n\tmlxsw_afa_vlan_vid_set(payload, vid);\n\tmlxsw_afa_vlan_pcp_cmd_set(payload, pcp_cmd);\n\tmlxsw_afa_vlan_pcp_set(payload, pcp);\n\tmlxsw_afa_vlan_ethertype_cmd_set(payload, ethertype_cmd);\n\tmlxsw_afa_vlan_ethertype_set(payload, ethertype);\n}\n\nint mlxsw_afa_block_append_vlan_modify(struct mlxsw_afa_block *block,\n\t\t\t\t       u16 vid, u8 pcp, u8 et,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tchar *act = mlxsw_afa_block_append_action(block,\n\t\t\t\t\t\t  MLXSW_AFA_VLAN_CODE,\n\t\t\t\t\t\t  MLXSW_AFA_VLAN_SIZE);\n\n\tif (IS_ERR(act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot append vlan_modify action\");\n\t\treturn PTR_ERR(act);\n\t}\n\tmlxsw_afa_vlan_pack(act, MLXSW_AFA_VLAN_VLAN_TAG_CMD_NOP,\n\t\t\t    MLXSW_AFA_VLAN_CMD_SET_OUTER, vid,\n\t\t\t    MLXSW_AFA_VLAN_CMD_SET_OUTER, pcp,\n\t\t\t    MLXSW_AFA_VLAN_CMD_SET_OUTER, et);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_vlan_modify);\n\n \n\n#define MLXSW_AFA_TRAP_CODE 0x03\n#define MLXSW_AFA_TRAP_SIZE 1\n\n#define MLXSW_AFA_TRAPWU_CODE 0x04\n#define MLXSW_AFA_TRAPWU_SIZE 2\n\nenum mlxsw_afa_trap_trap_action {\n\tMLXSW_AFA_TRAP_TRAP_ACTION_NOP = 0,\n\tMLXSW_AFA_TRAP_TRAP_ACTION_TRAP = 2,\n};\n\n \nMLXSW_ITEM32(afa, trap, trap_action, 0x00, 24, 4);\n\nenum mlxsw_afa_trap_forward_action {\n\tMLXSW_AFA_TRAP_FORWARD_ACTION_FORWARD = 1,\n\tMLXSW_AFA_TRAP_FORWARD_ACTION_DISCARD = 3,\n};\n\n \nMLXSW_ITEM32(afa, trap, forward_action, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(afa, trap, trap_id, 0x04, 0, 9);\n\n \nMLXSW_ITEM32(afa, trap, mirror_agent, 0x08, 29, 3);\n\n \nMLXSW_ITEM32(afa, trap, mirror_enable, 0x08, 24, 1);\n\n \nMLXSW_ITEM32(afa, trap, user_def_val, 0x0C, 0, 20);\n\nstatic inline void\nmlxsw_afa_trap_pack(char *payload,\n\t\t    enum mlxsw_afa_trap_trap_action trap_action,\n\t\t    enum mlxsw_afa_trap_forward_action forward_action,\n\t\t    u16 trap_id)\n{\n\tmlxsw_afa_trap_trap_action_set(payload, trap_action);\n\tmlxsw_afa_trap_forward_action_set(payload, forward_action);\n\tmlxsw_afa_trap_trap_id_set(payload, trap_id);\n}\n\nstatic inline void\nmlxsw_afa_trapwu_pack(char *payload,\n\t\t      enum mlxsw_afa_trap_trap_action trap_action,\n\t\t      enum mlxsw_afa_trap_forward_action forward_action,\n\t\t      u16 trap_id, u32 user_def_val)\n{\n\tmlxsw_afa_trap_pack(payload, trap_action, forward_action, trap_id);\n\tmlxsw_afa_trap_user_def_val_set(payload, user_def_val);\n}\n\nstatic inline void\nmlxsw_afa_trap_mirror_pack(char *payload, bool mirror_enable,\n\t\t\t   u8 mirror_agent)\n{\n\tmlxsw_afa_trap_mirror_enable_set(payload, mirror_enable);\n\tmlxsw_afa_trap_mirror_agent_set(payload, mirror_agent);\n}\n\nstatic char *mlxsw_afa_block_append_action_trap(struct mlxsw_afa_block *block,\n\t\t\t\t\t\tu8 action_code, u8 action_size)\n{\n\treturn mlxsw_afa_block_append_action_ext(block, action_code,\n\t\t\t\t\t\t action_size,\n\t\t\t\t\t\t MLXSW_AFA_ACTION_TYPE_TRAP);\n}\n\nstatic int mlxsw_afa_block_append_drop_plain(struct mlxsw_afa_block *block,\n\t\t\t\t\t     bool ingress)\n{\n\tchar *act = mlxsw_afa_block_append_action_trap(block,\n\t\t\t\t\t\t       MLXSW_AFA_TRAP_CODE,\n\t\t\t\t\t\t       MLXSW_AFA_TRAP_SIZE);\n\n\tif (IS_ERR(act))\n\t\treturn PTR_ERR(act);\n\tmlxsw_afa_trap_pack(act, MLXSW_AFA_TRAP_TRAP_ACTION_TRAP,\n\t\t\t    MLXSW_AFA_TRAP_FORWARD_ACTION_DISCARD,\n\t\t\t    ingress ? MLXSW_TRAP_ID_DISCARD_INGRESS_ACL :\n\t\t\t\t      MLXSW_TRAP_ID_DISCARD_EGRESS_ACL);\n\treturn 0;\n}\n\nstatic int\nmlxsw_afa_block_append_drop_with_cookie(struct mlxsw_afa_block *block,\n\t\t\t\t\tbool ingress,\n\t\t\t\t\tconst struct flow_action_cookie *fa_cookie,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_afa_cookie_ref *cookie_ref;\n\tu32 cookie_index;\n\tchar *act;\n\tint err;\n\n\tcookie_ref = mlxsw_afa_cookie_ref_create(block, fa_cookie);\n\tif (IS_ERR(cookie_ref)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot create cookie for drop action\");\n\t\treturn PTR_ERR(cookie_ref);\n\t}\n\tcookie_index = cookie_ref->cookie->cookie_index;\n\n\tact = mlxsw_afa_block_append_action_trap(block, MLXSW_AFA_TRAPWU_CODE,\n\t\t\t\t\t\t MLXSW_AFA_TRAPWU_SIZE);\n\tif (IS_ERR(act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot append drop with cookie action\");\n\t\terr = PTR_ERR(act);\n\t\tgoto err_append_action;\n\t}\n\tmlxsw_afa_trapwu_pack(act, MLXSW_AFA_TRAP_TRAP_ACTION_TRAP,\n\t\t\t      MLXSW_AFA_TRAP_FORWARD_ACTION_DISCARD,\n\t\t\t      ingress ? MLXSW_TRAP_ID_DISCARD_INGRESS_ACL :\n\t\t\t\t\tMLXSW_TRAP_ID_DISCARD_EGRESS_ACL,\n\t\t\t      cookie_index);\n\treturn 0;\n\nerr_append_action:\n\tmlxsw_afa_cookie_ref_destroy(block, cookie_ref);\n\treturn err;\n}\n\nint mlxsw_afa_block_append_drop(struct mlxsw_afa_block *block, bool ingress,\n\t\t\t\tconst struct flow_action_cookie *fa_cookie,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\treturn fa_cookie ?\n\t       mlxsw_afa_block_append_drop_with_cookie(block, ingress,\n\t\t\t\t\t\t       fa_cookie, extack) :\n\t       mlxsw_afa_block_append_drop_plain(block, ingress);\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_drop);\n\nint mlxsw_afa_block_append_trap(struct mlxsw_afa_block *block, u16 trap_id)\n{\n\tchar *act = mlxsw_afa_block_append_action_trap(block,\n\t\t\t\t\t\t       MLXSW_AFA_TRAP_CODE,\n\t\t\t\t\t\t       MLXSW_AFA_TRAP_SIZE);\n\n\tif (IS_ERR(act))\n\t\treturn PTR_ERR(act);\n\tmlxsw_afa_trap_pack(act, MLXSW_AFA_TRAP_TRAP_ACTION_TRAP,\n\t\t\t    MLXSW_AFA_TRAP_FORWARD_ACTION_DISCARD, trap_id);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_trap);\n\nint mlxsw_afa_block_append_trap_and_forward(struct mlxsw_afa_block *block,\n\t\t\t\t\t    u16 trap_id)\n{\n\tchar *act = mlxsw_afa_block_append_action_trap(block,\n\t\t\t\t\t\t       MLXSW_AFA_TRAP_CODE,\n\t\t\t\t\t\t       MLXSW_AFA_TRAP_SIZE);\n\n\tif (IS_ERR(act))\n\t\treturn PTR_ERR(act);\n\tmlxsw_afa_trap_pack(act, MLXSW_AFA_TRAP_TRAP_ACTION_TRAP,\n\t\t\t    MLXSW_AFA_TRAP_FORWARD_ACTION_FORWARD, trap_id);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_trap_and_forward);\n\nstruct mlxsw_afa_mirror {\n\tstruct mlxsw_afa_resource resource;\n\tint span_id;\n\tu16 local_in_port;\n\tbool ingress;\n};\n\nstatic void\nmlxsw_afa_mirror_destroy(struct mlxsw_afa_block *block,\n\t\t\t struct mlxsw_afa_mirror *mirror)\n{\n\tmlxsw_afa_resource_del(&mirror->resource);\n\tblock->afa->ops->mirror_del(block->afa->ops_priv,\n\t\t\t\t    mirror->local_in_port,\n\t\t\t\t    mirror->span_id,\n\t\t\t\t    mirror->ingress);\n\tkfree(mirror);\n}\n\nstatic void\nmlxsw_afa_mirror_destructor(struct mlxsw_afa_block *block,\n\t\t\t    struct mlxsw_afa_resource *resource)\n{\n\tstruct mlxsw_afa_mirror *mirror;\n\n\tmirror = container_of(resource, struct mlxsw_afa_mirror, resource);\n\tmlxsw_afa_mirror_destroy(block, mirror);\n}\n\nstatic struct mlxsw_afa_mirror *\nmlxsw_afa_mirror_create(struct mlxsw_afa_block *block, u16 local_in_port,\n\t\t\tconst struct net_device *out_dev, bool ingress)\n{\n\tstruct mlxsw_afa_mirror *mirror;\n\tint err;\n\n\tmirror = kzalloc(sizeof(*mirror), GFP_KERNEL);\n\tif (!mirror)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = block->afa->ops->mirror_add(block->afa->ops_priv,\n\t\t\t\t\t  local_in_port, out_dev,\n\t\t\t\t\t  ingress, &mirror->span_id);\n\tif (err)\n\t\tgoto err_mirror_add;\n\n\tmirror->ingress = ingress;\n\tmirror->local_in_port = local_in_port;\n\tmirror->resource.destructor = mlxsw_afa_mirror_destructor;\n\tmlxsw_afa_resource_add(block, &mirror->resource);\n\treturn mirror;\n\nerr_mirror_add:\n\tkfree(mirror);\n\treturn ERR_PTR(err);\n}\n\nstatic int\nmlxsw_afa_block_append_allocated_mirror(struct mlxsw_afa_block *block,\n\t\t\t\t\tu8 mirror_agent)\n{\n\tchar *act = mlxsw_afa_block_append_action_trap(block,\n\t\t\t\t\t\t       MLXSW_AFA_TRAP_CODE,\n\t\t\t\t\t\t       MLXSW_AFA_TRAP_SIZE);\n\n\tif (IS_ERR(act))\n\t\treturn PTR_ERR(act);\n\tmlxsw_afa_trap_pack(act, MLXSW_AFA_TRAP_TRAP_ACTION_NOP,\n\t\t\t    MLXSW_AFA_TRAP_FORWARD_ACTION_FORWARD, 0);\n\tmlxsw_afa_trap_mirror_pack(act, true, mirror_agent);\n\treturn 0;\n}\n\nint\nmlxsw_afa_block_append_mirror(struct mlxsw_afa_block *block, u16 local_in_port,\n\t\t\t      const struct net_device *out_dev, bool ingress,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_afa_mirror *mirror;\n\tint err;\n\n\tmirror = mlxsw_afa_mirror_create(block, local_in_port, out_dev,\n\t\t\t\t\t ingress);\n\tif (IS_ERR(mirror)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot create mirror action\");\n\t\treturn PTR_ERR(mirror);\n\t}\n\terr = mlxsw_afa_block_append_allocated_mirror(block, mirror->span_id);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot append mirror action\");\n\t\tgoto err_append_allocated_mirror;\n\t}\n\n\treturn 0;\n\nerr_append_allocated_mirror:\n\tmlxsw_afa_mirror_destroy(block, mirror);\n\treturn err;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_mirror);\n\n \n\n#define MLXSW_AFA_QOS_CODE 0x06\n#define MLXSW_AFA_QOS_SIZE 1\n\nenum mlxsw_afa_qos_ecn_cmd {\n\t \n\tMLXSW_AFA_QOS_ECN_CMD_NOP,\n\t \n\tMLXSW_AFA_QOS_ECN_CMD_SET,\n};\n\n \nMLXSW_ITEM32(afa, qos, ecn_cmd, 0x04, 29, 3);\n\n \nMLXSW_ITEM32(afa, qos, ecn, 0x04, 24, 2);\n\nenum mlxsw_afa_qos_dscp_cmd {\n\t \n\tMLXSW_AFA_QOS_DSCP_CMD_NOP,\n\t \n\tMLXSW_AFA_QOS_DSCP_CMD_SET_3LSB,\n\t \n\tMLXSW_AFA_QOS_DSCP_CMD_SET_3MSB,\n\t \n\tMLXSW_AFA_QOS_DSCP_CMD_SET_ALL,\n};\n\n \nMLXSW_ITEM32(afa, qos, dscp_cmd, 0x04, 14, 2);\n\n \nMLXSW_ITEM32(afa, qos, dscp, 0x04, 0, 6);\n\nenum mlxsw_afa_qos_switch_prio_cmd {\n\t \n\tMLXSW_AFA_QOS_SWITCH_PRIO_CMD_NOP,\n\t \n\tMLXSW_AFA_QOS_SWITCH_PRIO_CMD_SET,\n};\n\n \nMLXSW_ITEM32(afa, qos, switch_prio_cmd, 0x08, 14, 2);\n\n \nMLXSW_ITEM32(afa, qos, switch_prio, 0x08, 0, 4);\n\nenum mlxsw_afa_qos_dscp_rw {\n\tMLXSW_AFA_QOS_DSCP_RW_PRESERVE,\n\tMLXSW_AFA_QOS_DSCP_RW_SET,\n\tMLXSW_AFA_QOS_DSCP_RW_CLEAR,\n};\n\n \nMLXSW_ITEM32(afa, qos, dscp_rw, 0x0C, 30, 2);\n\nstatic inline void\nmlxsw_afa_qos_ecn_pack(char *payload,\n\t\t       enum mlxsw_afa_qos_ecn_cmd ecn_cmd, u8 ecn)\n{\n\tmlxsw_afa_qos_ecn_cmd_set(payload, ecn_cmd);\n\tmlxsw_afa_qos_ecn_set(payload, ecn);\n}\n\nstatic inline void\nmlxsw_afa_qos_dscp_pack(char *payload,\n\t\t\tenum mlxsw_afa_qos_dscp_cmd dscp_cmd, u8 dscp)\n{\n\tmlxsw_afa_qos_dscp_cmd_set(payload, dscp_cmd);\n\tmlxsw_afa_qos_dscp_set(payload, dscp);\n}\n\nstatic inline void\nmlxsw_afa_qos_switch_prio_pack(char *payload,\n\t\t\t       enum mlxsw_afa_qos_switch_prio_cmd prio_cmd,\n\t\t\t       u8 prio)\n{\n\tmlxsw_afa_qos_switch_prio_cmd_set(payload, prio_cmd);\n\tmlxsw_afa_qos_switch_prio_set(payload, prio);\n}\n\nstatic int __mlxsw_afa_block_append_qos_dsfield(struct mlxsw_afa_block *block,\n\t\t\t\t\t\tbool set_dscp, u8 dscp,\n\t\t\t\t\t\tbool set_ecn, u8 ecn,\n\t\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tchar *act = mlxsw_afa_block_append_action(block,\n\t\t\t\t\t\t  MLXSW_AFA_QOS_CODE,\n\t\t\t\t\t\t  MLXSW_AFA_QOS_SIZE);\n\n\tif (IS_ERR(act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot append QOS action\");\n\t\treturn PTR_ERR(act);\n\t}\n\n\tif (set_ecn)\n\t\tmlxsw_afa_qos_ecn_pack(act, MLXSW_AFA_QOS_ECN_CMD_SET, ecn);\n\tif (set_dscp) {\n\t\tmlxsw_afa_qos_dscp_pack(act, MLXSW_AFA_QOS_DSCP_CMD_SET_ALL,\n\t\t\t\t\tdscp);\n\t\tmlxsw_afa_qos_dscp_rw_set(act, MLXSW_AFA_QOS_DSCP_RW_CLEAR);\n\t}\n\n\treturn 0;\n}\n\nint mlxsw_afa_block_append_qos_dsfield(struct mlxsw_afa_block *block,\n\t\t\t\t       u8 dsfield,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn __mlxsw_afa_block_append_qos_dsfield(block,\n\t\t\t\t\t\t    true, dsfield >> 2,\n\t\t\t\t\t\t    true, dsfield & 0x03,\n\t\t\t\t\t\t    extack);\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_qos_dsfield);\n\nint mlxsw_afa_block_append_qos_dscp(struct mlxsw_afa_block *block,\n\t\t\t\t    u8 dscp, struct netlink_ext_ack *extack)\n{\n\treturn __mlxsw_afa_block_append_qos_dsfield(block,\n\t\t\t\t\t\t    true, dscp,\n\t\t\t\t\t\t    false, 0,\n\t\t\t\t\t\t    extack);\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_qos_dscp);\n\nint mlxsw_afa_block_append_qos_ecn(struct mlxsw_afa_block *block,\n\t\t\t\t   u8 ecn, struct netlink_ext_ack *extack)\n{\n\treturn __mlxsw_afa_block_append_qos_dsfield(block,\n\t\t\t\t\t\t    false, 0,\n\t\t\t\t\t\t    true, ecn,\n\t\t\t\t\t\t    extack);\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_qos_ecn);\n\nint mlxsw_afa_block_append_qos_switch_prio(struct mlxsw_afa_block *block,\n\t\t\t\t\t   u8 prio,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tchar *act = mlxsw_afa_block_append_action(block,\n\t\t\t\t\t\t  MLXSW_AFA_QOS_CODE,\n\t\t\t\t\t\t  MLXSW_AFA_QOS_SIZE);\n\n\tif (IS_ERR(act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot append QOS action\");\n\t\treturn PTR_ERR(act);\n\t}\n\tmlxsw_afa_qos_switch_prio_pack(act, MLXSW_AFA_QOS_SWITCH_PRIO_CMD_SET,\n\t\t\t\t       prio);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_qos_switch_prio);\n\n \n\n#define MLXSW_AFA_FORWARD_CODE 0x07\n#define MLXSW_AFA_FORWARD_SIZE 1\n\nenum mlxsw_afa_forward_type {\n\t \n\tMLXSW_AFA_FORWARD_TYPE_PBS,\n\t \n\tMLXSW_AFA_FORWARD_TYPE_OUTPUT,\n};\n\n \nMLXSW_ITEM32(afa, forward, type, 0x00, 24, 2);\n\n \nMLXSW_ITEM32(afa, forward, pbs_ptr, 0x08, 0, 24);\n\n \nMLXSW_ITEM32(afa, forward, in_port, 0x0C, 0, 1);\n\nstatic inline void\nmlxsw_afa_forward_pack(char *payload, enum mlxsw_afa_forward_type type,\n\t\t       u32 pbs_ptr, bool in_port)\n{\n\tmlxsw_afa_forward_type_set(payload, type);\n\tmlxsw_afa_forward_pbs_ptr_set(payload, pbs_ptr);\n\tmlxsw_afa_forward_in_port_set(payload, in_port);\n}\n\nint mlxsw_afa_block_append_fwd(struct mlxsw_afa_block *block,\n\t\t\t       u16 local_port, bool in_port,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_afa_fwd_entry_ref *fwd_entry_ref;\n\tu32 kvdl_index;\n\tchar *act;\n\tint err;\n\n\tif (in_port) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Forwarding to ingress port is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tfwd_entry_ref = mlxsw_afa_fwd_entry_ref_create(block, local_port);\n\tif (IS_ERR(fwd_entry_ref)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot create forward action\");\n\t\treturn PTR_ERR(fwd_entry_ref);\n\t}\n\tkvdl_index = fwd_entry_ref->fwd_entry->kvdl_index;\n\n\tact = mlxsw_afa_block_append_action(block, MLXSW_AFA_FORWARD_CODE,\n\t\t\t\t\t    MLXSW_AFA_FORWARD_SIZE);\n\tif (IS_ERR(act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot append forward action\");\n\t\terr = PTR_ERR(act);\n\t\tgoto err_append_action;\n\t}\n\tmlxsw_afa_forward_pack(act, MLXSW_AFA_FORWARD_TYPE_PBS,\n\t\t\t       kvdl_index, in_port);\n\treturn 0;\n\nerr_append_action:\n\tmlxsw_afa_fwd_entry_ref_destroy(block, fwd_entry_ref);\n\treturn err;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_fwd);\n\n \n\n#define MLXSW_AFA_POLCNT_CODE 0x08\n#define MLXSW_AFA_POLCNT_SIZE 1\n\nenum {\n\tMLXSW_AFA_POLCNT_COUNTER,\n\tMLXSW_AFA_POLCNT_POLICER,\n};\n\n \nMLXSW_ITEM32(afa, polcnt, c_p, 0x00, 31, 1);\n\nenum mlxsw_afa_polcnt_counter_set_type {\n\t \n\tMLXSW_AFA_POLCNT_COUNTER_SET_TYPE_NO_COUNT = 0x00,\n\t \n\tMLXSW_AFA_POLCNT_COUNTER_SET_TYPE_PACKETS_BYTES = 0x03,\n\t \n\tMLXSW_AFA_POLCNT_COUNTER_SET_TYPE_PACKETS = 0x05,\n};\n\n \nMLXSW_ITEM32(afa, polcnt, counter_set_type, 0x04, 24, 8);\n\n \nMLXSW_ITEM32(afa, polcnt, counter_index, 0x04, 0, 24);\n\n \nMLXSW_ITEM32(afa, polcnt, pid, 0x08, 0, 14);\n\nstatic inline void\nmlxsw_afa_polcnt_pack(char *payload,\n\t\t      enum mlxsw_afa_polcnt_counter_set_type set_type,\n\t\t      u32 counter_index)\n{\n\tmlxsw_afa_polcnt_c_p_set(payload, MLXSW_AFA_POLCNT_COUNTER);\n\tmlxsw_afa_polcnt_counter_set_type_set(payload, set_type);\n\tmlxsw_afa_polcnt_counter_index_set(payload, counter_index);\n}\n\nstatic void mlxsw_afa_polcnt_policer_pack(char *payload, u16 policer_index)\n{\n\tmlxsw_afa_polcnt_c_p_set(payload, MLXSW_AFA_POLCNT_POLICER);\n\tmlxsw_afa_polcnt_pid_set(payload, policer_index);\n}\n\nint mlxsw_afa_block_append_allocated_counter(struct mlxsw_afa_block *block,\n\t\t\t\t\t     u32 counter_index)\n{\n\tchar *act = mlxsw_afa_block_append_action(block, MLXSW_AFA_POLCNT_CODE,\n\t\t\t\t\t\t  MLXSW_AFA_POLCNT_SIZE);\n\tif (IS_ERR(act))\n\t\treturn PTR_ERR(act);\n\tmlxsw_afa_polcnt_pack(act, MLXSW_AFA_POLCNT_COUNTER_SET_TYPE_PACKETS_BYTES,\n\t\t\t      counter_index);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_allocated_counter);\n\nint mlxsw_afa_block_append_counter(struct mlxsw_afa_block *block,\n\t\t\t\t   u32 *p_counter_index,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_afa_counter *counter;\n\tu32 counter_index;\n\tint err;\n\n\tcounter = mlxsw_afa_counter_create(block);\n\tif (IS_ERR(counter)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot create count action\");\n\t\treturn PTR_ERR(counter);\n\t}\n\tcounter_index = counter->counter_index;\n\n\terr = mlxsw_afa_block_append_allocated_counter(block, counter_index);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot append count action\");\n\t\tgoto err_append_allocated_counter;\n\t}\n\tif (p_counter_index)\n\t\t*p_counter_index = counter_index;\n\treturn 0;\n\nerr_append_allocated_counter:\n\tmlxsw_afa_counter_destroy(block, counter);\n\treturn err;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_counter);\n\nint mlxsw_afa_block_append_police(struct mlxsw_afa_block *block,\n\t\t\t\t  u32 fa_index, u64 rate_bytes_ps, u32 burst,\n\t\t\t\t  u16 *p_policer_index,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_afa_policer_ref *policer_ref;\n\tchar *act;\n\tint err;\n\n\tpolicer_ref = mlxsw_afa_policer_ref_create(block, fa_index,\n\t\t\t\t\t\t   rate_bytes_ps,\n\t\t\t\t\t\t   burst, extack);\n\tif (IS_ERR(policer_ref))\n\t\treturn PTR_ERR(policer_ref);\n\t*p_policer_index = policer_ref->policer->policer_index;\n\n\tact = mlxsw_afa_block_append_action_ext(block, MLXSW_AFA_POLCNT_CODE,\n\t\t\t\t\t\tMLXSW_AFA_POLCNT_SIZE,\n\t\t\t\t\t\tMLXSW_AFA_ACTION_TYPE_POLICE);\n\tif (IS_ERR(act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot append police action\");\n\t\terr = PTR_ERR(act);\n\t\tgoto err_append_action;\n\t}\n\tmlxsw_afa_polcnt_policer_pack(act, *p_policer_index);\n\n\treturn 0;\n\nerr_append_action:\n\tmlxsw_afa_policer_ref_destroy(block, policer_ref);\n\treturn err;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_police);\n\n \n\n#define MLXSW_AFA_VIRFWD_CODE 0x0E\n#define MLXSW_AFA_VIRFWD_SIZE 1\n\nenum mlxsw_afa_virfwd_fid_cmd {\n\t \n\tMLXSW_AFA_VIRFWD_FID_CMD_NOOP,\n\t \n\tMLXSW_AFA_VIRFWD_FID_CMD_SET,\n};\n\n \nMLXSW_ITEM32(afa, virfwd, fid_cmd, 0x08, 29, 3);\n\n \nMLXSW_ITEM32(afa, virfwd, fid, 0x08, 0, 16);\n\nstatic inline void mlxsw_afa_virfwd_pack(char *payload,\n\t\t\t\t\t enum mlxsw_afa_virfwd_fid_cmd fid_cmd,\n\t\t\t\t\t u16 fid)\n{\n\tmlxsw_afa_virfwd_fid_cmd_set(payload, fid_cmd);\n\tmlxsw_afa_virfwd_fid_set(payload, fid);\n}\n\nint mlxsw_afa_block_append_fid_set(struct mlxsw_afa_block *block, u16 fid,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tchar *act = mlxsw_afa_block_append_action(block,\n\t\t\t\t\t\t  MLXSW_AFA_VIRFWD_CODE,\n\t\t\t\t\t\t  MLXSW_AFA_VIRFWD_SIZE);\n\tif (IS_ERR(act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot append fid_set action\");\n\t\treturn PTR_ERR(act);\n\t}\n\tmlxsw_afa_virfwd_pack(act, MLXSW_AFA_VIRFWD_FID_CMD_SET, fid);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_fid_set);\n\n \n\n#define MLXSW_AFA_IGNORE_CODE 0x0F\n#define MLXSW_AFA_IGNORE_SIZE 1\n\n \nMLXSW_ITEM32(afa, ignore, disable_learning, 0x00, 29, 1);\n\n \nMLXSW_ITEM32(afa, ignore, disable_security, 0x00, 28, 1);\n\nstatic void mlxsw_afa_ignore_pack(char *payload, bool disable_learning,\n\t\t\t\t  bool disable_security)\n{\n\tmlxsw_afa_ignore_disable_learning_set(payload, disable_learning);\n\tmlxsw_afa_ignore_disable_security_set(payload, disable_security);\n}\n\nint mlxsw_afa_block_append_ignore(struct mlxsw_afa_block *block,\n\t\t\t\t  bool disable_learning, bool disable_security)\n{\n\tchar *act = mlxsw_afa_block_append_action(block, MLXSW_AFA_IGNORE_CODE,\n\t\t\t\t\t\t  MLXSW_AFA_IGNORE_SIZE);\n\n\tif (IS_ERR(act))\n\t\treturn PTR_ERR(act);\n\tmlxsw_afa_ignore_pack(act, disable_learning, disable_security);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_ignore);\n\n \n\n#define MLXSW_AFA_MCROUTER_CODE 0x10\n#define MLXSW_AFA_MCROUTER_SIZE 2\n\nenum mlxsw_afa_mcrouter_rpf_action {\n\tMLXSW_AFA_MCROUTER_RPF_ACTION_NOP,\n\tMLXSW_AFA_MCROUTER_RPF_ACTION_TRAP,\n\tMLXSW_AFA_MCROUTER_RPF_ACTION_DISCARD_ERROR,\n};\n\n \nMLXSW_ITEM32(afa, mcrouter, rpf_action, 0x00, 28, 3);\n\n \nMLXSW_ITEM32(afa, mcrouter, expected_irif, 0x00, 0, 16);\n\n \nMLXSW_ITEM32(afa, mcrouter, min_mtu, 0x08, 0, 16);\n\nenum mlxsw_afa_mrouter_vrmid {\n\tMLXSW_AFA_MCROUTER_VRMID_INVALID,\n\tMLXSW_AFA_MCROUTER_VRMID_VALID\n};\n\n \nMLXSW_ITEM32(afa, mcrouter, vrmid, 0x0C, 31, 1);\n\n \nMLXSW_ITEM32(afa, mcrouter, rigr_rmid_index, 0x0C, 0, 24);\n\nstatic inline void\nmlxsw_afa_mcrouter_pack(char *payload,\n\t\t\tenum mlxsw_afa_mcrouter_rpf_action rpf_action,\n\t\t\tu16 expected_irif, u16 min_mtu,\n\t\t\tenum mlxsw_afa_mrouter_vrmid vrmid, u32 rigr_rmid_index)\n\n{\n\tmlxsw_afa_mcrouter_rpf_action_set(payload, rpf_action);\n\tmlxsw_afa_mcrouter_expected_irif_set(payload, expected_irif);\n\tmlxsw_afa_mcrouter_min_mtu_set(payload, min_mtu);\n\tmlxsw_afa_mcrouter_vrmid_set(payload, vrmid);\n\tmlxsw_afa_mcrouter_rigr_rmid_index_set(payload, rigr_rmid_index);\n}\n\nint mlxsw_afa_block_append_mcrouter(struct mlxsw_afa_block *block,\n\t\t\t\t    u16 expected_irif, u16 min_mtu,\n\t\t\t\t    bool rmid_valid, u32 kvdl_index)\n{\n\tchar *act = mlxsw_afa_block_append_action(block,\n\t\t\t\t\t\t  MLXSW_AFA_MCROUTER_CODE,\n\t\t\t\t\t\t  MLXSW_AFA_MCROUTER_SIZE);\n\tif (IS_ERR(act))\n\t\treturn PTR_ERR(act);\n\tmlxsw_afa_mcrouter_pack(act, MLXSW_AFA_MCROUTER_RPF_ACTION_TRAP,\n\t\t\t\texpected_irif, min_mtu, rmid_valid, kvdl_index);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_mcrouter);\n\n \n\n#define MLXSW_AFA_IP_CODE 0x11\n#define MLXSW_AFA_IP_SIZE 2\n\nenum mlxsw_afa_ip_s_d {\n\t \n\tMLXSW_AFA_IP_S_D_DIP,\n\t \n\tMLXSW_AFA_IP_S_D_SIP,\n};\n\n \nMLXSW_ITEM32(afa, ip, s_d, 0x00, 31, 1);\n\nenum mlxsw_afa_ip_m_l {\n\t \n\tMLXSW_AFA_IP_M_L_LSB,\n\t \n\tMLXSW_AFA_IP_M_L_MSB,\n};\n\n \nMLXSW_ITEM32(afa, ip, m_l, 0x00, 30, 1);\n\n \nMLXSW_ITEM32(afa, ip, ip_63_32, 0x08, 0, 32);\n\n \nMLXSW_ITEM32(afa, ip, ip_31_0, 0x0C, 0, 32);\n\nstatic void mlxsw_afa_ip_pack(char *payload, enum mlxsw_afa_ip_s_d s_d,\n\t\t\t      enum mlxsw_afa_ip_m_l m_l, u32 ip_31_0,\n\t\t\t      u32 ip_63_32)\n{\n\tmlxsw_afa_ip_s_d_set(payload, s_d);\n\tmlxsw_afa_ip_m_l_set(payload, m_l);\n\tmlxsw_afa_ip_ip_31_0_set(payload, ip_31_0);\n\tmlxsw_afa_ip_ip_63_32_set(payload, ip_63_32);\n}\n\nint mlxsw_afa_block_append_ip(struct mlxsw_afa_block *block, bool is_dip,\n\t\t\t      bool is_lsb, u32 val_31_0, u32 val_63_32,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tenum mlxsw_afa_ip_s_d s_d = is_dip ? MLXSW_AFA_IP_S_D_DIP :\n\t\t\t\t\t     MLXSW_AFA_IP_S_D_SIP;\n\tenum mlxsw_afa_ip_m_l m_l = is_lsb ? MLXSW_AFA_IP_M_L_LSB :\n\t\t\t\t\t     MLXSW_AFA_IP_M_L_MSB;\n\tchar *act = mlxsw_afa_block_append_action(block,\n\t\t\t\t\t\t  MLXSW_AFA_IP_CODE,\n\t\t\t\t\t\t  MLXSW_AFA_IP_SIZE);\n\n\tif (IS_ERR(act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot append IP action\");\n\t\treturn PTR_ERR(act);\n\t}\n\n\tmlxsw_afa_ip_pack(act, s_d, m_l, val_31_0, val_63_32);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_ip);\n\n \n\n#define MLXSW_AFA_L4PORT_CODE 0x12\n#define MLXSW_AFA_L4PORT_SIZE 1\n\nenum mlxsw_afa_l4port_s_d {\n\t \n\tMLXSW_AFA_L4PORT_S_D_SRC,\n\t \n\tMLXSW_AFA_L4PORT_S_D_DST,\n};\n\n \nMLXSW_ITEM32(afa, l4port, s_d, 0x00, 31, 1);\n\n \nMLXSW_ITEM32(afa, l4port, l4_port, 0x08, 0, 16);\n\nstatic void mlxsw_afa_l4port_pack(char *payload, enum mlxsw_afa_l4port_s_d s_d, u16 l4_port)\n{\n\tmlxsw_afa_l4port_s_d_set(payload, s_d);\n\tmlxsw_afa_l4port_l4_port_set(payload, l4_port);\n}\n\nint mlxsw_afa_block_append_l4port(struct mlxsw_afa_block *block, bool is_dport, u16 l4_port,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tenum mlxsw_afa_l4port_s_d s_d = is_dport ? MLXSW_AFA_L4PORT_S_D_DST :\n\t\t\t\t\t\t   MLXSW_AFA_L4PORT_S_D_SRC;\n\tchar *act = mlxsw_afa_block_append_action(block,\n\t\t\t\t\t\t  MLXSW_AFA_L4PORT_CODE,\n\t\t\t\t\t\t  MLXSW_AFA_L4PORT_SIZE);\n\n\tif (IS_ERR(act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot append L4_PORT action\");\n\t\treturn PTR_ERR(act);\n\t}\n\n\tmlxsw_afa_l4port_pack(act, s_d, l4_port);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_l4port);\n\n \n\n#define MLXSW_AFA_SAMPLER_CODE 0x13\n#define MLXSW_AFA_SAMPLER_SIZE 1\n\n \nMLXSW_ITEM32(afa, sampler, mirror_agent, 0x04, 0, 3);\n\n#define MLXSW_AFA_SAMPLER_RATE_MAX (BIT(24) - 1)\n\n \nMLXSW_ITEM32(afa, sampler, mirror_probability_rate, 0x08, 0, 24);\n\nstatic void mlxsw_afa_sampler_pack(char *payload, u8 mirror_agent, u32 rate)\n{\n\tmlxsw_afa_sampler_mirror_agent_set(payload, mirror_agent);\n\tmlxsw_afa_sampler_mirror_probability_rate_set(payload, rate);\n}\n\nstruct mlxsw_afa_sampler {\n\tstruct mlxsw_afa_resource resource;\n\tint span_id;\n\tu16 local_port;\n\tbool ingress;\n};\n\nstatic void mlxsw_afa_sampler_destroy(struct mlxsw_afa_block *block,\n\t\t\t\t      struct mlxsw_afa_sampler *sampler)\n{\n\tmlxsw_afa_resource_del(&sampler->resource);\n\tblock->afa->ops->sampler_del(block->afa->ops_priv, sampler->local_port,\n\t\t\t\t     sampler->span_id, sampler->ingress);\n\tkfree(sampler);\n}\n\nstatic void mlxsw_afa_sampler_destructor(struct mlxsw_afa_block *block,\n\t\t\t\t\t struct mlxsw_afa_resource *resource)\n{\n\tstruct mlxsw_afa_sampler *sampler;\n\n\tsampler = container_of(resource, struct mlxsw_afa_sampler, resource);\n\tmlxsw_afa_sampler_destroy(block, sampler);\n}\n\nstatic struct mlxsw_afa_sampler *\nmlxsw_afa_sampler_create(struct mlxsw_afa_block *block, u16 local_port,\n\t\t\t struct psample_group *psample_group, u32 rate,\n\t\t\t u32 trunc_size, bool truncate, bool ingress,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_afa_sampler *sampler;\n\tint err;\n\n\tsampler = kzalloc(sizeof(*sampler), GFP_KERNEL);\n\tif (!sampler)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = block->afa->ops->sampler_add(block->afa->ops_priv, local_port,\n\t\t\t\t\t   psample_group, rate, trunc_size,\n\t\t\t\t\t   truncate, ingress, &sampler->span_id,\n\t\t\t\t\t   extack);\n\tif (err)\n\t\tgoto err_sampler_add;\n\n\tsampler->ingress = ingress;\n\tsampler->local_port = local_port;\n\tsampler->resource.destructor = mlxsw_afa_sampler_destructor;\n\tmlxsw_afa_resource_add(block, &sampler->resource);\n\treturn sampler;\n\nerr_sampler_add:\n\tkfree(sampler);\n\treturn ERR_PTR(err);\n}\n\nstatic int\nmlxsw_afa_block_append_allocated_sampler(struct mlxsw_afa_block *block,\n\t\t\t\t\t u8 mirror_agent, u32 rate)\n{\n\tchar *act = mlxsw_afa_block_append_action(block, MLXSW_AFA_SAMPLER_CODE,\n\t\t\t\t\t\t  MLXSW_AFA_SAMPLER_SIZE);\n\n\tif (IS_ERR(act))\n\t\treturn PTR_ERR(act);\n\tmlxsw_afa_sampler_pack(act, mirror_agent, rate);\n\treturn 0;\n}\n\nint mlxsw_afa_block_append_sampler(struct mlxsw_afa_block *block, u16 local_port,\n\t\t\t\t   struct psample_group *psample_group,\n\t\t\t\t   u32 rate, u32 trunc_size, bool truncate,\n\t\t\t\t   bool ingress,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_afa_sampler *sampler;\n\tint err;\n\n\tif (rate > MLXSW_AFA_SAMPLER_RATE_MAX) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Sampling rate is too high\");\n\t\treturn -EINVAL;\n\t}\n\n\tsampler = mlxsw_afa_sampler_create(block, local_port, psample_group,\n\t\t\t\t\t   rate, trunc_size, truncate, ingress,\n\t\t\t\t\t   extack);\n\tif (IS_ERR(sampler))\n\t\treturn PTR_ERR(sampler);\n\n\terr = mlxsw_afa_block_append_allocated_sampler(block, sampler->span_id,\n\t\t\t\t\t\t       rate);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot append sampler action\");\n\t\tgoto err_append_allocated_sampler;\n\t}\n\n\treturn 0;\n\nerr_append_allocated_sampler:\n\tmlxsw_afa_sampler_destroy(block, sampler);\n\treturn err;\n}\nEXPORT_SYMBOL(mlxsw_afa_block_append_sampler);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}