{
  "module_name": "spectrum_policer.c",
  "hash_id": "2ccadc472635085ffb9a0f8ef1caace98d8ad93dff7ff22b29a2e5f054a2a768",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_policer.c",
  "human_readable_source": "\n \n\n#include <linux/idr.h>\n#include <linux/log2.h>\n#include <linux/mutex.h>\n#include <linux/netlink.h>\n#include <net/devlink.h>\n\n#include \"spectrum.h\"\n\nstruct mlxsw_sp_policer_family {\n\tenum mlxsw_sp_policer_type type;\n\tenum mlxsw_reg_qpcr_g qpcr_type;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tu16 start_index;  \n\tu16 end_index;  \n\tstruct idr policer_idr;\n\tstruct mutex lock;  \n\tatomic_t policers_count;\n\tconst struct mlxsw_sp_policer_family_ops *ops;\n};\n\nstruct mlxsw_sp_policer {\n\tstruct mlxsw_sp_policer_params params;\n\tu16 index;\n};\n\nstruct mlxsw_sp_policer_family_ops {\n\tint (*init)(struct mlxsw_sp_policer_family *family);\n\tvoid (*fini)(struct mlxsw_sp_policer_family *family);\n\tint (*policer_index_alloc)(struct mlxsw_sp_policer_family *family,\n\t\t\t\t   struct mlxsw_sp_policer *policer);\n\tstruct mlxsw_sp_policer * (*policer_index_free)(struct mlxsw_sp_policer_family *family,\n\t\t\t\t\t\t\tu16 policer_index);\n\tint (*policer_init)(struct mlxsw_sp_policer_family *family,\n\t\t\t    const struct mlxsw_sp_policer *policer);\n\tint (*policer_params_check)(const struct mlxsw_sp_policer_family *family,\n\t\t\t\t    const struct mlxsw_sp_policer_params *params,\n\t\t\t\t    struct netlink_ext_ack *extack);\n};\n\nstruct mlxsw_sp_policer_core {\n\tstruct mlxsw_sp_policer_family *family_arr[MLXSW_SP_POLICER_TYPE_MAX + 1];\n\tconst struct mlxsw_sp_policer_core_ops *ops;\n\tu8 lowest_bs_bits;\n\tu8 highest_bs_bits;\n};\n\nstruct mlxsw_sp_policer_core_ops {\n\tint (*init)(struct mlxsw_sp_policer_core *policer_core);\n};\n\nstatic u64 mlxsw_sp_policer_rate_bytes_ps_kbps(u64 rate_bytes_ps)\n{\n\treturn div_u64(rate_bytes_ps, 1000) * BITS_PER_BYTE;\n}\n\nstatic u8 mlxsw_sp_policer_burst_bytes_hw_units(u64 burst_bytes)\n{\n\t \n\tu64 bs512 = div_u64(burst_bytes, 64);\n\n\tif (!bs512)\n\t\treturn 0;\n\n\treturn fls64(bs512) - 1;\n}\n\nstatic u64 mlxsw_sp_policer_single_rate_occ_get(void *priv)\n{\n\tstruct mlxsw_sp_policer_family *family = priv;\n\n\treturn atomic_read(&family->policers_count);\n}\n\nstatic int\nmlxsw_sp_policer_single_rate_family_init(struct mlxsw_sp_policer_family *family)\n{\n\tstruct mlxsw_core *core = family->mlxsw_sp->core;\n\tstruct devlink *devlink;\n\n\t \n\tif (!MLXSW_CORE_RES_VALID(core, MAX_GLOBAL_POLICERS) ||\n\t    !MLXSW_CORE_RES_VALID(core, MAX_CPU_POLICERS))\n\t\treturn -EIO;\n\n\tfamily->start_index = MLXSW_CORE_RES_GET(core, MAX_CPU_POLICERS);\n\tfamily->end_index = MLXSW_CORE_RES_GET(core, MAX_GLOBAL_POLICERS);\n\n\tatomic_set(&family->policers_count, 0);\n\tdevlink = priv_to_devlink(core);\n\tdevl_resource_occ_get_register(devlink,\n\t\t\t\t       MLXSW_SP_RESOURCE_SINGLE_RATE_POLICERS,\n\t\t\t\t       mlxsw_sp_policer_single_rate_occ_get,\n\t\t\t\t       family);\n\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_policer_single_rate_family_fini(struct mlxsw_sp_policer_family *family)\n{\n\tstruct devlink *devlink = priv_to_devlink(family->mlxsw_sp->core);\n\n\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t MLXSW_SP_RESOURCE_SINGLE_RATE_POLICERS);\n\tWARN_ON(atomic_read(&family->policers_count) != 0);\n}\n\nstatic int\nmlxsw_sp_policer_single_rate_index_alloc(struct mlxsw_sp_policer_family *family,\n\t\t\t\t\t struct mlxsw_sp_policer *policer)\n{\n\tint id;\n\n\tmutex_lock(&family->lock);\n\tid = idr_alloc(&family->policer_idr, policer, family->start_index,\n\t\t       family->end_index, GFP_KERNEL);\n\tmutex_unlock(&family->lock);\n\n\tif (id < 0)\n\t\treturn id;\n\n\tatomic_inc(&family->policers_count);\n\tpolicer->index = id;\n\n\treturn 0;\n}\n\nstatic struct mlxsw_sp_policer *\nmlxsw_sp_policer_single_rate_index_free(struct mlxsw_sp_policer_family *family,\n\t\t\t\t\tu16 policer_index)\n{\n\tstruct mlxsw_sp_policer *policer;\n\n\tatomic_dec(&family->policers_count);\n\n\tmutex_lock(&family->lock);\n\tpolicer = idr_remove(&family->policer_idr, policer_index);\n\tmutex_unlock(&family->lock);\n\n\tWARN_ON(!policer);\n\n\treturn policer;\n}\n\nstatic int\nmlxsw_sp_policer_single_rate_init(struct mlxsw_sp_policer_family *family,\n\t\t\t\t  const struct mlxsw_sp_policer *policer)\n{\n\tu64 rate_kbps = mlxsw_sp_policer_rate_bytes_ps_kbps(policer->params.rate);\n\tu8 bs = mlxsw_sp_policer_burst_bytes_hw_units(policer->params.burst);\n\tstruct mlxsw_sp *mlxsw_sp = family->mlxsw_sp;\n\tchar qpcr_pl[MLXSW_REG_QPCR_LEN];\n\n\tmlxsw_reg_qpcr_pack(qpcr_pl, policer->index, MLXSW_REG_QPCR_IR_UNITS_K,\n\t\t\t    true, rate_kbps, bs);\n\tmlxsw_reg_qpcr_clear_counter_set(qpcr_pl, true);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpcr), qpcr_pl);\n}\n\nstatic int\nmlxsw_sp_policer_single_rate_params_check(const struct mlxsw_sp_policer_family *family,\n\t\t\t\t\t  const struct mlxsw_sp_policer_params *params,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_policer_core *policer_core = family->mlxsw_sp->policer_core;\n\tu64 rate_bps = params->rate * BITS_PER_BYTE;\n\tu8 bs;\n\n\tif (!params->bytes) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Only bandwidth policing is currently supported by single rate policers\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_power_of_2(params->burst)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Policer burst size is not power of two\");\n\t\treturn -EINVAL;\n\t}\n\n\tbs = mlxsw_sp_policer_burst_bytes_hw_units(params->burst);\n\n\tif (bs < policer_core->lowest_bs_bits) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Policer burst size lower than limit\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bs > policer_core->highest_bs_bits) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Policer burst size higher than limit\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rate_bps < MLXSW_REG_QPCR_LOWEST_CIR_BITS) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Policer rate lower than limit\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rate_bps > MLXSW_REG_QPCR_HIGHEST_CIR_BITS) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Policer rate higher than limit\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mlxsw_sp_policer_family_ops mlxsw_sp_policer_single_rate_ops = {\n\t.init\t\t\t= mlxsw_sp_policer_single_rate_family_init,\n\t.fini\t\t\t= mlxsw_sp_policer_single_rate_family_fini,\n\t.policer_index_alloc\t= mlxsw_sp_policer_single_rate_index_alloc,\n\t.policer_index_free\t= mlxsw_sp_policer_single_rate_index_free,\n\t.policer_init\t\t= mlxsw_sp_policer_single_rate_init,\n\t.policer_params_check\t= mlxsw_sp_policer_single_rate_params_check,\n};\n\nstatic const struct mlxsw_sp_policer_family mlxsw_sp_policer_single_rate_family = {\n\t.type\t\t= MLXSW_SP_POLICER_TYPE_SINGLE_RATE,\n\t.qpcr_type\t= MLXSW_REG_QPCR_G_GLOBAL,\n\t.ops\t\t= &mlxsw_sp_policer_single_rate_ops,\n};\n\nstatic const struct mlxsw_sp_policer_family *mlxsw_sp_policer_family_arr[] = {\n\t[MLXSW_SP_POLICER_TYPE_SINGLE_RATE]\t= &mlxsw_sp_policer_single_rate_family,\n};\n\nint mlxsw_sp_policer_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t enum mlxsw_sp_policer_type type,\n\t\t\t const struct mlxsw_sp_policer_params *params,\n\t\t\t struct netlink_ext_ack *extack, u16 *p_policer_index)\n{\n\tstruct mlxsw_sp_policer_family *family;\n\tstruct mlxsw_sp_policer *policer;\n\tint err;\n\n\tfamily = mlxsw_sp->policer_core->family_arr[type];\n\n\terr = family->ops->policer_params_check(family, params, extack);\n\tif (err)\n\t\treturn err;\n\n\tpolicer = kmalloc(sizeof(*policer), GFP_KERNEL);\n\tif (!policer)\n\t\treturn -ENOMEM;\n\tpolicer->params = *params;\n\n\terr = family->ops->policer_index_alloc(family, policer);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to allocate policer index\");\n\t\tgoto err_policer_index_alloc;\n\t}\n\n\terr = family->ops->policer_init(family, policer);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to initialize policer\");\n\t\tgoto err_policer_init;\n\t}\n\n\t*p_policer_index = policer->index;\n\n\treturn 0;\n\nerr_policer_init:\n\tfamily->ops->policer_index_free(family, policer->index);\nerr_policer_index_alloc:\n\tkfree(policer);\n\treturn err;\n}\n\nvoid mlxsw_sp_policer_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  enum mlxsw_sp_policer_type type, u16 policer_index)\n{\n\tstruct mlxsw_sp_policer_family *family;\n\tstruct mlxsw_sp_policer *policer;\n\n\tfamily = mlxsw_sp->policer_core->family_arr[type];\n\tpolicer = family->ops->policer_index_free(family, policer_index);\n\tkfree(policer);\n}\n\nint mlxsw_sp_policer_drops_counter_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       enum mlxsw_sp_policer_type type,\n\t\t\t\t       u16 policer_index, u64 *p_drops)\n{\n\tstruct mlxsw_sp_policer_family *family;\n\tchar qpcr_pl[MLXSW_REG_QPCR_LEN];\n\tint err;\n\n\tfamily = mlxsw_sp->policer_core->family_arr[type];\n\n\tMLXSW_REG_ZERO(qpcr, qpcr_pl);\n\tmlxsw_reg_qpcr_pid_set(qpcr_pl, policer_index);\n\tmlxsw_reg_qpcr_g_set(qpcr_pl, family->qpcr_type);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(qpcr), qpcr_pl);\n\tif (err)\n\t\treturn err;\n\n\t*p_drops = mlxsw_reg_qpcr_violate_count_get(qpcr_pl);\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_policer_family_register(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t const struct mlxsw_sp_policer_family *tmpl)\n{\n\tstruct mlxsw_sp_policer_family *family;\n\tint err;\n\n\tfamily = kmemdup(tmpl, sizeof(*family), GFP_KERNEL);\n\tif (!family)\n\t\treturn -ENOMEM;\n\n\tfamily->mlxsw_sp = mlxsw_sp;\n\tidr_init(&family->policer_idr);\n\tmutex_init(&family->lock);\n\n\terr = family->ops->init(family);\n\tif (err)\n\t\tgoto err_family_init;\n\n\tif (WARN_ON(family->start_index >= family->end_index)) {\n\t\terr = -EINVAL;\n\t\tgoto err_index_check;\n\t}\n\n\tmlxsw_sp->policer_core->family_arr[tmpl->type] = family;\n\n\treturn 0;\n\nerr_index_check:\n\tfamily->ops->fini(family);\nerr_family_init:\n\tmutex_destroy(&family->lock);\n\tidr_destroy(&family->policer_idr);\n\tkfree(family);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_policer_family_unregister(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_policer_family *family)\n{\n\tfamily->ops->fini(family);\n\tmutex_destroy(&family->lock);\n\tWARN_ON(!idr_is_empty(&family->policer_idr));\n\tidr_destroy(&family->policer_idr);\n\tkfree(family);\n}\n\nint mlxsw_sp_policers_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_policer_core *policer_core;\n\tint i, err;\n\n\tpolicer_core = kzalloc(sizeof(*policer_core), GFP_KERNEL);\n\tif (!policer_core)\n\t\treturn -ENOMEM;\n\tmlxsw_sp->policer_core = policer_core;\n\tpolicer_core->ops = mlxsw_sp->policer_core_ops;\n\n\terr = policer_core->ops->init(policer_core);\n\tif (err)\n\t\tgoto err_init;\n\n\tfor (i = 0; i < MLXSW_SP_POLICER_TYPE_MAX + 1; i++) {\n\t\terr = mlxsw_sp_policer_family_register(mlxsw_sp, mlxsw_sp_policer_family_arr[i]);\n\t\tif (err)\n\t\t\tgoto err_family_register;\n\t}\n\n\treturn 0;\n\nerr_family_register:\n\tfor (i--; i >= 0; i--) {\n\t\tstruct mlxsw_sp_policer_family *family;\n\n\t\tfamily = mlxsw_sp->policer_core->family_arr[i];\n\t\tmlxsw_sp_policer_family_unregister(mlxsw_sp, family);\n\t}\nerr_init:\n\tkfree(mlxsw_sp->policer_core);\n\treturn err;\n}\n\nvoid mlxsw_sp_policers_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tint i;\n\n\tfor (i = MLXSW_SP_POLICER_TYPE_MAX; i >= 0; i--) {\n\t\tstruct mlxsw_sp_policer_family *family;\n\n\t\tfamily = mlxsw_sp->policer_core->family_arr[i];\n\t\tmlxsw_sp_policer_family_unregister(mlxsw_sp, family);\n\t}\n\n\tkfree(mlxsw_sp->policer_core);\n}\n\nint mlxsw_sp_policer_resources_register(struct mlxsw_core *mlxsw_core)\n{\n\tu64 global_policers, cpu_policers, single_rate_policers;\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tstruct devlink_resource_size_params size_params;\n\tint err;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_core, MAX_GLOBAL_POLICERS) ||\n\t    !MLXSW_CORE_RES_VALID(mlxsw_core, MAX_CPU_POLICERS))\n\t\treturn -EIO;\n\n\tglobal_policers = MLXSW_CORE_RES_GET(mlxsw_core, MAX_GLOBAL_POLICERS);\n\tcpu_policers = MLXSW_CORE_RES_GET(mlxsw_core, MAX_CPU_POLICERS);\n\tsingle_rate_policers = global_policers - cpu_policers;\n\n\tdevlink_resource_size_params_init(&size_params, global_policers,\n\t\t\t\t\t  global_policers, 1,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\terr = devl_resource_register(devlink, \"global_policers\",\n\t\t\t\t     global_policers,\n\t\t\t\t     MLXSW_SP_RESOURCE_GLOBAL_POLICERS,\n\t\t\t\t     DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t     &size_params);\n\tif (err)\n\t\treturn err;\n\n\tdevlink_resource_size_params_init(&size_params, single_rate_policers,\n\t\t\t\t\t  single_rate_policers, 1,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\terr = devl_resource_register(devlink, \"single_rate_policers\",\n\t\t\t\t     single_rate_policers,\n\t\t\t\t     MLXSW_SP_RESOURCE_SINGLE_RATE_POLICERS,\n\t\t\t\t     MLXSW_SP_RESOURCE_GLOBAL_POLICERS,\n\t\t\t\t     &size_params);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp1_policer_core_init(struct mlxsw_sp_policer_core *policer_core)\n{\n\tpolicer_core->lowest_bs_bits = MLXSW_REG_QPCR_LOWEST_CBS_BITS_SP1;\n\tpolicer_core->highest_bs_bits = MLXSW_REG_QPCR_HIGHEST_CBS_BITS_SP1;\n\n\treturn 0;\n}\n\nconst struct mlxsw_sp_policer_core_ops mlxsw_sp1_policer_core_ops = {\n\t.init = mlxsw_sp1_policer_core_init,\n};\n\nstatic int\nmlxsw_sp2_policer_core_init(struct mlxsw_sp_policer_core *policer_core)\n{\n\tpolicer_core->lowest_bs_bits = MLXSW_REG_QPCR_LOWEST_CBS_BITS_SP2;\n\tpolicer_core->highest_bs_bits = MLXSW_REG_QPCR_HIGHEST_CBS_BITS_SP2;\n\n\treturn 0;\n}\n\nconst struct mlxsw_sp_policer_core_ops mlxsw_sp2_policer_core_ops = {\n\t.init = mlxsw_sp2_policer_core_init,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}