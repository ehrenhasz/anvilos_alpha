{
  "module_name": "spectrum_mr_tcam.c",
  "hash_id": "12e1f1e673f8b738cd889562e7ab4057e9f8843795b8430c291f8fe2f1c17ba2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_mr_tcam.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n\n#include \"spectrum_mr_tcam.h\"\n#include \"reg.h\"\n#include \"spectrum.h\"\n#include \"core_acl_flex_actions.h\"\n#include \"spectrum_mr.h\"\n\nstruct mlxsw_sp_mr_tcam {\n\tvoid *priv;\n};\n\n \nstruct mlxsw_sp_mr_erif_sublist {\n\tstruct list_head list;\n\tu32 rigr2_kvdl_index;\n\tint num_erifs;\n\tu16 erif_indices[MLXSW_REG_RIGR2_MAX_ERIFS];\n\tbool synced;\n};\n\nstruct mlxsw_sp_mr_tcam_erif_list {\n\tstruct list_head erif_sublists;\n\tu32 kvdl_index;\n};\n\nstatic bool\nmlxsw_sp_mr_erif_sublist_full(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_mr_erif_sublist *erif_sublist)\n{\n\tint erif_list_entries = MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t\t\t   MC_ERIF_LIST_ENTRIES);\n\n\treturn erif_sublist->num_erifs == erif_list_entries;\n}\n\nstatic void\nmlxsw_sp_mr_erif_list_init(struct mlxsw_sp_mr_tcam_erif_list *erif_list)\n{\n\tINIT_LIST_HEAD(&erif_list->erif_sublists);\n}\n\nstatic struct mlxsw_sp_mr_erif_sublist *\nmlxsw_sp_mr_erif_sublist_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_mr_tcam_erif_list *erif_list)\n{\n\tstruct mlxsw_sp_mr_erif_sublist *erif_sublist;\n\tint err;\n\n\terif_sublist = kzalloc(sizeof(*erif_sublist), GFP_KERNEL);\n\tif (!erif_sublist)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = mlxsw_sp_kvdl_alloc(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_MCRIGR,\n\t\t\t\t  1, &erif_sublist->rigr2_kvdl_index);\n\tif (err) {\n\t\tkfree(erif_sublist);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlist_add_tail(&erif_sublist->list, &erif_list->erif_sublists);\n\treturn erif_sublist;\n}\n\nstatic void\nmlxsw_sp_mr_erif_sublist_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_mr_erif_sublist *erif_sublist)\n{\n\tlist_del(&erif_sublist->list);\n\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_MCRIGR,\n\t\t\t   1, erif_sublist->rigr2_kvdl_index);\n\tkfree(erif_sublist);\n}\n\nstatic int\nmlxsw_sp_mr_erif_list_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  struct mlxsw_sp_mr_tcam_erif_list *erif_list,\n\t\t\t  u16 erif_index)\n{\n\tstruct mlxsw_sp_mr_erif_sublist *sublist;\n\n\t \n\tif (list_empty(&erif_list->erif_sublists)) {\n\t\tsublist = mlxsw_sp_mr_erif_sublist_create(mlxsw_sp, erif_list);\n\t\tif (IS_ERR(sublist))\n\t\t\treturn PTR_ERR(sublist);\n\t\terif_list->kvdl_index = sublist->rigr2_kvdl_index;\n\t} else {\n\t\tsublist = list_last_entry(&erif_list->erif_sublists,\n\t\t\t\t\t  struct mlxsw_sp_mr_erif_sublist,\n\t\t\t\t\t  list);\n\t\tsublist->synced = false;\n\t\tif (mlxsw_sp_mr_erif_sublist_full(mlxsw_sp, sublist)) {\n\t\t\tsublist = mlxsw_sp_mr_erif_sublist_create(mlxsw_sp,\n\t\t\t\t\t\t\t\t  erif_list);\n\t\t\tif (IS_ERR(sublist))\n\t\t\t\treturn PTR_ERR(sublist);\n\t\t}\n\t}\n\n\t \n\tsublist->erif_indices[sublist->num_erifs++] = erif_index;\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_mr_erif_list_flush(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_mr_tcam_erif_list *erif_list)\n{\n\tstruct mlxsw_sp_mr_erif_sublist *erif_sublist, *tmp;\n\n\tlist_for_each_entry_safe(erif_sublist, tmp, &erif_list->erif_sublists,\n\t\t\t\t list)\n\t\tmlxsw_sp_mr_erif_sublist_destroy(mlxsw_sp, erif_sublist);\n}\n\nstatic int\nmlxsw_sp_mr_erif_list_commit(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     struct mlxsw_sp_mr_tcam_erif_list *erif_list)\n{\n\tstruct mlxsw_sp_mr_erif_sublist *curr_sublist;\n\tchar rigr2_pl[MLXSW_REG_RIGR2_LEN];\n\tint err;\n\tint i;\n\n\tlist_for_each_entry(curr_sublist, &erif_list->erif_sublists, list) {\n\t\tif (curr_sublist->synced)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (list_is_last(&curr_sublist->list,\n\t\t\t\t &erif_list->erif_sublists)) {\n\t\t\tmlxsw_reg_rigr2_pack(rigr2_pl,\n\t\t\t\t\t     curr_sublist->rigr2_kvdl_index,\n\t\t\t\t\t     false, 0);\n\t\t} else {\n\t\t\tstruct mlxsw_sp_mr_erif_sublist *next_sublist;\n\n\t\t\tnext_sublist = list_next_entry(curr_sublist, list);\n\t\t\tmlxsw_reg_rigr2_pack(rigr2_pl,\n\t\t\t\t\t     curr_sublist->rigr2_kvdl_index,\n\t\t\t\t\t     true,\n\t\t\t\t\t     next_sublist->rigr2_kvdl_index);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < curr_sublist->num_erifs; i++) {\n\t\t\tu16 erif_index = curr_sublist->erif_indices[i];\n\n\t\t\tmlxsw_reg_rigr2_erif_entry_pack(rigr2_pl, i, true,\n\t\t\t\t\t\t\terif_index);\n\t\t}\n\n\t\t \n\t\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rigr2),\n\t\t\t\t      rigr2_pl);\n\t\tif (err)\n\t\t\t \n\t\t\treturn err;\n\t\tcurr_sublist->synced = true;\n\t}\n\treturn 0;\n}\n\nstatic void mlxsw_sp_mr_erif_list_move(struct mlxsw_sp_mr_tcam_erif_list *to,\n\t\t\t\t       struct mlxsw_sp_mr_tcam_erif_list *from)\n{\n\tlist_splice(&from->erif_sublists, &to->erif_sublists);\n\tto->kvdl_index = from->kvdl_index;\n}\n\nstruct mlxsw_sp_mr_tcam_route {\n\tstruct mlxsw_sp_mr_tcam_erif_list erif_list;\n\tstruct mlxsw_afa_block *afa_block;\n\tu32 counter_index;\n\tenum mlxsw_sp_mr_route_action action;\n\tstruct mlxsw_sp_mr_route_key key;\n\tu16 irif_index;\n\tu16 min_mtu;\n\tvoid *priv;\n};\n\nstatic struct mlxsw_afa_block *\nmlxsw_sp_mr_tcam_afa_block_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  enum mlxsw_sp_mr_route_action route_action,\n\t\t\t\t  u16 irif_index, u32 counter_index,\n\t\t\t\t  u16 min_mtu,\n\t\t\t\t  struct mlxsw_sp_mr_tcam_erif_list *erif_list)\n{\n\tstruct mlxsw_afa_block *afa_block;\n\tint err;\n\n\tafa_block = mlxsw_afa_block_create(mlxsw_sp->afa);\n\tif (IS_ERR(afa_block))\n\t\treturn afa_block;\n\n\terr = mlxsw_afa_block_append_allocated_counter(afa_block,\n\t\t\t\t\t\t       counter_index);\n\tif (err)\n\t\tgoto err;\n\n\tswitch (route_action) {\n\tcase MLXSW_SP_MR_ROUTE_ACTION_TRAP:\n\t\terr = mlxsw_afa_block_append_trap(afa_block,\n\t\t\t\t\t\t  MLXSW_TRAP_ID_ACL1);\n\t\tif (err)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase MLXSW_SP_MR_ROUTE_ACTION_TRAP_AND_FORWARD:\n\tcase MLXSW_SP_MR_ROUTE_ACTION_FORWARD:\n\t\t \n\t\terr = mlxsw_sp_mr_erif_list_commit(mlxsw_sp, erif_list);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\terr = mlxsw_afa_block_append_mcrouter(afa_block, irif_index,\n\t\t\t\t\t\t      min_mtu, false,\n\t\t\t\t\t\t      erif_list->kvdl_index);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tif (route_action == MLXSW_SP_MR_ROUTE_ACTION_TRAP_AND_FORWARD) {\n\t\t\terr = mlxsw_afa_block_append_trap_and_forward(afa_block,\n\t\t\t\t\t\t\t\t      MLXSW_TRAP_ID_ACL2);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\terr = mlxsw_afa_block_commit(afa_block);\n\tif (err)\n\t\tgoto err;\n\treturn afa_block;\nerr:\n\tmlxsw_afa_block_destroy(afa_block);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_mr_tcam_afa_block_destroy(struct mlxsw_afa_block *afa_block)\n{\n\tmlxsw_afa_block_destroy(afa_block);\n}\n\nstatic int\nmlxsw_sp_mr_tcam_erif_populate(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_mr_tcam_erif_list *erif_list,\n\t\t\t       struct mlxsw_sp_mr_route_info *route_info)\n{\n\tint err;\n\tint i;\n\n\tfor (i = 0; i < route_info->erif_num; i++) {\n\t\tu16 erif_index = route_info->erif_indices[i];\n\n\t\terr = mlxsw_sp_mr_erif_list_add(mlxsw_sp, erif_list,\n\t\t\t\t\t\terif_index);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_mr_tcam_route_create(struct mlxsw_sp *mlxsw_sp, void *priv,\n\t\t\t      void *route_priv,\n\t\t\t      struct mlxsw_sp_mr_route_params *route_params)\n{\n\tconst struct mlxsw_sp_mr_tcam_ops *ops = mlxsw_sp->mr_tcam_ops;\n\tstruct mlxsw_sp_mr_tcam_route *route = route_priv;\n\tstruct mlxsw_sp_mr_tcam *mr_tcam = priv;\n\tint err;\n\n\troute->key = route_params->key;\n\troute->irif_index = route_params->value.irif_index;\n\troute->min_mtu = route_params->value.min_mtu;\n\troute->action = route_params->value.route_action;\n\n\t \n\tmlxsw_sp_mr_erif_list_init(&route->erif_list);\n\terr = mlxsw_sp_mr_tcam_erif_populate(mlxsw_sp, &route->erif_list,\n\t\t\t\t\t     &route_params->value);\n\tif (err)\n\t\tgoto err_erif_populate;\n\n\t \n\terr = mlxsw_sp_flow_counter_alloc(mlxsw_sp, &route->counter_index);\n\tif (err)\n\t\tgoto err_counter_alloc;\n\n\t \n\troute->afa_block = mlxsw_sp_mr_tcam_afa_block_create(mlxsw_sp,\n\t\t\t\t\t\t\t     route->action,\n\t\t\t\t\t\t\t     route->irif_index,\n\t\t\t\t\t\t\t     route->counter_index,\n\t\t\t\t\t\t\t     route->min_mtu,\n\t\t\t\t\t\t\t     &route->erif_list);\n\tif (IS_ERR(route->afa_block)) {\n\t\terr = PTR_ERR(route->afa_block);\n\t\tgoto err_afa_block_create;\n\t}\n\n\troute->priv = kzalloc(ops->route_priv_size, GFP_KERNEL);\n\tif (!route->priv) {\n\t\terr = -ENOMEM;\n\t\tgoto err_route_priv_alloc;\n\t}\n\n\t \n\terr = ops->route_create(mlxsw_sp, mr_tcam->priv, route->priv,\n\t\t\t\t&route->key, route->afa_block,\n\t\t\t\troute_params->prio);\n\tif (err)\n\t\tgoto err_route_create;\n\treturn 0;\n\nerr_route_create:\n\tkfree(route->priv);\nerr_route_priv_alloc:\n\tmlxsw_sp_mr_tcam_afa_block_destroy(route->afa_block);\nerr_afa_block_create:\n\tmlxsw_sp_flow_counter_free(mlxsw_sp, route->counter_index);\nerr_erif_populate:\nerr_counter_alloc:\n\tmlxsw_sp_mr_erif_list_flush(mlxsw_sp, &route->erif_list);\n\treturn err;\n}\n\nstatic void mlxsw_sp_mr_tcam_route_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   void *priv, void *route_priv)\n{\n\tconst struct mlxsw_sp_mr_tcam_ops *ops = mlxsw_sp->mr_tcam_ops;\n\tstruct mlxsw_sp_mr_tcam_route *route = route_priv;\n\tstruct mlxsw_sp_mr_tcam *mr_tcam = priv;\n\n\tops->route_destroy(mlxsw_sp, mr_tcam->priv, route->priv, &route->key);\n\tkfree(route->priv);\n\tmlxsw_sp_mr_tcam_afa_block_destroy(route->afa_block);\n\tmlxsw_sp_flow_counter_free(mlxsw_sp, route->counter_index);\n\tmlxsw_sp_mr_erif_list_flush(mlxsw_sp, &route->erif_list);\n}\n\nstatic int mlxsw_sp_mr_tcam_route_stats(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tvoid *route_priv, u64 *packets,\n\t\t\t\t\tu64 *bytes)\n{\n\tstruct mlxsw_sp_mr_tcam_route *route = route_priv;\n\n\treturn mlxsw_sp_flow_counter_get(mlxsw_sp, route->counter_index,\n\t\t\t\t\t packets, bytes);\n}\n\nstatic int\nmlxsw_sp_mr_tcam_route_action_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     void *route_priv,\n\t\t\t\t     enum mlxsw_sp_mr_route_action route_action)\n{\n\tconst struct mlxsw_sp_mr_tcam_ops *ops = mlxsw_sp->mr_tcam_ops;\n\tstruct mlxsw_sp_mr_tcam_route *route = route_priv;\n\tstruct mlxsw_afa_block *afa_block;\n\tint err;\n\n\t \n\tafa_block = mlxsw_sp_mr_tcam_afa_block_create(mlxsw_sp, route_action,\n\t\t\t\t\t\t      route->irif_index,\n\t\t\t\t\t\t      route->counter_index,\n\t\t\t\t\t\t      route->min_mtu,\n\t\t\t\t\t\t      &route->erif_list);\n\tif (IS_ERR(afa_block))\n\t\treturn PTR_ERR(afa_block);\n\n\t \n\terr = ops->route_update(mlxsw_sp, route->priv, &route->key, afa_block);\n\tif (err)\n\t\tgoto err;\n\n\t \n\tmlxsw_sp_mr_tcam_afa_block_destroy(route->afa_block);\n\troute->afa_block = afa_block;\n\troute->action = route_action;\n\treturn 0;\nerr:\n\tmlxsw_sp_mr_tcam_afa_block_destroy(afa_block);\n\treturn err;\n}\n\nstatic int mlxsw_sp_mr_tcam_route_min_mtu_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t void *route_priv, u16 min_mtu)\n{\n\tconst struct mlxsw_sp_mr_tcam_ops *ops = mlxsw_sp->mr_tcam_ops;\n\tstruct mlxsw_sp_mr_tcam_route *route = route_priv;\n\tstruct mlxsw_afa_block *afa_block;\n\tint err;\n\n\t \n\tafa_block = mlxsw_sp_mr_tcam_afa_block_create(mlxsw_sp,\n\t\t\t\t\t\t      route->action,\n\t\t\t\t\t\t      route->irif_index,\n\t\t\t\t\t\t      route->counter_index,\n\t\t\t\t\t\t      min_mtu,\n\t\t\t\t\t\t      &route->erif_list);\n\tif (IS_ERR(afa_block))\n\t\treturn PTR_ERR(afa_block);\n\n\t \n\terr = ops->route_update(mlxsw_sp, route->priv, &route->key, afa_block);\n\tif (err)\n\t\tgoto err;\n\n\t \n\tmlxsw_sp_mr_tcam_afa_block_destroy(route->afa_block);\n\troute->afa_block = afa_block;\n\troute->min_mtu = min_mtu;\n\treturn 0;\nerr:\n\tmlxsw_sp_mr_tcam_afa_block_destroy(afa_block);\n\treturn err;\n}\n\nstatic int mlxsw_sp_mr_tcam_route_irif_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t      void *route_priv, u16 irif_index)\n{\n\tstruct mlxsw_sp_mr_tcam_route *route = route_priv;\n\n\tif (route->action != MLXSW_SP_MR_ROUTE_ACTION_TRAP)\n\t\treturn -EINVAL;\n\troute->irif_index = irif_index;\n\treturn 0;\n}\n\nstatic int mlxsw_sp_mr_tcam_route_erif_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   void *route_priv, u16 erif_index)\n{\n\tstruct mlxsw_sp_mr_tcam_route *route = route_priv;\n\tint err;\n\n\terr = mlxsw_sp_mr_erif_list_add(mlxsw_sp, &route->erif_list,\n\t\t\t\t\terif_index);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (route->action != MLXSW_SP_MR_ROUTE_ACTION_TRAP)\n\t\treturn mlxsw_sp_mr_erif_list_commit(mlxsw_sp,\n\t\t\t\t\t\t    &route->erif_list);\n\treturn 0;\n}\n\nstatic int mlxsw_sp_mr_tcam_route_erif_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   void *route_priv, u16 erif_index)\n{\n\tconst struct mlxsw_sp_mr_tcam_ops *ops = mlxsw_sp->mr_tcam_ops;\n\tstruct mlxsw_sp_mr_tcam_route *route = route_priv;\n\tstruct mlxsw_sp_mr_erif_sublist *erif_sublist;\n\tstruct mlxsw_sp_mr_tcam_erif_list erif_list;\n\tstruct mlxsw_afa_block *afa_block;\n\tint err;\n\tint i;\n\n\t \n\tmlxsw_sp_mr_erif_list_init(&erif_list);\n\tlist_for_each_entry(erif_sublist, &route->erif_list.erif_sublists, list) {\n\t\tfor (i = 0; i < erif_sublist->num_erifs; i++) {\n\t\t\tu16 curr_erif = erif_sublist->erif_indices[i];\n\n\t\t\tif (curr_erif == erif_index)\n\t\t\t\tcontinue;\n\t\t\terr = mlxsw_sp_mr_erif_list_add(mlxsw_sp, &erif_list,\n\t\t\t\t\t\t\tcurr_erif);\n\t\t\tif (err)\n\t\t\t\tgoto err_erif_list_add;\n\t\t}\n\t}\n\n\t \n\tafa_block = mlxsw_sp_mr_tcam_afa_block_create(mlxsw_sp, route->action,\n\t\t\t\t\t\t      route->irif_index,\n\t\t\t\t\t\t      route->counter_index,\n\t\t\t\t\t\t      route->min_mtu,\n\t\t\t\t\t\t      &erif_list);\n\tif (IS_ERR(afa_block)) {\n\t\terr = PTR_ERR(afa_block);\n\t\tgoto err_afa_block_create;\n\t}\n\n\t \n\terr = ops->route_update(mlxsw_sp, route->priv, &route->key, afa_block);\n\tif (err)\n\t\tgoto err_route_write;\n\n\tmlxsw_sp_mr_tcam_afa_block_destroy(route->afa_block);\n\tmlxsw_sp_mr_erif_list_flush(mlxsw_sp, &route->erif_list);\n\troute->afa_block = afa_block;\n\tmlxsw_sp_mr_erif_list_move(&route->erif_list, &erif_list);\n\treturn 0;\n\nerr_route_write:\n\tmlxsw_sp_mr_tcam_afa_block_destroy(afa_block);\nerr_afa_block_create:\nerr_erif_list_add:\n\tmlxsw_sp_mr_erif_list_flush(mlxsw_sp, &erif_list);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_mr_tcam_route_update(struct mlxsw_sp *mlxsw_sp, void *route_priv,\n\t\t\t      struct mlxsw_sp_mr_route_info *route_info)\n{\n\tconst struct mlxsw_sp_mr_tcam_ops *ops = mlxsw_sp->mr_tcam_ops;\n\tstruct mlxsw_sp_mr_tcam_route *route = route_priv;\n\tstruct mlxsw_sp_mr_tcam_erif_list erif_list;\n\tstruct mlxsw_afa_block *afa_block;\n\tint err;\n\n\t \n\tmlxsw_sp_mr_erif_list_init(&erif_list);\n\terr = mlxsw_sp_mr_tcam_erif_populate(mlxsw_sp, &erif_list, route_info);\n\tif (err)\n\t\tgoto err_erif_populate;\n\n\t \n\tafa_block = mlxsw_sp_mr_tcam_afa_block_create(mlxsw_sp,\n\t\t\t\t\t\t      route_info->route_action,\n\t\t\t\t\t\t      route_info->irif_index,\n\t\t\t\t\t\t      route->counter_index,\n\t\t\t\t\t\t      route_info->min_mtu,\n\t\t\t\t\t\t      &erif_list);\n\tif (IS_ERR(afa_block)) {\n\t\terr = PTR_ERR(afa_block);\n\t\tgoto err_afa_block_create;\n\t}\n\n\t \n\terr = ops->route_update(mlxsw_sp, route->priv, &route->key, afa_block);\n\tif (err)\n\t\tgoto err_route_write;\n\n\tmlxsw_sp_mr_tcam_afa_block_destroy(route->afa_block);\n\tmlxsw_sp_mr_erif_list_flush(mlxsw_sp, &route->erif_list);\n\troute->afa_block = afa_block;\n\tmlxsw_sp_mr_erif_list_move(&route->erif_list, &erif_list);\n\troute->action = route_info->route_action;\n\troute->irif_index = route_info->irif_index;\n\troute->min_mtu = route_info->min_mtu;\n\treturn 0;\n\nerr_route_write:\n\tmlxsw_sp_mr_tcam_afa_block_destroy(afa_block);\nerr_afa_block_create:\nerr_erif_populate:\n\tmlxsw_sp_mr_erif_list_flush(mlxsw_sp, &erif_list);\n\treturn err;\n}\n\nstatic int mlxsw_sp_mr_tcam_init(struct mlxsw_sp *mlxsw_sp, void *priv)\n{\n\tconst struct mlxsw_sp_mr_tcam_ops *ops = mlxsw_sp->mr_tcam_ops;\n\tstruct mlxsw_sp_mr_tcam *mr_tcam = priv;\n\tint err;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, MC_ERIF_LIST_ENTRIES))\n\t\treturn -EIO;\n\n\tmr_tcam->priv = kzalloc(ops->priv_size, GFP_KERNEL);\n\tif (!mr_tcam->priv)\n\t\treturn -ENOMEM;\n\n\terr = ops->init(mlxsw_sp, mr_tcam->priv);\n\tif (err)\n\t\tgoto err_init;\n\treturn 0;\n\nerr_init:\n\tkfree(mr_tcam->priv);\n\treturn err;\n}\n\nstatic void mlxsw_sp_mr_tcam_fini(struct mlxsw_sp *mlxsw_sp, void *priv)\n{\n\tconst struct mlxsw_sp_mr_tcam_ops *ops = mlxsw_sp->mr_tcam_ops;\n\tstruct mlxsw_sp_mr_tcam *mr_tcam = priv;\n\n\tops->fini(mr_tcam->priv);\n\tkfree(mr_tcam->priv);\n}\n\nconst struct mlxsw_sp_mr_ops mlxsw_sp_mr_tcam_ops = {\n\t.priv_size = sizeof(struct mlxsw_sp_mr_tcam),\n\t.route_priv_size = sizeof(struct mlxsw_sp_mr_tcam_route),\n\t.init = mlxsw_sp_mr_tcam_init,\n\t.route_create = mlxsw_sp_mr_tcam_route_create,\n\t.route_update = mlxsw_sp_mr_tcam_route_update,\n\t.route_stats = mlxsw_sp_mr_tcam_route_stats,\n\t.route_action_update = mlxsw_sp_mr_tcam_route_action_update,\n\t.route_min_mtu_update = mlxsw_sp_mr_tcam_route_min_mtu_update,\n\t.route_irif_update = mlxsw_sp_mr_tcam_route_irif_update,\n\t.route_erif_add = mlxsw_sp_mr_tcam_route_erif_add,\n\t.route_erif_del = mlxsw_sp_mr_tcam_route_erif_del,\n\t.route_destroy = mlxsw_sp_mr_tcam_route_destroy,\n\t.fini = mlxsw_sp_mr_tcam_fini,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}