{
  "module_name": "spectrum_acl.c",
  "hash_id": "a8866ff56838561b5c7adbcd77e0ac69c462d90c0972682bda9153abf36977b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/rhashtable.h>\n#include <linux/netdevice.h>\n#include <linux/mutex.h>\n#include <net/net_namespace.h>\n#include <net/tc_act/tc_vlan.h>\n\n#include \"reg.h\"\n#include \"core.h\"\n#include \"resources.h\"\n#include \"spectrum.h\"\n#include \"core_acl_flex_keys.h\"\n#include \"core_acl_flex_actions.h\"\n#include \"spectrum_acl_tcam.h\"\n\nstruct mlxsw_sp_acl {\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct mlxsw_afk *afk;\n\tstruct mlxsw_sp_fid *dummy_fid;\n\tstruct rhashtable ruleset_ht;\n\tstruct list_head rules;\n\tstruct mutex rules_lock;  \n\tstruct {\n\t\tstruct delayed_work dw;\n\t\tunsigned long interval;\t \n#define MLXSW_SP_ACL_RULE_ACTIVITY_UPDATE_PERIOD_MS 1000\n\t} rule_activity_update;\n\tstruct mlxsw_sp_acl_tcam tcam;\n};\n\nstruct mlxsw_afk *mlxsw_sp_acl_afk(struct mlxsw_sp_acl *acl)\n{\n\treturn acl->afk;\n}\n\nstruct mlxsw_sp_acl_tcam *mlxsw_sp_acl_to_tcam(struct mlxsw_sp_acl *acl)\n{\n\treturn &acl->tcam;\n}\n\nstruct mlxsw_sp_acl_ruleset_ht_key {\n\tstruct mlxsw_sp_flow_block *block;\n\tu32 chain_index;\n\tconst struct mlxsw_sp_acl_profile_ops *ops;\n};\n\nstruct mlxsw_sp_acl_ruleset {\n\tstruct rhash_head ht_node;  \n\tstruct mlxsw_sp_acl_ruleset_ht_key ht_key;\n\tstruct rhashtable rule_ht;\n\tunsigned int ref_count;\n\tunsigned int min_prio;\n\tunsigned int max_prio;\n\tunsigned long priv[];\n\t \n};\n\nstruct mlxsw_sp_acl_rule {\n\tstruct rhash_head ht_node;  \n\tstruct list_head list;\n\tunsigned long cookie;  \n\tstruct mlxsw_sp_acl_ruleset *ruleset;\n\tstruct mlxsw_sp_acl_rule_info *rulei;\n\tu64 last_used;\n\tu64 last_packets;\n\tu64 last_bytes;\n\tu64 last_drops;\n\tunsigned long priv[];\n\t \n};\n\nstatic const struct rhashtable_params mlxsw_sp_acl_ruleset_ht_params = {\n\t.key_len = sizeof(struct mlxsw_sp_acl_ruleset_ht_key),\n\t.key_offset = offsetof(struct mlxsw_sp_acl_ruleset, ht_key),\n\t.head_offset = offsetof(struct mlxsw_sp_acl_ruleset, ht_node),\n\t.automatic_shrinking = true,\n};\n\nstatic const struct rhashtable_params mlxsw_sp_acl_rule_ht_params = {\n\t.key_len = sizeof(unsigned long),\n\t.key_offset = offsetof(struct mlxsw_sp_acl_rule, cookie),\n\t.head_offset = offsetof(struct mlxsw_sp_acl_rule, ht_node),\n\t.automatic_shrinking = true,\n};\n\nstruct mlxsw_sp_fid *mlxsw_sp_acl_dummy_fid(struct mlxsw_sp *mlxsw_sp)\n{\n\treturn mlxsw_sp->acl->dummy_fid;\n}\n\nstatic bool\nmlxsw_sp_acl_ruleset_is_singular(const struct mlxsw_sp_acl_ruleset *ruleset)\n{\n\t \n\treturn ruleset->ref_count == 2;\n}\n\nint mlxsw_sp_acl_ruleset_bind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_flow_block *block,\n\t\t\t      struct mlxsw_sp_flow_block_binding *binding)\n{\n\tstruct mlxsw_sp_acl_ruleset *ruleset = block->ruleset_zero;\n\tconst struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;\n\n\treturn ops->ruleset_bind(mlxsw_sp, ruleset->priv,\n\t\t\t\t binding->mlxsw_sp_port, binding->ingress);\n}\n\nvoid mlxsw_sp_acl_ruleset_unbind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_flow_block *block,\n\t\t\t\t struct mlxsw_sp_flow_block_binding *binding)\n{\n\tstruct mlxsw_sp_acl_ruleset *ruleset = block->ruleset_zero;\n\tconst struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;\n\n\tops->ruleset_unbind(mlxsw_sp, ruleset->priv,\n\t\t\t    binding->mlxsw_sp_port, binding->ingress);\n}\n\nstatic int\nmlxsw_sp_acl_ruleset_block_bind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_acl_ruleset *ruleset,\n\t\t\t\tstruct mlxsw_sp_flow_block *block)\n{\n\tstruct mlxsw_sp_flow_block_binding *binding;\n\tint err;\n\n\tblock->ruleset_zero = ruleset;\n\tlist_for_each_entry(binding, &block->binding_list, list) {\n\t\terr = mlxsw_sp_acl_ruleset_bind(mlxsw_sp, block, binding);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\treturn 0;\n\nrollback:\n\tlist_for_each_entry_continue_reverse(binding, &block->binding_list,\n\t\t\t\t\t     list)\n\t\tmlxsw_sp_acl_ruleset_unbind(mlxsw_sp, block, binding);\n\tblock->ruleset_zero = NULL;\n\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_acl_ruleset_block_unbind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_acl_ruleset *ruleset,\n\t\t\t\t  struct mlxsw_sp_flow_block *block)\n{\n\tstruct mlxsw_sp_flow_block_binding *binding;\n\n\tlist_for_each_entry(binding, &block->binding_list, list)\n\t\tmlxsw_sp_acl_ruleset_unbind(mlxsw_sp, block, binding);\n\tblock->ruleset_zero = NULL;\n}\n\nstatic struct mlxsw_sp_acl_ruleset *\nmlxsw_sp_acl_ruleset_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_flow_block *block, u32 chain_index,\n\t\t\t    const struct mlxsw_sp_acl_profile_ops *ops,\n\t\t\t    struct mlxsw_afk_element_usage *tmplt_elusage)\n{\n\tstruct mlxsw_sp_acl *acl = mlxsw_sp->acl;\n\tstruct mlxsw_sp_acl_ruleset *ruleset;\n\tsize_t alloc_size;\n\tint err;\n\n\talloc_size = sizeof(*ruleset) + ops->ruleset_priv_size;\n\truleset = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!ruleset)\n\t\treturn ERR_PTR(-ENOMEM);\n\truleset->ref_count = 1;\n\truleset->ht_key.block = block;\n\truleset->ht_key.chain_index = chain_index;\n\truleset->ht_key.ops = ops;\n\n\terr = rhashtable_init(&ruleset->rule_ht, &mlxsw_sp_acl_rule_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_init;\n\n\terr = ops->ruleset_add(mlxsw_sp, &acl->tcam, ruleset->priv,\n\t\t\t       tmplt_elusage, &ruleset->min_prio,\n\t\t\t       &ruleset->max_prio);\n\tif (err)\n\t\tgoto err_ops_ruleset_add;\n\n\terr = rhashtable_insert_fast(&acl->ruleset_ht, &ruleset->ht_node,\n\t\t\t\t     mlxsw_sp_acl_ruleset_ht_params);\n\tif (err)\n\t\tgoto err_ht_insert;\n\n\treturn ruleset;\n\nerr_ht_insert:\n\tops->ruleset_del(mlxsw_sp, ruleset->priv);\nerr_ops_ruleset_add:\n\trhashtable_destroy(&ruleset->rule_ht);\nerr_rhashtable_init:\n\tkfree(ruleset);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_acl_ruleset_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t struct mlxsw_sp_acl_ruleset *ruleset)\n{\n\tconst struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;\n\tstruct mlxsw_sp_acl *acl = mlxsw_sp->acl;\n\n\trhashtable_remove_fast(&acl->ruleset_ht, &ruleset->ht_node,\n\t\t\t       mlxsw_sp_acl_ruleset_ht_params);\n\tops->ruleset_del(mlxsw_sp, ruleset->priv);\n\trhashtable_destroy(&ruleset->rule_ht);\n\tkfree(ruleset);\n}\n\nstatic void mlxsw_sp_acl_ruleset_ref_inc(struct mlxsw_sp_acl_ruleset *ruleset)\n{\n\truleset->ref_count++;\n}\n\nstatic void mlxsw_sp_acl_ruleset_ref_dec(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t struct mlxsw_sp_acl_ruleset *ruleset)\n{\n\tif (--ruleset->ref_count)\n\t\treturn;\n\tmlxsw_sp_acl_ruleset_destroy(mlxsw_sp, ruleset);\n}\n\nstatic struct mlxsw_sp_acl_ruleset *\n__mlxsw_sp_acl_ruleset_lookup(struct mlxsw_sp_acl *acl,\n\t\t\t      struct mlxsw_sp_flow_block *block, u32 chain_index,\n\t\t\t      const struct mlxsw_sp_acl_profile_ops *ops)\n{\n\tstruct mlxsw_sp_acl_ruleset_ht_key ht_key;\n\n\tmemset(&ht_key, 0, sizeof(ht_key));\n\tht_key.block = block;\n\tht_key.chain_index = chain_index;\n\tht_key.ops = ops;\n\treturn rhashtable_lookup_fast(&acl->ruleset_ht, &ht_key,\n\t\t\t\t      mlxsw_sp_acl_ruleset_ht_params);\n}\n\nstruct mlxsw_sp_acl_ruleset *\nmlxsw_sp_acl_ruleset_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_flow_block *block, u32 chain_index,\n\t\t\t    enum mlxsw_sp_acl_profile profile)\n{\n\tconst struct mlxsw_sp_acl_profile_ops *ops;\n\tstruct mlxsw_sp_acl *acl = mlxsw_sp->acl;\n\tstruct mlxsw_sp_acl_ruleset *ruleset;\n\n\tops = mlxsw_sp_acl_tcam_profile_ops(mlxsw_sp, profile);\n\tif (!ops)\n\t\treturn ERR_PTR(-EINVAL);\n\truleset = __mlxsw_sp_acl_ruleset_lookup(acl, block, chain_index, ops);\n\tif (!ruleset)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn ruleset;\n}\n\nstruct mlxsw_sp_acl_ruleset *\nmlxsw_sp_acl_ruleset_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t struct mlxsw_sp_flow_block *block, u32 chain_index,\n\t\t\t enum mlxsw_sp_acl_profile profile,\n\t\t\t struct mlxsw_afk_element_usage *tmplt_elusage)\n{\n\tconst struct mlxsw_sp_acl_profile_ops *ops;\n\tstruct mlxsw_sp_acl *acl = mlxsw_sp->acl;\n\tstruct mlxsw_sp_acl_ruleset *ruleset;\n\n\tops = mlxsw_sp_acl_tcam_profile_ops(mlxsw_sp, profile);\n\tif (!ops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\truleset = __mlxsw_sp_acl_ruleset_lookup(acl, block, chain_index, ops);\n\tif (ruleset) {\n\t\tmlxsw_sp_acl_ruleset_ref_inc(ruleset);\n\t\treturn ruleset;\n\t}\n\treturn mlxsw_sp_acl_ruleset_create(mlxsw_sp, block, chain_index, ops,\n\t\t\t\t\t   tmplt_elusage);\n}\n\nvoid mlxsw_sp_acl_ruleset_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_acl_ruleset *ruleset)\n{\n\tmlxsw_sp_acl_ruleset_ref_dec(mlxsw_sp, ruleset);\n}\n\nu16 mlxsw_sp_acl_ruleset_group_id(struct mlxsw_sp_acl_ruleset *ruleset)\n{\n\tconst struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;\n\n\treturn ops->ruleset_group_id(ruleset->priv);\n}\n\nvoid mlxsw_sp_acl_ruleset_prio_get(struct mlxsw_sp_acl_ruleset *ruleset,\n\t\t\t\t   unsigned int *p_min_prio,\n\t\t\t\t   unsigned int *p_max_prio)\n{\n\t*p_min_prio = ruleset->min_prio;\n\t*p_max_prio = ruleset->max_prio;\n}\n\nstruct mlxsw_sp_acl_rule_info *\nmlxsw_sp_acl_rulei_create(struct mlxsw_sp_acl *acl,\n\t\t\t  struct mlxsw_afa_block *afa_block)\n{\n\tstruct mlxsw_sp_acl_rule_info *rulei;\n\tint err;\n\n\trulei = kzalloc(sizeof(*rulei), GFP_KERNEL);\n\tif (!rulei)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (afa_block) {\n\t\trulei->act_block = afa_block;\n\t\treturn rulei;\n\t}\n\n\trulei->act_block = mlxsw_afa_block_create(acl->mlxsw_sp->afa);\n\tif (IS_ERR(rulei->act_block)) {\n\t\terr = PTR_ERR(rulei->act_block);\n\t\tgoto err_afa_block_create;\n\t}\n\trulei->action_created = 1;\n\treturn rulei;\n\nerr_afa_block_create:\n\tkfree(rulei);\n\treturn ERR_PTR(err);\n}\n\nvoid mlxsw_sp_acl_rulei_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_acl_rule_info *rulei)\n{\n\tif (rulei->action_created)\n\t\tmlxsw_afa_block_destroy(rulei->act_block);\n\tif (rulei->src_port_range_reg_valid)\n\t\tmlxsw_sp_port_range_reg_put(mlxsw_sp,\n\t\t\t\t\t    rulei->src_port_range_reg_index);\n\tif (rulei->dst_port_range_reg_valid)\n\t\tmlxsw_sp_port_range_reg_put(mlxsw_sp,\n\t\t\t\t\t    rulei->dst_port_range_reg_index);\n\tkfree(rulei);\n}\n\nint mlxsw_sp_acl_rulei_commit(struct mlxsw_sp_acl_rule_info *rulei)\n{\n\treturn mlxsw_afa_block_commit(rulei->act_block);\n}\n\nvoid mlxsw_sp_acl_rulei_priority(struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t unsigned int priority)\n{\n\trulei->priority = priority;\n}\n\nvoid mlxsw_sp_acl_rulei_keymask_u32(struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t    enum mlxsw_afk_element element,\n\t\t\t\t    u32 key_value, u32 mask_value)\n{\n\tmlxsw_afk_values_add_u32(&rulei->values, element,\n\t\t\t\t key_value, mask_value);\n}\n\nvoid mlxsw_sp_acl_rulei_keymask_buf(struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t    enum mlxsw_afk_element element,\n\t\t\t\t    const char *key_value,\n\t\t\t\t    const char *mask_value, unsigned int len)\n{\n\tmlxsw_afk_values_add_buf(&rulei->values, element,\n\t\t\t\t key_value, mask_value, len);\n}\n\nint mlxsw_sp_acl_rulei_act_continue(struct mlxsw_sp_acl_rule_info *rulei)\n{\n\treturn mlxsw_afa_block_continue(rulei->act_block);\n}\n\nint mlxsw_sp_acl_rulei_act_jump(struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\tu16 group_id)\n{\n\treturn mlxsw_afa_block_jump(rulei->act_block, group_id);\n}\n\nint mlxsw_sp_acl_rulei_act_terminate(struct mlxsw_sp_acl_rule_info *rulei)\n{\n\treturn mlxsw_afa_block_terminate(rulei->act_block);\n}\n\nint mlxsw_sp_acl_rulei_act_drop(struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\tbool ingress,\n\t\t\t\tconst struct flow_action_cookie *fa_cookie,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\treturn mlxsw_afa_block_append_drop(rulei->act_block, ingress,\n\t\t\t\t\t   fa_cookie, extack);\n}\n\nint mlxsw_sp_acl_rulei_act_trap(struct mlxsw_sp_acl_rule_info *rulei)\n{\n\treturn mlxsw_afa_block_append_trap(rulei->act_block,\n\t\t\t\t\t   MLXSW_TRAP_ID_ACL0);\n}\n\nint mlxsw_sp_acl_rulei_act_fwd(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t       struct net_device *out_dev,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tu16 local_port;\n\tbool in_port;\n\n\tif (out_dev) {\n\t\tif (!mlxsw_sp_port_dev_check(out_dev)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid output device\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmlxsw_sp_port = netdev_priv(out_dev);\n\t\tif (mlxsw_sp_port->mlxsw_sp != mlxsw_sp) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid output device\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal_port = mlxsw_sp_port->local_port;\n\t\tin_port = false;\n\t} else {\n\t\t \n\t\tlocal_port = 0;\n\t\tin_port = true;\n\t}\n\treturn mlxsw_afa_block_append_fwd(rulei->act_block,\n\t\t\t\t\t  local_port, in_port, extack);\n}\n\nint mlxsw_sp_acl_rulei_act_mirror(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t  struct mlxsw_sp_flow_block *block,\n\t\t\t\t  struct net_device *out_dev,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_flow_block_binding *binding;\n\tstruct mlxsw_sp_port *in_port;\n\n\tif (!list_is_singular(&block->binding_list)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Only a single mirror source is allowed\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tbinding = list_first_entry(&block->binding_list,\n\t\t\t\t   struct mlxsw_sp_flow_block_binding, list);\n\tin_port = binding->mlxsw_sp_port;\n\n\treturn mlxsw_afa_block_append_mirror(rulei->act_block,\n\t\t\t\t\t     in_port->local_port,\n\t\t\t\t\t     out_dev,\n\t\t\t\t\t     binding->ingress,\n\t\t\t\t\t     extack);\n}\n\nint mlxsw_sp_acl_rulei_act_vlan(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\tu32 action, u16 vid, u16 proto, u8 prio,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tu8 ethertype;\n\n\tif (action == FLOW_ACTION_VLAN_MANGLE) {\n\t\tswitch (proto) {\n\t\tcase ETH_P_8021Q:\n\t\t\tethertype = 0;\n\t\t\tbreak;\n\t\tcase ETH_P_8021AD:\n\t\t\tethertype = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported VLAN protocol\");\n\t\t\tdev_err(mlxsw_sp->bus_info->dev, \"Unsupported VLAN protocol %#04x\\n\",\n\t\t\t\tproto);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn mlxsw_afa_block_append_vlan_modify(rulei->act_block,\n\t\t\t\t\t\t\t  vid, prio, ethertype,\n\t\t\t\t\t\t\t  extack);\n\t} else {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported VLAN action\");\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Unsupported VLAN action\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nint mlxsw_sp_acl_rulei_act_priority(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t    u32 prio, struct netlink_ext_ack *extack)\n{\n\t \n\tif (prio >= IEEE_8021QAZ_MAX_TCS) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Only priorities 0..7 are supported\");\n\t\treturn -EINVAL;\n\t}\n\treturn mlxsw_afa_block_append_qos_switch_prio(rulei->act_block, prio,\n\t\t\t\t\t\t      extack);\n}\n\nstruct mlxsw_sp_acl_mangle_action {\n\tenum flow_action_mangle_base htype;\n\t \n\tu32 offset;\n\t \n\tu32 mask;\n\t \n\tu32 shift;\n\tenum mlxsw_sp_acl_mangle_field field;\n};\n\n#define MLXSW_SP_ACL_MANGLE_ACTION(_htype, _offset, _mask, _shift, _field) \\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.htype = _htype,\t\t\t\t\t\\\n\t\t.offset = _offset,\t\t\t\t\t\\\n\t\t.mask = _mask,\t\t\t\t\t\t\\\n\t\t.shift = _shift,\t\t\t\t\t\\\n\t\t.field = MLXSW_SP_ACL_MANGLE_FIELD_##_field,\t\t\\\n\t}\n\n#define MLXSW_SP_ACL_MANGLE_ACTION_IP4(_offset, _mask, _shift, _field) \\\n\tMLXSW_SP_ACL_MANGLE_ACTION(FLOW_ACT_MANGLE_HDR_TYPE_IP4,       \\\n\t\t\t\t   _offset, _mask, _shift, _field)\n\n#define MLXSW_SP_ACL_MANGLE_ACTION_IP6(_offset, _mask, _shift, _field) \\\n\tMLXSW_SP_ACL_MANGLE_ACTION(FLOW_ACT_MANGLE_HDR_TYPE_IP6,       \\\n\t\t\t\t   _offset, _mask, _shift, _field)\n\n#define MLXSW_SP_ACL_MANGLE_ACTION_TCP(_offset, _mask, _shift, _field) \\\n\tMLXSW_SP_ACL_MANGLE_ACTION(FLOW_ACT_MANGLE_HDR_TYPE_TCP, _offset, _mask, _shift, _field)\n\n#define MLXSW_SP_ACL_MANGLE_ACTION_UDP(_offset, _mask, _shift, _field) \\\n\tMLXSW_SP_ACL_MANGLE_ACTION(FLOW_ACT_MANGLE_HDR_TYPE_UDP, _offset, _mask, _shift, _field)\n\nstatic struct mlxsw_sp_acl_mangle_action mlxsw_sp_acl_mangle_actions[] = {\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP4(0, 0xff00ffff, 16, IP_DSFIELD),\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP4(0, 0xff03ffff, 18, IP_DSCP),\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP4(0, 0xfffcffff, 16, IP_ECN),\n\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP6(0, 0xf00fffff, 20, IP_DSFIELD),\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP6(0, 0xf03fffff, 22, IP_DSCP),\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP6(0, 0xffcfffff, 20, IP_ECN),\n\n\tMLXSW_SP_ACL_MANGLE_ACTION_TCP(0, 0x0000ffff, 16, IP_SPORT),\n\tMLXSW_SP_ACL_MANGLE_ACTION_TCP(0, 0xffff0000, 0,  IP_DPORT),\n\n\tMLXSW_SP_ACL_MANGLE_ACTION_UDP(0, 0x0000ffff, 16, IP_SPORT),\n\tMLXSW_SP_ACL_MANGLE_ACTION_UDP(0, 0xffff0000, 0,  IP_DPORT),\n\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP4(12, 0x00000000, 0, IP4_SIP),\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP4(16, 0x00000000, 0, IP4_DIP),\n\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP6(8, 0x00000000, 0, IP6_SIP_1),\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP6(12, 0x00000000, 0, IP6_SIP_2),\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP6(16, 0x00000000, 0, IP6_SIP_3),\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP6(20, 0x00000000, 0, IP6_SIP_4),\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP6(24, 0x00000000, 0, IP6_DIP_1),\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP6(28, 0x00000000, 0, IP6_DIP_2),\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP6(32, 0x00000000, 0, IP6_DIP_3),\n\tMLXSW_SP_ACL_MANGLE_ACTION_IP6(36, 0x00000000, 0, IP6_DIP_4),\n};\n\nstatic int\nmlxsw_sp_acl_rulei_act_mangle_field(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t    struct mlxsw_sp_acl_mangle_action *mact,\n\t\t\t\t    u32 val, struct netlink_ext_ack *extack)\n{\n\tswitch (mact->field) {\n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP_DSFIELD:\n\t\treturn mlxsw_afa_block_append_qos_dsfield(rulei->act_block,\n\t\t\t\t\t\t\t  val, extack);\n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP_DSCP:\n\t\treturn mlxsw_afa_block_append_qos_dscp(rulei->act_block,\n\t\t\t\t\t\t       val, extack);\n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP_ECN:\n\t\treturn mlxsw_afa_block_append_qos_ecn(rulei->act_block,\n\t\t\t\t\t\t      val, extack);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int mlxsw_sp1_acl_rulei_act_mangle_field(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tstruct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t\t\tstruct mlxsw_sp_acl_mangle_action *mact,\n\t\t\t\t\t\tu32 val, struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\terr = mlxsw_sp_acl_rulei_act_mangle_field(mlxsw_sp, rulei, mact, val, extack);\n\tif (err != -EOPNOTSUPP)\n\t\treturn err;\n\n\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported mangle field\");\n\treturn err;\n}\n\nstatic int\nmlxsw_sp2_acl_rulei_act_mangle_field_ip_odd(struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t\t    enum mlxsw_sp_acl_mangle_field field,\n\t\t\t\t\t    u32 val, struct netlink_ext_ack *extack)\n{\n\tif (!rulei->ipv6_valid) {\n\t\trulei->ipv6.prev_val = val;\n\t\trulei->ipv6_valid = true;\n\t\trulei->ipv6.prev_field = field;\n\t\treturn 0;\n\t}\n\n\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported mangle field order\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mlxsw_sp2_acl_rulei_act_mangle_field(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tstruct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t\t\tstruct mlxsw_sp_acl_mangle_action *mact,\n\t\t\t\t\t\tu32 val, struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\terr = mlxsw_sp_acl_rulei_act_mangle_field(mlxsw_sp, rulei, mact, val, extack);\n\tif (err != -EOPNOTSUPP)\n\t\treturn err;\n\n\tswitch (mact->field) {\n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP_SPORT:\n\t\treturn mlxsw_afa_block_append_l4port(rulei->act_block, false, val, extack);\n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP_DPORT:\n\t\treturn mlxsw_afa_block_append_l4port(rulei->act_block, true, val, extack);\n\t \n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP4_SIP:\n\t\treturn mlxsw_afa_block_append_ip(rulei->act_block, false,\n\t\t\t\t\t\t true, val, 0, extack);\n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP4_DIP:\n\t\treturn mlxsw_afa_block_append_ip(rulei->act_block, true,\n\t\t\t\t\t\t true, val, 0, extack);\n\t \n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP6_SIP_1:\n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP6_SIP_3:\n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP6_DIP_1:\n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP6_DIP_3:\n\t\treturn mlxsw_sp2_acl_rulei_act_mangle_field_ip_odd(rulei,\n\t\t\t\t\t\t\t\t   mact->field,\n\t\t\t\t\t\t\t\t   val, extack);\n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP6_SIP_2:\n\t\tif (rulei->ipv6_valid &&\n\t\t    rulei->ipv6.prev_field == MLXSW_SP_ACL_MANGLE_FIELD_IP6_SIP_1) {\n\t\t\trulei->ipv6_valid = false;\n\t\t\treturn mlxsw_afa_block_append_ip(rulei->act_block,\n\t\t\t\t\t\t\t false, false, val,\n\t\t\t\t\t\t\t rulei->ipv6.prev_val,\n\t\t\t\t\t\t\t extack);\n\t\t}\n\t\tbreak;\n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP6_SIP_4:\n\t\tif (rulei->ipv6_valid &&\n\t\t    rulei->ipv6.prev_field == MLXSW_SP_ACL_MANGLE_FIELD_IP6_SIP_3) {\n\t\t\trulei->ipv6_valid = false;\n\t\t\treturn mlxsw_afa_block_append_ip(rulei->act_block,\n\t\t\t\t\t\t\t false, true, val,\n\t\t\t\t\t\t\t rulei->ipv6.prev_val,\n\t\t\t\t\t\t\t extack);\n\t\t}\n\t\tbreak;\n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP6_DIP_2:\n\t\tif (rulei->ipv6_valid &&\n\t\t    rulei->ipv6.prev_field == MLXSW_SP_ACL_MANGLE_FIELD_IP6_DIP_1) {\n\t\t\trulei->ipv6_valid = false;\n\t\t\treturn mlxsw_afa_block_append_ip(rulei->act_block,\n\t\t\t\t\t\t\t true, false, val,\n\t\t\t\t\t\t\t rulei->ipv6.prev_val,\n\t\t\t\t\t\t\t extack);\n\t\t}\n\t\tbreak;\n\tcase MLXSW_SP_ACL_MANGLE_FIELD_IP6_DIP_4:\n\t\tif (rulei->ipv6_valid &&\n\t\t    rulei->ipv6.prev_field == MLXSW_SP_ACL_MANGLE_FIELD_IP6_DIP_3) {\n\t\t\trulei->ipv6_valid = false;\n\t\t\treturn mlxsw_afa_block_append_ip(rulei->act_block,\n\t\t\t\t\t\t\t true, true, val,\n\t\t\t\t\t\t\t rulei->ipv6.prev_val,\n\t\t\t\t\t\t\t extack);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported mangle field\");\n\treturn err;\n}\n\nint mlxsw_sp_acl_rulei_act_mangle(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t  enum flow_action_mangle_base htype,\n\t\t\t\t  u32 offset, u32 mask, u32 val,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tconst struct mlxsw_sp_acl_rulei_ops *acl_rulei_ops = mlxsw_sp->acl_rulei_ops;\n\tstruct mlxsw_sp_acl_mangle_action *mact;\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mlxsw_sp_acl_mangle_actions); ++i) {\n\t\tmact = &mlxsw_sp_acl_mangle_actions[i];\n\t\tif (mact->htype == htype &&\n\t\t    mact->offset == offset &&\n\t\t    mact->mask == mask) {\n\t\t\tval >>= mact->shift;\n\t\t\treturn acl_rulei_ops->act_mangle_field(mlxsw_sp,\n\t\t\t\t\t\t\t       rulei, mact,\n\t\t\t\t\t\t\t       val, extack);\n\t\t}\n\t}\n\n\tNL_SET_ERR_MSG_MOD(extack, \"Unknown mangle field\");\n\treturn -EINVAL;\n}\n\nint mlxsw_sp_acl_rulei_act_police(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t  u32 index, u64 rate_bytes_ps,\n\t\t\t\t  u32 burst, struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\terr = mlxsw_afa_block_append_police(rulei->act_block, index,\n\t\t\t\t\t    rate_bytes_ps, burst,\n\t\t\t\t\t    &rulei->policer_index, extack);\n\tif (err)\n\t\treturn err;\n\n\trulei->policer_index_valid = true;\n\n\treturn 0;\n}\n\nint mlxsw_sp_acl_rulei_act_count(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\terr = mlxsw_afa_block_append_counter(rulei->act_block,\n\t\t\t\t\t     &rulei->counter_index, extack);\n\tif (err)\n\t\treturn err;\n\trulei->counter_valid = true;\n\treturn 0;\n}\n\nint mlxsw_sp_acl_rulei_act_fid_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t   u16 fid, struct netlink_ext_ack *extack)\n{\n\treturn mlxsw_afa_block_append_fid_set(rulei->act_block, fid, extack);\n}\n\nint mlxsw_sp_acl_rulei_act_ignore(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t  bool disable_learning, bool disable_security)\n{\n\treturn mlxsw_afa_block_append_ignore(rulei->act_block,\n\t\t\t\t\t     disable_learning,\n\t\t\t\t\t     disable_security);\n}\n\nint mlxsw_sp_acl_rulei_act_sample(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t  struct mlxsw_sp_flow_block *block,\n\t\t\t\t  struct psample_group *psample_group, u32 rate,\n\t\t\t\t  u32 trunc_size, bool truncate,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_flow_block_binding *binding;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\n\tif (!list_is_singular(&block->binding_list)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Only a single sampling source is allowed\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tbinding = list_first_entry(&block->binding_list,\n\t\t\t\t   struct mlxsw_sp_flow_block_binding, list);\n\tmlxsw_sp_port = binding->mlxsw_sp_port;\n\n\treturn mlxsw_afa_block_append_sampler(rulei->act_block,\n\t\t\t\t\t      mlxsw_sp_port->local_port,\n\t\t\t\t\t      psample_group, rate, trunc_size,\n\t\t\t\t\t      truncate, binding->ingress,\n\t\t\t\t\t      extack);\n}\n\nstruct mlxsw_sp_acl_rule *\nmlxsw_sp_acl_rule_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t struct mlxsw_sp_acl_ruleset *ruleset,\n\t\t\t unsigned long cookie,\n\t\t\t struct mlxsw_afa_block *afa_block,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tconst struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;\n\tstruct mlxsw_sp_acl_rule *rule;\n\tint err;\n\n\tmlxsw_sp_acl_ruleset_ref_inc(ruleset);\n\trule = kzalloc(sizeof(*rule) + ops->rule_priv_size,\n\t\t       GFP_KERNEL);\n\tif (!rule) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\trule->cookie = cookie;\n\trule->ruleset = ruleset;\n\n\trule->rulei = mlxsw_sp_acl_rulei_create(mlxsw_sp->acl, afa_block);\n\tif (IS_ERR(rule->rulei)) {\n\t\terr = PTR_ERR(rule->rulei);\n\t\tgoto err_rulei_create;\n\t}\n\n\treturn rule;\n\nerr_rulei_create:\n\tkfree(rule);\nerr_alloc:\n\tmlxsw_sp_acl_ruleset_ref_dec(mlxsw_sp, ruleset);\n\treturn ERR_PTR(err);\n}\n\nvoid mlxsw_sp_acl_rule_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_acl_rule *rule)\n{\n\tstruct mlxsw_sp_acl_ruleset *ruleset = rule->ruleset;\n\n\tmlxsw_sp_acl_rulei_destroy(mlxsw_sp, rule->rulei);\n\tkfree(rule);\n\tmlxsw_sp_acl_ruleset_ref_dec(mlxsw_sp, ruleset);\n}\n\nint mlxsw_sp_acl_rule_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  struct mlxsw_sp_acl_rule *rule)\n{\n\tstruct mlxsw_sp_acl_ruleset *ruleset = rule->ruleset;\n\tconst struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;\n\tstruct mlxsw_sp_flow_block *block = ruleset->ht_key.block;\n\tint err;\n\n\terr = ops->rule_add(mlxsw_sp, ruleset->priv, rule->priv, rule->rulei);\n\tif (err)\n\t\treturn err;\n\n\terr = rhashtable_insert_fast(&ruleset->rule_ht, &rule->ht_node,\n\t\t\t\t     mlxsw_sp_acl_rule_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_insert;\n\n\tif (!ruleset->ht_key.chain_index &&\n\t    mlxsw_sp_acl_ruleset_is_singular(ruleset)) {\n\t\t \n\t\terr = mlxsw_sp_acl_ruleset_block_bind(mlxsw_sp, ruleset, block);\n\t\tif (err)\n\t\t\tgoto err_ruleset_block_bind;\n\t}\n\n\tmutex_lock(&mlxsw_sp->acl->rules_lock);\n\tlist_add_tail(&rule->list, &mlxsw_sp->acl->rules);\n\tmutex_unlock(&mlxsw_sp->acl->rules_lock);\n\tblock->rule_count++;\n\tblock->ingress_blocker_rule_count += rule->rulei->ingress_bind_blocker;\n\tblock->egress_blocker_rule_count += rule->rulei->egress_bind_blocker;\n\treturn 0;\n\nerr_ruleset_block_bind:\n\trhashtable_remove_fast(&ruleset->rule_ht, &rule->ht_node,\n\t\t\t       mlxsw_sp_acl_rule_ht_params);\nerr_rhashtable_insert:\n\tops->rule_del(mlxsw_sp, rule->priv);\n\treturn err;\n}\n\nvoid mlxsw_sp_acl_rule_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   struct mlxsw_sp_acl_rule *rule)\n{\n\tstruct mlxsw_sp_acl_ruleset *ruleset = rule->ruleset;\n\tconst struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;\n\tstruct mlxsw_sp_flow_block *block = ruleset->ht_key.block;\n\n\tblock->egress_blocker_rule_count -= rule->rulei->egress_bind_blocker;\n\tblock->ingress_blocker_rule_count -= rule->rulei->ingress_bind_blocker;\n\tblock->rule_count--;\n\tmutex_lock(&mlxsw_sp->acl->rules_lock);\n\tlist_del(&rule->list);\n\tmutex_unlock(&mlxsw_sp->acl->rules_lock);\n\tif (!ruleset->ht_key.chain_index &&\n\t    mlxsw_sp_acl_ruleset_is_singular(ruleset))\n\t\tmlxsw_sp_acl_ruleset_block_unbind(mlxsw_sp, ruleset, block);\n\trhashtable_remove_fast(&ruleset->rule_ht, &rule->ht_node,\n\t\t\t       mlxsw_sp_acl_rule_ht_params);\n\tops->rule_del(mlxsw_sp, rule->priv);\n}\n\nint mlxsw_sp_acl_rule_action_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_acl_rule *rule,\n\t\t\t\t     struct mlxsw_afa_block *afa_block)\n{\n\tstruct mlxsw_sp_acl_ruleset *ruleset = rule->ruleset;\n\tconst struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;\n\tstruct mlxsw_sp_acl_rule_info *rulei;\n\n\trulei = mlxsw_sp_acl_rule_rulei(rule);\n\trulei->act_block = afa_block;\n\n\treturn ops->rule_action_replace(mlxsw_sp, rule->priv, rule->rulei);\n}\n\nstruct mlxsw_sp_acl_rule *\nmlxsw_sp_acl_rule_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t struct mlxsw_sp_acl_ruleset *ruleset,\n\t\t\t unsigned long cookie)\n{\n\treturn rhashtable_lookup_fast(&ruleset->rule_ht, &cookie,\n\t\t\t\t       mlxsw_sp_acl_rule_ht_params);\n}\n\nstruct mlxsw_sp_acl_rule_info *\nmlxsw_sp_acl_rule_rulei(struct mlxsw_sp_acl_rule *rule)\n{\n\treturn rule->rulei;\n}\n\nstatic int mlxsw_sp_acl_rule_activity_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t     struct mlxsw_sp_acl_rule *rule)\n{\n\tstruct mlxsw_sp_acl_ruleset *ruleset = rule->ruleset;\n\tconst struct mlxsw_sp_acl_profile_ops *ops = ruleset->ht_key.ops;\n\tbool active;\n\tint err;\n\n\terr = ops->rule_activity_get(mlxsw_sp, rule->priv, &active);\n\tif (err)\n\t\treturn err;\n\tif (active)\n\t\trule->last_used = jiffies;\n\treturn 0;\n}\n\nstatic int mlxsw_sp_acl_rules_activity_update(struct mlxsw_sp_acl *acl)\n{\n\tstruct mlxsw_sp_acl_rule *rule;\n\tint err;\n\n\tmutex_lock(&acl->rules_lock);\n\tlist_for_each_entry(rule, &acl->rules, list) {\n\t\terr = mlxsw_sp_acl_rule_activity_update(acl->mlxsw_sp,\n\t\t\t\t\t\t\trule);\n\t\tif (err)\n\t\t\tgoto err_rule_update;\n\t}\n\tmutex_unlock(&acl->rules_lock);\n\treturn 0;\n\nerr_rule_update:\n\tmutex_unlock(&acl->rules_lock);\n\treturn err;\n}\n\nstatic void mlxsw_sp_acl_rule_activity_work_schedule(struct mlxsw_sp_acl *acl)\n{\n\tunsigned long interval = acl->rule_activity_update.interval;\n\n\tmlxsw_core_schedule_dw(&acl->rule_activity_update.dw,\n\t\t\t       msecs_to_jiffies(interval));\n}\n\nstatic void mlxsw_sp_acl_rule_activity_update_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_acl *acl = container_of(work, struct mlxsw_sp_acl,\n\t\t\t\t\t\trule_activity_update.dw.work);\n\tint err;\n\n\terr = mlxsw_sp_acl_rules_activity_update(acl);\n\tif (err)\n\t\tdev_err(acl->mlxsw_sp->bus_info->dev, \"Could not update acl activity\");\n\n\tmlxsw_sp_acl_rule_activity_work_schedule(acl);\n}\n\nint mlxsw_sp_acl_rule_get_stats(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_acl_rule *rule,\n\t\t\t\tu64 *packets, u64 *bytes, u64 *drops,\n\t\t\t\tu64 *last_use,\n\t\t\t\tenum flow_action_hw_stats *used_hw_stats)\n\n{\n\tenum mlxsw_sp_policer_type type = MLXSW_SP_POLICER_TYPE_SINGLE_RATE;\n\tstruct mlxsw_sp_acl_rule_info *rulei;\n\tu64 current_packets = 0;\n\tu64 current_bytes = 0;\n\tu64 current_drops = 0;\n\tint err;\n\n\trulei = mlxsw_sp_acl_rule_rulei(rule);\n\tif (rulei->counter_valid) {\n\t\terr = mlxsw_sp_flow_counter_get(mlxsw_sp, rulei->counter_index,\n\t\t\t\t\t\t&current_packets,\n\t\t\t\t\t\t&current_bytes);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*used_hw_stats = FLOW_ACTION_HW_STATS_IMMEDIATE;\n\t}\n\tif (rulei->policer_index_valid) {\n\t\terr = mlxsw_sp_policer_drops_counter_get(mlxsw_sp, type,\n\t\t\t\t\t\t\t rulei->policer_index,\n\t\t\t\t\t\t\t &current_drops);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t*packets = current_packets - rule->last_packets;\n\t*bytes = current_bytes - rule->last_bytes;\n\t*drops = current_drops - rule->last_drops;\n\t*last_use = rule->last_used;\n\n\trule->last_bytes = current_bytes;\n\trule->last_packets = current_packets;\n\trule->last_drops = current_drops;\n\n\treturn 0;\n}\n\nint mlxsw_sp_acl_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_fid *fid;\n\tstruct mlxsw_sp_acl *acl;\n\tsize_t alloc_size;\n\tint err;\n\n\talloc_size = sizeof(*acl) + mlxsw_sp_acl_tcam_priv_size(mlxsw_sp);\n\tacl = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!acl)\n\t\treturn -ENOMEM;\n\tmlxsw_sp->acl = acl;\n\tacl->mlxsw_sp = mlxsw_sp;\n\tacl->afk = mlxsw_afk_create(MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t\t\t       ACL_FLEX_KEYS),\n\t\t\t\t    mlxsw_sp->afk_ops);\n\tif (!acl->afk) {\n\t\terr = -ENOMEM;\n\t\tgoto err_afk_create;\n\t}\n\n\terr = rhashtable_init(&acl->ruleset_ht,\n\t\t\t      &mlxsw_sp_acl_ruleset_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_init;\n\n\tfid = mlxsw_sp_fid_dummy_get(mlxsw_sp);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tgoto err_fid_get;\n\t}\n\tacl->dummy_fid = fid;\n\n\tINIT_LIST_HEAD(&acl->rules);\n\tmutex_init(&acl->rules_lock);\n\terr = mlxsw_sp_acl_tcam_init(mlxsw_sp, &acl->tcam);\n\tif (err)\n\t\tgoto err_acl_ops_init;\n\n\t \n\tINIT_DELAYED_WORK(&acl->rule_activity_update.dw,\n\t\t\t  mlxsw_sp_acl_rule_activity_update_work);\n\tacl->rule_activity_update.interval = MLXSW_SP_ACL_RULE_ACTIVITY_UPDATE_PERIOD_MS;\n\tmlxsw_core_schedule_dw(&acl->rule_activity_update.dw, 0);\n\treturn 0;\n\nerr_acl_ops_init:\n\tmutex_destroy(&acl->rules_lock);\n\tmlxsw_sp_fid_put(fid);\nerr_fid_get:\n\trhashtable_destroy(&acl->ruleset_ht);\nerr_rhashtable_init:\n\tmlxsw_afk_destroy(acl->afk);\nerr_afk_create:\n\tkfree(acl);\n\treturn err;\n}\n\nvoid mlxsw_sp_acl_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_acl *acl = mlxsw_sp->acl;\n\n\tcancel_delayed_work_sync(&mlxsw_sp->acl->rule_activity_update.dw);\n\tmlxsw_sp_acl_tcam_fini(mlxsw_sp, &acl->tcam);\n\tmutex_destroy(&acl->rules_lock);\n\tWARN_ON(!list_empty(&acl->rules));\n\tmlxsw_sp_fid_put(acl->dummy_fid);\n\trhashtable_destroy(&acl->ruleset_ht);\n\tmlxsw_afk_destroy(acl->afk);\n\tkfree(acl);\n}\n\nstruct mlxsw_sp_acl_rulei_ops mlxsw_sp1_acl_rulei_ops = {\n\t.act_mangle_field = mlxsw_sp1_acl_rulei_act_mangle_field,\n};\n\nstruct mlxsw_sp_acl_rulei_ops mlxsw_sp2_acl_rulei_ops = {\n\t.act_mangle_field = mlxsw_sp2_acl_rulei_act_mangle_field,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}