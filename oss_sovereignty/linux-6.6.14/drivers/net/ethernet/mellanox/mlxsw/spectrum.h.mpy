{
  "module_name": "spectrum.h",
  "hash_id": "b55b26c245e16b548cad557b3a363c1018dbdbb8f1aa0a56fe0ddca33adcb490",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum.h",
  "human_readable_source": " \n \n\n#ifndef _MLXSW_SPECTRUM_H\n#define _MLXSW_SPECTRUM_H\n\n#include <linux/ethtool.h>\n#include <linux/types.h>\n#include <linux/netdevice.h>\n#include <linux/rhashtable.h>\n#include <linux/bitops.h>\n#include <linux/if_bridge.h>\n#include <linux/if_vlan.h>\n#include <linux/list.h>\n#include <linux/dcbnl.h>\n#include <linux/in6.h>\n#include <linux/notifier.h>\n#include <linux/net_namespace.h>\n#include <linux/spinlock.h>\n#include <net/psample.h>\n#include <net/pkt_cls.h>\n#include <net/red.h>\n#include <net/vxlan.h>\n#include <net/flow_offload.h>\n#include <net/inet_ecn.h>\n\n#include \"port.h\"\n#include \"core.h\"\n#include \"core_acl_flex_keys.h\"\n#include \"core_acl_flex_actions.h\"\n#include \"reg.h\"\n\n#define MLXSW_SP_DEFAULT_VID (VLAN_N_VID - 1)\n\n#define MLXSW_SP_FID_8021D_MAX 1024\n\n#define MLXSW_SP_MID_MAX 7000\n\n#define MLXSW_SP_KVD_LINEAR_SIZE 98304  \n#define MLXSW_SP_KVD_GRANULARITY 128\n\n#define MLXSW_SP_RESOURCE_NAME_KVD \"kvd\"\n#define MLXSW_SP_RESOURCE_NAME_KVD_LINEAR \"linear\"\n#define MLXSW_SP_RESOURCE_NAME_KVD_HASH_SINGLE \"hash_single\"\n#define MLXSW_SP_RESOURCE_NAME_KVD_HASH_DOUBLE \"hash_double\"\n#define MLXSW_SP_RESOURCE_NAME_KVD_LINEAR_SINGLES \"singles\"\n#define MLXSW_SP_RESOURCE_NAME_KVD_LINEAR_CHUNKS \"chunks\"\n#define MLXSW_SP_RESOURCE_NAME_KVD_LINEAR_LARGE_CHUNKS \"large_chunks\"\n\n#define MLXSW_SP_RESOURCE_NAME_SPAN \"span_agents\"\n\n#define MLXSW_SP_RESOURCE_NAME_COUNTERS \"counters\"\n#define MLXSW_SP_RESOURCE_NAME_COUNTERS_FLOW \"flow\"\n#define MLXSW_SP_RESOURCE_NAME_COUNTERS_RIF \"rif\"\n\nenum mlxsw_sp_resource_id {\n\tMLXSW_SP_RESOURCE_KVD = MLXSW_CORE_RESOURCE_MAX,\n\tMLXSW_SP_RESOURCE_KVD_LINEAR,\n\tMLXSW_SP_RESOURCE_KVD_HASH_SINGLE,\n\tMLXSW_SP_RESOURCE_KVD_HASH_DOUBLE,\n\tMLXSW_SP_RESOURCE_KVD_LINEAR_SINGLE,\n\tMLXSW_SP_RESOURCE_KVD_LINEAR_CHUNKS,\n\tMLXSW_SP_RESOURCE_KVD_LINEAR_LARGE_CHUNKS,\n\tMLXSW_SP_RESOURCE_SPAN,\n\tMLXSW_SP_RESOURCE_COUNTERS,\n\tMLXSW_SP_RESOURCE_COUNTERS_FLOW,\n\tMLXSW_SP_RESOURCE_COUNTERS_RIF,\n\tMLXSW_SP_RESOURCE_GLOBAL_POLICERS,\n\tMLXSW_SP_RESOURCE_SINGLE_RATE_POLICERS,\n\tMLXSW_SP_RESOURCE_RIF_MAC_PROFILES,\n\tMLXSW_SP_RESOURCE_RIFS,\n\tMLXSW_SP_RESOURCE_PORT_RANGE_REGISTERS,\n};\n\nstruct mlxsw_sp_port;\nstruct mlxsw_sp_rif;\nstruct mlxsw_sp_span_entry;\nenum mlxsw_sp_l3proto;\nunion mlxsw_sp_l3addr;\n\nstruct mlxsw_sp_upper {\n\tstruct net_device *dev;\n\tunsigned int ref_count;\n};\n\nenum mlxsw_sp_rif_type {\n\tMLXSW_SP_RIF_TYPE_SUBPORT,\n\tMLXSW_SP_RIF_TYPE_VLAN,\n\tMLXSW_SP_RIF_TYPE_FID,\n\tMLXSW_SP_RIF_TYPE_IPIP_LB,  \n\tMLXSW_SP_RIF_TYPE_MAX,\n};\n\nstruct mlxsw_sp_router_ops;\n\nextern const struct mlxsw_sp_router_ops mlxsw_sp1_router_ops;\nextern const struct mlxsw_sp_router_ops mlxsw_sp2_router_ops;\n\nstruct mlxsw_sp_switchdev_ops;\n\nextern const struct mlxsw_sp_switchdev_ops mlxsw_sp1_switchdev_ops;\nextern const struct mlxsw_sp_switchdev_ops mlxsw_sp2_switchdev_ops;\n\nenum mlxsw_sp_fid_type {\n\tMLXSW_SP_FID_TYPE_8021Q,\n\tMLXSW_SP_FID_TYPE_8021D,\n\tMLXSW_SP_FID_TYPE_RFID,\n\tMLXSW_SP_FID_TYPE_DUMMY,\n\tMLXSW_SP_FID_TYPE_MAX,\n};\n\nenum mlxsw_sp_nve_type {\n\tMLXSW_SP_NVE_TYPE_VXLAN,\n};\n\nstruct mlxsw_sp_sb;\nstruct mlxsw_sp_bridge;\nstruct mlxsw_sp_router;\nstruct mlxsw_sp_mr;\nstruct mlxsw_sp_acl;\nstruct mlxsw_sp_counter_pool;\nstruct mlxsw_sp_fid_core;\nstruct mlxsw_sp_kvdl;\nstruct mlxsw_sp_nve;\nstruct mlxsw_sp_kvdl_ops;\nstruct mlxsw_sp_mr_tcam_ops;\nstruct mlxsw_sp_acl_rulei_ops;\nstruct mlxsw_sp_acl_tcam_ops;\nstruct mlxsw_sp_nve_ops;\nstruct mlxsw_sp_sb_ops;\nstruct mlxsw_sp_sb_vals;\nstruct mlxsw_sp_port_type_speed_ops;\nstruct mlxsw_sp_ptp_state;\nstruct mlxsw_sp_ptp_ops;\nstruct mlxsw_sp_span_ops;\nstruct mlxsw_sp_qdisc_state;\nstruct mlxsw_sp_mall_entry;\nstruct mlxsw_sp_pgt;\n\nstruct mlxsw_sp_port_mapping {\n\tu8 module;\n\tu8 slot_index;\n\tu8 width;  \n\tu8 module_width;  \n\tu8 lane;\n};\n\nstruct mlxsw_sp_port_mapping_events {\n\tstruct list_head queue;\n\tspinlock_t queue_lock;  \n\tstruct work_struct work;\n};\n\nstruct mlxsw_sp_parsing {\n\trefcount_t parsing_depth_ref;\n\tu16 parsing_depth;\n\tu16 vxlan_udp_dport;\n\tstruct mutex lock;  \n};\n\nstruct mlxsw_sp {\n\tstruct mlxsw_sp_port **ports;\n\tstruct mlxsw_core *core;\n\tconst struct mlxsw_bus_info *bus_info;\n\tunsigned char base_mac[ETH_ALEN];\n\tconst unsigned char *mac_mask;\n\tstruct mlxsw_sp_upper *lags;\n\tstruct mlxsw_sp_port_mapping *port_mapping;\n\tstruct mlxsw_sp_port_mapping_events port_mapping_events;\n\tstruct rhashtable sample_trigger_ht;\n\tstruct mlxsw_sp_sb *sb;\n\tstruct mlxsw_sp_bridge *bridge;\n\tstruct mlxsw_sp_router *router;\n\tstruct mlxsw_sp_mr *mr;\n\tstruct mlxsw_afa *afa;\n\tstruct mlxsw_sp_acl *acl;\n\tstruct mlxsw_sp_fid_core *fid_core;\n\tstruct mlxsw_sp_policer_core *policer_core;\n\tstruct mlxsw_sp_port_range_core *pr_core;\n\tstruct mlxsw_sp_kvdl *kvdl;\n\tstruct mlxsw_sp_nve *nve;\n\tstruct notifier_block netdevice_nb;\n\tstruct mlxsw_sp_ptp_clock *clock;\n\tstruct mlxsw_sp_ptp_state *ptp_state;\n\tstruct mlxsw_sp_counter_pool *counter_pool;\n\tstruct mlxsw_sp_span *span;\n\tstruct mlxsw_sp_trap *trap;\n\tstruct mlxsw_sp_parsing parsing;\n\tconst struct mlxsw_sp_switchdev_ops *switchdev_ops;\n\tconst struct mlxsw_sp_kvdl_ops *kvdl_ops;\n\tconst struct mlxsw_afa_ops *afa_ops;\n\tconst struct mlxsw_afk_ops *afk_ops;\n\tconst struct mlxsw_sp_mr_tcam_ops *mr_tcam_ops;\n\tconst struct mlxsw_sp_acl_rulei_ops *acl_rulei_ops;\n\tconst struct mlxsw_sp_acl_tcam_ops *acl_tcam_ops;\n\tconst struct mlxsw_sp_acl_bf_ops *acl_bf_ops;\n\tconst struct mlxsw_sp_nve_ops **nve_ops_arr;\n\tconst struct mlxsw_sp_sb_vals *sb_vals;\n\tconst struct mlxsw_sp_sb_ops *sb_ops;\n\tconst struct mlxsw_sp_port_type_speed_ops *port_type_speed_ops;\n\tconst struct mlxsw_sp_ptp_ops *ptp_ops;\n\tconst struct mlxsw_sp_span_ops *span_ops;\n\tconst struct mlxsw_sp_policer_core_ops *policer_core_ops;\n\tconst struct mlxsw_sp_trap_ops *trap_ops;\n\tconst struct mlxsw_sp_mall_ops *mall_ops;\n\tconst struct mlxsw_sp_router_ops *router_ops;\n\tconst struct mlxsw_listener *listeners;\n\tconst struct mlxsw_sp_fid_family **fid_family_arr;\n\tsize_t listeners_count;\n\tu32 lowest_shaper_bs;\n\tstruct rhashtable ipv6_addr_ht;\n\tstruct mutex ipv6_addr_ht_lock;  \n\tstruct mlxsw_sp_pgt *pgt;\n\tbool pgt_smpe_index_valid;\n};\n\nstruct mlxsw_sp_ptp_ops {\n\tstruct mlxsw_sp_ptp_clock *\n\t\t(*clock_init)(struct mlxsw_sp *mlxsw_sp, struct device *dev);\n\tvoid (*clock_fini)(struct mlxsw_sp_ptp_clock *clock);\n\n\tstruct mlxsw_sp_ptp_state *(*init)(struct mlxsw_sp *mlxsw_sp);\n\tvoid (*fini)(struct mlxsw_sp_ptp_state *ptp_state);\n\n\t \n\tvoid (*receive)(struct mlxsw_sp *mlxsw_sp, struct sk_buff *skb,\n\t\t\tu16 local_port);\n\n\t \n\tvoid (*transmitted)(struct mlxsw_sp *mlxsw_sp, struct sk_buff *skb,\n\t\t\t    u16 local_port);\n\n\tint (*hwtstamp_get)(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t    struct hwtstamp_config *config);\n\tint (*hwtstamp_set)(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t    struct hwtstamp_config *config);\n\tvoid (*shaper_work)(struct work_struct *work);\n\tint (*get_ts_info)(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   struct ethtool_ts_info *info);\n\tint (*get_stats_count)(void);\n\tvoid (*get_stats_strings)(u8 **p);\n\tvoid (*get_stats)(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t  u64 *data, int data_index);\n\tint (*txhdr_construct)(struct mlxsw_core *mlxsw_core,\n\t\t\t       struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       const struct mlxsw_tx_info *tx_info);\n};\n\nstatic inline struct mlxsw_sp_upper *\nmlxsw_sp_lag_get(struct mlxsw_sp *mlxsw_sp, u16 lag_id)\n{\n\treturn &mlxsw_sp->lags[lag_id];\n}\n\nstruct mlxsw_sp_port_pcpu_stats {\n\tu64\t\t\trx_packets;\n\tu64\t\t\trx_bytes;\n\tu64\t\t\ttx_packets;\n\tu64\t\t\ttx_bytes;\n\tstruct u64_stats_sync\tsyncp;\n\tu32\t\t\ttx_dropped;\n};\n\nenum mlxsw_sp_sample_trigger_type {\n\tMLXSW_SP_SAMPLE_TRIGGER_TYPE_INGRESS,\n\tMLXSW_SP_SAMPLE_TRIGGER_TYPE_EGRESS,\n\tMLXSW_SP_SAMPLE_TRIGGER_TYPE_POLICY_ENGINE,\n};\n\nstruct mlxsw_sp_sample_trigger {\n\tenum mlxsw_sp_sample_trigger_type type;\n\tu16 local_port;  \n};\n\nstruct mlxsw_sp_sample_params {\n\tstruct psample_group *psample_group;\n\tu32 trunc_size;\n\tu32 rate;\n\tbool truncate;\n};\n\nstruct mlxsw_sp_bridge_port;\nstruct mlxsw_sp_fid;\n\nstruct mlxsw_sp_port_vlan {\n\tstruct list_head list;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tstruct mlxsw_sp_fid *fid;\n\tu16 vid;\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tstruct list_head bridge_vlan_node;\n};\n\n \nstruct mlxsw_sp_port_xstats {\n\tu64 ecn;\n\tu64 tc_ecn[TC_MAX_QUEUE];\n\tu64 wred_drop[TC_MAX_QUEUE];\n\tu64 tail_drop[TC_MAX_QUEUE];\n\tu64 backlog[TC_MAX_QUEUE];\n\tu64 tx_bytes[IEEE_8021QAZ_MAX_TCS];\n\tu64 tx_packets[IEEE_8021QAZ_MAX_TCS];\n};\n\nstruct mlxsw_sp_ptp_port_dir_stats {\n\tu64 packets;\n\tu64 timestamps;\n};\n\nstruct mlxsw_sp_ptp_port_stats {\n\tstruct mlxsw_sp_ptp_port_dir_stats rx_gcd;\n\tstruct mlxsw_sp_ptp_port_dir_stats tx_gcd;\n};\n\nstruct mlxsw_sp_port {\n\tstruct net_device *dev;\n\tstruct mlxsw_sp_port_pcpu_stats __percpu *pcpu_stats;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tu16 local_port;\n\tu8 lagged:1,\n\t   split:1,\n\t   security:1;\n\tu16 pvid;\n\tu16 lag_id;\n\tstruct {\n\t\tu8 tx_pause:1,\n\t\t   rx_pause:1,\n\t\t   autoneg:1;\n\t} link;\n\tstruct {\n\t\tstruct ieee_ets *ets;\n\t\tstruct ieee_maxrate *maxrate;\n\t\tstruct ieee_pfc *pfc;\n\t\tenum mlxsw_reg_qpts_trust_state trust_state;\n\t} dcb;\n\tstruct mlxsw_sp_port_mapping mapping;  \n\tstruct {\n\t\t#define MLXSW_HW_STATS_UPDATE_TIME HZ\n\t\tstruct rtnl_link_stats64 stats;\n\t\tstruct mlxsw_sp_port_xstats xstats;\n\t\tstruct delayed_work update_dw;\n\t} periodic_hw_stats;\n\tstruct list_head vlans_list;\n\tstruct mlxsw_sp_port_vlan *default_vlan;\n\tstruct mlxsw_sp_qdisc_state *qdisc;\n\tunsigned acl_rule_count;\n\tstruct mlxsw_sp_flow_block *ing_flow_block;\n\tstruct mlxsw_sp_flow_block *eg_flow_block;\n\tstruct {\n\t\tstruct delayed_work shaper_dw;\n\t\tstruct hwtstamp_config hwtstamp_config;\n\t\tu16 ing_types;\n\t\tu16 egr_types;\n\t\tstruct mlxsw_sp_ptp_port_stats stats;\n\t} ptp;\n\tint max_mtu;\n\tu32 max_speed;\n\tstruct mlxsw_sp_hdroom *hdroom;\n\tu64 module_overheat_initial_val;\n};\n\nstruct mlxsw_sp_port_type_speed_ops {\n\tvoid (*from_ptys_supported_port)(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t u32 ptys_eth_proto,\n\t\t\t\t\t struct ethtool_link_ksettings *cmd);\n\tvoid (*from_ptys_link)(struct mlxsw_sp *mlxsw_sp, u32 ptys_eth_proto,\n\t\t\t       unsigned long *mode);\n\tu32 (*from_ptys_speed)(struct mlxsw_sp *mlxsw_sp, u32 ptys_eth_proto);\n\tvoid (*from_ptys_link_mode)(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    bool carrier_ok, u32 ptys_eth_proto,\n\t\t\t\t    struct ethtool_link_ksettings *cmd);\n\tint (*ptys_max_speed)(struct mlxsw_sp_port *mlxsw_sp_port, u32 *p_max_speed);\n\tu32 (*to_ptys_advert_link)(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd);\n\tu32 (*to_ptys_speed_lanes)(struct mlxsw_sp *mlxsw_sp, u8 width,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd);\n\tvoid (*reg_ptys_eth_pack)(struct mlxsw_sp *mlxsw_sp, char *payload,\n\t\t\t\t  u16 local_port, u32 proto_admin, bool autoneg);\n\tvoid (*reg_ptys_eth_unpack)(struct mlxsw_sp *mlxsw_sp, char *payload,\n\t\t\t\t    u32 *p_eth_proto_cap,\n\t\t\t\t    u32 *p_eth_proto_admin,\n\t\t\t\t    u32 *p_eth_proto_oper);\n\tu32 (*ptys_proto_cap_masked_get)(u32 eth_proto_cap);\n};\n\nstruct mlxsw_sp_ports_bitmap {\n\tunsigned long *bitmap;\n\tunsigned int nbits;\n};\n\nstatic inline int\nmlxsw_sp_port_bitmap_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  struct mlxsw_sp_ports_bitmap *ports_bm)\n{\n\tunsigned int nbits = mlxsw_core_max_ports(mlxsw_sp->core);\n\n\tports_bm->nbits = nbits;\n\tports_bm->bitmap = bitmap_zalloc(nbits, GFP_KERNEL);\n\tif (!ports_bm->bitmap)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic inline void\nmlxsw_sp_port_bitmap_fini(struct mlxsw_sp_ports_bitmap *ports_bm)\n{\n\tbitmap_free(ports_bm->bitmap);\n}\n\nstatic inline u8 mlxsw_sp_tunnel_ecn_decap(u8 outer_ecn, u8 inner_ecn,\n\t\t\t\t\t   bool *trap_en)\n{\n\tbool set_ce = false;\n\n\t*trap_en = !!__INET_ECN_decapsulate(outer_ecn, inner_ecn, &set_ce);\n\tif (set_ce)\n\t\treturn INET_ECN_CE;\n\telse if (outer_ecn == INET_ECN_ECT_1 && inner_ecn == INET_ECN_ECT_0)\n\t\treturn INET_ECN_ECT_1;\n\telse\n\t\treturn inner_ecn;\n}\n\nstatic inline struct net_device *\nmlxsw_sp_bridge_vxlan_dev_find(struct net_device *br_dev)\n{\n\tstruct net_device *dev;\n\tstruct list_head *iter;\n\n\tnetdev_for_each_lower_dev(br_dev, dev, iter) {\n\t\tif (netif_is_vxlan(dev))\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n\nstatic inline bool mlxsw_sp_bridge_has_vxlan(struct net_device *br_dev)\n{\n\treturn !!mlxsw_sp_bridge_vxlan_dev_find(br_dev);\n}\n\nstatic inline int\nmlxsw_sp_vxlan_mapped_vid(const struct net_device *vxlan_dev, u16 *p_vid)\n{\n\tstruct bridge_vlan_info vinfo;\n\tu16 vid = 0;\n\tint err;\n\n\terr = br_vlan_get_pvid(vxlan_dev, &vid);\n\tif (err || !vid)\n\t\tgoto out;\n\n\terr = br_vlan_get_info(vxlan_dev, vid, &vinfo);\n\tif (err || !(vinfo.flags & BRIDGE_VLAN_INFO_UNTAGGED))\n\t\tvid = 0;\n\nout:\n\t*p_vid = vid;\n\treturn err;\n}\n\nstatic inline bool\nmlxsw_sp_port_is_pause_en(const struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\treturn mlxsw_sp_port->link.tx_pause || mlxsw_sp_port->link.rx_pause;\n}\n\nstatic inline struct mlxsw_sp_port *\nmlxsw_sp_port_lagged_get(struct mlxsw_sp *mlxsw_sp, u16 lag_id, u8 port_index)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tu16 local_port;\n\n\tlocal_port = mlxsw_core_lag_mapping_get(mlxsw_sp->core,\n\t\t\t\t\t\tlag_id, port_index);\n\tmlxsw_sp_port = mlxsw_sp->ports[local_port];\n\treturn mlxsw_sp_port && mlxsw_sp_port->lagged ? mlxsw_sp_port : NULL;\n}\n\nstatic inline struct mlxsw_sp_port_vlan *\nmlxsw_sp_port_vlan_find_by_vid(const struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t       u16 vid)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\n\tlist_for_each_entry(mlxsw_sp_port_vlan, &mlxsw_sp_port->vlans_list,\n\t\t\t    list) {\n\t\tif (mlxsw_sp_port_vlan->vid == vid)\n\t\t\treturn mlxsw_sp_port_vlan;\n\t}\n\n\treturn NULL;\n}\n\nenum mlxsw_sp_flood_type {\n\tMLXSW_SP_FLOOD_TYPE_UC,\n\tMLXSW_SP_FLOOD_TYPE_BC,\n\tMLXSW_SP_FLOOD_TYPE_MC,\n};\n\nint mlxsw_sp_port_get_stats_raw(struct net_device *dev, int grp,\n\t\t\t\tint prio, char *ppcnt_pl);\nint mlxsw_sp_port_admin_status_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t   bool is_up);\nint\nmlxsw_sp_port_vlan_classification_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      bool is_8021ad_tagged,\n\t\t\t\t      bool is_8021q_tagged);\nstatic inline bool\nmlxsw_sp_local_port_is_valid(struct mlxsw_sp *mlxsw_sp, u16 local_port)\n{\n\tunsigned int max_ports = mlxsw_core_max_ports(mlxsw_sp->core);\n\n\treturn local_port < max_ports && local_port;\n}\n\n \nstruct mlxsw_sp_hdroom_prio {\n\t \n\tu8 buf_idx;\n\t \n\tu8 ets_buf_idx;\n\t \n\tu8 set_buf_idx;\n\tbool lossy;\n};\n\nstruct mlxsw_sp_hdroom_buf {\n\tu32 thres_cells;\n\tu32 size_cells;\n\t \n\tu32 set_size_cells;\n\tbool lossy;\n};\n\nenum mlxsw_sp_hdroom_mode {\n\tMLXSW_SP_HDROOM_MODE_DCB,\n\tMLXSW_SP_HDROOM_MODE_TC,\n};\n\n#define MLXSW_SP_PB_COUNT 10\n\nstruct mlxsw_sp_hdroom {\n\tenum mlxsw_sp_hdroom_mode mode;\n\n\tstruct {\n\t\tstruct mlxsw_sp_hdroom_prio prio[IEEE_8021Q_MAX_PRIORITIES];\n\t} prios;\n\tstruct {\n\t\tstruct mlxsw_sp_hdroom_buf buf[MLXSW_SP_PB_COUNT];\n\t} bufs;\n\tstruct {\n\t\t \n\t\tu32 size_cells;\n\t\t \n\t\tu32 reserve_cells;\n\t\tbool enable;\n\t} int_buf;\n\tint delay_bytes;\n\tint mtu;\n};\n\nint mlxsw_sp_buffers_init(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_buffers_fini(struct mlxsw_sp *mlxsw_sp);\nint mlxsw_sp_port_buffers_init(struct mlxsw_sp_port *mlxsw_sp_port);\nvoid mlxsw_sp_port_buffers_fini(struct mlxsw_sp_port *mlxsw_sp_port);\nint mlxsw_sp_sb_pool_get(struct mlxsw_core *mlxsw_core,\n\t\t\t unsigned int sb_index, u16 pool_index,\n\t\t\t struct devlink_sb_pool_info *pool_info);\nint mlxsw_sp_sb_pool_set(struct mlxsw_core *mlxsw_core,\n\t\t\t unsigned int sb_index, u16 pool_index, u32 size,\n\t\t\t enum devlink_sb_threshold_type threshold_type,\n\t\t\t struct netlink_ext_ack *extack);\nint mlxsw_sp_sb_port_pool_get(struct mlxsw_core_port *mlxsw_core_port,\n\t\t\t      unsigned int sb_index, u16 pool_index,\n\t\t\t      u32 *p_threshold);\nint mlxsw_sp_sb_port_pool_set(struct mlxsw_core_port *mlxsw_core_port,\n\t\t\t      unsigned int sb_index, u16 pool_index,\n\t\t\t      u32 threshold, struct netlink_ext_ack *extack);\nint mlxsw_sp_sb_tc_pool_bind_get(struct mlxsw_core_port *mlxsw_core_port,\n\t\t\t\t unsigned int sb_index, u16 tc_index,\n\t\t\t\t enum devlink_sb_pool_type pool_type,\n\t\t\t\t u16 *p_pool_index, u32 *p_threshold);\nint mlxsw_sp_sb_tc_pool_bind_set(struct mlxsw_core_port *mlxsw_core_port,\n\t\t\t\t unsigned int sb_index, u16 tc_index,\n\t\t\t\t enum devlink_sb_pool_type pool_type,\n\t\t\t\t u16 pool_index, u32 threshold,\n\t\t\t\t struct netlink_ext_ack *extack);\nint mlxsw_sp_sb_occ_snapshot(struct mlxsw_core *mlxsw_core,\n\t\t\t     unsigned int sb_index);\nint mlxsw_sp_sb_occ_max_clear(struct mlxsw_core *mlxsw_core,\n\t\t\t      unsigned int sb_index);\nint mlxsw_sp_sb_occ_port_pool_get(struct mlxsw_core_port *mlxsw_core_port,\n\t\t\t\t  unsigned int sb_index, u16 pool_index,\n\t\t\t\t  u32 *p_cur, u32 *p_max);\nint mlxsw_sp_sb_occ_tc_port_bind_get(struct mlxsw_core_port *mlxsw_core_port,\n\t\t\t\t     unsigned int sb_index, u16 tc_index,\n\t\t\t\t     enum devlink_sb_pool_type pool_type,\n\t\t\t\t     u32 *p_cur, u32 *p_max);\nu32 mlxsw_sp_cells_bytes(const struct mlxsw_sp *mlxsw_sp, u32 cells);\nu32 mlxsw_sp_bytes_cells(const struct mlxsw_sp *mlxsw_sp, u32 bytes);\nvoid mlxsw_sp_hdroom_prios_reset_buf_idx(struct mlxsw_sp_hdroom *hdroom);\nvoid mlxsw_sp_hdroom_bufs_reset_lossiness(struct mlxsw_sp_hdroom *hdroom);\nvoid mlxsw_sp_hdroom_bufs_reset_sizes(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      struct mlxsw_sp_hdroom *hdroom);\nint mlxsw_sp_hdroom_configure(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t      const struct mlxsw_sp_hdroom *hdroom);\nstruct mlxsw_sp_sample_params *\nmlxsw_sp_sample_trigger_params_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      const struct mlxsw_sp_sample_trigger *trigger);\nint\nmlxsw_sp_sample_trigger_params_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   const struct mlxsw_sp_sample_trigger *trigger,\n\t\t\t\t   const struct mlxsw_sp_sample_params *params,\n\t\t\t\t   struct netlink_ext_ack *extack);\nvoid\nmlxsw_sp_sample_trigger_params_unset(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     const struct mlxsw_sp_sample_trigger *trigger);\nint mlxsw_sp_ipv6_addr_kvdl_index_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      const struct in6_addr *addr6,\n\t\t\t\t      u32 *p_kvdl_index);\nvoid\nmlxsw_sp_ipv6_addr_put(struct mlxsw_sp *mlxsw_sp, const struct in6_addr *addr6);\n\nextern const struct mlxsw_sp_sb_vals mlxsw_sp1_sb_vals;\nextern const struct mlxsw_sp_sb_vals mlxsw_sp2_sb_vals;\n\nextern const struct mlxsw_sp_sb_ops mlxsw_sp1_sb_ops;\nextern const struct mlxsw_sp_sb_ops mlxsw_sp2_sb_ops;\nextern const struct mlxsw_sp_sb_ops mlxsw_sp3_sb_ops;\n\n \nint mlxsw_sp_switchdev_init(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_switchdev_fini(struct mlxsw_sp *mlxsw_sp);\nint mlxsw_sp_rif_fdb_op(struct mlxsw_sp *mlxsw_sp, const char *mac, u16 fid,\n\t\t\tbool adding);\nvoid\nmlxsw_sp_port_vlan_bridge_leave(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan);\nint mlxsw_sp_port_bridge_join(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t      struct net_device *brport_dev,\n\t\t\t      struct net_device *br_dev,\n\t\t\t      struct netlink_ext_ack *extack);\nvoid mlxsw_sp_port_bridge_leave(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\tstruct net_device *brport_dev,\n\t\t\t\tstruct net_device *br_dev);\nbool mlxsw_sp_bridge_device_is_offloaded(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t const struct net_device *br_dev);\nint mlxsw_sp_bridge_vxlan_join(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       const struct net_device *br_dev,\n\t\t\t       const struct net_device *vxlan_dev, u16 vid,\n\t\t\t       struct netlink_ext_ack *extack);\nvoid mlxsw_sp_bridge_vxlan_leave(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t const struct net_device *vxlan_dev);\nextern struct notifier_block mlxsw_sp_switchdev_notifier;\n\n \nvoid mlxsw_sp_rx_listener_no_mark_func(struct sk_buff *skb,\n\t\t\t\t       u16 local_port, void *priv);\nvoid mlxsw_sp_ptp_receive(struct mlxsw_sp *mlxsw_sp, struct sk_buff *skb,\n\t\t\t  u16 local_port);\nint mlxsw_sp_port_speed_get(struct mlxsw_sp_port *mlxsw_sp_port, u32 *speed);\nint mlxsw_sp_port_ets_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t  enum mlxsw_reg_qeec_hr hr, u8 index, u8 next_index,\n\t\t\t  bool dwrr, u8 dwrr_weight);\nint mlxsw_sp_port_prio_tc_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t      u8 switch_prio, u8 tclass);\nint mlxsw_sp_port_ets_maxrate_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  enum mlxsw_reg_qeec_hr hr, u8 index,\n\t\t\t\t  u8 next_index, u32 maxrate, u8 burst_size);\nenum mlxsw_reg_spms_state mlxsw_sp_stp_spms_state(u8 stp_state);\nint mlxsw_sp_port_vid_stp_set(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid,\n\t\t\t      u8 state);\nint mlxsw_sp_port_vp_mode_set(struct mlxsw_sp_port *mlxsw_sp_port, bool enable);\nint mlxsw_sp_port_vid_learning_set(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid,\n\t\t\t\t   bool learn_enable);\nint mlxsw_sp_port_security_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t       bool enable);\nint mlxsw_sp_ethtype_to_sver_type(u16 ethtype, u8 *p_sver_type);\nint mlxsw_sp_port_egress_ethtype_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t     u16 ethtype);\nint mlxsw_sp_port_pvid_set(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid,\n\t\t\t   u16 ethtype);\nstruct mlxsw_sp_port_vlan *\nmlxsw_sp_port_vlan_create(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid);\nvoid mlxsw_sp_port_vlan_destroy(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan);\nint mlxsw_sp_port_kill_vid(struct net_device *dev,\n\t\t\t   __be16 __always_unused proto, u16 vid);\nint mlxsw_sp_port_vlan_set(struct mlxsw_sp_port *mlxsw_sp_port, u16 vid_begin,\n\t\t\t   u16 vid_end, bool is_member, bool untagged);\nint mlxsw_sp_flow_counter_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      unsigned int counter_index, u64 *packets,\n\t\t\t      u64 *bytes);\nint mlxsw_sp_flow_counter_alloc(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tunsigned int *p_counter_index);\nvoid mlxsw_sp_flow_counter_free(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tunsigned int counter_index);\nvoid mlxsw_sp_txhdr_construct(struct sk_buff *skb,\n\t\t\t      const struct mlxsw_tx_info *tx_info);\nint mlxsw_sp_txhdr_ptp_data_construct(struct mlxsw_core *mlxsw_core,\n\t\t\t\t      struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      const struct mlxsw_tx_info *tx_info);\nbool mlxsw_sp_port_dev_check(const struct net_device *dev);\nstruct mlxsw_sp *mlxsw_sp_lower_get(struct net_device *dev);\nstruct mlxsw_sp_port *mlxsw_sp_port_dev_lower_find(struct net_device *dev);\nstruct mlxsw_sp_port *mlxsw_sp_port_dev_lower_find_rcu(struct net_device *dev);\nint mlxsw_sp_parsing_depth_inc(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_parsing_depth_dec(struct mlxsw_sp *mlxsw_sp);\nint mlxsw_sp_parsing_vxlan_udp_dport_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t __be16 udp_dport);\n\n \n#ifdef CONFIG_MLXSW_SPECTRUM_DCB\nint mlxsw_sp_port_dcb_init(struct mlxsw_sp_port *mlxsw_sp_port);\nvoid mlxsw_sp_port_dcb_fini(struct mlxsw_sp_port *mlxsw_sp_port);\n#else\nstatic inline int mlxsw_sp_port_dcb_init(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\treturn 0;\n}\nstatic inline void mlxsw_sp_port_dcb_fini(struct mlxsw_sp_port *mlxsw_sp_port)\n{}\n#endif\n\n \nenum mlxsw_sp_l3proto {\n\tMLXSW_SP_L3_PROTO_IPV4,\n\tMLXSW_SP_L3_PROTO_IPV6,\n#define MLXSW_SP_L3_PROTO_MAX\t(MLXSW_SP_L3_PROTO_IPV6 + 1)\n};\n\nunion mlxsw_sp_l3addr {\n\t__be32 addr4;\n\tstruct in6_addr addr6;\n};\n\nu16 mlxsw_sp_rif_index(const struct mlxsw_sp_rif *rif);\nint mlxsw_sp_router_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t struct netlink_ext_ack *extack);\nvoid mlxsw_sp_router_fini(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_rif_macvlan_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      const struct net_device *macvlan_dev);\nvoid\nmlxsw_sp_port_vlan_router_leave(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan);\nvoid mlxsw_sp_rif_destroy_by_dev(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct net_device *dev);\nbool mlxsw_sp_rif_exists(struct mlxsw_sp *mlxsw_sp,\n\t\t\t const struct net_device *dev);\nu16 mlxsw_sp_rif_vid(struct mlxsw_sp *mlxsw_sp, const struct net_device *dev);\nu16 mlxsw_sp_router_port(const struct mlxsw_sp *mlxsw_sp);\nint mlxsw_sp_router_nve_promote_decap(struct mlxsw_sp *mlxsw_sp, u32 ul_tb_id,\n\t\t\t\t      enum mlxsw_sp_l3proto ul_proto,\n\t\t\t\t      const union mlxsw_sp_l3addr *ul_sip,\n\t\t\t\t      u32 tunnel_index);\nvoid mlxsw_sp_router_nve_demote_decap(struct mlxsw_sp *mlxsw_sp, u32 ul_tb_id,\n\t\t\t\t      enum mlxsw_sp_l3proto ul_proto,\n\t\t\t\t      const union mlxsw_sp_l3addr *ul_sip);\nint mlxsw_sp_router_tb_id_vr_id(struct mlxsw_sp *mlxsw_sp, u32 tb_id,\n\t\t\t\tu16 *vr_id);\nint mlxsw_sp_router_ul_rif_get(struct mlxsw_sp *mlxsw_sp, u32 ul_tb_id,\n\t\t\t       u16 *ul_rif_index);\nvoid mlxsw_sp_router_ul_rif_put(struct mlxsw_sp *mlxsw_sp, u16 ul_rif_index);\n\n \nenum mlxsw_sp_kvdl_entry_type {\n\tMLXSW_SP_KVDL_ENTRY_TYPE_ADJ,\n\tMLXSW_SP_KVDL_ENTRY_TYPE_ACTSET,\n\tMLXSW_SP_KVDL_ENTRY_TYPE_PBS,\n\tMLXSW_SP_KVDL_ENTRY_TYPE_MCRIGR,\n\tMLXSW_SP_KVDL_ENTRY_TYPE_IPV6_ADDRESS,\n\tMLXSW_SP_KVDL_ENTRY_TYPE_TNUMT,\n};\n\nstatic inline unsigned int\nmlxsw_sp_kvdl_entry_size(enum mlxsw_sp_kvdl_entry_type type)\n{\n\tswitch (type) {\n\tcase MLXSW_SP_KVDL_ENTRY_TYPE_ADJ:\n\tcase MLXSW_SP_KVDL_ENTRY_TYPE_ACTSET:\n\tcase MLXSW_SP_KVDL_ENTRY_TYPE_PBS:\n\tcase MLXSW_SP_KVDL_ENTRY_TYPE_MCRIGR:\n\tcase MLXSW_SP_KVDL_ENTRY_TYPE_IPV6_ADDRESS:\n\tcase MLXSW_SP_KVDL_ENTRY_TYPE_TNUMT:\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstruct mlxsw_sp_kvdl_ops {\n\tsize_t priv_size;\n\tint (*init)(struct mlxsw_sp *mlxsw_sp, void *priv);\n\tvoid (*fini)(struct mlxsw_sp *mlxsw_sp, void *priv);\n\tint (*alloc)(struct mlxsw_sp *mlxsw_sp, void *priv,\n\t\t     enum mlxsw_sp_kvdl_entry_type type,\n\t\t     unsigned int entry_count, u32 *p_entry_index);\n\tvoid (*free)(struct mlxsw_sp *mlxsw_sp, void *priv,\n\t\t     enum mlxsw_sp_kvdl_entry_type type,\n\t\t     unsigned int entry_count, int entry_index);\n\tint (*alloc_size_query)(struct mlxsw_sp *mlxsw_sp, void *priv,\n\t\t\t\tenum mlxsw_sp_kvdl_entry_type type,\n\t\t\t\tunsigned int entry_count,\n\t\t\t\tunsigned int *p_alloc_count);\n\tint (*resources_register)(struct mlxsw_sp *mlxsw_sp, void *priv);\n};\n\nint mlxsw_sp_kvdl_init(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_kvdl_fini(struct mlxsw_sp *mlxsw_sp);\nint mlxsw_sp_kvdl_alloc(struct mlxsw_sp *mlxsw_sp,\n\t\t\tenum mlxsw_sp_kvdl_entry_type type,\n\t\t\tunsigned int entry_count, u32 *p_entry_index);\nvoid mlxsw_sp_kvdl_free(struct mlxsw_sp *mlxsw_sp,\n\t\t\tenum mlxsw_sp_kvdl_entry_type type,\n\t\t\tunsigned int entry_count, int entry_index);\nint mlxsw_sp_kvdl_alloc_count_query(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    enum mlxsw_sp_kvdl_entry_type type,\n\t\t\t\t    unsigned int entry_count,\n\t\t\t\t    unsigned int *p_alloc_count);\n\n \nextern const struct mlxsw_sp_kvdl_ops mlxsw_sp1_kvdl_ops;\nint mlxsw_sp1_kvdl_resources_register(struct mlxsw_core *mlxsw_core);\n\n \nextern const struct mlxsw_sp_kvdl_ops mlxsw_sp2_kvdl_ops;\n\nenum mlxsw_sp_acl_mangle_field {\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP_DSFIELD,\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP_DSCP,\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP_ECN,\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP_SPORT,\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP_DPORT,\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP4_SIP,\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP4_DIP,\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP6_SIP_1,\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP6_SIP_2,\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP6_SIP_3,\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP6_SIP_4,\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP6_DIP_1,\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP6_DIP_2,\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP6_DIP_3,\n\tMLXSW_SP_ACL_MANGLE_FIELD_IP6_DIP_4,\n};\n\nstruct mlxsw_sp_acl_rule_info {\n\tunsigned int priority;\n\tstruct mlxsw_afk_element_values values;\n\tstruct mlxsw_afa_block *act_block;\n\tu8 action_created:1,\n\t   ingress_bind_blocker:1,\n\t   egress_bind_blocker:1,\n\t   counter_valid:1,\n\t   policer_index_valid:1,\n\t   ipv6_valid:1,\n\t   src_port_range_reg_valid:1,\n\t   dst_port_range_reg_valid:1;\n\tunsigned int counter_index;\n\tu16 policer_index;\n\tu8 src_port_range_reg_index;\n\tu8 dst_port_range_reg_index;\n\tstruct {\n\t\tu32 prev_val;\n\t\tenum mlxsw_sp_acl_mangle_field prev_field;\n\t} ipv6;\n};\n\n \nstruct mlxsw_sp_flow_block {\n\tstruct list_head binding_list;\n\tstruct {\n\t\tstruct list_head list;\n\t\tunsigned int min_prio;\n\t\tunsigned int max_prio;\n\t} mall;\n\tstruct mlxsw_sp_acl_ruleset *ruleset_zero;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tunsigned int rule_count;\n\tunsigned int disable_count;\n\tunsigned int ingress_blocker_rule_count;\n\tunsigned int egress_blocker_rule_count;\n\tunsigned int ingress_binding_count;\n\tunsigned int egress_binding_count;\n\tstruct net *net;\n};\n\nstruct mlxsw_sp_flow_block_binding {\n\tstruct list_head list;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tbool ingress;\n};\n\nstatic inline struct mlxsw_sp *\nmlxsw_sp_flow_block_mlxsw_sp(struct mlxsw_sp_flow_block *block)\n{\n\treturn block->mlxsw_sp;\n}\n\nstatic inline unsigned int\nmlxsw_sp_flow_block_rule_count(const struct mlxsw_sp_flow_block *block)\n{\n\treturn block ? block->rule_count : 0;\n}\n\nstatic inline void\nmlxsw_sp_flow_block_disable_inc(struct mlxsw_sp_flow_block *block)\n{\n\tif (block)\n\t\tblock->disable_count++;\n}\n\nstatic inline void\nmlxsw_sp_flow_block_disable_dec(struct mlxsw_sp_flow_block *block)\n{\n\tif (block)\n\t\tblock->disable_count--;\n}\n\nstatic inline bool\nmlxsw_sp_flow_block_disabled(const struct mlxsw_sp_flow_block *block)\n{\n\treturn block->disable_count;\n}\n\nstatic inline bool\nmlxsw_sp_flow_block_is_egress_bound(const struct mlxsw_sp_flow_block *block)\n{\n\treturn block->egress_binding_count;\n}\n\nstatic inline bool\nmlxsw_sp_flow_block_is_ingress_bound(const struct mlxsw_sp_flow_block *block)\n{\n\treturn block->ingress_binding_count;\n}\n\nstatic inline bool\nmlxsw_sp_flow_block_is_mixed_bound(const struct mlxsw_sp_flow_block *block)\n{\n\treturn block->ingress_binding_count && block->egress_binding_count;\n}\n\nstruct mlxsw_sp_flow_block *mlxsw_sp_flow_block_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t       struct net *net);\nvoid mlxsw_sp_flow_block_destroy(struct mlxsw_sp_flow_block *block);\nint mlxsw_sp_setup_tc_block_clsact(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t   struct flow_block_offload *f,\n\t\t\t\t   bool ingress);\n\n \nstruct mlxsw_sp_acl_ruleset;\n\nenum mlxsw_sp_acl_profile {\n\tMLXSW_SP_ACL_PROFILE_FLOWER,\n\tMLXSW_SP_ACL_PROFILE_MR,\n};\n\nstruct mlxsw_afk *mlxsw_sp_acl_afk(struct mlxsw_sp_acl *acl);\nstruct mlxsw_sp_acl_tcam *mlxsw_sp_acl_to_tcam(struct mlxsw_sp_acl *acl);\n\nint mlxsw_sp_acl_ruleset_bind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_flow_block *block,\n\t\t\t      struct mlxsw_sp_flow_block_binding *binding);\nvoid mlxsw_sp_acl_ruleset_unbind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_flow_block *block,\n\t\t\t\t struct mlxsw_sp_flow_block_binding *binding);\nstruct mlxsw_sp_acl_ruleset *\nmlxsw_sp_acl_ruleset_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_flow_block *block, u32 chain_index,\n\t\t\t    enum mlxsw_sp_acl_profile profile);\nstruct mlxsw_sp_acl_ruleset *\nmlxsw_sp_acl_ruleset_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t struct mlxsw_sp_flow_block *block, u32 chain_index,\n\t\t\t enum mlxsw_sp_acl_profile profile,\n\t\t\t struct mlxsw_afk_element_usage *tmplt_elusage);\nvoid mlxsw_sp_acl_ruleset_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_acl_ruleset *ruleset);\nu16 mlxsw_sp_acl_ruleset_group_id(struct mlxsw_sp_acl_ruleset *ruleset);\nvoid mlxsw_sp_acl_ruleset_prio_get(struct mlxsw_sp_acl_ruleset *ruleset,\n\t\t\t\t   unsigned int *p_min_prio,\n\t\t\t\t   unsigned int *p_max_prio);\n\nstruct mlxsw_sp_acl_rule_info *\nmlxsw_sp_acl_rulei_create(struct mlxsw_sp_acl *acl,\n\t\t\t  struct mlxsw_afa_block *afa_block);\nvoid mlxsw_sp_acl_rulei_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_acl_rule_info *rulei);\nint mlxsw_sp_acl_rulei_commit(struct mlxsw_sp_acl_rule_info *rulei);\nvoid mlxsw_sp_acl_rulei_priority(struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t unsigned int priority);\nvoid mlxsw_sp_acl_rulei_keymask_u32(struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t    enum mlxsw_afk_element element,\n\t\t\t\t    u32 key_value, u32 mask_value);\nvoid mlxsw_sp_acl_rulei_keymask_buf(struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t    enum mlxsw_afk_element element,\n\t\t\t\t    const char *key_value,\n\t\t\t\t    const char *mask_value, unsigned int len);\nint mlxsw_sp_acl_rulei_act_continue(struct mlxsw_sp_acl_rule_info *rulei);\nint mlxsw_sp_acl_rulei_act_jump(struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\tu16 group_id);\nint mlxsw_sp_acl_rulei_act_terminate(struct mlxsw_sp_acl_rule_info *rulei);\nint mlxsw_sp_acl_rulei_act_drop(struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\tbool ingress,\n\t\t\t\tconst struct flow_action_cookie *fa_cookie,\n\t\t\t\tstruct netlink_ext_ack *extack);\nint mlxsw_sp_acl_rulei_act_trap(struct mlxsw_sp_acl_rule_info *rulei);\nint mlxsw_sp_acl_rulei_act_mirror(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t  struct mlxsw_sp_flow_block *block,\n\t\t\t\t  struct net_device *out_dev,\n\t\t\t\t  struct netlink_ext_ack *extack);\nint mlxsw_sp_acl_rulei_act_fwd(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t       struct net_device *out_dev,\n\t\t\t       struct netlink_ext_ack *extack);\nint mlxsw_sp_acl_rulei_act_vlan(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\tu32 action, u16 vid, u16 proto, u8 prio,\n\t\t\t\tstruct netlink_ext_ack *extack);\nint mlxsw_sp_acl_rulei_act_priority(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t    u32 prio, struct netlink_ext_ack *extack);\nint mlxsw_sp_acl_rulei_act_mangle(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t  enum flow_action_mangle_base htype,\n\t\t\t\t  u32 offset, u32 mask, u32 val,\n\t\t\t\t  struct netlink_ext_ack *extack);\nint mlxsw_sp_acl_rulei_act_police(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t  u32 index, u64 rate_bytes_ps,\n\t\t\t\t  u32 burst, struct netlink_ext_ack *extack);\nint mlxsw_sp_acl_rulei_act_count(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t struct netlink_ext_ack *extack);\nint mlxsw_sp_acl_rulei_act_fid_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t   u16 fid, struct netlink_ext_ack *extack);\nint mlxsw_sp_acl_rulei_act_ignore(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t  bool disable_learning, bool disable_security);\nint mlxsw_sp_acl_rulei_act_sample(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t  struct mlxsw_sp_flow_block *block,\n\t\t\t\t  struct psample_group *psample_group, u32 rate,\n\t\t\t\t  u32 trunc_size, bool truncate,\n\t\t\t\t  struct netlink_ext_ack *extack);\n\nstruct mlxsw_sp_acl_rule;\n\nstruct mlxsw_sp_acl_rule *\nmlxsw_sp_acl_rule_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t struct mlxsw_sp_acl_ruleset *ruleset,\n\t\t\t unsigned long cookie,\n\t\t\t struct mlxsw_afa_block *afa_block,\n\t\t\t struct netlink_ext_ack *extack);\nvoid mlxsw_sp_acl_rule_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_acl_rule *rule);\nint mlxsw_sp_acl_rule_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  struct mlxsw_sp_acl_rule *rule);\nvoid mlxsw_sp_acl_rule_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   struct mlxsw_sp_acl_rule *rule);\nint mlxsw_sp_acl_rule_action_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_acl_rule *rule,\n\t\t\t\t     struct mlxsw_afa_block *afa_block);\nstruct mlxsw_sp_acl_rule *\nmlxsw_sp_acl_rule_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t struct mlxsw_sp_acl_ruleset *ruleset,\n\t\t\t unsigned long cookie);\nstruct mlxsw_sp_acl_rule_info *\nmlxsw_sp_acl_rule_rulei(struct mlxsw_sp_acl_rule *rule);\nint mlxsw_sp_acl_rule_get_stats(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_acl_rule *rule,\n\t\t\t\tu64 *packets, u64 *bytes, u64 *drops,\n\t\t\t\tu64 *last_use,\n\t\t\t\tenum flow_action_hw_stats *used_hw_stats);\n\nstruct mlxsw_sp_fid *mlxsw_sp_acl_dummy_fid(struct mlxsw_sp *mlxsw_sp);\n\nstatic inline const struct flow_action_cookie *\nmlxsw_sp_acl_act_cookie_lookup(struct mlxsw_sp *mlxsw_sp, u32 cookie_index)\n{\n\treturn mlxsw_afa_cookie_lookup(mlxsw_sp->afa, cookie_index);\n}\n\nint mlxsw_sp_acl_init(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_acl_fini(struct mlxsw_sp *mlxsw_sp);\n\nstruct mlxsw_sp_acl_mangle_action;\n\nstruct mlxsw_sp_acl_rulei_ops {\n\tint (*act_mangle_field)(struct mlxsw_sp *mlxsw_sp, struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\tstruct mlxsw_sp_acl_mangle_action *mact, u32 val,\n\t\t\t\tstruct netlink_ext_ack *extack);\n};\n\nextern struct mlxsw_sp_acl_rulei_ops mlxsw_sp1_acl_rulei_ops;\nextern struct mlxsw_sp_acl_rulei_ops mlxsw_sp2_acl_rulei_ops;\n\n \nstruct mlxsw_sp_acl_tcam;\nstruct mlxsw_sp_acl_tcam_region;\n\nstruct mlxsw_sp_acl_tcam_ops {\n\tenum mlxsw_reg_ptar_key_type key_type;\n\tsize_t priv_size;\n\tint (*init)(struct mlxsw_sp *mlxsw_sp, void *priv,\n\t\t    struct mlxsw_sp_acl_tcam *tcam);\n\tvoid (*fini)(struct mlxsw_sp *mlxsw_sp, void *priv);\n\tsize_t region_priv_size;\n\tint (*region_init)(struct mlxsw_sp *mlxsw_sp, void *region_priv,\n\t\t\t   void *tcam_priv,\n\t\t\t   struct mlxsw_sp_acl_tcam_region *region,\n\t\t\t   void *hints_priv);\n\tvoid (*region_fini)(struct mlxsw_sp *mlxsw_sp, void *region_priv);\n\tint (*region_associate)(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_acl_tcam_region *region);\n\tvoid * (*region_rehash_hints_get)(void *region_priv);\n\tvoid (*region_rehash_hints_put)(void *hints_priv);\n\tsize_t chunk_priv_size;\n\tvoid (*chunk_init)(void *region_priv, void *chunk_priv,\n\t\t\t   unsigned int priority);\n\tvoid (*chunk_fini)(void *chunk_priv);\n\tsize_t entry_priv_size;\n\tint (*entry_add)(struct mlxsw_sp *mlxsw_sp,\n\t\t\t void *region_priv, void *chunk_priv,\n\t\t\t void *entry_priv,\n\t\t\t struct mlxsw_sp_acl_rule_info *rulei);\n\tvoid (*entry_del)(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  void *region_priv, void *chunk_priv,\n\t\t\t  void *entry_priv);\n\tint (*entry_action_replace)(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    void *region_priv, void *entry_priv,\n\t\t\t\t    struct mlxsw_sp_acl_rule_info *rulei);\n\tint (*entry_activity_get)(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  void *region_priv, void *entry_priv,\n\t\t\t\t  bool *activity);\n};\n\n \nextern const struct mlxsw_sp_acl_tcam_ops mlxsw_sp1_acl_tcam_ops;\n\n \nextern const struct mlxsw_sp_acl_tcam_ops mlxsw_sp2_acl_tcam_ops;\n\n \nextern const struct mlxsw_afa_ops mlxsw_sp1_act_afa_ops;\nextern const struct mlxsw_afa_ops mlxsw_sp2_act_afa_ops;\n\n \nextern const struct mlxsw_afk_ops mlxsw_sp1_afk_ops;\nextern const struct mlxsw_afk_ops mlxsw_sp2_afk_ops;\nextern const struct mlxsw_afk_ops mlxsw_sp4_afk_ops;\n\n \nextern const struct mlxsw_sp_acl_bf_ops mlxsw_sp2_acl_bf_ops;\nextern const struct mlxsw_sp_acl_bf_ops mlxsw_sp4_acl_bf_ops;\n\n \nstruct mlxsw_sp_mall_ops {\n\tint (*sample_add)(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t  struct mlxsw_sp_mall_entry *mall_entry,\n\t\t\t  struct netlink_ext_ack *extack);\n\tvoid (*sample_del)(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t   struct mlxsw_sp_mall_entry *mall_entry);\n};\n\nextern const struct mlxsw_sp_mall_ops mlxsw_sp1_mall_ops;\nextern const struct mlxsw_sp_mall_ops mlxsw_sp2_mall_ops;\n\nenum mlxsw_sp_mall_action_type {\n\tMLXSW_SP_MALL_ACTION_TYPE_MIRROR,\n\tMLXSW_SP_MALL_ACTION_TYPE_SAMPLE,\n\tMLXSW_SP_MALL_ACTION_TYPE_TRAP,\n};\n\nstruct mlxsw_sp_mall_mirror_entry {\n\tconst struct net_device *to_dev;\n\tint span_id;\n};\n\nstruct mlxsw_sp_mall_trap_entry {\n\tint span_id;\n};\n\nstruct mlxsw_sp_mall_sample_entry {\n\tstruct mlxsw_sp_sample_params params;\n\tint span_id;\t \n};\n\nstruct mlxsw_sp_mall_entry {\n\tstruct list_head list;\n\tunsigned long cookie;\n\tunsigned int priority;\n\tenum mlxsw_sp_mall_action_type type;\n\tbool ingress;\n\tunion {\n\t\tstruct mlxsw_sp_mall_mirror_entry mirror;\n\t\tstruct mlxsw_sp_mall_trap_entry trap;\n\t\tstruct mlxsw_sp_mall_sample_entry sample;\n\t};\n\tstruct rcu_head rcu;\n};\n\nint mlxsw_sp_mall_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  struct mlxsw_sp_flow_block *block,\n\t\t\t  struct tc_cls_matchall_offload *f);\nvoid mlxsw_sp_mall_destroy(struct mlxsw_sp_flow_block *block,\n\t\t\t   struct tc_cls_matchall_offload *f);\nint mlxsw_sp_mall_port_bind(struct mlxsw_sp_flow_block *block,\n\t\t\t    struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t    struct netlink_ext_ack *extack);\nvoid mlxsw_sp_mall_port_unbind(struct mlxsw_sp_flow_block *block,\n\t\t\t       struct mlxsw_sp_port *mlxsw_sp_port);\nint mlxsw_sp_mall_prio_get(struct mlxsw_sp_flow_block *block, u32 chain_index,\n\t\t\t   unsigned int *p_min_prio, unsigned int *p_max_prio);\n\n \nint mlxsw_sp_flower_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_flow_block *block,\n\t\t\t    struct flow_cls_offload *f);\nvoid mlxsw_sp_flower_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     struct mlxsw_sp_flow_block *block,\n\t\t\t     struct flow_cls_offload *f);\nint mlxsw_sp_flower_stats(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  struct mlxsw_sp_flow_block *block,\n\t\t\t  struct flow_cls_offload *f);\nint mlxsw_sp_flower_tmplt_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_flow_block *block,\n\t\t\t\t struct flow_cls_offload *f);\nvoid mlxsw_sp_flower_tmplt_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_flow_block *block,\n\t\t\t\t   struct flow_cls_offload *f);\nint mlxsw_sp_flower_prio_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     struct mlxsw_sp_flow_block *block,\n\t\t\t     u32 chain_index, unsigned int *p_min_prio,\n\t\t\t     unsigned int *p_max_prio);\n\n \nint mlxsw_sp_tc_qdisc_init(struct mlxsw_sp_port *mlxsw_sp_port);\nvoid mlxsw_sp_tc_qdisc_fini(struct mlxsw_sp_port *mlxsw_sp_port);\nint mlxsw_sp_setup_tc_red(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t  struct tc_red_qopt_offload *p);\nint mlxsw_sp_setup_tc_prio(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t   struct tc_prio_qopt_offload *p);\nint mlxsw_sp_setup_tc_ets(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t  struct tc_ets_qopt_offload *p);\nint mlxsw_sp_setup_tc_tbf(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t  struct tc_tbf_qopt_offload *p);\nint mlxsw_sp_setup_tc_fifo(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t   struct tc_fifo_qopt_offload *p);\nint mlxsw_sp_setup_tc_block_qevent_early_drop(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t      struct flow_block_offload *f);\nint mlxsw_sp_setup_tc_block_qevent_mark(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\tstruct flow_block_offload *f);\n\n \nstruct mlxsw_sp_fid *mlxsw_sp_fid_lookup_by_index(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t  u16 fid_index);\nint mlxsw_sp_fid_nve_ifindex(const struct mlxsw_sp_fid *fid, int *nve_ifindex);\nint mlxsw_sp_fid_nve_type(const struct mlxsw_sp_fid *fid,\n\t\t\t  enum mlxsw_sp_nve_type *p_type);\nstruct mlxsw_sp_fid *mlxsw_sp_fid_lookup_by_vni(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t__be32 vni);\nint mlxsw_sp_fid_vni(const struct mlxsw_sp_fid *fid, __be32 *vni);\nint mlxsw_sp_fid_nve_flood_index_set(struct mlxsw_sp_fid *fid,\n\t\t\t\t     u32 nve_flood_index);\nvoid mlxsw_sp_fid_nve_flood_index_clear(struct mlxsw_sp_fid *fid);\nbool mlxsw_sp_fid_nve_flood_index_is_set(const struct mlxsw_sp_fid *fid);\nint mlxsw_sp_fid_vni_set(struct mlxsw_sp_fid *fid, enum mlxsw_sp_nve_type type,\n\t\t\t __be32 vni, int nve_ifindex);\nvoid mlxsw_sp_fid_vni_clear(struct mlxsw_sp_fid *fid);\nbool mlxsw_sp_fid_vni_is_set(const struct mlxsw_sp_fid *fid);\nvoid mlxsw_sp_fid_fdb_clear_offload(const struct mlxsw_sp_fid *fid,\n\t\t\t\t    const struct net_device *nve_dev);\nint mlxsw_sp_fid_flood_set(struct mlxsw_sp_fid *fid,\n\t\t\t   enum mlxsw_sp_flood_type packet_type, u16 local_port,\n\t\t\t   bool member);\nint mlxsw_sp_fid_port_vid_map(struct mlxsw_sp_fid *fid,\n\t\t\t      struct mlxsw_sp_port *mlxsw_sp_port, u16 vid);\nvoid mlxsw_sp_fid_port_vid_unmap(struct mlxsw_sp_fid *fid,\n\t\t\t\t struct mlxsw_sp_port *mlxsw_sp_port, u16 vid);\nu16 mlxsw_sp_fid_index(const struct mlxsw_sp_fid *fid);\nenum mlxsw_sp_fid_type mlxsw_sp_fid_type(const struct mlxsw_sp_fid *fid);\nint mlxsw_sp_fid_rif_set(struct mlxsw_sp_fid *fid, struct mlxsw_sp_rif *rif);\nvoid mlxsw_sp_fid_rif_unset(struct mlxsw_sp_fid *fid);\nstruct mlxsw_sp_rif *mlxsw_sp_fid_rif(const struct mlxsw_sp_fid *fid);\nenum mlxsw_sp_rif_type\nmlxsw_sp_fid_type_rif_type(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t   enum mlxsw_sp_fid_type type);\nu16 mlxsw_sp_fid_8021q_vid(const struct mlxsw_sp_fid *fid);\nstruct mlxsw_sp_fid *mlxsw_sp_fid_8021q_get(struct mlxsw_sp *mlxsw_sp, u16 vid);\nstruct mlxsw_sp_fid *mlxsw_sp_fid_8021d_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    int br_ifindex);\nstruct mlxsw_sp_fid *mlxsw_sp_fid_8021q_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t       u16 vid);\nstruct mlxsw_sp_fid *mlxsw_sp_fid_8021d_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t       int br_ifindex);\nstruct mlxsw_sp_fid *mlxsw_sp_fid_rfid_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   u16 rif_index);\nstruct mlxsw_sp_fid *mlxsw_sp_fid_dummy_get(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_fid_put(struct mlxsw_sp_fid *fid);\nint mlxsw_sp_port_fids_init(struct mlxsw_sp_port *mlxsw_sp_port);\nvoid mlxsw_sp_port_fids_fini(struct mlxsw_sp_port *mlxsw_sp_port);\nint mlxsw_sp_fids_init(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_fids_fini(struct mlxsw_sp *mlxsw_sp);\n\nextern const struct mlxsw_sp_fid_family *mlxsw_sp1_fid_family_arr[];\nextern const struct mlxsw_sp_fid_family *mlxsw_sp2_fid_family_arr[];\n\n \nenum mlxsw_sp_mr_route_prio {\n\tMLXSW_SP_MR_ROUTE_PRIO_SG,\n\tMLXSW_SP_MR_ROUTE_PRIO_STARG,\n\tMLXSW_SP_MR_ROUTE_PRIO_CATCHALL,\n\t__MLXSW_SP_MR_ROUTE_PRIO_MAX\n};\n\n#define MLXSW_SP_MR_ROUTE_PRIO_MAX (__MLXSW_SP_MR_ROUTE_PRIO_MAX - 1)\n\nstruct mlxsw_sp_mr_route_key;\n\nstruct mlxsw_sp_mr_tcam_ops {\n\tsize_t priv_size;\n\tint (*init)(struct mlxsw_sp *mlxsw_sp, void *priv);\n\tvoid (*fini)(void *priv);\n\tsize_t route_priv_size;\n\tint (*route_create)(struct mlxsw_sp *mlxsw_sp, void *priv,\n\t\t\t    void *route_priv,\n\t\t\t    struct mlxsw_sp_mr_route_key *key,\n\t\t\t    struct mlxsw_afa_block *afa_block,\n\t\t\t    enum mlxsw_sp_mr_route_prio prio);\n\tvoid (*route_destroy)(struct mlxsw_sp *mlxsw_sp, void *priv,\n\t\t\t      void *route_priv,\n\t\t\t      struct mlxsw_sp_mr_route_key *key);\n\tint (*route_update)(struct mlxsw_sp *mlxsw_sp, void *route_priv,\n\t\t\t    struct mlxsw_sp_mr_route_key *key,\n\t\t\t    struct mlxsw_afa_block *afa_block);\n};\n\n \nextern const struct mlxsw_sp_mr_tcam_ops mlxsw_sp1_mr_tcam_ops;\n\n \nextern const struct mlxsw_sp_mr_tcam_ops mlxsw_sp2_mr_tcam_ops;\n\n \nstruct mlxsw_sp_nve_params {\n\tenum mlxsw_sp_nve_type type;\n\t__be32 vni;\n\tconst struct net_device *dev;\n\tu16 ethertype;\n};\n\nextern const struct mlxsw_sp_nve_ops *mlxsw_sp1_nve_ops_arr[];\nextern const struct mlxsw_sp_nve_ops *mlxsw_sp2_nve_ops_arr[];\n\nint mlxsw_sp_nve_learned_ip_resolve(struct mlxsw_sp *mlxsw_sp, u32 uip,\n\t\t\t\t    enum mlxsw_sp_l3proto proto,\n\t\t\t\t    union mlxsw_sp_l3addr *addr);\nint mlxsw_sp_nve_flood_ip_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_fid *fid,\n\t\t\t      enum mlxsw_sp_l3proto proto,\n\t\t\t      union mlxsw_sp_l3addr *addr);\nvoid mlxsw_sp_nve_flood_ip_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_fid *fid,\n\t\t\t       enum mlxsw_sp_l3proto proto,\n\t\t\t       union mlxsw_sp_l3addr *addr);\nint mlxsw_sp_nve_ipv6_addr_kvdl_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    const struct in6_addr *addr6,\n\t\t\t\t    u32 *p_kvdl_index);\nvoid mlxsw_sp_nve_ipv6_addr_kvdl_unset(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       const struct in6_addr *addr6);\nint\nmlxsw_sp_nve_ipv6_addr_map_replace(struct mlxsw_sp *mlxsw_sp, const char *mac,\n\t\t\t\t   u16 fid_index,\n\t\t\t\t   const struct in6_addr *new_addr6);\nvoid mlxsw_sp_nve_ipv6_addr_map_del(struct mlxsw_sp *mlxsw_sp, const char *mac,\n\t\t\t\t    u16 fid_index);\nint mlxsw_sp_nve_fid_enable(struct mlxsw_sp *mlxsw_sp, struct mlxsw_sp_fid *fid,\n\t\t\t    struct mlxsw_sp_nve_params *params,\n\t\t\t    struct netlink_ext_ack *extack);\nvoid mlxsw_sp_nve_fid_disable(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_fid *fid);\nint mlxsw_sp_port_nve_init(struct mlxsw_sp_port *mlxsw_sp_port);\nvoid mlxsw_sp_port_nve_fini(struct mlxsw_sp_port *mlxsw_sp_port);\nint mlxsw_sp_nve_init(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_nve_fini(struct mlxsw_sp *mlxsw_sp);\n\n \nint mlxsw_sp_devlink_traps_init(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_devlink_traps_fini(struct mlxsw_sp *mlxsw_sp);\nint mlxsw_sp_trap_init(struct mlxsw_core *mlxsw_core,\n\t\t       const struct devlink_trap *trap, void *trap_ctx);\nvoid mlxsw_sp_trap_fini(struct mlxsw_core *mlxsw_core,\n\t\t\tconst struct devlink_trap *trap, void *trap_ctx);\nint mlxsw_sp_trap_action_set(struct mlxsw_core *mlxsw_core,\n\t\t\t     const struct devlink_trap *trap,\n\t\t\t     enum devlink_trap_action action,\n\t\t\t     struct netlink_ext_ack *extack);\nint mlxsw_sp_trap_group_init(struct mlxsw_core *mlxsw_core,\n\t\t\t     const struct devlink_trap_group *group);\nint mlxsw_sp_trap_group_set(struct mlxsw_core *mlxsw_core,\n\t\t\t    const struct devlink_trap_group *group,\n\t\t\t    const struct devlink_trap_policer *policer,\n\t\t\t    struct netlink_ext_ack *extack);\nint\nmlxsw_sp_trap_policer_init(struct mlxsw_core *mlxsw_core,\n\t\t\t   const struct devlink_trap_policer *policer);\nvoid mlxsw_sp_trap_policer_fini(struct mlxsw_core *mlxsw_core,\n\t\t\t\tconst struct devlink_trap_policer *policer);\nint\nmlxsw_sp_trap_policer_set(struct mlxsw_core *mlxsw_core,\n\t\t\t  const struct devlink_trap_policer *policer,\n\t\t\t  u64 rate, u64 burst, struct netlink_ext_ack *extack);\nint\nmlxsw_sp_trap_policer_counter_get(struct mlxsw_core *mlxsw_core,\n\t\t\t\t  const struct devlink_trap_policer *policer,\n\t\t\t\t  u64 *p_drops);\nint mlxsw_sp_trap_group_policer_hw_id_get(struct mlxsw_sp *mlxsw_sp, u16 id,\n\t\t\t\t\t  bool *p_enabled, u16 *p_hw_id);\n\nstatic inline struct net *mlxsw_sp_net(struct mlxsw_sp *mlxsw_sp)\n{\n\treturn mlxsw_core_net(mlxsw_sp->core);\n}\n\n \nextern const struct ethtool_ops mlxsw_sp_port_ethtool_ops;\nextern const struct mlxsw_sp_port_type_speed_ops mlxsw_sp1_port_type_speed_ops;\nextern const struct mlxsw_sp_port_type_speed_ops mlxsw_sp2_port_type_speed_ops;\n\n \nextern const struct mlxsw_sp_policer_core_ops mlxsw_sp1_policer_core_ops;\nextern const struct mlxsw_sp_policer_core_ops mlxsw_sp2_policer_core_ops;\n\nenum mlxsw_sp_policer_type {\n\tMLXSW_SP_POLICER_TYPE_SINGLE_RATE,\n\n\t__MLXSW_SP_POLICER_TYPE_MAX,\n\tMLXSW_SP_POLICER_TYPE_MAX = __MLXSW_SP_POLICER_TYPE_MAX - 1,\n};\n\nstruct mlxsw_sp_policer_params {\n\tu64 rate;\n\tu64 burst;\n\tbool bytes;\n};\n\nint mlxsw_sp_policer_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t enum mlxsw_sp_policer_type type,\n\t\t\t const struct mlxsw_sp_policer_params *params,\n\t\t\t struct netlink_ext_ack *extack, u16 *p_policer_index);\nvoid mlxsw_sp_policer_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  enum mlxsw_sp_policer_type type,\n\t\t\t  u16 policer_index);\nint mlxsw_sp_policer_drops_counter_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       enum mlxsw_sp_policer_type type,\n\t\t\t\t       u16 policer_index, u64 *p_drops);\nint mlxsw_sp_policers_init(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_policers_fini(struct mlxsw_sp *mlxsw_sp);\nint mlxsw_sp_policer_resources_register(struct mlxsw_core *mlxsw_core);\n\n \nint mlxsw_sp_pgt_mid_alloc(struct mlxsw_sp *mlxsw_sp, u16 *p_mid);\nvoid mlxsw_sp_pgt_mid_free(struct mlxsw_sp *mlxsw_sp, u16 mid_base);\nint mlxsw_sp_pgt_mid_alloc_range(struct mlxsw_sp *mlxsw_sp, u16 mid_base,\n\t\t\t\t u16 count);\nvoid mlxsw_sp_pgt_mid_free_range(struct mlxsw_sp *mlxsw_sp, u16 mid_base,\n\t\t\t\t u16 count);\nint mlxsw_sp_pgt_entry_port_set(struct mlxsw_sp *mlxsw_sp, u16 mid,\n\t\t\t\tu16 smpe, u16 local_port, bool member);\nint mlxsw_sp_pgt_init(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_pgt_fini(struct mlxsw_sp *mlxsw_sp);\n\n \nstruct mlxsw_sp_port_range {\n\tu16 min;\n\tu16 max;\n\tu8 source:1;\t \n};\n\nint mlxsw_sp_port_range_reg_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tconst struct mlxsw_sp_port_range *range,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tu8 *p_prr_index);\nvoid mlxsw_sp_port_range_reg_put(struct mlxsw_sp *mlxsw_sp, u8 prr_index);\nint mlxsw_sp_port_range_init(struct mlxsw_sp *mlxsw_sp);\nvoid mlxsw_sp_port_range_fini(struct mlxsw_sp *mlxsw_sp);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}