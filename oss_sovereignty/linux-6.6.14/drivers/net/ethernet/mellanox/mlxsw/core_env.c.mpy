{
  "module_name": "core_env.c",
  "hash_id": "dead60414867058598378eadb834ddcceae53cdbec07ec18cc4a184738039db5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/core_env.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/ethtool.h>\n#include <linux/sfp.h>\n#include <linux/mutex.h>\n\n#include \"core.h\"\n#include \"core_env.h\"\n#include \"item.h\"\n#include \"reg.h\"\n\nstruct mlxsw_env_module_info {\n\tu64 module_overheat_counter;\n\tbool is_overheat;\n\tint num_ports_mapped;\n\tint num_ports_up;\n\tenum ethtool_module_power_mode_policy power_mode_policy;\n\tenum mlxsw_reg_pmtm_module_type type;\n};\n\nstruct mlxsw_env_line_card {\n\tu8 module_count;\n\tbool active;\n\tstruct mlxsw_env_module_info module_info[];\n};\n\nstruct mlxsw_env {\n\tstruct mlxsw_core *core;\n\tconst struct mlxsw_bus_info *bus_info;\n\tu8 max_module_count;  \n\tu8 num_of_slots;  \n\tu8 max_eeprom_len;  \n\tstruct mutex line_cards_lock;  \n\tstruct mlxsw_env_line_card *line_cards[];\n};\n\nstatic bool __mlxsw_env_linecard_is_active(struct mlxsw_env *mlxsw_env,\n\t\t\t\t\t   u8 slot_index)\n{\n\treturn mlxsw_env->line_cards[slot_index]->active;\n}\n\nstatic bool mlxsw_env_linecard_is_active(struct mlxsw_env *mlxsw_env,\n\t\t\t\t\t u8 slot_index)\n{\n\tbool active;\n\n\tmutex_lock(&mlxsw_env->line_cards_lock);\n\tactive = __mlxsw_env_linecard_is_active(mlxsw_env, slot_index);\n\tmutex_unlock(&mlxsw_env->line_cards_lock);\n\n\treturn active;\n}\n\nstatic struct\nmlxsw_env_module_info *mlxsw_env_module_info_get(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t\t u8 slot_index, u8 module)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\n\treturn &mlxsw_env->line_cards[slot_index]->module_info[module];\n}\n\nstatic int __mlxsw_env_validate_module_type(struct mlxsw_core *core,\n\t\t\t\t\t    u8 slot_index, u8 module)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(core);\n\tstruct mlxsw_env_module_info *module_info;\n\tint err;\n\n\tif (!__mlxsw_env_linecard_is_active(mlxsw_env, slot_index))\n\t\treturn 0;\n\n\tmodule_info = mlxsw_env_module_info_get(core, slot_index, module);\n\tswitch (module_info->type) {\n\tcase MLXSW_REG_PMTM_MODULE_TYPE_TWISTED_PAIR:\n\t\terr = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\terr = 0;\n\t}\n\n\treturn err;\n}\n\nstatic int mlxsw_env_validate_module_type(struct mlxsw_core *core,\n\t\t\t\t\t  u8 slot_index, u8 module)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(core);\n\tint err;\n\n\tmutex_lock(&mlxsw_env->line_cards_lock);\n\terr = __mlxsw_env_validate_module_type(core, slot_index, module);\n\tmutex_unlock(&mlxsw_env->line_cards_lock);\n\n\treturn err;\n}\n\nstatic int\nmlxsw_env_validate_cable_ident(struct mlxsw_core *core, u8 slot_index, int id,\n\t\t\t       bool *qsfp, bool *cmis)\n{\n\tchar mcia_pl[MLXSW_REG_MCIA_LEN];\n\tchar *eeprom_tmp;\n\tu8 ident;\n\tint err;\n\n\terr = mlxsw_env_validate_module_type(core, slot_index, id);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mcia_pack(mcia_pl, slot_index, id,\n\t\t\t    MLXSW_REG_MCIA_PAGE0_LO_OFF, 0, 1,\n\t\t\t    MLXSW_REG_MCIA_I2C_ADDR_LOW);\n\terr = mlxsw_reg_query(core, MLXSW_REG(mcia), mcia_pl);\n\tif (err)\n\t\treturn err;\n\teeprom_tmp = mlxsw_reg_mcia_eeprom_data(mcia_pl);\n\tident = eeprom_tmp[0];\n\t*cmis = false;\n\tswitch (ident) {\n\tcase MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_SFP:\n\t\t*qsfp = false;\n\t\tbreak;\n\tcase MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP:\n\tcase MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP_PLUS:\n\tcase MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP28:\n\t\t*qsfp = true;\n\t\tbreak;\n\tcase MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP_DD:\n\tcase MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_OSFP:\n\t\t*qsfp = true;\n\t\t*cmis = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_env_query_module_eeprom(struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t      int module, u16 offset, u16 size, void *data,\n\t\t\t      bool qsfp, unsigned int *p_read_size)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tchar mcia_pl[MLXSW_REG_MCIA_LEN];\n\tchar *eeprom_tmp;\n\tu16 i2c_addr;\n\tu8 page = 0;\n\tint status;\n\tint err;\n\n\tsize = min_t(u16, size, mlxsw_env->max_eeprom_len);\n\n\tif (offset < MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH &&\n\t    offset + size > MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH)\n\t\t \n\t\tsize = MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH - offset;\n\n\ti2c_addr = MLXSW_REG_MCIA_I2C_ADDR_LOW;\n\tif (offset >= MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH) {\n\t\tif (qsfp) {\n\t\t\t \n\t\t\tpage = MLXSW_REG_MCIA_PAGE_GET(offset);\n\t\t\toffset -= MLXSW_REG_MCIA_EEPROM_UP_PAGE_LENGTH * page;\n\t\t\tif (offset + size > MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH)\n\t\t\t\tsize = MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH - offset;\n\t\t} else {\n\t\t\t \n\t\t\ti2c_addr = MLXSW_REG_MCIA_I2C_ADDR_HIGH;\n\t\t\toffset -= MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH;\n\t\t}\n\t}\n\n\tmlxsw_reg_mcia_pack(mcia_pl, slot_index, module, page, offset, size,\n\t\t\t    i2c_addr);\n\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mcia), mcia_pl);\n\tif (err)\n\t\treturn err;\n\n\tstatus = mlxsw_reg_mcia_status_get(mcia_pl);\n\tif (status)\n\t\treturn -EIO;\n\n\teeprom_tmp = mlxsw_reg_mcia_eeprom_data(mcia_pl);\n\tmemcpy(data, eeprom_tmp, size);\n\t*p_read_size = size;\n\n\treturn 0;\n}\n\nint\nmlxsw_env_module_temp_thresholds_get(struct mlxsw_core *core, u8 slot_index,\n\t\t\t\t     int module, int off, int *temp)\n{\n\tunsigned int module_temp, module_crit, module_emerg;\n\tunion {\n\t\tu8 buf[MLXSW_REG_MCIA_TH_ITEM_SIZE];\n\t\tu16 temp;\n\t} temp_thresh;\n\tchar mcia_pl[MLXSW_REG_MCIA_LEN] = {0};\n\tchar mtmp_pl[MLXSW_REG_MTMP_LEN];\n\tchar *eeprom_tmp;\n\tbool qsfp, cmis;\n\tint page;\n\tint err;\n\n\tmlxsw_reg_mtmp_pack(mtmp_pl, slot_index,\n\t\t\t    MLXSW_REG_MTMP_MODULE_INDEX_MIN + module, false,\n\t\t\t    false);\n\terr = mlxsw_reg_query(core, MLXSW_REG(mtmp), mtmp_pl);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_mtmp_unpack(mtmp_pl, &module_temp, NULL, &module_crit,\n\t\t\t      &module_emerg, NULL);\n\tif (!module_temp) {\n\t\t*temp = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tif (module_emerg) {\n\t\t*temp = off == SFP_TEMP_HIGH_WARN ? module_crit : module_emerg;\n\t\treturn 0;\n\t}\n\n\t \n\n\t \n\terr = mlxsw_env_validate_cable_ident(core, slot_index, module, &qsfp,\n\t\t\t\t\t     &cmis);\n\tif (err)\n\t\treturn err;\n\n\tif (qsfp) {\n\t\t \n\t\tif (cmis)\n\t\t\tpage = MLXSW_REG_MCIA_TH_PAGE_CMIS_NUM;\n\t\telse\n\t\t\tpage = MLXSW_REG_MCIA_TH_PAGE_NUM;\n\t\tmlxsw_reg_mcia_pack(mcia_pl, slot_index, module, page,\n\t\t\t\t    MLXSW_REG_MCIA_TH_PAGE_OFF + off,\n\t\t\t\t    MLXSW_REG_MCIA_TH_ITEM_SIZE,\n\t\t\t\t    MLXSW_REG_MCIA_I2C_ADDR_LOW);\n\t} else {\n\t\tmlxsw_reg_mcia_pack(mcia_pl, slot_index, module,\n\t\t\t\t    MLXSW_REG_MCIA_PAGE0_LO,\n\t\t\t\t    off, MLXSW_REG_MCIA_TH_ITEM_SIZE,\n\t\t\t\t    MLXSW_REG_MCIA_I2C_ADDR_HIGH);\n\t}\n\n\terr = mlxsw_reg_query(core, MLXSW_REG(mcia), mcia_pl);\n\tif (err)\n\t\treturn err;\n\n\teeprom_tmp = mlxsw_reg_mcia_eeprom_data(mcia_pl);\n\tmemcpy(temp_thresh.buf, eeprom_tmp, MLXSW_REG_MCIA_TH_ITEM_SIZE);\n\t*temp = temp_thresh.temp * 1000;\n\n\treturn 0;\n}\n\nint mlxsw_env_get_module_info(struct net_device *netdev,\n\t\t\t      struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t      int module, struct ethtool_modinfo *modinfo)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tu8 module_info[MLXSW_REG_MCIA_EEPROM_MODULE_INFO_SIZE];\n\tu16 offset = MLXSW_REG_MCIA_EEPROM_MODULE_INFO_SIZE;\n\tu8 module_rev_id, module_id, diag_mon;\n\tunsigned int read_size;\n\tint err;\n\n\tif (!mlxsw_env_linecard_is_active(mlxsw_env, slot_index)) {\n\t\tnetdev_err(netdev, \"Cannot read EEPROM of module on an inactive line card\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = mlxsw_env_validate_module_type(mlxsw_core, slot_index, module);\n\tif (err) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"EEPROM is not equipped on port module type\");\n\t\treturn err;\n\t}\n\n\terr = mlxsw_env_query_module_eeprom(mlxsw_core, slot_index, module, 0,\n\t\t\t\t\t    offset, module_info, false,\n\t\t\t\t\t    &read_size);\n\tif (err)\n\t\treturn err;\n\n\tif (read_size < offset)\n\t\treturn -EIO;\n\n\tmodule_rev_id = module_info[MLXSW_REG_MCIA_EEPROM_MODULE_INFO_REV_ID];\n\tmodule_id = module_info[MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID];\n\n\tswitch (module_id) {\n\tcase MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP:\n\t\tmodinfo->type       = ETH_MODULE_SFF_8436;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_MAX_LEN;\n\t\tbreak;\n\tcase MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP_PLUS:\n\tcase MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP28:\n\t\tif (module_id == MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP28 ||\n\t\t    module_rev_id >=\n\t\t    MLXSW_REG_MCIA_EEPROM_MODULE_INFO_REV_ID_8636) {\n\t\t\tmodinfo->type       = ETH_MODULE_SFF_8636;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8636_MAX_LEN;\n\t\t} else {\n\t\t\tmodinfo->type       = ETH_MODULE_SFF_8436;\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8436_MAX_LEN;\n\t\t}\n\t\tbreak;\n\tcase MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_SFP:\n\t\t \n\t\terr = mlxsw_env_query_module_eeprom(mlxsw_core, slot_index,\n\t\t\t\t\t\t    module, SFP_DIAGMON, 1,\n\t\t\t\t\t\t    &diag_mon, false,\n\t\t\t\t\t\t    &read_size);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (read_size < 1)\n\t\t\treturn -EIO;\n\n\t\tmodinfo->type       = ETH_MODULE_SFF_8472;\n\t\tif (diag_mon)\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t\telse\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN / 2;\n\t\tbreak;\n\tcase MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP_DD:\n\tcase MLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_OSFP:\n\t\t \n\t\tmodinfo->type       = ETH_MODULE_SFF_8636;\n\t\t \n\t\tif (module_info[MLXSW_REG_MCIA_EEPROM_MODULE_INFO_TYPE_ID] &\n\t\t    MLXSW_REG_MCIA_EEPROM_CMIS_FLAT_MEMORY)\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8636_LEN;\n\t\telse\n\t\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_env_get_module_info);\n\nint mlxsw_env_get_module_eeprom(struct net_device *netdev,\n\t\t\t\tstruct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t\tint module, struct ethtool_eeprom *ee,\n\t\t\t\tu8 *data)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tint offset = ee->offset;\n\tunsigned int read_size;\n\tbool qsfp, cmis;\n\tint i = 0;\n\tint err;\n\n\tif (!ee->len)\n\t\treturn -EINVAL;\n\n\tif (!mlxsw_env_linecard_is_active(mlxsw_env, slot_index)) {\n\t\tnetdev_err(netdev, \"Cannot read EEPROM of module on an inactive line card\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmemset(data, 0, ee->len);\n\t \n\terr = mlxsw_env_validate_cable_ident(mlxsw_core, slot_index, module,\n\t\t\t\t\t     &qsfp, &cmis);\n\tif (err)\n\t\treturn err;\n\n\twhile (i < ee->len) {\n\t\terr = mlxsw_env_query_module_eeprom(mlxsw_core, slot_index,\n\t\t\t\t\t\t    module, offset,\n\t\t\t\t\t\t    ee->len - i, data + i,\n\t\t\t\t\t\t    qsfp, &read_size);\n\t\tif (err) {\n\t\t\tnetdev_err(netdev, \"Eeprom query failed\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\ti += read_size;\n\t\toffset += read_size;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_env_get_module_eeprom);\n\nstatic int mlxsw_env_mcia_status_process(const char *mcia_pl,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tu8 status = mlxsw_reg_mcia_status_get(mcia_pl);\n\n\tswitch (status) {\n\tcase MLXSW_REG_MCIA_STATUS_GOOD:\n\t\treturn 0;\n\tcase MLXSW_REG_MCIA_STATUS_NO_EEPROM_MODULE:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"No response from module's EEPROM\");\n\t\treturn -EIO;\n\tcase MLXSW_REG_MCIA_STATUS_MODULE_NOT_SUPPORTED:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Module type not supported by the device\");\n\t\treturn -EOPNOTSUPP;\n\tcase MLXSW_REG_MCIA_STATUS_MODULE_NOT_CONNECTED:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"No module present indication\");\n\t\treturn -EIO;\n\tcase MLXSW_REG_MCIA_STATUS_I2C_ERROR:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Error occurred while trying to access module's EEPROM using I2C\");\n\t\treturn -EIO;\n\tcase MLXSW_REG_MCIA_STATUS_MODULE_DISABLED:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Module is disabled\");\n\t\treturn -EIO;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unknown error\");\n\t\treturn -EIO;\n\t}\n}\n\nint\nmlxsw_env_get_module_eeprom_by_page(struct mlxsw_core *mlxsw_core,\n\t\t\t\t    u8 slot_index, u8 module,\n\t\t\t\t    const struct ethtool_module_eeprom *page,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tu32 bytes_read = 0;\n\tu16 device_addr;\n\tint err;\n\n\tif (!mlxsw_env_linecard_is_active(mlxsw_env, slot_index)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Cannot read EEPROM of module on an inactive line card\");\n\t\treturn -EIO;\n\t}\n\n\terr = mlxsw_env_validate_module_type(mlxsw_core, slot_index, module);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"EEPROM is not equipped on port module type\");\n\t\treturn err;\n\t}\n\n\t \n\tdevice_addr = page->offset;\n\n\twhile (bytes_read < page->length) {\n\t\tchar mcia_pl[MLXSW_REG_MCIA_LEN];\n\t\tchar *eeprom_tmp;\n\t\tu8 size;\n\n\t\tsize = min_t(u8, page->length - bytes_read,\n\t\t\t     mlxsw_env->max_eeprom_len);\n\n\t\tmlxsw_reg_mcia_pack(mcia_pl, slot_index, module, page->page,\n\t\t\t\t    device_addr + bytes_read, size,\n\t\t\t\t    page->i2c_address);\n\t\tmlxsw_reg_mcia_bank_number_set(mcia_pl, page->bank);\n\n\t\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mcia), mcia_pl);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to access module's EEPROM\");\n\t\t\treturn err;\n\t\t}\n\n\t\terr = mlxsw_env_mcia_status_process(mcia_pl, extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\teeprom_tmp = mlxsw_reg_mcia_eeprom_data(mcia_pl);\n\t\tmemcpy(page->data + bytes_read, eeprom_tmp, size);\n\t\tbytes_read += size;\n\t}\n\n\treturn bytes_read;\n}\nEXPORT_SYMBOL(mlxsw_env_get_module_eeprom_by_page);\n\nstatic int mlxsw_env_module_reset(struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t\t  u8 module)\n{\n\tchar pmaos_pl[MLXSW_REG_PMAOS_LEN];\n\n\tmlxsw_reg_pmaos_pack(pmaos_pl, slot_index, module);\n\tmlxsw_reg_pmaos_rst_set(pmaos_pl, true);\n\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(pmaos), pmaos_pl);\n}\n\nint mlxsw_env_reset_module(struct net_device *netdev,\n\t\t\t   struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t   u8 module, u32 *flags)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tstruct mlxsw_env_module_info *module_info;\n\tu32 req = *flags;\n\tint err;\n\n\tif (!(req & ETH_RESET_PHY) &&\n\t    !(req & (ETH_RESET_PHY << ETH_RESET_SHARED_SHIFT)))\n\t\treturn 0;\n\n\tif (!mlxsw_env_linecard_is_active(mlxsw_env, slot_index)) {\n\t\tnetdev_err(netdev, \"Cannot reset module on an inactive line card\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmutex_lock(&mlxsw_env->line_cards_lock);\n\n\terr = __mlxsw_env_validate_module_type(mlxsw_core, slot_index, module);\n\tif (err) {\n\t\tnetdev_err(netdev, \"Reset module is not supported on port module type\\n\");\n\t\tgoto out;\n\t}\n\n\tmodule_info = mlxsw_env_module_info_get(mlxsw_core, slot_index, module);\n\tif (module_info->num_ports_up) {\n\t\tnetdev_err(netdev, \"Cannot reset module when ports using it are administratively up\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (module_info->num_ports_mapped > 1 &&\n\t    !(req & (ETH_RESET_PHY << ETH_RESET_SHARED_SHIFT))) {\n\t\tnetdev_err(netdev, \"Cannot reset module without \\\"phy-shared\\\" flag when shared by multiple ports\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = mlxsw_env_module_reset(mlxsw_core, slot_index, module);\n\tif (err) {\n\t\tnetdev_err(netdev, \"Failed to reset module\\n\");\n\t\tgoto out;\n\t}\n\n\t*flags &= ~(ETH_RESET_PHY | (ETH_RESET_PHY << ETH_RESET_SHARED_SHIFT));\n\nout:\n\tmutex_unlock(&mlxsw_env->line_cards_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(mlxsw_env_reset_module);\n\nint\nmlxsw_env_get_module_power_mode(struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t\tu8 module,\n\t\t\t\tstruct ethtool_module_power_mode_params *params,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tstruct mlxsw_env_module_info *module_info;\n\tchar mcion_pl[MLXSW_REG_MCION_LEN];\n\tu32 status_bits;\n\tint err = 0;\n\n\tmutex_lock(&mlxsw_env->line_cards_lock);\n\n\terr = __mlxsw_env_validate_module_type(mlxsw_core, slot_index, module);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Power mode is not supported on port module type\");\n\t\tgoto out;\n\t}\n\n\tmodule_info = mlxsw_env_module_info_get(mlxsw_core, slot_index, module);\n\tparams->policy = module_info->power_mode_policy;\n\n\t \n\tif (!__mlxsw_env_linecard_is_active(mlxsw_env, slot_index))\n\t\tgoto out;\n\n\tmlxsw_reg_mcion_pack(mcion_pl, slot_index, module);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mcion), mcion_pl);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to retrieve module's power mode\");\n\t\tgoto out;\n\t}\n\n\tstatus_bits = mlxsw_reg_mcion_module_status_bits_get(mcion_pl);\n\tif (!(status_bits & MLXSW_REG_MCION_MODULE_STATUS_BITS_PRESENT_MASK))\n\t\tgoto out;\n\n\tif (status_bits & MLXSW_REG_MCION_MODULE_STATUS_BITS_LOW_POWER_MASK)\n\t\tparams->mode = ETHTOOL_MODULE_POWER_MODE_LOW;\n\telse\n\t\tparams->mode = ETHTOOL_MODULE_POWER_MODE_HIGH;\n\nout:\n\tmutex_unlock(&mlxsw_env->line_cards_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(mlxsw_env_get_module_power_mode);\n\nstatic int mlxsw_env_module_enable_set(struct mlxsw_core *mlxsw_core,\n\t\t\t\t       u8 slot_index, u8 module, bool enable)\n{\n\tenum mlxsw_reg_pmaos_admin_status admin_status;\n\tchar pmaos_pl[MLXSW_REG_PMAOS_LEN];\n\n\tmlxsw_reg_pmaos_pack(pmaos_pl, slot_index, module);\n\tadmin_status = enable ? MLXSW_REG_PMAOS_ADMIN_STATUS_ENABLED :\n\t\t\t\tMLXSW_REG_PMAOS_ADMIN_STATUS_DISABLED;\n\tmlxsw_reg_pmaos_admin_status_set(pmaos_pl, admin_status);\n\tmlxsw_reg_pmaos_ase_set(pmaos_pl, true);\n\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(pmaos), pmaos_pl);\n}\n\nstatic int mlxsw_env_module_low_power_set(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t  u8 slot_index, u8 module,\n\t\t\t\t\t  bool low_power)\n{\n\tu16 eeprom_override_mask, eeprom_override;\n\tchar pmmp_pl[MLXSW_REG_PMMP_LEN];\n\n\tmlxsw_reg_pmmp_pack(pmmp_pl, slot_index, module);\n\tmlxsw_reg_pmmp_sticky_set(pmmp_pl, true);\n\t \n\teeprom_override_mask = ~MLXSW_REG_PMMP_EEPROM_OVERRIDE_LOW_POWER_MASK;\n\tmlxsw_reg_pmmp_eeprom_override_mask_set(pmmp_pl, eeprom_override_mask);\n\teeprom_override = low_power ? MLXSW_REG_PMMP_EEPROM_OVERRIDE_LOW_POWER_MASK :\n\t\t\t\t      0;\n\tmlxsw_reg_pmmp_eeprom_override_set(pmmp_pl, eeprom_override);\n\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(pmmp), pmmp_pl);\n}\n\nstatic int __mlxsw_env_set_module_power_mode(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t     u8 slot_index, u8 module,\n\t\t\t\t\t     bool low_power,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tint err;\n\n\t \n\tif (!__mlxsw_env_linecard_is_active(mlxsw_env, slot_index))\n\t\treturn 0;\n\n\terr = mlxsw_env_module_enable_set(mlxsw_core, slot_index, module, false);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to disable module\");\n\t\treturn err;\n\t}\n\n\terr = mlxsw_env_module_low_power_set(mlxsw_core, slot_index, module,\n\t\t\t\t\t     low_power);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to set module's power mode\");\n\t\tgoto err_module_low_power_set;\n\t}\n\n\terr = mlxsw_env_module_enable_set(mlxsw_core, slot_index, module, true);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to enable module\");\n\t\tgoto err_module_enable_set;\n\t}\n\n\treturn 0;\n\nerr_module_enable_set:\n\tmlxsw_env_module_low_power_set(mlxsw_core, slot_index, module,\n\t\t\t\t       !low_power);\nerr_module_low_power_set:\n\tmlxsw_env_module_enable_set(mlxsw_core, slot_index, module, true);\n\treturn err;\n}\n\nstatic int\nmlxsw_env_set_module_power_mode_apply(struct mlxsw_core *mlxsw_core,\n\t\t\t\t      u8 slot_index, u8 module,\n\t\t\t\t      enum ethtool_module_power_mode_policy policy,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_env_module_info *module_info;\n\tbool low_power;\n\tint err = 0;\n\n\terr = __mlxsw_env_validate_module_type(mlxsw_core, slot_index, module);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Power mode set is not supported on port module type\");\n\t\tgoto out;\n\t}\n\n\tmodule_info = mlxsw_env_module_info_get(mlxsw_core, slot_index, module);\n\tif (module_info->power_mode_policy == policy)\n\t\tgoto out;\n\n\t \n\tif (module_info->num_ports_up)\n\t\tgoto out_set_policy;\n\n\tlow_power = policy == ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO;\n\terr = __mlxsw_env_set_module_power_mode(mlxsw_core, slot_index, module,\n\t\t\t\t\t\tlow_power, extack);\n\tif (err)\n\t\tgoto out;\n\nout_set_policy:\n\tmodule_info->power_mode_policy = policy;\nout:\n\treturn err;\n}\n\nint\nmlxsw_env_set_module_power_mode(struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t\tu8 module,\n\t\t\t\tenum ethtool_module_power_mode_policy policy,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tint err;\n\n\tif (policy != ETHTOOL_MODULE_POWER_MODE_POLICY_HIGH &&\n\t    policy != ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported power mode policy\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&mlxsw_env->line_cards_lock);\n\terr = mlxsw_env_set_module_power_mode_apply(mlxsw_core, slot_index,\n\t\t\t\t\t\t    module, policy, extack);\n\tmutex_unlock(&mlxsw_env->line_cards_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(mlxsw_env_set_module_power_mode);\n\nstatic int mlxsw_env_module_has_temp_sensor(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t    u8 slot_index, u8 module,\n\t\t\t\t\t    bool *p_has_temp_sensor)\n{\n\tchar mtbr_pl[MLXSW_REG_MTBR_LEN];\n\tu16 temp;\n\tint err;\n\n\tmlxsw_reg_mtbr_pack(mtbr_pl, slot_index,\n\t\t\t    MLXSW_REG_MTBR_BASE_MODULE_INDEX + module, 1);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mtbr), mtbr_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mtbr_temp_unpack(mtbr_pl, 0, &temp, NULL);\n\n\tswitch (temp) {\n\tcase MLXSW_REG_MTBR_BAD_SENS_INFO:\n\tcase MLXSW_REG_MTBR_NO_CONN:\n\tcase MLXSW_REG_MTBR_NO_TEMP_SENS:\n\tcase MLXSW_REG_MTBR_INDEX_NA:\n\t\t*p_has_temp_sensor = false;\n\t\tbreak;\n\tdefault:\n\t\t*p_has_temp_sensor = temp ? true : false;\n\t}\n\treturn 0;\n}\n\nstatic int\nmlxsw_env_temp_event_set(struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t u16 sensor_index, bool enable)\n{\n\tchar mtmp_pl[MLXSW_REG_MTMP_LEN] = {0};\n\tenum mlxsw_reg_mtmp_tee tee;\n\tint err, threshold_hi;\n\n\tmlxsw_reg_mtmp_slot_index_set(mtmp_pl, slot_index);\n\tmlxsw_reg_mtmp_sensor_index_set(mtmp_pl, sensor_index);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mtmp), mtmp_pl);\n\tif (err)\n\t\treturn err;\n\n\tif (enable) {\n\t\terr = mlxsw_env_module_temp_thresholds_get(mlxsw_core,\n\t\t\t\t\t\t\t   slot_index,\n\t\t\t\t\t\t\t   sensor_index -\n\t\t\t\t\t\t\t   MLXSW_REG_MTMP_MODULE_INDEX_MIN,\n\t\t\t\t\t\t\t   SFP_TEMP_HIGH_WARN,\n\t\t\t\t\t\t\t   &threshold_hi);\n\t\t \n\t\tif (err)\n\t\t\tthreshold_hi = MLXSW_REG_MTMP_THRESH_HI;\n\t\telse\n\t\t\t \n\t\t\tthreshold_hi = threshold_hi / 1000 * 8;\n\n\t\tmlxsw_reg_mtmp_temperature_threshold_hi_set(mtmp_pl, threshold_hi);\n\t\tmlxsw_reg_mtmp_temperature_threshold_lo_set(mtmp_pl, threshold_hi -\n\t\t\t\t\t\t\t    MLXSW_REG_MTMP_HYSTERESIS_TEMP);\n\t}\n\ttee = enable ? MLXSW_REG_MTMP_TEE_GENERATE_EVENT : MLXSW_REG_MTMP_TEE_NO_EVENT;\n\tmlxsw_reg_mtmp_tee_set(mtmp_pl, tee);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mtmp), mtmp_pl);\n}\n\nstatic int mlxsw_env_module_temp_event_enable(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t      u8 slot_index)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tint i, err, sensor_index;\n\tbool has_temp_sensor;\n\n\tfor (i = 0; i < mlxsw_env->line_cards[slot_index]->module_count; i++) {\n\t\terr = mlxsw_env_module_has_temp_sensor(mlxsw_core, slot_index,\n\t\t\t\t\t\t       i, &has_temp_sensor);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!has_temp_sensor)\n\t\t\tcontinue;\n\n\t\tsensor_index = i + MLXSW_REG_MTMP_MODULE_INDEX_MIN;\n\t\terr = mlxsw_env_temp_event_set(mlxsw_core, slot_index,\n\t\t\t\t\t       sensor_index, true);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstruct mlxsw_env_module_temp_warn_event {\n\tstruct mlxsw_env *mlxsw_env;\n\tchar mtwe_pl[MLXSW_REG_MTWE_LEN];\n\tstruct work_struct work;\n};\n\nstatic void mlxsw_env_mtwe_event_work(struct work_struct *work)\n{\n\tstruct mlxsw_env_module_temp_warn_event *event;\n\tstruct mlxsw_env_module_info *module_info;\n\tstruct mlxsw_env *mlxsw_env;\n\tint i, sensor_warning;\n\tbool is_overheat;\n\n\tevent = container_of(work, struct mlxsw_env_module_temp_warn_event,\n\t\t\t     work);\n\tmlxsw_env = event->mlxsw_env;\n\n\tfor (i = 0; i < mlxsw_env->max_module_count; i++) {\n\t\t \n\t\tsensor_warning =\n\t\t\tmlxsw_reg_mtwe_sensor_warning_get(event->mtwe_pl,\n\t\t\t\t\t\t\t  i + MLXSW_REG_MTMP_MODULE_INDEX_MIN);\n\t\tmutex_lock(&mlxsw_env->line_cards_lock);\n\t\t \n\t\tmodule_info = mlxsw_env_module_info_get(mlxsw_env->core, 0, i);\n\t\tis_overheat = module_info->is_overheat;\n\n\t\tif ((is_overheat && sensor_warning) ||\n\t\t    (!is_overheat && !sensor_warning)) {\n\t\t\t \n\t\t\tmutex_unlock(&mlxsw_env->line_cards_lock);\n\t\t\tcontinue;\n\t\t} else if (is_overheat && !sensor_warning) {\n\t\t\t \n\t\t\tmodule_info->is_overheat = false;\n\t\t\tmutex_unlock(&mlxsw_env->line_cards_lock);\n\t\t} else {\n\t\t\t \n\t\t\tmodule_info->is_overheat = true;\n\t\t\tmodule_info->module_overheat_counter++;\n\t\t\tmutex_unlock(&mlxsw_env->line_cards_lock);\n\t\t}\n\t}\n\n\tkfree(event);\n}\n\nstatic void\nmlxsw_env_mtwe_listener_func(const struct mlxsw_reg_info *reg, char *mtwe_pl,\n\t\t\t     void *priv)\n{\n\tstruct mlxsw_env_module_temp_warn_event *event;\n\tstruct mlxsw_env *mlxsw_env = priv;\n\n\tevent = kmalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event)\n\t\treturn;\n\n\tevent->mlxsw_env = mlxsw_env;\n\tmemcpy(event->mtwe_pl, mtwe_pl, MLXSW_REG_MTWE_LEN);\n\tINIT_WORK(&event->work, mlxsw_env_mtwe_event_work);\n\tmlxsw_core_schedule_work(&event->work);\n}\n\nstatic const struct mlxsw_listener mlxsw_env_temp_warn_listener =\n\tMLXSW_CORE_EVENTL(mlxsw_env_mtwe_listener_func, MTWE);\n\nstatic int mlxsw_env_temp_warn_event_register(struct mlxsw_core *mlxsw_core)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\n\treturn mlxsw_core_trap_register(mlxsw_core,\n\t\t\t\t\t&mlxsw_env_temp_warn_listener,\n\t\t\t\t\tmlxsw_env);\n}\n\nstatic void mlxsw_env_temp_warn_event_unregister(struct mlxsw_env *mlxsw_env)\n{\n\tmlxsw_core_trap_unregister(mlxsw_env->core,\n\t\t\t\t   &mlxsw_env_temp_warn_listener, mlxsw_env);\n}\n\nstruct mlxsw_env_module_plug_unplug_event {\n\tstruct mlxsw_env *mlxsw_env;\n\tu8 slot_index;\n\tu8 module;\n\tstruct work_struct work;\n};\n\nstatic void mlxsw_env_pmpe_event_work(struct work_struct *work)\n{\n\tstruct mlxsw_env_module_plug_unplug_event *event;\n\tstruct mlxsw_env_module_info *module_info;\n\tstruct mlxsw_env *mlxsw_env;\n\tbool has_temp_sensor;\n\tu16 sensor_index;\n\tint err;\n\n\tevent = container_of(work, struct mlxsw_env_module_plug_unplug_event,\n\t\t\t     work);\n\tmlxsw_env = event->mlxsw_env;\n\n\tmutex_lock(&mlxsw_env->line_cards_lock);\n\tmodule_info = mlxsw_env_module_info_get(mlxsw_env->core,\n\t\t\t\t\t\tevent->slot_index,\n\t\t\t\t\t\tevent->module);\n\tmodule_info->is_overheat = false;\n\tmutex_unlock(&mlxsw_env->line_cards_lock);\n\n\terr = mlxsw_env_module_has_temp_sensor(mlxsw_env->core,\n\t\t\t\t\t       event->slot_index,\n\t\t\t\t\t       event->module,\n\t\t\t\t\t       &has_temp_sensor);\n\t \n\tif (err)\n\t\tgoto out;\n\n\tif (!has_temp_sensor)\n\t\tgoto out;\n\n\tsensor_index = event->module + MLXSW_REG_MTMP_MODULE_INDEX_MIN;\n\tmlxsw_env_temp_event_set(mlxsw_env->core, event->slot_index,\n\t\t\t\t sensor_index, true);\n\nout:\n\tkfree(event);\n}\n\nstatic void\nmlxsw_env_pmpe_listener_func(const struct mlxsw_reg_info *reg, char *pmpe_pl,\n\t\t\t     void *priv)\n{\n\tu8 slot_index = mlxsw_reg_pmpe_slot_index_get(pmpe_pl);\n\tstruct mlxsw_env_module_plug_unplug_event *event;\n\tenum mlxsw_reg_pmpe_module_status module_status;\n\tu8 module = mlxsw_reg_pmpe_module_get(pmpe_pl);\n\tstruct mlxsw_env *mlxsw_env = priv;\n\n\tif (WARN_ON_ONCE(module >= mlxsw_env->max_module_count ||\n\t\t\t slot_index >= mlxsw_env->num_of_slots))\n\t\treturn;\n\n\tmodule_status = mlxsw_reg_pmpe_module_status_get(pmpe_pl);\n\tif (module_status != MLXSW_REG_PMPE_MODULE_STATUS_PLUGGED_ENABLED)\n\t\treturn;\n\n\tevent = kmalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event)\n\t\treturn;\n\n\tevent->mlxsw_env = mlxsw_env;\n\tevent->slot_index = slot_index;\n\tevent->module = module;\n\tINIT_WORK(&event->work, mlxsw_env_pmpe_event_work);\n\tmlxsw_core_schedule_work(&event->work);\n}\n\nstatic const struct mlxsw_listener mlxsw_env_module_plug_listener =\n\tMLXSW_CORE_EVENTL(mlxsw_env_pmpe_listener_func, PMPE);\n\nstatic int\nmlxsw_env_module_plug_event_register(struct mlxsw_core *mlxsw_core)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\n\treturn mlxsw_core_trap_register(mlxsw_core,\n\t\t\t\t\t&mlxsw_env_module_plug_listener,\n\t\t\t\t\tmlxsw_env);\n}\n\nstatic void\nmlxsw_env_module_plug_event_unregister(struct mlxsw_env *mlxsw_env)\n{\n\tmlxsw_core_trap_unregister(mlxsw_env->core,\n\t\t\t\t   &mlxsw_env_module_plug_listener,\n\t\t\t\t   mlxsw_env);\n}\n\nstatic int\nmlxsw_env_module_oper_state_event_enable(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t u8 slot_index)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tint i, err;\n\n\tfor (i = 0; i < mlxsw_env->line_cards[slot_index]->module_count; i++) {\n\t\tchar pmaos_pl[MLXSW_REG_PMAOS_LEN];\n\n\t\tmlxsw_reg_pmaos_pack(pmaos_pl, slot_index, i);\n\t\tmlxsw_reg_pmaos_e_set(pmaos_pl,\n\t\t\t\t      MLXSW_REG_PMAOS_E_GENERATE_EVENT);\n\t\tmlxsw_reg_pmaos_ee_set(pmaos_pl, true);\n\t\terr = mlxsw_reg_write(mlxsw_core, MLXSW_REG(pmaos), pmaos_pl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nint\nmlxsw_env_module_overheat_counter_get(struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t\t      u8 module, u64 *p_counter)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tstruct mlxsw_env_module_info *module_info;\n\n\tmutex_lock(&mlxsw_env->line_cards_lock);\n\tmodule_info = mlxsw_env_module_info_get(mlxsw_core, slot_index, module);\n\t*p_counter = module_info->module_overheat_counter;\n\tmutex_unlock(&mlxsw_env->line_cards_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_env_module_overheat_counter_get);\n\nvoid mlxsw_env_module_port_map(struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t       u8 module)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tstruct mlxsw_env_module_info *module_info;\n\n\tmutex_lock(&mlxsw_env->line_cards_lock);\n\tmodule_info = mlxsw_env_module_info_get(mlxsw_core, slot_index, module);\n\tmodule_info->num_ports_mapped++;\n\tmutex_unlock(&mlxsw_env->line_cards_lock);\n}\nEXPORT_SYMBOL(mlxsw_env_module_port_map);\n\nvoid mlxsw_env_module_port_unmap(struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t\t u8 module)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tstruct mlxsw_env_module_info *module_info;\n\n\tmutex_lock(&mlxsw_env->line_cards_lock);\n\tmodule_info = mlxsw_env_module_info_get(mlxsw_core, slot_index, module);\n\tmodule_info->num_ports_mapped--;\n\tmutex_unlock(&mlxsw_env->line_cards_lock);\n}\nEXPORT_SYMBOL(mlxsw_env_module_port_unmap);\n\nint mlxsw_env_module_port_up(struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t     u8 module)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tstruct mlxsw_env_module_info *module_info;\n\tint err = 0;\n\n\tmutex_lock(&mlxsw_env->line_cards_lock);\n\n\tmodule_info = mlxsw_env_module_info_get(mlxsw_core, slot_index, module);\n\tif (module_info->power_mode_policy !=\n\t    ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO)\n\t\tgoto out_inc;\n\n\tif (module_info->num_ports_up != 0)\n\t\tgoto out_inc;\n\n\t \n\terr = __mlxsw_env_set_module_power_mode(mlxsw_core, slot_index, module,\n\t\t\t\t\t\tfalse, NULL);\n\tif (err)\n\t\tgoto out_unlock;\n\nout_inc:\n\tmodule_info->num_ports_up++;\nout_unlock:\n\tmutex_unlock(&mlxsw_env->line_cards_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(mlxsw_env_module_port_up);\n\nvoid mlxsw_env_module_port_down(struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t\tu8 module)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tstruct mlxsw_env_module_info *module_info;\n\n\tmutex_lock(&mlxsw_env->line_cards_lock);\n\n\tmodule_info = mlxsw_env_module_info_get(mlxsw_core, slot_index, module);\n\tmodule_info->num_ports_up--;\n\n\tif (module_info->power_mode_policy !=\n\t    ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO)\n\t\tgoto out_unlock;\n\n\tif (module_info->num_ports_up != 0)\n\t\tgoto out_unlock;\n\n\t \n\t__mlxsw_env_set_module_power_mode(mlxsw_core, slot_index, module, true,\n\t\t\t\t\t  NULL);\n\nout_unlock:\n\tmutex_unlock(&mlxsw_env->line_cards_lock);\n}\nEXPORT_SYMBOL(mlxsw_env_module_port_down);\n\nstatic int mlxsw_env_line_cards_alloc(struct mlxsw_env *env)\n{\n\tstruct mlxsw_env_module_info *module_info;\n\tint i, j;\n\n\tfor (i = 0; i < env->num_of_slots; i++) {\n\t\tenv->line_cards[i] = kzalloc(struct_size(env->line_cards[i],\n\t\t\t\t\t\t\t module_info,\n\t\t\t\t\t\t\t env->max_module_count),\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!env->line_cards[i])\n\t\t\tgoto kzalloc_err;\n\n\t\t \n\t\tfor (j = 0; j < env->max_module_count; j++) {\n\t\t\tmodule_info = &env->line_cards[i]->module_info[j];\n\t\t\tmodule_info->power_mode_policy =\n\t\t\t\t\tETHTOOL_MODULE_POWER_MODE_POLICY_HIGH;\n\t\t}\n\t}\n\n\treturn 0;\n\nkzalloc_err:\n\tfor (i--; i >= 0; i--)\n\t\tkfree(env->line_cards[i]);\n\treturn -ENOMEM;\n}\n\nstatic void mlxsw_env_line_cards_free(struct mlxsw_env *env)\n{\n\tint i = env->num_of_slots;\n\n\tfor (i--; i >= 0; i--)\n\t\tkfree(env->line_cards[i]);\n}\n\nstatic int\nmlxsw_env_module_event_enable(struct mlxsw_env *mlxsw_env, u8 slot_index)\n{\n\tint err;\n\n\terr = mlxsw_env_module_oper_state_event_enable(mlxsw_env->core,\n\t\t\t\t\t\t       slot_index);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_env_module_temp_event_enable(mlxsw_env->core, slot_index);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void\nmlxsw_env_module_event_disable(struct mlxsw_env *mlxsw_env, u8 slot_index)\n{\n}\n\nstatic int\nmlxsw_env_module_type_set(struct mlxsw_core *mlxsw_core, u8 slot_index)\n{\n\tstruct mlxsw_env *mlxsw_env = mlxsw_core_env(mlxsw_core);\n\tint i;\n\n\tfor (i = 0; i < mlxsw_env->line_cards[slot_index]->module_count; i++) {\n\t\tstruct mlxsw_env_module_info *module_info;\n\t\tchar pmtm_pl[MLXSW_REG_PMTM_LEN];\n\t\tint err;\n\n\t\tmlxsw_reg_pmtm_pack(pmtm_pl, slot_index, i);\n\t\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(pmtm), pmtm_pl);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmodule_info = mlxsw_env_module_info_get(mlxsw_core, slot_index,\n\t\t\t\t\t\t\ti);\n\t\tmodule_info->type = mlxsw_reg_pmtm_module_type_get(pmtm_pl);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nmlxsw_env_linecard_modules_power_mode_apply(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t    struct mlxsw_env *env,\n\t\t\t\t\t    u8 slot_index)\n{\n\tint i;\n\n\tfor (i = 0; i < env->line_cards[slot_index]->module_count; i++) {\n\t\tenum ethtool_module_power_mode_policy policy;\n\t\tstruct mlxsw_env_module_info *module_info;\n\t\tstruct netlink_ext_ack extack;\n\t\tint err;\n\n\t\tmodule_info = &env->line_cards[slot_index]->module_info[i];\n\t\tpolicy = module_info->power_mode_policy;\n\t\terr = mlxsw_env_set_module_power_mode_apply(mlxsw_core,\n\t\t\t\t\t\t\t    slot_index, i,\n\t\t\t\t\t\t\t    policy, &extack);\n\t\tif (err)\n\t\t\tdev_err(env->bus_info->dev, \"%s\\n\", extack._msg);\n\t}\n}\n\nstatic void\nmlxsw_env_got_active(struct mlxsw_core *mlxsw_core, u8 slot_index, void *priv)\n{\n\tstruct mlxsw_env *mlxsw_env = priv;\n\tchar mgpir_pl[MLXSW_REG_MGPIR_LEN];\n\tint err;\n\n\tmutex_lock(&mlxsw_env->line_cards_lock);\n\tif (__mlxsw_env_linecard_is_active(mlxsw_env, slot_index))\n\t\tgoto out_unlock;\n\n\tmlxsw_reg_mgpir_pack(mgpir_pl, slot_index);\n\terr = mlxsw_reg_query(mlxsw_env->core, MLXSW_REG(mgpir), mgpir_pl);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tmlxsw_reg_mgpir_unpack(mgpir_pl, NULL, NULL, NULL,\n\t\t\t       &mlxsw_env->line_cards[slot_index]->module_count,\n\t\t\t       NULL);\n\n\terr = mlxsw_env_module_event_enable(mlxsw_env, slot_index);\n\tif (err) {\n\t\tdev_err(mlxsw_env->bus_info->dev, \"Failed to enable port module events for line card in slot %d\\n\",\n\t\t\tslot_index);\n\t\tgoto err_mlxsw_env_module_event_enable;\n\t}\n\terr = mlxsw_env_module_type_set(mlxsw_env->core, slot_index);\n\tif (err) {\n\t\tdev_err(mlxsw_env->bus_info->dev, \"Failed to set modules' type for line card in slot %d\\n\",\n\t\t\tslot_index);\n\t\tgoto err_type_set;\n\t}\n\n\tmlxsw_env->line_cards[slot_index]->active = true;\n\t \n\tmlxsw_env_linecard_modules_power_mode_apply(mlxsw_core, mlxsw_env,\n\t\t\t\t\t\t    slot_index);\n\tmutex_unlock(&mlxsw_env->line_cards_lock);\n\n\treturn;\n\nerr_type_set:\n\tmlxsw_env_module_event_disable(mlxsw_env, slot_index);\nerr_mlxsw_env_module_event_enable:\nout_unlock:\n\tmutex_unlock(&mlxsw_env->line_cards_lock);\n}\n\nstatic void\nmlxsw_env_got_inactive(struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t       void *priv)\n{\n\tstruct mlxsw_env *mlxsw_env = priv;\n\n\tmutex_lock(&mlxsw_env->line_cards_lock);\n\tif (!__mlxsw_env_linecard_is_active(mlxsw_env, slot_index))\n\t\tgoto out_unlock;\n\tmlxsw_env->line_cards[slot_index]->active = false;\n\tmlxsw_env_module_event_disable(mlxsw_env, slot_index);\n\tmlxsw_env->line_cards[slot_index]->module_count = 0;\nout_unlock:\n\tmutex_unlock(&mlxsw_env->line_cards_lock);\n}\n\nstatic struct mlxsw_linecards_event_ops mlxsw_env_event_ops = {\n\t.got_active = mlxsw_env_got_active,\n\t.got_inactive = mlxsw_env_got_inactive,\n};\n\nstatic int mlxsw_env_max_module_eeprom_len_query(struct mlxsw_env *mlxsw_env)\n{\n\tchar mcam_pl[MLXSW_REG_MCAM_LEN];\n\tbool mcia_128b_supported;\n\tint err;\n\n\tmlxsw_reg_mcam_pack(mcam_pl,\n\t\t\t    MLXSW_REG_MCAM_FEATURE_GROUP_ENHANCED_FEATURES);\n\terr = mlxsw_reg_query(mlxsw_env->core, MLXSW_REG(mcam), mcam_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mcam_unpack(mcam_pl, MLXSW_REG_MCAM_MCIA_128B,\n\t\t\t      &mcia_128b_supported);\n\n\tmlxsw_env->max_eeprom_len = mcia_128b_supported ? 128 : 48;\n\n\treturn 0;\n}\n\nint mlxsw_env_init(struct mlxsw_core *mlxsw_core,\n\t\t   const struct mlxsw_bus_info *bus_info,\n\t\t   struct mlxsw_env **p_env)\n{\n\tu8 module_count, num_of_slots, max_module_count;\n\tchar mgpir_pl[MLXSW_REG_MGPIR_LEN];\n\tstruct mlxsw_env *env;\n\tint err;\n\n\tmlxsw_reg_mgpir_pack(mgpir_pl, 0);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mgpir), mgpir_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mgpir_unpack(mgpir_pl, NULL, NULL, NULL, &module_count,\n\t\t\t       &num_of_slots);\n\t \n\tmax_module_count = num_of_slots ?\n\t\t\t   mlxsw_reg_mgpir_max_modules_per_slot_get(mgpir_pl) :\n\t\t\t   module_count;\n\n\tenv = kzalloc(struct_size(env, line_cards, num_of_slots + 1),\n\t\t      GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\n\tenv->core = mlxsw_core;\n\tenv->bus_info = bus_info;\n\tenv->num_of_slots = num_of_slots + 1;\n\tenv->max_module_count = max_module_count;\n\terr = mlxsw_env_line_cards_alloc(env);\n\tif (err)\n\t\tgoto err_mlxsw_env_line_cards_alloc;\n\n\tmutex_init(&env->line_cards_lock);\n\t*p_env = env;\n\n\terr = mlxsw_linecards_event_ops_register(env->core,\n\t\t\t\t\t\t &mlxsw_env_event_ops, env);\n\tif (err)\n\t\tgoto err_linecards_event_ops_register;\n\n\terr = mlxsw_env_temp_warn_event_register(mlxsw_core);\n\tif (err)\n\t\tgoto err_temp_warn_event_register;\n\n\terr = mlxsw_env_module_plug_event_register(mlxsw_core);\n\tif (err)\n\t\tgoto err_module_plug_event_register;\n\n\t \n\tenv->line_cards[0]->module_count = num_of_slots ? 0 : module_count;\n\t \n\terr = mlxsw_env_module_event_enable(env, 0);\n\tif (err)\n\t\tgoto err_mlxsw_env_module_event_enable;\n\n\terr = mlxsw_env_module_type_set(mlxsw_core, 0);\n\tif (err)\n\t\tgoto err_type_set;\n\n\terr = mlxsw_env_max_module_eeprom_len_query(env);\n\tif (err)\n\t\tgoto err_eeprom_len_query;\n\n\tenv->line_cards[0]->active = true;\n\n\treturn 0;\n\nerr_eeprom_len_query:\nerr_type_set:\n\tmlxsw_env_module_event_disable(env, 0);\nerr_mlxsw_env_module_event_enable:\n\tmlxsw_env_module_plug_event_unregister(env);\nerr_module_plug_event_register:\n\tmlxsw_env_temp_warn_event_unregister(env);\nerr_temp_warn_event_register:\n\tmlxsw_linecards_event_ops_unregister(env->core,\n\t\t\t\t\t     &mlxsw_env_event_ops, env);\nerr_linecards_event_ops_register:\n\tmutex_destroy(&env->line_cards_lock);\n\tmlxsw_env_line_cards_free(env);\nerr_mlxsw_env_line_cards_alloc:\n\tkfree(env);\n\treturn err;\n}\n\nvoid mlxsw_env_fini(struct mlxsw_env *env)\n{\n\tenv->line_cards[0]->active = false;\n\tmlxsw_env_module_event_disable(env, 0);\n\tmlxsw_env_module_plug_event_unregister(env);\n\t \n\tmlxsw_core_flush_owq();\n\tmlxsw_env_temp_warn_event_unregister(env);\n\tmlxsw_linecards_event_ops_unregister(env->core,\n\t\t\t\t\t     &mlxsw_env_event_ops, env);\n\tmutex_destroy(&env->line_cards_lock);\n\tmlxsw_env_line_cards_free(env);\n\tkfree(env);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}