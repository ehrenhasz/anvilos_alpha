{
  "module_name": "spectrum_buffers.c",
  "hash_id": "02b959fe0d2f26b5c6c059f7e2576f9eab6a502517c00bd51fc8f9dab58927eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_buffers.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/dcbnl.h>\n#include <linux/if_ether.h>\n#include <linux/list.h>\n#include <linux/netlink.h>\n\n#include \"spectrum.h\"\n#include \"core.h\"\n#include \"port.h\"\n#include \"reg.h\"\n\nstruct mlxsw_sp_sb_pr {\n\tenum mlxsw_reg_sbpr_mode mode;\n\tu32 size;\n\tu8 freeze_mode:1,\n\t   freeze_size:1;\n};\n\nstruct mlxsw_cp_sb_occ {\n\tu32 cur;\n\tu32 max;\n};\n\nstruct mlxsw_sp_sb_cm {\n\tu32 min_buff;\n\tu32 max_buff;\n\tu16 pool_index;\n\tstruct mlxsw_cp_sb_occ occ;\n\tu8 freeze_pool:1,\n\t   freeze_thresh:1;\n};\n\n#define MLXSW_SP_SB_INFI -1U\n#define MLXSW_SP_SB_REST -2U\n\nstruct mlxsw_sp_sb_pm {\n\tu32 min_buff;\n\tu32 max_buff;\n\tstruct mlxsw_cp_sb_occ occ;\n};\n\nstruct mlxsw_sp_sb_mm {\n\tu32 min_buff;\n\tu32 max_buff;\n\tu16 pool_index;\n};\n\nstruct mlxsw_sp_sb_pool_des {\n\tenum mlxsw_reg_sbxx_dir dir;\n\tu8 pool;\n};\n\n#define MLXSW_SP_SB_POOL_ING\t\t0\n#define MLXSW_SP_SB_POOL_EGR\t\t4\n#define MLXSW_SP_SB_POOL_EGR_MC\t\t8\n#define MLXSW_SP_SB_POOL_ING_CPU\t9\n#define MLXSW_SP_SB_POOL_EGR_CPU\t10\n\nstatic const struct mlxsw_sp_sb_pool_des mlxsw_sp1_sb_pool_dess[] = {\n\t{MLXSW_REG_SBXX_DIR_INGRESS, 0},\n\t{MLXSW_REG_SBXX_DIR_INGRESS, 1},\n\t{MLXSW_REG_SBXX_DIR_INGRESS, 2},\n\t{MLXSW_REG_SBXX_DIR_INGRESS, 3},\n\t{MLXSW_REG_SBXX_DIR_EGRESS, 0},\n\t{MLXSW_REG_SBXX_DIR_EGRESS, 1},\n\t{MLXSW_REG_SBXX_DIR_EGRESS, 2},\n\t{MLXSW_REG_SBXX_DIR_EGRESS, 3},\n\t{MLXSW_REG_SBXX_DIR_EGRESS, 15},\n\t{MLXSW_REG_SBXX_DIR_INGRESS, 4},\n\t{MLXSW_REG_SBXX_DIR_EGRESS, 4},\n};\n\nstatic const struct mlxsw_sp_sb_pool_des mlxsw_sp2_sb_pool_dess[] = {\n\t{MLXSW_REG_SBXX_DIR_INGRESS, 0},\n\t{MLXSW_REG_SBXX_DIR_INGRESS, 1},\n\t{MLXSW_REG_SBXX_DIR_INGRESS, 2},\n\t{MLXSW_REG_SBXX_DIR_INGRESS, 3},\n\t{MLXSW_REG_SBXX_DIR_EGRESS, 0},\n\t{MLXSW_REG_SBXX_DIR_EGRESS, 1},\n\t{MLXSW_REG_SBXX_DIR_EGRESS, 2},\n\t{MLXSW_REG_SBXX_DIR_EGRESS, 3},\n\t{MLXSW_REG_SBXX_DIR_EGRESS, 15},\n\t{MLXSW_REG_SBXX_DIR_INGRESS, 4},\n\t{MLXSW_REG_SBXX_DIR_EGRESS, 4},\n};\n\n#define MLXSW_SP_SB_ING_TC_COUNT 8\n#define MLXSW_SP_SB_EG_TC_COUNT 16\n\nstruct mlxsw_sp_sb_port {\n\tstruct mlxsw_sp_sb_cm ing_cms[MLXSW_SP_SB_ING_TC_COUNT];\n\tstruct mlxsw_sp_sb_cm eg_cms[MLXSW_SP_SB_EG_TC_COUNT];\n\tstruct mlxsw_sp_sb_pm *pms;\n};\n\nstruct mlxsw_sp_sb {\n\tstruct mlxsw_sp_sb_pr *prs;\n\tstruct mlxsw_sp_sb_port *ports;\n\tu32 cell_size;\n\tu32 max_headroom_cells;\n\tu64 sb_size;\n};\n\nstruct mlxsw_sp_sb_vals {\n\tunsigned int pool_count;\n\tconst struct mlxsw_sp_sb_pool_des *pool_dess;\n\tconst struct mlxsw_sp_sb_pm *pms;\n\tconst struct mlxsw_sp_sb_pm *pms_cpu;\n\tconst struct mlxsw_sp_sb_pr *prs;\n\tconst struct mlxsw_sp_sb_mm *mms;\n\tconst struct mlxsw_sp_sb_cm *cms_ingress;\n\tconst struct mlxsw_sp_sb_cm *cms_egress;\n\tconst struct mlxsw_sp_sb_cm *cms_cpu;\n\tunsigned int mms_count;\n\tunsigned int cms_ingress_count;\n\tunsigned int cms_egress_count;\n\tunsigned int cms_cpu_count;\n};\n\nstruct mlxsw_sp_sb_ops {\n\tu32 (*int_buf_size_get)(int mtu, u32 speed);\n};\n\nu32 mlxsw_sp_cells_bytes(const struct mlxsw_sp *mlxsw_sp, u32 cells)\n{\n\treturn mlxsw_sp->sb->cell_size * cells;\n}\n\nu32 mlxsw_sp_bytes_cells(const struct mlxsw_sp *mlxsw_sp, u32 bytes)\n{\n\treturn DIV_ROUND_UP(bytes, mlxsw_sp->sb->cell_size);\n}\n\nstatic u32 mlxsw_sp_port_headroom_8x_adjust(const struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t    u32 size_cells)\n{\n\t \n\treturn mlxsw_sp_port->mapping.width == 8 ? 2 * size_cells : size_cells;\n}\n\nstatic struct mlxsw_sp_sb_pr *mlxsw_sp_sb_pr_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t u16 pool_index)\n{\n\treturn &mlxsw_sp->sb->prs[pool_index];\n}\n\nstatic bool mlxsw_sp_sb_cm_exists(u8 pg_buff, enum mlxsw_reg_sbxx_dir dir)\n{\n\tif (dir == MLXSW_REG_SBXX_DIR_INGRESS)\n\t\treturn pg_buff < MLXSW_SP_SB_ING_TC_COUNT;\n\telse\n\t\treturn pg_buff < MLXSW_SP_SB_EG_TC_COUNT;\n}\n\nstatic struct mlxsw_sp_sb_cm *mlxsw_sp_sb_cm_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t u16 local_port, u8 pg_buff,\n\t\t\t\t\t\t enum mlxsw_reg_sbxx_dir dir)\n{\n\tstruct mlxsw_sp_sb_port *sb_port = &mlxsw_sp->sb->ports[local_port];\n\n\tWARN_ON(!mlxsw_sp_sb_cm_exists(pg_buff, dir));\n\tif (dir == MLXSW_REG_SBXX_DIR_INGRESS)\n\t\treturn &sb_port->ing_cms[pg_buff];\n\telse\n\t\treturn &sb_port->eg_cms[pg_buff];\n}\n\nstatic struct mlxsw_sp_sb_pm *mlxsw_sp_sb_pm_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t u16 local_port, u16 pool_index)\n{\n\treturn &mlxsw_sp->sb->ports[local_port].pms[pool_index];\n}\n\nstatic int mlxsw_sp_sb_pr_write(struct mlxsw_sp *mlxsw_sp, u16 pool_index,\n\t\t\t\tenum mlxsw_reg_sbpr_mode mode,\n\t\t\t\tu32 size, bool infi_size)\n{\n\tconst struct mlxsw_sp_sb_pool_des *des =\n\t\t&mlxsw_sp->sb_vals->pool_dess[pool_index];\n\tchar sbpr_pl[MLXSW_REG_SBPR_LEN];\n\tstruct mlxsw_sp_sb_pr *pr;\n\tint err;\n\n\tmlxsw_reg_sbpr_pack(sbpr_pl, des->pool, des->dir, mode,\n\t\t\t    size, infi_size);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sbpr), sbpr_pl);\n\tif (err)\n\t\treturn err;\n\n\tif (infi_size)\n\t\tsize = mlxsw_sp_bytes_cells(mlxsw_sp, mlxsw_sp->sb->sb_size);\n\tpr = mlxsw_sp_sb_pr_get(mlxsw_sp, pool_index);\n\tpr->mode = mode;\n\tpr->size = size;\n\treturn 0;\n}\n\nstatic int mlxsw_sp_sb_pr_desc_write(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     enum mlxsw_reg_sbxx_dir dir,\n\t\t\t\t     enum mlxsw_reg_sbpr_mode mode,\n\t\t\t\t     u32 size, bool infi_size)\n{\n\tchar sbpr_pl[MLXSW_REG_SBPR_LEN];\n\n\t \n\tmlxsw_reg_sbpr_pack(sbpr_pl, 14, dir, mode, size, infi_size);\n\tmlxsw_reg_sbpr_desc_set(sbpr_pl, true);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sbpr), sbpr_pl);\n}\n\nstatic int mlxsw_sp_sb_cm_write(struct mlxsw_sp *mlxsw_sp, u16 local_port,\n\t\t\t\tu8 pg_buff, u32 min_buff, u32 max_buff,\n\t\t\t\tbool infi_max, u16 pool_index)\n{\n\tconst struct mlxsw_sp_sb_pool_des *des =\n\t\t&mlxsw_sp->sb_vals->pool_dess[pool_index];\n\tchar sbcm_pl[MLXSW_REG_SBCM_LEN];\n\tstruct mlxsw_sp_sb_cm *cm;\n\tint err;\n\n\tmlxsw_reg_sbcm_pack(sbcm_pl, local_port, pg_buff, des->dir,\n\t\t\t    min_buff, max_buff, infi_max, des->pool);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sbcm), sbcm_pl);\n\tif (err)\n\t\treturn err;\n\n\tif (mlxsw_sp_sb_cm_exists(pg_buff, des->dir)) {\n\t\tif (infi_max)\n\t\t\tmax_buff = mlxsw_sp_bytes_cells(mlxsw_sp,\n\t\t\t\t\t\t\tmlxsw_sp->sb->sb_size);\n\n\t\tcm = mlxsw_sp_sb_cm_get(mlxsw_sp, local_port, pg_buff,\n\t\t\t\t\tdes->dir);\n\t\tcm->min_buff = min_buff;\n\t\tcm->max_buff = max_buff;\n\t\tcm->pool_index = pool_index;\n\t}\n\treturn 0;\n}\n\nstatic int mlxsw_sp_sb_pm_write(struct mlxsw_sp *mlxsw_sp, u16 local_port,\n\t\t\t\tu16 pool_index, u32 min_buff, u32 max_buff)\n{\n\tconst struct mlxsw_sp_sb_pool_des *des =\n\t\t&mlxsw_sp->sb_vals->pool_dess[pool_index];\n\tchar sbpm_pl[MLXSW_REG_SBPM_LEN];\n\tstruct mlxsw_sp_sb_pm *pm;\n\tint err;\n\n\tmlxsw_reg_sbpm_pack(sbpm_pl, local_port, des->pool, des->dir, false,\n\t\t\t    min_buff, max_buff);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sbpm), sbpm_pl);\n\tif (err)\n\t\treturn err;\n\n\tpm = mlxsw_sp_sb_pm_get(mlxsw_sp, local_port, pool_index);\n\tpm->min_buff = min_buff;\n\tpm->max_buff = max_buff;\n\treturn 0;\n}\n\nstatic int mlxsw_sp_sb_pm_occ_clear(struct mlxsw_sp *mlxsw_sp, u16 local_port,\n\t\t\t\t    u16 pool_index, struct list_head *bulk_list)\n{\n\tconst struct mlxsw_sp_sb_pool_des *des =\n\t\t&mlxsw_sp->sb_vals->pool_dess[pool_index];\n\tchar sbpm_pl[MLXSW_REG_SBPM_LEN];\n\n\tif (local_port == MLXSW_PORT_CPU_PORT &&\n\t    des->dir == MLXSW_REG_SBXX_DIR_INGRESS)\n\t\treturn 0;\n\n\tmlxsw_reg_sbpm_pack(sbpm_pl, local_port, des->pool, des->dir,\n\t\t\t    true, 0, 0);\n\treturn mlxsw_reg_trans_query(mlxsw_sp->core, MLXSW_REG(sbpm), sbpm_pl,\n\t\t\t\t     bulk_list, NULL, 0);\n}\n\nstatic void mlxsw_sp_sb_pm_occ_query_cb(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\tchar *sbpm_pl, size_t sbpm_pl_len,\n\t\t\t\t\tunsigned long cb_priv)\n{\n\tstruct mlxsw_sp_sb_pm *pm = (struct mlxsw_sp_sb_pm *) cb_priv;\n\n\tmlxsw_reg_sbpm_unpack(sbpm_pl, &pm->occ.cur, &pm->occ.max);\n}\n\nstatic int mlxsw_sp_sb_pm_occ_query(struct mlxsw_sp *mlxsw_sp, u16 local_port,\n\t\t\t\t    u16 pool_index, struct list_head *bulk_list)\n{\n\tconst struct mlxsw_sp_sb_pool_des *des =\n\t\t&mlxsw_sp->sb_vals->pool_dess[pool_index];\n\tchar sbpm_pl[MLXSW_REG_SBPM_LEN];\n\tstruct mlxsw_sp_sb_pm *pm;\n\n\tif (local_port == MLXSW_PORT_CPU_PORT &&\n\t    des->dir == MLXSW_REG_SBXX_DIR_INGRESS)\n\t\treturn 0;\n\n\tpm = mlxsw_sp_sb_pm_get(mlxsw_sp, local_port, pool_index);\n\tmlxsw_reg_sbpm_pack(sbpm_pl, local_port, des->pool, des->dir,\n\t\t\t    false, 0, 0);\n\treturn mlxsw_reg_trans_query(mlxsw_sp->core, MLXSW_REG(sbpm), sbpm_pl,\n\t\t\t\t     bulk_list,\n\t\t\t\t     mlxsw_sp_sb_pm_occ_query_cb,\n\t\t\t\t     (unsigned long) pm);\n}\n\nvoid mlxsw_sp_hdroom_prios_reset_buf_idx(struct mlxsw_sp_hdroom *hdroom)\n{\n\tint prio;\n\n\tfor (prio = 0; prio < IEEE_8021QAZ_MAX_TCS; prio++) {\n\t\tswitch (hdroom->mode) {\n\t\tcase MLXSW_SP_HDROOM_MODE_DCB:\n\t\t\thdroom->prios.prio[prio].buf_idx = hdroom->prios.prio[prio].ets_buf_idx;\n\t\t\tbreak;\n\t\tcase MLXSW_SP_HDROOM_MODE_TC:\n\t\t\thdroom->prios.prio[prio].buf_idx = hdroom->prios.prio[prio].set_buf_idx;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid mlxsw_sp_hdroom_bufs_reset_lossiness(struct mlxsw_sp_hdroom *hdroom)\n{\n\tint prio;\n\tint i;\n\n\tfor (i = 0; i < DCBX_MAX_BUFFERS; i++)\n\t\thdroom->bufs.buf[i].lossy = true;\n\n\tfor (prio = 0; prio < IEEE_8021Q_MAX_PRIORITIES; prio++) {\n\t\tif (!hdroom->prios.prio[prio].lossy)\n\t\t\thdroom->bufs.buf[hdroom->prios.prio[prio].buf_idx].lossy = false;\n\t}\n}\n\nstatic u16 mlxsw_sp_hdroom_buf_threshold_get(const struct mlxsw_sp *mlxsw_sp, int mtu)\n{\n\treturn 2 * mlxsw_sp_bytes_cells(mlxsw_sp, mtu);\n}\n\nstatic void mlxsw_sp_hdroom_buf_pack(char *pbmc_pl, int index, u16 size, u16 thres, bool lossy)\n{\n\tif (lossy)\n\t\tmlxsw_reg_pbmc_lossy_buffer_pack(pbmc_pl, index, size);\n\telse\n\t\tmlxsw_reg_pbmc_lossless_buffer_pack(pbmc_pl, index, size,\n\t\t\t\t\t\t    thres);\n}\n\nstatic u16 mlxsw_sp_hdroom_buf_delay_get(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t const struct mlxsw_sp_hdroom *hdroom)\n{\n\tu16 delay_cells;\n\n\tdelay_cells = mlxsw_sp_bytes_cells(mlxsw_sp, hdroom->delay_bytes);\n\n\t \n\treturn 2 * delay_cells + mlxsw_sp_bytes_cells(mlxsw_sp, hdroom->mtu);\n}\n\nstatic u32 mlxsw_sp_hdroom_int_buf_size_get(struct mlxsw_sp *mlxsw_sp, int mtu, u32 speed)\n{\n\tu32 buffsize = mlxsw_sp->sb_ops->int_buf_size_get(mtu, speed);\n\n\treturn mlxsw_sp_bytes_cells(mlxsw_sp, buffsize) + 1;\n}\n\nstatic bool mlxsw_sp_hdroom_buf_is_used(const struct mlxsw_sp_hdroom *hdroom, int buf)\n{\n\tint prio;\n\n\tfor (prio = 0; prio < IEEE_8021QAZ_MAX_TCS; prio++) {\n\t\tif (hdroom->prios.prio[prio].buf_idx == buf)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid mlxsw_sp_hdroom_bufs_reset_sizes(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      struct mlxsw_sp_hdroom *hdroom)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu16 reserve_cells;\n\tint i;\n\n\t \n\treserve_cells = mlxsw_sp_hdroom_int_buf_size_get(mlxsw_sp, mlxsw_sp_port->max_mtu,\n\t\t\t\t\t\t\t mlxsw_sp_port->max_speed);\n\treserve_cells = mlxsw_sp_port_headroom_8x_adjust(mlxsw_sp_port, reserve_cells);\n\thdroom->int_buf.reserve_cells = reserve_cells;\n\n\tif (hdroom->int_buf.enable)\n\t\thdroom->int_buf.size_cells = reserve_cells;\n\telse\n\t\thdroom->int_buf.size_cells = 0;\n\n\t \n\tfor (i = 0; i < DCBX_MAX_BUFFERS; i++) {\n\t\tstruct mlxsw_sp_hdroom_buf *buf = &hdroom->bufs.buf[i];\n\t\tu16 thres_cells;\n\t\tu16 delay_cells;\n\n\t\tif (!mlxsw_sp_hdroom_buf_is_used(hdroom, i)) {\n\t\t\tthres_cells = 0;\n\t\t\tdelay_cells = 0;\n\t\t} else if (buf->lossy) {\n\t\t\tthres_cells = mlxsw_sp_hdroom_buf_threshold_get(mlxsw_sp, hdroom->mtu);\n\t\t\tdelay_cells = 0;\n\t\t} else {\n\t\t\tthres_cells = mlxsw_sp_hdroom_buf_threshold_get(mlxsw_sp, hdroom->mtu);\n\t\t\tdelay_cells = mlxsw_sp_hdroom_buf_delay_get(mlxsw_sp, hdroom);\n\t\t}\n\n\t\tthres_cells = mlxsw_sp_port_headroom_8x_adjust(mlxsw_sp_port, thres_cells);\n\t\tdelay_cells = mlxsw_sp_port_headroom_8x_adjust(mlxsw_sp_port, delay_cells);\n\n\t\tbuf->thres_cells = thres_cells;\n\t\tif (hdroom->mode == MLXSW_SP_HDROOM_MODE_DCB) {\n\t\t\tbuf->size_cells = thres_cells + delay_cells;\n\t\t} else {\n\t\t\t \n\t\t\tbuf->size_cells = max(buf->set_size_cells, buf->thres_cells);\n\t\t}\n\t}\n}\n\n#define MLXSW_SP_PB_UNUSED 8\n\nstatic int mlxsw_sp_hdroom_configure_buffers(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t     const struct mlxsw_sp_hdroom *hdroom, bool force)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar pbmc_pl[MLXSW_REG_PBMC_LEN];\n\tbool dirty;\n\tint err;\n\tint i;\n\n\tdirty = memcmp(&mlxsw_sp_port->hdroom->bufs, &hdroom->bufs, sizeof(hdroom->bufs));\n\tif (!dirty && !force)\n\t\treturn 0;\n\n\tmlxsw_reg_pbmc_pack(pbmc_pl, mlxsw_sp_port->local_port, 0xffff, 0xffff / 2);\n\tfor (i = 0; i < MLXSW_SP_PB_COUNT; i++) {\n\t\tconst struct mlxsw_sp_hdroom_buf *buf = &hdroom->bufs.buf[i];\n\n\t\tif (i == MLXSW_SP_PB_UNUSED)\n\t\t\tcontinue;\n\n\t\tmlxsw_sp_hdroom_buf_pack(pbmc_pl, i, buf->size_cells, buf->thres_cells, buf->lossy);\n\t}\n\n\tmlxsw_reg_pbmc_lossy_buffer_pack(pbmc_pl, MLXSW_REG_PBMC_PORT_SHARED_BUF_IDX, 0);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pbmc), pbmc_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_sp_port->hdroom->bufs = hdroom->bufs;\n\treturn 0;\n}\n\nstatic int mlxsw_sp_hdroom_configure_priomap(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t     const struct mlxsw_sp_hdroom *hdroom, bool force)\n{\n\tchar pptb_pl[MLXSW_REG_PPTB_LEN];\n\tbool dirty;\n\tint prio;\n\tint err;\n\n\tdirty = memcmp(&mlxsw_sp_port->hdroom->prios, &hdroom->prios, sizeof(hdroom->prios));\n\tif (!dirty && !force)\n\t\treturn 0;\n\n\tmlxsw_reg_pptb_pack(pptb_pl, mlxsw_sp_port->local_port);\n\tfor (prio = 0; prio < IEEE_8021QAZ_MAX_TCS; prio++)\n\t\tmlxsw_reg_pptb_prio_to_buff_pack(pptb_pl, prio, hdroom->prios.prio[prio].buf_idx);\n\n\terr = mlxsw_reg_write(mlxsw_sp_port->mlxsw_sp->core, MLXSW_REG(pptb), pptb_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_sp_port->hdroom->prios = hdroom->prios;\n\treturn 0;\n}\n\nstatic int mlxsw_sp_hdroom_configure_int_buf(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t     const struct mlxsw_sp_hdroom *hdroom, bool force)\n{\n\tchar sbib_pl[MLXSW_REG_SBIB_LEN];\n\tbool dirty;\n\tint err;\n\n\tdirty = memcmp(&mlxsw_sp_port->hdroom->int_buf, &hdroom->int_buf, sizeof(hdroom->int_buf));\n\tif (!dirty && !force)\n\t\treturn 0;\n\n\tmlxsw_reg_sbib_pack(sbib_pl, mlxsw_sp_port->local_port, hdroom->int_buf.size_cells);\n\terr = mlxsw_reg_write(mlxsw_sp_port->mlxsw_sp->core, MLXSW_REG(sbib), sbib_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_sp_port->hdroom->int_buf = hdroom->int_buf;\n\treturn 0;\n}\n\nstatic bool mlxsw_sp_hdroom_bufs_fit(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     const struct mlxsw_sp_hdroom *hdroom)\n{\n\tu32 taken_headroom_cells = 0;\n\tint i;\n\n\tfor (i = 0; i < MLXSW_SP_PB_COUNT; i++)\n\t\ttaken_headroom_cells += hdroom->bufs.buf[i].size_cells;\n\n\ttaken_headroom_cells += hdroom->int_buf.reserve_cells;\n\treturn taken_headroom_cells <= mlxsw_sp->sb->max_headroom_cells;\n}\n\nstatic int __mlxsw_sp_hdroom_configure(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t       const struct mlxsw_sp_hdroom *hdroom, bool force)\n{\n\tstruct mlxsw_sp_hdroom orig_hdroom;\n\tstruct mlxsw_sp_hdroom tmp_hdroom;\n\tint err;\n\tint i;\n\n\t \n\n\torig_hdroom = *mlxsw_sp_port->hdroom;\n\ttmp_hdroom = orig_hdroom;\n\tfor (i = 0; i < MLXSW_SP_PB_COUNT; i++) {\n\t\tif (hdroom->bufs.buf[i].size_cells)\n\t\t\ttmp_hdroom.bufs.buf[i] = hdroom->bufs.buf[i];\n\t}\n\n\tif (!mlxsw_sp_hdroom_bufs_fit(mlxsw_sp_port->mlxsw_sp, &tmp_hdroom) ||\n\t    !mlxsw_sp_hdroom_bufs_fit(mlxsw_sp_port->mlxsw_sp, hdroom))\n\t\treturn -ENOBUFS;\n\n\terr = mlxsw_sp_hdroom_configure_buffers(mlxsw_sp_port, &tmp_hdroom, force);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_hdroom_configure_priomap(mlxsw_sp_port, hdroom, force);\n\tif (err)\n\t\tgoto err_configure_priomap;\n\n\terr = mlxsw_sp_hdroom_configure_buffers(mlxsw_sp_port, hdroom, false);\n\tif (err)\n\t\tgoto err_configure_buffers;\n\n\terr = mlxsw_sp_hdroom_configure_int_buf(mlxsw_sp_port, hdroom, false);\n\tif (err)\n\t\tgoto err_configure_int_buf;\n\n\t*mlxsw_sp_port->hdroom = *hdroom;\n\treturn 0;\n\nerr_configure_int_buf:\n\tmlxsw_sp_hdroom_configure_buffers(mlxsw_sp_port, &tmp_hdroom, false);\nerr_configure_buffers:\n\tmlxsw_sp_hdroom_configure_priomap(mlxsw_sp_port, &tmp_hdroom, false);\nerr_configure_priomap:\n\tmlxsw_sp_hdroom_configure_buffers(mlxsw_sp_port, &orig_hdroom, false);\n\treturn err;\n}\n\nint mlxsw_sp_hdroom_configure(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t      const struct mlxsw_sp_hdroom *hdroom)\n{\n\treturn __mlxsw_sp_hdroom_configure(mlxsw_sp_port, hdroom, false);\n}\n\nstatic int mlxsw_sp_port_headroom_init(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_hdroom hdroom = {};\n\tu32 size9;\n\tint prio;\n\n\thdroom.mtu = mlxsw_sp_port->dev->mtu;\n\thdroom.mode = MLXSW_SP_HDROOM_MODE_DCB;\n\tfor (prio = 0; prio < IEEE_8021QAZ_MAX_TCS; prio++)\n\t\thdroom.prios.prio[prio].lossy = true;\n\n\tmlxsw_sp_hdroom_bufs_reset_lossiness(&hdroom);\n\tmlxsw_sp_hdroom_bufs_reset_sizes(mlxsw_sp_port, &hdroom);\n\n\t \n\tsize9 = mlxsw_sp_port_headroom_8x_adjust(mlxsw_sp_port, mlxsw_sp_port->max_mtu);\n\thdroom.bufs.buf[9].size_cells = mlxsw_sp_bytes_cells(mlxsw_sp, size9);\n\n\treturn __mlxsw_sp_hdroom_configure(mlxsw_sp_port, &hdroom, true);\n}\n\nstatic int mlxsw_sp_sb_port_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_sb_port *sb_port)\n{\n\tstruct mlxsw_sp_sb_pm *pms;\n\n\tpms = kcalloc(mlxsw_sp->sb_vals->pool_count, sizeof(*pms),\n\t\t      GFP_KERNEL);\n\tif (!pms)\n\t\treturn -ENOMEM;\n\tsb_port->pms = pms;\n\treturn 0;\n}\n\nstatic void mlxsw_sp_sb_port_fini(struct mlxsw_sp_sb_port *sb_port)\n{\n\tkfree(sb_port->pms);\n}\n\nstatic int mlxsw_sp_sb_ports_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tunsigned int max_ports = mlxsw_core_max_ports(mlxsw_sp->core);\n\tstruct mlxsw_sp_sb_pr *prs;\n\tint i;\n\tint err;\n\n\tmlxsw_sp->sb->ports = kcalloc(max_ports,\n\t\t\t\t      sizeof(struct mlxsw_sp_sb_port),\n\t\t\t\t      GFP_KERNEL);\n\tif (!mlxsw_sp->sb->ports)\n\t\treturn -ENOMEM;\n\n\tprs = kcalloc(mlxsw_sp->sb_vals->pool_count, sizeof(*prs),\n\t\t      GFP_KERNEL);\n\tif (!prs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_prs;\n\t}\n\tmlxsw_sp->sb->prs = prs;\n\n\tfor (i = 0; i < max_ports; i++) {\n\t\terr = mlxsw_sp_sb_port_init(mlxsw_sp, &mlxsw_sp->sb->ports[i]);\n\t\tif (err)\n\t\t\tgoto err_sb_port_init;\n\t}\n\n\treturn 0;\n\nerr_sb_port_init:\n\tfor (i--; i >= 0; i--)\n\t\tmlxsw_sp_sb_port_fini(&mlxsw_sp->sb->ports[i]);\n\tkfree(mlxsw_sp->sb->prs);\nerr_alloc_prs:\n\tkfree(mlxsw_sp->sb->ports);\n\treturn err;\n}\n\nstatic void mlxsw_sp_sb_ports_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tint max_ports = mlxsw_core_max_ports(mlxsw_sp->core);\n\tint i;\n\n\tfor (i = max_ports - 1; i >= 0; i--)\n\t\tmlxsw_sp_sb_port_fini(&mlxsw_sp->sb->ports[i]);\n\tkfree(mlxsw_sp->sb->prs);\n\tkfree(mlxsw_sp->sb->ports);\n}\n\n#define MLXSW_SP_SB_PR(_mode, _size)\t\\\n\t{\t\t\t\t\\\n\t\t.mode = _mode,\t\t\\\n\t\t.size = _size,\t\t\\\n\t}\n\n#define MLXSW_SP_SB_PR_EXT(_mode, _size, _freeze_mode, _freeze_size)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.mode = _mode,\t\t\t\t\t\t\\\n\t\t.size = _size,\t\t\t\t\t\t\\\n\t\t.freeze_mode = _freeze_mode,\t\t\t\t\\\n\t\t.freeze_size = _freeze_size,\t\t\t\t\\\n\t}\n\n#define MLXSW_SP1_SB_PR_CPU_SIZE\t(256 * 1000)\n\n \nstatic const struct mlxsw_sp_sb_pr mlxsw_sp1_sb_prs[] = {\n\tMLXSW_SP_SB_PR(MLXSW_REG_SBPR_MODE_DYNAMIC, MLXSW_SP_SB_REST),\n\tMLXSW_SP_SB_PR(MLXSW_REG_SBPR_MODE_DYNAMIC, 0),\n\tMLXSW_SP_SB_PR(MLXSW_REG_SBPR_MODE_DYNAMIC, 0),\n\tMLXSW_SP_SB_PR(MLXSW_REG_SBPR_MODE_DYNAMIC, 0),\n\tMLXSW_SP_SB_PR_EXT(MLXSW_REG_SBPR_MODE_DYNAMIC, MLXSW_SP_SB_REST,\n\t\t\t   true, false),\n\tMLXSW_SP_SB_PR(MLXSW_REG_SBPR_MODE_DYNAMIC, 0),\n\tMLXSW_SP_SB_PR(MLXSW_REG_SBPR_MODE_DYNAMIC, 0),\n\tMLXSW_SP_SB_PR(MLXSW_REG_SBPR_MODE_DYNAMIC, 0),\n\tMLXSW_SP_SB_PR_EXT(MLXSW_REG_SBPR_MODE_STATIC, MLXSW_SP_SB_INFI,\n\t\t\t   true, true),\n\tMLXSW_SP_SB_PR_EXT(MLXSW_REG_SBPR_MODE_DYNAMIC,\n\t\t\t   MLXSW_SP1_SB_PR_CPU_SIZE, true, false),\n\tMLXSW_SP_SB_PR_EXT(MLXSW_REG_SBPR_MODE_DYNAMIC,\n\t\t\t   MLXSW_SP1_SB_PR_CPU_SIZE, true, false),\n};\n\n#define MLXSW_SP2_SB_PR_CPU_SIZE\t(256 * 1000)\n\n \nstatic const struct mlxsw_sp_sb_pr mlxsw_sp2_sb_prs[] = {\n\tMLXSW_SP_SB_PR(MLXSW_REG_SBPR_MODE_DYNAMIC, MLXSW_SP_SB_REST),\n\tMLXSW_SP_SB_PR(MLXSW_REG_SBPR_MODE_STATIC, 0),\n\tMLXSW_SP_SB_PR(MLXSW_REG_SBPR_MODE_STATIC, 0),\n\tMLXSW_SP_SB_PR(MLXSW_REG_SBPR_MODE_STATIC, 0),\n\tMLXSW_SP_SB_PR_EXT(MLXSW_REG_SBPR_MODE_DYNAMIC, MLXSW_SP_SB_REST,\n\t\t\t   true, false),\n\tMLXSW_SP_SB_PR(MLXSW_REG_SBPR_MODE_STATIC, 0),\n\tMLXSW_SP_SB_PR(MLXSW_REG_SBPR_MODE_STATIC, 0),\n\tMLXSW_SP_SB_PR(MLXSW_REG_SBPR_MODE_STATIC, 0),\n\tMLXSW_SP_SB_PR_EXT(MLXSW_REG_SBPR_MODE_STATIC, MLXSW_SP_SB_INFI,\n\t\t\t   true, true),\n\tMLXSW_SP_SB_PR_EXT(MLXSW_REG_SBPR_MODE_DYNAMIC,\n\t\t\t   MLXSW_SP2_SB_PR_CPU_SIZE, true, false),\n\tMLXSW_SP_SB_PR_EXT(MLXSW_REG_SBPR_MODE_DYNAMIC,\n\t\t\t   MLXSW_SP2_SB_PR_CPU_SIZE, true, false),\n};\n\nstatic int mlxsw_sp_sb_prs_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tconst struct mlxsw_sp_sb_pr *prs,\n\t\t\t\tconst struct mlxsw_sp_sb_pool_des *pool_dess,\n\t\t\t\tsize_t prs_len)\n{\n\t \n\tu32 sb_cells = div_u64(mlxsw_sp->sb->sb_size, mlxsw_sp->sb->cell_size);\n\tu32 rest_cells[2] = {sb_cells, sb_cells};\n\tint i;\n\tint err;\n\n\t \n\tfor (i = 0; i < prs_len; i++) {\n\t\tenum mlxsw_reg_sbxx_dir dir = pool_dess[i].dir;\n\t\tu32 size = prs[i].size;\n\t\tu32 size_cells;\n\n\t\tif (size == MLXSW_SP_SB_INFI || size == MLXSW_SP_SB_REST)\n\t\t\tcontinue;\n\n\t\tsize_cells = mlxsw_sp_bytes_cells(mlxsw_sp, size);\n\t\tif (WARN_ON_ONCE(size_cells > rest_cells[dir]))\n\t\t\tcontinue;\n\n\t\trest_cells[dir] -= size_cells;\n\t}\n\n\tfor (i = 0; i < prs_len; i++) {\n\t\tu32 size = prs[i].size;\n\t\tu32 size_cells;\n\n\t\tif (size == MLXSW_SP_SB_INFI) {\n\t\t\terr = mlxsw_sp_sb_pr_write(mlxsw_sp, i, prs[i].mode,\n\t\t\t\t\t\t   0, true);\n\t\t} else if (size == MLXSW_SP_SB_REST) {\n\t\t\tsize_cells = rest_cells[pool_dess[i].dir];\n\t\t\terr = mlxsw_sp_sb_pr_write(mlxsw_sp, i, prs[i].mode,\n\t\t\t\t\t\t   size_cells, false);\n\t\t} else {\n\t\t\tsize_cells = mlxsw_sp_bytes_cells(mlxsw_sp, size);\n\t\t\terr = mlxsw_sp_sb_pr_write(mlxsw_sp, i, prs[i].mode,\n\t\t\t\t\t\t   size_cells, false);\n\t\t}\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = mlxsw_sp_sb_pr_desc_write(mlxsw_sp, MLXSW_REG_SBXX_DIR_INGRESS,\n\t\t\t\t\tMLXSW_REG_SBPR_MODE_DYNAMIC, 0, true);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_sb_pr_desc_write(mlxsw_sp, MLXSW_REG_SBXX_DIR_EGRESS,\n\t\t\t\t\tMLXSW_REG_SBPR_MODE_DYNAMIC, 0, true);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n#define MLXSW_SP_SB_CM(_min_buff, _max_buff, _pool)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.min_buff = _min_buff,\t\t\t\\\n\t\t.max_buff = _max_buff,\t\t\t\\\n\t\t.pool_index = _pool,\t\t\t\\\n\t}\n\n#define MLXSW_SP_SB_CM_ING(_min_buff, _max_buff)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.min_buff = _min_buff,\t\t\t\\\n\t\t.max_buff = _max_buff,\t\t\t\\\n\t\t.pool_index = MLXSW_SP_SB_POOL_ING,\t\\\n\t}\n\n#define MLXSW_SP_SB_CM_EGR(_min_buff, _max_buff)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.min_buff = _min_buff,\t\t\t\\\n\t\t.max_buff = _max_buff,\t\t\t\\\n\t\t.pool_index = MLXSW_SP_SB_POOL_EGR,\t\\\n\t}\n\n#define MLXSW_SP_SB_CM_EGR_MC(_min_buff, _max_buff)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.min_buff = _min_buff,\t\t\t\\\n\t\t.max_buff = _max_buff,\t\t\t\\\n\t\t.pool_index = MLXSW_SP_SB_POOL_EGR_MC,\t\\\n\t\t.freeze_pool = true,\t\t\t\\\n\t\t.freeze_thresh = true,\t\t\t\\\n\t}\n\nstatic const struct mlxsw_sp_sb_cm mlxsw_sp1_sb_cms_ingress[] = {\n\tMLXSW_SP_SB_CM_ING(10000, 8),\n\tMLXSW_SP_SB_CM_ING(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_CM_ING(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_CM_ING(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_CM_ING(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_CM_ING(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_CM_ING(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_CM_ING(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_CM_ING(0, 0),  \n\tMLXSW_SP_SB_CM(10000, 8, MLXSW_SP_SB_POOL_ING_CPU),\n};\n\nstatic const struct mlxsw_sp_sb_cm mlxsw_sp2_sb_cms_ingress[] = {\n\tMLXSW_SP_SB_CM_ING(0, 7),\n\tMLXSW_SP_SB_CM_ING(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_CM_ING(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_CM_ING(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_CM_ING(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_CM_ING(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_CM_ING(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_CM_ING(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_CM_ING(0, 0),  \n\tMLXSW_SP_SB_CM(10000, 8, MLXSW_SP_SB_POOL_ING_CPU),\n};\n\nstatic const struct mlxsw_sp_sb_cm mlxsw_sp1_sb_cms_egress[] = {\n\tMLXSW_SP_SB_CM_EGR(1500, 9),\n\tMLXSW_SP_SB_CM_EGR(1500, 9),\n\tMLXSW_SP_SB_CM_EGR(1500, 9),\n\tMLXSW_SP_SB_CM_EGR(1500, 9),\n\tMLXSW_SP_SB_CM_EGR(1500, 9),\n\tMLXSW_SP_SB_CM_EGR(1500, 9),\n\tMLXSW_SP_SB_CM_EGR(1500, 9),\n\tMLXSW_SP_SB_CM_EGR(1500, 9),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR(1, 0xff),\n};\n\nstatic const struct mlxsw_sp_sb_cm mlxsw_sp2_sb_cms_egress[] = {\n\tMLXSW_SP_SB_CM_EGR(0, 7),\n\tMLXSW_SP_SB_CM_EGR(0, 7),\n\tMLXSW_SP_SB_CM_EGR(0, 7),\n\tMLXSW_SP_SB_CM_EGR(0, 7),\n\tMLXSW_SP_SB_CM_EGR(0, 7),\n\tMLXSW_SP_SB_CM_EGR(0, 7),\n\tMLXSW_SP_SB_CM_EGR(0, 7),\n\tMLXSW_SP_SB_CM_EGR(0, 7),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR_MC(0, MLXSW_SP_SB_INFI),\n\tMLXSW_SP_SB_CM_EGR(1, 0xff),\n};\n\n#define MLXSW_SP_CPU_PORT_SB_CM MLXSW_SP_SB_CM(0, 0, MLXSW_SP_SB_POOL_EGR_CPU)\n\nstatic const struct mlxsw_sp_sb_cm mlxsw_sp_cpu_port_sb_cms[] = {\n\tMLXSW_SP_SB_CM(1000, 8, MLXSW_SP_SB_POOL_EGR_CPU),\n\tMLXSW_SP_SB_CM(1000, 8, MLXSW_SP_SB_POOL_EGR_CPU),\n\tMLXSW_SP_SB_CM(1000, 8, MLXSW_SP_SB_POOL_EGR_CPU),\n\tMLXSW_SP_SB_CM(1000, 8, MLXSW_SP_SB_POOL_EGR_CPU),\n\tMLXSW_SP_SB_CM(1000, 8, MLXSW_SP_SB_POOL_EGR_CPU),\n\tMLXSW_SP_SB_CM(1000, 8, MLXSW_SP_SB_POOL_EGR_CPU),\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_SB_CM(1000, 8, MLXSW_SP_SB_POOL_EGR_CPU),\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n\tMLXSW_SP_CPU_PORT_SB_CM,\n};\n\nstatic bool\nmlxsw_sp_sb_pool_is_static(struct mlxsw_sp *mlxsw_sp, u16 pool_index)\n{\n\tstruct mlxsw_sp_sb_pr *pr = mlxsw_sp_sb_pr_get(mlxsw_sp, pool_index);\n\n\treturn pr->mode == MLXSW_REG_SBPR_MODE_STATIC;\n}\n\nstatic int __mlxsw_sp_sb_cms_init(struct mlxsw_sp *mlxsw_sp, u16 local_port,\n\t\t\t\t  enum mlxsw_reg_sbxx_dir dir,\n\t\t\t\t  const struct mlxsw_sp_sb_cm *cms,\n\t\t\t\t  size_t cms_len)\n{\n\tconst struct mlxsw_sp_sb_vals *sb_vals = mlxsw_sp->sb_vals;\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < cms_len; i++) {\n\t\tconst struct mlxsw_sp_sb_cm *cm;\n\t\tu32 min_buff;\n\t\tu32 max_buff;\n\n\t\tif (i == 8 && dir == MLXSW_REG_SBXX_DIR_INGRESS)\n\t\t\tcontinue;  \n\t\tcm = &cms[i];\n\t\tif (WARN_ON(sb_vals->pool_dess[cm->pool_index].dir != dir))\n\t\t\tcontinue;\n\n\t\tmin_buff = mlxsw_sp_bytes_cells(mlxsw_sp, cm->min_buff);\n\t\tmax_buff = cm->max_buff;\n\t\tif (max_buff == MLXSW_SP_SB_INFI) {\n\t\t\terr = mlxsw_sp_sb_cm_write(mlxsw_sp, local_port, i,\n\t\t\t\t\t\t   min_buff, 0,\n\t\t\t\t\t\t   true, cm->pool_index);\n\t\t} else {\n\t\t\tif (mlxsw_sp_sb_pool_is_static(mlxsw_sp,\n\t\t\t\t\t\t       cm->pool_index))\n\t\t\t\tmax_buff = mlxsw_sp_bytes_cells(mlxsw_sp,\n\t\t\t\t\t\t\t\tmax_buff);\n\t\t\terr = mlxsw_sp_sb_cm_write(mlxsw_sp, local_port, i,\n\t\t\t\t\t\t   min_buff, max_buff,\n\t\t\t\t\t\t   false, cm->pool_index);\n\t\t}\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_sb_cms_init(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tint err;\n\n\terr = __mlxsw_sp_sb_cms_init(mlxsw_sp,\n\t\t\t\t     mlxsw_sp_port->local_port,\n\t\t\t\t     MLXSW_REG_SBXX_DIR_INGRESS,\n\t\t\t\t     mlxsw_sp->sb_vals->cms_ingress,\n\t\t\t\t     mlxsw_sp->sb_vals->cms_ingress_count);\n\tif (err)\n\t\treturn err;\n\treturn __mlxsw_sp_sb_cms_init(mlxsw_sp_port->mlxsw_sp,\n\t\t\t\t      mlxsw_sp_port->local_port,\n\t\t\t\t      MLXSW_REG_SBXX_DIR_EGRESS,\n\t\t\t\t      mlxsw_sp->sb_vals->cms_egress,\n\t\t\t\t      mlxsw_sp->sb_vals->cms_egress_count);\n}\n\nstatic int mlxsw_sp_cpu_port_sb_cms_init(struct mlxsw_sp *mlxsw_sp)\n{\n\treturn __mlxsw_sp_sb_cms_init(mlxsw_sp, 0, MLXSW_REG_SBXX_DIR_EGRESS,\n\t\t\t\t      mlxsw_sp->sb_vals->cms_cpu,\n\t\t\t\t      mlxsw_sp->sb_vals->cms_cpu_count);\n}\n\n#define MLXSW_SP_SB_PM(_min_buff, _max_buff)\t\\\n\t{\t\t\t\t\t\\\n\t\t.min_buff = _min_buff,\t\t\\\n\t\t.max_buff = _max_buff,\t\t\\\n\t}\n\n \nstatic const struct mlxsw_sp_sb_pm mlxsw_sp1_sb_pms[] = {\n\tMLXSW_SP_SB_PM(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MAX),\n\tMLXSW_SP_SB_PM(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_PM(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_PM(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_PM(0, 7),\n\tMLXSW_SP_SB_PM(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_PM(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_PM(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n\tMLXSW_SP_SB_PM(10000, 90000),\n\tMLXSW_SP_SB_PM(0, 8),\t \n\tMLXSW_SP_SB_PM(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n};\n\n \nstatic const struct mlxsw_sp_sb_pm mlxsw_sp2_sb_pms[] = {\n\tMLXSW_SP_SB_PM(0, 7),\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(0, 7),\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(10000, 90000),\n\tMLXSW_SP_SB_PM(0, 8),\t \n\tMLXSW_SP_SB_PM(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN),\n};\n\n \nstatic const struct mlxsw_sp_sb_pm mlxsw_sp_cpu_port_sb_pms[] = {\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(0, 90000),\n\tMLXSW_SP_SB_PM(0, 0),\n\tMLXSW_SP_SB_PM(0, MLXSW_REG_SBXX_DYN_MAX_BUFF_MAX),\n};\n\nstatic int mlxsw_sp_sb_pms_init(struct mlxsw_sp *mlxsw_sp, u16 local_port,\n\t\t\t\tconst struct mlxsw_sp_sb_pm *pms,\n\t\t\t\tbool skip_ingress)\n{\n\tint i, err;\n\n\tfor (i = 0; i < mlxsw_sp->sb_vals->pool_count; i++) {\n\t\tconst struct mlxsw_sp_sb_pm *pm = &pms[i];\n\t\tconst struct mlxsw_sp_sb_pool_des *des;\n\t\tu32 max_buff;\n\t\tu32 min_buff;\n\n\t\tdes = &mlxsw_sp->sb_vals->pool_dess[i];\n\t\tif (skip_ingress && des->dir == MLXSW_REG_SBXX_DIR_INGRESS)\n\t\t\tcontinue;\n\n\t\tmin_buff = mlxsw_sp_bytes_cells(mlxsw_sp, pm->min_buff);\n\t\tmax_buff = pm->max_buff;\n\t\tif (mlxsw_sp_sb_pool_is_static(mlxsw_sp, i))\n\t\t\tmax_buff = mlxsw_sp_bytes_cells(mlxsw_sp, max_buff);\n\t\terr = mlxsw_sp_sb_pm_write(mlxsw_sp, local_port, i, min_buff,\n\t\t\t\t\t   max_buff);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_sb_pms_init(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\n\treturn mlxsw_sp_sb_pms_init(mlxsw_sp, mlxsw_sp_port->local_port,\n\t\t\t\t    mlxsw_sp->sb_vals->pms, false);\n}\n\nstatic int mlxsw_sp_cpu_port_sb_pms_init(struct mlxsw_sp *mlxsw_sp)\n{\n\treturn mlxsw_sp_sb_pms_init(mlxsw_sp, 0, mlxsw_sp->sb_vals->pms_cpu,\n\t\t\t\t    true);\n}\n\n#define MLXSW_SP_SB_MM(_min_buff, _max_buff)\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.min_buff = _min_buff,\t\t\t\\\n\t\t.max_buff = _max_buff,\t\t\t\\\n\t\t.pool_index = MLXSW_SP_SB_POOL_EGR,\t\\\n\t}\n\nstatic const struct mlxsw_sp_sb_mm mlxsw_sp_sb_mms[] = {\n\tMLXSW_SP_SB_MM(0, 6),\n\tMLXSW_SP_SB_MM(0, 6),\n\tMLXSW_SP_SB_MM(0, 6),\n\tMLXSW_SP_SB_MM(0, 6),\n\tMLXSW_SP_SB_MM(0, 6),\n\tMLXSW_SP_SB_MM(0, 6),\n\tMLXSW_SP_SB_MM(0, 6),\n\tMLXSW_SP_SB_MM(0, 6),\n\tMLXSW_SP_SB_MM(0, 6),\n\tMLXSW_SP_SB_MM(0, 6),\n\tMLXSW_SP_SB_MM(0, 6),\n\tMLXSW_SP_SB_MM(0, 6),\n\tMLXSW_SP_SB_MM(0, 6),\n\tMLXSW_SP_SB_MM(0, 6),\n\tMLXSW_SP_SB_MM(0, 6),\n};\n\nstatic int mlxsw_sp_sb_mms_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tchar sbmm_pl[MLXSW_REG_SBMM_LEN];\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < mlxsw_sp->sb_vals->mms_count; i++) {\n\t\tconst struct mlxsw_sp_sb_pool_des *des;\n\t\tconst struct mlxsw_sp_sb_mm *mc;\n\t\tu32 min_buff;\n\n\t\tmc = &mlxsw_sp->sb_vals->mms[i];\n\t\tdes = &mlxsw_sp->sb_vals->pool_dess[mc->pool_index];\n\t\t \n\t\tmin_buff = mlxsw_sp_bytes_cells(mlxsw_sp, mc->min_buff);\n\t\tmlxsw_reg_sbmm_pack(sbmm_pl, i, min_buff, mc->max_buff,\n\t\t\t\t    des->pool);\n\t\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sbmm), sbmm_pl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void mlxsw_sp_pool_count(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tu16 *p_ingress_len, u16 *p_egress_len)\n{\n\tint i;\n\n\tfor (i = 0; i < mlxsw_sp->sb_vals->pool_count; ++i) {\n\t\tif (mlxsw_sp->sb_vals->pool_dess[i].dir ==\n\t\t    MLXSW_REG_SBXX_DIR_INGRESS)\n\t\t\t(*p_ingress_len)++;\n\t\telse\n\t\t\t(*p_egress_len)++;\n\t}\n\n\tWARN(*p_egress_len == 0, \"No egress pools\\n\");\n}\n\nconst struct mlxsw_sp_sb_vals mlxsw_sp1_sb_vals = {\n\t.pool_count = ARRAY_SIZE(mlxsw_sp1_sb_pool_dess),\n\t.pool_dess = mlxsw_sp1_sb_pool_dess,\n\t.pms = mlxsw_sp1_sb_pms,\n\t.pms_cpu = mlxsw_sp_cpu_port_sb_pms,\n\t.prs = mlxsw_sp1_sb_prs,\n\t.mms = mlxsw_sp_sb_mms,\n\t.cms_ingress = mlxsw_sp1_sb_cms_ingress,\n\t.cms_egress = mlxsw_sp1_sb_cms_egress,\n\t.cms_cpu = mlxsw_sp_cpu_port_sb_cms,\n\t.mms_count = ARRAY_SIZE(mlxsw_sp_sb_mms),\n\t.cms_ingress_count = ARRAY_SIZE(mlxsw_sp1_sb_cms_ingress),\n\t.cms_egress_count = ARRAY_SIZE(mlxsw_sp1_sb_cms_egress),\n\t.cms_cpu_count = ARRAY_SIZE(mlxsw_sp_cpu_port_sb_cms),\n};\n\nconst struct mlxsw_sp_sb_vals mlxsw_sp2_sb_vals = {\n\t.pool_count = ARRAY_SIZE(mlxsw_sp2_sb_pool_dess),\n\t.pool_dess = mlxsw_sp2_sb_pool_dess,\n\t.pms = mlxsw_sp2_sb_pms,\n\t.pms_cpu = mlxsw_sp_cpu_port_sb_pms,\n\t.prs = mlxsw_sp2_sb_prs,\n\t.mms = mlxsw_sp_sb_mms,\n\t.cms_ingress = mlxsw_sp2_sb_cms_ingress,\n\t.cms_egress = mlxsw_sp2_sb_cms_egress,\n\t.cms_cpu = mlxsw_sp_cpu_port_sb_cms,\n\t.mms_count = ARRAY_SIZE(mlxsw_sp_sb_mms),\n\t.cms_ingress_count = ARRAY_SIZE(mlxsw_sp2_sb_cms_ingress),\n\t.cms_egress_count = ARRAY_SIZE(mlxsw_sp2_sb_cms_egress),\n\t.cms_cpu_count = ARRAY_SIZE(mlxsw_sp_cpu_port_sb_cms),\n};\n\nstatic u32 mlxsw_sp1_pb_int_buf_size_get(int mtu, u32 speed)\n{\n\treturn mtu * 5 / 2;\n}\n\nstatic u32 __mlxsw_sp_pb_int_buf_size_get(int mtu, u32 speed, u32 buffer_factor)\n{\n\treturn 3 * mtu + buffer_factor * speed / 1000;\n}\n\n#define MLXSW_SP2_SPAN_EG_MIRROR_BUFFER_FACTOR 38\n\nstatic u32 mlxsw_sp2_pb_int_buf_size_get(int mtu, u32 speed)\n{\n\tint factor = MLXSW_SP2_SPAN_EG_MIRROR_BUFFER_FACTOR;\n\n\treturn __mlxsw_sp_pb_int_buf_size_get(mtu, speed, factor);\n}\n\n#define MLXSW_SP3_SPAN_EG_MIRROR_BUFFER_FACTOR 50\n\nstatic u32 mlxsw_sp3_pb_int_buf_size_get(int mtu, u32 speed)\n{\n\tint factor = MLXSW_SP3_SPAN_EG_MIRROR_BUFFER_FACTOR;\n\n\treturn __mlxsw_sp_pb_int_buf_size_get(mtu, speed, factor);\n}\n\nconst struct mlxsw_sp_sb_ops mlxsw_sp1_sb_ops = {\n\t.int_buf_size_get = mlxsw_sp1_pb_int_buf_size_get,\n};\n\nconst struct mlxsw_sp_sb_ops mlxsw_sp2_sb_ops = {\n\t.int_buf_size_get = mlxsw_sp2_pb_int_buf_size_get,\n};\n\nconst struct mlxsw_sp_sb_ops mlxsw_sp3_sb_ops = {\n\t.int_buf_size_get = mlxsw_sp3_pb_int_buf_size_get,\n};\n\nint mlxsw_sp_buffers_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tu32 max_headroom_size;\n\tu16 ing_pool_count = 0;\n\tu16 eg_pool_count = 0;\n\tint err;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, CELL_SIZE))\n\t\treturn -EIO;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, GUARANTEED_SHARED_BUFFER))\n\t\treturn -EIO;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, MAX_HEADROOM_SIZE))\n\t\treturn -EIO;\n\n\tmlxsw_sp->sb = kzalloc(sizeof(*mlxsw_sp->sb), GFP_KERNEL);\n\tif (!mlxsw_sp->sb)\n\t\treturn -ENOMEM;\n\tmlxsw_sp->sb->cell_size = MLXSW_CORE_RES_GET(mlxsw_sp->core, CELL_SIZE);\n\tmlxsw_sp->sb->sb_size = MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t\t\t   GUARANTEED_SHARED_BUFFER);\n\tmax_headroom_size = MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t\t       MAX_HEADROOM_SIZE);\n\t \n\tmlxsw_sp->sb->max_headroom_cells = max_headroom_size /\n\t\t\t\t\t\tmlxsw_sp->sb->cell_size;\n\n\terr = mlxsw_sp_sb_ports_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_sb_ports_init;\n\terr = mlxsw_sp_sb_prs_init(mlxsw_sp, mlxsw_sp->sb_vals->prs,\n\t\t\t\t   mlxsw_sp->sb_vals->pool_dess,\n\t\t\t\t   mlxsw_sp->sb_vals->pool_count);\n\tif (err)\n\t\tgoto err_sb_prs_init;\n\terr = mlxsw_sp_cpu_port_sb_cms_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_sb_cpu_port_sb_cms_init;\n\terr = mlxsw_sp_cpu_port_sb_pms_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_sb_cpu_port_pms_init;\n\terr = mlxsw_sp_sb_mms_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_sb_mms_init;\n\tmlxsw_sp_pool_count(mlxsw_sp, &ing_pool_count, &eg_pool_count);\n\terr = devl_sb_register(priv_to_devlink(mlxsw_sp->core), 0,\n\t\t\t       mlxsw_sp->sb->sb_size,\n\t\t\t       ing_pool_count,\n\t\t\t       eg_pool_count,\n\t\t\t       MLXSW_SP_SB_ING_TC_COUNT,\n\t\t\t       MLXSW_SP_SB_EG_TC_COUNT);\n\tif (err)\n\t\tgoto err_devlink_sb_register;\n\n\treturn 0;\n\nerr_devlink_sb_register:\nerr_sb_mms_init:\nerr_sb_cpu_port_pms_init:\nerr_sb_cpu_port_sb_cms_init:\nerr_sb_prs_init:\n\tmlxsw_sp_sb_ports_fini(mlxsw_sp);\nerr_sb_ports_init:\n\tkfree(mlxsw_sp->sb);\n\treturn err;\n}\n\nvoid mlxsw_sp_buffers_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tdevl_sb_unregister(priv_to_devlink(mlxsw_sp->core), 0);\n\tmlxsw_sp_sb_ports_fini(mlxsw_sp);\n\tkfree(mlxsw_sp->sb);\n}\n\nint mlxsw_sp_port_buffers_init(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tint err;\n\n\tmlxsw_sp_port->hdroom = kzalloc(sizeof(*mlxsw_sp_port->hdroom), GFP_KERNEL);\n\tif (!mlxsw_sp_port->hdroom)\n\t\treturn -ENOMEM;\n\tmlxsw_sp_port->hdroom->mtu = mlxsw_sp_port->dev->mtu;\n\n\terr = mlxsw_sp_port_headroom_init(mlxsw_sp_port);\n\tif (err)\n\t\tgoto err_headroom_init;\n\terr = mlxsw_sp_port_sb_cms_init(mlxsw_sp_port);\n\tif (err)\n\t\tgoto err_port_sb_cms_init;\n\terr = mlxsw_sp_port_sb_pms_init(mlxsw_sp_port);\n\tif (err)\n\t\tgoto err_port_sb_pms_init;\n\treturn 0;\n\nerr_port_sb_pms_init:\nerr_port_sb_cms_init:\nerr_headroom_init:\n\tkfree(mlxsw_sp_port->hdroom);\n\treturn err;\n}\n\nvoid mlxsw_sp_port_buffers_fini(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tkfree(mlxsw_sp_port->hdroom);\n}\n\nint mlxsw_sp_sb_pool_get(struct mlxsw_core *mlxsw_core,\n\t\t\t unsigned int sb_index, u16 pool_index,\n\t\t\t struct devlink_sb_pool_info *pool_info)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tenum mlxsw_reg_sbxx_dir dir;\n\tstruct mlxsw_sp_sb_pr *pr;\n\n\tdir = mlxsw_sp->sb_vals->pool_dess[pool_index].dir;\n\tpr = mlxsw_sp_sb_pr_get(mlxsw_sp, pool_index);\n\tpool_info->pool_type = (enum devlink_sb_pool_type) dir;\n\tpool_info->size = mlxsw_sp_cells_bytes(mlxsw_sp, pr->size);\n\tpool_info->threshold_type = (enum devlink_sb_threshold_type) pr->mode;\n\tpool_info->cell_size = mlxsw_sp->sb->cell_size;\n\treturn 0;\n}\n\nint mlxsw_sp_sb_pool_set(struct mlxsw_core *mlxsw_core,\n\t\t\t unsigned int sb_index, u16 pool_index, u32 size,\n\t\t\t enum devlink_sb_threshold_type threshold_type,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tu32 pool_size = mlxsw_sp_bytes_cells(mlxsw_sp, size);\n\tconst struct mlxsw_sp_sb_pr *pr;\n\tenum mlxsw_reg_sbpr_mode mode;\n\n\tmode = (enum mlxsw_reg_sbpr_mode) threshold_type;\n\tpr = &mlxsw_sp->sb_vals->prs[pool_index];\n\n\tif (size > MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t      GUARANTEED_SHARED_BUFFER)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Exceeded shared buffer size\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pr->freeze_mode && pr->mode != mode) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Changing this pool's threshold type is forbidden\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pr->freeze_size && pr->size != size) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Changing this pool's size is forbidden\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn mlxsw_sp_sb_pr_write(mlxsw_sp, pool_index, mode,\n\t\t\t\t    pool_size, false);\n}\n\n#define MLXSW_SP_SB_THRESHOLD_TO_ALPHA_OFFSET (-2)  \n\nstatic u32 mlxsw_sp_sb_threshold_out(struct mlxsw_sp *mlxsw_sp, u16 pool_index,\n\t\t\t\t     u32 max_buff)\n{\n\tstruct mlxsw_sp_sb_pr *pr = mlxsw_sp_sb_pr_get(mlxsw_sp, pool_index);\n\n\tif (pr->mode == MLXSW_REG_SBPR_MODE_DYNAMIC)\n\t\treturn max_buff - MLXSW_SP_SB_THRESHOLD_TO_ALPHA_OFFSET;\n\treturn mlxsw_sp_cells_bytes(mlxsw_sp, max_buff);\n}\n\nstatic int mlxsw_sp_sb_threshold_in(struct mlxsw_sp *mlxsw_sp, u16 pool_index,\n\t\t\t\t    u32 threshold, u32 *p_max_buff,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_sb_pr *pr = mlxsw_sp_sb_pr_get(mlxsw_sp, pool_index);\n\n\tif (pr->mode == MLXSW_REG_SBPR_MODE_DYNAMIC) {\n\t\tint val;\n\n\t\tval = threshold + MLXSW_SP_SB_THRESHOLD_TO_ALPHA_OFFSET;\n\t\tif (val < MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN ||\n\t\t    val > MLXSW_REG_SBXX_DYN_MAX_BUFF_MAX) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid dynamic threshold value\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*p_max_buff = val;\n\t} else {\n\t\t*p_max_buff = mlxsw_sp_bytes_cells(mlxsw_sp, threshold);\n\t}\n\treturn 0;\n}\n\nint mlxsw_sp_sb_port_pool_get(struct mlxsw_core_port *mlxsw_core_port,\n\t\t\t      unsigned int sb_index, u16 pool_index,\n\t\t\t      u32 *p_threshold)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port =\n\t\t\tmlxsw_core_port_driver_priv(mlxsw_core_port);\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\tstruct mlxsw_sp_sb_pm *pm = mlxsw_sp_sb_pm_get(mlxsw_sp, local_port,\n\t\t\t\t\t\t       pool_index);\n\n\t*p_threshold = mlxsw_sp_sb_threshold_out(mlxsw_sp, pool_index,\n\t\t\t\t\t\t pm->max_buff);\n\treturn 0;\n}\n\nint mlxsw_sp_sb_port_pool_set(struct mlxsw_core_port *mlxsw_core_port,\n\t\t\t      unsigned int sb_index, u16 pool_index,\n\t\t\t      u32 threshold, struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port =\n\t\t\tmlxsw_core_port_driver_priv(mlxsw_core_port);\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\tu32 max_buff;\n\tint err;\n\n\tif (local_port == MLXSW_PORT_CPU_PORT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Changing CPU port's threshold is forbidden\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = mlxsw_sp_sb_threshold_in(mlxsw_sp, pool_index,\n\t\t\t\t       threshold, &max_buff, extack);\n\tif (err)\n\t\treturn err;\n\n\treturn mlxsw_sp_sb_pm_write(mlxsw_sp, local_port, pool_index,\n\t\t\t\t    0, max_buff);\n}\n\nint mlxsw_sp_sb_tc_pool_bind_get(struct mlxsw_core_port *mlxsw_core_port,\n\t\t\t\t unsigned int sb_index, u16 tc_index,\n\t\t\t\t enum devlink_sb_pool_type pool_type,\n\t\t\t\t u16 *p_pool_index, u32 *p_threshold)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port =\n\t\t\tmlxsw_core_port_driver_priv(mlxsw_core_port);\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\tu8 pg_buff = tc_index;\n\tenum mlxsw_reg_sbxx_dir dir = (enum mlxsw_reg_sbxx_dir) pool_type;\n\tstruct mlxsw_sp_sb_cm *cm = mlxsw_sp_sb_cm_get(mlxsw_sp, local_port,\n\t\t\t\t\t\t       pg_buff, dir);\n\n\t*p_threshold = mlxsw_sp_sb_threshold_out(mlxsw_sp, cm->pool_index,\n\t\t\t\t\t\t cm->max_buff);\n\t*p_pool_index = cm->pool_index;\n\treturn 0;\n}\n\nint mlxsw_sp_sb_tc_pool_bind_set(struct mlxsw_core_port *mlxsw_core_port,\n\t\t\t\t unsigned int sb_index, u16 tc_index,\n\t\t\t\t enum devlink_sb_pool_type pool_type,\n\t\t\t\t u16 pool_index, u32 threshold,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port =\n\t\t\tmlxsw_core_port_driver_priv(mlxsw_core_port);\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\tconst struct mlxsw_sp_sb_cm *cm;\n\tu8 pg_buff = tc_index;\n\tenum mlxsw_reg_sbxx_dir dir = (enum mlxsw_reg_sbxx_dir) pool_type;\n\tu32 max_buff;\n\tint err;\n\n\tif (local_port == MLXSW_PORT_CPU_PORT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Changing CPU port's binding is forbidden\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dir != mlxsw_sp->sb_vals->pool_dess[pool_index].dir) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Binding egress TC to ingress pool and vice versa is forbidden\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dir == MLXSW_REG_SBXX_DIR_INGRESS)\n\t\tcm = &mlxsw_sp->sb_vals->cms_ingress[tc_index];\n\telse\n\t\tcm = &mlxsw_sp->sb_vals->cms_egress[tc_index];\n\n\tif (cm->freeze_pool && cm->pool_index != pool_index) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Binding this TC to a different pool is forbidden\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cm->freeze_thresh && cm->max_buff != threshold) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Changing this TC's threshold is forbidden\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = mlxsw_sp_sb_threshold_in(mlxsw_sp, pool_index,\n\t\t\t\t       threshold, &max_buff, extack);\n\tif (err)\n\t\treturn err;\n\n\treturn mlxsw_sp_sb_cm_write(mlxsw_sp, local_port, pg_buff,\n\t\t\t\t    0, max_buff, false, pool_index);\n}\n\n#define MASKED_COUNT_MAX \\\n\t(MLXSW_REG_SBSR_REC_MAX_COUNT / \\\n\t (MLXSW_SP_SB_ING_TC_COUNT + MLXSW_SP_SB_EG_TC_COUNT))\n\nstruct mlxsw_sp_sb_sr_occ_query_cb_ctx {\n\tu8 masked_count;\n\tu16 local_port_1;\n};\n\nstatic void mlxsw_sp_sb_sr_occ_query_cb(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\tchar *sbsr_pl, size_t sbsr_pl_len,\n\t\t\t\t\tunsigned long cb_priv)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tstruct mlxsw_sp_sb_sr_occ_query_cb_ctx cb_ctx;\n\tu8 masked_count;\n\tu16 local_port;\n\tint rec_index = 0;\n\tstruct mlxsw_sp_sb_cm *cm;\n\tint i;\n\n\tmemcpy(&cb_ctx, &cb_priv, sizeof(cb_ctx));\n\n\tmasked_count = 0;\n\tfor (local_port = cb_ctx.local_port_1;\n\t     local_port < mlxsw_core_max_ports(mlxsw_core); local_port++) {\n\t\tif (!mlxsw_sp->ports[local_port])\n\t\t\tcontinue;\n\t\tif (local_port == MLXSW_PORT_CPU_PORT) {\n\t\t\t \n\t\t\tmasked_count++;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = 0; i < MLXSW_SP_SB_ING_TC_COUNT; i++) {\n\t\t\tcm = mlxsw_sp_sb_cm_get(mlxsw_sp, local_port, i,\n\t\t\t\t\t\tMLXSW_REG_SBXX_DIR_INGRESS);\n\t\t\tmlxsw_reg_sbsr_rec_unpack(sbsr_pl, rec_index++,\n\t\t\t\t\t\t  &cm->occ.cur, &cm->occ.max);\n\t\t}\n\t\tif (++masked_count == cb_ctx.masked_count)\n\t\t\tbreak;\n\t}\n\tmasked_count = 0;\n\tfor (local_port = cb_ctx.local_port_1;\n\t     local_port < mlxsw_core_max_ports(mlxsw_core); local_port++) {\n\t\tif (!mlxsw_sp->ports[local_port])\n\t\t\tcontinue;\n\t\tfor (i = 0; i < MLXSW_SP_SB_EG_TC_COUNT; i++) {\n\t\t\tcm = mlxsw_sp_sb_cm_get(mlxsw_sp, local_port, i,\n\t\t\t\t\t\tMLXSW_REG_SBXX_DIR_EGRESS);\n\t\t\tmlxsw_reg_sbsr_rec_unpack(sbsr_pl, rec_index++,\n\t\t\t\t\t\t  &cm->occ.cur, &cm->occ.max);\n\t\t}\n\t\tif (++masked_count == cb_ctx.masked_count)\n\t\t\tbreak;\n\t}\n}\n\nint mlxsw_sp_sb_occ_snapshot(struct mlxsw_core *mlxsw_core,\n\t\t\t     unsigned int sb_index)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tu16 local_port, local_port_1, last_local_port;\n\tstruct mlxsw_sp_sb_sr_occ_query_cb_ctx cb_ctx;\n\tu8 masked_count, current_page = 0;\n\tunsigned long cb_priv = 0;\n\tLIST_HEAD(bulk_list);\n\tchar *sbsr_pl;\n\tint i;\n\tint err;\n\tint err2;\n\n\tsbsr_pl = kmalloc(MLXSW_REG_SBSR_LEN, GFP_KERNEL);\n\tif (!sbsr_pl)\n\t\treturn -ENOMEM;\n\n\tlocal_port = MLXSW_PORT_CPU_PORT;\nnext_batch:\n\tlocal_port_1 = local_port;\n\tmasked_count = 0;\n\tmlxsw_reg_sbsr_pack(sbsr_pl, false);\n\tmlxsw_reg_sbsr_port_page_set(sbsr_pl, current_page);\n\tlast_local_port = current_page * MLXSW_REG_SBSR_NUM_PORTS_IN_PAGE +\n\t\t\t  MLXSW_REG_SBSR_NUM_PORTS_IN_PAGE - 1;\n\n\tfor (i = 0; i < MLXSW_SP_SB_ING_TC_COUNT; i++)\n\t\tmlxsw_reg_sbsr_pg_buff_mask_set(sbsr_pl, i, 1);\n\tfor (i = 0; i < MLXSW_SP_SB_EG_TC_COUNT; i++)\n\t\tmlxsw_reg_sbsr_tclass_mask_set(sbsr_pl, i, 1);\n\tfor (; local_port < mlxsw_core_max_ports(mlxsw_core); local_port++) {\n\t\tif (!mlxsw_sp->ports[local_port])\n\t\t\tcontinue;\n\t\tif (local_port > last_local_port) {\n\t\t\tcurrent_page++;\n\t\t\tgoto do_query;\n\t\t}\n\t\tif (local_port != MLXSW_PORT_CPU_PORT) {\n\t\t\t \n\t\t\tmlxsw_reg_sbsr_ingress_port_mask_set(sbsr_pl,\n\t\t\t\t\t\t\t     local_port, 1);\n\t\t}\n\t\tmlxsw_reg_sbsr_egress_port_mask_set(sbsr_pl, local_port, 1);\n\t\tfor (i = 0; i < mlxsw_sp->sb_vals->pool_count; i++) {\n\t\t\terr = mlxsw_sp_sb_pm_occ_query(mlxsw_sp, local_port, i,\n\t\t\t\t\t\t       &bulk_list);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (++masked_count == MASKED_COUNT_MAX)\n\t\t\tgoto do_query;\n\t}\n\ndo_query:\n\tcb_ctx.masked_count = masked_count;\n\tcb_ctx.local_port_1 = local_port_1;\n\tmemcpy(&cb_priv, &cb_ctx, sizeof(cb_ctx));\n\terr = mlxsw_reg_trans_query(mlxsw_core, MLXSW_REG(sbsr), sbsr_pl,\n\t\t\t\t    &bulk_list, mlxsw_sp_sb_sr_occ_query_cb,\n\t\t\t\t    cb_priv);\n\tif (err)\n\t\tgoto out;\n\tif (local_port < mlxsw_core_max_ports(mlxsw_core)) {\n\t\tlocal_port++;\n\t\tgoto next_batch;\n\t}\n\nout:\n\terr2 = mlxsw_reg_trans_bulk_wait(&bulk_list);\n\tif (!err)\n\t\terr = err2;\n\tkfree(sbsr_pl);\n\treturn err;\n}\n\nint mlxsw_sp_sb_occ_max_clear(struct mlxsw_core *mlxsw_core,\n\t\t\t      unsigned int sb_index)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tu16 local_port, last_local_port;\n\tLIST_HEAD(bulk_list);\n\tunsigned int masked_count;\n\tu8 current_page = 0;\n\tchar *sbsr_pl;\n\tint i;\n\tint err;\n\tint err2;\n\n\tsbsr_pl = kmalloc(MLXSW_REG_SBSR_LEN, GFP_KERNEL);\n\tif (!sbsr_pl)\n\t\treturn -ENOMEM;\n\n\tlocal_port = MLXSW_PORT_CPU_PORT;\nnext_batch:\n\tmasked_count = 0;\n\tmlxsw_reg_sbsr_pack(sbsr_pl, true);\n\tmlxsw_reg_sbsr_port_page_set(sbsr_pl, current_page);\n\tlast_local_port = current_page * MLXSW_REG_SBSR_NUM_PORTS_IN_PAGE +\n\t\t\t  MLXSW_REG_SBSR_NUM_PORTS_IN_PAGE - 1;\n\n\tfor (i = 0; i < MLXSW_SP_SB_ING_TC_COUNT; i++)\n\t\tmlxsw_reg_sbsr_pg_buff_mask_set(sbsr_pl, i, 1);\n\tfor (i = 0; i < MLXSW_SP_SB_EG_TC_COUNT; i++)\n\t\tmlxsw_reg_sbsr_tclass_mask_set(sbsr_pl, i, 1);\n\tfor (; local_port < mlxsw_core_max_ports(mlxsw_core); local_port++) {\n\t\tif (!mlxsw_sp->ports[local_port])\n\t\t\tcontinue;\n\t\tif (local_port > last_local_port) {\n\t\t\tcurrent_page++;\n\t\t\tgoto do_query;\n\t\t}\n\t\tif (local_port != MLXSW_PORT_CPU_PORT) {\n\t\t\t \n\t\t\tmlxsw_reg_sbsr_ingress_port_mask_set(sbsr_pl,\n\t\t\t\t\t\t\t     local_port, 1);\n\t\t}\n\t\tmlxsw_reg_sbsr_egress_port_mask_set(sbsr_pl, local_port, 1);\n\t\tfor (i = 0; i < mlxsw_sp->sb_vals->pool_count; i++) {\n\t\t\terr = mlxsw_sp_sb_pm_occ_clear(mlxsw_sp, local_port, i,\n\t\t\t\t\t\t       &bulk_list);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (++masked_count == MASKED_COUNT_MAX)\n\t\t\tgoto do_query;\n\t}\n\ndo_query:\n\terr = mlxsw_reg_trans_query(mlxsw_core, MLXSW_REG(sbsr), sbsr_pl,\n\t\t\t\t    &bulk_list, NULL, 0);\n\tif (err)\n\t\tgoto out;\n\tif (local_port < mlxsw_core_max_ports(mlxsw_core)) {\n\t\tlocal_port++;\n\t\tgoto next_batch;\n\t}\n\nout:\n\terr2 = mlxsw_reg_trans_bulk_wait(&bulk_list);\n\tif (!err)\n\t\terr = err2;\n\tkfree(sbsr_pl);\n\treturn err;\n}\n\nint mlxsw_sp_sb_occ_port_pool_get(struct mlxsw_core_port *mlxsw_core_port,\n\t\t\t\t  unsigned int sb_index, u16 pool_index,\n\t\t\t\t  u32 *p_cur, u32 *p_max)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port =\n\t\t\tmlxsw_core_port_driver_priv(mlxsw_core_port);\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\tstruct mlxsw_sp_sb_pm *pm = mlxsw_sp_sb_pm_get(mlxsw_sp, local_port,\n\t\t\t\t\t\t       pool_index);\n\n\t*p_cur = mlxsw_sp_cells_bytes(mlxsw_sp, pm->occ.cur);\n\t*p_max = mlxsw_sp_cells_bytes(mlxsw_sp, pm->occ.max);\n\treturn 0;\n}\n\nint mlxsw_sp_sb_occ_tc_port_bind_get(struct mlxsw_core_port *mlxsw_core_port,\n\t\t\t\t     unsigned int sb_index, u16 tc_index,\n\t\t\t\t     enum devlink_sb_pool_type pool_type,\n\t\t\t\t     u32 *p_cur, u32 *p_max)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port =\n\t\t\tmlxsw_core_port_driver_priv(mlxsw_core_port);\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\tu8 pg_buff = tc_index;\n\tenum mlxsw_reg_sbxx_dir dir = (enum mlxsw_reg_sbxx_dir) pool_type;\n\tstruct mlxsw_sp_sb_cm *cm = mlxsw_sp_sb_cm_get(mlxsw_sp, local_port,\n\t\t\t\t\t\t       pg_buff, dir);\n\n\t*p_cur = mlxsw_sp_cells_bytes(mlxsw_sp, cm->occ.cur);\n\t*p_max = mlxsw_sp_cells_bytes(mlxsw_sp, cm->occ.max);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}