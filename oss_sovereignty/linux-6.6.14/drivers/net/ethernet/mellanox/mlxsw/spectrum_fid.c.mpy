{
  "module_name": "spectrum_fid.c",
  "hash_id": "06ec719b78fa6390f2628fa77ee0242fd4baec30b30a09532259484155faceda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_fid.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/if_vlan.h>\n#include <linux/if_bridge.h>\n#include <linux/netdevice.h>\n#include <linux/rhashtable.h>\n#include <linux/rtnetlink.h>\n#include <linux/refcount.h>\n\n#include \"spectrum.h\"\n#include \"reg.h\"\n\nstruct mlxsw_sp_fid_family;\n\nstruct mlxsw_sp_fid_core {\n\tstruct rhashtable fid_ht;\n\tstruct rhashtable vni_ht;\n\tstruct mlxsw_sp_fid_family *fid_family_arr[MLXSW_SP_FID_TYPE_MAX];\n\tunsigned int *port_fid_mappings;\n};\n\nstruct mlxsw_sp_fid_port_vid {\n\tstruct list_head list;\n\tu16 local_port;\n\tu16 vid;\n};\n\nstruct mlxsw_sp_fid {\n\tstruct list_head list;\n\tstruct mlxsw_sp_rif *rif;\n\trefcount_t ref_count;\n\tu16 fid_index;\n\tu16 fid_offset;\n\tstruct mlxsw_sp_fid_family *fid_family;\n\tstruct rhash_head ht_node;\n\n\tstruct rhash_head vni_ht_node;\n\tenum mlxsw_sp_nve_type nve_type;\n\t__be32 vni;\n\tu32 nve_flood_index;\n\tint nve_ifindex;\n\tu8 vni_valid:1,\n\t   nve_flood_index_valid:1;\n\tstruct list_head port_vid_list;  \n};\n\nstruct mlxsw_sp_fid_8021q {\n\tstruct mlxsw_sp_fid common;\n\tu16 vid;\n};\n\nstruct mlxsw_sp_fid_8021d {\n\tstruct mlxsw_sp_fid common;\n\tint br_ifindex;\n};\n\nstatic const struct rhashtable_params mlxsw_sp_fid_ht_params = {\n\t.key_len = sizeof_field(struct mlxsw_sp_fid, fid_index),\n\t.key_offset = offsetof(struct mlxsw_sp_fid, fid_index),\n\t.head_offset = offsetof(struct mlxsw_sp_fid, ht_node),\n};\n\nstatic const struct rhashtable_params mlxsw_sp_fid_vni_ht_params = {\n\t.key_len = sizeof_field(struct mlxsw_sp_fid, vni),\n\t.key_offset = offsetof(struct mlxsw_sp_fid, vni),\n\t.head_offset = offsetof(struct mlxsw_sp_fid, vni_ht_node),\n};\n\nstruct mlxsw_sp_flood_table {\n\tenum mlxsw_sp_flood_type packet_type;\n\tenum mlxsw_flood_table_type table_type;\n\tint table_index;\n};\n\nstruct mlxsw_sp_fid_ops {\n\tvoid (*setup)(struct mlxsw_sp_fid *fid, const void *arg);\n\tint (*configure)(struct mlxsw_sp_fid *fid);\n\tvoid (*deconfigure)(struct mlxsw_sp_fid *fid);\n\tint (*index_alloc)(struct mlxsw_sp_fid *fid, const void *arg,\n\t\t\t   u16 *p_fid_index);\n\tbool (*compare)(const struct mlxsw_sp_fid *fid,\n\t\t\tconst void *arg);\n\tint (*port_vid_map)(struct mlxsw_sp_fid *fid,\n\t\t\t    struct mlxsw_sp_port *port, u16 vid);\n\tvoid (*port_vid_unmap)(struct mlxsw_sp_fid *fid,\n\t\t\t       struct mlxsw_sp_port *port, u16 vid);\n\tint (*vni_set)(struct mlxsw_sp_fid *fid);\n\tvoid (*vni_clear)(struct mlxsw_sp_fid *fid);\n\tint (*nve_flood_index_set)(struct mlxsw_sp_fid *fid);\n\tvoid (*nve_flood_index_clear)(struct mlxsw_sp_fid *fid);\n\tvoid (*fdb_clear_offload)(const struct mlxsw_sp_fid *fid,\n\t\t\t\t  const struct net_device *nve_dev);\n\tint (*vid_to_fid_rif_update)(const struct mlxsw_sp_fid *fid,\n\t\t\t\t     const struct mlxsw_sp_rif *rif);\n};\n\nstruct mlxsw_sp_fid_family {\n\tenum mlxsw_sp_fid_type type;\n\tsize_t fid_size;\n\tu16 start_index;\n\tu16 end_index;\n\tstruct list_head fids_list;\n\tunsigned long *fids_bitmap;\n\tconst struct mlxsw_sp_flood_table *flood_tables;\n\tint nr_flood_tables;\n\tenum mlxsw_sp_rif_type rif_type;\n\tconst struct mlxsw_sp_fid_ops *ops;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tbool flood_rsp;\n\tenum mlxsw_reg_bridge_type bridge_type;\n\tu16 pgt_base;\n\tbool smpe_index_valid;\n};\n\nstatic const int mlxsw_sp_sfgc_uc_packet_types[MLXSW_REG_SFGC_TYPE_MAX] = {\n\t[MLXSW_REG_SFGC_TYPE_UNKNOWN_UNICAST]\t\t\t= 1,\n};\n\nstatic const int mlxsw_sp_sfgc_bc_packet_types[MLXSW_REG_SFGC_TYPE_MAX] = {\n\t[MLXSW_REG_SFGC_TYPE_BROADCAST]\t\t\t\t= 1,\n\t[MLXSW_REG_SFGC_TYPE_UNREGISTERED_MULTICAST_NON_IP]\t= 1,\n\t[MLXSW_REG_SFGC_TYPE_IPV4_LINK_LOCAL]\t\t\t= 1,\n\t[MLXSW_REG_SFGC_TYPE_IPV6_ALL_HOST]\t\t\t= 1,\n\t[MLXSW_REG_SFGC_TYPE_UNREGISTERED_MULTICAST_IPV6]\t= 1,\n};\n\nstatic const int mlxsw_sp_sfgc_mc_packet_types[MLXSW_REG_SFGC_TYPE_MAX] = {\n\t[MLXSW_REG_SFGC_TYPE_UNREGISTERED_MULTICAST_IPV4]\t= 1,\n};\n\nstatic const int *mlxsw_sp_packet_type_sfgc_types[] = {\n\t[MLXSW_SP_FLOOD_TYPE_UC]\t= mlxsw_sp_sfgc_uc_packet_types,\n\t[MLXSW_SP_FLOOD_TYPE_BC]\t= mlxsw_sp_sfgc_bc_packet_types,\n\t[MLXSW_SP_FLOOD_TYPE_MC]\t= mlxsw_sp_sfgc_mc_packet_types,\n};\n\nstruct mlxsw_sp_fid *mlxsw_sp_fid_lookup_by_index(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t  u16 fid_index)\n{\n\tstruct mlxsw_sp_fid *fid;\n\n\tfid = rhashtable_lookup_fast(&mlxsw_sp->fid_core->fid_ht, &fid_index,\n\t\t\t\t     mlxsw_sp_fid_ht_params);\n\tif (fid)\n\t\trefcount_inc(&fid->ref_count);\n\n\treturn fid;\n}\n\nint mlxsw_sp_fid_nve_ifindex(const struct mlxsw_sp_fid *fid, int *nve_ifindex)\n{\n\tif (!fid->vni_valid)\n\t\treturn -EINVAL;\n\n\t*nve_ifindex = fid->nve_ifindex;\n\n\treturn 0;\n}\n\nint mlxsw_sp_fid_nve_type(const struct mlxsw_sp_fid *fid,\n\t\t\t  enum mlxsw_sp_nve_type *p_type)\n{\n\tif (!fid->vni_valid)\n\t\treturn -EINVAL;\n\n\t*p_type = fid->nve_type;\n\n\treturn 0;\n}\n\nstruct mlxsw_sp_fid *mlxsw_sp_fid_lookup_by_vni(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t__be32 vni)\n{\n\tstruct mlxsw_sp_fid *fid;\n\n\tfid = rhashtable_lookup_fast(&mlxsw_sp->fid_core->vni_ht, &vni,\n\t\t\t\t     mlxsw_sp_fid_vni_ht_params);\n\tif (fid)\n\t\trefcount_inc(&fid->ref_count);\n\n\treturn fid;\n}\n\nint mlxsw_sp_fid_vni(const struct mlxsw_sp_fid *fid, __be32 *vni)\n{\n\tif (!fid->vni_valid)\n\t\treturn -EINVAL;\n\n\t*vni = fid->vni;\n\n\treturn 0;\n}\n\nint mlxsw_sp_fid_nve_flood_index_set(struct mlxsw_sp_fid *fid,\n\t\t\t\t     u32 nve_flood_index)\n{\n\tstruct mlxsw_sp_fid_family *fid_family = fid->fid_family;\n\tconst struct mlxsw_sp_fid_ops *ops = fid_family->ops;\n\tint err;\n\n\tif (WARN_ON(fid->nve_flood_index_valid))\n\t\treturn -EINVAL;\n\n\tfid->nve_flood_index = nve_flood_index;\n\tfid->nve_flood_index_valid = true;\n\terr = ops->nve_flood_index_set(fid);\n\tif (err)\n\t\tgoto err_nve_flood_index_set;\n\n\treturn 0;\n\nerr_nve_flood_index_set:\n\tfid->nve_flood_index_valid = false;\n\treturn err;\n}\n\nvoid mlxsw_sp_fid_nve_flood_index_clear(struct mlxsw_sp_fid *fid)\n{\n\tstruct mlxsw_sp_fid_family *fid_family = fid->fid_family;\n\tconst struct mlxsw_sp_fid_ops *ops = fid_family->ops;\n\n\tif (WARN_ON(!fid->nve_flood_index_valid))\n\t\treturn;\n\n\tfid->nve_flood_index_valid = false;\n\tops->nve_flood_index_clear(fid);\n}\n\nbool mlxsw_sp_fid_nve_flood_index_is_set(const struct mlxsw_sp_fid *fid)\n{\n\treturn fid->nve_flood_index_valid;\n}\n\nint mlxsw_sp_fid_vni_set(struct mlxsw_sp_fid *fid, enum mlxsw_sp_nve_type type,\n\t\t\t __be32 vni, int nve_ifindex)\n{\n\tstruct mlxsw_sp_fid_family *fid_family = fid->fid_family;\n\tconst struct mlxsw_sp_fid_ops *ops = fid_family->ops;\n\tstruct mlxsw_sp *mlxsw_sp = fid_family->mlxsw_sp;\n\tint err;\n\n\tif (WARN_ON(fid->vni_valid))\n\t\treturn -EINVAL;\n\n\tfid->nve_type = type;\n\tfid->nve_ifindex = nve_ifindex;\n\tfid->vni = vni;\n\terr = rhashtable_lookup_insert_fast(&mlxsw_sp->fid_core->vni_ht,\n\t\t\t\t\t    &fid->vni_ht_node,\n\t\t\t\t\t    mlxsw_sp_fid_vni_ht_params);\n\tif (err)\n\t\treturn err;\n\n\tfid->vni_valid = true;\n\terr = ops->vni_set(fid);\n\tif (err)\n\t\tgoto err_vni_set;\n\n\treturn 0;\n\nerr_vni_set:\n\tfid->vni_valid = false;\n\trhashtable_remove_fast(&mlxsw_sp->fid_core->vni_ht, &fid->vni_ht_node,\n\t\t\t       mlxsw_sp_fid_vni_ht_params);\n\treturn err;\n}\n\nvoid mlxsw_sp_fid_vni_clear(struct mlxsw_sp_fid *fid)\n{\n\tstruct mlxsw_sp_fid_family *fid_family = fid->fid_family;\n\tconst struct mlxsw_sp_fid_ops *ops = fid_family->ops;\n\tstruct mlxsw_sp *mlxsw_sp = fid_family->mlxsw_sp;\n\n\tif (WARN_ON(!fid->vni_valid))\n\t\treturn;\n\n\tfid->vni_valid = false;\n\tops->vni_clear(fid);\n\trhashtable_remove_fast(&mlxsw_sp->fid_core->vni_ht, &fid->vni_ht_node,\n\t\t\t       mlxsw_sp_fid_vni_ht_params);\n}\n\nbool mlxsw_sp_fid_vni_is_set(const struct mlxsw_sp_fid *fid)\n{\n\treturn fid->vni_valid;\n}\n\nvoid mlxsw_sp_fid_fdb_clear_offload(const struct mlxsw_sp_fid *fid,\n\t\t\t\t    const struct net_device *nve_dev)\n{\n\tstruct mlxsw_sp_fid_family *fid_family = fid->fid_family;\n\tconst struct mlxsw_sp_fid_ops *ops = fid_family->ops;\n\n\tif (ops->fdb_clear_offload)\n\t\tops->fdb_clear_offload(fid, nve_dev);\n}\n\nstatic const struct mlxsw_sp_flood_table *\nmlxsw_sp_fid_flood_table_lookup(const struct mlxsw_sp_fid *fid,\n\t\t\t\tenum mlxsw_sp_flood_type packet_type)\n{\n\tstruct mlxsw_sp_fid_family *fid_family = fid->fid_family;\n\tint i;\n\n\tfor (i = 0; i < fid_family->nr_flood_tables; i++) {\n\t\tif (fid_family->flood_tables[i].packet_type != packet_type)\n\t\t\tcontinue;\n\t\treturn &fid_family->flood_tables[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic u16\nmlxsw_sp_fid_family_num_fids(const struct mlxsw_sp_fid_family *fid_family)\n{\n\treturn fid_family->end_index - fid_family->start_index + 1;\n}\n\nstatic u16\nmlxsw_sp_fid_flood_table_mid(const struct mlxsw_sp_fid_family *fid_family,\n\t\t\t     const struct mlxsw_sp_flood_table *flood_table,\n\t\t\t     u16 fid_offset)\n{\n\tu16 num_fids;\n\n\tnum_fids = mlxsw_sp_fid_family_num_fids(fid_family);\n\treturn fid_family->pgt_base + num_fids * flood_table->table_index +\n\t       fid_offset;\n}\n\nint mlxsw_sp_fid_flood_set(struct mlxsw_sp_fid *fid,\n\t\t\t   enum mlxsw_sp_flood_type packet_type, u16 local_port,\n\t\t\t   bool member)\n{\n\tstruct mlxsw_sp_fid_family *fid_family = fid->fid_family;\n\tconst struct mlxsw_sp_flood_table *flood_table;\n\tu16 mid_index;\n\n\tif (WARN_ON(!fid_family->flood_tables))\n\t\treturn -EINVAL;\n\n\tflood_table = mlxsw_sp_fid_flood_table_lookup(fid, packet_type);\n\tif (!flood_table)\n\t\treturn -ESRCH;\n\n\tmid_index = mlxsw_sp_fid_flood_table_mid(fid_family, flood_table,\n\t\t\t\t\t\t fid->fid_offset);\n\treturn mlxsw_sp_pgt_entry_port_set(fid_family->mlxsw_sp, mid_index,\n\t\t\t\t\t   fid->fid_index, local_port, member);\n}\n\nint mlxsw_sp_fid_port_vid_map(struct mlxsw_sp_fid *fid,\n\t\t\t      struct mlxsw_sp_port *mlxsw_sp_port, u16 vid)\n{\n\tif (WARN_ON(!fid->fid_family->ops->port_vid_map))\n\t\treturn -EINVAL;\n\treturn fid->fid_family->ops->port_vid_map(fid, mlxsw_sp_port, vid);\n}\n\nvoid mlxsw_sp_fid_port_vid_unmap(struct mlxsw_sp_fid *fid,\n\t\t\t\t struct mlxsw_sp_port *mlxsw_sp_port, u16 vid)\n{\n\tfid->fid_family->ops->port_vid_unmap(fid, mlxsw_sp_port, vid);\n}\n\nu16 mlxsw_sp_fid_index(const struct mlxsw_sp_fid *fid)\n{\n\treturn fid->fid_index;\n}\n\nenum mlxsw_sp_fid_type mlxsw_sp_fid_type(const struct mlxsw_sp_fid *fid)\n{\n\treturn fid->fid_family->type;\n}\n\nstruct mlxsw_sp_rif *mlxsw_sp_fid_rif(const struct mlxsw_sp_fid *fid)\n{\n\treturn fid->rif;\n}\n\nenum mlxsw_sp_rif_type\nmlxsw_sp_fid_type_rif_type(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t   enum mlxsw_sp_fid_type type)\n{\n\tstruct mlxsw_sp_fid_core *fid_core = mlxsw_sp->fid_core;\n\n\treturn fid_core->fid_family_arr[type]->rif_type;\n}\n\nstatic struct mlxsw_sp_fid_8021q *\nmlxsw_sp_fid_8021q_fid(const struct mlxsw_sp_fid *fid)\n{\n\treturn container_of(fid, struct mlxsw_sp_fid_8021q, common);\n}\n\nu16 mlxsw_sp_fid_8021q_vid(const struct mlxsw_sp_fid *fid)\n{\n\treturn mlxsw_sp_fid_8021q_fid(fid)->vid;\n}\n\nstatic void mlxsw_sp_fid_8021q_setup(struct mlxsw_sp_fid *fid, const void *arg)\n{\n\tu16 vid = *(u16 *) arg;\n\n\tmlxsw_sp_fid_8021q_fid(fid)->vid = vid;\n\tfid->fid_offset = fid->fid_index - fid->fid_family->start_index;\n}\n\nstatic enum mlxsw_reg_sfmr_op mlxsw_sp_sfmr_op(bool valid)\n{\n\treturn valid ? MLXSW_REG_SFMR_OP_CREATE_FID :\n\t\t       MLXSW_REG_SFMR_OP_DESTROY_FID;\n}\n\nstatic int mlxsw_sp_fid_op(const struct mlxsw_sp_fid *fid, bool valid)\n{\n\tstruct mlxsw_sp *mlxsw_sp = fid->fid_family->mlxsw_sp;\n\tchar sfmr_pl[MLXSW_REG_SFMR_LEN];\n\tu16 smpe;\n\n\tsmpe = fid->fid_family->smpe_index_valid ? fid->fid_index : 0;\n\n\tmlxsw_reg_sfmr_pack(sfmr_pl, mlxsw_sp_sfmr_op(valid), fid->fid_index,\n\t\t\t    fid->fid_offset, fid->fid_family->flood_rsp,\n\t\t\t    fid->fid_family->bridge_type,\n\t\t\t    fid->fid_family->smpe_index_valid, smpe);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfmr), sfmr_pl);\n}\n\nstatic int mlxsw_sp_fid_edit_op(const struct mlxsw_sp_fid *fid,\n\t\t\t\tconst struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp *mlxsw_sp = fid->fid_family->mlxsw_sp;\n\tchar sfmr_pl[MLXSW_REG_SFMR_LEN];\n\tu16 smpe;\n\n\tsmpe = fid->fid_family->smpe_index_valid ? fid->fid_index : 0;\n\n\tmlxsw_reg_sfmr_pack(sfmr_pl, MLXSW_REG_SFMR_OP_CREATE_FID,\n\t\t\t    fid->fid_index, fid->fid_offset,\n\t\t\t    fid->fid_family->flood_rsp,\n\t\t\t    fid->fid_family->bridge_type,\n\t\t\t    fid->fid_family->smpe_index_valid, smpe);\n\tmlxsw_reg_sfmr_vv_set(sfmr_pl, fid->vni_valid);\n\tmlxsw_reg_sfmr_vni_set(sfmr_pl, be32_to_cpu(fid->vni));\n\tmlxsw_reg_sfmr_vtfp_set(sfmr_pl, fid->nve_flood_index_valid);\n\tmlxsw_reg_sfmr_nve_tunnel_flood_ptr_set(sfmr_pl, fid->nve_flood_index);\n\n\tif (rif) {\n\t\tmlxsw_reg_sfmr_irif_v_set(sfmr_pl, true);\n\t\tmlxsw_reg_sfmr_irif_set(sfmr_pl, mlxsw_sp_rif_index(rif));\n\t}\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfmr), sfmr_pl);\n}\n\nstatic int mlxsw_sp_fid_vni_to_fid_map(const struct mlxsw_sp_fid *fid,\n\t\t\t\t       const struct mlxsw_sp_rif *rif,\n\t\t\t\t       bool valid)\n{\n\tstruct mlxsw_sp *mlxsw_sp = fid->fid_family->mlxsw_sp;\n\tchar svfa_pl[MLXSW_REG_SVFA_LEN];\n\tbool irif_valid;\n\tu16 irif_index;\n\n\tirif_valid = !!rif;\n\tirif_index = rif ? mlxsw_sp_rif_index(rif) : 0;\n\n\tmlxsw_reg_svfa_vni_pack(svfa_pl, valid, fid->fid_index,\n\t\t\t\tbe32_to_cpu(fid->vni), irif_valid, irif_index);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(svfa), svfa_pl);\n}\n\nstatic int mlxsw_sp_fid_to_fid_rif_update(const struct mlxsw_sp_fid *fid,\n\t\t\t\t\t  const struct mlxsw_sp_rif *rif)\n{\n\treturn mlxsw_sp_fid_edit_op(fid, rif);\n}\n\nstatic int mlxsw_sp_fid_vni_to_fid_rif_update(const struct mlxsw_sp_fid *fid,\n\t\t\t\t\t      const struct mlxsw_sp_rif *rif)\n{\n\tif (!fid->vni_valid)\n\t\treturn 0;\n\n\treturn mlxsw_sp_fid_vni_to_fid_map(fid, rif, fid->vni_valid);\n}\n\nstatic int\nmlxsw_sp_fid_vid_to_fid_map(const struct mlxsw_sp_fid *fid, u16 vid, bool valid,\n\t\t\t    const struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp *mlxsw_sp = fid->fid_family->mlxsw_sp;\n\tchar svfa_pl[MLXSW_REG_SVFA_LEN];\n\tbool irif_valid;\n\tu16 irif_index;\n\n\tirif_valid = !!rif;\n\tirif_index = rif ? mlxsw_sp_rif_index(rif) : 0;\n\n\tmlxsw_reg_svfa_vid_pack(svfa_pl, valid, fid->fid_index, vid, irif_valid,\n\t\t\t\tirif_index);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(svfa), svfa_pl);\n}\n\nstatic int\nmlxsw_sp_fid_8021q_vid_to_fid_rif_update(const struct mlxsw_sp_fid *fid,\n\t\t\t\t\t const struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp_fid_8021q *fid_8021q = mlxsw_sp_fid_8021q_fid(fid);\n\n\t \n\treturn mlxsw_sp_fid_vid_to_fid_map(fid, fid_8021q->vid, true, rif);\n}\n\nstatic int\nmlxsw_sp_fid_port_vid_to_fid_rif_update_one(const struct mlxsw_sp_fid *fid,\n\t\t\t\t\t    struct mlxsw_sp_fid_port_vid *pv,\n\t\t\t\t\t    bool irif_valid, u16 irif_index)\n{\n\tstruct mlxsw_sp *mlxsw_sp = fid->fid_family->mlxsw_sp;\n\tchar svfa_pl[MLXSW_REG_SVFA_LEN];\n\n\tmlxsw_reg_svfa_port_vid_pack(svfa_pl, pv->local_port, true,\n\t\t\t\t     fid->fid_index, pv->vid, irif_valid,\n\t\t\t\t     irif_index);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(svfa), svfa_pl);\n}\n\nstatic int mlxsw_sp_fid_vid_to_fid_rif_set(const struct mlxsw_sp_fid *fid,\n\t\t\t\t\t   const struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp *mlxsw_sp = fid->fid_family->mlxsw_sp;\n\tstruct mlxsw_sp_fid_port_vid *pv;\n\tu16 irif_index;\n\tint err;\n\n\terr = fid->fid_family->ops->vid_to_fid_rif_update(fid, rif);\n\tif (err)\n\t\treturn err;\n\n\tirif_index = mlxsw_sp_rif_index(rif);\n\n\tlist_for_each_entry(pv, &fid->port_vid_list, list) {\n\t\t \n\t\tif (!mlxsw_sp->fid_core->port_fid_mappings[pv->local_port])\n\t\t\tcontinue;\n\n\t\terr = mlxsw_sp_fid_port_vid_to_fid_rif_update_one(fid, pv,\n\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t  irif_index);\n\t\tif (err)\n\t\t\tgoto err_port_vid_to_fid_rif_update_one;\n\t}\n\n\treturn 0;\n\nerr_port_vid_to_fid_rif_update_one:\n\tlist_for_each_entry_continue_reverse(pv, &fid->port_vid_list, list) {\n\t\tif (!mlxsw_sp->fid_core->port_fid_mappings[pv->local_port])\n\t\t\tcontinue;\n\n\t\tmlxsw_sp_fid_port_vid_to_fid_rif_update_one(fid, pv, false, 0);\n\t}\n\n\tfid->fid_family->ops->vid_to_fid_rif_update(fid, NULL);\n\treturn err;\n}\n\nstatic void mlxsw_sp_fid_vid_to_fid_rif_unset(const struct mlxsw_sp_fid *fid)\n{\n\tstruct mlxsw_sp *mlxsw_sp = fid->fid_family->mlxsw_sp;\n\tstruct mlxsw_sp_fid_port_vid *pv;\n\n\tlist_for_each_entry(pv, &fid->port_vid_list, list) {\n\t\t \n\t\tif (!mlxsw_sp->fid_core->port_fid_mappings[pv->local_port])\n\t\t\tcontinue;\n\n\t\tmlxsw_sp_fid_port_vid_to_fid_rif_update_one(fid, pv, false, 0);\n\t}\n\n\tfid->fid_family->ops->vid_to_fid_rif_update(fid, NULL);\n}\n\nstatic int mlxsw_sp_fid_reiv_handle(struct mlxsw_sp_fid *fid, u16 rif_index,\n\t\t\t\t    bool valid, u8 port_page)\n{\n\tu16 local_port_end = (port_page + 1) * MLXSW_REG_REIV_REC_MAX_COUNT - 1;\n\tu16 local_port_start = port_page * MLXSW_REG_REIV_REC_MAX_COUNT;\n\tstruct mlxsw_sp *mlxsw_sp = fid->fid_family->mlxsw_sp;\n\tstruct mlxsw_sp_fid_port_vid *port_vid;\n\tu8 rec_num, entries_num = 0;\n\tchar *reiv_pl;\n\tint err;\n\n\treiv_pl = kmalloc(MLXSW_REG_REIV_LEN, GFP_KERNEL);\n\tif (!reiv_pl)\n\t\treturn -ENOMEM;\n\n\tmlxsw_reg_reiv_pack(reiv_pl, port_page, rif_index);\n\n\tlist_for_each_entry(port_vid, &fid->port_vid_list, list) {\n\t\t \n\t\tif (port_vid->local_port < local_port_start)\n\t\t\tcontinue;\n\n\t\tif (port_vid->local_port > local_port_end)\n\t\t\tbreak;\n\n\t\trec_num = port_vid->local_port % MLXSW_REG_REIV_REC_MAX_COUNT;\n\t\tmlxsw_reg_reiv_rec_update_set(reiv_pl, rec_num, true);\n\t\tmlxsw_reg_reiv_rec_evid_set(reiv_pl, rec_num,\n\t\t\t\t\t    valid ? port_vid->vid : 0);\n\t\tentries_num++;\n\t}\n\n\tif (!entries_num) {\n\t\tkfree(reiv_pl);\n\t\treturn 0;\n\t}\n\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(reiv), reiv_pl);\n\tif (err)\n\t\tgoto err_reg_write;\n\n\tkfree(reiv_pl);\n\treturn 0;\n\nerr_reg_write:\n\tkfree(reiv_pl);\n\treturn err;\n}\n\nstatic int mlxsw_sp_fid_erif_eport_to_vid_map(struct mlxsw_sp_fid *fid,\n\t\t\t\t\t      u16 rif_index, bool valid)\n{\n\tstruct mlxsw_sp *mlxsw_sp = fid->fid_family->mlxsw_sp;\n\tu8 num_port_pages;\n\tint err, i;\n\n\tnum_port_pages = mlxsw_core_max_ports(mlxsw_sp->core) /\n\t\t\t MLXSW_REG_REIV_REC_MAX_COUNT + 1;\n\n\tfor (i = 0; i < num_port_pages; i++) {\n\t\terr = mlxsw_sp_fid_reiv_handle(fid, rif_index, valid, i);\n\t\tif (err)\n\t\t\tgoto err_reiv_handle;\n\t}\n\n\treturn 0;\n\nerr_reiv_handle:\n\tfor (; i >= 0; i--)\n\t\tmlxsw_sp_fid_reiv_handle(fid, rif_index, !valid, i);\n\treturn err;\n}\n\nint mlxsw_sp_fid_rif_set(struct mlxsw_sp_fid *fid, struct mlxsw_sp_rif *rif)\n{\n\tu16 rif_index = mlxsw_sp_rif_index(rif);\n\tint err;\n\n\terr = mlxsw_sp_fid_to_fid_rif_update(fid, rif);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_fid_vni_to_fid_rif_update(fid, rif);\n\tif (err)\n\t\tgoto err_vni_to_fid_rif_update;\n\n\terr = mlxsw_sp_fid_vid_to_fid_rif_set(fid, rif);\n\tif (err)\n\t\tgoto err_vid_to_fid_rif_set;\n\n\terr = mlxsw_sp_fid_erif_eport_to_vid_map(fid, rif_index, true);\n\tif (err)\n\t\tgoto err_erif_eport_to_vid_map;\n\n\tfid->rif = rif;\n\treturn 0;\n\nerr_erif_eport_to_vid_map:\n\tmlxsw_sp_fid_vid_to_fid_rif_unset(fid);\nerr_vid_to_fid_rif_set:\n\tmlxsw_sp_fid_vni_to_fid_rif_update(fid, NULL);\nerr_vni_to_fid_rif_update:\n\tmlxsw_sp_fid_to_fid_rif_update(fid, NULL);\n\treturn err;\n}\n\nvoid mlxsw_sp_fid_rif_unset(struct mlxsw_sp_fid *fid)\n{\n\tu16 rif_index;\n\n\tif (!fid->rif)\n\t\treturn;\n\n\trif_index = mlxsw_sp_rif_index(fid->rif);\n\tfid->rif = NULL;\n\n\tmlxsw_sp_fid_erif_eport_to_vid_map(fid, rif_index, false);\n\tmlxsw_sp_fid_vid_to_fid_rif_unset(fid);\n\tmlxsw_sp_fid_vni_to_fid_rif_update(fid, NULL);\n\tmlxsw_sp_fid_to_fid_rif_update(fid, NULL);\n}\n\nstatic int mlxsw_sp_fid_vni_op(const struct mlxsw_sp_fid *fid)\n{\n\tint err;\n\n\terr = mlxsw_sp_fid_vni_to_fid_map(fid, fid->rif, fid->vni_valid);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_fid_edit_op(fid, fid->rif);\n\tif (err)\n\t\tgoto err_fid_edit_op;\n\n\treturn 0;\n\nerr_fid_edit_op:\n\tmlxsw_sp_fid_vni_to_fid_map(fid, fid->rif, !fid->vni_valid);\n\treturn err;\n}\n\nstatic int __mlxsw_sp_fid_port_vid_map(const struct mlxsw_sp_fid *fid,\n\t\t\t\t       u16 local_port, u16 vid, bool valid)\n{\n\tstruct mlxsw_sp *mlxsw_sp = fid->fid_family->mlxsw_sp;\n\tchar svfa_pl[MLXSW_REG_SVFA_LEN];\n\tbool irif_valid = false;\n\tu16 irif_index = 0;\n\n\tif (fid->rif) {\n\t\tirif_valid = true;\n\t\tirif_index = mlxsw_sp_rif_index(fid->rif);\n\t}\n\n\tmlxsw_reg_svfa_port_vid_pack(svfa_pl, local_port, valid, fid->fid_index,\n\t\t\t\t     vid, irif_valid, irif_index);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(svfa), svfa_pl);\n}\n\nstatic struct mlxsw_sp_fid_8021d *\nmlxsw_sp_fid_8021d_fid(const struct mlxsw_sp_fid *fid)\n{\n\treturn container_of(fid, struct mlxsw_sp_fid_8021d, common);\n}\n\nstatic void mlxsw_sp_fid_8021d_setup(struct mlxsw_sp_fid *fid, const void *arg)\n{\n\tint br_ifindex = *(int *) arg;\n\n\tmlxsw_sp_fid_8021d_fid(fid)->br_ifindex = br_ifindex;\n\tfid->fid_offset = fid->fid_index - fid->fid_family->start_index;\n}\n\nstatic int mlxsw_sp_fid_8021d_configure(struct mlxsw_sp_fid *fid)\n{\n\treturn mlxsw_sp_fid_op(fid, true);\n}\n\nstatic void mlxsw_sp_fid_8021d_deconfigure(struct mlxsw_sp_fid *fid)\n{\n\tif (fid->vni_valid)\n\t\tmlxsw_sp_nve_fid_disable(fid->fid_family->mlxsw_sp, fid);\n\tmlxsw_sp_fid_op(fid, false);\n}\n\nstatic int mlxsw_sp_fid_8021d_index_alloc(struct mlxsw_sp_fid *fid,\n\t\t\t\t\t  const void *arg, u16 *p_fid_index)\n{\n\tstruct mlxsw_sp_fid_family *fid_family = fid->fid_family;\n\tu16 nr_fids, fid_index;\n\n\tnr_fids = fid_family->end_index - fid_family->start_index + 1;\n\tfid_index = find_first_zero_bit(fid_family->fids_bitmap, nr_fids);\n\tif (fid_index == nr_fids)\n\t\treturn -ENOBUFS;\n\t*p_fid_index = fid_family->start_index + fid_index;\n\n\treturn 0;\n}\n\nstatic bool\nmlxsw_sp_fid_8021d_compare(const struct mlxsw_sp_fid *fid, const void *arg)\n{\n\tint br_ifindex = *(int *) arg;\n\n\treturn mlxsw_sp_fid_8021d_fid(fid)->br_ifindex == br_ifindex;\n}\n\nstatic int mlxsw_sp_port_vp_mode_trans(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tint err;\n\n\tlist_for_each_entry(mlxsw_sp_port_vlan, &mlxsw_sp_port->vlans_list,\n\t\t\t    list) {\n\t\tstruct mlxsw_sp_fid *fid = mlxsw_sp_port_vlan->fid;\n\t\tu16 vid = mlxsw_sp_port_vlan->vid;\n\n\t\tif (!fid)\n\t\t\tcontinue;\n\n\t\terr = __mlxsw_sp_fid_port_vid_map(fid,\n\t\t\t\t\t\t  mlxsw_sp_port->local_port,\n\t\t\t\t\t\t  vid, true);\n\t\tif (err)\n\t\t\tgoto err_fid_port_vid_map;\n\t}\n\n\terr = mlxsw_sp_port_vp_mode_set(mlxsw_sp_port, true);\n\tif (err)\n\t\tgoto err_port_vp_mode_set;\n\n\treturn 0;\n\nerr_port_vp_mode_set:\nerr_fid_port_vid_map:\n\tlist_for_each_entry_continue_reverse(mlxsw_sp_port_vlan,\n\t\t\t\t\t     &mlxsw_sp_port->vlans_list, list) {\n\t\tstruct mlxsw_sp_fid *fid = mlxsw_sp_port_vlan->fid;\n\t\tu16 vid = mlxsw_sp_port_vlan->vid;\n\n\t\tif (!fid)\n\t\t\tcontinue;\n\n\t\t__mlxsw_sp_fid_port_vid_map(fid, mlxsw_sp_port->local_port, vid,\n\t\t\t\t\t    false);\n\t}\n\treturn err;\n}\n\nstatic void mlxsw_sp_port_vlan_mode_trans(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\n\tmlxsw_sp_port_vp_mode_set(mlxsw_sp_port, false);\n\n\tlist_for_each_entry_reverse(mlxsw_sp_port_vlan,\n\t\t\t\t    &mlxsw_sp_port->vlans_list, list) {\n\t\tstruct mlxsw_sp_fid *fid = mlxsw_sp_port_vlan->fid;\n\t\tu16 vid = mlxsw_sp_port_vlan->vid;\n\n\t\tif (!fid)\n\t\t\tcontinue;\n\n\t\t__mlxsw_sp_fid_port_vid_map(fid, mlxsw_sp_port->local_port, vid,\n\t\t\t\t\t    false);\n\t}\n}\n\nstatic int\nmlxsw_sp_fid_port_vid_list_add(struct mlxsw_sp_fid *fid, u16 local_port,\n\t\t\t       u16 vid)\n{\n\tstruct mlxsw_sp_fid_port_vid *port_vid, *tmp_port_vid;\n\n\tport_vid = kzalloc(sizeof(*port_vid), GFP_KERNEL);\n\tif (!port_vid)\n\t\treturn -ENOMEM;\n\n\tport_vid->local_port = local_port;\n\tport_vid->vid = vid;\n\n\tlist_for_each_entry(tmp_port_vid, &fid->port_vid_list, list) {\n\t\tif (tmp_port_vid->local_port > local_port)\n\t\t\tbreak;\n\t}\n\n\tlist_add_tail(&port_vid->list, &tmp_port_vid->list);\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_fid_port_vid_list_del(struct mlxsw_sp_fid *fid, u16 local_port,\n\t\t\t       u16 vid)\n{\n\tstruct mlxsw_sp_fid_port_vid *port_vid, *tmp;\n\n\tlist_for_each_entry_safe(port_vid, tmp, &fid->port_vid_list, list) {\n\t\tif (port_vid->local_port != local_port || port_vid->vid != vid)\n\t\t\tcontinue;\n\n\t\tlist_del(&port_vid->list);\n\t\tkfree(port_vid);\n\t\treturn;\n\t}\n}\n\nstatic int\nmlxsw_sp_fid_mpe_table_map(const struct mlxsw_sp_fid *fid, u16 local_port,\n\t\t\t   u16 vid, bool valid)\n{\n\tstruct mlxsw_sp *mlxsw_sp = fid->fid_family->mlxsw_sp;\n\tchar smpe_pl[MLXSW_REG_SMPE_LEN];\n\n\tmlxsw_reg_smpe_pack(smpe_pl, local_port, fid->fid_index,\n\t\t\t    valid ? vid : 0);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(smpe), smpe_pl);\n}\n\nstatic int\nmlxsw_sp_fid_erif_eport_to_vid_map_one(const struct mlxsw_sp_fid *fid,\n\t\t\t\t       u16 local_port, u16 vid, bool valid)\n{\n\tu8 port_page = local_port / MLXSW_REG_REIV_REC_MAX_COUNT;\n\tu8 rec_num = local_port % MLXSW_REG_REIV_REC_MAX_COUNT;\n\tstruct mlxsw_sp *mlxsw_sp = fid->fid_family->mlxsw_sp;\n\tu16 rif_index = mlxsw_sp_rif_index(fid->rif);\n\tchar *reiv_pl;\n\tint err;\n\n\treiv_pl = kmalloc(MLXSW_REG_REIV_LEN, GFP_KERNEL);\n\tif (!reiv_pl)\n\t\treturn -ENOMEM;\n\n\tmlxsw_reg_reiv_pack(reiv_pl, port_page, rif_index);\n\tmlxsw_reg_reiv_rec_update_set(reiv_pl, rec_num, true);\n\tmlxsw_reg_reiv_rec_evid_set(reiv_pl, rec_num, valid ? vid : 0);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(reiv), reiv_pl);\n\tkfree(reiv_pl);\n\treturn err;\n}\n\nstatic int mlxsw_sp_fid_evid_map(const struct mlxsw_sp_fid *fid, u16 local_port,\n\t\t\t\t u16 vid, bool valid)\n{\n\tint err;\n\n\terr = mlxsw_sp_fid_mpe_table_map(fid, local_port, vid, valid);\n\tif (err)\n\t\treturn err;\n\n\tif (!fid->rif)\n\t\treturn 0;\n\n\terr = mlxsw_sp_fid_erif_eport_to_vid_map_one(fid, local_port, vid,\n\t\t\t\t\t\t     valid);\n\tif (err)\n\t\tgoto err_erif_eport_to_vid_map_one;\n\n\treturn 0;\n\nerr_erif_eport_to_vid_map_one:\n\tmlxsw_sp_fid_mpe_table_map(fid, local_port, vid, !valid);\n\treturn err;\n}\n\nstatic int mlxsw_sp_fid_8021d_port_vid_map(struct mlxsw_sp_fid *fid,\n\t\t\t\t\t   struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t   u16 vid)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\tint err;\n\n\terr = __mlxsw_sp_fid_port_vid_map(fid, mlxsw_sp_port->local_port, vid,\n\t\t\t\t\t  true);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_fid_evid_map(fid, local_port, vid, true);\n\tif (err)\n\t\tgoto err_fid_evid_map;\n\n\terr = mlxsw_sp_fid_port_vid_list_add(fid, mlxsw_sp_port->local_port,\n\t\t\t\t\t     vid);\n\tif (err)\n\t\tgoto err_port_vid_list_add;\n\n\tif (mlxsw_sp->fid_core->port_fid_mappings[local_port]++ == 0) {\n\t\terr = mlxsw_sp_port_vp_mode_trans(mlxsw_sp_port);\n\t\tif (err)\n\t\t\tgoto err_port_vp_mode_trans;\n\t}\n\n\treturn 0;\n\nerr_port_vp_mode_trans:\n\tmlxsw_sp->fid_core->port_fid_mappings[local_port]--;\n\tmlxsw_sp_fid_port_vid_list_del(fid, mlxsw_sp_port->local_port, vid);\nerr_port_vid_list_add:\n\tmlxsw_sp_fid_evid_map(fid, local_port, vid, false);\nerr_fid_evid_map:\n\t__mlxsw_sp_fid_port_vid_map(fid, mlxsw_sp_port->local_port, vid, false);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_fid_8021d_port_vid_unmap(struct mlxsw_sp_fid *fid,\n\t\t\t\t  struct mlxsw_sp_port *mlxsw_sp_port, u16 vid)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\n\tif (mlxsw_sp->fid_core->port_fid_mappings[local_port] == 1)\n\t\tmlxsw_sp_port_vlan_mode_trans(mlxsw_sp_port);\n\tmlxsw_sp->fid_core->port_fid_mappings[local_port]--;\n\tmlxsw_sp_fid_port_vid_list_del(fid, mlxsw_sp_port->local_port, vid);\n\tmlxsw_sp_fid_evid_map(fid, local_port, vid, false);\n\t__mlxsw_sp_fid_port_vid_map(fid, mlxsw_sp_port->local_port, vid, false);\n}\n\nstatic int mlxsw_sp_fid_8021d_vni_set(struct mlxsw_sp_fid *fid)\n{\n\treturn mlxsw_sp_fid_vni_op(fid);\n}\n\nstatic void mlxsw_sp_fid_8021d_vni_clear(struct mlxsw_sp_fid *fid)\n{\n\tmlxsw_sp_fid_vni_op(fid);\n}\n\nstatic int mlxsw_sp_fid_8021d_nve_flood_index_set(struct mlxsw_sp_fid *fid)\n{\n\treturn mlxsw_sp_fid_edit_op(fid, fid->rif);\n}\n\nstatic void mlxsw_sp_fid_8021d_nve_flood_index_clear(struct mlxsw_sp_fid *fid)\n{\n\tmlxsw_sp_fid_edit_op(fid, fid->rif);\n}\n\nstatic void\nmlxsw_sp_fid_8021d_fdb_clear_offload(const struct mlxsw_sp_fid *fid,\n\t\t\t\t     const struct net_device *nve_dev)\n{\n\tbr_fdb_clear_offload(nve_dev, 0);\n}\n\nstatic int\nmlxsw_sp_fid_8021d_vid_to_fid_rif_update(const struct mlxsw_sp_fid *fid,\n\t\t\t\t\t const struct mlxsw_sp_rif *rif)\n{\n\treturn 0;\n}\n\nstatic const struct mlxsw_sp_fid_ops mlxsw_sp_fid_8021d_ops = {\n\t.setup\t\t\t= mlxsw_sp_fid_8021d_setup,\n\t.configure\t\t= mlxsw_sp_fid_8021d_configure,\n\t.deconfigure\t\t= mlxsw_sp_fid_8021d_deconfigure,\n\t.index_alloc\t\t= mlxsw_sp_fid_8021d_index_alloc,\n\t.compare\t\t= mlxsw_sp_fid_8021d_compare,\n\t.port_vid_map\t\t= mlxsw_sp_fid_8021d_port_vid_map,\n\t.port_vid_unmap\t\t= mlxsw_sp_fid_8021d_port_vid_unmap,\n\t.vni_set\t\t= mlxsw_sp_fid_8021d_vni_set,\n\t.vni_clear\t\t= mlxsw_sp_fid_8021d_vni_clear,\n\t.nve_flood_index_set\t= mlxsw_sp_fid_8021d_nve_flood_index_set,\n\t.nve_flood_index_clear\t= mlxsw_sp_fid_8021d_nve_flood_index_clear,\n\t.fdb_clear_offload\t= mlxsw_sp_fid_8021d_fdb_clear_offload,\n\t.vid_to_fid_rif_update  = mlxsw_sp_fid_8021d_vid_to_fid_rif_update,\n};\n\n#define MLXSW_SP_FID_8021Q_MAX (VLAN_N_VID - 2)\n#define MLXSW_SP_FID_RFID_MAX (11 * 1024)\n#define MLXSW_SP_FID_8021Q_PGT_BASE 0\n#define MLXSW_SP_FID_8021D_PGT_BASE (3 * MLXSW_SP_FID_8021Q_MAX)\n\nstatic const struct mlxsw_sp_flood_table mlxsw_sp_fid_8021d_flood_tables[] = {\n\t{\n\t\t.packet_type\t= MLXSW_SP_FLOOD_TYPE_UC,\n\t\t.table_type\t= MLXSW_REG_SFGC_TABLE_TYPE_FID_OFFSET,\n\t\t.table_index\t= 0,\n\t},\n\t{\n\t\t.packet_type\t= MLXSW_SP_FLOOD_TYPE_MC,\n\t\t.table_type\t= MLXSW_REG_SFGC_TABLE_TYPE_FID_OFFSET,\n\t\t.table_index\t= 1,\n\t},\n\t{\n\t\t.packet_type\t= MLXSW_SP_FLOOD_TYPE_BC,\n\t\t.table_type\t= MLXSW_REG_SFGC_TABLE_TYPE_FID_OFFSET,\n\t\t.table_index\t= 2,\n\t},\n};\n\nstatic bool\nmlxsw_sp_fid_8021q_compare(const struct mlxsw_sp_fid *fid, const void *arg)\n{\n\tu16 vid = *(u16 *) arg;\n\n\treturn mlxsw_sp_fid_8021q_fid(fid)->vid == vid;\n}\n\nstatic void\nmlxsw_sp_fid_8021q_fdb_clear_offload(const struct mlxsw_sp_fid *fid,\n\t\t\t\t     const struct net_device *nve_dev)\n{\n\tbr_fdb_clear_offload(nve_dev, mlxsw_sp_fid_8021q_vid(fid));\n}\n\nstatic void mlxsw_sp_fid_rfid_setup(struct mlxsw_sp_fid *fid, const void *arg)\n{\n\tfid->fid_offset = 0;\n}\n\nstatic int mlxsw_sp_fid_rfid_configure(struct mlxsw_sp_fid *fid)\n{\n\treturn mlxsw_sp_fid_op(fid, true);\n}\n\nstatic void mlxsw_sp_fid_rfid_deconfigure(struct mlxsw_sp_fid *fid)\n{\n\tmlxsw_sp_fid_op(fid, false);\n}\n\nstatic int mlxsw_sp_fid_rfid_index_alloc(struct mlxsw_sp_fid *fid,\n\t\t\t\t\t const void *arg, u16 *p_fid_index)\n{\n\tu16 rif_index = *(u16 *) arg;\n\n\t*p_fid_index = fid->fid_family->start_index + rif_index;\n\n\treturn 0;\n}\n\nstatic bool mlxsw_sp_fid_rfid_compare(const struct mlxsw_sp_fid *fid,\n\t\t\t\t      const void *arg)\n{\n\tu16 rif_index = *(u16 *) arg;\n\n\treturn fid->fid_index == rif_index + fid->fid_family->start_index;\n}\n\nstatic int mlxsw_sp_fid_rfid_port_vid_map(struct mlxsw_sp_fid *fid,\n\t\t\t\t\t  struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t  u16 vid)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\tint err;\n\n\terr = mlxsw_sp_fid_port_vid_list_add(fid, mlxsw_sp_port->local_port,\n\t\t\t\t\t     vid);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = __mlxsw_sp_fid_port_vid_map(fid, mlxsw_sp_port->local_port, vid,\n\t\t\t\t\t  true);\n\tif (err)\n\t\tgoto err_port_vid_map;\n\n\tif (fid->rif) {\n\t\terr = mlxsw_sp_fid_erif_eport_to_vid_map_one(fid, local_port,\n\t\t\t\t\t\t\t     vid, true);\n\t\tif (err)\n\t\t\tgoto err_erif_eport_to_vid_map_one;\n\t}\n\n\tif (mlxsw_sp->fid_core->port_fid_mappings[local_port]++ == 0) {\n\t\terr = mlxsw_sp_port_vp_mode_trans(mlxsw_sp_port);\n\t\tif (err)\n\t\t\tgoto err_port_vp_mode_trans;\n\t}\n\n\treturn 0;\n\nerr_port_vp_mode_trans:\n\tmlxsw_sp->fid_core->port_fid_mappings[local_port]--;\n\tif (fid->rif)\n\t\tmlxsw_sp_fid_erif_eport_to_vid_map_one(fid, local_port, vid,\n\t\t\t\t\t\t       false);\nerr_erif_eport_to_vid_map_one:\n\t__mlxsw_sp_fid_port_vid_map(fid, mlxsw_sp_port->local_port, vid, false);\nerr_port_vid_map:\n\tmlxsw_sp_fid_port_vid_list_del(fid, mlxsw_sp_port->local_port, vid);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_fid_rfid_port_vid_unmap(struct mlxsw_sp_fid *fid,\n\t\t\t\t struct mlxsw_sp_port *mlxsw_sp_port, u16 vid)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\n\tif (mlxsw_sp->fid_core->port_fid_mappings[local_port] == 1)\n\t\tmlxsw_sp_port_vlan_mode_trans(mlxsw_sp_port);\n\tmlxsw_sp->fid_core->port_fid_mappings[local_port]--;\n\n\tif (fid->rif)\n\t\tmlxsw_sp_fid_erif_eport_to_vid_map_one(fid, local_port, vid,\n\t\t\t\t\t\t       false);\n\t__mlxsw_sp_fid_port_vid_map(fid, mlxsw_sp_port->local_port, vid, false);\n\tmlxsw_sp_fid_port_vid_list_del(fid, mlxsw_sp_port->local_port, vid);\n}\n\nstatic int mlxsw_sp_fid_rfid_vni_set(struct mlxsw_sp_fid *fid)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void mlxsw_sp_fid_rfid_vni_clear(struct mlxsw_sp_fid *fid)\n{\n\tWARN_ON_ONCE(1);\n}\n\nstatic int mlxsw_sp_fid_rfid_nve_flood_index_set(struct mlxsw_sp_fid *fid)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void mlxsw_sp_fid_rfid_nve_flood_index_clear(struct mlxsw_sp_fid *fid)\n{\n\tWARN_ON_ONCE(1);\n}\n\nstatic int\nmlxsw_sp_fid_rfid_vid_to_fid_rif_update(const struct mlxsw_sp_fid *fid,\n\t\t\t\t\tconst struct mlxsw_sp_rif *rif)\n{\n\treturn 0;\n}\n\nstatic const struct mlxsw_sp_fid_ops mlxsw_sp_fid_rfid_ops = {\n\t.setup\t\t\t= mlxsw_sp_fid_rfid_setup,\n\t.configure\t\t= mlxsw_sp_fid_rfid_configure,\n\t.deconfigure\t\t= mlxsw_sp_fid_rfid_deconfigure,\n\t.index_alloc\t\t= mlxsw_sp_fid_rfid_index_alloc,\n\t.compare\t\t= mlxsw_sp_fid_rfid_compare,\n\t.port_vid_map\t\t= mlxsw_sp_fid_rfid_port_vid_map,\n\t.port_vid_unmap\t\t= mlxsw_sp_fid_rfid_port_vid_unmap,\n\t.vni_set                = mlxsw_sp_fid_rfid_vni_set,\n\t.vni_clear\t\t= mlxsw_sp_fid_rfid_vni_clear,\n\t.nve_flood_index_set\t= mlxsw_sp_fid_rfid_nve_flood_index_set,\n\t.nve_flood_index_clear\t= mlxsw_sp_fid_rfid_nve_flood_index_clear,\n\t.vid_to_fid_rif_update  = mlxsw_sp_fid_rfid_vid_to_fid_rif_update,\n};\n\nstatic void mlxsw_sp_fid_dummy_setup(struct mlxsw_sp_fid *fid, const void *arg)\n{\n\tfid->fid_offset = 0;\n}\n\nstatic int mlxsw_sp_fid_dummy_configure(struct mlxsw_sp_fid *fid)\n{\n\treturn mlxsw_sp_fid_op(fid, true);\n}\n\nstatic void mlxsw_sp_fid_dummy_deconfigure(struct mlxsw_sp_fid *fid)\n{\n\tmlxsw_sp_fid_op(fid, false);\n}\n\nstatic int mlxsw_sp_fid_dummy_index_alloc(struct mlxsw_sp_fid *fid,\n\t\t\t\t\t  const void *arg, u16 *p_fid_index)\n{\n\t*p_fid_index = fid->fid_family->start_index;\n\n\treturn 0;\n}\n\nstatic bool mlxsw_sp_fid_dummy_compare(const struct mlxsw_sp_fid *fid,\n\t\t\t\t       const void *arg)\n{\n\treturn true;\n}\n\nstatic int mlxsw_sp_fid_dummy_vni_set(struct mlxsw_sp_fid *fid)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void mlxsw_sp_fid_dummy_vni_clear(struct mlxsw_sp_fid *fid)\n{\n\tWARN_ON_ONCE(1);\n}\n\nstatic int mlxsw_sp_fid_dummy_nve_flood_index_set(struct mlxsw_sp_fid *fid)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void mlxsw_sp_fid_dummy_nve_flood_index_clear(struct mlxsw_sp_fid *fid)\n{\n\tWARN_ON_ONCE(1);\n}\n\nstatic const struct mlxsw_sp_fid_ops mlxsw_sp_fid_dummy_ops = {\n\t.setup\t\t\t= mlxsw_sp_fid_dummy_setup,\n\t.configure\t\t= mlxsw_sp_fid_dummy_configure,\n\t.deconfigure\t\t= mlxsw_sp_fid_dummy_deconfigure,\n\t.index_alloc\t\t= mlxsw_sp_fid_dummy_index_alloc,\n\t.compare\t\t= mlxsw_sp_fid_dummy_compare,\n\t.vni_set                = mlxsw_sp_fid_dummy_vni_set,\n\t.vni_clear\t\t= mlxsw_sp_fid_dummy_vni_clear,\n\t.nve_flood_index_set\t= mlxsw_sp_fid_dummy_nve_flood_index_set,\n\t.nve_flood_index_clear\t= mlxsw_sp_fid_dummy_nve_flood_index_clear,\n};\n\nstatic int mlxsw_sp_fid_8021q_configure(struct mlxsw_sp_fid *fid)\n{\n\tstruct mlxsw_sp_fid_8021q *fid_8021q = mlxsw_sp_fid_8021q_fid(fid);\n\tint err;\n\n\terr = mlxsw_sp_fid_op(fid, true);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_fid_vid_to_fid_map(fid, fid_8021q->vid, true, fid->rif);\n\tif (err)\n\t\tgoto err_vid_to_fid_map;\n\n\treturn 0;\n\nerr_vid_to_fid_map:\n\tmlxsw_sp_fid_op(fid, false);\n\treturn err;\n}\n\nstatic void mlxsw_sp_fid_8021q_deconfigure(struct mlxsw_sp_fid *fid)\n{\n\tstruct mlxsw_sp_fid_8021q *fid_8021q = mlxsw_sp_fid_8021q_fid(fid);\n\n\tif (fid->vni_valid)\n\t\tmlxsw_sp_nve_fid_disable(fid->fid_family->mlxsw_sp, fid);\n\n\tmlxsw_sp_fid_vid_to_fid_map(fid, fid_8021q->vid, false, NULL);\n\tmlxsw_sp_fid_op(fid, false);\n}\n\nstatic int mlxsw_sp_fid_8021q_port_vid_map(struct mlxsw_sp_fid *fid,\n\t\t\t\t\t   struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t   u16 vid)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\tint err;\n\n\t \n\tif (mlxsw_sp->fid_core->port_fid_mappings[local_port]) {\n\t\terr =  __mlxsw_sp_fid_port_vid_map(fid, local_port, vid, true);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = mlxsw_sp_fid_evid_map(fid, local_port, vid, true);\n\tif (err)\n\t\tgoto err_fid_evid_map;\n\n\terr = mlxsw_sp_fid_port_vid_list_add(fid, mlxsw_sp_port->local_port,\n\t\t\t\t\t     vid);\n\tif (err)\n\t\tgoto err_port_vid_list_add;\n\n\treturn 0;\n\nerr_port_vid_list_add:\n\t mlxsw_sp_fid_evid_map(fid, local_port, vid, false);\nerr_fid_evid_map:\n\tif (mlxsw_sp->fid_core->port_fid_mappings[local_port])\n\t\t__mlxsw_sp_fid_port_vid_map(fid, local_port, vid, false);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_fid_8021q_port_vid_unmap(struct mlxsw_sp_fid *fid,\n\t\t\t\t  struct mlxsw_sp_port *mlxsw_sp_port, u16 vid)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\n\tmlxsw_sp_fid_port_vid_list_del(fid, mlxsw_sp_port->local_port, vid);\n\tmlxsw_sp_fid_evid_map(fid, local_port, vid, false);\n\tif (mlxsw_sp->fid_core->port_fid_mappings[local_port])\n\t\t__mlxsw_sp_fid_port_vid_map(fid, local_port, vid, false);\n}\n\nstatic const struct mlxsw_sp_fid_ops mlxsw_sp_fid_8021q_ops = {\n\t.setup\t\t\t= mlxsw_sp_fid_8021q_setup,\n\t.configure\t\t= mlxsw_sp_fid_8021q_configure,\n\t.deconfigure\t\t= mlxsw_sp_fid_8021q_deconfigure,\n\t.index_alloc\t\t= mlxsw_sp_fid_8021d_index_alloc,\n\t.compare\t\t= mlxsw_sp_fid_8021q_compare,\n\t.port_vid_map\t\t= mlxsw_sp_fid_8021q_port_vid_map,\n\t.port_vid_unmap\t\t= mlxsw_sp_fid_8021q_port_vid_unmap,\n\t.vni_set\t\t= mlxsw_sp_fid_8021d_vni_set,\n\t.vni_clear\t\t= mlxsw_sp_fid_8021d_vni_clear,\n\t.nve_flood_index_set\t= mlxsw_sp_fid_8021d_nve_flood_index_set,\n\t.nve_flood_index_clear\t= mlxsw_sp_fid_8021d_nve_flood_index_clear,\n\t.fdb_clear_offload\t= mlxsw_sp_fid_8021q_fdb_clear_offload,\n\t.vid_to_fid_rif_update  = mlxsw_sp_fid_8021q_vid_to_fid_rif_update,\n};\n\n \n#define MLXSW_SP_FID_8021Q_START\t1  \n#define MLXSW_SP_FID_8021Q_END\t\t(MLXSW_SP_FID_8021Q_START + \\\n\t\t\t\t\t MLXSW_SP_FID_8021Q_MAX - 1)\n\n \n#define MLXSW_SP_FID_8021D_START\t(MLXSW_SP_FID_8021Q_END + 1)\n#define MLXSW_SP_FID_8021D_END\t\t(MLXSW_SP_FID_8021D_START + \\\n\t\t\t\t\t MLXSW_SP_FID_8021D_MAX - 1)\n\n \n#define MLXSW_SP_FID_DUMMY\t\t(MLXSW_SP_FID_8021D_END + 1)\n\n \n#define MLXSW_SP_RFID_START\t\t(MLXSW_SP_FID_DUMMY + 1)\n#define MLXSW_SP_RFID_END\t\t(MLXSW_SP_RFID_START + \\\n\t\t\t\t\t MLXSW_SP_FID_RFID_MAX - 1)\n\nstatic const struct mlxsw_sp_fid_family mlxsw_sp1_fid_8021q_family = {\n\t.type\t\t\t= MLXSW_SP_FID_TYPE_8021Q,\n\t.fid_size\t\t= sizeof(struct mlxsw_sp_fid_8021q),\n\t.start_index\t\t= MLXSW_SP_FID_8021Q_START,\n\t.end_index\t\t= MLXSW_SP_FID_8021Q_END,\n\t.flood_tables\t\t= mlxsw_sp_fid_8021d_flood_tables,\n\t.nr_flood_tables\t= ARRAY_SIZE(mlxsw_sp_fid_8021d_flood_tables),\n\t.rif_type\t\t= MLXSW_SP_RIF_TYPE_VLAN,\n\t.ops\t\t\t= &mlxsw_sp_fid_8021q_ops,\n\t.flood_rsp              = false,\n\t.bridge_type            = MLXSW_REG_BRIDGE_TYPE_0,\n\t.pgt_base\t\t= MLXSW_SP_FID_8021Q_PGT_BASE,\n\t.smpe_index_valid\t= false,\n};\n\nstatic const struct mlxsw_sp_fid_family mlxsw_sp1_fid_8021d_family = {\n\t.type\t\t\t= MLXSW_SP_FID_TYPE_8021D,\n\t.fid_size\t\t= sizeof(struct mlxsw_sp_fid_8021d),\n\t.start_index\t\t= MLXSW_SP_FID_8021D_START,\n\t.end_index\t\t= MLXSW_SP_FID_8021D_END,\n\t.flood_tables\t\t= mlxsw_sp_fid_8021d_flood_tables,\n\t.nr_flood_tables\t= ARRAY_SIZE(mlxsw_sp_fid_8021d_flood_tables),\n\t.rif_type\t\t= MLXSW_SP_RIF_TYPE_FID,\n\t.ops\t\t\t= &mlxsw_sp_fid_8021d_ops,\n\t.bridge_type            = MLXSW_REG_BRIDGE_TYPE_1,\n\t.pgt_base\t\t= MLXSW_SP_FID_8021D_PGT_BASE,\n\t.smpe_index_valid       = false,\n};\n\nstatic const struct mlxsw_sp_fid_family mlxsw_sp1_fid_dummy_family = {\n\t.type\t\t\t= MLXSW_SP_FID_TYPE_DUMMY,\n\t.fid_size\t\t= sizeof(struct mlxsw_sp_fid),\n\t.start_index\t\t= MLXSW_SP_FID_DUMMY,\n\t.end_index\t\t= MLXSW_SP_FID_DUMMY,\n\t.ops\t\t\t= &mlxsw_sp_fid_dummy_ops,\n\t.smpe_index_valid       = false,\n};\n\nstatic const struct mlxsw_sp_fid_family mlxsw_sp_fid_rfid_family = {\n\t.type\t\t\t= MLXSW_SP_FID_TYPE_RFID,\n\t.fid_size\t\t= sizeof(struct mlxsw_sp_fid),\n\t.start_index\t\t= MLXSW_SP_RFID_START,\n\t.end_index\t\t= MLXSW_SP_RFID_END,\n\t.rif_type\t\t= MLXSW_SP_RIF_TYPE_SUBPORT,\n\t.ops\t\t\t= &mlxsw_sp_fid_rfid_ops,\n\t.flood_rsp              = true,\n\t.smpe_index_valid       = false,\n};\n\nconst struct mlxsw_sp_fid_family *mlxsw_sp1_fid_family_arr[] = {\n\t[MLXSW_SP_FID_TYPE_8021Q]\t= &mlxsw_sp1_fid_8021q_family,\n\t[MLXSW_SP_FID_TYPE_8021D]\t= &mlxsw_sp1_fid_8021d_family,\n\t[MLXSW_SP_FID_TYPE_DUMMY]\t= &mlxsw_sp1_fid_dummy_family,\n\t[MLXSW_SP_FID_TYPE_RFID]\t= &mlxsw_sp_fid_rfid_family,\n};\n\nstatic const struct mlxsw_sp_fid_family mlxsw_sp2_fid_8021q_family = {\n\t.type\t\t\t= MLXSW_SP_FID_TYPE_8021Q,\n\t.fid_size\t\t= sizeof(struct mlxsw_sp_fid_8021q),\n\t.start_index\t\t= MLXSW_SP_FID_8021Q_START,\n\t.end_index\t\t= MLXSW_SP_FID_8021Q_END,\n\t.flood_tables\t\t= mlxsw_sp_fid_8021d_flood_tables,\n\t.nr_flood_tables\t= ARRAY_SIZE(mlxsw_sp_fid_8021d_flood_tables),\n\t.rif_type\t\t= MLXSW_SP_RIF_TYPE_VLAN,\n\t.ops\t\t\t= &mlxsw_sp_fid_8021q_ops,\n\t.flood_rsp              = false,\n\t.bridge_type            = MLXSW_REG_BRIDGE_TYPE_0,\n\t.pgt_base\t\t= MLXSW_SP_FID_8021Q_PGT_BASE,\n\t.smpe_index_valid\t= true,\n};\n\nstatic const struct mlxsw_sp_fid_family mlxsw_sp2_fid_8021d_family = {\n\t.type\t\t\t= MLXSW_SP_FID_TYPE_8021D,\n\t.fid_size\t\t= sizeof(struct mlxsw_sp_fid_8021d),\n\t.start_index\t\t= MLXSW_SP_FID_8021D_START,\n\t.end_index\t\t= MLXSW_SP_FID_8021D_END,\n\t.flood_tables\t\t= mlxsw_sp_fid_8021d_flood_tables,\n\t.nr_flood_tables\t= ARRAY_SIZE(mlxsw_sp_fid_8021d_flood_tables),\n\t.rif_type\t\t= MLXSW_SP_RIF_TYPE_FID,\n\t.ops\t\t\t= &mlxsw_sp_fid_8021d_ops,\n\t.bridge_type            = MLXSW_REG_BRIDGE_TYPE_1,\n\t.pgt_base\t\t= MLXSW_SP_FID_8021D_PGT_BASE,\n\t.smpe_index_valid       = true,\n};\n\nstatic const struct mlxsw_sp_fid_family mlxsw_sp2_fid_dummy_family = {\n\t.type\t\t\t= MLXSW_SP_FID_TYPE_DUMMY,\n\t.fid_size\t\t= sizeof(struct mlxsw_sp_fid),\n\t.start_index\t\t= MLXSW_SP_FID_DUMMY,\n\t.end_index\t\t= MLXSW_SP_FID_DUMMY,\n\t.ops\t\t\t= &mlxsw_sp_fid_dummy_ops,\n\t.smpe_index_valid       = false,\n};\n\nconst struct mlxsw_sp_fid_family *mlxsw_sp2_fid_family_arr[] = {\n\t[MLXSW_SP_FID_TYPE_8021Q]\t= &mlxsw_sp2_fid_8021q_family,\n\t[MLXSW_SP_FID_TYPE_8021D]\t= &mlxsw_sp2_fid_8021d_family,\n\t[MLXSW_SP_FID_TYPE_DUMMY]\t= &mlxsw_sp2_fid_dummy_family,\n\t[MLXSW_SP_FID_TYPE_RFID]\t= &mlxsw_sp_fid_rfid_family,\n};\n\nstatic struct mlxsw_sp_fid *mlxsw_sp_fid_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tenum mlxsw_sp_fid_type type,\n\t\t\t\t\t\tconst void *arg)\n{\n\tstruct mlxsw_sp_fid_family *fid_family;\n\tstruct mlxsw_sp_fid *fid;\n\n\tfid_family = mlxsw_sp->fid_core->fid_family_arr[type];\n\tlist_for_each_entry(fid, &fid_family->fids_list, list) {\n\t\tif (!fid->fid_family->ops->compare(fid, arg))\n\t\t\tcontinue;\n\t\trefcount_inc(&fid->ref_count);\n\t\treturn fid;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mlxsw_sp_fid *mlxsw_sp_fid_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t     enum mlxsw_sp_fid_type type,\n\t\t\t\t\t     const void *arg)\n{\n\tstruct mlxsw_sp_fid_family *fid_family;\n\tstruct mlxsw_sp_fid *fid;\n\tu16 fid_index;\n\tint err;\n\n\tfid = mlxsw_sp_fid_lookup(mlxsw_sp, type, arg);\n\tif (fid)\n\t\treturn fid;\n\n\tfid_family = mlxsw_sp->fid_core->fid_family_arr[type];\n\tfid = kzalloc(fid_family->fid_size, GFP_KERNEL);\n\tif (!fid)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&fid->port_vid_list);\n\tfid->fid_family = fid_family;\n\n\terr = fid->fid_family->ops->index_alloc(fid, arg, &fid_index);\n\tif (err)\n\t\tgoto err_index_alloc;\n\tfid->fid_index = fid_index;\n\t__set_bit(fid_index - fid_family->start_index, fid_family->fids_bitmap);\n\n\tfid->fid_family->ops->setup(fid, arg);\n\n\terr = fid->fid_family->ops->configure(fid);\n\tif (err)\n\t\tgoto err_configure;\n\n\terr = rhashtable_insert_fast(&mlxsw_sp->fid_core->fid_ht, &fid->ht_node,\n\t\t\t\t     mlxsw_sp_fid_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_insert;\n\n\tlist_add(&fid->list, &fid_family->fids_list);\n\trefcount_set(&fid->ref_count, 1);\n\treturn fid;\n\nerr_rhashtable_insert:\n\tfid->fid_family->ops->deconfigure(fid);\nerr_configure:\n\t__clear_bit(fid_index - fid_family->start_index,\n\t\t    fid_family->fids_bitmap);\nerr_index_alloc:\n\tkfree(fid);\n\treturn ERR_PTR(err);\n}\n\nvoid mlxsw_sp_fid_put(struct mlxsw_sp_fid *fid)\n{\n\tstruct mlxsw_sp_fid_family *fid_family = fid->fid_family;\n\tstruct mlxsw_sp *mlxsw_sp = fid_family->mlxsw_sp;\n\n\tif (!refcount_dec_and_test(&fid->ref_count))\n\t\treturn;\n\n\tlist_del(&fid->list);\n\trhashtable_remove_fast(&mlxsw_sp->fid_core->fid_ht,\n\t\t\t       &fid->ht_node, mlxsw_sp_fid_ht_params);\n\tfid->fid_family->ops->deconfigure(fid);\n\t__clear_bit(fid->fid_index - fid_family->start_index,\n\t\t    fid_family->fids_bitmap);\n\tWARN_ON_ONCE(!list_empty(&fid->port_vid_list));\n\tkfree(fid);\n}\n\nstruct mlxsw_sp_fid *mlxsw_sp_fid_8021q_get(struct mlxsw_sp *mlxsw_sp, u16 vid)\n{\n\treturn mlxsw_sp_fid_get(mlxsw_sp, MLXSW_SP_FID_TYPE_8021Q, &vid);\n}\n\nstruct mlxsw_sp_fid *mlxsw_sp_fid_8021d_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    int br_ifindex)\n{\n\treturn mlxsw_sp_fid_get(mlxsw_sp, MLXSW_SP_FID_TYPE_8021D, &br_ifindex);\n}\n\nstruct mlxsw_sp_fid *mlxsw_sp_fid_8021q_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t       u16 vid)\n{\n\treturn mlxsw_sp_fid_lookup(mlxsw_sp, MLXSW_SP_FID_TYPE_8021Q, &vid);\n}\n\nstruct mlxsw_sp_fid *mlxsw_sp_fid_8021d_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t       int br_ifindex)\n{\n\treturn mlxsw_sp_fid_lookup(mlxsw_sp, MLXSW_SP_FID_TYPE_8021D,\n\t\t\t\t   &br_ifindex);\n}\n\nstruct mlxsw_sp_fid *mlxsw_sp_fid_rfid_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   u16 rif_index)\n{\n\treturn mlxsw_sp_fid_get(mlxsw_sp, MLXSW_SP_FID_TYPE_RFID, &rif_index);\n}\n\nstruct mlxsw_sp_fid *mlxsw_sp_fid_dummy_get(struct mlxsw_sp *mlxsw_sp)\n{\n\treturn mlxsw_sp_fid_get(mlxsw_sp, MLXSW_SP_FID_TYPE_DUMMY, NULL);\n}\n\nstatic int\nmlxsw_sp_fid_flood_table_init(struct mlxsw_sp_fid_family *fid_family,\n\t\t\t      const struct mlxsw_sp_flood_table *flood_table)\n{\n\tenum mlxsw_sp_flood_type packet_type = flood_table->packet_type;\n\tstruct mlxsw_sp *mlxsw_sp = fid_family->mlxsw_sp;\n\tconst int *sfgc_packet_types;\n\tu16 num_fids, mid_base;\n\tint err, i;\n\n\tmid_base = mlxsw_sp_fid_flood_table_mid(fid_family, flood_table, 0);\n\tnum_fids = mlxsw_sp_fid_family_num_fids(fid_family);\n\terr = mlxsw_sp_pgt_mid_alloc_range(mlxsw_sp, mid_base, num_fids);\n\tif (err)\n\t\treturn err;\n\n\tsfgc_packet_types = mlxsw_sp_packet_type_sfgc_types[packet_type];\n\tfor (i = 0; i < MLXSW_REG_SFGC_TYPE_MAX; i++) {\n\t\tchar sfgc_pl[MLXSW_REG_SFGC_LEN];\n\n\t\tif (!sfgc_packet_types[i])\n\t\t\tcontinue;\n\n\t\tmlxsw_reg_sfgc_pack(sfgc_pl, i, fid_family->bridge_type,\n\t\t\t\t    flood_table->table_type, 0, mid_base);\n\n\t\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfgc), sfgc_pl);\n\t\tif (err)\n\t\t\tgoto err_reg_write;\n\t}\n\n\treturn 0;\n\nerr_reg_write:\n\tmlxsw_sp_pgt_mid_free_range(mlxsw_sp, mid_base, num_fids);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_fid_flood_table_fini(struct mlxsw_sp_fid_family *fid_family,\n\t\t\t      const struct mlxsw_sp_flood_table *flood_table)\n{\n\tstruct mlxsw_sp *mlxsw_sp = fid_family->mlxsw_sp;\n\tu16 num_fids, mid_base;\n\n\tmid_base = mlxsw_sp_fid_flood_table_mid(fid_family, flood_table, 0);\n\tnum_fids = mlxsw_sp_fid_family_num_fids(fid_family);\n\tmlxsw_sp_pgt_mid_free_range(mlxsw_sp, mid_base, num_fids);\n}\n\nstatic int\nmlxsw_sp_fid_flood_tables_init(struct mlxsw_sp_fid_family *fid_family)\n{\n\tint i;\n\n\tfor (i = 0; i < fid_family->nr_flood_tables; i++) {\n\t\tconst struct mlxsw_sp_flood_table *flood_table;\n\t\tint err;\n\n\t\tflood_table = &fid_family->flood_tables[i];\n\t\terr = mlxsw_sp_fid_flood_table_init(fid_family, flood_table);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_fid_flood_tables_fini(struct mlxsw_sp_fid_family *fid_family)\n{\n\tint i;\n\n\tfor (i = 0; i < fid_family->nr_flood_tables; i++) {\n\t\tconst struct mlxsw_sp_flood_table *flood_table;\n\n\t\tflood_table = &fid_family->flood_tables[i];\n\t\tmlxsw_sp_fid_flood_table_fini(fid_family, flood_table);\n\t}\n}\n\nstatic int mlxsw_sp_fid_family_register(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tconst struct mlxsw_sp_fid_family *tmpl)\n{\n\tu16 nr_fids = tmpl->end_index - tmpl->start_index + 1;\n\tstruct mlxsw_sp_fid_family *fid_family;\n\tint err;\n\n\tfid_family = kmemdup(tmpl, sizeof(*fid_family), GFP_KERNEL);\n\tif (!fid_family)\n\t\treturn -ENOMEM;\n\n\tfid_family->mlxsw_sp = mlxsw_sp;\n\tINIT_LIST_HEAD(&fid_family->fids_list);\n\tfid_family->fids_bitmap = bitmap_zalloc(nr_fids, GFP_KERNEL);\n\tif (!fid_family->fids_bitmap) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_fids_bitmap;\n\t}\n\n\tif (fid_family->flood_tables) {\n\t\terr = mlxsw_sp_fid_flood_tables_init(fid_family);\n\t\tif (err)\n\t\t\tgoto err_fid_flood_tables_init;\n\t}\n\n\tmlxsw_sp->fid_core->fid_family_arr[tmpl->type] = fid_family;\n\n\treturn 0;\n\nerr_fid_flood_tables_init:\n\tbitmap_free(fid_family->fids_bitmap);\nerr_alloc_fids_bitmap:\n\tkfree(fid_family);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_fid_family_unregister(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_fid_family *fid_family)\n{\n\tmlxsw_sp->fid_core->fid_family_arr[fid_family->type] = NULL;\n\n\tif (fid_family->flood_tables)\n\t\tmlxsw_sp_fid_flood_tables_fini(fid_family);\n\n\tbitmap_free(fid_family->fids_bitmap);\n\tWARN_ON_ONCE(!list_empty(&fid_family->fids_list));\n\tkfree(fid_family);\n}\n\nint mlxsw_sp_port_fids_init(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\n\t \n\tmlxsw_sp->fid_core->port_fid_mappings[mlxsw_sp_port->local_port] = 0;\n\n\treturn mlxsw_sp_port_vp_mode_set(mlxsw_sp_port, false);\n}\n\nvoid mlxsw_sp_port_fids_fini(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\n\tmlxsw_sp->fid_core->port_fid_mappings[mlxsw_sp_port->local_port] = 0;\n}\n\nint mlxsw_sp_fids_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tunsigned int max_ports = mlxsw_core_max_ports(mlxsw_sp->core);\n\tstruct mlxsw_sp_fid_core *fid_core;\n\tint err, i;\n\n\tfid_core = kzalloc(sizeof(*mlxsw_sp->fid_core), GFP_KERNEL);\n\tif (!fid_core)\n\t\treturn -ENOMEM;\n\tmlxsw_sp->fid_core = fid_core;\n\n\terr = rhashtable_init(&fid_core->fid_ht, &mlxsw_sp_fid_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_fid_init;\n\n\terr = rhashtable_init(&fid_core->vni_ht, &mlxsw_sp_fid_vni_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_vni_init;\n\n\tfid_core->port_fid_mappings = kcalloc(max_ports, sizeof(unsigned int),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!fid_core->port_fid_mappings) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_port_fid_mappings;\n\t}\n\n\tfor (i = 0; i < MLXSW_SP_FID_TYPE_MAX; i++) {\n\t\terr = mlxsw_sp_fid_family_register(mlxsw_sp,\n\t\t\t\t\t\t   mlxsw_sp->fid_family_arr[i]);\n\n\t\tif (err)\n\t\t\tgoto err_fid_ops_register;\n\t}\n\n\treturn 0;\n\nerr_fid_ops_register:\n\tfor (i--; i >= 0; i--) {\n\t\tstruct mlxsw_sp_fid_family *fid_family;\n\n\t\tfid_family = fid_core->fid_family_arr[i];\n\t\tmlxsw_sp_fid_family_unregister(mlxsw_sp, fid_family);\n\t}\n\tkfree(fid_core->port_fid_mappings);\nerr_alloc_port_fid_mappings:\n\trhashtable_destroy(&fid_core->vni_ht);\nerr_rhashtable_vni_init:\n\trhashtable_destroy(&fid_core->fid_ht);\nerr_rhashtable_fid_init:\n\tkfree(fid_core);\n\treturn err;\n}\n\nvoid mlxsw_sp_fids_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_fid_core *fid_core = mlxsw_sp->fid_core;\n\tint i;\n\n\tfor (i = 0; i < MLXSW_SP_FID_TYPE_MAX; i++)\n\t\tmlxsw_sp_fid_family_unregister(mlxsw_sp,\n\t\t\t\t\t       fid_core->fid_family_arr[i]);\n\tkfree(fid_core->port_fid_mappings);\n\trhashtable_destroy(&fid_core->vni_ht);\n\trhashtable_destroy(&fid_core->fid_ht);\n\tkfree(fid_core);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}