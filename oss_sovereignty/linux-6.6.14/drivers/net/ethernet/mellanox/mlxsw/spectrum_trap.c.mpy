{
  "module_name": "spectrum_trap.c",
  "hash_id": "85b2226d9c49be2c089c6dc64518be3ead6df2a097744feb1cc388437d28f131",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/netlink.h>\n#include <net/devlink.h>\n#include <uapi/linux/devlink.h>\n\n#include \"core.h\"\n#include \"reg.h\"\n#include \"spectrum.h\"\n#include \"spectrum_trap.h\"\n\nstruct mlxsw_sp_trap_policer_item {\n\tstruct devlink_trap_policer policer;\n\tu16 hw_id;\n};\n\nstruct mlxsw_sp_trap_group_item {\n\tstruct devlink_trap_group group;\n\tu16 hw_group_id;\n\tu8 priority;\n\tu8 fixed_policer:1;  \n};\n\n#define MLXSW_SP_TRAP_LISTENERS_MAX 3\n\nstruct mlxsw_sp_trap_item {\n\tstruct devlink_trap trap;\n\tstruct mlxsw_listener listeners_arr[MLXSW_SP_TRAP_LISTENERS_MAX];\n\tu8 is_source:1;\n};\n\n \nenum {\n\tDEVLINK_MLXSW_TRAP_ID_BASE = DEVLINK_TRAP_GENERIC_ID_MAX,\n\tDEVLINK_MLXSW_TRAP_ID_IRIF_DISABLED,\n\tDEVLINK_MLXSW_TRAP_ID_ERIF_DISABLED,\n};\n\n#define DEVLINK_MLXSW_TRAP_NAME_IRIF_DISABLED \\\n\t\"irif_disabled\"\n#define DEVLINK_MLXSW_TRAP_NAME_ERIF_DISABLED \\\n\t\"erif_disabled\"\n\n#define MLXSW_SP_TRAP_METADATA DEVLINK_TRAP_METADATA_TYPE_F_IN_PORT\n\nenum {\n\t \n\tMLXSW_SP_MIRROR_REASON_INGRESS = 1,\n\t \n\tMLXSW_SP_MIRROR_REASON_POLICY_ENGINE = 2,\n\t \n\tMLXSW_SP_MIRROR_REASON_INGRESS_WRED = 9,\n\t \n\tMLXSW_SP_MIRROR_REASON_EGRESS = 14,\n};\n\nstatic int mlxsw_sp_rx_listener(struct mlxsw_sp *mlxsw_sp, struct sk_buff *skb,\n\t\t\t\tu16 local_port,\n\t\t\t\tstruct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp_port_pcpu_stats *pcpu_stats;\n\n\tif (unlikely(!mlxsw_sp_port)) {\n\t\tdev_warn_ratelimited(mlxsw_sp->bus_info->dev, \"Port %d: skb received for non-existent port\\n\",\n\t\t\t\t     local_port);\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tskb->dev = mlxsw_sp_port->dev;\n\n\tpcpu_stats = this_cpu_ptr(mlxsw_sp_port->pcpu_stats);\n\tu64_stats_update_begin(&pcpu_stats->syncp);\n\tpcpu_stats->rx_packets++;\n\tpcpu_stats->rx_bytes += skb->len;\n\tu64_stats_update_end(&pcpu_stats->syncp);\n\n\tskb->protocol = eth_type_trans(skb, skb->dev);\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_rx_drop_listener(struct sk_buff *skb, u16 local_port,\n\t\t\t\t      void *trap_ctx)\n{\n\tstruct devlink_port *in_devlink_port;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct devlink *devlink;\n\tint err;\n\n\tmlxsw_sp = devlink_trap_ctx_priv(trap_ctx);\n\tmlxsw_sp_port = mlxsw_sp->ports[local_port];\n\n\terr = mlxsw_sp_rx_listener(mlxsw_sp, skb, local_port, mlxsw_sp_port);\n\tif (err)\n\t\treturn;\n\n\tdevlink = priv_to_devlink(mlxsw_sp->core);\n\tin_devlink_port = mlxsw_core_port_devlink_port_get(mlxsw_sp->core,\n\t\t\t\t\t\t\t   local_port);\n\tskb_push(skb, ETH_HLEN);\n\tdevlink_trap_report(devlink, skb, trap_ctx, in_devlink_port, NULL);\n\tconsume_skb(skb);\n}\n\nstatic void mlxsw_sp_rx_acl_drop_listener(struct sk_buff *skb, u16 local_port,\n\t\t\t\t\t  void *trap_ctx)\n{\n\tu32 cookie_index = mlxsw_skb_cb(skb)->rx_md_info.cookie_index;\n\tconst struct flow_action_cookie *fa_cookie;\n\tstruct devlink_port *in_devlink_port;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct devlink *devlink;\n\tint err;\n\n\tmlxsw_sp = devlink_trap_ctx_priv(trap_ctx);\n\tmlxsw_sp_port = mlxsw_sp->ports[local_port];\n\n\terr = mlxsw_sp_rx_listener(mlxsw_sp, skb, local_port, mlxsw_sp_port);\n\tif (err)\n\t\treturn;\n\n\tdevlink = priv_to_devlink(mlxsw_sp->core);\n\tin_devlink_port = mlxsw_core_port_devlink_port_get(mlxsw_sp->core,\n\t\t\t\t\t\t\t   local_port);\n\tskb_push(skb, ETH_HLEN);\n\trcu_read_lock();\n\tfa_cookie = mlxsw_sp_acl_act_cookie_lookup(mlxsw_sp, cookie_index);\n\tdevlink_trap_report(devlink, skb, trap_ctx, in_devlink_port, fa_cookie);\n\trcu_read_unlock();\n\tconsume_skb(skb);\n}\n\nstatic int __mlxsw_sp_rx_no_mark_listener(struct sk_buff *skb, u16 local_port,\n\t\t\t\t\t  void *trap_ctx)\n{\n\tstruct devlink_port *in_devlink_port;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct devlink *devlink;\n\tint err;\n\n\tmlxsw_sp = devlink_trap_ctx_priv(trap_ctx);\n\tmlxsw_sp_port = mlxsw_sp->ports[local_port];\n\n\terr = mlxsw_sp_rx_listener(mlxsw_sp, skb, local_port, mlxsw_sp_port);\n\tif (err)\n\t\treturn err;\n\n\tdevlink = priv_to_devlink(mlxsw_sp->core);\n\tin_devlink_port = mlxsw_core_port_devlink_port_get(mlxsw_sp->core,\n\t\t\t\t\t\t\t   local_port);\n\tskb_push(skb, ETH_HLEN);\n\tdevlink_trap_report(devlink, skb, trap_ctx, in_devlink_port, NULL);\n\tskb_pull(skb, ETH_HLEN);\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_rx_no_mark_listener(struct sk_buff *skb, u16 local_port,\n\t\t\t\t\t void *trap_ctx)\n{\n\tint err;\n\n\terr = __mlxsw_sp_rx_no_mark_listener(skb, local_port, trap_ctx);\n\tif (err)\n\t\treturn;\n\n\tnetif_receive_skb(skb);\n}\n\nstatic void mlxsw_sp_rx_mark_listener(struct sk_buff *skb, u16 local_port,\n\t\t\t\t      void *trap_ctx)\n{\n\tskb->offload_fwd_mark = 1;\n\tmlxsw_sp_rx_no_mark_listener(skb, local_port, trap_ctx);\n}\n\nstatic void mlxsw_sp_rx_l3_mark_listener(struct sk_buff *skb, u16 local_port,\n\t\t\t\t\t void *trap_ctx)\n{\n\tskb->offload_l3_fwd_mark = 1;\n\tskb->offload_fwd_mark = 1;\n\tmlxsw_sp_rx_no_mark_listener(skb, local_port, trap_ctx);\n}\n\nstatic void mlxsw_sp_rx_ptp_listener(struct sk_buff *skb, u16 local_port,\n\t\t\t\t     void *trap_ctx)\n{\n\tstruct mlxsw_sp *mlxsw_sp = devlink_trap_ctx_priv(trap_ctx);\n\tint err;\n\n\terr = __mlxsw_sp_rx_no_mark_listener(skb, local_port, trap_ctx);\n\tif (err)\n\t\treturn;\n\n\t \n\tskb_push(skb, ETH_HLEN);\n\tmlxsw_sp_ptp_receive(mlxsw_sp, skb, local_port);\n}\n\nstatic struct mlxsw_sp_port *\nmlxsw_sp_sample_tx_port_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    const struct mlxsw_rx_md_info *rx_md_info)\n{\n\tu16 local_port;\n\n\tif (!rx_md_info->tx_port_valid)\n\t\treturn NULL;\n\n\tif (rx_md_info->tx_port_is_lag)\n\t\tlocal_port = mlxsw_core_lag_mapping_get(mlxsw_sp->core,\n\t\t\t\t\t\t\trx_md_info->tx_lag_id,\n\t\t\t\t\t\t\trx_md_info->tx_lag_port_index);\n\telse\n\t\tlocal_port = rx_md_info->tx_sys_port;\n\n\tif (local_port >= mlxsw_core_max_ports(mlxsw_sp->core))\n\t\treturn NULL;\n\n\treturn mlxsw_sp->ports[local_port];\n}\n\n \n#define MLXSW_SP_MIRROR_LATENCY_SHIFT\t6\n\nstatic void mlxsw_sp_psample_md_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct psample_metadata *md,\n\t\t\t\t     struct sk_buff *skb, int in_ifindex,\n\t\t\t\t     bool truncate, u32 trunc_size)\n{\n\tstruct mlxsw_rx_md_info *rx_md_info = &mlxsw_skb_cb(skb)->rx_md_info;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\n\tmd->trunc_size = truncate ? trunc_size : skb->len;\n\tmd->in_ifindex = in_ifindex;\n\tmlxsw_sp_port = mlxsw_sp_sample_tx_port_get(mlxsw_sp, rx_md_info);\n\tmd->out_ifindex = mlxsw_sp_port && mlxsw_sp_port->dev ?\n\t\t\t  mlxsw_sp_port->dev->ifindex : 0;\n\tmd->out_tc_valid = rx_md_info->tx_tc_valid;\n\tmd->out_tc = rx_md_info->tx_tc;\n\tmd->out_tc_occ_valid = rx_md_info->tx_congestion_valid;\n\tmd->out_tc_occ = rx_md_info->tx_congestion;\n\tmd->latency_valid = rx_md_info->latency_valid;\n\tmd->latency = rx_md_info->latency;\n\tmd->latency <<= MLXSW_SP_MIRROR_LATENCY_SHIFT;\n}\n\nstatic void mlxsw_sp_rx_sample_listener(struct sk_buff *skb, u16 local_port,\n\t\t\t\t\tvoid *trap_ctx)\n{\n\tstruct mlxsw_sp *mlxsw_sp = devlink_trap_ctx_priv(trap_ctx);\n\tstruct mlxsw_sp_sample_trigger trigger;\n\tstruct mlxsw_sp_sample_params *params;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tstruct psample_metadata md = {};\n\tint err;\n\n\terr = __mlxsw_sp_rx_no_mark_listener(skb, local_port, trap_ctx);\n\tif (err)\n\t\treturn;\n\n\tmlxsw_sp_port = mlxsw_sp->ports[local_port];\n\tif (!mlxsw_sp_port)\n\t\tgoto out;\n\n\ttrigger.type = MLXSW_SP_SAMPLE_TRIGGER_TYPE_INGRESS;\n\ttrigger.local_port = local_port;\n\tparams = mlxsw_sp_sample_trigger_params_lookup(mlxsw_sp, &trigger);\n\tif (!params)\n\t\tgoto out;\n\n\t \n\tskb_push(skb, ETH_HLEN);\n\tmlxsw_sp_psample_md_init(mlxsw_sp, &md, skb,\n\t\t\t\t mlxsw_sp_port->dev->ifindex, params->truncate,\n\t\t\t\t params->trunc_size);\n\tpsample_sample_packet(params->psample_group, skb, params->rate, &md);\nout:\n\tconsume_skb(skb);\n}\n\nstatic void mlxsw_sp_rx_sample_tx_listener(struct sk_buff *skb, u16 local_port,\n\t\t\t\t\t   void *trap_ctx)\n{\n\tstruct mlxsw_rx_md_info *rx_md_info = &mlxsw_skb_cb(skb)->rx_md_info;\n\tstruct mlxsw_sp *mlxsw_sp = devlink_trap_ctx_priv(trap_ctx);\n\tstruct mlxsw_sp_port *mlxsw_sp_port, *mlxsw_sp_port_tx;\n\tstruct mlxsw_sp_sample_trigger trigger;\n\tstruct mlxsw_sp_sample_params *params;\n\tstruct psample_metadata md = {};\n\tint err;\n\n\t \n\tif (local_port == MLXSW_PORT_CPU_PORT)\n\t\tgoto out;\n\n\terr = __mlxsw_sp_rx_no_mark_listener(skb, local_port, trap_ctx);\n\tif (err)\n\t\treturn;\n\n\tmlxsw_sp_port = mlxsw_sp->ports[local_port];\n\tif (!mlxsw_sp_port)\n\t\tgoto out;\n\n\t \n\tmlxsw_sp_port_tx = mlxsw_sp_sample_tx_port_get(mlxsw_sp, rx_md_info);\n\tif (!mlxsw_sp_port_tx)\n\t\tgoto out;\n\n\ttrigger.type = MLXSW_SP_SAMPLE_TRIGGER_TYPE_EGRESS;\n\ttrigger.local_port = mlxsw_sp_port_tx->local_port;\n\tparams = mlxsw_sp_sample_trigger_params_lookup(mlxsw_sp, &trigger);\n\tif (!params)\n\t\tgoto out;\n\n\t \n\tskb_push(skb, ETH_HLEN);\n\tmlxsw_sp_psample_md_init(mlxsw_sp, &md, skb,\n\t\t\t\t mlxsw_sp_port->dev->ifindex, params->truncate,\n\t\t\t\t params->trunc_size);\n\tpsample_sample_packet(params->psample_group, skb, params->rate, &md);\nout:\n\tconsume_skb(skb);\n}\n\nstatic void mlxsw_sp_rx_sample_acl_listener(struct sk_buff *skb, u16 local_port,\n\t\t\t\t\t    void *trap_ctx)\n{\n\tstruct mlxsw_sp *mlxsw_sp = devlink_trap_ctx_priv(trap_ctx);\n\tstruct mlxsw_sp_sample_trigger trigger = {\n\t\t.type = MLXSW_SP_SAMPLE_TRIGGER_TYPE_POLICY_ENGINE,\n\t};\n\tstruct mlxsw_sp_sample_params *params;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tstruct psample_metadata md = {};\n\tint err;\n\n\terr = __mlxsw_sp_rx_no_mark_listener(skb, local_port, trap_ctx);\n\tif (err)\n\t\treturn;\n\n\tmlxsw_sp_port = mlxsw_sp->ports[local_port];\n\tif (!mlxsw_sp_port)\n\t\tgoto out;\n\n\tparams = mlxsw_sp_sample_trigger_params_lookup(mlxsw_sp, &trigger);\n\tif (!params)\n\t\tgoto out;\n\n\t \n\tskb_push(skb, ETH_HLEN);\n\tmlxsw_sp_psample_md_init(mlxsw_sp, &md, skb,\n\t\t\t\t mlxsw_sp_port->dev->ifindex, params->truncate,\n\t\t\t\t params->trunc_size);\n\tpsample_sample_packet(params->psample_group, skb, params->rate, &md);\nout:\n\tconsume_skb(skb);\n}\n\n#define MLXSW_SP_TRAP_DROP(_id, _group_id)\t\t\t\t      \\\n\tDEVLINK_TRAP_GENERIC(DROP, DROP, _id,\t\t\t\t      \\\n\t\t\t     DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id,\t      \\\n\t\t\t     MLXSW_SP_TRAP_METADATA)\n\n#define MLXSW_SP_TRAP_DROP_EXT(_id, _group_id, _metadata)\t\t      \\\n\tDEVLINK_TRAP_GENERIC(DROP, DROP, _id,\t\t\t\t      \\\n\t\t\t     DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id,\t      \\\n\t\t\t     MLXSW_SP_TRAP_METADATA | (_metadata))\n\n#define MLXSW_SP_TRAP_BUFFER_DROP(_id)\t\t\t\t\t      \\\n\tDEVLINK_TRAP_GENERIC(DROP, TRAP, _id,\t\t\t\t      \\\n\t\t\t     DEVLINK_TRAP_GROUP_GENERIC_ID_BUFFER_DROPS,      \\\n\t\t\t     MLXSW_SP_TRAP_METADATA)\n\n#define MLXSW_SP_TRAP_DRIVER_DROP(_id, _group_id)\t\t\t      \\\n\tDEVLINK_TRAP_DRIVER(DROP, DROP, DEVLINK_MLXSW_TRAP_ID_##_id,\t      \\\n\t\t\t    DEVLINK_MLXSW_TRAP_NAME_##_id,\t\t      \\\n\t\t\t    DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id,\t      \\\n\t\t\t    MLXSW_SP_TRAP_METADATA)\n\n#define MLXSW_SP_TRAP_EXCEPTION(_id, _group_id)\t\t      \\\n\tDEVLINK_TRAP_GENERIC(EXCEPTION, TRAP, _id,\t\t\t      \\\n\t\t\t     DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id,\t      \\\n\t\t\t     MLXSW_SP_TRAP_METADATA)\n\n#define MLXSW_SP_TRAP_CONTROL(_id, _group_id, _action)\t\t\t      \\\n\tDEVLINK_TRAP_GENERIC(CONTROL, _action, _id,\t\t\t      \\\n\t\t\t     DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id,\t      \\\n\t\t\t     MLXSW_SP_TRAP_METADATA)\n\n#define MLXSW_SP_RXL_DISCARD(_id, _group_id)\t\t\t\t      \\\n\tMLXSW_RXL_DIS(mlxsw_sp_rx_drop_listener, DISCARD_##_id,\t\t      \\\n\t\t      TRAP_EXCEPTION_TO_CPU, false, SP_##_group_id,\t      \\\n\t\t      SET_FW_DEFAULT, SP_##_group_id)\n\n#define MLXSW_SP_RXL_ACL_DISCARD(_id, _en_group_id, _dis_group_id)\t      \\\n\tMLXSW_RXL_DIS(mlxsw_sp_rx_acl_drop_listener, DISCARD_##_id,\t      \\\n\t\t      TRAP_EXCEPTION_TO_CPU, false, SP_##_en_group_id,\t      \\\n\t\t      SET_FW_DEFAULT, SP_##_dis_group_id)\n\n#define MLXSW_SP_RXL_BUFFER_DISCARD(_mirror_reason)\t\t\t      \\\n\tMLXSW_RXL_MIRROR(mlxsw_sp_rx_drop_listener, 0, SP_BUFFER_DISCARDS,    \\\n\t\t\t MLXSW_SP_MIRROR_REASON_##_mirror_reason)\n\n#define MLXSW_SP_RXL_EXCEPTION(_id, _group_id, _action)\t\t\t      \\\n\tMLXSW_RXL(mlxsw_sp_rx_mark_listener, _id,\t\t\t      \\\n\t\t   _action, false, SP_##_group_id, SET_FW_DEFAULT)\n\n#define MLXSW_SP_RXL_NO_MARK(_id, _group_id, _action, _is_ctrl)\t\t      \\\n\tMLXSW_RXL(mlxsw_sp_rx_no_mark_listener, _id, _action,\t\t      \\\n\t\t  _is_ctrl, SP_##_group_id, DISCARD)\n\n#define MLXSW_SP_RXL_MARK(_id, _group_id, _action, _is_ctrl)\t\t      \\\n\tMLXSW_RXL(mlxsw_sp_rx_mark_listener, _id, _action, _is_ctrl,\t      \\\n\t\t  SP_##_group_id, DISCARD)\n\n#define MLXSW_SP_RXL_L3_MARK(_id, _group_id, _action, _is_ctrl)\t\t      \\\n\tMLXSW_RXL(mlxsw_sp_rx_l3_mark_listener, _id, _action, _is_ctrl,\t      \\\n\t\t  SP_##_group_id, DISCARD)\n\n#define MLXSW_SP_TRAP_POLICER(_id, _rate, _burst)\t\t\t      \\\n\tDEVLINK_TRAP_POLICER(_id, _rate, _burst,\t\t\t      \\\n\t\t\t     MLXSW_REG_QPCR_HIGHEST_CIR,\t\t      \\\n\t\t\t     MLXSW_REG_QPCR_LOWEST_CIR,\t\t\t      \\\n\t\t\t     1 << MLXSW_REG_QPCR_HIGHEST_CBS,\t\t      \\\n\t\t\t     1 << MLXSW_REG_QPCR_LOWEST_CBS)\n\n \nstatic const struct mlxsw_sp_trap_policer_item\nmlxsw_sp_trap_policer_items_arr[] = {\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(1, 10 * 1024, 4096),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(2, 128, 128),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(3, 128, 128),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(4, 128, 128),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(5, 16 * 1024, 8192),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(6, 128, 128),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(7, 1024, 512),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(8, 20 * 1024, 8192),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(9, 128, 128),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(10, 1024, 512),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(11, 256, 128),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(12, 128, 128),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(13, 128, 128),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(14, 1024, 512),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(15, 1024, 512),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(16, 24 * 1024, 16384),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(17, 19 * 1024, 8192),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(18, 1024, 512),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(19, 1024, 512),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(20, 10240, 4096),\n\t},\n\t{\n\t\t.policer = MLXSW_SP_TRAP_POLICER(21, 128, 128),\n\t},\n};\n\nstatic const struct mlxsw_sp_trap_group_item mlxsw_sp_trap_group_items_arr[] = {\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(L2_DROPS, 1),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_L2_DISCARDS,\n\t\t.priority = 0,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(L3_DROPS, 1),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_L3_DISCARDS,\n\t\t.priority = 0,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(L3_EXCEPTIONS, 1),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_L3_EXCEPTIONS,\n\t\t.priority = 2,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(TUNNEL_DROPS, 1),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_TUNNEL_DISCARDS,\n\t\t.priority = 0,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(ACL_DROPS, 1),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_ACL_DISCARDS,\n\t\t.priority = 0,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(STP, 2),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_STP,\n\t\t.priority = 5,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(LACP, 3),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_LACP,\n\t\t.priority = 5,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(LLDP, 4),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_LLDP,\n\t\t.priority = 5,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(MC_SNOOPING, 5),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_MC_SNOOPING,\n\t\t.priority = 3,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(DHCP, 6),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_DHCP,\n\t\t.priority = 2,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(NEIGH_DISCOVERY, 7),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_NEIGH_DISCOVERY,\n\t\t.priority = 2,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(BFD, 8),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_BFD,\n\t\t.priority = 5,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(OSPF, 9),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_OSPF,\n\t\t.priority = 5,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(BGP, 10),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_BGP,\n\t\t.priority = 4,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(VRRP, 11),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_VRRP,\n\t\t.priority = 5,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(PIM, 12),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_PIM,\n\t\t.priority = 5,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(UC_LB, 13),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_LBERROR,\n\t\t.priority = 0,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(LOCAL_DELIVERY, 14),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_IP2ME,\n\t\t.priority = 2,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(EXTERNAL_DELIVERY, 19),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_EXTERNAL_ROUTE,\n\t\t.priority = 1,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(IPV6, 15),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_IPV6,\n\t\t.priority = 2,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(PTP_EVENT, 16),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_PTP0,\n\t\t.priority = 5,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(PTP_GENERAL, 17),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_PTP1,\n\t\t.priority = 2,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(ACL_TRAP, 18),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_FLOW_LOGGING,\n\t\t.priority = 4,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(EAPOL, 21),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_EAPOL,\n\t\t.priority = 5,\n\t},\n};\n\nstatic const struct mlxsw_sp_trap_item mlxsw_sp_trap_items_arr[] = {\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(SMAC_MC, L2_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ING_PACKET_SMAC_MC, L2_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(VLAN_TAG_MISMATCH, L2_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ING_SWITCH_VTAG_ALLOW,\n\t\t\t\t\t     L2_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(INGRESS_VLAN_FILTER, L2_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ING_SWITCH_VLAN, L2_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(INGRESS_STP_FILTER, L2_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ING_SWITCH_STP, L2_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(EMPTY_TX_LIST, L2_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(LOOKUP_SWITCH_UC, L2_DISCARDS),\n\t\t\tMLXSW_SP_RXL_DISCARD(LOOKUP_SWITCH_MC_NULL, L2_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(PORT_LOOPBACK_FILTER, L2_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(LOOKUP_SWITCH_LB, L2_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(BLACKHOLE_ROUTE, L3_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ROUTER2, L3_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(NON_IP_PACKET, L3_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ING_ROUTER_NON_IP_PACKET,\n\t\t\t\t\t     L3_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(UC_DIP_MC_DMAC, L3_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ING_ROUTER_UC_DIP_MC_DMAC,\n\t\t\t\t\t     L3_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(DIP_LB, L3_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ING_ROUTER_DIP_LB, L3_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(SIP_MC, L3_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ING_ROUTER_SIP_MC, L3_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(SIP_LB, L3_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ING_ROUTER_SIP_LB, L3_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(CORRUPTED_IP_HDR, L3_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ING_ROUTER_CORRUPTED_IP_HDR,\n\t\t\t\t\t     L3_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(IPV4_SIP_BC, L3_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ING_ROUTER_IPV4_SIP_BC,\n\t\t\t\t\t     L3_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(IPV6_MC_DIP_RESERVED_SCOPE,\n\t\t\t\t\t   L3_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(IPV6_MC_DIP_RESERVED_SCOPE,\n\t\t\t\t\t     L3_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(IPV6_MC_DIP_INTERFACE_LOCAL_SCOPE,\n\t\t\t\t\t   L3_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(IPV6_MC_DIP_INTERFACE_LOCAL_SCOPE,\n\t\t\t\t\t     L3_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_EXCEPTION(MTU_ERROR, L3_EXCEPTIONS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_EXCEPTION(MTUERROR, L3_EXCEPTIONS,\n\t\t\t\t\t       TRAP_TO_CPU),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_EXCEPTION(TTL_ERROR, L3_EXCEPTIONS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_EXCEPTION(TTLERROR, L3_EXCEPTIONS,\n\t\t\t\t\t       TRAP_TO_CPU),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_EXCEPTION(RPF, L3_EXCEPTIONS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_EXCEPTION(RPF, L3_EXCEPTIONS, TRAP_TO_CPU),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_EXCEPTION(REJECT_ROUTE, L3_EXCEPTIONS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_EXCEPTION(RTR_INGRESS1, L3_EXCEPTIONS,\n\t\t\t\t\t       TRAP_TO_CPU),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_EXCEPTION(UNRESOLVED_NEIGH,\n\t\t\t\t\t\tL3_EXCEPTIONS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_EXCEPTION(HOST_MISS_IPV4, L3_EXCEPTIONS,\n\t\t\t\t\t       TRAP_TO_CPU),\n\t\t\tMLXSW_SP_RXL_EXCEPTION(HOST_MISS_IPV6, L3_EXCEPTIONS,\n\t\t\t\t\t       TRAP_TO_CPU),\n\t\t\tMLXSW_SP_RXL_EXCEPTION(RTR_EGRESS0, L3_EXCEPTIONS,\n\t\t\t\t\t       TRAP_EXCEPTION_TO_CPU),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_EXCEPTION(IPV4_LPM_UNICAST_MISS,\n\t\t\t\t\t\tL3_EXCEPTIONS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_EXCEPTION(DISCARD_ROUTER_LPM4,\n\t\t\t\t\t       L3_EXCEPTIONS,\n\t\t\t\t\t       TRAP_EXCEPTION_TO_CPU),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_EXCEPTION(IPV6_LPM_UNICAST_MISS,\n\t\t\t\t\t\tL3_EXCEPTIONS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_EXCEPTION(DISCARD_ROUTER_LPM6,\n\t\t\t\t\t       L3_EXCEPTIONS,\n\t\t\t\t\t       TRAP_EXCEPTION_TO_CPU),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DRIVER_DROP(IRIF_DISABLED, L3_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ROUTER_IRIF_EN, L3_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DRIVER_DROP(ERIF_DISABLED, L3_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ROUTER_ERIF_EN, L3_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(NON_ROUTABLE, L3_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(NON_ROUTABLE, L3_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_EXCEPTION(DECAP_ERROR, TUNNEL_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_EXCEPTION(DECAP_ECN0, TUNNEL_DISCARDS,\n\t\t\t\t\t       TRAP_EXCEPTION_TO_CPU),\n\t\t\tMLXSW_SP_RXL_EXCEPTION(IPIP_DECAP_ERROR,\n\t\t\t\t\t       TUNNEL_DISCARDS,\n\t\t\t\t\t       TRAP_EXCEPTION_TO_CPU),\n\t\t\tMLXSW_SP_RXL_EXCEPTION(DISCARD_DEC_PKT, TUNNEL_DISCARDS,\n\t\t\t\t\t       TRAP_EXCEPTION_TO_CPU),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(OVERLAY_SMAC_MC, TUNNEL_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(OVERLAY_SMAC_MC, TUNNEL_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP_EXT(INGRESS_FLOW_ACTION_DROP,\n\t\t\t\t\t       ACL_DROPS,\n\t\t\t\t\t       DEVLINK_TRAP_METADATA_TYPE_F_FA_COOKIE),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_ACL_DISCARD(INGRESS_ACL, ACL_DISCARDS,\n\t\t\t\t\t\t DUMMY),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP_EXT(EGRESS_FLOW_ACTION_DROP,\n\t\t\t\t\t       ACL_DROPS,\n\t\t\t\t\t       DEVLINK_TRAP_METADATA_TYPE_F_FA_COOKIE),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_ACL_DISCARD(EGRESS_ACL, ACL_DISCARDS,\n\t\t\t\t\t\t DUMMY),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(STP, STP, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_NO_MARK(STP, STP, TRAP_TO_CPU, true),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(LACP, LACP, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_NO_MARK(LACP, LACP, TRAP_TO_CPU, true),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(LLDP, LLDP, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_RXL(mlxsw_sp_rx_ptp_listener, LLDP, TRAP_TO_CPU,\n\t\t\t\t  true, SP_LLDP, DISCARD),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IGMP_QUERY, MC_SNOOPING, MIRROR),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IGMP_QUERY, MC_SNOOPING,\n\t\t\t\t\t  MIRROR_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IGMP_V1_REPORT, MC_SNOOPING,\n\t\t\t\t\t      TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_NO_MARK(IGMP_V1_REPORT, MC_SNOOPING,\n\t\t\t\t\t     TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IGMP_V2_REPORT, MC_SNOOPING,\n\t\t\t\t\t      TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_NO_MARK(IGMP_V2_REPORT, MC_SNOOPING,\n\t\t\t\t\t     TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IGMP_V3_REPORT, MC_SNOOPING,\n\t\t\t\t\t      TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_NO_MARK(IGMP_V3_REPORT, MC_SNOOPING,\n\t\t\t\t\t     TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IGMP_V2_LEAVE, MC_SNOOPING,\n\t\t\t\t\t      TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_NO_MARK(IGMP_V2_LEAVE, MC_SNOOPING,\n\t\t\t\t\t     TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(MLD_QUERY, MC_SNOOPING, MIRROR),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV6_MLDV12_LISTENER_QUERY,\n\t\t\t\t\t  MC_SNOOPING, MIRROR_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(MLD_V1_REPORT, MC_SNOOPING,\n\t\t\t\t\t      TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_NO_MARK(IPV6_MLDV1_LISTENER_REPORT,\n\t\t\t\t\t     MC_SNOOPING, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(MLD_V2_REPORT, MC_SNOOPING,\n\t\t\t\t\t      TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_NO_MARK(IPV6_MLDV2_LISTENER_REPORT,\n\t\t\t\t\t     MC_SNOOPING, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(MLD_V1_DONE, MC_SNOOPING,\n\t\t\t\t\t      TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_NO_MARK(IPV6_MLDV1_LISTENER_DONE,\n\t\t\t\t\t     MC_SNOOPING, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV4_DHCP, DHCP, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV4_DHCP, DHCP, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_DHCP, DHCP, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV6_DHCP, DHCP, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(ARP_REQUEST, NEIGH_DISCOVERY,\n\t\t\t\t\t      MIRROR),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(ROUTER_ARPBC, NEIGH_DISCOVERY,\n\t\t\t\t\t  TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(ARP_RESPONSE, NEIGH_DISCOVERY,\n\t\t\t\t\t      MIRROR),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(ROUTER_ARPUC, NEIGH_DISCOVERY,\n\t\t\t\t\t  TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(ARP_OVERLAY, NEIGH_DISCOVERY,\n\t\t\t\t\t      TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_NO_MARK(NVE_DECAP_ARP, NEIGH_DISCOVERY,\n\t\t\t\t\t     TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_NEIGH_SOLICIT,\n\t\t\t\t\t      NEIGH_DISCOVERY, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(L3_IPV6_NEIGHBOR_SOLICITATION,\n\t\t\t\t\t  NEIGH_DISCOVERY, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_NEIGH_ADVERT,\n\t\t\t\t\t      NEIGH_DISCOVERY, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(L3_IPV6_NEIGHBOR_ADVERTISEMENT,\n\t\t\t\t\t  NEIGH_DISCOVERY, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV4_BFD, BFD, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV4_BFD, BFD, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_BFD, BFD, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV6_BFD, BFD, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV4_OSPF, OSPF, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV4_OSPF, OSPF, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_OSPF, OSPF, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV6_OSPF, OSPF, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV4_BGP, BGP, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV4_BGP, BGP, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_BGP, BGP, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV6_BGP, BGP, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV4_VRRP, VRRP, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV4_VRRP, VRRP, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_VRRP, VRRP, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV6_VRRP, VRRP, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV4_PIM, PIM, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV4_PIM, PIM, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_PIM, PIM, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV6_PIM, PIM, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(UC_LB, UC_LB, MIRROR),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_L3_MARK(LBERROR, LBERROR, MIRROR_TO_CPU,\n\t\t\t\t\t     false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(LOCAL_ROUTE, LOCAL_DELIVERY,\n\t\t\t\t\t      TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IP2ME, IP2ME, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(EXTERNAL_ROUTE, EXTERNAL_DELIVERY,\n\t\t\t\t\t      TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(RTR_INGRESS0, EXTERNAL_ROUTE,\n\t\t\t\t\t  TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_UC_DIP_LINK_LOCAL_SCOPE,\n\t\t\t\t\t      LOCAL_DELIVERY, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV6_LINK_LOCAL_DEST, IP2ME,\n\t\t\t\t\t  TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV4_ROUTER_ALERT, LOCAL_DELIVERY,\n\t\t\t\t\t      TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(ROUTER_ALERT_IPV4, IP2ME, TRAP_TO_CPU,\n\t\t\t\t\t  false),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t#undef IPV6_ROUTER_ALERT\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_ROUTER_ALERT, LOCAL_DELIVERY,\n\t\t\t\t\t      TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(ROUTER_ALERT_IPV6, IP2ME, TRAP_TO_CPU,\n\t\t\t\t\t  false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_DIP_ALL_NODES, IPV6, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV6_ALL_NODES_LINK, IPV6,\n\t\t\t\t\t  TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_DIP_ALL_ROUTERS, IPV6, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(IPV6_ALL_ROUTERS_LINK, IPV6,\n\t\t\t\t\t  TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_ROUTER_SOLICIT, IPV6, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(L3_IPV6_ROUTER_SOLICITATION, IPV6,\n\t\t\t\t\t  TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_ROUTER_ADVERT, IPV6, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(L3_IPV6_ROUTER_ADVERTISEMENT, IPV6,\n\t\t\t\t\t  TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(IPV6_REDIRECT, IPV6, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_MARK(L3_IPV6_REDIRECTION, IPV6,\n\t\t\t\t\t  TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(PTP_EVENT, PTP_EVENT, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_RXL(mlxsw_sp_rx_ptp_listener, PTP0, TRAP_TO_CPU,\n\t\t\t\t  false, SP_PTP0, DISCARD),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(PTP_GENERAL, PTP_GENERAL, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_NO_MARK(PTP1, PTP1, TRAP_TO_CPU, false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(FLOW_ACTION_TRAP, ACL_TRAP, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_NO_MARK(ACL0, FLOW_LOGGING, TRAP_TO_CPU,\n\t\t\t\t\t     false),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(BLACKHOLE_NEXTHOP, L3_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_DISCARD(ROUTER3, L3_DISCARDS),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(EAPOL, EAPOL, TRAP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_NO_MARK(EAPOL, EAPOL, TRAP_TO_CPU, true),\n\t\t},\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_DROP(LOCKED_PORT, L2_DROPS),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_RXL_DIS(mlxsw_sp_rx_drop_listener, FDB_MISS,\n\t\t\t\t      TRAP_EXCEPTION_TO_CPU, false,\n\t\t\t\t      SP_L2_DISCARDS, DISCARD, SP_L2_DISCARDS),\n\t\t\tMLXSW_RXL_DIS(mlxsw_sp_rx_drop_listener, FDB_MISMATCH,\n\t\t\t\t      TRAP_EXCEPTION_TO_CPU, false,\n\t\t\t\t      SP_L2_DISCARDS, DISCARD, SP_L2_DISCARDS),\n\t\t},\n\t},\n};\n\nstatic struct mlxsw_sp_trap_policer_item *\nmlxsw_sp_trap_policer_item_lookup(struct mlxsw_sp *mlxsw_sp, u32 id)\n{\n\tstruct mlxsw_sp_trap *trap = mlxsw_sp->trap;\n\tint i;\n\n\tfor (i = 0; i < trap->policers_count; i++) {\n\t\tif (trap->policer_items_arr[i].policer.id == id)\n\t\t\treturn &trap->policer_items_arr[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mlxsw_sp_trap_group_item *\nmlxsw_sp_trap_group_item_lookup(struct mlxsw_sp *mlxsw_sp, u16 id)\n{\n\tstruct mlxsw_sp_trap *trap = mlxsw_sp->trap;\n\tint i;\n\n\tfor (i = 0; i < trap->groups_count; i++) {\n\t\tif (trap->group_items_arr[i].group.id == id)\n\t\t\treturn &trap->group_items_arr[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mlxsw_sp_trap_item *\nmlxsw_sp_trap_item_lookup(struct mlxsw_sp *mlxsw_sp, u16 id)\n{\n\tstruct mlxsw_sp_trap *trap = mlxsw_sp->trap;\n\tint i;\n\n\tfor (i = 0; i < trap->traps_count; i++) {\n\t\tif (trap->trap_items_arr[i].trap.id == id)\n\t\t\treturn &trap->trap_items_arr[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int mlxsw_sp_trap_cpu_policers_set(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_trap *trap = mlxsw_sp->trap;\n\tchar qpcr_pl[MLXSW_REG_QPCR_LEN];\n\tu16 hw_id;\n\n\t \n\thw_id = find_first_zero_bit(trap->policers_usage, trap->max_policers);\n\tif (WARN_ON(hw_id == trap->max_policers))\n\t\treturn -ENOBUFS;\n\n\t__set_bit(hw_id, trap->policers_usage);\n\ttrap->thin_policer_hw_id = hw_id;\n\tmlxsw_reg_qpcr_pack(qpcr_pl, hw_id, MLXSW_REG_QPCR_IR_UNITS_M,\n\t\t\t    false, 1, 4);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpcr), qpcr_pl);\n}\n\nstatic int mlxsw_sp_trap_dummy_group_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tchar htgt_pl[MLXSW_REG_HTGT_LEN];\n\n\tmlxsw_reg_htgt_pack(htgt_pl, MLXSW_REG_HTGT_TRAP_GROUP_SP_DUMMY,\n\t\t\t    mlxsw_sp->trap->thin_policer_hw_id, 0, 1);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(htgt), htgt_pl);\n}\n\nstatic int mlxsw_sp_trap_policer_items_arr_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tsize_t arr_size = ARRAY_SIZE(mlxsw_sp_trap_policer_items_arr);\n\tsize_t elem_size = sizeof(struct mlxsw_sp_trap_policer_item);\n\tstruct mlxsw_sp_trap *trap = mlxsw_sp->trap;\n\tsize_t free_policers = 0;\n\tu32 last_id;\n\tint i;\n\n\tfor_each_clear_bit(i, trap->policers_usage, trap->max_policers)\n\t\tfree_policers++;\n\n\tif (arr_size > free_policers) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Exceeded number of supported packet trap policers\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\n\ttrap->policer_items_arr = kcalloc(free_policers, elem_size, GFP_KERNEL);\n\tif (!trap->policer_items_arr)\n\t\treturn -ENOMEM;\n\n\ttrap->policers_count = free_policers;\n\n\t \n\tmemcpy(trap->policer_items_arr, mlxsw_sp_trap_policer_items_arr,\n\t       elem_size * arr_size);\n\n\t \n\tlast_id = mlxsw_sp_trap_policer_items_arr[arr_size - 1].policer.id;\n\tfor (i = arr_size; i < trap->policers_count; i++) {\n\t\tconst struct mlxsw_sp_trap_policer_item *policer_item;\n\n\t\t \n\t\tpolicer_item = &mlxsw_sp_trap_policer_items_arr[0];\n\t\ttrap->policer_items_arr[i] = *policer_item;\n\t\ttrap->policer_items_arr[i].policer.id = ++last_id;\n\t\ttrap->policer_items_arr[i].policer.init_rate = 1;\n\t\ttrap->policer_items_arr[i].policer.init_burst = 16;\n\t}\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_trap_policer_items_arr_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tkfree(mlxsw_sp->trap->policer_items_arr);\n}\n\nstatic int mlxsw_sp_trap_policers_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tconst struct mlxsw_sp_trap_policer_item *policer_item;\n\tstruct mlxsw_sp_trap *trap = mlxsw_sp->trap;\n\tint err, i;\n\n\terr = mlxsw_sp_trap_policer_items_arr_init(mlxsw_sp);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < trap->policers_count; i++) {\n\t\tpolicer_item = &trap->policer_items_arr[i];\n\t\terr = devl_trap_policers_register(devlink,\n\t\t\t\t\t\t  &policer_item->policer, 1);\n\t\tif (err)\n\t\t\tgoto err_trap_policer_register;\n\t}\n\n\treturn 0;\n\nerr_trap_policer_register:\n\tfor (i--; i >= 0; i--) {\n\t\tpolicer_item = &trap->policer_items_arr[i];\n\t\tdevl_trap_policers_unregister(devlink,\n\t\t\t\t\t      &policer_item->policer, 1);\n\t}\n\tmlxsw_sp_trap_policer_items_arr_fini(mlxsw_sp);\n\treturn err;\n}\n\nstatic void mlxsw_sp_trap_policers_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tconst struct mlxsw_sp_trap_policer_item *policer_item;\n\tstruct mlxsw_sp_trap *trap = mlxsw_sp->trap;\n\tint i;\n\n\tfor (i = trap->policers_count - 1; i >= 0; i--) {\n\t\tpolicer_item = &trap->policer_items_arr[i];\n\t\tdevl_trap_policers_unregister(devlink,\n\t\t\t\t\t      &policer_item->policer, 1);\n\t}\n\tmlxsw_sp_trap_policer_items_arr_fini(mlxsw_sp);\n}\n\nstatic int mlxsw_sp_trap_group_items_arr_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tsize_t common_groups_count = ARRAY_SIZE(mlxsw_sp_trap_group_items_arr);\n\tconst struct mlxsw_sp_trap_group_item *spec_group_items_arr;\n\tsize_t elem_size = sizeof(struct mlxsw_sp_trap_group_item);\n\tstruct mlxsw_sp_trap *trap = mlxsw_sp->trap;\n\tsize_t groups_count, spec_groups_count;\n\tint err;\n\n\terr = mlxsw_sp->trap_ops->groups_init(mlxsw_sp, &spec_group_items_arr,\n\t\t\t\t\t      &spec_groups_count);\n\tif (err)\n\t\treturn err;\n\n\t \n\tgroups_count = common_groups_count + spec_groups_count;\n\ttrap->group_items_arr = kcalloc(groups_count, elem_size, GFP_KERNEL);\n\tif (!trap->group_items_arr)\n\t\treturn -ENOMEM;\n\n\tmemcpy(trap->group_items_arr, mlxsw_sp_trap_group_items_arr,\n\t       elem_size * common_groups_count);\n\tmemcpy(trap->group_items_arr + common_groups_count,\n\t       spec_group_items_arr, elem_size * spec_groups_count);\n\n\ttrap->groups_count = groups_count;\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_trap_group_items_arr_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tkfree(mlxsw_sp->trap->group_items_arr);\n}\n\nstatic int mlxsw_sp_trap_groups_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tconst struct mlxsw_sp_trap_group_item *group_item;\n\tstruct mlxsw_sp_trap *trap = mlxsw_sp->trap;\n\tint err, i;\n\n\terr = mlxsw_sp_trap_group_items_arr_init(mlxsw_sp);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < trap->groups_count; i++) {\n\t\tgroup_item = &trap->group_items_arr[i];\n\t\terr = devl_trap_groups_register(devlink, &group_item->group, 1);\n\t\tif (err)\n\t\t\tgoto err_trap_group_register;\n\t}\n\n\treturn 0;\n\nerr_trap_group_register:\n\tfor (i--; i >= 0; i--) {\n\t\tgroup_item = &trap->group_items_arr[i];\n\t\tdevl_trap_groups_unregister(devlink, &group_item->group, 1);\n\t}\n\tmlxsw_sp_trap_group_items_arr_fini(mlxsw_sp);\n\treturn err;\n}\n\nstatic void mlxsw_sp_trap_groups_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tstruct mlxsw_sp_trap *trap = mlxsw_sp->trap;\n\tint i;\n\n\tfor (i = trap->groups_count - 1; i >= 0; i--) {\n\t\tconst struct mlxsw_sp_trap_group_item *group_item;\n\n\t\tgroup_item = &trap->group_items_arr[i];\n\t\tdevl_trap_groups_unregister(devlink, &group_item->group, 1);\n\t}\n\tmlxsw_sp_trap_group_items_arr_fini(mlxsw_sp);\n}\n\nstatic bool\nmlxsw_sp_trap_listener_is_valid(const struct mlxsw_listener *listener)\n{\n\treturn listener->trap_id != 0;\n}\n\nstatic int mlxsw_sp_trap_items_arr_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tsize_t common_traps_count = ARRAY_SIZE(mlxsw_sp_trap_items_arr);\n\tconst struct mlxsw_sp_trap_item *spec_trap_items_arr;\n\tsize_t elem_size = sizeof(struct mlxsw_sp_trap_item);\n\tstruct mlxsw_sp_trap *trap = mlxsw_sp->trap;\n\tsize_t traps_count, spec_traps_count;\n\tint err;\n\n\terr = mlxsw_sp->trap_ops->traps_init(mlxsw_sp, &spec_trap_items_arr,\n\t\t\t\t\t     &spec_traps_count);\n\tif (err)\n\t\treturn err;\n\n\t \n\ttraps_count = common_traps_count + spec_traps_count;\n\ttrap->trap_items_arr = kcalloc(traps_count, elem_size, GFP_KERNEL);\n\tif (!trap->trap_items_arr)\n\t\treturn -ENOMEM;\n\n\tmemcpy(trap->trap_items_arr, mlxsw_sp_trap_items_arr,\n\t       elem_size * common_traps_count);\n\tmemcpy(trap->trap_items_arr + common_traps_count,\n\t       spec_trap_items_arr, elem_size * spec_traps_count);\n\n\ttrap->traps_count = traps_count;\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_trap_items_arr_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tkfree(mlxsw_sp->trap->trap_items_arr);\n}\n\nstatic int mlxsw_sp_traps_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tstruct mlxsw_sp_trap *trap = mlxsw_sp->trap;\n\tconst struct mlxsw_sp_trap_item *trap_item;\n\tint err, i;\n\n\terr = mlxsw_sp_trap_items_arr_init(mlxsw_sp);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < trap->traps_count; i++) {\n\t\ttrap_item = &trap->trap_items_arr[i];\n\t\terr = devl_traps_register(devlink, &trap_item->trap, 1,\n\t\t\t\t\t  mlxsw_sp);\n\t\tif (err)\n\t\t\tgoto err_trap_register;\n\t}\n\n\treturn 0;\n\nerr_trap_register:\n\tfor (i--; i >= 0; i--) {\n\t\ttrap_item = &trap->trap_items_arr[i];\n\t\tdevl_traps_unregister(devlink, &trap_item->trap, 1);\n\t}\n\tmlxsw_sp_trap_items_arr_fini(mlxsw_sp);\n\treturn err;\n}\n\nstatic void mlxsw_sp_traps_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tstruct mlxsw_sp_trap *trap = mlxsw_sp->trap;\n\tint i;\n\n\tfor (i = trap->traps_count - 1; i >= 0; i--) {\n\t\tconst struct mlxsw_sp_trap_item *trap_item;\n\n\t\ttrap_item = &trap->trap_items_arr[i];\n\t\tdevl_traps_unregister(devlink, &trap_item->trap, 1);\n\t}\n\tmlxsw_sp_trap_items_arr_fini(mlxsw_sp);\n}\n\nint mlxsw_sp_devlink_traps_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tint err;\n\n\terr = mlxsw_sp_trap_cpu_policers_set(mlxsw_sp);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_trap_dummy_group_init(mlxsw_sp);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_trap_policers_init(mlxsw_sp);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_trap_groups_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_trap_groups_init;\n\n\terr = mlxsw_sp_traps_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_traps_init;\n\n\treturn 0;\n\nerr_traps_init:\n\tmlxsw_sp_trap_groups_fini(mlxsw_sp);\nerr_trap_groups_init:\n\tmlxsw_sp_trap_policers_fini(mlxsw_sp);\n\treturn err;\n}\n\nvoid mlxsw_sp_devlink_traps_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tmlxsw_sp_traps_fini(mlxsw_sp);\n\tmlxsw_sp_trap_groups_fini(mlxsw_sp);\n\tmlxsw_sp_trap_policers_fini(mlxsw_sp);\n}\n\nint mlxsw_sp_trap_init(struct mlxsw_core *mlxsw_core,\n\t\t       const struct devlink_trap *trap, void *trap_ctx)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tconst struct mlxsw_sp_trap_item *trap_item;\n\tint i;\n\n\ttrap_item = mlxsw_sp_trap_item_lookup(mlxsw_sp, trap->id);\n\tif (WARN_ON(!trap_item))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < MLXSW_SP_TRAP_LISTENERS_MAX; i++) {\n\t\tconst struct mlxsw_listener *listener;\n\t\tint err;\n\n\t\tlistener = &trap_item->listeners_arr[i];\n\t\tif (!mlxsw_sp_trap_listener_is_valid(listener))\n\t\t\tcontinue;\n\t\terr = mlxsw_core_trap_register(mlxsw_core, listener, trap_ctx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid mlxsw_sp_trap_fini(struct mlxsw_core *mlxsw_core,\n\t\t\tconst struct devlink_trap *trap, void *trap_ctx)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tconst struct mlxsw_sp_trap_item *trap_item;\n\tint i;\n\n\ttrap_item = mlxsw_sp_trap_item_lookup(mlxsw_sp, trap->id);\n\tif (WARN_ON(!trap_item))\n\t\treturn;\n\n\tfor (i = MLXSW_SP_TRAP_LISTENERS_MAX - 1; i >= 0; i--) {\n\t\tconst struct mlxsw_listener *listener;\n\n\t\tlistener = &trap_item->listeners_arr[i];\n\t\tif (!mlxsw_sp_trap_listener_is_valid(listener))\n\t\t\tcontinue;\n\t\tmlxsw_core_trap_unregister(mlxsw_core, listener, trap_ctx);\n\t}\n}\n\nint mlxsw_sp_trap_action_set(struct mlxsw_core *mlxsw_core,\n\t\t\t     const struct devlink_trap *trap,\n\t\t\t     enum devlink_trap_action action,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tconst struct mlxsw_sp_trap_item *trap_item;\n\tint i;\n\n\ttrap_item = mlxsw_sp_trap_item_lookup(mlxsw_sp, trap->id);\n\tif (WARN_ON(!trap_item))\n\t\treturn -EINVAL;\n\n\tif (trap_item->is_source) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Changing the action of source traps is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfor (i = 0; i < MLXSW_SP_TRAP_LISTENERS_MAX; i++) {\n\t\tconst struct mlxsw_listener *listener;\n\t\tbool enabled;\n\t\tint err;\n\n\t\tlistener = &trap_item->listeners_arr[i];\n\t\tif (!mlxsw_sp_trap_listener_is_valid(listener))\n\t\t\tcontinue;\n\n\t\tswitch (action) {\n\t\tcase DEVLINK_TRAP_ACTION_DROP:\n\t\t\tenabled = false;\n\t\t\tbreak;\n\t\tcase DEVLINK_TRAP_ACTION_TRAP:\n\t\t\tenabled = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = mlxsw_core_trap_state_set(mlxsw_core, listener, enabled);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int\n__mlxsw_sp_trap_group_init(struct mlxsw_core *mlxsw_core,\n\t\t\t   const struct devlink_trap_group *group,\n\t\t\t   u32 policer_id, struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tu16 hw_policer_id = MLXSW_REG_HTGT_INVALID_POLICER;\n\tconst struct mlxsw_sp_trap_group_item *group_item;\n\tchar htgt_pl[MLXSW_REG_HTGT_LEN];\n\n\tgroup_item = mlxsw_sp_trap_group_item_lookup(mlxsw_sp, group->id);\n\tif (WARN_ON(!group_item))\n\t\treturn -EINVAL;\n\n\tif (group_item->fixed_policer && policer_id != group->init_policer_id) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Changing the policer binding of this group is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (policer_id) {\n\t\tstruct mlxsw_sp_trap_policer_item *policer_item;\n\n\t\tpolicer_item = mlxsw_sp_trap_policer_item_lookup(mlxsw_sp,\n\t\t\t\t\t\t\t\t policer_id);\n\t\tif (WARN_ON(!policer_item))\n\t\t\treturn -EINVAL;\n\t\thw_policer_id = policer_item->hw_id;\n\t}\n\n\tmlxsw_reg_htgt_pack(htgt_pl, group_item->hw_group_id, hw_policer_id,\n\t\t\t    group_item->priority, group_item->priority);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(htgt), htgt_pl);\n}\n\nint mlxsw_sp_trap_group_init(struct mlxsw_core *mlxsw_core,\n\t\t\t     const struct devlink_trap_group *group)\n{\n\treturn __mlxsw_sp_trap_group_init(mlxsw_core, group,\n\t\t\t\t\t  group->init_policer_id, NULL);\n}\n\nint mlxsw_sp_trap_group_set(struct mlxsw_core *mlxsw_core,\n\t\t\t    const struct devlink_trap_group *group,\n\t\t\t    const struct devlink_trap_policer *policer,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tu32 policer_id = policer ? policer->id : 0;\n\n\treturn __mlxsw_sp_trap_group_init(mlxsw_core, group, policer_id,\n\t\t\t\t\t  extack);\n}\n\nstatic int\nmlxsw_sp_trap_policer_item_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_trap_policer_item *policer_item)\n{\n\tstruct mlxsw_sp_trap *trap = mlxsw_sp->trap;\n\tu16 hw_id;\n\n\t \n\thw_id = find_first_zero_bit(trap->policers_usage, trap->max_policers);\n\tif (WARN_ON(hw_id == trap->max_policers))\n\t\treturn -ENOBUFS;\n\n\t__set_bit(hw_id, trap->policers_usage);\n\tpolicer_item->hw_id = hw_id;\n\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_trap_policer_item_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_trap_policer_item *policer_item)\n{\n\t__clear_bit(policer_item->hw_id, mlxsw_sp->trap->policers_usage);\n}\n\nstatic int mlxsw_sp_trap_policer_bs(u64 burst, u8 *p_burst_size,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tint bs = fls64(burst) - 1;\n\n\tif (burst != (BIT_ULL(bs))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Policer burst size is not power of two\");\n\t\treturn -EINVAL;\n\t}\n\n\t*p_burst_size = bs;\n\n\treturn 0;\n}\n\nstatic int __mlxsw_sp_trap_policer_set(struct mlxsw_sp *mlxsw_sp, u16 hw_id,\n\t\t\t\t       u64 rate, u64 burst, bool clear_counter,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tchar qpcr_pl[MLXSW_REG_QPCR_LEN];\n\tu8 burst_size;\n\tint err;\n\n\terr = mlxsw_sp_trap_policer_bs(burst, &burst_size, extack);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_qpcr_pack(qpcr_pl, hw_id, MLXSW_REG_QPCR_IR_UNITS_M, false,\n\t\t\t    rate, burst_size);\n\tmlxsw_reg_qpcr_clear_counter_set(qpcr_pl, clear_counter);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpcr), qpcr_pl);\n}\n\nint mlxsw_sp_trap_policer_init(struct mlxsw_core *mlxsw_core,\n\t\t\t       const struct devlink_trap_policer *policer)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tstruct mlxsw_sp_trap_policer_item *policer_item;\n\tint err;\n\n\tpolicer_item = mlxsw_sp_trap_policer_item_lookup(mlxsw_sp, policer->id);\n\tif (WARN_ON(!policer_item))\n\t\treturn -EINVAL;\n\n\terr = mlxsw_sp_trap_policer_item_init(mlxsw_sp, policer_item);\n\tif (err)\n\t\treturn err;\n\n\terr = __mlxsw_sp_trap_policer_set(mlxsw_sp, policer_item->hw_id,\n\t\t\t\t\t  policer->init_rate,\n\t\t\t\t\t  policer->init_burst, true, NULL);\n\tif (err)\n\t\tgoto err_trap_policer_set;\n\n\treturn 0;\n\nerr_trap_policer_set:\n\tmlxsw_sp_trap_policer_item_fini(mlxsw_sp, policer_item);\n\treturn err;\n}\n\nvoid mlxsw_sp_trap_policer_fini(struct mlxsw_core *mlxsw_core,\n\t\t\t\tconst struct devlink_trap_policer *policer)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tstruct mlxsw_sp_trap_policer_item *policer_item;\n\n\tpolicer_item = mlxsw_sp_trap_policer_item_lookup(mlxsw_sp, policer->id);\n\tif (WARN_ON(!policer_item))\n\t\treturn;\n\n\tmlxsw_sp_trap_policer_item_fini(mlxsw_sp, policer_item);\n}\n\nint mlxsw_sp_trap_policer_set(struct mlxsw_core *mlxsw_core,\n\t\t\t      const struct devlink_trap_policer *policer,\n\t\t\t      u64 rate, u64 burst,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tstruct mlxsw_sp_trap_policer_item *policer_item;\n\n\tpolicer_item = mlxsw_sp_trap_policer_item_lookup(mlxsw_sp, policer->id);\n\tif (WARN_ON(!policer_item))\n\t\treturn -EINVAL;\n\n\treturn __mlxsw_sp_trap_policer_set(mlxsw_sp, policer_item->hw_id,\n\t\t\t\t\t   rate, burst, false, extack);\n}\n\nint\nmlxsw_sp_trap_policer_counter_get(struct mlxsw_core *mlxsw_core,\n\t\t\t\t  const struct devlink_trap_policer *policer,\n\t\t\t\t  u64 *p_drops)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tstruct mlxsw_sp_trap_policer_item *policer_item;\n\tchar qpcr_pl[MLXSW_REG_QPCR_LEN];\n\tint err;\n\n\tpolicer_item = mlxsw_sp_trap_policer_item_lookup(mlxsw_sp, policer->id);\n\tif (WARN_ON(!policer_item))\n\t\treturn -EINVAL;\n\n\tmlxsw_reg_qpcr_pack(qpcr_pl, policer_item->hw_id,\n\t\t\t    MLXSW_REG_QPCR_IR_UNITS_M, false, 0, 0);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(qpcr), qpcr_pl);\n\tif (err)\n\t\treturn err;\n\n\t*p_drops = mlxsw_reg_qpcr_violate_count_get(qpcr_pl);\n\n\treturn 0;\n}\n\nint mlxsw_sp_trap_group_policer_hw_id_get(struct mlxsw_sp *mlxsw_sp, u16 id,\n\t\t\t\t\t  bool *p_enabled, u16 *p_hw_id)\n{\n\tstruct mlxsw_sp_trap_policer_item *pol_item;\n\tstruct mlxsw_sp_trap_group_item *gr_item;\n\tu32 pol_id;\n\n\tgr_item = mlxsw_sp_trap_group_item_lookup(mlxsw_sp, id);\n\tif (!gr_item)\n\t\treturn -ENOENT;\n\n\tpol_id = gr_item->group.init_policer_id;\n\tif (!pol_id) {\n\t\t*p_enabled = false;\n\t\treturn 0;\n\t}\n\n\tpol_item = mlxsw_sp_trap_policer_item_lookup(mlxsw_sp, pol_id);\n\tif (WARN_ON(!pol_item))\n\t\treturn -ENOENT;\n\n\t*p_enabled = true;\n\t*p_hw_id = pol_item->hw_id;\n\treturn 0;\n}\n\nstatic const struct mlxsw_sp_trap_group_item\nmlxsw_sp1_trap_group_items_arr[] = {\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(ACL_SAMPLE, 0),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_PKT_SAMPLE,\n\t\t.priority = 0,\n\t},\n};\n\nstatic const struct mlxsw_sp_trap_item\nmlxsw_sp1_trap_items_arr[] = {\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(FLOW_ACTION_SAMPLE, ACL_SAMPLE,\n\t\t\t\t\t      MIRROR),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_RXL(mlxsw_sp_rx_sample_listener, PKT_SAMPLE,\n\t\t\t\t  MIRROR_TO_CPU, false, SP_PKT_SAMPLE, DISCARD),\n\t\t},\n\t},\n};\n\nstatic int\nmlxsw_sp1_trap_groups_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   const struct mlxsw_sp_trap_group_item **arr,\n\t\t\t   size_t *p_groups_count)\n{\n\t*arr = mlxsw_sp1_trap_group_items_arr;\n\t*p_groups_count = ARRAY_SIZE(mlxsw_sp1_trap_group_items_arr);\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp1_traps_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tconst struct mlxsw_sp_trap_item **arr,\n\t\t\t\tsize_t *p_traps_count)\n{\n\t*arr = mlxsw_sp1_trap_items_arr;\n\t*p_traps_count = ARRAY_SIZE(mlxsw_sp1_trap_items_arr);\n\n\treturn 0;\n}\n\nconst struct mlxsw_sp_trap_ops mlxsw_sp1_trap_ops = {\n\t.groups_init = mlxsw_sp1_trap_groups_init,\n\t.traps_init = mlxsw_sp1_traps_init,\n};\n\nstatic const struct mlxsw_sp_trap_group_item\nmlxsw_sp2_trap_group_items_arr[] = {\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(BUFFER_DROPS, 20),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_BUFFER_DISCARDS,\n\t\t.priority = 0,\n\t\t.fixed_policer = true,\n\t},\n\t{\n\t\t.group = DEVLINK_TRAP_GROUP_GENERIC(ACL_SAMPLE, 0),\n\t\t.hw_group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_PKT_SAMPLE,\n\t\t.priority = 0,\n\t\t.fixed_policer = true,\n\t},\n};\n\nstatic const struct mlxsw_sp_trap_item\nmlxsw_sp2_trap_items_arr[] = {\n\t{\n\t\t.trap = MLXSW_SP_TRAP_BUFFER_DROP(EARLY_DROP),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_SP_RXL_BUFFER_DISCARD(INGRESS_WRED),\n\t\t},\n\t\t.is_source = true,\n\t},\n\t{\n\t\t.trap = MLXSW_SP_TRAP_CONTROL(FLOW_ACTION_SAMPLE, ACL_SAMPLE,\n\t\t\t\t\t      MIRROR),\n\t\t.listeners_arr = {\n\t\t\tMLXSW_RXL_MIRROR(mlxsw_sp_rx_sample_listener, 1,\n\t\t\t\t\t SP_PKT_SAMPLE,\n\t\t\t\t\t MLXSW_SP_MIRROR_REASON_INGRESS),\n\t\t\tMLXSW_RXL_MIRROR(mlxsw_sp_rx_sample_tx_listener, 1,\n\t\t\t\t\t SP_PKT_SAMPLE,\n\t\t\t\t\t MLXSW_SP_MIRROR_REASON_EGRESS),\n\t\t\tMLXSW_RXL_MIRROR(mlxsw_sp_rx_sample_acl_listener, 1,\n\t\t\t\t\t SP_PKT_SAMPLE,\n\t\t\t\t\t MLXSW_SP_MIRROR_REASON_POLICY_ENGINE),\n\t\t},\n\t},\n};\n\nstatic int\nmlxsw_sp2_trap_groups_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   const struct mlxsw_sp_trap_group_item **arr,\n\t\t\t   size_t *p_groups_count)\n{\n\t*arr = mlxsw_sp2_trap_group_items_arr;\n\t*p_groups_count = ARRAY_SIZE(mlxsw_sp2_trap_group_items_arr);\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp2_traps_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tconst struct mlxsw_sp_trap_item **arr,\n\t\t\t\tsize_t *p_traps_count)\n{\n\t*arr = mlxsw_sp2_trap_items_arr;\n\t*p_traps_count = ARRAY_SIZE(mlxsw_sp2_trap_items_arr);\n\n\treturn 0;\n}\n\nconst struct mlxsw_sp_trap_ops mlxsw_sp2_trap_ops = {\n\t.groups_init = mlxsw_sp2_trap_groups_init,\n\t.traps_init = mlxsw_sp2_traps_init,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}