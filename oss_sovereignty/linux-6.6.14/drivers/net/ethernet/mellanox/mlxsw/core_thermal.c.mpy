{
  "module_name": "core_thermal.c",
  "hash_id": "05e96091d7f3fcd4cfd0693eb21146968910bef83a94c78c30d165eb43b4190d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/core_thermal.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/sysfs.h>\n#include <linux/thermal.h>\n#include <linux/err.h>\n#include <linux/sfp.h>\n\n#include \"core.h\"\n#include \"core_env.h\"\n\n#define MLXSW_THERMAL_POLL_INT\t1000\t \n#define MLXSW_THERMAL_SLOW_POLL_INT\t20000\t \n#define MLXSW_THERMAL_ASIC_TEMP_NORM\t75000\t \n#define MLXSW_THERMAL_ASIC_TEMP_HIGH\t85000\t \n#define MLXSW_THERMAL_ASIC_TEMP_HOT\t105000\t \n#define MLXSW_THERMAL_MODULE_TEMP_NORM\t55000\t \n#define MLXSW_THERMAL_MODULE_TEMP_HIGH\t65000\t \n#define MLXSW_THERMAL_MODULE_TEMP_HOT\t80000\t \n#define MLXSW_THERMAL_HYSTERESIS_TEMP\t5000\t \n#define MLXSW_THERMAL_MODULE_TEMP_SHIFT\t(MLXSW_THERMAL_HYSTERESIS_TEMP * 2)\n#define MLXSW_THERMAL_MAX_STATE\t10\n#define MLXSW_THERMAL_MIN_STATE\t2\n#define MLXSW_THERMAL_MAX_DUTY\t255\n\n \nstatic char * const mlxsw_thermal_external_allowed_cdev[] = {\n\t\"mlxreg_fan\",\n};\n\nstruct mlxsw_cooling_states {\n\tint\tmin_state;\n\tint\tmax_state;\n};\n\nstatic const struct thermal_trip default_thermal_trips[] = {\n\t{\t \n\t\t.type\t\t= THERMAL_TRIP_ACTIVE,\n\t\t.temperature\t= MLXSW_THERMAL_ASIC_TEMP_NORM,\n\t\t.hysteresis\t= MLXSW_THERMAL_HYSTERESIS_TEMP,\n\t},\n\t{\n\t\t \n\t\t.type\t\t= THERMAL_TRIP_ACTIVE,\n\t\t.temperature\t= MLXSW_THERMAL_ASIC_TEMP_HIGH,\n\t\t.hysteresis\t= MLXSW_THERMAL_HYSTERESIS_TEMP,\n\t},\n\t{\t \n\t\t.type\t\t= THERMAL_TRIP_HOT,\n\t\t.temperature\t= MLXSW_THERMAL_ASIC_TEMP_HOT,\n\t},\n};\n\nstatic const struct thermal_trip default_thermal_module_trips[] = {\n\t{\t \n\t\t.type\t\t= THERMAL_TRIP_ACTIVE,\n\t\t.temperature\t= MLXSW_THERMAL_MODULE_TEMP_NORM,\n\t\t.hysteresis\t= MLXSW_THERMAL_HYSTERESIS_TEMP,\n\t},\n\t{\n\t\t \n\t\t.type\t\t= THERMAL_TRIP_ACTIVE,\n\t\t.temperature\t= MLXSW_THERMAL_MODULE_TEMP_HIGH,\n\t\t.hysteresis\t= MLXSW_THERMAL_HYSTERESIS_TEMP,\n\t},\n\t{\t \n\t\t.type\t\t= THERMAL_TRIP_HOT,\n\t\t.temperature\t= MLXSW_THERMAL_MODULE_TEMP_HOT,\n\t},\n};\n\nstatic const struct mlxsw_cooling_states default_cooling_states[] = {\n\t{\n\t\t.min_state\t= 0,\n\t\t.max_state\t= (4 * MLXSW_THERMAL_MAX_STATE) / 10,\n\t},\n\t{\n\t\t.min_state\t= (4 * MLXSW_THERMAL_MAX_STATE) / 10,\n\t\t.max_state\t= MLXSW_THERMAL_MAX_STATE,\n\t},\n\t{\n\t\t.min_state\t= MLXSW_THERMAL_MAX_STATE,\n\t\t.max_state\t= MLXSW_THERMAL_MAX_STATE,\n\t},\n};\n\n#define MLXSW_THERMAL_NUM_TRIPS\tARRAY_SIZE(default_thermal_trips)\n\n \n#define MLXSW_THERMAL_TRIP_MASK\t(BIT(MLXSW_THERMAL_NUM_TRIPS) - 1)\n\nstruct mlxsw_thermal;\n\nstruct mlxsw_thermal_module {\n\tstruct mlxsw_thermal *parent;\n\tstruct thermal_zone_device *tzdev;\n\tstruct thermal_trip trips[MLXSW_THERMAL_NUM_TRIPS];\n\tstruct mlxsw_cooling_states cooling_states[MLXSW_THERMAL_NUM_TRIPS];\n\tint module;  \n\tu8 slot_index;\n};\n\nstruct mlxsw_thermal_area {\n\tstruct mlxsw_thermal_module *tz_module_arr;\n\tu8 tz_module_num;\n\tstruct mlxsw_thermal_module *tz_gearbox_arr;\n\tu8 tz_gearbox_num;\n\tu8 slot_index;\n\tbool active;\n};\n\nstruct mlxsw_thermal {\n\tstruct mlxsw_core *core;\n\tconst struct mlxsw_bus_info *bus_info;\n\tstruct thermal_zone_device *tzdev;\n\tint polling_delay;\n\tstruct thermal_cooling_device *cdevs[MLXSW_MFCR_PWMS_MAX];\n\tstruct thermal_trip trips[MLXSW_THERMAL_NUM_TRIPS];\n\tstruct mlxsw_cooling_states cooling_states[MLXSW_THERMAL_NUM_TRIPS];\n\tstruct mlxsw_thermal_area line_cards[];\n};\n\nstatic inline u8 mlxsw_state_to_duty(int state)\n{\n\treturn DIV_ROUND_CLOSEST(state * MLXSW_THERMAL_MAX_DUTY,\n\t\t\t\t MLXSW_THERMAL_MAX_STATE);\n}\n\nstatic inline int mlxsw_duty_to_state(u8 duty)\n{\n\treturn DIV_ROUND_CLOSEST(duty * MLXSW_THERMAL_MAX_STATE,\n\t\t\t\t MLXSW_THERMAL_MAX_DUTY);\n}\n\nstatic int mlxsw_get_cooling_device_idx(struct mlxsw_thermal *thermal,\n\t\t\t\t\tstruct thermal_cooling_device *cdev)\n{\n\tint i;\n\n\tfor (i = 0; i < MLXSW_MFCR_PWMS_MAX; i++)\n\t\tif (thermal->cdevs[i] == cdev)\n\t\t\treturn i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mlxsw_thermal_external_allowed_cdev); i++) {\n\t\tif (!strcmp(cdev->type, mlxsw_thermal_external_allowed_cdev[i]))\n\t\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int mlxsw_thermal_bind(struct thermal_zone_device *tzdev,\n\t\t\t      struct thermal_cooling_device *cdev)\n{\n\tstruct mlxsw_thermal *thermal = thermal_zone_device_priv(tzdev);\n\tstruct device *dev = thermal->bus_info->dev;\n\tint i, err;\n\n\t \n\tif (mlxsw_get_cooling_device_idx(thermal, cdev) < 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < MLXSW_THERMAL_NUM_TRIPS; i++) {\n\t\tconst struct mlxsw_cooling_states *state = &thermal->cooling_states[i];\n\n\t\terr = thermal_zone_bind_cooling_device(tzdev, i, cdev,\n\t\t\t\t\t\t       state->max_state,\n\t\t\t\t\t\t       state->min_state,\n\t\t\t\t\t\t       THERMAL_WEIGHT_DEFAULT);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"Failed to bind cooling device to trip %d\\n\", i);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int mlxsw_thermal_unbind(struct thermal_zone_device *tzdev,\n\t\t\t\tstruct thermal_cooling_device *cdev)\n{\n\tstruct mlxsw_thermal *thermal = thermal_zone_device_priv(tzdev);\n\tstruct device *dev = thermal->bus_info->dev;\n\tint i;\n\tint err;\n\n\t \n\tif (mlxsw_get_cooling_device_idx(thermal, cdev) < 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < MLXSW_THERMAL_NUM_TRIPS; i++) {\n\t\terr = thermal_zone_unbind_cooling_device(tzdev, i, cdev);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"Failed to unbind cooling device\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int mlxsw_thermal_get_temp(struct thermal_zone_device *tzdev,\n\t\t\t\t  int *p_temp)\n{\n\tstruct mlxsw_thermal *thermal = thermal_zone_device_priv(tzdev);\n\tstruct device *dev = thermal->bus_info->dev;\n\tchar mtmp_pl[MLXSW_REG_MTMP_LEN];\n\tint temp;\n\tint err;\n\n\tmlxsw_reg_mtmp_pack(mtmp_pl, 0, 0, false, false);\n\n\terr = mlxsw_reg_query(thermal->core, MLXSW_REG(mtmp), mtmp_pl);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to query temp sensor\\n\");\n\t\treturn err;\n\t}\n\tmlxsw_reg_mtmp_unpack(mtmp_pl, &temp, NULL, NULL, NULL, NULL);\n\n\t*p_temp = temp;\n\treturn 0;\n}\n\nstatic struct thermal_zone_params mlxsw_thermal_params = {\n\t.no_hwmon = true,\n};\n\nstatic struct thermal_zone_device_ops mlxsw_thermal_ops = {\n\t.bind = mlxsw_thermal_bind,\n\t.unbind = mlxsw_thermal_unbind,\n\t.get_temp = mlxsw_thermal_get_temp,\n};\n\nstatic int mlxsw_thermal_module_bind(struct thermal_zone_device *tzdev,\n\t\t\t\t     struct thermal_cooling_device *cdev)\n{\n\tstruct mlxsw_thermal_module *tz = thermal_zone_device_priv(tzdev);\n\tstruct mlxsw_thermal *thermal = tz->parent;\n\tint i, j, err;\n\n\t \n\tif (mlxsw_get_cooling_device_idx(thermal, cdev) < 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < MLXSW_THERMAL_NUM_TRIPS; i++) {\n\t\tconst struct mlxsw_cooling_states *state = &tz->cooling_states[i];\n\n\t\terr = thermal_zone_bind_cooling_device(tzdev, i, cdev,\n\t\t\t\t\t\t       state->max_state,\n\t\t\t\t\t\t       state->min_state,\n\t\t\t\t\t\t       THERMAL_WEIGHT_DEFAULT);\n\t\tif (err < 0)\n\t\t\tgoto err_thermal_zone_bind_cooling_device;\n\t}\n\treturn 0;\n\nerr_thermal_zone_bind_cooling_device:\n\tfor (j = i - 1; j >= 0; j--)\n\t\tthermal_zone_unbind_cooling_device(tzdev, j, cdev);\n\treturn err;\n}\n\nstatic int mlxsw_thermal_module_unbind(struct thermal_zone_device *tzdev,\n\t\t\t\t       struct thermal_cooling_device *cdev)\n{\n\tstruct mlxsw_thermal_module *tz = thermal_zone_device_priv(tzdev);\n\tstruct mlxsw_thermal *thermal = tz->parent;\n\tint i;\n\tint err;\n\n\t \n\tif (mlxsw_get_cooling_device_idx(thermal, cdev) < 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < MLXSW_THERMAL_NUM_TRIPS; i++) {\n\t\terr = thermal_zone_unbind_cooling_device(tzdev, i, cdev);\n\t\tWARN_ON(err);\n\t}\n\treturn err;\n}\n\nstatic int mlxsw_thermal_module_temp_get(struct thermal_zone_device *tzdev,\n\t\t\t\t\t int *p_temp)\n{\n\tstruct mlxsw_thermal_module *tz = thermal_zone_device_priv(tzdev);\n\tstruct mlxsw_thermal *thermal = tz->parent;\n\tchar mtmp_pl[MLXSW_REG_MTMP_LEN];\n\tu16 sensor_index;\n\tint err;\n\n\tsensor_index = MLXSW_REG_MTMP_MODULE_INDEX_MIN + tz->module;\n\tmlxsw_reg_mtmp_pack(mtmp_pl, tz->slot_index, sensor_index,\n\t\t\t    false, false);\n\terr = mlxsw_reg_query(thermal->core, MLXSW_REG(mtmp), mtmp_pl);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_mtmp_unpack(mtmp_pl, p_temp, NULL, NULL, NULL, NULL);\n\treturn 0;\n}\n\nstatic struct thermal_zone_device_ops mlxsw_thermal_module_ops = {\n\t.bind\t\t= mlxsw_thermal_module_bind,\n\t.unbind\t\t= mlxsw_thermal_module_unbind,\n\t.get_temp\t= mlxsw_thermal_module_temp_get,\n};\n\nstatic int mlxsw_thermal_gearbox_temp_get(struct thermal_zone_device *tzdev,\n\t\t\t\t\t  int *p_temp)\n{\n\tstruct mlxsw_thermal_module *tz = thermal_zone_device_priv(tzdev);\n\tstruct mlxsw_thermal *thermal = tz->parent;\n\tchar mtmp_pl[MLXSW_REG_MTMP_LEN];\n\tu16 index;\n\tint temp;\n\tint err;\n\n\tindex = MLXSW_REG_MTMP_GBOX_INDEX_MIN + tz->module;\n\tmlxsw_reg_mtmp_pack(mtmp_pl, tz->slot_index, index, false, false);\n\n\terr = mlxsw_reg_query(thermal->core, MLXSW_REG(mtmp), mtmp_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mtmp_unpack(mtmp_pl, &temp, NULL, NULL, NULL, NULL);\n\n\t*p_temp = temp;\n\treturn 0;\n}\n\nstatic struct thermal_zone_device_ops mlxsw_thermal_gearbox_ops = {\n\t.bind\t\t= mlxsw_thermal_module_bind,\n\t.unbind\t\t= mlxsw_thermal_module_unbind,\n\t.get_temp\t= mlxsw_thermal_gearbox_temp_get,\n};\n\nstatic int mlxsw_thermal_get_max_state(struct thermal_cooling_device *cdev,\n\t\t\t\t       unsigned long *p_state)\n{\n\t*p_state = MLXSW_THERMAL_MAX_STATE;\n\treturn 0;\n}\n\nstatic int mlxsw_thermal_get_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t       unsigned long *p_state)\n\n{\n\tstruct mlxsw_thermal *thermal = cdev->devdata;\n\tstruct device *dev = thermal->bus_info->dev;\n\tchar mfsc_pl[MLXSW_REG_MFSC_LEN];\n\tint err, idx;\n\tu8 duty;\n\n\tidx = mlxsw_get_cooling_device_idx(thermal, cdev);\n\tif (idx < 0)\n\t\treturn idx;\n\n\tmlxsw_reg_mfsc_pack(mfsc_pl, idx, 0);\n\terr = mlxsw_reg_query(thermal->core, MLXSW_REG(mfsc), mfsc_pl);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to query PWM duty\\n\");\n\t\treturn err;\n\t}\n\n\tduty = mlxsw_reg_mfsc_pwm_duty_cycle_get(mfsc_pl);\n\t*p_state = mlxsw_duty_to_state(duty);\n\treturn 0;\n}\n\nstatic int mlxsw_thermal_set_cur_state(struct thermal_cooling_device *cdev,\n\t\t\t\t       unsigned long state)\n\n{\n\tstruct mlxsw_thermal *thermal = cdev->devdata;\n\tstruct device *dev = thermal->bus_info->dev;\n\tchar mfsc_pl[MLXSW_REG_MFSC_LEN];\n\tint idx;\n\tint err;\n\n\tif (state > MLXSW_THERMAL_MAX_STATE)\n\t\treturn -EINVAL;\n\n\tidx = mlxsw_get_cooling_device_idx(thermal, cdev);\n\tif (idx < 0)\n\t\treturn idx;\n\n\t \n\tstate = max_t(unsigned long, MLXSW_THERMAL_MIN_STATE, state);\n\tmlxsw_reg_mfsc_pack(mfsc_pl, idx, mlxsw_state_to_duty(state));\n\terr = mlxsw_reg_write(thermal->core, MLXSW_REG(mfsc), mfsc_pl);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to write PWM duty\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic const struct thermal_cooling_device_ops mlxsw_cooling_ops = {\n\t.get_max_state\t= mlxsw_thermal_get_max_state,\n\t.get_cur_state\t= mlxsw_thermal_get_cur_state,\n\t.set_cur_state\t= mlxsw_thermal_set_cur_state,\n};\n\nstatic int\nmlxsw_thermal_module_tz_init(struct mlxsw_thermal_module *module_tz)\n{\n\tchar tz_name[THERMAL_NAME_LENGTH];\n\tint err;\n\n\tif (module_tz->slot_index)\n\t\tsnprintf(tz_name, sizeof(tz_name), \"mlxsw-lc%d-module%d\",\n\t\t\t module_tz->slot_index, module_tz->module + 1);\n\telse\n\t\tsnprintf(tz_name, sizeof(tz_name), \"mlxsw-module%d\",\n\t\t\t module_tz->module + 1);\n\tmodule_tz->tzdev = thermal_zone_device_register_with_trips(tz_name,\n\t\t\t\t\t\t\tmodule_tz->trips,\n\t\t\t\t\t\t\tMLXSW_THERMAL_NUM_TRIPS,\n\t\t\t\t\t\t\tMLXSW_THERMAL_TRIP_MASK,\n\t\t\t\t\t\t\tmodule_tz,\n\t\t\t\t\t\t\t&mlxsw_thermal_module_ops,\n\t\t\t\t\t\t\t&mlxsw_thermal_params,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tmodule_tz->parent->polling_delay);\n\tif (IS_ERR(module_tz->tzdev)) {\n\t\terr = PTR_ERR(module_tz->tzdev);\n\t\treturn err;\n\t}\n\n\terr = thermal_zone_device_enable(module_tz->tzdev);\n\tif (err)\n\t\tthermal_zone_device_unregister(module_tz->tzdev);\n\n\treturn err;\n}\n\nstatic void mlxsw_thermal_module_tz_fini(struct thermal_zone_device *tzdev)\n{\n\tthermal_zone_device_unregister(tzdev);\n}\n\nstatic void\nmlxsw_thermal_module_init(struct device *dev, struct mlxsw_core *core,\n\t\t\t  struct mlxsw_thermal *thermal,\n\t\t\t  struct mlxsw_thermal_area *area, u8 module)\n{\n\tstruct mlxsw_thermal_module *module_tz;\n\n\tmodule_tz = &area->tz_module_arr[module];\n\t \n\tif (module_tz->parent)\n\t\treturn;\n\tmodule_tz->module = module;\n\tmodule_tz->slot_index = area->slot_index;\n\tmodule_tz->parent = thermal;\n\tBUILD_BUG_ON(ARRAY_SIZE(default_thermal_module_trips) !=\n\t\t     MLXSW_THERMAL_NUM_TRIPS);\n\tmemcpy(module_tz->trips, default_thermal_module_trips,\n\t       sizeof(thermal->trips));\n\tmemcpy(module_tz->cooling_states, default_cooling_states,\n\t       sizeof(thermal->cooling_states));\n}\n\nstatic void mlxsw_thermal_module_fini(struct mlxsw_thermal_module *module_tz)\n{\n\tif (module_tz && module_tz->tzdev) {\n\t\tmlxsw_thermal_module_tz_fini(module_tz->tzdev);\n\t\tmodule_tz->tzdev = NULL;\n\t\tmodule_tz->parent = NULL;\n\t}\n}\n\nstatic int\nmlxsw_thermal_modules_init(struct device *dev, struct mlxsw_core *core,\n\t\t\t   struct mlxsw_thermal *thermal,\n\t\t\t   struct mlxsw_thermal_area *area)\n{\n\tstruct mlxsw_thermal_module *module_tz;\n\tchar mgpir_pl[MLXSW_REG_MGPIR_LEN];\n\tint i, err;\n\n\tmlxsw_reg_mgpir_pack(mgpir_pl, area->slot_index);\n\terr = mlxsw_reg_query(core, MLXSW_REG(mgpir), mgpir_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mgpir_unpack(mgpir_pl, NULL, NULL, NULL,\n\t\t\t       &area->tz_module_num, NULL);\n\n\t \n\tif (!area->tz_module_num)\n\t\treturn 0;\n\n\tarea->tz_module_arr = kcalloc(area->tz_module_num,\n\t\t\t\t      sizeof(*area->tz_module_arr),\n\t\t\t\t      GFP_KERNEL);\n\tif (!area->tz_module_arr)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < area->tz_module_num; i++)\n\t\tmlxsw_thermal_module_init(dev, core, thermal, area, i);\n\n\tfor (i = 0; i < area->tz_module_num; i++) {\n\t\tmodule_tz = &area->tz_module_arr[i];\n\t\tif (!module_tz->parent)\n\t\t\tcontinue;\n\t\terr = mlxsw_thermal_module_tz_init(module_tz);\n\t\tif (err)\n\t\t\tgoto err_thermal_module_tz_init;\n\t}\n\n\treturn 0;\n\nerr_thermal_module_tz_init:\n\tfor (i = area->tz_module_num - 1; i >= 0; i--)\n\t\tmlxsw_thermal_module_fini(&area->tz_module_arr[i]);\n\tkfree(area->tz_module_arr);\n\treturn err;\n}\n\nstatic void\nmlxsw_thermal_modules_fini(struct mlxsw_thermal *thermal,\n\t\t\t   struct mlxsw_thermal_area *area)\n{\n\tint i;\n\n\tfor (i = area->tz_module_num - 1; i >= 0; i--)\n\t\tmlxsw_thermal_module_fini(&area->tz_module_arr[i]);\n\tkfree(area->tz_module_arr);\n}\n\nstatic int\nmlxsw_thermal_gearbox_tz_init(struct mlxsw_thermal_module *gearbox_tz)\n{\n\tchar tz_name[THERMAL_NAME_LENGTH];\n\tint ret;\n\n\tif (gearbox_tz->slot_index)\n\t\tsnprintf(tz_name, sizeof(tz_name), \"mlxsw-lc%d-gearbox%d\",\n\t\t\t gearbox_tz->slot_index, gearbox_tz->module + 1);\n\telse\n\t\tsnprintf(tz_name, sizeof(tz_name), \"mlxsw-gearbox%d\",\n\t\t\t gearbox_tz->module + 1);\n\tgearbox_tz->tzdev = thermal_zone_device_register_with_trips(tz_name,\n\t\t\t\t\t\tgearbox_tz->trips,\n\t\t\t\t\t\tMLXSW_THERMAL_NUM_TRIPS,\n\t\t\t\t\t\tMLXSW_THERMAL_TRIP_MASK,\n\t\t\t\t\t\tgearbox_tz,\n\t\t\t\t\t\t&mlxsw_thermal_gearbox_ops,\n\t\t\t\t\t\t&mlxsw_thermal_params, 0,\n\t\t\t\t\t\tgearbox_tz->parent->polling_delay);\n\tif (IS_ERR(gearbox_tz->tzdev))\n\t\treturn PTR_ERR(gearbox_tz->tzdev);\n\n\tret = thermal_zone_device_enable(gearbox_tz->tzdev);\n\tif (ret)\n\t\tthermal_zone_device_unregister(gearbox_tz->tzdev);\n\n\treturn ret;\n}\n\nstatic void\nmlxsw_thermal_gearbox_tz_fini(struct mlxsw_thermal_module *gearbox_tz)\n{\n\tthermal_zone_device_unregister(gearbox_tz->tzdev);\n}\n\nstatic int\nmlxsw_thermal_gearboxes_init(struct device *dev, struct mlxsw_core *core,\n\t\t\t     struct mlxsw_thermal *thermal,\n\t\t\t     struct mlxsw_thermal_area *area)\n{\n\tenum mlxsw_reg_mgpir_device_type device_type;\n\tstruct mlxsw_thermal_module *gearbox_tz;\n\tchar mgpir_pl[MLXSW_REG_MGPIR_LEN];\n\tu8 gbox_num;\n\tint i;\n\tint err;\n\n\tmlxsw_reg_mgpir_pack(mgpir_pl, area->slot_index);\n\terr = mlxsw_reg_query(core, MLXSW_REG(mgpir), mgpir_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mgpir_unpack(mgpir_pl, &gbox_num, &device_type, NULL,\n\t\t\t       NULL, NULL);\n\tif (device_type != MLXSW_REG_MGPIR_DEVICE_TYPE_GEARBOX_DIE ||\n\t    !gbox_num)\n\t\treturn 0;\n\n\tarea->tz_gearbox_num = gbox_num;\n\tarea->tz_gearbox_arr = kcalloc(area->tz_gearbox_num,\n\t\t\t\t       sizeof(*area->tz_gearbox_arr),\n\t\t\t\t       GFP_KERNEL);\n\tif (!area->tz_gearbox_arr)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < area->tz_gearbox_num; i++) {\n\t\tgearbox_tz = &area->tz_gearbox_arr[i];\n\t\tmemcpy(gearbox_tz->trips, default_thermal_trips,\n\t\t       sizeof(thermal->trips));\n\t\tmemcpy(gearbox_tz->cooling_states, default_cooling_states,\n\t\t       sizeof(thermal->cooling_states));\n\t\tgearbox_tz->module = i;\n\t\tgearbox_tz->parent = thermal;\n\t\tgearbox_tz->slot_index = area->slot_index;\n\t\terr = mlxsw_thermal_gearbox_tz_init(gearbox_tz);\n\t\tif (err)\n\t\t\tgoto err_thermal_gearbox_tz_init;\n\t}\n\n\treturn 0;\n\nerr_thermal_gearbox_tz_init:\n\tfor (i--; i >= 0; i--)\n\t\tmlxsw_thermal_gearbox_tz_fini(&area->tz_gearbox_arr[i]);\n\tkfree(area->tz_gearbox_arr);\n\treturn err;\n}\n\nstatic void\nmlxsw_thermal_gearboxes_fini(struct mlxsw_thermal *thermal,\n\t\t\t     struct mlxsw_thermal_area *area)\n{\n\tint i;\n\n\tfor (i = area->tz_gearbox_num - 1; i >= 0; i--)\n\t\tmlxsw_thermal_gearbox_tz_fini(&area->tz_gearbox_arr[i]);\n\tkfree(area->tz_gearbox_arr);\n}\n\nstatic void\nmlxsw_thermal_got_active(struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t void *priv)\n{\n\tstruct mlxsw_thermal *thermal = priv;\n\tstruct mlxsw_thermal_area *linecard;\n\tint err;\n\n\tlinecard = &thermal->line_cards[slot_index];\n\n\tif (linecard->active)\n\t\treturn;\n\n\tlinecard->slot_index = slot_index;\n\terr = mlxsw_thermal_modules_init(thermal->bus_info->dev, thermal->core,\n\t\t\t\t\t thermal, linecard);\n\tif (err) {\n\t\tdev_err(thermal->bus_info->dev, \"Failed to configure thermal objects for line card modules in slot %d\\n\",\n\t\t\tslot_index);\n\t\treturn;\n\t}\n\n\terr = mlxsw_thermal_gearboxes_init(thermal->bus_info->dev,\n\t\t\t\t\t   thermal->core, thermal, linecard);\n\tif (err) {\n\t\tdev_err(thermal->bus_info->dev, \"Failed to configure thermal objects for line card gearboxes in slot %d\\n\",\n\t\t\tslot_index);\n\t\tgoto err_thermal_linecard_gearboxes_init;\n\t}\n\n\tlinecard->active = true;\n\n\treturn;\n\nerr_thermal_linecard_gearboxes_init:\n\tmlxsw_thermal_modules_fini(thermal, linecard);\n}\n\nstatic void\nmlxsw_thermal_got_inactive(struct mlxsw_core *mlxsw_core, u8 slot_index,\n\t\t\t   void *priv)\n{\n\tstruct mlxsw_thermal *thermal = priv;\n\tstruct mlxsw_thermal_area *linecard;\n\n\tlinecard = &thermal->line_cards[slot_index];\n\tif (!linecard->active)\n\t\treturn;\n\tlinecard->active = false;\n\tmlxsw_thermal_gearboxes_fini(thermal, linecard);\n\tmlxsw_thermal_modules_fini(thermal, linecard);\n}\n\nstatic struct mlxsw_linecards_event_ops mlxsw_thermal_event_ops = {\n\t.got_active = mlxsw_thermal_got_active,\n\t.got_inactive = mlxsw_thermal_got_inactive,\n};\n\nint mlxsw_thermal_init(struct mlxsw_core *core,\n\t\t       const struct mlxsw_bus_info *bus_info,\n\t\t       struct mlxsw_thermal **p_thermal)\n{\n\tchar mfcr_pl[MLXSW_REG_MFCR_LEN] = { 0 };\n\tenum mlxsw_reg_mfcr_pwm_frequency freq;\n\tstruct device *dev = bus_info->dev;\n\tchar mgpir_pl[MLXSW_REG_MGPIR_LEN];\n\tstruct mlxsw_thermal *thermal;\n\tu8 pwm_active, num_of_slots;\n\tu16 tacho_active;\n\tint err, i;\n\n\tmlxsw_reg_mgpir_pack(mgpir_pl, 0);\n\terr = mlxsw_reg_query(core, MLXSW_REG(mgpir), mgpir_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mgpir_unpack(mgpir_pl, NULL, NULL, NULL, NULL,\n\t\t\t       &num_of_slots);\n\n\tthermal = kzalloc(struct_size(thermal, line_cards, num_of_slots + 1),\n\t\t\t  GFP_KERNEL);\n\tif (!thermal)\n\t\treturn -ENOMEM;\n\n\tthermal->core = core;\n\tthermal->bus_info = bus_info;\n\tmemcpy(thermal->trips, default_thermal_trips, sizeof(thermal->trips));\n\tmemcpy(thermal->cooling_states, default_cooling_states, sizeof(thermal->cooling_states));\n\tthermal->line_cards[0].slot_index = 0;\n\n\terr = mlxsw_reg_query(thermal->core, MLXSW_REG(mfcr), mfcr_pl);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to probe PWMs\\n\");\n\t\tgoto err_reg_query;\n\t}\n\tmlxsw_reg_mfcr_unpack(mfcr_pl, &freq, &tacho_active, &pwm_active);\n\n\tfor (i = 0; i < MLXSW_MFCR_TACHOS_MAX; i++) {\n\t\tif (tacho_active & BIT(i)) {\n\t\t\tchar mfsl_pl[MLXSW_REG_MFSL_LEN];\n\n\t\t\tmlxsw_reg_mfsl_pack(mfsl_pl, i, 0, 0);\n\n\t\t\t \n\t\t\terr = mlxsw_reg_query(thermal->core, MLXSW_REG(mfsl),\n\t\t\t\t\t      mfsl_pl);\n\t\t\tif (err)\n\t\t\t\tgoto err_reg_query;\n\n\t\t\t \n\t\t\tmlxsw_reg_mfsl_tach_min_set(mfsl_pl, 0);\n\t\t\terr = mlxsw_reg_write(thermal->core, MLXSW_REG(mfsl),\n\t\t\t\t\t      mfsl_pl);\n\t\t\tif (err)\n\t\t\t\tgoto err_reg_write;\n\t\t}\n\t}\n\tfor (i = 0; i < MLXSW_MFCR_PWMS_MAX; i++) {\n\t\tif (pwm_active & BIT(i)) {\n\t\t\tstruct thermal_cooling_device *cdev;\n\n\t\t\tcdev = thermal_cooling_device_register(\"mlxsw_fan\",\n\t\t\t\t\t\t\t       thermal,\n\t\t\t\t\t\t\t       &mlxsw_cooling_ops);\n\t\t\tif (IS_ERR(cdev)) {\n\t\t\t\terr = PTR_ERR(cdev);\n\t\t\t\tdev_err(dev, \"Failed to register cooling device\\n\");\n\t\t\t\tgoto err_thermal_cooling_device_register;\n\t\t\t}\n\t\t\tthermal->cdevs[i] = cdev;\n\t\t}\n\t}\n\n\tthermal->polling_delay = bus_info->low_frequency ?\n\t\t\t\t MLXSW_THERMAL_SLOW_POLL_INT :\n\t\t\t\t MLXSW_THERMAL_POLL_INT;\n\n\tthermal->tzdev = thermal_zone_device_register_with_trips(\"mlxsw\",\n\t\t\t\t\t\t      thermal->trips,\n\t\t\t\t\t\t      MLXSW_THERMAL_NUM_TRIPS,\n\t\t\t\t\t\t      MLXSW_THERMAL_TRIP_MASK,\n\t\t\t\t\t\t      thermal,\n\t\t\t\t\t\t      &mlxsw_thermal_ops,\n\t\t\t\t\t\t      &mlxsw_thermal_params, 0,\n\t\t\t\t\t\t      thermal->polling_delay);\n\tif (IS_ERR(thermal->tzdev)) {\n\t\terr = PTR_ERR(thermal->tzdev);\n\t\tdev_err(dev, \"Failed to register thermal zone\\n\");\n\t\tgoto err_thermal_zone_device_register;\n\t}\n\n\terr = mlxsw_thermal_modules_init(dev, core, thermal,\n\t\t\t\t\t &thermal->line_cards[0]);\n\tif (err)\n\t\tgoto err_thermal_modules_init;\n\n\terr = mlxsw_thermal_gearboxes_init(dev, core, thermal,\n\t\t\t\t\t   &thermal->line_cards[0]);\n\tif (err)\n\t\tgoto err_thermal_gearboxes_init;\n\n\terr = mlxsw_linecards_event_ops_register(core,\n\t\t\t\t\t\t &mlxsw_thermal_event_ops,\n\t\t\t\t\t\t thermal);\n\tif (err)\n\t\tgoto err_linecards_event_ops_register;\n\n\terr = thermal_zone_device_enable(thermal->tzdev);\n\tif (err)\n\t\tgoto err_thermal_zone_device_enable;\n\n\tthermal->line_cards[0].active = true;\n\t*p_thermal = thermal;\n\treturn 0;\n\nerr_thermal_zone_device_enable:\n\tmlxsw_linecards_event_ops_unregister(thermal->core,\n\t\t\t\t\t     &mlxsw_thermal_event_ops,\n\t\t\t\t\t     thermal);\nerr_linecards_event_ops_register:\n\tmlxsw_thermal_gearboxes_fini(thermal, &thermal->line_cards[0]);\nerr_thermal_gearboxes_init:\n\tmlxsw_thermal_modules_fini(thermal, &thermal->line_cards[0]);\nerr_thermal_modules_init:\n\tif (thermal->tzdev) {\n\t\tthermal_zone_device_unregister(thermal->tzdev);\n\t\tthermal->tzdev = NULL;\n\t}\nerr_thermal_zone_device_register:\nerr_thermal_cooling_device_register:\n\tfor (i = 0; i < MLXSW_MFCR_PWMS_MAX; i++)\n\t\tif (thermal->cdevs[i])\n\t\t\tthermal_cooling_device_unregister(thermal->cdevs[i]);\nerr_reg_write:\nerr_reg_query:\n\tkfree(thermal);\n\treturn err;\n}\n\nvoid mlxsw_thermal_fini(struct mlxsw_thermal *thermal)\n{\n\tint i;\n\n\tthermal->line_cards[0].active = false;\n\tmlxsw_linecards_event_ops_unregister(thermal->core,\n\t\t\t\t\t     &mlxsw_thermal_event_ops,\n\t\t\t\t\t     thermal);\n\tmlxsw_thermal_gearboxes_fini(thermal, &thermal->line_cards[0]);\n\tmlxsw_thermal_modules_fini(thermal, &thermal->line_cards[0]);\n\tif (thermal->tzdev) {\n\t\tthermal_zone_device_unregister(thermal->tzdev);\n\t\tthermal->tzdev = NULL;\n\t}\n\n\tfor (i = 0; i < MLXSW_MFCR_PWMS_MAX; i++) {\n\t\tif (thermal->cdevs[i]) {\n\t\t\tthermal_cooling_device_unregister(thermal->cdevs[i]);\n\t\t\tthermal->cdevs[i] = NULL;\n\t\t}\n\t}\n\n\tkfree(thermal);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}