{
  "module_name": "spectrum_mr.c",
  "hash_id": "93a1e0f4ceabc06bbabab5c7e1fd66546bcf6d4f7d5349bf4be560cca64a0f68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_mr.c",
  "human_readable_source": "\n \n\n#include <linux/mutex.h>\n#include <linux/rhashtable.h>\n#include <net/ipv6.h>\n\n#include \"spectrum_mr.h\"\n#include \"spectrum_router.h\"\n\nstruct mlxsw_sp_mr {\n\tconst struct mlxsw_sp_mr_ops *mr_ops;\n\tvoid *catchall_route_priv;\n\tstruct delayed_work stats_update_dw;\n\tstruct list_head table_list;\n\tstruct mutex table_list_lock;  \n#define MLXSW_SP_MR_ROUTES_COUNTER_UPDATE_INTERVAL 5000  \n\tunsigned long priv[];\n\t \n};\n\nstruct mlxsw_sp_mr_vif;\nstruct mlxsw_sp_mr_vif_ops {\n\tbool (*is_regular)(const struct mlxsw_sp_mr_vif *vif);\n};\n\nstruct mlxsw_sp_mr_vif {\n\tstruct net_device *dev;\n\tconst struct mlxsw_sp_rif *rif;\n\tunsigned long vif_flags;\n\n\t \n\tstruct list_head route_evif_list;\n\n\t \n\tstruct list_head route_ivif_list;\n\n\t \n\tconst struct mlxsw_sp_mr_vif_ops *ops;\n};\n\nstruct mlxsw_sp_mr_route_vif_entry {\n\tstruct list_head vif_node;\n\tstruct list_head route_node;\n\tstruct mlxsw_sp_mr_vif *mr_vif;\n\tstruct mlxsw_sp_mr_route *mr_route;\n};\n\nstruct mlxsw_sp_mr_table;\nstruct mlxsw_sp_mr_table_ops {\n\tbool (*is_route_valid)(const struct mlxsw_sp_mr_table *mr_table,\n\t\t\t       const struct mr_mfc *mfc);\n\tvoid (*key_create)(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t   struct mlxsw_sp_mr_route_key *key,\n\t\t\t   struct mr_mfc *mfc);\n\tbool (*is_route_starg)(const struct mlxsw_sp_mr_table *mr_table,\n\t\t\t       const struct mlxsw_sp_mr_route *mr_route);\n};\n\nstruct mlxsw_sp_mr_table {\n\tstruct list_head node;\n\tenum mlxsw_sp_l3proto proto;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tu32 vr_id;\n\tstruct mlxsw_sp_mr_vif vifs[MAXVIFS];\n\tstruct list_head route_list;\n\tstruct mutex route_list_lock;  \n\tstruct rhashtable route_ht;\n\tconst struct mlxsw_sp_mr_table_ops *ops;\n\tchar catchall_route_priv[];\n\t \n};\n\nstruct mlxsw_sp_mr_route {\n\tstruct list_head node;\n\tstruct rhash_head ht_node;\n\tstruct mlxsw_sp_mr_route_key key;\n\tenum mlxsw_sp_mr_route_action route_action;\n\tu16 min_mtu;\n\tstruct mr_mfc *mfc;\n\tvoid *route_priv;\n\tconst struct mlxsw_sp_mr_table *mr_table;\n\t \n\tstruct list_head evif_list;\n\t \n\tstruct mlxsw_sp_mr_route_vif_entry ivif;\n};\n\nstatic const struct rhashtable_params mlxsw_sp_mr_route_ht_params = {\n\t.key_len = sizeof(struct mlxsw_sp_mr_route_key),\n\t.key_offset = offsetof(struct mlxsw_sp_mr_route, key),\n\t.head_offset = offsetof(struct mlxsw_sp_mr_route, ht_node),\n\t.automatic_shrinking = true,\n};\n\nstatic bool mlxsw_sp_mr_vif_valid(const struct mlxsw_sp_mr_vif *vif)\n{\n\treturn vif->ops->is_regular(vif) && vif->dev && vif->rif;\n}\n\nstatic bool mlxsw_sp_mr_vif_exists(const struct mlxsw_sp_mr_vif *vif)\n{\n\treturn vif->dev;\n}\n\nstatic bool\nmlxsw_sp_mr_route_ivif_in_evifs(const struct mlxsw_sp_mr_route *mr_route)\n{\n\tvifi_t ivif = mr_route->mfc->mfc_parent;\n\n\treturn mr_route->mfc->mfc_un.res.ttls[ivif] != 255;\n}\n\nstatic int\nmlxsw_sp_mr_route_valid_evifs_num(const struct mlxsw_sp_mr_route *mr_route)\n{\n\tstruct mlxsw_sp_mr_route_vif_entry *rve;\n\tint valid_evifs;\n\n\tvalid_evifs = 0;\n\tlist_for_each_entry(rve, &mr_route->evif_list, route_node)\n\t\tif (mlxsw_sp_mr_vif_valid(rve->mr_vif))\n\t\t\tvalid_evifs++;\n\treturn valid_evifs;\n}\n\nstatic enum mlxsw_sp_mr_route_action\nmlxsw_sp_mr_route_action(const struct mlxsw_sp_mr_route *mr_route)\n{\n\tstruct mlxsw_sp_mr_route_vif_entry *rve;\n\n\t \n\tif (!mlxsw_sp_mr_vif_valid(mr_route->ivif.mr_vif))\n\t\treturn MLXSW_SP_MR_ROUTE_ACTION_TRAP;\n\n\t \n\tif (mr_route->mr_table->ops->is_route_starg(mr_route->mr_table,\n\t\t\t\t\t\t    mr_route) &&\n\t    !mlxsw_sp_mr_route_ivif_in_evifs(mr_route))\n\t\treturn MLXSW_SP_MR_ROUTE_ACTION_TRAP;\n\n\t \n\tif (!mlxsw_sp_mr_route_valid_evifs_num(mr_route))\n\t\treturn MLXSW_SP_MR_ROUTE_ACTION_TRAP;\n\n\t \n\tlist_for_each_entry(rve, &mr_route->evif_list, route_node)\n\t\tif (mlxsw_sp_mr_vif_exists(rve->mr_vif) && !rve->mr_vif->rif)\n\t\t\treturn MLXSW_SP_MR_ROUTE_ACTION_TRAP_AND_FORWARD;\n\n\treturn MLXSW_SP_MR_ROUTE_ACTION_FORWARD;\n}\n\nstatic enum mlxsw_sp_mr_route_prio\nmlxsw_sp_mr_route_prio(const struct mlxsw_sp_mr_route *mr_route)\n{\n\treturn mr_route->mr_table->ops->is_route_starg(mr_route->mr_table,\n\t\t\t\t\t\t       mr_route) ?\n\t\tMLXSW_SP_MR_ROUTE_PRIO_STARG : MLXSW_SP_MR_ROUTE_PRIO_SG;\n}\n\nstatic int mlxsw_sp_mr_route_evif_link(struct mlxsw_sp_mr_route *mr_route,\n\t\t\t\t       struct mlxsw_sp_mr_vif *mr_vif)\n{\n\tstruct mlxsw_sp_mr_route_vif_entry *rve;\n\n\trve = kzalloc(sizeof(*rve), GFP_KERNEL);\n\tif (!rve)\n\t\treturn -ENOMEM;\n\trve->mr_route = mr_route;\n\trve->mr_vif = mr_vif;\n\tlist_add_tail(&rve->route_node, &mr_route->evif_list);\n\tlist_add_tail(&rve->vif_node, &mr_vif->route_evif_list);\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_mr_route_evif_unlink(struct mlxsw_sp_mr_route_vif_entry *rve)\n{\n\tlist_del(&rve->route_node);\n\tlist_del(&rve->vif_node);\n\tkfree(rve);\n}\n\nstatic void mlxsw_sp_mr_route_ivif_link(struct mlxsw_sp_mr_route *mr_route,\n\t\t\t\t\tstruct mlxsw_sp_mr_vif *mr_vif)\n{\n\tmr_route->ivif.mr_route = mr_route;\n\tmr_route->ivif.mr_vif = mr_vif;\n\tlist_add_tail(&mr_route->ivif.vif_node, &mr_vif->route_ivif_list);\n}\n\nstatic void mlxsw_sp_mr_route_ivif_unlink(struct mlxsw_sp_mr_route *mr_route)\n{\n\tlist_del(&mr_route->ivif.vif_node);\n}\n\nstatic int\nmlxsw_sp_mr_route_info_create(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t      struct mlxsw_sp_mr_route *mr_route,\n\t\t\t      struct mlxsw_sp_mr_route_info *route_info)\n{\n\tstruct mlxsw_sp_mr_route_vif_entry *rve;\n\tu16 *erif_indices;\n\tu16 irif_index;\n\tu16 erif = 0;\n\n\terif_indices = kmalloc_array(MAXVIFS, sizeof(*erif_indices),\n\t\t\t\t     GFP_KERNEL);\n\tif (!erif_indices)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(rve, &mr_route->evif_list, route_node) {\n\t\tif (mlxsw_sp_mr_vif_valid(rve->mr_vif)) {\n\t\t\tu16 rifi = mlxsw_sp_rif_index(rve->mr_vif->rif);\n\n\t\t\terif_indices[erif++] = rifi;\n\t\t}\n\t}\n\n\tif (mlxsw_sp_mr_vif_valid(mr_route->ivif.mr_vif))\n\t\tirif_index = mlxsw_sp_rif_index(mr_route->ivif.mr_vif->rif);\n\telse\n\t\tirif_index = 0;\n\n\troute_info->irif_index = irif_index;\n\troute_info->erif_indices = erif_indices;\n\troute_info->min_mtu = mr_route->min_mtu;\n\troute_info->route_action = mr_route->route_action;\n\troute_info->erif_num = erif;\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_mr_route_info_destroy(struct mlxsw_sp_mr_route_info *route_info)\n{\n\tkfree(route_info->erif_indices);\n}\n\nstatic int mlxsw_sp_mr_route_write(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t\t   struct mlxsw_sp_mr_route *mr_route,\n\t\t\t\t   bool replace)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mr_table->mlxsw_sp;\n\tstruct mlxsw_sp_mr_route_info route_info;\n\tstruct mlxsw_sp_mr *mr = mlxsw_sp->mr;\n\tint err;\n\n\terr = mlxsw_sp_mr_route_info_create(mr_table, mr_route, &route_info);\n\tif (err)\n\t\treturn err;\n\n\tif (!replace) {\n\t\tstruct mlxsw_sp_mr_route_params route_params;\n\n\t\tmr_route->route_priv = kzalloc(mr->mr_ops->route_priv_size,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!mr_route->route_priv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\troute_params.key = mr_route->key;\n\t\troute_params.value = route_info;\n\t\troute_params.prio = mlxsw_sp_mr_route_prio(mr_route);\n\t\terr = mr->mr_ops->route_create(mlxsw_sp, mr->priv,\n\t\t\t\t\t       mr_route->route_priv,\n\t\t\t\t\t       &route_params);\n\t\tif (err)\n\t\t\tkfree(mr_route->route_priv);\n\t} else {\n\t\terr = mr->mr_ops->route_update(mlxsw_sp, mr_route->route_priv,\n\t\t\t\t\t       &route_info);\n\t}\nout:\n\tmlxsw_sp_mr_route_info_destroy(&route_info);\n\treturn err;\n}\n\nstatic void mlxsw_sp_mr_route_erase(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t\t    struct mlxsw_sp_mr_route *mr_route)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mr_table->mlxsw_sp;\n\tstruct mlxsw_sp_mr *mr = mlxsw_sp->mr;\n\n\tmr->mr_ops->route_destroy(mlxsw_sp, mr->priv, mr_route->route_priv);\n\tkfree(mr_route->route_priv);\n}\n\nstatic struct mlxsw_sp_mr_route *\nmlxsw_sp_mr_route_create(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t struct mr_mfc *mfc)\n{\n\tstruct mlxsw_sp_mr_route_vif_entry *rve, *tmp;\n\tstruct mlxsw_sp_mr_route *mr_route;\n\tint err = 0;\n\tint i;\n\n\t \n\tmr_route = kzalloc(sizeof(*mr_route), GFP_KERNEL);\n\tif (!mr_route)\n\t\treturn ERR_PTR(-ENOMEM);\n\tINIT_LIST_HEAD(&mr_route->evif_list);\n\n\t \n\tmr_route->min_mtu = ETH_MAX_MTU;\n\tmr_cache_hold(mfc);\n\tmr_route->mfc = mfc;\n\tmr_table->ops->key_create(mr_table, &mr_route->key, mr_route->mfc);\n\n\tmr_route->mr_table = mr_table;\n\tfor (i = 0; i < MAXVIFS; i++) {\n\t\tif (mfc->mfc_un.res.ttls[i] != 255) {\n\t\t\terr = mlxsw_sp_mr_route_evif_link(mr_route,\n\t\t\t\t\t\t\t  &mr_table->vifs[i]);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t\tif (mr_table->vifs[i].dev &&\n\t\t\t    mr_table->vifs[i].dev->mtu < mr_route->min_mtu)\n\t\t\t\tmr_route->min_mtu = mr_table->vifs[i].dev->mtu;\n\t\t}\n\t}\n\tmlxsw_sp_mr_route_ivif_link(mr_route,\n\t\t\t\t    &mr_table->vifs[mfc->mfc_parent]);\n\n\tmr_route->route_action = mlxsw_sp_mr_route_action(mr_route);\n\treturn mr_route;\nerr:\n\tmr_cache_put(mfc);\n\tlist_for_each_entry_safe(rve, tmp, &mr_route->evif_list, route_node)\n\t\tmlxsw_sp_mr_route_evif_unlink(rve);\n\tkfree(mr_route);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_mr_route_destroy(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t\t      struct mlxsw_sp_mr_route *mr_route)\n{\n\tstruct mlxsw_sp_mr_route_vif_entry *rve, *tmp;\n\n\tmlxsw_sp_mr_route_ivif_unlink(mr_route);\n\tmr_cache_put(mr_route->mfc);\n\tlist_for_each_entry_safe(rve, tmp, &mr_route->evif_list, route_node)\n\t\tmlxsw_sp_mr_route_evif_unlink(rve);\n\tkfree(mr_route);\n}\n\nstatic void mlxsw_sp_mr_mfc_offload_set(struct mlxsw_sp_mr_route *mr_route,\n\t\t\t\t\tbool offload)\n{\n\tif (offload)\n\t\tmr_route->mfc->mfc_flags |= MFC_OFFLOAD;\n\telse\n\t\tmr_route->mfc->mfc_flags &= ~MFC_OFFLOAD;\n}\n\nstatic void mlxsw_sp_mr_mfc_offload_update(struct mlxsw_sp_mr_route *mr_route)\n{\n\tbool offload;\n\n\toffload = mr_route->route_action != MLXSW_SP_MR_ROUTE_ACTION_TRAP;\n\tmlxsw_sp_mr_mfc_offload_set(mr_route, offload);\n}\n\nstatic void __mlxsw_sp_mr_route_del(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t\t    struct mlxsw_sp_mr_route *mr_route)\n{\n\tWARN_ON_ONCE(!mutex_is_locked(&mr_table->route_list_lock));\n\n\tmlxsw_sp_mr_mfc_offload_set(mr_route, false);\n\trhashtable_remove_fast(&mr_table->route_ht, &mr_route->ht_node,\n\t\t\t       mlxsw_sp_mr_route_ht_params);\n\tlist_del(&mr_route->node);\n\tmlxsw_sp_mr_route_erase(mr_table, mr_route);\n\tmlxsw_sp_mr_route_destroy(mr_table, mr_route);\n}\n\nint mlxsw_sp_mr_route_add(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t  struct mr_mfc *mfc, bool replace)\n{\n\tstruct mlxsw_sp_mr_route *mr_orig_route = NULL;\n\tstruct mlxsw_sp_mr_route *mr_route;\n\tint err;\n\n\tif (!mr_table->ops->is_route_valid(mr_table, mfc))\n\t\treturn -EINVAL;\n\n\t \n\tmr_route = mlxsw_sp_mr_route_create(mr_table, mfc);\n\tif (IS_ERR(mr_route))\n\t\treturn PTR_ERR(mr_route);\n\n\t \n\tmr_orig_route = rhashtable_lookup_fast(&mr_table->route_ht,\n\t\t\t\t\t       &mr_route->key,\n\t\t\t\t\t       mlxsw_sp_mr_route_ht_params);\n\tif (replace) {\n\t\t \n\t\tif (WARN_ON(!mr_orig_route)) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto err_no_orig_route;\n\t\t}\n\t\tmr_route->route_priv = mr_orig_route->route_priv;\n\t} else if (mr_orig_route) {\n\t\t \n\t\tdev_warn(mr_table->mlxsw_sp->bus_info->dev,\n\t\t\t \"Offloading proxy routes is not supported.\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_duplicate_route;\n\t}\n\n\t \n\terr = mlxsw_sp_mr_route_write(mr_table, mr_route, replace);\n\tif (err)\n\t\tgoto err_mr_route_write;\n\n\t \n\tmutex_lock(&mr_table->route_list_lock);\n\tlist_add_tail(&mr_route->node, &mr_table->route_list);\n\tmutex_unlock(&mr_table->route_list_lock);\n\terr = rhashtable_insert_fast(&mr_table->route_ht,\n\t\t\t\t     &mr_route->ht_node,\n\t\t\t\t     mlxsw_sp_mr_route_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_insert;\n\n\t \n\tif (replace) {\n\t\trhashtable_remove_fast(&mr_table->route_ht,\n\t\t\t\t       &mr_orig_route->ht_node,\n\t\t\t\t       mlxsw_sp_mr_route_ht_params);\n\t\tlist_del(&mr_orig_route->node);\n\t\tmlxsw_sp_mr_route_destroy(mr_table, mr_orig_route);\n\t}\n\n\tmlxsw_sp_mr_mfc_offload_update(mr_route);\n\treturn 0;\n\nerr_rhashtable_insert:\n\tmutex_lock(&mr_table->route_list_lock);\n\tlist_del(&mr_route->node);\n\tmutex_unlock(&mr_table->route_list_lock);\n\tmlxsw_sp_mr_route_erase(mr_table, mr_route);\nerr_mr_route_write:\nerr_no_orig_route:\nerr_duplicate_route:\n\tmlxsw_sp_mr_route_destroy(mr_table, mr_route);\n\treturn err;\n}\n\nvoid mlxsw_sp_mr_route_del(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t   struct mr_mfc *mfc)\n{\n\tstruct mlxsw_sp_mr_route *mr_route;\n\tstruct mlxsw_sp_mr_route_key key;\n\n\tmr_table->ops->key_create(mr_table, &key, mfc);\n\tmr_route = rhashtable_lookup_fast(&mr_table->route_ht, &key,\n\t\t\t\t\t  mlxsw_sp_mr_route_ht_params);\n\tif (mr_route) {\n\t\tmutex_lock(&mr_table->route_list_lock);\n\t\t__mlxsw_sp_mr_route_del(mr_table, mr_route);\n\t\tmutex_unlock(&mr_table->route_list_lock);\n\t}\n}\n\n \nstatic int\nmlxsw_sp_mr_route_ivif_resolve(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t       struct mlxsw_sp_mr_route_vif_entry *rve)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mr_table->mlxsw_sp;\n\tenum mlxsw_sp_mr_route_action route_action;\n\tstruct mlxsw_sp_mr *mr = mlxsw_sp->mr;\n\tu16 irif_index;\n\tint err;\n\n\troute_action = mlxsw_sp_mr_route_action(rve->mr_route);\n\tif (route_action == MLXSW_SP_MR_ROUTE_ACTION_TRAP)\n\t\treturn 0;\n\n\t \n\tirif_index = mlxsw_sp_rif_index(rve->mr_vif->rif);\n\terr = mr->mr_ops->route_irif_update(mlxsw_sp, rve->mr_route->route_priv,\n\t\t\t\t\t    irif_index);\n\tif (err)\n\t\treturn err;\n\n\terr = mr->mr_ops->route_action_update(mlxsw_sp,\n\t\t\t\t\t      rve->mr_route->route_priv,\n\t\t\t\t\t      route_action);\n\tif (err)\n\t\t \n\t\treturn err;\n\n\trve->mr_route->route_action = route_action;\n\tmlxsw_sp_mr_mfc_offload_update(rve->mr_route);\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_mr_route_ivif_unresolve(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t\t struct mlxsw_sp_mr_route_vif_entry *rve)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mr_table->mlxsw_sp;\n\tstruct mlxsw_sp_mr *mr = mlxsw_sp->mr;\n\n\tmr->mr_ops->route_action_update(mlxsw_sp, rve->mr_route->route_priv,\n\t\t\t\t\tMLXSW_SP_MR_ROUTE_ACTION_TRAP);\n\trve->mr_route->route_action = MLXSW_SP_MR_ROUTE_ACTION_TRAP;\n\tmlxsw_sp_mr_mfc_offload_update(rve->mr_route);\n}\n\n \nstatic int\nmlxsw_sp_mr_route_evif_resolve(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t       struct mlxsw_sp_mr_route_vif_entry *rve)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mr_table->mlxsw_sp;\n\tenum mlxsw_sp_mr_route_action route_action;\n\tstruct mlxsw_sp_mr *mr = mlxsw_sp->mr;\n\tu16 erif_index = 0;\n\tint err;\n\n\t \n\tif (mlxsw_sp_mr_vif_valid(rve->mr_vif)) {\n\t\terif_index = mlxsw_sp_rif_index(rve->mr_vif->rif);\n\t\terr = mr->mr_ops->route_erif_add(mlxsw_sp,\n\t\t\t\t\t\t rve->mr_route->route_priv,\n\t\t\t\t\t\t erif_index);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\troute_action = mlxsw_sp_mr_route_action(rve->mr_route);\n\tif (route_action != rve->mr_route->route_action) {\n\t\terr = mr->mr_ops->route_action_update(mlxsw_sp,\n\t\t\t\t\t\t      rve->mr_route->route_priv,\n\t\t\t\t\t\t      route_action);\n\t\tif (err)\n\t\t\tgoto err_route_action_update;\n\t}\n\n\t \n\tif (rve->mr_vif->dev->mtu < rve->mr_route->min_mtu) {\n\t\trve->mr_route->min_mtu = rve->mr_vif->dev->mtu;\n\t\terr = mr->mr_ops->route_min_mtu_update(mlxsw_sp,\n\t\t\t\t\t\t       rve->mr_route->route_priv,\n\t\t\t\t\t\t       rve->mr_route->min_mtu);\n\t\tif (err)\n\t\t\tgoto err_route_min_mtu_update;\n\t}\n\n\trve->mr_route->route_action = route_action;\n\tmlxsw_sp_mr_mfc_offload_update(rve->mr_route);\n\treturn 0;\n\nerr_route_min_mtu_update:\n\tif (route_action != rve->mr_route->route_action)\n\t\tmr->mr_ops->route_action_update(mlxsw_sp,\n\t\t\t\t\t\trve->mr_route->route_priv,\n\t\t\t\t\t\trve->mr_route->route_action);\nerr_route_action_update:\n\tif (mlxsw_sp_mr_vif_valid(rve->mr_vif))\n\t\tmr->mr_ops->route_erif_del(mlxsw_sp, rve->mr_route->route_priv,\n\t\t\t\t\t   erif_index);\n\treturn err;\n}\n\n \nstatic void\nmlxsw_sp_mr_route_evif_unresolve(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t\t struct mlxsw_sp_mr_route_vif_entry *rve)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mr_table->mlxsw_sp;\n\tenum mlxsw_sp_mr_route_action route_action;\n\tstruct mlxsw_sp_mr *mr = mlxsw_sp->mr;\n\tu16 rifi;\n\n\t \n\tif (!mlxsw_sp_mr_vif_valid(rve->mr_vif))\n\t\treturn;\n\n\t \n\tif (mlxsw_sp_mr_route_valid_evifs_num(rve->mr_route) == 1)\n\t\troute_action = MLXSW_SP_MR_ROUTE_ACTION_TRAP;\n\telse\n\t\troute_action = mlxsw_sp_mr_route_action(rve->mr_route);\n\tif (route_action != rve->mr_route->route_action)\n\t\tmr->mr_ops->route_action_update(mlxsw_sp,\n\t\t\t\t\t\trve->mr_route->route_priv,\n\t\t\t\t\t\troute_action);\n\n\t \n\trifi = mlxsw_sp_rif_index(rve->mr_vif->rif);\n\tmr->mr_ops->route_erif_del(mlxsw_sp, rve->mr_route->route_priv, rifi);\n\trve->mr_route->route_action = route_action;\n\tmlxsw_sp_mr_mfc_offload_update(rve->mr_route);\n}\n\nstatic int mlxsw_sp_mr_vif_resolve(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct mlxsw_sp_mr_vif *mr_vif,\n\t\t\t\t   unsigned long vif_flags,\n\t\t\t\t   const struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp_mr_route_vif_entry *irve, *erve;\n\tint err;\n\n\t \n\tmr_vif->dev = dev;\n\tmr_vif->rif = rif;\n\tmr_vif->vif_flags = vif_flags;\n\n\t \n\tlist_for_each_entry(irve, &mr_vif->route_ivif_list, vif_node) {\n\t\terr = mlxsw_sp_mr_route_ivif_resolve(mr_table, irve);\n\t\tif (err)\n\t\t\tgoto err_irif_unresolve;\n\t}\n\n\t \n\tlist_for_each_entry(erve, &mr_vif->route_evif_list, vif_node) {\n\t\terr = mlxsw_sp_mr_route_evif_resolve(mr_table, erve);\n\t\tif (err)\n\t\t\tgoto err_erif_unresolve;\n\t}\n\treturn 0;\n\nerr_erif_unresolve:\n\tlist_for_each_entry_continue_reverse(erve, &mr_vif->route_evif_list,\n\t\t\t\t\t     vif_node)\n\t\tmlxsw_sp_mr_route_evif_unresolve(mr_table, erve);\nerr_irif_unresolve:\n\tlist_for_each_entry_continue_reverse(irve, &mr_vif->route_ivif_list,\n\t\t\t\t\t     vif_node)\n\t\tmlxsw_sp_mr_route_ivif_unresolve(mr_table, irve);\n\tmr_vif->rif = NULL;\n\treturn err;\n}\n\nstatic void mlxsw_sp_mr_vif_unresolve(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      struct mlxsw_sp_mr_vif *mr_vif)\n{\n\tstruct mlxsw_sp_mr_route_vif_entry *rve;\n\n\t \n\tlist_for_each_entry(rve, &mr_vif->route_evif_list, vif_node)\n\t\tmlxsw_sp_mr_route_evif_unresolve(mr_table, rve);\n\n\t \n\tlist_for_each_entry(rve, &mr_vif->route_ivif_list, vif_node)\n\t\tmlxsw_sp_mr_route_ivif_unresolve(mr_table, rve);\n\n\t \n\tmr_vif->dev = dev;\n\tmr_vif->rif = NULL;\n}\n\nint mlxsw_sp_mr_vif_add(struct mlxsw_sp_mr_table *mr_table,\n\t\t\tstruct net_device *dev, vifi_t vif_index,\n\t\t\tunsigned long vif_flags, const struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp_mr_vif *mr_vif = &mr_table->vifs[vif_index];\n\n\tif (WARN_ON(vif_index >= MAXVIFS))\n\t\treturn -EINVAL;\n\tif (mr_vif->dev)\n\t\treturn -EEXIST;\n\treturn mlxsw_sp_mr_vif_resolve(mr_table, dev, mr_vif, vif_flags, rif);\n}\n\nvoid mlxsw_sp_mr_vif_del(struct mlxsw_sp_mr_table *mr_table, vifi_t vif_index)\n{\n\tstruct mlxsw_sp_mr_vif *mr_vif = &mr_table->vifs[vif_index];\n\n\tif (WARN_ON(vif_index >= MAXVIFS))\n\t\treturn;\n\tif (WARN_ON(!mr_vif->dev))\n\t\treturn;\n\tmlxsw_sp_mr_vif_unresolve(mr_table, NULL, mr_vif);\n}\n\nstatic struct mlxsw_sp_mr_vif *\nmlxsw_sp_mr_dev_vif_lookup(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t   const struct mlxsw_sp_rif *rif)\n{\n\tvifi_t vif_index;\n\n\tfor (vif_index = 0; vif_index < MAXVIFS; vif_index++)\n\t\tif (mlxsw_sp_rif_dev_is(rif, mr_table->vifs[vif_index].dev))\n\t\t\treturn &mr_table->vifs[vif_index];\n\treturn NULL;\n}\n\nint mlxsw_sp_mr_rif_add(struct mlxsw_sp_mr_table *mr_table,\n\t\t\tconst struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp_mr_vif *mr_vif;\n\n\tif (!mlxsw_sp_rif_has_dev(rif))\n\t\treturn 0;\n\n\tmr_vif = mlxsw_sp_mr_dev_vif_lookup(mr_table, rif);\n\tif (!mr_vif)\n\t\treturn 0;\n\treturn mlxsw_sp_mr_vif_resolve(mr_table, mr_vif->dev, mr_vif,\n\t\t\t\t       mr_vif->vif_flags, rif);\n}\n\nvoid mlxsw_sp_mr_rif_del(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t const struct mlxsw_sp_rif *rif)\n{\n\tstruct mlxsw_sp_mr_vif *mr_vif;\n\n\tif (!mlxsw_sp_rif_has_dev(rif))\n\t\treturn;\n\n\tmr_vif = mlxsw_sp_mr_dev_vif_lookup(mr_table, rif);\n\tif (!mr_vif)\n\t\treturn;\n\tmlxsw_sp_mr_vif_unresolve(mr_table, mr_vif->dev, mr_vif);\n}\n\nvoid mlxsw_sp_mr_rif_mtu_update(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t\tconst struct mlxsw_sp_rif *rif, int mtu)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mr_table->mlxsw_sp;\n\tstruct mlxsw_sp_mr_route_vif_entry *rve;\n\tstruct mlxsw_sp_mr *mr = mlxsw_sp->mr;\n\tstruct mlxsw_sp_mr_vif *mr_vif;\n\n\tif (!mlxsw_sp_rif_has_dev(rif))\n\t\treturn;\n\n\t \n\tmr_vif = mlxsw_sp_mr_dev_vif_lookup(mr_table, rif);\n\tif (!mr_vif)\n\t\treturn;\n\n\t \n\tlist_for_each_entry(rve, &mr_vif->route_evif_list, vif_node) {\n\t\tif (mtu < rve->mr_route->min_mtu) {\n\t\t\trve->mr_route->min_mtu = mtu;\n\t\t\tmr->mr_ops->route_min_mtu_update(mlxsw_sp,\n\t\t\t\t\t\t\t rve->mr_route->route_priv,\n\t\t\t\t\t\t\t mtu);\n\t\t}\n\t}\n}\n\n \nstatic bool\nmlxsw_sp_mr_route4_validate(const struct mlxsw_sp_mr_table *mr_table,\n\t\t\t    const struct mr_mfc *c)\n{\n\tstruct mfc_cache *mfc = (struct mfc_cache *) c;\n\n\t \n\tif (mfc->mfc_origin == htonl(INADDR_ANY) &&\n\t    mfc->mfc_mcastgrp == htonl(INADDR_ANY)) {\n\t\tdev_warn(mr_table->mlxsw_sp->bus_info->dev,\n\t\t\t \"Offloading proxy routes is not supported.\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void mlxsw_sp_mr_route4_key(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t\t   struct mlxsw_sp_mr_route_key *key,\n\t\t\t\t   struct mr_mfc *c)\n{\n\tconst struct mfc_cache *mfc = (struct mfc_cache *) c;\n\tbool starg;\n\n\tstarg = (mfc->mfc_origin == htonl(INADDR_ANY));\n\n\tmemset(key, 0, sizeof(*key));\n\tkey->vrid = mr_table->vr_id;\n\tkey->proto = MLXSW_SP_L3_PROTO_IPV4;\n\tkey->group.addr4 = mfc->mfc_mcastgrp;\n\tkey->group_mask.addr4 = htonl(0xffffffff);\n\tkey->source.addr4 = mfc->mfc_origin;\n\tkey->source_mask.addr4 = htonl(starg ? 0 : 0xffffffff);\n}\n\nstatic bool mlxsw_sp_mr_route4_starg(const struct mlxsw_sp_mr_table *mr_table,\n\t\t\t\t     const struct mlxsw_sp_mr_route *mr_route)\n{\n\treturn mr_route->key.source_mask.addr4 == htonl(INADDR_ANY);\n}\n\nstatic bool mlxsw_sp_mr_vif4_is_regular(const struct mlxsw_sp_mr_vif *vif)\n{\n\treturn !(vif->vif_flags & (VIFF_TUNNEL | VIFF_REGISTER));\n}\n\nstatic bool\nmlxsw_sp_mr_route6_validate(const struct mlxsw_sp_mr_table *mr_table,\n\t\t\t    const struct mr_mfc *c)\n{\n\tstruct mfc6_cache *mfc = (struct mfc6_cache *) c;\n\n\t \n\tif (ipv6_addr_any(&mfc->mf6c_origin) &&\n\t    ipv6_addr_any(&mfc->mf6c_mcastgrp)) {\n\t\tdev_warn(mr_table->mlxsw_sp->bus_info->dev,\n\t\t\t \"Offloading proxy routes is not supported.\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void mlxsw_sp_mr_route6_key(struct mlxsw_sp_mr_table *mr_table,\n\t\t\t\t   struct mlxsw_sp_mr_route_key *key,\n\t\t\t\t   struct mr_mfc *c)\n{\n\tconst struct mfc6_cache *mfc = (struct mfc6_cache *) c;\n\n\tmemset(key, 0, sizeof(*key));\n\tkey->vrid = mr_table->vr_id;\n\tkey->proto = MLXSW_SP_L3_PROTO_IPV6;\n\tkey->group.addr6 = mfc->mf6c_mcastgrp;\n\tmemset(&key->group_mask.addr6, 0xff, sizeof(key->group_mask.addr6));\n\tkey->source.addr6 = mfc->mf6c_origin;\n\tif (!ipv6_addr_any(&mfc->mf6c_origin))\n\t\tmemset(&key->source_mask.addr6, 0xff,\n\t\t       sizeof(key->source_mask.addr6));\n}\n\nstatic bool mlxsw_sp_mr_route6_starg(const struct mlxsw_sp_mr_table *mr_table,\n\t\t\t\t     const struct mlxsw_sp_mr_route *mr_route)\n{\n\treturn ipv6_addr_any(&mr_route->key.source_mask.addr6);\n}\n\nstatic bool mlxsw_sp_mr_vif6_is_regular(const struct mlxsw_sp_mr_vif *vif)\n{\n\treturn !(vif->vif_flags & MIFF_REGISTER);\n}\n\nstatic struct\nmlxsw_sp_mr_vif_ops mlxsw_sp_mr_vif_ops_arr[] = {\n\t{\n\t\t.is_regular = mlxsw_sp_mr_vif4_is_regular,\n\t},\n\t{\n\t\t.is_regular = mlxsw_sp_mr_vif6_is_regular,\n\t},\n};\n\nstatic struct\nmlxsw_sp_mr_table_ops mlxsw_sp_mr_table_ops_arr[] = {\n\t{\n\t\t.is_route_valid = mlxsw_sp_mr_route4_validate,\n\t\t.key_create = mlxsw_sp_mr_route4_key,\n\t\t.is_route_starg = mlxsw_sp_mr_route4_starg,\n\t},\n\t{\n\t\t.is_route_valid = mlxsw_sp_mr_route6_validate,\n\t\t.key_create = mlxsw_sp_mr_route6_key,\n\t\t.is_route_starg = mlxsw_sp_mr_route6_starg,\n\t},\n\n};\n\nstruct mlxsw_sp_mr_table *mlxsw_sp_mr_table_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t   u32 vr_id,\n\t\t\t\t\t\t   enum mlxsw_sp_l3proto proto)\n{\n\tstruct mlxsw_sp_mr_route_params catchall_route_params = {\n\t\t.prio = MLXSW_SP_MR_ROUTE_PRIO_CATCHALL,\n\t\t.key = {\n\t\t\t.vrid = vr_id,\n\t\t\t.proto = proto,\n\t\t},\n\t\t.value = {\n\t\t\t.route_action = MLXSW_SP_MR_ROUTE_ACTION_TRAP,\n\t\t}\n\t};\n\tstruct mlxsw_sp_mr *mr = mlxsw_sp->mr;\n\tstruct mlxsw_sp_mr_table *mr_table;\n\tint err;\n\tint i;\n\n\tmr_table = kzalloc(sizeof(*mr_table) + mr->mr_ops->route_priv_size,\n\t\t\t   GFP_KERNEL);\n\tif (!mr_table)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmr_table->vr_id = vr_id;\n\tmr_table->mlxsw_sp = mlxsw_sp;\n\tmr_table->proto = proto;\n\tmr_table->ops = &mlxsw_sp_mr_table_ops_arr[proto];\n\tINIT_LIST_HEAD(&mr_table->route_list);\n\tmutex_init(&mr_table->route_list_lock);\n\n\terr = rhashtable_init(&mr_table->route_ht,\n\t\t\t      &mlxsw_sp_mr_route_ht_params);\n\tif (err)\n\t\tgoto err_route_rhashtable_init;\n\n\tfor (i = 0; i < MAXVIFS; i++) {\n\t\tINIT_LIST_HEAD(&mr_table->vifs[i].route_evif_list);\n\t\tINIT_LIST_HEAD(&mr_table->vifs[i].route_ivif_list);\n\t\tmr_table->vifs[i].ops = &mlxsw_sp_mr_vif_ops_arr[proto];\n\t}\n\n\terr = mr->mr_ops->route_create(mlxsw_sp, mr->priv,\n\t\t\t\t       mr_table->catchall_route_priv,\n\t\t\t\t       &catchall_route_params);\n\tif (err)\n\t\tgoto err_ops_route_create;\n\tmutex_lock(&mr->table_list_lock);\n\tlist_add_tail(&mr_table->node, &mr->table_list);\n\tmutex_unlock(&mr->table_list_lock);\n\treturn mr_table;\n\nerr_ops_route_create:\n\trhashtable_destroy(&mr_table->route_ht);\nerr_route_rhashtable_init:\n\tmutex_destroy(&mr_table->route_list_lock);\n\tkfree(mr_table);\n\treturn ERR_PTR(err);\n}\n\nvoid mlxsw_sp_mr_table_destroy(struct mlxsw_sp_mr_table *mr_table)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mr_table->mlxsw_sp;\n\tstruct mlxsw_sp_mr *mr = mlxsw_sp->mr;\n\n\tWARN_ON(!mlxsw_sp_mr_table_empty(mr_table));\n\tmutex_lock(&mr->table_list_lock);\n\tlist_del(&mr_table->node);\n\tmutex_unlock(&mr->table_list_lock);\n\tmr->mr_ops->route_destroy(mlxsw_sp, mr->priv,\n\t\t\t\t  &mr_table->catchall_route_priv);\n\trhashtable_destroy(&mr_table->route_ht);\n\tmutex_destroy(&mr_table->route_list_lock);\n\tkfree(mr_table);\n}\n\nvoid mlxsw_sp_mr_table_flush(struct mlxsw_sp_mr_table *mr_table)\n{\n\tstruct mlxsw_sp_mr_route *mr_route, *tmp;\n\tint i;\n\n\tmutex_lock(&mr_table->route_list_lock);\n\tlist_for_each_entry_safe(mr_route, tmp, &mr_table->route_list, node)\n\t\t__mlxsw_sp_mr_route_del(mr_table, mr_route);\n\tmutex_unlock(&mr_table->route_list_lock);\n\n\tfor (i = 0; i < MAXVIFS; i++) {\n\t\tmr_table->vifs[i].dev = NULL;\n\t\tmr_table->vifs[i].rif = NULL;\n\t}\n}\n\nbool mlxsw_sp_mr_table_empty(const struct mlxsw_sp_mr_table *mr_table)\n{\n\tint i;\n\n\tfor (i = 0; i < MAXVIFS; i++)\n\t\tif (mr_table->vifs[i].dev)\n\t\t\treturn false;\n\treturn list_empty(&mr_table->route_list);\n}\n\nstatic void mlxsw_sp_mr_route_stats_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   struct mlxsw_sp_mr_route *mr_route)\n{\n\tstruct mlxsw_sp_mr *mr = mlxsw_sp->mr;\n\tu64 packets, bytes;\n\n\tif (mr_route->route_action == MLXSW_SP_MR_ROUTE_ACTION_TRAP)\n\t\treturn;\n\n\tmr->mr_ops->route_stats(mlxsw_sp, mr_route->route_priv, &packets,\n\t\t\t\t&bytes);\n\n\tif (mr_route->mfc->mfc_un.res.pkt != packets)\n\t\tmr_route->mfc->mfc_un.res.lastuse = jiffies;\n\tmr_route->mfc->mfc_un.res.pkt = packets;\n\tmr_route->mfc->mfc_un.res.bytes = bytes;\n}\n\nstatic void mlxsw_sp_mr_stats_update(struct work_struct *work)\n{\n\tstruct mlxsw_sp_mr *mr = container_of(work, struct mlxsw_sp_mr,\n\t\t\t\t\t      stats_update_dw.work);\n\tstruct mlxsw_sp_mr_table *mr_table;\n\tstruct mlxsw_sp_mr_route *mr_route;\n\tunsigned long interval;\n\n\tmutex_lock(&mr->table_list_lock);\n\tlist_for_each_entry(mr_table, &mr->table_list, node) {\n\t\tmutex_lock(&mr_table->route_list_lock);\n\t\tlist_for_each_entry(mr_route, &mr_table->route_list, node)\n\t\t\tmlxsw_sp_mr_route_stats_update(mr_table->mlxsw_sp,\n\t\t\t\t\t\t       mr_route);\n\t\tmutex_unlock(&mr_table->route_list_lock);\n\t}\n\tmutex_unlock(&mr->table_list_lock);\n\n\tinterval = msecs_to_jiffies(MLXSW_SP_MR_ROUTES_COUNTER_UPDATE_INTERVAL);\n\tmlxsw_core_schedule_dw(&mr->stats_update_dw, interval);\n}\n\nint mlxsw_sp_mr_init(struct mlxsw_sp *mlxsw_sp,\n\t\t     const struct mlxsw_sp_mr_ops *mr_ops)\n{\n\tstruct mlxsw_sp_mr *mr;\n\tunsigned long interval;\n\tint err;\n\n\tmr = kzalloc(sizeof(*mr) + mr_ops->priv_size, GFP_KERNEL);\n\tif (!mr)\n\t\treturn -ENOMEM;\n\tmr->mr_ops = mr_ops;\n\tmlxsw_sp->mr = mr;\n\tINIT_LIST_HEAD(&mr->table_list);\n\tmutex_init(&mr->table_list_lock);\n\n\terr = mr_ops->init(mlxsw_sp, mr->priv);\n\tif (err)\n\t\tgoto err;\n\n\t \n\tINIT_DELAYED_WORK(&mr->stats_update_dw, mlxsw_sp_mr_stats_update);\n\tinterval = msecs_to_jiffies(MLXSW_SP_MR_ROUTES_COUNTER_UPDATE_INTERVAL);\n\tmlxsw_core_schedule_dw(&mr->stats_update_dw, interval);\n\treturn 0;\nerr:\n\tmutex_destroy(&mr->table_list_lock);\n\tkfree(mr);\n\treturn err;\n}\n\nvoid mlxsw_sp_mr_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_mr *mr = mlxsw_sp->mr;\n\n\tcancel_delayed_work_sync(&mr->stats_update_dw);\n\tmr->mr_ops->fini(mlxsw_sp, mr->priv);\n\tmutex_destroy(&mr->table_list_lock);\n\tkfree(mr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}