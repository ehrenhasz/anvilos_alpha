{
  "module_name": "spectrum_port_range.c",
  "hash_id": "790a827ea9cf7c3ea4f4f53554853d2297be36eeabb46b55cf9dc8b12237617c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_port_range.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/netlink.h>\n#include <linux/refcount.h>\n#include <linux/xarray.h>\n#include <net/devlink.h>\n\n#include \"spectrum.h\"\n\nstruct mlxsw_sp_port_range_reg {\n\tstruct mlxsw_sp_port_range range;\n\trefcount_t refcount;\n\tu32 index;\n};\n\nstruct mlxsw_sp_port_range_core {\n\tstruct xarray prr_xa;\n\tstruct xa_limit prr_ids;\n\tatomic_t prr_count;\n};\n\nstatic int\nmlxsw_sp_port_range_reg_configure(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  const struct mlxsw_sp_port_range_reg *prr)\n{\n\tchar pprr_pl[MLXSW_REG_PPRR_LEN];\n\n\t \n\tmlxsw_reg_pprr_pack(pprr_pl, prr->index);\n\tmlxsw_reg_pprr_ipv4_set(pprr_pl, true);\n\tmlxsw_reg_pprr_ipv6_set(pprr_pl, true);\n\tmlxsw_reg_pprr_src_set(pprr_pl, prr->range.source);\n\tmlxsw_reg_pprr_dst_set(pprr_pl, !prr->range.source);\n\tmlxsw_reg_pprr_tcp_set(pprr_pl, true);\n\tmlxsw_reg_pprr_udp_set(pprr_pl, true);\n\tmlxsw_reg_pprr_port_range_min_set(pprr_pl, prr->range.min);\n\tmlxsw_reg_pprr_port_range_max_set(pprr_pl, prr->range.max);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pprr), pprr_pl);\n}\n\nstatic struct mlxsw_sp_port_range_reg *\nmlxsw_sp_port_range_reg_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       const struct mlxsw_sp_port_range *range,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_port_range_core *pr_core = mlxsw_sp->pr_core;\n\tstruct mlxsw_sp_port_range_reg *prr;\n\tint err;\n\n\tprr = kzalloc(sizeof(*prr), GFP_KERNEL);\n\tif (!prr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tprr->range = *range;\n\trefcount_set(&prr->refcount, 1);\n\n\terr = xa_alloc(&pr_core->prr_xa, &prr->index, prr, pr_core->prr_ids,\n\t\t       GFP_KERNEL);\n\tif (err) {\n\t\tif (err == -EBUSY)\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Exceeded number of port range registers\");\n\t\tgoto err_xa_alloc;\n\t}\n\n\terr = mlxsw_sp_port_range_reg_configure(mlxsw_sp, prr);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to configure port range register\");\n\t\tgoto err_reg_configure;\n\t}\n\n\tatomic_inc(&pr_core->prr_count);\n\n\treturn prr;\n\nerr_reg_configure:\n\txa_erase(&pr_core->prr_xa, prr->index);\nerr_xa_alloc:\n\tkfree(prr);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_port_range_reg_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    struct mlxsw_sp_port_range_reg *prr)\n{\n\tstruct mlxsw_sp_port_range_core *pr_core = mlxsw_sp->pr_core;\n\n\tatomic_dec(&pr_core->prr_count);\n\txa_erase(&pr_core->prr_xa, prr->index);\n\tkfree(prr);\n}\n\nstatic struct mlxsw_sp_port_range_reg *\nmlxsw_sp_port_range_reg_find(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     const struct mlxsw_sp_port_range *range)\n{\n\tstruct mlxsw_sp_port_range_core *pr_core = mlxsw_sp->pr_core;\n\tstruct mlxsw_sp_port_range_reg *prr;\n\tunsigned long index;\n\n\txa_for_each(&pr_core->prr_xa, index, prr) {\n\t\tif (prr->range.min == range->min &&\n\t\t    prr->range.max == range->max &&\n\t\t    prr->range.source == range->source)\n\t\t\treturn prr;\n\t}\n\n\treturn NULL;\n}\n\nint mlxsw_sp_port_range_reg_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tconst struct mlxsw_sp_port_range *range,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tu8 *p_prr_index)\n{\n\tstruct mlxsw_sp_port_range_reg *prr;\n\n\tprr = mlxsw_sp_port_range_reg_find(mlxsw_sp, range);\n\tif (prr) {\n\t\trefcount_inc(&prr->refcount);\n\t\t*p_prr_index = prr->index;\n\t\treturn 0;\n\t}\n\n\tprr = mlxsw_sp_port_range_reg_create(mlxsw_sp, range, extack);\n\tif (IS_ERR(prr))\n\t\treturn PTR_ERR(prr);\n\n\t*p_prr_index = prr->index;\n\n\treturn 0;\n}\n\nvoid mlxsw_sp_port_range_reg_put(struct mlxsw_sp *mlxsw_sp, u8 prr_index)\n{\n\tstruct mlxsw_sp_port_range_core *pr_core = mlxsw_sp->pr_core;\n\tstruct mlxsw_sp_port_range_reg *prr;\n\n\tprr = xa_load(&pr_core->prr_xa, prr_index);\n\tif (WARN_ON(!prr))\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&prr->refcount))\n\t\treturn;\n\n\tmlxsw_sp_port_range_reg_destroy(mlxsw_sp, prr);\n}\n\nstatic u64 mlxsw_sp_port_range_reg_occ_get(void *priv)\n{\n\tstruct mlxsw_sp_port_range_core *pr_core = priv;\n\n\treturn atomic_read(&pr_core->prr_count);\n}\n\nint mlxsw_sp_port_range_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_port_range_core *pr_core;\n\tstruct mlxsw_core *core = mlxsw_sp->core;\n\tu64 max;\n\n\tif (!MLXSW_CORE_RES_VALID(core, ACL_MAX_L4_PORT_RANGE))\n\t\treturn -EIO;\n\tmax = MLXSW_CORE_RES_GET(core, ACL_MAX_L4_PORT_RANGE);\n\n\t \n\tWARN_ON(max > BITS_PER_BYTE * sizeof(u16));\n\n\tpr_core = kzalloc(sizeof(*mlxsw_sp->pr_core), GFP_KERNEL);\n\tif (!pr_core)\n\t\treturn -ENOMEM;\n\tmlxsw_sp->pr_core = pr_core;\n\n\tpr_core->prr_ids.max = max - 1;\n\txa_init_flags(&pr_core->prr_xa, XA_FLAGS_ALLOC);\n\n\tdevl_resource_occ_get_register(priv_to_devlink(core),\n\t\t\t\t       MLXSW_SP_RESOURCE_PORT_RANGE_REGISTERS,\n\t\t\t\t       mlxsw_sp_port_range_reg_occ_get,\n\t\t\t\t       pr_core);\n\n\treturn 0;\n}\n\nvoid mlxsw_sp_port_range_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_port_range_core *pr_core = mlxsw_sp->pr_core;\n\n\tdevl_resource_occ_get_unregister(priv_to_devlink(mlxsw_sp->core),\n\t\t\t\t\t MLXSW_SP_RESOURCE_PORT_RANGE_REGISTERS);\n\tWARN_ON(!xa_empty(&pr_core->prr_xa));\n\txa_destroy(&pr_core->prr_xa);\n\tkfree(pr_core);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}