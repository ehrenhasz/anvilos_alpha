{
  "module_name": "spectrum_acl_tcam.c",
  "hash_id": "0bd500f68ae0220a030754e08752da098c95760979c722c6fe886fdd604783f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/list.h>\n#include <linux/rhashtable.h>\n#include <linux/netdevice.h>\n#include <linux/mutex.h>\n#include <net/devlink.h>\n#include <trace/events/mlxsw.h>\n\n#include \"reg.h\"\n#include \"core.h\"\n#include \"resources.h\"\n#include \"spectrum.h\"\n#include \"spectrum_acl_tcam.h\"\n#include \"core_acl_flex_keys.h\"\n\nsize_t mlxsw_sp_acl_tcam_priv_size(struct mlxsw_sp *mlxsw_sp)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\n\treturn ops->priv_size;\n}\n\n#define MLXSW_SP_ACL_TCAM_VREGION_REHASH_INTRVL_DFLT 5000  \n#define MLXSW_SP_ACL_TCAM_VREGION_REHASH_INTRVL_MIN 3000  \n#define MLXSW_SP_ACL_TCAM_VREGION_REHASH_CREDITS 100  \n\nint mlxsw_sp_acl_tcam_priority_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_acl_rule_info *rulei,\n\t\t\t\t   u32 *priority, bool fillup_priority)\n{\n\tu64 max_priority;\n\n\tif (!fillup_priority) {\n\t\t*priority = 0;\n\t\treturn 0;\n\t}\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, KVD_SIZE))\n\t\treturn -EIO;\n\n\t \n\tmax_priority = MLXSW_CORE_RES_GET(mlxsw_sp->core, KVD_SIZE) - 1;\n\tif (rulei->priority >= max_priority)\n\t\treturn -EINVAL;\n\n\t \n\t*priority = max_priority - rulei->priority;\n\treturn 0;\n}\n\nstatic int mlxsw_sp_acl_tcam_region_id_get(struct mlxsw_sp_acl_tcam *tcam,\n\t\t\t\t\t   u16 *p_id)\n{\n\tu16 id;\n\n\tid = find_first_zero_bit(tcam->used_regions, tcam->max_regions);\n\tif (id < tcam->max_regions) {\n\t\t__set_bit(id, tcam->used_regions);\n\t\t*p_id = id;\n\t\treturn 0;\n\t}\n\treturn -ENOBUFS;\n}\n\nstatic void mlxsw_sp_acl_tcam_region_id_put(struct mlxsw_sp_acl_tcam *tcam,\n\t\t\t\t\t    u16 id)\n{\n\t__clear_bit(id, tcam->used_regions);\n}\n\nstatic int mlxsw_sp_acl_tcam_group_id_get(struct mlxsw_sp_acl_tcam *tcam,\n\t\t\t\t\t  u16 *p_id)\n{\n\tu16 id;\n\n\tid = find_first_zero_bit(tcam->used_groups, tcam->max_groups);\n\tif (id < tcam->max_groups) {\n\t\t__set_bit(id, tcam->used_groups);\n\t\t*p_id = id;\n\t\treturn 0;\n\t}\n\treturn -ENOBUFS;\n}\n\nstatic void mlxsw_sp_acl_tcam_group_id_put(struct mlxsw_sp_acl_tcam *tcam,\n\t\t\t\t\t   u16 id)\n{\n\t__clear_bit(id, tcam->used_groups);\n}\n\nstruct mlxsw_sp_acl_tcam_pattern {\n\tconst enum mlxsw_afk_element *elements;\n\tunsigned int elements_count;\n};\n\nstruct mlxsw_sp_acl_tcam_group {\n\tstruct mlxsw_sp_acl_tcam *tcam;\n\tu16 id;\n\tstruct mutex lock;  \n\tstruct list_head region_list;\n\tunsigned int region_count;\n};\n\nstruct mlxsw_sp_acl_tcam_vgroup {\n\tstruct mlxsw_sp_acl_tcam_group group;\n\tstruct list_head vregion_list;\n\tstruct rhashtable vchunk_ht;\n\tconst struct mlxsw_sp_acl_tcam_pattern *patterns;\n\tunsigned int patterns_count;\n\tbool tmplt_elusage_set;\n\tstruct mlxsw_afk_element_usage tmplt_elusage;\n\tbool vregion_rehash_enabled;\n\tunsigned int *p_min_prio;\n\tunsigned int *p_max_prio;\n};\n\nstruct mlxsw_sp_acl_tcam_rehash_ctx {\n\tvoid *hints_priv;\n\tbool this_is_rollback;\n\tstruct mlxsw_sp_acl_tcam_vchunk *current_vchunk;  \n\tstruct mlxsw_sp_acl_tcam_ventry *start_ventry;  \n\tstruct mlxsw_sp_acl_tcam_ventry *stop_ventry;  \n};\n\nstruct mlxsw_sp_acl_tcam_vregion {\n\tstruct mutex lock;  \n\tstruct mlxsw_sp_acl_tcam_region *region;\n\tstruct mlxsw_sp_acl_tcam_region *region2;  \n\tstruct list_head list;  \n\tstruct list_head tlist;  \n\tstruct list_head vchunk_list;  \n\tstruct mlxsw_afk_key_info *key_info;\n\tstruct mlxsw_sp_acl_tcam *tcam;\n\tstruct mlxsw_sp_acl_tcam_vgroup *vgroup;\n\tstruct {\n\t\tstruct delayed_work dw;\n\t\tstruct mlxsw_sp_acl_tcam_rehash_ctx ctx;\n\t} rehash;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tunsigned int ref_count;\n};\n\nstruct mlxsw_sp_acl_tcam_vchunk;\n\nstruct mlxsw_sp_acl_tcam_chunk {\n\tstruct mlxsw_sp_acl_tcam_vchunk *vchunk;\n\tstruct mlxsw_sp_acl_tcam_region *region;\n\tunsigned long priv[];\n\t \n};\n\nstruct mlxsw_sp_acl_tcam_vchunk {\n\tstruct mlxsw_sp_acl_tcam_chunk *chunk;\n\tstruct mlxsw_sp_acl_tcam_chunk *chunk2;  \n\tstruct list_head list;  \n\tstruct rhash_head ht_node;  \n\tstruct list_head ventry_list;\n\tunsigned int priority;  \n\tstruct mlxsw_sp_acl_tcam_vgroup *vgroup;\n\tstruct mlxsw_sp_acl_tcam_vregion *vregion;\n\tunsigned int ref_count;\n};\n\nstruct mlxsw_sp_acl_tcam_entry {\n\tstruct mlxsw_sp_acl_tcam_ventry *ventry;\n\tstruct mlxsw_sp_acl_tcam_chunk *chunk;\n\tunsigned long priv[];\n\t \n};\n\nstruct mlxsw_sp_acl_tcam_ventry {\n\tstruct mlxsw_sp_acl_tcam_entry *entry;\n\tstruct list_head list;  \n\tstruct mlxsw_sp_acl_tcam_vchunk *vchunk;\n\tstruct mlxsw_sp_acl_rule_info *rulei;\n};\n\nstatic const struct rhashtable_params mlxsw_sp_acl_tcam_vchunk_ht_params = {\n\t.key_len = sizeof(unsigned int),\n\t.key_offset = offsetof(struct mlxsw_sp_acl_tcam_vchunk, priority),\n\t.head_offset = offsetof(struct mlxsw_sp_acl_tcam_vchunk, ht_node),\n\t.automatic_shrinking = true,\n};\n\nstatic int mlxsw_sp_acl_tcam_group_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct mlxsw_sp_acl_tcam_group *group)\n{\n\tstruct mlxsw_sp_acl_tcam_region *region;\n\tchar pagt_pl[MLXSW_REG_PAGT_LEN];\n\tint acl_index = 0;\n\n\tmlxsw_reg_pagt_pack(pagt_pl, group->id);\n\tlist_for_each_entry(region, &group->region_list, list) {\n\t\tbool multi = false;\n\n\t\t \n\t\tif (region->list.next != &group->region_list &&\n\t\t    list_next_entry(region, list)->vregion == region->vregion)\n\t\t\tmulti = true;\n\t\tmlxsw_reg_pagt_acl_id_pack(pagt_pl, acl_index++,\n\t\t\t\t\t   region->id, multi);\n\t}\n\tmlxsw_reg_pagt_size_set(pagt_pl, acl_index);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pagt), pagt_pl);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_group_add(struct mlxsw_sp_acl_tcam *tcam,\n\t\t\t    struct mlxsw_sp_acl_tcam_group *group)\n{\n\tint err;\n\n\tgroup->tcam = tcam;\n\tINIT_LIST_HEAD(&group->region_list);\n\n\terr = mlxsw_sp_acl_tcam_group_id_get(tcam, &group->id);\n\tif (err)\n\t\treturn err;\n\n\tmutex_init(&group->lock);\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_acl_tcam_group_del(struct mlxsw_sp_acl_tcam_group *group)\n{\n\tstruct mlxsw_sp_acl_tcam *tcam = group->tcam;\n\n\tmutex_destroy(&group->lock);\n\tmlxsw_sp_acl_tcam_group_id_put(tcam, group->id);\n\tWARN_ON(!list_empty(&group->region_list));\n}\n\nstatic int\nmlxsw_sp_acl_tcam_vgroup_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     struct mlxsw_sp_acl_tcam *tcam,\n\t\t\t     struct mlxsw_sp_acl_tcam_vgroup *vgroup,\n\t\t\t     const struct mlxsw_sp_acl_tcam_pattern *patterns,\n\t\t\t     unsigned int patterns_count,\n\t\t\t     struct mlxsw_afk_element_usage *tmplt_elusage,\n\t\t\t     bool vregion_rehash_enabled,\n\t\t\t     unsigned int *p_min_prio,\n\t\t\t     unsigned int *p_max_prio)\n{\n\tint err;\n\n\tvgroup->patterns = patterns;\n\tvgroup->patterns_count = patterns_count;\n\tvgroup->vregion_rehash_enabled = vregion_rehash_enabled;\n\tvgroup->p_min_prio = p_min_prio;\n\tvgroup->p_max_prio = p_max_prio;\n\n\tif (tmplt_elusage) {\n\t\tvgroup->tmplt_elusage_set = true;\n\t\tmemcpy(&vgroup->tmplt_elusage, tmplt_elusage,\n\t\t       sizeof(vgroup->tmplt_elusage));\n\t}\n\tINIT_LIST_HEAD(&vgroup->vregion_list);\n\n\terr = mlxsw_sp_acl_tcam_group_add(tcam, &vgroup->group);\n\tif (err)\n\t\treturn err;\n\n\terr = rhashtable_init(&vgroup->vchunk_ht,\n\t\t\t      &mlxsw_sp_acl_tcam_vchunk_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_init;\n\n\treturn 0;\n\nerr_rhashtable_init:\n\tmlxsw_sp_acl_tcam_group_del(&vgroup->group);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_acl_tcam_vgroup_del(struct mlxsw_sp_acl_tcam_vgroup *vgroup)\n{\n\trhashtable_destroy(&vgroup->vchunk_ht);\n\tmlxsw_sp_acl_tcam_group_del(&vgroup->group);\n\tWARN_ON(!list_empty(&vgroup->vregion_list));\n}\n\nstatic int\nmlxsw_sp_acl_tcam_group_bind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     struct mlxsw_sp_acl_tcam_group *group,\n\t\t\t     struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t     bool ingress)\n{\n\tchar ppbt_pl[MLXSW_REG_PPBT_LEN];\n\n\tmlxsw_reg_ppbt_pack(ppbt_pl, ingress ? MLXSW_REG_PXBT_E_IACL :\n\t\t\t\t\t       MLXSW_REG_PXBT_E_EACL,\n\t\t\t    MLXSW_REG_PXBT_OP_BIND, mlxsw_sp_port->local_port,\n\t\t\t    group->id);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ppbt), ppbt_pl);\n}\n\nstatic void\nmlxsw_sp_acl_tcam_group_unbind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_acl_tcam_group *group,\n\t\t\t       struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t       bool ingress)\n{\n\tchar ppbt_pl[MLXSW_REG_PPBT_LEN];\n\n\tmlxsw_reg_ppbt_pack(ppbt_pl, ingress ? MLXSW_REG_PXBT_E_IACL :\n\t\t\t\t\t       MLXSW_REG_PXBT_E_EACL,\n\t\t\t    MLXSW_REG_PXBT_OP_UNBIND, mlxsw_sp_port->local_port,\n\t\t\t    group->id);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ppbt), ppbt_pl);\n}\n\nstatic u16\nmlxsw_sp_acl_tcam_group_id(struct mlxsw_sp_acl_tcam_group *group)\n{\n\treturn group->id;\n}\n\nstatic unsigned int\nmlxsw_sp_acl_tcam_vregion_prio(struct mlxsw_sp_acl_tcam_vregion *vregion)\n{\n\tstruct mlxsw_sp_acl_tcam_vchunk *vchunk;\n\n\tif (list_empty(&vregion->vchunk_list))\n\t\treturn 0;\n\t \n\tvchunk = list_first_entry(&vregion->vchunk_list,\n\t\t\t\t  typeof(*vchunk), list);\n\treturn vchunk->priority;\n}\n\nstatic unsigned int\nmlxsw_sp_acl_tcam_vregion_max_prio(struct mlxsw_sp_acl_tcam_vregion *vregion)\n{\n\tstruct mlxsw_sp_acl_tcam_vchunk *vchunk;\n\n\tif (list_empty(&vregion->vchunk_list))\n\t\treturn 0;\n\tvchunk = list_last_entry(&vregion->vchunk_list,\n\t\t\t\t typeof(*vchunk), list);\n\treturn vchunk->priority;\n}\n\nstatic void\nmlxsw_sp_acl_tcam_vgroup_prio_update(struct mlxsw_sp_acl_tcam_vgroup *vgroup)\n{\n\tstruct mlxsw_sp_acl_tcam_vregion *vregion;\n\n\tif (list_empty(&vgroup->vregion_list))\n\t\treturn;\n\tvregion = list_first_entry(&vgroup->vregion_list,\n\t\t\t\t   typeof(*vregion), list);\n\t*vgroup->p_min_prio = mlxsw_sp_acl_tcam_vregion_prio(vregion);\n\tvregion = list_last_entry(&vgroup->vregion_list,\n\t\t\t\t  typeof(*vregion), list);\n\t*vgroup->p_max_prio = mlxsw_sp_acl_tcam_vregion_max_prio(vregion);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_group_region_attach(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct mlxsw_sp_acl_tcam_group *group,\n\t\t\t\t      struct mlxsw_sp_acl_tcam_region *region,\n\t\t\t\t      unsigned int priority,\n\t\t\t\t      struct mlxsw_sp_acl_tcam_region *next_region)\n{\n\tstruct mlxsw_sp_acl_tcam_region *region2;\n\tstruct list_head *pos;\n\tint err;\n\n\tmutex_lock(&group->lock);\n\tif (group->region_count == group->tcam->max_group_size) {\n\t\terr = -ENOBUFS;\n\t\tgoto err_region_count_check;\n\t}\n\n\tif (next_region) {\n\t\t \n\t\tpos = &next_region->list;\n\t} else {\n\t\t \n\t\tlist_for_each(pos, &group->region_list) {\n\t\t\tregion2 = list_entry(pos, typeof(*region2), list);\n\t\t\tif (mlxsw_sp_acl_tcam_vregion_prio(region2->vregion) >\n\t\t\t    priority)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tlist_add_tail(&region->list, pos);\n\tregion->group = group;\n\n\terr = mlxsw_sp_acl_tcam_group_update(mlxsw_sp, group);\n\tif (err)\n\t\tgoto err_group_update;\n\n\tgroup->region_count++;\n\tmutex_unlock(&group->lock);\n\treturn 0;\n\nerr_group_update:\n\tlist_del(&region->list);\nerr_region_count_check:\n\tmutex_unlock(&group->lock);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_acl_tcam_group_region_detach(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct mlxsw_sp_acl_tcam_region *region)\n{\n\tstruct mlxsw_sp_acl_tcam_group *group = region->group;\n\n\tmutex_lock(&group->lock);\n\tlist_del(&region->list);\n\tgroup->region_count--;\n\tmlxsw_sp_acl_tcam_group_update(mlxsw_sp, group);\n\tmutex_unlock(&group->lock);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_vgroup_vregion_attach(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_acl_tcam_vgroup *vgroup,\n\t\t\t\t\tstruct mlxsw_sp_acl_tcam_vregion *vregion,\n\t\t\t\t\tunsigned int priority)\n{\n\tstruct mlxsw_sp_acl_tcam_vregion *vregion2;\n\tstruct list_head *pos;\n\tint err;\n\n\t \n\tlist_for_each(pos, &vgroup->vregion_list) {\n\t\tvregion2 = list_entry(pos, typeof(*vregion2), list);\n\t\tif (mlxsw_sp_acl_tcam_vregion_prio(vregion2) > priority)\n\t\t\tbreak;\n\t}\n\tlist_add_tail(&vregion->list, pos);\n\n\terr = mlxsw_sp_acl_tcam_group_region_attach(mlxsw_sp, &vgroup->group,\n\t\t\t\t\t\t    vregion->region,\n\t\t\t\t\t\t    priority, NULL);\n\tif (err)\n\t\tgoto err_region_attach;\n\n\treturn 0;\n\nerr_region_attach:\n\tlist_del(&vregion->list);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_acl_tcam_vgroup_vregion_detach(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_acl_tcam_vregion *vregion)\n{\n\tlist_del(&vregion->list);\n\tif (vregion->region2)\n\t\tmlxsw_sp_acl_tcam_group_region_detach(mlxsw_sp,\n\t\t\t\t\t\t      vregion->region2);\n\tmlxsw_sp_acl_tcam_group_region_detach(mlxsw_sp, vregion->region);\n}\n\nstatic struct mlxsw_sp_acl_tcam_vregion *\nmlxsw_sp_acl_tcam_vgroup_vregion_find(struct mlxsw_sp_acl_tcam_vgroup *vgroup,\n\t\t\t\t      unsigned int priority,\n\t\t\t\t      struct mlxsw_afk_element_usage *elusage,\n\t\t\t\t      bool *p_need_split)\n{\n\tstruct mlxsw_sp_acl_tcam_vregion *vregion, *vregion2;\n\tstruct list_head *pos;\n\tbool issubset;\n\n\tlist_for_each(pos, &vgroup->vregion_list) {\n\t\tvregion = list_entry(pos, typeof(*vregion), list);\n\n\t\t \n\t\tif (pos->next != &vgroup->vregion_list) {  \n\t\t\tvregion2 = list_entry(pos->next, typeof(*vregion2),\n\t\t\t\t\t      list);\n\t\t\tif (priority >=\n\t\t\t    mlxsw_sp_acl_tcam_vregion_prio(vregion2))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tissubset = mlxsw_afk_key_info_subset(vregion->key_info,\n\t\t\t\t\t\t     elusage);\n\n\t\t \n\t\tif (!issubset &&\n\t\t    priority < mlxsw_sp_acl_tcam_vregion_prio(vregion))\n\t\t\treturn NULL;\n\n\t\t \n\t\tif (!issubset &&\n\t\t    priority > mlxsw_sp_acl_tcam_vregion_max_prio(vregion))\n\t\t\tcontinue;\n\n\t\t \n\t\t*p_need_split = !issubset;\n\t\treturn vregion;\n\t}\n\treturn NULL;  \n}\n\nstatic void\nmlxsw_sp_acl_tcam_vgroup_use_patterns(struct mlxsw_sp_acl_tcam_vgroup *vgroup,\n\t\t\t\t      struct mlxsw_afk_element_usage *elusage,\n\t\t\t\t      struct mlxsw_afk_element_usage *out)\n{\n\tconst struct mlxsw_sp_acl_tcam_pattern *pattern;\n\tint i;\n\n\t \n\tif (vgroup->tmplt_elusage_set) {\n\t\tmemcpy(out, &vgroup->tmplt_elusage, sizeof(*out));\n\t\tWARN_ON(!mlxsw_afk_element_usage_subset(elusage, out));\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < vgroup->patterns_count; i++) {\n\t\tpattern = &vgroup->patterns[i];\n\t\tmlxsw_afk_element_usage_fill(out, pattern->elements,\n\t\t\t\t\t     pattern->elements_count);\n\t\tif (mlxsw_afk_element_usage_subset(elusage, out))\n\t\t\treturn;\n\t}\n\tmemcpy(out, elusage, sizeof(*out));\n}\n\nstatic int\nmlxsw_sp_acl_tcam_region_alloc(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_acl_tcam_region *region)\n{\n\tstruct mlxsw_afk_key_info *key_info = region->key_info;\n\tchar ptar_pl[MLXSW_REG_PTAR_LEN];\n\tunsigned int encodings_count;\n\tint i;\n\tint err;\n\n\tmlxsw_reg_ptar_pack(ptar_pl, MLXSW_REG_PTAR_OP_ALLOC,\n\t\t\t    region->key_type,\n\t\t\t    MLXSW_SP_ACL_TCAM_REGION_BASE_COUNT,\n\t\t\t    region->id, region->tcam_region_info);\n\tencodings_count = mlxsw_afk_key_info_blocks_count_get(key_info);\n\tfor (i = 0; i < encodings_count; i++) {\n\t\tu16 encoding;\n\n\t\tencoding = mlxsw_afk_key_info_block_encoding_get(key_info, i);\n\t\tmlxsw_reg_ptar_key_id_pack(ptar_pl, i, encoding);\n\t}\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ptar), ptar_pl);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_ptar_unpack(ptar_pl, region->tcam_region_info);\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_acl_tcam_region_free(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_acl_tcam_region *region)\n{\n\tchar ptar_pl[MLXSW_REG_PTAR_LEN];\n\n\tmlxsw_reg_ptar_pack(ptar_pl, MLXSW_REG_PTAR_OP_FREE,\n\t\t\t    region->key_type, 0, region->id,\n\t\t\t    region->tcam_region_info);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ptar), ptar_pl);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_region_enable(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_acl_tcam_region *region)\n{\n\tchar pacl_pl[MLXSW_REG_PACL_LEN];\n\n\tmlxsw_reg_pacl_pack(pacl_pl, region->id, true,\n\t\t\t    region->tcam_region_info);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pacl), pacl_pl);\n}\n\nstatic void\nmlxsw_sp_acl_tcam_region_disable(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_acl_tcam_region *region)\n{\n\tchar pacl_pl[MLXSW_REG_PACL_LEN];\n\n\tmlxsw_reg_pacl_pack(pacl_pl, region->id, false,\n\t\t\t    region->tcam_region_info);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pacl), pacl_pl);\n}\n\nstatic struct mlxsw_sp_acl_tcam_region *\nmlxsw_sp_acl_tcam_region_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_acl_tcam *tcam,\n\t\t\t\tstruct mlxsw_sp_acl_tcam_vregion *vregion,\n\t\t\t\tvoid *hints_priv)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\tstruct mlxsw_sp_acl_tcam_region *region;\n\tint err;\n\n\tregion = kzalloc(sizeof(*region) + ops->region_priv_size, GFP_KERNEL);\n\tif (!region)\n\t\treturn ERR_PTR(-ENOMEM);\n\tregion->mlxsw_sp = mlxsw_sp;\n\tregion->vregion = vregion;\n\tregion->key_info = vregion->key_info;\n\n\terr = mlxsw_sp_acl_tcam_region_id_get(tcam, &region->id);\n\tif (err)\n\t\tgoto err_region_id_get;\n\n\terr = ops->region_associate(mlxsw_sp, region);\n\tif (err)\n\t\tgoto err_tcam_region_associate;\n\n\tregion->key_type = ops->key_type;\n\terr = mlxsw_sp_acl_tcam_region_alloc(mlxsw_sp, region);\n\tif (err)\n\t\tgoto err_tcam_region_alloc;\n\n\terr = mlxsw_sp_acl_tcam_region_enable(mlxsw_sp, region);\n\tif (err)\n\t\tgoto err_tcam_region_enable;\n\n\terr = ops->region_init(mlxsw_sp, region->priv, tcam->priv,\n\t\t\t       region, hints_priv);\n\tif (err)\n\t\tgoto err_tcam_region_init;\n\n\treturn region;\n\nerr_tcam_region_init:\n\tmlxsw_sp_acl_tcam_region_disable(mlxsw_sp, region);\nerr_tcam_region_enable:\n\tmlxsw_sp_acl_tcam_region_free(mlxsw_sp, region);\nerr_tcam_region_alloc:\nerr_tcam_region_associate:\n\tmlxsw_sp_acl_tcam_region_id_put(tcam, region->id);\nerr_region_id_get:\n\tkfree(region);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_acl_tcam_region_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_acl_tcam_region *region)\n{\n\tstruct mlxsw_sp_acl_tcam *tcam = mlxsw_sp_acl_to_tcam(mlxsw_sp->acl);\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\n\tops->region_fini(mlxsw_sp, region->priv);\n\tmlxsw_sp_acl_tcam_region_disable(mlxsw_sp, region);\n\tmlxsw_sp_acl_tcam_region_free(mlxsw_sp, region);\n\tmlxsw_sp_acl_tcam_region_id_put(tcam, region->id);\n\tkfree(region);\n}\n\nstatic void\nmlxsw_sp_acl_tcam_vregion_rehash_work_schedule(struct mlxsw_sp_acl_tcam_vregion *vregion)\n{\n\tunsigned long interval = vregion->tcam->vregion_rehash_intrvl;\n\n\tif (!interval)\n\t\treturn;\n\tmlxsw_core_schedule_dw(&vregion->rehash.dw,\n\t\t\t       msecs_to_jiffies(interval));\n}\n\nstatic void\nmlxsw_sp_acl_tcam_vregion_rehash(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_acl_tcam_vregion *vregion,\n\t\t\t\t int *credits);\n\nstatic void mlxsw_sp_acl_tcam_vregion_rehash_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_acl_tcam_vregion *vregion =\n\t\tcontainer_of(work, struct mlxsw_sp_acl_tcam_vregion,\n\t\t\t     rehash.dw.work);\n\tint credits = MLXSW_SP_ACL_TCAM_VREGION_REHASH_CREDITS;\n\n\tmlxsw_sp_acl_tcam_vregion_rehash(vregion->mlxsw_sp, vregion, &credits);\n\tif (credits < 0)\n\t\t \n\t\tmlxsw_core_schedule_dw(&vregion->rehash.dw, 0);\n\telse\n\t\tmlxsw_sp_acl_tcam_vregion_rehash_work_schedule(vregion);\n}\n\nstatic void\nmlxsw_sp_acl_tcam_rehash_ctx_vchunk_changed(struct mlxsw_sp_acl_tcam_vchunk *vchunk)\n{\n\tstruct mlxsw_sp_acl_tcam_vregion *vregion = vchunk->vregion;\n\n\t \n\tif (vregion->rehash.ctx.current_vchunk == vchunk) {\n\t\tvregion->rehash.ctx.start_ventry = NULL;\n\t\tvregion->rehash.ctx.stop_ventry = NULL;\n\t}\n}\n\nstatic void\nmlxsw_sp_acl_tcam_rehash_ctx_vregion_changed(struct mlxsw_sp_acl_tcam_vregion *vregion)\n{\n\t \n\tvregion->rehash.ctx.current_vchunk = NULL;\n}\n\nstatic struct mlxsw_sp_acl_tcam_vregion *\nmlxsw_sp_acl_tcam_vregion_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_acl_tcam_vgroup *vgroup,\n\t\t\t\t unsigned int priority,\n\t\t\t\t struct mlxsw_afk_element_usage *elusage)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\tstruct mlxsw_afk *afk = mlxsw_sp_acl_afk(mlxsw_sp->acl);\n\tstruct mlxsw_sp_acl_tcam *tcam = vgroup->group.tcam;\n\tstruct mlxsw_sp_acl_tcam_vregion *vregion;\n\tint err;\n\n\tvregion = kzalloc(sizeof(*vregion), GFP_KERNEL);\n\tif (!vregion)\n\t\treturn ERR_PTR(-ENOMEM);\n\tINIT_LIST_HEAD(&vregion->vchunk_list);\n\tmutex_init(&vregion->lock);\n\tvregion->tcam = tcam;\n\tvregion->mlxsw_sp = mlxsw_sp;\n\tvregion->vgroup = vgroup;\n\tvregion->ref_count = 1;\n\n\tvregion->key_info = mlxsw_afk_key_info_get(afk, elusage);\n\tif (IS_ERR(vregion->key_info)) {\n\t\terr = PTR_ERR(vregion->key_info);\n\t\tgoto err_key_info_get;\n\t}\n\n\tvregion->region = mlxsw_sp_acl_tcam_region_create(mlxsw_sp, tcam,\n\t\t\t\t\t\t\t  vregion, NULL);\n\tif (IS_ERR(vregion->region)) {\n\t\terr = PTR_ERR(vregion->region);\n\t\tgoto err_region_create;\n\t}\n\n\terr = mlxsw_sp_acl_tcam_vgroup_vregion_attach(mlxsw_sp, vgroup, vregion,\n\t\t\t\t\t\t      priority);\n\tif (err)\n\t\tgoto err_vgroup_vregion_attach;\n\n\tif (vgroup->vregion_rehash_enabled && ops->region_rehash_hints_get) {\n\t\t \n\t\tINIT_DELAYED_WORK(&vregion->rehash.dw,\n\t\t\t\t  mlxsw_sp_acl_tcam_vregion_rehash_work);\n\t\tmlxsw_sp_acl_tcam_vregion_rehash_work_schedule(vregion);\n\t\tmutex_lock(&tcam->lock);\n\t\tlist_add_tail(&vregion->tlist, &tcam->vregion_list);\n\t\tmutex_unlock(&tcam->lock);\n\t}\n\n\treturn vregion;\n\nerr_vgroup_vregion_attach:\n\tmlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region);\nerr_region_create:\n\tmlxsw_afk_key_info_put(vregion->key_info);\nerr_key_info_get:\n\tkfree(vregion);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_acl_tcam_vregion_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_acl_tcam_vregion *vregion)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\tstruct mlxsw_sp_acl_tcam_vgroup *vgroup = vregion->vgroup;\n\tstruct mlxsw_sp_acl_tcam *tcam = vregion->tcam;\n\n\tif (vgroup->vregion_rehash_enabled && ops->region_rehash_hints_get) {\n\t\tmutex_lock(&tcam->lock);\n\t\tlist_del(&vregion->tlist);\n\t\tmutex_unlock(&tcam->lock);\n\t\tcancel_delayed_work_sync(&vregion->rehash.dw);\n\t}\n\tmlxsw_sp_acl_tcam_vgroup_vregion_detach(mlxsw_sp, vregion);\n\tif (vregion->region2)\n\t\tmlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region2);\n\tmlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, vregion->region);\n\tmlxsw_afk_key_info_put(vregion->key_info);\n\tmutex_destroy(&vregion->lock);\n\tkfree(vregion);\n}\n\nstatic struct mlxsw_sp_acl_tcam_vregion *\nmlxsw_sp_acl_tcam_vregion_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_acl_tcam_vgroup *vgroup,\n\t\t\t      unsigned int priority,\n\t\t\t      struct mlxsw_afk_element_usage *elusage)\n{\n\tstruct mlxsw_afk_element_usage vregion_elusage;\n\tstruct mlxsw_sp_acl_tcam_vregion *vregion;\n\tbool need_split;\n\n\tvregion = mlxsw_sp_acl_tcam_vgroup_vregion_find(vgroup, priority,\n\t\t\t\t\t\t\telusage, &need_split);\n\tif (vregion) {\n\t\tif (need_split) {\n\t\t\t \n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t\t}\n\t\tvregion->ref_count++;\n\t\treturn vregion;\n\t}\n\n\tmlxsw_sp_acl_tcam_vgroup_use_patterns(vgroup, elusage,\n\t\t\t\t\t      &vregion_elusage);\n\n\treturn mlxsw_sp_acl_tcam_vregion_create(mlxsw_sp, vgroup, priority,\n\t\t\t\t\t\t&vregion_elusage);\n}\n\nstatic void\nmlxsw_sp_acl_tcam_vregion_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_acl_tcam_vregion *vregion)\n{\n\tif (--vregion->ref_count)\n\t\treturn;\n\tmlxsw_sp_acl_tcam_vregion_destroy(mlxsw_sp, vregion);\n}\n\nstatic struct mlxsw_sp_acl_tcam_chunk *\nmlxsw_sp_acl_tcam_chunk_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_acl_tcam_vchunk *vchunk,\n\t\t\t       struct mlxsw_sp_acl_tcam_region *region)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\tstruct mlxsw_sp_acl_tcam_chunk *chunk;\n\n\tchunk = kzalloc(sizeof(*chunk) + ops->chunk_priv_size, GFP_KERNEL);\n\tif (!chunk)\n\t\treturn ERR_PTR(-ENOMEM);\n\tchunk->vchunk = vchunk;\n\tchunk->region = region;\n\n\tops->chunk_init(region->priv, chunk->priv, vchunk->priority);\n\treturn chunk;\n}\n\nstatic void\nmlxsw_sp_acl_tcam_chunk_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_acl_tcam_chunk *chunk)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\n\tops->chunk_fini(chunk->priv);\n\tkfree(chunk);\n}\n\nstatic struct mlxsw_sp_acl_tcam_vchunk *\nmlxsw_sp_acl_tcam_vchunk_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_acl_tcam_vgroup *vgroup,\n\t\t\t\tunsigned int priority,\n\t\t\t\tstruct mlxsw_afk_element_usage *elusage)\n{\n\tstruct mlxsw_sp_acl_tcam_vchunk *vchunk, *vchunk2;\n\tstruct mlxsw_sp_acl_tcam_vregion *vregion;\n\tstruct list_head *pos;\n\tint err;\n\n\tif (priority == MLXSW_SP_ACL_TCAM_CATCHALL_PRIO)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tvchunk = kzalloc(sizeof(*vchunk), GFP_KERNEL);\n\tif (!vchunk)\n\t\treturn ERR_PTR(-ENOMEM);\n\tINIT_LIST_HEAD(&vchunk->ventry_list);\n\tvchunk->priority = priority;\n\tvchunk->vgroup = vgroup;\n\tvchunk->ref_count = 1;\n\n\tvregion = mlxsw_sp_acl_tcam_vregion_get(mlxsw_sp, vgroup,\n\t\t\t\t\t\tpriority, elusage);\n\tif (IS_ERR(vregion)) {\n\t\terr = PTR_ERR(vregion);\n\t\tgoto err_vregion_get;\n\t}\n\n\tvchunk->vregion = vregion;\n\n\terr = rhashtable_insert_fast(&vgroup->vchunk_ht, &vchunk->ht_node,\n\t\t\t\t     mlxsw_sp_acl_tcam_vchunk_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_insert;\n\n\tmutex_lock(&vregion->lock);\n\tvchunk->chunk = mlxsw_sp_acl_tcam_chunk_create(mlxsw_sp, vchunk,\n\t\t\t\t\t\t       vchunk->vregion->region);\n\tif (IS_ERR(vchunk->chunk)) {\n\t\tmutex_unlock(&vregion->lock);\n\t\terr = PTR_ERR(vchunk->chunk);\n\t\tgoto err_chunk_create;\n\t}\n\n\tmlxsw_sp_acl_tcam_rehash_ctx_vregion_changed(vregion);\n\n\t \n\tlist_for_each(pos, &vregion->vchunk_list) {\n\t\tvchunk2 = list_entry(pos, typeof(*vchunk2), list);\n\t\tif (vchunk2->priority > priority)\n\t\t\tbreak;\n\t}\n\tlist_add_tail(&vchunk->list, pos);\n\tmutex_unlock(&vregion->lock);\n\tmlxsw_sp_acl_tcam_vgroup_prio_update(vgroup);\n\n\treturn vchunk;\n\nerr_chunk_create:\n\trhashtable_remove_fast(&vgroup->vchunk_ht, &vchunk->ht_node,\n\t\t\t       mlxsw_sp_acl_tcam_vchunk_ht_params);\nerr_rhashtable_insert:\n\tmlxsw_sp_acl_tcam_vregion_put(mlxsw_sp, vregion);\nerr_vregion_get:\n\tkfree(vchunk);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_acl_tcam_vchunk_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_acl_tcam_vchunk *vchunk)\n{\n\tstruct mlxsw_sp_acl_tcam_vregion *vregion = vchunk->vregion;\n\tstruct mlxsw_sp_acl_tcam_vgroup *vgroup = vchunk->vgroup;\n\n\tmutex_lock(&vregion->lock);\n\tmlxsw_sp_acl_tcam_rehash_ctx_vregion_changed(vregion);\n\tlist_del(&vchunk->list);\n\tif (vchunk->chunk2)\n\t\tmlxsw_sp_acl_tcam_chunk_destroy(mlxsw_sp, vchunk->chunk2);\n\tmlxsw_sp_acl_tcam_chunk_destroy(mlxsw_sp, vchunk->chunk);\n\tmutex_unlock(&vregion->lock);\n\trhashtable_remove_fast(&vgroup->vchunk_ht, &vchunk->ht_node,\n\t\t\t       mlxsw_sp_acl_tcam_vchunk_ht_params);\n\tmlxsw_sp_acl_tcam_vregion_put(mlxsw_sp, vchunk->vregion);\n\tkfree(vchunk);\n\tmlxsw_sp_acl_tcam_vgroup_prio_update(vgroup);\n}\n\nstatic struct mlxsw_sp_acl_tcam_vchunk *\nmlxsw_sp_acl_tcam_vchunk_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     struct mlxsw_sp_acl_tcam_vgroup *vgroup,\n\t\t\t     unsigned int priority,\n\t\t\t     struct mlxsw_afk_element_usage *elusage)\n{\n\tstruct mlxsw_sp_acl_tcam_vchunk *vchunk;\n\n\tvchunk = rhashtable_lookup_fast(&vgroup->vchunk_ht, &priority,\n\t\t\t\t\tmlxsw_sp_acl_tcam_vchunk_ht_params);\n\tif (vchunk) {\n\t\tif (WARN_ON(!mlxsw_afk_key_info_subset(vchunk->vregion->key_info,\n\t\t\t\t\t\t       elusage)))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tvchunk->ref_count++;\n\t\treturn vchunk;\n\t}\n\treturn mlxsw_sp_acl_tcam_vchunk_create(mlxsw_sp, vgroup,\n\t\t\t\t\t       priority, elusage);\n}\n\nstatic void\nmlxsw_sp_acl_tcam_vchunk_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     struct mlxsw_sp_acl_tcam_vchunk *vchunk)\n{\n\tif (--vchunk->ref_count)\n\t\treturn;\n\tmlxsw_sp_acl_tcam_vchunk_destroy(mlxsw_sp, vchunk);\n}\n\nstatic struct mlxsw_sp_acl_tcam_entry *\nmlxsw_sp_acl_tcam_entry_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_acl_tcam_ventry *ventry,\n\t\t\t       struct mlxsw_sp_acl_tcam_chunk *chunk)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\tstruct mlxsw_sp_acl_tcam_entry *entry;\n\tint err;\n\n\tentry = kzalloc(sizeof(*entry) + ops->entry_priv_size, GFP_KERNEL);\n\tif (!entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\tentry->ventry = ventry;\n\tentry->chunk = chunk;\n\n\terr = ops->entry_add(mlxsw_sp, chunk->region->priv, chunk->priv,\n\t\t\t     entry->priv, ventry->rulei);\n\tif (err)\n\t\tgoto err_entry_add;\n\n\treturn entry;\n\nerr_entry_add:\n\tkfree(entry);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_acl_tcam_entry_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    struct mlxsw_sp_acl_tcam_entry *entry)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\n\tops->entry_del(mlxsw_sp, entry->chunk->region->priv,\n\t\t       entry->chunk->priv, entry->priv);\n\tkfree(entry);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_entry_action_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_acl_tcam_region *region,\n\t\t\t\t       struct mlxsw_sp_acl_tcam_entry *entry,\n\t\t\t\t       struct mlxsw_sp_acl_rule_info *rulei)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\n\treturn ops->entry_action_replace(mlxsw_sp, region->priv,\n\t\t\t\t\t entry->priv, rulei);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_entry_activity_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_acl_tcam_entry *entry,\n\t\t\t\t     bool *activity)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\n\treturn ops->entry_activity_get(mlxsw_sp, entry->chunk->region->priv,\n\t\t\t\t       entry->priv, activity);\n}\n\nstatic int mlxsw_sp_acl_tcam_ventry_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_acl_tcam_vgroup *vgroup,\n\t\t\t\t\tstruct mlxsw_sp_acl_tcam_ventry *ventry,\n\t\t\t\t\tstruct mlxsw_sp_acl_rule_info *rulei)\n{\n\tstruct mlxsw_sp_acl_tcam_vregion *vregion;\n\tstruct mlxsw_sp_acl_tcam_vchunk *vchunk;\n\tint err;\n\n\tvchunk = mlxsw_sp_acl_tcam_vchunk_get(mlxsw_sp, vgroup, rulei->priority,\n\t\t\t\t\t      &rulei->values.elusage);\n\tif (IS_ERR(vchunk))\n\t\treturn PTR_ERR(vchunk);\n\n\tventry->vchunk = vchunk;\n\tventry->rulei = rulei;\n\tvregion = vchunk->vregion;\n\n\tmutex_lock(&vregion->lock);\n\tventry->entry = mlxsw_sp_acl_tcam_entry_create(mlxsw_sp, ventry,\n\t\t\t\t\t\t       vchunk->chunk);\n\tif (IS_ERR(ventry->entry)) {\n\t\tmutex_unlock(&vregion->lock);\n\t\terr = PTR_ERR(ventry->entry);\n\t\tgoto err_entry_create;\n\t}\n\n\tlist_add_tail(&ventry->list, &vchunk->ventry_list);\n\tmlxsw_sp_acl_tcam_rehash_ctx_vchunk_changed(vchunk);\n\tmutex_unlock(&vregion->lock);\n\n\treturn 0;\n\nerr_entry_create:\n\tmlxsw_sp_acl_tcam_vchunk_put(mlxsw_sp, vchunk);\n\treturn err;\n}\n\nstatic void mlxsw_sp_acl_tcam_ventry_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t struct mlxsw_sp_acl_tcam_ventry *ventry)\n{\n\tstruct mlxsw_sp_acl_tcam_vchunk *vchunk = ventry->vchunk;\n\tstruct mlxsw_sp_acl_tcam_vregion *vregion = vchunk->vregion;\n\n\tmutex_lock(&vregion->lock);\n\tmlxsw_sp_acl_tcam_rehash_ctx_vchunk_changed(vchunk);\n\tlist_del(&ventry->list);\n\tmlxsw_sp_acl_tcam_entry_destroy(mlxsw_sp, ventry->entry);\n\tmutex_unlock(&vregion->lock);\n\tmlxsw_sp_acl_tcam_vchunk_put(mlxsw_sp, vchunk);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_ventry_action_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_acl_tcam_ventry *ventry,\n\t\t\t\t\tstruct mlxsw_sp_acl_rule_info *rulei)\n{\n\tstruct mlxsw_sp_acl_tcam_vchunk *vchunk = ventry->vchunk;\n\n\treturn mlxsw_sp_acl_tcam_entry_action_replace(mlxsw_sp,\n\t\t\t\t\t\t      vchunk->vregion->region,\n\t\t\t\t\t\t      ventry->entry, rulei);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_ventry_activity_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct mlxsw_sp_acl_tcam_ventry *ventry,\n\t\t\t\t      bool *activity)\n{\n\treturn mlxsw_sp_acl_tcam_entry_activity_get(mlxsw_sp,\n\t\t\t\t\t\t    ventry->entry, activity);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_ventry_migrate(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_acl_tcam_ventry *ventry,\n\t\t\t\t struct mlxsw_sp_acl_tcam_chunk *chunk,\n\t\t\t\t int *credits)\n{\n\tstruct mlxsw_sp_acl_tcam_entry *new_entry;\n\n\t \n\tif (ventry->entry->chunk == chunk)\n\t\treturn 0;\n\n\tif (--(*credits) < 0)\n\t\treturn 0;\n\n\tnew_entry = mlxsw_sp_acl_tcam_entry_create(mlxsw_sp, ventry, chunk);\n\tif (IS_ERR(new_entry))\n\t\treturn PTR_ERR(new_entry);\n\tmlxsw_sp_acl_tcam_entry_destroy(mlxsw_sp, ventry->entry);\n\tventry->entry = new_entry;\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_acl_tcam_vchunk_migrate_start(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_acl_tcam_vchunk *vchunk,\n\t\t\t\t       struct mlxsw_sp_acl_tcam_region *region,\n\t\t\t\t       struct mlxsw_sp_acl_tcam_rehash_ctx *ctx)\n{\n\tstruct mlxsw_sp_acl_tcam_chunk *new_chunk;\n\n\tnew_chunk = mlxsw_sp_acl_tcam_chunk_create(mlxsw_sp, vchunk, region);\n\tif (IS_ERR(new_chunk))\n\t\treturn PTR_ERR(new_chunk);\n\tvchunk->chunk2 = vchunk->chunk;\n\tvchunk->chunk = new_chunk;\n\tctx->current_vchunk = vchunk;\n\tctx->start_ventry = NULL;\n\tctx->stop_ventry = NULL;\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_acl_tcam_vchunk_migrate_end(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_acl_tcam_vchunk *vchunk,\n\t\t\t\t     struct mlxsw_sp_acl_tcam_rehash_ctx *ctx)\n{\n\tmlxsw_sp_acl_tcam_chunk_destroy(mlxsw_sp, vchunk->chunk2);\n\tvchunk->chunk2 = NULL;\n\tctx->current_vchunk = NULL;\n}\n\nstatic int\nmlxsw_sp_acl_tcam_vchunk_migrate_one(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_acl_tcam_vchunk *vchunk,\n\t\t\t\t     struct mlxsw_sp_acl_tcam_region *region,\n\t\t\t\t     struct mlxsw_sp_acl_tcam_rehash_ctx *ctx,\n\t\t\t\t     int *credits)\n{\n\tstruct mlxsw_sp_acl_tcam_ventry *ventry;\n\tint err;\n\n\tif (vchunk->chunk->region != region) {\n\t\terr = mlxsw_sp_acl_tcam_vchunk_migrate_start(mlxsw_sp, vchunk,\n\t\t\t\t\t\t\t     region, ctx);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (!vchunk->chunk2) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tif (ctx->start_ventry)\n\t\tventry = ctx->start_ventry;\n\telse\n\t\tventry = list_first_entry(&vchunk->ventry_list,\n\t\t\t\t\t  typeof(*ventry), list);\n\n\tlist_for_each_entry_from(ventry, &vchunk->ventry_list, list) {\n\t\t \n\t\tif (ventry == ctx->stop_ventry)\n\t\t\tbreak;\n\n\t\terr = mlxsw_sp_acl_tcam_ventry_migrate(mlxsw_sp, ventry,\n\t\t\t\t\t\t       vchunk->chunk, credits);\n\t\tif (err) {\n\t\t\tif (ctx->this_is_rollback) {\n\t\t\t\t \n\t\t\t\tctx->start_ventry = ventry;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\t \n\t\t\tswap(vchunk->chunk, vchunk->chunk2);\n\t\t\t \n\t\t\tctx->start_ventry = NULL;\n\t\t\tctx->stop_ventry = ventry;\n\t\t\treturn err;\n\t\t} else if (*credits < 0) {\n\t\t\t \n\t\t\tctx->start_ventry = ventry;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmlxsw_sp_acl_tcam_vchunk_migrate_end(mlxsw_sp, vchunk, ctx);\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_acl_tcam_vchunk_migrate_all(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_acl_tcam_vregion *vregion,\n\t\t\t\t     struct mlxsw_sp_acl_tcam_rehash_ctx *ctx,\n\t\t\t\t     int *credits)\n{\n\tstruct mlxsw_sp_acl_tcam_vchunk *vchunk;\n\tint err;\n\n\t \n\tif (ctx->current_vchunk)\n\t\tvchunk = ctx->current_vchunk;\n\telse\n\t\tvchunk = list_first_entry(&vregion->vchunk_list,\n\t\t\t\t\t  typeof(*vchunk), list);\n\n\tlist_for_each_entry_from(vchunk, &vregion->vchunk_list, list) {\n\t\terr = mlxsw_sp_acl_tcam_vchunk_migrate_one(mlxsw_sp, vchunk,\n\t\t\t\t\t\t\t   vregion->region,\n\t\t\t\t\t\t\t   ctx, credits);\n\t\tif (err || *credits < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_acl_tcam_vregion_migrate(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_acl_tcam_vregion *vregion,\n\t\t\t\t  struct mlxsw_sp_acl_tcam_rehash_ctx *ctx,\n\t\t\t\t  int *credits)\n{\n\tint err, err2;\n\n\ttrace_mlxsw_sp_acl_tcam_vregion_migrate(mlxsw_sp, vregion);\n\tmutex_lock(&vregion->lock);\n\terr = mlxsw_sp_acl_tcam_vchunk_migrate_all(mlxsw_sp, vregion,\n\t\t\t\t\t\t   ctx, credits);\n\tif (err) {\n\t\t \n\t\tswap(vregion->region, vregion->region2);\n\t\tctx->current_vchunk = NULL;\n\t\tctx->this_is_rollback = true;\n\t\terr2 = mlxsw_sp_acl_tcam_vchunk_migrate_all(mlxsw_sp, vregion,\n\t\t\t\t\t\t\t    ctx, credits);\n\t\tif (err2) {\n\t\t\ttrace_mlxsw_sp_acl_tcam_vregion_rehash_rollback_failed(mlxsw_sp,\n\t\t\t\t\t\t\t\t\t       vregion);\n\t\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to rollback during vregion migration fail\\n\");\n\t\t\t \n\t\t}\n\t}\n\tmutex_unlock(&vregion->lock);\n\ttrace_mlxsw_sp_acl_tcam_vregion_migrate_end(mlxsw_sp, vregion);\n\treturn err;\n}\n\nstatic bool\nmlxsw_sp_acl_tcam_vregion_rehash_in_progress(const struct mlxsw_sp_acl_tcam_rehash_ctx *ctx)\n{\n\treturn ctx->hints_priv;\n}\n\nstatic int\nmlxsw_sp_acl_tcam_vregion_rehash_start(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp_acl_tcam_vregion *vregion,\n\t\t\t\t       struct mlxsw_sp_acl_tcam_rehash_ctx *ctx)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\tunsigned int priority = mlxsw_sp_acl_tcam_vregion_prio(vregion);\n\tstruct mlxsw_sp_acl_tcam_region *new_region;\n\tvoid *hints_priv;\n\tint err;\n\n\ttrace_mlxsw_sp_acl_tcam_vregion_rehash(mlxsw_sp, vregion);\n\n\thints_priv = ops->region_rehash_hints_get(vregion->region->priv);\n\tif (IS_ERR(hints_priv))\n\t\treturn PTR_ERR(hints_priv);\n\n\tnew_region = mlxsw_sp_acl_tcam_region_create(mlxsw_sp, vregion->tcam,\n\t\t\t\t\t\t     vregion, hints_priv);\n\tif (IS_ERR(new_region)) {\n\t\terr = PTR_ERR(new_region);\n\t\tgoto err_region_create;\n\t}\n\n\t \n\tvregion->region2 = vregion->region;\n\tvregion->region = new_region;\n\terr = mlxsw_sp_acl_tcam_group_region_attach(mlxsw_sp,\n\t\t\t\t\t\t    vregion->region2->group,\n\t\t\t\t\t\t    new_region, priority,\n\t\t\t\t\t\t    vregion->region2);\n\tif (err)\n\t\tgoto err_group_region_attach;\n\n\tctx->hints_priv = hints_priv;\n\tctx->this_is_rollback = false;\n\n\treturn 0;\n\nerr_group_region_attach:\n\tvregion->region = vregion->region2;\n\tvregion->region2 = NULL;\n\tmlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, new_region);\nerr_region_create:\n\tops->region_rehash_hints_put(hints_priv);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_acl_tcam_vregion_rehash_end(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_acl_tcam_vregion *vregion,\n\t\t\t\t     struct mlxsw_sp_acl_tcam_rehash_ctx *ctx)\n{\n\tstruct mlxsw_sp_acl_tcam_region *unused_region = vregion->region2;\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\n\tvregion->region2 = NULL;\n\tmlxsw_sp_acl_tcam_group_region_detach(mlxsw_sp, unused_region);\n\tmlxsw_sp_acl_tcam_region_destroy(mlxsw_sp, unused_region);\n\tops->region_rehash_hints_put(ctx->hints_priv);\n\tctx->hints_priv = NULL;\n}\n\nstatic void\nmlxsw_sp_acl_tcam_vregion_rehash(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_acl_tcam_vregion *vregion,\n\t\t\t\t int *credits)\n{\n\tstruct mlxsw_sp_acl_tcam_rehash_ctx *ctx = &vregion->rehash.ctx;\n\tint err;\n\n\t \n\tif (!mlxsw_sp_acl_tcam_vregion_rehash_in_progress(ctx)) {\n\t\terr = mlxsw_sp_acl_tcam_vregion_rehash_start(mlxsw_sp,\n\t\t\t\t\t\t\t     vregion, ctx);\n\t\tif (err) {\n\t\t\tif (err != -EAGAIN)\n\t\t\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed get rehash hints\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\terr = mlxsw_sp_acl_tcam_vregion_migrate(mlxsw_sp, vregion,\n\t\t\t\t\t\tctx, credits);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to migrate vregion\\n\");\n\t}\n\n\tif (*credits >= 0)\n\t\tmlxsw_sp_acl_tcam_vregion_rehash_end(mlxsw_sp, vregion, ctx);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_region_rehash_intrvl_get(struct devlink *devlink, u32 id,\n\t\t\t\t\t   struct devlink_param_gset_ctx *ctx)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_sp_acl_tcam *tcam;\n\tstruct mlxsw_sp *mlxsw_sp;\n\n\tmlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\ttcam = mlxsw_sp_acl_to_tcam(mlxsw_sp->acl);\n\tctx->val.vu32 = tcam->vregion_rehash_intrvl;\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_acl_tcam_region_rehash_intrvl_set(struct devlink *devlink, u32 id,\n\t\t\t\t\t   struct devlink_param_gset_ctx *ctx)\n{\n\tstruct mlxsw_core *mlxsw_core = devlink_priv(devlink);\n\tstruct mlxsw_sp_acl_tcam_vregion *vregion;\n\tstruct mlxsw_sp_acl_tcam *tcam;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tu32 val = ctx->val.vu32;\n\n\tif (val < MLXSW_SP_ACL_TCAM_VREGION_REHASH_INTRVL_MIN && val)\n\t\treturn -EINVAL;\n\n\tmlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\ttcam = mlxsw_sp_acl_to_tcam(mlxsw_sp->acl);\n\ttcam->vregion_rehash_intrvl = val;\n\tmutex_lock(&tcam->lock);\n\tlist_for_each_entry(vregion, &tcam->vregion_list, tlist) {\n\t\tif (val)\n\t\t\tmlxsw_core_schedule_dw(&vregion->rehash.dw, 0);\n\t\telse\n\t\t\tcancel_delayed_work_sync(&vregion->rehash.dw);\n\t}\n\tmutex_unlock(&tcam->lock);\n\treturn 0;\n}\n\nstatic const struct devlink_param mlxsw_sp_acl_tcam_rehash_params[] = {\n\tDEVLINK_PARAM_DRIVER(MLXSW_DEVLINK_PARAM_ID_ACL_REGION_REHASH_INTERVAL,\n\t\t\t     \"acl_region_rehash_interval\",\n\t\t\t     DEVLINK_PARAM_TYPE_U32,\n\t\t\t     BIT(DEVLINK_PARAM_CMODE_RUNTIME),\n\t\t\t     mlxsw_sp_acl_tcam_region_rehash_intrvl_get,\n\t\t\t     mlxsw_sp_acl_tcam_region_rehash_intrvl_set,\n\t\t\t     NULL),\n};\n\nstatic int mlxsw_sp_acl_tcam_rehash_params_register(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\n\tif (!mlxsw_sp->acl_tcam_ops->region_rehash_hints_get)\n\t\treturn 0;\n\n\treturn devl_params_register(devlink, mlxsw_sp_acl_tcam_rehash_params,\n\t\t\t\t    ARRAY_SIZE(mlxsw_sp_acl_tcam_rehash_params));\n}\n\nstatic void\nmlxsw_sp_acl_tcam_rehash_params_unregister(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\n\tif (!mlxsw_sp->acl_tcam_ops->region_rehash_hints_get)\n\t\treturn;\n\n\tdevl_params_unregister(devlink, mlxsw_sp_acl_tcam_rehash_params,\n\t\t\t       ARRAY_SIZE(mlxsw_sp_acl_tcam_rehash_params));\n}\n\nint mlxsw_sp_acl_tcam_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   struct mlxsw_sp_acl_tcam *tcam)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\tu64 max_tcam_regions;\n\tu64 max_regions;\n\tu64 max_groups;\n\tint err;\n\n\tmutex_init(&tcam->lock);\n\ttcam->vregion_rehash_intrvl =\n\t\t\tMLXSW_SP_ACL_TCAM_VREGION_REHASH_INTRVL_DFLT;\n\tINIT_LIST_HEAD(&tcam->vregion_list);\n\n\terr = mlxsw_sp_acl_tcam_rehash_params_register(mlxsw_sp);\n\tif (err)\n\t\tgoto err_rehash_params_register;\n\n\tmax_tcam_regions = MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t\t      ACL_MAX_TCAM_REGIONS);\n\tmax_regions = MLXSW_CORE_RES_GET(mlxsw_sp->core, ACL_MAX_REGIONS);\n\n\t \n\tif (max_tcam_regions < max_regions)\n\t\tmax_regions = max_tcam_regions;\n\n\ttcam->used_regions = bitmap_zalloc(max_regions, GFP_KERNEL);\n\tif (!tcam->used_regions) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_used_regions;\n\t}\n\ttcam->max_regions = max_regions;\n\n\tmax_groups = MLXSW_CORE_RES_GET(mlxsw_sp->core, ACL_MAX_GROUPS);\n\ttcam->used_groups = bitmap_zalloc(max_groups, GFP_KERNEL);\n\tif (!tcam->used_groups) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_used_groups;\n\t}\n\ttcam->max_groups = max_groups;\n\ttcam->max_group_size = MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t\t\t  ACL_MAX_GROUP_SIZE);\n\ttcam->max_group_size = min_t(unsigned int, tcam->max_group_size,\n\t\t\t\t     MLXSW_REG_PAGT_ACL_MAX_NUM);\n\n\terr = ops->init(mlxsw_sp, tcam->priv, tcam);\n\tif (err)\n\t\tgoto err_tcam_init;\n\n\treturn 0;\n\nerr_tcam_init:\n\tbitmap_free(tcam->used_groups);\nerr_alloc_used_groups:\n\tbitmap_free(tcam->used_regions);\nerr_alloc_used_regions:\n\tmlxsw_sp_acl_tcam_rehash_params_unregister(mlxsw_sp);\nerr_rehash_params_register:\n\tmutex_destroy(&tcam->lock);\n\treturn err;\n}\n\nvoid mlxsw_sp_acl_tcam_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_acl_tcam *tcam)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\n\tops->fini(mlxsw_sp, tcam->priv);\n\tbitmap_free(tcam->used_groups);\n\tbitmap_free(tcam->used_regions);\n\tmlxsw_sp_acl_tcam_rehash_params_unregister(mlxsw_sp);\n\tmutex_destroy(&tcam->lock);\n}\n\nstatic const enum mlxsw_afk_element mlxsw_sp_acl_tcam_pattern_ipv4[] = {\n\tMLXSW_AFK_ELEMENT_SRC_SYS_PORT,\n\tMLXSW_AFK_ELEMENT_DMAC_32_47,\n\tMLXSW_AFK_ELEMENT_DMAC_0_31,\n\tMLXSW_AFK_ELEMENT_SMAC_32_47,\n\tMLXSW_AFK_ELEMENT_SMAC_0_31,\n\tMLXSW_AFK_ELEMENT_ETHERTYPE,\n\tMLXSW_AFK_ELEMENT_IP_PROTO,\n\tMLXSW_AFK_ELEMENT_SRC_IP_0_31,\n\tMLXSW_AFK_ELEMENT_DST_IP_0_31,\n\tMLXSW_AFK_ELEMENT_DST_L4_PORT,\n\tMLXSW_AFK_ELEMENT_SRC_L4_PORT,\n\tMLXSW_AFK_ELEMENT_VID,\n\tMLXSW_AFK_ELEMENT_PCP,\n\tMLXSW_AFK_ELEMENT_TCP_FLAGS,\n\tMLXSW_AFK_ELEMENT_IP_TTL_,\n\tMLXSW_AFK_ELEMENT_IP_ECN,\n\tMLXSW_AFK_ELEMENT_IP_DSCP,\n};\n\nstatic const enum mlxsw_afk_element mlxsw_sp_acl_tcam_pattern_ipv6[] = {\n\tMLXSW_AFK_ELEMENT_ETHERTYPE,\n\tMLXSW_AFK_ELEMENT_IP_PROTO,\n\tMLXSW_AFK_ELEMENT_SRC_IP_96_127,\n\tMLXSW_AFK_ELEMENT_SRC_IP_64_95,\n\tMLXSW_AFK_ELEMENT_SRC_IP_32_63,\n\tMLXSW_AFK_ELEMENT_SRC_IP_0_31,\n\tMLXSW_AFK_ELEMENT_DST_IP_96_127,\n\tMLXSW_AFK_ELEMENT_DST_IP_64_95,\n\tMLXSW_AFK_ELEMENT_DST_IP_32_63,\n\tMLXSW_AFK_ELEMENT_DST_IP_0_31,\n\tMLXSW_AFK_ELEMENT_DST_L4_PORT,\n\tMLXSW_AFK_ELEMENT_SRC_L4_PORT,\n};\n\nstatic const struct mlxsw_sp_acl_tcam_pattern mlxsw_sp_acl_tcam_patterns[] = {\n\t{\n\t\t.elements = mlxsw_sp_acl_tcam_pattern_ipv4,\n\t\t.elements_count = ARRAY_SIZE(mlxsw_sp_acl_tcam_pattern_ipv4),\n\t},\n\t{\n\t\t.elements = mlxsw_sp_acl_tcam_pattern_ipv6,\n\t\t.elements_count = ARRAY_SIZE(mlxsw_sp_acl_tcam_pattern_ipv6),\n\t},\n};\n\n#define MLXSW_SP_ACL_TCAM_PATTERNS_COUNT \\\n\tARRAY_SIZE(mlxsw_sp_acl_tcam_patterns)\n\nstruct mlxsw_sp_acl_tcam_flower_ruleset {\n\tstruct mlxsw_sp_acl_tcam_vgroup vgroup;\n};\n\nstruct mlxsw_sp_acl_tcam_flower_rule {\n\tstruct mlxsw_sp_acl_tcam_ventry ventry;\n};\n\nstatic int\nmlxsw_sp_acl_tcam_flower_ruleset_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_acl_tcam *tcam,\n\t\t\t\t     void *ruleset_priv,\n\t\t\t\t     struct mlxsw_afk_element_usage *tmplt_elusage,\n\t\t\t\t     unsigned int *p_min_prio,\n\t\t\t\t     unsigned int *p_max_prio)\n{\n\tstruct mlxsw_sp_acl_tcam_flower_ruleset *ruleset = ruleset_priv;\n\n\treturn mlxsw_sp_acl_tcam_vgroup_add(mlxsw_sp, tcam, &ruleset->vgroup,\n\t\t\t\t\t    mlxsw_sp_acl_tcam_patterns,\n\t\t\t\t\t    MLXSW_SP_ACL_TCAM_PATTERNS_COUNT,\n\t\t\t\t\t    tmplt_elusage, true,\n\t\t\t\t\t    p_min_prio, p_max_prio);\n}\n\nstatic void\nmlxsw_sp_acl_tcam_flower_ruleset_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     void *ruleset_priv)\n{\n\tstruct mlxsw_sp_acl_tcam_flower_ruleset *ruleset = ruleset_priv;\n\n\tmlxsw_sp_acl_tcam_vgroup_del(&ruleset->vgroup);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_flower_ruleset_bind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      void *ruleset_priv,\n\t\t\t\t      struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      bool ingress)\n{\n\tstruct mlxsw_sp_acl_tcam_flower_ruleset *ruleset = ruleset_priv;\n\n\treturn mlxsw_sp_acl_tcam_group_bind(mlxsw_sp, &ruleset->vgroup.group,\n\t\t\t\t\t    mlxsw_sp_port, ingress);\n}\n\nstatic void\nmlxsw_sp_acl_tcam_flower_ruleset_unbind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tvoid *ruleset_priv,\n\t\t\t\t\tstruct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\tbool ingress)\n{\n\tstruct mlxsw_sp_acl_tcam_flower_ruleset *ruleset = ruleset_priv;\n\n\tmlxsw_sp_acl_tcam_group_unbind(mlxsw_sp, &ruleset->vgroup.group,\n\t\t\t\t       mlxsw_sp_port, ingress);\n}\n\nstatic u16\nmlxsw_sp_acl_tcam_flower_ruleset_group_id(void *ruleset_priv)\n{\n\tstruct mlxsw_sp_acl_tcam_flower_ruleset *ruleset = ruleset_priv;\n\n\treturn mlxsw_sp_acl_tcam_group_id(&ruleset->vgroup.group);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_flower_rule_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  void *ruleset_priv, void *rule_priv,\n\t\t\t\t  struct mlxsw_sp_acl_rule_info *rulei)\n{\n\tstruct mlxsw_sp_acl_tcam_flower_ruleset *ruleset = ruleset_priv;\n\tstruct mlxsw_sp_acl_tcam_flower_rule *rule = rule_priv;\n\n\treturn mlxsw_sp_acl_tcam_ventry_add(mlxsw_sp, &ruleset->vgroup,\n\t\t\t\t\t    &rule->ventry, rulei);\n}\n\nstatic void\nmlxsw_sp_acl_tcam_flower_rule_del(struct mlxsw_sp *mlxsw_sp, void *rule_priv)\n{\n\tstruct mlxsw_sp_acl_tcam_flower_rule *rule = rule_priv;\n\n\tmlxsw_sp_acl_tcam_ventry_del(mlxsw_sp, &rule->ventry);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_flower_rule_action_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t     void *rule_priv,\n\t\t\t\t\t     struct mlxsw_sp_acl_rule_info *rulei)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nmlxsw_sp_acl_tcam_flower_rule_activity_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   void *rule_priv, bool *activity)\n{\n\tstruct mlxsw_sp_acl_tcam_flower_rule *rule = rule_priv;\n\n\treturn mlxsw_sp_acl_tcam_ventry_activity_get(mlxsw_sp, &rule->ventry,\n\t\t\t\t\t\t     activity);\n}\n\nstatic const struct mlxsw_sp_acl_profile_ops mlxsw_sp_acl_tcam_flower_ops = {\n\t.ruleset_priv_size\t= sizeof(struct mlxsw_sp_acl_tcam_flower_ruleset),\n\t.ruleset_add\t\t= mlxsw_sp_acl_tcam_flower_ruleset_add,\n\t.ruleset_del\t\t= mlxsw_sp_acl_tcam_flower_ruleset_del,\n\t.ruleset_bind\t\t= mlxsw_sp_acl_tcam_flower_ruleset_bind,\n\t.ruleset_unbind\t\t= mlxsw_sp_acl_tcam_flower_ruleset_unbind,\n\t.ruleset_group_id\t= mlxsw_sp_acl_tcam_flower_ruleset_group_id,\n\t.rule_priv_size\t\t= sizeof(struct mlxsw_sp_acl_tcam_flower_rule),\n\t.rule_add\t\t= mlxsw_sp_acl_tcam_flower_rule_add,\n\t.rule_del\t\t= mlxsw_sp_acl_tcam_flower_rule_del,\n\t.rule_action_replace\t= mlxsw_sp_acl_tcam_flower_rule_action_replace,\n\t.rule_activity_get\t= mlxsw_sp_acl_tcam_flower_rule_activity_get,\n};\n\nstruct mlxsw_sp_acl_tcam_mr_ruleset {\n\tstruct mlxsw_sp_acl_tcam_vchunk *vchunk;\n\tstruct mlxsw_sp_acl_tcam_vgroup vgroup;\n};\n\nstruct mlxsw_sp_acl_tcam_mr_rule {\n\tstruct mlxsw_sp_acl_tcam_ventry ventry;\n};\n\nstatic int\nmlxsw_sp_acl_tcam_mr_ruleset_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_acl_tcam *tcam,\n\t\t\t\t void *ruleset_priv,\n\t\t\t\t struct mlxsw_afk_element_usage *tmplt_elusage,\n\t\t\t\t unsigned int *p_min_prio,\n\t\t\t\t unsigned int *p_max_prio)\n{\n\tstruct mlxsw_sp_acl_tcam_mr_ruleset *ruleset = ruleset_priv;\n\tint err;\n\n\terr = mlxsw_sp_acl_tcam_vgroup_add(mlxsw_sp, tcam, &ruleset->vgroup,\n\t\t\t\t\t   mlxsw_sp_acl_tcam_patterns,\n\t\t\t\t\t   MLXSW_SP_ACL_TCAM_PATTERNS_COUNT,\n\t\t\t\t\t   tmplt_elusage, false,\n\t\t\t\t\t   p_min_prio, p_max_prio);\n\tif (err)\n\t\treturn err;\n\n\t \n\truleset->vchunk = mlxsw_sp_acl_tcam_vchunk_get(mlxsw_sp,\n\t\t\t\t\t\t       &ruleset->vgroup, 1,\n\t\t\t\t\t\t       tmplt_elusage);\n\tif (IS_ERR(ruleset->vchunk)) {\n\t\terr = PTR_ERR(ruleset->vchunk);\n\t\tgoto err_chunk_get;\n\t}\n\n\treturn 0;\n\nerr_chunk_get:\n\tmlxsw_sp_acl_tcam_vgroup_del(&ruleset->vgroup);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_acl_tcam_mr_ruleset_del(struct mlxsw_sp *mlxsw_sp, void *ruleset_priv)\n{\n\tstruct mlxsw_sp_acl_tcam_mr_ruleset *ruleset = ruleset_priv;\n\n\tmlxsw_sp_acl_tcam_vchunk_put(mlxsw_sp, ruleset->vchunk);\n\tmlxsw_sp_acl_tcam_vgroup_del(&ruleset->vgroup);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_mr_ruleset_bind(struct mlxsw_sp *mlxsw_sp, void *ruleset_priv,\n\t\t\t\t  struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  bool ingress)\n{\n\t \n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_acl_tcam_mr_ruleset_unbind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    void *ruleset_priv,\n\t\t\t\t    struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    bool ingress)\n{\n}\n\nstatic u16\nmlxsw_sp_acl_tcam_mr_ruleset_group_id(void *ruleset_priv)\n{\n\tstruct mlxsw_sp_acl_tcam_mr_ruleset *ruleset = ruleset_priv;\n\n\treturn mlxsw_sp_acl_tcam_group_id(&ruleset->vgroup.group);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_mr_rule_add(struct mlxsw_sp *mlxsw_sp, void *ruleset_priv,\n\t\t\t      void *rule_priv,\n\t\t\t      struct mlxsw_sp_acl_rule_info *rulei)\n{\n\tstruct mlxsw_sp_acl_tcam_mr_ruleset *ruleset = ruleset_priv;\n\tstruct mlxsw_sp_acl_tcam_mr_rule *rule = rule_priv;\n\n\treturn mlxsw_sp_acl_tcam_ventry_add(mlxsw_sp, &ruleset->vgroup,\n\t\t\t\t\t   &rule->ventry, rulei);\n}\n\nstatic void\nmlxsw_sp_acl_tcam_mr_rule_del(struct mlxsw_sp *mlxsw_sp, void *rule_priv)\n{\n\tstruct mlxsw_sp_acl_tcam_mr_rule *rule = rule_priv;\n\n\tmlxsw_sp_acl_tcam_ventry_del(mlxsw_sp, &rule->ventry);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_mr_rule_action_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t void *rule_priv,\n\t\t\t\t\t struct mlxsw_sp_acl_rule_info *rulei)\n{\n\tstruct mlxsw_sp_acl_tcam_mr_rule *rule = rule_priv;\n\n\treturn mlxsw_sp_acl_tcam_ventry_action_replace(mlxsw_sp, &rule->ventry,\n\t\t\t\t\t\t       rulei);\n}\n\nstatic int\nmlxsw_sp_acl_tcam_mr_rule_activity_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       void *rule_priv, bool *activity)\n{\n\t*activity = false;\n\n\treturn 0;\n}\n\nstatic const struct mlxsw_sp_acl_profile_ops mlxsw_sp_acl_tcam_mr_ops = {\n\t.ruleset_priv_size\t= sizeof(struct mlxsw_sp_acl_tcam_mr_ruleset),\n\t.ruleset_add\t\t= mlxsw_sp_acl_tcam_mr_ruleset_add,\n\t.ruleset_del\t\t= mlxsw_sp_acl_tcam_mr_ruleset_del,\n\t.ruleset_bind\t\t= mlxsw_sp_acl_tcam_mr_ruleset_bind,\n\t.ruleset_unbind\t\t= mlxsw_sp_acl_tcam_mr_ruleset_unbind,\n\t.ruleset_group_id\t= mlxsw_sp_acl_tcam_mr_ruleset_group_id,\n\t.rule_priv_size\t\t= sizeof(struct mlxsw_sp_acl_tcam_mr_rule),\n\t.rule_add\t\t= mlxsw_sp_acl_tcam_mr_rule_add,\n\t.rule_del\t\t= mlxsw_sp_acl_tcam_mr_rule_del,\n\t.rule_action_replace\t= mlxsw_sp_acl_tcam_mr_rule_action_replace,\n\t.rule_activity_get\t= mlxsw_sp_acl_tcam_mr_rule_activity_get,\n};\n\nstatic const struct mlxsw_sp_acl_profile_ops *\nmlxsw_sp_acl_tcam_profile_ops_arr[] = {\n\t[MLXSW_SP_ACL_PROFILE_FLOWER] = &mlxsw_sp_acl_tcam_flower_ops,\n\t[MLXSW_SP_ACL_PROFILE_MR] = &mlxsw_sp_acl_tcam_mr_ops,\n};\n\nconst struct mlxsw_sp_acl_profile_ops *\nmlxsw_sp_acl_tcam_profile_ops(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      enum mlxsw_sp_acl_profile profile)\n{\n\tconst struct mlxsw_sp_acl_profile_ops *ops;\n\n\tif (WARN_ON(profile >= ARRAY_SIZE(mlxsw_sp_acl_tcam_profile_ops_arr)))\n\t\treturn NULL;\n\tops = mlxsw_sp_acl_tcam_profile_ops_arr[profile];\n\tif (WARN_ON(!ops))\n\t\treturn NULL;\n\treturn ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}