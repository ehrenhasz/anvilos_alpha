{
  "module_name": "pci.c",
  "hash_id": "9baf3012afbe60cddea08636b4ab13d2c16c8a1b54093e1ee4932db1033b9b9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/if_vlan.h>\n#include <linux/log2.h>\n#include <linux/string.h>\n\n#include \"pci_hw.h\"\n#include \"pci.h\"\n#include \"core.h\"\n#include \"cmd.h\"\n#include \"port.h\"\n#include \"resources.h\"\n\n#define mlxsw_pci_write32(mlxsw_pci, reg, val) \\\n\tiowrite32be(val, (mlxsw_pci)->hw_addr + (MLXSW_PCI_ ## reg))\n#define mlxsw_pci_read32(mlxsw_pci, reg) \\\n\tioread32be((mlxsw_pci)->hw_addr + (MLXSW_PCI_ ## reg))\n\nenum mlxsw_pci_queue_type {\n\tMLXSW_PCI_QUEUE_TYPE_SDQ,\n\tMLXSW_PCI_QUEUE_TYPE_RDQ,\n\tMLXSW_PCI_QUEUE_TYPE_CQ,\n\tMLXSW_PCI_QUEUE_TYPE_EQ,\n};\n\n#define MLXSW_PCI_QUEUE_TYPE_COUNT\t4\n\nstatic const u16 mlxsw_pci_doorbell_type_offset[] = {\n\tMLXSW_PCI_DOORBELL_SDQ_OFFSET,\t \n\tMLXSW_PCI_DOORBELL_RDQ_OFFSET,\t \n\tMLXSW_PCI_DOORBELL_CQ_OFFSET,\t \n\tMLXSW_PCI_DOORBELL_EQ_OFFSET,\t \n};\n\nstatic const u16 mlxsw_pci_doorbell_arm_type_offset[] = {\n\t0,  \n\t0,  \n\tMLXSW_PCI_DOORBELL_ARM_CQ_OFFSET,  \n\tMLXSW_PCI_DOORBELL_ARM_EQ_OFFSET,  \n};\n\nstruct mlxsw_pci_mem_item {\n\tchar *buf;\n\tdma_addr_t mapaddr;\n\tsize_t size;\n};\n\nstruct mlxsw_pci_queue_elem_info {\n\tchar *elem;  \n\tunion {\n\t\tstruct {\n\t\t\tstruct sk_buff *skb;\n\t\t} sdq;\n\t\tstruct {\n\t\t\tstruct sk_buff *skb;\n\t\t} rdq;\n\t} u;\n};\n\nstruct mlxsw_pci_queue {\n\tspinlock_t lock;  \n\tstruct mlxsw_pci_mem_item mem_item;\n\tstruct mlxsw_pci_queue_elem_info *elem_info;\n\tu16 producer_counter;\n\tu16 consumer_counter;\n\tu16 count;  \n\tu8 num;  \n\tu8 elem_size;  \n\tenum mlxsw_pci_queue_type type;\n\tstruct tasklet_struct tasklet;  \n\tstruct mlxsw_pci *pci;\n\tunion {\n\t\tstruct {\n\t\t\tu32 comp_sdq_count;\n\t\t\tu32 comp_rdq_count;\n\t\t\tenum mlxsw_pci_cqe_v v;\n\t\t} cq;\n\t\tstruct {\n\t\t\tu32 ev_cmd_count;\n\t\t\tu32 ev_comp_count;\n\t\t\tu32 ev_other_count;\n\t\t} eq;\n\t} u;\n};\n\nstruct mlxsw_pci_queue_type_group {\n\tstruct mlxsw_pci_queue *q;\n\tu8 count;  \n};\n\nstruct mlxsw_pci {\n\tstruct pci_dev *pdev;\n\tu8 __iomem *hw_addr;\n\tu64 free_running_clock_offset;\n\tu64 utc_sec_offset;\n\tu64 utc_nsec_offset;\n\tstruct mlxsw_pci_queue_type_group queues[MLXSW_PCI_QUEUE_TYPE_COUNT];\n\tu32 doorbell_offset;\n\tstruct mlxsw_core *core;\n\tstruct {\n\t\tstruct mlxsw_pci_mem_item *items;\n\t\tunsigned int count;\n\t} fw_area;\n\tstruct {\n\t\tstruct mlxsw_pci_mem_item out_mbox;\n\t\tstruct mlxsw_pci_mem_item in_mbox;\n\t\tstruct mutex lock;  \n\t\tbool nopoll;\n\t\twait_queue_head_t wait;\n\t\tbool wait_done;\n\t\tstruct {\n\t\t\tu8 status;\n\t\t\tu64 out_param;\n\t\t} comp;\n\t} cmd;\n\tstruct mlxsw_bus_info bus_info;\n\tconst struct pci_device_id *id;\n\tenum mlxsw_pci_cqe_v max_cqe_ver;  \n\tu8 num_sdq_cqs;  \n};\n\nstatic void mlxsw_pci_queue_tasklet_schedule(struct mlxsw_pci_queue *q)\n{\n\ttasklet_schedule(&q->tasklet);\n}\n\nstatic char *__mlxsw_pci_queue_elem_get(struct mlxsw_pci_queue *q,\n\t\t\t\t\tsize_t elem_size, int elem_index)\n{\n\treturn q->mem_item.buf + (elem_size * elem_index);\n}\n\nstatic struct mlxsw_pci_queue_elem_info *\nmlxsw_pci_queue_elem_info_get(struct mlxsw_pci_queue *q, int elem_index)\n{\n\treturn &q->elem_info[elem_index];\n}\n\nstatic struct mlxsw_pci_queue_elem_info *\nmlxsw_pci_queue_elem_info_producer_get(struct mlxsw_pci_queue *q)\n{\n\tint index = q->producer_counter & (q->count - 1);\n\n\tif ((u16) (q->producer_counter - q->consumer_counter) == q->count)\n\t\treturn NULL;\n\treturn mlxsw_pci_queue_elem_info_get(q, index);\n}\n\nstatic struct mlxsw_pci_queue_elem_info *\nmlxsw_pci_queue_elem_info_consumer_get(struct mlxsw_pci_queue *q)\n{\n\tint index = q->consumer_counter & (q->count - 1);\n\n\treturn mlxsw_pci_queue_elem_info_get(q, index);\n}\n\nstatic char *mlxsw_pci_queue_elem_get(struct mlxsw_pci_queue *q, int elem_index)\n{\n\treturn mlxsw_pci_queue_elem_info_get(q, elem_index)->elem;\n}\n\nstatic bool mlxsw_pci_elem_hw_owned(struct mlxsw_pci_queue *q, bool owner_bit)\n{\n\treturn owner_bit != !!(q->consumer_counter & q->count);\n}\n\nstatic struct mlxsw_pci_queue_type_group *\nmlxsw_pci_queue_type_group_get(struct mlxsw_pci *mlxsw_pci,\n\t\t\t       enum mlxsw_pci_queue_type q_type)\n{\n\treturn &mlxsw_pci->queues[q_type];\n}\n\nstatic u8 __mlxsw_pci_queue_count(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t  enum mlxsw_pci_queue_type q_type)\n{\n\tstruct mlxsw_pci_queue_type_group *queue_group;\n\n\tqueue_group = mlxsw_pci_queue_type_group_get(mlxsw_pci, q_type);\n\treturn queue_group->count;\n}\n\nstatic u8 mlxsw_pci_sdq_count(struct mlxsw_pci *mlxsw_pci)\n{\n\treturn __mlxsw_pci_queue_count(mlxsw_pci, MLXSW_PCI_QUEUE_TYPE_SDQ);\n}\n\nstatic u8 mlxsw_pci_cq_count(struct mlxsw_pci *mlxsw_pci)\n{\n\treturn __mlxsw_pci_queue_count(mlxsw_pci, MLXSW_PCI_QUEUE_TYPE_CQ);\n}\n\nstatic struct mlxsw_pci_queue *\n__mlxsw_pci_queue_get(struct mlxsw_pci *mlxsw_pci,\n\t\t      enum mlxsw_pci_queue_type q_type, u8 q_num)\n{\n\treturn &mlxsw_pci->queues[q_type].q[q_num];\n}\n\nstatic struct mlxsw_pci_queue *mlxsw_pci_sdq_get(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t\t\t u8 q_num)\n{\n\treturn __mlxsw_pci_queue_get(mlxsw_pci,\n\t\t\t\t     MLXSW_PCI_QUEUE_TYPE_SDQ, q_num);\n}\n\nstatic struct mlxsw_pci_queue *mlxsw_pci_rdq_get(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t\t\t u8 q_num)\n{\n\treturn __mlxsw_pci_queue_get(mlxsw_pci,\n\t\t\t\t     MLXSW_PCI_QUEUE_TYPE_RDQ, q_num);\n}\n\nstatic struct mlxsw_pci_queue *mlxsw_pci_cq_get(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t\t\tu8 q_num)\n{\n\treturn __mlxsw_pci_queue_get(mlxsw_pci, MLXSW_PCI_QUEUE_TYPE_CQ, q_num);\n}\n\nstatic struct mlxsw_pci_queue *mlxsw_pci_eq_get(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t\t\tu8 q_num)\n{\n\treturn __mlxsw_pci_queue_get(mlxsw_pci, MLXSW_PCI_QUEUE_TYPE_EQ, q_num);\n}\n\nstatic void __mlxsw_pci_queue_doorbell_set(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t\t   struct mlxsw_pci_queue *q,\n\t\t\t\t\t   u16 val)\n{\n\tmlxsw_pci_write32(mlxsw_pci,\n\t\t\t  DOORBELL(mlxsw_pci->doorbell_offset,\n\t\t\t\t   mlxsw_pci_doorbell_type_offset[q->type],\n\t\t\t\t   q->num), val);\n}\n\nstatic void __mlxsw_pci_queue_doorbell_arm_set(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t\t       struct mlxsw_pci_queue *q,\n\t\t\t\t\t       u16 val)\n{\n\tmlxsw_pci_write32(mlxsw_pci,\n\t\t\t  DOORBELL(mlxsw_pci->doorbell_offset,\n\t\t\t\t   mlxsw_pci_doorbell_arm_type_offset[q->type],\n\t\t\t\t   q->num), val);\n}\n\nstatic void mlxsw_pci_queue_doorbell_producer_ring(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t\t\t   struct mlxsw_pci_queue *q)\n{\n\twmb();  \n\t__mlxsw_pci_queue_doorbell_set(mlxsw_pci, q, q->producer_counter);\n}\n\nstatic void mlxsw_pci_queue_doorbell_consumer_ring(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t\t\t   struct mlxsw_pci_queue *q)\n{\n\twmb();  \n\t__mlxsw_pci_queue_doorbell_set(mlxsw_pci, q,\n\t\t\t\t       q->consumer_counter + q->count);\n}\n\nstatic void\nmlxsw_pci_queue_doorbell_arm_consumer_ring(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t\t   struct mlxsw_pci_queue *q)\n{\n\twmb();  \n\t__mlxsw_pci_queue_doorbell_arm_set(mlxsw_pci, q, q->consumer_counter);\n}\n\nstatic dma_addr_t __mlxsw_pci_queue_page_get(struct mlxsw_pci_queue *q,\n\t\t\t\t\t     int page_index)\n{\n\treturn q->mem_item.mapaddr + MLXSW_PCI_PAGE_SIZE * page_index;\n}\n\nstatic int mlxsw_pci_sdq_init(struct mlxsw_pci *mlxsw_pci, char *mbox,\n\t\t\t      struct mlxsw_pci_queue *q)\n{\n\tint tclass;\n\tint lp;\n\tint i;\n\tint err;\n\n\tq->producer_counter = 0;\n\tq->consumer_counter = 0;\n\ttclass = q->num == MLXSW_PCI_SDQ_EMAD_INDEX ? MLXSW_PCI_SDQ_EMAD_TC :\n\t\t\t\t\t\t      MLXSW_PCI_SDQ_CTL_TC;\n\tlp = q->num == MLXSW_PCI_SDQ_EMAD_INDEX ? MLXSW_CMD_MBOX_SW2HW_DQ_SDQ_LP_IGNORE_WQE :\n\t\t\t\t\t\t  MLXSW_CMD_MBOX_SW2HW_DQ_SDQ_LP_WQE;\n\n\t \n\tmlxsw_cmd_mbox_sw2hw_dq_cq_set(mbox, q->num);\n\tmlxsw_cmd_mbox_sw2hw_dq_sdq_lp_set(mbox, lp);\n\tmlxsw_cmd_mbox_sw2hw_dq_sdq_tclass_set(mbox, tclass);\n\tmlxsw_cmd_mbox_sw2hw_dq_log2_dq_sz_set(mbox, 3);  \n\tfor (i = 0; i < MLXSW_PCI_AQ_PAGES; i++) {\n\t\tdma_addr_t mapaddr = __mlxsw_pci_queue_page_get(q, i);\n\n\t\tmlxsw_cmd_mbox_sw2hw_dq_pa_set(mbox, i, mapaddr);\n\t}\n\n\terr = mlxsw_cmd_sw2hw_sdq(mlxsw_pci->core, mbox, q->num);\n\tif (err)\n\t\treturn err;\n\tmlxsw_pci_queue_doorbell_producer_ring(mlxsw_pci, q);\n\treturn 0;\n}\n\nstatic void mlxsw_pci_sdq_fini(struct mlxsw_pci *mlxsw_pci,\n\t\t\t       struct mlxsw_pci_queue *q)\n{\n\tmlxsw_cmd_hw2sw_sdq(mlxsw_pci->core, q->num);\n}\n\nstatic int mlxsw_pci_wqe_frag_map(struct mlxsw_pci *mlxsw_pci, char *wqe,\n\t\t\t\t  int index, char *frag_data, size_t frag_len,\n\t\t\t\t  int direction)\n{\n\tstruct pci_dev *pdev = mlxsw_pci->pdev;\n\tdma_addr_t mapaddr;\n\n\tmapaddr = dma_map_single(&pdev->dev, frag_data, frag_len, direction);\n\tif (unlikely(dma_mapping_error(&pdev->dev, mapaddr))) {\n\t\tdev_err_ratelimited(&pdev->dev, \"failed to dma map tx frag\\n\");\n\t\treturn -EIO;\n\t}\n\tmlxsw_pci_wqe_address_set(wqe, index, mapaddr);\n\tmlxsw_pci_wqe_byte_count_set(wqe, index, frag_len);\n\treturn 0;\n}\n\nstatic void mlxsw_pci_wqe_frag_unmap(struct mlxsw_pci *mlxsw_pci, char *wqe,\n\t\t\t\t     int index, int direction)\n{\n\tstruct pci_dev *pdev = mlxsw_pci->pdev;\n\tsize_t frag_len = mlxsw_pci_wqe_byte_count_get(wqe, index);\n\tdma_addr_t mapaddr = mlxsw_pci_wqe_address_get(wqe, index);\n\n\tif (!frag_len)\n\t\treturn;\n\tdma_unmap_single(&pdev->dev, mapaddr, frag_len, direction);\n}\n\nstatic int mlxsw_pci_rdq_skb_alloc(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t   struct mlxsw_pci_queue_elem_info *elem_info)\n{\n\tsize_t buf_len = MLXSW_PORT_MAX_MTU;\n\tchar *wqe = elem_info->elem;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = netdev_alloc_skb_ip_align(NULL, buf_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\terr = mlxsw_pci_wqe_frag_map(mlxsw_pci, wqe, 0, skb->data,\n\t\t\t\t     buf_len, DMA_FROM_DEVICE);\n\tif (err)\n\t\tgoto err_frag_map;\n\n\telem_info->u.rdq.skb = skb;\n\treturn 0;\n\nerr_frag_map:\n\tdev_kfree_skb_any(skb);\n\treturn err;\n}\n\nstatic void mlxsw_pci_rdq_skb_free(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t   struct mlxsw_pci_queue_elem_info *elem_info)\n{\n\tstruct sk_buff *skb;\n\tchar *wqe;\n\n\tskb = elem_info->u.rdq.skb;\n\twqe = elem_info->elem;\n\n\tmlxsw_pci_wqe_frag_unmap(mlxsw_pci, wqe, 0, DMA_FROM_DEVICE);\n\tdev_kfree_skb_any(skb);\n}\n\nstatic int mlxsw_pci_rdq_init(struct mlxsw_pci *mlxsw_pci, char *mbox,\n\t\t\t      struct mlxsw_pci_queue *q)\n{\n\tstruct mlxsw_pci_queue_elem_info *elem_info;\n\tu8 sdq_count = mlxsw_pci_sdq_count(mlxsw_pci);\n\tint i;\n\tint err;\n\n\tq->producer_counter = 0;\n\tq->consumer_counter = 0;\n\n\t \n\tmlxsw_cmd_mbox_sw2hw_dq_cq_set(mbox, sdq_count + q->num);\n\tmlxsw_cmd_mbox_sw2hw_dq_log2_dq_sz_set(mbox, 3);  \n\tfor (i = 0; i < MLXSW_PCI_AQ_PAGES; i++) {\n\t\tdma_addr_t mapaddr = __mlxsw_pci_queue_page_get(q, i);\n\n\t\tmlxsw_cmd_mbox_sw2hw_dq_pa_set(mbox, i, mapaddr);\n\t}\n\n\terr = mlxsw_cmd_sw2hw_rdq(mlxsw_pci->core, mbox, q->num);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_pci_queue_doorbell_producer_ring(mlxsw_pci, q);\n\n\tfor (i = 0; i < q->count; i++) {\n\t\telem_info = mlxsw_pci_queue_elem_info_producer_get(q);\n\t\tBUG_ON(!elem_info);\n\t\terr = mlxsw_pci_rdq_skb_alloc(mlxsw_pci, elem_info);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t\t \n\t\tq->producer_counter++;\n\t\tmlxsw_pci_queue_doorbell_producer_ring(mlxsw_pci, q);\n\t}\n\n\treturn 0;\n\nrollback:\n\tfor (i--; i >= 0; i--) {\n\t\telem_info = mlxsw_pci_queue_elem_info_get(q, i);\n\t\tmlxsw_pci_rdq_skb_free(mlxsw_pci, elem_info);\n\t}\n\tmlxsw_cmd_hw2sw_rdq(mlxsw_pci->core, q->num);\n\n\treturn err;\n}\n\nstatic void mlxsw_pci_rdq_fini(struct mlxsw_pci *mlxsw_pci,\n\t\t\t       struct mlxsw_pci_queue *q)\n{\n\tstruct mlxsw_pci_queue_elem_info *elem_info;\n\tint i;\n\n\tmlxsw_cmd_hw2sw_rdq(mlxsw_pci->core, q->num);\n\tfor (i = 0; i < q->count; i++) {\n\t\telem_info = mlxsw_pci_queue_elem_info_get(q, i);\n\t\tmlxsw_pci_rdq_skb_free(mlxsw_pci, elem_info);\n\t}\n}\n\nstatic void mlxsw_pci_cq_pre_init(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t  struct mlxsw_pci_queue *q)\n{\n\tq->u.cq.v = mlxsw_pci->max_cqe_ver;\n\n\tif (q->u.cq.v == MLXSW_PCI_CQE_V2 &&\n\t    q->num < mlxsw_pci->num_sdq_cqs &&\n\t    !mlxsw_core_sdq_supports_cqe_v2(mlxsw_pci->core))\n\t\tq->u.cq.v = MLXSW_PCI_CQE_V1;\n}\n\nstatic int mlxsw_pci_cq_init(struct mlxsw_pci *mlxsw_pci, char *mbox,\n\t\t\t     struct mlxsw_pci_queue *q)\n{\n\tint i;\n\tint err;\n\n\tq->consumer_counter = 0;\n\n\tfor (i = 0; i < q->count; i++) {\n\t\tchar *elem = mlxsw_pci_queue_elem_get(q, i);\n\n\t\tmlxsw_pci_cqe_owner_set(q->u.cq.v, elem, 1);\n\t}\n\n\tif (q->u.cq.v == MLXSW_PCI_CQE_V1)\n\t\tmlxsw_cmd_mbox_sw2hw_cq_cqe_ver_set(mbox,\n\t\t\t\tMLXSW_CMD_MBOX_SW2HW_CQ_CQE_VER_1);\n\telse if (q->u.cq.v == MLXSW_PCI_CQE_V2)\n\t\tmlxsw_cmd_mbox_sw2hw_cq_cqe_ver_set(mbox,\n\t\t\t\tMLXSW_CMD_MBOX_SW2HW_CQ_CQE_VER_2);\n\n\tmlxsw_cmd_mbox_sw2hw_cq_c_eqn_set(mbox, MLXSW_PCI_EQ_COMP_NUM);\n\tmlxsw_cmd_mbox_sw2hw_cq_st_set(mbox, 0);\n\tmlxsw_cmd_mbox_sw2hw_cq_log_cq_size_set(mbox, ilog2(q->count));\n\tfor (i = 0; i < MLXSW_PCI_AQ_PAGES; i++) {\n\t\tdma_addr_t mapaddr = __mlxsw_pci_queue_page_get(q, i);\n\n\t\tmlxsw_cmd_mbox_sw2hw_cq_pa_set(mbox, i, mapaddr);\n\t}\n\terr = mlxsw_cmd_sw2hw_cq(mlxsw_pci->core, mbox, q->num);\n\tif (err)\n\t\treturn err;\n\tmlxsw_pci_queue_doorbell_consumer_ring(mlxsw_pci, q);\n\tmlxsw_pci_queue_doorbell_arm_consumer_ring(mlxsw_pci, q);\n\treturn 0;\n}\n\nstatic void mlxsw_pci_cq_fini(struct mlxsw_pci *mlxsw_pci,\n\t\t\t      struct mlxsw_pci_queue *q)\n{\n\tmlxsw_cmd_hw2sw_cq(mlxsw_pci->core, q->num);\n}\n\nstatic unsigned int mlxsw_pci_read32_off(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t\t ptrdiff_t off)\n{\n\treturn ioread32be(mlxsw_pci->hw_addr + off);\n}\n\nstatic void mlxsw_pci_skb_cb_ts_set(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    enum mlxsw_pci_cqe_v cqe_v, char *cqe)\n{\n\tu8 ts_type;\n\n\tif (cqe_v != MLXSW_PCI_CQE_V2)\n\t\treturn;\n\n\tts_type = mlxsw_pci_cqe2_time_stamp_type_get(cqe);\n\n\tif (ts_type != MLXSW_PCI_CQE_TIME_STAMP_TYPE_UTC &&\n\t    ts_type != MLXSW_PCI_CQE_TIME_STAMP_TYPE_MIRROR_UTC)\n\t\treturn;\n\n\tmlxsw_skb_cb(skb)->cqe_ts.sec = mlxsw_pci_cqe2_time_stamp_sec_get(cqe);\n\tmlxsw_skb_cb(skb)->cqe_ts.nsec =\n\t\tmlxsw_pci_cqe2_time_stamp_nsec_get(cqe);\n}\n\nstatic void mlxsw_pci_cqe_sdq_handle(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t     struct mlxsw_pci_queue *q,\n\t\t\t\t     u16 consumer_counter_limit,\n\t\t\t\t     enum mlxsw_pci_cqe_v cqe_v,\n\t\t\t\t     char *cqe)\n{\n\tstruct pci_dev *pdev = mlxsw_pci->pdev;\n\tstruct mlxsw_pci_queue_elem_info *elem_info;\n\tstruct mlxsw_tx_info tx_info;\n\tchar *wqe;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tspin_lock(&q->lock);\n\telem_info = mlxsw_pci_queue_elem_info_consumer_get(q);\n\ttx_info = mlxsw_skb_cb(elem_info->u.sdq.skb)->tx_info;\n\tskb = elem_info->u.sdq.skb;\n\twqe = elem_info->elem;\n\tfor (i = 0; i < MLXSW_PCI_WQE_SG_ENTRIES; i++)\n\t\tmlxsw_pci_wqe_frag_unmap(mlxsw_pci, wqe, i, DMA_TO_DEVICE);\n\n\tif (unlikely(!tx_info.is_emad &&\n\t\t     skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {\n\t\tmlxsw_pci_skb_cb_ts_set(mlxsw_pci, skb, cqe_v, cqe);\n\t\tmlxsw_core_ptp_transmitted(mlxsw_pci->core, skb,\n\t\t\t\t\t   tx_info.local_port);\n\t\tskb = NULL;\n\t}\n\n\tif (skb)\n\t\tdev_kfree_skb_any(skb);\n\telem_info->u.sdq.skb = NULL;\n\n\tif (q->consumer_counter++ != consumer_counter_limit)\n\t\tdev_dbg_ratelimited(&pdev->dev, \"Consumer counter does not match limit in SDQ\\n\");\n\tspin_unlock(&q->lock);\n}\n\nstatic void mlxsw_pci_cqe_rdq_md_tx_port_init(struct sk_buff *skb,\n\t\t\t\t\t      const char *cqe)\n{\n\tstruct mlxsw_skb_cb *cb = mlxsw_skb_cb(skb);\n\n\tif (mlxsw_pci_cqe2_tx_lag_get(cqe)) {\n\t\tcb->rx_md_info.tx_port_is_lag = true;\n\t\tcb->rx_md_info.tx_lag_id = mlxsw_pci_cqe2_tx_lag_id_get(cqe);\n\t\tcb->rx_md_info.tx_lag_port_index =\n\t\t\tmlxsw_pci_cqe2_tx_lag_subport_get(cqe);\n\t} else {\n\t\tcb->rx_md_info.tx_port_is_lag = false;\n\t\tcb->rx_md_info.tx_sys_port =\n\t\t\tmlxsw_pci_cqe2_tx_system_port_get(cqe);\n\t}\n\n\tif (cb->rx_md_info.tx_sys_port != MLXSW_PCI_CQE2_TX_PORT_MULTI_PORT &&\n\t    cb->rx_md_info.tx_sys_port != MLXSW_PCI_CQE2_TX_PORT_INVALID)\n\t\tcb->rx_md_info.tx_port_valid = 1;\n\telse\n\t\tcb->rx_md_info.tx_port_valid = 0;\n}\n\nstatic void mlxsw_pci_cqe_rdq_md_init(struct sk_buff *skb, const char *cqe)\n{\n\tstruct mlxsw_skb_cb *cb = mlxsw_skb_cb(skb);\n\n\tcb->rx_md_info.tx_congestion = mlxsw_pci_cqe2_mirror_cong_get(cqe);\n\tif (cb->rx_md_info.tx_congestion != MLXSW_PCI_CQE2_MIRROR_CONG_INVALID)\n\t\tcb->rx_md_info.tx_congestion_valid = 1;\n\telse\n\t\tcb->rx_md_info.tx_congestion_valid = 0;\n\tcb->rx_md_info.tx_congestion <<= MLXSW_PCI_CQE2_MIRROR_CONG_SHIFT;\n\n\tcb->rx_md_info.latency = mlxsw_pci_cqe2_mirror_latency_get(cqe);\n\tif (cb->rx_md_info.latency != MLXSW_PCI_CQE2_MIRROR_LATENCY_INVALID)\n\t\tcb->rx_md_info.latency_valid = 1;\n\telse\n\t\tcb->rx_md_info.latency_valid = 0;\n\n\tcb->rx_md_info.tx_tc = mlxsw_pci_cqe2_mirror_tclass_get(cqe);\n\tif (cb->rx_md_info.tx_tc != MLXSW_PCI_CQE2_MIRROR_TCLASS_INVALID)\n\t\tcb->rx_md_info.tx_tc_valid = 1;\n\telse\n\t\tcb->rx_md_info.tx_tc_valid = 0;\n\n\tmlxsw_pci_cqe_rdq_md_tx_port_init(skb, cqe);\n}\n\nstatic void mlxsw_pci_cqe_rdq_handle(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t     struct mlxsw_pci_queue *q,\n\t\t\t\t     u16 consumer_counter_limit,\n\t\t\t\t     enum mlxsw_pci_cqe_v cqe_v, char *cqe)\n{\n\tstruct pci_dev *pdev = mlxsw_pci->pdev;\n\tstruct mlxsw_pci_queue_elem_info *elem_info;\n\tstruct mlxsw_rx_info rx_info = {};\n\tchar wqe[MLXSW_PCI_WQE_SIZE];\n\tstruct sk_buff *skb;\n\tu16 byte_count;\n\tint err;\n\n\telem_info = mlxsw_pci_queue_elem_info_consumer_get(q);\n\tskb = elem_info->u.rdq.skb;\n\tmemcpy(wqe, elem_info->elem, MLXSW_PCI_WQE_SIZE);\n\n\tif (q->consumer_counter++ != consumer_counter_limit)\n\t\tdev_dbg_ratelimited(&pdev->dev, \"Consumer counter does not match limit in RDQ\\n\");\n\n\terr = mlxsw_pci_rdq_skb_alloc(mlxsw_pci, elem_info);\n\tif (err) {\n\t\tdev_err_ratelimited(&pdev->dev, \"Failed to alloc skb for RDQ\\n\");\n\t\tgoto out;\n\t}\n\n\tmlxsw_pci_wqe_frag_unmap(mlxsw_pci, wqe, 0, DMA_FROM_DEVICE);\n\n\tif (mlxsw_pci_cqe_lag_get(cqe_v, cqe)) {\n\t\trx_info.is_lag = true;\n\t\trx_info.u.lag_id = mlxsw_pci_cqe_lag_id_get(cqe_v, cqe);\n\t\trx_info.lag_port_index =\n\t\t\tmlxsw_pci_cqe_lag_subport_get(cqe_v, cqe);\n\t} else {\n\t\trx_info.is_lag = false;\n\t\trx_info.u.sys_port = mlxsw_pci_cqe_system_port_get(cqe);\n\t}\n\n\trx_info.trap_id = mlxsw_pci_cqe_trap_id_get(cqe);\n\n\tif (rx_info.trap_id == MLXSW_TRAP_ID_DISCARD_INGRESS_ACL ||\n\t    rx_info.trap_id == MLXSW_TRAP_ID_DISCARD_EGRESS_ACL) {\n\t\tu32 cookie_index = 0;\n\n\t\tif (mlxsw_pci->max_cqe_ver >= MLXSW_PCI_CQE_V2)\n\t\t\tcookie_index = mlxsw_pci_cqe2_user_def_val_orig_pkt_len_get(cqe);\n\t\tmlxsw_skb_cb(skb)->rx_md_info.cookie_index = cookie_index;\n\t} else if (rx_info.trap_id >= MLXSW_TRAP_ID_MIRROR_SESSION0 &&\n\t\t   rx_info.trap_id <= MLXSW_TRAP_ID_MIRROR_SESSION7 &&\n\t\t   mlxsw_pci->max_cqe_ver >= MLXSW_PCI_CQE_V2) {\n\t\trx_info.mirror_reason = mlxsw_pci_cqe2_mirror_reason_get(cqe);\n\t\tmlxsw_pci_cqe_rdq_md_init(skb, cqe);\n\t} else if (rx_info.trap_id == MLXSW_TRAP_ID_PKT_SAMPLE &&\n\t\t   mlxsw_pci->max_cqe_ver >= MLXSW_PCI_CQE_V2) {\n\t\tmlxsw_pci_cqe_rdq_md_tx_port_init(skb, cqe);\n\t}\n\n\tmlxsw_pci_skb_cb_ts_set(mlxsw_pci, skb, cqe_v, cqe);\n\n\tbyte_count = mlxsw_pci_cqe_byte_count_get(cqe);\n\tif (mlxsw_pci_cqe_crc_get(cqe_v, cqe))\n\t\tbyte_count -= ETH_FCS_LEN;\n\tskb_put(skb, byte_count);\n\tmlxsw_core_skb_receive(mlxsw_pci->core, skb, &rx_info);\n\nout:\n\t \n\tq->producer_counter++;\n\tmlxsw_pci_queue_doorbell_producer_ring(mlxsw_pci, q);\n\treturn;\n}\n\nstatic char *mlxsw_pci_cq_sw_cqe_get(struct mlxsw_pci_queue *q)\n{\n\tstruct mlxsw_pci_queue_elem_info *elem_info;\n\tchar *elem;\n\tbool owner_bit;\n\n\telem_info = mlxsw_pci_queue_elem_info_consumer_get(q);\n\telem = elem_info->elem;\n\towner_bit = mlxsw_pci_cqe_owner_get(q->u.cq.v, elem);\n\tif (mlxsw_pci_elem_hw_owned(q, owner_bit))\n\t\treturn NULL;\n\tq->consumer_counter++;\n\trmb();  \n\treturn elem;\n}\n\nstatic void mlxsw_pci_cq_tasklet(struct tasklet_struct *t)\n{\n\tstruct mlxsw_pci_queue *q = from_tasklet(q, t, tasklet);\n\tstruct mlxsw_pci *mlxsw_pci = q->pci;\n\tchar *cqe;\n\tint items = 0;\n\tint credits = q->count >> 1;\n\n\twhile ((cqe = mlxsw_pci_cq_sw_cqe_get(q))) {\n\t\tu16 wqe_counter = mlxsw_pci_cqe_wqe_counter_get(cqe);\n\t\tu8 sendq = mlxsw_pci_cqe_sr_get(q->u.cq.v, cqe);\n\t\tu8 dqn = mlxsw_pci_cqe_dqn_get(q->u.cq.v, cqe);\n\t\tchar ncqe[MLXSW_PCI_CQE_SIZE_MAX];\n\n\t\tmemcpy(ncqe, cqe, q->elem_size);\n\t\tmlxsw_pci_queue_doorbell_consumer_ring(mlxsw_pci, q);\n\n\t\tif (sendq) {\n\t\t\tstruct mlxsw_pci_queue *sdq;\n\n\t\t\tsdq = mlxsw_pci_sdq_get(mlxsw_pci, dqn);\n\t\t\tmlxsw_pci_cqe_sdq_handle(mlxsw_pci, sdq,\n\t\t\t\t\t\t wqe_counter, q->u.cq.v, ncqe);\n\t\t\tq->u.cq.comp_sdq_count++;\n\t\t} else {\n\t\t\tstruct mlxsw_pci_queue *rdq;\n\n\t\t\trdq = mlxsw_pci_rdq_get(mlxsw_pci, dqn);\n\t\t\tmlxsw_pci_cqe_rdq_handle(mlxsw_pci, rdq,\n\t\t\t\t\t\t wqe_counter, q->u.cq.v, ncqe);\n\t\t\tq->u.cq.comp_rdq_count++;\n\t\t}\n\t\tif (++items == credits)\n\t\t\tbreak;\n\t}\n\tif (items)\n\t\tmlxsw_pci_queue_doorbell_arm_consumer_ring(mlxsw_pci, q);\n}\n\nstatic u16 mlxsw_pci_cq_elem_count(const struct mlxsw_pci_queue *q)\n{\n\treturn q->u.cq.v == MLXSW_PCI_CQE_V2 ? MLXSW_PCI_CQE2_COUNT :\n\t\t\t\t\t       MLXSW_PCI_CQE01_COUNT;\n}\n\nstatic u8 mlxsw_pci_cq_elem_size(const struct mlxsw_pci_queue *q)\n{\n\treturn q->u.cq.v == MLXSW_PCI_CQE_V2 ? MLXSW_PCI_CQE2_SIZE :\n\t\t\t\t\t       MLXSW_PCI_CQE01_SIZE;\n}\n\nstatic int mlxsw_pci_eq_init(struct mlxsw_pci *mlxsw_pci, char *mbox,\n\t\t\t     struct mlxsw_pci_queue *q)\n{\n\tint i;\n\tint err;\n\n\tq->consumer_counter = 0;\n\n\tfor (i = 0; i < q->count; i++) {\n\t\tchar *elem = mlxsw_pci_queue_elem_get(q, i);\n\n\t\tmlxsw_pci_eqe_owner_set(elem, 1);\n\t}\n\n\tmlxsw_cmd_mbox_sw2hw_eq_int_msix_set(mbox, 1);  \n\tmlxsw_cmd_mbox_sw2hw_eq_st_set(mbox, 1);  \n\tmlxsw_cmd_mbox_sw2hw_eq_log_eq_size_set(mbox, ilog2(q->count));\n\tfor (i = 0; i < MLXSW_PCI_AQ_PAGES; i++) {\n\t\tdma_addr_t mapaddr = __mlxsw_pci_queue_page_get(q, i);\n\n\t\tmlxsw_cmd_mbox_sw2hw_eq_pa_set(mbox, i, mapaddr);\n\t}\n\terr = mlxsw_cmd_sw2hw_eq(mlxsw_pci->core, mbox, q->num);\n\tif (err)\n\t\treturn err;\n\tmlxsw_pci_queue_doorbell_consumer_ring(mlxsw_pci, q);\n\tmlxsw_pci_queue_doorbell_arm_consumer_ring(mlxsw_pci, q);\n\treturn 0;\n}\n\nstatic void mlxsw_pci_eq_fini(struct mlxsw_pci *mlxsw_pci,\n\t\t\t      struct mlxsw_pci_queue *q)\n{\n\tmlxsw_cmd_hw2sw_eq(mlxsw_pci->core, q->num);\n}\n\nstatic void mlxsw_pci_eq_cmd_event(struct mlxsw_pci *mlxsw_pci, char *eqe)\n{\n\tmlxsw_pci->cmd.comp.status = mlxsw_pci_eqe_cmd_status_get(eqe);\n\tmlxsw_pci->cmd.comp.out_param =\n\t\t((u64) mlxsw_pci_eqe_cmd_out_param_h_get(eqe)) << 32 |\n\t\tmlxsw_pci_eqe_cmd_out_param_l_get(eqe);\n\tmlxsw_pci->cmd.wait_done = true;\n\twake_up(&mlxsw_pci->cmd.wait);\n}\n\nstatic char *mlxsw_pci_eq_sw_eqe_get(struct mlxsw_pci_queue *q)\n{\n\tstruct mlxsw_pci_queue_elem_info *elem_info;\n\tchar *elem;\n\tbool owner_bit;\n\n\telem_info = mlxsw_pci_queue_elem_info_consumer_get(q);\n\telem = elem_info->elem;\n\towner_bit = mlxsw_pci_eqe_owner_get(elem);\n\tif (mlxsw_pci_elem_hw_owned(q, owner_bit))\n\t\treturn NULL;\n\tq->consumer_counter++;\n\trmb();  \n\treturn elem;\n}\n\nstatic void mlxsw_pci_eq_tasklet(struct tasklet_struct *t)\n{\n\tstruct mlxsw_pci_queue *q = from_tasklet(q, t, tasklet);\n\tstruct mlxsw_pci *mlxsw_pci = q->pci;\n\tu8 cq_count = mlxsw_pci_cq_count(mlxsw_pci);\n\tunsigned long active_cqns[BITS_TO_LONGS(MLXSW_PCI_CQS_MAX)];\n\tchar *eqe;\n\tu8 cqn;\n\tbool cq_handle = false;\n\tint items = 0;\n\tint credits = q->count >> 1;\n\n\tmemset(&active_cqns, 0, sizeof(active_cqns));\n\n\twhile ((eqe = mlxsw_pci_eq_sw_eqe_get(q))) {\n\n\t\t \n\t\tswitch (q->num) {\n\t\tcase MLXSW_PCI_EQ_ASYNC_NUM:\n\t\t\tmlxsw_pci_eq_cmd_event(mlxsw_pci, eqe);\n\t\t\tq->u.eq.ev_cmd_count++;\n\t\t\tbreak;\n\t\tcase MLXSW_PCI_EQ_COMP_NUM:\n\t\t\tcqn = mlxsw_pci_eqe_cqn_get(eqe);\n\t\t\tset_bit(cqn, active_cqns);\n\t\t\tcq_handle = true;\n\t\t\tq->u.eq.ev_comp_count++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tq->u.eq.ev_other_count++;\n\t\t}\n\t\tif (++items == credits)\n\t\t\tbreak;\n\t}\n\tif (items) {\n\t\tmlxsw_pci_queue_doorbell_consumer_ring(mlxsw_pci, q);\n\t\tmlxsw_pci_queue_doorbell_arm_consumer_ring(mlxsw_pci, q);\n\t}\n\n\tif (!cq_handle)\n\t\treturn;\n\tfor_each_set_bit(cqn, active_cqns, cq_count) {\n\t\tq = mlxsw_pci_cq_get(mlxsw_pci, cqn);\n\t\tmlxsw_pci_queue_tasklet_schedule(q);\n\t}\n}\n\nstruct mlxsw_pci_queue_ops {\n\tconst char *name;\n\tenum mlxsw_pci_queue_type type;\n\tvoid (*pre_init)(struct mlxsw_pci *mlxsw_pci,\n\t\t\t struct mlxsw_pci_queue *q);\n\tint (*init)(struct mlxsw_pci *mlxsw_pci, char *mbox,\n\t\t    struct mlxsw_pci_queue *q);\n\tvoid (*fini)(struct mlxsw_pci *mlxsw_pci,\n\t\t     struct mlxsw_pci_queue *q);\n\tvoid (*tasklet)(struct tasklet_struct *t);\n\tu16 (*elem_count_f)(const struct mlxsw_pci_queue *q);\n\tu8 (*elem_size_f)(const struct mlxsw_pci_queue *q);\n\tu16 elem_count;\n\tu8 elem_size;\n};\n\nstatic const struct mlxsw_pci_queue_ops mlxsw_pci_sdq_ops = {\n\t.type\t\t= MLXSW_PCI_QUEUE_TYPE_SDQ,\n\t.init\t\t= mlxsw_pci_sdq_init,\n\t.fini\t\t= mlxsw_pci_sdq_fini,\n\t.elem_count\t= MLXSW_PCI_WQE_COUNT,\n\t.elem_size\t= MLXSW_PCI_WQE_SIZE,\n};\n\nstatic const struct mlxsw_pci_queue_ops mlxsw_pci_rdq_ops = {\n\t.type\t\t= MLXSW_PCI_QUEUE_TYPE_RDQ,\n\t.init\t\t= mlxsw_pci_rdq_init,\n\t.fini\t\t= mlxsw_pci_rdq_fini,\n\t.elem_count\t= MLXSW_PCI_WQE_COUNT,\n\t.elem_size\t= MLXSW_PCI_WQE_SIZE\n};\n\nstatic const struct mlxsw_pci_queue_ops mlxsw_pci_cq_ops = {\n\t.type\t\t= MLXSW_PCI_QUEUE_TYPE_CQ,\n\t.pre_init\t= mlxsw_pci_cq_pre_init,\n\t.init\t\t= mlxsw_pci_cq_init,\n\t.fini\t\t= mlxsw_pci_cq_fini,\n\t.tasklet\t= mlxsw_pci_cq_tasklet,\n\t.elem_count_f\t= mlxsw_pci_cq_elem_count,\n\t.elem_size_f\t= mlxsw_pci_cq_elem_size\n};\n\nstatic const struct mlxsw_pci_queue_ops mlxsw_pci_eq_ops = {\n\t.type\t\t= MLXSW_PCI_QUEUE_TYPE_EQ,\n\t.init\t\t= mlxsw_pci_eq_init,\n\t.fini\t\t= mlxsw_pci_eq_fini,\n\t.tasklet\t= mlxsw_pci_eq_tasklet,\n\t.elem_count\t= MLXSW_PCI_EQE_COUNT,\n\t.elem_size\t= MLXSW_PCI_EQE_SIZE\n};\n\nstatic int mlxsw_pci_queue_init(struct mlxsw_pci *mlxsw_pci, char *mbox,\n\t\t\t\tconst struct mlxsw_pci_queue_ops *q_ops,\n\t\t\t\tstruct mlxsw_pci_queue *q, u8 q_num)\n{\n\tstruct mlxsw_pci_mem_item *mem_item = &q->mem_item;\n\tint i;\n\tint err;\n\n\tq->num = q_num;\n\tif (q_ops->pre_init)\n\t\tq_ops->pre_init(mlxsw_pci, q);\n\n\tspin_lock_init(&q->lock);\n\tq->count = q_ops->elem_count_f ? q_ops->elem_count_f(q) :\n\t\t\t\t\t q_ops->elem_count;\n\tq->elem_size = q_ops->elem_size_f ? q_ops->elem_size_f(q) :\n\t\t\t\t\t    q_ops->elem_size;\n\tq->type = q_ops->type;\n\tq->pci = mlxsw_pci;\n\n\tif (q_ops->tasklet)\n\t\ttasklet_setup(&q->tasklet, q_ops->tasklet);\n\n\tmem_item->size = MLXSW_PCI_AQ_SIZE;\n\tmem_item->buf = dma_alloc_coherent(&mlxsw_pci->pdev->dev,\n\t\t\t\t\t   mem_item->size, &mem_item->mapaddr,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!mem_item->buf)\n\t\treturn -ENOMEM;\n\n\tq->elem_info = kcalloc(q->count, sizeof(*q->elem_info), GFP_KERNEL);\n\tif (!q->elem_info) {\n\t\terr = -ENOMEM;\n\t\tgoto err_elem_info_alloc;\n\t}\n\n\t \n\tfor (i = 0; i < q->count; i++) {\n\t\tstruct mlxsw_pci_queue_elem_info *elem_info;\n\n\t\telem_info = mlxsw_pci_queue_elem_info_get(q, i);\n\t\telem_info->elem =\n\t\t\t__mlxsw_pci_queue_elem_get(q, q->elem_size, i);\n\t}\n\n\tmlxsw_cmd_mbox_zero(mbox);\n\terr = q_ops->init(mlxsw_pci, mbox, q);\n\tif (err)\n\t\tgoto err_q_ops_init;\n\treturn 0;\n\nerr_q_ops_init:\n\tkfree(q->elem_info);\nerr_elem_info_alloc:\n\tdma_free_coherent(&mlxsw_pci->pdev->dev, mem_item->size,\n\t\t\t  mem_item->buf, mem_item->mapaddr);\n\treturn err;\n}\n\nstatic void mlxsw_pci_queue_fini(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t const struct mlxsw_pci_queue_ops *q_ops,\n\t\t\t\t struct mlxsw_pci_queue *q)\n{\n\tstruct mlxsw_pci_mem_item *mem_item = &q->mem_item;\n\n\tq_ops->fini(mlxsw_pci, q);\n\tkfree(q->elem_info);\n\tdma_free_coherent(&mlxsw_pci->pdev->dev, mem_item->size,\n\t\t\t  mem_item->buf, mem_item->mapaddr);\n}\n\nstatic int mlxsw_pci_queue_group_init(struct mlxsw_pci *mlxsw_pci, char *mbox,\n\t\t\t\t      const struct mlxsw_pci_queue_ops *q_ops,\n\t\t\t\t      u8 num_qs)\n{\n\tstruct mlxsw_pci_queue_type_group *queue_group;\n\tint i;\n\tint err;\n\n\tqueue_group = mlxsw_pci_queue_type_group_get(mlxsw_pci, q_ops->type);\n\tqueue_group->q = kcalloc(num_qs, sizeof(*queue_group->q), GFP_KERNEL);\n\tif (!queue_group->q)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_qs; i++) {\n\t\terr = mlxsw_pci_queue_init(mlxsw_pci, mbox, q_ops,\n\t\t\t\t\t   &queue_group->q[i], i);\n\t\tif (err)\n\t\t\tgoto err_queue_init;\n\t}\n\tqueue_group->count = num_qs;\n\n\treturn 0;\n\nerr_queue_init:\n\tfor (i--; i >= 0; i--)\n\t\tmlxsw_pci_queue_fini(mlxsw_pci, q_ops, &queue_group->q[i]);\n\tkfree(queue_group->q);\n\treturn err;\n}\n\nstatic void mlxsw_pci_queue_group_fini(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t       const struct mlxsw_pci_queue_ops *q_ops)\n{\n\tstruct mlxsw_pci_queue_type_group *queue_group;\n\tint i;\n\n\tqueue_group = mlxsw_pci_queue_type_group_get(mlxsw_pci, q_ops->type);\n\tfor (i = 0; i < queue_group->count; i++)\n\t\tmlxsw_pci_queue_fini(mlxsw_pci, q_ops, &queue_group->q[i]);\n\tkfree(queue_group->q);\n}\n\nstatic int mlxsw_pci_aqs_init(struct mlxsw_pci *mlxsw_pci, char *mbox)\n{\n\tstruct pci_dev *pdev = mlxsw_pci->pdev;\n\tu8 num_sdqs;\n\tu8 sdq_log2sz;\n\tu8 num_rdqs;\n\tu8 rdq_log2sz;\n\tu8 num_cqs;\n\tu8 cq_log2sz;\n\tu8 cqv2_log2sz;\n\tu8 num_eqs;\n\tu8 eq_log2sz;\n\tint err;\n\n\tmlxsw_cmd_mbox_zero(mbox);\n\terr = mlxsw_cmd_query_aq_cap(mlxsw_pci->core, mbox);\n\tif (err)\n\t\treturn err;\n\n\tnum_sdqs = mlxsw_cmd_mbox_query_aq_cap_max_num_sdqs_get(mbox);\n\tsdq_log2sz = mlxsw_cmd_mbox_query_aq_cap_log_max_sdq_sz_get(mbox);\n\tnum_rdqs = mlxsw_cmd_mbox_query_aq_cap_max_num_rdqs_get(mbox);\n\trdq_log2sz = mlxsw_cmd_mbox_query_aq_cap_log_max_rdq_sz_get(mbox);\n\tnum_cqs = mlxsw_cmd_mbox_query_aq_cap_max_num_cqs_get(mbox);\n\tcq_log2sz = mlxsw_cmd_mbox_query_aq_cap_log_max_cq_sz_get(mbox);\n\tcqv2_log2sz = mlxsw_cmd_mbox_query_aq_cap_log_max_cqv2_sz_get(mbox);\n\tnum_eqs = mlxsw_cmd_mbox_query_aq_cap_max_num_eqs_get(mbox);\n\teq_log2sz = mlxsw_cmd_mbox_query_aq_cap_log_max_eq_sz_get(mbox);\n\n\tif (num_sdqs + num_rdqs > num_cqs ||\n\t    num_sdqs < MLXSW_PCI_SDQS_MIN ||\n\t    num_cqs > MLXSW_PCI_CQS_MAX || num_eqs != MLXSW_PCI_EQS_COUNT) {\n\t\tdev_err(&pdev->dev, \"Unsupported number of queues\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((1 << sdq_log2sz != MLXSW_PCI_WQE_COUNT) ||\n\t    (1 << rdq_log2sz != MLXSW_PCI_WQE_COUNT) ||\n\t    (1 << cq_log2sz != MLXSW_PCI_CQE01_COUNT) ||\n\t    (mlxsw_pci->max_cqe_ver == MLXSW_PCI_CQE_V2 &&\n\t     (1 << cqv2_log2sz != MLXSW_PCI_CQE2_COUNT)) ||\n\t    (1 << eq_log2sz != MLXSW_PCI_EQE_COUNT)) {\n\t\tdev_err(&pdev->dev, \"Unsupported number of async queue descriptors\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmlxsw_pci->num_sdq_cqs = num_sdqs;\n\n\terr = mlxsw_pci_queue_group_init(mlxsw_pci, mbox, &mlxsw_pci_eq_ops,\n\t\t\t\t\t num_eqs);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize event queues\\n\");\n\t\treturn err;\n\t}\n\n\terr = mlxsw_pci_queue_group_init(mlxsw_pci, mbox, &mlxsw_pci_cq_ops,\n\t\t\t\t\t num_cqs);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize completion queues\\n\");\n\t\tgoto err_cqs_init;\n\t}\n\n\terr = mlxsw_pci_queue_group_init(mlxsw_pci, mbox, &mlxsw_pci_sdq_ops,\n\t\t\t\t\t num_sdqs);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize send descriptor queues\\n\");\n\t\tgoto err_sdqs_init;\n\t}\n\n\terr = mlxsw_pci_queue_group_init(mlxsw_pci, mbox, &mlxsw_pci_rdq_ops,\n\t\t\t\t\t num_rdqs);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to initialize receive descriptor queues\\n\");\n\t\tgoto err_rdqs_init;\n\t}\n\n\t \n\tmlxsw_pci->cmd.nopoll = true;\n\treturn 0;\n\nerr_rdqs_init:\n\tmlxsw_pci_queue_group_fini(mlxsw_pci, &mlxsw_pci_sdq_ops);\nerr_sdqs_init:\n\tmlxsw_pci_queue_group_fini(mlxsw_pci, &mlxsw_pci_cq_ops);\nerr_cqs_init:\n\tmlxsw_pci_queue_group_fini(mlxsw_pci, &mlxsw_pci_eq_ops);\n\treturn err;\n}\n\nstatic void mlxsw_pci_aqs_fini(struct mlxsw_pci *mlxsw_pci)\n{\n\tmlxsw_pci->cmd.nopoll = false;\n\tmlxsw_pci_queue_group_fini(mlxsw_pci, &mlxsw_pci_rdq_ops);\n\tmlxsw_pci_queue_group_fini(mlxsw_pci, &mlxsw_pci_sdq_ops);\n\tmlxsw_pci_queue_group_fini(mlxsw_pci, &mlxsw_pci_cq_ops);\n\tmlxsw_pci_queue_group_fini(mlxsw_pci, &mlxsw_pci_eq_ops);\n}\n\nstatic void\nmlxsw_pci_config_profile_swid_config(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t     char *mbox, int index,\n\t\t\t\t     const struct mlxsw_swid_config *swid)\n{\n\tu8 mask = 0;\n\n\tif (swid->used_type) {\n\t\tmlxsw_cmd_mbox_config_profile_swid_config_type_set(\n\t\t\tmbox, index, swid->type);\n\t\tmask |= 1;\n\t}\n\tif (swid->used_properties) {\n\t\tmlxsw_cmd_mbox_config_profile_swid_config_properties_set(\n\t\t\tmbox, index, swid->properties);\n\t\tmask |= 2;\n\t}\n\tmlxsw_cmd_mbox_config_profile_swid_config_mask_set(mbox, index, mask);\n}\n\nstatic int\nmlxsw_pci_profile_get_kvd_sizes(const struct mlxsw_pci *mlxsw_pci,\n\t\t\t\tconst struct mlxsw_config_profile *profile,\n\t\t\t\tstruct mlxsw_res *res)\n{\n\tu64 single_size, double_size, linear_size;\n\tint err;\n\n\terr = mlxsw_core_kvd_sizes_get(mlxsw_pci->core, profile,\n\t\t\t\t       &single_size, &double_size,\n\t\t\t\t       &linear_size);\n\tif (err)\n\t\treturn err;\n\n\tMLXSW_RES_SET(res, KVD_SINGLE_SIZE, single_size);\n\tMLXSW_RES_SET(res, KVD_DOUBLE_SIZE, double_size);\n\tMLXSW_RES_SET(res, KVD_LINEAR_SIZE, linear_size);\n\n\treturn 0;\n}\n\nstatic int mlxsw_pci_config_profile(struct mlxsw_pci *mlxsw_pci, char *mbox,\n\t\t\t\t    const struct mlxsw_config_profile *profile,\n\t\t\t\t    struct mlxsw_res *res)\n{\n\tint i;\n\tint err;\n\n\tmlxsw_cmd_mbox_zero(mbox);\n\n\tif (profile->used_max_vepa_channels) {\n\t\tmlxsw_cmd_mbox_config_profile_set_max_vepa_channels_set(\n\t\t\tmbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_max_vepa_channels_set(\n\t\t\tmbox, profile->max_vepa_channels);\n\t}\n\tif (profile->used_max_lag) {\n\t\tmlxsw_cmd_mbox_config_profile_set_max_lag_set(mbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_max_lag_set(mbox,\n\t\t\t\t\t\t\t  profile->max_lag);\n\t}\n\tif (profile->used_max_mid) {\n\t\tmlxsw_cmd_mbox_config_profile_set_max_mid_set(\n\t\t\tmbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_max_mid_set(\n\t\t\tmbox, profile->max_mid);\n\t}\n\tif (profile->used_max_pgt) {\n\t\tmlxsw_cmd_mbox_config_profile_set_max_pgt_set(\n\t\t\tmbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_max_pgt_set(\n\t\t\tmbox, profile->max_pgt);\n\t}\n\tif (profile->used_max_system_port) {\n\t\tmlxsw_cmd_mbox_config_profile_set_max_system_port_set(\n\t\t\tmbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_max_system_port_set(\n\t\t\tmbox, profile->max_system_port);\n\t}\n\tif (profile->used_max_vlan_groups) {\n\t\tmlxsw_cmd_mbox_config_profile_set_max_vlan_groups_set(\n\t\t\tmbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_max_vlan_groups_set(\n\t\t\tmbox, profile->max_vlan_groups);\n\t}\n\tif (profile->used_max_regions) {\n\t\tmlxsw_cmd_mbox_config_profile_set_max_regions_set(\n\t\t\tmbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_max_regions_set(\n\t\t\tmbox, profile->max_regions);\n\t}\n\tif (profile->used_flood_tables) {\n\t\tmlxsw_cmd_mbox_config_profile_set_flood_tables_set(\n\t\t\tmbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_max_flood_tables_set(\n\t\t\tmbox, profile->max_flood_tables);\n\t\tmlxsw_cmd_mbox_config_profile_max_vid_flood_tables_set(\n\t\t\tmbox, profile->max_vid_flood_tables);\n\t\tmlxsw_cmd_mbox_config_profile_max_fid_offset_flood_tables_set(\n\t\t\tmbox, profile->max_fid_offset_flood_tables);\n\t\tmlxsw_cmd_mbox_config_profile_fid_offset_flood_table_size_set(\n\t\t\tmbox, profile->fid_offset_flood_table_size);\n\t\tmlxsw_cmd_mbox_config_profile_max_fid_flood_tables_set(\n\t\t\tmbox, profile->max_fid_flood_tables);\n\t\tmlxsw_cmd_mbox_config_profile_fid_flood_table_size_set(\n\t\t\tmbox, profile->fid_flood_table_size);\n\t}\n\tif (profile->used_flood_mode) {\n\t\tmlxsw_cmd_mbox_config_profile_set_flood_mode_set(\n\t\t\tmbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_flood_mode_set(\n\t\t\tmbox, profile->flood_mode);\n\t}\n\tif (profile->used_max_ib_mc) {\n\t\tmlxsw_cmd_mbox_config_profile_set_max_ib_mc_set(\n\t\t\tmbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_max_ib_mc_set(\n\t\t\tmbox, profile->max_ib_mc);\n\t}\n\tif (profile->used_max_pkey) {\n\t\tmlxsw_cmd_mbox_config_profile_set_max_pkey_set(\n\t\t\tmbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_max_pkey_set(\n\t\t\tmbox, profile->max_pkey);\n\t}\n\tif (profile->used_ar_sec) {\n\t\tmlxsw_cmd_mbox_config_profile_set_ar_sec_set(\n\t\t\tmbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_ar_sec_set(\n\t\t\tmbox, profile->ar_sec);\n\t}\n\tif (profile->used_adaptive_routing_group_cap) {\n\t\tmlxsw_cmd_mbox_config_profile_set_adaptive_routing_group_cap_set(\n\t\t\tmbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_adaptive_routing_group_cap_set(\n\t\t\tmbox, profile->adaptive_routing_group_cap);\n\t}\n\tif (profile->used_ubridge) {\n\t\tmlxsw_cmd_mbox_config_profile_set_ubridge_set(mbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_ubridge_set(mbox,\n\t\t\t\t\t\t\t  profile->ubridge);\n\t}\n\tif (profile->used_kvd_sizes && MLXSW_RES_VALID(res, KVD_SIZE)) {\n\t\terr = mlxsw_pci_profile_get_kvd_sizes(mlxsw_pci, profile, res);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmlxsw_cmd_mbox_config_profile_set_kvd_linear_size_set(mbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_kvd_linear_size_set(mbox,\n\t\t\t\t\tMLXSW_RES_GET(res, KVD_LINEAR_SIZE));\n\t\tmlxsw_cmd_mbox_config_profile_set_kvd_hash_single_size_set(mbox,\n\t\t\t\t\t\t\t\t\t   1);\n\t\tmlxsw_cmd_mbox_config_profile_kvd_hash_single_size_set(mbox,\n\t\t\t\t\tMLXSW_RES_GET(res, KVD_SINGLE_SIZE));\n\t\tmlxsw_cmd_mbox_config_profile_set_kvd_hash_double_size_set(\n\t\t\t\t\t\t\t\tmbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_kvd_hash_double_size_set(mbox,\n\t\t\t\t\tMLXSW_RES_GET(res, KVD_DOUBLE_SIZE));\n\t}\n\n\tfor (i = 0; i < MLXSW_CONFIG_PROFILE_SWID_COUNT; i++)\n\t\tmlxsw_pci_config_profile_swid_config(mlxsw_pci, mbox, i,\n\t\t\t\t\t\t     &profile->swid_config[i]);\n\n\tif (mlxsw_pci->max_cqe_ver > MLXSW_PCI_CQE_V0) {\n\t\tmlxsw_cmd_mbox_config_profile_set_cqe_version_set(mbox, 1);\n\t\tmlxsw_cmd_mbox_config_profile_cqe_version_set(mbox, 1);\n\t}\n\n\tif (profile->used_cqe_time_stamp_type) {\n\t\tmlxsw_cmd_mbox_config_profile_set_cqe_time_stamp_type_set(mbox,\n\t\t\t\t\t\t\t\t\t  1);\n\t\tmlxsw_cmd_mbox_config_profile_cqe_time_stamp_type_set(mbox,\n\t\t\t\t\tprofile->cqe_time_stamp_type);\n\t}\n\n\treturn mlxsw_cmd_config_profile_set(mlxsw_pci->core, mbox);\n}\n\nstatic int mlxsw_pci_boardinfo(struct mlxsw_pci *mlxsw_pci, char *mbox)\n{\n\tstruct mlxsw_bus_info *bus_info = &mlxsw_pci->bus_info;\n\tint err;\n\n\tmlxsw_cmd_mbox_zero(mbox);\n\terr = mlxsw_cmd_boardinfo(mlxsw_pci->core, mbox);\n\tif (err)\n\t\treturn err;\n\tmlxsw_cmd_mbox_boardinfo_vsd_memcpy_from(mbox, bus_info->vsd);\n\tmlxsw_cmd_mbox_boardinfo_psid_memcpy_from(mbox, bus_info->psid);\n\treturn 0;\n}\n\nstatic int mlxsw_pci_fw_area_init(struct mlxsw_pci *mlxsw_pci, char *mbox,\n\t\t\t\t  u16 num_pages)\n{\n\tstruct mlxsw_pci_mem_item *mem_item;\n\tint nent = 0;\n\tint i;\n\tint err;\n\n\tmlxsw_pci->fw_area.items = kcalloc(num_pages, sizeof(*mem_item),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!mlxsw_pci->fw_area.items)\n\t\treturn -ENOMEM;\n\tmlxsw_pci->fw_area.count = num_pages;\n\n\tmlxsw_cmd_mbox_zero(mbox);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tmem_item = &mlxsw_pci->fw_area.items[i];\n\n\t\tmem_item->size = MLXSW_PCI_PAGE_SIZE;\n\t\tmem_item->buf = dma_alloc_coherent(&mlxsw_pci->pdev->dev,\n\t\t\t\t\t\t   mem_item->size,\n\t\t\t\t\t\t   &mem_item->mapaddr, GFP_KERNEL);\n\t\tif (!mem_item->buf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_alloc;\n\t\t}\n\t\tmlxsw_cmd_mbox_map_fa_pa_set(mbox, nent, mem_item->mapaddr);\n\t\tmlxsw_cmd_mbox_map_fa_log2size_set(mbox, nent, 0);  \n\t\tif (++nent == MLXSW_CMD_MAP_FA_VPM_ENTRIES_MAX) {\n\t\t\terr = mlxsw_cmd_map_fa(mlxsw_pci->core, mbox, nent);\n\t\t\tif (err)\n\t\t\t\tgoto err_cmd_map_fa;\n\t\t\tnent = 0;\n\t\t\tmlxsw_cmd_mbox_zero(mbox);\n\t\t}\n\t}\n\n\tif (nent) {\n\t\terr = mlxsw_cmd_map_fa(mlxsw_pci->core, mbox, nent);\n\t\tif (err)\n\t\t\tgoto err_cmd_map_fa;\n\t}\n\n\treturn 0;\n\nerr_cmd_map_fa:\nerr_alloc:\n\tfor (i--; i >= 0; i--) {\n\t\tmem_item = &mlxsw_pci->fw_area.items[i];\n\n\t\tdma_free_coherent(&mlxsw_pci->pdev->dev, mem_item->size,\n\t\t\t\t  mem_item->buf, mem_item->mapaddr);\n\t}\n\tkfree(mlxsw_pci->fw_area.items);\n\treturn err;\n}\n\nstatic void mlxsw_pci_fw_area_fini(struct mlxsw_pci *mlxsw_pci)\n{\n\tstruct mlxsw_pci_mem_item *mem_item;\n\tint i;\n\n\tmlxsw_cmd_unmap_fa(mlxsw_pci->core);\n\n\tfor (i = 0; i < mlxsw_pci->fw_area.count; i++) {\n\t\tmem_item = &mlxsw_pci->fw_area.items[i];\n\n\t\tdma_free_coherent(&mlxsw_pci->pdev->dev, mem_item->size,\n\t\t\t\t  mem_item->buf, mem_item->mapaddr);\n\t}\n\tkfree(mlxsw_pci->fw_area.items);\n}\n\nstatic irqreturn_t mlxsw_pci_eq_irq_handler(int irq, void *dev_id)\n{\n\tstruct mlxsw_pci *mlxsw_pci = dev_id;\n\tstruct mlxsw_pci_queue *q;\n\tint i;\n\n\tfor (i = 0; i < MLXSW_PCI_EQS_COUNT; i++) {\n\t\tq = mlxsw_pci_eq_get(mlxsw_pci, i);\n\t\tmlxsw_pci_queue_tasklet_schedule(q);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int mlxsw_pci_mbox_alloc(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\tstruct mlxsw_pci_mem_item *mbox)\n{\n\tstruct pci_dev *pdev = mlxsw_pci->pdev;\n\tint err = 0;\n\n\tmbox->size = MLXSW_CMD_MBOX_SIZE;\n\tmbox->buf = dma_alloc_coherent(&pdev->dev, MLXSW_CMD_MBOX_SIZE,\n\t\t\t\t       &mbox->mapaddr, GFP_KERNEL);\n\tif (!mbox->buf) {\n\t\tdev_err(&pdev->dev, \"Failed allocating memory for mailbox\\n\");\n\t\terr = -ENOMEM;\n\t}\n\n\treturn err;\n}\n\nstatic void mlxsw_pci_mbox_free(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\tstruct mlxsw_pci_mem_item *mbox)\n{\n\tstruct pci_dev *pdev = mlxsw_pci->pdev;\n\n\tdma_free_coherent(&pdev->dev, MLXSW_CMD_MBOX_SIZE, mbox->buf,\n\t\t\t  mbox->mapaddr);\n}\n\nstatic int mlxsw_pci_sys_ready_wait(struct mlxsw_pci *mlxsw_pci,\n\t\t\t\t    const struct pci_device_id *id,\n\t\t\t\t    u32 *p_sys_status)\n{\n\tunsigned long end;\n\tu32 val;\n\n\t \n\tmsleep(MLXSW_PCI_SW_RESET_WAIT_MSECS);\n\n\tend = jiffies + msecs_to_jiffies(MLXSW_PCI_SW_RESET_TIMEOUT_MSECS);\n\tdo {\n\t\tval = mlxsw_pci_read32(mlxsw_pci, FW_READY);\n\t\tif ((val & MLXSW_PCI_FW_READY_MASK) == MLXSW_PCI_FW_READY_MAGIC)\n\t\t\treturn 0;\n\t\tcond_resched();\n\t} while (time_before(jiffies, end));\n\n\t*p_sys_status = val & MLXSW_PCI_FW_READY_MASK;\n\n\treturn -EBUSY;\n}\n\nstatic int mlxsw_pci_sw_reset(struct mlxsw_pci *mlxsw_pci,\n\t\t\t      const struct pci_device_id *id)\n{\n\tstruct pci_dev *pdev = mlxsw_pci->pdev;\n\tchar mrsr_pl[MLXSW_REG_MRSR_LEN];\n\tu32 sys_status;\n\tint err;\n\n\terr = mlxsw_pci_sys_ready_wait(mlxsw_pci, id, &sys_status);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to reach system ready status before reset. Status is 0x%x\\n\",\n\t\t\tsys_status);\n\t\treturn err;\n\t}\n\n\tmlxsw_reg_mrsr_pack(mrsr_pl);\n\terr = mlxsw_reg_write(mlxsw_pci->core, MLXSW_REG(mrsr), mrsr_pl);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_pci_sys_ready_wait(mlxsw_pci, id, &sys_status);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to reach system ready status after reset. Status is 0x%x\\n\",\n\t\t\tsys_status);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_pci_alloc_irq_vectors(struct mlxsw_pci *mlxsw_pci)\n{\n\tint err;\n\n\terr = pci_alloc_irq_vectors(mlxsw_pci->pdev, 1, 1, PCI_IRQ_MSIX);\n\tif (err < 0)\n\t\tdev_err(&mlxsw_pci->pdev->dev, \"MSI-X init failed\\n\");\n\treturn err;\n}\n\nstatic void mlxsw_pci_free_irq_vectors(struct mlxsw_pci *mlxsw_pci)\n{\n\tpci_free_irq_vectors(mlxsw_pci->pdev);\n}\n\nstatic int mlxsw_pci_init(void *bus_priv, struct mlxsw_core *mlxsw_core,\n\t\t\t  const struct mlxsw_config_profile *profile,\n\t\t\t  struct mlxsw_res *res)\n{\n\tstruct mlxsw_pci *mlxsw_pci = bus_priv;\n\tstruct pci_dev *pdev = mlxsw_pci->pdev;\n\tchar *mbox;\n\tu16 num_pages;\n\tint err;\n\n\tmlxsw_pci->core = mlxsw_core;\n\n\tmbox = mlxsw_cmd_mbox_alloc();\n\tif (!mbox)\n\t\treturn -ENOMEM;\n\n\terr = mlxsw_pci_sw_reset(mlxsw_pci, mlxsw_pci->id);\n\tif (err)\n\t\tgoto err_sw_reset;\n\n\terr = mlxsw_pci_alloc_irq_vectors(mlxsw_pci);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"MSI-X init failed\\n\");\n\t\tgoto err_alloc_irq;\n\t}\n\n\terr = mlxsw_cmd_query_fw(mlxsw_core, mbox);\n\tif (err)\n\t\tgoto err_query_fw;\n\n\tmlxsw_pci->bus_info.fw_rev.major =\n\t\tmlxsw_cmd_mbox_query_fw_fw_rev_major_get(mbox);\n\tmlxsw_pci->bus_info.fw_rev.minor =\n\t\tmlxsw_cmd_mbox_query_fw_fw_rev_minor_get(mbox);\n\tmlxsw_pci->bus_info.fw_rev.subminor =\n\t\tmlxsw_cmd_mbox_query_fw_fw_rev_subminor_get(mbox);\n\n\tif (mlxsw_cmd_mbox_query_fw_cmd_interface_rev_get(mbox) != 1) {\n\t\tdev_err(&pdev->dev, \"Unsupported cmd interface revision ID queried from hw\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_iface_rev;\n\t}\n\tif (mlxsw_cmd_mbox_query_fw_doorbell_page_bar_get(mbox) != 0) {\n\t\tdev_err(&pdev->dev, \"Unsupported doorbell page bar queried from hw\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_doorbell_page_bar;\n\t}\n\n\tmlxsw_pci->doorbell_offset =\n\t\tmlxsw_cmd_mbox_query_fw_doorbell_page_offset_get(mbox);\n\n\tif (mlxsw_cmd_mbox_query_fw_fr_rn_clk_bar_get(mbox) != 0) {\n\t\tdev_err(&pdev->dev, \"Unsupported free running clock BAR queried from hw\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_fr_rn_clk_bar;\n\t}\n\n\tmlxsw_pci->free_running_clock_offset =\n\t\tmlxsw_cmd_mbox_query_fw_free_running_clock_offset_get(mbox);\n\n\tif (mlxsw_cmd_mbox_query_fw_utc_sec_bar_get(mbox) != 0) {\n\t\tdev_err(&pdev->dev, \"Unsupported UTC sec BAR queried from hw\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_utc_sec_bar;\n\t}\n\n\tmlxsw_pci->utc_sec_offset =\n\t\tmlxsw_cmd_mbox_query_fw_utc_sec_offset_get(mbox);\n\n\tif (mlxsw_cmd_mbox_query_fw_utc_nsec_bar_get(mbox) != 0) {\n\t\tdev_err(&pdev->dev, \"Unsupported UTC nsec BAR queried from hw\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_utc_nsec_bar;\n\t}\n\n\tmlxsw_pci->utc_nsec_offset =\n\t\tmlxsw_cmd_mbox_query_fw_utc_nsec_offset_get(mbox);\n\n\tnum_pages = mlxsw_cmd_mbox_query_fw_fw_pages_get(mbox);\n\terr = mlxsw_pci_fw_area_init(mlxsw_pci, mbox, num_pages);\n\tif (err)\n\t\tgoto err_fw_area_init;\n\n\terr = mlxsw_pci_boardinfo(mlxsw_pci, mbox);\n\tif (err)\n\t\tgoto err_boardinfo;\n\n\terr = mlxsw_core_resources_query(mlxsw_core, mbox, res);\n\tif (err)\n\t\tgoto err_query_resources;\n\n\tif (MLXSW_CORE_RES_VALID(mlxsw_core, CQE_V2) &&\n\t    MLXSW_CORE_RES_GET(mlxsw_core, CQE_V2))\n\t\tmlxsw_pci->max_cqe_ver = MLXSW_PCI_CQE_V2;\n\telse if (MLXSW_CORE_RES_VALID(mlxsw_core, CQE_V1) &&\n\t\t MLXSW_CORE_RES_GET(mlxsw_core, CQE_V1))\n\t\tmlxsw_pci->max_cqe_ver = MLXSW_PCI_CQE_V1;\n\telse if ((MLXSW_CORE_RES_VALID(mlxsw_core, CQE_V0) &&\n\t\t  MLXSW_CORE_RES_GET(mlxsw_core, CQE_V0)) ||\n\t\t !MLXSW_CORE_RES_VALID(mlxsw_core, CQE_V0)) {\n\t\tmlxsw_pci->max_cqe_ver = MLXSW_PCI_CQE_V0;\n\t} else {\n\t\tdev_err(&pdev->dev, \"Invalid supported CQE version combination reported\\n\");\n\t\tgoto err_cqe_v_check;\n\t}\n\n\terr = mlxsw_pci_config_profile(mlxsw_pci, mbox, profile, res);\n\tif (err)\n\t\tgoto err_config_profile;\n\n\t \n\terr = mlxsw_core_resources_query(mlxsw_core, mbox, res);\n\tif (err)\n\t\tgoto err_requery_resources;\n\n\terr = mlxsw_pci_aqs_init(mlxsw_pci, mbox);\n\tif (err)\n\t\tgoto err_aqs_init;\n\n\terr = request_irq(pci_irq_vector(pdev, 0),\n\t\t\t  mlxsw_pci_eq_irq_handler, 0,\n\t\t\t  mlxsw_pci->bus_info.device_kind, mlxsw_pci);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"IRQ request failed\\n\");\n\t\tgoto err_request_eq_irq;\n\t}\n\n\tgoto mbox_put;\n\nerr_request_eq_irq:\n\tmlxsw_pci_aqs_fini(mlxsw_pci);\nerr_aqs_init:\nerr_requery_resources:\nerr_config_profile:\nerr_cqe_v_check:\nerr_query_resources:\nerr_boardinfo:\n\tmlxsw_pci_fw_area_fini(mlxsw_pci);\nerr_fw_area_init:\nerr_utc_nsec_bar:\nerr_utc_sec_bar:\nerr_fr_rn_clk_bar:\nerr_doorbell_page_bar:\nerr_iface_rev:\nerr_query_fw:\n\tmlxsw_pci_free_irq_vectors(mlxsw_pci);\nerr_alloc_irq:\nerr_sw_reset:\nmbox_put:\n\tmlxsw_cmd_mbox_free(mbox);\n\treturn err;\n}\n\nstatic void mlxsw_pci_fini(void *bus_priv)\n{\n\tstruct mlxsw_pci *mlxsw_pci = bus_priv;\n\n\tfree_irq(pci_irq_vector(mlxsw_pci->pdev, 0), mlxsw_pci);\n\tmlxsw_pci_aqs_fini(mlxsw_pci);\n\tmlxsw_pci_fw_area_fini(mlxsw_pci);\n\tmlxsw_pci_free_irq_vectors(mlxsw_pci);\n}\n\nstatic struct mlxsw_pci_queue *\nmlxsw_pci_sdq_pick(struct mlxsw_pci *mlxsw_pci,\n\t\t   const struct mlxsw_tx_info *tx_info)\n{\n\tu8 ctl_sdq_count = mlxsw_pci_sdq_count(mlxsw_pci) - 1;\n\tu8 sdqn;\n\n\tif (tx_info->is_emad) {\n\t\tsdqn = MLXSW_PCI_SDQ_EMAD_INDEX;\n\t} else {\n\t\tBUILD_BUG_ON(MLXSW_PCI_SDQ_EMAD_INDEX != 0);\n\t\tsdqn = 1 + (tx_info->local_port % ctl_sdq_count);\n\t}\n\n\treturn mlxsw_pci_sdq_get(mlxsw_pci, sdqn);\n}\n\nstatic bool mlxsw_pci_skb_transmit_busy(void *bus_priv,\n\t\t\t\t\tconst struct mlxsw_tx_info *tx_info)\n{\n\tstruct mlxsw_pci *mlxsw_pci = bus_priv;\n\tstruct mlxsw_pci_queue *q = mlxsw_pci_sdq_pick(mlxsw_pci, tx_info);\n\n\treturn !mlxsw_pci_queue_elem_info_producer_get(q);\n}\n\nstatic int mlxsw_pci_skb_transmit(void *bus_priv, struct sk_buff *skb,\n\t\t\t\t  const struct mlxsw_tx_info *tx_info)\n{\n\tstruct mlxsw_pci *mlxsw_pci = bus_priv;\n\tstruct mlxsw_pci_queue *q;\n\tstruct mlxsw_pci_queue_elem_info *elem_info;\n\tchar *wqe;\n\tint i;\n\tint err;\n\n\tif (skb_shinfo(skb)->nr_frags > MLXSW_PCI_WQE_SG_ENTRIES - 1) {\n\t\terr = skb_linearize(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tq = mlxsw_pci_sdq_pick(mlxsw_pci, tx_info);\n\tspin_lock_bh(&q->lock);\n\telem_info = mlxsw_pci_queue_elem_info_producer_get(q);\n\tif (!elem_info) {\n\t\t \n\t\terr = -EAGAIN;\n\t\tgoto unlock;\n\t}\n\tmlxsw_skb_cb(skb)->tx_info = *tx_info;\n\telem_info->u.sdq.skb = skb;\n\n\twqe = elem_info->elem;\n\tmlxsw_pci_wqe_c_set(wqe, 1);  \n\tmlxsw_pci_wqe_lp_set(wqe, 0);\n\tmlxsw_pci_wqe_type_set(wqe, MLXSW_PCI_WQE_TYPE_ETHERNET);\n\n\terr = mlxsw_pci_wqe_frag_map(mlxsw_pci, wqe, 0, skb->data,\n\t\t\t\t     skb_headlen(skb), DMA_TO_DEVICE);\n\tif (err)\n\t\tgoto unlock;\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\terr = mlxsw_pci_wqe_frag_map(mlxsw_pci, wqe, i + 1,\n\t\t\t\t\t     skb_frag_address(frag),\n\t\t\t\t\t     skb_frag_size(frag),\n\t\t\t\t\t     DMA_TO_DEVICE);\n\t\tif (err)\n\t\t\tgoto unmap_frags;\n\t}\n\n\tif (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP))\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\n\t \n\tfor (i++; i < MLXSW_PCI_WQE_SG_ENTRIES; i++)\n\t\tmlxsw_pci_wqe_byte_count_set(wqe, i, 0);\n\n\t \n\tq->producer_counter++;\n\tmlxsw_pci_queue_doorbell_producer_ring(mlxsw_pci, q);\n\n\tgoto unlock;\n\nunmap_frags:\n\tfor (; i >= 0; i--)\n\t\tmlxsw_pci_wqe_frag_unmap(mlxsw_pci, wqe, i, DMA_TO_DEVICE);\nunlock:\n\tspin_unlock_bh(&q->lock);\n\treturn err;\n}\n\nstatic int mlxsw_pci_cmd_exec(void *bus_priv, u16 opcode, u8 opcode_mod,\n\t\t\t      u32 in_mod, bool out_mbox_direct,\n\t\t\t      char *in_mbox, size_t in_mbox_size,\n\t\t\t      char *out_mbox, size_t out_mbox_size,\n\t\t\t      u8 *p_status)\n{\n\tstruct mlxsw_pci *mlxsw_pci = bus_priv;\n\tdma_addr_t in_mapaddr = 0, out_mapaddr = 0;\n\tbool evreq = mlxsw_pci->cmd.nopoll;\n\tunsigned long timeout = msecs_to_jiffies(MLXSW_PCI_CIR_TIMEOUT_MSECS);\n\tbool *p_wait_done = &mlxsw_pci->cmd.wait_done;\n\tint err;\n\n\t*p_status = MLXSW_CMD_STATUS_OK;\n\n\terr = mutex_lock_interruptible(&mlxsw_pci->cmd.lock);\n\tif (err)\n\t\treturn err;\n\n\tif (in_mbox) {\n\t\tmemcpy(mlxsw_pci->cmd.in_mbox.buf, in_mbox, in_mbox_size);\n\t\tin_mapaddr = mlxsw_pci->cmd.in_mbox.mapaddr;\n\t}\n\tmlxsw_pci_write32(mlxsw_pci, CIR_IN_PARAM_HI, upper_32_bits(in_mapaddr));\n\tmlxsw_pci_write32(mlxsw_pci, CIR_IN_PARAM_LO, lower_32_bits(in_mapaddr));\n\n\tif (out_mbox)\n\t\tout_mapaddr = mlxsw_pci->cmd.out_mbox.mapaddr;\n\tmlxsw_pci_write32(mlxsw_pci, CIR_OUT_PARAM_HI, upper_32_bits(out_mapaddr));\n\tmlxsw_pci_write32(mlxsw_pci, CIR_OUT_PARAM_LO, lower_32_bits(out_mapaddr));\n\n\tmlxsw_pci_write32(mlxsw_pci, CIR_IN_MODIFIER, in_mod);\n\tmlxsw_pci_write32(mlxsw_pci, CIR_TOKEN, 0);\n\n\t*p_wait_done = false;\n\n\twmb();  \n\tmlxsw_pci_write32(mlxsw_pci, CIR_CTRL,\n\t\t\t  MLXSW_PCI_CIR_CTRL_GO_BIT |\n\t\t\t  (evreq ? MLXSW_PCI_CIR_CTRL_EVREQ_BIT : 0) |\n\t\t\t  (opcode_mod << MLXSW_PCI_CIR_CTRL_OPCODE_MOD_SHIFT) |\n\t\t\t  opcode);\n\n\tif (!evreq) {\n\t\tunsigned long end;\n\n\t\tend = jiffies + timeout;\n\t\tdo {\n\t\t\tu32 ctrl = mlxsw_pci_read32(mlxsw_pci, CIR_CTRL);\n\n\t\t\tif (!(ctrl & MLXSW_PCI_CIR_CTRL_GO_BIT)) {\n\t\t\t\t*p_wait_done = true;\n\t\t\t\t*p_status = ctrl >> MLXSW_PCI_CIR_CTRL_STATUS_SHIFT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t} while (time_before(jiffies, end));\n\t} else {\n\t\twait_event_timeout(mlxsw_pci->cmd.wait, *p_wait_done, timeout);\n\t\t*p_status = mlxsw_pci->cmd.comp.status;\n\t}\n\n\terr = 0;\n\tif (*p_wait_done) {\n\t\tif (*p_status)\n\t\t\terr = -EIO;\n\t} else {\n\t\terr = -ETIMEDOUT;\n\t}\n\n\tif (!err && out_mbox && out_mbox_direct) {\n\t\t \n\t\t__be32 tmp;\n\n\t\tif (!evreq) {\n\t\t\ttmp = cpu_to_be32(mlxsw_pci_read32(mlxsw_pci,\n\t\t\t\t\t\t\t   CIR_OUT_PARAM_HI));\n\t\t\tmemcpy(out_mbox, &tmp, sizeof(tmp));\n\t\t\ttmp = cpu_to_be32(mlxsw_pci_read32(mlxsw_pci,\n\t\t\t\t\t\t\t   CIR_OUT_PARAM_LO));\n\t\t\tmemcpy(out_mbox + sizeof(tmp), &tmp, sizeof(tmp));\n\t\t}\n\t} else if (!err && out_mbox) {\n\t\tmemcpy(out_mbox, mlxsw_pci->cmd.out_mbox.buf, out_mbox_size);\n\t}\n\n\tmutex_unlock(&mlxsw_pci->cmd.lock);\n\n\treturn err;\n}\n\nstatic u32 mlxsw_pci_read_frc_h(void *bus_priv)\n{\n\tstruct mlxsw_pci *mlxsw_pci = bus_priv;\n\tu64 frc_offset_h;\n\n\tfrc_offset_h = mlxsw_pci->free_running_clock_offset;\n\treturn mlxsw_pci_read32_off(mlxsw_pci, frc_offset_h);\n}\n\nstatic u32 mlxsw_pci_read_frc_l(void *bus_priv)\n{\n\tstruct mlxsw_pci *mlxsw_pci = bus_priv;\n\tu64 frc_offset_l;\n\n\tfrc_offset_l = mlxsw_pci->free_running_clock_offset + 4;\n\treturn mlxsw_pci_read32_off(mlxsw_pci, frc_offset_l);\n}\n\nstatic u32 mlxsw_pci_read_utc_sec(void *bus_priv)\n{\n\tstruct mlxsw_pci *mlxsw_pci = bus_priv;\n\n\treturn mlxsw_pci_read32_off(mlxsw_pci, mlxsw_pci->utc_sec_offset);\n}\n\nstatic u32 mlxsw_pci_read_utc_nsec(void *bus_priv)\n{\n\tstruct mlxsw_pci *mlxsw_pci = bus_priv;\n\n\treturn mlxsw_pci_read32_off(mlxsw_pci, mlxsw_pci->utc_nsec_offset);\n}\n\nstatic const struct mlxsw_bus mlxsw_pci_bus = {\n\t.kind\t\t\t= \"pci\",\n\t.init\t\t\t= mlxsw_pci_init,\n\t.fini\t\t\t= mlxsw_pci_fini,\n\t.skb_transmit_busy\t= mlxsw_pci_skb_transmit_busy,\n\t.skb_transmit\t\t= mlxsw_pci_skb_transmit,\n\t.cmd_exec\t\t= mlxsw_pci_cmd_exec,\n\t.read_frc_h\t\t= mlxsw_pci_read_frc_h,\n\t.read_frc_l\t\t= mlxsw_pci_read_frc_l,\n\t.read_utc_sec\t\t= mlxsw_pci_read_utc_sec,\n\t.read_utc_nsec\t\t= mlxsw_pci_read_utc_nsec,\n\t.features\t\t= MLXSW_BUS_F_TXRX | MLXSW_BUS_F_RESET,\n};\n\nstatic int mlxsw_pci_cmd_init(struct mlxsw_pci *mlxsw_pci)\n{\n\tint err;\n\n\tmutex_init(&mlxsw_pci->cmd.lock);\n\tinit_waitqueue_head(&mlxsw_pci->cmd.wait);\n\n\terr = mlxsw_pci_mbox_alloc(mlxsw_pci, &mlxsw_pci->cmd.in_mbox);\n\tif (err)\n\t\tgoto err_in_mbox_alloc;\n\n\terr = mlxsw_pci_mbox_alloc(mlxsw_pci, &mlxsw_pci->cmd.out_mbox);\n\tif (err)\n\t\tgoto err_out_mbox_alloc;\n\n\treturn 0;\n\nerr_out_mbox_alloc:\n\tmlxsw_pci_mbox_free(mlxsw_pci, &mlxsw_pci->cmd.in_mbox);\nerr_in_mbox_alloc:\n\tmutex_destroy(&mlxsw_pci->cmd.lock);\n\treturn err;\n}\n\nstatic void mlxsw_pci_cmd_fini(struct mlxsw_pci *mlxsw_pci)\n{\n\tmlxsw_pci_mbox_free(mlxsw_pci, &mlxsw_pci->cmd.out_mbox);\n\tmlxsw_pci_mbox_free(mlxsw_pci, &mlxsw_pci->cmd.in_mbox);\n\tmutex_destroy(&mlxsw_pci->cmd.lock);\n}\n\nstatic int mlxsw_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tconst char *driver_name = dev_driver_string(&pdev->dev);\n\tstruct mlxsw_pci *mlxsw_pci;\n\tint err;\n\n\tmlxsw_pci = kzalloc(sizeof(*mlxsw_pci), GFP_KERNEL);\n\tif (!mlxsw_pci)\n\t\treturn -ENOMEM;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"pci_enable_device failed\\n\");\n\t\tgoto err_pci_enable_device;\n\t}\n\n\terr = pci_request_regions(pdev, driver_name);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"pci_request_regions failed\\n\");\n\t\tgoto err_pci_request_regions;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"dma_set_mask failed\\n\");\n\t\t\tgoto err_pci_set_dma_mask;\n\t\t}\n\t}\n\n\tif (pci_resource_len(pdev, 0) < MLXSW_PCI_BAR0_SIZE) {\n\t\tdev_err(&pdev->dev, \"invalid PCI region size\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_pci_resource_len_check;\n\t}\n\n\tmlxsw_pci->hw_addr = ioremap(pci_resource_start(pdev, 0),\n\t\t\t\t     pci_resource_len(pdev, 0));\n\tif (!mlxsw_pci->hw_addr) {\n\t\tdev_err(&pdev->dev, \"ioremap failed\\n\");\n\t\terr = -EIO;\n\t\tgoto err_ioremap;\n\t}\n\tpci_set_master(pdev);\n\n\tmlxsw_pci->pdev = pdev;\n\tpci_set_drvdata(pdev, mlxsw_pci);\n\n\terr = mlxsw_pci_cmd_init(mlxsw_pci);\n\tif (err)\n\t\tgoto err_pci_cmd_init;\n\n\tmlxsw_pci->bus_info.device_kind = driver_name;\n\tmlxsw_pci->bus_info.device_name = pci_name(mlxsw_pci->pdev);\n\tmlxsw_pci->bus_info.dev = &pdev->dev;\n\tmlxsw_pci->bus_info.read_clock_capable = true;\n\tmlxsw_pci->id = id;\n\n\terr = mlxsw_core_bus_device_register(&mlxsw_pci->bus_info,\n\t\t\t\t\t     &mlxsw_pci_bus, mlxsw_pci, false,\n\t\t\t\t\t     NULL, NULL);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"cannot register bus device\\n\");\n\t\tgoto err_bus_device_register;\n\t}\n\n\treturn 0;\n\nerr_bus_device_register:\n\tmlxsw_pci_cmd_fini(mlxsw_pci);\nerr_pci_cmd_init:\n\tiounmap(mlxsw_pci->hw_addr);\nerr_ioremap:\nerr_pci_resource_len_check:\nerr_pci_set_dma_mask:\n\tpci_release_regions(pdev);\nerr_pci_request_regions:\n\tpci_disable_device(pdev);\nerr_pci_enable_device:\n\tkfree(mlxsw_pci);\n\treturn err;\n}\n\nstatic void mlxsw_pci_remove(struct pci_dev *pdev)\n{\n\tstruct mlxsw_pci *mlxsw_pci = pci_get_drvdata(pdev);\n\n\tmlxsw_core_bus_device_unregister(mlxsw_pci->core, false);\n\tmlxsw_pci_cmd_fini(mlxsw_pci);\n\tiounmap(mlxsw_pci->hw_addr);\n\tpci_release_regions(mlxsw_pci->pdev);\n\tpci_disable_device(mlxsw_pci->pdev);\n\tkfree(mlxsw_pci);\n}\n\nint mlxsw_pci_driver_register(struct pci_driver *pci_driver)\n{\n\tpci_driver->probe = mlxsw_pci_probe;\n\tpci_driver->remove = mlxsw_pci_remove;\n\tpci_driver->shutdown = mlxsw_pci_remove;\n\treturn pci_register_driver(pci_driver);\n}\nEXPORT_SYMBOL(mlxsw_pci_driver_register);\n\nvoid mlxsw_pci_driver_unregister(struct pci_driver *pci_driver)\n{\n\tpci_unregister_driver(pci_driver);\n}\nEXPORT_SYMBOL(mlxsw_pci_driver_unregister);\n\nstatic int __init mlxsw_pci_module_init(void)\n{\n\treturn 0;\n}\n\nstatic void __exit mlxsw_pci_module_exit(void)\n{\n}\n\nmodule_init(mlxsw_pci_module_init);\nmodule_exit(mlxsw_pci_module_exit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Jiri Pirko <jiri@mellanox.com>\");\nMODULE_DESCRIPTION(\"Mellanox switch PCI interface driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}