{
  "module_name": "spectrum_ptp.c",
  "hash_id": "dfcc9b565eed2314e365e9378441aaef3637e157b46cbe5945556d4cc330596e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_ptp.c",
  "human_readable_source": "\n \n\n#include <linux/ptp_clock_kernel.h>\n#include <linux/clocksource.h>\n#include <linux/timecounter.h>\n#include <linux/spinlock.h>\n#include <linux/device.h>\n#include <linux/rhashtable.h>\n#include <linux/ptp_classify.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/net_tstamp.h>\n#include <linux/refcount.h>\n\n#include \"spectrum.h\"\n#include \"spectrum_ptp.h\"\n#include \"core.h\"\n\n#define MLXSW_SP1_PTP_CLOCK_CYCLES_SHIFT\t29\n#define MLXSW_SP1_PTP_CLOCK_FREQ_KHZ\t\t156257  \n#define MLXSW_SP1_PTP_CLOCK_MASK\t\t64\n\n#define MLXSW_SP1_PTP_HT_GC_INTERVAL\t\t500  \n\n \n#define MLXSW_SP1_PTP_HT_GC_TIMEOUT\t\t1000  \n\nstruct mlxsw_sp_ptp_state {\n\tstruct mlxsw_sp *mlxsw_sp;\n};\n\nstruct mlxsw_sp1_ptp_state {\n\tstruct mlxsw_sp_ptp_state common;\n\tstruct rhltable unmatched_ht;\n\tspinlock_t unmatched_lock;  \n\tstruct delayed_work ht_gc_dw;\n\tu32 gc_cycle;\n};\n\nstruct mlxsw_sp2_ptp_state {\n\tstruct mlxsw_sp_ptp_state common;\n\trefcount_t ptp_port_enabled_ref;  \n\tstruct hwtstamp_config config;\n\tstruct mutex lock;  \n};\n\nstruct mlxsw_sp1_ptp_key {\n\tu16 local_port;\n\tu8 message_type;\n\tu16 sequence_id;\n\tu8 domain_number;\n\tbool ingress;\n};\n\nstruct mlxsw_sp1_ptp_unmatched {\n\tstruct mlxsw_sp1_ptp_key key;\n\tstruct rhlist_head ht_node;\n\tstruct rcu_head rcu;\n\tstruct sk_buff *skb;\n\tu64 timestamp;\n\tu32 gc_cycle;\n};\n\nstatic const struct rhashtable_params mlxsw_sp1_ptp_unmatched_ht_params = {\n\t.key_len = sizeof_field(struct mlxsw_sp1_ptp_unmatched, key),\n\t.key_offset = offsetof(struct mlxsw_sp1_ptp_unmatched, key),\n\t.head_offset = offsetof(struct mlxsw_sp1_ptp_unmatched, ht_node),\n};\n\nstruct mlxsw_sp_ptp_clock {\n\tstruct mlxsw_core *core;\n\tstruct ptp_clock *ptp;\n\tstruct ptp_clock_info ptp_info;\n};\n\nstruct mlxsw_sp1_ptp_clock {\n\tstruct mlxsw_sp_ptp_clock common;\n\tspinlock_t lock;  \n\tstruct cyclecounter cycles;\n\tstruct timecounter tc;\n\tu32 nominal_c_mult;\n\tunsigned long overflow_period;\n\tstruct delayed_work overflow_work;\n};\n\nstatic struct mlxsw_sp1_ptp_state *\nmlxsw_sp1_ptp_state(struct mlxsw_sp *mlxsw_sp)\n{\n\treturn container_of(mlxsw_sp->ptp_state, struct mlxsw_sp1_ptp_state,\n\t\t\t    common);\n}\n\nstatic struct mlxsw_sp2_ptp_state *\nmlxsw_sp2_ptp_state(struct mlxsw_sp *mlxsw_sp)\n{\n\treturn container_of(mlxsw_sp->ptp_state, struct mlxsw_sp2_ptp_state,\n\t\t\t    common);\n}\n\nstatic struct mlxsw_sp1_ptp_clock *\nmlxsw_sp1_ptp_clock(struct ptp_clock_info *ptp)\n{\n\treturn container_of(ptp, struct mlxsw_sp1_ptp_clock, common.ptp_info);\n}\n\nstatic u64 __mlxsw_sp1_ptp_read_frc(struct mlxsw_sp1_ptp_clock *clock,\n\t\t\t\t    struct ptp_system_timestamp *sts)\n{\n\tstruct mlxsw_core *mlxsw_core = clock->common.core;\n\tu32 frc_h1, frc_h2, frc_l;\n\n\tfrc_h1 = mlxsw_core_read_frc_h(mlxsw_core);\n\tptp_read_system_prets(sts);\n\tfrc_l = mlxsw_core_read_frc_l(mlxsw_core);\n\tptp_read_system_postts(sts);\n\tfrc_h2 = mlxsw_core_read_frc_h(mlxsw_core);\n\n\tif (frc_h1 != frc_h2) {\n\t\t \n\t\tptp_read_system_prets(sts);\n\t\tfrc_l = mlxsw_core_read_frc_l(mlxsw_core);\n\t\tptp_read_system_postts(sts);\n\t}\n\n\treturn (u64) frc_l | (u64) frc_h2 << 32;\n}\n\nstatic u64 mlxsw_sp1_ptp_read_frc(const struct cyclecounter *cc)\n{\n\tstruct mlxsw_sp1_ptp_clock *clock =\n\t\tcontainer_of(cc, struct mlxsw_sp1_ptp_clock, cycles);\n\n\treturn __mlxsw_sp1_ptp_read_frc(clock, NULL) & cc->mask;\n}\n\nstatic int\nmlxsw_sp_ptp_phc_adjfreq(struct mlxsw_sp_ptp_clock *clock, int freq_adj)\n{\n\tstruct mlxsw_core *mlxsw_core = clock->core;\n\tchar mtutc_pl[MLXSW_REG_MTUTC_LEN];\n\n\tmlxsw_reg_mtutc_pack(mtutc_pl, MLXSW_REG_MTUTC_OPERATION_ADJUST_FREQ,\n\t\t\t     freq_adj, 0, 0, 0);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mtutc), mtutc_pl);\n}\n\nstatic u64 mlxsw_sp1_ptp_ns2cycles(const struct timecounter *tc, u64 nsec)\n{\n\tu64 cycles = (u64) nsec;\n\n\tcycles <<= tc->cc->shift;\n\tcycles = div_u64(cycles, tc->cc->mult);\n\n\treturn cycles;\n}\n\nstatic int\nmlxsw_sp1_ptp_phc_settime(struct mlxsw_sp1_ptp_clock *clock, u64 nsec)\n{\n\tstruct mlxsw_core *mlxsw_core = clock->common.core;\n\tu64 next_sec, next_sec_in_nsec, cycles;\n\tchar mtutc_pl[MLXSW_REG_MTUTC_LEN];\n\tchar mtpps_pl[MLXSW_REG_MTPPS_LEN];\n\tint err;\n\n\tnext_sec = div_u64(nsec, NSEC_PER_SEC) + 1;\n\tnext_sec_in_nsec = next_sec * NSEC_PER_SEC;\n\n\tspin_lock_bh(&clock->lock);\n\tcycles = mlxsw_sp1_ptp_ns2cycles(&clock->tc, next_sec_in_nsec);\n\tspin_unlock_bh(&clock->lock);\n\n\tmlxsw_reg_mtpps_vpin_pack(mtpps_pl, cycles);\n\terr = mlxsw_reg_write(mlxsw_core, MLXSW_REG(mtpps), mtpps_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mtutc_pack(mtutc_pl,\n\t\t\t     MLXSW_REG_MTUTC_OPERATION_SET_TIME_AT_NEXT_SEC,\n\t\t\t     0, next_sec, 0, 0);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mtutc), mtutc_pl);\n}\n\nstatic int mlxsw_sp1_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct mlxsw_sp1_ptp_clock *clock = mlxsw_sp1_ptp_clock(ptp);\n\ts32 ppb;\n\n\tppb = scaled_ppm_to_ppb(scaled_ppm);\n\n\tspin_lock_bh(&clock->lock);\n\ttimecounter_read(&clock->tc);\n\tclock->cycles.mult = adjust_by_scaled_ppm(clock->nominal_c_mult,\n\t\t\t\t\t\t  scaled_ppm);\n\tspin_unlock_bh(&clock->lock);\n\n\treturn mlxsw_sp_ptp_phc_adjfreq(&clock->common, ppb);\n}\n\nstatic int mlxsw_sp1_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct mlxsw_sp1_ptp_clock *clock = mlxsw_sp1_ptp_clock(ptp);\n\tu64 nsec;\n\n\tspin_lock_bh(&clock->lock);\n\ttimecounter_adjtime(&clock->tc, delta);\n\tnsec = timecounter_read(&clock->tc);\n\tspin_unlock_bh(&clock->lock);\n\n\treturn mlxsw_sp1_ptp_phc_settime(clock, nsec);\n}\n\nstatic int mlxsw_sp1_ptp_gettimex(struct ptp_clock_info *ptp,\n\t\t\t\t  struct timespec64 *ts,\n\t\t\t\t  struct ptp_system_timestamp *sts)\n{\n\tstruct mlxsw_sp1_ptp_clock *clock = mlxsw_sp1_ptp_clock(ptp);\n\tu64 cycles, nsec;\n\n\tspin_lock_bh(&clock->lock);\n\tcycles = __mlxsw_sp1_ptp_read_frc(clock, sts);\n\tnsec = timecounter_cyc2time(&clock->tc, cycles);\n\tspin_unlock_bh(&clock->lock);\n\n\t*ts = ns_to_timespec64(nsec);\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp1_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t\t const struct timespec64 *ts)\n{\n\tstruct mlxsw_sp1_ptp_clock *clock = mlxsw_sp1_ptp_clock(ptp);\n\tu64 nsec = timespec64_to_ns(ts);\n\n\tspin_lock_bh(&clock->lock);\n\ttimecounter_init(&clock->tc, &clock->cycles, nsec);\n\tnsec = timecounter_read(&clock->tc);\n\tspin_unlock_bh(&clock->lock);\n\n\treturn mlxsw_sp1_ptp_phc_settime(clock, nsec);\n}\n\nstatic const struct ptp_clock_info mlxsw_sp1_ptp_clock_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"mlxsw_sp_clock\",\n\t.max_adj\t= 100000000,\n\t.adjfine\t= mlxsw_sp1_ptp_adjfine,\n\t.adjtime\t= mlxsw_sp1_ptp_adjtime,\n\t.gettimex64\t= mlxsw_sp1_ptp_gettimex,\n\t.settime64\t= mlxsw_sp1_ptp_settime,\n};\n\nstatic void mlxsw_sp1_ptp_clock_overflow(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct mlxsw_sp1_ptp_clock *clock;\n\n\tclock = container_of(dwork, struct mlxsw_sp1_ptp_clock, overflow_work);\n\n\tspin_lock_bh(&clock->lock);\n\ttimecounter_read(&clock->tc);\n\tspin_unlock_bh(&clock->lock);\n\tmlxsw_core_schedule_dw(&clock->overflow_work, clock->overflow_period);\n}\n\nstruct mlxsw_sp_ptp_clock *\nmlxsw_sp1_ptp_clock_init(struct mlxsw_sp *mlxsw_sp, struct device *dev)\n{\n\tu64 overflow_cycles, nsec, frac = 0;\n\tstruct mlxsw_sp1_ptp_clock *clock;\n\tint err;\n\n\tclock = kzalloc(sizeof(*clock), GFP_KERNEL);\n\tif (!clock)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&clock->lock);\n\tclock->cycles.read = mlxsw_sp1_ptp_read_frc;\n\tclock->cycles.shift = MLXSW_SP1_PTP_CLOCK_CYCLES_SHIFT;\n\tclock->cycles.mult = clocksource_khz2mult(MLXSW_SP1_PTP_CLOCK_FREQ_KHZ,\n\t\t\t\t\t\t  clock->cycles.shift);\n\tclock->nominal_c_mult = clock->cycles.mult;\n\tclock->cycles.mask = CLOCKSOURCE_MASK(MLXSW_SP1_PTP_CLOCK_MASK);\n\tclock->common.core = mlxsw_sp->core;\n\n\ttimecounter_init(&clock->tc, &clock->cycles, 0);\n\n\t \n\toverflow_cycles = div64_u64(~0ULL >> 1, clock->cycles.mult);\n\toverflow_cycles = min(overflow_cycles, div_u64(clock->cycles.mask, 3));\n\n\tnsec = cyclecounter_cyc2ns(&clock->cycles, overflow_cycles, 0, &frac);\n\tclock->overflow_period = nsecs_to_jiffies(nsec);\n\n\tINIT_DELAYED_WORK(&clock->overflow_work, mlxsw_sp1_ptp_clock_overflow);\n\tmlxsw_core_schedule_dw(&clock->overflow_work, 0);\n\n\tclock->common.ptp_info = mlxsw_sp1_ptp_clock_info;\n\tclock->common.ptp = ptp_clock_register(&clock->common.ptp_info, dev);\n\tif (IS_ERR(clock->common.ptp)) {\n\t\terr = PTR_ERR(clock->common.ptp);\n\t\tdev_err(dev, \"ptp_clock_register failed %d\\n\", err);\n\t\tgoto err_ptp_clock_register;\n\t}\n\n\treturn &clock->common;\n\nerr_ptp_clock_register:\n\tcancel_delayed_work_sync(&clock->overflow_work);\n\tkfree(clock);\n\treturn ERR_PTR(err);\n}\n\nvoid mlxsw_sp1_ptp_clock_fini(struct mlxsw_sp_ptp_clock *clock_common)\n{\n\tstruct mlxsw_sp1_ptp_clock *clock =\n\t\tcontainer_of(clock_common, struct mlxsw_sp1_ptp_clock, common);\n\n\tptp_clock_unregister(clock_common->ptp);\n\tcancel_delayed_work_sync(&clock->overflow_work);\n\tkfree(clock);\n}\n\nstatic u64 mlxsw_sp2_ptp_read_utc(struct mlxsw_sp_ptp_clock *clock,\n\t\t\t\t  struct ptp_system_timestamp *sts)\n{\n\tstruct mlxsw_core *mlxsw_core = clock->core;\n\tu32 utc_sec1, utc_sec2, utc_nsec;\n\n\tutc_sec1 = mlxsw_core_read_utc_sec(mlxsw_core);\n\tptp_read_system_prets(sts);\n\tutc_nsec = mlxsw_core_read_utc_nsec(mlxsw_core);\n\tptp_read_system_postts(sts);\n\tutc_sec2 = mlxsw_core_read_utc_sec(mlxsw_core);\n\n\tif (utc_sec1 != utc_sec2) {\n\t\t \n\t\tptp_read_system_prets(sts);\n\t\tutc_nsec = mlxsw_core_read_utc_nsec(mlxsw_core);\n\t\tptp_read_system_postts(sts);\n\t}\n\n\treturn (u64)utc_sec2 * NSEC_PER_SEC + utc_nsec;\n}\n\nstatic int\nmlxsw_sp2_ptp_phc_settime(struct mlxsw_sp_ptp_clock *clock, u64 nsec)\n{\n\tstruct mlxsw_core *mlxsw_core = clock->core;\n\tchar mtutc_pl[MLXSW_REG_MTUTC_LEN];\n\tu32 sec, nsec_rem;\n\n\tsec = div_u64_rem(nsec, NSEC_PER_SEC, &nsec_rem);\n\tmlxsw_reg_mtutc_pack(mtutc_pl,\n\t\t\t     MLXSW_REG_MTUTC_OPERATION_SET_TIME_IMMEDIATE,\n\t\t\t     0, sec, nsec_rem, 0);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mtutc), mtutc_pl);\n}\n\nstatic int mlxsw_sp2_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct mlxsw_sp_ptp_clock *clock =\n\t\tcontainer_of(ptp, struct mlxsw_sp_ptp_clock, ptp_info);\n\ts32 ppb = scaled_ppm_to_ppb(scaled_ppm);\n\n\t \n\treturn mlxsw_sp_ptp_phc_adjfreq(clock, -ppb);\n}\n\nstatic int mlxsw_sp2_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct mlxsw_sp_ptp_clock *clock =\n\t\tcontainer_of(ptp, struct mlxsw_sp_ptp_clock, ptp_info);\n\tstruct mlxsw_core *mlxsw_core = clock->core;\n\tchar mtutc_pl[MLXSW_REG_MTUTC_LEN];\n\n\t \n\tif (delta < S16_MIN || delta > S16_MAX) {\n\t\tu64 nsec;\n\n\t\tnsec = mlxsw_sp2_ptp_read_utc(clock, NULL);\n\t\tnsec += delta;\n\n\t\treturn mlxsw_sp2_ptp_phc_settime(clock, nsec);\n\t}\n\n\tmlxsw_reg_mtutc_pack(mtutc_pl,\n\t\t\t     MLXSW_REG_MTUTC_OPERATION_ADJUST_TIME,\n\t\t\t     0, 0, 0, delta);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mtutc), mtutc_pl);\n}\n\nstatic int mlxsw_sp2_ptp_gettimex(struct ptp_clock_info *ptp,\n\t\t\t\t  struct timespec64 *ts,\n\t\t\t\t  struct ptp_system_timestamp *sts)\n{\n\tstruct mlxsw_sp_ptp_clock *clock =\n\t\tcontainer_of(ptp, struct mlxsw_sp_ptp_clock, ptp_info);\n\tu64 nsec;\n\n\tnsec = mlxsw_sp2_ptp_read_utc(clock, sts);\n\t*ts = ns_to_timespec64(nsec);\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp2_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t\t const struct timespec64 *ts)\n{\n\tstruct mlxsw_sp_ptp_clock *clock =\n\t\tcontainer_of(ptp, struct mlxsw_sp_ptp_clock, ptp_info);\n\tu64 nsec = timespec64_to_ns(ts);\n\n\treturn mlxsw_sp2_ptp_phc_settime(clock, nsec);\n}\n\nstatic const struct ptp_clock_info mlxsw_sp2_ptp_clock_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"mlxsw_sp_clock\",\n\t.max_adj\t= MLXSW_REG_MTUTC_MAX_FREQ_ADJ,\n\t.adjfine\t= mlxsw_sp2_ptp_adjfine,\n\t.adjtime\t= mlxsw_sp2_ptp_adjtime,\n\t.gettimex64\t= mlxsw_sp2_ptp_gettimex,\n\t.settime64\t= mlxsw_sp2_ptp_settime,\n};\n\nstruct mlxsw_sp_ptp_clock *\nmlxsw_sp2_ptp_clock_init(struct mlxsw_sp *mlxsw_sp, struct device *dev)\n{\n\tstruct mlxsw_sp_ptp_clock *clock;\n\tint err;\n\n\tclock = kzalloc(sizeof(*clock), GFP_KERNEL);\n\tif (!clock)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclock->core = mlxsw_sp->core;\n\n\tclock->ptp_info = mlxsw_sp2_ptp_clock_info;\n\n\terr = mlxsw_sp2_ptp_phc_settime(clock, 0);\n\tif (err) {\n\t\tdev_err(dev, \"setting UTC time failed %d\\n\", err);\n\t\tgoto err_ptp_phc_settime;\n\t}\n\n\tclock->ptp = ptp_clock_register(&clock->ptp_info, dev);\n\tif (IS_ERR(clock->ptp)) {\n\t\terr = PTR_ERR(clock->ptp);\n\t\tdev_err(dev, \"ptp_clock_register failed %d\\n\", err);\n\t\tgoto err_ptp_clock_register;\n\t}\n\n\treturn clock;\n\nerr_ptp_clock_register:\nerr_ptp_phc_settime:\n\tkfree(clock);\n\treturn ERR_PTR(err);\n}\n\nvoid mlxsw_sp2_ptp_clock_fini(struct mlxsw_sp_ptp_clock *clock)\n{\n\tptp_clock_unregister(clock->ptp);\n\tkfree(clock);\n}\n\nstatic int mlxsw_sp_ptp_parse(struct sk_buff *skb,\n\t\t\t      u8 *p_domain_number,\n\t\t\t      u8 *p_message_type,\n\t\t\t      u16 *p_sequence_id)\n{\n\tunsigned int ptp_class;\n\tstruct ptp_header *hdr;\n\n\tptp_class = ptp_classify_raw(skb);\n\n\tswitch (ptp_class & PTP_CLASS_VMASK) {\n\tcase PTP_CLASS_V1:\n\tcase PTP_CLASS_V2:\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\thdr = ptp_parse_header(skb, ptp_class);\n\tif (!hdr)\n\t\treturn -EINVAL;\n\n\t*p_message_type\t = ptp_get_msgtype(hdr, ptp_class);\n\t*p_domain_number = hdr->domain_number;\n\t*p_sequence_id\t = be16_to_cpu(hdr->sequence_id);\n\n\treturn 0;\n}\n\n \nstatic int\nmlxsw_sp1_ptp_unmatched_save(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     struct mlxsw_sp1_ptp_key key,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     u64 timestamp)\n{\n\tint cycles = MLXSW_SP1_PTP_HT_GC_TIMEOUT / MLXSW_SP1_PTP_HT_GC_INTERVAL;\n\tstruct mlxsw_sp1_ptp_state *ptp_state = mlxsw_sp1_ptp_state(mlxsw_sp);\n\tstruct mlxsw_sp1_ptp_unmatched *unmatched;\n\tint err;\n\n\tunmatched = kzalloc(sizeof(*unmatched), GFP_ATOMIC);\n\tif (!unmatched)\n\t\treturn -ENOMEM;\n\n\tunmatched->key = key;\n\tunmatched->skb = skb;\n\tunmatched->timestamp = timestamp;\n\tunmatched->gc_cycle = ptp_state->gc_cycle + cycles;\n\n\terr = rhltable_insert(&ptp_state->unmatched_ht, &unmatched->ht_node,\n\t\t\t      mlxsw_sp1_ptp_unmatched_ht_params);\n\tif (err)\n\t\tkfree(unmatched);\n\n\treturn err;\n}\n\nstatic struct mlxsw_sp1_ptp_unmatched *\nmlxsw_sp1_ptp_unmatched_lookup(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp1_ptp_key key, int *p_length)\n{\n\tstruct mlxsw_sp1_ptp_state *ptp_state = mlxsw_sp1_ptp_state(mlxsw_sp);\n\tstruct mlxsw_sp1_ptp_unmatched *unmatched, *last = NULL;\n\tstruct rhlist_head *tmp, *list;\n\tint length = 0;\n\n\tlist = rhltable_lookup(&ptp_state->unmatched_ht, &key,\n\t\t\t       mlxsw_sp1_ptp_unmatched_ht_params);\n\trhl_for_each_entry_rcu(unmatched, tmp, list, ht_node) {\n\t\tlast = unmatched;\n\t\tlength++;\n\t}\n\n\t*p_length = length;\n\treturn last;\n}\n\nstatic int\nmlxsw_sp1_ptp_unmatched_remove(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp1_ptp_unmatched *unmatched)\n{\n\tstruct mlxsw_sp1_ptp_state *ptp_state = mlxsw_sp1_ptp_state(mlxsw_sp);\n\n\treturn rhltable_remove(&ptp_state->unmatched_ht,\n\t\t\t       &unmatched->ht_node,\n\t\t\t       mlxsw_sp1_ptp_unmatched_ht_params);\n}\n\n \nstatic void mlxsw_sp1_ptp_packet_finish(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct sk_buff *skb, u16 local_port,\n\t\t\t\t\tbool ingress,\n\t\t\t\t\tstruct skb_shared_hwtstamps *hwtstamps)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\n\t \n\tmlxsw_sp_port = mlxsw_sp->ports[local_port];\n\tif (!(mlxsw_sp_port && (!skb->dev || skb->dev == mlxsw_sp_port->dev))) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\tif (ingress) {\n\t\tif (hwtstamps)\n\t\t\t*skb_hwtstamps(skb) = *hwtstamps;\n\t\tmlxsw_sp_rx_listener_no_mark_func(skb, local_port, mlxsw_sp);\n\t} else {\n\t\t \n\t\tskb_tstamp_tx(skb, hwtstamps);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void mlxsw_sp1_packet_timestamp(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       struct mlxsw_sp1_ptp_key key,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       u64 timestamp)\n{\n\tstruct mlxsw_sp_ptp_clock *clock_common = mlxsw_sp->clock;\n\tstruct mlxsw_sp1_ptp_clock *clock =\n\t\tcontainer_of(clock_common, struct mlxsw_sp1_ptp_clock, common);\n\n\tstruct skb_shared_hwtstamps hwtstamps;\n\tu64 nsec;\n\n\tspin_lock_bh(&clock->lock);\n\tnsec = timecounter_cyc2time(&clock->tc, timestamp);\n\tspin_unlock_bh(&clock->lock);\n\n\thwtstamps.hwtstamp = ns_to_ktime(nsec);\n\tmlxsw_sp1_ptp_packet_finish(mlxsw_sp, skb,\n\t\t\t\t    key.local_port, key.ingress, &hwtstamps);\n}\n\nstatic void\nmlxsw_sp1_ptp_unmatched_finish(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp1_ptp_unmatched *unmatched)\n{\n\tif (unmatched->skb && unmatched->timestamp)\n\t\tmlxsw_sp1_packet_timestamp(mlxsw_sp, unmatched->key,\n\t\t\t\t\t   unmatched->skb,\n\t\t\t\t\t   unmatched->timestamp);\n\telse if (unmatched->skb)\n\t\tmlxsw_sp1_ptp_packet_finish(mlxsw_sp, unmatched->skb,\n\t\t\t\t\t    unmatched->key.local_port,\n\t\t\t\t\t    unmatched->key.ingress, NULL);\n\tkfree_rcu(unmatched, rcu);\n}\n\nstatic void mlxsw_sp1_ptp_unmatched_free_fn(void *ptr, void *arg)\n{\n\tstruct mlxsw_sp1_ptp_unmatched *unmatched = ptr;\n\n\t \n\tif (unmatched->skb)\n\t\tdev_kfree_skb_any(unmatched->skb);\n\tkfree_rcu(unmatched, rcu);\n}\n\nstatic void mlxsw_sp1_ptp_got_piece(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp1_ptp_key key,\n\t\t\t\t    struct sk_buff *skb, u64 timestamp)\n{\n\tstruct mlxsw_sp1_ptp_state *ptp_state = mlxsw_sp1_ptp_state(mlxsw_sp);\n\tstruct mlxsw_sp1_ptp_unmatched *unmatched;\n\tint length;\n\tint err;\n\n\trcu_read_lock();\n\n\tspin_lock(&ptp_state->unmatched_lock);\n\n\tunmatched = mlxsw_sp1_ptp_unmatched_lookup(mlxsw_sp, key, &length);\n\tif (skb && unmatched && unmatched->timestamp) {\n\t\tunmatched->skb = skb;\n\t} else if (timestamp && unmatched && unmatched->skb) {\n\t\tunmatched->timestamp = timestamp;\n\t} else {\n\t\t \n\t\tif (length < 100)\n\t\t\terr = mlxsw_sp1_ptp_unmatched_save(mlxsw_sp, key,\n\t\t\t\t\t\t\t   skb, timestamp);\n\t\telse\n\t\t\terr = -E2BIG;\n\t\tif (err && skb)\n\t\t\tmlxsw_sp1_ptp_packet_finish(mlxsw_sp, skb,\n\t\t\t\t\t\t    key.local_port,\n\t\t\t\t\t\t    key.ingress, NULL);\n\t\tunmatched = NULL;\n\t}\n\n\tif (unmatched) {\n\t\terr = mlxsw_sp1_ptp_unmatched_remove(mlxsw_sp, unmatched);\n\t\tWARN_ON_ONCE(err);\n\t}\n\n\tspin_unlock(&ptp_state->unmatched_lock);\n\n\tif (unmatched)\n\t\tmlxsw_sp1_ptp_unmatched_finish(mlxsw_sp, unmatched);\n\n\trcu_read_unlock();\n}\n\nstatic void mlxsw_sp1_ptp_got_packet(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct sk_buff *skb, u16 local_port,\n\t\t\t\t     bool ingress)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tstruct mlxsw_sp1_ptp_key key;\n\tu8 types;\n\tint err;\n\n\tmlxsw_sp_port = mlxsw_sp->ports[local_port];\n\tif (!mlxsw_sp_port)\n\t\tgoto immediate;\n\n\ttypes = ingress ? mlxsw_sp_port->ptp.ing_types :\n\t\t\t  mlxsw_sp_port->ptp.egr_types;\n\tif (!types)\n\t\tgoto immediate;\n\n\tmemset(&key, 0, sizeof(key));\n\tkey.local_port = local_port;\n\tkey.ingress = ingress;\n\n\terr = mlxsw_sp_ptp_parse(skb, &key.domain_number, &key.message_type,\n\t\t\t\t &key.sequence_id);\n\tif (err)\n\t\tgoto immediate;\n\n\t \n\tif (!((1 << key.message_type) & types))\n\t\tgoto immediate;\n\n\tmlxsw_sp1_ptp_got_piece(mlxsw_sp, key, skb, 0);\n\treturn;\n\nimmediate:\n\tmlxsw_sp1_ptp_packet_finish(mlxsw_sp, skb, local_port, ingress, NULL);\n}\n\nvoid mlxsw_sp1_ptp_got_timestamp(struct mlxsw_sp *mlxsw_sp, bool ingress,\n\t\t\t\t u16 local_port, u8 message_type,\n\t\t\t\t u8 domain_number, u16 sequence_id,\n\t\t\t\t u64 timestamp)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tstruct mlxsw_sp1_ptp_key key;\n\tu8 types;\n\n\tif (WARN_ON_ONCE(!mlxsw_sp_local_port_is_valid(mlxsw_sp, local_port)))\n\t\treturn;\n\tmlxsw_sp_port = mlxsw_sp->ports[local_port];\n\tif (!mlxsw_sp_port)\n\t\treturn;\n\n\ttypes = ingress ? mlxsw_sp_port->ptp.ing_types :\n\t\t\t  mlxsw_sp_port->ptp.egr_types;\n\n\t \n\tif (!((1 << message_type) & types))\n\t\treturn;\n\n\tmemset(&key, 0, sizeof(key));\n\tkey.local_port = local_port;\n\tkey.domain_number = domain_number;\n\tkey.message_type = message_type;\n\tkey.sequence_id = sequence_id;\n\tkey.ingress = ingress;\n\n\tmlxsw_sp1_ptp_got_piece(mlxsw_sp, key, NULL, timestamp);\n}\n\nvoid mlxsw_sp1_ptp_receive(struct mlxsw_sp *mlxsw_sp, struct sk_buff *skb,\n\t\t\t   u16 local_port)\n{\n\tskb_reset_mac_header(skb);\n\tmlxsw_sp1_ptp_got_packet(mlxsw_sp, skb, local_port, true);\n}\n\nvoid mlxsw_sp1_ptp_transmitted(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct sk_buff *skb, u16 local_port)\n{\n\tmlxsw_sp1_ptp_got_packet(mlxsw_sp, skb, local_port, false);\n}\n\nstatic void\nmlxsw_sp1_ptp_ht_gc_collect(struct mlxsw_sp1_ptp_state *ptp_state,\n\t\t\t    struct mlxsw_sp1_ptp_unmatched *unmatched)\n{\n\tstruct mlxsw_sp *mlxsw_sp = ptp_state->common.mlxsw_sp;\n\tstruct mlxsw_sp_ptp_port_dir_stats *stats;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tint err;\n\n\t \n\tlocal_bh_disable();\n\n\tspin_lock(&ptp_state->unmatched_lock);\n\terr = rhltable_remove(&ptp_state->unmatched_ht, &unmatched->ht_node,\n\t\t\t      mlxsw_sp1_ptp_unmatched_ht_params);\n\tspin_unlock(&ptp_state->unmatched_lock);\n\n\tif (err)\n\t\t \n\t\tgoto out;\n\n\tmlxsw_sp_port = mlxsw_sp->ports[unmatched->key.local_port];\n\tif (mlxsw_sp_port) {\n\t\tstats = unmatched->key.ingress ?\n\t\t\t&mlxsw_sp_port->ptp.stats.rx_gcd :\n\t\t\t&mlxsw_sp_port->ptp.stats.tx_gcd;\n\t\tif (unmatched->skb)\n\t\t\tstats->packets++;\n\t\telse\n\t\t\tstats->timestamps++;\n\t}\n\n\t \n\tmlxsw_sp1_ptp_unmatched_finish(mlxsw_sp, unmatched);\n\nout:\n\tlocal_bh_enable();\n}\n\nstatic void mlxsw_sp1_ptp_ht_gc(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct mlxsw_sp1_ptp_unmatched *unmatched;\n\tstruct mlxsw_sp1_ptp_state *ptp_state;\n\tstruct rhashtable_iter iter;\n\tu32 gc_cycle;\n\tvoid *obj;\n\n\tptp_state = container_of(dwork, struct mlxsw_sp1_ptp_state, ht_gc_dw);\n\tgc_cycle = ptp_state->gc_cycle++;\n\n\trhltable_walk_enter(&ptp_state->unmatched_ht, &iter);\n\trhashtable_walk_start(&iter);\n\twhile ((obj = rhashtable_walk_next(&iter))) {\n\t\tif (IS_ERR(obj))\n\t\t\tcontinue;\n\n\t\tunmatched = obj;\n\t\tif (unmatched->gc_cycle <= gc_cycle)\n\t\t\tmlxsw_sp1_ptp_ht_gc_collect(ptp_state, unmatched);\n\t}\n\trhashtable_walk_stop(&iter);\n\trhashtable_walk_exit(&iter);\n\n\tmlxsw_core_schedule_dw(&ptp_state->ht_gc_dw,\n\t\t\t       MLXSW_SP1_PTP_HT_GC_INTERVAL);\n}\n\nstatic int mlxsw_sp_ptp_mtptpt_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   enum mlxsw_reg_mtptpt_trap_id trap_id,\n\t\t\t\t   u16 message_type)\n{\n\tchar mtptpt_pl[MLXSW_REG_MTPTPT_LEN];\n\n\tmlxsw_reg_mtptpt_pack(mtptpt_pl, trap_id, message_type);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mtptpt), mtptpt_pl);\n}\n\nstatic int mlxsw_sp1_ptp_set_fifo_clr_on_trap(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t      bool clr)\n{\n\tchar mogcr_pl[MLXSW_REG_MOGCR_LEN] = {0};\n\tint err;\n\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(mogcr), mogcr_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mogcr_ptp_iftc_set(mogcr_pl, clr);\n\tmlxsw_reg_mogcr_ptp_eftc_set(mogcr_pl, clr);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mogcr), mogcr_pl);\n}\n\nstatic int mlxsw_sp1_ptp_mtpppc_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    u16 ing_types, u16 egr_types)\n{\n\tchar mtpppc_pl[MLXSW_REG_MTPPPC_LEN];\n\n\tmlxsw_reg_mtpppc_pack(mtpppc_pl, ing_types, egr_types);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mtpppc), mtpppc_pl);\n}\n\nstruct mlxsw_sp1_ptp_shaper_params {\n\tu32 ethtool_speed;\n\tenum mlxsw_reg_qpsc_port_speed port_speed;\n\tu8 shaper_time_exp;\n\tu8 shaper_time_mantissa;\n\tu8 shaper_inc;\n\tu8 shaper_bs;\n\tu8 port_to_shaper_credits;\n\tint ing_timestamp_inc;\n\tint egr_timestamp_inc;\n};\n\nstatic const struct mlxsw_sp1_ptp_shaper_params\nmlxsw_sp1_ptp_shaper_params[] = {\n\t{\n\t\t.ethtool_speed\t\t= SPEED_100,\n\t\t.port_speed\t\t= MLXSW_REG_QPSC_PORT_SPEED_100M,\n\t\t.shaper_time_exp\t= 4,\n\t\t.shaper_time_mantissa\t= 12,\n\t\t.shaper_inc\t\t= 9,\n\t\t.shaper_bs\t\t= 1,\n\t\t.port_to_shaper_credits\t= 1,\n\t\t.ing_timestamp_inc\t= -313,\n\t\t.egr_timestamp_inc\t= 313,\n\t},\n\t{\n\t\t.ethtool_speed\t\t= SPEED_1000,\n\t\t.port_speed\t\t= MLXSW_REG_QPSC_PORT_SPEED_1G,\n\t\t.shaper_time_exp\t= 0,\n\t\t.shaper_time_mantissa\t= 12,\n\t\t.shaper_inc\t\t= 6,\n\t\t.shaper_bs\t\t= 0,\n\t\t.port_to_shaper_credits\t= 1,\n\t\t.ing_timestamp_inc\t= -35,\n\t\t.egr_timestamp_inc\t= 35,\n\t},\n\t{\n\t\t.ethtool_speed\t\t= SPEED_10000,\n\t\t.port_speed\t\t= MLXSW_REG_QPSC_PORT_SPEED_10G,\n\t\t.shaper_time_exp\t= 0,\n\t\t.shaper_time_mantissa\t= 2,\n\t\t.shaper_inc\t\t= 14,\n\t\t.shaper_bs\t\t= 1,\n\t\t.port_to_shaper_credits\t= 1,\n\t\t.ing_timestamp_inc\t= -11,\n\t\t.egr_timestamp_inc\t= 11,\n\t},\n\t{\n\t\t.ethtool_speed\t\t= SPEED_25000,\n\t\t.port_speed\t\t= MLXSW_REG_QPSC_PORT_SPEED_25G,\n\t\t.shaper_time_exp\t= 0,\n\t\t.shaper_time_mantissa\t= 0,\n\t\t.shaper_inc\t\t= 11,\n\t\t.shaper_bs\t\t= 1,\n\t\t.port_to_shaper_credits\t= 1,\n\t\t.ing_timestamp_inc\t= -14,\n\t\t.egr_timestamp_inc\t= 14,\n\t},\n};\n\n#define MLXSW_SP1_PTP_SHAPER_PARAMS_LEN ARRAY_SIZE(mlxsw_sp1_ptp_shaper_params)\n\nstatic int mlxsw_sp1_ptp_shaper_params_set(struct mlxsw_sp *mlxsw_sp)\n{\n\tconst struct mlxsw_sp1_ptp_shaper_params *params;\n\tchar qpsc_pl[MLXSW_REG_QPSC_LEN];\n\tint i, err;\n\n\tfor (i = 0; i < MLXSW_SP1_PTP_SHAPER_PARAMS_LEN; i++) {\n\t\tparams = &mlxsw_sp1_ptp_shaper_params[i];\n\t\tmlxsw_reg_qpsc_pack(qpsc_pl, params->port_speed,\n\t\t\t\t    params->shaper_time_exp,\n\t\t\t\t    params->shaper_time_mantissa,\n\t\t\t\t    params->shaper_inc, params->shaper_bs,\n\t\t\t\t    params->port_to_shaper_credits,\n\t\t\t\t    params->ing_timestamp_inc,\n\t\t\t\t    params->egr_timestamp_inc);\n\t\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpsc), qpsc_pl);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_ptp_traps_set(struct mlxsw_sp *mlxsw_sp)\n{\n\tu16 event_message_type;\n\tint err;\n\n\t \n\tevent_message_type = BIT(PTP_MSGTYPE_SYNC) |\n\t\t\t     BIT(PTP_MSGTYPE_DELAY_REQ) |\n\t\t\t     BIT(PTP_MSGTYPE_PDELAY_REQ) |\n\t\t\t     BIT(PTP_MSGTYPE_PDELAY_RESP);\n\n\terr = mlxsw_sp_ptp_mtptpt_set(mlxsw_sp, MLXSW_REG_MTPTPT_TRAP_ID_PTP0,\n\t\t\t\t      event_message_type);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mlxsw_sp_ptp_mtptpt_set(mlxsw_sp, MLXSW_REG_MTPTPT_TRAP_ID_PTP1,\n\t\t\t\t      ~event_message_type);\n\tif (err)\n\t\tgoto err_mtptpt1_set;\n\n\treturn 0;\n\nerr_mtptpt1_set:\n\tmlxsw_sp_ptp_mtptpt_set(mlxsw_sp, MLXSW_REG_MTPTPT_TRAP_ID_PTP0, 0);\n\treturn err;\n}\n\nstatic void mlxsw_sp_ptp_traps_unset(struct mlxsw_sp *mlxsw_sp)\n{\n\tmlxsw_sp_ptp_mtptpt_set(mlxsw_sp, MLXSW_REG_MTPTPT_TRAP_ID_PTP1, 0);\n\tmlxsw_sp_ptp_mtptpt_set(mlxsw_sp, MLXSW_REG_MTPTPT_TRAP_ID_PTP0, 0);\n}\n\nstruct mlxsw_sp_ptp_state *mlxsw_sp1_ptp_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp1_ptp_state *ptp_state;\n\tint err;\n\n\terr = mlxsw_sp1_ptp_shaper_params_set(mlxsw_sp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tptp_state = kzalloc(sizeof(*ptp_state), GFP_KERNEL);\n\tif (!ptp_state)\n\t\treturn ERR_PTR(-ENOMEM);\n\tptp_state->common.mlxsw_sp = mlxsw_sp;\n\n\tspin_lock_init(&ptp_state->unmatched_lock);\n\n\terr = rhltable_init(&ptp_state->unmatched_ht,\n\t\t\t    &mlxsw_sp1_ptp_unmatched_ht_params);\n\tif (err)\n\t\tgoto err_hashtable_init;\n\n\terr = mlxsw_sp_ptp_traps_set(mlxsw_sp);\n\tif (err)\n\t\tgoto err_ptp_traps_set;\n\n\terr = mlxsw_sp1_ptp_set_fifo_clr_on_trap(mlxsw_sp, true);\n\tif (err)\n\t\tgoto err_fifo_clr;\n\n\tINIT_DELAYED_WORK(&ptp_state->ht_gc_dw, mlxsw_sp1_ptp_ht_gc);\n\tmlxsw_core_schedule_dw(&ptp_state->ht_gc_dw,\n\t\t\t       MLXSW_SP1_PTP_HT_GC_INTERVAL);\n\treturn &ptp_state->common;\n\nerr_fifo_clr:\n\tmlxsw_sp_ptp_traps_unset(mlxsw_sp);\nerr_ptp_traps_set:\n\trhltable_destroy(&ptp_state->unmatched_ht);\nerr_hashtable_init:\n\tkfree(ptp_state);\n\treturn ERR_PTR(err);\n}\n\nvoid mlxsw_sp1_ptp_fini(struct mlxsw_sp_ptp_state *ptp_state_common)\n{\n\tstruct mlxsw_sp *mlxsw_sp = ptp_state_common->mlxsw_sp;\n\tstruct mlxsw_sp1_ptp_state *ptp_state;\n\n\tptp_state = mlxsw_sp1_ptp_state(mlxsw_sp);\n\n\tcancel_delayed_work_sync(&ptp_state->ht_gc_dw);\n\tmlxsw_sp1_ptp_mtpppc_set(mlxsw_sp, 0, 0);\n\tmlxsw_sp1_ptp_set_fifo_clr_on_trap(mlxsw_sp, false);\n\tmlxsw_sp_ptp_traps_unset(mlxsw_sp);\n\trhltable_free_and_destroy(&ptp_state->unmatched_ht,\n\t\t\t\t  &mlxsw_sp1_ptp_unmatched_free_fn, NULL);\n\tkfree(ptp_state);\n}\n\nint mlxsw_sp1_ptp_hwtstamp_get(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t       struct hwtstamp_config *config)\n{\n\t*config = mlxsw_sp_port->ptp.hwtstamp_config;\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp1_ptp_get_message_types(const struct hwtstamp_config *config,\n\t\t\t\tu16 *p_ing_types, u16 *p_egr_types,\n\t\t\t\tenum hwtstamp_rx_filters *p_rx_filter)\n{\n\tenum hwtstamp_rx_filters rx_filter = config->rx_filter;\n\tenum hwtstamp_tx_types tx_type = config->tx_type;\n\tu16 ing_types = 0x00;\n\tu16 egr_types = 0x00;\n\n\tswitch (tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\tegr_types = 0x00;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tegr_types = 0xff;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\tcase HWTSTAMP_TX_ONESTEP_P2P:\n\t\treturn -ERANGE;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\ting_types = 0x00;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\t\ting_types = 0x01;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\ting_types = 0x02;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\t\ting_types = 0x0f;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_ALL:\n\t\ting_types = 0xff;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_SOME:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\t\treturn -ERANGE;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*p_ing_types = ing_types;\n\t*p_egr_types = egr_types;\n\t*p_rx_filter = rx_filter;\n\treturn 0;\n}\n\nstatic int mlxsw_sp1_ptp_mtpppc_update(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t       u16 ing_types, u16 egr_types)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_port *tmp;\n\tu16 orig_ing_types = 0;\n\tu16 orig_egr_types = 0;\n\tint err;\n\tint i;\n\n\t \n\tfor (i = 1; i < mlxsw_core_max_ports(mlxsw_sp->core); i++) {\n\t\ttmp = mlxsw_sp->ports[i];\n\t\tif (tmp) {\n\t\t\torig_ing_types |= tmp->ptp.ing_types;\n\t\t\torig_egr_types |= tmp->ptp.egr_types;\n\t\t}\n\t\tif (tmp && tmp != mlxsw_sp_port) {\n\t\t\ting_types |= tmp->ptp.ing_types;\n\t\t\tegr_types |= tmp->ptp.egr_types;\n\t\t}\n\t}\n\n\tif ((ing_types || egr_types) && !(orig_ing_types || orig_egr_types)) {\n\t\terr = mlxsw_sp_parsing_depth_inc(mlxsw_sp);\n\t\tif (err) {\n\t\t\tnetdev_err(mlxsw_sp_port->dev, \"Failed to increase parsing depth\");\n\t\t\treturn err;\n\t\t}\n\t}\n\tif (!(ing_types || egr_types) && (orig_ing_types || orig_egr_types))\n\t\tmlxsw_sp_parsing_depth_dec(mlxsw_sp);\n\n\treturn mlxsw_sp1_ptp_mtpppc_set(mlxsw_sp_port->mlxsw_sp,\n\t\t\t\t       ing_types, egr_types);\n}\n\nstatic bool mlxsw_sp1_ptp_hwtstamp_enabled(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\treturn mlxsw_sp_port->ptp.ing_types || mlxsw_sp_port->ptp.egr_types;\n}\n\nstatic int\nmlxsw_sp1_ptp_port_shaper_set(struct mlxsw_sp_port *mlxsw_sp_port, bool enable)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar qeec_pl[MLXSW_REG_QEEC_LEN];\n\n\tmlxsw_reg_qeec_ptps_pack(qeec_pl, mlxsw_sp_port->local_port, enable);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qeec), qeec_pl);\n}\n\nstatic int mlxsw_sp1_ptp_port_shaper_check(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tbool ptps = false;\n\tint err, i;\n\tu32 speed;\n\n\tif (!mlxsw_sp1_ptp_hwtstamp_enabled(mlxsw_sp_port))\n\t\treturn mlxsw_sp1_ptp_port_shaper_set(mlxsw_sp_port, false);\n\n\terr = mlxsw_sp_port_speed_get(mlxsw_sp_port, &speed);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < MLXSW_SP1_PTP_SHAPER_PARAMS_LEN; i++) {\n\t\tif (mlxsw_sp1_ptp_shaper_params[i].ethtool_speed == speed) {\n\t\t\tptps = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn mlxsw_sp1_ptp_port_shaper_set(mlxsw_sp_port, ptps);\n}\n\nvoid mlxsw_sp1_ptp_shaper_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tint err;\n\n\tmlxsw_sp_port = container_of(dwork, struct mlxsw_sp_port,\n\t\t\t\t     ptp.shaper_dw);\n\n\tif (!mlxsw_sp1_ptp_hwtstamp_enabled(mlxsw_sp_port))\n\t\treturn;\n\n\terr = mlxsw_sp1_ptp_port_shaper_check(mlxsw_sp_port);\n\tif (err)\n\t\tnetdev_err(mlxsw_sp_port->dev, \"Failed to set up PTP shaper\\n\");\n}\n\nint mlxsw_sp1_ptp_hwtstamp_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t       struct hwtstamp_config *config)\n{\n\tenum hwtstamp_rx_filters rx_filter;\n\tu16 ing_types;\n\tu16 egr_types;\n\tint err;\n\n\terr = mlxsw_sp1_ptp_get_message_types(config, &ing_types, &egr_types,\n\t\t\t\t\t      &rx_filter);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp1_ptp_mtpppc_update(mlxsw_sp_port, ing_types, egr_types);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_sp_port->ptp.hwtstamp_config = *config;\n\tmlxsw_sp_port->ptp.ing_types = ing_types;\n\tmlxsw_sp_port->ptp.egr_types = egr_types;\n\n\terr = mlxsw_sp1_ptp_port_shaper_check(mlxsw_sp_port);\n\tif (err)\n\t\treturn err;\n\n\t \n\tconfig->rx_filter = rx_filter;\n\n\treturn 0;\n}\n\nint mlxsw_sp1_ptp_get_ts_info(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct ethtool_ts_info *info)\n{\n\tinfo->phc_index = ptp_clock_index(mlxsw_sp->clock->ptp);\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF) |\n\t\t\t BIT(HWTSTAMP_TX_ON);\n\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |\n\t\t\t   BIT(HWTSTAMP_FILTER_ALL);\n\n\treturn 0;\n}\n\nstruct mlxsw_sp_ptp_port_stat {\n\tchar str[ETH_GSTRING_LEN];\n\tptrdiff_t offset;\n};\n\n#define MLXSW_SP_PTP_PORT_STAT(NAME, FIELD)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.str = NAME,\t\t\t\t\t\t\\\n\t\t.offset = offsetof(struct mlxsw_sp_ptp_port_stats,\t\\\n\t\t\t\t    FIELD),\t\t\t\t\\\n\t}\n\nstatic const struct mlxsw_sp_ptp_port_stat mlxsw_sp_ptp_port_stats[] = {\n\tMLXSW_SP_PTP_PORT_STAT(\"ptp_rx_gcd_packets\",    rx_gcd.packets),\n\tMLXSW_SP_PTP_PORT_STAT(\"ptp_rx_gcd_timestamps\", rx_gcd.timestamps),\n\tMLXSW_SP_PTP_PORT_STAT(\"ptp_tx_gcd_packets\",    tx_gcd.packets),\n\tMLXSW_SP_PTP_PORT_STAT(\"ptp_tx_gcd_timestamps\", tx_gcd.timestamps),\n};\n\n#undef MLXSW_SP_PTP_PORT_STAT\n\n#define MLXSW_SP_PTP_PORT_STATS_LEN \\\n\tARRAY_SIZE(mlxsw_sp_ptp_port_stats)\n\nint mlxsw_sp1_get_stats_count(void)\n{\n\treturn MLXSW_SP_PTP_PORT_STATS_LEN;\n}\n\nvoid mlxsw_sp1_get_stats_strings(u8 **p)\n{\n\tint i;\n\n\tfor (i = 0; i < MLXSW_SP_PTP_PORT_STATS_LEN; i++) {\n\t\tmemcpy(*p, mlxsw_sp_ptp_port_stats[i].str,\n\t\t       ETH_GSTRING_LEN);\n\t\t*p += ETH_GSTRING_LEN;\n\t}\n}\n\nvoid mlxsw_sp1_get_stats(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t u64 *data, int data_index)\n{\n\tvoid *stats = &mlxsw_sp_port->ptp.stats;\n\tptrdiff_t offset;\n\tint i;\n\n\tdata += data_index;\n\tfor (i = 0; i < MLXSW_SP_PTP_PORT_STATS_LEN; i++) {\n\t\toffset = mlxsw_sp_ptp_port_stats[i].offset;\n\t\t*data++ = *(u64 *)(stats + offset);\n\t}\n}\n\nstruct mlxsw_sp_ptp_state *mlxsw_sp2_ptp_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp2_ptp_state *ptp_state;\n\tint err;\n\n\tptp_state = kzalloc(sizeof(*ptp_state), GFP_KERNEL);\n\tif (!ptp_state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptp_state->common.mlxsw_sp = mlxsw_sp;\n\n\terr = mlxsw_sp_ptp_traps_set(mlxsw_sp);\n\tif (err)\n\t\tgoto err_ptp_traps_set;\n\n\trefcount_set(&ptp_state->ptp_port_enabled_ref, 0);\n\tmutex_init(&ptp_state->lock);\n\treturn &ptp_state->common;\n\nerr_ptp_traps_set:\n\tkfree(ptp_state);\n\treturn ERR_PTR(err);\n}\n\nvoid mlxsw_sp2_ptp_fini(struct mlxsw_sp_ptp_state *ptp_state_common)\n{\n\tstruct mlxsw_sp *mlxsw_sp = ptp_state_common->mlxsw_sp;\n\tstruct mlxsw_sp2_ptp_state *ptp_state;\n\n\tptp_state = mlxsw_sp2_ptp_state(mlxsw_sp);\n\n\tmutex_destroy(&ptp_state->lock);\n\tmlxsw_sp_ptp_traps_unset(mlxsw_sp);\n\tkfree(ptp_state);\n}\n\nstatic u32 mlxsw_ptp_utc_time_stamp_sec_get(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t    u8 cqe_ts_sec)\n{\n\tu32 utc_sec = mlxsw_core_read_utc_sec(mlxsw_core);\n\n\tif (cqe_ts_sec > (utc_sec & 0xff))\n\t\t \n\t\tutc_sec -= 256;\n\n\tutc_sec &= ~0xff;\n\tutc_sec |= cqe_ts_sec;\n\n\treturn utc_sec;\n}\n\nstatic void mlxsw_sp2_ptp_hwtstamp_fill(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\tconst struct mlxsw_skb_cb *cb,\n\t\t\t\t\tstruct skb_shared_hwtstamps *hwtstamps)\n{\n\tu64 ts_sec, ts_nsec, nsec;\n\n\tWARN_ON_ONCE(!cb->cqe_ts.sec && !cb->cqe_ts.nsec);\n\n\t \n\tts_sec = mlxsw_ptp_utc_time_stamp_sec_get(mlxsw_core, cb->cqe_ts.sec);\n\tts_nsec = cb->cqe_ts.nsec;\n\n\tnsec = ts_sec * NSEC_PER_SEC + ts_nsec;\n\n\thwtstamps->hwtstamp = ns_to_ktime(nsec);\n}\n\nvoid mlxsw_sp2_ptp_receive(struct mlxsw_sp *mlxsw_sp, struct sk_buff *skb,\n\t\t\t   u16 local_port)\n{\n\tstruct skb_shared_hwtstamps hwtstamps;\n\n\tmlxsw_sp2_ptp_hwtstamp_fill(mlxsw_sp->core, mlxsw_skb_cb(skb),\n\t\t\t\t    &hwtstamps);\n\t*skb_hwtstamps(skb) = hwtstamps;\n\tmlxsw_sp_rx_listener_no_mark_func(skb, local_port, mlxsw_sp);\n}\n\nvoid mlxsw_sp2_ptp_transmitted(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct sk_buff *skb, u16 local_port)\n{\n\tstruct skb_shared_hwtstamps hwtstamps;\n\n\tmlxsw_sp2_ptp_hwtstamp_fill(mlxsw_sp->core, mlxsw_skb_cb(skb),\n\t\t\t\t    &hwtstamps);\n\tskb_tstamp_tx(skb, &hwtstamps);\n\tdev_kfree_skb_any(skb);\n}\n\nint mlxsw_sp2_ptp_hwtstamp_get(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t       struct hwtstamp_config *config)\n{\n\tstruct mlxsw_sp2_ptp_state *ptp_state;\n\n\tptp_state = mlxsw_sp2_ptp_state(mlxsw_sp_port->mlxsw_sp);\n\n\tmutex_lock(&ptp_state->lock);\n\t*config = ptp_state->config;\n\tmutex_unlock(&ptp_state->lock);\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp2_ptp_get_message_types(const struct hwtstamp_config *config,\n\t\t\t\tu16 *p_ing_types, u16 *p_egr_types,\n\t\t\t\tenum hwtstamp_rx_filters *p_rx_filter)\n{\n\tenum hwtstamp_rx_filters rx_filter = config->rx_filter;\n\tenum hwtstamp_tx_types tx_type = config->tx_type;\n\tu16 ing_types = 0x00;\n\tu16 egr_types = 0x00;\n\n\t*p_rx_filter = rx_filter;\n\n\tswitch (rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\ting_types = 0x00;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\t\t \n\t\ting_types = 0x0f;\n\t\t*p_rx_filter = HWTSTAMP_FILTER_SOME;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_ALL:\n\tcase HWTSTAMP_FILTER_SOME:\n\tcase HWTSTAMP_FILTER_NTP_ALL:\n\t\treturn -ERANGE;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\tegr_types = 0x00;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tegr_types = 0x0f;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\tcase HWTSTAMP_TX_ONESTEP_P2P:\n\t\treturn -ERANGE;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ing_types && !egr_types) || (!ing_types && egr_types))\n\t\treturn -EINVAL;\n\n\t*p_ing_types = ing_types;\n\t*p_egr_types = egr_types;\n\treturn 0;\n}\n\nstatic int mlxsw_sp2_ptp_mtpcpc_set(struct mlxsw_sp *mlxsw_sp, bool ptp_trap_en,\n\t\t\t\t    u16 ing_types, u16 egr_types)\n{\n\tchar mtpcpc_pl[MLXSW_REG_MTPCPC_LEN];\n\n\tmlxsw_reg_mtpcpc_pack(mtpcpc_pl, false, 0, ptp_trap_en, ing_types,\n\t\t\t      egr_types);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mtpcpc), mtpcpc_pl);\n}\n\nstatic int mlxsw_sp2_ptp_enable(struct mlxsw_sp *mlxsw_sp, u16 ing_types,\n\t\t\t\tu16 egr_types,\n\t\t\t\tstruct hwtstamp_config new_config)\n{\n\tstruct mlxsw_sp2_ptp_state *ptp_state = mlxsw_sp2_ptp_state(mlxsw_sp);\n\tint err;\n\n\terr = mlxsw_sp2_ptp_mtpcpc_set(mlxsw_sp, true, ing_types, egr_types);\n\tif (err)\n\t\treturn err;\n\n\tptp_state->config = new_config;\n\treturn 0;\n}\n\nstatic int mlxsw_sp2_ptp_disable(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct hwtstamp_config new_config)\n{\n\tstruct mlxsw_sp2_ptp_state *ptp_state = mlxsw_sp2_ptp_state(mlxsw_sp);\n\tint err;\n\n\terr = mlxsw_sp2_ptp_mtpcpc_set(mlxsw_sp, false, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tptp_state->config = new_config;\n\treturn 0;\n}\n\nstatic int mlxsw_sp2_ptp_configure_port(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\tu16 ing_types, u16 egr_types,\n\t\t\t\t\tstruct hwtstamp_config new_config)\n{\n\tstruct mlxsw_sp2_ptp_state *ptp_state;\n\tint err;\n\n\tptp_state = mlxsw_sp2_ptp_state(mlxsw_sp_port->mlxsw_sp);\n\n\tif (refcount_inc_not_zero(&ptp_state->ptp_port_enabled_ref))\n\t\treturn 0;\n\n\terr = mlxsw_sp2_ptp_enable(mlxsw_sp_port->mlxsw_sp, ing_types,\n\t\t\t\t   egr_types, new_config);\n\tif (err)\n\t\treturn err;\n\n\trefcount_set(&ptp_state->ptp_port_enabled_ref, 1);\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp2_ptp_deconfigure_port(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t  struct hwtstamp_config new_config)\n{\n\tstruct mlxsw_sp2_ptp_state *ptp_state;\n\tint err;\n\n\tptp_state = mlxsw_sp2_ptp_state(mlxsw_sp_port->mlxsw_sp);\n\n\tif (!refcount_dec_and_test(&ptp_state->ptp_port_enabled_ref))\n\t\treturn 0;\n\n\terr = mlxsw_sp2_ptp_disable(mlxsw_sp_port->mlxsw_sp, new_config);\n\tif (err)\n\t\tgoto err_ptp_disable;\n\n\treturn 0;\n\nerr_ptp_disable:\n\trefcount_set(&ptp_state->ptp_port_enabled_ref, 1);\n\treturn err;\n}\n\nint mlxsw_sp2_ptp_hwtstamp_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t       struct hwtstamp_config *config)\n{\n\tstruct mlxsw_sp2_ptp_state *ptp_state;\n\tenum hwtstamp_rx_filters rx_filter;\n\tstruct hwtstamp_config new_config;\n\tu16 new_ing_types, new_egr_types;\n\tbool ptp_enabled;\n\tint err;\n\n\tptp_state = mlxsw_sp2_ptp_state(mlxsw_sp_port->mlxsw_sp);\n\tmutex_lock(&ptp_state->lock);\n\n\terr = mlxsw_sp2_ptp_get_message_types(config, &new_ing_types,\n\t\t\t\t\t      &new_egr_types, &rx_filter);\n\tif (err)\n\t\tgoto err_get_message_types;\n\n\tnew_config.flags = config->flags;\n\tnew_config.tx_type = config->tx_type;\n\tnew_config.rx_filter = rx_filter;\n\n\tptp_enabled = mlxsw_sp_port->ptp.ing_types ||\n\t\t      mlxsw_sp_port->ptp.egr_types;\n\n\tif ((new_ing_types || new_egr_types) && !ptp_enabled) {\n\t\terr = mlxsw_sp2_ptp_configure_port(mlxsw_sp_port, new_ing_types,\n\t\t\t\t\t\t   new_egr_types, new_config);\n\t\tif (err)\n\t\t\tgoto err_configure_port;\n\t} else if (!new_ing_types && !new_egr_types && ptp_enabled) {\n\t\terr = mlxsw_sp2_ptp_deconfigure_port(mlxsw_sp_port, new_config);\n\t\tif (err)\n\t\t\tgoto err_deconfigure_port;\n\t}\n\n\tmlxsw_sp_port->ptp.ing_types = new_ing_types;\n\tmlxsw_sp_port->ptp.egr_types = new_egr_types;\n\n\t \n\tconfig->rx_filter = rx_filter;\n\tmutex_unlock(&ptp_state->lock);\n\n\treturn 0;\n\nerr_deconfigure_port:\nerr_configure_port:\nerr_get_message_types:\n\tmutex_unlock(&ptp_state->lock);\n\treturn err;\n}\n\nint mlxsw_sp2_ptp_get_ts_info(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct ethtool_ts_info *info)\n{\n\tinfo->phc_index = ptp_clock_index(mlxsw_sp->clock->ptp);\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF) |\n\t\t\t BIT(HWTSTAMP_TX_ON);\n\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\n\t\t\t   BIT(HWTSTAMP_FILTER_PTP_V2_EVENT);\n\n\treturn 0;\n}\n\nint mlxsw_sp_ptp_txhdr_construct(struct mlxsw_core *mlxsw_core,\n\t\t\t\t struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t const struct mlxsw_tx_info *tx_info)\n{\n\tmlxsw_sp_txhdr_construct(skb, tx_info);\n\treturn 0;\n}\n\nint mlxsw_sp2_ptp_txhdr_construct(struct mlxsw_core *mlxsw_core,\n\t\t\t\t  struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  const struct mlxsw_tx_info *tx_info)\n{\n\t \n\tif (!skb_vlan_tagged(skb)) {\n\t\tskb = vlan_insert_tag_set_proto(skb, htons(ETH_P_8021Q),\n\t\t\t\t\t\tMLXSW_SP_DEFAULT_VID);\n\t\tif (!skb) {\n\t\t\tthis_cpu_inc(mlxsw_sp_port->pcpu_stats->tx_dropped);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn mlxsw_sp_txhdr_ptp_data_construct(mlxsw_core, mlxsw_sp_port, skb,\n\t\t\t\t\t\t tx_info);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}