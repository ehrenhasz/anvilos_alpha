{
  "module_name": "spectrum_dpipe.c",
  "hash_id": "bcb2cdf4252a192f8c005762d52c89e79265973cd5925feea4ae37549a5f9e25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_dpipe.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/mutex.h>\n#include <net/devlink.h>\n\n#include \"spectrum.h\"\n#include \"spectrum_dpipe.h\"\n#include \"spectrum_router.h\"\n\nenum mlxsw_sp_field_metadata_id {\n\tMLXSW_SP_DPIPE_FIELD_METADATA_ERIF_PORT,\n\tMLXSW_SP_DPIPE_FIELD_METADATA_L3_FORWARD,\n\tMLXSW_SP_DPIPE_FIELD_METADATA_L3_DROP,\n\tMLXSW_SP_DPIPE_FIELD_METADATA_ADJ_INDEX,\n\tMLXSW_SP_DPIPE_FIELD_METADATA_ADJ_SIZE,\n\tMLXSW_SP_DPIPE_FIELD_METADATA_ADJ_HASH_INDEX,\n};\n\nstatic struct devlink_dpipe_field mlxsw_sp_dpipe_fields_metadata[] = {\n\t{\n\t\t.name = \"erif_port\",\n\t\t.id = MLXSW_SP_DPIPE_FIELD_METADATA_ERIF_PORT,\n\t\t.bitwidth = 32,\n\t\t.mapping_type = DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX,\n\t},\n\t{\n\t\t.name = \"l3_forward\",\n\t\t.id = MLXSW_SP_DPIPE_FIELD_METADATA_L3_FORWARD,\n\t\t.bitwidth = 1,\n\t},\n\t{\n\t\t.name = \"l3_drop\",\n\t\t.id = MLXSW_SP_DPIPE_FIELD_METADATA_L3_DROP,\n\t\t.bitwidth = 1,\n\t},\n\t{\n\t\t.name = \"adj_index\",\n\t\t.id = MLXSW_SP_DPIPE_FIELD_METADATA_ADJ_INDEX,\n\t\t.bitwidth = 32,\n\t},\n\t{\n\t\t.name = \"adj_size\",\n\t\t.id = MLXSW_SP_DPIPE_FIELD_METADATA_ADJ_SIZE,\n\t\t.bitwidth = 32,\n\t},\n\t{\n\t\t.name = \"adj_hash_index\",\n\t\t.id = MLXSW_SP_DPIPE_FIELD_METADATA_ADJ_HASH_INDEX,\n\t\t.bitwidth = 32,\n\t},\n};\n\nenum mlxsw_sp_dpipe_header_id {\n\tMLXSW_SP_DPIPE_HEADER_METADATA,\n};\n\nstatic struct devlink_dpipe_header mlxsw_sp_dpipe_header_metadata = {\n\t.name = \"mlxsw_meta\",\n\t.id = MLXSW_SP_DPIPE_HEADER_METADATA,\n\t.fields = mlxsw_sp_dpipe_fields_metadata,\n\t.fields_count = ARRAY_SIZE(mlxsw_sp_dpipe_fields_metadata),\n};\n\nstatic struct devlink_dpipe_header *mlxsw_dpipe_headers[] = {\n\t&mlxsw_sp_dpipe_header_metadata,\n\t&devlink_dpipe_header_ethernet,\n\t&devlink_dpipe_header_ipv4,\n\t&devlink_dpipe_header_ipv6,\n};\n\nstatic struct devlink_dpipe_headers mlxsw_sp_dpipe_headers = {\n\t.headers = mlxsw_dpipe_headers,\n\t.headers_count = ARRAY_SIZE(mlxsw_dpipe_headers),\n};\n\nstatic int mlxsw_sp_dpipe_table_erif_actions_dump(void *priv,\n\t\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct devlink_dpipe_action action = {0};\n\tint err;\n\n\taction.type = DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY;\n\taction.header = &mlxsw_sp_dpipe_header_metadata;\n\taction.field_id = MLXSW_SP_DPIPE_FIELD_METADATA_L3_FORWARD;\n\n\terr = devlink_dpipe_action_put(skb, &action);\n\tif (err)\n\t\treturn err;\n\n\taction.type = DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY;\n\taction.header = &mlxsw_sp_dpipe_header_metadata;\n\taction.field_id = MLXSW_SP_DPIPE_FIELD_METADATA_L3_DROP;\n\n\treturn devlink_dpipe_action_put(skb, &action);\n}\n\nstatic int mlxsw_sp_dpipe_table_erif_matches_dump(void *priv,\n\t\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct devlink_dpipe_match match = {0};\n\n\tmatch.type = DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT;\n\tmatch.header = &mlxsw_sp_dpipe_header_metadata;\n\tmatch.field_id = MLXSW_SP_DPIPE_FIELD_METADATA_ERIF_PORT;\n\n\treturn devlink_dpipe_match_put(skb, &match);\n}\n\nstatic void\nmlxsw_sp_erif_match_action_prepare(struct devlink_dpipe_match *match,\n\t\t\t\t   struct devlink_dpipe_action *action)\n{\n\taction->type = DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY;\n\taction->header = &mlxsw_sp_dpipe_header_metadata;\n\taction->field_id = MLXSW_SP_DPIPE_FIELD_METADATA_L3_FORWARD;\n\n\tmatch->type = DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT;\n\tmatch->header = &mlxsw_sp_dpipe_header_metadata;\n\tmatch->field_id = MLXSW_SP_DPIPE_FIELD_METADATA_ERIF_PORT;\n}\n\nstatic int mlxsw_sp_erif_entry_prepare(struct devlink_dpipe_entry *entry,\n\t\t\t\t       struct devlink_dpipe_value *match_value,\n\t\t\t\t       struct devlink_dpipe_match *match,\n\t\t\t\t       struct devlink_dpipe_value *action_value,\n\t\t\t\t       struct devlink_dpipe_action *action)\n{\n\tentry->match_values = match_value;\n\tentry->match_values_count = 1;\n\n\tentry->action_values = action_value;\n\tentry->action_values_count = 1;\n\n\tmatch_value->match = match;\n\tmatch_value->value_size = sizeof(u32);\n\tmatch_value->value = kmalloc(match_value->value_size, GFP_KERNEL);\n\tif (!match_value->value)\n\t\treturn -ENOMEM;\n\n\taction_value->action = action;\n\taction_value->value_size = sizeof(u32);\n\taction_value->value = kmalloc(action_value->value_size, GFP_KERNEL);\n\tif (!action_value->value)\n\t\tgoto err_action_alloc;\n\treturn 0;\n\nerr_action_alloc:\n\tkfree(match_value->value);\n\treturn -ENOMEM;\n}\n\nstatic int mlxsw_sp_erif_entry_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct devlink_dpipe_entry *entry,\n\t\t\t\t   struct mlxsw_sp_rif *rif,\n\t\t\t\t   bool counters_enabled)\n{\n\tu32 *action_value;\n\tu32 *rif_value;\n\tu64 cnt;\n\tint err;\n\n\t \n\trif_value = entry->match_values->value;\n\t*rif_value = mlxsw_sp_rif_index(rif);\n\tentry->match_values->mapping_value = mlxsw_sp_rif_dev_ifindex(rif);\n\tentry->match_values->mapping_valid = true;\n\n\t \n\taction_value = entry->action_values->value;\n\t*action_value = 1;\n\n\tentry->counter_valid = false;\n\tentry->counter = 0;\n\tentry->index = mlxsw_sp_rif_index(rif);\n\n\tif (!counters_enabled)\n\t\treturn 0;\n\n\terr = mlxsw_sp_rif_counter_value_get(mlxsw_sp, rif,\n\t\t\t\t\t     MLXSW_SP_RIF_COUNTER_EGRESS,\n\t\t\t\t\t     &cnt);\n\tif (!err) {\n\t\tentry->counter = cnt;\n\t\tentry->counter_valid = true;\n\t}\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_dpipe_table_erif_entries_dump(void *priv, bool counters_enabled,\n\t\t\t\t       struct devlink_dpipe_dump_ctx *dump_ctx)\n{\n\tstruct devlink_dpipe_value match_value, action_value;\n\tstruct devlink_dpipe_action action = {0};\n\tstruct devlink_dpipe_match match = {0};\n\tstruct devlink_dpipe_entry entry = {0};\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\tunsigned int rif_count;\n\tint i, j;\n\tint err;\n\n\tmemset(&match_value, 0, sizeof(match_value));\n\tmemset(&action_value, 0, sizeof(action_value));\n\n\tmlxsw_sp_erif_match_action_prepare(&match, &action);\n\terr = mlxsw_sp_erif_entry_prepare(&entry, &match_value, &match,\n\t\t\t\t\t  &action_value, &action);\n\tif (err)\n\t\treturn err;\n\n\trif_count = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS);\n\tmutex_lock(&mlxsw_sp->router->lock);\n\ti = 0;\nstart_again:\n\terr = devlink_dpipe_entry_ctx_prepare(dump_ctx);\n\tif (err)\n\t\tgoto err_ctx_prepare;\n\tj = 0;\n\tfor (; i < rif_count; i++) {\n\t\tstruct mlxsw_sp_rif *rif = mlxsw_sp_rif_by_index(mlxsw_sp, i);\n\n\t\tif (!rif || !mlxsw_sp_rif_has_dev(rif))\n\t\t\tcontinue;\n\t\terr = mlxsw_sp_erif_entry_get(mlxsw_sp, &entry, rif,\n\t\t\t\t\t      counters_enabled);\n\t\tif (err)\n\t\t\tgoto err_entry_get;\n\t\terr = devlink_dpipe_entry_ctx_append(dump_ctx, &entry);\n\t\tif (err) {\n\t\t\tif (err == -EMSGSIZE) {\n\t\t\t\tif (!j)\n\t\t\t\t\tgoto err_entry_append;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto err_entry_append;\n\t\t}\n\t\tj++;\n\t}\n\n\tdevlink_dpipe_entry_ctx_close(dump_ctx);\n\tif (i != rif_count)\n\t\tgoto start_again;\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\n\tdevlink_dpipe_entry_clear(&entry);\n\treturn 0;\nerr_entry_append:\nerr_entry_get:\nerr_ctx_prepare:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\tdevlink_dpipe_entry_clear(&entry);\n\treturn err;\n}\n\nstatic int mlxsw_sp_dpipe_table_erif_counters_update(void *priv, bool enable)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\tint i;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\tfor (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++) {\n\t\tstruct mlxsw_sp_rif *rif = mlxsw_sp_rif_by_index(mlxsw_sp, i);\n\n\t\tif (!rif)\n\t\t\tcontinue;\n\t\tif (enable)\n\t\t\tmlxsw_sp_rif_counter_alloc(rif,\n\t\t\t\t\t\t   MLXSW_SP_RIF_COUNTER_EGRESS);\n\t\telse\n\t\t\tmlxsw_sp_rif_counter_free(rif,\n\t\t\t\t\t\t  MLXSW_SP_RIF_COUNTER_EGRESS);\n\t}\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\treturn 0;\n}\n\nstatic u64 mlxsw_sp_dpipe_table_erif_size_get(void *priv)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\treturn MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS);\n}\n\nstatic struct devlink_dpipe_table_ops mlxsw_sp_erif_ops = {\n\t.matches_dump = mlxsw_sp_dpipe_table_erif_matches_dump,\n\t.actions_dump = mlxsw_sp_dpipe_table_erif_actions_dump,\n\t.entries_dump = mlxsw_sp_dpipe_table_erif_entries_dump,\n\t.counters_set_update = mlxsw_sp_dpipe_table_erif_counters_update,\n\t.size_get = mlxsw_sp_dpipe_table_erif_size_get,\n};\n\nstatic int mlxsw_sp_dpipe_erif_table_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\n\treturn devl_dpipe_table_register(devlink,\n\t\t\t\t\t MLXSW_SP_DPIPE_TABLE_NAME_ERIF,\n\t\t\t\t\t &mlxsw_sp_erif_ops,\n\t\t\t\t\t mlxsw_sp, false);\n}\n\nstatic void mlxsw_sp_dpipe_erif_table_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\n\tdevl_dpipe_table_unregister(devlink, MLXSW_SP_DPIPE_TABLE_NAME_ERIF);\n}\n\nstatic int mlxsw_sp_dpipe_table_host_matches_dump(struct sk_buff *skb, int type)\n{\n\tstruct devlink_dpipe_match match = {0};\n\tint err;\n\n\tmatch.type = DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT;\n\tmatch.header = &mlxsw_sp_dpipe_header_metadata;\n\tmatch.field_id = MLXSW_SP_DPIPE_FIELD_METADATA_ERIF_PORT;\n\n\terr = devlink_dpipe_match_put(skb, &match);\n\tif (err)\n\t\treturn err;\n\n\tswitch (type) {\n\tcase AF_INET:\n\t\tmatch.type = DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT;\n\t\tmatch.header = &devlink_dpipe_header_ipv4;\n\t\tmatch.field_id = DEVLINK_DPIPE_FIELD_IPV4_DST_IP;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tmatch.type = DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT;\n\t\tmatch.header = &devlink_dpipe_header_ipv6;\n\t\tmatch.field_id = DEVLINK_DPIPE_FIELD_IPV6_DST_IP;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\treturn devlink_dpipe_match_put(skb, &match);\n}\n\nstatic int\nmlxsw_sp_dpipe_table_host4_matches_dump(void *priv, struct sk_buff *skb)\n{\n\treturn mlxsw_sp_dpipe_table_host_matches_dump(skb, AF_INET);\n}\n\nstatic int\nmlxsw_sp_dpipe_table_host_actions_dump(void *priv, struct sk_buff *skb)\n{\n\tstruct devlink_dpipe_action action = {0};\n\n\taction.type = DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY;\n\taction.header = &devlink_dpipe_header_ethernet;\n\taction.field_id = DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC;\n\n\treturn devlink_dpipe_action_put(skb, &action);\n}\n\nenum mlxsw_sp_dpipe_table_host_match {\n\tMLXSW_SP_DPIPE_TABLE_HOST_MATCH_RIF,\n\tMLXSW_SP_DPIPE_TABLE_HOST_MATCH_DIP,\n\tMLXSW_SP_DPIPE_TABLE_HOST_MATCH_COUNT,\n};\n\nstatic void\nmlxsw_sp_dpipe_table_host_match_action_prepare(struct devlink_dpipe_match *matches,\n\t\t\t\t\t       struct devlink_dpipe_action *action,\n\t\t\t\t\t       int type)\n{\n\tstruct devlink_dpipe_match *match;\n\n\tmatch = &matches[MLXSW_SP_DPIPE_TABLE_HOST_MATCH_RIF];\n\tmatch->type = DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT;\n\tmatch->header = &mlxsw_sp_dpipe_header_metadata;\n\tmatch->field_id = MLXSW_SP_DPIPE_FIELD_METADATA_ERIF_PORT;\n\n\tmatch = &matches[MLXSW_SP_DPIPE_TABLE_HOST_MATCH_DIP];\n\tmatch->type = DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT;\n\tswitch (type) {\n\tcase AF_INET:\n\t\tmatch->header = &devlink_dpipe_header_ipv4;\n\t\tmatch->field_id = DEVLINK_DPIPE_FIELD_IPV4_DST_IP;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tmatch->header = &devlink_dpipe_header_ipv6;\n\t\tmatch->field_id = DEVLINK_DPIPE_FIELD_IPV6_DST_IP;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\taction->type = DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY;\n\taction->header = &devlink_dpipe_header_ethernet;\n\taction->field_id = DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC;\n}\n\nstatic int\nmlxsw_sp_dpipe_table_host_entry_prepare(struct devlink_dpipe_entry *entry,\n\t\t\t\t\tstruct devlink_dpipe_value *match_values,\n\t\t\t\t\tstruct devlink_dpipe_match *matches,\n\t\t\t\t\tstruct devlink_dpipe_value *action_value,\n\t\t\t\t\tstruct devlink_dpipe_action *action,\n\t\t\t\t\tint type)\n{\n\tstruct devlink_dpipe_value *match_value;\n\tstruct devlink_dpipe_match *match;\n\n\tentry->match_values = match_values;\n\tentry->match_values_count = MLXSW_SP_DPIPE_TABLE_HOST_MATCH_COUNT;\n\n\tentry->action_values = action_value;\n\tentry->action_values_count = 1;\n\n\tmatch = &matches[MLXSW_SP_DPIPE_TABLE_HOST_MATCH_RIF];\n\tmatch_value = &match_values[MLXSW_SP_DPIPE_TABLE_HOST_MATCH_RIF];\n\n\tmatch_value->match = match;\n\tmatch_value->value_size = sizeof(u32);\n\tmatch_value->value = kmalloc(match_value->value_size, GFP_KERNEL);\n\tif (!match_value->value)\n\t\treturn -ENOMEM;\n\n\tmatch = &matches[MLXSW_SP_DPIPE_TABLE_HOST_MATCH_DIP];\n\tmatch_value = &match_values[MLXSW_SP_DPIPE_TABLE_HOST_MATCH_DIP];\n\n\tmatch_value->match = match;\n\tswitch (type) {\n\tcase AF_INET:\n\t\tmatch_value->value_size = sizeof(u32);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tmatch_value->value_size = sizeof(struct in6_addr);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tmatch_value->value = kmalloc(match_value->value_size, GFP_KERNEL);\n\tif (!match_value->value)\n\t\treturn -ENOMEM;\n\n\taction_value->action = action;\n\taction_value->value_size = sizeof(u64);\n\taction_value->value = kmalloc(action_value->value_size, GFP_KERNEL);\n\tif (!action_value->value)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void\n__mlxsw_sp_dpipe_table_host_entry_fill(struct devlink_dpipe_entry *entry,\n\t\t\t\t       struct mlxsw_sp_rif *rif,\n\t\t\t\t       unsigned char *ha, void *dip)\n{\n\tstruct devlink_dpipe_value *value;\n\tu32 *rif_value;\n\tu8 *ha_value;\n\n\t \n\tvalue = &entry->match_values[MLXSW_SP_DPIPE_TABLE_HOST_MATCH_RIF];\n\n\trif_value = value->value;\n\t*rif_value = mlxsw_sp_rif_index(rif);\n\tvalue->mapping_value = mlxsw_sp_rif_dev_ifindex(rif);\n\tvalue->mapping_valid = true;\n\n\t \n\tvalue = &entry->match_values[MLXSW_SP_DPIPE_TABLE_HOST_MATCH_DIP];\n\tmemcpy(value->value, dip, value->value_size);\n\n\t \n\tvalue = entry->action_values;\n\tha_value = value->value;\n\tether_addr_copy(ha_value, ha);\n}\n\nstatic void\nmlxsw_sp_dpipe_table_host4_entry_fill(struct devlink_dpipe_entry *entry,\n\t\t\t\t      struct mlxsw_sp_neigh_entry *neigh_entry,\n\t\t\t\t      struct mlxsw_sp_rif *rif)\n{\n\tunsigned char *ha;\n\tu32 dip;\n\n\tha = mlxsw_sp_neigh_entry_ha(neigh_entry);\n\tdip = mlxsw_sp_neigh4_entry_dip(neigh_entry);\n\t__mlxsw_sp_dpipe_table_host_entry_fill(entry, rif, ha, &dip);\n}\n\nstatic void\nmlxsw_sp_dpipe_table_host6_entry_fill(struct devlink_dpipe_entry *entry,\n\t\t\t\t      struct mlxsw_sp_neigh_entry *neigh_entry,\n\t\t\t\t      struct mlxsw_sp_rif *rif)\n{\n\tstruct in6_addr *dip;\n\tunsigned char *ha;\n\n\tha = mlxsw_sp_neigh_entry_ha(neigh_entry);\n\tdip = mlxsw_sp_neigh6_entry_dip(neigh_entry);\n\n\t__mlxsw_sp_dpipe_table_host_entry_fill(entry, rif, ha, dip);\n}\n\nstatic void\nmlxsw_sp_dpipe_table_host_entry_fill(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct devlink_dpipe_entry *entry,\n\t\t\t\t     struct mlxsw_sp_neigh_entry *neigh_entry,\n\t\t\t\t     struct mlxsw_sp_rif *rif,\n\t\t\t\t     int type)\n{\n\tint err;\n\n\tswitch (type) {\n\tcase AF_INET:\n\t\tmlxsw_sp_dpipe_table_host4_entry_fill(entry, neigh_entry, rif);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tmlxsw_sp_dpipe_table_host6_entry_fill(entry, neigh_entry, rif);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\terr = mlxsw_sp_neigh_counter_get(mlxsw_sp, neigh_entry,\n\t\t\t\t\t &entry->counter);\n\tif (!err)\n\t\tentry->counter_valid = true;\n}\n\nstatic int\nmlxsw_sp_dpipe_table_host_entries_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct devlink_dpipe_entry *entry,\n\t\t\t\t      bool counters_enabled,\n\t\t\t\t      struct devlink_dpipe_dump_ctx *dump_ctx,\n\t\t\t\t      int type)\n{\n\tint rif_neigh_count = 0;\n\tint rif_neigh_skip = 0;\n\tint neigh_count = 0;\n\tint rif_count;\n\tint i, j;\n\tint err;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\ti = 0;\n\trif_count = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS);\nstart_again:\n\terr = devlink_dpipe_entry_ctx_prepare(dump_ctx);\n\tif (err)\n\t\tgoto err_ctx_prepare;\n\tj = 0;\n\trif_neigh_skip = rif_neigh_count;\n\tfor (; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++) {\n\t\tstruct mlxsw_sp_rif *rif = mlxsw_sp_rif_by_index(mlxsw_sp, i);\n\t\tstruct mlxsw_sp_neigh_entry *neigh_entry;\n\n\t\tif (!rif)\n\t\t\tcontinue;\n\n\t\trif_neigh_count = 0;\n\t\tmlxsw_sp_rif_neigh_for_each(neigh_entry, rif) {\n\t\t\tint neigh_type = mlxsw_sp_neigh_entry_type(neigh_entry);\n\n\t\t\tif (neigh_type != type)\n\t\t\t\tcontinue;\n\n\t\t\tif (neigh_type == AF_INET6 &&\n\t\t\t    mlxsw_sp_neigh_ipv6_ignore(neigh_entry))\n\t\t\t\tcontinue;\n\n\t\t\tif (rif_neigh_count < rif_neigh_skip)\n\t\t\t\tgoto skip;\n\n\t\t\tmlxsw_sp_dpipe_table_host_entry_fill(mlxsw_sp, entry,\n\t\t\t\t\t\t\t     neigh_entry, rif,\n\t\t\t\t\t\t\t     type);\n\t\t\tentry->index = neigh_count;\n\t\t\terr = devlink_dpipe_entry_ctx_append(dump_ctx, entry);\n\t\t\tif (err) {\n\t\t\t\tif (err == -EMSGSIZE) {\n\t\t\t\t\tif (!j)\n\t\t\t\t\t\tgoto err_entry_append;\n\t\t\t\t\telse\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tgoto err_entry_append;\n\t\t\t}\n\t\t\tneigh_count++;\n\t\t\tj++;\nskip:\n\t\t\trif_neigh_count++;\n\t\t}\n\t\trif_neigh_skip = 0;\n\t}\nout:\n\tdevlink_dpipe_entry_ctx_close(dump_ctx);\n\tif (i != rif_count)\n\t\tgoto start_again;\n\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\treturn 0;\n\nerr_ctx_prepare:\nerr_entry_append:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_dpipe_table_host_entries_dump(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t       bool counters_enabled,\n\t\t\t\t       struct devlink_dpipe_dump_ctx *dump_ctx,\n\t\t\t\t       int type)\n{\n\tstruct devlink_dpipe_value match_values[MLXSW_SP_DPIPE_TABLE_HOST_MATCH_COUNT];\n\tstruct devlink_dpipe_match matches[MLXSW_SP_DPIPE_TABLE_HOST_MATCH_COUNT];\n\tstruct devlink_dpipe_value action_value;\n\tstruct devlink_dpipe_action action = {0};\n\tstruct devlink_dpipe_entry entry = {0};\n\tint err;\n\n\tmemset(matches, 0, MLXSW_SP_DPIPE_TABLE_HOST_MATCH_COUNT *\n\t\t\t   sizeof(matches[0]));\n\tmemset(match_values, 0, MLXSW_SP_DPIPE_TABLE_HOST_MATCH_COUNT *\n\t\t\t\tsizeof(match_values[0]));\n\tmemset(&action_value, 0, sizeof(action_value));\n\n\tmlxsw_sp_dpipe_table_host_match_action_prepare(matches, &action, type);\n\terr = mlxsw_sp_dpipe_table_host_entry_prepare(&entry, match_values,\n\t\t\t\t\t\t      matches, &action_value,\n\t\t\t\t\t\t      &action, type);\n\tif (err)\n\t\tgoto out;\n\n\terr = mlxsw_sp_dpipe_table_host_entries_get(mlxsw_sp, &entry,\n\t\t\t\t\t\t    counters_enabled, dump_ctx,\n\t\t\t\t\t\t    type);\nout:\n\tdevlink_dpipe_entry_clear(&entry);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_dpipe_table_host4_entries_dump(void *priv, bool counters_enabled,\n\t\t\t\t\tstruct devlink_dpipe_dump_ctx *dump_ctx)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\treturn mlxsw_sp_dpipe_table_host_entries_dump(mlxsw_sp,\n\t\t\t\t\t\t      counters_enabled,\n\t\t\t\t\t\t      dump_ctx, AF_INET);\n}\n\nstatic void\nmlxsw_sp_dpipe_table_host_counters_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  bool enable, int type)\n{\n\tint i;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\tfor (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++) {\n\t\tstruct mlxsw_sp_rif *rif = mlxsw_sp_rif_by_index(mlxsw_sp, i);\n\t\tstruct mlxsw_sp_neigh_entry *neigh_entry;\n\n\t\tif (!rif)\n\t\t\tcontinue;\n\t\tmlxsw_sp_rif_neigh_for_each(neigh_entry, rif) {\n\t\t\tint neigh_type = mlxsw_sp_neigh_entry_type(neigh_entry);\n\n\t\t\tif (neigh_type != type)\n\t\t\t\tcontinue;\n\n\t\t\tif (neigh_type == AF_INET6 &&\n\t\t\t    mlxsw_sp_neigh_ipv6_ignore(neigh_entry))\n\t\t\t\tcontinue;\n\n\t\t\tmlxsw_sp_neigh_entry_counter_update(mlxsw_sp,\n\t\t\t\t\t\t\t    neigh_entry,\n\t\t\t\t\t\t\t    enable);\n\t\t}\n\t}\n\tmutex_unlock(&mlxsw_sp->router->lock);\n}\n\nstatic int mlxsw_sp_dpipe_table_host4_counters_update(void *priv, bool enable)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\tmlxsw_sp_dpipe_table_host_counters_update(mlxsw_sp, enable, AF_INET);\n\treturn 0;\n}\n\nstatic u64\nmlxsw_sp_dpipe_table_host_size_get(struct mlxsw_sp *mlxsw_sp, int type)\n{\n\tu64 size = 0;\n\tint i;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\tfor (i = 0; i < MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_RIFS); i++) {\n\t\tstruct mlxsw_sp_rif *rif = mlxsw_sp_rif_by_index(mlxsw_sp, i);\n\t\tstruct mlxsw_sp_neigh_entry *neigh_entry;\n\n\t\tif (!rif)\n\t\t\tcontinue;\n\t\tmlxsw_sp_rif_neigh_for_each(neigh_entry, rif) {\n\t\t\tint neigh_type = mlxsw_sp_neigh_entry_type(neigh_entry);\n\n\t\t\tif (neigh_type != type)\n\t\t\t\tcontinue;\n\n\t\t\tif (neigh_type == AF_INET6 &&\n\t\t\t    mlxsw_sp_neigh_ipv6_ignore(neigh_entry))\n\t\t\t\tcontinue;\n\n\t\t\tsize++;\n\t\t}\n\t}\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\n\treturn size;\n}\n\nstatic u64 mlxsw_sp_dpipe_table_host4_size_get(void *priv)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\treturn mlxsw_sp_dpipe_table_host_size_get(mlxsw_sp, AF_INET);\n}\n\nstatic struct devlink_dpipe_table_ops mlxsw_sp_host4_ops = {\n\t.matches_dump = mlxsw_sp_dpipe_table_host4_matches_dump,\n\t.actions_dump = mlxsw_sp_dpipe_table_host_actions_dump,\n\t.entries_dump = mlxsw_sp_dpipe_table_host4_entries_dump,\n\t.counters_set_update = mlxsw_sp_dpipe_table_host4_counters_update,\n\t.size_get = mlxsw_sp_dpipe_table_host4_size_get,\n};\n\n#define MLXSW_SP_DPIPE_TABLE_RESOURCE_UNIT_HOST4 1\n\nstatic int mlxsw_sp_dpipe_host4_table_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tint err;\n\n\terr = devl_dpipe_table_register(devlink,\n\t\t\t\t\tMLXSW_SP_DPIPE_TABLE_NAME_HOST4,\n\t\t\t\t\t&mlxsw_sp_host4_ops,\n\t\t\t\t\tmlxsw_sp, false);\n\tif (err)\n\t\treturn err;\n\n\terr = devl_dpipe_table_resource_set(devlink,\n\t\t\t\t\t    MLXSW_SP_DPIPE_TABLE_NAME_HOST4,\n\t\t\t\t\t    MLXSW_SP_RESOURCE_KVD_HASH_SINGLE,\n\t\t\t\t\t    MLXSW_SP_DPIPE_TABLE_RESOURCE_UNIT_HOST4);\n\tif (err)\n\t\tgoto err_resource_set;\n\n\treturn 0;\n\nerr_resource_set:\n\tdevl_dpipe_table_unregister(devlink,\n\t\t\t\t    MLXSW_SP_DPIPE_TABLE_NAME_HOST4);\n\treturn err;\n}\n\nstatic void mlxsw_sp_dpipe_host4_table_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\n\tdevl_dpipe_table_unregister(devlink,\n\t\t\t\t    MLXSW_SP_DPIPE_TABLE_NAME_HOST4);\n}\n\nstatic int\nmlxsw_sp_dpipe_table_host6_matches_dump(void *priv, struct sk_buff *skb)\n{\n\treturn mlxsw_sp_dpipe_table_host_matches_dump(skb, AF_INET6);\n}\n\nstatic int\nmlxsw_sp_dpipe_table_host6_entries_dump(void *priv, bool counters_enabled,\n\t\t\t\t\tstruct devlink_dpipe_dump_ctx *dump_ctx)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\treturn mlxsw_sp_dpipe_table_host_entries_dump(mlxsw_sp,\n\t\t\t\t\t\t      counters_enabled,\n\t\t\t\t\t\t      dump_ctx, AF_INET6);\n}\n\nstatic int mlxsw_sp_dpipe_table_host6_counters_update(void *priv, bool enable)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\tmlxsw_sp_dpipe_table_host_counters_update(mlxsw_sp, enable, AF_INET6);\n\treturn 0;\n}\n\nstatic u64 mlxsw_sp_dpipe_table_host6_size_get(void *priv)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\treturn mlxsw_sp_dpipe_table_host_size_get(mlxsw_sp, AF_INET6);\n}\n\nstatic struct devlink_dpipe_table_ops mlxsw_sp_host6_ops = {\n\t.matches_dump = mlxsw_sp_dpipe_table_host6_matches_dump,\n\t.actions_dump = mlxsw_sp_dpipe_table_host_actions_dump,\n\t.entries_dump = mlxsw_sp_dpipe_table_host6_entries_dump,\n\t.counters_set_update = mlxsw_sp_dpipe_table_host6_counters_update,\n\t.size_get = mlxsw_sp_dpipe_table_host6_size_get,\n};\n\n#define MLXSW_SP_DPIPE_TABLE_RESOURCE_UNIT_HOST6 2\n\nstatic int mlxsw_sp_dpipe_host6_table_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tint err;\n\n\terr = devl_dpipe_table_register(devlink,\n\t\t\t\t\tMLXSW_SP_DPIPE_TABLE_NAME_HOST6,\n\t\t\t\t\t&mlxsw_sp_host6_ops,\n\t\t\t\t\tmlxsw_sp, false);\n\tif (err)\n\t\treturn err;\n\n\terr = devl_dpipe_table_resource_set(devlink,\n\t\t\t\t\t    MLXSW_SP_DPIPE_TABLE_NAME_HOST6,\n\t\t\t\t\t    MLXSW_SP_RESOURCE_KVD_HASH_DOUBLE,\n\t\t\t\t\t    MLXSW_SP_DPIPE_TABLE_RESOURCE_UNIT_HOST6);\n\tif (err)\n\t\tgoto err_resource_set;\n\n\treturn 0;\n\nerr_resource_set:\n\tdevl_dpipe_table_unregister(devlink,\n\t\t\t\t    MLXSW_SP_DPIPE_TABLE_NAME_HOST6);\n\treturn err;\n}\n\nstatic void mlxsw_sp_dpipe_host6_table_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\n\tdevl_dpipe_table_unregister(devlink,\n\t\t\t\t    MLXSW_SP_DPIPE_TABLE_NAME_HOST6);\n}\n\nstatic int mlxsw_sp_dpipe_table_adj_matches_dump(void *priv,\n\t\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct devlink_dpipe_match match = {0};\n\tint err;\n\n\tmatch.type = DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT;\n\tmatch.header = &mlxsw_sp_dpipe_header_metadata;\n\tmatch.field_id = MLXSW_SP_DPIPE_FIELD_METADATA_ADJ_INDEX;\n\n\terr = devlink_dpipe_match_put(skb, &match);\n\tif (err)\n\t\treturn err;\n\n\tmatch.type = DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT;\n\tmatch.header = &mlxsw_sp_dpipe_header_metadata;\n\tmatch.field_id = MLXSW_SP_DPIPE_FIELD_METADATA_ADJ_SIZE;\n\n\terr = devlink_dpipe_match_put(skb, &match);\n\tif (err)\n\t\treturn err;\n\n\tmatch.type = DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT;\n\tmatch.header = &mlxsw_sp_dpipe_header_metadata;\n\tmatch.field_id = MLXSW_SP_DPIPE_FIELD_METADATA_ADJ_HASH_INDEX;\n\n\treturn devlink_dpipe_match_put(skb, &match);\n}\n\nstatic int mlxsw_sp_dpipe_table_adj_actions_dump(void *priv,\n\t\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct devlink_dpipe_action action = {0};\n\tint err;\n\n\taction.type = DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY;\n\taction.header = &devlink_dpipe_header_ethernet;\n\taction.field_id = DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC;\n\n\terr = devlink_dpipe_action_put(skb, &action);\n\tif (err)\n\t\treturn err;\n\n\taction.type = DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY;\n\taction.header = &mlxsw_sp_dpipe_header_metadata;\n\taction.field_id = MLXSW_SP_DPIPE_FIELD_METADATA_ERIF_PORT;\n\n\treturn devlink_dpipe_action_put(skb, &action);\n}\n\nstatic u64 mlxsw_sp_dpipe_table_adj_size(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_nexthop *nh;\n\tu64 size = 0;\n\n\tmlxsw_sp_nexthop_for_each(nh, mlxsw_sp->router)\n\t\tif (mlxsw_sp_nexthop_is_forward(nh) &&\n\t\t    !mlxsw_sp_nexthop_group_has_ipip(nh))\n\t\t\tsize++;\n\treturn size;\n}\n\nenum mlxsw_sp_dpipe_table_adj_match {\n\tMLXSW_SP_DPIPE_TABLE_ADJ_MATCH_INDEX,\n\tMLXSW_SP_DPIPE_TABLE_ADJ_MATCH_SIZE,\n\tMLXSW_SP_DPIPE_TABLE_ADJ_MATCH_HASH_INDEX,\n\tMLXSW_SP_DPIPE_TABLE_ADJ_MATCH_COUNT,\n};\n\nenum mlxsw_sp_dpipe_table_adj_action {\n\tMLXSW_SP_DPIPE_TABLE_ADJ_ACTION_DST_MAC,\n\tMLXSW_SP_DPIPE_TABLE_ADJ_ACTION_ERIF_PORT,\n\tMLXSW_SP_DPIPE_TABLE_ADJ_ACTION_COUNT,\n};\n\nstatic void\nmlxsw_sp_dpipe_table_adj_match_action_prepare(struct devlink_dpipe_match *matches,\n\t\t\t\t\t      struct devlink_dpipe_action *actions)\n{\n\tstruct devlink_dpipe_action *action;\n\tstruct devlink_dpipe_match *match;\n\n\tmatch = &matches[MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_INDEX];\n\tmatch->type = DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT;\n\tmatch->header = &mlxsw_sp_dpipe_header_metadata;\n\tmatch->field_id = MLXSW_SP_DPIPE_FIELD_METADATA_ADJ_INDEX;\n\n\tmatch = &matches[MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_SIZE];\n\tmatch->type = DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT;\n\tmatch->header = &mlxsw_sp_dpipe_header_metadata;\n\tmatch->field_id = MLXSW_SP_DPIPE_FIELD_METADATA_ADJ_SIZE;\n\n\tmatch = &matches[MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_HASH_INDEX];\n\tmatch->type = DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT;\n\tmatch->header = &mlxsw_sp_dpipe_header_metadata;\n\tmatch->field_id = MLXSW_SP_DPIPE_FIELD_METADATA_ADJ_HASH_INDEX;\n\n\taction = &actions[MLXSW_SP_DPIPE_TABLE_ADJ_ACTION_DST_MAC];\n\taction->type = DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY;\n\taction->header = &devlink_dpipe_header_ethernet;\n\taction->field_id = DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC;\n\n\taction = &actions[MLXSW_SP_DPIPE_TABLE_ADJ_ACTION_ERIF_PORT];\n\taction->type = DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY;\n\taction->header = &mlxsw_sp_dpipe_header_metadata;\n\taction->field_id = MLXSW_SP_DPIPE_FIELD_METADATA_ERIF_PORT;\n}\n\nstatic int\nmlxsw_sp_dpipe_table_adj_entry_prepare(struct devlink_dpipe_entry *entry,\n\t\t\t\t       struct devlink_dpipe_value *match_values,\n\t\t\t\t       struct devlink_dpipe_match *matches,\n\t\t\t\t       struct devlink_dpipe_value *action_values,\n\t\t\t\t       struct devlink_dpipe_action *actions)\n{\tstruct devlink_dpipe_value *action_value;\n\tstruct devlink_dpipe_value *match_value;\n\tstruct devlink_dpipe_action *action;\n\tstruct devlink_dpipe_match *match;\n\n\tentry->match_values = match_values;\n\tentry->match_values_count = MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_COUNT;\n\n\tentry->action_values = action_values;\n\tentry->action_values_count = MLXSW_SP_DPIPE_TABLE_ADJ_ACTION_COUNT;\n\n\tmatch = &matches[MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_INDEX];\n\tmatch_value = &match_values[MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_INDEX];\n\n\tmatch_value->match = match;\n\tmatch_value->value_size = sizeof(u32);\n\tmatch_value->value = kmalloc(match_value->value_size, GFP_KERNEL);\n\tif (!match_value->value)\n\t\treturn -ENOMEM;\n\n\tmatch = &matches[MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_SIZE];\n\tmatch_value = &match_values[MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_SIZE];\n\n\tmatch_value->match = match;\n\tmatch_value->value_size = sizeof(u32);\n\tmatch_value->value = kmalloc(match_value->value_size, GFP_KERNEL);\n\tif (!match_value->value)\n\t\treturn -ENOMEM;\n\n\tmatch = &matches[MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_HASH_INDEX];\n\tmatch_value = &match_values[MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_HASH_INDEX];\n\n\tmatch_value->match = match;\n\tmatch_value->value_size = sizeof(u32);\n\tmatch_value->value = kmalloc(match_value->value_size, GFP_KERNEL);\n\tif (!match_value->value)\n\t\treturn -ENOMEM;\n\n\taction = &actions[MLXSW_SP_DPIPE_TABLE_ADJ_ACTION_DST_MAC];\n\taction_value = &action_values[MLXSW_SP_DPIPE_TABLE_ADJ_ACTION_DST_MAC];\n\n\taction_value->action = action;\n\taction_value->value_size = sizeof(u64);\n\taction_value->value = kmalloc(action_value->value_size, GFP_KERNEL);\n\tif (!action_value->value)\n\t\treturn -ENOMEM;\n\n\taction = &actions[MLXSW_SP_DPIPE_TABLE_ADJ_ACTION_ERIF_PORT];\n\taction_value = &action_values[MLXSW_SP_DPIPE_TABLE_ADJ_ACTION_ERIF_PORT];\n\n\taction_value->action = action;\n\taction_value->value_size = sizeof(u32);\n\taction_value->value = kmalloc(action_value->value_size, GFP_KERNEL);\n\tif (!action_value->value)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void\n__mlxsw_sp_dpipe_table_adj_entry_fill(struct devlink_dpipe_entry *entry,\n\t\t\t\t      u32 adj_index, u32 adj_size,\n\t\t\t\t      u32 adj_hash_index, unsigned char *ha,\n\t\t\t\t      struct mlxsw_sp_rif *rif)\n{\n\tstruct devlink_dpipe_value *value;\n\tu32 *p_rif_value;\n\tu32 *p_index;\n\n\tvalue = &entry->match_values[MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_INDEX];\n\tp_index = value->value;\n\t*p_index = adj_index;\n\n\tvalue = &entry->match_values[MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_SIZE];\n\tp_index = value->value;\n\t*p_index = adj_size;\n\n\tvalue = &entry->match_values[MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_HASH_INDEX];\n\tp_index = value->value;\n\t*p_index = adj_hash_index;\n\n\tvalue = &entry->action_values[MLXSW_SP_DPIPE_TABLE_ADJ_ACTION_DST_MAC];\n\tether_addr_copy(value->value, ha);\n\n\tvalue = &entry->action_values[MLXSW_SP_DPIPE_TABLE_ADJ_ACTION_ERIF_PORT];\n\tp_rif_value = value->value;\n\t*p_rif_value = mlxsw_sp_rif_index(rif);\n\tvalue->mapping_value = mlxsw_sp_rif_dev_ifindex(rif);\n\tvalue->mapping_valid = true;\n}\n\nstatic void mlxsw_sp_dpipe_table_adj_entry_fill(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tstruct mlxsw_sp_nexthop *nh,\n\t\t\t\t\t\tstruct devlink_dpipe_entry *entry)\n{\n\tstruct mlxsw_sp_rif *rif = mlxsw_sp_nexthop_rif(nh);\n\tunsigned char *ha = mlxsw_sp_nexthop_ha(nh);\n\tu32 adj_hash_index = 0;\n\tu32 adj_index = 0;\n\tu32 adj_size = 0;\n\tint err;\n\n\tmlxsw_sp_nexthop_indexes(nh, &adj_index, &adj_size, &adj_hash_index);\n\t__mlxsw_sp_dpipe_table_adj_entry_fill(entry, adj_index, adj_size,\n\t\t\t\t\t      adj_hash_index, ha, rif);\n\terr = mlxsw_sp_nexthop_counter_get(mlxsw_sp, nh, &entry->counter);\n\tif (!err)\n\t\tentry->counter_valid = true;\n}\n\nstatic int\nmlxsw_sp_dpipe_table_adj_entries_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct devlink_dpipe_entry *entry,\n\t\t\t\t     bool counters_enabled,\n\t\t\t\t     struct devlink_dpipe_dump_ctx *dump_ctx)\n{\n\tstruct mlxsw_sp_nexthop *nh;\n\tint entry_index = 0;\n\tint nh_count_max;\n\tint nh_count = 0;\n\tint nh_skip;\n\tint j;\n\tint err;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\tnh_count_max = mlxsw_sp_dpipe_table_adj_size(mlxsw_sp);\nstart_again:\n\terr = devlink_dpipe_entry_ctx_prepare(dump_ctx);\n\tif (err)\n\t\tgoto err_ctx_prepare;\n\tj = 0;\n\tnh_skip = nh_count;\n\tnh_count = 0;\n\tmlxsw_sp_nexthop_for_each(nh, mlxsw_sp->router) {\n\t\tif (!mlxsw_sp_nexthop_is_forward(nh) ||\n\t\t    mlxsw_sp_nexthop_group_has_ipip(nh))\n\t\t\tcontinue;\n\n\t\tif (nh_count < nh_skip)\n\t\t\tgoto skip;\n\n\t\tmlxsw_sp_dpipe_table_adj_entry_fill(mlxsw_sp, nh, entry);\n\t\tentry->index = entry_index;\n\t\terr = devlink_dpipe_entry_ctx_append(dump_ctx, entry);\n\t\tif (err) {\n\t\t\tif (err == -EMSGSIZE) {\n\t\t\t\tif (!j)\n\t\t\t\t\tgoto err_entry_append;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto err_entry_append;\n\t\t}\n\t\tentry_index++;\n\t\tj++;\nskip:\n\t\tnh_count++;\n\t}\n\n\tdevlink_dpipe_entry_ctx_close(dump_ctx);\n\tif (nh_count != nh_count_max)\n\t\tgoto start_again;\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\n\treturn 0;\n\nerr_ctx_prepare:\nerr_entry_append:\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_dpipe_table_adj_entries_dump(void *priv, bool counters_enabled,\n\t\t\t\t      struct devlink_dpipe_dump_ctx *dump_ctx)\n{\n\tstruct devlink_dpipe_value action_values[MLXSW_SP_DPIPE_TABLE_ADJ_ACTION_COUNT];\n\tstruct devlink_dpipe_value match_values[MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_COUNT];\n\tstruct devlink_dpipe_action actions[MLXSW_SP_DPIPE_TABLE_ADJ_ACTION_COUNT];\n\tstruct devlink_dpipe_match matches[MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_COUNT];\n\tstruct devlink_dpipe_entry entry = {0};\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\tint err;\n\n\tmemset(matches, 0, MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_COUNT *\n\t\t\t   sizeof(matches[0]));\n\tmemset(match_values, 0, MLXSW_SP_DPIPE_TABLE_ADJ_MATCH_COUNT *\n\t\t\t\tsizeof(match_values[0]));\n\tmemset(actions, 0, MLXSW_SP_DPIPE_TABLE_ADJ_ACTION_COUNT *\n\t\t\t   sizeof(actions[0]));\n\tmemset(action_values, 0, MLXSW_SP_DPIPE_TABLE_ADJ_ACTION_COUNT *\n\t\t\t\t sizeof(action_values[0]));\n\n\tmlxsw_sp_dpipe_table_adj_match_action_prepare(matches, actions);\n\terr = mlxsw_sp_dpipe_table_adj_entry_prepare(&entry,\n\t\t\t\t\t\t     match_values, matches,\n\t\t\t\t\t\t     action_values, actions);\n\tif (err)\n\t\tgoto out;\n\n\terr = mlxsw_sp_dpipe_table_adj_entries_get(mlxsw_sp, &entry,\n\t\t\t\t\t\t   counters_enabled, dump_ctx);\nout:\n\tdevlink_dpipe_entry_clear(&entry);\n\treturn err;\n}\n\nstatic int mlxsw_sp_dpipe_table_adj_counters_update(void *priv, bool enable)\n{\n\tchar ratr_pl[MLXSW_REG_RATR_LEN];\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\tstruct mlxsw_sp_nexthop *nh;\n\tu32 adj_hash_index = 0;\n\tu32 adj_index = 0;\n\tu32 adj_size = 0;\n\n\tmlxsw_sp_nexthop_for_each(nh, mlxsw_sp->router) {\n\t\tif (!mlxsw_sp_nexthop_is_forward(nh) ||\n\t\t    mlxsw_sp_nexthop_group_has_ipip(nh))\n\t\t\tcontinue;\n\n\t\tmlxsw_sp_nexthop_indexes(nh, &adj_index, &adj_size,\n\t\t\t\t\t &adj_hash_index);\n\t\tif (enable)\n\t\t\tmlxsw_sp_nexthop_counter_alloc(mlxsw_sp, nh);\n\t\telse\n\t\t\tmlxsw_sp_nexthop_counter_free(mlxsw_sp, nh);\n\t\tmlxsw_sp_nexthop_eth_update(mlxsw_sp,\n\t\t\t\t\t    adj_index + adj_hash_index, nh,\n\t\t\t\t\t    true, ratr_pl);\n\t}\n\treturn 0;\n}\n\nstatic u64\nmlxsw_sp_dpipe_table_adj_size_get(void *priv)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\tu64 size;\n\n\tmutex_lock(&mlxsw_sp->router->lock);\n\tsize = mlxsw_sp_dpipe_table_adj_size(mlxsw_sp);\n\tmutex_unlock(&mlxsw_sp->router->lock);\n\n\treturn size;\n}\n\nstatic struct devlink_dpipe_table_ops mlxsw_sp_dpipe_table_adj_ops = {\n\t.matches_dump = mlxsw_sp_dpipe_table_adj_matches_dump,\n\t.actions_dump = mlxsw_sp_dpipe_table_adj_actions_dump,\n\t.entries_dump = mlxsw_sp_dpipe_table_adj_entries_dump,\n\t.counters_set_update = mlxsw_sp_dpipe_table_adj_counters_update,\n\t.size_get = mlxsw_sp_dpipe_table_adj_size_get,\n};\n\n#define MLXSW_SP_DPIPE_TABLE_RESOURCE_UNIT_ADJ 1\n\nstatic int mlxsw_sp_dpipe_adj_table_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tint err;\n\n\terr = devl_dpipe_table_register(devlink,\n\t\t\t\t\tMLXSW_SP_DPIPE_TABLE_NAME_ADJ,\n\t\t\t\t\t&mlxsw_sp_dpipe_table_adj_ops,\n\t\t\t\t\tmlxsw_sp, false);\n\tif (err)\n\t\treturn err;\n\n\terr = devl_dpipe_table_resource_set(devlink,\n\t\t\t\t\t    MLXSW_SP_DPIPE_TABLE_NAME_ADJ,\n\t\t\t\t\t    MLXSW_SP_RESOURCE_KVD_LINEAR,\n\t\t\t\t\t    MLXSW_SP_DPIPE_TABLE_RESOURCE_UNIT_ADJ);\n\tif (err)\n\t\tgoto err_resource_set;\n\n\treturn 0;\n\nerr_resource_set:\n\tdevl_dpipe_table_unregister(devlink,\n\t\t\t\t    MLXSW_SP_DPIPE_TABLE_NAME_ADJ);\n\treturn err;\n}\n\nstatic void mlxsw_sp_dpipe_adj_table_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\n\tdevl_dpipe_table_unregister(devlink,\n\t\t\t\t    MLXSW_SP_DPIPE_TABLE_NAME_ADJ);\n}\n\nint mlxsw_sp_dpipe_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tint err;\n\n\tdevl_dpipe_headers_register(devlink, &mlxsw_sp_dpipe_headers);\n\n\terr = mlxsw_sp_dpipe_erif_table_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_erif_table_init;\n\n\terr = mlxsw_sp_dpipe_host4_table_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_host4_table_init;\n\n\terr = mlxsw_sp_dpipe_host6_table_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_host6_table_init;\n\n\terr = mlxsw_sp_dpipe_adj_table_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_adj_table_init;\n\n\treturn 0;\nerr_adj_table_init:\n\tmlxsw_sp_dpipe_host6_table_fini(mlxsw_sp);\nerr_host6_table_init:\n\tmlxsw_sp_dpipe_host4_table_fini(mlxsw_sp);\nerr_host4_table_init:\n\tmlxsw_sp_dpipe_erif_table_fini(mlxsw_sp);\nerr_erif_table_init:\n\tdevl_dpipe_headers_unregister(priv_to_devlink(mlxsw_sp->core));\n\treturn err;\n}\n\nvoid mlxsw_sp_dpipe_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\n\tmlxsw_sp_dpipe_adj_table_fini(mlxsw_sp);\n\tmlxsw_sp_dpipe_host6_table_fini(mlxsw_sp);\n\tmlxsw_sp_dpipe_host4_table_fini(mlxsw_sp);\n\tmlxsw_sp_dpipe_erif_table_fini(mlxsw_sp);\n\tdevl_dpipe_headers_unregister(devlink);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}