{
  "module_name": "minimal.c",
  "hash_id": "0e70b8e1a15cc7c7dba3013ed4b5c56669854ee8ff6cb66b9553cacf89b7ce45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/minimal.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/types.h>\n\n#include \"core.h\"\n#include \"core_env.h\"\n#include \"i2c.h\"\n\nstatic const char mlxsw_m_driver_name[] = \"mlxsw_minimal\";\n\n#define MLXSW_M_FWREV_MINOR\t2000\n#define MLXSW_M_FWREV_SUBMINOR\t1886\n\nstatic const struct mlxsw_fw_rev mlxsw_m_fw_rev = {\n\t.minor = MLXSW_M_FWREV_MINOR,\n\t.subminor = MLXSW_M_FWREV_SUBMINOR,\n};\n\nstruct mlxsw_m_port;\n\nstruct mlxsw_m_line_card {\n\tbool active;\n\tint module_to_port[];\n};\n\nstruct mlxsw_m {\n\tstruct mlxsw_m_port **ports;\n\tstruct mlxsw_core *core;\n\tconst struct mlxsw_bus_info *bus_info;\n\tu8 base_mac[ETH_ALEN];\n\tu8 max_ports;\n\tu8 max_modules_per_slot;  \n\tu8 num_of_slots;  \n\tstruct mlxsw_m_line_card **line_cards;\n};\n\nstruct mlxsw_m_port {\n\tstruct net_device *dev;\n\tstruct mlxsw_m *mlxsw_m;\n\tu16 local_port;\n\tu8 slot_index;\n\tu8 module;\n\tu8 module_offset;\n};\n\nstatic int mlxsw_m_base_mac_get(struct mlxsw_m *mlxsw_m)\n{\n\tchar spad_pl[MLXSW_REG_SPAD_LEN] = {0};\n\tint err;\n\n\terr = mlxsw_reg_query(mlxsw_m->core, MLXSW_REG(spad), spad_pl);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_spad_base_mac_memcpy_from(spad_pl, mlxsw_m->base_mac);\n\treturn 0;\n}\n\nstatic int mlxsw_m_port_open(struct net_device *dev)\n{\n\tstruct mlxsw_m_port *mlxsw_m_port = netdev_priv(dev);\n\tstruct mlxsw_m *mlxsw_m = mlxsw_m_port->mlxsw_m;\n\n\treturn mlxsw_env_module_port_up(mlxsw_m->core, 0,\n\t\t\t\t\tmlxsw_m_port->module);\n}\n\nstatic int mlxsw_m_port_stop(struct net_device *dev)\n{\n\tstruct mlxsw_m_port *mlxsw_m_port = netdev_priv(dev);\n\tstruct mlxsw_m *mlxsw_m = mlxsw_m_port->mlxsw_m;\n\n\tmlxsw_env_module_port_down(mlxsw_m->core, 0, mlxsw_m_port->module);\n\treturn 0;\n}\n\nstatic const struct net_device_ops mlxsw_m_port_netdev_ops = {\n\t.ndo_open\t\t= mlxsw_m_port_open,\n\t.ndo_stop\t\t= mlxsw_m_port_stop,\n};\n\nstatic void mlxsw_m_module_get_drvinfo(struct net_device *dev,\n\t\t\t\t       struct ethtool_drvinfo *drvinfo)\n{\n\tstruct mlxsw_m_port *mlxsw_m_port = netdev_priv(dev);\n\tstruct mlxsw_m *mlxsw_m = mlxsw_m_port->mlxsw_m;\n\n\tstrscpy(drvinfo->driver, mlxsw_m->bus_info->device_kind,\n\t\tsizeof(drvinfo->driver));\n\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t \"%d.%d.%d\",\n\t\t mlxsw_m->bus_info->fw_rev.major,\n\t\t mlxsw_m->bus_info->fw_rev.minor,\n\t\t mlxsw_m->bus_info->fw_rev.subminor);\n\tstrscpy(drvinfo->bus_info, mlxsw_m->bus_info->device_name,\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic int mlxsw_m_get_module_info(struct net_device *netdev,\n\t\t\t\t   struct ethtool_modinfo *modinfo)\n{\n\tstruct mlxsw_m_port *mlxsw_m_port = netdev_priv(netdev);\n\tstruct mlxsw_core *core = mlxsw_m_port->mlxsw_m->core;\n\n\treturn mlxsw_env_get_module_info(netdev, core,\n\t\t\t\t\t mlxsw_m_port->slot_index,\n\t\t\t\t\t mlxsw_m_port->module, modinfo);\n}\n\nstatic int\nmlxsw_m_get_module_eeprom(struct net_device *netdev, struct ethtool_eeprom *ee,\n\t\t\t  u8 *data)\n{\n\tstruct mlxsw_m_port *mlxsw_m_port = netdev_priv(netdev);\n\tstruct mlxsw_core *core = mlxsw_m_port->mlxsw_m->core;\n\n\treturn mlxsw_env_get_module_eeprom(netdev, core,\n\t\t\t\t\t   mlxsw_m_port->slot_index,\n\t\t\t\t\t   mlxsw_m_port->module, ee, data);\n}\n\nstatic int\nmlxsw_m_get_module_eeprom_by_page(struct net_device *netdev,\n\t\t\t\t  const struct ethtool_module_eeprom *page,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_m_port *mlxsw_m_port = netdev_priv(netdev);\n\tstruct mlxsw_core *core = mlxsw_m_port->mlxsw_m->core;\n\n\treturn mlxsw_env_get_module_eeprom_by_page(core,\n\t\t\t\t\t\t   mlxsw_m_port->slot_index,\n\t\t\t\t\t\t   mlxsw_m_port->module,\n\t\t\t\t\t\t   page, extack);\n}\n\nstatic int mlxsw_m_reset(struct net_device *netdev, u32 *flags)\n{\n\tstruct mlxsw_m_port *mlxsw_m_port = netdev_priv(netdev);\n\tstruct mlxsw_core *core = mlxsw_m_port->mlxsw_m->core;\n\n\treturn mlxsw_env_reset_module(netdev, core, mlxsw_m_port->slot_index,\n\t\t\t\t      mlxsw_m_port->module,\n\t\t\t\t      flags);\n}\n\nstatic int\nmlxsw_m_get_module_power_mode(struct net_device *netdev,\n\t\t\t      struct ethtool_module_power_mode_params *params,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_m_port *mlxsw_m_port = netdev_priv(netdev);\n\tstruct mlxsw_core *core = mlxsw_m_port->mlxsw_m->core;\n\n\treturn mlxsw_env_get_module_power_mode(core, mlxsw_m_port->slot_index,\n\t\t\t\t\t       mlxsw_m_port->module,\n\t\t\t\t\t       params, extack);\n}\n\nstatic int\nmlxsw_m_set_module_power_mode(struct net_device *netdev,\n\t\t\t      const struct ethtool_module_power_mode_params *params,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_m_port *mlxsw_m_port = netdev_priv(netdev);\n\tstruct mlxsw_core *core = mlxsw_m_port->mlxsw_m->core;\n\n\treturn mlxsw_env_set_module_power_mode(core, mlxsw_m_port->slot_index,\n\t\t\t\t\t       mlxsw_m_port->module,\n\t\t\t\t\t       params->policy, extack);\n}\n\nstatic const struct ethtool_ops mlxsw_m_port_ethtool_ops = {\n\t.get_drvinfo\t\t= mlxsw_m_module_get_drvinfo,\n\t.get_module_info\t= mlxsw_m_get_module_info,\n\t.get_module_eeprom\t= mlxsw_m_get_module_eeprom,\n\t.get_module_eeprom_by_page = mlxsw_m_get_module_eeprom_by_page,\n\t.reset\t\t\t= mlxsw_m_reset,\n\t.get_module_power_mode\t= mlxsw_m_get_module_power_mode,\n\t.set_module_power_mode\t= mlxsw_m_set_module_power_mode,\n};\n\nstatic int\nmlxsw_m_port_module_info_get(struct mlxsw_m *mlxsw_m, u16 local_port,\n\t\t\t     u8 *p_module, u8 *p_width, u8 *p_slot_index)\n{\n\tchar pmlp_pl[MLXSW_REG_PMLP_LEN];\n\tint err;\n\n\tmlxsw_reg_pmlp_pack(pmlp_pl, local_port);\n\terr = mlxsw_reg_query(mlxsw_m->core, MLXSW_REG(pmlp), pmlp_pl);\n\tif (err)\n\t\treturn err;\n\t*p_module = mlxsw_reg_pmlp_module_get(pmlp_pl, 0);\n\t*p_width = mlxsw_reg_pmlp_width_get(pmlp_pl);\n\t*p_slot_index = mlxsw_reg_pmlp_slot_index_get(pmlp_pl, 0);\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_m_port_dev_addr_get(struct mlxsw_m_port *mlxsw_m_port)\n{\n\tstruct mlxsw_m *mlxsw_m = mlxsw_m_port->mlxsw_m;\n\tchar ppad_pl[MLXSW_REG_PPAD_LEN];\n\tu8 addr[ETH_ALEN];\n\tint err;\n\n\tmlxsw_reg_ppad_pack(ppad_pl, false, 0);\n\terr = mlxsw_reg_query(mlxsw_m->core, MLXSW_REG(ppad), ppad_pl);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_ppad_mac_memcpy_from(ppad_pl, addr);\n\teth_hw_addr_gen(mlxsw_m_port->dev, addr, mlxsw_m_port->module + 1 +\n\t\t\tmlxsw_m_port->module_offset);\n\treturn 0;\n}\n\nstatic bool mlxsw_m_port_created(struct mlxsw_m *mlxsw_m, u16 local_port)\n{\n\treturn mlxsw_m->ports[local_port];\n}\n\nstatic int\nmlxsw_m_port_create(struct mlxsw_m *mlxsw_m, u16 local_port, u8 slot_index,\n\t\t    u8 module)\n{\n\tstruct mlxsw_m_port *mlxsw_m_port;\n\tstruct net_device *dev;\n\tint err;\n\n\terr = mlxsw_core_port_init(mlxsw_m->core, local_port, slot_index,\n\t\t\t\t   module + 1, false, 0, false,\n\t\t\t\t   0, mlxsw_m->base_mac,\n\t\t\t\t   sizeof(mlxsw_m->base_mac));\n\tif (err) {\n\t\tdev_err(mlxsw_m->bus_info->dev, \"Port %d: Failed to init core port\\n\",\n\t\t\tlocal_port);\n\t\treturn err;\n\t}\n\n\tdev = alloc_etherdev(sizeof(struct mlxsw_m_port));\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_etherdev;\n\t}\n\n\tSET_NETDEV_DEV(dev, mlxsw_m->bus_info->dev);\n\tdev_net_set(dev, mlxsw_core_net(mlxsw_m->core));\n\tmlxsw_m_port = netdev_priv(dev);\n\tmlxsw_core_port_netdev_link(mlxsw_m->core, local_port,\n\t\t\t\t    mlxsw_m_port, dev);\n\tmlxsw_m_port->dev = dev;\n\tmlxsw_m_port->mlxsw_m = mlxsw_m;\n\tmlxsw_m_port->local_port = local_port;\n\tmlxsw_m_port->module = module;\n\tmlxsw_m_port->slot_index = slot_index;\n\t \n\tmlxsw_m_port->module_offset = mlxsw_m_port->slot_index ?\n\t\t\t\t      (mlxsw_m_port->slot_index - 1) *\n\t\t\t\t      mlxsw_m->max_modules_per_slot : 0;\n\n\tdev->netdev_ops = &mlxsw_m_port_netdev_ops;\n\tdev->ethtool_ops = &mlxsw_m_port_ethtool_ops;\n\n\terr = mlxsw_m_port_dev_addr_get(mlxsw_m_port);\n\tif (err) {\n\t\tdev_err(mlxsw_m->bus_info->dev, \"Port %d: Unable to get port mac address\\n\",\n\t\t\tmlxsw_m_port->local_port);\n\t\tgoto err_dev_addr_get;\n\t}\n\n\tnetif_carrier_off(dev);\n\tmlxsw_m->ports[local_port] = mlxsw_m_port;\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(mlxsw_m->bus_info->dev, \"Port %d: Failed to register netdev\\n\",\n\t\t\tmlxsw_m_port->local_port);\n\t\tgoto err_register_netdev;\n\t}\n\n\treturn 0;\n\nerr_register_netdev:\n\tmlxsw_m->ports[local_port] = NULL;\nerr_dev_addr_get:\n\tfree_netdev(dev);\nerr_alloc_etherdev:\n\tmlxsw_core_port_fini(mlxsw_m->core, local_port);\n\treturn err;\n}\n\nstatic void mlxsw_m_port_remove(struct mlxsw_m *mlxsw_m, u16 local_port)\n{\n\tstruct mlxsw_m_port *mlxsw_m_port = mlxsw_m->ports[local_port];\n\n\tunregister_netdev(mlxsw_m_port->dev);  \n\tmlxsw_m->ports[local_port] = NULL;\n\tfree_netdev(mlxsw_m_port->dev);\n\tmlxsw_core_port_fini(mlxsw_m->core, local_port);\n}\n\nstatic int*\nmlxsw_m_port_mapping_get(struct mlxsw_m *mlxsw_m, u8 slot_index, u8 module)\n{\n\treturn &mlxsw_m->line_cards[slot_index]->module_to_port[module];\n}\n\nstatic int mlxsw_m_port_module_map(struct mlxsw_m *mlxsw_m, u16 local_port,\n\t\t\t\t   u8 *last_module)\n{\n\tunsigned int max_ports = mlxsw_core_max_ports(mlxsw_m->core);\n\tu8 module, width, slot_index;\n\tint *module_to_port;\n\tint err;\n\n\t \n\terr = mlxsw_m_port_module_info_get(mlxsw_m, local_port, &module,\n\t\t\t\t\t   &width, &slot_index);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (mlxsw_m->line_cards[slot_index]->active)\n\t\treturn 0;\n\tif (!width)\n\t\treturn 0;\n\t \n\tif (module == *last_module)\n\t\treturn 0;\n\t*last_module = module;\n\n\tif (WARN_ON_ONCE(module >= max_ports))\n\t\treturn -EINVAL;\n\tmlxsw_env_module_port_map(mlxsw_m->core, slot_index, module);\n\tmodule_to_port = mlxsw_m_port_mapping_get(mlxsw_m, slot_index, module);\n\t*module_to_port = local_port;\n\n\treturn 0;\n}\n\nstatic void\nmlxsw_m_port_module_unmap(struct mlxsw_m *mlxsw_m, u8 slot_index, u8 module)\n{\n\tint *module_to_port = mlxsw_m_port_mapping_get(mlxsw_m, slot_index,\n\t\t\t\t\t\t       module);\n\t*module_to_port = -1;\n\tmlxsw_env_module_port_unmap(mlxsw_m->core, slot_index, module);\n}\n\nstatic int mlxsw_m_linecards_init(struct mlxsw_m *mlxsw_m)\n{\n\tunsigned int max_ports = mlxsw_core_max_ports(mlxsw_m->core);\n\tchar mgpir_pl[MLXSW_REG_MGPIR_LEN];\n\tu8 num_of_modules;\n\tint i, j, err;\n\n\tmlxsw_reg_mgpir_pack(mgpir_pl, 0);\n\terr = mlxsw_reg_query(mlxsw_m->core, MLXSW_REG(mgpir), mgpir_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mgpir_unpack(mgpir_pl, NULL, NULL, NULL, &num_of_modules,\n\t\t\t       &mlxsw_m->num_of_slots);\n\t \n\tif (mlxsw_m->num_of_slots)\n\t\tmlxsw_m->max_modules_per_slot =\n\t\t\tmlxsw_reg_mgpir_max_modules_per_slot_get(mgpir_pl);\n\telse\n\t\tmlxsw_m->max_modules_per_slot = num_of_modules;\n\t \n\tmlxsw_m->num_of_slots += 1;\n\n\tmlxsw_m->ports = kcalloc(max_ports, sizeof(*mlxsw_m->ports),\n\t\t\t\t GFP_KERNEL);\n\tif (!mlxsw_m->ports)\n\t\treturn -ENOMEM;\n\n\tmlxsw_m->line_cards = kcalloc(mlxsw_m->num_of_slots,\n\t\t\t\t      sizeof(*mlxsw_m->line_cards),\n\t\t\t\t      GFP_KERNEL);\n\tif (!mlxsw_m->line_cards) {\n\t\terr = -ENOMEM;\n\t\tgoto err_kcalloc;\n\t}\n\n\tfor (i = 0; i < mlxsw_m->num_of_slots; i++) {\n\t\tmlxsw_m->line_cards[i] =\n\t\t\tkzalloc(struct_size(mlxsw_m->line_cards[i],\n\t\t\t\t\t    module_to_port,\n\t\t\t\t\t    mlxsw_m->max_modules_per_slot),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!mlxsw_m->line_cards[i]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_kmalloc_array;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < mlxsw_m->max_modules_per_slot; j++)\n\t\t\tmlxsw_m->line_cards[i]->module_to_port[j] = -1;\n\t}\n\n\treturn 0;\n\nerr_kmalloc_array:\n\tfor (i--; i >= 0; i--)\n\t\tkfree(mlxsw_m->line_cards[i]);\n\tkfree(mlxsw_m->line_cards);\nerr_kcalloc:\n\tkfree(mlxsw_m->ports);\n\treturn err;\n}\n\nstatic void mlxsw_m_linecards_fini(struct mlxsw_m *mlxsw_m)\n{\n\tint i = mlxsw_m->num_of_slots;\n\n\tfor (i--; i >= 0; i--)\n\t\tkfree(mlxsw_m->line_cards[i]);\n\tkfree(mlxsw_m->line_cards);\n\tkfree(mlxsw_m->ports);\n}\n\nstatic void\nmlxsw_m_linecard_port_module_unmap(struct mlxsw_m *mlxsw_m, u8 slot_index)\n{\n\tint i;\n\n\tfor (i = mlxsw_m->max_modules_per_slot - 1; i >= 0; i--) {\n\t\tint *module_to_port;\n\n\t\tmodule_to_port = mlxsw_m_port_mapping_get(mlxsw_m, slot_index, i);\n\t\tif (*module_to_port > 0)\n\t\t\tmlxsw_m_port_module_unmap(mlxsw_m, slot_index, i);\n\t}\n}\n\nstatic int\nmlxsw_m_linecard_ports_create(struct mlxsw_m *mlxsw_m, u8 slot_index)\n{\n\tint *module_to_port;\n\tint i, err;\n\n\tfor (i = 0; i < mlxsw_m->max_modules_per_slot; i++) {\n\t\tmodule_to_port = mlxsw_m_port_mapping_get(mlxsw_m, slot_index, i);\n\t\tif (*module_to_port > 0) {\n\t\t\terr = mlxsw_m_port_create(mlxsw_m, *module_to_port,\n\t\t\t\t\t\t  slot_index, i);\n\t\t\tif (err)\n\t\t\t\tgoto err_port_create;\n\t\t\t \n\t\t\tif (!mlxsw_m->line_cards[slot_index]->active)\n\t\t\t\tmlxsw_m->line_cards[slot_index]->active = true;\n\t\t}\n\t}\n\treturn 0;\n\nerr_port_create:\n\tfor (i--; i >= 0; i--) {\n\t\tmodule_to_port = mlxsw_m_port_mapping_get(mlxsw_m, slot_index, i);\n\t\tif (*module_to_port > 0 &&\n\t\t    mlxsw_m_port_created(mlxsw_m, *module_to_port)) {\n\t\t\tmlxsw_m_port_remove(mlxsw_m, *module_to_port);\n\t\t\t \n\t\t\tif (mlxsw_m->line_cards[slot_index]->active)\n\t\t\t\tmlxsw_m->line_cards[slot_index]->active = false;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic void\nmlxsw_m_linecard_ports_remove(struct mlxsw_m *mlxsw_m, u8 slot_index)\n{\n\tint i;\n\n\tfor (i = 0; i < mlxsw_m->max_modules_per_slot; i++) {\n\t\tint *module_to_port = mlxsw_m_port_mapping_get(mlxsw_m,\n\t\t\t\t\t\t\t       slot_index, i);\n\n\t\tif (*module_to_port > 0 &&\n\t\t    mlxsw_m_port_created(mlxsw_m, *module_to_port)) {\n\t\t\tmlxsw_m_port_remove(mlxsw_m, *module_to_port);\n\t\t\tmlxsw_m_port_module_unmap(mlxsw_m, slot_index, i);\n\t\t}\n\t}\n}\n\nstatic int mlxsw_m_ports_module_map(struct mlxsw_m *mlxsw_m)\n{\n\tunsigned int max_ports = mlxsw_core_max_ports(mlxsw_m->core);\n\tu8 last_module = max_ports;\n\tint i, err;\n\n\tfor (i = 1; i < max_ports; i++) {\n\t\terr = mlxsw_m_port_module_map(mlxsw_m, i, &last_module);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_m_ports_create(struct mlxsw_m *mlxsw_m)\n{\n\tint err;\n\n\t \n\terr = mlxsw_m_ports_module_map(mlxsw_m);\n\tif (err)\n\t\tgoto err_ports_module_map;\n\n\t \n\terr = mlxsw_m_linecard_ports_create(mlxsw_m, 0);\n\tif (err)\n\t\tgoto err_linecard_ports_create;\n\n\treturn 0;\n\nerr_linecard_ports_create:\nerr_ports_module_map:\n\tmlxsw_m_linecard_port_module_unmap(mlxsw_m, 0);\n\n\treturn err;\n}\n\nstatic void mlxsw_m_ports_remove(struct mlxsw_m *mlxsw_m)\n{\n\tmlxsw_m_linecard_ports_remove(mlxsw_m, 0);\n}\n\nstatic void\nmlxsw_m_ports_remove_selected(struct mlxsw_core *mlxsw_core,\n\t\t\t      bool (*selector)(void *priv, u16 local_port),\n\t\t\t      void *priv)\n{\n\tstruct mlxsw_m *mlxsw_m = mlxsw_core_driver_priv(mlxsw_core);\n\tstruct mlxsw_linecard *linecard_priv = priv;\n\tstruct mlxsw_m_line_card *linecard;\n\n\tlinecard = mlxsw_m->line_cards[linecard_priv->slot_index];\n\n\tif (WARN_ON(!linecard->active))\n\t\treturn;\n\n\tmlxsw_m_linecard_ports_remove(mlxsw_m, linecard_priv->slot_index);\n\tlinecard->active = false;\n}\n\nstatic int mlxsw_m_fw_rev_validate(struct mlxsw_m *mlxsw_m)\n{\n\tconst struct mlxsw_fw_rev *rev = &mlxsw_m->bus_info->fw_rev;\n\n\t \n\tif (mlxsw_core_fw_rev_minor_subminor_validate(rev, &mlxsw_m_fw_rev))\n\t\treturn 0;\n\n\tdev_err(mlxsw_m->bus_info->dev, \"The firmware version %d.%d.%d is incompatible with the driver (required >= %d.%d.%d)\\n\",\n\t\trev->major, rev->minor, rev->subminor, rev->major,\n\t\tmlxsw_m_fw_rev.minor, mlxsw_m_fw_rev.subminor);\n\n\treturn -EINVAL;\n}\n\nstatic void\nmlxsw_m_got_active(struct mlxsw_core *mlxsw_core, u8 slot_index, void *priv)\n{\n\tstruct mlxsw_m_line_card *linecard;\n\tstruct mlxsw_m *mlxsw_m = priv;\n\tint err;\n\n\tlinecard = mlxsw_m->line_cards[slot_index];\n\t \n\tif (linecard->active)\n\t\treturn;\n\n\t \n\terr = mlxsw_m_ports_module_map(mlxsw_m);\n\tif (err)\n\t\tgoto err_ports_module_map;\n\n\t \n\terr = mlxsw_m_linecard_ports_create(mlxsw_m, slot_index);\n\tif (err) {\n\t\tdev_err(mlxsw_m->bus_info->dev, \"Failed to create port for line card at slot %d\\n\",\n\t\t\tslot_index);\n\t\tgoto err_linecard_ports_create;\n\t}\n\n\tlinecard->active = true;\n\n\treturn;\n\nerr_linecard_ports_create:\nerr_ports_module_map:\n\tmlxsw_m_linecard_port_module_unmap(mlxsw_m, slot_index);\n}\n\nstatic void\nmlxsw_m_got_inactive(struct mlxsw_core *mlxsw_core, u8 slot_index, void *priv)\n{\n\tstruct mlxsw_m_line_card *linecard;\n\tstruct mlxsw_m *mlxsw_m = priv;\n\n\tlinecard = mlxsw_m->line_cards[slot_index];\n\n\tif (WARN_ON(!linecard->active))\n\t\treturn;\n\n\tmlxsw_m_linecard_ports_remove(mlxsw_m, slot_index);\n\tlinecard->active = false;\n}\n\nstatic struct mlxsw_linecards_event_ops mlxsw_m_event_ops = {\n\t.got_active = mlxsw_m_got_active,\n\t.got_inactive = mlxsw_m_got_inactive,\n};\n\nstatic int mlxsw_m_init(struct mlxsw_core *mlxsw_core,\n\t\t\tconst struct mlxsw_bus_info *mlxsw_bus_info,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_m *mlxsw_m = mlxsw_core_driver_priv(mlxsw_core);\n\tint err;\n\n\tmlxsw_m->core = mlxsw_core;\n\tmlxsw_m->bus_info = mlxsw_bus_info;\n\n\terr = mlxsw_m_fw_rev_validate(mlxsw_m);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_m_base_mac_get(mlxsw_m);\n\tif (err) {\n\t\tdev_err(mlxsw_m->bus_info->dev, \"Failed to get base mac\\n\");\n\t\treturn err;\n\t}\n\n\terr = mlxsw_m_linecards_init(mlxsw_m);\n\tif (err) {\n\t\tdev_err(mlxsw_m->bus_info->dev, \"Failed to create line cards\\n\");\n\t\treturn err;\n\t}\n\n\terr = mlxsw_linecards_event_ops_register(mlxsw_core,\n\t\t\t\t\t\t &mlxsw_m_event_ops, mlxsw_m);\n\tif (err) {\n\t\tdev_err(mlxsw_m->bus_info->dev, \"Failed to register line cards operations\\n\");\n\t\tgoto linecards_event_ops_register;\n\t}\n\n\terr = mlxsw_m_ports_create(mlxsw_m);\n\tif (err) {\n\t\tdev_err(mlxsw_m->bus_info->dev, \"Failed to create ports\\n\");\n\t\tgoto err_ports_create;\n\t}\n\n\treturn 0;\n\nerr_ports_create:\n\tmlxsw_linecards_event_ops_unregister(mlxsw_core,\n\t\t\t\t\t     &mlxsw_m_event_ops, mlxsw_m);\nlinecards_event_ops_register:\n\tmlxsw_m_linecards_fini(mlxsw_m);\n\treturn err;\n}\n\nstatic void mlxsw_m_fini(struct mlxsw_core *mlxsw_core)\n{\n\tstruct mlxsw_m *mlxsw_m = mlxsw_core_driver_priv(mlxsw_core);\n\n\tmlxsw_m_ports_remove(mlxsw_m);\n\tmlxsw_linecards_event_ops_unregister(mlxsw_core,\n\t\t\t\t\t     &mlxsw_m_event_ops, mlxsw_m);\n\tmlxsw_m_linecards_fini(mlxsw_m);\n}\n\nstatic const struct mlxsw_config_profile mlxsw_m_config_profile;\n\nstatic struct mlxsw_driver mlxsw_m_driver = {\n\t.kind\t\t\t= mlxsw_m_driver_name,\n\t.priv_size\t\t= sizeof(struct mlxsw_m),\n\t.init\t\t\t= mlxsw_m_init,\n\t.fini\t\t\t= mlxsw_m_fini,\n\t.ports_remove_selected\t= mlxsw_m_ports_remove_selected,\n\t.profile\t\t= &mlxsw_m_config_profile,\n};\n\nstatic const struct i2c_device_id mlxsw_m_i2c_id[] = {\n\t{ \"mlxsw_minimal\", 0},\n\t{ },\n};\n\nstatic struct i2c_driver mlxsw_m_i2c_driver = {\n\t.driver.name = \"mlxsw_minimal\",\n\t.class = I2C_CLASS_HWMON,\n\t.id_table = mlxsw_m_i2c_id,\n};\n\nstatic int __init mlxsw_m_module_init(void)\n{\n\tint err;\n\n\terr = mlxsw_core_driver_register(&mlxsw_m_driver);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_i2c_driver_register(&mlxsw_m_i2c_driver);\n\tif (err)\n\t\tgoto err_i2c_driver_register;\n\n\treturn 0;\n\nerr_i2c_driver_register:\n\tmlxsw_core_driver_unregister(&mlxsw_m_driver);\n\n\treturn err;\n}\n\nstatic void __exit mlxsw_m_module_exit(void)\n{\n\tmlxsw_i2c_driver_unregister(&mlxsw_m_i2c_driver);\n\tmlxsw_core_driver_unregister(&mlxsw_m_driver);\n}\n\nmodule_init(mlxsw_m_module_init);\nmodule_exit(mlxsw_m_module_exit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Vadim Pasternak <vadimp@mellanox.com>\");\nMODULE_DESCRIPTION(\"Mellanox minimal driver\");\nMODULE_DEVICE_TABLE(i2c, mlxsw_m_i2c_id);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}