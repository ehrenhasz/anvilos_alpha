{
  "module_name": "spectrum_acl_flex_actions.c",
  "hash_id": "428bf47647bfbc52a2818fc34d31173321c9853ed4002f5209c8d26e7d5932b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_flex_actions.c",
  "human_readable_source": "\n \n\n#include \"spectrum_acl_flex_actions.h\"\n#include \"core_acl_flex_actions.h\"\n#include \"spectrum_span.h\"\n\nstatic int mlxsw_sp_act_kvdl_set_add(void *priv, u32 *p_kvdl_index,\n\t\t\t\t     char *enc_actions, bool is_first, bool ca)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\tchar pefa_pl[MLXSW_REG_PEFA_LEN];\n\tu32 kvdl_index;\n\tint err;\n\n\t \n\tif (is_first)\n\t\treturn 0;\n\n\terr = mlxsw_sp_kvdl_alloc(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ACTSET,\n\t\t\t\t  1, &kvdl_index);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_pefa_pack(pefa_pl, kvdl_index, ca, enc_actions);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pefa), pefa_pl);\n\tif (err)\n\t\tgoto err_pefa_write;\n\t*p_kvdl_index = kvdl_index;\n\treturn 0;\n\nerr_pefa_write:\n\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ACTSET,\n\t\t\t   1, kvdl_index);\n\treturn err;\n}\n\nstatic int mlxsw_sp1_act_kvdl_set_add(void *priv, u32 *p_kvdl_index,\n\t\t\t\t      char *enc_actions, bool is_first)\n{\n\treturn mlxsw_sp_act_kvdl_set_add(priv, p_kvdl_index, enc_actions,\n\t\t\t\t\t is_first, false);\n}\n\nstatic int mlxsw_sp2_act_kvdl_set_add(void *priv, u32 *p_kvdl_index,\n\t\t\t\t      char *enc_actions, bool is_first)\n{\n\treturn mlxsw_sp_act_kvdl_set_add(priv, p_kvdl_index, enc_actions,\n\t\t\t\t\t is_first, true);\n}\n\nstatic void mlxsw_sp_act_kvdl_set_del(void *priv, u32 kvdl_index,\n\t\t\t\t      bool is_first)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\tif (is_first)\n\t\treturn;\n\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_ACTSET,\n\t\t\t   1, kvdl_index);\n}\n\nstatic int mlxsw_sp1_act_kvdl_set_activity_get(void *priv, u32 kvdl_index,\n\t\t\t\t\t       bool *activity)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mlxsw_sp2_act_kvdl_set_activity_get(void *priv, u32 kvdl_index,\n\t\t\t\t\t       bool *activity)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\tchar pefa_pl[MLXSW_REG_PEFA_LEN];\n\tint err;\n\n\tmlxsw_reg_pefa_pack(pefa_pl, kvdl_index, true, NULL);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(pefa), pefa_pl);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_pefa_unpack(pefa_pl, activity);\n\treturn 0;\n}\n\nstatic int mlxsw_sp_act_kvdl_fwd_entry_add(void *priv, u32 *p_kvdl_index,\n\t\t\t\t\t   u16 local_port)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\tchar ppbs_pl[MLXSW_REG_PPBS_LEN];\n\tu32 kvdl_index;\n\tint err;\n\n\terr = mlxsw_sp_kvdl_alloc(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_PBS,\n\t\t\t\t  1, &kvdl_index);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_ppbs_pack(ppbs_pl, kvdl_index, local_port);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(ppbs), ppbs_pl);\n\tif (err)\n\t\tgoto err_ppbs_write;\n\t*p_kvdl_index = kvdl_index;\n\treturn 0;\n\nerr_ppbs_write:\n\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_PBS,\n\t\t\t   1, kvdl_index);\n\treturn err;\n}\n\nstatic void mlxsw_sp_act_kvdl_fwd_entry_del(void *priv, u32 kvdl_index)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\tmlxsw_sp_kvdl_free(mlxsw_sp, MLXSW_SP_KVDL_ENTRY_TYPE_PBS,\n\t\t\t   1, kvdl_index);\n}\n\nstatic int\nmlxsw_sp_act_counter_index_get(void *priv, unsigned int *p_counter_index)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\treturn mlxsw_sp_flow_counter_alloc(mlxsw_sp, p_counter_index);\n}\n\nstatic void\nmlxsw_sp_act_counter_index_put(void *priv, unsigned int counter_index)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\tmlxsw_sp_flow_counter_free(mlxsw_sp, counter_index);\n}\n\nstatic int\nmlxsw_sp_act_mirror_add(void *priv, u16 local_in_port,\n\t\t\tconst struct net_device *out_dev,\n\t\t\tbool ingress, int *p_span_id)\n{\n\tstruct mlxsw_sp_span_agent_parms agent_parms = {};\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\tint err;\n\n\tagent_parms.to_dev = out_dev;\n\terr = mlxsw_sp_span_agent_get(mlxsw_sp, p_span_id, &agent_parms);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_sp_port = mlxsw_sp->ports[local_in_port];\n\terr = mlxsw_sp_span_analyzed_port_get(mlxsw_sp_port, ingress);\n\tif (err)\n\t\tgoto err_analyzed_port_get;\n\n\treturn 0;\n\nerr_analyzed_port_get:\n\tmlxsw_sp_span_agent_put(mlxsw_sp, *p_span_id);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_act_mirror_del(void *priv, u16 local_in_port, int span_id, bool ingress)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\tmlxsw_sp_port = mlxsw_sp->ports[local_in_port];\n\tmlxsw_sp_span_analyzed_port_put(mlxsw_sp_port, ingress);\n\tmlxsw_sp_span_agent_put(mlxsw_sp, span_id);\n}\n\nstatic int mlxsw_sp_act_policer_add(void *priv, u64 rate_bytes_ps, u32 burst,\n\t\t\t\t    u16 *p_policer_index,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_policer_params params;\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\tparams.rate = rate_bytes_ps;\n\tparams.burst = burst;\n\tparams.bytes = true;\n\treturn mlxsw_sp_policer_add(mlxsw_sp,\n\t\t\t\t    MLXSW_SP_POLICER_TYPE_SINGLE_RATE,\n\t\t\t\t    &params, extack, p_policer_index);\n}\n\nstatic void mlxsw_sp_act_policer_del(void *priv, u16 policer_index)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\tmlxsw_sp_policer_del(mlxsw_sp, MLXSW_SP_POLICER_TYPE_SINGLE_RATE,\n\t\t\t     policer_index);\n}\n\nstatic int mlxsw_sp1_act_sampler_add(void *priv, u16 local_port,\n\t\t\t\t     struct psample_group *psample_group,\n\t\t\t\t     u32 rate, u32 trunc_size, bool truncate,\n\t\t\t\t     bool ingress, int *p_span_id,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tNL_SET_ERR_MSG_MOD(extack, \"Sampling action is not supported on Spectrum-1\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic void mlxsw_sp1_act_sampler_del(void *priv, u16 local_port, int span_id,\n\t\t\t\t      bool ingress)\n{\n\tWARN_ON_ONCE(1);\n}\n\nconst struct mlxsw_afa_ops mlxsw_sp1_act_afa_ops = {\n\t.kvdl_set_add\t\t= mlxsw_sp1_act_kvdl_set_add,\n\t.kvdl_set_del\t\t= mlxsw_sp_act_kvdl_set_del,\n\t.kvdl_set_activity_get\t= mlxsw_sp1_act_kvdl_set_activity_get,\n\t.kvdl_fwd_entry_add\t= mlxsw_sp_act_kvdl_fwd_entry_add,\n\t.kvdl_fwd_entry_del\t= mlxsw_sp_act_kvdl_fwd_entry_del,\n\t.counter_index_get\t= mlxsw_sp_act_counter_index_get,\n\t.counter_index_put\t= mlxsw_sp_act_counter_index_put,\n\t.mirror_add\t\t= mlxsw_sp_act_mirror_add,\n\t.mirror_del\t\t= mlxsw_sp_act_mirror_del,\n\t.policer_add\t\t= mlxsw_sp_act_policer_add,\n\t.policer_del\t\t= mlxsw_sp_act_policer_del,\n\t.sampler_add\t\t= mlxsw_sp1_act_sampler_add,\n\t.sampler_del\t\t= mlxsw_sp1_act_sampler_del,\n};\n\nstatic int mlxsw_sp2_act_sampler_add(void *priv, u16 local_port,\n\t\t\t\t     struct psample_group *psample_group,\n\t\t\t\t     u32 rate, u32 trunc_size, bool truncate,\n\t\t\t\t     bool ingress, int *p_span_id,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_span_agent_parms agent_parms = {\n\t\t.session_id = MLXSW_SP_SPAN_SESSION_ID_SAMPLING,\n\t};\n\tstruct mlxsw_sp_sample_trigger trigger = {\n\t\t.type = MLXSW_SP_SAMPLE_TRIGGER_TYPE_POLICY_ENGINE,\n\t};\n\tstruct mlxsw_sp_sample_params params;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\tint err;\n\n\tparams.psample_group = psample_group;\n\tparams.trunc_size = trunc_size;\n\tparams.rate = rate;\n\tparams.truncate = truncate;\n\terr = mlxsw_sp_sample_trigger_params_set(mlxsw_sp, &trigger, &params,\n\t\t\t\t\t\t extack);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_span_agent_get(mlxsw_sp, p_span_id, &agent_parms);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to get SPAN agent\");\n\t\tgoto err_span_agent_get;\n\t}\n\n\tmlxsw_sp_port = mlxsw_sp->ports[local_port];\n\terr = mlxsw_sp_span_analyzed_port_get(mlxsw_sp_port, ingress);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to get analyzed port\");\n\t\tgoto err_analyzed_port_get;\n\t}\n\n\treturn 0;\n\nerr_analyzed_port_get:\n\tmlxsw_sp_span_agent_put(mlxsw_sp, *p_span_id);\nerr_span_agent_get:\n\tmlxsw_sp_sample_trigger_params_unset(mlxsw_sp, &trigger);\n\treturn err;\n}\n\nstatic void mlxsw_sp2_act_sampler_del(void *priv, u16 local_port, int span_id,\n\t\t\t\t      bool ingress)\n{\n\tstruct mlxsw_sp_sample_trigger trigger = {\n\t\t.type = MLXSW_SP_SAMPLE_TRIGGER_TYPE_POLICY_ENGINE,\n\t};\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tstruct mlxsw_sp *mlxsw_sp = priv;\n\n\tmlxsw_sp_port = mlxsw_sp->ports[local_port];\n\tmlxsw_sp_span_analyzed_port_put(mlxsw_sp_port, ingress);\n\tmlxsw_sp_span_agent_put(mlxsw_sp, span_id);\n\tmlxsw_sp_sample_trigger_params_unset(mlxsw_sp, &trigger);\n}\n\nconst struct mlxsw_afa_ops mlxsw_sp2_act_afa_ops = {\n\t.kvdl_set_add\t\t= mlxsw_sp2_act_kvdl_set_add,\n\t.kvdl_set_del\t\t= mlxsw_sp_act_kvdl_set_del,\n\t.kvdl_set_activity_get\t= mlxsw_sp2_act_kvdl_set_activity_get,\n\t.kvdl_fwd_entry_add\t= mlxsw_sp_act_kvdl_fwd_entry_add,\n\t.kvdl_fwd_entry_del\t= mlxsw_sp_act_kvdl_fwd_entry_del,\n\t.counter_index_get\t= mlxsw_sp_act_counter_index_get,\n\t.counter_index_put\t= mlxsw_sp_act_counter_index_put,\n\t.mirror_add\t\t= mlxsw_sp_act_mirror_add,\n\t.mirror_del\t\t= mlxsw_sp_act_mirror_del,\n\t.policer_add\t\t= mlxsw_sp_act_policer_add,\n\t.policer_del\t\t= mlxsw_sp_act_policer_del,\n\t.sampler_add\t\t= mlxsw_sp2_act_sampler_add,\n\t.sampler_del\t\t= mlxsw_sp2_act_sampler_del,\n\t.dummy_first_set\t= true,\n};\n\nint mlxsw_sp_afa_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tmlxsw_sp->afa = mlxsw_afa_create(MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t\t\t\t    ACL_ACTIONS_PER_SET),\n\t\t\t\t\t mlxsw_sp->afa_ops, mlxsw_sp);\n\treturn PTR_ERR_OR_ZERO(mlxsw_sp->afa);\n}\n\nvoid mlxsw_sp_afa_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tmlxsw_afa_destroy(mlxsw_sp->afa);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}