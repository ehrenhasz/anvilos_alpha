{
  "module_name": "spectrum2_kvdl.c",
  "hash_id": "59eedc524259cb71984735f5cd0dcb67be5bdda751daeb125297ab9f169337b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum2_kvdl.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n\n#include \"spectrum.h\"\n#include \"core.h\"\n#include \"reg.h\"\n#include \"resources.h\"\n\nstruct mlxsw_sp2_kvdl_part_info {\n\tu8 res_type;\n\t \n\tenum mlxsw_res_id usage_bit_count_res_id;\n\tenum mlxsw_res_id index_range_res_id;\n};\n\n#define MLXSW_SP2_KVDL_PART_INFO(_entry_type, _res_type,\t\t\t\\\n\t\t\t\t _usage_bit_count_res_id, _index_range_res_id)\t\\\n[MLXSW_SP_KVDL_ENTRY_TYPE_##_entry_type] = {\t\t\t\t\t\\\n\t.res_type = _res_type,\t\t\t\t\t\t\t\\\n\t.usage_bit_count_res_id = MLXSW_RES_ID_##_usage_bit_count_res_id,\t\\\n\t.index_range_res_id = MLXSW_RES_ID_##_index_range_res_id,\t\t\\\n}\n\nstatic const struct mlxsw_sp2_kvdl_part_info mlxsw_sp2_kvdl_parts_info[] = {\n\tMLXSW_SP2_KVDL_PART_INFO(ADJ, 0x21, KVD_SIZE, MAX_KVD_LINEAR_RANGE),\n\tMLXSW_SP2_KVDL_PART_INFO(ACTSET, 0x23, MAX_KVD_ACTION_SETS,\n\t\t\t\t MAX_KVD_ACTION_SETS),\n\tMLXSW_SP2_KVDL_PART_INFO(PBS, 0x24, KVD_SIZE, KVD_SIZE),\n\tMLXSW_SP2_KVDL_PART_INFO(MCRIGR, 0x26, KVD_SIZE, KVD_SIZE),\n\tMLXSW_SP2_KVDL_PART_INFO(IPV6_ADDRESS, 0x28, KVD_SIZE, KVD_SIZE),\n\tMLXSW_SP2_KVDL_PART_INFO(TNUMT, 0x29, KVD_SIZE, KVD_SIZE),\n};\n\n#define MLXSW_SP2_KVDL_PARTS_INFO_LEN ARRAY_SIZE(mlxsw_sp2_kvdl_parts_info)\n\nstruct mlxsw_sp2_kvdl_part {\n\tconst struct mlxsw_sp2_kvdl_part_info *info;\n\tunsigned int usage_bit_count;\n\tunsigned int indexes_per_usage_bit;\n\tunsigned int last_allocated_bit;\n\tunsigned long usage[];\t \n};\n\nstruct mlxsw_sp2_kvdl {\n\tstruct mlxsw_sp2_kvdl_part *parts[MLXSW_SP2_KVDL_PARTS_INFO_LEN];\n};\n\nstatic int mlxsw_sp2_kvdl_part_find_zero_bits(struct mlxsw_sp2_kvdl_part *part,\n\t\t\t\t\t      unsigned int bit_count,\n\t\t\t\t\t      unsigned int *p_bit)\n{\n\tunsigned int start_bit;\n\tunsigned int bit;\n\tunsigned int i;\n\tbool wrap = false;\n\n\tstart_bit = part->last_allocated_bit + 1;\n\tif (start_bit == part->usage_bit_count)\n\t\tstart_bit = 0;\n\tbit = start_bit;\nagain:\n\tbit = find_next_zero_bit(part->usage, part->usage_bit_count, bit);\n\tif (!wrap && bit + bit_count >= part->usage_bit_count) {\n\t\twrap = true;\n\t\tbit = 0;\n\t\tgoto again;\n\t}\n\tif (wrap && bit + bit_count >= start_bit)\n\t\treturn -ENOBUFS;\n\tfor (i = 0; i < bit_count; i++) {\n\t\tif (test_bit(bit + i, part->usage)) {\n\t\t\tbit += bit_count;\n\t\t\tgoto again;\n\t\t}\n\t}\n\t*p_bit = bit;\n\treturn 0;\n}\n\nstatic int mlxsw_sp2_kvdl_part_alloc(struct mlxsw_sp2_kvdl_part *part,\n\t\t\t\t     unsigned int size,\n\t\t\t\t     u32 *p_kvdl_index)\n{\n\tunsigned int bit_count;\n\tunsigned int bit;\n\tunsigned int i;\n\tint err;\n\n\tbit_count = DIV_ROUND_UP(size, part->indexes_per_usage_bit);\n\terr = mlxsw_sp2_kvdl_part_find_zero_bits(part, bit_count, &bit);\n\tif (err)\n\t\treturn err;\n\tfor (i = 0; i < bit_count; i++)\n\t\t__set_bit(bit + i, part->usage);\n\t*p_kvdl_index = bit * part->indexes_per_usage_bit;\n\treturn 0;\n}\n\nstatic int mlxsw_sp2_kvdl_rec_del(struct mlxsw_sp *mlxsw_sp, u8 res_type,\n\t\t\t\t  u16 size, u32 kvdl_index)\n{\n\tchar *iedr_pl;\n\tint err;\n\n\tiedr_pl = kmalloc(MLXSW_REG_IEDR_LEN, GFP_KERNEL);\n\tif (!iedr_pl)\n\t\treturn -ENOMEM;\n\n\tmlxsw_reg_iedr_pack(iedr_pl);\n\tmlxsw_reg_iedr_rec_pack(iedr_pl, 0, res_type, size, kvdl_index);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(iedr), iedr_pl);\n\tkfree(iedr_pl);\n\treturn err;\n}\n\nstatic void mlxsw_sp2_kvdl_part_free(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp2_kvdl_part *part,\n\t\t\t\t     unsigned int size, u32 kvdl_index)\n{\n\tunsigned int bit_count;\n\tunsigned int bit;\n\tunsigned int i;\n\tint err;\n\n\t \n\terr = mlxsw_sp2_kvdl_rec_del(mlxsw_sp, part->info->res_type,\n\t\t\t\t     size, kvdl_index);\n\tif (err)\n\t\treturn;\n\n\tbit_count = DIV_ROUND_UP(size, part->indexes_per_usage_bit);\n\tbit = kvdl_index / part->indexes_per_usage_bit;\n\tfor (i = 0; i < bit_count; i++)\n\t\t__clear_bit(bit + i, part->usage);\n}\n\nstatic int mlxsw_sp2_kvdl_alloc(struct mlxsw_sp *mlxsw_sp, void *priv,\n\t\t\t\tenum mlxsw_sp_kvdl_entry_type type,\n\t\t\t\tunsigned int entry_count,\n\t\t\t\tu32 *p_entry_index)\n{\n\tunsigned int size = entry_count * mlxsw_sp_kvdl_entry_size(type);\n\tstruct mlxsw_sp2_kvdl *kvdl = priv;\n\tstruct mlxsw_sp2_kvdl_part *part = kvdl->parts[type];\n\n\treturn mlxsw_sp2_kvdl_part_alloc(part, size, p_entry_index);\n}\n\nstatic void mlxsw_sp2_kvdl_free(struct mlxsw_sp *mlxsw_sp, void *priv,\n\t\t\t\tenum mlxsw_sp_kvdl_entry_type type,\n\t\t\t\tunsigned int entry_count,\n\t\t\t\tint entry_index)\n{\n\tunsigned int size = entry_count * mlxsw_sp_kvdl_entry_size(type);\n\tstruct mlxsw_sp2_kvdl *kvdl = priv;\n\tstruct mlxsw_sp2_kvdl_part *part = kvdl->parts[type];\n\n\treturn mlxsw_sp2_kvdl_part_free(mlxsw_sp, part, size, entry_index);\n}\n\nstatic int mlxsw_sp2_kvdl_alloc_size_query(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   void *priv,\n\t\t\t\t\t   enum mlxsw_sp_kvdl_entry_type type,\n\t\t\t\t\t   unsigned int entry_count,\n\t\t\t\t\t   unsigned int *p_alloc_count)\n{\n\t*p_alloc_count = entry_count;\n\treturn 0;\n}\n\nstatic struct mlxsw_sp2_kvdl_part *\nmlxsw_sp2_kvdl_part_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t const struct mlxsw_sp2_kvdl_part_info *info)\n{\n\tunsigned int indexes_per_usage_bit;\n\tstruct mlxsw_sp2_kvdl_part *part;\n\tunsigned int index_range;\n\tunsigned int usage_bit_count;\n\tsize_t usage_size;\n\n\tif (!mlxsw_core_res_valid(mlxsw_sp->core,\n\t\t\t\t  info->usage_bit_count_res_id) ||\n\t    !mlxsw_core_res_valid(mlxsw_sp->core,\n\t\t\t\t  info->index_range_res_id))\n\t\treturn ERR_PTR(-EIO);\n\tusage_bit_count = mlxsw_core_res_get(mlxsw_sp->core,\n\t\t\t\t\t     info->usage_bit_count_res_id);\n\tindex_range = mlxsw_core_res_get(mlxsw_sp->core,\n\t\t\t\t\t info->index_range_res_id);\n\n\t \n\tindexes_per_usage_bit = index_range / usage_bit_count;\n\n\tusage_size = BITS_TO_LONGS(usage_bit_count) * sizeof(unsigned long);\n\tpart = kzalloc(sizeof(*part) + usage_size, GFP_KERNEL);\n\tif (!part)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpart->info = info;\n\tpart->usage_bit_count = usage_bit_count;\n\tpart->indexes_per_usage_bit = indexes_per_usage_bit;\n\tpart->last_allocated_bit = usage_bit_count - 1;\n\treturn part;\n}\n\nstatic void mlxsw_sp2_kvdl_part_fini(struct mlxsw_sp2_kvdl_part *part)\n{\n\tkfree(part);\n}\n\nstatic int mlxsw_sp2_kvdl_parts_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp2_kvdl *kvdl)\n{\n\tconst struct mlxsw_sp2_kvdl_part_info *info;\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < MLXSW_SP2_KVDL_PARTS_INFO_LEN; i++) {\n\t\tinfo = &mlxsw_sp2_kvdl_parts_info[i];\n\t\tkvdl->parts[i] = mlxsw_sp2_kvdl_part_init(mlxsw_sp, info);\n\t\tif (IS_ERR(kvdl->parts[i])) {\n\t\t\terr = PTR_ERR(kvdl->parts[i]);\n\t\t\tgoto err_kvdl_part_init;\n\t\t}\n\t}\n\treturn 0;\n\nerr_kvdl_part_init:\n\tfor (i--; i >= 0; i--)\n\t\tmlxsw_sp2_kvdl_part_fini(kvdl->parts[i]);\n\treturn err;\n}\n\nstatic void mlxsw_sp2_kvdl_parts_fini(struct mlxsw_sp2_kvdl *kvdl)\n{\n\tint i;\n\n\tfor (i = 0; i < MLXSW_SP2_KVDL_PARTS_INFO_LEN; i++)\n\t\tmlxsw_sp2_kvdl_part_fini(kvdl->parts[i]);\n}\n\nstatic int mlxsw_sp2_kvdl_init(struct mlxsw_sp *mlxsw_sp, void *priv)\n{\n\tstruct mlxsw_sp2_kvdl *kvdl = priv;\n\n\treturn mlxsw_sp2_kvdl_parts_init(mlxsw_sp, kvdl);\n}\n\nstatic void mlxsw_sp2_kvdl_fini(struct mlxsw_sp *mlxsw_sp, void *priv)\n{\n\tstruct mlxsw_sp2_kvdl *kvdl = priv;\n\n\tmlxsw_sp2_kvdl_parts_fini(kvdl);\n}\n\nconst struct mlxsw_sp_kvdl_ops mlxsw_sp2_kvdl_ops = {\n\t.priv_size = sizeof(struct mlxsw_sp2_kvdl),\n\t.init = mlxsw_sp2_kvdl_init,\n\t.fini = mlxsw_sp2_kvdl_fini,\n\t.alloc = mlxsw_sp2_kvdl_alloc,\n\t.free = mlxsw_sp2_kvdl_free,\n\t.alloc_size_query = mlxsw_sp2_kvdl_alloc_size_query,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}