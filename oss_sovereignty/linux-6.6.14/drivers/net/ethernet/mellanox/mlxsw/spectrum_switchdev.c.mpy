{
  "module_name": "spectrum_switchdev.c",
  "hash_id": "ecae719882fabd8f640c632540550bc23b8fc1c820f12095bc35805bc128f727",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/skbuff.h>\n#include <linux/if_vlan.h>\n#include <linux/if_bridge.h>\n#include <linux/workqueue.h>\n#include <linux/jiffies.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <net/switchdev.h>\n#include <net/vxlan.h>\n\n#include \"spectrum_span.h\"\n#include \"spectrum_switchdev.h\"\n#include \"spectrum.h\"\n#include \"core.h\"\n#include \"reg.h\"\n\nstruct mlxsw_sp_bridge_ops;\n\nstruct mlxsw_sp_bridge {\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct {\n\t\tstruct delayed_work dw;\n#define MLXSW_SP_DEFAULT_LEARNING_INTERVAL 100\n\t\tunsigned int interval;  \n\t} fdb_notify;\n#define MLXSW_SP_MIN_AGEING_TIME 10\n#define MLXSW_SP_MAX_AGEING_TIME 1000000\n#define MLXSW_SP_DEFAULT_AGEING_TIME 300\n\tu32 ageing_time;\n\tbool vlan_enabled_exists;\n\tstruct list_head bridges_list;\n\tDECLARE_BITMAP(mids_bitmap, MLXSW_SP_MID_MAX);\n\tconst struct mlxsw_sp_bridge_ops *bridge_8021q_ops;\n\tconst struct mlxsw_sp_bridge_ops *bridge_8021d_ops;\n\tconst struct mlxsw_sp_bridge_ops *bridge_8021ad_ops;\n};\n\nstruct mlxsw_sp_bridge_device {\n\tstruct net_device *dev;\n\tstruct list_head list;\n\tstruct list_head ports_list;\n\tstruct list_head mdb_list;\n\tstruct rhashtable mdb_ht;\n\tu8 vlan_enabled:1,\n\t   multicast_enabled:1,\n\t   mrouter:1;\n\tconst struct mlxsw_sp_bridge_ops *ops;\n};\n\nstruct mlxsw_sp_bridge_port {\n\tstruct net_device *dev;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct list_head list;\n\tstruct list_head vlans_list;\n\tunsigned int ref_count;\n\tu8 stp_state;\n\tunsigned long flags;\n\tbool mrouter;\n\tbool lagged;\n\tunion {\n\t\tu16 lag_id;\n\t\tu16 system_port;\n\t};\n};\n\nstruct mlxsw_sp_bridge_vlan {\n\tstruct list_head list;\n\tstruct list_head port_vlan_list;\n\tu16 vid;\n};\n\nstruct mlxsw_sp_bridge_ops {\n\tint (*port_join)(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t struct netlink_ext_ack *extack);\n\tvoid (*port_leave)(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t   struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t   struct mlxsw_sp_port *mlxsw_sp_port);\n\tint (*vxlan_join)(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t  const struct net_device *vxlan_dev, u16 vid,\n\t\t\t  struct netlink_ext_ack *extack);\n\tstruct mlxsw_sp_fid *\n\t\t(*fid_get)(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t   u16 vid, struct netlink_ext_ack *extack);\n\tstruct mlxsw_sp_fid *\n\t\t(*fid_lookup)(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t      u16 vid);\n\tu16 (*fid_vid)(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t       const struct mlxsw_sp_fid *fid);\n};\n\nstruct mlxsw_sp_switchdev_ops {\n\tvoid (*init)(struct mlxsw_sp *mlxsw_sp);\n};\n\nstruct mlxsw_sp_mdb_entry_key {\n\tunsigned char addr[ETH_ALEN];\n\tu16 fid;\n};\n\nstruct mlxsw_sp_mdb_entry {\n\tstruct list_head list;\n\tstruct rhash_head ht_node;\n\tstruct mlxsw_sp_mdb_entry_key key;\n\tu16 mid;\n\tstruct list_head ports_list;\n\tu16 ports_count;\n};\n\nstruct mlxsw_sp_mdb_entry_port {\n\tstruct list_head list;  \n\tu16 local_port;\n\trefcount_t refcount;\n\tbool mrouter;\n};\n\nstatic const struct rhashtable_params mlxsw_sp_mdb_ht_params = {\n\t.key_offset = offsetof(struct mlxsw_sp_mdb_entry, key),\n\t.head_offset = offsetof(struct mlxsw_sp_mdb_entry, ht_node),\n\t.key_len = sizeof(struct mlxsw_sp_mdb_entry_key),\n};\n\nstatic int\nmlxsw_sp_bridge_port_fdb_flush(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t       u16 fid_index);\n\nstatic void\nmlxsw_sp_bridge_port_mdb_flush(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t       struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t       u16 fid_index);\n\nstatic int\nmlxsw_sp_bridge_mdb_mc_enable_sync(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_bridge_device\n\t\t\t\t   *bridge_device, bool mc_enabled);\n\nstatic void\nmlxsw_sp_port_mrouter_update_mdb(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\t bool add);\n\nstatic struct mlxsw_sp_bridge_device *\nmlxsw_sp_bridge_device_find(const struct mlxsw_sp_bridge *bridge,\n\t\t\t    const struct net_device *br_dev)\n{\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\n\tlist_for_each_entry(bridge_device, &bridge->bridges_list, list)\n\t\tif (bridge_device->dev == br_dev)\n\t\t\treturn bridge_device;\n\n\treturn NULL;\n}\n\nbool mlxsw_sp_bridge_device_is_offloaded(const struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t const struct net_device *br_dev)\n{\n\treturn !!mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);\n}\n\nstatic int mlxsw_sp_bridge_device_upper_rif_destroy(struct net_device *dev,\n\t\t\t\t\t\t    struct netdev_nested_priv *priv)\n{\n\tstruct mlxsw_sp *mlxsw_sp = priv->data;\n\n\tmlxsw_sp_rif_destroy_by_dev(mlxsw_sp, dev);\n\treturn 0;\n}\n\nstatic void mlxsw_sp_bridge_device_rifs_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tstruct net_device *dev)\n{\n\tstruct netdev_nested_priv priv = {\n\t\t.data = (void *)mlxsw_sp,\n\t};\n\n\tmlxsw_sp_rif_destroy_by_dev(mlxsw_sp, dev);\n\tnetdev_walk_all_upper_dev_rcu(dev,\n\t\t\t\t      mlxsw_sp_bridge_device_upper_rif_destroy,\n\t\t\t\t      &priv);\n}\n\nstatic int mlxsw_sp_bridge_device_vxlan_init(struct mlxsw_sp_bridge *bridge,\n\t\t\t\t\t     struct net_device *br_dev,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev, *stop_dev;\n\tstruct list_head *iter;\n\tint err;\n\n\tnetdev_for_each_lower_dev(br_dev, dev, iter) {\n\t\tif (netif_is_vxlan(dev) && netif_running(dev)) {\n\t\t\terr = mlxsw_sp_bridge_vxlan_join(bridge->mlxsw_sp,\n\t\t\t\t\t\t\t br_dev, dev, 0,\n\t\t\t\t\t\t\t extack);\n\t\t\tif (err) {\n\t\t\t\tstop_dev = dev;\n\t\t\t\tgoto err_vxlan_join;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_vxlan_join:\n\tnetdev_for_each_lower_dev(br_dev, dev, iter) {\n\t\tif (netif_is_vxlan(dev) && netif_running(dev)) {\n\t\t\tif (stop_dev == dev)\n\t\t\t\tbreak;\n\t\t\tmlxsw_sp_bridge_vxlan_leave(bridge->mlxsw_sp, dev);\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic void mlxsw_sp_bridge_device_vxlan_fini(struct mlxsw_sp_bridge *bridge,\n\t\t\t\t\t      struct net_device *br_dev)\n{\n\tstruct net_device *dev;\n\tstruct list_head *iter;\n\n\tnetdev_for_each_lower_dev(br_dev, dev, iter) {\n\t\tif (netif_is_vxlan(dev) && netif_running(dev))\n\t\t\tmlxsw_sp_bridge_vxlan_leave(bridge->mlxsw_sp, dev);\n\t}\n}\n\nstatic void mlxsw_sp_fdb_notify_work_schedule(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t      bool no_delay)\n{\n\tstruct mlxsw_sp_bridge *bridge = mlxsw_sp->bridge;\n\tunsigned int interval = no_delay ? 0 : bridge->fdb_notify.interval;\n\n\tmlxsw_core_schedule_dw(&bridge->fdb_notify.dw,\n\t\t\t       msecs_to_jiffies(interval));\n}\n\nstatic struct mlxsw_sp_bridge_device *\nmlxsw_sp_bridge_device_create(struct mlxsw_sp_bridge *bridge,\n\t\t\t      struct net_device *br_dev,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct device *dev = bridge->mlxsw_sp->bus_info->dev;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tbool vlan_enabled = br_vlan_enabled(br_dev);\n\tint err;\n\n\tif (vlan_enabled && bridge->vlan_enabled_exists) {\n\t\tdev_err(dev, \"Only one VLAN-aware bridge is supported\\n\");\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Only one VLAN-aware bridge is supported\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbridge_device = kzalloc(sizeof(*bridge_device), GFP_KERNEL);\n\tif (!bridge_device)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = rhashtable_init(&bridge_device->mdb_ht, &mlxsw_sp_mdb_ht_params);\n\tif (err)\n\t\tgoto err_mdb_rhashtable_init;\n\n\tbridge_device->dev = br_dev;\n\tbridge_device->vlan_enabled = vlan_enabled;\n\tbridge_device->multicast_enabled = br_multicast_enabled(br_dev);\n\tbridge_device->mrouter = br_multicast_router(br_dev);\n\tINIT_LIST_HEAD(&bridge_device->ports_list);\n\tif (vlan_enabled) {\n\t\tu16 proto;\n\n\t\tbridge->vlan_enabled_exists = true;\n\t\tbr_vlan_get_proto(br_dev, &proto);\n\t\tif (proto == ETH_P_8021AD)\n\t\t\tbridge_device->ops = bridge->bridge_8021ad_ops;\n\t\telse\n\t\t\tbridge_device->ops = bridge->bridge_8021q_ops;\n\t} else {\n\t\tbridge_device->ops = bridge->bridge_8021d_ops;\n\t}\n\tINIT_LIST_HEAD(&bridge_device->mdb_list);\n\n\tif (list_empty(&bridge->bridges_list))\n\t\tmlxsw_sp_fdb_notify_work_schedule(bridge->mlxsw_sp, false);\n\tlist_add(&bridge_device->list, &bridge->bridges_list);\n\n\t \n\terr = mlxsw_sp_bridge_device_vxlan_init(bridge, br_dev, extack);\n\tif (err)\n\t\tgoto err_vxlan_init;\n\n\treturn bridge_device;\n\nerr_vxlan_init:\n\tlist_del(&bridge_device->list);\n\tif (bridge_device->vlan_enabled)\n\t\tbridge->vlan_enabled_exists = false;\n\trhashtable_destroy(&bridge_device->mdb_ht);\nerr_mdb_rhashtable_init:\n\tkfree(bridge_device);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_bridge_device_destroy(struct mlxsw_sp_bridge *bridge,\n\t\t\t       struct mlxsw_sp_bridge_device *bridge_device)\n{\n\tmlxsw_sp_bridge_device_vxlan_fini(bridge, bridge_device->dev);\n\tmlxsw_sp_bridge_device_rifs_destroy(bridge->mlxsw_sp,\n\t\t\t\t\t    bridge_device->dev);\n\tlist_del(&bridge_device->list);\n\tif (list_empty(&bridge->bridges_list))\n\t\tcancel_delayed_work(&bridge->fdb_notify.dw);\n\tif (bridge_device->vlan_enabled)\n\t\tbridge->vlan_enabled_exists = false;\n\tWARN_ON(!list_empty(&bridge_device->ports_list));\n\tWARN_ON(!list_empty(&bridge_device->mdb_list));\n\trhashtable_destroy(&bridge_device->mdb_ht);\n\tkfree(bridge_device);\n}\n\nstatic struct mlxsw_sp_bridge_device *\nmlxsw_sp_bridge_device_get(struct mlxsw_sp_bridge *bridge,\n\t\t\t   struct net_device *br_dev,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\n\tbridge_device = mlxsw_sp_bridge_device_find(bridge, br_dev);\n\tif (bridge_device)\n\t\treturn bridge_device;\n\n\treturn mlxsw_sp_bridge_device_create(bridge, br_dev, extack);\n}\n\nstatic void\nmlxsw_sp_bridge_device_put(struct mlxsw_sp_bridge *bridge,\n\t\t\t   struct mlxsw_sp_bridge_device *bridge_device)\n{\n\tif (list_empty(&bridge_device->ports_list))\n\t\tmlxsw_sp_bridge_device_destroy(bridge, bridge_device);\n}\n\nstatic struct mlxsw_sp_bridge_port *\n__mlxsw_sp_bridge_port_find(const struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t    const struct net_device *brport_dev)\n{\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\n\tlist_for_each_entry(bridge_port, &bridge_device->ports_list, list) {\n\t\tif (bridge_port->dev == brport_dev)\n\t\t\treturn bridge_port;\n\t}\n\n\treturn NULL;\n}\n\nstruct mlxsw_sp_bridge_port *\nmlxsw_sp_bridge_port_find(struct mlxsw_sp_bridge *bridge,\n\t\t\t  struct net_device *brport_dev)\n{\n\tstruct net_device *br_dev = netdev_master_upper_dev_get(brport_dev);\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\n\tif (!br_dev)\n\t\treturn NULL;\n\n\tbridge_device = mlxsw_sp_bridge_device_find(bridge, br_dev);\n\tif (!bridge_device)\n\t\treturn NULL;\n\n\treturn __mlxsw_sp_bridge_port_find(bridge_device, brport_dev);\n}\n\nstatic int mlxsw_sp_port_obj_add(struct net_device *dev, const void *ctx,\n\t\t\t\t const struct switchdev_obj *obj,\n\t\t\t\t struct netlink_ext_ack *extack);\nstatic int mlxsw_sp_port_obj_del(struct net_device *dev, const void *ctx,\n\t\t\t\t const struct switchdev_obj *obj);\n\nstruct mlxsw_sp_bridge_port_replay_switchdev_objs {\n\tstruct net_device *brport_dev;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tint done;\n};\n\nstatic int\nmlxsw_sp_bridge_port_replay_switchdev_objs(struct notifier_block *nb,\n\t\t\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tstruct switchdev_notifier_port_obj_info *port_obj_info = ptr;\n\tstruct netlink_ext_ack *extack = port_obj_info->info.extack;\n\tstruct mlxsw_sp_bridge_port_replay_switchdev_objs *rso;\n\tint err = 0;\n\n\trso = (void *)port_obj_info->info.ctx;\n\n\tif (event != SWITCHDEV_PORT_OBJ_ADD ||\n\t    dev != rso->brport_dev)\n\t\tgoto out;\n\n\t \n\tif (port_obj_info->obj->id == SWITCHDEV_OBJ_ID_PORT_VLAN) {\n\t\tu16 vid = SWITCHDEV_OBJ_PORT_VLAN(port_obj_info->obj)->vid;\n\n\t\terr = mlxsw_sp_port_kill_vid(rso->mlxsw_sp_port->dev, 0, vid);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t++rso->done;\n\terr = mlxsw_sp_port_obj_add(rso->mlxsw_sp_port->dev, NULL,\n\t\t\t\t    port_obj_info->obj, extack);\n\nout:\n\treturn notifier_from_errno(err);\n}\n\nstatic struct notifier_block mlxsw_sp_bridge_port_replay_switchdev_objs_nb = {\n\t.notifier_call = mlxsw_sp_bridge_port_replay_switchdev_objs,\n};\n\nstatic int\nmlxsw_sp_bridge_port_unreplay_switchdev_objs(struct notifier_block *nb,\n\t\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tstruct switchdev_notifier_port_obj_info *port_obj_info = ptr;\n\tstruct mlxsw_sp_bridge_port_replay_switchdev_objs *rso;\n\n\trso = (void *)port_obj_info->info.ctx;\n\n\tif (event != SWITCHDEV_PORT_OBJ_ADD ||\n\t    dev != rso->brport_dev)\n\t\treturn NOTIFY_DONE;\n\tif (!rso->done--)\n\t\treturn NOTIFY_STOP;\n\n\tmlxsw_sp_port_obj_del(rso->mlxsw_sp_port->dev, NULL,\n\t\t\t      port_obj_info->obj);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block mlxsw_sp_bridge_port_unreplay_switchdev_objs_nb = {\n\t.notifier_call = mlxsw_sp_bridge_port_unreplay_switchdev_objs,\n};\n\nstatic struct mlxsw_sp_bridge_port *\nmlxsw_sp_bridge_port_create(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t    struct net_device *brport_dev,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tint err;\n\n\tbridge_port = kzalloc(sizeof(*bridge_port), GFP_KERNEL);\n\tif (!bridge_port)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmlxsw_sp_port = mlxsw_sp_port_dev_lower_find(brport_dev);\n\tbridge_port->lagged = mlxsw_sp_port->lagged;\n\tif (bridge_port->lagged)\n\t\tbridge_port->lag_id = mlxsw_sp_port->lag_id;\n\telse\n\t\tbridge_port->system_port = mlxsw_sp_port->local_port;\n\tbridge_port->dev = brport_dev;\n\tbridge_port->bridge_device = bridge_device;\n\tbridge_port->stp_state = br_port_get_stp_state(brport_dev);\n\tbridge_port->flags = BR_LEARNING | BR_FLOOD | BR_LEARNING_SYNC |\n\t\t\t     BR_MCAST_FLOOD;\n\tINIT_LIST_HEAD(&bridge_port->vlans_list);\n\tlist_add(&bridge_port->list, &bridge_device->ports_list);\n\tbridge_port->ref_count = 1;\n\n\terr = switchdev_bridge_port_offload(brport_dev, mlxsw_sp_port->dev,\n\t\t\t\t\t    NULL, NULL, NULL, false, extack);\n\tif (err)\n\t\tgoto err_switchdev_offload;\n\n\treturn bridge_port;\n\nerr_switchdev_offload:\n\tlist_del(&bridge_port->list);\n\tkfree(bridge_port);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_bridge_port_destroy(struct mlxsw_sp_bridge_port *bridge_port)\n{\n\tswitchdev_bridge_port_unoffload(bridge_port->dev, NULL, NULL, NULL);\n\tlist_del(&bridge_port->list);\n\tWARN_ON(!list_empty(&bridge_port->vlans_list));\n\tkfree(bridge_port);\n}\n\nstatic struct mlxsw_sp_bridge_port *\nmlxsw_sp_bridge_port_get(struct mlxsw_sp_bridge *bridge,\n\t\t\t struct net_device *brport_dev,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net_device *br_dev = netdev_master_upper_dev_get(brport_dev);\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tint err;\n\n\tbridge_port = mlxsw_sp_bridge_port_find(bridge, brport_dev);\n\tif (bridge_port) {\n\t\tbridge_port->ref_count++;\n\t\treturn bridge_port;\n\t}\n\n\tbridge_device = mlxsw_sp_bridge_device_get(bridge, br_dev, extack);\n\tif (IS_ERR(bridge_device))\n\t\treturn ERR_CAST(bridge_device);\n\n\tbridge_port = mlxsw_sp_bridge_port_create(bridge_device, brport_dev,\n\t\t\t\t\t\t  extack);\n\tif (IS_ERR(bridge_port)) {\n\t\terr = PTR_ERR(bridge_port);\n\t\tgoto err_bridge_port_create;\n\t}\n\n\treturn bridge_port;\n\nerr_bridge_port_create:\n\tmlxsw_sp_bridge_device_put(bridge, bridge_device);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_bridge_port_put(struct mlxsw_sp_bridge *bridge,\n\t\t\t\t     struct mlxsw_sp_bridge_port *bridge_port)\n{\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\n\tif (--bridge_port->ref_count != 0)\n\t\treturn;\n\tbridge_device = bridge_port->bridge_device;\n\tmlxsw_sp_bridge_port_destroy(bridge_port);\n\tmlxsw_sp_bridge_device_put(bridge, bridge_device);\n}\n\nstatic struct mlxsw_sp_port_vlan *\nmlxsw_sp_port_vlan_find_by_bridge(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  const struct mlxsw_sp_bridge_device *\n\t\t\t\t  bridge_device,\n\t\t\t\t  u16 vid)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\n\tlist_for_each_entry(mlxsw_sp_port_vlan, &mlxsw_sp_port->vlans_list,\n\t\t\t    list) {\n\t\tif (!mlxsw_sp_port_vlan->bridge_port)\n\t\t\tcontinue;\n\t\tif (mlxsw_sp_port_vlan->bridge_port->bridge_device !=\n\t\t    bridge_device)\n\t\t\tcontinue;\n\t\tif (bridge_device->vlan_enabled &&\n\t\t    mlxsw_sp_port_vlan->vid != vid)\n\t\t\tcontinue;\n\t\treturn mlxsw_sp_port_vlan;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mlxsw_sp_port_vlan*\nmlxsw_sp_port_vlan_find_by_fid(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t       u16 fid_index)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\n\tlist_for_each_entry(mlxsw_sp_port_vlan, &mlxsw_sp_port->vlans_list,\n\t\t\t    list) {\n\t\tstruct mlxsw_sp_fid *fid = mlxsw_sp_port_vlan->fid;\n\n\t\tif (fid && mlxsw_sp_fid_index(fid) == fid_index)\n\t\t\treturn mlxsw_sp_port_vlan;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mlxsw_sp_bridge_vlan *\nmlxsw_sp_bridge_vlan_find(const struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t  u16 vid)\n{\n\tstruct mlxsw_sp_bridge_vlan *bridge_vlan;\n\n\tlist_for_each_entry(bridge_vlan, &bridge_port->vlans_list, list) {\n\t\tif (bridge_vlan->vid == vid)\n\t\t\treturn bridge_vlan;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mlxsw_sp_bridge_vlan *\nmlxsw_sp_bridge_vlan_create(struct mlxsw_sp_bridge_port *bridge_port, u16 vid)\n{\n\tstruct mlxsw_sp_bridge_vlan *bridge_vlan;\n\n\tbridge_vlan = kzalloc(sizeof(*bridge_vlan), GFP_KERNEL);\n\tif (!bridge_vlan)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&bridge_vlan->port_vlan_list);\n\tbridge_vlan->vid = vid;\n\tlist_add(&bridge_vlan->list, &bridge_port->vlans_list);\n\n\treturn bridge_vlan;\n}\n\nstatic void\nmlxsw_sp_bridge_vlan_destroy(struct mlxsw_sp_bridge_vlan *bridge_vlan)\n{\n\tlist_del(&bridge_vlan->list);\n\tWARN_ON(!list_empty(&bridge_vlan->port_vlan_list));\n\tkfree(bridge_vlan);\n}\n\nstatic struct mlxsw_sp_bridge_vlan *\nmlxsw_sp_bridge_vlan_get(struct mlxsw_sp_bridge_port *bridge_port, u16 vid)\n{\n\tstruct mlxsw_sp_bridge_vlan *bridge_vlan;\n\n\tbridge_vlan = mlxsw_sp_bridge_vlan_find(bridge_port, vid);\n\tif (bridge_vlan)\n\t\treturn bridge_vlan;\n\n\treturn mlxsw_sp_bridge_vlan_create(bridge_port, vid);\n}\n\nstatic void mlxsw_sp_bridge_vlan_put(struct mlxsw_sp_bridge_vlan *bridge_vlan)\n{\n\tif (list_empty(&bridge_vlan->port_vlan_list))\n\t\tmlxsw_sp_bridge_vlan_destroy(bridge_vlan);\n}\n\nstatic int\nmlxsw_sp_port_bridge_vlan_stp_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  struct mlxsw_sp_bridge_vlan *bridge_vlan,\n\t\t\t\t  u8 state)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\n\tlist_for_each_entry(mlxsw_sp_port_vlan, &bridge_vlan->port_vlan_list,\n\t\t\t    bridge_vlan_node) {\n\t\tif (mlxsw_sp_port_vlan->mlxsw_sp_port != mlxsw_sp_port)\n\t\t\tcontinue;\n\t\treturn mlxsw_sp_port_vid_stp_set(mlxsw_sp_port,\n\t\t\t\t\t\t bridge_vlan->vid, state);\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_attr_stp_state_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t    struct net_device *orig_dev,\n\t\t\t\t\t    u8 state)\n{\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tstruct mlxsw_sp_bridge_vlan *bridge_vlan;\n\tint err;\n\n\t \n\tbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp_port->mlxsw_sp->bridge,\n\t\t\t\t\t\torig_dev);\n\tif (!bridge_port)\n\t\treturn 0;\n\n\tlist_for_each_entry(bridge_vlan, &bridge_port->vlans_list, list) {\n\t\terr = mlxsw_sp_port_bridge_vlan_stp_set(mlxsw_sp_port,\n\t\t\t\t\t\t\tbridge_vlan, state);\n\t\tif (err)\n\t\t\tgoto err_port_bridge_vlan_stp_set;\n\t}\n\n\tbridge_port->stp_state = state;\n\n\treturn 0;\n\nerr_port_bridge_vlan_stp_set:\n\tlist_for_each_entry_continue_reverse(bridge_vlan,\n\t\t\t\t\t     &bridge_port->vlans_list, list)\n\t\tmlxsw_sp_port_bridge_vlan_stp_set(mlxsw_sp_port, bridge_vlan,\n\t\t\t\t\t\t  bridge_port->stp_state);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_port_bridge_vlan_flood_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    struct mlxsw_sp_bridge_vlan *bridge_vlan,\n\t\t\t\t    enum mlxsw_sp_flood_type packet_type,\n\t\t\t\t    bool member)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\n\tlist_for_each_entry(mlxsw_sp_port_vlan, &bridge_vlan->port_vlan_list,\n\t\t\t    bridge_vlan_node) {\n\t\tif (mlxsw_sp_port_vlan->mlxsw_sp_port != mlxsw_sp_port)\n\t\t\tcontinue;\n\t\treturn mlxsw_sp_fid_flood_set(mlxsw_sp_port_vlan->fid,\n\t\t\t\t\t      packet_type,\n\t\t\t\t\t      mlxsw_sp_port->local_port,\n\t\t\t\t\t      member);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_bridge_port_flood_table_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t     struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\t     enum mlxsw_sp_flood_type packet_type,\n\t\t\t\t     bool member)\n{\n\tstruct mlxsw_sp_bridge_vlan *bridge_vlan;\n\tint err;\n\n\tlist_for_each_entry(bridge_vlan, &bridge_port->vlans_list, list) {\n\t\terr = mlxsw_sp_port_bridge_vlan_flood_set(mlxsw_sp_port,\n\t\t\t\t\t\t\t  bridge_vlan,\n\t\t\t\t\t\t\t  packet_type,\n\t\t\t\t\t\t\t  member);\n\t\tif (err)\n\t\t\tgoto err_port_bridge_vlan_flood_set;\n\t}\n\n\treturn 0;\n\nerr_port_bridge_vlan_flood_set:\n\tlist_for_each_entry_continue_reverse(bridge_vlan,\n\t\t\t\t\t     &bridge_port->vlans_list, list)\n\t\tmlxsw_sp_port_bridge_vlan_flood_set(mlxsw_sp_port, bridge_vlan,\n\t\t\t\t\t\t    packet_type, !member);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_bridge_vlans_flood_set(struct mlxsw_sp_bridge_vlan *bridge_vlan,\n\t\t\t\tenum mlxsw_sp_flood_type packet_type,\n\t\t\t\tbool member)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tint err;\n\n\tlist_for_each_entry(mlxsw_sp_port_vlan, &bridge_vlan->port_vlan_list,\n\t\t\t    bridge_vlan_node) {\n\t\tu16 local_port = mlxsw_sp_port_vlan->mlxsw_sp_port->local_port;\n\n\t\terr = mlxsw_sp_fid_flood_set(mlxsw_sp_port_vlan->fid,\n\t\t\t\t\t     packet_type, local_port, member);\n\t\tif (err)\n\t\t\tgoto err_fid_flood_set;\n\t}\n\n\treturn 0;\n\nerr_fid_flood_set:\n\tlist_for_each_entry_continue_reverse(mlxsw_sp_port_vlan,\n\t\t\t\t\t     &bridge_vlan->port_vlan_list,\n\t\t\t\t\t     list) {\n\t\tu16 local_port = mlxsw_sp_port_vlan->mlxsw_sp_port->local_port;\n\n\t\tmlxsw_sp_fid_flood_set(mlxsw_sp_port_vlan->fid, packet_type,\n\t\t\t\t       local_port, !member);\n\t}\n\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_bridge_ports_flood_table_set(struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\t      enum mlxsw_sp_flood_type packet_type,\n\t\t\t\t      bool member)\n{\n\tstruct mlxsw_sp_bridge_vlan *bridge_vlan;\n\tint err;\n\n\tlist_for_each_entry(bridge_vlan, &bridge_port->vlans_list, list) {\n\t\terr = mlxsw_sp_bridge_vlans_flood_set(bridge_vlan, packet_type,\n\t\t\t\t\t\t      member);\n\t\tif (err)\n\t\t\tgoto err_bridge_vlans_flood_set;\n\t}\n\n\treturn 0;\n\nerr_bridge_vlans_flood_set:\n\tlist_for_each_entry_continue_reverse(bridge_vlan,\n\t\t\t\t\t     &bridge_port->vlans_list, list)\n\t\tmlxsw_sp_bridge_vlans_flood_set(bridge_vlan, packet_type,\n\t\t\t\t\t\t!member);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_port_bridge_vlan_learning_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t       struct mlxsw_sp_bridge_vlan *bridge_vlan,\n\t\t\t\t       bool set)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tu16 vid = bridge_vlan->vid;\n\n\tlist_for_each_entry(mlxsw_sp_port_vlan, &bridge_vlan->port_vlan_list,\n\t\t\t    bridge_vlan_node) {\n\t\tif (mlxsw_sp_port_vlan->mlxsw_sp_port != mlxsw_sp_port)\n\t\t\tcontinue;\n\t\treturn mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, set);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_bridge_port_learning_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\t  bool set)\n{\n\tstruct mlxsw_sp_bridge_vlan *bridge_vlan;\n\tint err;\n\n\tlist_for_each_entry(bridge_vlan, &bridge_port->vlans_list, list) {\n\t\terr = mlxsw_sp_port_bridge_vlan_learning_set(mlxsw_sp_port,\n\t\t\t\t\t\t\t     bridge_vlan, set);\n\t\tif (err)\n\t\t\tgoto err_port_bridge_vlan_learning_set;\n\t}\n\n\treturn 0;\n\nerr_port_bridge_vlan_learning_set:\n\tlist_for_each_entry_continue_reverse(bridge_vlan,\n\t\t\t\t\t     &bridge_port->vlans_list, list)\n\t\tmlxsw_sp_port_bridge_vlan_learning_set(mlxsw_sp_port,\n\t\t\t\t\t\t       bridge_vlan, !set);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_port_attr_br_pre_flags_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    const struct net_device *orig_dev,\n\t\t\t\t    struct switchdev_brport_flags flags,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (flags.mask & ~(BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD |\n\t\t\t   BR_PORT_LOCKED | BR_PORT_MAB)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported bridge port flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((flags.mask & BR_PORT_LOCKED) && is_vlan_dev(orig_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Locked flag cannot be set on a VLAN upper\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((flags.mask & BR_PORT_LOCKED) && vlan_uses_dev(orig_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Locked flag cannot be set on a bridge port that has VLAN uppers\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_attr_br_flags_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t   struct net_device *orig_dev,\n\t\t\t\t\t   struct switchdev_brport_flags flags)\n{\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tint err;\n\n\tbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp_port->mlxsw_sp->bridge,\n\t\t\t\t\t\torig_dev);\n\tif (!bridge_port)\n\t\treturn 0;\n\n\tif (flags.mask & BR_FLOOD) {\n\t\terr = mlxsw_sp_bridge_port_flood_table_set(mlxsw_sp_port,\n\t\t\t\t\t\t\t   bridge_port,\n\t\t\t\t\t\t\t   MLXSW_SP_FLOOD_TYPE_UC,\n\t\t\t\t\t\t\t   flags.val & BR_FLOOD);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (flags.mask & BR_LEARNING) {\n\t\terr = mlxsw_sp_bridge_port_learning_set(mlxsw_sp_port,\n\t\t\t\t\t\t\tbridge_port,\n\t\t\t\t\t\t\tflags.val & BR_LEARNING);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (flags.mask & BR_PORT_LOCKED) {\n\t\terr = mlxsw_sp_port_security_set(mlxsw_sp_port,\n\t\t\t\t\t\t flags.val & BR_PORT_LOCKED);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (bridge_port->bridge_device->multicast_enabled)\n\t\tgoto out;\n\n\tif (flags.mask & BR_MCAST_FLOOD) {\n\t\terr = mlxsw_sp_bridge_port_flood_table_set(mlxsw_sp_port,\n\t\t\t\t\t\t\t   bridge_port,\n\t\t\t\t\t\t\t   MLXSW_SP_FLOOD_TYPE_MC,\n\t\t\t\t\t\t\t   flags.val & BR_MCAST_FLOOD);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\nout:\n\tmemcpy(&bridge_port->flags, &flags.val, sizeof(flags.val));\n\treturn 0;\n}\n\nstatic int mlxsw_sp_ageing_set(struct mlxsw_sp *mlxsw_sp, u32 ageing_time)\n{\n\tchar sfdat_pl[MLXSW_REG_SFDAT_LEN];\n\tint err;\n\n\tmlxsw_reg_sfdat_pack(sfdat_pl, ageing_time);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfdat), sfdat_pl);\n\tif (err)\n\t\treturn err;\n\tmlxsw_sp->bridge->ageing_time = ageing_time;\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_attr_br_ageing_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t    unsigned long ageing_clock_t)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tunsigned long ageing_jiffies = clock_t_to_jiffies(ageing_clock_t);\n\tu32 ageing_time = jiffies_to_msecs(ageing_jiffies) / 1000;\n\n\tif (ageing_time < MLXSW_SP_MIN_AGEING_TIME ||\n\t    ageing_time > MLXSW_SP_MAX_AGEING_TIME)\n\t\treturn -ERANGE;\n\n\treturn mlxsw_sp_ageing_set(mlxsw_sp, ageing_time);\n}\n\nstatic int mlxsw_sp_port_attr_br_vlan_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t  struct net_device *orig_dev,\n\t\t\t\t\t  bool vlan_enabled)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\n\tbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, orig_dev);\n\tif (WARN_ON(!bridge_device))\n\t\treturn -EINVAL;\n\n\tif (bridge_device->vlan_enabled == vlan_enabled)\n\t\treturn 0;\n\n\tnetdev_err(bridge_device->dev, \"VLAN filtering can't be changed for existing bridge\\n\");\n\treturn -EINVAL;\n}\n\nstatic int mlxsw_sp_port_attr_br_vlan_proto_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t\tstruct net_device *orig_dev,\n\t\t\t\t\t\tu16 vlan_proto)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\n\tbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, orig_dev);\n\tif (WARN_ON(!bridge_device))\n\t\treturn -EINVAL;\n\n\tnetdev_err(bridge_device->dev, \"VLAN protocol can't be changed on existing bridge\\n\");\n\treturn -EINVAL;\n}\n\nstatic int mlxsw_sp_port_attr_mrouter_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t  struct net_device *orig_dev,\n\t\t\t\t\t  bool is_port_mrouter)\n{\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tint err;\n\n\tbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp_port->mlxsw_sp->bridge,\n\t\t\t\t\t\torig_dev);\n\tif (!bridge_port)\n\t\treturn 0;\n\n\tmlxsw_sp_port_mrouter_update_mdb(mlxsw_sp_port, bridge_port,\n\t\t\t\t\t is_port_mrouter);\n\n\tif (!bridge_port->bridge_device->multicast_enabled)\n\t\tgoto out;\n\n\terr = mlxsw_sp_bridge_port_flood_table_set(mlxsw_sp_port, bridge_port,\n\t\t\t\t\t\t   MLXSW_SP_FLOOD_TYPE_MC,\n\t\t\t\t\t\t   is_port_mrouter);\n\tif (err)\n\t\treturn err;\n\nout:\n\tbridge_port->mrouter = is_port_mrouter;\n\treturn 0;\n}\n\nstatic bool mlxsw_sp_mc_flood(const struct mlxsw_sp_bridge_port *bridge_port)\n{\n\tconst struct mlxsw_sp_bridge_device *bridge_device;\n\n\tbridge_device = bridge_port->bridge_device;\n\treturn bridge_device->multicast_enabled ? bridge_port->mrouter :\n\t\t\t\t\tbridge_port->flags & BR_MCAST_FLOOD;\n}\n\nstatic int mlxsw_sp_port_mc_disabled_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t struct net_device *orig_dev,\n\t\t\t\t\t bool mc_disabled)\n{\n\tenum mlxsw_sp_flood_type packet_type = MLXSW_SP_FLOOD_TYPE_MC;\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tint err;\n\n\t \n\tbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, orig_dev);\n\tif (!bridge_device)\n\t\treturn 0;\n\n\tif (bridge_device->multicast_enabled == !mc_disabled)\n\t\treturn 0;\n\n\tbridge_device->multicast_enabled = !mc_disabled;\n\terr = mlxsw_sp_bridge_mdb_mc_enable_sync(mlxsw_sp, bridge_device,\n\t\t\t\t\t\t !mc_disabled);\n\tif (err)\n\t\tgoto err_mc_enable_sync;\n\n\tlist_for_each_entry(bridge_port, &bridge_device->ports_list, list) {\n\t\tbool member = mlxsw_sp_mc_flood(bridge_port);\n\n\t\terr = mlxsw_sp_bridge_ports_flood_table_set(bridge_port,\n\t\t\t\t\t\t\t    packet_type,\n\t\t\t\t\t\t\t    member);\n\t\tif (err)\n\t\t\tgoto err_flood_table_set;\n\t}\n\n\treturn 0;\n\nerr_flood_table_set:\n\tlist_for_each_entry_continue_reverse(bridge_port,\n\t\t\t\t\t     &bridge_device->ports_list, list) {\n\t\tbool member = mlxsw_sp_mc_flood(bridge_port);\n\n\t\tmlxsw_sp_bridge_ports_flood_table_set(bridge_port, packet_type,\n\t\t\t\t\t\t      !member);\n\t}\n\tmlxsw_sp_bridge_mdb_mc_enable_sync(mlxsw_sp, bridge_device,\n\t\t\t\t\t   mc_disabled);\nerr_mc_enable_sync:\n\tbridge_device->multicast_enabled = mc_disabled;\n\treturn err;\n}\n\nstatic struct mlxsw_sp_mdb_entry_port *\nmlxsw_sp_mdb_entry_port_lookup(struct mlxsw_sp_mdb_entry *mdb_entry,\n\t\t\t       u16 local_port)\n{\n\tstruct mlxsw_sp_mdb_entry_port *mdb_entry_port;\n\n\tlist_for_each_entry(mdb_entry_port, &mdb_entry->ports_list, list) {\n\t\tif (mdb_entry_port->local_port == local_port)\n\t\t\treturn mdb_entry_port;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mlxsw_sp_mdb_entry_port *\nmlxsw_sp_mdb_entry_port_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_mdb_entry *mdb_entry,\n\t\t\t    u16 local_port)\n{\n\tstruct mlxsw_sp_mdb_entry_port *mdb_entry_port;\n\tint err;\n\n\tmdb_entry_port = mlxsw_sp_mdb_entry_port_lookup(mdb_entry, local_port);\n\tif (mdb_entry_port) {\n\t\tif (mdb_entry_port->mrouter &&\n\t\t    refcount_read(&mdb_entry_port->refcount) == 1)\n\t\t\tmdb_entry->ports_count++;\n\n\t\trefcount_inc(&mdb_entry_port->refcount);\n\t\treturn mdb_entry_port;\n\t}\n\n\terr = mlxsw_sp_pgt_entry_port_set(mlxsw_sp, mdb_entry->mid,\n\t\t\t\t\t  mdb_entry->key.fid, local_port, true);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmdb_entry_port = kzalloc(sizeof(*mdb_entry_port), GFP_KERNEL);\n\tif (!mdb_entry_port) {\n\t\terr = -ENOMEM;\n\t\tgoto err_mdb_entry_port_alloc;\n\t}\n\n\tmdb_entry_port->local_port = local_port;\n\trefcount_set(&mdb_entry_port->refcount, 1);\n\tlist_add(&mdb_entry_port->list, &mdb_entry->ports_list);\n\tmdb_entry->ports_count++;\n\n\treturn mdb_entry_port;\n\nerr_mdb_entry_port_alloc:\n\tmlxsw_sp_pgt_entry_port_set(mlxsw_sp, mdb_entry->mid,\n\t\t\t\t    mdb_entry->key.fid, local_port, false);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_mdb_entry_port_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_mdb_entry *mdb_entry,\n\t\t\t    u16 local_port, bool force)\n{\n\tstruct mlxsw_sp_mdb_entry_port *mdb_entry_port;\n\n\tmdb_entry_port = mlxsw_sp_mdb_entry_port_lookup(mdb_entry, local_port);\n\tif (!mdb_entry_port)\n\t\treturn;\n\n\tif (!force && !refcount_dec_and_test(&mdb_entry_port->refcount)) {\n\t\tif (mdb_entry_port->mrouter &&\n\t\t    refcount_read(&mdb_entry_port->refcount) == 1)\n\t\t\tmdb_entry->ports_count--;\n\t\treturn;\n\t}\n\n\tmdb_entry->ports_count--;\n\tlist_del(&mdb_entry_port->list);\n\tkfree(mdb_entry_port);\n\tmlxsw_sp_pgt_entry_port_set(mlxsw_sp, mdb_entry->mid,\n\t\t\t\t    mdb_entry->key.fid, local_port, false);\n}\n\nstatic __always_unused struct mlxsw_sp_mdb_entry_port *\nmlxsw_sp_mdb_entry_mrouter_port_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_mdb_entry *mdb_entry,\n\t\t\t\t    u16 local_port)\n{\n\tstruct mlxsw_sp_mdb_entry_port *mdb_entry_port;\n\tint err;\n\n\tmdb_entry_port = mlxsw_sp_mdb_entry_port_lookup(mdb_entry, local_port);\n\tif (mdb_entry_port) {\n\t\tif (!mdb_entry_port->mrouter)\n\t\t\trefcount_inc(&mdb_entry_port->refcount);\n\t\treturn mdb_entry_port;\n\t}\n\n\terr = mlxsw_sp_pgt_entry_port_set(mlxsw_sp, mdb_entry->mid,\n\t\t\t\t\t  mdb_entry->key.fid, local_port, true);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmdb_entry_port = kzalloc(sizeof(*mdb_entry_port), GFP_KERNEL);\n\tif (!mdb_entry_port) {\n\t\terr = -ENOMEM;\n\t\tgoto err_mdb_entry_port_alloc;\n\t}\n\n\tmdb_entry_port->local_port = local_port;\n\trefcount_set(&mdb_entry_port->refcount, 1);\n\tmdb_entry_port->mrouter = true;\n\tlist_add(&mdb_entry_port->list, &mdb_entry->ports_list);\n\n\treturn mdb_entry_port;\n\nerr_mdb_entry_port_alloc:\n\tmlxsw_sp_pgt_entry_port_set(mlxsw_sp, mdb_entry->mid,\n\t\t\t\t    mdb_entry->key.fid, local_port, false);\n\treturn ERR_PTR(err);\n}\n\nstatic __always_unused void\nmlxsw_sp_mdb_entry_mrouter_port_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_mdb_entry *mdb_entry,\n\t\t\t\t    u16 local_port)\n{\n\tstruct mlxsw_sp_mdb_entry_port *mdb_entry_port;\n\n\tmdb_entry_port = mlxsw_sp_mdb_entry_port_lookup(mdb_entry, local_port);\n\tif (!mdb_entry_port)\n\t\treturn;\n\n\tif (!mdb_entry_port->mrouter)\n\t\treturn;\n\n\tmdb_entry_port->mrouter = false;\n\tif (!refcount_dec_and_test(&mdb_entry_port->refcount))\n\t\treturn;\n\n\tlist_del(&mdb_entry_port->list);\n\tkfree(mdb_entry_port);\n\tmlxsw_sp_pgt_entry_port_set(mlxsw_sp, mdb_entry->mid,\n\t\t\t\t    mdb_entry->key.fid, local_port, false);\n}\n\nstatic void\nmlxsw_sp_bridge_mrouter_update_mdb(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t   bool add)\n{\n\tu16 local_port = mlxsw_sp_router_port(mlxsw_sp);\n\tstruct mlxsw_sp_mdb_entry *mdb_entry;\n\n\tlist_for_each_entry(mdb_entry, &bridge_device->mdb_list, list) {\n\t\tif (add)\n\t\t\tmlxsw_sp_mdb_entry_mrouter_port_get(mlxsw_sp, mdb_entry,\n\t\t\t\t\t\t\t    local_port);\n\t\telse\n\t\t\tmlxsw_sp_mdb_entry_mrouter_port_put(mlxsw_sp, mdb_entry,\n\t\t\t\t\t\t\t    local_port);\n\t}\n}\n\nstatic int\nmlxsw_sp_port_attr_br_mrouter_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  struct net_device *orig_dev,\n\t\t\t\t  bool is_mrouter)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\n\t \n\tbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, orig_dev);\n\tif (!bridge_device)\n\t\treturn 0;\n\n\tif (bridge_device->mrouter != is_mrouter)\n\t\tmlxsw_sp_bridge_mrouter_update_mdb(mlxsw_sp, bridge_device,\n\t\t\t\t\t\t   is_mrouter);\n\tbridge_device->mrouter = is_mrouter;\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_attr_set(struct net_device *dev, const void *ctx,\n\t\t\t\t  const struct switchdev_attr *attr,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tint err;\n\n\tswitch (attr->id) {\n\tcase SWITCHDEV_ATTR_ID_PORT_STP_STATE:\n\t\terr = mlxsw_sp_port_attr_stp_state_set(mlxsw_sp_port,\n\t\t\t\t\t\t       attr->orig_dev,\n\t\t\t\t\t\t       attr->u.stp_state);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS:\n\t\terr = mlxsw_sp_port_attr_br_pre_flags_set(mlxsw_sp_port,\n\t\t\t\t\t\t\t  attr->orig_dev,\n\t\t\t\t\t\t\t  attr->u.brport_flags,\n\t\t\t\t\t\t\t  extack);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:\n\t\terr = mlxsw_sp_port_attr_br_flags_set(mlxsw_sp_port,\n\t\t\t\t\t\t      attr->orig_dev,\n\t\t\t\t\t\t      attr->u.brport_flags);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME:\n\t\terr = mlxsw_sp_port_attr_br_ageing_set(mlxsw_sp_port,\n\t\t\t\t\t\t       attr->u.ageing_time);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING:\n\t\terr = mlxsw_sp_port_attr_br_vlan_set(mlxsw_sp_port,\n\t\t\t\t\t\t     attr->orig_dev,\n\t\t\t\t\t\t     attr->u.vlan_filtering);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_VLAN_PROTOCOL:\n\t\terr = mlxsw_sp_port_attr_br_vlan_proto_set(mlxsw_sp_port,\n\t\t\t\t\t\t\t   attr->orig_dev,\n\t\t\t\t\t\t\t   attr->u.vlan_protocol);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_MROUTER:\n\t\terr = mlxsw_sp_port_attr_mrouter_set(mlxsw_sp_port,\n\t\t\t\t\t\t     attr->orig_dev,\n\t\t\t\t\t\t     attr->u.mrouter);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED:\n\t\terr = mlxsw_sp_port_mc_disabled_set(mlxsw_sp_port,\n\t\t\t\t\t\t    attr->orig_dev,\n\t\t\t\t\t\t    attr->u.mc_disabled);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_MROUTER:\n\t\terr = mlxsw_sp_port_attr_br_mrouter_set(mlxsw_sp_port,\n\t\t\t\t\t\t\tattr->orig_dev,\n\t\t\t\t\t\t\tattr->u.mrouter);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmlxsw_sp_span_respin(mlxsw_sp_port->mlxsw_sp);\n\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_port_vlan_fid_join(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan,\n\t\t\t    struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\tu16 vid = mlxsw_sp_port_vlan->vid;\n\tstruct mlxsw_sp_fid *fid;\n\tint err;\n\n\tbridge_device = bridge_port->bridge_device;\n\tfid = bridge_device->ops->fid_get(bridge_device, vid, extack);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\terr = mlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_UC, local_port,\n\t\t\t\t     bridge_port->flags & BR_FLOOD);\n\tif (err)\n\t\tgoto err_fid_uc_flood_set;\n\n\terr = mlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_MC, local_port,\n\t\t\t\t     mlxsw_sp_mc_flood(bridge_port));\n\tif (err)\n\t\tgoto err_fid_mc_flood_set;\n\n\terr = mlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_BC, local_port,\n\t\t\t\t     true);\n\tif (err)\n\t\tgoto err_fid_bc_flood_set;\n\n\terr = mlxsw_sp_fid_port_vid_map(fid, mlxsw_sp_port, vid);\n\tif (err)\n\t\tgoto err_fid_port_vid_map;\n\n\tmlxsw_sp_port_vlan->fid = fid;\n\n\treturn 0;\n\nerr_fid_port_vid_map:\n\tmlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_BC, local_port, false);\nerr_fid_bc_flood_set:\n\tmlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_MC, local_port, false);\nerr_fid_mc_flood_set:\n\tmlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_UC, local_port, false);\nerr_fid_uc_flood_set:\n\tmlxsw_sp_fid_put(fid);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_port_vlan_fid_leave(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;\n\tstruct mlxsw_sp_fid *fid = mlxsw_sp_port_vlan->fid;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\tu16 vid = mlxsw_sp_port_vlan->vid;\n\n\tmlxsw_sp_port_vlan->fid = NULL;\n\tmlxsw_sp_fid_port_vid_unmap(fid, mlxsw_sp_port, vid);\n\tmlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_BC, local_port, false);\n\tmlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_MC, local_port, false);\n\tmlxsw_sp_fid_flood_set(fid, MLXSW_SP_FLOOD_TYPE_UC, local_port, false);\n\tmlxsw_sp_fid_put(fid);\n}\n\nstatic u16\nmlxsw_sp_port_pvid_determine(const struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t     u16 vid, bool is_pvid)\n{\n\tif (is_pvid)\n\t\treturn vid;\n\telse if (mlxsw_sp_port->pvid == vid)\n\t\treturn 0;\t \n\telse\n\t\treturn mlxsw_sp_port->pvid;\n}\n\nstatic int\nmlxsw_sp_port_vlan_bridge_join(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan,\n\t\t\t       struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;\n\tstruct mlxsw_sp_bridge_vlan *bridge_vlan;\n\tu16 vid = mlxsw_sp_port_vlan->vid;\n\tint err;\n\n\t \n\tif (mlxsw_sp_port_vlan->bridge_port)\n\t\treturn 0;\n\n\terr = mlxsw_sp_port_vlan_fid_join(mlxsw_sp_port_vlan, bridge_port,\n\t\t\t\t\t  extack);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid,\n\t\t\t\t\t     bridge_port->flags & BR_LEARNING);\n\tif (err)\n\t\tgoto err_port_vid_learning_set;\n\n\terr = mlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid,\n\t\t\t\t\tbridge_port->stp_state);\n\tif (err)\n\t\tgoto err_port_vid_stp_set;\n\n\tbridge_vlan = mlxsw_sp_bridge_vlan_get(bridge_port, vid);\n\tif (!bridge_vlan) {\n\t\terr = -ENOMEM;\n\t\tgoto err_bridge_vlan_get;\n\t}\n\n\tlist_add(&mlxsw_sp_port_vlan->bridge_vlan_node,\n\t\t &bridge_vlan->port_vlan_list);\n\n\tmlxsw_sp_bridge_port_get(mlxsw_sp_port->mlxsw_sp->bridge,\n\t\t\t\t bridge_port->dev, extack);\n\tmlxsw_sp_port_vlan->bridge_port = bridge_port;\n\n\treturn 0;\n\nerr_bridge_vlan_get:\n\tmlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid, BR_STATE_DISABLED);\nerr_port_vid_stp_set:\n\tmlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, false);\nerr_port_vid_learning_set:\n\tmlxsw_sp_port_vlan_fid_leave(mlxsw_sp_port_vlan);\n\treturn err;\n}\n\nvoid\nmlxsw_sp_port_vlan_bridge_leave(struct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = mlxsw_sp_port_vlan->mlxsw_sp_port;\n\tstruct mlxsw_sp_fid *fid = mlxsw_sp_port_vlan->fid;\n\tstruct mlxsw_sp_bridge_vlan *bridge_vlan;\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tu16 vid = mlxsw_sp_port_vlan->vid;\n\tbool last_port;\n\n\tif (WARN_ON(mlxsw_sp_fid_type(fid) != MLXSW_SP_FID_TYPE_8021Q &&\n\t\t    mlxsw_sp_fid_type(fid) != MLXSW_SP_FID_TYPE_8021D))\n\t\treturn;\n\n\tbridge_port = mlxsw_sp_port_vlan->bridge_port;\n\tbridge_vlan = mlxsw_sp_bridge_vlan_find(bridge_port, vid);\n\tlast_port = list_is_singular(&bridge_vlan->port_vlan_list);\n\n\tlist_del(&mlxsw_sp_port_vlan->bridge_vlan_node);\n\tmlxsw_sp_bridge_vlan_put(bridge_vlan);\n\tmlxsw_sp_port_vid_stp_set(mlxsw_sp_port, vid, BR_STATE_DISABLED);\n\tmlxsw_sp_port_vid_learning_set(mlxsw_sp_port, vid, false);\n\tif (last_port)\n\t\tmlxsw_sp_bridge_port_fdb_flush(mlxsw_sp_port->mlxsw_sp,\n\t\t\t\t\t       bridge_port,\n\t\t\t\t\t       mlxsw_sp_fid_index(fid));\n\n\tmlxsw_sp_bridge_port_mdb_flush(mlxsw_sp_port, bridge_port,\n\t\t\t\t       mlxsw_sp_fid_index(fid));\n\n\tmlxsw_sp_port_vlan_fid_leave(mlxsw_sp_port_vlan);\n\n\tmlxsw_sp_bridge_port_put(mlxsw_sp_port->mlxsw_sp->bridge, bridge_port);\n\tmlxsw_sp_port_vlan->bridge_port = NULL;\n}\n\nstatic int\nmlxsw_sp_bridge_port_vlan_add(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t      struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t      u16 vid, bool is_untagged, bool is_pvid,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tu16 pvid = mlxsw_sp_port_pvid_determine(mlxsw_sp_port, vid, is_pvid);\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tu16 old_pvid = mlxsw_sp_port->pvid;\n\tu16 proto;\n\tint err;\n\n\t \n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);\n\tif (mlxsw_sp_port_vlan &&\n\t    mlxsw_sp_port_vlan->bridge_port != bridge_port)\n\t\treturn -EEXIST;\n\n\tif (!mlxsw_sp_port_vlan) {\n\t\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_create(mlxsw_sp_port,\n\t\t\t\t\t\t\t       vid);\n\t\tif (IS_ERR(mlxsw_sp_port_vlan))\n\t\t\treturn PTR_ERR(mlxsw_sp_port_vlan);\n\t}\n\n\terr = mlxsw_sp_port_vlan_set(mlxsw_sp_port, vid, vid, true,\n\t\t\t\t     is_untagged);\n\tif (err)\n\t\tgoto err_port_vlan_set;\n\n\tbr_vlan_get_proto(bridge_port->bridge_device->dev, &proto);\n\terr = mlxsw_sp_port_pvid_set(mlxsw_sp_port, pvid, proto);\n\tif (err)\n\t\tgoto err_port_pvid_set;\n\n\terr = mlxsw_sp_port_vlan_bridge_join(mlxsw_sp_port_vlan, bridge_port,\n\t\t\t\t\t     extack);\n\tif (err)\n\t\tgoto err_port_vlan_bridge_join;\n\n\treturn 0;\n\nerr_port_vlan_bridge_join:\n\tmlxsw_sp_port_pvid_set(mlxsw_sp_port, old_pvid, proto);\nerr_port_pvid_set:\n\tmlxsw_sp_port_vlan_set(mlxsw_sp_port, vid, vid, false, false);\nerr_port_vlan_set:\n\tmlxsw_sp_port_vlan_destroy(mlxsw_sp_port_vlan);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_br_rif_pvid_change(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct net_device *br_dev,\n\t\t\t    const struct switchdev_obj_port_vlan *vlan,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tbool flag_pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\n\treturn mlxsw_sp_router_bridge_vlan_add(mlxsw_sp, br_dev, vlan->vid,\n\t\t\t\t\t       flag_pvid, extack);\n}\n\nstatic int mlxsw_sp_port_vlans_add(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t   const struct switchdev_obj_port_vlan *vlan,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tbool flag_untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tbool flag_pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct net_device *orig_dev = vlan->obj.orig_dev;\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\n\tif (netif_is_bridge_master(orig_dev)) {\n\t\tint err = 0;\n\n\t\tif (br_vlan_enabled(orig_dev))\n\t\t\terr = mlxsw_sp_br_rif_pvid_change(mlxsw_sp, orig_dev,\n\t\t\t\t\t\t\t  vlan, extack);\n\t\tif (!err)\n\t\t\terr = -EOPNOTSUPP;\n\t\treturn err;\n\t}\n\n\tbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp->bridge, orig_dev);\n\tif (WARN_ON(!bridge_port))\n\t\treturn -EINVAL;\n\n\tif (!bridge_port->bridge_device->vlan_enabled)\n\t\treturn 0;\n\n\treturn mlxsw_sp_bridge_port_vlan_add(mlxsw_sp_port, bridge_port,\n\t\t\t\t\t     vlan->vid, flag_untagged,\n\t\t\t\t\t     flag_pvid, extack);\n}\n\nstatic enum mlxsw_reg_sfdf_flush_type mlxsw_sp_fdb_flush_type(bool lagged)\n{\n\treturn lagged ? MLXSW_REG_SFDF_FLUSH_PER_LAG_AND_FID :\n\t\t\tMLXSW_REG_SFDF_FLUSH_PER_PORT_AND_FID;\n}\n\nstatic int\nmlxsw_sp_bridge_port_fdb_flush(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t       u16 fid_index)\n{\n\tbool lagged = bridge_port->lagged;\n\tchar sfdf_pl[MLXSW_REG_SFDF_LEN];\n\tu16 system_port;\n\n\tsystem_port = lagged ? bridge_port->lag_id : bridge_port->system_port;\n\tmlxsw_reg_sfdf_pack(sfdf_pl, mlxsw_sp_fdb_flush_type(lagged));\n\tmlxsw_reg_sfdf_fid_set(sfdf_pl, fid_index);\n\tmlxsw_reg_sfdf_port_fid_system_port_set(sfdf_pl, system_port);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfdf), sfdf_pl);\n}\n\nstatic enum mlxsw_reg_sfd_rec_policy mlxsw_sp_sfd_rec_policy(bool dynamic)\n{\n\treturn dynamic ? MLXSW_REG_SFD_REC_POLICY_DYNAMIC_ENTRY_INGRESS :\n\t\t\t MLXSW_REG_SFD_REC_POLICY_DYNAMIC_ENTRY_MLAG;\n}\n\nstatic enum mlxsw_reg_sfd_op mlxsw_sp_sfd_op(bool adding)\n{\n\treturn adding ? MLXSW_REG_SFD_OP_WRITE_EDIT :\n\t\t\tMLXSW_REG_SFD_OP_WRITE_REMOVE;\n}\n\nstatic int\nmlxsw_sp_port_fdb_tun_uc_op4(struct mlxsw_sp *mlxsw_sp, bool dynamic,\n\t\t\t     const char *mac, u16 fid, __be32 addr, bool adding)\n{\n\tchar *sfd_pl;\n\tu8 num_rec;\n\tu32 uip;\n\tint err;\n\n\tsfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);\n\tif (!sfd_pl)\n\t\treturn -ENOMEM;\n\n\tuip = be32_to_cpu(addr);\n\tmlxsw_reg_sfd_pack(sfd_pl, mlxsw_sp_sfd_op(adding), 0);\n\tmlxsw_reg_sfd_uc_tunnel_pack4(sfd_pl, 0,\n\t\t\t\t      mlxsw_sp_sfd_rec_policy(dynamic), mac,\n\t\t\t\t      fid, MLXSW_REG_SFD_REC_ACTION_NOP, uip);\n\tnum_rec = mlxsw_reg_sfd_num_rec_get(sfd_pl);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfd), sfd_pl);\n\tif (err)\n\t\tgoto out;\n\n\tif (num_rec != mlxsw_reg_sfd_num_rec_get(sfd_pl))\n\t\terr = -EBUSY;\n\nout:\n\tkfree(sfd_pl);\n\treturn err;\n}\n\nstatic int mlxsw_sp_port_fdb_tun_uc_op6_sfd_write(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t  const char *mac, u16 fid,\n\t\t\t\t\t\t  u32 kvdl_index, bool adding)\n{\n\tchar *sfd_pl;\n\tu8 num_rec;\n\tint err;\n\n\tsfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);\n\tif (!sfd_pl)\n\t\treturn -ENOMEM;\n\n\tmlxsw_reg_sfd_pack(sfd_pl, mlxsw_sp_sfd_op(adding), 0);\n\tmlxsw_reg_sfd_uc_tunnel_pack6(sfd_pl, 0, mac, fid,\n\t\t\t\t      MLXSW_REG_SFD_REC_ACTION_NOP, kvdl_index);\n\tnum_rec = mlxsw_reg_sfd_num_rec_get(sfd_pl);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfd), sfd_pl);\n\tif (err)\n\t\tgoto out;\n\n\tif (num_rec != mlxsw_reg_sfd_num_rec_get(sfd_pl))\n\t\terr = -EBUSY;\n\nout:\n\tkfree(sfd_pl);\n\treturn err;\n}\n\nstatic int mlxsw_sp_port_fdb_tun_uc_op6_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    const char *mac, u16 fid,\n\t\t\t\t\t    const struct in6_addr *addr)\n{\n\tu32 kvdl_index;\n\tint err;\n\n\terr = mlxsw_sp_nve_ipv6_addr_kvdl_set(mlxsw_sp, addr, &kvdl_index);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_port_fdb_tun_uc_op6_sfd_write(mlxsw_sp, mac, fid,\n\t\t\t\t\t\t     kvdl_index, true);\n\tif (err)\n\t\tgoto err_sfd_write;\n\n\terr = mlxsw_sp_nve_ipv6_addr_map_replace(mlxsw_sp, mac, fid, addr);\n\tif (err)\n\t\t \n\t\tgoto err_addr_replace;\n\n\treturn 0;\n\nerr_addr_replace:\n\tmlxsw_sp_port_fdb_tun_uc_op6_sfd_write(mlxsw_sp, mac, fid, kvdl_index,\n\t\t\t\t\t       false);\nerr_sfd_write:\n\tmlxsw_sp_nve_ipv6_addr_kvdl_unset(mlxsw_sp, addr);\n\treturn err;\n}\n\nstatic void mlxsw_sp_port_fdb_tun_uc_op6_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t     const char *mac, u16 fid,\n\t\t\t\t\t     const struct in6_addr *addr)\n{\n\tmlxsw_sp_nve_ipv6_addr_map_del(mlxsw_sp, mac, fid);\n\tmlxsw_sp_port_fdb_tun_uc_op6_sfd_write(mlxsw_sp, mac, fid, 0, false);\n\tmlxsw_sp_nve_ipv6_addr_kvdl_unset(mlxsw_sp, addr);\n}\n\nstatic int\nmlxsw_sp_port_fdb_tun_uc_op6(struct mlxsw_sp *mlxsw_sp, const char *mac,\n\t\t\t     u16 fid, const struct in6_addr *addr, bool adding)\n{\n\tif (adding)\n\t\treturn mlxsw_sp_port_fdb_tun_uc_op6_add(mlxsw_sp, mac, fid,\n\t\t\t\t\t\t\taddr);\n\n\tmlxsw_sp_port_fdb_tun_uc_op6_del(mlxsw_sp, mac, fid, addr);\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_fdb_tunnel_uc_op(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  const char *mac, u16 fid,\n\t\t\t\t\t  enum mlxsw_sp_l3proto proto,\n\t\t\t\t\t  const union mlxsw_sp_l3addr *addr,\n\t\t\t\t\t  bool adding, bool dynamic)\n{\n\tswitch (proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\treturn mlxsw_sp_port_fdb_tun_uc_op4(mlxsw_sp, dynamic, mac, fid,\n\t\t\t\t\t\t    addr->addr4, adding);\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\treturn mlxsw_sp_port_fdb_tun_uc_op6(mlxsw_sp, mac, fid,\n\t\t\t\t\t\t    &addr->addr6, adding);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int __mlxsw_sp_port_fdb_uc_op(struct mlxsw_sp *mlxsw_sp, u16 local_port,\n\t\t\t\t     const char *mac, u16 fid, u16 vid,\n\t\t\t\t     bool adding,\n\t\t\t\t     enum mlxsw_reg_sfd_rec_action action,\n\t\t\t\t     enum mlxsw_reg_sfd_rec_policy policy)\n{\n\tchar *sfd_pl;\n\tu8 num_rec;\n\tint err;\n\n\tsfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);\n\tif (!sfd_pl)\n\t\treturn -ENOMEM;\n\n\tmlxsw_reg_sfd_pack(sfd_pl, mlxsw_sp_sfd_op(adding), 0);\n\tmlxsw_reg_sfd_uc_pack(sfd_pl, 0, policy, mac, fid, vid, action,\n\t\t\t      local_port);\n\tnum_rec = mlxsw_reg_sfd_num_rec_get(sfd_pl);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfd), sfd_pl);\n\tif (err)\n\t\tgoto out;\n\n\tif (num_rec != mlxsw_reg_sfd_num_rec_get(sfd_pl))\n\t\terr = -EBUSY;\n\nout:\n\tkfree(sfd_pl);\n\treturn err;\n}\n\nstatic int mlxsw_sp_port_fdb_uc_op(struct mlxsw_sp *mlxsw_sp, u16 local_port,\n\t\t\t\t   const char *mac, u16 fid, u16 vid,\n\t\t\t\t   bool adding, bool dynamic)\n{\n\treturn __mlxsw_sp_port_fdb_uc_op(mlxsw_sp, local_port, mac, fid, vid,\n\t\t\t\t\t adding, MLXSW_REG_SFD_REC_ACTION_NOP,\n\t\t\t\t\t mlxsw_sp_sfd_rec_policy(dynamic));\n}\n\nint mlxsw_sp_rif_fdb_op(struct mlxsw_sp *mlxsw_sp, const char *mac, u16 fid,\n\t\t\tbool adding)\n{\n\treturn __mlxsw_sp_port_fdb_uc_op(mlxsw_sp, 0, mac, fid, 0, adding,\n\t\t\t\t\t MLXSW_REG_SFD_REC_ACTION_FORWARD_IP_ROUTER,\n\t\t\t\t\t MLXSW_REG_SFD_REC_POLICY_STATIC_ENTRY);\n}\n\nstatic int mlxsw_sp_port_fdb_uc_lag_op(struct mlxsw_sp *mlxsw_sp, u16 lag_id,\n\t\t\t\t       const char *mac, u16 fid, u16 lag_vid,\n\t\t\t\t       bool adding, bool dynamic)\n{\n\tchar *sfd_pl;\n\tu8 num_rec;\n\tint err;\n\n\tsfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);\n\tif (!sfd_pl)\n\t\treturn -ENOMEM;\n\n\tmlxsw_reg_sfd_pack(sfd_pl, mlxsw_sp_sfd_op(adding), 0);\n\tmlxsw_reg_sfd_uc_lag_pack(sfd_pl, 0, mlxsw_sp_sfd_rec_policy(dynamic),\n\t\t\t\t  mac, fid, MLXSW_REG_SFD_REC_ACTION_NOP,\n\t\t\t\t  lag_vid, lag_id);\n\tnum_rec = mlxsw_reg_sfd_num_rec_get(sfd_pl);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfd), sfd_pl);\n\tif (err)\n\t\tgoto out;\n\n\tif (num_rec != mlxsw_reg_sfd_num_rec_get(sfd_pl))\n\t\terr = -EBUSY;\n\nout:\n\tkfree(sfd_pl);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_port_fdb_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t      struct switchdev_notifier_fdb_info *fdb_info, bool adding)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct net_device *orig_dev = fdb_info->info.dev;\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tu16 fid_index, vid;\n\n\tbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp->bridge, orig_dev);\n\tif (!bridge_port)\n\t\treturn -EINVAL;\n\n\tbridge_device = bridge_port->bridge_device;\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_bridge(mlxsw_sp_port,\n\t\t\t\t\t\t\t       bridge_device,\n\t\t\t\t\t\t\t       fdb_info->vid);\n\tif (!mlxsw_sp_port_vlan)\n\t\treturn 0;\n\n\tfid_index = mlxsw_sp_fid_index(mlxsw_sp_port_vlan->fid);\n\tvid = mlxsw_sp_port_vlan->vid;\n\n\tif (!bridge_port->lagged)\n\t\treturn mlxsw_sp_port_fdb_uc_op(mlxsw_sp,\n\t\t\t\t\t       bridge_port->system_port,\n\t\t\t\t\t       fdb_info->addr, fid_index, vid,\n\t\t\t\t\t       adding, false);\n\telse\n\t\treturn mlxsw_sp_port_fdb_uc_lag_op(mlxsw_sp,\n\t\t\t\t\t\t   bridge_port->lag_id,\n\t\t\t\t\t\t   fdb_info->addr, fid_index,\n\t\t\t\t\t\t   vid, adding, false);\n}\n\nstatic int mlxsw_sp_mdb_entry_write(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    const struct mlxsw_sp_mdb_entry *mdb_entry,\n\t\t\t\t    bool adding)\n{\n\tchar *sfd_pl;\n\tu8 num_rec;\n\tint err;\n\n\tsfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);\n\tif (!sfd_pl)\n\t\treturn -ENOMEM;\n\n\tmlxsw_reg_sfd_pack(sfd_pl, mlxsw_sp_sfd_op(adding), 0);\n\tmlxsw_reg_sfd_mc_pack(sfd_pl, 0, mdb_entry->key.addr,\n\t\t\t      mdb_entry->key.fid, MLXSW_REG_SFD_REC_ACTION_NOP,\n\t\t\t      mdb_entry->mid);\n\tnum_rec = mlxsw_reg_sfd_num_rec_get(sfd_pl);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(sfd), sfd_pl);\n\tif (err)\n\t\tgoto out;\n\n\tif (num_rec != mlxsw_reg_sfd_num_rec_get(sfd_pl))\n\t\terr = -EBUSY;\n\nout:\n\tkfree(sfd_pl);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_bridge_port_get_ports_bitmap(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\t      struct mlxsw_sp_ports_bitmap *ports_bm)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tu64 max_lag_members, i;\n\tint lag_id;\n\n\tif (!bridge_port->lagged) {\n\t\tset_bit(bridge_port->system_port, ports_bm->bitmap);\n\t} else {\n\t\tmax_lag_members = MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t\t\t     MAX_LAG_MEMBERS);\n\t\tlag_id = bridge_port->lag_id;\n\t\tfor (i = 0; i < max_lag_members; i++) {\n\t\t\tmlxsw_sp_port = mlxsw_sp_port_lagged_get(mlxsw_sp,\n\t\t\t\t\t\t\t\t lag_id, i);\n\t\t\tif (mlxsw_sp_port)\n\t\t\t\tset_bit(mlxsw_sp_port->local_port,\n\t\t\t\t\tports_bm->bitmap);\n\t\t}\n\t}\n}\n\nstatic void\nmlxsw_sp_mc_get_mrouters_bitmap(struct mlxsw_sp_ports_bitmap *flood_bm,\n\t\t\t\tstruct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\tstruct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\n\tlist_for_each_entry(bridge_port, &bridge_device->ports_list, list) {\n\t\tif (bridge_port->mrouter) {\n\t\t\tmlxsw_sp_bridge_port_get_ports_bitmap(mlxsw_sp,\n\t\t\t\t\t\t\t      bridge_port,\n\t\t\t\t\t\t\t      flood_bm);\n\t\t}\n\t}\n}\n\nstatic int mlxsw_sp_mc_mdb_mrouters_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_ports_bitmap *ports_bm,\n\t\t\t\t\tstruct mlxsw_sp_mdb_entry *mdb_entry)\n{\n\tstruct mlxsw_sp_mdb_entry_port *mdb_entry_port;\n\tunsigned int nbits = ports_bm->nbits;\n\tint i;\n\n\tfor_each_set_bit(i, ports_bm->bitmap, nbits) {\n\t\tmdb_entry_port = mlxsw_sp_mdb_entry_mrouter_port_get(mlxsw_sp,\n\t\t\t\t\t\t\t\t     mdb_entry,\n\t\t\t\t\t\t\t\t     i);\n\t\tif (IS_ERR(mdb_entry_port)) {\n\t\t\tnbits = i;\n\t\t\tgoto err_mrouter_port_get;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_mrouter_port_get:\n\tfor_each_set_bit(i, ports_bm->bitmap, nbits)\n\t\tmlxsw_sp_mdb_entry_mrouter_port_put(mlxsw_sp, mdb_entry, i);\n\treturn PTR_ERR(mdb_entry_port);\n}\n\nstatic void mlxsw_sp_mc_mdb_mrouters_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t struct mlxsw_sp_ports_bitmap *ports_bm,\n\t\t\t\t\t struct mlxsw_sp_mdb_entry *mdb_entry)\n{\n\tint i;\n\n\tfor_each_set_bit(i, ports_bm->bitmap, ports_bm->nbits)\n\t\tmlxsw_sp_mdb_entry_mrouter_port_put(mlxsw_sp, mdb_entry, i);\n}\n\nstatic int\nmlxsw_sp_mc_mdb_mrouters_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t     struct mlxsw_sp_mdb_entry *mdb_entry, bool add)\n{\n\tstruct mlxsw_sp_ports_bitmap ports_bm;\n\tint err;\n\n\terr = mlxsw_sp_port_bitmap_init(mlxsw_sp, &ports_bm);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_sp_mc_get_mrouters_bitmap(&ports_bm, bridge_device, mlxsw_sp);\n\n\tif (add)\n\t\terr = mlxsw_sp_mc_mdb_mrouters_add(mlxsw_sp, &ports_bm,\n\t\t\t\t\t\t   mdb_entry);\n\telse\n\t\tmlxsw_sp_mc_mdb_mrouters_del(mlxsw_sp, &ports_bm, mdb_entry);\n\n\tmlxsw_sp_port_bitmap_fini(&ports_bm);\n\treturn err;\n}\n\nstatic struct mlxsw_sp_mdb_entry *\nmlxsw_sp_mc_mdb_entry_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t   const unsigned char *addr, u16 fid, u16 local_port)\n{\n\tstruct mlxsw_sp_mdb_entry_port *mdb_entry_port;\n\tstruct mlxsw_sp_mdb_entry *mdb_entry;\n\tint err;\n\n\tmdb_entry = kzalloc(sizeof(*mdb_entry), GFP_KERNEL);\n\tif (!mdb_entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tether_addr_copy(mdb_entry->key.addr, addr);\n\tmdb_entry->key.fid = fid;\n\terr = mlxsw_sp_pgt_mid_alloc(mlxsw_sp, &mdb_entry->mid);\n\tif (err)\n\t\tgoto err_pgt_mid_alloc;\n\n\tINIT_LIST_HEAD(&mdb_entry->ports_list);\n\n\terr = mlxsw_sp_mc_mdb_mrouters_set(mlxsw_sp, bridge_device, mdb_entry,\n\t\t\t\t\t   true);\n\tif (err)\n\t\tgoto err_mdb_mrouters_set;\n\n\tmdb_entry_port = mlxsw_sp_mdb_entry_port_get(mlxsw_sp, mdb_entry,\n\t\t\t\t\t\t     local_port);\n\tif (IS_ERR(mdb_entry_port)) {\n\t\terr = PTR_ERR(mdb_entry_port);\n\t\tgoto err_mdb_entry_port_get;\n\t}\n\n\tif (bridge_device->multicast_enabled) {\n\t\terr = mlxsw_sp_mdb_entry_write(mlxsw_sp, mdb_entry, true);\n\t\tif (err)\n\t\t\tgoto err_mdb_entry_write;\n\t}\n\n\terr = rhashtable_insert_fast(&bridge_device->mdb_ht,\n\t\t\t\t     &mdb_entry->ht_node,\n\t\t\t\t     mlxsw_sp_mdb_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_insert;\n\n\tlist_add_tail(&mdb_entry->list, &bridge_device->mdb_list);\n\n\treturn mdb_entry;\n\nerr_rhashtable_insert:\n\tif (bridge_device->multicast_enabled)\n\t\tmlxsw_sp_mdb_entry_write(mlxsw_sp, mdb_entry, false);\nerr_mdb_entry_write:\n\tmlxsw_sp_mdb_entry_port_put(mlxsw_sp, mdb_entry, local_port, false);\nerr_mdb_entry_port_get:\n\tmlxsw_sp_mc_mdb_mrouters_set(mlxsw_sp, bridge_device, mdb_entry, false);\nerr_mdb_mrouters_set:\n\tmlxsw_sp_pgt_mid_free(mlxsw_sp, mdb_entry->mid);\nerr_pgt_mid_alloc:\n\tkfree(mdb_entry);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_mc_mdb_entry_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   struct mlxsw_sp_mdb_entry *mdb_entry,\n\t\t\t   struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t   u16 local_port, bool force)\n{\n\tlist_del(&mdb_entry->list);\n\trhashtable_remove_fast(&bridge_device->mdb_ht, &mdb_entry->ht_node,\n\t\t\t       mlxsw_sp_mdb_ht_params);\n\tif (bridge_device->multicast_enabled)\n\t\tmlxsw_sp_mdb_entry_write(mlxsw_sp, mdb_entry, false);\n\tmlxsw_sp_mdb_entry_port_put(mlxsw_sp, mdb_entry, local_port, force);\n\tmlxsw_sp_mc_mdb_mrouters_set(mlxsw_sp, bridge_device, mdb_entry, false);\n\tWARN_ON(!list_empty(&mdb_entry->ports_list));\n\tmlxsw_sp_pgt_mid_free(mlxsw_sp, mdb_entry->mid);\n\tkfree(mdb_entry);\n}\n\nstatic struct mlxsw_sp_mdb_entry *\nmlxsw_sp_mc_mdb_entry_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t  const unsigned char *addr, u16 fid, u16 local_port)\n{\n\tstruct mlxsw_sp_mdb_entry_key key = {};\n\tstruct mlxsw_sp_mdb_entry *mdb_entry;\n\n\tether_addr_copy(key.addr, addr);\n\tkey.fid = fid;\n\tmdb_entry = rhashtable_lookup_fast(&bridge_device->mdb_ht, &key,\n\t\t\t\t\t   mlxsw_sp_mdb_ht_params);\n\tif (mdb_entry) {\n\t\tstruct mlxsw_sp_mdb_entry_port *mdb_entry_port;\n\n\t\tmdb_entry_port = mlxsw_sp_mdb_entry_port_get(mlxsw_sp,\n\t\t\t\t\t\t\t     mdb_entry,\n\t\t\t\t\t\t\t     local_port);\n\t\tif (IS_ERR(mdb_entry_port))\n\t\t\treturn ERR_CAST(mdb_entry_port);\n\n\t\treturn mdb_entry;\n\t}\n\n\treturn mlxsw_sp_mc_mdb_entry_init(mlxsw_sp, bridge_device, addr, fid,\n\t\t\t\t\t  local_port);\n}\n\nstatic bool\nmlxsw_sp_mc_mdb_entry_remove(struct mlxsw_sp_mdb_entry *mdb_entry,\n\t\t\t     struct mlxsw_sp_mdb_entry_port *removed_entry_port,\n\t\t\t     bool force)\n{\n\tif (mdb_entry->ports_count > 1)\n\t\treturn false;\n\n\tif (force)\n\t\treturn true;\n\n\tif (!removed_entry_port->mrouter &&\n\t    refcount_read(&removed_entry_port->refcount) > 1)\n\t\treturn false;\n\n\tif (removed_entry_port->mrouter &&\n\t    refcount_read(&removed_entry_port->refcount) > 2)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void\nmlxsw_sp_mc_mdb_entry_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t  struct mlxsw_sp_mdb_entry *mdb_entry, u16 local_port,\n\t\t\t  bool force)\n{\n\tstruct mlxsw_sp_mdb_entry_port *mdb_entry_port;\n\n\tmdb_entry_port = mlxsw_sp_mdb_entry_port_lookup(mdb_entry, local_port);\n\tif (!mdb_entry_port)\n\t\treturn;\n\n\t \n\tif (mlxsw_sp_mc_mdb_entry_remove(mdb_entry, mdb_entry_port, force))\n\t\tmlxsw_sp_mc_mdb_entry_fini(mlxsw_sp, mdb_entry, bridge_device,\n\t\t\t\t\t   local_port, force);\n\telse\n\t\tmlxsw_sp_mdb_entry_port_put(mlxsw_sp, mdb_entry, local_port,\n\t\t\t\t\t    force);\n}\n\nstatic int mlxsw_sp_port_mdb_add(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct net_device *orig_dev = mdb->obj.orig_dev;\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tstruct mlxsw_sp_mdb_entry *mdb_entry;\n\tu16 fid_index;\n\n\tbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp->bridge, orig_dev);\n\tif (!bridge_port)\n\t\treturn 0;\n\n\tbridge_device = bridge_port->bridge_device;\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_bridge(mlxsw_sp_port,\n\t\t\t\t\t\t\t       bridge_device,\n\t\t\t\t\t\t\t       mdb->vid);\n\tif (!mlxsw_sp_port_vlan)\n\t\treturn 0;\n\n\tfid_index = mlxsw_sp_fid_index(mlxsw_sp_port_vlan->fid);\n\n\tmdb_entry = mlxsw_sp_mc_mdb_entry_get(mlxsw_sp, bridge_device,\n\t\t\t\t\t      mdb->addr, fid_index,\n\t\t\t\t\t      mlxsw_sp_port->local_port);\n\tif (IS_ERR(mdb_entry))\n\t\treturn PTR_ERR(mdb_entry);\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_bridge_mdb_mc_enable_sync(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t   bool mc_enabled)\n{\n\tstruct mlxsw_sp_mdb_entry *mdb_entry;\n\tint err;\n\n\tlist_for_each_entry(mdb_entry, &bridge_device->mdb_list, list) {\n\t\terr = mlxsw_sp_mdb_entry_write(mlxsw_sp, mdb_entry, mc_enabled);\n\t\tif (err)\n\t\t\tgoto err_mdb_entry_write;\n\t}\n\treturn 0;\n\nerr_mdb_entry_write:\n\tlist_for_each_entry_continue_reverse(mdb_entry,\n\t\t\t\t\t     &bridge_device->mdb_list, list)\n\t\tmlxsw_sp_mdb_entry_write(mlxsw_sp, mdb_entry, !mc_enabled);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_port_mrouter_update_mdb(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\t bool add)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\tstruct mlxsw_sp_mdb_entry *mdb_entry;\n\n\tbridge_device = bridge_port->bridge_device;\n\n\tlist_for_each_entry(mdb_entry, &bridge_device->mdb_list, list) {\n\t\tif (add)\n\t\t\tmlxsw_sp_mdb_entry_mrouter_port_get(mlxsw_sp, mdb_entry,\n\t\t\t\t\t\t\t    local_port);\n\t\telse\n\t\t\tmlxsw_sp_mdb_entry_mrouter_port_put(mlxsw_sp, mdb_entry,\n\t\t\t\t\t\t\t    local_port);\n\t}\n}\n\nstatic int mlxsw_sp_port_obj_add(struct net_device *dev, const void *ctx,\n\t\t\t\t const struct switchdev_obj *obj,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tconst struct switchdev_obj_port_vlan *vlan;\n\tint err = 0;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\tvlan = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\n\t\terr = mlxsw_sp_port_vlans_add(mlxsw_sp_port, vlan, extack);\n\n\t\t \n\t\tmlxsw_sp_span_respin(mlxsw_sp_port->mlxsw_sp);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\t\terr = mlxsw_sp_port_mdb_add(mlxsw_sp_port,\n\t\t\t\t\t    SWITCHDEV_OBJ_PORT_MDB(obj));\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_bridge_port_vlan_del(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t      struct mlxsw_sp_bridge_port *bridge_port, u16 vid)\n{\n\tu16 pvid = mlxsw_sp_port->pvid == vid ? 0 : mlxsw_sp_port->pvid;\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tu16 proto;\n\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);\n\tif (WARN_ON(!mlxsw_sp_port_vlan))\n\t\treturn;\n\n\tmlxsw_sp_port_vlan_bridge_leave(mlxsw_sp_port_vlan);\n\tbr_vlan_get_proto(bridge_port->bridge_device->dev, &proto);\n\tmlxsw_sp_port_pvid_set(mlxsw_sp_port, pvid, proto);\n\tmlxsw_sp_port_vlan_set(mlxsw_sp_port, vid, vid, false, false);\n\tmlxsw_sp_port_vlan_destroy(mlxsw_sp_port_vlan);\n}\n\nstatic int mlxsw_sp_port_vlans_del(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t   const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct net_device *orig_dev = vlan->obj.orig_dev;\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\n\tif (netif_is_bridge_master(orig_dev))\n\t\treturn -EOPNOTSUPP;\n\n\tbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp->bridge, orig_dev);\n\tif (WARN_ON(!bridge_port))\n\t\treturn -EINVAL;\n\n\tif (!bridge_port->bridge_device->vlan_enabled)\n\t\treturn 0;\n\n\tmlxsw_sp_bridge_port_vlan_del(mlxsw_sp_port, bridge_port, vlan->vid);\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_mdb_del(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct net_device *orig_dev = mdb->obj.orig_dev;\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct net_device *dev = mlxsw_sp_port->dev;\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tstruct mlxsw_sp_mdb_entry_key key = {};\n\tstruct mlxsw_sp_mdb_entry *mdb_entry;\n\tu16 fid_index;\n\n\tbridge_port = mlxsw_sp_bridge_port_find(mlxsw_sp->bridge, orig_dev);\n\tif (!bridge_port)\n\t\treturn 0;\n\n\tbridge_device = bridge_port->bridge_device;\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_bridge(mlxsw_sp_port,\n\t\t\t\t\t\t\t       bridge_device,\n\t\t\t\t\t\t\t       mdb->vid);\n\tif (!mlxsw_sp_port_vlan)\n\t\treturn 0;\n\n\tfid_index = mlxsw_sp_fid_index(mlxsw_sp_port_vlan->fid);\n\n\tether_addr_copy(key.addr, mdb->addr);\n\tkey.fid = fid_index;\n\tmdb_entry = rhashtable_lookup_fast(&bridge_device->mdb_ht, &key,\n\t\t\t\t\t   mlxsw_sp_mdb_ht_params);\n\tif (!mdb_entry) {\n\t\tnetdev_err(dev, \"Unable to remove port from MC DB\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmlxsw_sp_mc_mdb_entry_put(mlxsw_sp, bridge_device, mdb_entry,\n\t\t\t\t  mlxsw_sp_port->local_port, false);\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_bridge_port_mdb_flush(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t       struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t       u16 fid_index)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct mlxsw_sp_mdb_entry *mdb_entry, *tmp;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\n\tbridge_device = bridge_port->bridge_device;\n\n\tlist_for_each_entry_safe(mdb_entry, tmp, &bridge_device->mdb_list,\n\t\t\t\t list) {\n\t\tif (mdb_entry->key.fid != fid_index)\n\t\t\tcontinue;\n\n\t\tif (bridge_port->mrouter)\n\t\t\tmlxsw_sp_mdb_entry_mrouter_port_put(mlxsw_sp,\n\t\t\t\t\t\t\t    mdb_entry,\n\t\t\t\t\t\t\t    local_port);\n\n\t\tmlxsw_sp_mc_mdb_entry_put(mlxsw_sp, bridge_device, mdb_entry,\n\t\t\t\t\t  local_port, true);\n\t}\n}\n\nstatic int mlxsw_sp_port_obj_del(struct net_device *dev, const void *ctx,\n\t\t\t\t const struct switchdev_obj *obj)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tint err = 0;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\terr = mlxsw_sp_port_vlans_del(mlxsw_sp_port,\n\t\t\t\t\t      SWITCHDEV_OBJ_PORT_VLAN(obj));\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\t\terr = mlxsw_sp_port_mdb_del(mlxsw_sp_port,\n\t\t\t\t\t    SWITCHDEV_OBJ_PORT_MDB(obj));\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmlxsw_sp_span_respin(mlxsw_sp_port->mlxsw_sp);\n\n\treturn err;\n}\n\nstatic struct mlxsw_sp_port *mlxsw_sp_lag_rep_port(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t   u16 lag_id)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tu64 max_lag_members;\n\tint i;\n\n\tmax_lag_members = MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t\t     MAX_LAG_MEMBERS);\n\tfor (i = 0; i < max_lag_members; i++) {\n\t\tmlxsw_sp_port = mlxsw_sp_port_lagged_get(mlxsw_sp, lag_id, i);\n\t\tif (mlxsw_sp_port)\n\t\t\treturn mlxsw_sp_port;\n\t}\n\treturn NULL;\n}\n\nstatic int\nmlxsw_sp_bridge_port_replay(struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t    struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_bridge_port_replay_switchdev_objs rso = {\n\t\t.brport_dev = bridge_port->dev,\n\t\t.mlxsw_sp_port = mlxsw_sp_port,\n\t};\n\tstruct notifier_block *nb;\n\tint err;\n\n\tnb = &mlxsw_sp_bridge_port_replay_switchdev_objs_nb;\n\terr = switchdev_bridge_port_replay(bridge_port->dev, mlxsw_sp_port->dev,\n\t\t\t\t\t   &rso, NULL, nb, extack);\n\tif (err)\n\t\tgoto err_replay;\n\n\treturn 0;\n\nerr_replay:\n\tnb = &mlxsw_sp_bridge_port_unreplay_switchdev_objs_nb;\n\tswitchdev_bridge_port_replay(bridge_port->dev, mlxsw_sp_port->dev,\n\t\t\t\t     &rso, NULL, nb, extack);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_bridge_vlan_aware_port_join(struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\t     struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tif (is_vlan_dev(bridge_port->dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Can not enslave a VLAN device to a VLAN-aware bridge\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mlxsw_sp_port->default_vlan->fid)\n\t\tmlxsw_sp_port_vlan_router_leave(mlxsw_sp_port->default_vlan);\n\n\treturn mlxsw_sp_bridge_port_replay(bridge_port, mlxsw_sp_port, extack);\n}\n\nstatic int\nmlxsw_sp_bridge_8021q_port_join(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\tstruct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\tstruct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\treturn mlxsw_sp_bridge_vlan_aware_port_join(bridge_port, mlxsw_sp_port,\n\t\t\t\t\t\t    extack);\n}\n\nstatic void\nmlxsw_sp_bridge_vlan_aware_port_leave(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\t \n\tmlxsw_sp_port_pvid_set(mlxsw_sp_port, MLXSW_SP_DEFAULT_VID,\n\t\t\t       ETH_P_8021Q);\n}\n\nstatic void\nmlxsw_sp_bridge_8021q_port_leave(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\t struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tmlxsw_sp_bridge_vlan_aware_port_leave(mlxsw_sp_port);\n}\n\nstatic int\nmlxsw_sp_bridge_vlan_aware_vxlan_join(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t      const struct net_device *vxlan_dev,\n\t\t\t\t      u16 vid, u16 ethertype,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(bridge_device->dev);\n\tstruct vxlan_dev *vxlan = netdev_priv(vxlan_dev);\n\tstruct mlxsw_sp_nve_params params = {\n\t\t.type = MLXSW_SP_NVE_TYPE_VXLAN,\n\t\t.vni = vxlan->cfg.vni,\n\t\t.dev = vxlan_dev,\n\t\t.ethertype = ethertype,\n\t};\n\tstruct mlxsw_sp_fid *fid;\n\tint err;\n\n\t \n\tif (!vid) {\n\t\terr = mlxsw_sp_vxlan_mapped_vid(vxlan_dev, &vid);\n\t\tif (err || !vid)\n\t\t\treturn err;\n\t}\n\n\tfid = mlxsw_sp_fid_8021q_get(mlxsw_sp, vid);\n\tif (IS_ERR(fid)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to create 802.1Q FID\");\n\t\treturn PTR_ERR(fid);\n\t}\n\n\tif (mlxsw_sp_fid_vni_is_set(fid)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VNI is already set on FID\");\n\t\terr = -EINVAL;\n\t\tgoto err_vni_exists;\n\t}\n\n\terr = mlxsw_sp_nve_fid_enable(mlxsw_sp, fid, &params, extack);\n\tif (err)\n\t\tgoto err_nve_fid_enable;\n\n\treturn 0;\n\nerr_nve_fid_enable:\nerr_vni_exists:\n\tmlxsw_sp_fid_put(fid);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_bridge_8021q_vxlan_join(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t const struct net_device *vxlan_dev, u16 vid,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn mlxsw_sp_bridge_vlan_aware_vxlan_join(bridge_device, vxlan_dev,\n\t\t\t\t\t\t     vid, ETH_P_8021Q, extack);\n}\n\nstatic struct net_device *\nmlxsw_sp_bridge_8021q_vxlan_dev_find(struct net_device *br_dev, u16 vid)\n{\n\tstruct net_device *dev;\n\tstruct list_head *iter;\n\n\tnetdev_for_each_lower_dev(br_dev, dev, iter) {\n\t\tu16 pvid;\n\t\tint err;\n\n\t\tif (!netif_is_vxlan(dev))\n\t\t\tcontinue;\n\n\t\terr = mlxsw_sp_vxlan_mapped_vid(dev, &pvid);\n\t\tif (err || pvid != vid)\n\t\t\tcontinue;\n\n\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mlxsw_sp_fid *\nmlxsw_sp_bridge_8021q_fid_get(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t      u16 vid, struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(bridge_device->dev);\n\n\treturn mlxsw_sp_fid_8021q_get(mlxsw_sp, vid);\n}\n\nstatic struct mlxsw_sp_fid *\nmlxsw_sp_bridge_8021q_fid_lookup(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t u16 vid)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(bridge_device->dev);\n\n\treturn mlxsw_sp_fid_8021q_lookup(mlxsw_sp, vid);\n}\n\nstatic u16\nmlxsw_sp_bridge_8021q_fid_vid(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t      const struct mlxsw_sp_fid *fid)\n{\n\treturn mlxsw_sp_fid_8021q_vid(fid);\n}\n\nstatic const struct mlxsw_sp_bridge_ops mlxsw_sp_bridge_8021q_ops = {\n\t.port_join\t= mlxsw_sp_bridge_8021q_port_join,\n\t.port_leave\t= mlxsw_sp_bridge_8021q_port_leave,\n\t.vxlan_join\t= mlxsw_sp_bridge_8021q_vxlan_join,\n\t.fid_get\t= mlxsw_sp_bridge_8021q_fid_get,\n\t.fid_lookup\t= mlxsw_sp_bridge_8021q_fid_lookup,\n\t.fid_vid\t= mlxsw_sp_bridge_8021q_fid_vid,\n};\n\nstatic bool\nmlxsw_sp_port_is_br_member(const struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t   const struct net_device *br_dev)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\n\tlist_for_each_entry(mlxsw_sp_port_vlan, &mlxsw_sp_port->vlans_list,\n\t\t\t    list) {\n\t\tif (mlxsw_sp_port_vlan->bridge_port &&\n\t\t    mlxsw_sp_port_vlan->bridge_port->bridge_device->dev ==\n\t\t    br_dev)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int\nmlxsw_sp_bridge_8021d_port_join(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\tstruct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\tstruct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tstruct net_device *dev = bridge_port->dev;\n\tu16 vid;\n\tint err;\n\n\tvid = is_vlan_dev(dev) ? vlan_dev_vlan_id(dev) : MLXSW_SP_DEFAULT_VID;\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);\n\tif (WARN_ON(!mlxsw_sp_port_vlan))\n\t\treturn -EINVAL;\n\n\tif (mlxsw_sp_port_is_br_member(mlxsw_sp_port, bridge_device->dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Can not bridge VLAN uppers of the same port\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mlxsw_sp_port_vlan->fid)\n\t\tmlxsw_sp_port_vlan_router_leave(mlxsw_sp_port_vlan);\n\n\terr = mlxsw_sp_port_vlan_bridge_join(mlxsw_sp_port_vlan, bridge_port,\n\t\t\t\t\t     extack);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_bridge_port_replay(bridge_port, mlxsw_sp_port, extack);\n\tif (err)\n\t\tgoto err_replay;\n\n\treturn 0;\n\nerr_replay:\n\tmlxsw_sp_port_vlan_bridge_leave(mlxsw_sp_port_vlan);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_bridge_8021d_port_leave(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\t struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tstruct net_device *dev = bridge_port->dev;\n\tu16 vid;\n\n\tvid = is_vlan_dev(dev) ? vlan_dev_vlan_id(dev) : MLXSW_SP_DEFAULT_VID;\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_vid(mlxsw_sp_port, vid);\n\tif (!mlxsw_sp_port_vlan || !mlxsw_sp_port_vlan->bridge_port)\n\t\treturn;\n\n\tmlxsw_sp_port_vlan_bridge_leave(mlxsw_sp_port_vlan);\n}\n\nstatic int\nmlxsw_sp_bridge_8021d_vxlan_join(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t const struct net_device *vxlan_dev, u16 vid,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(bridge_device->dev);\n\tstruct vxlan_dev *vxlan = netdev_priv(vxlan_dev);\n\tstruct mlxsw_sp_nve_params params = {\n\t\t.type = MLXSW_SP_NVE_TYPE_VXLAN,\n\t\t.vni = vxlan->cfg.vni,\n\t\t.dev = vxlan_dev,\n\t\t.ethertype = ETH_P_8021Q,\n\t};\n\tstruct mlxsw_sp_fid *fid;\n\tint err;\n\n\tfid = mlxsw_sp_fid_8021d_get(mlxsw_sp, bridge_device->dev->ifindex);\n\tif (IS_ERR(fid)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to create 802.1D FID\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mlxsw_sp_fid_vni_is_set(fid)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VNI is already set on FID\");\n\t\terr = -EINVAL;\n\t\tgoto err_vni_exists;\n\t}\n\n\terr = mlxsw_sp_nve_fid_enable(mlxsw_sp, fid, &params, extack);\n\tif (err)\n\t\tgoto err_nve_fid_enable;\n\n\treturn 0;\n\nerr_nve_fid_enable:\nerr_vni_exists:\n\tmlxsw_sp_fid_put(fid);\n\treturn err;\n}\n\nstatic struct mlxsw_sp_fid *\nmlxsw_sp_bridge_8021d_fid_get(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t      u16 vid, struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(bridge_device->dev);\n\n\treturn mlxsw_sp_fid_8021d_get(mlxsw_sp, bridge_device->dev->ifindex);\n}\n\nstatic struct mlxsw_sp_fid *\nmlxsw_sp_bridge_8021d_fid_lookup(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t u16 vid)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_lower_get(bridge_device->dev);\n\n\t \n\tif (vid)\n\t\treturn NULL;\n\n\treturn mlxsw_sp_fid_8021d_lookup(mlxsw_sp, bridge_device->dev->ifindex);\n}\n\nstatic u16\nmlxsw_sp_bridge_8021d_fid_vid(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t      const struct mlxsw_sp_fid *fid)\n{\n\treturn 0;\n}\n\nstatic const struct mlxsw_sp_bridge_ops mlxsw_sp_bridge_8021d_ops = {\n\t.port_join\t= mlxsw_sp_bridge_8021d_port_join,\n\t.port_leave\t= mlxsw_sp_bridge_8021d_port_leave,\n\t.vxlan_join\t= mlxsw_sp_bridge_8021d_vxlan_join,\n\t.fid_get\t= mlxsw_sp_bridge_8021d_fid_get,\n\t.fid_lookup\t= mlxsw_sp_bridge_8021d_fid_lookup,\n\t.fid_vid\t= mlxsw_sp_bridge_8021d_fid_vid,\n};\n\nstatic int\nmlxsw_sp_bridge_8021ad_port_join(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\t struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\terr = mlxsw_sp_port_vlan_classification_set(mlxsw_sp_port, true, false);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_bridge_vlan_aware_port_join(bridge_port, mlxsw_sp_port,\n\t\t\t\t\t\t   extack);\n\tif (err)\n\t\tgoto err_bridge_vlan_aware_port_join;\n\n\treturn 0;\n\nerr_bridge_vlan_aware_port_join:\n\tmlxsw_sp_port_vlan_classification_set(mlxsw_sp_port, false, true);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_bridge_8021ad_port_leave(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t  struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\t  struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tmlxsw_sp_bridge_vlan_aware_port_leave(mlxsw_sp_port);\n\tmlxsw_sp_port_vlan_classification_set(mlxsw_sp_port, false, true);\n}\n\nstatic int\nmlxsw_sp_bridge_8021ad_vxlan_join(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t  const struct net_device *vxlan_dev, u16 vid,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\treturn mlxsw_sp_bridge_vlan_aware_vxlan_join(bridge_device, vxlan_dev,\n\t\t\t\t\t\t     vid, ETH_P_8021AD, extack);\n}\n\nstatic const struct mlxsw_sp_bridge_ops mlxsw_sp1_bridge_8021ad_ops = {\n\t.port_join\t= mlxsw_sp_bridge_8021ad_port_join,\n\t.port_leave\t= mlxsw_sp_bridge_8021ad_port_leave,\n\t.vxlan_join\t= mlxsw_sp_bridge_8021ad_vxlan_join,\n\t.fid_get\t= mlxsw_sp_bridge_8021q_fid_get,\n\t.fid_lookup\t= mlxsw_sp_bridge_8021q_fid_lookup,\n\t.fid_vid\t= mlxsw_sp_bridge_8021q_fid_vid,\n};\n\nstatic int\nmlxsw_sp2_bridge_8021ad_port_join(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t  struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\t  struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\t \n\terr = mlxsw_sp_port_egress_ethtype_set(mlxsw_sp_port, ETH_P_8021AD);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_bridge_8021ad_port_join(bridge_device, bridge_port,\n\t\t\t\t\t       mlxsw_sp_port, extack);\n\tif (err)\n\t\tgoto err_bridge_8021ad_port_join;\n\n\treturn 0;\n\nerr_bridge_8021ad_port_join:\n\tmlxsw_sp_port_egress_ethtype_set(mlxsw_sp_port, ETH_P_8021Q);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp2_bridge_8021ad_port_leave(struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t   struct mlxsw_sp_bridge_port *bridge_port,\n\t\t\t\t   struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tmlxsw_sp_bridge_8021ad_port_leave(bridge_device, bridge_port,\n\t\t\t\t\t  mlxsw_sp_port);\n\tmlxsw_sp_port_egress_ethtype_set(mlxsw_sp_port, ETH_P_8021Q);\n}\n\nstatic const struct mlxsw_sp_bridge_ops mlxsw_sp2_bridge_8021ad_ops = {\n\t.port_join\t= mlxsw_sp2_bridge_8021ad_port_join,\n\t.port_leave\t= mlxsw_sp2_bridge_8021ad_port_leave,\n\t.vxlan_join\t= mlxsw_sp_bridge_8021ad_vxlan_join,\n\t.fid_get\t= mlxsw_sp_bridge_8021q_fid_get,\n\t.fid_lookup\t= mlxsw_sp_bridge_8021q_fid_lookup,\n\t.fid_vid\t= mlxsw_sp_bridge_8021q_fid_vid,\n};\n\nint mlxsw_sp_port_bridge_join(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t      struct net_device *brport_dev,\n\t\t\t      struct net_device *br_dev,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tint err;\n\n\tbridge_port = mlxsw_sp_bridge_port_get(mlxsw_sp->bridge, brport_dev,\n\t\t\t\t\t       extack);\n\tif (IS_ERR(bridge_port))\n\t\treturn PTR_ERR(bridge_port);\n\tbridge_device = bridge_port->bridge_device;\n\n\terr = bridge_device->ops->port_join(bridge_device, bridge_port,\n\t\t\t\t\t    mlxsw_sp_port, extack);\n\tif (err)\n\t\tgoto err_port_join;\n\n\terr = mlxsw_sp_netdevice_enslavement_replay(mlxsw_sp, br_dev, extack);\n\tif (err)\n\t\tgoto err_replay;\n\n\treturn 0;\n\nerr_replay:\n\tbridge_device->ops->port_leave(bridge_device, bridge_port,\n\t\t\t\t       mlxsw_sp_port);\nerr_port_join:\n\tmlxsw_sp_bridge_port_put(mlxsw_sp->bridge, bridge_port);\n\treturn err;\n}\n\nvoid mlxsw_sp_port_bridge_leave(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\tstruct net_device *brport_dev,\n\t\t\t\tstruct net_device *br_dev)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\n\tbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);\n\tif (!bridge_device)\n\t\treturn;\n\tbridge_port = __mlxsw_sp_bridge_port_find(bridge_device, brport_dev);\n\tif (!bridge_port)\n\t\treturn;\n\n\tbridge_device->ops->port_leave(bridge_device, bridge_port,\n\t\t\t\t       mlxsw_sp_port);\n\tmlxsw_sp_port_security_set(mlxsw_sp_port, false);\n\tmlxsw_sp_bridge_port_put(mlxsw_sp->bridge, bridge_port);\n}\n\nint mlxsw_sp_bridge_vxlan_join(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       const struct net_device *br_dev,\n\t\t\t       const struct net_device *vxlan_dev, u16 vid,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\n\tbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);\n\tif (WARN_ON(!bridge_device))\n\t\treturn -EINVAL;\n\n\treturn bridge_device->ops->vxlan_join(bridge_device, vxlan_dev, vid,\n\t\t\t\t\t      extack);\n}\n\nvoid mlxsw_sp_bridge_vxlan_leave(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t const struct net_device *vxlan_dev)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(vxlan_dev);\n\tstruct mlxsw_sp_fid *fid;\n\n\t \n\tfid = mlxsw_sp_fid_lookup_by_vni(mlxsw_sp, vxlan->cfg.vni);\n\tif (!fid)\n\t\treturn;\n\n\tmlxsw_sp_nve_fid_disable(mlxsw_sp, fid);\n\t \n\tmlxsw_sp_fid_put(fid);\n\tmlxsw_sp_fid_put(fid);\n}\n\nstatic void\nmlxsw_sp_switchdev_vxlan_addr_convert(const union vxlan_addr *vxlan_addr,\n\t\t\t\t      enum mlxsw_sp_l3proto *proto,\n\t\t\t\t      union mlxsw_sp_l3addr *addr)\n{\n\tif (vxlan_addr->sa.sa_family == AF_INET) {\n\t\taddr->addr4 = vxlan_addr->sin.sin_addr.s_addr;\n\t\t*proto = MLXSW_SP_L3_PROTO_IPV4;\n\t} else {\n\t\taddr->addr6 = vxlan_addr->sin6.sin6_addr;\n\t\t*proto = MLXSW_SP_L3_PROTO_IPV6;\n\t}\n}\n\nstatic void\nmlxsw_sp_switchdev_addr_vxlan_convert(enum mlxsw_sp_l3proto proto,\n\t\t\t\t      const union mlxsw_sp_l3addr *addr,\n\t\t\t\t      union vxlan_addr *vxlan_addr)\n{\n\tswitch (proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\tvxlan_addr->sa.sa_family = AF_INET;\n\t\tvxlan_addr->sin.sin_addr.s_addr = addr->addr4;\n\t\tbreak;\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\tvxlan_addr->sa.sa_family = AF_INET6;\n\t\tvxlan_addr->sin6.sin6_addr = addr->addr6;\n\t\tbreak;\n\t}\n}\n\nstatic void mlxsw_sp_fdb_vxlan_call_notifiers(struct net_device *dev,\n\t\t\t\t\t      const char *mac,\n\t\t\t\t\t      enum mlxsw_sp_l3proto proto,\n\t\t\t\t\t      union mlxsw_sp_l3addr *addr,\n\t\t\t\t\t      __be32 vni, bool adding)\n{\n\tstruct switchdev_notifier_vxlan_fdb_info info;\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tenum switchdev_notifier_type type;\n\n\ttype = adding ? SWITCHDEV_VXLAN_FDB_ADD_TO_BRIDGE :\n\t\t\tSWITCHDEV_VXLAN_FDB_DEL_TO_BRIDGE;\n\tmlxsw_sp_switchdev_addr_vxlan_convert(proto, addr, &info.remote_ip);\n\tinfo.remote_port = vxlan->cfg.dst_port;\n\tinfo.remote_vni = vni;\n\tinfo.remote_ifindex = 0;\n\tether_addr_copy(info.eth_addr, mac);\n\tinfo.vni = vni;\n\tinfo.offloaded = adding;\n\tcall_switchdev_notifiers(type, dev, &info.info, NULL);\n}\n\nstatic void mlxsw_sp_fdb_nve_call_notifiers(struct net_device *dev,\n\t\t\t\t\t    const char *mac,\n\t\t\t\t\t    enum mlxsw_sp_l3proto proto,\n\t\t\t\t\t    union mlxsw_sp_l3addr *addr,\n\t\t\t\t\t    __be32 vni,\n\t\t\t\t\t    bool adding)\n{\n\tif (netif_is_vxlan(dev))\n\t\tmlxsw_sp_fdb_vxlan_call_notifiers(dev, mac, proto, addr, vni,\n\t\t\t\t\t\t  adding);\n}\n\nstatic void\nmlxsw_sp_fdb_call_notifiers(enum switchdev_notifier_type type,\n\t\t\t    const char *mac, u16 vid,\n\t\t\t    struct net_device *dev, bool offloaded, bool locked)\n{\n\tstruct switchdev_notifier_fdb_info info = {};\n\n\tinfo.addr = mac;\n\tinfo.vid = vid;\n\tinfo.offloaded = offloaded;\n\tinfo.locked = locked;\n\tcall_switchdev_notifiers(type, dev, &info.info, NULL);\n}\n\nstatic void mlxsw_sp_fdb_notify_mac_process(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    char *sfn_pl, int rec_index,\n\t\t\t\t\t    bool adding)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tu16 local_port, vid, fid, evid = 0;\n\tenum switchdev_notifier_type type;\n\tchar mac[ETH_ALEN];\n\tbool do_notification = true;\n\tint err;\n\n\tmlxsw_reg_sfn_mac_unpack(sfn_pl, rec_index, mac, &fid, &local_port);\n\n\tif (WARN_ON_ONCE(!mlxsw_sp_local_port_is_valid(mlxsw_sp, local_port)))\n\t\treturn;\n\tmlxsw_sp_port = mlxsw_sp->ports[local_port];\n\tif (!mlxsw_sp_port) {\n\t\tdev_err_ratelimited(mlxsw_sp->bus_info->dev, \"Incorrect local port in FDB notification\\n\");\n\t\tgoto just_remove;\n\t}\n\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_fid(mlxsw_sp_port, fid);\n\tif (!mlxsw_sp_port_vlan) {\n\t\tnetdev_err(mlxsw_sp_port->dev, \"Failed to find a matching {Port, VID} following FDB notification\\n\");\n\t\tgoto just_remove;\n\t}\n\n\tbridge_port = mlxsw_sp_port_vlan->bridge_port;\n\tif (!bridge_port) {\n\t\tnetdev_err(mlxsw_sp_port->dev, \"{Port, VID} not associated with a bridge\\n\");\n\t\tgoto just_remove;\n\t}\n\n\tbridge_device = bridge_port->bridge_device;\n\tvid = bridge_device->vlan_enabled ? mlxsw_sp_port_vlan->vid : 0;\n\tevid = mlxsw_sp_port_vlan->vid;\n\n\tif (adding && mlxsw_sp_port->security) {\n\t\tmlxsw_sp_fdb_call_notifiers(SWITCHDEV_FDB_ADD_TO_BRIDGE, mac,\n\t\t\t\t\t    vid, bridge_port->dev, false, true);\n\t\treturn;\n\t}\n\ndo_fdb_op:\n\terr = mlxsw_sp_port_fdb_uc_op(mlxsw_sp, local_port, mac, fid, evid,\n\t\t\t\t      adding, true);\n\tif (err) {\n\t\tdev_err_ratelimited(mlxsw_sp->bus_info->dev, \"Failed to set FDB entry\\n\");\n\t\treturn;\n\t}\n\n\tif (!do_notification)\n\t\treturn;\n\ttype = adding ? SWITCHDEV_FDB_ADD_TO_BRIDGE : SWITCHDEV_FDB_DEL_TO_BRIDGE;\n\tmlxsw_sp_fdb_call_notifiers(type, mac, vid, bridge_port->dev, adding,\n\t\t\t\t    false);\n\n\treturn;\n\njust_remove:\n\tadding = false;\n\tdo_notification = false;\n\tgoto do_fdb_op;\n}\n\nstatic void mlxsw_sp_fdb_notify_mac_lag_process(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\tchar *sfn_pl, int rec_index,\n\t\t\t\t\t\tbool adding)\n{\n\tstruct mlxsw_sp_port_vlan *mlxsw_sp_port_vlan;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tenum switchdev_notifier_type type;\n\tchar mac[ETH_ALEN];\n\tu16 lag_vid = 0;\n\tu16 lag_id;\n\tu16 vid, fid;\n\tbool do_notification = true;\n\tint err;\n\n\tmlxsw_reg_sfn_mac_lag_unpack(sfn_pl, rec_index, mac, &fid, &lag_id);\n\tmlxsw_sp_port = mlxsw_sp_lag_rep_port(mlxsw_sp, lag_id);\n\tif (!mlxsw_sp_port) {\n\t\tdev_err_ratelimited(mlxsw_sp->bus_info->dev, \"Cannot find port representor for LAG\\n\");\n\t\tgoto just_remove;\n\t}\n\n\tmlxsw_sp_port_vlan = mlxsw_sp_port_vlan_find_by_fid(mlxsw_sp_port, fid);\n\tif (!mlxsw_sp_port_vlan) {\n\t\tnetdev_err(mlxsw_sp_port->dev, \"Failed to find a matching {Port, VID} following FDB notification\\n\");\n\t\tgoto just_remove;\n\t}\n\n\tbridge_port = mlxsw_sp_port_vlan->bridge_port;\n\tif (!bridge_port) {\n\t\tnetdev_err(mlxsw_sp_port->dev, \"{Port, VID} not associated with a bridge\\n\");\n\t\tgoto just_remove;\n\t}\n\n\tbridge_device = bridge_port->bridge_device;\n\tvid = bridge_device->vlan_enabled ? mlxsw_sp_port_vlan->vid : 0;\n\tlag_vid = mlxsw_sp_port_vlan->vid;\n\n\tif (adding && mlxsw_sp_port->security) {\n\t\tmlxsw_sp_fdb_call_notifiers(SWITCHDEV_FDB_ADD_TO_BRIDGE, mac,\n\t\t\t\t\t    vid, bridge_port->dev, false, true);\n\t\treturn;\n\t}\n\ndo_fdb_op:\n\terr = mlxsw_sp_port_fdb_uc_lag_op(mlxsw_sp, lag_id, mac, fid, lag_vid,\n\t\t\t\t\t  adding, true);\n\tif (err) {\n\t\tdev_err_ratelimited(mlxsw_sp->bus_info->dev, \"Failed to set FDB entry\\n\");\n\t\treturn;\n\t}\n\n\tif (!do_notification)\n\t\treturn;\n\ttype = adding ? SWITCHDEV_FDB_ADD_TO_BRIDGE : SWITCHDEV_FDB_DEL_TO_BRIDGE;\n\tmlxsw_sp_fdb_call_notifiers(type, mac, vid, bridge_port->dev, adding,\n\t\t\t\t    false);\n\n\treturn;\n\njust_remove:\n\tadding = false;\n\tdo_notification = false;\n\tgoto do_fdb_op;\n}\n\nstatic int\n__mlxsw_sp_fdb_notify_mac_uc_tunnel_process(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    const struct mlxsw_sp_fid *fid,\n\t\t\t\t\t    bool adding,\n\t\t\t\t\t    struct net_device **nve_dev,\n\t\t\t\t\t    u16 *p_vid, __be32 *p_vni)\n{\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct net_device *br_dev, *dev;\n\tint nve_ifindex;\n\tint err;\n\n\terr = mlxsw_sp_fid_nve_ifindex(fid, &nve_ifindex);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_fid_vni(fid, p_vni);\n\tif (err)\n\t\treturn err;\n\n\tdev = __dev_get_by_index(mlxsw_sp_net(mlxsw_sp), nve_ifindex);\n\tif (!dev)\n\t\treturn -EINVAL;\n\t*nve_dev = dev;\n\n\tif (!netif_running(dev))\n\t\treturn -EINVAL;\n\n\tif (adding && !br_port_flag_is_set(dev, BR_LEARNING))\n\t\treturn -EINVAL;\n\n\tif (adding && netif_is_vxlan(dev)) {\n\t\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\n\t\tif (!(vxlan->cfg.flags & VXLAN_F_LEARN))\n\t\t\treturn -EINVAL;\n\t}\n\n\tbr_dev = netdev_master_upper_dev_get(dev);\n\tif (!br_dev)\n\t\treturn -EINVAL;\n\n\tbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);\n\tif (!bridge_device)\n\t\treturn -EINVAL;\n\n\t*p_vid = bridge_device->ops->fid_vid(bridge_device, fid);\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_fdb_notify_mac_uc_tunnel_process(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t\t      char *sfn_pl,\n\t\t\t\t\t\t      int rec_index,\n\t\t\t\t\t\t      bool adding)\n{\n\tenum mlxsw_reg_sfn_uc_tunnel_protocol sfn_proto;\n\tenum switchdev_notifier_type type;\n\tstruct net_device *nve_dev;\n\tunion mlxsw_sp_l3addr addr;\n\tstruct mlxsw_sp_fid *fid;\n\tchar mac[ETH_ALEN];\n\tu16 fid_index, vid;\n\t__be32 vni;\n\tu32 uip;\n\tint err;\n\n\tmlxsw_reg_sfn_uc_tunnel_unpack(sfn_pl, rec_index, mac, &fid_index,\n\t\t\t\t       &uip, &sfn_proto);\n\n\tfid = mlxsw_sp_fid_lookup_by_index(mlxsw_sp, fid_index);\n\tif (!fid)\n\t\tgoto err_fid_lookup;\n\n\terr = mlxsw_sp_nve_learned_ip_resolve(mlxsw_sp, uip,\n\t\t\t\t\t      (enum mlxsw_sp_l3proto) sfn_proto,\n\t\t\t\t\t      &addr);\n\tif (err)\n\t\tgoto err_ip_resolve;\n\n\terr = __mlxsw_sp_fdb_notify_mac_uc_tunnel_process(mlxsw_sp, fid, adding,\n\t\t\t\t\t\t\t  &nve_dev, &vid, &vni);\n\tif (err)\n\t\tgoto err_fdb_process;\n\n\terr = mlxsw_sp_port_fdb_tunnel_uc_op(mlxsw_sp, mac, fid_index,\n\t\t\t\t\t     (enum mlxsw_sp_l3proto) sfn_proto,\n\t\t\t\t\t     &addr, adding, true);\n\tif (err)\n\t\tgoto err_fdb_op;\n\n\tmlxsw_sp_fdb_nve_call_notifiers(nve_dev, mac,\n\t\t\t\t\t(enum mlxsw_sp_l3proto) sfn_proto,\n\t\t\t\t\t&addr, vni, adding);\n\n\ttype = adding ? SWITCHDEV_FDB_ADD_TO_BRIDGE :\n\t\t\tSWITCHDEV_FDB_DEL_TO_BRIDGE;\n\tmlxsw_sp_fdb_call_notifiers(type, mac, vid, nve_dev, adding, false);\n\n\tmlxsw_sp_fid_put(fid);\n\n\treturn;\n\nerr_fdb_op:\nerr_fdb_process:\nerr_ip_resolve:\n\tmlxsw_sp_fid_put(fid);\nerr_fid_lookup:\n\t \n\tmlxsw_sp_port_fdb_tunnel_uc_op(mlxsw_sp, mac, fid_index,\n\t\t\t\t       (enum mlxsw_sp_l3proto) sfn_proto, &addr,\n\t\t\t\t       false, true);\n}\n\nstatic void mlxsw_sp_fdb_notify_rec_process(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t    char *sfn_pl, int rec_index)\n{\n\tswitch (mlxsw_reg_sfn_rec_type_get(sfn_pl, rec_index)) {\n\tcase MLXSW_REG_SFN_REC_TYPE_LEARNED_MAC:\n\t\tmlxsw_sp_fdb_notify_mac_process(mlxsw_sp, sfn_pl,\n\t\t\t\t\t\trec_index, true);\n\t\tbreak;\n\tcase MLXSW_REG_SFN_REC_TYPE_AGED_OUT_MAC:\n\t\tmlxsw_sp_fdb_notify_mac_process(mlxsw_sp, sfn_pl,\n\t\t\t\t\t\trec_index, false);\n\t\tbreak;\n\tcase MLXSW_REG_SFN_REC_TYPE_LEARNED_MAC_LAG:\n\t\tmlxsw_sp_fdb_notify_mac_lag_process(mlxsw_sp, sfn_pl,\n\t\t\t\t\t\t    rec_index, true);\n\t\tbreak;\n\tcase MLXSW_REG_SFN_REC_TYPE_AGED_OUT_MAC_LAG:\n\t\tmlxsw_sp_fdb_notify_mac_lag_process(mlxsw_sp, sfn_pl,\n\t\t\t\t\t\t    rec_index, false);\n\t\tbreak;\n\tcase MLXSW_REG_SFN_REC_TYPE_LEARNED_UNICAST_TUNNEL:\n\t\tmlxsw_sp_fdb_notify_mac_uc_tunnel_process(mlxsw_sp, sfn_pl,\n\t\t\t\t\t\t\t  rec_index, true);\n\t\tbreak;\n\tcase MLXSW_REG_SFN_REC_TYPE_AGED_OUT_UNICAST_TUNNEL:\n\t\tmlxsw_sp_fdb_notify_mac_uc_tunnel_process(mlxsw_sp, sfn_pl,\n\t\t\t\t\t\t\t  rec_index, false);\n\t\tbreak;\n\t}\n}\n\n#define MLXSW_SP_FDB_SFN_QUERIES_PER_SESSION 10\n\nstatic void mlxsw_sp_fdb_notify_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_bridge *bridge;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tbool reschedule = false;\n\tchar *sfn_pl;\n\tint queries;\n\tu8 num_rec;\n\tint i;\n\tint err;\n\n\tsfn_pl = kmalloc(MLXSW_REG_SFN_LEN, GFP_KERNEL);\n\tif (!sfn_pl)\n\t\treturn;\n\n\tbridge = container_of(work, struct mlxsw_sp_bridge, fdb_notify.dw.work);\n\tmlxsw_sp = bridge->mlxsw_sp;\n\n\trtnl_lock();\n\tif (list_empty(&bridge->bridges_list))\n\t\tgoto out;\n\treschedule = true;\n\tqueries = MLXSW_SP_FDB_SFN_QUERIES_PER_SESSION;\n\twhile (queries > 0) {\n\t\tmlxsw_reg_sfn_pack(sfn_pl);\n\t\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(sfn), sfn_pl);\n\t\tif (err) {\n\t\t\tdev_err_ratelimited(mlxsw_sp->bus_info->dev, \"Failed to get FDB notifications\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tnum_rec = mlxsw_reg_sfn_num_rec_get(sfn_pl);\n\t\tfor (i = 0; i < num_rec; i++)\n\t\t\tmlxsw_sp_fdb_notify_rec_process(mlxsw_sp, sfn_pl, i);\n\t\tif (num_rec != MLXSW_REG_SFN_REC_MAX_COUNT)\n\t\t\tgoto out;\n\t\tqueries--;\n\t}\n\nout:\n\trtnl_unlock();\n\tkfree(sfn_pl);\n\tif (!reschedule)\n\t\treturn;\n\tmlxsw_sp_fdb_notify_work_schedule(mlxsw_sp, !queries);\n}\n\nstruct mlxsw_sp_switchdev_event_work {\n\tstruct work_struct work;\n\tnetdevice_tracker dev_tracker;\n\tunion {\n\t\tstruct switchdev_notifier_fdb_info fdb_info;\n\t\tstruct switchdev_notifier_vxlan_fdb_info vxlan_fdb_info;\n\t};\n\tstruct net_device *dev;\n\tunsigned long event;\n};\n\nstatic void\nmlxsw_sp_switchdev_bridge_vxlan_fdb_event(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct mlxsw_sp_switchdev_event_work *\n\t\t\t\t\t  switchdev_work,\n\t\t\t\t\t  struct mlxsw_sp_fid *fid, __be32 vni)\n{\n\tstruct switchdev_notifier_vxlan_fdb_info vxlan_fdb_info;\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tstruct net_device *dev = switchdev_work->dev;\n\tenum mlxsw_sp_l3proto proto;\n\tunion mlxsw_sp_l3addr addr;\n\tint err;\n\n\tfdb_info = &switchdev_work->fdb_info;\n\terr = vxlan_fdb_find_uc(dev, fdb_info->addr, vni, &vxlan_fdb_info);\n\tif (err)\n\t\treturn;\n\n\tmlxsw_sp_switchdev_vxlan_addr_convert(&vxlan_fdb_info.remote_ip,\n\t\t\t\t\t      &proto, &addr);\n\n\tswitch (switchdev_work->event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\terr = mlxsw_sp_port_fdb_tunnel_uc_op(mlxsw_sp,\n\t\t\t\t\t\t     vxlan_fdb_info.eth_addr,\n\t\t\t\t\t\t     mlxsw_sp_fid_index(fid),\n\t\t\t\t\t\t     proto, &addr, true, false);\n\t\tif (err)\n\t\t\treturn;\n\t\tvxlan_fdb_info.offloaded = true;\n\t\tcall_switchdev_notifiers(SWITCHDEV_VXLAN_FDB_OFFLOADED, dev,\n\t\t\t\t\t &vxlan_fdb_info.info, NULL);\n\t\tmlxsw_sp_fdb_call_notifiers(SWITCHDEV_FDB_OFFLOADED,\n\t\t\t\t\t    vxlan_fdb_info.eth_addr,\n\t\t\t\t\t    fdb_info->vid, dev, true, false);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\terr = mlxsw_sp_port_fdb_tunnel_uc_op(mlxsw_sp,\n\t\t\t\t\t\t     vxlan_fdb_info.eth_addr,\n\t\t\t\t\t\t     mlxsw_sp_fid_index(fid),\n\t\t\t\t\t\t     proto, &addr, false,\n\t\t\t\t\t\t     false);\n\t\tvxlan_fdb_info.offloaded = false;\n\t\tcall_switchdev_notifiers(SWITCHDEV_VXLAN_FDB_OFFLOADED, dev,\n\t\t\t\t\t &vxlan_fdb_info.info, NULL);\n\t\tbreak;\n\t}\n}\n\nstatic void\nmlxsw_sp_switchdev_bridge_nve_fdb_event(struct mlxsw_sp_switchdev_event_work *\n\t\t\t\t\tswitchdev_work)\n{\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct net_device *dev = switchdev_work->dev;\n\tstruct net_device *br_dev;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct mlxsw_sp_fid *fid;\n\t__be32 vni;\n\tint err;\n\n\tif (switchdev_work->event != SWITCHDEV_FDB_ADD_TO_DEVICE &&\n\t    switchdev_work->event != SWITCHDEV_FDB_DEL_TO_DEVICE)\n\t\treturn;\n\n\tif (switchdev_work->event == SWITCHDEV_FDB_ADD_TO_DEVICE &&\n\t    (!switchdev_work->fdb_info.added_by_user ||\n\t     switchdev_work->fdb_info.is_local))\n\t\treturn;\n\n\tif (!netif_running(dev))\n\t\treturn;\n\tbr_dev = netdev_master_upper_dev_get(dev);\n\tif (!br_dev)\n\t\treturn;\n\tif (!netif_is_bridge_master(br_dev))\n\t\treturn;\n\tmlxsw_sp = mlxsw_sp_lower_get(br_dev);\n\tif (!mlxsw_sp)\n\t\treturn;\n\tbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);\n\tif (!bridge_device)\n\t\treturn;\n\n\tfid = bridge_device->ops->fid_lookup(bridge_device,\n\t\t\t\t\t     switchdev_work->fdb_info.vid);\n\tif (!fid)\n\t\treturn;\n\n\terr = mlxsw_sp_fid_vni(fid, &vni);\n\tif (err)\n\t\tgoto out;\n\n\tmlxsw_sp_switchdev_bridge_vxlan_fdb_event(mlxsw_sp, switchdev_work, fid,\n\t\t\t\t\t\t  vni);\n\nout:\n\tmlxsw_sp_fid_put(fid);\n}\n\nstatic void mlxsw_sp_switchdev_bridge_fdb_event_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_switchdev_event_work *switchdev_work =\n\t\tcontainer_of(work, struct mlxsw_sp_switchdev_event_work, work);\n\tstruct net_device *dev = switchdev_work->dev;\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tstruct mlxsw_sp_port *mlxsw_sp_port;\n\tint err;\n\n\trtnl_lock();\n\tif (netif_is_vxlan(dev)) {\n\t\tmlxsw_sp_switchdev_bridge_nve_fdb_event(switchdev_work);\n\t\tgoto out;\n\t}\n\n\tmlxsw_sp_port = mlxsw_sp_port_dev_lower_find(dev);\n\tif (!mlxsw_sp_port)\n\t\tgoto out;\n\n\tswitch (switchdev_work->event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\tfdb_info = &switchdev_work->fdb_info;\n\t\tif (!fdb_info->added_by_user || fdb_info->is_local)\n\t\t\tbreak;\n\t\terr = mlxsw_sp_port_fdb_set(mlxsw_sp_port, fdb_info, true);\n\t\tif (err)\n\t\t\tbreak;\n\t\tmlxsw_sp_fdb_call_notifiers(SWITCHDEV_FDB_OFFLOADED,\n\t\t\t\t\t    fdb_info->addr,\n\t\t\t\t\t    fdb_info->vid, dev, true, false);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tfdb_info = &switchdev_work->fdb_info;\n\t\tmlxsw_sp_port_fdb_set(mlxsw_sp_port, fdb_info, false);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_ADD_TO_BRIDGE:\n\tcase SWITCHDEV_FDB_DEL_TO_BRIDGE:\n\t\t \n\t\tbreak;\n\t}\n\n\tmlxsw_sp_span_respin(mlxsw_sp_port->mlxsw_sp);\n\nout:\n\trtnl_unlock();\n\tkfree(switchdev_work->fdb_info.addr);\n\tnetdev_put(dev, &switchdev_work->dev_tracker);\n\tkfree(switchdev_work);\n}\n\nstatic void\nmlxsw_sp_switchdev_vxlan_fdb_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_switchdev_event_work *\n\t\t\t\t switchdev_work)\n{\n\tstruct switchdev_notifier_vxlan_fdb_info *vxlan_fdb_info;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct net_device *dev = switchdev_work->dev;\n\tenum mlxsw_sp_l3proto proto;\n\tunion mlxsw_sp_l3addr addr;\n\tstruct net_device *br_dev;\n\tstruct mlxsw_sp_fid *fid;\n\tu16 vid;\n\tint err;\n\n\tvxlan_fdb_info = &switchdev_work->vxlan_fdb_info;\n\tbr_dev = netdev_master_upper_dev_get(dev);\n\n\tbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);\n\tif (!bridge_device)\n\t\treturn;\n\n\tfid = mlxsw_sp_fid_lookup_by_vni(mlxsw_sp, vxlan_fdb_info->vni);\n\tif (!fid)\n\t\treturn;\n\n\tmlxsw_sp_switchdev_vxlan_addr_convert(&vxlan_fdb_info->remote_ip,\n\t\t\t\t\t      &proto, &addr);\n\n\tif (is_zero_ether_addr(vxlan_fdb_info->eth_addr)) {\n\t\terr = mlxsw_sp_nve_flood_ip_add(mlxsw_sp, fid, proto, &addr);\n\t\tif (err) {\n\t\t\tmlxsw_sp_fid_put(fid);\n\t\t\treturn;\n\t\t}\n\t\tvxlan_fdb_info->offloaded = true;\n\t\tcall_switchdev_notifiers(SWITCHDEV_VXLAN_FDB_OFFLOADED, dev,\n\t\t\t\t\t &vxlan_fdb_info->info, NULL);\n\t\tmlxsw_sp_fid_put(fid);\n\t\treturn;\n\t}\n\n\t \n\tvid = bridge_device->ops->fid_vid(bridge_device, fid);\n\tif (br_fdb_find_port(br_dev, vxlan_fdb_info->eth_addr, vid) != dev)\n\t\tgoto err_br_fdb_find;\n\n\terr = mlxsw_sp_port_fdb_tunnel_uc_op(mlxsw_sp, vxlan_fdb_info->eth_addr,\n\t\t\t\t\t     mlxsw_sp_fid_index(fid), proto,\n\t\t\t\t\t     &addr, true, false);\n\tif (err)\n\t\tgoto err_fdb_tunnel_uc_op;\n\tvxlan_fdb_info->offloaded = true;\n\tcall_switchdev_notifiers(SWITCHDEV_VXLAN_FDB_OFFLOADED, dev,\n\t\t\t\t &vxlan_fdb_info->info, NULL);\n\tmlxsw_sp_fdb_call_notifiers(SWITCHDEV_FDB_OFFLOADED,\n\t\t\t\t    vxlan_fdb_info->eth_addr, vid, dev, true,\n\t\t\t\t    false);\n\n\tmlxsw_sp_fid_put(fid);\n\n\treturn;\n\nerr_fdb_tunnel_uc_op:\nerr_br_fdb_find:\n\tmlxsw_sp_fid_put(fid);\n}\n\nstatic void\nmlxsw_sp_switchdev_vxlan_fdb_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_switchdev_event_work *\n\t\t\t\t switchdev_work)\n{\n\tstruct switchdev_notifier_vxlan_fdb_info *vxlan_fdb_info;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct net_device *dev = switchdev_work->dev;\n\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\tenum mlxsw_sp_l3proto proto;\n\tunion mlxsw_sp_l3addr addr;\n\tstruct mlxsw_sp_fid *fid;\n\tu16 vid;\n\n\tvxlan_fdb_info = &switchdev_work->vxlan_fdb_info;\n\tif (!vxlan_fdb_info->offloaded)\n\t\treturn;\n\n\tbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);\n\tif (!bridge_device)\n\t\treturn;\n\n\tfid = mlxsw_sp_fid_lookup_by_vni(mlxsw_sp, vxlan_fdb_info->vni);\n\tif (!fid)\n\t\treturn;\n\n\tmlxsw_sp_switchdev_vxlan_addr_convert(&vxlan_fdb_info->remote_ip,\n\t\t\t\t\t      &proto, &addr);\n\n\tif (is_zero_ether_addr(vxlan_fdb_info->eth_addr)) {\n\t\tmlxsw_sp_nve_flood_ip_del(mlxsw_sp, fid, proto, &addr);\n\t\tmlxsw_sp_fid_put(fid);\n\t\treturn;\n\t}\n\n\tmlxsw_sp_port_fdb_tunnel_uc_op(mlxsw_sp, vxlan_fdb_info->eth_addr,\n\t\t\t\t       mlxsw_sp_fid_index(fid), proto, &addr,\n\t\t\t\t       false, false);\n\tvid = bridge_device->ops->fid_vid(bridge_device, fid);\n\tmlxsw_sp_fdb_call_notifiers(SWITCHDEV_FDB_OFFLOADED,\n\t\t\t\t    vxlan_fdb_info->eth_addr, vid, dev, false,\n\t\t\t\t    false);\n\n\tmlxsw_sp_fid_put(fid);\n}\n\nstatic void mlxsw_sp_switchdev_vxlan_fdb_event_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_switchdev_event_work *switchdev_work =\n\t\tcontainer_of(work, struct mlxsw_sp_switchdev_event_work, work);\n\tstruct net_device *dev = switchdev_work->dev;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct net_device *br_dev;\n\n\trtnl_lock();\n\n\tif (!netif_running(dev))\n\t\tgoto out;\n\tbr_dev = netdev_master_upper_dev_get(dev);\n\tif (!br_dev)\n\t\tgoto out;\n\tif (!netif_is_bridge_master(br_dev))\n\t\tgoto out;\n\tmlxsw_sp = mlxsw_sp_lower_get(br_dev);\n\tif (!mlxsw_sp)\n\t\tgoto out;\n\n\tswitch (switchdev_work->event) {\n\tcase SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE:\n\t\tmlxsw_sp_switchdev_vxlan_fdb_add(mlxsw_sp, switchdev_work);\n\t\tbreak;\n\tcase SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE:\n\t\tmlxsw_sp_switchdev_vxlan_fdb_del(mlxsw_sp, switchdev_work);\n\t\tbreak;\n\t}\n\nout:\n\trtnl_unlock();\n\tnetdev_put(dev, &switchdev_work->dev_tracker);\n\tkfree(switchdev_work);\n}\n\nstatic int\nmlxsw_sp_switchdev_vxlan_work_prepare(struct mlxsw_sp_switchdev_event_work *\n\t\t\t\t      switchdev_work,\n\t\t\t\t      struct switchdev_notifier_info *info)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(switchdev_work->dev);\n\tstruct switchdev_notifier_vxlan_fdb_info *vxlan_fdb_info;\n\tstruct vxlan_config *cfg = &vxlan->cfg;\n\tstruct netlink_ext_ack *extack;\n\n\textack = switchdev_notifier_info_to_extack(info);\n\tvxlan_fdb_info = container_of(info,\n\t\t\t\t      struct switchdev_notifier_vxlan_fdb_info,\n\t\t\t\t      info);\n\n\tif (vxlan_fdb_info->remote_port != cfg->dst_port) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: FDB: Non-default remote port is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (vxlan_fdb_info->remote_vni != cfg->vni ||\n\t    vxlan_fdb_info->vni != cfg->vni) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: FDB: Non-default VNI is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (vxlan_fdb_info->remote_ifindex) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: FDB: Local interface is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (is_multicast_ether_addr(vxlan_fdb_info->eth_addr)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: FDB: Multicast MAC addresses not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (vxlan_addr_multicast(&vxlan_fdb_info->remote_ip)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VxLAN: FDB: Multicast destination IP is not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitchdev_work->vxlan_fdb_info = *vxlan_fdb_info;\n\n\treturn 0;\n}\n\n \nstatic int mlxsw_sp_switchdev_event(struct notifier_block *unused,\n\t\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tstruct mlxsw_sp_switchdev_event_work *switchdev_work;\n\tstruct switchdev_notifier_fdb_info *fdb_info;\n\tstruct switchdev_notifier_info *info = ptr;\n\tstruct net_device *br_dev;\n\tint err;\n\n\tif (event == SWITCHDEV_PORT_ATTR_SET) {\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     mlxsw_sp_port_dev_check,\n\t\t\t\t\t\t     mlxsw_sp_port_attr_set);\n\t\treturn notifier_from_errno(err);\n\t}\n\n\t \n\tbr_dev = netdev_master_upper_dev_get_rcu(dev);\n\tif (!br_dev)\n\t\treturn NOTIFY_DONE;\n\tif (!netif_is_bridge_master(br_dev))\n\t\treturn NOTIFY_DONE;\n\tif (!mlxsw_sp_port_dev_lower_find_rcu(br_dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitchdev_work = kzalloc(sizeof(*switchdev_work), GFP_ATOMIC);\n\tif (!switchdev_work)\n\t\treturn NOTIFY_BAD;\n\n\tswitchdev_work->dev = dev;\n\tswitchdev_work->event = event;\n\n\tswitch (event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\tcase SWITCHDEV_FDB_ADD_TO_BRIDGE:\n\tcase SWITCHDEV_FDB_DEL_TO_BRIDGE:\n\t\tfdb_info = container_of(info,\n\t\t\t\t\tstruct switchdev_notifier_fdb_info,\n\t\t\t\t\tinfo);\n\t\tINIT_WORK(&switchdev_work->work,\n\t\t\t  mlxsw_sp_switchdev_bridge_fdb_event_work);\n\t\tmemcpy(&switchdev_work->fdb_info, ptr,\n\t\t       sizeof(switchdev_work->fdb_info));\n\t\tswitchdev_work->fdb_info.addr = kzalloc(ETH_ALEN, GFP_ATOMIC);\n\t\tif (!switchdev_work->fdb_info.addr)\n\t\t\tgoto err_addr_alloc;\n\t\tether_addr_copy((u8 *)switchdev_work->fdb_info.addr,\n\t\t\t\tfdb_info->addr);\n\t\t \n\t\tnetdev_hold(dev, &switchdev_work->dev_tracker, GFP_ATOMIC);\n\t\tbreak;\n\tcase SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE:\n\tcase SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE:\n\t\tINIT_WORK(&switchdev_work->work,\n\t\t\t  mlxsw_sp_switchdev_vxlan_fdb_event_work);\n\t\terr = mlxsw_sp_switchdev_vxlan_work_prepare(switchdev_work,\n\t\t\t\t\t\t\t    info);\n\t\tif (err)\n\t\t\tgoto err_vxlan_work_prepare;\n\t\tnetdev_hold(dev, &switchdev_work->dev_tracker, GFP_ATOMIC);\n\t\tbreak;\n\tdefault:\n\t\tkfree(switchdev_work);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tmlxsw_core_schedule_work(&switchdev_work->work);\n\n\treturn NOTIFY_DONE;\n\nerr_vxlan_work_prepare:\nerr_addr_alloc:\n\tkfree(switchdev_work);\n\treturn NOTIFY_BAD;\n}\n\nstruct notifier_block mlxsw_sp_switchdev_notifier = {\n\t.notifier_call = mlxsw_sp_switchdev_event,\n};\n\nstatic int\nmlxsw_sp_switchdev_vxlan_vlan_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t  const struct net_device *vxlan_dev, u16 vid,\n\t\t\t\t  bool flag_untagged, bool flag_pvid,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(vxlan_dev);\n\t__be32 vni = vxlan->cfg.vni;\n\tstruct mlxsw_sp_fid *fid;\n\tu16 old_vid;\n\tint err;\n\n\t \n\tif (flag_untagged && flag_pvid &&\n\t    mlxsw_sp_bridge_8021q_vxlan_dev_find(bridge_device->dev, vid)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VLAN already mapped to a different VNI\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!netif_running(vxlan_dev))\n\t\treturn 0;\n\n\t \n\tfid = mlxsw_sp_fid_lookup_by_vni(mlxsw_sp, vni);\n\tif (!fid) {\n\t\tif (!flag_untagged || !flag_pvid)\n\t\t\treturn 0;\n\t\treturn bridge_device->ops->vxlan_join(bridge_device, vxlan_dev,\n\t\t\t\t\t\t      vid, extack);\n\t}\n\n\t \n\told_vid = mlxsw_sp_fid_8021q_vid(fid);\n\tif (vid == old_vid) {\n\t\tif (WARN_ON(flag_untagged && flag_pvid)) {\n\t\t\tmlxsw_sp_fid_put(fid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmlxsw_sp_bridge_vxlan_leave(mlxsw_sp, vxlan_dev);\n\t\tmlxsw_sp_fid_put(fid);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!flag_pvid) {\n\t\tmlxsw_sp_fid_put(fid);\n\t\treturn 0;\n\t}\n\n\t \n\tmlxsw_sp_bridge_vxlan_leave(mlxsw_sp, vxlan_dev);\n\tmlxsw_sp_fid_put(fid);\n\n\t \n\tif (!flag_untagged)\n\t\treturn 0;\n\n\terr = bridge_device->ops->vxlan_join(bridge_device, vxlan_dev, vid, extack);\n\tif (err)\n\t\tgoto err_vxlan_join;\n\n\treturn 0;\n\nerr_vxlan_join:\n\tbridge_device->ops->vxlan_join(bridge_device, vxlan_dev, old_vid, NULL);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_switchdev_vxlan_vlan_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  struct mlxsw_sp_bridge_device *bridge_device,\n\t\t\t\t  const struct net_device *vxlan_dev, u16 vid)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(vxlan_dev);\n\t__be32 vni = vxlan->cfg.vni;\n\tstruct mlxsw_sp_fid *fid;\n\n\tif (!netif_running(vxlan_dev))\n\t\treturn;\n\n\tfid = mlxsw_sp_fid_lookup_by_vni(mlxsw_sp, vni);\n\tif (!fid)\n\t\treturn;\n\n\t \n\tif (mlxsw_sp_fid_8021q_vid(fid) != vid)\n\t\tgoto out;\n\n\tmlxsw_sp_bridge_vxlan_leave(mlxsw_sp, vxlan_dev);\n\nout:\n\tmlxsw_sp_fid_put(fid);\n}\n\nstatic int\nmlxsw_sp_switchdev_vxlan_vlans_add(struct net_device *vxlan_dev,\n\t\t\t\t   struct switchdev_notifier_port_obj_info *\n\t\t\t\t   port_obj_info)\n{\n\tstruct switchdev_obj_port_vlan *vlan =\n\t\tSWITCHDEV_OBJ_PORT_VLAN(port_obj_info->obj);\n\tbool flag_untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tbool flag_pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct netlink_ext_ack *extack;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct net_device *br_dev;\n\n\textack = switchdev_notifier_info_to_extack(&port_obj_info->info);\n\tbr_dev = netdev_master_upper_dev_get(vxlan_dev);\n\tif (!br_dev)\n\t\treturn 0;\n\n\tmlxsw_sp = mlxsw_sp_lower_get(br_dev);\n\tif (!mlxsw_sp)\n\t\treturn 0;\n\n\tport_obj_info->handled = true;\n\n\tbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);\n\tif (!bridge_device)\n\t\treturn -EINVAL;\n\n\tif (!bridge_device->vlan_enabled)\n\t\treturn 0;\n\n\treturn mlxsw_sp_switchdev_vxlan_vlan_add(mlxsw_sp, bridge_device,\n\t\t\t\t\t\t vxlan_dev, vlan->vid,\n\t\t\t\t\t\t flag_untagged,\n\t\t\t\t\t\t flag_pvid, extack);\n}\n\nstatic void\nmlxsw_sp_switchdev_vxlan_vlans_del(struct net_device *vxlan_dev,\n\t\t\t\t   struct switchdev_notifier_port_obj_info *\n\t\t\t\t   port_obj_info)\n{\n\tstruct switchdev_obj_port_vlan *vlan =\n\t\tSWITCHDEV_OBJ_PORT_VLAN(port_obj_info->obj);\n\tstruct mlxsw_sp_bridge_device *bridge_device;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct net_device *br_dev;\n\n\tbr_dev = netdev_master_upper_dev_get(vxlan_dev);\n\tif (!br_dev)\n\t\treturn;\n\n\tmlxsw_sp = mlxsw_sp_lower_get(br_dev);\n\tif (!mlxsw_sp)\n\t\treturn;\n\n\tport_obj_info->handled = true;\n\n\tbridge_device = mlxsw_sp_bridge_device_find(mlxsw_sp->bridge, br_dev);\n\tif (!bridge_device)\n\t\treturn;\n\n\tif (!bridge_device->vlan_enabled)\n\t\treturn;\n\n\tmlxsw_sp_switchdev_vxlan_vlan_del(mlxsw_sp, bridge_device, vxlan_dev,\n\t\t\t\t\t  vlan->vid);\n}\n\nstatic int\nmlxsw_sp_switchdev_handle_vxlan_obj_add(struct net_device *vxlan_dev,\n\t\t\t\t\tstruct switchdev_notifier_port_obj_info *\n\t\t\t\t\tport_obj_info)\n{\n\tint err = 0;\n\n\tswitch (port_obj_info->obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\terr = mlxsw_sp_switchdev_vxlan_vlans_add(vxlan_dev,\n\t\t\t\t\t\t\t port_obj_info);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_switchdev_handle_vxlan_obj_del(struct net_device *vxlan_dev,\n\t\t\t\t\tstruct switchdev_notifier_port_obj_info *\n\t\t\t\t\tport_obj_info)\n{\n\tswitch (port_obj_info->obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\tmlxsw_sp_switchdev_vxlan_vlans_del(vxlan_dev, port_obj_info);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int mlxsw_sp_switchdev_blocking_event(struct notifier_block *unused,\n\t\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tint err = 0;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_OBJ_ADD:\n\t\tif (netif_is_vxlan(dev))\n\t\t\terr = mlxsw_sp_switchdev_handle_vxlan_obj_add(dev, ptr);\n\t\telse\n\t\t\terr = switchdev_handle_port_obj_add(dev, ptr,\n\t\t\t\t\t\t\tmlxsw_sp_port_dev_check,\n\t\t\t\t\t\t\tmlxsw_sp_port_obj_add);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_PORT_OBJ_DEL:\n\t\tif (netif_is_vxlan(dev))\n\t\t\tmlxsw_sp_switchdev_handle_vxlan_obj_del(dev, ptr);\n\t\telse\n\t\t\terr = switchdev_handle_port_obj_del(dev, ptr,\n\t\t\t\t\t\t\tmlxsw_sp_port_dev_check,\n\t\t\t\t\t\t\tmlxsw_sp_port_obj_del);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     mlxsw_sp_port_dev_check,\n\t\t\t\t\t\t     mlxsw_sp_port_attr_set);\n\t\treturn notifier_from_errno(err);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block mlxsw_sp_switchdev_blocking_notifier = {\n\t.notifier_call = mlxsw_sp_switchdev_blocking_event,\n};\n\nu8\nmlxsw_sp_bridge_port_stp_state(struct mlxsw_sp_bridge_port *bridge_port)\n{\n\treturn bridge_port->stp_state;\n}\n\nstatic int mlxsw_sp_fdb_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_bridge *bridge = mlxsw_sp->bridge;\n\tstruct notifier_block *nb;\n\tint err;\n\n\terr = mlxsw_sp_ageing_set(mlxsw_sp, MLXSW_SP_DEFAULT_AGEING_TIME);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to set default ageing time\\n\");\n\t\treturn err;\n\t}\n\n\terr = register_switchdev_notifier(&mlxsw_sp_switchdev_notifier);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to register switchdev notifier\\n\");\n\t\treturn err;\n\t}\n\n\tnb = &mlxsw_sp_switchdev_blocking_notifier;\n\terr = register_switchdev_blocking_notifier(nb);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to register switchdev blocking notifier\\n\");\n\t\tgoto err_register_switchdev_blocking_notifier;\n\t}\n\n\tINIT_DELAYED_WORK(&bridge->fdb_notify.dw, mlxsw_sp_fdb_notify_work);\n\tbridge->fdb_notify.interval = MLXSW_SP_DEFAULT_LEARNING_INTERVAL;\n\treturn 0;\n\nerr_register_switchdev_blocking_notifier:\n\tunregister_switchdev_notifier(&mlxsw_sp_switchdev_notifier);\n\treturn err;\n}\n\nstatic void mlxsw_sp_fdb_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct notifier_block *nb;\n\n\tcancel_delayed_work_sync(&mlxsw_sp->bridge->fdb_notify.dw);\n\n\tnb = &mlxsw_sp_switchdev_blocking_notifier;\n\tunregister_switchdev_blocking_notifier(nb);\n\n\tunregister_switchdev_notifier(&mlxsw_sp_switchdev_notifier);\n}\n\nstatic void mlxsw_sp1_switchdev_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tmlxsw_sp->bridge->bridge_8021ad_ops = &mlxsw_sp1_bridge_8021ad_ops;\n}\n\nconst struct mlxsw_sp_switchdev_ops mlxsw_sp1_switchdev_ops = {\n\t.init\t= mlxsw_sp1_switchdev_init,\n};\n\nstatic void mlxsw_sp2_switchdev_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tmlxsw_sp->bridge->bridge_8021ad_ops = &mlxsw_sp2_bridge_8021ad_ops;\n}\n\nconst struct mlxsw_sp_switchdev_ops mlxsw_sp2_switchdev_ops = {\n\t.init\t= mlxsw_sp2_switchdev_init,\n};\n\nint mlxsw_sp_switchdev_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_bridge *bridge;\n\n\tbridge = kzalloc(sizeof(*mlxsw_sp->bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\tmlxsw_sp->bridge = bridge;\n\tbridge->mlxsw_sp = mlxsw_sp;\n\n\tINIT_LIST_HEAD(&mlxsw_sp->bridge->bridges_list);\n\n\tbridge->bridge_8021q_ops = &mlxsw_sp_bridge_8021q_ops;\n\tbridge->bridge_8021d_ops = &mlxsw_sp_bridge_8021d_ops;\n\n\tmlxsw_sp->switchdev_ops->init(mlxsw_sp);\n\n\treturn mlxsw_sp_fdb_init(mlxsw_sp);\n}\n\nvoid mlxsw_sp_switchdev_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tmlxsw_sp_fdb_fini(mlxsw_sp);\n\tWARN_ON(!list_empty(&mlxsw_sp->bridge->bridges_list));\n\tkfree(mlxsw_sp->bridge);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}