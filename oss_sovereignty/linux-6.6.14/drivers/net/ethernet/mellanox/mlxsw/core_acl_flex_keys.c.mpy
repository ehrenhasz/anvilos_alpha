{
  "module_name": "core_acl_flex_keys.c",
  "hash_id": "1dfcd97b81d3f561f048a40d17439dcef10ae9dd755df38c9541a11a1bf79308",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_keys.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/errno.h>\n\n#include \"item.h\"\n#include \"core_acl_flex_keys.h\"\n\n \nstatic const struct mlxsw_afk_element_info mlxsw_afk_element_infos[] = {\n\tMLXSW_AFK_ELEMENT_INFO_U32(SRC_SYS_PORT, 0x00, 16, 16),\n\tMLXSW_AFK_ELEMENT_INFO_BUF(DMAC_32_47, 0x04, 2),\n\tMLXSW_AFK_ELEMENT_INFO_BUF(DMAC_0_31, 0x06, 4),\n\tMLXSW_AFK_ELEMENT_INFO_BUF(SMAC_32_47, 0x0A, 2),\n\tMLXSW_AFK_ELEMENT_INFO_BUF(SMAC_0_31, 0x0C, 4),\n\tMLXSW_AFK_ELEMENT_INFO_U32(ETHERTYPE, 0x00, 0, 16),\n\tMLXSW_AFK_ELEMENT_INFO_U32(IP_PROTO, 0x10, 0, 8),\n\tMLXSW_AFK_ELEMENT_INFO_U32(VID, 0x10, 8, 12),\n\tMLXSW_AFK_ELEMENT_INFO_U32(PCP, 0x10, 20, 3),\n\tMLXSW_AFK_ELEMENT_INFO_U32(TCP_FLAGS, 0x10, 23, 9),\n\tMLXSW_AFK_ELEMENT_INFO_U32(DST_L4_PORT, 0x14, 0, 16),\n\tMLXSW_AFK_ELEMENT_INFO_U32(SRC_L4_PORT, 0x14, 16, 16),\n\tMLXSW_AFK_ELEMENT_INFO_U32(IP_TTL_, 0x18, 0, 8),\n\tMLXSW_AFK_ELEMENT_INFO_U32(IP_ECN, 0x18, 9, 2),\n\tMLXSW_AFK_ELEMENT_INFO_U32(IP_DSCP, 0x18, 11, 6),\n\tMLXSW_AFK_ELEMENT_INFO_U32(VIRT_ROUTER_MSB, 0x18, 17, 4),\n\tMLXSW_AFK_ELEMENT_INFO_U32(VIRT_ROUTER_LSB, 0x18, 21, 8),\n\tMLXSW_AFK_ELEMENT_INFO_BUF(SRC_IP_96_127, 0x20, 4),\n\tMLXSW_AFK_ELEMENT_INFO_BUF(SRC_IP_64_95, 0x24, 4),\n\tMLXSW_AFK_ELEMENT_INFO_BUF(SRC_IP_32_63, 0x28, 4),\n\tMLXSW_AFK_ELEMENT_INFO_BUF(SRC_IP_0_31, 0x2C, 4),\n\tMLXSW_AFK_ELEMENT_INFO_BUF(DST_IP_96_127, 0x30, 4),\n\tMLXSW_AFK_ELEMENT_INFO_BUF(DST_IP_64_95, 0x34, 4),\n\tMLXSW_AFK_ELEMENT_INFO_BUF(DST_IP_32_63, 0x38, 4),\n\tMLXSW_AFK_ELEMENT_INFO_BUF(DST_IP_0_31, 0x3C, 4),\n\tMLXSW_AFK_ELEMENT_INFO_U32(FDB_MISS, 0x40, 0, 1),\n\tMLXSW_AFK_ELEMENT_INFO_U32(L4_PORT_RANGE, 0x40, 1, 16),\n};\n\nstruct mlxsw_afk {\n\tstruct list_head key_info_list;\n\tunsigned int max_blocks;\n\tconst struct mlxsw_afk_ops *ops;\n\tconst struct mlxsw_afk_block *blocks;\n\tunsigned int blocks_count;\n};\n\nstatic bool mlxsw_afk_blocks_check(struct mlxsw_afk *mlxsw_afk)\n{\n\tint i;\n\tint j;\n\n\tfor (i = 0; i < mlxsw_afk->blocks_count; i++) {\n\t\tconst struct mlxsw_afk_block *block = &mlxsw_afk->blocks[i];\n\n\t\tfor (j = 0; j < block->instances_count; j++) {\n\t\t\tconst struct mlxsw_afk_element_info *elinfo;\n\t\t\tstruct mlxsw_afk_element_inst *elinst;\n\n\t\t\telinst = &block->instances[j];\n\t\t\telinfo = &mlxsw_afk_element_infos[elinst->element];\n\t\t\tif (elinst->type != elinfo->type ||\n\t\t\t    (!elinst->avoid_size_check &&\n\t\t\t     elinst->item.size.bits !=\n\t\t\t     elinfo->item.size.bits))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstruct mlxsw_afk *mlxsw_afk_create(unsigned int max_blocks,\n\t\t\t\t   const struct mlxsw_afk_ops *ops)\n{\n\tstruct mlxsw_afk *mlxsw_afk;\n\n\tmlxsw_afk = kzalloc(sizeof(*mlxsw_afk), GFP_KERNEL);\n\tif (!mlxsw_afk)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&mlxsw_afk->key_info_list);\n\tmlxsw_afk->max_blocks = max_blocks;\n\tmlxsw_afk->ops = ops;\n\tmlxsw_afk->blocks = ops->blocks;\n\tmlxsw_afk->blocks_count = ops->blocks_count;\n\tWARN_ON(!mlxsw_afk_blocks_check(mlxsw_afk));\n\treturn mlxsw_afk;\n}\nEXPORT_SYMBOL(mlxsw_afk_create);\n\nvoid mlxsw_afk_destroy(struct mlxsw_afk *mlxsw_afk)\n{\n\tWARN_ON(!list_empty(&mlxsw_afk->key_info_list));\n\tkfree(mlxsw_afk);\n}\nEXPORT_SYMBOL(mlxsw_afk_destroy);\n\nstruct mlxsw_afk_key_info {\n\tstruct list_head list;\n\tunsigned int ref_count;\n\tunsigned int blocks_count;\n\tint element_to_block[MLXSW_AFK_ELEMENT_MAX];  \n\tstruct mlxsw_afk_element_usage elusage;\n\tconst struct mlxsw_afk_block *blocks[];\n};\n\nstatic bool\nmlxsw_afk_key_info_elements_eq(struct mlxsw_afk_key_info *key_info,\n\t\t\t       struct mlxsw_afk_element_usage *elusage)\n{\n\treturn memcmp(&key_info->elusage, elusage, sizeof(*elusage)) == 0;\n}\n\nstatic struct mlxsw_afk_key_info *\nmlxsw_afk_key_info_find(struct mlxsw_afk *mlxsw_afk,\n\t\t\tstruct mlxsw_afk_element_usage *elusage)\n{\n\tstruct mlxsw_afk_key_info *key_info;\n\n\tlist_for_each_entry(key_info, &mlxsw_afk->key_info_list, list) {\n\t\tif (mlxsw_afk_key_info_elements_eq(key_info, elusage))\n\t\t\treturn key_info;\n\t}\n\treturn NULL;\n}\n\nstruct mlxsw_afk_picker {\n\tDECLARE_BITMAP(element, MLXSW_AFK_ELEMENT_MAX);\n\tunsigned int total;\n};\n\nstatic void mlxsw_afk_picker_count_hits(struct mlxsw_afk *mlxsw_afk,\n\t\t\t\t\tstruct mlxsw_afk_picker *picker,\n\t\t\t\t\tenum mlxsw_afk_element element)\n{\n\tint i;\n\tint j;\n\n\tfor (i = 0; i < mlxsw_afk->blocks_count; i++) {\n\t\tconst struct mlxsw_afk_block *block = &mlxsw_afk->blocks[i];\n\n\t\tfor (j = 0; j < block->instances_count; j++) {\n\t\t\tstruct mlxsw_afk_element_inst *elinst;\n\n\t\t\telinst = &block->instances[j];\n\t\t\tif (elinst->element == element) {\n\t\t\t\t__set_bit(element, picker[i].element);\n\t\t\t\tpicker[i].total++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void mlxsw_afk_picker_subtract_hits(struct mlxsw_afk *mlxsw_afk,\n\t\t\t\t\t   struct mlxsw_afk_picker *picker,\n\t\t\t\t\t   int block_index)\n{\n\tDECLARE_BITMAP(hits_element, MLXSW_AFK_ELEMENT_MAX);\n\tint i;\n\tint j;\n\n\tmemcpy(&hits_element, &picker[block_index].element,\n\t       sizeof(hits_element));\n\n\tfor (i = 0; i < mlxsw_afk->blocks_count; i++) {\n\t\tfor_each_set_bit(j, hits_element, MLXSW_AFK_ELEMENT_MAX) {\n\t\t\tif (__test_and_clear_bit(j, picker[i].element))\n\t\t\t\tpicker[i].total--;\n\t\t}\n\t}\n}\n\nstatic int mlxsw_afk_picker_most_hits_get(struct mlxsw_afk *mlxsw_afk,\n\t\t\t\t\t  struct mlxsw_afk_picker *picker)\n{\n\tint most_index = -EINVAL;  \n\tint most_hits = 0;\n\tint i;\n\n\tfor (i = 0; i < mlxsw_afk->blocks_count; i++) {\n\t\tif (picker[i].total > most_hits) {\n\t\t\tmost_hits = picker[i].total;\n\t\t\tmost_index = i;\n\t\t}\n\t}\n\treturn most_index;\n}\n\nstatic int mlxsw_afk_picker_key_info_add(struct mlxsw_afk *mlxsw_afk,\n\t\t\t\t\t struct mlxsw_afk_picker *picker,\n\t\t\t\t\t int block_index,\n\t\t\t\t\t struct mlxsw_afk_key_info *key_info)\n{\n\tenum mlxsw_afk_element element;\n\n\tif (key_info->blocks_count == mlxsw_afk->max_blocks)\n\t\treturn -EINVAL;\n\n\tfor_each_set_bit(element, picker[block_index].element,\n\t\t\t MLXSW_AFK_ELEMENT_MAX) {\n\t\tkey_info->element_to_block[element] = key_info->blocks_count;\n\t\tmlxsw_afk_element_usage_add(&key_info->elusage, element);\n\t}\n\n\tkey_info->blocks[key_info->blocks_count] =\n\t\t\t\t\t&mlxsw_afk->blocks[block_index];\n\tkey_info->blocks_count++;\n\treturn 0;\n}\n\nstatic int mlxsw_afk_picker(struct mlxsw_afk *mlxsw_afk,\n\t\t\t    struct mlxsw_afk_key_info *key_info,\n\t\t\t    struct mlxsw_afk_element_usage *elusage)\n{\n\tstruct mlxsw_afk_picker *picker;\n\tenum mlxsw_afk_element element;\n\tint err;\n\n\tpicker = kcalloc(mlxsw_afk->blocks_count, sizeof(*picker), GFP_KERNEL);\n\tif (!picker)\n\t\treturn -ENOMEM;\n\n\t \n\n\tmlxsw_afk_element_usage_for_each(element, elusage)\n\t\tmlxsw_afk_picker_count_hits(mlxsw_afk, picker, element);\n\n\tdo {\n\t\tint block_index;\n\n\t\tblock_index = mlxsw_afk_picker_most_hits_get(mlxsw_afk, picker);\n\t\tif (block_index < 0) {\n\t\t\terr = block_index;\n\t\t\tgoto out;\n\t\t}\n\t\terr = mlxsw_afk_picker_key_info_add(mlxsw_afk, picker,\n\t\t\t\t\t\t    block_index, key_info);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tmlxsw_afk_picker_subtract_hits(mlxsw_afk, picker, block_index);\n\t} while (!mlxsw_afk_key_info_elements_eq(key_info, elusage));\n\n\terr = 0;\nout:\n\tkfree(picker);\n\treturn err;\n}\n\nstatic struct mlxsw_afk_key_info *\nmlxsw_afk_key_info_create(struct mlxsw_afk *mlxsw_afk,\n\t\t\t  struct mlxsw_afk_element_usage *elusage)\n{\n\tstruct mlxsw_afk_key_info *key_info;\n\tint err;\n\n\tkey_info = kzalloc(struct_size(key_info, blocks, mlxsw_afk->max_blocks),\n\t\t\t   GFP_KERNEL);\n\tif (!key_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = mlxsw_afk_picker(mlxsw_afk, key_info, elusage);\n\tif (err)\n\t\tgoto err_picker;\n\tlist_add(&key_info->list, &mlxsw_afk->key_info_list);\n\tkey_info->ref_count = 1;\n\treturn key_info;\n\nerr_picker:\n\tkfree(key_info);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_afk_key_info_destroy(struct mlxsw_afk_key_info *key_info)\n{\n\tlist_del(&key_info->list);\n\tkfree(key_info);\n}\n\nstruct mlxsw_afk_key_info *\nmlxsw_afk_key_info_get(struct mlxsw_afk *mlxsw_afk,\n\t\t       struct mlxsw_afk_element_usage *elusage)\n{\n\tstruct mlxsw_afk_key_info *key_info;\n\n\tkey_info = mlxsw_afk_key_info_find(mlxsw_afk, elusage);\n\tif (key_info) {\n\t\tkey_info->ref_count++;\n\t\treturn key_info;\n\t}\n\treturn mlxsw_afk_key_info_create(mlxsw_afk, elusage);\n}\nEXPORT_SYMBOL(mlxsw_afk_key_info_get);\n\nvoid mlxsw_afk_key_info_put(struct mlxsw_afk_key_info *key_info)\n{\n\tif (--key_info->ref_count)\n\t\treturn;\n\tmlxsw_afk_key_info_destroy(key_info);\n}\nEXPORT_SYMBOL(mlxsw_afk_key_info_put);\n\nbool mlxsw_afk_key_info_subset(struct mlxsw_afk_key_info *key_info,\n\t\t\t       struct mlxsw_afk_element_usage *elusage)\n{\n\treturn mlxsw_afk_element_usage_subset(elusage, &key_info->elusage);\n}\nEXPORT_SYMBOL(mlxsw_afk_key_info_subset);\n\nstatic const struct mlxsw_afk_element_inst *\nmlxsw_afk_block_elinst_get(const struct mlxsw_afk_block *block,\n\t\t\t   enum mlxsw_afk_element element)\n{\n\tint i;\n\n\tfor (i = 0; i < block->instances_count; i++) {\n\t\tstruct mlxsw_afk_element_inst *elinst;\n\n\t\telinst = &block->instances[i];\n\t\tif (elinst->element == element)\n\t\t\treturn elinst;\n\t}\n\treturn NULL;\n}\n\nstatic const struct mlxsw_afk_element_inst *\nmlxsw_afk_key_info_elinst_get(struct mlxsw_afk_key_info *key_info,\n\t\t\t      enum mlxsw_afk_element element,\n\t\t\t      int *p_block_index)\n{\n\tconst struct mlxsw_afk_element_inst *elinst;\n\tconst struct mlxsw_afk_block *block;\n\tint block_index;\n\n\tif (WARN_ON(!test_bit(element, key_info->elusage.usage)))\n\t\treturn NULL;\n\tblock_index = key_info->element_to_block[element];\n\tblock = key_info->blocks[block_index];\n\n\telinst = mlxsw_afk_block_elinst_get(block, element);\n\tif (WARN_ON(!elinst))\n\t\treturn NULL;\n\n\t*p_block_index = block_index;\n\treturn elinst;\n}\n\nu16\nmlxsw_afk_key_info_block_encoding_get(const struct mlxsw_afk_key_info *key_info,\n\t\t\t\t      int block_index)\n{\n\treturn key_info->blocks[block_index]->encoding;\n}\nEXPORT_SYMBOL(mlxsw_afk_key_info_block_encoding_get);\n\nunsigned int\nmlxsw_afk_key_info_blocks_count_get(const struct mlxsw_afk_key_info *key_info)\n{\n\treturn key_info->blocks_count;\n}\nEXPORT_SYMBOL(mlxsw_afk_key_info_blocks_count_get);\n\nvoid mlxsw_afk_values_add_u32(struct mlxsw_afk_element_values *values,\n\t\t\t      enum mlxsw_afk_element element,\n\t\t\t      u32 key_value, u32 mask_value)\n{\n\tconst struct mlxsw_afk_element_info *elinfo =\n\t\t\t\t&mlxsw_afk_element_infos[element];\n\tconst struct mlxsw_item *storage_item = &elinfo->item;\n\n\tif (!mask_value)\n\t\treturn;\n\tif (WARN_ON(elinfo->type != MLXSW_AFK_ELEMENT_TYPE_U32))\n\t\treturn;\n\t__mlxsw_item_set32(values->storage.key, storage_item, 0, key_value);\n\t__mlxsw_item_set32(values->storage.mask, storage_item, 0, mask_value);\n\tmlxsw_afk_element_usage_add(&values->elusage, element);\n}\nEXPORT_SYMBOL(mlxsw_afk_values_add_u32);\n\nvoid mlxsw_afk_values_add_buf(struct mlxsw_afk_element_values *values,\n\t\t\t      enum mlxsw_afk_element element,\n\t\t\t      const char *key_value, const char *mask_value,\n\t\t\t      unsigned int len)\n{\n\tconst struct mlxsw_afk_element_info *elinfo =\n\t\t\t\t&mlxsw_afk_element_infos[element];\n\tconst struct mlxsw_item *storage_item = &elinfo->item;\n\n\tif (!memchr_inv(mask_value, 0, len))  \n\t\treturn;\n\tif (WARN_ON(elinfo->type != MLXSW_AFK_ELEMENT_TYPE_BUF) ||\n\t    WARN_ON(elinfo->item.size.bytes != len))\n\t\treturn;\n\t__mlxsw_item_memcpy_to(values->storage.key, key_value,\n\t\t\t       storage_item, 0);\n\t__mlxsw_item_memcpy_to(values->storage.mask, mask_value,\n\t\t\t       storage_item, 0);\n\tmlxsw_afk_element_usage_add(&values->elusage, element);\n}\nEXPORT_SYMBOL(mlxsw_afk_values_add_buf);\n\nstatic void mlxsw_sp_afk_encode_u32(const struct mlxsw_item *storage_item,\n\t\t\t\t    const struct mlxsw_item *output_item,\n\t\t\t\t    char *storage, char *output, int diff)\n{\n\tu32 value;\n\n\tvalue = __mlxsw_item_get32(storage, storage_item, 0);\n\t__mlxsw_item_set32(output, output_item, 0, value + diff);\n}\n\nstatic void mlxsw_sp_afk_encode_buf(const struct mlxsw_item *storage_item,\n\t\t\t\t    const struct mlxsw_item *output_item,\n\t\t\t\t    char *storage, char *output)\n{\n\tchar *storage_data = __mlxsw_item_data(storage, storage_item, 0);\n\tchar *output_data = __mlxsw_item_data(output, output_item, 0);\n\tsize_t len = output_item->size.bytes;\n\n\tmemcpy(output_data, storage_data, len);\n}\n\nstatic void\nmlxsw_sp_afk_encode_one(const struct mlxsw_afk_element_inst *elinst,\n\t\t\tchar *output, char *storage, int u32_diff)\n{\n\tconst struct mlxsw_item *output_item = &elinst->item;\n\tconst struct mlxsw_afk_element_info *elinfo;\n\tconst struct mlxsw_item *storage_item;\n\n\telinfo = &mlxsw_afk_element_infos[elinst->element];\n\tstorage_item = &elinfo->item;\n\tif (elinst->type == MLXSW_AFK_ELEMENT_TYPE_U32)\n\t\tmlxsw_sp_afk_encode_u32(storage_item, output_item,\n\t\t\t\t\tstorage, output, u32_diff);\n\telse if (elinst->type == MLXSW_AFK_ELEMENT_TYPE_BUF)\n\t\tmlxsw_sp_afk_encode_buf(storage_item, output_item,\n\t\t\t\t\tstorage, output);\n}\n\n#define MLXSW_SP_AFK_KEY_BLOCK_MAX_SIZE 16\n\nvoid mlxsw_afk_encode(struct mlxsw_afk *mlxsw_afk,\n\t\t      struct mlxsw_afk_key_info *key_info,\n\t\t      struct mlxsw_afk_element_values *values,\n\t\t      char *key, char *mask)\n{\n\tunsigned int blocks_count =\n\t\t\tmlxsw_afk_key_info_blocks_count_get(key_info);\n\tchar block_mask[MLXSW_SP_AFK_KEY_BLOCK_MAX_SIZE];\n\tchar block_key[MLXSW_SP_AFK_KEY_BLOCK_MAX_SIZE];\n\tconst struct mlxsw_afk_element_inst *elinst;\n\tenum mlxsw_afk_element element;\n\tint block_index, i;\n\n\tfor (i = 0; i < blocks_count; i++) {\n\t\tmemset(block_key, 0, MLXSW_SP_AFK_KEY_BLOCK_MAX_SIZE);\n\t\tmemset(block_mask, 0, MLXSW_SP_AFK_KEY_BLOCK_MAX_SIZE);\n\n\t\tmlxsw_afk_element_usage_for_each(element, &values->elusage) {\n\t\t\telinst = mlxsw_afk_key_info_elinst_get(key_info,\n\t\t\t\t\t\t\t       element,\n\t\t\t\t\t\t\t       &block_index);\n\t\t\tif (!elinst || block_index != i)\n\t\t\t\tcontinue;\n\n\t\t\tmlxsw_sp_afk_encode_one(elinst, block_key,\n\t\t\t\t\t\tvalues->storage.key,\n\t\t\t\t\t\telinst->u32_key_diff);\n\t\t\tmlxsw_sp_afk_encode_one(elinst, block_mask,\n\t\t\t\t\t\tvalues->storage.mask, 0);\n\t\t}\n\n\t\tmlxsw_afk->ops->encode_block(key, i, block_key);\n\t\tmlxsw_afk->ops->encode_block(mask, i, block_mask);\n\t}\n}\nEXPORT_SYMBOL(mlxsw_afk_encode);\n\nvoid mlxsw_afk_clear(struct mlxsw_afk *mlxsw_afk, char *key,\n\t\t     int block_start, int block_end)\n{\n\tint i;\n\n\tfor (i = block_start; i <= block_end; i++)\n\t\tmlxsw_afk->ops->clear_block(key, i);\n}\nEXPORT_SYMBOL(mlxsw_afk_clear);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}