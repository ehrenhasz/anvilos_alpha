{
  "module_name": "spectrum_acl_erp.c",
  "hash_id": "15005e3843f4a3b53cbe2c2864d7bd2deb6f86b5ff3d2c51b19110f6ecbcefa8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_erp.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/errno.h>\n#include <linux/genalloc.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/objagg.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n\n#include \"core.h\"\n#include \"reg.h\"\n#include \"spectrum.h\"\n#include \"spectrum_acl_tcam.h\"\n\n \n#define MLXSW_SP_ACL_ERP_GENALLOC_OFFSET 0x100\n#define MLXSW_SP_ACL_ERP_MAX_PER_REGION 16\n\nstruct mlxsw_sp_acl_erp_core {\n\tunsigned int erpt_entries_size[MLXSW_SP_ACL_ATCAM_REGION_TYPE_MAX + 1];\n\tstruct gen_pool *erp_tables;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tstruct mlxsw_sp_acl_bf *bf;\n\tunsigned int num_erp_banks;\n};\n\nstruct mlxsw_sp_acl_erp_key {\n\tchar mask[MLXSW_REG_PTCEX_FLEX_KEY_BLOCKS_LEN];\n#define __MASK_LEN 0x38\n#define __MASK_IDX(i) (__MASK_LEN - (i) - 1)\n\tbool ctcam;\n};\n\nstruct mlxsw_sp_acl_erp {\n\tstruct mlxsw_sp_acl_erp_key key;\n\tu8 id;\n\tu8 index;\n\tDECLARE_BITMAP(mask_bitmap, MLXSW_SP_ACL_TCAM_MASK_LEN);\n\tstruct list_head list;\n\tstruct mlxsw_sp_acl_erp_table *erp_table;\n};\n\nstruct mlxsw_sp_acl_erp_master_mask {\n\tDECLARE_BITMAP(bitmap, MLXSW_SP_ACL_TCAM_MASK_LEN);\n\tunsigned int count[MLXSW_SP_ACL_TCAM_MASK_LEN];\n};\n\nstruct mlxsw_sp_acl_erp_table {\n\tstruct mlxsw_sp_acl_erp_master_mask master_mask;\n\tDECLARE_BITMAP(erp_id_bitmap, MLXSW_SP_ACL_ERP_MAX_PER_REGION);\n\tDECLARE_BITMAP(erp_index_bitmap, MLXSW_SP_ACL_ERP_MAX_PER_REGION);\n\tstruct list_head atcam_erps_list;\n\tstruct mlxsw_sp_acl_erp_core *erp_core;\n\tstruct mlxsw_sp_acl_atcam_region *aregion;\n\tconst struct mlxsw_sp_acl_erp_table_ops *ops;\n\tunsigned long base_index;\n\tunsigned int num_atcam_erps;\n\tunsigned int num_max_atcam_erps;\n\tunsigned int num_ctcam_erps;\n\tunsigned int num_deltas;\n\tstruct objagg *objagg;\n\tstruct mutex objagg_lock;  \n};\n\nstruct mlxsw_sp_acl_erp_table_ops {\n\tstruct mlxsw_sp_acl_erp *\n\t\t(*erp_create)(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t      struct mlxsw_sp_acl_erp_key *key);\n\tvoid (*erp_destroy)(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t    struct mlxsw_sp_acl_erp *erp);\n};\n\nstatic struct mlxsw_sp_acl_erp *\nmlxsw_sp_acl_erp_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t     struct mlxsw_sp_acl_erp_key *key);\nstatic void\nmlxsw_sp_acl_erp_mask_destroy(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t      struct mlxsw_sp_acl_erp *erp);\nstatic struct mlxsw_sp_acl_erp *\nmlxsw_sp_acl_erp_second_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t    struct mlxsw_sp_acl_erp_key *key);\nstatic void\nmlxsw_sp_acl_erp_second_mask_destroy(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t     struct mlxsw_sp_acl_erp *erp);\nstatic struct mlxsw_sp_acl_erp *\nmlxsw_sp_acl_erp_first_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t   struct mlxsw_sp_acl_erp_key *key);\nstatic void\nmlxsw_sp_acl_erp_first_mask_destroy(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t    struct mlxsw_sp_acl_erp *erp);\nstatic void\nmlxsw_sp_acl_erp_no_mask_destroy(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t struct mlxsw_sp_acl_erp *erp);\n\nstatic const struct mlxsw_sp_acl_erp_table_ops erp_multiple_masks_ops = {\n\t.erp_create = mlxsw_sp_acl_erp_mask_create,\n\t.erp_destroy = mlxsw_sp_acl_erp_mask_destroy,\n};\n\nstatic const struct mlxsw_sp_acl_erp_table_ops erp_two_masks_ops = {\n\t.erp_create = mlxsw_sp_acl_erp_mask_create,\n\t.erp_destroy = mlxsw_sp_acl_erp_second_mask_destroy,\n};\n\nstatic const struct mlxsw_sp_acl_erp_table_ops erp_single_mask_ops = {\n\t.erp_create = mlxsw_sp_acl_erp_second_mask_create,\n\t.erp_destroy = mlxsw_sp_acl_erp_first_mask_destroy,\n};\n\nstatic const struct mlxsw_sp_acl_erp_table_ops erp_no_mask_ops = {\n\t.erp_create = mlxsw_sp_acl_erp_first_mask_create,\n\t.erp_destroy = mlxsw_sp_acl_erp_no_mask_destroy,\n};\n\nstatic bool\nmlxsw_sp_acl_erp_table_is_used(const struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\treturn erp_table->ops != &erp_single_mask_ops &&\n\t       erp_table->ops != &erp_no_mask_ops;\n}\n\nstatic unsigned int\nmlxsw_sp_acl_erp_bank_get(const struct mlxsw_sp_acl_erp *erp)\n{\n\treturn erp->index % erp->erp_table->erp_core->num_erp_banks;\n}\n\nstatic unsigned int\nmlxsw_sp_acl_erp_table_entry_size(const struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\tstruct mlxsw_sp_acl_atcam_region *aregion = erp_table->aregion;\n\tstruct mlxsw_sp_acl_erp_core *erp_core = erp_table->erp_core;\n\n\treturn erp_core->erpt_entries_size[aregion->type];\n}\n\nstatic int mlxsw_sp_acl_erp_id_get(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t   u8 *p_id)\n{\n\tu8 id;\n\n\tid = find_first_zero_bit(erp_table->erp_id_bitmap,\n\t\t\t\t MLXSW_SP_ACL_ERP_MAX_PER_REGION);\n\tif (id < MLXSW_SP_ACL_ERP_MAX_PER_REGION) {\n\t\t__set_bit(id, erp_table->erp_id_bitmap);\n\t\t*p_id = id;\n\t\treturn 0;\n\t}\n\n\treturn -ENOBUFS;\n}\n\nstatic void mlxsw_sp_acl_erp_id_put(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t    u8 id)\n{\n\t__clear_bit(id, erp_table->erp_id_bitmap);\n}\n\nstatic void\nmlxsw_sp_acl_erp_master_mask_bit_set(unsigned long bit,\n\t\t\t\t     struct mlxsw_sp_acl_erp_master_mask *mask)\n{\n\tif (mask->count[bit]++ == 0)\n\t\t__set_bit(bit, mask->bitmap);\n}\n\nstatic void\nmlxsw_sp_acl_erp_master_mask_bit_clear(unsigned long bit,\n\t\t\t\t       struct mlxsw_sp_acl_erp_master_mask *mask)\n{\n\tif (--mask->count[bit] == 0)\n\t\t__clear_bit(bit, mask->bitmap);\n}\n\nstatic int\nmlxsw_sp_acl_erp_master_mask_update(struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\tstruct mlxsw_sp_acl_tcam_region *region = erp_table->aregion->region;\n\tstruct mlxsw_sp *mlxsw_sp = region->mlxsw_sp;\n\tchar percr_pl[MLXSW_REG_PERCR_LEN];\n\tchar *master_mask;\n\n\tmlxsw_reg_percr_pack(percr_pl, region->id);\n\tmaster_mask = mlxsw_reg_percr_master_mask_data(percr_pl);\n\tbitmap_to_arr32((u32 *) master_mask, erp_table->master_mask.bitmap,\n\t\t\tMLXSW_SP_ACL_TCAM_MASK_LEN);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(percr), percr_pl);\n}\n\nstatic int\nmlxsw_sp_acl_erp_master_mask_set(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t struct mlxsw_sp_acl_erp_key *key)\n{\n\tDECLARE_BITMAP(mask_bitmap, MLXSW_SP_ACL_TCAM_MASK_LEN);\n\tunsigned long bit;\n\tint err;\n\n\tbitmap_from_arr32(mask_bitmap, (u32 *) key->mask,\n\t\t\t  MLXSW_SP_ACL_TCAM_MASK_LEN);\n\tfor_each_set_bit(bit, mask_bitmap, MLXSW_SP_ACL_TCAM_MASK_LEN)\n\t\tmlxsw_sp_acl_erp_master_mask_bit_set(bit,\n\t\t\t\t\t\t     &erp_table->master_mask);\n\n\terr = mlxsw_sp_acl_erp_master_mask_update(erp_table);\n\tif (err)\n\t\tgoto err_master_mask_update;\n\n\treturn 0;\n\nerr_master_mask_update:\n\tfor_each_set_bit(bit, mask_bitmap, MLXSW_SP_ACL_TCAM_MASK_LEN)\n\t\tmlxsw_sp_acl_erp_master_mask_bit_clear(bit,\n\t\t\t\t\t\t       &erp_table->master_mask);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_acl_erp_master_mask_clear(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t   struct mlxsw_sp_acl_erp_key *key)\n{\n\tDECLARE_BITMAP(mask_bitmap, MLXSW_SP_ACL_TCAM_MASK_LEN);\n\tunsigned long bit;\n\tint err;\n\n\tbitmap_from_arr32(mask_bitmap, (u32 *) key->mask,\n\t\t\t  MLXSW_SP_ACL_TCAM_MASK_LEN);\n\tfor_each_set_bit(bit, mask_bitmap, MLXSW_SP_ACL_TCAM_MASK_LEN)\n\t\tmlxsw_sp_acl_erp_master_mask_bit_clear(bit,\n\t\t\t\t\t\t       &erp_table->master_mask);\n\n\terr = mlxsw_sp_acl_erp_master_mask_update(erp_table);\n\tif (err)\n\t\tgoto err_master_mask_update;\n\n\treturn 0;\n\nerr_master_mask_update:\n\tfor_each_set_bit(bit, mask_bitmap, MLXSW_SP_ACL_TCAM_MASK_LEN)\n\t\tmlxsw_sp_acl_erp_master_mask_bit_set(bit,\n\t\t\t\t\t\t     &erp_table->master_mask);\n\treturn err;\n}\n\nstatic struct mlxsw_sp_acl_erp *\nmlxsw_sp_acl_erp_generic_create(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\tstruct mlxsw_sp_acl_erp_key *key)\n{\n\tstruct mlxsw_sp_acl_erp *erp;\n\tint err;\n\n\terp = kzalloc(sizeof(*erp), GFP_KERNEL);\n\tif (!erp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = mlxsw_sp_acl_erp_id_get(erp_table, &erp->id);\n\tif (err)\n\t\tgoto err_erp_id_get;\n\n\tmemcpy(&erp->key, key, sizeof(*key));\n\tlist_add(&erp->list, &erp_table->atcam_erps_list);\n\terp_table->num_atcam_erps++;\n\terp->erp_table = erp_table;\n\n\terr = mlxsw_sp_acl_erp_master_mask_set(erp_table, &erp->key);\n\tif (err)\n\t\tgoto err_master_mask_set;\n\n\treturn erp;\n\nerr_master_mask_set:\n\terp_table->num_atcam_erps--;\n\tlist_del(&erp->list);\n\tmlxsw_sp_acl_erp_id_put(erp_table, erp->id);\nerr_erp_id_get:\n\tkfree(erp);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_acl_erp_generic_destroy(struct mlxsw_sp_acl_erp *erp)\n{\n\tstruct mlxsw_sp_acl_erp_table *erp_table = erp->erp_table;\n\n\tmlxsw_sp_acl_erp_master_mask_clear(erp_table, &erp->key);\n\terp_table->num_atcam_erps--;\n\tlist_del(&erp->list);\n\tmlxsw_sp_acl_erp_id_put(erp_table, erp->id);\n\tkfree(erp);\n}\n\nstatic int\nmlxsw_sp_acl_erp_table_alloc(struct mlxsw_sp_acl_erp_core *erp_core,\n\t\t\t     unsigned int num_erps,\n\t\t\t     enum mlxsw_sp_acl_atcam_region_type region_type,\n\t\t\t     unsigned long *p_index)\n{\n\tunsigned int num_rows, entry_size;\n\tunsigned long index;\n\n\t \n\tif (num_erps % erp_core->num_erp_banks != 0)\n\t\treturn -EINVAL;\n\n\tentry_size = erp_core->erpt_entries_size[region_type];\n\tnum_rows = num_erps / erp_core->num_erp_banks;\n\n\tindex = gen_pool_alloc(erp_core->erp_tables, num_rows * entry_size);\n\tif (!index)\n\t\treturn -ENOBUFS;\n\n\t*p_index = index - MLXSW_SP_ACL_ERP_GENALLOC_OFFSET;\n\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_acl_erp_table_free(struct mlxsw_sp_acl_erp_core *erp_core,\n\t\t\t    unsigned int num_erps,\n\t\t\t    enum mlxsw_sp_acl_atcam_region_type region_type,\n\t\t\t    unsigned long index)\n{\n\tunsigned long base_index;\n\tunsigned int entry_size;\n\tsize_t size;\n\n\tentry_size = erp_core->erpt_entries_size[region_type];\n\tbase_index = index + MLXSW_SP_ACL_ERP_GENALLOC_OFFSET;\n\tsize = num_erps / erp_core->num_erp_banks * entry_size;\n\tgen_pool_free(erp_core->erp_tables, base_index, size);\n}\n\nstatic struct mlxsw_sp_acl_erp *\nmlxsw_sp_acl_erp_table_master_rp(struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\tif (!list_is_singular(&erp_table->atcam_erps_list))\n\t\treturn NULL;\n\n\treturn list_first_entry(&erp_table->atcam_erps_list,\n\t\t\t\tstruct mlxsw_sp_acl_erp, list);\n}\n\nstatic int mlxsw_sp_acl_erp_index_get(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t      u8 *p_index)\n{\n\tu8 index;\n\n\tindex = find_first_zero_bit(erp_table->erp_index_bitmap,\n\t\t\t\t    erp_table->num_max_atcam_erps);\n\tif (index < erp_table->num_max_atcam_erps) {\n\t\t__set_bit(index, erp_table->erp_index_bitmap);\n\t\t*p_index = index;\n\t\treturn 0;\n\t}\n\n\treturn -ENOBUFS;\n}\n\nstatic void mlxsw_sp_acl_erp_index_put(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t       u8 index)\n{\n\t__clear_bit(index, erp_table->erp_index_bitmap);\n}\n\nstatic void\nmlxsw_sp_acl_erp_table_locate(const struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t      const struct mlxsw_sp_acl_erp *erp,\n\t\t\t      u8 *p_erpt_bank, u8 *p_erpt_index)\n{\n\tunsigned int entry_size = mlxsw_sp_acl_erp_table_entry_size(erp_table);\n\tstruct mlxsw_sp_acl_erp_core *erp_core = erp_table->erp_core;\n\tunsigned int row;\n\n\t*p_erpt_bank = erp->index % erp_core->num_erp_banks;\n\trow = erp->index / erp_core->num_erp_banks;\n\t*p_erpt_index = erp_table->base_index + row * entry_size;\n}\n\nstatic int\nmlxsw_sp_acl_erp_table_erp_add(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t       struct mlxsw_sp_acl_erp *erp)\n{\n\tstruct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;\n\tenum mlxsw_reg_perpt_key_size key_size;\n\tchar perpt_pl[MLXSW_REG_PERPT_LEN];\n\tu8 erpt_bank, erpt_index;\n\n\tmlxsw_sp_acl_erp_table_locate(erp_table, erp, &erpt_bank, &erpt_index);\n\tkey_size = (enum mlxsw_reg_perpt_key_size) erp_table->aregion->type;\n\tmlxsw_reg_perpt_pack(perpt_pl, erpt_bank, erpt_index, key_size, erp->id,\n\t\t\t     0, erp_table->base_index, erp->index,\n\t\t\t     erp->key.mask);\n\tmlxsw_reg_perpt_erp_vector_pack(perpt_pl, erp_table->erp_index_bitmap,\n\t\t\t\t\tMLXSW_SP_ACL_ERP_MAX_PER_REGION);\n\tmlxsw_reg_perpt_erp_vector_set(perpt_pl, erp->index, true);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(perpt), perpt_pl);\n}\n\nstatic void mlxsw_sp_acl_erp_table_erp_del(struct mlxsw_sp_acl_erp *erp)\n{\n\tchar empty_mask[MLXSW_REG_PTCEX_FLEX_KEY_BLOCKS_LEN] = { 0 };\n\tstruct mlxsw_sp_acl_erp_table *erp_table = erp->erp_table;\n\tstruct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;\n\tenum mlxsw_reg_perpt_key_size key_size;\n\tchar perpt_pl[MLXSW_REG_PERPT_LEN];\n\tu8 erpt_bank, erpt_index;\n\n\tmlxsw_sp_acl_erp_table_locate(erp_table, erp, &erpt_bank, &erpt_index);\n\tkey_size = (enum mlxsw_reg_perpt_key_size) erp_table->aregion->type;\n\tmlxsw_reg_perpt_pack(perpt_pl, erpt_bank, erpt_index, key_size, erp->id,\n\t\t\t     0, erp_table->base_index, erp->index, empty_mask);\n\tmlxsw_reg_perpt_erp_vector_pack(perpt_pl, erp_table->erp_index_bitmap,\n\t\t\t\t\tMLXSW_SP_ACL_ERP_MAX_PER_REGION);\n\tmlxsw_reg_perpt_erp_vector_set(perpt_pl, erp->index, false);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(perpt), perpt_pl);\n}\n\nstatic int\nmlxsw_sp_acl_erp_table_enable(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t      bool ctcam_le)\n{\n\tstruct mlxsw_sp_acl_tcam_region *region = erp_table->aregion->region;\n\tstruct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;\n\tchar pererp_pl[MLXSW_REG_PERERP_LEN];\n\n\tmlxsw_reg_pererp_pack(pererp_pl, region->id, ctcam_le, true, 0,\n\t\t\t      erp_table->base_index, 0);\n\tmlxsw_reg_pererp_erp_vector_pack(pererp_pl, erp_table->erp_index_bitmap,\n\t\t\t\t\t MLXSW_SP_ACL_ERP_MAX_PER_REGION);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pererp), pererp_pl);\n}\n\nstatic void\nmlxsw_sp_acl_erp_table_disable(struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\tstruct mlxsw_sp_acl_tcam_region *region = erp_table->aregion->region;\n\tstruct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;\n\tchar pererp_pl[MLXSW_REG_PERERP_LEN];\n\tstruct mlxsw_sp_acl_erp *master_rp;\n\n\tmaster_rp = mlxsw_sp_acl_erp_table_master_rp(erp_table);\n\t \n\tmlxsw_reg_pererp_pack(pererp_pl, region->id, false, false, 0, 0,\n\t\t\t      master_rp ? master_rp->id : 0);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pererp), pererp_pl);\n}\n\nstatic int\nmlxsw_sp_acl_erp_table_relocate(struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\tstruct mlxsw_sp_acl_erp *erp;\n\tint err;\n\n\tlist_for_each_entry(erp, &erp_table->atcam_erps_list, list) {\n\t\terr = mlxsw_sp_acl_erp_table_erp_add(erp_table, erp);\n\t\tif (err)\n\t\t\tgoto err_table_erp_add;\n\t}\n\n\treturn 0;\n\nerr_table_erp_add:\n\tlist_for_each_entry_continue_reverse(erp, &erp_table->atcam_erps_list,\n\t\t\t\t\t     list)\n\t\tmlxsw_sp_acl_erp_table_erp_del(erp);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_acl_erp_table_expand(struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\tunsigned int num_erps, old_num_erps = erp_table->num_max_atcam_erps;\n\tstruct mlxsw_sp_acl_erp_core *erp_core = erp_table->erp_core;\n\tunsigned long old_base_index = erp_table->base_index;\n\tbool ctcam_le = erp_table->num_ctcam_erps > 0;\n\tint err;\n\n\tif (erp_table->num_atcam_erps < erp_table->num_max_atcam_erps)\n\t\treturn 0;\n\n\tif (erp_table->num_max_atcam_erps == MLXSW_SP_ACL_ERP_MAX_PER_REGION)\n\t\treturn -ENOBUFS;\n\n\tnum_erps = old_num_erps + erp_core->num_erp_banks;\n\terr = mlxsw_sp_acl_erp_table_alloc(erp_core, num_erps,\n\t\t\t\t\t   erp_table->aregion->type,\n\t\t\t\t\t   &erp_table->base_index);\n\tif (err)\n\t\treturn err;\n\terp_table->num_max_atcam_erps = num_erps;\n\n\terr = mlxsw_sp_acl_erp_table_relocate(erp_table);\n\tif (err)\n\t\tgoto err_table_relocate;\n\n\terr = mlxsw_sp_acl_erp_table_enable(erp_table, ctcam_le);\n\tif (err)\n\t\tgoto err_table_enable;\n\n\tmlxsw_sp_acl_erp_table_free(erp_core, old_num_erps,\n\t\t\t\t    erp_table->aregion->type, old_base_index);\n\n\treturn 0;\n\nerr_table_enable:\nerr_table_relocate:\n\terp_table->num_max_atcam_erps = old_num_erps;\n\tmlxsw_sp_acl_erp_table_free(erp_core, num_erps,\n\t\t\t\t    erp_table->aregion->type,\n\t\t\t\t    erp_table->base_index);\n\terp_table->base_index = old_base_index;\n\treturn err;\n}\n\nstatic int\nmlxsw_acl_erp_table_bf_add(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t   struct mlxsw_sp_acl_erp *erp)\n{\n\tstruct mlxsw_sp_acl_atcam_region *aregion = erp_table->aregion;\n\tunsigned int erp_bank = mlxsw_sp_acl_erp_bank_get(erp);\n\tstruct mlxsw_sp_acl_atcam_entry *aentry;\n\tint err;\n\n\tlist_for_each_entry(aentry, &aregion->entries_list, list) {\n\t\terr = mlxsw_sp_acl_bf_entry_add(aregion->region->mlxsw_sp,\n\t\t\t\t\t\terp_table->erp_core->bf,\n\t\t\t\t\t\taregion, erp_bank, aentry);\n\t\tif (err)\n\t\t\tgoto bf_entry_add_err;\n\t}\n\n\treturn 0;\n\nbf_entry_add_err:\n\tlist_for_each_entry_continue_reverse(aentry, &aregion->entries_list,\n\t\t\t\t\t     list)\n\t\tmlxsw_sp_acl_bf_entry_del(aregion->region->mlxsw_sp,\n\t\t\t\t\t  erp_table->erp_core->bf,\n\t\t\t\t\t  aregion, erp_bank, aentry);\n\treturn err;\n}\n\nstatic void\nmlxsw_acl_erp_table_bf_del(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t   struct mlxsw_sp_acl_erp *erp)\n{\n\tstruct mlxsw_sp_acl_atcam_region *aregion = erp_table->aregion;\n\tunsigned int erp_bank = mlxsw_sp_acl_erp_bank_get(erp);\n\tstruct mlxsw_sp_acl_atcam_entry *aentry;\n\n\tlist_for_each_entry_reverse(aentry, &aregion->entries_list, list)\n\t\tmlxsw_sp_acl_bf_entry_del(aregion->region->mlxsw_sp,\n\t\t\t\t\t  erp_table->erp_core->bf,\n\t\t\t\t\t  aregion, erp_bank, aentry);\n}\n\nstatic int\nmlxsw_sp_acl_erp_region_table_trans(struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\tstruct mlxsw_sp_acl_erp_core *erp_core = erp_table->erp_core;\n\tstruct mlxsw_sp_acl_erp *master_rp;\n\tint err;\n\n\t \n\terr = mlxsw_sp_acl_erp_table_alloc(erp_core, erp_core->num_erp_banks,\n\t\t\t\t\t   erp_table->aregion->type,\n\t\t\t\t\t   &erp_table->base_index);\n\tif (err)\n\t\treturn err;\n\terp_table->num_max_atcam_erps = erp_core->num_erp_banks;\n\n\t \n\tmaster_rp = mlxsw_sp_acl_erp_table_master_rp(erp_table);\n\tif (!master_rp) {\n\t\terr = -EINVAL;\n\t\tgoto err_table_master_rp;\n\t}\n\n\t \n\tmaster_rp->index = 0;\n\t__set_bit(master_rp->index, erp_table->erp_index_bitmap);\n\n\terr = mlxsw_sp_acl_erp_table_erp_add(erp_table, master_rp);\n\tif (err)\n\t\tgoto err_table_master_rp_add;\n\n\t \n\terr = mlxsw_acl_erp_table_bf_add(erp_table, master_rp);\n\tif (err)\n\t\tgoto err_table_bf_add;\n\n\terr = mlxsw_sp_acl_erp_table_enable(erp_table, false);\n\tif (err)\n\t\tgoto err_table_enable;\n\n\treturn 0;\n\nerr_table_enable:\n\tmlxsw_acl_erp_table_bf_del(erp_table, master_rp);\nerr_table_bf_add:\n\tmlxsw_sp_acl_erp_table_erp_del(master_rp);\nerr_table_master_rp_add:\n\t__clear_bit(master_rp->index, erp_table->erp_index_bitmap);\nerr_table_master_rp:\n\tmlxsw_sp_acl_erp_table_free(erp_core, erp_table->num_max_atcam_erps,\n\t\t\t\t    erp_table->aregion->type,\n\t\t\t\t    erp_table->base_index);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_acl_erp_region_master_mask_trans(struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\tstruct mlxsw_sp_acl_erp_core *erp_core = erp_table->erp_core;\n\tstruct mlxsw_sp_acl_erp *master_rp;\n\n\tmlxsw_sp_acl_erp_table_disable(erp_table);\n\tmaster_rp = mlxsw_sp_acl_erp_table_master_rp(erp_table);\n\tif (!master_rp)\n\t\treturn;\n\tmlxsw_acl_erp_table_bf_del(erp_table, master_rp);\n\tmlxsw_sp_acl_erp_table_erp_del(master_rp);\n\t__clear_bit(master_rp->index, erp_table->erp_index_bitmap);\n\tmlxsw_sp_acl_erp_table_free(erp_core, erp_table->num_max_atcam_erps,\n\t\t\t\t    erp_table->aregion->type,\n\t\t\t\t    erp_table->base_index);\n}\n\nstatic int\nmlxsw_sp_acl_erp_region_erp_add(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\tstruct mlxsw_sp_acl_erp *erp)\n{\n\tstruct mlxsw_sp_acl_tcam_region *region = erp_table->aregion->region;\n\tstruct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;\n\tbool ctcam_le = erp_table->num_ctcam_erps > 0;\n\tchar pererp_pl[MLXSW_REG_PERERP_LEN];\n\n\tmlxsw_reg_pererp_pack(pererp_pl, region->id, ctcam_le, true, 0,\n\t\t\t      erp_table->base_index, 0);\n\tmlxsw_reg_pererp_erp_vector_pack(pererp_pl, erp_table->erp_index_bitmap,\n\t\t\t\t\t MLXSW_SP_ACL_ERP_MAX_PER_REGION);\n\tmlxsw_reg_pererp_erpt_vector_set(pererp_pl, erp->index, true);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pererp), pererp_pl);\n}\n\nstatic void mlxsw_sp_acl_erp_region_erp_del(struct mlxsw_sp_acl_erp *erp)\n{\n\tstruct mlxsw_sp_acl_erp_table *erp_table = erp->erp_table;\n\tstruct mlxsw_sp_acl_tcam_region *region = erp_table->aregion->region;\n\tstruct mlxsw_sp *mlxsw_sp = erp_table->erp_core->mlxsw_sp;\n\tbool ctcam_le = erp_table->num_ctcam_erps > 0;\n\tchar pererp_pl[MLXSW_REG_PERERP_LEN];\n\n\tmlxsw_reg_pererp_pack(pererp_pl, region->id, ctcam_le, true, 0,\n\t\t\t      erp_table->base_index, 0);\n\tmlxsw_reg_pererp_erp_vector_pack(pererp_pl, erp_table->erp_index_bitmap,\n\t\t\t\t\t MLXSW_SP_ACL_ERP_MAX_PER_REGION);\n\tmlxsw_reg_pererp_erpt_vector_set(pererp_pl, erp->index, false);\n\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pererp), pererp_pl);\n}\n\nstatic int\nmlxsw_sp_acl_erp_region_ctcam_enable(struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\t \n\tif (erp_table->num_ctcam_erps > 1)\n\t\treturn 0;\n\n\treturn mlxsw_sp_acl_erp_table_enable(erp_table, true);\n}\n\nstatic void\nmlxsw_sp_acl_erp_region_ctcam_disable(struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\t \n\tif (erp_table->num_ctcam_erps > 1)\n\t\treturn;\n\n\tmlxsw_sp_acl_erp_table_enable(erp_table, false);\n}\n\nstatic int\n__mlxsw_sp_acl_erp_table_other_inc(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t   unsigned int *inc_num)\n{\n\tint err;\n\n\t \n\tif (!mlxsw_sp_acl_erp_table_is_used(erp_table)) {\n\t\terr = mlxsw_sp_acl_erp_region_table_trans(erp_table);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (erp_table->ops != &erp_multiple_masks_ops)\n\t\terp_table->ops = &erp_multiple_masks_ops;\n\n\t(*inc_num)++;\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_acl_erp_ctcam_inc(struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\treturn __mlxsw_sp_acl_erp_table_other_inc(erp_table,\n\t\t\t\t\t\t  &erp_table->num_ctcam_erps);\n}\n\nstatic int mlxsw_sp_acl_erp_delta_inc(struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\treturn __mlxsw_sp_acl_erp_table_other_inc(erp_table,\n\t\t\t\t\t\t  &erp_table->num_deltas);\n}\n\nstatic void\n__mlxsw_sp_acl_erp_table_other_dec(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t   unsigned int *dec_num)\n{\n\t(*dec_num)--;\n\n\t \n\tif (erp_table->num_ctcam_erps > 0 || erp_table->num_deltas > 0)\n\t\treturn;\n\n\tswitch (erp_table->num_atcam_erps) {\n\tcase 2:\n\t\t \n\t\terp_table->ops = &erp_two_masks_ops;\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tmlxsw_sp_acl_erp_region_master_mask_trans(erp_table);\n\t\terp_table->ops = &erp_single_mask_ops;\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tmlxsw_sp_acl_erp_table_disable(erp_table);\n\t\tmlxsw_sp_acl_erp_table_free(erp_table->erp_core,\n\t\t\t\t\t    erp_table->num_max_atcam_erps,\n\t\t\t\t\t    erp_table->aregion->type,\n\t\t\t\t\t    erp_table->base_index);\n\t\terp_table->ops = &erp_no_mask_ops;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void mlxsw_sp_acl_erp_ctcam_dec(struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\t__mlxsw_sp_acl_erp_table_other_dec(erp_table,\n\t\t\t\t\t   &erp_table->num_ctcam_erps);\n}\n\nstatic void mlxsw_sp_acl_erp_delta_dec(struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\t__mlxsw_sp_acl_erp_table_other_dec(erp_table,\n\t\t\t\t\t   &erp_table->num_deltas);\n}\n\nstatic struct mlxsw_sp_acl_erp *\nmlxsw_sp_acl_erp_ctcam_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t   struct mlxsw_sp_acl_erp_key *key)\n{\n\tstruct mlxsw_sp_acl_erp *erp;\n\tint err;\n\n\terp = kzalloc(sizeof(*erp), GFP_KERNEL);\n\tif (!erp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(&erp->key, key, sizeof(*key));\n\tbitmap_from_arr32(erp->mask_bitmap, (u32 *) key->mask,\n\t\t\t  MLXSW_SP_ACL_TCAM_MASK_LEN);\n\n\terr = mlxsw_sp_acl_erp_ctcam_inc(erp_table);\n\tif (err)\n\t\tgoto err_erp_ctcam_inc;\n\n\terp->erp_table = erp_table;\n\n\terr = mlxsw_sp_acl_erp_master_mask_set(erp_table, &erp->key);\n\tif (err)\n\t\tgoto err_master_mask_set;\n\n\terr = mlxsw_sp_acl_erp_region_ctcam_enable(erp_table);\n\tif (err)\n\t\tgoto err_erp_region_ctcam_enable;\n\n\treturn erp;\n\nerr_erp_region_ctcam_enable:\n\tmlxsw_sp_acl_erp_master_mask_clear(erp_table, &erp->key);\nerr_master_mask_set:\n\tmlxsw_sp_acl_erp_ctcam_dec(erp_table);\nerr_erp_ctcam_inc:\n\tkfree(erp);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_acl_erp_ctcam_mask_destroy(struct mlxsw_sp_acl_erp *erp)\n{\n\tstruct mlxsw_sp_acl_erp_table *erp_table = erp->erp_table;\n\n\tmlxsw_sp_acl_erp_region_ctcam_disable(erp_table);\n\tmlxsw_sp_acl_erp_master_mask_clear(erp_table, &erp->key);\n\tmlxsw_sp_acl_erp_ctcam_dec(erp_table);\n\tkfree(erp);\n}\n\nstatic struct mlxsw_sp_acl_erp *\nmlxsw_sp_acl_erp_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t     struct mlxsw_sp_acl_erp_key *key)\n{\n\tstruct mlxsw_sp_acl_erp *erp;\n\tint err;\n\n\tif (key->ctcam)\n\t\treturn mlxsw_sp_acl_erp_ctcam_mask_create(erp_table, key);\n\n\t \n\terr = mlxsw_sp_acl_erp_table_expand(erp_table);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\terp = mlxsw_sp_acl_erp_generic_create(erp_table, key);\n\tif (IS_ERR(erp))\n\t\treturn erp;\n\n\terr = mlxsw_sp_acl_erp_index_get(erp_table, &erp->index);\n\tif (err)\n\t\tgoto err_erp_index_get;\n\n\terr = mlxsw_sp_acl_erp_table_erp_add(erp_table, erp);\n\tif (err)\n\t\tgoto err_table_erp_add;\n\n\terr = mlxsw_sp_acl_erp_region_erp_add(erp_table, erp);\n\tif (err)\n\t\tgoto err_region_erp_add;\n\n\terp_table->ops = &erp_multiple_masks_ops;\n\n\treturn erp;\n\nerr_region_erp_add:\n\tmlxsw_sp_acl_erp_table_erp_del(erp);\nerr_table_erp_add:\n\tmlxsw_sp_acl_erp_index_put(erp_table, erp->index);\nerr_erp_index_get:\n\tmlxsw_sp_acl_erp_generic_destroy(erp);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_acl_erp_mask_destroy(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t      struct mlxsw_sp_acl_erp *erp)\n{\n\tif (erp->key.ctcam)\n\t\treturn mlxsw_sp_acl_erp_ctcam_mask_destroy(erp);\n\n\tmlxsw_sp_acl_erp_region_erp_del(erp);\n\tmlxsw_sp_acl_erp_table_erp_del(erp);\n\tmlxsw_sp_acl_erp_index_put(erp_table, erp->index);\n\tmlxsw_sp_acl_erp_generic_destroy(erp);\n\n\tif (erp_table->num_atcam_erps == 2 && erp_table->num_ctcam_erps == 0 &&\n\t    erp_table->num_deltas == 0)\n\t\terp_table->ops = &erp_two_masks_ops;\n}\n\nstatic struct mlxsw_sp_acl_erp *\nmlxsw_sp_acl_erp_second_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t    struct mlxsw_sp_acl_erp_key *key)\n{\n\tstruct mlxsw_sp_acl_erp *erp;\n\tint err;\n\n\tif (key->ctcam)\n\t\treturn mlxsw_sp_acl_erp_ctcam_mask_create(erp_table, key);\n\n\t \n\terr = mlxsw_sp_acl_erp_region_table_trans(erp_table);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\terp = mlxsw_sp_acl_erp_generic_create(erp_table, key);\n\tif (IS_ERR(erp)) {\n\t\terr = PTR_ERR(erp);\n\t\tgoto err_erp_create;\n\t}\n\n\terr = mlxsw_sp_acl_erp_index_get(erp_table, &erp->index);\n\tif (err)\n\t\tgoto err_erp_index_get;\n\n\terr = mlxsw_sp_acl_erp_table_erp_add(erp_table, erp);\n\tif (err)\n\t\tgoto err_table_erp_add;\n\n\terr = mlxsw_sp_acl_erp_region_erp_add(erp_table, erp);\n\tif (err)\n\t\tgoto err_region_erp_add;\n\n\terp_table->ops = &erp_two_masks_ops;\n\n\treturn erp;\n\nerr_region_erp_add:\n\tmlxsw_sp_acl_erp_table_erp_del(erp);\nerr_table_erp_add:\n\tmlxsw_sp_acl_erp_index_put(erp_table, erp->index);\nerr_erp_index_get:\n\tmlxsw_sp_acl_erp_generic_destroy(erp);\nerr_erp_create:\n\tmlxsw_sp_acl_erp_region_master_mask_trans(erp_table);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_acl_erp_second_mask_destroy(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t     struct mlxsw_sp_acl_erp *erp)\n{\n\tif (erp->key.ctcam)\n\t\treturn mlxsw_sp_acl_erp_ctcam_mask_destroy(erp);\n\n\tmlxsw_sp_acl_erp_region_erp_del(erp);\n\tmlxsw_sp_acl_erp_table_erp_del(erp);\n\tmlxsw_sp_acl_erp_index_put(erp_table, erp->index);\n\tmlxsw_sp_acl_erp_generic_destroy(erp);\n\t \n\tmlxsw_sp_acl_erp_region_master_mask_trans(erp_table);\n\n\terp_table->ops = &erp_single_mask_ops;\n}\n\nstatic struct mlxsw_sp_acl_erp *\nmlxsw_sp_acl_erp_first_mask_create(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t   struct mlxsw_sp_acl_erp_key *key)\n{\n\tstruct mlxsw_sp_acl_erp *erp;\n\n\tif (key->ctcam)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terp = mlxsw_sp_acl_erp_generic_create(erp_table, key);\n\tif (IS_ERR(erp))\n\t\treturn erp;\n\n\terp_table->ops = &erp_single_mask_ops;\n\n\treturn erp;\n}\n\nstatic void\nmlxsw_sp_acl_erp_first_mask_destroy(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t    struct mlxsw_sp_acl_erp *erp)\n{\n\tmlxsw_sp_acl_erp_generic_destroy(erp);\n\terp_table->ops = &erp_no_mask_ops;\n}\n\nstatic void\nmlxsw_sp_acl_erp_no_mask_destroy(struct mlxsw_sp_acl_erp_table *erp_table,\n\t\t\t\t struct mlxsw_sp_acl_erp *erp)\n{\n\tWARN_ON(1);\n}\n\nstruct mlxsw_sp_acl_erp_mask *\nmlxsw_sp_acl_erp_mask_get(struct mlxsw_sp_acl_atcam_region *aregion,\n\t\t\t  const char *mask, bool ctcam)\n{\n\tstruct mlxsw_sp_acl_erp_table *erp_table = aregion->erp_table;\n\tstruct mlxsw_sp_acl_erp_key key;\n\tstruct objagg_obj *objagg_obj;\n\n\tmemcpy(key.mask, mask, MLXSW_REG_PTCEX_FLEX_KEY_BLOCKS_LEN);\n\tkey.ctcam = ctcam;\n\tmutex_lock(&erp_table->objagg_lock);\n\tobjagg_obj = objagg_obj_get(erp_table->objagg, &key);\n\tmutex_unlock(&erp_table->objagg_lock);\n\tif (IS_ERR(objagg_obj))\n\t\treturn ERR_CAST(objagg_obj);\n\treturn (struct mlxsw_sp_acl_erp_mask *) objagg_obj;\n}\n\nvoid mlxsw_sp_acl_erp_mask_put(struct mlxsw_sp_acl_atcam_region *aregion,\n\t\t\t       struct mlxsw_sp_acl_erp_mask *erp_mask)\n{\n\tstruct objagg_obj *objagg_obj = (struct objagg_obj *) erp_mask;\n\tstruct mlxsw_sp_acl_erp_table *erp_table = aregion->erp_table;\n\n\tmutex_lock(&erp_table->objagg_lock);\n\tobjagg_obj_put(erp_table->objagg, objagg_obj);\n\tmutex_unlock(&erp_table->objagg_lock);\n}\n\nint mlxsw_sp_acl_erp_bf_insert(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_acl_atcam_region *aregion,\n\t\t\t       struct mlxsw_sp_acl_erp_mask *erp_mask,\n\t\t\t       struct mlxsw_sp_acl_atcam_entry *aentry)\n{\n\tstruct objagg_obj *objagg_obj = (struct objagg_obj *) erp_mask;\n\tconst struct mlxsw_sp_acl_erp *erp = objagg_obj_root_priv(objagg_obj);\n\tunsigned int erp_bank;\n\n\tif (!mlxsw_sp_acl_erp_table_is_used(erp->erp_table))\n\t\treturn 0;\n\n\terp_bank = mlxsw_sp_acl_erp_bank_get(erp);\n\treturn mlxsw_sp_acl_bf_entry_add(mlxsw_sp,\n\t\t\t\t\terp->erp_table->erp_core->bf,\n\t\t\t\t\taregion, erp_bank, aentry);\n}\n\nvoid mlxsw_sp_acl_erp_bf_remove(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_acl_atcam_region *aregion,\n\t\t\t\tstruct mlxsw_sp_acl_erp_mask *erp_mask,\n\t\t\t\tstruct mlxsw_sp_acl_atcam_entry *aentry)\n{\n\tstruct objagg_obj *objagg_obj = (struct objagg_obj *) erp_mask;\n\tconst struct mlxsw_sp_acl_erp *erp = objagg_obj_root_priv(objagg_obj);\n\tunsigned int erp_bank;\n\n\tif (!mlxsw_sp_acl_erp_table_is_used(erp->erp_table))\n\t\treturn;\n\n\terp_bank = mlxsw_sp_acl_erp_bank_get(erp);\n\tmlxsw_sp_acl_bf_entry_del(mlxsw_sp,\n\t\t\t\t  erp->erp_table->erp_core->bf,\n\t\t\t\t  aregion, erp_bank, aentry);\n}\n\nbool\nmlxsw_sp_acl_erp_mask_is_ctcam(const struct mlxsw_sp_acl_erp_mask *erp_mask)\n{\n\tstruct objagg_obj *objagg_obj = (struct objagg_obj *) erp_mask;\n\tconst struct mlxsw_sp_acl_erp_key *key = objagg_obj_raw(objagg_obj);\n\n\treturn key->ctcam;\n}\n\nu8 mlxsw_sp_acl_erp_mask_erp_id(const struct mlxsw_sp_acl_erp_mask *erp_mask)\n{\n\tstruct objagg_obj *objagg_obj = (struct objagg_obj *) erp_mask;\n\tconst struct mlxsw_sp_acl_erp *erp = objagg_obj_root_priv(objagg_obj);\n\n\treturn erp->id;\n}\n\nstruct mlxsw_sp_acl_erp_delta {\n\tstruct mlxsw_sp_acl_erp_key key;\n\tu16 start;\n\tu8 mask;\n};\n\nu16 mlxsw_sp_acl_erp_delta_start(const struct mlxsw_sp_acl_erp_delta *delta)\n{\n\treturn delta->start;\n}\n\nu8 mlxsw_sp_acl_erp_delta_mask(const struct mlxsw_sp_acl_erp_delta *delta)\n{\n\treturn delta->mask;\n}\n\nu8 mlxsw_sp_acl_erp_delta_value(const struct mlxsw_sp_acl_erp_delta *delta,\n\t\t\t\tconst char *enc_key)\n{\n\tu16 start = delta->start;\n\tu8 mask = delta->mask;\n\tu16 tmp;\n\n\tif (!mask)\n\t\treturn 0;\n\n\ttmp = (unsigned char) enc_key[__MASK_IDX(start / 8)];\n\tif (start / 8 + 1 < __MASK_LEN)\n\t\ttmp |= (unsigned char) enc_key[__MASK_IDX(start / 8 + 1)] << 8;\n\ttmp >>= start % 8;\n\ttmp &= mask;\n\treturn tmp;\n}\n\nvoid mlxsw_sp_acl_erp_delta_clear(const struct mlxsw_sp_acl_erp_delta *delta,\n\t\t\t\t  const char *enc_key)\n{\n\tu16 start = delta->start;\n\tu8 mask = delta->mask;\n\tunsigned char *byte;\n\tu16 tmp;\n\n\ttmp = mask;\n\ttmp <<= start % 8;\n\ttmp = ~tmp;\n\n\tbyte = (unsigned char *) &enc_key[__MASK_IDX(start / 8)];\n\t*byte &= tmp & 0xff;\n\tif (start / 8 + 1 < __MASK_LEN) {\n\t\tbyte = (unsigned char *) &enc_key[__MASK_IDX(start / 8 + 1)];\n\t\t*byte &= (tmp >> 8) & 0xff;\n\t}\n}\n\nstatic const struct mlxsw_sp_acl_erp_delta\nmlxsw_sp_acl_erp_delta_default = {};\n\nconst struct mlxsw_sp_acl_erp_delta *\nmlxsw_sp_acl_erp_delta(const struct mlxsw_sp_acl_erp_mask *erp_mask)\n{\n\tstruct objagg_obj *objagg_obj = (struct objagg_obj *) erp_mask;\n\tconst struct mlxsw_sp_acl_erp_delta *delta;\n\n\tdelta = objagg_obj_delta_priv(objagg_obj);\n\tif (!delta)\n\t\tdelta = &mlxsw_sp_acl_erp_delta_default;\n\treturn delta;\n}\n\nstatic int\nmlxsw_sp_acl_erp_delta_fill(const struct mlxsw_sp_acl_erp_key *parent_key,\n\t\t\t    const struct mlxsw_sp_acl_erp_key *key,\n\t\t\t    u16 *delta_start, u8 *delta_mask)\n{\n\tint offset = 0;\n\tint si = -1;\n\tu16 pmask;\n\tu16 mask;\n\tint i;\n\n\t \n\tfor (i = 0; i < __MASK_LEN; i++) {\n\t\tif (parent_key->mask[__MASK_IDX(i)] == key->mask[__MASK_IDX(i)])\n\t\t\tcontinue;\n\t\tif (si == -1)\n\t\t\tsi = i;\n\t\telse if (si != i - 1)\n\t\t\treturn -EINVAL;\n\t}\n\tif (si == -1) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\tpmask = (unsigned char) parent_key->mask[__MASK_IDX(si)];\n\tmask = (unsigned char) key->mask[__MASK_IDX(si)];\n\tif (si + 1 < __MASK_LEN) {\n\t\tpmask |= (unsigned char) parent_key->mask[__MASK_IDX(si + 1)] << 8;\n\t\tmask |= (unsigned char) key->mask[__MASK_IDX(si + 1)] << 8;\n\t}\n\n\tif ((pmask ^ mask) & pmask)\n\t\treturn -EINVAL;\n\tmask &= ~pmask;\n\twhile (!(mask & (1 << offset)))\n\t\toffset++;\n\twhile (!(mask & 1))\n\t\tmask >>= 1;\n\tif (mask & 0xff00)\n\t\treturn -EINVAL;\n\n\t*delta_start = si * 8 + offset;\n\t*delta_mask = mask;\n\n\treturn 0;\n}\n\nstatic bool mlxsw_sp_acl_erp_delta_check(void *priv, const void *parent_obj,\n\t\t\t\t\t const void *obj)\n{\n\tconst struct mlxsw_sp_acl_erp_key *parent_key = parent_obj;\n\tconst struct mlxsw_sp_acl_erp_key *key = obj;\n\tu16 delta_start;\n\tu8 delta_mask;\n\tint err;\n\n\terr = mlxsw_sp_acl_erp_delta_fill(parent_key, key,\n\t\t\t\t\t  &delta_start, &delta_mask);\n\treturn err ? false : true;\n}\n\nstatic int mlxsw_sp_acl_erp_hints_obj_cmp(const void *obj1, const void *obj2)\n{\n\tconst struct mlxsw_sp_acl_erp_key *key1 = obj1;\n\tconst struct mlxsw_sp_acl_erp_key *key2 = obj2;\n\n\t \n\treturn memcmp(key1->mask, key2->mask, sizeof(key1->mask));\n}\n\nstatic void *mlxsw_sp_acl_erp_delta_create(void *priv, void *parent_obj,\n\t\t\t\t\t   void *obj)\n{\n\tstruct mlxsw_sp_acl_erp_key *parent_key = parent_obj;\n\tstruct mlxsw_sp_acl_atcam_region *aregion = priv;\n\tstruct mlxsw_sp_acl_erp_table *erp_table = aregion->erp_table;\n\tstruct mlxsw_sp_acl_erp_key *key = obj;\n\tstruct mlxsw_sp_acl_erp_delta *delta;\n\tu16 delta_start;\n\tu8 delta_mask;\n\tint err;\n\n\tif (parent_key->ctcam || key->ctcam)\n\t\treturn ERR_PTR(-EINVAL);\n\terr = mlxsw_sp_acl_erp_delta_fill(parent_key, key,\n\t\t\t\t\t  &delta_start, &delta_mask);\n\tif (err)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdelta = kzalloc(sizeof(*delta), GFP_KERNEL);\n\tif (!delta)\n\t\treturn ERR_PTR(-ENOMEM);\n\tdelta->start = delta_start;\n\tdelta->mask = delta_mask;\n\n\terr = mlxsw_sp_acl_erp_delta_inc(erp_table);\n\tif (err)\n\t\tgoto err_erp_delta_inc;\n\n\tmemcpy(&delta->key, key, sizeof(*key));\n\terr = mlxsw_sp_acl_erp_master_mask_set(erp_table, &delta->key);\n\tif (err)\n\t\tgoto err_master_mask_set;\n\n\treturn delta;\n\nerr_master_mask_set:\n\tmlxsw_sp_acl_erp_delta_dec(erp_table);\nerr_erp_delta_inc:\n\tkfree(delta);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_acl_erp_delta_destroy(void *priv, void *delta_priv)\n{\n\tstruct mlxsw_sp_acl_erp_delta *delta = delta_priv;\n\tstruct mlxsw_sp_acl_atcam_region *aregion = priv;\n\tstruct mlxsw_sp_acl_erp_table *erp_table = aregion->erp_table;\n\n\tmlxsw_sp_acl_erp_master_mask_clear(erp_table, &delta->key);\n\tmlxsw_sp_acl_erp_delta_dec(erp_table);\n\tkfree(delta);\n}\n\nstatic void *mlxsw_sp_acl_erp_root_create(void *priv, void *obj,\n\t\t\t\t\t  unsigned int root_id)\n{\n\tstruct mlxsw_sp_acl_atcam_region *aregion = priv;\n\tstruct mlxsw_sp_acl_erp_table *erp_table = aregion->erp_table;\n\tstruct mlxsw_sp_acl_erp_key *key = obj;\n\n\tif (!key->ctcam &&\n\t    root_id != OBJAGG_OBJ_ROOT_ID_INVALID &&\n\t    root_id >= MLXSW_SP_ACL_ERP_MAX_PER_REGION)\n\t\treturn ERR_PTR(-ENOBUFS);\n\treturn erp_table->ops->erp_create(erp_table, key);\n}\n\nstatic void mlxsw_sp_acl_erp_root_destroy(void *priv, void *root_priv)\n{\n\tstruct mlxsw_sp_acl_atcam_region *aregion = priv;\n\tstruct mlxsw_sp_acl_erp_table *erp_table = aregion->erp_table;\n\n\terp_table->ops->erp_destroy(erp_table, root_priv);\n}\n\nstatic const struct objagg_ops mlxsw_sp_acl_erp_objagg_ops = {\n\t.obj_size = sizeof(struct mlxsw_sp_acl_erp_key),\n\t.delta_check = mlxsw_sp_acl_erp_delta_check,\n\t.hints_obj_cmp = mlxsw_sp_acl_erp_hints_obj_cmp,\n\t.delta_create = mlxsw_sp_acl_erp_delta_create,\n\t.delta_destroy = mlxsw_sp_acl_erp_delta_destroy,\n\t.root_create = mlxsw_sp_acl_erp_root_create,\n\t.root_destroy = mlxsw_sp_acl_erp_root_destroy,\n};\n\nstatic struct mlxsw_sp_acl_erp_table *\nmlxsw_sp_acl_erp_table_create(struct mlxsw_sp_acl_atcam_region *aregion,\n\t\t\t      struct objagg_hints *hints)\n{\n\tstruct mlxsw_sp_acl_erp_table *erp_table;\n\tint err;\n\n\terp_table = kzalloc(sizeof(*erp_table), GFP_KERNEL);\n\tif (!erp_table)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terp_table->objagg = objagg_create(&mlxsw_sp_acl_erp_objagg_ops,\n\t\t\t\t\t  hints, aregion);\n\tif (IS_ERR(erp_table->objagg)) {\n\t\terr = PTR_ERR(erp_table->objagg);\n\t\tgoto err_objagg_create;\n\t}\n\n\terp_table->erp_core = aregion->atcam->erp_core;\n\terp_table->ops = &erp_no_mask_ops;\n\tINIT_LIST_HEAD(&erp_table->atcam_erps_list);\n\terp_table->aregion = aregion;\n\tmutex_init(&erp_table->objagg_lock);\n\n\treturn erp_table;\n\nerr_objagg_create:\n\tkfree(erp_table);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_acl_erp_table_destroy(struct mlxsw_sp_acl_erp_table *erp_table)\n{\n\tWARN_ON(!list_empty(&erp_table->atcam_erps_list));\n\tmutex_destroy(&erp_table->objagg_lock);\n\tobjagg_destroy(erp_table->objagg);\n\tkfree(erp_table);\n}\n\nstatic int\nmlxsw_sp_acl_erp_master_mask_init(struct mlxsw_sp_acl_atcam_region *aregion)\n{\n\tstruct mlxsw_sp *mlxsw_sp = aregion->region->mlxsw_sp;\n\tchar percr_pl[MLXSW_REG_PERCR_LEN];\n\n\tmlxsw_reg_percr_pack(percr_pl, aregion->region->id);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(percr), percr_pl);\n}\n\nstatic int\nmlxsw_sp_acl_erp_region_param_init(struct mlxsw_sp_acl_atcam_region *aregion)\n{\n\tstruct mlxsw_sp *mlxsw_sp = aregion->region->mlxsw_sp;\n\tchar pererp_pl[MLXSW_REG_PERERP_LEN];\n\n\tmlxsw_reg_pererp_pack(pererp_pl, aregion->region->id, false, false, 0,\n\t\t\t      0, 0);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pererp), pererp_pl);\n}\n\nstatic int\nmlxsw_sp_acl_erp_hints_check(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     struct mlxsw_sp_acl_atcam_region *aregion,\n\t\t\t     struct objagg_hints *hints, bool *p_rehash_needed)\n{\n\tstruct mlxsw_sp_acl_erp_table *erp_table = aregion->erp_table;\n\tconst struct objagg_stats *ostats;\n\tconst struct objagg_stats *hstats;\n\tint err;\n\n\t*p_rehash_needed = false;\n\n\tmutex_lock(&erp_table->objagg_lock);\n\tostats = objagg_stats_get(erp_table->objagg);\n\tmutex_unlock(&erp_table->objagg_lock);\n\tif (IS_ERR(ostats)) {\n\t\tdev_err_ratelimited(mlxsw_sp->bus_info->dev, \"Failed to get ERP stats\\n\");\n\t\treturn PTR_ERR(ostats);\n\t}\n\n\thstats = objagg_hints_stats_get(hints);\n\tif (IS_ERR(hstats)) {\n\t\tdev_err_ratelimited(mlxsw_sp->bus_info->dev, \"Failed to get ERP hints stats\\n\");\n\t\terr = PTR_ERR(hstats);\n\t\tgoto err_hints_stats_get;\n\t}\n\n\t \n\tif (hstats->root_count < ostats->root_count)\n\t\t*p_rehash_needed = true;\n\n\terr = 0;\n\n\tobjagg_stats_put(hstats);\nerr_hints_stats_get:\n\tobjagg_stats_put(ostats);\n\treturn err;\n}\n\nvoid *\nmlxsw_sp_acl_erp_rehash_hints_get(struct mlxsw_sp_acl_atcam_region *aregion)\n{\n\tstruct mlxsw_sp_acl_erp_table *erp_table = aregion->erp_table;\n\tstruct mlxsw_sp *mlxsw_sp = aregion->region->mlxsw_sp;\n\tstruct objagg_hints *hints;\n\tbool rehash_needed;\n\tint err;\n\n\tmutex_lock(&erp_table->objagg_lock);\n\thints = objagg_hints_get(erp_table->objagg,\n\t\t\t\t OBJAGG_OPT_ALGO_SIMPLE_GREEDY);\n\tmutex_unlock(&erp_table->objagg_lock);\n\tif (IS_ERR(hints)) {\n\t\tdev_err_ratelimited(mlxsw_sp->bus_info->dev, \"Failed to create ERP hints\\n\");\n\t\treturn ERR_CAST(hints);\n\t}\n\terr = mlxsw_sp_acl_erp_hints_check(mlxsw_sp, aregion, hints,\n\t\t\t\t\t   &rehash_needed);\n\tif (err)\n\t\tgoto errout;\n\n\tif (!rehash_needed) {\n\t\terr = -EAGAIN;\n\t\tgoto errout;\n\t}\n\treturn hints;\n\nerrout:\n\tobjagg_hints_put(hints);\n\treturn ERR_PTR(err);\n}\n\nvoid mlxsw_sp_acl_erp_rehash_hints_put(void *hints_priv)\n{\n\tstruct objagg_hints *hints = hints_priv;\n\n\tobjagg_hints_put(hints);\n}\n\nint mlxsw_sp_acl_erp_region_init(struct mlxsw_sp_acl_atcam_region *aregion,\n\t\t\t\t void *hints_priv)\n{\n\tstruct mlxsw_sp_acl_erp_table *erp_table;\n\tstruct objagg_hints *hints = hints_priv;\n\tint err;\n\n\terp_table = mlxsw_sp_acl_erp_table_create(aregion, hints);\n\tif (IS_ERR(erp_table))\n\t\treturn PTR_ERR(erp_table);\n\taregion->erp_table = erp_table;\n\n\t \n\terr = mlxsw_sp_acl_erp_master_mask_init(aregion);\n\tif (err)\n\t\tgoto err_erp_master_mask_init;\n\n\t \n\terr = mlxsw_sp_acl_erp_region_param_init(aregion);\n\tif (err)\n\t\tgoto err_erp_region_param_init;\n\n\treturn 0;\n\nerr_erp_region_param_init:\nerr_erp_master_mask_init:\n\tmlxsw_sp_acl_erp_table_destroy(erp_table);\n\treturn err;\n}\n\nvoid mlxsw_sp_acl_erp_region_fini(struct mlxsw_sp_acl_atcam_region *aregion)\n{\n\tmlxsw_sp_acl_erp_table_destroy(aregion->erp_table);\n}\n\nstatic int\nmlxsw_sp_acl_erp_tables_sizes_query(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_acl_erp_core *erp_core)\n{\n\tunsigned int size;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, ACL_ERPT_ENTRIES_2KB) ||\n\t    !MLXSW_CORE_RES_VALID(mlxsw_sp->core, ACL_ERPT_ENTRIES_4KB) ||\n\t    !MLXSW_CORE_RES_VALID(mlxsw_sp->core, ACL_ERPT_ENTRIES_8KB) ||\n\t    !MLXSW_CORE_RES_VALID(mlxsw_sp->core, ACL_ERPT_ENTRIES_12KB))\n\t\treturn -EIO;\n\n\tsize = MLXSW_CORE_RES_GET(mlxsw_sp->core, ACL_ERPT_ENTRIES_2KB);\n\terp_core->erpt_entries_size[MLXSW_SP_ACL_ATCAM_REGION_TYPE_2KB] = size;\n\n\tsize = MLXSW_CORE_RES_GET(mlxsw_sp->core, ACL_ERPT_ENTRIES_4KB);\n\terp_core->erpt_entries_size[MLXSW_SP_ACL_ATCAM_REGION_TYPE_4KB] = size;\n\n\tsize = MLXSW_CORE_RES_GET(mlxsw_sp->core, ACL_ERPT_ENTRIES_8KB);\n\terp_core->erpt_entries_size[MLXSW_SP_ACL_ATCAM_REGION_TYPE_8KB] = size;\n\n\tsize = MLXSW_CORE_RES_GET(mlxsw_sp->core, ACL_ERPT_ENTRIES_12KB);\n\terp_core->erpt_entries_size[MLXSW_SP_ACL_ATCAM_REGION_TYPE_12KB] = size;\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_acl_erp_tables_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_acl_erp_core *erp_core)\n{\n\tunsigned int erpt_bank_size;\n\tint err;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, ACL_MAX_ERPT_BANK_SIZE) ||\n\t    !MLXSW_CORE_RES_VALID(mlxsw_sp->core, ACL_MAX_ERPT_BANKS))\n\t\treturn -EIO;\n\terpt_bank_size = MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t\t    ACL_MAX_ERPT_BANK_SIZE);\n\terp_core->num_erp_banks = MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t\t\t     ACL_MAX_ERPT_BANKS);\n\n\terp_core->erp_tables = gen_pool_create(0, -1);\n\tif (!erp_core->erp_tables)\n\t\treturn -ENOMEM;\n\tgen_pool_set_algo(erp_core->erp_tables, gen_pool_best_fit, NULL);\n\n\terr = gen_pool_add(erp_core->erp_tables,\n\t\t\t   MLXSW_SP_ACL_ERP_GENALLOC_OFFSET, erpt_bank_size,\n\t\t\t   -1);\n\tif (err)\n\t\tgoto err_gen_pool_add;\n\n\terp_core->bf = mlxsw_sp_acl_bf_init(mlxsw_sp, erp_core->num_erp_banks);\n\tif (IS_ERR(erp_core->bf)) {\n\t\terr = PTR_ERR(erp_core->bf);\n\t\tgoto err_bf_init;\n\t}\n\n\t \n\terr = mlxsw_sp_acl_erp_tables_sizes_query(mlxsw_sp, erp_core);\n\tif (err)\n\t\tgoto err_erp_tables_sizes_query;\n\n\treturn 0;\n\nerr_erp_tables_sizes_query:\n\tmlxsw_sp_acl_bf_fini(erp_core->bf);\nerr_bf_init:\nerr_gen_pool_add:\n\tgen_pool_destroy(erp_core->erp_tables);\n\treturn err;\n}\n\nstatic void mlxsw_sp_acl_erp_tables_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t struct mlxsw_sp_acl_erp_core *erp_core)\n{\n\tmlxsw_sp_acl_bf_fini(erp_core->bf);\n\tgen_pool_destroy(erp_core->erp_tables);\n}\n\nint mlxsw_sp_acl_erps_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   struct mlxsw_sp_acl_atcam *atcam)\n{\n\tstruct mlxsw_sp_acl_erp_core *erp_core;\n\tint err;\n\n\terp_core = kzalloc(sizeof(*erp_core), GFP_KERNEL);\n\tif (!erp_core)\n\t\treturn -ENOMEM;\n\terp_core->mlxsw_sp = mlxsw_sp;\n\tatcam->erp_core = erp_core;\n\n\terr = mlxsw_sp_acl_erp_tables_init(mlxsw_sp, erp_core);\n\tif (err)\n\t\tgoto err_erp_tables_init;\n\n\treturn 0;\n\nerr_erp_tables_init:\n\tkfree(erp_core);\n\treturn err;\n}\n\nvoid mlxsw_sp_acl_erps_fini(struct mlxsw_sp *mlxsw_sp,\n\t\t\t    struct mlxsw_sp_acl_atcam *atcam)\n{\n\tmlxsw_sp_acl_erp_tables_fini(mlxsw_sp, atcam->erp_core);\n\tkfree(atcam->erp_core);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}