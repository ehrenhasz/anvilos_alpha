{
  "module_name": "core_acl_flex_keys.h",
  "hash_id": "589c27c7c4091265e169fc52cf03f2127fd21592c245e6a0b2818390071b3988",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/core_acl_flex_keys.h",
  "human_readable_source": " \n \n\n#ifndef _MLXSW_CORE_ACL_FLEX_KEYS_H\n#define _MLXSW_CORE_ACL_FLEX_KEYS_H\n\n#include <linux/types.h>\n#include <linux/bitmap.h>\n\n#include \"item.h\"\n\nenum mlxsw_afk_element {\n\tMLXSW_AFK_ELEMENT_SRC_SYS_PORT,\n\tMLXSW_AFK_ELEMENT_DMAC_32_47,\n\tMLXSW_AFK_ELEMENT_DMAC_0_31,\n\tMLXSW_AFK_ELEMENT_SMAC_32_47,\n\tMLXSW_AFK_ELEMENT_SMAC_0_31,\n\tMLXSW_AFK_ELEMENT_ETHERTYPE,\n\tMLXSW_AFK_ELEMENT_IP_PROTO,\n\tMLXSW_AFK_ELEMENT_SRC_IP_96_127,\n\tMLXSW_AFK_ELEMENT_SRC_IP_64_95,\n\tMLXSW_AFK_ELEMENT_SRC_IP_32_63,\n\tMLXSW_AFK_ELEMENT_SRC_IP_0_31,\n\tMLXSW_AFK_ELEMENT_DST_IP_96_127,\n\tMLXSW_AFK_ELEMENT_DST_IP_64_95,\n\tMLXSW_AFK_ELEMENT_DST_IP_32_63,\n\tMLXSW_AFK_ELEMENT_DST_IP_0_31,\n\tMLXSW_AFK_ELEMENT_DST_L4_PORT,\n\tMLXSW_AFK_ELEMENT_SRC_L4_PORT,\n\tMLXSW_AFK_ELEMENT_VID,\n\tMLXSW_AFK_ELEMENT_PCP,\n\tMLXSW_AFK_ELEMENT_TCP_FLAGS,\n\tMLXSW_AFK_ELEMENT_IP_TTL_,\n\tMLXSW_AFK_ELEMENT_IP_ECN,\n\tMLXSW_AFK_ELEMENT_IP_DSCP,\n\tMLXSW_AFK_ELEMENT_VIRT_ROUTER_MSB,\n\tMLXSW_AFK_ELEMENT_VIRT_ROUTER_LSB,\n\tMLXSW_AFK_ELEMENT_FDB_MISS,\n\tMLXSW_AFK_ELEMENT_L4_PORT_RANGE,\n\tMLXSW_AFK_ELEMENT_MAX,\n};\n\nenum mlxsw_afk_element_type {\n\tMLXSW_AFK_ELEMENT_TYPE_U32,\n\tMLXSW_AFK_ELEMENT_TYPE_BUF,\n};\n\nstruct mlxsw_afk_element_info {\n\tenum mlxsw_afk_element element;  \n\tenum mlxsw_afk_element_type type;\n\tstruct mlxsw_item item;  \n};\n\n#define MLXSW_AFK_ELEMENT_INFO(_type, _element, _offset, _shift, _size)\t\t\\\n\t[MLXSW_AFK_ELEMENT_##_element] = {\t\t\t\t\t\\\n\t\t.element = MLXSW_AFK_ELEMENT_##_element,\t\t\t\\\n\t\t.type = _type,\t\t\t\t\t\t\t\\\n\t\t.item = {\t\t\t\t\t\t\t\\\n\t\t\t.offset = _offset,\t\t\t\t\t\\\n\t\t\t.shift = _shift,\t\t\t\t\t\\\n\t\t\t.size = {.bits = _size},\t\t\t\t\\\n\t\t\t.name = #_element,\t\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\t\\\n\t}\n\n#define MLXSW_AFK_ELEMENT_INFO_U32(_element, _offset, _shift, _size)\t\t\\\n\tMLXSW_AFK_ELEMENT_INFO(MLXSW_AFK_ELEMENT_TYPE_U32,\t\t\t\\\n\t\t\t       _element, _offset, _shift, _size)\n\n#define MLXSW_AFK_ELEMENT_INFO_BUF(_element, _offset, _size)\t\t\t\\\n\tMLXSW_AFK_ELEMENT_INFO(MLXSW_AFK_ELEMENT_TYPE_BUF,\t\t\t\\\n\t\t\t       _element, _offset, 0, _size)\n\n#define MLXSW_AFK_ELEMENT_STORAGE_SIZE 0x44\n\nstruct mlxsw_afk_element_inst {  \n\tenum mlxsw_afk_element element;\n\tenum mlxsw_afk_element_type type;\n\tstruct mlxsw_item item;  \n\tint u32_key_diff;  \n\tbool avoid_size_check;\n};\n\n#define MLXSW_AFK_ELEMENT_INST(_type, _element, _offset,\t\t\t\\\n\t\t\t       _shift, _size, _u32_key_diff, _avoid_size_check)\t\\\n\t{\t\t\t\t\t\t\t\t\t\\\n\t\t.element = MLXSW_AFK_ELEMENT_##_element,\t\t\t\\\n\t\t.type = _type,\t\t\t\t\t\t\t\\\n\t\t.item = {\t\t\t\t\t\t\t\\\n\t\t\t.offset = _offset,\t\t\t\t\t\\\n\t\t\t.shift = _shift,\t\t\t\t\t\\\n\t\t\t.size = {.bits = _size},\t\t\t\t\\\n\t\t\t.name = #_element,\t\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\t\\\n\t\t.u32_key_diff = _u32_key_diff,\t\t\t\t\t\\\n\t\t.avoid_size_check = _avoid_size_check,\t\t\t\t\\\n\t}\n\n#define MLXSW_AFK_ELEMENT_INST_U32(_element, _offset, _shift, _size)\t\t\\\n\tMLXSW_AFK_ELEMENT_INST(MLXSW_AFK_ELEMENT_TYPE_U32,\t\t\t\\\n\t\t\t       _element, _offset, _shift, _size, 0, false)\n\n#define MLXSW_AFK_ELEMENT_INST_EXT_U32(_element, _offset,\t\t\t\\\n\t\t\t\t       _shift, _size, _key_diff,\t\t\\\n\t\t\t\t       _avoid_size_check)\t\t\t\\\n\tMLXSW_AFK_ELEMENT_INST(MLXSW_AFK_ELEMENT_TYPE_U32,\t\t\t\\\n\t\t\t       _element, _offset, _shift, _size,\t\t\\\n\t\t\t       _key_diff, _avoid_size_check)\n\n#define MLXSW_AFK_ELEMENT_INST_BUF(_element, _offset, _size)\t\t\t\\\n\tMLXSW_AFK_ELEMENT_INST(MLXSW_AFK_ELEMENT_TYPE_BUF,\t\t\t\\\n\t\t\t       _element, _offset, 0, _size, 0, false)\n\nstruct mlxsw_afk_block {\n\tu16 encoding;  \n\tstruct mlxsw_afk_element_inst *instances;\n\tunsigned int instances_count;\n};\n\n#define MLXSW_AFK_BLOCK(_encoding, _instances)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\\\n\t\t.encoding = _encoding,\t\t\t\t\t\t\\\n\t\t.instances = _instances,\t\t\t\t\t\\\n\t\t.instances_count = ARRAY_SIZE(_instances),\t\t\t\\\n\t}\n\nstruct mlxsw_afk_element_usage {\n\tDECLARE_BITMAP(usage, MLXSW_AFK_ELEMENT_MAX);\n};\n\n#define mlxsw_afk_element_usage_for_each(element, elusage)\t\t\t\\\n\tfor_each_set_bit(element, (elusage)->usage, MLXSW_AFK_ELEMENT_MAX)\n\nstatic inline void\nmlxsw_afk_element_usage_add(struct mlxsw_afk_element_usage *elusage,\n\t\t\t    enum mlxsw_afk_element element)\n{\n\t__set_bit(element, elusage->usage);\n}\n\nstatic inline void\nmlxsw_afk_element_usage_zero(struct mlxsw_afk_element_usage *elusage)\n{\n\tbitmap_zero(elusage->usage, MLXSW_AFK_ELEMENT_MAX);\n}\n\nstatic inline void\nmlxsw_afk_element_usage_fill(struct mlxsw_afk_element_usage *elusage,\n\t\t\t     const enum mlxsw_afk_element *elements,\n\t\t\t     unsigned int elements_count)\n{\n\tint i;\n\n\tmlxsw_afk_element_usage_zero(elusage);\n\tfor (i = 0; i < elements_count; i++)\n\t\tmlxsw_afk_element_usage_add(elusage, elements[i]);\n}\n\nstatic inline bool\nmlxsw_afk_element_usage_subset(struct mlxsw_afk_element_usage *elusage_small,\n\t\t\t       struct mlxsw_afk_element_usage *elusage_big)\n{\n\tint i;\n\n\tfor (i = 0; i < MLXSW_AFK_ELEMENT_MAX; i++)\n\t\tif (test_bit(i, elusage_small->usage) &&\n\t\t    !test_bit(i, elusage_big->usage))\n\t\t\treturn false;\n\treturn true;\n}\n\nstruct mlxsw_afk;\n\nstruct mlxsw_afk_ops {\n\tconst struct mlxsw_afk_block *blocks;\n\tunsigned int blocks_count;\n\tvoid (*encode_block)(char *output, int block_index, char *block);\n\tvoid (*clear_block)(char *output, int block_index);\n};\n\nstruct mlxsw_afk *mlxsw_afk_create(unsigned int max_blocks,\n\t\t\t\t   const struct mlxsw_afk_ops *ops);\nvoid mlxsw_afk_destroy(struct mlxsw_afk *mlxsw_afk);\n\nstruct mlxsw_afk_key_info;\n\nstruct mlxsw_afk_key_info *\nmlxsw_afk_key_info_get(struct mlxsw_afk *mlxsw_afk,\n\t\t       struct mlxsw_afk_element_usage *elusage);\nvoid mlxsw_afk_key_info_put(struct mlxsw_afk_key_info *key_info);\nbool mlxsw_afk_key_info_subset(struct mlxsw_afk_key_info *key_info,\n\t\t\t       struct mlxsw_afk_element_usage *elusage);\n\nu16\nmlxsw_afk_key_info_block_encoding_get(const struct mlxsw_afk_key_info *key_info,\n\t\t\t\t      int block_index);\nunsigned int\nmlxsw_afk_key_info_blocks_count_get(const struct mlxsw_afk_key_info *key_info);\n\nstruct mlxsw_afk_element_values {\n\tstruct mlxsw_afk_element_usage elusage;\n\tstruct {\n\t\tchar key[MLXSW_AFK_ELEMENT_STORAGE_SIZE];\n\t\tchar mask[MLXSW_AFK_ELEMENT_STORAGE_SIZE];\n\t} storage;\n};\n\nvoid mlxsw_afk_values_add_u32(struct mlxsw_afk_element_values *values,\n\t\t\t      enum mlxsw_afk_element element,\n\t\t\t      u32 key_value, u32 mask_value);\nvoid mlxsw_afk_values_add_buf(struct mlxsw_afk_element_values *values,\n\t\t\t      enum mlxsw_afk_element element,\n\t\t\t      const char *key_value, const char *mask_value,\n\t\t\t      unsigned int len);\nvoid mlxsw_afk_encode(struct mlxsw_afk *mlxsw_afk,\n\t\t      struct mlxsw_afk_key_info *key_info,\n\t\t      struct mlxsw_afk_element_values *values,\n\t\t      char *key, char *mask);\nvoid mlxsw_afk_clear(struct mlxsw_afk *mlxsw_afk, char *key,\n\t\t     int block_start, int block_end);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}