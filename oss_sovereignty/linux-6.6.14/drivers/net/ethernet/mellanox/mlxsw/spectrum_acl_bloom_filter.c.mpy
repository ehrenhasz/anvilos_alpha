{
  "module_name": "spectrum_acl_bloom_filter.c",
  "hash_id": "42b5a267b6a4a29cfedb5a77c0b2e6aa1b73192b0eb1cfc869ecd8dc26d6b316",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_bloom_filter.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/refcount.h>\n#include <linux/mutex.h>\n\n#include \"spectrum.h\"\n#include \"spectrum_acl_tcam.h\"\n\nstruct mlxsw_sp_acl_bf {\n\tstruct mutex lock;  \n\tunsigned int bank_size;\n\trefcount_t refcnt[];\n};\n\n \n#define MLXSW_BLOOM_KEY_CHUNKS 3\n\n \n#define MLXSW_SP2_BLOOM_KEY_LEN 69\n\n \n#define MLXSW_SP2_BLOOM_CHUNK_PAD_BYTES 3\n#define MLXSW_SP2_BLOOM_CHUNK_KEY_BYTES 18\n#define MLXSW_SP2_BLOOM_KEY_CHUNK_BYTES 23\n\n \n#define MLXSW_SP2_BLOOM_CHUNK_KEY_OFFSET 5\n\n \nstatic const u16 mlxsw_sp2_acl_bf_crc16_tab[256] = {\n0x0000, 0x8529, 0x8f7b, 0x0a52, 0x9bdf, 0x1ef6, 0x14a4, 0x918d,\n0xb297, 0x37be, 0x3dec, 0xb8c5, 0x2948, 0xac61, 0xa633, 0x231a,\n0xe007, 0x652e, 0x6f7c, 0xea55, 0x7bd8, 0xfef1, 0xf4a3, 0x718a,\n0x5290, 0xd7b9, 0xddeb, 0x58c2, 0xc94f, 0x4c66, 0x4634, 0xc31d,\n0x4527, 0xc00e, 0xca5c, 0x4f75, 0xdef8, 0x5bd1, 0x5183, 0xd4aa,\n0xf7b0, 0x7299, 0x78cb, 0xfde2, 0x6c6f, 0xe946, 0xe314, 0x663d,\n0xa520, 0x2009, 0x2a5b, 0xaf72, 0x3eff, 0xbbd6, 0xb184, 0x34ad,\n0x17b7, 0x929e, 0x98cc, 0x1de5, 0x8c68, 0x0941, 0x0313, 0x863a,\n0x8a4e, 0x0f67, 0x0535, 0x801c, 0x1191, 0x94b8, 0x9eea, 0x1bc3,\n0x38d9, 0xbdf0, 0xb7a2, 0x328b, 0xa306, 0x262f, 0x2c7d, 0xa954,\n0x6a49, 0xef60, 0xe532, 0x601b, 0xf196, 0x74bf, 0x7eed, 0xfbc4,\n0xd8de, 0x5df7, 0x57a5, 0xd28c, 0x4301, 0xc628, 0xcc7a, 0x4953,\n0xcf69, 0x4a40, 0x4012, 0xc53b, 0x54b6, 0xd19f, 0xdbcd, 0x5ee4,\n0x7dfe, 0xf8d7, 0xf285, 0x77ac, 0xe621, 0x6308, 0x695a, 0xec73,\n0x2f6e, 0xaa47, 0xa015, 0x253c, 0xb4b1, 0x3198, 0x3bca, 0xbee3,\n0x9df9, 0x18d0, 0x1282, 0x97ab, 0x0626, 0x830f, 0x895d, 0x0c74,\n0x91b5, 0x149c, 0x1ece, 0x9be7, 0x0a6a, 0x8f43, 0x8511, 0x0038,\n0x2322, 0xa60b, 0xac59, 0x2970, 0xb8fd, 0x3dd4, 0x3786, 0xb2af,\n0x71b2, 0xf49b, 0xfec9, 0x7be0, 0xea6d, 0x6f44, 0x6516, 0xe03f,\n0xc325, 0x460c, 0x4c5e, 0xc977, 0x58fa, 0xddd3, 0xd781, 0x52a8,\n0xd492, 0x51bb, 0x5be9, 0xdec0, 0x4f4d, 0xca64, 0xc036, 0x451f,\n0x6605, 0xe32c, 0xe97e, 0x6c57, 0xfdda, 0x78f3, 0x72a1, 0xf788,\n0x3495, 0xb1bc, 0xbbee, 0x3ec7, 0xaf4a, 0x2a63, 0x2031, 0xa518,\n0x8602, 0x032b, 0x0979, 0x8c50, 0x1ddd, 0x98f4, 0x92a6, 0x178f,\n0x1bfb, 0x9ed2, 0x9480, 0x11a9, 0x8024, 0x050d, 0x0f5f, 0x8a76,\n0xa96c, 0x2c45, 0x2617, 0xa33e, 0x32b3, 0xb79a, 0xbdc8, 0x38e1,\n0xfbfc, 0x7ed5, 0x7487, 0xf1ae, 0x6023, 0xe50a, 0xef58, 0x6a71,\n0x496b, 0xcc42, 0xc610, 0x4339, 0xd2b4, 0x579d, 0x5dcf, 0xd8e6,\n0x5edc, 0xdbf5, 0xd1a7, 0x548e, 0xc503, 0x402a, 0x4a78, 0xcf51,\n0xec4b, 0x6962, 0x6330, 0xe619, 0x7794, 0xf2bd, 0xf8ef, 0x7dc6,\n0xbedb, 0x3bf2, 0x31a0, 0xb489, 0x2504, 0xa02d, 0xaa7f, 0x2f56,\n0x0c4c, 0x8965, 0x8337, 0x061e, 0x9793, 0x12ba, 0x18e8, 0x9dc1,\n};\n\n \n#define MLXSW_SP4_BLOOM_KEY_LEN 60\n\n \n\n#define MLXSW_SP4_BLOOM_CHUNK_PAD_BYTES 0\n#define MLXSW_SP4_BLOOM_CHUNK_KEY_BYTES 18\n#define MLXSW_SP4_BLOOM_KEY_CHUNK_BYTES 20\n\n \n#define MLXSW_SP4_BLOOM_CHUNK_KEY_OFFSET 2\n\n \n\n \nstatic const u16 mlxsw_sp4_acl_bf_crc10_tab[256] = {\n0x0000, 0x001b, 0x0036, 0x002d, 0x006c, 0x0077, 0x005a, 0x0041,\n0x00d8, 0x00c3, 0x00ee, 0x00f5, 0x00b4, 0x00af, 0x0082, 0x0099,\n0x01b0, 0x01ab, 0x0186, 0x019d, 0x01dc, 0x01c7, 0x01ea, 0x01f1,\n0x0168, 0x0173, 0x015e, 0x0145, 0x0104, 0x011f, 0x0132, 0x0129,\n0x0360, 0x037b, 0x0356, 0x034d, 0x030c, 0x0317, 0x033a, 0x0321,\n0x03b8, 0x03a3, 0x038e, 0x0395, 0x03d4, 0x03cf, 0x03e2, 0x03f9,\n0x02d0, 0x02cb, 0x02e6, 0x02fd, 0x02bc, 0x02a7, 0x028a, 0x0291,\n0x0208, 0x0213, 0x023e, 0x0225, 0x0264, 0x027f, 0x0252, 0x0249,\n0x02db, 0x02c0, 0x02ed, 0x02f6, 0x02b7, 0x02ac, 0x0281, 0x029a,\n0x0203, 0x0218, 0x0235, 0x022e, 0x026f, 0x0274, 0x0259, 0x0242,\n0x036b, 0x0370, 0x035d, 0x0346, 0x0307, 0x031c, 0x0331, 0x032a,\n0x03b3, 0x03a8, 0x0385, 0x039e, 0x03df, 0x03c4, 0x03e9, 0x03f2,\n0x01bb, 0x01a0, 0x018d, 0x0196, 0x01d7, 0x01cc, 0x01e1, 0x01fa,\n0x0163, 0x0178, 0x0155, 0x014e, 0x010f, 0x0114, 0x0139, 0x0122,\n0x000b, 0x0010, 0x003d, 0x0026, 0x0067, 0x007c, 0x0051, 0x004a,\n0x00d3, 0x00c8, 0x00e5, 0x00fe, 0x00bf, 0x00a4, 0x0089, 0x0092,\n0x01ad, 0x01b6, 0x019b, 0x0180, 0x01c1, 0x01da, 0x01f7, 0x01ec,\n0x0175, 0x016e, 0x0143, 0x0158, 0x0119, 0x0102, 0x012f, 0x0134,\n0x001d, 0x0006, 0x002b, 0x0030, 0x0071, 0x006a, 0x0047, 0x005c,\n0x00c5, 0x00de, 0x00f3, 0x00e8, 0x00a9, 0x00b2, 0x009f, 0x0084,\n0x02cd, 0x02d6, 0x02fb, 0x02e0, 0x02a1, 0x02ba, 0x0297, 0x028c,\n0x0215, 0x020e, 0x0223, 0x0238, 0x0279, 0x0262, 0x024f, 0x0254,\n0x037d, 0x0366, 0x034b, 0x0350, 0x0311, 0x030a, 0x0327, 0x033c,\n0x03a5, 0x03be, 0x0393, 0x0388, 0x03c9, 0x03d2, 0x03ff, 0x03e4,\n0x0376, 0x036d, 0x0340, 0x035b, 0x031a, 0x0301, 0x032c, 0x0337,\n0x03ae, 0x03b5, 0x0398, 0x0383, 0x03c2, 0x03d9, 0x03f4, 0x03ef,\n0x02c6, 0x02dd, 0x02f0, 0x02eb, 0x02aa, 0x02b1, 0x029c, 0x0287,\n0x021e, 0x0205, 0x0228, 0x0233, 0x0272, 0x0269, 0x0244, 0x025f,\n0x0016, 0x000d, 0x0020, 0x003b, 0x007a, 0x0061, 0x004c, 0x0057,\n0x00ce, 0x00d5, 0x00f8, 0x00e3, 0x00a2, 0x00b9, 0x0094, 0x008f,\n0x01a6, 0x01bd, 0x0190, 0x018b, 0x01ca, 0x01d1, 0x01fc, 0x01e7,\n0x017e, 0x0165, 0x0148, 0x0153, 0x0112, 0x0109, 0x0124, 0x013f,\n};\n\n \nstatic const u8 mlxsw_sp4_acl_bf_crc6_tab[256] = {\n0x00, 0x2d, 0x37, 0x1a, 0x03, 0x2e, 0x34, 0x19,\n0x06, 0x2b, 0x31, 0x1c, 0x05, 0x28, 0x32, 0x1f,\n0x0c, 0x21, 0x3b, 0x16, 0x0f, 0x22, 0x38, 0x15,\n0x0a, 0x27, 0x3d, 0x10, 0x09, 0x24, 0x3e, 0x13,\n0x18, 0x35, 0x2f, 0x02, 0x1b, 0x36, 0x2c, 0x01,\n0x1e, 0x33, 0x29, 0x04, 0x1d, 0x30, 0x2a, 0x07,\n0x14, 0x39, 0x23, 0x0e, 0x17, 0x3a, 0x20, 0x0d,\n0x12, 0x3f, 0x25, 0x08, 0x11, 0x3c, 0x26, 0x0b,\n0x30, 0x1d, 0x07, 0x2a, 0x33, 0x1e, 0x04, 0x29,\n0x36, 0x1b, 0x01, 0x2c, 0x35, 0x18, 0x02, 0x2f,\n0x3c, 0x11, 0x0b, 0x26, 0x3f, 0x12, 0x08, 0x25,\n0x3a, 0x17, 0x0d, 0x20, 0x39, 0x14, 0x0e, 0x23,\n0x28, 0x05, 0x1f, 0x32, 0x2b, 0x06, 0x1c, 0x31,\n0x2e, 0x03, 0x19, 0x34, 0x2d, 0x00, 0x1a, 0x37,\n0x24, 0x09, 0x13, 0x3e, 0x27, 0x0a, 0x10, 0x3d,\n0x22, 0x0f, 0x15, 0x38, 0x21, 0x0c, 0x16, 0x3b,\n0x0d, 0x20, 0x3a, 0x17, 0x0e, 0x23, 0x39, 0x14,\n0x0b, 0x26, 0x3c, 0x11, 0x08, 0x25, 0x3f, 0x12,\n0x01, 0x2c, 0x36, 0x1b, 0x02, 0x2f, 0x35, 0x18,\n0x07, 0x2a, 0x30, 0x1d, 0x04, 0x29, 0x33, 0x1e,\n0x15, 0x38, 0x22, 0x0f, 0x16, 0x3b, 0x21, 0x0c,\n0x13, 0x3e, 0x24, 0x09, 0x10, 0x3d, 0x27, 0x0a,\n0x19, 0x34, 0x2e, 0x03, 0x1a, 0x37, 0x2d, 0x00,\n0x1f, 0x32, 0x28, 0x05, 0x1c, 0x31, 0x2b, 0x06,\n0x3d, 0x10, 0x0a, 0x27, 0x3e, 0x13, 0x09, 0x24,\n0x3b, 0x16, 0x0c, 0x21, 0x38, 0x15, 0x0f, 0x22,\n0x31, 0x1c, 0x06, 0x2b, 0x32, 0x1f, 0x05, 0x28,\n0x37, 0x1a, 0x00, 0x2d, 0x34, 0x19, 0x03, 0x2e,\n0x25, 0x08, 0x12, 0x3f, 0x26, 0x0b, 0x11, 0x3c,\n0x23, 0x0e, 0x14, 0x39, 0x20, 0x0d, 0x17, 0x3a,\n0x29, 0x04, 0x1e, 0x33, 0x2a, 0x07, 0x1d, 0x30,\n0x2f, 0x02, 0x18, 0x35, 0x2c, 0x01, 0x1b, 0x36,\n};\n\n \nstatic const u8 chunk_key_offsets[MLXSW_BLOOM_KEY_CHUNKS] = {2, 20, 38};\n\nstatic u16 mlxsw_sp2_acl_bf_crc16_byte(u16 crc, u8 c)\n{\n\treturn (crc << 8) ^ mlxsw_sp2_acl_bf_crc16_tab[(crc >> 8) ^ c];\n}\n\nstatic u16 mlxsw_sp2_acl_bf_crc(const u8 *buffer, size_t len)\n{\n\tu16 crc = 0;\n\n\twhile (len--)\n\t\tcrc = mlxsw_sp2_acl_bf_crc16_byte(crc, *buffer++);\n\treturn crc;\n}\n\nstatic void\n__mlxsw_sp_acl_bf_key_encode(struct mlxsw_sp_acl_atcam_region *aregion,\n\t\t\t     struct mlxsw_sp_acl_atcam_entry *aentry,\n\t\t\t     char *output, u8 *len, u8 max_chunks, u8 pad_bytes,\n\t\t\t     u8 key_offset, u8 chunk_key_len, u8 chunk_len)\n{\n\tstruct mlxsw_afk_key_info *key_info = aregion->region->key_info;\n\tu8 chunk_index, chunk_count, block_count;\n\tchar *chunk = output;\n\t__be16 erp_region_id;\n\n\tblock_count = mlxsw_afk_key_info_blocks_count_get(key_info);\n\tchunk_count = 1 + ((block_count - 1) >> 2);\n\terp_region_id = cpu_to_be16(aentry->ht_key.erp_id |\n\t\t\t\t   (aregion->region->id << 4));\n\tfor (chunk_index = max_chunks - chunk_count; chunk_index < max_chunks;\n\t     chunk_index++) {\n\t\tmemset(chunk, 0, pad_bytes);\n\t\tmemcpy(chunk + pad_bytes, &erp_region_id,\n\t\t       sizeof(erp_region_id));\n\t\tmemcpy(chunk + key_offset,\n\t\t       &aentry->enc_key[chunk_key_offsets[chunk_index]],\n\t\t       chunk_key_len);\n\t\tchunk += chunk_len;\n\t}\n\t*len = chunk_count * chunk_len;\n}\n\nstatic void\nmlxsw_sp2_acl_bf_key_encode(struct mlxsw_sp_acl_atcam_region *aregion,\n\t\t\t    struct mlxsw_sp_acl_atcam_entry *aentry,\n\t\t\t    char *output, u8 *len)\n{\n\t__mlxsw_sp_acl_bf_key_encode(aregion, aentry, output, len,\n\t\t\t\t     MLXSW_BLOOM_KEY_CHUNKS,\n\t\t\t\t     MLXSW_SP2_BLOOM_CHUNK_PAD_BYTES,\n\t\t\t\t     MLXSW_SP2_BLOOM_CHUNK_KEY_OFFSET,\n\t\t\t\t     MLXSW_SP2_BLOOM_CHUNK_KEY_BYTES,\n\t\t\t\t     MLXSW_SP2_BLOOM_KEY_CHUNK_BYTES);\n}\n\nstatic unsigned int\nmlxsw_sp2_acl_bf_index_get(struct mlxsw_sp_acl_bf *bf,\n\t\t\t   struct mlxsw_sp_acl_atcam_region *aregion,\n\t\t\t   struct mlxsw_sp_acl_atcam_entry *aentry)\n{\n\tchar bf_key[MLXSW_SP2_BLOOM_KEY_LEN];\n\tu8 bf_size;\n\n\tmlxsw_sp2_acl_bf_key_encode(aregion, aentry, bf_key, &bf_size);\n\treturn mlxsw_sp2_acl_bf_crc(bf_key, bf_size);\n}\n\nstatic u16 mlxsw_sp4_acl_bf_crc10_byte(u16 crc, u8 c)\n{\n\tu8 index = ((crc >> 2) ^ c) & 0xff;\n\n\treturn ((crc << 8) ^ mlxsw_sp4_acl_bf_crc10_tab[index]) & 0x3ff;\n}\n\nstatic u16 mlxsw_sp4_acl_bf_crc6_byte(u16 crc, u8 c)\n{\n\tu8 index = (crc ^ c) & 0xff;\n\n\treturn ((crc << 6) ^ (mlxsw_sp4_acl_bf_crc6_tab[index] << 2)) & 0xfc;\n}\n\nstatic u16 mlxsw_sp4_acl_bf_crc(const u8 *buffer, size_t len)\n{\n\tu16 crc_row = 0, crc_col = 0;\n\n\twhile (len--) {\n\t\tcrc_row = mlxsw_sp4_acl_bf_crc10_byte(crc_row, *buffer);\n\t\tcrc_col = mlxsw_sp4_acl_bf_crc6_byte(crc_col, *buffer);\n\t\tbuffer++;\n\t}\n\n\tcrc_col >>= 2;\n\n\t \n\treturn (crc_col << 10) | crc_row;\n}\n\nstatic void right_shift_array(char *arr, u8 len, u8 shift_bits)\n{\n\tu8 byte_mask = 0xff >> shift_bits;\n\tint i;\n\n\tif (WARN_ON(!shift_bits || shift_bits >= 8))\n\t\treturn;\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\t \n\t\tarr[i + 1] &= byte_mask;\n\t\tarr[i + 1] |= arr[i] << (8 - shift_bits);\n\t\tarr[i] = arr[i] >> shift_bits;\n\t}\n}\n\nstatic void mlxsw_sp4_bf_key_shift_chunks(u8 chunk_count, char *output)\n{\n\t \n\tswitch (chunk_count) {\n\tcase 2:\n\t\t \n\t\tright_shift_array(output, MLXSW_SP4_BLOOM_KEY_CHUNK_BYTES, 2);\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tright_shift_array(output + MLXSW_SP4_BLOOM_KEY_CHUNK_BYTES,\n\t\t\t\t  MLXSW_SP4_BLOOM_KEY_CHUNK_BYTES, 2);\n\t\tright_shift_array(output, MLXSW_SP4_BLOOM_KEY_CHUNK_BYTES, 4);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(chunk_count > MLXSW_BLOOM_KEY_CHUNKS);\n\t}\n}\n\nstatic void\nmlxsw_sp4_acl_bf_key_encode(struct mlxsw_sp_acl_atcam_region *aregion,\n\t\t\t    struct mlxsw_sp_acl_atcam_entry *aentry,\n\t\t\t    char *output, u8 *len)\n{\n\tstruct mlxsw_afk_key_info *key_info = aregion->region->key_info;\n\tu8 block_count = mlxsw_afk_key_info_blocks_count_get(key_info);\n\tu8 chunk_count = 1 + ((block_count - 1) >> 2);\n\n\t__mlxsw_sp_acl_bf_key_encode(aregion, aentry, output, len,\n\t\t\t\t     MLXSW_BLOOM_KEY_CHUNKS,\n\t\t\t\t     MLXSW_SP4_BLOOM_CHUNK_PAD_BYTES,\n\t\t\t\t     MLXSW_SP4_BLOOM_CHUNK_KEY_OFFSET,\n\t\t\t\t     MLXSW_SP4_BLOOM_CHUNK_KEY_BYTES,\n\t\t\t\t     MLXSW_SP4_BLOOM_KEY_CHUNK_BYTES);\n\tmlxsw_sp4_bf_key_shift_chunks(chunk_count, output);\n}\n\nstatic unsigned int\nmlxsw_sp4_acl_bf_index_get(struct mlxsw_sp_acl_bf *bf,\n\t\t\t   struct mlxsw_sp_acl_atcam_region *aregion,\n\t\t\t   struct mlxsw_sp_acl_atcam_entry *aentry)\n{\n\tchar bf_key[MLXSW_SP4_BLOOM_KEY_LEN] = {};\n\tu8 bf_size;\n\n\tmlxsw_sp4_acl_bf_key_encode(aregion, aentry, bf_key, &bf_size);\n\treturn mlxsw_sp4_acl_bf_crc(bf_key, bf_size);\n}\n\nstatic unsigned int\nmlxsw_sp_acl_bf_rule_count_index_get(struct mlxsw_sp_acl_bf *bf,\n\t\t\t\t     unsigned int erp_bank,\n\t\t\t\t     unsigned int bf_index)\n{\n\treturn erp_bank * bf->bank_size + bf_index;\n}\n\nint\nmlxsw_sp_acl_bf_entry_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  struct mlxsw_sp_acl_bf *bf,\n\t\t\t  struct mlxsw_sp_acl_atcam_region *aregion,\n\t\t\t  unsigned int erp_bank,\n\t\t\t  struct mlxsw_sp_acl_atcam_entry *aentry)\n{\n\tunsigned int rule_index;\n\tchar *peabfe_pl;\n\tu16 bf_index;\n\tint err;\n\n\tmutex_lock(&bf->lock);\n\n\tbf_index = mlxsw_sp->acl_bf_ops->index_get(bf, aregion, aentry);\n\trule_index = mlxsw_sp_acl_bf_rule_count_index_get(bf, erp_bank,\n\t\t\t\t\t\t\t  bf_index);\n\n\tif (refcount_inc_not_zero(&bf->refcnt[rule_index])) {\n\t\terr = 0;\n\t\tgoto unlock;\n\t}\n\n\tpeabfe_pl = kmalloc(MLXSW_REG_PEABFE_LEN, GFP_KERNEL);\n\tif (!peabfe_pl) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tmlxsw_reg_peabfe_pack(peabfe_pl);\n\tmlxsw_reg_peabfe_rec_pack(peabfe_pl, 0, 1, erp_bank, bf_index);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(peabfe), peabfe_pl);\n\tkfree(peabfe_pl);\n\tif (err)\n\t\tgoto unlock;\n\n\trefcount_set(&bf->refcnt[rule_index], 1);\n\terr = 0;\n\nunlock:\n\tmutex_unlock(&bf->lock);\n\treturn err;\n}\n\nvoid\nmlxsw_sp_acl_bf_entry_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  struct mlxsw_sp_acl_bf *bf,\n\t\t\t  struct mlxsw_sp_acl_atcam_region *aregion,\n\t\t\t  unsigned int erp_bank,\n\t\t\t  struct mlxsw_sp_acl_atcam_entry *aentry)\n{\n\tunsigned int rule_index;\n\tchar *peabfe_pl;\n\tu16 bf_index;\n\n\tmutex_lock(&bf->lock);\n\n\tbf_index = mlxsw_sp->acl_bf_ops->index_get(bf, aregion, aentry);\n\trule_index = mlxsw_sp_acl_bf_rule_count_index_get(bf, erp_bank,\n\t\t\t\t\t\t\t  bf_index);\n\n\tif (refcount_dec_and_test(&bf->refcnt[rule_index])) {\n\t\tpeabfe_pl = kmalloc(MLXSW_REG_PEABFE_LEN, GFP_KERNEL);\n\t\tif (!peabfe_pl)\n\t\t\tgoto unlock;\n\n\t\tmlxsw_reg_peabfe_pack(peabfe_pl);\n\t\tmlxsw_reg_peabfe_rec_pack(peabfe_pl, 0, 0, erp_bank, bf_index);\n\t\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(peabfe), peabfe_pl);\n\t\tkfree(peabfe_pl);\n\t}\n\nunlock:\n\tmutex_unlock(&bf->lock);\n}\n\nstruct mlxsw_sp_acl_bf *\nmlxsw_sp_acl_bf_init(struct mlxsw_sp *mlxsw_sp, unsigned int num_erp_banks)\n{\n\tstruct mlxsw_sp_acl_bf *bf;\n\tunsigned int bf_bank_size;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, ACL_MAX_BF_LOG))\n\t\treturn ERR_PTR(-EIO);\n\n\t \n\tbf_bank_size = 1 << MLXSW_CORE_RES_GET(mlxsw_sp->core, ACL_MAX_BF_LOG);\n\tbf = kzalloc(struct_size(bf, refcnt, size_mul(bf_bank_size, num_erp_banks)),\n\t\t     GFP_KERNEL);\n\tif (!bf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbf->bank_size = bf_bank_size;\n\tmutex_init(&bf->lock);\n\n\treturn bf;\n}\n\nvoid mlxsw_sp_acl_bf_fini(struct mlxsw_sp_acl_bf *bf)\n{\n\tmutex_destroy(&bf->lock);\n\tkfree(bf);\n}\n\nconst struct mlxsw_sp_acl_bf_ops mlxsw_sp2_acl_bf_ops = {\n\t.index_get = mlxsw_sp2_acl_bf_index_get,\n};\n\nconst struct mlxsw_sp_acl_bf_ops mlxsw_sp4_acl_bf_ops = {\n\t.index_get = mlxsw_sp4_acl_bf_index_get,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}