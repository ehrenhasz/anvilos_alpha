{
  "module_name": "spectrum_pgt.c",
  "hash_id": "b62f9afdcf9e4a162376836b9533f64930e32a52c9015b309f763f1666c47144",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_pgt.c",
  "human_readable_source": "\n \n\n#include <linux/refcount.h>\n#include <linux/idr.h>\n\n#include \"spectrum.h\"\n#include \"reg.h\"\n\nstruct mlxsw_sp_pgt {\n\tstruct idr pgt_idr;\n\tu16 end_index;  \n\tstruct mutex lock;  \n\tbool smpe_index_valid;\n};\n\nstruct mlxsw_sp_pgt_entry {\n\tstruct list_head ports_list;\n\tu16 index;\n\tu16 smpe_index;\n};\n\nstruct mlxsw_sp_pgt_entry_port {\n\tstruct list_head list;  \n\tu16 local_port;\n};\n\nint mlxsw_sp_pgt_mid_alloc(struct mlxsw_sp *mlxsw_sp, u16 *p_mid)\n{\n\tint index, err = 0;\n\n\tmutex_lock(&mlxsw_sp->pgt->lock);\n\tindex = idr_alloc(&mlxsw_sp->pgt->pgt_idr, NULL, 0,\n\t\t\t  mlxsw_sp->pgt->end_index, GFP_KERNEL);\n\n\tif (index < 0) {\n\t\terr = index;\n\t\tgoto err_idr_alloc;\n\t}\n\n\t*p_mid = index;\n\tmutex_unlock(&mlxsw_sp->pgt->lock);\n\treturn 0;\n\nerr_idr_alloc:\n\tmutex_unlock(&mlxsw_sp->pgt->lock);\n\treturn err;\n}\n\nvoid mlxsw_sp_pgt_mid_free(struct mlxsw_sp *mlxsw_sp, u16 mid_base)\n{\n\tmutex_lock(&mlxsw_sp->pgt->lock);\n\tWARN_ON(idr_remove(&mlxsw_sp->pgt->pgt_idr, mid_base));\n\tmutex_unlock(&mlxsw_sp->pgt->lock);\n}\n\nint\nmlxsw_sp_pgt_mid_alloc_range(struct mlxsw_sp *mlxsw_sp, u16 mid_base, u16 count)\n{\n\tunsigned int idr_cursor;\n\tint i, err;\n\n\tmutex_lock(&mlxsw_sp->pgt->lock);\n\n\t \n\tidr_cursor = idr_get_cursor(&mlxsw_sp->pgt->pgt_idr);\n\tif (WARN_ON(idr_cursor != mid_base)) {\n\t\terr = -EINVAL;\n\t\tgoto err_idr_cursor;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\terr = idr_alloc_cyclic(&mlxsw_sp->pgt->pgt_idr, NULL,\n\t\t\t\t       mid_base, mid_base + count, GFP_KERNEL);\n\t\tif (err < 0)\n\t\t\tgoto err_idr_alloc_cyclic;\n\t}\n\n\tmutex_unlock(&mlxsw_sp->pgt->lock);\n\treturn 0;\n\nerr_idr_alloc_cyclic:\n\tfor (i--; i >= 0; i--)\n\t\tidr_remove(&mlxsw_sp->pgt->pgt_idr, mid_base + i);\nerr_idr_cursor:\n\tmutex_unlock(&mlxsw_sp->pgt->lock);\n\treturn err;\n}\n\nvoid\nmlxsw_sp_pgt_mid_free_range(struct mlxsw_sp *mlxsw_sp, u16 mid_base, u16 count)\n{\n\tstruct idr *pgt_idr = &mlxsw_sp->pgt->pgt_idr;\n\tint i;\n\n\tmutex_lock(&mlxsw_sp->pgt->lock);\n\n\tfor (i = 0; i < count; i++)\n\t\tWARN_ON_ONCE(idr_remove(pgt_idr, mid_base + i));\n\n\tmutex_unlock(&mlxsw_sp->pgt->lock);\n}\n\nstatic struct mlxsw_sp_pgt_entry_port *\nmlxsw_sp_pgt_entry_port_lookup(struct mlxsw_sp_pgt_entry *pgt_entry,\n\t\t\t       u16 local_port)\n{\n\tstruct mlxsw_sp_pgt_entry_port *pgt_entry_port;\n\n\tlist_for_each_entry(pgt_entry_port, &pgt_entry->ports_list, list) {\n\t\tif (pgt_entry_port->local_port == local_port)\n\t\t\treturn pgt_entry_port;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mlxsw_sp_pgt_entry *\nmlxsw_sp_pgt_entry_create(struct mlxsw_sp_pgt *pgt, u16 mid, u16 smpe)\n{\n\tstruct mlxsw_sp_pgt_entry *pgt_entry;\n\tvoid *ret;\n\tint err;\n\n\tpgt_entry = kzalloc(sizeof(*pgt_entry), GFP_KERNEL);\n\tif (!pgt_entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = idr_replace(&pgt->pgt_idr, pgt_entry, mid);\n\tif (IS_ERR(ret)) {\n\t\terr = PTR_ERR(ret);\n\t\tgoto err_idr_replace;\n\t}\n\n\tINIT_LIST_HEAD(&pgt_entry->ports_list);\n\tpgt_entry->index = mid;\n\tpgt_entry->smpe_index = smpe;\n\treturn pgt_entry;\n\nerr_idr_replace:\n\tkfree(pgt_entry);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlxsw_sp_pgt_entry_destroy(struct mlxsw_sp_pgt *pgt,\n\t\t\t\t       struct mlxsw_sp_pgt_entry *pgt_entry)\n{\n\tWARN_ON(!list_empty(&pgt_entry->ports_list));\n\n\tpgt_entry = idr_replace(&pgt->pgt_idr, NULL, pgt_entry->index);\n\tif (WARN_ON(IS_ERR(pgt_entry)))\n\t\treturn;\n\n\tkfree(pgt_entry);\n}\n\nstatic struct mlxsw_sp_pgt_entry *\nmlxsw_sp_pgt_entry_get(struct mlxsw_sp_pgt *pgt, u16 mid, u16 smpe)\n{\n\tstruct mlxsw_sp_pgt_entry *pgt_entry;\n\n\tpgt_entry = idr_find(&pgt->pgt_idr, mid);\n\tif (pgt_entry)\n\t\treturn pgt_entry;\n\n\treturn mlxsw_sp_pgt_entry_create(pgt, mid, smpe);\n}\n\nstatic void mlxsw_sp_pgt_entry_put(struct mlxsw_sp_pgt *pgt, u16 mid)\n{\n\tstruct mlxsw_sp_pgt_entry *pgt_entry;\n\n\tpgt_entry = idr_find(&pgt->pgt_idr, mid);\n\tif (WARN_ON(!pgt_entry))\n\t\treturn;\n\n\tif (list_empty(&pgt_entry->ports_list))\n\t\tmlxsw_sp_pgt_entry_destroy(pgt, pgt_entry);\n}\n\nstatic void mlxsw_sp_pgt_smid2_port_set(char *smid2_pl, u16 local_port,\n\t\t\t\t\tbool member)\n{\n\tmlxsw_reg_smid2_port_set(smid2_pl, local_port, member);\n\tmlxsw_reg_smid2_port_mask_set(smid2_pl, local_port, 1);\n}\n\nstatic int\nmlxsw_sp_pgt_entry_port_write(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      const struct mlxsw_sp_pgt_entry *pgt_entry,\n\t\t\t      u16 local_port, bool member)\n{\n\tchar *smid2_pl;\n\tint err;\n\n\tsmid2_pl = kmalloc(MLXSW_REG_SMID2_LEN, GFP_KERNEL);\n\tif (!smid2_pl)\n\t\treturn -ENOMEM;\n\n\tmlxsw_reg_smid2_pack(smid2_pl, pgt_entry->index, 0, 0,\n\t\t\t     mlxsw_sp->pgt->smpe_index_valid,\n\t\t\t     pgt_entry->smpe_index);\n\n\tmlxsw_sp_pgt_smid2_port_set(smid2_pl, local_port, member);\n\terr = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(smid2), smid2_pl);\n\n\tkfree(smid2_pl);\n\n\treturn err;\n}\n\nstatic struct mlxsw_sp_pgt_entry_port *\nmlxsw_sp_pgt_entry_port_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       struct mlxsw_sp_pgt_entry *pgt_entry,\n\t\t\t       u16 local_port)\n{\n\tstruct mlxsw_sp_pgt_entry_port *pgt_entry_port;\n\tint err;\n\n\tpgt_entry_port = kzalloc(sizeof(*pgt_entry_port), GFP_KERNEL);\n\tif (!pgt_entry_port)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = mlxsw_sp_pgt_entry_port_write(mlxsw_sp, pgt_entry, local_port,\n\t\t\t\t\t    true);\n\tif (err)\n\t\tgoto err_pgt_entry_port_write;\n\n\tpgt_entry_port->local_port = local_port;\n\tlist_add(&pgt_entry_port->list, &pgt_entry->ports_list);\n\n\treturn pgt_entry_port;\n\nerr_pgt_entry_port_write:\n\tkfree(pgt_entry_port);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_pgt_entry_port_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tstruct mlxsw_sp_pgt_entry *pgt_entry,\n\t\t\t\tstruct mlxsw_sp_pgt_entry_port *pgt_entry_port)\n\n{\n\tlist_del(&pgt_entry_port->list);\n\tmlxsw_sp_pgt_entry_port_write(mlxsw_sp, pgt_entry,\n\t\t\t\t      pgt_entry_port->local_port, false);\n\tkfree(pgt_entry_port);\n}\n\nstatic int mlxsw_sp_pgt_entry_port_add(struct mlxsw_sp *mlxsw_sp, u16 mid,\n\t\t\t\t       u16 smpe, u16 local_port)\n{\n\tstruct mlxsw_sp_pgt_entry_port *pgt_entry_port;\n\tstruct mlxsw_sp_pgt_entry *pgt_entry;\n\tint err;\n\n\tmutex_lock(&mlxsw_sp->pgt->lock);\n\n\tpgt_entry = mlxsw_sp_pgt_entry_get(mlxsw_sp->pgt, mid, smpe);\n\tif (IS_ERR(pgt_entry)) {\n\t\terr = PTR_ERR(pgt_entry);\n\t\tgoto err_pgt_entry_get;\n\t}\n\n\tpgt_entry_port = mlxsw_sp_pgt_entry_port_create(mlxsw_sp, pgt_entry,\n\t\t\t\t\t\t\tlocal_port);\n\tif (IS_ERR(pgt_entry_port)) {\n\t\terr = PTR_ERR(pgt_entry_port);\n\t\tgoto err_pgt_entry_port_get;\n\t}\n\n\tmutex_unlock(&mlxsw_sp->pgt->lock);\n\treturn 0;\n\nerr_pgt_entry_port_get:\n\tmlxsw_sp_pgt_entry_put(mlxsw_sp->pgt, mid);\nerr_pgt_entry_get:\n\tmutex_unlock(&mlxsw_sp->pgt->lock);\n\treturn err;\n}\n\nstatic void mlxsw_sp_pgt_entry_port_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tu16 mid, u16 smpe, u16 local_port)\n{\n\tstruct mlxsw_sp_pgt_entry_port *pgt_entry_port;\n\tstruct mlxsw_sp_pgt_entry *pgt_entry;\n\n\tmutex_lock(&mlxsw_sp->pgt->lock);\n\n\tpgt_entry = idr_find(&mlxsw_sp->pgt->pgt_idr, mid);\n\tif (!pgt_entry)\n\t\tgoto out;\n\n\tpgt_entry_port = mlxsw_sp_pgt_entry_port_lookup(pgt_entry, local_port);\n\tif (!pgt_entry_port)\n\t\tgoto out;\n\n\tmlxsw_sp_pgt_entry_port_destroy(mlxsw_sp, pgt_entry, pgt_entry_port);\n\tmlxsw_sp_pgt_entry_put(mlxsw_sp->pgt, mid);\n\nout:\n\tmutex_unlock(&mlxsw_sp->pgt->lock);\n}\n\nint mlxsw_sp_pgt_entry_port_set(struct mlxsw_sp *mlxsw_sp, u16 mid,\n\t\t\t\tu16 smpe, u16 local_port, bool member)\n{\n\tif (member)\n\t\treturn mlxsw_sp_pgt_entry_port_add(mlxsw_sp, mid, smpe,\n\t\t\t\t\t\t   local_port);\n\n\tmlxsw_sp_pgt_entry_port_del(mlxsw_sp, mid, smpe, local_port);\n\treturn 0;\n}\n\nint mlxsw_sp_pgt_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_pgt *pgt;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, PGT_SIZE))\n\t\treturn -EIO;\n\n\tpgt = kzalloc(sizeof(*mlxsw_sp->pgt), GFP_KERNEL);\n\tif (!pgt)\n\t\treturn -ENOMEM;\n\n\tidr_init(&pgt->pgt_idr);\n\tpgt->end_index = MLXSW_CORE_RES_GET(mlxsw_sp->core, PGT_SIZE);\n\tmutex_init(&pgt->lock);\n\tpgt->smpe_index_valid = mlxsw_sp->pgt_smpe_index_valid;\n\tmlxsw_sp->pgt = pgt;\n\treturn 0;\n}\n\nvoid mlxsw_sp_pgt_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tmutex_destroy(&mlxsw_sp->pgt->lock);\n\tWARN_ON(!idr_is_empty(&mlxsw_sp->pgt->pgt_idr));\n\tidr_destroy(&mlxsw_sp->pgt->pgt_idr);\n\tkfree(mlxsw_sp->pgt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}