{
  "module_name": "reg.h",
  "hash_id": "91ff8334e6a05348022622ab2942bcd64c39bfaf97340341244f7458b347b8a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/reg.h",
  "human_readable_source": " \n \n\n#ifndef _MLXSW_REG_H\n#define _MLXSW_REG_H\n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/bitops.h>\n#include <linux/if_vlan.h>\n\n#include \"item.h\"\n#include \"port.h\"\n\nstruct mlxsw_reg_info {\n\tu16 id;\n\tu16 len;  \n\tconst char *name;\n};\n\n#define MLXSW_REG_DEFINE(_name, _id, _len)\t\t\t\t\\\nstatic const struct mlxsw_reg_info mlxsw_reg_##_name = {\t\t\\\n\t.id = _id,\t\t\t\t\t\t\t\\\n\t.len = _len,\t\t\t\t\t\t\t\\\n\t.name = #_name,\t\t\t\t\t\t\t\\\n}\n\n#define MLXSW_REG(type) (&mlxsw_reg_##type)\n#define MLXSW_REG_LEN(type) MLXSW_REG(type)->len\n#define MLXSW_REG_ZERO(type, payload) memset(payload, 0, MLXSW_REG(type)->len)\n\n \n#define MLXSW_REG_SGCR_ID 0x2000\n#define MLXSW_REG_SGCR_LEN 0x10\n\nMLXSW_REG_DEFINE(sgcr, MLXSW_REG_SGCR_ID, MLXSW_REG_SGCR_LEN);\n\n \nMLXSW_ITEM32(reg, sgcr, llb, 0x04, 0, 1);\n\nstatic inline void mlxsw_reg_sgcr_pack(char *payload, bool llb)\n{\n\tMLXSW_REG_ZERO(sgcr, payload);\n\tmlxsw_reg_sgcr_llb_set(payload, !!llb);\n}\n\n \n#define MLXSW_REG_SPAD_ID 0x2002\n#define MLXSW_REG_SPAD_LEN 0x10\n\nMLXSW_REG_DEFINE(spad, MLXSW_REG_SPAD_ID, MLXSW_REG_SPAD_LEN);\n\n \nMLXSW_ITEM_BUF(reg, spad, base_mac, 0x02, 6);\n\n \n#define MLXSW_REG_SSPR_ID 0x2008\n#define MLXSW_REG_SSPR_LEN 0x8\n\nMLXSW_REG_DEFINE(sspr, MLXSW_REG_SSPR_ID, MLXSW_REG_SSPR_LEN);\n\n \nMLXSW_ITEM32(reg, sspr, m, 0x00, 31, 1);\n\n \nMLXSW_ITEM32_LP(reg, sspr, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, sspr, system_port, 0x04, 0, 16);\n\nstatic inline void mlxsw_reg_sspr_pack(char *payload, u16 local_port)\n{\n\tMLXSW_REG_ZERO(sspr, payload);\n\tmlxsw_reg_sspr_m_set(payload, 1);\n\tmlxsw_reg_sspr_local_port_set(payload, local_port);\n\tmlxsw_reg_sspr_system_port_set(payload, local_port);\n}\n\n \n#define MLXSW_REG_SFDAT_ID 0x2009\n#define MLXSW_REG_SFDAT_LEN 0x8\n\nMLXSW_REG_DEFINE(sfdat, MLXSW_REG_SFDAT_ID, MLXSW_REG_SFDAT_LEN);\n\n \nMLXSW_ITEM32(reg, sfdat, swid, 0x00, 24, 8);\n\n \nMLXSW_ITEM32(reg, sfdat, age_time, 0x04, 0, 20);\n\nstatic inline void mlxsw_reg_sfdat_pack(char *payload, u32 age_time)\n{\n\tMLXSW_REG_ZERO(sfdat, payload);\n\tmlxsw_reg_sfdat_swid_set(payload, 0);\n\tmlxsw_reg_sfdat_age_time_set(payload, age_time);\n}\n\n \n#define MLXSW_REG_SFD_ID 0x200A\n#define MLXSW_REG_SFD_BASE_LEN 0x10  \n#define MLXSW_REG_SFD_REC_LEN 0x10  \n#define MLXSW_REG_SFD_REC_MAX_COUNT 64\n#define MLXSW_REG_SFD_LEN (MLXSW_REG_SFD_BASE_LEN +\t\\\n\t\t\t   MLXSW_REG_SFD_REC_LEN * MLXSW_REG_SFD_REC_MAX_COUNT)\n\nMLXSW_REG_DEFINE(sfd, MLXSW_REG_SFD_ID, MLXSW_REG_SFD_LEN);\n\n \nMLXSW_ITEM32(reg, sfd, swid, 0x00, 24, 8);\n\nenum mlxsw_reg_sfd_op {\n\t \n\tMLXSW_REG_SFD_OP_QUERY_DUMP = 0,\n\t \n\tMLXSW_REG_SFD_OP_QUERY_QUERY = 1,\n\t \n\tMLXSW_REG_SFD_OP_QUERY_QUERY_AND_CLEAR_ACTIVITY = 2,\n\t \n\tMLXSW_REG_SFD_OP_WRITE_TEST = 0,\n\t \n\tMLXSW_REG_SFD_OP_WRITE_EDIT = 1,\n\t \n\tMLXSW_REG_SFD_OP_WRITE_REMOVE = 2,\n\t \n\tMLXSW_REG_SFD_OP_WRITE_REMOVE_NOTIFICATION = 2,\n};\n\n \nMLXSW_ITEM32(reg, sfd, op, 0x04, 30, 2);\n\n \nMLXSW_ITEM32(reg, sfd, record_locator, 0x04, 0, 30);\n\n \nMLXSW_ITEM32(reg, sfd, num_rec, 0x08, 0, 8);\n\nstatic inline void mlxsw_reg_sfd_pack(char *payload, enum mlxsw_reg_sfd_op op,\n\t\t\t\t      u32 record_locator)\n{\n\tMLXSW_REG_ZERO(sfd, payload);\n\tmlxsw_reg_sfd_op_set(payload, op);\n\tmlxsw_reg_sfd_record_locator_set(payload, record_locator);\n}\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, rec_swid, MLXSW_REG_SFD_BASE_LEN, 24, 8,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x00, false);\n\nenum mlxsw_reg_sfd_rec_type {\n\tMLXSW_REG_SFD_REC_TYPE_UNICAST = 0x0,\n\tMLXSW_REG_SFD_REC_TYPE_UNICAST_LAG = 0x1,\n\tMLXSW_REG_SFD_REC_TYPE_MULTICAST = 0x2,\n\tMLXSW_REG_SFD_REC_TYPE_UNICAST_TUNNEL = 0xC,\n};\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, rec_type, MLXSW_REG_SFD_BASE_LEN, 20, 4,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x00, false);\n\nenum mlxsw_reg_sfd_rec_policy {\n\t \n\tMLXSW_REG_SFD_REC_POLICY_STATIC_ENTRY = 0,\n\t \n\tMLXSW_REG_SFD_REC_POLICY_DYNAMIC_ENTRY_MLAG = 1,\n\t \n\tMLXSW_REG_SFD_REC_POLICY_DYNAMIC_ENTRY_INGRESS = 3,\n};\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, rec_policy, MLXSW_REG_SFD_BASE_LEN, 18, 2,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, rec_a, MLXSW_REG_SFD_BASE_LEN, 16, 1,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM_BUF_INDEXED(reg, sfd, rec_mac, MLXSW_REG_SFD_BASE_LEN, 6,\n\t\t       MLXSW_REG_SFD_REC_LEN, 0x02);\n\nenum mlxsw_reg_sfd_rec_action {\n\t \n\tMLXSW_REG_SFD_REC_ACTION_NOP = 0,\n\t \n\tMLXSW_REG_SFD_REC_ACTION_MIRROR_TO_CPU = 1,\n\t \n\tMLXSW_REG_SFD_REC_ACTION_TRAP = 2,\n\t \n\tMLXSW_REG_SFD_REC_ACTION_FORWARD_IP_ROUTER = 3,\n\tMLXSW_REG_SFD_REC_ACTION_DISCARD_ERROR = 15,\n};\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, rec_action, MLXSW_REG_SFD_BASE_LEN, 28, 4,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x0C, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, uc_sub_port, MLXSW_REG_SFD_BASE_LEN, 16, 8,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x08, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, uc_set_vid, MLXSW_REG_SFD_BASE_LEN, 31, 1,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x08, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, uc_fid_vid, MLXSW_REG_SFD_BASE_LEN, 0, 16,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x08, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, uc_vid, MLXSW_REG_SFD_BASE_LEN, 16, 12,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x0C, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, uc_system_port, MLXSW_REG_SFD_BASE_LEN, 0, 16,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x0C, false);\n\nstatic inline void mlxsw_reg_sfd_rec_pack(char *payload, int rec_index,\n\t\t\t\t\t  enum mlxsw_reg_sfd_rec_type rec_type,\n\t\t\t\t\t  const char *mac,\n\t\t\t\t\t  enum mlxsw_reg_sfd_rec_action action)\n{\n\tu8 num_rec = mlxsw_reg_sfd_num_rec_get(payload);\n\n\tif (rec_index >= num_rec)\n\t\tmlxsw_reg_sfd_num_rec_set(payload, rec_index + 1);\n\tmlxsw_reg_sfd_rec_swid_set(payload, rec_index, 0);\n\tmlxsw_reg_sfd_rec_type_set(payload, rec_index, rec_type);\n\tmlxsw_reg_sfd_rec_mac_memcpy_to(payload, rec_index, mac);\n\tmlxsw_reg_sfd_rec_action_set(payload, rec_index, action);\n}\n\nstatic inline void mlxsw_reg_sfd_uc_pack(char *payload, int rec_index,\n\t\t\t\t\t enum mlxsw_reg_sfd_rec_policy policy,\n\t\t\t\t\t const char *mac, u16 fid_vid, u16 vid,\n\t\t\t\t\t enum mlxsw_reg_sfd_rec_action action,\n\t\t\t\t\t u16 local_port)\n{\n\tmlxsw_reg_sfd_rec_pack(payload, rec_index,\n\t\t\t       MLXSW_REG_SFD_REC_TYPE_UNICAST, mac, action);\n\tmlxsw_reg_sfd_rec_policy_set(payload, rec_index, policy);\n\tmlxsw_reg_sfd_uc_sub_port_set(payload, rec_index, 0);\n\tmlxsw_reg_sfd_uc_fid_vid_set(payload, rec_index, fid_vid);\n\tmlxsw_reg_sfd_uc_set_vid_set(payload, rec_index, vid ? true : false);\n\tmlxsw_reg_sfd_uc_vid_set(payload, rec_index, vid);\n\tmlxsw_reg_sfd_uc_system_port_set(payload, rec_index, local_port);\n}\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, uc_lag_sub_port, MLXSW_REG_SFD_BASE_LEN, 16, 8,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x08, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, uc_lag_set_vid, MLXSW_REG_SFD_BASE_LEN, 31, 1,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x08, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, uc_lag_fid_vid, MLXSW_REG_SFD_BASE_LEN, 0, 16,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x08, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, uc_lag_lag_vid, MLXSW_REG_SFD_BASE_LEN, 16, 12,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x0C, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, uc_lag_lag_id, MLXSW_REG_SFD_BASE_LEN, 0, 10,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x0C, false);\n\nstatic inline void\nmlxsw_reg_sfd_uc_lag_pack(char *payload, int rec_index,\n\t\t\t  enum mlxsw_reg_sfd_rec_policy policy,\n\t\t\t  const char *mac, u16 fid_vid,\n\t\t\t  enum mlxsw_reg_sfd_rec_action action, u16 lag_vid,\n\t\t\t  u16 lag_id)\n{\n\tmlxsw_reg_sfd_rec_pack(payload, rec_index,\n\t\t\t       MLXSW_REG_SFD_REC_TYPE_UNICAST_LAG,\n\t\t\t       mac, action);\n\tmlxsw_reg_sfd_rec_policy_set(payload, rec_index, policy);\n\tmlxsw_reg_sfd_uc_lag_sub_port_set(payload, rec_index, 0);\n\tmlxsw_reg_sfd_uc_lag_fid_vid_set(payload, rec_index, fid_vid);\n\tmlxsw_reg_sfd_uc_lag_set_vid_set(payload, rec_index, true);\n\tmlxsw_reg_sfd_uc_lag_lag_vid_set(payload, rec_index, lag_vid);\n\tmlxsw_reg_sfd_uc_lag_lag_id_set(payload, rec_index, lag_id);\n}\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, mc_pgi, MLXSW_REG_SFD_BASE_LEN, 16, 13,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x08, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, mc_fid_vid, MLXSW_REG_SFD_BASE_LEN, 0, 16,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x08, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, mc_mid, MLXSW_REG_SFD_BASE_LEN, 0, 16,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x0C, false);\n\nstatic inline void\nmlxsw_reg_sfd_mc_pack(char *payload, int rec_index,\n\t\t      const char *mac, u16 fid_vid,\n\t\t      enum mlxsw_reg_sfd_rec_action action, u16 mid)\n{\n\tmlxsw_reg_sfd_rec_pack(payload, rec_index,\n\t\t\t       MLXSW_REG_SFD_REC_TYPE_MULTICAST, mac, action);\n\tmlxsw_reg_sfd_mc_pgi_set(payload, rec_index, 0x1FFF);\n\tmlxsw_reg_sfd_mc_fid_vid_set(payload, rec_index, fid_vid);\n\tmlxsw_reg_sfd_mc_mid_set(payload, rec_index, mid);\n}\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, uc_tunnel_uip_msb, MLXSW_REG_SFD_BASE_LEN, 24,\n\t\t     8, MLXSW_REG_SFD_REC_LEN, 0x08, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, uc_tunnel_fid, MLXSW_REG_SFD_BASE_LEN, 0, 16,\n\t\t     MLXSW_REG_SFD_REC_LEN, 0x08, false);\n\nenum mlxsw_reg_sfd_uc_tunnel_protocol {\n\tMLXSW_REG_SFD_UC_TUNNEL_PROTOCOL_IPV4,\n\tMLXSW_REG_SFD_UC_TUNNEL_PROTOCOL_IPV6,\n};\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, uc_tunnel_protocol, MLXSW_REG_SFD_BASE_LEN, 27,\n\t\t     1, MLXSW_REG_SFD_REC_LEN, 0x0C, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfd, uc_tunnel_uip_lsb, MLXSW_REG_SFD_BASE_LEN, 0,\n\t\t     24, MLXSW_REG_SFD_REC_LEN, 0x0C, false);\n\nstatic inline void\nmlxsw_reg_sfd_uc_tunnel_pack(char *payload, int rec_index,\n\t\t\t     enum mlxsw_reg_sfd_rec_policy policy,\n\t\t\t     const char *mac, u16 fid,\n\t\t\t     enum mlxsw_reg_sfd_rec_action action,\n\t\t\t     enum mlxsw_reg_sfd_uc_tunnel_protocol proto)\n{\n\tmlxsw_reg_sfd_rec_pack(payload, rec_index,\n\t\t\t       MLXSW_REG_SFD_REC_TYPE_UNICAST_TUNNEL, mac,\n\t\t\t       action);\n\tmlxsw_reg_sfd_rec_policy_set(payload, rec_index, policy);\n\tmlxsw_reg_sfd_uc_tunnel_fid_set(payload, rec_index, fid);\n\tmlxsw_reg_sfd_uc_tunnel_protocol_set(payload, rec_index, proto);\n}\n\nstatic inline void\nmlxsw_reg_sfd_uc_tunnel_pack4(char *payload, int rec_index,\n\t\t\t      enum mlxsw_reg_sfd_rec_policy policy,\n\t\t\t      const char *mac, u16 fid,\n\t\t\t      enum mlxsw_reg_sfd_rec_action action, u32 uip)\n{\n\tmlxsw_reg_sfd_uc_tunnel_uip_msb_set(payload, rec_index, uip >> 24);\n\tmlxsw_reg_sfd_uc_tunnel_uip_lsb_set(payload, rec_index, uip);\n\tmlxsw_reg_sfd_uc_tunnel_pack(payload, rec_index, policy, mac, fid,\n\t\t\t\t     action,\n\t\t\t\t     MLXSW_REG_SFD_UC_TUNNEL_PROTOCOL_IPV4);\n}\n\nstatic inline void\nmlxsw_reg_sfd_uc_tunnel_pack6(char *payload, int rec_index, const char *mac,\n\t\t\t      u16 fid, enum mlxsw_reg_sfd_rec_action action,\n\t\t\t      u32 uip_ptr)\n{\n\tmlxsw_reg_sfd_uc_tunnel_uip_lsb_set(payload, rec_index, uip_ptr);\n\t \n\tmlxsw_reg_sfd_uc_tunnel_pack(payload, rec_index,\n\t\t\t\t     MLXSW_REG_SFD_REC_POLICY_STATIC_ENTRY,\n\t\t\t\t     mac, fid, action,\n\t\t\t\t     MLXSW_REG_SFD_UC_TUNNEL_PROTOCOL_IPV6);\n}\n\nenum mlxsw_reg_tunnel_port {\n\tMLXSW_REG_TUNNEL_PORT_NVE,\n\tMLXSW_REG_TUNNEL_PORT_VPLS,\n\tMLXSW_REG_TUNNEL_PORT_FLEX_TUNNEL0,\n\tMLXSW_REG_TUNNEL_PORT_FLEX_TUNNEL1,\n};\n\n \n#define MLXSW_REG_SFN_ID 0x200B\n#define MLXSW_REG_SFN_BASE_LEN 0x10  \n#define MLXSW_REG_SFN_REC_LEN 0x10  \n#define MLXSW_REG_SFN_REC_MAX_COUNT 64\n#define MLXSW_REG_SFN_LEN (MLXSW_REG_SFN_BASE_LEN +\t\\\n\t\t\t   MLXSW_REG_SFN_REC_LEN * MLXSW_REG_SFN_REC_MAX_COUNT)\n\nMLXSW_REG_DEFINE(sfn, MLXSW_REG_SFN_ID, MLXSW_REG_SFN_LEN);\n\n \nMLXSW_ITEM32(reg, sfn, swid, 0x00, 24, 8);\n\n \nMLXSW_ITEM32(reg, sfn, end, 0x04, 20, 1);\n\n \nMLXSW_ITEM32(reg, sfn, num_rec, 0x04, 0, 8);\n\nstatic inline void mlxsw_reg_sfn_pack(char *payload)\n{\n\tMLXSW_REG_ZERO(sfn, payload);\n\tmlxsw_reg_sfn_swid_set(payload, 0);\n\tmlxsw_reg_sfn_end_set(payload, 0);\n\tmlxsw_reg_sfn_num_rec_set(payload, MLXSW_REG_SFN_REC_MAX_COUNT);\n}\n\n \nMLXSW_ITEM32_INDEXED(reg, sfn, rec_swid, MLXSW_REG_SFN_BASE_LEN, 24, 8,\n\t\t     MLXSW_REG_SFN_REC_LEN, 0x00, false);\n\nenum mlxsw_reg_sfn_rec_type {\n\t \n\tMLXSW_REG_SFN_REC_TYPE_LEARNED_MAC = 0x5,\n\t \n\tMLXSW_REG_SFN_REC_TYPE_LEARNED_MAC_LAG = 0x6,\n\t \n\tMLXSW_REG_SFN_REC_TYPE_AGED_OUT_MAC = 0x7,\n\t \n\tMLXSW_REG_SFN_REC_TYPE_AGED_OUT_MAC_LAG = 0x8,\n\t \n\tMLXSW_REG_SFN_REC_TYPE_LEARNED_UNICAST_TUNNEL = 0xD,\n\t \n\tMLXSW_REG_SFN_REC_TYPE_AGED_OUT_UNICAST_TUNNEL = 0xE,\n};\n\n \nMLXSW_ITEM32_INDEXED(reg, sfn, rec_type, MLXSW_REG_SFN_BASE_LEN, 20, 4,\n\t\t     MLXSW_REG_SFN_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM_BUF_INDEXED(reg, sfn, rec_mac, MLXSW_REG_SFN_BASE_LEN, 6,\n\t\t       MLXSW_REG_SFN_REC_LEN, 0x02);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfn, mac_sub_port, MLXSW_REG_SFN_BASE_LEN, 16, 8,\n\t\t     MLXSW_REG_SFN_REC_LEN, 0x08, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfn, mac_fid, MLXSW_REG_SFN_BASE_LEN, 0, 16,\n\t\t     MLXSW_REG_SFN_REC_LEN, 0x08, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfn, mac_system_port, MLXSW_REG_SFN_BASE_LEN, 0, 16,\n\t\t     MLXSW_REG_SFN_REC_LEN, 0x0C, false);\n\nstatic inline void mlxsw_reg_sfn_mac_unpack(char *payload, int rec_index,\n\t\t\t\t\t    char *mac, u16 *p_vid,\n\t\t\t\t\t    u16 *p_local_port)\n{\n\tmlxsw_reg_sfn_rec_mac_memcpy_from(payload, rec_index, mac);\n\t*p_vid = mlxsw_reg_sfn_mac_fid_get(payload, rec_index);\n\t*p_local_port = mlxsw_reg_sfn_mac_system_port_get(payload, rec_index);\n}\n\n \nMLXSW_ITEM32_INDEXED(reg, sfn, mac_lag_lag_id, MLXSW_REG_SFN_BASE_LEN, 0, 10,\n\t\t     MLXSW_REG_SFN_REC_LEN, 0x0C, false);\n\nstatic inline void mlxsw_reg_sfn_mac_lag_unpack(char *payload, int rec_index,\n\t\t\t\t\t\tchar *mac, u16 *p_vid,\n\t\t\t\t\t\tu16 *p_lag_id)\n{\n\tmlxsw_reg_sfn_rec_mac_memcpy_from(payload, rec_index, mac);\n\t*p_vid = mlxsw_reg_sfn_mac_fid_get(payload, rec_index);\n\t*p_lag_id = mlxsw_reg_sfn_mac_lag_lag_id_get(payload, rec_index);\n}\n\n \nMLXSW_ITEM32_INDEXED(reg, sfn, uc_tunnel_uip_msb, MLXSW_REG_SFN_BASE_LEN, 24,\n\t\t     8, MLXSW_REG_SFN_REC_LEN, 0x08, false);\n\nenum mlxsw_reg_sfn_uc_tunnel_protocol {\n\tMLXSW_REG_SFN_UC_TUNNEL_PROTOCOL_IPV4,\n\tMLXSW_REG_SFN_UC_TUNNEL_PROTOCOL_IPV6,\n};\n\n \nMLXSW_ITEM32_INDEXED(reg, sfn, uc_tunnel_protocol, MLXSW_REG_SFN_BASE_LEN, 27,\n\t\t     1, MLXSW_REG_SFN_REC_LEN, 0x0C, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfn, uc_tunnel_uip_lsb, MLXSW_REG_SFN_BASE_LEN, 0,\n\t\t     24, MLXSW_REG_SFN_REC_LEN, 0x0C, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sfn, tunnel_port, MLXSW_REG_SFN_BASE_LEN, 0, 4,\n\t\t     MLXSW_REG_SFN_REC_LEN, 0x10, false);\n\nstatic inline void\nmlxsw_reg_sfn_uc_tunnel_unpack(char *payload, int rec_index, char *mac,\n\t\t\t       u16 *p_fid, u32 *p_uip,\n\t\t\t       enum mlxsw_reg_sfn_uc_tunnel_protocol *p_proto)\n{\n\tu32 uip_msb, uip_lsb;\n\n\tmlxsw_reg_sfn_rec_mac_memcpy_from(payload, rec_index, mac);\n\t*p_fid = mlxsw_reg_sfn_mac_fid_get(payload, rec_index);\n\tuip_msb = mlxsw_reg_sfn_uc_tunnel_uip_msb_get(payload, rec_index);\n\tuip_lsb = mlxsw_reg_sfn_uc_tunnel_uip_lsb_get(payload, rec_index);\n\t*p_uip = uip_msb << 24 | uip_lsb;\n\t*p_proto = mlxsw_reg_sfn_uc_tunnel_protocol_get(payload, rec_index);\n}\n\n \n#define MLXSW_REG_SPMS_ID 0x200D\n#define MLXSW_REG_SPMS_LEN 0x404\n\nMLXSW_REG_DEFINE(spms, MLXSW_REG_SPMS_ID, MLXSW_REG_SPMS_LEN);\n\n \nMLXSW_ITEM32_LP(reg, spms, 0x00, 16, 0x00, 12);\n\nenum mlxsw_reg_spms_state {\n\tMLXSW_REG_SPMS_STATE_NO_CHANGE,\n\tMLXSW_REG_SPMS_STATE_DISCARDING,\n\tMLXSW_REG_SPMS_STATE_LEARNING,\n\tMLXSW_REG_SPMS_STATE_FORWARDING,\n};\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, spms, state, 0x04, 0x400, 2);\n\nstatic inline void mlxsw_reg_spms_pack(char *payload, u16 local_port)\n{\n\tMLXSW_REG_ZERO(spms, payload);\n\tmlxsw_reg_spms_local_port_set(payload, local_port);\n}\n\nstatic inline void mlxsw_reg_spms_vid_pack(char *payload, u16 vid,\n\t\t\t\t\t   enum mlxsw_reg_spms_state state)\n{\n\tmlxsw_reg_spms_state_set(payload, vid, state);\n}\n\n \n#define MLXSW_REG_SPVID_ID 0x200E\n#define MLXSW_REG_SPVID_LEN 0x08\n\nMLXSW_REG_DEFINE(spvid, MLXSW_REG_SPVID_ID, MLXSW_REG_SPVID_LEN);\n\n \nMLXSW_ITEM32(reg, spvid, tport, 0x00, 24, 1);\n\n \nMLXSW_ITEM32_LP(reg, spvid, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, spvid, sub_port, 0x00, 8, 8);\n\n \nMLXSW_ITEM32(reg, spvid, egr_et_set, 0x04, 24, 1);\n\n \nMLXSW_ITEM32(reg, spvid, et_vlan, 0x04, 16, 2);\n\n \nMLXSW_ITEM32(reg, spvid, pvid, 0x04, 0, 12);\n\nstatic inline void mlxsw_reg_spvid_pack(char *payload, u16 local_port, u16 pvid,\n\t\t\t\t\tu8 et_vlan)\n{\n\tMLXSW_REG_ZERO(spvid, payload);\n\tmlxsw_reg_spvid_local_port_set(payload, local_port);\n\tmlxsw_reg_spvid_pvid_set(payload, pvid);\n\tmlxsw_reg_spvid_et_vlan_set(payload, et_vlan);\n}\n\n \n#define MLXSW_REG_SPVM_ID 0x200F\n#define MLXSW_REG_SPVM_BASE_LEN 0x04  \n#define MLXSW_REG_SPVM_REC_LEN 0x04  \n#define MLXSW_REG_SPVM_REC_MAX_COUNT 255\n#define MLXSW_REG_SPVM_LEN (MLXSW_REG_SPVM_BASE_LEN +\t\\\n\t\t    MLXSW_REG_SPVM_REC_LEN * MLXSW_REG_SPVM_REC_MAX_COUNT)\n\nMLXSW_REG_DEFINE(spvm, MLXSW_REG_SPVM_ID, MLXSW_REG_SPVM_LEN);\n\n \nMLXSW_ITEM32(reg, spvm, pt, 0x00, 31, 1);\n\n \nMLXSW_ITEM32(reg, spvm, pte, 0x00, 30, 1);\n\n \nMLXSW_ITEM32_LP(reg, spvm, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, spvm, sub_port, 0x00, 8, 8);\n\n \nMLXSW_ITEM32(reg, spvm, num_rec, 0x00, 0, 8);\n\n \nMLXSW_ITEM32_INDEXED(reg, spvm, rec_i,\n\t\t     MLXSW_REG_SPVM_BASE_LEN, 14, 1,\n\t\t     MLXSW_REG_SPVM_REC_LEN, 0, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, spvm, rec_e,\n\t\t     MLXSW_REG_SPVM_BASE_LEN, 13, 1,\n\t\t     MLXSW_REG_SPVM_REC_LEN, 0, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, spvm, rec_u,\n\t\t     MLXSW_REG_SPVM_BASE_LEN, 12, 1,\n\t\t     MLXSW_REG_SPVM_REC_LEN, 0, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, spvm, rec_vid,\n\t\t     MLXSW_REG_SPVM_BASE_LEN, 0, 12,\n\t\t     MLXSW_REG_SPVM_REC_LEN, 0, false);\n\nstatic inline void mlxsw_reg_spvm_pack(char *payload, u16 local_port,\n\t\t\t\t       u16 vid_begin, u16 vid_end,\n\t\t\t\t       bool is_member, bool untagged)\n{\n\tint size = vid_end - vid_begin + 1;\n\tint i;\n\n\tMLXSW_REG_ZERO(spvm, payload);\n\tmlxsw_reg_spvm_local_port_set(payload, local_port);\n\tmlxsw_reg_spvm_num_rec_set(payload, size);\n\n\tfor (i = 0; i < size; i++) {\n\t\tmlxsw_reg_spvm_rec_i_set(payload, i, is_member);\n\t\tmlxsw_reg_spvm_rec_e_set(payload, i, is_member);\n\t\tmlxsw_reg_spvm_rec_u_set(payload, i, untagged);\n\t\tmlxsw_reg_spvm_rec_vid_set(payload, i, vid_begin + i);\n\t}\n}\n\n \n#define MLXSW_REG_SPAFT_ID 0x2010\n#define MLXSW_REG_SPAFT_LEN 0x08\n\nMLXSW_REG_DEFINE(spaft, MLXSW_REG_SPAFT_ID, MLXSW_REG_SPAFT_LEN);\n\n \nMLXSW_ITEM32_LP(reg, spaft, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, spaft, sub_port, 0x00, 8, 8);\n\n \nMLXSW_ITEM32(reg, spaft, allow_untagged, 0x04, 31, 1);\n\n \nMLXSW_ITEM32(reg, spaft, allow_prio_tagged, 0x04, 30, 1);\n\n \nMLXSW_ITEM32(reg, spaft, allow_tagged, 0x04, 29, 1);\n\nstatic inline void mlxsw_reg_spaft_pack(char *payload, u16 local_port,\n\t\t\t\t\tbool allow_untagged)\n{\n\tMLXSW_REG_ZERO(spaft, payload);\n\tmlxsw_reg_spaft_local_port_set(payload, local_port);\n\tmlxsw_reg_spaft_allow_untagged_set(payload, allow_untagged);\n\tmlxsw_reg_spaft_allow_prio_tagged_set(payload, allow_untagged);\n\tmlxsw_reg_spaft_allow_tagged_set(payload, true);\n}\n\n \n#define MLXSW_REG_SFGC_ID 0x2011\n#define MLXSW_REG_SFGC_LEN 0x14\n\nMLXSW_REG_DEFINE(sfgc, MLXSW_REG_SFGC_ID, MLXSW_REG_SFGC_LEN);\n\nenum mlxsw_reg_sfgc_type {\n\tMLXSW_REG_SFGC_TYPE_BROADCAST,\n\tMLXSW_REG_SFGC_TYPE_UNKNOWN_UNICAST,\n\tMLXSW_REG_SFGC_TYPE_UNREGISTERED_MULTICAST_IPV4,\n\tMLXSW_REG_SFGC_TYPE_UNREGISTERED_MULTICAST_IPV6,\n\tMLXSW_REG_SFGC_TYPE_RESERVED,\n\tMLXSW_REG_SFGC_TYPE_UNREGISTERED_MULTICAST_NON_IP,\n\tMLXSW_REG_SFGC_TYPE_IPV4_LINK_LOCAL,\n\tMLXSW_REG_SFGC_TYPE_IPV6_ALL_HOST,\n\tMLXSW_REG_SFGC_TYPE_MAX,\n};\n\n \nMLXSW_ITEM32(reg, sfgc, type, 0x00, 0, 4);\n\n \nenum mlxsw_reg_bridge_type {\n\tMLXSW_REG_BRIDGE_TYPE_0 = 0,  \n\tMLXSW_REG_BRIDGE_TYPE_1 = 1,  \n};\n\n \nMLXSW_ITEM32(reg, sfgc, bridge_type, 0x04, 24, 3);\n\nenum mlxsw_flood_table_type {\n\tMLXSW_REG_SFGC_TABLE_TYPE_VID = 1,\n\tMLXSW_REG_SFGC_TABLE_TYPE_SINGLE = 2,\n\tMLXSW_REG_SFGC_TABLE_TYPE_ANY = 0,\n\tMLXSW_REG_SFGC_TABLE_TYPE_FID_OFFSET = 3,\n\tMLXSW_REG_SFGC_TABLE_TYPE_FID = 4,\n};\n\n \nMLXSW_ITEM32(reg, sfgc, table_type, 0x04, 16, 3);\n\n \nMLXSW_ITEM32(reg, sfgc, flood_table, 0x04, 0, 6);\n\n \nMLXSW_ITEM32(reg, sfgc, counter_set_type, 0x0C, 24, 8);\n\n \nMLXSW_ITEM32(reg, sfgc, counter_index, 0x0C, 0, 24);\n\n \nMLXSW_ITEM32(reg, sfgc, mid_base, 0x10, 0, 16);\n\nstatic inline void\nmlxsw_reg_sfgc_pack(char *payload, enum mlxsw_reg_sfgc_type type,\n\t\t    enum mlxsw_reg_bridge_type bridge_type,\n\t\t    enum mlxsw_flood_table_type table_type,\n\t\t    unsigned int flood_table, u16 mid_base)\n{\n\tMLXSW_REG_ZERO(sfgc, payload);\n\tmlxsw_reg_sfgc_type_set(payload, type);\n\tmlxsw_reg_sfgc_bridge_type_set(payload, bridge_type);\n\tmlxsw_reg_sfgc_table_type_set(payload, table_type);\n\tmlxsw_reg_sfgc_flood_table_set(payload, flood_table);\n\tmlxsw_reg_sfgc_mid_base_set(payload, mid_base);\n}\n\n \n#define MLXSW_REG_SFDF_ID 0x2013\n#define MLXSW_REG_SFDF_LEN 0x14\n\nMLXSW_REG_DEFINE(sfdf, MLXSW_REG_SFDF_ID, MLXSW_REG_SFDF_LEN);\n\n \nMLXSW_ITEM32(reg, sfdf, swid, 0x00, 24, 8);\n\nenum mlxsw_reg_sfdf_flush_type {\n\tMLXSW_REG_SFDF_FLUSH_PER_SWID,\n\tMLXSW_REG_SFDF_FLUSH_PER_FID,\n\tMLXSW_REG_SFDF_FLUSH_PER_PORT,\n\tMLXSW_REG_SFDF_FLUSH_PER_PORT_AND_FID,\n\tMLXSW_REG_SFDF_FLUSH_PER_LAG,\n\tMLXSW_REG_SFDF_FLUSH_PER_LAG_AND_FID,\n\tMLXSW_REG_SFDF_FLUSH_PER_NVE,\n\tMLXSW_REG_SFDF_FLUSH_PER_NVE_AND_FID,\n};\n\n \nMLXSW_ITEM32(reg, sfdf, flush_type, 0x04, 28, 4);\n\n \nMLXSW_ITEM32(reg, sfdf, flush_static, 0x04, 24, 1);\n\nstatic inline void mlxsw_reg_sfdf_pack(char *payload,\n\t\t\t\t       enum mlxsw_reg_sfdf_flush_type type)\n{\n\tMLXSW_REG_ZERO(sfdf, payload);\n\tmlxsw_reg_sfdf_flush_type_set(payload, type);\n\tmlxsw_reg_sfdf_flush_static_set(payload, true);\n}\n\n \nMLXSW_ITEM32(reg, sfdf, fid, 0x0C, 0, 16);\n\n \nMLXSW_ITEM32(reg, sfdf, system_port, 0x0C, 0, 16);\n\n \nMLXSW_ITEM32(reg, sfdf, port_fid_system_port, 0x08, 0, 16);\n\n \nMLXSW_ITEM32(reg, sfdf, lag_id, 0x0C, 0, 10);\n\n \nMLXSW_ITEM32(reg, sfdf, lag_fid_lag_id, 0x08, 0, 10);\n\n \n#define MLXSW_REG_SLDR_ID 0x2014\n#define MLXSW_REG_SLDR_LEN 0x0C  \n\nMLXSW_REG_DEFINE(sldr, MLXSW_REG_SLDR_ID, MLXSW_REG_SLDR_LEN);\n\nenum mlxsw_reg_sldr_op {\n\t \n\tMLXSW_REG_SLDR_OP_LAG_CREATE,\n\tMLXSW_REG_SLDR_OP_LAG_DESTROY,\n\t \n\tMLXSW_REG_SLDR_OP_LAG_ADD_PORT_LIST,\n\t \n\tMLXSW_REG_SLDR_OP_LAG_REMOVE_PORT_LIST,\n};\n\n \nMLXSW_ITEM32(reg, sldr, op, 0x00, 29, 3);\n\n \nMLXSW_ITEM32(reg, sldr, lag_id, 0x00, 0, 10);\n\nstatic inline void mlxsw_reg_sldr_lag_create_pack(char *payload, u8 lag_id)\n{\n\tMLXSW_REG_ZERO(sldr, payload);\n\tmlxsw_reg_sldr_op_set(payload, MLXSW_REG_SLDR_OP_LAG_CREATE);\n\tmlxsw_reg_sldr_lag_id_set(payload, lag_id);\n}\n\nstatic inline void mlxsw_reg_sldr_lag_destroy_pack(char *payload, u8 lag_id)\n{\n\tMLXSW_REG_ZERO(sldr, payload);\n\tmlxsw_reg_sldr_op_set(payload, MLXSW_REG_SLDR_OP_LAG_DESTROY);\n\tmlxsw_reg_sldr_lag_id_set(payload, lag_id);\n}\n\n \nMLXSW_ITEM32(reg, sldr, num_ports, 0x04, 24, 8);\n\n \nMLXSW_ITEM32_INDEXED(reg, sldr, system_port, 0x08, 0, 16, 4, 0, false);\n\nstatic inline void mlxsw_reg_sldr_lag_add_port_pack(char *payload, u8 lag_id,\n\t\t\t\t\t\t    u16 local_port)\n{\n\tMLXSW_REG_ZERO(sldr, payload);\n\tmlxsw_reg_sldr_op_set(payload, MLXSW_REG_SLDR_OP_LAG_ADD_PORT_LIST);\n\tmlxsw_reg_sldr_lag_id_set(payload, lag_id);\n\tmlxsw_reg_sldr_num_ports_set(payload, 1);\n\tmlxsw_reg_sldr_system_port_set(payload, 0, local_port);\n}\n\nstatic inline void mlxsw_reg_sldr_lag_remove_port_pack(char *payload, u8 lag_id,\n\t\t\t\t\t\t       u16 local_port)\n{\n\tMLXSW_REG_ZERO(sldr, payload);\n\tmlxsw_reg_sldr_op_set(payload, MLXSW_REG_SLDR_OP_LAG_REMOVE_PORT_LIST);\n\tmlxsw_reg_sldr_lag_id_set(payload, lag_id);\n\tmlxsw_reg_sldr_num_ports_set(payload, 1);\n\tmlxsw_reg_sldr_system_port_set(payload, 0, local_port);\n}\n\n \n#define MLXSW_REG_SLCR_ID 0x2015\n#define MLXSW_REG_SLCR_LEN 0x10\n\nMLXSW_REG_DEFINE(slcr, MLXSW_REG_SLCR_ID, MLXSW_REG_SLCR_LEN);\n\nenum mlxsw_reg_slcr_pp {\n\t \n\tMLXSW_REG_SLCR_PP_GLOBAL,\n\t \n\tMLXSW_REG_SLCR_PP_PER_PORT,\n};\n\n \nMLXSW_ITEM32(reg, slcr, pp, 0x00, 24, 1);\n\n \nMLXSW_ITEM32_LP(reg, slcr, 0x00, 16, 0x00, 12);\n\nenum mlxsw_reg_slcr_type {\n\tMLXSW_REG_SLCR_TYPE_CRC,  \n\tMLXSW_REG_SLCR_TYPE_XOR,\n\tMLXSW_REG_SLCR_TYPE_RANDOM,\n};\n\n \nMLXSW_ITEM32(reg, slcr, type, 0x00, 0, 4);\n\n \n#define MLXSW_REG_SLCR_LAG_HASH_IN_PORT\t\tBIT(0)\n \n#define MLXSW_REG_SLCR_LAG_HASH_SMAC_IP\t\tBIT(1)\n \n#define MLXSW_REG_SLCR_LAG_HASH_SMAC_NONIP\tBIT(2)\n#define MLXSW_REG_SLCR_LAG_HASH_SMAC \\\n\t(MLXSW_REG_SLCR_LAG_HASH_SMAC_IP | \\\n\t MLXSW_REG_SLCR_LAG_HASH_SMAC_NONIP)\n \n#define MLXSW_REG_SLCR_LAG_HASH_DMAC_IP\t\tBIT(3)\n \n#define MLXSW_REG_SLCR_LAG_HASH_DMAC_NONIP\tBIT(4)\n#define MLXSW_REG_SLCR_LAG_HASH_DMAC \\\n\t(MLXSW_REG_SLCR_LAG_HASH_DMAC_IP | \\\n\t MLXSW_REG_SLCR_LAG_HASH_DMAC_NONIP)\n \n#define MLXSW_REG_SLCR_LAG_HASH_ETHERTYPE_IP\tBIT(5)\n \n#define MLXSW_REG_SLCR_LAG_HASH_ETHERTYPE_NONIP\tBIT(6)\n#define MLXSW_REG_SLCR_LAG_HASH_ETHERTYPE \\\n\t(MLXSW_REG_SLCR_LAG_HASH_ETHERTYPE_IP | \\\n\t MLXSW_REG_SLCR_LAG_HASH_ETHERTYPE_NONIP)\n \n#define MLXSW_REG_SLCR_LAG_HASH_VLANID_IP\tBIT(7)\n \n#define MLXSW_REG_SLCR_LAG_HASH_VLANID_NONIP\tBIT(8)\n#define MLXSW_REG_SLCR_LAG_HASH_VLANID \\\n\t(MLXSW_REG_SLCR_LAG_HASH_VLANID_IP | \\\n\t MLXSW_REG_SLCR_LAG_HASH_VLANID_NONIP)\n \n#define MLXSW_REG_SLCR_LAG_HASH_SIP\t\tBIT(9)\n \n#define MLXSW_REG_SLCR_LAG_HASH_DIP\t\tBIT(10)\n \n#define MLXSW_REG_SLCR_LAG_HASH_SPORT\t\tBIT(11)\n \n#define MLXSW_REG_SLCR_LAG_HASH_DPORT\t\tBIT(12)\n \n#define MLXSW_REG_SLCR_LAG_HASH_IPPROTO\t\tBIT(13)\n \n#define MLXSW_REG_SLCR_LAG_HASH_FLOWLABEL\tBIT(14)\n \n#define MLXSW_REG_SLCR_LAG_HASH_FCOE_SID\tBIT(15)\n \n#define MLXSW_REG_SLCR_LAG_HASH_FCOE_DID\tBIT(16)\n \n#define MLXSW_REG_SLCR_LAG_HASH_FCOE_OXID\tBIT(17)\n \n#define MLXSW_REG_SLCR_LAG_HASH_ROCE_DQP\tBIT(19)\n\n \nMLXSW_ITEM32(reg, slcr, lag_hash, 0x04, 0, 20);\n\n \nMLXSW_ITEM32(reg, slcr, seed, 0x08, 0, 32);\n\nstatic inline void mlxsw_reg_slcr_pack(char *payload, u16 lag_hash, u32 seed)\n{\n\tMLXSW_REG_ZERO(slcr, payload);\n\tmlxsw_reg_slcr_pp_set(payload, MLXSW_REG_SLCR_PP_GLOBAL);\n\tmlxsw_reg_slcr_type_set(payload, MLXSW_REG_SLCR_TYPE_CRC);\n\tmlxsw_reg_slcr_lag_hash_set(payload, lag_hash);\n\tmlxsw_reg_slcr_seed_set(payload, seed);\n}\n\n \n#define MLXSW_REG_SLCOR_ID 0x2016\n#define MLXSW_REG_SLCOR_LEN 0x10\n\nMLXSW_REG_DEFINE(slcor, MLXSW_REG_SLCOR_ID, MLXSW_REG_SLCOR_LEN);\n\nenum mlxsw_reg_slcor_col {\n\t \n\tMLXSW_REG_SLCOR_COL_LAG_ADD_PORT,\n\tMLXSW_REG_SLCOR_COL_LAG_COLLECTOR_ENABLED,\n\tMLXSW_REG_SLCOR_COL_LAG_COLLECTOR_DISABLED,\n\tMLXSW_REG_SLCOR_COL_LAG_REMOVE_PORT,\n};\n\n \nMLXSW_ITEM32(reg, slcor, col, 0x00, 30, 2);\n\n \nMLXSW_ITEM32_LP(reg, slcor, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, slcor, lag_id, 0x00, 0, 10);\n\n \nMLXSW_ITEM32(reg, slcor, port_index, 0x04, 0, 10);\n\nstatic inline void mlxsw_reg_slcor_pack(char *payload,\n\t\t\t\t\tu16 local_port, u16 lag_id,\n\t\t\t\t\tenum mlxsw_reg_slcor_col col)\n{\n\tMLXSW_REG_ZERO(slcor, payload);\n\tmlxsw_reg_slcor_col_set(payload, col);\n\tmlxsw_reg_slcor_local_port_set(payload, local_port);\n\tmlxsw_reg_slcor_lag_id_set(payload, lag_id);\n}\n\nstatic inline void mlxsw_reg_slcor_port_add_pack(char *payload,\n\t\t\t\t\t\t u16 local_port, u16 lag_id,\n\t\t\t\t\t\t u8 port_index)\n{\n\tmlxsw_reg_slcor_pack(payload, local_port, lag_id,\n\t\t\t     MLXSW_REG_SLCOR_COL_LAG_ADD_PORT);\n\tmlxsw_reg_slcor_port_index_set(payload, port_index);\n}\n\nstatic inline void mlxsw_reg_slcor_port_remove_pack(char *payload,\n\t\t\t\t\t\t    u16 local_port, u16 lag_id)\n{\n\tmlxsw_reg_slcor_pack(payload, local_port, lag_id,\n\t\t\t     MLXSW_REG_SLCOR_COL_LAG_REMOVE_PORT);\n}\n\nstatic inline void mlxsw_reg_slcor_col_enable_pack(char *payload,\n\t\t\t\t\t\t   u16 local_port, u16 lag_id)\n{\n\tmlxsw_reg_slcor_pack(payload, local_port, lag_id,\n\t\t\t     MLXSW_REG_SLCOR_COL_LAG_COLLECTOR_ENABLED);\n}\n\nstatic inline void mlxsw_reg_slcor_col_disable_pack(char *payload,\n\t\t\t\t\t\t    u16 local_port, u16 lag_id)\n{\n\tmlxsw_reg_slcor_pack(payload, local_port, lag_id,\n\t\t\t     MLXSW_REG_SLCOR_COL_LAG_COLLECTOR_ENABLED);\n}\n\n \n#define MLXSW_REG_SPMLR_ID 0x2018\n#define MLXSW_REG_SPMLR_LEN 0x8\n\nMLXSW_REG_DEFINE(spmlr, MLXSW_REG_SPMLR_ID, MLXSW_REG_SPMLR_LEN);\n\n \nMLXSW_ITEM32_LP(reg, spmlr, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, spmlr, sub_port, 0x00, 8, 8);\n\nenum mlxsw_reg_spmlr_learn_mode {\n\tMLXSW_REG_SPMLR_LEARN_MODE_DISABLE = 0,\n\tMLXSW_REG_SPMLR_LEARN_MODE_ENABLE = 2,\n\tMLXSW_REG_SPMLR_LEARN_MODE_SEC = 3,\n};\n\n \nMLXSW_ITEM32(reg, spmlr, learn_mode, 0x04, 30, 2);\n\nstatic inline void mlxsw_reg_spmlr_pack(char *payload, u16 local_port,\n\t\t\t\t\tenum mlxsw_reg_spmlr_learn_mode mode)\n{\n\tMLXSW_REG_ZERO(spmlr, payload);\n\tmlxsw_reg_spmlr_local_port_set(payload, local_port);\n\tmlxsw_reg_spmlr_sub_port_set(payload, 0);\n\tmlxsw_reg_spmlr_learn_mode_set(payload, mode);\n}\n\n \n#define MLXSW_REG_SVFA_ID 0x201C\n#define MLXSW_REG_SVFA_LEN 0x18\n\nMLXSW_REG_DEFINE(svfa, MLXSW_REG_SVFA_ID, MLXSW_REG_SVFA_LEN);\n\n \nMLXSW_ITEM32(reg, svfa, swid, 0x00, 24, 8);\n\n \nMLXSW_ITEM32_LP(reg, svfa, 0x00, 16, 0x00, 12);\n\nenum mlxsw_reg_svfa_mt {\n\tMLXSW_REG_SVFA_MT_VID_TO_FID,\n\tMLXSW_REG_SVFA_MT_PORT_VID_TO_FID,\n\tMLXSW_REG_SVFA_MT_VNI_TO_FID,\n};\n\n \nMLXSW_ITEM32(reg, svfa, mapping_table, 0x00, 8, 3);\n\n \nMLXSW_ITEM32(reg, svfa, v, 0x00, 0, 1);\n\n \nMLXSW_ITEM32(reg, svfa, fid, 0x04, 16, 16);\n\n \nMLXSW_ITEM32(reg, svfa, vid, 0x04, 0, 12);\n\n \nMLXSW_ITEM32(reg, svfa, counter_set_type, 0x08, 24, 8);\n\n \nMLXSW_ITEM32(reg, svfa, counter_index, 0x08, 0, 24);\n\n \nMLXSW_ITEM32(reg, svfa, vni, 0x10, 0, 24);\n\n \nMLXSW_ITEM32(reg, svfa, irif_v, 0x14, 24, 1);\n\n \nMLXSW_ITEM32(reg, svfa, irif, 0x14, 0, 16);\n\nstatic inline void __mlxsw_reg_svfa_pack(char *payload,\n\t\t\t\t\t enum mlxsw_reg_svfa_mt mt, bool valid,\n\t\t\t\t\t u16 fid, bool irif_v, u16 irif)\n{\n\tMLXSW_REG_ZERO(svfa, payload);\n\tmlxsw_reg_svfa_swid_set(payload, 0);\n\tmlxsw_reg_svfa_mapping_table_set(payload, mt);\n\tmlxsw_reg_svfa_v_set(payload, valid);\n\tmlxsw_reg_svfa_fid_set(payload, fid);\n\tmlxsw_reg_svfa_irif_v_set(payload, irif_v);\n\tmlxsw_reg_svfa_irif_set(payload, irif_v ? irif : 0);\n}\n\nstatic inline void mlxsw_reg_svfa_port_vid_pack(char *payload, u16 local_port,\n\t\t\t\t\t\tbool valid, u16 fid, u16 vid,\n\t\t\t\t\t\tbool irif_v, u16 irif)\n{\n\tenum mlxsw_reg_svfa_mt mt = MLXSW_REG_SVFA_MT_PORT_VID_TO_FID;\n\n\t__mlxsw_reg_svfa_pack(payload, mt, valid, fid, irif_v, irif);\n\tmlxsw_reg_svfa_local_port_set(payload, local_port);\n\tmlxsw_reg_svfa_vid_set(payload, vid);\n}\n\nstatic inline void mlxsw_reg_svfa_vid_pack(char *payload, bool valid, u16 fid,\n\t\t\t\t\t   u16 vid, bool irif_v, u16 irif)\n{\n\tenum mlxsw_reg_svfa_mt mt = MLXSW_REG_SVFA_MT_VID_TO_FID;\n\n\t__mlxsw_reg_svfa_pack(payload, mt, valid, fid, irif_v, irif);\n\tmlxsw_reg_svfa_vid_set(payload, vid);\n}\n\nstatic inline void mlxsw_reg_svfa_vni_pack(char *payload, bool valid, u16 fid,\n\t\t\t\t\t   u32 vni, bool irif_v, u16 irif)\n{\n\tenum mlxsw_reg_svfa_mt mt = MLXSW_REG_SVFA_MT_VNI_TO_FID;\n\n\t__mlxsw_reg_svfa_pack(payload, mt, valid, fid, irif_v, irif);\n\tmlxsw_reg_svfa_vni_set(payload, vni);\n}\n\n \n#define MLXSW_REG_SPVTR_ID 0x201D\n#define MLXSW_REG_SPVTR_LEN 0x10\n\nMLXSW_REG_DEFINE(spvtr, MLXSW_REG_SPVTR_ID, MLXSW_REG_SPVTR_LEN);\n\n \nMLXSW_ITEM32(reg, spvtr, tport, 0x00, 24, 1);\n\n \nMLXSW_ITEM32_LP(reg, spvtr, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, spvtr, ippe, 0x04, 31, 1);\n\n \nMLXSW_ITEM32(reg, spvtr, ipve, 0x04, 30, 1);\n\n \nMLXSW_ITEM32(reg, spvtr, epve, 0x04, 29, 1);\n\n \nMLXSW_ITEM32(reg, spvtr, ipprio_mode, 0x04, 20, 4);\n\nenum mlxsw_reg_spvtr_ipvid_mode {\n\t \n\tMLXSW_REG_SPVTR_IPVID_MODE_IEEE_COMPLIANT_PVID,\n\t \n\tMLXSW_REG_SPVTR_IPVID_MODE_PUSH_VLAN_FOR_UNTAGGED_PACKET,\n\t \n\tMLXSW_REG_SPVTR_IPVID_MODE_ALWAYS_PUSH_VLAN,\n};\n\n \nMLXSW_ITEM32(reg, spvtr, ipvid_mode, 0x04, 16, 4);\n\nenum mlxsw_reg_spvtr_epvid_mode {\n\t \n\tMLXSW_REG_SPVTR_EPVID_MODE_IEEE_COMPLIANT_VLAN_MEMBERSHIP,\n\t \n\tMLXSW_REG_SPVTR_EPVID_MODE_POP_VLAN,\n};\n\n \nMLXSW_ITEM32(reg, spvtr, epvid_mode, 0x04, 0, 4);\n\nstatic inline void mlxsw_reg_spvtr_pack(char *payload, bool tport,\n\t\t\t\t\tu16 local_port,\n\t\t\t\t\tenum mlxsw_reg_spvtr_ipvid_mode ipvid_mode)\n{\n\tMLXSW_REG_ZERO(spvtr, payload);\n\tmlxsw_reg_spvtr_tport_set(payload, tport);\n\tmlxsw_reg_spvtr_local_port_set(payload, local_port);\n\tmlxsw_reg_spvtr_ipvid_mode_set(payload, ipvid_mode);\n\tmlxsw_reg_spvtr_ipve_set(payload, true);\n}\n\n \n#define MLXSW_REG_SVPE_ID 0x201E\n#define MLXSW_REG_SVPE_LEN 0x4\n\nMLXSW_REG_DEFINE(svpe, MLXSW_REG_SVPE_ID, MLXSW_REG_SVPE_LEN);\n\n \nMLXSW_ITEM32_LP(reg, svpe, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, svpe, vp_en, 0x00, 8, 1);\n\nstatic inline void mlxsw_reg_svpe_pack(char *payload, u16 local_port,\n\t\t\t\t       bool enable)\n{\n\tMLXSW_REG_ZERO(svpe, payload);\n\tmlxsw_reg_svpe_local_port_set(payload, local_port);\n\tmlxsw_reg_svpe_vp_en_set(payload, enable);\n}\n\n \n#define MLXSW_REG_SFMR_ID 0x201F\n#define MLXSW_REG_SFMR_LEN 0x30\n\nMLXSW_REG_DEFINE(sfmr, MLXSW_REG_SFMR_ID, MLXSW_REG_SFMR_LEN);\n\nenum mlxsw_reg_sfmr_op {\n\tMLXSW_REG_SFMR_OP_CREATE_FID,\n\tMLXSW_REG_SFMR_OP_DESTROY_FID,\n};\n\n \nMLXSW_ITEM32(reg, sfmr, op, 0x00, 24, 4);\n\n \nMLXSW_ITEM32(reg, sfmr, fid, 0x00, 0, 16);\n\n \nMLXSW_ITEM32(reg, sfmr, flood_rsp, 0x08, 31, 1);\n\n \nMLXSW_ITEM32(reg, sfmr, flood_bridge_type, 0x08, 28, 1);\n\n \nMLXSW_ITEM32(reg, sfmr, fid_offset, 0x08, 0, 16);\n\n \nMLXSW_ITEM32(reg, sfmr, vtfp, 0x0C, 31, 1);\n\n \nMLXSW_ITEM32(reg, sfmr, nve_tunnel_flood_ptr, 0x0C, 0, 24);\n\n \nMLXSW_ITEM32(reg, sfmr, vv, 0x10, 31, 1);\n\n \nMLXSW_ITEM32(reg, sfmr, vni, 0x10, 0, 24);\n\n \nMLXSW_ITEM32(reg, sfmr, irif_v, 0x14, 24, 1);\n\n \nMLXSW_ITEM32(reg, sfmr, irif, 0x14, 0, 16);\n\n \nMLXSW_ITEM32(reg, sfmr, smpe_valid, 0x28, 20, 1);\n\n \nMLXSW_ITEM32(reg, sfmr, smpe, 0x28, 0, 16);\n\nstatic inline void mlxsw_reg_sfmr_pack(char *payload,\n\t\t\t\t       enum mlxsw_reg_sfmr_op op, u16 fid,\n\t\t\t\t       u16 fid_offset, bool flood_rsp,\n\t\t\t\t       enum mlxsw_reg_bridge_type bridge_type,\n\t\t\t\t       bool smpe_valid, u16 smpe)\n{\n\tMLXSW_REG_ZERO(sfmr, payload);\n\tmlxsw_reg_sfmr_op_set(payload, op);\n\tmlxsw_reg_sfmr_fid_set(payload, fid);\n\tmlxsw_reg_sfmr_fid_offset_set(payload, fid_offset);\n\tmlxsw_reg_sfmr_vtfp_set(payload, false);\n\tmlxsw_reg_sfmr_vv_set(payload, false);\n\tmlxsw_reg_sfmr_flood_rsp_set(payload, flood_rsp);\n\tmlxsw_reg_sfmr_flood_bridge_type_set(payload, bridge_type);\n\tmlxsw_reg_sfmr_smpe_valid_set(payload, smpe_valid);\n\tmlxsw_reg_sfmr_smpe_set(payload, smpe);\n}\n\n \n#define MLXSW_REG_SPVMLR_ID 0x2020\n#define MLXSW_REG_SPVMLR_BASE_LEN 0x04  \n#define MLXSW_REG_SPVMLR_REC_LEN 0x04  \n#define MLXSW_REG_SPVMLR_REC_MAX_COUNT 255\n#define MLXSW_REG_SPVMLR_LEN (MLXSW_REG_SPVMLR_BASE_LEN + \\\n\t\t\t      MLXSW_REG_SPVMLR_REC_LEN * \\\n\t\t\t      MLXSW_REG_SPVMLR_REC_MAX_COUNT)\n\nMLXSW_REG_DEFINE(spvmlr, MLXSW_REG_SPVMLR_ID, MLXSW_REG_SPVMLR_LEN);\n\n \nMLXSW_ITEM32_LP(reg, spvmlr, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, spvmlr, num_rec, 0x00, 0, 8);\n\n \nMLXSW_ITEM32_INDEXED(reg, spvmlr, rec_learn_enable, MLXSW_REG_SPVMLR_BASE_LEN,\n\t\t     31, 1, MLXSW_REG_SPVMLR_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, spvmlr, rec_vid, MLXSW_REG_SPVMLR_BASE_LEN, 0, 12,\n\t\t     MLXSW_REG_SPVMLR_REC_LEN, 0x00, false);\n\nstatic inline void mlxsw_reg_spvmlr_pack(char *payload, u16 local_port,\n\t\t\t\t\t u16 vid_begin, u16 vid_end,\n\t\t\t\t\t bool learn_enable)\n{\n\tint num_rec = vid_end - vid_begin + 1;\n\tint i;\n\n\tWARN_ON(num_rec < 1 || num_rec > MLXSW_REG_SPVMLR_REC_MAX_COUNT);\n\n\tMLXSW_REG_ZERO(spvmlr, payload);\n\tmlxsw_reg_spvmlr_local_port_set(payload, local_port);\n\tmlxsw_reg_spvmlr_num_rec_set(payload, num_rec);\n\n\tfor (i = 0; i < num_rec; i++) {\n\t\tmlxsw_reg_spvmlr_rec_learn_enable_set(payload, i, learn_enable);\n\t\tmlxsw_reg_spvmlr_rec_vid_set(payload, i, vid_begin + i);\n\t}\n}\n\n \n#define MLXSW_REG_SPFSR_ID 0x2023\n#define MLXSW_REG_SPFSR_LEN 0x08\n\nMLXSW_REG_DEFINE(spfsr, MLXSW_REG_SPFSR_ID, MLXSW_REG_SPFSR_LEN);\n\n \nMLXSW_ITEM32_LP(reg, spfsr, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, spfsr, security, 0x04, 31, 1);\n\nstatic inline void mlxsw_reg_spfsr_pack(char *payload, u16 local_port,\n\t\t\t\t\tbool security)\n{\n\tMLXSW_REG_ZERO(spfsr, payload);\n\tmlxsw_reg_spfsr_local_port_set(payload, local_port);\n\tmlxsw_reg_spfsr_security_set(payload, security);\n}\n\n \n#define MLXSW_REG_SPVC_ID 0x2026\n#define MLXSW_REG_SPVC_LEN 0x0C\n\nMLXSW_REG_DEFINE(spvc, MLXSW_REG_SPVC_ID, MLXSW_REG_SPVC_LEN);\n\n \nMLXSW_ITEM32_LP(reg, spvc, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, spvc, inner_et2, 0x08, 17, 1);\n\n \nMLXSW_ITEM32(reg, spvc, et2, 0x08, 16, 1);\n\n \nMLXSW_ITEM32(reg, spvc, inner_et1, 0x08, 9, 1);\n\n \nMLXSW_ITEM32(reg, spvc, et1, 0x08, 8, 1);\n\n \nMLXSW_ITEM32(reg, spvc, inner_et0, 0x08, 1, 1);\n\n \nMLXSW_ITEM32(reg, spvc, et0, 0x08, 0, 1);\n\nstatic inline void mlxsw_reg_spvc_pack(char *payload, u16 local_port, bool et1,\n\t\t\t\t       bool et0)\n{\n\tMLXSW_REG_ZERO(spvc, payload);\n\tmlxsw_reg_spvc_local_port_set(payload, local_port);\n\t \n\tmlxsw_reg_spvc_inner_et1_set(payload, 1);\n\tmlxsw_reg_spvc_inner_et0_set(payload, 1);\n\tmlxsw_reg_spvc_et1_set(payload, et1);\n\tmlxsw_reg_spvc_et0_set(payload, et0);\n}\n\n \n#define MLXSW_REG_SPEVET_ID 0x202A\n#define MLXSW_REG_SPEVET_LEN 0x08\n\nMLXSW_REG_DEFINE(spevet, MLXSW_REG_SPEVET_ID, MLXSW_REG_SPEVET_LEN);\n\n \nMLXSW_ITEM32_LP(reg, spevet, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, spevet, et_vlan, 0x04, 16, 2);\n\nstatic inline void mlxsw_reg_spevet_pack(char *payload, u16 local_port,\n\t\t\t\t\t u8 et_vlan)\n{\n\tMLXSW_REG_ZERO(spevet, payload);\n\tmlxsw_reg_spevet_local_port_set(payload, local_port);\n\tmlxsw_reg_spevet_et_vlan_set(payload, et_vlan);\n}\n\n \n#define MLXSW_REG_SMPE_ID 0x202B\n#define MLXSW_REG_SMPE_LEN 0x0C\n\nMLXSW_REG_DEFINE(smpe, MLXSW_REG_SMPE_ID, MLXSW_REG_SMPE_LEN);\n\n \nMLXSW_ITEM32_LP(reg, smpe, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, smpe, smpe_index, 0x04, 0, 16);\n\n \nMLXSW_ITEM32(reg, smpe, evid, 0x08, 0, 12);\n\nstatic inline void mlxsw_reg_smpe_pack(char *payload, u16 local_port,\n\t\t\t\t       u16 smpe_index, u16 evid)\n{\n\tMLXSW_REG_ZERO(smpe, payload);\n\tmlxsw_reg_smpe_local_port_set(payload, local_port);\n\tmlxsw_reg_smpe_smpe_index_set(payload, smpe_index);\n\tmlxsw_reg_smpe_evid_set(payload, evid);\n}\n\n \n#define MLXSW_REG_SMID2_ID 0x2034\n#define MLXSW_REG_SMID2_LEN 0x120\n\nMLXSW_REG_DEFINE(smid2, MLXSW_REG_SMID2_ID, MLXSW_REG_SMID2_LEN);\n\n \nMLXSW_ITEM32(reg, smid2, swid, 0x00, 24, 8);\n\n \nMLXSW_ITEM32(reg, smid2, mid, 0x00, 0, 16);\n\n \nMLXSW_ITEM32(reg, smid2, smpe_valid, 0x08, 20, 1);\n\n \nMLXSW_ITEM32(reg, smid2, smpe, 0x08, 0, 16);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, smid2, port, 0x20, 0x80, 1);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, smid2, port_mask, 0xA0, 0x80, 1);\n\nstatic inline void mlxsw_reg_smid2_pack(char *payload, u16 mid, u16 port,\n\t\t\t\t\tbool set, bool smpe_valid, u16 smpe)\n{\n\tMLXSW_REG_ZERO(smid2, payload);\n\tmlxsw_reg_smid2_swid_set(payload, 0);\n\tmlxsw_reg_smid2_mid_set(payload, mid);\n\tmlxsw_reg_smid2_port_set(payload, port, set);\n\tmlxsw_reg_smid2_port_mask_set(payload, port, 1);\n\tmlxsw_reg_smid2_smpe_valid_set(payload, smpe_valid);\n\tmlxsw_reg_smid2_smpe_set(payload, smpe_valid ? smpe : 0);\n}\n\n \n#define MLXSW_REG_CWTP_ID 0x2802\n#define MLXSW_REG_CWTP_BASE_LEN 0x28\n#define MLXSW_REG_CWTP_PROFILE_DATA_REC_LEN 0x08\n#define MLXSW_REG_CWTP_LEN 0x40\n\nMLXSW_REG_DEFINE(cwtp, MLXSW_REG_CWTP_ID, MLXSW_REG_CWTP_LEN);\n\n \nMLXSW_ITEM32_LP(reg, cwtp, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, cwtp, traffic_class, 32, 0, 8);\n\n \nMLXSW_ITEM32_INDEXED(reg, cwtp, profile_min, MLXSW_REG_CWTP_BASE_LEN,\n\t\t     0, 20, MLXSW_REG_CWTP_PROFILE_DATA_REC_LEN, 0, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, cwtp, profile_percent, MLXSW_REG_CWTP_BASE_LEN,\n\t\t     24, 7, MLXSW_REG_CWTP_PROFILE_DATA_REC_LEN, 4, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, cwtp, profile_max, MLXSW_REG_CWTP_BASE_LEN,\n\t\t     0, 20, MLXSW_REG_CWTP_PROFILE_DATA_REC_LEN, 4, false);\n\n#define MLXSW_REG_CWTP_MIN_VALUE 64\n#define MLXSW_REG_CWTP_MAX_PROFILE 2\n#define MLXSW_REG_CWTP_DEFAULT_PROFILE 1\n\nstatic inline void mlxsw_reg_cwtp_pack(char *payload, u16 local_port,\n\t\t\t\t       u8 traffic_class)\n{\n\tint i;\n\n\tMLXSW_REG_ZERO(cwtp, payload);\n\tmlxsw_reg_cwtp_local_port_set(payload, local_port);\n\tmlxsw_reg_cwtp_traffic_class_set(payload, traffic_class);\n\n\tfor (i = 0; i <= MLXSW_REG_CWTP_MAX_PROFILE; i++) {\n\t\tmlxsw_reg_cwtp_profile_min_set(payload, i,\n\t\t\t\t\t       MLXSW_REG_CWTP_MIN_VALUE);\n\t\tmlxsw_reg_cwtp_profile_max_set(payload, i,\n\t\t\t\t\t       MLXSW_REG_CWTP_MIN_VALUE);\n\t}\n}\n\n#define MLXSW_REG_CWTP_PROFILE_TO_INDEX(profile) (profile - 1)\n\nstatic inline void\nmlxsw_reg_cwtp_profile_pack(char *payload, u8 profile, u32 min, u32 max,\n\t\t\t    u32 probability)\n{\n\tu8 index = MLXSW_REG_CWTP_PROFILE_TO_INDEX(profile);\n\n\tmlxsw_reg_cwtp_profile_min_set(payload, index, min);\n\tmlxsw_reg_cwtp_profile_max_set(payload, index, max);\n\tmlxsw_reg_cwtp_profile_percent_set(payload, index, probability);\n}\n\n \n#define MLXSW_REG_CWTPM_ID 0x2803\n#define MLXSW_REG_CWTPM_LEN 0x44\n\nMLXSW_REG_DEFINE(cwtpm, MLXSW_REG_CWTPM_ID, MLXSW_REG_CWTPM_LEN);\n\n \nMLXSW_ITEM32_LP(reg, cwtpm, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, cwtpm, traffic_class, 32, 0, 8);\n\n \nMLXSW_ITEM32(reg, cwtpm, ew, 36, 1, 1);\n\n \nMLXSW_ITEM32(reg, cwtpm, ee, 36, 0, 1);\n\n \nMLXSW_ITEM32(reg, cwtpm, tcp_g, 52, 0, 2);\n\n \nMLXSW_ITEM32(reg, cwtpm, tcp_y, 56, 16, 2);\n\n \nMLXSW_ITEM32(reg, cwtpm, tcp_r, 56, 0, 2);\n\n \nMLXSW_ITEM32(reg, cwtpm, ntcp_g, 60, 0, 2);\n\n \nMLXSW_ITEM32(reg, cwtpm, ntcp_y, 64, 16, 2);\n\n \nMLXSW_ITEM32(reg, cwtpm, ntcp_r, 64, 0, 2);\n\n#define MLXSW_REG_CWTPM_RESET_PROFILE 0\n\nstatic inline void mlxsw_reg_cwtpm_pack(char *payload, u16 local_port,\n\t\t\t\t\tu8 traffic_class, u8 profile,\n\t\t\t\t\tbool wred, bool ecn)\n{\n\tMLXSW_REG_ZERO(cwtpm, payload);\n\tmlxsw_reg_cwtpm_local_port_set(payload, local_port);\n\tmlxsw_reg_cwtpm_traffic_class_set(payload, traffic_class);\n\tmlxsw_reg_cwtpm_ew_set(payload, wred);\n\tmlxsw_reg_cwtpm_ee_set(payload, ecn);\n\tmlxsw_reg_cwtpm_tcp_g_set(payload, profile);\n\tmlxsw_reg_cwtpm_tcp_y_set(payload, profile);\n\tmlxsw_reg_cwtpm_tcp_r_set(payload, profile);\n\tmlxsw_reg_cwtpm_ntcp_g_set(payload, profile);\n\tmlxsw_reg_cwtpm_ntcp_y_set(payload, profile);\n\tmlxsw_reg_cwtpm_ntcp_r_set(payload, profile);\n}\n\n \n#define MLXSW_REG_PGCR_ID 0x3001\n#define MLXSW_REG_PGCR_LEN 0x20\n\nMLXSW_REG_DEFINE(pgcr, MLXSW_REG_PGCR_ID, MLXSW_REG_PGCR_LEN);\n\n \nMLXSW_ITEM32(reg, pgcr, default_action_pointer_base, 0x1C, 0, 24);\n\nstatic inline void mlxsw_reg_pgcr_pack(char *payload, u32 pointer_base)\n{\n\tMLXSW_REG_ZERO(pgcr, payload);\n\tmlxsw_reg_pgcr_default_action_pointer_base_set(payload, pointer_base);\n}\n\n \n#define MLXSW_REG_PPBT_ID 0x3002\n#define MLXSW_REG_PPBT_LEN 0x14\n\nMLXSW_REG_DEFINE(ppbt, MLXSW_REG_PPBT_ID, MLXSW_REG_PPBT_LEN);\n\nenum mlxsw_reg_pxbt_e {\n\tMLXSW_REG_PXBT_E_IACL,\n\tMLXSW_REG_PXBT_E_EACL,\n};\n\n \nMLXSW_ITEM32(reg, ppbt, e, 0x00, 31, 1);\n\nenum mlxsw_reg_pxbt_op {\n\tMLXSW_REG_PXBT_OP_BIND,\n\tMLXSW_REG_PXBT_OP_UNBIND,\n};\n\n \nMLXSW_ITEM32(reg, ppbt, op, 0x00, 28, 3);\n\n \nMLXSW_ITEM32_LP(reg, ppbt, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, ppbt, g, 0x10, 31, 1);\n\n \nMLXSW_ITEM32(reg, ppbt, acl_info, 0x10, 0, 16);\n\nstatic inline void mlxsw_reg_ppbt_pack(char *payload, enum mlxsw_reg_pxbt_e e,\n\t\t\t\t       enum mlxsw_reg_pxbt_op op,\n\t\t\t\t       u16 local_port, u16 acl_info)\n{\n\tMLXSW_REG_ZERO(ppbt, payload);\n\tmlxsw_reg_ppbt_e_set(payload, e);\n\tmlxsw_reg_ppbt_op_set(payload, op);\n\tmlxsw_reg_ppbt_local_port_set(payload, local_port);\n\tmlxsw_reg_ppbt_g_set(payload, true);\n\tmlxsw_reg_ppbt_acl_info_set(payload, acl_info);\n}\n\n \n#define MLXSW_REG_PACL_ID 0x3004\n#define MLXSW_REG_PACL_LEN 0x70\n\nMLXSW_REG_DEFINE(pacl, MLXSW_REG_PACL_ID, MLXSW_REG_PACL_LEN);\n\n \nMLXSW_ITEM32(reg, pacl, v, 0x00, 24, 1);\n\n \nMLXSW_ITEM32(reg, pacl, acl_id, 0x08, 0, 16);\n\n#define MLXSW_REG_PXXX_TCAM_REGION_INFO_LEN 16\n\n \nMLXSW_ITEM_BUF(reg, pacl, tcam_region_info, 0x30,\n\t       MLXSW_REG_PXXX_TCAM_REGION_INFO_LEN);\n\nstatic inline void mlxsw_reg_pacl_pack(char *payload, u16 acl_id,\n\t\t\t\t       bool valid, const char *tcam_region_info)\n{\n\tMLXSW_REG_ZERO(pacl, payload);\n\tmlxsw_reg_pacl_acl_id_set(payload, acl_id);\n\tmlxsw_reg_pacl_v_set(payload, valid);\n\tmlxsw_reg_pacl_tcam_region_info_memcpy_to(payload, tcam_region_info);\n}\n\n \n#define MLXSW_REG_PAGT_ID 0x3005\n#define MLXSW_REG_PAGT_BASE_LEN 0x30\n#define MLXSW_REG_PAGT_ACL_LEN 4\n#define MLXSW_REG_PAGT_ACL_MAX_NUM 16\n#define MLXSW_REG_PAGT_LEN (MLXSW_REG_PAGT_BASE_LEN + \\\n\t\tMLXSW_REG_PAGT_ACL_MAX_NUM * MLXSW_REG_PAGT_ACL_LEN)\n\nMLXSW_REG_DEFINE(pagt, MLXSW_REG_PAGT_ID, MLXSW_REG_PAGT_LEN);\n\n \nMLXSW_ITEM32(reg, pagt, size, 0x00, 0, 8);\n\n \nMLXSW_ITEM32(reg, pagt, acl_group_id, 0x08, 0, 16);\n\n \nMLXSW_ITEM32_INDEXED(reg, pagt, multi, 0x30, 31, 1, 0x04, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, pagt, acl_id, 0x30, 0, 16, 0x04, 0x00, false);\n\nstatic inline void mlxsw_reg_pagt_pack(char *payload, u16 acl_group_id)\n{\n\tMLXSW_REG_ZERO(pagt, payload);\n\tmlxsw_reg_pagt_acl_group_id_set(payload, acl_group_id);\n}\n\nstatic inline void mlxsw_reg_pagt_acl_id_pack(char *payload, int index,\n\t\t\t\t\t      u16 acl_id, bool multi)\n{\n\tu8 size = mlxsw_reg_pagt_size_get(payload);\n\n\tif (index >= size)\n\t\tmlxsw_reg_pagt_size_set(payload, index + 1);\n\tmlxsw_reg_pagt_multi_set(payload, index, multi);\n\tmlxsw_reg_pagt_acl_id_set(payload, index, acl_id);\n}\n\n \n#define MLXSW_REG_PTAR_ID 0x3006\n#define MLXSW_REG_PTAR_BASE_LEN 0x20\n#define MLXSW_REG_PTAR_KEY_ID_LEN 1\n#define MLXSW_REG_PTAR_KEY_ID_MAX_NUM 16\n#define MLXSW_REG_PTAR_LEN (MLXSW_REG_PTAR_BASE_LEN + \\\n\t\tMLXSW_REG_PTAR_KEY_ID_MAX_NUM * MLXSW_REG_PTAR_KEY_ID_LEN)\n\nMLXSW_REG_DEFINE(ptar, MLXSW_REG_PTAR_ID, MLXSW_REG_PTAR_LEN);\n\nenum mlxsw_reg_ptar_op {\n\t \n\tMLXSW_REG_PTAR_OP_ALLOC,\n\t \n\tMLXSW_REG_PTAR_OP_RESIZE,\n\t \n\tMLXSW_REG_PTAR_OP_FREE,\n\t \n\tMLXSW_REG_PTAR_OP_TEST,\n};\n\n \nMLXSW_ITEM32(reg, ptar, op, 0x00, 28, 4);\n\n \nMLXSW_ITEM32(reg, ptar, action_set_type, 0x00, 16, 8);\n\nenum mlxsw_reg_ptar_key_type {\n\tMLXSW_REG_PTAR_KEY_TYPE_FLEX = 0x50,  \n\tMLXSW_REG_PTAR_KEY_TYPE_FLEX2 = 0x51,  \n};\n\n \nMLXSW_ITEM32(reg, ptar, key_type, 0x00, 0, 8);\n\n \nMLXSW_ITEM32(reg, ptar, region_size, 0x04, 0, 16);\n\n \nMLXSW_ITEM32(reg, ptar, region_id, 0x08, 0, 16);\n\n \nMLXSW_ITEM_BUF(reg, ptar, tcam_region_info, 0x10,\n\t       MLXSW_REG_PXXX_TCAM_REGION_INFO_LEN);\n\n \nMLXSW_ITEM8_INDEXED(reg, ptar, flexible_key_id, 0x20, 0, 8,\n\t\t    MLXSW_REG_PTAR_KEY_ID_LEN, 0x00, false);\n\nstatic inline void mlxsw_reg_ptar_pack(char *payload, enum mlxsw_reg_ptar_op op,\n\t\t\t\t       enum mlxsw_reg_ptar_key_type key_type,\n\t\t\t\t       u16 region_size, u16 region_id,\n\t\t\t\t       const char *tcam_region_info)\n{\n\tMLXSW_REG_ZERO(ptar, payload);\n\tmlxsw_reg_ptar_op_set(payload, op);\n\tmlxsw_reg_ptar_action_set_type_set(payload, 2);  \n\tmlxsw_reg_ptar_key_type_set(payload, key_type);\n\tmlxsw_reg_ptar_region_size_set(payload, region_size);\n\tmlxsw_reg_ptar_region_id_set(payload, region_id);\n\tmlxsw_reg_ptar_tcam_region_info_memcpy_to(payload, tcam_region_info);\n}\n\nstatic inline void mlxsw_reg_ptar_key_id_pack(char *payload, int index,\n\t\t\t\t\t      u16 key_id)\n{\n\tmlxsw_reg_ptar_flexible_key_id_set(payload, index, key_id);\n}\n\nstatic inline void mlxsw_reg_ptar_unpack(char *payload, char *tcam_region_info)\n{\n\tmlxsw_reg_ptar_tcam_region_info_memcpy_from(payload, tcam_region_info);\n}\n\n \n#define MLXSW_REG_PPRR_ID 0x3008\n#define MLXSW_REG_PPRR_LEN 0x14\n\nMLXSW_REG_DEFINE(pprr, MLXSW_REG_PPRR_ID, MLXSW_REG_PPRR_LEN);\n\n \nMLXSW_ITEM32(reg, pprr, ipv4, 0x00, 31, 1);\n\n \nMLXSW_ITEM32(reg, pprr, ipv6, 0x00, 30, 1);\n\n \nMLXSW_ITEM32(reg, pprr, src, 0x00, 29, 1);\n\n \nMLXSW_ITEM32(reg, pprr, dst, 0x00, 28, 1);\n\n \nMLXSW_ITEM32(reg, pprr, tcp, 0x00, 27, 1);\n\n \nMLXSW_ITEM32(reg, pprr, udp, 0x00, 26, 1);\n\n \nMLXSW_ITEM32(reg, pprr, register_index, 0x00, 0, 8);\n\n \nMLXSW_ITEM32(reg, pprr, port_range_min, 0x04, 16, 16);\n\n \nMLXSW_ITEM32(reg, pprr, port_range_max, 0x04, 0, 16);\n\nstatic inline void mlxsw_reg_pprr_pack(char *payload, u8 register_index)\n{\n\tMLXSW_REG_ZERO(pprr, payload);\n\tmlxsw_reg_pprr_register_index_set(payload, register_index);\n}\n\n \n#define MLXSW_REG_PPBS_ID 0x300C\n#define MLXSW_REG_PPBS_LEN 0x14\n\nMLXSW_REG_DEFINE(ppbs, MLXSW_REG_PPBS_ID, MLXSW_REG_PPBS_LEN);\n\n \nMLXSW_ITEM32(reg, ppbs, pbs_ptr, 0x08, 0, 24);\n\n \nMLXSW_ITEM32(reg, ppbs, system_port, 0x10, 0, 16);\n\nstatic inline void mlxsw_reg_ppbs_pack(char *payload, u32 pbs_ptr,\n\t\t\t\t       u16 system_port)\n{\n\tMLXSW_REG_ZERO(ppbs, payload);\n\tmlxsw_reg_ppbs_pbs_ptr_set(payload, pbs_ptr);\n\tmlxsw_reg_ppbs_system_port_set(payload, system_port);\n}\n\n \n#define MLXSW_REG_PRCR_ID 0x300D\n#define MLXSW_REG_PRCR_LEN 0x40\n\nMLXSW_REG_DEFINE(prcr, MLXSW_REG_PRCR_ID, MLXSW_REG_PRCR_LEN);\n\nenum mlxsw_reg_prcr_op {\n\t \n\tMLXSW_REG_PRCR_OP_MOVE,\n\t \n\tMLXSW_REG_PRCR_OP_COPY,\n};\n\n \nMLXSW_ITEM32(reg, prcr, op, 0x00, 28, 4);\n\n \nMLXSW_ITEM32(reg, prcr, offset, 0x00, 0, 16);\n\n \nMLXSW_ITEM32(reg, prcr, size, 0x04, 0, 16);\n\n \nMLXSW_ITEM_BUF(reg, prcr, tcam_region_info, 0x10,\n\t       MLXSW_REG_PXXX_TCAM_REGION_INFO_LEN);\n\n \nMLXSW_ITEM32(reg, prcr, dest_offset, 0x20, 0, 16);\n\n \nMLXSW_ITEM_BUF(reg, prcr, dest_tcam_region_info, 0x30,\n\t       MLXSW_REG_PXXX_TCAM_REGION_INFO_LEN);\n\nstatic inline void mlxsw_reg_prcr_pack(char *payload, enum mlxsw_reg_prcr_op op,\n\t\t\t\t       const char *src_tcam_region_info,\n\t\t\t\t       u16 src_offset,\n\t\t\t\t       const char *dest_tcam_region_info,\n\t\t\t\t       u16 dest_offset, u16 size)\n{\n\tMLXSW_REG_ZERO(prcr, payload);\n\tmlxsw_reg_prcr_op_set(payload, op);\n\tmlxsw_reg_prcr_offset_set(payload, src_offset);\n\tmlxsw_reg_prcr_size_set(payload, size);\n\tmlxsw_reg_prcr_tcam_region_info_memcpy_to(payload,\n\t\t\t\t\t\t  src_tcam_region_info);\n\tmlxsw_reg_prcr_dest_offset_set(payload, dest_offset);\n\tmlxsw_reg_prcr_dest_tcam_region_info_memcpy_to(payload,\n\t\t\t\t\t\t       dest_tcam_region_info);\n}\n\n \n#define MLXSW_REG_PEFA_ID 0x300F\n#define MLXSW_REG_PEFA_LEN 0xB0\n\nMLXSW_REG_DEFINE(pefa, MLXSW_REG_PEFA_ID, MLXSW_REG_PEFA_LEN);\n\n \nMLXSW_ITEM32(reg, pefa, index, 0x00, 0, 24);\n\n \nMLXSW_ITEM32(reg, pefa, a, 0x04, 29, 1);\n\n \nMLXSW_ITEM32(reg, pefa, ca, 0x04, 24, 1);\n\n#define MLXSW_REG_FLEX_ACTION_SET_LEN 0xA8\n\n \nMLXSW_ITEM_BUF(reg, pefa, flex_action_set, 0x08, MLXSW_REG_FLEX_ACTION_SET_LEN);\n\nstatic inline void mlxsw_reg_pefa_pack(char *payload, u32 index, bool ca,\n\t\t\t\t       const char *flex_action_set)\n{\n\tMLXSW_REG_ZERO(pefa, payload);\n\tmlxsw_reg_pefa_index_set(payload, index);\n\tmlxsw_reg_pefa_ca_set(payload, ca);\n\tif (flex_action_set)\n\t\tmlxsw_reg_pefa_flex_action_set_memcpy_to(payload,\n\t\t\t\t\t\t\t flex_action_set);\n}\n\nstatic inline void mlxsw_reg_pefa_unpack(char *payload, bool *p_a)\n{\n\t*p_a = mlxsw_reg_pefa_a_get(payload);\n}\n\n \n#define MLXSW_REG_PEMRBT_ID 0x3014\n#define MLXSW_REG_PEMRBT_LEN 0x14\n\nMLXSW_REG_DEFINE(pemrbt, MLXSW_REG_PEMRBT_ID, MLXSW_REG_PEMRBT_LEN);\n\nenum mlxsw_reg_pemrbt_protocol {\n\tMLXSW_REG_PEMRBT_PROTO_IPV4,\n\tMLXSW_REG_PEMRBT_PROTO_IPV6,\n};\n\n \nMLXSW_ITEM32(reg, pemrbt, protocol, 0x00, 0, 1);\n\n \nMLXSW_ITEM32(reg, pemrbt, group_id, 0x10, 0, 16);\n\nstatic inline void\nmlxsw_reg_pemrbt_pack(char *payload, enum mlxsw_reg_pemrbt_protocol protocol,\n\t\t      u16 group_id)\n{\n\tMLXSW_REG_ZERO(pemrbt, payload);\n\tmlxsw_reg_pemrbt_protocol_set(payload, protocol);\n\tmlxsw_reg_pemrbt_group_id_set(payload, group_id);\n}\n\n \n#define MLXSW_REG_PTCE2_ID 0x3017\n#define MLXSW_REG_PTCE2_LEN 0x1D8\n\nMLXSW_REG_DEFINE(ptce2, MLXSW_REG_PTCE2_ID, MLXSW_REG_PTCE2_LEN);\n\n \nMLXSW_ITEM32(reg, ptce2, v, 0x00, 31, 1);\n\n \nMLXSW_ITEM32(reg, ptce2, a, 0x00, 30, 1);\n\nenum mlxsw_reg_ptce2_op {\n\t \n\tMLXSW_REG_PTCE2_OP_QUERY_READ = 0,\n\t \n\tMLXSW_REG_PTCE2_OP_QUERY_CLEAR_ON_READ = 1,\n\t \n\tMLXSW_REG_PTCE2_OP_WRITE_WRITE = 0,\n\t \n\tMLXSW_REG_PTCE2_OP_WRITE_UPDATE = 1,\n\t \n\tMLXSW_REG_PTCE2_OP_WRITE_CLEAR_ACTIVITY = 2,\n};\n\n \nMLXSW_ITEM32(reg, ptce2, op, 0x00, 20, 3);\n\n \nMLXSW_ITEM32(reg, ptce2, offset, 0x00, 0, 16);\n\n \nMLXSW_ITEM32(reg, ptce2, priority, 0x04, 0, 24);\n\n \nMLXSW_ITEM_BUF(reg, ptce2, tcam_region_info, 0x10,\n\t       MLXSW_REG_PXXX_TCAM_REGION_INFO_LEN);\n\n#define MLXSW_REG_PTCEX_FLEX_KEY_BLOCKS_LEN 96\n\n \nMLXSW_ITEM_BUF(reg, ptce2, flex_key_blocks, 0x20,\n\t       MLXSW_REG_PTCEX_FLEX_KEY_BLOCKS_LEN);\n\n \nMLXSW_ITEM_BUF(reg, ptce2, mask, 0x80,\n\t       MLXSW_REG_PTCEX_FLEX_KEY_BLOCKS_LEN);\n\n \nMLXSW_ITEM_BUF(reg, ptce2, flex_action_set, 0xE0,\n\t       MLXSW_REG_FLEX_ACTION_SET_LEN);\n\nstatic inline void mlxsw_reg_ptce2_pack(char *payload, bool valid,\n\t\t\t\t\tenum mlxsw_reg_ptce2_op op,\n\t\t\t\t\tconst char *tcam_region_info,\n\t\t\t\t\tu16 offset, u32 priority)\n{\n\tMLXSW_REG_ZERO(ptce2, payload);\n\tmlxsw_reg_ptce2_v_set(payload, valid);\n\tmlxsw_reg_ptce2_op_set(payload, op);\n\tmlxsw_reg_ptce2_offset_set(payload, offset);\n\tmlxsw_reg_ptce2_priority_set(payload, priority);\n\tmlxsw_reg_ptce2_tcam_region_info_memcpy_to(payload, tcam_region_info);\n}\n\n \n#define MLXSW_REG_PERPT_ID 0x3021\n#define MLXSW_REG_PERPT_LEN 0x80\n\nMLXSW_REG_DEFINE(perpt, MLXSW_REG_PERPT_ID, MLXSW_REG_PERPT_LEN);\n\n \nMLXSW_ITEM32(reg, perpt, erpt_bank, 0x00, 16, 4);\n\n \nMLXSW_ITEM32(reg, perpt, erpt_index, 0x00, 0, 8);\n\nenum mlxsw_reg_perpt_key_size {\n\tMLXSW_REG_PERPT_KEY_SIZE_2KB,\n\tMLXSW_REG_PERPT_KEY_SIZE_4KB,\n\tMLXSW_REG_PERPT_KEY_SIZE_8KB,\n\tMLXSW_REG_PERPT_KEY_SIZE_12KB,\n};\n\n \nMLXSW_ITEM32(reg, perpt, key_size, 0x04, 0, 4);\n\n \nMLXSW_ITEM32(reg, perpt, bf_bypass, 0x08, 8, 1);\n\n \nMLXSW_ITEM32(reg, perpt, erp_id, 0x08, 0, 4);\n\n \nMLXSW_ITEM32(reg, perpt, erpt_base_bank, 0x0C, 16, 4);\n\n \nMLXSW_ITEM32(reg, perpt, erpt_base_index, 0x0C, 0, 8);\n\n \nMLXSW_ITEM32(reg, perpt, erp_index_in_vector, 0x10, 0, 4);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, perpt, erp_vector, 0x14, 4, 1);\n\n \nMLXSW_ITEM_BUF(reg, perpt, mask, 0x20, MLXSW_REG_PTCEX_FLEX_KEY_BLOCKS_LEN);\n\nstatic inline void mlxsw_reg_perpt_erp_vector_pack(char *payload,\n\t\t\t\t\t\t   unsigned long *erp_vector,\n\t\t\t\t\t\t   unsigned long size)\n{\n\tunsigned long bit;\n\n\tfor_each_set_bit(bit, erp_vector, size)\n\t\tmlxsw_reg_perpt_erp_vector_set(payload, bit, true);\n}\n\nstatic inline void\nmlxsw_reg_perpt_pack(char *payload, u8 erpt_bank, u8 erpt_index,\n\t\t     enum mlxsw_reg_perpt_key_size key_size, u8 erp_id,\n\t\t     u8 erpt_base_bank, u8 erpt_base_index, u8 erp_index,\n\t\t     char *mask)\n{\n\tMLXSW_REG_ZERO(perpt, payload);\n\tmlxsw_reg_perpt_erpt_bank_set(payload, erpt_bank);\n\tmlxsw_reg_perpt_erpt_index_set(payload, erpt_index);\n\tmlxsw_reg_perpt_key_size_set(payload, key_size);\n\tmlxsw_reg_perpt_bf_bypass_set(payload, false);\n\tmlxsw_reg_perpt_erp_id_set(payload, erp_id);\n\tmlxsw_reg_perpt_erpt_base_bank_set(payload, erpt_base_bank);\n\tmlxsw_reg_perpt_erpt_base_index_set(payload, erpt_base_index);\n\tmlxsw_reg_perpt_erp_index_in_vector_set(payload, erp_index);\n\tmlxsw_reg_perpt_mask_memcpy_to(payload, mask);\n}\n\n \n#define MLXSW_REG_PERAR_ID 0x3026\n#define MLXSW_REG_PERAR_LEN 0x08\n\nMLXSW_REG_DEFINE(perar, MLXSW_REG_PERAR_ID, MLXSW_REG_PERAR_LEN);\n\n \nMLXSW_ITEM32(reg, perar, region_id, 0x00, 0, 16);\n\nstatic inline unsigned int\nmlxsw_reg_perar_hw_regions_needed(unsigned int block_num)\n{\n\treturn DIV_ROUND_UP(block_num, 4);\n}\n\n \nMLXSW_ITEM32(reg, perar, hw_region, 0x04, 0, 16);\n\nstatic inline void mlxsw_reg_perar_pack(char *payload, u16 region_id,\n\t\t\t\t\tu16 hw_region)\n{\n\tMLXSW_REG_ZERO(perar, payload);\n\tmlxsw_reg_perar_region_id_set(payload, region_id);\n\tmlxsw_reg_perar_hw_region_set(payload, hw_region);\n}\n\n \n#define MLXSW_REG_PTCE3_ID 0x3027\n#define MLXSW_REG_PTCE3_LEN 0xF0\n\nMLXSW_REG_DEFINE(ptce3, MLXSW_REG_PTCE3_ID, MLXSW_REG_PTCE3_LEN);\n\n \nMLXSW_ITEM32(reg, ptce3, v, 0x00, 31, 1);\n\nenum mlxsw_reg_ptce3_op {\n\t \n\t MLXSW_REG_PTCE3_OP_WRITE_WRITE = 0,\n\t  \n\t MLXSW_REG_PTCE3_OP_WRITE_UPDATE = 1,\n\t  \n\t MLXSW_REG_PTCE3_OP_QUERY_READ = 0,\n};\n\n \nMLXSW_ITEM32(reg, ptce3, op, 0x00, 20, 3);\n\n \nMLXSW_ITEM32(reg, ptce3, priority, 0x04, 0, 24);\n\n \nMLXSW_ITEM_BUF(reg, ptce3, tcam_region_info, 0x10,\n\t       MLXSW_REG_PXXX_TCAM_REGION_INFO_LEN);\n\n \nMLXSW_ITEM_BUF(reg, ptce3, flex2_key_blocks, 0x20,\n\t       MLXSW_REG_PTCEX_FLEX_KEY_BLOCKS_LEN);\n\n \nMLXSW_ITEM32(reg, ptce3, erp_id, 0x80, 0, 4);\n\n \nMLXSW_ITEM32(reg, ptce3, delta_start, 0x84, 0, 10);\n\n \nMLXSW_ITEM32(reg, ptce3, delta_mask, 0x88, 16, 8);\n\n \nMLXSW_ITEM32(reg, ptce3, delta_value, 0x88, 0, 8);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, ptce3, prune_vector, 0x90, 4, 1);\n\n \nMLXSW_ITEM32(reg, ptce3, prune_ctcam, 0x94, 31, 1);\n\n \nMLXSW_ITEM32(reg, ptce3, large_exists, 0x98, 31, 1);\n\n \nMLXSW_ITEM32(reg, ptce3, large_entry_key_id, 0x98, 0, 24);\n\n \nMLXSW_ITEM32(reg, ptce3, action_pointer, 0xA0, 0, 24);\n\nstatic inline void mlxsw_reg_ptce3_pack(char *payload, bool valid,\n\t\t\t\t\tenum mlxsw_reg_ptce3_op op,\n\t\t\t\t\tu32 priority,\n\t\t\t\t\tconst char *tcam_region_info,\n\t\t\t\t\tconst char *key, u8 erp_id,\n\t\t\t\t\tu16 delta_start, u8 delta_mask,\n\t\t\t\t\tu8 delta_value, bool large_exists,\n\t\t\t\t\tu32 lkey_id, u32 action_pointer)\n{\n\tMLXSW_REG_ZERO(ptce3, payload);\n\tmlxsw_reg_ptce3_v_set(payload, valid);\n\tmlxsw_reg_ptce3_op_set(payload, op);\n\tmlxsw_reg_ptce3_priority_set(payload, priority);\n\tmlxsw_reg_ptce3_tcam_region_info_memcpy_to(payload, tcam_region_info);\n\tmlxsw_reg_ptce3_flex2_key_blocks_memcpy_to(payload, key);\n\tmlxsw_reg_ptce3_erp_id_set(payload, erp_id);\n\tmlxsw_reg_ptce3_delta_start_set(payload, delta_start);\n\tmlxsw_reg_ptce3_delta_mask_set(payload, delta_mask);\n\tmlxsw_reg_ptce3_delta_value_set(payload, delta_value);\n\tmlxsw_reg_ptce3_large_exists_set(payload, large_exists);\n\tmlxsw_reg_ptce3_large_entry_key_id_set(payload, lkey_id);\n\tmlxsw_reg_ptce3_action_pointer_set(payload, action_pointer);\n}\n\n \n#define MLXSW_REG_PERCR_ID 0x302A\n#define MLXSW_REG_PERCR_LEN 0x80\n\nMLXSW_REG_DEFINE(percr, MLXSW_REG_PERCR_ID, MLXSW_REG_PERCR_LEN);\n\n \nMLXSW_ITEM32(reg, percr, region_id, 0x00, 0, 16);\n\n \nMLXSW_ITEM32(reg, percr, atcam_ignore_prune, 0x04, 25, 1);\n\n \nMLXSW_ITEM32(reg, percr, ctcam_ignore_prune, 0x04, 24, 1);\n\n \nMLXSW_ITEM32(reg, percr, bf_bypass, 0x04, 16, 1);\n\n \nMLXSW_ITEM_BUF(reg, percr, master_mask, 0x20, 96);\n\nstatic inline void mlxsw_reg_percr_pack(char *payload, u16 region_id)\n{\n\tMLXSW_REG_ZERO(percr, payload);\n\tmlxsw_reg_percr_region_id_set(payload, region_id);\n\tmlxsw_reg_percr_atcam_ignore_prune_set(payload, false);\n\tmlxsw_reg_percr_ctcam_ignore_prune_set(payload, false);\n\tmlxsw_reg_percr_bf_bypass_set(payload, false);\n}\n\n \n#define MLXSW_REG_PERERP_ID 0x302B\n#define MLXSW_REG_PERERP_LEN 0x1C\n\nMLXSW_REG_DEFINE(pererp, MLXSW_REG_PERERP_ID, MLXSW_REG_PERERP_LEN);\n\n \nMLXSW_ITEM32(reg, pererp, region_id, 0x00, 0, 16);\n\n \nMLXSW_ITEM32(reg, pererp, ctcam_le, 0x04, 28, 1);\n\n \nMLXSW_ITEM32(reg, pererp, erpt_pointer_valid, 0x10, 31, 1);\n\n \nMLXSW_ITEM32(reg, pererp, erpt_bank_pointer, 0x10, 16, 4);\n\n \nMLXSW_ITEM32(reg, pererp, erpt_pointer, 0x10, 0, 8);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, pererp, erpt_vector, 0x14, 4, 1);\n\n \nMLXSW_ITEM32(reg, pererp, master_rp_id, 0x18, 0, 4);\n\nstatic inline void mlxsw_reg_pererp_erp_vector_pack(char *payload,\n\t\t\t\t\t\t    unsigned long *erp_vector,\n\t\t\t\t\t\t    unsigned long size)\n{\n\tunsigned long bit;\n\n\tfor_each_set_bit(bit, erp_vector, size)\n\t\tmlxsw_reg_pererp_erpt_vector_set(payload, bit, true);\n}\n\nstatic inline void mlxsw_reg_pererp_pack(char *payload, u16 region_id,\n\t\t\t\t\t bool ctcam_le, bool erpt_pointer_valid,\n\t\t\t\t\t u8 erpt_bank_pointer, u8 erpt_pointer,\n\t\t\t\t\t u8 master_rp_id)\n{\n\tMLXSW_REG_ZERO(pererp, payload);\n\tmlxsw_reg_pererp_region_id_set(payload, region_id);\n\tmlxsw_reg_pererp_ctcam_le_set(payload, ctcam_le);\n\tmlxsw_reg_pererp_erpt_pointer_valid_set(payload, erpt_pointer_valid);\n\tmlxsw_reg_pererp_erpt_bank_pointer_set(payload, erpt_bank_pointer);\n\tmlxsw_reg_pererp_erpt_pointer_set(payload, erpt_pointer);\n\tmlxsw_reg_pererp_master_rp_id_set(payload, master_rp_id);\n}\n\n \n#define MLXSW_REG_PEABFE_ID 0x3022\n#define MLXSW_REG_PEABFE_BASE_LEN 0x10\n#define MLXSW_REG_PEABFE_BF_REC_LEN 0x4\n#define MLXSW_REG_PEABFE_BF_REC_MAX_COUNT 256\n#define MLXSW_REG_PEABFE_LEN (MLXSW_REG_PEABFE_BASE_LEN + \\\n\t\t\t      MLXSW_REG_PEABFE_BF_REC_LEN * \\\n\t\t\t      MLXSW_REG_PEABFE_BF_REC_MAX_COUNT)\n\nMLXSW_REG_DEFINE(peabfe, MLXSW_REG_PEABFE_ID, MLXSW_REG_PEABFE_LEN);\n\n \nMLXSW_ITEM32(reg, peabfe, size, 0x00, 0, 9);\n\n \nMLXSW_ITEM32_INDEXED(reg, peabfe, bf_entry_state,\n\t\t     MLXSW_REG_PEABFE_BASE_LEN,\t31, 1,\n\t\t     MLXSW_REG_PEABFE_BF_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, peabfe, bf_entry_bank,\n\t\t     MLXSW_REG_PEABFE_BASE_LEN,\t24, 4,\n\t\t     MLXSW_REG_PEABFE_BF_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, peabfe, bf_entry_index,\n\t\t     MLXSW_REG_PEABFE_BASE_LEN,\t0, 24,\n\t\t     MLXSW_REG_PEABFE_BF_REC_LEN, 0x00, false);\n\nstatic inline void mlxsw_reg_peabfe_pack(char *payload)\n{\n\tMLXSW_REG_ZERO(peabfe, payload);\n}\n\nstatic inline void mlxsw_reg_peabfe_rec_pack(char *payload, int rec_index,\n\t\t\t\t\t     u8 state, u8 bank, u32 bf_index)\n{\n\tu8 num_rec = mlxsw_reg_peabfe_size_get(payload);\n\n\tif (rec_index >= num_rec)\n\t\tmlxsw_reg_peabfe_size_set(payload, rec_index + 1);\n\tmlxsw_reg_peabfe_bf_entry_state_set(payload, rec_index, state);\n\tmlxsw_reg_peabfe_bf_entry_bank_set(payload, rec_index, bank);\n\tmlxsw_reg_peabfe_bf_entry_index_set(payload, rec_index, bf_index);\n}\n\n \n#define MLXSW_REG_IEDR_ID 0x3804\n#define MLXSW_REG_IEDR_BASE_LEN 0x10  \n#define MLXSW_REG_IEDR_REC_LEN 0x8  \n#define MLXSW_REG_IEDR_REC_MAX_COUNT 64\n#define MLXSW_REG_IEDR_LEN (MLXSW_REG_IEDR_BASE_LEN +\t\\\n\t\t\t    MLXSW_REG_IEDR_REC_LEN *\t\\\n\t\t\t    MLXSW_REG_IEDR_REC_MAX_COUNT)\n\nMLXSW_REG_DEFINE(iedr, MLXSW_REG_IEDR_ID, MLXSW_REG_IEDR_LEN);\n\n \nMLXSW_ITEM32(reg, iedr, num_rec, 0x00, 0, 8);\n\n \nMLXSW_ITEM32_INDEXED(reg, iedr, rec_type, MLXSW_REG_IEDR_BASE_LEN, 24, 8,\n\t\t     MLXSW_REG_IEDR_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, iedr, rec_size, MLXSW_REG_IEDR_BASE_LEN, 0, 13,\n\t\t     MLXSW_REG_IEDR_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, iedr, rec_index_start, MLXSW_REG_IEDR_BASE_LEN, 0, 24,\n\t\t     MLXSW_REG_IEDR_REC_LEN, 0x04, false);\n\nstatic inline void mlxsw_reg_iedr_pack(char *payload)\n{\n\tMLXSW_REG_ZERO(iedr, payload);\n}\n\nstatic inline void mlxsw_reg_iedr_rec_pack(char *payload, int rec_index,\n\t\t\t\t\t   u8 rec_type, u16 rec_size,\n\t\t\t\t\t   u32 rec_index_start)\n{\n\tu8 num_rec = mlxsw_reg_iedr_num_rec_get(payload);\n\n\tif (rec_index >= num_rec)\n\t\tmlxsw_reg_iedr_num_rec_set(payload, rec_index + 1);\n\tmlxsw_reg_iedr_rec_type_set(payload, rec_index, rec_type);\n\tmlxsw_reg_iedr_rec_size_set(payload, rec_index, rec_size);\n\tmlxsw_reg_iedr_rec_index_start_set(payload, rec_index, rec_index_start);\n}\n\n \n#define MLXSW_REG_QPTS_ID 0x4002\n#define MLXSW_REG_QPTS_LEN 0x8\n\nMLXSW_REG_DEFINE(qpts, MLXSW_REG_QPTS_ID, MLXSW_REG_QPTS_LEN);\n\n \nMLXSW_ITEM32_LP(reg, qpts, 0x00, 16, 0x00, 12);\n\nenum mlxsw_reg_qpts_trust_state {\n\tMLXSW_REG_QPTS_TRUST_STATE_PCP = 1,\n\tMLXSW_REG_QPTS_TRUST_STATE_DSCP = 2,  \n};\n\n \nMLXSW_ITEM32(reg, qpts, trust_state, 0x04, 0, 3);\n\nstatic inline void mlxsw_reg_qpts_pack(char *payload, u16 local_port,\n\t\t\t\t       enum mlxsw_reg_qpts_trust_state ts)\n{\n\tMLXSW_REG_ZERO(qpts, payload);\n\n\tmlxsw_reg_qpts_local_port_set(payload, local_port);\n\tmlxsw_reg_qpts_trust_state_set(payload, ts);\n}\n\n \n#define MLXSW_REG_QPCR_ID 0x4004\n#define MLXSW_REG_QPCR_LEN 0x28\n\nMLXSW_REG_DEFINE(qpcr, MLXSW_REG_QPCR_ID, MLXSW_REG_QPCR_LEN);\n\nenum mlxsw_reg_qpcr_g {\n\tMLXSW_REG_QPCR_G_GLOBAL = 2,\n\tMLXSW_REG_QPCR_G_STORM_CONTROL = 3,\n};\n\n \nMLXSW_ITEM32(reg, qpcr, g, 0x00, 14, 2);\n\n \nMLXSW_ITEM32(reg, qpcr, pid, 0x00, 0, 14);\n\n \nMLXSW_ITEM32(reg, qpcr, clear_counter, 0x04, 31, 1);\n\n \nMLXSW_ITEM32(reg, qpcr, color_aware, 0x04, 15, 1);\n\n \nMLXSW_ITEM32(reg, qpcr, bytes, 0x04, 14, 1);\n\nenum mlxsw_reg_qpcr_ir_units {\n\tMLXSW_REG_QPCR_IR_UNITS_M,\n\tMLXSW_REG_QPCR_IR_UNITS_K,\n};\n\n \nMLXSW_ITEM32(reg, qpcr, ir_units, 0x04, 12, 1);\n\nenum mlxsw_reg_qpcr_rate_type {\n\tMLXSW_REG_QPCR_RATE_TYPE_SINGLE = 1,\n\tMLXSW_REG_QPCR_RATE_TYPE_DOUBLE = 2,\n};\n\n \nMLXSW_ITEM32(reg, qpcr, rate_type, 0x04, 8, 2);\n\n \nMLXSW_ITEM32(reg, qpcr, cbs, 0x08, 24, 6);\n\n \nMLXSW_ITEM32(reg, qpcr, cir, 0x0C, 0, 32);\n\n \nMLXSW_ITEM32(reg, qpcr, eir, 0x10, 0, 32);\n\n#define MLXSW_REG_QPCR_DOUBLE_RATE_ACTION 2\n\n \nMLXSW_ITEM32(reg, qpcr, exceed_action, 0x14, 0, 4);\n\nenum mlxsw_reg_qpcr_action {\n\t \n\tMLXSW_REG_QPCR_ACTION_DISCARD = 1,\n\t \n\tMLXSW_REG_QPCR_ACTION_FORWARD = 2,\n};\n\n \nMLXSW_ITEM32(reg, qpcr, violate_action, 0x18, 0, 4);\n\n \nMLXSW_ITEM64(reg, qpcr, violate_count, 0x20, 0, 64);\n\n \n#define MLXSW_REG_QPCR_LOWEST_CIR\t1\n#define MLXSW_REG_QPCR_HIGHEST_CIR\t(2 * 1000 * 1000 * 1000)  \n#define MLXSW_REG_QPCR_LOWEST_CBS\t4\n#define MLXSW_REG_QPCR_HIGHEST_CBS\t24\n\n \n#define MLXSW_REG_QPCR_LOWEST_CIR_BITS\t\t1024  \n#define MLXSW_REG_QPCR_HIGHEST_CIR_BITS\t\t2000000000000ULL  \n#define MLXSW_REG_QPCR_LOWEST_CBS_BITS_SP1\t4\n#define MLXSW_REG_QPCR_LOWEST_CBS_BITS_SP2\t4\n#define MLXSW_REG_QPCR_HIGHEST_CBS_BITS_SP1\t25\n#define MLXSW_REG_QPCR_HIGHEST_CBS_BITS_SP2\t31\n\nstatic inline void mlxsw_reg_qpcr_pack(char *payload, u16 pid,\n\t\t\t\t       enum mlxsw_reg_qpcr_ir_units ir_units,\n\t\t\t\t       bool bytes, u32 cir, u16 cbs)\n{\n\tMLXSW_REG_ZERO(qpcr, payload);\n\tmlxsw_reg_qpcr_pid_set(payload, pid);\n\tmlxsw_reg_qpcr_g_set(payload, MLXSW_REG_QPCR_G_GLOBAL);\n\tmlxsw_reg_qpcr_rate_type_set(payload, MLXSW_REG_QPCR_RATE_TYPE_SINGLE);\n\tmlxsw_reg_qpcr_violate_action_set(payload,\n\t\t\t\t\t  MLXSW_REG_QPCR_ACTION_DISCARD);\n\tmlxsw_reg_qpcr_cir_set(payload, cir);\n\tmlxsw_reg_qpcr_ir_units_set(payload, ir_units);\n\tmlxsw_reg_qpcr_bytes_set(payload, bytes);\n\tmlxsw_reg_qpcr_cbs_set(payload, cbs);\n}\n\n \n#define MLXSW_REG_QTCT_ID 0x400A\n#define MLXSW_REG_QTCT_LEN 0x08\n\nMLXSW_REG_DEFINE(qtct, MLXSW_REG_QTCT_ID, MLXSW_REG_QTCT_LEN);\n\n \nMLXSW_ITEM32_LP(reg, qtct, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, qtct, sub_port, 0x00, 8, 8);\n\n \nMLXSW_ITEM32(reg, qtct, switch_prio, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, qtct, tclass, 0x04, 0, 4);\n\nstatic inline void mlxsw_reg_qtct_pack(char *payload, u16 local_port,\n\t\t\t\t       u8 switch_prio, u8 tclass)\n{\n\tMLXSW_REG_ZERO(qtct, payload);\n\tmlxsw_reg_qtct_local_port_set(payload, local_port);\n\tmlxsw_reg_qtct_switch_prio_set(payload, switch_prio);\n\tmlxsw_reg_qtct_tclass_set(payload, tclass);\n}\n\n \n#define MLXSW_REG_QEEC_ID 0x400D\n#define MLXSW_REG_QEEC_LEN 0x20\n\nMLXSW_REG_DEFINE(qeec, MLXSW_REG_QEEC_ID, MLXSW_REG_QEEC_LEN);\n\n \nMLXSW_ITEM32_LP(reg, qeec, 0x00, 16, 0x00, 12);\n\nenum mlxsw_reg_qeec_hr {\n\tMLXSW_REG_QEEC_HR_PORT,\n\tMLXSW_REG_QEEC_HR_GROUP,\n\tMLXSW_REG_QEEC_HR_SUBGROUP,\n\tMLXSW_REG_QEEC_HR_TC,\n};\n\n \nMLXSW_ITEM32(reg, qeec, element_hierarchy, 0x04, 16, 4);\n\n \nMLXSW_ITEM32(reg, qeec, element_index, 0x04, 0, 8);\n\n \nMLXSW_ITEM32(reg, qeec, next_element_index, 0x08, 0, 8);\n\n \nMLXSW_ITEM32(reg, qeec, mise, 0x0C, 31, 1);\n\n \nMLXSW_ITEM32(reg, qeec, ptps, 0x0C, 29, 1);\n\nenum {\n\tMLXSW_REG_QEEC_BYTES_MODE,\n\tMLXSW_REG_QEEC_PACKETS_MODE,\n};\n\n \nMLXSW_ITEM32(reg, qeec, pb, 0x0C, 28, 1);\n\n \n#define MLXSW_REG_QEEC_MIS_MIN\t200000\t\t \n\n \nMLXSW_ITEM32(reg, qeec, min_shaper_rate, 0x0C, 0, 28);\n\n \nMLXSW_ITEM32(reg, qeec, mase, 0x10, 31, 1);\n\n \n#define MLXSW_REG_QEEC_MAS_DIS\t((1u << 31) - 1)\t \n\n \nMLXSW_ITEM32(reg, qeec, max_shaper_rate, 0x10, 0, 31);\n\n \nMLXSW_ITEM32(reg, qeec, de, 0x18, 31, 1);\n\n \nMLXSW_ITEM32(reg, qeec, dwrr, 0x18, 15, 1);\n\n \nMLXSW_ITEM32(reg, qeec, dwrr_weight, 0x18, 0, 8);\n\n \nMLXSW_ITEM32(reg, qeec, max_shaper_bs, 0x1C, 0, 6);\n\n#define MLXSW_REG_QEEC_HIGHEST_SHAPER_BS\t25\n#define MLXSW_REG_QEEC_LOWEST_SHAPER_BS_SP1\t5\n#define MLXSW_REG_QEEC_LOWEST_SHAPER_BS_SP2\t11\n#define MLXSW_REG_QEEC_LOWEST_SHAPER_BS_SP3\t11\n#define MLXSW_REG_QEEC_LOWEST_SHAPER_BS_SP4\t11\n\nstatic inline void mlxsw_reg_qeec_pack(char *payload, u16 local_port,\n\t\t\t\t       enum mlxsw_reg_qeec_hr hr, u8 index,\n\t\t\t\t       u8 next_index)\n{\n\tMLXSW_REG_ZERO(qeec, payload);\n\tmlxsw_reg_qeec_local_port_set(payload, local_port);\n\tmlxsw_reg_qeec_element_hierarchy_set(payload, hr);\n\tmlxsw_reg_qeec_element_index_set(payload, index);\n\tmlxsw_reg_qeec_next_element_index_set(payload, next_index);\n}\n\nstatic inline void mlxsw_reg_qeec_ptps_pack(char *payload, u16 local_port,\n\t\t\t\t\t    bool ptps)\n{\n\tMLXSW_REG_ZERO(qeec, payload);\n\tmlxsw_reg_qeec_local_port_set(payload, local_port);\n\tmlxsw_reg_qeec_element_hierarchy_set(payload, MLXSW_REG_QEEC_HR_PORT);\n\tmlxsw_reg_qeec_ptps_set(payload, ptps);\n}\n\n \n#define MLXSW_REG_QRWE_ID 0x400F\n#define MLXSW_REG_QRWE_LEN 0x08\n\nMLXSW_REG_DEFINE(qrwe, MLXSW_REG_QRWE_ID, MLXSW_REG_QRWE_LEN);\n\n \nMLXSW_ITEM32_LP(reg, qrwe, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, qrwe, dscp, 0x04, 1, 1);\n\n \nMLXSW_ITEM32(reg, qrwe, pcp, 0x04, 0, 1);\n\nstatic inline void mlxsw_reg_qrwe_pack(char *payload, u16 local_port,\n\t\t\t\t       bool rewrite_pcp, bool rewrite_dscp)\n{\n\tMLXSW_REG_ZERO(qrwe, payload);\n\tmlxsw_reg_qrwe_local_port_set(payload, local_port);\n\tmlxsw_reg_qrwe_pcp_set(payload, rewrite_pcp);\n\tmlxsw_reg_qrwe_dscp_set(payload, rewrite_dscp);\n}\n\n \n#define MLXSW_REG_QPDSM_ID 0x4011\n#define MLXSW_REG_QPDSM_BASE_LEN 0x04  \n#define MLXSW_REG_QPDSM_PRIO_ENTRY_REC_LEN 0x4  \n#define MLXSW_REG_QPDSM_PRIO_ENTRY_REC_MAX_COUNT 16\n#define MLXSW_REG_QPDSM_LEN (MLXSW_REG_QPDSM_BASE_LEN +\t\t\t\\\n\t\t\t     MLXSW_REG_QPDSM_PRIO_ENTRY_REC_LEN *\t\\\n\t\t\t     MLXSW_REG_QPDSM_PRIO_ENTRY_REC_MAX_COUNT)\n\nMLXSW_REG_DEFINE(qpdsm, MLXSW_REG_QPDSM_ID, MLXSW_REG_QPDSM_LEN);\n\n \nMLXSW_ITEM32_LP(reg, qpdsm, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32_INDEXED(reg, qpdsm, prio_entry_color0_e,\n\t\t     MLXSW_REG_QPDSM_BASE_LEN, 31, 1,\n\t\t     MLXSW_REG_QPDSM_PRIO_ENTRY_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, qpdsm, prio_entry_color0_dscp,\n\t\t     MLXSW_REG_QPDSM_BASE_LEN, 24, 6,\n\t\t     MLXSW_REG_QPDSM_PRIO_ENTRY_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, qpdsm, prio_entry_color1_e,\n\t\t     MLXSW_REG_QPDSM_BASE_LEN, 23, 1,\n\t\t     MLXSW_REG_QPDSM_PRIO_ENTRY_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, qpdsm, prio_entry_color1_dscp,\n\t\t     MLXSW_REG_QPDSM_BASE_LEN, 16, 6,\n\t\t     MLXSW_REG_QPDSM_PRIO_ENTRY_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, qpdsm, prio_entry_color2_e,\n\t\t     MLXSW_REG_QPDSM_BASE_LEN, 15, 1,\n\t\t     MLXSW_REG_QPDSM_PRIO_ENTRY_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, qpdsm, prio_entry_color2_dscp,\n\t\t     MLXSW_REG_QPDSM_BASE_LEN, 8, 6,\n\t\t     MLXSW_REG_QPDSM_PRIO_ENTRY_REC_LEN, 0x00, false);\n\nstatic inline void mlxsw_reg_qpdsm_pack(char *payload, u16 local_port)\n{\n\tMLXSW_REG_ZERO(qpdsm, payload);\n\tmlxsw_reg_qpdsm_local_port_set(payload, local_port);\n}\n\nstatic inline void\nmlxsw_reg_qpdsm_prio_pack(char *payload, unsigned short prio, u8 dscp)\n{\n\tmlxsw_reg_qpdsm_prio_entry_color0_e_set(payload, prio, 1);\n\tmlxsw_reg_qpdsm_prio_entry_color0_dscp_set(payload, prio, dscp);\n\tmlxsw_reg_qpdsm_prio_entry_color1_e_set(payload, prio, 1);\n\tmlxsw_reg_qpdsm_prio_entry_color1_dscp_set(payload, prio, dscp);\n\tmlxsw_reg_qpdsm_prio_entry_color2_e_set(payload, prio, 1);\n\tmlxsw_reg_qpdsm_prio_entry_color2_dscp_set(payload, prio, dscp);\n}\n\n \n#define MLXSW_REG_QPDP_ID 0x4007\n#define MLXSW_REG_QPDP_LEN 0x8\n\nMLXSW_REG_DEFINE(qpdp, MLXSW_REG_QPDP_ID, MLXSW_REG_QPDP_LEN);\n\n \nMLXSW_ITEM32_LP(reg, qpdp, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, qpdp, switch_prio, 0x04, 0, 4);\n\nstatic inline void mlxsw_reg_qpdp_pack(char *payload, u16 local_port,\n\t\t\t\t       u8 switch_prio)\n{\n\tMLXSW_REG_ZERO(qpdp, payload);\n\tmlxsw_reg_qpdp_local_port_set(payload, local_port);\n\tmlxsw_reg_qpdp_switch_prio_set(payload, switch_prio);\n}\n\n \n#define MLXSW_REG_QPDPM_ID 0x4013\n#define MLXSW_REG_QPDPM_BASE_LEN 0x4  \n#define MLXSW_REG_QPDPM_DSCP_ENTRY_REC_LEN 0x2  \n#define MLXSW_REG_QPDPM_DSCP_ENTRY_REC_MAX_COUNT 64\n#define MLXSW_REG_QPDPM_LEN (MLXSW_REG_QPDPM_BASE_LEN +\t\t\t\\\n\t\t\t     MLXSW_REG_QPDPM_DSCP_ENTRY_REC_LEN *\t\\\n\t\t\t     MLXSW_REG_QPDPM_DSCP_ENTRY_REC_MAX_COUNT)\n\nMLXSW_REG_DEFINE(qpdpm, MLXSW_REG_QPDPM_ID, MLXSW_REG_QPDPM_LEN);\n\n \nMLXSW_ITEM32_LP(reg, qpdpm, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM16_INDEXED(reg, qpdpm, dscp_entry_e, MLXSW_REG_QPDPM_BASE_LEN, 15, 1,\n\t\t     MLXSW_REG_QPDPM_DSCP_ENTRY_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM16_INDEXED(reg, qpdpm, dscp_entry_prio,\n\t\t     MLXSW_REG_QPDPM_BASE_LEN, 0, 4,\n\t\t     MLXSW_REG_QPDPM_DSCP_ENTRY_REC_LEN, 0x00, false);\n\nstatic inline void mlxsw_reg_qpdpm_pack(char *payload, u16 local_port)\n{\n\tMLXSW_REG_ZERO(qpdpm, payload);\n\tmlxsw_reg_qpdpm_local_port_set(payload, local_port);\n}\n\nstatic inline void\nmlxsw_reg_qpdpm_dscp_pack(char *payload, unsigned short dscp, u8 prio)\n{\n\tmlxsw_reg_qpdpm_dscp_entry_e_set(payload, dscp, 1);\n\tmlxsw_reg_qpdpm_dscp_entry_prio_set(payload, dscp, prio);\n}\n\n \n#define MLXSW_REG_QTCTM_ID 0x401A\n#define MLXSW_REG_QTCTM_LEN 0x08\n\nMLXSW_REG_DEFINE(qtctm, MLXSW_REG_QTCTM_ID, MLXSW_REG_QTCTM_LEN);\n\n \nMLXSW_ITEM32_LP(reg, qtctm, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, qtctm, mc, 0x04, 0, 1);\n\nstatic inline void\nmlxsw_reg_qtctm_pack(char *payload, u16 local_port, bool mc)\n{\n\tMLXSW_REG_ZERO(qtctm, payload);\n\tmlxsw_reg_qtctm_local_port_set(payload, local_port);\n\tmlxsw_reg_qtctm_mc_set(payload, mc);\n}\n\n \n#define MLXSW_REG_QPSC_ID 0x401B\n#define MLXSW_REG_QPSC_LEN 0x28\n\nMLXSW_REG_DEFINE(qpsc, MLXSW_REG_QPSC_ID, MLXSW_REG_QPSC_LEN);\n\nenum mlxsw_reg_qpsc_port_speed {\n\tMLXSW_REG_QPSC_PORT_SPEED_100M,\n\tMLXSW_REG_QPSC_PORT_SPEED_1G,\n\tMLXSW_REG_QPSC_PORT_SPEED_10G,\n\tMLXSW_REG_QPSC_PORT_SPEED_25G,\n};\n\n \nMLXSW_ITEM32(reg, qpsc, port_speed, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, qpsc, shaper_time_exp, 0x04, 16, 4);\n\n \nMLXSW_ITEM32(reg, qpsc, shaper_time_mantissa, 0x04, 0, 5);\n\n \nMLXSW_ITEM32(reg, qpsc, shaper_inc, 0x08, 0, 5);\n\n \nMLXSW_ITEM32(reg, qpsc, shaper_bs, 0x0C, 0, 6);\n\n \nMLXSW_ITEM32(reg, qpsc, ptsc_we, 0x10, 31, 1);\n\n \nMLXSW_ITEM32(reg, qpsc, port_to_shaper_credits, 0x10, 0, 8);\n\n \nMLXSW_ITEM32(reg, qpsc, ing_timestamp_inc, 0x20, 0, 32);\n\n \nMLXSW_ITEM32(reg, qpsc, egr_timestamp_inc, 0x24, 0, 32);\n\nstatic inline void\nmlxsw_reg_qpsc_pack(char *payload, enum mlxsw_reg_qpsc_port_speed port_speed,\n\t\t    u8 shaper_time_exp, u8 shaper_time_mantissa, u8 shaper_inc,\n\t\t    u8 shaper_bs, u8 port_to_shaper_credits,\n\t\t    int ing_timestamp_inc, int egr_timestamp_inc)\n{\n\tMLXSW_REG_ZERO(qpsc, payload);\n\tmlxsw_reg_qpsc_port_speed_set(payload, port_speed);\n\tmlxsw_reg_qpsc_shaper_time_exp_set(payload, shaper_time_exp);\n\tmlxsw_reg_qpsc_shaper_time_mantissa_set(payload, shaper_time_mantissa);\n\tmlxsw_reg_qpsc_shaper_inc_set(payload, shaper_inc);\n\tmlxsw_reg_qpsc_shaper_bs_set(payload, shaper_bs);\n\tmlxsw_reg_qpsc_ptsc_we_set(payload, true);\n\tmlxsw_reg_qpsc_port_to_shaper_credits_set(payload, port_to_shaper_credits);\n\tmlxsw_reg_qpsc_ing_timestamp_inc_set(payload, ing_timestamp_inc);\n\tmlxsw_reg_qpsc_egr_timestamp_inc_set(payload, egr_timestamp_inc);\n}\n\n \n#define MLXSW_REG_PMLP_ID 0x5002\n#define MLXSW_REG_PMLP_LEN 0x40\n\nMLXSW_REG_DEFINE(pmlp, MLXSW_REG_PMLP_ID, MLXSW_REG_PMLP_LEN);\n\n \nMLXSW_ITEM32(reg, pmlp, rxtx, 0x00, 31, 1);\n\n \nMLXSW_ITEM32_LP(reg, pmlp, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, pmlp, width, 0x00, 0, 8);\n\n \nMLXSW_ITEM32_INDEXED(reg, pmlp, module, 0x04, 0, 8, 0x04, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, pmlp, slot_index, 0x04, 8, 4, 0x04, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, pmlp, tx_lane, 0x04, 16, 4, 0x04, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, pmlp, rx_lane, 0x04, 24, 4, 0x04, 0x00, false);\n\nstatic inline void mlxsw_reg_pmlp_pack(char *payload, u16 local_port)\n{\n\tMLXSW_REG_ZERO(pmlp, payload);\n\tmlxsw_reg_pmlp_local_port_set(payload, local_port);\n}\n\n \n#define MLXSW_REG_PMTU_ID 0x5003\n#define MLXSW_REG_PMTU_LEN 0x10\n\nMLXSW_REG_DEFINE(pmtu, MLXSW_REG_PMTU_ID, MLXSW_REG_PMTU_LEN);\n\n \nMLXSW_ITEM32_LP(reg, pmtu, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, pmtu, max_mtu, 0x04, 16, 16);\n\n \nMLXSW_ITEM32(reg, pmtu, admin_mtu, 0x08, 16, 16);\n\n \nMLXSW_ITEM32(reg, pmtu, oper_mtu, 0x0C, 16, 16);\n\nstatic inline void mlxsw_reg_pmtu_pack(char *payload, u16 local_port,\n\t\t\t\t       u16 new_mtu)\n{\n\tMLXSW_REG_ZERO(pmtu, payload);\n\tmlxsw_reg_pmtu_local_port_set(payload, local_port);\n\tmlxsw_reg_pmtu_max_mtu_set(payload, 0);\n\tmlxsw_reg_pmtu_admin_mtu_set(payload, new_mtu);\n\tmlxsw_reg_pmtu_oper_mtu_set(payload, 0);\n}\n\n \n#define MLXSW_REG_PTYS_ID 0x5004\n#define MLXSW_REG_PTYS_LEN 0x40\n\nMLXSW_REG_DEFINE(ptys, MLXSW_REG_PTYS_ID, MLXSW_REG_PTYS_LEN);\n\n \nMLXSW_ITEM32(reg, ptys, an_disable_admin, 0x00, 30, 1);\n\n \nMLXSW_ITEM32_LP(reg, ptys, 0x00, 16, 0x00, 12);\n\n#define MLXSW_REG_PTYS_PROTO_MASK_IB\tBIT(0)\n#define MLXSW_REG_PTYS_PROTO_MASK_ETH\tBIT(2)\n\n \nMLXSW_ITEM32(reg, ptys, proto_mask, 0x00, 0, 3);\n\nenum {\n\tMLXSW_REG_PTYS_AN_STATUS_NA,\n\tMLXSW_REG_PTYS_AN_STATUS_OK,\n\tMLXSW_REG_PTYS_AN_STATUS_FAIL,\n};\n\n \nMLXSW_ITEM32(reg, ptys, an_status, 0x04, 28, 4);\n\n#define MLXSW_REG_PTYS_EXT_ETH_SPEED_SGMII_100M\t\t\t\tBIT(0)\n#define MLXSW_REG_PTYS_EXT_ETH_SPEED_1000BASE_X_SGMII\t\t\tBIT(1)\n#define MLXSW_REG_PTYS_EXT_ETH_SPEED_5GBASE_R\t\t\t\tBIT(3)\n#define MLXSW_REG_PTYS_EXT_ETH_SPEED_XFI_XAUI_1_10G\t\t\tBIT(4)\n#define MLXSW_REG_PTYS_EXT_ETH_SPEED_XLAUI_4_XLPPI_4_40G\t\tBIT(5)\n#define MLXSW_REG_PTYS_EXT_ETH_SPEED_25GAUI_1_25GBASE_CR_KR\t\tBIT(6)\n#define MLXSW_REG_PTYS_EXT_ETH_SPEED_50GAUI_2_LAUI_2_50GBASE_CR2_KR2\tBIT(7)\n#define MLXSW_REG_PTYS_EXT_ETH_SPEED_50GAUI_1_LAUI_1_50GBASE_CR_KR\tBIT(8)\n#define MLXSW_REG_PTYS_EXT_ETH_SPEED_CAUI_4_100GBASE_CR4_KR4\t\tBIT(9)\n#define MLXSW_REG_PTYS_EXT_ETH_SPEED_100GAUI_2_100GBASE_CR2_KR2\t\tBIT(10)\n#define MLXSW_REG_PTYS_EXT_ETH_SPEED_200GAUI_4_200GBASE_CR4_KR4\t\tBIT(12)\n#define MLXSW_REG_PTYS_EXT_ETH_SPEED_400GAUI_8\t\t\t\tBIT(15)\n#define MLXSW_REG_PTYS_EXT_ETH_SPEED_800GAUI_8\t\t\t\tBIT(19)\n\n \nMLXSW_ITEM32(reg, ptys, ext_eth_proto_cap, 0x08, 0, 32);\n\n#define MLXSW_REG_PTYS_ETH_SPEED_SGMII\t\t\tBIT(0)\n#define MLXSW_REG_PTYS_ETH_SPEED_1000BASE_KX\t\tBIT(1)\n#define MLXSW_REG_PTYS_ETH_SPEED_10GBASE_CX4\t\tBIT(2)\n#define MLXSW_REG_PTYS_ETH_SPEED_10GBASE_KX4\t\tBIT(3)\n#define MLXSW_REG_PTYS_ETH_SPEED_10GBASE_KR\t\tBIT(4)\n#define MLXSW_REG_PTYS_ETH_SPEED_40GBASE_CR4\t\tBIT(6)\n#define MLXSW_REG_PTYS_ETH_SPEED_40GBASE_KR4\t\tBIT(7)\n#define MLXSW_REG_PTYS_ETH_SPEED_10GBASE_CR\t\tBIT(12)\n#define MLXSW_REG_PTYS_ETH_SPEED_10GBASE_SR\t\tBIT(13)\n#define MLXSW_REG_PTYS_ETH_SPEED_10GBASE_ER_LR\t\tBIT(14)\n#define MLXSW_REG_PTYS_ETH_SPEED_40GBASE_SR4\t\tBIT(15)\n#define MLXSW_REG_PTYS_ETH_SPEED_40GBASE_LR4_ER4\tBIT(16)\n#define MLXSW_REG_PTYS_ETH_SPEED_50GBASE_SR2\t\tBIT(18)\n#define MLXSW_REG_PTYS_ETH_SPEED_50GBASE_KR4\t\tBIT(19)\n#define MLXSW_REG_PTYS_ETH_SPEED_100GBASE_CR4\t\tBIT(20)\n#define MLXSW_REG_PTYS_ETH_SPEED_100GBASE_SR4\t\tBIT(21)\n#define MLXSW_REG_PTYS_ETH_SPEED_100GBASE_KR4\t\tBIT(22)\n#define MLXSW_REG_PTYS_ETH_SPEED_100GBASE_LR4_ER4\tBIT(23)\n#define MLXSW_REG_PTYS_ETH_SPEED_100BASE_T\t\tBIT(24)\n#define MLXSW_REG_PTYS_ETH_SPEED_1000BASE_T\t\tBIT(25)\n#define MLXSW_REG_PTYS_ETH_SPEED_25GBASE_CR\t\tBIT(27)\n#define MLXSW_REG_PTYS_ETH_SPEED_25GBASE_KR\t\tBIT(28)\n#define MLXSW_REG_PTYS_ETH_SPEED_25GBASE_SR\t\tBIT(29)\n#define MLXSW_REG_PTYS_ETH_SPEED_50GBASE_CR2\t\tBIT(30)\n#define MLXSW_REG_PTYS_ETH_SPEED_50GBASE_KR2\t\tBIT(31)\n\n \nMLXSW_ITEM32(reg, ptys, eth_proto_cap, 0x0C, 0, 32);\n\n \nMLXSW_ITEM32(reg, ptys, ext_eth_proto_admin, 0x14, 0, 32);\n\n \nMLXSW_ITEM32(reg, ptys, eth_proto_admin, 0x18, 0, 32);\n\n \nMLXSW_ITEM32(reg, ptys, ext_eth_proto_oper, 0x20, 0, 32);\n\n \nMLXSW_ITEM32(reg, ptys, eth_proto_oper, 0x24, 0, 32);\n\nenum mlxsw_reg_ptys_connector_type {\n\tMLXSW_REG_PTYS_CONNECTOR_TYPE_UNKNOWN_OR_NO_CONNECTOR,\n\tMLXSW_REG_PTYS_CONNECTOR_TYPE_PORT_NONE,\n\tMLXSW_REG_PTYS_CONNECTOR_TYPE_PORT_TP,\n\tMLXSW_REG_PTYS_CONNECTOR_TYPE_PORT_AUI,\n\tMLXSW_REG_PTYS_CONNECTOR_TYPE_PORT_BNC,\n\tMLXSW_REG_PTYS_CONNECTOR_TYPE_PORT_MII,\n\tMLXSW_REG_PTYS_CONNECTOR_TYPE_PORT_FIBRE,\n\tMLXSW_REG_PTYS_CONNECTOR_TYPE_PORT_DA,\n\tMLXSW_REG_PTYS_CONNECTOR_TYPE_PORT_OTHER,\n};\n\n \nMLXSW_ITEM32(reg, ptys, connector_type, 0x2C, 0, 4);\n\nstatic inline void mlxsw_reg_ptys_eth_pack(char *payload, u16 local_port,\n\t\t\t\t\t   u32 proto_admin, bool autoneg)\n{\n\tMLXSW_REG_ZERO(ptys, payload);\n\tmlxsw_reg_ptys_local_port_set(payload, local_port);\n\tmlxsw_reg_ptys_proto_mask_set(payload, MLXSW_REG_PTYS_PROTO_MASK_ETH);\n\tmlxsw_reg_ptys_eth_proto_admin_set(payload, proto_admin);\n\tmlxsw_reg_ptys_an_disable_admin_set(payload, !autoneg);\n}\n\nstatic inline void mlxsw_reg_ptys_ext_eth_pack(char *payload, u16 local_port,\n\t\t\t\t\t       u32 proto_admin, bool autoneg)\n{\n\tMLXSW_REG_ZERO(ptys, payload);\n\tmlxsw_reg_ptys_local_port_set(payload, local_port);\n\tmlxsw_reg_ptys_proto_mask_set(payload, MLXSW_REG_PTYS_PROTO_MASK_ETH);\n\tmlxsw_reg_ptys_ext_eth_proto_admin_set(payload, proto_admin);\n\tmlxsw_reg_ptys_an_disable_admin_set(payload, !autoneg);\n}\n\nstatic inline void mlxsw_reg_ptys_eth_unpack(char *payload,\n\t\t\t\t\t     u32 *p_eth_proto_cap,\n\t\t\t\t\t     u32 *p_eth_proto_admin,\n\t\t\t\t\t     u32 *p_eth_proto_oper)\n{\n\tif (p_eth_proto_cap)\n\t\t*p_eth_proto_cap =\n\t\t\tmlxsw_reg_ptys_eth_proto_cap_get(payload);\n\tif (p_eth_proto_admin)\n\t\t*p_eth_proto_admin =\n\t\t\tmlxsw_reg_ptys_eth_proto_admin_get(payload);\n\tif (p_eth_proto_oper)\n\t\t*p_eth_proto_oper =\n\t\t\tmlxsw_reg_ptys_eth_proto_oper_get(payload);\n}\n\nstatic inline void mlxsw_reg_ptys_ext_eth_unpack(char *payload,\n\t\t\t\t\t\t u32 *p_eth_proto_cap,\n\t\t\t\t\t\t u32 *p_eth_proto_admin,\n\t\t\t\t\t\t u32 *p_eth_proto_oper)\n{\n\tif (p_eth_proto_cap)\n\t\t*p_eth_proto_cap =\n\t\t\tmlxsw_reg_ptys_ext_eth_proto_cap_get(payload);\n\tif (p_eth_proto_admin)\n\t\t*p_eth_proto_admin =\n\t\t\tmlxsw_reg_ptys_ext_eth_proto_admin_get(payload);\n\tif (p_eth_proto_oper)\n\t\t*p_eth_proto_oper =\n\t\t\tmlxsw_reg_ptys_ext_eth_proto_oper_get(payload);\n}\n\n \n#define MLXSW_REG_PPAD_ID 0x5005\n#define MLXSW_REG_PPAD_LEN 0x10\n\nMLXSW_REG_DEFINE(ppad, MLXSW_REG_PPAD_ID, MLXSW_REG_PPAD_LEN);\n\n \nMLXSW_ITEM32(reg, ppad, single_base_mac, 0x00, 28, 1);\n\n \nMLXSW_ITEM32_LP(reg, ppad, 0x00, 16, 0x00, 24);\n\n \nMLXSW_ITEM_BUF(reg, ppad, mac, 0x02, 6);\n\nstatic inline void mlxsw_reg_ppad_pack(char *payload, bool single_base_mac,\n\t\t\t\t       u16 local_port)\n{\n\tMLXSW_REG_ZERO(ppad, payload);\n\tmlxsw_reg_ppad_single_base_mac_set(payload, !!single_base_mac);\n\tmlxsw_reg_ppad_local_port_set(payload, local_port);\n}\n\n \n#define MLXSW_REG_PAOS_ID 0x5006\n#define MLXSW_REG_PAOS_LEN 0x10\n\nMLXSW_REG_DEFINE(paos, MLXSW_REG_PAOS_ID, MLXSW_REG_PAOS_LEN);\n\n \nMLXSW_ITEM32(reg, paos, swid, 0x00, 24, 8);\n\n \nMLXSW_ITEM32_LP(reg, paos, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, paos, admin_status, 0x00, 8, 4);\n\n \nMLXSW_ITEM32(reg, paos, oper_status, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, paos, ase, 0x04, 31, 1);\n\n \nMLXSW_ITEM32(reg, paos, ee, 0x04, 30, 1);\n\n \nMLXSW_ITEM32(reg, paos, e, 0x04, 0, 2);\n\nstatic inline void mlxsw_reg_paos_pack(char *payload, u16 local_port,\n\t\t\t\t       enum mlxsw_port_admin_status status)\n{\n\tMLXSW_REG_ZERO(paos, payload);\n\tmlxsw_reg_paos_swid_set(payload, 0);\n\tmlxsw_reg_paos_local_port_set(payload, local_port);\n\tmlxsw_reg_paos_admin_status_set(payload, status);\n\tmlxsw_reg_paos_oper_status_set(payload, 0);\n\tmlxsw_reg_paos_ase_set(payload, 1);\n\tmlxsw_reg_paos_ee_set(payload, 1);\n\tmlxsw_reg_paos_e_set(payload, 1);\n}\n\n \n#define MLXSW_REG_PFCC_ID 0x5007\n#define MLXSW_REG_PFCC_LEN 0x20\n\nMLXSW_REG_DEFINE(pfcc, MLXSW_REG_PFCC_ID, MLXSW_REG_PFCC_LEN);\n\n \nMLXSW_ITEM32_LP(reg, pfcc, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, pfcc, pnat, 0x00, 14, 2);\n\n \nMLXSW_ITEM32(reg, pfcc, shl_cap, 0x00, 1, 1);\n\n \nMLXSW_ITEM32(reg, pfcc, shl_opr, 0x00, 0, 1);\n\n \nMLXSW_ITEM32(reg, pfcc, ppan, 0x04, 28, 4);\n\n \nMLXSW_ITEM32(reg, pfcc, prio_mask_tx, 0x04, 16, 8);\n\n \nMLXSW_ITEM32(reg, pfcc, prio_mask_rx, 0x04, 0, 8);\n\n \nMLXSW_ITEM32(reg, pfcc, pptx, 0x08, 31, 1);\n\n \nMLXSW_ITEM32(reg, pfcc, aptx, 0x08, 30, 1);\n\n \nMLXSW_ITEM32(reg, pfcc, pfctx, 0x08, 16, 8);\n\n \nMLXSW_ITEM32(reg, pfcc, pprx, 0x0C, 31, 1);\n\n \nMLXSW_ITEM32(reg, pfcc, aprx, 0x0C, 30, 1);\n\n \nMLXSW_ITEM32(reg, pfcc, pfcrx, 0x0C, 16, 8);\n\n#define MLXSW_REG_PFCC_ALL_PRIO 0xFF\n\nstatic inline void mlxsw_reg_pfcc_prio_pack(char *payload, u8 pfc_en)\n{\n\tmlxsw_reg_pfcc_prio_mask_tx_set(payload, MLXSW_REG_PFCC_ALL_PRIO);\n\tmlxsw_reg_pfcc_prio_mask_rx_set(payload, MLXSW_REG_PFCC_ALL_PRIO);\n\tmlxsw_reg_pfcc_pfctx_set(payload, pfc_en);\n\tmlxsw_reg_pfcc_pfcrx_set(payload, pfc_en);\n}\n\nstatic inline void mlxsw_reg_pfcc_pack(char *payload, u16 local_port)\n{\n\tMLXSW_REG_ZERO(pfcc, payload);\n\tmlxsw_reg_pfcc_local_port_set(payload, local_port);\n}\n\n \n#define MLXSW_REG_PPCNT_ID 0x5008\n#define MLXSW_REG_PPCNT_LEN 0x100\n#define MLXSW_REG_PPCNT_COUNTERS_OFFSET 0x08\n\nMLXSW_REG_DEFINE(ppcnt, MLXSW_REG_PPCNT_ID, MLXSW_REG_PPCNT_LEN);\n\n \nMLXSW_ITEM32(reg, ppcnt, swid, 0x00, 24, 8);\n\n \nMLXSW_ITEM32_LP(reg, ppcnt, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, ppcnt, pnat, 0x00, 14, 2);\n\nenum mlxsw_reg_ppcnt_grp {\n\tMLXSW_REG_PPCNT_IEEE_8023_CNT = 0x0,\n\tMLXSW_REG_PPCNT_RFC_2863_CNT = 0x1,\n\tMLXSW_REG_PPCNT_RFC_2819_CNT = 0x2,\n\tMLXSW_REG_PPCNT_RFC_3635_CNT = 0x3,\n\tMLXSW_REG_PPCNT_EXT_CNT = 0x5,\n\tMLXSW_REG_PPCNT_DISCARD_CNT = 0x6,\n\tMLXSW_REG_PPCNT_PRIO_CNT = 0x10,\n\tMLXSW_REG_PPCNT_TC_CNT = 0x11,\n\tMLXSW_REG_PPCNT_TC_CONG_CNT = 0x13,\n};\n\n \nMLXSW_ITEM32(reg, ppcnt, grp, 0x00, 0, 6);\n\n \nMLXSW_ITEM32(reg, ppcnt, clr, 0x04, 31, 1);\n\n \nMLXSW_ITEM32(reg, ppcnt, lp_gl, 0x04, 30, 1);\n\n \nMLXSW_ITEM32(reg, ppcnt, prio_tc, 0x04, 0, 5);\n\n \n\n \nMLXSW_ITEM64(reg, ppcnt, a_frames_transmitted_ok,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x00, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_frames_received_ok,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x08, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_frame_check_sequence_errors,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x10, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_alignment_errors,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x18, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_octets_transmitted_ok,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x20, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_octets_received_ok,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x28, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_multicast_frames_xmitted_ok,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x30, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_broadcast_frames_xmitted_ok,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x38, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_multicast_frames_received_ok,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x40, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_broadcast_frames_received_ok,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x48, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_in_range_length_errors,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x50, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_out_of_range_length_field,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x58, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_frame_too_long_errors,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x60, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_symbol_error_during_carrier,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x68, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_mac_control_frames_transmitted,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x70, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_mac_control_frames_received,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x78, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_unsupported_opcodes_received,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x80, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_pause_mac_ctrl_frames_received,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x88, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, a_pause_mac_ctrl_frames_transmitted,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x90, 0, 64);\n\n \n\n \nMLXSW_ITEM64(reg, ppcnt, if_in_discards,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x10, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, if_out_discards,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x38, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, if_out_errors,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x40, 0, 64);\n\n \n\n \nMLXSW_ITEM64(reg, ppcnt, ether_stats_undersize_pkts,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x30, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ether_stats_oversize_pkts,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x38, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ether_stats_fragments,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x40, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ether_stats_pkts64octets,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x58, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ether_stats_pkts65to127octets,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x60, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ether_stats_pkts128to255octets,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x68, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ether_stats_pkts256to511octets,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x70, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ether_stats_pkts512to1023octets,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x78, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ether_stats_pkts1024to1518octets,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x80, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ether_stats_pkts1519to2047octets,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x88, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ether_stats_pkts2048to4095octets,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x90, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ether_stats_pkts4096to8191octets,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x98, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ether_stats_pkts8192to10239octets,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0xA0, 0, 64);\n\n \n\n \nMLXSW_ITEM64(reg, ppcnt, dot3stats_fcs_errors,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x08, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, dot3stats_symbol_errors,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x60, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, dot3control_in_unknown_opcodes,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x68, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, dot3in_pause_frames,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x70, 0, 64);\n\n \n\n \nMLXSW_ITEM64(reg, ppcnt, ecn_marked,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x08, 0, 64);\n\n \n\n \nMLXSW_ITEM64(reg, ppcnt, ingress_general,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x00, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ingress_policy_engine,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x08, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ingress_vlan_membership,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x10, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ingress_tag_frame_type,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x18, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, egress_vlan_membership,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x20, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, loopback_filter,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x28, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, egress_general,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x30, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, egress_hoq,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x40, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, egress_policy_engine,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x50, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ingress_tx_link_down,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x58, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, egress_stp_filter,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x60, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, egress_sll,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x70, 0, 64);\n\n \n\n \nMLXSW_ITEM64(reg, ppcnt, rx_octets,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x00, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, rx_frames,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x20, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, tx_octets,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x28, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, tx_frames,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x48, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, rx_pause,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x50, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, rx_pause_duration,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x58, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, tx_pause,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x60, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, tx_pause_duration,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x68, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, tx_pause_transition,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x70, 0, 64);\n\n \n\n \nMLXSW_ITEM64(reg, ppcnt, tc_transmit_queue,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x00, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, tc_no_buffer_discard_uc,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x08, 0, 64);\n\n \n\n \nMLXSW_ITEM64(reg, ppcnt, wred_discard,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x00, 0, 64);\n\n \nMLXSW_ITEM64(reg, ppcnt, ecn_marked_tc,\n\t     MLXSW_REG_PPCNT_COUNTERS_OFFSET + 0x08, 0, 64);\n\nstatic inline void mlxsw_reg_ppcnt_pack(char *payload, u16 local_port,\n\t\t\t\t\tenum mlxsw_reg_ppcnt_grp grp,\n\t\t\t\t\tu8 prio_tc)\n{\n\tMLXSW_REG_ZERO(ppcnt, payload);\n\tmlxsw_reg_ppcnt_swid_set(payload, 0);\n\tmlxsw_reg_ppcnt_local_port_set(payload, local_port);\n\tmlxsw_reg_ppcnt_pnat_set(payload, 0);\n\tmlxsw_reg_ppcnt_grp_set(payload, grp);\n\tmlxsw_reg_ppcnt_clr_set(payload, 0);\n\tmlxsw_reg_ppcnt_lp_gl_set(payload, 1);\n\tmlxsw_reg_ppcnt_prio_tc_set(payload, prio_tc);\n}\n\n \n#define MLXSW_REG_PPTB_ID 0x500B\n#define MLXSW_REG_PPTB_LEN 0x10\n\nMLXSW_REG_DEFINE(pptb, MLXSW_REG_PPTB_ID, MLXSW_REG_PPTB_LEN);\n\nenum {\n\tMLXSW_REG_PPTB_MM_UM,\n\tMLXSW_REG_PPTB_MM_UNICAST,\n\tMLXSW_REG_PPTB_MM_MULTICAST,\n};\n\n \nMLXSW_ITEM32(reg, pptb, mm, 0x00, 28, 2);\n\n \nMLXSW_ITEM32_LP(reg, pptb, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, pptb, um, 0x00, 8, 1);\n\n \nMLXSW_ITEM32(reg, pptb, pm, 0x00, 0, 8);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, pptb, prio_to_buff, 0x04, 0x04, 4);\n\n \nMLXSW_ITEM32(reg, pptb, pm_msb, 0x08, 24, 8);\n\n \nMLXSW_ITEM32(reg, pptb, untagged_buff, 0x08, 0, 4);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, pptb, prio_to_buff_msb, 0x0C, 0x04, 4);\n\n#define MLXSW_REG_PPTB_ALL_PRIO 0xFF\n\nstatic inline void mlxsw_reg_pptb_pack(char *payload, u16 local_port)\n{\n\tMLXSW_REG_ZERO(pptb, payload);\n\tmlxsw_reg_pptb_mm_set(payload, MLXSW_REG_PPTB_MM_UM);\n\tmlxsw_reg_pptb_local_port_set(payload, local_port);\n\tmlxsw_reg_pptb_pm_set(payload, MLXSW_REG_PPTB_ALL_PRIO);\n\tmlxsw_reg_pptb_pm_msb_set(payload, MLXSW_REG_PPTB_ALL_PRIO);\n}\n\nstatic inline void mlxsw_reg_pptb_prio_to_buff_pack(char *payload, u8 prio,\n\t\t\t\t\t\t    u8 buff)\n{\n\tmlxsw_reg_pptb_prio_to_buff_set(payload, prio, buff);\n\tmlxsw_reg_pptb_prio_to_buff_msb_set(payload, prio, buff);\n}\n\n \n#define MLXSW_REG_PBMC_ID 0x500C\n#define MLXSW_REG_PBMC_LEN 0x6C\n\nMLXSW_REG_DEFINE(pbmc, MLXSW_REG_PBMC_ID, MLXSW_REG_PBMC_LEN);\n\n \nMLXSW_ITEM32_LP(reg, pbmc, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, pbmc, xoff_timer_value, 0x04, 16, 16);\n\n \nMLXSW_ITEM32(reg, pbmc, xoff_refresh, 0x04, 0, 16);\n\n#define MLXSW_REG_PBMC_PORT_SHARED_BUF_IDX 11\n\n \nMLXSW_ITEM32_INDEXED(reg, pbmc, buf_lossy, 0x0C, 25, 1, 0x08, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, pbmc, buf_epsb, 0x0C, 24, 1, 0x08, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, pbmc, buf_size, 0x0C, 0, 16, 0x08, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, pbmc, buf_xoff_threshold, 0x0C, 16, 16,\n\t\t     0x08, 0x04, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, pbmc, buf_xon_threshold, 0x0C, 0, 16,\n\t\t     0x08, 0x04, false);\n\nstatic inline void mlxsw_reg_pbmc_pack(char *payload, u16 local_port,\n\t\t\t\t       u16 xoff_timer_value, u16 xoff_refresh)\n{\n\tMLXSW_REG_ZERO(pbmc, payload);\n\tmlxsw_reg_pbmc_local_port_set(payload, local_port);\n\tmlxsw_reg_pbmc_xoff_timer_value_set(payload, xoff_timer_value);\n\tmlxsw_reg_pbmc_xoff_refresh_set(payload, xoff_refresh);\n}\n\nstatic inline void mlxsw_reg_pbmc_lossy_buffer_pack(char *payload,\n\t\t\t\t\t\t    int buf_index,\n\t\t\t\t\t\t    u16 size)\n{\n\tmlxsw_reg_pbmc_buf_lossy_set(payload, buf_index, 1);\n\tmlxsw_reg_pbmc_buf_epsb_set(payload, buf_index, 0);\n\tmlxsw_reg_pbmc_buf_size_set(payload, buf_index, size);\n}\n\nstatic inline void mlxsw_reg_pbmc_lossless_buffer_pack(char *payload,\n\t\t\t\t\t\t       int buf_index, u16 size,\n\t\t\t\t\t\t       u16 threshold)\n{\n\tmlxsw_reg_pbmc_buf_lossy_set(payload, buf_index, 0);\n\tmlxsw_reg_pbmc_buf_epsb_set(payload, buf_index, 0);\n\tmlxsw_reg_pbmc_buf_size_set(payload, buf_index, size);\n\tmlxsw_reg_pbmc_buf_xoff_threshold_set(payload, buf_index, threshold);\n\tmlxsw_reg_pbmc_buf_xon_threshold_set(payload, buf_index, threshold);\n}\n\n \n#define MLXSW_REG_PSPA_ID 0x500D\n#define MLXSW_REG_PSPA_LEN 0x8\n\nMLXSW_REG_DEFINE(pspa, MLXSW_REG_PSPA_ID, MLXSW_REG_PSPA_LEN);\n\n \nMLXSW_ITEM32(reg, pspa, swid, 0x00, 24, 8);\n\n \nMLXSW_ITEM32_LP(reg, pspa, 0x00, 16, 0x00, 0);\n\n \nMLXSW_ITEM32(reg, pspa, sub_port, 0x00, 8, 8);\n\nstatic inline void mlxsw_reg_pspa_pack(char *payload, u8 swid, u16 local_port)\n{\n\tMLXSW_REG_ZERO(pspa, payload);\n\tmlxsw_reg_pspa_swid_set(payload, swid);\n\tmlxsw_reg_pspa_local_port_set(payload, local_port);\n\tmlxsw_reg_pspa_sub_port_set(payload, 0);\n}\n\n \n#define MLXSW_REG_PMAOS_ID 0x5012\n#define MLXSW_REG_PMAOS_LEN 0x10\n\nMLXSW_REG_DEFINE(pmaos, MLXSW_REG_PMAOS_ID, MLXSW_REG_PMAOS_LEN);\n\n \nMLXSW_ITEM32(reg, pmaos, rst, 0x00, 31, 1);\n\n \nMLXSW_ITEM32(reg, pmaos, slot_index, 0x00, 24, 4);\n\n \nMLXSW_ITEM32(reg, pmaos, module, 0x00, 16, 8);\n\nenum mlxsw_reg_pmaos_admin_status {\n\tMLXSW_REG_PMAOS_ADMIN_STATUS_ENABLED = 1,\n\tMLXSW_REG_PMAOS_ADMIN_STATUS_DISABLED = 2,\n\t \n\tMLXSW_REG_PMAOS_ADMIN_STATUS_ENABLED_ONCE = 3,\n};\n\n \nMLXSW_ITEM32(reg, pmaos, admin_status, 0x00, 8, 4);\n\n \nMLXSW_ITEM32(reg, pmaos, ase, 0x04, 31, 1);\n\n \nMLXSW_ITEM32(reg, pmaos, ee, 0x04, 30, 1);\n\nenum mlxsw_reg_pmaos_e {\n\tMLXSW_REG_PMAOS_E_DO_NOT_GENERATE_EVENT,\n\tMLXSW_REG_PMAOS_E_GENERATE_EVENT,\n\tMLXSW_REG_PMAOS_E_GENERATE_SINGLE_EVENT,\n};\n\n \nMLXSW_ITEM32(reg, pmaos, e, 0x04, 0, 2);\n\nstatic inline void mlxsw_reg_pmaos_pack(char *payload, u8 slot_index, u8 module)\n{\n\tMLXSW_REG_ZERO(pmaos, payload);\n\tmlxsw_reg_pmaos_slot_index_set(payload, slot_index);\n\tmlxsw_reg_pmaos_module_set(payload, module);\n}\n\n \n#define MLXSW_REG_PPLR_ID 0x5018\n#define MLXSW_REG_PPLR_LEN 0x8\n\nMLXSW_REG_DEFINE(pplr, MLXSW_REG_PPLR_ID, MLXSW_REG_PPLR_LEN);\n\n \nMLXSW_ITEM32_LP(reg, pplr, 0x00, 16, 0x00, 12);\n\n \n#define MLXSW_REG_PPLR_LB_TYPE_BIT_PHY_LOCAL BIT(1)\n\n \nMLXSW_ITEM32(reg, pplr, lb_en, 0x04, 0, 8);\n\nstatic inline void mlxsw_reg_pplr_pack(char *payload, u16 local_port,\n\t\t\t\t       bool phy_local)\n{\n\tMLXSW_REG_ZERO(pplr, payload);\n\tmlxsw_reg_pplr_local_port_set(payload, local_port);\n\tmlxsw_reg_pplr_lb_en_set(payload,\n\t\t\t\t phy_local ?\n\t\t\t\t MLXSW_REG_PPLR_LB_TYPE_BIT_PHY_LOCAL : 0);\n}\n\n \n#define MLXSW_REG_PMTDB_ID 0x501A\n#define MLXSW_REG_PMTDB_LEN 0x40\n\nMLXSW_REG_DEFINE(pmtdb, MLXSW_REG_PMTDB_ID, MLXSW_REG_PMTDB_LEN);\n\n \nMLXSW_ITEM32(reg, pmtdb, slot_index, 0x00, 24, 4);\n\n \nMLXSW_ITEM32(reg, pmtdb, module, 0x00, 16, 8);\n\n \nMLXSW_ITEM32(reg, pmtdb, ports_width, 0x00, 12, 4);\n\n \nMLXSW_ITEM32(reg, pmtdb, num_ports, 0x00, 8, 4);\n\nenum mlxsw_reg_pmtdb_status {\n\tMLXSW_REG_PMTDB_STATUS_SUCCESS,\n};\n\n \nMLXSW_ITEM32(reg, pmtdb, status, 0x00, 0, 4);\n\n \nMLXSW_ITEM16_INDEXED(reg, pmtdb, port_num, 0x04, 0, 10, 0x02, 0x00, false);\n\nstatic inline void mlxsw_reg_pmtdb_pack(char *payload, u8 slot_index, u8 module,\n\t\t\t\t\tu8 ports_width, u8 num_ports)\n{\n\tMLXSW_REG_ZERO(pmtdb, payload);\n\tmlxsw_reg_pmtdb_slot_index_set(payload, slot_index);\n\tmlxsw_reg_pmtdb_module_set(payload, module);\n\tmlxsw_reg_pmtdb_ports_width_set(payload, ports_width);\n\tmlxsw_reg_pmtdb_num_ports_set(payload, num_ports);\n}\n\n \n#define MLXSW_REG_PMECR_ID 0x501B\n#define MLXSW_REG_PMECR_LEN 0x20\n\nMLXSW_REG_DEFINE(pmecr, MLXSW_REG_PMECR_ID, MLXSW_REG_PMECR_LEN);\n\n \nMLXSW_ITEM32_LP(reg, pmecr, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, pmecr, ee, 0x04, 30, 1);\n\n \nMLXSW_ITEM32(reg, pmecr, eswi, 0x04, 24, 1);\n\n \nMLXSW_ITEM32(reg, pmecr, swi, 0x04, 8, 1);\n\nenum mlxsw_reg_pmecr_e {\n\tMLXSW_REG_PMECR_E_DO_NOT_GENERATE_EVENT,\n\tMLXSW_REG_PMECR_E_GENERATE_EVENT,\n\tMLXSW_REG_PMECR_E_GENERATE_SINGLE_EVENT,\n};\n\n \nMLXSW_ITEM32(reg, pmecr, e, 0x04, 0, 2);\n\nstatic inline void mlxsw_reg_pmecr_pack(char *payload, u16 local_port,\n\t\t\t\t\tenum mlxsw_reg_pmecr_e e)\n{\n\tMLXSW_REG_ZERO(pmecr, payload);\n\tmlxsw_reg_pmecr_local_port_set(payload, local_port);\n\tmlxsw_reg_pmecr_e_set(payload, e);\n\tmlxsw_reg_pmecr_ee_set(payload, true);\n\tmlxsw_reg_pmecr_swi_set(payload, true);\n\tmlxsw_reg_pmecr_eswi_set(payload, true);\n}\n\n \n#define MLXSW_REG_PMPE_ID 0x5024\n#define MLXSW_REG_PMPE_LEN 0x10\n\nMLXSW_REG_DEFINE(pmpe, MLXSW_REG_PMPE_ID, MLXSW_REG_PMPE_LEN);\n\n \nMLXSW_ITEM32(reg, pmpe, slot_index, 0x00, 24, 4);\n\n \nMLXSW_ITEM32(reg, pmpe, module, 0x00, 16, 8);\n\nenum mlxsw_reg_pmpe_module_status {\n\tMLXSW_REG_PMPE_MODULE_STATUS_PLUGGED_ENABLED = 1,\n\tMLXSW_REG_PMPE_MODULE_STATUS_UNPLUGGED,\n\tMLXSW_REG_PMPE_MODULE_STATUS_PLUGGED_ERROR,\n\tMLXSW_REG_PMPE_MODULE_STATUS_PLUGGED_DISABLED,\n};\n\n \nMLXSW_ITEM32(reg, pmpe, module_status, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, pmpe, error_type, 0x04, 8, 4);\n\n \n#define MLXSW_REG_PDDR_ID 0x5031\n#define MLXSW_REG_PDDR_LEN 0x100\n\nMLXSW_REG_DEFINE(pddr, MLXSW_REG_PDDR_ID, MLXSW_REG_PDDR_LEN);\n\n \nMLXSW_ITEM32_LP(reg, pddr, 0x00, 16, 0x00, 12);\n\nenum mlxsw_reg_pddr_page_select {\n\tMLXSW_REG_PDDR_PAGE_SELECT_TROUBLESHOOTING_INFO = 1,\n};\n\n \nMLXSW_ITEM32(reg, pddr, page_select, 0x04, 0, 8);\n\nenum mlxsw_reg_pddr_trblsh_group_opcode {\n\t \n\tMLXSW_REG_PDDR_TRBLSH_GROUP_OPCODE_MONITOR,\n};\n\n \nMLXSW_ITEM32(reg, pddr, trblsh_group_opcode, 0x08, 0, 16);\n\n \nMLXSW_ITEM32(reg, pddr, trblsh_status_opcode, 0x0C, 0, 16);\n\nstatic inline void mlxsw_reg_pddr_pack(char *payload, u16 local_port,\n\t\t\t\t       u8 page_select)\n{\n\tMLXSW_REG_ZERO(pddr, payload);\n\tmlxsw_reg_pddr_local_port_set(payload, local_port);\n\tmlxsw_reg_pddr_page_select_set(payload, page_select);\n}\n\n \n#define MLXSW_REG_PMMP_ID 0x5044\n#define MLXSW_REG_PMMP_LEN 0x2C\n\nMLXSW_REG_DEFINE(pmmp, MLXSW_REG_PMMP_ID, MLXSW_REG_PMMP_LEN);\n\n \nMLXSW_ITEM32(reg, pmmp, module, 0x00, 16, 8);\n\n \nMLXSW_ITEM32(reg, pmmp, slot_index, 0x00, 24, 4);\n\n \nMLXSW_ITEM32(reg, pmmp, sticky, 0x00, 0, 1);\n\n \nMLXSW_ITEM32(reg, pmmp, eeprom_override_mask, 0x04, 16, 16);\n\nenum {\n\t \n\tMLXSW_REG_PMMP_EEPROM_OVERRIDE_LOW_POWER_MASK = BIT(8),\n};\n\n \nMLXSW_ITEM32(reg, pmmp, eeprom_override, 0x04, 0, 16);\n\nstatic inline void mlxsw_reg_pmmp_pack(char *payload, u8 slot_index, u8 module)\n{\n\tMLXSW_REG_ZERO(pmmp, payload);\n\tmlxsw_reg_pmmp_slot_index_set(payload, slot_index);\n\tmlxsw_reg_pmmp_module_set(payload, module);\n}\n\n \n#define MLXSW_REG_PLLP_ID 0x504A\n#define MLXSW_REG_PLLP_LEN 0x10\n\nMLXSW_REG_DEFINE(pllp, MLXSW_REG_PLLP_ID, MLXSW_REG_PLLP_LEN);\n\n \nMLXSW_ITEM32_LP(reg, pllp, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, pllp, label_port, 0x00, 0, 8);\n\n \nMLXSW_ITEM32(reg, pllp, split_num, 0x04, 0, 4);\n\n \nMLXSW_ITEM32(reg, pllp, slot_index, 0x08, 0, 4);\n\nstatic inline void mlxsw_reg_pllp_pack(char *payload, u16 local_port)\n{\n\tMLXSW_REG_ZERO(pllp, payload);\n\tmlxsw_reg_pllp_local_port_set(payload, local_port);\n}\n\nstatic inline void mlxsw_reg_pllp_unpack(char *payload, u8 *label_port,\n\t\t\t\t\t u8 *split_num, u8 *slot_index)\n{\n\t*label_port = mlxsw_reg_pllp_label_port_get(payload);\n\t*split_num = mlxsw_reg_pllp_split_num_get(payload);\n\t*slot_index = mlxsw_reg_pllp_slot_index_get(payload);\n}\n\n \n#define MLXSW_REG_PMTM_ID 0x5067\n#define MLXSW_REG_PMTM_LEN 0x10\n\nMLXSW_REG_DEFINE(pmtm, MLXSW_REG_PMTM_ID, MLXSW_REG_PMTM_LEN);\n\n \nMLXSW_ITEM32(reg, pmtm, slot_index, 0x00, 24, 4);\n\n \nMLXSW_ITEM32(reg, pmtm, module, 0x00, 16, 8);\n\nenum mlxsw_reg_pmtm_module_type {\n\tMLXSW_REG_PMTM_MODULE_TYPE_BACKPLANE_4_LANES = 0,\n\tMLXSW_REG_PMTM_MODULE_TYPE_QSFP = 1,\n\tMLXSW_REG_PMTM_MODULE_TYPE_SFP = 2,\n\tMLXSW_REG_PMTM_MODULE_TYPE_BACKPLANE_SINGLE_LANE = 4,\n\tMLXSW_REG_PMTM_MODULE_TYPE_BACKPLANE_2_LANES = 8,\n\tMLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP4X = 10,\n\tMLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP2X = 11,\n\tMLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP1X = 12,\n\tMLXSW_REG_PMTM_MODULE_TYPE_QSFP_DD = 14,\n\tMLXSW_REG_PMTM_MODULE_TYPE_OSFP = 15,\n\tMLXSW_REG_PMTM_MODULE_TYPE_SFP_DD = 16,\n\tMLXSW_REG_PMTM_MODULE_TYPE_DSFP = 17,\n\tMLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP8X = 18,\n\tMLXSW_REG_PMTM_MODULE_TYPE_TWISTED_PAIR = 19,\n};\n\n \nMLXSW_ITEM32(reg, pmtm, module_type, 0x04, 0, 5);\n\nstatic inline void mlxsw_reg_pmtm_pack(char *payload, u8 slot_index, u8 module)\n{\n\tMLXSW_REG_ZERO(pmtm, payload);\n\tmlxsw_reg_pmtm_slot_index_set(payload, slot_index);\n\tmlxsw_reg_pmtm_module_set(payload, module);\n}\n\n \n#define MLXSW_REG_HTGT_ID 0x7002\n#define MLXSW_REG_HTGT_LEN 0x20\n\nMLXSW_REG_DEFINE(htgt, MLXSW_REG_HTGT_ID, MLXSW_REG_HTGT_LEN);\n\n \nMLXSW_ITEM32(reg, htgt, swid, 0x00, 24, 8);\n\n#define MLXSW_REG_HTGT_PATH_TYPE_LOCAL 0x0\t \n\n \nMLXSW_ITEM32(reg, htgt, type, 0x00, 8, 4);\n\nenum mlxsw_reg_htgt_trap_group {\n\tMLXSW_REG_HTGT_TRAP_GROUP_EMAD,\n\tMLXSW_REG_HTGT_TRAP_GROUP_CORE_EVENT,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_STP,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_LACP,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_LLDP,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_MC_SNOOPING,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_BGP,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_OSPF,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_PIM,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_MULTICAST,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_NEIGH_DISCOVERY,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_ROUTER_EXP,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_EXTERNAL_ROUTE,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_IP2ME,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_DHCP,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_EVENT,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_IPV6,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_LBERROR,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_PTP0,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_PTP1,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_VRRP,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_PKT_SAMPLE,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_FLOW_LOGGING,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_FID_MISS,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_BFD,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_DUMMY,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_L2_DISCARDS,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_L3_DISCARDS,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_L3_EXCEPTIONS,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_TUNNEL_DISCARDS,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_ACL_DISCARDS,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_BUFFER_DISCARDS,\n\tMLXSW_REG_HTGT_TRAP_GROUP_SP_EAPOL,\n\n\t__MLXSW_REG_HTGT_TRAP_GROUP_MAX,\n\tMLXSW_REG_HTGT_TRAP_GROUP_MAX = __MLXSW_REG_HTGT_TRAP_GROUP_MAX - 1\n};\n\n \nMLXSW_ITEM32(reg, htgt, trap_group, 0x00, 0, 8);\n\nenum {\n\tMLXSW_REG_HTGT_POLICER_DISABLE,\n\tMLXSW_REG_HTGT_POLICER_ENABLE,\n};\n\n \nMLXSW_ITEM32(reg, htgt, pide, 0x04, 15, 1);\n\n#define MLXSW_REG_HTGT_INVALID_POLICER 0xff\n\n \nMLXSW_ITEM32(reg, htgt, pid, 0x04, 0, 8);\n\n#define MLXSW_REG_HTGT_TRAP_TO_CPU 0x0\n\n \nMLXSW_ITEM32(reg, htgt, mirror_action, 0x08, 8, 2);\n\n \nMLXSW_ITEM32(reg, htgt, mirroring_agent, 0x08, 0, 3);\n\n#define MLXSW_REG_HTGT_DEFAULT_PRIORITY 0\n\n \nMLXSW_ITEM32(reg, htgt, priority, 0x0C, 0, 4);\n\n#define MLXSW_REG_HTGT_DEFAULT_TC 7\n\n \nMLXSW_ITEM32(reg, htgt, local_path_cpu_tclass, 0x10, 16, 6);\n\nenum mlxsw_reg_htgt_local_path_rdq {\n\tMLXSW_REG_HTGT_LOCAL_PATH_RDQ_SX2_CTRL = 0x13,\n\tMLXSW_REG_HTGT_LOCAL_PATH_RDQ_SX2_RX = 0x14,\n\tMLXSW_REG_HTGT_LOCAL_PATH_RDQ_SX2_EMAD = 0x15,\n\tMLXSW_REG_HTGT_LOCAL_PATH_RDQ_SIB_EMAD = 0x15,\n};\n \nMLXSW_ITEM32(reg, htgt, local_path_rdq, 0x10, 0, 6);\n\nstatic inline void mlxsw_reg_htgt_pack(char *payload, u8 group, u8 policer_id,\n\t\t\t\t       u8 priority, u8 tc)\n{\n\tMLXSW_REG_ZERO(htgt, payload);\n\n\tif (policer_id == MLXSW_REG_HTGT_INVALID_POLICER) {\n\t\tmlxsw_reg_htgt_pide_set(payload,\n\t\t\t\t\tMLXSW_REG_HTGT_POLICER_DISABLE);\n\t} else {\n\t\tmlxsw_reg_htgt_pide_set(payload,\n\t\t\t\t\tMLXSW_REG_HTGT_POLICER_ENABLE);\n\t\tmlxsw_reg_htgt_pid_set(payload, policer_id);\n\t}\n\n\tmlxsw_reg_htgt_type_set(payload, MLXSW_REG_HTGT_PATH_TYPE_LOCAL);\n\tmlxsw_reg_htgt_trap_group_set(payload, group);\n\tmlxsw_reg_htgt_mirror_action_set(payload, MLXSW_REG_HTGT_TRAP_TO_CPU);\n\tmlxsw_reg_htgt_mirroring_agent_set(payload, 0);\n\tmlxsw_reg_htgt_priority_set(payload, priority);\n\tmlxsw_reg_htgt_local_path_cpu_tclass_set(payload, tc);\n\tmlxsw_reg_htgt_local_path_rdq_set(payload, group);\n}\n\n \n#define MLXSW_REG_HPKT_ID 0x7003\n#define MLXSW_REG_HPKT_LEN 0x10\n\nMLXSW_REG_DEFINE(hpkt, MLXSW_REG_HPKT_ID, MLXSW_REG_HPKT_LEN);\n\nenum {\n\tMLXSW_REG_HPKT_ACK_NOT_REQUIRED,\n\tMLXSW_REG_HPKT_ACK_REQUIRED,\n};\n\n \nMLXSW_ITEM32(reg, hpkt, ack, 0x00, 24, 1);\n\nenum mlxsw_reg_hpkt_action {\n\tMLXSW_REG_HPKT_ACTION_FORWARD,\n\tMLXSW_REG_HPKT_ACTION_TRAP_TO_CPU,\n\tMLXSW_REG_HPKT_ACTION_MIRROR_TO_CPU,\n\tMLXSW_REG_HPKT_ACTION_DISCARD,\n\tMLXSW_REG_HPKT_ACTION_SOFT_DISCARD,\n\tMLXSW_REG_HPKT_ACTION_TRAP_AND_SOFT_DISCARD,\n\tMLXSW_REG_HPKT_ACTION_TRAP_EXCEPTION_TO_CPU,\n\tMLXSW_REG_HPKT_ACTION_SET_FW_DEFAULT = 15,\n};\n\n \nMLXSW_ITEM32(reg, hpkt, action, 0x00, 20, 3);\n\n \nMLXSW_ITEM32(reg, hpkt, trap_group, 0x00, 12, 6);\n\n \nMLXSW_ITEM32(reg, hpkt, trap_id, 0x00, 0, 10);\n\nenum {\n\tMLXSW_REG_HPKT_CTRL_PACKET_DEFAULT,\n\tMLXSW_REG_HPKT_CTRL_PACKET_NO_BUFFER,\n\tMLXSW_REG_HPKT_CTRL_PACKET_USE_BUFFER,\n};\n\n \nMLXSW_ITEM32(reg, hpkt, ctrl, 0x04, 16, 2);\n\nstatic inline void mlxsw_reg_hpkt_pack(char *payload, u8 action, u16 trap_id,\n\t\t\t\t       enum mlxsw_reg_htgt_trap_group trap_group,\n\t\t\t\t       bool is_ctrl)\n{\n\tMLXSW_REG_ZERO(hpkt, payload);\n\tmlxsw_reg_hpkt_ack_set(payload, MLXSW_REG_HPKT_ACK_NOT_REQUIRED);\n\tmlxsw_reg_hpkt_action_set(payload, action);\n\tmlxsw_reg_hpkt_trap_group_set(payload, trap_group);\n\tmlxsw_reg_hpkt_trap_id_set(payload, trap_id);\n\tmlxsw_reg_hpkt_ctrl_set(payload, is_ctrl ?\n\t\t\t\tMLXSW_REG_HPKT_CTRL_PACKET_USE_BUFFER :\n\t\t\t\tMLXSW_REG_HPKT_CTRL_PACKET_NO_BUFFER);\n}\n\n \n#define MLXSW_REG_RGCR_ID 0x8001\n#define MLXSW_REG_RGCR_LEN 0x28\n\nMLXSW_REG_DEFINE(rgcr, MLXSW_REG_RGCR_ID, MLXSW_REG_RGCR_LEN);\n\n \nMLXSW_ITEM32(reg, rgcr, ipv4_en, 0x00, 31, 1);\n\n \nMLXSW_ITEM32(reg, rgcr, ipv6_en, 0x00, 30, 1);\n\n \nMLXSW_ITEM32(reg, rgcr, max_router_interfaces, 0x10, 0, 16);\n\n \nMLXSW_ITEM32(reg, rgcr, usp, 0x18, 20, 1);\n\n \nMLXSW_ITEM32(reg, rgcr, pcp_rw, 0x18, 16, 2);\n\n \nMLXSW_ITEM32(reg, rgcr, activity_dis, 0x20, 0, 8);\n\nstatic inline void mlxsw_reg_rgcr_pack(char *payload, bool ipv4_en,\n\t\t\t\t       bool ipv6_en)\n{\n\tMLXSW_REG_ZERO(rgcr, payload);\n\tmlxsw_reg_rgcr_ipv4_en_set(payload, ipv4_en);\n\tmlxsw_reg_rgcr_ipv6_en_set(payload, ipv6_en);\n}\n\n \n#define MLXSW_REG_RITR_ID 0x8002\n#define MLXSW_REG_RITR_LEN 0x40\n\nMLXSW_REG_DEFINE(ritr, MLXSW_REG_RITR_ID, MLXSW_REG_RITR_LEN);\n\n \nMLXSW_ITEM32(reg, ritr, enable, 0x00, 31, 1);\n\n \nMLXSW_ITEM32(reg, ritr, ipv4, 0x00, 29, 1);\n\n \nMLXSW_ITEM32(reg, ritr, ipv6, 0x00, 28, 1);\n\n \nMLXSW_ITEM32(reg, ritr, ipv4_mc, 0x00, 27, 1);\n\n \nMLXSW_ITEM32(reg, ritr, ipv6_mc, 0x00, 26, 1);\n\nenum mlxsw_reg_ritr_if_type {\n\t \n\tMLXSW_REG_RITR_VLAN_IF,\n\t \n\tMLXSW_REG_RITR_FID_IF,\n\t \n\tMLXSW_REG_RITR_SP_IF,\n\t \n\tMLXSW_REG_RITR_LOOPBACK_IF,\n};\n\n \nMLXSW_ITEM32(reg, ritr, type, 0x00, 23, 3);\n\nenum {\n\tMLXSW_REG_RITR_RIF_CREATE,\n\tMLXSW_REG_RITR_RIF_DEL,\n};\n\n \nMLXSW_ITEM32(reg, ritr, op, 0x00, 20, 2);\n\n \nMLXSW_ITEM32(reg, ritr, rif, 0x00, 0, 16);\n\n \nMLXSW_ITEM32(reg, ritr, ipv4_fe, 0x04, 29, 1);\n\n \nMLXSW_ITEM32(reg, ritr, ipv6_fe, 0x04, 28, 1);\n\n \nMLXSW_ITEM32(reg, ritr, ipv4_mc_fe, 0x04, 27, 1);\n\n \nMLXSW_ITEM32(reg, ritr, ipv6_mc_fe, 0x04, 26, 1);\n\n \nMLXSW_ITEM32(reg, ritr, lb_en, 0x04, 24, 1);\n\n \nMLXSW_ITEM32(reg, ritr, virtual_router, 0x04, 0, 16);\n\n \nMLXSW_ITEM32(reg, ritr, mtu, 0x34, 0, 16);\n\n \nMLXSW_ITEM32(reg, ritr, if_swid, 0x08, 24, 8);\n\n \nMLXSW_ITEM32(reg, ritr, if_mac_profile_id, 0x10, 16, 4);\n\n \nMLXSW_ITEM_BUF(reg, ritr, if_mac, 0x12, 6);\n\n \nMLXSW_ITEM32(reg, ritr, if_vrrp_id_ipv6, 0x1C, 8, 8);\n\n \nMLXSW_ITEM32(reg, ritr, if_vrrp_id_ipv4, 0x1C, 0, 8);\n\n \n\n \nMLXSW_ITEM32(reg, ritr, vlan_if_vlan_id, 0x08, 0, 12);\n\n \nMLXSW_ITEM32(reg, ritr, vlan_if_efid, 0x0C, 0, 16);\n\n \n\n \nMLXSW_ITEM32(reg, ritr, fid_if_fid, 0x08, 0, 16);\n\n \n\n \nMLXSW_ITEM32(reg, ritr, sp_if_lag, 0x08, 24, 1);\n\n \nMLXSW_ITEM32(reg, ritr, sp_if_system_port, 0x08, 0, 16);\n\n \nMLXSW_ITEM32(reg, ritr, sp_if_efid, 0x0C, 0, 16);\n\n \nMLXSW_ITEM32(reg, ritr, sp_if_vid, 0x18, 0, 12);\n\n \n\nenum mlxsw_reg_ritr_loopback_protocol {\n\t \n\tMLXSW_REG_RITR_LOOPBACK_PROTOCOL_IPIP_IPV4,\n\t \n\tMLXSW_REG_RITR_LOOPBACK_PROTOCOL_IPIP_IPV6,\n\t \n\tMLXSW_REG_RITR_LOOPBACK_GENERIC,\n};\n\n \nMLXSW_ITEM32(reg, ritr, loopback_protocol, 0x08, 28, 4);\n\nenum mlxsw_reg_ritr_loopback_ipip_type {\n\t \n\tMLXSW_REG_RITR_LOOPBACK_IPIP_TYPE_IP_IN_IP,\n\t \n\tMLXSW_REG_RITR_LOOPBACK_IPIP_TYPE_IP_IN_GRE_IN_IP,\n\t \n\tMLXSW_REG_RITR_LOOPBACK_IPIP_TYPE_IP_IN_GRE_KEY_IN_IP,\n};\n\n \nMLXSW_ITEM32(reg, ritr, loopback_ipip_type, 0x10, 24, 4);\n\nenum mlxsw_reg_ritr_loopback_ipip_options {\n\t \n\tMLXSW_REG_RITR_LOOPBACK_IPIP_OPTIONS_GRE_KEY_PRESET,\n};\n\n \nMLXSW_ITEM32(reg, ritr, loopback_ipip_options, 0x10, 20, 4);\n\n \nMLXSW_ITEM32(reg, ritr, loopback_ipip_uvr, 0x10, 0, 16);\n\n \nMLXSW_ITEM32(reg, ritr, loopback_ipip_underlay_rif, 0x14, 0, 16);\n\n \nMLXSW_ITEM_BUF(reg, ritr, loopback_ipip_usip6, 0x18, 16);\nMLXSW_ITEM32(reg, ritr, loopback_ipip_usip4, 0x24, 0, 32);\n\n \nMLXSW_ITEM32(reg, ritr, loopback_ipip_gre_key, 0x28, 0, 32);\n\n \nenum mlxsw_reg_ritr_counter_set_type {\n\t \n\tMLXSW_REG_RITR_COUNTER_SET_TYPE_NO_COUNT = 0x0,\n\t \n\tMLXSW_REG_RITR_COUNTER_SET_TYPE_BASIC = 0x9,\n};\n\n \nMLXSW_ITEM32(reg, ritr, ingress_counter_index, 0x38, 0, 24);\n\n \nMLXSW_ITEM32(reg, ritr, ingress_counter_set_type, 0x38, 24, 8);\n\n \nMLXSW_ITEM32(reg, ritr, egress_counter_index, 0x3C, 0, 24);\n\n \nMLXSW_ITEM32(reg, ritr, egress_counter_set_type, 0x3C, 24, 8);\n\nstatic inline void mlxsw_reg_ritr_counter_pack(char *payload, u32 index,\n\t\t\t\t\t       bool enable, bool egress)\n{\n\tenum mlxsw_reg_ritr_counter_set_type set_type;\n\n\tif (enable)\n\t\tset_type = MLXSW_REG_RITR_COUNTER_SET_TYPE_BASIC;\n\telse\n\t\tset_type = MLXSW_REG_RITR_COUNTER_SET_TYPE_NO_COUNT;\n\n\tif (egress) {\n\t\tmlxsw_reg_ritr_egress_counter_set_type_set(payload, set_type);\n\t\tmlxsw_reg_ritr_egress_counter_index_set(payload, index);\n\t} else {\n\t\tmlxsw_reg_ritr_ingress_counter_set_type_set(payload, set_type);\n\t\tmlxsw_reg_ritr_ingress_counter_index_set(payload, index);\n\t}\n}\n\nstatic inline void mlxsw_reg_ritr_rif_pack(char *payload, u16 rif)\n{\n\tMLXSW_REG_ZERO(ritr, payload);\n\tmlxsw_reg_ritr_rif_set(payload, rif);\n}\n\nstatic inline void mlxsw_reg_ritr_sp_if_pack(char *payload, bool lag,\n\t\t\t\t\t     u16 system_port, u16 efid, u16 vid)\n{\n\tmlxsw_reg_ritr_sp_if_lag_set(payload, lag);\n\tmlxsw_reg_ritr_sp_if_system_port_set(payload, system_port);\n\tmlxsw_reg_ritr_sp_if_efid_set(payload, efid);\n\tmlxsw_reg_ritr_sp_if_vid_set(payload, vid);\n}\n\nstatic inline void mlxsw_reg_ritr_pack(char *payload, bool enable,\n\t\t\t\t       enum mlxsw_reg_ritr_if_type type,\n\t\t\t\t       u16 rif, u16 vr_id, u16 mtu)\n{\n\tbool op = enable ? MLXSW_REG_RITR_RIF_CREATE : MLXSW_REG_RITR_RIF_DEL;\n\n\tMLXSW_REG_ZERO(ritr, payload);\n\tmlxsw_reg_ritr_enable_set(payload, enable);\n\tmlxsw_reg_ritr_ipv4_set(payload, 1);\n\tmlxsw_reg_ritr_ipv6_set(payload, 1);\n\tmlxsw_reg_ritr_ipv4_mc_set(payload, 1);\n\tmlxsw_reg_ritr_ipv6_mc_set(payload, 1);\n\tmlxsw_reg_ritr_type_set(payload, type);\n\tmlxsw_reg_ritr_op_set(payload, op);\n\tmlxsw_reg_ritr_rif_set(payload, rif);\n\tmlxsw_reg_ritr_ipv4_fe_set(payload, 1);\n\tmlxsw_reg_ritr_ipv6_fe_set(payload, 1);\n\tmlxsw_reg_ritr_ipv4_mc_fe_set(payload, 1);\n\tmlxsw_reg_ritr_ipv6_mc_fe_set(payload, 1);\n\tmlxsw_reg_ritr_lb_en_set(payload, 1);\n\tmlxsw_reg_ritr_virtual_router_set(payload, vr_id);\n\tmlxsw_reg_ritr_mtu_set(payload, mtu);\n}\n\nstatic inline void mlxsw_reg_ritr_mac_pack(char *payload, const char *mac)\n{\n\tmlxsw_reg_ritr_if_mac_memcpy_to(payload, mac);\n}\n\nstatic inline void\nmlxsw_reg_ritr_vlan_if_pack(char *payload, bool enable, u16 rif, u16 vr_id,\n\t\t\t    u16 mtu, const char *mac, u8 mac_profile_id,\n\t\t\t    u16 vlan_id, u16 efid)\n{\n\tenum mlxsw_reg_ritr_if_type type = MLXSW_REG_RITR_VLAN_IF;\n\n\tmlxsw_reg_ritr_pack(payload, enable, type, rif, vr_id, mtu);\n\tmlxsw_reg_ritr_if_mac_memcpy_to(payload, mac);\n\tmlxsw_reg_ritr_if_mac_profile_id_set(payload, mac_profile_id);\n\tmlxsw_reg_ritr_vlan_if_vlan_id_set(payload, vlan_id);\n\tmlxsw_reg_ritr_vlan_if_efid_set(payload, efid);\n}\n\nstatic inline void\nmlxsw_reg_ritr_loopback_ipip_common_pack(char *payload,\n\t\t\t    enum mlxsw_reg_ritr_loopback_ipip_type ipip_type,\n\t\t\t    enum mlxsw_reg_ritr_loopback_ipip_options options,\n\t\t\t    u16 uvr_id, u16 underlay_rif, u32 gre_key)\n{\n\tmlxsw_reg_ritr_loopback_ipip_type_set(payload, ipip_type);\n\tmlxsw_reg_ritr_loopback_ipip_options_set(payload, options);\n\tmlxsw_reg_ritr_loopback_ipip_uvr_set(payload, uvr_id);\n\tmlxsw_reg_ritr_loopback_ipip_underlay_rif_set(payload, underlay_rif);\n\tmlxsw_reg_ritr_loopback_ipip_gre_key_set(payload, gre_key);\n}\n\nstatic inline void\nmlxsw_reg_ritr_loopback_ipip4_pack(char *payload,\n\t\t\t    enum mlxsw_reg_ritr_loopback_ipip_type ipip_type,\n\t\t\t    enum mlxsw_reg_ritr_loopback_ipip_options options,\n\t\t\t    u16 uvr_id, u16 underlay_rif, u32 usip, u32 gre_key)\n{\n\tmlxsw_reg_ritr_loopback_protocol_set(payload,\n\t\t\t\t    MLXSW_REG_RITR_LOOPBACK_PROTOCOL_IPIP_IPV4);\n\tmlxsw_reg_ritr_loopback_ipip_common_pack(payload, ipip_type, options,\n\t\t\t\t\t\t uvr_id, underlay_rif, gre_key);\n\tmlxsw_reg_ritr_loopback_ipip_usip4_set(payload, usip);\n}\n\nstatic inline void\nmlxsw_reg_ritr_loopback_ipip6_pack(char *payload,\n\t\t\t\t   enum mlxsw_reg_ritr_loopback_ipip_type ipip_type,\n\t\t\t\t   enum mlxsw_reg_ritr_loopback_ipip_options options,\n\t\t\t\t   u16 uvr_id, u16 underlay_rif,\n\t\t\t\t   const struct in6_addr *usip, u32 gre_key)\n{\n\tenum mlxsw_reg_ritr_loopback_protocol protocol =\n\t\tMLXSW_REG_RITR_LOOPBACK_PROTOCOL_IPIP_IPV6;\n\n\tmlxsw_reg_ritr_loopback_protocol_set(payload, protocol);\n\tmlxsw_reg_ritr_loopback_ipip_common_pack(payload, ipip_type, options,\n\t\t\t\t\t\t uvr_id, underlay_rif, gre_key);\n\tmlxsw_reg_ritr_loopback_ipip_usip6_memcpy_to(payload,\n\t\t\t\t\t\t     (const char *)usip);\n}\n\n \n#define MLXSW_REG_RTAR_ID 0x8004\n#define MLXSW_REG_RTAR_LEN 0x20\n\nMLXSW_REG_DEFINE(rtar, MLXSW_REG_RTAR_ID, MLXSW_REG_RTAR_LEN);\n\nenum mlxsw_reg_rtar_op {\n\tMLXSW_REG_RTAR_OP_ALLOCATE,\n\tMLXSW_REG_RTAR_OP_RESIZE,\n\tMLXSW_REG_RTAR_OP_DEALLOCATE,\n};\n\n \nMLXSW_ITEM32(reg, rtar, op, 0x00, 28, 4);\n\nenum mlxsw_reg_rtar_key_type {\n\tMLXSW_REG_RTAR_KEY_TYPE_IPV4_MULTICAST = 1,\n\tMLXSW_REG_RTAR_KEY_TYPE_IPV6_MULTICAST = 3\n};\n\n \nMLXSW_ITEM32(reg, rtar, key_type, 0x00, 0, 8);\n\n \nMLXSW_ITEM32(reg, rtar, region_size, 0x04, 0, 16);\n\nstatic inline void mlxsw_reg_rtar_pack(char *payload,\n\t\t\t\t       enum mlxsw_reg_rtar_op op,\n\t\t\t\t       enum mlxsw_reg_rtar_key_type key_type,\n\t\t\t\t       u16 region_size)\n{\n\tMLXSW_REG_ZERO(rtar, payload);\n\tmlxsw_reg_rtar_op_set(payload, op);\n\tmlxsw_reg_rtar_key_type_set(payload, key_type);\n\tmlxsw_reg_rtar_region_size_set(payload, region_size);\n}\n\n \n#define MLXSW_REG_RATR_ID 0x8008\n#define MLXSW_REG_RATR_LEN 0x2C\n\nMLXSW_REG_DEFINE(ratr, MLXSW_REG_RATR_ID, MLXSW_REG_RATR_LEN);\n\nenum mlxsw_reg_ratr_op {\n\t \n\tMLXSW_REG_RATR_OP_QUERY_READ = 0,\n\t \n\tMLXSW_REG_RATR_OP_QUERY_READ_CLEAR = 2,\n\t \n\tMLXSW_REG_RATR_OP_WRITE_WRITE_ENTRY = 1,\n\t \n\tMLXSW_REG_RATR_OP_WRITE_WRITE_ENTRY_ON_ACTIVITY = 3,\n};\n\n \nMLXSW_ITEM32(reg, ratr, op, 0x00, 28, 4);\n\n \nMLXSW_ITEM32(reg, ratr, v, 0x00, 24, 1);\n\n \nMLXSW_ITEM32(reg, ratr, a, 0x00, 16, 1);\n\nenum mlxsw_reg_ratr_type {\n\t \n\tMLXSW_REG_RATR_TYPE_ETHERNET,\n\t \n\tMLXSW_REG_RATR_TYPE_IPOIB_UC,\n\t \n\tMLXSW_REG_RATR_TYPE_IPOIB_UC_W_GRH,\n\t \n\tMLXSW_REG_RATR_TYPE_IPOIB_MC,\n\t \n\tMLXSW_REG_RATR_TYPE_MPLS,\n\t \n\tMLXSW_REG_RATR_TYPE_IPIP,\n};\n\n \nMLXSW_ITEM32(reg, ratr, type, 0x04, 28, 4);\n\n \nMLXSW_ITEM32(reg, ratr, adjacency_index_low, 0x04, 0, 16);\n\n \nMLXSW_ITEM32(reg, ratr, egress_router_interface, 0x08, 0, 16);\n\nenum mlxsw_reg_ratr_trap_action {\n\tMLXSW_REG_RATR_TRAP_ACTION_NOP,\n\tMLXSW_REG_RATR_TRAP_ACTION_TRAP,\n\tMLXSW_REG_RATR_TRAP_ACTION_MIRROR_TO_CPU,\n\tMLXSW_REG_RATR_TRAP_ACTION_MIRROR,\n\tMLXSW_REG_RATR_TRAP_ACTION_DISCARD_ERRORS,\n};\n\n \nMLXSW_ITEM32(reg, ratr, trap_action, 0x0C, 28, 4);\n\n \nMLXSW_ITEM32(reg, ratr, adjacency_index_high, 0x0C, 16, 8);\n\nenum mlxsw_reg_ratr_trap_id {\n\tMLXSW_REG_RATR_TRAP_ID_RTR_EGRESS0,\n\tMLXSW_REG_RATR_TRAP_ID_RTR_EGRESS1,\n};\n\n \nMLXSW_ITEM32(reg, ratr, trap_id, 0x0C, 0, 8);\n\n \nMLXSW_ITEM_BUF(reg, ratr, eth_destination_mac, 0x12, 6);\n\nenum mlxsw_reg_ratr_ipip_type {\n\t \n\tMLXSW_REG_RATR_IPIP_TYPE_IPV4,\n\t \n\tMLXSW_REG_RATR_IPIP_TYPE_IPV6,\n};\n\n \nMLXSW_ITEM32(reg, ratr, ipip_type, 0x10, 16, 4);\n\n \nMLXSW_ITEM32(reg, ratr, ipip_ipv4_udip, 0x18, 0, 32);\n\n \nMLXSW_ITEM32(reg, ratr, ipip_ipv6_ptr, 0x1C, 0, 24);\n\nenum mlxsw_reg_flow_counter_set_type {\n\t \n\tMLXSW_REG_FLOW_COUNTER_SET_TYPE_NO_COUNT = 0x00,\n\t \n\tMLXSW_REG_FLOW_COUNTER_SET_TYPE_PACKETS_BYTES = 0x03,\n\t \n\tMLXSW_REG_FLOW_COUNTER_SET_TYPE_PACKETS = 0x05,\n};\n\n \nMLXSW_ITEM32(reg, ratr, counter_set_type, 0x28, 24, 8);\n\n \nMLXSW_ITEM32(reg, ratr, counter_index, 0x28, 0, 24);\n\nstatic inline void\nmlxsw_reg_ratr_pack(char *payload,\n\t\t    enum mlxsw_reg_ratr_op op, bool valid,\n\t\t    enum mlxsw_reg_ratr_type type,\n\t\t    u32 adjacency_index, u16 egress_rif)\n{\n\tMLXSW_REG_ZERO(ratr, payload);\n\tmlxsw_reg_ratr_op_set(payload, op);\n\tmlxsw_reg_ratr_v_set(payload, valid);\n\tmlxsw_reg_ratr_type_set(payload, type);\n\tmlxsw_reg_ratr_adjacency_index_low_set(payload, adjacency_index);\n\tmlxsw_reg_ratr_adjacency_index_high_set(payload, adjacency_index >> 16);\n\tmlxsw_reg_ratr_egress_router_interface_set(payload, egress_rif);\n}\n\nstatic inline void mlxsw_reg_ratr_eth_entry_pack(char *payload,\n\t\t\t\t\t\t const char *dest_mac)\n{\n\tmlxsw_reg_ratr_eth_destination_mac_memcpy_to(payload, dest_mac);\n}\n\nstatic inline void mlxsw_reg_ratr_ipip4_entry_pack(char *payload, u32 ipv4_udip)\n{\n\tmlxsw_reg_ratr_ipip_type_set(payload, MLXSW_REG_RATR_IPIP_TYPE_IPV4);\n\tmlxsw_reg_ratr_ipip_ipv4_udip_set(payload, ipv4_udip);\n}\n\nstatic inline void mlxsw_reg_ratr_ipip6_entry_pack(char *payload, u32 ipv6_ptr)\n{\n\tmlxsw_reg_ratr_ipip_type_set(payload, MLXSW_REG_RATR_IPIP_TYPE_IPV6);\n\tmlxsw_reg_ratr_ipip_ipv6_ptr_set(payload, ipv6_ptr);\n}\n\nstatic inline void mlxsw_reg_ratr_counter_pack(char *payload, u64 counter_index,\n\t\t\t\t\t       bool counter_enable)\n{\n\tenum mlxsw_reg_flow_counter_set_type set_type;\n\n\tif (counter_enable)\n\t\tset_type = MLXSW_REG_FLOW_COUNTER_SET_TYPE_PACKETS_BYTES;\n\telse\n\t\tset_type = MLXSW_REG_FLOW_COUNTER_SET_TYPE_NO_COUNT;\n\n\tmlxsw_reg_ratr_counter_index_set(payload, counter_index);\n\tmlxsw_reg_ratr_counter_set_type_set(payload, set_type);\n}\n\n \n#define MLXSW_REG_RDPM_ID 0x8009\n#define MLXSW_REG_RDPM_BASE_LEN 0x00\n#define MLXSW_REG_RDPM_DSCP_ENTRY_REC_LEN 0x01\n#define MLXSW_REG_RDPM_DSCP_ENTRY_REC_MAX_COUNT 64\n#define MLXSW_REG_RDPM_LEN 0x40\n#define MLXSW_REG_RDPM_LAST_ENTRY (MLXSW_REG_RDPM_BASE_LEN + \\\n\t\t\t\t   MLXSW_REG_RDPM_LEN - \\\n\t\t\t\t   MLXSW_REG_RDPM_DSCP_ENTRY_REC_LEN)\n\nMLXSW_REG_DEFINE(rdpm, MLXSW_REG_RDPM_ID, MLXSW_REG_RDPM_LEN);\n\n \nMLXSW_ITEM8_INDEXED(reg, rdpm, dscp_entry_e, MLXSW_REG_RDPM_LAST_ENTRY, 7, 1,\n\t\t    -MLXSW_REG_RDPM_DSCP_ENTRY_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM8_INDEXED(reg, rdpm, dscp_entry_prio, MLXSW_REG_RDPM_LAST_ENTRY, 0, 4,\n\t\t    -MLXSW_REG_RDPM_DSCP_ENTRY_REC_LEN, 0x00, false);\n\nstatic inline void mlxsw_reg_rdpm_pack(char *payload, unsigned short index,\n\t\t\t\t       u8 prio)\n{\n\tmlxsw_reg_rdpm_dscp_entry_e_set(payload, index, 1);\n\tmlxsw_reg_rdpm_dscp_entry_prio_set(payload, index, prio);\n}\n\n \n#define MLXSW_REG_RICNT_ID 0x800B\n#define MLXSW_REG_RICNT_LEN 0x100\n\nMLXSW_REG_DEFINE(ricnt, MLXSW_REG_RICNT_ID, MLXSW_REG_RICNT_LEN);\n\n \nMLXSW_ITEM32(reg, ricnt, counter_index, 0x04, 0, 24);\n\nenum mlxsw_reg_ricnt_counter_set_type {\n\t \n\tMLXSW_REG_RICNT_COUNTER_SET_TYPE_NO_COUNT = 0x00,\n\t \n\tMLXSW_REG_RICNT_COUNTER_SET_TYPE_BASIC = 0x09,\n};\n\n \nMLXSW_ITEM32(reg, ricnt, counter_set_type, 0x04, 24, 8);\n\nenum mlxsw_reg_ricnt_opcode {\n\t \n\tMLXSW_REG_RICNT_OPCODE_NOP = 0x00,\n\t \n\tMLXSW_REG_RICNT_OPCODE_CLEAR = 0x08,\n};\n\n \nMLXSW_ITEM32(reg, ricnt, op, 0x00, 28, 4);\n\n \nMLXSW_ITEM64(reg, ricnt, good_unicast_packets, 0x08, 0, 64);\n\n \nMLXSW_ITEM64(reg, ricnt, good_multicast_packets, 0x10, 0, 64);\n\n \nMLXSW_ITEM64(reg, ricnt, good_broadcast_packets, 0x18, 0, 64);\n\n \nMLXSW_ITEM64(reg, ricnt, good_unicast_bytes, 0x20, 0, 64);\n\n \nMLXSW_ITEM64(reg, ricnt, good_multicast_bytes, 0x28, 0, 64);\n\n \nMLXSW_ITEM64(reg, ricnt, good_broadcast_bytes, 0x30, 0, 64);\n\n \nMLXSW_ITEM64(reg, ricnt, error_packets, 0x38, 0, 64);\n\n \nMLXSW_ITEM64(reg, ricnt, discard_packets, 0x40, 0, 64);\n\n \nMLXSW_ITEM64(reg, ricnt, error_bytes, 0x48, 0, 64);\n\n \nMLXSW_ITEM64(reg, ricnt, discard_bytes, 0x50, 0, 64);\n\nstatic inline void mlxsw_reg_ricnt_pack(char *payload, u32 index,\n\t\t\t\t\tenum mlxsw_reg_ricnt_opcode op)\n{\n\tMLXSW_REG_ZERO(ricnt, payload);\n\tmlxsw_reg_ricnt_op_set(payload, op);\n\tmlxsw_reg_ricnt_counter_index_set(payload, index);\n\tmlxsw_reg_ricnt_counter_set_type_set(payload,\n\t\t\t\t\t     MLXSW_REG_RICNT_COUNTER_SET_TYPE_BASIC);\n}\n\n \n#define MLXSW_REG_RRCR_ID 0x800F\n#define MLXSW_REG_RRCR_LEN 0x24\n\nMLXSW_REG_DEFINE(rrcr, MLXSW_REG_RRCR_ID, MLXSW_REG_RRCR_LEN);\n\nenum mlxsw_reg_rrcr_op {\n\t \n\tMLXSW_REG_RRCR_OP_MOVE,\n\t \n\tMLXSW_REG_RRCR_OP_COPY,\n};\n\n \nMLXSW_ITEM32(reg, rrcr, op, 0x00, 28, 4);\n\n \nMLXSW_ITEM32(reg, rrcr, offset, 0x00, 0, 16);\n\n \nMLXSW_ITEM32(reg, rrcr, size, 0x04, 0, 16);\n\n \nMLXSW_ITEM32(reg, rrcr, table_id, 0x10, 0, 4);\n\n \nMLXSW_ITEM32(reg, rrcr, dest_offset, 0x20, 0, 16);\n\nstatic inline void mlxsw_reg_rrcr_pack(char *payload, enum mlxsw_reg_rrcr_op op,\n\t\t\t\t       u16 offset, u16 size,\n\t\t\t\t       enum mlxsw_reg_rtar_key_type table_id,\n\t\t\t\t       u16 dest_offset)\n{\n\tMLXSW_REG_ZERO(rrcr, payload);\n\tmlxsw_reg_rrcr_op_set(payload, op);\n\tmlxsw_reg_rrcr_offset_set(payload, offset);\n\tmlxsw_reg_rrcr_size_set(payload, size);\n\tmlxsw_reg_rrcr_table_id_set(payload, table_id);\n\tmlxsw_reg_rrcr_dest_offset_set(payload, dest_offset);\n}\n\n \n#define MLXSW_REG_RALTA_ID 0x8010\n#define MLXSW_REG_RALTA_LEN 0x04\n\nMLXSW_REG_DEFINE(ralta, MLXSW_REG_RALTA_ID, MLXSW_REG_RALTA_LEN);\n\n \nMLXSW_ITEM32(reg, ralta, op, 0x00, 28, 2);\n\nenum mlxsw_reg_ralxx_protocol {\n\tMLXSW_REG_RALXX_PROTOCOL_IPV4,\n\tMLXSW_REG_RALXX_PROTOCOL_IPV6,\n};\n\n \nMLXSW_ITEM32(reg, ralta, protocol, 0x00, 24, 4);\n\n \nMLXSW_ITEM32(reg, ralta, tree_id, 0x00, 0, 8);\n\nstatic inline void mlxsw_reg_ralta_pack(char *payload, bool alloc,\n\t\t\t\t\tenum mlxsw_reg_ralxx_protocol protocol,\n\t\t\t\t\tu8 tree_id)\n{\n\tMLXSW_REG_ZERO(ralta, payload);\n\tmlxsw_reg_ralta_op_set(payload, !alloc);\n\tmlxsw_reg_ralta_protocol_set(payload, protocol);\n\tmlxsw_reg_ralta_tree_id_set(payload, tree_id);\n}\n\n \n#define MLXSW_REG_RALST_ID 0x8011\n#define MLXSW_REG_RALST_LEN 0x104\n\nMLXSW_REG_DEFINE(ralst, MLXSW_REG_RALST_ID, MLXSW_REG_RALST_LEN);\n\n \nMLXSW_ITEM32(reg, ralst, root_bin, 0x00, 16, 8);\n\n \nMLXSW_ITEM32(reg, ralst, tree_id, 0x00, 0, 8);\n\n#define MLXSW_REG_RALST_BIN_NO_CHILD 0xff\n#define MLXSW_REG_RALST_BIN_OFFSET 0x04\n#define MLXSW_REG_RALST_BIN_COUNT 128\n\n \nMLXSW_ITEM16_INDEXED(reg, ralst, left_child_bin, 0x04, 8, 8, 0x02, 0x00, false);\n\n \nMLXSW_ITEM16_INDEXED(reg, ralst, right_child_bin, 0x04, 0, 8, 0x02, 0x00,\n\t\t     false);\n\nstatic inline void mlxsw_reg_ralst_pack(char *payload, u8 root_bin, u8 tree_id)\n{\n\tMLXSW_REG_ZERO(ralst, payload);\n\n\t \n\tmemset(payload + MLXSW_REG_RALST_BIN_OFFSET,\n\t       MLXSW_REG_RALST_BIN_NO_CHILD, MLXSW_REG_RALST_BIN_COUNT * 2);\n\n\tmlxsw_reg_ralst_root_bin_set(payload, root_bin);\n\tmlxsw_reg_ralst_tree_id_set(payload, tree_id);\n}\n\nstatic inline void mlxsw_reg_ralst_bin_pack(char *payload, u8 bin_number,\n\t\t\t\t\t    u8 left_child_bin,\n\t\t\t\t\t    u8 right_child_bin)\n{\n\tint bin_index = bin_number - 1;\n\n\tmlxsw_reg_ralst_left_child_bin_set(payload, bin_index, left_child_bin);\n\tmlxsw_reg_ralst_right_child_bin_set(payload, bin_index,\n\t\t\t\t\t    right_child_bin);\n}\n\n \n#define MLXSW_REG_RALTB_ID 0x8012\n#define MLXSW_REG_RALTB_LEN 0x04\n\nMLXSW_REG_DEFINE(raltb, MLXSW_REG_RALTB_ID, MLXSW_REG_RALTB_LEN);\n\n \nMLXSW_ITEM32(reg, raltb, virtual_router, 0x00, 16, 16);\n\n \nMLXSW_ITEM32(reg, raltb, protocol, 0x00, 12, 4);\n\n \nMLXSW_ITEM32(reg, raltb, tree_id, 0x00, 0, 8);\n\nstatic inline void mlxsw_reg_raltb_pack(char *payload, u16 virtual_router,\n\t\t\t\t\tenum mlxsw_reg_ralxx_protocol protocol,\n\t\t\t\t\tu8 tree_id)\n{\n\tMLXSW_REG_ZERO(raltb, payload);\n\tmlxsw_reg_raltb_virtual_router_set(payload, virtual_router);\n\tmlxsw_reg_raltb_protocol_set(payload, protocol);\n\tmlxsw_reg_raltb_tree_id_set(payload, tree_id);\n}\n\n \n#define MLXSW_REG_RALUE_ID 0x8013\n#define MLXSW_REG_RALUE_LEN 0x38\n\nMLXSW_REG_DEFINE(ralue, MLXSW_REG_RALUE_ID, MLXSW_REG_RALUE_LEN);\n\n \nMLXSW_ITEM32(reg, ralue, protocol, 0x00, 24, 4);\n\nenum mlxsw_reg_ralue_op {\n\t \n\tMLXSW_REG_RALUE_OP_QUERY_READ = 0,\n\t \n\tMLXSW_REG_RALUE_OP_QUERY_CLEAR = 1,\n\t \n\tMLXSW_REG_RALUE_OP_WRITE_WRITE = 0,\n\t \n\tMLXSW_REG_RALUE_OP_WRITE_UPDATE = 1,\n\t \n\tMLXSW_REG_RALUE_OP_WRITE_CLEAR = 2,\n\t \n\tMLXSW_REG_RALUE_OP_WRITE_DELETE = 3,\n};\n\n \nMLXSW_ITEM32(reg, ralue, op, 0x00, 20, 3);\n\n \nMLXSW_ITEM32(reg, ralue, a, 0x00, 16, 1);\n\n \nMLXSW_ITEM32(reg, ralue, virtual_router, 0x04, 16, 16);\n\n#define MLXSW_REG_RALUE_OP_U_MASK_ENTRY_TYPE\tBIT(0)\n#define MLXSW_REG_RALUE_OP_U_MASK_BMP_LEN\tBIT(1)\n#define MLXSW_REG_RALUE_OP_U_MASK_ACTION\tBIT(2)\n\n \nMLXSW_ITEM32(reg, ralue, op_u_mask, 0x04, 8, 3);\n\n \nMLXSW_ITEM32(reg, ralue, prefix_len, 0x08, 0, 8);\n\n \nMLXSW_ITEM32(reg, ralue, dip4, 0x18, 0, 32);\nMLXSW_ITEM_BUF(reg, ralue, dip6, 0x0C, 16);\n\nenum mlxsw_reg_ralue_entry_type {\n\tMLXSW_REG_RALUE_ENTRY_TYPE_MARKER_ENTRY = 1,\n\tMLXSW_REG_RALUE_ENTRY_TYPE_ROUTE_ENTRY = 2,\n\tMLXSW_REG_RALUE_ENTRY_TYPE_MARKER_AND_ROUTE_ENTRY = 3,\n};\n\n \nMLXSW_ITEM32(reg, ralue, entry_type, 0x1C, 30, 2);\n\n \nMLXSW_ITEM32(reg, ralue, bmp_len, 0x1C, 16, 8);\n\nenum mlxsw_reg_ralue_action_type {\n\tMLXSW_REG_RALUE_ACTION_TYPE_REMOTE,\n\tMLXSW_REG_RALUE_ACTION_TYPE_LOCAL,\n\tMLXSW_REG_RALUE_ACTION_TYPE_IP2ME,\n};\n\n \nMLXSW_ITEM32(reg, ralue, action_type, 0x1C, 0, 2);\n\nenum mlxsw_reg_ralue_trap_action {\n\tMLXSW_REG_RALUE_TRAP_ACTION_NOP,\n\tMLXSW_REG_RALUE_TRAP_ACTION_TRAP,\n\tMLXSW_REG_RALUE_TRAP_ACTION_MIRROR_TO_CPU,\n\tMLXSW_REG_RALUE_TRAP_ACTION_MIRROR,\n\tMLXSW_REG_RALUE_TRAP_ACTION_DISCARD_ERROR,\n};\n\n \nMLXSW_ITEM32(reg, ralue, trap_action, 0x20, 28, 4);\n\n \nMLXSW_ITEM32(reg, ralue, trap_id, 0x20, 0, 9);\n\n \nMLXSW_ITEM32(reg, ralue, adjacency_index, 0x24, 0, 24);\n\n \nMLXSW_ITEM32(reg, ralue, ecmp_size, 0x28, 0, 13);\n\n \nMLXSW_ITEM32(reg, ralue, local_erif, 0x24, 0, 16);\n\n \nMLXSW_ITEM32(reg, ralue, ip2me_v, 0x24, 31, 1);\n\n \nMLXSW_ITEM32(reg, ralue, ip2me_tunnel_ptr, 0x24, 0, 24);\n\nstatic inline void mlxsw_reg_ralue_pack(char *payload,\n\t\t\t\t\tenum mlxsw_reg_ralxx_protocol protocol,\n\t\t\t\t\tenum mlxsw_reg_ralue_op op,\n\t\t\t\t\tu16 virtual_router, u8 prefix_len)\n{\n\tMLXSW_REG_ZERO(ralue, payload);\n\tmlxsw_reg_ralue_protocol_set(payload, protocol);\n\tmlxsw_reg_ralue_op_set(payload, op);\n\tmlxsw_reg_ralue_virtual_router_set(payload, virtual_router);\n\tmlxsw_reg_ralue_prefix_len_set(payload, prefix_len);\n\tmlxsw_reg_ralue_entry_type_set(payload,\n\t\t\t\t       MLXSW_REG_RALUE_ENTRY_TYPE_ROUTE_ENTRY);\n\tmlxsw_reg_ralue_bmp_len_set(payload, prefix_len);\n}\n\nstatic inline void mlxsw_reg_ralue_pack4(char *payload,\n\t\t\t\t\t enum mlxsw_reg_ralxx_protocol protocol,\n\t\t\t\t\t enum mlxsw_reg_ralue_op op,\n\t\t\t\t\t u16 virtual_router, u8 prefix_len,\n\t\t\t\t\t u32 dip)\n{\n\tmlxsw_reg_ralue_pack(payload, protocol, op, virtual_router, prefix_len);\n\tmlxsw_reg_ralue_dip4_set(payload, dip);\n}\n\nstatic inline void mlxsw_reg_ralue_pack6(char *payload,\n\t\t\t\t\t enum mlxsw_reg_ralxx_protocol protocol,\n\t\t\t\t\t enum mlxsw_reg_ralue_op op,\n\t\t\t\t\t u16 virtual_router, u8 prefix_len,\n\t\t\t\t\t const void *dip)\n{\n\tmlxsw_reg_ralue_pack(payload, protocol, op, virtual_router, prefix_len);\n\tmlxsw_reg_ralue_dip6_memcpy_to(payload, dip);\n}\n\nstatic inline void\nmlxsw_reg_ralue_act_remote_pack(char *payload,\n\t\t\t\tenum mlxsw_reg_ralue_trap_action trap_action,\n\t\t\t\tu16 trap_id, u32 adjacency_index, u16 ecmp_size)\n{\n\tmlxsw_reg_ralue_action_type_set(payload,\n\t\t\t\t\tMLXSW_REG_RALUE_ACTION_TYPE_REMOTE);\n\tmlxsw_reg_ralue_trap_action_set(payload, trap_action);\n\tmlxsw_reg_ralue_trap_id_set(payload, trap_id);\n\tmlxsw_reg_ralue_adjacency_index_set(payload, adjacency_index);\n\tmlxsw_reg_ralue_ecmp_size_set(payload, ecmp_size);\n}\n\nstatic inline void\nmlxsw_reg_ralue_act_local_pack(char *payload,\n\t\t\t       enum mlxsw_reg_ralue_trap_action trap_action,\n\t\t\t       u16 trap_id, u16 local_erif)\n{\n\tmlxsw_reg_ralue_action_type_set(payload,\n\t\t\t\t\tMLXSW_REG_RALUE_ACTION_TYPE_LOCAL);\n\tmlxsw_reg_ralue_trap_action_set(payload, trap_action);\n\tmlxsw_reg_ralue_trap_id_set(payload, trap_id);\n\tmlxsw_reg_ralue_local_erif_set(payload, local_erif);\n}\n\nstatic inline void\nmlxsw_reg_ralue_act_ip2me_pack(char *payload)\n{\n\tmlxsw_reg_ralue_action_type_set(payload,\n\t\t\t\t\tMLXSW_REG_RALUE_ACTION_TYPE_IP2ME);\n}\n\nstatic inline void\nmlxsw_reg_ralue_act_ip2me_tun_pack(char *payload, u32 tunnel_ptr)\n{\n\tmlxsw_reg_ralue_action_type_set(payload,\n\t\t\t\t\tMLXSW_REG_RALUE_ACTION_TYPE_IP2ME);\n\tmlxsw_reg_ralue_ip2me_v_set(payload, 1);\n\tmlxsw_reg_ralue_ip2me_tunnel_ptr_set(payload, tunnel_ptr);\n}\n\n \n#define MLXSW_REG_RAUHT_ID 0x8014\n#define MLXSW_REG_RAUHT_LEN 0x74\n\nMLXSW_REG_DEFINE(rauht, MLXSW_REG_RAUHT_ID, MLXSW_REG_RAUHT_LEN);\n\nenum mlxsw_reg_rauht_type {\n\tMLXSW_REG_RAUHT_TYPE_IPV4,\n\tMLXSW_REG_RAUHT_TYPE_IPV6,\n};\n\n \nMLXSW_ITEM32(reg, rauht, type, 0x00, 24, 2);\n\nenum mlxsw_reg_rauht_op {\n\tMLXSW_REG_RAUHT_OP_QUERY_READ = 0,\n\t \n\tMLXSW_REG_RAUHT_OP_QUERY_CLEAR_ON_READ = 1,\n\t \n\tMLXSW_REG_RAUHT_OP_WRITE_ADD = 0,\n\t \n\tMLXSW_REG_RAUHT_OP_WRITE_UPDATE = 1,\n\t \n\tMLXSW_REG_RAUHT_OP_WRITE_CLEAR_ACTIVITY = 2,\n\t \n\tMLXSW_REG_RAUHT_OP_WRITE_DELETE = 3,\n\t \n\tMLXSW_REG_RAUHT_OP_WRITE_DELETE_ALL = 4,\n\t \n};\n\n \nMLXSW_ITEM32(reg, rauht, op, 0x00, 20, 3);\n\n \nMLXSW_ITEM32(reg, rauht, a, 0x00, 16, 1);\n\n \nMLXSW_ITEM32(reg, rauht, rif, 0x00, 0, 16);\n\n \nMLXSW_ITEM32(reg, rauht, dip4, 0x1C, 0x0, 32);\nMLXSW_ITEM_BUF(reg, rauht, dip6, 0x10, 16);\n\nenum mlxsw_reg_rauht_trap_action {\n\tMLXSW_REG_RAUHT_TRAP_ACTION_NOP,\n\tMLXSW_REG_RAUHT_TRAP_ACTION_TRAP,\n\tMLXSW_REG_RAUHT_TRAP_ACTION_MIRROR_TO_CPU,\n\tMLXSW_REG_RAUHT_TRAP_ACTION_MIRROR,\n\tMLXSW_REG_RAUHT_TRAP_ACTION_DISCARD_ERRORS,\n};\n\n \nMLXSW_ITEM32(reg, rauht, trap_action, 0x60, 28, 4);\n\nenum mlxsw_reg_rauht_trap_id {\n\tMLXSW_REG_RAUHT_TRAP_ID_RTR_EGRESS0,\n\tMLXSW_REG_RAUHT_TRAP_ID_RTR_EGRESS1,\n};\n\n \nMLXSW_ITEM32(reg, rauht, trap_id, 0x60, 0, 9);\n\n \nMLXSW_ITEM32(reg, rauht, counter_set_type, 0x68, 24, 8);\n\n \nMLXSW_ITEM32(reg, rauht, counter_index, 0x68, 0, 24);\n\n \nMLXSW_ITEM_BUF(reg, rauht, mac, 0x6E, 6);\n\nstatic inline void mlxsw_reg_rauht_pack(char *payload,\n\t\t\t\t\tenum mlxsw_reg_rauht_op op, u16 rif,\n\t\t\t\t\tconst char *mac)\n{\n\tMLXSW_REG_ZERO(rauht, payload);\n\tmlxsw_reg_rauht_op_set(payload, op);\n\tmlxsw_reg_rauht_rif_set(payload, rif);\n\tmlxsw_reg_rauht_mac_memcpy_to(payload, mac);\n}\n\nstatic inline void mlxsw_reg_rauht_pack4(char *payload,\n\t\t\t\t\t enum mlxsw_reg_rauht_op op, u16 rif,\n\t\t\t\t\t const char *mac, u32 dip)\n{\n\tmlxsw_reg_rauht_pack(payload, op, rif, mac);\n\tmlxsw_reg_rauht_dip4_set(payload, dip);\n}\n\nstatic inline void mlxsw_reg_rauht_pack6(char *payload,\n\t\t\t\t\t enum mlxsw_reg_rauht_op op, u16 rif,\n\t\t\t\t\t const char *mac, const char *dip)\n{\n\tmlxsw_reg_rauht_pack(payload, op, rif, mac);\n\tmlxsw_reg_rauht_type_set(payload, MLXSW_REG_RAUHT_TYPE_IPV6);\n\tmlxsw_reg_rauht_dip6_memcpy_to(payload, dip);\n}\n\nstatic inline void mlxsw_reg_rauht_pack_counter(char *payload,\n\t\t\t\t\t\tu64 counter_index)\n{\n\tmlxsw_reg_rauht_counter_index_set(payload, counter_index);\n\tmlxsw_reg_rauht_counter_set_type_set(payload,\n\t\t\t\t\t     MLXSW_REG_FLOW_COUNTER_SET_TYPE_PACKETS_BYTES);\n}\n\n \n#define MLXSW_REG_RALEU_ID 0x8015\n#define MLXSW_REG_RALEU_LEN 0x28\n\nMLXSW_REG_DEFINE(raleu, MLXSW_REG_RALEU_ID, MLXSW_REG_RALEU_LEN);\n\n \nMLXSW_ITEM32(reg, raleu, protocol, 0x00, 24, 4);\n\n \nMLXSW_ITEM32(reg, raleu, virtual_router, 0x00, 0, 16);\n\n \nMLXSW_ITEM32(reg, raleu, adjacency_index, 0x10, 0, 24);\n\n \nMLXSW_ITEM32(reg, raleu, ecmp_size, 0x14, 0, 13);\n\n \nMLXSW_ITEM32(reg, raleu, new_adjacency_index, 0x20, 0, 24);\n\n \nMLXSW_ITEM32(reg, raleu, new_ecmp_size, 0x24, 0, 13);\n\nstatic inline void mlxsw_reg_raleu_pack(char *payload,\n\t\t\t\t\tenum mlxsw_reg_ralxx_protocol protocol,\n\t\t\t\t\tu16 virtual_router,\n\t\t\t\t\tu32 adjacency_index, u16 ecmp_size,\n\t\t\t\t\tu32 new_adjacency_index,\n\t\t\t\t\tu16 new_ecmp_size)\n{\n\tMLXSW_REG_ZERO(raleu, payload);\n\tmlxsw_reg_raleu_protocol_set(payload, protocol);\n\tmlxsw_reg_raleu_virtual_router_set(payload, virtual_router);\n\tmlxsw_reg_raleu_adjacency_index_set(payload, adjacency_index);\n\tmlxsw_reg_raleu_ecmp_size_set(payload, ecmp_size);\n\tmlxsw_reg_raleu_new_adjacency_index_set(payload, new_adjacency_index);\n\tmlxsw_reg_raleu_new_ecmp_size_set(payload, new_ecmp_size);\n}\n\n \n#define MLXSW_REG_RAUHTD_ID 0x8018\n#define MLXSW_REG_RAUHTD_BASE_LEN 0x20\n#define MLXSW_REG_RAUHTD_REC_LEN 0x20\n#define MLXSW_REG_RAUHTD_REC_MAX_NUM 32\n#define MLXSW_REG_RAUHTD_LEN (MLXSW_REG_RAUHTD_BASE_LEN + \\\n\t\tMLXSW_REG_RAUHTD_REC_MAX_NUM * MLXSW_REG_RAUHTD_REC_LEN)\n#define MLXSW_REG_RAUHTD_IPV4_ENT_PER_REC 4\n\nMLXSW_REG_DEFINE(rauhtd, MLXSW_REG_RAUHTD_ID, MLXSW_REG_RAUHTD_LEN);\n\n#define MLXSW_REG_RAUHTD_FILTER_A BIT(0)\n#define MLXSW_REG_RAUHTD_FILTER_RIF BIT(3)\n\n \nMLXSW_ITEM32(reg, rauhtd, filter_fields, 0x00, 0, 8);\n\nenum mlxsw_reg_rauhtd_op {\n\tMLXSW_REG_RAUHTD_OP_DUMP,\n\tMLXSW_REG_RAUHTD_OP_DUMP_AND_CLEAR,\n};\n\n \nMLXSW_ITEM32(reg, rauhtd, op, 0x04, 24, 2);\n\n \nMLXSW_ITEM32(reg, rauhtd, num_rec, 0x04, 0, 8);\n\n \nMLXSW_ITEM32(reg, rauhtd, entry_a, 0x08, 16, 1);\n\nenum mlxsw_reg_rauhtd_type {\n\tMLXSW_REG_RAUHTD_TYPE_IPV4,\n\tMLXSW_REG_RAUHTD_TYPE_IPV6,\n};\n\n \nMLXSW_ITEM32(reg, rauhtd, type, 0x08, 0, 4);\n\n \nMLXSW_ITEM32(reg, rauhtd, entry_rif, 0x0C, 0, 16);\n\nstatic inline void mlxsw_reg_rauhtd_pack(char *payload,\n\t\t\t\t\t enum mlxsw_reg_rauhtd_type type)\n{\n\tMLXSW_REG_ZERO(rauhtd, payload);\n\tmlxsw_reg_rauhtd_filter_fields_set(payload, MLXSW_REG_RAUHTD_FILTER_A);\n\tmlxsw_reg_rauhtd_op_set(payload, MLXSW_REG_RAUHTD_OP_DUMP_AND_CLEAR);\n\tmlxsw_reg_rauhtd_num_rec_set(payload, MLXSW_REG_RAUHTD_REC_MAX_NUM);\n\tmlxsw_reg_rauhtd_entry_a_set(payload, 1);\n\tmlxsw_reg_rauhtd_type_set(payload, type);\n}\n\n \nMLXSW_ITEM32_INDEXED(reg, rauhtd, ipv4_rec_num_entries,\n\t\t     MLXSW_REG_RAUHTD_BASE_LEN, 28, 2,\n\t\t     MLXSW_REG_RAUHTD_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, rauhtd, rec_type, MLXSW_REG_RAUHTD_BASE_LEN, 24, 2,\n\t\t     MLXSW_REG_RAUHTD_REC_LEN, 0x00, false);\n\n#define MLXSW_REG_RAUHTD_IPV4_ENT_LEN 0x8\n\n \nMLXSW_ITEM32_INDEXED(reg, rauhtd, ipv4_ent_a, MLXSW_REG_RAUHTD_BASE_LEN, 16, 1,\n\t\t     MLXSW_REG_RAUHTD_IPV4_ENT_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, rauhtd, ipv4_ent_rif, MLXSW_REG_RAUHTD_BASE_LEN, 0,\n\t\t     16, MLXSW_REG_RAUHTD_IPV4_ENT_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, rauhtd, ipv4_ent_dip, MLXSW_REG_RAUHTD_BASE_LEN, 0,\n\t\t     32, MLXSW_REG_RAUHTD_IPV4_ENT_LEN, 0x04, false);\n\n#define MLXSW_REG_RAUHTD_IPV6_ENT_LEN 0x20\n\n \nMLXSW_ITEM32_INDEXED(reg, rauhtd, ipv6_ent_a, MLXSW_REG_RAUHTD_BASE_LEN, 16, 1,\n\t\t     MLXSW_REG_RAUHTD_IPV6_ENT_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, rauhtd, ipv6_ent_rif, MLXSW_REG_RAUHTD_BASE_LEN, 0,\n\t\t     16, MLXSW_REG_RAUHTD_IPV6_ENT_LEN, 0x00, false);\n\n \nMLXSW_ITEM_BUF_INDEXED(reg, rauhtd, ipv6_ent_dip, MLXSW_REG_RAUHTD_BASE_LEN,\n\t\t       16, MLXSW_REG_RAUHTD_IPV6_ENT_LEN, 0x10);\n\nstatic inline void mlxsw_reg_rauhtd_ent_ipv4_unpack(char *payload,\n\t\t\t\t\t\t    int ent_index, u16 *p_rif,\n\t\t\t\t\t\t    u32 *p_dip)\n{\n\t*p_rif = mlxsw_reg_rauhtd_ipv4_ent_rif_get(payload, ent_index);\n\t*p_dip = mlxsw_reg_rauhtd_ipv4_ent_dip_get(payload, ent_index);\n}\n\nstatic inline void mlxsw_reg_rauhtd_ent_ipv6_unpack(char *payload,\n\t\t\t\t\t\t    int rec_index, u16 *p_rif,\n\t\t\t\t\t\t    char *p_dip)\n{\n\t*p_rif = mlxsw_reg_rauhtd_ipv6_ent_rif_get(payload, rec_index);\n\tmlxsw_reg_rauhtd_ipv6_ent_dip_memcpy_from(payload, rec_index, p_dip);\n}\n\n \n#define MLXSW_REG_RTDP_ID 0x8020\n#define MLXSW_REG_RTDP_LEN 0x44\n\nMLXSW_REG_DEFINE(rtdp, MLXSW_REG_RTDP_ID, MLXSW_REG_RTDP_LEN);\n\nenum mlxsw_reg_rtdp_type {\n\tMLXSW_REG_RTDP_TYPE_NVE,\n\tMLXSW_REG_RTDP_TYPE_IPIP,\n};\n\n \nMLXSW_ITEM32(reg, rtdp, type, 0x00, 28, 4);\n\n \nMLXSW_ITEM32(reg, rtdp, tunnel_index, 0x00, 0, 24);\n\n \nMLXSW_ITEM32(reg, rtdp, egress_router_interface, 0x40, 0, 16);\n\n \n\n \nMLXSW_ITEM32(reg, rtdp, ipip_irif, 0x04, 16, 16);\n\nenum mlxsw_reg_rtdp_ipip_sip_check {\n\t \n\tMLXSW_REG_RTDP_IPIP_SIP_CHECK_NO,\n\t \n\tMLXSW_REG_RTDP_IPIP_SIP_CHECK_FILTER_IPV4,\n\t \n\tMLXSW_REG_RTDP_IPIP_SIP_CHECK_FILTER_IPV6 = 3,\n};\n\n \nMLXSW_ITEM32(reg, rtdp, ipip_sip_check, 0x04, 0, 3);\n\n \n#define MLXSW_REG_RTDP_IPIP_TYPE_CHECK_ALLOW_IPIP\tBIT(0)\n \n#define MLXSW_REG_RTDP_IPIP_TYPE_CHECK_ALLOW_GRE\tBIT(1)\n \n#define MLXSW_REG_RTDP_IPIP_TYPE_CHECK_ALLOW_GRE_KEY\tBIT(2)\n\n \nMLXSW_ITEM32(reg, rtdp, ipip_type_check, 0x08, 24, 3);\n\n \nMLXSW_ITEM32(reg, rtdp, ipip_gre_key_check, 0x08, 23, 1);\n\n \nMLXSW_ITEM32(reg, rtdp, ipip_ipv4_usip, 0x0C, 0, 32);\n\n \nMLXSW_ITEM32(reg, rtdp, ipip_ipv6_usip_ptr, 0x10, 0, 24);\n\n \nMLXSW_ITEM32(reg, rtdp, ipip_expected_gre_key, 0x14, 0, 32);\n\nstatic inline void mlxsw_reg_rtdp_pack(char *payload,\n\t\t\t\t       enum mlxsw_reg_rtdp_type type,\n\t\t\t\t       u32 tunnel_index)\n{\n\tMLXSW_REG_ZERO(rtdp, payload);\n\tmlxsw_reg_rtdp_type_set(payload, type);\n\tmlxsw_reg_rtdp_tunnel_index_set(payload, tunnel_index);\n}\n\nstatic inline void\nmlxsw_reg_rtdp_ipip_pack(char *payload, u16 irif,\n\t\t\t enum mlxsw_reg_rtdp_ipip_sip_check sip_check,\n\t\t\t unsigned int type_check, bool gre_key_check,\n\t\t\t u32 expected_gre_key)\n{\n\tmlxsw_reg_rtdp_ipip_irif_set(payload, irif);\n\tmlxsw_reg_rtdp_ipip_sip_check_set(payload, sip_check);\n\tmlxsw_reg_rtdp_ipip_type_check_set(payload, type_check);\n\tmlxsw_reg_rtdp_ipip_gre_key_check_set(payload, gre_key_check);\n\tmlxsw_reg_rtdp_ipip_expected_gre_key_set(payload, expected_gre_key);\n}\n\nstatic inline void\nmlxsw_reg_rtdp_ipip4_pack(char *payload, u16 irif,\n\t\t\t  enum mlxsw_reg_rtdp_ipip_sip_check sip_check,\n\t\t\t  unsigned int type_check, bool gre_key_check,\n\t\t\t  u32 ipv4_usip, u32 expected_gre_key)\n{\n\tmlxsw_reg_rtdp_ipip_pack(payload, irif, sip_check, type_check,\n\t\t\t\t gre_key_check, expected_gre_key);\n\tmlxsw_reg_rtdp_ipip_ipv4_usip_set(payload, ipv4_usip);\n}\n\nstatic inline void\nmlxsw_reg_rtdp_ipip6_pack(char *payload, u16 irif,\n\t\t\t  enum mlxsw_reg_rtdp_ipip_sip_check sip_check,\n\t\t\t  unsigned int type_check, bool gre_key_check,\n\t\t\t  u32 ipv6_usip_ptr, u32 expected_gre_key)\n{\n\tmlxsw_reg_rtdp_ipip_pack(payload, irif, sip_check, type_check,\n\t\t\t\t gre_key_check, expected_gre_key);\n\tmlxsw_reg_rtdp_ipip_ipv6_usip_ptr_set(payload, ipv6_usip_ptr);\n}\n\n \n#define MLXSW_REG_RIPS_ID 0x8021\n#define MLXSW_REG_RIPS_LEN 0x14\n\nMLXSW_REG_DEFINE(rips, MLXSW_REG_RIPS_ID, MLXSW_REG_RIPS_LEN);\n\n \nMLXSW_ITEM32(reg, rips, index, 0x00, 0, 24);\n\n \nMLXSW_ITEM_BUF(reg, rips, ipv6, 0x04, 16);\n\nstatic inline void mlxsw_reg_rips_pack(char *payload, u32 index,\n\t\t\t\t       const struct in6_addr *ipv6)\n{\n\tMLXSW_REG_ZERO(rips, payload);\n\tmlxsw_reg_rips_index_set(payload, index);\n\tmlxsw_reg_rips_ipv6_memcpy_to(payload, (const char *)ipv6);\n}\n\n \n#define MLXSW_REG_RATRAD_ID 0x8022\n#define MLXSW_REG_RATRAD_LEN 0x210\n\nMLXSW_REG_DEFINE(ratrad, MLXSW_REG_RATRAD_ID, MLXSW_REG_RATRAD_LEN);\n\nenum {\n\t \n\tMLXSW_REG_RATRAD_OP_READ_ACTIVITY,\n\t \n\tMLXSW_REG_RATRAD_OP_READ_CLEAR_ACTIVITY,\n};\n\n \nMLXSW_ITEM32(reg, ratrad, op, 0x00, 30, 2);\n\n \nMLXSW_ITEM32(reg, ratrad, ecmp_size, 0x00, 0, 13);\n\n \nMLXSW_ITEM32(reg, ratrad, adjacency_index, 0x04, 0, 24);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, ratrad, activity_vector, 0x10, 0x200, 1);\n\nstatic inline void mlxsw_reg_ratrad_pack(char *payload, u32 adjacency_index,\n\t\t\t\t\t u16 ecmp_size)\n{\n\tMLXSW_REG_ZERO(ratrad, payload);\n\tmlxsw_reg_ratrad_op_set(payload,\n\t\t\t\tMLXSW_REG_RATRAD_OP_READ_CLEAR_ACTIVITY);\n\tmlxsw_reg_ratrad_ecmp_size_set(payload, ecmp_size);\n\tmlxsw_reg_ratrad_adjacency_index_set(payload, adjacency_index);\n}\n\n \n#define MLXSW_REG_RIGR2_ID 0x8023\n#define MLXSW_REG_RIGR2_LEN 0xB0\n\n#define MLXSW_REG_RIGR2_MAX_ERIFS 32\n\nMLXSW_REG_DEFINE(rigr2, MLXSW_REG_RIGR2_ID, MLXSW_REG_RIGR2_LEN);\n\n \nMLXSW_ITEM32(reg, rigr2, rigr_index, 0x04, 0, 24);\n\n \nMLXSW_ITEM32(reg, rigr2, vnext, 0x08, 31, 1);\n\n \nMLXSW_ITEM32(reg, rigr2, next_rigr_index, 0x08, 0, 24);\n\n \nMLXSW_ITEM32(reg, rigr2, vrmid, 0x20, 31, 1);\n\n \nMLXSW_ITEM32(reg, rigr2, rmid_index, 0x20, 0, 16);\n\n \nMLXSW_ITEM32_INDEXED(reg, rigr2, erif_entry_v, 0x24, 31, 1, 4, 0, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, rigr2, erif_entry_erif, 0x24, 0, 16, 4, 0, false);\n\nstatic inline void mlxsw_reg_rigr2_pack(char *payload, u32 rigr_index,\n\t\t\t\t\tbool vnext, u32 next_rigr_index)\n{\n\tMLXSW_REG_ZERO(rigr2, payload);\n\tmlxsw_reg_rigr2_rigr_index_set(payload, rigr_index);\n\tmlxsw_reg_rigr2_vnext_set(payload, vnext);\n\tmlxsw_reg_rigr2_next_rigr_index_set(payload, next_rigr_index);\n\tmlxsw_reg_rigr2_vrmid_set(payload, 0);\n\tmlxsw_reg_rigr2_rmid_index_set(payload, 0);\n}\n\nstatic inline void mlxsw_reg_rigr2_erif_entry_pack(char *payload, int index,\n\t\t\t\t\t\t   bool v, u16 erif)\n{\n\tmlxsw_reg_rigr2_erif_entry_v_set(payload, index, v);\n\tmlxsw_reg_rigr2_erif_entry_erif_set(payload, index, erif);\n}\n\n \n#define MLXSW_REG_RECR2_ID 0x8025\n#define MLXSW_REG_RECR2_LEN 0x38\n\nMLXSW_REG_DEFINE(recr2, MLXSW_REG_RECR2_ID, MLXSW_REG_RECR2_LEN);\n\n \nMLXSW_ITEM32(reg, recr2, pp, 0x00, 24, 1);\n\n \nMLXSW_ITEM32(reg, recr2, sh, 0x00, 8, 1);\n\n \nMLXSW_ITEM32(reg, recr2, seed, 0x08, 0, 32);\n\nenum {\n\t \n\tMLXSW_REG_RECR2_IPV4_EN_NOT_TCP_NOT_UDP\t= 3,\n\t \n\tMLXSW_REG_RECR2_IPV4_EN_TCP_UDP\t\t= 4,\n\t \n\tMLXSW_REG_RECR2_IPV6_EN_NOT_TCP_NOT_UDP\t= 5,\n\t \n\tMLXSW_REG_RECR2_IPV6_EN_TCP_UDP\t\t= 6,\n\t \n\tMLXSW_REG_RECR2_TCP_UDP_EN_IPV4\t\t= 7,\n\t \n\tMLXSW_REG_RECR2_TCP_UDP_EN_IPV6\t\t= 8,\n\n\t__MLXSW_REG_RECR2_HEADER_CNT,\n};\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, recr2, outer_header_enables, 0x10, 0x04, 1);\n\nenum {\n\t \n\tMLXSW_REG_RECR2_IPV4_SIP0\t\t\t= 9,\n\tMLXSW_REG_RECR2_IPV4_SIP3\t\t\t= 12,\n\t \n\tMLXSW_REG_RECR2_IPV4_DIP0\t\t\t= 13,\n\tMLXSW_REG_RECR2_IPV4_DIP3\t\t\t= 16,\n\t \n\tMLXSW_REG_RECR2_IPV4_PROTOCOL\t\t\t= 17,\n\t \n\tMLXSW_REG_RECR2_IPV6_SIP0_7\t\t\t= 21,\n\tMLXSW_REG_RECR2_IPV6_SIP8\t\t\t= 29,\n\tMLXSW_REG_RECR2_IPV6_SIP15\t\t\t= 36,\n\t \n\tMLXSW_REG_RECR2_IPV6_DIP0_7\t\t\t= 37,\n\tMLXSW_REG_RECR2_IPV6_DIP8\t\t\t= 45,\n\tMLXSW_REG_RECR2_IPV6_DIP15\t\t\t= 52,\n\t \n\tMLXSW_REG_RECR2_IPV6_NEXT_HEADER\t\t= 53,\n\t \n\tMLXSW_REG_RECR2_IPV6_FLOW_LABEL\t\t\t= 57,\n\t \n\tMLXSW_REG_RECR2_TCP_UDP_SPORT\t\t\t= 74,\n\t \n\tMLXSW_REG_RECR2_TCP_UDP_DPORT\t\t\t= 75,\n\n\t__MLXSW_REG_RECR2_FIELD_CNT,\n};\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, recr2, outer_header_fields_enable, 0x14, 0x14, 1);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, recr2, inner_header_enables, 0x2C, 0x04, 1);\n\nenum {\n\t \n\tMLXSW_REG_RECR2_INNER_IPV4_SIP0\t\t\t= 3,\n\tMLXSW_REG_RECR2_INNER_IPV4_SIP3\t\t\t= 6,\n\t \n\tMLXSW_REG_RECR2_INNER_IPV4_DIP0\t\t\t= 7,\n\tMLXSW_REG_RECR2_INNER_IPV4_DIP3\t\t\t= 10,\n\t \n\tMLXSW_REG_RECR2_INNER_IPV4_PROTOCOL\t\t= 11,\n\t \n\tMLXSW_REG_RECR2_INNER_IPV6_SIP0_7\t\t= 12,\n\tMLXSW_REG_RECR2_INNER_IPV6_SIP8\t\t\t= 20,\n\tMLXSW_REG_RECR2_INNER_IPV6_SIP15\t\t= 27,\n\t \n\tMLXSW_REG_RECR2_INNER_IPV6_DIP0_7\t\t= 28,\n\tMLXSW_REG_RECR2_INNER_IPV6_DIP8\t\t\t= 36,\n\tMLXSW_REG_RECR2_INNER_IPV6_DIP15\t\t= 43,\n\t \n\tMLXSW_REG_RECR2_INNER_IPV6_NEXT_HEADER\t\t= 44,\n\t \n\tMLXSW_REG_RECR2_INNER_IPV6_FLOW_LABEL\t\t= 45,\n\t \n\tMLXSW_REG_RECR2_INNER_TCP_UDP_SPORT\t\t= 46,\n\t \n\tMLXSW_REG_RECR2_INNER_TCP_UDP_DPORT\t\t= 47,\n\n\t__MLXSW_REG_RECR2_INNER_FIELD_CNT,\n};\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, recr2, inner_header_fields_enable, 0x30, 0x08, 1);\n\nstatic inline void mlxsw_reg_recr2_pack(char *payload, u32 seed)\n{\n\tMLXSW_REG_ZERO(recr2, payload);\n\tmlxsw_reg_recr2_pp_set(payload, false);\n\tmlxsw_reg_recr2_sh_set(payload, true);\n\tmlxsw_reg_recr2_seed_set(payload, seed);\n}\n\n \n#define MLXSW_REG_RMFT2_ID 0x8027\n#define MLXSW_REG_RMFT2_LEN 0x174\n\nMLXSW_REG_DEFINE(rmft2, MLXSW_REG_RMFT2_ID, MLXSW_REG_RMFT2_LEN);\n\n \nMLXSW_ITEM32(reg, rmft2, v, 0x00, 31, 1);\n\nenum mlxsw_reg_rmft2_type {\n\tMLXSW_REG_RMFT2_TYPE_IPV4,\n\tMLXSW_REG_RMFT2_TYPE_IPV6\n};\n\n \nMLXSW_ITEM32(reg, rmft2, type, 0x00, 28, 2);\n\nenum mlxsw_sp_reg_rmft2_op {\n\t \n\tMLXSW_REG_RMFT2_OP_READ_WRITE,\n};\n\n \nMLXSW_ITEM32(reg, rmft2, op, 0x00, 20, 2);\n\n \nMLXSW_ITEM32(reg, rmft2, a, 0x00, 16, 1);\n\n \nMLXSW_ITEM32(reg, rmft2, offset, 0x00, 0, 16);\n\n \nMLXSW_ITEM32(reg, rmft2, virtual_router, 0x04, 0, 16);\n\nenum mlxsw_reg_rmft2_irif_mask {\n\tMLXSW_REG_RMFT2_IRIF_MASK_IGNORE,\n\tMLXSW_REG_RMFT2_IRIF_MASK_COMPARE\n};\n\n \nMLXSW_ITEM32(reg, rmft2, irif_mask, 0x08, 24, 1);\n\n \nMLXSW_ITEM32(reg, rmft2, irif, 0x08, 0, 16);\n\n \nMLXSW_ITEM_BUF(reg, rmft2, dip6, 0x10, 16);\nMLXSW_ITEM32(reg, rmft2, dip4, 0x1C, 0, 32);\n\n \nMLXSW_ITEM_BUF(reg, rmft2, dip6_mask, 0x20, 16);\nMLXSW_ITEM32(reg, rmft2, dip4_mask, 0x2C, 0, 32);\n\n \nMLXSW_ITEM_BUF(reg, rmft2, sip6, 0x30, 16);\nMLXSW_ITEM32(reg, rmft2, sip4, 0x3C, 0, 32);\n\n \nMLXSW_ITEM_BUF(reg, rmft2, sip6_mask, 0x40, 16);\nMLXSW_ITEM32(reg, rmft2, sip4_mask, 0x4C, 0, 32);\n\n \nMLXSW_ITEM_BUF(reg, rmft2, flexible_action_set, 0x80,\n\t       MLXSW_REG_FLEX_ACTION_SET_LEN);\n\nstatic inline void\nmlxsw_reg_rmft2_common_pack(char *payload, bool v, u16 offset,\n\t\t\t    u16 virtual_router,\n\t\t\t    enum mlxsw_reg_rmft2_irif_mask irif_mask, u16 irif,\n\t\t\t    const char *flex_action_set)\n{\n\tMLXSW_REG_ZERO(rmft2, payload);\n\tmlxsw_reg_rmft2_v_set(payload, v);\n\tmlxsw_reg_rmft2_op_set(payload, MLXSW_REG_RMFT2_OP_READ_WRITE);\n\tmlxsw_reg_rmft2_offset_set(payload, offset);\n\tmlxsw_reg_rmft2_virtual_router_set(payload, virtual_router);\n\tmlxsw_reg_rmft2_irif_mask_set(payload, irif_mask);\n\tmlxsw_reg_rmft2_irif_set(payload, irif);\n\tif (flex_action_set)\n\t\tmlxsw_reg_rmft2_flexible_action_set_memcpy_to(payload,\n\t\t\t\t\t\t\t      flex_action_set);\n}\n\nstatic inline void\nmlxsw_reg_rmft2_ipv4_pack(char *payload, bool v, u16 offset, u16 virtual_router,\n\t\t\t  enum mlxsw_reg_rmft2_irif_mask irif_mask, u16 irif,\n\t\t\t  u32 dip4, u32 dip4_mask, u32 sip4, u32 sip4_mask,\n\t\t\t  const char *flexible_action_set)\n{\n\tmlxsw_reg_rmft2_common_pack(payload, v, offset, virtual_router,\n\t\t\t\t    irif_mask, irif, flexible_action_set);\n\tmlxsw_reg_rmft2_type_set(payload, MLXSW_REG_RMFT2_TYPE_IPV4);\n\tmlxsw_reg_rmft2_dip4_set(payload, dip4);\n\tmlxsw_reg_rmft2_dip4_mask_set(payload, dip4_mask);\n\tmlxsw_reg_rmft2_sip4_set(payload, sip4);\n\tmlxsw_reg_rmft2_sip4_mask_set(payload, sip4_mask);\n}\n\nstatic inline void\nmlxsw_reg_rmft2_ipv6_pack(char *payload, bool v, u16 offset, u16 virtual_router,\n\t\t\t  enum mlxsw_reg_rmft2_irif_mask irif_mask, u16 irif,\n\t\t\t  struct in6_addr dip6, struct in6_addr dip6_mask,\n\t\t\t  struct in6_addr sip6, struct in6_addr sip6_mask,\n\t\t\t  const char *flexible_action_set)\n{\n\tmlxsw_reg_rmft2_common_pack(payload, v, offset, virtual_router,\n\t\t\t\t    irif_mask, irif, flexible_action_set);\n\tmlxsw_reg_rmft2_type_set(payload, MLXSW_REG_RMFT2_TYPE_IPV6);\n\tmlxsw_reg_rmft2_dip6_memcpy_to(payload, (void *)&dip6);\n\tmlxsw_reg_rmft2_dip6_mask_memcpy_to(payload, (void *)&dip6_mask);\n\tmlxsw_reg_rmft2_sip6_memcpy_to(payload, (void *)&sip6);\n\tmlxsw_reg_rmft2_sip6_mask_memcpy_to(payload, (void *)&sip6_mask);\n}\n\n \n#define MLXSW_REG_REIV_ID 0x8034\n#define MLXSW_REG_REIV_BASE_LEN 0x20  \n#define MLXSW_REG_REIV_REC_LEN 0x04  \n#define MLXSW_REG_REIV_REC_MAX_COUNT 256  \n#define MLXSW_REG_REIV_LEN (MLXSW_REG_REIV_BASE_LEN +\t\\\n\t\t\t    MLXSW_REG_REIV_REC_LEN *\t\\\n\t\t\t    MLXSW_REG_REIV_REC_MAX_COUNT)\n\nMLXSW_REG_DEFINE(reiv, MLXSW_REG_REIV_ID, MLXSW_REG_REIV_LEN);\n\n \nMLXSW_ITEM32(reg, reiv, port_page, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, reiv, erif, 0x04, 0, 16);\n\n \nMLXSW_ITEM32_INDEXED(reg, reiv, rec_update, MLXSW_REG_REIV_BASE_LEN, 31, 1,\n\t\t     MLXSW_REG_REIV_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, reiv, rec_evid, MLXSW_REG_REIV_BASE_LEN, 0, 12,\n\t\t     MLXSW_REG_REIV_REC_LEN, 0x00, false);\n\nstatic inline void mlxsw_reg_reiv_pack(char *payload, u8 port_page, u16 erif)\n{\n\tMLXSW_REG_ZERO(reiv, payload);\n\tmlxsw_reg_reiv_port_page_set(payload, port_page);\n\tmlxsw_reg_reiv_erif_set(payload, erif);\n}\n\n \n#define MLXSW_REG_MFCR_ID 0x9001\n#define MLXSW_REG_MFCR_LEN 0x08\n\nMLXSW_REG_DEFINE(mfcr, MLXSW_REG_MFCR_ID, MLXSW_REG_MFCR_LEN);\n\nenum mlxsw_reg_mfcr_pwm_frequency {\n\tMLXSW_REG_MFCR_PWM_FEQ_11HZ = 0x00,\n\tMLXSW_REG_MFCR_PWM_FEQ_14_7HZ = 0x01,\n\tMLXSW_REG_MFCR_PWM_FEQ_22_1HZ = 0x02,\n\tMLXSW_REG_MFCR_PWM_FEQ_1_4KHZ = 0x40,\n\tMLXSW_REG_MFCR_PWM_FEQ_5KHZ = 0x41,\n\tMLXSW_REG_MFCR_PWM_FEQ_20KHZ = 0x42,\n\tMLXSW_REG_MFCR_PWM_FEQ_22_5KHZ = 0x43,\n\tMLXSW_REG_MFCR_PWM_FEQ_25KHZ = 0x44,\n};\n\n \nMLXSW_ITEM32(reg, mfcr, pwm_frequency, 0x00, 0, 7);\n\n#define MLXSW_MFCR_TACHOS_MAX 10\n\n \nMLXSW_ITEM32(reg, mfcr, tacho_active, 0x04, 16, MLXSW_MFCR_TACHOS_MAX);\n\n#define MLXSW_MFCR_PWMS_MAX 5\n\n \nMLXSW_ITEM32(reg, mfcr, pwm_active, 0x04, 0, MLXSW_MFCR_PWMS_MAX);\n\nstatic inline void\nmlxsw_reg_mfcr_pack(char *payload,\n\t\t    enum mlxsw_reg_mfcr_pwm_frequency pwm_frequency)\n{\n\tMLXSW_REG_ZERO(mfcr, payload);\n\tmlxsw_reg_mfcr_pwm_frequency_set(payload, pwm_frequency);\n}\n\nstatic inline void\nmlxsw_reg_mfcr_unpack(char *payload,\n\t\t      enum mlxsw_reg_mfcr_pwm_frequency *p_pwm_frequency,\n\t\t      u16 *p_tacho_active, u8 *p_pwm_active)\n{\n\t*p_pwm_frequency = mlxsw_reg_mfcr_pwm_frequency_get(payload);\n\t*p_tacho_active = mlxsw_reg_mfcr_tacho_active_get(payload);\n\t*p_pwm_active = mlxsw_reg_mfcr_pwm_active_get(payload);\n}\n\n \n#define MLXSW_REG_MFSC_ID 0x9002\n#define MLXSW_REG_MFSC_LEN 0x08\n\nMLXSW_REG_DEFINE(mfsc, MLXSW_REG_MFSC_ID, MLXSW_REG_MFSC_LEN);\n\n \nMLXSW_ITEM32(reg, mfsc, pwm, 0x00, 24, 3);\n\n \nMLXSW_ITEM32(reg, mfsc, pwm_duty_cycle, 0x04, 0, 8);\n\nstatic inline void mlxsw_reg_mfsc_pack(char *payload, u8 pwm,\n\t\t\t\t       u8 pwm_duty_cycle)\n{\n\tMLXSW_REG_ZERO(mfsc, payload);\n\tmlxsw_reg_mfsc_pwm_set(payload, pwm);\n\tmlxsw_reg_mfsc_pwm_duty_cycle_set(payload, pwm_duty_cycle);\n}\n\n \n#define MLXSW_REG_MFSM_ID 0x9003\n#define MLXSW_REG_MFSM_LEN 0x08\n\nMLXSW_REG_DEFINE(mfsm, MLXSW_REG_MFSM_ID, MLXSW_REG_MFSM_LEN);\n\n \nMLXSW_ITEM32(reg, mfsm, tacho, 0x00, 24, 4);\n\n \nMLXSW_ITEM32(reg, mfsm, rpm, 0x04, 0, 16);\n\nstatic inline void mlxsw_reg_mfsm_pack(char *payload, u8 tacho)\n{\n\tMLXSW_REG_ZERO(mfsm, payload);\n\tmlxsw_reg_mfsm_tacho_set(payload, tacho);\n}\n\n \n#define MLXSW_REG_MFSL_ID 0x9004\n#define MLXSW_REG_MFSL_LEN 0x0C\n\nMLXSW_REG_DEFINE(mfsl, MLXSW_REG_MFSL_ID, MLXSW_REG_MFSL_LEN);\n\n \nMLXSW_ITEM32(reg, mfsl, tacho, 0x00, 24, 4);\n\n \nMLXSW_ITEM32(reg, mfsl, tach_min, 0x04, 0, 16);\n\n \nMLXSW_ITEM32(reg, mfsl, tach_max, 0x08, 0, 16);\n\nstatic inline void mlxsw_reg_mfsl_pack(char *payload, u8 tacho,\n\t\t\t\t       u16 tach_min, u16 tach_max)\n{\n\tMLXSW_REG_ZERO(mfsl, payload);\n\tmlxsw_reg_mfsl_tacho_set(payload, tacho);\n\tmlxsw_reg_mfsl_tach_min_set(payload, tach_min);\n\tmlxsw_reg_mfsl_tach_max_set(payload, tach_max);\n}\n\nstatic inline void mlxsw_reg_mfsl_unpack(char *payload, u8 tacho,\n\t\t\t\t\t u16 *p_tach_min, u16 *p_tach_max)\n{\n\tif (p_tach_min)\n\t\t*p_tach_min = mlxsw_reg_mfsl_tach_min_get(payload);\n\n\tif (p_tach_max)\n\t\t*p_tach_max = mlxsw_reg_mfsl_tach_max_get(payload);\n}\n\n \n#define MLXSW_REG_FORE_ID 0x9007\n#define MLXSW_REG_FORE_LEN 0x0C\n\nMLXSW_REG_DEFINE(fore, MLXSW_REG_FORE_ID, MLXSW_REG_FORE_LEN);\n\n \nMLXSW_ITEM32(reg, fore, fan_under_limit, 0x00, 16, 10);\n\nstatic inline void mlxsw_reg_fore_unpack(char *payload, u8 tacho,\n\t\t\t\t\t bool *fault)\n{\n\tu16 limit;\n\n\tif (fault) {\n\t\tlimit = mlxsw_reg_fore_fan_under_limit_get(payload);\n\t\t*fault = limit & BIT(tacho);\n\t}\n}\n\n \n#define MLXSW_REG_MTCAP_ID 0x9009\n#define MLXSW_REG_MTCAP_LEN 0x08\n\nMLXSW_REG_DEFINE(mtcap, MLXSW_REG_MTCAP_ID, MLXSW_REG_MTCAP_LEN);\n\n \nMLXSW_ITEM32(reg, mtcap, sensor_count, 0x00, 0, 7);\n\n \n#define MLXSW_REG_MTMP_ID 0x900A\n#define MLXSW_REG_MTMP_LEN 0x20\n\nMLXSW_REG_DEFINE(mtmp, MLXSW_REG_MTMP_ID, MLXSW_REG_MTMP_LEN);\n\n \nMLXSW_ITEM32(reg, mtmp, slot_index, 0x00, 16, 4);\n\n#define MLXSW_REG_MTMP_MODULE_INDEX_MIN 64\n#define MLXSW_REG_MTMP_GBOX_INDEX_MIN 256\n \nMLXSW_ITEM32(reg, mtmp, sensor_index, 0x00, 0, 12);\n\n \n#define MLXSW_REG_MTMP_TEMP_TO_MC(val) ({ typeof(val) v_ = (val); \\\n\t\t\t\t\t  ((v_) >= 0) ? ((v_) * 125) : \\\n\t\t\t\t\t  ((s16)((GENMASK(15, 0) + (v_) + 1) \\\n\t\t\t\t\t   * 125)); })\n\n \nMLXSW_ITEM32(reg, mtmp, max_operational_temperature, 0x04, 16, 16);\n\n \nMLXSW_ITEM32(reg, mtmp, temperature, 0x04, 0, 16);\n\n \nMLXSW_ITEM32(reg, mtmp, mte, 0x08, 31, 1);\n\n \nMLXSW_ITEM32(reg, mtmp, mtr, 0x08, 30, 1);\n\n \nMLXSW_ITEM32(reg, mtmp, max_temperature, 0x08, 0, 16);\n\n \n\nenum mlxsw_reg_mtmp_tee {\n\tMLXSW_REG_MTMP_TEE_NO_EVENT,\n\tMLXSW_REG_MTMP_TEE_GENERATE_EVENT,\n\tMLXSW_REG_MTMP_TEE_GENERATE_SINGLE_EVENT,\n};\n\nMLXSW_ITEM32(reg, mtmp, tee, 0x0C, 30, 2);\n\n#define MLXSW_REG_MTMP_THRESH_HI 0x348\t \n\n \nMLXSW_ITEM32(reg, mtmp, temperature_threshold_hi, 0x0C, 0, 16);\n\n#define MLXSW_REG_MTMP_HYSTERESIS_TEMP 0x28  \n \nMLXSW_ITEM32(reg, mtmp, temperature_threshold_lo, 0x10, 0, 16);\n\n#define MLXSW_REG_MTMP_SENSOR_NAME_SIZE 8\n\n \nMLXSW_ITEM_BUF(reg, mtmp, sensor_name, 0x18, MLXSW_REG_MTMP_SENSOR_NAME_SIZE);\n\nstatic inline void mlxsw_reg_mtmp_pack(char *payload, u8 slot_index,\n\t\t\t\t       u16 sensor_index, bool max_temp_enable,\n\t\t\t\t       bool max_temp_reset)\n{\n\tMLXSW_REG_ZERO(mtmp, payload);\n\tmlxsw_reg_mtmp_slot_index_set(payload, slot_index);\n\tmlxsw_reg_mtmp_sensor_index_set(payload, sensor_index);\n\tmlxsw_reg_mtmp_mte_set(payload, max_temp_enable);\n\tmlxsw_reg_mtmp_mtr_set(payload, max_temp_reset);\n\tmlxsw_reg_mtmp_temperature_threshold_hi_set(payload,\n\t\t\t\t\t\t    MLXSW_REG_MTMP_THRESH_HI);\n}\n\nstatic inline void mlxsw_reg_mtmp_unpack(char *payload, int *p_temp,\n\t\t\t\t\t int *p_max_temp, int *p_temp_hi,\n\t\t\t\t\t int *p_max_oper_temp,\n\t\t\t\t\t char *sensor_name)\n{\n\ts16 temp;\n\n\tif (p_temp) {\n\t\ttemp = mlxsw_reg_mtmp_temperature_get(payload);\n\t\t*p_temp = MLXSW_REG_MTMP_TEMP_TO_MC(temp);\n\t}\n\tif (p_max_temp) {\n\t\ttemp = mlxsw_reg_mtmp_max_temperature_get(payload);\n\t\t*p_max_temp = MLXSW_REG_MTMP_TEMP_TO_MC(temp);\n\t}\n\tif (p_temp_hi) {\n\t\ttemp = mlxsw_reg_mtmp_temperature_threshold_hi_get(payload);\n\t\t*p_temp_hi = MLXSW_REG_MTMP_TEMP_TO_MC(temp);\n\t}\n\tif (p_max_oper_temp) {\n\t\ttemp = mlxsw_reg_mtmp_max_operational_temperature_get(payload);\n\t\t*p_max_oper_temp = MLXSW_REG_MTMP_TEMP_TO_MC(temp);\n\t}\n\tif (sensor_name)\n\t\tmlxsw_reg_mtmp_sensor_name_memcpy_from(payload, sensor_name);\n}\n\n \n#define MLXSW_REG_MTWE_ID 0x900B\n#define MLXSW_REG_MTWE_LEN 0x10\n\nMLXSW_REG_DEFINE(mtwe, MLXSW_REG_MTWE_ID, MLXSW_REG_MTWE_LEN);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, mtwe, sensor_warning, 0x0, 0x10, 1);\n\n \n#define MLXSW_REG_MTBR_ID 0x900F\n#define MLXSW_REG_MTBR_BASE_LEN 0x10  \n#define MLXSW_REG_MTBR_REC_LEN 0x04  \n#define MLXSW_REG_MTBR_REC_MAX_COUNT 47  \n#define MLXSW_REG_MTBR_LEN (MLXSW_REG_MTBR_BASE_LEN +\t\\\n\t\t\t    MLXSW_REG_MTBR_REC_LEN *\t\\\n\t\t\t    MLXSW_REG_MTBR_REC_MAX_COUNT)\n\nMLXSW_REG_DEFINE(mtbr, MLXSW_REG_MTBR_ID, MLXSW_REG_MTBR_LEN);\n\n \nMLXSW_ITEM32(reg, mtbr, slot_index, 0x00, 16, 4);\n\n \nMLXSW_ITEM32(reg, mtbr, base_sensor_index, 0x00, 0, 12);\n\n \nMLXSW_ITEM32(reg, mtbr, num_rec, 0x04, 0, 8);\n\n \nMLXSW_ITEM32_INDEXED(reg, mtbr, rec_max_temp, MLXSW_REG_MTBR_BASE_LEN, 16,\n\t\t     16, MLXSW_REG_MTBR_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, mtbr, rec_temp, MLXSW_REG_MTBR_BASE_LEN, 0, 16,\n\t\t     MLXSW_REG_MTBR_REC_LEN, 0x00, false);\n\nstatic inline void mlxsw_reg_mtbr_pack(char *payload, u8 slot_index,\n\t\t\t\t       u16 base_sensor_index, u8 num_rec)\n{\n\tMLXSW_REG_ZERO(mtbr, payload);\n\tmlxsw_reg_mtbr_slot_index_set(payload, slot_index);\n\tmlxsw_reg_mtbr_base_sensor_index_set(payload, base_sensor_index);\n\tmlxsw_reg_mtbr_num_rec_set(payload, num_rec);\n}\n\n \nenum mlxsw_reg_mtbr_temp_status {\n\tMLXSW_REG_MTBR_NO_CONN\t\t= 0x8000,\n\tMLXSW_REG_MTBR_NO_TEMP_SENS\t= 0x8001,\n\tMLXSW_REG_MTBR_INDEX_NA\t\t= 0x8002,\n\tMLXSW_REG_MTBR_BAD_SENS_INFO\t= 0x8003,\n};\n\n \n#define MLXSW_REG_MTBR_BASE_MODULE_INDEX 64\n\nstatic inline void mlxsw_reg_mtbr_temp_unpack(char *payload, int rec_ind,\n\t\t\t\t\t      u16 *p_temp, u16 *p_max_temp)\n{\n\tif (p_temp)\n\t\t*p_temp = mlxsw_reg_mtbr_rec_temp_get(payload, rec_ind);\n\tif (p_max_temp)\n\t\t*p_max_temp = mlxsw_reg_mtbr_rec_max_temp_get(payload, rec_ind);\n}\n\n \n\n#define MLXSW_REG_MCIA_ID 0x9014\n#define MLXSW_REG_MCIA_LEN 0x94\n\nMLXSW_REG_DEFINE(mcia, MLXSW_REG_MCIA_ID, MLXSW_REG_MCIA_LEN);\n\n \nMLXSW_ITEM32(reg, mcia, module, 0x00, 16, 8);\n\n \nMLXSW_ITEM32(reg, mcia, slot, 0x00, 12, 4);\n\nenum {\n\tMLXSW_REG_MCIA_STATUS_GOOD = 0,\n\t \n\tMLXSW_REG_MCIA_STATUS_NO_EEPROM_MODULE = 1,\n\t \n\tMLXSW_REG_MCIA_STATUS_MODULE_NOT_SUPPORTED = 2,\n\t \n\tMLXSW_REG_MCIA_STATUS_MODULE_NOT_CONNECTED = 3,\n\t \n\tMLXSW_REG_MCIA_STATUS_I2C_ERROR = 9,\n\t \n\tMLXSW_REG_MCIA_STATUS_MODULE_DISABLED = 16,\n};\n\n \nMLXSW_ITEM32(reg, mcia, status, 0x00, 0, 8);\n\n \nMLXSW_ITEM32(reg, mcia, i2c_device_address, 0x04, 24, 8);\n\n \nMLXSW_ITEM32(reg, mcia, page_number, 0x04, 16, 8);\n\n \nMLXSW_ITEM32(reg, mcia, device_address, 0x04, 0, 16);\n\n \nMLXSW_ITEM32(reg, mcia, bank_number, 0x08, 16, 8);\n\n \nMLXSW_ITEM32(reg, mcia, size, 0x08, 0, 16);\n\n#define MLXSW_REG_MCIA_EEPROM_PAGE_LENGTH\t256\n#define MLXSW_REG_MCIA_EEPROM_UP_PAGE_LENGTH\t128\n#define MLXSW_REG_MCIA_I2C_ADDR_LOW\t\t0x50\n#define MLXSW_REG_MCIA_I2C_ADDR_HIGH\t\t0x51\n#define MLXSW_REG_MCIA_PAGE0_LO_OFF\t\t0xa0\n#define MLXSW_REG_MCIA_TH_ITEM_SIZE\t\t2\n#define MLXSW_REG_MCIA_TH_PAGE_NUM\t\t3\n#define MLXSW_REG_MCIA_TH_PAGE_CMIS_NUM\t\t2\n#define MLXSW_REG_MCIA_PAGE0_LO\t\t\t0\n#define MLXSW_REG_MCIA_TH_PAGE_OFF\t\t0x80\n#define MLXSW_REG_MCIA_EEPROM_CMIS_FLAT_MEMORY\tBIT(7)\n\nenum mlxsw_reg_mcia_eeprom_module_info_rev_id {\n\tMLXSW_REG_MCIA_EEPROM_MODULE_INFO_REV_ID_UNSPC\t= 0x00,\n\tMLXSW_REG_MCIA_EEPROM_MODULE_INFO_REV_ID_8436\t= 0x01,\n\tMLXSW_REG_MCIA_EEPROM_MODULE_INFO_REV_ID_8636\t= 0x03,\n};\n\nenum mlxsw_reg_mcia_eeprom_module_info_id {\n\tMLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_SFP\t= 0x03,\n\tMLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP\t= 0x0C,\n\tMLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP_PLUS\t= 0x0D,\n\tMLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP28\t= 0x11,\n\tMLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_QSFP_DD\t= 0x18,\n\tMLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID_OSFP\t= 0x19,\n};\n\nenum mlxsw_reg_mcia_eeprom_module_info {\n\tMLXSW_REG_MCIA_EEPROM_MODULE_INFO_ID,\n\tMLXSW_REG_MCIA_EEPROM_MODULE_INFO_REV_ID,\n\tMLXSW_REG_MCIA_EEPROM_MODULE_INFO_TYPE_ID,\n\tMLXSW_REG_MCIA_EEPROM_MODULE_INFO_SIZE,\n};\n\n \nMLXSW_ITEM_BUF(reg, mcia, eeprom, 0x10, 128);\n\n \n#define MLXSW_REG_MCIA_PAGE_GET(off) (((off) - \\\n\t\t\t\tMLXSW_REG_MCIA_EEPROM_PAGE_LENGTH) / \\\n\t\t\t\tMLXSW_REG_MCIA_EEPROM_UP_PAGE_LENGTH + 1)\n\nstatic inline void mlxsw_reg_mcia_pack(char *payload, u8 slot_index, u8 module,\n\t\t\t\t       u8 page_number, u16 device_addr, u8 size,\n\t\t\t\t       u8 i2c_device_addr)\n{\n\tMLXSW_REG_ZERO(mcia, payload);\n\tmlxsw_reg_mcia_slot_set(payload, slot_index);\n\tmlxsw_reg_mcia_module_set(payload, module);\n\tmlxsw_reg_mcia_page_number_set(payload, page_number);\n\tmlxsw_reg_mcia_device_address_set(payload, device_addr);\n\tmlxsw_reg_mcia_size_set(payload, size);\n\tmlxsw_reg_mcia_i2c_device_address_set(payload, i2c_device_addr);\n}\n\n \n#define MLXSW_REG_MPAT_ID 0x901A\n#define MLXSW_REG_MPAT_LEN 0x78\n\nMLXSW_REG_DEFINE(mpat, MLXSW_REG_MPAT_ID, MLXSW_REG_MPAT_LEN);\n\n \nMLXSW_ITEM32(reg, mpat, pa_id, 0x00, 28, 4);\n\n \nMLXSW_ITEM32(reg, mpat, session_id, 0x00, 24, 4);\n\n \nMLXSW_ITEM32(reg, mpat, system_port, 0x00, 0, 16);\n\n \nMLXSW_ITEM32(reg, mpat, e, 0x04, 31, 1);\n\n \nMLXSW_ITEM32(reg, mpat, qos, 0x04, 26, 1);\n\n \nMLXSW_ITEM32(reg, mpat, be, 0x04, 25, 1);\n\nenum mlxsw_reg_mpat_span_type {\n\t \n\tMLXSW_REG_MPAT_SPAN_TYPE_LOCAL_ETH = 0x0,\n\n\t \n\tMLXSW_REG_MPAT_SPAN_TYPE_REMOTE_ETH = 0x1,\n\n\t \n\tMLXSW_REG_MPAT_SPAN_TYPE_REMOTE_ETH_L3 = 0x3,\n};\n\n \nMLXSW_ITEM32(reg, mpat, span_type, 0x04, 0, 4);\n\n \nMLXSW_ITEM32(reg, mpat, pide, 0x0C, 15, 1);\n\n \nMLXSW_ITEM32(reg, mpat, pid, 0x0C, 0, 14);\n\n \n\n \nMLXSW_ITEM32(reg, mpat, eth_rspan_vid, 0x18, 0, 12);\n\n \n\nenum mlxsw_reg_mpat_eth_rspan_version {\n\tMLXSW_REG_MPAT_ETH_RSPAN_VERSION_NO_HEADER = 15,\n};\n\n \nMLXSW_ITEM32(reg, mpat, eth_rspan_version, 0x10, 18, 4);\n\n \nMLXSW_ITEM_BUF(reg, mpat, eth_rspan_mac, 0x12, 6);\n\n \nMLXSW_ITEM32(reg, mpat, eth_rspan_tp, 0x18, 16, 1);\n\n \n\nenum mlxsw_reg_mpat_eth_rspan_protocol {\n\tMLXSW_REG_MPAT_ETH_RSPAN_PROTOCOL_IPV4,\n\tMLXSW_REG_MPAT_ETH_RSPAN_PROTOCOL_IPV6,\n};\n\n \nMLXSW_ITEM32(reg, mpat, eth_rspan_protocol, 0x18, 24, 4);\n\n \nMLXSW_ITEM32(reg, mpat, eth_rspan_ttl, 0x1C, 4, 8);\n\n \nMLXSW_ITEM_BUF(reg, mpat, eth_rspan_smac, 0x22, 6);\n\n \nMLXSW_ITEM32(reg, mpat, eth_rspan_dip4, 0x4C, 0, 32);\nMLXSW_ITEM_BUF(reg, mpat, eth_rspan_dip6, 0x40, 16);\n\n \nMLXSW_ITEM32(reg, mpat, eth_rspan_sip4, 0x5C, 0, 32);\nMLXSW_ITEM_BUF(reg, mpat, eth_rspan_sip6, 0x50, 16);\n\nstatic inline void mlxsw_reg_mpat_pack(char *payload, u8 pa_id,\n\t\t\t\t       u16 system_port, bool e,\n\t\t\t\t       enum mlxsw_reg_mpat_span_type span_type)\n{\n\tMLXSW_REG_ZERO(mpat, payload);\n\tmlxsw_reg_mpat_pa_id_set(payload, pa_id);\n\tmlxsw_reg_mpat_system_port_set(payload, system_port);\n\tmlxsw_reg_mpat_e_set(payload, e);\n\tmlxsw_reg_mpat_qos_set(payload, 1);\n\tmlxsw_reg_mpat_be_set(payload, 1);\n\tmlxsw_reg_mpat_span_type_set(payload, span_type);\n}\n\nstatic inline void mlxsw_reg_mpat_eth_rspan_pack(char *payload, u16 vid)\n{\n\tmlxsw_reg_mpat_eth_rspan_vid_set(payload, vid);\n}\n\nstatic inline void\nmlxsw_reg_mpat_eth_rspan_l2_pack(char *payload,\n\t\t\t\t enum mlxsw_reg_mpat_eth_rspan_version version,\n\t\t\t\t const char *mac,\n\t\t\t\t bool tp)\n{\n\tmlxsw_reg_mpat_eth_rspan_version_set(payload, version);\n\tmlxsw_reg_mpat_eth_rspan_mac_memcpy_to(payload, mac);\n\tmlxsw_reg_mpat_eth_rspan_tp_set(payload, tp);\n}\n\nstatic inline void\nmlxsw_reg_mpat_eth_rspan_l3_ipv4_pack(char *payload, u8 ttl,\n\t\t\t\t      const char *smac,\n\t\t\t\t      u32 sip, u32 dip)\n{\n\tmlxsw_reg_mpat_eth_rspan_ttl_set(payload, ttl);\n\tmlxsw_reg_mpat_eth_rspan_smac_memcpy_to(payload, smac);\n\tmlxsw_reg_mpat_eth_rspan_protocol_set(payload,\n\t\t\t\t    MLXSW_REG_MPAT_ETH_RSPAN_PROTOCOL_IPV4);\n\tmlxsw_reg_mpat_eth_rspan_sip4_set(payload, sip);\n\tmlxsw_reg_mpat_eth_rspan_dip4_set(payload, dip);\n}\n\nstatic inline void\nmlxsw_reg_mpat_eth_rspan_l3_ipv6_pack(char *payload, u8 ttl,\n\t\t\t\t      const char *smac,\n\t\t\t\t      struct in6_addr sip, struct in6_addr dip)\n{\n\tmlxsw_reg_mpat_eth_rspan_ttl_set(payload, ttl);\n\tmlxsw_reg_mpat_eth_rspan_smac_memcpy_to(payload, smac);\n\tmlxsw_reg_mpat_eth_rspan_protocol_set(payload,\n\t\t\t\t    MLXSW_REG_MPAT_ETH_RSPAN_PROTOCOL_IPV6);\n\tmlxsw_reg_mpat_eth_rspan_sip6_memcpy_to(payload, (void *)&sip);\n\tmlxsw_reg_mpat_eth_rspan_dip6_memcpy_to(payload, (void *)&dip);\n}\n\n \n#define MLXSW_REG_MPAR_ID 0x901B\n#define MLXSW_REG_MPAR_LEN 0x0C\n\nMLXSW_REG_DEFINE(mpar, MLXSW_REG_MPAR_ID, MLXSW_REG_MPAR_LEN);\n\n \nMLXSW_ITEM32_LP(reg, mpar, 0x00, 16, 0x00, 4);\n\nenum mlxsw_reg_mpar_i_e {\n\tMLXSW_REG_MPAR_TYPE_EGRESS,\n\tMLXSW_REG_MPAR_TYPE_INGRESS,\n};\n\n \nMLXSW_ITEM32(reg, mpar, i_e, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, mpar, enable, 0x04, 31, 1);\n\n \nMLXSW_ITEM32(reg, mpar, pa_id, 0x04, 0, 4);\n\n#define MLXSW_REG_MPAR_RATE_MAX 3500000000UL\n\n \nMLXSW_ITEM32(reg, mpar, probability_rate, 0x08, 0, 32);\n\nstatic inline void mlxsw_reg_mpar_pack(char *payload, u16 local_port,\n\t\t\t\t       enum mlxsw_reg_mpar_i_e i_e,\n\t\t\t\t       bool enable, u8 pa_id,\n\t\t\t\t       u32 probability_rate)\n{\n\tMLXSW_REG_ZERO(mpar, payload);\n\tmlxsw_reg_mpar_local_port_set(payload, local_port);\n\tmlxsw_reg_mpar_enable_set(payload, enable);\n\tmlxsw_reg_mpar_i_e_set(payload, i_e);\n\tmlxsw_reg_mpar_pa_id_set(payload, pa_id);\n\tmlxsw_reg_mpar_probability_rate_set(payload, probability_rate);\n}\n\n \n#define MLXSW_REG_MGIR_ID 0x9020\n#define MLXSW_REG_MGIR_LEN 0x9C\n\nMLXSW_REG_DEFINE(mgir, MLXSW_REG_MGIR_ID, MLXSW_REG_MGIR_LEN);\n\n \nMLXSW_ITEM32(reg, mgir, hw_info_device_hw_revision, 0x0, 16, 16);\n\n \nMLXSW_ITEM32(reg, mgir, fw_info_latency_tlv, 0x20, 29, 1);\n\n \nMLXSW_ITEM32(reg, mgir, fw_info_string_tlv, 0x20, 28, 1);\n\n#define MLXSW_REG_MGIR_FW_INFO_PSID_SIZE 16\n\n \nMLXSW_ITEM_BUF(reg, mgir, fw_info_psid, 0x30, MLXSW_REG_MGIR_FW_INFO_PSID_SIZE);\n\n \nMLXSW_ITEM32(reg, mgir, fw_info_extended_major, 0x44, 0, 32);\n\n \nMLXSW_ITEM32(reg, mgir, fw_info_extended_minor, 0x48, 0, 32);\n\n \nMLXSW_ITEM32(reg, mgir, fw_info_extended_sub_minor, 0x4C, 0, 32);\n\nstatic inline void mlxsw_reg_mgir_pack(char *payload)\n{\n\tMLXSW_REG_ZERO(mgir, payload);\n}\n\nstatic inline void\nmlxsw_reg_mgir_unpack(char *payload, u32 *hw_rev, char *fw_info_psid,\n\t\t      u32 *fw_major, u32 *fw_minor, u32 *fw_sub_minor)\n{\n\t*hw_rev = mlxsw_reg_mgir_hw_info_device_hw_revision_get(payload);\n\tmlxsw_reg_mgir_fw_info_psid_memcpy_from(payload, fw_info_psid);\n\t*fw_major = mlxsw_reg_mgir_fw_info_extended_major_get(payload);\n\t*fw_minor = mlxsw_reg_mgir_fw_info_extended_minor_get(payload);\n\t*fw_sub_minor = mlxsw_reg_mgir_fw_info_extended_sub_minor_get(payload);\n}\n\n \n#define MLXSW_REG_MRSR_ID 0x9023\n#define MLXSW_REG_MRSR_LEN 0x08\n\nMLXSW_REG_DEFINE(mrsr, MLXSW_REG_MRSR_ID, MLXSW_REG_MRSR_LEN);\n\n \nMLXSW_ITEM32(reg, mrsr, command, 0x00, 0, 4);\n\nstatic inline void mlxsw_reg_mrsr_pack(char *payload)\n{\n\tMLXSW_REG_ZERO(mrsr, payload);\n\tmlxsw_reg_mrsr_command_set(payload, 1);\n}\n\n \n#define MLXSW_REG_MLCR_ID 0x902B\n#define MLXSW_REG_MLCR_LEN 0x0C\n\nMLXSW_REG_DEFINE(mlcr, MLXSW_REG_MLCR_ID, MLXSW_REG_MLCR_LEN);\n\n \nMLXSW_ITEM32_LP(reg, mlcr, 0x00, 16, 0x00, 24);\n\n#define MLXSW_REG_MLCR_DURATION_MAX 0xFFFF\n\n \nMLXSW_ITEM32(reg, mlcr, beacon_duration, 0x04, 0, 16);\n\n \nMLXSW_ITEM32(reg, mlcr, beacon_remain, 0x08, 0, 16);\n\nstatic inline void mlxsw_reg_mlcr_pack(char *payload, u16 local_port,\n\t\t\t\t       bool active)\n{\n\tMLXSW_REG_ZERO(mlcr, payload);\n\tmlxsw_reg_mlcr_local_port_set(payload, local_port);\n\tmlxsw_reg_mlcr_beacon_duration_set(payload, active ?\n\t\t\t\t\t   MLXSW_REG_MLCR_DURATION_MAX : 0);\n}\n\n \n#define MLXSW_REG_MCION_ID 0x9052\n#define MLXSW_REG_MCION_LEN 0x18\n\nMLXSW_REG_DEFINE(mcion, MLXSW_REG_MCION_ID, MLXSW_REG_MCION_LEN);\n\n \nMLXSW_ITEM32(reg, mcion, module, 0x00, 16, 8);\n\n \nMLXSW_ITEM32(reg, mcion, slot_index, 0x00, 12, 4);\n\nenum {\n\tMLXSW_REG_MCION_MODULE_STATUS_BITS_PRESENT_MASK = BIT(0),\n\tMLXSW_REG_MCION_MODULE_STATUS_BITS_LOW_POWER_MASK = BIT(8),\n};\n\n \nMLXSW_ITEM32(reg, mcion, module_status_bits, 0x04, 0, 16);\n\nstatic inline void mlxsw_reg_mcion_pack(char *payload, u8 slot_index, u8 module)\n{\n\tMLXSW_REG_ZERO(mcion, payload);\n\tmlxsw_reg_mcion_slot_index_set(payload, slot_index);\n\tmlxsw_reg_mcion_module_set(payload, module);\n}\n\n \n#define MLXSW_REG_MTPPS_ID 0x9053\n#define MLXSW_REG_MTPPS_LEN 0x3C\n\nMLXSW_REG_DEFINE(mtpps, MLXSW_REG_MTPPS_ID, MLXSW_REG_MTPPS_LEN);\n\n \nMLXSW_ITEM32(reg, mtpps, enable, 0x20, 31, 1);\n\nenum mlxsw_reg_mtpps_pin_mode {\n\tMLXSW_REG_MTPPS_PIN_MODE_VIRTUAL_PIN = 0x2,\n};\n\n \nMLXSW_ITEM32(reg, mtpps, pin_mode, 0x20, 8, 4);\n\n#define MLXSW_REG_MTPPS_PIN_SP_VIRTUAL_PIN\t7\n\n \nMLXSW_ITEM32(reg, mtpps, pin, 0x20, 0, 8);\n\n \nMLXSW_ITEM64(reg, mtpps, time_stamp, 0x28, 0, 64);\n\nstatic inline void\nmlxsw_reg_mtpps_vpin_pack(char *payload, u64 time_stamp)\n{\n\tMLXSW_REG_ZERO(mtpps, payload);\n\tmlxsw_reg_mtpps_pin_set(payload, MLXSW_REG_MTPPS_PIN_SP_VIRTUAL_PIN);\n\tmlxsw_reg_mtpps_pin_mode_set(payload,\n\t\t\t\t     MLXSW_REG_MTPPS_PIN_MODE_VIRTUAL_PIN);\n\tmlxsw_reg_mtpps_enable_set(payload, true);\n\tmlxsw_reg_mtpps_time_stamp_set(payload, time_stamp);\n}\n\n \n#define MLXSW_REG_MTUTC_ID 0x9055\n#define MLXSW_REG_MTUTC_LEN 0x1C\n\nMLXSW_REG_DEFINE(mtutc, MLXSW_REG_MTUTC_ID, MLXSW_REG_MTUTC_LEN);\n\nenum mlxsw_reg_mtutc_operation {\n\tMLXSW_REG_MTUTC_OPERATION_SET_TIME_AT_NEXT_SEC = 0,\n\tMLXSW_REG_MTUTC_OPERATION_SET_TIME_IMMEDIATE = 1,\n\tMLXSW_REG_MTUTC_OPERATION_ADJUST_TIME = 2,\n\tMLXSW_REG_MTUTC_OPERATION_ADJUST_FREQ = 3,\n};\n\n \nMLXSW_ITEM32(reg, mtutc, operation, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, mtutc, freq_adjustment, 0x04, 0, 32);\n\n#define MLXSW_REG_MTUTC_MAX_FREQ_ADJ (50 * 1000 * 1000)\n\n \nMLXSW_ITEM32(reg, mtutc, utc_sec, 0x10, 0, 32);\n\n \nMLXSW_ITEM32(reg, mtutc, utc_nsec, 0x14, 0, 30);\n\n \nMLXSW_ITEM32(reg, mtutc, time_adjustment, 0x18, 0, 32);\n\nstatic inline void\nmlxsw_reg_mtutc_pack(char *payload, enum mlxsw_reg_mtutc_operation oper,\n\t\t     u32 freq_adj, u32 utc_sec, u32 utc_nsec, u32 time_adj)\n{\n\tMLXSW_REG_ZERO(mtutc, payload);\n\tmlxsw_reg_mtutc_operation_set(payload, oper);\n\tmlxsw_reg_mtutc_freq_adjustment_set(payload, freq_adj);\n\tmlxsw_reg_mtutc_utc_sec_set(payload, utc_sec);\n\tmlxsw_reg_mtutc_utc_nsec_set(payload, utc_nsec);\n\tmlxsw_reg_mtutc_time_adjustment_set(payload, time_adj);\n}\n\n \n#define MLXSW_REG_MCQI_ID 0x9061\n#define MLXSW_REG_MCQI_BASE_LEN 0x18\n#define MLXSW_REG_MCQI_CAP_LEN 0x14\n#define MLXSW_REG_MCQI_LEN (MLXSW_REG_MCQI_BASE_LEN + MLXSW_REG_MCQI_CAP_LEN)\n\nMLXSW_REG_DEFINE(mcqi, MLXSW_REG_MCQI_ID, MLXSW_REG_MCQI_LEN);\n\n \nMLXSW_ITEM32(reg, mcqi, component_index, 0x00, 0, 16);\n\nenum mlxfw_reg_mcqi_info_type {\n\tMLXSW_REG_MCQI_INFO_TYPE_CAPABILITIES,\n};\n\n \nMLXSW_ITEM32(reg, mcqi, info_type, 0x08, 0, 5);\n\n \nMLXSW_ITEM32(reg, mcqi, offset, 0x10, 0, 32);\n\n \nMLXSW_ITEM32(reg, mcqi, data_size, 0x14, 0, 16);\n\n \nMLXSW_ITEM32(reg, mcqi, cap_max_component_size, 0x20, 0, 32);\n\n \nMLXSW_ITEM32(reg, mcqi, cap_log_mcda_word_size, 0x24, 28, 4);\n\n \nMLXSW_ITEM32(reg, mcqi, cap_mcda_max_write_size, 0x24, 0, 16);\n\nstatic inline void mlxsw_reg_mcqi_pack(char *payload, u16 component_index)\n{\n\tMLXSW_REG_ZERO(mcqi, payload);\n\tmlxsw_reg_mcqi_component_index_set(payload, component_index);\n\tmlxsw_reg_mcqi_info_type_set(payload,\n\t\t\t\t     MLXSW_REG_MCQI_INFO_TYPE_CAPABILITIES);\n\tmlxsw_reg_mcqi_offset_set(payload, 0);\n\tmlxsw_reg_mcqi_data_size_set(payload, MLXSW_REG_MCQI_CAP_LEN);\n}\n\nstatic inline void mlxsw_reg_mcqi_unpack(char *payload,\n\t\t\t\t\t u32 *p_cap_max_component_size,\n\t\t\t\t\t u8 *p_cap_log_mcda_word_size,\n\t\t\t\t\t u16 *p_cap_mcda_max_write_size)\n{\n\t*p_cap_max_component_size =\n\t\tmlxsw_reg_mcqi_cap_max_component_size_get(payload);\n\t*p_cap_log_mcda_word_size =\n\t\tmlxsw_reg_mcqi_cap_log_mcda_word_size_get(payload);\n\t*p_cap_mcda_max_write_size =\n\t\tmlxsw_reg_mcqi_cap_mcda_max_write_size_get(payload);\n}\n\n \n#define MLXSW_REG_MCC_ID 0x9062\n#define MLXSW_REG_MCC_LEN 0x1C\n\nMLXSW_REG_DEFINE(mcc, MLXSW_REG_MCC_ID, MLXSW_REG_MCC_LEN);\n\nenum mlxsw_reg_mcc_instruction {\n\tMLXSW_REG_MCC_INSTRUCTION_LOCK_UPDATE_HANDLE = 0x01,\n\tMLXSW_REG_MCC_INSTRUCTION_RELEASE_UPDATE_HANDLE = 0x02,\n\tMLXSW_REG_MCC_INSTRUCTION_UPDATE_COMPONENT = 0x03,\n\tMLXSW_REG_MCC_INSTRUCTION_VERIFY_COMPONENT = 0x04,\n\tMLXSW_REG_MCC_INSTRUCTION_ACTIVATE = 0x06,\n\tMLXSW_REG_MCC_INSTRUCTION_CANCEL = 0x08,\n};\n\n \nMLXSW_ITEM32(reg, mcc, instruction, 0x00, 0, 8);\n\n \nMLXSW_ITEM32(reg, mcc, component_index, 0x04, 0, 16);\n\n \nMLXSW_ITEM32(reg, mcc, update_handle, 0x08, 0, 24);\n\n \nMLXSW_ITEM32(reg, mcc, error_code, 0x0C, 8, 8);\n\n \nMLXSW_ITEM32(reg, mcc, control_state, 0x0C, 0, 4);\n\n \nMLXSW_ITEM32(reg, mcc, component_size, 0x10, 0, 32);\n\nstatic inline void mlxsw_reg_mcc_pack(char *payload,\n\t\t\t\t      enum mlxsw_reg_mcc_instruction instr,\n\t\t\t\t      u16 component_index, u32 update_handle,\n\t\t\t\t      u32 component_size)\n{\n\tMLXSW_REG_ZERO(mcc, payload);\n\tmlxsw_reg_mcc_instruction_set(payload, instr);\n\tmlxsw_reg_mcc_component_index_set(payload, component_index);\n\tmlxsw_reg_mcc_update_handle_set(payload, update_handle);\n\tmlxsw_reg_mcc_component_size_set(payload, component_size);\n}\n\nstatic inline void mlxsw_reg_mcc_unpack(char *payload, u32 *p_update_handle,\n\t\t\t\t\tu8 *p_error_code, u8 *p_control_state)\n{\n\tif (p_update_handle)\n\t\t*p_update_handle = mlxsw_reg_mcc_update_handle_get(payload);\n\tif (p_error_code)\n\t\t*p_error_code = mlxsw_reg_mcc_error_code_get(payload);\n\tif (p_control_state)\n\t\t*p_control_state = mlxsw_reg_mcc_control_state_get(payload);\n}\n\n \n#define MLXSW_REG_MCDA_ID 0x9063\n#define MLXSW_REG_MCDA_BASE_LEN 0x10\n#define MLXSW_REG_MCDA_MAX_DATA_LEN 0x80\n#define MLXSW_REG_MCDA_LEN \\\n\t\t(MLXSW_REG_MCDA_BASE_LEN + MLXSW_REG_MCDA_MAX_DATA_LEN)\n\nMLXSW_REG_DEFINE(mcda, MLXSW_REG_MCDA_ID, MLXSW_REG_MCDA_LEN);\n\n \nMLXSW_ITEM32(reg, mcda, update_handle, 0x00, 0, 24);\n\n \nMLXSW_ITEM32(reg, mcda, offset, 0x04, 0, 32);\n\n \nMLXSW_ITEM32(reg, mcda, size, 0x08, 0, 16);\n\n \nMLXSW_ITEM32_INDEXED(reg, mcda, data, 0x10, 0, 32, 4, 0, false);\n\nstatic inline void mlxsw_reg_mcda_pack(char *payload, u32 update_handle,\n\t\t\t\t       u32 offset, u16 size, u8 *data)\n{\n\tint i;\n\n\tMLXSW_REG_ZERO(mcda, payload);\n\tmlxsw_reg_mcda_update_handle_set(payload, update_handle);\n\tmlxsw_reg_mcda_offset_set(payload, offset);\n\tmlxsw_reg_mcda_size_set(payload, size);\n\n\tfor (i = 0; i < size / 4; i++)\n\t\tmlxsw_reg_mcda_data_set(payload, i, *(u32 *) &data[i * 4]);\n}\n\n \n#define MLXSW_REG_MCAM_ID 0x907F\n#define MLXSW_REG_MCAM_LEN 0x48\n\nMLXSW_REG_DEFINE(mcam, MLXSW_REG_MCAM_ID, MLXSW_REG_MCAM_LEN);\n\nenum mlxsw_reg_mcam_feature_group {\n\t \n\tMLXSW_REG_MCAM_FEATURE_GROUP_ENHANCED_FEATURES,\n};\n\n \nMLXSW_ITEM32(reg, mcam, feature_group, 0x00, 16, 8);\n\nenum mlxsw_reg_mcam_mng_feature_cap_mask_bits {\n\t \n\tMLXSW_REG_MCAM_MCIA_128B = 34,\n};\n\n#define MLXSW_REG_BYTES_PER_DWORD 0x4\n\n \n#define MLXSW_REG_MCAM_MNG_FEATURE_CAP_MASK_DWORD(_dw_num, _offset)\t \\\n\tMLXSW_ITEM_BIT_ARRAY(reg, mcam, mng_feature_cap_mask_dw##_dw_num, \\\n\t\t\t     _offset, MLXSW_REG_BYTES_PER_DWORD, 1)\n\n \nMLXSW_REG_MCAM_MNG_FEATURE_CAP_MASK_DWORD(0, 0x28);\nMLXSW_REG_MCAM_MNG_FEATURE_CAP_MASK_DWORD(1, 0x2C);\nMLXSW_REG_MCAM_MNG_FEATURE_CAP_MASK_DWORD(2, 0x30);\nMLXSW_REG_MCAM_MNG_FEATURE_CAP_MASK_DWORD(3, 0x34);\n\nstatic inline void\nmlxsw_reg_mcam_pack(char *payload, enum mlxsw_reg_mcam_feature_group feat_group)\n{\n\tMLXSW_REG_ZERO(mcam, payload);\n\tmlxsw_reg_mcam_feature_group_set(payload, feat_group);\n}\n\nstatic inline void\nmlxsw_reg_mcam_unpack(char *payload,\n\t\t      enum mlxsw_reg_mcam_mng_feature_cap_mask_bits bit,\n\t\t      bool *p_mng_feature_cap_val)\n{\n\tint offset = bit % (MLXSW_REG_BYTES_PER_DWORD * BITS_PER_BYTE);\n\tint dword = bit / (MLXSW_REG_BYTES_PER_DWORD * BITS_PER_BYTE);\n\tu8 (*getters[])(const char *, u16) = {\n\t\tmlxsw_reg_mcam_mng_feature_cap_mask_dw0_get,\n\t\tmlxsw_reg_mcam_mng_feature_cap_mask_dw1_get,\n\t\tmlxsw_reg_mcam_mng_feature_cap_mask_dw2_get,\n\t\tmlxsw_reg_mcam_mng_feature_cap_mask_dw3_get,\n\t};\n\n\tif (!WARN_ON_ONCE(dword >= ARRAY_SIZE(getters)))\n\t\t*p_mng_feature_cap_val = getters[dword](payload, offset);\n}\n\n \n#define MLXSW_REG_MPSC_ID 0x9080\n#define MLXSW_REG_MPSC_LEN 0x1C\n\nMLXSW_REG_DEFINE(mpsc, MLXSW_REG_MPSC_ID, MLXSW_REG_MPSC_LEN);\n\n \nMLXSW_ITEM32_LP(reg, mpsc, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, mpsc, e, 0x04, 30, 1);\n\n#define MLXSW_REG_MPSC_RATE_MAX 3500000000UL\n\n \nMLXSW_ITEM32(reg, mpsc, rate, 0x08, 0, 32);\n\nstatic inline void mlxsw_reg_mpsc_pack(char *payload, u16 local_port, bool e,\n\t\t\t\t       u32 rate)\n{\n\tMLXSW_REG_ZERO(mpsc, payload);\n\tmlxsw_reg_mpsc_local_port_set(payload, local_port);\n\tmlxsw_reg_mpsc_e_set(payload, e);\n\tmlxsw_reg_mpsc_rate_set(payload, rate);\n}\n\n \n#define MLXSW_REG_MGPC_ID 0x9081\n#define MLXSW_REG_MGPC_LEN 0x18\n\nMLXSW_REG_DEFINE(mgpc, MLXSW_REG_MGPC_ID, MLXSW_REG_MGPC_LEN);\n\n \nMLXSW_ITEM32(reg, mgpc, counter_set_type, 0x00, 24, 8);\n\n \nMLXSW_ITEM32(reg, mgpc, counter_index, 0x00, 0, 24);\n\nenum mlxsw_reg_mgpc_opcode {\n\t \n\tMLXSW_REG_MGPC_OPCODE_NOP = 0x00,\n\t \n\tMLXSW_REG_MGPC_OPCODE_CLEAR = 0x08,\n};\n\n \nMLXSW_ITEM32(reg, mgpc, opcode, 0x04, 28, 4);\n\n \nMLXSW_ITEM64(reg, mgpc, byte_counter, 0x08, 0, 64);\n\n \nMLXSW_ITEM64(reg, mgpc, packet_counter, 0x10, 0, 64);\n\nstatic inline void mlxsw_reg_mgpc_pack(char *payload, u32 counter_index,\n\t\t\t\t       enum mlxsw_reg_mgpc_opcode opcode,\n\t\t\t\t       enum mlxsw_reg_flow_counter_set_type set_type)\n{\n\tMLXSW_REG_ZERO(mgpc, payload);\n\tmlxsw_reg_mgpc_counter_index_set(payload, counter_index);\n\tmlxsw_reg_mgpc_counter_set_type_set(payload, set_type);\n\tmlxsw_reg_mgpc_opcode_set(payload, opcode);\n}\n\n \n#define MLXSW_REG_MPRS_ID 0x9083\n#define MLXSW_REG_MPRS_LEN 0x14\n\nMLXSW_REG_DEFINE(mprs, MLXSW_REG_MPRS_ID, MLXSW_REG_MPRS_LEN);\n\n \nMLXSW_ITEM32(reg, mprs, parsing_depth, 0x00, 0, 16);\n\n \nMLXSW_ITEM32(reg, mprs, parsing_en, 0x04, 0, 16);\n\n \nMLXSW_ITEM32(reg, mprs, vxlan_udp_dport, 0x10, 0, 16);\n\nstatic inline void mlxsw_reg_mprs_pack(char *payload, u16 parsing_depth,\n\t\t\t\t       u16 vxlan_udp_dport)\n{\n\tMLXSW_REG_ZERO(mprs, payload);\n\tmlxsw_reg_mprs_parsing_depth_set(payload, parsing_depth);\n\tmlxsw_reg_mprs_parsing_en_set(payload, true);\n\tmlxsw_reg_mprs_vxlan_udp_dport_set(payload, vxlan_udp_dport);\n}\n\n \n#define MLXSW_REG_MOGCR_ID 0x9086\n#define MLXSW_REG_MOGCR_LEN 0x20\n\nMLXSW_REG_DEFINE(mogcr, MLXSW_REG_MOGCR_ID, MLXSW_REG_MOGCR_LEN);\n\n \nMLXSW_ITEM32(reg, mogcr, ptp_iftc, 0x00, 1, 1);\n\n \nMLXSW_ITEM32(reg, mogcr, ptp_eftc, 0x00, 0, 1);\n\n \nMLXSW_ITEM32(reg, mogcr, mirroring_pid_base, 0x0C, 0, 14);\n\n \n#define MLXSW_REG_MPAGR_ID 0x9089\n#define MLXSW_REG_MPAGR_LEN 0x0C\n\nMLXSW_REG_DEFINE(mpagr, MLXSW_REG_MPAGR_ID, MLXSW_REG_MPAGR_LEN);\n\nenum mlxsw_reg_mpagr_trigger {\n\tMLXSW_REG_MPAGR_TRIGGER_EGRESS,\n\tMLXSW_REG_MPAGR_TRIGGER_INGRESS,\n\tMLXSW_REG_MPAGR_TRIGGER_INGRESS_WRED,\n\tMLXSW_REG_MPAGR_TRIGGER_INGRESS_SHARED_BUFFER,\n\tMLXSW_REG_MPAGR_TRIGGER_INGRESS_ING_CONG,\n\tMLXSW_REG_MPAGR_TRIGGER_INGRESS_EGR_CONG,\n\tMLXSW_REG_MPAGR_TRIGGER_EGRESS_ECN,\n\tMLXSW_REG_MPAGR_TRIGGER_EGRESS_HIGH_LATENCY,\n};\n\n \nMLXSW_ITEM32(reg, mpagr, trigger, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, mpagr, pa_id, 0x04, 0, 4);\n\n#define MLXSW_REG_MPAGR_RATE_MAX 3500000000UL\n\n \nMLXSW_ITEM32(reg, mpagr, probability_rate, 0x08, 0, 32);\n\nstatic inline void mlxsw_reg_mpagr_pack(char *payload,\n\t\t\t\t\tenum mlxsw_reg_mpagr_trigger trigger,\n\t\t\t\t\tu8 pa_id, u32 probability_rate)\n{\n\tMLXSW_REG_ZERO(mpagr, payload);\n\tmlxsw_reg_mpagr_trigger_set(payload, trigger);\n\tmlxsw_reg_mpagr_pa_id_set(payload, pa_id);\n\tmlxsw_reg_mpagr_probability_rate_set(payload, probability_rate);\n}\n\n \n#define MLXSW_REG_MOMTE_ID 0x908D\n#define MLXSW_REG_MOMTE_LEN 0x10\n\nMLXSW_REG_DEFINE(momte, MLXSW_REG_MOMTE_ID, MLXSW_REG_MOMTE_LEN);\n\n \nMLXSW_ITEM32_LP(reg, momte, 0x00, 16, 0x00, 12);\n\nenum mlxsw_reg_momte_type {\n\tMLXSW_REG_MOMTE_TYPE_WRED = 0x20,\n\tMLXSW_REG_MOMTE_TYPE_SHARED_BUFFER_TCLASS = 0x31,\n\tMLXSW_REG_MOMTE_TYPE_SHARED_BUFFER_TCLASS_DESCRIPTORS = 0x32,\n\tMLXSW_REG_MOMTE_TYPE_SHARED_BUFFER_EGRESS_PORT = 0x33,\n\tMLXSW_REG_MOMTE_TYPE_ING_CONG = 0x40,\n\tMLXSW_REG_MOMTE_TYPE_EGR_CONG = 0x50,\n\tMLXSW_REG_MOMTE_TYPE_ECN = 0x60,\n\tMLXSW_REG_MOMTE_TYPE_HIGH_LATENCY = 0x70,\n};\n\n \nMLXSW_ITEM32(reg, momte, type, 0x04, 0, 8);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, momte, tclass_en, 0x08, 0x08, 1);\n\nstatic inline void mlxsw_reg_momte_pack(char *payload, u16 local_port,\n\t\t\t\t\tenum mlxsw_reg_momte_type type)\n{\n\tMLXSW_REG_ZERO(momte, payload);\n\tmlxsw_reg_momte_local_port_set(payload, local_port);\n\tmlxsw_reg_momte_type_set(payload, type);\n}\n\n \n#define MLXSW_REG_MTPPPC_ID 0x9090\n#define MLXSW_REG_MTPPPC_LEN 0x28\n\nMLXSW_REG_DEFINE(mtpppc, MLXSW_REG_MTPPPC_ID, MLXSW_REG_MTPPPC_LEN);\n\n \nMLXSW_ITEM32(reg, mtpppc, ing_timestamp_message_type, 0x08, 0, 16);\n\n \nMLXSW_ITEM32(reg, mtpppc, egr_timestamp_message_type, 0x0C, 0, 16);\n\nstatic inline void mlxsw_reg_mtpppc_pack(char *payload, u16 ing, u16 egr)\n{\n\tMLXSW_REG_ZERO(mtpppc, payload);\n\tmlxsw_reg_mtpppc_ing_timestamp_message_type_set(payload, ing);\n\tmlxsw_reg_mtpppc_egr_timestamp_message_type_set(payload, egr);\n}\n\n \n\n#define MLXSW_REG_MTPPTR_ID 0x9091\n#define MLXSW_REG_MTPPTR_BASE_LEN 0x10  \n#define MLXSW_REG_MTPPTR_REC_LEN 0x10  \n#define MLXSW_REG_MTPPTR_REC_MAX_COUNT 4\n#define MLXSW_REG_MTPPTR_LEN (MLXSW_REG_MTPPTR_BASE_LEN +\t\t\\\n\t\t    MLXSW_REG_MTPPTR_REC_LEN * MLXSW_REG_MTPPTR_REC_MAX_COUNT)\n\nMLXSW_REG_DEFINE(mtpptr, MLXSW_REG_MTPPTR_ID, MLXSW_REG_MTPPTR_LEN);\n\n \nMLXSW_ITEM32_LP(reg, mtpptr, 0x00, 16, 0x00, 12);\n\nenum mlxsw_reg_mtpptr_dir {\n\tMLXSW_REG_MTPPTR_DIR_INGRESS,\n\tMLXSW_REG_MTPPTR_DIR_EGRESS,\n};\n\n \nMLXSW_ITEM32(reg, mtpptr, dir, 0x00, 0, 1);\n\n \nMLXSW_ITEM32(reg, mtpptr, clr, 0x04, 31, 1);\n\n \nMLXSW_ITEM32(reg, mtpptr, num_rec, 0x08, 0, 4);\n\n \nMLXSW_ITEM32_INDEXED(reg, mtpptr, rec_message_type,\n\t\t     MLXSW_REG_MTPPTR_BASE_LEN, 8, 4,\n\t\t     MLXSW_REG_MTPPTR_REC_LEN, 0, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, mtpptr, rec_domain_number,\n\t\t     MLXSW_REG_MTPPTR_BASE_LEN, 0, 8,\n\t\t     MLXSW_REG_MTPPTR_REC_LEN, 0, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, mtpptr, rec_sequence_id,\n\t\t     MLXSW_REG_MTPPTR_BASE_LEN, 0, 16,\n\t\t     MLXSW_REG_MTPPTR_REC_LEN, 0x4, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, mtpptr, rec_timestamp_high,\n\t\t     MLXSW_REG_MTPPTR_BASE_LEN, 0, 32,\n\t\t     MLXSW_REG_MTPPTR_REC_LEN, 0x8, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, mtpptr, rec_timestamp_low,\n\t\t     MLXSW_REG_MTPPTR_BASE_LEN, 0, 32,\n\t\t     MLXSW_REG_MTPPTR_REC_LEN, 0xC, false);\n\nstatic inline void mlxsw_reg_mtpptr_unpack(const char *payload,\n\t\t\t\t\t   unsigned int rec,\n\t\t\t\t\t   u8 *p_message_type,\n\t\t\t\t\t   u8 *p_domain_number,\n\t\t\t\t\t   u16 *p_sequence_id,\n\t\t\t\t\t   u64 *p_timestamp)\n{\n\tu32 timestamp_high, timestamp_low;\n\n\t*p_message_type = mlxsw_reg_mtpptr_rec_message_type_get(payload, rec);\n\t*p_domain_number = mlxsw_reg_mtpptr_rec_domain_number_get(payload, rec);\n\t*p_sequence_id = mlxsw_reg_mtpptr_rec_sequence_id_get(payload, rec);\n\ttimestamp_high = mlxsw_reg_mtpptr_rec_timestamp_high_get(payload, rec);\n\ttimestamp_low = mlxsw_reg_mtpptr_rec_timestamp_low_get(payload, rec);\n\t*p_timestamp = (u64)timestamp_high << 32 | timestamp_low;\n}\n\n \n#define MLXSW_REG_MTPTPT_ID 0x9092\n#define MLXSW_REG_MTPTPT_LEN 0x08\n\nMLXSW_REG_DEFINE(mtptpt, MLXSW_REG_MTPTPT_ID, MLXSW_REG_MTPTPT_LEN);\n\nenum mlxsw_reg_mtptpt_trap_id {\n\tMLXSW_REG_MTPTPT_TRAP_ID_PTP0,\n\tMLXSW_REG_MTPTPT_TRAP_ID_PTP1,\n};\n\n \nMLXSW_ITEM32(reg, mtptpt, trap_id, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, mtptpt, message_type, 0x04, 0, 16);\n\nstatic inline void mlxsw_reg_mtptpt_pack(char *payload,\n\t\t\t\t\t enum mlxsw_reg_mtptpt_trap_id trap_id,\n\t\t\t\t\t u16 message_type)\n{\n\tMLXSW_REG_ZERO(mtptpt, payload);\n\tmlxsw_reg_mtptpt_trap_id_set(payload, trap_id);\n\tmlxsw_reg_mtptpt_message_type_set(payload, message_type);\n}\n\n \n#define MLXSW_REG_MTPCPC_ID 0x9093\n#define MLXSW_REG_MTPCPC_LEN 0x2C\n\nMLXSW_REG_DEFINE(mtpcpc, MLXSW_REG_MTPCPC_ID, MLXSW_REG_MTPCPC_LEN);\n\n \nMLXSW_ITEM32(reg, mtpcpc, pport, 0x00, 31, 1);\n\n \nMLXSW_ITEM32_LP(reg, mtpcpc, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, mtpcpc, ptp_trap_en, 0x04, 0, 1);\n\n \nMLXSW_ITEM32(reg, mtpcpc, ing_correction_message_type, 0x10, 0, 16);\n\n \nMLXSW_ITEM32(reg, mtpcpc, egr_correction_message_type, 0x14, 0, 16);\n\nstatic inline void mlxsw_reg_mtpcpc_pack(char *payload, bool pport,\n\t\t\t\t\t u16 local_port, bool ptp_trap_en,\n\t\t\t\t\t u16 ing, u16 egr)\n{\n\tMLXSW_REG_ZERO(mtpcpc, payload);\n\tmlxsw_reg_mtpcpc_pport_set(payload, pport);\n\tmlxsw_reg_mtpcpc_local_port_set(payload, pport ? local_port : 0);\n\tmlxsw_reg_mtpcpc_ptp_trap_en_set(payload, ptp_trap_en);\n\tmlxsw_reg_mtpcpc_ing_correction_message_type_set(payload, ing);\n\tmlxsw_reg_mtpcpc_egr_correction_message_type_set(payload, egr);\n}\n\n \n#define MLXSW_REG_MFGD_ID 0x90F0\n#define MLXSW_REG_MFGD_LEN 0x0C\n\nMLXSW_REG_DEFINE(mfgd, MLXSW_REG_MFGD_ID, MLXSW_REG_MFGD_LEN);\n\n \nMLXSW_ITEM32(reg, mfgd, fatal_event_mode, 0x00, 9, 2);\n\n \nMLXSW_ITEM32(reg, mfgd, trigger_test, 0x00, 11, 1);\n\n \n#define MLXSW_REG_MGPIR_ID 0x9100\n#define MLXSW_REG_MGPIR_LEN 0xA0\n\nMLXSW_REG_DEFINE(mgpir, MLXSW_REG_MGPIR_ID, MLXSW_REG_MGPIR_LEN);\n\nenum mlxsw_reg_mgpir_device_type {\n\tMLXSW_REG_MGPIR_DEVICE_TYPE_NONE,\n\tMLXSW_REG_MGPIR_DEVICE_TYPE_GEARBOX_DIE,\n};\n\n \nMLXSW_ITEM32(reg, mgpir, slot_index, 0x00, 28, 4);\n\n \nMLXSW_ITEM32(reg, mgpir, device_type, 0x00, 24, 4);\n\n \nMLXSW_ITEM32(reg, mgpir, devices_per_flash, 0x00, 16, 8);\n\n \nMLXSW_ITEM32(reg, mgpir, num_of_devices, 0x00, 0, 8);\n\n \nMLXSW_ITEM32(reg, mgpir, max_modules_per_slot, 0x04, 16, 8);\n\n \nMLXSW_ITEM32(reg, mgpir, num_of_slots, 0x04, 8, 8);\n\n \nMLXSW_ITEM32(reg, mgpir, num_of_modules, 0x04, 0, 8);\n\nstatic inline void mlxsw_reg_mgpir_pack(char *payload, u8 slot_index)\n{\n\tMLXSW_REG_ZERO(mgpir, payload);\n\tmlxsw_reg_mgpir_slot_index_set(payload, slot_index);\n}\n\nstatic inline void\nmlxsw_reg_mgpir_unpack(char *payload, u8 *num_of_devices,\n\t\t       enum mlxsw_reg_mgpir_device_type *device_type,\n\t\t       u8 *devices_per_flash, u8 *num_of_modules,\n\t\t       u8 *num_of_slots)\n{\n\tif (num_of_devices)\n\t\t*num_of_devices = mlxsw_reg_mgpir_num_of_devices_get(payload);\n\tif (device_type)\n\t\t*device_type = mlxsw_reg_mgpir_device_type_get(payload);\n\tif (devices_per_flash)\n\t\t*devices_per_flash =\n\t\t\t\tmlxsw_reg_mgpir_devices_per_flash_get(payload);\n\tif (num_of_modules)\n\t\t*num_of_modules = mlxsw_reg_mgpir_num_of_modules_get(payload);\n\tif (num_of_slots)\n\t\t*num_of_slots = mlxsw_reg_mgpir_num_of_slots_get(payload);\n}\n\n \n#define MLXSW_REG_MBCT_ID 0x9120\n#define MLXSW_REG_MBCT_LEN 0x420\n\nMLXSW_REG_DEFINE(mbct, MLXSW_REG_MBCT_ID, MLXSW_REG_MBCT_LEN);\n\n \nMLXSW_ITEM32(reg, mbct, slot_index, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, mbct, data_size, 0x04, 0, 11);\n\nenum mlxsw_reg_mbct_op {\n\tMLXSW_REG_MBCT_OP_ERASE_INI_IMAGE = 1,\n\tMLXSW_REG_MBCT_OP_DATA_TRANSFER,  \n\tMLXSW_REG_MBCT_OP_ACTIVATE,\n\tMLXSW_REG_MBCT_OP_CLEAR_ERRORS = 6,\n\tMLXSW_REG_MBCT_OP_QUERY_STATUS,\n};\n\n \nMLXSW_ITEM32(reg, mbct, op, 0x08, 28, 4);\n\n \nMLXSW_ITEM32(reg, mbct, last, 0x08, 26, 1);\n\n \nMLXSW_ITEM32(reg, mbct, oee, 0x08, 25, 1);\n\nenum mlxsw_reg_mbct_status {\n\t \n\tMLXSW_REG_MBCT_STATUS_PART_DATA = 2,\n\tMLXSW_REG_MBCT_STATUS_LAST_DATA,\n\tMLXSW_REG_MBCT_STATUS_ERASE_COMPLETE,\n\t \n\tMLXSW_REG_MBCT_STATUS_ERROR_INI_IN_USE,\n\t \n\tMLXSW_REG_MBCT_STATUS_ERASE_FAILED = 7,\n\tMLXSW_REG_MBCT_STATUS_INI_ERROR,\n\tMLXSW_REG_MBCT_STATUS_ACTIVATION_FAILED,\n\tMLXSW_REG_MBCT_STATUS_ILLEGAL_OPERATION = 11,\n};\n\n \nMLXSW_ITEM32(reg, mbct, status, 0x0C, 24, 5);\n\nenum mlxsw_reg_mbct_fsm_state {\n\tMLXSW_REG_MBCT_FSM_STATE_INI_IN_USE = 5,\n\tMLXSW_REG_MBCT_FSM_STATE_ERROR,\n};\n\n \nMLXSW_ITEM32(reg, mbct, fsm_state,  0x0C, 16, 4);\n\n#define MLXSW_REG_MBCT_DATA_LEN 1024\n\n \nMLXSW_ITEM_BUF(reg, mbct, data, 0x20, MLXSW_REG_MBCT_DATA_LEN);\n\nstatic inline void mlxsw_reg_mbct_pack(char *payload, u8 slot_index,\n\t\t\t\t       enum mlxsw_reg_mbct_op op, bool oee)\n{\n\tMLXSW_REG_ZERO(mbct, payload);\n\tmlxsw_reg_mbct_slot_index_set(payload, slot_index);\n\tmlxsw_reg_mbct_op_set(payload, op);\n\tmlxsw_reg_mbct_oee_set(payload, oee);\n}\n\nstatic inline void mlxsw_reg_mbct_dt_pack(char *payload,\n\t\t\t\t\t  u16 data_size, bool last,\n\t\t\t\t\t  const char *data)\n{\n\tif (WARN_ON(data_size > MLXSW_REG_MBCT_DATA_LEN))\n\t\treturn;\n\tmlxsw_reg_mbct_data_size_set(payload, data_size);\n\tmlxsw_reg_mbct_last_set(payload, last);\n\tmlxsw_reg_mbct_data_memcpy_to(payload, data);\n}\n\nstatic inline void\nmlxsw_reg_mbct_unpack(const char *payload, u8 *p_slot_index,\n\t\t      enum mlxsw_reg_mbct_status *p_status,\n\t\t      enum mlxsw_reg_mbct_fsm_state *p_fsm_state)\n{\n\tif (p_slot_index)\n\t\t*p_slot_index = mlxsw_reg_mbct_slot_index_get(payload);\n\t*p_status = mlxsw_reg_mbct_status_get(payload);\n\tif (p_fsm_state)\n\t\t*p_fsm_state = mlxsw_reg_mbct_fsm_state_get(payload);\n}\n\n \n#define MLXSW_REG_MDDT_ID 0x9160\n#define MLXSW_REG_MDDT_LEN 0x110\n\nMLXSW_REG_DEFINE(mddt, MLXSW_REG_MDDT_ID, MLXSW_REG_MDDT_LEN);\n\n \nMLXSW_ITEM32(reg, mddt, slot_index, 0x00, 8, 4);\n\n \nMLXSW_ITEM32(reg, mddt, device_index, 0x00, 0, 8);\n\n \nMLXSW_ITEM32(reg, mddt, read_size, 0x04, 24, 8);\n\n \nMLXSW_ITEM32(reg, mddt, write_size, 0x04, 16, 8);\n\nenum mlxsw_reg_mddt_status {\n\tMLXSW_REG_MDDT_STATUS_OK,\n};\n\n \nMLXSW_ITEM32(reg, mddt, status, 0x0C, 24, 8);\n\nenum mlxsw_reg_mddt_method {\n\tMLXSW_REG_MDDT_METHOD_QUERY,\n\tMLXSW_REG_MDDT_METHOD_WRITE,\n};\n\n \nMLXSW_ITEM32(reg, mddt, method, 0x0C, 22, 2);\n\n \nMLXSW_ITEM32(reg, mddt, register_id, 0x0C, 0, 16);\n\n#define MLXSW_REG_MDDT_PAYLOAD_OFFSET 0x0C\n#define MLXSW_REG_MDDT_PRM_REGISTER_HEADER_LEN 4\n\nstatic inline char *mlxsw_reg_mddt_inner_payload(char *payload)\n{\n\treturn payload + MLXSW_REG_MDDT_PAYLOAD_OFFSET +\n\t       MLXSW_REG_MDDT_PRM_REGISTER_HEADER_LEN;\n}\n\nstatic inline void mlxsw_reg_mddt_pack(char *payload, u8 slot_index,\n\t\t\t\t       u8 device_index,\n\t\t\t\t       enum mlxsw_reg_mddt_method method,\n\t\t\t\t       const struct mlxsw_reg_info *reg,\n\t\t\t\t       char **inner_payload)\n{\n\tint len = reg->len + MLXSW_REG_MDDT_PRM_REGISTER_HEADER_LEN;\n\n\tif (WARN_ON(len + MLXSW_REG_MDDT_PAYLOAD_OFFSET > MLXSW_REG_MDDT_LEN))\n\t\tlen = MLXSW_REG_MDDT_LEN - MLXSW_REG_MDDT_PAYLOAD_OFFSET;\n\n\tMLXSW_REG_ZERO(mddt, payload);\n\tmlxsw_reg_mddt_slot_index_set(payload, slot_index);\n\tmlxsw_reg_mddt_device_index_set(payload, device_index);\n\tmlxsw_reg_mddt_method_set(payload, method);\n\tmlxsw_reg_mddt_register_id_set(payload, reg->id);\n\tmlxsw_reg_mddt_read_size_set(payload, len / 4);\n\tmlxsw_reg_mddt_write_size_set(payload, len / 4);\n\t*inner_payload = mlxsw_reg_mddt_inner_payload(payload);\n}\n\n \n#define MLXSW_REG_MDDQ_ID 0x9161\n#define MLXSW_REG_MDDQ_LEN 0x30\n\nMLXSW_REG_DEFINE(mddq, MLXSW_REG_MDDQ_ID, MLXSW_REG_MDDQ_LEN);\n\n \nMLXSW_ITEM32(reg, mddq, sie, 0x00, 31, 1);\n\nenum mlxsw_reg_mddq_query_type {\n\tMLXSW_REG_MDDQ_QUERY_TYPE_SLOT_INFO = 1,\n\tMLXSW_REG_MDDQ_QUERY_TYPE_DEVICE_INFO,  \n\tMLXSW_REG_MDDQ_QUERY_TYPE_SLOT_NAME,\n};\n\n \nMLXSW_ITEM32(reg, mddq, query_type, 0x00, 16, 8);\n\n \nMLXSW_ITEM32(reg, mddq, slot_index, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, mddq, response_msg_seq, 0x04, 16, 8);\n\n \nMLXSW_ITEM32(reg, mddq, request_msg_seq, 0x04, 0, 8);\n\n \nMLXSW_ITEM32(reg, mddq, data_valid, 0x08, 31, 1);\n\n \nMLXSW_ITEM32(reg, mddq, slot_info_provisioned, 0x10, 31, 1);\n\n \nMLXSW_ITEM32(reg, mddq, slot_info_sr_valid, 0x10, 30, 1);\n\nenum mlxsw_reg_mddq_slot_info_ready {\n\tMLXSW_REG_MDDQ_SLOT_INFO_READY_NOT_READY,\n\tMLXSW_REG_MDDQ_SLOT_INFO_READY_READY,\n\tMLXSW_REG_MDDQ_SLOT_INFO_READY_ERROR,\n};\n\n \nMLXSW_ITEM32(reg, mddq, slot_info_lc_ready, 0x10, 28, 2);\n\n \nMLXSW_ITEM32(reg, mddq, slot_info_active, 0x10, 27, 1);\n\n \nMLXSW_ITEM32(reg, mddq, slot_info_hw_revision, 0x14, 16, 16);\n\n \nMLXSW_ITEM32(reg, mddq, slot_info_ini_file_version, 0x14, 0, 16);\n\n \nMLXSW_ITEM32(reg, mddq, slot_info_card_type, 0x18, 0, 8);\n\nstatic inline void\n__mlxsw_reg_mddq_pack(char *payload, u8 slot_index,\n\t\t      enum mlxsw_reg_mddq_query_type query_type)\n{\n\tMLXSW_REG_ZERO(mddq, payload);\n\tmlxsw_reg_mddq_slot_index_set(payload, slot_index);\n\tmlxsw_reg_mddq_query_type_set(payload, query_type);\n}\n\nstatic inline void\nmlxsw_reg_mddq_slot_info_pack(char *payload, u8 slot_index, bool sie)\n{\n\t__mlxsw_reg_mddq_pack(payload, slot_index,\n\t\t\t      MLXSW_REG_MDDQ_QUERY_TYPE_SLOT_INFO);\n\tmlxsw_reg_mddq_sie_set(payload, sie);\n}\n\nstatic inline void\nmlxsw_reg_mddq_slot_info_unpack(const char *payload, u8 *p_slot_index,\n\t\t\t\tbool *p_provisioned, bool *p_sr_valid,\n\t\t\t\tenum mlxsw_reg_mddq_slot_info_ready *p_lc_ready,\n\t\t\t\tbool *p_active, u16 *p_hw_revision,\n\t\t\t\tu16 *p_ini_file_version,\n\t\t\t\tu8 *p_card_type)\n{\n\t*p_slot_index = mlxsw_reg_mddq_slot_index_get(payload);\n\t*p_provisioned = mlxsw_reg_mddq_slot_info_provisioned_get(payload);\n\t*p_sr_valid = mlxsw_reg_mddq_slot_info_sr_valid_get(payload);\n\t*p_lc_ready = mlxsw_reg_mddq_slot_info_lc_ready_get(payload);\n\t*p_active = mlxsw_reg_mddq_slot_info_active_get(payload);\n\t*p_hw_revision = mlxsw_reg_mddq_slot_info_hw_revision_get(payload);\n\t*p_ini_file_version = mlxsw_reg_mddq_slot_info_ini_file_version_get(payload);\n\t*p_card_type = mlxsw_reg_mddq_slot_info_card_type_get(payload);\n}\n\n \nMLXSW_ITEM32(reg, mddq, device_info_flash_owner, 0x10, 30, 1);\n\n \nMLXSW_ITEM32(reg, mddq, device_info_device_index, 0x10, 0, 8);\n\n \nMLXSW_ITEM32(reg, mddq, device_info_fw_major, 0x14, 16, 16);\n\n \nMLXSW_ITEM32(reg, mddq, device_info_fw_minor, 0x18, 16, 16);\n\n \nMLXSW_ITEM32(reg, mddq, device_info_fw_sub_minor, 0x18, 0, 16);\n\nstatic inline void\nmlxsw_reg_mddq_device_info_pack(char *payload, u8 slot_index,\n\t\t\t\tu8 request_msg_seq)\n{\n\t__mlxsw_reg_mddq_pack(payload, slot_index,\n\t\t\t      MLXSW_REG_MDDQ_QUERY_TYPE_DEVICE_INFO);\n\tmlxsw_reg_mddq_request_msg_seq_set(payload, request_msg_seq);\n}\n\nstatic inline void\nmlxsw_reg_mddq_device_info_unpack(const char *payload, u8 *p_response_msg_seq,\n\t\t\t\t  bool *p_data_valid, bool *p_flash_owner,\n\t\t\t\t  u8 *p_device_index, u16 *p_fw_major,\n\t\t\t\t  u16 *p_fw_minor, u16 *p_fw_sub_minor)\n{\n\t*p_response_msg_seq = mlxsw_reg_mddq_response_msg_seq_get(payload);\n\t*p_data_valid = mlxsw_reg_mddq_data_valid_get(payload);\n\t*p_flash_owner = mlxsw_reg_mddq_device_info_flash_owner_get(payload);\n\t*p_device_index = mlxsw_reg_mddq_device_info_device_index_get(payload);\n\t*p_fw_major = mlxsw_reg_mddq_device_info_fw_major_get(payload);\n\t*p_fw_minor = mlxsw_reg_mddq_device_info_fw_minor_get(payload);\n\t*p_fw_sub_minor = mlxsw_reg_mddq_device_info_fw_sub_minor_get(payload);\n}\n\n#define MLXSW_REG_MDDQ_SLOT_ASCII_NAME_LEN 20\n\n \nMLXSW_ITEM_BUF(reg, mddq, slot_ascii_name, 0x10,\n\t       MLXSW_REG_MDDQ_SLOT_ASCII_NAME_LEN);\n\nstatic inline void\nmlxsw_reg_mddq_slot_name_pack(char *payload, u8 slot_index)\n{\n\t__mlxsw_reg_mddq_pack(payload, slot_index,\n\t\t\t      MLXSW_REG_MDDQ_QUERY_TYPE_SLOT_NAME);\n}\n\nstatic inline void\nmlxsw_reg_mddq_slot_name_unpack(const char *payload, char *slot_ascii_name)\n{\n\tmlxsw_reg_mddq_slot_ascii_name_memcpy_from(payload, slot_ascii_name);\n}\n\n \n#define MLXSW_REG_MDDC_ID 0x9163\n#define MLXSW_REG_MDDC_LEN 0x30\n\nMLXSW_REG_DEFINE(mddc, MLXSW_REG_MDDC_ID, MLXSW_REG_MDDC_LEN);\n\n \nMLXSW_ITEM32(reg, mddc, slot_index, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, mddc, rst, 0x04, 29, 1);\n\n \nMLXSW_ITEM32(reg, mddc, device_enable, 0x04, 28, 1);\n\nstatic inline void mlxsw_reg_mddc_pack(char *payload, u8 slot_index, bool rst,\n\t\t\t\t       bool device_enable)\n{\n\tMLXSW_REG_ZERO(mddc, payload);\n\tmlxsw_reg_mddc_slot_index_set(payload, slot_index);\n\tmlxsw_reg_mddc_rst_set(payload, rst);\n\tmlxsw_reg_mddc_device_enable_set(payload, device_enable);\n}\n\n \n#define MLXSW_REG_MFDE_ID 0x9200\n#define MLXSW_REG_MFDE_LEN 0x30\n\nMLXSW_REG_DEFINE(mfde, MLXSW_REG_MFDE_ID, MLXSW_REG_MFDE_LEN);\n\n \nMLXSW_ITEM32(reg, mfde, irisc_id, 0x00, 24, 8);\n\nenum mlxsw_reg_mfde_severity {\n\t \n\tMLXSW_REG_MFDE_SEVERITY_FATL = 2,\n\t \n\tMLXSW_REG_MFDE_SEVERITY_NRML = 3,\n\t \n\tMLXSW_REG_MFDE_SEVERITY_INTR = 5,\n};\n\n \nMLXSW_ITEM32(reg, mfde, severity, 0x00, 16, 8);\n\nenum mlxsw_reg_mfde_event_id {\n\t \n\tMLXSW_REG_MFDE_EVENT_ID_CRSPACE_TO = 1,\n\t \n\tMLXSW_REG_MFDE_EVENT_ID_KVD_IM_STOP,\n\t \n\tMLXSW_REG_MFDE_EVENT_ID_TEST,\n\t \n\tMLXSW_REG_MFDE_EVENT_ID_FW_ASSERT,\n\t \n\tMLXSW_REG_MFDE_EVENT_ID_FATAL_CAUSE,\n};\n\n \nMLXSW_ITEM32(reg, mfde, event_id, 0x00, 0, 16);\n\nenum mlxsw_reg_mfde_method {\n\tMLXSW_REG_MFDE_METHOD_QUERY,\n\tMLXSW_REG_MFDE_METHOD_WRITE,\n};\n\n \nMLXSW_ITEM32(reg, mfde, method, 0x04, 29, 1);\n\n \nMLXSW_ITEM32(reg, mfde, long_process, 0x04, 28, 1);\n\nenum mlxsw_reg_mfde_command_type {\n\tMLXSW_REG_MFDE_COMMAND_TYPE_MAD,\n\tMLXSW_REG_MFDE_COMMAND_TYPE_EMAD,\n\tMLXSW_REG_MFDE_COMMAND_TYPE_CMDIF,\n};\n\n \nMLXSW_ITEM32(reg, mfde, command_type, 0x04, 24, 2);\n\n \nMLXSW_ITEM32(reg, mfde, reg_attr_id, 0x04, 0, 16);\n\n \nMLXSW_ITEM32(reg, mfde, crspace_to_log_address, 0x10, 0, 32);\n\n \nMLXSW_ITEM32(reg, mfde, crspace_to_oe, 0x14, 24, 1);\n\n \nMLXSW_ITEM32(reg, mfde, crspace_to_log_id, 0x14, 0, 4);\n\n \nMLXSW_ITEM64(reg, mfde, crspace_to_log_ip, 0x18, 0, 64);\n\n \nMLXSW_ITEM32(reg, mfde, kvd_im_stop_oe, 0x10, 24, 1);\n\n \nMLXSW_ITEM32(reg, mfde, kvd_im_stop_pipes_mask, 0x10, 0, 16);\n\n \nMLXSW_ITEM32(reg, mfde, fw_assert_var0, 0x10, 0, 32);\nMLXSW_ITEM32(reg, mfde, fw_assert_var1, 0x14, 0, 32);\nMLXSW_ITEM32(reg, mfde, fw_assert_var2, 0x18, 0, 32);\nMLXSW_ITEM32(reg, mfde, fw_assert_var3, 0x1C, 0, 32);\nMLXSW_ITEM32(reg, mfde, fw_assert_var4, 0x20, 0, 32);\n\n \nMLXSW_ITEM32(reg, mfde, fw_assert_existptr, 0x24, 0, 32);\n\n \nMLXSW_ITEM32(reg, mfde, fw_assert_callra, 0x28, 0, 32);\n\n \nMLXSW_ITEM32(reg, mfde, fw_assert_oe, 0x2C, 24, 1);\n\n \nMLXSW_ITEM32(reg, mfde, fw_assert_tile_v, 0x2C, 23, 1);\n\n \nMLXSW_ITEM32(reg, mfde, fw_assert_tile_index, 0x2C, 16, 6);\n\n \nMLXSW_ITEM32(reg, mfde, fw_assert_ext_synd, 0x2C, 0, 16);\n\n \nMLXSW_ITEM32(reg, mfde, fatal_cause_id, 0x10, 0, 18);\n\n \nMLXSW_ITEM32(reg, mfde, fatal_cause_tile_v, 0x14, 23, 1);\n\n \nMLXSW_ITEM32(reg, mfde, fatal_cause_tile_index, 0x14, 16, 6);\n\n \n#define MLXSW_REG_TNGCR_ID 0xA001\n#define MLXSW_REG_TNGCR_LEN 0x44\n\nMLXSW_REG_DEFINE(tngcr, MLXSW_REG_TNGCR_ID, MLXSW_REG_TNGCR_LEN);\n\nenum mlxsw_reg_tngcr_type {\n\tMLXSW_REG_TNGCR_TYPE_VXLAN,\n\tMLXSW_REG_TNGCR_TYPE_VXLAN_GPE,\n\tMLXSW_REG_TNGCR_TYPE_GENEVE,\n\tMLXSW_REG_TNGCR_TYPE_NVGRE,\n};\n\n \nMLXSW_ITEM32(reg, tngcr, type, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, tngcr, nve_valid, 0x04, 31, 1);\n\n \nMLXSW_ITEM32(reg, tngcr, nve_ttl_uc, 0x04, 0, 8);\n\n \nMLXSW_ITEM32(reg, tngcr, nve_ttl_mc, 0x08, 0, 8);\n\nenum {\n\t \n\tMLXSW_REG_TNGCR_FL_NO_COPY,\n\t \n\tMLXSW_REG_TNGCR_FL_COPY,\n};\n\n \nMLXSW_ITEM32(reg, tngcr, nve_flc, 0x0C, 25, 1);\n\nenum {\n\t \n\tMLXSW_REG_TNGCR_FL_NO_HASH,\n\t \n\tMLXSW_REG_TNGCR_FL_HASH,\n};\n\n \nMLXSW_ITEM32(reg, tngcr, nve_flh, 0x0C, 24, 1);\n\n \nMLXSW_ITEM32(reg, tngcr, nve_fl_prefix, 0x0C, 8, 12);\n\n \nMLXSW_ITEM32(reg, tngcr, nve_fl_suffix, 0x0C, 0, 8);\n\nenum {\n\t \n\tMLXSW_REG_TNGCR_UDP_SPORT_NO_HASH,\n\t \n\tMLXSW_REG_TNGCR_UDP_SPORT_HASH,\n};\n\n \nMLXSW_ITEM32(reg, tngcr, nve_udp_sport_type, 0x10, 24, 1);\n\n \nMLXSW_ITEM32(reg, tngcr, nve_udp_sport_prefix, 0x10, 8, 8);\n\n \nMLXSW_ITEM32(reg, tngcr, nve_group_size_mc, 0x18, 0, 8);\n\n \nMLXSW_ITEM32(reg, tngcr, nve_group_size_flood, 0x1C, 0, 8);\n\n \nMLXSW_ITEM32(reg, tngcr, learn_enable, 0x20, 31, 1);\n\n \nMLXSW_ITEM32(reg, tngcr, underlay_virtual_router, 0x20, 0, 16);\n\n \nMLXSW_ITEM32(reg, tngcr, underlay_rif, 0x24, 0, 16);\n\n \nMLXSW_ITEM32(reg, tngcr, usipv4, 0x28, 0, 32);\n\n \nMLXSW_ITEM_BUF(reg, tngcr, usipv6, 0x30, 16);\n\nstatic inline void mlxsw_reg_tngcr_pack(char *payload,\n\t\t\t\t\tenum mlxsw_reg_tngcr_type type,\n\t\t\t\t\tbool valid, u8 ttl)\n{\n\tMLXSW_REG_ZERO(tngcr, payload);\n\tmlxsw_reg_tngcr_type_set(payload, type);\n\tmlxsw_reg_tngcr_nve_valid_set(payload, valid);\n\tmlxsw_reg_tngcr_nve_ttl_uc_set(payload, ttl);\n\tmlxsw_reg_tngcr_nve_ttl_mc_set(payload, ttl);\n\tmlxsw_reg_tngcr_nve_flc_set(payload, MLXSW_REG_TNGCR_FL_NO_COPY);\n\tmlxsw_reg_tngcr_nve_flh_set(payload, 0);\n\tmlxsw_reg_tngcr_nve_udp_sport_type_set(payload,\n\t\t\t\t\t       MLXSW_REG_TNGCR_UDP_SPORT_HASH);\n\tmlxsw_reg_tngcr_nve_udp_sport_prefix_set(payload, 0);\n\tmlxsw_reg_tngcr_nve_group_size_mc_set(payload, 1);\n\tmlxsw_reg_tngcr_nve_group_size_flood_set(payload, 1);\n}\n\n \n#define MLXSW_REG_TNUMT_ID 0xA003\n#define MLXSW_REG_TNUMT_LEN 0x20\n\nMLXSW_REG_DEFINE(tnumt, MLXSW_REG_TNUMT_ID, MLXSW_REG_TNUMT_LEN);\n\nenum mlxsw_reg_tnumt_record_type {\n\tMLXSW_REG_TNUMT_RECORD_TYPE_IPV4,\n\tMLXSW_REG_TNUMT_RECORD_TYPE_IPV6,\n\tMLXSW_REG_TNUMT_RECORD_TYPE_LABEL,\n};\n\n \nMLXSW_ITEM32(reg, tnumt, record_type, 0x00, 28, 4);\n\n \nMLXSW_ITEM32(reg, tnumt, tunnel_port, 0x00, 24, 4);\n\n \nMLXSW_ITEM32(reg, tnumt, underlay_mc_ptr, 0x00, 0, 24);\n\n \nMLXSW_ITEM32(reg, tnumt, vnext, 0x04, 31, 1);\n\n \nMLXSW_ITEM32(reg, tnumt, next_underlay_mc_ptr, 0x04, 0, 24);\n\n \nMLXSW_ITEM32(reg, tnumt, record_size, 0x08, 0, 3);\n\n \nMLXSW_ITEM32_INDEXED(reg, tnumt, udip, 0x0C, 0, 32, 0x04, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, tnumt, udip_ptr, 0x0C, 0, 24, 0x04, 0x00, false);\n\nstatic inline void mlxsw_reg_tnumt_pack(char *payload,\n\t\t\t\t\tenum mlxsw_reg_tnumt_record_type type,\n\t\t\t\t\tenum mlxsw_reg_tunnel_port tport,\n\t\t\t\t\tu32 underlay_mc_ptr, bool vnext,\n\t\t\t\t\tu32 next_underlay_mc_ptr,\n\t\t\t\t\tu8 record_size)\n{\n\tMLXSW_REG_ZERO(tnumt, payload);\n\tmlxsw_reg_tnumt_record_type_set(payload, type);\n\tmlxsw_reg_tnumt_tunnel_port_set(payload, tport);\n\tmlxsw_reg_tnumt_underlay_mc_ptr_set(payload, underlay_mc_ptr);\n\tmlxsw_reg_tnumt_vnext_set(payload, vnext);\n\tmlxsw_reg_tnumt_next_underlay_mc_ptr_set(payload, next_underlay_mc_ptr);\n\tmlxsw_reg_tnumt_record_size_set(payload, record_size);\n}\n\n \n#define MLXSW_REG_TNQCR_ID 0xA010\n#define MLXSW_REG_TNQCR_LEN 0x0C\n\nMLXSW_REG_DEFINE(tnqcr, MLXSW_REG_TNQCR_ID, MLXSW_REG_TNQCR_LEN);\n\n \nMLXSW_ITEM32(reg, tnqcr, enc_set_dscp, 0x04, 28, 1);\n\nstatic inline void mlxsw_reg_tnqcr_pack(char *payload)\n{\n\tMLXSW_REG_ZERO(tnqcr, payload);\n\tmlxsw_reg_tnqcr_enc_set_dscp_set(payload, 0);\n}\n\n \n#define MLXSW_REG_TNQDR_ID 0xA011\n#define MLXSW_REG_TNQDR_LEN 0x08\n\nMLXSW_REG_DEFINE(tnqdr, MLXSW_REG_TNQDR_ID, MLXSW_REG_TNQDR_LEN);\n\n \nMLXSW_ITEM32_LP(reg, tnqdr, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, tnqdr, dscp, 0x04, 0, 6);\n\nstatic inline void mlxsw_reg_tnqdr_pack(char *payload, u16 local_port)\n{\n\tMLXSW_REG_ZERO(tnqdr, payload);\n\tmlxsw_reg_tnqdr_local_port_set(payload, local_port);\n\tmlxsw_reg_tnqdr_dscp_set(payload, 0);\n}\n\n \n#define MLXSW_REG_TNEEM_ID 0xA012\n#define MLXSW_REG_TNEEM_LEN 0x0C\n\nMLXSW_REG_DEFINE(tneem, MLXSW_REG_TNEEM_ID, MLXSW_REG_TNEEM_LEN);\n\n \nMLXSW_ITEM32(reg, tneem, overlay_ecn, 0x04, 24, 2);\n\n \nMLXSW_ITEM32(reg, tneem, underlay_ecn, 0x04, 16, 2);\n\nstatic inline void mlxsw_reg_tneem_pack(char *payload, u8 overlay_ecn,\n\t\t\t\t\tu8 underlay_ecn)\n{\n\tMLXSW_REG_ZERO(tneem, payload);\n\tmlxsw_reg_tneem_overlay_ecn_set(payload, overlay_ecn);\n\tmlxsw_reg_tneem_underlay_ecn_set(payload, underlay_ecn);\n}\n\n \n#define MLXSW_REG_TNDEM_ID 0xA013\n#define MLXSW_REG_TNDEM_LEN 0x0C\n\nMLXSW_REG_DEFINE(tndem, MLXSW_REG_TNDEM_ID, MLXSW_REG_TNDEM_LEN);\n\n \nMLXSW_ITEM32(reg, tndem, underlay_ecn, 0x04, 24, 2);\n\n \nMLXSW_ITEM32(reg, tndem, overlay_ecn, 0x04, 16, 2);\n\n \nMLXSW_ITEM32(reg, tndem, eip_ecn, 0x04, 8, 2);\n\n \nMLXSW_ITEM32(reg, tndem, trap_en, 0x08, 28, 4);\n\n \nMLXSW_ITEM32(reg, tndem, trap_id, 0x08, 0, 9);\n\nstatic inline void mlxsw_reg_tndem_pack(char *payload, u8 underlay_ecn,\n\t\t\t\t\tu8 overlay_ecn, u8 ecn, bool trap_en,\n\t\t\t\t\tu16 trap_id)\n{\n\tMLXSW_REG_ZERO(tndem, payload);\n\tmlxsw_reg_tndem_underlay_ecn_set(payload, underlay_ecn);\n\tmlxsw_reg_tndem_overlay_ecn_set(payload, overlay_ecn);\n\tmlxsw_reg_tndem_eip_ecn_set(payload, ecn);\n\tmlxsw_reg_tndem_trap_en_set(payload, trap_en);\n\tmlxsw_reg_tndem_trap_id_set(payload, trap_id);\n}\n\n \n#define MLXSW_REG_TNPC_ID 0xA020\n#define MLXSW_REG_TNPC_LEN 0x18\n\nMLXSW_REG_DEFINE(tnpc, MLXSW_REG_TNPC_ID, MLXSW_REG_TNPC_LEN);\n\n \nMLXSW_ITEM32(reg, tnpc, tunnel_port, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, tnpc, learn_enable_v6, 0x04, 1, 1);\n\n \nMLXSW_ITEM32(reg, tnpc, learn_enable_v4, 0x04, 0, 1);\n\nstatic inline void mlxsw_reg_tnpc_pack(char *payload,\n\t\t\t\t       enum mlxsw_reg_tunnel_port tport,\n\t\t\t\t       bool learn_enable)\n{\n\tMLXSW_REG_ZERO(tnpc, payload);\n\tmlxsw_reg_tnpc_tunnel_port_set(payload, tport);\n\tmlxsw_reg_tnpc_learn_enable_v4_set(payload, learn_enable);\n\tmlxsw_reg_tnpc_learn_enable_v6_set(payload, learn_enable);\n}\n\n \n#define MLXSW_REG_TIGCR_ID 0xA801\n#define MLXSW_REG_TIGCR_LEN 0x10\n\nMLXSW_REG_DEFINE(tigcr, MLXSW_REG_TIGCR_ID, MLXSW_REG_TIGCR_LEN);\n\n \nMLXSW_ITEM32(reg, tigcr, ttlc, 0x04, 8, 1);\n\n \nMLXSW_ITEM32(reg, tigcr, ttl_uc, 0x04, 0, 8);\n\nstatic inline void mlxsw_reg_tigcr_pack(char *payload, bool ttlc, u8 ttl_uc)\n{\n\tMLXSW_REG_ZERO(tigcr, payload);\n\tmlxsw_reg_tigcr_ttlc_set(payload, ttlc);\n\tmlxsw_reg_tigcr_ttl_uc_set(payload, ttl_uc);\n}\n\n \n#define MLXSW_REG_TIEEM_ID 0xA812\n#define MLXSW_REG_TIEEM_LEN 0x0C\n\nMLXSW_REG_DEFINE(tieem, MLXSW_REG_TIEEM_ID, MLXSW_REG_TIEEM_LEN);\n\n \nMLXSW_ITEM32(reg, tieem, overlay_ecn, 0x04, 24, 2);\n\n \nMLXSW_ITEM32(reg, tieem, underlay_ecn, 0x04, 16, 2);\n\nstatic inline void mlxsw_reg_tieem_pack(char *payload, u8 overlay_ecn,\n\t\t\t\t\tu8 underlay_ecn)\n{\n\tMLXSW_REG_ZERO(tieem, payload);\n\tmlxsw_reg_tieem_overlay_ecn_set(payload, overlay_ecn);\n\tmlxsw_reg_tieem_underlay_ecn_set(payload, underlay_ecn);\n}\n\n \n#define MLXSW_REG_TIDEM_ID 0xA813\n#define MLXSW_REG_TIDEM_LEN 0x0C\n\nMLXSW_REG_DEFINE(tidem, MLXSW_REG_TIDEM_ID, MLXSW_REG_TIDEM_LEN);\n\n \nMLXSW_ITEM32(reg, tidem, underlay_ecn, 0x04, 24, 2);\n\n \nMLXSW_ITEM32(reg, tidem, overlay_ecn, 0x04, 16, 2);\n\n \nMLXSW_ITEM32(reg, tidem, eip_ecn, 0x04, 8, 2);\n\n \nMLXSW_ITEM32(reg, tidem, trap_en, 0x08, 28, 4);\n\n \nMLXSW_ITEM32(reg, tidem, trap_id, 0x08, 0, 9);\n\nstatic inline void mlxsw_reg_tidem_pack(char *payload, u8 underlay_ecn,\n\t\t\t\t\tu8 overlay_ecn, u8 eip_ecn,\n\t\t\t\t\tbool trap_en, u16 trap_id)\n{\n\tMLXSW_REG_ZERO(tidem, payload);\n\tmlxsw_reg_tidem_underlay_ecn_set(payload, underlay_ecn);\n\tmlxsw_reg_tidem_overlay_ecn_set(payload, overlay_ecn);\n\tmlxsw_reg_tidem_eip_ecn_set(payload, eip_ecn);\n\tmlxsw_reg_tidem_trap_en_set(payload, trap_en);\n\tmlxsw_reg_tidem_trap_id_set(payload, trap_id);\n}\n\n \n#define MLXSW_REG_SBPR_ID 0xB001\n#define MLXSW_REG_SBPR_LEN 0x14\n\nMLXSW_REG_DEFINE(sbpr, MLXSW_REG_SBPR_ID, MLXSW_REG_SBPR_LEN);\n\n \nMLXSW_ITEM32(reg, sbpr, desc, 0x00, 31, 1);\n\n \nenum mlxsw_reg_sbxx_dir {\n\tMLXSW_REG_SBXX_DIR_INGRESS,\n\tMLXSW_REG_SBXX_DIR_EGRESS,\n};\n\n \nMLXSW_ITEM32(reg, sbpr, dir, 0x00, 24, 2);\n\n \nMLXSW_ITEM32(reg, sbpr, pool, 0x00, 0, 4);\n\n \nMLXSW_ITEM32(reg, sbpr, infi_size, 0x04, 31, 1);\n\n \nMLXSW_ITEM32(reg, sbpr, size, 0x04, 0, 24);\n\nenum mlxsw_reg_sbpr_mode {\n\tMLXSW_REG_SBPR_MODE_STATIC,\n\tMLXSW_REG_SBPR_MODE_DYNAMIC,\n};\n\n \nMLXSW_ITEM32(reg, sbpr, mode, 0x08, 0, 4);\n\nstatic inline void mlxsw_reg_sbpr_pack(char *payload, u8 pool,\n\t\t\t\t       enum mlxsw_reg_sbxx_dir dir,\n\t\t\t\t       enum mlxsw_reg_sbpr_mode mode, u32 size,\n\t\t\t\t       bool infi_size)\n{\n\tMLXSW_REG_ZERO(sbpr, payload);\n\tmlxsw_reg_sbpr_pool_set(payload, pool);\n\tmlxsw_reg_sbpr_dir_set(payload, dir);\n\tmlxsw_reg_sbpr_mode_set(payload, mode);\n\tmlxsw_reg_sbpr_size_set(payload, size);\n\tmlxsw_reg_sbpr_infi_size_set(payload, infi_size);\n}\n\n \n#define MLXSW_REG_SBCM_ID 0xB002\n#define MLXSW_REG_SBCM_LEN 0x28\n\nMLXSW_REG_DEFINE(sbcm, MLXSW_REG_SBCM_ID, MLXSW_REG_SBCM_LEN);\n\n \nMLXSW_ITEM32_LP(reg, sbcm, 0x00, 16, 0x00, 4);\n\n \nMLXSW_ITEM32(reg, sbcm, pg_buff, 0x00, 8, 6);\n\n \nMLXSW_ITEM32(reg, sbcm, dir, 0x00, 0, 2);\n\n \nMLXSW_ITEM32(reg, sbcm, min_buff, 0x18, 0, 24);\n\n \n#define MLXSW_REG_SBXX_DYN_MAX_BUFF_MIN 1\n#define MLXSW_REG_SBXX_DYN_MAX_BUFF_MAX 14\n\n \nMLXSW_ITEM32(reg, sbcm, infi_max, 0x1C, 31, 1);\n\n \nMLXSW_ITEM32(reg, sbcm, max_buff, 0x1C, 0, 24);\n\n \nMLXSW_ITEM32(reg, sbcm, pool, 0x24, 0, 4);\n\nstatic inline void mlxsw_reg_sbcm_pack(char *payload, u16 local_port, u8 pg_buff,\n\t\t\t\t       enum mlxsw_reg_sbxx_dir dir,\n\t\t\t\t       u32 min_buff, u32 max_buff,\n\t\t\t\t       bool infi_max, u8 pool)\n{\n\tMLXSW_REG_ZERO(sbcm, payload);\n\tmlxsw_reg_sbcm_local_port_set(payload, local_port);\n\tmlxsw_reg_sbcm_pg_buff_set(payload, pg_buff);\n\tmlxsw_reg_sbcm_dir_set(payload, dir);\n\tmlxsw_reg_sbcm_min_buff_set(payload, min_buff);\n\tmlxsw_reg_sbcm_max_buff_set(payload, max_buff);\n\tmlxsw_reg_sbcm_infi_max_set(payload, infi_max);\n\tmlxsw_reg_sbcm_pool_set(payload, pool);\n}\n\n \n#define MLXSW_REG_SBPM_ID 0xB003\n#define MLXSW_REG_SBPM_LEN 0x28\n\nMLXSW_REG_DEFINE(sbpm, MLXSW_REG_SBPM_ID, MLXSW_REG_SBPM_LEN);\n\n \nMLXSW_ITEM32_LP(reg, sbpm, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, sbpm, pool, 0x00, 8, 4);\n\n \nMLXSW_ITEM32(reg, sbpm, dir, 0x00, 0, 2);\n\n \nMLXSW_ITEM32(reg, sbpm, buff_occupancy, 0x10, 0, 24);\n\n \nMLXSW_ITEM32(reg, sbpm, clr, 0x14, 31, 1);\n\n \nMLXSW_ITEM32(reg, sbpm, max_buff_occupancy, 0x14, 0, 24);\n\n \nMLXSW_ITEM32(reg, sbpm, min_buff, 0x18, 0, 24);\n\n \nMLXSW_ITEM32(reg, sbpm, max_buff, 0x1C, 0, 24);\n\nstatic inline void mlxsw_reg_sbpm_pack(char *payload, u16 local_port, u8 pool,\n\t\t\t\t       enum mlxsw_reg_sbxx_dir dir, bool clr,\n\t\t\t\t       u32 min_buff, u32 max_buff)\n{\n\tMLXSW_REG_ZERO(sbpm, payload);\n\tmlxsw_reg_sbpm_local_port_set(payload, local_port);\n\tmlxsw_reg_sbpm_pool_set(payload, pool);\n\tmlxsw_reg_sbpm_dir_set(payload, dir);\n\tmlxsw_reg_sbpm_clr_set(payload, clr);\n\tmlxsw_reg_sbpm_min_buff_set(payload, min_buff);\n\tmlxsw_reg_sbpm_max_buff_set(payload, max_buff);\n}\n\nstatic inline void mlxsw_reg_sbpm_unpack(char *payload, u32 *p_buff_occupancy,\n\t\t\t\t\t u32 *p_max_buff_occupancy)\n{\n\t*p_buff_occupancy = mlxsw_reg_sbpm_buff_occupancy_get(payload);\n\t*p_max_buff_occupancy = mlxsw_reg_sbpm_max_buff_occupancy_get(payload);\n}\n\n \n#define MLXSW_REG_SBMM_ID 0xB004\n#define MLXSW_REG_SBMM_LEN 0x28\n\nMLXSW_REG_DEFINE(sbmm, MLXSW_REG_SBMM_ID, MLXSW_REG_SBMM_LEN);\n\n \nMLXSW_ITEM32(reg, sbmm, prio, 0x00, 8, 4);\n\n \nMLXSW_ITEM32(reg, sbmm, min_buff, 0x18, 0, 24);\n\n \nMLXSW_ITEM32(reg, sbmm, max_buff, 0x1C, 0, 24);\n\n \nMLXSW_ITEM32(reg, sbmm, pool, 0x24, 0, 4);\n\nstatic inline void mlxsw_reg_sbmm_pack(char *payload, u8 prio, u32 min_buff,\n\t\t\t\t       u32 max_buff, u8 pool)\n{\n\tMLXSW_REG_ZERO(sbmm, payload);\n\tmlxsw_reg_sbmm_prio_set(payload, prio);\n\tmlxsw_reg_sbmm_min_buff_set(payload, min_buff);\n\tmlxsw_reg_sbmm_max_buff_set(payload, max_buff);\n\tmlxsw_reg_sbmm_pool_set(payload, pool);\n}\n\n \n#define MLXSW_REG_SBSR_ID 0xB005\n#define MLXSW_REG_SBSR_BASE_LEN 0x5C  \n#define MLXSW_REG_SBSR_REC_LEN 0x8  \n#define MLXSW_REG_SBSR_REC_MAX_COUNT 120\n#define MLXSW_REG_SBSR_LEN (MLXSW_REG_SBSR_BASE_LEN +\t\\\n\t\t\t    MLXSW_REG_SBSR_REC_LEN *\t\\\n\t\t\t    MLXSW_REG_SBSR_REC_MAX_COUNT)\n\nMLXSW_REG_DEFINE(sbsr, MLXSW_REG_SBSR_ID, MLXSW_REG_SBSR_LEN);\n\n \nMLXSW_ITEM32(reg, sbsr, clr, 0x00, 31, 1);\n\n#define MLXSW_REG_SBSR_NUM_PORTS_IN_PAGE 256\n\n \nMLXSW_ITEM32(reg, sbsr, port_page, 0x04, 0, 4);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, sbsr, ingress_port_mask, 0x10, 0x20, 1);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, sbsr, pg_buff_mask, 0x30, 0x4, 1);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, sbsr, egress_port_mask, 0x34, 0x20, 1);\n\n \nMLXSW_ITEM_BIT_ARRAY(reg, sbsr, tclass_mask, 0x54, 0x8, 1);\n\nstatic inline void mlxsw_reg_sbsr_pack(char *payload, bool clr)\n{\n\tMLXSW_REG_ZERO(sbsr, payload);\n\tmlxsw_reg_sbsr_clr_set(payload, clr);\n}\n\n \nMLXSW_ITEM32_INDEXED(reg, sbsr, rec_buff_occupancy, MLXSW_REG_SBSR_BASE_LEN,\n\t\t     0, 24, MLXSW_REG_SBSR_REC_LEN, 0x00, false);\n\n \nMLXSW_ITEM32_INDEXED(reg, sbsr, rec_max_buff_occupancy, MLXSW_REG_SBSR_BASE_LEN,\n\t\t     0, 24, MLXSW_REG_SBSR_REC_LEN, 0x04, false);\n\nstatic inline void mlxsw_reg_sbsr_rec_unpack(char *payload, int rec_index,\n\t\t\t\t\t     u32 *p_buff_occupancy,\n\t\t\t\t\t     u32 *p_max_buff_occupancy)\n{\n\t*p_buff_occupancy =\n\t\tmlxsw_reg_sbsr_rec_buff_occupancy_get(payload, rec_index);\n\t*p_max_buff_occupancy =\n\t\tmlxsw_reg_sbsr_rec_max_buff_occupancy_get(payload, rec_index);\n}\n\n \n#define MLXSW_REG_SBIB_ID 0xB006\n#define MLXSW_REG_SBIB_LEN 0x10\n\nMLXSW_REG_DEFINE(sbib, MLXSW_REG_SBIB_ID, MLXSW_REG_SBIB_LEN);\n\n \nMLXSW_ITEM32_LP(reg, sbib, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, sbib, buff_size, 0x08, 0, 24);\n\nstatic inline void mlxsw_reg_sbib_pack(char *payload, u16 local_port,\n\t\t\t\t       u32 buff_size)\n{\n\tMLXSW_REG_ZERO(sbib, payload);\n\tmlxsw_reg_sbib_local_port_set(payload, local_port);\n\tmlxsw_reg_sbib_buff_size_set(payload, buff_size);\n}\n\nstatic const struct mlxsw_reg_info *mlxsw_reg_infos[] = {\n\tMLXSW_REG(sgcr),\n\tMLXSW_REG(spad),\n\tMLXSW_REG(sspr),\n\tMLXSW_REG(sfdat),\n\tMLXSW_REG(sfd),\n\tMLXSW_REG(sfn),\n\tMLXSW_REG(spms),\n\tMLXSW_REG(spvid),\n\tMLXSW_REG(spvm),\n\tMLXSW_REG(spaft),\n\tMLXSW_REG(sfgc),\n\tMLXSW_REG(sfdf),\n\tMLXSW_REG(sldr),\n\tMLXSW_REG(slcr),\n\tMLXSW_REG(slcor),\n\tMLXSW_REG(spmlr),\n\tMLXSW_REG(svfa),\n\tMLXSW_REG(spvtr),\n\tMLXSW_REG(svpe),\n\tMLXSW_REG(sfmr),\n\tMLXSW_REG(spvmlr),\n\tMLXSW_REG(spfsr),\n\tMLXSW_REG(spvc),\n\tMLXSW_REG(spevet),\n\tMLXSW_REG(smpe),\n\tMLXSW_REG(smid2),\n\tMLXSW_REG(cwtp),\n\tMLXSW_REG(cwtpm),\n\tMLXSW_REG(pgcr),\n\tMLXSW_REG(ppbt),\n\tMLXSW_REG(pacl),\n\tMLXSW_REG(pagt),\n\tMLXSW_REG(ptar),\n\tMLXSW_REG(pprr),\n\tMLXSW_REG(ppbs),\n\tMLXSW_REG(prcr),\n\tMLXSW_REG(pefa),\n\tMLXSW_REG(pemrbt),\n\tMLXSW_REG(ptce2),\n\tMLXSW_REG(perpt),\n\tMLXSW_REG(peabfe),\n\tMLXSW_REG(perar),\n\tMLXSW_REG(ptce3),\n\tMLXSW_REG(percr),\n\tMLXSW_REG(pererp),\n\tMLXSW_REG(iedr),\n\tMLXSW_REG(qpts),\n\tMLXSW_REG(qpcr),\n\tMLXSW_REG(qtct),\n\tMLXSW_REG(qeec),\n\tMLXSW_REG(qrwe),\n\tMLXSW_REG(qpdsm),\n\tMLXSW_REG(qpdp),\n\tMLXSW_REG(qpdpm),\n\tMLXSW_REG(qtctm),\n\tMLXSW_REG(qpsc),\n\tMLXSW_REG(pmlp),\n\tMLXSW_REG(pmtu),\n\tMLXSW_REG(ptys),\n\tMLXSW_REG(ppad),\n\tMLXSW_REG(paos),\n\tMLXSW_REG(pfcc),\n\tMLXSW_REG(ppcnt),\n\tMLXSW_REG(pptb),\n\tMLXSW_REG(pbmc),\n\tMLXSW_REG(pspa),\n\tMLXSW_REG(pmaos),\n\tMLXSW_REG(pplr),\n\tMLXSW_REG(pmtdb),\n\tMLXSW_REG(pmecr),\n\tMLXSW_REG(pmpe),\n\tMLXSW_REG(pddr),\n\tMLXSW_REG(pmmp),\n\tMLXSW_REG(pllp),\n\tMLXSW_REG(pmtm),\n\tMLXSW_REG(htgt),\n\tMLXSW_REG(hpkt),\n\tMLXSW_REG(rgcr),\n\tMLXSW_REG(ritr),\n\tMLXSW_REG(rtar),\n\tMLXSW_REG(ratr),\n\tMLXSW_REG(rtdp),\n\tMLXSW_REG(rips),\n\tMLXSW_REG(ratrad),\n\tMLXSW_REG(rdpm),\n\tMLXSW_REG(ricnt),\n\tMLXSW_REG(rrcr),\n\tMLXSW_REG(ralta),\n\tMLXSW_REG(ralst),\n\tMLXSW_REG(raltb),\n\tMLXSW_REG(ralue),\n\tMLXSW_REG(rauht),\n\tMLXSW_REG(raleu),\n\tMLXSW_REG(rauhtd),\n\tMLXSW_REG(rigr2),\n\tMLXSW_REG(recr2),\n\tMLXSW_REG(rmft2),\n\tMLXSW_REG(reiv),\n\tMLXSW_REG(mfcr),\n\tMLXSW_REG(mfsc),\n\tMLXSW_REG(mfsm),\n\tMLXSW_REG(mfsl),\n\tMLXSW_REG(fore),\n\tMLXSW_REG(mtcap),\n\tMLXSW_REG(mtmp),\n\tMLXSW_REG(mtwe),\n\tMLXSW_REG(mtbr),\n\tMLXSW_REG(mcia),\n\tMLXSW_REG(mpat),\n\tMLXSW_REG(mpar),\n\tMLXSW_REG(mgir),\n\tMLXSW_REG(mrsr),\n\tMLXSW_REG(mlcr),\n\tMLXSW_REG(mcion),\n\tMLXSW_REG(mtpps),\n\tMLXSW_REG(mtutc),\n\tMLXSW_REG(mcqi),\n\tMLXSW_REG(mcc),\n\tMLXSW_REG(mcda),\n\tMLXSW_REG(mcam),\n\tMLXSW_REG(mpsc),\n\tMLXSW_REG(mgpc),\n\tMLXSW_REG(mprs),\n\tMLXSW_REG(mogcr),\n\tMLXSW_REG(mpagr),\n\tMLXSW_REG(momte),\n\tMLXSW_REG(mtpppc),\n\tMLXSW_REG(mtpptr),\n\tMLXSW_REG(mtptpt),\n\tMLXSW_REG(mtpcpc),\n\tMLXSW_REG(mfgd),\n\tMLXSW_REG(mgpir),\n\tMLXSW_REG(mbct),\n\tMLXSW_REG(mddt),\n\tMLXSW_REG(mddq),\n\tMLXSW_REG(mddc),\n\tMLXSW_REG(mfde),\n\tMLXSW_REG(tngcr),\n\tMLXSW_REG(tnumt),\n\tMLXSW_REG(tnqcr),\n\tMLXSW_REG(tnqdr),\n\tMLXSW_REG(tneem),\n\tMLXSW_REG(tndem),\n\tMLXSW_REG(tnpc),\n\tMLXSW_REG(tigcr),\n\tMLXSW_REG(tieem),\n\tMLXSW_REG(tidem),\n\tMLXSW_REG(sbpr),\n\tMLXSW_REG(sbcm),\n\tMLXSW_REG(sbpm),\n\tMLXSW_REG(sbmm),\n\tMLXSW_REG(sbsr),\n\tMLXSW_REG(sbib),\n};\n\nstatic inline const char *mlxsw_reg_id_str(u16 reg_id)\n{\n\tconst struct mlxsw_reg_info *reg_info;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mlxsw_reg_infos); i++) {\n\t\treg_info = mlxsw_reg_infos[i];\n\t\tif (reg_info->id == reg_id)\n\t\t\treturn reg_info->name;\n\t}\n\treturn \"*UNKNOWN*\";\n}\n\n \n#define MLXSW_REG_PUDE_LEN 0x10\n\n \nMLXSW_ITEM32(reg, pude, swid, 0x00, 24, 8);\n\n \nMLXSW_ITEM32_LP(reg, pude, 0x00, 16, 0x00, 12);\n\n \nMLXSW_ITEM32(reg, pude, admin_status, 0x00, 8, 4);\n\n \nMLXSW_ITEM32(reg, pude, oper_status, 0x00, 0, 4);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}