{
  "module_name": "spectrum_matchall.c",
  "hash_id": "20bea8538dd42fecd55fcf926f1e31c21be71c3aef2d82fd7948c5c0bbd27eb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_matchall.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <net/flow_offload.h>\n\n#include \"spectrum.h\"\n#include \"spectrum_span.h\"\n#include \"reg.h\"\n\nstatic struct mlxsw_sp_mall_entry *\nmlxsw_sp_mall_entry_find(struct mlxsw_sp_flow_block *block, unsigned long cookie)\n{\n\tstruct mlxsw_sp_mall_entry *mall_entry;\n\n\tlist_for_each_entry(mall_entry, &block->mall.list, list)\n\t\tif (mall_entry->cookie == cookie)\n\t\t\treturn mall_entry;\n\n\treturn NULL;\n}\n\nstatic int\nmlxsw_sp_mall_port_mirror_add(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t      struct mlxsw_sp_mall_entry *mall_entry,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_span_agent_parms agent_parms = {};\n\tstruct mlxsw_sp_span_trigger_parms parms;\n\tenum mlxsw_sp_span_trigger trigger;\n\tint err;\n\n\tif (!mall_entry->mirror.to_dev) {\n\t\tNL_SET_ERR_MSG(extack, \"Could not find requested device\");\n\t\treturn -EINVAL;\n\t}\n\n\tagent_parms.to_dev = mall_entry->mirror.to_dev;\n\terr = mlxsw_sp_span_agent_get(mlxsw_sp, &mall_entry->mirror.span_id,\n\t\t\t\t      &agent_parms);\n\tif (err) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to get SPAN agent\");\n\t\treturn err;\n\t}\n\n\terr = mlxsw_sp_span_analyzed_port_get(mlxsw_sp_port,\n\t\t\t\t\t      mall_entry->ingress);\n\tif (err) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to get analyzed port\");\n\t\tgoto err_analyzed_port_get;\n\t}\n\n\ttrigger = mall_entry->ingress ? MLXSW_SP_SPAN_TRIGGER_INGRESS :\n\t\t\t\t\tMLXSW_SP_SPAN_TRIGGER_EGRESS;\n\tparms.span_id = mall_entry->mirror.span_id;\n\tparms.probability_rate = 1;\n\terr = mlxsw_sp_span_agent_bind(mlxsw_sp, trigger, mlxsw_sp_port,\n\t\t\t\t       &parms);\n\tif (err) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to bind SPAN agent\");\n\t\tgoto err_agent_bind;\n\t}\n\n\treturn 0;\n\nerr_agent_bind:\n\tmlxsw_sp_span_analyzed_port_put(mlxsw_sp_port, mall_entry->ingress);\nerr_analyzed_port_get:\n\tmlxsw_sp_span_agent_put(mlxsw_sp, mall_entry->mirror.span_id);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_mall_port_mirror_del(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t      struct mlxsw_sp_mall_entry *mall_entry)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_span_trigger_parms parms;\n\tenum mlxsw_sp_span_trigger trigger;\n\n\ttrigger = mall_entry->ingress ? MLXSW_SP_SPAN_TRIGGER_INGRESS :\n\t\t\t\t\tMLXSW_SP_SPAN_TRIGGER_EGRESS;\n\tparms.span_id = mall_entry->mirror.span_id;\n\tmlxsw_sp_span_agent_unbind(mlxsw_sp, trigger, mlxsw_sp_port, &parms);\n\tmlxsw_sp_span_analyzed_port_put(mlxsw_sp_port, mall_entry->ingress);\n\tmlxsw_sp_span_agent_put(mlxsw_sp, mall_entry->mirror.span_id);\n}\n\nstatic int mlxsw_sp_mall_port_sample_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t bool enable, u32 rate)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar mpsc_pl[MLXSW_REG_MPSC_LEN];\n\n\tmlxsw_reg_mpsc_pack(mpsc_pl, mlxsw_sp_port->local_port, enable, rate);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mpsc), mpsc_pl);\n}\n\nstatic int\nmlxsw_sp_mall_port_sample_add(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t      struct mlxsw_sp_mall_entry *mall_entry,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_sample_trigger trigger;\n\tint err;\n\n\tif (mall_entry->ingress)\n\t\ttrigger.type = MLXSW_SP_SAMPLE_TRIGGER_TYPE_INGRESS;\n\telse\n\t\ttrigger.type = MLXSW_SP_SAMPLE_TRIGGER_TYPE_EGRESS;\n\ttrigger.local_port = mlxsw_sp_port->local_port;\n\terr = mlxsw_sp_sample_trigger_params_set(mlxsw_sp, &trigger,\n\t\t\t\t\t\t &mall_entry->sample.params,\n\t\t\t\t\t\t extack);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp->mall_ops->sample_add(mlxsw_sp, mlxsw_sp_port,\n\t\t\t\t\t     mall_entry, extack);\n\tif (err)\n\t\tgoto err_port_sample_set;\n\treturn 0;\n\nerr_port_sample_set:\n\tmlxsw_sp_sample_trigger_params_unset(mlxsw_sp, &trigger);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp_mall_port_sample_del(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t      struct mlxsw_sp_mall_entry *mall_entry)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_sample_trigger trigger;\n\n\tif (mall_entry->ingress)\n\t\ttrigger.type = MLXSW_SP_SAMPLE_TRIGGER_TYPE_INGRESS;\n\telse\n\t\ttrigger.type = MLXSW_SP_SAMPLE_TRIGGER_TYPE_EGRESS;\n\ttrigger.local_port = mlxsw_sp_port->local_port;\n\n\tmlxsw_sp->mall_ops->sample_del(mlxsw_sp, mlxsw_sp_port, mall_entry);\n\tmlxsw_sp_sample_trigger_params_unset(mlxsw_sp, &trigger);\n}\n\nstatic int\nmlxsw_sp_mall_port_rule_add(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t    struct mlxsw_sp_mall_entry *mall_entry,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tswitch (mall_entry->type) {\n\tcase MLXSW_SP_MALL_ACTION_TYPE_MIRROR:\n\t\treturn mlxsw_sp_mall_port_mirror_add(mlxsw_sp_port, mall_entry,\n\t\t\t\t\t\t     extack);\n\tcase MLXSW_SP_MALL_ACTION_TYPE_SAMPLE:\n\t\treturn mlxsw_sp_mall_port_sample_add(mlxsw_sp_port, mall_entry,\n\t\t\t\t\t\t     extack);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void\nmlxsw_sp_mall_port_rule_del(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t    struct mlxsw_sp_mall_entry *mall_entry)\n{\n\tswitch (mall_entry->type) {\n\tcase MLXSW_SP_MALL_ACTION_TYPE_MIRROR:\n\t\tmlxsw_sp_mall_port_mirror_del(mlxsw_sp_port, mall_entry);\n\t\tbreak;\n\tcase MLXSW_SP_MALL_ACTION_TYPE_SAMPLE:\n\t\tmlxsw_sp_mall_port_sample_del(mlxsw_sp_port, mall_entry);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n\nstatic void mlxsw_sp_mall_prio_update(struct mlxsw_sp_flow_block *block)\n{\n\tstruct mlxsw_sp_mall_entry *mall_entry;\n\n\tif (list_empty(&block->mall.list))\n\t\treturn;\n\tblock->mall.min_prio = UINT_MAX;\n\tblock->mall.max_prio = 0;\n\tlist_for_each_entry(mall_entry, &block->mall.list, list) {\n\t\tif (mall_entry->priority < block->mall.min_prio)\n\t\t\tblock->mall.min_prio = mall_entry->priority;\n\t\tif (mall_entry->priority > block->mall.max_prio)\n\t\t\tblock->mall.max_prio = mall_entry->priority;\n\t}\n}\n\nint mlxsw_sp_mall_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t  struct mlxsw_sp_flow_block *block,\n\t\t\t  struct tc_cls_matchall_offload *f)\n{\n\tstruct mlxsw_sp_flow_block_binding *binding;\n\tstruct mlxsw_sp_mall_entry *mall_entry;\n\t__be16 protocol = f->common.protocol;\n\tstruct flow_action_entry *act;\n\tunsigned int flower_min_prio;\n\tunsigned int flower_max_prio;\n\tbool flower_prio_valid;\n\tint err;\n\n\tif (!flow_offload_has_one_action(&f->rule->action)) {\n\t\tNL_SET_ERR_MSG(f->common.extack, \"Only singular actions are supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (f->common.chain_index) {\n\t\tNL_SET_ERR_MSG(f->common.extack, \"Only chain 0 is supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (mlxsw_sp_flow_block_is_mixed_bound(block)) {\n\t\tNL_SET_ERR_MSG(f->common.extack, \"Only not mixed bound blocks are supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = mlxsw_sp_flower_prio_get(mlxsw_sp, block, f->common.chain_index,\n\t\t\t\t       &flower_min_prio, &flower_max_prio);\n\tif (err) {\n\t\tif (err != -ENOENT) {\n\t\t\tNL_SET_ERR_MSG(f->common.extack, \"Failed to get flower priorities\");\n\t\t\treturn err;\n\t\t}\n\t\tflower_prio_valid = false;\n\t\t \n\t} else {\n\t\tflower_prio_valid = true;\n\t}\n\n\tif (protocol != htons(ETH_P_ALL)) {\n\t\tNL_SET_ERR_MSG(f->common.extack, \"matchall rules only supported with 'all' protocol\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmall_entry = kzalloc(sizeof(*mall_entry), GFP_KERNEL);\n\tif (!mall_entry)\n\t\treturn -ENOMEM;\n\tmall_entry->cookie = f->cookie;\n\tmall_entry->priority = f->common.prio;\n\tmall_entry->ingress = mlxsw_sp_flow_block_is_ingress_bound(block);\n\n\tif (flower_prio_valid && mall_entry->ingress &&\n\t    mall_entry->priority >= flower_min_prio) {\n\t\tNL_SET_ERR_MSG(f->common.extack, \"Failed to add behind existing flower rules\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto errout;\n\t}\n\tif (flower_prio_valid && !mall_entry->ingress &&\n\t    mall_entry->priority <= flower_max_prio) {\n\t\tNL_SET_ERR_MSG(f->common.extack, \"Failed to add in front of existing flower rules\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto errout;\n\t}\n\n\tact = &f->rule->action.entries[0];\n\n\tswitch (act->id) {\n\tcase FLOW_ACTION_MIRRED:\n\t\tmall_entry->type = MLXSW_SP_MALL_ACTION_TYPE_MIRROR;\n\t\tmall_entry->mirror.to_dev = act->dev;\n\t\tbreak;\n\tcase FLOW_ACTION_SAMPLE:\n\t\tmall_entry->type = MLXSW_SP_MALL_ACTION_TYPE_SAMPLE;\n\t\tmall_entry->sample.params.psample_group = act->sample.psample_group;\n\t\tmall_entry->sample.params.truncate = act->sample.truncate;\n\t\tmall_entry->sample.params.trunc_size = act->sample.trunc_size;\n\t\tmall_entry->sample.params.rate = act->sample.rate;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto errout;\n\t}\n\n\tlist_for_each_entry(binding, &block->binding_list, list) {\n\t\terr = mlxsw_sp_mall_port_rule_add(binding->mlxsw_sp_port,\n\t\t\t\t\t\t  mall_entry, f->common.extack);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\n\tblock->rule_count++;\n\tif (mall_entry->ingress)\n\t\tblock->egress_blocker_rule_count++;\n\telse\n\t\tblock->ingress_blocker_rule_count++;\n\tlist_add_tail(&mall_entry->list, &block->mall.list);\n\tmlxsw_sp_mall_prio_update(block);\n\treturn 0;\n\nrollback:\n\tlist_for_each_entry_continue_reverse(binding, &block->binding_list,\n\t\t\t\t\t     list)\n\t\tmlxsw_sp_mall_port_rule_del(binding->mlxsw_sp_port, mall_entry);\nerrout:\n\tkfree(mall_entry);\n\treturn err;\n}\n\nvoid mlxsw_sp_mall_destroy(struct mlxsw_sp_flow_block *block,\n\t\t\t   struct tc_cls_matchall_offload *f)\n{\n\tstruct mlxsw_sp_flow_block_binding *binding;\n\tstruct mlxsw_sp_mall_entry *mall_entry;\n\n\tmall_entry = mlxsw_sp_mall_entry_find(block, f->cookie);\n\tif (!mall_entry) {\n\t\tNL_SET_ERR_MSG(f->common.extack, \"Entry not found\");\n\t\treturn;\n\t}\n\n\tlist_del(&mall_entry->list);\n\tif (mall_entry->ingress)\n\t\tblock->egress_blocker_rule_count--;\n\telse\n\t\tblock->ingress_blocker_rule_count--;\n\tblock->rule_count--;\n\tlist_for_each_entry(binding, &block->binding_list, list)\n\t\tmlxsw_sp_mall_port_rule_del(binding->mlxsw_sp_port, mall_entry);\n\tkfree_rcu(mall_entry, rcu);  \n\tmlxsw_sp_mall_prio_update(block);\n}\n\nint mlxsw_sp_mall_port_bind(struct mlxsw_sp_flow_block *block,\n\t\t\t    struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_mall_entry *mall_entry;\n\tint err;\n\n\tlist_for_each_entry(mall_entry, &block->mall.list, list) {\n\t\terr = mlxsw_sp_mall_port_rule_add(mlxsw_sp_port, mall_entry,\n\t\t\t\t\t\t  extack);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\treturn 0;\n\nrollback:\n\tlist_for_each_entry_continue_reverse(mall_entry, &block->mall.list,\n\t\t\t\t\t     list)\n\t\tmlxsw_sp_mall_port_rule_del(mlxsw_sp_port, mall_entry);\n\treturn err;\n}\n\nvoid mlxsw_sp_mall_port_unbind(struct mlxsw_sp_flow_block *block,\n\t\t\t       struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp_mall_entry *mall_entry;\n\n\tlist_for_each_entry(mall_entry, &block->mall.list, list)\n\t\tmlxsw_sp_mall_port_rule_del(mlxsw_sp_port, mall_entry);\n}\n\nint mlxsw_sp_mall_prio_get(struct mlxsw_sp_flow_block *block, u32 chain_index,\n\t\t\t   unsigned int *p_min_prio, unsigned int *p_max_prio)\n{\n\tif (chain_index || list_empty(&block->mall.list))\n\t\t \n\t\treturn -ENOENT;\n\t*p_min_prio = block->mall.min_prio;\n\t*p_max_prio = block->mall.max_prio;\n\treturn 0;\n}\n\nstatic int mlxsw_sp1_mall_sample_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t     struct mlxsw_sp_mall_entry *mall_entry,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tu32 rate = mall_entry->sample.params.rate;\n\n\tif (!mall_entry->ingress) {\n\t\tNL_SET_ERR_MSG(extack, \"Sampling is not supported on egress\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (rate > MLXSW_REG_MPSC_RATE_MAX) {\n\t\tNL_SET_ERR_MSG(extack, \"Unsupported sampling rate\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn mlxsw_sp_mall_port_sample_set(mlxsw_sp_port, true, rate);\n}\n\nstatic void mlxsw_sp1_mall_sample_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      struct mlxsw_sp_mall_entry *mall_entry)\n{\n\tmlxsw_sp_mall_port_sample_set(mlxsw_sp_port, false, 1);\n}\n\nconst struct mlxsw_sp_mall_ops mlxsw_sp1_mall_ops = {\n\t.sample_add = mlxsw_sp1_mall_sample_add,\n\t.sample_del = mlxsw_sp1_mall_sample_del,\n};\n\nstatic int mlxsw_sp2_mall_sample_add(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t     struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t     struct mlxsw_sp_mall_entry *mall_entry,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_sp_span_trigger_parms trigger_parms = {};\n\tstruct mlxsw_sp_span_agent_parms agent_parms = {\n\t\t.to_dev = NULL,\t \n\t\t.session_id = MLXSW_SP_SPAN_SESSION_ID_SAMPLING,\n\t};\n\tu32 rate = mall_entry->sample.params.rate;\n\tenum mlxsw_sp_span_trigger span_trigger;\n\tint err;\n\n\terr = mlxsw_sp_span_agent_get(mlxsw_sp, &mall_entry->sample.span_id,\n\t\t\t\t      &agent_parms);\n\tif (err) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to get SPAN agent\");\n\t\treturn err;\n\t}\n\n\terr = mlxsw_sp_span_analyzed_port_get(mlxsw_sp_port,\n\t\t\t\t\t      mall_entry->ingress);\n\tif (err) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to get analyzed port\");\n\t\tgoto err_analyzed_port_get;\n\t}\n\n\tspan_trigger = mall_entry->ingress ? MLXSW_SP_SPAN_TRIGGER_INGRESS :\n\t\t\t\t\t     MLXSW_SP_SPAN_TRIGGER_EGRESS;\n\ttrigger_parms.span_id = mall_entry->sample.span_id;\n\ttrigger_parms.probability_rate = rate;\n\terr = mlxsw_sp_span_agent_bind(mlxsw_sp, span_trigger, mlxsw_sp_port,\n\t\t\t\t       &trigger_parms);\n\tif (err) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to bind SPAN agent\");\n\t\tgoto err_agent_bind;\n\t}\n\n\treturn 0;\n\nerr_agent_bind:\n\tmlxsw_sp_span_analyzed_port_put(mlxsw_sp_port, mall_entry->ingress);\nerr_analyzed_port_get:\n\tmlxsw_sp_span_agent_put(mlxsw_sp, mall_entry->sample.span_id);\n\treturn err;\n}\n\nstatic void mlxsw_sp2_mall_sample_del(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t      struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      struct mlxsw_sp_mall_entry *mall_entry)\n{\n\tstruct mlxsw_sp_span_trigger_parms trigger_parms = {};\n\tenum mlxsw_sp_span_trigger span_trigger;\n\n\tspan_trigger = mall_entry->ingress ? MLXSW_SP_SPAN_TRIGGER_INGRESS :\n\t\t\t\t\t     MLXSW_SP_SPAN_TRIGGER_EGRESS;\n\ttrigger_parms.span_id = mall_entry->sample.span_id;\n\tmlxsw_sp_span_agent_unbind(mlxsw_sp, span_trigger, mlxsw_sp_port,\n\t\t\t\t   &trigger_parms);\n\tmlxsw_sp_span_analyzed_port_put(mlxsw_sp_port, mall_entry->ingress);\n\tmlxsw_sp_span_agent_put(mlxsw_sp, mall_entry->sample.span_id);\n}\n\nconst struct mlxsw_sp_mall_ops mlxsw_sp2_mall_ops = {\n\t.sample_add = mlxsw_sp2_mall_sample_add,\n\t.sample_del = mlxsw_sp2_mall_sample_del,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}