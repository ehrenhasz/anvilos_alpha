{
  "module_name": "spectrum_dcb.c",
  "hash_id": "510ffbceede12632bd2e27bd6b3c500fe93472e157499516170faaf8c801a2b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_dcb.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/string.h>\n#include <linux/bitops.h>\n#include <net/dcbnl.h>\n\n#include \"spectrum.h\"\n#include \"reg.h\"\n\nstatic u8 mlxsw_sp_dcbnl_getdcbx(struct net_device __always_unused *dev)\n{\n\treturn DCB_CAP_DCBX_HOST | DCB_CAP_DCBX_VER_IEEE;\n}\n\nstatic u8 mlxsw_sp_dcbnl_setdcbx(struct net_device __always_unused *dev,\n\t\t\t\t u8 mode)\n{\n\treturn (mode != (DCB_CAP_DCBX_HOST | DCB_CAP_DCBX_VER_IEEE)) ? 1 : 0;\n}\n\nstatic int mlxsw_sp_dcbnl_ieee_getets(struct net_device *dev,\n\t\t\t\t      struct ieee_ets *ets)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\n\tmemcpy(ets, mlxsw_sp_port->dcb.ets, sizeof(*ets));\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_ets_validate(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      struct ieee_ets *ets)\n{\n\tstruct net_device *dev = mlxsw_sp_port->dev;\n\tbool has_ets_tc = false;\n\tint i, tx_bw_sum = 0;\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tswitch (ets->tc_tsa[i]) {\n\t\tcase IEEE_8021QAZ_TSA_STRICT:\n\t\t\tbreak;\n\t\tcase IEEE_8021QAZ_TSA_ETS:\n\t\t\thas_ets_tc = true;\n\t\t\ttx_bw_sum += ets->tc_tx_bw[i];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_err(dev, \"Only strict priority and ETS are supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ets->prio_tc[i] >= IEEE_8021QAZ_MAX_TCS) {\n\t\t\tnetdev_err(dev, \"Invalid TC\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (has_ets_tc && tx_bw_sum != 100) {\n\t\tnetdev_err(dev, \"Total ETS bandwidth should equal 100\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_headroom_ets_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\t  struct ieee_ets *ets)\n{\n\tstruct net_device *dev = mlxsw_sp_port->dev;\n\tstruct mlxsw_sp_hdroom hdroom;\n\tint prio;\n\tint err;\n\n\thdroom = *mlxsw_sp_port->hdroom;\n\tfor (prio = 0; prio < IEEE_8021QAZ_MAX_TCS; prio++)\n\t\thdroom.prios.prio[prio].ets_buf_idx = ets->prio_tc[prio];\n\tmlxsw_sp_hdroom_prios_reset_buf_idx(&hdroom);\n\tmlxsw_sp_hdroom_bufs_reset_lossiness(&hdroom);\n\tmlxsw_sp_hdroom_bufs_reset_sizes(mlxsw_sp_port, &hdroom);\n\n\terr = mlxsw_sp_hdroom_configure(mlxsw_sp_port, &hdroom);\n\tif (err) {\n\t\tnetdev_err(dev, \"Failed to configure port's headroom\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __mlxsw_sp_dcbnl_ieee_setets(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t\tstruct ieee_ets *ets)\n{\n\tstruct ieee_ets *my_ets = mlxsw_sp_port->dcb.ets;\n\tstruct net_device *dev = mlxsw_sp_port->dev;\n\tint i, err;\n\n\t \n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\tbool dwrr = ets->tc_tsa[i] == IEEE_8021QAZ_TSA_ETS;\n\t\tu8 weight = ets->tc_tx_bw[i];\n\n\t\terr = mlxsw_sp_port_ets_set(mlxsw_sp_port,\n\t\t\t\t\t    MLXSW_REG_QEEC_HR_SUBGROUP, i,\n\t\t\t\t\t    0, dwrr, weight);\n\t\tif (err) {\n\t\t\tnetdev_err(dev, \"Failed to link subgroup ETS element %d to group\\n\",\n\t\t\t\t   i);\n\t\t\tgoto err_port_ets_set;\n\t\t}\n\t}\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\terr = mlxsw_sp_port_prio_tc_set(mlxsw_sp_port, i,\n\t\t\t\t\t\tets->prio_tc[i]);\n\t\tif (err) {\n\t\t\tnetdev_err(dev, \"Failed to map prio %d to TC %d\\n\", i,\n\t\t\t\t   ets->prio_tc[i]);\n\t\t\tgoto err_port_prio_tc_set;\n\t\t}\n\t}\n\n\t \n\terr = mlxsw_sp_port_headroom_ets_set(mlxsw_sp_port, ets);\n\tif (err)\n\t\tgoto err_port_headroom_set;\n\n\treturn 0;\n\nerr_port_headroom_set:\n\ti = IEEE_8021QAZ_MAX_TCS;\nerr_port_prio_tc_set:\n\tfor (i--; i >= 0; i--)\n\t\tmlxsw_sp_port_prio_tc_set(mlxsw_sp_port, i, my_ets->prio_tc[i]);\n\ti = IEEE_8021QAZ_MAX_TCS;\nerr_port_ets_set:\n\tfor (i--; i >= 0; i--) {\n\t\tbool dwrr = my_ets->tc_tsa[i] == IEEE_8021QAZ_TSA_ETS;\n\t\tu8 weight = my_ets->tc_tx_bw[i];\n\n\t\terr = mlxsw_sp_port_ets_set(mlxsw_sp_port,\n\t\t\t\t\t    MLXSW_REG_QEEC_HR_SUBGROUP, i,\n\t\t\t\t\t    0, dwrr, weight);\n\t}\n\treturn err;\n}\n\nstatic int mlxsw_sp_dcbnl_ieee_setets(struct net_device *dev,\n\t\t\t\t      struct ieee_ets *ets)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tint err;\n\n\terr = mlxsw_sp_port_ets_validate(mlxsw_sp_port, ets);\n\tif (err)\n\t\treturn err;\n\n\terr = __mlxsw_sp_dcbnl_ieee_setets(mlxsw_sp_port, ets);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(mlxsw_sp_port->dcb.ets, ets, sizeof(*ets));\n\tmlxsw_sp_port->dcb.ets->ets_cap = IEEE_8021QAZ_MAX_TCS;\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_dcbnl_app_validate(struct net_device *dev,\n\t\t\t\t       struct dcb_app *app)\n{\n\tif (app->priority >= IEEE_8021QAZ_MAX_TCS) {\n\t\tnetdev_err(dev, \"APP entry with priority value %u is invalid\\n\",\n\t\t\t   app->priority);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (app->selector) {\n\tcase IEEE_8021QAZ_APP_SEL_DSCP:\n\t\tif (app->protocol >= 64) {\n\t\t\tnetdev_err(dev, \"DSCP APP entry with protocol value %u is invalid\\n\",\n\t\t\t\t   app->protocol);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase IEEE_8021QAZ_APP_SEL_ETHERTYPE:\n\t\tif (app->protocol) {\n\t\t\tnetdev_err(dev, \"EtherType APP entries with protocol value != 0 not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_err(dev, \"APP entries with selector %u not supported\\n\",\n\t\t\t   app->selector);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic u8\nmlxsw_sp_port_dcb_app_default_prio(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tu8 prio_mask;\n\n\tprio_mask = dcb_ieee_getapp_default_prio_mask(mlxsw_sp_port->dev);\n\tif (prio_mask)\n\t\t \n\t\treturn fls(prio_mask) - 1;\n\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_port_dcb_app_dscp_prio_map(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    u8 default_prio,\n\t\t\t\t    struct dcb_ieee_app_dscp_map *map)\n{\n\tint i;\n\n\tdcb_ieee_getapp_dscp_prio_mask_map(mlxsw_sp_port->dev, map);\n\tfor (i = 0; i < ARRAY_SIZE(map->map); ++i) {\n\t\tif (map->map[i])\n\t\t\tmap->map[i] = fls(map->map[i]) - 1;\n\t\telse\n\t\t\tmap->map[i] = default_prio;\n\t}\n}\n\nstatic bool\nmlxsw_sp_port_dcb_app_prio_dscp_map(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    struct dcb_ieee_app_prio_map *map)\n{\n\tbool have_dscp = false;\n\tint i;\n\n\tdcb_ieee_getapp_prio_dscp_mask_map(mlxsw_sp_port->dev, map);\n\tfor (i = 0; i < ARRAY_SIZE(map->map); ++i) {\n\t\tif (map->map[i]) {\n\t\t\tmap->map[i] = fls64(map->map[i]) - 1;\n\t\t\thave_dscp = true;\n\t\t}\n\t}\n\n\treturn have_dscp;\n}\n\nstatic int\nmlxsw_sp_port_dcb_app_update_qpts(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  enum mlxsw_reg_qpts_trust_state ts)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar qpts_pl[MLXSW_REG_QPTS_LEN];\n\n\tmlxsw_reg_qpts_pack(qpts_pl, mlxsw_sp_port->local_port, ts);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpts), qpts_pl);\n}\n\nstatic int\nmlxsw_sp_port_dcb_app_update_qrwe(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  bool rewrite_dscp)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar qrwe_pl[MLXSW_REG_QRWE_LEN];\n\n\tmlxsw_reg_qrwe_pack(qrwe_pl, mlxsw_sp_port->local_port,\n\t\t\t    false, rewrite_dscp);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qrwe), qrwe_pl);\n}\n\nstatic int\nmlxsw_sp_port_dcb_toggle_trust(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t       enum mlxsw_reg_qpts_trust_state ts)\n{\n\tbool rewrite_dscp = ts == MLXSW_REG_QPTS_TRUST_STATE_DSCP;\n\tint err;\n\n\tif (mlxsw_sp_port->dcb.trust_state == ts)\n\t\treturn 0;\n\n\terr = mlxsw_sp_port_dcb_app_update_qpts(mlxsw_sp_port, ts);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_port_dcb_app_update_qrwe(mlxsw_sp_port, rewrite_dscp);\n\tif (err)\n\t\tgoto err_update_qrwe;\n\n\tmlxsw_sp_port->dcb.trust_state = ts;\n\treturn 0;\n\nerr_update_qrwe:\n\tmlxsw_sp_port_dcb_app_update_qpts(mlxsw_sp_port,\n\t\t\t\t\t  mlxsw_sp_port->dcb.trust_state);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_port_dcb_app_update_qpdp(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t  u8 default_prio)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar qpdp_pl[MLXSW_REG_QPDP_LEN];\n\n\tmlxsw_reg_qpdp_pack(qpdp_pl, mlxsw_sp_port->local_port, default_prio);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpdp), qpdp_pl);\n}\n\nstatic int\nmlxsw_sp_port_dcb_app_update_qpdpm(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t   struct dcb_ieee_app_dscp_map *map)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar qpdpm_pl[MLXSW_REG_QPDPM_LEN];\n\tshort int i;\n\n\tmlxsw_reg_qpdpm_pack(qpdpm_pl, mlxsw_sp_port->local_port);\n\tfor (i = 0; i < ARRAY_SIZE(map->map); ++i)\n\t\tmlxsw_reg_qpdpm_dscp_pack(qpdpm_pl, i, map->map[i]);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpdpm), qpdpm_pl);\n}\n\nstatic int\nmlxsw_sp_port_dcb_app_update_qpdsm(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t   struct dcb_ieee_app_prio_map *map)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tchar qpdsm_pl[MLXSW_REG_QPDSM_LEN];\n\tshort int i;\n\n\tmlxsw_reg_qpdsm_pack(qpdsm_pl, mlxsw_sp_port->local_port);\n\tfor (i = 0; i < ARRAY_SIZE(map->map); ++i)\n\t\tmlxsw_reg_qpdsm_prio_pack(qpdsm_pl, i, map->map[i]);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpdsm), qpdsm_pl);\n}\n\nstatic int mlxsw_sp_port_dcb_app_update(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct dcb_ieee_app_prio_map prio_map;\n\tstruct dcb_ieee_app_dscp_map dscp_map;\n\tu8 default_prio;\n\tbool have_dscp;\n\tint err;\n\n\tdefault_prio = mlxsw_sp_port_dcb_app_default_prio(mlxsw_sp_port);\n\terr = mlxsw_sp_port_dcb_app_update_qpdp(mlxsw_sp_port, default_prio);\n\tif (err) {\n\t\tnetdev_err(mlxsw_sp_port->dev, \"Couldn't configure port default priority\\n\");\n\t\treturn err;\n\t}\n\n\thave_dscp = mlxsw_sp_port_dcb_app_prio_dscp_map(mlxsw_sp_port,\n\t\t\t\t\t\t\t&prio_map);\n\n\tmlxsw_sp_port_dcb_app_dscp_prio_map(mlxsw_sp_port, default_prio,\n\t\t\t\t\t    &dscp_map);\n\terr = mlxsw_sp_port_dcb_app_update_qpdpm(mlxsw_sp_port,\n\t\t\t\t\t\t &dscp_map);\n\tif (err) {\n\t\tnetdev_err(mlxsw_sp_port->dev, \"Couldn't configure priority map\\n\");\n\t\treturn err;\n\t}\n\n\terr = mlxsw_sp_port_dcb_app_update_qpdsm(mlxsw_sp_port,\n\t\t\t\t\t\t &prio_map);\n\tif (err) {\n\t\tnetdev_err(mlxsw_sp_port->dev, \"Couldn't configure DSCP rewrite map\\n\");\n\t\treturn err;\n\t}\n\n\tif (!have_dscp) {\n\t\terr = mlxsw_sp_port_dcb_toggle_trust(mlxsw_sp_port,\n\t\t\t\t\tMLXSW_REG_QPTS_TRUST_STATE_PCP);\n\t\tif (err)\n\t\t\tnetdev_err(mlxsw_sp_port->dev, \"Couldn't switch to trust L2\\n\");\n\t\treturn err;\n\t}\n\n\terr = mlxsw_sp_port_dcb_toggle_trust(mlxsw_sp_port,\n\t\t\t\t\t     MLXSW_REG_QPTS_TRUST_STATE_DSCP);\n\tif (err) {\n\t\t \n\t\tnetdev_err(mlxsw_sp_port->dev, \"Couldn't switch to trust L3\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_dcbnl_ieee_setapp(struct net_device *dev,\n\t\t\t\t      struct dcb_app *app)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tint err;\n\n\terr = mlxsw_sp_dcbnl_app_validate(dev, app);\n\tif (err)\n\t\treturn err;\n\n\terr = dcb_ieee_setapp(dev, app);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_port_dcb_app_update(mlxsw_sp_port);\n\tif (err)\n\t\tgoto err_update;\n\n\treturn 0;\n\nerr_update:\n\tdcb_ieee_delapp(dev, app);\n\treturn err;\n}\n\nstatic int mlxsw_sp_dcbnl_ieee_delapp(struct net_device *dev,\n\t\t\t\t      struct dcb_app *app)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tint err;\n\n\terr = dcb_ieee_delapp(dev, app);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp_port_dcb_app_update(mlxsw_sp_port);\n\tif (err)\n\t\tnetdev_err(dev, \"Failed to update DCB APP configuration\\n\");\n\treturn 0;\n}\n\nstatic int mlxsw_sp_dcbnl_ieee_getmaxrate(struct net_device *dev,\n\t\t\t\t\t  struct ieee_maxrate *maxrate)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\n\tmemcpy(maxrate, mlxsw_sp_port->dcb.maxrate, sizeof(*maxrate));\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_dcbnl_ieee_setmaxrate(struct net_device *dev,\n\t\t\t\t\t  struct ieee_maxrate *maxrate)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tstruct ieee_maxrate *my_maxrate = mlxsw_sp_port->dcb.maxrate;\n\tint err, i;\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\terr = mlxsw_sp_port_ets_maxrate_set(mlxsw_sp_port,\n\t\t\t\t\t\t    MLXSW_REG_QEEC_HR_SUBGROUP,\n\t\t\t\t\t\t    i, 0,\n\t\t\t\t\t\t    maxrate->tc_maxrate[i], 0);\n\t\tif (err) {\n\t\t\tnetdev_err(dev, \"Failed to set maxrate for TC %d\\n\", i);\n\t\t\tgoto err_port_ets_maxrate_set;\n\t\t}\n\t}\n\n\tmemcpy(mlxsw_sp_port->dcb.maxrate, maxrate, sizeof(*maxrate));\n\n\treturn 0;\n\nerr_port_ets_maxrate_set:\n\tfor (i--; i >= 0; i--)\n\t\tmlxsw_sp_port_ets_maxrate_set(mlxsw_sp_port,\n\t\t\t\t\t      MLXSW_REG_QEEC_HR_SUBGROUP,\n\t\t\t\t\t      i, 0,\n\t\t\t\t\t      my_maxrate->tc_maxrate[i], 0);\n\treturn err;\n}\n\nstatic int mlxsw_sp_port_pfc_cnt_get(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t     u8 prio)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct ieee_pfc *my_pfc = mlxsw_sp_port->dcb.pfc;\n\tchar ppcnt_pl[MLXSW_REG_PPCNT_LEN];\n\tint err;\n\n\tmlxsw_reg_ppcnt_pack(ppcnt_pl, mlxsw_sp_port->local_port,\n\t\t\t     MLXSW_REG_PPCNT_PRIO_CNT, prio);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ppcnt), ppcnt_pl);\n\tif (err)\n\t\treturn err;\n\n\tmy_pfc->requests[prio] = mlxsw_reg_ppcnt_tx_pause_get(ppcnt_pl);\n\tmy_pfc->indications[prio] = mlxsw_reg_ppcnt_rx_pause_get(ppcnt_pl);\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_dcbnl_ieee_getpfc(struct net_device *dev,\n\t\t\t\t      struct ieee_pfc *pfc)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tint err, i;\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\n\t\terr = mlxsw_sp_port_pfc_cnt_get(mlxsw_sp_port, i);\n\t\tif (err) {\n\t\t\tnetdev_err(dev, \"Failed to get PFC count for priority %d\\n\",\n\t\t\t\t   i);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tmemcpy(pfc, mlxsw_sp_port->dcb.pfc, sizeof(*pfc));\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_port_pfc_set(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t struct ieee_pfc *pfc)\n{\n\tchar pfcc_pl[MLXSW_REG_PFCC_LEN];\n\n\tmlxsw_reg_pfcc_pack(pfcc_pl, mlxsw_sp_port->local_port);\n\tmlxsw_reg_pfcc_pprx_set(pfcc_pl, mlxsw_sp_port->link.rx_pause);\n\tmlxsw_reg_pfcc_pptx_set(pfcc_pl, mlxsw_sp_port->link.tx_pause);\n\tmlxsw_reg_pfcc_prio_pack(pfcc_pl, pfc->pfc_en);\n\n\treturn mlxsw_reg_write(mlxsw_sp_port->mlxsw_sp->core, MLXSW_REG(pfcc),\n\t\t\t       pfcc_pl);\n}\n\nstatic int mlxsw_sp_dcbnl_ieee_setpfc(struct net_device *dev,\n\t\t\t\t      struct ieee_pfc *pfc)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tbool pause_en = mlxsw_sp_port_is_pause_en(mlxsw_sp_port);\n\tstruct mlxsw_sp_hdroom orig_hdroom;\n\tstruct mlxsw_sp_hdroom hdroom;\n\tint prio;\n\tint err;\n\n\tif (pause_en && pfc->pfc_en) {\n\t\tnetdev_err(dev, \"PAUSE frames already enabled on port\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\torig_hdroom = *mlxsw_sp_port->hdroom;\n\n\thdroom = orig_hdroom;\n\tif (pfc->pfc_en)\n\t\thdroom.delay_bytes = DIV_ROUND_UP(pfc->delay, BITS_PER_BYTE);\n\telse\n\t\thdroom.delay_bytes = 0;\n\n\tfor (prio = 0; prio < IEEE_8021QAZ_MAX_TCS; prio++)\n\t\thdroom.prios.prio[prio].lossy = !(pfc->pfc_en & BIT(prio));\n\n\tmlxsw_sp_hdroom_bufs_reset_lossiness(&hdroom);\n\tmlxsw_sp_hdroom_bufs_reset_sizes(mlxsw_sp_port, &hdroom);\n\n\terr = mlxsw_sp_hdroom_configure(mlxsw_sp_port, &hdroom);\n\tif (err) {\n\t\tnetdev_err(dev, \"Failed to configure port's headroom for PFC\\n\");\n\t\treturn err;\n\t}\n\n\terr = mlxsw_sp_port_pfc_set(mlxsw_sp_port, pfc);\n\tif (err) {\n\t\tnetdev_err(dev, \"Failed to configure PFC\\n\");\n\t\tgoto err_port_pfc_set;\n\t}\n\n\tmemcpy(mlxsw_sp_port->dcb.pfc, pfc, sizeof(*pfc));\n\tmlxsw_sp_port->dcb.pfc->pfc_cap = IEEE_8021QAZ_MAX_TCS;\n\n\treturn 0;\n\nerr_port_pfc_set:\n\tmlxsw_sp_hdroom_configure(mlxsw_sp_port, &orig_hdroom);\n\treturn err;\n}\n\nstatic int mlxsw_sp_dcbnl_getbuffer(struct net_device *dev, struct dcbnl_buffer *buf)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tstruct mlxsw_sp_hdroom *hdroom = mlxsw_sp_port->hdroom;\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tint prio;\n\tint i;\n\n\tbuf->total_size = 0;\n\n\tBUILD_BUG_ON(DCBX_MAX_BUFFERS > MLXSW_SP_PB_COUNT);\n\tfor (i = 0; i < MLXSW_SP_PB_COUNT; i++) {\n\t\tu32 bytes = mlxsw_sp_cells_bytes(mlxsw_sp, hdroom->bufs.buf[i].size_cells);\n\n\t\tif (i < DCBX_MAX_BUFFERS)\n\t\t\tbuf->buffer_size[i] = bytes;\n\t\tbuf->total_size += bytes;\n\t}\n\n\tbuf->total_size += mlxsw_sp_cells_bytes(mlxsw_sp, hdroom->int_buf.size_cells);\n\n\tfor (prio = 0; prio < IEEE_8021Q_MAX_PRIORITIES; prio++)\n\t\tbuf->prio2buffer[prio] = hdroom->prios.prio[prio].buf_idx;\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp_dcbnl_setbuffer(struct net_device *dev, struct dcbnl_buffer *buf)\n{\n\tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_hdroom hdroom;\n\tint prio;\n\tint i;\n\n\thdroom = *mlxsw_sp_port->hdroom;\n\n\tif (hdroom.mode != MLXSW_SP_HDROOM_MODE_TC) {\n\t\tnetdev_err(dev, \"The use of dcbnl_setbuffer is only allowed if egress is configured using TC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (prio = 0; prio < IEEE_8021Q_MAX_PRIORITIES; prio++)\n\t\thdroom.prios.prio[prio].set_buf_idx = buf->prio2buffer[prio];\n\n\tBUILD_BUG_ON(DCBX_MAX_BUFFERS > MLXSW_SP_PB_COUNT);\n\tfor (i = 0; i < DCBX_MAX_BUFFERS; i++)\n\t\thdroom.bufs.buf[i].set_size_cells = mlxsw_sp_bytes_cells(mlxsw_sp,\n\t\t\t\t\t\t\t\t\t buf->buffer_size[i]);\n\n\tmlxsw_sp_hdroom_prios_reset_buf_idx(&hdroom);\n\tmlxsw_sp_hdroom_bufs_reset_lossiness(&hdroom);\n\tmlxsw_sp_hdroom_bufs_reset_sizes(mlxsw_sp_port, &hdroom);\n\treturn mlxsw_sp_hdroom_configure(mlxsw_sp_port, &hdroom);\n}\n\nstatic const struct dcbnl_rtnl_ops mlxsw_sp_dcbnl_ops = {\n\t.ieee_getets\t\t= mlxsw_sp_dcbnl_ieee_getets,\n\t.ieee_setets\t\t= mlxsw_sp_dcbnl_ieee_setets,\n\t.ieee_getmaxrate\t= mlxsw_sp_dcbnl_ieee_getmaxrate,\n\t.ieee_setmaxrate\t= mlxsw_sp_dcbnl_ieee_setmaxrate,\n\t.ieee_getpfc\t\t= mlxsw_sp_dcbnl_ieee_getpfc,\n\t.ieee_setpfc\t\t= mlxsw_sp_dcbnl_ieee_setpfc,\n\t.ieee_setapp\t\t= mlxsw_sp_dcbnl_ieee_setapp,\n\t.ieee_delapp\t\t= mlxsw_sp_dcbnl_ieee_delapp,\n\n\t.getdcbx\t\t= mlxsw_sp_dcbnl_getdcbx,\n\t.setdcbx\t\t= mlxsw_sp_dcbnl_setdcbx,\n\n\t.dcbnl_getbuffer\t= mlxsw_sp_dcbnl_getbuffer,\n\t.dcbnl_setbuffer\t= mlxsw_sp_dcbnl_setbuffer,\n};\n\nstatic int mlxsw_sp_port_ets_init(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tmlxsw_sp_port->dcb.ets = kzalloc(sizeof(*mlxsw_sp_port->dcb.ets),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!mlxsw_sp_port->dcb.ets)\n\t\treturn -ENOMEM;\n\n\tmlxsw_sp_port->dcb.ets->ets_cap = IEEE_8021QAZ_MAX_TCS;\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_port_ets_fini(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tkfree(mlxsw_sp_port->dcb.ets);\n}\n\nstatic int mlxsw_sp_port_maxrate_init(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tint i;\n\n\tmlxsw_sp_port->dcb.maxrate = kmalloc(sizeof(*mlxsw_sp_port->dcb.maxrate),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!mlxsw_sp_port->dcb.maxrate)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\n\t\tmlxsw_sp_port->dcb.maxrate->tc_maxrate[i] = MLXSW_REG_QEEC_MAS_DIS;\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_port_maxrate_fini(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tkfree(mlxsw_sp_port->dcb.maxrate);\n}\n\nstatic int mlxsw_sp_port_pfc_init(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tmlxsw_sp_port->dcb.pfc = kzalloc(sizeof(*mlxsw_sp_port->dcb.pfc),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!mlxsw_sp_port->dcb.pfc)\n\t\treturn -ENOMEM;\n\n\tmlxsw_sp_port->dcb.pfc->pfc_cap = IEEE_8021QAZ_MAX_TCS;\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_port_pfc_fini(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tkfree(mlxsw_sp_port->dcb.pfc);\n}\n\nint mlxsw_sp_port_dcb_init(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tint err;\n\n\terr = mlxsw_sp_port_ets_init(mlxsw_sp_port);\n\tif (err)\n\t\treturn err;\n\terr = mlxsw_sp_port_maxrate_init(mlxsw_sp_port);\n\tif (err)\n\t\tgoto err_port_maxrate_init;\n\terr = mlxsw_sp_port_pfc_init(mlxsw_sp_port);\n\tif (err)\n\t\tgoto err_port_pfc_init;\n\n\tmlxsw_sp_port->dcb.trust_state = MLXSW_REG_QPTS_TRUST_STATE_PCP;\n\tmlxsw_sp_port->dev->dcbnl_ops = &mlxsw_sp_dcbnl_ops;\n\n\treturn 0;\n\nerr_port_pfc_init:\n\tmlxsw_sp_port_maxrate_fini(mlxsw_sp_port);\nerr_port_maxrate_init:\n\tmlxsw_sp_port_ets_fini(mlxsw_sp_port);\n\treturn err;\n}\n\nvoid mlxsw_sp_port_dcb_fini(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tmlxsw_sp_port_pfc_fini(mlxsw_sp_port);\n\tmlxsw_sp_port_maxrate_fini(mlxsw_sp_port);\n\tmlxsw_sp_port_ets_fini(mlxsw_sp_port);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}