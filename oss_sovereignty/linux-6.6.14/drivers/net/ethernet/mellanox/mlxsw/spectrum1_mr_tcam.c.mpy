{
  "module_name": "spectrum1_mr_tcam.c",
  "hash_id": "72402b8582f5982e956dfd32ce59c964d924d8d22d68e0e486f2423f3ff048d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum1_mr_tcam.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/parman.h>\n\n#include \"reg.h\"\n#include \"spectrum.h\"\n#include \"core_acl_flex_actions.h\"\n#include \"spectrum_mr.h\"\n\nstruct mlxsw_sp1_mr_tcam_region {\n\tstruct mlxsw_sp *mlxsw_sp;\n\tenum mlxsw_reg_rtar_key_type rtar_key_type;\n\tstruct parman *parman;\n\tstruct parman_prio *parman_prios;\n};\n\nstruct mlxsw_sp1_mr_tcam {\n\tstruct mlxsw_sp1_mr_tcam_region tcam_regions[MLXSW_SP_L3_PROTO_MAX];\n};\n\nstruct mlxsw_sp1_mr_tcam_route {\n\tstruct parman_item parman_item;\n\tstruct parman_prio *parman_prio;\n};\n\nstatic int mlxsw_sp1_mr_tcam_route_replace(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t   struct parman_item *parman_item,\n\t\t\t\t\t   struct mlxsw_sp_mr_route_key *key,\n\t\t\t\t\t   struct mlxsw_afa_block *afa_block)\n{\n\tchar rmft2_pl[MLXSW_REG_RMFT2_LEN];\n\n\tswitch (key->proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\tmlxsw_reg_rmft2_ipv4_pack(rmft2_pl, true, parman_item->index,\n\t\t\t\t\t  key->vrid,\n\t\t\t\t\t  MLXSW_REG_RMFT2_IRIF_MASK_IGNORE, 0,\n\t\t\t\t\t  ntohl(key->group.addr4),\n\t\t\t\t\t  ntohl(key->group_mask.addr4),\n\t\t\t\t\t  ntohl(key->source.addr4),\n\t\t\t\t\t  ntohl(key->source_mask.addr4),\n\t\t\t\t\t  mlxsw_afa_block_first_set(afa_block));\n\t\tbreak;\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\tmlxsw_reg_rmft2_ipv6_pack(rmft2_pl, true, parman_item->index,\n\t\t\t\t\t  key->vrid,\n\t\t\t\t\t  MLXSW_REG_RMFT2_IRIF_MASK_IGNORE, 0,\n\t\t\t\t\t  key->group.addr6,\n\t\t\t\t\t  key->group_mask.addr6,\n\t\t\t\t\t  key->source.addr6,\n\t\t\t\t\t  key->source_mask.addr6,\n\t\t\t\t\t  mlxsw_afa_block_first_set(afa_block));\n\t}\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rmft2), rmft2_pl);\n}\n\nstatic int mlxsw_sp1_mr_tcam_route_remove(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  struct parman_item *parman_item,\n\t\t\t\t\t  struct mlxsw_sp_mr_route_key *key)\n{\n\tstruct in6_addr zero_addr = IN6ADDR_ANY_INIT;\n\tchar rmft2_pl[MLXSW_REG_RMFT2_LEN];\n\n\tswitch (key->proto) {\n\tcase MLXSW_SP_L3_PROTO_IPV4:\n\t\tmlxsw_reg_rmft2_ipv4_pack(rmft2_pl, false, parman_item->index,\n\t\t\t\t\t  key->vrid, 0, 0, 0, 0, 0, 0, NULL);\n\t\tbreak;\n\tcase MLXSW_SP_L3_PROTO_IPV6:\n\t\tmlxsw_reg_rmft2_ipv6_pack(rmft2_pl, false, parman_item->index,\n\t\t\t\t\t  key->vrid, 0, 0, zero_addr, zero_addr,\n\t\t\t\t\t  zero_addr, zero_addr, NULL);\n\t\tbreak;\n\t}\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rmft2), rmft2_pl);\n}\n\nstatic struct mlxsw_sp1_mr_tcam_region *\nmlxsw_sp1_mr_tcam_protocol_region(struct mlxsw_sp1_mr_tcam *mr_tcam,\n\t\t\t\t  enum mlxsw_sp_l3proto proto)\n{\n\treturn &mr_tcam->tcam_regions[proto];\n}\n\nstatic int\nmlxsw_sp1_mr_tcam_route_parman_item_add(struct mlxsw_sp1_mr_tcam *mr_tcam,\n\t\t\t\t\tstruct mlxsw_sp1_mr_tcam_route *route,\n\t\t\t\t\tstruct mlxsw_sp_mr_route_key *key,\n\t\t\t\t\tenum mlxsw_sp_mr_route_prio prio)\n{\n\tstruct mlxsw_sp1_mr_tcam_region *tcam_region;\n\tint err;\n\n\ttcam_region = mlxsw_sp1_mr_tcam_protocol_region(mr_tcam, key->proto);\n\terr = parman_item_add(tcam_region->parman,\n\t\t\t      &tcam_region->parman_prios[prio],\n\t\t\t      &route->parman_item);\n\tif (err)\n\t\treturn err;\n\n\troute->parman_prio = &tcam_region->parman_prios[prio];\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp1_mr_tcam_route_parman_item_remove(struct mlxsw_sp1_mr_tcam *mr_tcam,\n\t\t\t\t\t   struct mlxsw_sp1_mr_tcam_route *route,\n\t\t\t\t\t   struct mlxsw_sp_mr_route_key *key)\n{\n\tstruct mlxsw_sp1_mr_tcam_region *tcam_region;\n\n\ttcam_region = mlxsw_sp1_mr_tcam_protocol_region(mr_tcam, key->proto);\n\tparman_item_remove(tcam_region->parman,\n\t\t\t   route->parman_prio, &route->parman_item);\n}\n\nstatic int\nmlxsw_sp1_mr_tcam_route_create(struct mlxsw_sp *mlxsw_sp, void *priv,\n\t\t\t       void *route_priv,\n\t\t\t       struct mlxsw_sp_mr_route_key *key,\n\t\t\t       struct mlxsw_afa_block *afa_block,\n\t\t\t       enum mlxsw_sp_mr_route_prio prio)\n{\n\tstruct mlxsw_sp1_mr_tcam_route *route = route_priv;\n\tstruct mlxsw_sp1_mr_tcam *mr_tcam = priv;\n\tint err;\n\n\terr = mlxsw_sp1_mr_tcam_route_parman_item_add(mr_tcam, route,\n\t\t\t\t\t\t      key, prio);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_sp1_mr_tcam_route_replace(mlxsw_sp, &route->parman_item,\n\t\t\t\t\t      key, afa_block);\n\tif (err)\n\t\tgoto err_route_replace;\n\treturn 0;\n\nerr_route_replace:\n\tmlxsw_sp1_mr_tcam_route_parman_item_remove(mr_tcam, route, key);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp1_mr_tcam_route_destroy(struct mlxsw_sp *mlxsw_sp, void *priv,\n\t\t\t\tvoid *route_priv,\n\t\t\t\tstruct mlxsw_sp_mr_route_key *key)\n{\n\tstruct mlxsw_sp1_mr_tcam_route *route = route_priv;\n\tstruct mlxsw_sp1_mr_tcam *mr_tcam = priv;\n\n\tmlxsw_sp1_mr_tcam_route_remove(mlxsw_sp, &route->parman_item, key);\n\tmlxsw_sp1_mr_tcam_route_parman_item_remove(mr_tcam, route, key);\n}\n\nstatic int\nmlxsw_sp1_mr_tcam_route_update(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       void *route_priv,\n\t\t\t       struct mlxsw_sp_mr_route_key *key,\n\t\t\t       struct mlxsw_afa_block *afa_block)\n{\n\tstruct mlxsw_sp1_mr_tcam_route *route = route_priv;\n\n\treturn mlxsw_sp1_mr_tcam_route_replace(mlxsw_sp, &route->parman_item,\n\t\t\t\t\t       key, afa_block);\n}\n\n#define MLXSW_SP1_MR_TCAM_REGION_BASE_COUNT 16\n#define MLXSW_SP1_MR_TCAM_REGION_RESIZE_STEP 16\n\nstatic int\nmlxsw_sp1_mr_tcam_region_alloc(struct mlxsw_sp1_mr_tcam_region *mr_tcam_region)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mr_tcam_region->mlxsw_sp;\n\tchar rtar_pl[MLXSW_REG_RTAR_LEN];\n\n\tmlxsw_reg_rtar_pack(rtar_pl, MLXSW_REG_RTAR_OP_ALLOCATE,\n\t\t\t    mr_tcam_region->rtar_key_type,\n\t\t\t    MLXSW_SP1_MR_TCAM_REGION_BASE_COUNT);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rtar), rtar_pl);\n}\n\nstatic void\nmlxsw_sp1_mr_tcam_region_free(struct mlxsw_sp1_mr_tcam_region *mr_tcam_region)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mr_tcam_region->mlxsw_sp;\n\tchar rtar_pl[MLXSW_REG_RTAR_LEN];\n\n\tmlxsw_reg_rtar_pack(rtar_pl, MLXSW_REG_RTAR_OP_DEALLOCATE,\n\t\t\t    mr_tcam_region->rtar_key_type, 0);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rtar), rtar_pl);\n}\n\nstatic int mlxsw_sp1_mr_tcam_region_parman_resize(void *priv,\n\t\t\t\t\t\t  unsigned long new_count)\n{\n\tstruct mlxsw_sp1_mr_tcam_region *mr_tcam_region = priv;\n\tstruct mlxsw_sp *mlxsw_sp = mr_tcam_region->mlxsw_sp;\n\tchar rtar_pl[MLXSW_REG_RTAR_LEN];\n\tu64 max_tcam_rules;\n\n\tmax_tcam_rules = MLXSW_CORE_RES_GET(mlxsw_sp->core, ACL_MAX_TCAM_RULES);\n\tif (new_count > max_tcam_rules)\n\t\treturn -EINVAL;\n\tmlxsw_reg_rtar_pack(rtar_pl, MLXSW_REG_RTAR_OP_RESIZE,\n\t\t\t    mr_tcam_region->rtar_key_type, new_count);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rtar), rtar_pl);\n}\n\nstatic void mlxsw_sp1_mr_tcam_region_parman_move(void *priv,\n\t\t\t\t\t\t unsigned long from_index,\n\t\t\t\t\t\t unsigned long to_index,\n\t\t\t\t\t\t unsigned long count)\n{\n\tstruct mlxsw_sp1_mr_tcam_region *mr_tcam_region = priv;\n\tstruct mlxsw_sp *mlxsw_sp = mr_tcam_region->mlxsw_sp;\n\tchar rrcr_pl[MLXSW_REG_RRCR_LEN];\n\n\tmlxsw_reg_rrcr_pack(rrcr_pl, MLXSW_REG_RRCR_OP_MOVE,\n\t\t\t    from_index, count,\n\t\t\t    mr_tcam_region->rtar_key_type, to_index);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(rrcr), rrcr_pl);\n}\n\nstatic const struct parman_ops mlxsw_sp1_mr_tcam_region_parman_ops = {\n\t.base_count\t= MLXSW_SP1_MR_TCAM_REGION_BASE_COUNT,\n\t.resize_step\t= MLXSW_SP1_MR_TCAM_REGION_RESIZE_STEP,\n\t.resize\t\t= mlxsw_sp1_mr_tcam_region_parman_resize,\n\t.move\t\t= mlxsw_sp1_mr_tcam_region_parman_move,\n\t.algo\t\t= PARMAN_ALGO_TYPE_LSORT,\n};\n\nstatic int\nmlxsw_sp1_mr_tcam_region_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp1_mr_tcam_region *mr_tcam_region,\n\t\t\t      enum mlxsw_reg_rtar_key_type rtar_key_type)\n{\n\tstruct parman_prio *parman_prios;\n\tstruct parman *parman;\n\tint err;\n\tint i;\n\n\tmr_tcam_region->rtar_key_type = rtar_key_type;\n\tmr_tcam_region->mlxsw_sp = mlxsw_sp;\n\n\terr = mlxsw_sp1_mr_tcam_region_alloc(mr_tcam_region);\n\tif (err)\n\t\treturn err;\n\n\tparman = parman_create(&mlxsw_sp1_mr_tcam_region_parman_ops,\n\t\t\t       mr_tcam_region);\n\tif (!parman) {\n\t\terr = -ENOMEM;\n\t\tgoto err_parman_create;\n\t}\n\tmr_tcam_region->parman = parman;\n\n\tparman_prios = kmalloc_array(MLXSW_SP_MR_ROUTE_PRIO_MAX + 1,\n\t\t\t\t     sizeof(*parman_prios), GFP_KERNEL);\n\tif (!parman_prios) {\n\t\terr = -ENOMEM;\n\t\tgoto err_parman_prios_alloc;\n\t}\n\tmr_tcam_region->parman_prios = parman_prios;\n\n\tfor (i = 0; i < MLXSW_SP_MR_ROUTE_PRIO_MAX + 1; i++)\n\t\tparman_prio_init(mr_tcam_region->parman,\n\t\t\t\t &mr_tcam_region->parman_prios[i], i);\n\treturn 0;\n\nerr_parman_prios_alloc:\n\tparman_destroy(parman);\nerr_parman_create:\n\tmlxsw_sp1_mr_tcam_region_free(mr_tcam_region);\n\treturn err;\n}\n\nstatic void\nmlxsw_sp1_mr_tcam_region_fini(struct mlxsw_sp1_mr_tcam_region *mr_tcam_region)\n{\n\tint i;\n\n\tfor (i = 0; i < MLXSW_SP_MR_ROUTE_PRIO_MAX + 1; i++)\n\t\tparman_prio_fini(&mr_tcam_region->parman_prios[i]);\n\tkfree(mr_tcam_region->parman_prios);\n\tparman_destroy(mr_tcam_region->parman);\n\tmlxsw_sp1_mr_tcam_region_free(mr_tcam_region);\n}\n\nstatic int mlxsw_sp1_mr_tcam_init(struct mlxsw_sp *mlxsw_sp, void *priv)\n{\n\tstruct mlxsw_sp1_mr_tcam *mr_tcam = priv;\n\tstruct mlxsw_sp1_mr_tcam_region *region = &mr_tcam->tcam_regions[0];\n\tu32 rtar_key;\n\tint err;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, ACL_MAX_TCAM_RULES))\n\t\treturn -EIO;\n\n\trtar_key = MLXSW_REG_RTAR_KEY_TYPE_IPV4_MULTICAST;\n\terr = mlxsw_sp1_mr_tcam_region_init(mlxsw_sp,\n\t\t\t\t\t    &region[MLXSW_SP_L3_PROTO_IPV4],\n\t\t\t\t\t    rtar_key);\n\tif (err)\n\t\treturn err;\n\n\trtar_key = MLXSW_REG_RTAR_KEY_TYPE_IPV6_MULTICAST;\n\terr = mlxsw_sp1_mr_tcam_region_init(mlxsw_sp,\n\t\t\t\t\t    &region[MLXSW_SP_L3_PROTO_IPV6],\n\t\t\t\t\t    rtar_key);\n\tif (err)\n\t\tgoto err_ipv6_region_init;\n\n\treturn 0;\n\nerr_ipv6_region_init:\n\tmlxsw_sp1_mr_tcam_region_fini(&region[MLXSW_SP_L3_PROTO_IPV4]);\n\treturn err;\n}\n\nstatic void mlxsw_sp1_mr_tcam_fini(void *priv)\n{\n\tstruct mlxsw_sp1_mr_tcam *mr_tcam = priv;\n\tstruct mlxsw_sp1_mr_tcam_region *region = &mr_tcam->tcam_regions[0];\n\n\tmlxsw_sp1_mr_tcam_region_fini(&region[MLXSW_SP_L3_PROTO_IPV6]);\n\tmlxsw_sp1_mr_tcam_region_fini(&region[MLXSW_SP_L3_PROTO_IPV4]);\n}\n\nconst struct mlxsw_sp_mr_tcam_ops mlxsw_sp1_mr_tcam_ops = {\n\t.priv_size = sizeof(struct mlxsw_sp1_mr_tcam),\n\t.init = mlxsw_sp1_mr_tcam_init,\n\t.fini = mlxsw_sp1_mr_tcam_fini,\n\t.route_priv_size = sizeof(struct mlxsw_sp1_mr_tcam_route),\n\t.route_create = mlxsw_sp1_mr_tcam_route_create,\n\t.route_destroy = mlxsw_sp1_mr_tcam_route_destroy,\n\t.route_update = mlxsw_sp1_mr_tcam_route_update,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}