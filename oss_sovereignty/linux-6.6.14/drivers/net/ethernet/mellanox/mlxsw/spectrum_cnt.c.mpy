{
  "module_name": "spectrum_cnt.c",
  "hash_id": "c6e5b2981caa97ad6bbec7d0fbaa689ef5ca748cba4f0118e5994a8295ffc796",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_cnt.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/spinlock.h>\n\n#include \"spectrum_cnt.h\"\n\nstruct mlxsw_sp_counter_sub_pool {\n\tu64 size;\n\tunsigned int base_index;\n\tenum mlxsw_res_id entry_size_res_id;\n\tconst char *resource_name;  \n\tu64 resource_id;  \n\tunsigned int entry_size;\n\tunsigned int bank_count;\n\tatomic_t active_entries_count;\n};\n\nstruct mlxsw_sp_counter_pool {\n\tu64 pool_size;\n\tunsigned long *usage;  \n\tspinlock_t counter_pool_lock;  \n\tatomic_t active_entries_count;\n\tunsigned int sub_pools_count;\n\tstruct mlxsw_sp_counter_sub_pool sub_pools[];\n};\n\nstatic const struct mlxsw_sp_counter_sub_pool mlxsw_sp_counter_sub_pools[] = {\n\t[MLXSW_SP_COUNTER_SUB_POOL_FLOW] = {\n\t\t.entry_size_res_id = MLXSW_RES_ID_COUNTER_SIZE_PACKETS_BYTES,\n\t\t.resource_name = MLXSW_SP_RESOURCE_NAME_COUNTERS_FLOW,\n\t\t.resource_id = MLXSW_SP_RESOURCE_COUNTERS_FLOW,\n\t\t.bank_count = 6,\n\t},\n\t[MLXSW_SP_COUNTER_SUB_POOL_RIF] = {\n\t\t.entry_size_res_id = MLXSW_RES_ID_COUNTER_SIZE_ROUTER_BASIC,\n\t\t.resource_name = MLXSW_SP_RESOURCE_NAME_COUNTERS_RIF,\n\t\t.resource_id = MLXSW_SP_RESOURCE_COUNTERS_RIF,\n\t\t.bank_count = 2,\n\t}\n};\n\nstatic u64 mlxsw_sp_counter_sub_pool_occ_get(void *priv)\n{\n\tconst struct mlxsw_sp_counter_sub_pool *sub_pool = priv;\n\n\treturn atomic_read(&sub_pool->active_entries_count);\n}\n\nstatic int mlxsw_sp_counter_sub_pools_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_counter_pool *pool = mlxsw_sp->counter_pool;\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tstruct mlxsw_sp_counter_sub_pool *sub_pool;\n\tunsigned int base_index = 0;\n\tenum mlxsw_res_id res_id;\n\tint err;\n\tint i;\n\n\tfor (i = 0; i < pool->sub_pools_count; i++) {\n\t\tsub_pool = &pool->sub_pools[i];\n\t\tres_id = sub_pool->entry_size_res_id;\n\n\t\tif (!mlxsw_core_res_valid(mlxsw_sp->core, res_id))\n\t\t\treturn -EIO;\n\t\tsub_pool->entry_size = mlxsw_core_res_get(mlxsw_sp->core,\n\t\t\t\t\t\t\t  res_id);\n\t\terr = devl_resource_size_get(devlink,\n\t\t\t\t\t     sub_pool->resource_id,\n\t\t\t\t\t     &sub_pool->size);\n\t\tif (err)\n\t\t\tgoto err_resource_size_get;\n\n\t\tdevl_resource_occ_get_register(devlink,\n\t\t\t\t\t       sub_pool->resource_id,\n\t\t\t\t\t       mlxsw_sp_counter_sub_pool_occ_get,\n\t\t\t\t\t       sub_pool);\n\n\t\tsub_pool->base_index = base_index;\n\t\tbase_index += sub_pool->size;\n\t\tatomic_set(&sub_pool->active_entries_count, 0);\n\t}\n\treturn 0;\n\nerr_resource_size_get:\n\tfor (i--; i >= 0; i--) {\n\t\tsub_pool = &pool->sub_pools[i];\n\n\t\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t\t sub_pool->resource_id);\n\t}\n\treturn err;\n}\n\nstatic void mlxsw_sp_counter_sub_pools_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_counter_pool *pool = mlxsw_sp->counter_pool;\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tstruct mlxsw_sp_counter_sub_pool *sub_pool;\n\tint i;\n\n\tfor (i = 0; i < pool->sub_pools_count; i++) {\n\t\tsub_pool = &pool->sub_pools[i];\n\n\t\tWARN_ON(atomic_read(&sub_pool->active_entries_count));\n\t\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t\t sub_pool->resource_id);\n\t}\n}\n\nstatic u64 mlxsw_sp_counter_pool_occ_get(void *priv)\n{\n\tconst struct mlxsw_sp_counter_pool *pool = priv;\n\n\treturn atomic_read(&pool->active_entries_count);\n}\n\nint mlxsw_sp_counter_pool_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tunsigned int sub_pools_count = ARRAY_SIZE(mlxsw_sp_counter_sub_pools);\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tstruct mlxsw_sp_counter_pool *pool;\n\tint err;\n\n\tpool = kzalloc(struct_size(pool, sub_pools, sub_pools_count),\n\t\t       GFP_KERNEL);\n\tif (!pool)\n\t\treturn -ENOMEM;\n\tmlxsw_sp->counter_pool = pool;\n\tpool->sub_pools_count = sub_pools_count;\n\tmemcpy(pool->sub_pools, mlxsw_sp_counter_sub_pools,\n\t       flex_array_size(pool, sub_pools, pool->sub_pools_count));\n\tspin_lock_init(&pool->counter_pool_lock);\n\tatomic_set(&pool->active_entries_count, 0);\n\n\terr = devl_resource_size_get(devlink, MLXSW_SP_RESOURCE_COUNTERS,\n\t\t\t\t     &pool->pool_size);\n\tif (err)\n\t\tgoto err_pool_resource_size_get;\n\tdevl_resource_occ_get_register(devlink, MLXSW_SP_RESOURCE_COUNTERS,\n\t\t\t\t       mlxsw_sp_counter_pool_occ_get, pool);\n\n\tpool->usage = bitmap_zalloc(pool->pool_size, GFP_KERNEL);\n\tif (!pool->usage) {\n\t\terr = -ENOMEM;\n\t\tgoto err_usage_alloc;\n\t}\n\n\terr = mlxsw_sp_counter_sub_pools_init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_sub_pools_init;\n\n\treturn 0;\n\nerr_sub_pools_init:\n\tbitmap_free(pool->usage);\nerr_usage_alloc:\n\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t MLXSW_SP_RESOURCE_COUNTERS);\nerr_pool_resource_size_get:\n\tkfree(pool);\n\treturn err;\n}\n\nvoid mlxsw_sp_counter_pool_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct mlxsw_sp_counter_pool *pool = mlxsw_sp->counter_pool;\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\n\tmlxsw_sp_counter_sub_pools_fini(mlxsw_sp);\n\tWARN_ON(find_first_bit(pool->usage, pool->pool_size) !=\n\t\t\t       pool->pool_size);\n\tWARN_ON(atomic_read(&pool->active_entries_count));\n\tbitmap_free(pool->usage);\n\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t MLXSW_SP_RESOURCE_COUNTERS);\n\tkfree(pool);\n}\n\nint mlxsw_sp_counter_alloc(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   enum mlxsw_sp_counter_sub_pool_id sub_pool_id,\n\t\t\t   unsigned int *p_counter_index)\n{\n\tstruct mlxsw_sp_counter_pool *pool = mlxsw_sp->counter_pool;\n\tstruct mlxsw_sp_counter_sub_pool *sub_pool;\n\tunsigned int entry_index;\n\tunsigned int stop_index;\n\tint i, err;\n\n\tsub_pool = &pool->sub_pools[sub_pool_id];\n\tstop_index = sub_pool->base_index + sub_pool->size;\n\tentry_index = sub_pool->base_index;\n\n\tspin_lock(&pool->counter_pool_lock);\n\tentry_index = find_next_zero_bit(pool->usage, stop_index, entry_index);\n\tif (entry_index == stop_index) {\n\t\terr = -ENOBUFS;\n\t\tgoto err_alloc;\n\t}\n\t \n\tif (entry_index + sub_pool->entry_size > stop_index) {\n\t\terr = -ENOBUFS;\n\t\tgoto err_alloc;\n\t}\n\tfor (i = 0; i < sub_pool->entry_size; i++)\n\t\t__set_bit(entry_index + i, pool->usage);\n\tspin_unlock(&pool->counter_pool_lock);\n\n\t*p_counter_index = entry_index;\n\tatomic_add(sub_pool->entry_size, &sub_pool->active_entries_count);\n\tatomic_add(sub_pool->entry_size, &pool->active_entries_count);\n\treturn 0;\n\nerr_alloc:\n\tspin_unlock(&pool->counter_pool_lock);\n\treturn err;\n}\n\nvoid mlxsw_sp_counter_free(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   enum mlxsw_sp_counter_sub_pool_id sub_pool_id,\n\t\t\t   unsigned int counter_index)\n{\n\tstruct mlxsw_sp_counter_pool *pool = mlxsw_sp->counter_pool;\n\tstruct mlxsw_sp_counter_sub_pool *sub_pool;\n\tint i;\n\n\tif (WARN_ON(counter_index >= pool->pool_size))\n\t\treturn;\n\tsub_pool = &pool->sub_pools[sub_pool_id];\n\tspin_lock(&pool->counter_pool_lock);\n\tfor (i = 0; i < sub_pool->entry_size; i++)\n\t\t__clear_bit(counter_index + i, pool->usage);\n\tspin_unlock(&pool->counter_pool_lock);\n\tatomic_sub(sub_pool->entry_size, &sub_pool->active_entries_count);\n\tatomic_sub(sub_pool->entry_size, &pool->active_entries_count);\n}\n\nint mlxsw_sp_counter_resources_register(struct mlxsw_core *mlxsw_core)\n{\n\tstatic struct devlink_resource_size_params size_params;\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_core);\n\tconst struct mlxsw_sp_counter_sub_pool *sub_pool;\n\tunsigned int total_bank_config;\n\tu64 sub_pool_size;\n\tu64 base_index;\n\tu64 pool_size;\n\tu64 bank_size;\n\tint err;\n\tint i;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_core, COUNTER_POOL_SIZE) ||\n\t    !MLXSW_CORE_RES_VALID(mlxsw_core, COUNTER_BANK_SIZE))\n\t\treturn -EIO;\n\n\tpool_size = MLXSW_CORE_RES_GET(mlxsw_core, COUNTER_POOL_SIZE);\n\tbank_size = MLXSW_CORE_RES_GET(mlxsw_core, COUNTER_BANK_SIZE);\n\n\tdevlink_resource_size_params_init(&size_params, pool_size,\n\t\t\t\t\t  pool_size, bank_size,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\terr = devl_resource_register(devlink,\n\t\t\t\t     MLXSW_SP_RESOURCE_NAME_COUNTERS,\n\t\t\t\t     pool_size,\n\t\t\t\t     MLXSW_SP_RESOURCE_COUNTERS,\n\t\t\t\t     DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t     &size_params);\n\tif (err)\n\t\treturn err;\n\n\t \n\ttotal_bank_config = 0;\n\tbase_index = 0;\n\tfor (i = 0; i < ARRAY_SIZE(mlxsw_sp_counter_sub_pools); i++) {\n\t\tsub_pool = &mlxsw_sp_counter_sub_pools[i];\n\t\tsub_pool_size = sub_pool->bank_count * bank_size;\n\t\t \n\t\tif (base_index + sub_pool_size > pool_size)\n\t\t\tsub_pool_size = pool_size - base_index;\n\t\tbase_index += sub_pool_size;\n\n\t\tdevlink_resource_size_params_init(&size_params, sub_pool_size,\n\t\t\t\t\t\t  sub_pool_size, bank_size,\n\t\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\t\terr = devl_resource_register(devlink,\n\t\t\t\t\t     sub_pool->resource_name,\n\t\t\t\t\t     sub_pool_size,\n\t\t\t\t\t     sub_pool->resource_id,\n\t\t\t\t\t     MLXSW_SP_RESOURCE_COUNTERS,\n\t\t\t\t\t     &size_params);\n\t\tif (err)\n\t\t\treturn err;\n\t\ttotal_bank_config += sub_pool->bank_count;\n\t}\n\n\t \n\tif (WARN_ON(total_bank_config > div64_u64(pool_size, bank_size) + 1))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}