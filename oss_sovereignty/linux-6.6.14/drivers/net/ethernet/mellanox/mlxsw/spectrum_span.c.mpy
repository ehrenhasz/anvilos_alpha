{
  "module_name": "spectrum_span.c",
  "hash_id": "76f10d869bfdf66b7a4e848edc8ac01823b2ab89a3fc3274b7b8ecaf7d32dbed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/spectrum_span.c",
  "human_readable_source": "\n \n\n#include <linux/if_bridge.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/rtnetlink.h>\n#include <linux/workqueue.h>\n#include <net/arp.h>\n#include <net/gre.h>\n#include <net/lag.h>\n#include <net/ndisc.h>\n#include <net/ip6_tunnel.h>\n\n#include \"spectrum.h\"\n#include \"spectrum_ipip.h\"\n#include \"spectrum_span.h\"\n#include \"spectrum_switchdev.h\"\n\nstruct mlxsw_sp_span {\n\tstruct work_struct work;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tconst struct mlxsw_sp_span_trigger_ops **span_trigger_ops_arr;\n\tconst struct mlxsw_sp_span_entry_ops **span_entry_ops_arr;\n\tsize_t span_entry_ops_arr_size;\n\tstruct list_head analyzed_ports_list;\n\tstruct mutex analyzed_ports_lock;  \n\tstruct list_head trigger_entries_list;\n\tu16 policer_id_base;\n\trefcount_t policer_id_base_ref_count;\n\tatomic_t active_entries_count;\n\tint entries_count;\n\tstruct mlxsw_sp_span_entry entries[];\n};\n\nstruct mlxsw_sp_span_analyzed_port {\n\tstruct list_head list;  \n\trefcount_t ref_count;\n\tu16 local_port;\n\tbool ingress;\n};\n\nstruct mlxsw_sp_span_trigger_entry {\n\tstruct list_head list;  \n\tstruct mlxsw_sp_span *span;\n\tconst struct mlxsw_sp_span_trigger_ops *ops;\n\trefcount_t ref_count;\n\tu16 local_port;\n\tenum mlxsw_sp_span_trigger trigger;\n\tstruct mlxsw_sp_span_trigger_parms parms;\n};\n\nenum mlxsw_sp_span_trigger_type {\n\tMLXSW_SP_SPAN_TRIGGER_TYPE_PORT,\n\tMLXSW_SP_SPAN_TRIGGER_TYPE_GLOBAL,\n};\n\nstruct mlxsw_sp_span_trigger_ops {\n\tint (*bind)(struct mlxsw_sp_span_trigger_entry *trigger_entry);\n\tvoid (*unbind)(struct mlxsw_sp_span_trigger_entry *trigger_entry);\n\tbool (*matches)(struct mlxsw_sp_span_trigger_entry *trigger_entry,\n\t\t\tenum mlxsw_sp_span_trigger trigger,\n\t\t\tstruct mlxsw_sp_port *mlxsw_sp_port);\n\tint (*enable)(struct mlxsw_sp_span_trigger_entry *trigger_entry,\n\t\t      struct mlxsw_sp_port *mlxsw_sp_port, u8 tc);\n\tvoid (*disable)(struct mlxsw_sp_span_trigger_entry *trigger_entry,\n\t\t\tstruct mlxsw_sp_port *mlxsw_sp_port, u8 tc);\n};\n\nstatic void mlxsw_sp_span_respin_work(struct work_struct *work);\n\nstatic u64 mlxsw_sp_span_occ_get(void *priv)\n{\n\tconst struct mlxsw_sp *mlxsw_sp = priv;\n\n\treturn atomic_read(&mlxsw_sp->span->active_entries_count);\n}\n\nint mlxsw_sp_span_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\tstruct mlxsw_sp_span *span;\n\tint i, entries_count, err;\n\n\tif (!MLXSW_CORE_RES_VALID(mlxsw_sp->core, MAX_SPAN))\n\t\treturn -EIO;\n\n\tentries_count = MLXSW_CORE_RES_GET(mlxsw_sp->core, MAX_SPAN);\n\tspan = kzalloc(struct_size(span, entries, entries_count), GFP_KERNEL);\n\tif (!span)\n\t\treturn -ENOMEM;\n\trefcount_set(&span->policer_id_base_ref_count, 0);\n\tspan->entries_count = entries_count;\n\tatomic_set(&span->active_entries_count, 0);\n\tmutex_init(&span->analyzed_ports_lock);\n\tINIT_LIST_HEAD(&span->analyzed_ports_list);\n\tINIT_LIST_HEAD(&span->trigger_entries_list);\n\tspan->mlxsw_sp = mlxsw_sp;\n\tmlxsw_sp->span = span;\n\n\tfor (i = 0; i < mlxsw_sp->span->entries_count; i++)\n\t\tmlxsw_sp->span->entries[i].id = i;\n\n\terr = mlxsw_sp->span_ops->init(mlxsw_sp);\n\tif (err)\n\t\tgoto err_init;\n\n\tdevl_resource_occ_get_register(devlink, MLXSW_SP_RESOURCE_SPAN,\n\t\t\t\t       mlxsw_sp_span_occ_get, mlxsw_sp);\n\tINIT_WORK(&span->work, mlxsw_sp_span_respin_work);\n\n\treturn 0;\n\nerr_init:\n\tmutex_destroy(&mlxsw_sp->span->analyzed_ports_lock);\n\tkfree(mlxsw_sp->span);\n\treturn err;\n}\n\nvoid mlxsw_sp_span_fini(struct mlxsw_sp *mlxsw_sp)\n{\n\tstruct devlink *devlink = priv_to_devlink(mlxsw_sp->core);\n\n\tcancel_work_sync(&mlxsw_sp->span->work);\n\tdevl_resource_occ_get_unregister(devlink, MLXSW_SP_RESOURCE_SPAN);\n\n\tWARN_ON_ONCE(!list_empty(&mlxsw_sp->span->trigger_entries_list));\n\tWARN_ON_ONCE(!list_empty(&mlxsw_sp->span->analyzed_ports_list));\n\tmutex_destroy(&mlxsw_sp->span->analyzed_ports_lock);\n\tkfree(mlxsw_sp->span);\n}\n\nstatic bool mlxsw_sp1_span_cpu_can_handle(const struct net_device *dev)\n{\n\treturn !dev;\n}\n\nstatic int mlxsw_sp1_span_entry_cpu_parms(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  const struct net_device *to_dev,\n\t\t\t\t\t  struct mlxsw_sp_span_parms *sparmsp)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nmlxsw_sp1_span_entry_cpu_configure(struct mlxsw_sp_span_entry *span_entry,\n\t\t\t\t   struct mlxsw_sp_span_parms sparms)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void\nmlxsw_sp1_span_entry_cpu_deconfigure(struct mlxsw_sp_span_entry *span_entry)\n{\n}\n\nstatic const\nstruct mlxsw_sp_span_entry_ops mlxsw_sp1_span_entry_ops_cpu = {\n\t.is_static = true,\n\t.can_handle = mlxsw_sp1_span_cpu_can_handle,\n\t.parms_set = mlxsw_sp1_span_entry_cpu_parms,\n\t.configure = mlxsw_sp1_span_entry_cpu_configure,\n\t.deconfigure = mlxsw_sp1_span_entry_cpu_deconfigure,\n};\n\nstatic int\nmlxsw_sp_span_entry_phys_parms(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       const struct net_device *to_dev,\n\t\t\t       struct mlxsw_sp_span_parms *sparmsp)\n{\n\tsparmsp->dest_port = netdev_priv(to_dev);\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_span_entry_phys_configure(struct mlxsw_sp_span_entry *span_entry,\n\t\t\t\t   struct mlxsw_sp_span_parms sparms)\n{\n\tstruct mlxsw_sp_port *dest_port = sparms.dest_port;\n\tstruct mlxsw_sp *mlxsw_sp = dest_port->mlxsw_sp;\n\tu16 local_port = dest_port->local_port;\n\tchar mpat_pl[MLXSW_REG_MPAT_LEN];\n\tint pa_id = span_entry->id;\n\n\t \n\tmlxsw_reg_mpat_pack(mpat_pl, pa_id, local_port, true,\n\t\t\t    MLXSW_REG_MPAT_SPAN_TYPE_LOCAL_ETH);\n\tmlxsw_reg_mpat_session_id_set(mpat_pl, sparms.session_id);\n\tmlxsw_reg_mpat_pide_set(mpat_pl, sparms.policer_enable);\n\tmlxsw_reg_mpat_pid_set(mpat_pl, sparms.policer_id);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mpat), mpat_pl);\n}\n\nstatic void\nmlxsw_sp_span_entry_deconfigure_common(struct mlxsw_sp_span_entry *span_entry,\n\t\t\t\t       enum mlxsw_reg_mpat_span_type span_type)\n{\n\tstruct mlxsw_sp_port *dest_port = span_entry->parms.dest_port;\n\tstruct mlxsw_sp *mlxsw_sp = dest_port->mlxsw_sp;\n\tu16 local_port = dest_port->local_port;\n\tchar mpat_pl[MLXSW_REG_MPAT_LEN];\n\tint pa_id = span_entry->id;\n\n\tmlxsw_reg_mpat_pack(mpat_pl, pa_id, local_port, false, span_type);\n\tmlxsw_reg_mpat_session_id_set(mpat_pl, span_entry->parms.session_id);\n\tmlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mpat), mpat_pl);\n}\n\nstatic void\nmlxsw_sp_span_entry_phys_deconfigure(struct mlxsw_sp_span_entry *span_entry)\n{\n\tmlxsw_sp_span_entry_deconfigure_common(span_entry,\n\t\t\t\t\t    MLXSW_REG_MPAT_SPAN_TYPE_LOCAL_ETH);\n}\n\nstatic const\nstruct mlxsw_sp_span_entry_ops mlxsw_sp_span_entry_ops_phys = {\n\t.is_static = true,\n\t.can_handle = mlxsw_sp_port_dev_check,\n\t.parms_set = mlxsw_sp_span_entry_phys_parms,\n\t.configure = mlxsw_sp_span_entry_phys_configure,\n\t.deconfigure = mlxsw_sp_span_entry_phys_deconfigure,\n};\n\nstatic int mlxsw_sp_span_dmac(struct neigh_table *tbl,\n\t\t\t      const void *pkey,\n\t\t\t      struct net_device *dev,\n\t\t\t      unsigned char dmac[ETH_ALEN])\n{\n\tstruct neighbour *neigh = neigh_lookup(tbl, pkey, dev);\n\tint err = 0;\n\n\tif (!neigh) {\n\t\tneigh = neigh_create(tbl, pkey, dev);\n\t\tif (IS_ERR(neigh))\n\t\t\treturn PTR_ERR(neigh);\n\t}\n\n\tneigh_event_send(neigh, NULL);\n\n\tread_lock_bh(&neigh->lock);\n\tif ((neigh->nud_state & NUD_VALID) && !neigh->dead)\n\t\tmemcpy(dmac, neigh->ha, ETH_ALEN);\n\telse\n\t\terr = -ENOENT;\n\tread_unlock_bh(&neigh->lock);\n\n\tneigh_release(neigh);\n\treturn err;\n}\n\nstatic int\nmlxsw_sp_span_entry_unoffloadable(struct mlxsw_sp_span_parms *sparmsp)\n{\n\tsparmsp->dest_port = NULL;\n\treturn 0;\n}\n\nstatic struct net_device *\nmlxsw_sp_span_entry_bridge_8021q(const struct net_device *br_dev,\n\t\t\t\t unsigned char *dmac,\n\t\t\t\t u16 *p_vid)\n{\n\tstruct bridge_vlan_info vinfo;\n\tstruct net_device *edev;\n\tu16 vid = *p_vid;\n\n\tif (!vid && WARN_ON(br_vlan_get_pvid(br_dev, &vid)))\n\t\treturn NULL;\n\tif (!vid || br_vlan_get_info(br_dev, vid, &vinfo) ||\n\t    !(vinfo.flags & BRIDGE_VLAN_INFO_BRENTRY))\n\t\treturn NULL;\n\n\tedev = br_fdb_find_port(br_dev, dmac, vid);\n\tif (!edev)\n\t\treturn NULL;\n\n\tif (br_vlan_get_info(edev, vid, &vinfo))\n\t\treturn NULL;\n\tif (vinfo.flags & BRIDGE_VLAN_INFO_UNTAGGED)\n\t\t*p_vid = 0;\n\telse\n\t\t*p_vid = vid;\n\treturn edev;\n}\n\nstatic struct net_device *\nmlxsw_sp_span_entry_bridge_8021d(const struct net_device *br_dev,\n\t\t\t\t unsigned char *dmac)\n{\n\treturn br_fdb_find_port(br_dev, dmac, 0);\n}\n\nstatic struct net_device *\nmlxsw_sp_span_entry_bridge(const struct net_device *br_dev,\n\t\t\t   unsigned char dmac[ETH_ALEN],\n\t\t\t   u16 *p_vid)\n{\n\tstruct mlxsw_sp_bridge_port *bridge_port;\n\tenum mlxsw_reg_spms_state spms_state;\n\tstruct net_device *dev = NULL;\n\tstruct mlxsw_sp_port *port;\n\tu8 stp_state;\n\n\tif (br_vlan_enabled(br_dev))\n\t\tdev = mlxsw_sp_span_entry_bridge_8021q(br_dev, dmac, p_vid);\n\telse if (!*p_vid)\n\t\tdev = mlxsw_sp_span_entry_bridge_8021d(br_dev, dmac);\n\tif (!dev)\n\t\treturn NULL;\n\n\tport = mlxsw_sp_port_dev_lower_find(dev);\n\tif (!port)\n\t\treturn NULL;\n\n\tbridge_port = mlxsw_sp_bridge_port_find(port->mlxsw_sp->bridge, dev);\n\tif (!bridge_port)\n\t\treturn NULL;\n\n\tstp_state = mlxsw_sp_bridge_port_stp_state(bridge_port);\n\tspms_state = mlxsw_sp_stp_spms_state(stp_state);\n\tif (spms_state != MLXSW_REG_SPMS_STATE_FORWARDING)\n\t\treturn NULL;\n\n\treturn dev;\n}\n\nstatic struct net_device *\nmlxsw_sp_span_entry_vlan(const struct net_device *vlan_dev,\n\t\t\t u16 *p_vid)\n{\n\t*p_vid = vlan_dev_vlan_id(vlan_dev);\n\treturn vlan_dev_real_dev(vlan_dev);\n}\n\nstatic struct net_device *\nmlxsw_sp_span_entry_lag(struct net_device *lag_dev)\n{\n\tstruct net_device *dev;\n\tstruct list_head *iter;\n\n\tnetdev_for_each_lower_dev(lag_dev, dev, iter)\n\t\tif (netif_carrier_ok(dev) &&\n\t\t    net_lag_port_dev_txable(dev) &&\n\t\t    mlxsw_sp_port_dev_check(dev))\n\t\t\treturn dev;\n\n\treturn NULL;\n}\n\nstatic __maybe_unused int\nmlxsw_sp_span_entry_tunnel_parms_common(struct net_device *edev,\n\t\t\t\t\tunion mlxsw_sp_l3addr saddr,\n\t\t\t\t\tunion mlxsw_sp_l3addr daddr,\n\t\t\t\t\tunion mlxsw_sp_l3addr gw,\n\t\t\t\t\t__u8 ttl,\n\t\t\t\t\tstruct neigh_table *tbl,\n\t\t\t\t\tstruct mlxsw_sp_span_parms *sparmsp)\n{\n\tunsigned char dmac[ETH_ALEN];\n\tu16 vid = 0;\n\n\tif (mlxsw_sp_l3addr_is_zero(gw))\n\t\tgw = daddr;\n\n\tif (!edev || mlxsw_sp_span_dmac(tbl, &gw, edev, dmac))\n\t\tgoto unoffloadable;\n\n\tif (is_vlan_dev(edev))\n\t\tedev = mlxsw_sp_span_entry_vlan(edev, &vid);\n\n\tif (netif_is_bridge_master(edev)) {\n\t\tedev = mlxsw_sp_span_entry_bridge(edev, dmac, &vid);\n\t\tif (!edev)\n\t\t\tgoto unoffloadable;\n\t}\n\n\tif (is_vlan_dev(edev)) {\n\t\tif (vid || !(edev->flags & IFF_UP))\n\t\t\tgoto unoffloadable;\n\t\tedev = mlxsw_sp_span_entry_vlan(edev, &vid);\n\t}\n\n\tif (netif_is_lag_master(edev)) {\n\t\tif (!(edev->flags & IFF_UP))\n\t\t\tgoto unoffloadable;\n\t\tedev = mlxsw_sp_span_entry_lag(edev);\n\t\tif (!edev)\n\t\t\tgoto unoffloadable;\n\t}\n\n\tif (!mlxsw_sp_port_dev_check(edev))\n\t\tgoto unoffloadable;\n\n\tsparmsp->dest_port = netdev_priv(edev);\n\tsparmsp->ttl = ttl;\n\tmemcpy(sparmsp->dmac, dmac, ETH_ALEN);\n\tmemcpy(sparmsp->smac, edev->dev_addr, ETH_ALEN);\n\tsparmsp->saddr = saddr;\n\tsparmsp->daddr = daddr;\n\tsparmsp->vid = vid;\n\treturn 0;\n\nunoffloadable:\n\treturn mlxsw_sp_span_entry_unoffloadable(sparmsp);\n}\n\n#if IS_ENABLED(CONFIG_NET_IPGRE)\nstatic struct net_device *\nmlxsw_sp_span_gretap4_route(const struct net_device *to_dev,\n\t\t\t    __be32 *saddrp, __be32 *daddrp)\n{\n\tstruct ip_tunnel *tun = netdev_priv(to_dev);\n\tstruct net_device *dev = NULL;\n\tstruct ip_tunnel_parm parms;\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\n\t \n\tASSERT_RTNL();\n\n\tparms = mlxsw_sp_ipip_netdev_parms4(to_dev);\n\tip_tunnel_init_flow(&fl4, parms.iph.protocol, *daddrp, *saddrp,\n\t\t\t    0, 0, dev_net(to_dev), parms.link, tun->fwmark, 0,\n\t\t\t    0);\n\n\trt = ip_route_output_key(tun->net, &fl4);\n\tif (IS_ERR(rt))\n\t\treturn NULL;\n\n\tif (rt->rt_type != RTN_UNICAST)\n\t\tgoto out;\n\n\tdev = rt->dst.dev;\n\t*saddrp = fl4.saddr;\n\tif (rt->rt_gw_family == AF_INET)\n\t\t*daddrp = rt->rt_gw4;\n\t \n\telse if (rt->rt_gw_family == AF_INET6)\n\t\tdev = NULL;\n\nout:\n\tip_rt_put(rt);\n\treturn dev;\n}\n\nstatic int\nmlxsw_sp_span_entry_gretap4_parms(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  const struct net_device *to_dev,\n\t\t\t\t  struct mlxsw_sp_span_parms *sparmsp)\n{\n\tstruct ip_tunnel_parm tparm = mlxsw_sp_ipip_netdev_parms4(to_dev);\n\tunion mlxsw_sp_l3addr saddr = { .addr4 = tparm.iph.saddr };\n\tunion mlxsw_sp_l3addr daddr = { .addr4 = tparm.iph.daddr };\n\tbool inherit_tos = tparm.iph.tos & 0x1;\n\tbool inherit_ttl = !tparm.iph.ttl;\n\tunion mlxsw_sp_l3addr gw = daddr;\n\tstruct net_device *l3edev;\n\n\tif (!(to_dev->flags & IFF_UP) ||\n\t     \n\t    tparm.i_flags || tparm.o_flags ||\n\t     \n\t    inherit_ttl || !inherit_tos ||\n\t     \n\t    mlxsw_sp_l3addr_is_zero(daddr))\n\t\treturn mlxsw_sp_span_entry_unoffloadable(sparmsp);\n\n\tl3edev = mlxsw_sp_span_gretap4_route(to_dev, &saddr.addr4, &gw.addr4);\n\treturn mlxsw_sp_span_entry_tunnel_parms_common(l3edev, saddr, daddr, gw,\n\t\t\t\t\t\t       tparm.iph.ttl,\n\t\t\t\t\t\t       &arp_tbl, sparmsp);\n}\n\nstatic int\nmlxsw_sp_span_entry_gretap4_configure(struct mlxsw_sp_span_entry *span_entry,\n\t\t\t\t      struct mlxsw_sp_span_parms sparms)\n{\n\tstruct mlxsw_sp_port *dest_port = sparms.dest_port;\n\tstruct mlxsw_sp *mlxsw_sp = dest_port->mlxsw_sp;\n\tu16 local_port = dest_port->local_port;\n\tchar mpat_pl[MLXSW_REG_MPAT_LEN];\n\tint pa_id = span_entry->id;\n\n\t \n\tmlxsw_reg_mpat_pack(mpat_pl, pa_id, local_port, true,\n\t\t\t    MLXSW_REG_MPAT_SPAN_TYPE_REMOTE_ETH_L3);\n\tmlxsw_reg_mpat_pide_set(mpat_pl, sparms.policer_enable);\n\tmlxsw_reg_mpat_pid_set(mpat_pl, sparms.policer_id);\n\tmlxsw_reg_mpat_eth_rspan_pack(mpat_pl, sparms.vid);\n\tmlxsw_reg_mpat_eth_rspan_l2_pack(mpat_pl,\n\t\t\t\t    MLXSW_REG_MPAT_ETH_RSPAN_VERSION_NO_HEADER,\n\t\t\t\t    sparms.dmac, !!sparms.vid);\n\tmlxsw_reg_mpat_eth_rspan_l3_ipv4_pack(mpat_pl,\n\t\t\t\t\t      sparms.ttl, sparms.smac,\n\t\t\t\t\t      be32_to_cpu(sparms.saddr.addr4),\n\t\t\t\t\t      be32_to_cpu(sparms.daddr.addr4));\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mpat), mpat_pl);\n}\n\nstatic void\nmlxsw_sp_span_entry_gretap4_deconfigure(struct mlxsw_sp_span_entry *span_entry)\n{\n\tmlxsw_sp_span_entry_deconfigure_common(span_entry,\n\t\t\t\t\tMLXSW_REG_MPAT_SPAN_TYPE_REMOTE_ETH_L3);\n}\n\nstatic const struct mlxsw_sp_span_entry_ops mlxsw_sp_span_entry_ops_gretap4 = {\n\t.can_handle = netif_is_gretap,\n\t.parms_set = mlxsw_sp_span_entry_gretap4_parms,\n\t.configure = mlxsw_sp_span_entry_gretap4_configure,\n\t.deconfigure = mlxsw_sp_span_entry_gretap4_deconfigure,\n};\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6_GRE)\nstatic struct net_device *\nmlxsw_sp_span_gretap6_route(const struct net_device *to_dev,\n\t\t\t    struct in6_addr *saddrp,\n\t\t\t    struct in6_addr *daddrp)\n{\n\tstruct ip6_tnl *t = netdev_priv(to_dev);\n\tstruct flowi6 fl6 = t->fl.u.ip6;\n\tstruct net_device *dev = NULL;\n\tstruct dst_entry *dst;\n\tstruct rt6_info *rt6;\n\n\t \n\tASSERT_RTNL();\n\n\tfl6.flowi6_mark = t->parms.fwmark;\n\tif (!ip6_tnl_xmit_ctl(t, &fl6.saddr, &fl6.daddr))\n\t\treturn NULL;\n\n\tdst = ip6_route_output(t->net, NULL, &fl6);\n\tif (!dst || dst->error)\n\t\tgoto out;\n\n\trt6 = container_of(dst, struct rt6_info, dst);\n\n\tdev = dst->dev;\n\t*saddrp = fl6.saddr;\n\t*daddrp = rt6->rt6i_gateway;\n\nout:\n\tdst_release(dst);\n\treturn dev;\n}\n\nstatic int\nmlxsw_sp_span_entry_gretap6_parms(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  const struct net_device *to_dev,\n\t\t\t\t  struct mlxsw_sp_span_parms *sparmsp)\n{\n\tstruct __ip6_tnl_parm tparm = mlxsw_sp_ipip_netdev_parms6(to_dev);\n\tbool inherit_tos = tparm.flags & IP6_TNL_F_USE_ORIG_TCLASS;\n\tunion mlxsw_sp_l3addr saddr = { .addr6 = tparm.laddr };\n\tunion mlxsw_sp_l3addr daddr = { .addr6 = tparm.raddr };\n\tbool inherit_ttl = !tparm.hop_limit;\n\tunion mlxsw_sp_l3addr gw = daddr;\n\tstruct net_device *l3edev;\n\n\tif (!(to_dev->flags & IFF_UP) ||\n\t     \n\t    tparm.i_flags || tparm.o_flags ||\n\t     \n\t    inherit_ttl || !inherit_tos ||\n\t     \n\t    mlxsw_sp_l3addr_is_zero(daddr))\n\t\treturn mlxsw_sp_span_entry_unoffloadable(sparmsp);\n\n\tl3edev = mlxsw_sp_span_gretap6_route(to_dev, &saddr.addr6, &gw.addr6);\n\treturn mlxsw_sp_span_entry_tunnel_parms_common(l3edev, saddr, daddr, gw,\n\t\t\t\t\t\t       tparm.hop_limit,\n\t\t\t\t\t\t       &nd_tbl, sparmsp);\n}\n\nstatic int\nmlxsw_sp_span_entry_gretap6_configure(struct mlxsw_sp_span_entry *span_entry,\n\t\t\t\t      struct mlxsw_sp_span_parms sparms)\n{\n\tstruct mlxsw_sp_port *dest_port = sparms.dest_port;\n\tstruct mlxsw_sp *mlxsw_sp = dest_port->mlxsw_sp;\n\tu16 local_port = dest_port->local_port;\n\tchar mpat_pl[MLXSW_REG_MPAT_LEN];\n\tint pa_id = span_entry->id;\n\n\t \n\tmlxsw_reg_mpat_pack(mpat_pl, pa_id, local_port, true,\n\t\t\t    MLXSW_REG_MPAT_SPAN_TYPE_REMOTE_ETH_L3);\n\tmlxsw_reg_mpat_pide_set(mpat_pl, sparms.policer_enable);\n\tmlxsw_reg_mpat_pid_set(mpat_pl, sparms.policer_id);\n\tmlxsw_reg_mpat_eth_rspan_pack(mpat_pl, sparms.vid);\n\tmlxsw_reg_mpat_eth_rspan_l2_pack(mpat_pl,\n\t\t\t\t    MLXSW_REG_MPAT_ETH_RSPAN_VERSION_NO_HEADER,\n\t\t\t\t    sparms.dmac, !!sparms.vid);\n\tmlxsw_reg_mpat_eth_rspan_l3_ipv6_pack(mpat_pl, sparms.ttl, sparms.smac,\n\t\t\t\t\t      sparms.saddr.addr6,\n\t\t\t\t\t      sparms.daddr.addr6);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mpat), mpat_pl);\n}\n\nstatic void\nmlxsw_sp_span_entry_gretap6_deconfigure(struct mlxsw_sp_span_entry *span_entry)\n{\n\tmlxsw_sp_span_entry_deconfigure_common(span_entry,\n\t\t\t\t\tMLXSW_REG_MPAT_SPAN_TYPE_REMOTE_ETH_L3);\n}\n\nstatic const\nstruct mlxsw_sp_span_entry_ops mlxsw_sp_span_entry_ops_gretap6 = {\n\t.can_handle = netif_is_ip6gretap,\n\t.parms_set = mlxsw_sp_span_entry_gretap6_parms,\n\t.configure = mlxsw_sp_span_entry_gretap6_configure,\n\t.deconfigure = mlxsw_sp_span_entry_gretap6_deconfigure,\n};\n#endif\n\nstatic bool\nmlxsw_sp_span_vlan_can_handle(const struct net_device *dev)\n{\n\treturn is_vlan_dev(dev) &&\n\t       mlxsw_sp_port_dev_check(vlan_dev_real_dev(dev));\n}\n\nstatic int\nmlxsw_sp_span_entry_vlan_parms(struct mlxsw_sp *mlxsw_sp,\n\t\t\t       const struct net_device *to_dev,\n\t\t\t       struct mlxsw_sp_span_parms *sparmsp)\n{\n\tstruct net_device *real_dev;\n\tu16 vid;\n\n\tif (!(to_dev->flags & IFF_UP))\n\t\treturn mlxsw_sp_span_entry_unoffloadable(sparmsp);\n\n\treal_dev = mlxsw_sp_span_entry_vlan(to_dev, &vid);\n\tsparmsp->dest_port = netdev_priv(real_dev);\n\tsparmsp->vid = vid;\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp_span_entry_vlan_configure(struct mlxsw_sp_span_entry *span_entry,\n\t\t\t\t   struct mlxsw_sp_span_parms sparms)\n{\n\tstruct mlxsw_sp_port *dest_port = sparms.dest_port;\n\tstruct mlxsw_sp *mlxsw_sp = dest_port->mlxsw_sp;\n\tu16 local_port = dest_port->local_port;\n\tchar mpat_pl[MLXSW_REG_MPAT_LEN];\n\tint pa_id = span_entry->id;\n\n\tmlxsw_reg_mpat_pack(mpat_pl, pa_id, local_port, true,\n\t\t\t    MLXSW_REG_MPAT_SPAN_TYPE_REMOTE_ETH);\n\tmlxsw_reg_mpat_pide_set(mpat_pl, sparms.policer_enable);\n\tmlxsw_reg_mpat_pid_set(mpat_pl, sparms.policer_id);\n\tmlxsw_reg_mpat_eth_rspan_pack(mpat_pl, sparms.vid);\n\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mpat), mpat_pl);\n}\n\nstatic void\nmlxsw_sp_span_entry_vlan_deconfigure(struct mlxsw_sp_span_entry *span_entry)\n{\n\tmlxsw_sp_span_entry_deconfigure_common(span_entry,\n\t\t\t\t\tMLXSW_REG_MPAT_SPAN_TYPE_REMOTE_ETH);\n}\n\nstatic const\nstruct mlxsw_sp_span_entry_ops mlxsw_sp_span_entry_ops_vlan = {\n\t.can_handle = mlxsw_sp_span_vlan_can_handle,\n\t.parms_set = mlxsw_sp_span_entry_vlan_parms,\n\t.configure = mlxsw_sp_span_entry_vlan_configure,\n\t.deconfigure = mlxsw_sp_span_entry_vlan_deconfigure,\n};\n\nstatic const\nstruct mlxsw_sp_span_entry_ops *mlxsw_sp1_span_entry_ops_arr[] = {\n\t&mlxsw_sp1_span_entry_ops_cpu,\n\t&mlxsw_sp_span_entry_ops_phys,\n#if IS_ENABLED(CONFIG_NET_IPGRE)\n\t&mlxsw_sp_span_entry_ops_gretap4,\n#endif\n#if IS_ENABLED(CONFIG_IPV6_GRE)\n\t&mlxsw_sp_span_entry_ops_gretap6,\n#endif\n\t&mlxsw_sp_span_entry_ops_vlan,\n};\n\nstatic bool mlxsw_sp2_span_cpu_can_handle(const struct net_device *dev)\n{\n\treturn !dev;\n}\n\nstatic int mlxsw_sp2_span_entry_cpu_parms(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t  const struct net_device *to_dev,\n\t\t\t\t\t  struct mlxsw_sp_span_parms *sparmsp)\n{\n\tsparmsp->dest_port = mlxsw_sp->ports[MLXSW_PORT_CPU_PORT];\n\treturn 0;\n}\n\nstatic int\nmlxsw_sp2_span_entry_cpu_configure(struct mlxsw_sp_span_entry *span_entry,\n\t\t\t\t   struct mlxsw_sp_span_parms sparms)\n{\n\t \n\treturn mlxsw_sp_span_entry_phys_configure(span_entry, sparms);\n}\n\nstatic void\nmlxsw_sp2_span_entry_cpu_deconfigure(struct mlxsw_sp_span_entry *span_entry)\n{\n\tenum mlxsw_reg_mpat_span_type span_type;\n\n\tspan_type = MLXSW_REG_MPAT_SPAN_TYPE_LOCAL_ETH;\n\tmlxsw_sp_span_entry_deconfigure_common(span_entry, span_type);\n}\n\nstatic const\nstruct mlxsw_sp_span_entry_ops mlxsw_sp2_span_entry_ops_cpu = {\n\t.is_static = true,\n\t.can_handle = mlxsw_sp2_span_cpu_can_handle,\n\t.parms_set = mlxsw_sp2_span_entry_cpu_parms,\n\t.configure = mlxsw_sp2_span_entry_cpu_configure,\n\t.deconfigure = mlxsw_sp2_span_entry_cpu_deconfigure,\n};\n\nstatic const\nstruct mlxsw_sp_span_entry_ops *mlxsw_sp2_span_entry_ops_arr[] = {\n\t&mlxsw_sp2_span_entry_ops_cpu,\n\t&mlxsw_sp_span_entry_ops_phys,\n#if IS_ENABLED(CONFIG_NET_IPGRE)\n\t&mlxsw_sp_span_entry_ops_gretap4,\n#endif\n#if IS_ENABLED(CONFIG_IPV6_GRE)\n\t&mlxsw_sp_span_entry_ops_gretap6,\n#endif\n\t&mlxsw_sp_span_entry_ops_vlan,\n};\n\nstatic int\nmlxsw_sp_span_entry_nop_parms(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      const struct net_device *to_dev,\n\t\t\t      struct mlxsw_sp_span_parms *sparmsp)\n{\n\treturn mlxsw_sp_span_entry_unoffloadable(sparmsp);\n}\n\nstatic int\nmlxsw_sp_span_entry_nop_configure(struct mlxsw_sp_span_entry *span_entry,\n\t\t\t\t  struct mlxsw_sp_span_parms sparms)\n{\n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_span_entry_nop_deconfigure(struct mlxsw_sp_span_entry *span_entry)\n{\n}\n\nstatic const struct mlxsw_sp_span_entry_ops mlxsw_sp_span_entry_ops_nop = {\n\t.parms_set = mlxsw_sp_span_entry_nop_parms,\n\t.configure = mlxsw_sp_span_entry_nop_configure,\n\t.deconfigure = mlxsw_sp_span_entry_nop_deconfigure,\n};\n\nstatic void\nmlxsw_sp_span_entry_configure(struct mlxsw_sp *mlxsw_sp,\n\t\t\t      struct mlxsw_sp_span_entry *span_entry,\n\t\t\t      struct mlxsw_sp_span_parms sparms)\n{\n\tint err;\n\n\tif (!sparms.dest_port)\n\t\tgoto set_parms;\n\n\tif (sparms.dest_port->mlxsw_sp != mlxsw_sp) {\n\t\tdev_err(mlxsw_sp->bus_info->dev,\n\t\t\t\"Cannot mirror to a port which belongs to a different mlxsw instance\\n\");\n\t\tsparms.dest_port = NULL;\n\t\tgoto set_parms;\n\t}\n\n\terr = span_entry->ops->configure(span_entry, sparms);\n\tif (err) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Failed to offload mirror\\n\");\n\t\tsparms.dest_port = NULL;\n\t\tgoto set_parms;\n\t}\n\nset_parms:\n\tspan_entry->parms = sparms;\n}\n\nstatic void\nmlxsw_sp_span_entry_deconfigure(struct mlxsw_sp_span_entry *span_entry)\n{\n\tif (span_entry->parms.dest_port)\n\t\tspan_entry->ops->deconfigure(span_entry);\n}\n\nstatic int mlxsw_sp_span_policer_id_base_set(struct mlxsw_sp_span *span,\n\t\t\t\t\t     u16 policer_id)\n{\n\tstruct mlxsw_sp *mlxsw_sp = span->mlxsw_sp;\n\tu16 policer_id_base;\n\tint err;\n\n\t \n\tif (refcount_read(&span->policer_id_base_ref_count)) {\n\t\tif (policer_id < span->policer_id_base ||\n\t\t    policer_id >= span->policer_id_base + span->entries_count)\n\t\t\treturn -EINVAL;\n\n\t\trefcount_inc(&span->policer_id_base_ref_count);\n\t\treturn 0;\n\t}\n\n\t \n\tpolicer_id_base = policer_id % 2 == 0 ? policer_id : policer_id - 1;\n\terr = mlxsw_sp->span_ops->policer_id_base_set(mlxsw_sp,\n\t\t\t\t\t\t      policer_id_base);\n\tif (err)\n\t\treturn err;\n\n\tspan->policer_id_base = policer_id_base;\n\trefcount_set(&span->policer_id_base_ref_count, 1);\n\n\treturn 0;\n}\n\nstatic void mlxsw_sp_span_policer_id_base_unset(struct mlxsw_sp_span *span)\n{\n\tif (refcount_dec_and_test(&span->policer_id_base_ref_count))\n\t\tspan->policer_id_base = 0;\n}\n\nstatic struct mlxsw_sp_span_entry *\nmlxsw_sp_span_entry_create(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   const struct net_device *to_dev,\n\t\t\t   const struct mlxsw_sp_span_entry_ops *ops,\n\t\t\t   struct mlxsw_sp_span_parms sparms)\n{\n\tstruct mlxsw_sp_span_entry *span_entry = NULL;\n\tint i;\n\n\t \n\tfor (i = 0; i < mlxsw_sp->span->entries_count; i++) {\n\t\tif (!refcount_read(&mlxsw_sp->span->entries[i].ref_count)) {\n\t\t\tspan_entry = &mlxsw_sp->span->entries[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!span_entry)\n\t\treturn NULL;\n\n\tif (sparms.policer_enable) {\n\t\tint err;\n\n\t\terr = mlxsw_sp_span_policer_id_base_set(mlxsw_sp->span,\n\t\t\t\t\t\t\tsparms.policer_id);\n\t\tif (err)\n\t\t\treturn NULL;\n\t}\n\n\tatomic_inc(&mlxsw_sp->span->active_entries_count);\n\tspan_entry->ops = ops;\n\trefcount_set(&span_entry->ref_count, 1);\n\tspan_entry->to_dev = to_dev;\n\tmlxsw_sp_span_entry_configure(mlxsw_sp, span_entry, sparms);\n\n\treturn span_entry;\n}\n\nstatic void mlxsw_sp_span_entry_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\tstruct mlxsw_sp_span_entry *span_entry)\n{\n\tmlxsw_sp_span_entry_deconfigure(span_entry);\n\tatomic_dec(&mlxsw_sp->span->active_entries_count);\n\tif (span_entry->parms.policer_enable)\n\t\tmlxsw_sp_span_policer_id_base_unset(mlxsw_sp->span);\n}\n\nstruct mlxsw_sp_span_entry *\nmlxsw_sp_span_entry_find_by_port(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t const struct net_device *to_dev)\n{\n\tint i;\n\n\tfor (i = 0; i < mlxsw_sp->span->entries_count; i++) {\n\t\tstruct mlxsw_sp_span_entry *curr = &mlxsw_sp->span->entries[i];\n\n\t\tif (refcount_read(&curr->ref_count) && curr->to_dev == to_dev)\n\t\t\treturn curr;\n\t}\n\treturn NULL;\n}\n\nvoid mlxsw_sp_span_entry_invalidate(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t    struct mlxsw_sp_span_entry *span_entry)\n{\n\tmlxsw_sp_span_entry_deconfigure(span_entry);\n\tspan_entry->ops = &mlxsw_sp_span_entry_ops_nop;\n}\n\nstatic struct mlxsw_sp_span_entry *\nmlxsw_sp_span_entry_find_by_id(struct mlxsw_sp *mlxsw_sp, int span_id)\n{\n\tint i;\n\n\tfor (i = 0; i < mlxsw_sp->span->entries_count; i++) {\n\t\tstruct mlxsw_sp_span_entry *curr = &mlxsw_sp->span->entries[i];\n\n\t\tif (refcount_read(&curr->ref_count) && curr->id == span_id)\n\t\t\treturn curr;\n\t}\n\treturn NULL;\n}\n\nstatic struct mlxsw_sp_span_entry *\nmlxsw_sp_span_entry_find_by_parms(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t  const struct net_device *to_dev,\n\t\t\t\t  const struct mlxsw_sp_span_parms *sparms)\n{\n\tint i;\n\n\tfor (i = 0; i < mlxsw_sp->span->entries_count; i++) {\n\t\tstruct mlxsw_sp_span_entry *curr = &mlxsw_sp->span->entries[i];\n\n\t\tif (refcount_read(&curr->ref_count) && curr->to_dev == to_dev &&\n\t\t    curr->parms.policer_enable == sparms->policer_enable &&\n\t\t    curr->parms.policer_id == sparms->policer_id &&\n\t\t    curr->parms.session_id == sparms->session_id)\n\t\t\treturn curr;\n\t}\n\treturn NULL;\n}\n\nstatic struct mlxsw_sp_span_entry *\nmlxsw_sp_span_entry_get(struct mlxsw_sp *mlxsw_sp,\n\t\t\tconst struct net_device *to_dev,\n\t\t\tconst struct mlxsw_sp_span_entry_ops *ops,\n\t\t\tstruct mlxsw_sp_span_parms sparms)\n{\n\tstruct mlxsw_sp_span_entry *span_entry;\n\n\tspan_entry = mlxsw_sp_span_entry_find_by_parms(mlxsw_sp, to_dev,\n\t\t\t\t\t\t       &sparms);\n\tif (span_entry) {\n\t\t \n\t\trefcount_inc(&span_entry->ref_count);\n\t\treturn span_entry;\n\t}\n\n\treturn mlxsw_sp_span_entry_create(mlxsw_sp, to_dev, ops, sparms);\n}\n\nstatic int mlxsw_sp_span_entry_put(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t   struct mlxsw_sp_span_entry *span_entry)\n{\n\tif (refcount_dec_and_test(&span_entry->ref_count))\n\t\tmlxsw_sp_span_entry_destroy(mlxsw_sp, span_entry);\n\treturn 0;\n}\n\nstatic int mlxsw_sp_span_port_buffer_update(struct mlxsw_sp_port *mlxsw_sp_port, bool enable)\n{\n\tstruct mlxsw_sp_hdroom hdroom;\n\n\thdroom = *mlxsw_sp_port->hdroom;\n\thdroom.int_buf.enable = enable;\n\tmlxsw_sp_hdroom_bufs_reset_sizes(mlxsw_sp_port, &hdroom);\n\n\treturn mlxsw_sp_hdroom_configure(mlxsw_sp_port, &hdroom);\n}\n\nstatic int\nmlxsw_sp_span_port_buffer_enable(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\treturn mlxsw_sp_span_port_buffer_update(mlxsw_sp_port, true);\n}\n\nstatic void mlxsw_sp_span_port_buffer_disable(struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tmlxsw_sp_span_port_buffer_update(mlxsw_sp_port, false);\n}\n\nstatic struct mlxsw_sp_span_analyzed_port *\nmlxsw_sp_span_analyzed_port_find(struct mlxsw_sp_span *span, u16 local_port,\n\t\t\t\t bool ingress)\n{\n\tstruct mlxsw_sp_span_analyzed_port *analyzed_port;\n\n\tlist_for_each_entry(analyzed_port, &span->analyzed_ports_list, list) {\n\t\tif (analyzed_port->local_port == local_port &&\n\t\t    analyzed_port->ingress == ingress)\n\t\t\treturn analyzed_port;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct mlxsw_sp_span_entry_ops *\nmlxsw_sp_span_entry_ops(struct mlxsw_sp *mlxsw_sp,\n\t\t\tconst struct net_device *to_dev)\n{\n\tstruct mlxsw_sp_span *span = mlxsw_sp->span;\n\tsize_t i;\n\n\tfor (i = 0; i < span->span_entry_ops_arr_size; ++i)\n\t\tif (span->span_entry_ops_arr[i]->can_handle(to_dev))\n\t\t\treturn span->span_entry_ops_arr[i];\n\n\treturn NULL;\n}\n\nstatic void mlxsw_sp_span_respin_work(struct work_struct *work)\n{\n\tstruct mlxsw_sp_span *span;\n\tstruct mlxsw_sp *mlxsw_sp;\n\tint i, err;\n\n\tspan = container_of(work, struct mlxsw_sp_span, work);\n\tmlxsw_sp = span->mlxsw_sp;\n\n\trtnl_lock();\n\tfor (i = 0; i < mlxsw_sp->span->entries_count; i++) {\n\t\tstruct mlxsw_sp_span_entry *curr = &mlxsw_sp->span->entries[i];\n\t\tstruct mlxsw_sp_span_parms sparms = {NULL};\n\n\t\tif (!refcount_read(&curr->ref_count))\n\t\t\tcontinue;\n\n\t\tif (curr->ops->is_static)\n\t\t\tcontinue;\n\n\t\terr = curr->ops->parms_set(mlxsw_sp, curr->to_dev, &sparms);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\tif (memcmp(&sparms, &curr->parms, sizeof(sparms))) {\n\t\t\tmlxsw_sp_span_entry_deconfigure(curr);\n\t\t\tmlxsw_sp_span_entry_configure(mlxsw_sp, curr, sparms);\n\t\t}\n\t}\n\trtnl_unlock();\n}\n\nvoid mlxsw_sp_span_respin(struct mlxsw_sp *mlxsw_sp)\n{\n\tif (atomic_read(&mlxsw_sp->span->active_entries_count) == 0)\n\t\treturn;\n\tmlxsw_core_schedule_work(&mlxsw_sp->span->work);\n}\n\nint mlxsw_sp_span_agent_get(struct mlxsw_sp *mlxsw_sp, int *p_span_id,\n\t\t\t    const struct mlxsw_sp_span_agent_parms *parms)\n{\n\tconst struct net_device *to_dev = parms->to_dev;\n\tconst struct mlxsw_sp_span_entry_ops *ops;\n\tstruct mlxsw_sp_span_entry *span_entry;\n\tstruct mlxsw_sp_span_parms sparms;\n\tint err;\n\n\tASSERT_RTNL();\n\n\tops = mlxsw_sp_span_entry_ops(mlxsw_sp, to_dev);\n\tif (!ops) {\n\t\tdev_err(mlxsw_sp->bus_info->dev, \"Cannot mirror to requested destination\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(&sparms, 0, sizeof(sparms));\n\terr = ops->parms_set(mlxsw_sp, to_dev, &sparms);\n\tif (err)\n\t\treturn err;\n\n\tsparms.policer_id = parms->policer_id;\n\tsparms.policer_enable = parms->policer_enable;\n\tsparms.session_id = parms->session_id;\n\tspan_entry = mlxsw_sp_span_entry_get(mlxsw_sp, to_dev, ops, sparms);\n\tif (!span_entry)\n\t\treturn -ENOBUFS;\n\n\t*p_span_id = span_entry->id;\n\n\treturn 0;\n}\n\nvoid mlxsw_sp_span_agent_put(struct mlxsw_sp *mlxsw_sp, int span_id)\n{\n\tstruct mlxsw_sp_span_entry *span_entry;\n\n\tASSERT_RTNL();\n\n\tspan_entry = mlxsw_sp_span_entry_find_by_id(mlxsw_sp, span_id);\n\tif (WARN_ON_ONCE(!span_entry))\n\t\treturn;\n\n\tmlxsw_sp_span_entry_put(mlxsw_sp, span_entry);\n}\n\nstatic struct mlxsw_sp_span_analyzed_port *\nmlxsw_sp_span_analyzed_port_create(struct mlxsw_sp_span *span,\n\t\t\t\t   struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t   bool ingress)\n{\n\tstruct mlxsw_sp_span_analyzed_port *analyzed_port;\n\tint err;\n\n\tanalyzed_port = kzalloc(sizeof(*analyzed_port), GFP_KERNEL);\n\tif (!analyzed_port)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trefcount_set(&analyzed_port->ref_count, 1);\n\tanalyzed_port->local_port = mlxsw_sp_port->local_port;\n\tanalyzed_port->ingress = ingress;\n\tlist_add_tail(&analyzed_port->list, &span->analyzed_ports_list);\n\n\t \n\tif (!ingress) {\n\t\terr = mlxsw_sp_span_port_buffer_enable(mlxsw_sp_port);\n\t\tif (err)\n\t\t\tgoto err_buffer_update;\n\t}\n\n\treturn analyzed_port;\n\nerr_buffer_update:\n\tlist_del(&analyzed_port->list);\n\tkfree(analyzed_port);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_span_analyzed_port_destroy(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    struct mlxsw_sp_span_analyzed_port *\n\t\t\t\t    analyzed_port)\n{\n\t \n\tif (!analyzed_port->ingress)\n\t\tmlxsw_sp_span_port_buffer_disable(mlxsw_sp_port);\n\n\tlist_del(&analyzed_port->list);\n\tkfree(analyzed_port);\n}\n\nint mlxsw_sp_span_analyzed_port_get(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t    bool ingress)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_span_analyzed_port *analyzed_port;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\tint err = 0;\n\n\tmutex_lock(&mlxsw_sp->span->analyzed_ports_lock);\n\n\tanalyzed_port = mlxsw_sp_span_analyzed_port_find(mlxsw_sp->span,\n\t\t\t\t\t\t\t local_port, ingress);\n\tif (analyzed_port) {\n\t\trefcount_inc(&analyzed_port->ref_count);\n\t\tgoto out_unlock;\n\t}\n\n\tanalyzed_port = mlxsw_sp_span_analyzed_port_create(mlxsw_sp->span,\n\t\t\t\t\t\t\t   mlxsw_sp_port,\n\t\t\t\t\t\t\t   ingress);\n\tif (IS_ERR(analyzed_port))\n\t\terr = PTR_ERR(analyzed_port);\n\nout_unlock:\n\tmutex_unlock(&mlxsw_sp->span->analyzed_ports_lock);\n\treturn err;\n}\n\nvoid mlxsw_sp_span_analyzed_port_put(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t     bool ingress)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_span_analyzed_port *analyzed_port;\n\tu16 local_port = mlxsw_sp_port->local_port;\n\n\tmutex_lock(&mlxsw_sp->span->analyzed_ports_lock);\n\n\tanalyzed_port = mlxsw_sp_span_analyzed_port_find(mlxsw_sp->span,\n\t\t\t\t\t\t\t local_port, ingress);\n\tif (WARN_ON_ONCE(!analyzed_port))\n\t\tgoto out_unlock;\n\n\tif (!refcount_dec_and_test(&analyzed_port->ref_count))\n\t\tgoto out_unlock;\n\n\tmlxsw_sp_span_analyzed_port_destroy(mlxsw_sp_port, analyzed_port);\n\nout_unlock:\n\tmutex_unlock(&mlxsw_sp->span->analyzed_ports_lock);\n}\n\nstatic int\n__mlxsw_sp_span_trigger_port_bind(struct mlxsw_sp_span *span,\n\t\t\t\t  struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t  trigger_entry, bool enable)\n{\n\tchar mpar_pl[MLXSW_REG_MPAR_LEN];\n\tenum mlxsw_reg_mpar_i_e i_e;\n\n\tswitch (trigger_entry->trigger) {\n\tcase MLXSW_SP_SPAN_TRIGGER_INGRESS:\n\t\ti_e = MLXSW_REG_MPAR_TYPE_INGRESS;\n\t\tbreak;\n\tcase MLXSW_SP_SPAN_TRIGGER_EGRESS:\n\t\ti_e = MLXSW_REG_MPAR_TYPE_EGRESS;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (trigger_entry->parms.probability_rate > MLXSW_REG_MPAR_RATE_MAX)\n\t\treturn -EINVAL;\n\n\tmlxsw_reg_mpar_pack(mpar_pl, trigger_entry->local_port, i_e, enable,\n\t\t\t    trigger_entry->parms.span_id,\n\t\t\t    trigger_entry->parms.probability_rate);\n\treturn mlxsw_reg_write(span->mlxsw_sp->core, MLXSW_REG(mpar), mpar_pl);\n}\n\nstatic int\nmlxsw_sp_span_trigger_port_bind(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\ttrigger_entry)\n{\n\treturn __mlxsw_sp_span_trigger_port_bind(trigger_entry->span,\n\t\t\t\t\t\t trigger_entry, true);\n}\n\nstatic void\nmlxsw_sp_span_trigger_port_unbind(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t  trigger_entry)\n{\n\t__mlxsw_sp_span_trigger_port_bind(trigger_entry->span, trigger_entry,\n\t\t\t\t\t  false);\n}\n\nstatic bool\nmlxsw_sp_span_trigger_port_matches(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t   trigger_entry,\n\t\t\t\t   enum mlxsw_sp_span_trigger trigger,\n\t\t\t\t   struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\treturn trigger_entry->trigger == trigger &&\n\t       trigger_entry->local_port == mlxsw_sp_port->local_port;\n}\n\nstatic int\nmlxsw_sp_span_trigger_port_enable(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t  trigger_entry,\n\t\t\t\t  struct mlxsw_sp_port *mlxsw_sp_port, u8 tc)\n{\n\t \n\treturn 0;\n}\n\nstatic void\nmlxsw_sp_span_trigger_port_disable(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t   trigger_entry,\n\t\t\t\t   struct mlxsw_sp_port *mlxsw_sp_port, u8 tc)\n{\n}\n\nstatic const struct mlxsw_sp_span_trigger_ops\nmlxsw_sp_span_trigger_port_ops = {\n\t.bind = mlxsw_sp_span_trigger_port_bind,\n\t.unbind = mlxsw_sp_span_trigger_port_unbind,\n\t.matches = mlxsw_sp_span_trigger_port_matches,\n\t.enable = mlxsw_sp_span_trigger_port_enable,\n\t.disable = mlxsw_sp_span_trigger_port_disable,\n};\n\nstatic int\nmlxsw_sp1_span_trigger_global_bind(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t   trigger_entry)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void\nmlxsw_sp1_span_trigger_global_unbind(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t     trigger_entry)\n{\n}\n\nstatic bool\nmlxsw_sp1_span_trigger_global_matches(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t      trigger_entry,\n\t\t\t\t      enum mlxsw_sp_span_trigger trigger,\n\t\t\t\t      struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tWARN_ON_ONCE(1);\n\treturn false;\n}\n\nstatic int\nmlxsw_sp1_span_trigger_global_enable(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t     trigger_entry,\n\t\t\t\t     struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t     u8 tc)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void\nmlxsw_sp1_span_trigger_global_disable(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t      trigger_entry,\n\t\t\t\t      struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      u8 tc)\n{\n}\n\nstatic const struct mlxsw_sp_span_trigger_ops\nmlxsw_sp1_span_trigger_global_ops = {\n\t.bind = mlxsw_sp1_span_trigger_global_bind,\n\t.unbind = mlxsw_sp1_span_trigger_global_unbind,\n\t.matches = mlxsw_sp1_span_trigger_global_matches,\n\t.enable = mlxsw_sp1_span_trigger_global_enable,\n\t.disable = mlxsw_sp1_span_trigger_global_disable,\n};\n\nstatic const struct mlxsw_sp_span_trigger_ops *\nmlxsw_sp1_span_trigger_ops_arr[] = {\n\t[MLXSW_SP_SPAN_TRIGGER_TYPE_PORT] = &mlxsw_sp_span_trigger_port_ops,\n\t[MLXSW_SP_SPAN_TRIGGER_TYPE_GLOBAL] =\n\t\t&mlxsw_sp1_span_trigger_global_ops,\n};\n\nstatic int\nmlxsw_sp2_span_trigger_global_bind(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t   trigger_entry)\n{\n\tstruct mlxsw_sp *mlxsw_sp = trigger_entry->span->mlxsw_sp;\n\tenum mlxsw_reg_mpagr_trigger trigger;\n\tchar mpagr_pl[MLXSW_REG_MPAGR_LEN];\n\n\tswitch (trigger_entry->trigger) {\n\tcase MLXSW_SP_SPAN_TRIGGER_TAIL_DROP:\n\t\ttrigger = MLXSW_REG_MPAGR_TRIGGER_INGRESS_SHARED_BUFFER;\n\t\tbreak;\n\tcase MLXSW_SP_SPAN_TRIGGER_EARLY_DROP:\n\t\ttrigger = MLXSW_REG_MPAGR_TRIGGER_INGRESS_WRED;\n\t\tbreak;\n\tcase MLXSW_SP_SPAN_TRIGGER_ECN:\n\t\ttrigger = MLXSW_REG_MPAGR_TRIGGER_EGRESS_ECN;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (trigger_entry->parms.probability_rate > MLXSW_REG_MPAGR_RATE_MAX)\n\t\treturn -EINVAL;\n\n\tmlxsw_reg_mpagr_pack(mpagr_pl, trigger, trigger_entry->parms.span_id,\n\t\t\t     trigger_entry->parms.probability_rate);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mpagr), mpagr_pl);\n}\n\nstatic void\nmlxsw_sp2_span_trigger_global_unbind(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t     trigger_entry)\n{\n\t \n}\n\nstatic bool\nmlxsw_sp2_span_trigger_global_matches(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t      trigger_entry,\n\t\t\t\t      enum mlxsw_sp_span_trigger trigger,\n\t\t\t\t      struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\treturn trigger_entry->trigger == trigger;\n}\n\nstatic int\n__mlxsw_sp2_span_trigger_global_enable(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t       trigger_entry,\n\t\t\t\t       struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t       u8 tc, bool enable)\n{\n\tstruct mlxsw_sp *mlxsw_sp = trigger_entry->span->mlxsw_sp;\n\tchar momte_pl[MLXSW_REG_MOMTE_LEN];\n\tenum mlxsw_reg_momte_type type;\n\tint err;\n\n\tswitch (trigger_entry->trigger) {\n\tcase MLXSW_SP_SPAN_TRIGGER_TAIL_DROP:\n\t\ttype = MLXSW_REG_MOMTE_TYPE_SHARED_BUFFER_TCLASS;\n\t\tbreak;\n\tcase MLXSW_SP_SPAN_TRIGGER_EARLY_DROP:\n\t\ttype = MLXSW_REG_MOMTE_TYPE_WRED;\n\t\tbreak;\n\tcase MLXSW_SP_SPAN_TRIGGER_ECN:\n\t\ttype = MLXSW_REG_MOMTE_TYPE_ECN;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmlxsw_reg_momte_pack(momte_pl, mlxsw_sp_port->local_port, type);\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(momte), momte_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_momte_tclass_en_set(momte_pl, tc, enable);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(momte), momte_pl);\n}\n\nstatic int\nmlxsw_sp2_span_trigger_global_enable(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t     trigger_entry,\n\t\t\t\t     struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t     u8 tc)\n{\n\treturn __mlxsw_sp2_span_trigger_global_enable(trigger_entry,\n\t\t\t\t\t\t      mlxsw_sp_port, tc, true);\n}\n\nstatic void\nmlxsw_sp2_span_trigger_global_disable(struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t      trigger_entry,\n\t\t\t\t      struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t      u8 tc)\n{\n\t__mlxsw_sp2_span_trigger_global_enable(trigger_entry, mlxsw_sp_port, tc,\n\t\t\t\t\t       false);\n}\n\nstatic const struct mlxsw_sp_span_trigger_ops\nmlxsw_sp2_span_trigger_global_ops = {\n\t.bind = mlxsw_sp2_span_trigger_global_bind,\n\t.unbind = mlxsw_sp2_span_trigger_global_unbind,\n\t.matches = mlxsw_sp2_span_trigger_global_matches,\n\t.enable = mlxsw_sp2_span_trigger_global_enable,\n\t.disable = mlxsw_sp2_span_trigger_global_disable,\n};\n\nstatic const struct mlxsw_sp_span_trigger_ops *\nmlxsw_sp2_span_trigger_ops_arr[] = {\n\t[MLXSW_SP_SPAN_TRIGGER_TYPE_PORT] = &mlxsw_sp_span_trigger_port_ops,\n\t[MLXSW_SP_SPAN_TRIGGER_TYPE_GLOBAL] =\n\t\t&mlxsw_sp2_span_trigger_global_ops,\n};\n\nstatic void\nmlxsw_sp_span_trigger_ops_set(struct mlxsw_sp_span_trigger_entry *trigger_entry)\n{\n\tstruct mlxsw_sp_span *span = trigger_entry->span;\n\tenum mlxsw_sp_span_trigger_type type;\n\n\tswitch (trigger_entry->trigger) {\n\tcase MLXSW_SP_SPAN_TRIGGER_INGRESS:\n\tcase MLXSW_SP_SPAN_TRIGGER_EGRESS:\n\t\ttype = MLXSW_SP_SPAN_TRIGGER_TYPE_PORT;\n\t\tbreak;\n\tcase MLXSW_SP_SPAN_TRIGGER_TAIL_DROP:\n\tcase MLXSW_SP_SPAN_TRIGGER_EARLY_DROP:\n\tcase MLXSW_SP_SPAN_TRIGGER_ECN:\n\t\ttype = MLXSW_SP_SPAN_TRIGGER_TYPE_GLOBAL;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\ttrigger_entry->ops = span->span_trigger_ops_arr[type];\n}\n\nstatic struct mlxsw_sp_span_trigger_entry *\nmlxsw_sp_span_trigger_entry_create(struct mlxsw_sp_span *span,\n\t\t\t\t   enum mlxsw_sp_span_trigger trigger,\n\t\t\t\t   struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t   const struct mlxsw_sp_span_trigger_parms\n\t\t\t\t   *parms)\n{\n\tstruct mlxsw_sp_span_trigger_entry *trigger_entry;\n\tint err;\n\n\ttrigger_entry = kzalloc(sizeof(*trigger_entry), GFP_KERNEL);\n\tif (!trigger_entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trefcount_set(&trigger_entry->ref_count, 1);\n\ttrigger_entry->local_port = mlxsw_sp_port ? mlxsw_sp_port->local_port :\n\t\t\t\t\t\t    0;\n\ttrigger_entry->trigger = trigger;\n\tmemcpy(&trigger_entry->parms, parms, sizeof(trigger_entry->parms));\n\ttrigger_entry->span = span;\n\tmlxsw_sp_span_trigger_ops_set(trigger_entry);\n\tlist_add_tail(&trigger_entry->list, &span->trigger_entries_list);\n\n\terr = trigger_entry->ops->bind(trigger_entry);\n\tif (err)\n\t\tgoto err_trigger_entry_bind;\n\n\treturn trigger_entry;\n\nerr_trigger_entry_bind:\n\tlist_del(&trigger_entry->list);\n\tkfree(trigger_entry);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlxsw_sp_span_trigger_entry_destroy(struct mlxsw_sp_span *span,\n\t\t\t\t    struct mlxsw_sp_span_trigger_entry *\n\t\t\t\t    trigger_entry)\n{\n\ttrigger_entry->ops->unbind(trigger_entry);\n\tlist_del(&trigger_entry->list);\n\tkfree(trigger_entry);\n}\n\nstatic struct mlxsw_sp_span_trigger_entry *\nmlxsw_sp_span_trigger_entry_find(struct mlxsw_sp_span *span,\n\t\t\t\t enum mlxsw_sp_span_trigger trigger,\n\t\t\t\t struct mlxsw_sp_port *mlxsw_sp_port)\n{\n\tstruct mlxsw_sp_span_trigger_entry *trigger_entry;\n\n\tlist_for_each_entry(trigger_entry, &span->trigger_entries_list, list) {\n\t\tif (trigger_entry->ops->matches(trigger_entry, trigger,\n\t\t\t\t\t\tmlxsw_sp_port))\n\t\t\treturn trigger_entry;\n\t}\n\n\treturn NULL;\n}\n\nint mlxsw_sp_span_agent_bind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t     enum mlxsw_sp_span_trigger trigger,\n\t\t\t     struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t     const struct mlxsw_sp_span_trigger_parms *parms)\n{\n\tstruct mlxsw_sp_span_trigger_entry *trigger_entry;\n\tint err = 0;\n\n\tASSERT_RTNL();\n\n\tif (!mlxsw_sp_span_entry_find_by_id(mlxsw_sp, parms->span_id))\n\t\treturn -EINVAL;\n\n\ttrigger_entry = mlxsw_sp_span_trigger_entry_find(mlxsw_sp->span,\n\t\t\t\t\t\t\t trigger,\n\t\t\t\t\t\t\t mlxsw_sp_port);\n\tif (trigger_entry) {\n\t\tif (trigger_entry->parms.span_id != parms->span_id ||\n\t\t    trigger_entry->parms.probability_rate !=\n\t\t    parms->probability_rate)\n\t\t\treturn -EINVAL;\n\t\trefcount_inc(&trigger_entry->ref_count);\n\t\tgoto out;\n\t}\n\n\ttrigger_entry = mlxsw_sp_span_trigger_entry_create(mlxsw_sp->span,\n\t\t\t\t\t\t\t   trigger,\n\t\t\t\t\t\t\t   mlxsw_sp_port,\n\t\t\t\t\t\t\t   parms);\n\tif (IS_ERR(trigger_entry))\n\t\terr = PTR_ERR(trigger_entry);\n\nout:\n\treturn err;\n}\n\nvoid mlxsw_sp_span_agent_unbind(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\tenum mlxsw_sp_span_trigger trigger,\n\t\t\t\tstruct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\tconst struct mlxsw_sp_span_trigger_parms *parms)\n{\n\tstruct mlxsw_sp_span_trigger_entry *trigger_entry;\n\n\tASSERT_RTNL();\n\n\tif (WARN_ON_ONCE(!mlxsw_sp_span_entry_find_by_id(mlxsw_sp,\n\t\t\t\t\t\t\t parms->span_id)))\n\t\treturn;\n\n\ttrigger_entry = mlxsw_sp_span_trigger_entry_find(mlxsw_sp->span,\n\t\t\t\t\t\t\t trigger,\n\t\t\t\t\t\t\t mlxsw_sp_port);\n\tif (WARN_ON_ONCE(!trigger_entry))\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&trigger_entry->ref_count))\n\t\treturn;\n\n\tmlxsw_sp_span_trigger_entry_destroy(mlxsw_sp->span, trigger_entry);\n}\n\nint mlxsw_sp_span_trigger_enable(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t enum mlxsw_sp_span_trigger trigger, u8 tc)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_span_trigger_entry *trigger_entry;\n\n\tASSERT_RTNL();\n\n\ttrigger_entry = mlxsw_sp_span_trigger_entry_find(mlxsw_sp->span,\n\t\t\t\t\t\t\t trigger,\n\t\t\t\t\t\t\t mlxsw_sp_port);\n\tif (WARN_ON_ONCE(!trigger_entry))\n\t\treturn -EINVAL;\n\n\treturn trigger_entry->ops->enable(trigger_entry, mlxsw_sp_port, tc);\n}\n\nvoid mlxsw_sp_span_trigger_disable(struct mlxsw_sp_port *mlxsw_sp_port,\n\t\t\t\t   enum mlxsw_sp_span_trigger trigger, u8 tc)\n{\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\n\tstruct mlxsw_sp_span_trigger_entry *trigger_entry;\n\n\tASSERT_RTNL();\n\n\ttrigger_entry = mlxsw_sp_span_trigger_entry_find(mlxsw_sp->span,\n\t\t\t\t\t\t\t trigger,\n\t\t\t\t\t\t\t mlxsw_sp_port);\n\tif (WARN_ON_ONCE(!trigger_entry))\n\t\treturn;\n\n\treturn trigger_entry->ops->disable(trigger_entry, mlxsw_sp_port, tc);\n}\n\nbool mlxsw_sp_span_trigger_is_ingress(enum mlxsw_sp_span_trigger trigger)\n{\n\tswitch (trigger) {\n\tcase MLXSW_SP_SPAN_TRIGGER_INGRESS:\n\tcase MLXSW_SP_SPAN_TRIGGER_EARLY_DROP:\n\tcase MLXSW_SP_SPAN_TRIGGER_TAIL_DROP:\n\t\treturn true;\n\tcase MLXSW_SP_SPAN_TRIGGER_EGRESS:\n\tcase MLXSW_SP_SPAN_TRIGGER_ECN:\n\t\treturn false;\n\t}\n\n\tWARN_ON_ONCE(1);\n\treturn false;\n}\n\nstatic int mlxsw_sp1_span_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tsize_t arr_size = ARRAY_SIZE(mlxsw_sp1_span_entry_ops_arr);\n\n\t \n\tif (WARN_ON(mlxsw_sp1_span_entry_ops_arr[0] !=\n\t\t    &mlxsw_sp1_span_entry_ops_cpu))\n\t\treturn -EINVAL;\n\n\tmlxsw_sp->span->span_trigger_ops_arr = mlxsw_sp1_span_trigger_ops_arr;\n\tmlxsw_sp->span->span_entry_ops_arr = mlxsw_sp1_span_entry_ops_arr;\n\tmlxsw_sp->span->span_entry_ops_arr_size = arr_size;\n\n\treturn 0;\n}\n\nstatic int mlxsw_sp1_span_policer_id_base_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t      u16 policer_id_base)\n{\n\treturn -EOPNOTSUPP;\n}\n\nconst struct mlxsw_sp_span_ops mlxsw_sp1_span_ops = {\n\t.init = mlxsw_sp1_span_init,\n\t.policer_id_base_set = mlxsw_sp1_span_policer_id_base_set,\n};\n\nstatic int mlxsw_sp2_span_init(struct mlxsw_sp *mlxsw_sp)\n{\n\tsize_t arr_size = ARRAY_SIZE(mlxsw_sp2_span_entry_ops_arr);\n\n\t \n\tif (WARN_ON(mlxsw_sp2_span_entry_ops_arr[0] !=\n\t\t    &mlxsw_sp2_span_entry_ops_cpu))\n\t\treturn -EINVAL;\n\n\tmlxsw_sp->span->span_trigger_ops_arr = mlxsw_sp2_span_trigger_ops_arr;\n\tmlxsw_sp->span->span_entry_ops_arr = mlxsw_sp2_span_entry_ops_arr;\n\tmlxsw_sp->span->span_entry_ops_arr_size = arr_size;\n\n\treturn 0;\n}\n\n#define MLXSW_SP2_SPAN_EG_MIRROR_BUFFER_FACTOR 38\n#define MLXSW_SP3_SPAN_EG_MIRROR_BUFFER_FACTOR 50\n\nstatic int mlxsw_sp2_span_policer_id_base_set(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t\t      u16 policer_id_base)\n{\n\tchar mogcr_pl[MLXSW_REG_MOGCR_LEN];\n\tint err;\n\n\terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(mogcr), mogcr_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mogcr_mirroring_pid_base_set(mogcr_pl, policer_id_base);\n\treturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(mogcr), mogcr_pl);\n}\n\nconst struct mlxsw_sp_span_ops mlxsw_sp2_span_ops = {\n\t.init = mlxsw_sp2_span_init,\n\t.policer_id_base_set = mlxsw_sp2_span_policer_id_base_set,\n};\n\nconst struct mlxsw_sp_span_ops mlxsw_sp3_span_ops = {\n\t.init = mlxsw_sp2_span_init,\n\t.policer_id_base_set = mlxsw_sp2_span_policer_id_base_set,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}