{
  "module_name": "core_linecards.c",
  "hash_id": "2ec6978498b81160ed59fd0ff8055f4832690386c1ec8d0e2b56aff23a4f5431",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/core_linecards.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n\n#include \"core.h\"\n#include \"../mlxfw/mlxfw.h\"\n\nstruct mlxsw_linecard_ini_file {\n\t__le16 size;\n\tunion {\n\t\tu8 data[0];\n\t\tstruct {\n\t\t\t__be16 hw_revision;\n\t\t\t__be16 ini_version;\n\t\t\tu8 __dontcare[3];\n\t\t\tu8 type;\n\t\t\tu8 name[20];\n\t\t} format;\n\t};\n};\n\nstruct mlxsw_linecard_types_info {\n\tstruct mlxsw_linecard_ini_file **ini_files;\n\tunsigned int count;\n\tsize_t data_size;\n\tchar *data;\n};\n\n#define MLXSW_LINECARD_STATUS_EVENT_TO (10 * MSEC_PER_SEC)\n\nstatic void\nmlxsw_linecard_status_event_to_schedule(struct mlxsw_linecard *linecard,\n\t\t\t\t\tenum mlxsw_linecard_status_event_type status_event_type)\n{\n\tcancel_delayed_work_sync(&linecard->status_event_to_dw);\n\tlinecard->status_event_type_to = status_event_type;\n\tmlxsw_core_schedule_dw(&linecard->status_event_to_dw,\n\t\t\t       msecs_to_jiffies(MLXSW_LINECARD_STATUS_EVENT_TO));\n}\n\nstatic void\nmlxsw_linecard_status_event_done(struct mlxsw_linecard *linecard,\n\t\t\t\t enum mlxsw_linecard_status_event_type status_event_type)\n{\n\tif (linecard->status_event_type_to == status_event_type)\n\t\tcancel_delayed_work_sync(&linecard->status_event_to_dw);\n}\n\nstatic const char *\nmlxsw_linecard_types_lookup(struct mlxsw_linecards *linecards, u8 card_type)\n{\n\tstruct mlxsw_linecard_types_info *types_info;\n\tstruct mlxsw_linecard_ini_file *ini_file;\n\tint i;\n\n\ttypes_info = linecards->types_info;\n\tif (!types_info)\n\t\treturn NULL;\n\tfor (i = 0; i < types_info->count; i++) {\n\t\tini_file = linecards->types_info->ini_files[i];\n\t\tif (ini_file->format.type == card_type)\n\t\t\treturn ini_file->format.name;\n\t}\n\treturn NULL;\n}\n\nstatic const char *mlxsw_linecard_type_name(struct mlxsw_linecard *linecard)\n{\n\tstruct mlxsw_core *mlxsw_core = linecard->linecards->mlxsw_core;\n\tchar mddq_pl[MLXSW_REG_MDDQ_LEN];\n\tint err;\n\n\tmlxsw_reg_mddq_slot_name_pack(mddq_pl, linecard->slot_index);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mddq), mddq_pl);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tmlxsw_reg_mddq_slot_name_unpack(mddq_pl, linecard->name);\n\treturn linecard->name;\n}\n\nstruct mlxsw_linecard_device_fw_info {\n\tstruct mlxfw_dev mlxfw_dev;\n\tstruct mlxsw_core *mlxsw_core;\n\tstruct mlxsw_linecard *linecard;\n};\n\nstatic int mlxsw_linecard_device_fw_component_query(struct mlxfw_dev *mlxfw_dev,\n\t\t\t\t\t\t    u16 component_index,\n\t\t\t\t\t\t    u32 *p_max_size,\n\t\t\t\t\t\t    u8 *p_align_bits,\n\t\t\t\t\t\t    u16 *p_max_write_size)\n{\n\tstruct mlxsw_linecard_device_fw_info *info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_linecard_device_fw_info,\n\t\t\t     mlxfw_dev);\n\tstruct mlxsw_linecard *linecard = info->linecard;\n\tstruct mlxsw_core *mlxsw_core = info->mlxsw_core;\n\tchar mddt_pl[MLXSW_REG_MDDT_LEN];\n\tchar *mcqi_pl;\n\tint err;\n\n\tmlxsw_reg_mddt_pack(mddt_pl, linecard->slot_index,\n\t\t\t    linecard->device.index,\n\t\t\t    MLXSW_REG_MDDT_METHOD_QUERY,\n\t\t\t    MLXSW_REG(mcqi), &mcqi_pl);\n\n\tmlxsw_reg_mcqi_pack(mcqi_pl, component_index);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mddt), mddt_pl);\n\tif (err)\n\t\treturn err;\n\tmlxsw_reg_mcqi_unpack(mcqi_pl, p_max_size, p_align_bits,\n\t\t\t      p_max_write_size);\n\n\t*p_align_bits = max_t(u8, *p_align_bits, 2);\n\t*p_max_write_size = min_t(u16, *p_max_write_size,\n\t\t\t\t  MLXSW_REG_MCDA_MAX_DATA_LEN);\n\treturn 0;\n}\n\nstatic int mlxsw_linecard_device_fw_fsm_lock(struct mlxfw_dev *mlxfw_dev,\n\t\t\t\t\t     u32 *fwhandle)\n{\n\tstruct mlxsw_linecard_device_fw_info *info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_linecard_device_fw_info,\n\t\t\t     mlxfw_dev);\n\tstruct mlxsw_linecard *linecard = info->linecard;\n\tstruct mlxsw_core *mlxsw_core = info->mlxsw_core;\n\tchar mddt_pl[MLXSW_REG_MDDT_LEN];\n\tu8 control_state;\n\tchar *mcc_pl;\n\tint err;\n\n\tmlxsw_reg_mddt_pack(mddt_pl, linecard->slot_index,\n\t\t\t    linecard->device.index,\n\t\t\t    MLXSW_REG_MDDT_METHOD_QUERY,\n\t\t\t    MLXSW_REG(mcc), &mcc_pl);\n\tmlxsw_reg_mcc_pack(mcc_pl, 0, 0, 0, 0);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mddt), mddt_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mcc_unpack(mcc_pl, fwhandle, NULL, &control_state);\n\tif (control_state != MLXFW_FSM_STATE_IDLE)\n\t\treturn -EBUSY;\n\n\tmlxsw_reg_mddt_pack(mddt_pl, linecard->slot_index,\n\t\t\t    linecard->device.index,\n\t\t\t    MLXSW_REG_MDDT_METHOD_WRITE,\n\t\t\t    MLXSW_REG(mcc), &mcc_pl);\n\tmlxsw_reg_mcc_pack(mcc_pl, MLXSW_REG_MCC_INSTRUCTION_LOCK_UPDATE_HANDLE,\n\t\t\t   0, *fwhandle, 0);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mddt), mddt_pl);\n}\n\nstatic int\nmlxsw_linecard_device_fw_fsm_component_update(struct mlxfw_dev *mlxfw_dev,\n\t\t\t\t\t      u32 fwhandle,\n\t\t\t\t\t      u16 component_index,\n\t\t\t\t\t      u32 component_size)\n{\n\tstruct mlxsw_linecard_device_fw_info *info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_linecard_device_fw_info,\n\t\t\t     mlxfw_dev);\n\tstruct mlxsw_linecard *linecard = info->linecard;\n\tstruct mlxsw_core *mlxsw_core = info->mlxsw_core;\n\tchar mddt_pl[MLXSW_REG_MDDT_LEN];\n\tchar *mcc_pl;\n\n\tmlxsw_reg_mddt_pack(mddt_pl, linecard->slot_index,\n\t\t\t    linecard->device.index,\n\t\t\t    MLXSW_REG_MDDT_METHOD_WRITE,\n\t\t\t    MLXSW_REG(mcc), &mcc_pl);\n\tmlxsw_reg_mcc_pack(mcc_pl, MLXSW_REG_MCC_INSTRUCTION_UPDATE_COMPONENT,\n\t\t\t   component_index, fwhandle, component_size);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mddt), mddt_pl);\n}\n\nstatic int\nmlxsw_linecard_device_fw_fsm_block_download(struct mlxfw_dev *mlxfw_dev,\n\t\t\t\t\t    u32 fwhandle, u8 *data,\n\t\t\t\t\t    u16 size, u32 offset)\n{\n\tstruct mlxsw_linecard_device_fw_info *info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_linecard_device_fw_info,\n\t\t\t     mlxfw_dev);\n\tstruct mlxsw_linecard *linecard = info->linecard;\n\tstruct mlxsw_core *mlxsw_core = info->mlxsw_core;\n\tchar mddt_pl[MLXSW_REG_MDDT_LEN];\n\tchar *mcda_pl;\n\n\tmlxsw_reg_mddt_pack(mddt_pl, linecard->slot_index,\n\t\t\t    linecard->device.index,\n\t\t\t    MLXSW_REG_MDDT_METHOD_WRITE,\n\t\t\t    MLXSW_REG(mcda), &mcda_pl);\n\tmlxsw_reg_mcda_pack(mcda_pl, fwhandle, offset, size, data);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mddt), mddt_pl);\n}\n\nstatic int\nmlxsw_linecard_device_fw_fsm_component_verify(struct mlxfw_dev *mlxfw_dev,\n\t\t\t\t\t      u32 fwhandle, u16 component_index)\n{\n\tstruct mlxsw_linecard_device_fw_info *info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_linecard_device_fw_info,\n\t\t\t     mlxfw_dev);\n\tstruct mlxsw_linecard *linecard = info->linecard;\n\tstruct mlxsw_core *mlxsw_core = info->mlxsw_core;\n\tchar mddt_pl[MLXSW_REG_MDDT_LEN];\n\tchar *mcc_pl;\n\n\tmlxsw_reg_mddt_pack(mddt_pl, linecard->slot_index,\n\t\t\t    linecard->device.index,\n\t\t\t    MLXSW_REG_MDDT_METHOD_WRITE,\n\t\t\t    MLXSW_REG(mcc), &mcc_pl);\n\tmlxsw_reg_mcc_pack(mcc_pl, MLXSW_REG_MCC_INSTRUCTION_VERIFY_COMPONENT,\n\t\t\t   component_index, fwhandle, 0);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mddt), mddt_pl);\n}\n\nstatic int mlxsw_linecard_device_fw_fsm_activate(struct mlxfw_dev *mlxfw_dev,\n\t\t\t\t\t\t u32 fwhandle)\n{\n\tstruct mlxsw_linecard_device_fw_info *info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_linecard_device_fw_info,\n\t\t\t     mlxfw_dev);\n\tstruct mlxsw_linecard *linecard = info->linecard;\n\tstruct mlxsw_core *mlxsw_core = info->mlxsw_core;\n\tchar mddt_pl[MLXSW_REG_MDDT_LEN];\n\tchar *mcc_pl;\n\n\tmlxsw_reg_mddt_pack(mddt_pl, linecard->slot_index,\n\t\t\t    linecard->device.index,\n\t\t\t    MLXSW_REG_MDDT_METHOD_WRITE,\n\t\t\t    MLXSW_REG(mcc), &mcc_pl);\n\tmlxsw_reg_mcc_pack(mcc_pl, MLXSW_REG_MCC_INSTRUCTION_ACTIVATE,\n\t\t\t   0, fwhandle, 0);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mddt), mddt_pl);\n}\n\nstatic int\nmlxsw_linecard_device_fw_fsm_query_state(struct mlxfw_dev *mlxfw_dev,\n\t\t\t\t\t u32 fwhandle,\n\t\t\t\t\t enum mlxfw_fsm_state *fsm_state,\n\t\t\t\t\t enum mlxfw_fsm_state_err *fsm_state_err)\n{\n\tstruct mlxsw_linecard_device_fw_info *info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_linecard_device_fw_info,\n\t\t\t     mlxfw_dev);\n\tstruct mlxsw_linecard *linecard = info->linecard;\n\tstruct mlxsw_core *mlxsw_core = info->mlxsw_core;\n\tchar mddt_pl[MLXSW_REG_MDDT_LEN];\n\tu8 control_state;\n\tu8 error_code;\n\tchar *mcc_pl;\n\tint err;\n\n\tmlxsw_reg_mddt_pack(mddt_pl, linecard->slot_index,\n\t\t\t    linecard->device.index,\n\t\t\t    MLXSW_REG_MDDT_METHOD_QUERY,\n\t\t\t    MLXSW_REG(mcc), &mcc_pl);\n\tmlxsw_reg_mcc_pack(mcc_pl, 0, 0, fwhandle, 0);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mddt), mddt_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mcc_unpack(mcc_pl, NULL, &error_code, &control_state);\n\t*fsm_state = control_state;\n\t*fsm_state_err = min_t(enum mlxfw_fsm_state_err, error_code,\n\t\t\t       MLXFW_FSM_STATE_ERR_MAX);\n\treturn 0;\n}\n\nstatic void mlxsw_linecard_device_fw_fsm_cancel(struct mlxfw_dev *mlxfw_dev,\n\t\t\t\t\t\tu32 fwhandle)\n{\n\tstruct mlxsw_linecard_device_fw_info *info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_linecard_device_fw_info,\n\t\t\t     mlxfw_dev);\n\tstruct mlxsw_linecard *linecard = info->linecard;\n\tstruct mlxsw_core *mlxsw_core = info->mlxsw_core;\n\tchar mddt_pl[MLXSW_REG_MDDT_LEN];\n\tchar *mcc_pl;\n\n\tmlxsw_reg_mddt_pack(mddt_pl, linecard->slot_index,\n\t\t\t    linecard->device.index,\n\t\t\t    MLXSW_REG_MDDT_METHOD_WRITE,\n\t\t\t    MLXSW_REG(mcc), &mcc_pl);\n\tmlxsw_reg_mcc_pack(mcc_pl, MLXSW_REG_MCC_INSTRUCTION_CANCEL,\n\t\t\t   0, fwhandle, 0);\n\tmlxsw_reg_write(mlxsw_core, MLXSW_REG(mddt), mddt_pl);\n}\n\nstatic void mlxsw_linecard_device_fw_fsm_release(struct mlxfw_dev *mlxfw_dev,\n\t\t\t\t\t\t u32 fwhandle)\n{\n\tstruct mlxsw_linecard_device_fw_info *info =\n\t\tcontainer_of(mlxfw_dev, struct mlxsw_linecard_device_fw_info,\n\t\t\t     mlxfw_dev);\n\tstruct mlxsw_linecard *linecard = info->linecard;\n\tstruct mlxsw_core *mlxsw_core = info->mlxsw_core;\n\tchar mddt_pl[MLXSW_REG_MDDT_LEN];\n\tchar *mcc_pl;\n\n\tmlxsw_reg_mddt_pack(mddt_pl, linecard->slot_index,\n\t\t\t    linecard->device.index,\n\t\t\t    MLXSW_REG_MDDT_METHOD_WRITE,\n\t\t\t    MLXSW_REG(mcc), &mcc_pl);\n\tmlxsw_reg_mcc_pack(mcc_pl,\n\t\t\t   MLXSW_REG_MCC_INSTRUCTION_RELEASE_UPDATE_HANDLE,\n\t\t\t   0, fwhandle, 0);\n\tmlxsw_reg_write(mlxsw_core, MLXSW_REG(mddt), mddt_pl);\n}\n\nstatic const struct mlxfw_dev_ops mlxsw_linecard_device_dev_ops = {\n\t.component_query\t= mlxsw_linecard_device_fw_component_query,\n\t.fsm_lock\t\t= mlxsw_linecard_device_fw_fsm_lock,\n\t.fsm_component_update\t= mlxsw_linecard_device_fw_fsm_component_update,\n\t.fsm_block_download\t= mlxsw_linecard_device_fw_fsm_block_download,\n\t.fsm_component_verify\t= mlxsw_linecard_device_fw_fsm_component_verify,\n\t.fsm_activate\t\t= mlxsw_linecard_device_fw_fsm_activate,\n\t.fsm_query_state\t= mlxsw_linecard_device_fw_fsm_query_state,\n\t.fsm_cancel\t\t= mlxsw_linecard_device_fw_fsm_cancel,\n\t.fsm_release\t\t= mlxsw_linecard_device_fw_fsm_release,\n};\n\nint mlxsw_linecard_flash_update(struct devlink *linecard_devlink,\n\t\t\t\tstruct mlxsw_linecard *linecard,\n\t\t\t\tconst struct firmware *firmware,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_core *mlxsw_core = linecard->linecards->mlxsw_core;\n\tstruct mlxsw_linecard_device_fw_info info = {\n\t\t.mlxfw_dev = {\n\t\t\t.ops = &mlxsw_linecard_device_dev_ops,\n\t\t\t.psid = linecard->device.info.psid,\n\t\t\t.psid_size = strlen(linecard->device.info.psid),\n\t\t\t.devlink = linecard_devlink,\n\t\t},\n\t\t.mlxsw_core = mlxsw_core,\n\t\t.linecard = linecard,\n\t};\n\tint err;\n\n\tmutex_lock(&linecard->lock);\n\tif (!linecard->active) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Only active line cards can be flashed\");\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\terr = mlxsw_core_fw_flash(mlxsw_core, &info.mlxfw_dev,\n\t\t\t\t  firmware, extack);\nunlock:\n\tmutex_unlock(&linecard->lock);\n\treturn err;\n}\n\nstatic int mlxsw_linecard_device_psid_get(struct mlxsw_linecard *linecard,\n\t\t\t\t\t  u8 device_index, char *psid)\n{\n\tstruct mlxsw_core *mlxsw_core = linecard->linecards->mlxsw_core;\n\tchar mddt_pl[MLXSW_REG_MDDT_LEN];\n\tchar *mgir_pl;\n\tint err;\n\n\tmlxsw_reg_mddt_pack(mddt_pl, linecard->slot_index, device_index,\n\t\t\t    MLXSW_REG_MDDT_METHOD_QUERY,\n\t\t\t    MLXSW_REG(mgir), &mgir_pl);\n\n\tmlxsw_reg_mgir_pack(mgir_pl);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mddt), mddt_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mgir_fw_info_psid_memcpy_from(mgir_pl, psid);\n\treturn 0;\n}\n\nstatic int mlxsw_linecard_device_info_update(struct mlxsw_linecard *linecard)\n{\n\tstruct mlxsw_core *mlxsw_core = linecard->linecards->mlxsw_core;\n\tbool flashable_found = false;\n\tu8 msg_seq = 0;\n\n\tdo {\n\t\tstruct mlxsw_linecard_device_info info;\n\t\tchar mddq_pl[MLXSW_REG_MDDQ_LEN];\n\t\tbool flash_owner;\n\t\tbool data_valid;\n\t\tu8 device_index;\n\t\tint err;\n\n\t\tmlxsw_reg_mddq_device_info_pack(mddq_pl, linecard->slot_index,\n\t\t\t\t\t\tmsg_seq);\n\t\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mddq), mddq_pl);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmlxsw_reg_mddq_device_info_unpack(mddq_pl, &msg_seq,\n\t\t\t\t\t\t  &data_valid, &flash_owner,\n\t\t\t\t\t\t  &device_index,\n\t\t\t\t\t\t  &info.fw_major,\n\t\t\t\t\t\t  &info.fw_minor,\n\t\t\t\t\t\t  &info.fw_sub_minor);\n\t\tif (!data_valid)\n\t\t\tbreak;\n\t\tif (!flash_owner)  \n\t\t\tcontinue;\n\t\tif (flashable_found) {\n\t\t\tdev_warn_once(linecard->linecards->bus_info->dev, \"linecard %u: More flashable devices present, exposing only the first one\\n\",\n\t\t\t\t      linecard->slot_index);\n\t\t\treturn 0;\n\t\t}\n\n\t\terr = mlxsw_linecard_device_psid_get(linecard, device_index,\n\t\t\t\t\t\t     info.psid);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tlinecard->device.info = info;\n\t\tlinecard->device.index = device_index;\n\t\tflashable_found = true;\n\t} while (msg_seq);\n\n\treturn 0;\n}\n\nstatic void mlxsw_linecard_provision_fail(struct mlxsw_linecard *linecard)\n{\n\tlinecard->provisioned = false;\n\tlinecard->ready = false;\n\tlinecard->active = false;\n\tdevlink_linecard_provision_fail(linecard->devlink_linecard);\n}\n\nstruct mlxsw_linecards_event_ops_item {\n\tstruct list_head list;\n\tconst struct mlxsw_linecards_event_ops *event_ops;\n\tvoid *priv;\n};\n\nstatic void\nmlxsw_linecard_event_op_call(struct mlxsw_linecard *linecard,\n\t\t\t     mlxsw_linecards_event_op_t *op, void *priv)\n{\n\tstruct mlxsw_core *mlxsw_core = linecard->linecards->mlxsw_core;\n\n\tif (!op)\n\t\treturn;\n\top(mlxsw_core, linecard->slot_index, priv);\n}\n\nstatic void\nmlxsw_linecard_active_ops_call(struct mlxsw_linecard *linecard)\n{\n\tstruct mlxsw_linecards *linecards = linecard->linecards;\n\tstruct mlxsw_linecards_event_ops_item *item;\n\n\tmutex_lock(&linecards->event_ops_list_lock);\n\tlist_for_each_entry(item, &linecards->event_ops_list, list)\n\t\tmlxsw_linecard_event_op_call(linecard,\n\t\t\t\t\t     item->event_ops->got_active,\n\t\t\t\t\t     item->priv);\n\tmutex_unlock(&linecards->event_ops_list_lock);\n}\n\nstatic void\nmlxsw_linecard_inactive_ops_call(struct mlxsw_linecard *linecard)\n{\n\tstruct mlxsw_linecards *linecards = linecard->linecards;\n\tstruct mlxsw_linecards_event_ops_item *item;\n\n\tmutex_lock(&linecards->event_ops_list_lock);\n\tlist_for_each_entry(item, &linecards->event_ops_list, list)\n\t\tmlxsw_linecard_event_op_call(linecard,\n\t\t\t\t\t     item->event_ops->got_inactive,\n\t\t\t\t\t     item->priv);\n\tmutex_unlock(&linecards->event_ops_list_lock);\n}\n\nstatic void\nmlxsw_linecards_event_ops_register_call(struct mlxsw_linecards *linecards,\n\t\t\t\t\tconst struct mlxsw_linecards_event_ops_item *item)\n{\n\tstruct mlxsw_linecard *linecard;\n\tint i;\n\n\tfor (i = 0; i < linecards->count; i++) {\n\t\tlinecard = mlxsw_linecard_get(linecards, i + 1);\n\t\tmutex_lock(&linecard->lock);\n\t\tif (linecard->active)\n\t\t\tmlxsw_linecard_event_op_call(linecard,\n\t\t\t\t\t\t     item->event_ops->got_active,\n\t\t\t\t\t\t     item->priv);\n\t\tmutex_unlock(&linecard->lock);\n\t}\n}\n\nstatic void\nmlxsw_linecards_event_ops_unregister_call(struct mlxsw_linecards *linecards,\n\t\t\t\t\t  const struct mlxsw_linecards_event_ops_item *item)\n{\n\tstruct mlxsw_linecard *linecard;\n\tint i;\n\n\tfor (i = 0; i < linecards->count; i++) {\n\t\tlinecard = mlxsw_linecard_get(linecards, i + 1);\n\t\tmutex_lock(&linecard->lock);\n\t\tif (linecard->active)\n\t\t\tmlxsw_linecard_event_op_call(linecard,\n\t\t\t\t\t\t     item->event_ops->got_inactive,\n\t\t\t\t\t\t     item->priv);\n\t\tmutex_unlock(&linecard->lock);\n\t}\n}\n\nint mlxsw_linecards_event_ops_register(struct mlxsw_core *mlxsw_core,\n\t\t\t\t       struct mlxsw_linecards_event_ops *ops,\n\t\t\t\t       void *priv)\n{\n\tstruct mlxsw_linecards *linecards = mlxsw_core_linecards(mlxsw_core);\n\tstruct mlxsw_linecards_event_ops_item *item;\n\n\tif (!linecards)\n\t\treturn 0;\n\titem = kzalloc(sizeof(*item), GFP_KERNEL);\n\tif (!item)\n\t\treturn -ENOMEM;\n\titem->event_ops = ops;\n\titem->priv = priv;\n\n\tmutex_lock(&linecards->event_ops_list_lock);\n\tlist_add_tail(&item->list, &linecards->event_ops_list);\n\tmutex_unlock(&linecards->event_ops_list_lock);\n\tmlxsw_linecards_event_ops_register_call(linecards, item);\n\treturn 0;\n}\nEXPORT_SYMBOL(mlxsw_linecards_event_ops_register);\n\nvoid mlxsw_linecards_event_ops_unregister(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t  struct mlxsw_linecards_event_ops *ops,\n\t\t\t\t\t  void *priv)\n{\n\tstruct mlxsw_linecards *linecards = mlxsw_core_linecards(mlxsw_core);\n\tstruct mlxsw_linecards_event_ops_item *item, *tmp;\n\tbool found = false;\n\n\tif (!linecards)\n\t\treturn;\n\tmutex_lock(&linecards->event_ops_list_lock);\n\tlist_for_each_entry_safe(item, tmp, &linecards->event_ops_list, list) {\n\t\tif (item->event_ops == ops && item->priv == priv) {\n\t\t\tlist_del(&item->list);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&linecards->event_ops_list_lock);\n\n\tif (!found)\n\t\treturn;\n\tmlxsw_linecards_event_ops_unregister_call(linecards, item);\n\tkfree(item);\n}\nEXPORT_SYMBOL(mlxsw_linecards_event_ops_unregister);\n\nint mlxsw_linecard_devlink_info_get(struct mlxsw_linecard *linecard,\n\t\t\t\t    struct devlink_info_req *req,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tchar buf[32];\n\tint err;\n\n\tmutex_lock(&linecard->lock);\n\tif (WARN_ON(!linecard->provisioned)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t}\n\n\tsprintf(buf, \"%d\", linecard->hw_revision);\n\terr = devlink_info_version_fixed_put(req, \"hw.revision\", buf);\n\tif (err)\n\t\tgoto unlock;\n\n\tsprintf(buf, \"%d\", linecard->ini_version);\n\terr = devlink_info_version_running_put(req, \"ini.version\", buf);\n\tif (err)\n\t\tgoto unlock;\n\n\tif (linecard->active) {\n\t\tstruct mlxsw_linecard_device_info *info = &linecard->device.info;\n\n\t\terr = devlink_info_version_fixed_put(req,\n\t\t\t\t\t\t     DEVLINK_INFO_VERSION_GENERIC_FW_PSID,\n\t\t\t\t\t\t     info->psid);\n\n\t\tsprintf(buf, \"%u.%u.%u\", info->fw_major, info->fw_minor,\n\t\t\tinfo->fw_sub_minor);\n\t\terr = devlink_info_version_running_put(req,\n\t\t\t\t\t\t       DEVLINK_INFO_VERSION_GENERIC_FW,\n\t\t\t\t\t\t       buf);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\nunlock:\n\tmutex_unlock(&linecard->lock);\n\treturn err;\n}\n\nstatic int\nmlxsw_linecard_provision_set(struct mlxsw_linecard *linecard, u8 card_type,\n\t\t\t     u16 hw_revision, u16 ini_version)\n{\n\tstruct mlxsw_linecards *linecards = linecard->linecards;\n\tconst char *type;\n\tint err;\n\n\ttype = mlxsw_linecard_types_lookup(linecards, card_type);\n\tmlxsw_linecard_status_event_done(linecard,\n\t\t\t\t\t MLXSW_LINECARD_STATUS_EVENT_TYPE_PROVISION);\n\tif (!type) {\n\t\t \n\t\ttype = mlxsw_linecard_type_name(linecard);\n\t\tif (IS_ERR(type)) {\n\t\t\tmlxsw_linecard_provision_fail(linecard);\n\t\t\treturn PTR_ERR(type);\n\t\t}\n\t}\n\tlinecard->provisioned = true;\n\tlinecard->hw_revision = hw_revision;\n\tlinecard->ini_version = ini_version;\n\n\terr = mlxsw_linecard_bdev_add(linecard);\n\tif (err) {\n\t\tlinecard->provisioned = false;\n\t\tmlxsw_linecard_provision_fail(linecard);\n\t\treturn err;\n\t}\n\n\tdevlink_linecard_provision_set(linecard->devlink_linecard, type);\n\treturn 0;\n}\n\nstatic void mlxsw_linecard_provision_clear(struct mlxsw_linecard *linecard)\n{\n\tmlxsw_linecard_status_event_done(linecard,\n\t\t\t\t\t MLXSW_LINECARD_STATUS_EVENT_TYPE_UNPROVISION);\n\tmlxsw_linecard_bdev_del(linecard);\n\tlinecard->provisioned = false;\n\tdevlink_linecard_provision_clear(linecard->devlink_linecard);\n}\n\nstatic int mlxsw_linecard_ready_set(struct mlxsw_linecard *linecard)\n{\n\tstruct mlxsw_core *mlxsw_core = linecard->linecards->mlxsw_core;\n\tchar mddc_pl[MLXSW_REG_MDDC_LEN];\n\tint err;\n\n\terr = mlxsw_linecard_device_info_update(linecard);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mddc_pack(mddc_pl, linecard->slot_index, false, true);\n\terr = mlxsw_reg_write(mlxsw_core, MLXSW_REG(mddc), mddc_pl);\n\tif (err)\n\t\treturn err;\n\tlinecard->ready = true;\n\treturn 0;\n}\n\nstatic int mlxsw_linecard_ready_clear(struct mlxsw_linecard *linecard)\n{\n\tstruct mlxsw_core *mlxsw_core = linecard->linecards->mlxsw_core;\n\tchar mddc_pl[MLXSW_REG_MDDC_LEN];\n\tint err;\n\n\tmlxsw_reg_mddc_pack(mddc_pl, linecard->slot_index, false, false);\n\terr = mlxsw_reg_write(mlxsw_core, MLXSW_REG(mddc), mddc_pl);\n\tif (err)\n\t\treturn err;\n\tlinecard->ready = false;\n\treturn 0;\n}\n\nstatic void mlxsw_linecard_active_set(struct mlxsw_linecard *linecard)\n{\n\tmlxsw_linecard_active_ops_call(linecard);\n\tlinecard->active = true;\n\tdevlink_linecard_activate(linecard->devlink_linecard);\n}\n\nstatic void mlxsw_linecard_active_clear(struct mlxsw_linecard *linecard)\n{\n\tmlxsw_linecard_inactive_ops_call(linecard);\n\tlinecard->active = false;\n\tdevlink_linecard_deactivate(linecard->devlink_linecard);\n}\n\nstatic int mlxsw_linecard_status_process(struct mlxsw_linecards *linecards,\n\t\t\t\t\t struct mlxsw_linecard *linecard,\n\t\t\t\t\t const char *mddq_pl)\n{\n\tenum mlxsw_reg_mddq_slot_info_ready ready;\n\tbool provisioned, sr_valid, active;\n\tu16 ini_version, hw_revision;\n\tu8 slot_index, card_type;\n\tint err = 0;\n\n\tmlxsw_reg_mddq_slot_info_unpack(mddq_pl, &slot_index, &provisioned,\n\t\t\t\t\t&sr_valid, &ready, &active,\n\t\t\t\t\t&hw_revision, &ini_version,\n\t\t\t\t\t&card_type);\n\n\tif (linecard) {\n\t\tif (WARN_ON(slot_index != linecard->slot_index))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (WARN_ON(slot_index > linecards->count))\n\t\t\treturn -EINVAL;\n\t\tlinecard = mlxsw_linecard_get(linecards, slot_index);\n\t}\n\n\tmutex_lock(&linecard->lock);\n\n\tif (provisioned && linecard->provisioned != provisioned) {\n\t\terr = mlxsw_linecard_provision_set(linecard, card_type,\n\t\t\t\t\t\t   hw_revision, ini_version);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (ready == MLXSW_REG_MDDQ_SLOT_INFO_READY_READY && !linecard->ready) {\n\t\terr = mlxsw_linecard_ready_set(linecard);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (active && linecard->active != active)\n\t\tmlxsw_linecard_active_set(linecard);\n\n\tif (!active && linecard->active != active)\n\t\tmlxsw_linecard_active_clear(linecard);\n\n\tif (ready != MLXSW_REG_MDDQ_SLOT_INFO_READY_READY &&\n\t    linecard->ready) {\n\t\terr = mlxsw_linecard_ready_clear(linecard);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!provisioned && linecard->provisioned != provisioned)\n\t\tmlxsw_linecard_provision_clear(linecard);\n\nout:\n\tmutex_unlock(&linecard->lock);\n\treturn err;\n}\n\nstatic int mlxsw_linecard_status_get_and_process(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t\t struct mlxsw_linecards *linecards,\n\t\t\t\t\t\t struct mlxsw_linecard *linecard)\n{\n\tchar mddq_pl[MLXSW_REG_MDDQ_LEN];\n\tint err;\n\n\tmlxsw_reg_mddq_slot_info_pack(mddq_pl, linecard->slot_index, false);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mddq), mddq_pl);\n\tif (err)\n\t\treturn err;\n\n\treturn mlxsw_linecard_status_process(linecards, linecard, mddq_pl);\n}\n\nstatic void mlxsw_linecards_irq_event_handler(struct mlxsw_core *mlxsw_core)\n{\n\tstruct mlxsw_linecards *linecards = mlxsw_core_linecards(mlxsw_core);\n\tint i;\n\n\t \n\tfor (i = 0; i < linecards->count; i++) {\n\t\tstruct mlxsw_linecard *linecard = mlxsw_linecard_get(linecards,\n\t\t\t\t\t\t\t\t     i + 1);\n\n\t\tmlxsw_linecard_status_get_and_process(mlxsw_core, linecards,\n\t\t\t\t\t\t      linecard);\n\t}\n}\n\nstatic const char * const mlxsw_linecard_status_event_type_name[] = {\n\t[MLXSW_LINECARD_STATUS_EVENT_TYPE_PROVISION] = \"provision\",\n\t[MLXSW_LINECARD_STATUS_EVENT_TYPE_UNPROVISION] = \"unprovision\",\n};\n\nstatic void mlxsw_linecard_status_event_to_work(struct work_struct *work)\n{\n\tstruct mlxsw_linecard *linecard =\n\t\tcontainer_of(work, struct mlxsw_linecard,\n\t\t\t     status_event_to_dw.work);\n\n\tmutex_lock(&linecard->lock);\n\tdev_err(linecard->linecards->bus_info->dev, \"linecard %u: Timeout reached waiting on %s status event\",\n\t\tlinecard->slot_index,\n\t\tmlxsw_linecard_status_event_type_name[linecard->status_event_type_to]);\n\tmlxsw_linecard_provision_fail(linecard);\n\tmutex_unlock(&linecard->lock);\n}\n\nstatic int __mlxsw_linecard_fix_fsm_state(struct mlxsw_linecard *linecard)\n{\n\tdev_info(linecard->linecards->bus_info->dev, \"linecard %u: Clearing FSM state error\",\n\t\t linecard->slot_index);\n\tmlxsw_reg_mbct_pack(linecard->mbct_pl, linecard->slot_index,\n\t\t\t    MLXSW_REG_MBCT_OP_CLEAR_ERRORS, false);\n\treturn mlxsw_reg_write(linecard->linecards->mlxsw_core,\n\t\t\t       MLXSW_REG(mbct), linecard->mbct_pl);\n}\n\nstatic int mlxsw_linecard_fix_fsm_state(struct mlxsw_linecard *linecard,\n\t\t\t\t\tenum mlxsw_reg_mbct_fsm_state fsm_state)\n{\n\tif (fsm_state != MLXSW_REG_MBCT_FSM_STATE_ERROR)\n\t\treturn 0;\n\treturn __mlxsw_linecard_fix_fsm_state(linecard);\n}\n\nstatic int\nmlxsw_linecard_query_ini_status(struct mlxsw_linecard *linecard,\n\t\t\t\tenum mlxsw_reg_mbct_status *status,\n\t\t\t\tenum mlxsw_reg_mbct_fsm_state *fsm_state,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tmlxsw_reg_mbct_pack(linecard->mbct_pl, linecard->slot_index,\n\t\t\t    MLXSW_REG_MBCT_OP_QUERY_STATUS, false);\n\terr = mlxsw_reg_query(linecard->linecards->mlxsw_core, MLXSW_REG(mbct),\n\t\t\t      linecard->mbct_pl);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to query linecard INI status\");\n\t\treturn err;\n\t}\n\tmlxsw_reg_mbct_unpack(linecard->mbct_pl, NULL, status, fsm_state);\n\treturn err;\n}\n\nstatic int\nmlxsw_linecard_ini_transfer(struct mlxsw_core *mlxsw_core,\n\t\t\t    struct mlxsw_linecard *linecard,\n\t\t\t    const struct mlxsw_linecard_ini_file *ini_file,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tenum mlxsw_reg_mbct_fsm_state fsm_state;\n\tenum mlxsw_reg_mbct_status status;\n\tsize_t size_left;\n\tconst u8 *data;\n\tint err;\n\n\tsize_left = le16_to_cpu(ini_file->size);\n\tdata = ini_file->data;\n\twhile (size_left) {\n\t\tsize_t data_size = MLXSW_REG_MBCT_DATA_LEN;\n\t\tbool is_last = false;\n\n\t\tif (size_left <= MLXSW_REG_MBCT_DATA_LEN) {\n\t\t\tdata_size = size_left;\n\t\t\tis_last = true;\n\t\t}\n\n\t\tmlxsw_reg_mbct_pack(linecard->mbct_pl, linecard->slot_index,\n\t\t\t\t    MLXSW_REG_MBCT_OP_DATA_TRANSFER, false);\n\t\tmlxsw_reg_mbct_dt_pack(linecard->mbct_pl, data_size,\n\t\t\t\t       is_last, data);\n\t\terr = mlxsw_reg_write(mlxsw_core, MLXSW_REG(mbct),\n\t\t\t\t      linecard->mbct_pl);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to issue linecard INI data transfer\");\n\t\t\treturn err;\n\t\t}\n\t\tmlxsw_reg_mbct_unpack(linecard->mbct_pl, NULL,\n\t\t\t\t      &status, &fsm_state);\n\t\tif ((!is_last && status != MLXSW_REG_MBCT_STATUS_PART_DATA) ||\n\t\t    (is_last && status != MLXSW_REG_MBCT_STATUS_LAST_DATA)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to transfer linecard INI data\");\n\t\t\tmlxsw_linecard_fix_fsm_state(linecard, fsm_state);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsize_left -= data_size;\n\t\tdata += data_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmlxsw_linecard_ini_erase(struct mlxsw_core *mlxsw_core,\n\t\t\t struct mlxsw_linecard *linecard,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tenum mlxsw_reg_mbct_fsm_state fsm_state;\n\tenum mlxsw_reg_mbct_status status;\n\tint err;\n\n\tmlxsw_reg_mbct_pack(linecard->mbct_pl, linecard->slot_index,\n\t\t\t    MLXSW_REG_MBCT_OP_ERASE_INI_IMAGE, false);\n\terr = mlxsw_reg_write(mlxsw_core, MLXSW_REG(mbct),\n\t\t\t      linecard->mbct_pl);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to issue linecard INI erase\");\n\t\treturn err;\n\t}\n\tmlxsw_reg_mbct_unpack(linecard->mbct_pl, NULL, &status, &fsm_state);\n\tswitch (status) {\n\tcase MLXSW_REG_MBCT_STATUS_ERASE_COMPLETE:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tfallthrough;\n\tcase MLXSW_REG_MBCT_STATUS_ERASE_FAILED:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to erase linecard INI\");\n\t\tgoto fix_fsm_err_out;\n\tcase MLXSW_REG_MBCT_STATUS_ERROR_INI_IN_USE:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to erase linecard INI while being used\");\n\t\tgoto fix_fsm_err_out;\n\t}\n\treturn 0;\n\nfix_fsm_err_out:\n\tmlxsw_linecard_fix_fsm_state(linecard, fsm_state);\n\treturn -EINVAL;\n}\n\nstatic void mlxsw_linecard_bct_process(struct mlxsw_core *mlxsw_core,\n\t\t\t\t       const char *mbct_pl)\n{\n\tstruct mlxsw_linecards *linecards = mlxsw_core_linecards(mlxsw_core);\n\tenum mlxsw_reg_mbct_fsm_state fsm_state;\n\tenum mlxsw_reg_mbct_status status;\n\tstruct mlxsw_linecard *linecard;\n\tu8 slot_index;\n\n\tmlxsw_reg_mbct_unpack(mbct_pl, &slot_index, &status, &fsm_state);\n\tif (WARN_ON(slot_index > linecards->count))\n\t\treturn;\n\tlinecard = mlxsw_linecard_get(linecards, slot_index);\n\tmutex_lock(&linecard->lock);\n\tif (status == MLXSW_REG_MBCT_STATUS_ACTIVATION_FAILED) {\n\t\tdev_err(linecards->bus_info->dev, \"linecard %u: Failed to activate INI\",\n\t\t\tlinecard->slot_index);\n\t\tgoto fix_fsm_out;\n\t}\n\tmutex_unlock(&linecard->lock);\n\treturn;\n\nfix_fsm_out:\n\tmlxsw_linecard_fix_fsm_state(linecard, fsm_state);\n\tmlxsw_linecard_provision_fail(linecard);\n\tmutex_unlock(&linecard->lock);\n}\n\nstatic int\nmlxsw_linecard_ini_activate(struct mlxsw_core *mlxsw_core,\n\t\t\t    struct mlxsw_linecard *linecard,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tenum mlxsw_reg_mbct_fsm_state fsm_state;\n\tenum mlxsw_reg_mbct_status status;\n\tint err;\n\n\tmlxsw_reg_mbct_pack(linecard->mbct_pl, linecard->slot_index,\n\t\t\t    MLXSW_REG_MBCT_OP_ACTIVATE, true);\n\terr = mlxsw_reg_write(mlxsw_core, MLXSW_REG(mbct), linecard->mbct_pl);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to issue linecard INI activation\");\n\t\treturn err;\n\t}\n\tmlxsw_reg_mbct_unpack(linecard->mbct_pl, NULL, &status, &fsm_state);\n\tif (status == MLXSW_REG_MBCT_STATUS_ACTIVATION_FAILED) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to activate linecard INI\");\n\t\tgoto fix_fsm_err_out;\n\t}\n\n\treturn 0;\n\nfix_fsm_err_out:\n\tmlxsw_linecard_fix_fsm_state(linecard, fsm_state);\n\treturn -EINVAL;\n}\n\n#define MLXSW_LINECARD_INI_WAIT_RETRIES 10\n#define MLXSW_LINECARD_INI_WAIT_MS 500\n\nstatic int\nmlxsw_linecard_ini_in_use_wait(struct mlxsw_core *mlxsw_core,\n\t\t\t       struct mlxsw_linecard *linecard,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tenum mlxsw_reg_mbct_fsm_state fsm_state;\n\tenum mlxsw_reg_mbct_status status;\n\tunsigned int ini_wait_retries = 0;\n\tint err;\n\nquery_ini_status:\n\terr = mlxsw_linecard_query_ini_status(linecard, &status,\n\t\t\t\t\t      &fsm_state, extack);\n\tif (err)\n\t\treturn err;\n\n\tswitch (fsm_state) {\n\tcase MLXSW_REG_MBCT_FSM_STATE_INI_IN_USE:\n\t\tif (ini_wait_retries++ > MLXSW_LINECARD_INI_WAIT_RETRIES) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to wait for linecard INI to be unused\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmdelay(MLXSW_LINECARD_INI_WAIT_MS);\n\t\tgoto query_ini_status;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic bool mlxsw_linecard_port_selector(void *priv, u16 local_port)\n{\n\tstruct mlxsw_linecard *linecard = priv;\n\tstruct mlxsw_core *mlxsw_core;\n\n\tmlxsw_core = linecard->linecards->mlxsw_core;\n\treturn linecard == mlxsw_core_port_linecard_get(mlxsw_core, local_port);\n}\n\nstatic int mlxsw_linecard_provision(struct devlink_linecard *devlink_linecard,\n\t\t\t\t    void *priv, const char *type,\n\t\t\t\t    const void *type_priv,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tconst struct mlxsw_linecard_ini_file *ini_file = type_priv;\n\tstruct mlxsw_linecard *linecard = priv;\n\tstruct mlxsw_core *mlxsw_core;\n\tint err;\n\n\tmutex_lock(&linecard->lock);\n\n\tmlxsw_core = linecard->linecards->mlxsw_core;\n\n\terr = mlxsw_linecard_ini_erase(mlxsw_core, linecard, extack);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = mlxsw_linecard_ini_transfer(mlxsw_core, linecard,\n\t\t\t\t\t  ini_file, extack);\n\tif (err)\n\t\tgoto err_out;\n\n\tmlxsw_linecard_status_event_to_schedule(linecard,\n\t\t\t\t\t\tMLXSW_LINECARD_STATUS_EVENT_TYPE_PROVISION);\n\terr = mlxsw_linecard_ini_activate(mlxsw_core, linecard, extack);\n\tif (err)\n\t\tgoto err_out;\n\n\tgoto out;\n\nerr_out:\n\tmlxsw_linecard_provision_fail(linecard);\nout:\n\tmutex_unlock(&linecard->lock);\n\treturn err;\n}\n\nstatic int mlxsw_linecard_unprovision(struct devlink_linecard *devlink_linecard,\n\t\t\t\t      void *priv,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlxsw_linecard *linecard = priv;\n\tstruct mlxsw_core *mlxsw_core;\n\tint err;\n\n\tmutex_lock(&linecard->lock);\n\n\tmlxsw_core = linecard->linecards->mlxsw_core;\n\n\tmlxsw_core_ports_remove_selected(mlxsw_core,\n\t\t\t\t\t mlxsw_linecard_port_selector,\n\t\t\t\t\t linecard);\n\n\terr = mlxsw_linecard_ini_in_use_wait(mlxsw_core, linecard, extack);\n\tif (err)\n\t\tgoto err_out;\n\n\tmlxsw_linecard_status_event_to_schedule(linecard,\n\t\t\t\t\t\tMLXSW_LINECARD_STATUS_EVENT_TYPE_UNPROVISION);\n\terr = mlxsw_linecard_ini_erase(mlxsw_core, linecard, extack);\n\tif (err)\n\t\tgoto err_out;\n\n\tgoto out;\n\nerr_out:\n\tmlxsw_linecard_provision_fail(linecard);\nout:\n\tmutex_unlock(&linecard->lock);\n\treturn err;\n}\n\nstatic bool mlxsw_linecard_same_provision(struct devlink_linecard *devlink_linecard,\n\t\t\t\t\t  void *priv, const char *type,\n\t\t\t\t\t  const void *type_priv)\n{\n\tconst struct mlxsw_linecard_ini_file *ini_file = type_priv;\n\tstruct mlxsw_linecard *linecard = priv;\n\tbool ret;\n\n\tmutex_lock(&linecard->lock);\n\tret = linecard->hw_revision == be16_to_cpu(ini_file->format.hw_revision) &&\n\t      linecard->ini_version == be16_to_cpu(ini_file->format.ini_version);\n\tmutex_unlock(&linecard->lock);\n\treturn ret;\n}\n\nstatic unsigned int\nmlxsw_linecard_types_count(struct devlink_linecard *devlink_linecard,\n\t\t\t   void *priv)\n{\n\tstruct mlxsw_linecard *linecard = priv;\n\n\treturn linecard->linecards->types_info ?\n\t       linecard->linecards->types_info->count : 0;\n}\n\nstatic void mlxsw_linecard_types_get(struct devlink_linecard *devlink_linecard,\n\t\t\t\t     void *priv, unsigned int index,\n\t\t\t\t     const char **type, const void **type_priv)\n{\n\tstruct mlxsw_linecard_types_info *types_info;\n\tstruct mlxsw_linecard_ini_file *ini_file;\n\tstruct mlxsw_linecard *linecard = priv;\n\n\ttypes_info = linecard->linecards->types_info;\n\tif (WARN_ON_ONCE(!types_info))\n\t\treturn;\n\tini_file = types_info->ini_files[index];\n\t*type = ini_file->format.name;\n\t*type_priv = ini_file;\n}\n\nstatic const struct devlink_linecard_ops mlxsw_linecard_ops = {\n\t.provision = mlxsw_linecard_provision,\n\t.unprovision = mlxsw_linecard_unprovision,\n\t.same_provision = mlxsw_linecard_same_provision,\n\t.types_count = mlxsw_linecard_types_count,\n\t.types_get = mlxsw_linecard_types_get,\n};\n\nstruct mlxsw_linecard_status_event {\n\tstruct mlxsw_core *mlxsw_core;\n\tchar mddq_pl[MLXSW_REG_MDDQ_LEN];\n\tstruct work_struct work;\n};\n\nstatic void mlxsw_linecard_status_event_work(struct work_struct *work)\n{\n\tstruct mlxsw_linecard_status_event *event;\n\tstruct mlxsw_linecards *linecards;\n\tstruct mlxsw_core *mlxsw_core;\n\n\tevent = container_of(work, struct mlxsw_linecard_status_event, work);\n\tmlxsw_core = event->mlxsw_core;\n\tlinecards = mlxsw_core_linecards(mlxsw_core);\n\tmlxsw_linecard_status_process(linecards, NULL, event->mddq_pl);\n\tkfree(event);\n}\n\nstatic void\nmlxsw_linecard_status_listener_func(const struct mlxsw_reg_info *reg,\n\t\t\t\t    char *mddq_pl, void *priv)\n{\n\tstruct mlxsw_linecard_status_event *event;\n\tstruct mlxsw_core *mlxsw_core = priv;\n\n\tevent = kmalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event)\n\t\treturn;\n\tevent->mlxsw_core = mlxsw_core;\n\tmemcpy(event->mddq_pl, mddq_pl, sizeof(event->mddq_pl));\n\tINIT_WORK(&event->work, mlxsw_linecard_status_event_work);\n\tmlxsw_core_schedule_work(&event->work);\n}\n\nstruct mlxsw_linecard_bct_event {\n\tstruct mlxsw_core *mlxsw_core;\n\tchar mbct_pl[MLXSW_REG_MBCT_LEN];\n\tstruct work_struct work;\n};\n\nstatic void mlxsw_linecard_bct_event_work(struct work_struct *work)\n{\n\tstruct mlxsw_linecard_bct_event *event;\n\tstruct mlxsw_core *mlxsw_core;\n\n\tevent = container_of(work, struct mlxsw_linecard_bct_event, work);\n\tmlxsw_core = event->mlxsw_core;\n\tmlxsw_linecard_bct_process(mlxsw_core, event->mbct_pl);\n\tkfree(event);\n}\n\nstatic void\nmlxsw_linecard_bct_listener_func(const struct mlxsw_reg_info *reg,\n\t\t\t\t char *mbct_pl, void *priv)\n{\n\tstruct mlxsw_linecard_bct_event *event;\n\tstruct mlxsw_core *mlxsw_core = priv;\n\n\tevent = kmalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event)\n\t\treturn;\n\tevent->mlxsw_core = mlxsw_core;\n\tmemcpy(event->mbct_pl, mbct_pl, sizeof(event->mbct_pl));\n\tINIT_WORK(&event->work, mlxsw_linecard_bct_event_work);\n\tmlxsw_core_schedule_work(&event->work);\n}\n\nstatic const struct mlxsw_listener mlxsw_linecard_listener[] = {\n\tMLXSW_CORE_EVENTL(mlxsw_linecard_status_listener_func, DSDSC),\n\tMLXSW_CORE_EVENTL(mlxsw_linecard_bct_listener_func, BCTOE),\n};\n\nstatic int mlxsw_linecard_event_delivery_set(struct mlxsw_core *mlxsw_core,\n\t\t\t\t\t     struct mlxsw_linecard *linecard,\n\t\t\t\t\t     bool enable)\n{\n\tchar mddq_pl[MLXSW_REG_MDDQ_LEN];\n\n\tmlxsw_reg_mddq_slot_info_pack(mddq_pl, linecard->slot_index, enable);\n\treturn mlxsw_reg_write(mlxsw_core, MLXSW_REG(mddq), mddq_pl);\n}\n\nstatic int mlxsw_linecard_init(struct mlxsw_core *mlxsw_core,\n\t\t\t       struct mlxsw_linecards *linecards,\n\t\t\t       u8 slot_index)\n{\n\tstruct devlink_linecard *devlink_linecard;\n\tstruct mlxsw_linecard *linecard;\n\n\tlinecard = mlxsw_linecard_get(linecards, slot_index);\n\tlinecard->slot_index = slot_index;\n\tlinecard->linecards = linecards;\n\tmutex_init(&linecard->lock);\n\n\tdevlink_linecard = devl_linecard_create(priv_to_devlink(mlxsw_core),\n\t\t\t\t\t\tslot_index, &mlxsw_linecard_ops,\n\t\t\t\t\t\tlinecard);\n\tif (IS_ERR(devlink_linecard))\n\t\treturn PTR_ERR(devlink_linecard);\n\n\tlinecard->devlink_linecard = devlink_linecard;\n\tINIT_DELAYED_WORK(&linecard->status_event_to_dw,\n\t\t\t  &mlxsw_linecard_status_event_to_work);\n\n\treturn 0;\n}\n\nstatic void mlxsw_linecard_fini(struct mlxsw_core *mlxsw_core,\n\t\t\t\tstruct mlxsw_linecards *linecards,\n\t\t\t\tu8 slot_index)\n{\n\tstruct mlxsw_linecard *linecard;\n\n\tlinecard = mlxsw_linecard_get(linecards, slot_index);\n\tcancel_delayed_work_sync(&linecard->status_event_to_dw);\n\t \n\tmlxsw_core_flush_owq();\n\tif (linecard->active)\n\t\tmlxsw_linecard_active_clear(linecard);\n\tmlxsw_linecard_bdev_del(linecard);\n\tdevl_linecard_destroy(linecard->devlink_linecard);\n\tmutex_destroy(&linecard->lock);\n}\n\nstatic int\nmlxsw_linecard_event_delivery_init(struct mlxsw_core *mlxsw_core,\n\t\t\t\t   struct mlxsw_linecards *linecards,\n\t\t\t\t   u8 slot_index)\n{\n\tstruct mlxsw_linecard *linecard;\n\tint err;\n\n\tlinecard = mlxsw_linecard_get(linecards, slot_index);\n\terr = mlxsw_linecard_event_delivery_set(mlxsw_core, linecard, true);\n\tif (err)\n\t\treturn err;\n\n\terr = mlxsw_linecard_status_get_and_process(mlxsw_core, linecards,\n\t\t\t\t\t\t    linecard);\n\tif (err)\n\t\tgoto err_status_get_and_process;\n\n\treturn 0;\n\nerr_status_get_and_process:\n\tmlxsw_linecard_event_delivery_set(mlxsw_core, linecard, false);\n\treturn err;\n}\n\nstatic void\nmlxsw_linecard_event_delivery_fini(struct mlxsw_core *mlxsw_core,\n\t\t\t\t   struct mlxsw_linecards *linecards,\n\t\t\t\t   u8 slot_index)\n{\n\tstruct mlxsw_linecard *linecard;\n\n\tlinecard = mlxsw_linecard_get(linecards, slot_index);\n\tmlxsw_linecard_event_delivery_set(mlxsw_core, linecard, false);\n}\n\n \n\n#define MLXSW_LINECARDS_INI_BUNDLE_MAGIC \"NVLCINI+\"\n\nstatic int\nmlxsw_linecard_types_file_validate(struct mlxsw_linecards *linecards,\n\t\t\t\t   struct mlxsw_linecard_types_info *types_info)\n{\n\tsize_t magic_size = strlen(MLXSW_LINECARDS_INI_BUNDLE_MAGIC);\n\tstruct mlxsw_linecard_ini_file *ini_file;\n\tsize_t size = types_info->data_size;\n\tconst u8 *data = types_info->data;\n\tunsigned int count = 0;\n\tu16 ini_file_size;\n\n\tif (size < magic_size) {\n\t\tdev_warn(linecards->bus_info->dev, \"Invalid linecards INIs file size, smaller than magic size\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (memcmp(data, MLXSW_LINECARDS_INI_BUNDLE_MAGIC, magic_size)) {\n\t\tdev_warn(linecards->bus_info->dev, \"Invalid linecards INIs file magic pattern\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata += magic_size;\n\tsize -= magic_size;\n\n\twhile (size > 0) {\n\t\tif (size < sizeof(*ini_file)) {\n\t\t\tdev_warn(linecards->bus_info->dev, \"Linecards INIs file contains INI which is smaller than bare minimum\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tini_file = (struct mlxsw_linecard_ini_file *) data;\n\t\tini_file_size = le16_to_cpu(ini_file->size);\n\t\tif (ini_file_size + sizeof(__le16) > size) {\n\t\t\tdev_warn(linecards->bus_info->dev, \"Linecards INIs file appears to be truncated\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ini_file_size % 4) {\n\t\t\tdev_warn(linecards->bus_info->dev, \"Linecards INIs file contains INI with invalid size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdata += ini_file_size + sizeof(__le16);\n\t\tsize -= ini_file_size + sizeof(__le16);\n\t\tcount++;\n\t}\n\tif (!count) {\n\t\tdev_warn(linecards->bus_info->dev, \"Linecards INIs file does not contain any INI\\n\");\n\t\treturn -EINVAL;\n\t}\n\ttypes_info->count = count;\n\treturn 0;\n}\n\nstatic void\nmlxsw_linecard_types_file_parse(struct mlxsw_linecard_types_info *types_info)\n{\n\tsize_t magic_size = strlen(MLXSW_LINECARDS_INI_BUNDLE_MAGIC);\n\tsize_t size = types_info->data_size - magic_size;\n\tconst u8 *data = types_info->data + magic_size;\n\tstruct mlxsw_linecard_ini_file *ini_file;\n\tunsigned int count = 0;\n\tu16 ini_file_size;\n\tint i;\n\n\twhile (size) {\n\t\tini_file = (struct mlxsw_linecard_ini_file *) data;\n\t\tini_file_size = le16_to_cpu(ini_file->size);\n\t\tfor (i = 0; i < ini_file_size / 4; i++) {\n\t\t\tu32 *val = &((u32 *) ini_file->data)[i];\n\n\t\t\t*val = swab32(*val);\n\t\t}\n\t\ttypes_info->ini_files[count] = ini_file;\n\t\tdata += ini_file_size + sizeof(__le16);\n\t\tsize -= ini_file_size + sizeof(__le16);\n\t\tcount++;\n\t}\n}\n\n#define MLXSW_LINECARDS_INI_BUNDLE_FILENAME_FMT \\\n\t\"mellanox/lc_ini_bundle_%u_%u.bin\"\n#define MLXSW_LINECARDS_INI_BUNDLE_FILENAME_LEN \\\n\t(sizeof(MLXSW_LINECARDS_INI_BUNDLE_FILENAME_FMT) + 4)\n\nstatic int mlxsw_linecard_types_init(struct mlxsw_core *mlxsw_core,\n\t\t\t\t     struct mlxsw_linecards *linecards)\n{\n\tconst struct mlxsw_fw_rev *rev = &linecards->bus_info->fw_rev;\n\tchar filename[MLXSW_LINECARDS_INI_BUNDLE_FILENAME_LEN];\n\tstruct mlxsw_linecard_types_info *types_info;\n\tconst struct firmware *firmware;\n\tint err;\n\n\terr = snprintf(filename, sizeof(filename),\n\t\t       MLXSW_LINECARDS_INI_BUNDLE_FILENAME_FMT,\n\t\t       rev->minor, rev->subminor);\n\tWARN_ON(err >= sizeof(filename));\n\n\terr = request_firmware_direct(&firmware, filename,\n\t\t\t\t      linecards->bus_info->dev);\n\tif (err) {\n\t\tdev_warn(linecards->bus_info->dev, \"Could not request linecards INI file \\\"%s\\\", provisioning will not be possible\\n\",\n\t\t\t filename);\n\t\treturn 0;\n\t}\n\n\ttypes_info = kzalloc(sizeof(*types_info), GFP_KERNEL);\n\tif (!types_info) {\n\t\trelease_firmware(firmware);\n\t\treturn -ENOMEM;\n\t}\n\tlinecards->types_info = types_info;\n\n\ttypes_info->data_size = firmware->size;\n\ttypes_info->data = vmalloc(types_info->data_size);\n\tif (!types_info->data) {\n\t\terr = -ENOMEM;\n\t\trelease_firmware(firmware);\n\t\tgoto err_data_alloc;\n\t}\n\tmemcpy(types_info->data, firmware->data, types_info->data_size);\n\trelease_firmware(firmware);\n\n\terr = mlxsw_linecard_types_file_validate(linecards, types_info);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto err_type_file_file_validate;\n\t}\n\n\ttypes_info->ini_files = kmalloc_array(types_info->count,\n\t\t\t\t\t      sizeof(struct mlxsw_linecard_ini_file *),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!types_info->ini_files) {\n\t\terr = -ENOMEM;\n\t\tgoto err_ini_files_alloc;\n\t}\n\n\tmlxsw_linecard_types_file_parse(types_info);\n\n\treturn 0;\n\nerr_ini_files_alloc:\nerr_type_file_file_validate:\n\tvfree(types_info->data);\nerr_data_alloc:\n\tkfree(types_info);\n\treturn err;\n}\n\nstatic void mlxsw_linecard_types_fini(struct mlxsw_linecards *linecards)\n{\n\tstruct mlxsw_linecard_types_info *types_info = linecards->types_info;\n\n\tif (!types_info)\n\t\treturn;\n\tkfree(types_info->ini_files);\n\tvfree(types_info->data);\n\tkfree(types_info);\n}\n\nint mlxsw_linecards_init(struct mlxsw_core *mlxsw_core,\n\t\t\t const struct mlxsw_bus_info *bus_info)\n{\n\tchar mgpir_pl[MLXSW_REG_MGPIR_LEN];\n\tstruct mlxsw_linecards *linecards;\n\tu8 slot_count;\n\tint err;\n\tint i;\n\n\tmlxsw_reg_mgpir_pack(mgpir_pl, 0);\n\terr = mlxsw_reg_query(mlxsw_core, MLXSW_REG(mgpir), mgpir_pl);\n\tif (err)\n\t\treturn err;\n\n\tmlxsw_reg_mgpir_unpack(mgpir_pl, NULL, NULL, NULL,\n\t\t\t       NULL, &slot_count);\n\tif (!slot_count)\n\t\treturn 0;\n\n\tlinecards = vzalloc(struct_size(linecards, linecards, slot_count));\n\tif (!linecards)\n\t\treturn -ENOMEM;\n\tlinecards->count = slot_count;\n\tlinecards->mlxsw_core = mlxsw_core;\n\tlinecards->bus_info = bus_info;\n\tINIT_LIST_HEAD(&linecards->event_ops_list);\n\tmutex_init(&linecards->event_ops_list_lock);\n\n\terr = mlxsw_linecard_types_init(mlxsw_core, linecards);\n\tif (err)\n\t\tgoto err_types_init;\n\n\terr = mlxsw_core_traps_register(mlxsw_core, mlxsw_linecard_listener,\n\t\t\t\t\tARRAY_SIZE(mlxsw_linecard_listener),\n\t\t\t\t\tmlxsw_core);\n\tif (err)\n\t\tgoto err_traps_register;\n\n\terr = mlxsw_core_irq_event_handler_register(mlxsw_core,\n\t\t\t\t\t\t    mlxsw_linecards_irq_event_handler);\n\tif (err)\n\t\tgoto err_irq_event_handler_register;\n\n\tmlxsw_core_linecards_set(mlxsw_core, linecards);\n\n\tfor (i = 0; i < linecards->count; i++) {\n\t\terr = mlxsw_linecard_init(mlxsw_core, linecards, i + 1);\n\t\tif (err)\n\t\t\tgoto err_linecard_init;\n\t}\n\n\tfor (i = 0; i < linecards->count; i++) {\n\t\terr = mlxsw_linecard_event_delivery_init(mlxsw_core, linecards,\n\t\t\t\t\t\t\t i + 1);\n\t\tif (err)\n\t\t\tgoto err_linecard_event_delivery_init;\n\t}\n\n\treturn 0;\n\nerr_linecard_event_delivery_init:\n\tfor (i--; i >= 0; i--)\n\t\tmlxsw_linecard_event_delivery_fini(mlxsw_core, linecards, i + 1);\n\ti = linecards->count;\nerr_linecard_init:\n\tfor (i--; i >= 0; i--)\n\t\tmlxsw_linecard_fini(mlxsw_core, linecards, i + 1);\n\tmlxsw_core_irq_event_handler_unregister(mlxsw_core,\n\t\t\t\t\t\tmlxsw_linecards_irq_event_handler);\nerr_irq_event_handler_register:\n\tmlxsw_core_traps_unregister(mlxsw_core, mlxsw_linecard_listener,\n\t\t\t\t    ARRAY_SIZE(mlxsw_linecard_listener),\n\t\t\t\t    mlxsw_core);\nerr_traps_register:\n\tmlxsw_linecard_types_fini(linecards);\nerr_types_init:\n\tvfree(linecards);\n\treturn err;\n}\n\nvoid mlxsw_linecards_fini(struct mlxsw_core *mlxsw_core)\n{\n\tstruct mlxsw_linecards *linecards = mlxsw_core_linecards(mlxsw_core);\n\tint i;\n\n\tif (!linecards)\n\t\treturn;\n\tfor (i = 0; i < linecards->count; i++)\n\t\tmlxsw_linecard_event_delivery_fini(mlxsw_core, linecards, i + 1);\n\tfor (i = 0; i < linecards->count; i++)\n\t\tmlxsw_linecard_fini(mlxsw_core, linecards, i + 1);\n\tmlxsw_core_irq_event_handler_unregister(mlxsw_core,\n\t\t\t\t\t\tmlxsw_linecards_irq_event_handler);\n\tmlxsw_core_traps_unregister(mlxsw_core, mlxsw_linecard_listener,\n\t\t\t\t    ARRAY_SIZE(mlxsw_linecard_listener),\n\t\t\t\t    mlxsw_core);\n\tmlxsw_linecard_types_fini(linecards);\n\tmutex_destroy(&linecards->event_ops_list_lock);\n\tWARN_ON(!list_empty(&linecards->event_ops_list));\n\tvfree(linecards);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}