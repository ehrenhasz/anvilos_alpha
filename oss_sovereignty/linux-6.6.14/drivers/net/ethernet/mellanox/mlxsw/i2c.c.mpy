{
  "module_name": "i2c.c",
  "hash_id": "72ca700f78e6e0406594abb6390a0802e317b99bd8df3ea85ebbb548c141cc33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxsw/i2c.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_data/mlxreg.h>\n#include <linux/slab.h>\n\n#include \"cmd.h\"\n#include \"core.h\"\n#include \"i2c.h\"\n#include \"resources.h\"\n\n#define MLXSW_I2C_CIR2_BASE\t\t0x72000\n#define MLXSW_I2C_CIR_STATUS_OFF\t0x18\n#define MLXSW_I2C_CIR2_OFF_STATUS\t(MLXSW_I2C_CIR2_BASE + \\\n\t\t\t\t\t MLXSW_I2C_CIR_STATUS_OFF)\n#define MLXSW_I2C_OPMOD_SHIFT\t\t12\n#define MLXSW_I2C_EVENT_BIT_SHIFT\t22\n#define MLXSW_I2C_GO_BIT_SHIFT\t\t23\n#define MLXSW_I2C_CIR_CTRL_STATUS_SHIFT\t24\n#define MLXSW_I2C_EVENT_BIT\t\tBIT(MLXSW_I2C_EVENT_BIT_SHIFT)\n#define MLXSW_I2C_GO_BIT\t\tBIT(MLXSW_I2C_GO_BIT_SHIFT)\n#define MLXSW_I2C_GO_OPMODE\t\tBIT(MLXSW_I2C_OPMOD_SHIFT)\n#define MLXSW_I2C_SET_IMM_CMD\t\t(MLXSW_I2C_GO_OPMODE | \\\n\t\t\t\t\t MLXSW_CMD_OPCODE_QUERY_FW)\n#define MLXSW_I2C_PUSH_IMM_CMD\t\t(MLXSW_I2C_GO_BIT | \\\n\t\t\t\t\t MLXSW_I2C_SET_IMM_CMD)\n#define MLXSW_I2C_SET_CMD\t\t(MLXSW_CMD_OPCODE_ACCESS_REG)\n#define MLXSW_I2C_PUSH_CMD\t\t(MLXSW_I2C_GO_BIT | MLXSW_I2C_SET_CMD)\n#define MLXSW_I2C_TLV_HDR_SIZE\t\t0x10\n#define MLXSW_I2C_ADDR_WIDTH\t\t4\n#define MLXSW_I2C_PUSH_CMD_SIZE\t\t(MLXSW_I2C_ADDR_WIDTH + 4)\n#define MLXSW_I2C_SET_EVENT_CMD\t\t(MLXSW_I2C_EVENT_BIT)\n#define MLXSW_I2C_PUSH_EVENT_CMD\t(MLXSW_I2C_GO_BIT | \\\n\t\t\t\t\t MLXSW_I2C_SET_EVENT_CMD)\n#define MLXSW_I2C_READ_SEMA_SIZE\t4\n#define MLXSW_I2C_PREP_SIZE\t\t(MLXSW_I2C_ADDR_WIDTH + 28)\n#define MLXSW_I2C_MBOX_SIZE\t\t20\n#define MLXSW_I2C_MBOX_OUT_PARAM_OFF\t12\n#define MLXSW_I2C_MBOX_OFFSET_BITS\t20\n#define MLXSW_I2C_MBOX_SIZE_BITS\t12\n#define MLXSW_I2C_ADDR_BUF_SIZE\t\t4\n#define MLXSW_I2C_BLK_DEF\t\t32\n#define MLXSW_I2C_BLK_MAX\t\t100\n#define MLXSW_I2C_RETRY\t\t\t5\n#define MLXSW_I2C_TIMEOUT_MSECS\t\t5000\n#define MLXSW_I2C_MAX_DATA_SIZE\t\t256\n\n \n#define MLXSW_I2C_DEFAULT_IRQ\t\t17\n#define MLXSW_FAST_I2C_SLAVE\t\t0x37\n\n \nstruct mlxsw_i2c {\n\tstruct {\n\t\tu32 mb_size_in;\n\t\tu32 mb_off_in;\n\t\tu32 mb_size_out;\n\t\tu32 mb_off_out;\n\t\tstruct mutex lock;\n\t} cmd;\n\tstruct device *dev;\n\tstruct mlxsw_core *core;\n\tstruct mlxsw_bus_info bus_info;\n\tu16 block_size;\n\tstruct mlxreg_core_hotplug_platform_data *pdata;\n\tstruct work_struct irq_work;\n\tint irq;\n};\n\n#define MLXSW_I2C_READ_MSG(_client, _addr_buf, _buf, _len) {\t\\\n\t{ .addr = (_client)->addr,\t\t\t\t\\\n\t  .buf = (_addr_buf),\t\t\t\t\t\\\n\t  .len = MLXSW_I2C_ADDR_BUF_SIZE,\t\t\t\\\n\t  .flags = 0 },\t\t\t\t\t\t\\\n\t{ .addr = (_client)->addr,\t\t\t\t\\\n\t  .buf = (_buf),\t\t\t\t\t\\\n\t  .len = (_len),\t\t\t\t\t\\\n\t  .flags = I2C_M_RD } }\n\n#define MLXSW_I2C_WRITE_MSG(_client, _buf, _len)\t\t\\\n\t{ .addr = (_client)->addr,\t\t\t\t\\\n\t  .buf = (u8 *)(_buf),\t\t\t\t\t\\\n\t  .len = (_len),\t\t\t\t\t\\\n\t  .flags = 0 }\n\n \nstatic inline void\nmlxsw_i2c_convert_mbox(struct mlxsw_i2c *mlxsw_i2c, u8 *buf)\n{\n\tu32 tmp;\n\n\t \n\ttmp = be32_to_cpup((__be32 *) buf);\n\tmlxsw_i2c->cmd.mb_off_in = tmp &\n\t\t\t\t   GENMASK(MLXSW_I2C_MBOX_OFFSET_BITS - 1, 0);\n\tmlxsw_i2c->cmd.mb_size_in = (tmp & GENMASK(31,\n\t\t\t\t\tMLXSW_I2C_MBOX_OFFSET_BITS)) >>\n\t\t\t\t\tMLXSW_I2C_MBOX_OFFSET_BITS;\n\n\ttmp = be32_to_cpup((__be32 *) (buf + MLXSW_I2C_ADDR_WIDTH));\n\tmlxsw_i2c->cmd.mb_off_out = tmp &\n\t\t\t\t    GENMASK(MLXSW_I2C_MBOX_OFFSET_BITS - 1, 0);\n\tmlxsw_i2c->cmd.mb_size_out = (tmp & GENMASK(31,\n\t\t\t\t\tMLXSW_I2C_MBOX_OFFSET_BITS)) >>\n\t\t\t\t\tMLXSW_I2C_MBOX_OFFSET_BITS;\n}\n\n \nstatic inline int mlxsw_i2c_get_reg_size(u8 *in_mbox)\n{\n\tu16  tmp = be16_to_cpup((__be16 *) (in_mbox + MLXSW_I2C_TLV_HDR_SIZE));\n\n\treturn (tmp & 0x7ff) * 4 + MLXSW_I2C_TLV_HDR_SIZE;\n}\n\n \nstatic inline void mlxsw_i2c_set_slave_addr(u8 *buf, u32 off)\n{\n\t__be32 *val = (__be32 *) buf;\n\n\t*val = htonl(off);\n}\n\n \nstatic int mlxsw_i2c_wait_go_bit(struct i2c_client *client,\n\t\t\t\t struct mlxsw_i2c *mlxsw_i2c, u8 *p_status)\n{\n\tu8 addr_buf[MLXSW_I2C_ADDR_BUF_SIZE];\n\tu8 buf[MLXSW_I2C_READ_SEMA_SIZE];\n\tint len = MLXSW_I2C_READ_SEMA_SIZE;\n\tstruct i2c_msg read_sema[] =\n\t\tMLXSW_I2C_READ_MSG(client, addr_buf, buf, len);\n\tbool wait_done = false;\n\tunsigned long end;\n\tint i = 0, err;\n\n\tmlxsw_i2c_set_slave_addr(addr_buf, MLXSW_I2C_CIR2_OFF_STATUS);\n\n\tend = jiffies + msecs_to_jiffies(MLXSW_I2C_TIMEOUT_MSECS);\n\tdo {\n\t\tu32 ctrl;\n\n\t\terr = i2c_transfer(client->adapter, read_sema,\n\t\t\t\t   ARRAY_SIZE(read_sema));\n\n\t\tctrl = be32_to_cpu(*(__be32 *) buf);\n\t\tif (err == ARRAY_SIZE(read_sema)) {\n\t\t\tif (!(ctrl & MLXSW_I2C_GO_BIT)) {\n\t\t\t\twait_done = true;\n\t\t\t\t*p_status = ctrl >>\n\t\t\t\t\t    MLXSW_I2C_CIR_CTRL_STATUS_SHIFT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcond_resched();\n\t} while ((time_before(jiffies, end)) || (i++ < MLXSW_I2C_RETRY));\n\n\tif (wait_done) {\n\t\tif (*p_status)\n\t\t\terr = -EIO;\n\t} else {\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn err > 0 ? 0 : err;\n}\n\n \nstatic int mlxsw_i2c_write_cmd(struct i2c_client *client,\n\t\t\t       struct mlxsw_i2c *mlxsw_i2c,\n\t\t\t       int immediate)\n{\n\t__be32 push_cmd_buf[MLXSW_I2C_PUSH_CMD_SIZE / 4] = {\n\t\t0, cpu_to_be32(MLXSW_I2C_PUSH_IMM_CMD)\n\t};\n\t__be32 prep_cmd_buf[MLXSW_I2C_PREP_SIZE / 4] = {\n\t\t0, 0, 0, 0, 0, 0,\n\t\tcpu_to_be32(client->adapter->nr & 0xffff),\n\t\tcpu_to_be32(MLXSW_I2C_SET_IMM_CMD)\n\t};\n\tstruct i2c_msg push_cmd =\n\t\tMLXSW_I2C_WRITE_MSG(client, push_cmd_buf,\n\t\t\t\t    MLXSW_I2C_PUSH_CMD_SIZE);\n\tstruct i2c_msg prep_cmd =\n\t\tMLXSW_I2C_WRITE_MSG(client, prep_cmd_buf, MLXSW_I2C_PREP_SIZE);\n\tint err;\n\n\tif (!immediate) {\n\t\tpush_cmd_buf[1] = cpu_to_be32(MLXSW_I2C_PUSH_CMD);\n\t\tprep_cmd_buf[7] = cpu_to_be32(MLXSW_I2C_SET_CMD);\n\t}\n\tmlxsw_i2c_set_slave_addr((u8 *)prep_cmd_buf,\n\t\t\t\t MLXSW_I2C_CIR2_BASE);\n\tmlxsw_i2c_set_slave_addr((u8 *)push_cmd_buf,\n\t\t\t\t MLXSW_I2C_CIR2_OFF_STATUS);\n\n\t \n\terr = i2c_transfer(client->adapter, &prep_cmd, 1);\n\tif (err < 0)\n\t\treturn err;\n\telse if (err != 1)\n\t\treturn -EIO;\n\n\t \n\terr = i2c_transfer(client->adapter, &push_cmd, 1);\n\tif (err < 0)\n\t\treturn err;\n\telse if (err != 1)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int\nmlxsw_i2c_write_init_cmd(struct i2c_client *client,\n\t\t\t struct mlxsw_i2c *mlxsw_i2c, u16 opcode, u32 in_mod)\n{\n\t__be32 push_cmd_buf[MLXSW_I2C_PUSH_CMD_SIZE / 4] = {\n\t\t0, cpu_to_be32(MLXSW_I2C_PUSH_EVENT_CMD)\n\t};\n\t__be32 prep_cmd_buf[MLXSW_I2C_PREP_SIZE / 4] = {\n\t\t0, 0, 0, 0, 0, 0,\n\t\tcpu_to_be32(client->adapter->nr & 0xffff),\n\t\tcpu_to_be32(MLXSW_I2C_SET_EVENT_CMD)\n\t};\n\tstruct i2c_msg push_cmd =\n\t\tMLXSW_I2C_WRITE_MSG(client, push_cmd_buf,\n\t\t\t\t    MLXSW_I2C_PUSH_CMD_SIZE);\n\tstruct i2c_msg prep_cmd =\n\t\tMLXSW_I2C_WRITE_MSG(client, prep_cmd_buf, MLXSW_I2C_PREP_SIZE);\n\tu8 status;\n\tint err;\n\n\tpush_cmd_buf[1] = cpu_to_be32(MLXSW_I2C_PUSH_EVENT_CMD | opcode);\n\tprep_cmd_buf[3] = cpu_to_be32(in_mod);\n\tprep_cmd_buf[7] = cpu_to_be32(MLXSW_I2C_GO_BIT | opcode);\n\tmlxsw_i2c_set_slave_addr((u8 *)prep_cmd_buf,\n\t\t\t\t MLXSW_I2C_CIR2_BASE);\n\tmlxsw_i2c_set_slave_addr((u8 *)push_cmd_buf,\n\t\t\t\t MLXSW_I2C_CIR2_OFF_STATUS);\n\n\t \n\terr = i2c_transfer(client->adapter, &prep_cmd, 1);\n\tif (err < 0)\n\t\treturn err;\n\telse if (err != 1)\n\t\treturn -EIO;\n\n\t \n\terr = i2c_transfer(client->adapter, &push_cmd, 1);\n\tif (err < 0)\n\t\treturn err;\n\telse if (err != 1)\n\t\treturn -EIO;\n\n\t \n\terr = mlxsw_i2c_wait_go_bit(client, mlxsw_i2c, &status);\n\tif (err) {\n\t\tdev_err(&client->dev, \"HW semaphore is not released\");\n\t\treturn err;\n\t}\n\n\t \n\tif (status) {\n\t\tdev_err(&client->dev, \"Bad transaction completion status %x\\n\",\n\t\t\tstatus);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mlxsw_i2c_get_mbox(struct i2c_client *client,\n\t\t\t      struct mlxsw_i2c *mlxsw_i2c)\n{\n\tu8 addr_buf[MLXSW_I2C_ADDR_BUF_SIZE];\n\tu8 buf[MLXSW_I2C_MBOX_SIZE];\n\tstruct i2c_msg mbox_cmd[] =\n\t\tMLXSW_I2C_READ_MSG(client, addr_buf, buf, MLXSW_I2C_MBOX_SIZE);\n\tint err;\n\n\t \n\tmlxsw_i2c_set_slave_addr(addr_buf, MLXSW_I2C_CIR2_BASE);\n\terr = i2c_transfer(client->adapter, mbox_cmd, 2);\n\tif (err != 2) {\n\t\tdev_err(&client->dev, \"Could not obtain mail boxes\\n\");\n\t\tif (!err)\n\t\t\treturn -EIO;\n\t\telse\n\t\t\treturn err;\n\t}\n\n\t \n\tmlxsw_i2c_convert_mbox(mlxsw_i2c, &buf[MLXSW_I2C_MBOX_OUT_PARAM_OFF]);\n\n\treturn err;\n}\n\n \nstatic int\nmlxsw_i2c_write(struct device *dev, size_t in_mbox_size, u8 *in_mbox, int num,\n\t\tu8 *p_status)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mlxsw_i2c *mlxsw_i2c = i2c_get_clientdata(client);\n\tunsigned long timeout = msecs_to_jiffies(MLXSW_I2C_TIMEOUT_MSECS);\n\tint off = mlxsw_i2c->cmd.mb_off_in, chunk_size, i, j;\n\tunsigned long end;\n\tu8 *tran_buf;\n\tstruct i2c_msg write_tran =\n\t\tMLXSW_I2C_WRITE_MSG(client, NULL, MLXSW_I2C_PUSH_CMD_SIZE);\n\tint err;\n\n\ttran_buf = kmalloc(mlxsw_i2c->block_size + MLXSW_I2C_ADDR_BUF_SIZE,\n\t\t\t   GFP_KERNEL);\n\tif (!tran_buf)\n\t\treturn -ENOMEM;\n\n\twrite_tran.buf = tran_buf;\n\tfor (i = 0; i < num; i++) {\n\t\tchunk_size = (in_mbox_size > mlxsw_i2c->block_size) ?\n\t\t\t     mlxsw_i2c->block_size : in_mbox_size;\n\t\twrite_tran.len = MLXSW_I2C_ADDR_WIDTH + chunk_size;\n\t\tmlxsw_i2c_set_slave_addr(tran_buf, off);\n\t\tmemcpy(&tran_buf[MLXSW_I2C_ADDR_BUF_SIZE], in_mbox +\n\t\t       mlxsw_i2c->block_size * i, chunk_size);\n\n\t\tj = 0;\n\t\tend = jiffies + timeout;\n\t\tdo {\n\t\t\terr = i2c_transfer(client->adapter, &write_tran, 1);\n\t\t\tif (err == 1)\n\t\t\t\tbreak;\n\n\t\t\tcond_resched();\n\t\t} while ((time_before(jiffies, end)) ||\n\t\t\t (j++ < MLXSW_I2C_RETRY));\n\n\t\tif (err != 1) {\n\t\t\tif (!err) {\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto mlxsw_i2c_write_exit;\n\t\t\t}\n\t\t}\n\n\t\toff += chunk_size;\n\t\tin_mbox_size -= chunk_size;\n\t}\n\n\t \n\terr = mlxsw_i2c_write_cmd(client, mlxsw_i2c, 0);\n\tif (err) {\n\t\tdev_err(&client->dev, \"Could not start transaction\");\n\t\terr = -EIO;\n\t\tgoto mlxsw_i2c_write_exit;\n\t}\n\n\t \n\terr = mlxsw_i2c_wait_go_bit(client, mlxsw_i2c, p_status);\n\tif (err) {\n\t\tdev_err(&client->dev, \"HW semaphore is not released\");\n\t\tgoto mlxsw_i2c_write_exit;\n\t}\n\n\t \n\tif (*p_status) {\n\t\tdev_err(&client->dev, \"Bad transaction completion status %x\\n\",\n\t\t\t*p_status);\n\t\terr = -EIO;\n\t}\n\nmlxsw_i2c_write_exit:\n\tkfree(tran_buf);\n\treturn err;\n}\n\n \nstatic int\nmlxsw_i2c_cmd(struct device *dev, u16 opcode, u32 in_mod, size_t in_mbox_size,\n\t      u8 *in_mbox, size_t out_mbox_size, u8 *out_mbox, u8 *status)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct mlxsw_i2c *mlxsw_i2c = i2c_get_clientdata(client);\n\tunsigned long timeout = msecs_to_jiffies(MLXSW_I2C_TIMEOUT_MSECS);\n\tu8 tran_buf[MLXSW_I2C_ADDR_BUF_SIZE];\n\tint num, chunk_size, reg_size, i, j;\n\tint off = mlxsw_i2c->cmd.mb_off_out;\n\tunsigned long end;\n\tstruct i2c_msg read_tran[] =\n\t\tMLXSW_I2C_READ_MSG(client, tran_buf, NULL, 0);\n\tint err;\n\n\tWARN_ON(in_mbox_size % sizeof(u32) || out_mbox_size % sizeof(u32));\n\n\tif (in_mbox) {\n\t\treg_size = mlxsw_i2c_get_reg_size(in_mbox);\n\t\tnum = reg_size / mlxsw_i2c->block_size;\n\t\tif (reg_size % mlxsw_i2c->block_size)\n\t\t\tnum++;\n\n\t\tif (mutex_lock_interruptible(&mlxsw_i2c->cmd.lock) < 0) {\n\t\t\tdev_err(&client->dev, \"Could not acquire lock\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = mlxsw_i2c_write(dev, reg_size, in_mbox, num, status);\n\t\tif (err)\n\t\t\tgoto cmd_fail;\n\n\t\t \n\t\tif (!out_mbox) {\n\t\t\tmutex_unlock(&mlxsw_i2c->cmd.lock);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t \n\t\treg_size = MLXSW_I2C_MAX_DATA_SIZE;\n\t\tnum = DIV_ROUND_UP(reg_size, mlxsw_i2c->block_size);\n\n\t\tif (mutex_lock_interruptible(&mlxsw_i2c->cmd.lock) < 0) {\n\t\t\tdev_err(&client->dev, \"Could not acquire lock\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = mlxsw_i2c_write_init_cmd(client, mlxsw_i2c, opcode,\n\t\t\t\t\t       in_mod);\n\t\tif (err)\n\t\t\tgoto cmd_fail;\n\t}\n\n\t \n\tread_tran[1].buf = out_mbox;\n\tfor (i = 0; i < num; i++) {\n\t\tchunk_size = (reg_size > mlxsw_i2c->block_size) ?\n\t\t\t     mlxsw_i2c->block_size : reg_size;\n\t\tread_tran[1].len = chunk_size;\n\t\tmlxsw_i2c_set_slave_addr(tran_buf, off);\n\n\t\tj = 0;\n\t\tend = jiffies + timeout;\n\t\tdo {\n\t\t\terr = i2c_transfer(client->adapter, read_tran,\n\t\t\t\t\t   ARRAY_SIZE(read_tran));\n\t\t\tif (err == ARRAY_SIZE(read_tran))\n\t\t\t\tbreak;\n\n\t\t\tcond_resched();\n\t\t} while ((time_before(jiffies, end)) ||\n\t\t\t (j++ < MLXSW_I2C_RETRY));\n\n\t\tif (err != ARRAY_SIZE(read_tran)) {\n\t\t\tif (!err)\n\t\t\t\terr = -EIO;\n\n\t\t\tgoto cmd_fail;\n\t\t}\n\n\t\toff += chunk_size;\n\t\treg_size -= chunk_size;\n\t\tread_tran[1].buf += chunk_size;\n\t}\n\n\tmutex_unlock(&mlxsw_i2c->cmd.lock);\n\n\treturn 0;\n\ncmd_fail:\n\tmutex_unlock(&mlxsw_i2c->cmd.lock);\n\treturn err;\n}\n\nstatic int mlxsw_i2c_cmd_exec(void *bus_priv, u16 opcode, u8 opcode_mod,\n\t\t\t      u32 in_mod, bool out_mbox_direct,\n\t\t\t      char *in_mbox, size_t in_mbox_size,\n\t\t\t      char *out_mbox, size_t out_mbox_size,\n\t\t\t      u8 *status)\n{\n\tstruct mlxsw_i2c *mlxsw_i2c = bus_priv;\n\n\treturn mlxsw_i2c_cmd(mlxsw_i2c->dev, opcode, in_mod, in_mbox_size,\n\t\t\t     in_mbox, out_mbox_size, out_mbox, status);\n}\n\nstatic bool mlxsw_i2c_skb_transmit_busy(void *bus_priv,\n\t\t\t\t\tconst struct mlxsw_tx_info *tx_info)\n{\n\treturn false;\n}\n\nstatic int mlxsw_i2c_skb_transmit(void *bus_priv, struct sk_buff *skb,\n\t\t\t\t  const struct mlxsw_tx_info *tx_info)\n{\n\treturn 0;\n}\n\nstatic int\nmlxsw_i2c_init(void *bus_priv, struct mlxsw_core *mlxsw_core,\n\t       const struct mlxsw_config_profile *profile,\n\t       struct mlxsw_res *res)\n{\n\tstruct mlxsw_i2c *mlxsw_i2c = bus_priv;\n\tchar *mbox;\n\tint err;\n\n\tmlxsw_i2c->core = mlxsw_core;\n\n\tmbox = mlxsw_cmd_mbox_alloc();\n\tif (!mbox)\n\t\treturn -ENOMEM;\n\n\terr = mlxsw_cmd_query_fw(mlxsw_core, mbox);\n\tif (err)\n\t\tgoto mbox_put;\n\n\tmlxsw_i2c->bus_info.fw_rev.major =\n\t\tmlxsw_cmd_mbox_query_fw_fw_rev_major_get(mbox);\n\tmlxsw_i2c->bus_info.fw_rev.minor =\n\t\tmlxsw_cmd_mbox_query_fw_fw_rev_minor_get(mbox);\n\tmlxsw_i2c->bus_info.fw_rev.subminor =\n\t\tmlxsw_cmd_mbox_query_fw_fw_rev_subminor_get(mbox);\n\n\terr = mlxsw_core_resources_query(mlxsw_core, mbox, res);\n\nmbox_put:\n\tmlxsw_cmd_mbox_free(mbox);\n\treturn err;\n}\n\nstatic void mlxsw_i2c_fini(void *bus_priv)\n{\n\tstruct mlxsw_i2c *mlxsw_i2c = bus_priv;\n\n\tmlxsw_i2c->core = NULL;\n}\n\nstatic void mlxsw_i2c_work_handler(struct work_struct *work)\n{\n\tstruct mlxsw_i2c *mlxsw_i2c;\n\n\tmlxsw_i2c = container_of(work, struct mlxsw_i2c, irq_work);\n\tmlxsw_core_irq_event_handlers_call(mlxsw_i2c->core);\n}\n\nstatic irqreturn_t mlxsw_i2c_irq_handler(int irq, void *dev)\n{\n\tstruct mlxsw_i2c *mlxsw_i2c = dev;\n\n\tmlxsw_core_schedule_work(&mlxsw_i2c->irq_work);\n\n\t \n\treturn IRQ_NONE;\n}\n\nstatic int mlxsw_i2c_irq_init(struct mlxsw_i2c *mlxsw_i2c, u8 addr)\n{\n\tint err;\n\n\t \n\tif (!IS_REACHABLE(CONFIG_MLXREG_HOTPLUG))\n\t\treturn 0;\n\n\t \n\tif (mlxsw_i2c->pdata && mlxsw_i2c->pdata->irq)\n\t\tmlxsw_i2c->irq = mlxsw_i2c->pdata->irq;\n\telse if (addr == MLXSW_FAST_I2C_SLAVE)\n\t\tmlxsw_i2c->irq = MLXSW_I2C_DEFAULT_IRQ;\n\n\tif (!mlxsw_i2c->irq)\n\t\treturn 0;\n\n\tINIT_WORK(&mlxsw_i2c->irq_work, mlxsw_i2c_work_handler);\n\terr = request_irq(mlxsw_i2c->irq, mlxsw_i2c_irq_handler,\n\t\t\t  IRQF_TRIGGER_FALLING | IRQF_SHARED, \"mlxsw-i2c\",\n\t\t\t  mlxsw_i2c);\n\tif (err) {\n\t\tdev_err(mlxsw_i2c->bus_info.dev, \"Failed to request irq: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void mlxsw_i2c_irq_fini(struct mlxsw_i2c *mlxsw_i2c)\n{\n\tif (!IS_REACHABLE(CONFIG_MLXREG_HOTPLUG) || !mlxsw_i2c->irq)\n\t\treturn;\n\tcancel_work_sync(&mlxsw_i2c->irq_work);\n\tfree_irq(mlxsw_i2c->irq, mlxsw_i2c);\n}\n\nstatic const struct mlxsw_bus mlxsw_i2c_bus = {\n\t.kind\t\t\t= \"i2c\",\n\t.init\t\t\t= mlxsw_i2c_init,\n\t.fini\t\t\t= mlxsw_i2c_fini,\n\t.skb_transmit_busy\t= mlxsw_i2c_skb_transmit_busy,\n\t.skb_transmit\t\t= mlxsw_i2c_skb_transmit,\n\t.cmd_exec\t\t= mlxsw_i2c_cmd_exec,\n};\n\nstatic int mlxsw_i2c_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tconst struct i2c_adapter_quirks *quirks = client->adapter->quirks;\n\tstruct mlxsw_i2c *mlxsw_i2c;\n\tu8 status;\n\tint err;\n\n\tmlxsw_i2c = devm_kzalloc(&client->dev, sizeof(*mlxsw_i2c), GFP_KERNEL);\n\tif (!mlxsw_i2c)\n\t\treturn -ENOMEM;\n\n\tif (quirks) {\n\t\tif ((quirks->max_read_len &&\n\t\t     quirks->max_read_len < MLXSW_I2C_BLK_DEF) ||\n\t\t    (quirks->max_write_len &&\n\t\t     quirks->max_write_len < MLXSW_I2C_BLK_DEF)) {\n\t\t\tdev_err(&client->dev, \"Insufficient transaction buffer length\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tmlxsw_i2c->block_size = min_t(u16, MLXSW_I2C_BLK_MAX,\n\t\t\t\t\t      min_t(u16, quirks->max_read_len,\n\t\t\t\t\t\t    quirks->max_write_len));\n\t} else {\n\t\tmlxsw_i2c->block_size = MLXSW_I2C_BLK_DEF;\n\t}\n\n\ti2c_set_clientdata(client, mlxsw_i2c);\n\tmutex_init(&mlxsw_i2c->cmd.lock);\n\n\t \n\n\t \n\terr = mlxsw_i2c_write_cmd(client, mlxsw_i2c, 1);\n\tif (err) {\n\t\tdev_err(&client->dev, \"Could not start transaction\");\n\t\tgoto errout;\n\t}\n\n\t \n\terr = mlxsw_i2c_wait_go_bit(client, mlxsw_i2c, &status);\n\tif (err) {\n\t\tdev_err(&client->dev, \"HW semaphore is not released\");\n\t\tgoto errout;\n\t}\n\n\t \n\tif (status) {\n\t\tdev_err(&client->dev, \"Bad transaction completion status %x\\n\",\n\t\t\tstatus);\n\t\terr = -EIO;\n\t\tgoto errout;\n\t}\n\n\t \n\terr = mlxsw_i2c_get_mbox(client, mlxsw_i2c);\n\tif (err < 0) {\n\t\tdev_err(&client->dev, \"Fail to get mailboxes\\n\");\n\t\tgoto errout;\n\t}\n\n\tdev_info(&client->dev, \"%s mb size=%x off=0x%08x out mb size=%x off=0x%08x\\n\",\n\t\t id->name, mlxsw_i2c->cmd.mb_size_in,\n\t\t mlxsw_i2c->cmd.mb_off_in, mlxsw_i2c->cmd.mb_size_out,\n\t\t mlxsw_i2c->cmd.mb_off_out);\n\n\t \n\tmlxsw_i2c->bus_info.device_kind = id->name;\n\tmlxsw_i2c->bus_info.device_name = client->name;\n\tmlxsw_i2c->bus_info.dev = &client->dev;\n\tmlxsw_i2c->bus_info.low_frequency = true;\n\tmlxsw_i2c->dev = &client->dev;\n\tmlxsw_i2c->pdata = client->dev.platform_data;\n\n\terr = mlxsw_i2c_irq_init(mlxsw_i2c, client->addr);\n\tif (err)\n\t\tgoto errout;\n\n\terr = mlxsw_core_bus_device_register(&mlxsw_i2c->bus_info,\n\t\t\t\t\t     &mlxsw_i2c_bus, mlxsw_i2c, false,\n\t\t\t\t\t     NULL, NULL);\n\tif (err) {\n\t\tdev_err(&client->dev, \"Fail to register core bus\\n\");\n\t\tgoto err_bus_device_register;\n\t}\n\n\treturn 0;\n\nerr_bus_device_register:\n\tmlxsw_i2c_irq_fini(mlxsw_i2c);\nerrout:\n\tmutex_destroy(&mlxsw_i2c->cmd.lock);\n\ti2c_set_clientdata(client, NULL);\n\n\treturn err;\n}\n\nstatic void mlxsw_i2c_remove(struct i2c_client *client)\n{\n\tstruct mlxsw_i2c *mlxsw_i2c = i2c_get_clientdata(client);\n\n\tmlxsw_core_bus_device_unregister(mlxsw_i2c->core, false);\n\tmlxsw_i2c_irq_fini(mlxsw_i2c);\n\tmutex_destroy(&mlxsw_i2c->cmd.lock);\n}\n\nint mlxsw_i2c_driver_register(struct i2c_driver *i2c_driver)\n{\n\ti2c_driver->probe = mlxsw_i2c_probe;\n\ti2c_driver->remove = mlxsw_i2c_remove;\n\treturn i2c_add_driver(i2c_driver);\n}\nEXPORT_SYMBOL(mlxsw_i2c_driver_register);\n\nvoid mlxsw_i2c_driver_unregister(struct i2c_driver *i2c_driver)\n{\n\ti2c_del_driver(i2c_driver);\n}\nEXPORT_SYMBOL(mlxsw_i2c_driver_unregister);\n\nMODULE_AUTHOR(\"Vadim Pasternak <vadimp@mellanox.com>\");\nMODULE_DESCRIPTION(\"Mellanox switch I2C interface driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}