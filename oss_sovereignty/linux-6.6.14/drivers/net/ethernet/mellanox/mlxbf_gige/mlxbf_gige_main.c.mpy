{
  "module_name": "mlxbf_gige_main.c",
  "hash_id": "fcb6ded3a9e37e4316bdfb7c3eabff9fe6b1b341e852dc2d8aa1cc2318bcb1ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlxbf_gige/mlxbf_gige_main.c",
  "human_readable_source": "\n\n \n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/etherdevice.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/skbuff.h>\n\n#include \"mlxbf_gige.h\"\n#include \"mlxbf_gige_regs.h\"\n\n \nstruct sk_buff *mlxbf_gige_alloc_skb(struct mlxbf_gige *priv,\n\t\t\t\t     unsigned int map_len,\n\t\t\t\t     dma_addr_t *buf_dma,\n\t\t\t\t     enum dma_data_direction dir)\n{\n\tstruct sk_buff *skb;\n\tu64 addr, offset;\n\n\t \n\tskb = netdev_alloc_skb(priv->netdev, MLXBF_GIGE_DEFAULT_BUF_SZ * 2);\n\tif (!skb)\n\t\treturn NULL;\n\n\t \n\taddr = (long)skb->data;\n\toffset = (addr + MLXBF_GIGE_DEFAULT_BUF_SZ - 1) &\n\t\t~(MLXBF_GIGE_DEFAULT_BUF_SZ - 1);\n\toffset -= addr;\n\tif (offset)\n\t\tskb_reserve(skb, offset);\n\n\t \n\t*buf_dma = dma_map_single(priv->dev, skb->data, map_len, dir);\n\tif (dma_mapping_error(priv->dev, *buf_dma)) {\n\t\tdev_kfree_skb(skb);\n\t\t*buf_dma = (dma_addr_t)0;\n\t\treturn NULL;\n\t}\n\n\treturn skb;\n}\n\nstatic void mlxbf_gige_initial_mac(struct mlxbf_gige *priv)\n{\n\tu8 mac[ETH_ALEN];\n\tu64 local_mac;\n\n\teth_zero_addr(mac);\n\tmlxbf_gige_get_mac_rx_filter(priv, MLXBF_GIGE_LOCAL_MAC_FILTER_IDX,\n\t\t\t\t     &local_mac);\n\tu64_to_ether_addr(local_mac, mac);\n\n\tif (is_valid_ether_addr(mac)) {\n\t\teth_hw_addr_set(priv->netdev, mac);\n\t} else {\n\t\t \n\t\teth_hw_addr_random(priv->netdev);\n\t}\n\n\tlocal_mac = ether_addr_to_u64(priv->netdev->dev_addr);\n\tmlxbf_gige_set_mac_rx_filter(priv, MLXBF_GIGE_LOCAL_MAC_FILTER_IDX,\n\t\t\t\t     local_mac);\n}\n\nstatic void mlxbf_gige_cache_stats(struct mlxbf_gige *priv)\n{\n\tstruct mlxbf_gige_stats *p;\n\n\t \n\tp = &priv->stats;\n\tp->rx_din_dropped_pkts += readq(priv->base +\n\t\t\t\t\tMLXBF_GIGE_RX_DIN_DROP_COUNTER);\n\tp->rx_filter_passed_pkts += readq(priv->base +\n\t\t\t\t\t  MLXBF_GIGE_RX_PASS_COUNTER_ALL);\n\tp->rx_filter_discard_pkts += readq(priv->base +\n\t\t\t\t\t   MLXBF_GIGE_RX_DISC_COUNTER_ALL);\n}\n\nstatic int mlxbf_gige_clean_port(struct mlxbf_gige *priv)\n{\n\tu64 control;\n\tu64 temp;\n\tint err;\n\n\t \n\tcontrol = readq(priv->base + MLXBF_GIGE_CONTROL);\n\tcontrol |= MLXBF_GIGE_CONTROL_CLEAN_PORT_EN;\n\twriteq(control, priv->base + MLXBF_GIGE_CONTROL);\n\n\t \n\tmb();\n\n\terr = readq_poll_timeout_atomic(priv->base + MLXBF_GIGE_STATUS, temp,\n\t\t\t\t\t(temp & MLXBF_GIGE_STATUS_READY),\n\t\t\t\t\t100, 100000);\n\n\t \n\tcontrol = readq(priv->base + MLXBF_GIGE_CONTROL);\n\tcontrol &= ~MLXBF_GIGE_CONTROL_CLEAN_PORT_EN;\n\twriteq(control, priv->base + MLXBF_GIGE_CONTROL);\n\n\treturn err;\n}\n\nstatic int mlxbf_gige_open(struct net_device *netdev)\n{\n\tstruct mlxbf_gige *priv = netdev_priv(netdev);\n\tstruct phy_device *phydev = netdev->phydev;\n\tu64 control;\n\tu64 int_en;\n\tint err;\n\n\t \n\tcontrol = readq(priv->base + MLXBF_GIGE_CONTROL);\n\tcontrol |= MLXBF_GIGE_CONTROL_PORT_EN;\n\twriteq(control, priv->base + MLXBF_GIGE_CONTROL);\n\n\terr = mlxbf_gige_request_irqs(priv);\n\tif (err)\n\t\treturn err;\n\tmlxbf_gige_cache_stats(priv);\n\terr = mlxbf_gige_clean_port(priv);\n\tif (err)\n\t\tgoto free_irqs;\n\n\t \n\tpriv->valid_polarity = 0;\n\n\tphy_start(phydev);\n\n\terr = mlxbf_gige_tx_init(priv);\n\tif (err)\n\t\tgoto free_irqs;\n\terr = mlxbf_gige_rx_init(priv);\n\tif (err)\n\t\tgoto tx_deinit;\n\n\tnetif_napi_add(netdev, &priv->napi, mlxbf_gige_poll);\n\tnapi_enable(&priv->napi);\n\tnetif_start_queue(netdev);\n\n\t \n\tint_en = MLXBF_GIGE_INT_EN_HW_ACCESS_ERROR |\n\t\t MLXBF_GIGE_INT_EN_TX_CHECKSUM_INPUTS |\n\t\t MLXBF_GIGE_INT_EN_TX_SMALL_FRAME_SIZE |\n\t\t MLXBF_GIGE_INT_EN_TX_PI_CI_EXCEED_WQ_SIZE |\n\t\t MLXBF_GIGE_INT_EN_SW_CONFIG_ERROR |\n\t\t MLXBF_GIGE_INT_EN_SW_ACCESS_ERROR |\n\t\t MLXBF_GIGE_INT_EN_RX_RECEIVE_PACKET;\n\n\t \n\tmb();\n\n\twriteq(int_en, priv->base + MLXBF_GIGE_INT_EN);\n\n\treturn 0;\n\ntx_deinit:\n\tmlxbf_gige_tx_deinit(priv);\n\nfree_irqs:\n\tmlxbf_gige_free_irqs(priv);\n\treturn err;\n}\n\nstatic int mlxbf_gige_stop(struct net_device *netdev)\n{\n\tstruct mlxbf_gige *priv = netdev_priv(netdev);\n\n\twriteq(0, priv->base + MLXBF_GIGE_INT_EN);\n\tnetif_stop_queue(netdev);\n\tnapi_disable(&priv->napi);\n\tnetif_napi_del(&priv->napi);\n\tmlxbf_gige_free_irqs(priv);\n\n\tphy_stop(netdev->phydev);\n\n\tmlxbf_gige_rx_deinit(priv);\n\tmlxbf_gige_tx_deinit(priv);\n\tmlxbf_gige_cache_stats(priv);\n\tmlxbf_gige_clean_port(priv);\n\n\treturn 0;\n}\n\nstatic int mlxbf_gige_eth_ioctl(struct net_device *netdev,\n\t\t\t\tstruct ifreq *ifr, int cmd)\n{\n\tif (!(netif_running(netdev)))\n\t\treturn -EINVAL;\n\n\treturn phy_mii_ioctl(netdev->phydev, ifr, cmd);\n}\n\nstatic void mlxbf_gige_set_rx_mode(struct net_device *netdev)\n{\n\tstruct mlxbf_gige *priv = netdev_priv(netdev);\n\tbool new_promisc_enabled;\n\n\tnew_promisc_enabled = netdev->flags & IFF_PROMISC;\n\n\t \n\tif (new_promisc_enabled != priv->promisc_enabled) {\n\t\tpriv->promisc_enabled = new_promisc_enabled;\n\n\t\tif (new_promisc_enabled)\n\t\t\tmlxbf_gige_enable_promisc(priv);\n\t\telse\n\t\t\tmlxbf_gige_disable_promisc(priv);\n\t}\n}\n\nstatic void mlxbf_gige_get_stats64(struct net_device *netdev,\n\t\t\t\t   struct rtnl_link_stats64 *stats)\n{\n\tstruct mlxbf_gige *priv = netdev_priv(netdev);\n\n\tnetdev_stats_to_stats64(stats, &netdev->stats);\n\n\tstats->rx_length_errors = priv->stats.rx_truncate_errors;\n\tstats->rx_fifo_errors = priv->stats.rx_din_dropped_pkts +\n\t\t\t\treadq(priv->base + MLXBF_GIGE_RX_DIN_DROP_COUNTER);\n\tstats->rx_crc_errors = priv->stats.rx_mac_errors;\n\tstats->rx_errors = stats->rx_length_errors +\n\t\t\t   stats->rx_fifo_errors +\n\t\t\t   stats->rx_crc_errors;\n\n\tstats->tx_fifo_errors = priv->stats.tx_fifo_full;\n\tstats->tx_errors = stats->tx_fifo_errors;\n}\n\nstatic const struct net_device_ops mlxbf_gige_netdev_ops = {\n\t.ndo_open\t\t= mlxbf_gige_open,\n\t.ndo_stop\t\t= mlxbf_gige_stop,\n\t.ndo_start_xmit\t\t= mlxbf_gige_start_xmit,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_eth_ioctl\t\t= mlxbf_gige_eth_ioctl,\n\t.ndo_set_rx_mode        = mlxbf_gige_set_rx_mode,\n\t.ndo_get_stats64        = mlxbf_gige_get_stats64,\n};\n\nstatic void mlxbf_gige_bf2_adjust_link(struct net_device *netdev)\n{\n\tstruct phy_device *phydev = netdev->phydev;\n\n\tphy_print_status(phydev);\n}\n\nstatic void mlxbf_gige_bf3_adjust_link(struct net_device *netdev)\n{\n\tstruct mlxbf_gige *priv = netdev_priv(netdev);\n\tstruct phy_device *phydev = netdev->phydev;\n\tu8 sgmii_mode;\n\tu16 ipg_size;\n\tu32 val;\n\n\tif (phydev->link && phydev->speed != priv->prev_speed) {\n\t\tswitch (phydev->speed) {\n\t\tcase 1000:\n\t\t\tipg_size = MLXBF_GIGE_1G_IPG_SIZE;\n\t\t\tsgmii_mode = MLXBF_GIGE_1G_SGMII_MODE;\n\t\t\tbreak;\n\t\tcase 100:\n\t\t\tipg_size = MLXBF_GIGE_100M_IPG_SIZE;\n\t\t\tsgmii_mode = MLXBF_GIGE_100M_SGMII_MODE;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tipg_size = MLXBF_GIGE_10M_IPG_SIZE;\n\t\t\tsgmii_mode = MLXBF_GIGE_10M_SGMII_MODE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\n\t\tval = readl(priv->plu_base + MLXBF_GIGE_PLU_TX_REG0);\n\t\tval &= ~(MLXBF_GIGE_PLU_TX_IPG_SIZE_MASK | MLXBF_GIGE_PLU_TX_SGMII_MODE_MASK);\n\t\tval |= FIELD_PREP(MLXBF_GIGE_PLU_TX_IPG_SIZE_MASK, ipg_size);\n\t\tval |= FIELD_PREP(MLXBF_GIGE_PLU_TX_SGMII_MODE_MASK, sgmii_mode);\n\t\twritel(val, priv->plu_base + MLXBF_GIGE_PLU_TX_REG0);\n\n\t\tval = readl(priv->plu_base + MLXBF_GIGE_PLU_RX_REG0);\n\t\tval &= ~MLXBF_GIGE_PLU_RX_SGMII_MODE_MASK;\n\t\tval |= FIELD_PREP(MLXBF_GIGE_PLU_RX_SGMII_MODE_MASK, sgmii_mode);\n\t\twritel(val, priv->plu_base + MLXBF_GIGE_PLU_RX_REG0);\n\n\t\tpriv->prev_speed = phydev->speed;\n\t}\n\n\tphy_print_status(phydev);\n}\n\nstatic void mlxbf_gige_bf2_set_phy_link_mode(struct phy_device *phydev)\n{\n\t \n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_1000baseT_Half_BIT);\n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_100baseT_Full_BIT);\n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_100baseT_Half_BIT);\n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_10baseT_Full_BIT);\n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_10baseT_Half_BIT);\n\n\t \n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydev->advertising);\n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, phydev->advertising);\n}\n\nstatic void mlxbf_gige_bf3_set_phy_link_mode(struct phy_device *phydev)\n{\n\t \n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_1000baseT_Half_BIT);\n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_100baseT_Half_BIT);\n\tphy_remove_link_mode(phydev, ETHTOOL_LINK_MODE_10baseT_Half_BIT);\n\n\t \n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydev->advertising);\n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, phydev->advertising);\n}\n\nstatic struct mlxbf_gige_link_cfg mlxbf_gige_link_cfgs[] = {\n\t[MLXBF_GIGE_VERSION_BF2] = {\n\t\t.set_phy_link_mode = mlxbf_gige_bf2_set_phy_link_mode,\n\t\t.adjust_link = mlxbf_gige_bf2_adjust_link,\n\t\t.phy_mode = PHY_INTERFACE_MODE_GMII\n\t},\n\t[MLXBF_GIGE_VERSION_BF3] = {\n\t\t.set_phy_link_mode = mlxbf_gige_bf3_set_phy_link_mode,\n\t\t.adjust_link = mlxbf_gige_bf3_adjust_link,\n\t\t.phy_mode = PHY_INTERFACE_MODE_SGMII\n\t}\n};\n\nstatic int mlxbf_gige_probe(struct platform_device *pdev)\n{\n\tstruct phy_device *phydev;\n\tstruct net_device *netdev;\n\tstruct mlxbf_gige *priv;\n\tvoid __iomem *llu_base;\n\tvoid __iomem *plu_base;\n\tvoid __iomem *base;\n\tint addr, phy_irq;\n\tint err;\n\n\tbase = devm_platform_ioremap_resource(pdev, MLXBF_GIGE_RES_MAC);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tllu_base = devm_platform_ioremap_resource(pdev, MLXBF_GIGE_RES_LLU);\n\tif (IS_ERR(llu_base))\n\t\treturn PTR_ERR(llu_base);\n\n\tplu_base = devm_platform_ioremap_resource(pdev, MLXBF_GIGE_RES_PLU);\n\tif (IS_ERR(plu_base))\n\t\treturn PTR_ERR(plu_base);\n\n\tnetdev = devm_alloc_etherdev(&pdev->dev, sizeof(*priv));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\tnetdev->netdev_ops = &mlxbf_gige_netdev_ops;\n\tnetdev->ethtool_ops = &mlxbf_gige_ethtool_ops;\n\tpriv = netdev_priv(netdev);\n\tpriv->netdev = netdev;\n\n\tplatform_set_drvdata(pdev, priv);\n\tpriv->dev = &pdev->dev;\n\tpriv->pdev = pdev;\n\n\tspin_lock_init(&priv->lock);\n\n\tpriv->hw_version = readq(base + MLXBF_GIGE_VERSION);\n\n\t \n\terr = mlxbf_gige_mdio_probe(pdev, priv);\n\tif (err)\n\t\treturn err;\n\n\tpriv->base = base;\n\tpriv->llu_base = llu_base;\n\tpriv->plu_base = plu_base;\n\n\tpriv->rx_q_entries = MLXBF_GIGE_DEFAULT_RXQ_SZ;\n\tpriv->tx_q_entries = MLXBF_GIGE_DEFAULT_TXQ_SZ;\n\n\t \n\tmlxbf_gige_initial_mac(priv);\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"DMA configuration failed: 0x%x\\n\", err);\n\t\tgoto out;\n\t}\n\n\tpriv->error_irq = platform_get_irq(pdev, MLXBF_GIGE_ERROR_INTR_IDX);\n\tpriv->rx_irq = platform_get_irq(pdev, MLXBF_GIGE_RECEIVE_PKT_INTR_IDX);\n\tpriv->llu_plu_irq = platform_get_irq(pdev, MLXBF_GIGE_LLU_PLU_INTR_IDX);\n\n\tphy_irq = acpi_dev_gpio_irq_get_by(ACPI_COMPANION(&pdev->dev), \"phy-gpios\", 0);\n\tif (phy_irq < 0) {\n\t\tdev_err(&pdev->dev, \"Error getting PHY irq. Use polling instead\");\n\t\tphy_irq = PHY_POLL;\n\t}\n\n\tphydev = phy_find_first(priv->mdiobus);\n\tif (!phydev) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\taddr = phydev->mdio.addr;\n\tpriv->mdiobus->irq[addr] = phy_irq;\n\tphydev->irq = phy_irq;\n\n\terr = phy_connect_direct(netdev, phydev,\n\t\t\t\t mlxbf_gige_link_cfgs[priv->hw_version].adjust_link,\n\t\t\t\t mlxbf_gige_link_cfgs[priv->hw_version].phy_mode);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Could not attach to PHY\\n\");\n\t\tgoto out;\n\t}\n\n\tmlxbf_gige_link_cfgs[priv->hw_version].set_phy_link_mode(phydev);\n\n\t \n\tphy_attached_info(phydev);\n\n\terr = register_netdev(netdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to register netdev\\n\");\n\t\tphy_disconnect(phydev);\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tmlxbf_gige_mdio_remove(priv);\n\treturn err;\n}\n\nstatic int mlxbf_gige_remove(struct platform_device *pdev)\n{\n\tstruct mlxbf_gige *priv = platform_get_drvdata(pdev);\n\n\tunregister_netdev(priv->netdev);\n\tphy_disconnect(priv->netdev->phydev);\n\tmlxbf_gige_mdio_remove(priv);\n\tplatform_set_drvdata(pdev, NULL);\n\n\treturn 0;\n}\n\nstatic void mlxbf_gige_shutdown(struct platform_device *pdev)\n{\n\tstruct mlxbf_gige *priv = platform_get_drvdata(pdev);\n\n\twriteq(0, priv->base + MLXBF_GIGE_INT_EN);\n\tmlxbf_gige_clean_port(priv);\n}\n\nstatic const struct acpi_device_id __maybe_unused mlxbf_gige_acpi_match[] = {\n\t{ \"MLNXBF17\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, mlxbf_gige_acpi_match);\n\nstatic struct platform_driver mlxbf_gige_driver = {\n\t.probe = mlxbf_gige_probe,\n\t.remove = mlxbf_gige_remove,\n\t.shutdown = mlxbf_gige_shutdown,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.acpi_match_table = ACPI_PTR(mlxbf_gige_acpi_match),\n\t},\n};\n\nmodule_platform_driver(mlxbf_gige_driver);\n\nMODULE_DESCRIPTION(\"Mellanox BlueField SoC Gigabit Ethernet Driver\");\nMODULE_AUTHOR(\"David Thompson <davthompson@nvidia.com>\");\nMODULE_AUTHOR(\"Asmaa Mnebhi <asmaa@nvidia.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}