{
  "module_name": "devcom.c",
  "hash_id": "3ee13f6c25d8d2ecd0585fd1d8b6d399c6083d4137db86870c8e48a48da6a4da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/devcom.c",
  "human_readable_source": "\n \n\n#include <linux/mlx5/vport.h>\n#include <linux/list.h>\n#include \"lib/devcom.h\"\n#include \"mlx5_core.h\"\n\nstatic LIST_HEAD(devcom_dev_list);\nstatic LIST_HEAD(devcom_comp_list);\n \nstatic DEFINE_MUTEX(dev_list_lock);\n \nstatic DEFINE_MUTEX(comp_list_lock);\n\n#define devcom_for_each_component(iter) \\\n\tlist_for_each_entry(iter, &devcom_comp_list, comp_list)\n\nstruct mlx5_devcom_dev {\n\tstruct list_head list;\n\tstruct mlx5_core_dev *dev;\n\tstruct kref ref;\n};\n\nstruct mlx5_devcom_comp {\n\tstruct list_head comp_list;\n\tenum mlx5_devcom_component id;\n\tu64 key;\n\tstruct list_head comp_dev_list_head;\n\tmlx5_devcom_event_handler_t handler;\n\tstruct kref ref;\n\tbool ready;\n\tstruct rw_semaphore sem;\n};\n\nstruct mlx5_devcom_comp_dev {\n\tstruct list_head list;\n\tstruct mlx5_devcom_comp *comp;\n\tstruct mlx5_devcom_dev *devc;\n\tvoid __rcu *data;\n};\n\nstatic bool devcom_dev_exists(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_devcom_dev *iter;\n\n\tlist_for_each_entry(iter, &devcom_dev_list, list)\n\t\tif (iter->dev == dev)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct mlx5_devcom_dev *\nmlx5_devcom_dev_alloc(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_devcom_dev *devc;\n\n\tdevc = kzalloc(sizeof(*devc), GFP_KERNEL);\n\tif (!devc)\n\t\treturn NULL;\n\n\tdevc->dev = dev;\n\tkref_init(&devc->ref);\n\treturn devc;\n}\n\nstruct mlx5_devcom_dev *\nmlx5_devcom_register_device(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_devcom_dev *devc;\n\n\tmutex_lock(&dev_list_lock);\n\n\tif (devcom_dev_exists(dev)) {\n\t\tdevc = ERR_PTR(-EEXIST);\n\t\tgoto out;\n\t}\n\n\tdevc = mlx5_devcom_dev_alloc(dev);\n\tif (!devc) {\n\t\tdevc = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&devc->list, &devcom_dev_list);\nout:\n\tmutex_unlock(&dev_list_lock);\n\treturn devc;\n}\n\nstatic void\nmlx5_devcom_dev_release(struct kref *ref)\n{\n\tstruct mlx5_devcom_dev *devc = container_of(ref, struct mlx5_devcom_dev, ref);\n\n\tmutex_lock(&dev_list_lock);\n\tlist_del(&devc->list);\n\tmutex_unlock(&dev_list_lock);\n\tkfree(devc);\n}\n\nvoid mlx5_devcom_unregister_device(struct mlx5_devcom_dev *devc)\n{\n\tif (!IS_ERR_OR_NULL(devc))\n\t\tkref_put(&devc->ref, mlx5_devcom_dev_release);\n}\n\nstatic struct mlx5_devcom_comp *\nmlx5_devcom_comp_alloc(u64 id, u64 key, mlx5_devcom_event_handler_t handler)\n{\n\tstruct mlx5_devcom_comp *comp;\n\n\tcomp = kzalloc(sizeof(*comp), GFP_KERNEL);\n\tif (!comp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcomp->id = id;\n\tcomp->key = key;\n\tcomp->handler = handler;\n\tinit_rwsem(&comp->sem);\n\tkref_init(&comp->ref);\n\tINIT_LIST_HEAD(&comp->comp_dev_list_head);\n\n\treturn comp;\n}\n\nstatic void\nmlx5_devcom_comp_release(struct kref *ref)\n{\n\tstruct mlx5_devcom_comp *comp = container_of(ref, struct mlx5_devcom_comp, ref);\n\n\tmutex_lock(&comp_list_lock);\n\tlist_del(&comp->comp_list);\n\tmutex_unlock(&comp_list_lock);\n\tkfree(comp);\n}\n\nstatic struct mlx5_devcom_comp_dev *\ndevcom_alloc_comp_dev(struct mlx5_devcom_dev *devc,\n\t\t      struct mlx5_devcom_comp *comp,\n\t\t      void *data)\n{\n\tstruct mlx5_devcom_comp_dev *devcom;\n\n\tdevcom = kzalloc(sizeof(*devcom), GFP_KERNEL);\n\tif (!devcom)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkref_get(&devc->ref);\n\tdevcom->devc = devc;\n\tdevcom->comp = comp;\n\trcu_assign_pointer(devcom->data, data);\n\n\tdown_write(&comp->sem);\n\tlist_add_tail(&devcom->list, &comp->comp_dev_list_head);\n\tup_write(&comp->sem);\n\n\treturn devcom;\n}\n\nstatic void\ndevcom_free_comp_dev(struct mlx5_devcom_comp_dev *devcom)\n{\n\tstruct mlx5_devcom_comp *comp = devcom->comp;\n\n\tdown_write(&comp->sem);\n\tlist_del(&devcom->list);\n\tup_write(&comp->sem);\n\n\tkref_put(&devcom->devc->ref, mlx5_devcom_dev_release);\n\tkfree(devcom);\n\tkref_put(&comp->ref, mlx5_devcom_comp_release);\n}\n\nstatic bool\ndevcom_component_equal(struct mlx5_devcom_comp *devcom,\n\t\t       enum mlx5_devcom_component id,\n\t\t       u64 key)\n{\n\treturn devcom->id == id && devcom->key == key;\n}\n\nstatic struct mlx5_devcom_comp *\ndevcom_component_get(struct mlx5_devcom_dev *devc,\n\t\t     enum mlx5_devcom_component id,\n\t\t     u64 key,\n\t\t     mlx5_devcom_event_handler_t handler)\n{\n\tstruct mlx5_devcom_comp *comp;\n\n\tdevcom_for_each_component(comp) {\n\t\tif (devcom_component_equal(comp, id, key)) {\n\t\t\tif (handler == comp->handler) {\n\t\t\t\tkref_get(&comp->ref);\n\t\t\t\treturn comp;\n\t\t\t}\n\n\t\t\tmlx5_core_err(devc->dev,\n\t\t\t\t      \"Cannot register existing devcom component with different handler\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstruct mlx5_devcom_comp_dev *\nmlx5_devcom_register_component(struct mlx5_devcom_dev *devc,\n\t\t\t       enum mlx5_devcom_component id,\n\t\t\t       u64 key,\n\t\t\t       mlx5_devcom_event_handler_t handler,\n\t\t\t       void *data)\n{\n\tstruct mlx5_devcom_comp_dev *devcom;\n\tstruct mlx5_devcom_comp *comp;\n\n\tif (IS_ERR_OR_NULL(devc))\n\t\treturn NULL;\n\n\tmutex_lock(&comp_list_lock);\n\tcomp = devcom_component_get(devc, id, key, handler);\n\tif (IS_ERR(comp)) {\n\t\tdevcom = ERR_PTR(-EINVAL);\n\t\tgoto out_unlock;\n\t}\n\n\tif (!comp) {\n\t\tcomp = mlx5_devcom_comp_alloc(id, key, handler);\n\t\tif (IS_ERR(comp)) {\n\t\t\tdevcom = ERR_CAST(comp);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tlist_add_tail(&comp->comp_list, &devcom_comp_list);\n\t}\n\tmutex_unlock(&comp_list_lock);\n\n\tdevcom = devcom_alloc_comp_dev(devc, comp, data);\n\tif (IS_ERR(devcom))\n\t\tkref_put(&comp->ref, mlx5_devcom_comp_release);\n\n\treturn devcom;\n\nout_unlock:\n\tmutex_unlock(&comp_list_lock);\n\treturn devcom;\n}\n\nvoid mlx5_devcom_unregister_component(struct mlx5_devcom_comp_dev *devcom)\n{\n\tif (!IS_ERR_OR_NULL(devcom))\n\t\tdevcom_free_comp_dev(devcom);\n}\n\nint mlx5_devcom_send_event(struct mlx5_devcom_comp_dev *devcom,\n\t\t\t   int event, int rollback_event,\n\t\t\t   void *event_data)\n{\n\tstruct mlx5_devcom_comp_dev *pos;\n\tstruct mlx5_devcom_comp *comp;\n\tint err = 0;\n\tvoid *data;\n\n\tif (IS_ERR_OR_NULL(devcom))\n\t\treturn -ENODEV;\n\n\tcomp = devcom->comp;\n\tdown_write(&comp->sem);\n\tlist_for_each_entry(pos, &comp->comp_dev_list_head, list) {\n\t\tdata = rcu_dereference_protected(pos->data, lockdep_is_held(&comp->sem));\n\n\t\tif (pos != devcom && data) {\n\t\t\terr = comp->handler(event, data, event_data);\n\t\t\tif (err)\n\t\t\t\tgoto rollback;\n\t\t}\n\t}\n\n\tup_write(&comp->sem);\n\treturn 0;\n\nrollback:\n\tif (list_entry_is_head(pos, &comp->comp_dev_list_head, list))\n\t\tgoto out;\n\tpos = list_prev_entry(pos, list);\n\tlist_for_each_entry_from_reverse(pos, &comp->comp_dev_list_head, list) {\n\t\tdata = rcu_dereference_protected(pos->data, lockdep_is_held(&comp->sem));\n\n\t\tif (pos != devcom && data)\n\t\t\tcomp->handler(rollback_event, data, event_data);\n\t}\nout:\n\tup_write(&comp->sem);\n\treturn err;\n}\n\nvoid mlx5_devcom_comp_set_ready(struct mlx5_devcom_comp_dev *devcom, bool ready)\n{\n\tWARN_ON(!rwsem_is_locked(&devcom->comp->sem));\n\n\tWRITE_ONCE(devcom->comp->ready, ready);\n}\n\nbool mlx5_devcom_comp_is_ready(struct mlx5_devcom_comp_dev *devcom)\n{\n\tif (IS_ERR_OR_NULL(devcom))\n\t\treturn false;\n\n\treturn READ_ONCE(devcom->comp->ready);\n}\n\nbool mlx5_devcom_for_each_peer_begin(struct mlx5_devcom_comp_dev *devcom)\n{\n\tstruct mlx5_devcom_comp *comp;\n\n\tif (IS_ERR_OR_NULL(devcom))\n\t\treturn false;\n\n\tcomp = devcom->comp;\n\tdown_read(&comp->sem);\n\tif (!READ_ONCE(comp->ready)) {\n\t\tup_read(&comp->sem);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid mlx5_devcom_for_each_peer_end(struct mlx5_devcom_comp_dev *devcom)\n{\n\tup_read(&devcom->comp->sem);\n}\n\nvoid *mlx5_devcom_get_next_peer_data(struct mlx5_devcom_comp_dev *devcom,\n\t\t\t\t     struct mlx5_devcom_comp_dev **pos)\n{\n\tstruct mlx5_devcom_comp *comp = devcom->comp;\n\tstruct mlx5_devcom_comp_dev *tmp;\n\tvoid *data;\n\n\ttmp = list_prepare_entry(*pos, &comp->comp_dev_list_head, list);\n\n\tlist_for_each_entry_continue(tmp, &comp->comp_dev_list_head, list) {\n\t\tif (tmp != devcom) {\n\t\t\tdata = rcu_dereference_protected(tmp->data, lockdep_is_held(&comp->sem));\n\t\t\tif (data)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (list_entry_is_head(tmp, &comp->comp_dev_list_head, list))\n\t\treturn NULL;\n\n\t*pos = tmp;\n\treturn data;\n}\n\nvoid *mlx5_devcom_get_next_peer_data_rcu(struct mlx5_devcom_comp_dev *devcom,\n\t\t\t\t\t struct mlx5_devcom_comp_dev **pos)\n{\n\tstruct mlx5_devcom_comp *comp = devcom->comp;\n\tstruct mlx5_devcom_comp_dev *tmp;\n\tvoid *data;\n\n\ttmp = list_prepare_entry(*pos, &comp->comp_dev_list_head, list);\n\n\tlist_for_each_entry_continue(tmp, &comp->comp_dev_list_head, list) {\n\t\tif (tmp != devcom) {\n\t\t\t \n\t\t\tif (!READ_ONCE(comp->ready))\n\t\t\t\treturn NULL;\n\t\t\tdata = rcu_dereference(tmp->data);\n\t\t\tif (data)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (list_entry_is_head(tmp, &comp->comp_dev_list_head, list))\n\t\treturn NULL;\n\n\t*pos = tmp;\n\treturn data;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}