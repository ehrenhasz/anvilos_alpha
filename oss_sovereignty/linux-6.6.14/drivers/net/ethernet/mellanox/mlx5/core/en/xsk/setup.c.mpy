{
  "module_name": "setup.c",
  "hash_id": "f99a1e66c3b80a5a73b24b8510e05d6a7573394f5f881537bf1438ba8e52255d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/xsk/setup.c",
  "human_readable_source": "\n \n\n#include \"setup.h\"\n#include \"en/params.h\"\n#include \"en/txrx.h\"\n#include \"en/health.h\"\n#include <net/xdp_sock_drv.h>\n\nstatic int mlx5e_legacy_rq_validate_xsk(struct mlx5_core_dev *mdev,\n\t\t\t\t\tstruct mlx5e_params *params,\n\t\t\t\t\tstruct mlx5e_xsk_param *xsk)\n{\n\tif (!mlx5e_rx_is_linear_skb(mdev, params, xsk)) {\n\t\tmlx5_core_err(mdev, \"Legacy RQ linear mode for XSK can't be activated with current params\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n#define MLX5E_MIN_XSK_CHUNK_SIZE max(2048, XDP_UMEM_MIN_CHUNK_SIZE)\n\nbool mlx5e_validate_xsk_param(struct mlx5e_params *params,\n\t\t\t      struct mlx5e_xsk_param *xsk,\n\t\t\t      struct mlx5_core_dev *mdev)\n{\n\t \n\tif (xsk->chunk_size > PAGE_SIZE || xsk->chunk_size < MLX5E_MIN_XSK_CHUNK_SIZE) {\n\t\tmlx5_core_err(mdev, \"XSK chunk size %u out of bounds [%u, %lu]\\n\", xsk->chunk_size,\n\t\t\t      MLX5E_MIN_XSK_CHUNK_SIZE, PAGE_SIZE);\n\t\treturn false;\n\t}\n\n\t \n\tswitch (params->rq_wq_type) {\n\tcase MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ:\n\t\treturn !mlx5e_mpwrq_validate_xsk(mdev, params, xsk);\n\tdefault:  \n\t\treturn !mlx5e_legacy_rq_validate_xsk(mdev, params, xsk);\n\t}\n}\n\nstatic void mlx5e_build_xsk_cparam(struct mlx5_core_dev *mdev,\n\t\t\t\t   struct mlx5e_params *params,\n\t\t\t\t   struct mlx5e_xsk_param *xsk,\n\t\t\t\t   u16 q_counter,\n\t\t\t\t   struct mlx5e_channel_param *cparam)\n{\n\tmlx5e_build_rq_param(mdev, params, xsk, q_counter, &cparam->rq);\n\tmlx5e_build_xdpsq_param(mdev, params, xsk, &cparam->xdp_sq);\n}\n\nstatic int mlx5e_init_xsk_rq(struct mlx5e_channel *c,\n\t\t\t     struct mlx5e_params *params,\n\t\t\t     struct xsk_buff_pool *pool,\n\t\t\t     struct mlx5e_xsk_param *xsk,\n\t\t\t     struct mlx5e_rq *rq)\n{\n\tstruct mlx5_core_dev *mdev = c->mdev;\n\tint rq_xdp_ix;\n\tint err;\n\n\trq->wq_type      = params->rq_wq_type;\n\trq->pdev         = c->pdev;\n\trq->netdev       = c->netdev;\n\trq->priv         = c->priv;\n\trq->tstamp       = c->tstamp;\n\trq->clock        = &mdev->clock;\n\trq->icosq        = &c->icosq;\n\trq->ix           = c->ix;\n\trq->channel      = c;\n\trq->mdev         = mdev;\n\trq->hw_mtu       = MLX5E_SW2HW_MTU(params, params->sw_mtu);\n\trq->xdpsq        = &c->rq_xdpsq;\n\trq->xsk_pool     = pool;\n\trq->stats        = &c->priv->channel_stats[c->ix]->xskrq;\n\trq->ptp_cyc2time = mlx5_rq_ts_translator(mdev);\n\trq_xdp_ix        = c->ix;\n\terr = mlx5e_rq_set_handlers(rq, params, xsk);\n\tif (err)\n\t\treturn err;\n\n\treturn xdp_rxq_info_reg(&rq->xdp_rxq, rq->netdev, rq_xdp_ix, c->napi.napi_id);\n}\n\nstatic int mlx5e_open_xsk_rq(struct mlx5e_channel *c, struct mlx5e_params *params,\n\t\t\t     struct mlx5e_rq_param *rq_params, struct xsk_buff_pool *pool,\n\t\t\t     struct mlx5e_xsk_param *xsk)\n{\n\tstruct mlx5e_rq *xskrq = &c->xskrq;\n\tint err;\n\n\terr = mlx5e_init_xsk_rq(c, params, pool, xsk, xskrq);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5e_open_rq(params, rq_params, xsk, cpu_to_node(c->cpu), xskrq);\n\tif (err)\n\t\treturn err;\n\n\t__set_bit(MLX5E_RQ_STATE_XSK, &xskrq->state);\n\treturn 0;\n}\n\nint mlx5e_open_xsk(struct mlx5e_priv *priv, struct mlx5e_params *params,\n\t\t   struct mlx5e_xsk_param *xsk, struct xsk_buff_pool *pool,\n\t\t   struct mlx5e_channel *c)\n{\n\tstruct mlx5e_channel_param *cparam;\n\tstruct mlx5e_create_cq_param ccp;\n\tint err;\n\n\tmlx5e_build_create_cq_param(&ccp, c);\n\n\tif (!mlx5e_validate_xsk_param(params, xsk, priv->mdev))\n\t\treturn -EINVAL;\n\n\tcparam = kvzalloc(sizeof(*cparam), GFP_KERNEL);\n\tif (!cparam)\n\t\treturn -ENOMEM;\n\n\tmlx5e_build_xsk_cparam(priv->mdev, params, xsk, priv->q_counter, cparam);\n\n\terr = mlx5e_open_cq(c->priv, params->rx_cq_moderation, &cparam->rq.cqp, &ccp,\n\t\t\t    &c->xskrq.cq);\n\tif (unlikely(err))\n\t\tgoto err_free_cparam;\n\n\terr = mlx5e_open_xsk_rq(c, params, &cparam->rq, pool, xsk);\n\tif (unlikely(err))\n\t\tgoto err_close_rx_cq;\n\n\terr = mlx5e_open_cq(c->priv, params->tx_cq_moderation, &cparam->xdp_sq.cqp, &ccp,\n\t\t\t    &c->xsksq.cq);\n\tif (unlikely(err))\n\t\tgoto err_close_rq;\n\n\t \n\terr = mlx5e_open_xdpsq(c, params, &cparam->xdp_sq, pool, &c->xsksq, true);\n\tif (unlikely(err))\n\t\tgoto err_close_tx_cq;\n\n\tkvfree(cparam);\n\n\tset_bit(MLX5E_CHANNEL_STATE_XSK, c->state);\n\n\treturn 0;\n\nerr_close_tx_cq:\n\tmlx5e_close_cq(&c->xsksq.cq);\n\nerr_close_rq:\n\tmlx5e_close_rq(&c->xskrq);\n\nerr_close_rx_cq:\n\tmlx5e_close_cq(&c->xskrq.cq);\n\nerr_free_cparam:\n\tkvfree(cparam);\n\n\treturn err;\n}\n\nvoid mlx5e_close_xsk(struct mlx5e_channel *c)\n{\n\tclear_bit(MLX5E_CHANNEL_STATE_XSK, c->state);\n\tsynchronize_net();  \n\n\tmlx5e_close_rq(&c->xskrq);\n\tmlx5e_close_cq(&c->xskrq.cq);\n\tmlx5e_close_xdpsq(&c->xsksq);\n\tmlx5e_close_cq(&c->xsksq.cq);\n\n\tmemset(&c->xskrq, 0, sizeof(c->xskrq));\n\tmemset(&c->xsksq, 0, sizeof(c->xsksq));\n}\n\nvoid mlx5e_activate_xsk(struct mlx5e_channel *c)\n{\n\t \n\tmlx5e_reporter_icosq_suspend_recovery(c);\n\tset_bit(MLX5E_RQ_STATE_ENABLED, &c->xskrq.state);\n\tmlx5e_reporter_icosq_resume_recovery(c);\n\n\t \n}\n\nvoid mlx5e_deactivate_xsk(struct mlx5e_channel *c)\n{\n\t \n\tmlx5e_reporter_icosq_suspend_recovery(c);\n\tclear_bit(MLX5E_RQ_STATE_ENABLED, &c->xskrq.state);\n\tmlx5e_reporter_icosq_resume_recovery(c);\n\tsynchronize_net();  \n\n\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}