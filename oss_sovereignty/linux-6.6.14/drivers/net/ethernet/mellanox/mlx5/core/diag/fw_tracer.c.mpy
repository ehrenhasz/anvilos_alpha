{
  "module_name": "fw_tracer.c",
  "hash_id": "b3b8dd4fe49ac7bababcef2012fcaa00183d33a52df01f009db6f5a62fbf41ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/diag/fw_tracer.c",
  "human_readable_source": " \n#define CREATE_TRACE_POINTS\n#include \"lib/eq.h\"\n#include \"fw_tracer.h\"\n#include \"fw_tracer_tracepoint.h\"\n\nstatic int mlx5_query_mtrc_caps(struct mlx5_fw_tracer *tracer)\n{\n\tu32 *string_db_base_address_out = tracer->str_db.base_address_out;\n\tu32 *string_db_size_out = tracer->str_db.size_out;\n\tstruct mlx5_core_dev *dev = tracer->dev;\n\tu32 out[MLX5_ST_SZ_DW(mtrc_cap)] = {0};\n\tu32 in[MLX5_ST_SZ_DW(mtrc_cap)] = {0};\n\tvoid *mtrc_cap_sp;\n\tint err, i;\n\n\terr = mlx5_core_access_reg(dev, in, sizeof(in), out, sizeof(out),\n\t\t\t\t   MLX5_REG_MTRC_CAP, 0, 0);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"FWTracer: Error reading tracer caps %d\\n\",\n\t\t\t       err);\n\t\treturn err;\n\t}\n\n\tif (!MLX5_GET(mtrc_cap, out, trace_to_memory)) {\n\t\tmlx5_core_dbg(dev, \"FWTracer: Device does not support logging traces to memory\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\ttracer->trc_ver = MLX5_GET(mtrc_cap, out, trc_ver);\n\ttracer->str_db.first_string_trace =\n\t\t\tMLX5_GET(mtrc_cap, out, first_string_trace);\n\ttracer->str_db.num_string_trace =\n\t\t\tMLX5_GET(mtrc_cap, out, num_string_trace);\n\ttracer->str_db.num_string_db = MLX5_GET(mtrc_cap, out, num_string_db);\n\ttracer->owner = !!MLX5_GET(mtrc_cap, out, trace_owner);\n\ttracer->str_db.loaded = false;\n\n\tfor (i = 0; i < tracer->str_db.num_string_db; i++) {\n\t\tmtrc_cap_sp = MLX5_ADDR_OF(mtrc_cap, out, string_db_param[i]);\n\t\tstring_db_base_address_out[i] = MLX5_GET(mtrc_string_db_param,\n\t\t\t\t\t\t\t mtrc_cap_sp,\n\t\t\t\t\t\t\t string_db_base_address);\n\t\tstring_db_size_out[i] = MLX5_GET(mtrc_string_db_param,\n\t\t\t\t\t\t mtrc_cap_sp, string_db_size);\n\t}\n\n\treturn err;\n}\n\nstatic int mlx5_set_mtrc_caps_trace_owner(struct mlx5_fw_tracer *tracer,\n\t\t\t\t\t  u32 *out, u32 out_size,\n\t\t\t\t\t  u8 trace_owner)\n{\n\tstruct mlx5_core_dev *dev = tracer->dev;\n\tu32 in[MLX5_ST_SZ_DW(mtrc_cap)] = {0};\n\n\tMLX5_SET(mtrc_cap, in, trace_owner, trace_owner);\n\n\treturn mlx5_core_access_reg(dev, in, sizeof(in), out, out_size,\n\t\t\t\t    MLX5_REG_MTRC_CAP, 0, 1);\n}\n\nstatic int mlx5_fw_tracer_ownership_acquire(struct mlx5_fw_tracer *tracer)\n{\n\tstruct mlx5_core_dev *dev = tracer->dev;\n\tu32 out[MLX5_ST_SZ_DW(mtrc_cap)] = {0};\n\tint err;\n\n\terr = mlx5_set_mtrc_caps_trace_owner(tracer, out, sizeof(out),\n\t\t\t\t\t     MLX5_FW_TRACER_ACQUIRE_OWNERSHIP);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"FWTracer: Acquire tracer ownership failed %d\\n\",\n\t\t\t       err);\n\t\treturn err;\n\t}\n\n\ttracer->owner = !!MLX5_GET(mtrc_cap, out, trace_owner);\n\n\tif (!tracer->owner)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic void mlx5_fw_tracer_ownership_release(struct mlx5_fw_tracer *tracer)\n{\n\tu32 out[MLX5_ST_SZ_DW(mtrc_cap)] = {0};\n\n\tmlx5_set_mtrc_caps_trace_owner(tracer, out, sizeof(out),\n\t\t\t\t       MLX5_FW_TRACER_RELEASE_OWNERSHIP);\n\ttracer->owner = false;\n}\n\nstatic int mlx5_fw_tracer_create_log_buf(struct mlx5_fw_tracer *tracer)\n{\n\tstruct mlx5_core_dev *dev = tracer->dev;\n\tstruct device *ddev;\n\tdma_addr_t dma;\n\tvoid *buff;\n\tgfp_t gfp;\n\tint err;\n\n\ttracer->buff.size = TRACE_BUFFER_SIZE_BYTE;\n\n\tgfp = GFP_KERNEL | __GFP_ZERO;\n\tbuff = (void *)__get_free_pages(gfp,\n\t\t\t\t\tget_order(tracer->buff.size));\n\tif (!buff) {\n\t\terr = -ENOMEM;\n\t\tmlx5_core_warn(dev, \"FWTracer: Failed to allocate pages, %d\\n\", err);\n\t\treturn err;\n\t}\n\ttracer->buff.log_buf = buff;\n\n\tddev = mlx5_core_dma_dev(dev);\n\tdma = dma_map_single(ddev, buff, tracer->buff.size, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(ddev, dma)) {\n\t\tmlx5_core_warn(dev, \"FWTracer: Unable to map DMA: %d\\n\",\n\t\t\t       dma_mapping_error(ddev, dma));\n\t\terr = -ENOMEM;\n\t\tgoto free_pages;\n\t}\n\ttracer->buff.dma = dma;\n\n\treturn 0;\n\nfree_pages:\n\tfree_pages((unsigned long)tracer->buff.log_buf, get_order(tracer->buff.size));\n\n\treturn err;\n}\n\nstatic void mlx5_fw_tracer_destroy_log_buf(struct mlx5_fw_tracer *tracer)\n{\n\tstruct mlx5_core_dev *dev = tracer->dev;\n\tstruct device *ddev;\n\n\tif (!tracer->buff.log_buf)\n\t\treturn;\n\n\tddev = mlx5_core_dma_dev(dev);\n\tdma_unmap_single(ddev, tracer->buff.dma, tracer->buff.size, DMA_FROM_DEVICE);\n\tfree_pages((unsigned long)tracer->buff.log_buf, get_order(tracer->buff.size));\n}\n\nstatic int mlx5_fw_tracer_create_mkey(struct mlx5_fw_tracer *tracer)\n{\n\tstruct mlx5_core_dev *dev = tracer->dev;\n\tint err, inlen, i;\n\t__be64 *mtt;\n\tvoid *mkc;\n\tu32 *in;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_mkey_in) +\n\t\t\tsizeof(*mtt) * round_up(TRACER_BUFFER_PAGE_NUM, 2);\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(create_mkey_in, in, translations_octword_actual_size,\n\t\t DIV_ROUND_UP(TRACER_BUFFER_PAGE_NUM, 2));\n\tmtt = (__be64 *)MLX5_ADDR_OF(create_mkey_in, in, klm_pas_mtt);\n\tfor (i = 0 ; i < TRACER_BUFFER_PAGE_NUM ; i++)\n\t\tmtt[i] = cpu_to_be64(tracer->buff.dma + i * PAGE_SIZE);\n\n\tmkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);\n\tMLX5_SET(mkc, mkc, access_mode_1_0, MLX5_MKC_ACCESS_MODE_MTT);\n\tMLX5_SET(mkc, mkc, lr, 1);\n\tMLX5_SET(mkc, mkc, lw, 1);\n\tMLX5_SET(mkc, mkc, pd, tracer->buff.pdn);\n\tMLX5_SET(mkc, mkc, bsf_octword_size, 0);\n\tMLX5_SET(mkc, mkc, qpn, 0xffffff);\n\tMLX5_SET(mkc, mkc, log_page_size, PAGE_SHIFT);\n\tMLX5_SET(mkc, mkc, translations_octword_size,\n\t\t DIV_ROUND_UP(TRACER_BUFFER_PAGE_NUM, 2));\n\tMLX5_SET64(mkc, mkc, start_addr, tracer->buff.dma);\n\tMLX5_SET64(mkc, mkc, len, tracer->buff.size);\n\terr = mlx5_core_create_mkey(dev, &tracer->buff.mkey, in, inlen);\n\tif (err)\n\t\tmlx5_core_warn(dev, \"FWTracer: Failed to create mkey, %d\\n\", err);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic void mlx5_fw_tracer_free_strings_db(struct mlx5_fw_tracer *tracer)\n{\n\tu32 num_string_db = tracer->str_db.num_string_db;\n\tint i;\n\n\tfor (i = 0; i < num_string_db; i++) {\n\t\tkfree(tracer->str_db.buffer[i]);\n\t\ttracer->str_db.buffer[i] = NULL;\n\t}\n}\n\nstatic int mlx5_fw_tracer_allocate_strings_db(struct mlx5_fw_tracer *tracer)\n{\n\tu32 *string_db_size_out = tracer->str_db.size_out;\n\tu32 num_string_db = tracer->str_db.num_string_db;\n\tint i;\n\n\tfor (i = 0; i < num_string_db; i++) {\n\t\tif (!string_db_size_out[i])\n\t\t\tcontinue;\n\t\ttracer->str_db.buffer[i] = kzalloc(string_db_size_out[i], GFP_KERNEL);\n\t\tif (!tracer->str_db.buffer[i])\n\t\t\tgoto free_strings_db;\n\t}\n\n\treturn 0;\n\nfree_strings_db:\n\tmlx5_fw_tracer_free_strings_db(tracer);\n\treturn -ENOMEM;\n}\n\nstatic void\nmlx5_fw_tracer_init_saved_traces_array(struct mlx5_fw_tracer *tracer)\n{\n\ttracer->st_arr.saved_traces_index = 0;\n\tmutex_init(&tracer->st_arr.lock);\n}\n\nstatic void\nmlx5_fw_tracer_clean_saved_traces_array(struct mlx5_fw_tracer *tracer)\n{\n\tmutex_destroy(&tracer->st_arr.lock);\n}\n\nstatic void mlx5_tracer_read_strings_db(struct work_struct *work)\n{\n\tstruct mlx5_fw_tracer *tracer = container_of(work, struct mlx5_fw_tracer,\n\t\t\t\t\t\t     read_fw_strings_work);\n\tu32 num_of_reads, num_string_db = tracer->str_db.num_string_db;\n\tstruct mlx5_core_dev *dev = tracer->dev;\n\tu32 in[MLX5_ST_SZ_DW(mtrc_cap)] = {0};\n\tu32 leftovers, offset;\n\tint err = 0, i, j;\n\tu32 *out, outlen;\n\tvoid *out_value;\n\n\toutlen = MLX5_ST_SZ_BYTES(mtrc_stdb) + STRINGS_DB_READ_SIZE_BYTES;\n\tout = kzalloc(outlen, GFP_KERNEL);\n\tif (!out) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_string_db; i++) {\n\t\tif (!tracer->str_db.size_out[i])\n\t\t\tcontinue;\n\t\toffset = 0;\n\t\tMLX5_SET(mtrc_stdb, in, string_db_index, i);\n\t\tnum_of_reads = tracer->str_db.size_out[i] /\n\t\t\t\tSTRINGS_DB_READ_SIZE_BYTES;\n\t\tleftovers = (tracer->str_db.size_out[i] %\n\t\t\t\tSTRINGS_DB_READ_SIZE_BYTES) /\n\t\t\t\t\tSTRINGS_DB_LEFTOVER_SIZE_BYTES;\n\n\t\tMLX5_SET(mtrc_stdb, in, read_size, STRINGS_DB_READ_SIZE_BYTES);\n\t\tfor (j = 0; j < num_of_reads; j++) {\n\t\t\tMLX5_SET(mtrc_stdb, in, start_offset, offset);\n\n\t\t\terr = mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t\t\t   outlen, MLX5_REG_MTRC_STDB,\n\t\t\t\t\t\t   0, 1);\n\t\t\tif (err) {\n\t\t\t\tmlx5_core_dbg(dev, \"FWTracer: Failed to read strings DB %d\\n\",\n\t\t\t\t\t      err);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tout_value = MLX5_ADDR_OF(mtrc_stdb, out, string_db_data);\n\t\t\tmemcpy(tracer->str_db.buffer[i] + offset, out_value,\n\t\t\t       STRINGS_DB_READ_SIZE_BYTES);\n\t\t\toffset += STRINGS_DB_READ_SIZE_BYTES;\n\t\t}\n\n\t\t \n\t\tMLX5_SET(mtrc_stdb, in, read_size,\n\t\t\t STRINGS_DB_LEFTOVER_SIZE_BYTES);\n\t\tfor (j = 0; j < leftovers; j++) {\n\t\t\tMLX5_SET(mtrc_stdb, in, start_offset, offset);\n\n\t\t\terr = mlx5_core_access_reg(dev, in, sizeof(in), out,\n\t\t\t\t\t\t   outlen, MLX5_REG_MTRC_STDB,\n\t\t\t\t\t\t   0, 1);\n\t\t\tif (err) {\n\t\t\t\tmlx5_core_dbg(dev, \"FWTracer: Failed to read strings DB %d\\n\",\n\t\t\t\t\t      err);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tout_value = MLX5_ADDR_OF(mtrc_stdb, out, string_db_data);\n\t\t\tmemcpy(tracer->str_db.buffer[i] + offset, out_value,\n\t\t\t       STRINGS_DB_LEFTOVER_SIZE_BYTES);\n\t\t\toffset += STRINGS_DB_LEFTOVER_SIZE_BYTES;\n\t\t}\n\t}\n\n\ttracer->str_db.loaded = true;\n\nout_free:\n\tkfree(out);\nout:\n\treturn;\n}\n\nstatic void mlx5_fw_tracer_arm(struct mlx5_core_dev *dev)\n{\n\tu32 out[MLX5_ST_SZ_DW(mtrc_ctrl)] = {0};\n\tu32 in[MLX5_ST_SZ_DW(mtrc_ctrl)] = {0};\n\tint err;\n\n\tMLX5_SET(mtrc_ctrl, in, arm_event, 1);\n\n\terr = mlx5_core_access_reg(dev, in, sizeof(in), out, sizeof(out),\n\t\t\t\t   MLX5_REG_MTRC_CTRL, 0, 1);\n\tif (err)\n\t\tmlx5_core_warn(dev, \"FWTracer: Failed to arm tracer event %d\\n\", err);\n}\n\nstatic const char *VAL_PARM\t\t= \"%llx\";\nstatic const char *REPLACE_64_VAL_PARM\t= \"%x%x\";\nstatic const char *PARAM_CHAR\t\t= \"%\";\n\nstatic int mlx5_tracer_message_hash(u32 message_id)\n{\n\treturn jhash_1word(message_id, 0) & (MESSAGE_HASH_SIZE - 1);\n}\n\nstatic struct tracer_string_format *mlx5_tracer_message_insert(struct mlx5_fw_tracer *tracer,\n\t\t\t\t\t\t\t       struct tracer_event *tracer_event)\n{\n\tstruct hlist_head *head =\n\t\t&tracer->hash[mlx5_tracer_message_hash(tracer_event->string_event.tmsn)];\n\tstruct tracer_string_format *cur_string;\n\n\tcur_string = kzalloc(sizeof(*cur_string), GFP_KERNEL);\n\tif (!cur_string)\n\t\treturn NULL;\n\n\thlist_add_head(&cur_string->hlist, head);\n\n\treturn cur_string;\n}\n\nstatic struct tracer_string_format *mlx5_tracer_get_string(struct mlx5_fw_tracer *tracer,\n\t\t\t\t\t\t\t   struct tracer_event *tracer_event)\n{\n\tstruct tracer_string_format *cur_string;\n\tu32 str_ptr, offset;\n\tint i;\n\n\tstr_ptr = tracer_event->string_event.string_param;\n\n\tfor (i = 0; i < tracer->str_db.num_string_db; i++) {\n\t\tif (!tracer->str_db.size_out[i])\n\t\t\tcontinue;\n\t\tif (str_ptr > tracer->str_db.base_address_out[i] &&\n\t\t    str_ptr < tracer->str_db.base_address_out[i] +\n\t\t    tracer->str_db.size_out[i]) {\n\t\t\toffset = str_ptr - tracer->str_db.base_address_out[i];\n\t\t\t \n\t\t\tcur_string = mlx5_tracer_message_insert(tracer, tracer_event);\n\t\t\tif (!cur_string)\n\t\t\t\treturn NULL;\n\t\t\tcur_string->string = (char *)(tracer->str_db.buffer[i] +\n\t\t\t\t\t\t\toffset);\n\t\t\treturn cur_string;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void mlx5_tracer_clean_message(struct tracer_string_format *str_frmt)\n{\n\thlist_del(&str_frmt->hlist);\n\tkfree(str_frmt);\n}\n\nstatic int mlx5_tracer_get_num_of_params(char *str)\n{\n\tchar *substr, *pstr = str;\n\tint num_of_params = 0;\n\n\t \n\tsubstr = strstr(pstr, VAL_PARM);\n\twhile (substr) {\n\t\tmemcpy(substr, REPLACE_64_VAL_PARM, 4);\n\t\tpstr = substr;\n\t\tsubstr = strstr(pstr, VAL_PARM);\n\t}\n\n\t \n\tsubstr = strstr(str, PARAM_CHAR);\n\twhile (substr) {\n\t\tnum_of_params += 1;\n\t\tstr = substr + 1;\n\t\tsubstr = strstr(str, PARAM_CHAR);\n\t}\n\n\treturn num_of_params;\n}\n\nstatic struct tracer_string_format *mlx5_tracer_message_find(struct hlist_head *head,\n\t\t\t\t\t\t\t     u8 event_id, u32 tmsn)\n{\n\tstruct tracer_string_format *message;\n\n\thlist_for_each_entry(message, head, hlist)\n\t\tif (message->event_id == event_id && message->tmsn == tmsn)\n\t\t\treturn message;\n\n\treturn NULL;\n}\n\nstatic struct tracer_string_format *mlx5_tracer_message_get(struct mlx5_fw_tracer *tracer,\n\t\t\t\t\t\t\t    struct tracer_event *tracer_event)\n{\n\tstruct hlist_head *head =\n\t\t&tracer->hash[mlx5_tracer_message_hash(tracer_event->string_event.tmsn)];\n\n\treturn mlx5_tracer_message_find(head, tracer_event->event_id, tracer_event->string_event.tmsn);\n}\n\nstatic void poll_trace(struct mlx5_fw_tracer *tracer,\n\t\t       struct tracer_event *tracer_event, u64 *trace)\n{\n\tu32 timestamp_low, timestamp_mid, timestamp_high, urts;\n\n\ttracer_event->event_id = MLX5_GET(tracer_event, trace, event_id);\n\ttracer_event->lost_event = MLX5_GET(tracer_event, trace, lost);\n\ttracer_event->out = trace;\n\n\tswitch (tracer_event->event_id) {\n\tcase TRACER_EVENT_TYPE_TIMESTAMP:\n\t\ttracer_event->type = TRACER_EVENT_TYPE_TIMESTAMP;\n\t\turts = MLX5_GET(tracer_timestamp_event, trace, urts);\n\t\tif (tracer->trc_ver == 0)\n\t\t\ttracer_event->timestamp_event.unreliable = !!(urts >> 2);\n\t\telse\n\t\t\ttracer_event->timestamp_event.unreliable = !!(urts & 1);\n\n\t\ttimestamp_low = MLX5_GET(tracer_timestamp_event,\n\t\t\t\t\t trace, timestamp7_0);\n\t\ttimestamp_mid = MLX5_GET(tracer_timestamp_event,\n\t\t\t\t\t trace, timestamp39_8);\n\t\ttimestamp_high = MLX5_GET(tracer_timestamp_event,\n\t\t\t\t\t  trace, timestamp52_40);\n\n\t\ttracer_event->timestamp_event.timestamp =\n\t\t\t\t((u64)timestamp_high << 40) |\n\t\t\t\t((u64)timestamp_mid << 8) |\n\t\t\t\t(u64)timestamp_low;\n\t\tbreak;\n\tdefault:\n\t\tif (tracer_event->event_id >= tracer->str_db.first_string_trace &&\n\t\t    tracer_event->event_id <= tracer->str_db.first_string_trace +\n\t\t\t\t\t      tracer->str_db.num_string_trace) {\n\t\t\ttracer_event->type = TRACER_EVENT_TYPE_STRING;\n\t\t\ttracer_event->string_event.timestamp =\n\t\t\t\tMLX5_GET(tracer_string_event, trace, timestamp);\n\t\t\ttracer_event->string_event.string_param =\n\t\t\t\tMLX5_GET(tracer_string_event, trace, string_param);\n\t\t\ttracer_event->string_event.tmsn =\n\t\t\t\tMLX5_GET(tracer_string_event, trace, tmsn);\n\t\t\ttracer_event->string_event.tdsn =\n\t\t\t\tMLX5_GET(tracer_string_event, trace, tdsn);\n\t\t} else {\n\t\t\ttracer_event->type = TRACER_EVENT_TYPE_UNRECOGNIZED;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic u64 get_block_timestamp(struct mlx5_fw_tracer *tracer, u64 *ts_event)\n{\n\tstruct tracer_event tracer_event;\n\tu8 event_id;\n\n\tevent_id = MLX5_GET(tracer_event, ts_event, event_id);\n\n\tif (event_id == TRACER_EVENT_TYPE_TIMESTAMP)\n\t\tpoll_trace(tracer, &tracer_event, ts_event);\n\telse\n\t\ttracer_event.timestamp_event.timestamp = 0;\n\n\treturn tracer_event.timestamp_event.timestamp;\n}\n\nstatic void mlx5_fw_tracer_clean_print_hash(struct mlx5_fw_tracer *tracer)\n{\n\tstruct tracer_string_format *str_frmt;\n\tstruct hlist_node *n;\n\tint i;\n\n\tfor (i = 0; i < MESSAGE_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_safe(str_frmt, n, &tracer->hash[i], hlist)\n\t\t\tmlx5_tracer_clean_message(str_frmt);\n\t}\n}\n\nstatic void mlx5_fw_tracer_clean_ready_list(struct mlx5_fw_tracer *tracer)\n{\n\tstruct tracer_string_format *str_frmt, *tmp_str;\n\n\tlist_for_each_entry_safe(str_frmt, tmp_str, &tracer->ready_strings_list,\n\t\t\t\t list)\n\t\tlist_del(&str_frmt->list);\n}\n\nstatic void mlx5_fw_tracer_save_trace(struct mlx5_fw_tracer *tracer,\n\t\t\t\t      u64 timestamp, bool lost,\n\t\t\t\t      u8 event_id, char *msg)\n{\n\tstruct mlx5_fw_trace_data *trace_data;\n\n\tmutex_lock(&tracer->st_arr.lock);\n\ttrace_data = &tracer->st_arr.straces[tracer->st_arr.saved_traces_index];\n\ttrace_data->timestamp = timestamp;\n\ttrace_data->lost = lost;\n\ttrace_data->event_id = event_id;\n\tstrscpy_pad(trace_data->msg, msg, TRACE_STR_MSG);\n\n\ttracer->st_arr.saved_traces_index =\n\t\t(tracer->st_arr.saved_traces_index + 1) & (SAVED_TRACES_NUM - 1);\n\tmutex_unlock(&tracer->st_arr.lock);\n}\n\nstatic noinline\nvoid mlx5_tracer_print_trace(struct tracer_string_format *str_frmt,\n\t\t\t     struct mlx5_core_dev *dev,\n\t\t\t     u64 trace_timestamp)\n{\n\tchar\ttmp[512];\n\n\tsnprintf(tmp, sizeof(tmp), str_frmt->string,\n\t\t str_frmt->params[0],\n\t\t str_frmt->params[1],\n\t\t str_frmt->params[2],\n\t\t str_frmt->params[3],\n\t\t str_frmt->params[4],\n\t\t str_frmt->params[5],\n\t\t str_frmt->params[6]);\n\n\ttrace_mlx5_fw(dev->tracer, trace_timestamp, str_frmt->lost,\n\t\t      str_frmt->event_id, tmp);\n\n\tmlx5_fw_tracer_save_trace(dev->tracer, trace_timestamp,\n\t\t\t\t  str_frmt->lost, str_frmt->event_id, tmp);\n\n\t \n\tmlx5_tracer_clean_message(str_frmt);\n}\n\nstatic int mlx5_tracer_handle_raw_string(struct mlx5_fw_tracer *tracer,\n\t\t\t\t\t struct tracer_event *tracer_event)\n{\n\tstruct tracer_string_format *cur_string;\n\n\tcur_string = mlx5_tracer_message_insert(tracer, tracer_event);\n\tif (!cur_string)\n\t\treturn -1;\n\n\tcur_string->event_id = tracer_event->event_id;\n\tcur_string->timestamp = tracer_event->string_event.timestamp;\n\tcur_string->lost = tracer_event->lost_event;\n\tcur_string->string = \"0x%08x%08x\";\n\tcur_string->num_of_params = 2;\n\tcur_string->params[0] = upper_32_bits(*tracer_event->out);\n\tcur_string->params[1] = lower_32_bits(*tracer_event->out);\n\tlist_add_tail(&cur_string->list, &tracer->ready_strings_list);\n\treturn 0;\n}\n\nstatic int mlx5_tracer_handle_string_trace(struct mlx5_fw_tracer *tracer,\n\t\t\t\t\t   struct tracer_event *tracer_event)\n{\n\tstruct tracer_string_format *cur_string;\n\n\tif (tracer_event->string_event.tdsn == 0) {\n\t\tcur_string = mlx5_tracer_get_string(tracer, tracer_event);\n\t\tif (!cur_string)\n\t\t\treturn mlx5_tracer_handle_raw_string(tracer, tracer_event);\n\n\t\tcur_string->num_of_params = mlx5_tracer_get_num_of_params(cur_string->string);\n\t\tcur_string->last_param_num = 0;\n\t\tcur_string->event_id = tracer_event->event_id;\n\t\tcur_string->tmsn = tracer_event->string_event.tmsn;\n\t\tcur_string->timestamp = tracer_event->string_event.timestamp;\n\t\tcur_string->lost = tracer_event->lost_event;\n\t\tif (cur_string->num_of_params == 0)  \n\t\t\tlist_add_tail(&cur_string->list, &tracer->ready_strings_list);\n\t} else {\n\t\tcur_string = mlx5_tracer_message_get(tracer, tracer_event);\n\t\tif (!cur_string) {\n\t\t\tpr_debug(\"%s Got string event for unknown string tmsn: %d\\n\",\n\t\t\t\t __func__, tracer_event->string_event.tmsn);\n\t\t\treturn mlx5_tracer_handle_raw_string(tracer, tracer_event);\n\t\t}\n\t\tcur_string->last_param_num += 1;\n\t\tif (cur_string->last_param_num > TRACER_MAX_PARAMS) {\n\t\t\tpr_debug(\"%s Number of params exceeds the max (%d)\\n\",\n\t\t\t\t __func__, TRACER_MAX_PARAMS);\n\t\t\tlist_add_tail(&cur_string->list, &tracer->ready_strings_list);\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tcur_string->params[cur_string->last_param_num - 1] =\n\t\t\ttracer_event->string_event.string_param;\n\t\tif (cur_string->last_param_num == cur_string->num_of_params)\n\t\t\tlist_add_tail(&cur_string->list, &tracer->ready_strings_list);\n\t}\n\n\treturn 0;\n}\n\nstatic void mlx5_tracer_handle_timestamp_trace(struct mlx5_fw_tracer *tracer,\n\t\t\t\t\t       struct tracer_event *tracer_event)\n{\n\tstruct tracer_timestamp_event timestamp_event =\n\t\t\t\t\t\ttracer_event->timestamp_event;\n\tstruct tracer_string_format *str_frmt, *tmp_str;\n\tstruct mlx5_core_dev *dev = tracer->dev;\n\tu64 trace_timestamp;\n\n\tlist_for_each_entry_safe(str_frmt, tmp_str, &tracer->ready_strings_list, list) {\n\t\tlist_del(&str_frmt->list);\n\t\tif (str_frmt->timestamp < (timestamp_event.timestamp & MASK_6_0))\n\t\t\ttrace_timestamp = (timestamp_event.timestamp & MASK_52_7) |\n\t\t\t\t\t  (str_frmt->timestamp & MASK_6_0);\n\t\telse\n\t\t\ttrace_timestamp = ((timestamp_event.timestamp - 1) & MASK_52_7) |\n\t\t\t\t\t  (str_frmt->timestamp & MASK_6_0);\n\n\t\tmlx5_tracer_print_trace(str_frmt, dev, trace_timestamp);\n\t}\n}\n\nstatic int mlx5_tracer_handle_trace(struct mlx5_fw_tracer *tracer,\n\t\t\t\t    struct tracer_event *tracer_event)\n{\n\tif (tracer_event->type == TRACER_EVENT_TYPE_STRING) {\n\t\tmlx5_tracer_handle_string_trace(tracer, tracer_event);\n\t} else if (tracer_event->type == TRACER_EVENT_TYPE_TIMESTAMP) {\n\t\tif (!tracer_event->timestamp_event.unreliable)\n\t\t\tmlx5_tracer_handle_timestamp_trace(tracer, tracer_event);\n\t} else {\n\t\tpr_debug(\"%s Got unrecognised type %d for parsing, exiting..\\n\",\n\t\t\t __func__, tracer_event->type);\n\t}\n\treturn 0;\n}\n\nstatic void mlx5_fw_tracer_handle_traces(struct work_struct *work)\n{\n\tstruct mlx5_fw_tracer *tracer =\n\t\t\tcontainer_of(work, struct mlx5_fw_tracer, handle_traces_work);\n\tu64 block_timestamp, last_block_timestamp, tmp_trace_block[TRACES_PER_BLOCK];\n\tu32 block_count, start_offset, prev_start_offset, prev_consumer_index;\n\tu32 trace_event_size = MLX5_ST_SZ_BYTES(tracer_event);\n\tstruct mlx5_core_dev *dev = tracer->dev;\n\tstruct tracer_event tracer_event;\n\tint i;\n\n\tmlx5_core_dbg(dev, \"FWTracer: Handle Trace event, owner=(%d)\\n\", tracer->owner);\n\tif (!tracer->owner)\n\t\treturn;\n\n\tif (unlikely(!tracer->str_db.loaded))\n\t\tgoto arm;\n\n\tblock_count = tracer->buff.size / TRACER_BLOCK_SIZE_BYTE;\n\tstart_offset = tracer->buff.consumer_index * TRACER_BLOCK_SIZE_BYTE;\n\n\t \n\tmemcpy(tmp_trace_block, tracer->buff.log_buf + start_offset,\n\t       TRACER_BLOCK_SIZE_BYTE);\n\n\tblock_timestamp =\n\t\tget_block_timestamp(tracer, &tmp_trace_block[TRACES_PER_BLOCK - 1]);\n\n\twhile (block_timestamp > tracer->last_timestamp) {\n\t\t \n\t\tif (tracer->last_timestamp) {\n\t\t\tu64 *ts_event;\n\t\t\t \n\t\t\tprev_consumer_index =\n\t\t\t\t(tracer->buff.consumer_index - 1) & (block_count - 1);\n\t\t\tprev_start_offset = prev_consumer_index * TRACER_BLOCK_SIZE_BYTE;\n\n\t\t\tts_event = tracer->buff.log_buf + prev_start_offset +\n\t\t\t\t   (TRACES_PER_BLOCK - 1) * trace_event_size;\n\t\t\tlast_block_timestamp = get_block_timestamp(tracer, ts_event);\n\t\t\t \n\t\t\tif (tracer->last_timestamp != last_block_timestamp) {\n\t\t\t\tmlx5_core_warn(dev, \"FWTracer: Events were lost\\n\");\n\t\t\t\ttracer->last_timestamp = block_timestamp;\n\t\t\t\ttracer->buff.consumer_index =\n\t\t\t\t\t(tracer->buff.consumer_index + 1) & (block_count - 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < TRACES_PER_BLOCK ; i++) {\n\t\t\tpoll_trace(tracer, &tracer_event, &tmp_trace_block[i]);\n\t\t\tmlx5_tracer_handle_trace(tracer, &tracer_event);\n\t\t}\n\n\t\ttracer->buff.consumer_index =\n\t\t\t(tracer->buff.consumer_index + 1) & (block_count - 1);\n\n\t\ttracer->last_timestamp = block_timestamp;\n\t\tstart_offset = tracer->buff.consumer_index * TRACER_BLOCK_SIZE_BYTE;\n\t\tmemcpy(tmp_trace_block, tracer->buff.log_buf + start_offset,\n\t\t       TRACER_BLOCK_SIZE_BYTE);\n\t\tblock_timestamp = get_block_timestamp(tracer,\n\t\t\t\t\t\t      &tmp_trace_block[TRACES_PER_BLOCK - 1]);\n\t}\n\narm:\n\tmlx5_fw_tracer_arm(dev);\n}\n\nstatic int mlx5_fw_tracer_set_mtrc_conf(struct mlx5_fw_tracer *tracer)\n{\n\tstruct mlx5_core_dev *dev = tracer->dev;\n\tu32 out[MLX5_ST_SZ_DW(mtrc_conf)] = {0};\n\tu32 in[MLX5_ST_SZ_DW(mtrc_conf)] = {0};\n\tint err;\n\n\tMLX5_SET(mtrc_conf, in, trace_mode, TRACE_TO_MEMORY);\n\tMLX5_SET(mtrc_conf, in, log_trace_buffer_size,\n\t\t ilog2(TRACER_BUFFER_PAGE_NUM));\n\tMLX5_SET(mtrc_conf, in, trace_mkey, tracer->buff.mkey);\n\n\terr = mlx5_core_access_reg(dev, in, sizeof(in), out, sizeof(out),\n\t\t\t\t   MLX5_REG_MTRC_CONF, 0, 1);\n\tif (err)\n\t\tmlx5_core_warn(dev, \"FWTracer: Failed to set tracer configurations %d\\n\", err);\n\n\ttracer->buff.consumer_index = 0;\n\treturn err;\n}\n\nstatic int mlx5_fw_tracer_set_mtrc_ctrl(struct mlx5_fw_tracer *tracer, u8 status, u8 arm)\n{\n\tstruct mlx5_core_dev *dev = tracer->dev;\n\tu32 out[MLX5_ST_SZ_DW(mtrc_ctrl)] = {0};\n\tu32 in[MLX5_ST_SZ_DW(mtrc_ctrl)] = {0};\n\tint err;\n\n\tMLX5_SET(mtrc_ctrl, in, modify_field_select, TRACE_STATUS);\n\tMLX5_SET(mtrc_ctrl, in, trace_status, status);\n\tMLX5_SET(mtrc_ctrl, in, arm_event, arm);\n\n\terr = mlx5_core_access_reg(dev, in, sizeof(in), out, sizeof(out),\n\t\t\t\t   MLX5_REG_MTRC_CTRL, 0, 1);\n\n\tif (!err && status)\n\t\ttracer->last_timestamp = 0;\n\n\treturn err;\n}\n\nstatic int mlx5_fw_tracer_start(struct mlx5_fw_tracer *tracer)\n{\n\tstruct mlx5_core_dev *dev = tracer->dev;\n\tint err;\n\n\terr = mlx5_fw_tracer_ownership_acquire(tracer);\n\tif (err) {\n\t\tmlx5_core_dbg(dev, \"FWTracer: Ownership was not granted %d\\n\", err);\n\t\t \n\t\treturn 0;\n\t}\n\n\terr = mlx5_fw_tracer_set_mtrc_conf(tracer);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"FWTracer: Failed to set tracer configuration %d\\n\", err);\n\t\tgoto release_ownership;\n\t}\n\n\t \n\terr = mlx5_fw_tracer_set_mtrc_ctrl(tracer, 1, 1);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"FWTracer: Failed to enable tracer %d\\n\", err);\n\t\tgoto release_ownership;\n\t}\n\n\tmlx5_core_dbg(dev, \"FWTracer: Ownership granted and active\\n\");\n\treturn 0;\n\nrelease_ownership:\n\tmlx5_fw_tracer_ownership_release(tracer);\n\treturn err;\n}\n\nstatic void mlx5_fw_tracer_ownership_change(struct work_struct *work)\n{\n\tstruct mlx5_fw_tracer *tracer =\n\t\tcontainer_of(work, struct mlx5_fw_tracer, ownership_change_work);\n\n\tmlx5_core_dbg(tracer->dev, \"FWTracer: ownership changed, current=(%d)\\n\", tracer->owner);\n\tif (tracer->owner) {\n\t\tmlx5_fw_tracer_ownership_acquire(tracer);\n\t\treturn;\n\t}\n\n\tmlx5_fw_tracer_start(tracer);\n}\n\nstatic int mlx5_fw_tracer_set_core_dump_reg(struct mlx5_core_dev *dev,\n\t\t\t\t\t    u32 *in, int size_in)\n{\n\tu32 out[MLX5_ST_SZ_DW(core_dump_reg)] = {};\n\n\tif (!MLX5_CAP_DEBUG(dev, core_dump_general) &&\n\t    !MLX5_CAP_DEBUG(dev, core_dump_qp))\n\t\treturn -EOPNOTSUPP;\n\n\treturn mlx5_core_access_reg(dev, in, size_in, out, sizeof(out),\n\t\t\t\t    MLX5_REG_CORE_DUMP, 0, 1);\n}\n\nint mlx5_fw_tracer_trigger_core_dump_general(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_fw_tracer *tracer = dev->tracer;\n\tu32 in[MLX5_ST_SZ_DW(core_dump_reg)] = {};\n\tint err;\n\n\tif (!MLX5_CAP_DEBUG(dev, core_dump_general) || !tracer)\n\t\treturn -EOPNOTSUPP;\n\tif (!tracer->owner)\n\t\treturn -EPERM;\n\n\tMLX5_SET(core_dump_reg, in, core_dump_type, 0x0);\n\n\terr =  mlx5_fw_tracer_set_core_dump_reg(dev, in, sizeof(in));\n\tif (err)\n\t\treturn err;\n\tqueue_work(tracer->work_queue, &tracer->handle_traces_work);\n\tflush_workqueue(tracer->work_queue);\n\treturn 0;\n}\n\nstatic int\nmlx5_devlink_fmsg_fill_trace(struct devlink_fmsg *fmsg,\n\t\t\t     struct mlx5_fw_trace_data *trace_data)\n{\n\tint err;\n\n\terr = devlink_fmsg_obj_nest_start(fmsg);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u64_pair_put(fmsg, \"timestamp\", trace_data->timestamp);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_bool_pair_put(fmsg, \"lost\", trace_data->lost);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_u8_pair_put(fmsg, \"event_id\", trace_data->event_id);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_string_pair_put(fmsg, \"msg\", trace_data->msg);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_fmsg_obj_nest_end(fmsg);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}\n\nint mlx5_fw_tracer_get_saved_traces_objects(struct mlx5_fw_tracer *tracer,\n\t\t\t\t\t    struct devlink_fmsg *fmsg)\n{\n\tstruct mlx5_fw_trace_data *straces = tracer->st_arr.straces;\n\tu32 index, start_index, end_index;\n\tu32 saved_traces_index;\n\tint err;\n\n\tif (!straces[0].timestamp)\n\t\treturn -ENOMSG;\n\n\tmutex_lock(&tracer->st_arr.lock);\n\tsaved_traces_index = tracer->st_arr.saved_traces_index;\n\tif (straces[saved_traces_index].timestamp)\n\t\tstart_index = saved_traces_index;\n\telse\n\t\tstart_index = 0;\n\tend_index = (saved_traces_index - 1) & (SAVED_TRACES_NUM - 1);\n\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"dump fw traces\");\n\tif (err)\n\t\tgoto unlock;\n\tindex = start_index;\n\twhile (index != end_index) {\n\t\terr = mlx5_devlink_fmsg_fill_trace(fmsg, &straces[index]);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\tindex = (index + 1) & (SAVED_TRACES_NUM - 1);\n\t}\n\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\nunlock:\n\tmutex_unlock(&tracer->st_arr.lock);\n\treturn err;\n}\n\nstatic void mlx5_fw_tracer_update_db(struct work_struct *work)\n{\n\tstruct mlx5_fw_tracer *tracer =\n\t\t\tcontainer_of(work, struct mlx5_fw_tracer, update_db_work);\n\n\tmlx5_fw_tracer_reload(tracer);\n}\n\n \nstruct mlx5_fw_tracer *mlx5_fw_tracer_create(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_fw_tracer *tracer = NULL;\n\tint err;\n\n\tif (!MLX5_CAP_MCAM_REG(dev, tracer_registers)) {\n\t\tmlx5_core_dbg(dev, \"FWTracer: Tracer capability not present\\n\");\n\t\treturn NULL;\n\t}\n\n\ttracer = kvzalloc(sizeof(*tracer), GFP_KERNEL);\n\tif (!tracer)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttracer->work_queue = create_singlethread_workqueue(\"mlx5_fw_tracer\");\n\tif (!tracer->work_queue) {\n\t\terr = -ENOMEM;\n\t\tgoto free_tracer;\n\t}\n\n\ttracer->dev = dev;\n\n\tINIT_LIST_HEAD(&tracer->ready_strings_list);\n\tINIT_WORK(&tracer->ownership_change_work, mlx5_fw_tracer_ownership_change);\n\tINIT_WORK(&tracer->read_fw_strings_work, mlx5_tracer_read_strings_db);\n\tINIT_WORK(&tracer->handle_traces_work, mlx5_fw_tracer_handle_traces);\n\tINIT_WORK(&tracer->update_db_work, mlx5_fw_tracer_update_db);\n\tmutex_init(&tracer->state_lock);\n\n\n\terr = mlx5_query_mtrc_caps(tracer);\n\tif (err) {\n\t\tmlx5_core_dbg(dev, \"FWTracer: Failed to query capabilities %d\\n\", err);\n\t\tgoto destroy_workqueue;\n\t}\n\n\terr = mlx5_fw_tracer_create_log_buf(tracer);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"FWTracer: Create log buffer failed %d\\n\", err);\n\t\tgoto destroy_workqueue;\n\t}\n\n\terr = mlx5_fw_tracer_allocate_strings_db(tracer);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"FWTracer: Allocate strings database failed %d\\n\", err);\n\t\tgoto free_log_buf;\n\t}\n\n\tmlx5_fw_tracer_init_saved_traces_array(tracer);\n\tmlx5_core_dbg(dev, \"FWTracer: Tracer created\\n\");\n\n\treturn tracer;\n\nfree_log_buf:\n\tmlx5_fw_tracer_destroy_log_buf(tracer);\ndestroy_workqueue:\n\ttracer->dev = NULL;\n\tdestroy_workqueue(tracer->work_queue);\nfree_tracer:\n\tkvfree(tracer);\n\treturn ERR_PTR(err);\n}\n\nstatic int fw_tracer_event(struct notifier_block *nb, unsigned long action, void *data);\n\n \nint mlx5_fw_tracer_init(struct mlx5_fw_tracer *tracer)\n{\n\tstruct mlx5_core_dev *dev;\n\tint err;\n\n\tif (IS_ERR_OR_NULL(tracer))\n\t\treturn 0;\n\n\tif (!tracer->str_db.loaded)\n\t\tqueue_work(tracer->work_queue, &tracer->read_fw_strings_work);\n\n\tmutex_lock(&tracer->state_lock);\n\tif (test_and_set_bit(MLX5_TRACER_STATE_UP, &tracer->state))\n\t\tgoto unlock;\n\n\tdev = tracer->dev;\n\n\terr = mlx5_core_alloc_pd(dev, &tracer->buff.pdn);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"FWTracer: Failed to allocate PD %d\\n\", err);\n\t\tgoto err_cancel_work;\n\t}\n\n\terr = mlx5_fw_tracer_create_mkey(tracer);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"FWTracer: Failed to create mkey %d\\n\", err);\n\t\tgoto err_dealloc_pd;\n\t}\n\n\tMLX5_NB_INIT(&tracer->nb, fw_tracer_event, DEVICE_TRACER);\n\tmlx5_eq_notifier_register(dev, &tracer->nb);\n\n\terr = mlx5_fw_tracer_start(tracer);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"FWTracer: Failed to start tracer %d\\n\", err);\n\t\tgoto err_notifier_unregister;\n\t}\nunlock:\n\tmutex_unlock(&tracer->state_lock);\n\treturn 0;\n\nerr_notifier_unregister:\n\tmlx5_eq_notifier_unregister(dev, &tracer->nb);\n\tmlx5_core_destroy_mkey(dev, tracer->buff.mkey);\nerr_dealloc_pd:\n\tmlx5_core_dealloc_pd(dev, tracer->buff.pdn);\nerr_cancel_work:\n\tcancel_work_sync(&tracer->read_fw_strings_work);\n\tmutex_unlock(&tracer->state_lock);\n\treturn err;\n}\n\n \nvoid mlx5_fw_tracer_cleanup(struct mlx5_fw_tracer *tracer)\n{\n\tif (IS_ERR_OR_NULL(tracer))\n\t\treturn;\n\n\tmutex_lock(&tracer->state_lock);\n\tif (!test_and_clear_bit(MLX5_TRACER_STATE_UP, &tracer->state))\n\t\tgoto unlock;\n\n\tmlx5_core_dbg(tracer->dev, \"FWTracer: Cleanup, is owner ? (%d)\\n\",\n\t\t      tracer->owner);\n\tmlx5_eq_notifier_unregister(tracer->dev, &tracer->nb);\n\tcancel_work_sync(&tracer->ownership_change_work);\n\tcancel_work_sync(&tracer->handle_traces_work);\n\t \n\tcancel_work(&tracer->update_db_work);\n\n\tif (tracer->owner)\n\t\tmlx5_fw_tracer_ownership_release(tracer);\n\n\tmlx5_core_destroy_mkey(tracer->dev, tracer->buff.mkey);\n\tmlx5_core_dealloc_pd(tracer->dev, tracer->buff.pdn);\nunlock:\n\tmutex_unlock(&tracer->state_lock);\n}\n\n \nvoid mlx5_fw_tracer_destroy(struct mlx5_fw_tracer *tracer)\n{\n\tif (IS_ERR_OR_NULL(tracer))\n\t\treturn;\n\n\tmlx5_core_dbg(tracer->dev, \"FWTracer: Destroy\\n\");\n\n\tcancel_work_sync(&tracer->read_fw_strings_work);\n\tmlx5_fw_tracer_clean_ready_list(tracer);\n\tmlx5_fw_tracer_clean_print_hash(tracer);\n\tmlx5_fw_tracer_clean_saved_traces_array(tracer);\n\tmlx5_fw_tracer_free_strings_db(tracer);\n\tmlx5_fw_tracer_destroy_log_buf(tracer);\n\tmutex_destroy(&tracer->state_lock);\n\tdestroy_workqueue(tracer->work_queue);\n\tkvfree(tracer);\n}\n\nstatic int mlx5_fw_tracer_recreate_strings_db(struct mlx5_fw_tracer *tracer)\n{\n\tstruct mlx5_core_dev *dev;\n\tint err;\n\n\tif (test_and_set_bit(MLX5_TRACER_RECREATE_DB, &tracer->state))\n\t\treturn 0;\n\tcancel_work_sync(&tracer->read_fw_strings_work);\n\tmlx5_fw_tracer_clean_ready_list(tracer);\n\tmlx5_fw_tracer_clean_print_hash(tracer);\n\tmlx5_fw_tracer_clean_saved_traces_array(tracer);\n\tmlx5_fw_tracer_free_strings_db(tracer);\n\n\tdev = tracer->dev;\n\terr = mlx5_query_mtrc_caps(tracer);\n\tif (err) {\n\t\tmlx5_core_dbg(dev, \"FWTracer: Failed to query capabilities %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\terr = mlx5_fw_tracer_allocate_strings_db(tracer);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"FWTracer: Allocate strings DB failed %d\\n\", err);\n\t\tgoto out;\n\t}\n\tmlx5_fw_tracer_init_saved_traces_array(tracer);\nout:\n\tclear_bit(MLX5_TRACER_RECREATE_DB, &tracer->state);\n\treturn err;\n}\n\nint mlx5_fw_tracer_reload(struct mlx5_fw_tracer *tracer)\n{\n\tstruct mlx5_core_dev *dev;\n\tint err;\n\n\tif (IS_ERR_OR_NULL(tracer))\n\t\treturn 0;\n\n\tdev = tracer->dev;\n\tmlx5_fw_tracer_cleanup(tracer);\n\terr = mlx5_fw_tracer_recreate_strings_db(tracer);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"Failed to recreate FW tracer strings DB\\n\");\n\t\treturn err;\n\t}\n\terr = mlx5_fw_tracer_init(tracer);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"Failed to re-initialize FW tracer\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int fw_tracer_event(struct notifier_block *nb, unsigned long action, void *data)\n{\n\tstruct mlx5_fw_tracer *tracer = mlx5_nb_cof(nb, struct mlx5_fw_tracer, nb);\n\tstruct mlx5_core_dev *dev = tracer->dev;\n\tstruct mlx5_eqe *eqe = data;\n\n\tswitch (eqe->sub_type) {\n\tcase MLX5_TRACER_SUBTYPE_OWNERSHIP_CHANGE:\n\t\tqueue_work(tracer->work_queue, &tracer->ownership_change_work);\n\t\tbreak;\n\tcase MLX5_TRACER_SUBTYPE_TRACES_AVAILABLE:\n\t\tqueue_work(tracer->work_queue, &tracer->handle_traces_work);\n\t\tbreak;\n\tcase MLX5_TRACER_SUBTYPE_STRINGS_DB_UPDATE:\n\t\tqueue_work(tracer->work_queue, &tracer->update_db_work);\n\t\tbreak;\n\tdefault:\n\t\tmlx5_core_dbg(dev, \"FWTracer: Event with unrecognized subtype: sub_type %d\\n\",\n\t\t\t      eqe->sub_type);\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nEXPORT_TRACEPOINT_SYMBOL(mlx5_fw);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}