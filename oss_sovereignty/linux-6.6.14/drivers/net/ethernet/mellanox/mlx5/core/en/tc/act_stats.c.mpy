{
  "module_name": "act_stats.c",
  "hash_id": "a6fa9aa64d1f44e3eec5b7533f126dd1fc0d34babb627590a79cafcc5e80a50f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act_stats.c",
  "human_readable_source": "\n\n\n#include <linux/rhashtable.h>\n#include <net/flow_offload.h>\n#include \"en/tc_priv.h\"\n#include \"act_stats.h\"\n#include \"en/fs.h\"\n\nstruct mlx5e_tc_act_stats_handle {\n\tstruct rhashtable ht;\n\tspinlock_t ht_lock;  \n};\n\nstruct mlx5e_tc_act_stats {\n\tunsigned long\t\ttc_act_cookie;\n\n\tstruct mlx5_fc\t\t*counter;\n\tu64\t\t\tlastpackets;\n\tu64\t\t\tlastbytes;\n\n\tstruct rhash_head\thash;\n\tstruct rcu_head\t\trcu_head;\n};\n\nstatic const struct rhashtable_params act_counters_ht_params = {\n\t.head_offset = offsetof(struct mlx5e_tc_act_stats, hash),\n\t.key_offset = offsetof(struct mlx5e_tc_act_stats, tc_act_cookie),\n\t.key_len = sizeof_field(struct mlx5e_tc_act_stats, tc_act_cookie),\n\t.automatic_shrinking = true,\n};\n\nstruct mlx5e_tc_act_stats_handle *\nmlx5e_tc_act_stats_create(void)\n{\n\tstruct mlx5e_tc_act_stats_handle *handle;\n\tint err;\n\n\thandle = kvzalloc(sizeof(*handle), GFP_KERNEL);\n\tif (!handle)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = rhashtable_init(&handle->ht, &act_counters_ht_params);\n\tif (err)\n\t\tgoto err;\n\n\tspin_lock_init(&handle->ht_lock);\n\treturn handle;\nerr:\n\tkvfree(handle);\n\treturn ERR_PTR(err);\n}\n\nvoid mlx5e_tc_act_stats_free(struct mlx5e_tc_act_stats_handle *handle)\n{\n\trhashtable_destroy(&handle->ht);\n\tkvfree(handle);\n}\n\nstatic int\nmlx5e_tc_act_stats_add(struct mlx5e_tc_act_stats_handle *handle,\n\t\t       unsigned long act_cookie,\n\t\t       struct mlx5_fc *counter)\n{\n\tstruct mlx5e_tc_act_stats *act_stats, *old_act_stats;\n\tstruct rhashtable *ht = &handle->ht;\n\tu64 lastused;\n\tint err = 0;\n\n\tact_stats = kvzalloc(sizeof(*act_stats), GFP_KERNEL);\n\tif (!act_stats)\n\t\treturn -ENOMEM;\n\n\tact_stats->tc_act_cookie = act_cookie;\n\tact_stats->counter = counter;\n\n\tmlx5_fc_query_cached_raw(counter,\n\t\t\t\t &act_stats->lastbytes,\n\t\t\t\t &act_stats->lastpackets, &lastused);\n\n\trcu_read_lock();\n\told_act_stats = rhashtable_lookup_get_insert_fast(ht,\n\t\t\t\t\t\t\t  &act_stats->hash,\n\t\t\t\t\t\t\t  act_counters_ht_params);\n\tif (IS_ERR(old_act_stats)) {\n\t\terr = PTR_ERR(old_act_stats);\n\t\tgoto err_hash_insert;\n\t} else if (old_act_stats) {\n\t\terr = -EEXIST;\n\t\tgoto err_hash_insert;\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n\nerr_hash_insert:\n\trcu_read_unlock();\n\tkvfree(act_stats);\n\treturn err;\n}\n\nvoid\nmlx5e_tc_act_stats_del_flow(struct mlx5e_tc_act_stats_handle *handle,\n\t\t\t    struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5_flow_attr *attr;\n\tstruct mlx5e_tc_act_stats *act_stats;\n\tint i;\n\n\tif (!flow_flag_test(flow, USE_ACT_STATS))\n\t\treturn;\n\n\tlist_for_each_entry(attr, &flow->attrs, list) {\n\t\tfor (i = 0; i < attr->tc_act_cookies_count; i++) {\n\t\t\tstruct rhashtable *ht = &handle->ht;\n\n\t\t\tspin_lock(&handle->ht_lock);\n\t\t\tact_stats = rhashtable_lookup_fast(ht,\n\t\t\t\t\t\t\t   &attr->tc_act_cookies[i],\n\t\t\t\t\t\t\t   act_counters_ht_params);\n\t\t\tif (act_stats &&\n\t\t\t    rhashtable_remove_fast(ht, &act_stats->hash,\n\t\t\t\t\t\t   act_counters_ht_params) == 0)\n\t\t\t\tkvfree_rcu(act_stats, rcu_head);\n\n\t\t\tspin_unlock(&handle->ht_lock);\n\t\t}\n\t}\n}\n\nint\nmlx5e_tc_act_stats_add_flow(struct mlx5e_tc_act_stats_handle *handle,\n\t\t\t    struct mlx5e_tc_flow *flow)\n{\n\tstruct mlx5_fc *curr_counter = NULL;\n\tunsigned long last_cookie = 0;\n\tstruct mlx5_flow_attr *attr;\n\tint err;\n\tint i;\n\n\tif (!flow_flag_test(flow, USE_ACT_STATS))\n\t\treturn 0;\n\n\tlist_for_each_entry(attr, &flow->attrs, list) {\n\t\tif (attr->counter)\n\t\t\tcurr_counter = attr->counter;\n\n\t\tfor (i = 0; i < attr->tc_act_cookies_count; i++) {\n\t\t\t \n\t\t\tif (last_cookie == attr->tc_act_cookies[i])\n\t\t\t\tcontinue;\n\n\t\t\terr = mlx5e_tc_act_stats_add(handle, attr->tc_act_cookies[i], curr_counter);\n\t\t\tif (err)\n\t\t\t\tgoto out_err;\n\t\t\tlast_cookie = attr->tc_act_cookies[i];\n\t\t}\n\t}\n\n\treturn 0;\nout_err:\n\tmlx5e_tc_act_stats_del_flow(handle, flow);\n\treturn err;\n}\n\nint\nmlx5e_tc_act_stats_fill_stats(struct mlx5e_tc_act_stats_handle *handle,\n\t\t\t      struct flow_offload_action *fl_act)\n{\n\tstruct rhashtable *ht = &handle->ht;\n\tstruct mlx5e_tc_act_stats *item;\n\tu64 pkts, bytes, lastused;\n\tint err = 0;\n\n\trcu_read_lock();\n\titem = rhashtable_lookup(ht, &fl_act->cookie, act_counters_ht_params);\n\tif (!item) {\n\t\trcu_read_unlock();\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\n\tmlx5_fc_query_cached_raw(item->counter,\n\t\t\t\t &bytes, &pkts, &lastused);\n\n\tflow_stats_update(&fl_act->stats,\n\t\t\t  bytes - item->lastbytes,\n\t\t\t  pkts - item->lastpackets,\n\t\t\t  0, lastused, FLOW_ACTION_HW_STATS_DELAYED);\n\n\titem->lastpackets = pkts;\n\titem->lastbytes = bytes;\n\trcu_read_unlock();\n\n\treturn 0;\n\nerr_out:\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}