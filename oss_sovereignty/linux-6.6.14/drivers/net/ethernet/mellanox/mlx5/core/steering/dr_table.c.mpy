{
  "module_name": "dr_table.c",
  "hash_id": "a7d345e1614ec9d56f8e04382e77adcbe96c9dab39a9a4e19d47063801c10158",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_table.c",
  "human_readable_source": "\n \n\n#include \"dr_types.h\"\n\nstatic int dr_table_set_miss_action_nic(struct mlx5dr_domain *dmn,\n\t\t\t\t\tstruct mlx5dr_table_rx_tx *nic_tbl,\n\t\t\t\t\tstruct mlx5dr_action *action)\n{\n\tstruct mlx5dr_matcher_rx_tx *last_nic_matcher = NULL;\n\tstruct mlx5dr_htbl_connect_info info;\n\tstruct mlx5dr_ste_htbl *last_htbl;\n\tstruct mlx5dr_icm_chunk *chunk;\n\tint ret;\n\n\tif (!list_empty(&nic_tbl->nic_matcher_list))\n\t\tlast_nic_matcher = list_last_entry(&nic_tbl->nic_matcher_list,\n\t\t\t\t\t\t   struct mlx5dr_matcher_rx_tx,\n\t\t\t\t\t\t   list_node);\n\n\tif (last_nic_matcher)\n\t\tlast_htbl = last_nic_matcher->e_anchor;\n\telse\n\t\tlast_htbl = nic_tbl->s_anchor;\n\n\tif (action) {\n\t\tchunk = nic_tbl->nic_dmn->type == DR_DOMAIN_NIC_TYPE_RX ?\n\t\t\taction->dest_tbl->tbl->rx.s_anchor->chunk :\n\t\t\taction->dest_tbl->tbl->tx.s_anchor->chunk;\n\t\tnic_tbl->default_icm_addr = mlx5dr_icm_pool_get_chunk_icm_addr(chunk);\n\t} else {\n\t\tnic_tbl->default_icm_addr = nic_tbl->nic_dmn->default_icm_addr;\n\t}\n\n\tinfo.type = CONNECT_MISS;\n\tinfo.miss_icm_addr = nic_tbl->default_icm_addr;\n\n\tret = mlx5dr_ste_htbl_init_and_postsend(dmn, nic_tbl->nic_dmn,\n\t\t\t\t\t\tlast_htbl, &info, true);\n\tif (ret)\n\t\tmlx5dr_dbg(dmn, \"Failed to set NIC RX/TX miss action, ret %d\\n\", ret);\n\n\treturn ret;\n}\n\nint mlx5dr_table_set_miss_action(struct mlx5dr_table *tbl,\n\t\t\t\t struct mlx5dr_action *action)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tif (action && action->action_type != DR_ACTION_TYP_FT)\n\t\treturn -EOPNOTSUPP;\n\n\tmlx5dr_domain_lock(tbl->dmn);\n\n\tif (tbl->dmn->type == MLX5DR_DOMAIN_TYPE_NIC_RX ||\n\t    tbl->dmn->type == MLX5DR_DOMAIN_TYPE_FDB) {\n\t\tret = dr_table_set_miss_action_nic(tbl->dmn, &tbl->rx, action);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (tbl->dmn->type == MLX5DR_DOMAIN_TYPE_NIC_TX ||\n\t    tbl->dmn->type == MLX5DR_DOMAIN_TYPE_FDB) {\n\t\tret = dr_table_set_miss_action_nic(tbl->dmn, &tbl->tx, action);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (tbl->miss_action)\n\t\trefcount_dec(&tbl->miss_action->refcount);\n\n\t \n\ttbl->miss_action = action;\n\tif (tbl->miss_action)\n\t\trefcount_inc(&action->refcount);\n\nout:\n\tmlx5dr_domain_unlock(tbl->dmn);\n\treturn ret;\n}\n\nstatic void dr_table_uninit_nic(struct mlx5dr_table_rx_tx *nic_tbl)\n{\n\tmlx5dr_htbl_put(nic_tbl->s_anchor);\n}\n\nstatic void dr_table_uninit_fdb(struct mlx5dr_table *tbl)\n{\n\tdr_table_uninit_nic(&tbl->rx);\n\tdr_table_uninit_nic(&tbl->tx);\n}\n\nstatic void dr_table_uninit(struct mlx5dr_table *tbl)\n{\n\tmlx5dr_domain_lock(tbl->dmn);\n\n\tswitch (tbl->dmn->type) {\n\tcase MLX5DR_DOMAIN_TYPE_NIC_RX:\n\t\tdr_table_uninit_nic(&tbl->rx);\n\t\tbreak;\n\tcase MLX5DR_DOMAIN_TYPE_NIC_TX:\n\t\tdr_table_uninit_nic(&tbl->tx);\n\t\tbreak;\n\tcase MLX5DR_DOMAIN_TYPE_FDB:\n\t\tdr_table_uninit_fdb(tbl);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(true);\n\t\tbreak;\n\t}\n\n\tmlx5dr_domain_unlock(tbl->dmn);\n}\n\nstatic int dr_table_init_nic(struct mlx5dr_domain *dmn,\n\t\t\t     struct mlx5dr_table_rx_tx *nic_tbl)\n{\n\tstruct mlx5dr_domain_rx_tx *nic_dmn = nic_tbl->nic_dmn;\n\tstruct mlx5dr_htbl_connect_info info;\n\tint ret;\n\n\tINIT_LIST_HEAD(&nic_tbl->nic_matcher_list);\n\n\tnic_tbl->default_icm_addr = nic_dmn->default_icm_addr;\n\n\tnic_tbl->s_anchor = mlx5dr_ste_htbl_alloc(dmn->ste_icm_pool,\n\t\t\t\t\t\t  DR_CHUNK_SIZE_1,\n\t\t\t\t\t\t  MLX5DR_STE_LU_TYPE_DONT_CARE,\n\t\t\t\t\t\t  0);\n\tif (!nic_tbl->s_anchor) {\n\t\tmlx5dr_err(dmn, \"Failed allocating htbl\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo.type = CONNECT_MISS;\n\tinfo.miss_icm_addr = nic_dmn->default_icm_addr;\n\tret = mlx5dr_ste_htbl_init_and_postsend(dmn, nic_dmn,\n\t\t\t\t\t\tnic_tbl->s_anchor,\n\t\t\t\t\t\t&info, true);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Failed int and send htbl\\n\");\n\t\tgoto free_s_anchor;\n\t}\n\n\tmlx5dr_htbl_get(nic_tbl->s_anchor);\n\n\treturn 0;\n\nfree_s_anchor:\n\tmlx5dr_ste_htbl_free(nic_tbl->s_anchor);\n\treturn ret;\n}\n\nstatic int dr_table_init_fdb(struct mlx5dr_table *tbl)\n{\n\tint ret;\n\n\tret = dr_table_init_nic(tbl->dmn, &tbl->rx);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dr_table_init_nic(tbl->dmn, &tbl->tx);\n\tif (ret)\n\t\tgoto destroy_rx;\n\n\treturn 0;\n\ndestroy_rx:\n\tdr_table_uninit_nic(&tbl->rx);\n\treturn ret;\n}\n\nstatic int dr_table_init(struct mlx5dr_table *tbl)\n{\n\tint ret = 0;\n\n\tINIT_LIST_HEAD(&tbl->matcher_list);\n\n\tmlx5dr_domain_lock(tbl->dmn);\n\n\tswitch (tbl->dmn->type) {\n\tcase MLX5DR_DOMAIN_TYPE_NIC_RX:\n\t\ttbl->table_type = MLX5_FLOW_TABLE_TYPE_NIC_RX;\n\t\ttbl->rx.nic_dmn = &tbl->dmn->info.rx;\n\t\tret = dr_table_init_nic(tbl->dmn, &tbl->rx);\n\t\tbreak;\n\tcase MLX5DR_DOMAIN_TYPE_NIC_TX:\n\t\ttbl->table_type = MLX5_FLOW_TABLE_TYPE_NIC_TX;\n\t\ttbl->tx.nic_dmn = &tbl->dmn->info.tx;\n\t\tret = dr_table_init_nic(tbl->dmn, &tbl->tx);\n\t\tbreak;\n\tcase MLX5DR_DOMAIN_TYPE_FDB:\n\t\ttbl->table_type = MLX5_FLOW_TABLE_TYPE_FDB;\n\t\ttbl->rx.nic_dmn = &tbl->dmn->info.rx;\n\t\ttbl->tx.nic_dmn = &tbl->dmn->info.tx;\n\t\tret = dr_table_init_fdb(tbl);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(true);\n\t\tbreak;\n\t}\n\n\tmlx5dr_domain_unlock(tbl->dmn);\n\n\treturn ret;\n}\n\nstatic int dr_table_destroy_sw_owned_tbl(struct mlx5dr_table *tbl)\n{\n\treturn mlx5dr_cmd_destroy_flow_table(tbl->dmn->mdev,\n\t\t\t\t\t     tbl->table_id,\n\t\t\t\t\t     tbl->table_type);\n}\n\nstatic int dr_table_create_sw_owned_tbl(struct mlx5dr_table *tbl, u16 uid)\n{\n\tbool en_encap = !!(tbl->flags & MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT);\n\tbool en_decap = !!(tbl->flags & MLX5_FLOW_TABLE_TUNNEL_EN_DECAP);\n\tstruct mlx5dr_cmd_create_flow_table_attr ft_attr = {};\n\tu64 icm_addr_rx = 0;\n\tu64 icm_addr_tx = 0;\n\tint ret;\n\n\tif (tbl->rx.s_anchor)\n\t\ticm_addr_rx = mlx5dr_icm_pool_get_chunk_icm_addr(tbl->rx.s_anchor->chunk);\n\n\tif (tbl->tx.s_anchor)\n\t\ticm_addr_tx = mlx5dr_icm_pool_get_chunk_icm_addr(tbl->tx.s_anchor->chunk);\n\n\tft_attr.table_type = tbl->table_type;\n\tft_attr.icm_addr_rx = icm_addr_rx;\n\tft_attr.icm_addr_tx = icm_addr_tx;\n\tft_attr.level = tbl->dmn->info.caps.max_ft_level - 1;\n\tft_attr.sw_owner = true;\n\tft_attr.decap_en = en_decap;\n\tft_attr.reformat_en = en_encap;\n\tft_attr.uid = uid;\n\n\tret = mlx5dr_cmd_create_flow_table(tbl->dmn->mdev, &ft_attr,\n\t\t\t\t\t   NULL, &tbl->table_id);\n\n\treturn ret;\n}\n\nstruct mlx5dr_table *mlx5dr_table_create(struct mlx5dr_domain *dmn, u32 level,\n\t\t\t\t\t u32 flags, u16 uid)\n{\n\tstruct mlx5dr_table *tbl;\n\tint ret;\n\n\trefcount_inc(&dmn->refcount);\n\n\ttbl = kzalloc(sizeof(*tbl), GFP_KERNEL);\n\tif (!tbl)\n\t\tgoto dec_ref;\n\n\ttbl->dmn = dmn;\n\ttbl->level = level;\n\ttbl->flags = flags;\n\trefcount_set(&tbl->refcount, 1);\n\n\tret = dr_table_init(tbl);\n\tif (ret)\n\t\tgoto free_tbl;\n\n\tret = dr_table_create_sw_owned_tbl(tbl, uid);\n\tif (ret)\n\t\tgoto uninit_tbl;\n\n\tINIT_LIST_HEAD(&tbl->dbg_node);\n\tmlx5dr_dbg_tbl_add(tbl);\n\treturn tbl;\n\nuninit_tbl:\n\tdr_table_uninit(tbl);\nfree_tbl:\n\tkfree(tbl);\ndec_ref:\n\trefcount_dec(&dmn->refcount);\n\treturn NULL;\n}\n\nint mlx5dr_table_destroy(struct mlx5dr_table *tbl)\n{\n\tint ret;\n\n\tif (WARN_ON_ONCE(refcount_read(&tbl->refcount) > 1))\n\t\treturn -EBUSY;\n\n\tmlx5dr_dbg_tbl_del(tbl);\n\tret = dr_table_destroy_sw_owned_tbl(tbl);\n\tif (ret)\n\t\tmlx5dr_err(tbl->dmn, \"Failed to destroy sw owned table\\n\");\n\n\tdr_table_uninit(tbl);\n\n\tif (tbl->miss_action)\n\t\trefcount_dec(&tbl->miss_action->refcount);\n\n\trefcount_dec(&tbl->dmn->refcount);\n\tkfree(tbl);\n\n\treturn ret;\n}\n\nu32 mlx5dr_table_get_id(struct mlx5dr_table *tbl)\n{\n\treturn tbl->table_id;\n}\n\nstruct mlx5dr_table *mlx5dr_table_get_from_fs_ft(struct mlx5_flow_table *ft)\n{\n\treturn ft->fs_dr_table.dr_table;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}