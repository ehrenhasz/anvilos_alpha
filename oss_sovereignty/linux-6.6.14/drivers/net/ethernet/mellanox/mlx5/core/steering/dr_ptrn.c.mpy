{
  "module_name": "dr_ptrn.c",
  "hash_id": "7449a91bccfb7c8b20fb3e829a7210e39207e03faedf819f8634a218424734cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_ptrn.c",
  "human_readable_source": "\n\n\n#include \"dr_types.h\"\n#include \"mlx5_ifc_dr_ste_v1.h\"\n\nenum dr_ptrn_modify_hdr_action_id {\n\tDR_PTRN_MODIFY_HDR_ACTION_ID_NOP = 0x00,\n\tDR_PTRN_MODIFY_HDR_ACTION_ID_COPY = 0x05,\n\tDR_PTRN_MODIFY_HDR_ACTION_ID_SET = 0x06,\n\tDR_PTRN_MODIFY_HDR_ACTION_ID_ADD = 0x07,\n\tDR_PTRN_MODIFY_HDR_ACTION_ID_INSERT_INLINE = 0x0a,\n};\n\nstruct mlx5dr_ptrn_mgr {\n\tstruct mlx5dr_domain *dmn;\n\tstruct mlx5dr_icm_pool *ptrn_icm_pool;\n\t \n\tstruct list_head ptrn_list;\n\tstruct mutex modify_hdr_mutex;  \n};\n\n \nstatic bool dr_ptrn_compare_modify_hdr(size_t cur_num_of_actions,\n\t\t\t\t       __be64 cur_hw_actions[],\n\t\t\t\t       size_t num_of_actions,\n\t\t\t\t       __be64 hw_actions[])\n{\n\tint i;\n\n\tif (cur_num_of_actions != num_of_actions)\n\t\treturn false;\n\n\tfor (i = 0; i < num_of_actions; i++) {\n\t\tu8 action_id =\n\t\t\tMLX5_GET(ste_double_action_set_v1, &hw_actions[i], action_id);\n\n\t\tif (action_id == DR_PTRN_MODIFY_HDR_ACTION_ID_COPY) {\n\t\t\tif (hw_actions[i] != cur_hw_actions[i])\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif ((__force __be32)hw_actions[i] !=\n\t\t\t    (__force __be32)cur_hw_actions[i])\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic struct mlx5dr_ptrn_obj *\ndr_ptrn_find_cached_pattern(struct mlx5dr_ptrn_mgr *mgr,\n\t\t\t    size_t num_of_actions,\n\t\t\t    __be64 hw_actions[])\n{\n\tstruct mlx5dr_ptrn_obj *cached_pattern;\n\tstruct mlx5dr_ptrn_obj *tmp;\n\n\tlist_for_each_entry_safe(cached_pattern, tmp, &mgr->ptrn_list, list) {\n\t\tif (dr_ptrn_compare_modify_hdr(cached_pattern->num_of_actions,\n\t\t\t\t\t       (__be64 *)cached_pattern->data,\n\t\t\t\t\t       num_of_actions,\n\t\t\t\t\t       hw_actions)) {\n\t\t\t \n\t\t\tlist_del_init(&cached_pattern->list);\n\t\t\tlist_add(&cached_pattern->list, &mgr->ptrn_list);\n\t\t\treturn cached_pattern;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mlx5dr_ptrn_obj *\ndr_ptrn_alloc_pattern(struct mlx5dr_ptrn_mgr *mgr,\n\t\t      u16 num_of_actions, u8 *data)\n{\n\tstruct mlx5dr_ptrn_obj *pattern;\n\tstruct mlx5dr_icm_chunk *chunk;\n\tu32 chunk_size;\n\tu32 index;\n\n\tchunk_size = ilog2(roundup_pow_of_two(num_of_actions));\n\t \n\tchunk_size = max_t(u32, chunk_size, DR_CHUNK_SIZE_8);\n\n\tchunk = mlx5dr_icm_alloc_chunk(mgr->ptrn_icm_pool, chunk_size);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tindex = (mlx5dr_icm_pool_get_chunk_icm_addr(chunk) -\n\t\t mgr->dmn->info.caps.hdr_modify_pattern_icm_addr) /\n\t\tDR_ACTION_CACHE_LINE_SIZE;\n\n\tpattern = kzalloc(sizeof(*pattern), GFP_KERNEL);\n\tif (!pattern)\n\t\tgoto free_chunk;\n\n\tpattern->data = kzalloc(num_of_actions * DR_MODIFY_ACTION_SIZE *\n\t\t\t\tsizeof(*pattern->data), GFP_KERNEL);\n\tif (!pattern->data)\n\t\tgoto free_pattern;\n\n\tmemcpy(pattern->data, data, num_of_actions * DR_MODIFY_ACTION_SIZE);\n\tpattern->chunk = chunk;\n\tpattern->index = index;\n\tpattern->num_of_actions = num_of_actions;\n\n\tlist_add(&pattern->list, &mgr->ptrn_list);\n\trefcount_set(&pattern->refcount, 1);\n\n\treturn pattern;\n\nfree_pattern:\n\tkfree(pattern);\nfree_chunk:\n\tmlx5dr_icm_free_chunk(chunk);\n\treturn NULL;\n}\n\nstatic void\ndr_ptrn_free_pattern(struct mlx5dr_ptrn_obj *pattern)\n{\n\tlist_del(&pattern->list);\n\tmlx5dr_icm_free_chunk(pattern->chunk);\n\tkfree(pattern->data);\n\tkfree(pattern);\n}\n\nstruct mlx5dr_ptrn_obj *\nmlx5dr_ptrn_cache_get_pattern(struct mlx5dr_ptrn_mgr *mgr,\n\t\t\t      u16 num_of_actions,\n\t\t\t      u8 *data)\n{\n\tstruct mlx5dr_ptrn_obj *pattern;\n\tu64 *hw_actions;\n\tu8 action_id;\n\tint i;\n\n\tmutex_lock(&mgr->modify_hdr_mutex);\n\tpattern = dr_ptrn_find_cached_pattern(mgr,\n\t\t\t\t\t      num_of_actions,\n\t\t\t\t\t      (__be64 *)data);\n\tif (!pattern) {\n\t\t \n\t\tpattern = dr_ptrn_alloc_pattern(mgr, num_of_actions, data);\n\t\tif (!pattern)\n\t\t\tgoto out_unlock;\n\n\t\thw_actions = (u64 *)pattern->data;\n\t\t \n\t\tfor (i = 0; i < num_of_actions; i++) {\n\t\t\taction_id = MLX5_GET(ste_double_action_set_v1, &hw_actions[i], action_id);\n\n\t\t\tif (action_id == DR_PTRN_MODIFY_HDR_ACTION_ID_SET ||\n\t\t\t    action_id == DR_PTRN_MODIFY_HDR_ACTION_ID_ADD ||\n\t\t\t    action_id == DR_PTRN_MODIFY_HDR_ACTION_ID_INSERT_INLINE)\n\t\t\t\tMLX5_SET(ste_double_action_set_v1, &hw_actions[i], inline_data, 0);\n\t\t}\n\n\t\tif (mlx5dr_send_postsend_pattern(mgr->dmn, pattern->chunk,\n\t\t\t\t\t\t num_of_actions, pattern->data)) {\n\t\t\trefcount_dec(&pattern->refcount);\n\t\t\tgoto free_pattern;\n\t\t}\n\t} else {\n\t\trefcount_inc(&pattern->refcount);\n\t}\n\n\tmutex_unlock(&mgr->modify_hdr_mutex);\n\n\treturn pattern;\n\nfree_pattern:\n\tdr_ptrn_free_pattern(pattern);\nout_unlock:\n\tmutex_unlock(&mgr->modify_hdr_mutex);\n\treturn NULL;\n}\n\nvoid\nmlx5dr_ptrn_cache_put_pattern(struct mlx5dr_ptrn_mgr *mgr,\n\t\t\t      struct mlx5dr_ptrn_obj *pattern)\n{\n\tmutex_lock(&mgr->modify_hdr_mutex);\n\n\tif (refcount_dec_and_test(&pattern->refcount))\n\t\tdr_ptrn_free_pattern(pattern);\n\n\tmutex_unlock(&mgr->modify_hdr_mutex);\n}\n\nstruct mlx5dr_ptrn_mgr *mlx5dr_ptrn_mgr_create(struct mlx5dr_domain *dmn)\n{\n\tstruct mlx5dr_ptrn_mgr *mgr;\n\n\tif (!mlx5dr_domain_is_support_ptrn_arg(dmn))\n\t\treturn NULL;\n\n\tmgr = kzalloc(sizeof(*mgr), GFP_KERNEL);\n\tif (!mgr)\n\t\treturn NULL;\n\n\tmgr->dmn = dmn;\n\tmgr->ptrn_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_MODIFY_HDR_PTRN);\n\tif (!mgr->ptrn_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get modify-header-pattern memory\\n\");\n\t\tgoto free_mgr;\n\t}\n\n\tINIT_LIST_HEAD(&mgr->ptrn_list);\n\tmutex_init(&mgr->modify_hdr_mutex);\n\n\treturn mgr;\n\nfree_mgr:\n\tkfree(mgr);\n\treturn NULL;\n}\n\nvoid mlx5dr_ptrn_mgr_destroy(struct mlx5dr_ptrn_mgr *mgr)\n{\n\tstruct mlx5dr_ptrn_obj *pattern;\n\tstruct mlx5dr_ptrn_obj *tmp;\n\n\tif (!mgr)\n\t\treturn;\n\n\tWARN_ON(!list_empty(&mgr->ptrn_list));\n\n\tlist_for_each_entry_safe(pattern, tmp, &mgr->ptrn_list, list) {\n\t\tlist_del(&pattern->list);\n\t\tkfree(pattern->data);\n\t\tkfree(pattern);\n\t}\n\n\tmlx5dr_icm_pool_destroy(mgr->ptrn_icm_pool);\n\tmutex_destroy(&mgr->modify_hdr_mutex);\n\tkfree(mgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}