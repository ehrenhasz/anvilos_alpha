{
  "module_name": "sample.c",
  "hash_id": "e4f30511dd51c26071eb8110788ba127bbfef2ad0d57ba14330291ab56484dac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc/sample.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n#include <net/psample.h>\n#include \"en/mapping.h\"\n#include \"en/tc/post_act.h\"\n#include \"en/tc/act/sample.h\"\n#include \"en/mod_hdr.h\"\n#include \"sample.h\"\n#include \"eswitch.h\"\n#include \"en_tc.h\"\n#include \"fs_core.h\"\n\n#define MLX5_ESW_VPORT_TBL_SIZE_SAMPLE (64 * 1024)\n\nstatic struct esw_vport_tbl_namespace mlx5_esw_vport_tbl_sample_ns = {\n\t.max_fte = MLX5_ESW_VPORT_TBL_SIZE_SAMPLE,\n\t.max_num_groups = 0,     \n\t.flags = 0,\n};\n\nstruct mlx5e_tc_psample {\n\tstruct mlx5_eswitch *esw;\n\tstruct mlx5_flow_table *termtbl;\n\tstruct mlx5_flow_handle *termtbl_rule;\n\tDECLARE_HASHTABLE(hashtbl, 8);\n\tstruct mutex ht_lock;  \n\tDECLARE_HASHTABLE(restore_hashtbl, 8);\n\tstruct mutex restore_lock;  \n\tstruct mlx5e_post_act *post_act;\n};\n\nstruct mlx5e_sampler {\n\tstruct hlist_node hlist;\n\tu32 sampler_id;\n\tu32 sample_ratio;\n\tu32 sample_table_id;\n\tu32 default_table_id;\n\tint count;\n};\n\nstruct mlx5e_sample_flow {\n\tstruct mlx5e_sampler *sampler;\n\tstruct mlx5e_sample_restore *restore;\n\tstruct mlx5_flow_attr *pre_attr;\n\tstruct mlx5_flow_handle *pre_rule;\n\tstruct mlx5_flow_attr *post_attr;\n\tstruct mlx5_flow_handle *post_rule;\n};\n\nstruct mlx5e_sample_restore {\n\tstruct hlist_node hlist;\n\tstruct mlx5_modify_hdr *modify_hdr;\n\tstruct mlx5_flow_handle *rule;\n\tu32 obj_id;\n\tint count;\n};\n\nstatic int\nsampler_termtbl_create(struct mlx5e_tc_psample *tc_psample)\n{\n\tstruct mlx5_eswitch *esw = tc_psample->esw;\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_core_dev *dev = esw->dev;\n\tstruct mlx5_flow_namespace *root_ns;\n\tstruct mlx5_flow_act act = {};\n\tint err;\n\n\tif (!MLX5_CAP_ESW_FLOWTABLE_FDB(dev, termination_table))  {\n\t\tmlx5_core_warn(dev, \"termination table is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\troot_ns = mlx5_get_flow_namespace(dev, MLX5_FLOW_NAMESPACE_FDB);\n\tif (!root_ns) {\n\t\tmlx5_core_warn(dev, \"failed to get FDB flow namespace\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tft_attr.flags = MLX5_FLOW_TABLE_TERMINATION | MLX5_FLOW_TABLE_UNMANAGED;\n\tft_attr.autogroup.max_num_groups = 1;\n\tft_attr.prio = FDB_SLOW_PATH;\n\tft_attr.max_fte = 1;\n\tft_attr.level = 1;\n\ttc_psample->termtbl = mlx5_create_auto_grouped_flow_table(root_ns, &ft_attr);\n\tif (IS_ERR(tc_psample->termtbl)) {\n\t\terr = PTR_ERR(tc_psample->termtbl);\n\t\tmlx5_core_warn(dev, \"failed to create termtbl, err: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tact.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tdest.vport.num = esw->manager_vport;\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_VPORT;\n\ttc_psample->termtbl_rule = mlx5_add_flow_rules(tc_psample->termtbl, NULL, &act, &dest, 1);\n\tif (IS_ERR(tc_psample->termtbl_rule)) {\n\t\terr = PTR_ERR(tc_psample->termtbl_rule);\n\t\tmlx5_core_warn(dev, \"failed to create termtbl rule, err: %d\\n\", err);\n\t\tmlx5_destroy_flow_table(tc_psample->termtbl);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nsampler_termtbl_destroy(struct mlx5e_tc_psample *tc_psample)\n{\n\tmlx5_del_flow_rules(tc_psample->termtbl_rule);\n\tmlx5_destroy_flow_table(tc_psample->termtbl);\n}\n\nstatic int\nsampler_obj_create(struct mlx5_core_dev *mdev, struct mlx5e_sampler *sampler)\n{\n\tu32 in[MLX5_ST_SZ_DW(create_sampler_obj_in)] = {};\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];\n\tu64 general_obj_types;\n\tvoid *obj;\n\tint err;\n\n\tgeneral_obj_types = MLX5_CAP_GEN_64(mdev, general_obj_types);\n\tif (!(general_obj_types & MLX5_HCA_CAP_GENERAL_OBJECT_TYPES_SAMPLER))\n\t\treturn -EOPNOTSUPP;\n\tif (!MLX5_CAP_ESW_FLOWTABLE_FDB(mdev, ignore_flow_level))\n\t\treturn -EOPNOTSUPP;\n\n\tobj = MLX5_ADDR_OF(create_sampler_obj_in, in, sampler_object);\n\tMLX5_SET(sampler_obj, obj, table_type, FS_FT_FDB);\n\tMLX5_SET(sampler_obj, obj, ignore_flow_level, 1);\n\tMLX5_SET(sampler_obj, obj, level, 1);\n\tMLX5_SET(sampler_obj, obj, sample_ratio, sampler->sample_ratio);\n\tMLX5_SET(sampler_obj, obj, sample_table_id, sampler->sample_table_id);\n\tMLX5_SET(sampler_obj, obj, default_table_id, sampler->default_table_id);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode, MLX5_CMD_OP_CREATE_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type, MLX5_GENERAL_OBJECT_TYPES_SAMPLER);\n\n\terr = mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n\tif (!err)\n\t\tsampler->sampler_id = MLX5_GET(general_obj_out_cmd_hdr, out, obj_id);\n\n\treturn err;\n}\n\nstatic void\nsampler_obj_destroy(struct mlx5_core_dev *mdev, u32 sampler_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(general_obj_in_cmd_hdr)] = {};\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode, MLX5_CMD_OP_DESTROY_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type, MLX5_GENERAL_OBJECT_TYPES_SAMPLER);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_id, sampler_id);\n\n\tmlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n}\n\nstatic u32\nsampler_hash(u32 sample_ratio, u32 default_table_id)\n{\n\treturn jhash_2words(sample_ratio, default_table_id, 0);\n}\n\nstatic int\nsampler_cmp(u32 sample_ratio1, u32 default_table_id1, u32 sample_ratio2, u32 default_table_id2)\n{\n\treturn sample_ratio1 != sample_ratio2 || default_table_id1 != default_table_id2;\n}\n\nstatic struct mlx5e_sampler *\nsampler_get(struct mlx5e_tc_psample *tc_psample, u32 sample_ratio, u32 default_table_id)\n{\n\tstruct mlx5e_sampler *sampler;\n\tu32 hash_key;\n\tint err;\n\n\tmutex_lock(&tc_psample->ht_lock);\n\thash_key = sampler_hash(sample_ratio, default_table_id);\n\thash_for_each_possible(tc_psample->hashtbl, sampler, hlist, hash_key)\n\t\tif (!sampler_cmp(sampler->sample_ratio, sampler->default_table_id,\n\t\t\t\t sample_ratio, default_table_id))\n\t\t\tgoto add_ref;\n\n\tsampler = kzalloc(sizeof(*sampler), GFP_KERNEL);\n\tif (!sampler) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tsampler->sample_table_id = tc_psample->termtbl->id;\n\tsampler->default_table_id = default_table_id;\n\tsampler->sample_ratio = sample_ratio;\n\n\terr = sampler_obj_create(tc_psample->esw->dev, sampler);\n\tif (err)\n\t\tgoto err_create;\n\n\thash_add(tc_psample->hashtbl, &sampler->hlist, hash_key);\n\nadd_ref:\n\tsampler->count++;\n\tmutex_unlock(&tc_psample->ht_lock);\n\treturn sampler;\n\nerr_create:\n\tkfree(sampler);\nerr_alloc:\n\tmutex_unlock(&tc_psample->ht_lock);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nsampler_put(struct mlx5e_tc_psample *tc_psample, struct mlx5e_sampler *sampler)\n{\n\tmutex_lock(&tc_psample->ht_lock);\n\tif (--sampler->count == 0) {\n\t\thash_del(&sampler->hlist);\n\t\tsampler_obj_destroy(tc_psample->esw->dev, sampler->sampler_id);\n\t\tkfree(sampler);\n\t}\n\tmutex_unlock(&tc_psample->ht_lock);\n}\n\n \nstatic struct mlx5_modify_hdr *\nsample_modify_hdr_get(struct mlx5_core_dev *mdev, u32 obj_id,\n\t\t      struct mlx5e_tc_mod_hdr_acts *mod_acts)\n{\n\tstruct mlx5_modify_hdr *modify_hdr;\n\tint err;\n\n\terr = mlx5e_tc_match_to_reg_set(mdev, mod_acts, MLX5_FLOW_NAMESPACE_FDB,\n\t\t\t\t\tMAPPED_OBJ_TO_REG, obj_id);\n\tif (err)\n\t\tgoto err_set_regc0;\n\n\tmodify_hdr = mlx5_modify_header_alloc(mdev, MLX5_FLOW_NAMESPACE_FDB,\n\t\t\t\t\t      mod_acts->num_actions,\n\t\t\t\t\t      mod_acts->actions);\n\tif (IS_ERR(modify_hdr)) {\n\t\terr = PTR_ERR(modify_hdr);\n\t\tgoto err_modify_hdr;\n\t}\n\n\tmlx5e_mod_hdr_dealloc(mod_acts);\n\treturn modify_hdr;\n\nerr_modify_hdr:\n\tmlx5e_mod_hdr_dealloc(mod_acts);\nerr_set_regc0:\n\treturn ERR_PTR(err);\n}\n\nstatic struct mlx5e_sample_restore *\nsample_restore_get(struct mlx5e_tc_psample *tc_psample, u32 obj_id,\n\t\t   struct mlx5e_tc_mod_hdr_acts *mod_acts)\n{\n\tstruct mlx5_eswitch *esw = tc_psample->esw;\n\tstruct mlx5_core_dev *mdev = esw->dev;\n\tstruct mlx5e_sample_restore *restore;\n\tstruct mlx5_modify_hdr *modify_hdr;\n\tint err;\n\n\tmutex_lock(&tc_psample->restore_lock);\n\thash_for_each_possible(tc_psample->restore_hashtbl, restore, hlist, obj_id)\n\t\tif (restore->obj_id == obj_id)\n\t\t\tgoto add_ref;\n\n\trestore = kzalloc(sizeof(*restore), GFP_KERNEL);\n\tif (!restore) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\trestore->obj_id = obj_id;\n\n\tmodify_hdr = sample_modify_hdr_get(mdev, obj_id, mod_acts);\n\tif (IS_ERR(modify_hdr)) {\n\t\terr = PTR_ERR(modify_hdr);\n\t\tgoto err_modify_hdr;\n\t}\n\trestore->modify_hdr = modify_hdr;\n\n\trestore->rule = esw_add_restore_rule(esw, obj_id);\n\tif (IS_ERR(restore->rule)) {\n\t\terr = PTR_ERR(restore->rule);\n\t\tgoto err_restore;\n\t}\n\n\thash_add(tc_psample->restore_hashtbl, &restore->hlist, obj_id);\nadd_ref:\n\trestore->count++;\n\tmutex_unlock(&tc_psample->restore_lock);\n\treturn restore;\n\nerr_restore:\n\tmlx5_modify_header_dealloc(mdev, restore->modify_hdr);\nerr_modify_hdr:\n\tkfree(restore);\nerr_alloc:\n\tmutex_unlock(&tc_psample->restore_lock);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nsample_restore_put(struct mlx5e_tc_psample *tc_psample, struct mlx5e_sample_restore *restore)\n{\n\tmutex_lock(&tc_psample->restore_lock);\n\tif (--restore->count == 0)\n\t\thash_del(&restore->hlist);\n\tmutex_unlock(&tc_psample->restore_lock);\n\n\tif (!restore->count) {\n\t\tmlx5_del_flow_rules(restore->rule);\n\t\tmlx5_modify_header_dealloc(tc_psample->esw->dev, restore->modify_hdr);\n\t\tkfree(restore);\n\t}\n}\n\nvoid mlx5e_tc_sample_skb(struct sk_buff *skb, struct mlx5_mapped_obj *mapped_obj)\n{\n\tu32 trunc_size = mapped_obj->sample.trunc_size;\n\tstruct psample_group psample_group = {};\n\tstruct psample_metadata md = {};\n\n\tmd.trunc_size = trunc_size ? min(trunc_size, skb->len) : skb->len;\n\tmd.in_ifindex = skb->dev->ifindex;\n\tpsample_group.group_num = mapped_obj->sample.group_id;\n\tpsample_group.net = &init_net;\n\tskb_push(skb, skb->mac_len);\n\n\tpsample_sample_packet(&psample_group, skb, mapped_obj->sample.rate, &md);\n}\n\nstatic int\nadd_post_rule(struct mlx5_eswitch *esw, struct mlx5e_sample_flow *sample_flow,\n\t      struct mlx5_flow_spec *spec, struct mlx5_flow_attr *attr,\n\t      u32 *default_tbl_id)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\tu32 attr_sz = ns_to_attr_sz(MLX5_FLOW_NAMESPACE_FDB);\n\tstruct mlx5_vport_tbl_attr per_vport_tbl_attr;\n\tstruct mlx5_flow_table *default_tbl;\n\tstruct mlx5_flow_attr *post_attr;\n\tint err;\n\n\t \n\tper_vport_tbl_attr.chain = attr->chain;\n\tper_vport_tbl_attr.prio = attr->prio;\n\tper_vport_tbl_attr.vport = esw_attr->in_rep->vport;\n\tper_vport_tbl_attr.vport_ns = &mlx5_esw_vport_tbl_sample_ns;\n\tdefault_tbl = mlx5_esw_vporttbl_get(esw, &per_vport_tbl_attr);\n\tif (IS_ERR(default_tbl)) {\n\t\terr = PTR_ERR(default_tbl);\n\t\tgoto err_default_tbl;\n\t}\n\t*default_tbl_id = default_tbl->id;\n\n\tpost_attr = mlx5_alloc_flow_attr(MLX5_FLOW_NAMESPACE_FDB);\n\tif (!post_attr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_attr;\n\t}\n\tsample_flow->post_attr = post_attr;\n\tmemcpy(post_attr, attr, attr_sz);\n\t \n\tpost_attr->chain = 0;\n\tpost_attr->prio = 0;\n\tpost_attr->ft = default_tbl;\n\tpost_attr->flags = MLX5_ATTR_FLAG_NO_IN_PORT;\n\n\t \n\tmlx5_eswitch_clear_rule_source_port(esw, spec);\n\tsample_flow->post_rule = mlx5_eswitch_add_offloaded_rule(esw, spec, post_attr);\n\tif (IS_ERR(sample_flow->post_rule)) {\n\t\terr = PTR_ERR(sample_flow->post_rule);\n\t\tgoto err_rule;\n\t}\n\treturn 0;\n\nerr_rule:\n\tkfree(post_attr);\nerr_attr:\n\tmlx5_esw_vporttbl_put(esw, &per_vport_tbl_attr);\nerr_default_tbl:\n\treturn err;\n}\n\nstatic void\ndel_post_rule(struct mlx5_eswitch *esw, struct mlx5e_sample_flow *sample_flow,\n\t      struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\tstruct mlx5_vport_tbl_attr tbl_attr;\n\n\tmlx5_eswitch_del_offloaded_rule(esw, sample_flow->post_rule, sample_flow->post_attr);\n\tkfree(sample_flow->post_attr);\n\ttbl_attr.chain = attr->chain;\n\ttbl_attr.prio = attr->prio;\n\ttbl_attr.vport = esw_attr->in_rep->vport;\n\ttbl_attr.vport_ns = &mlx5_esw_vport_tbl_sample_ns;\n\tmlx5_esw_vporttbl_put(esw, &tbl_attr);\n}\n\n \nstruct mlx5_flow_handle *\nmlx5e_tc_sample_offload(struct mlx5e_tc_psample *tc_psample,\n\t\t\tstruct mlx5_flow_spec *spec,\n\t\t\tstruct mlx5_flow_attr *attr)\n{\n\tstruct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;\n\tstruct mlx5_esw_flow_attr *pre_esw_attr;\n\tstruct mlx5_mapped_obj restore_obj = {};\n\tstruct mlx5e_tc_mod_hdr_acts *mod_acts;\n\tstruct mlx5e_sample_flow *sample_flow;\n\tstruct mlx5e_sample_attr *sample_attr;\n\tstruct mlx5_flow_attr *pre_attr;\n\tstruct mlx5_eswitch *esw;\n\tu32 default_tbl_id;\n\tu32 obj_id;\n\tint err;\n\n\tif (IS_ERR_OR_NULL(tc_psample))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tsample_flow = kzalloc(sizeof(*sample_flow), GFP_KERNEL);\n\tif (!sample_flow)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsample_attr = &attr->sample_attr;\n\tsample_attr->sample_flow = sample_flow;\n\n\t \n\tesw = tc_psample->esw;\n\tif (mlx5e_tc_act_sample_is_multi_table(esw->dev, attr)) {\n\t\tstruct mlx5_flow_table *ft;\n\n\t\tft = mlx5e_tc_post_act_get_ft(tc_psample->post_act);\n\t\tdefault_tbl_id = ft->id;\n\t} else {\n\t\terr = add_post_rule(esw, sample_flow, spec, attr, &default_tbl_id);\n\t\tif (err)\n\t\t\tgoto err_post_rule;\n\t}\n\n\t \n\tsample_flow->sampler = sampler_get(tc_psample, sample_attr->rate, default_tbl_id);\n\tif (IS_ERR(sample_flow->sampler)) {\n\t\terr = PTR_ERR(sample_flow->sampler);\n\t\tgoto err_sampler;\n\t}\n\tsample_attr->sampler_id = sample_flow->sampler->sampler_id;\n\n\t \n\trestore_obj.type = MLX5_MAPPED_OBJ_SAMPLE;\n\trestore_obj.sample.group_id = sample_attr->group_num;\n\trestore_obj.sample.rate = sample_attr->rate;\n\trestore_obj.sample.trunc_size = sample_attr->trunc_size;\n\trestore_obj.sample.tunnel_id = attr->tunnel_id;\n\terr = mapping_add(esw->offloads.reg_c0_obj_pool, &restore_obj, &obj_id);\n\tif (err)\n\t\tgoto err_obj_id;\n\tsample_attr->restore_obj_id = obj_id;\n\n\t \n\tmod_acts = &attr->parse_attr->mod_hdr_acts;\n\tsample_flow->restore = sample_restore_get(tc_psample, obj_id, mod_acts);\n\tif (IS_ERR(sample_flow->restore)) {\n\t\terr = PTR_ERR(sample_flow->restore);\n\t\tgoto err_sample_restore;\n\t}\n\n\t \n\tpre_attr = mlx5_alloc_flow_attr(MLX5_FLOW_NAMESPACE_FDB);\n\tif (!pre_attr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_pre_flow_attr;\n\t}\n\tpre_attr->action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST | MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\t \n\tif (attr->action & MLX5_FLOW_CONTEXT_ACTION_DECAP)\n\t\tpre_attr->action |= MLX5_FLOW_CONTEXT_ACTION_DECAP;\n\tpre_attr->modify_hdr = sample_flow->restore->modify_hdr;\n\tpre_attr->flags = MLX5_ATTR_FLAG_SAMPLE;\n\tpre_attr->inner_match_level = attr->inner_match_level;\n\tpre_attr->outer_match_level = attr->outer_match_level;\n\tpre_attr->chain = attr->chain;\n\tpre_attr->prio = attr->prio;\n\tpre_attr->ft = attr->ft;\n\tpre_attr->sample_attr = *sample_attr;\n\tpre_esw_attr = pre_attr->esw_attr;\n\tpre_esw_attr->in_mdev = esw_attr->in_mdev;\n\tpre_esw_attr->in_rep = esw_attr->in_rep;\n\tsample_flow->pre_rule = mlx5_eswitch_add_offloaded_rule(esw, spec, pre_attr);\n\tif (IS_ERR(sample_flow->pre_rule)) {\n\t\terr = PTR_ERR(sample_flow->pre_rule);\n\t\tgoto err_pre_offload_rule;\n\t}\n\tsample_flow->pre_attr = pre_attr;\n\n\treturn sample_flow->pre_rule;\n\nerr_pre_offload_rule:\n\tkfree(pre_attr);\nerr_alloc_pre_flow_attr:\n\tsample_restore_put(tc_psample, sample_flow->restore);\nerr_sample_restore:\n\tmapping_remove(esw->offloads.reg_c0_obj_pool, obj_id);\nerr_obj_id:\n\tsampler_put(tc_psample, sample_flow->sampler);\nerr_sampler:\n\tif (sample_flow->post_rule)\n\t\tdel_post_rule(esw, sample_flow, attr);\nerr_post_rule:\n\tkfree(sample_flow);\n\treturn ERR_PTR(err);\n}\n\nvoid\nmlx5e_tc_sample_unoffload(struct mlx5e_tc_psample *tc_psample,\n\t\t\t  struct mlx5_flow_handle *rule,\n\t\t\t  struct mlx5_flow_attr *attr)\n{\n\tstruct mlx5e_sample_flow *sample_flow;\n\tstruct mlx5_eswitch *esw;\n\n\tif (IS_ERR_OR_NULL(tc_psample))\n\t\treturn;\n\n\t \n\tesw = tc_psample->esw;\n\tsample_flow = attr->sample_attr.sample_flow;\n\tmlx5_eswitch_del_offloaded_rule(esw, sample_flow->pre_rule, sample_flow->pre_attr);\n\n\tsample_restore_put(tc_psample, sample_flow->restore);\n\tmapping_remove(esw->offloads.reg_c0_obj_pool, attr->sample_attr.restore_obj_id);\n\tsampler_put(tc_psample, sample_flow->sampler);\n\tif (sample_flow->post_rule)\n\t\tdel_post_rule(esw, sample_flow, attr);\n\n\tkfree(sample_flow->pre_attr);\n\tkfree(sample_flow);\n}\n\nstruct mlx5e_tc_psample *\nmlx5e_tc_sample_init(struct mlx5_eswitch *esw, struct mlx5e_post_act *post_act)\n{\n\tstruct mlx5e_tc_psample *tc_psample;\n\tint err;\n\n\ttc_psample = kzalloc(sizeof(*tc_psample), GFP_KERNEL);\n\tif (!tc_psample)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (IS_ERR_OR_NULL(post_act)) {\n\t\terr = PTR_ERR(post_act);\n\t\tgoto err_post_act;\n\t}\n\ttc_psample->post_act = post_act;\n\ttc_psample->esw = esw;\n\terr = sampler_termtbl_create(tc_psample);\n\tif (err)\n\t\tgoto err_post_act;\n\n\tmutex_init(&tc_psample->ht_lock);\n\tmutex_init(&tc_psample->restore_lock);\n\n\treturn tc_psample;\n\nerr_post_act:\n\tkfree(tc_psample);\n\treturn ERR_PTR(err);\n}\n\nvoid\nmlx5e_tc_sample_cleanup(struct mlx5e_tc_psample *tc_psample)\n{\n\tif (IS_ERR_OR_NULL(tc_psample))\n\t\treturn;\n\n\tmutex_destroy(&tc_psample->restore_lock);\n\tmutex_destroy(&tc_psample->ht_lock);\n\tsampler_termtbl_destroy(tc_psample);\n\tkfree(tc_psample);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}