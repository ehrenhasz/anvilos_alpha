{
  "module_name": "dr_cmd.c",
  "hash_id": "5098bd1c75b6efbd3d6beb3af4b0606181032bc8474a1ea1628ea080eca3a472",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/steering/dr_cmd.c",
  "human_readable_source": "\n \n\n#include \"dr_types.h\"\n\nint mlx5dr_cmd_query_esw_vport_context(struct mlx5_core_dev *mdev,\n\t\t\t\t       bool other_vport,\n\t\t\t\t       u16 vport_number,\n\t\t\t\t       u64 *icm_address_rx,\n\t\t\t\t       u64 *icm_address_tx)\n{\n\tu32 out[MLX5_ST_SZ_DW(query_esw_vport_context_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(query_esw_vport_context_in)] = {};\n\tint err;\n\n\tMLX5_SET(query_esw_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_QUERY_ESW_VPORT_CONTEXT);\n\tMLX5_SET(query_esw_vport_context_in, in, other_vport, other_vport);\n\tMLX5_SET(query_esw_vport_context_in, in, vport_number, vport_number);\n\n\terr = mlx5_cmd_exec_inout(mdev, query_esw_vport_context, in, out);\n\tif (err)\n\t\treturn err;\n\n\t*icm_address_rx =\n\t\tMLX5_GET64(query_esw_vport_context_out, out,\n\t\t\t   esw_vport_context.sw_steering_vport_icm_address_rx);\n\t*icm_address_tx =\n\t\tMLX5_GET64(query_esw_vport_context_out, out,\n\t\t\t   esw_vport_context.sw_steering_vport_icm_address_tx);\n\treturn 0;\n}\n\nint mlx5dr_cmd_query_gvmi(struct mlx5_core_dev *mdev, bool other_vport,\n\t\t\t  u16 vport_number, u16 *gvmi)\n{\n\tbool ec_vf_func = other_vport ? mlx5_core_is_ec_vf_vport(mdev, vport_number) : false;\n\tu32 in[MLX5_ST_SZ_DW(query_hca_cap_in)] = {};\n\tint out_size;\n\tvoid *out;\n\tint err;\n\n\tout_size = MLX5_ST_SZ_BYTES(query_hca_cap_out);\n\tout = kzalloc(out_size, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(query_hca_cap_in, in, opcode, MLX5_CMD_OP_QUERY_HCA_CAP);\n\tMLX5_SET(query_hca_cap_in, in, other_function, other_vport);\n\tMLX5_SET(query_hca_cap_in, in, function_id, mlx5_vport_to_func_id(mdev, vport_number, ec_vf_func));\n\tMLX5_SET(query_hca_cap_in, in, ec_vf_function, ec_vf_func);\n\tMLX5_SET(query_hca_cap_in, in, op_mod,\n\t\t MLX5_SET_HCA_CAP_OP_MOD_GENERAL_DEVICE << 1 |\n\t\t HCA_CAP_OPMOD_GET_CUR);\n\n\terr = mlx5_cmd_exec_inout(mdev, query_hca_cap, in, out);\n\tif (err) {\n\t\tkfree(out);\n\t\treturn err;\n\t}\n\n\t*gvmi = MLX5_GET(query_hca_cap_out, out, capability.cmd_hca_cap.vhca_id);\n\n\tkfree(out);\n\treturn 0;\n}\n\nint mlx5dr_cmd_query_esw_caps(struct mlx5_core_dev *mdev,\n\t\t\t      struct mlx5dr_esw_caps *caps)\n{\n\tcaps->drop_icm_address_rx =\n\t\tMLX5_CAP64_ESW_FLOWTABLE(mdev,\n\t\t\t\t\t sw_steering_fdb_action_drop_icm_address_rx);\n\tcaps->drop_icm_address_tx =\n\t\tMLX5_CAP64_ESW_FLOWTABLE(mdev,\n\t\t\t\t\t sw_steering_fdb_action_drop_icm_address_tx);\n\tcaps->uplink_icm_address_rx =\n\t\tMLX5_CAP64_ESW_FLOWTABLE(mdev,\n\t\t\t\t\t sw_steering_uplink_icm_address_rx);\n\tcaps->uplink_icm_address_tx =\n\t\tMLX5_CAP64_ESW_FLOWTABLE(mdev,\n\t\t\t\t\t sw_steering_uplink_icm_address_tx);\n\tcaps->sw_owner_v2 = MLX5_CAP_ESW_FLOWTABLE_FDB(mdev, sw_owner_v2);\n\tif (!caps->sw_owner_v2)\n\t\tcaps->sw_owner = MLX5_CAP_ESW_FLOWTABLE_FDB(mdev, sw_owner);\n\n\treturn 0;\n}\n\nstatic int dr_cmd_query_nic_vport_roce_en(struct mlx5_core_dev *mdev,\n\t\t\t\t\t  u16 vport, bool *roce_en)\n{\n\tu32 out[MLX5_ST_SZ_DW(query_nic_vport_context_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(query_nic_vport_context_in)] = {};\n\tint err;\n\n\tMLX5_SET(query_nic_vport_context_in, in, opcode,\n\t\t MLX5_CMD_OP_QUERY_NIC_VPORT_CONTEXT);\n\tMLX5_SET(query_nic_vport_context_in, in, vport_number, vport);\n\tMLX5_SET(query_nic_vport_context_in, in, other_vport, !!vport);\n\n\terr = mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n\tif (err)\n\t\treturn err;\n\n\t*roce_en = MLX5_GET(query_nic_vport_context_out, out,\n\t\t\t    nic_vport_context.roce_en);\n\treturn 0;\n}\n\nint mlx5dr_cmd_query_device(struct mlx5_core_dev *mdev,\n\t\t\t    struct mlx5dr_cmd_caps *caps)\n{\n\tbool roce_en;\n\tint err;\n\n\tcaps->prio_tag_required\t= MLX5_CAP_GEN(mdev, prio_tag_required);\n\tcaps->eswitch_manager\t= MLX5_CAP_GEN(mdev, eswitch_manager);\n\tcaps->gvmi\t\t= MLX5_CAP_GEN(mdev, vhca_id);\n\tcaps->flex_protocols\t= MLX5_CAP_GEN(mdev, flex_parser_protocols);\n\tcaps->sw_format_ver\t= MLX5_CAP_GEN(mdev, steering_format_version);\n\tcaps->roce_caps.fl_rc_qp_when_roce_disabled =\n\t\tMLX5_CAP_GEN(mdev, fl_rc_qp_when_roce_disabled);\n\n\tif (MLX5_CAP_GEN(mdev, roce)) {\n\t\terr = dr_cmd_query_nic_vport_roce_en(mdev, 0, &roce_en);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcaps->roce_caps.roce_en = roce_en;\n\t\tcaps->roce_caps.fl_rc_qp_when_roce_disabled |=\n\t\t\tMLX5_CAP_ROCE(mdev, fl_rc_qp_when_roce_disabled);\n\t\tcaps->roce_caps.fl_rc_qp_when_roce_enabled =\n\t\t\tMLX5_CAP_ROCE(mdev, fl_rc_qp_when_roce_enabled);\n\t}\n\n\tcaps->isolate_vl_tc = MLX5_CAP_GEN(mdev, isolate_vl_tc_new);\n\n\tcaps->support_modify_argument =\n\t\tMLX5_CAP_GEN_64(mdev, general_obj_types) &\n\t\tMLX5_GENERAL_OBJ_TYPES_CAP_HEADER_MODIFY_ARGUMENT;\n\n\tif (caps->support_modify_argument) {\n\t\tcaps->log_header_modify_argument_granularity =\n\t\t\tMLX5_CAP_GEN(mdev, log_header_modify_argument_granularity);\n\t\tcaps->log_header_modify_argument_max_alloc =\n\t\t\tMLX5_CAP_GEN(mdev, log_header_modify_argument_max_alloc);\n\t}\n\n\t \n\tcaps->flex_parser_ok_bits_supp =\n\t\tMLX5_CAP_FLOWTABLE(mdev,\n\t\t\t\t   flow_table_properties_nic_receive.ft_field_support.geneve_tlv_option_0_exist);\n\n\tif (caps->flex_protocols & MLX5_FLEX_PARSER_ICMP_V4_ENABLED) {\n\t\tcaps->flex_parser_id_icmp_dw0 = MLX5_CAP_GEN(mdev, flex_parser_id_icmp_dw0);\n\t\tcaps->flex_parser_id_icmp_dw1 = MLX5_CAP_GEN(mdev, flex_parser_id_icmp_dw1);\n\t}\n\n\tif (caps->flex_protocols & MLX5_FLEX_PARSER_ICMP_V6_ENABLED) {\n\t\tcaps->flex_parser_id_icmpv6_dw0 =\n\t\t\tMLX5_CAP_GEN(mdev, flex_parser_id_icmpv6_dw0);\n\t\tcaps->flex_parser_id_icmpv6_dw1 =\n\t\t\tMLX5_CAP_GEN(mdev, flex_parser_id_icmpv6_dw1);\n\t}\n\n\tif (caps->flex_protocols & MLX5_FLEX_PARSER_GENEVE_TLV_OPTION_0_ENABLED)\n\t\tcaps->flex_parser_id_geneve_tlv_option_0 =\n\t\t\tMLX5_CAP_GEN(mdev, flex_parser_id_geneve_tlv_option_0);\n\n\tif (caps->flex_protocols & MLX5_FLEX_PARSER_MPLS_OVER_GRE_ENABLED)\n\t\tcaps->flex_parser_id_mpls_over_gre =\n\t\t\tMLX5_CAP_GEN(mdev, flex_parser_id_outer_first_mpls_over_gre);\n\n\tif (caps->flex_protocols & MLX5_FLEX_PARSER_MPLS_OVER_UDP_ENABLED)\n\t\tcaps->flex_parser_id_mpls_over_udp =\n\t\t\tMLX5_CAP_GEN(mdev, flex_parser_id_outer_first_mpls_over_udp_label);\n\n\tif (caps->flex_protocols & MLX5_FLEX_PARSER_GTPU_DW_0_ENABLED)\n\t\tcaps->flex_parser_id_gtpu_dw_0 =\n\t\t\tMLX5_CAP_GEN(mdev, flex_parser_id_gtpu_dw_0);\n\n\tif (caps->flex_protocols & MLX5_FLEX_PARSER_GTPU_TEID_ENABLED)\n\t\tcaps->flex_parser_id_gtpu_teid =\n\t\t\tMLX5_CAP_GEN(mdev, flex_parser_id_gtpu_teid);\n\n\tif (caps->flex_protocols & MLX5_FLEX_PARSER_GTPU_DW_2_ENABLED)\n\t\tcaps->flex_parser_id_gtpu_dw_2 =\n\t\t\tMLX5_CAP_GEN(mdev, flex_parser_id_gtpu_dw_2);\n\n\tif (caps->flex_protocols & MLX5_FLEX_PARSER_GTPU_FIRST_EXT_DW_0_ENABLED)\n\t\tcaps->flex_parser_id_gtpu_first_ext_dw_0 =\n\t\t\tMLX5_CAP_GEN(mdev, flex_parser_id_gtpu_first_ext_dw_0);\n\n\tcaps->nic_rx_drop_address =\n\t\tMLX5_CAP64_FLOWTABLE(mdev, sw_steering_nic_rx_action_drop_icm_address);\n\tcaps->nic_tx_drop_address =\n\t\tMLX5_CAP64_FLOWTABLE(mdev, sw_steering_nic_tx_action_drop_icm_address);\n\tcaps->nic_tx_allow_address =\n\t\tMLX5_CAP64_FLOWTABLE(mdev, sw_steering_nic_tx_action_allow_icm_address);\n\n\tcaps->rx_sw_owner_v2 = MLX5_CAP_FLOWTABLE_NIC_RX(mdev, sw_owner_v2);\n\tcaps->tx_sw_owner_v2 = MLX5_CAP_FLOWTABLE_NIC_TX(mdev, sw_owner_v2);\n\n\tif (!caps->rx_sw_owner_v2)\n\t\tcaps->rx_sw_owner = MLX5_CAP_FLOWTABLE_NIC_RX(mdev, sw_owner);\n\tif (!caps->tx_sw_owner_v2)\n\t\tcaps->tx_sw_owner = MLX5_CAP_FLOWTABLE_NIC_TX(mdev, sw_owner);\n\n\tcaps->max_ft_level = MLX5_CAP_FLOWTABLE_NIC_RX(mdev, max_ft_level);\n\n\tcaps->log_icm_size = MLX5_CAP_DEV_MEM(mdev, log_steering_sw_icm_size);\n\tcaps->hdr_modify_icm_addr =\n\t\tMLX5_CAP64_DEV_MEM(mdev, header_modify_sw_icm_start_address);\n\n\tcaps->log_modify_pattern_icm_size =\n\t\tMLX5_CAP_DEV_MEM(mdev, log_header_modify_pattern_sw_icm_size);\n\n\tcaps->hdr_modify_pattern_icm_addr =\n\t\tMLX5_CAP64_DEV_MEM(mdev, header_modify_pattern_sw_icm_start_address);\n\n\tcaps->roce_min_src_udp = MLX5_CAP_ROCE(mdev, r_roce_min_src_udp_port);\n\n\tcaps->is_ecpf = mlx5_core_is_ecpf_esw_manager(mdev);\n\n\treturn 0;\n}\n\nint mlx5dr_cmd_query_flow_table(struct mlx5_core_dev *dev,\n\t\t\t\tenum fs_flow_table_type type,\n\t\t\t\tu32 table_id,\n\t\t\t\tstruct mlx5dr_cmd_query_flow_table_details *output)\n{\n\tu32 out[MLX5_ST_SZ_DW(query_flow_table_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(query_flow_table_in)] = {};\n\tint err;\n\n\tMLX5_SET(query_flow_table_in, in, opcode,\n\t\t MLX5_CMD_OP_QUERY_FLOW_TABLE);\n\n\tMLX5_SET(query_flow_table_in, in, table_type, type);\n\tMLX5_SET(query_flow_table_in, in, table_id, table_id);\n\n\terr = mlx5_cmd_exec_inout(dev, query_flow_table, in, out);\n\tif (err)\n\t\treturn err;\n\n\toutput->status = MLX5_GET(query_flow_table_out, out, status);\n\toutput->level = MLX5_GET(query_flow_table_out, out, flow_table_context.level);\n\n\toutput->sw_owner_icm_root_1 = MLX5_GET64(query_flow_table_out, out,\n\t\t\t\t\t\t flow_table_context.sw_owner_icm_root_1);\n\toutput->sw_owner_icm_root_0 = MLX5_GET64(query_flow_table_out, out,\n\t\t\t\t\t\t flow_table_context.sw_owner_icm_root_0);\n\n\treturn 0;\n}\n\nint mlx5dr_cmd_query_flow_sampler(struct mlx5_core_dev *dev,\n\t\t\t\t  u32 sampler_id,\n\t\t\t\t  u64 *rx_icm_addr,\n\t\t\t\t  u64 *tx_icm_addr)\n{\n\tu32 out[MLX5_ST_SZ_DW(query_sampler_obj_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(general_obj_in_cmd_hdr)] = {};\n\tvoid *attr;\n\tint ret;\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode,\n\t\t MLX5_CMD_OP_QUERY_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type,\n\t\t MLX5_GENERAL_OBJECT_TYPES_SAMPLER);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_id, sampler_id);\n\n\tret = mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));\n\tif (ret)\n\t\treturn ret;\n\n\tattr = MLX5_ADDR_OF(query_sampler_obj_out, out, sampler_object);\n\n\t*rx_icm_addr = MLX5_GET64(sampler_obj, attr,\n\t\t\t\t  sw_steering_icm_address_rx);\n\t*tx_icm_addr = MLX5_GET64(sampler_obj, attr,\n\t\t\t\t  sw_steering_icm_address_tx);\n\n\treturn 0;\n}\n\nint mlx5dr_cmd_sync_steering(struct mlx5_core_dev *mdev)\n{\n\tu32 in[MLX5_ST_SZ_DW(sync_steering_in)] = {};\n\n\t \n\tif (mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR)\n\t\treturn 0;\n\n\tMLX5_SET(sync_steering_in, in, opcode, MLX5_CMD_OP_SYNC_STEERING);\n\n\treturn mlx5_cmd_exec_in(mdev, sync_steering, in);\n}\n\nint mlx5dr_cmd_set_fte_modify_and_vport(struct mlx5_core_dev *mdev,\n\t\t\t\t\tu32 table_type,\n\t\t\t\t\tu32 table_id,\n\t\t\t\t\tu32 group_id,\n\t\t\t\t\tu32 modify_header_id,\n\t\t\t\t\tu16 vport)\n{\n\tu32 out[MLX5_ST_SZ_DW(set_fte_out)] = {};\n\tvoid *in_flow_context;\n\tunsigned int inlen;\n\tvoid *in_dests;\n\tu32 *in;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(set_fte_in) +\n\t\t1 * MLX5_ST_SZ_BYTES(dest_format_struct);  \n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(set_fte_in, in, opcode, MLX5_CMD_OP_SET_FLOW_TABLE_ENTRY);\n\tMLX5_SET(set_fte_in, in, table_type, table_type);\n\tMLX5_SET(set_fte_in, in, table_id, table_id);\n\n\tin_flow_context = MLX5_ADDR_OF(set_fte_in, in, flow_context);\n\tMLX5_SET(flow_context, in_flow_context, group_id, group_id);\n\tMLX5_SET(flow_context, in_flow_context, modify_header_id, modify_header_id);\n\tMLX5_SET(flow_context, in_flow_context, destination_list_size, 1);\n\tMLX5_SET(flow_context, in_flow_context, action,\n\t\t MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |\n\t\t MLX5_FLOW_CONTEXT_ACTION_MOD_HDR);\n\n\tin_dests = MLX5_ADDR_OF(flow_context, in_flow_context, destination);\n\tMLX5_SET(dest_format_struct, in_dests, destination_type,\n\t\t MLX5_IFC_FLOW_DESTINATION_TYPE_VPORT);\n\tMLX5_SET(dest_format_struct, in_dests, destination_id, vport);\n\n\terr = mlx5_cmd_exec(mdev, in, inlen, out, sizeof(out));\n\tkvfree(in);\n\n\treturn err;\n}\n\nint mlx5dr_cmd_del_flow_table_entry(struct mlx5_core_dev *mdev,\n\t\t\t\t    u32 table_type,\n\t\t\t\t    u32 table_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(delete_fte_in)] = {};\n\n\tMLX5_SET(delete_fte_in, in, opcode, MLX5_CMD_OP_DELETE_FLOW_TABLE_ENTRY);\n\tMLX5_SET(delete_fte_in, in, table_type, table_type);\n\tMLX5_SET(delete_fte_in, in, table_id, table_id);\n\n\treturn mlx5_cmd_exec_in(mdev, delete_fte, in);\n}\n\nint mlx5dr_cmd_alloc_modify_header(struct mlx5_core_dev *mdev,\n\t\t\t\t   u32 table_type,\n\t\t\t\t   u8 num_of_actions,\n\t\t\t\t   u64 *actions,\n\t\t\t\t   u32 *modify_header_id)\n{\n\tu32 out[MLX5_ST_SZ_DW(alloc_modify_header_context_out)] = {};\n\tvoid *p_actions;\n\tu32 inlen;\n\tu32 *in;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(alloc_modify_header_context_in) +\n\t\t num_of_actions * sizeof(u64);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(alloc_modify_header_context_in, in, opcode,\n\t\t MLX5_CMD_OP_ALLOC_MODIFY_HEADER_CONTEXT);\n\tMLX5_SET(alloc_modify_header_context_in, in, table_type, table_type);\n\tMLX5_SET(alloc_modify_header_context_in, in, num_of_actions, num_of_actions);\n\tp_actions = MLX5_ADDR_OF(alloc_modify_header_context_in, in, actions);\n\tmemcpy(p_actions, actions, num_of_actions * sizeof(u64));\n\n\terr = mlx5_cmd_exec(mdev, in, inlen, out, sizeof(out));\n\tif (err)\n\t\tgoto out;\n\n\t*modify_header_id = MLX5_GET(alloc_modify_header_context_out, out,\n\t\t\t\t     modify_header_id);\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nint mlx5dr_cmd_dealloc_modify_header(struct mlx5_core_dev *mdev,\n\t\t\t\t     u32 modify_header_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(dealloc_modify_header_context_in)] = {};\n\n\tMLX5_SET(dealloc_modify_header_context_in, in, opcode,\n\t\t MLX5_CMD_OP_DEALLOC_MODIFY_HEADER_CONTEXT);\n\tMLX5_SET(dealloc_modify_header_context_in, in, modify_header_id,\n\t\t modify_header_id);\n\n\treturn mlx5_cmd_exec_in(mdev, dealloc_modify_header_context, in);\n}\n\nint mlx5dr_cmd_create_empty_flow_group(struct mlx5_core_dev *mdev,\n\t\t\t\t       u32 table_type,\n\t\t\t\t       u32 table_id,\n\t\t\t\t       u32 *group_id)\n{\n\tu32 out[MLX5_ST_SZ_DW(create_flow_group_out)] = {};\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tu32 *in;\n\tint err;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(create_flow_group_in, in, opcode, MLX5_CMD_OP_CREATE_FLOW_GROUP);\n\tMLX5_SET(create_flow_group_in, in, table_type, table_type);\n\tMLX5_SET(create_flow_group_in, in, table_id, table_id);\n\n\terr = mlx5_cmd_exec_inout(mdev, create_flow_group, in, out);\n\tif (err)\n\t\tgoto out;\n\n\t*group_id = MLX5_GET(create_flow_group_out, out, group_id);\n\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nint mlx5dr_cmd_destroy_flow_group(struct mlx5_core_dev *mdev,\n\t\t\t\t  u32 table_type,\n\t\t\t\t  u32 table_id,\n\t\t\t\t  u32 group_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(destroy_flow_group_in)] = {};\n\n\tMLX5_SET(destroy_flow_group_in, in, opcode,\n\t\t MLX5_CMD_OP_DESTROY_FLOW_GROUP);\n\tMLX5_SET(destroy_flow_group_in, in, table_type, table_type);\n\tMLX5_SET(destroy_flow_group_in, in, table_id, table_id);\n\tMLX5_SET(destroy_flow_group_in, in, group_id, group_id);\n\n\treturn mlx5_cmd_exec_in(mdev, destroy_flow_group, in);\n}\n\nint mlx5dr_cmd_create_flow_table(struct mlx5_core_dev *mdev,\n\t\t\t\t struct mlx5dr_cmd_create_flow_table_attr *attr,\n\t\t\t\t u64 *fdb_rx_icm_addr,\n\t\t\t\t u32 *table_id)\n{\n\tu32 out[MLX5_ST_SZ_DW(create_flow_table_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(create_flow_table_in)] = {};\n\tvoid *ft_mdev;\n\tint err;\n\n\tMLX5_SET(create_flow_table_in, in, opcode, MLX5_CMD_OP_CREATE_FLOW_TABLE);\n\tMLX5_SET(create_flow_table_in, in, table_type, attr->table_type);\n\tMLX5_SET(create_flow_table_in, in, uid, attr->uid);\n\n\tft_mdev = MLX5_ADDR_OF(create_flow_table_in, in, flow_table_context);\n\tMLX5_SET(flow_table_context, ft_mdev, termination_table, attr->term_tbl);\n\tMLX5_SET(flow_table_context, ft_mdev, sw_owner, attr->sw_owner);\n\tMLX5_SET(flow_table_context, ft_mdev, level, attr->level);\n\n\tif (attr->sw_owner) {\n\t\t \n\t\tif (attr->table_type == MLX5_FLOW_TABLE_TYPE_NIC_RX) {\n\t\t\tMLX5_SET64(flow_table_context, ft_mdev,\n\t\t\t\t   sw_owner_icm_root_0, attr->icm_addr_rx);\n\t\t} else if (attr->table_type == MLX5_FLOW_TABLE_TYPE_NIC_TX) {\n\t\t\tMLX5_SET64(flow_table_context, ft_mdev,\n\t\t\t\t   sw_owner_icm_root_0, attr->icm_addr_tx);\n\t\t} else if (attr->table_type == MLX5_FLOW_TABLE_TYPE_FDB) {\n\t\t\tMLX5_SET64(flow_table_context, ft_mdev,\n\t\t\t\t   sw_owner_icm_root_0, attr->icm_addr_rx);\n\t\t\tMLX5_SET64(flow_table_context, ft_mdev,\n\t\t\t\t   sw_owner_icm_root_1, attr->icm_addr_tx);\n\t\t}\n\t}\n\n\tMLX5_SET(create_flow_table_in, in, flow_table_context.decap_en,\n\t\t attr->decap_en);\n\tMLX5_SET(create_flow_table_in, in, flow_table_context.reformat_en,\n\t\t attr->reformat_en);\n\n\terr = mlx5_cmd_exec_inout(mdev, create_flow_table, in, out);\n\tif (err)\n\t\treturn err;\n\n\t*table_id = MLX5_GET(create_flow_table_out, out, table_id);\n\tif (!attr->sw_owner && attr->table_type == MLX5_FLOW_TABLE_TYPE_FDB &&\n\t    fdb_rx_icm_addr)\n\t\t*fdb_rx_icm_addr =\n\t\t(u64)MLX5_GET(create_flow_table_out, out, icm_address_31_0) |\n\t\t(u64)MLX5_GET(create_flow_table_out, out, icm_address_39_32) << 32 |\n\t\t(u64)MLX5_GET(create_flow_table_out, out, icm_address_63_40) << 40;\n\n\treturn 0;\n}\n\nint mlx5dr_cmd_destroy_flow_table(struct mlx5_core_dev *mdev,\n\t\t\t\t  u32 table_id,\n\t\t\t\t  u32 table_type)\n{\n\tu32 in[MLX5_ST_SZ_DW(destroy_flow_table_in)] = {};\n\n\tMLX5_SET(destroy_flow_table_in, in, opcode,\n\t\t MLX5_CMD_OP_DESTROY_FLOW_TABLE);\n\tMLX5_SET(destroy_flow_table_in, in, table_type, table_type);\n\tMLX5_SET(destroy_flow_table_in, in, table_id, table_id);\n\n\treturn mlx5_cmd_exec_in(mdev, destroy_flow_table, in);\n}\n\nint mlx5dr_cmd_create_reformat_ctx(struct mlx5_core_dev *mdev,\n\t\t\t\t   enum mlx5_reformat_ctx_type rt,\n\t\t\t\t   u8 reformat_param_0,\n\t\t\t\t   u8 reformat_param_1,\n\t\t\t\t   size_t reformat_size,\n\t\t\t\t   void *reformat_data,\n\t\t\t\t   u32 *reformat_id)\n{\n\tu32 out[MLX5_ST_SZ_DW(alloc_packet_reformat_context_out)] = {};\n\tsize_t inlen, cmd_data_sz, cmd_total_sz;\n\tvoid *prctx;\n\tvoid *pdata;\n\tvoid *in;\n\tint err;\n\n\tcmd_total_sz = MLX5_ST_SZ_BYTES(alloc_packet_reformat_context_in);\n\tcmd_data_sz = MLX5_FLD_SZ_BYTES(alloc_packet_reformat_context_in,\n\t\t\t\t\tpacket_reformat_context.reformat_data);\n\tinlen = ALIGN(cmd_total_sz + reformat_size - cmd_data_sz, 4);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(alloc_packet_reformat_context_in, in, opcode,\n\t\t MLX5_CMD_OP_ALLOC_PACKET_REFORMAT_CONTEXT);\n\n\tprctx = MLX5_ADDR_OF(alloc_packet_reformat_context_in, in, packet_reformat_context);\n\tpdata = MLX5_ADDR_OF(packet_reformat_context_in, prctx, reformat_data);\n\n\tMLX5_SET(packet_reformat_context_in, prctx, reformat_type, rt);\n\tMLX5_SET(packet_reformat_context_in, prctx, reformat_param_0, reformat_param_0);\n\tMLX5_SET(packet_reformat_context_in, prctx, reformat_param_1, reformat_param_1);\n\tMLX5_SET(packet_reformat_context_in, prctx, reformat_data_size, reformat_size);\n\tif (reformat_data && reformat_size)\n\t\tmemcpy(pdata, reformat_data, reformat_size);\n\n\terr = mlx5_cmd_exec(mdev, in, inlen, out, sizeof(out));\n\tif (err)\n\t\tgoto err_free_in;\n\n\t*reformat_id = MLX5_GET(alloc_packet_reformat_context_out, out, packet_reformat_id);\n\nerr_free_in:\n\tkvfree(in);\n\treturn err;\n}\n\nvoid mlx5dr_cmd_destroy_reformat_ctx(struct mlx5_core_dev *mdev,\n\t\t\t\t     u32 reformat_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(dealloc_packet_reformat_context_in)] = {};\n\n\tMLX5_SET(dealloc_packet_reformat_context_in, in, opcode,\n\t\t MLX5_CMD_OP_DEALLOC_PACKET_REFORMAT_CONTEXT);\n\tMLX5_SET(dealloc_packet_reformat_context_in, in, packet_reformat_id,\n\t\t reformat_id);\n\n\tmlx5_cmd_exec_in(mdev, dealloc_packet_reformat_context, in);\n}\n\nstatic void dr_cmd_set_definer_format(void *ptr, u16 format_id,\n\t\t\t\t      u8 *dw_selectors,\n\t\t\t\t      u8 *byte_selectors)\n{\n\tif (format_id != MLX5_IFC_DEFINER_FORMAT_ID_SELECT)\n\t\treturn;\n\n\tMLX5_SET(match_definer, ptr, format_select_dw0, dw_selectors[0]);\n\tMLX5_SET(match_definer, ptr, format_select_dw1, dw_selectors[1]);\n\tMLX5_SET(match_definer, ptr, format_select_dw2, dw_selectors[2]);\n\tMLX5_SET(match_definer, ptr, format_select_dw3, dw_selectors[3]);\n\tMLX5_SET(match_definer, ptr, format_select_dw4, dw_selectors[4]);\n\tMLX5_SET(match_definer, ptr, format_select_dw5, dw_selectors[5]);\n\tMLX5_SET(match_definer, ptr, format_select_dw6, dw_selectors[6]);\n\tMLX5_SET(match_definer, ptr, format_select_dw7, dw_selectors[7]);\n\tMLX5_SET(match_definer, ptr, format_select_dw8, dw_selectors[8]);\n\n\tMLX5_SET(match_definer, ptr, format_select_byte0, byte_selectors[0]);\n\tMLX5_SET(match_definer, ptr, format_select_byte1, byte_selectors[1]);\n\tMLX5_SET(match_definer, ptr, format_select_byte2, byte_selectors[2]);\n\tMLX5_SET(match_definer, ptr, format_select_byte3, byte_selectors[3]);\n\tMLX5_SET(match_definer, ptr, format_select_byte4, byte_selectors[4]);\n\tMLX5_SET(match_definer, ptr, format_select_byte5, byte_selectors[5]);\n\tMLX5_SET(match_definer, ptr, format_select_byte6, byte_selectors[6]);\n\tMLX5_SET(match_definer, ptr, format_select_byte7, byte_selectors[7]);\n}\n\nint mlx5dr_cmd_create_definer(struct mlx5_core_dev *mdev,\n\t\t\t      u16 format_id,\n\t\t\t      u8 *dw_selectors,\n\t\t\t      u8 *byte_selectors,\n\t\t\t      u8 *match_mask,\n\t\t\t      u32 *definer_id)\n{\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)] = {};\n\tu32 in[MLX5_ST_SZ_DW(create_match_definer_in)] = {};\n\tvoid *ptr;\n\tint err;\n\n\tptr = MLX5_ADDR_OF(create_match_definer_in, in,\n\t\t\t   general_obj_in_cmd_hdr);\n\tMLX5_SET(general_obj_in_cmd_hdr, ptr, opcode,\n\t\t MLX5_CMD_OP_CREATE_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, ptr, obj_type,\n\t\t MLX5_OBJ_TYPE_MATCH_DEFINER);\n\n\tptr = MLX5_ADDR_OF(create_match_definer_in, in, obj_context);\n\tMLX5_SET(match_definer, ptr, format_id, format_id);\n\n\tdr_cmd_set_definer_format(ptr, format_id,\n\t\t\t\t  dw_selectors, byte_selectors);\n\n\tptr = MLX5_ADDR_OF(match_definer, ptr, match_mask);\n\tmemcpy(ptr, match_mask, MLX5_FLD_SZ_BYTES(match_definer, match_mask));\n\n\terr = mlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n\tif (err)\n\t\treturn err;\n\n\t*definer_id = MLX5_GET(general_obj_out_cmd_hdr, out, obj_id);\n\n\treturn 0;\n}\n\nvoid\nmlx5dr_cmd_destroy_definer(struct mlx5_core_dev *mdev, u32 definer_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(general_obj_in_cmd_hdr)] = {};\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)];\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode, MLX5_CMD_OP_DESTROY_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type, MLX5_OBJ_TYPE_MATCH_DEFINER);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_id, definer_id);\n\n\tmlx5_cmd_exec(mdev, in, sizeof(in), out, sizeof(out));\n}\n\nint mlx5dr_cmd_query_gid(struct mlx5_core_dev *mdev, u8 vhca_port_num,\n\t\t\t u16 index, struct mlx5dr_cmd_gid_attr *attr)\n{\n\tu32 out[MLX5_ST_SZ_DW(query_roce_address_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(query_roce_address_in)] = {};\n\tint err;\n\n\tMLX5_SET(query_roce_address_in, in, opcode,\n\t\t MLX5_CMD_OP_QUERY_ROCE_ADDRESS);\n\n\tMLX5_SET(query_roce_address_in, in, roce_address_index, index);\n\tMLX5_SET(query_roce_address_in, in, vhca_port_num, vhca_port_num);\n\n\terr = mlx5_cmd_exec_inout(mdev, query_roce_address, in, out);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(&attr->gid,\n\t       MLX5_ADDR_OF(query_roce_address_out,\n\t\t\t    out, roce_address.source_l3_address),\n\t       sizeof(attr->gid));\n\tmemcpy(attr->mac,\n\t       MLX5_ADDR_OF(query_roce_address_out, out,\n\t\t\t    roce_address.source_mac_47_32),\n\t       sizeof(attr->mac));\n\n\tif (MLX5_GET(query_roce_address_out, out,\n\t\t     roce_address.roce_version) == MLX5_ROCE_VERSION_2)\n\t\tattr->roce_ver = MLX5_ROCE_VERSION_2;\n\telse\n\t\tattr->roce_ver = MLX5_ROCE_VERSION_1;\n\n\treturn 0;\n}\n\nint mlx5dr_cmd_create_modify_header_arg(struct mlx5_core_dev *dev,\n\t\t\t\t\tu16 log_obj_range, u32 pd,\n\t\t\t\t\tu32 *obj_id)\n{\n\tu32 in[MLX5_ST_SZ_DW(create_modify_header_arg_in)] = {};\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)] = {};\n\tvoid *attr;\n\tint ret;\n\n\tattr = MLX5_ADDR_OF(create_modify_header_arg_in, in, hdr);\n\tMLX5_SET(general_obj_in_cmd_hdr, attr, opcode,\n\t\t MLX5_CMD_OP_CREATE_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, attr, obj_type,\n\t\t MLX5_OBJ_TYPE_HEADER_MODIFY_ARGUMENT);\n\tMLX5_SET(general_obj_in_cmd_hdr, attr,\n\t\t op_param.create.log_obj_range, log_obj_range);\n\n\tattr = MLX5_ADDR_OF(create_modify_header_arg_in, in, arg);\n\tMLX5_SET(modify_header_arg, attr, access_pd, pd);\n\n\tret = mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));\n\tif (ret)\n\t\treturn ret;\n\n\t*obj_id = MLX5_GET(general_obj_out_cmd_hdr, out, obj_id);\n\treturn 0;\n}\n\nvoid mlx5dr_cmd_destroy_modify_header_arg(struct mlx5_core_dev *dev,\n\t\t\t\t\t  u32 obj_id)\n{\n\tu32 out[MLX5_ST_SZ_DW(general_obj_out_cmd_hdr)] = {};\n\tu32 in[MLX5_ST_SZ_DW(general_obj_in_cmd_hdr)] = {};\n\n\tMLX5_SET(general_obj_in_cmd_hdr, in, opcode,\n\t\t MLX5_CMD_OP_DESTROY_GENERAL_OBJECT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_type,\n\t\t MLX5_OBJ_TYPE_HEADER_MODIFY_ARGUMENT);\n\tMLX5_SET(general_obj_in_cmd_hdr, in, obj_id, obj_id);\n\n\tmlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));\n}\n\nstatic int mlx5dr_cmd_set_extended_dest(struct mlx5_core_dev *dev,\n\t\t\t\t\tstruct mlx5dr_cmd_fte_info *fte,\n\t\t\t\t\tbool *extended_dest)\n{\n\tint fw_log_max_fdb_encap_uplink = MLX5_CAP_ESW(dev, log_max_fdb_encap_uplink);\n\tint num_fwd_destinations = 0;\n\tint num_encap = 0;\n\tint i;\n\n\t*extended_dest = false;\n\tif (!(fte->action.action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST))\n\t\treturn 0;\n\tfor (i = 0; i < fte->dests_size; i++) {\n\t\tif (fte->dest_arr[i].type == MLX5_FLOW_DESTINATION_TYPE_COUNTER ||\n\t\t    fte->dest_arr[i].type == MLX5_FLOW_DESTINATION_TYPE_NONE)\n\t\t\tcontinue;\n\t\tif ((fte->dest_arr[i].type == MLX5_FLOW_DESTINATION_TYPE_VPORT ||\n\t\t     fte->dest_arr[i].type == MLX5_FLOW_DESTINATION_TYPE_UPLINK) &&\n\t\t    fte->dest_arr[i].vport.flags & MLX5_FLOW_DEST_VPORT_REFORMAT_ID)\n\t\t\tnum_encap++;\n\t\tnum_fwd_destinations++;\n\t}\n\n\tif (num_fwd_destinations > 1 && num_encap > 0)\n\t\t*extended_dest = true;\n\n\tif (*extended_dest && !fw_log_max_fdb_encap_uplink) {\n\t\tmlx5_core_warn(dev, \"FW does not support extended destination\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (num_encap > (1 << fw_log_max_fdb_encap_uplink)) {\n\t\tmlx5_core_warn(dev, \"FW does not support more than %d encaps\",\n\t\t\t       1 << fw_log_max_fdb_encap_uplink);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint mlx5dr_cmd_set_fte(struct mlx5_core_dev *dev,\n\t\t       int opmod, int modify_mask,\n\t\t       struct mlx5dr_cmd_ft_info *ft,\n\t\t       u32 group_id,\n\t\t       struct mlx5dr_cmd_fte_info *fte)\n{\n\tu32 out[MLX5_ST_SZ_DW(set_fte_out)] = {};\n\tvoid *in_flow_context, *vlan;\n\tbool extended_dest = false;\n\tvoid *in_match_value;\n\tunsigned int inlen;\n\tint dst_cnt_size;\n\tvoid *in_dests;\n\tu32 *in;\n\tint err;\n\tint i;\n\n\tif (mlx5dr_cmd_set_extended_dest(dev, fte, &extended_dest))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!extended_dest)\n\t\tdst_cnt_size = MLX5_ST_SZ_BYTES(dest_format_struct);\n\telse\n\t\tdst_cnt_size = MLX5_ST_SZ_BYTES(extended_dest_format);\n\n\tinlen = MLX5_ST_SZ_BYTES(set_fte_in) + fte->dests_size * dst_cnt_size;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(set_fte_in, in, opcode, MLX5_CMD_OP_SET_FLOW_TABLE_ENTRY);\n\tMLX5_SET(set_fte_in, in, op_mod, opmod);\n\tMLX5_SET(set_fte_in, in, modify_enable_mask, modify_mask);\n\tMLX5_SET(set_fte_in, in, table_type, ft->type);\n\tMLX5_SET(set_fte_in, in, table_id, ft->id);\n\tMLX5_SET(set_fte_in, in, flow_index, fte->index);\n\tMLX5_SET(set_fte_in, in, ignore_flow_level, fte->ignore_flow_level);\n\tif (ft->vport) {\n\t\tMLX5_SET(set_fte_in, in, vport_number, ft->vport);\n\t\tMLX5_SET(set_fte_in, in, other_vport, 1);\n\t}\n\n\tin_flow_context = MLX5_ADDR_OF(set_fte_in, in, flow_context);\n\tMLX5_SET(flow_context, in_flow_context, group_id, group_id);\n\n\tMLX5_SET(flow_context, in_flow_context, flow_tag,\n\t\t fte->flow_context.flow_tag);\n\tMLX5_SET(flow_context, in_flow_context, flow_source,\n\t\t fte->flow_context.flow_source);\n\n\tMLX5_SET(flow_context, in_flow_context, extended_destination,\n\t\t extended_dest);\n\tif (extended_dest) {\n\t\tu32 action;\n\n\t\taction = fte->action.action &\n\t\t\t~MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;\n\t\tMLX5_SET(flow_context, in_flow_context, action, action);\n\t} else {\n\t\tMLX5_SET(flow_context, in_flow_context, action,\n\t\t\t fte->action.action);\n\t\tif (fte->action.pkt_reformat)\n\t\t\tMLX5_SET(flow_context, in_flow_context, packet_reformat_id,\n\t\t\t\t fte->action.pkt_reformat->id);\n\t}\n\tif (fte->action.modify_hdr)\n\t\tMLX5_SET(flow_context, in_flow_context, modify_header_id,\n\t\t\t fte->action.modify_hdr->id);\n\n\tvlan = MLX5_ADDR_OF(flow_context, in_flow_context, push_vlan);\n\n\tMLX5_SET(vlan, vlan, ethtype, fte->action.vlan[0].ethtype);\n\tMLX5_SET(vlan, vlan, vid, fte->action.vlan[0].vid);\n\tMLX5_SET(vlan, vlan, prio, fte->action.vlan[0].prio);\n\n\tvlan = MLX5_ADDR_OF(flow_context, in_flow_context, push_vlan_2);\n\n\tMLX5_SET(vlan, vlan, ethtype, fte->action.vlan[1].ethtype);\n\tMLX5_SET(vlan, vlan, vid, fte->action.vlan[1].vid);\n\tMLX5_SET(vlan, vlan, prio, fte->action.vlan[1].prio);\n\n\tin_match_value = MLX5_ADDR_OF(flow_context, in_flow_context,\n\t\t\t\t      match_value);\n\tmemcpy(in_match_value, fte->val, sizeof(u32) * MLX5_ST_SZ_DW_MATCH_PARAM);\n\n\tin_dests = MLX5_ADDR_OF(flow_context, in_flow_context, destination);\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) {\n\t\tint list_size = 0;\n\n\t\tfor (i = 0; i < fte->dests_size; i++) {\n\t\t\tenum mlx5_flow_destination_type type = fte->dest_arr[i].type;\n\t\t\tenum mlx5_ifc_flow_destination_type ifc_type;\n\t\t\tunsigned int id;\n\n\t\t\tif (type == MLX5_FLOW_DESTINATION_TYPE_COUNTER)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (type) {\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_NONE:\n\t\t\t\tcontinue;\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE_NUM:\n\t\t\t\tid = fte->dest_arr[i].ft_num;\n\t\t\t\tifc_type = MLX5_IFC_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\t\t\t\tbreak;\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE:\n\t\t\t\tid = fte->dest_arr[i].ft_id;\n\t\t\t\tifc_type = MLX5_IFC_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\n\t\t\t\tbreak;\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_UPLINK:\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_VPORT:\n\t\t\t\tif (type == MLX5_FLOW_DESTINATION_TYPE_VPORT) {\n\t\t\t\t\tid = fte->dest_arr[i].vport.num;\n\t\t\t\t\tMLX5_SET(dest_format_struct, in_dests,\n\t\t\t\t\t\t destination_eswitch_owner_vhca_id_valid,\n\t\t\t\t\t\t !!(fte->dest_arr[i].vport.flags &\n\t\t\t\t\t\t    MLX5_FLOW_DEST_VPORT_VHCA_ID));\n\t\t\t\t\tifc_type = MLX5_IFC_FLOW_DESTINATION_TYPE_VPORT;\n\t\t\t\t} else {\n\t\t\t\t\tid = 0;\n\t\t\t\t\tifc_type = MLX5_IFC_FLOW_DESTINATION_TYPE_UPLINK;\n\t\t\t\t\tMLX5_SET(dest_format_struct, in_dests,\n\t\t\t\t\t\t destination_eswitch_owner_vhca_id_valid, 1);\n\t\t\t\t}\n\t\t\t\tMLX5_SET(dest_format_struct, in_dests,\n\t\t\t\t\t destination_eswitch_owner_vhca_id,\n\t\t\t\t\t fte->dest_arr[i].vport.vhca_id);\n\t\t\t\tif (extended_dest && (fte->dest_arr[i].vport.flags &\n\t\t\t\t\t\t    MLX5_FLOW_DEST_VPORT_REFORMAT_ID)) {\n\t\t\t\t\tMLX5_SET(dest_format_struct, in_dests,\n\t\t\t\t\t\t packet_reformat,\n\t\t\t\t\t\t !!(fte->dest_arr[i].vport.flags &\n\t\t\t\t\t\t    MLX5_FLOW_DEST_VPORT_REFORMAT_ID));\n\t\t\t\t\tMLX5_SET(extended_dest_format, in_dests,\n\t\t\t\t\t\t packet_reformat_id,\n\t\t\t\t\t\t fte->dest_arr[i].vport.reformat_id);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MLX5_FLOW_DESTINATION_TYPE_FLOW_SAMPLER:\n\t\t\t\tid = fte->dest_arr[i].sampler_id;\n\t\t\t\tifc_type = MLX5_IFC_FLOW_DESTINATION_TYPE_FLOW_SAMPLER;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tid = fte->dest_arr[i].tir_num;\n\t\t\t\tifc_type = MLX5_IFC_FLOW_DESTINATION_TYPE_TIR;\n\t\t\t}\n\n\t\t\tMLX5_SET(dest_format_struct, in_dests, destination_type,\n\t\t\t\t ifc_type);\n\t\t\tMLX5_SET(dest_format_struct, in_dests, destination_id, id);\n\t\t\tin_dests += dst_cnt_size;\n\t\t\tlist_size++;\n\t\t}\n\n\t\tMLX5_SET(flow_context, in_flow_context, destination_list_size,\n\t\t\t list_size);\n\t}\n\n\tif (fte->action.action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {\n\t\tint max_list_size = BIT(MLX5_CAP_FLOWTABLE_TYPE(dev,\n\t\t\t\t\tlog_max_flow_counter,\n\t\t\t\t\tft->type));\n\t\tint list_size = 0;\n\n\t\tfor (i = 0; i < fte->dests_size; i++) {\n\t\t\tif (fte->dest_arr[i].type !=\n\t\t\t    MLX5_FLOW_DESTINATION_TYPE_COUNTER)\n\t\t\t\tcontinue;\n\n\t\t\tMLX5_SET(flow_counter_list, in_dests, flow_counter_id,\n\t\t\t\t fte->dest_arr[i].counter_id);\n\t\t\tin_dests += dst_cnt_size;\n\t\t\tlist_size++;\n\t\t}\n\t\tif (list_size > max_list_size) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tMLX5_SET(flow_context, in_flow_context, flow_counter_list_size,\n\t\t\t list_size);\n\t}\n\n\terr = mlx5_cmd_exec(dev, in, inlen, out, sizeof(out));\nerr_out:\n\tkvfree(in);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}