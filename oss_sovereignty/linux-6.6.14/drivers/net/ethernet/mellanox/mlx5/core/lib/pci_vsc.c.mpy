{
  "module_name": "pci_vsc.c",
  "hash_id": "9b6f8ffc3334cd3a7bf7471d0f5cd6b11fad82146938bfeabbbd0277b1b18d68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/pci_vsc.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include \"mlx5_core.h\"\n#include \"pci_vsc.h\"\n\n#define MLX5_EXTRACT_C(source, offset, size)\t\\\n\t((((u32)(source)) >> (offset)) & MLX5_ONES32(size))\n#define MLX5_EXTRACT(src, start, len)\t\t\\\n\t(((len) == 32) ? (src) : MLX5_EXTRACT_C(src, start, len))\n#define MLX5_ONES32(size)\t\t\t\\\n\t((size) ? (0xffffffff >> (32 - (size))) : 0)\n#define MLX5_MASK32(offset, size)\t\t\\\n\t(MLX5_ONES32(size) << (offset))\n#define MLX5_MERGE_C(rsrc1, rsrc2, start, len)  \\\n\t((((rsrc2) << (start)) & (MLX5_MASK32((start), (len)))) | \\\n\t((rsrc1) & (~MLX5_MASK32((start), (len)))))\n#define MLX5_MERGE(rsrc1, rsrc2, start, len)\t\\\n\t(((len) == 32) ? (rsrc2) : MLX5_MERGE_C(rsrc1, rsrc2, start, len))\n#define vsc_read(dev, offset, val) \\\n\tpci_read_config_dword((dev)->pdev, (dev)->vsc_addr + (offset), (val))\n#define vsc_write(dev, offset, val) \\\n\tpci_write_config_dword((dev)->pdev, (dev)->vsc_addr + (offset), (val))\n#define VSC_MAX_RETRIES 2048\n\nenum {\n\tVSC_CTRL_OFFSET = 0x4,\n\tVSC_COUNTER_OFFSET = 0x8,\n\tVSC_SEMAPHORE_OFFSET = 0xc,\n\tVSC_ADDR_OFFSET = 0x10,\n\tVSC_DATA_OFFSET = 0x14,\n\n\tVSC_FLAG_BIT_OFFS = 31,\n\tVSC_FLAG_BIT_LEN = 1,\n\n\tVSC_SYND_BIT_OFFS = 30,\n\tVSC_SYND_BIT_LEN = 1,\n\n\tVSC_ADDR_BIT_OFFS = 0,\n\tVSC_ADDR_BIT_LEN = 30,\n\n\tVSC_SPACE_BIT_OFFS = 0,\n\tVSC_SPACE_BIT_LEN = 16,\n\n\tVSC_SIZE_VLD_BIT_OFFS = 28,\n\tVSC_SIZE_VLD_BIT_LEN = 1,\n\n\tVSC_STATUS_BIT_OFFS = 29,\n\tVSC_STATUS_BIT_LEN = 3,\n};\n\nvoid mlx5_pci_vsc_init(struct mlx5_core_dev *dev)\n{\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn;\n\n\tdev->vsc_addr = pci_find_capability(dev->pdev,\n\t\t\t\t\t    PCI_CAP_ID_VNDR);\n\tif (!dev->vsc_addr)\n\t\tmlx5_core_warn(dev, \"Failed to get valid vendor specific ID\\n\");\n}\n\nint mlx5_vsc_gw_lock(struct mlx5_core_dev *dev)\n{\n\tu32 counter = 0;\n\tint retries = 0;\n\tu32 lock_val;\n\tint ret;\n\n\tpci_cfg_access_lock(dev->pdev);\n\tdo {\n\t\tif (retries > VSC_MAX_RETRIES) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto pci_unlock;\n\t\t}\n\n\t\t \n\t\tret = vsc_read(dev, VSC_SEMAPHORE_OFFSET, &lock_val);\n\t\tif (ret)\n\t\t\tgoto pci_unlock;\n\n\t\tif (lock_val) {\n\t\t\tretries++;\n\t\t\tusleep_range(1000, 2000);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = vsc_read(dev, VSC_COUNTER_OFFSET, &counter);\n\t\tif (ret)\n\t\t\tgoto pci_unlock;\n\n\t\tret = vsc_write(dev, VSC_SEMAPHORE_OFFSET, counter);\n\t\tif (ret)\n\t\t\tgoto pci_unlock;\n\n\t\tret = vsc_read(dev, VSC_SEMAPHORE_OFFSET, &lock_val);\n\t\tif (ret)\n\t\t\tgoto pci_unlock;\n\n\t\tretries++;\n\t} while (counter != lock_val);\n\n\treturn 0;\n\npci_unlock:\n\tpci_cfg_access_unlock(dev->pdev);\n\treturn ret;\n}\n\nint mlx5_vsc_gw_unlock(struct mlx5_core_dev *dev)\n{\n\tint ret;\n\n\tret = vsc_write(dev, VSC_SEMAPHORE_OFFSET, MLX5_VSC_UNLOCK);\n\tpci_cfg_access_unlock(dev->pdev);\n\treturn ret;\n}\n\nint mlx5_vsc_gw_set_space(struct mlx5_core_dev *dev, u16 space,\n\t\t\t  u32 *ret_space_size)\n{\n\tint ret;\n\tu32 val = 0;\n\n\tif (!mlx5_vsc_accessible(dev))\n\t\treturn -EINVAL;\n\n\tif (ret_space_size)\n\t\t*ret_space_size = 0;\n\n\t \n\tret = vsc_read(dev, VSC_CTRL_OFFSET, &val);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tval = MLX5_MERGE(val, space, VSC_SPACE_BIT_OFFS, VSC_SPACE_BIT_LEN);\n\tret = vsc_write(dev, VSC_CTRL_OFFSET, val);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = vsc_read(dev, VSC_CTRL_OFFSET, &val);\n\tif (ret)\n\t\tgoto out;\n\n\tif (MLX5_EXTRACT(val, VSC_STATUS_BIT_OFFS, VSC_STATUS_BIT_LEN) == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (ret_space_size &&\n\t    MLX5_EXTRACT(val, VSC_SIZE_VLD_BIT_OFFS, VSC_SIZE_VLD_BIT_LEN)) {\n\t\tret = vsc_read(dev, VSC_ADDR_OFFSET, &val);\n\t\tif (ret) {\n\t\t\tmlx5_core_warn(dev, \"Failed to get max space size\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\t*ret_space_size = MLX5_EXTRACT(val, VSC_ADDR_BIT_OFFS,\n\t\t\t\t\t       VSC_ADDR_BIT_LEN);\n\t}\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nstatic int mlx5_vsc_wait_on_flag(struct mlx5_core_dev *dev, u8 expected_val)\n{\n\tint retries = 0;\n\tu32 flag;\n\tint ret;\n\n\tdo {\n\t\tif (retries > VSC_MAX_RETRIES)\n\t\t\treturn -EBUSY;\n\n\t\tret = vsc_read(dev, VSC_ADDR_OFFSET, &flag);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tflag = MLX5_EXTRACT(flag, VSC_FLAG_BIT_OFFS, VSC_FLAG_BIT_LEN);\n\t\tretries++;\n\n\t\tif ((retries & 0xf) == 0)\n\t\t\tusleep_range(1000, 2000);\n\n\t} while (flag != expected_val);\n\n\treturn 0;\n}\n\nstatic int mlx5_vsc_gw_write(struct mlx5_core_dev *dev, unsigned int address,\n\t\t\t     u32 data)\n{\n\tint ret;\n\n\tif (MLX5_EXTRACT(address, VSC_SYND_BIT_OFFS,\n\t\t\t VSC_FLAG_BIT_LEN + VSC_SYND_BIT_LEN))\n\t\treturn -EINVAL;\n\n\t \n\taddress = MLX5_MERGE(address, 1, VSC_FLAG_BIT_OFFS, 1);\n\tret = vsc_write(dev, VSC_DATA_OFFSET, data);\n\tif (ret)\n\t\tgoto out;\n\n\tret = vsc_write(dev, VSC_ADDR_OFFSET, address);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = mlx5_vsc_wait_on_flag(dev, 0);\n\nout:\n\treturn ret;\n}\n\nstatic int mlx5_vsc_gw_read(struct mlx5_core_dev *dev, unsigned int address,\n\t\t\t    u32 *data)\n{\n\tint ret;\n\n\tif (MLX5_EXTRACT(address, VSC_SYND_BIT_OFFS,\n\t\t\t VSC_FLAG_BIT_LEN + VSC_SYND_BIT_LEN))\n\t\treturn -EINVAL;\n\n\tret = vsc_write(dev, VSC_ADDR_OFFSET, address);\n\tif (ret)\n\t\tgoto out;\n\n\tret = mlx5_vsc_wait_on_flag(dev, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tret = vsc_read(dev, VSC_DATA_OFFSET, data);\nout:\n\treturn ret;\n}\n\nstatic int mlx5_vsc_gw_read_fast(struct mlx5_core_dev *dev,\n\t\t\t\t unsigned int read_addr,\n\t\t\t\t unsigned int *next_read_addr,\n\t\t\t\t u32 *data)\n{\n\tint ret;\n\n\tret = mlx5_vsc_gw_read(dev, read_addr, data);\n\tif (ret)\n\t\tgoto out;\n\n\tret = vsc_read(dev, VSC_ADDR_OFFSET, next_read_addr);\n\tif (ret)\n\t\tgoto out;\n\n\t*next_read_addr = MLX5_EXTRACT(*next_read_addr, VSC_ADDR_BIT_OFFS,\n\t\t\t\t       VSC_ADDR_BIT_LEN);\n\n\tif (*next_read_addr <= read_addr)\n\t\tret = -EINVAL;\nout:\n\treturn ret;\n}\n\nint mlx5_vsc_gw_read_block_fast(struct mlx5_core_dev *dev, u32 *data,\n\t\t\t\tint length)\n{\n\tunsigned int next_read_addr = 0;\n\tunsigned int read_addr = 0;\n\n\twhile (read_addr < length) {\n\t\tif (mlx5_vsc_gw_read_fast(dev, read_addr, &next_read_addr,\n\t\t\t\t\t  &data[(read_addr >> 2)]))\n\t\t\treturn read_addr;\n\n\t\tread_addr = next_read_addr;\n\t}\n\treturn length;\n}\n\nint mlx5_vsc_sem_set_space(struct mlx5_core_dev *dev, u16 space,\n\t\t\t   enum mlx5_vsc_state state)\n{\n\tu32 data, id = 0;\n\tint ret;\n\n\tret = mlx5_vsc_gw_set_space(dev, MLX5_SEMAPHORE_SPACE_DOMAIN, NULL);\n\tif (ret) {\n\t\tmlx5_core_warn(dev, \"Failed to set gw space %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (state == MLX5_VSC_LOCK) {\n\t\t \n\t\tret = vsc_read(dev, VSC_COUNTER_OFFSET, &id);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = mlx5_vsc_gw_write(dev, space, id);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = mlx5_vsc_gw_read(dev, space, &data);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (data != id)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}