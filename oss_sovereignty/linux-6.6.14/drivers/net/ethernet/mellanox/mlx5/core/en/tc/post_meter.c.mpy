{
  "module_name": "post_meter.c",
  "hash_id": "924e540a337ee70525486b398ea5d63e29e2dce831de13bd3a48323fd29baddc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc/post_meter.c",
  "human_readable_source": "\n\n\n#include \"en/tc_priv.h\"\n#include \"post_meter.h\"\n#include \"en/tc/post_act.h\"\n\n#define MLX5_PACKET_COLOR_BITS MLX5_REG_MAPPING_MBITS(PACKET_COLOR_TO_REG)\n#define MLX5_PACKET_COLOR_MASK MLX5_REG_MAPPING_MASK(PACKET_COLOR_TO_REG)\n\nstruct mlx5e_post_meter_rate_table {\n\tstruct mlx5_flow_table *ft;\n\tstruct mlx5_flow_group *fg;\n\tstruct mlx5_flow_handle *green_rule;\n\tstruct mlx5_flow_attr *green_attr;\n\tstruct mlx5_flow_handle *red_rule;\n\tstruct mlx5_flow_attr *red_attr;\n};\n\nstruct mlx5e_post_meter_mtu_table {\n\tstruct mlx5_flow_table *ft;\n\tstruct mlx5_flow_group *fg;\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_attr *attr;\n};\n\nstruct mlx5e_post_meter_mtu_tables {\n\tstruct mlx5e_post_meter_mtu_table green_table;\n\tstruct mlx5e_post_meter_mtu_table red_table;\n};\n\nstruct mlx5e_post_meter_priv {\n\tenum mlx5e_post_meter_type type;\n\tunion {\n\t\tstruct mlx5e_post_meter_rate_table rate_steering_table;\n\t\tstruct mlx5e_post_meter_mtu_tables  mtu_tables;\n\t};\n};\n\nstruct mlx5_flow_table *\nmlx5e_post_meter_get_ft(struct mlx5e_post_meter_priv *post_meter)\n{\n\treturn post_meter->rate_steering_table.ft;\n}\n\nstruct mlx5_flow_table *\nmlx5e_post_meter_get_mtu_true_ft(struct mlx5e_post_meter_priv *post_meter)\n{\n\treturn post_meter->mtu_tables.green_table.ft;\n}\n\nstruct mlx5_flow_table *\nmlx5e_post_meter_get_mtu_false_ft(struct mlx5e_post_meter_priv *post_meter)\n{\n\treturn post_meter->mtu_tables.red_table.ft;\n}\n\nstatic struct mlx5_flow_table *\nmlx5e_post_meter_table_create(struct mlx5e_priv *priv,\n\t\t\t      enum mlx5_flow_namespace_type ns_type)\n{\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_flow_namespace *root_ns;\n\n\troot_ns = mlx5_get_flow_namespace(priv->mdev, ns_type);\n\tif (!root_ns) {\n\t\tmlx5_core_warn(priv->mdev, \"Failed to get namespace for flow meter\\n\");\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tft_attr.flags = MLX5_FLOW_TABLE_UNMANAGED;\n\tft_attr.prio = FDB_SLOW_PATH;\n\tft_attr.max_fte = 2;\n\tft_attr.level = 1;\n\n\treturn mlx5_create_flow_table(root_ns, &ft_attr);\n}\n\nstatic int\nmlx5e_post_meter_rate_fg_create(struct mlx5e_priv *priv,\n\t\t\t\tstruct mlx5e_post_meter_priv *post_meter)\n{\n\tstruct mlx5e_post_meter_rate_table *table = &post_meter->rate_steering_table;\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tvoid *misc2, *match_criteria;\n\tu32 *flow_group_in;\n\tint err = 0;\n\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tif (!flow_group_in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(create_flow_group_in, flow_group_in, match_criteria_enable,\n\t\t MLX5_MATCH_MISC_PARAMETERS_2);\n\tmatch_criteria = MLX5_ADDR_OF(create_flow_group_in, flow_group_in,\n\t\t\t\t      match_criteria);\n\tmisc2 = MLX5_ADDR_OF(fte_match_param, match_criteria, misc_parameters_2);\n\tMLX5_SET(fte_match_set_misc2, misc2, metadata_reg_c_5, MLX5_PACKET_COLOR_MASK);\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, 0);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, 1);\n\n\ttable->fg = mlx5_create_flow_group(table->ft, flow_group_in);\n\tif (IS_ERR(table->fg)) {\n\t\tmlx5_core_warn(priv->mdev, \"Failed to create post_meter flow group\\n\");\n\t\terr = PTR_ERR(table->fg);\n\t}\n\n\tkvfree(flow_group_in);\n\treturn err;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5e_post_meter_add_rule(struct mlx5e_priv *priv,\n\t\t\t  struct mlx5e_post_meter_priv *post_meter,\n\t\t\t  struct mlx5_flow_spec *spec,\n\t\t\t  struct mlx5_flow_attr *attr,\n\t\t\t  struct mlx5_fc *act_counter,\n\t\t\t  struct mlx5_fc *drop_counter)\n{\n\tstruct mlx5_eswitch *esw = priv->mdev->priv.eswitch;\n\tstruct mlx5_flow_handle *ret;\n\n\tattr->action |= MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\tif (attr->action & MLX5_FLOW_CONTEXT_ACTION_DROP)\n\t\tattr->counter = drop_counter;\n\telse\n\t\tattr->counter = act_counter;\n\n\tattr->flags |= MLX5_ATTR_FLAG_NO_IN_PORT;\n\tattr->inner_match_level = MLX5_MATCH_NONE;\n\tattr->outer_match_level = MLX5_MATCH_NONE;\n\tattr->chain = 0;\n\tattr->prio = 0;\n\n\tret = mlx5_eswitch_add_offloaded_rule(esw, spec, attr);\n\n\t \n\tattr->action &= ~MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\n\treturn ret;\n}\n\nstatic int\nmlx5e_post_meter_rate_rules_create(struct mlx5e_priv *priv,\n\t\t\t\t   struct mlx5e_post_meter_priv *post_meter,\n\t\t\t\t   struct mlx5e_post_act *post_act,\n\t\t\t\t   struct mlx5_fc *act_counter,\n\t\t\t\t   struct mlx5_fc *drop_counter,\n\t\t\t\t   struct mlx5_flow_attr *green_attr,\n\t\t\t\t   struct mlx5_flow_attr *red_attr)\n{\n\tstruct mlx5e_post_meter_rate_table *table = &post_meter->rate_steering_table;\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tint err;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\tmlx5e_tc_match_to_reg_match(spec, PACKET_COLOR_TO_REG,\n\t\t\t\t    MLX5_FLOW_METER_COLOR_RED, MLX5_PACKET_COLOR_MASK);\n\tred_attr->ft = post_meter->rate_steering_table.ft;\n\trule = mlx5e_post_meter_add_rule(priv, post_meter, spec, red_attr,\n\t\t\t\t\t act_counter, drop_counter);\n\tif (IS_ERR(rule)) {\n\t\tmlx5_core_warn(priv->mdev, \"Failed to create post_meter exceed rule\\n\");\n\t\terr = PTR_ERR(rule);\n\t\tgoto err_red;\n\t}\n\ttable->red_rule = rule;\n\ttable->red_attr = red_attr;\n\n\tmlx5e_tc_match_to_reg_match(spec, PACKET_COLOR_TO_REG,\n\t\t\t\t    MLX5_FLOW_METER_COLOR_GREEN, MLX5_PACKET_COLOR_MASK);\n\tgreen_attr->ft = post_meter->rate_steering_table.ft;\n\trule = mlx5e_post_meter_add_rule(priv, post_meter, spec, green_attr,\n\t\t\t\t\t act_counter, drop_counter);\n\tif (IS_ERR(rule)) {\n\t\tmlx5_core_warn(priv->mdev, \"Failed to create post_meter notexceed rule\\n\");\n\t\terr = PTR_ERR(rule);\n\t\tgoto err_green;\n\t}\n\ttable->green_rule = rule;\n\ttable->green_attr = green_attr;\n\n\tkvfree(spec);\n\treturn 0;\n\nerr_green:\n\tmlx5_del_flow_rules(table->red_rule);\nerr_red:\n\tkvfree(spec);\n\treturn err;\n}\n\nstatic void\nmlx5e_post_meter_rate_rules_destroy(struct mlx5_eswitch *esw,\n\t\t\t\t    struct mlx5e_post_meter_priv *post_meter)\n{\n\tstruct mlx5e_post_meter_rate_table *rate_table = &post_meter->rate_steering_table;\n\n\tmlx5_eswitch_del_offloaded_rule(esw, rate_table->red_rule, rate_table->red_attr);\n\tmlx5_eswitch_del_offloaded_rule(esw, rate_table->green_rule, rate_table->green_attr);\n}\n\nstatic void\nmlx5e_post_meter_rate_fg_destroy(struct mlx5e_post_meter_priv *post_meter)\n{\n\tmlx5_destroy_flow_group(post_meter->rate_steering_table.fg);\n}\n\nstatic void\nmlx5e_post_meter_rate_table_destroy(struct mlx5e_post_meter_priv *post_meter)\n{\n\tmlx5_destroy_flow_table(post_meter->rate_steering_table.ft);\n}\n\nstatic void\nmlx5e_post_meter_mtu_rules_destroy(struct mlx5e_post_meter_priv *post_meter)\n{\n\tstruct mlx5e_post_meter_mtu_tables *mtu_tables = &post_meter->mtu_tables;\n\n\tmlx5_del_flow_rules(mtu_tables->green_table.rule);\n\tmlx5_del_flow_rules(mtu_tables->red_table.rule);\n}\n\nstatic void\nmlx5e_post_meter_mtu_fg_destroy(struct mlx5e_post_meter_priv *post_meter)\n{\n\tstruct mlx5e_post_meter_mtu_tables *mtu_tables = &post_meter->mtu_tables;\n\n\tmlx5_destroy_flow_group(mtu_tables->green_table.fg);\n\tmlx5_destroy_flow_group(mtu_tables->red_table.fg);\n}\n\nstatic void\nmlx5e_post_meter_mtu_table_destroy(struct mlx5e_post_meter_priv *post_meter)\n{\n\tstruct mlx5e_post_meter_mtu_tables *mtu_tables = &post_meter->mtu_tables;\n\n\tmlx5_destroy_flow_table(mtu_tables->green_table.ft);\n\tmlx5_destroy_flow_table(mtu_tables->red_table.ft);\n}\n\nstatic int\nmlx5e_post_meter_rate_create(struct mlx5e_priv *priv,\n\t\t\t     enum mlx5_flow_namespace_type ns_type,\n\t\t\t     struct mlx5e_post_act *post_act,\n\t\t\t     struct mlx5_fc *act_counter,\n\t\t\t     struct mlx5_fc *drop_counter,\n\t\t\t     struct mlx5e_post_meter_priv *post_meter,\n\t\t\t     struct mlx5_flow_attr *green_attr,\n\t\t\t     struct mlx5_flow_attr *red_attr)\n{\n\tstruct mlx5_flow_table *ft;\n\tint err;\n\n\tpost_meter->type = MLX5E_POST_METER_RATE;\n\n\tft = mlx5e_post_meter_table_create(priv, ns_type);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tmlx5_core_warn(priv->mdev, \"Failed to create post_meter table\\n\");\n\t\tgoto err_ft;\n\t}\n\n\tpost_meter->rate_steering_table.ft = ft;\n\n\terr = mlx5e_post_meter_rate_fg_create(priv, post_meter);\n\tif (err)\n\t\tgoto err_fg;\n\n\terr = mlx5e_post_meter_rate_rules_create(priv, post_meter, post_act,\n\t\t\t\t\t\t act_counter, drop_counter,\n\t\t\t\t\t\t green_attr, red_attr);\n\tif (err)\n\t\tgoto err_rules;\n\n\treturn 0;\n\nerr_rules:\n\tmlx5e_post_meter_rate_fg_destroy(post_meter);\nerr_fg:\n\tmlx5e_post_meter_rate_table_destroy(post_meter);\nerr_ft:\n\treturn err;\n}\n\nstatic int\nmlx5e_post_meter_create_mtu_table(struct mlx5e_priv *priv,\n\t\t\t\t  enum mlx5_flow_namespace_type ns_type,\n\t\t\t\t  struct mlx5e_post_meter_mtu_table *table)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fg;\n\tu32 *flow_group_in;\n\tint err;\n\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tif (!flow_group_in)\n\t\treturn -ENOMEM;\n\n\ttable->ft = mlx5e_post_meter_table_create(priv, ns_type);\n\tif (IS_ERR(table->ft)) {\n\t\terr = PTR_ERR(table->ft);\n\t\tgoto err_ft;\n\t}\n\n\t \n\tmemset(flow_group_in, 0, inlen);\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, 1);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, 1);\n\tfg = mlx5_create_flow_group(table->ft, flow_group_in);\n\tif (IS_ERR(fg)) {\n\t\terr = PTR_ERR(fg);\n\t\tgoto err_miss_grp;\n\t}\n\ttable->fg = fg;\n\n\tkvfree(flow_group_in);\n\treturn 0;\n\nerr_miss_grp:\n\tmlx5_destroy_flow_table(table->ft);\nerr_ft:\n\tkvfree(flow_group_in);\n\treturn err;\n}\n\nstatic int\nmlx5e_post_meter_mtu_create(struct mlx5e_priv *priv,\n\t\t\t    enum mlx5_flow_namespace_type ns_type,\n\t\t\t    struct mlx5e_post_act *post_act,\n\t\t\t    struct mlx5_fc *act_counter,\n\t\t\t    struct mlx5_fc *drop_counter,\n\t\t\t    struct mlx5e_post_meter_priv *post_meter,\n\t\t\t    struct mlx5_flow_attr *green_attr,\n\t\t\t    struct mlx5_flow_attr *red_attr)\n{\n\tstruct mlx5e_post_meter_mtu_tables *mtu_tables = &post_meter->mtu_tables;\n\tstatic struct mlx5_flow_spec zero_spec = {};\n\tstruct mlx5_flow_handle *rule;\n\tint err;\n\n\tpost_meter->type = MLX5E_POST_METER_MTU;\n\n\terr = mlx5e_post_meter_create_mtu_table(priv, ns_type, &mtu_tables->green_table);\n\tif (err)\n\t\tgoto err_green_ft;\n\n\tgreen_attr->ft = mtu_tables->green_table.ft;\n\trule = mlx5e_post_meter_add_rule(priv, post_meter, &zero_spec, green_attr,\n\t\t\t\t\t act_counter, drop_counter);\n\tif (IS_ERR(rule)) {\n\t\tmlx5_core_warn(priv->mdev, \"Failed to create post_meter conform rule\\n\");\n\t\terr = PTR_ERR(rule);\n\t\tgoto err_green_rule;\n\t}\n\tmtu_tables->green_table.rule = rule;\n\tmtu_tables->green_table.attr = green_attr;\n\n\terr = mlx5e_post_meter_create_mtu_table(priv, ns_type, &mtu_tables->red_table);\n\tif (err)\n\t\tgoto err_red_ft;\n\n\tred_attr->ft = mtu_tables->red_table.ft;\n\trule = mlx5e_post_meter_add_rule(priv, post_meter, &zero_spec, red_attr,\n\t\t\t\t\t act_counter, drop_counter);\n\tif (IS_ERR(rule)) {\n\t\tmlx5_core_warn(priv->mdev, \"Failed to create post_meter exceed rule\\n\");\n\t\terr = PTR_ERR(rule);\n\t\tgoto err_red_rule;\n\t}\n\tmtu_tables->red_table.rule = rule;\n\tmtu_tables->red_table.attr = red_attr;\n\n\treturn 0;\n\nerr_red_rule:\n\tmlx5_destroy_flow_table(mtu_tables->red_table.ft);\nerr_red_ft:\n\tmlx5_del_flow_rules(mtu_tables->green_table.rule);\nerr_green_rule:\n\tmlx5_destroy_flow_table(mtu_tables->green_table.ft);\nerr_green_ft:\n\treturn err;\n}\n\nstruct mlx5e_post_meter_priv *\nmlx5e_post_meter_init(struct mlx5e_priv *priv,\n\t\t      enum mlx5_flow_namespace_type ns_type,\n\t\t      struct mlx5e_post_act *post_act,\n\t\t      enum mlx5e_post_meter_type type,\n\t\t      struct mlx5_fc *act_counter,\n\t\t      struct mlx5_fc *drop_counter,\n\t\t      struct mlx5_flow_attr *branch_true,\n\t\t      struct mlx5_flow_attr *branch_false)\n{\n\tstruct mlx5e_post_meter_priv *post_meter;\n\tint err;\n\n\tpost_meter = kzalloc(sizeof(*post_meter), GFP_KERNEL);\n\tif (!post_meter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tswitch (type) {\n\tcase MLX5E_POST_METER_MTU:\n\t\terr = mlx5e_post_meter_mtu_create(priv, ns_type, post_act,\n\t\t\t\t\t\t  act_counter, drop_counter, post_meter,\n\t\t\t\t\t\t  branch_true, branch_false);\n\t\tbreak;\n\tcase MLX5E_POST_METER_RATE:\n\t\terr = mlx5e_post_meter_rate_create(priv, ns_type, post_act,\n\t\t\t\t\t\t   act_counter, drop_counter, post_meter,\n\t\t\t\t\t\t   branch_true, branch_false);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\tif (err)\n\t\tgoto err;\n\n\treturn post_meter;\n\nerr:\n\tkfree(post_meter);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlx5e_post_meter_rate_destroy(struct mlx5_eswitch *esw, struct mlx5e_post_meter_priv *post_meter)\n{\n\tmlx5e_post_meter_rate_rules_destroy(esw, post_meter);\n\tmlx5e_post_meter_rate_fg_destroy(post_meter);\n\tmlx5e_post_meter_rate_table_destroy(post_meter);\n}\n\nstatic void\nmlx5e_post_meter_mtu_destroy(struct mlx5e_post_meter_priv *post_meter)\n{\n\tmlx5e_post_meter_mtu_rules_destroy(post_meter);\n\tmlx5e_post_meter_mtu_fg_destroy(post_meter);\n\tmlx5e_post_meter_mtu_table_destroy(post_meter);\n}\n\nvoid\nmlx5e_post_meter_cleanup(struct mlx5_eswitch *esw, struct mlx5e_post_meter_priv *post_meter)\n{\n\tif (post_meter->type == MLX5E_POST_METER_RATE)\n\t\tmlx5e_post_meter_rate_destroy(esw, post_meter);\n\telse\n\t\tmlx5e_post_meter_mtu_destroy(post_meter);\n\n\tkfree(post_meter);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}