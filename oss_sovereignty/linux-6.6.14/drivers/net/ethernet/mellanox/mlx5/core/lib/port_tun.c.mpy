{
  "module_name": "port_tun.c",
  "hash_id": "975bfc75667894cbd2db42c53cc3d5c32d3786848ef0b4d24e3995e81d691801",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/port_tun.c",
  "human_readable_source": " \n \n\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/port.h>\n#include \"mlx5_core.h\"\n#include \"lib/port_tun.h\"\n\nstruct mlx5_port_tun_entropy_flags {\n\tbool force_supported, force_enabled;\n\tbool calc_supported, calc_enabled;\n\tbool gre_calc_supported, gre_calc_enabled;\n};\n\nstatic void mlx5_query_port_tun_entropy(struct mlx5_core_dev *mdev,\n\t\t\t\t\tstruct mlx5_port_tun_entropy_flags *entropy_flags)\n{\n\tu32 out[MLX5_ST_SZ_DW(pcmr_reg)];\n\t \n\tentropy_flags->force_supported = false;\n\tentropy_flags->calc_supported = false;\n\tentropy_flags->gre_calc_supported = false;\n\tentropy_flags->force_enabled = false;\n\tentropy_flags->calc_enabled = true;\n\tentropy_flags->gre_calc_enabled = true;\n\n\tif (!MLX5_CAP_GEN(mdev, ports_check))\n\t\treturn;\n\n\tif (mlx5_query_ports_check(mdev, out, sizeof(out)))\n\t\treturn;\n\n\tentropy_flags->force_supported = !!(MLX5_GET(pcmr_reg, out, entropy_force_cap));\n\tentropy_flags->calc_supported = !!(MLX5_GET(pcmr_reg, out, entropy_calc_cap));\n\tentropy_flags->gre_calc_supported = !!(MLX5_GET(pcmr_reg, out, entropy_gre_calc_cap));\n\tentropy_flags->force_enabled = !!(MLX5_GET(pcmr_reg, out, entropy_force));\n\tentropy_flags->calc_enabled = !!(MLX5_GET(pcmr_reg, out, entropy_calc));\n\tentropy_flags->gre_calc_enabled = !!(MLX5_GET(pcmr_reg, out, entropy_gre_calc));\n}\n\nstatic int mlx5_set_port_tun_entropy_calc(struct mlx5_core_dev *mdev, u8 enable,\n\t\t\t\t\t  u8 force)\n{\n\tu32 in[MLX5_ST_SZ_DW(pcmr_reg)] = {0};\n\tint err;\n\n\terr = mlx5_query_ports_check(mdev, in, sizeof(in));\n\tif (err)\n\t\treturn err;\n\tMLX5_SET(pcmr_reg, in, local_port, 1);\n\tMLX5_SET(pcmr_reg, in, entropy_force, force);\n\tMLX5_SET(pcmr_reg, in, entropy_calc, enable);\n\treturn mlx5_set_ports_check(mdev, in, sizeof(in));\n}\n\nstatic int mlx5_set_port_gre_tun_entropy_calc(struct mlx5_core_dev *mdev,\n\t\t\t\t\t      u8 enable, u8 force)\n{\n\tu32 in[MLX5_ST_SZ_DW(pcmr_reg)] = {0};\n\tint err;\n\n\terr = mlx5_query_ports_check(mdev, in, sizeof(in));\n\tif (err)\n\t\treturn err;\n\tMLX5_SET(pcmr_reg, in, local_port, 1);\n\tMLX5_SET(pcmr_reg, in, entropy_force, force);\n\tMLX5_SET(pcmr_reg, in, entropy_gre_calc, enable);\n\treturn mlx5_set_ports_check(mdev, in, sizeof(in));\n}\n\nvoid mlx5_init_port_tun_entropy(struct mlx5_tun_entropy *tun_entropy,\n\t\t\t\tstruct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_port_tun_entropy_flags entropy_flags;\n\n\ttun_entropy->mdev = mdev;\n\tmutex_init(&tun_entropy->lock);\n\tmlx5_query_port_tun_entropy(mdev, &entropy_flags);\n\ttun_entropy->num_enabling_entries = 0;\n\ttun_entropy->num_disabling_entries = 0;\n\ttun_entropy->enabled = entropy_flags.calc_supported ?\n\t\t\t       entropy_flags.calc_enabled : true;\n}\n\nstatic int mlx5_set_entropy(struct mlx5_tun_entropy *tun_entropy,\n\t\t\t    int reformat_type, bool enable)\n{\n\tstruct mlx5_port_tun_entropy_flags entropy_flags;\n\tint err;\n\n\tmlx5_query_port_tun_entropy(tun_entropy->mdev, &entropy_flags);\n\t \n\tif (entropy_flags.gre_calc_supported &&\n\t    reformat_type == MLX5_REFORMAT_TYPE_L2_TO_NVGRE) {\n\t\tif (!entropy_flags.force_supported)\n\t\t\treturn 0;\n\t\terr = mlx5_set_port_gre_tun_entropy_calc(tun_entropy->mdev,\n\t\t\t\t\t\t\t enable, !enable);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (entropy_flags.calc_supported) {\n\t\t \n\t\tif (entropy_flags.force_enabled &&\n\t\t    enable == entropy_flags.calc_enabled) {\n\t\t\tmlx5_core_warn(tun_entropy->mdev,\n\t\t\t\t       \"Unexpected entropy calc setting - expected %d\",\n\t\t\t\t       !entropy_flags.calc_enabled);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t \n\t\tif (tun_entropy->num_enabling_entries)\n\t\t\treturn -EOPNOTSUPP;\n\t\terr = mlx5_set_port_tun_entropy_calc(tun_entropy->mdev, enable,\n\t\t\t\t\t\t     entropy_flags.force_supported);\n\t\tif (err)\n\t\t\treturn err;\n\t\ttun_entropy->enabled = enable;\n\t\t \n\t\tif (entropy_flags.force_supported && enable) {\n\t\t\terr = mlx5_set_port_tun_entropy_calc(tun_entropy->mdev, 1, 0);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint mlx5_tun_entropy_refcount_inc(struct mlx5_tun_entropy *tun_entropy,\n\t\t\t\t  int reformat_type)\n{\n\tint err = -EOPNOTSUPP;\n\n\tmutex_lock(&tun_entropy->lock);\n\tif ((reformat_type == MLX5_REFORMAT_TYPE_L2_TO_VXLAN ||\n\t     reformat_type == MLX5_REFORMAT_TYPE_L2_TO_L3_TUNNEL) &&\n\t    tun_entropy->enabled) {\n\t\t \n\t\ttun_entropy->num_enabling_entries++;\n\t\terr = 0;\n\t} else if (reformat_type == MLX5_REFORMAT_TYPE_L2_TO_NVGRE) {\n\t\t \n\t\tif (tun_entropy->num_disabling_entries == 0)\n\t\t\terr = mlx5_set_entropy(tun_entropy, reformat_type, 0);\n\t\telse\n\t\t\terr = 0;\n\t\tif (!err)\n\t\t\ttun_entropy->num_disabling_entries++;\n\t}\n\tmutex_unlock(&tun_entropy->lock);\n\n\treturn err;\n}\n\nvoid mlx5_tun_entropy_refcount_dec(struct mlx5_tun_entropy *tun_entropy,\n\t\t\t\t   int reformat_type)\n{\n\tmutex_lock(&tun_entropy->lock);\n\tif (reformat_type == MLX5_REFORMAT_TYPE_L2_TO_VXLAN)\n\t\ttun_entropy->num_enabling_entries--;\n\telse if (reformat_type == MLX5_REFORMAT_TYPE_L2_TO_NVGRE &&\n\t\t --tun_entropy->num_disabling_entries == 0)\n\t\tmlx5_set_entropy(tun_entropy, reformat_type, 1);\n\tmutex_unlock(&tun_entropy->lock);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}