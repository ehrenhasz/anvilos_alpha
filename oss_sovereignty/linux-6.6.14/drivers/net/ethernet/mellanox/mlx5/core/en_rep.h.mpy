{
  "module_name": "en_rep.h",
  "hash_id": "72bf92e62ec4612391d888e37bea79bb5f1be294d8c950220ca3c4a0ecb56c98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h",
  "human_readable_source": " \n\n#ifndef __MLX5E_REP_H__\n#define __MLX5E_REP_H__\n\n#include <net/ip_tunnels.h>\n#include <linux/rhashtable.h>\n#include <linux/mutex.h>\n#include \"eswitch.h\"\n#include \"en.h\"\n#include \"lib/port_tun.h\"\n\n#ifdef CONFIG_MLX5_ESWITCH\nextern const struct mlx5e_rx_handlers mlx5e_rx_handlers_rep;\n\nstruct mlx5e_neigh_update_table {\n\tstruct rhashtable       neigh_ht;\n\t \n\tstruct list_head\tneigh_list;\n\t \n\tstruct mutex\t\tencap_lock;\n\tstruct notifier_block   netevent_nb;\n\tstruct delayed_work     neigh_stats_work;\n\tunsigned long           min_interval;  \n};\n\nstruct mlx5_tc_ct_priv;\nstruct mlx5_tc_int_port_priv;\nstruct mlx5e_rep_bond;\nstruct mlx5e_tc_tun_encap;\nstruct mlx5e_post_act;\nstruct mlx5e_flow_meters;\n\nstruct mlx5_rep_uplink_priv {\n\t \n\tstruct list_head\t    tc_indr_block_priv_list;\n\n\tstruct mlx5_tun_entropy tun_entropy;\n\n\t \n\tstruct mutex                unready_flows_lock;\n\tstruct list_head            unready_flows;\n\tstruct work_struct          reoffload_flows_work;\n\n\t \n\tstruct mapping_ctx *tunnel_mapping;\n\t \n\tstruct mapping_ctx *tunnel_enc_opts_mapping;\n\n\tstruct mlx5e_post_act *post_act;\n\tstruct mlx5_tc_ct_priv *ct_priv;\n\tstruct mlx5e_tc_psample *tc_psample;\n\n\t \n\tstruct mlx5e_rep_bond *bond;\n\n\t \n\tstruct mlx5e_tc_tun_encap *encap;\n\n\t \n\tstruct mlx5e_tc_int_port_priv *int_port_priv;\n\n\tstruct mlx5e_flow_meters *flow_meters;\n\n\t \n\tstruct mlx5e_tc_act_stats_handle *action_stats_handle;\n\n\tstruct work_struct mpesw_work;\n};\n\nstruct mlx5e_rep_priv {\n\tstruct mlx5_eswitch_rep *rep;\n\tstruct mlx5e_neigh_update_table neigh_update;\n\tstruct net_device      *netdev;\n\tstruct mlx5_flow_table *root_ft;\n\tstruct mlx5_flow_handle *vport_rx_rule;\n\tstruct list_head       vport_sqs_list;\n\tstruct mlx5_rep_uplink_priv uplink_priv;  \n\tstruct rtnl_link_stats64 prev_vf_vport_stats;\n\tstruct mlx5_flow_handle *send_to_vport_meta_rule;\n\tstruct rhashtable tc_ht;\n\tstruct devlink_health_reporter *rep_vnic_reporter;\n};\n\nstatic inline\nstruct mlx5e_rep_priv *mlx5e_rep_to_rep_priv(struct mlx5_eswitch_rep *rep)\n{\n\treturn rep->rep_data[REP_ETH].priv;\n}\n\nstruct mlx5e_neigh {\n\tunion {\n\t\t__be32\tv4;\n\t\tstruct in6_addr v6;\n\t} dst_ip;\n\tint family;\n};\n\nstruct mlx5e_neigh_hash_entry {\n\tstruct rhash_head rhash_node;\n\tstruct mlx5e_neigh m_neigh;\n\tstruct mlx5e_priv *priv;\n\tstruct net_device *neigh_dev;\n\n\t \n\tstruct list_head neigh_list;\n\n\t \n\tspinlock_t encap_list_lock;\n\t \n\tstruct list_head encap_list;\n\n\t \n\trefcount_t refcnt;\n\n\t \n\tunsigned long reported_lastuse;\n\n\tstruct rcu_head rcu;\n};\n\nenum {\n\t \n\tMLX5_ENCAP_ENTRY_VALID     = BIT(0),\n\tMLX5_REFORMAT_DECAP        = BIT(1),\n\tMLX5_ENCAP_ENTRY_NO_ROUTE  = BIT(2),\n};\n\nstruct mlx5e_decap_key {\n\tstruct ethhdr key;\n};\n\nstruct mlx5e_decap_entry {\n\tstruct mlx5e_decap_key key;\n\tstruct list_head flows;\n\tstruct hlist_node hlist;\n\trefcount_t refcnt;\n\tstruct completion res_ready;\n\tint compl_result;\n\tstruct mlx5_pkt_reformat *pkt_reformat;\n\tstruct rcu_head rcu;\n};\n\nstruct mlx5e_mpls_info {\n\tu32             label;\n\tu8              tc;\n\tu8              bos;\n\tu8              ttl;\n};\n\nstruct mlx5e_encap_entry {\n\t \n\tstruct mlx5e_neigh_hash_entry *nhe;\n\t \n\tstruct list_head encap_list;\n\t \n\tstruct hlist_node encap_hlist;\n\tstruct list_head flows;\n\tstruct list_head route_list;\n\tstruct mlx5_pkt_reformat *pkt_reformat;\n\tconst struct ip_tunnel_info *tun_info;\n\tstruct mlx5e_mpls_info mpls_info;\n\tunsigned char h_dest[ETH_ALEN];\t \n\n\tstruct net_device *out_dev;\n\tint route_dev_ifindex;\n\tstruct mlx5e_tc_tunnel *tunnel;\n\tint reformat_type;\n\tu8 flags;\n\tchar *encap_header;\n\tint encap_size;\n\trefcount_t refcnt;\n\tstruct completion res_ready;\n\tint compl_result;\n\tstruct rcu_head rcu;\n};\n\nstruct mlx5e_rep_sq_peer {\n\tstruct mlx5_flow_handle *rule;\n\tvoid *peer;\n};\n\nstruct mlx5e_rep_sq {\n\tstruct mlx5_flow_handle\t*send_to_vport_rule;\n\tstruct xarray sq_peer;\n\tu32 sqn;\n\tstruct list_head\t list;\n};\n\nint mlx5e_rep_init(void);\nvoid mlx5e_rep_cleanup(void);\nint mlx5e_rep_bond_init(struct mlx5e_rep_priv *rpriv);\nvoid mlx5e_rep_bond_cleanup(struct mlx5e_rep_priv *rpriv);\nint mlx5e_rep_bond_enslave(struct mlx5_eswitch *esw, struct net_device *netdev,\n\t\t\t   struct net_device *lag_dev);\nvoid mlx5e_rep_bond_unslave(struct mlx5_eswitch *esw,\n\t\t\t    const struct net_device *netdev,\n\t\t\t    const struct net_device *lag_dev);\nint mlx5e_rep_bond_update(struct mlx5e_priv *priv, bool cleanup);\n\nbool mlx5e_rep_has_offload_stats(const struct net_device *dev, int attr_id);\nint mlx5e_rep_get_offload_stats(int attr_id, const struct net_device *dev,\n\t\t\t\tvoid *sp);\n\nbool mlx5e_is_uplink_rep(struct mlx5e_priv *priv);\nvoid mlx5e_rep_activate_channels(struct mlx5e_priv *priv);\nvoid mlx5e_rep_deactivate_channels(struct mlx5e_priv *priv);\n\nvoid mlx5e_rep_queue_neigh_stats_work(struct mlx5e_priv *priv);\n\nbool mlx5e_eswitch_vf_rep(const struct net_device *netdev);\nbool mlx5e_eswitch_uplink_rep(const struct net_device *netdev);\nstatic inline bool mlx5e_eswitch_rep(const struct net_device *netdev)\n{\n\treturn mlx5e_eswitch_vf_rep(netdev) ||\n\t       mlx5e_eswitch_uplink_rep(netdev);\n}\n\n#else  \nstatic inline bool mlx5e_is_uplink_rep(struct mlx5e_priv *priv) { return false; }\nstatic inline void mlx5e_rep_activate_channels(struct mlx5e_priv *priv) {}\nstatic inline void mlx5e_rep_deactivate_channels(struct mlx5e_priv *priv) {}\nstatic inline int mlx5e_rep_init(void) { return 0; };\nstatic inline void mlx5e_rep_cleanup(void) {};\nstatic inline bool mlx5e_rep_has_offload_stats(const struct net_device *dev,\n\t\t\t\t\t       int attr_id) { return false; }\nstatic inline int mlx5e_rep_get_offload_stats(int attr_id,\n\t\t\t\t\t      const struct net_device *dev,\n\t\t\t\t\t      void *sp) { return -EOPNOTSUPP; }\n#endif\n\nstatic inline bool mlx5e_is_vport_rep(struct mlx5e_priv *priv)\n{\n\treturn (MLX5_ESWITCH_MANAGER(priv->mdev) && priv->ppriv);\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}