{
  "module_name": "hv_vhca_stats.c",
  "hash_id": "1e8ce61daf21b7fa07356c693d4fa7b85c5d128c151136788f05ec8521449b60",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/hv_vhca_stats.c",
  "human_readable_source": "\n\n\n#include \"en.h\"\n#include \"en/hv_vhca_stats.h\"\n#include \"lib/hv_vhca.h\"\n#include \"lib/hv.h\"\n\nstruct mlx5e_hv_vhca_per_ring_stats {\n\tu64     rx_packets;\n\tu64     rx_bytes;\n\tu64     tx_packets;\n\tu64     tx_bytes;\n};\n\nstatic void\nmlx5e_hv_vhca_fill_ring_stats(struct mlx5e_priv *priv, int ch,\n\t\t\t      struct mlx5e_hv_vhca_per_ring_stats *data)\n{\n\tstruct mlx5e_channel_stats *stats;\n\tint tc;\n\n\tstats = priv->channel_stats[ch];\n\tdata->rx_packets = stats->rq.packets;\n\tdata->rx_bytes   = stats->rq.bytes;\n\n\tfor (tc = 0; tc < priv->max_opened_tc; tc++) {\n\t\tdata->tx_packets += stats->sq[tc].packets;\n\t\tdata->tx_bytes   += stats->sq[tc].bytes;\n\t}\n}\n\nstatic void mlx5e_hv_vhca_fill_stats(struct mlx5e_priv *priv, void *data,\n\t\t\t\t     int buf_len)\n{\n\tint ch, i = 0;\n\n\tfor (ch = 0; ch < priv->stats_nch; ch++) {\n\t\tvoid *buf = data + i;\n\n\t\tif (WARN_ON_ONCE(buf +\n\t\t\t\t sizeof(struct mlx5e_hv_vhca_per_ring_stats) >\n\t\t\t\t data + buf_len))\n\t\t\treturn;\n\n\t\tmlx5e_hv_vhca_fill_ring_stats(priv, ch, buf);\n\t\ti += sizeof(struct mlx5e_hv_vhca_per_ring_stats);\n\t}\n}\n\nstatic int mlx5e_hv_vhca_stats_buf_size(struct mlx5e_priv *priv)\n{\n\treturn (sizeof(struct mlx5e_hv_vhca_per_ring_stats) *\n\t\tpriv->stats_nch);\n}\n\nstatic void mlx5e_hv_vhca_stats_work(struct work_struct *work)\n{\n\tstruct mlx5e_hv_vhca_stats_agent *sagent;\n\tstruct mlx5_hv_vhca_agent *agent;\n\tstruct delayed_work *dwork;\n\tstruct mlx5e_priv *priv;\n\tint buf_len, rc;\n\tvoid *buf;\n\n\tdwork = to_delayed_work(work);\n\tsagent = container_of(dwork, struct mlx5e_hv_vhca_stats_agent, work);\n\tpriv = container_of(sagent, struct mlx5e_priv, stats_agent);\n\tbuf_len = mlx5e_hv_vhca_stats_buf_size(priv);\n\tagent = sagent->agent;\n\tbuf = sagent->buf;\n\n\tmemset(buf, 0, buf_len);\n\tmlx5e_hv_vhca_fill_stats(priv, buf, buf_len);\n\n\trc = mlx5_hv_vhca_agent_write(agent, buf, buf_len);\n\tif (rc) {\n\t\tmlx5_core_err(priv->mdev,\n\t\t\t      \"%s: Failed to write stats, err = %d\\n\",\n\t\t\t      __func__, rc);\n\t\treturn;\n\t}\n\n\tif (sagent->delay)\n\t\tqueue_delayed_work(priv->wq, &sagent->work, sagent->delay);\n}\n\nenum {\n\tMLX5_HV_VHCA_STATS_VERSION     = 1,\n\tMLX5_HV_VHCA_STATS_UPDATE_ONCE = 0xFFFF,\n};\n\nstatic void mlx5e_hv_vhca_stats_control(struct mlx5_hv_vhca_agent *agent,\n\t\t\t\t\tstruct mlx5_hv_vhca_control_block *block)\n{\n\tstruct mlx5e_hv_vhca_stats_agent *sagent;\n\tstruct mlx5e_priv *priv;\n\n\tpriv = mlx5_hv_vhca_agent_priv(agent);\n\tsagent = &priv->stats_agent;\n\n\tblock->version = MLX5_HV_VHCA_STATS_VERSION;\n\tblock->rings   = priv->stats_nch;\n\n\tif (!block->command) {\n\t\tcancel_delayed_work_sync(&priv->stats_agent.work);\n\t\treturn;\n\t}\n\n\tsagent->delay = block->command == MLX5_HV_VHCA_STATS_UPDATE_ONCE ? 0 :\n\t\t\tmsecs_to_jiffies(block->command * 100);\n\n\tqueue_delayed_work(priv->wq, &sagent->work, sagent->delay);\n}\n\nstatic void mlx5e_hv_vhca_stats_cleanup(struct mlx5_hv_vhca_agent *agent)\n{\n\tstruct mlx5e_priv *priv = mlx5_hv_vhca_agent_priv(agent);\n\n\tcancel_delayed_work_sync(&priv->stats_agent.work);\n}\n\nvoid mlx5e_hv_vhca_stats_create(struct mlx5e_priv *priv)\n{\n\tint buf_len = mlx5e_hv_vhca_stats_buf_size(priv);\n\tstruct mlx5_hv_vhca_agent *agent;\n\n\tpriv->stats_agent.buf = kvzalloc(buf_len, GFP_KERNEL);\n\tif (!priv->stats_agent.buf)\n\t\treturn;\n\n\tagent = mlx5_hv_vhca_agent_create(priv->mdev->hv_vhca,\n\t\t\t\t\t  MLX5_HV_VHCA_AGENT_STATS,\n\t\t\t\t\t  mlx5e_hv_vhca_stats_control, NULL,\n\t\t\t\t\t  mlx5e_hv_vhca_stats_cleanup,\n\t\t\t\t\t  priv);\n\n\tif (IS_ERR_OR_NULL(agent)) {\n\t\tif (IS_ERR(agent))\n\t\t\tnetdev_warn(priv->netdev,\n\t\t\t\t    \"Failed to create hv vhca stats agent, err = %ld\\n\",\n\t\t\t\t    PTR_ERR(agent));\n\n\t\tkvfree(priv->stats_agent.buf);\n\t\treturn;\n\t}\n\n\tpriv->stats_agent.agent = agent;\n\tINIT_DELAYED_WORK(&priv->stats_agent.work, mlx5e_hv_vhca_stats_work);\n}\n\nvoid mlx5e_hv_vhca_stats_destroy(struct mlx5e_priv *priv)\n{\n\tif (IS_ERR_OR_NULL(priv->stats_agent.agent))\n\t\treturn;\n\n\tmlx5_hv_vhca_agent_destroy(priv->stats_agent.agent);\n\tkvfree(priv->stats_agent.buf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}