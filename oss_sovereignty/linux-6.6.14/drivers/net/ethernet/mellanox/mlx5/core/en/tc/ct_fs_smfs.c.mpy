{
  "module_name": "ct_fs_smfs.c",
  "hash_id": "625092d86a7b9f4381a95abdcd235b51943effecef8f6be91c5225e661b5e5dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/tc/ct_fs_smfs.c",
  "human_readable_source": "\n \n\n#include <linux/refcount.h>\n\n#include \"en_tc.h\"\n#include \"en/tc_priv.h\"\n#include \"en/tc_ct.h\"\n#include \"en/tc/ct_fs.h\"\n\n#include \"lib/smfs.h\"\n\n#define INIT_ERR_PREFIX \"ct_fs_smfs init failed\"\n#define ct_dbg(fmt, args...)\\\n\tnetdev_dbg(fs->netdev, \"ct_fs_smfs debug: \" fmt \"\\n\", ##args)\n#define MLX5_CT_TCP_FLAGS_MASK cpu_to_be16(be32_to_cpu(TCP_FLAG_RST | TCP_FLAG_FIN) >> 16)\n\nstruct mlx5_ct_fs_smfs_matcher {\n\tstruct mlx5dr_matcher *dr_matcher;\n\tstruct list_head list;\n\tint prio;\n\trefcount_t ref;\n};\n\nstruct mlx5_ct_fs_smfs_matchers {\n\tstruct mlx5_ct_fs_smfs_matcher smfs_matchers[6];\n\tstruct list_head used;\n};\n\nstruct mlx5_ct_fs_smfs {\n\tstruct mlx5dr_table *ct_tbl, *ct_nat_tbl;\n\tstruct mlx5_ct_fs_smfs_matchers matchers;\n\tstruct mlx5_ct_fs_smfs_matchers matchers_nat;\n\tstruct mlx5dr_action *fwd_action;\n\tstruct mlx5_flow_table *ct_nat;\n\tstruct mutex lock;  \n};\n\nstruct mlx5_ct_fs_smfs_rule {\n\tstruct mlx5_ct_fs_rule fs_rule;\n\tstruct mlx5dr_rule *rule;\n\tstruct mlx5dr_action *count_action;\n\tstruct mlx5_ct_fs_smfs_matcher *smfs_matcher;\n};\n\nstatic inline void\nmlx5_ct_fs_smfs_fill_mask(struct mlx5_ct_fs *fs, struct mlx5_flow_spec *spec, bool ipv4, bool tcp,\n\t\t\t  bool gre)\n{\n\tvoid *headers_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, outer_headers);\n\n\tif (likely(MLX5_CAP_FLOWTABLE_NIC_RX(fs->dev, ft_field_support.outer_ip_version)))\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, headers_c, ip_version);\n\telse\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, headers_c, ethertype);\n\n\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, headers_c, ip_protocol);\n\tif (likely(ipv4)) {\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t src_ipv4_src_ipv6.ipv4_layout.ipv4);\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t dst_ipv4_dst_ipv6.ipv4_layout.ipv4);\n\t} else {\n\t\tmemset(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t    dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t       0xFF,\n\t\t       MLX5_FLD_SZ_BYTES(fte_match_set_lyr_2_4,\n\t\t\t\t\t dst_ipv4_dst_ipv6.ipv6_layout.ipv6));\n\t\tmemset(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t    src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t       0xFF,\n\t\t       MLX5_FLD_SZ_BYTES(fte_match_set_lyr_2_4,\n\t\t\t\t\t src_ipv4_src_ipv6.ipv6_layout.ipv6));\n\t}\n\n\tif (likely(tcp)) {\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, headers_c, tcp_sport);\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, headers_c, tcp_dport);\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, tcp_flags,\n\t\t\t ntohs(MLX5_CT_TCP_FLAGS_MASK));\n\t} else if (!gre) {\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, headers_c, udp_sport);\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, headers_c, udp_dport);\n\t}\n\n\tmlx5e_tc_match_to_reg_match(spec, ZONE_TO_REG, 0, MLX5_CT_ZONE_MASK);\n}\n\nstatic struct mlx5dr_matcher *\nmlx5_ct_fs_smfs_matcher_create(struct mlx5_ct_fs *fs, struct mlx5dr_table *tbl, bool ipv4,\n\t\t\t       bool tcp, bool gre, u32 priority)\n{\n\tstruct mlx5dr_matcher *dr_matcher;\n\tstruct mlx5_flow_spec *spec;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmlx5_ct_fs_smfs_fill_mask(fs, spec, ipv4, tcp, gre);\n\tspec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS_2 | MLX5_MATCH_OUTER_HEADERS;\n\n\tdr_matcher = mlx5_smfs_matcher_create(tbl, priority, spec);\n\tkvfree(spec);\n\tif (!dr_matcher)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn dr_matcher;\n}\n\nstatic struct mlx5_ct_fs_smfs_matcher *\nmlx5_ct_fs_smfs_matcher_get(struct mlx5_ct_fs *fs, bool nat, bool ipv4, bool tcp, bool gre)\n{\n\tstruct mlx5_ct_fs_smfs *fs_smfs = mlx5_ct_fs_priv(fs);\n\tstruct mlx5_ct_fs_smfs_matcher *m, *smfs_matcher;\n\tstruct mlx5_ct_fs_smfs_matchers *matchers;\n\tstruct mlx5dr_matcher *dr_matcher;\n\tstruct mlx5dr_table *tbl;\n\tstruct list_head *prev;\n\tint prio;\n\n\tmatchers = nat ? &fs_smfs->matchers_nat : &fs_smfs->matchers;\n\tsmfs_matcher = &matchers->smfs_matchers[ipv4 * 3 + tcp * 2 + gre];\n\n\tif (refcount_inc_not_zero(&smfs_matcher->ref))\n\t\treturn smfs_matcher;\n\n\tmutex_lock(&fs_smfs->lock);\n\n\t \n\tif (refcount_inc_not_zero(&smfs_matcher->ref))\n\t\tgoto out_unlock;\n\n\t\n\tprio = 0;\n\tprev = &matchers->used;\n\tlist_for_each_entry(m, &matchers->used, list) {\n\t\tprev = &m->list;\n\n\t\tif (m->prio == prio)\n\t\t\tprio = m->prio + 1;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\ttbl = nat ? fs_smfs->ct_nat_tbl : fs_smfs->ct_tbl;\n\tdr_matcher = mlx5_ct_fs_smfs_matcher_create(fs, tbl, ipv4, tcp, gre, prio);\n\tif (IS_ERR(dr_matcher)) {\n\t\tnetdev_warn(fs->netdev,\n\t\t\t    \"ct_fs_smfs: failed to create matcher (nat %d, ipv4 %d, tcp %d, gre %d), err: %ld\\n\",\n\t\t\t    nat, ipv4, tcp, gre, PTR_ERR(dr_matcher));\n\n\t\tsmfs_matcher = ERR_CAST(dr_matcher);\n\t\tgoto out_unlock;\n\t}\n\n\tsmfs_matcher->dr_matcher = dr_matcher;\n\tsmfs_matcher->prio = prio;\n\tlist_add(&smfs_matcher->list, prev);\n\trefcount_set(&smfs_matcher->ref, 1);\n\nout_unlock:\n\tmutex_unlock(&fs_smfs->lock);\n\treturn smfs_matcher;\n}\n\nstatic void\nmlx5_ct_fs_smfs_matcher_put(struct mlx5_ct_fs *fs, struct mlx5_ct_fs_smfs_matcher *smfs_matcher)\n{\n\tstruct mlx5_ct_fs_smfs *fs_smfs = mlx5_ct_fs_priv(fs);\n\n\tif (!refcount_dec_and_mutex_lock(&smfs_matcher->ref, &fs_smfs->lock))\n\t\treturn;\n\n\tmlx5_smfs_matcher_destroy(smfs_matcher->dr_matcher);\n\tlist_del(&smfs_matcher->list);\n\tmutex_unlock(&fs_smfs->lock);\n}\n\nstatic int\nmlx5_ct_fs_smfs_init(struct mlx5_ct_fs *fs, struct mlx5_flow_table *ct,\n\t\t     struct mlx5_flow_table *ct_nat, struct mlx5_flow_table *post_ct)\n{\n\tstruct mlx5dr_table *ct_tbl, *ct_nat_tbl, *post_ct_tbl;\n\tstruct mlx5_ct_fs_smfs *fs_smfs = mlx5_ct_fs_priv(fs);\n\n\tpost_ct_tbl = mlx5_smfs_table_get_from_fs_ft(post_ct);\n\tct_nat_tbl = mlx5_smfs_table_get_from_fs_ft(ct_nat);\n\tct_tbl = mlx5_smfs_table_get_from_fs_ft(ct);\n\tfs_smfs->ct_nat = ct_nat;\n\n\tif (!ct_tbl || !ct_nat_tbl || !post_ct_tbl) {\n\t\tnetdev_warn(fs->netdev, \"ct_fs_smfs: failed to init, missing backing dr tables\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tct_dbg(\"using smfs steering\");\n\n\tfs_smfs->fwd_action = mlx5_smfs_action_create_dest_table(post_ct_tbl);\n\tif (!fs_smfs->fwd_action) {\n\t\treturn -EINVAL;\n\t}\n\n\tfs_smfs->ct_tbl = ct_tbl;\n\tfs_smfs->ct_nat_tbl = ct_nat_tbl;\n\tmutex_init(&fs_smfs->lock);\n\tINIT_LIST_HEAD(&fs_smfs->matchers.used);\n\tINIT_LIST_HEAD(&fs_smfs->matchers_nat.used);\n\n\treturn 0;\n}\n\nstatic void\nmlx5_ct_fs_smfs_destroy(struct mlx5_ct_fs *fs)\n{\n\tstruct mlx5_ct_fs_smfs *fs_smfs = mlx5_ct_fs_priv(fs);\n\n\tmlx5_smfs_action_destroy(fs_smfs->fwd_action);\n}\n\nstatic inline bool\nmlx5_tc_ct_valid_used_dissector_keys(const u64 used_keys)\n{\n#define DISS_BIT(name) BIT_ULL(FLOW_DISSECTOR_KEY_ ## name)\n\tconst u64 basic_keys = DISS_BIT(BASIC) | DISS_BIT(CONTROL) |\n\t\t\t\tDISS_BIT(META);\n\tconst u64 ipv4_tcp = basic_keys | DISS_BIT(IPV4_ADDRS) |\n\t\t\t\tDISS_BIT(PORTS) | DISS_BIT(TCP);\n\tconst u64 ipv6_tcp = basic_keys | DISS_BIT(IPV6_ADDRS) |\n\t\t\t\tDISS_BIT(PORTS) | DISS_BIT(TCP);\n\tconst u64 ipv4_udp = basic_keys | DISS_BIT(IPV4_ADDRS) |\n\t\t\t\tDISS_BIT(PORTS);\n\tconst u64 ipv6_udp = basic_keys | DISS_BIT(IPV6_ADDRS) |\n\t\t\t\t DISS_BIT(PORTS);\n\tconst u64 ipv4_gre = basic_keys | DISS_BIT(IPV4_ADDRS);\n\tconst u64 ipv6_gre = basic_keys | DISS_BIT(IPV6_ADDRS);\n\n\treturn (used_keys == ipv4_tcp || used_keys == ipv4_udp || used_keys == ipv6_tcp ||\n\t\tused_keys == ipv6_udp || used_keys == ipv4_gre || used_keys == ipv6_gre);\n}\n\nstatic bool\nmlx5_ct_fs_smfs_ct_validate_flow_rule(struct mlx5_ct_fs *fs, struct flow_rule *flow_rule)\n{\n\tstruct flow_match_ipv4_addrs ipv4_addrs;\n\tstruct flow_match_ipv6_addrs ipv6_addrs;\n\tstruct flow_match_control control;\n\tstruct flow_match_basic basic;\n\tstruct flow_match_ports ports;\n\tstruct flow_match_tcp tcp;\n\n\tif (!mlx5_tc_ct_valid_used_dissector_keys(flow_rule->match.dissector->used_keys)) {\n\t\tct_dbg(\"rule uses unexpected dissectors (0x%016llx)\",\n\t\t       flow_rule->match.dissector->used_keys);\n\t\treturn false;\n\t}\n\n\tflow_rule_match_basic(flow_rule, &basic);\n\tflow_rule_match_control(flow_rule, &control);\n\tflow_rule_match_ipv4_addrs(flow_rule, &ipv4_addrs);\n\tflow_rule_match_ipv6_addrs(flow_rule, &ipv6_addrs);\n\tif (basic.key->ip_proto != IPPROTO_GRE)\n\t\tflow_rule_match_ports(flow_rule, &ports);\n\tif (basic.key->ip_proto == IPPROTO_TCP)\n\t\tflow_rule_match_tcp(flow_rule, &tcp);\n\n\tif (basic.mask->n_proto != htons(0xFFFF) ||\n\t    (basic.key->n_proto != htons(ETH_P_IP) && basic.key->n_proto != htons(ETH_P_IPV6)) ||\n\t    basic.mask->ip_proto != 0xFF ||\n\t    (basic.key->ip_proto != IPPROTO_UDP && basic.key->ip_proto != IPPROTO_TCP &&\n\t     basic.key->ip_proto != IPPROTO_GRE)) {\n\t\tct_dbg(\"rule uses unexpected basic match (n_proto 0x%04x/0x%04x, ip_proto 0x%02x/0x%02x)\",\n\t\t       ntohs(basic.key->n_proto), ntohs(basic.mask->n_proto),\n\t\t       basic.key->ip_proto, basic.mask->ip_proto);\n\t\treturn false;\n\t}\n\n\tif (basic.key->ip_proto != IPPROTO_GRE &&\n\t    (ports.mask->src != htons(0xFFFF) || ports.mask->dst != htons(0xFFFF))) {\n\t\tct_dbg(\"rule uses ports match (src 0x%04x, dst 0x%04x)\",\n\t\t       ports.mask->src, ports.mask->dst);\n\t\treturn false;\n\t}\n\n\tif (basic.key->ip_proto == IPPROTO_TCP && tcp.mask->flags != MLX5_CT_TCP_FLAGS_MASK) {\n\t\tct_dbg(\"rule uses unexpected tcp match (flags 0x%02x)\", tcp.mask->flags);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic struct mlx5_ct_fs_rule *\nmlx5_ct_fs_smfs_ct_rule_add(struct mlx5_ct_fs *fs, struct mlx5_flow_spec *spec,\n\t\t\t    struct mlx5_flow_attr *attr, struct flow_rule *flow_rule)\n{\n\tstruct mlx5_ct_fs_smfs *fs_smfs = mlx5_ct_fs_priv(fs);\n\tstruct mlx5_ct_fs_smfs_matcher *smfs_matcher;\n\tstruct mlx5_ct_fs_smfs_rule *smfs_rule;\n\tstruct mlx5dr_action *actions[5];\n\tstruct mlx5dr_rule *rule;\n\tint num_actions = 0, err;\n\tbool nat, tcp, ipv4, gre;\n\n\tif (!mlx5_ct_fs_smfs_ct_validate_flow_rule(fs, flow_rule))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tsmfs_rule = kzalloc(sizeof(*smfs_rule), GFP_KERNEL);\n\tif (!smfs_rule)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsmfs_rule->count_action = mlx5_smfs_action_create_flow_counter(mlx5_fc_id(attr->counter));\n\tif (!smfs_rule->count_action) {\n\t\terr = -EINVAL;\n\t\tgoto err_count;\n\t}\n\n\tactions[num_actions++] = smfs_rule->count_action;\n\tactions[num_actions++] = attr->modify_hdr->action.dr_action;\n\tactions[num_actions++] = fs_smfs->fwd_action;\n\n\tnat = (attr->ft == fs_smfs->ct_nat);\n\tipv4 = mlx5e_tc_get_ip_version(spec, true) == 4;\n\ttcp = MLX5_GET(fte_match_param, spec->match_value,\n\t\t       outer_headers.ip_protocol) == IPPROTO_TCP;\n\tgre = MLX5_GET(fte_match_param, spec->match_value,\n\t\t       outer_headers.ip_protocol) == IPPROTO_GRE;\n\n\tsmfs_matcher = mlx5_ct_fs_smfs_matcher_get(fs, nat, ipv4, tcp, gre);\n\tif (IS_ERR(smfs_matcher)) {\n\t\terr = PTR_ERR(smfs_matcher);\n\t\tgoto err_matcher;\n\t}\n\n\trule = mlx5_smfs_rule_create(smfs_matcher->dr_matcher, spec, num_actions, actions,\n\t\t\t\t     spec->flow_context.flow_source);\n\tif (!rule) {\n\t\terr = -EINVAL;\n\t\tgoto err_create;\n\t}\n\n\tsmfs_rule->rule = rule;\n\tsmfs_rule->smfs_matcher = smfs_matcher;\n\n\treturn &smfs_rule->fs_rule;\n\nerr_create:\n\tmlx5_ct_fs_smfs_matcher_put(fs, smfs_matcher);\nerr_matcher:\n\tmlx5_smfs_action_destroy(smfs_rule->count_action);\nerr_count:\n\tkfree(smfs_rule);\n\treturn ERR_PTR(err);\n}\n\nstatic void\nmlx5_ct_fs_smfs_ct_rule_del(struct mlx5_ct_fs *fs, struct mlx5_ct_fs_rule *fs_rule)\n{\n\tstruct mlx5_ct_fs_smfs_rule *smfs_rule = container_of(fs_rule,\n\t\t\t\t\t\t\t      struct mlx5_ct_fs_smfs_rule,\n\t\t\t\t\t\t\t      fs_rule);\n\n\tmlx5_smfs_rule_destroy(smfs_rule->rule);\n\tmlx5_ct_fs_smfs_matcher_put(fs, smfs_rule->smfs_matcher);\n\tmlx5_smfs_action_destroy(smfs_rule->count_action);\n\tkfree(smfs_rule);\n}\n\nstatic struct mlx5_ct_fs_ops fs_smfs_ops = {\n\t.ct_rule_add = mlx5_ct_fs_smfs_ct_rule_add,\n\t.ct_rule_del = mlx5_ct_fs_smfs_ct_rule_del,\n\n\t.init = mlx5_ct_fs_smfs_init,\n\t.destroy = mlx5_ct_fs_smfs_destroy,\n\n\t.priv_size = sizeof(struct mlx5_ct_fs_smfs),\n};\n\nstruct mlx5_ct_fs_ops *\nmlx5_ct_fs_smfs_ops_get(void)\n{\n\treturn &fs_smfs_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}