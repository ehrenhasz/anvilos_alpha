{
  "module_name": "macsec_fs.c",
  "hash_id": "d8cb17e9b705f336661ff943319da00a11901e924de7a70c2b94b74acd6a4aba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/lib/macsec_fs.c",
  "human_readable_source": "\n \n\n#include <net/macsec.h>\n#include <linux/mlx5/qp.h>\n#include <linux/if_vlan.h>\n#include <linux/mlx5/fs_helpers.h>\n#include <linux/mlx5/macsec.h>\n#include \"fs_core.h\"\n#include \"lib/macsec_fs.h\"\n#include \"mlx5_core.h\"\n\n \n#define CRYPTO_NUM_MAXSEC_FTE BIT(15)\n#define CRYPTO_TABLE_DEFAULT_RULE_GROUP_SIZE 1\n\n#define TX_CRYPTO_TABLE_LEVEL 0\n#define TX_CRYPTO_TABLE_NUM_GROUPS 3\n#define TX_CRYPTO_TABLE_MKE_GROUP_SIZE 1\n#define TX_CRYPTO_TABLE_SA_GROUP_SIZE \\\n\t(CRYPTO_NUM_MAXSEC_FTE - (TX_CRYPTO_TABLE_MKE_GROUP_SIZE + \\\n\t\t\t\t  CRYPTO_TABLE_DEFAULT_RULE_GROUP_SIZE))\n#define TX_CHECK_TABLE_LEVEL 1\n#define TX_CHECK_TABLE_NUM_FTE 2\n#define RX_CRYPTO_TABLE_LEVEL 0\n#define RX_CHECK_TABLE_LEVEL 1\n#define RX_ROCE_TABLE_LEVEL 2\n#define RX_CHECK_TABLE_NUM_FTE 3\n#define RX_ROCE_TABLE_NUM_FTE 2\n#define RX_CRYPTO_TABLE_NUM_GROUPS 3\n#define RX_CRYPTO_TABLE_SA_RULE_WITH_SCI_GROUP_SIZE \\\n\t((CRYPTO_NUM_MAXSEC_FTE - CRYPTO_TABLE_DEFAULT_RULE_GROUP_SIZE) / 2)\n#define RX_CRYPTO_TABLE_SA_RULE_WITHOUT_SCI_GROUP_SIZE \\\n\t(CRYPTO_NUM_MAXSEC_FTE - RX_CRYPTO_TABLE_SA_RULE_WITH_SCI_GROUP_SIZE)\n#define RX_NUM_OF_RULES_PER_SA 2\n\n#define RDMA_RX_ROCE_IP_TABLE_LEVEL 0\n#define RDMA_RX_ROCE_MACSEC_OP_TABLE_LEVEL 1\n\n#define MLX5_MACSEC_TAG_LEN 8  \n#define MLX5_MACSEC_SECTAG_TCI_AN_FIELD_BITMASK 0x23\n#define MLX5_MACSEC_SECTAG_TCI_AN_FIELD_OFFSET 0x8\n#define MLX5_MACSEC_SECTAG_TCI_SC_FIELD_OFFSET 0x5\n#define MLX5_MACSEC_SECTAG_TCI_SC_FIELD_BIT (0x1 << MLX5_MACSEC_SECTAG_TCI_SC_FIELD_OFFSET)\n#define MLX5_SECTAG_HEADER_SIZE_WITHOUT_SCI 0x8\n#define MLX5_SECTAG_HEADER_SIZE_WITH_SCI (MLX5_SECTAG_HEADER_SIZE_WITHOUT_SCI + MACSEC_SCI_LEN)\n\n \n#define MLX5_ETH_WQE_FT_META_MACSEC_MASK 0x3E\n\n \n#define macsec_fs_set_tx_fs_id(fs_id) (MLX5_ETH_WQE_FT_META_MACSEC | (fs_id) << 2)\n#define macsec_fs_set_rx_fs_id(fs_id) ((fs_id) | BIT(30))\n\nstruct mlx5_sectag_header {\n\t__be16 ethertype;\n\tu8 tci_an;\n\tu8 sl;\n\tu32 pn;\n\tu8 sci[MACSEC_SCI_LEN];  \n}  __packed;\n\nstruct mlx5_roce_macsec_tx_rule {\n\tu32 fs_id;\n\tu16 gid_idx;\n\tstruct list_head entry;\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_modify_hdr *meta_modhdr;\n};\n\nstruct mlx5_macsec_tx_rule {\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_pkt_reformat *pkt_reformat;\n\tu32 fs_id;\n};\n\nstruct mlx5_macsec_flow_table {\n\tint num_groups;\n\tstruct mlx5_flow_table *t;\n\tstruct mlx5_flow_group **g;\n};\n\nstruct mlx5_macsec_tables {\n\tstruct mlx5_macsec_flow_table ft_crypto;\n\tstruct mlx5_flow_handle *crypto_miss_rule;\n\n\tstruct mlx5_flow_table *ft_check;\n\tstruct mlx5_flow_group  *ft_check_group;\n\tstruct mlx5_fc *check_miss_rule_counter;\n\tstruct mlx5_flow_handle *check_miss_rule;\n\tstruct mlx5_fc *check_rule_counter;\n\n\tu32 refcnt;\n};\n\nstruct mlx5_fs_id {\n\tu32 id;\n\trefcount_t refcnt;\n\tsci_t sci;\n\tstruct rhash_head hash;\n};\n\nstruct mlx5_macsec_device {\n\tstruct list_head macsec_devices_list_entry;\n\tvoid *macdev;\n\tstruct xarray tx_id_xa;\n\tstruct xarray rx_id_xa;\n};\n\nstruct mlx5_macsec_tx {\n\tstruct mlx5_flow_handle *crypto_mke_rule;\n\tstruct mlx5_flow_handle *check_rule;\n\n\tstruct ida tx_halloc;\n\n\tstruct mlx5_macsec_tables tables;\n\n\tstruct mlx5_flow_table *ft_rdma_tx;\n};\n\nstruct mlx5_roce_macsec_rx_rule {\n\tu32 fs_id;\n\tu16 gid_idx;\n\tstruct mlx5_flow_handle *op;\n\tstruct mlx5_flow_handle *ip;\n\tstruct list_head entry;\n};\n\nstruct mlx5_macsec_rx_rule {\n\tstruct mlx5_flow_handle *rule[RX_NUM_OF_RULES_PER_SA];\n\tstruct mlx5_modify_hdr *meta_modhdr;\n};\n\nstruct mlx5_macsec_miss {\n\tstruct mlx5_flow_group *g;\n\tstruct mlx5_flow_handle *rule;\n};\n\nstruct mlx5_macsec_rx_roce {\n\t \n\tstruct mlx5_flow_group *g;\n\tstruct mlx5_flow_table *ft;\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_modify_hdr *copy_modify_hdr;\n\tstruct mlx5_macsec_miss nic_miss;\n\n\t \n\tstruct mlx5_flow_table *ft_ip_check;\n\tstruct mlx5_flow_table *ft_macsec_op_check;\n\tstruct mlx5_macsec_miss miss;\n};\n\nstruct mlx5_macsec_rx {\n\tstruct mlx5_flow_handle *check_rule[2];\n\tstruct mlx5_pkt_reformat *check_rule_pkt_reformat[2];\n\n\tstruct mlx5_macsec_tables tables;\n\tstruct mlx5_macsec_rx_roce roce;\n};\n\nunion mlx5_macsec_rule {\n\tstruct mlx5_macsec_tx_rule tx_rule;\n\tstruct mlx5_macsec_rx_rule rx_rule;\n};\n\nstatic const struct rhashtable_params rhash_sci = {\n\t.key_len = sizeof_field(struct mlx5_fs_id, sci),\n\t.key_offset = offsetof(struct mlx5_fs_id, sci),\n\t.head_offset = offsetof(struct mlx5_fs_id, hash),\n\t.automatic_shrinking = true,\n\t.min_size = 1,\n};\n\nstatic const struct rhashtable_params rhash_fs_id = {\n\t.key_len = sizeof_field(struct mlx5_fs_id, id),\n\t.key_offset = offsetof(struct mlx5_fs_id, id),\n\t.head_offset = offsetof(struct mlx5_fs_id, hash),\n\t.automatic_shrinking = true,\n\t.min_size = 1,\n};\n\nstruct mlx5_macsec_fs {\n\tstruct mlx5_core_dev *mdev;\n\tstruct mlx5_macsec_tx *tx_fs;\n\tstruct mlx5_macsec_rx *rx_fs;\n\n\t \n\tstruct mlx5_macsec_stats stats;\n\n\t \n\tstruct rhashtable sci_hash;       \n\n\t \n\tstruct rhashtable fs_id_hash;       \n\n\t \n\tstruct list_head macsec_devices_list;\n};\n\nstatic void macsec_fs_destroy_groups(struct mlx5_macsec_flow_table *ft)\n{\n\tint i;\n\n\tfor (i = ft->num_groups - 1; i >= 0; i--) {\n\t\tif (!IS_ERR_OR_NULL(ft->g[i]))\n\t\t\tmlx5_destroy_flow_group(ft->g[i]);\n\t\tft->g[i] = NULL;\n\t}\n\tft->num_groups = 0;\n}\n\nstatic void macsec_fs_destroy_flow_table(struct mlx5_macsec_flow_table *ft)\n{\n\tmacsec_fs_destroy_groups(ft);\n\tkfree(ft->g);\n\tmlx5_destroy_flow_table(ft->t);\n\tft->t = NULL;\n}\n\nstatic void macsec_fs_tx_destroy(struct mlx5_macsec_fs *macsec_fs)\n{\n\tstruct mlx5_macsec_tx *tx_fs = macsec_fs->tx_fs;\n\tstruct mlx5_macsec_tables *tx_tables;\n\n\tif (mlx5_is_macsec_roce_supported(macsec_fs->mdev))\n\t\tmlx5_destroy_flow_table(tx_fs->ft_rdma_tx);\n\n\ttx_tables = &tx_fs->tables;\n\n\t \n\tif (tx_fs->check_rule) {\n\t\tmlx5_del_flow_rules(tx_fs->check_rule);\n\t\ttx_fs->check_rule = NULL;\n\t}\n\n\tif (tx_tables->check_miss_rule) {\n\t\tmlx5_del_flow_rules(tx_tables->check_miss_rule);\n\t\ttx_tables->check_miss_rule = NULL;\n\t}\n\n\tif (tx_tables->ft_check_group) {\n\t\tmlx5_destroy_flow_group(tx_tables->ft_check_group);\n\t\ttx_tables->ft_check_group = NULL;\n\t}\n\n\tif (tx_tables->ft_check) {\n\t\tmlx5_destroy_flow_table(tx_tables->ft_check);\n\t\ttx_tables->ft_check = NULL;\n\t}\n\n\t \n\tif (tx_fs->crypto_mke_rule) {\n\t\tmlx5_del_flow_rules(tx_fs->crypto_mke_rule);\n\t\ttx_fs->crypto_mke_rule = NULL;\n\t}\n\n\tif (tx_tables->crypto_miss_rule) {\n\t\tmlx5_del_flow_rules(tx_tables->crypto_miss_rule);\n\t\ttx_tables->crypto_miss_rule = NULL;\n\t}\n\n\tmacsec_fs_destroy_flow_table(&tx_tables->ft_crypto);\n}\n\nstatic int macsec_fs_tx_create_crypto_table_groups(struct mlx5_macsec_flow_table *ft)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tint mclen = MLX5_ST_SZ_BYTES(fte_match_param);\n\tint ix = 0;\n\tu32 *in;\n\tint err;\n\tu8 *mc;\n\n\tft->g = kcalloc(TX_CRYPTO_TABLE_NUM_GROUPS, sizeof(*ft->g), GFP_KERNEL);\n\tif (!ft->g)\n\t\treturn -ENOMEM;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\n\tif (!in) {\n\t\tkfree(ft->g);\n\t\tft->g = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tmc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\n\t \n\tMLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);\n\tMLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.ethertype);\n\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += TX_CRYPTO_TABLE_MKE_GROUP_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);\n\tif (IS_ERR(ft->g[ft->num_groups]))\n\t\tgoto err;\n\tft->num_groups++;\n\n\t \n\tmemset(in, 0, inlen);\n\tmemset(mc, 0, mclen);\n\tMLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_MISC_PARAMETERS_2);\n\tMLX5_SET(fte_match_param, mc, misc_parameters_2.metadata_reg_a,\n\t\t MLX5_ETH_WQE_FT_META_MACSEC_MASK);\n\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += TX_CRYPTO_TABLE_SA_GROUP_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);\n\tif (IS_ERR(ft->g[ft->num_groups]))\n\t\tgoto err;\n\tft->num_groups++;\n\n\t \n\tmemset(in, 0, inlen);\n\tmemset(mc, 0, mclen);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += CRYPTO_TABLE_DEFAULT_RULE_GROUP_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);\n\tif (IS_ERR(ft->g[ft->num_groups]))\n\t\tgoto err;\n\tft->num_groups++;\n\n\tkvfree(in);\n\treturn 0;\n\nerr:\n\terr = PTR_ERR(ft->g[ft->num_groups]);\n\tft->g[ft->num_groups] = NULL;\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic struct mlx5_flow_table\n\t*macsec_fs_auto_group_table_create(struct mlx5_flow_namespace *ns, int flags,\n\t\t\t\t\t   int level, int max_fte)\n{\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_flow_table *fdb = NULL;\n\n\t \n\tft_attr.autogroup.num_reserved_entries = 1;\n\tft_attr.autogroup.max_num_groups = 1;\n\tft_attr.prio = 0;\n\tft_attr.flags = flags;\n\tft_attr.level = level;\n\tft_attr.max_fte = max_fte;\n\n\tfdb = mlx5_create_auto_grouped_flow_table(ns, &ft_attr);\n\n\treturn fdb;\n}\n\nenum {\n\tRDMA_TX_MACSEC_LEVEL = 0,\n};\n\nstatic int macsec_fs_tx_roce_create(struct mlx5_macsec_fs *macsec_fs)\n{\n\tstruct mlx5_macsec_tx *tx_fs = macsec_fs->tx_fs;\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\tstruct mlx5_flow_namespace *ns;\n\tstruct mlx5_flow_table *ft;\n\tint err;\n\n\tif (!mlx5_is_macsec_roce_supported(mdev)) {\n\t\tmlx5_core_dbg(mdev, \"Failed to init RoCE MACsec, capabilities not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tns = mlx5_get_flow_namespace(mdev, MLX5_FLOW_NAMESPACE_RDMA_TX_MACSEC);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\n\t \n\tft = macsec_fs_auto_group_table_create(ns, 0, RDMA_TX_MACSEC_LEVEL, CRYPTO_NUM_MAXSEC_FTE);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tmlx5_core_err(mdev, \"Failed to create MACsec RoCE Tx crypto table err(%d)\\n\", err);\n\t\treturn err;\n\t}\n\ttx_fs->ft_rdma_tx = ft;\n\n\treturn 0;\n}\n\nstatic int macsec_fs_tx_create(struct mlx5_macsec_fs *macsec_fs)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_macsec_tx *tx_fs = macsec_fs->tx_fs;\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_macsec_tables *tx_tables;\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_macsec_flow_table *ft_crypto;\n\tstruct mlx5_flow_table *flow_table;\n\tstruct mlx5_flow_group *flow_group;\n\tstruct mlx5_flow_namespace *ns;\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tu32 *flow_group_in;\n\tint err;\n\n\tns = mlx5_get_flow_namespace(mdev, MLX5_FLOW_NAMESPACE_EGRESS_MACSEC);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tif (!flow_group_in) {\n\t\terr = -ENOMEM;\n\t\tgoto out_spec;\n\t}\n\n\ttx_tables = &tx_fs->tables;\n\tft_crypto = &tx_tables->ft_crypto;\n\n\t \n\tft_attr.flags = MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT;\n\tft_attr.level = TX_CRYPTO_TABLE_LEVEL;\n\tft_attr.max_fte = CRYPTO_NUM_MAXSEC_FTE;\n\n\tflow_table = mlx5_create_flow_table(ns, &ft_attr);\n\tif (IS_ERR(flow_table)) {\n\t\terr = PTR_ERR(flow_table);\n\t\tmlx5_core_err(mdev, \"Failed to create MACsec Tx crypto table err(%d)\\n\", err);\n\t\tgoto out_flow_group;\n\t}\n\tft_crypto->t = flow_table;\n\n\t \n\terr = macsec_fs_tx_create_crypto_table_groups(ft_crypto);\n\tif (err) {\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to create default flow group for MACsec Tx crypto table err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err;\n\t}\n\n\t \n\tspec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ethertype);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ethertype, ETH_P_PAE);\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_ALLOW;\n\n\trule = mlx5_add_flow_rules(ft_crypto->t, spec, &flow_act, NULL, 0);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"Failed to add MACsec TX MKE rule, err=%d\\n\", err);\n\t\tgoto err;\n\t}\n\ttx_fs->crypto_mke_rule = rule;\n\n\t \n\tmemset(&flow_act, 0, sizeof(flow_act));\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_ALLOW;\n\trule = mlx5_add_flow_rules(ft_crypto->t, NULL, &flow_act, NULL, 0);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"Failed to add MACsec Tx table default miss rule %d\\n\", err);\n\t\tgoto err;\n\t}\n\ttx_tables->crypto_miss_rule = rule;\n\n\t \n\tflow_table = macsec_fs_auto_group_table_create(ns, 0, TX_CHECK_TABLE_LEVEL,\n\t\t\t\t\t\t       TX_CHECK_TABLE_NUM_FTE);\n\tif (IS_ERR(flow_table)) {\n\t\terr = PTR_ERR(flow_table);\n\t\tmlx5_core_err(mdev, \"Fail to create MACsec TX check table, err(%d)\\n\", err);\n\t\tgoto err;\n\t}\n\ttx_tables->ft_check = flow_table;\n\n\t \n\tmemset(flow_group_in, 0, inlen);\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, flow_table->max_fte - 1);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, flow_table->max_fte - 1);\n\tflow_group = mlx5_create_flow_group(tx_tables->ft_check, flow_group_in);\n\tif (IS_ERR(flow_group)) {\n\t\terr = PTR_ERR(flow_group);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to create default flow group for MACsec Tx crypto table err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err;\n\t}\n\ttx_tables->ft_check_group = flow_group;\n\n\t \n\tmemset(&dest, 0, sizeof(struct mlx5_flow_destination));\n\tmemset(&flow_act, 0, sizeof(flow_act));\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\tdest.counter_id = mlx5_fc_id(tx_tables->check_miss_rule_counter);\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_DROP | MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\trule = mlx5_add_flow_rules(tx_tables->ft_check,  NULL, &flow_act, &dest, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"Failed to added MACsec tx check drop rule, err(%d)\\n\", err);\n\t\tgoto err;\n\t}\n\ttx_tables->check_miss_rule = rule;\n\n\t \n\tmemset(spec, 0, sizeof(struct mlx5_flow_spec));\n\tmemset(&dest, 0, sizeof(struct mlx5_flow_destination));\n\tmemset(&flow_act, 0, sizeof(flow_act));\n\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, misc_parameters_2.metadata_reg_c_4);\n\tMLX5_SET(fte_match_param, spec->match_value, misc_parameters_2.metadata_reg_c_4, 0);\n\tspec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS_2;\n\n\tflow_act.flags = FLOW_ACT_NO_APPEND;\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_ALLOW | MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\tdest.counter_id = mlx5_fc_id(tx_tables->check_rule_counter);\n\trule = mlx5_add_flow_rules(tx_tables->ft_check, spec, &flow_act, &dest, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"Failed to add MACsec check rule, err=%d\\n\", err);\n\t\tgoto err;\n\t}\n\ttx_fs->check_rule = rule;\n\n\terr = macsec_fs_tx_roce_create(macsec_fs);\n\tif (err)\n\t\tgoto err;\n\n\tkvfree(flow_group_in);\n\tkvfree(spec);\n\treturn 0;\n\nerr:\n\tmacsec_fs_tx_destroy(macsec_fs);\nout_flow_group:\n\tkvfree(flow_group_in);\nout_spec:\n\tkvfree(spec);\n\treturn err;\n}\n\nstatic int macsec_fs_tx_ft_get(struct mlx5_macsec_fs *macsec_fs)\n{\n\tstruct mlx5_macsec_tx *tx_fs = macsec_fs->tx_fs;\n\tstruct mlx5_macsec_tables *tx_tables;\n\tint err = 0;\n\n\ttx_tables = &tx_fs->tables;\n\tif (tx_tables->refcnt)\n\t\tgoto out;\n\n\terr = macsec_fs_tx_create(macsec_fs);\n\tif (err)\n\t\treturn err;\n\nout:\n\ttx_tables->refcnt++;\n\treturn err;\n}\n\nstatic void macsec_fs_tx_ft_put(struct mlx5_macsec_fs *macsec_fs)\n{\n\tstruct mlx5_macsec_tables *tx_tables = &macsec_fs->tx_fs->tables;\n\n\tif (--tx_tables->refcnt)\n\t\treturn;\n\n\tmacsec_fs_tx_destroy(macsec_fs);\n}\n\nstatic int macsec_fs_tx_setup_fte(struct mlx5_macsec_fs *macsec_fs,\n\t\t\t\t  struct mlx5_flow_spec *spec,\n\t\t\t\t  struct mlx5_flow_act *flow_act,\n\t\t\t\t  u32 macsec_obj_id,\n\t\t\t\t  u32 *fs_id)\n{\n\tstruct mlx5_macsec_tx *tx_fs = macsec_fs->tx_fs;\n\tint err = 0;\n\tu32 id;\n\n\terr = ida_alloc_range(&tx_fs->tx_halloc, 1,\n\t\t\t      MLX5_MACSEC_NUM_OF_SUPPORTED_INTERFACES,\n\t\t\t      GFP_KERNEL);\n\tif (err < 0)\n\t\treturn err;\n\n\tid = err;\n\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_2;\n\n\t \n\tMLX5_SET(fte_match_param, spec->match_criteria, misc_parameters_2.metadata_reg_a,\n\t\t MLX5_ETH_WQE_FT_META_MACSEC_MASK);\n\tMLX5_SET(fte_match_param, spec->match_value, misc_parameters_2.metadata_reg_a,\n\t\t macsec_fs_set_tx_fs_id(id));\n\n\t*fs_id = id;\n\tflow_act->crypto.type = MLX5_FLOW_CONTEXT_ENCRYPT_DECRYPT_TYPE_MACSEC;\n\tflow_act->crypto.obj_id = macsec_obj_id;\n\n\tmlx5_core_dbg(macsec_fs->mdev, \"Tx fte: macsec obj_id %u, fs_id %u\\n\", macsec_obj_id, id);\n\treturn 0;\n}\n\nstatic void macsec_fs_tx_create_sectag_header(const struct macsec_context *ctx,\n\t\t\t\t\t      char *reformatbf,\n\t\t\t\t\t      size_t *reformat_size)\n{\n\tconst struct macsec_secy *secy = ctx->secy;\n\tbool sci_present = macsec_send_sci(secy);\n\tstruct mlx5_sectag_header sectag = {};\n\tconst struct macsec_tx_sc *tx_sc;\n\n\ttx_sc = &secy->tx_sc;\n\tsectag.ethertype = htons(ETH_P_MACSEC);\n\n\tif (sci_present) {\n\t\tsectag.tci_an |= MACSEC_TCI_SC;\n\t\tmemcpy(&sectag.sci, &secy->sci,\n\t\t       sizeof(sectag.sci));\n\t} else {\n\t\tif (tx_sc->end_station)\n\t\t\tsectag.tci_an |= MACSEC_TCI_ES;\n\t\tif (tx_sc->scb)\n\t\t\tsectag.tci_an |= MACSEC_TCI_SCB;\n\t}\n\n\t \n\tif (tx_sc->encrypt)\n\t\tsectag.tci_an |= MACSEC_TCI_CONFID;\n\telse if (secy->icv_len != MACSEC_DEFAULT_ICV_LEN)\n\t\tsectag.tci_an |= MACSEC_TCI_C;\n\n\tsectag.tci_an |= tx_sc->encoding_sa;\n\n\t*reformat_size = MLX5_MACSEC_TAG_LEN + (sci_present ? MACSEC_SCI_LEN : 0);\n\n\tmemcpy(reformatbf, &sectag, *reformat_size);\n}\n\nstatic bool macsec_fs_is_macsec_device_empty(struct mlx5_macsec_device *macsec_device)\n{\n\tif (xa_empty(&macsec_device->tx_id_xa) &&\n\t    xa_empty(&macsec_device->rx_id_xa))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void macsec_fs_id_del(struct list_head *macsec_devices_list, u32 fs_id,\n\t\t\t     void *macdev, struct rhashtable *hash_table, bool is_tx)\n{\n\tconst struct rhashtable_params *rhash = (is_tx) ? &rhash_sci : &rhash_fs_id;\n\tstruct mlx5_macsec_device *iter, *macsec_device = NULL;\n\tstruct mlx5_fs_id *fs_id_found;\n\tstruct xarray *fs_id_xa;\n\n\tlist_for_each_entry(iter, macsec_devices_list, macsec_devices_list_entry) {\n\t\tif (iter->macdev == macdev) {\n\t\t\tmacsec_device = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tWARN_ON(!macsec_device);\n\n\tfs_id_xa = (is_tx) ? &macsec_device->tx_id_xa :\n\t\t\t     &macsec_device->rx_id_xa;\n\txa_lock(fs_id_xa);\n\tfs_id_found = xa_load(fs_id_xa, fs_id);\n\tWARN_ON(!fs_id_found);\n\n\tif (!refcount_dec_and_test(&fs_id_found->refcnt)) {\n\t\txa_unlock(fs_id_xa);\n\t\treturn;\n\t}\n\n\tif (fs_id_found->id) {\n\t\t \n\t\trhashtable_remove_fast(hash_table, &fs_id_found->hash, *rhash);\n\t\tfs_id_found->id = 0;\n\t}\n\txa_unlock(fs_id_xa);\n\n\txa_erase(fs_id_xa, fs_id);\n\n\tkfree(fs_id_found);\n\n\tif (macsec_fs_is_macsec_device_empty(macsec_device)) {\n\t\tlist_del(&macsec_device->macsec_devices_list_entry);\n\t\tkfree(macsec_device);\n\t}\n}\n\nstatic int macsec_fs_id_add(struct list_head *macsec_devices_list, u32 fs_id,\n\t\t\t    void *macdev, struct rhashtable *hash_table, sci_t sci,\n\t\t\t    bool is_tx)\n{\n\tconst struct rhashtable_params *rhash = (is_tx) ? &rhash_sci : &rhash_fs_id;\n\tstruct mlx5_macsec_device *iter, *macsec_device = NULL;\n\tstruct mlx5_fs_id *fs_id_iter;\n\tstruct xarray *fs_id_xa;\n\tint err;\n\n\tif (!is_tx) {\n\t\trcu_read_lock();\n\t\tfs_id_iter = rhashtable_lookup(hash_table, &fs_id, rhash_fs_id);\n\t\tif (fs_id_iter) {\n\t\t\trefcount_inc(&fs_id_iter->refcnt);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tfs_id_iter = kzalloc(sizeof(*fs_id_iter), GFP_KERNEL);\n\tif (!fs_id_iter)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(iter, macsec_devices_list, macsec_devices_list_entry) {\n\t\tif (iter->macdev == macdev) {\n\t\t\tmacsec_device = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!macsec_device) {  \n\t\tmacsec_device = kzalloc(sizeof(*macsec_device), GFP_KERNEL);\n\t\tif (!macsec_device) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_alloc_dev;\n\t\t}\n\t\tmacsec_device->macdev = macdev;\n\t\txa_init(&macsec_device->tx_id_xa);\n\t\txa_init(&macsec_device->rx_id_xa);\n\t\tlist_add(&macsec_device->macsec_devices_list_entry, macsec_devices_list);\n\t}\n\n\tfs_id_xa = (is_tx) ? &macsec_device->tx_id_xa :\n\t\t\t     &macsec_device->rx_id_xa;\n\tfs_id_iter->id = fs_id;\n\trefcount_set(&fs_id_iter->refcnt, 1);\n\tfs_id_iter->sci = sci;\n\terr = xa_err(xa_store(fs_id_xa, fs_id, fs_id_iter, GFP_KERNEL));\n\tif (err)\n\t\tgoto err_store_id;\n\n\terr = rhashtable_insert_fast(hash_table, &fs_id_iter->hash, *rhash);\n\tif (err)\n\t\tgoto err_hash_insert;\n\n\treturn 0;\n\nerr_hash_insert:\n\txa_erase(fs_id_xa, fs_id);\nerr_store_id:\n\tif (macsec_fs_is_macsec_device_empty(macsec_device)) {\n\t\tlist_del(&macsec_device->macsec_devices_list_entry);\n\t\tkfree(macsec_device);\n\t}\nerr_alloc_dev:\n\tkfree(fs_id_iter);\n\treturn err;\n}\n\nstatic void macsec_fs_tx_del_rule(struct mlx5_macsec_fs *macsec_fs,\n\t\t\t\t  struct mlx5_macsec_tx_rule *tx_rule,\n\t\t\t\t  void *macdev)\n{\n\tmacsec_fs_id_del(&macsec_fs->macsec_devices_list, tx_rule->fs_id, macdev,\n\t\t\t &macsec_fs->sci_hash, true);\n\n\tif (tx_rule->rule) {\n\t\tmlx5_del_flow_rules(tx_rule->rule);\n\t\ttx_rule->rule = NULL;\n\t}\n\n\tif (tx_rule->pkt_reformat) {\n\t\tmlx5_packet_reformat_dealloc(macsec_fs->mdev, tx_rule->pkt_reformat);\n\t\ttx_rule->pkt_reformat = NULL;\n\t}\n\n\tif (tx_rule->fs_id) {\n\t\tida_free(&macsec_fs->tx_fs->tx_halloc, tx_rule->fs_id);\n\t\ttx_rule->fs_id = 0;\n\t}\n\n\tkfree(tx_rule);\n\n\tmacsec_fs_tx_ft_put(macsec_fs);\n}\n\n#define MLX5_REFORMAT_PARAM_ADD_MACSEC_OFFSET_4_BYTES 1\n\nstatic union mlx5_macsec_rule *\nmacsec_fs_tx_add_rule(struct mlx5_macsec_fs *macsec_fs,\n\t\t      const struct macsec_context *macsec_ctx,\n\t\t      struct mlx5_macsec_rule_attrs *attrs, u32 *fs_id)\n{\n\tchar reformatbf[MLX5_MACSEC_TAG_LEN + MACSEC_SCI_LEN];\n\tstruct mlx5_pkt_reformat_params reformat_params = {};\n\tstruct mlx5_macsec_tx *tx_fs = macsec_fs->tx_fs;\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\tunion mlx5_macsec_rule *macsec_rule = NULL;\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_macsec_tables *tx_tables;\n\tstruct mlx5_macsec_tx_rule *tx_rule;\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tsize_t reformat_size;\n\tint err = 0;\n\n\ttx_tables = &tx_fs->tables;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn NULL;\n\n\terr = macsec_fs_tx_ft_get(macsec_fs);\n\tif (err)\n\t\tgoto out_spec;\n\n\tmacsec_rule = kzalloc(sizeof(*macsec_rule), GFP_KERNEL);\n\tif (!macsec_rule) {\n\t\tmacsec_fs_tx_ft_put(macsec_fs);\n\t\tgoto out_spec;\n\t}\n\n\ttx_rule = &macsec_rule->tx_rule;\n\n\t \n\tmacsec_fs_tx_create_sectag_header(macsec_ctx, reformatbf, &reformat_size);\n\n\treformat_params.type = MLX5_REFORMAT_TYPE_ADD_MACSEC;\n\treformat_params.size = reformat_size;\n\treformat_params.data = reformatbf;\n\n\tif (is_vlan_dev(macsec_ctx->netdev))\n\t\treformat_params.param_0 = MLX5_REFORMAT_PARAM_ADD_MACSEC_OFFSET_4_BYTES;\n\n\tflow_act.pkt_reformat = mlx5_packet_reformat_alloc(mdev,\n\t\t\t\t\t\t\t   &reformat_params,\n\t\t\t\t\t\t\t   MLX5_FLOW_NAMESPACE_EGRESS_MACSEC);\n\tif (IS_ERR(flow_act.pkt_reformat)) {\n\t\terr = PTR_ERR(flow_act.pkt_reformat);\n\t\tmlx5_core_err(mdev, \"Failed to allocate MACsec Tx reformat context err=%d\\n\",  err);\n\t\tgoto err;\n\t}\n\ttx_rule->pkt_reformat = flow_act.pkt_reformat;\n\n\terr = macsec_fs_tx_setup_fte(macsec_fs, spec, &flow_act, attrs->macsec_obj_id, fs_id);\n\tif (err) {\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to add packet reformat for MACsec TX crypto rule, err=%d\\n\",\n\t\t\t      err);\n\t\tgoto err;\n\t}\n\n\ttx_rule->fs_id = *fs_id;\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |\n\t\t\t  MLX5_FLOW_CONTEXT_ACTION_CRYPTO_ENCRYPT |\n\t\t\t  MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest.ft = tx_tables->ft_check;\n\trule = mlx5_add_flow_rules(tx_tables->ft_crypto.t, spec, &flow_act, &dest, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"Failed to add MACsec TX crypto rule, err=%d\\n\", err);\n\t\tgoto err;\n\t}\n\ttx_rule->rule = rule;\n\n\terr = macsec_fs_id_add(&macsec_fs->macsec_devices_list, *fs_id, macsec_ctx->secy->netdev,\n\t\t\t       &macsec_fs->sci_hash, attrs->sci, true);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"Failed to save fs_id, err=%d\\n\", err);\n\t\tgoto err;\n\t}\n\n\tgoto out_spec;\n\nerr:\n\tmacsec_fs_tx_del_rule(macsec_fs, tx_rule, macsec_ctx->secy->netdev);\n\tmacsec_rule = NULL;\nout_spec:\n\tkvfree(spec);\n\n\treturn macsec_rule;\n}\n\nstatic void macsec_fs_tx_cleanup(struct mlx5_macsec_fs *macsec_fs)\n{\n\tstruct mlx5_macsec_tx *tx_fs = macsec_fs->tx_fs;\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\tstruct mlx5_macsec_tables *tx_tables;\n\n\tif (!tx_fs)\n\t\treturn;\n\n\ttx_tables = &tx_fs->tables;\n\tif (tx_tables->refcnt) {\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Can't destroy MACsec offload tx_fs, refcnt(%u) isn't 0\\n\",\n\t\t\t      tx_tables->refcnt);\n\t\treturn;\n\t}\n\n\tida_destroy(&tx_fs->tx_halloc);\n\n\tif (tx_tables->check_miss_rule_counter) {\n\t\tmlx5_fc_destroy(mdev, tx_tables->check_miss_rule_counter);\n\t\ttx_tables->check_miss_rule_counter = NULL;\n\t}\n\n\tif (tx_tables->check_rule_counter) {\n\t\tmlx5_fc_destroy(mdev, tx_tables->check_rule_counter);\n\t\ttx_tables->check_rule_counter = NULL;\n\t}\n\n\tkfree(tx_fs);\n\tmacsec_fs->tx_fs = NULL;\n}\n\nstatic int macsec_fs_tx_init(struct mlx5_macsec_fs *macsec_fs)\n{\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\tstruct mlx5_macsec_tables *tx_tables;\n\tstruct mlx5_macsec_tx *tx_fs;\n\tstruct mlx5_fc *flow_counter;\n\tint err;\n\n\ttx_fs = kzalloc(sizeof(*tx_fs), GFP_KERNEL);\n\tif (!tx_fs)\n\t\treturn -ENOMEM;\n\n\ttx_tables = &tx_fs->tables;\n\n\tflow_counter = mlx5_fc_create(mdev, false);\n\tif (IS_ERR(flow_counter)) {\n\t\terr = PTR_ERR(flow_counter);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to create MACsec Tx encrypt flow counter, err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err_encrypt_counter;\n\t}\n\ttx_tables->check_rule_counter = flow_counter;\n\n\tflow_counter = mlx5_fc_create(mdev, false);\n\tif (IS_ERR(flow_counter)) {\n\t\terr = PTR_ERR(flow_counter);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to create MACsec Tx drop flow counter, err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err_drop_counter;\n\t}\n\ttx_tables->check_miss_rule_counter = flow_counter;\n\n\tida_init(&tx_fs->tx_halloc);\n\tINIT_LIST_HEAD(&macsec_fs->macsec_devices_list);\n\n\tmacsec_fs->tx_fs = tx_fs;\n\n\treturn 0;\n\nerr_drop_counter:\n\tmlx5_fc_destroy(mdev, tx_tables->check_rule_counter);\n\ttx_tables->check_rule_counter = NULL;\n\nerr_encrypt_counter:\n\tkfree(tx_fs);\n\tmacsec_fs->tx_fs = NULL;\n\n\treturn err;\n}\n\nstatic void macsec_fs_rx_roce_miss_destroy(struct mlx5_macsec_miss *miss)\n{\n\tmlx5_del_flow_rules(miss->rule);\n\tmlx5_destroy_flow_group(miss->g);\n}\n\nstatic void macsec_fs_rdma_rx_destroy(struct mlx5_macsec_rx_roce *roce, struct mlx5_core_dev *mdev)\n{\n\tif (!mlx5_is_macsec_roce_supported(mdev))\n\t\treturn;\n\n\tmlx5_del_flow_rules(roce->nic_miss.rule);\n\tmlx5_del_flow_rules(roce->rule);\n\tmlx5_modify_header_dealloc(mdev, roce->copy_modify_hdr);\n\tmlx5_destroy_flow_group(roce->nic_miss.g);\n\tmlx5_destroy_flow_group(roce->g);\n\tmlx5_destroy_flow_table(roce->ft);\n\n\tmacsec_fs_rx_roce_miss_destroy(&roce->miss);\n\tmlx5_destroy_flow_table(roce->ft_macsec_op_check);\n\tmlx5_destroy_flow_table(roce->ft_ip_check);\n}\n\nstatic void macsec_fs_rx_destroy(struct mlx5_macsec_fs *macsec_fs)\n{\n\tstruct mlx5_macsec_rx *rx_fs = macsec_fs->rx_fs;\n\tstruct mlx5_macsec_tables *rx_tables;\n\tint i;\n\n\t \n\tfor (i = 1; i >= 0; --i) {\n\t\tif (rx_fs->check_rule[i]) {\n\t\t\tmlx5_del_flow_rules(rx_fs->check_rule[i]);\n\t\t\trx_fs->check_rule[i] = NULL;\n\t\t}\n\n\t\tif (rx_fs->check_rule_pkt_reformat[i]) {\n\t\t\tmlx5_packet_reformat_dealloc(macsec_fs->mdev,\n\t\t\t\t\t\t     rx_fs->check_rule_pkt_reformat[i]);\n\t\t\trx_fs->check_rule_pkt_reformat[i] = NULL;\n\t\t}\n\t}\n\n\trx_tables = &rx_fs->tables;\n\n\tif (rx_tables->check_miss_rule) {\n\t\tmlx5_del_flow_rules(rx_tables->check_miss_rule);\n\t\trx_tables->check_miss_rule = NULL;\n\t}\n\n\tif (rx_tables->ft_check_group) {\n\t\tmlx5_destroy_flow_group(rx_tables->ft_check_group);\n\t\trx_tables->ft_check_group = NULL;\n\t}\n\n\tif (rx_tables->ft_check) {\n\t\tmlx5_destroy_flow_table(rx_tables->ft_check);\n\t\trx_tables->ft_check = NULL;\n\t}\n\n\t \n\tif (rx_tables->crypto_miss_rule) {\n\t\tmlx5_del_flow_rules(rx_tables->crypto_miss_rule);\n\t\trx_tables->crypto_miss_rule = NULL;\n\t}\n\n\tmacsec_fs_destroy_flow_table(&rx_tables->ft_crypto);\n\n\tmacsec_fs_rdma_rx_destroy(&macsec_fs->rx_fs->roce, macsec_fs->mdev);\n}\n\nstatic int macsec_fs_rx_create_crypto_table_groups(struct mlx5_macsec_flow_table *ft)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tint mclen = MLX5_ST_SZ_BYTES(fte_match_param);\n\tint ix = 0;\n\tu32 *in;\n\tint err;\n\tu8 *mc;\n\n\tft->g = kcalloc(RX_CRYPTO_TABLE_NUM_GROUPS, sizeof(*ft->g), GFP_KERNEL);\n\tif (!ft->g)\n\t\treturn -ENOMEM;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\tkfree(ft->g);\n\t\treturn -ENOMEM;\n\t}\n\n\tmc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\n\t \n\tMLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS |\n\t\t\t\t\t\tMLX5_MATCH_MISC_PARAMETERS_5);\n\tMLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.ethertype);\n\n\tMLX5_SET(fte_match_param, mc, misc_parameters_5.macsec_tag_0,\n\t\t MLX5_MACSEC_SECTAG_TCI_AN_FIELD_BITMASK <<\n\t\t MLX5_MACSEC_SECTAG_TCI_AN_FIELD_OFFSET);\n\tMLX5_SET_TO_ONES(fte_match_param, mc, misc_parameters_5.macsec_tag_2);\n\tMLX5_SET_TO_ONES(fte_match_param, mc, misc_parameters_5.macsec_tag_3);\n\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += RX_CRYPTO_TABLE_SA_RULE_WITH_SCI_GROUP_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);\n\tif (IS_ERR(ft->g[ft->num_groups]))\n\t\tgoto err;\n\tft->num_groups++;\n\n\t \n\tmemset(in, 0, inlen);\n\tmemset(mc, 0, mclen);\n\tMLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS |\n\t\t\t\t\t\tMLX5_MATCH_MISC_PARAMETERS_5);\n\tMLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.smac_47_16);\n\tMLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.smac_15_0);\n\tMLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.ethertype);\n\n\tMLX5_SET(fte_match_param, mc, misc_parameters_5.macsec_tag_0,\n\t\t MLX5_MACSEC_SECTAG_TCI_AN_FIELD_BITMASK << MLX5_MACSEC_SECTAG_TCI_AN_FIELD_OFFSET);\n\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += RX_CRYPTO_TABLE_SA_RULE_WITHOUT_SCI_GROUP_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);\n\tif (IS_ERR(ft->g[ft->num_groups]))\n\t\tgoto err;\n\tft->num_groups++;\n\n\t \n\tmemset(in, 0, inlen);\n\tmemset(mc, 0, mclen);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += CRYPTO_TABLE_DEFAULT_RULE_GROUP_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);\n\tif (IS_ERR(ft->g[ft->num_groups]))\n\t\tgoto err;\n\tft->num_groups++;\n\n\tkvfree(in);\n\treturn 0;\n\nerr:\n\terr = PTR_ERR(ft->g[ft->num_groups]);\n\tft->g[ft->num_groups] = NULL;\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic int macsec_fs_rx_create_check_decap_rule(struct mlx5_macsec_fs *macsec_fs,\n\t\t\t\t\t\tstruct mlx5_flow_destination *dest,\n\t\t\t\t\t\tstruct mlx5_flow_act *flow_act,\n\t\t\t\t\t\tstruct mlx5_flow_spec *spec,\n\t\t\t\t\t\tint reformat_param_size)\n{\n\tint rule_index = (reformat_param_size == MLX5_SECTAG_HEADER_SIZE_WITH_SCI) ? 0 : 1;\n\tu8 mlx5_reformat_buf[MLX5_SECTAG_HEADER_SIZE_WITH_SCI];\n\tstruct mlx5_pkt_reformat_params reformat_params = {};\n\tstruct mlx5_macsec_rx *rx_fs = macsec_fs->rx_fs;\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\tstruct mlx5_flow_destination roce_dest[2];\n\tstruct mlx5_macsec_tables *rx_tables;\n\tstruct mlx5_flow_handle *rule;\n\tint err = 0, dstn = 0;\n\n\trx_tables = &rx_fs->tables;\n\n\t \n\tmemset(dest, 0, sizeof(*dest));\n\tmemset(flow_act, 0, sizeof(*flow_act));\n\tmemset(spec, 0, sizeof(*spec));\n\n\treformat_params.type = MLX5_REFORMAT_TYPE_DEL_MACSEC;\n\treformat_params.size = reformat_param_size;\n\treformat_params.data = mlx5_reformat_buf;\n\tflow_act->pkt_reformat = mlx5_packet_reformat_alloc(mdev,\n\t\t\t\t\t\t\t    &reformat_params,\n\t\t\t\t\t\t\t    MLX5_FLOW_NAMESPACE_KERNEL_RX_MACSEC);\n\tif (IS_ERR(flow_act->pkt_reformat)) {\n\t\terr = PTR_ERR(flow_act->pkt_reformat);\n\t\tmlx5_core_err(mdev, \"Failed to allocate MACsec Rx reformat context err=%d\\n\", err);\n\t\treturn err;\n\t}\n\trx_fs->check_rule_pkt_reformat[rule_index] = flow_act->pkt_reformat;\n\n\tspec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS_2;\n\t \n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, misc_parameters_2.macsec_syndrome);\n\tMLX5_SET(fte_match_param, spec->match_value, misc_parameters_2.macsec_syndrome, 0);\n\t \n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, misc_parameters_2.metadata_reg_c_4);\n\tMLX5_SET(fte_match_param, spec->match_value, misc_parameters_2.metadata_reg_c_4, 0);\n\n\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_5;\n\t \n\tMLX5_SET(fte_match_param, spec->match_criteria, misc_parameters_5.macsec_tag_0,\n\t\t MLX5_MACSEC_SECTAG_TCI_SC_FIELD_BIT << MLX5_MACSEC_SECTAG_TCI_AN_FIELD_OFFSET);\n\n\tif (reformat_param_size == MLX5_SECTAG_HEADER_SIZE_WITH_SCI)\n\t\tMLX5_SET(fte_match_param, spec->match_value, misc_parameters_5.macsec_tag_0,\n\t\t\t MLX5_MACSEC_SECTAG_TCI_SC_FIELD_BIT <<\n\t\t\t MLX5_MACSEC_SECTAG_TCI_AN_FIELD_OFFSET);\n\n\tflow_act->flags = FLOW_ACT_NO_APPEND;\n\n\tif (rx_fs->roce.ft) {\n\t\tflow_act->action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\t\troce_dest[dstn].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\t\troce_dest[dstn].ft = rx_fs->roce.ft;\n\t\tdstn++;\n\t} else {\n\t\tflow_act->action = MLX5_FLOW_CONTEXT_ACTION_FWD_NEXT_PRIO;\n\t}\n\n\tflow_act->action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT |\n\t\t\t    MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\troce_dest[dstn].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\troce_dest[dstn].counter_id = mlx5_fc_id(rx_tables->check_rule_counter);\n\trule = mlx5_add_flow_rules(rx_tables->ft_check, spec, flow_act, roce_dest, dstn + 1);\n\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"Failed to add MACsec Rx check rule, err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\trx_fs->check_rule[rule_index] = rule;\n\n\treturn 0;\n}\n\nstatic int macsec_fs_rx_roce_miss_create(struct mlx5_core_dev *mdev,\n\t\t\t\t\t struct mlx5_macsec_rx_roce *roce)\n{\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_group *flow_group;\n\tstruct mlx5_flow_handle *rule;\n\tu32 *flow_group_in;\n\tint err;\n\n\tflow_group_in = kvzalloc(MLX5_ST_SZ_BYTES(create_flow_group_in), GFP_KERNEL);\n\tif (!flow_group_in)\n\t\treturn -ENOMEM;\n\n\t \n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index,\n\t\t roce->ft_macsec_op_check->max_fte - 1);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index,\n\t\t roce->ft_macsec_op_check->max_fte - 1);\n\tflow_group = mlx5_create_flow_group(roce->ft_macsec_op_check, flow_group_in);\n\tif (IS_ERR(flow_group)) {\n\t\terr = PTR_ERR(flow_group);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to create miss flow group for MACsec RoCE operation check table err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err_macsec_op_miss_group;\n\t}\n\troce->miss.g = flow_group;\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_DROP;\n\trule = mlx5_add_flow_rules(roce->ft_macsec_op_check,  NULL, &flow_act, NULL, 0);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"Failed to add miss rule to MACsec RoCE operation check table err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err_macsec_op_rule;\n\t}\n\troce->miss.rule = rule;\n\n\tkvfree(flow_group_in);\n\treturn 0;\n\nerr_macsec_op_rule:\n\tmlx5_destroy_flow_group(roce->miss.g);\nerr_macsec_op_miss_group:\n\tkvfree(flow_group_in);\n\treturn err;\n}\n\n#define MLX5_RX_ROCE_GROUP_SIZE BIT(0)\n\nstatic int macsec_fs_rx_roce_jump_to_rdma_groups_create(struct mlx5_core_dev *mdev,\n\t\t\t\t\t\t\tstruct mlx5_macsec_rx_roce *roce)\n{\n\tstruct mlx5_flow_group *g;\n\tvoid *outer_headers_c;\n\tint ix = 0;\n\tu32 *in;\n\tint err;\n\tu8 *mc;\n\n\tin = kvzalloc(MLX5_ST_SZ_BYTES(create_flow_group_in), GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tmc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\touter_headers_c = MLX5_ADDR_OF(fte_match_param, mc, outer_headers);\n\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, ip_protocol);\n\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, udp_dport);\n\n\tMLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5_RX_ROCE_GROUP_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tg = mlx5_create_flow_group(roce->ft, in);\n\tif (IS_ERR(g)) {\n\t\terr = PTR_ERR(g);\n\t\tmlx5_core_err(mdev, \"Failed to create main flow group for MACsec RoCE NIC UDP table err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err_udp_group;\n\t}\n\troce->g = g;\n\n\tmemset(in, 0, MLX5_ST_SZ_BYTES(create_flow_group_in));\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5_RX_ROCE_GROUP_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tg = mlx5_create_flow_group(roce->ft, in);\n\tif (IS_ERR(g)) {\n\t\terr = PTR_ERR(g);\n\t\tmlx5_core_err(mdev, \"Failed to create miss flow group for MACsec RoCE NIC UDP table err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err_udp_miss_group;\n\t}\n\troce->nic_miss.g = g;\n\n\tkvfree(in);\n\treturn 0;\n\nerr_udp_miss_group:\n\tmlx5_destroy_flow_group(roce->g);\nerr_udp_group:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int macsec_fs_rx_roce_jump_to_rdma_rules_create(struct mlx5_macsec_fs *macsec_fs,\n\t\t\t\t\t\t       struct mlx5_macsec_rx_roce *roce)\n{\n\tu8 action[MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto)] = {};\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\tstruct mlx5_flow_destination dst = {};\n\tstruct mlx5_modify_hdr *modify_hdr;\n\tMLX5_DECLARE_FLOW_ACT(flow_act);\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tint err;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\tspec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_protocol);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_protocol, IPPROTO_UDP);\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.udp_dport);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.udp_dport, ROCE_V2_UDP_DPORT);\n\n\tMLX5_SET(copy_action_in, action, action_type, MLX5_ACTION_TYPE_COPY);\n\tMLX5_SET(copy_action_in, action, src_field, MLX5_ACTION_IN_FIELD_METADATA_REG_B);\n\tMLX5_SET(copy_action_in, action, src_offset, 0);\n\tMLX5_SET(copy_action_in, action, length, 32);\n\tMLX5_SET(copy_action_in, action, dst_field, MLX5_ACTION_IN_FIELD_METADATA_REG_C_5);\n\tMLX5_SET(copy_action_in, action, dst_offset, 0);\n\n\tmodify_hdr = mlx5_modify_header_alloc(macsec_fs->mdev, MLX5_FLOW_NAMESPACE_KERNEL_RX_MACSEC,\n\t\t\t\t\t      1, action);\n\n\tif (IS_ERR(modify_hdr)) {\n\t\terr = PTR_ERR(modify_hdr);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to alloc macsec copy modify_header_id err(%d)\\n\", err);\n\t\tgoto err_alloc_hdr;\n\t}\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_MOD_HDR | MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tflow_act.modify_hdr = modify_hdr;\n\tdst.type = MLX5_FLOW_DESTINATION_TYPE_TABLE_TYPE;\n\tdst.ft = roce->ft_ip_check;\n\trule = mlx5_add_flow_rules(roce->ft, spec, &flow_act, &dst, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"Failed to add rule to MACsec RoCE NIC UDP table err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err_add_rule;\n\t}\n\troce->rule = rule;\n\troce->copy_modify_hdr = modify_hdr;\n\n\tmemset(&flow_act, 0, sizeof(flow_act));\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_NEXT_PRIO;\n\trule = mlx5_add_flow_rules(roce->ft, NULL, &flow_act, NULL, 0);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"Failed to add miss rule to MACsec RoCE NIC UDP table err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err_add_rule2;\n\t}\n\troce->nic_miss.rule = rule;\n\n\tkvfree(spec);\n\treturn 0;\n\nerr_add_rule2:\n\tmlx5_del_flow_rules(roce->rule);\nerr_add_rule:\n\tmlx5_modify_header_dealloc(macsec_fs->mdev, modify_hdr);\nerr_alloc_hdr:\n\tkvfree(spec);\n\treturn err;\n}\n\nstatic int macsec_fs_rx_roce_jump_to_rdma_create(struct mlx5_macsec_fs *macsec_fs,\n\t\t\t\t\t\t struct mlx5_macsec_rx_roce *roce)\n{\n\tint err;\n\n\terr = macsec_fs_rx_roce_jump_to_rdma_groups_create(macsec_fs->mdev, roce);\n\tif (err)\n\t\treturn err;\n\n\terr = macsec_fs_rx_roce_jump_to_rdma_rules_create(macsec_fs, roce);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tmlx5_destroy_flow_group(roce->nic_miss.g);\n\tmlx5_destroy_flow_group(roce->g);\n\treturn err;\n}\n\nstatic int macsec_fs_rx_roce_create(struct mlx5_macsec_fs *macsec_fs)\n{\n\tstruct mlx5_macsec_rx *rx_fs = macsec_fs->rx_fs;\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_flow_namespace *ns;\n\tstruct mlx5_flow_table *ft;\n\tint err = 0;\n\n\tif (!mlx5_is_macsec_roce_supported(macsec_fs->mdev)) {\n\t\tmlx5_core_dbg(mdev, \"Failed to init RoCE MACsec, capabilities not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tns = mlx5_get_flow_namespace(macsec_fs->mdev, MLX5_FLOW_NAMESPACE_RDMA_RX_MACSEC);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\n\tft = macsec_fs_auto_group_table_create(ns, 0, RDMA_RX_ROCE_IP_TABLE_LEVEL,\n\t\t\t\t\t       CRYPTO_NUM_MAXSEC_FTE);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to create MACsec IP check RoCE table err(%d)\\n\", err);\n\t\treturn err;\n\t}\n\trx_fs->roce.ft_ip_check = ft;\n\n\tft = macsec_fs_auto_group_table_create(ns, 0, RDMA_RX_ROCE_MACSEC_OP_TABLE_LEVEL,\n\t\t\t\t\t       CRYPTO_NUM_MAXSEC_FTE);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to create MACsec operation check RoCE table err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err_macsec_op;\n\t}\n\trx_fs->roce.ft_macsec_op_check = ft;\n\n\terr = macsec_fs_rx_roce_miss_create(mdev, &rx_fs->roce);\n\tif (err)\n\t\tgoto err_miss_create;\n\n\tns = mlx5_get_flow_namespace(macsec_fs->mdev, MLX5_FLOW_NAMESPACE_KERNEL_RX_MACSEC);\n\tif (!ns) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_ns;\n\t}\n\n\tft_attr.level = RX_ROCE_TABLE_LEVEL;\n\tft_attr.max_fte = RX_ROCE_TABLE_NUM_FTE;\n\tft = mlx5_create_flow_table(ns, &ft_attr);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to create MACsec jump to RX RoCE, NIC table err(%d)\\n\", err);\n\t\tgoto err_ns;\n\t}\n\trx_fs->roce.ft = ft;\n\n\terr = macsec_fs_rx_roce_jump_to_rdma_create(macsec_fs, &rx_fs->roce);\n\tif (err)\n\t\tgoto err_udp_ft;\n\n\treturn 0;\n\nerr_udp_ft:\n\tmlx5_destroy_flow_table(rx_fs->roce.ft);\nerr_ns:\n\tmacsec_fs_rx_roce_miss_destroy(&rx_fs->roce.miss);\nerr_miss_create:\n\tmlx5_destroy_flow_table(rx_fs->roce.ft_macsec_op_check);\nerr_macsec_op:\n\tmlx5_destroy_flow_table(rx_fs->roce.ft_ip_check);\n\treturn err;\n}\n\nstatic int macsec_fs_rx_create(struct mlx5_macsec_fs *macsec_fs)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_macsec_rx *rx_fs = macsec_fs->rx_fs;\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\tstruct mlx5_macsec_flow_table *ft_crypto;\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_macsec_tables *rx_tables;\n\tstruct mlx5_flow_table *flow_table;\n\tstruct mlx5_flow_group *flow_group;\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_namespace *ns;\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tu32 *flow_group_in;\n\tint err;\n\n\tns = mlx5_get_flow_namespace(mdev, MLX5_FLOW_NAMESPACE_KERNEL_RX_MACSEC);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tif (!flow_group_in) {\n\t\terr = -ENOMEM;\n\t\tgoto free_spec;\n\t}\n\n\trx_tables = &rx_fs->tables;\n\tft_crypto = &rx_tables->ft_crypto;\n\n\terr = macsec_fs_rx_roce_create(macsec_fs);\n\tif (err)\n\t\tgoto out_flow_group;\n\n\t \n\tft_attr.level = RX_CRYPTO_TABLE_LEVEL;\n\tft_attr.max_fte = CRYPTO_NUM_MAXSEC_FTE;\n\n\tflow_table = mlx5_create_flow_table(ns, &ft_attr);\n\tif (IS_ERR(flow_table)) {\n\t\terr = PTR_ERR(flow_table);\n\t\tmlx5_core_err(mdev, \"Failed to create MACsec Rx crypto table err(%d)\\n\", err);\n\t\tgoto err;\n\t}\n\tft_crypto->t = flow_table;\n\n\t \n\terr = macsec_fs_rx_create_crypto_table_groups(ft_crypto);\n\tif (err) {\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to create default flow group for MACsec Tx crypto table err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err;\n\t}\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_NEXT_PRIO;\n\trule = mlx5_add_flow_rules(ft_crypto->t, NULL, &flow_act, NULL, 0);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to add MACsec Rx crypto table default miss rule %d\\n\",\n\t\t\t      err);\n\t\tgoto err;\n\t}\n\trx_tables->crypto_miss_rule = rule;\n\n\t \n\tflow_table = macsec_fs_auto_group_table_create(ns,\n\t\t\t\t\t\t       MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT,\n\t\t\t\t\t\t       RX_CHECK_TABLE_LEVEL,\n\t\t\t\t\t\t       RX_CHECK_TABLE_NUM_FTE);\n\tif (IS_ERR(flow_table)) {\n\t\terr = PTR_ERR(flow_table);\n\t\tmlx5_core_err(mdev, \"Fail to create MACsec RX check table, err(%d)\\n\", err);\n\t\tgoto err;\n\t}\n\trx_tables->ft_check = flow_table;\n\n\t \n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, flow_table->max_fte - 1);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, flow_table->max_fte - 1);\n\tflow_group = mlx5_create_flow_group(rx_tables->ft_check, flow_group_in);\n\tif (IS_ERR(flow_group)) {\n\t\terr = PTR_ERR(flow_group);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to create default flow group for MACsec Rx check table err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err;\n\t}\n\trx_tables->ft_check_group = flow_group;\n\n\t \n\tmemset(&flow_act, 0, sizeof(flow_act));\n\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\tdest.counter_id = mlx5_fc_id(rx_tables->check_miss_rule_counter);\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_DROP | MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\trule = mlx5_add_flow_rules(rx_tables->ft_check,  NULL, &flow_act, &dest, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev, \"Failed to added MACsec Rx check drop rule, err(%d)\\n\", err);\n\t\tgoto err;\n\t}\n\trx_tables->check_miss_rule = rule;\n\n\t \n\terr = macsec_fs_rx_create_check_decap_rule(macsec_fs, &dest, &flow_act, spec,\n\t\t\t\t\t\t   MLX5_SECTAG_HEADER_SIZE_WITH_SCI);\n\tif (err)\n\t\tgoto err;\n\n\terr = macsec_fs_rx_create_check_decap_rule(macsec_fs, &dest, &flow_act, spec,\n\t\t\t\t\t\t   MLX5_SECTAG_HEADER_SIZE_WITHOUT_SCI);\n\tif (err)\n\t\tgoto err;\n\n\tgoto out_flow_group;\n\nerr:\n\tmacsec_fs_rx_destroy(macsec_fs);\nout_flow_group:\n\tkvfree(flow_group_in);\nfree_spec:\n\tkvfree(spec);\n\treturn err;\n}\n\nstatic int macsec_fs_rx_ft_get(struct mlx5_macsec_fs *macsec_fs)\n{\n\tstruct mlx5_macsec_tables *rx_tables = &macsec_fs->rx_fs->tables;\n\tint err = 0;\n\n\tif (rx_tables->refcnt)\n\t\tgoto out;\n\n\terr = macsec_fs_rx_create(macsec_fs);\n\tif (err)\n\t\treturn err;\n\nout:\n\trx_tables->refcnt++;\n\treturn err;\n}\n\nstatic void macsec_fs_rx_ft_put(struct mlx5_macsec_fs *macsec_fs)\n{\n\tstruct mlx5_macsec_tables *rx_tables = &macsec_fs->rx_fs->tables;\n\n\tif (--rx_tables->refcnt)\n\t\treturn;\n\n\tmacsec_fs_rx_destroy(macsec_fs);\n}\n\nstatic void macsec_fs_rx_del_rule(struct mlx5_macsec_fs *macsec_fs,\n\t\t\t\t  struct mlx5_macsec_rx_rule *rx_rule,\n\t\t\t\t  void *macdev, u32 fs_id)\n{\n\tint i;\n\n\tmacsec_fs_id_del(&macsec_fs->macsec_devices_list, fs_id, macdev,\n\t\t\t &macsec_fs->fs_id_hash, false);\n\n\tfor (i = 0; i < RX_NUM_OF_RULES_PER_SA; ++i) {\n\t\tif (rx_rule->rule[i]) {\n\t\t\tmlx5_del_flow_rules(rx_rule->rule[i]);\n\t\t\trx_rule->rule[i] = NULL;\n\t\t}\n\t}\n\n\tif (rx_rule->meta_modhdr) {\n\t\tmlx5_modify_header_dealloc(macsec_fs->mdev, rx_rule->meta_modhdr);\n\t\trx_rule->meta_modhdr = NULL;\n\t}\n\n\tkfree(rx_rule);\n\n\tmacsec_fs_rx_ft_put(macsec_fs);\n}\n\nstatic void macsec_fs_rx_setup_fte(struct mlx5_flow_spec *spec,\n\t\t\t\t   struct mlx5_flow_act *flow_act,\n\t\t\t\t   struct mlx5_macsec_rule_attrs *attrs,\n\t\t\t\t   bool sci_present)\n{\n\tu8 tci_an = (sci_present << MLX5_MACSEC_SECTAG_TCI_SC_FIELD_OFFSET) | attrs->assoc_num;\n\tstruct mlx5_flow_act_crypto_params *crypto_params = &flow_act->crypto;\n\t__be32 *sci_p = (__be32 *)(&attrs->sci);\n\n\tspec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\n\t \n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ethertype);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ethertype, ETH_P_MACSEC);\n\n\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_5;\n\n\t \n\tMLX5_SET(fte_match_param, spec->match_criteria, misc_parameters_5.macsec_tag_0,\n\t\t MLX5_MACSEC_SECTAG_TCI_AN_FIELD_BITMASK << MLX5_MACSEC_SECTAG_TCI_AN_FIELD_OFFSET);\n\tMLX5_SET(fte_match_param, spec->match_value, misc_parameters_5.macsec_tag_0,\n\t\t tci_an << MLX5_MACSEC_SECTAG_TCI_AN_FIELD_OFFSET);\n\n\tif (sci_present) {\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t misc_parameters_5.macsec_tag_2);\n\t\tMLX5_SET(fte_match_param, spec->match_value, misc_parameters_5.macsec_tag_2,\n\t\t\t be32_to_cpu(sci_p[0]));\n\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t misc_parameters_5.macsec_tag_3);\n\t\tMLX5_SET(fte_match_param, spec->match_value, misc_parameters_5.macsec_tag_3,\n\t\t\t be32_to_cpu(sci_p[1]));\n\t} else {\n\t\t \n\t\t \n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.smac_47_16);\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.smac_15_0);\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value, outer_headers.smac_47_16),\n\t\t       sci_p, ETH_ALEN);\n\t}\n\n\tcrypto_params->type = MLX5_FLOW_CONTEXT_ENCRYPT_DECRYPT_TYPE_MACSEC;\n\tcrypto_params->obj_id = attrs->macsec_obj_id;\n}\n\nstatic union mlx5_macsec_rule *\nmacsec_fs_rx_add_rule(struct mlx5_macsec_fs *macsec_fs,\n\t\t      const struct macsec_context *macsec_ctx,\n\t\t      struct mlx5_macsec_rule_attrs *attrs,\n\t\t      u32 fs_id)\n{\n\tu8 action[MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto)] = {};\n\tstruct mlx5_macsec_rx *rx_fs = macsec_fs->rx_fs;\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\tunion mlx5_macsec_rule *macsec_rule = NULL;\n\tstruct mlx5_modify_hdr *modify_hdr = NULL;\n\tstruct mlx5_macsec_flow_table *ft_crypto;\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_macsec_tables *rx_tables;\n\tstruct mlx5_macsec_rx_rule *rx_rule;\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *rule;\n\tstruct mlx5_flow_spec *spec;\n\tint err = 0;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn NULL;\n\n\terr = macsec_fs_rx_ft_get(macsec_fs);\n\tif (err)\n\t\tgoto out_spec;\n\n\tmacsec_rule = kzalloc(sizeof(*macsec_rule), GFP_KERNEL);\n\tif (!macsec_rule) {\n\t\tmacsec_fs_rx_ft_put(macsec_fs);\n\t\tgoto out_spec;\n\t}\n\n\trx_rule = &macsec_rule->rx_rule;\n\trx_tables = &rx_fs->tables;\n\tft_crypto = &rx_tables->ft_crypto;\n\n\t \n\t \n\tMLX5_SET(set_action_in, action, action_type, MLX5_ACTION_TYPE_SET);\n\tMLX5_SET(set_action_in, action, field, MLX5_ACTION_IN_FIELD_METADATA_REG_B);\n\tMLX5_SET(set_action_in, action, data, macsec_fs_set_rx_fs_id(fs_id));\n\tMLX5_SET(set_action_in, action, offset, 0);\n\tMLX5_SET(set_action_in, action, length, 32);\n\n\tmodify_hdr = mlx5_modify_header_alloc(mdev, MLX5_FLOW_NAMESPACE_KERNEL_RX_MACSEC,\n\t\t\t\t\t      1, action);\n\tif (IS_ERR(modify_hdr)) {\n\t\terr = PTR_ERR(modify_hdr);\n\t\tmlx5_core_err(mdev, \"Fail to alloc MACsec set modify_header_id err=%d\\n\", err);\n\t\tmodify_hdr = NULL;\n\t\tgoto err;\n\t}\n\trx_rule->meta_modhdr = modify_hdr;\n\n\t \n\tmacsec_fs_rx_setup_fte(spec, &flow_act, attrs, true);\n\n\tflow_act.modify_hdr = modify_hdr;\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |\n\t\t\t  MLX5_FLOW_CONTEXT_ACTION_CRYPTO_DECRYPT |\n\t\t\t  MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest.ft = rx_tables->ft_check;\n\trule = mlx5_add_flow_rules(ft_crypto->t, spec, &flow_act, &dest, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to add SA with SCI rule to Rx crypto rule, err=%d\\n\",\n\t\t\t      err);\n\t\tgoto err;\n\t}\n\trx_rule->rule[0] = rule;\n\n\t \n\tif ((cpu_to_be64((__force u64)attrs->sci) & 0xFFFF) == ntohs(MACSEC_PORT_ES)) {\n\t\tmemset(spec, 0, sizeof(struct mlx5_flow_spec));\n\t\tmemset(&dest, 0, sizeof(struct mlx5_flow_destination));\n\t\tmemset(&flow_act, 0, sizeof(flow_act));\n\n\t\tmacsec_fs_rx_setup_fte(spec, &flow_act, attrs, false);\n\n\t\tflow_act.modify_hdr = modify_hdr;\n\t\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |\n\t\t\t\t  MLX5_FLOW_CONTEXT_ACTION_CRYPTO_DECRYPT |\n\t\t\t\t  MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\n\t\tdest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\t\tdest.ft = rx_tables->ft_check;\n\t\trule = mlx5_add_flow_rules(ft_crypto->t, spec, &flow_act, &dest, 1);\n\t\tif (IS_ERR(rule)) {\n\t\t\terr = PTR_ERR(rule);\n\t\t\tmlx5_core_err(mdev,\n\t\t\t\t      \"Failed to add SA without SCI rule to Rx crypto rule, err=%d\\n\",\n\t\t\t\t      err);\n\t\t\tgoto err;\n\t\t}\n\t\trx_rule->rule[1] = rule;\n\t}\n\n\terr = macsec_fs_id_add(&macsec_fs->macsec_devices_list, fs_id, macsec_ctx->secy->netdev,\n\t\t\t       &macsec_fs->fs_id_hash, attrs->sci, false);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"Failed to save fs_id, err=%d\\n\", err);\n\t\tgoto err;\n\t}\n\n\tkvfree(spec);\n\treturn macsec_rule;\n\nerr:\n\tmacsec_fs_rx_del_rule(macsec_fs, rx_rule, macsec_ctx->secy->netdev, fs_id);\n\tmacsec_rule = NULL;\nout_spec:\n\tkvfree(spec);\n\treturn macsec_rule;\n}\n\nstatic int macsec_fs_rx_init(struct mlx5_macsec_fs *macsec_fs)\n{\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\tstruct mlx5_macsec_tables *rx_tables;\n\tstruct mlx5_macsec_rx *rx_fs;\n\tstruct mlx5_fc *flow_counter;\n\tint err;\n\n\trx_fs =\tkzalloc(sizeof(*rx_fs), GFP_KERNEL);\n\tif (!rx_fs)\n\t\treturn -ENOMEM;\n\n\tflow_counter = mlx5_fc_create(mdev, false);\n\tif (IS_ERR(flow_counter)) {\n\t\terr = PTR_ERR(flow_counter);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to create MACsec Rx encrypt flow counter, err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err_encrypt_counter;\n\t}\n\n\trx_tables = &rx_fs->tables;\n\trx_tables->check_rule_counter = flow_counter;\n\n\tflow_counter = mlx5_fc_create(mdev, false);\n\tif (IS_ERR(flow_counter)) {\n\t\terr = PTR_ERR(flow_counter);\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Failed to create MACsec Rx drop flow counter, err(%d)\\n\",\n\t\t\t      err);\n\t\tgoto err_drop_counter;\n\t}\n\trx_tables->check_miss_rule_counter = flow_counter;\n\n\tmacsec_fs->rx_fs = rx_fs;\n\n\treturn 0;\n\nerr_drop_counter:\n\tmlx5_fc_destroy(mdev, rx_tables->check_rule_counter);\n\trx_tables->check_rule_counter = NULL;\n\nerr_encrypt_counter:\n\tkfree(rx_fs);\n\tmacsec_fs->rx_fs = NULL;\n\n\treturn err;\n}\n\nstatic void macsec_fs_rx_cleanup(struct mlx5_macsec_fs *macsec_fs)\n{\n\tstruct mlx5_macsec_rx *rx_fs = macsec_fs->rx_fs;\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\tstruct mlx5_macsec_tables *rx_tables;\n\n\tif (!rx_fs)\n\t\treturn;\n\n\trx_tables = &rx_fs->tables;\n\n\tif (rx_tables->refcnt) {\n\t\tmlx5_core_err(mdev,\n\t\t\t      \"Can't destroy MACsec offload rx_fs, refcnt(%u) isn't 0\\n\",\n\t\t\t      rx_tables->refcnt);\n\t\treturn;\n\t}\n\n\tif (rx_tables->check_miss_rule_counter) {\n\t\tmlx5_fc_destroy(mdev, rx_tables->check_miss_rule_counter);\n\t\trx_tables->check_miss_rule_counter = NULL;\n\t}\n\n\tif (rx_tables->check_rule_counter) {\n\t\tmlx5_fc_destroy(mdev, rx_tables->check_rule_counter);\n\t\trx_tables->check_rule_counter = NULL;\n\t}\n\n\tkfree(rx_fs);\n\tmacsec_fs->rx_fs = NULL;\n}\n\nstatic void set_ipaddr_spec_v4(struct sockaddr_in *in, struct mlx5_flow_spec *spec, bool is_dst_ip)\n{\n\tMLX5_SET(fte_match_param, spec->match_value,\n\t\t outer_headers.ip_version, MLX5_FS_IPV4_VERSION);\n\n\tif (is_dst_ip) {\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t outer_headers.dst_ipv4_dst_ipv6.ipv4_layout.ipv4);\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    outer_headers.dst_ipv4_dst_ipv6.ipv4_layout.ipv4),\n\t\t       &in->sin_addr.s_addr, 4);\n\t} else {\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t outer_headers.src_ipv4_src_ipv6.ipv4_layout.ipv4);\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    outer_headers.src_ipv4_src_ipv6.ipv4_layout.ipv4),\n\t\t       &in->sin_addr.s_addr, 4);\n\t}\n}\n\nstatic void set_ipaddr_spec_v6(struct sockaddr_in6 *in6, struct mlx5_flow_spec *spec,\n\t\t\t       bool is_dst_ip)\n{\n\tMLX5_SET(fte_match_param, spec->match_value,\n\t\t outer_headers.ip_version, MLX5_FS_IPV6_VERSION);\n\n\tif (is_dst_ip) {\n\t\tmemset(MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t\t    outer_headers.dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t       0xff, 16);\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    outer_headers.dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t       &in6->sin6_addr, 16);\n\t} else {\n\t\tmemset(MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t\t    outer_headers.src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t       0xff, 16);\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    outer_headers.src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t       &in6->sin6_addr, 16);\n\t}\n}\n\nstatic void set_ipaddr_spec(const struct sockaddr *addr,\n\t\t\t    struct mlx5_flow_spec *spec, bool is_dst_ip)\n{\n\tstruct sockaddr_in6 *in6;\n\n\tspec->match_criteria_enable |= MLX5_MATCH_OUTER_HEADERS;\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t outer_headers.ip_version);\n\n\tif (addr->sa_family == AF_INET) {\n\t\tstruct sockaddr_in *in = (struct sockaddr_in *)addr;\n\n\t\tset_ipaddr_spec_v4(in, spec, is_dst_ip);\n\t\treturn;\n\t}\n\n\tin6 = (struct sockaddr_in6 *)addr;\n\tset_ipaddr_spec_v6(in6, spec, is_dst_ip);\n}\n\nstatic void macsec_fs_del_roce_rule_rx(struct mlx5_roce_macsec_rx_rule *rx_rule)\n{\n\tmlx5_del_flow_rules(rx_rule->op);\n\tmlx5_del_flow_rules(rx_rule->ip);\n\tlist_del(&rx_rule->entry);\n\tkfree(rx_rule);\n}\n\nstatic void macsec_fs_del_roce_rules_rx(struct mlx5_macsec_fs *macsec_fs, u32 fs_id,\n\t\t\t\t\tstruct list_head *rx_rules_list)\n{\n\tstruct mlx5_roce_macsec_rx_rule *rx_rule, *next;\n\n\tif (!mlx5_is_macsec_roce_supported(macsec_fs->mdev))\n\t\treturn;\n\n\tlist_for_each_entry_safe(rx_rule, next, rx_rules_list, entry) {\n\t\tif (rx_rule->fs_id == fs_id)\n\t\t\tmacsec_fs_del_roce_rule_rx(rx_rule);\n\t}\n}\n\nstatic void macsec_fs_del_roce_rule_tx(struct mlx5_core_dev *mdev,\n\t\t\t\t       struct mlx5_roce_macsec_tx_rule *tx_rule)\n{\n\tmlx5_del_flow_rules(tx_rule->rule);\n\tmlx5_modify_header_dealloc(mdev, tx_rule->meta_modhdr);\n\tlist_del(&tx_rule->entry);\n\tkfree(tx_rule);\n}\n\nstatic void macsec_fs_del_roce_rules_tx(struct mlx5_macsec_fs *macsec_fs, u32 fs_id,\n\t\t\t\t\tstruct list_head *tx_rules_list)\n{\n\tstruct mlx5_roce_macsec_tx_rule *tx_rule, *next;\n\n\tif (!mlx5_is_macsec_roce_supported(macsec_fs->mdev))\n\t\treturn;\n\n\tlist_for_each_entry_safe(tx_rule, next, tx_rules_list, entry) {\n\t\tif (tx_rule->fs_id == fs_id)\n\t\t\tmacsec_fs_del_roce_rule_tx(macsec_fs->mdev, tx_rule);\n\t}\n}\n\nvoid mlx5_macsec_fs_get_stats_fill(struct mlx5_macsec_fs *macsec_fs, void *macsec_stats)\n{\n\tstruct mlx5_macsec_stats *stats = (struct mlx5_macsec_stats *)macsec_stats;\n\tstruct mlx5_macsec_tables *tx_tables = &macsec_fs->tx_fs->tables;\n\tstruct mlx5_macsec_tables *rx_tables = &macsec_fs->rx_fs->tables;\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\n\tif (tx_tables->check_rule_counter)\n\t\tmlx5_fc_query(mdev, tx_tables->check_rule_counter,\n\t\t\t      &stats->macsec_tx_pkts, &stats->macsec_tx_bytes);\n\n\tif (tx_tables->check_miss_rule_counter)\n\t\tmlx5_fc_query(mdev, tx_tables->check_miss_rule_counter,\n\t\t\t      &stats->macsec_tx_pkts_drop, &stats->macsec_tx_bytes_drop);\n\n\tif (rx_tables->check_rule_counter)\n\t\tmlx5_fc_query(mdev, rx_tables->check_rule_counter,\n\t\t\t      &stats->macsec_rx_pkts, &stats->macsec_rx_bytes);\n\n\tif (rx_tables->check_miss_rule_counter)\n\t\tmlx5_fc_query(mdev, rx_tables->check_miss_rule_counter,\n\t\t\t      &stats->macsec_rx_pkts_drop, &stats->macsec_rx_bytes_drop);\n}\n\nstruct mlx5_macsec_stats *mlx5_macsec_fs_get_stats(struct mlx5_macsec_fs *macsec_fs)\n{\n\tif (!macsec_fs)\n\t\treturn NULL;\n\n\treturn &macsec_fs->stats;\n}\n\nu32 mlx5_macsec_fs_get_fs_id_from_hashtable(struct mlx5_macsec_fs *macsec_fs, sci_t *sci)\n{\n\tstruct mlx5_fs_id *mlx5_fs_id;\n\tu32 fs_id = 0;\n\n\trcu_read_lock();\n\tmlx5_fs_id = rhashtable_lookup(&macsec_fs->sci_hash, sci, rhash_sci);\n\tif (mlx5_fs_id)\n\t\tfs_id = mlx5_fs_id->id;\n\trcu_read_unlock();\n\n\treturn fs_id;\n}\n\nunion mlx5_macsec_rule *\nmlx5_macsec_fs_add_rule(struct mlx5_macsec_fs *macsec_fs,\n\t\t\tconst struct macsec_context *macsec_ctx,\n\t\t\tstruct mlx5_macsec_rule_attrs *attrs,\n\t\t\tu32 *sa_fs_id)\n{\n\tstruct mlx5_macsec_event_data data = {.macsec_fs = macsec_fs,\n\t\t\t\t\t      .macdev = macsec_ctx->secy->netdev,\n\t\t\t\t\t      .is_tx =\n\t\t\t\t\t      (attrs->action == MLX5_ACCEL_MACSEC_ACTION_ENCRYPT)\n\t};\n\tunion mlx5_macsec_rule *macsec_rule;\n\tu32 tx_new_fs_id;\n\n\tmacsec_rule = (attrs->action == MLX5_ACCEL_MACSEC_ACTION_ENCRYPT) ?\n\t\tmacsec_fs_tx_add_rule(macsec_fs, macsec_ctx, attrs, &tx_new_fs_id) :\n\t\tmacsec_fs_rx_add_rule(macsec_fs, macsec_ctx, attrs, *sa_fs_id);\n\n\tdata.fs_id = (data.is_tx) ? tx_new_fs_id : *sa_fs_id;\n\tif (macsec_rule)\n\t\tblocking_notifier_call_chain(&macsec_fs->mdev->macsec_nh,\n\t\t\t\t\t     MLX5_DRIVER_EVENT_MACSEC_SA_ADDED,\n\t\t\t\t\t     &data);\n\n\treturn macsec_rule;\n}\n\nvoid mlx5_macsec_fs_del_rule(struct mlx5_macsec_fs *macsec_fs,\n\t\t\t     union mlx5_macsec_rule *macsec_rule,\n\t\t\t     int action, void *macdev, u32 sa_fs_id)\n{\n\tstruct mlx5_macsec_event_data data = {.macsec_fs = macsec_fs,\n\t\t\t\t\t      .macdev = macdev,\n\t\t\t\t\t      .is_tx = (action == MLX5_ACCEL_MACSEC_ACTION_ENCRYPT)\n\t};\n\n\tdata.fs_id = (data.is_tx) ? macsec_rule->tx_rule.fs_id : sa_fs_id;\n\tblocking_notifier_call_chain(&macsec_fs->mdev->macsec_nh,\n\t\t\t\t     MLX5_DRIVER_EVENT_MACSEC_SA_DELETED,\n\t\t\t\t     &data);\n\n\t(action == MLX5_ACCEL_MACSEC_ACTION_ENCRYPT) ?\n\t\tmacsec_fs_tx_del_rule(macsec_fs, &macsec_rule->tx_rule, macdev) :\n\t\tmacsec_fs_rx_del_rule(macsec_fs, &macsec_rule->rx_rule, macdev, sa_fs_id);\n}\n\nstatic int mlx5_macsec_fs_add_roce_rule_rx(struct mlx5_macsec_fs *macsec_fs, u32 fs_id, u16 gid_idx,\n\t\t\t\t\t   const struct sockaddr *addr,\n\t\t\t\t\t   struct list_head *rx_rules_list)\n{\n\tstruct mlx5_macsec_rx *rx_fs = macsec_fs->rx_fs;\n\tstruct mlx5_roce_macsec_rx_rule *rx_rule;\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *new_rule;\n\tstruct mlx5_flow_spec *spec;\n\tint err = 0;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\trx_rule = kzalloc(sizeof(*rx_rule), GFP_KERNEL);\n\tif (!rx_rule) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tset_ipaddr_spec(addr, spec, true);\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tdest.ft = rx_fs->roce.ft_macsec_op_check;\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tnew_rule = mlx5_add_flow_rules(rx_fs->roce.ft_ip_check, spec, &flow_act,\n\t\t\t\t       &dest, 1);\n\tif (IS_ERR(new_rule)) {\n\t\terr = PTR_ERR(new_rule);\n\t\tgoto ip_rule_err;\n\t}\n\trx_rule->ip = new_rule;\n\n\tmemset(&flow_act, 0, sizeof(flow_act));\n\tmemset(spec, 0, sizeof(*spec));\n\n\tspec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_2;\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, misc_parameters_2.metadata_reg_c_5);\n\tMLX5_SET(fte_match_param, spec->match_value, misc_parameters_2.metadata_reg_c_5,\n\t\t macsec_fs_set_rx_fs_id(fs_id));\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_ALLOW;\n\tnew_rule = mlx5_add_flow_rules(rx_fs->roce.ft_macsec_op_check, spec, &flow_act,\n\t\t\t\t       NULL, 0);\n\tif (IS_ERR(new_rule)) {\n\t\terr = PTR_ERR(new_rule);\n\t\tgoto op_rule_err;\n\t}\n\trx_rule->op = new_rule;\n\trx_rule->gid_idx = gid_idx;\n\trx_rule->fs_id = fs_id;\n\tlist_add_tail(&rx_rule->entry, rx_rules_list);\n\n\tgoto out;\n\nop_rule_err:\n\tmlx5_del_flow_rules(rx_rule->ip);\n\trx_rule->ip = NULL;\nip_rule_err:\n\tkfree(rx_rule);\nout:\n\tkvfree(spec);\n\treturn err;\n}\n\nstatic int mlx5_macsec_fs_add_roce_rule_tx(struct mlx5_macsec_fs *macsec_fs, u32 fs_id, u16 gid_idx,\n\t\t\t\t\t   const struct sockaddr *addr,\n\t\t\t\t\t   struct list_head *tx_rules_list)\n{\n\tu8 action[MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto)] = {};\n\tstruct mlx5_macsec_tx *tx_fs = macsec_fs->tx_fs;\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\tstruct mlx5_modify_hdr *modify_hdr = NULL;\n\tstruct mlx5_roce_macsec_tx_rule *tx_rule;\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *new_rule;\n\tstruct mlx5_flow_spec *spec;\n\tint err = 0;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\ttx_rule = kzalloc(sizeof(*tx_rule), GFP_KERNEL);\n\tif (!tx_rule) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tset_ipaddr_spec(addr, spec, false);\n\n\tMLX5_SET(set_action_in, action, action_type, MLX5_ACTION_TYPE_SET);\n\tMLX5_SET(set_action_in, action, field, MLX5_ACTION_IN_FIELD_METADATA_REG_A);\n\tMLX5_SET(set_action_in, action, data, macsec_fs_set_tx_fs_id(fs_id));\n\tMLX5_SET(set_action_in, action, offset, 0);\n\tMLX5_SET(set_action_in, action, length, 32);\n\n\tmodify_hdr = mlx5_modify_header_alloc(mdev, MLX5_FLOW_NAMESPACE_RDMA_TX_MACSEC,\n\t\t\t\t\t      1, action);\n\tif (IS_ERR(modify_hdr)) {\n\t\terr = PTR_ERR(modify_hdr);\n\t\tmlx5_core_err(mdev, \"Fail to alloc ROCE MACsec set modify_header_id err=%d\\n\",\n\t\t\t      err);\n\t\tmodify_hdr = NULL;\n\t\tgoto modify_hdr_err;\n\t}\n\ttx_rule->meta_modhdr = modify_hdr;\n\n\tflow_act.modify_hdr = modify_hdr;\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST | MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_TABLE_TYPE;\n\tdest.ft = tx_fs->tables.ft_crypto.t;\n\tnew_rule = mlx5_add_flow_rules(tx_fs->ft_rdma_tx, spec, &flow_act, &dest, 1);\n\tif (IS_ERR(new_rule)) {\n\t\terr = PTR_ERR(new_rule);\n\t\tmlx5_core_err(mdev, \"Failed to add ROCE TX rule, err=%d\\n\", err);\n\t\tgoto rule_err;\n\t}\n\ttx_rule->rule = new_rule;\n\ttx_rule->gid_idx = gid_idx;\n\ttx_rule->fs_id = fs_id;\n\tlist_add_tail(&tx_rule->entry, tx_rules_list);\n\n\tgoto out;\n\nrule_err:\n\tmlx5_modify_header_dealloc(mdev, tx_rule->meta_modhdr);\nmodify_hdr_err:\n\tkfree(tx_rule);\nout:\n\tkvfree(spec);\n\treturn err;\n}\n\nvoid mlx5_macsec_del_roce_rule(u16 gid_idx, struct mlx5_macsec_fs *macsec_fs,\n\t\t\t       struct list_head *tx_rules_list, struct list_head *rx_rules_list)\n{\n\tstruct mlx5_roce_macsec_rx_rule *rx_rule, *next_rx;\n\tstruct mlx5_roce_macsec_tx_rule *tx_rule, *next_tx;\n\n\tlist_for_each_entry_safe(tx_rule, next_tx, tx_rules_list, entry) {\n\t\tif (tx_rule->gid_idx == gid_idx)\n\t\t\tmacsec_fs_del_roce_rule_tx(macsec_fs->mdev, tx_rule);\n\t}\n\n\tlist_for_each_entry_safe(rx_rule, next_rx, rx_rules_list, entry) {\n\t\tif (rx_rule->gid_idx == gid_idx)\n\t\t\tmacsec_fs_del_roce_rule_rx(rx_rule);\n\t}\n}\nEXPORT_SYMBOL_GPL(mlx5_macsec_del_roce_rule);\n\nint mlx5_macsec_add_roce_rule(void *macdev, const struct sockaddr *addr, u16 gid_idx,\n\t\t\t      struct list_head *tx_rules_list, struct list_head *rx_rules_list,\n\t\t\t      struct mlx5_macsec_fs *macsec_fs)\n{\n\tstruct mlx5_macsec_device *iter, *macsec_device = NULL;\n\tstruct mlx5_core_dev *mdev = macsec_fs->mdev;\n\tstruct mlx5_fs_id *fs_id_iter;\n\tunsigned long index = 0;\n\tint err;\n\n\tlist_for_each_entry(iter, &macsec_fs->macsec_devices_list, macsec_devices_list_entry) {\n\t\tif (iter->macdev == macdev) {\n\t\t\tmacsec_device = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!macsec_device)\n\t\treturn 0;\n\n\txa_for_each(&macsec_device->tx_id_xa, index, fs_id_iter) {\n\t\terr = mlx5_macsec_fs_add_roce_rule_tx(macsec_fs, fs_id_iter->id, gid_idx, addr,\n\t\t\t\t\t\t      tx_rules_list);\n\t\tif (err) {\n\t\t\tmlx5_core_err(mdev, \"MACsec offload: Failed to add roce TX rule\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tindex = 0;\n\txa_for_each(&macsec_device->rx_id_xa, index, fs_id_iter) {\n\t\terr = mlx5_macsec_fs_add_roce_rule_rx(macsec_fs, fs_id_iter->id, gid_idx, addr,\n\t\t\t\t\t\t      rx_rules_list);\n\t\tif (err) {\n\t\t\tmlx5_core_err(mdev, \"MACsec offload: Failed to add roce TX rule\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn 0;\nout:\n\tmlx5_macsec_del_roce_rule(gid_idx, macsec_fs, tx_rules_list, rx_rules_list);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx5_macsec_add_roce_rule);\n\nvoid mlx5_macsec_add_roce_sa_rules(u32 fs_id, const struct sockaddr *addr, u16 gid_idx,\n\t\t\t\t   struct list_head *tx_rules_list,\n\t\t\t\t   struct list_head *rx_rules_list,\n\t\t\t\t   struct mlx5_macsec_fs *macsec_fs, bool is_tx)\n{\n\t(is_tx) ?\n\t\tmlx5_macsec_fs_add_roce_rule_tx(macsec_fs, fs_id, gid_idx, addr,\n\t\t\t\t\t\ttx_rules_list) :\n\t\tmlx5_macsec_fs_add_roce_rule_rx(macsec_fs, fs_id, gid_idx, addr,\n\t\t\t\t\t\trx_rules_list);\n}\nEXPORT_SYMBOL_GPL(mlx5_macsec_add_roce_sa_rules);\n\nvoid mlx5_macsec_del_roce_sa_rules(u32 fs_id, struct mlx5_macsec_fs *macsec_fs,\n\t\t\t\t   struct list_head *tx_rules_list,\n\t\t\t\t   struct list_head *rx_rules_list, bool is_tx)\n{\n\t(is_tx) ?\n\t\tmacsec_fs_del_roce_rules_tx(macsec_fs, fs_id, tx_rules_list) :\n\t\tmacsec_fs_del_roce_rules_rx(macsec_fs, fs_id, rx_rules_list);\n}\nEXPORT_SYMBOL_GPL(mlx5_macsec_del_roce_sa_rules);\n\nvoid mlx5_macsec_fs_cleanup(struct mlx5_macsec_fs *macsec_fs)\n{\n\tmacsec_fs_rx_cleanup(macsec_fs);\n\tmacsec_fs_tx_cleanup(macsec_fs);\n\trhashtable_destroy(&macsec_fs->fs_id_hash);\n\trhashtable_destroy(&macsec_fs->sci_hash);\n\tkfree(macsec_fs);\n}\n\nstruct mlx5_macsec_fs *\nmlx5_macsec_fs_init(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_macsec_fs *macsec_fs;\n\tint err;\n\n\tmacsec_fs = kzalloc(sizeof(*macsec_fs), GFP_KERNEL);\n\tif (!macsec_fs)\n\t\treturn NULL;\n\n\tmacsec_fs->mdev = mdev;\n\n\terr = rhashtable_init(&macsec_fs->sci_hash, &rhash_sci);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"MACsec offload: Failed to init SCI hash table, err=%d\\n\",\n\t\t\t      err);\n\t\tgoto err_hash;\n\t}\n\n\terr = rhashtable_init(&macsec_fs->fs_id_hash, &rhash_fs_id);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"MACsec offload: Failed to init FS_ID hash table, err=%d\\n\",\n\t\t\t      err);\n\t\tgoto sci_hash_cleanup;\n\t}\n\n\terr = macsec_fs_tx_init(macsec_fs);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"MACsec offload: Failed to init tx_fs, err=%d\\n\", err);\n\t\tgoto fs_id_hash_cleanup;\n\t}\n\n\terr = macsec_fs_rx_init(macsec_fs);\n\tif (err) {\n\t\tmlx5_core_err(mdev, \"MACsec offload: Failed to init tx_fs, err=%d\\n\", err);\n\t\tgoto tx_cleanup;\n\t}\n\n\tBLOCKING_INIT_NOTIFIER_HEAD(&mdev->macsec_nh);\n\n\treturn macsec_fs;\n\ntx_cleanup:\n\tmacsec_fs_tx_cleanup(macsec_fs);\nfs_id_hash_cleanup:\n\trhashtable_destroy(&macsec_fs->fs_id_hash);\nsci_hash_cleanup:\n\trhashtable_destroy(&macsec_fs->sci_hash);\nerr_hash:\n\tkfree(macsec_fs);\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}