{
  "module_name": "hw_table.c",
  "hash_id": "6ae6d8bf72eb80863137dc8b4295a91940a9e05d389ef5d06fd5f39a2df4744f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/sf/hw_table.c",
  "human_readable_source": "\n \n#include <linux/mlx5/driver.h>\n#include \"vhca_event.h\"\n#include \"priv.h\"\n#include \"sf.h\"\n#include \"mlx5_ifc_vhca_event.h\"\n#include \"ecpf.h\"\n#include \"mlx5_core.h\"\n#include \"eswitch.h\"\n#include \"diag/sf_tracepoint.h\"\n#include \"devlink.h\"\n\nstruct mlx5_sf_hw {\n\tu32 usr_sfnum;\n\tu8 allocated: 1;\n\tu8 pending_delete: 1;\n};\n\nstruct mlx5_sf_hwc_table {\n\tstruct mlx5_sf_hw *sfs;\n\tint max_fn;\n\tu16 start_fn_id;\n};\n\nenum mlx5_sf_hwc_index {\n\tMLX5_SF_HWC_LOCAL,\n\tMLX5_SF_HWC_EXTERNAL,\n\tMLX5_SF_HWC_MAX,\n};\n\nstruct mlx5_sf_hw_table {\n\tstruct mlx5_core_dev *dev;\n\tstruct mutex table_lock;  \n\tstruct notifier_block vhca_nb;\n\tstruct mlx5_sf_hwc_table hwc[MLX5_SF_HWC_MAX];\n};\n\nstatic struct mlx5_sf_hwc_table *\nmlx5_sf_controller_to_hwc(struct mlx5_core_dev *dev, u32 controller)\n{\n\tint idx = !!controller;\n\n\treturn &dev->priv.sf_hw_table->hwc[idx];\n}\n\nu16 mlx5_sf_sw_to_hw_id(struct mlx5_core_dev *dev, u32 controller, u16 sw_id)\n{\n\tstruct mlx5_sf_hwc_table *hwc;\n\n\thwc = mlx5_sf_controller_to_hwc(dev, controller);\n\treturn hwc->start_fn_id + sw_id;\n}\n\nstatic u16 mlx5_sf_hw_to_sw_id(struct mlx5_sf_hwc_table *hwc, u16 hw_id)\n{\n\treturn hw_id - hwc->start_fn_id;\n}\n\nstatic struct mlx5_sf_hwc_table *\nmlx5_sf_table_fn_to_hwc(struct mlx5_sf_hw_table *table, u16 fn_id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(table->hwc); i++) {\n\t\tif (table->hwc[i].max_fn &&\n\t\t    fn_id >= table->hwc[i].start_fn_id &&\n\t\t    fn_id < (table->hwc[i].start_fn_id + table->hwc[i].max_fn))\n\t\t\treturn &table->hwc[i];\n\t}\n\treturn NULL;\n}\n\nstatic int mlx5_sf_hw_table_id_alloc(struct mlx5_sf_hw_table *table, u32 controller,\n\t\t\t\t     u32 usr_sfnum)\n{\n\tstruct mlx5_sf_hwc_table *hwc;\n\tint free_idx = -1;\n\tint i;\n\n\thwc = mlx5_sf_controller_to_hwc(table->dev, controller);\n\tif (!hwc->sfs)\n\t\treturn -ENOSPC;\n\n\tfor (i = 0; i < hwc->max_fn; i++) {\n\t\tif (!hwc->sfs[i].allocated && free_idx == -1) {\n\t\t\tfree_idx = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hwc->sfs[i].allocated && hwc->sfs[i].usr_sfnum == usr_sfnum)\n\t\t\treturn -EEXIST;\n\t}\n\n\tif (free_idx == -1)\n\t\treturn -ENOSPC;\n\n\thwc->sfs[free_idx].usr_sfnum = usr_sfnum;\n\thwc->sfs[free_idx].allocated = true;\n\treturn free_idx;\n}\n\nstatic void mlx5_sf_hw_table_id_free(struct mlx5_sf_hw_table *table, u32 controller, int id)\n{\n\tstruct mlx5_sf_hwc_table *hwc;\n\n\thwc = mlx5_sf_controller_to_hwc(table->dev, controller);\n\thwc->sfs[id].allocated = false;\n\thwc->sfs[id].pending_delete = false;\n}\n\nint mlx5_sf_hw_table_sf_alloc(struct mlx5_core_dev *dev, u32 controller, u32 usr_sfnum)\n{\n\tstruct mlx5_sf_hw_table *table = dev->priv.sf_hw_table;\n\tu16 hw_fn_id;\n\tint sw_id;\n\tint err;\n\n\tif (!table)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&table->table_lock);\n\tsw_id = mlx5_sf_hw_table_id_alloc(table, controller, usr_sfnum);\n\tif (sw_id < 0) {\n\t\terr = sw_id;\n\t\tgoto exist_err;\n\t}\n\n\thw_fn_id = mlx5_sf_sw_to_hw_id(dev, controller, sw_id);\n\terr = mlx5_cmd_alloc_sf(dev, hw_fn_id);\n\tif (err)\n\t\tgoto err;\n\n\terr = mlx5_modify_vhca_sw_id(dev, hw_fn_id, usr_sfnum);\n\tif (err)\n\t\tgoto vhca_err;\n\n\tif (controller) {\n\t\t \n\t\terr = mlx5_vhca_event_arm(dev, hw_fn_id);\n\t\tif (err)\n\t\t\tgoto vhca_err;\n\t}\n\n\ttrace_mlx5_sf_hwc_alloc(dev, controller, hw_fn_id, usr_sfnum);\n\tmutex_unlock(&table->table_lock);\n\treturn sw_id;\n\nvhca_err:\n\tmlx5_cmd_dealloc_sf(dev, hw_fn_id);\nerr:\n\tmlx5_sf_hw_table_id_free(table, controller, sw_id);\nexist_err:\n\tmutex_unlock(&table->table_lock);\n\treturn err;\n}\n\nvoid mlx5_sf_hw_table_sf_free(struct mlx5_core_dev *dev, u32 controller, u16 id)\n{\n\tstruct mlx5_sf_hw_table *table = dev->priv.sf_hw_table;\n\tu16 hw_fn_id;\n\n\tmutex_lock(&table->table_lock);\n\thw_fn_id = mlx5_sf_sw_to_hw_id(dev, controller, id);\n\tmlx5_cmd_dealloc_sf(dev, hw_fn_id);\n\tmlx5_sf_hw_table_id_free(table, controller, id);\n\tmutex_unlock(&table->table_lock);\n}\n\nstatic void mlx5_sf_hw_table_hwc_sf_free(struct mlx5_core_dev *dev,\n\t\t\t\t\t struct mlx5_sf_hwc_table *hwc, int idx)\n{\n\tmlx5_cmd_dealloc_sf(dev, hwc->start_fn_id + idx);\n\thwc->sfs[idx].allocated = false;\n\thwc->sfs[idx].pending_delete = false;\n\ttrace_mlx5_sf_hwc_free(dev, hwc->start_fn_id + idx);\n}\n\nvoid mlx5_sf_hw_table_sf_deferred_free(struct mlx5_core_dev *dev, u32 controller, u16 id)\n{\n\tstruct mlx5_sf_hw_table *table = dev->priv.sf_hw_table;\n\tu32 out[MLX5_ST_SZ_DW(query_vhca_state_out)] = {};\n\tstruct mlx5_sf_hwc_table *hwc;\n\tu16 hw_fn_id;\n\tu8 state;\n\tint err;\n\n\thw_fn_id = mlx5_sf_sw_to_hw_id(dev, controller, id);\n\thwc = mlx5_sf_controller_to_hwc(dev, controller);\n\tmutex_lock(&table->table_lock);\n\terr = mlx5_cmd_query_vhca_state(dev, hw_fn_id, out, sizeof(out));\n\tif (err)\n\t\tgoto err;\n\tstate = MLX5_GET(query_vhca_state_out, out, vhca_state_context.vhca_state);\n\tif (state == MLX5_VHCA_STATE_ALLOCATED) {\n\t\tmlx5_cmd_dealloc_sf(dev, hw_fn_id);\n\t\thwc->sfs[id].allocated = false;\n\t} else {\n\t\thwc->sfs[id].pending_delete = true;\n\t\ttrace_mlx5_sf_hwc_deferred_free(dev, hw_fn_id);\n\t}\nerr:\n\tmutex_unlock(&table->table_lock);\n}\n\nstatic void mlx5_sf_hw_table_hwc_dealloc_all(struct mlx5_core_dev *dev,\n\t\t\t\t\t     struct mlx5_sf_hwc_table *hwc)\n{\n\tint i;\n\n\tfor (i = 0; i < hwc->max_fn; i++) {\n\t\tif (hwc->sfs[i].allocated)\n\t\t\tmlx5_sf_hw_table_hwc_sf_free(dev, hwc, i);\n\t}\n}\n\nstatic void mlx5_sf_hw_table_dealloc_all(struct mlx5_sf_hw_table *table)\n{\n\tmlx5_sf_hw_table_hwc_dealloc_all(table->dev, &table->hwc[MLX5_SF_HWC_EXTERNAL]);\n\tmlx5_sf_hw_table_hwc_dealloc_all(table->dev, &table->hwc[MLX5_SF_HWC_LOCAL]);\n}\n\nstatic int mlx5_sf_hw_table_hwc_init(struct mlx5_sf_hwc_table *hwc, u16 max_fn, u16 base_id)\n{\n\tstruct mlx5_sf_hw *sfs;\n\n\tif (!max_fn)\n\t\treturn 0;\n\n\tsfs = kcalloc(max_fn, sizeof(*sfs), GFP_KERNEL);\n\tif (!sfs)\n\t\treturn -ENOMEM;\n\n\thwc->sfs = sfs;\n\thwc->max_fn = max_fn;\n\thwc->start_fn_id = base_id;\n\treturn 0;\n}\n\nstatic void mlx5_sf_hw_table_hwc_cleanup(struct mlx5_sf_hwc_table *hwc)\n{\n\tkfree(hwc->sfs);\n}\n\nstatic void mlx5_sf_hw_table_res_unregister(struct mlx5_core_dev *dev)\n{\n\tdevl_resources_unregister(priv_to_devlink(dev));\n}\n\nstatic int mlx5_sf_hw_table_res_register(struct mlx5_core_dev *dev, u16 max_fn,\n\t\t\t\t\t u16 max_ext_fn)\n{\n\tstruct devlink_resource_size_params size_params;\n\tstruct devlink *devlink = priv_to_devlink(dev);\n\tint err;\n\n\tdevlink_resource_size_params_init(&size_params, max_fn, max_fn, 1,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\terr = devl_resource_register(devlink, \"max_local_SFs\", max_fn, MLX5_DL_RES_MAX_LOCAL_SFS,\n\t\t\t\t     DEVLINK_RESOURCE_ID_PARENT_TOP, &size_params);\n\tif (err)\n\t\treturn err;\n\n\tdevlink_resource_size_params_init(&size_params, max_ext_fn, max_ext_fn, 1,\n\t\t\t\t\t  DEVLINK_RESOURCE_UNIT_ENTRY);\n\treturn devl_resource_register(devlink, \"max_external_SFs\", max_ext_fn,\n\t\t\t\t      MLX5_DL_RES_MAX_EXTERNAL_SFS, DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t      &size_params);\n}\n\nint mlx5_sf_hw_table_init(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_sf_hw_table *table;\n\tu16 max_ext_fn = 0;\n\tu16 ext_base_id = 0;\n\tu16 base_id;\n\tu16 max_fn;\n\tint err;\n\n\tif (!mlx5_vhca_event_supported(dev))\n\t\treturn 0;\n\n\tmax_fn = mlx5_sf_max_functions(dev);\n\n\terr = mlx5_esw_sf_max_hpf_functions(dev, &max_ext_fn, &ext_base_id);\n\tif (err)\n\t\treturn err;\n\n\tif (mlx5_sf_hw_table_res_register(dev, max_fn, max_ext_fn))\n\t\tmlx5_core_dbg(dev, \"failed to register max SFs resources\");\n\n\tif (!max_fn && !max_ext_fn)\n\t\treturn 0;\n\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (!table) {\n\t\terr = -ENOMEM;\n\t\tgoto alloc_err;\n\t}\n\n\tmutex_init(&table->table_lock);\n\ttable->dev = dev;\n\tdev->priv.sf_hw_table = table;\n\n\tbase_id = mlx5_sf_start_function_id(dev);\n\terr = mlx5_sf_hw_table_hwc_init(&table->hwc[MLX5_SF_HWC_LOCAL], max_fn, base_id);\n\tif (err)\n\t\tgoto table_err;\n\n\terr = mlx5_sf_hw_table_hwc_init(&table->hwc[MLX5_SF_HWC_EXTERNAL],\n\t\t\t\t\tmax_ext_fn, ext_base_id);\n\tif (err)\n\t\tgoto ext_err;\n\n\tmlx5_core_dbg(dev, \"SF HW table: max sfs = %d, ext sfs = %d\\n\", max_fn, max_ext_fn);\n\treturn 0;\n\next_err:\n\tmlx5_sf_hw_table_hwc_cleanup(&table->hwc[MLX5_SF_HWC_LOCAL]);\ntable_err:\n\tmutex_destroy(&table->table_lock);\n\tkfree(table);\nalloc_err:\n\tmlx5_sf_hw_table_res_unregister(dev);\n\treturn err;\n}\n\nvoid mlx5_sf_hw_table_cleanup(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_sf_hw_table *table = dev->priv.sf_hw_table;\n\n\tif (!table)\n\t\tgoto res_unregister;\n\n\tmlx5_sf_hw_table_hwc_cleanup(&table->hwc[MLX5_SF_HWC_EXTERNAL]);\n\tmlx5_sf_hw_table_hwc_cleanup(&table->hwc[MLX5_SF_HWC_LOCAL]);\n\tmutex_destroy(&table->table_lock);\n\tkfree(table);\nres_unregister:\n\tmlx5_sf_hw_table_res_unregister(dev);\n}\n\nstatic int mlx5_sf_hw_vhca_event(struct notifier_block *nb, unsigned long opcode, void *data)\n{\n\tstruct mlx5_sf_hw_table *table = container_of(nb, struct mlx5_sf_hw_table, vhca_nb);\n\tconst struct mlx5_vhca_state_event *event = data;\n\tstruct mlx5_sf_hwc_table *hwc;\n\tstruct mlx5_sf_hw *sf_hw;\n\tu16 sw_id;\n\n\tif (event->new_vhca_state != MLX5_VHCA_STATE_ALLOCATED)\n\t\treturn 0;\n\n\thwc = mlx5_sf_table_fn_to_hwc(table, event->function_id);\n\tif (!hwc)\n\t\treturn 0;\n\n\tsw_id = mlx5_sf_hw_to_sw_id(hwc, event->function_id);\n\tsf_hw = &hwc->sfs[sw_id];\n\n\tmutex_lock(&table->table_lock);\n\t \n\tif (sf_hw->allocated && sf_hw->pending_delete)\n\t\tmlx5_sf_hw_table_hwc_sf_free(table->dev, hwc, sw_id);\n\tmutex_unlock(&table->table_lock);\n\treturn 0;\n}\n\nint mlx5_sf_hw_table_create(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_sf_hw_table *table = dev->priv.sf_hw_table;\n\n\tif (!table)\n\t\treturn 0;\n\n\ttable->vhca_nb.notifier_call = mlx5_sf_hw_vhca_event;\n\treturn mlx5_vhca_event_notifier_register(dev, &table->vhca_nb);\n}\n\nvoid mlx5_sf_hw_table_destroy(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_sf_hw_table *table = dev->priv.sf_hw_table;\n\n\tif (!table)\n\t\treturn;\n\n\tmlx5_vhca_event_notifier_unregister(dev, &table->vhca_nb);\n\t \n\tmlx5_sf_hw_table_dealloc_all(table);\n}\n\nbool mlx5_sf_hw_table_supported(const struct mlx5_core_dev *dev)\n{\n\treturn !!dev->priv.sf_hw_table;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}