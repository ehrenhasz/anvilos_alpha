{
  "module_name": "bridge_mcast.c",
  "hash_id": "6dce2d11c4d5ba80f0f78bdd0e38f101c665bb7ed2d009078916de8a2217b03b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge_mcast.c",
  "human_readable_source": "\n \n\n#include \"lib/devcom.h\"\n#include \"bridge.h\"\n#include \"eswitch.h\"\n#include \"bridge_priv.h\"\n#include \"diag/bridge_tracepoint.h\"\n\nstatic const struct rhashtable_params mdb_ht_params = {\n\t.key_offset = offsetof(struct mlx5_esw_bridge_mdb_entry, key),\n\t.key_len = sizeof(struct mlx5_esw_bridge_mdb_key),\n\t.head_offset = offsetof(struct mlx5_esw_bridge_mdb_entry, ht_node),\n\t.automatic_shrinking = true,\n};\n\nint mlx5_esw_bridge_mdb_init(struct mlx5_esw_bridge *bridge)\n{\n\tINIT_LIST_HEAD(&bridge->mdb_list);\n\treturn rhashtable_init(&bridge->mdb_ht, &mdb_ht_params);\n}\n\nvoid mlx5_esw_bridge_mdb_cleanup(struct mlx5_esw_bridge *bridge)\n{\n\trhashtable_destroy(&bridge->mdb_ht);\n}\n\nstatic struct mlx5_esw_bridge_port *\nmlx5_esw_bridge_mdb_port_lookup(struct mlx5_esw_bridge_port *port,\n\t\t\t\tstruct mlx5_esw_bridge_mdb_entry *entry)\n{\n\treturn xa_load(&entry->ports, mlx5_esw_bridge_port_key(port));\n}\n\nstatic int mlx5_esw_bridge_mdb_port_insert(struct mlx5_esw_bridge_port *port,\n\t\t\t\t\t   struct mlx5_esw_bridge_mdb_entry *entry)\n{\n\tint err = xa_insert(&entry->ports, mlx5_esw_bridge_port_key(port), port, GFP_KERNEL);\n\n\tif (!err)\n\t\tentry->num_ports++;\n\treturn err;\n}\n\nstatic void mlx5_esw_bridge_mdb_port_remove(struct mlx5_esw_bridge_port *port,\n\t\t\t\t\t    struct mlx5_esw_bridge_mdb_entry *entry)\n{\n\txa_erase(&entry->ports, mlx5_esw_bridge_port_key(port));\n\tentry->num_ports--;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_mdb_flow_create(u16 esw_owner_vhca_id, struct mlx5_esw_bridge_mdb_entry *entry,\n\t\t\t\tstruct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_flow_act flow_act = {\n\t\t.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST,\n\t\t.flags = FLOW_ACT_NO_APPEND | FLOW_ACT_IGNORE_FLOW_LEVEL,\n\t};\n\tint num_dests = entry->num_ports, i = 0;\n\tstruct mlx5_flow_destination *dests;\n\tstruct mlx5_esw_bridge_port *port;\n\tstruct mlx5_flow_spec *rule_spec;\n\tstruct mlx5_flow_handle *handle;\n\tu8 *dmac_v, *dmac_c;\n\tunsigned long idx;\n\n\trule_spec = kvzalloc(sizeof(*rule_spec), GFP_KERNEL);\n\tif (!rule_spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdests = kvcalloc(num_dests, sizeof(*dests), GFP_KERNEL);\n\tif (!dests) {\n\t\tkvfree(rule_spec);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\txa_for_each(&entry->ports, idx, port) {\n\t\tdests[i].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\t\tdests[i].ft = port->mcast.ft;\n\t\ti++;\n\t}\n\n\trule_spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\tdmac_v = MLX5_ADDR_OF(fte_match_param, rule_spec->match_value, outer_headers.dmac_47_16);\n\tether_addr_copy(dmac_v, entry->key.addr);\n\tdmac_c = MLX5_ADDR_OF(fte_match_param, rule_spec->match_criteria, outer_headers.dmac_47_16);\n\teth_broadcast_addr(dmac_c);\n\n\tif (entry->key.vid) {\n\t\tif (bridge->vlan_proto == ETH_P_8021Q) {\n\t\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria,\n\t\t\t\t\t outer_headers.cvlan_tag);\n\t\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_value,\n\t\t\t\t\t outer_headers.cvlan_tag);\n\t\t} else if (bridge->vlan_proto == ETH_P_8021AD) {\n\t\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria,\n\t\t\t\t\t outer_headers.svlan_tag);\n\t\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_value,\n\t\t\t\t\t outer_headers.svlan_tag);\n\t\t}\n\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria,\n\t\t\t\t outer_headers.first_vid);\n\t\tMLX5_SET(fte_match_param, rule_spec->match_value, outer_headers.first_vid,\n\t\t\t entry->key.vid);\n\t}\n\n\thandle = mlx5_add_flow_rules(bridge->egress_ft, rule_spec, &flow_act, dests, num_dests);\n\n\tkvfree(dests);\n\tkvfree(rule_spec);\n\treturn handle;\n}\n\nstatic int\nmlx5_esw_bridge_port_mdb_offload(struct mlx5_esw_bridge_port *port,\n\t\t\t\t struct mlx5_esw_bridge_mdb_entry *entry)\n{\n\tstruct mlx5_flow_handle *handle;\n\n\thandle = mlx5_esw_bridge_mdb_flow_create(port->esw_owner_vhca_id, entry, port->bridge);\n\tif (entry->egress_handle) {\n\t\tmlx5_del_flow_rules(entry->egress_handle);\n\t\tentry->egress_handle = NULL;\n\t}\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tentry->egress_handle = handle;\n\treturn 0;\n}\n\nstatic struct mlx5_esw_bridge_mdb_entry *\nmlx5_esw_bridge_mdb_lookup(struct mlx5_esw_bridge *bridge,\n\t\t\t   const unsigned char *addr, u16 vid)\n{\n\tstruct mlx5_esw_bridge_mdb_key key = {};\n\n\tether_addr_copy(key.addr, addr);\n\tkey.vid = vid;\n\treturn rhashtable_lookup_fast(&bridge->mdb_ht, &key, mdb_ht_params);\n}\n\nstatic struct mlx5_esw_bridge_mdb_entry *\nmlx5_esw_bridge_port_mdb_entry_init(struct mlx5_esw_bridge_port *port,\n\t\t\t\t    const unsigned char *addr, u16 vid)\n{\n\tstruct mlx5_esw_bridge *bridge = port->bridge;\n\tstruct mlx5_esw_bridge_mdb_entry *entry;\n\tint err;\n\n\tentry = kvzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tether_addr_copy(entry->key.addr, addr);\n\tentry->key.vid = vid;\n\txa_init(&entry->ports);\n\terr = rhashtable_insert_fast(&bridge->mdb_ht, &entry->ht_node, mdb_ht_params);\n\tif (err)\n\t\tgoto err_ht_insert;\n\n\tlist_add(&entry->list, &bridge->mdb_list);\n\n\treturn entry;\n\nerr_ht_insert:\n\txa_destroy(&entry->ports);\n\tkvfree(entry);\n\treturn ERR_PTR(err);\n}\n\nstatic void mlx5_esw_bridge_port_mdb_entry_cleanup(struct mlx5_esw_bridge *bridge,\n\t\t\t\t\t\t   struct mlx5_esw_bridge_mdb_entry *entry)\n{\n\tif (entry->egress_handle)\n\t\tmlx5_del_flow_rules(entry->egress_handle);\n\tlist_del(&entry->list);\n\trhashtable_remove_fast(&bridge->mdb_ht, &entry->ht_node, mdb_ht_params);\n\txa_destroy(&entry->ports);\n\tkvfree(entry);\n}\n\nint mlx5_esw_bridge_port_mdb_attach(struct net_device *dev, struct mlx5_esw_bridge_port *port,\n\t\t\t\t    const unsigned char *addr, u16 vid)\n{\n\tstruct mlx5_esw_bridge *bridge = port->bridge;\n\tstruct mlx5_esw_bridge_mdb_entry *entry;\n\tint err;\n\n\tif (!(bridge->flags & MLX5_ESW_BRIDGE_MCAST_FLAG))\n\t\treturn -EOPNOTSUPP;\n\n\tentry = mlx5_esw_bridge_mdb_lookup(bridge, addr, vid);\n\tif (entry) {\n\t\tif (mlx5_esw_bridge_mdb_port_lookup(port, entry)) {\n\t\t\tesw_warn(bridge->br_offloads->esw->dev, \"MDB attach entry is already attached to port (MAC=%pM,vid=%u,vport=%u)\\n\",\n\t\t\t\t addr, vid, port->vport_num);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tentry = mlx5_esw_bridge_port_mdb_entry_init(port, addr, vid);\n\t\tif (IS_ERR(entry)) {\n\t\t\terr = PTR_ERR(entry);\n\t\t\tesw_warn(bridge->br_offloads->esw->dev, \"MDB attach failed to init entry (MAC=%pM,vid=%u,vport=%u,err=%d)\\n\",\n\t\t\t\t addr, vid, port->vport_num, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = mlx5_esw_bridge_mdb_port_insert(port, entry);\n\tif (err) {\n\t\tif (!entry->num_ports)\n\t\t\tmlx5_esw_bridge_port_mdb_entry_cleanup(bridge, entry);  \n\t\tesw_warn(bridge->br_offloads->esw->dev,\n\t\t\t \"MDB attach failed to insert port (MAC=%pM,vid=%u,vport=%u,err=%d)\\n\",\n\t\t\t addr, vid, port->vport_num, err);\n\t\treturn err;\n\t}\n\n\terr = mlx5_esw_bridge_port_mdb_offload(port, entry);\n\tif (err)\n\t\t \n\t\tesw_warn(bridge->br_offloads->esw->dev, \"MDB attach failed to offload (MAC=%pM,vid=%u,vport=%u,err=%d)\\n\",\n\t\t\t addr, vid, port->vport_num, err);\n\n\ttrace_mlx5_esw_bridge_port_mdb_attach(dev, entry);\n\treturn 0;\n}\n\nstatic void mlx5_esw_bridge_port_mdb_entry_detach(struct mlx5_esw_bridge_port *port,\n\t\t\t\t\t\t  struct mlx5_esw_bridge_mdb_entry *entry)\n{\n\tstruct mlx5_esw_bridge *bridge = port->bridge;\n\tint err;\n\n\tmlx5_esw_bridge_mdb_port_remove(port, entry);\n\tif (!entry->num_ports) {\n\t\tmlx5_esw_bridge_port_mdb_entry_cleanup(bridge, entry);\n\t\treturn;\n\t}\n\n\terr = mlx5_esw_bridge_port_mdb_offload(port, entry);\n\tif (err)\n\t\t \n\t\tesw_warn(bridge->br_offloads->esw->dev, \"MDB detach failed to offload (MAC=%pM,vid=%u,vport=%u)\\n\",\n\t\t\t entry->key.addr, entry->key.vid, port->vport_num);\n}\n\nvoid mlx5_esw_bridge_port_mdb_detach(struct net_device *dev, struct mlx5_esw_bridge_port *port,\n\t\t\t\t     const unsigned char *addr, u16 vid)\n{\n\tstruct mlx5_esw_bridge *bridge = port->bridge;\n\tstruct mlx5_esw_bridge_mdb_entry *entry;\n\n\tentry = mlx5_esw_bridge_mdb_lookup(bridge, addr, vid);\n\tif (!entry) {\n\t\tesw_debug(bridge->br_offloads->esw->dev,\n\t\t\t  \"MDB detach entry not found (MAC=%pM,vid=%u,vport=%u)\\n\",\n\t\t\t  addr, vid, port->vport_num);\n\t\treturn;\n\t}\n\n\tif (!mlx5_esw_bridge_mdb_port_lookup(port, entry)) {\n\t\tesw_debug(bridge->br_offloads->esw->dev,\n\t\t\t  \"MDB detach entry not attached to the port (MAC=%pM,vid=%u,vport=%u)\\n\",\n\t\t\t  addr, vid, port->vport_num);\n\t\treturn;\n\t}\n\n\ttrace_mlx5_esw_bridge_port_mdb_detach(dev, entry);\n\tmlx5_esw_bridge_port_mdb_entry_detach(port, entry);\n}\n\nvoid mlx5_esw_bridge_port_mdb_vlan_flush(struct mlx5_esw_bridge_port *port,\n\t\t\t\t\t struct mlx5_esw_bridge_vlan *vlan)\n{\n\tstruct mlx5_esw_bridge *bridge = port->bridge;\n\tstruct mlx5_esw_bridge_mdb_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &bridge->mdb_list, list)\n\t\tif (entry->key.vid == vlan->vid && mlx5_esw_bridge_mdb_port_lookup(port, entry))\n\t\t\tmlx5_esw_bridge_port_mdb_entry_detach(port, entry);\n}\n\nstatic void mlx5_esw_bridge_port_mdb_flush(struct mlx5_esw_bridge_port *port)\n{\n\tstruct mlx5_esw_bridge *bridge = port->bridge;\n\tstruct mlx5_esw_bridge_mdb_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &bridge->mdb_list, list)\n\t\tif (mlx5_esw_bridge_mdb_port_lookup(port, entry))\n\t\t\tmlx5_esw_bridge_port_mdb_entry_detach(port, entry);\n}\n\nvoid mlx5_esw_bridge_mdb_flush(struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_esw_bridge_mdb_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &bridge->mdb_list, list)\n\t\tmlx5_esw_bridge_port_mdb_entry_cleanup(bridge, entry);\n}\nstatic int mlx5_esw_bridge_port_mcast_fts_init(struct mlx5_esw_bridge_port *port,\n\t\t\t\t\t       struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_eswitch *esw = bridge->br_offloads->esw;\n\tstruct mlx5_flow_table *mcast_ft;\n\n\tmcast_ft = mlx5_esw_bridge_table_create(MLX5_ESW_BRIDGE_MCAST_TABLE_SIZE,\n\t\t\t\t\t\tMLX5_ESW_BRIDGE_LEVEL_MCAST_TABLE,\n\t\t\t\t\t\tesw);\n\tif (IS_ERR(mcast_ft))\n\t\treturn PTR_ERR(mcast_ft);\n\n\tport->mcast.ft = mcast_ft;\n\treturn 0;\n}\n\nstatic void mlx5_esw_bridge_port_mcast_fts_cleanup(struct mlx5_esw_bridge_port *port)\n{\n\tif (port->mcast.ft)\n\t\tmlx5_destroy_flow_table(port->mcast.ft);\n\tport->mcast.ft = NULL;\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_mcast_filter_fg_create(struct mlx5_eswitch *esw,\n\t\t\t\t       struct mlx5_flow_table *mcast_ft)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fg;\n\tu32 *in, *match;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tMLX5_SET(create_flow_group_in, in, match_criteria_enable, MLX5_MATCH_MISC_PARAMETERS_2);\n\tmatch = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\n\tMLX5_SET(fte_match_param, match, misc_parameters_2.metadata_reg_c_0,\n\t\t mlx5_eswitch_get_vport_metadata_mask());\n\n\tMLX5_SET(create_flow_group_in, in, start_flow_index,\n\t\t MLX5_ESW_BRIDGE_MCAST_TABLE_FILTER_GRP_IDX_FROM);\n\tMLX5_SET(create_flow_group_in, in, end_flow_index,\n\t\t MLX5_ESW_BRIDGE_MCAST_TABLE_FILTER_GRP_IDX_TO);\n\n\tfg = mlx5_create_flow_group(mcast_ft, in);\n\tkvfree(in);\n\tif (IS_ERR(fg))\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to create filter flow group for bridge mcast table (err=%pe)\\n\",\n\t\t\t fg);\n\n\treturn fg;\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_mcast_vlan_proto_fg_create(unsigned int from, unsigned int to, u16 vlan_proto,\n\t\t\t\t\t   struct mlx5_eswitch *esw,\n\t\t\t\t\t   struct mlx5_flow_table *mcast_ft)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fg;\n\tu32 *in, *match;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tMLX5_SET(create_flow_group_in, in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);\n\tmatch = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\n\tif (vlan_proto == ETH_P_8021Q)\n\t\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.cvlan_tag);\n\telse if (vlan_proto == ETH_P_8021AD)\n\t\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.svlan_tag);\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.first_vid);\n\n\tMLX5_SET(create_flow_group_in, in, start_flow_index, from);\n\tMLX5_SET(create_flow_group_in, in, end_flow_index, to);\n\n\tfg = mlx5_create_flow_group(mcast_ft, in);\n\tkvfree(in);\n\tif (IS_ERR(fg))\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to create VLAN(proto=%x) flow group for bridge mcast table (err=%pe)\\n\",\n\t\t\t vlan_proto, fg);\n\n\treturn fg;\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_mcast_vlan_fg_create(struct mlx5_eswitch *esw, struct mlx5_flow_table *mcast_ft)\n{\n\tunsigned int from = MLX5_ESW_BRIDGE_MCAST_TABLE_VLAN_GRP_IDX_FROM;\n\tunsigned int to = MLX5_ESW_BRIDGE_MCAST_TABLE_VLAN_GRP_IDX_TO;\n\n\treturn mlx5_esw_bridge_mcast_vlan_proto_fg_create(from, to, ETH_P_8021Q, esw, mcast_ft);\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_mcast_qinq_fg_create(struct mlx5_eswitch *esw,\n\t\t\t\t     struct mlx5_flow_table *mcast_ft)\n{\n\tunsigned int from = MLX5_ESW_BRIDGE_MCAST_TABLE_QINQ_GRP_IDX_FROM;\n\tunsigned int to = MLX5_ESW_BRIDGE_MCAST_TABLE_QINQ_GRP_IDX_TO;\n\n\treturn mlx5_esw_bridge_mcast_vlan_proto_fg_create(from, to, ETH_P_8021AD, esw, mcast_ft);\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_mcast_fwd_fg_create(struct mlx5_eswitch *esw,\n\t\t\t\t    struct mlx5_flow_table *mcast_ft)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fg;\n\tu32 *in;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tMLX5_SET(create_flow_group_in, in, start_flow_index,\n\t\t MLX5_ESW_BRIDGE_MCAST_TABLE_FWD_GRP_IDX_FROM);\n\tMLX5_SET(create_flow_group_in, in, end_flow_index,\n\t\t MLX5_ESW_BRIDGE_MCAST_TABLE_FWD_GRP_IDX_TO);\n\n\tfg = mlx5_create_flow_group(mcast_ft, in);\n\tkvfree(in);\n\tif (IS_ERR(fg))\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to create forward flow group for bridge mcast table (err=%pe)\\n\",\n\t\t\t fg);\n\n\treturn fg;\n}\n\nstatic int mlx5_esw_bridge_port_mcast_fgs_init(struct mlx5_esw_bridge_port *port)\n{\n\tstruct mlx5_flow_group *fwd_fg, *qinq_fg, *vlan_fg, *filter_fg;\n\tstruct mlx5_eswitch *esw = port->bridge->br_offloads->esw;\n\tstruct mlx5_flow_table *mcast_ft = port->mcast.ft;\n\tint err;\n\n\tfilter_fg = mlx5_esw_bridge_mcast_filter_fg_create(esw, mcast_ft);\n\tif (IS_ERR(filter_fg))\n\t\treturn PTR_ERR(filter_fg);\n\n\tvlan_fg = mlx5_esw_bridge_mcast_vlan_fg_create(esw, mcast_ft);\n\tif (IS_ERR(vlan_fg)) {\n\t\terr = PTR_ERR(vlan_fg);\n\t\tgoto err_vlan_fg;\n\t}\n\n\tqinq_fg = mlx5_esw_bridge_mcast_qinq_fg_create(esw, mcast_ft);\n\tif (IS_ERR(qinq_fg)) {\n\t\terr = PTR_ERR(qinq_fg);\n\t\tgoto err_qinq_fg;\n\t}\n\n\tfwd_fg = mlx5_esw_bridge_mcast_fwd_fg_create(esw, mcast_ft);\n\tif (IS_ERR(fwd_fg)) {\n\t\terr = PTR_ERR(fwd_fg);\n\t\tgoto err_fwd_fg;\n\t}\n\n\tport->mcast.filter_fg = filter_fg;\n\tport->mcast.vlan_fg = vlan_fg;\n\tport->mcast.qinq_fg = qinq_fg;\n\tport->mcast.fwd_fg = fwd_fg;\n\n\treturn 0;\n\nerr_fwd_fg:\n\tmlx5_destroy_flow_group(qinq_fg);\nerr_qinq_fg:\n\tmlx5_destroy_flow_group(vlan_fg);\nerr_vlan_fg:\n\tmlx5_destroy_flow_group(filter_fg);\n\treturn err;\n}\n\nstatic void mlx5_esw_bridge_port_mcast_fgs_cleanup(struct mlx5_esw_bridge_port *port)\n{\n\tif (port->mcast.fwd_fg)\n\t\tmlx5_destroy_flow_group(port->mcast.fwd_fg);\n\tport->mcast.fwd_fg = NULL;\n\tif (port->mcast.qinq_fg)\n\t\tmlx5_destroy_flow_group(port->mcast.qinq_fg);\n\tport->mcast.qinq_fg = NULL;\n\tif (port->mcast.vlan_fg)\n\t\tmlx5_destroy_flow_group(port->mcast.vlan_fg);\n\tport->mcast.vlan_fg = NULL;\n\tif (port->mcast.filter_fg)\n\t\tmlx5_destroy_flow_group(port->mcast.filter_fg);\n\tport->mcast.filter_fg = NULL;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_mcast_flow_with_esw_create(struct mlx5_esw_bridge_port *port,\n\t\t\t\t\t   struct mlx5_eswitch *esw)\n{\n\tstruct mlx5_flow_act flow_act = {\n\t\t.action = MLX5_FLOW_CONTEXT_ACTION_DROP,\n\t\t.flags = FLOW_ACT_NO_APPEND,\n\t};\n\tstruct mlx5_flow_spec *rule_spec;\n\tstruct mlx5_flow_handle *handle;\n\n\trule_spec = kvzalloc(sizeof(*rule_spec), GFP_KERNEL);\n\tif (!rule_spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trule_spec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS_2;\n\n\tMLX5_SET(fte_match_param, rule_spec->match_criteria,\n\t\t misc_parameters_2.metadata_reg_c_0, mlx5_eswitch_get_vport_metadata_mask());\n\tMLX5_SET(fte_match_param, rule_spec->match_value, misc_parameters_2.metadata_reg_c_0,\n\t\t mlx5_eswitch_get_vport_metadata_for_match(esw, port->vport_num));\n\n\thandle = mlx5_add_flow_rules(port->mcast.ft, rule_spec, &flow_act, NULL, 0);\n\n\tkvfree(rule_spec);\n\treturn handle;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_mcast_filter_flow_create(struct mlx5_esw_bridge_port *port)\n{\n\treturn mlx5_esw_bridge_mcast_flow_with_esw_create(port, port->bridge->br_offloads->esw);\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_mcast_filter_flow_peer_create(struct mlx5_esw_bridge_port *port)\n{\n\tstruct mlx5_devcom_comp_dev *devcom = port->bridge->br_offloads->esw->devcom, *pos;\n\tstruct mlx5_eswitch *tmp, *peer_esw = NULL;\n\tstatic struct mlx5_flow_handle *handle;\n\n\tif (!mlx5_devcom_for_each_peer_begin(devcom))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmlx5_devcom_for_each_peer_entry(devcom, tmp, pos) {\n\t\tif (mlx5_esw_is_owner(tmp, port->vport_num, port->esw_owner_vhca_id)) {\n\t\t\tpeer_esw = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!peer_esw) {\n\t\thandle = ERR_PTR(-ENODEV);\n\t\tgoto out;\n\t}\n\n\thandle = mlx5_esw_bridge_mcast_flow_with_esw_create(port, peer_esw);\n\nout:\n\tmlx5_devcom_for_each_peer_end(devcom);\n\treturn handle;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_mcast_vlan_flow_create(u16 vlan_proto, struct mlx5_esw_bridge_port *port,\n\t\t\t\t       struct mlx5_esw_bridge_vlan *vlan)\n{\n\tstruct mlx5_flow_act flow_act = {\n\t\t.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST,\n\t\t.flags = FLOW_ACT_NO_APPEND,\n\t};\n\tstruct mlx5_flow_destination dest = {\n\t\t.type = MLX5_FLOW_DESTINATION_TYPE_VPORT,\n\t\t.vport.num = port->vport_num,\n\t};\n\tstruct mlx5_esw_bridge *bridge = port->bridge;\n\tstruct mlx5_flow_spec *rule_spec;\n\tstruct mlx5_flow_handle *handle;\n\n\trule_spec = kvzalloc(sizeof(*rule_spec), GFP_KERNEL);\n\tif (!rule_spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (MLX5_CAP_ESW_FLOWTABLE(bridge->br_offloads->esw->dev, flow_source) &&\n\t    port->vport_num == MLX5_VPORT_UPLINK)\n\t\trule_spec->flow_context.flow_source =\n\t\t\tMLX5_FLOW_CONTEXT_FLOW_SOURCE_LOCAL_VPORT;\n\trule_spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\n\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;\n\tflow_act.pkt_reformat = vlan->pkt_reformat_pop;\n\n\tif (vlan_proto == ETH_P_8021Q) {\n\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria,\n\t\t\t\t outer_headers.cvlan_tag);\n\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_value,\n\t\t\t\t outer_headers.cvlan_tag);\n\t} else if (vlan_proto == ETH_P_8021AD) {\n\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria,\n\t\t\t\t outer_headers.svlan_tag);\n\t\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_value,\n\t\t\t\t outer_headers.svlan_tag);\n\t}\n\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria, outer_headers.first_vid);\n\tMLX5_SET(fte_match_param, rule_spec->match_value, outer_headers.first_vid, vlan->vid);\n\n\tif (MLX5_CAP_ESW(bridge->br_offloads->esw->dev, merged_eswitch)) {\n\t\tdest.vport.flags = MLX5_FLOW_DEST_VPORT_VHCA_ID;\n\t\tdest.vport.vhca_id = port->esw_owner_vhca_id;\n\t}\n\thandle = mlx5_add_flow_rules(port->mcast.ft, rule_spec, &flow_act, &dest, 1);\n\n\tkvfree(rule_spec);\n\treturn handle;\n}\n\nint mlx5_esw_bridge_vlan_mcast_init(u16 vlan_proto, struct mlx5_esw_bridge_port *port,\n\t\t\t\t    struct mlx5_esw_bridge_vlan *vlan)\n{\n\tstruct mlx5_flow_handle *handle;\n\n\tif (!(port->bridge->flags & MLX5_ESW_BRIDGE_MCAST_FLAG))\n\t\treturn 0;\n\n\thandle = mlx5_esw_bridge_mcast_vlan_flow_create(vlan_proto, port, vlan);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tvlan->mcast_handle = handle;\n\treturn 0;\n}\n\nvoid mlx5_esw_bridge_vlan_mcast_cleanup(struct mlx5_esw_bridge_vlan *vlan)\n{\n\tif (vlan->mcast_handle)\n\t\tmlx5_del_flow_rules(vlan->mcast_handle);\n\tvlan->mcast_handle = NULL;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_mcast_fwd_flow_create(struct mlx5_esw_bridge_port *port)\n{\n\tstruct mlx5_flow_act flow_act = {\n\t\t.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST,\n\t\t.flags = FLOW_ACT_NO_APPEND,\n\t};\n\tstruct mlx5_flow_destination dest = {\n\t\t.type = MLX5_FLOW_DESTINATION_TYPE_VPORT,\n\t\t.vport.num = port->vport_num,\n\t};\n\tstruct mlx5_esw_bridge *bridge = port->bridge;\n\tstruct mlx5_flow_spec *rule_spec;\n\tstruct mlx5_flow_handle *handle;\n\n\trule_spec = kvzalloc(sizeof(*rule_spec), GFP_KERNEL);\n\tif (!rule_spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (MLX5_CAP_ESW_FLOWTABLE(bridge->br_offloads->esw->dev, flow_source) &&\n\t    port->vport_num == MLX5_VPORT_UPLINK)\n\t\trule_spec->flow_context.flow_source =\n\t\t\tMLX5_FLOW_CONTEXT_FLOW_SOURCE_LOCAL_VPORT;\n\n\tif (MLX5_CAP_ESW(bridge->br_offloads->esw->dev, merged_eswitch)) {\n\t\tdest.vport.flags = MLX5_FLOW_DEST_VPORT_VHCA_ID;\n\t\tdest.vport.vhca_id = port->esw_owner_vhca_id;\n\t}\n\thandle = mlx5_add_flow_rules(port->mcast.ft, rule_spec, &flow_act, &dest, 1);\n\n\tkvfree(rule_spec);\n\treturn handle;\n}\n\nstatic int mlx5_esw_bridge_port_mcast_fhs_init(struct mlx5_esw_bridge_port *port)\n{\n\tstruct mlx5_flow_handle *filter_handle, *fwd_handle;\n\tstruct mlx5_esw_bridge_vlan *vlan, *failed;\n\tunsigned long index;\n\tint err;\n\n\n\tfilter_handle = (port->flags & MLX5_ESW_BRIDGE_PORT_FLAG_PEER) ?\n\t\tmlx5_esw_bridge_mcast_filter_flow_peer_create(port) :\n\t\tmlx5_esw_bridge_mcast_filter_flow_create(port);\n\tif (IS_ERR(filter_handle))\n\t\treturn PTR_ERR(filter_handle);\n\n\tfwd_handle = mlx5_esw_bridge_mcast_fwd_flow_create(port);\n\tif (IS_ERR(fwd_handle)) {\n\t\terr = PTR_ERR(fwd_handle);\n\t\tgoto err_fwd;\n\t}\n\n\txa_for_each(&port->vlans, index, vlan) {\n\t\terr = mlx5_esw_bridge_vlan_mcast_init(port->bridge->vlan_proto, port, vlan);\n\t\tif (err) {\n\t\t\tfailed = vlan;\n\t\t\tgoto err_vlan;\n\t\t}\n\t}\n\n\tport->mcast.filter_handle = filter_handle;\n\tport->mcast.fwd_handle = fwd_handle;\n\n\treturn 0;\n\nerr_vlan:\n\txa_for_each(&port->vlans, index, vlan) {\n\t\tif (vlan == failed)\n\t\t\tbreak;\n\n\t\tmlx5_esw_bridge_vlan_mcast_cleanup(vlan);\n\t}\n\tmlx5_del_flow_rules(fwd_handle);\nerr_fwd:\n\tmlx5_del_flow_rules(filter_handle);\n\treturn err;\n}\n\nstatic void mlx5_esw_bridge_port_mcast_fhs_cleanup(struct mlx5_esw_bridge_port *port)\n{\n\tstruct mlx5_esw_bridge_vlan *vlan;\n\tunsigned long index;\n\n\txa_for_each(&port->vlans, index, vlan)\n\t\tmlx5_esw_bridge_vlan_mcast_cleanup(vlan);\n\n\tif (port->mcast.fwd_handle)\n\t\tmlx5_del_flow_rules(port->mcast.fwd_handle);\n\tport->mcast.fwd_handle = NULL;\n\tif (port->mcast.filter_handle)\n\t\tmlx5_del_flow_rules(port->mcast.filter_handle);\n\tport->mcast.filter_handle = NULL;\n}\n\nint mlx5_esw_bridge_port_mcast_init(struct mlx5_esw_bridge_port *port)\n{\n\tstruct mlx5_esw_bridge *bridge = port->bridge;\n\tint err;\n\n\tif (!(bridge->flags & MLX5_ESW_BRIDGE_MCAST_FLAG))\n\t\treturn 0;\n\n\terr = mlx5_esw_bridge_port_mcast_fts_init(port, bridge);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5_esw_bridge_port_mcast_fgs_init(port);\n\tif (err)\n\t\tgoto err_fgs;\n\n\terr = mlx5_esw_bridge_port_mcast_fhs_init(port);\n\tif (err)\n\t\tgoto err_fhs;\n\treturn err;\n\nerr_fhs:\n\tmlx5_esw_bridge_port_mcast_fgs_cleanup(port);\nerr_fgs:\n\tmlx5_esw_bridge_port_mcast_fts_cleanup(port);\n\treturn err;\n}\n\nvoid mlx5_esw_bridge_port_mcast_cleanup(struct mlx5_esw_bridge_port *port)\n{\n\tmlx5_esw_bridge_port_mdb_flush(port);\n\tmlx5_esw_bridge_port_mcast_fhs_cleanup(port);\n\tmlx5_esw_bridge_port_mcast_fgs_cleanup(port);\n\tmlx5_esw_bridge_port_mcast_fts_cleanup(port);\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_ingress_igmp_fg_create(struct mlx5_eswitch *esw,\n\t\t\t\t       struct mlx5_flow_table *ingress_ft)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fg;\n\tu32 *in, *match;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tMLX5_SET(create_flow_group_in, in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);\n\tmatch = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.ip_version);\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.ip_protocol);\n\n\tMLX5_SET(create_flow_group_in, in, start_flow_index,\n\t\t MLX5_ESW_BRIDGE_INGRESS_TABLE_IGMP_GRP_IDX_FROM);\n\tMLX5_SET(create_flow_group_in, in, end_flow_index,\n\t\t MLX5_ESW_BRIDGE_INGRESS_TABLE_IGMP_GRP_IDX_TO);\n\n\tfg = mlx5_create_flow_group(ingress_ft, in);\n\tkvfree(in);\n\tif (IS_ERR(fg))\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to create IGMP flow group for bridge ingress table (err=%pe)\\n\",\n\t\t\t fg);\n\n\treturn fg;\n}\n\nstatic struct mlx5_flow_group *\nmlx5_esw_bridge_ingress_mld_fg_create(struct mlx5_eswitch *esw,\n\t\t\t\t      struct mlx5_flow_table *ingress_ft)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fg;\n\tu32 *in, *match;\n\n\tif (!(MLX5_CAP_GEN(esw->dev, flex_parser_protocols) & MLX5_FLEX_PROTO_ICMPV6)) {\n\t\tesw_warn(esw->dev,\n\t\t\t \"Can't create MLD flow group due to missing hardware ICMPv6 parsing support\\n\");\n\t\treturn NULL;\n\t}\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tMLX5_SET(create_flow_group_in, in, match_criteria_enable,\n\t\t MLX5_MATCH_OUTER_HEADERS | MLX5_MATCH_MISC_PARAMETERS_3);\n\tmatch = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\n\tMLX5_SET_TO_ONES(fte_match_param, match, outer_headers.ip_version);\n\tMLX5_SET_TO_ONES(fte_match_param, match, misc_parameters_3.icmpv6_type);\n\n\tMLX5_SET(create_flow_group_in, in, start_flow_index,\n\t\t MLX5_ESW_BRIDGE_INGRESS_TABLE_MLD_GRP_IDX_FROM);\n\tMLX5_SET(create_flow_group_in, in, end_flow_index,\n\t\t MLX5_ESW_BRIDGE_INGRESS_TABLE_MLD_GRP_IDX_TO);\n\n\tfg = mlx5_create_flow_group(ingress_ft, in);\n\tkvfree(in);\n\tif (IS_ERR(fg))\n\t\tesw_warn(esw->dev,\n\t\t\t \"Failed to create MLD flow group for bridge ingress table (err=%pe)\\n\",\n\t\t\t fg);\n\n\treturn fg;\n}\n\nstatic int\nmlx5_esw_bridge_ingress_mcast_fgs_init(struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_flow_table *ingress_ft = br_offloads->ingress_ft;\n\tstruct mlx5_eswitch *esw = br_offloads->esw;\n\tstruct mlx5_flow_group *igmp_fg, *mld_fg;\n\n\tigmp_fg = mlx5_esw_bridge_ingress_igmp_fg_create(esw, ingress_ft);\n\tif (IS_ERR(igmp_fg))\n\t\treturn PTR_ERR(igmp_fg);\n\n\tmld_fg = mlx5_esw_bridge_ingress_mld_fg_create(esw, ingress_ft);\n\tif (IS_ERR(mld_fg)) {\n\t\tmlx5_destroy_flow_group(igmp_fg);\n\t\treturn PTR_ERR(mld_fg);\n\t}\n\n\tbr_offloads->ingress_igmp_fg = igmp_fg;\n\tbr_offloads->ingress_mld_fg = mld_fg;\n\treturn 0;\n}\n\nstatic void\nmlx5_esw_bridge_ingress_mcast_fgs_cleanup(struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tif (br_offloads->ingress_mld_fg)\n\t\tmlx5_destroy_flow_group(br_offloads->ingress_mld_fg);\n\tbr_offloads->ingress_mld_fg = NULL;\n\tif (br_offloads->ingress_igmp_fg)\n\t\tmlx5_destroy_flow_group(br_offloads->ingress_igmp_fg);\n\tbr_offloads->ingress_igmp_fg = NULL;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_ingress_igmp_fh_create(struct mlx5_flow_table *ingress_ft,\n\t\t\t\t       struct mlx5_flow_table *skip_ft)\n{\n\tstruct mlx5_flow_destination dest = {\n\t\t.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE,\n\t\t.ft = skip_ft,\n\t};\n\tstruct mlx5_flow_act flow_act = {\n\t\t.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST,\n\t\t.flags = FLOW_ACT_NO_APPEND,\n\t};\n\tstruct mlx5_flow_spec *rule_spec;\n\tstruct mlx5_flow_handle *handle;\n\n\trule_spec = kvzalloc(sizeof(*rule_spec), GFP_KERNEL);\n\tif (!rule_spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trule_spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\n\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria, outer_headers.ip_version);\n\tMLX5_SET(fte_match_param, rule_spec->match_value, outer_headers.ip_version, 4);\n\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria, outer_headers.ip_protocol);\n\tMLX5_SET(fte_match_param, rule_spec->match_value, outer_headers.ip_protocol, IPPROTO_IGMP);\n\n\thandle = mlx5_add_flow_rules(ingress_ft, rule_spec, &flow_act, &dest, 1);\n\n\tkvfree(rule_spec);\n\treturn handle;\n}\n\nstatic struct mlx5_flow_handle *\nmlx5_esw_bridge_ingress_mld_fh_create(u8 type, struct mlx5_flow_table *ingress_ft,\n\t\t\t\t      struct mlx5_flow_table *skip_ft)\n{\n\tstruct mlx5_flow_destination dest = {\n\t\t.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE,\n\t\t.ft = skip_ft,\n\t};\n\tstruct mlx5_flow_act flow_act = {\n\t\t.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST,\n\t\t.flags = FLOW_ACT_NO_APPEND,\n\t};\n\tstruct mlx5_flow_spec *rule_spec;\n\tstruct mlx5_flow_handle *handle;\n\n\trule_spec = kvzalloc(sizeof(*rule_spec), GFP_KERNEL);\n\tif (!rule_spec)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trule_spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS | MLX5_MATCH_MISC_PARAMETERS_3;\n\n\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria, outer_headers.ip_version);\n\tMLX5_SET(fte_match_param, rule_spec->match_value, outer_headers.ip_version, 6);\n\tMLX5_SET_TO_ONES(fte_match_param, rule_spec->match_criteria, misc_parameters_3.icmpv6_type);\n\tMLX5_SET(fte_match_param, rule_spec->match_value, misc_parameters_3.icmpv6_type, type);\n\n\thandle = mlx5_add_flow_rules(ingress_ft, rule_spec, &flow_act, &dest, 1);\n\n\tkvfree(rule_spec);\n\treturn handle;\n}\n\nstatic int\nmlx5_esw_bridge_ingress_mcast_fhs_create(struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_flow_handle *igmp_handle, *mld_query_handle, *mld_report_handle,\n\t\t*mld_done_handle;\n\tstruct mlx5_flow_table *ingress_ft = br_offloads->ingress_ft,\n\t\t*skip_ft = br_offloads->skip_ft;\n\tint err;\n\n\tigmp_handle = mlx5_esw_bridge_ingress_igmp_fh_create(ingress_ft, skip_ft);\n\tif (IS_ERR(igmp_handle))\n\t\treturn PTR_ERR(igmp_handle);\n\n\tif (br_offloads->ingress_mld_fg) {\n\t\tmld_query_handle = mlx5_esw_bridge_ingress_mld_fh_create(ICMPV6_MGM_QUERY,\n\t\t\t\t\t\t\t\t\t ingress_ft,\n\t\t\t\t\t\t\t\t\t skip_ft);\n\t\tif (IS_ERR(mld_query_handle)) {\n\t\t\terr = PTR_ERR(mld_query_handle);\n\t\t\tgoto err_mld_query;\n\t\t}\n\n\t\tmld_report_handle = mlx5_esw_bridge_ingress_mld_fh_create(ICMPV6_MGM_REPORT,\n\t\t\t\t\t\t\t\t\t  ingress_ft,\n\t\t\t\t\t\t\t\t\t  skip_ft);\n\t\tif (IS_ERR(mld_report_handle)) {\n\t\t\terr = PTR_ERR(mld_report_handle);\n\t\t\tgoto err_mld_report;\n\t\t}\n\n\t\tmld_done_handle = mlx5_esw_bridge_ingress_mld_fh_create(ICMPV6_MGM_REDUCTION,\n\t\t\t\t\t\t\t\t\tingress_ft,\n\t\t\t\t\t\t\t\t\tskip_ft);\n\t\tif (IS_ERR(mld_done_handle)) {\n\t\t\terr = PTR_ERR(mld_done_handle);\n\t\t\tgoto err_mld_done;\n\t\t}\n\t} else {\n\t\tmld_query_handle = NULL;\n\t\tmld_report_handle = NULL;\n\t\tmld_done_handle = NULL;\n\t}\n\n\tbr_offloads->igmp_handle = igmp_handle;\n\tbr_offloads->mld_query_handle = mld_query_handle;\n\tbr_offloads->mld_report_handle = mld_report_handle;\n\tbr_offloads->mld_done_handle = mld_done_handle;\n\n\treturn 0;\n\nerr_mld_done:\n\tmlx5_del_flow_rules(mld_report_handle);\nerr_mld_report:\n\tmlx5_del_flow_rules(mld_query_handle);\nerr_mld_query:\n\tmlx5_del_flow_rules(igmp_handle);\n\treturn err;\n}\n\nstatic void\nmlx5_esw_bridge_ingress_mcast_fhs_cleanup(struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tif (br_offloads->mld_done_handle)\n\t\tmlx5_del_flow_rules(br_offloads->mld_done_handle);\n\tbr_offloads->mld_done_handle = NULL;\n\tif (br_offloads->mld_report_handle)\n\t\tmlx5_del_flow_rules(br_offloads->mld_report_handle);\n\tbr_offloads->mld_report_handle = NULL;\n\tif (br_offloads->mld_query_handle)\n\t\tmlx5_del_flow_rules(br_offloads->mld_query_handle);\n\tbr_offloads->mld_query_handle = NULL;\n\tif (br_offloads->igmp_handle)\n\t\tmlx5_del_flow_rules(br_offloads->igmp_handle);\n\tbr_offloads->igmp_handle = NULL;\n}\n\nstatic int mlx5_esw_brige_mcast_init(struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_esw_bridge_offloads *br_offloads = bridge->br_offloads;\n\tstruct mlx5_esw_bridge_port *port, *failed;\n\tunsigned long i;\n\tint err;\n\n\txa_for_each(&br_offloads->ports, i, port) {\n\t\tif (port->bridge != bridge)\n\t\t\tcontinue;\n\n\t\terr = mlx5_esw_bridge_port_mcast_init(port);\n\t\tif (err) {\n\t\t\tfailed = port;\n\t\t\tgoto err_port;\n\t\t}\n\t}\n\treturn 0;\n\nerr_port:\n\txa_for_each(&br_offloads->ports, i, port) {\n\t\tif (port == failed)\n\t\t\tbreak;\n\t\tif (port->bridge != bridge)\n\t\t\tcontinue;\n\n\t\tmlx5_esw_bridge_port_mcast_cleanup(port);\n\t}\n\treturn err;\n}\n\nstatic void mlx5_esw_brige_mcast_cleanup(struct mlx5_esw_bridge *bridge)\n{\n\tstruct mlx5_esw_bridge_offloads *br_offloads = bridge->br_offloads;\n\tstruct mlx5_esw_bridge_port *port;\n\tunsigned long i;\n\n\txa_for_each(&br_offloads->ports, i, port) {\n\t\tif (port->bridge != bridge)\n\t\t\tcontinue;\n\n\t\tmlx5_esw_bridge_port_mcast_cleanup(port);\n\t}\n}\n\nstatic int mlx5_esw_brige_mcast_global_enable(struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tint err;\n\n\tif (br_offloads->ingress_igmp_fg)\n\t\treturn 0;  \n\n\terr = mlx5_esw_bridge_ingress_mcast_fgs_init(br_offloads);\n\tif (err) {\n\t\tesw_warn(br_offloads->esw->dev,\n\t\t\t \"Failed to create global multicast flow groups (err=%d)\\n\",\n\t\t\t err);\n\t\treturn err;\n\t}\n\n\terr = mlx5_esw_bridge_ingress_mcast_fhs_create(br_offloads);\n\tif (err) {\n\t\tesw_warn(br_offloads->esw->dev,\n\t\t\t \"Failed to create global multicast flows (err=%d)\\n\",\n\t\t\t err);\n\t\tgoto err_fhs;\n\t}\n\n\treturn 0;\n\nerr_fhs:\n\tmlx5_esw_bridge_ingress_mcast_fgs_cleanup(br_offloads);\n\treturn err;\n}\n\nstatic void mlx5_esw_brige_mcast_global_disable(struct mlx5_esw_bridge_offloads *br_offloads)\n{\n\tstruct mlx5_esw_bridge *br;\n\n\tlist_for_each_entry(br, &br_offloads->bridges, list) {\n\t\t \n\t\tif (br->flags & MLX5_ESW_BRIDGE_MCAST_FLAG)\n\t\t\treturn;\n\t}\n\n\tmlx5_esw_bridge_ingress_mcast_fhs_cleanup(br_offloads);\n\tmlx5_esw_bridge_ingress_mcast_fgs_cleanup(br_offloads);\n}\n\nint mlx5_esw_bridge_mcast_enable(struct mlx5_esw_bridge *bridge)\n{\n\tint err;\n\n\terr = mlx5_esw_brige_mcast_global_enable(bridge->br_offloads);\n\tif (err)\n\t\treturn err;\n\n\tbridge->flags |= MLX5_ESW_BRIDGE_MCAST_FLAG;\n\n\terr = mlx5_esw_brige_mcast_init(bridge);\n\tif (err) {\n\t\tesw_warn(bridge->br_offloads->esw->dev, \"Failed to enable multicast (err=%d)\\n\",\n\t\t\t err);\n\t\tbridge->flags &= ~MLX5_ESW_BRIDGE_MCAST_FLAG;\n\t\tmlx5_esw_brige_mcast_global_disable(bridge->br_offloads);\n\t}\n\treturn err;\n}\n\nvoid mlx5_esw_bridge_mcast_disable(struct mlx5_esw_bridge *bridge)\n{\n\tmlx5_esw_brige_mcast_cleanup(bridge);\n\tbridge->flags &= ~MLX5_ESW_BRIDGE_MCAST_FLAG;\n\tmlx5_esw_brige_mcast_global_disable(bridge->br_offloads);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}