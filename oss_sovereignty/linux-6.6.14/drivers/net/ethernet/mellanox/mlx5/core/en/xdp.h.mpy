{
  "module_name": "xdp.h",
  "hash_id": "a3e47ce0d884cf896f4faf68ad574a182a76c2b329cf791ca1ffe24e9e83c46f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en/xdp.h",
  "human_readable_source": " \n#ifndef __MLX5_EN_XDP_H__\n#define __MLX5_EN_XDP_H__\n\n#include <linux/indirect_call_wrapper.h>\n\n#include \"en.h\"\n#include \"en/txrx.h\"\n\n#define MLX5E_XDP_MIN_INLINE (ETH_HLEN + VLAN_HLEN)\n\n#define MLX5E_XDP_INLINE_WQE_MAX_DS_CNT 16\n#define MLX5E_XDP_INLINE_WQE_SZ_THRSD \\\n\t(MLX5E_XDP_INLINE_WQE_MAX_DS_CNT * MLX5_SEND_WQE_DS - \\\n\t sizeof(struct mlx5_wqe_inline_seg))\n\nstruct mlx5e_xdp_buff {\n\tstruct xdp_buff xdp;\n\tstruct mlx5_cqe64 *cqe;\n\tstruct mlx5e_rq *rq;\n};\n\n \nenum mlx5e_xdp_xmit_mode {\n\t \n\tMLX5E_XDP_XMIT_MODE_FRAME,\n\n\t \n\tMLX5E_XDP_XMIT_MODE_PAGE,\n\n\t \n\tMLX5E_XDP_XMIT_MODE_XSK,\n};\n\n \n#define MLX5E_XDP_FIFO_ENTRIES2DS_MAX_RATIO 4\n\nunion mlx5e_xdp_info {\n\tenum mlx5e_xdp_xmit_mode mode;\n\tunion {\n\t\tstruct xdp_frame *xdpf;\n\t\tdma_addr_t dma_addr;\n\t} frame;\n\tunion {\n\t\tstruct mlx5e_rq *rq;\n\t\tu8 num;\n\t\tstruct page *page;\n\t} page;\n};\n\nstruct mlx5e_xsk_param;\nint mlx5e_xdp_max_mtu(struct mlx5e_params *params, struct mlx5e_xsk_param *xsk);\nbool mlx5e_xdp_handle(struct mlx5e_rq *rq,\n\t\t      struct bpf_prog *prog, struct mlx5e_xdp_buff *mlctx);\nvoid mlx5e_xdp_mpwqe_complete(struct mlx5e_xdpsq *sq);\nbool mlx5e_poll_xdpsq_cq(struct mlx5e_cq *cq);\nvoid mlx5e_free_xdpsq_descs(struct mlx5e_xdpsq *sq);\nvoid mlx5e_set_xmit_fp(struct mlx5e_xdpsq *sq, bool is_mpw);\nvoid mlx5e_xdp_rx_poll_complete(struct mlx5e_rq *rq);\nint mlx5e_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **frames,\n\t\t   u32 flags);\n\nextern const struct xdp_metadata_ops mlx5e_xdp_metadata_ops;\n\nINDIRECT_CALLABLE_DECLARE(bool mlx5e_xmit_xdp_frame_mpwqe(struct mlx5e_xdpsq *sq,\n\t\t\t\t\t\t\t  struct mlx5e_xmit_data *xdptxd,\n\t\t\t\t\t\t\t  int check_result));\nINDIRECT_CALLABLE_DECLARE(bool mlx5e_xmit_xdp_frame(struct mlx5e_xdpsq *sq,\n\t\t\t\t\t\t    struct mlx5e_xmit_data *xdptxd,\n\t\t\t\t\t\t    int check_result));\nINDIRECT_CALLABLE_DECLARE(int mlx5e_xmit_xdp_frame_check_mpwqe(struct mlx5e_xdpsq *sq));\nINDIRECT_CALLABLE_DECLARE(int mlx5e_xmit_xdp_frame_check(struct mlx5e_xdpsq *sq));\n\nstatic inline void mlx5e_xdp_tx_enable(struct mlx5e_priv *priv)\n{\n\tset_bit(MLX5E_STATE_XDP_TX_ENABLED, &priv->state);\n\n\tif (priv->channels.params.xdp_prog)\n\t\tset_bit(MLX5E_STATE_XDP_ACTIVE, &priv->state);\n}\n\nstatic inline void mlx5e_xdp_tx_disable(struct mlx5e_priv *priv)\n{\n\tif (priv->channels.params.xdp_prog)\n\t\tclear_bit(MLX5E_STATE_XDP_ACTIVE, &priv->state);\n\n\tclear_bit(MLX5E_STATE_XDP_TX_ENABLED, &priv->state);\n\t \n\tsynchronize_net();\n}\n\nstatic inline bool mlx5e_xdp_tx_is_enabled(struct mlx5e_priv *priv)\n{\n\treturn test_bit(MLX5E_STATE_XDP_TX_ENABLED, &priv->state);\n}\n\nstatic inline bool mlx5e_xdp_is_active(struct mlx5e_priv *priv)\n{\n\treturn test_bit(MLX5E_STATE_XDP_ACTIVE, &priv->state);\n}\n\nstatic inline void mlx5e_xmit_xdp_doorbell(struct mlx5e_xdpsq *sq)\n{\n\tif (sq->doorbell_cseg) {\n\t\tmlx5e_notify_hw(&sq->wq, sq->pc, sq->uar_map, sq->doorbell_cseg);\n\t\tsq->doorbell_cseg = NULL;\n\t}\n}\n\n \nstatic inline bool mlx5e_xdp_get_inline_state(struct mlx5e_xdpsq *sq, bool cur)\n{\n\tu16 outstanding = sq->xdpi_fifo_pc - sq->xdpi_fifo_cc;\n\n#define MLX5E_XDP_INLINE_WATERMARK_LOW\t10\n#define MLX5E_XDP_INLINE_WATERMARK_HIGH 128\n\n\tif (cur && outstanding <= MLX5E_XDP_INLINE_WATERMARK_LOW)\n\t\treturn false;\n\n\tif (!cur && outstanding >= MLX5E_XDP_INLINE_WATERMARK_HIGH)\n\t\treturn true;\n\n\treturn cur;\n}\n\nstatic inline bool mlx5e_xdp_mpwqe_is_full(struct mlx5e_tx_mpwqe *session, u8 max_sq_mpw_wqebbs)\n{\n\tif (session->inline_on)\n\t\treturn session->ds_count + MLX5E_XDP_INLINE_WQE_MAX_DS_CNT >\n\t\t       max_sq_mpw_wqebbs * MLX5_SEND_WQEBB_NUM_DS;\n\n\treturn mlx5e_tx_mpwqe_is_full(session, max_sq_mpw_wqebbs);\n}\n\nstruct mlx5e_xdp_wqe_info {\n\tu8 num_wqebbs;\n\tu8 num_pkts;\n};\n\nstatic inline void\nmlx5e_xdp_mpwqe_add_dseg(struct mlx5e_xdpsq *sq,\n\t\t\t struct mlx5e_xmit_data *xdptxd,\n\t\t\t struct mlx5e_xdpsq_stats *stats)\n{\n\tstruct mlx5e_tx_mpwqe *session = &sq->mpwqe;\n\tstruct mlx5_wqe_data_seg *dseg =\n\t\t(struct mlx5_wqe_data_seg *)session->wqe + session->ds_count;\n\tu32 dma_len = xdptxd->len;\n\n\tsession->pkt_count++;\n\tsession->bytes_count += dma_len;\n\n\tif (session->inline_on && dma_len <= MLX5E_XDP_INLINE_WQE_SZ_THRSD) {\n\t\tstruct mlx5_wqe_inline_seg *inline_dseg =\n\t\t\t(struct mlx5_wqe_inline_seg *)dseg;\n\t\tu16 ds_len = sizeof(*inline_dseg) + dma_len;\n\t\tu16 ds_cnt = DIV_ROUND_UP(ds_len, MLX5_SEND_WQE_DS);\n\n\t\tinline_dseg->byte_count = cpu_to_be32(dma_len | MLX5_INLINE_SEG);\n\t\tmemcpy(inline_dseg->data, xdptxd->data, dma_len);\n\n\t\tsession->ds_count += ds_cnt;\n\t\tstats->inlnw++;\n\t\treturn;\n\t}\n\n\tdseg->addr       = cpu_to_be64(xdptxd->dma_addr);\n\tdseg->byte_count = cpu_to_be32(dma_len);\n\tdseg->lkey       = sq->mkey_be;\n\tsession->ds_count++;\n}\n\nstatic inline void\nmlx5e_xdpi_fifo_push(struct mlx5e_xdp_info_fifo *fifo,\n\t\t     union mlx5e_xdp_info xi)\n{\n\tu32 i = (*fifo->pc)++ & fifo->mask;\n\n\tfifo->xi[i] = xi;\n}\n\nstatic inline union mlx5e_xdp_info\nmlx5e_xdpi_fifo_pop(struct mlx5e_xdp_info_fifo *fifo)\n{\n\treturn fifo->xi[(*fifo->cc)++ & fifo->mask];\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}