{
  "module_name": "core.c",
  "hash_id": "95b9223ef778812bda4e15776365e4b98b068943ede74d1332e6172035f1d9a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/fpga/core.c",
  "human_readable_source": " \n\n#include <linux/etherdevice.h>\n#include <linux/mlx5/driver.h>\n\n#include \"mlx5_core.h\"\n#include \"lib/mlx5.h\"\n#include \"lib/eq.h\"\n#include \"fpga/core.h\"\n#include \"fpga/conn.h\"\n\nstatic const char *const mlx5_fpga_error_strings[] = {\n\t\"Null Syndrome\",\n\t\"Corrupted DDR\",\n\t\"Flash Timeout\",\n\t\"Internal Link Error\",\n\t\"Watchdog HW Failure\",\n\t\"I2C Failure\",\n\t\"Image Changed\",\n\t\"Temperature Critical\",\n};\n\nstatic const char * const mlx5_fpga_qp_error_strings[] = {\n\t\"Null Syndrome\",\n\t\"Retry Counter Expired\",\n\t\"RNR Expired\",\n};\nstatic struct mlx5_fpga_device *mlx5_fpga_device_alloc(void)\n{\n\tstruct mlx5_fpga_device *fdev;\n\n\tfdev = kzalloc(sizeof(*fdev), GFP_KERNEL);\n\tif (!fdev)\n\t\treturn NULL;\n\n\tspin_lock_init(&fdev->state_lock);\n\tfdev->state = MLX5_FPGA_STATUS_NONE;\n\treturn fdev;\n}\n\nstatic const char *mlx5_fpga_image_name(enum mlx5_fpga_image image)\n{\n\tswitch (image) {\n\tcase MLX5_FPGA_IMAGE_USER:\n\t\treturn \"user\";\n\tcase MLX5_FPGA_IMAGE_FACTORY:\n\t\treturn \"factory\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *mlx5_fpga_name(u32 fpga_id)\n{\n\tstatic char ret[32];\n\n\tswitch (fpga_id) {\n\tcase MLX5_FPGA_NEWTON:\n\t\treturn \"Newton\";\n\tcase MLX5_FPGA_EDISON:\n\t\treturn \"Edison\";\n\tcase MLX5_FPGA_MORSE:\n\t\treturn \"Morse\";\n\tcase MLX5_FPGA_MORSEQ:\n\t\treturn \"MorseQ\";\n\t}\n\n\tsnprintf(ret, sizeof(ret), \"Unknown %d\", fpga_id);\n\treturn ret;\n}\n\nstatic int mlx5_is_fpga_lookaside(u32 fpga_id)\n{\n\treturn fpga_id != MLX5_FPGA_NEWTON && fpga_id != MLX5_FPGA_EDISON;\n}\n\nstatic int mlx5_fpga_device_load_check(struct mlx5_fpga_device *fdev)\n{\n\tstruct mlx5_fpga_query query;\n\tint err;\n\n\terr = mlx5_fpga_query(fdev->mdev, &query);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to query status: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tfdev->last_admin_image = query.admin_image;\n\tfdev->last_oper_image = query.oper_image;\n\n\tmlx5_fpga_info(fdev, \"Status %u; Admin image %u; Oper image %u\\n\",\n\t\t       query.status, query.admin_image, query.oper_image);\n\n\t \n\tif (mlx5_is_fpga_lookaside(MLX5_CAP_FPGA(fdev->mdev, fpga_id)))\n\t\treturn 0;\n\n\tif (query.status != MLX5_FPGA_STATUS_SUCCESS) {\n\t\tmlx5_fpga_err(fdev, \"%s image failed to load; status %u\\n\",\n\t\t\t      mlx5_fpga_image_name(fdev->last_oper_image),\n\t\t\t      query.status);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx5_fpga_device_brb(struct mlx5_fpga_device *fdev)\n{\n\tint err;\n\tstruct mlx5_core_dev *mdev = fdev->mdev;\n\n\terr = mlx5_fpga_ctrl_op(mdev, MLX5_FPGA_CTRL_OPERATION_SANDBOX_BYPASS_ON);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to set bypass on: %d\\n\", err);\n\t\treturn err;\n\t}\n\terr = mlx5_fpga_ctrl_op(mdev, MLX5_FPGA_CTRL_OPERATION_RESET_SANDBOX);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to reset SBU: %d\\n\", err);\n\t\treturn err;\n\t}\n\terr = mlx5_fpga_ctrl_op(mdev, MLX5_FPGA_CTRL_OPERATION_SANDBOX_BYPASS_OFF);\n\tif (err) {\n\t\tmlx5_fpga_err(fdev, \"Failed to set bypass off: %d\\n\", err);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int mlx5_fpga_event(struct mlx5_fpga_device *, unsigned long, void *);\n\nstatic int fpga_err_event(struct notifier_block *nb, unsigned long event, void *eqe)\n{\n\tstruct mlx5_fpga_device *fdev = mlx5_nb_cof(nb, struct mlx5_fpga_device, fpga_err_nb);\n\n\treturn mlx5_fpga_event(fdev, event, eqe);\n}\n\nstatic int fpga_qp_err_event(struct notifier_block *nb, unsigned long event, void *eqe)\n{\n\tstruct mlx5_fpga_device *fdev = mlx5_nb_cof(nb, struct mlx5_fpga_device, fpga_qp_err_nb);\n\n\treturn mlx5_fpga_event(fdev, event, eqe);\n}\n\nint mlx5_fpga_device_start(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_fpga_device *fdev = mdev->fpga;\n\tunsigned int max_num_qps;\n\tunsigned long flags;\n\tu32 fpga_id;\n\tint err;\n\n\tif (!fdev)\n\t\treturn 0;\n\n\terr = mlx5_fpga_caps(fdev->mdev);\n\tif (err)\n\t\tgoto out;\n\n\terr = mlx5_fpga_device_load_check(fdev);\n\tif (err)\n\t\tgoto out;\n\n\tfpga_id = MLX5_CAP_FPGA(fdev->mdev, fpga_id);\n\tmlx5_fpga_info(fdev, \"FPGA card %s:%u\\n\", mlx5_fpga_name(fpga_id), fpga_id);\n\n\t \n\tif (mlx5_is_fpga_lookaside(fpga_id))\n\t\tgoto out;\n\n\tmlx5_fpga_info(fdev, \"%s(%d): image, version %u; SBU %06x:%04x version %d\\n\",\n\t\t       mlx5_fpga_image_name(fdev->last_oper_image),\n\t\t       fdev->last_oper_image,\n\t\t       MLX5_CAP_FPGA(fdev->mdev, image_version),\n\t\t       MLX5_CAP_FPGA(fdev->mdev, ieee_vendor_id),\n\t\t       MLX5_CAP_FPGA(fdev->mdev, sandbox_product_id),\n\t\t       MLX5_CAP_FPGA(fdev->mdev, sandbox_product_version));\n\n\tmax_num_qps = MLX5_CAP_FPGA(mdev, shell_caps.max_num_qps);\n\tif (!max_num_qps) {\n\t\tmlx5_fpga_err(fdev, \"FPGA reports 0 QPs in SHELL_CAPS\\n\");\n\t\terr = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = mlx5_core_reserve_gids(mdev, max_num_qps);\n\tif (err)\n\t\tgoto out;\n\n\tMLX5_NB_INIT(&fdev->fpga_err_nb, fpga_err_event, FPGA_ERROR);\n\tMLX5_NB_INIT(&fdev->fpga_qp_err_nb, fpga_qp_err_event, FPGA_QP_ERROR);\n\tmlx5_eq_notifier_register(fdev->mdev, &fdev->fpga_err_nb);\n\tmlx5_eq_notifier_register(fdev->mdev, &fdev->fpga_qp_err_nb);\n\n\terr = mlx5_fpga_conn_device_init(fdev);\n\tif (err)\n\t\tgoto err_rsvd_gid;\n\n\tif (fdev->last_oper_image == MLX5_FPGA_IMAGE_USER) {\n\t\terr = mlx5_fpga_device_brb(fdev);\n\t\tif (err)\n\t\t\tgoto err_conn_init;\n\t}\n\n\tgoto out;\n\nerr_conn_init:\n\tmlx5_fpga_conn_device_cleanup(fdev);\n\nerr_rsvd_gid:\n\tmlx5_eq_notifier_unregister(fdev->mdev, &fdev->fpga_err_nb);\n\tmlx5_eq_notifier_unregister(fdev->mdev, &fdev->fpga_qp_err_nb);\n\tmlx5_core_unreserve_gids(mdev, max_num_qps);\nout:\n\tspin_lock_irqsave(&fdev->state_lock, flags);\n\tfdev->state = err ? MLX5_FPGA_STATUS_FAILURE : MLX5_FPGA_STATUS_SUCCESS;\n\tspin_unlock_irqrestore(&fdev->state_lock, flags);\n\treturn err;\n}\n\nint mlx5_fpga_init(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_fpga_device *fdev;\n\n\tif (!MLX5_CAP_GEN(mdev, fpga)) {\n\t\tmlx5_core_dbg(mdev, \"FPGA capability not present\\n\");\n\t\treturn 0;\n\t}\n\n\tmlx5_core_dbg(mdev, \"Initializing FPGA\\n\");\n\n\tfdev = mlx5_fpga_device_alloc();\n\tif (!fdev)\n\t\treturn -ENOMEM;\n\n\tfdev->mdev = mdev;\n\tmdev->fpga = fdev;\n\n\treturn 0;\n}\n\nvoid mlx5_fpga_device_stop(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_fpga_device *fdev = mdev->fpga;\n\tunsigned int max_num_qps;\n\tunsigned long flags;\n\tint err;\n\n\tif (!fdev)\n\t\treturn;\n\n\tif (mlx5_is_fpga_lookaside(MLX5_CAP_FPGA(fdev->mdev, fpga_id)))\n\t\treturn;\n\n\tspin_lock_irqsave(&fdev->state_lock, flags);\n\tif (fdev->state != MLX5_FPGA_STATUS_SUCCESS) {\n\t\tspin_unlock_irqrestore(&fdev->state_lock, flags);\n\t\treturn;\n\t}\n\tfdev->state = MLX5_FPGA_STATUS_NONE;\n\tspin_unlock_irqrestore(&fdev->state_lock, flags);\n\n\tif (fdev->last_oper_image == MLX5_FPGA_IMAGE_USER) {\n\t\terr = mlx5_fpga_ctrl_op(mdev, MLX5_FPGA_CTRL_OPERATION_SANDBOX_BYPASS_ON);\n\t\tif (err)\n\t\t\tmlx5_fpga_err(fdev, \"Failed to re-set SBU bypass on: %d\\n\",\n\t\t\t\t      err);\n\t}\n\n\tmlx5_fpga_conn_device_cleanup(fdev);\n\tmlx5_eq_notifier_unregister(fdev->mdev, &fdev->fpga_err_nb);\n\tmlx5_eq_notifier_unregister(fdev->mdev, &fdev->fpga_qp_err_nb);\n\n\tmax_num_qps = MLX5_CAP_FPGA(mdev, shell_caps.max_num_qps);\n\tmlx5_core_unreserve_gids(mdev, max_num_qps);\n}\n\nvoid mlx5_fpga_cleanup(struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_fpga_device *fdev = mdev->fpga;\n\n\tmlx5_fpga_device_stop(mdev);\n\tkfree(fdev);\n\tmdev->fpga = NULL;\n}\n\nstatic const char *mlx5_fpga_syndrome_to_string(u8 syndrome)\n{\n\tif (syndrome < ARRAY_SIZE(mlx5_fpga_error_strings))\n\t\treturn mlx5_fpga_error_strings[syndrome];\n\treturn \"Unknown\";\n}\n\nstatic const char *mlx5_fpga_qp_syndrome_to_string(u8 syndrome)\n{\n\tif (syndrome < ARRAY_SIZE(mlx5_fpga_qp_error_strings))\n\t\treturn mlx5_fpga_qp_error_strings[syndrome];\n\treturn \"Unknown\";\n}\n\nstatic int mlx5_fpga_event(struct mlx5_fpga_device *fdev,\n\t\t\t   unsigned long event, void *eqe)\n{\n\tvoid *data = ((struct mlx5_eqe *)eqe)->data.raw;\n\tconst char *event_name;\n\tbool teardown = false;\n\tunsigned long flags;\n\tu8 syndrome;\n\n\tswitch (event) {\n\tcase MLX5_EVENT_TYPE_FPGA_ERROR:\n\t\tsyndrome = MLX5_GET(fpga_error_event, data, syndrome);\n\t\tevent_name = mlx5_fpga_syndrome_to_string(syndrome);\n\t\tbreak;\n\tcase MLX5_EVENT_TYPE_FPGA_QP_ERROR:\n\t\tsyndrome = MLX5_GET(fpga_qp_error_event, data, syndrome);\n\t\tevent_name = mlx5_fpga_qp_syndrome_to_string(syndrome);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tspin_lock_irqsave(&fdev->state_lock, flags);\n\tswitch (fdev->state) {\n\tcase MLX5_FPGA_STATUS_SUCCESS:\n\t\tmlx5_fpga_warn(fdev, \"Error %u: %s\\n\", syndrome, event_name);\n\t\tteardown = true;\n\t\tbreak;\n\tdefault:\n\t\tmlx5_fpga_warn_ratelimited(fdev, \"Unexpected error event %u: %s\\n\",\n\t\t\t\t\t   syndrome, event_name);\n\t}\n\tspin_unlock_irqrestore(&fdev->state_lock, flags);\n\t \n\tif (teardown)\n\t\tmlx5_trigger_health_work(fdev->mdev);\n\n\treturn NOTIFY_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}