{
  "module_name": "en_arfs.c",
  "hash_id": "ec4a8f9af339567cd5ea3d8ebb9b47fab3981d7eeba23f2f19e551921886090a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c",
  "human_readable_source": " \n\n#include <linux/hash.h>\n#include <linux/mlx5/fs.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include \"en.h\"\n\n#define ARFS_HASH_SHIFT BITS_PER_BYTE\n#define ARFS_HASH_SIZE BIT(BITS_PER_BYTE)\n\nstruct arfs_table {\n\tstruct mlx5e_flow_table  ft;\n\tstruct mlx5_flow_handle\t *default_rule;\n\tstruct hlist_head\t rules_hash[ARFS_HASH_SIZE];\n};\n\nenum arfs_type {\n\tARFS_IPV4_TCP,\n\tARFS_IPV6_TCP,\n\tARFS_IPV4_UDP,\n\tARFS_IPV6_UDP,\n\tARFS_NUM_TYPES,\n};\n\nstruct mlx5e_arfs_tables {\n\tstruct arfs_table arfs_tables[ARFS_NUM_TYPES];\n\t \n\tspinlock_t                     arfs_lock;\n\tint                            last_filter_id;\n\tstruct workqueue_struct        *wq;\n};\n\nstruct arfs_tuple {\n\t__be16 etype;\n\tu8     ip_proto;\n\tunion {\n\t\t__be32 src_ipv4;\n\t\tstruct in6_addr src_ipv6;\n\t};\n\tunion {\n\t\t__be32 dst_ipv4;\n\t\tstruct in6_addr dst_ipv6;\n\t};\n\t__be16 src_port;\n\t__be16 dst_port;\n};\n\nstruct arfs_rule {\n\tstruct mlx5e_priv\t*priv;\n\tstruct work_struct      arfs_work;\n\tstruct mlx5_flow_handle *rule;\n\tstruct hlist_node\thlist;\n\tint\t\t\trxq;\n\t \n\tint\t\t\tflow_id;\n\t \n\tint\t\t\tfilter_id;\n\tstruct arfs_tuple\ttuple;\n};\n\n#define mlx5e_for_each_arfs_rule(hn, tmp, arfs_tables, i, j) \\\n\tfor (i = 0; i < ARFS_NUM_TYPES; i++) \\\n\t\tmlx5e_for_each_hash_arfs_rule(hn, tmp, arfs_tables[i].rules_hash, j)\n\n#define mlx5e_for_each_hash_arfs_rule(hn, tmp, hash, j) \\\n\tfor (j = 0; j < ARFS_HASH_SIZE; j++) \\\n\t\thlist_for_each_entry_safe(hn, tmp, &hash[j], hlist)\n\nstatic enum mlx5_traffic_types arfs_get_tt(enum arfs_type type)\n{\n\tswitch (type) {\n\tcase ARFS_IPV4_TCP:\n\t\treturn MLX5_TT_IPV4_TCP;\n\tcase ARFS_IPV4_UDP:\n\t\treturn MLX5_TT_IPV4_UDP;\n\tcase ARFS_IPV6_TCP:\n\t\treturn MLX5_TT_IPV6_TCP;\n\tcase ARFS_IPV6_UDP:\n\t\treturn MLX5_TT_IPV6_UDP;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int arfs_disable(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);\n\tint err, i;\n\n\tfor (i = 0; i < ARFS_NUM_TYPES; i++) {\n\t\t \n\t\terr = mlx5_ttc_fwd_default_dest(ttc, arfs_get_tt(i));\n\t\tif (err) {\n\t\t\tfs_err(fs,\n\t\t\t       \"%s: modify ttc[%d] default destination failed, err(%d)\\n\",\n\t\t\t       __func__, arfs_get_tt(i), err);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void arfs_del_rules(struct mlx5e_flow_steering *fs);\n\nint mlx5e_arfs_disable(struct mlx5e_flow_steering *fs)\n{\n\t \n\tif (!mlx5e_fs_get_arfs(fs))\n\t\treturn 0;\n\n\tarfs_del_rules(fs);\n\n\treturn arfs_disable(fs);\n}\n\nint mlx5e_arfs_enable(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5_ttc_table *ttc = mlx5e_fs_get_ttc(fs, false);\n\tstruct mlx5e_arfs_tables *arfs =  mlx5e_fs_get_arfs(fs);\n\tstruct mlx5_flow_destination dest = {};\n\tint err, i;\n\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tfor (i = 0; i < ARFS_NUM_TYPES; i++) {\n\t\tdest.ft = arfs->arfs_tables[i].ft.t;\n\t\t \n\t\terr = mlx5_ttc_fwd_dest(ttc, arfs_get_tt(i), &dest);\n\t\tif (err) {\n\t\t\tfs_err(fs, \"%s: modify ttc[%d] dest to arfs, failed err(%d)\\n\",\n\t\t\t       __func__, arfs_get_tt(i), err);\n\t\t\tarfs_disable(fs);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void arfs_destroy_table(struct arfs_table *arfs_t)\n{\n\tmlx5_del_flow_rules(arfs_t->default_rule);\n\tmlx5e_destroy_flow_table(&arfs_t->ft);\n}\n\nstatic void _mlx5e_cleanup_tables(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5e_arfs_tables *arfs =  mlx5e_fs_get_arfs(fs);\n\tint i;\n\n\tarfs_del_rules(fs);\n\tdestroy_workqueue(arfs->wq);\n\tfor (i = 0; i < ARFS_NUM_TYPES; i++) {\n\t\tif (!IS_ERR_OR_NULL(arfs->arfs_tables[i].ft.t))\n\t\t\tarfs_destroy_table(&arfs->arfs_tables[i]);\n\t}\n}\n\nvoid mlx5e_arfs_destroy_tables(struct mlx5e_flow_steering *fs, bool ntuple)\n{\n\tstruct mlx5e_arfs_tables *arfs =  mlx5e_fs_get_arfs(fs);\n\n\tif (!ntuple)\n\t\treturn;\n\n\t_mlx5e_cleanup_tables(fs);\n\tmlx5e_fs_set_arfs(fs, NULL);\n\tkvfree(arfs);\n}\n\nstatic int arfs_add_default_rule(struct mlx5e_flow_steering *fs,\n\t\t\t\t struct mlx5e_rx_res *rx_res,\n\t\t\t\t enum arfs_type type)\n{\n\tstruct mlx5e_arfs_tables *arfs =  mlx5e_fs_get_arfs(fs);\n\tstruct arfs_table *arfs_t = &arfs->arfs_tables[type];\n\tstruct mlx5_flow_destination dest = {};\n\tMLX5_DECLARE_FLOW_ACT(flow_act);\n\tenum mlx5_traffic_types tt;\n\tint err = 0;\n\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;\n\ttt = arfs_get_tt(type);\n\tif (tt == -EINVAL) {\n\t\tfs_err(fs, \"%s: bad arfs_type: %d\\n\", __func__, type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdest.tir_num = mlx5e_rx_res_get_tirn_rss(rx_res, tt);\n\tarfs_t->default_rule = mlx5_add_flow_rules(arfs_t->ft.t, NULL,\n\t\t\t\t\t\t   &flow_act,\n\t\t\t\t\t\t   &dest, 1);\n\tif (IS_ERR(arfs_t->default_rule)) {\n\t\terr = PTR_ERR(arfs_t->default_rule);\n\t\tarfs_t->default_rule = NULL;\n\t\tfs_err(fs, \"%s: add rule failed, arfs type=%d\\n\", __func__, type);\n\t}\n\n\treturn err;\n}\n\n#define MLX5E_ARFS_NUM_GROUPS\t2\n#define MLX5E_ARFS_GROUP1_SIZE\t(BIT(16) - 1)\n#define MLX5E_ARFS_GROUP2_SIZE\tBIT(0)\n#define MLX5E_ARFS_TABLE_SIZE\t(MLX5E_ARFS_GROUP1_SIZE +\\\n\t\t\t\t MLX5E_ARFS_GROUP2_SIZE)\nstatic int arfs_create_groups(struct mlx5e_flow_table *ft,\n\t\t\t      enum  arfs_type type)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tvoid *outer_headers_c;\n\tint ix = 0;\n\tu32 *in;\n\tint err;\n\tu8 *mc;\n\n\tft->g = kcalloc(MLX5E_ARFS_NUM_GROUPS,\n\t\t\tsizeof(*ft->g), GFP_KERNEL);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif  (!in || !ft->g) {\n\t\tkfree(ft->g);\n\t\tkvfree(in);\n\t\treturn -ENOMEM;\n\t}\n\n\tmc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);\n\touter_headers_c = MLX5_ADDR_OF(fte_match_param, mc,\n\t\t\t\t       outer_headers);\n\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, ethertype);\n\tswitch (type) {\n\tcase ARFS_IPV4_TCP:\n\tcase ARFS_IPV6_TCP:\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, tcp_dport);\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, tcp_sport);\n\t\tbreak;\n\tcase ARFS_IPV4_UDP:\n\tcase ARFS_IPV6_UDP:\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, udp_dport);\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c, udp_sport);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase ARFS_IPV4_TCP:\n\tcase ARFS_IPV4_UDP:\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c,\n\t\t\t\t src_ipv4_src_ipv6.ipv4_layout.ipv4);\n\t\tMLX5_SET_TO_ONES(fte_match_set_lyr_2_4, outer_headers_c,\n\t\t\t\t dst_ipv4_dst_ipv6.ipv4_layout.ipv4);\n\t\tbreak;\n\tcase ARFS_IPV6_TCP:\n\tcase ARFS_IPV6_UDP:\n\t\tmemset(MLX5_ADDR_OF(fte_match_set_lyr_2_4, outer_headers_c,\n\t\t\t\t    src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t       0xff, 16);\n\t\tmemset(MLX5_ADDR_OF(fte_match_set_lyr_2_4, outer_headers_c,\n\t\t\t\t    dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t       0xff, 16);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tMLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5E_ARFS_GROUP1_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);\n\tif (IS_ERR(ft->g[ft->num_groups]))\n\t\tgoto err;\n\tft->num_groups++;\n\n\tmemset(in, 0, inlen);\n\tMLX5_SET_CFG(in, start_flow_index, ix);\n\tix += MLX5E_ARFS_GROUP2_SIZE;\n\tMLX5_SET_CFG(in, end_flow_index, ix - 1);\n\tft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);\n\tif (IS_ERR(ft->g[ft->num_groups]))\n\t\tgoto err;\n\tft->num_groups++;\n\n\tkvfree(in);\n\treturn 0;\n\nerr:\n\terr = PTR_ERR(ft->g[ft->num_groups]);\n\tft->g[ft->num_groups] = NULL;\nout:\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic int arfs_create_table(struct mlx5e_flow_steering *fs,\n\t\t\t     struct mlx5e_rx_res *rx_res,\n\t\t\t     enum arfs_type type)\n{\n\tstruct mlx5_flow_namespace *ns = mlx5e_fs_get_ns(fs, false);\n\tstruct mlx5e_arfs_tables *arfs = mlx5e_fs_get_arfs(fs);\n\tstruct mlx5e_flow_table *ft = &arfs->arfs_tables[type].ft;\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tint err;\n\n\tft->num_groups = 0;\n\n\tft_attr.max_fte = MLX5E_ARFS_TABLE_SIZE;\n\tft_attr.level = MLX5E_ARFS_FT_LEVEL;\n\tft_attr.prio = MLX5E_NIC_PRIO;\n\n\tft->t = mlx5_create_flow_table(ns, &ft_attr);\n\tif (IS_ERR(ft->t)) {\n\t\terr = PTR_ERR(ft->t);\n\t\tft->t = NULL;\n\t\treturn err;\n\t}\n\n\terr = arfs_create_groups(ft, type);\n\tif (err)\n\t\tgoto err;\n\n\terr = arfs_add_default_rule(fs, rx_res,  type);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tmlx5e_destroy_flow_table(ft);\n\treturn err;\n}\n\nint mlx5e_arfs_create_tables(struct mlx5e_flow_steering *fs,\n\t\t\t     struct mlx5e_rx_res *rx_res, bool ntuple)\n{\n\tstruct mlx5e_arfs_tables *arfs;\n\tint err = -ENOMEM;\n\tint i;\n\n\tif (!ntuple)\n\t\treturn 0;\n\n\tarfs = kvzalloc(sizeof(*arfs), GFP_KERNEL);\n\tif (!arfs)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&arfs->arfs_lock);\n\tarfs->wq = create_singlethread_workqueue(\"mlx5e_arfs\");\n\tif (!arfs->wq)\n\t\tgoto err;\n\n\tmlx5e_fs_set_arfs(fs, arfs);\n\n\tfor (i = 0; i < ARFS_NUM_TYPES; i++) {\n\t\terr = arfs_create_table(fs, rx_res, i);\n\t\tif (err)\n\t\t\tgoto err_des;\n\t}\n\treturn 0;\n\nerr_des:\n\t_mlx5e_cleanup_tables(fs);\nerr:\n\tmlx5e_fs_set_arfs(fs, NULL);\n\tkvfree(arfs);\n\treturn err;\n}\n\n#define MLX5E_ARFS_EXPIRY_QUOTA 60\n\nstatic void arfs_may_expire_flow(struct mlx5e_priv *priv)\n{\n\tstruct mlx5e_arfs_tables *arfs = mlx5e_fs_get_arfs(priv->fs);\n\tstruct arfs_rule *arfs_rule;\n\tstruct hlist_node *htmp;\n\tHLIST_HEAD(del_list);\n\tint quota = 0;\n\tint i;\n\tint j;\n\n\tspin_lock_bh(&arfs->arfs_lock);\n\tmlx5e_for_each_arfs_rule(arfs_rule, htmp, arfs->arfs_tables, i, j) {\n\t\tif (!work_pending(&arfs_rule->arfs_work) &&\n\t\t    rps_may_expire_flow(priv->netdev,\n\t\t\t\t\tarfs_rule->rxq, arfs_rule->flow_id,\n\t\t\t\t\tarfs_rule->filter_id)) {\n\t\t\thlist_del_init(&arfs_rule->hlist);\n\t\t\thlist_add_head(&arfs_rule->hlist, &del_list);\n\t\t\tif (quota++ > MLX5E_ARFS_EXPIRY_QUOTA)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&arfs->arfs_lock);\n\thlist_for_each_entry_safe(arfs_rule, htmp, &del_list, hlist) {\n\t\tif (arfs_rule->rule) {\n\t\t\tmlx5_del_flow_rules(arfs_rule->rule);\n\t\t\tpriv->channel_stats[arfs_rule->rxq]->rq.arfs_expired++;\n\t\t}\n\t\thlist_del(&arfs_rule->hlist);\n\t\tkfree(arfs_rule);\n\t}\n}\n\nstatic void arfs_del_rules(struct mlx5e_flow_steering *fs)\n{\n\tstruct mlx5e_arfs_tables *arfs = mlx5e_fs_get_arfs(fs);\n\tstruct hlist_node *htmp;\n\tstruct arfs_rule *rule;\n\tHLIST_HEAD(del_list);\n\tint i;\n\tint j;\n\n\tspin_lock_bh(&arfs->arfs_lock);\n\tmlx5e_for_each_arfs_rule(rule, htmp, arfs->arfs_tables, i, j) {\n\t\thlist_del_init(&rule->hlist);\n\t\thlist_add_head(&rule->hlist, &del_list);\n\t}\n\tspin_unlock_bh(&arfs->arfs_lock);\n\n\thlist_for_each_entry_safe(rule, htmp, &del_list, hlist) {\n\t\tcancel_work_sync(&rule->arfs_work);\n\t\tif (rule->rule)\n\t\t\tmlx5_del_flow_rules(rule->rule);\n\t\thlist_del(&rule->hlist);\n\t\tkfree(rule);\n\t}\n}\n\nstatic struct hlist_head *\narfs_hash_bucket(struct arfs_table *arfs_t, __be16 src_port,\n\t\t __be16 dst_port)\n{\n\tunsigned long l;\n\tint bucket_idx;\n\n\tl = (__force unsigned long)src_port |\n\t    ((__force unsigned long)dst_port << 2);\n\n\tbucket_idx = hash_long(l, ARFS_HASH_SHIFT);\n\n\treturn &arfs_t->rules_hash[bucket_idx];\n}\n\nstatic struct arfs_table *arfs_get_table(struct mlx5e_arfs_tables *arfs,\n\t\t\t\t\t u8 ip_proto, __be16 etype)\n{\n\tif (etype == htons(ETH_P_IP) && ip_proto == IPPROTO_TCP)\n\t\treturn &arfs->arfs_tables[ARFS_IPV4_TCP];\n\tif (etype == htons(ETH_P_IP) && ip_proto == IPPROTO_UDP)\n\t\treturn &arfs->arfs_tables[ARFS_IPV4_UDP];\n\tif (etype == htons(ETH_P_IPV6) && ip_proto == IPPROTO_TCP)\n\t\treturn &arfs->arfs_tables[ARFS_IPV6_TCP];\n\tif (etype == htons(ETH_P_IPV6) && ip_proto == IPPROTO_UDP)\n\t\treturn &arfs->arfs_tables[ARFS_IPV6_UDP];\n\n\treturn NULL;\n}\n\nstatic struct mlx5_flow_handle *arfs_add_rule(struct mlx5e_priv *priv,\n\t\t\t\t\t      struct arfs_rule *arfs_rule)\n{\n\tstruct mlx5e_arfs_tables *arfs = mlx5e_fs_get_arfs(priv->fs);\n\tstruct arfs_tuple *tuple = &arfs_rule->tuple;\n\tstruct mlx5_flow_handle *rule = NULL;\n\tstruct mlx5_flow_destination dest = {};\n\tMLX5_DECLARE_FLOW_ACT(flow_act);\n\tstruct arfs_table *arfs_table;\n\tstruct mlx5_flow_spec *spec;\n\tstruct mlx5_flow_table *ft;\n\tint err = 0;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\tif (!spec) {\n\t\tpriv->channel_stats[arfs_rule->rxq]->rq.arfs_err++;\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tspec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t outer_headers.ethertype);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ethertype,\n\t\t ntohs(tuple->etype));\n\tarfs_table = arfs_get_table(arfs, tuple->ip_proto, tuple->etype);\n\tif (!arfs_table) {\n\t\tWARN_ONCE(1, \"arfs table does not exist for etype %u and ip_proto %u\\n\",\n\t\t\t  tuple->etype, tuple->ip_proto);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tft = arfs_table->ft.t;\n\tif (tuple->ip_proto == IPPROTO_TCP) {\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t outer_headers.tcp_dport);\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t outer_headers.tcp_sport);\n\t\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.tcp_dport,\n\t\t\t ntohs(tuple->dst_port));\n\t\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.tcp_sport,\n\t\t\t ntohs(tuple->src_port));\n\t} else {\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t outer_headers.udp_dport);\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t outer_headers.udp_sport);\n\t\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.udp_dport,\n\t\t\t ntohs(tuple->dst_port));\n\t\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.udp_sport,\n\t\t\t ntohs(tuple->src_port));\n\t}\n\tif (tuple->etype == htons(ETH_P_IP)) {\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    outer_headers.src_ipv4_src_ipv6.ipv4_layout.ipv4),\n\t\t       &tuple->src_ipv4,\n\t\t       4);\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    outer_headers.dst_ipv4_dst_ipv6.ipv4_layout.ipv4),\n\t\t       &tuple->dst_ipv4,\n\t\t       4);\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t outer_headers.src_ipv4_src_ipv6.ipv4_layout.ipv4);\n\t\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t\t outer_headers.dst_ipv4_dst_ipv6.ipv4_layout.ipv4);\n\t} else {\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    outer_headers.src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t       &tuple->src_ipv6,\n\t\t       16);\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    outer_headers.dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t       &tuple->dst_ipv6,\n\t\t       16);\n\t\tmemset(MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t\t    outer_headers.src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t       0xff,\n\t\t       16);\n\t\tmemset(MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t\t    outer_headers.dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t       0xff,\n\t\t       16);\n\t}\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;\n\tdest.tir_num = mlx5e_rx_res_get_tirn_direct(priv->rx_res, arfs_rule->rxq);\n\trule = mlx5_add_flow_rules(ft, spec, &flow_act, &dest, 1);\n\tif (IS_ERR(rule)) {\n\t\terr = PTR_ERR(rule);\n\t\tpriv->channel_stats[arfs_rule->rxq]->rq.arfs_err++;\n\t\tnetdev_dbg(priv->netdev,\n\t\t\t   \"%s: add rule(filter id=%d, rq idx=%d, ip proto=0x%x) failed,err=%d\\n\",\n\t\t\t   __func__, arfs_rule->filter_id, arfs_rule->rxq,\n\t\t\t   tuple->ip_proto, err);\n\t}\n\nout:\n\tkvfree(spec);\n\treturn err ? ERR_PTR(err) : rule;\n}\n\nstatic void arfs_modify_rule_rq(struct mlx5e_priv *priv,\n\t\t\t\tstruct mlx5_flow_handle *rule, u16 rxq)\n{\n\tstruct mlx5_flow_destination dst = {};\n\tint err = 0;\n\n\tdst.type = MLX5_FLOW_DESTINATION_TYPE_TIR;\n\tdst.tir_num = mlx5e_rx_res_get_tirn_direct(priv->rx_res, rxq);\n\terr =  mlx5_modify_rule_destination(rule, &dst, NULL);\n\tif (err) {\n\t\tpriv->channel_stats[rxq]->rq.arfs_err++;\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Failed to modify aRFS rule destination to rq=%d\\n\", rxq);\n\t}\n}\n\nstatic void arfs_handle_work(struct work_struct *work)\n{\n\tstruct arfs_rule *arfs_rule = container_of(work,\n\t\t\t\t\t\t   struct arfs_rule,\n\t\t\t\t\t\t   arfs_work);\n\tstruct mlx5e_priv *priv = arfs_rule->priv;\n\tstruct mlx5e_arfs_tables *arfs;\n\tstruct mlx5_flow_handle *rule;\n\n\tarfs = mlx5e_fs_get_arfs(priv->fs);\n\tmutex_lock(&priv->state_lock);\n\tif (!test_bit(MLX5E_STATE_OPENED, &priv->state)) {\n\t\tspin_lock_bh(&arfs->arfs_lock);\n\t\thlist_del(&arfs_rule->hlist);\n\t\tspin_unlock_bh(&arfs->arfs_lock);\n\n\t\tmutex_unlock(&priv->state_lock);\n\t\tkfree(arfs_rule);\n\t\tgoto out;\n\t}\n\tmutex_unlock(&priv->state_lock);\n\n\tif (!arfs_rule->rule) {\n\t\trule = arfs_add_rule(priv, arfs_rule);\n\t\tif (IS_ERR(rule))\n\t\t\tgoto out;\n\t\tarfs_rule->rule = rule;\n\t\tpriv->channel_stats[arfs_rule->rxq]->rq.arfs_add++;\n\t} else {\n\t\tarfs_modify_rule_rq(priv, arfs_rule->rule,\n\t\t\t\t    arfs_rule->rxq);\n\t}\nout:\n\tarfs_may_expire_flow(priv);\n}\n\nstatic struct arfs_rule *arfs_alloc_rule(struct mlx5e_priv *priv,\n\t\t\t\t\t struct arfs_table *arfs_t,\n\t\t\t\t\t const struct flow_keys *fk,\n\t\t\t\t\t u16 rxq, u32 flow_id)\n{\n\tstruct mlx5e_arfs_tables *arfs =  mlx5e_fs_get_arfs(priv->fs);\n\tstruct arfs_rule *rule;\n\tstruct arfs_tuple *tuple;\n\n\trule = kzalloc(sizeof(*rule), GFP_ATOMIC);\n\tif (!rule) {\n\t\tpriv->channel_stats[rxq]->rq.arfs_err++;\n\t\treturn NULL;\n\t}\n\n\trule->priv = priv;\n\trule->rxq = rxq;\n\tINIT_WORK(&rule->arfs_work, arfs_handle_work);\n\n\ttuple = &rule->tuple;\n\ttuple->etype = fk->basic.n_proto;\n\ttuple->ip_proto = fk->basic.ip_proto;\n\tif (tuple->etype == htons(ETH_P_IP)) {\n\t\ttuple->src_ipv4 = fk->addrs.v4addrs.src;\n\t\ttuple->dst_ipv4 = fk->addrs.v4addrs.dst;\n\t} else {\n\t\tmemcpy(&tuple->src_ipv6, &fk->addrs.v6addrs.src,\n\t\t       sizeof(struct in6_addr));\n\t\tmemcpy(&tuple->dst_ipv6, &fk->addrs.v6addrs.dst,\n\t\t       sizeof(struct in6_addr));\n\t}\n\ttuple->src_port = fk->ports.src;\n\ttuple->dst_port = fk->ports.dst;\n\n\trule->flow_id = flow_id;\n\trule->filter_id = arfs->last_filter_id++ % RPS_NO_FILTER;\n\n\thlist_add_head(&rule->hlist,\n\t\t       arfs_hash_bucket(arfs_t, tuple->src_port,\n\t\t\t\t\ttuple->dst_port));\n\treturn rule;\n}\n\nstatic bool arfs_cmp(const struct arfs_tuple *tuple, const struct flow_keys *fk)\n{\n\tif (tuple->src_port != fk->ports.src || tuple->dst_port != fk->ports.dst)\n\t\treturn false;\n\tif (tuple->etype != fk->basic.n_proto)\n\t\treturn false;\n\tif (tuple->etype == htons(ETH_P_IP))\n\t\treturn tuple->src_ipv4 == fk->addrs.v4addrs.src &&\n\t\t       tuple->dst_ipv4 == fk->addrs.v4addrs.dst;\n\tif (tuple->etype == htons(ETH_P_IPV6))\n\t\treturn !memcmp(&tuple->src_ipv6, &fk->addrs.v6addrs.src,\n\t\t\t       sizeof(struct in6_addr)) &&\n\t\t       !memcmp(&tuple->dst_ipv6, &fk->addrs.v6addrs.dst,\n\t\t\t       sizeof(struct in6_addr));\n\treturn false;\n}\n\nstatic struct arfs_rule *arfs_find_rule(struct arfs_table *arfs_t,\n\t\t\t\t\tconst struct flow_keys *fk)\n{\n\tstruct arfs_rule *arfs_rule;\n\tstruct hlist_head *head;\n\n\thead = arfs_hash_bucket(arfs_t, fk->ports.src, fk->ports.dst);\n\thlist_for_each_entry(arfs_rule, head, hlist) {\n\t\tif (arfs_cmp(&arfs_rule->tuple, fk))\n\t\t\treturn arfs_rule;\n\t}\n\n\treturn NULL;\n}\n\nint mlx5e_rx_flow_steer(struct net_device *dev, const struct sk_buff *skb,\n\t\t\tu16 rxq_index, u32 flow_id)\n{\n\tstruct mlx5e_priv *priv = netdev_priv(dev);\n\tstruct mlx5e_arfs_tables *arfs;\n\tstruct arfs_rule *arfs_rule;\n\tstruct arfs_table *arfs_t;\n\tstruct flow_keys fk;\n\n\tarfs =  mlx5e_fs_get_arfs(priv->fs);\n\tif (!skb_flow_dissect_flow_keys(skb, &fk, 0))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (fk.basic.n_proto != htons(ETH_P_IP) &&\n\t    fk.basic.n_proto != htons(ETH_P_IPV6))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (skb->encapsulation)\n\t\treturn -EPROTONOSUPPORT;\n\n\tarfs_t = arfs_get_table(arfs, fk.basic.ip_proto, fk.basic.n_proto);\n\tif (!arfs_t)\n\t\treturn -EPROTONOSUPPORT;\n\n\tspin_lock_bh(&arfs->arfs_lock);\n\tarfs_rule = arfs_find_rule(arfs_t, &fk);\n\tif (arfs_rule) {\n\t\tif (arfs_rule->rxq == rxq_index || work_busy(&arfs_rule->arfs_work)) {\n\t\t\tspin_unlock_bh(&arfs->arfs_lock);\n\t\t\treturn arfs_rule->filter_id;\n\t\t}\n\n\t\tpriv->channel_stats[rxq_index]->rq.arfs_request_in++;\n\t\tpriv->channel_stats[arfs_rule->rxq]->rq.arfs_request_out++;\n\t\tarfs_rule->rxq = rxq_index;\n\t} else {\n\t\tarfs_rule = arfs_alloc_rule(priv, arfs_t, &fk, rxq_index, flow_id);\n\t\tif (!arfs_rule) {\n\t\t\tspin_unlock_bh(&arfs->arfs_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tqueue_work(arfs->wq, &arfs_rule->arfs_work);\n\tspin_unlock_bh(&arfs->arfs_lock);\n\treturn arfs_rule->filter_id;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}