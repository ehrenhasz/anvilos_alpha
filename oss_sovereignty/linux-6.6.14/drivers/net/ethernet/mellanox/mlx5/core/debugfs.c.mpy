{
  "module_name": "debugfs.c",
  "hash_id": "e9ca3b1252c83e0095318fcc325a939301b2285382b11ecbb33bd3e1f0a94e7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/debugfs.c",
  "human_readable_source": " \n\n#include <linux/debugfs.h>\n#include <linux/mlx5/qp.h>\n#include <linux/mlx5/cq.h>\n#include <linux/mlx5/driver.h>\n#include \"mlx5_core.h\"\n#include \"lib/eq.h\"\n\nenum {\n\tQP_PID,\n\tQP_STATE,\n\tQP_XPORT,\n\tQP_MTU,\n\tQP_N_RECV,\n\tQP_RECV_SZ,\n\tQP_N_SEND,\n\tQP_LOG_PG_SZ,\n\tQP_RQPN,\n};\n\nstatic char *qp_fields[] = {\n\t[QP_PID]\t= \"pid\",\n\t[QP_STATE]\t= \"state\",\n\t[QP_XPORT]\t= \"transport\",\n\t[QP_MTU]\t= \"mtu\",\n\t[QP_N_RECV]\t= \"num_recv\",\n\t[QP_RECV_SZ]\t= \"rcv_wqe_sz\",\n\t[QP_N_SEND]\t= \"num_send\",\n\t[QP_LOG_PG_SZ]\t= \"log2_page_sz\",\n\t[QP_RQPN]\t= \"remote_qpn\",\n};\n\nenum {\n\tEQ_NUM_EQES,\n\tEQ_INTR,\n\tEQ_LOG_PG_SZ,\n};\n\nstatic char *eq_fields[] = {\n\t[EQ_NUM_EQES]\t= \"num_eqes\",\n\t[EQ_INTR]\t= \"intr\",\n\t[EQ_LOG_PG_SZ]\t= \"log_page_size\",\n};\n\nenum {\n\tCQ_PID,\n\tCQ_NUM_CQES,\n\tCQ_LOG_PG_SZ,\n};\n\nstatic char *cq_fields[] = {\n\t[CQ_PID]\t= \"pid\",\n\t[CQ_NUM_CQES]\t= \"num_cqes\",\n\t[CQ_LOG_PG_SZ]\t= \"log_page_size\",\n};\n\nstruct dentry *mlx5_debugfs_root;\nEXPORT_SYMBOL(mlx5_debugfs_root);\n\nvoid mlx5_register_debugfs(void)\n{\n\tmlx5_debugfs_root = debugfs_create_dir(\"mlx5\", NULL);\n}\n\nvoid mlx5_unregister_debugfs(void)\n{\n\tdebugfs_remove(mlx5_debugfs_root);\n}\n\nstruct dentry *mlx5_debugfs_get_dev_root(struct mlx5_core_dev *dev)\n{\n\treturn dev->priv.dbg.dbg_root;\n}\nEXPORT_SYMBOL(mlx5_debugfs_get_dev_root);\n\nvoid mlx5_qp_debugfs_init(struct mlx5_core_dev *dev)\n{\n\tdev->priv.dbg.qp_debugfs = debugfs_create_dir(\"QPs\", dev->priv.dbg.dbg_root);\n}\nEXPORT_SYMBOL(mlx5_qp_debugfs_init);\n\nvoid mlx5_qp_debugfs_cleanup(struct mlx5_core_dev *dev)\n{\n\tdebugfs_remove_recursive(dev->priv.dbg.qp_debugfs);\n}\nEXPORT_SYMBOL(mlx5_qp_debugfs_cleanup);\n\nvoid mlx5_eq_debugfs_init(struct mlx5_core_dev *dev)\n{\n\tdev->priv.dbg.eq_debugfs = debugfs_create_dir(\"EQs\", dev->priv.dbg.dbg_root);\n}\n\nvoid mlx5_eq_debugfs_cleanup(struct mlx5_core_dev *dev)\n{\n\tdebugfs_remove_recursive(dev->priv.dbg.eq_debugfs);\n}\n\nstatic ssize_t average_read(struct file *filp, char __user *buf, size_t count,\n\t\t\t    loff_t *pos)\n{\n\tstruct mlx5_cmd_stats *stats;\n\tu64 field = 0;\n\tint ret;\n\tchar tbuf[22];\n\n\tstats = filp->private_data;\n\tspin_lock_irq(&stats->lock);\n\tif (stats->n)\n\t\tfield = div64_u64(stats->sum, stats->n);\n\tspin_unlock_irq(&stats->lock);\n\tret = snprintf(tbuf, sizeof(tbuf), \"%llu\\n\", field);\n\treturn simple_read_from_buffer(buf, count, pos, tbuf, ret);\n}\n\nstatic ssize_t average_write(struct file *filp, const char __user *buf,\n\t\t\t     size_t count, loff_t *pos)\n{\n\tstruct mlx5_cmd_stats *stats;\n\n\tstats = filp->private_data;\n\tspin_lock_irq(&stats->lock);\n\tstats->sum = 0;\n\tstats->n = 0;\n\tspin_unlock_irq(&stats->lock);\n\n\t*pos += count;\n\n\treturn count;\n}\n\nstatic const struct file_operations stats_fops = {\n\t.owner\t= THIS_MODULE,\n\t.open\t= simple_open,\n\t.read\t= average_read,\n\t.write\t= average_write,\n};\n\nstatic ssize_t slots_read(struct file *filp, char __user *buf, size_t count,\n\t\t\t  loff_t *pos)\n{\n\tstruct mlx5_cmd *cmd;\n\tchar tbuf[6];\n\tint weight;\n\tint field;\n\tint ret;\n\n\tcmd = filp->private_data;\n\tweight = bitmap_weight(&cmd->vars.bitmask, cmd->vars.max_reg_cmds);\n\tfield = cmd->vars.max_reg_cmds - weight;\n\tret = snprintf(tbuf, sizeof(tbuf), \"%d\\n\", field);\n\treturn simple_read_from_buffer(buf, count, pos, tbuf, ret);\n}\n\nstatic const struct file_operations slots_fops = {\n\t.owner\t= THIS_MODULE,\n\t.open\t= simple_open,\n\t.read\t= slots_read,\n};\n\nstatic struct mlx5_cmd_stats *\nmlx5_cmdif_alloc_stats(struct xarray *stats_xa, int opcode)\n{\n\tstruct mlx5_cmd_stats *stats = kzalloc(sizeof(*stats), GFP_KERNEL);\n\tint err;\n\n\tif (!stats)\n\t\treturn NULL;\n\n\terr = xa_insert(stats_xa, opcode, stats, GFP_KERNEL);\n\tif (err) {\n\t\tkfree(stats);\n\t\treturn NULL;\n\t}\n\tspin_lock_init(&stats->lock);\n\treturn stats;\n}\n\nvoid mlx5_cmdif_debugfs_init(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_cmd_stats *stats;\n\tstruct dentry **cmd;\n\tconst char *namep;\n\tint i;\n\n\tcmd = &dev->priv.dbg.cmdif_debugfs;\n\t*cmd = debugfs_create_dir(\"commands\", dev->priv.dbg.dbg_root);\n\n\tdebugfs_create_file(\"slots_inuse\", 0400, *cmd, &dev->cmd, &slots_fops);\n\n\txa_init(&dev->cmd.stats);\n\n\tfor (i = 0; i < MLX5_CMD_OP_MAX; i++) {\n\t\tnamep = mlx5_command_str(i);\n\t\tif (strcmp(namep, \"unknown command opcode\")) {\n\t\t\tstats = mlx5_cmdif_alloc_stats(&dev->cmd.stats, i);\n\t\t\tif (!stats)\n\t\t\t\tcontinue;\n\t\t\tstats->root = debugfs_create_dir(namep, *cmd);\n\n\t\t\tdebugfs_create_file(\"average\", 0400, stats->root, stats,\n\t\t\t\t\t    &stats_fops);\n\t\t\tdebugfs_create_u64(\"n\", 0400, stats->root, &stats->n);\n\t\t\tdebugfs_create_u64(\"failed\", 0400, stats->root, &stats->failed);\n\t\t\tdebugfs_create_u64(\"failed_mbox_status\", 0400, stats->root,\n\t\t\t\t\t   &stats->failed_mbox_status);\n\t\t\tdebugfs_create_u32(\"last_failed_errno\", 0400, stats->root,\n\t\t\t\t\t   &stats->last_failed_errno);\n\t\t\tdebugfs_create_u8(\"last_failed_mbox_status\", 0400, stats->root,\n\t\t\t\t\t  &stats->last_failed_mbox_status);\n\t\t\tdebugfs_create_x32(\"last_failed_syndrome\", 0400, stats->root,\n\t\t\t\t\t   &stats->last_failed_syndrome);\n\t\t}\n\t}\n}\n\nvoid mlx5_cmdif_debugfs_cleanup(struct mlx5_core_dev *dev)\n{\n\tstruct mlx5_cmd_stats *stats;\n\tunsigned long i;\n\n\tdebugfs_remove_recursive(dev->priv.dbg.cmdif_debugfs);\n\txa_for_each(&dev->cmd.stats, i, stats)\n\t\tkfree(stats);\n\txa_destroy(&dev->cmd.stats);\n}\n\nvoid mlx5_cq_debugfs_init(struct mlx5_core_dev *dev)\n{\n\tdev->priv.dbg.cq_debugfs = debugfs_create_dir(\"CQs\", dev->priv.dbg.dbg_root);\n}\n\nvoid mlx5_cq_debugfs_cleanup(struct mlx5_core_dev *dev)\n{\n\tdebugfs_remove_recursive(dev->priv.dbg.cq_debugfs);\n}\n\nvoid mlx5_pages_debugfs_init(struct mlx5_core_dev *dev)\n{\n\tstruct dentry *pages;\n\n\tdev->priv.dbg.pages_debugfs = debugfs_create_dir(\"pages\", dev->priv.dbg.dbg_root);\n\tpages = dev->priv.dbg.pages_debugfs;\n\n\tdebugfs_create_u32(\"fw_pages_total\", 0400, pages, &dev->priv.fw_pages);\n\tdebugfs_create_u32(\"fw_pages_vfs\", 0400, pages, &dev->priv.page_counters[MLX5_VF]);\n\tdebugfs_create_u32(\"fw_pages_ec_vfs\", 0400, pages, &dev->priv.page_counters[MLX5_EC_VF]);\n\tdebugfs_create_u32(\"fw_pages_sfs\", 0400, pages, &dev->priv.page_counters[MLX5_SF]);\n\tdebugfs_create_u32(\"fw_pages_host_pf\", 0400, pages, &dev->priv.page_counters[MLX5_HOST_PF]);\n\tdebugfs_create_u32(\"fw_pages_alloc_failed\", 0400, pages, &dev->priv.fw_pages_alloc_failed);\n\tdebugfs_create_u32(\"fw_pages_give_dropped\", 0400, pages, &dev->priv.give_pages_dropped);\n\tdebugfs_create_u32(\"fw_pages_reclaim_discard\", 0400, pages,\n\t\t\t   &dev->priv.reclaim_pages_discard);\n}\n\nvoid mlx5_pages_debugfs_cleanup(struct mlx5_core_dev *dev)\n{\n\tdebugfs_remove_recursive(dev->priv.dbg.pages_debugfs);\n}\n\nstatic u64 qp_read_field(struct mlx5_core_dev *dev, struct mlx5_core_qp *qp,\n\t\t\t int index, int *is_str)\n{\n\tint outlen = MLX5_ST_SZ_BYTES(query_qp_out);\n\tu32 in[MLX5_ST_SZ_DW(query_qp_in)] = {};\n\tu64 param = 0;\n\tu32 *out;\n\tint state;\n\tu32 *qpc;\n\tint err;\n\n\tout = kzalloc(outlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn 0;\n\n\tMLX5_SET(query_qp_in, in, opcode, MLX5_CMD_OP_QUERY_QP);\n\tMLX5_SET(query_qp_in, in, qpn, qp->qpn);\n\terr = mlx5_cmd_exec_inout(dev, query_qp, in, out);\n\tif (err)\n\t\tgoto out;\n\n\t*is_str = 0;\n\n\tqpc = MLX5_ADDR_OF(query_qp_out, out, qpc);\n\tswitch (index) {\n\tcase QP_PID:\n\t\tparam = qp->pid;\n\t\tbreak;\n\tcase QP_STATE:\n\t\tstate = MLX5_GET(qpc, qpc, state);\n\t\tparam = (unsigned long)mlx5_qp_state_str(state);\n\t\t*is_str = 1;\n\t\tbreak;\n\tcase QP_XPORT:\n\t\tparam = (unsigned long)mlx5_qp_type_str(MLX5_GET(qpc, qpc, st));\n\t\t*is_str = 1;\n\t\tbreak;\n\tcase QP_MTU:\n\t\tswitch (MLX5_GET(qpc, qpc, mtu)) {\n\t\tcase IB_MTU_256:\n\t\t\tparam = 256;\n\t\t\tbreak;\n\t\tcase IB_MTU_512:\n\t\t\tparam = 512;\n\t\t\tbreak;\n\t\tcase IB_MTU_1024:\n\t\t\tparam = 1024;\n\t\t\tbreak;\n\t\tcase IB_MTU_2048:\n\t\t\tparam = 2048;\n\t\t\tbreak;\n\t\tcase IB_MTU_4096:\n\t\t\tparam = 4096;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparam = 0;\n\t\t}\n\t\tbreak;\n\tcase QP_N_RECV:\n\t\tparam = 1 << MLX5_GET(qpc, qpc, log_rq_size);\n\t\tbreak;\n\tcase QP_RECV_SZ:\n\t\tparam = 1 << (MLX5_GET(qpc, qpc, log_rq_stride) + 4);\n\t\tbreak;\n\tcase QP_N_SEND:\n\t\tif (!MLX5_GET(qpc, qpc, no_sq))\n\t\t\tparam = 1 << MLX5_GET(qpc, qpc, log_sq_size);\n\t\tbreak;\n\tcase QP_LOG_PG_SZ:\n\t\tparam = MLX5_GET(qpc, qpc, log_page_size) + 12;\n\t\tbreak;\n\tcase QP_RQPN:\n\t\tparam = MLX5_GET(qpc, qpc, remote_qpn);\n\t\tbreak;\n\t}\nout:\n\tkfree(out);\n\treturn param;\n}\n\nstatic u64 eq_read_field(struct mlx5_core_dev *dev, struct mlx5_eq *eq,\n\t\t\t int index)\n{\n\tint outlen = MLX5_ST_SZ_BYTES(query_eq_out);\n\tu32 in[MLX5_ST_SZ_DW(query_eq_in)] = {};\n\tu64 param = 0;\n\tvoid *ctx;\n\tu32 *out;\n\tint err;\n\n\tout = kzalloc(outlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn param;\n\n\tMLX5_SET(query_eq_in, in, opcode, MLX5_CMD_OP_QUERY_EQ);\n\tMLX5_SET(query_eq_in, in, eq_number, eq->eqn);\n\terr = mlx5_cmd_exec_inout(dev, query_eq, in, out);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"failed to query eq\\n\");\n\t\tgoto out;\n\t}\n\tctx = MLX5_ADDR_OF(query_eq_out, out, eq_context_entry);\n\n\tswitch (index) {\n\tcase EQ_NUM_EQES:\n\t\tparam = 1 << MLX5_GET(eqc, ctx, log_eq_size);\n\t\tbreak;\n\tcase EQ_INTR:\n\t\tparam = MLX5_GET(eqc, ctx, intr);\n\t\tbreak;\n\tcase EQ_LOG_PG_SZ:\n\t\tparam = MLX5_GET(eqc, ctx, log_page_size) + 12;\n\t\tbreak;\n\t}\n\nout:\n\tkfree(out);\n\treturn param;\n}\n\nstatic u64 cq_read_field(struct mlx5_core_dev *dev, struct mlx5_core_cq *cq,\n\t\t\t int index)\n{\n\tint outlen = MLX5_ST_SZ_BYTES(query_cq_out);\n\tu64 param = 0;\n\tvoid *ctx;\n\tu32 *out;\n\tint err;\n\n\tout = kvzalloc(outlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn param;\n\n\terr = mlx5_core_query_cq(dev, cq, out);\n\tif (err) {\n\t\tmlx5_core_warn(dev, \"failed to query cq\\n\");\n\t\tgoto out;\n\t}\n\tctx = MLX5_ADDR_OF(query_cq_out, out, cq_context);\n\n\tswitch (index) {\n\tcase CQ_PID:\n\t\tparam = cq->pid;\n\t\tbreak;\n\tcase CQ_NUM_CQES:\n\t\tparam = 1 << MLX5_GET(cqc, ctx, log_cq_size);\n\t\tbreak;\n\tcase CQ_LOG_PG_SZ:\n\t\tparam = MLX5_GET(cqc, ctx, log_page_size);\n\t\tbreak;\n\t}\n\nout:\n\tkvfree(out);\n\treturn param;\n}\n\nstatic ssize_t dbg_read(struct file *filp, char __user *buf, size_t count,\n\t\t\tloff_t *pos)\n{\n\tstruct mlx5_field_desc *desc;\n\tstruct mlx5_rsc_debug *d;\n\tchar tbuf[18];\n\tint is_str = 0;\n\tu64 field;\n\tint ret;\n\n\tdesc = filp->private_data;\n\td = (void *)(desc - desc->i) - sizeof(*d);\n\tswitch (d->type) {\n\tcase MLX5_DBG_RSC_QP:\n\t\tfield = qp_read_field(d->dev, d->object, desc->i, &is_str);\n\t\tbreak;\n\n\tcase MLX5_DBG_RSC_EQ:\n\t\tfield = eq_read_field(d->dev, d->object, desc->i);\n\t\tbreak;\n\n\tcase MLX5_DBG_RSC_CQ:\n\t\tfield = cq_read_field(d->dev, d->object, desc->i);\n\t\tbreak;\n\n\tdefault:\n\t\tmlx5_core_warn(d->dev, \"invalid resource type %d\\n\", d->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_str)\n\t\tret = snprintf(tbuf, sizeof(tbuf), \"%s\\n\", (const char *)(unsigned long)field);\n\telse\n\t\tret = snprintf(tbuf, sizeof(tbuf), \"0x%llx\\n\", field);\n\n\treturn simple_read_from_buffer(buf, count, pos, tbuf, ret);\n}\n\nstatic const struct file_operations fops = {\n\t.owner\t= THIS_MODULE,\n\t.open\t= simple_open,\n\t.read\t= dbg_read,\n};\n\nstatic int add_res_tree(struct mlx5_core_dev *dev, enum dbg_rsc_type type,\n\t\t\tstruct dentry *root, struct mlx5_rsc_debug **dbg,\n\t\t\tint rsn, char **field, int nfile, void *data)\n{\n\tstruct mlx5_rsc_debug *d;\n\tchar resn[32];\n\tint i;\n\n\td = kzalloc(struct_size(d, fields, nfile), GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\td->dev = dev;\n\td->object = data;\n\td->type = type;\n\tsprintf(resn, \"0x%x\", rsn);\n\td->root = debugfs_create_dir(resn,  root);\n\n\tfor (i = 0; i < nfile; i++) {\n\t\td->fields[i].i = i;\n\t\tdebugfs_create_file(field[i], 0400, d->root, &d->fields[i],\n\t\t\t\t    &fops);\n\t}\n\t*dbg = d;\n\n\treturn 0;\n}\n\nstatic void rem_res_tree(struct mlx5_rsc_debug *d)\n{\n\tdebugfs_remove_recursive(d->root);\n\tkfree(d);\n}\n\nint mlx5_debug_qp_add(struct mlx5_core_dev *dev, struct mlx5_core_qp *qp)\n{\n\tint err;\n\n\tif (!mlx5_debugfs_root)\n\t\treturn 0;\n\n\terr = add_res_tree(dev, MLX5_DBG_RSC_QP, dev->priv.dbg.qp_debugfs,\n\t\t\t   &qp->dbg, qp->qpn, qp_fields,\n\t\t\t   ARRAY_SIZE(qp_fields), qp);\n\tif (err)\n\t\tqp->dbg = NULL;\n\n\treturn err;\n}\nEXPORT_SYMBOL(mlx5_debug_qp_add);\n\nvoid mlx5_debug_qp_remove(struct mlx5_core_dev *dev, struct mlx5_core_qp *qp)\n{\n\tif (!mlx5_debugfs_root || !qp->dbg)\n\t\treturn;\n\n\trem_res_tree(qp->dbg);\n\tqp->dbg = NULL;\n}\nEXPORT_SYMBOL(mlx5_debug_qp_remove);\n\nint mlx5_debug_eq_add(struct mlx5_core_dev *dev, struct mlx5_eq *eq)\n{\n\tint err;\n\n\tif (!mlx5_debugfs_root)\n\t\treturn 0;\n\n\terr = add_res_tree(dev, MLX5_DBG_RSC_EQ, dev->priv.dbg.eq_debugfs,\n\t\t\t   &eq->dbg, eq->eqn, eq_fields,\n\t\t\t   ARRAY_SIZE(eq_fields), eq);\n\tif (err)\n\t\teq->dbg = NULL;\n\n\treturn err;\n}\n\nvoid mlx5_debug_eq_remove(struct mlx5_core_dev *dev, struct mlx5_eq *eq)\n{\n\tif (!mlx5_debugfs_root)\n\t\treturn;\n\n\tif (eq->dbg)\n\t\trem_res_tree(eq->dbg);\n}\n\nint mlx5_debug_cq_add(struct mlx5_core_dev *dev, struct mlx5_core_cq *cq)\n{\n\tint err;\n\n\tif (!mlx5_debugfs_root)\n\t\treturn 0;\n\n\terr = add_res_tree(dev, MLX5_DBG_RSC_CQ, dev->priv.dbg.cq_debugfs,\n\t\t\t   &cq->dbg, cq->cqn, cq_fields,\n\t\t\t   ARRAY_SIZE(cq_fields), cq);\n\tif (err)\n\t\tcq->dbg = NULL;\n\n\treturn err;\n}\n\nvoid mlx5_debug_cq_remove(struct mlx5_core_dev *dev, struct mlx5_core_cq *cq)\n{\n\tif (!mlx5_debugfs_root)\n\t\treturn;\n\n\tif (cq->dbg) {\n\t\trem_res_tree(cq->dbg);\n\t\tcq->dbg = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}