{
  "module_name": "ethtool.c",
  "hash_id": "ce5cd21ea6c4f632a86893fd0fe9dd7ec76a9e92a5881c363ee5ff67d1963f1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ethtool.c",
  "human_readable_source": " \n\n#include \"en.h\"\n#include \"ipoib.h\"\n#include \"en/fs_ethtool.h\"\n\nstatic void mlx5i_get_drvinfo(struct net_device *dev,\n\t\t\t      struct ethtool_drvinfo *drvinfo)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(dev);\n\n\tmlx5e_ethtool_get_drvinfo(priv, drvinfo);\n\tstrscpy(drvinfo->driver, KBUILD_MODNAME \"[ib_ipoib]\",\n\t\tsizeof(drvinfo->driver));\n}\n\nstatic void mlx5i_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tstruct mlx5e_priv *priv  = mlx5i_epriv(dev);\n\n\tmlx5e_ethtool_get_strings(priv, stringset, data);\n}\n\nstatic int mlx5i_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(dev);\n\n\treturn mlx5e_ethtool_get_sset_count(priv, sset);\n}\n\nstatic void mlx5i_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t    struct ethtool_stats *stats,\n\t\t\t\t    u64 *data)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(dev);\n\n\tmlx5e_ethtool_get_ethtool_stats(priv, stats, data);\n}\n\nstatic int mlx5i_set_ringparam(struct net_device *dev,\n\t\t\t       struct ethtool_ringparam *param,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_param,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(dev);\n\n\treturn mlx5e_ethtool_set_ringparam(priv, param);\n}\n\nstatic void mlx5i_get_ringparam(struct net_device *dev,\n\t\t\t\tstruct ethtool_ringparam *param,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_param,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(dev);\n\n\tmlx5e_ethtool_get_ringparam(priv, param, kernel_param);\n}\n\nstatic int mlx5i_set_channels(struct net_device *dev,\n\t\t\t      struct ethtool_channels *ch)\n{\n\tstruct mlx5i_priv *ipriv = netdev_priv(dev);\n\tstruct mlx5e_priv *epriv = mlx5i_epriv(dev);\n\n\t \n\tASSERT_RTNL();\n\tif (ipriv->num_sub_interfaces > 0) {\n\t\tmlx5_core_warn(epriv->mdev,\n\t\t\t       \"can't change number of channels for interfaces with sub interfaces (%u)\\n\",\n\t\t\t       ipriv->num_sub_interfaces);\n\t\treturn -EINVAL;\n\t}\n\n\treturn mlx5e_ethtool_set_channels(epriv, ch);\n}\n\nstatic void mlx5i_get_channels(struct net_device *dev,\n\t\t\t       struct ethtool_channels *ch)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(dev);\n\n\tmlx5e_ethtool_get_channels(priv, ch);\n}\n\nstatic int mlx5i_set_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *coal,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(netdev);\n\n\treturn mlx5e_ethtool_set_coalesce(priv, coal, kernel_coal, extack);\n}\n\nstatic int mlx5i_get_coalesce(struct net_device *netdev,\n\t\t\t      struct ethtool_coalesce *coal,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(netdev);\n\n\treturn mlx5e_ethtool_get_coalesce(priv, coal, kernel_coal);\n}\n\nstatic int mlx5i_get_ts_info(struct net_device *netdev,\n\t\t\t     struct ethtool_ts_info *info)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(netdev);\n\n\treturn mlx5e_ethtool_get_ts_info(priv, info);\n}\n\nstatic int mlx5i_flash_device(struct net_device *netdev,\n\t\t\t      struct ethtool_flash *flash)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(netdev);\n\n\treturn mlx5e_ethtool_flash_device(priv, flash);\n}\n\nstatic inline int mlx5_ptys_width_enum_to_int(enum mlx5_ptys_width width)\n{\n\tswitch (width) {\n\tcase MLX5_PTYS_WIDTH_1X:  return  1;\n\tcase MLX5_PTYS_WIDTH_2X:  return  2;\n\tcase MLX5_PTYS_WIDTH_4X:  return  4;\n\tcase MLX5_PTYS_WIDTH_8X:  return  8;\n\tcase MLX5_PTYS_WIDTH_12X: return 12;\n\tdefault:\t\t  return -1;\n\t}\n}\n\nenum mlx5_ptys_rate {\n\tMLX5_PTYS_RATE_SDR\t= 1 << 0,\n\tMLX5_PTYS_RATE_DDR\t= 1 << 1,\n\tMLX5_PTYS_RATE_QDR\t= 1 << 2,\n\tMLX5_PTYS_RATE_FDR10\t= 1 << 3,\n\tMLX5_PTYS_RATE_FDR\t= 1 << 4,\n\tMLX5_PTYS_RATE_EDR\t= 1 << 5,\n\tMLX5_PTYS_RATE_HDR\t= 1 << 6,\n\tMLX5_PTYS_RATE_NDR\t= 1 << 7,\n\tMLX5_PTYS_RATE_XDR\t= 1 << 8,\n};\n\nstatic inline int mlx5_ptys_rate_enum_to_int(enum mlx5_ptys_rate rate)\n{\n\tswitch (rate) {\n\tcase MLX5_PTYS_RATE_SDR:   return 2500;\n\tcase MLX5_PTYS_RATE_DDR:   return 5000;\n\tcase MLX5_PTYS_RATE_QDR:\n\tcase MLX5_PTYS_RATE_FDR10: return 10000;\n\tcase MLX5_PTYS_RATE_FDR:   return 14000;\n\tcase MLX5_PTYS_RATE_EDR:   return 25000;\n\tcase MLX5_PTYS_RATE_HDR:   return 50000;\n\tcase MLX5_PTYS_RATE_NDR:   return 100000;\n\tcase MLX5_PTYS_RATE_XDR:   return 200000;\n\tdefault:\t\t   return -1;\n\t}\n}\n\nstatic u32 mlx5i_get_speed_settings(u16 ib_link_width_oper, u16 ib_proto_oper)\n{\n\tint rate, width;\n\n\trate = mlx5_ptys_rate_enum_to_int(ib_proto_oper);\n\tif (rate < 0)\n\t\treturn SPEED_UNKNOWN;\n\twidth = mlx5_ptys_width_enum_to_int(ib_link_width_oper);\n\tif (width < 0)\n\t\treturn SPEED_UNKNOWN;\n\n\treturn rate * width;\n}\n\nstatic int mlx5i_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t    struct ethtool_link_ksettings *link_ksettings)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(netdev);\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tu16 ib_link_width_oper;\n\tu16 ib_proto_oper;\n\tint speed, ret;\n\n\tret = mlx5_query_ib_port_oper(mdev, &ib_link_width_oper, &ib_proto_oper,\n\t\t\t\t      1);\n\tif (ret)\n\t\treturn ret;\n\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, supported);\n\tethtool_link_ksettings_zero_link_mode(link_ksettings, advertising);\n\n\tspeed = mlx5i_get_speed_settings(ib_link_width_oper, ib_proto_oper);\n\tlink_ksettings->base.speed = speed;\n\tlink_ksettings->base.duplex = speed == SPEED_UNKNOWN ? DUPLEX_UNKNOWN : DUPLEX_FULL;\n\n\tlink_ksettings->base.port = PORT_OTHER;\n\n\tlink_ksettings->base.autoneg = AUTONEG_DISABLE;\n\n\treturn 0;\n}\n\nstatic u32 mlx5i_flow_type_mask(u32 flow_type)\n{\n\treturn flow_type & ~(FLOW_EXT | FLOW_MAC_EXT | FLOW_RSS);\n}\n\nstatic int mlx5i_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(dev);\n\tstruct ethtool_rx_flow_spec *fs = &cmd->fs;\n\n\tif (mlx5i_flow_type_mask(fs->flow_type) == ETHER_FLOW)\n\t\treturn -EINVAL;\n\n\treturn mlx5e_ethtool_set_rxnfc(priv, cmd);\n}\n\nstatic int mlx5i_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,\n\t\t\t   u32 *rule_locs)\n{\n\tstruct mlx5e_priv *priv = mlx5i_epriv(dev);\n\n\t \n\tif (info->cmd == ETHTOOL_GRXRINGS) {\n\t\tinfo->data = priv->channels.params.num_channels;\n\t\treturn 0;\n\t}\n\n\treturn mlx5e_ethtool_get_rxnfc(priv, info, rule_locs);\n}\n\nconst struct ethtool_ops mlx5i_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE,\n\t.get_drvinfo        = mlx5i_get_drvinfo,\n\t.get_strings        = mlx5i_get_strings,\n\t.get_sset_count     = mlx5i_get_sset_count,\n\t.get_ethtool_stats  = mlx5i_get_ethtool_stats,\n\t.get_ringparam      = mlx5i_get_ringparam,\n\t.set_ringparam      = mlx5i_set_ringparam,\n\t.flash_device       = mlx5i_flash_device,\n\t.get_channels       = mlx5i_get_channels,\n\t.set_channels       = mlx5i_set_channels,\n\t.get_coalesce       = mlx5i_get_coalesce,\n\t.set_coalesce       = mlx5i_set_coalesce,\n\t.get_ts_info        = mlx5i_get_ts_info,\n\t.get_rxnfc          = mlx5i_get_rxnfc,\n\t.set_rxnfc          = mlx5i_set_rxnfc,\n\t.get_link_ksettings = mlx5i_get_link_ksettings,\n\t.get_link           = ethtool_op_get_link,\n};\n\nconst struct ethtool_ops mlx5i_pkey_ethtool_ops = {\n\t.get_drvinfo        = mlx5i_get_drvinfo,\n\t.get_link           = ethtool_op_get_link,\n\t.get_ts_info        = mlx5i_get_ts_info,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}